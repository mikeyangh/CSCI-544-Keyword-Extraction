Page1一种面向有环兴趣路径的过程内剖析方法王璐璐李必信(东南大学计算机科学与工程学院南京211189)(东南大学软件工程研究所南京211189)摘要路径剖析技术用于获取和分析程序中各条路径的执行次数.路径剖析采用在待剖析程序中插装探针的方式以跟踪执行,并使用对路径进行编码的方式以高效地获取剖析结果.选择性剖析是针对用户感兴趣的一部分路径,在非选择性剖析技术的基础上进行优化,以尽可能低的耗费来完成剖析.现有的选择性剖析技术采用的优化措施局限于减少探针数目和压缩路径编码空间,而且其允许的用户兴趣路径局限于无环路径.文中提出了一种新的选择性剖析方法PSP(ProfilingSelectedPaths),可以精确的剖析带有循环的兴趣路径,并使用了在执行过程中对非兴趣路径进行检测和提前终止的技术来降低耗费.理论分析和实验评估表明PSP方法能够精确地剖析兴趣路径,并使用兴趣路径来提升剖析效率.关键词路径剖析;兴趣路径;动态分析;软件测试1引言个待剖析程序,当该程序被多次执行之后,给出这些执行的各条路径及每条路径的执行频率.路径剖析与边的剖析(edgeprofiling)和基本块剖析(block路径剖析(pathprofiling)的目标在于:给定一profiling)相比,能够提供对程序动态行为更为精确Page2的描述.这种描述的信息能够广泛地应用于多个领域,如调试、测试和程序理解[1-2]、路径敏感代码的优化[3-7]、指令调度[8-11]、代码布局优化[12]以及静态分支预测的改进[13-14].为了获知执行路径及其频率,剖析方法在目标程序中插装探针(probe),在程序的执行过程中收集执行信息.而且由于侧重于路径的频率(少数路径可能执行很多次),从效率的角度出发,需要对路径进行编码(pathid),使用整数来表示路径,以便高效的进行路径比较和执行次数统计.这样路径剖析技术在待剖析程序的执行中通过探针变量的运算来计算路径编码,并在每次执行完毕后,使用探针变量的值来唯一地确定所执行的路径编码.剖析结果的精确性要求剖析方法对每条可剖析路径的编码是唯一的.现有的剖析技术可以分为两类:过程内剖析和过程间剖析,分别应用在单过程和多过程的场景下.过程内剖析技术可以进一步分为选择性剖析和非选择性剖析,其中选择性剖析使用较低的耗费获取兴趣路径的执行频率,而非选择性剖析处理所有的可剖析路径.在实际应用中,剖析结果的使用者往往仅对部分的路径频率感兴趣[15],例如在程序调试中,编程人员可能需要比对特定的执行;软件测试中,测试者可能需要统计测试用在特定路径上的覆盖;程序理解中,编程人员可能更侧重于某些关键路径等.注意到在这些应用中,用户感兴趣的路径不局限于无环路径.针对这些情况,选择性剖析方法在剖析之前,接受一个基于用户需求提供的兴趣路径集合PI(PathsofInterest),相应地,其他路径组成集合PN(PathsNotofinterest).PI路径的执行频率是选择性剖析的目标.现有的选择性剖析方法存在两个关键问题:如何从路径的选择性剖析(即忽略PN路径的剖析)中获益;如何处理PI中的循环路径(即保证有环情况下每条路径编码的唯一性).前者,现有的方法主要采用两种方式来提高剖析效率:减少探针数目[16]和压缩路径编码空间[15]以优化存储效率;后者,现有方法仅接受无环路径作为兴趣路径.本文针对这两个问题分别提出了在执行过程中对非兴趣路径进行检测和提前终止的技术来降低耗费;基于一种能够保证有环路径唯一编码的非选择性剖析方法PAP(ProfilingAllPaths)[17]来设计本文中的选择性剖析方法.EPP(EfficientPathProfiling)[18]是一种过程内非选择性剖析方法,能够保证无环CFG(ControlFlowGraph)上每条路径的精确剖析.这种方法首先在CFG无环路径之上;执行,导致不必要的耗费;的边上分布权值,无环路径的编码等同于该路径上所有边的权值之和.基于EPP,研究人员提出了两种选择性剖析方法,SPP(SelectivePathProfiling[16])和PrePP(PreferentialPathProfiling)[15].二者的区别在于,SPP对于兴趣路径中的边分配较大的权值,以达到降低非兴趣路径编码的目的;PrePP对于兴趣路径中的边分配较低的权值,以压缩兴趣路径的编码,能够使用数组而非链表进行存储,以提升效率.但是这两种方法存在如下问题:(1)不能处理有环路径,故用户兴趣被局限于(2)缺乏PN的检测,故不能避免PN路径的(3)不能保证PI路径编码在所有路径编码中的唯一性,故可能导致不精确的剖析结果.为了达到有环路径的精确选择性剖析,本文提出了一种新的方法PSP(ProfilingSelectedPaths),如果在执行过程中发现当前执行的路径属于PN,则将其提前结束,以节约耗费.在如下的章节中,我们按照如下的顺序对PSP方法进行说明:首先,把SPP改进为ESPP(EnhancedSPP),可以保证无环情况下PI路径的唯一编码,达到无环CFG上的精确选择性剖析.其次,提出3种执行中的PN路径检测技术,能够在程序执行中检测出大量的PN路径,以提前结束执行,节约耗费.基于这3种检测技术及其组合,给出有环情况下的过程内精确剖析方法PSP及其4种实现方式(PSP0~PSP3),这4种方式均可对有环路径进行选择性剖析,并具有不同的成本效益.最后,从理论和实验两个方面对PSP的4种实现方式进行对比,找出优缺点和适用对象,并通过与相关工作的比较来检验其有效性.本文第2节介绍预备知识;第3节首先讨论如何将SPP改进为ESPP,并将之应用与无环子图的选择性剖析中,然后论述了3种路径检测技术和4种PSP实现方式;第4节给出了实验评估和比较;第5节总结了相关工作.而第6节是总结与展望.2预备知识本节首先定义了一些基本术语(部分术语已在相关文献中定义),然后介绍了EPP、SPP和PrePP的基本思想,以便于理解PSP的思想,最后介绍了PAP及其在无环子图上的应用,基于此,PSP可以Page3处理有环的兴趣路径.2.1基本术语非循环路径剖析算法主要应用于DAG(DirectedAcyclicGraph),本文主要关注于有环CFG,故某些已有的术语需要修改定义,并需要一些新的术语.PI(PathsofInterest):表示兴趣路径集合[16].EI(EdgesofInterest):表示兴趣边集合,即PI路径所包含的边[16].NI(NodesofInterest):表示PI路径所包含的节点(或基本块)集合.PN(PathsNotofinterest):表示所有不包含于PI集合的路径.NN(NodesNotofinterest):表示非兴趣节点集合,即所有不包含于NI的节点.BE(BoundaryEdges):表示边界边集合,其中的边不属于EI且源节点属于NI.NE(iNvalidEdges):表示无效边集合,其中的边不属于EI且源节点属于NN.Pathid:表示路径编码,即路径末端的探针变量值(该定义泛化了文献[15]中使用边权值之和对路径编码的定义).LocalPathid:表示局部(路径)编码.在程序的某个子图中的路径编码.TempPathid:表示临时(路径)编码.在程序执行过程中的某一位置,已执行的路径部分的编码.2.2EPPEPP[18]使用一个整型变量(假设为r)来进行探针运算和路径编码.在EPP中,DAG中的每条边分配一个整数(可能为正、负或者零),当程序运行中执行了非零权值的边时,依据该权值探针变量相应地增减,每条非循环路径的编码就是该路径中所有边的权值之和.EPP的权值分配算法(Ball-Larus算法,简称BL算法)可以保证每条非循环路径具有唯一的整数编码,如算法1所示.算法1.BL算法.输入:G待剖析DAG输出:Val(e)图G中每条边e的权值FOREACHvertexvinreversetopologicalorderDOIFvisaleafvertexTHENENDELSEENDEPP在DAG的边上所插装的探针使用的形式为r=r+i,其中i即为相应边的权值.算法1的主要思想在于,对于一个多出边的节点,调整各条出边上的权值保证执行每条出边的路径的pathid属于不同的整数区间.图1(a)显示了EPP计算权值的方式(Na表示节点a的NumPaths值).对于节点a,其NumPaths值通过累加各个子节点的NumPaths值进行计算,最终的结果等同于其所有子节点的NumPaths值之和,即经过a的所有路径总数.对于a的每条出边,该边的权值等同于当前的Na,而后将该出边所指向节点的NumPaths值加入Na.按照这种方式分配的权值即可保证每条路径对应不同的pathid.由于BL算法需要在DAG上执行,故在处理有环CFG时需要先将其转化为DAG.EPP采用的处理方式是:对于每条回边,使用两条虚拟的边(一条从CFG入口指向回边的目标节点,一条从回边的源节点指向CFG出口)来代替,如图2中(a)和(b)所示.其中的回边GD由边AD和GH代替.这样转化后的CFG中不再含有循环,相应地,不再剖析执行过回边的路径.Page42.3SPPSPP将EPP扩展到选择性剖析之中,利用兴趣路径来降低剖析的耗费.针对待剖析的DAG和其上的兴趣路径集合,SPP按照如下步骤进行:1.对DAG中的边分配权值,SPP与EPP的区别在于,在处理某个节点的多条出边时,各条边按照先计算非EI边、后计算EI边的顺序进行,以保证EI边的权值较大,进而保证PI路径的pathid较大(如图3(a)所示,粗线表示EI边);2.对单入边节点,其入边上的非零权值转移到其所有的出边上,这样在保证每条路径pathid不变的情况下,EI边上的非零权值数目尽可能的少(如图3(b)所示,图8(a)给出了更一般的表示);3.删除非EI边上的权值,如图3(c)所示.这样在保证PI路径的pathid不变的情况下,减小PN路径的pathid并减少探针数目.由于步骤1使得PI路径的pathid较大,故此项操作之后,PN路径的pathid减小,而不会影响PI路径编码的唯一性(PN路径的编码可能不再唯一).实际上,这种方法的正确性存在问题,因为路径的编码是由边的权值之和所决定,而PN路径也可能包含某些权值较大的EI边,步骤1中仅由EI边具有较大的权值并不能保证PI路径具有较大的pathid.例如图3(c)所示,假设图中有两条兴趣路径ADH和ABDEGH,在删除边FG上的权值之和,非兴趣路径ADEFGH与兴趣路径ADH的pathid都等于6,这样的编码冲突就会导致不精确的剖析结果.为了修正该问题,本文在SPP步骤3的删除探针之前添加了PI路径pathid唯一性的检查,避免了对某些必要探针的删除,达到了DAG上精确的选择性剖析.详见3.1节.2.4PrePP在路径剖析中,由于静态路径总数随着路径长度呈指数增长,路径编码往往较大,如果超过数组下标长度(65535)的限制,则需要使用链表代替数组进行路径频率的存储.由于链表的存储效率远低于数组的存储效率,这种代替会明显降低剖析效率.在选择性剖析中,与大量的静态路径相比,用户的兴趣路径可能并不多,故而若能将兴趣路径的编码压缩到数组下标长度限制之内,就可以避免使用链表带来的效率降低.基于此,PrePP[15]的目标就在于为PI路径提供较为紧凑的编码,该方法同时保证PI路径的pathid互不冲突,但是PI路径和PN路径的编码可能冲突,这就可能引起不精确的剖析结果.PrePP算法的思想在于,使用NumPaths计算边的权值时,NumPaths仅统计经由每条出边的兴趣路径总数而非静态路径总数,这样边的权值很小,故而能够压缩路径编码空间,提高存储效率.2.5PAPEPP剖析对象局限于无环路径,但是有环路径广泛存在于实际应用中.为了突破这一限制,研究人员主要采用两种方式:其一是沿用使用加法进行探针变量运算的方式,而通过增加逻辑控制变量来记录回边的执行情况,并且在不同的执行情况下,对每条边采用不同的权值,以达到在一定的循环体执行次数之内所有路径的唯一编码[2,19];其二是使用加法和乘法相结合的方式进行探针变量的运算[17,20].对于前一种方式,逻辑控制随着CFG循环结构的复杂化和循环体执行次数的增加将会变得非常复杂,而难以应用;对于后一种方式,可以处理复杂的循环和回边多次执行的路径,但是难以保证静态路径编码的连续性(即编码区间内一些整数不对应任何路径编码),可能在一定程度上浪费编码空间,降低了存储效率.为了达到较强的剖析能力,本文采用后一种方式.文献[20]处理的是调用关系,文献[17]是过程内非选择性剖析,更贴近本文的研究对象,故本文使用文献[17]中的PAP.有别于EPP,PAP使用的探针形式为r··=r×s+i(简记为s(i)),而探针插装算法为:对于CFG中一个有多个入边的节点N,设其入边数目为s,则以任意顺序在其每条入边上插装探针s(0),s(1),…,s(s-1),如算法2及图1(b)所示.图2(c)中给出了一个PAP插装的示例,以表明PAP和EPP在插装方式和处理循环上的不同之处.由于不需要像BL算法那样对CFG的节点进行逆拓扑排序,PAP算法的代价为O(E),其中E为CFG中边的总数.Page5算法2.PAP插装算法.输入:f待剖析CFGaddP(f:entry,“r··=0”);//探针变量初始化FOREACHnodeninfDOints=n.fanIn();//s是节点n的入度IFs>1THENENDaddP(f:exit,“recordr”);//收集pathidsEND由于在探针变量计算过程中使用了加法和乘法相结合的方式,那么按照不同入边交汇于同一个节点N的任意两条路径的编码不会相同,因为二者对N的入度取余的余数不同.进而,在文献[17]中证明,这样的插装方式可以保证任意两条静态路径具有不同的pathid.PAP可以与EPP相结合以减少部分路径编码的浪费,文献[17]定义了可规约无环子图RAS(ReducibleAcyclicSubgraph),是CFG中满足如下条件的子图s:(1)s是单入口单出口DAG;(2)s的入口节点是s的出口节点的前必经节点;(3)s的出口节点是s的入口节点的后必经节点.在这样的子图上,PAP能够与EPP相结合.EPP用于剖析RAS中的路径片段,PAP用于剖析RAS之外的部分,二者的路径编码可以在RAS的出口处结合在一起:若RAS中有n条无环路径,PAP将之视为有n个分支的节点,EPP所获取的localpathid即标注了所执行的分支.类似地,本文使用ESPP剖析RAS,并与PAP相结合来得到PSP的4种实现方式之一(PSP1).在下文中,我们讨论如何将PAP扩展至选择性剖析,使用兴趣路径集合来提高效率.3选择性路径剖析这一节首先给出ESPP算法,然后描述了PSP的4种实现(PSP0~PSP3)的实现细节,最后对这4种实现进行了理论上的比较.3.1ESPPSPP不能保证剖析结果的精确性.如2.3节所述,当某些必要的权值被删除时,本小节按照如下方式将SPP改进为ESPP:使用SPP算法的步骤1和步骤2进行DAG边的权值分配、转移之后,在删除非EI边上的权值时,删除每个权值都检查在删除之后每个PI路径的pathid是否仍然唯一,如是,则删除;如否,则不删除.迭代地检查、删除每个非EI边的权值,直至所有权值均不能删除为止.ESPP算法如算法3所示.算法3.ESPP(G,EI).输入:G待剖析DAG输出:Val(e)图G中每条边e的权值/步骤1.计算边的权值/NumPaths(EXIT)=1;FOREACHnon-exitnodevinreversetopologicalorderDONumPaths(v)=0;FOREACHoutedgeenotinEI:v→wDOVal(e)=NumPaths(v);NumPaths(v)=NumPaths(v)+NumPaths(w);ENDFOREACHoutedgeeinEI:v→wDOVal(e)=NumPaths(v);NumPaths(v)=NumPaths(v)+NumPaths(w);ENDEND/步骤2.权值转移/FOREACHnodevintopologicalorderDOIF(vhasonlyoneinedgeei)and(Val(ei)>0)FOREACHoutedgeeo:v→wDOVal(eo)=Val(eo)+Val(ei);ENDVal(ei)=0;ENDEND/步骤3.删除非兴趣边的权值/SetPIpathids,PNpathids;//PIpathids和PNpathidsgetPIpathidsfromVal;//通过边的权值计算PI路FOREACHedgeenotinEIandVal(e)!=0DOgetPNpathidsfromValandVal(e);IFPIpathids∩PNpathids=THENVal(e)=0;ENDENDESPP算法在SPP算法的基础上添加了删除探针时对路径编码唯一性的检测,这种检测保证了任意两条不同兴趣路径的编码不同且任意一条兴趣路Page6径与任一条非兴趣路径的编码不同,进而可以保证对兴趣路径的剖析结果是精确的.ESPP算法属于贪心算法,该算法的结果不一定是最少数目的权值分配方案(即最少探针).如果在删除时穷举所有的权值组合方案,则可以得到最优解,但是由于pathid和边的权值之间存在复杂的组合关系,这样的穷举过程耗费的时间过大.所以本文采用贪心策略提高算法效率.ESPP的算法耗费为O(E2×P+E×I×P),因为步骤1耗费O(E),步骤2耗费O(E),步骤3耗费O(E2×P+E×I×P)①,其中E是DAG的边数,I是DAG中的兴趣路径的数目,P是静态路径总数.3.2非兴趣路径的检测“提前结束”(earlytermination)是由非选择性路径剖析方法所提出的技术,如文献[18,21],其含义为:如果执行到CFG的某个位置,该位置之后的执行路径是确定的(即不再有分支的可能),那么可以直接确定所执行的路径,而不需执行该路径剩余的部分,以节约执行时间.为了节约更多的执行时间,程序出口处的探针将被“前推”,即转移到离程序入口更近的位置.在本文中,我们将提前结束的思想扩展至选择性剖析:如果在执行中检测到当前执行的路径属于非兴趣路径,那么可以终止当前执行以节约时间.这要求在执行过程中进行路径检测,而一方面这种检测需要额外的耗费,另一方面要求能够尽早地检测出尽可能多的非兴趣路径,以尽可能地节约执行耗费.权衡这两个方面,我们给出3种检测技术T1~T3以供选择.T1.检测temppathid.检测的依据在于非兴趣路径和兴趣路径的temppathid在某些位置不同.在CFG的必要位置(具体位置详见3.3节)枚举所有兴趣路径的temppathid,那么当执行中发现当前的temppathid不属于任一兴趣路径,则可以判定执行了非兴趣路径,应该提前结束.T2.检测localpathid.检测的依据在于某些非兴趣路径和兴趣路径会在子图上执行不同的路径片段.我们在无环子图上应用ESPP,并在子图的出口处检查localpathid,如果发现执行了非兴趣路径,那么应该提前结束.T3.检测BE.检测的依据在于兴趣路径上只会执行EI边,执行了BE边或NE边的路径必然是非兴趣路径;任一条路径在执行任何NE边之前必然会先执行某一条BE边②,所以只需在BE边上进行检测即可.基于T1~T3,我们设计了PSP0~PSP3,其中PSP0使用T1进行检测,PSP1使用T2,PSP2使用T3,而PSP3同时使用T2和T3.T1能够检测出所有的非兴趣路径,而T2和T3仅能检测出部分路径,相应地,T1的检测耗费也高于后二者.由此我们可以得出T1~T3,以及PSP0~PSP3的检测需要的耗费和能够节约的耗费的偏序关系,如图4所示.接下来的章节依次讨论了PSP0~PSP3的算法及其耗费(算法复杂度)③.3.3PSP0PSP0使用T1进行检测,需要在CFG的必要位置枚举所有兴趣路径的temppathid.首先考虑何种位置上的检测是不必要的.从CFG中可以抽象出3种结构:顺序、多入边交汇、多出边分支,如图5所示(图中的边既可以是普通边,也可以是回边).我们拟对这3种结构进行检查,确定执行到节点B时,检测是否是必要的.图5(a)中,B处的检测显然是不必要的.因为如果B处temppathid与兴趣路径冲突,那么A处temppathid已经冲突并提前结束,所以B处不会检测出任何的非兴趣路径.图5(b),B处的检测也是不必要的.因为一条路径包含①②③Page7了A或C,那么必然包含B,而不论是兴趣路径或是非兴趣路径,B处也不会检测出任何的非兴趣路径.图5(c),B处的检测是必要的.因为有可能AB是BE边而AC是EI边,B处即可提前结束非兴趣路径.由以上分析可知,PSP0需要进行路径检测的位置是:其前驱具有多条出边的节点.基于此,我们设计了PSP0算法,如算法4所示.该算法首先计算PAP算法的探针,然后在必要位置计算兴趣路径的temppathid,并以此插装路径检测的探针.该算法的耗费为O(E+N×I),其中E是CFG的边数,N是节点数,而I是兴趣路径数目(假设兴趣路径的最大长度为常量)(算法步骤1耗费为O(E),步骤2耗费为O(N×I),步骤3耗费为O(N)).算法4.PSP0(G,PI).输入:G待剖析CFG输出:ps探针集合/步骤1.PAP探针插装/FOREACHnodeninGDOints=n.fanIn();inti=0;FOREACHinedgeeofnDOps.addPAPProbe(e,s,i++);//在边e上插装探ENDEND/步骤2.在必要位置计算兴趣路径的temppathids/Map〈Node,Set〉tp;//tp记录temppathidsFOREACHnodeninGDOIFnisunnecessarytocheckTHENENDinitializeanInteger-Set,namedpathids;FOREACHpathpinPIDOENDtp.put(n,pathids);END/步骤3.计算探针/FOREACHnodeninGDOSetpathids=tp.get(n);ifpathids!=nullthenps.addIdentifyProbe(n,pathids);ENDEND图6给出了一个PSP0的示例,其中有两条兴趣路径BDE和BDEBDE,那么图中边BC为BE边,CE为NE边,其余边均为EI边.使用PSP0算法进行插装:(1)节点E是不需检测的位置,因为E的两个前驱节点C和D均只有一条出边,其余节点均需要检测;(2)按照PAP算法进行路径编码(PAP插装如图中控制流边上所注)后,按照兴趣路径计算每个节点处的temppathid集合,以此对是否执行了非兴趣路径进行判定,结果如图6所示.我们以非兴趣路径Entry-B-D-E-B-C-E-Exit为例,说明图6中的实例在插装后的执行步骤:(1)首先,在Entry节点处,变量r的值初始化为0;(2)随后经过运算r··=r×2执行至节点B,此时r的值依然是0;(3)在节点B处,由于集合f0,3g包含r的当前值0,故未能检测出当前执行的路径为非兴趣路径,继续执行;(4)在节点D处,与节点B处的运算结果相同,(5)在节点E处,经BE边上的运算,当前r的值为1;(6)在节点B出,经EB边上的运算,当前r的值为3,依然在集合{0,3}内,故继续执行;(7)在节点C出,由于C处兴趣路径编码集合为空集,故在此处当前执行被识别为非兴趣路径,停止执行.依然继续执行;Page83.4PSP1由于ESPP是一种无环图上的精确选择性剖析方法,可以将之用于剖析有环CFG的无环子图RAS,并与PAP相结合来达到有环图的精确选择性剖析.步骤如下:(1)在RAS之中,ESPP使用局部探针变量对路径片段进行选择性剖析;(2)在RAS的出口处,使用T2进行路径检测:检查localpathid,如果发现不属于任一兴趣路径,则提前结束;(3)如果在RAS的出口处未检测到非兴趣路径,那么localpathid将结合到PAP的全局探针变量计算之中,继续执行.PSP1的算法如算法5所示,输入兴趣路径和RAS集合,使用ESPP剖析RAS并在RAS出口处添加路径检测和结合PAP编码的探针.对于每次执行,要么提前结束,要么完成执行之后获得唯一的路径编码.由于ESPP算法耗费为O(P×E2+P×E×I),PAP算法耗费为O(E),所以PSP1算法耗费为O(S×P×E2+S×P×E×I),其中S为RAS数目,E为CFG边数,I为兴趣路径数目,P为各个RAS中的静态路径总数的上限.算法5.PSP1(G,PI,rass).输入:G待剖析CFG输出:ps探针集合/步骤1.RAS上应用ESPP/Listhandled_nodes;//记录使用ESPP方法处理的节点FOREACHRASrinrassDOaddallnodesofrintohandled_nodes;handled_nodes.remove(r.entry);performESPPalgorithmonrandaddprobesintops;getlocal_pathidsofPIpathsinsider;//计算局部编码ps.addIdentifyProbe(r.exit,local_pathids);//如果local_pathid不属于local_pathids,则提前结END/步骤2.RAS外应用PAP/FOREACHnodeninGDOIFhandled_nodes.contains(n)THENCONTINUE;ENDints=n.fanIn();IFs<2THENCONTINUE;ENDinti=0;FOREACHinedgeeofnDOps.addPAPProbe(e,s,i++);//在边e上插装探ENDEND图7给出了一个PSP1示例,方框中是一个RAS,假设有两条兴趣路径为ABDEMJG和ABE-MJGBDEMJG,那么RAS之中有两条兴趣路径片段:BDEMJG和BEMJG;使用ESPP剖析,可以删除非兴趣边IJ的权值,节约探针;两条兴趣路径片段的localpathid为5和8,所以在RAS的出口节点G处,如果当前的局部探针变量r的值不是5或8,就代表执行了非兴趣路径,可以提前终止,否则与PAP结合EPP的方式类似,将localpathid结合到PAP的探针变量计算之中.3.5PSP2受SPP转移探针插装位置的启发,PAP的探针也可以转移位置.SPP为了将探针更多地分布到非EI边上以尽可能多地删除,故其将权值从节点的唯一入边转移到该节点的出边(即“后推”);而在PSP中,为了尽可能早地达到提前结束,有必要将探针从节点的出边转移到该节点的入边(即“前推”).3.5.1探针前推在PAP探针插装的基础上,可以将单出边节点出边上的探针(如果存在的话)“吸收”到其入边上,如图8(b)所示,连续执行两个探针x(i)和y(k)的结果与仅执行一个探针xy(yi+k)对于探针变量计算具有同样的影响(因为(r×x+i)×y+k=r×x×y+y×i+k).这样完成探针转移的同时不会影响任何路径的pathid.如果某个节点的出边属于EI集合而其部分入边属于NE集合,那么经过这样的探Page9针转移后,可以达到减少探针的效果.3.5.2PSP2算法基于兴趣路径集合PI,CFG中的节点可以划分为两个集合,NI和NN;相应地,CFG中的边可以划分为3个集合,EI、BE和NE.这样的CFG划分如图9所示,假设兴趣路径为ABDH和ACEH,那么左边方框中的是NN节点,右边方框是NI节点,EI中的边为粗线表示,BE集合包括边BE和边BF,其余边为NE边.在进行探针插装时,根据T3的检测机制,只需要在BE边上插装提前结束的探针,而在NE边上删除所有探针(由于BE边上已经结束,不会执行任何NE边).如图9中在边BE和边BF上插装提前结束的语句(如图中X符号所示),则NE边不会被执行.由以上讨论,可以得出PSP2算法,如算法6①所示,其中包括3个步骤:(1)在每条BE边上添加提前结束的探针,NE变得不可达,将这两个集合中的边从CFG中删去;(2)在简化后的CFG上,使用PAP算法进行剖析;(3)将探针前推.算法6.PSP2(G,PI).输入:G待剖析CFG输出:ps探针集合/集合计算/getEI,BE,NE,NIfromPI;/BE边上添加提前结束探针/FOREACHedgeeinBEDOps.addENDing(e);//边e上提前结束remove(G,e);//从G中删除边eENDFOREACHedgeeinNEDOremove(G,e);//从G中删除不可达边ENDps=ps+PAP(G);//修改后的G上应用PAP方法,/EI边上探针前推/FOREACHnodeninNIinreversetopologicalorderDOIFnhasonlyoneoutedgeeTHENEND算法6的耗费为O(E×I),因为对CFG进行划分需要耗费O(E×I),而其他步骤的耗费仅为O(E),其中E是CFG的边数,而I是兴趣路径总数.3.6PSP3T2在RAS的出口进行检测而T3在BE边上进行检测,这两种检测技术可以同时在一种剖析方法中得到应用,将PSP1和PSP2两种方法结合起来:首先,应用PSP2并在CFG中删除非兴趣边,达到简化的目的;然后,在简化后的CFG中使用RAS并应用PSP1进行检测.这种方法我们称为PSP3,其算法如算法7所示,其耗费为PSP1和PSP2之和:O(S×P×E2+S×P×E×I+E×I)=O(S×P×E2+S×P×E×I)(参数含义同前).算法7.PSP3(G,PI).输入:G待剖析CFG输出:ps探针集合/步骤1.边上检测非兴趣路径/usePSP2withGandPI,andaddtheprobesintops;removeBEandNEedgesfromG;/步骤2.选择RASs/①对G中的节点进行逆拓扑排序时,不考虑G中的回边,即Page10onthereducedgraphG,searchallRASs;choosesuitableRASsandputtheminsetrass;/步骤3.RASs上应用ESPP/useESPPwithG,PIandrass,andaddtheprobesintops;PSP3示例如图10所示,其中的控制流结构和兴趣路径与图7相同.图10(a)中,PSP2在边MI和IG上进行路径检测,图10(b)在简化后的CFG上,应用PSP1进行剖析.注意到RAS结构简化之后,路径数目由9条减少为2条,相应地,在结合PAP全局变量计算时可以压缩路径编码空间,减少编码浪费,提高存储效率.4实验我们基于JAVA语言和JDT(Eclipse3.4)实现了PSP0~PSP3,以进行实验分析.实验分为两个部分:首先在多个非循环程序上记录和比较PSP0~PSP3与相关方法SPP和PrePP的效率与精确度(因为SPP和PrePP是非循环剖析方法);然后在多个循环程序上对PSP0~PSP3进行比较,以发现各种方法的适用情况,并将之与PAP进行比较以验证选择性剖析的有效性.前一实验的度量变量为执行时间和不精确度,后一实验的度量变量为执行时间(PSP0~PSP3均为精确剖析方法).不精确度定义如下①:rateinaccuracy=|pathcollected|-|PIexecuted|4.1非循环程序在非循环程序的实验中,我们首先使用一个简单的程序GetMid[22]作为实例进行分析,同时对实验步骤进行说明,便于后文的理解;然后从SPECjvm2008②中抽取多个具有代表性的程序作为基准测试程序进行实验.GetMid程序(记为程序No.0)的功能是返回输入的3个数据中的中间数,其源码如下:doubleGetMid(doublex1,doublex2,doublex3){doublemid=x3;if(x2<x3){elseif(x1>x3)returnmid;}我们从其源码中抽取CFG,并随机选取两条静态路径作为兴趣路径,使用SPP,PrePP和PSP进行剖析,插装结果如图11所示(temppathid简记为“tp”).其中对于PSP1和PSP3,由于程序中无环,故整个CFG被当做一个RAS进行处理.然后我们使用随机输入多次执行插装后的程序,收集各种方法插装结果的执行时间和剖析的不精确性.挑选基准测试程序:我们按照如下准则从SPECjvm2008和JDK中(1)无环或环可忽略;(2)可独立执行;(3)无过程间调用或过程间调用可被忽略.据此,我们挑选了9个程序,其中SPECjvm2008的5个分别为check.PepTest.checkMathFcts,check.Main.runBench-mark,startup.Main.harnessMain,check.PepTest.-testIf,check.PepTest.checkRemain-ders;JDK中的4个分别为net.SocketPermission.getActions,net.URLConnection.guessContentType-FromStream,awt.AWTKeyStroke.getModifiersText,awt.GridBag-Layout.alignOnBaseline(依次简记为程序No.1~No.9).表1列出了这些程序的相关信息,包括控制流图相关参数和LOC(LinesOfCode).①②Page11图11选择性剖析程序GetMid表1benchmark程序信息guessContentTypeFromStream无环21232646252057203358371991623行选择性剖析,步骤如下:针对这些程序,我们首先使用10条兴趣路径进(1)对于每个待测程序独立地随机生成10组兴趣路径;(2)对于每组兴趣路径使用六种剖析方法插装后,随机生成10个输入运行插装后的程序;(3)统计10组兴趣路径的平均剖析效果,包括时间耗费timecost(单位为ms)和非精确性inaccu-racy(单位为百分比).实验结果如图12所示,其结果可以总结如下:(1)PSP0在9个程序中的3个(No.2,No.3和No.5)上取得最高效率,同时其平均时间也最低;PSP2在5个程序(No.1,No.4,No.6,No.7和No.8)上取得最高效率;剩余的程序在No.9上PrePP效率最高;(2)PSP0的平均时间耗费较SPP降低79.83%,较PrePP降低80.10%;PSP1的平均时间耗费较SPP增加1.67%,较PrePP增加0.30%;PSP2的平均时间耗费较SPP降低16.30%,较PrePP降低17.42%;PSP3的平均时间耗费较SPP降低17.58%,较PrePP降低18.68%;(3)在不精确度方面,SPP在程序No.3,No.6和No.9上分别有10.00%,4.07%和88.68%的不精确度,9个程序上平均为11.20%;PrePP在9个程序上均存在不精确度,10%至86.68%不等,平均为44.07%.为了观察不同兴趣路径对剖析效率的影响,我们对每个程序采用50条兴趣路径,按照上述步骤重新进行实验,结果如图13所示,其中结果为:(1)PSP0在9个程序中的2个(No.3和No.5)上取得最高效率,同时其平均时间也最低;PSP2在4个程序(No.1,No.6,No.7和No.8)、PSP3在程序No.2、PrePP在2个程序(No.4和No.9)上取得最高效率;(2)PSP0的平均时间耗费较SPP降低16.76%,较PrePP降低12.60%;PSP1的平均时间耗费较Page12图12无环程序上使用10条兴趣路径的实验结果SPP增加0.19%,较PrePP增加5.21%;PSP2的平均时间耗费较SPP降低4.63%,较PrePP增加0.14%;PSP3的平均时间耗费较SPP降低2.12%,较PrePP增加2.78%;(3)在不精确度方面,SPP在程序No.3和No.9上分别有30.00%和100.00%的不精确度,平均为14.44%;PrePP在8个程序(除No.1之外)上存在不精确度,1.33%至100.00%不等,9个程序上的平均值为25.20%.通过比较图12和图13,可以发现:(1)兴趣路径从10条增加到50条,所有剖析方法的平均时间耗费均有所增加,但是幅度不同:SPP增加了6.86%,PrePP增加了0.40%,PSP0~PSP3分别增加了341.05%,5.31%,21.75%和26.90%.PrePP的时间耗费基本不随兴趣路径数目变化,但是其不精确性很高,应用价值较低.PSP0的时间耗费随兴趣路径增多呈现最明显的增加,所以比较适合兴趣路径较少的情况;(2)PSP0在执行时间较长的程序上应用效果好,但是其时间耗费随着兴趣路径的数目增长最快.这是由于PSP0对兴趣路径的检查能力最强,同时其检查需要的时间也最多;(3)SPP和PrePP存在着明显的不精确性,尤以PrePP为甚.这使得其剖析结果的应用价值较低.随着兴趣路径的增多,PrePP的不精确性有着明显的改善,但依然处于较高水平;(4)在无环程序上PSP1应用效果不佳,这是由于整个控制流图作为一个RAS,PSP1仅在程序终止位置进行兴趣路径的检测,检测带来的收益有限;(5)PSP2在执行时间较短的程序上效果较好,这一方面是由于PSP2能够保证剖析的精确性,另一方面由于PSP2的“动态耗费”很小,且不随兴趣路径增多而增长,表现较为稳定.PSP3与之类似.Page13图13无环程序上使用50条兴趣路径的实验结果执行时间.4.2循环程序由于SPP和PrePP不剖析循环,故在这部分实验中我们仅比较PSP0~PSP3,以观察其效率.目的在于回答如下问题Q:面对具体应用时,如何根据相关参数从PSP0~PSP3中选择合适的一种方法进行剖析?我们使用SPECjvm2008中的部分循环程序作为测试程序,并在其上选择不同数量的兴趣路径,观察4种PSP方法的效果.4.2.1针对不同兴趣路径的实验结果4.1节的实验中已发现PI集合对PSP效率存在影响,本小节的实验对此做进一步的探索,步骤如下:首先,我们选择SPEC中scimark包中的6个程序作为基准测试程序,并随机抽取程序的部分静态路径作为PI;然后,基于PI对测试程序进行剖析;最后,使用随机输入执行插装后的程序,并收集使用10~100条兴趣路径,实验结果如图14所示(图中时间耗费为0表示执行时间小于1ms,无法检测),从中我们可以观察到:(1)每种情况下,至少有一种PSP的实现方式耗费低于PAP,这意味着合适的选择性剖析方法可以带来效率的提高;(2)程序measureLU未有明确的最优剖析方法,而在其他5个程序上,效率最高的剖析方法依次(从上到下、从左到右)为:PSP2、PSP0、PSP3、PSP0和PSP0.故大多数情况下,一个待剖析程序对应某种最优的剖析方法,该方法可以适用于各种兴趣路径的情况;PSP0适用于大部分循环程序;(3)在程序nextDoubles上,随着PI的增大,PSP0~PSP3的时间耗费均越来越多,部分甚至超过PAP的耗费,这种情况意味着选择性剖析并未带来效率的提高.相对而言,PSP0耗费增长得最快而PSP2的耗费增长最慢.而在其他程序上,未有明显Page14图14使用PSP剖析循环程序的时间耗费的增长趋势.综合图12~图14的实验结果,可知PSP0的表现明显区别于其他方法:其耗费常常为最高或最低.这是由于PSP0对PN路径的检测能力和检测耗费均为最高(参见图4),而二者之差决定了剖析的效率.检测能力带来的效率提升与程序实现相关,而检测耗费仅与程序抽象结构(控制流图、兴趣路径等)相关.可以推测PSP0适用于程序结构简单、执行缓慢的情形.对于其他方法也有适用的剖析场景.下面我们通过实验结果的分类统计来获得更一般、有效的结论.4.2.2实验结果与参数关联性分析4.2.1小节给出了实验结果,并分析了其与兴趣路径数量的关系.为了回答前文论述的问题Q,这里我们列举一些较易获得的应用参数,统计实验结果与这些参数的关联,以找出有效的参数作为选择PSP方法的依据.这些参数包括程序节点总数、程序循环总数、循环体节点占总结点的比例、RAS个数、最大RAS节点数以及原始程序单次执行时间6种参数.对于每种参数,我们以该参数在实验中出现的取值范围的中位数为基准,将实验结果划分为相同数量的两部分,统计PSP0~PSP3在两部分的效率.为统一起见,我们使用PSP0~PSP3插装后执行时间相对于原始程序执行时间的百分比作为衡量标准.结果如图15所示.从图中可以看出:(1)在6种参数划分的12个类别中,PSP0在6类中效率最优,其选择标准明确:当节点数小于20,或原始执行时间不小于500ms,或环节点比例小于0.85,或RAS个数少于2,或循环个数不少于4个,或最大RAS节点数目少于7个的情况下均应选择PSP0;(2)对于其他情况(即PSP0不适用),由于没有统一的最优方法,我们需要对参数的区分度进行排序,其依据为PSP1~PSP3中次优方法与最优方法的效率差值,该值越大,说明相应的参数区分度越好;(3)按照图中从左到右、从上到下的顺序,6种参数的区分度依次为14.9%、38.5%、45.1%、43.2%、37.6%和46.5%;(4)按照参数区分度由大到小,我们对于不适用PSP0的6类情况依如下优先次序进行选择:①原始执行时间小于500ms选择PSP2;②循环节点比例不小于0.85选择PSP2;③RAS个数不少于2个选择PSP2;④循环个数少于4个选择PSP2;⑤最大RAS节点数目不少于7个选择PSP2;⑥节点数不小于20选择PSP1.以上即为从实验结果中获取对问题Q的答案,说明在选择性剖析中如何从PSP1~PSP3中选择一种合适的方法进行应用:根据具体应用时获得的参数取值,从PSP1~PSP3之中选择适用的剖析方法,如图16所示.例如,在剖析某程序前,获知该程序CFG节点数为24,则应选择PSP1进行剖析;若同时获知该程序循环节点比例为0.9,那么则应选择PSP2进行剖析,因为后一参数优先级更高.特别Page15图15实验结果与6种参数关联性分析图17静态耗费地,如果在6种参数均可统计的情况下,那么仅收集原始执行时间即可,因为该参数优先级最高.4.3静态耗费统计由于在剖析过程中,插装算法只需要运行一次,而插装后的程序需要反复多次执行,故一般来说,动态耗费在剖析算法的效率评价中占据主导地位.这里我们统计前面实验所用的6个循环程序,比较PSP0~PSP3在各个程序上的静态耗费,如图17所示,其中AlgorithmCost指插装算法计算探针的时间耗费,InstrumentationCost指使用探针完成源码文Page16件插装的时间耗费.从图中可以看出:(1)InstrumentationCost远小于AlgorithmCost,且具有一定的随机性,这和磁盘的文件写入机制有关;(2)随着兴趣路径的增多,算法耗费总体上呈现增长趋势;(3)PSP0~PSP3在所有程序上的平均算法耗费依次为28.7ms、27.9ms、38.1ms和53.4ms,即PSP1算法耗费最低,PSP0次之,PSP3最高.4.4威胁分析种内部威胁:下面我们对实验威胁进行分析.其中主要有两(1)实验人员偏向.由于实验对象的选取较为客观,且实验结果均为自动生成,避免了实验人员的偏向影响实验结果.在未来工作中,使用更多的程序进行实验将会得出更客观的结论;(2)实验可靠性.一方面,我们使用的实验平台为Eclipse和JVM,具有较高可靠性;另一方面,我们对部分插装结果的正确性进行了人工验证,使得各种剖析方法的实现也具有较高可靠性;(2)结论可靠性.从实验中可以看出,一种选择性剖析方法的效果在一定程度上依赖于待剖析程序的结构.实验中使用了多个带剖析程序并从其结果中得出结论,该结论应当适用于许多结构;(3)实验对象的代表性.在实验中使用了来自两个Benchmark系统的15个程序,具有较高代表性.在将来工作中,需要更广泛的实验来对PSP效果进行检验.5相关工作(3)度量标准的合理性.我们采用的“时间耗费”、“不精确性”等度量标准均为选择性剖析方法的主要性能指标,其值的高低直接关系到某种剖析方法是否适合应用.而外部威胁主要有3种:(1)实验环境.我们的实验步骤遵循选择性路径剖析方法的步骤.实验步骤与实际应用步骤的唯一区别在于,实验中的兴趣路径是随机生成的,而实际应用中的兴趣路径应当由用户指定;除第2节讨论的剖析方法以外,其他的单过程表2单过程剖析方法分类剖析技术EPP[18]ExPP[2]kIPP[19]PAP[17]TPP[21]PraPP[23]SPP[16]PrePP[15]PSP是否剖析循环是否完全精确剖析方法总结如下.在非循环剖析方面,Joshi等人[21]提出TPP(TargetedPathProfiling)、使用明显路径(“obviouspaths”)和冷边(“coldedges”)来提高EPP的效率;Bond等人[23]提出PraPP(PracticalPathProfiling),改进了TPP的效率,使用边的剖析结果简化路径剖析.在循环剖析方面,Tallam等人[2]提出一种近似算法ExPP,可以剖析包含循环体二次执行的路径;这种方法由Roy等人[19]进一步改进为kIPP,可以达到执行循环体数次路径的精确剖析.在这些剖析技术中,部分方法剖析所有的可剖析路径[2,17-19],其他方法仅剖析部分路径[15-16,21,23].这些“部分剖析”技术可进一步划分为两类:剖析的路径集合是基于路径频率所选择的还是基于用户兴趣所选择的,即剖析“热”路径(执行频率高的路径)或剖析兴趣路径.文献[21,23]通过删除冷边自动的从剖析中删除冷路径,由于剖析路径较少,与EPP相比效率有所提高;而文献[15-16]接受一个兴趣路径集合进行剖析,来提高非选择性剖析方法的效率,这也是本文方法PSP的目的.SPP、PrePP和PSP的区别如下:(1)SPP给予兴趣路径较大的pathid以将其与非兴趣路径相区分,通过减少探针数目来提高EPP效率;(2)PrePP给予兴趣路径较小的pathid以压缩编码空间,通过提高存储效率来提高EPP效率.文献[15]中同时证明了兴趣路径和非兴趣路径的编码不可能“完美”分离(完美分离即通过调整边的权值使兴趣路径和非兴趣路径的编码属于两个不相交区间),故这种方法无法在压缩编码空间的同时,保证兴趣路径编码的唯一性;(3)不同于SPP关注于删除探针,也不同于PrePP关注于压缩编码,PSP主要使用提前结束的思想来提高剖析效率.同时,尽可能的减少探针和压缩编码的思想也存在于PSP各种实现方式之中.表2从多个方面比较了单过程剖析方法,并显示出了PSP与其他选择性剖析方法相比的两个优点:支持循环路径作为兴趣路径,并且是完全精确的.实验结果也验证了其在耗费上的可行性.Page176总结与展望本文的主要贡献如下:将SPP改进为ESPP,以达到无环图上的精确选择性剖析;提出了使用提前结束的方法提高选择性剖析效率的思想;由于提前结束需要在执行中检测非兴趣路径,给出了3种检测的方法T1~T3,具有不同的耗费和收益,以适用不同情况;基于这3种检测方法,设计了4种能够剖析循环的选择性剖析方法PSP0~PSP3,与已有方法相比具有3个优势:允许循环路径作为兴趣路径、剖析结构完全精确,且实验显示,在大部分实例上,PSP比其他方法的效率更高;绘制了T1~T3、PSP0~PSP3之间各种耗费的偏序关系;并基于实验结果给出了在实际应用中如何选择合适的PSP实现方式的策略.在将来的研究中,我们可以按照如下方向进一步改进PSP:更多的非兴趣路径检测方法,如使用路径片段(不局限于RAS之中)进行检测;更广的应用场景,如将之扩展至过程间剖析之中,用来剖析用户感兴趣的特定方法调用及序列等.
