Page1DUCG:一种新的动态不确定因果知识的表达和推理方法(I):离散、静态、证据确定和有向无环图情况张勤(北京航空航天大学计算机学院北京100191)摘要贝叶斯网络(BN)是国际上流行的处理不确定因果知识的表达和推理模型.文中指出:即使所有变量均为二状态,BN中的子变量也有单赋值和多赋值之分.在单赋值情况下适用的知识的简洁表达和推理方法在多赋值情况下不适用.为克服BN的上述及其它缺陷,文中提出了DUCG(DynamicalUncertaintyCausalityGraph)理论模型,以图形方式简洁表达任何情况下的不确定因果关系,并基于证据化简图形和展开事件,以得到所关注假设事件及其状态概率表达式.此外,DUCG允许知识表达不完备,使其超越了BN理论框架.一个入侵者报警系统被用来解释DUCG理论.关键词智能系统;知识表达;概率推理;因果关系;不确定性1引言处理不确定因果关系的知识表达方式和推理方法是人工智能系统必须解决的关键问题之一.迄今已提出了许多理论模型.如CertaintyFactor[1]、EvidenceReasoning[2]、PROSPECTOR[3]、FuzzyLogic[4]、BN[5-20]等等.其中,BN正日益流行[12,16].简洁的知识表达方式和高效的推理算法是BN研究的核心问题之一.众所周知,BN中条件概率分布CPD(Condi-tionalProbabilityDistribution)的典型表达方式是条件概率表CPT(ConditionalProbabilityTable).然而,CPT需要说明太多参数.例如,1个子变量和5个父变量且所有变量均有5个状态,则CPT中的条件概率参数为56=15625个.针对这一问题,学术界提出了许多简洁(compact)表达方式和推理算法.例如noisy-OR[6]、CSI(ContextSpecificIndepend-ence)[21]、DCD(DynamicCausalityDiagram)[22]等等.然而,这些模型均以二状态变量为例提出和说明,实际上讨论的均为单赋值情况而非多赋值情况.本文指出:单赋值情况和多赋值情况有着本质区别,适用于单赋值情况的简洁表达方式和推理算法通常不适用于多赋值情况.所谓单赋值(single-valued)情况或多赋值(multi-valued)情况,是指所涉及的子变量是单赋值的或多赋值的.单赋值变量和多赋值变量的定义如下.定义1.说明变量状态的原因被称为赋值.单赋值变量是指子变量的赋值状态只有一个(通常称为true状态);多赋值变量是指子变量的赋值状态多于一个.例如,在学术界熟知的盗窃、地震和报警系统例子中[6],警报既可被盗窃引发,也可被地震引发.警报变量有两个状态:“警报响”(true状态)、“警报不响”(false状态).通常,仅“警报响”状态的原因被说明(即盗窃或地震引发警报),而“警报不响”状态的原因不被说明,因为“警报不响”状态的原因已被缺省地说明为“警报响”状态的补集.根据上述定义,作为子变量的报警变量是单赋值的.又如冰箱温度变量,该变量有3个状态:温度“高”、“低”和“正常”.“高”状态的原因可能是冰箱压缩机故障;“低”状态的原因可能是冰箱温度探测器故障.这里,温度变量的两个状态的原因被分别说明.根据上述定义,作为子变量的温度变量是多赋值的.需要指出的是:多赋值变量的含义与多状态变量的含义完全不同.多状态(multi-state)变量是指该变量的状态多于两个,否则即为二状态(binary)变量.二状态变量有且仅有两个状态.例如响与不响、雄与雌,等等.需要注意的是,二状态变量既可以是单赋值的,也可以是多赋值的.上例中的警报变量是单赋值的二状态变量;而性别变量却通常是多赋值的二状态变量,因为性别变量的两个状态“雄”与“雌”的生物学原因通常被分别说明.多状态变量通常是多赋值变量.上述温度变量既是多状态变量,又是多赋值变量.这是因为单赋值多状态变量是无意义的.作为单赋值变量,多状态变量除true状态外的所有其它状态可被压缩为一个状态:false,是true状态的补集.换句话说,单赋值多状态变量实际上是单赋值二状态变量.在许多文献中(例如文献[16]),单赋值变量常常被混淆为二状态变量,而多赋值变量常常被混淆为多状态变量.这种混淆的结果是:仅适用于单赋值情况的简洁表达方式和推理方法被简单地进行状态概率强制归一而被不适当地推广于多赋值情况.本文下一节将指出,这样的推广理论上无依据,实践上是不合理的、不自洽的、不精确的、甚至不具有可操作性.鉴于此,本文提出了DUCG模型,以解决上述问题和其它问题.Page3第2节将详细讨论单赋值情况和多赋值情况的本质区别,进一步阐明提出DUCG的3个主要动机之一.其它两个是处理有向循环图DCG(将在下一篇文章中讨论)和不完备的知识表达和推理.第3节简单介绍了笔者在文献[22]中提出的DCD模型.这种介绍伴随着与noisy-OR和CSI的比较,因为尽管DCD比CSI早两年提出,但学术界并不熟悉.而noisy-OR和CSI却已为学术界广泛知晓.介绍DCD的原因在于DCUG是从DCD发展而来的.本节除介绍了DCD外,还进一步将其扩展为单赋值DUCG(S-DUCG).应当说明,该节所讨论的实际上仅限于单赋值情况.第4节讨论多赋值情况的简洁表达,提出了多赋值DUCG模型(M-DUCG).第5节将S-DUCG和M-DUCG结合为DUCG模型,既适用于单赋值情况,又适用于多赋值情况,实现了文献[23]所提出的简洁表达和推理所需要的充分性(sufficiency)和可分离性(separability).第6节讨论如何和为什么DUCG的表达可以是不完备的.这种表达的不完备性已经超越了BN的理论框架,是DUCG的一个重要新特性.该特性能够大大减少建造知识库和推理的工作量和难度.第7节提出基于观测到的证据对DUCG进行有效化简的方法.通过化简,通常无需任何数值计算即可得到定性的推理结果.这种化简与待推理问题无关,所采用的证据包括事件发生的时序.基于化简的DUCG,第8节提出后续的推理算法.该算法提出了一种处理绑定了DUCG所定义的权重系数的事件运算的新算法.基于应用该算法所展开的事件表达式,将对应的独立事件的概率参数代入即可算得所关注的假设事件的条件状态概率和条件排序概率.其中条件排序概率是本文新定义的.第9节对本文进行小结,并对后续工作进行简要介绍.限于篇幅,本文仅讨论静态、离散、证据确定和有向无环图(DirectedAcyclicGraph,DAG)情况.2单赋值情况和多赋值情况的本质区别在许多二状态变量情况中,人们只需要说明子变量Xn的true状态的原因即可,因为false状态的原因已经被隐含地说明为true状态的补集.其中,下标n用于标识子变量.设第2个下标为“1”代表true状态、第2个下标为“2”代表false状态.对于文献[6]中所提出的学术界熟知的盗窃(X1)、地震(X2)和警报(X3)例子来说,X3=x31(警报响)可被X1=x11(盗窃发生)和X2=x21(地震发生)分别引起.对于领域工程师来说,分别给出X1=x11和X2=x21引发X3=x31的特殊条件概率是比较容易的,而直接给出CPT则比较困难.这是因为盗窃和地震分属完全不同的领域.然而,需要指出的是,本例中只有X3=x31的原因被说明,而X3=x32(警报不响)的原因不得被单独说明,因为X3=x32已被隐含地说明为X3=x31的补集.图1解释了这种二状态单赋值情况.其中,代表状态层的因果关系,用文字记为Pnk;ij.下标“nk;ij”表明事件Xn=xnk由事件Xi=xij引起.图中的有向弧采用特别的箭头形状是为了区别于BN中CPT类型的因果关系有向弧.此外,本文中“;”被用来分隔子变量和父变量,其前的标识是子变量的,其后的标识是父变量的.然而,现实世界并非总是如此简单.例如,一个简单的数字记忆电路具有“01”和“10”两个状态或输出.这是一个典型的二状态变量.类似于警报变量,我们可以将其记为X3,且X3=x31代表状态“01”、X3=x32代表状态“10”.不同的是,X3=x31和X3=x32可分别由不同的事件引起.例如,X3=x31由X1=x11引起;X3=x32由X2=x21引起;否则X3的状态随机确定.上述两个原因分别导致各自的结果的“特殊”条件概率分别为p31;11和p32;21.使用“特殊”条件概率一词的原因在于通常pnk;ij≠Pr{Xn=xnk|Xi=xij}.事实上,pnk;ij是DCD中的连接事件Pnk;ij的发生概率,pnk;ij≡Pr{Pnk;ij}.pnk;ij也是noisy-OR中的禁事件(Inhibitor)的补集的发生概率(参见文献[6]或3.1节).类似的符号在文献[24]中也被采用.其中p31;11和p32;21被分别记为cX11(X31)和cX21(X32).这些记法的目的在于区分一般的和特殊的条件概率.为简单起见,在不引起混淆的情况下,特殊条件概率在以下将被简称为概率.第1节提到性别变量(X3)也是一个二状态多赋值变量.该变量有“雄”(X3=x31)和“雌”(X3=x32)两个地位相同的状态,其生物学原因不同,被分别说明.抽象地,一个简单的二状态多赋值情况如图2所示.图1(b)和图2(b)的本质区别在于:图2(b)中Page4X3=x31和X3=x32的原因被分别说明.注意:图1(a)和图2(a)是完全相同的.这意味着单赋值和多赋值两种情况之间的本质差别在变量或节点层面被隐藏了.这种隐藏在CPT表达方式下并无实质意义,因为这种差别已体现在CPT的数据中.但在简洁表达方式下,这种隐藏导致了实质性的问题.这些问题将在稍后讨论.多赋值情况在子变量为多状态变量时通常遇到.例如核反应堆温度变量(X3)可能有5个状态:“正常”(X3=x31)、“高”(X3=x32)、“快速升高”(X3=x33)、“低”(X3=x34)和“快速降低”(X3=x35).这些状态的原因通常不同,且被分别说明.众所周知,在任何情况下,一个变量的所有状态的发生概率之和应等于1.这种性质被称为归一性.单赋值情况总是满足归一性的,因为true状态的概率不可能超过1,即Pr{true|E}1;而false状态不过是true状态的补集,即Pr{false|E}=1-Pr{true|E}.其中E代表任意条件.然而,在多赋值情况下,归一性通常难以满足.例如,设图2中X3=x31由X1=x11引起的概率为p31;11=0.6;X3=x32由X2=x21引起的概率为p32;21=0.8.如果我们简单地将多赋值情况下的这两个状态分别作为两个单赋值情况对待,我们有X3=x31独立于X2;X3=x32独立于X1.本质上,这是因为X3=x31和X3=x32的原因被分别说明.于是,给定条件E=(X1=x11)∩(X2=x21),如果按照两个单赋值情况来对待,我们有Pr{X3=x31|E}=Pr{X3=x31|X1=x11}=p31;11和Pr{X3=x32|E}=Pr{X3=x32|X2=x21}=p32;21.又由于X3=x31和X3=x32互斥,我们进而有即X3的状态归一性未能满足.这是由于X3=x31和X3=x32因互斥而相关,同时它们的原因又被作为两个独立的单赋值状态而被分别说明.解决这一问题的现有方法(例如文献[16])是应用式(1):Pr{Xn=xnk|E}=Pr{(Xn=xnk)∩E}然而,式(1)仅当∑k从式(2)即可看出:Pr{Xn=xnk|E}=Pr{(Xn=xnk)∩E}式中第2个等号成立的条件是∑k1.然而,按照两个单赋值情况分别算出的Pr{Xn=xnk|E}通常不满足∑k经证明了这一点.这个问题在CPT表达方式下并不存在,因为∑k足的.其中,E代表CPT中的父变量的状态组合.换句话说,这个问题仅存在于简洁表达方式中.可能有人认为:当∑k需应用式(1)实现归一化.正是因为∑kE}≠1,才需要应用式(1).但式(2)表明,式(1)正是基于∑k式(1)中,结果成了前提.可见,式(1)没有任何理论基础,是人为强加的.另一些人可能认为式(1)是处理多赋值情况的近似方法.然而情况并非如此,因为许多文献(例如文献[16])认为式(1)是精确解.此外,如果式(1)是近似解,则应有误差估计.但迄今并未看到关于应用式(1)的误差估计的文献.最后,由于本文仅讨论精确解,近似方法不属于本文的讨论范围.除上述理论分析外,下述例子进一步揭示了在多赋值情况下应用式(1)将会产生的4个实际问题.2.1不合理性图3的示例来自文献[21]中的图1,其中所有变量均为二状态变量.本例采用CSI表达方式,左分支代表true状态,右分支代表false状态.为简单起见,事件Xn=xnk被记为Xnk,例如X1=x11被记为X11;X4的第j种父变量状态组合(statecombi-Page5nationofparentvariables)被记为SCPV4;j,例如SCPV4;1=X11X21X31,其中事件的相乘代表逻辑与(AND).本例中,如果仅X41≡(X4=x41)的原因被图3X41≡(X4=x41)的原因的CSI说明设我们不将X42作为X41的补集对待,而是单独说明其原因如图4所示,则本例变成多赋值情况.注意,X1不是X42的父变量,但却是X41的父变量.一般来说,在多赋值情况下,子变量的不同状态可以有不同的父变量.图4X42≡(X4=x42)的原因和参数的独立CSI说明显然,将图3与图4相结合,我们有Pr{X41|SCPV4;j}+Pr{X42|SCPV4;j}≠1.下面我们来看如果应用式(1)强加归一性将会是怎样的情况.记Ej=SCPV4;j.式(1)可被进一步写成Pr{Xnk|Ej}=Pr{Xnk|Ej}其中,αn;j被称为归一化系数.在式(3)和(4)中,右边的Pr{Xnk|Ej}是归一化前的值,左边的Pr{Xnk|Ej}是归一化后的值.注意,式(4)中的归一化系数αn;j是一个取决于Ej=SCPVn;j的变量,不是常数.按照式(4),图3和图4所示的多赋值情况的归一化系数为α4;1=1/(Pr{X41|E1}+Pr{X42|E1})α4;2=1/(Pr{X41|E2}+Pr{X42|E2})α4;3=1/(Pr{X41|E3}+Pr{X42|E3})说明,同时X42≡(X4=x42)的原因不被单独说明,则本例是单赋值情况,因为X42已被隐含地说明为X41的补集.α4;4=1/(Pr{X41|E4}+Pr{X42|E4})α4;5=1/(Pr{X41|E5}+Pr{X42|E5})α4;6=1/(Pr{X41|E6}+Pr{X42|E6})α4;7=1/(Pr{X41|E7}+Pr{X42|E7})α4;8=1/(Pr{X41|E8}+Pr{X42|E8})应用式(3),可算出本例的CPT如表1所示.jEj=SCPV4;jPr{X41|Ej}Pr{X42|Ej}α4;j1X11X21X311/32/31/0.62X11X21X321/21/21/0.43X11X22X312/97/91/0.94X11X22X322/97/91/0.95X12X21X311/21/21/0.86X12X21X322/31/31/0.67X12X22X316/137/131/1.38X12X22X328/157/151/1.5从表1可见,CPT是基于很多且不同的归一化系数而算得的.一般来说,归一化系数的数量与父变量状态组合SCPVn;j的数量相等.也就是说,这些不同的归一化系数的数量巨大.例如,5个父变量且每个变量有5个状态,则归一化系数的数量达55=3125个.这个数量对于领域工程师来说太多了.在分别说明子变量不同状态的原因和参数时,他们难以意识到存在如此之多不同的归一化系数.这里的问题是:我们为什么需要如此之多隐含的不同的归一化系数?这些不同的归一化系数是领域工程师在表达知识时意识到的吗?换句话说,这些归一化系数是领域工程师想要的吗?这些隐含的系数是否表达了领域工程师的知识?显然,人们在应用式(1)或式(3)和(4)时,并没有明确地意识到和回答这些问Page6题.因此,简单地将多赋值情况下的不同状态作为单赋值情况下的多个true状态分别对待是不合理的.2.2不一致性如果我们将图3和图4中pi的值(表2中的表2两套狆犻值的比较jEj=SCPV4;j1X11X21X31p1=0.2p5=0.41/0.6p1=0.1p5=0.22X11X21X32p1=0.2p6=0.21/0.4p1=0.1p6=0.13X11X22X31p1=0.2p7=0.71/0.9p1=0.1p7=0.354X11X22X32p1=0.2p7=0.71/0.9p1=0.1p7=0.355X12X21X31p2=0.4p5=0.41/0.8p2=0.2p5=0.26X12X21X32p2=0.4p6=0.21/0.6p2=0.2p6=0.17X12X22X31p3=0.6p7=0.71/1.3p3=0.3p7=0.358X12X22X32p4=0.8p7=0.71/1.5p4=0.4p7=0.35这里出现了一个矛盾:不同的参数可能对应相同的CPT,但却可能产生不同的链式概率推理结果.为说明这一矛盾,考虑图5中关于冰箱温度的例子.其中的变量状态或事件的定义如下:X11={冷却剂泄漏};X12={无冷却剂泄漏};X21={温度探测器失灵};X22={温度探测器正常};X31={温度偏高};X32={温度偏低};X33={温度正常};X41={食物腐败};X42={无食物腐败};X51={能耗偏高};X52={无能耗偏高}.在CSI表达方式下,X31,X32,X33和X41的原因可被分别说明如图6所示.其中分支自左至右按照变量状态标号顺序排列(1,2,…).基于图6,X31(温度偏高)可被X11(冷却剂泄漏)引起,概率为0.6;X32(温度偏低)可被X21(温度探测器失灵)引起,概率为0.8;X41(食物腐败)可被X31引起,概率为0.7;X51(能耗偏高)可被X32引起,概率为0.5;X42(无食物腐败)是X41的补集,即X42=珡X41;X52(无能耗偏高)是X51的补集,即X52=珡X51.图6X31、X32、X33和X41的原因的CSI表达第1套值)改变为表2中的第2套值,所算得的CPT仍如表1所示.这归因于归一化系数的相应改变.显然,X3是多赋值变量,X4和X5是单赋值变量.这是因为X3的多于1个状态的原因被分别说明,X4和X5只有1个状态的原因被说明.给定Ej=X11X21,如果将X31、X32和X33分别作为3个单赋值情况下的true状态对待,则根据图6,我们有得为0.6/(0.6+0.8+0)=0.4286(8)应用式(1),X3在X11X21条件下的CPT值可算Pr{X31|X11X21}∑kPr{X32|X11X21}∑kPr{X33|X11X21}∑k如果我们将图6或式(5)~(7)中的参数改变为0.8/(0.6+0.8+0)=0.5714(9)0/(0.6+0.8+0)=0.0根据式(1),我们仍有Pr{X31|X11X21}∑k0.3/(0.3+0.4+0)=0.4286(14)Pr{X32|X11X21}∑k0.4/(0.3+0.4+0)=0.5714(15)Pr{X33|X11X21}∑kPage70/(0.3+0.4+0)=0.0也就是说,X3在X11X21条件下的CPT值保持不变.现在我们来看看计算Pr{X41|X11X21}和Pr{X42|X11X21}的情况.注意:因为X4是单赋值的,无需应用式(1).根据图5,我们有Pr{X41|X11X21}=Pr{X41|X31}Pr{X31|X11X21}+根据图6(d),我们有于是,式(17)成为Pr{X41|X11X21}=0.7Pr{X31|X11X21}(18)对于计算Pr{X31|X11X21},我们有两种选择:一种是用式(8)或式(14)中的CPT值.在这种选择下,我们有Pr{X41|X11X21}=0.7×0.4286=0.3(19)Pr{X42|X11X21}=1-Pr{X41|X11X21}式(20)是由于X4是单赋值的.这种选择将推理计算限定于使用CPT的值.虽然本例的CPT值是按照简洁表达方式算出来的,但我们却放弃了对应于该简洁表达方式的链式推理算法.显然,这种放弃是我们所不愿意的.另一种选择是用式(5)或(11)的值,即用归一化之前的概率值进行链式推理.当采用式(5)的值时,式(19)、(20)变成Pr{X41|X11X21}=0.7×0.6=0.42(21)Pr{X41|X11X21}=1-Pr{X41|X11X21}当采用式(11)的值时,式(19)、(20)变成Pr{X41|X11X21}=0.7×0.3=0.21(23)Pr{X41|X11X21}=1-Pr{X41|X11X21}这里我们看到,式(19)、(20)、式(21)、(22)和式(23)、(24)的值彼此不同.换句话说,虽然式(5)~(7)和式(11)~(13)所示的两套参数对应同一个CPT,但链式推理结果却不同.事实上,这种不同可能正是领域工程师给出不同参数时希望的效果,但却与相同的CPT应得出相同的推理结果矛盾.2.3不精确性应用式(1)必须分别计算多赋值子变量的所有状态的条件概率.这里,多赋值变量的每一个状态都被作为一个单赋值情况的true状态对待.这就要求多赋值变量的所有状态都要按照单赋值变量的true状态分别说明其原因.例如,X31、X32和X33的原因在图6(a)~(c)中被分别说明.然而,在图6(c)中说明的X33的原因是不精确的,因为X33≠珡X11珡X21=X12X22.例如,即使X11和X21均发生,X33也仍可能发生,因为X11X21尚不足以导致X31或X32.精确的表达应当是X33=珡X31珡X32.换句话说,X33是X31+X32的补集.其中,“+”代表互斥或(XOR).于是,Pr{X33|X11X21}=1-Pr{X31|X11X21}-必须指出,补集不是一种独立的原因说明,不能用于式(1)的计算,否则将会出现问题.如上例,要计算Pr{X33|X11X21},必须先知道Pr{X31|X11X21}和Pr{X32|X11X21}.但要知道用式(1)算得的归一化的Pr{X31|X11X21}和Pr{X32|X11X21},就必须先知道Pr{X33|X11X21}.这显然是矛盾的.归一化前的Pr{X31|X11X21}和Pr{X32|X11X21}不能被用来计算Pr{X33|X11X21}.这是因为按照式(5)和式(6),我们有Pr{X33|X11X21}=1-Pr{X31|X11X21}-这是一个不合理的值.因此,如果我们坚持应用式(1),类似于图6(c)的不精确表达就难以避免.2.4不可操作性式(25)就变成了式(26):在上述计算中,如果我们用式(11)和(12)的值,Pr{X33|X11X21}=1-Pr{X31|X11X21}-这是一个可接受的值.尽管如此,除了要冒式(25)的风险外,如果有多于一个状态采用补集方式说明原因,也会导致类似计算实际上无法操作.例如,如果上例中X32和X33的原因被分别说明为X11+X33和X11+X32的补集,则式(26)的计算将无法操作.这是因为Pr{X32|X11X21}=1-Pr{X31|X11X21}-Page8Pr{X33|X11X21}=1-Pr{X31|X11X21}-应当指出,领域工程师往往只关心所关注状态的原因(例如X31是X41的唯一有意义的原因),而对其它状态的原因并不关心.这可能导致实际上无法说明不被关注的状态的原因.这不仅是因为增加了不必要的工作量和难度,而且是因为领域工程师可能根本就不知道如何单独说明(不是作为其它状态的补集来说明)这些状态的原因.2.5小结将单赋值情况下适用的简洁表达方式和推理算法简单地通过应用式(1)而推广于多赋值情况是不恰当的.这一方面是因为理论上无依据,另一方面是因为实际操作中会出现不合理、不一致、不精确和不可操作的情况.多赋值情况的本质是:简洁表达方式必须解决一对矛盾:(a)满足子变量各状态因互斥而相关(必须满足状态概率归一);(b)多赋值子变量的各状态的原因被独立说明.(a)中的相关性与(b)中的独立性是矛盾的.然而(a)必须被满足,(b)也是简洁表达所要求的.由于用式(1)来解决这个矛盾并不恰当,我们必须寻找新的解决方案.DUCG正是本文提出的解决方案.应当指出,本文只用了CSI为例来解释多赋值情况下应用式(1)存在的问题,但这些问题同样存在于应用式(1)的所有其它模型中,例如noisy-OR、DCD等等.同样需要指出的是,单赋值和多赋值仅仅与子变量有关,而与父变量无关.单赋值子变量的父变量的活跃状态可以有多个.图7示例的是一个单赋值情况.其父变量X1有3个状态,X1和另一个父变量X2有两个活跃状态,但子变量X3却只有一个赋值状态(单赋值).注意,图1(a),图2(a)和图7(a)是完全相同的,但它们却隐含着不同的因果关系.图7父变量活跃状态多于一个的单赋值情况示例3用于单赋值情况的S-DUCG模型本节简要介绍DCD模型,因为它提供了DUCG模型的基本思想.但是,在介绍DCD和提出DUCG之前,有必要定义一套新的符号体系.在DCD和DUCG中,大写英文字母代表变量或事件,小写英文字母代表变量的概率分布或事件的发生概率;变量或事件的第1个下标用以区分变量,第2个下标用以区分变量的状态(即事件).也就是说,第1和第2个下标共同确定某变量处于某状态这一事件.例如,Xn代表标号为n的变量,Xnk代表变量Xn的第k个状态.Xnk同时也是一个事件,即变量Xn处于状态k.相应地,xnk≡Pr{Xnk}.变量Xn与事件Xnk之间的差别在于Xnk有两个下标.采用这套新的符号体系的原因在于方便变量状态或相应事件的表达.这种方便在上一节的例子中已经显现.为简单起见,除逻辑门变量外,本节的所有变量均为二状态变量.读者须注意本节的有些表达式在多赋值情况下是不适用的.3.1DCD的简要介绍本节简要介绍DCD的基本概念.理解DCD的基本概念非常重要,因为DUCG是从DCD发展而来的.为便于读者理解,本节采用与noisy-OR和CSI对比的方式来介绍DCD.尽管DCD的提出比CSI早两年,但学术界对DCD并不熟悉,对noisy-OR和CSI却较熟悉.所以,将三者进行简单对比有助于读者理解DCD.需要说明的是,本文不打算对三者进行系统比较,因为这种系统比较的工作量大,也超出了本文的范围.学术界熟知的noisy-OR可用图8(c)的示例说明,该图与文献[6]中的图4.20类似.图中状态1代表true状态;状态2代表false状态.例中,Pr{X31|X11X22}=0.3,Pr{X31|X12X21}=0.6(这两式仅在单赋值情况下成立).根据noisy-OR,图8(b)中的CPT可被算得如Page9图8(a)所示.其中,Pr{X31|X11X21}=1-(1-Pr{X31|X12X21})(1-Pr{X31|X11X22})=1-(1-0.3)(1-0.7)=0.72.本例中,noisy-OR只需要2个参数(0.3和0.6)就可以表达CPT中的8个参数.然而,对于图9(a)中所示的CPT,noisy-OR无能为力,因为X11和X21彼此非逻辑或的关系.图9(b)所示为CSI的解决方案,其中左分支代表状态1(true状态),右分支代表状态2(false状态).本例中,CSI只用了3个参数(0.3,0.6,0.2)就表达了CPT中的8个参数.然而,对于图10(a)所示的CPT,虽然CSI也能将其间接地表达如图10(b)所示,但其简洁程度不够,因为起作用的实际上只有一个参数:0.3.用DCD,本例可被更简洁地表达如图11(a)所示.图11(a)直观地表达了X11或X21或两者共同都可以引起X31,且其概率均为0.3.这正是图10(a)中的CPT实际上告诉我们的.事实上,图8和图9的情况也能用DCD分别表达如图11(b)和(c)所示.按照文献[13]中的定义,图11(b)中X11和X21的关系为逻辑或(OR).j12m图11(c)中的逻辑门变量用G4表达,用以说明变量X1和X2之间复杂的逻辑关系.本例中,G4是X3的一个特殊父变量、有3个互斥的状态:G41、G42和G43.这3个状态引起X31的概率分别为0.3、0.6和0.2.作为对文献[22]中提出的DCD的发展,本文提出任何DCD的逻辑门均可用表3来说明其逻辑关系.这个表被称为逻辑门说明LGS(LogicGateSpecification).图11(a)中,LGS4说明G41=X11∪X21.这里,G4代表的是或门,并且只有一个活跃状态.但在图11(c)中,G4有3个活跃状态.表达不同逻辑关系的逻辑门的图形符号不必有差别.我们只需用统一的图形符号来代表任何逻辑门,同时用表3定义的LGSi来说明其中不同的逻辑关系.这里,下标i用以区分不同的逻辑门变量以及其它变量.显然,图11(b)与图8(c)是等价的.图11(b)告诉我们的是:X11和X21可独立或共同地引起X31,因为按照DCD中的缺省定义,X11和X21对X31是逻辑或的关系.在DCD中,图11(b)的条件概率Pr{X31|X11X22}和Pr{X31|X12X21}被看成是两个独立的连接事件P31;11和P31;21的发生概率,即Pr{X31|X11X22}=Pr{P31;11}=p31;11,Pr{X31|X12X21}=Pr{P31;21}=p31;21.实际上,当人们给出Pr{X31|X11X22}时,人们考虑的仅仅是X11而不是X22,甚至可能根本没有意识到X2的存在.对于Pr{X31|X12X21}来说,情况也是同样的.这是因为X1和X2通常处于不同的领域.例如盗窃和地震尽管都能引起振动从而触发警报,但却属于完全不同的领域,人们很难把它们结合起来考虑,通常是分别考虑.这种情况可以用图12来进一步解释.图中X31既可以被X11引起也可以被X21引起.X31仅被X11引起这一事件记为X31;11;X31仅被X21引起这一事件记为X31;21.X31;11或X31;21之一发生或同时发生均可引起X31发生.在X31;i1和Xi1(i∈{1,2})之间存在一个不确定的作用机理.给定Xi1发生,当这个机理起作用时,X31;i1发生;当这个机理不Page10它只能是一个独立的原因;同时也可以是原因事件或变量;起作用时,X31;i1不发生.在DCD中,这个不确定的作用机理由事件P31;i1来表达.P31;i1可被理解为:在Xi1发生的条件下,Xi1引起X31;i1、从而引起X31这样一个随机事件.P31;i1的发生与否表达了Xi1引起X31;i1从而引起X31的不确定性.采用事件表达式的表述:X31;i1=P31;i1Xi1.其中,P31;i1和Xi1处于逻辑与的关系.由于P31;i1是否发生是不确定的、且独立于任何其它因素,可知P31;i1是一个独立的随机事件.DCD和DUCG中的一些特定类型变量的定义:X代表结果或效果事件或变量,画为圆形.它B代表基本或根(root)事件或变量,画为矩形.G代表逻辑门事件或变量;P代表连接事件或变量.其中,犘n1;i代表事件矩阵[Pn1;i1Pn1;i2…Pn1;im].图13是这些变量应用的示例.如图13(a)所示,Pn1;i1、Pn1;h1和犘n1;g分别为从父事件或变量Xi1、Bh1和Gg到子事件Xn1之间的有向弧.作为单赋值变量,Xn只有一个赋值状态:Xn1.作为Xn1的父变量,Xi有一个活跃状态Xi1,Bh有一个活跃状态Bh1,Gg有多个活跃状态.这就是为什么连接事件Pn1;i1、Pn1;h1和连接事件矩阵犘n1;g被分别使用的原因.为简单起见,Pn1;i1、Pn1;h1、犘n1;g和变量状态通常被省略.于是图13(a)通常被画成图13(b).系写为事件的积之和的表达式:借助于P事件,我们可以将图11(b)的因果关X31=X31;11∪X31;21=P31;11X11∪P31;21X21(27)在X11X21的条件下,我们有应用概率论的容斥原理或迪·摩根定律,我们有Pr{X31|X11X21}=Pr{P31;11∪P31;21}=Pr{P31;11}+Pr{P31;21}-Pr{P31;11}Pr{P31;21}=p31;11+p31;21-p31;11p31;21=0.3+0.6-0.3×0.6=0.72,或Pr{X31|X11X21}=Pr{X31|X11X21}=1-Pr{珡X31|X11X21}=1-Pr{P31;11X11∪P31;21X21|X11X21}=1-Pr{P31;11∪P31;21}=1-Pr{珚P31;11珚P31;21}=1-Pr{珚P31;11}Pr{珚P31;21}=1-(1-0.3)(1-0.6)=0.72.后者正是noisy-OR告诉我们的.在noisy-OR中,1-pnk;ij≡Pr{珚Pnk;ij}被看成是图8(c)中的禁事件(inhibitor)Ii的发生概率.我们可以将X11和X21又作为两个子事件,继续按照式(27)展开X31的方式将其展开为事件的积之和的表达式.在DAG的情况下,这个过程可以一直持续到B类型变量而结束.这个过程被称为事件展开.任何事件或以任何逻辑关系组成的事件的集合都可以按照这种方式展开为事件的积之和的表达式.在展开过程中,逻辑运算中的与、或、非、互斥或、吸收、互斥、取补等算法都可以应用.例如,设我们的问题是“Pr{Hkj|E}=?”.其中Hkj代表所关注的假设事件或事件表达式(例如H11=B12,H21=X11,H22=X12,H31=X21B13,H32=X22B12等等),E代表一组处于逻辑与关系中的事件.按照条件概率公式,我们有我们可以将HkjE和E分别展开为两个仅由P和B类型的事件组成的积之和的事件表达式,通过逻辑运算使得表达式积内去重、积间互斥,然后将表达式中的大写字母(P或B类型事件)替换为小写字母(p或b类型参数),即可算出Pr{HkjE}和Pr{E}的值,进而用式(28)算出Pr{Hkj|E}的值.这里,进行概率计算的事件表达式必须是互斥的积之和的表达式.为获得互斥积之和的事件表达式,我们可以反复应用下述公式(详见文献[22]):C1∪C2∪…∪Cn=C1+珚C1C2+珚C1珚C2C3+…+珚C=V1j1V2j2…Vmjm=珚V1j1+V1j1珚V2j2+V1j1V2j2珚V3j3+…+其中,V∈{X,P,G,B},C=V1j1V2j2…Vmjm,ji是变量Vi的状态下标、“+”是互斥或算符.C通常被称为割集(cutset)、代表不同展开阶段的事件的积.反复应用式(28)和(29),同时应用事件的上述算法,我们即可得到仅由P和B类型独立事件组成的互斥的积之和表达式.简而言之,上述算法由两步组成:(1)通过事件展开获得仅由P和B类型事件组成的Page11互斥积之和的事件表达式;(2)用小写字母替换表达式中相应的大写字母进行数值计算.有时,我们只需要第1步即可得到推理答案.例如:在一些诊断类问题中,我们通过第1步发现HkjE≠0,HgyE=0.这里,“0”代表空集,Hgy代表除Hkj外的所有其它可能假设.于是,我们无须数值计算即知Hkj是给定证据E条件下的唯一可能的诊断结果,概率参数无用.在以下各节中,我们将会看到这种算法带给我们的巨大的表达和推理方面的好处.在结束介绍DCD之前,必须指出,DCD能够表达各种复杂的不确定因果关系,例如但并不限于图14~21所示.在图21中,j标识父变量的状态组合.理论上,任何CPT都可以用图21所示的DCD的全组合逻辑门来表达.显然,全组合逻辑门等价于CPT.这是最坏的情况,因为应用全组合逻辑门实际上并不能获得表达上的简洁性.然而,全组合逻辑门却显示了DCD具有尽可能简洁地表达任何不确定因果关系的能力.需要说明的是,一个逻辑门可以是另一个逻辑门的输入变量,多个逻辑门可以是同一子变量的父变量,逻辑门可以是子变量的部分父变量(如图20所示).因此,逻辑门的确是简洁表达变量间各种复杂的不确定因果关系的一种强有力的工具.应当指出,文献[25]提出的因果独立模型(CausalIndependenceModel,CIM)中的确定作用函数(DeterministicInteractionFunction)f(I1,…In)与逻辑门Gg有类似之处.在CIM中,I1,…,In是子变量Xg和其父变量V1,…,Vn之间的中介变量;Pr{f(I1,…,In)|I1,…,In}与Pr{Ggk|SCPVg;j}类似:只能等于1或0.其中,SCPVg;j代表逻辑门Gg的输入变量或Xg的父变量的第j个状态组合.f(I1,…,In)与Gg的区别在于:(1)Ggk不等于Xgk,但f(I1,…,In)等于Xgk;(2)前者用Pr{Ii|Vi}的乘积来计算不确定性,其条件是V1,…,Vn彼此独立.后者的输入变量彼此可相关;(3)对应于f(I1,…,Page12In)的V1,…,Vn是子变量的所有父变量,但逻辑门的输入变量可以是子变量的部分父变量,且逻辑门可以作为其它逻辑门的输入变量.有人认为逻辑门虽然统一了对任何逻辑关系的表达,但其增加的图形表达比隐含了任何逻辑关系的CPT的表达更复杂,从而否定引入逻辑门的意义.但如果注意到逻辑门所具有的CPT所没有的强大的简洁表达功能,这种否定就不成立了.其实,引入逻辑门的更重要的意义还在于其导致了DCD中连接事件的引入和事件展开算法的引入,这使得DCD不仅能处理DAG(有向无环图),而且能处理DCG(有向循环图,详见文献[22]).3.2对DCD的进一步发展:S-DUCGS-DUCG(Single-valuedDUCG)在DCD的基础上增加了两个工具:条件连接事件和缺省事件.3.2.1条件连接事件在图20中我们注意到,X11和X21同时发生引起X31的概率是0.72而不是0.6,但0.6却可能是人们主观上想要表达的.图20所展示的直观想法是:当仅X11发生时,X31的发生概率为0.3;当X11X21发生时,X31的发生概率为0.6.然而,由于P31;11和P31;41处于逻辑或的关系,X11X21引起X31的概率从0.6增加到了0.72,而这并不是人们想要表达的.为避免这种增加,可将图20改为图22.其中,被定义为条件连接事件.P31;11的条件被记为Z31;11=珡X21=X22.即,当X21不存在时,P31;11存在,否则P31;11不存在.这里,P31;11绑定了Z31;11,并且可被表达为P31;11Z31;11=P31;11X22.一般来说,条件连接事件Pnk;ij和条件连接事件矢量犘nk;i的条件可被分别记为Znk;ij和犣nk;i,带条件的Pnk;ij和犘nk;i可被分别表达为Pnk;ijZnk;ij和犘nk;i犣nk;i.其中,在单赋值情况下,k标识子变量的赋值状态.以图22为例,n=3,k=1,事件表达式为X31=P31;11Z31;11X11∪P31;41G41=P31;11X22X11+P31;41X11X21,Pr{X31}=Pr{P31;11X22X11+P31;41X11X21}Pr{X31|X11X22}=Pr{(P31;11X22X11+Pr{X31|X11X21}=Pr{(P31;11X22X11+显然,条件连接事件还可用于许多其它情况,DCD的表达能力可由此得到极大扩展.以文献[6]的盗窃警报系统为例,如果盗窃(X11)和地震(X21)通过相同的作用机理(振动)引起警报(X31),我们可以用图23而非图18来表达其因果关系.其中,Z31;11=珡X21=X22.图23中,仅当无地震时,盗窃产生的振动对于警报才有意义.反之,当同时出现地震时,其振动远远超过盗窃的振动,使得盗窃振动并不能增加报警响的几率.在地震的强振动下,仍然不确定的是报警装置是否正常.因此,X11和X21的同时发生并不能增加X31发生的概率,仍应为0.9,而不是0.9+0.8-0.9×0.8=0.98.进而,设老鼠(X41)也能引起振动,其概率为0.6.即老鼠、盗窃和地震都能引起振动,从而引起警报.但老鼠振动并不能加强盗窃振动,老鼠和盗窃振动并不能加强地震振动,则报警系统的不确定因果关系将如图24所示.其中,Z31;41=X12X22,Z31;11=X22.应当指出,绑定于Pnk;ij的条件Znk;ij的内容是很宽泛的.事实上,Znk;ij可以是任何可判定其真伪的事件.这个事件不仅包括子变量Xn的父变量处于Page13何种状态,也包括因果图中任何地方的任何变量的状态,甚至包括因果图中不能图形表达的事件.例如,等等.其中,Xgm和Phy;gm可出现在因果图中的任何地方;λ、β和σ可以是任何包含或未包含在因果图中的物理参数;E1和E2可以是任何包含或未包含在因果图中的事件.基于所观察到的证据或事件展开的结果,Znk;ij可以被判定为真(Znk;ij=1),也可以被判定为假(Znk;ij=0).如果Znk;ij是否发生无法判定,则包含Znk;ij的事件表达式必须与(Znk;ij+珚Znk;ij)相乘再展开,并且Znk;ij的验前概率分布也必须被给定.否则该事件表达式的概率将无法计算.当然,这种情况并不常见,因为定义Znk;ij时就应当考虑到可判定其真伪.由上可见,本文提出的条件连接事件可以表达远比CSI或文献[26]提出的CBN(ContingentBayesianNetwork)所能表达的更为复杂的逻辑关系.仅当Znk;ij只涉及Xn的父变量的状态时,条件连接事件的表达才类似于CSI和CBN,但其推理算法仍不同.实际上,当条件连接事件仅仅涉及父变量的状态时,其所表达的内容也可以被DCD的逻辑门替代.但即使在这种简单情况下,条件连接事件的表达也比逻辑门更加直观方便,何况条件事件并不局限于父变量的状态.用新增变量替代条件连接事件来表达相应的条件逻辑关系也是有可能的.但是,在许多情况下,新增变量非常困难.例如,X11早于X21发生这一事件就很难用新增变量的方式来表达,因为X11和X21在因果图中已经存在.对于Znk;ij=珚Phy;gmXgm的情况,由于Phy;gm是有向弧,也很难用新增变量来表达.实际上,珚Phy;gmXgm意味着虽然Xgm发生,但Xhy并未发生,因为Phy;gm未发生.这个绑定于普通连接事件的条件在实践中很常见,却很难用新增变量的方式来表达.可见,条件连接事件为表达变量间复杂的逻辑关系提供了一个方便和直观的图形工具,其引入是对现有不确定因果关系表达的实质性扩充.最后应当指出,条件连接事件的意义已经超出了对CPT的简洁表达的意义.因为在一个CPT中,一旦给定父变量的状态组合,子变量的状态概率分布就给定了.但在条件连接事件包含父变量以外的事件、或包含父变量事件发生顺序的情况下,CPT不仅取决于父变量的状态组合,还取决于其它事件.这已经超越了BN中CPT的定义.所以,本文引入的条件连接事件已经突破了BN的理论框架.3.2.2缺省事件文献[18-20]指出,在许多情况下,子变量的原因并不能被全部表达在模型中.换句话说,即使子变量的所有父变量都处于false状态,子变量仍可能存在缺省的非(0,1)的状态概率分布.这个概率分布是由某些未知的或未能明确表达的原因引起的.这些原因可用Leak[18,20]或Dummy[19]变量表达.Leak或Dummy变量的状态只有一个:true.即这是一个发生概率恒等于1的必然事件.但为方便起见,我们仍称其为变量,尽管它的状态永不改变.为反映Leak变量对概率计算的影响,文献[18]提出了如下公式Pr{Xn|∩m其中,Xi(i∈{1,…,m},i≠n)是显式(explicit)表达的Xn的原因事件,pn;0为Leak事件导致Xn事件发生的概率.然而,上述公式仅当不存在或只有一个显式原因时才好理解.当显式原因多于一个时,多出的原因的概率贡献就都被放大了1/(1-pn;0).这让人费解.文献[18]并未给出解释.在S-DUCG中,Xn的这个未知或未明确表达的原因被定义为缺省变量Dn,并用图形表示.与其它变量类似,由一个连接变量Pnk;nD将Dn与Xn相连.Dn与其它变量的唯一区别在于Dn只有一个必然发生的状态,即Pr{Dn}≡1.在许多情况下,仅当所有显式表达的原因事件均不存在时,Dn才起作用,并导致Xn的缺省概率分布.如图25(c)所示,设Page14Z31;3D=珡X11珡X21=X12X22,则CPT如图25(a)所示.与图22比较,Pr{X31|X12X22}=0.1而非0.这是因为有了来自Dn的贡献.当然,Dn也可以按其它方式使用.如上例,我们可以定义Z31;3D=珡X11=X12,则CPT将如图25(b)所示.又如Dn可以被当作一个普通的变量对待,用普通连接事件Pnk;nD而非条件连接事件将其连接到Xn,则Dn将作为一个背景变量发挥作用.4多赋值情况下的M-DUCG模型基于文献[18]提出的扩展noisy-OR方法的基本思想,文献[19]和文献[20]分别提出了两个适用多赋值情况的具体方案,但只能用于梯度变量.本文提出的M-DUCG模型则可用于任何情况.4.1M-DUCG的基本概念作为本文提出的DUCG模型的组成部分,M-DUCG是处理多赋值情况的一个新的理论模型.本节和以后各节将循序予以说明.首先,M-DUCG基于如下假设.假设1.设Vi(V∈{X,B,G})是Xn的父变量,则下式成立:其中,ji标识父变量Vi的状态;rn;i定义为Xn和Vi之间的关联度;rn≡∑i在Viji已发生的条件下Viji独立导致Xnk发生这一随机事件.为与S-DUCG中的连接事件相区别,Ank;iji被称为父事件Viji与子事件Xnk之间的作用事件.值得注意的是,式(31)是由绑定了系数(rn;i/rn)的事件组成的积之和的表达式.图26是对这个假设的解释.其中,为简单起见,i∈{1,2,…,m},n{1,2,…,m}.注意:图中有向弧的形状是,而不是,也不是.前者表达的是权重后的独立因果链接.换句话说,标识了CPT中的父变量;代表连接事件变量;代表权重后的作用事件变量犉n;i≡(rn;i/rn)犃n;i.其中,犃n;i是一个以Ank;iji为元素的事件矩阵,k标识矩阵的行,ji标识矩阵的列;犉n;i≡(rn;i/rn)犃n;i被称为权重作用事件变量,是一个事件矩阵,其元素为Fnk;iji≡(rn;i/rn)Ank;iji.为简单起见,在不引起混淆的情况下,ji可简记为j.对Ank;ij的解释类似于图12中对Pnk;ij的解释.图12和图26有两个显著的区别:(1)在图12中,X31;11和X31;21的关系是逻辑或(OR);在图26中,Xnk;ij和Xnk;ij(j≠j)的关系是互斥或(XOR);(2)在图26中,权重系数(rn;i/rn)被绑定于Ank;ij;在图12中,没有任何系数被绑定于Pnk;ij.类似于Pnk;ij,Ank;ij代表Vij已发生条件下Vij确实引发Xnk;ij的不确定作用机理.如果这个机理起了作用,则Xnk;ij,从而Xnk发生;如果这个机理未起作用,则Xnk;ij=0(空集).由于这个作用机理独立于任何其它因素,Ank;ij是一个独立的随机事件.当然,对于k≠k,Ank;ij与Ank;ij互斥,因为Xnk与Xnk互斥.定义ank;iji≡Pr{Ank;iji},则ank;iji(简记为ank;ij)就是由领域工程师分别给定的原始参数.通常情况下,这些参数满足这对应于式(33)中,“1”代表全集.对rn;i的解释如下:在某些情况下,领域工程师对Vi和Xn之间是否存在因果关系没有把握.这类不确定性由rn;i表征.即(a)当领域工程师确定两者之间存在因果关系时,rn;i=1;(b)当领域够工程师确定两者之间不存在因果关系时,rn;i=0;(c)介于(a)和(b)之间的情况由0<rn;i<1表达.由于(b)不可能出现,因为rn;i=0意味着Vi不是Xn的父变量,所以rn;i≠0.于是我们有1rn;i>0.又由于rn;i总是以(rn;i/rn)的形式出现,因而rn;i是否1并不重要.有时,人们也可以用rn;i>1来强调Xn与Vi之间的关联度高于Xn与其它父变量之间的关联度.于是,1rn;i>0的限制条件被放松为rn;i>0.实际上,真正起作用的是(rn;i/rn),它是Vi对Xn的概率分布的贡献的权重.由于权重系数(rn;i/rn)的存在,尽管Ank;ij能够导致Xnk;ij从而导致Xnk,但其概率却因其它父变量的平衡而被缩减(rn;i/rn).注意:具有不同的k或j但相同的n和i的Ank;ij在引起Xnk;ij从而Xnk的时候绑定了相同的权重(rn;i/rn).Page15按照式(31),运用事件算法(例如V11|V11V22=1和V11|V12V22=0),我们可以很容易地得到下述结果:xnk≡Pr{Xnk}=∑i=∑i其中,viji≡Pr{Viji}.应用相同方法,读者不难得出在部分父变量状态组合条件下的结果.以上我们看到,式(31)分别说明了子变量不同状态的原因,这是多赋值情况的简洁表达所需要的.下面我们证明式(31)自动满足子变量状态概率归一.证明.根据∑k∑irn;i,由式(31),我们有∑kXnk=∑k∑i应当注意到:在M-DUCG中,父变量因权重系数(rn;i/rn)的存在而相关,同时参数ank;ij和rn;i又是独立给定的,可见,M-DUCG巧妙地解决了子变量的状态因互斥而相关和各父变量与子变量的因果关系独立表达之间的矛盾.这使得我们能够在多赋值情况下简洁表达CPT.例如,设1个子变量和5个父变量各有5个状态,则CPT的参数有56=15625个.采用M-DUCG的简洁表达,其参数仅有53+5=130个.本质上,假设1是建立在如下认识基础之上的:每个父变量独立贡献一个被权重了的子变量的状态概率分布,所有父变量贡献的权重后的状态概率分布之和构成子变量的最终状态概率分布,子变量究竟处于哪个状态由这个概率分布随机决定.这个认识非常简单,实际上就是领域工程师对客观世界的直观认识.因而,M-DUCG很容易应用,尤其适用于参数由领域工程师根据自己的经验直接给定的情况.图27为M-DUCG的一个例子.其中,子变量Xn有两个父变量V1=B1和V2=B2;3个变量各有3个状态;Xn的任何状态都可以由任何一个父变量的任何一个状态独立引起.本例反映的是两个父变量属于两个独立的领域、且子变量的各状态处于完全等价地位的情况.基于M-DUCG,领域工程师可以很容易地给出参数ank;ij,bij≡Pr{Bij}和rn;i.例如,图27的参数可被分别给定如下:Xn和B1之间的参数:犪n;1≡犫1≡[b11b12b13]T=[0.30.50.2]T,rn;1=1.Xn和B2之间的参数:在B11B21发生的条件下,按照式(34),犪n;2≡犫2≡[b21b22b23]T=[0.40.40.2]Trn;2=3,这里假定了Xn与B2的关联度是Xn与B1的关联度的3倍.于是,rn=rn;1+rn;2=1+3=4.本例中我们看到,与B1和B2有关的两组参数是分别独立给定的.事实上,究竟rn;1=1和rn;2=3还是rn;1=0.3和rn;2=0.9无关紧要,因为两者都有(rn;1/rn)=0.25和(rn;2/rn)=0.75.可见,rn;i的大小只具有相对意义.Pr{Xn1|B11B21}=(rn;1/rn)an1;11+(rn;2/rn)an1;21Pr{Xn2|B11B21}=(rn;1/rn)an2;11+(rn;2/rn)an2;21Pr{Xn3|B11B21}=(rn;1/rn)an3;11+(rn;2/rn)an3;21正如预期,∑3k=1以同样的方式,我们可以算出Xnk在B1和B2的其它状态组合下的条件概率.应用式(35),Xnk的无条件概率也可以很容易地算出为Pr{Xn1}=0.4475,Pr{Xn2}=0.625和Pr{Xn3}=0.2875.正如预期,Page16∑3k=1应当指出,与现有方法不同,上述归一化结果是在没有应用任何归一化公式的情况下自动获得的.这意味着M-DUCG允许我们直接计算所关注的Pr{Xnk}或Pr{Xnk|E},而无须计算我们并不关注的Pr{Xnk}或Pr{Xnk|E}.其中,E代表任何证据或条件.本文后面将表明,M-DUCG的这一特性为人们建造知识库和进行概率推理提供了巨大的方便.M-DUCG除可用于多赋值情况外,还可用于单赋值情况.在单赋值情况下,仅子变量的true状态的原因由式(31)说明.false状态则是true状态的补集.如图8的情况,设a31;11=0.3,a31;21=0.6,r3;1=1,r3;2=1,我们有Pr{X31|X11X21}=(r3;1/r3)a31;11+(r3;2/r3)a31;21Pr{X32|X11X21}=1-0.45=0.55,Pr{X31|X11X22}=(r3;1/r3)a31;11=(1/1)×0.3Pr{X32|X11X22}=1-0.3=0.7,Pr{X31|X12X21}=(r3;2/r3)a31;21=(1/1)×0.6Pr{X32|X12X21}=1-0.6=0.4,Pr{X31|X12X22}=0;Pr{X32|X12X22}=1-0=1,所得CPT如图28所示.显然,图28中的CPT不同于图8(a)中的CPT.这意味着M-DUCG确实表达并响应了不同的知识.注意,图28中X11和X21导致X31的概率是(0.3+0.6)/2=0.45,而不是图8(a)中的0.72.这是因为在M-DUCG中,r3;1=r3;2=1,r3=r3;1+r3;2=2,导致最终结果是X11和X21的贡献的平均值,而不是S-DUCG中两者贡献的逻辑或所产生的值.如果令r3;2=3,我们有r3=r3;1+r3;2=4,则Pr{X31|X11X21}=(1/4)×0.3+(3/4)×0.6这是因为X21的贡献权重是X11的3倍.应当指出,式(34)和(35)看起来与文献[23]的结果类似.在文献[23]中,类似的公式为Pr{Xnk|∩iViji}=∑iPr{Xnk}=∑i其中,式(36)是一个假设.但仔细分析可知,式(36)、式(37)与式(34)、(35)相比有本质的不同,因为证明.按照式(31),Pr{Xnk|Viji}=(rn;i/rn)Pr{Ank;iji}+最后,文献[23]指出简洁表达方式应当具备充分性(sufficiency)和可分离性(separability).在M-DUCG中,这两者都实现了.4.2M-DUCG中的逻辑门实践中,子变量和其父变量之间的逻辑关系并非总如4.2节所述这般简单.在复杂情况下,可利用逻辑门.类似于3.1节所述,逻辑门Gi可以用表3所示的LGSi说明.如图29示例,设B1、X2、X4、B5为二状态变量,LGS3如图30所示.图29中,X4有两个父变量:G3和B5.应用式(31)和图30所示之LGS3,我们有X4k=(r4;3/r4)∑2=(r4;3/r4)(A4k;31(B11∪X21)+=(r4;3/r4)(A4k;31B11+A4k;31B12X21+与S-DUCG中的情况类似,最复杂的情况可以用全组合逻辑门来表达.如上例,设G3为全组合逻辑门,我们有X4k=(r4;3/r4)(A4k;31B11X21+A4k;32B12X21+Page17全组合逻辑门等价于对应的CPT.然而,在DUCG中,一个CPT可以只包含部分父变量.如上例,G3所表达的CPT仅包含B1和X2这两个父变量,不包含B5.在DUCG中,我们仍用有向弧来表达子变量与包含于一个CPT中的部分父变量之间的因果链接.如上例,当G3是一个全组合逻辑门时,图29可被简单且等价地表达为图31.当然,在图31中,B5也可以被包含在CPT中.但在某些情况下,我们需要这种分开表达.例如,设以B1和X2为父变量的CPT已从统计数据中获得.如果我们想采取措施改变目标系统的状态(例如,采取某种政策来改变某经济系统的状态),我们可能就需要图31所示的分开表达.其中,B5代表拟采取的政策,任务是预测各种政策选项的效果,以便我们能够做出较好的决策.在这种情况下,我们没有包含了B1、X2和B5的统计数据可用,只有X2和B5的统计数据及独立的领域专家关于B5影响X4的经验知识可用.注意,我们在加入了B5变量后,B1和X2仍在继续影响X4.于是,我们必须判断以B1和X2为父变量构成的CPT4;3影响X4的权重r4;3和B5影响X4的权重r4;5.这种情况正是图31所表达的.以上对以B1和X2为父变量构成的CPT加上了下标“4;3”,是因为这个CPT对应于图29所示的逻辑门G3.为简单起见,类似的表达将不再逐一说明.进而,这种分开表达的同一个子变量的CPT可以不只一个.图32是一个示例,它等价于更容易被理解的图33.在图33中,G3和G10是全组合逻辑门.我们不只需要一个CPT的原因在于不同的领域工程师可能有不同组别的统计数据.这些不同组别的数据是由不同的领域工程师各自收集的,无法合成为一组数据.于是我们不得不面对由不同组别数据构成的不同的CPT,并按图32或图33所示方式将它们结合使用.此外,不同的CPT可以共享同一个父变量.这种情况如图34(a)或(b)所示(共享X2).注意,包含于CPT中的父变量也可以同时是独立的父变量(如图中的B6).图34共享父变量且多于一个CPT的情况示例读者可能已注意到,图32中的X6、B8、B9可被包含在一个CPT中.但有时采用多重逻辑门可以使表达更简洁.例如,设X6、B8和B9各有3个状态、LGS7如图35所示.则在CPT4;10中,只需要3×2=6个参数.如果我们将X6、B8、B9作为一个CPT中的父变量对待,该CPT的参数将达33=27个.最后,领域工程师给出的LGS可不必覆盖输入变量的所有状态组合,因为领域工程师可能只关心这些输入变量状态组合中的一部分.在这种情况下,如图35所示的一个输入变量的剩余状态可被自动加入到逻辑门中,该状态代表所有LGS中未显式表达的输入变量状态的剩余组合.如图30示例,设B1和X2各有3个状态,则图30所示的LGS3是不完备的,必须加上剩余状态G33=B13∪X23,才能覆盖B1和X2的所有状态组合.在加入了如图35所示的剩余状态后,这时的LGS被称为完备的(未必是全组合的).对于完备的LGSi,逻辑门变量Gi可被作为一个与Bi或Xi类似的普通变量对待,即Gi的状态互斥且完备.Page18证明.∑jPr{Gij}=∑j应当注意,LGS中的每个逻辑表达式中事件乘积的互斥可通过应用式(29)和(30)得到.如图35示例,图36图3和图4示例的M-DUCG表达图37图36中的CPT4(表达子变量X4的BN类型的CPT)在本例中,设r4;7=r4;8=1,于是r4=r4;7+r4;8=2.应用式(34),CPT4可算得如图37(a)所示.其结果与表1显然不同.如果将表1的pi改为表2所示的新pi,对应的改变是新的a4k;7j和a4k;8j,则在M-DUCG中算得的新CPT4如图37(b)所示.显然,结果与图37(a)不同.注意:第2节中用式(1)计算表2所示两套不同pi参数所对应的CPT时,结果均如表1所示,无变化.而本节我们看到,在M-DUCG中,这两套参数算出的CPT是不同的.这反映了M-DUCG对参数变化的响应.不仅如此,如果r4;7≠r4;8,计算结果也将与图37(a)和(b)所示不同.这是因为在M-DUCG中,(rn;i/rn)是有实质意义的参数.4.3M-DUCG中的条件作用事件类似于S-DUCG中的条件连接事件,M-DUCG引入了条件作用事件.以图38为例,A4k;1j为一个条件作用事件.设其条件为犣4;1=珡X21,即仅当X21不存在时,A4k;1j才可能发生.一般地,犣n;i为一个以Znk;ij为元素的事件矩阵,或为一个对所有Ank;ij都相同的表达式中所有事件的乘积均互斥的LGS称为互斥LGS.采用互斥LGS,DUCG中的事件表达式与计算该事件的概率的表达式相同.因而在展开逻辑门的时候,宜采用如图30和图33所示的互斥LGS.为进行比较,下面用M-DUCG来处理图3和图4所示的多赋值情况.在M-DUCG中,图3和图4所示的多赋值情况被表达为图36和图37.条件事件.于是,当观测到或给定X21后,犣4;1=0,导致r4;1=0,即X4和X1之间无因果关系;否则,A4k;1j成为普通的作用事件.本例中,应用式(31),人们可能直观地以为X4k=(r4;1/r4)犣4;1∑j1=(r4;1/r4)珡X2,1∑j1(r4;2/r4)∑j2但这一表达并不准确.此外,其中的r4是一个取决于条件犣4;1是否满足的不确定参数.通常情况下,基于观测到的证据,可判定条件犣n;i是否满足,因为Znk;ij的定义要求其可被观测.如果没被观测到,则犣n;i的验前概率必须被给定或通过某种方式被计算出来.如本例,Pr{犣4;1}=Pr{珡X21}=1-Pr{X21},其中Pr{X21}要么被给定、要么通过对X21的事件展开而被计算出来.与3.2.1节相同,当Z4;1未被观测到时,X4k的精确表达式应为X4k=(犣4;1+珚犣4;1)X4kPage19=(X21+珡X21)(r4;1/r4)珡X21∑j1(r4;2/r4)∑j2=(r4;2/(r4;2+r4;3))A4k;21X21+(r4;3/(r4;2+r4;3))X21∑j3(r4;1/(r4;1+r4;2+r4;3))珡X21∑j1(r4;2/(r4;1+r4;2+r4;3))∑j2≠1(r4;3/(r4;1+r4;2+r4;3))珡X21∑j3其中,珡X21=∑j2≠1全集)的归一化要求.最后X4k|X1j1X21X3j3=(r4;2/(r4;2+r4;3))A4k;21+X4k|X1j1X2j2X3j3=(r4;1/(r4;1+r4;2+r4;3))A4k;1j1+将式(38)和(39)中的大写字母用小写字母替换,我们即可很容易地算出Pr{X4k}和Pr{X4k|X1j1X2j2X3j3}.按照如上所述方法,读者可以自行求解条件作用事件的更复杂情况.类似于3.2.1节中的条件事件,犃n;i的条件犣n;i也可以是多样的,不限于Xn的父变量的状态.这突破了简洁表达BN中的CPT这一常规的理论框架.4.4M-DUCG中的缺省事件文献[18]提到,可将leak变量[18,20]作为一个新的父变量L对待.L在文献[19]中被称为dummy变量.L的特性在于它只有一个true状态,即Pr{L=true}≡1.类似于L变量,在M-DUCG中定义了缺省变量Dn,其定义与S-DUCG中Dn的定义完全相同.不同的是,S-DUCG中的连接事件Pnk;nD在M-DUCG中变成了权重作用事件(rn;n/rn)Ank;nD.其中,Ank;nD为Xnk与Dn之间的作用事件,rn;n为两者之间的关联度.与Ank;ij比较,Ank;nD的父变量只有一个状态,因为Dn只有一个状态.为方便起见,Ank;nD也可用Ank;ij代表.这时,i=n,j代表D.在多赋值情况下,尽管子变量各状态是等价的,仍可能存在一个特殊状态,标识为η.通常,η=0.这个特殊状态通常就是正常状态.例如,设变量Xi代表温度.我们可以定义Xi0=“正常”,Xi1=“偏高”,Xi2=“快速升高”,Xi3=“偏低”,Xi4=“快速降低”,等等.其中,Xi0代表正常状态,Xij(j≠0)代表非正常状态.实践中,人们通常并不关心变量的正常状态,而是关心其非正常状态.也就是说,正常状态通常不是赋值状态,其原因和结果通常不被说明,即:领域工程师通常不给出ai0;mg和ank;i0.在这种情况下,当所有非D类型父变量都处于正常状态时,子变量的状态概率分布将仅由缺省变量Dn引起,即Xn的状态概率分布为(rn;n/rn)Pr{Ank;nD}Pr{Dn}=Pr{Ank;nD}=ank;nD.这是因为在这种情况下,所有Ank;ij(i≠n,j≠D)均不存在,且rn=rn;D.通常,Ank;nD是一个条件作用事件,其条件为Znk;nD={Xn的所有非Dn父事件对Xn均无影响}.用矩阵的术语,犃n;n以犣n;n=Znk;nD为条件,其中Ank;nD是事件矩阵犃n;n的元素,Znk;nD是事件矩阵犣n;n的元素,所有元素均相同.在图形中,犃n;n被画成从Dn到Xn的虚线有向弧.当然,Dn也可作为常规父变量使用.这时Dn的作用是给其它父变量增加了一个子变量的背景概率分布.5DUCG:M-DUCG和S-DUCG的结合对于完备地表达CPD来说,S-DUCG或M-DUCG提供了对CPD的一种简洁表达.至于究竟是选择S-DUCG还是M-DUCG,取决于所表达模块的具体情况.模块(module)由一个子变量和其父变量(包括逻辑门)组成.在某些文献中(例如文献[19,21]),“模块”被称为“家庭”(family).应当注意到,家庭一词隐含着DAG结构,即所有变量之间只存在单向的血缘关系,不可能子孙同时又是祖先.但DUCG模型允许存在有向循环图DCG(将在后文讨论),即子孙可能同时又是祖先.因而在DUCG中,“家庭”一词被舍去而选用了“模块”一词.鉴于本文仅限于处理DAG情况,“模块”和“家庭”的含义大体相同.唯一的不同在于DUCG的模块包括了起中间连接作用的逻辑门变量(G类型变量)、连接或作用变量(P或A类型变量)及其条件变量(Z类型变量).如图34示例,子变量X4及其父变量B1、X2、B5和B6构成一个模块,既可以含逻辑门G3和G7(如图34(b)所示),也可以不含(如图34(a)所示).如图36示例,子变量X5及其父变量X1和X4构成一个模块;而子变量X4及其父变量X1、X2、X3、G7、G8则构成另一个模块.图11、图14~21也分别构成Page20模块.对于一个特定的模块,当子变量为单赋值时,S-DUCG和M-DUCG都可用;当子变量为多赋值时,仅M-DUCG可用.对不同的模块可自由选择应用S-DUCG或M-DUCG,并将这些模块简单连接构成一个因果图,即为DUCG.S-DUCG和M-DUCG的共同思想是用独立事件Pnk;ji或Ank;ij以及权重系数rn;i、逻辑门Gi、条件事件Zn;i和缺省事件Dn来简洁表达模块内子变量(X类型变量)与其{B,X}类型父变量(中间可能存在逻辑门变量)之间的不确定因果关系.在S-DUCG中,采用连接事件Pnk;ij;在M-DUCG中,采用绑定了权重系数(rn;i/rn)的作用事件Ank;ij.Pnk;ij和Ank;ij都表达相同的作用机理:父事件Vij(V∈{B,X,G,D})引发子事件Xnk.DUCG模型有3个优点:(1)能够直观简洁地表达模块内的各种复杂的不确定因果关系;(2)由于引入独立的连接事件或作用事件,当获得证据后,因果图可通过删除无关的独立事件而被大大化简,推理也变得非常容易(以后的章节将详细讨论);(3)在建造DUCG的过程中,不同的模块可由不同的领域工程师分别独立建造,只要求相同变量的定义保持一致即可.这样,分别独立建造的不同的模块可以由计算机自动进行简单连接而构成一个最终的DUCG,从而将大型复杂的DUCG建造问题变得非常简单.当然,如此建造的DUCG很可能会出现DCG结构,这是由于各个模块的简单连接造成的.限于篇幅,DCG结构将在以后讨论,本文只讨论DAG结构.需要指出的是,正是由于DUCG模型能够处理DCG结构,上述模块化的DUCG建造方法才是现实可行的.一个DAG结构的DUCG的示例如图39所示.该DUCG由3个模块构成:{X4,B1,B2}及其内部有向弧;{X5,B1,B2,B3}及其内部有向弧;{X7,G6,X4,X5,D7}及其内部有向弧.{}中的第1个变量为该模块的子变量.在图39中,犣5;1=犣5;2=B32,逻辑门G6的说明LGS6如图40所示.作为子变量的X4和X5是多赋值变量,各有3个状态;B1和B2是二状态变量;X7是单赋值变量(仅X71的原因被说明);{B,X,D}类型事件的定义如下:B11≡{老鼠出现};B12≡{无老鼠};B21≡{入侵者出现};B22≡{无入侵者};B31≡{地震发生};B32≡{无地震};X41≡{无红外线信号};X42≡{轻度红外线信号};X43≡{强红外线信号};X51≡{无振动信号};X52≡{轻度振动信号};X53≡{强振动信号};X71≡{警报响};X72≡{无警报};D7≡{导致警报响的未知原因}.这个入侵者探测系统有两个探测器:即红外线探测器和振动探测器.每个探测器的信号输出有3个状态:某些状态可以触发警报,另一些不能.警报对两个探测器信号的响应遵从LGS6所表达的逻辑关系.其中G63所表达的逻辑关系不能触发警报,也就是说,P71;63=0.然而,即使G63为真,警报仍有可能被某些未知的原因触发,这些原因可能是警报器的误响,等等.这些未知原因由D7表达.X4j(j∈{1,2,3})的原因有2个:B11和B21;X5j(j∈{1,2,3})的原因有3个:B11,B21和B31.仅当未发生地震时,B11和B21起作用,即A5j;11和A5j;21以Z5;1=Z5;2=B32为条件.此外,B12、B22和B32与X4和X5之间无因果关系.来自B1、B2和B3的关于X4和X5的关联度相同,即r4;1=r4;2=r5;1=r5;2=r5;3=1.本例的其它相关参数给定如下:犪4;11=[0.70.30]T;犪4;21=[00.30.7]T犪5;11=[0.60.40]T;犪5;21=[00.60.4]T;犪5;31=[00.10.9]T狆71;6=[0.90.70];p71;7D=0.005犫1=[0.10.9]T;犫2=[0.10.9]T;犫3=[0.010.99]T其中,至此,建造入侵者报警系统DUCG的任务完成.对Page21应的BN如图41所示.其中的3个CPT(CPT4、CPT5、CPT7)涉及54个参数,而图39中的{a,p,b,r}类型参数只有30个.需要注意的是,本例并没有给出参数犪n;i2≡[an1;i2an2;i2an3;i2]T.这是因为B12、B22和B32与X4和X5均无关.可见,本例的DUCG对于简洁表达一组变量(B1,B2,B3,X4,X5,X7)的联合概率分布来说是不完备的.事实上,根据图39和图40的DUCG及其参数无法算出图41的所有CPT,除非我们进一步给定犪n;i2(n∈{4,5},i∈{1,2,3}).换句话说,一个模块的DUCG简洁表达可能只表达了该模块CPD的部分内容,而非完备.含有表达不完备的模块的DUCG称为不完备DUCG.下一节我们将详细讨论不完备的DUCG.6不完备DUCG所谓完备表达,是指根据简洁表达所给定的参数即可算出对应的所有CPT或CPD.在上例中,DUCG的某些参数并未给定,导致并不能从给定的DUCG算出所有的CPT.不仅如此,图39的参数还可给定为犪4;11=[0.70.3-]T;犪4;21=[-0.30.7]T犪5;11=[0.60.4-]T;犪5;21=[-0.60.4]T;犪5;31=[-0.10.9]T狆71;6=[0.90.7-];p71;7D=0.005犫1=[0.1-]T;犫2=[0.1-]T;犫3=[0.01-]T其中,“-”代表缺失或无关.我们甚至可以将改成前者“-”的值实际上是“0”,后者“-”的值却不应当是“0”,但从效果上看等价于“0”(即没有因果关系).注意,这里的约束条件∑k实际上已被放松为∑k在DUCG中,人们可以只给出所关注的参数,而不考虑不受关注的参数.DUCG的这个特性导致DUCG尽管可以是、但也可以不是CPD的简洁表达.从本质上看,DUCG是人们关于现实世界的不确定知识的表达,而不必是一组变量的联合概率分布的表达.后者只是前者的一个特例.可见,不完备DUCG已经突破了BN的基本理论框架.DUCG可以不完备的原因在于DUCG的链式推理是自我依赖的.换句话说,在DUCG的推理中,Pr{Xnk}的计算与Pr{Xnk}无关,与ank;ij也无关.这里,k≠k.注意,在所有应用式(1)的模型中,Pr{Xnk}的计算与Pr{Xnk}都是相关的.在DUCG中,当我们根据式(35)计算Pr{Xnk}时,我们无须知道ank;ij(k≠k).这意味着DUCG的某些参数可以缺失,而不会影响我们所关注的的推理计算(精确计算).例如,设B1、B2和X3为二状态变量、X32=F32;11B11+F32;22B22.如果我们只关注X32,领域工程师只需要给出a32;11和a32;22,无须给出a32;12、a32;21、a31;11、a31;12、a31;21和a31;22.用概率表达式,我们有Pr{X32}=Pr{F32;11}Pr{B11}+Pr{F32;22}Pr{B22}其中,fnk;ij≡Pr{Fnk;ij}=Pr{(rn;i/rn)Ank;ij}≡(rn;i/rn)Pr{Ank;ij}=(rn;i/rn)ank;ij.可见,Pr{X32}的计算与Pr{X3j}(j≠1)及其输入作用事件无关.正是由于DUCG推理的自我依赖特性,才使得DUCG的表达可以是不完备的.这种不完备性可以大大降低建造DUCG的工作量和难度,再加上DUCG能够处理DCG,使得DUCG成为超越了BN的一个新的理论体系.换句话说,BN是DUCG的一个子集.当DUCG完备且无DCG时,DUCG是BN的一种简洁表达;当DUCG不完备或包含DCG时,DUCG就突破了BN的疆界.7在证据犈条件下化简DUCG一旦收到证据E,我们可以通过固定在E中已Page22确定状态的变量来初步化简DUCG.例如,设E=E1E2=B32X71,其中E1=B32,E2=X71.则图39的DUCG可被初步化简如图42所示.图42E条件下初步化简的DUCG(基于图39)图中,B32和X71是被固定的状态.这种初步化简的方法已在文献[27]中提出.该文献阐明了利用证据编译(compiling)BN的功效.本文下面将提出进一步化简DUCG的方法.其基本思想与文献[27-28]相同,即:将与E矛盾或与问题无关的变量删除.如图42示例,由于在E条件下犣5;1和犣5;2已满足,犃5;1和犃5;2成为普通作用变量,即从B1和B2到X5的虚线有向弧变成了实线有向弧.进而,由于犪5;32未给定(效果上与犪5;32=0相同),B32不是X5的原因.因而犃5;3在化简DUCG的过程中被删除.化简后的DUCG如图43所示.图43基于图42的在E条件下化简后的DUCG一般来说,我们可以应用下述规则来进一步化简已经初步化简的DUCG.规则1.如果E显示犣n;i不满足,将犉n;i或犘n;i从DUCG中删除;如果E显示犣n;i已经满足,则条件犉n;i或犘n;i成为普通犉n;i或犘n;i.规则2.如果E显示Vij(V∈{B,X})为真,但Vij却不是Xn的父事件,则将犉n;i或犘n;i从DUCG中删除.例如,设X32不是X5的父事件,当E显示V32为真时,将犉5;3从DUCG中删除.规则3.如果E显示Xnk为真,但Xnk不可能被Vi(V∈{B,X,G})的任何状态引起,则将犉n;i或犘n;i从DUCG中删除,但Vi是待求解假设事件中的某变量或其后代变量、且其间的因果关系未被已知事件阻断的情况除外.例如,设X53不可能被X2的任何状态引起,X2也不是待求假设事件中的变量或其后代,或虽是其后代但其间的因果链被已知事件阻断.则当E显示X53为真时,犉5;2被删除.规则3中的例外是指如下情况:当Xnk不可能由Vi的任何状态引起、但预期Xnk(k≠k)可由以包含在假设事件中的Vhg为起点的因果链(通过Vi)而引起时,Xnk成为Vhg的负面证据,从而降低Vhg发生的慨率.在这种情况下,Xnk和Vi与假设事件中的Vhg是相关的.此时犉n;i或犘n;i不能被删去.如果Vi和Vhg之间的因果链被任何确知事件阻断,则Xn与Vi之间的因果关系与假设事件不再相关.这时犉n;i或犘n;i可被删去.规则4.当E显示Xnk和Vij(V∈{B,X})为真,同时Xnk不可能由Vij引起时,将犉n;i或犘n;i从DUCG中删除.例如,当E显示Xnk和Bij为真,同时ank;ij=0或未给定,则犉n;i被删除.规则5.因任何原因导致Xn或Gn无输入变量,则将Xn或Gn及其输出有向弧从DUCG中删除.根据定义,Xn或Gn必须有输入变量,没有输入变量的Xn或Gn是无意义的,从而也与待求解问题无关,故被删除.Xn或Gn被删除后,以Xn或Gn为起点的输出有向弧当然也无意义,从而也被删除.需要说明的是,犉n;nD也是Xn的输入变量.当其存在时,Xn不能被删除.规则6.因任何原因导致Gi没有输出,则将Gi从DUCG中删除.例如,设Gi有两个子变量X1和X2.如果E显示X11和X21为真,同时X11和X21不可能由Gi的任何状态引起,导致应用上述规则3删除了犉1;i和犉2;i,进而导致Gi没有了输出,则Gi被删除.因为没有输出的逻辑门是无意义的,也与待求解问题无关.规则7.如果(1)Xn的状态未知;(2)Xn无输出;(3)未预知Xn包含在待求解的假设事件中,则将Xn及其所有输入有向弧从DUCG中删除.例如,设X3的状态未知、X3无输出、且不是预定包含在待求解的假设事件中的变量,则将X3和犉3;i从DUCG中删除.这是因为在给定E后,X3和犉3;i对确定所应当关注的假设事件以及计算这些假设事件在E条件下的概率没有任何影响.规则8.如果E显示Xnk及其因果链上游事件Vij为真,且Xnk早于Vij出现,即Vij不可能是Xnk的原因,则将Xnk和Vij之间因果链中的但与Xnk上游的其它因果链无关的F和P类型变量从DUCG中删除.例如,设E显示X43的出现早于其爷爷辈事件B22,在他们之间的变量为X1.如果无其它X43的上Page23游变量通过X1与X43相连,则将犉4;1和犉1;2删除.然而,如果B3也是X1的父变量(即B3也可以通过犉43;1而导致X43),则仅犉1;2可被删除,犉4;1不能被删除,因为犉43;1犉1;3B3仍是一条可能的因果链.应当指出,本规则比较特殊,是关于事件发生时序的规则,早在文献[22]中即已提出.本文只是将其延伸到M-DUCG.这个规则之所以能够应用,是基于DUCG将变量之间的不确定因果关系用A和P类型随机事件来表达.规则9.如果存在一组变量(称为独立组)与E中涉及的变量无因果连通关系,且不是预定关注的假设事件中的变量,则将这组变量从DUCG中删除.例如,设B1、X2以及犉2;1与E中涉及的任何变量无任何因果连通关系,同时它们也非预定关注其状态的变量,则删除B1、X2和犉2;1.这是因为在给定E的条件下,它们与寻找应受关注的假设事件及计算其概率无关.规则10.如果(1)E显示一组变量状态为正常,即Xnη为真,n∈SI,SI是这组变量的标识集;(2)存在另一组状态未知的{B,X,G,D,F,P}类型的变量,这些变量只与SI中的Xnη变量相连.换句话说,这一组变量(称为孤立组)被SI中的Xnη事件阻断而独立于其它变量;(3)孤立组中的变量非预定关注其状态的变量,则将孤立组变量从DUCG中删除.例如,设E显示X20和X40为真,即η=0、SI={2,4},变量{V3,V5,犉2;3,犉4;3,犉2;5,犉4;5,犉3;5}的状态未知,仅与X2和X4相连,其中并无预定其状态受关注的变量,则{V3,V5,犉2;3,犉4;3,犉2;5,犉4;5,犉3;5}成为孤立组变量,被从DUCG中删除.这是因为孤立组变量与其它变量的相关性被X20和X40阻断了,导致它们与寻找应受关注的假设事件及其概率计算的推理过程无关.规则1~10可按任何顺序反复应用.应当指出,规则1~10所进行的化简不同于文献[28]中提出的VE(VariableElimination)化简,因为VE化简基于特定问题“Pr{Xnk|E}=?”,规则1~10则仅基于E,所化简的DUCG可用于化简后仍存在的任何所关注的问题.当然,基于化简后的DUCG,仍可针对某具体问题应用VE和上述规则进行进一步化简.由于应用上述规则化简,原DUCG中的变量被分成了两组,分别用Sin和Sout的下标集合来标识.包含在Sin中的变量就是仍留在化简后的DUCG中的变量,包含在Sout中的变量则是应用规则1~10而被删除的变量.被删除的变量实际上是在E条件下与待求解问题无关的变量.也就是说,与待求解问题有关的变量在化简DUCG后已从原来的Sin+Sout减少为Sin.如图39和图43示例,Sin={1,2,4,5,7}、Sout={3}.实际应用中,往往SinSin+Sout.因此,应用规则1~10可以大大减少推理的工作量和难度.本文以下将仅讨论包含在Sin中的变量.换句话说,下面的讨论将基于化简后的DUCG,即只有仍包含在化简后的DUCG中的假设事件属于被讨论的范围.对于诊断(逆向推理)类问题,这意味着可能的根(root)或原因事件被减少为仅包含在Sin中的状态未知的B类型变量的状态.有时,Sin中仅仅包含一个状态未知的B类型变量.这时,诊断工作实际上已经完成,因为可能的原因事件已经被唯一并且精确地确定了.注意,这一结果的获得并不依赖于任何数值计算.因而,概率参数的精度在DUCG中显得不那么重要.这是DUCG的又一个优点.8基于化简后的DUCG的概率推理设Hkj是我们希望求其条件概率的假设事件,条件为所观察到的证据E=∩hEh=∩hVhyh.Hkj由{X,B,P,A}类型事件组成(P和A类型事件可作为推理的假设事件是DUCG的又一贡献),k标识在Hkj中的变量组合(例如Hk=B1X2),j标识这些变量的状态组合(例如Hkj=B11X23),Eh=Vhyh(V∈{X,B}),则Hkj的条件概率的计算公式为hskj≡Pr{Hkj|E}=Pr{HkjE}其中hskj被称为Hkj的状态条件概率.基于化简后的DUCG,我们可以采用两种方案计算hskj.第1种方案用CPT进行计算:当化简后的DUCG表达完备且无DCG时,我们可计算出各模块的CPT,亦即将化简后的DUCG转化为一个标准的BN,然后用现有的计算BN的方法进行推理计算.当化简后的DUCG表达不完备时,无法计算出所有模块的CPT(含DCG的情况将在下一篇文章中讨论),这时必须采用本文提出的第2种方案.第2种方案基于最早在文献[22]中提出的事件Page24运算算法.但文献[22]仅仅涉及DCD的情况.本文将其推广到DUCG的任何情况.第2种方案用式(40)进行计算.先将式中的∩hVhyh和Hkj∩hVhyh分别展开为由{B,A,P,D}类型事件组成的互斥积之和的表达式,然后用对应的概率参数(对应的小写字母)替代表达式中的事件(大写字母),从而算出hskj.在事件展开过程中,下述规则可能被用到,其中“1”代表全集、“0”代表空集.规则11.任给V∈{B,X,G,D},j≠j,整数y2,则(Vij)y=Vij,VijVij=0.证明.根据定义,Vij是一个事件.根据逻辑运算法则,(Vij)y=Vij.另据定义,同一变量的不同状态互斥,因而有VijVij=0.规则11有多种应用方式.例如,设E1=Xnk=Fnk;ijXij,E2=Xij,则有E1E2=Fnk;ijXijXij=Fnk;ijXij=E1.又如,设E1=Xnk=Fnk;ijXij,E2=Xij,其中j≠j,则有E1E2=Fnk;ijXijXij=0.规则12.给定整数y2,k≠k,j≠j,则(Fnk;ij)y=(rn;i/rn)yAnk;ij,Fnk;ijFnk;ij=0,Fnk;ijFnk;ij=0,Fnk;ijFnk;ij=0.证明.根据定义,(Fnk;ij)y=((rn;i/rn)Ank;ij)y.由于Ank;ij是一个事件,我们有(Ank;ij)y=Ank;ij,从而有(Fnk;ij)y=((rn;i/rn)Ank;ij)y=(rn;i/rn)yAnk;ij.根据规则11,当k≠k时,XnkXnk=0.这意味着Ank;ij与Ank;ij不能并存,即Ank;ijAnk;ij=0.类似地,当j≠j时,VijVij=0(V∈{X,B,G}).这意味着Ank;ij与Ank;ij不能并存,即Ank;ijAnk;ij=0.因而我们有Fnk;ijFnk;ij=(rn;i/rn)2Ank;ijAnk;ij=0,Fnk;ijFnk;ij=(rn;i/rn)2Ank;ijAnk;ij=0,Fnk;ijFnk;ij=(rn;i/rn)2Ank;ijAnk;ij=0.证毕.例如,设E1=Fnk;ijXij+Fnk;gyBgy,E2=Fnk;gyBgy,E3=Fnk;ijXij,其中k≠k.我们有E1E2=Fnk;ijXijFnk;gyBgy+(Fnk;gyBgy)2=(rn;irn;g/r2n)Ank;ijXijAnk;gyBgy+=Fnk;ijXijFnk;ijXij+Fnk;gyBgyFnk;ijXij=0.规则13.令Sm代表标号为m的变量标识集,m∈{1,2,…,M},S1S2S3…SM,则∑Mm=1∏i∈Sm证明.设E1和E2是两个事件.根据集合理论,E1∪E1E2=E1=E1∪E1,即一旦E1发生,相当于表达式中的E1E2也发生,即有E1E2=E1.类似地,∑Mm=1∏i∈SmFnk;ijiViji=∑M其中第3个“=”是因为在S1S2S3…SM的条件下,一旦∏i∈S1成立,即有∏i∈Sm例如,我们有F31;11V11+F31;11V11F31;22V22=(r3;1/r3)A31;11V11+(r3;1/r3)A31;11V11(r3;2/r3)A31;22V22=(r3;1/r3+(r3;1/r3)(r3;2/r3))A31;11V11,其中S1={1},S2={1,2},M=2.应当指出,规则13实际上定义了一种有别于常规集合理论的新算法.这是因为在M-DUCG中,A类型的事件总是绑定了权重系数(rn;i/rn).规则13指出:在保留集合理论的事件吸收算法的同时,不应由于A类型事件的吸收而导致其权重系数消失.如上例,A31;11V11A31;22V22应当被A31;11V11吸收,但绑定于A31;11V11A31;22V22的权重系数(r3;1/r3)(r3;2/r3)不应因此而消失.换句话说,事件运算和权重系数运算都应当进行.规则14.令j=ji,则证明.i是式中的i的取值之一.运用与规则13相同的概念,我们有Fnk;ijVij∑i=(Fnk;ijVij)2+Fnk;ijVij∑i≠i=(rn;i/rn)2Ank;ijVij+(rn;i/rn)∑i≠i=(rn;i/rn)2Ank;ijVij+(rn;i/rn)∑i≠i(=(rn;i/rn)2+(rn;i/rn)∑i≠i(=(rn;i/rn)∑i=(rn;i/rn)Ank;ijVij=Fnk;ijVij.Page25规则14看起来似乎表明来自不同父变量的权重作用事件Fnk;ij彼此互斥,即给定i≠i,Fnk;ijFnk;ij=0,同时(Fnk;ij)2=Fnk;ij.但这种理解不对,因为(1)Ank;ij和Ank;ij彼此是独立的;(2)根据规则12,(Fnk;ij)2=(rn;i/rn)Fnk;ij,而不是(Fnk;ij)2=Fnk;ij.限于篇幅,效率更高的基于事件矩阵和概率矩阵的算法将在下一篇文章中介绍.图42为一个应用示例.通过化简得到图43所示的化简后的DUCG后,剩下的受关注的假设事件为H11≡B11,H21≡B21,H71≡P71;7D.令SH代表证据E条件下的所有可能假设事件的集合,则SH={H11,H21,H71}.SH是E条件下可能的假设事件样本空间,也是DUCG对诊断类问题的定性推理结果.由于证据E1=B32的影响已被包含在图43中,B32已与化简后的DUCG无关,从而有Pr{B21|B32X71}=Pr{B21|X71}.根据式(40),我们有hs21≡Pr{B21|B32X71}=Pr{B21|X71}=Pr{B21X71}分别展开X71和B21X71,我们有X71=(P71;61G61+P71;62G62)∪P71;7DD7=(P71;61G61+P71;62G62)珚P71;7D+P71;7D=(P71;61(X42+X43)X52+P71;62X43X53)珚P71;7D+P71;7D=P71;61珚P71;7DX42X52+P71;61珚P71;7DX43X52+P71;62珚P71;7DX43X53+P71;7D=P71;61珚P71;7D(F42;11B11+F42;21B21)·(F52;11B11+F52;21B21)+P71;61珚P71;7D(F43;11B11+F43;21B21)·(F52;11B11+F52;21B21)+P71;62珚P71;7D(F43;11B11+F43;21B21)·(F53;11B11+F53;21B21)+P71;7D=珚P71;7D(P71;61(F42;11F52;11B11+F42;21F52;21B21)+P71;61(F43;11F52;11B11+F43;21F52;21B21)+P71;62(F43;11F53;11B11+F43;21F53;21B21))+P71;7D;B21X71=B21(P71;61珚P71;7D(F42;11F52;11B11+F42;21F52;21B21)+P71;61珚P71;7D(F43;11F52;11B11+F43;21F52;21B21)+P71;62珚P71;7D(F43;11F53;11B11+F43;21F53;21B21)+P71;7D)=B21(P71;61珚P71;7D(F42;11F52;11B11+F42;21F52;21)+P71;61珚P71;7D(F43;11F52;11B11+F43;21F52;21)+P71;62珚P71;7D(F43;11F53;11B11+F43;21F53;21)+P71;7D).上面已经给定了{b,p,a,r}类型参数.注意到Pr{Fnk;ij}=fnk;ij=(rn;i/rn)ank;ij,将上式中的大写字母用相应的小写字母替换,我们可以和很容易地算出Pr{X71}=0.02589,Pr{B21X71}=0.01898.最后,根据上述条件概率公式可得hs21=0.73.类似地,hs11=Pr{H11|E}=Pr{B11|X71}=0.19,hs71=Pr{H71|E}=Pr{P71;7D|X71}=0.19.鉴于SH={B11,B21,P71;7D}是在E条件下仅存的3个可能的假设事件,H11=B11,H21=B21和H71=P71;7D的排序概率可分别算得为hr11=0.17,hr21=0.66和hr71=0.17.其中,排序条件概率的定义如下:满足显而易见,如果SH中只有一个假设事件Hkj,根据式(41),我们无须计算hskj即知hrkj=1.对诊断类推理问题,如果在E条件下化简DUCG后仅剩一个假设事件Hkj,则尽管HkjE≠E,诊断推理也无须数值计算即结束,因为我们已确知hrkj=1.同时,由于(1)数值计算前已知定性推理结果SH;(2)数值计算仅限于对这些包含在SH中的假设事件,数据精度对计算结果的影响被大大降低,因而DUCG对参数精度的要求较低.换句话说,DUCG对参数精度具有较高的鲁棒性.读者可能已经注意到:图43是多连通的.本例显示:DUCG即使是在多联通情况下,也无需像BN那样应用团算法(clustering)或割集条件算法(cut-setconditioning),因为DUCG无需用任何特殊算法,仅仅通过事件展开就已自动将多连通分解了.也就是说,DUCG的算法与单连通和多连通无关.这是DUCG的又一个优点.9结论和后续工作适用于单赋值情况的不确定因果关系的简洁表达和推理算法并不能简单地用于多赋值情况,因为其强制归一算法是不恰当的.为解决多赋值问题,本文提出了DUCG模型.该模型既可用于单赋值情况(S-DUCG),也可用于多赋值情况(M-DUCG).其中M-DUCG模型也同时可用于单赋值情况.文献[23]提出的简洁表达和推理应当满足的充分性和可分离性在DUCG模型中都得以实现.此外,基于所观察到的证据(包括事件发生时序)而化简后的DUCG,本文提出了一个新的概率推理的工具,即事件展开算法.该算法与化简后的DUCG是单连通还是多连通无关.文中提出了一套化简的DUCG和进Page26行事件展开的运算规则.通常,化简后的DUCG可在进行数值计算之前提供一个定性的、有时甚至是最终的推理结果.而且,得益于事件展开算法,DUCG对于表达CPD来说可以是不完备的,即DUCG不必表达不受关注的因果关系,尽管这些因果关系对于表达CPD来说是必须的.用数学的语言来说,尽管DUCG能够是(在没有DCG的情况下)、但并不必须是一组变量的联合概率分布的表达.DUCG的不完备性、处理DCG的能力和与简洁表达普通CPT不同的条件连接事件和作用事件的引入,使得DUCG是一个超越了BN的新的理论体系.最后,文中还提出了一个处理绑定了权重系数的事件的逻辑运算新算法.限于篇幅,本文仅处理静态、离散、证据确定和有向无环图DAG的情况.然而,DUCG的目标还在于处理有向循环图DCG、证据在线动态变化、因果关系强度是时间的函数、过程系统所涉及的初因和非初因事件、权重后的以前因果作用在当前时刻的连续叠加、同一DUCG中确定和不确定因果关系的自由混合、不确定或模糊证据、连续和离散变量的自由混合等问题.这些问题将在本文的后续论文中分别论述.后续的另一篇论文将讨论DUCG在某核电站二回路系统动态故障诊断中的应用.该应用涉及100多个真实变量并包含DCG结构.
