Page1异构集群系统中安全关键实时应用调度研究朱晓敏1)陆佩忠2)1)(国防科学技术大学信息系统工程重点实验室长沙410073)2)(复旦大学计算机科学技术学院上海200433)摘要在集群系统中,为有安全需求的实时应用提供安全保障得到了广泛关注,但将实时应用的安全需求与调度算法相结合的研究并不多.文中提出了一种异构集群系统中安全关键实时应用的2阶段调度策略———TPSS.该策略综合考虑了任务的安全需求与时间限制.在TPSS的第1阶段,提出了一种自适应调度算法DSRF,当系统负载较重时,DSRF算法能在保证任务安全需求的基础上,通过降低新到任务和等待队列中任务的安全级别来提高任务的调度成功率.相反,当系统负载较轻时,DSRF算法能在保证系统具有较高调度成功率的基础上充分利用任务在截止期前的空闲时间提高新任务的安全级别.在TPSS的第2阶段,提出了一种新的算法FMSL,用来为所接收任务提供较为公平的安全服务,同时进一步提高了任务的整体安全级别.文中通过大量的模拟实验对TPSS策略与DSRF算法、SAEDF算法和RF算法进行了比较.实验结果表明,TPSS策略优于其它方法,使系统具有较强的安全性与灵活性.关键词调度;异构集群;实时;安全关键;截止期1引言近年来,集群技术发展飞快,在成本和体积迅速下降的同时,计算能力大幅度提升.对于计算密集型和数据密集型应用,采用集群技术是较为经济和可靠的手段[1].尤其是由不同计算能力的节点组成的异构集群在实际应用中得到了广泛应用.这是因为同一集群中的节点可能在不同时期购买,在计算能力上会有所差异,同时出于经济目的考虑,那些仍然具有一定计算能力的节点会和新购买的节点放在一起,从而构成了一个异构集群[2].目前,很多实时应用采用集群方式进行处理,例如,信号处理[3-4]、图像处理[5]、天气预报[6]等等.这些实时应用不仅要求运行结果正确,而且实时应用中的任务要在一定时间内完成[7].通常,实时系统分为硬实时系统[8]和软实时系统[9]两类.在硬实时系统(如病人监控系统、飞机控制系统)中,任何一个任务不能在截止期内完成都可能产生灾难性的后果;而在软实时系统(如视频传输系统、电话交换系统)中,一些任务不能在截止期内完成不会对系统产生太大的影响,但要尽量提高任务的调度成功率[7].本文所研究的安全关键实时应用运行在软实时系统上.随着实时应用的不断发展,运行在集群上的许多实时应用不仅具有时限要求,而且还有安全保障要求[9].例如,在实时股票报价更新和交易系统中,每个用户的请求和企业后台应用程序的响应都有时间限制和安全需求,因此需要在用户与企业后台应用程序之间搭建集群来进行处理.但是由于集群执行的用户应用程序可以被大批用户访问,同时这些应用程序大多未经验证,因此,应用程序和用户都可能对集群构成威胁[10].例如,黑客可能利用应用程序漏洞控制集群,恶意用户也可能通过占用集群资源进行拒绝服务(DOS)攻击,甚至合法用户也可能通过篡改共享数据或执行大量循环操作以中断其它用户接受服务.然而,许多现存的集群计算环境还没有采用任何机制以应对安全威胁.因此,必须提供安全服务以保护运行于集群系统之上的安全性能要求较高的实时应用.在集群计算环境中,调度算法对于提高实时应用的性能起着至关重要的作用[11].但是目前大多数调度算法仅仅考虑如何提高实时应用中任务的调度成功率,而未考虑应用的安全问题.本文提出一种2阶段调度策略TPSS(Two-PhaseSchedulingStrategy).该策略综合考虑了运行在异构集群上实时应用的安全需求与时间限制,能够根据系统状态动态调整调度目标.当任务到达速度较快、任务截止期较短或节点数较少等情况,使得系统负载较重时,任务的调度成功率作为调度的主要目标.相反,当系统负载较轻时,TPSS能够在保证任务具有较高调度成功率的基础上利用任务截止期前的空闲时间提高任务的安全级别.需要注意的是,最小的安全级别能够满足用户的基本需求,高安全级别可以充分利用系统资源,使得系统的安全性更强.与此同时,TPSS使得所接收任务具有较公平的安全服务,即在满足调度成功率不降低的前提下,任务之间的安全级别相差较小,从而降低了实时应用被攻击的概率.本文第2节回顾相关的研究工作;第3节提出一种新的调度器模型和具有安全需求的任务模型;第4节介绍本文提出的TPSS策略和其中的DSRF算法与FMSL算法,并对这两种算法进行分析;第5节通过大量的模拟实验测试TPSS策略的性能;第6节总结全文.2相关工作目前已有许多应用于集群系统的调度算法.但是多处理器系统中的多任务最优分配问题仍是个NP难题[12].因此,在实际应用中,通常采用尽可能接近最优的启发式(Heuristic)算法来解决这类调度问题[13-14].很多学者在这方面做了大量的工作.Branu等人对11种常用的启发式调度算法进行了评估[15].这些调度算法包括OLB、UDA、FastGreedy、Min-min、Max-min、Greedy、GeneticAlgo-rithm(GA)、SimulatedAnnealing(SA)、GSA、Tabu和A.文献[15]的实验结果表明,Min-min、GA和A具有较好的性能,但Min-min算法的负载均衡性相对较差.之后Maheswaran等人提出的Sufferage算法具有比Min-min算法较好的综合性能[16].Subramani等人提出了一种相邻伙伴模式的启发式调度算法也具有较好性能[13].尽管以上这些算法具有较高的吞吐率和较好的负载均衡,但这些算法没有考虑任务的时间限制,不适合实时应用.尤其是GA和SA等采用人工智能的方法,由于这些方法的计算时间具有非常高的可变性,因此采用最长调度时间将极大增加系统延迟,甚至使系统变得不可调度[17].实时任务调度算法一直是实时系统中的一个热Page3点研究问题.实时调度算法可以分为静态调度算法(static/offline)[18]和动态调度算法(dynamic/online)[2,19]两类.通常静态调度算法用于调度周期性(periodic)任务,而动态调度算法用于非周期(aperiodic)任务调度.本文考虑任务动态到达,因此采用的调度算法属于动态调度算法.同时,一些调度算法采用抢占式(preemptive)的调度方式[20-21],即任务在执行过程中可以被其它高优先级任务中断,而另一些调度算法采用非抢占式(Non-Preemptive)的调度方式[22-23].文献[22]指出,非抢占式的调度方式由于减少了任务之间的切换开销从而比抢占式的调度方式更为有效,尤其适合于软实时系统.由于本文考虑的安全关键实时应用运行在软实时系统上,因此本文提出的调度算法采用非抢占式的调度方式.此外,一些调度算法用于调度彼此存在依赖关系(dependent)的任务,这些任务之间的关系通常用由向无环图(DAG)来描述[2,19,24];而另一些调度算法用于调度不存在依赖关系的任务,即独立(inde-pendent)任务[3-4,23,25].本文采用的调度算法用于调度独立任务,因为有依赖关系的任务调度可以转换为独立任务调度[26].独立任务的调度算法可以采用两种模式:立即模式和批模式[16].所谓立即模式即任务到达后立即调度,而批模式采用当任务数量积累到一定数量时再进行调度.虽然采用批模式的调度方法可以积累较多的任务信息,使得某些调度较为有效,但是在实时系统中,尤其是任务截止期很短的情况下,采用批模式调度时,先到任务必须等待任务数达到一定量时才可被调度,这样就造成一些先到任务由于等待延迟而错失其截止期,降低了任务的调度成功率,因此本文的调度算法采用立即模式.近年来,人们越来越关注于解决集群系统中的安全问题,为集群系统提供灵活有效的安全保障已经成为一个基本需求.例如,Son等人提出了一种方法来折中安全质量以达到所需的实时要求[27];Yurcik等人开发了一种通过监控方式管理集群系统安全的工具[28];Koenig等人描述了一种集群安全工具NVisionCC,用来监视集群中节点的处理过程并在异常情况下进行报警[29],等等.但是由于这些安全技术或策略没有考虑到应用的时间限制,因此不适合实时应用.也有一些研究涉及到集群系统中实时应用的安全问题.例如,George等人提出了一种并行控制协议以满足实时应用的安全需求[30].Ahmed等人提出了一种安全最优并行控制协议来折中实时应用的安全需求和时间要求[31].一些学者研究如何将集群中的安全问题与调度算法结合在一起,从而提高运行在集群上的安全关键实时应用的安全性.Xie等人提出了一种具有安全需求的调度策略SAREC和其相应的调度算法SAEDF,用于提高集群系统中实时应用的安全性[32].但是,SAEDF算法是一种贪婪算法,由于过于追求任务的高安全级别从而降低了任务的调度成功率,尤其是在系统负载较重时更为突出.同时,任务之间安全级别差异较大.之后Xiong等人在遗传算法的基础上提出了一种安全关键实时应用的调度算法,进一步提高了任务的整体安全级别[33].但是如前所述,这种人工智能的方法容易使系统变得不可调度,同时又采用了批模式的调度方式,使得对于实时性要求较高的应用不适用.此外,上面的调度算法都假设集群是同构的,即集群中所有节点具有相同的处理能力,限制了算法在异构集群中的扩展性.为此,本文提出一种用于异构集群系统中安全关键实时应用的调度策略,该策略能够根据系统运行状态动态调整调度目标,使得算法具有很强的自适应性,同时尽力为所接收的任务提供较为公平的服务.3系统调度模型3.1调度器模型调度器模型可以分为两类:集中式(centralized)调度器模型和分布式(distributed)调度器模型[2].在集中式调度器模型中,由一个称之为中心调度器的处理器来收集全局调度信息,并做出调度决定.而在分布式调度器模型中,各自处理单元的调度程序根据局部范围的调度信息进行任务调度.与分布式调度器模型相比,集中式调度器模型具有两个显著优点:(1)通过对中心调度器的备份,便于实现容错处理;(2)实现比较容易.为实现TPSS的调度目标,本文在集中式调度器模型的基础上进行了改进,给出了一种新的调度器模型,如图1所示.该模型适合于具有安全需求且运行在异构集群系统上的实时应用.在该调度器模型中,实时调度器为一全局调度器.当有一新任务到达时,实时调度器首先收集各节点上正在运行任务和局部队列中等待任务的反馈信息(feedbackinformation),这些反馈信息包括正在运行任务的剩余执行时间、排队等待任务的等待时间等.然后根据实时调度器中的DSRF算法来决定Page4新任务是否可以被接收.如果新任务可以被接收,则将该任务发送到目的节点的等待队列中,否则发送到拒绝队列中.如果新任务被发送到目的节点后,实时调度器将任务调度信息(schedulinginformation)发送到该目的节点.这些任务调度信息包括所有等待队列中任务的执行顺序、为任务所提供的安全服务.需要注意的是,当一个新任务被发送到某一目的节点后,在同一节点的等待队列中,先于新任务到达的那些任务的执行顺序和为其提供的安全服务可能发生改变.之后,安全级别控制器———局部控制器根据FMSL算法对目的节点局部队列中任务的安全级别进行调整,使得任务具有较为公平的安全服务,同时进一步提高任务的整体安全级别.在调整过程中,等待队列中的所有任务满足其截止期且总体完成时间不延迟,因此保证了任务的调度成功率.3.2任务模型令某一实时应用为一组实时独立任务的集合T={t1,t2,…,tn}.N={n1,n2,…,nm}为节点集合,其中每个节点具有不同的处理能力.执行时间用矩阵犈=(eij)n×m表示,其中元素eij表示任务ti在节点nj上的执行时间.ai和di分别表示任务ti的到达时间和截止期.令犈犛犜=(estij)n×m为任务最早开始时间矩阵,其中元素estij表示任务ti在节点nj上的最早开始时间.犣=(zij)n×m为一二元矩阵,zij=1当且仅当任务ti被分配到节点nj上,否则zij=0.犗=(oij)n×m为任务执行顺序矩阵,在zij=1时,元素oij表示任务ti在节点nj上的执行顺序.一个系统可以采用多种不同类型的安全服务.这些服务类型包括保密服务、完整性服务、认证服务等等.我们将同一种类型的安全服务分在一组,在同一组内,多种安全服务可以提供同一类型的安全保证,但是由于采用的机制有所不同,所以安全质量有所不同.例如,SEAL、RC4和DES都是加密算法,但是它们所提供的安全质量却不同.假设有q组安全服务G={g1,g2,…,gq}.犛=(sij)|si|×q为安全级别矩阵,其中元素sij表示gj组中安全服务si的安全级别,0<sij1,|sij|表示gj组中安全服务的个数.每个任务可以选择不同组中的不同服务从而形成一个整体安全级别.假设Xij表示任务ti在节点nj上所有可能的安全服务组合,xij表示任务ti在节点nj上选择安全服务的一种组合,则任务ti在节点nj上的安全级别可以表示为sl(xij)=zij∑q其中wl表示gl组的权重,skl表示gl组中安全服务sk的安全级别.在实际应用中,安全开销必须被定量地计算以使得调度更为有效.本文采用的安全开销模型类似于文献[32].由于侦听(snooping)、篡改(alteration)和哄骗(spoofing)是集群环境中最常见的3种攻击,而防范这3种攻击的有效方法就是提供保密服务(confidentialityservice)、完整性服务(integrityservice)和认证服务(authenticationservice).为不失一般性和便于分析比较,我们也考虑这3种类型的安全服务.与文献[32]不同的是,本文考虑了安全开销在异构环境中的差异.假设任务ti需要组gl中的第k个安全服务,如果ti被分配到节点nj上,则其安全开销可以表示为其中g1、g2和g3分别提供保密服务、完整性服务和认证服务,pj表示节点nj的处理能力.表1~3给出了每种安全服务所对应的安全级别和它们相应的性能(在90MHz奔腾处理器上测定)[32],其中μk1、μk2和μk3分别代表在组g1、g2和g3中第k个安全服务的性能.对于保密服务和完整性服务,安全计算开销取决于使用的加密算法(对于保密服务)、Hash函数(对于完整性服务)、被保护的数据大小和节点的处理能力;而对于认证服务,安全计算开销则只依赖于所采用的认证技术和节点的处理能力.设si为任务ti的数据大小,pj表示节点nj的处理能力,pb表示基准节点的处理能力,则任务ti在节点nj的安全开销c(xij)可进一步表示为c(xij)=zij∑2Page5加密算法skl(安全级别)uk1/(KB·ms-1)SEALRC4BlowfishKnufu/KhafreRC5RijndaelDESIDEAHash函数skl(安全级别)uk1/(KB·ms-1)MD4MD5RIPEMDRIPEMD-128SHA-1RIPEMD-160Tiger4TPSS策略TPSS策略包含两个算法:DSRF算法和FMSL算法.DSRF算法用于根据系统负载情况,自适应地调整调度目标,使得在系统负载较重时,任务具有较高的调度成功率;而在系统负载较轻时,能在保证任务具有较高调度成功率的基础上最大化任务的安全级别.FMSL算法用于为所接收任务提供较为公平的服务,并且能够进一步提高任务的整体安全级别.4.1DSRF算法DSRF算法源于RF(ResponseFirst)算法[19].RF算法的核心思想是把任务分配到具有最早完成时间的节点上.这种算法采用立即模式,是在异构集群系统中实时任务调度普遍采用的一种算法.但是RF算法没有考虑应用的安全需求,同时不具备自适应性.本文提出的DSRF算法包括3个步骤.在步骤1中,新到任务被分配最高的安全级别,然后按照截止期最早最优先的策略插入到节点的局部队列中,选择具有最早完成时间的节点作为目的节点.需要注意的是,这里的截止期最早最优先策略不是传统的EDF方法,因为EDF算法是抢占式的,而我们采用的这种策略只是对局部队列中的任务进行执行顺序的排队.步骤1用来最大化任务的安全级别.如果采用最高安全级别能够保证新任务的时限要求,同时执行顺序大于新任务的那些任务也满足其截止期,那么分配该任务;如果在任何节点上都不能满足上面的限制,那么转而执行步骤2.在步骤2中,降低新任务的安全级别,直到满足步骤1中所述的限制条件.步骤2同样用来尽力提高新任务的安全级别.当步骤2也不能将任务分配时,步骤3开始工作.步骤3首先选择局部队列中任务安全级别之和最大的节点,然后采用轮询(round-robin)的方法降低局部队列中这些等待任务的安全级别,直到新任务能被分配,如果所有等待任务的安全级别都降到最低仍不能满足新任务或执行顺序晚于新任务的那些任务的时间限制,则放弃该任务,否则将新任务分配到该节点.步骤3用来提高任务的调度成功率.下面介绍DSRF算法的一些性质.性质1.如果任务ti被分配到节点nj上,则ti和nj局部队列中执行顺序大于ti的那些任务必须满足下面2个不等式:其中,estkj=estkj+eij+c(xij),任务ti在节点nj的最早开始时间estij可被计算为estij=ai+∑okj<oij,wk=1其中,ai为任务ti的到达时间,rj为节点nj上正在运行任务的剩余执行时间,∑okj<oij,wk=1节点nj等待队列中执行顺序小于ti的任务的执行时间(包括安全开销).如果任务tk在等待队列中,则wk=1,否则wk=0.性质2.如果步骤3开始执行,那么步骤3所选择的节点nj其局部队列中等待任务tl的最早开始时间需重新计算.(1)如果任务tl的执行顺序小于新任务ti的执行顺序,即olj<oij,则任务tl的最早开始时间可被计算为(2)如果任务tl的执行顺序大于新任务ti的执行顺序,即olj>oij,则任务tl的最早开始时间可被计算为estlj=estlj-∑okj<oljPage6其中c(xkj)表示当任务tk的安全级别降低后新的安全开销.注意,当等待任务的安全级别降低后,必须满足性质1.DSRF算法的伪代码如算法1所示.DSRF算法是一种自适应调度算法,在保证任务调度成功率的基础上尽力提高任务的安全级别.首先,新到任务被指定最高的安全级别(见第2行).如果采用最高的安全级别不能满足性质1,降低新任务的安全级别直到满足性质1(见第3~17行).如果新任务采用最小的安全级别仍然不能满足性质1,选择局部队列中等待任务安全级别之和最大的节点(见第23行),采用轮询的方式降低这些等待任务的安全级别直到满足性质1(见第25~29行).如果这些任务的安全级别都被降到最低仍不能满足性质1,那么拒绝新任务,否则接收这个任务(见40~45行).算法1.DSRF算法.1.foreachnewtasktido2.find←false;sl(xij)←max{sl};/初始化/3.whilesl(xij)!=min{sl}do4.earliestFinishTime←;/初始化/5.foreachnodenjintheclusterdo6.Calculaterjand∑okj<oij,wk=17.Calculatethefinishtimefij:8.iffij<earliestFinishTimethen9.earliestFinishTime←fij;findNode←j;10.endif11.endfor12.ifestim+eim+c(xim)diandtk,okm>oim:13.find←true;break;14.else15.Degradeonesecurityleveling1,g2org3by16.endif17.endwhile18.iffind==truethen19.AllocatetitonodefindNode;20.Updateearlieststarttime(EST)oftasksin21.else22.degradeSum←0;S←;/初始化/23.Selectnodenlonwhichthesumofsecurity24.PutthesetasksintosetS;25.whileS!=do26.degradeSum++;27.foreachtasktkonnodenldo28.ifsl(xkl)!=min{sl}then29.sl(xkl)-=degradeSum;30.CalculatenewESTaccordingtoProperty2;31.ifestim+eim+c(xim)diandtk,okm>32.find←true;break;33.endif34.else35.RemovetkfromS;36.endif37.endfor38.iffind==truethenbreak;endif39.endwhile40.iffind==truethen41.Allocatetitonodenl;42.UpdateESToftasksinthelocalqueueofnl;43.else44.Rejecttaskti;45.endif46.endif47.endfor定理1.DSRF算法的时间复杂度为O(3k(mn+n2)),其中m为集群中的节点数,n为一个节点局部队列中等待任务数,k为安全级别个数.证明.计算新任务ti在一个节点上的完成时间,其时间复杂度为O(n)(见第6~7行).验证ti是否能满足自身和在同一节点的局部队列中执行顺序大于ti的那些任务的时间限制,其时间复杂度为O(n)(见第12行).更新目标节点局部队列中任务的最早开始时间,其时间复杂度为O(n)(见第20行).找到局部队列中等待任务的安全级别之和最大的节点(选中节点),其时间复杂度为O(m)(见第23行).将选中节点等待队列中的任务复制到集合S的时间复杂度为O(n)(见第24行).降低选中节点局部队列中任务的安全级别,其最坏时间复杂度为O(3kn2)(见第25~39行).如果任务ti能被分配,则分配该任务并更新所分配节点局部队列中任务的最早开始时间,其时间复杂度为O(n)(见第41~42行).其它行的时间复杂度均为O(1).因此DSRF算法的时间复杂度可被计算为O(3k)(O(m)(O(n)))+3O(n)+O(m)+O(3nk2)=O(3k(mn+n2)).证毕.由于n为一个节点等待队列中的等待任务个数,所以n的值较小.同时,在实际应用中,k和m也不是非常大的数,因此DSRF算法的时间复杂度Page7不高.4.2FMSL算法为使得所接收任务具有较公平的安全服务,同时进一步提高任务的整体安全级别,当一新任务被分配到某一节点后,FMSL算法将对该节点上局部队列中的任务做进一步处理.节点nj上任务安全级别的公平性可用任务安全级别的标准差FLj表示,FMSL算法的目标即在不影响任务调度成功率的基础上最小化FLj.FMSL算法的核心思想是通过降低高级别任务的安全级别以提高低级别任务的安全级别.当一新任务被分配到目标节点后,将安全级别相对最高和相对最低的任务分别拷贝到集合maxSet和minSet中.降低maxSet集合中任务的安全级别以提高minSet集合中任务的安全级别,在这一过程中必须保证这些任务满足时间限制,且局部队列中这些任务的整体完成时间不被延迟.下面介绍FMSL算法的一些性质.性质3.如果tp∈maxSet,tq∈minSet,当opj<oqj时,则必须满足下面的不等式:其中estqj和c(xqj)分别为任务tq的安全级别提高后新的最早开始时间和新安全开销.其中c(xpj)为tp的安全级别降低后新的安全开销.执行顺序在任务tp和tq执行顺序之间的任务tb,其最早开始时间可被重新计算为早开始时间可被重新计算为执行顺序大于任务tq执行顺序的任务ta,其最estaj=estaj-(estqj+c(xqj)-estqj-c(xqj))图2给出了性质3的一个实例,其中fij表示任务ti在节点nj上的完成时间.性质4.如果tp∈maxSet,tq∈minSet,当opj>oqj时,则必须满足下面的不等式:其中c(xqj)为任务tq的安全级别提高后新的安全开销.执行顺序在任务tp和tq执行顺序之间的任务tb,当tq的安全级别提高后,必须满足其截止期:其中estbj为新最早开始时间,可被计算为任务tp的最早开始时间计算方法与tb一致,同时要满足tp的新完成时间要小于等于原完成时间,以保证任务的调度成功率.早开始时间可被重新计算为执行顺序大于任务tp执行顺序的任务ta,其最estaj=estaj-(estpj+c(xpj)-estpj-c(xpj))图3给出了性质4的一个实例.FMSL算法的伪代码如算法2所示.算法2.FMSL算法.1.whiletruedo2.canAdjust←false;/初始化/3.Puttaskswithmaximalsecuritylevelandmini-4.whilemaxSet!=do5.GetatasktpfrommaxSet;6.whileminSet!=do7.addLevel←-1;/初始化/8.GetatasktqfromminSet;9.Degradesecurityleveloftponelevel;10.CalculateaddLeveloftq;11.ifaddLevel==0thencontinue;endif12.ifopj>oqjthen13.whileaddLevel>0do14.ifestqj+eqj+c(xqj)dqandestbj+ebj+Page815.break;16.else17.addLevel--;18.endif19.endwhile20.ifaddLevel!=0then21.UpdateESToftasksinthelocalqueueby22.RemovetpfrommaxSet;removetqfrom23.canAdjust←true;break;24.endif25.endif26.ifopj<oqjthen27.UpdateESToftasksinthelocalqueueby28.RemovetpfrommaxSet;removetqfrom29.endif30.GetnexttaskfromminSet;31.endwhile32.ifcanAdjust==truethenbreak;endif33.GetnexttaskfrommaxSet;34.endwhile35.ifcanAdjust==falsethenbreak;endif36.endwhileFMSL算法首先将节点局部队列中安全级别相对最高和安全级别相对最低的任务分别拷贝到集合maxSet和minSet中(见第3行).从集合maxSet中任选一任务tp,并从集合minSet中任选一任务tq,如果tp降低一个安全级别不能使得tq提高一个级别,那么从minSet选择另外一个任务(见第4~11行).如果tp的执行顺序大于tq的执行顺序,当tq的安全级别被提高后,那么tq和执行顺序在tp和tq之间的那些任务不能错失其截止期(性质4).如果性质4不能满足,降低增加的安全级别直到满足性质4(见第12~17行).当tp和tq的安全级别调整后,将tp和tq分别从集合maxSet和minSet中移除,因为它们此时已经不具有相对最高和最低的安全级别(见第22行).如果tp的执行顺序小于tq的执行顺序,根据性质3更新局部队列中等待任务的最早开始时间并将tp和tq分别从集合maxSet和minSet中移除(见第26~29行).如果没有任何任务的安全级别可以调整,那么结束该算法(见第35行).定理2.FMSL算法的时间复杂度为O(n2(k+n)),n为一个节点nj局部队列中的等待任务数,k为安全级别个数.证明.找到节点nj局部队列中安全级别相对最高和相对最低的任务,其时间复杂度为O(n)(见第3行).当tp的执行顺序大于tq的执行顺序时,降低任务tq提高的安全级别,以满足tq和执行顺序在tp和tq之间那些任务的时间要求,其最坏时间复杂度为O(k)(见第13~19行).根据性质4,更新nj局部队列中等待任务的最早开始时间,其时间复杂度为O(n)(见第21行).当tp的执行顺序小于tq的执行顺序时,根据性质3,更新nj局部队列中等待任务的最早开始时间,其时间复杂度为O(n)(见第27行),因此FMSL算法的时间复杂度可被计算为O(n)+O(n)(O(n)((O(k)+O(n))+O(n)))=O(n2(k+n)).由于局部队列中的等待任务数n较小,同时在maxSet和minSet中的任务数还要远小于n,因此FMSL算法的时间复杂度不高.5实验测试本文通过大量的模拟实验结果来说明TPSS策略的性能.将其与RF[19]、DSRF和SAEDF[32]的结果进行比较.为公平起见,将RF算法进行了略微修改,即它随机选择任务的安全级别.本文主要从以下几个方面比较了TPSS、RF、DSRF和SAEDF的性能:(1)调度成功率(GuaranteeRatio,GR);(2)安全级别均值(SecurityLevelAverage,(3)安全级别标准误差(SecurityLevelStand-(4)整体系统性能(OverallSystemPerform-SLA);ardDeviation,SLSD);ance,OSP,OSP=GRSLA/SLSD).5.1模拟方法与参数异构性可以分为节点异构性和任务异构性[16].本文在实验中充分考虑了节点和任务的异构性.下面给出实验的模拟方法:(1)为了体现节点的异构性,用pj表示节点nj的处理能力.pj为一正实数,pj越大节点的处理能力越强.参数powerAverage和powerSpan分别表示节点的平均处理能力和处理能力的浮动范围.pj均匀分布在powerAverage-powerSpan和power-Average+powerSpan之间.(2)hi表示任务ti的处理难度.hi为一正实数,hi越大任务ti在同一节点上的执行时间越长.参数hardnessAverage和hardnessSpan分别表示所有任务的平均处理难度和处理难度的浮动范围.hiPage9均匀分布在hardnessAverage-hardnessSpan和hardnessAverage+hardnessSpan之间,用以体现任务的异构性.(3)文献[16]将任务执行时间矩阵分为一致(Consistent)矩阵和不一致(Inconsistent)矩阵.本文中的任务执行矩阵采用一致矩阵,即任务的执行时间与任务的处理难度成反比,与节点的处理能力成正比.任务ti在节点nj上的执行时间eij可以表示为eij=baseTime×(hi/pj).参数baseTime为一正实数.(4)任务ti在节点nj上的安全开销c(xij)充分考虑了任务异构性和节点异构性.c(xij)的计算如公式(3)所示.(5)任务ti的截止期可被计算为di=ai+max{eij}+max{c(xij)}+baseDeadline.其中ai表示任务ti的到达时间,max{eij}表示ti在所有节点上的最长执行时间,max{c(xij)}表示ti在所有节点上的最大安全开销,baseDeadline为一随机正实数,baseDeadline越大,任务截止期越宽松.(6)任务ti的到达时间ai=ai-1+intervalTime,图4节点对性能的影响图4(a)显示了DSRF的调度成功率一直高于SAEDF的调度成功率,这是因为SAEDF在满足新任务和同一节点局部队列中任务截止期的前提下,始终为新任务选择尽可能最高的安全级别,这将导致新任务具有较长的执行时间,因此在系统负载较重时,晚到达的任务具有较晚的开始时间.如果任务其中ai-1表示ti的前一个任务ti-1的到达时间,a0=0.参数intervalTime为一正实数,决定任务的到达速度.(7)任务ti的数据大小si正比于ti的处理难度.表4给出了实验中的参数值.si=baseSize×hi.参数baseSize为一正实数.powerAveragehardnessAveragehardnessSpanbaseDeadlineintervalTime安全服务权值w1=0.2,w2=0.5,w3=0.35.2节点对性能的影响DSRF和SAEDF的影响.实验结果如图4所示.本节通过一组实验来观察节点数对TPSS、RF、的开始时间延迟,那么任务错失其截止期的概率增大.与SAEDF不同的是,当系统负载较重时,DSRF将任务的调度成功率作为系统的主要目标.DSRF通过降低局部队列中等待任务的安全级别,提高了系统的调度成功率.需要注意的是,任务的安全级别降到最低仍在系统可接受的安全级别范围内.从Page10图4(a)中可以看出,TPSS的调度成功率有时略高于DSRF的调度成功率,这是因为TPSS中的FMSL算法在调整局部队列中任务的安全级别时,有时会使得所有任务的新总体完成时间略早于原完成时间,因此后到任务的最早开始时间提前,使得任务的调度成功率略有增加(图2、图3的例子也表明这一点).图4(a)还显示了当节点数小于24时,RF具有最低的调度成功率,但是当节点数大于40时,RF具有最高的调度成功率,这是因为RF随机选取任务的安全级别,因此调度成功率不确定.图4(b)显示了当节点数小于24时,SAEDF的安全级别均值高于DSRF的安全级别均值,这是因为SAEDF尽力提高接收任务的安全级别而未考虑系统的负载情况.相反,尽管DSRF的安全级别均值略低于SAEDF的安全级别均值,但是DSRF具有较高的调度成功率.从图4(b)可看出,TPSS的安全级别均值一直高于SAEDF的安全级别均值,这是因为TPSS算法在调整任务安全级别时,一个高安全级别任务被降低一个安全级别后,可以使得一个低安全级别任务提高一到多个安全级别,因此任务的整体安全级别提高了.当节点数大于24时,DSRF具有和SAEDF基本相同的安全级别均值,这是因为当系统负载较轻时,DSRF能够充分利用任务截止期前的空闲时间,提高任务的安全级别.因图5(a)表明,当到达时间较小时,任务的到达速度较快,使得在节点局部队列中的等待任务较多,图5任务达到速度对性能的影响此TPSS具有很强的自适应性.图4(c)显示了TPSS的安全级别标准误差一直小于DSRF和SAEDF的安全级别标准误差.这可解释为TPSS中的FMSL算法在保证局部队列中任务时间限制的前提下,均衡任务的安全级别,使得任务具有较公平的安全服务.相反,DSRF和SAEDF没有考虑这一点.当节点数较少时,系统负载较重,先到任务具有较高的安全级别,而晚到任务则需要通过降低其安全级别才可能保证被调度,因此任务的安全级别差异较大.随着节点数的增加,系统负载减轻,能够保证任务在接收的同时具有较高的安全级别,因此安全级别标准误差降低.由于RF随机选取安全级别,因此RF的安全级别标准误差与节点数不具有线性关系.图4(d)显示了TPSS的总体系统性能明显好于其它算法,平均高于RF、SAEDF和DSRF45.2%、53.9%和67.7%.图4(d)表明,当节点数较多时,TPSS的整体性能增加显著,这意味着在系统负载较轻时,系统性能收益较大.5.3任务到达速度对性能的影响本节我们通过一组实验来观察任务到达速度对对TPSS、RF、DSRF和SAEDF的影响.在本组实验中调整参数intervalTime从0.5~1.5,步长为0.1.实验结果如图5所示.所以一些晚到达任务由于具有较晚的开始时间而错失其截止期.随着到达时间值的增大,任务的到达速Page11度变慢,使得在节点局部队列中的任务较少,任务具有较早的开始时间,因此任务的调度成功率增加.从图5(a)可以看出,TPSS和DSRF相比于SAEDF具有较高的调度成功率,这是因为DSRF通过降低等待队列中任务的安全级别,减小了这些任务的运行时间,因此更多的任务因为具有较早的开始时间而被接收.相反,SAEDF始终保持所接收任务的安全级别保持不变,因此一些任务由于具有较晚开始时间而错失截止期,不能被接收.尤其是当任务达到速度很快时,DSRF具有更高的调度成功率,这是因为DSRF是一种自适应调度算法,当任务到达速度较快使得系统负载较重时,调度成功率是DSRF算法的主要目标.图5(a)还显示,当到达时间值大于0.7时,RF的调度成功率高于其它方法,这是因为RF随机选取任务的安全级别,从图5(b)可以看出此时RF选择的安全级别均值最低,因此具有较高的调度成功率.图5(b)显示,当到达时间值小于1.3时,SAEDF的安全级别均值略高于DSRF的安全级别均值,这是因为SAEDF过于追求当前新到任务的高安全级别,而没有考虑后到任务的调度成功率.相反,DSRF图6节点异构性对性能的影响图6(a)显示,随着节点异构性的增大,调度成功率有所增加,这是由于节点性能降低导致所接收任务的减少数目要小于节点性能提高导致所接收任务的增加数目.从图6(a)中可以看出尽管节点的异构性变化较大,但TPSS的调度成功率一直高于算法采用自适应的调度策略,在系统负载较重时,通过降低节点局部队列中等待任务的安全级别提高了任务的调度成功率.当到达时间值大于1.3时,DSRF和SAEDF具有相似的安全级别均值,这种情况是因为当任务到达速度较慢时,DSRF算法不必通过降低任务的安全级别来接收新任务,此时提高任务的安全级别变成了DSRF的主要目标.从图5(c)可以看出,TPSS相比SAEDF具有较小的安全级别标准误差,尤其是当任务到达速度较快时,这是因为FMSL算法起到的作用使得所接收任务间的安全级别差异较小.图5(d)给出了整体的系统性能,TPSS的整体系统性能明显好于其它算法,这说明对于非周期任务,TPSS具有更强的灵活性和可靠性.5.4节点异构性对性能的影响本节我们通过一组实验来观察节点异构性对TPSS、RF、DSRF和SAEDF的影响.实验中用参数powerSpan代表节点的异构性变化,powerSpan增大,则节点的异构性增大,反之减小.实验结果如图6所示.DSRF和SAEDF的调度成功率.同时,在参数powerSpan的值为50时,RF的调度成功率高于TPSS的调度成功率,但是此时,RF随机选择的安全级别最低,因此具有较高的调度成功率.图6(b)显示了TPSS、DSRF和SAEDF的安全Page12级别均值明显高于RF的安全级别均值,这是因为TPSS、DSRF和SAEDF在调度过程中会优化任务的安全级别,而RF没有考虑到这一点.从图6(b)中可以看出,当powerSpan小于400时,SAEDF的安全级别均值高于DSRF的安全级别均值,但是TPSS相对于SAEDF却具有较高的安全级别均值,这是因为TPSS中的FMSL算法可使得任务的整体安全级别进一步提高.从图6(c)可是看出,TPSS的安全级别标准误差小于DSRF和SAEDF的安全级别标准误差,因为FMSL算法通过调整任务的安全级别,减小了任务安全级别之间的差异.此外,图6(c)显示了有时RF相对TPSS具有更低的安全级别标准误差,这是因为RF随机选取的安全级别均较低,因此安全级别的差异较低.图6(d)显示了整体系统性能,TPSS的整体系统性能平均高于RF、SAEDF和DSRF的OPS48.3%、56.7%和88.7%.因此TPSS适合于异构集群系统环境.6结论本文提出了一种异构集群系统中处理安全关键实时应用的调度器模型.在该调度器模型的基础上,提出了一种2阶段的调度策略———TPSS.在第1阶段,提出了一种自适应调度算法DSRF,用于任务的实时调度.DSRF能够根据系统的负载情况,自适应地调整调度目标.当系统负载较重时,DSRF算法在满足系统基本安全保障的同时,将调度成功率作为调度的主要目标;当系统负载较轻时,DSRF算法能够在保证系统具有较高调度成功率的基础上,充分利用任务截止期前的空闲时间提高任务的安全级别.在第2阶段,提出了一种用来为所接收任务提供公平安全服务的算法FMSL.FMSL算法在不降低任务调度成功率的基础上,通过减小节点局部队列中任务之间的安全级别差异来为任务提供较为公平的服务,从而降低了任务被攻击的概率.另外,FMSL算法在调整任务安全级别的过程中能够进一步提高任务的整体安全级别.最后,通过大量的模拟实验对TPSS、RF、SAEDF和DSRF进行了比较,实验结果表明,TPSS的性能优于其它算法,适合于异构集群系统环境,尤其是任务达到速度变化较大、节点动态加入或退出集群等情况,使得系统具有较强的安全性和灵活性.
