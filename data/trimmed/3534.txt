Page1基于频繁闭情节及其生成子的无冗余情节规则抽取朱辉生1),2)汪卫2)施伯乐2)1)(泰州师范高等专科学校江苏泰州225300)2)(复旦大学计算机科学技术学院上海200433)摘要情节规则挖掘旨在发现频繁情节之间的因果关联,已广泛应用于传感器数据处理、网络安全监控、金融证券管理、事务日志分析等众多领域.针对一个事件序列上的无冗余情节规则挖掘,提出了算法Extractor.该算法采用最小且非重叠发生的支持度定义和深度优先的搜索策略来发现频繁闭情节及其生成子,保证了频繁闭情节及其生成子的挖掘质量和挖掘效率;利用非生成子情节的Apriori性质,避免了冗余的情节生成子判断;直接由频繁闭情节及其生成子产生无冗余情节规则,提高了情节规则的生成质量和生成效率.所进行的实验证实了该情节规则抽取算法的有效性.关键词事件序列;频繁闭情节;情节生成子;情节规则1引言情节刻画了事件类型之间的紧随关系,而情节规则描述了频繁情节的因果关联.自Mannila等人[1]引入情节规则的概念以来,情节规则挖掘的问题一直是数据挖掘领域研究的热点之一,许多学者对此展开了深入研究,提出了TASA[2]、WinMiner[3]等经Page2典算法,并将它们应用于传感器数据处理[4]、网络安全监控[5]、金融证券管理[6]、软件规范挖掘[7]、事务日志分析[8]等众多领域.然而,现有的情节规则挖掘算法存在以下不足:(1)基于滑动窗口或最小发生来计算一个情节的支持度,致使频繁情节的挖掘质量不高;(2)直接由频繁情节集产生所有的情节规则,导致规则数量过于庞大且存在冗余;(3)尽管利用一些修剪技术来筛选冗余的情节规则,但这种后期的修剪处理增加了算法的时间代价.那么,直接由频繁闭情节集来抽取情节规则,是否可以避免产生冗余规则呢?不幸的是,冗余问题依然存在.例如,假设事件序列ES1=〈(A,1),(A,2),(B,3),(D,4),(A,5),(C,6),(B,7),(B,8),(E,9),(A,10),(B,11),(A,12),(C,13),(E,14),(F,15)〉是某图书馆Web服务器上记载的一个涉及多个读者对多个文档的阅读序列,其中字母符号表示该图书馆提供的某个文档,数字表示某读者对相应文档的开始阅读时间.若使用最小且非重叠发生的情节支持度定义,则在支持度阈值min_sup=2时,ES1上所有的频繁情节和频繁闭情节分别如表1和表2所示,这些情节刻画了读者们的阅读行为,从而有助于图书馆人员发现文献之间的关联并向读者提供个性化的推荐服务.尽管频繁闭情节的个数远远少于频繁情节的个数,但直接由频繁闭情节集仍能产生如表3所示的50个情节规则,其中存在许多冗余规则.情节支持度情节支持度情节支持度〈A〉5〈ABAE〉2〈BAC〉2〈AA〉2〈ABC〉2〈BACE〉2〈AAB〉2〈ABCE〉2〈BAE〉2〈AAC〉2〈ABE〉2〈BB〉2〈AACE〉2〈AC〉2〈BC〉2〈AAE〉2〈ACE〉2〈BCE〉2〈AB〉3〈AE〉2〈BE〉2〈ABA〉2〈B〉2〈C〉2〈ABAC〉2〈BA〉2〈CE〉2〈ABACE〉2〈BAB〉2〈E〉2情节支持度情节支持度情节支持度〈A〉5〈ABACE〉2〈BAB〉2〈AAB〉2〈B〉〈AB〉3〈BA〉3情节规则支持度置信度/%情节规则支持度置信度/%〈A〉→〈A〉240〈AB〉→〈A〉267〈A〉→〈B〉360〈AB〉→〈C〉267〈A〉→〈AB〉240〈AB〉→〈E〉267〈AA〉→〈B〉2100〈AB〉→〈AC〉267〈A〉→〈C〉240〈AB〉→〈AE〉267〈A〉→〈E〉240〈AB〉→〈CE〉267〈A〉→〈BA〉240〈AB〉→〈ACE〉267〈A〉→〈BC〉240〈AA〉→〈C〉2100〈A〉→〈BE〉240〈AA〉→〈E〉2100〈A〉→〈AC〉240〈AA〉→〈CE〉2100〈A〉→〈AE〉240〈AC〉→〈E〉2100〈A〉→〈CE〉240〈BA〉→〈C〉267〈A〉→〈BAC〉240〈BA〉→〈E〉267〈A〉→〈BAE〉240〈BA〉→〈CE〉267〈A〉→〈BCE〉240〈BC〉→〈E〉2100〈A〉→〈ACE〉240〈ABA〉→〈C〉2100〈A〉→〈BACE〉240〈ABA〉→〈E〉2100〈B〉→〈A〉375〈ABA〉→〈CE〉2100〈B〉→〈C〉250〈ABC〉→〈E〉2100〈B〉→〈E〉250〈AAC〉→〈E〉2100〈B〉→〈AC〉250〈BAC〉→〈E〉2100〈B〉→〈AE〉250〈ABAC〉→〈E〉2100〈B〉→〈CE〉250〈B〉→〈B〉250〈B〉→〈ACE〉250〈B〉→〈AB〉250〈C〉→〈E〉2100〈BA〉→〈B〉2671999年,Pasquier等人[9]引入了项集生成子的概念:一个项集称为生成子,当且仅当该项集不存在与其支持度相同的任何一个真子集.在一个交易数据库中,包含在相同交易集的项集的集合称为一个等价类[10],生成子和闭项集可以将交易数据库中所有项集合的幂集划分为不同的等价类,在每个这样的等价类中,项集生成子是最小的元素,而闭项集则是最大的元素.根据最小描述长度MDL原理,Li等人[11]证明了项集生成子对于其所属的等价类具有最小的描述长度,可以避免对训练数据集的“过拟合”和抗噪音能力差等问题,因此,项集生成子比频繁闭项集更适于分类应用.基于频繁闭项集及其生成子可以直接产生具有最小前件和最大后件的无冗余关联规则基,典型算法有Gen[12]、DPMiner[13]等.依据交易数据库等价类和项集生成子的定义,Lo等人[14]引入了序列数据库等价类和序列模式生成子的概念:一个序列数据库中包含在相同序列集的序列模式的集合称为一个等价类;一个序列模式称为生成子,当且仅当该序列模式不存在与其支持度相同的任何一个真子序列模式.基于MDL原理,他们同样证明了序列模式生成子比闭序列模式更适于解决分类问题,并且提出了由搜索空间压缩、发现生成子超集、筛选非生成子3个步骤组成的序列模式生成子挖掘算法GenMiner.Page3然而,关联规则和序列模式的挖掘是针对一个交易数据库或序列数据库,相关的算法并不能直接应用于针对一个事件序列的情节规则挖掘.目前尚无文献报道利用情节生成子来抽取无冗余情节规则的相关研究.能否结合项集生成子及序列模式生成子的概念来定义情节生成子?情节生成子是否具有与项集生成子一样的Apriori性质?能否借鉴无冗余关联规则基的挖掘方法来抽取无冗余情节规则?这些正是本文研究的主要动机.为此,我们引入了情节生成子的概念和非生成子情节的Apriori性质,并提出了一个情节规则的抽取算法Extractor.该算法采用最小且非重叠发生的支持度定义和深度优先的搜索策略来发现频繁闭情节及其生成子,保证了频繁闭情节及其生成子的挖掘质量和挖掘效率;利用非生成子情节的Apriori性质,避免了冗余的情节生成子判断;直接由频繁闭情节及其生成子产生无冗余情节规则,提高了情节规则的生成质量和生成效率.理论分析和实验评估证明该算法能有效地抽取给定事件序列上的所有无冗余情节规则.2相关工作关联规则的挖掘研究由来已久,针对如何控制由频繁项集产生的关联规则数量问题,Pasquier等人[9]引入了项集生成子的概念:不存在与其支持度相同的任何一个真子集的项集,并提出了频繁闭项集的挖掘算法A-Close;Bastide等人[12]根据Galois连接的闭包定义了两种关联规则基:具有最小前件和最大后件的精确关联规则(置信度等于100%的关联规则)组成的无冗余精确关联规则基、具有最小前件和最大后件的近似关联规则(置信度小于100%的关联规则)组成的无冗余近似关联规则基,并提出了直接由频繁闭项集及其生成子来产生无冗余关联规则基的算法Gen.与Gen算法中的广度优先搜索策略不同,Li等人[13]提出的算法DPMiner采用了深度优先的搜索策略,利用倒置的FP树来发现频繁闭项集及其生成子,进而产生交易数据库中具有δ差异的等价类.为了拓展生成子在序列模式挖掘中的应用,Lo等人[14]引入了序列数据库等价类和序列模式生成子的概念,并结合序列数据库等价类的特性,提出了序列模式生成子的挖掘算法GenMiner.该算法首先采用深度优先的搜索策略来创建存储了所有序列模式的前缀搜索树PSL,然后通过遍历PSL得到包含所有序列模式生成子的超集Gen-S,最后根据比较Gen-S中2个序列模式的支持度来筛选非生成子的序列模式.然而,情节规则的挖掘有别于关联规则与序列模式的挖掘,前者挖掘的对象是一个事件序列,并非是一个事务数据库和序列数据库.Mannila等人[1]首先引入了情节规则的概念:带有两个时间约束的情节规则可以表示为β[win1]→α[win2],其中βα,即β是α的子情节,win1、win2分别是两个时间窗口.该规则的语义是若情节β在一个不超过win1的最小区间[ts,te]上发生,则情节α将会在不超过win2的最小区间[ts,te]上发生.随后,Hatonen等人[2]基于通信故障诊断的应用背景,提出了挖掘给定事件序列上所有情节规则的算法TASA,该算法分为3个步骤:首先,基于广度优先的搜索策略和滑动窗口的情节支持度定义,通过多遍扫描事件序列,以候选、剪枝再测试的处理方式发现频繁情节;其次,由频繁情节集产生情节规则集;最后,使用Pruning、Ordering、Grouping等技术来筛选冗余的情节规则.为了在产生情节规则的同时,能够发现使情节规则具有最大置信度的最小时间窗口,Meger等人[3]于2004年提出了算法WinMiner,该算法采用了深度优先的搜索策略和最小发生的情节支持度定义,只需单遍扫描事件序列,且不会产生任何候选情节,但其情节规则集的产生也是直接基于频繁情节集.近年来,流数据的日益普及使得上述情节规则挖掘方法得到了广泛的应用,如基于传感器网络的大规模数据管理[4]、集误用检测和异常检测于一体的网络安全监控[5]、金融事件关联与股票价格趋势的分析[6]、基于程序验证与缺陷发现的软件规范挖掘[7]、动态系统中事件日志的概要分析[8]等.针对现有情节规则挖掘算法存在的不足,本文提出了一个基于事件序列上的频繁闭情节及其生成子来抽取所有无冗余情节规则的算法Extractor.表4列出了本文提出的算法Extractor与现有相关算法的主要区别.算法搜索策略情节的支持度计算方法挖掘结果TASA[2]广度优先滑动窗口(可能重叠)所有情节规则WinMiner[3]深度优先最小发生(可能重叠)所有情节规则Gen[12]广度优先DPMiner[13]深度优先GenMiner[14]深度优先Extractor(本文)深度优先最小且非重叠发生无冗余情节Page43预备知识3.1基本概念定义1(事件,事件序列,子序列).给定一个事件类型集ε={E1,E2,…,En},一个事件就是一个二元组(E,t),其中,E∈ε,t表示该事件的发生时间.定义在ε上的一个事件序列ES是由若干事件按发生时间先后排列的序列,表示为ES=〈(E1,t1),(E2,t2),…,(Es,ts)〉,其中ti<tj(1i<js).给定两个序列ES和ES,若ES=ES或ES是由ES删除某些事件后得到的剩余序列,则称ES是ES的子序列.定义2(情节,子情节).一个情节α是由若干事件类型组成的序列,表示为α=〈E1E2…Ek〉,其中元素Ei(1ik)∈ε且对于所有的i和j(1i<jk)满足Ei总是排列在Ej之前.情节α中的元素个数称为α的长度,记为|α|.长度为k的情节也称为k-情节.给定情节α=〈E1E2…Em〉和β=〈E1E2…Ek〉,若至少存在一个整数序列1l1<l2<…lk,满足Ei=Eli(1ik),则称β是α的一个子情节,或α是β的一个超情节,记为βα或αβ.若βα且β≠α,则称β是α的一个真子情节,或α是β的一个真超情节,记为βα或αβ.定义3(前缀,后缀,串接,投影).给定情节α=〈E1E2…En〉,若对于所有的i(1im<n),满足Ei=Ei,则称情节β=〈E1E2…Em〉是α的m-前缀,记为prefix(α,m).给定情节α=〈E1E2…Ek〉(k>1),称情节〈EiEi+1…Ek〉(2ik)是α的i-后缀,记为suffix(α,i).给定情节α=〈E1E2…Em〉和β=〈E1E2…Ek〉,则〈E1E2…EmE1E2…Ek〉称为α和β的串接,记为concat(α,β).设βα,j是β在α中首次出现的结束位置,则从α中删除第1至第j个事件类型后剩余的情节称为β在α上的投影,记为project(α,β).定义4(前向扩展,后向扩展,中间扩展).设k-情节α=〈E1E2…Ek〉,e为1-情节,则〈E1E2…Eke〉、〈eE1E2…Ek〉和〈E1…EieEi+1…Ek〉分别称为α的前向扩展、后向扩展和中间扩展.实际上,α的前向扩展也是以α为前缀、e为后缀进行情节增长后得到的情节concat(α,e).定义5(发生).给定事件序列ES和情节α=〈E1E2…Ek〉,若至少存在ES的一个子序列ES=〈(E1,t1),(E2,t2),…,(Ek,tk)〉,满足ti<ti+1(1ik-1),则称ES上发生(或出现)了情节α,区间[t1,tk]称为α在ES上的一次发生,其中t1和tk分别称为该发生的起始时间和终止时间.定义6(最小发生).设[ts,te]是情节α在事件序列ES上的一次发生,若在ES上不存在α的另一次发生[ts,te],使得ts<ts且tete,或tsts且te<te,即[ts,te][ts,te],则称[ts,te]是α在ES上的一次最小发生.定义7(最小且非重叠发生).设[ts,te]和[ts,te]是情节α在事件序列ES上的两次发生,若(1)te<ts或te<ts;且(2)[ts,te]和[ts,te]都是α的最小发生,则[ts,te]和[ts,te]是α在ES上的最小且非重叠发生.定义8(支持度).情节α在事件序列ES上所有最小且非重叠发生组成的最大集合的基数称为α的支持度,记为α.sup.定义9(频繁情节,频繁闭情节,情节生成子).给定支持度阈值min_sup,若情节α的支持度大于等于min_sup,则α是一个频繁情节.若情节α是频繁的,且α的任何一个真超情节的支持度均不等于α的支持度,则α是一个频繁闭情节.设f是一个闭情节,gf,若g的支持度等于f的支持度,且g不存在与其支持度相同的任何一个真子情节,则g称为闭情节f的一个情节生成子.定义10(情节规则).一个情节规则γ是一个五元组(l,r,s,c,w).其中,l、r、s、c、w分别称为γ的前件、后件、支持度、置信度和窗口宽度.情节规则γ的支持度用于衡量该规则在事件序列上的统计特性,它等于情节concat(γ.l,γ.r)的支持度;情节规则γ的置信度用于衡量该规则的可信程度,它等于情节concat(γ.l,γ.r)的支持度与情节γ.l的支持度比值.情节规则γ的窗口宽度用于约束该规则的前件和后件必须在这个指定的时间区间内先后发生,它等于情节concat(γ.l,γ.r)的所有最小且非重叠发生的平均时间.定义11(无冗余情节规则).给定情节规则γ(l,r,s,c,w),若不存在情节规则γ(l,r,s,c,w),使得γ.s=γ.s,γ.c=γ.c,γ.lγ.l,γ.rγ.r,则称γ是一个无冗余情节规则,否则是一个冗余情节规则.在所有支持度相同且置信度相同的情节规则中,无冗余情节规则同时具有最小的前件和最大的后件.3.2问题描述给定事件序列ES、支持度阈值min_sup和置Page5信度阈值min_conf,则问题可以描述为:设计一个能够抽取ES上所有无冗余情节规则的算法,要求:(1)单遍扫描ES,发现频繁情节的过程中不产生候选情节;(2)直接由发现的频繁闭情节及其生成子产生无冗余情节规则.4无冗余情节规则抽取算法Extractor4.1算法描述文献[15]提出了算法MANEPI以发现给定事件序列上的频繁情节,该算法采用深度优先的搜索策略和最小且非重叠发生的支持度定义,只需单遍扫描事件序列,且挖掘过程避免了候选情节的产生和情节发生的“过计数”问题,具有较高的挖掘效率和挖掘质量.为此,本文提出的算法Extractor采用了与MANEPI一样的搜索策略和支持度定义,但与MANEPI不同的是,算法Extractor旨在发现频繁闭情节及其生成子,并进而直接由频繁闭情节及其生成子产生无冗余情节规则.下面是Extractor的伪代码.Extractor(ES,min_sup,min_conf).Input:ES:aneventsequence=〈(E1,t1),(E2,t2),…,Output:R:asetofallnon-redundantepisoderules1.LetFE=2.ScanESoncetofindallfrequent1-episodesand3.Foreachfrequent1-episodeedo4.MineGrow(e)5.Foreachα∈FEdo6.CheckClosure(α)7.CheckGenerator(α)8.FormRule(FE,min_conf,R)9.ReturnRProcedureMineGrow(α)Input:α:anepisodetobegrownObjective:growtheexistingfrequentepisodeα1.Foreachfrequent1-episodeedo2.Letβ=concat(α,e)3.Ifβ.smin_sup4.Letβ.clo=β.gen=05.LetFE=FE∪β6.Ifβ.s=α.s7.Letβ.gen=-18.Ifα.clo=09.Letα.clo=-110.MineGrow(β)4.2生成子检查算法Extractor的关键步骤之一是如何确定一个情节是否为生成子.项集生成子具有如下Apriori性质[14]:“若一个项集是一个频繁闭项集的生成子,则该生成子的真子集也是这个频繁闭项集的生成子”,这个性质可以用来加快项集生成子的挖掘.那么,情节生成子是否也具有类似的Apriori性质:若一个情节是一个频繁闭情节的生成子,则该生成子的真子情节也是这个频繁闭情节的生成子?以表1和表2为例,情节〈AA〉是频繁闭情节〈ABACE〉的一个生成子,因为〈AA〉的支持度等于〈ABACE〉的支持度,且〈AA〉不存在与其具有相同支持度的任何真子情节.然而,〈AA〉的一个真子情节〈A〉却不是〈ABACE〉的生成子,这是因为〈A〉的支持度并不等于〈ABACE〉的支持度.尽管情节生成子不具有Apriori性质,但是一些非生成子情节却具有引理1所示的Apriori性质,它可以用来加快情节生成子的发现.引理1.给定一个情节α,如果存在α的一个真子情节β,使得β.mano=α.mano,则情节α及以其为前缀的其它任何情节都是非生成子情节.证明.(1)根据定义9可知,情节α是一个非生成子情节;(2)因α.mano=β.mano,故对于已知事件序列上的任何一个频繁1-情节e而言,只要能以α为前缀、e为后缀进行情节增长得到concat(α,e),也就能以β为前缀、e为后缀进行情节增长而得到concat(β,e),并使得concat(β,e).mano=concat(α,e).mano,即concat(β,e)的支持度等于concat(α,e)的支持度.又因为β是α的真子情节,所以concat(β,e)也是concat(α,e)的真子情节,从而根据定义9可知,以α为前缀的concat(α,e)不是生成子情节.证毕.以表2为例,因为〈ABA〉.mano=〈AA〉.mano且〈ABA〉〈AA〉,所以情节〈ABA〉及以其为前缀的任何其它情节(如〈ABACE〉)都是非生成子情节.由于算法Extractor在过程MineGrow中已通过比较频繁情节α与其前向扩展的支持度来检查α的当前前向扩展是否为生成子,所以在得到频繁情节集FE后,针对尚未确定为生成子的频繁情节β而言,我们只要通过比较β与β的其它真子情节的支持度就可以确定β是否为生成子.下面是生成子Page6检查的伪代码.ProcedureCheckGenerator(α)Input:α:afrequentepisodeObjective:checkwhetherepisodeαisagenerator1.Ifα.gen=-12.Ifβs.t.β.mano=α.manoandβα3.Setthegeneratorsofαandanyepisodewithα根据置信度的不同,无冗余情节规则可以分为4.Else5.Fori=1to|α|-1do6.Letβ=〈E1…Ei-1Ei+1…E|α|〉7.Ifβ∈FEandβ.s=α.s8.Letα.gen=-19.Break10.Return4.3规则产生如下两个类别.类别1.无冗余精确情节规则,即置信度等于100%的无冗余情节规则.设C为频繁闭情节集,Gf为C中频繁闭情节f的所有情节生成子组成的集合,则所有的无冗余精确情节规则可以表示为集合:RE={(l,r,s,c,w)|l∈Gf∧r=project(f,l)∧f∈C∧l≠f},式中:l是频繁闭情节f的一个情节生成子,约束条件l≠f保证了一个情节规则的前件不能为空.定理1.无冗余精确情节规则集蕴含了所有精确情节规则的信息.证明.设γ是一个由频繁闭情节f得到的精确情节规则,因为γ.c=100%,所以γ.s=concat(γ.l,γ.r).s=(γ.l).s.对于f而言,必然存在一个无冗余精确情节规则γ,满足γ.l是f的情节生成子,γ.s=concat(γ.l,γ.r).s=(γ.l).s=f.s,且γ.lγ.lconcat(γ.l,γ.r)f,即表示γ的前件和后件可由γ得到.因为γ.lγ.lconcat(γ.l,γ.r)f,所以f.sconcat(γ.l,γ.r).s(γ.l).s(γ.l).s.由于f.s=(γ.l).s=γ.s,所以γ.s=concat(γ.l,γ.r).s=γ.s,即表示γ的支持度可以由γ得到.由于γ.lγ.l,γ.rγ.r,且情节规则主要用于在前件发生时预测后件的发生情况,所以γ的窗口宽度蕴含了γ的窗口宽度.类别2.无冗余近似情节规则,即置信度小于100%的无冗余情节规则.设C、G分别为频繁闭情节集和情节生成子集,δ(α)表示一个与频繁情节α具有相同支持度的频繁闭情节,则所有的无冗余近似情节规则可以表示为集合:RA={(l,r,s,c,w)|l∈G∧r=project(f,l)∧f∈C∧δ(l)f},式中:l是频繁闭情节δ(l)的情节生成子,δ(l)是另一个频繁闭情节f的真子情节.定理2.无冗余近似情节规则集蕴含了所有近似情节规则的信息.证明.设γ是一个近似情节规则,因为γ.c<100%,所以δ(γ.l)δ(concat(γ.l,γ.r)).对于γ.l和concat(γ.l,γ.r)而言,存在两个情节生成子g1和g2,满足g1γ.lδ(γ.l)=δ(g1),g2concat(γ.l,γ.r)δ(concat(γ.l,γ.r))=δ(g2).因为γ.lconcat(γ.l,γ.r),所以γ.lδ(g1)concat(γ.l,γ.r)δ(g2),这说明必然存在一个无冗余近似情节规则γ满足γ.l=g1,γ.r=project(δ(g2),g1).因为g1γ.lδ(g1)concat(γ.l,γ.r)δ(g2),所以γ的前件和后件可由γ得到.由于γ.s=concat(γ.l,γ.r).s=δ(g2).s=γ.s,所以γ的支持度可由γ得到.因g1γ.lδ(g1),故(g1).s=(γ.l).s=δ(g1).s,γ.c=concat(γ.l,γ.r).s/(γ.l).s=δ(g2).s/δ(g1).s=concat(γ.l,γ.r).s/(γ.l).s=γ.c,表示γ的置信度可由γ得到.下面是规则产生的伪代码.PrecedureFormRule(FE,min_conf,R)Input:FE:asetoffrequentepisodesaftercheckingObjective:generateallnon-redundantepisoderules1.LetR=2.Foreachf∈FEwithf.clo=0do3.Foreachg∈FEwithg.gen=0do4.Ifgf5.Letr=project(f,g)6.Letα=concat(g,r)7.Ifα.s/g.smin_conf8.LetR=R∪(g,r,α.s,α.s/g.s,α.w)4.4运行实例设给定的事件序列为ES1,min_sup=2,min_conf=0,现使用算法Extractor发现ES1上所有的无冗余情节规则.挖掘时得到的情节生成子和无冗余情节规则分别如表5和表6所示.情节生成子支持度情节生成子支持度〈A〉〈B〉〈C〉〈E〉Page7前件后件支持度置信度/%窗口宽度〈AA〉〈B〉〈AA〉〈CE〉2100〈C〉〈E〉〈A〉〈AB〉2〈A〉〈B〉〈A〉〈BACE〉2〈B〉〈ACE〉2〈AB〉〈ACE〉2〈BA〉〈CE〉2〈B〉〈A〉3〈B〉〈AB〉2〈BA〉〈B〉由表3和表6可以看出,相对于所有情节规则,算法Extractor抽取的无冗余情节规则不仅在数据量上大大减少,而且没有丢失其它情节规则的信息.4.5算法复杂度分析设L为事件序列为ES的长度,ε为ES中的事件类型集,FE为ES上所有频繁情节组成的集合,则算法Extractor的复杂度分析如下.定理3.Extractor的时间复杂度为Ο(|FE|·|ε|·L).证明.情节增长、闭合性检查、生成子检查、规则产生是Extractor的主要时间代价.(1)完成一次以已存在的频繁情节α为前缀、频繁1-情节e为后缀的情节增长操作,只需单遍扫描mo(α)和mo(e),其时间复杂度为Ο(L).而Extractor只需以FE中的每个情节为前缀进行情节增长,增长的次数至多为频繁1-情节的个数,其上界为|ε|,因此,Extractor为完成全部的情节增长操作所需的时间复杂度为Ο(|FE|·|ε|·L).(2)在闭合性检查之前,由所有频繁情节组成的集合FE中至多存在|FE|个闭合性待定的频繁情节,对于每一个这样的情节α而言,确定其闭合性在最坏的情况下需要比较α的支持度与其2|ε|(|ε|为频繁1-情节个数的上界)个中间扩展及后向扩展的支持度,而每一个这样的扩展又至多出现在情节α中的任一位置上,所以完成所有闭合性检查的最坏时间复杂度为Ο(|FE|·|ε|·|α|)Ο(|FE|·|ε|·L).(3)生成子检查的时间消耗与闭合性检查相同,其最坏时间复杂度也为Ο(|FE|·|ε|·L).(4)频繁闭情节的个数上界为|FE|,所以规则产生过程所需的最坏时间复杂度为Ο(|FE|·|FE|)Ο(|FE|·|ε|·L).综上,算法的时间复杂度为Ο(|FE|·|ε|·L).定理4.Extractor的空间复杂度为Ο(|FE|2).证明.算法需要维护所有频繁闭情节及情节规则,所以空间复杂度为Ο(|FE|2).5实验评估我们通过9组实验对比了算法Extractor、TASA[2]和WinMiner[3]的时空性能和挖掘质量.为了能够客观地评价3个算法,我们对TASA和WinMiner进行了适当调整,即均使用与Extractor一样的最小且非重叠发生的情节支持度定义,修改后的TASA和WinMiner分别表示为TASA_mano和WinMiner_mano.实验采用的硬件环境为2GHzIntel(R)Core(TM)2DuoCPU,内存2GB,操作系统为WindowsXP,程序采用Java实现.5.1数据集对于合成数据集,我们首先使用IBM合成数据生成器QuestMarket-Basket的修改版生成了每个交易为单个项的交易序列,通过设置D=0.001,C=300000,N=20,S=300000,其中参数D表示交易序列的个数(单位为1000),C表示每个交易序列中交易的平均个数,N表示所有交易项的类型种数(单位为1000),S为最长交易序列中交易的平均个数,这样就得到了一个20000种交易项类型上的由300000个交易组成的交易序列.然后,为该交易序列中的每个交易依次赋上一个连续的正整数以作为每个交易发生的时间戳,这样,我们就构造了一个20K种事件类型上的由300K个事件组成的事件序列.对于真实数据集,考虑到作为国内最具影响力的知识传播与数字化学习平台,中国知网CNKI①为全社会提供了最丰富、最全面的文献资源,为了能够发现CNKI中相关文献之间的引用关系,并为广大学者展开相关研究提供个性化的推荐服务,我们选用了CNKI的一个Web服务器上从2010年11月1日至2010年11月30日的日志数据,该日志数据包括了相关读者对132885种不同文献的211665个阅读序列.5.2实验结果实验1.运行时间与支持度阈值的关系.选择300K合成数据集和30天真实数据集,在设定置信度阈值为60%的前提下,通过改变支持度阈值,得①http://www.cnki.netPage8到了如图1所示的3个算法在两个数据集上的运行时间(以ms为单位).可以看出,随着支持度阈值的减小,3个算法的运行时间都线性增加,但Extractor要优于TASA_mano和WinMiner_mano,且它们的运行时间之差随着支持度阈值的减小而不断增加,导致上述事实的主要原因是:TASA_mano和WinMiner_mano旨在发现所有的情节规则,并分别采用了广度优先和深度优先的搜索策略,而Extractor基于深度优先的搜索策略,并内嵌了一个优化技术,旨在发现无冗余的情节规则.实验2.运行时间与置信度阈值的关系.选择300K合成数据集和30天真实数据集,在设定这两个数据集的支持度阈值分别为800和7的前提下,通过改变置信度阈值,得到了如图2所示的3个算法在两个数据集上的运行时间(以ms为单位).可以看出,随着置信度阈值的减小,3个算法的运行时间也在线性增加,但Extractor要优于TASA_mano和WinMiner_mano,原因同实验1的解释.我们同时还观察到:相对于支持度而言,置信度对3个算法运行时间的影响要相对平稳,这是因为3个算法均是首先基于支持度阈值发现频繁情节,然后再基于置信度阈值来产生情节规则.实验3.运行时间与序列长度的关系.首先从300K合成数据集中选择前100K、前150K、前200K、前250K个事件作为4个合成子序列;再从30天真实数据集中选择前6天、前12天、前18天、前24天的事件作为4个真实子序列;然后通过设定合成数据集和真实数据集的支持度阈值分别为800和7,置信度阈值均为60%,得到了如图3所示的序列长度对算法时间性能的影响.可以看出,3个算法的运行时间都随着序列长Page9度的增加而线性增加,且3个算法的时间性能对比同实验1,产生这些现象的原因与实验1的解释相同.实验4.内存开销与支持度阈值的关系.选择300K合成数据集和30天真实数据集,在设定置信度阈值为60%的前提下,通过改变支持度阈值,得到了得到了如图4所示的3个算法在两个数据集上的内存开销(以KB为单位).可以看出,随着支持度阈值的减小,3个算法的内存开销都在线性增加,但Extractor要优于TASA_mano和WinMiner_mano,原因与实验1的解释相同.实验5.内存开销与置信度阈值的关系.选择300K合成数据集和30天真实数据集,在设定它们的支持度阈值分别为800和7的前提下,通过改变置信度阈值,得到了如图5所示的算法在两个数据集上的内存开销(以KB为单位).可以看出,随着置信度阈值的减小,算法的内存开销都在线性增加,但Extractor要优于TASA_mano和WinMiner_mano,原因与实验1的解释相同.实验6.内存开销与序列长度的关系.通过设定合成数据集和真实数据集的支持度阈值分别为800和7,置信度阈值均为60%,得到了如图6所示的序列长度对3个算法内存开销的影响.可以看出,3个算法的内存开销都随着序列长度的增加而线性增加,但Extractor要优于TASA_mano和WinMiner_mano,原因与实验1的解释相同.实验7.规则个数与支持度阈值的关系.选择300K合成数据集和30天真实数据集,在设定置信度阈值为60%的前提下,通过改变支持度阈值,得Page10到了如图7所示的3个算法在两个数据集上发现的情节规则个数.可以看出,随着支持度阈值的减小,3个算法均发现了更多的情节规则,这是因为支持度阈值越小,基于越多的频繁闭情节和情节生成子产生的情节规则也就更多.我们同时还观察到:Extractor发现的规则个数远少于TASA_mano和WinMiner_mano,这是因为Extractor产生的是无冗余情节规则,而TASA_mano和WinMiner_mano产生的是所有情节规则.实验8.规则个数与置信度阈值的关系.选择300K合成数据集和30天真实数据集,在设定这两个数据集的支持度阈值分别为800和7的前提下,通过改变置信度阈值,得到了如图8所示的算法在两个数据集上发现的情节规则个数.可以看出,随着置信度阈值的减小,3个算法均发现了更多的情节规则,但Extractor的规则个数远少于TASA_mano和WinMiner_mano,原因与实验7的解释相同.实验9.规则个数与序列长度的关系.通过设定合成数据集和真实数据集的支持度阈值分别为800和7,置信度阈值均为60%,得到了如图9所示的序列长度对算法所发现情节规则个数的影响.可以看出,随着序列长度的增加,3个算法均发现了更多的情节规则,但Extractor的规则个数远少于TASA_mano和WinMiner_mano,原因与实验7的解释相同.6结论现有的情节规则挖掘算法存在挖掘质量不高、挖掘效率较低等不足.本文提出的情节规则挖掘算法Extractor基于最小且非重叠发生来计算一个情Page11节的支持度,避免了情节发生的“过计数”问题,保证了频繁闭情节及其生成子的挖掘质量;采用深度优先的搜索策略并结合非生成子情节的Apriori性质,加快了频繁闭情节及其生成子的挖掘过程;直接由频繁闭情节及其生成子产生无冗余情节规则,提高了情节规则的生成质量和生成效率.理论分析和实验评估证明算法Extractor能够有效地抽取给定事件序列上的所有无冗余情节规则.
