Page1两层传感器网络中隐私与完整性保护的范围查询协议李睿林亚平易叶青胡玉鹏(湖南大学信息科学与工程学院长沙410082)摘要针对两层传感器网络中存储节点更容易受到攻击这一问题,文中提出一种隐私与完整性保护的范围查询协议:VQuery.VQuery在保证存储节点正确执行查询的同时能有效防止敏感数据与查询条件的泄露.为了保护数据的隐私性,提出了一种基于多项式技术的隐私保护方案,该方案利用多项式技术对节点采集的数据范围信息和查询条件进行编码,保证存储节点在不知道数据和查询条件真实内容的情况下正确地执行查询处理.为了保护查询结果的完整性,提出了一种基于水印链技术的完整性认证方案,该方案能有效检测查询结果的完整性.为了对多维数据查询结果的完整性认证,提出了一种多维区间树的数据结构来表示多维数据.分析和实验结果论证了VQuery协议的有效性.关键词两层传感器网络;隐私与完整性保护;范围查询;多项式;水印链1引言无线传感器网络为环境监测和移动目标识别与跟踪提供了一种非常经济的分布式解决方案[1-2].本文研究两层架构的传感器网络(Two-tieredsensornetworks),如图1所示.在两层传感器网络中,存储节点为附近的传感器提供数据存储服务的同时,也负责执行Sink发送来的查询处理.相对于传统的传感器网络,两层传感器网络具有3个明显的优势:(1)每个传感器可将数据发送到附近的存储节点,不必以多跳的形式发送给远处的Sink,从而降低了传感器的通信开销;(2)每个传感器可以周期性地将采集到的数据提交给存储节点进行存储,大大改善了传感器存储资源不足的问题;(3)查询处理变得更加方便有效,因为当Sink执行查询时只需要和存储节点进行通信,存储节点也只需要在本地执行查询即可.两层传感器网络最先在文献[3]中介绍,然后被广泛应用于各类监测[4-7].目前市面上也出现了一些存储节点的产品如StarGate①和RISE②等.然而,在两层传感器网络当中,存储节点扮演了一个关键角色,因此在敌对环境中更容易招致攻击.一个妥协(compromised)的存储节点将会对网络产生重大的威胁:(1)攻击者可以获取存储或将要存储在妥协的存储节点上的敏感数据;(2)妥协的存储节点可能会向Sink返回虚假的或者不完整的查询结果.在两层传感器网络当中设计一个隐私与完整性保护的范围查询协议是一个非常具有挑战性的难题.其困难之处在于:(1)为了防止信息泄露,传感器在发送数据给存储节点之前需要对数据进行加密处理.同样,Sink发送查询条件给存储节点时也需要对查询条件进行加密.因此需要解决在既不知道查询条件真实值,又不知道待查询数据真实值的情况下如何实现正确的查询处理;(2)一个妥协的存储节点可能会伪造虚假的查询结果或删除一些满足查询条件的数据.因此需要对查询结果进行完整性认证,以检测出这种恶意行为.为此,本文提出了一种新颖的隐私与完整性保护的范围查询协议:VQuery.为了实现隐私保护,VQuery采用多项式技术对数据范围与查询条件进行编码,实现了存储节点在不知道查询条件和数据真实值的情况下,正确地执行查询处理.为了保护查询结果的完整性,本文采用水印链技术,将数据区间形成一条水印链.Sink利用这种水印链技术可以验证查询结果的完整性.为了实现对多维数据查询结果的隐私与完整性保护,本文提出了一种多维区间树的数据结构来表示多维数据.为了验证VQuery的有效性,本文利用IntelLab③提供的真实数据对VQuery协议与已有的协议进行测试与比较.实验结果表明无论在通信开销还是存储空间开销上,VQuery协议均优于已有的协议.本文考虑的传感器采集的数据均为整数,然而在实际中,传感器采集的数据的原始形态可能不是整数,如温度、湿度,但这些数据能很方便转换成整数,因此,经过数据转换后,本文提出的协议也适合这些情况.2相关工作在两层结构传感器网络中,范围查询的隐私与完整性保护问题已引起一些学者的关注[8-11].在隐私保护方面:Sheng和Li[8]及Shi等人[9-10]采用Hacigumus等人[12]提出的用于数据库隐私保护的桶划分方法保护两层结构传感器网络中的范围查询的隐私性与完整性.该方法首先根据数据分布规律将数据划分成多个桶,每个桶分配一个唯一的ID.当传感器完成数据采集后,将这些数据分配到相应的桶内,并加密这些数据,连同桶ID一起发送给最近的存储节点.当Sink执行一个范围查询时,首先将查询条件转换为最小的桶ID集,然后将这个桶ID集作为查询条件发送给存储节点,存储节点找到所有满足条件的桶,将桶内加密数据与桶ID作为查询结果发送给Sink.S&L方案的不足之处在于:在桶划分技术中,一个妥协的存储节点能估算数据与查询条件的实际值[13];对于多维数据,传感器与存储节点的通信能量开销和存储空间开销随维度数①②③Page3的增加呈指数增长.为了解决这一问题,Chen和Liu[11]提出了一种称之为SafeQ的安全查询协议.SafeQ采用前缀编码的方法对查询条件和数据进行编码,一方面能使存储节点正确地执行查询处理,另一方面能有效地防止妥协的存储节点估算数据与查询条件的实际值.相对于S&L协议,在多维数据的情况下,SafeQ协议在存储空间开销和通信能量开销方面有了较大的改善.然而,由于SafeQ采用前缀编码的方法进行隐私保护,需要将采集的n个数据转换为n+1个区间,每个区间需要多个前缀来表示,因此其空间开销与通信能量开销依然很大,这对于资源受限的传感器网络来说是难以承受的.例如,在一个周期中,一个传感器采集了4个数据{9,17,33,43},假定下界与上界分别为1和100.根据SafeQ协议,这些数据将被转换为5个区间{[1,9],[9,17],[17,33],[33,43],[43,100]},用前缀编码的方式表示这些区间为{100,01,001,0001},{1001,101,11,1000},{10001,1001,101,11,10000},{100001,10001,1001,1010},{101011,1011,11,10,11000,1100100}.显然SafeQ需要用23个前缀才能表示这采集的4个数据,其数据量增大了近6倍.在多维情况下,区间数将随维度成倍增长,所需的前缀会非常多.在完整性保护方面:Sheng和Li[8]首先提出了一种基于桶的信息编码技术,该技术的基本思路是让每个传感器为每个空桶产生一个唯一的编码数,Sink利用这些编码数对查询结果的完整性进行认证.为了降低通信能量开销,Shi等人[9-11]则提出了一种时空交错(SpatiotemporalCrosscheck)的校验方案.其基本思想是:每个传感器用一个位图(BitMap)描述哪些桶有数据,并将位图广播给其附近的传感器,每个传感器接收到其它传感器的位图后,将其附加到数据项中,并加密发送给Sink.该方案的不足是:若一个妥协的传感器伪造虚假的位图将会危及其它节点.为了解决这一问题,Chen和Liu[11]提出了一种称之为邻居链表(NeighborhoodChain)的数据结构用于对查询结果进行完整性认证,但在邻居链表中每一个数据将被存储两次,增大了传感器与存储节点的存储空间与通信能量开销.例如,一个传感器采集2个三维数据(3,2,4)和(5,4,7),假定最低界与最高界分别为(0,0,0)和(10,10,10),根据SafeQ,构造这两个数据的邻居界为{(0,0,0)|(3,2,4),(3,2,4)|(5,4,7),(5,4,7)|(10,10,10),(10,10,10)},显然邻居链表的数据量比原始数据量增大了2倍多.数字水印(DigitalWatermarking)技术是将一些标识信息直接嵌入数字载体(如媒体、文档、软件等)当中,但不影响原载体的使用价值,也不容易被人的知觉系统觉察.通过这些隐藏在载体中的信息,可以达到确认内容创建者、购买者、传送隐秘信息或者判断载体是否被篡改等目的[14-15].最近有一些学者应用数字水印技术解决无线传感器网络中的一些安全问题.Feng等人[16]提出了一种知识产权保护技术,该方法利用传感器感知数据可能有微量误差的特性嵌入水印,保护无线传感器网络采集的数据版权.Zhang等人[17]将扩频水印技术用于无线传感器网络,解决安全聚合的问题.在数据完整性认证方面,文献[18]提出了一种水印链技术用于检查流数据的完整性,文献[19]在文献[18]的基础上进一步提出了两种脆弱水印技术,用于传感器数据的完整性认证.3问题陈述与基本假设如图1所示,一个典型的两层传感器网络包括3种类型的节点:传感器、存储节点和Sink.传感器的主要任务是采集环境数据(如温度、湿度等),但数量众多的传感器存储能力与计算能力受限,节点易失效.存储节点相对于传感器来说具有较强的计算能力与较大的存储容量,节点能移动且不易失效.传感器将自身采集的数据周期性地报告给最近的存储节点,用户根据需要向Sink发出查询命令,Sink对查询命令进行改写,然后发送给存储节点,存储节点根据查询命令返回满足条件的数据给Sink,Sink对返回的查询结果进行完整性认证,并将最终结论返回给用户.对于上述两层传感器网络,本文做出如下假设:(1)所有的传感器在部署前分配一个唯一的ID以及预置相应的隐私保护函数,如传感器sη分配的ID为η,预置的隐私保护函数为Pη(x);存储节点预置查询函数Q(x,y);(2)所有传感器与存储节点均是松散同步,本文将时间划分成互不重叠的周期,每个周期内节点采样的次数为n次,传感器sη所采集的数据用三元组(η,t,{d1,d2,…,dn})表示,其中t表示周期序列,d1,d2,…,dn表示传感器采集的数据;(3)每一个传感器单独与Sink共享一个密钥,Page4如传感器sη与Sink共享的密钥为kη.本文假设Sink是可信的.在敌对环境中,传感器和存储节点均有可能被攻击者俘获,当一个传感器被俘获后,攻击者既可以读取传感器内的数据,也可以伪造虚假的数据发送给最近的存储节点.由于传感器缺乏抗篡改机制,要想阻止这类攻击是十分困难的,但传感器数量众多,单个传感器所采集的数据仅仅是整个结果的一个小片段.存储节点与传感器不同,它存储了大量传感器节点的数据,也是执行查询处理的场地,当一个存储节点被俘获时,攻击者可以获取大量的敏感数据,伪造虚假的查询结果或向用户提供不完整的查询结果等,因此妥协一个存储节点其危害性将大大超过妥协一个传感器.本文主要关注存储节点被妥协的情况.4一维数据的隐私与完整性保护4.1一维数据的隐私保护为了保护数据的隐私性,需要对数据进行加密,以防止非法用户的读取.如何在加密后的数据中实施有效的查询处理是一个挑战性的难题.本节主要讨论一维数据的隐私保护方法.一维数据的隐私保护方法的基本过程如下:当传感器sη完成一个周期的数据采集后,首先利用给定的参数Δt将采集的数据分配到相应的数据区间中,并对相邻的空区间进行合并;然后利用密钥kη对每个区间内的数据进行块加密,同时也利用构造的隐私保护函数Pη(x)对区间信息进行编码,然后将加密和编码的结果发送给附近的存储节点.当Sink需要执行一个查询时,Sink先利用查询函数将查询条件转换为关于传感器ID号的函数发送给存储节点,存储节点将按照4.1.3节所描述的方法执行查询处理,并向Sink返回查询结果.下面分别介绍隐私保护函数和查询函数的构造,然后分两个阶段详细介绍一维数据的隐私保护方法.4.1.1隐私保护函数和查询函数的设计本小节讨论隐私保护函数和查询函数的设计.隐私保护函数和查询函数需要满足如下条件:(1)为了使存储节点在不知道数据真实值的情况下能确定哪些数据在查询结果中,隐私保护函数和查询函数都应能对数据保序.另外,采用隐私保护函数编码的结果不能太大,避免消耗过多的空间和能量;(2)不同传感器应具有不同的隐私保护函数,Sink发送查询条件给存储节点后,存储节点应能在采用不同隐私保护函数编码后的数据上进行查询处理;(3)根据Sink发送的查询条件和一个或几个隐私保护函数应不能破解查询函数和其它隐私保护函数.为了满足以上要求,查询函数和隐私保护函数需要包含3部分:(1)数据处理部分g(x,·).数据处理部分应能对数据保序,且g(x,·)计算出的结果值不能太大,避免消耗过多的存储空间;(2)传感器ID处理部分f(y,·).该部分使不同传感器具有不同隐私保护函数,且存储节点能在经过不同隐私保护函数编码后的数据上进行查询处理;(3)结果扰动部分φ(y)和rη,分别对查询函数和隐私保护函数的结果进行扰动,增强查询函数和隐私保护函数的安全性.文献[20]采用多项式技术为动态会议设计了一种密钥分配方案,在该文的启示下,本文查询函数设计如下①:Q(x,y)=∑0i,jτ式(1)中,要求Ai,j为非负整数,τ为该多项式的阶.可以将传感器的ID号也看成是传感器采集的数据,因此,为简单起见,我们让函数g(x,·)和f(x,·)为同一函数.我们参照logistical模型来设计g(x,·).g(x,·)定义如下:g(x,i)=(g(x,i-1)+α)(1+r(g(x,i-1))),i2xi,{式(2)中,α为一个正常数,r(x)定义为r(x)=β(1-x/Nm),1-x/Nm>0式(3)中,β为一个正常数.根据传感器采集的数据的取值范围,选择一个合适的Nm,确保g(x,·)在该范围内是增函数.传感器节点sη的隐私保护函数定义如下:Pη(x)=∑0i,jτ接下来讨论结果扰动部分φ(y)和rη的取值.为满足条件1,当x1>x2时,应有Pη(x1)>Pη(x2)和Q(x1,y)>Q(x2,y)成立.设M(y)是Q(x,y)去掉扰动部分φ(y)对于变量y的最小差值函数,则M(y)为M(y)=∑0i,jτ①与文献[20]区别的是,本文设计的多项式不是对称多项式.Page5式(5)中Bj=∑0iτ是一个单调递增函数,传感器ID1,当y=1时,函数M(y)取最小值:M(1)=∑0i,jτ为一个正整数,且2l-1M(1)2l成立.引入系统参数r(0<r<l-1).扰动部分rη取随机数,且rη∈{0,1,…,2r-1}.显然有Pη(x+1)>Pη(x)成立.接下来讨论扰动函数φ(y)的产生,设φ(y)=∑0jτCjg(y,j)+2r-1,系数Cj(0jτ)为随机数,产生规则为:先产生高阶系数,在高阶系数确定的情况下逐步产生低阶系数,具体如下:烄烅Pη(x+1)成立.烆定理1.当x∈N,有Pη(x)Q(x,η)<证明.首先证明Pη(x)Q(x,η).因为Q(x,η)-Pη(x)=∑0i,jτ所以Pη(x)Q(x,η).接下来证明Q(x,η)<Pη(x+1).因为Pη(x+1)-Q(x,η)=∑0i,jτ∑0i,jτ∑0i,jτ=∑0iτ=∑0iτ>12∑0iτ12∑0i,jτ12∑0i,jτ又因为r<l-1,所以2l-2-2r+12l-2-2l-2+1>0,所以Pη(x+1)>Q(x,η).由于Pη(x)Q(x,η)<Pη(x+1),因此x1>x2,有Q(x1,y)>Q(x2,y)成立,即Q(x,y)对数据保序.传感器在部署前分配唯一的ID号,并预置一个与ID号相关的隐私保护函数.传感器利用隐私保护函数对区间信息进行编码.同时,安全服务器给Sink预置查询函数Q(x,y).当进行范围查询Qt:{t,[a,b]}时,Sink利用查询函数将查询条件转换成Qt:{t,[Qa(y),Qb(y)]}(注:Qx(y)=Q(x,y),该查询条件为关于传感器ID号的一元函数),并将该查询条件发送给存储节点.存储节点接收到查询条件后,为不同传感器采集的数据计算查询条件.设传感器Sη的ID号为η,存储节点为Sη采集的数据计算的查询条件为Qt:{t,[Qa(η),Qb(η)]}.设Sη的一个数据区间为(di,dj],该区间中的数据在查询结果中,当且仅当不等式Qa(η)<Pη(di)Qb(η)或(Pη(di)<Qa(η))∩(Pη(dj)>Qb(η))或Qa(η)<Pη(dj)Qb(η)成立.根据这一条件,存储节点能在不知道数据与查询条件真实值的情况下实现正确查询.4.1.2传感器内的数据处理阶段本小节主要描述传感器怎样处理在一个周期内采集的数据.用(η,t,{d1,d2,…,dn})表示传感器Sη在周期t内采集的数据.当Sη完成一个周期的数据采样后,数据处理过程可以描述为如下两个步骤:1.根据参数Δt划分数据区间{〈(b0,b1],x1〉,〈(b1,b2],x2〉,…,〈(bm-1,bm],xm〉},其中bi-bi-1=Δt,b0与bm分别表示数据可能的最小和最大值,且Sink知道b0与bm的值,(bi-1,bi]表示一个数据范围,xi表示在范围(bi-1,bi]内的数据个数,然后每个传感器将采集的数据分配到相应的区间,并进一步合并相邻的空区间.2.用DSi表示第i个区间(bi,bi+1]内的数据集,则〈(bi,bi+1],(DSi)〉表示第i个区间及该区间内的数据,若DSi为空,则在DSi中加入一个为空的特殊标识符Null.每个传感器利用隐私保护函数对每个区间的起、止值进行编码,然后再利用节点自身的密钥对每个区间的数据集进行加密,去除重复区间信息后发送给最近的存储节点.例如,假设Sη采集的数据为(η,t,{1,2,3,4,7}),Δt=2,b0=1,bm=12.执行步骤1可得到如下区间:{η,t,〈(0,2],2〉,〈(2,4],2〉,〈(4,6],0〉,〈(6,8],1〉,〈(8,10],0〉,〈(10,12],0〉},合并空区间得{η,t,〈(0,2],2〉,〈(2,4],2〉,〈(4,6],0〉,〈(6,8],1〉,Page6〈(8,12],0〉}.在上述例子中Sη的数据可以组织成如下的形式:{η,t,〈(0,2],(1,2)〉,〈(2,4],(3,4)〉,〈(4,6],(Null)〉,〈(6,8],(7)〉,〈(8,12],(Null)〉}.利用隐私保护函数对区间信息进行编码,并利用密钥kη对数据进行加密得{η,t,〈(Pη(0),Pη(2)],(1,2)kη〉,〈(Pη(2),Pη(4)],(3,4)kη〉,〈(Pη(4),Pη(6)],(Null)kη〉,〈(Pη(6),Pη(8)],(7)kη〉,〈(Pη(8),Pη(12)],(Null)kη〉}.去除重复区间信息得{η,t,〈Pη(0),(1,2)kη〉,〈Pη(2),(3,4)kη〉,〈Pη(4),(Null)kη〉,〈Pη(6),(7)kη〉,〈(Pη(8),Pη(12)](Null)kη〉}.传感器Sη将这些经过编码和加密的数据发送给附近的存储节点.4.1.3存储节点内的查询处理阶段本小节主要阐述Sink如何将一个范围查询发送给存储节点,以及存储节点如何在不知真实数据的情况下执行查询处理.当Sink需在存储节点上执行查询Qt:{t,[a,b]}([a,b](b0,bm])时,须执行如下4个步骤:1.Sink首先利用查询函数将查询条件Qt:{t,[a,b]}转换为一个关于传感器ID号函数形式的查询条件Qt:{t,[Qa(y),Qb(y)]}.然后将该查询函数发送给存储节点.2.存储节点接收到Sink发来的查询函数后,分别为每个提交数据的传感器计算查询条件,如给ID号为η的传感器节点Sη计算的查询条件为Qt:{t,[Qa(η),Qb(η)]}.3.存储节点根据最终编码的查询条件完成查询处理.假设传感器Sη提交的数据为{η,t,〈Pη(b0),(DS0)kη〉,…,〈(Pη(bl),Pη(bl+1)](DSl)kη〉},若(DSi)kη满足查询条件,当且仅当不等式(Pη(bi)<Qa(η))∩(Pη(bi+1)>Qb(η))或Qa(η)<Pη(bi)Qb(η)或Qa(η)<Pη(bi+1)Qb(η)成立.4.将查询结果与查询结果所在区间的上、下界信息(用于验证查询结果的完整性)发送给Sink.例如,假设Sη采集数据中满足查询条件的数据为{η,t,〈Pη(bi),(DSi)kη〉,…,〈(Pη(bi+q)],(DSi+q)kη〉}(该数据是已经去除了重复区间信息的数据),则查询结果所在区间的上界为Pη(bi+q+1),下界为Pη(bi).4.2一维数据的完整性保护本文考虑查询结果的完整性保护包括两方面:(1)验证查询结果是否被伪造;(2)验证查询结果中是否有符合查询条件的数据被删除.存储节点在没有获得加密数据密钥的情况下去伪造查询结果,最有可能就是采用重放攻击.因此,本文将数据所在的周期信息嵌入到数据中来防止这种攻击.为了验证满足查询条件的数据是否被删除,本文采用水印链技术[18-19]将数据区间形成一条链,Sink通过验证查询结果中水印链的连续性以及查询结果区间是否覆盖查询区间来确认查询结果中是否有符合条件的数据被删除.采用水印技术最大的好处就是没有额外的数据通信开销和存储开销.一维数据查询结果完整性保护的基本过程可以描述为如下过程:(1)在一个传感器采集的数据中,根据每个区间内数据的大小确定每个区间的前驱与后继;(2)采用Hash的办法为除第一个区间外的每个区间内的数据与当前周期号计算一个长度为l的Hash值;(3)将每个区间的l位Hash值作为水印嵌入到其前驱区间内的数据中,其中l表示嵌入的数据位数,将在第6节中讨论l的取值;(4)当Sink接收到存储节点返回的查询结果时,用户将通过判断水印链的完整性,查询结果的界是否包含查询条件分别验证每个传感器所提供的查询结果是否完整.下面分两个小节分别阐述水印的生成、嵌入和查询结果的完整性认证.4.2.1水印的生成与嵌入假定传感器Sη在周期t内采集的数据被划分成m个区间,DS0,DS1,…,DSm-1分别表示这些区间相应的数据集,用hl(DSi‖t)表示数据集DSi连接周期信息t产生的l位Hash值.hl(DSi‖t)定义如下:hl(DSi‖t)=HASH(DSi‖t)mod(2l-1)(7)式(7)中,HASH()函数为MD5或者SHA,这些Hash函数对任意长度的输入数据产生一个定长的Hash值.水印的生成与嵌入描述为如下的步骤:1.判断每个数据集内的数据是否为空标识,如果为空则用该区间的大小(区间的终止值减去起始值)加入到该数据集合,保证每一个数据集中均存在数据.2.为每个数据集DS0,DS1,…,DSm-1分别产生l位Hash值.3.将hl(DSi‖t)嵌入到DSi-1中,其中i=1,2,…,m,并用函数E(DSi-1,hl(DSi‖t))表示以hl(DSi‖t)为水印嵌入到数据集DSi-1中,具体的水印嵌入过程为:将l位水印数据平均分配给该数据集的每个数据,每个数据将分配到的水印位直接链接到其最低位,如:数据3需要嵌入两位水印‘01’,3的二进制表示为‘11’,链接水印位‘01’后得‘1101’,若数据集中的数据个数大于l,则选取最前(或最后)的l个数据嵌入水印即可,如果数据集中的数据个数太少,本文将不能嵌入到数据中的水印位作为一个数据加入到数据集中,并进行标记.4.2.2查询结果的完整性验证Sink收到查询结果后,首先对每个传感器的数据进行解密,然后对存储节点提供的每个传感器的查询结果进行完整性认证.假定传感器节点Sη所提供Page7的查询结果为(E(DSi,hl(DSi+1‖t)))kη,(E(DSi+1,hl(DSi+2‖t)))kη,…,(E(DSi+q,hl(DSi+q+1‖t)))kη.查询结果所在区间的上、下界分别为Pη(bi+q+1)与Pη(bi),则认证过程主要包含如下步骤:1.首先利用查询函数计算初始查询条件Qt:{t,[a,b]}的最终编码Qt:{t,[Qa(η),Qb(η)]},并判断表达式[Qa(η),Qb(η)](Pη(bi),Pη(bi+q+1)]是否成立,若表达式不成立则表明查询结果不完整,否则继续执行步2.2.对查询结果解密得(E(DSi,hl(DSi+1‖t))),(E(DSi+1,hl(DSi+2‖t))),…,(E(DSi+q,hl(DSi+q+1‖t))).3.从查询结果的每个数据集提取l位水印并恢复为原始的查询结果,即得到查询结果为DSi,DSi+1,…,DSi+q,水印信息为hl(DSi+1‖t),hl(DSi+2‖t),…,hl(DSi+q+1‖t).4.分别计算数据集DSi+1,DSi+2,…,DSi+q的l位Hash值,并将计算得到的Hash值与提取的水印hl(DSi+1‖t),hl(DSi+2‖t),…,hl(DSi+q+1‖t)进行比较,若不匹配则表明查询结果不完整,否则查询结果是完整的.5多维数据的隐私与完整性保护为了实现更为精确的监控,部署在自然环境中的传感器一般会同时监测多种数据,比如,湿度、温度、光强度等,在这种情况下,节点所采集的数据是多维的.一个z维的数据项D可用一个z元组来表示(d1,d2,…,dz),其中dl(1lz)表示第l维的值.一个z维的范围查询包括了z个子范围查询[a1,b1],[a2,b2],…,[az,bz],其中[al,bl]表示在第l维上的范围查询条件.5.1多维数据的隐私保护本文将4.1节的一维数据隐私保护方案扩展为如下的多维数据的隐私保护方案.不妨用{η,t,(D1,D2,…,Dn)}表示传感器Sη在周期t内采集的n个多维数据,式中Dj=(d1情况类似,多维数据隐私保护描述为如下步骤.首先,当一个传感器完成一个周期的数据采集后,利用给定的参数(Δ1t,…,Δzt)将采集的数据分配到相应的多维区间中,考虑到多维数据的复杂性,本文提出了一种多维区间树(Multi-DimensionalRangeTree,MDRT)的数据结构,利用多维区间树可以有效地处理空区间合并问题,达到节省资源的目的.然后,对每个区间内的数据进行块加密以及对区间信息进行编码,将这些加密和编码的数据发送给附近的存储节点.当Sink需要执行查询Qt:{t,([a1,b1],…,[az,bz])}时,与处理一维数据的情况类似,Sink先利用查询函数将查询条件转换为关于传感器ID号的函数的查询条件Qt:{t,([Qa1(y),Qb1(y)],…,[Qaz(y),Qbz(y)])},并发送给存储节点.存储节点接收到Sink的查询条件后,分别为每个传感器计算最终查询条件.如为ID号为η的传感器Sη计算的查询条件为Qt:{t,([Qa1(η),Qb1(η)],…,[Qaz(η),Qbz(η)])}.最后,存储节点根据为每一个传感器计算的查询条件完成查询处理.如Sη的一个区间((b1i1,b1i1+1],…,(bziz,bziz+1])内的数据集(DSi)kηt满足查询条件,当且仅当表达式{(Pη(b1i1)<Qa1(η))∩(Pη(b1i1+1)>Qb1(η))∨(Qa1(η)<Pη(b1i1)Qb1(η))∨(Qa1(η)<Pη(b1i+1)Qb1(η))}∧…∧{(Pη(bz(Qaz(η)<Pη(bziz)Qbz(η))∨(Qaz(η)<Pη(bzi+1)Qbz(η))}的值为真.显然根据这一条件能让存储节点在不知道数据与查询条件真实值的情况下正确判断一个多维数据集是否满足查询条件.本文提出的MDRT是一棵有向树,具有下列5个性质:(1)在MDRT中存在一个没有入边(incomingedges)的节点,称之为根节点,在MDRT中也存在一些没有出边(outgoingedge)的节点,称之为终端节点(或叶子节点);(2)处在MDRT中第1层的每条边表示第1维的一个子区间,第2层的每条边表示第2维的一个子区间,…,第z层的每一条边表示第z维的一个子区间;(3)同一层上的同一个节点的出边所表示的子区间互不交叠.任何一条由根节点到叶子节点的路径长度都相等;(4)从根节点到叶子节点的一条有向路径均表(5)每个节点均有一个标签,叶子节点的标签是满足由根节点到叶子节点的路径所表示的多维区间内的元素的个数,非叶子节点的标签则用节点所处的层数来表示.如果一棵MDRT的第i层(1iz,根节点为第1层)的共父节点的每个节点的出边所表示的子区间是连续的,并且将这些子区间合并之后就是第l维的整个范围,本文称这样的MDRT为完全多维区间树(CompleteMulti-DimensionalRangeTree,CMDRT).对于一棵MDRT,如果不是一棵CMDRT,可以插入一些子树使之成为CMDRT,基本思路是按照层次扫描MDRT及其子树,当发现任意MDRT树中,根结点的下一层的孩子结点不能覆盖其对应示一个多维区间;Page8的范围,则插入相应的孩子结点,使该层结点所覆盖的范围与对应层的范围一致.例如,对于图2,以D1为根结点的MDRT树,其孩子结点覆盖的范围是(0,3]∪(3,6]∪(6,9]=(0,9];该层实际对应的范围是(0,12],因此插入子树根结点(9,12].然后依次处理各层,得到如图3所示的CMDRT.下面结合一个实例来阐述多维数据的隐私保护的具体过程.假定传感器Sη在周期t内采集的数据为{η,t,((1,3),(2,2),(2,1),(3,1),(3,2),(1,10),(2,10),(2,11),(3,12),(4,5),(4,4),(4,6),(5,6),(6,6),(7,10),(7,11),(8,10),(9,12))},参数Δt=(3,3),每维取值范围均为[1,12].按照上述的方法将传感器Sη的数据分配到如下4个多维区间:〈((0,3],(0,3]),((1,3),(2,2),(2,1),(3,1),(3,2))〉,〈(0,3],(9,12],((1,10),(2,10),(2,11),(3,12))〉,〈(3,6],(3,6],((4,5),(4,4),(4,6),(5,6),(6,6))〉,〈(6,9],(9,12],((7,10),(7,11),(8,10),(9,12))〉.然后,将这些非空的多维数据区间构造成一棵多维区间树(如图2所示),再将多维区间树转换成完全多维区间树,本例插入5个空区间即可转换为一颗完全多维区间树(如图3所示),在这5个空区间内加入空标识后得〈((0,3],(3,9]),(Null)〉,〈((3,6],(0,3]),(Null)〉,〈(3,6],(6,12],(Null)〉,〈((6,9],(1,9]),(Null)〉,〈((9,12],(0,12]),(Null)〉.再利用隐私保护函数对多维区间信息进行编码,利用私钥加密区间内的数集,将结果发送给附近的存储节点.当Sink需要在存储节点上执行查询[4,12][1,9]时,Sink首先用查询函数将查询条件转换成关于传感器ID的函数并发送给存储节点.存储节点收到Sink发来的查询条件后,为每一个传感器节点计算最终查询条件并执行查询处理,将查询结果与查询结果的上、下界发送给Sink.与一维数据不同的是,查询结果的界为一个多维区间,它是每一维上的查询结果的界的最大公共界,在上述的实例中查询结果的最大公共界为((3,12],(0,9]).5.2多维数据的完整性保护多维数据查询结果的完整性保护与一维数据查询结果的完整性保护一样,同样需要验证查询结果是否被伪造以及满足查询条件的数据是否被删除.为了有效验证多维数据查询结果的完整性,本文将一维数据中使用的水印链技术扩展为多水印链技术,多水印链技术与4.2节的水印链技术最主要的区别是在一个多维的查询结果中只有最后一维数据不同的数据通过水印链接起来的,因此在一个多维的查询结果中存在多条水印链.多维数据的查询结果的完整性保护的基本过程描述为如下过程:(1)根据参数(Δ1t,…,Δzt)将传感器采集的数据分别配到相应的区间,然后建立一棵MDRT树,并将所建立的MDRT转换为相应的CMDRT;(2)根据每个区间在CMDRT中的位置确定每个区间的前驱与后继,具体方法为:若叶子节点ui与叶子节点uj共父节点且节点ui在uj的左边,ui与uj间再无其它节点,则称ui是uj前驱,那么从根节点到ui的路径所表示的多维区间则是从根节点到uj的路径所表示的多维区间的前驱;(3)利用Hash函数为一个具有前驱区间的多维区间内的数据产生l位Hash值;(4)将每个区间的l位Hash值作为水印嵌入到其前驱区间内的数据中;(5)当Sink接收到存储节点返回的查询结果时,用户将通过判断水印链的完整性以及查询结果的界是否包含查询条件,分别验证每个传感器所提供的查询结果的完整性.在多水印链技术中水印的生成、嵌入和提取与4.2节所描述的水印链技术是一致的,当Sink接收到存储节点返回的查询结果时,同样用户通过判断水印链的完整性以及查询结果的界是否包含查询条件,其步骤与4.2节一维数据的完整性认证一致.例如,一个传感器有如下的区间与数据:〈((0,3],(0,3]),((1,3),(2,2),(2,1),(3,1),(3,2))〉,〈(0,3],(9,12],((1,10),(2,10),(2,11),(3,12))〉,〈(3,6],(3,6],((4,5),(4,4),(4,6),(5,6),(6,6))〉,〈(6,9],(9,12],((7,10),(7,11),(8,10),(9,12))〉,〈((0,3],(3,9]),(Null)〉,Page9〈((3,6],(0,3]),(Null)〉,〈(3,6],(6,12],(Null)〉,〈((6,9],(1,9]),(Null)〉,〈((9,12],(0,12]),(Null)〉,即对应了图3所示的CMDRT,根据上述描述的多水印链技术,区间(0,3],(0,3])没有前驱,区间(0,3],(3,9]的前驱区间为(0,3],(0,3].同样区间(3,6],(0,3]无前驱区间,区间(3,6],(3,6]的前驱区间为(3,6],(0,3].图4描述了这些区间的前驱关系.6分析首先对本文方案进行复杂性分析与安全性分析.复杂性分析主要包括传感器处理数据的时间复杂度与空间复杂度以及存储节点处理数据的空间复杂度;安全性分析主要包含数据的隐私性与查询结果的完整性.然后再讨论方案中的一些重要参数的取值问题.6.1复杂度分析假定一个传感器在一个周期内采集了n个数据,z表示数据的维数.表1分别列出本文所提协议针对单个传感器、存储节点以及Sink节点的计算复杂度、通信能量开销与存储空间复杂度,其中计算复杂度均是考虑最坏情况下的计算复杂度.SensorStorageNodeSinkO(z)查询条件处理6.2安全性分析(1)隐私性分析在两层结构的传感器网络中,当存储节点被妥协时,本文提出的隐私保护方法能有效地保护数据的隐私性.这是因为:本文方案让每个传感器在递交数据给存储节点之前,利用预置的密钥对数据进行加密.如果没有加密的密钥,攻击者仅通过存储节点存储的密文来计算每个传感器采集的数据是十分困难的.接下来讨论查询函数和隐私保护函数的安全性.本文在文献[20]的研究结果的基础上设计了查询函数和隐私保护函数.文献[20]采用的是对称多项式,并证明了当多项式的阶为t时,所提方案是t安全的,即攻击者妥协节点小于t的情况下无法破解剩下的多项式.本文设计的查询函数和隐私保护函数与文献[20]存在两点不同:(1)本文多项式为非对称;(2)本文设计了函数g(x,i)来替代文献[20]中的指数函数xi,用函数g(x,i)代替xi是为了减小计算结果的值,在安全性上没有降低.本文与文献[20]在安全性的分析上是一致的.我们从两个方面来分析所设计查询函数和隐私保护函数的安全性:①攻击者妥协小于τ个传感器节点,并获得妥②攻击者俘获任意多个查询条件以及妥协一个传感器节点并获得妥协节点上的隐私保护多项式(妥协不超过τ个传感器与妥协一个传感器情况是相同的).对于第1种情况,本文的安全分析与文献[20]相同,为简单起见,我们先不考虑扰动系数的问题.假设攻击者妥协了k(k<τ)个传感器节点,并获得其上的隐私保护函数,可以得到如下方程组(以g(x,i)的系数为例):协节点的隐私保护多项式;该方程组中存在τ个系数但只有k个方程,根据文献[20]的研究结果,当k<τ时,攻击者无法破解这些系数.另外,本文设计的隐私保护函数增加了扰动系数,进一步地增加了破解者的破解难度.从上述分析可以看出,在实际应用中应为查询函数和隐私保护函数选取合适的τ值.接下来分析第2种情况,即攻击者妥协了存储节点以及一个传感器Sη并获得隐私保护函数Pη(x)的情况下是否能破解查询函数和其它传感器的隐私保护函数问题.设攻击者收集到Sink发送的查询条件Q:{t,Qa(y),Qb(y)},可将Sη的ID号代入该查询函数计算出结果,并建立如下方程:∑0i,jτ要破解查询函数或者其它传感器的隐私保护函Page10数,关键是求解系数Ai,j.由于隐私保护函数Pη(x)的单调性以及已知传感器采集数据的范围,采用二分查找法可查找出式(9)中的查询值‘a’.但式(9)中涉及的φ(y)是随机扰动函数,对于不同的查询条件,φ(y)不同,φ(y)中的系数是在一个范围内的随机数,系数Ck的取值范围为Ck∈0,…,1Ai,j-∑k+1jτ整体考虑,其取值范围是(0,2r-1)(注:参数r在4.1.1节中已经说明).攻击者收集到n个查询多项式后可以建立n个等式,这些等式中共有n+τ+1个未知数,要破解系数Ai,j,攻击者需要猜测τ+1个φ(y)的取值,其破解难度至少是Ω(2r×(τ+1)).(2)完整性分析在一个两层结构的传感器网络中,本文方案能让用户有效地验证查询结果的完整性.本文的主要思想是:让每个传感器利用上述的方法为每个区间内的数据生成水印并嵌入到其前驱区间的数据中,每个数据区间通过嵌入水印后能形成一条或多条链,Sink通过判断水印链的完整性以及查询结果的界是否包含查询条件来验证查询结果的完整性.由于传感器在递交数据给存储节点前将嵌入水印的数据进行加密,因此一个妥协的存储节点在没有获得传感器密钥的情况下要想伪造一个合法的数据并为其嵌入合法的水印是十分困难的.此外,删除一些查询结果中的数据则破坏查询结果内的水印链的完整性.根据文献[18]的分析,删除一个数据块,而不被检测出来的概率为1/2l-1.下面讨论水印长度l的取值问题.显然,l的值越大,本文的方案检测恶意行为的概率就越高,但l的值受到通信开销的约束.在本文的方案中为了保护数据的隐私性,同时也为了方便查询,每个传感器在向存储节点递交数据之前将数据进行块加密,由于传感器资源受限,不太可能使用开销较大的非对称加密机制,因此选用开销相对较小的DES对称加密机制.DES是一种分组密码体制,要求明文按64位一组分成若干组,若不足64bit,则使用任意的二进制流填充,密钥长为56位.假定每个传感器采集的每个数据长度为16bit,首先讨论数据不进行压缩的情况,在保证不增加通信量的情况下,可以嵌入的水印长度.由于传感器采集的数据的高位上通常有2~3位的冗余(16bit的数据最大可以表示65536,而实际的采集的数据通常小于10000),可以利用这些位以及进行加密时需要填充的数据位嵌入水印.因此,当数据集中只有一个数据时,则至少可以嵌入48+2=50bit的水印位(其中48bit为填充位,2bit为数据冗余位).同理若数据集中只有2个数据,至少可嵌入36bit的水印位.最坏情况,若数据集中恰有4个数据,其长度为64bit刚好构成一个组,只能利用数据冗余位至少可嵌入8位水印.当数据集中的数据多于4个时,则可以嵌入的水印位又会增加,因为一个数据集对应的加密数据块会增加,为水印的嵌入提供了更多的空间.因此,当数据集中含有4个数据的时候可以嵌入的水印位最少.我们希望在数据集中含有4个数据时,能嵌入更多的水印位.因此,我们采用数据压缩的办法寻找更多的数据位用于水印的嵌入.按照本文的方案,当数据集不为空时,该数据区间的取值范围由参数Δt确定,因此在该区间中数据的最大增量可以用log2Δt位来表示.因此,该数据块中可以用于嵌入水印的位为64-14-3log2Δt位.其中‘14’是表示用14位表示该数据集中的最小数据,3log2Δt表示用增量式方式表示后面3个数据所需要的位数.当Δt100时,可以嵌入的水印位至少为29位.则删除一个数据块不被检测出来的概率非常小.6.3查询结果的假阳性分析当利用区间信息对密文直接进行查询操作时,其查询结果集为正确结果集的一个超集(含有错检的数据),因此本文称这一问题为查询结果的假阳性问题.该结果集以密文的形式发送给Sink,Sink进行解密后进行处理,得到正确的查询结果后返回给用户.为了定量分析查询结果的假阳性问题,设区间(bi-1,bi](bi-bi-1=Δt)为查询结果中的任意区间.用向量犞=(v1,v2,…,vΔt)(v1<v2<…<vΔt)表示所有可能处于区间(bi-1,bi]内的数据,用向量犉犞=(fv1,fv2,…,fvΔt)表示向量犞内数据在区间(bi-1,bi]内的频度,并设N=∑Δt例如,区间(0,5]内有数据{1,1,1,2,2,5},则犞=(1,2,3,4,5),犉犞=(3,2,0,0,1).根据本文的协议易知,若(bi-1,bi][a,b]时,区间(bi-1,bi]内所有的数据都满足查询条件,因此该区间没有假阳性现象.若bi-1<abi或bi-1<bbi时,区间(bi-1,bi]内只有部分的数据满足查询条件,因此存在假阳性问题.首先考虑bi-1<abi情况.当a=v1时,数据(v1,v2,…,vΔt)都满足查询条件,不满足查询条件的Page11数据个数为0;当a=v2时,数据(v2,…,vΔt)都满足查询条件.不满足查询条件的数据个数为f1;当a=v3时,数据(v3,…,vΔt)都满足查询条件.不满足查询条件的数据个数为f1+f2;由此类推,当a=vi时,数据(vi,…,vΔt)都满足查询条件.不满足查询条件的数据个数为f1+f2+…+fi-1.假定a为(v1,v2,…,vΔt)中任意一个值的概率相等,因此不满足查询条件的数据个数的期望数为Δtf1+11同理可得,当bi-1<bbi时不满足查询条件的数据个数的期望数为1ΔtfΔt+1当b-a>Δt时,上述两种情况都会同时存在于查询结果之中,因此查询结果的假阳性的总期望值为式(10)与式(11)的和,即得6.4参数分析传感器递交数据量的大小与存储节点返回查询结果数据量的大小是衡量本文的协议的效率的两个重要指标.实际上,传感器递交数据量是由两部分组成,一部分是传感器采集的加密后的数据,这部分的数据量的大小与参数Δt值无关,只与周期的长短与实际上,对于传感器的通信能量开销和存储节点的存储空间开销是一致的,Δt的值越大,则传感器的通信能量开销和存储节点的存储空间开销越小.由于查询结果的最小化问题已经合理地平衡了假阳性问题与区间信息的大小,因此用上述模型的结果作为传感器最优结果.考虑多维数据的情况,令传感器Si所采集的n个多维数据中dln与dl1分别代表第l(1lz)维中最大值与最小值,参数Δt=(Δ1t,Δ2t,…,Δzt),同样忽略区间(bl0,dl1]与(dln,blm]对结果的影响,将这些采集的数据分配至∏z采样频率有关;另一部分数据是编码后的区间信息,显然Δt值越小区间数越多,相应的信息量也就越大.由于本文协议与已有的工作一样,在查询结果中存在着假阳性问题,假阳性问题越突出,则存储节点的返回给Sink的查询结果就越大,由6.3节的结论可知,假阳性的大小与Δt取值有关,显然Δt的值越大区间数越少,每个区间内的数据量越多,因此假阳性问题越突出.为了得到参数Δt的最优值,建立如下的数学模型.考虑一维数据的情况,令传感器Si所采集的n个数据按升序排列为{d1,d2,…,dn},由于本文的方案会对相邻的空区间进行合并,因此忽略区间(b0,d1]与(dn,bm]对结果的影响,将这些采集的数据划入(dn-d1)/Δt个区间,平均每个区间将有nΔt/(dn-d1)个数据,由6.3节对假阳性分析的结论可知对于任意查询,其假阳性的大小约为nΔt/(dn-d1).用ω表示平均每个区间所需的编码信息量.要使本文的协议效率达到最高,只要区间信息与假阳性两者之和最小即可,因此可得到如下的目标函数:min(ω×(dn-d1)/Δt+nΔt/(dn-d1))(13)式(12)是一个单决策变量的优化模型,不妨令G(Δt)=ω×(dn-d1)/Δt+nΔt/(dn-d1),因为(ω×(dn-d1)/Δt)×(nΔt/(dn-d1))≡ωn,所以当且仅当ω×(dn-d1)/Δt=nΔt/(dn-d1)时G(Δt)有最小值.考虑到约束条件Δt为非负整数,参数Δt的值为)Gdn-d1n×n槡ω()>Gdn-d1n×n槡ω(阳性分析的结论可知对于任意查询,其假阳性的大小约为n∏z编码信息量.要使本文的协议效率达到最高,只要区间信息与假阳性两者之和最小即可,因此可得到如下的规划方程:式(14)是一个单决策变量的优化模型,不妨令G(Δ1t,…,Δzt)=ω∏zG(Δ1t,…,Δzt)的极值即可转换为求解如下的方程组:Page12l=1Δ1t∏zΔ2t∏zΔzt∏zl=1l=1求解上述方程组并对结果取整后即可得到Δ1t,…,Δzt的最优值.7实验为了验证VQuery的有效性,本文将VQuery与已有工作(包括SafeQ-bloom[11]、SafeQ-basic[11]、S&Lscheme[8])进行详细的比较.我们在OMnet++平台上实现了VQuery、SafeQ与S&Lscheme.并采用平均通信开销和存储空间开销两个指标来评估实验结果,为了增强实验结果的可信性,本文仍采用SafeQ[11]与S&Lscheme[8]所使用的测试数据集,该数据集是由IntelLab部署的具有44个节点的真实传感器网络,在2004年1月3日至2004年3月10日期间内所采集的数据,并且每个节点同时采集了3个方面的数据即:温度、湿度与电压.为了得到不同维度的测试数据,仿照SafeQ,取温度数据作为一维数据集,取温度和湿度作为二维测试数据集,取温度、湿度和电压则作为三维测试数据集.本文采用两种方案与SafeQ与S&Lscheme进行比较:方案1,采用与SafeQ相同的网络拓扑,即将44个传感器分成4个组,每个组内有11个传感节点和一个存储节点;方案2,将44个传感器作为一个组,所有传感器采集的数据提交到一个存储节点上.在VQuery协议的实现中,参数Δt的取值直接影响能量开销和查询结果的精确度问题.为了进一步验证和直观化6.3节中的分析结果,本文对该参数进行了实验.为便于分析,本文考虑一维数据在时隙time-slot=1情形下的查询结果.图5(a)是参数Δt和查询结果精度的关系.如图所示,随着Δt的不断增大,区间划分也不断增大,此时查询精度逐渐下降.Δt=1时,即每个区间至多只存在一个数据,查询精度为100%,不存在任何假阳性数据.Δt=20时,查询精度为99.21%.Δt=80时,查询精度下降比较明显,为94.13%.图5(b)是传感器节点和存储节点的总传输能dln-dl1Δlt+ndln-dl1Δlt+ndln-dl1Δlt+n耗和参数Δt的关系.根据6.3节数学模型中的分析,随着Δt的增大,区间划分变大,编码信息量减少,因此传感器节点的传输能耗会不断减少.但随着区间划分增大,存储节点传输的查询结果中包含的假阳性数据会逐渐增多,因此传输能耗增大.图5(b)中反映的是两者的总能耗.在参数Δt实验的基础上,在接下来的VQuery协议实现的过程中,采用了使总能耗最小的Δt值,并根据该值划分区间,将节点所采集的数据分配致相应的区间,然后根据5.1节的方法构建一棵完全多维区间树(CMDRT),并利用构造的隐私保护函数对每个区间的起始值与终止值进行编码,并按4.2.1节的方法为每个区间内的数据生成和嵌入水印(每个区间的水印位为29bit).在实验中,我们选用DES作为加密算法,每个密文块的大小为64bit,每个周期的大小设为10min~80min,在一个周期内让Sink随机地产生1000个范围查询.SafeQ与S&Lscheme的实现我们分别参考了文献[11]和文献[8].实验结果表明本文所提出的VQuery协议在通信能量开销与存储空间开销方面均优于SafeQ-bloom、SafeQ-basic与S&Lscheme.采用方案1得到的详细数据如下:(1)存储节点的存储空间开销.一维数据的测试情况表明,存储节点在VQuery协议中存储空间开销比SafeQ-bloom协议小5.84倍,比Safe-basic小12.23倍,比S&Lscheme小5.71倍;二维数据的测试表明,存储节点在VQuery协议中的存储空间开销比SafeQ-bloom协议小3.43倍,比Safe-basicPage13小11.50倍,比S&Lscheme小45.14倍;三维数据的测试表明,存储节点在VQuery协议中的存储空间开销比SafeQ-bloom协议小2.90倍,比Safe-basic小9.96倍,比S&Lscheme小656.12倍.(2)传感器的通信能量.一维数据的测试情况表明,传感器在VQuery协议中通信能量开销比SafeQ-bloom协议小5.72倍,比Safe-basic小12.1倍,比S&Lscheme小5.71倍;二维数据的测试表明,传感器在VQuery协议中通信能量开销比SafeQ-bloom协议小3.39倍,比Safe-basic小11.44倍,比S&Lscheme小45.06倍;三维数据的测试表明,传感器在VQuery协议中通信能量开销比SafeQ-bloom协议小2.83倍,比Safe-basic小9.81倍,比S&Lscheme小657.25倍.(3)存储节点提交查询结果的通信能量开销.一维数据的测试情况表明,存储节点在VQuery协议中提交查询结果时的通信能量开销比SafeQ-bloom协议小2.86倍,比Safe-basic小9.33倍,比S&Lscheme小4.06倍;二维数据的测试表明,存储节点在VQuery协议中提交查询结果时的通信能量开销比SafeQ-bloom协议小2.43倍,比Safe-basic小7.89倍,比S&Lscheme小21.53倍;三维数据的测试表明,存储节点在VQuery协议中提交查询结果时的通信能量开销比SafeQ-bloom协议小2.93倍,比Safe-basic小7.54倍,比S&Lscheme小192.55倍.采用方案2得到的详细数据如下:(1)存储节点的存储空间开销.一维数据的测试情况表明,存储节点在VQuery协议中存储空间开销比SafeQ-bloom协议小4.38倍,比Safe-basic小16.59倍,比S&Lscheme小7.36倍;二维数据的测试表明,存储节点在VQuery协议中的存储空间开销比SafeQ-bloom协议小4.16倍,比Safe-basic小15.95倍,比S&Lscheme小68.88倍;三维数据图6一个传感器在数据提交阶段的平均通信能量开销(方案1)的测试表明,存储节点在VQuery协议中的存储空间开销比SafeQ-bloom协议小3.64倍,比Safe-basic小12.85倍,比S&Lscheme小691.323倍.(2)传感器的通信能量.一维数据的测试情况表明,传感器在VQuery协议中通信能量开销比SafeQ-bloom协议小2.39倍,比Safe-basic小11.25倍,比S&Lscheme小1.46倍;二维数据的测试表明,传感器在VQuery协议中通信能量开销比SafeQ-bloom协议小1.47倍,比Safe-basic小8.06倍,比S&Lscheme小47.66倍;三维数据的测试表明,传感器在VQuery协议中通信能量开销比SafeQ-bloom协议小2.24倍,比Safe-basic小13.35倍,比S&Lscheme小796.28倍.(3)存储节点提交查询结果的通信能量开销.一维数据的测试情况表明,存储节点在VQuery协议中提交查询结果时的通信能量开销比SafeQ-bloom协议小3.63倍,比Safe-basic小9.41倍,比S&Lscheme小4.98倍;二维数据的测试表明,存储节点在VQuery协议中提交查询结果时的通信能量开销比SafeQ-bloom协议小3.09倍,比Safe-basic小6.73倍,比S&Lscheme小31.25倍;三维数据的测试表明,存储节点在VQuery协议中提交查询结果时的通信能量开销比SafeQ-bloom协议小3.94倍,比Safe-basic小4.21倍,比S&Lscheme小236.79倍.图6~图8是在方案1下得到的实验结果;图9~图11是在方案2下得到的实验结果.图6(a)、图7(a)、图9(a)、图10(a)分别描绘了VQuery、SafeQ-bloom、SafeQ-basic与S&L4个协议在一维测试数据集的情况下,一个传感器与存储节点在不同长度的周期内的平均通信能耗情况;类似地,图6(b)、图7(b)、图9(b)、图10(b)则描述的是二维测试数据集的情况下一个传感器与存储节点平均通信能耗情况,图6(c)、图7(c)、图9(c)、图10(c)则Page14图7一个存储节点在回复查询结果时的平均通信能量开销(方案1)图8一个存储节点的平均存储空间开销(方案1)图9一个传感器在数据提交阶段的平均通信能量开销(方案2)图10一个存储节点在回复查询结果时的平均通信能量开销(方案2)图11一个存储节点的平均存储空间开销(方案2)Page15描述的是三维测试数据集的情况下,一个传感器与存储节点平均通信能耗情况.图8(a)~(c)和图11(a)~(c)分别描绘了在方案1和方案2下VQuery、SafeQ-bloom、SafeQ-basic与S&L4个协议中存储节点在一、二、三维测试数据集情况下的存储空间开销(注:图6(c),图7(c),8(b),图8(c),图9(c),图10(c),图11(b),图11(c)的纵坐标采用的是对数坐标).本文提出的方案在进行数据完整性认证方面采用区间信息与水印技术相结合的办法,水印嵌入不需要增加额外的空间,提出的MDRT树在空区间合并上具有很高的效率,能有效地减少区间的个数,从而降低了验证信息量,实验结果也体现了这一方案的有效性.8结束语本文提出了一种针对两层结构传感器网络的隐私与完整性保护的范围查询协议:VQuery,该协议能让存储节点正确地处理查询的同时也能有效地保护数据的隐私性与查询结果的完整性.为了实现保护数据的隐私性,提出了一种基于多项式技术的隐私保护方案,对区间信息与查询条件进行编码,能使存储节点在不知道查询条件与待查询数据真实值的情况下正确执行查询处理.为了保护数据的完整性,提出了一种基于水印链技术的完整性保护方案,该方案通过在数据中嵌入水印信息后使数据形成一条或多条链,因此能有效地验证一维或多维查询结果的完整性.为了实现多维数据的隐私与完整性保护的范围查询,提出了一种多维区间树的数据结构,该结构能有效地表示多维数据.为了验证VQuery协议的有效性,本文利用IntelLab提供的真实数据对协议进行测试,实验结果表明在一维和多维情况,VQuery都比SafeQ-basic、SafeQ-bloom和S&L具有更低的通信能量与存储空间开销.
