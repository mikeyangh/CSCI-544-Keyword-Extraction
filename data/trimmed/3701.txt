Page1覆盖表生成的遗传算法配置参数优化梁亚澜聂长海(南京大学计算机软件新技术国家重点实验室南京210093)摘要覆盖表生成是组合测试的关键问题,很多数学方法、贪心算法以及演化搜索方法等被应用于生成各种覆盖表.针对演化搜索方法的性能受到方法本身配置参数影响很大这一实际问题,文中以二维覆盖表生成为实例,系统地对典型的演化搜索方法———遗传算法的种群规模、进化代数、交叉概率、变异概率以及遗传算法的变种算法等因素进行探索,设计了pair-wise法、Basechoice法和爬山法3条实验路线探索遗传算法的这些配置参数及其相互作用对算法生成二维覆盖表效果的影响,并回答两个问题:对于特定二维覆盖表生成问题,是否存在遗传算法的最优参数配置;对于一般的二维覆盖表生成问题,是否存在通用的遗传算法最优参数配置.关键词二维覆盖表;遗传算法;配置参数优化;组合测试;测试用例生成1引言果受到软件自身及外部许多因素的影响.如何以尽可能小的代价检测出软件系统中各种因素及其相互作用所引发的各类故障是一个非常重要的问题.软件作为一个复杂的逻辑体,其最终的运行效组合测试方法通过生成少量测试用例[1],以较Page2小代价最大限度地对软件系统各因素间的相互作用关系进行覆盖,可以有效检测系统中各种因素相互作用所触发的软件故障.根据Kuhn等人[2]的研究发现,测试二维交互关系能够找出70%的错误,因此全盘考虑测试的成本、覆盖表的生成难度以及各种组合覆盖程度对覆盖表规模的影响等因素.两两组合测试是人们最常使用的方法[1].目前国内外对于二维覆盖表生成方法的研究已有不少成果,人们提出了很多数学方法[3]、贪心算法[4-6]以及演化搜索算法[7-8]等.遗传算法是一种典型的演化搜索方法,该方法被广泛地应用于解决复杂的优化问题.人们也已将其应用于覆盖表生成[9-11],但现有的文献未能考虑到演化搜索方法的性能受到方法本身配置参数影响很大这一实际问题.本文针对该问题,以二维覆盖表生成为实例,系统地探索遗传算法各配置参数及其相互作用对算法性能的影响.本文重点关注于遗传算法生成覆盖表的效果与遗传算法本身配置参数变化的关系,从而更好地发掘遗传算法生成覆盖表的潜力.我们通过实验对遗传算法的种群规模、进化机制、交叉概率、变异概率及其变种算法这5个因素进行取值组合,设计了pair-wise法、Basechoice法[12-13]和爬山法3条不同的实验路线,系统地探索遗传算法的5个因素及其相互作用对遗传算法覆盖表生成效果的影响程度和影响性质,并以生成覆盖表规模和消耗时间为分析依据寻找出最佳配置,为今后进一步研究覆盖表生成的遗传算法打下理论和实践基础.本文第2节介绍相关研究,并指出存在的问题;第3节给出覆盖表的定义及相关概念;第4节对遗传算法4个参数配置及其变种算法的概念进行简要介绍;第5节是具体的实验设计;第6节分析实验数据并得出结论;第7节是总结和展望.2相关工作及存在的问题Ghazi等人[9]在2003年最先将遗传算法应用于覆盖表生成,他们通过实验得出在参数个数为4,每个参数取值个数都为3的待测系统中,利用遗传算法可以得到包含11条测试用例的二维覆盖表.文章只表明使用遗传算法生成覆盖表的可行性,实验只用了一个例子,实验设计过于简单且没有进行深入的研究.Shiba等人[10]在2005年介绍覆盖表生成的人工智能技术的文章中,对遗传算法如何确定染色体结构、适应度函数、选择交叉变异策略等进行了讨论,并对其中一组配置进行了实验,文章中并没有对遗传算法生成覆盖表的性能进行分析.McCaffrey[11]在2010年提出遗传算法生成覆盖表的性能会受到其自身配置参数的影响,并提取出种群规模、染色体结构、进化选择策略等因素进行了讨论.但是McCaffrey只通过实验验证了在其中一种参数配置下,遗传算法生成覆盖表的效果比较理想,并没有系统地探索遗传算法自身的这些因素及其相互作用对算法性能的影响特点和影响程度.针对已有工作未能系统探索遗传算法生成覆盖表的性能,本文对遗传算法的配置参数进行了更为深入的探索,重点关注种群规模、进化代数、交叉概率、变异概率及遗传算法的变种算法这5个重要配置参数及其相互关系对遗传算法生成覆盖表性能的影响程度和影响性质,通过科学的实验设计,对这5个配置参数的取值组合进行优化以找出覆盖表生成遗传算法的最优参数配置,从而进一步发掘遗传算法在覆盖表生成方面的潜力.3覆盖表软件质量受到其自身及外部许多因素的影响,针对这一实际问题,要求一个完备的检测方法必须能够检测出这些因素及其相互作用关系所引发的各类故障.覆盖表,特别是二维覆盖表可以用最少的测试代价,系统地覆盖待测试系统中的各种参数组合.以下我们先给出测试用例的定义,再通过一个例子介绍什么是覆盖表,然后给出覆盖表的一般定义.定义1.设待测系统SUT有n个参数,每个参数有vi(1in)个取值,形成集合Vi.n元组〈a1,a2,…,an〉称为SUT的一个测试用例(ai∈Vi).如表1所示,一个待测系统SUT存在4个可能影响其性能的参数分别为C1、C2、C3、C4.每个参数各有3个不同的取值{0、1、2}.如果以穷举法对4个参数的所有取值组合进行检测,我们需要34=81个测试用例才可以检测出各因素相互之间的关系所引发的故障,测试代价相对较大.这个缺点在系统因素及其相互作用更复杂的待测软件中更为明显.而且测试数据表明,并不是所有参数取值之间都存在相互作用,因此穷举法会产生大量冗余的测试用例.Page3C1012组合测试方法所生成的测试用例集———覆盖表[1],通过对软件系统各因素间的相互作用关系进行有选择的针对性覆盖,大大减少了冗余的测试用例,同时在保证测试效果的前提下有效地缩减了测试用例集的规模.在表1的例子中,如需要覆盖任意两个参数间的相互关系,则只需要表2中的9条测试用例,从该表中可以检查它覆盖了任意两个参数之间的9个组合,在实际检测中可以检测出SUT中所有因为两两参数之间的相互作用而引发的软件故障.C1012210210覆盖表作为组合测试的测试用例集,其定义如下.定义2.假设影响一个待测系统的参数共n个,每个参数有v种可能取值.则覆盖表CA(N;t,n,v)是一个N×n的数组,每行对应着一条测试用例,每列对应一个参数的所有取值.任意t个参数形成的子数组N×t覆盖了该t个参数所有取值的组合,即每个t元组至少出现1次.其中t为组合覆盖测试的强度,本文中提到的两两组合测试指的是t=2的情况,生成的即为二维覆盖表[1].在真实的软件系统中,影响系统的参数取值数目可能不尽相同.于是人们将覆盖表扩展,形成了混合覆盖表MCA(N;t,n,(v1,v2,…,vn)).表中第i列对应第i个参数,该参数取值数目记为vi,任意t个参数形成的N×t的子数组中包含了该t个参数的所有t元组.当v1=v2=…=vn=v时,MCA(N;t,n,(v1,v2,…,vn))即为CA(N;t,n,v)[1].覆盖表的生成是组合测试的关键环节,目前国内外对组合测试的很多研究主要集中在该领域.除了数学方法[3]、启发式贪心算法[4-6]等,演化搜索算法是其中一类重要的方法,这一类方法利用模拟退火[7]、遗传算法[9-11]、蚁群算法和粒子群算法等演化计算技术生成覆盖表,是已有贪心算法和数学方法的重要补充,具有很强的灵活性和有效性,但其性能受其自身配置参数影响很大,本文针对这一实际问题,以遗传算法这一典型的演化搜索算法为研究对象,系统地探索算法中各配置参数对算法生成覆盖表的最终效果的影响性质和影响程度.4覆盖表生成的遗传算法遗传算法[9-11,14]是一种通过模拟自然世界生物进化过程探索问题最优解的演化搜索算法,已被广泛地用于复杂的优化问题.在遗传算法中,问题的一组候选解以染色体的形式构成算法的初始种群,算法对每一代种群中的染色体进行交叉变异,然后通过适应度函数值这一评价标准淘汰适应值较差的染色体,保留适应值较好染色体进入下一代,直到某一代种群中出现适应值满足问题要求的染色体,该染色体即为问题的最优解.在本文中,我们采用待测系统SUT中参数C1,C2,…,Cn的一个取值组合〈a1,a2,…,an〉作为染色体,即候选测试用例,以逐条生成测试用例的方式构造二维覆盖表.算法流程图如图1所示,其具体步骤如下:1.初始化测试用例集TG(TG可设空集,也可放入所需的初始用例);初始化待测系统SUT中需要被覆盖的二元组集合S;随机生成初始的种群,种群规模为m;初始化进化代数T;初始化种群个体的适应值数组fitness.2.计算种群中各染色体的适应度函数值,适应值即为该染色体所包含的未被TG覆盖的二元组合对个数.3.对种群中的染色体进行选择、交叉(交叉概率为Pc)、变异(变异概率为Pm)以产生新的种群.对新种群中的个体进行适应值评价,若新的种群中存在最优染色体c,则将其作为覆盖表中的一条新的用例,跳至步5;否则重复该步过程,直到迭代次数达到T.4.在当前种群中选择适应值最高的染色体c,作为覆盖表中的一条新的用例.5.将c加入TG中,并从S中删去c所包含的二元组合对,若S为空集,即当前TG中的用例包含了所有二元组合对,则算法结束,TG即为所求覆盖表;否则,跳至步3.由于遗传算法的效果受其自身配置参数的影响,为了进一步提高算法生成覆盖表的性能,以下我们从中提取出种群规模m、进化代数T、交叉概率Pc、变异概率Pm以及遗传算法变种算法这5个对其性能影响较大的重要因素进行进一步讨论.Page4图1覆盖表生成的遗传算法流程图4.1种群规模犿遗传算法中种群是由一定数量的染色体组成,种群中染色体的数量称为种群规模m.通常种群规模太小则不能提供足够的采样点,造成算法过早收敛;种群太大虽然可以增加优化信息,阻止早熟收敛的发生,但无疑会增加计算量,造成收敛时间太长.为了准确找到最合适的种群规模取值,在正式实验前,我们对不同种群规模下遗传算法生成覆盖表的性能进行了初步的测试工作,结果显示:种群规模在6000以上时,算法生成覆盖表的规模下降程度不明显,算法速度却大大降低;种群规模在100以下时,算法生成覆盖表的规模有增加趋势且性能很不稳定.综合考虑实验的准确度和复杂度等因素,本文种群规模m的取值集合为{100,2100,4100,6100},该取值集合既保证实验能够击中最合适的种群规模取值,又保证实验复杂度在可操作范围内.4.2进化代数犜通过进化代数T限定算法每轮的迭代次数,迭代次数达到进化代数T则算法终止.与种群规模取值相似,终止进化代数过小,则生成的解无法接近最优解,过大,则运行消耗代价过大.因此,在实际问题解决时,需要权衡各方面因素,力图找到一个平衡点.在正式实验前,根据对不同进化代数取值下遗传算法生成覆盖表性能的初步测试我们发现:进化代数在100以下时,算法生成覆盖表的规模有增大趋势;进化代数在1000以上时,算法生成覆盖表的规模没有明显减小趋势且算法的速度大大降低.综合考虑实验的准确度和复杂度等因素,本文T的取值集合为{100,600,1100}.4.3交叉概率犘犮对种群中的染色体进行交叉操作以产生新的染色体,实质上是对问题解空间的广度搜索.交叉概率太大,则种群中个体更新很快,容易破坏已有的高适应值的个体;概率太小,则交叉操作很少进行,会使搜索停滞不前,造成算法的不收敛.通过测试工作,我们发现交叉概率Pc对遗传算法性能的影响没有明显的趋向性,为了保证实验结果的准确,对其采取在合法取值空间中均匀取值的方法,Pc的取值集合为{1,0.8,0.6,0.4,0.2}.4.4变异概率犘犿变异操作是对种群模式的扰动,有利于增加种群的多样性,实质上是对问题解空间的深度搜索.同样,变异概率太小则很难产生新模式;变异概率太大则会使遗传算法成为随机搜索算法,失去遗传算法的特性和优点.与交叉概率Pc相同,变异概率Pm对算法性能的影响也没有明显的趋向性,为了保证能够击中最合适的Pm取值,本文Pm的取值集合为{1,0.8,0.6,0.4,0.2}.4.5遗传算法的变种算法本文在对传统遗传算法4个配置参数进行探索的同时,对遗传算法进行一定程度的改动,以发掘遗Page5传算法生成覆盖表的潜力.本文所探索的算法分别为:GA:即遗传算法.GA采用逐条生成测试用例的方法;在种群进化过程中,父代的最优个体c直接进入子代,其余染色体的选择策略select为轮盘赌选择法;适应值f为该条染色体所包含的未被覆盖对个数;交叉策略为多点交叉;变异策略是单点变异.GA-:在种群进化过程中,GA-将GA中适应值f改为该条染色体所包含的已被覆盖对的个数,使GA的优胜劣汰制变为优汰劣胜制(注:优汰劣胜仅为种群进化中select的标准,而个体进入覆盖表的标准仍是选取包含未被覆盖对个数最多的个体).GAr:在种群进化过程中,GAr将GA染色体选择策略select改为随机选择,即父代中的个体随机选择进入子代.GAclimb:在GA的基础上采用爬山法对每一代种群中最优个体进行处理:GAclimb算法中每一代的最优个体c只可能被当前适应值更高的个体替换,否则直接进入下一代而不参加其它操作.算法保证了最优个体的优良特性能够在不被交叉变异破坏的基础上得到不断优化.群中最优个体的处理,处理过程同GAclimb.群中最优个体的处理,处理过程同GAclimb.5实验设计GA-climb:在GA-的基础上改变对每一代种GArclimb:在GAr的基础上改变对每一代种实验表明,覆盖表生成的遗传算法的效果会受到其自身5个因素(配置参数)的影响.如何确定相应的配置参数取值以求算法达到最好效果,即如何对有序集〈算法,种群规模,进化次数,交叉概率,变异概率〉进行取值,这是本文需要解决的问题.本文通过对形如〈GA-,2100,600,0.21,0.41〉的不同参数配置下的遗传算法的性能进行测试和比较,主要回答以下问题:(1)遗传算法这5个因素对于算法的性能的影响程度和性质如何.(2)是否存在一组最优参数配置,使得二维覆盖表的遗传算法对于某个特定问题,总是能发挥较优的性能.(3)该组最优参数配置是否具有通用性,即对于其它覆盖表生成问题也能产生近优解.本文对不同参数配置下遗传算法生成覆盖表性能的评判标准为:首先考虑算法生成覆盖表规模,生成覆盖表规模最小的为最优参数配置;若不同参数配置下生成覆盖表规模相同,则选取生成覆盖表过程消耗时间最少的为最优参数配置.遗传算法5个配置参数在相应取值范围内产生的值组合(即参数配置)规模十分庞大,在表3中的参数取值情况下,共产生6×4×3×5×5=1800种不同的参数配置,利用每一种配置对应的遗传算法进行覆盖表生成并选优是不可行的.算法种群规模进化代数交叉概率变异概率GA10010011GA-21006000.80.8GAr410011000.60.6GAclimb6100GA-climbGArclimb为了更高效地解决问题,本实验采用3条实验路线对最优参数配置进行搜索,利用3个不同的参数配置集,在确保击中最优参数配置的前提下大大减少了所需测试的配置个数(为了在配置集中方便记录各参数的取值,本文将其对应为有序的自然数,如表3中“种群规模”中有4个不同取值,我们将其与0,1,2,3这4个自然数相对应):(1)pair-wise参数配置集假设表3中各参数两两之间存在相互作用,我们对其进行二维组合覆盖,生成的二维覆盖表作为pair-wise配置集.为了概率更高地包含较优配置,本文没有采用规模最小的覆盖表,而是加入了适量冗余.如表4所示,该覆盖表共有34组不同的参数配置,这34条参数配置覆盖了所有参数之间的二维组合.比较该组参数配置集下遗传算法的待测实例覆盖表生成效果,从中得到最优参数配置Px(1x34).测试号a1a2a3a4a5P153101P241203P322044P430110P500021P651030P732232P813013P903240P1011142P1143124P1220133P1350214P1440002P1512220P1602111P1721211Page6(2)Basechoice参数配置集Basechoice是一种组合设计方法[12-13].该方法先选取一个参数配置作为基准参数配置B(在本实验中该基准配置B即为pair-wise法所得最优参数配置Px),在此基础上改变其中某一个因素的取值并保持其余因素取值不变,从而产生一组参数配置集.采用上述方法对遗传算法所有因素取值进行覆盖,得到的参数配置集即为Basechoice参数配置集.例如表5是以表4中的P13为基准参数配置所对应的Basechoice配置集.测试号a1a2a3a4a5测试号a1a2a3a4a5B150214B1150114B200214B1250204B310214B1350224B420214B1450234B530214B1550244B640214B1650210B751214B1750211B852214B1850212B953214B1950213B1050014(3)爬山法参数配置集爬山法首先选取一个参数配置作为基准参数配置C0,例如假设C0为〈5,0,2,1,4〉(在本实验中该基准配置C0即为pair-wise法所得最优参数配置Px),从遗传算法第1个配置参数变种算法开始,依次改变其在C0中的取值并保持其余参数取值不变,从而产生6个参数配置集.比较该组参数配置下遗传算法的覆盖表生成效果,选取生成效果最好的参数配置C1作为新的选定配置,例如变种算法取值为2时效果最好,则C1=〈2,0,2,1,4〉.然后在C1的基础上改变遗传算法第2个配置参数种群规模的取值,得到4个参数配置集并产生C2,例如种群规模取值为1时生成效果最好,则C2=〈2,1,2,1,4〉.依此类推,直到改变第5个配置参数的取值得到C5,C5即为爬山法所得的最优参数配置.上述过程说明爬山法参数配置集是在实验中一步步动态生成的.为满足实验需求,我们设计了可配置的覆盖表生成的遗传算法工具COGA(ConfigurableandOp-timizedGeneticAlgorithm).COGA可自动以上文所描述的pair-wise法、Basechoice法和爬山法这3条实验路线对遗传算法的5个因素进行取值集合空间的搜索和取值组合的优化,得到待测实例的覆盖表生成的最优参数配置.其输入为:(1)待测实例描述,如313(13个参数,每个参数都有3个取值);(2)遗传算法5个配置参数各自的参数取值集合.输出为:(1)运行3条实验路线过程中覆盖表的生成规模和消耗时间等数据记录;(2)能为待测实例生成最优覆盖表的遗传算法配置.6实验结果及分析根据实验设计我们对不同规模的待测实例进行覆盖表生成,得到各待测实例在不同配置集下遗传算法生成的覆盖表规模和消耗时间.考虑到每一个待测实例的参数配置优化过程都需要对34+23+23=80个不同参数配置下的待测实例进行覆盖表生成实验,且为了保证数据的准确性,本文对Basechoice配置集和爬山配置集中的每一个配置都进行5次实验并取最优解为生成结果,消耗时间较多,所以只选取15个具有代表性的待测实例进行实验(在24GB内存,4核CPU(Intel(R)Xeon(R)E7450,主频2.40GHz)的刀片机远程终端上运行,实验周期为1个月),其中待测实例的选取兼顾下列几点:(1)选取410、313和64等较为常见的待测实例.(2)有选择地加入覆盖表生成规模和消耗时间相差较大的待测实例,以增加实验用例选择空间的广度.(3)包含参数取值不一致的待测实例,以保证实验结论更加准确可靠.下面我们分别对3个配置集下的实验数据进行整理分析.6.1pair-wise实验实验所得覆盖表的生成规模和消耗时间分别如表6、表7所示,表中第1列列出pair-wise配置集中34个不同配置{P1,P2,…,P34};第1行是各个待测实例,例如410表示该待测实例有10个参数,每个参数取值个数均为4;766756表示该待测实例有19个参数,其中6个参数有7个取值,7个参数有6个取值,还有6个参数有5个取值.通过不同配置下的覆盖表生成结果对比可以发现,利用遗传算法生成覆盖表的最终效果受算法自身配置参数的影响很大,例如在实例620中,不同参数配置下的覆盖表生成规模最多时相差42个,差距十分明显.综合覆盖表的生成规模和消耗时间这两个标准,我们得到pair-wise配置集中各待测实例的最优参数配置Px并在表中用加粗标记.Page7表6pair-wise配置集生成覆盖表的规模覆盖表规模410313610420810320620430630101176675682726252615146382364513822P1301962391062387461061739271394523P2302061371062284451021678973394421P331207044125241015312120710380414222P43119664111624965011319010076394320P536217949151281206013924512195454525P6301964421132393481121849675394421P7311960381042186451041709174404422P832197144124241025212120510579404522P931207044125241015212220510478444325P1032207245128251055412621410881424422P1130196237102227941961628574404324P1237238251148271216114124612692474725P1330186435100237742901578275394521P143120704312024995111819810077394523P1532207244125231015212320710779424423P1630207044124241005312220410679414221P1732197245130251055512421311081414324P18301960381032284451011679075414323P1933206943123251015312120510479404523P20291960371022284441031658774374223P2131207044126241025212120810580424322P22301963391072290481091789375384522P2337228649150281195814025012294444724P24291962391052288471071749374384222P2531206844122241005112020210280424322P2631217144127241025212220610579424422P2728195937101218244991628674394422P28311962401112286481051729172404423P29291964421122493501141889877394322P30292164411092291471091789373394321P3138238252153281206014225212295484826P3232217144123241005212120510480414424P33302063381052286471051739173394223P34301961401112288471061748975404422表7pair-wise配置集生成覆盖表消耗时间消耗时间/s410313610420810320620430630101176675682726252615146382364513822P1124.7126.9255.11576.346395.384343.171303.921836.194256.82785.9183756218.421224.0538.657151.883P2196.3159.4388.58431.14682.645251.431014.19965.3652247.351147.472533796.65876.616139.028201.132P312.312.4527.28559.71745.84934.663139.309206.733479.15789.622460.436.036140.6352.91712.636P41.961.7164.4777.1137.4724.0417.19116.94239.35913.71318.894.2447.020.8111.825P50.4060.3280.9361.4671.7320.8273.6973.4478.1753.2133.930.8111.3580.140.344P66.5985.92813.96227.84622.88515.55463.75874.584171.83544.024186.817.11358.7812.0916.131P7696.1485.61327.91341.42192.5716.633033.812817.996692.293760.3165691884.061808.05575.207703.798P8146.197.53322.81292.798548.734163.957692.926558.9831311.05949.9841231675.906307.042124.91145.128P9148911233422.263282.936018.411818.747675.656090.1914289.410288.7132787073.293733.321218.491799.47P10121.488.69266.72305.04465.10170.07713.938657.9341525.18840.7051699539.062350.222119.232118.296P11801.1563.41586.31462.62565.8852.283087.672516.316030.954446.8657703602.511762.69734.421927.551P122.1371.8564.8528.2688.34.25920.04719.54746.2717.33221.926.8647.0980.6872.199P132.8552.436.2089.5798.935.9922.423.2653.41417.7723.458.25310.0461.1543.261P140.3430.3120.8271.2951.3420.7183.0422.9956.9272.7143.341.4661.0770.2340.608P15695.6511.71564.61604.02714.6800.393662.593314.437847.89516.4270053282.451834.4652.615740.755P16370.7281.5819.29881.271491.9480.3591993.181850.174284.35367.0435261768.58982.853230.741366.743P1779.6168.48178.12340.50303.51178.309802.344927.0362177.241590.61714285.169369.08321.99688.094P1818.1713.3835.52240.76359.20222.18389.76387.719198.823223.908180.977.67357.34614.60219.687P19140.7133.1278.42671.83465.35384.951505.132115.124855.74060.783386532.322815.68245.302150.432P20136.6133.0268.63578.47426.79338.011307.881914.074636.332481.773510519.515620.9537.846156.952P2184.39680.48182.52396.96308.69220.68904.7431219.82986.442316.972333336.588501.04421.20186.394P22136.493.88273.09266.43463.05147.88607.062515.3651184.251263.51951578.545293.594134.925147.421P230.3750.3280.921.3891.5130.783.3393.0897.7073.0893.590.7491.1240.0940.483P24338.9257.0721.11774.651197.3421.401712.391671.073744.483971.433159939.906906.459284.624417.49P25116.585.50246.84292.05437.94149.59665.375587.7811403.491406.241265301.191346.97795.909127.531P26118.292.22264.41299.68464.32158.80693.456604.1921503.991471.951303305.512343.109125.409133.911P273.092.9956.9311.2311.316.0226.14626.72361.96322.77628.16.28711.3881.8724.82P28849.1557.51618.71628.92895.02884.353437.123066.036772.357634.6655552023.261846.54838.849966.489P2957.7742.63124.94134.85213.5477.064292.767281.145664.408620.151651.9165.283153.25553.49266.347P3020.1222.6842.55710768.31358.329223.83309.459732.799357.086648.448.298133.3196.58424.305P314.793.96310.60917.17618.869.07940.20138.15891.05838.15844.19.01714.7421.7945.476P32382.9291.2850.99882.161454.7466.211954.011816.524260.864007.9233781066.63991.37355.323446.693P331496.1094.3023.12786.14958.51579.96372.315476.7412436.21217099213844.53310.331256.711701.78P34816.2562.91621.61632.32932.8870.303540.492962.766801.136821.8354632147.671859.83834.793866.039Page8表中数据显示,所有待测实例除了64,其余最优参数配置均选择climb算法,由此得出初步结论:利用遗传算法生成覆盖表时,算法选择以climb算法为优.Pair-wise实验对有限的34个不同参数配置下的待测实例进行覆盖表生成,可以得出不同的参数配置对覆盖表生成效果影响很大这一结论.而这些影响具体是由哪一组参数的两两组合所引起,需进行更有针对性的实验才能确定.目前对于如何确定参数两两交互作用对算法性能的影响这一问题,仅有Bryce等[6]基于贪心算法6个决策点的两两交互作用的相关研究,其实验过程和文章篇幅都较长.所以要验证本文中遗传算法的参数交互作用,需以Bryce的实验设计为参考,另文详细讨论.Pair-wise实验主要考虑了遗传算法各配置参数之间的二维组合关系对算法效果的影响,并从中得到各待测实例的覆盖表生成的最优参数配置Px,但实验没有对遗传算法的5个配置参数进行单独地深入探索,因此无法准确评价这5个配置参数各自对算法效果的影响性质和影响程度,这在很大程度上影响了实验结论的完备性.为了解决这一问题,我们在pair-wise实验的基础上设计了Basechoice实表8Basechoice/爬山实验中选择不同算法时覆盖表的生成规模覆盖表规模算法410313610420810320620430630101176675682726252615146382364513822033#19#76#44#126#26#104#48#126#212#107#7838#4424136228150147271155213924912177404524235218249147271165213624512176#4142#24#32819593699217441891548274384220428196035100217741901608370374320528176135100217741901578271364220表9Basechoice/爬山实验中选择不同算法时覆盖表的消耗时间消耗时间/s算法41031361042081032062043063010117667568272625261514638236451382203.9#2.9#9.19#13.2#13.76#7.94#32.18#2995#76.3#27#32.7#22251588.6#56.12.9314.243.509.6815.0916.198.2235.21332282.4633.2037.4722041698.854.72.1823.682.98.8313.7914.157.8333.38196579.228.7434.88225.3#869.12.9#1.69#33.092.86.9310.4210.256.0222.93254753.319.825.0221411619.844.91.8343.142.77.0110.1610.395.6723.29251654.8719.9725.1120341562.245.41.9352.92.36.489.588.935.7922.4152452.8717.823.5218.42627.72.71.78例)相比A中覆盖表最小生成规模(126个测试用为了准确分析表中的数据,本文用“”标记出例)仍少36个测试用例,且消耗时间也少于A,这表各待测实例的覆盖表生成的最优算法选择,并将算明,对遗传算法的种群最优个体进行爬山优化能够法进行如下划分:A={GA,GA-,GAr};B={GA在加快算法收敛速度的同时有效提高算法的性能.climb,GA-climb,GArclimb}.通过比较A,B集通过进一步的分析,我们发现在A集合中GA的性合的数据可以发现表8和表9中“”都集中于B集能总体优于GA-和GAr,但在B中这种性能上的差合,即无论是覆盖表的生成规模还是消耗时间,B集距却基本消失,这表明选择机制的不同对算法性能合中算法的整体性能明显优于A集合.以待测实例1011为例,B中覆盖表最大生成规模(90个测试用也有影响(优胜劣汰的轮盘赌选择机制要优于优汰验.Basechoice实验以pair-wise实验所得的配置Px为基准参数配置,通过改变Px中的某一个参数取值得到参数配置集并进行实验,更注重于发掘各配置参数自身对算法效果的影响.6.2Basechoice实验实验以pair-wise法所得的最优参数配置Px作为基准参数配置.由于在pair-wise实验中得到的不同待测实例的覆盖表生成的最优参数配置不一致(如表6、表7所示),相应的Basechoice实验配置集也不相同.考虑到演化搜索算法的不确定性,本文对每一个配置都进行了5次测试并取最优解为生成结果.下面我们分别探索各个集合中每个配置参数对遗传算法生成覆盖表效果的影响性质和影响程度,找出该配置参数的最优取值.6.2.1遗传算法的变种算法本文中遗传算法共有6个不同的变种算法,即每个待测实例对应6个不同的参数配置.这6个配置下各覆盖表生成规模和消耗时间如表8、表9所示(5次测试取最优结果),由于基准参数配置Px不一致,本文以算法选择为标准对生成结果进行统一排序,其中Px用加粗标记.Page9劣胜的轮盘赌选择机制和随机选择机制),但这种影响会在种群最优个体的爬山优化过程中被削弱.6.2.2种群规模本文中种群规模的参数取值集合为{100,2100,4100,6100},对应4个不同的参数配置,这4表10Basechoice实验中选择不同种群规模时覆盖表的生成规模种群规模1002818593510021774190157827539462021002919593610022774291159857239422141002818593599217741911598373374221610029185935100227741911578371384321表11Basechoice实验中选择不同种群规模时覆盖表的消耗时间种群规模1003.092.436.939.588.946.0222.413.05317.823.53.2110.7330.051.832100195.158.52381.1240.8197.4249.2544.1476.11451631114693.5307.21.1113.84100622.5118.31239506.4391696.31177.1371392816573133231620.952.92361.561001363191.72842861.4599.71503200225166354340849142181079.35.16799.6表10、表11中数据显示“”大多集中在第一行,即种群规模取值为100时算法性能最优.通过进一步比较我们发现,种群规模取值不同时同一待测实例的覆盖表生成规模相互之间差距并不大,但消耗时间会随着种群规模的增加而明显增加.如待测实例620中4个配置下的覆盖表生成规模均为77,消耗时间的差距最大时却达到100倍之多.这表明,在本实验中种群规模对算法的影响主要体现在时间上,即种群规模的增加会增加时间负担,但不会为算法性能的提升提供较大帮助.不过除了待测实例64,上述4个配表10Basechoice验证实验中选择不同种群规模时覆盖表的生成规模种群规模10033197644126261045312621210793434624210030196741114239449115189977939422241002919674111223934911318596793842226100301865411112493481121839576384322表11Basechoice验证实验中选择不同种群规模时覆盖表的消耗时间种群规模1003.92.99.1913.213.767.9432.1817.1476.32732.73.9412.320.0471.692100192.7133.8430.6466.1707.7261.71086521.123391337116269.59442.21.1230.564100595.7416.3141013002242706.330201570695143143383136.21588.62.962.3361001342872.93080265350261499626929951355394217072225.326805.164102数据显示,虽然非climb算法的整体性能不如climb算法,但在非climb算法中,一定范围内增加种群规模能够减小覆盖表的生成规模.因此我们得出结论,种群规模对非climb遗传算法的性能具有一定影响,在一定范围内种群规模越大,算法性能越好,但这种影响会被climb遗传算个参数配置下各待测实例的覆盖表生成规模和消耗时间如表10、表11所示(5次测试取最优解).加粗部分是基准参数配置Px,“”标记的是Basechoice实验所得各待测实例覆盖表生成的遗传算法种群规模最优取值.置中的算法选择都是climb算法,而没有涉及非climb算法,为了保证结论的准确性,我们利用各待测实例另做了一组验证实验,以探索种群规模取值对GA,GA-,GAr这3个非climb算法的性能影响.验证实验步骤如下:先从表8和表9中的非climb算法中选出对应各待测实例的覆盖表生成效果最优的算法,用“#”标记(观察可知,算法集中于GA),然后用其代替各待测实例原基准配置Px中的算法.在此基础上重复6.2.2节实验.实验数据如表10和表11所示.法中种群最优个体的爬山优化过程削弱.6.2.3进化代数本文中进化代数的取值集合为{100,600,1100},对应3个不同的配置,这3个参数配置下各待测实例的覆盖表生成规模和消耗时间如表12、表13所示(5次测试取最优解).Page10表12Basechoice实验中选择不同进化代数时覆盖表的生成规模进化代数10028186239108228745103178907337422060029196036100217941941608571384220110028185935100217741901578272374321表13Basechoice实验中选择不同进化代数时覆盖表的消耗时间进化代数1000.300.230.671.00.940.612.31479.35.61.922.4369.152.282.90.446001.781.403.825.405.043.4312.46251630.19.7713.4218.4330.0717.31.8311003.092.436.939.588.936.0222.444635317.823.5602.9620.9532.13.78根据以往的经验来看,进化代数的取值会对算法的性能产生较大影响,但本实验的数据显示,对于不同大小待测实例的覆盖表生成,进化代数的影响程度并不相同.例如在较大的待测实例1011和620中,随着进化代数的增加,覆盖表的规模明显减小;但在较小的待测实例410和313中,进化代数取值不同时覆盖表的规模变化不大.上述结论表明,进化代表12Basechoice验证实验中选择不同进化代数时覆盖表的生成规模进化代数1003320764412725103491262101087839422460033217744128251044812521010876404224110033197644126261044812621210776384324表13Basechoice验证实验中选择不同进化代数时覆盖表的消耗时间进化代数1000.340.2660.81.221.290.702.95508.27.222.562.8634.58119.42.90.256002.061.6854.937.257.694.1917.6299542.914.9517.1225.3731.9717.31.6911003.92.99.1913.213.87.9432.2551276.32732.7352.21588.632.12.81数据显示:在非climb算法中,随着进化代数的增加,算法性能未出现明显变化,即climb遗传算法中种群最优个体的爬山优化过程会削弱进化代数对算法性能的影响.6.2.4交叉概率本文中交叉概率的取值集合为{1,0.8,0.6,0.4,0.2},对应5个不同的配置,这5个配置下各待测实例的覆盖表生成规模和消耗时间如表14、表15所示(5次测试取最优解).表14Basechoice实验中选择不同交叉概率时覆盖表的生成规模交叉概率1.0291959361002177429115882713642200.8281859351002177429015782713643200.6281859351002276419015784733641210.429186036992176418915884723742210.228195935100217642881568472374220表15Basechoice实验中选择不同交叉概率时覆盖表的消耗时间交叉概率1.03.422.567.2549.899.136.0822.29256753.617.5823.67218627.672.861.970.83.282.436.839.588.936.0722.425515317.823.5219.9568.052.871.830.63.262.456.999.589.036.3521.97251652.817.5823.84219.7569.92.51.860.43.262.427.089.838.836.1321.86251051.617.6323.70225620.792.821.950.23.092.546.939.558.976.0221.84257451.417.323.80214.1620.952.921.86数的取值改变不会对较小规模待测实例的覆盖表生成产生很大影响,但对于较大规模待测实例的覆盖表生成,进化代数在一定范围内取值越大,生成规模越小.为了验证这种现象是否是由算法种群最优个体的爬山优化所引起,我们将3个配置中的climb算法全部替换为非climb算法并再次测试,方法同6.2.2节的验证实验,实验数据如表12和表13所示.Page11表14、表15中“”分布十分分散,且比较每一列数据我们发现,交叉概率取不同值时,同一待测实例的覆盖表生成规模最大差距仅为2个测试用例.由于算法性能十分接近,我们将其看做是遗传算法的不确定性所引起的随机扰动,即交叉概率在一定范围内的改变不会对覆盖表生成的遗传算法性能造表14Basechoice验证实验中选择不同交叉概率时覆盖表的生成规模交叉概率1.0342177451272510448125210107763942240.8331976441262510448126212107753942240.6332077441242510448126211105783941240.4332076441242510347125209106773942230.233207644123261034912520910479384325表15Basechoice验证实验中选择不同交叉概率时覆盖表的消耗时间交叉概率1.03.933.099.0813.5913.937.7432.12300878.6627.8630.78225.312872.861.530.83.792.98.9213.213.767.7232.18298676.32732.7196.612882.91.690.63.652.939.013.3913.577.7432.11299579.0327.5930.30202.112842.531.530.43.782.939.0313.2313.577.7531.78297478.0826.8330.75196.713442.821.470.23.92.929.1913.2313.377.9431.68307077.8627.0930.03199.21588.62.781.596.2.5变异概率本文中变异概率的取值集合为{1,0.8,0.6,0.4,0.2},对应5个不同的配置,这5个配置下各待表16Basechoice实验中选择不同变异概率时覆盖表的生成规模变异概率1.02918634111322924711218497734042200.82919624011222924611218595714042210.62818613910721914611017893713942200.42818593710321834510216487723742200.228185935100217741901578273384221表17Basechoice实验中选择不同变异概率时覆盖表的消耗时间变异概率1.03.392.707.6112.4511.786.829.23297369.723.6830.3219.9689.383.241.830.83.532.97.4112.412.066.9329.31288070.724.2830.3218.4695.593.512.010.63.232.757.4412.1511.696.6229.03288369.123.5630.2206671.13.491.900.43.092.586.9311.0310.236.0225.49280962.720.4727.5214.8620.93.432.110.22.92.436.449.588.935.7722.425165317.823.5197.2588.112.92.06表16、表17中“”集中在最后一行,即本实验中绝大多数待测实例的变异概率最优取值都为0.2.通过对每一列数据的进一步比较可以发现,在多数覆盖表中,其生成规模和消耗时间都随着变异概率的减小总体呈递减趋势.如在待测实例810中,随着变异概率的逐渐减小,生成的覆盖表规模减小了13个测试用例,同时算法的消耗时间从11.78s逐步减到了8.93s.上述结果表明,变异概率的取值对覆盖表生成的遗传算法性能具有较大影响,多数成太大影响.为了验证这一现象是否是由climb算法中种群最优个体的爬山优化所引起,同6.2.2节,我们进行了验证实验,实验数据如表14和表15所示.数据显示,交叉概率的改变对算法性能影响仍然很小,即交叉概率对算法性能的影响程度与算法是否是climb算法无关.测实例的覆盖表生成规模和消耗时间如表16、表17所示(5次测试取最优解).情况下,变异概率越小,算法性能越好.同样,为了验证这一现象是否是由climb算法中种群最优个体的爬山优化所引起,我们进行了验证实验,实验步骤同6.2.2节,即以表8和表9中的覆盖表生成效果为标准,将各配置中的climb算法改为非climb算法.实验数据如表16和表17所示.数据显示,随着变异概率的减小,多数覆盖表的规模和消耗时间仍总体呈减少趋势,即变异概率对算法性能的影响程度与算法是否是climb算法无关.Page12表16Basechoice验证实验中选择不同变异概率时覆盖表的生成规模变异概率1.0362284511512711951140249123784242240.8352281491472711651139245121764142240.6352179481432611351136239119774041240.4332176471392611150132230114783841240.231197044126241044812621210777404125表17Basechoice验证实验中选择不同变异概率时覆盖表的消耗时间变异概率1.04.173.539.8316.2917.938.8238.92331991.3535.4838.03198.01485.23.251.690.84.183.629.9516.2218.328.6138.95336292.5935.1338.31225.31462.52.91.580.64.013.439.5215.6517.718.3537.81326290.7534.7137.22196.11446.62.491.560.43.93.299.1914.8716.377.9435.88319186.2131.9234.71190.91588.63.321.480.23.182.97.5813.213.766.8932.18299576.32732.7173.01382.22.491.43综合上述实验数据可以得到遗传算法5个配置参数在不同待测实例中的覆盖表生成的最优参数取值.我们将这些最优参数取值进行组合,即得到不同待测实例的遗传算法覆盖表生成的最优参数配置.表18basechoice实验所得各待测实例的最优参数配置及覆盖表生成结果实例算法mTPcPmSizeTime/s实例算法mTPcPmSizeTime/s410GArclimb1001000.20.2280.234630GAclimb10011000.20.28771.99313GArclimb1001000.40.2180.1871011GAclimb10011000.20.215422.09610GAclimb10011000.80.2596.724766756GArclimb10011000.80.28229.39420GArclimb10011000.20.23511.7582726252GA-climb61006001.00.6702413810GArclimb41006000.40.2101252.66151463823GArclimb41001000.80.43969.51320GA-climb1006000.20.2213.5764GArclimb21001000.60.2421.123620GAclimb10011000.20.27530.9513822GArclimb1001000.81.0210.234430GArclimb1006000.40.24116.97Basechoice实验能够准确评价遗传算法5个配置参数各自对算法性能的影响性质和影响程度,并找出每一个配置参数在不同待测实例的覆盖表生成问题中的最优取值,但实验只注重算法配置参数的局部优化,没有考虑算法整体性能是否得到提升.实验数据显示,在待测实例810中,覆盖表最小生成规模为99(见实验过程),而Basechoice实验得出最优参数配置的覆盖表生成规模为101,因此算法各配置参数达到局部最优时,算法整体性能不一定最优.为了更好地探索覆盖表生成的遗传算法最优配置,我们设计了另一条实验路线———爬山实验,爬山实验能够较好地处理算法局部配置参数优化和算法整体性能提升之间的平衡关系,实验对参数配置的每一轮优化都是在上一轮优化的基础上进行,算法的整体性能会随着配置参数的逐步优化而一步步提升,从而得到能使算法整体性能达到最优的参数配置.6.3爬山实验实验以pair-wise实验所得最优参数配置Px作为基准参数配置.由于爬山实验是在实验过程中一步步对遗传算法的配置参数进行优化,所以配置集如表18所示,待测实例不同,其最优参数配置也不同.下面我们利用这些最优参数配置生成15个待测实例的覆盖表,为了保证结果的准确性,我们从10次生成结果中取最优解.是动态生成的,下面我们将按照算法配置参数的优化顺序对实验进行逐步分析并找出该配置参数的最优取值.考虑到演化搜索算法结果的不确定性和运行时间较长这一实际问题,实验从5次运行结果中选取最优解作为测试结果.6.3.1遗传算法的变种算法首先改变遗传算法的变种算法这一参数取值,由于基准参数配置Px不一致,每个待测实例各自产生5个参数配置,对应算法的不同参数取值.实验结果见表8、表9.综合覆盖表的生成规模和消耗时间这两个标准,我们得到算法选择的最优取值,其所对应的参数配置C1如表19所示.表19爬山实验各待测实例中算法优化所对应的参数配置犆1实例a1a2a3a4a5实例a1a2a3a4a5410502436303021431350214101130214610302437667565021442050214827262524310181030214615146382352243320402436452044620302145138225011043053124Page136.3.2种群规模在C1的基础上我们对种群规模的取值进行改变,每个待测实例各自对应4个不同的参数配置,测试结果如表20、表21,表中“”标记种群规模的最优参数取值.由此我们得到各待测实例的参数种群规模表20爬山实验中选择不同种群规模时覆盖表的生成规模1002917593599217440891548275394220210028186035982277418915585703942214100291860369921774190156837236422061002818583698217641911558370384321表21爬山实验中选择不同种群规模时覆盖表的消耗时间种群规模1002.992.286.1610.110.255.6722.912.753.319.823.53.6810.730.131.78210064.456.1135394.5614246897459189815291146283.237.211.3138.754100131118.92691222197267926121354559151503133899.7627.72.9277.846100202190.341324314379146552722474105009267491420341079.34.56132.4表22爬山实验各待测实例中种群规模优化实例a1a2a3a4a5实例a1a2a3a4a5410512436303021431350214101130214610332437667565021442050214827262524110181031214615146382352243320402436450044620302145138225011043050124表23爬山实验中选择不同进化代数时覆盖表的生成规模进化代数1002919613710322834310116690723742206002819603610021774091158857038432011002817583598217440891548271364321表24爬山实验中选择不同进化代数时覆盖表的消耗时间进化代数1006.110.17239.11.0358.90.612.342.365.592.182.4345.2452.280.130.4460034.81.72245.713393.3412.8312.730.011.613.4283330.070.331.78110064.42.2841310.16145.6722.922.253.319.823.5489.1627.70.703.26表25爬山实验各待测实例中进化代数优化实例a1a2a3a4a5实例a1a2a3a4a5410511436303021431350214101130214610332437667565021442050214827262524110181031214615146382352243320401436450044620302145138225001043050124配置C2,如表22所示.通过观察表20、表21中数据可知,种群规模的改变对算法性能的影响主要体现在消耗时间上,对覆盖表的生成规模没有产生较大影响,这进一步验证了Basechoice实验中的结论.6.3.3进化代数在C2的基础上改变进化代数的参数取值,对应各待测实例的3个不同参数配置,测试结果如表23、表24所示,其中“”标记进化代数的最优取值.比较表中的数据,我们发现在766756、1011和810这些规模较大的待测实例中,进化代数取值越大时覆盖表生成规模越小;而在320、410和513822这些规模较小的待测实例中覆盖表生成规模变化却没有明显规律,这验证了Basechoice实验中的结论.实验最终得到各待测实例的参数配置C3,见表25.6.3.4交叉概率在C3的基础上改变交叉概率的取值,对应各待测实例的5个不同参数配置,测试结果如表26、表27所示,其中“”标记交叉概率的最优取值.通过对表中数据进行观察可知,交叉概率的改变对覆盖表的生成规模及消耗时间没有太大影响,不同交叉概率取值下覆盖表的生成规模之间差距很小,且没有明显的规律可循.结论与Basechoice实验一致.在对交叉概率进行优化后我们得到各待测实例的参数配置C4,见表28.Page14交叉概率表26爬山实验中选择不同交叉概率时覆盖表的生成规模1.029196137992176418915582703642210.828176035982174418915482703642200.629186136982275408815584713641210.428195936992175418815684723743220.22819583698217640871558471364221表27爬山实验中选择不同交叉概率时覆盖表的消耗时间交叉概率1.037.442.76416.411.2607.73.3723.112.4154.220.823.67283626.20.0470.450.835.682.28407.210.16143.422.912.2453.319.823.5281568.10.190.440.635.373.06418.111.36043.4522.9512.7153.320.323.84282569.90.030.470.434.32.67411.210.66113.4522.7412.2553.020.323.70291620.80.0470.470.234.82.7841310.3614.3.3422.9312.452.620.1523.80263627.70.130.45表28爬山实验各待测实例中交叉概率优化实例a1a2a3a4a5实例a1a2a3a4a5410511336303024431350214101130214610332437667565021442050214827262524111181031224615146382352213320401436450024620302145138225001043050144变异概率表29爬山实验中选择不同变异概率时覆盖表的生成规模1.02919614110923934911218597714043200.82918613910422914811018395704043200.62819593910222884710717293703942200.428195836992181449816187713642210.22817583598217440871548270384120表30爬山实验中选择不同变异概率时覆盖表的消耗时间变异概率表31爬山实验各待测实例中变异概率优化1.037.712.87431.212.1716.93.8430.2216.4771.127.530.3290.2699.380.0470.440.838.363.70425.412.2680.33.7430.1416.5471.527.630.3281695.590.0470.450.637.043.15422.211.5666.53.7429.1616.2169.025.830.2277671.10.0470.450.434.33.01413.710.8635.43.3426.0414.5261.722.727.5273.4568.10.0470.4420.232.12.340210.16043.3122.912.452.619.823.5279.5588.10.030.43通过这5轮实验,我们得到各待测实例覆盖表生成的最优参数配置.如表32所示,不同覆盖表的最优参数配置各不相同.下面我们利用这些最优参数配置生成各待测实例的覆盖表,为了保证结果的准确性,我们从10次生成结果中取最优解.实例a1a2a3a4a5实例a1a2a3a4a54105113463030244313502141011302146103324476675650214420502148272625241112810312246151463823522133204014464500246203021451382250014430501446.3.5变异概率在C4的基础上对变异概率的取值进行改变,对应各待测实例的5个不同参数配置,测试结果见表29、表30,其中“”标记交叉概率的最优取值.通过观察我们发现,随着变异概率的减小,覆盖表的生成规模和消耗时间总体呈减小趋势.这表明在一定范围内变异概率的取值越小,覆盖表生成的遗传算法性能越好,与Basechoice实验结论一致.实验最终得到各待测实例的参数配置C5,见表31.Page15表32爬山实验所得各待测实例的最优参数配置及覆盖表生成结果实例算法mTPcPmSizeTime/s实例算法mTPcPmSizeTime/s410GArclimb21006000.40.22832.1630GAclimb10011000.20.28752.6313GArclimb10011000.80.2172.281011GAclimb10011000.80.215419.8610GAclimb610011000.20.258402766756GArclimb10011000.80.28223.5420GArclimb10011000.80.23510.182726252GA-climb21006000.80.670277810GAclimb21006000.60.2986046151463823GArclimb410011000.80.436568.1320GA-climb1006000.20.2213.3164GArclimb1001000.60.2410.03620GAclimb10011000.80.27422.9513822GArclimb1001000.80.2200.43430GArclimb1006000.20.24012.46.4实验结论本实验通过pair-wise实验,Basechoice实验以及爬山实验这3条实验路线系统地探索了覆盖表生成的遗传算法中各配置参数的取值及其相互作用对算法性能的影响.3条实验路线探索算法性能的角度和侧重点各不相同,pair-wise实验主要探索遗传算法各配置参数之间的二维组合关系对算法性能的影响,实验的参数配置集是遗传算法5个配置参数的二元组合覆盖表.Basechoice实验更侧重于发掘各配置参数自身对算法效果的影响,实验对遗传算法的5个配置参数进行了单独的深入探索.爬山实验则是对参数配置进行逐步优化,参数配置的整体性能会随着每一轮参数优化的完成而一步步提高.表33各待测实例的最终最优配置和覆盖表生成结果实例算法mTPcPmSizeTime/s实例算法mTPcPmSizeTime/s410GArclimb1001000.20.2280.234630GAclimb10011000.20.28752.6313GArclimb10011000.80.2172.281011GAclimb10011000.80.215419.8610GAclimb610011000.20.258402766756GArclimb10011000.80.28223.5420GArclimb10011000.80.23510.182726252GA-climb21006000.80.670277810GAclimb21006000.60.2986046151463823GArclimb410011000.80.436568.1320GA-climb1006000.20.2213.3164GArclimb1001000.60.2410.03620GAclimb10011000.80.27422.9513822GArclimb1001000.80.2200.43430GArclimb1006000.20.24012.47总结和展望本文系统地研究了遗传算法这一演化搜索算法在进行覆盖表生成时的性能优化问题,通过3条实验路线探索遗传算法的变种算法、种群规模、进化代数、交叉概率和变异概率这5个因素及其相互作用对算法性能的影响,得出以下结论:(1)覆盖表生成的遗传算法性能受算法的参数配置影响很大,不同参数配置下的覆盖表生成结果之间具有明显差异.例如参数配置中算法选择为GAclimb或GArclimb时算法生成覆盖表的规模普遍较小,而算法选择为GA-时,则会生成较大规模的覆盖表.(2)遗传算法的各配置参数对算法生成覆盖表通过实验我们得出结论,算法选择、进化代数和变异概率这3个配置参数对覆盖表生成的遗传算法整体性能影响较大,种群规模的影响只体现在算法消耗时间上,而交叉概率的影响相对较小.其中算法选择以GAclimb和GArclimb算法较优,且进化代数取值较大,交叉概率取值较小时算法性能会有明显提高.结论表明,对于某个特定问题的二维覆盖表生成,遗传算法中存在一组最优参数配置,使其总是能发挥较优的性能.表33中是比较三组实验后所得15个待测实例的最优参数配置和覆盖表生成结果.观察可知,不同待测实例中,覆盖表生成的最优参数配置之间差异很大,即不存在一组适用于所有二维覆盖表生成的最优参数配置.性能存在不同程度的影响,其中算法选择、进化代数和变异概率这3个配置参数对覆盖表生成的遗传算法整体性能影响较大,种群规模的影响只体现在算法消耗时间上,而交叉概率的影响相对较小.(3)对于特定的二维覆盖表生成问题,存在一组最优参数配置,使得遗传算法总能发挥较优的性能.对于一般的二维覆盖表生成问题,则不存在这样一组通用的最优参数配置.不同的覆盖表生成问题,其最优参数配置之间存在差异,但也具有一定的共性,实验结论显示,在本文涉及的15个待测实例的最优参数配置中,算法选择集中于GAclimb和GArclimb算法,进化代数取值总体较大,变异概率取值总体较小.在以后的工作中,我们将在已有的工作基础上对实验中所得到的遗传算法最优参数配置进行验证Page16和进一步优化,例如,以实验结论为基础扩大配置参数取值集合,进一步探索climb算法下更大进化代数,更小变异概率的遗传算法性能;对相同参数配置下的待测实例进行10次甚至20次的覆盖表生成实验以使实验结果更加精确等.另一方面,由于实验规模和复杂度会进一步增加,我们计划将实验迁移到云计算环境中,利用云计算平台优越的计算能力更好更快地设计和实施实验.针对覆盖表生成过程中,遗传算法的通用最优配置不存在的情况,我们将研究利用本文实验方法构建一种两阶段多配置并行遗传算法,该方法首先使用pair-wise参数覆盖表配置一组遗传算法先行进行计算,然后选择其中性能好的配置,以这几个配置为基础分别作爬山和Basechoice配置试验,用它们中产生的最好的结果作为并行遗传算法的结果.关于这个方法的效果验证我们将另文讨论.针对特定的覆盖表生成实例,另外一个改进遗传算法性能的方向是我们拟采用配置演化的方法,演化过程中首先随机生成一组遗传算法的配置作为初始种群,运行这组配置对应的遗传算法,生成该特定实例的覆盖表,以每个算法生成的该特定实例的覆盖表规模作为适应值度量,覆盖表规模越小,适应值越高,从而对这组配置进行适应值排序,并对其进行选择、交叉和变异,形成第二代种群.循环该过程,直到性能不再提高或达到某种收敛标准,系统研究这种方法的性能和成本.
