Page1Purpose融合:基于风险purpose的隐私查询访问控制刘逸敏1),2)周浩峰1)王智慧1)汪卫1)1)(复旦大学计算机科学技术学院上海200433)2)(第二军医大学第三附属医院信息科上海200438)摘要基于purpose的查询技术是关系数据库对隐私数据访问控制的基础,目前大多数研究都仅仅关注在独立隐私保护数据库环境下,如何建立有效的基于purpose的隐私数据访问控制模型.但随着分布应用整合和数据共享需求的日益增长,如何合并独立应用下基于purpose访问控制模型的问题就应运而生.为解决这一问题,文章提出了多应用系统集成环境下基于融合purpose的隐私数据访问控制实现机制.文章首先分析了由于合并独立purpose模型而引起的潜在隐私数据查询泄漏,提出了合并后的purpose树是一棵隐私泄漏风险树,并给出了树结点隐私风险度的计算模型.其次,将隐私泄漏风险树分解成一棵所有结点风险度为0的风险平衡树以及一组由风险度不为0的结点组成的风险路径.这样,一个查询可被改写为先对风险平衡purpose树的查询,再对风险路径查询,以此达到隐私泄漏风险最小的安全查询结果.文章给出了3组实验的结果:(1)对于同一用户同一查询,在不同purpose模型下的查询时间比较.文章提出的模型并没有在查询时间上带来更大的开销.(2)对RPPAAC模型防止隐私数据泄漏的有效性验证.文中的模型可降低由应用整合引起访问控制机制不平衡所带来的隐私数据泄漏风险.(3)不同情况下purpose融合的执行时间比较.文章与相关研究的不同之处是将purpose作为隐私数据的载体、purpose树的路径作为隐私数据的传递通道,引入了显性隐私度和隐性隐私度的计算模型,评估基于一个purpose查询可能带来的隐私泄漏风险,进而提出了多应用系统集成环境下基于融合purpose的隐私数据访问控制实现机制.关键词隐私;隐私保护数据库;purpose;隐私度;访问控制1引言信息网络技术的快速发展提供了许多基于网络平台的增值服务,如医疗机构间电子健康档案的共享和网络在线预定服务等,然而,用户在享受便捷的同时,个人隐私数据泄漏的风险也随之不断增加,因此隐私数据访问控制技术的研究与应用迫在眉睫.自P3P(TheW3C’sPlatformforPrivacyPref-erence)[1]和OECD[2]对隐私数据访问规范发布以来,出现了许多对基于purpose的隐私数据访问控制模型的研究,并在不同领域中得到应用,如在关系数据库中以树结构描述datapurpose的generaliza-tion/specialization特性,访问控制模型以查询用户的accesspurpose是否与隐私数据的datapurpose匹配机制去实现[3-9];还有些控制模型借鉴了安全数据库用户访问等级的概念,将purpose作为数据访问的安全等级,分别对应不同的泛化的隐私数据,该控制机制是同一用户在不同的purpose等级下,查询不同的隐私数据[6,10-11];第三类模型是一项业务由可选的多组purpose组成,那么完成一项业务的最小隐私数据泄漏是找出一组purpose,使基于该组purpose的可访问隐私数据最小[12-13];还有些模型拓展了传统的基于角色的访问控制机制,对角色的授权从原先的对数据库对象(关系)的访问扩展到基于不同purpose下的对不同隐私数据(关系中的属性)的访问[14-16].但随着分布应用的整合和数据共享的需求的增加,如何把原先不同应用已建立的基于purpose访问控制模型进行合并的问题就应运而生,并逐渐成为一个亟待解决的问题,而已有的模型大都没涉及如何解决该类问题.本文基于对隐私数据的最大查询结果和最小查询隐私泄漏需求[9,17-19],研究了分布应用被整合环境下由于合并独立purpose模型而引起的潜在隐私数据查询泄漏问题,提出了合并后的purpose树是一棵隐私泄漏风险树,并给出了结点隐私风险度的计算模型.基于风险purpose的隐私查询访问控制模型的基本思想是将隐私泄漏风险树分解成一棵平衡树和一组风险路径,一个查询被改写为先对平衡purpose树的查询,若结点隐私度不为0,再对风险路径查询,以此达到隐私泄漏风险最小的安全查询结果.本文的主要贡献是:(1)提出了计算由于相同purpose结点合并而可能引起的该结点访问隐私属性增加的隐私度以及计算由于合并后存在路径传递而引起的隐私属性增加的隐私度的方法.(2)提出分裂风险结点、建立一棵隐私度为0的平衡purpose树以及存储风险路径算法,使控制模型的查询能返回隐私泄漏风险最小的安全查询结果.(3)实验表明,本文提出的隐私数据库访问控制模型能有效减少由应用整合引起访问控制机制不平衡所带来的隐私数据泄漏风险.本文第2节是相关工作;第3节详细介绍融合purpose树结点隐私度的计算模型和基于风险pur-pose查询的隐私数据库访问控制模型;第4节是模型实验和讨论;最后第5节总结本文工作并给出展望.2相关工作与本文研究内容相关的领域有隐私保护数据库、访问控制技术和风险评估.本文对隐私数据与隐私策略的定义遵循了P3P[1]的工业标准,将purpose作为隐私数据访问与管理的元素,并且purpose具Page3有层次特性.本文涉及的purpose树融合,是以HDB[4]提出的purpose作为隐私数据标签、以pur-pose树定义隐私策略[5]为基础,假设在隐私数据库中已存在了描述隐私访问规则的purpose树.在对purpose层次定义方面本文与原先工作相同的是purpose树是一棵Gengealization/Speciliza-tion树[3,5-6,10-11],不同的是本文进一步定义了pur-pose树结点之间隐私数据访问的传递关系.在现有工作中将基于purpose的访问归结为对元数据表的链接操作,但元数据表属性的设置没有反映pur-pose的层次结构,会引起元数据的冗余.另一方面现有元数据模式的设计没有考虑不同应用之间元数据的整合,这样就不能解决基于多purpose融合查询的访问控制模型合并问题.有些工作[12-13,15]与本文定义的purpose层次概念不同,它们把purpose树看成是一项任务的分解,路径构成了完成任务的每个节点,隐私控制就是找出一条路径,使路径上可访问的隐私数据权重值最小.在访问控制策略研究方面,现有的工作[5,14,16]大都是在单应用环境下基于purpose树的查询控制,但一旦在多应用环境下purpose树结构变化,现有的控制机制就有隐私数据查询泄漏的风险.本文在给出purpose隐私度的计算模型方面,基于了社会网络评估用户风险的概念[20-22],在现有的工作中都将用户的配置信息作为用户的隐私数据,通过评估配置信息的隐私程度来给出用户在社会网络下的风险度.这些工作与本文计算隐私度的目的不同,前者是评估风险,而本文是通过隐私度计算去实现数据库的访问控制机制.3基于风险purpose的隐私查询访问控制当二棵独立purpose树合并时,由于相同结点的合并导致purpose下可访问隐私属性的增加,打破了原先独立purpose树的风险平衡,合并后的purpose树(CombinedPurposeTree,CPT)是一棵有隐私数据泄漏风险的purpose树,所以需要重建基于CPT查询的访问控制模型.本节先以实例说明基于CPT查询的隐私泄漏过程,提出风险purpose树结点隐私度的计算模型;其次定义融合purpose树(JointPurposeTree,JPT)为一棵结点带有隐私度的CPT,并给出算法分裂隐私度不为0的结点,将JPT模型分解成一棵平衡树和一组风险路径;最后基于JPT的查询改变为先对平衡purpose树的查询,若结点隐私度不为0,再对风险路径查询,以此来实现基于风险purpose的隐私查询访问控制(RiskPurposeBasedPrivacy-AwareAccessCon-trol,RPPAAC).3.1问题描述设已知应用s1和s2的隐私数据库purpose模型pt1、pt2和purpose的元数据如图1和图2所示,表示user1和user2分别基于pt1和pt2的pur-pose查询允许访问的隐私数据.Purpose树中有部分结点相同,但相同purpose结点下可访问的隐私数据不完全相等,根据purpose模型的generaliza-tion/specilization的特性[3-5,13,19],使pt1和pt2基于purpose=p3的访问有如下性质(‘∷’表示等同于):pt1(purpose=p3)∷pt1(purpose=(p3,p4,p5))pt2(purpose=p3)∷pt2(purpose=(p3,p4))如其中基于pt2下purpose=p3的查询能访问隐私数据{mobile,result},同样基于pt2的purpose=p4的查询除了可访问数据msn外,也能访问{mobile,result}.当分布应用s1和s2被整合时,就需要合并两棵满足不同应用需求的purpose树,并且要求基于融合后purpose树的查询要控制隐私数据泄漏的风险.Purpose合并有两种方式,一是通过根结点合并将pt2作为pt1的子树,这种方式由于直接合并导致存在重复的purpose结点,以purpose为访问目的的查询会引起歧义.另一种方式是先将相同pur-pose结点合并生成pt3,当pt2有剩余结点时,在pt3中找到剩余结点的父结点,并将其作为该父结点的子节点插入pt3,已知图3是pt1、pt2合并后purpose模型pt3的树结构(p0(p1(p3(p4,p4,Page4p5)),p2,p1)和合并后purpose={p0,p1,p3,p5}的元数据,虚线圈表示合并过程,从元数据表可发现由于树结构的变化,user1基于合并pt3的purpose=p3的查询结果是{result,mobile},而合并前基于pt1的purpose=p3的查询结果是result,由此会引起隐私数据的查询泄漏.同样user2基于pt3的purpose=p5的查询结果{mailbox,history,dis-ease}多于基于pt2的purpose=p5的查询结果,当考虑了purpose的generalization/specilization的特性后,基于pt3的purpose=p5还可访问数据{result,mobile},即存在p3p5的路径,而在pt2中不存在这样的访问路径.所以合并后purpose树pt3是一个带有隐私泄漏风险的访问控制模型.图3pt3元数据(purpose=p0,p1,p3,p5)和purpose树pt33.2purpose融合Purpose融合涉及purpose树的合并以及合并后purpose结点隐私度的计算.隐私度计算的基本思想是计算由于相同purpose结点合并而可能引起该结点访问隐私属性增加的风险度以及计算由于合并后存在路径传递而引起的隐私属性增加的风险度.3.2.1隐私度计算模型定义1(purpose树PT,PurposeTree).一个系统的隐私数据访问目的(purpose)用一棵层次purpose树PT表示,pi和pj是PT的结点,每个结点对应了其可读取的隐私属性集.若pi是pj的父结点,表示pi和pj是泛化和特例(generalization/specilization)的关系,其路径表示基于pi的访问等同于基于{pi,pj}的访问.设{ui}和{vj}分别是基于pi和pj可查询的隐私属性集,那么基于pj的可访问数据集是{ui}∪{vj},如图1应用s1的purpose树是pt1,基于p0和p1可访问的隐私属性分别是{p-id},{p-id,orders}.定义2(合并purpose树CPT,CombinedPur-poseTree).设pti、ptj∈PT,pti[m]和ptj[n]分别是pti和ptj的一个结点,那么CPT=pti∪ptj.设CPT[r]是CPT的一个结点,当pti[m]=ptj[n],那么CPT[r]=pti[m];基于purpose=CPT[r]的查询可访问数据是{ui}∪{vj};否则CPT[r]=PARENT(pti[m]).图4是pt2被并入pt1的分解图.定义3(隐私度,PrivacyRisk).Purpose树结点的隐私度是指基于该结点的查询存在隐私数据泄漏风险的程度.由于purpose树结点间有generali-zation/specialization的关系,结点的隐私度不仅要考虑基于结点本身的查询存在隐私泄漏的风险,还要考虑结点所有查询路径上隐私数据泄漏的风险,因此结点隐私度的度量是结点显性隐私度和结点隐性隐私度的函数.隐私度和隐私度计算有如下性质.性质1(显性隐私度pr,publicrisk).结点的显性隐私度是由于相同purpose结点合并而可能引起该结点下可访问隐私属性增加的风险程度,设pt1、pt2∈PT,pi和pj分别是pt1和pt2的结点,{ui}和{vj}分别是基于pi和pj可查询的隐私属性集,n=(count|{ui}∪{vj}|-count|{ui}∩{vj}|),表示属性集中不相同隐私属性的数量.当pi=pj且二结点合并后的结点是cptl,此时基于purpose=cptl的查询可访问数据集{ui}∪{vj},那么cptl的显性隐私度pr(cptl)=n,若{ui}={vj},则n=0.pi的显性隐私度pr(pi)与pi所能访问隐私属性的数量是否增加有关,若增加数量越多,说明隐私数据库用户u基于pi的查询所能访问的隐私属性就越多,而这些隐私属性中的一部分信息可能已超出了合并前访问控制模型返回的内容范围.由图3所示p3的显性隐私度pr(p3)=1,pr(p5)=3;显然没有合并的结点的显性隐私度pr(p4)=pr(p4)=pr(p0)=0.性质2(隐性隐私度hr,hiddenrisk).结点的隐性隐私度是由于合并后存在路径传递而引起的访问隐私属性增加的风险程度,设pi是pt1的任意结点,k是结点pi的度,那么hr(pi)=k.Page5pi隐性隐私度的计算与pi下的子结点数量有关,表示一旦pi可访问隐私数据增加,那么pi所有路径上的子结点,会因层次purpose树的继承关系也额外增加了本不可访问的隐私数据,所以pi的隐性隐私度以树结点pi的度来衡量.图3中hr(p3)=3,说明若p3可读隐私属性增加,那么其3个子结点的可读隐私属性也随之增加,加大了数据泄漏的风险,而hr(p5)=0.性质3(隐私度计算r,PrivacyRiskComputa-tion).purpose树结点的隐私度是关于pr和hr的函数f(pr,hr),设pi∈pt1那么pi的隐私度计算有如下模型,r(pi)=pr(pi)hr(pi)模型表示当且仅当pr(pi)≠0时,才存在结点隐私度,因为pr(pi)=0时,表示基于pi可访问隐私数据没有增加,由此也不会影响其子结点可读隐私属性的变化.r(pi)越大,表明用户基于pi或pi子结点的查询,其隐私数据泄漏的风险就越高.图3所示pt3树中r(p3)=4,r(p5)=3,而根据定义,模型其余结点的隐私度为0.定义4(风险树RPT、平衡树BPT和融合树JPT,RiskPurposeTree、BalancePurposeTreeandJointPurposeTree).设pt1、pt2∈PT,pi是PT的任意一个结点,1in,n是PT的结点数RPT是一棵风险purpose树,当且仅当pi,有r(pi)≠0;BPT是一棵平衡purpose树,当且仅当pi,有r(pi)=0,表明任何用户基于BPT树中purpose的查询,其返回结果不会造成隐私数据的泄漏;JPT是一棵融合树,Jpt=pt1∪pt2,表示融合树JPT是一棵已计算结点隐私度的CPT,且也是一棵风险树.图3所示pt3是一棵带有隐私数据泄漏风险的融合purpose树.3.2.2融合树生成算法算法1为融合purpose树生成算法,首先Combined_purpose()是purpose树合并算法,其次Joint_purpose()是计算合并树的每个结点隐私度,并生成融合purpose树.算法1.融合purpose树生成算法.Purpose树合并算法Combined_purpose()输入:pt1,pt2//pt1,pt2是分布应用s1和s2的pur-输出:pt3//pt3是一棵合并树,由pt2并入pt1BEGIN1.DOWHILE1in2.j=13.DOWHILE1jm4.IFp1[i]=p2[j]THEN//比较pt1,pt2结点,5.A[i]=D1[i]∪D2[j],pt3[i]=pt1[i]6.break7.ELSEIFp1[i]=Parent[p2[j]]THEN8.Child[p3[i]]=p2[j]9.break10.ENDIF11.j=j+112.ENDDO13.i=i+114.ENDDOENDPurpose树融合算法Joint_purpose()输入:A[pt1],A[pt2]//pt1,pt2树模型的隐私数据表输出:JPT(pt3)//结点带有隐私度的融合树pt3,//显性隐私度、隐性隐私度和隐私度计算公式分别是pr、hr和r,p1[i]、p2[j]和pt3[k]分别是pt1、pt2和pt3的一个结点,l是pt3的结点数BEGIN1.Combined_purpose()2.DOWHILE1kl3.DOWHILE1inOR1jm4.IFpt3[k]=p1[i]ORpt3[k]=p2[j]THEN5.计算pr(pt3[k]),hr(pt3[k],r(pt3[k])=6.ELSEpr(pt3[k])=0,r(pt3[k])=0//若结7.ENDIF8.Break//继续匹配pt3的下一个结点9.ELSEi=i+1ORj=j+110.ENDIF11.ENDDO12.l=l+1Page613.ENDDOEND3.2.3应用实例已知一临床应用s1,用户doctor可查询隐私关系模式T1(p_id#,result,drug,disease,history,orders,operation),其访问控制模型如图1,描述了基于purpose的隐私数据访问控制规则,设p3=report,说明以查阅报告(purpose=report)为目的的查询,可读取患者的隐私属性{p-id,orders,result}.已知应用s2,用户manager可查询隐私关系模式T2(p_id#,ins_type,m-phone,msn,mailbox,charges)为患者提供服务,其访问控制模型如图2,如新增报告推送功能,同样以purpose=report为访问目的,可查询数据{mobile,result}.设doctor和manager分别发出查询Q1和Q2,Q1:SelectFromT1forp3;Q2:SelectFromT1forp5;基于原访问模型规则分别返回结果r1={p-id,orders,result}和r2={p-id,history}.但当s1和s2合并后,pt1、pt2的合成purpose模型pt3如图3所示,设doctor发出基于pt3的试探查询Q1:SelectFromT2forp3,返回r1={p-id,mobile}.而{mobile}是只有manager才可读取的隐私数据.同样manager再次发出基于pt3的相同查询Q2:SelectFromT1forp5,返回r2={p-id,orders,result,disease,history},而其中{orders,result,disease}不应是manager在purpose=p5下可查询到的隐私数据.可见融合后的pt3是带有隐私泄漏风险的访问控制模型,由于r(p3)=4,r(p5)=3,其余结点为0,所以需分裂结点p3、p5,需要建立如图5所示的一棵风险平衡树pt4和一组隐私路径.3.3基于风险purpose的隐私查询访问控制模型(RPPAAC)模型控制方法的主要思想是分裂每个r(pi)≠0的结点,将风险融合树分解为一棵每个节点r(pi)=0的平衡树,任何用户基于平衡树purpose的查询没有隐私数据泄漏问题.其次是存储风险路径的元数据,即风险路径purpose下可读取的隐私属性.当有一个带有purpose的查询请求时[23],先执行基于平衡树purpose的查询,得到结果r1,再以用户(或角色)为参数执行基于风险路径purpose的查询,得到结果r2,那么最终的查询结果r=r1+r2.3.3.1模型定义RPPAAC模型满足返回隐私泄漏风险最小的安全查询结果.定义5(安全查询结果,SafeResult,SR).已知pt1、pt2∈PT,分别是应用s1和s2的purpose树,pu是pt1和pt2的purpose集合,已知Jpt是融合树,Jpt=pt1∪pt2,R(DJpt)是基于Jpt树的查询结果,用户u发出基于purposepu的对数据库D的查询是Q,那么用户u基于融合树Jpt的purpose的安全查询结果满足SR∈R(DJpt)|R(DJpt)=R(Dp1)∪R(Dp2),表示用户基于融合purpose树的查询结果应与基于合并前purpose模型的查询结果一致.定义6(风险路径,PrivacyPath).已知path是Jpt的一条路径,且path∈pt1或path∈pt2,R(Dpath)是基于path的查询结果,风险路径是指所有用户u基于path查询的结果PR不是安全查询结果,即有PR≠SR.已知路径Path、路径下可访问的隐私属性集Data以及查询用户User,那么风险路径是一个三元组G(Path,Data,User).图4中G2所示的是pt2的一条风险路径p0p3p4被合并到pt1的过程,已知pt2purpose的元数据如图2所示,基于pt2的查询用户是manager,那么此风险路径模型为GG2[(p0(p3(p4))),(pid,mobile,result,msn),manager].定义7(基于风险路径purpose的隐私属性计算).已知RJpt、RBpt是融合风险模型JPT和平衡模型BPT的元数据关系模式,pt1、pt2∈PT,式(1)是风险路径上基于purpose=p可查询隐私属性的计算定义πattr(σpurpose=pRJp()t)-πattr(σpurpose=pRBp()t)(1)平衡模型BPT的隐私属性可通过式(2)获得:πattr(σpurpose=pRpt()1)∩πattr(σpurpose=pRpt()2)(2)式(2)是找出控制模型pt1和pt2重合的那些隐私属性,这些属性与查询用户无关.按照上述定义,基于purposepu的对数据库D在融合树访问控制模型下的查询是Q,那么其隐私泄漏风险最小的查询结果是在未融合pt树环境下基于purposepu对数据库D查询结果的一个子集,有R(DBPT)+R(DPath)R(Dpt).算法2和算法3Page7分别是基于风险purpose树查询算法和purpose融合访问控制算法.3.3.2算法描述算法2.基于风险purpose树查询算法.融合Purpose分解算法decomposed_purpose()//目的将风险树分解为平衡树和风险路径输入:JPT(pt3),u//具有隐私度的pt3,原pt1、pt2的输出:Tpt4,Tpath//pt3的风险平衡关系Tpt4,风险//设pt3[i]是pt3的一个结点,l是pt3的结点数BEGIN1.DOWHILE1il2.IFr(pt3[i])=0,THEN3.pt3[i],A[i]存入Tpt4[i]//结点是非隐私结点4.ENDIF5.IFr(pt3[i])≠0,THEN//分裂结点pt3[i]6.计算“式(1)”,得到AE[i],pt3[i],7.计算“式(2)”,得到AB[i],pt3[i],u[i]存入8.ENDIF9.i=i+110.ENDDOEND融合Purpose分解查询控制算法query_purpose()输入:Q,U,Tpt4,Tpath,JPT(pt3)//Q是用户U的带输出:R//基于融合purpose访问控制的查询结果BEGIN1.已知Q的查询purpose=p,A[p]是purpose=p下2.IFr(pt3[p])=0THEN//查询是基于平衡树的查询3.IFTpt4[p]=pt3[p]THEN4.R=A[p]5.ELSE6.R=null7.ENDIF8.ENDIF9.IFr(pt3[j])≠0THEN//查询是基于平衡树和风10.IFTpt4[p]=pt3[p]THENr1=AB[i]ELSE11.IFTpath[p]=pt3[p]THENr2=AE[i]ELSE12.R=r1+r213.ENDIFEND算法3.purpose融合隐私查询访问控制算法.风险purpose访问控制purpose_control(input:Q,u,pt1,pt2,A[pt1],A[pt2];output:R)//用户u的查询为Q,pt1,pt2是独立的purpose树,1.Combined_purpose(pt1,pt2)2.Joint_purpose(A[pt1],A[pt2])3.decomposed_purpose(JPT(pt3),u)4.query_purpose(Q,Tpt4,Tpath)END3.3.3应用实例图5是应用实例的融合purpose模型被分解成平衡树和隐私路径,若基于purpose=p3的查询,p3结点被分裂成p3B和p3E,其中r(p3B)=0,基于式(2),p3B的隐私属性是{result}∩{result,mobile}={result},而基于式(1),p3E的隐私属性是({p-id,orders,result,mobile}-{result})={p-id,orders,mobile},{p-id,orders}是p3由于层次关系继承了p1、p0的隐私属性.同样p5结点被分裂成p5B和p5E,其中p5B是,若不考虑结点访问的继承性质,p5E的隐私属性是{mailbox,history,disease}.按风险路径定义(定义6),风险路径的隐私属性如图6所示.再分析doctor的查询Q1和Q1,基于pt3的查询已知r(p3)≠0,所以先进行基于pt4中purpose=p3B的查询,返回r1=(result);再基于风险路径purpose=p3E的查询,返回包含继承的隐私属性r2=(p-id,orders),那么结果r=r1+r2=(p-id,result,orders),而Q1无查询结果返回,查询路径如图6实线圈,所以模型控制了由合并purpose带来的隐私数据泄漏风险.同样分析manager的查询Q2(Q2=Q2),由于purpose=p5B为,查询基于风险路径purpose=p5E,查询的结果r=(p-id,history),查询路径如图6虚线圈.从实例可见相同查询下基于新访问控制模型的查询结果等于分别基于未融合前pt1和pt2的查询结果,满足最大返回结果和最小隐私数据泄漏.若基于purpose=p1的查询,Page8因为r(p1)=0,直接在平衡树pt4查询;若基于purpose=p4查询,因为r(p4)=0且p4pt4,直接在风险路径中查询.4实验与讨论4.1实验设置实验中涉及的purpose树、元数据关系和用户的查询都基于了文章中应用实例的应用场景,实验环境是WindowsXP,AMDATHLON1640B2.71GHz,1GB内存,Sqlsever2000,T1和T2的数据记录数n=8400.本文共设置了3组实验:(1)基于不同purpose模型下相同查询所需时间的比较.本组实验比较了相同用户在基于风险purpose和基于有访问控制purpose模型环境下,运行相同查询所需要的时间,并且从返回结果来观察purpose融合访问控制机制的执行效果.(2)RPPAAC模型防止隐私数据泄漏的有效性验证.本组实验主要检验基于融合purpose访问控制机制的查询是否能防止隐私数据的泄漏,实验中的返回结果说明来自第3节的应用实例.(3)purpose融合的效率验证.本组实验的目的是为了了解purpose融合所需的时间.4.2基于不同purpose模型下相同查询所需时间的tor,发出查询Q1和Q1:比较本组实验基于如下的应用场景:(1)应用s1具有purpose树pt1,其用户是doc-Q1:SelectFromT1forp3;Q1:Select(2)应用s2具有purpose树pt2,其用户是Q2:SelectFromT1forp5FromT2forp3manager,发出查询Q2:本组实验主要比较了如下两种purpose模型下的查询执行时间:①purpose模型是按照定义1将两棵独立purpose树合并而成,如pt1、pt2合并成pt3.②融合purpose访问控制机制的purpose模型图8相同查询下用户在不同purpose模型下返回的查询结果由一棵平衡purpose树pt4和一组隐私泄漏风险路径组成(图5).本组实验中Doctor和manager的查询都是基于pt3(图3)访问规则的查询.图7是doc-tor和manager基于上述两种purpose下的查询时间比较,为清晰比较以Q+、Q1+和Q2+代表在情况②的查询,其查询时间以阴影柱状图表示.图7doctor和manager基于不同purpose下的查询时间从图7可以看出,在相同查询条件下基于融合purpose控制机制的查询(Q+,Q1+和Q2+)时间性能开要稍优于基于一般的合并purpose模型的查询(Q1、Q1和Q2),查询时间分别从3334.31ms、2613.7ms和3849.34ms减少到了3040.8ms、2585.14ms和3458.65ms.究其原因在于查询时间取决于用户查询purpose与purpose树结点匹配的时间,这与purpose树的深度有关.在情况①下purpose树深度h=4,结点数n=8;而情况②尽管分解后的平衡树深度不变,但需匹配的结点数减少到n=5.由于风险路径表示为一个关系模式,其元组数是路径上的purpose个数,数量较少,因此基于风险路径的查询时间可以忽略.实验结果符合树的查找时间是Θlg(n)的特性,所以本文提出的融合purpose访问控制机制并没有在查询时间上给应用带来更大的开销.4.3RPPAAC模型防止隐私数据泄漏的有效性验证本组实验主要检验基于融合purpose访问控制机制的查询是否能防止隐私数据的泄漏,实验中的返回结果说明来自第3节的应用实例.图8是用户发出同一查询在3种不同purpose模型下返回的查询结果.Page9doctor基于pt1的查询是指在独立应用s1中的查询,已知隐私数据mobile只有用户manager才可读取,但图8所示的返回结果显示基于情况①模型下doctor的查询有隐私泄漏风险,而基于情况②模型下doctor的查询结果等于原先独立应用下的查询结果,这说明了泄漏风险原因由不同用户的相同purpose的合并引起.同样manager在基于情况②模型下的查询结果等于原先独立应用s2下的查询结果,而情况①多返回了结果,结果{result,orders,disease}只有doctor在purpose={p3,p5}下才可读取,引起泄漏的原因在于purpose树相同结点合并后用户继承了其它用户父节点可访问的隐私数据.由此从返回查询结果看,融合purpose的访问控制机制能控制由Generalization/Specilization特性和相同purpose合并带来的潜在隐私泄漏风险.4.4purpose融合的效率验证本组实验的目的是为了了解决定purpose融合所需时间的关键因素.图9是基于图4中G1、G2和G33种合并模式下的融合时间,G1所需的时间最少,因为是路径的直接合并.G3的时间稍多于G1,尽管G1和G3合并路径上的结点数一样(n=2),但G3要对purpose=p5做合并,需要额外的匹配时间.G3模式开销的时间最长,因为被合并的路径最长.可见融合时间取决于树的深度h和被合并路径的结点数n,时间开销是O(nh).4.5本文与相关工作的不同点本文将purpose作为隐私数据的载体、将pur-pose树的路径作为隐私数据的传递通道,引入了显性隐私度和隐性隐私度的计算模型,进而评估基于一个purpose查询可能带来的隐私泄漏风险.本文讨论的是多应用环境下基于融合purpose的访问控制,尽管都是基于对purpose的匹配,但本文给出了带有隐私泄漏风险的purpose树模型和基于带有purpose隐私度查询的访问控制实现机制.5总结与展望系统内隐私数据访问规则的变化、系统间功能的整合以及分布式应用的需求等应用场景都迫切需要隐私保护数据库多purpose融合,本文率先提出了融合purpose树结点的隐私度计算模型,从而评估每个purpose结点由于融合后Generalization/Specilization关系变化所引起可访问隐私数据泄漏的风险程度.进而基于RPPAAC模型提出了风险purpose隐私查询的访问控制模型,从而返回隐私泄漏风险最小的安全查询结果.在下一步的工作中,将隐私数据属性retention、external-recipients引入隐私度计算模型,研究其对隐私数据泄漏的影响.
