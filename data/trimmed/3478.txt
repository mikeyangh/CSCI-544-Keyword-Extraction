Page1一种ρ-支配轮廓查询的高效处理算法信俊昌1)白梅1)东韩2)王国仁1)1)(东北大学信息科学与工程学院沈阳110819)2)(国家海洋信息中心天津300171)摘要近年来,作为重要的多目标决策手段的轮廓查询逐渐得到学术界的重视,相继提出了基于不同支配关系的多种轮廓变体查询.首先,通过对实际应用需求进行分析,提出了基于元组对应数值间比例值大小的ρ-支配关系的定义,进而提出了ρ-支配轮廓查询的概念.其次,对ρ-支配轮廓的基本性质进行了细致而深入的分析,在此基础上,提出了基于分支定界的ρ-支配轮廓查询算法(BranchandBoundρ-DominantSkylineAlgorithm,BBDS),避免了对R-树索引的多次访问,从而提高了ρ-支配轮廓查询的执行效率.最后,通过大量的仿真实验对ρ-支配轮廓查询的语义进行分析,并对BBDS算法的性能进行验证.实验结果表明,ρ-支配轮廓查询是轮廓查询语义的扩展和补充,而提出的BBDS算法则是求解ρ-支配轮廓查询的高效算法.关键词轮廓查询;轮廓变体;ρ-支配关系;ρ-支配轮廓;分支定界1引言作为多目标决策与数据挖掘的重要手段之一,轮廓查询[1-2]在许多实际应用中都发挥着非常重要的作用.在不同的应用场合中,“好坏”的评价标准往往也有所不同,在传统轮廓查询的基础上派生出了大量的轮廓变体查询,如多目标轮廓[3]、k-支配轮廓[4]、Top-k频率轮廓[5]和Top-k轮廓[6]等.这些轮廓变体查询极大地丰富了轮廓查询的语义,扩大了轮廓查询的应用范围.已有的轮廓变体查询中的支配关系都依赖于元组对应数值之间的大小关系,均没有考虑数值间的比例关系.然而,在一些实际应用中,数值间的大小关系不能完全说明问题,这时就需要用数值间的比例作为“好坏”关系的评价.例如,想选取一个温度和湿度都较低的地方做仓库,A地点温度20、湿度30,B地点温度18、湿度32,传统的支配不能区分地点A和B哪个更适合做仓库,而考虑数值大小关系时,发现它们的差值都为2,同样不能决定A和B哪个地方更好,这时可以考虑数值的比例关系,发现B在两维与A的比值均小于1.1,但是A在两维与B的比值不均小于1.1,所以可以判定地点B更适合作为仓库.尤其当各维度上数值的数量级不同时,这种用比例关系衡量元组间的“好坏”关系将更能说明问题.因为ρ-支配关系与已有的轮廓变体查询中的支配关系有着明显的不同,所以已有的轮廓变体查询算法都无法直接用来计算ρ-支配轮廓查询.由于ρ-支配轮廓查询在日常生活中有着非常广泛的应用,因此,亟需设计高效的算法计算ρ-支配轮廓查询以满足日益增长的实际应用需求.本文详尽地阐明了ρ-支配轮廓查询的语义,并深入地分析了ρ-支配轮廓的性质,进而提出了基于分支定界的ρ-支配轮廓查询算法BBDS.归结起来,本文的主要贡献如下:(1)提出了ρ-支配关系以及基于该支配关系的ρ-支配轮廓查询的概念;(2)深入分析了ρ-支配轮廓查询的性质,提出了基于分支定界的ρ-支配轮廓查询算法(BranchandBoundρ-DominantSkyline,BBDS);(3)设计了详细的性能评价实验,实验结果表明BBDS算法可以有效地处理ρ-支配轮廓查询.本文第2节回顾相关研究工作;第3节介绍ρ-支配轮廓查询的定义;第4节分析ρ-支配轮廓的性质,进而提出基于分支定界的ρ-支配轮廓查询处理算法BBDS;第5节介绍仿真实验结果,同时对实验结果进行分析;第6节对全文进行总结.2相关工作在传统轮廓查询的基础上,多种轮廓变体查询被相继提出.Balke和Guntzer[3]研究了基于多目标函数的多目标检索问题,提出了支持Top-k查询和轮廓查询的一般形式的多目标检索算法.Lee等人[6]研究了依据用户特定偏好来进行动态查找的个性化轮廓排序查询,提出了访问压缩存储结构的新颖算法降低存储负载.Sharifzadeh等人[7]提出了基于多个查询点距离的空间轮廓查询,利用该查询的几何性质提高空间轮廓查询的计算效率.Chan等人[4]提出了依赖于元组子维度空间上的支配关系的k-支配轮廓查询,并提出了单遍扫描、两遍扫描和顺序访问三种不同的算法计算k-支配轮廓.除k-支配轮廓之外,Chan等人[5]考虑了每个元组成为轮廓元组的子维度空间数量,提出了Top-k频率轮廓查询,同时提出了近似算法快速计算Top-k频率轮廓.Lin等人[8]提出了总体支配面积最大的k-最具代表性轮廓查询.针对k-最具代表性轮廓查询存在的问题,Tao等人[9]提出了使得非代表性轮廓点与最近代表性轮廓点之间距离最小化的基于距离的代表性轮廓查询.Papadias等人[10]提出了返回支配元组最多的k个元组的Top-k支配能力排序轮廓,并提出了基本的求解算法.接着,Yiu等人[11]提出了多种高效算法计算Top-k支配能力排序轮廓.吴俊杰等人[12]扩充Top-k支配能力排序轮廓的概念,提出了考虑权重的Top-k支配能力排序轮廓.Xia等人[13]提出了允许数值差异的ε-支配关系,进而提出了ε-轮廓的概念,并设计了多种算法计算ε-轮廓.在上述的轮廓变体查询中,文献[3]、文献[6]和文献[7]的研究内容与本文关系不大.k-支配轮廓和Top-k频率轮廓,都是通过维度特征来控制结果数目;k-最具代表性轮廓查询和Top-k支配能力排序轮廓,都是依赖数据支配面积来控制结果数目;ε-轮廓是通过增减数值来控制结果数目;而本文提出的ρ-支配轮廓是通过调整数值间的比例关系来控制结果数目.此外,Levandoski等人[14]研究了扩展现有数据库管理软件支持轮廓变体查询的框架.Zhang等Page3人[15]提出了轮廓变体查询框架将多种轮廓变体查询进行统一.然而,本文提出的ρ-支配轮廓不具备该框架要求的轮廓变体查询的有理性和传递性等性质,因而无法利用该框架计算ρ-支配轮廓.3问题描述本文中假设所有的元组在各维度上的取值都不为负,如果出现负值,需要经过预处理变成正值后再进行处理.首先,回顾一下传统支配关系和传统轮廓的相关概念[1],如定义1和2所示.定义1.元组tx支配元组ty(记为txty)当且仅当在所有维度tx都不比ty差,且在至少一个维度tx比ty好,即k,tx[k]ty[k]且l,tx[l]<ty[l].定义2.元组集合D中所有不被其它元组支配的元组构成了D的轮廓,简记为Sky(D).如图1所示,元组ta、tb和tc支配元组te,元组tc和td支配元组tf,而折线上的ta、tb、tc和td均不被其它元组所支配,共同构成了图1的传统轮廓.接着,介绍ρ-支配关系和ρ-支配轮廓的形式化定义,如定义3和4所示.定义3.元组txρ-支配元组ty(记为txρty)当且仅当在所有维度tx与ty之间的比值都不比ρ差,且在至少一维tx与ty之间的比值比ρ好.即k,tx[k]/ty[k]ρ且l,tx[l]/ty[l]<ρ.定义4.元组集合D中所有不被其它元组ρ-支配的元组构成了D的ρ-支配轮廓,简记为ρ-Sky(D).根据定义1和3可知,当ρ=1时,ρ-支配关系等价于支配关系.根据定义2和4可知,当ρ=1时,ρ-Sky(D)=Sky(D).因而可以说,传统轮廓是ρ-支配轮廓在ρ=1时的特例.图2展示了ρ=2时的ρ-支配轮廓示例.图中的方形元组代表了对应的圆形元组与原点之间连线的中点,根据定义1和3可知,当ρ=2时,被方形元组支配的元组一定被原始元组ρ-支配.图中的阴影部分表明了元组te的2-支配区域.因为元组tb在阴影部分内,所以元组te2-支配tb.同理可得,元组ta、tc和te2-支配元组tb,元组ta、tb、tc和td2-支配元组te,元组ta、tb、tc和td2-支配元组tf.因为元组ta、tc和td均不被集合中任何其它元组2-支配,所以它们共同构成了图2的ρ-支配轮廓(ρ=2).4ρ-支配轮廓查询处理本节中,首先分析ρ-支配轮廓的基本性质,然后介绍BBDS算法的具体处理过程.4.1基本性质当元组间的支配关系满足传递性条件时,相应的轮廓变体查询可以使用基于R-树的分支定界轮廓算法(BranchandBoundSkyline,BBS)求解[15].幸运地,当ρ1时,ρ-支配关系满足传递性,具体如定理1所示.定理1.设ρ1,如果3个元组tx、ty和tz满足txρty且tyρtz,那么txρtz.证明.根据定义3可知,txρtyk,tx[k]/ty[k]ρ∧l,tx[l]/ty[l]<ρ,tyρtzk,ty[k]/tz[k]ρ∧j,ty[j]/tz[j]<ρ.由于tx[k]/ty[k]ρ且ty[k]/tz[k]ρ,两端分别相乘得tx[k]/tz[k]ρ2.又因为ρ1,所以ρ2ρ.因此,k,tx[k]/tz[k]ρ.同理可证,l,tx[l]/tz[l]<ρ.根据定义3,可得txρtz.根据定理1,当ρ1时,ρ-支配轮廓可以用BBSPage4算法求解.然而,当ρ>1时,ρ-支配关系不再具备传递性,需要研究新算法计算ρ>1时的ρ-支配轮廓.在介绍ρ>1时,ρ-支配轮廓查询求解算法之前,先分析ρ-支配关系和ρ-支配轮廓的一些重要性质.引理1.设ρ>1,如果两个元组tx和ty满足txty,那么txρty.证明.根据定义1可知,txtyk,tx[k]ty[k]∧l,tx[l]<ty[l].由于tx[k]ty[k],所以tx[k]/ty[k]1.因为ρ>1,所以k,tx[k]/ty[k]ρ.同理可证,l,tx[l]/ty[l]<ρ.根据定义3,可得txρty.根据引理1可知,当ρ>1时,一个元组支配另一个元组意味着它同时也ρ-支配该元组,所以,ρ-支配轮廓是传统轮廓的子集,具体如定理2所示.定理2.设ρ>1,如果集合D中的元组tx满足tx∈ρ-Sky(D),那么tx∈Sky(D),即ρ-Sky(D)Sky(D).证明.用反证法证明.假设txSky(D),根据定义2可知,集合D中存在元组t满足ttx.又根据引理1,ttxtρtx.根据定义4,txρ-Sky(D),与已知条件相矛盾.因此,ρ-Sky(D)Sky(D).根据定理2可知,只有属于传统轮廓的元组才有可能成为ρ-支配轮廓元组,因而可以先计算元组集合的轮廓Sky(D),再对Sky(D)中的每个元组逐一判断进而得到ρ-支配轮廓,称为ρ-支配轮廓的基准算法.基准算法的具体处理过程如算法1所示.首先,初始化元组集合S和堆H(第1行);其次,将R-树中根的所有项加入H(第2行);接着,当H不为空时,取出H中的首元素e(第3~4行);如果e是中间结点,那么判断e是否被S中的元组支配.若e不被S中的任何元组支配,则将e中所有不被S中的任何元组支配的结点加入H(第5~9行);如果e是叶结点,那么同样判断e是否被S中的元组支配.若e不被S中的任何元组支配,则将e加入到集合S中(第10~12行).经过上述计算过程(第1~12行),集合S中得到了元组集合D中的轮廓.逐一取出集合S中的轮廓元组p,如果p被集合D中的任何元组ρ-支配,则将该元组从集合S中移除(第13~15行);最后,基准算法返回元组集合D的ρ-支配轮廓S.算法1.基准算法.输入:参数ρ和元组集合D的R-树索引R输出:ρ-支配轮廓ρ-Sky(D);1.ListS=;HeapH=;2.H.insertAllEntry(R.root);3.while(Hisnotempty)//遍历R-树4.e=H.removeTopEntry();//取堆中首个结点5.if(e是中间结点)//中间结点的处理6.if(e.min不被S中的任何元组支配)7.for(eachchildeiofe)8.if(ei.min不被S中的任何元组支配)9.H.insertEntry(ei);//加入堆排序10.else11.if(e不被S中的任何元组支配)12.S=S+{e};13.for(eachpointpinS)14.if(p被D中的元组ρ-支配)//基于R-树判断15.S=S-{p};16.ReturnS.基准算法需要多次访问R-树以便逐一确认每个轮廓元组是否为ρ-支配轮廓元组,无疑将消耗大量的计算时间,需要进一步优化.引理2.设ρ>1,如果3个元组tx、ty和tz满足txty且tyρtz,那么txρtz.证明.根据定义1可知,根据定义3可知,tyρtzk,ty[k]/tz[k]ρ∧j,ty[j]/tz[j]<ρ.因为ty[k]/tz[k]ρ,所以ty[k]ρ×tz[k].又因为tx[k]ty[k],所以tx[k]ρ×tz[k],两端同除以tz[k]得tx[k]/tz[k]ρ.同理可证,l,tx[l]/tz[l]<ρ.txtyk,tx[k]ty[k]∧l,tx[l]<ty[l].根据定义3,可得txρtz.根据引理2可知,除了能支配元组ty的元组tx之外,所有能被元组tyρ-支配的元组都能被元组txρ-支配.因此,只需保留最多被一个元组支配的元组,即2-轮廓带(Skyband)[10]就可以保证ρ-支配轮廓结果的正确性,如定理3所示.定义5.元组集合D中,最多被(k-1)个元组支配的元组构成了D的k层轮廓带,简记为Skyk(D).定理3.设ρ>1,ρ-Sky(D)=ρ-Sky(Sky2(D)).证明.(1)证明ρ-Sky(D)ρ-Sky(Sky2(D)).假设tρ-Sky(Sky2(D)),那么tSky2(D)或者t∈Sky2(D),tρt.如果tSky2(D),那么t∈D,满足tt,根据引理1,tρt,所以tPage5ρ-Sky(D);如果t∈Sky2(D),tρt,那么tρ-Sky(D).因此,ρ-Sky(D)ρ-Sky(Sky2(D)).(2)证明ρ-Sky(Sky2(D))ρ-Sky(D).假设tρ-Sky(D),那么根据定义4,t∈D,满足tρt.如果t∈Sky2(D),那么tρ-Sky(Sky2(D));如果tSky2(D),那么t∈D,满足t≠t且tt,根据引理2,tρt,所以tρ-Sky(Sky2(D)).因此,ρ-Sky(Sky2(D))ρ-Sky(D).综上所述,ρ-Sky(D)=ρ-Sky(Sky2(D)).证毕.根据定理3可知,所有被两个或两个以上元组支配的元组都不影响ρ-支配轮廓的计算,因此,可以在计算过程中将这样的元组(或者R-树结点)直接丢弃,以便避免不必要的比较操作,从而提高查询效率.分析2-轮廓带中的元组的特征,可以进一步得到下面的定理4.定理4.设ρ>1,如果轮廓元组t不是ρ-支配轮廓元组,那么t要么被另一个轮廓元组ρ-支配,要么被它所支配的2-轮廓带元组ρ-支配.证明.因为元组t不是ρ-支配轮廓元组,所以t∈D,满足tρt.那么t可能是轮廓元组,也可能是非轮廓的2-轮廓带元组,还可能是非2-轮廓带元组.下面分情况加以讨论.(1)如果t是轮廓元组,直接满足结论;(2)如果t是非轮廓的2-轮廓带元组,根据定义5可知,元组t要么被轮廓元组t支配,要么被非t的其它轮廓元组支配.如果元组t被轮廓元组t支配,直接满足结论.如果元组t被非t的其它轮廓元组支配,那么根据引理2可知,支配元组t的轮廓元组ρ-支配元组t,满足结论.(3)如果t是非2-轮廓带元组,根据定义5可知,至少存在一个非t的轮廓元组支配t,根据引理2可知,该轮廓元组ρ-支配元组t,满足结论.综上所述,如果轮廓元组t不是ρ-支配轮廓元组,那么t要么被另一个轮廓元组ρ-支配,要么被它所支配的2-轮廓带元组ρ-支配.根据定理4可知,如果一个轮廓元组不是ρ-支配轮廓元组,只要它不被自己所支配的2-轮廓带元组ρ-支配,那么它一定被另一个轮廓元组所ρ-支配.因此,非轮廓的2-轮廓带元组只对支配它的轮廓元组的判断有直接影响,与其它的轮廓元组的判断无关,可以在判定后直接丢弃,只需要保留所有的轮廓元组即可保证ρ-支配轮廓结果的正确性.4.2BBDS算法定理2确定了哪些元组(轮廓元组)是候选的ρ-支配轮廓元组,而定理3和定理4,确定了哪些元组对ρ-支配轮廓的计算没有影响,哪些元组影响较小.根据前面的分析,可得出基于分支定界的查询算法.基于分支定界的ρ-支配轮廓查询算法的具体处理过程如算法2所示.首先,初始化ρ-支配轮廓元组集合S、非ρ-支配轮廓元组的轮廓元组集合SS和堆H(第1行);其次,将R-树中根的所有项加入H(第2行);接着,当H不为空时,取出H中的首元素e(第3~4行);如果e是中间结点,那么判断e是否被S+SS中的两个元组支配.若e不被S+SS中的两个元组支配,则将e中所有不被S+SS中的两个元组支配的结点加入H(第5~9行);如果e是叶结点(第10行),那么首先判断e是否被S+SS中的元组支配(第11行).若e不被S+SS中的任何元组支配,则继续判断它是否被S+SS中的任何元组ρ-支配(第12行).若e不被S+SS中的任何元组ρ-支配,则将e加入到集合S中(第13行),否则,将e加入到集合SS中(第14~15行).接着,将集合S中被eρ-支配的元组移动到集合SS中(第16~17行).如果e只被S+SS中的一个元组支配,那么需要用e来判定支配它的元组是否为ρ-支配轮廓元组(第18~21行).最后,BBDS算法返回元组集合D的ρ-支配轮廓S.算法2.基于分支定界的ρ-支配轮廓查询算法.输入:参数ρ和元组集合D的R-树索引R;输出:ρ-支配轮廓ρ-Sky(D);1.ListS=;ListSS=;HeapH=;2.H.insertAllEntry(R.root);3.while(Hisnotempty)//遍历R-树4.e=H.removeTopEntry();//取堆中首个结点5.if(e是中间结点)//中间结点的处理6.if(e.min不被(S+SS)中的两个元组支配)7.for(eachchildeiofe)8.if(ei.min不被(S+SS)中的两个元组支配)9.H.insertEntry(ei);//加入堆排序10.else11.if(e不被(S+SS)中的任何元组支配)12.if(e不被(S+SS)中的任何元组ρ-支配)13.S=S+{e};//ρ-支配轮廓点14.else15.SS=SS+{e};//非ρ-支配轮廓点16.D=getRhoDominated(S,e)17.S=S-D;SS=SS+D;18.elseif(e只被(S+SS)中的一个元组支配)19.p=getDominating(S,e)20.if(p被e所ρ-支配)21.S=S-{p};SS=SS+{p};22.ReturnS.Page65实验结果与分析本节的实验中,使用VisualC++语言实现了基准算法(BA)和基于分支定界的ρ-支配轮廓查询算法(BBDS).实验环境为PentiumIV2.4GHzCPU、512MBDDR内存、80GB硬盘和WindowsXP操作系统.使用轮廓查询的标准测试数据生成器[10]分别生成独立分布、正相关分布和反相关分布的实验数据.由于独立分布与正相关的性质比较接近,因此本节的实验仅列举了各算法在独立分布和反相关分布下的性能变化规律.实验中所考察的主要参数的变化范围及默认值如表1所示.参数数据维度数据集大小/K默认值3变化范围2,3,4,5100,300,首先,考查ρ值大小对结果集大小的影响.图3中给出了数据集大小为100K、维度为3维时,ρ值大小由0.9变化到2.5时,ρ-支配轮廓大小的变化规律.从图中可以看出,无论在独立分布还是在反相关分布的数据集中,随着ρ值的不断增大,ρ-支配轮廓大小逐渐变小.这是因为ρ值的增加,意味着元组更加容易被ρ-支配,使得元组成为ρ-支配轮廓的可能性减少,ρ-支配轮廓的结果数量也随之减少.在反相关分布下,随着ρ值的增加,ρ-支配轮廓大小急剧减少,这是因为反相关分布特征导致的,当ρ值增加时,元组间被ρ-支配的概率大大提高,从而导致了ρ-支配轮廓的结果数量骤减.其次,考查ρ值大小对各个算法性能的影响.图4给出了数据集大小为100K、维度为3维时,ρ值大小由1.5变化到2.5时各算法性能的变化规律.从图中可以看出,无论在独立分布还是在反相关分布的数据集中,各算法的响应时间随着ρ值增加而影响不大.在反相关分布下,各算法的响应时间都大于独立分布下算法的响应时间.无论ρ值如何变化,在同样的数据分布下,BBDS算法的响应时间都要小于BA算法的响应时间.接着,考查维度大小对各个算法性能的影响.图5、图6中分别给出了数据集大小为100K、ρ值为1.5时,维度由2维变化到5维时,结果集的大小变化以及各算法性能的变化规律.无论在独立分布还是在反相关分布的数据集中,从图5中可以看出,返回的ρ-支配轮廓集合数量和轮廓集合数量都随着维度增加而增加,同时由图6中可见,各算法的响应时间也随着数据维度的增加而相应的增加.这是因为数据维度的增加,意味着元组间关系判别时需要计算的次数增加,同时,在数据集大小相同时,数据维度的增加还意味着元组被支配和ρ-支配的概率降低,使得元组成为轮廓和ρ-支配轮廓的可能性提高,轮廓和ρ-支配轮廓的结果数量往往也同时增加,这些都导致了ρ-支配轮廓计算时需要进行的计算次数增加.在反相关分布下,轮廓集合的数量要远Page7远大于独立分布下轮廓集的数量,从而导致了各算法在反相关分布下的响应时间远远高于对应独立分布下的响应时间.无论维度如何变化,在同样的数据分布下,BBDS算法的响应时间始终低于BA算法的响应时间.最后,考查数据集大小对各算法性能的影响.图7给出了数据维度为3、ρ值为1.5时,数据集由100K变化到900K各算法性能的变化规律.从图中可以看出,无论在独立分布还是在反相关分布的数据集中,各算法的响应时间都随着数据集的增加而相应地增加.这是因为数据集大小的增加意味着元组成为轮廓的门槛降低,算法终止前需要处理的数据量增加,因此算法的响应时间相应增加.同样,在反相关分布下,元组的被支配概率降低,使得元组成为轮廓的可能性提高,求ρ-支配轮廓时需要进行的运算次数相应增加,因而算法在反相关分布下的响应时间高于独立分布下的响应时间.同时,与数据维度的增加对算法性能的影响相比,数据集大小增加的影响要小很多,因此,在数据集增加时,算法响应时间的增速相对较慢,没有数据维度增加时变化的明显.无论数据集大小如何变化,在同样的数据分布下,BBDS算法的响应时间始终低于BA算法的响应时间.Page8综上所述,无论在独立分布,还是在反相关分布下,BBDS算法的性能始终优于BA算法,并且BBDS算法的响应时间在10s到1000s的量级,说明BBDS算法是计算ρ-支配轮廓有效算法.6结论本文对ρ-支配轮廓查询处理技术进行了深入的研究.首先,通过对实际应用需求进行分析,提出了ρ-支配关系以及基于该支配关系的ρ-支配轮廓查询的概念;接着,深入分析了ρ-支配轮廓查询的性质,提出了基于分支定界的ρ-支配轮廓查询算法(BranchandBoundρ-DominantSkyline,BBDS);最后,设计了详细的性能评价实验,实验结果表明BBDS算法可以有效地处理ρ-支配轮廓查询.BBDS算法的性能可以满足应用需求,是计算ρ-支配轮廓的有效算法.
