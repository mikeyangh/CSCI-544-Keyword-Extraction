Page1基于上下文定界的递归队列并发程序可达性分析钱俊彦1),2)贾书贵1)赵岭忠1)郭云川3)1)(桂林电子科技大学广西可信软件重点实验室广西桂林541004)2)(武汉大学软件工程国家重点实验室武汉430072)3)(中国科学院信息工程研究所北京100093)摘要基于无界FIFO消息队列的通信框架作为一种通用的并发系统模型,常用于事件驱动的并发程序或分布式程序建模.然而当模型包含递归过程调用时,即使仅考虑执行有限次上下文切换,其可达性问题仍是不可判定的.假定进程的消息队列约束为良序,即仅当进程的局部栈为空时才能从队列中读取消息,则其在上下文切换定界上的可达性为可判定.文中以基于队列通信的递归并发程序为对象,研究其可达性问题.首先构造能模拟递归队列并发程序执行的多栈下推系统,并提出转换方法;然后给出一种基于多栈下推系统的上下文切换定界可达算法,算法使用标准Post操作描述下推系统的迭代,基于良序排队控制进程对队列的出队操作,穷尽地计算k次上下文切换之内的正向可达格局,并证明了构造多栈下推系统方法和上下文切换定界可达算法的正确性;最后对目标状态集合与可达格局状态集合的交集进行判空,确定目标状态是否可达,从而较好地解决此类并发程序的可达性问题.关键词上下文定界;良序排队;可达性;递归;并发程序1引言基于消息队列通信框架作为一种通用的并发系统模型,常用于事件驱动的并发程序或基于网络通信的分布式程序的信任建模.递归队列并发程序通信框架是一种典型的基于消息队列通信的并发程序模型,其任务通常作为队列中的消息,在发布任务时,进行入队操作;执行任务时,进行出队操作.此类程序基于事件驱动可高效、及时地对外部操作进行响应,被广泛地应用于事件驱动下的应用程序,如Windows平台.为充分发挥多核体系架构的强大处理能力,并发系统往往根据实际负载情况,通过消息队列或网络通信的方式,动态地调度待处理的多个任务进行并发处理.然而,在并发处理中任何潜在的缺陷或错误可能造成系统运行异常,甚至导致崩溃.为了防止这些问题,一种有效方式是采用模型检验工具来分析此类系统安全性[1].目前,研究保障此类系统安全性的模型检验已成为当前学术界的一个研究热点和难点.模型检验队列模型(即基于消息队列通信的模型)的主要难题是无界FIFO(FirstInputFirstOutput)队列可能引起状态空间爆炸问题.一些研究人员采用基于自动机理论来分析与验证此类系统,譬如,基于有损信道通信的系统[2]、队列系统的约束模型———基于单个队列通信的系统[3]、基于特定类型消息队列通信的系统[4]、任意时刻仅单个队列运行的半双工传输系统[5]以及基于单个队列通信的多计数器系统[6]等.另外,Jhala等人[7]提出基于消息计数器限界分析异步程序的数据流.为了进一步有效地抑制状态空间爆炸,一种有效的方式是采用上下文定界的分析方法来限定上下文切换次数.实验表明:许多并发相关的错误可在极少数上下文切换执行中显现出来,故穷尽搜索有限次上下文切换执行能够高效地查找程序中隐匿的错误和漏洞[8].由于上下文定界的有效性,一些研究人员在上下文定界方面开展了许多研究,例如异步动态下推系统[9]、包含有限可见堆系统[10]及递归布尔程序[11]的上下文定界分析.然而当并发模型包含递归过程调用时,即使仅考虑执行有限次上下文切换,其可达性问题仍是不可判定的.为了使上下文切换定界可达性问题可判定,约束系统进程的消息队列为良序:即仅当进程的局部栈为空时,进程才能从队列中读取消息.Salvatore等针对并发队列系统可达性问题的研究表明:任何时刻单个递归进程执行的异步程序,若仅当进程的局部栈为空时才能读取任务时,则其可达性问题是可判定的[12-13].但Salvatore等未能提出相应的可达性求解算法.Qadeer等人[14]在2004年首次提出并发系统的上下文定界分析,并证明了在基于共享内存通信的递归布尔程序上,其上下文定界可达性问题是可判定的,同时,给出了基于该思想的KISS框架.2005年Qadeer等人[8]提出了上下文定界可达算法,然而该算法没有考虑消息队列通信,故仅适用于基于共享变量通信的并发系统,不适用于基于消息队列通信的并发递归程序的可达性分析.本文基于队列通信并发系统的可判定理论,对Qadeer等人的上下文定界可达算法进行了改进、扩展,提出一种适用于多栈下推系统上下文切换定界可达问题的判定算法,使之在计算某一个上下文的正向可达格局集合时,采用基于多栈下推系统的操作语义来处理相应的pop、push操作.该算法同时适用于基于共享变量通信的和基于消息队列通信的并发递归程序可达性求解.具体地讲,本文研究基于FIFO队列通信的有限状态递归程序的可达性问题.方法如下:给定一个递归队列并发程序,首先,构造模拟递归队列并发程序执行的多栈下推系统,将其上下文切换定界可达性问题转换为多栈下推系统的阶定界可达性问题(k上下文切换对应于3k+1个阶).其次,基于上下文定界思想和良序排队约束,提出一种针对多栈下推Page3系统的上下文定界可达算法来作为求解递归队列并发程序可达性问题的算法基础.该算法使用标准Post操作描述每个下推系统的迭代过程,基于良序排队定义控制进程对队列的出队操作,通过下文切换函数实现上下文的切换,穷尽地计算k次上下文切换内正向可达的格局.最后对目标状态集合与可达格局状态集合的交集进行判空,从而较好解决此类递归队列并发程序的可达性问题.在此基础上,对上下文切换可达算法的适用性加以扩展,通过局部性质的可达性求解,然后使用组合方法对系统待验证的整体性质进行验证,减少单次可达性求解的时间和空间代价,使得能处理更为复杂的问题.本文第2节是队列系统的基础定义,并简要介绍下推系统和多栈下推系统;第3节给出构造可模拟良序排队的递归程序执行的多栈下推系统的转换方法;第4节提出一种针对多栈下推系统的上下文切换定界可达算法,该算法可穷尽地计算多栈下推系统在k次上下文切换内正向可达的格局集合,为解决递归队列并发程序的(状态)可达性问题提供了算法基础;第5节给出基于局部性质可达性求解的组合验证思想;第6节举例说明算法步骤,并对可能的求解结果进行分析;第7节总结全文并指出进一步的研究工作.2队列系统与下推系统本节简要介绍基于无界FIFO队列和共享内存通信的并发系统,以及下推系统和多栈下推系统.此类并发系统含有限个进程,进程之间通过共享内存和消息队列进行通信.进程状态由状态格局进行描述,包括进程的控制位置、局部变量及进程所访问共享内存的赋值.每个消息队列具有唯一的发送进程和接收进程,其字母表是有限的,但存储的消息数目是无界的.定义1.体系结构.一个体系结构是一个四元组(P,Q,Sender,Receiver),其中P是有限进程集合,Q是有限队列集合,Sender:Q→P和Receiver:Q→P是两个指派函数,分别为每个队列q∈Q指派唯一的发送进程和接收进程,并规定每个队列的发送进程和接收进程是不同的:即对于q∈Q,Sender(q)≠Receiver(q).文中使用p、p、pi等符号表示集合P中的进Sender(q)=p.Receiver(q)=p.程,使用q、q等符号表示集合Q中的队列.2.1基于队列通信的递归程序假定Π表示有限的消息字母表,A=(P,Q,Sender,Receiver)是一个体系结构,则进程p∈P的动作的形式如下:(1)p:send(q,m),其中m∈Π,q∈Q,且(2)p:recv(q,m),其中m∈Π,q∈Q,且(3)p:int,或者p:call或者p:ret.其中动作p:send(q,m)表示进程p向队列q中写入消息m(队列q被预先定义为进程p的接收队列);p:recv(q,m)表示进程p从队列q中读取消息m;p:int表示进程p的不处理队列的内部动作;p:call和p:ret为栈动作,p:call相当于进程p的局部过程调用,进程p将调用地址、局部变量的赋值等数据存储到局部栈的栈顶,并迁移到新状态;p:ret相当于进程p中过程调用的返回,弹出局部栈的内容并迁移到新状态,该新状态取决于进程p的当前状态和从栈中读取的数据.假定Actp表示进程p的动作集合,Act=∪p∈PActp表示P中所有进程的动作集合.Calls表示调用动作的集合{p:call|p∈P},Rets表示返回动作的集合{p:ret|p∈P}.定义2.递归队列并发程序[13].给定一个体系结构A=(P,Q,Sender,Receiver),其上的递归队列并发程序是一个五元组R=(S,s0,Π,Γ,{Tp}p∈P),其中S是有限的状态集合,s0∈S是初始状态,Π是有限的消息字母表,Γ是有限的栈字母表,Tp是进程p的迁移关系集合.假定Actp是进程p在消息字母表Π上的动作集合,则迁移关系集合Tp形式如下:Tp(S×(Actp\{p:call,p:ret})×S)∪给定递归队列并发程序R,其格局为一个三元组(s,{σp}p∈P,{μq}q∈Q),其中s∈S是状态;对于进程p∈P,σp∈Γ是进程p的局部栈内容,进程p的栈顶内容位于σp的最左端,栈底内容位于σp的最右端;对于队列q∈Q,μq∈Π是队列q的内容,队列q的队尾消息位于μq的最左端,队头消息位于μq的最右端.格局之间的迁移关系操作语义如图1所示.Page4给定递归队列并发程序R=(S,s0,Π,Γ,图1递归队列并发程序R的操作语义{Tp}p∈P),其运行是一个迁移序列:c0actn→-1cn-1··=ε}q∈Q)表示初始格局,栈σp和队列μq的初始{μq化都为空,状态格局cn=(s^,{σp}p∈P,{μq}q∈Q)为可达状态格局,蕴含状态s^是可达的.基于队列通信的递归程序的可达性问题描述为:给定递归队列并发程序R和目标状态集合TS,确定R经过某次运行,状态s^∈T是否可达.2.2上下文切换定界队列系统的上下文定义为:对于进程,任意长度的连续执行操作,进程仅可从一个队列中读取消息,但可向所有输出消息队列写入消息.其上下文定界的可达性问题可描述为:经过有限次上下文切换的运行,某个状态格局(或全局状态)是否可达.基于上下文定界的方法能获得良好的状态空间覆盖度[15],并能高效地搜索进程间的交错.由于队列系统的可达性问题通常是不可判定的,故基于上下文切换定界研究队列系统可达性问题显得尤为重要.假定进程至多可从一个队列q中读取消息,但可向所有的输出队列写入消息,则队列系统的上下文描述可为单个进程的连续执行序列.给定满足条件Receiver(q)=p的进程p和队列q,令Actp,q={p:int,p:call,p:ret}∪{p:send(q,m)|q∈Q,Sender(q)=p,m∈Π}∪{p:recv(q,m)|m∈Π}(Actp,q表示进程p从队列q中读取消息的动作集合),如果集合{i|acti∈Actp,q,acti+1Actp,q,p∈P,q∈Q}的基数至多是k∈,则运行c0c2…actn→-1cn-1递归队列并发程序的上下文切换定界可达性问题描述为:给定递归队列并发程序R,目标状态集合T和正整数k∈,确定经过至多k次上下文切换的运行,T中目标状态是否可达.2.3良序排队递归队列并发程序是良序排队的,当且仅当进程p∈P的局部栈为空时,才可从对应的消息队列中读取消息.也就是说,良序排队的递归队列并发程序不存在如下形式的运行:c0act→ncn,其中cn-1=(s,{σp}p∈P,{μq}q∈Q),cn-1actn-1=p:recv(q,m),且σp≠ε,即进程的局部栈不为空时,不能执行动作p:recv(q,m).由于进程处理任务时,直至执行结束时才处理下一个任务,中途不允许被中断[16],故良序排队的约束是适当的.2.4下推系统定义3.下推系统.一个下推系统是一个三元组=(G,Γ,Δ),其中G是全局状态集合(全局状态包括进程的控制位置、局部变量以及进程所访问的共享内存赋值),Γ是栈字母表,Δ(G×Γ)×(G×Γ)是有限的迁移关系集合.下推系统的格局c是一个元组〈g,w〉,其中g∈G是全局状态,w∈Γ是包含空串ε的有限字符串.格局之间的迁移系统→Δ定义如下:对于所有w∈Γ,〈g,γw〉→Δ〈g,ww〉成立,当且仅当(〈g,γ〉,〈g,w〉)∈Δ,符号→Δ表示→Δ的自反传递闭包.迁移关系Δ包含如下3种下推规则:(1)〈g,γ〉→〈g,γ1γ〉描述栈的pop操作,该规则描述某个函数调用或者递归过程调用,即将调用函数的地址和局部变量的值(使用符号γ1表示)存储到栈顶.Page5(2)〈g,γ〉→〈g,ε〉描述栈的push操作,该规则描述函数调用返回,即调用的函数或过程执行结束时,从栈顶弹出被调用函数的地址及其局部变量赋值,返回后继续执行,如果被调用函数具有返回值,则使用某个新定义的变量将此返回值传递给调用进程的全局状态.(3)〈g,γ〉→〈g,γ〉描述递归过程调用和函数返回之外的简单操作,例如赋值语句,即仅改变全局状态,当前栈内容保持不变.定义4.自动机[17].给定下推系统=(G,Γ,Δ),则对应于下推系统的自动机A=(Q,Γ,δ,I,F)是一个有限状态自动机,其中QG是一个有限状态集合,Γ是下推系统的字母表,δQ×{Γ,ε}×Q是迁移关系,IQ是初始状态,FQ是终止状态.下推系统接受格局〈g,w〉,当且仅当存在终止状态q∈F,使得自动机A满足:g→wq.下推系统的格局集合是正则的,当且仅当存在某个自动机接受该格局集合.给定初始格局为〈gin,win〉的下推系统和格局集合SG×Γ,使用PostΔ(S)表示格局集合S的所有正向可达的格局集合,即PostΔ(S)={c|c∈S.c→Δc},可知从正则格局集合通过正向可达获得的格局集合也是正则的.如果下推系统正向可达的格局集合是正则的,那么其可达性问题是可判定的[17-18].假定是一个下推系统,A是一个正则的下推自动机,自动机A接受的格局集合是L(A),则存在一个满足如下条件的正则下推自动机A:PostΔ(L(A))=L(A).此外,根据下推系统和下推自动机A可构造自动机A,其时间复杂度与和A的大小呈多项式关系[19].2.5多栈下推系统多栈下推系统是标准下推系统的一种自然扩展,系统中包含多个栈结构.形式上,多栈下推系统(MultiStackPushdownSystems,MSPS)是一个元组=(S,s0,St,Γ,Δ),其中S是有限状态集合,s0∈S是初始状态,St是有限的栈集合,Γ是栈字母表,Δ=Δint∪Δpush∪Δpop是迁移关系,其中ΔintS×S,ΔpushS×St×Γ×S,并且ΔpopS×St×Γ×S.多栈下推系统的格局c是一个元组〈s,{σst}st∈St〉,其中s∈S是的当前状态,包括全局变量的赋值和程序的控制位置,对于任意栈st∈St,σst∈Γ表示栈st的内容,同时假定栈顶的符号位于栈内容σst的最左端.的初始格局是〈s0,{σst}st∈St〉,对于任意栈st∈St,每个栈初始化都为空,即σst=ε.可通过格局之间的迁移关系Δ得出的操作语义,如图2所示,格局间的迁移关系Δ记作〈s,{σst}st∈St〉→δ〈s,{σst}st∈St〉.下文如不做特别说明,则对于每个st∈St,σst=σst成立.δ=(s,s)∈Δint〈s,{σst}st∈St〉→δ〈s,{σst}st∈St〉〈s,{σst}st∈(St\{st})∪{σst}〉→δ〈s,{σst}st∈(St\{st})∪{a.σst}〉[Push]〈s,{σst}st∈(St\{st})∪{a.σst}〉→δ〈s,{σst}st∈(St\{st})∪{σst}〉[Pop]多栈下推系统的运行是一个迁移序列c0δ→2c2…δ→ncn,如果c0是的初始格局,且cn=c1〈s^,{σst}st∈St〉,则状态s^∈S是可达的.定义5.阶段.运行的一个阶段(简称为阶)是运行中对同一个栈执行pop操作的执行序列.对于正整数k∈,一个k-阶的运行至多包含k个阶段.如果可将序列δ1…δn划分为某个新序列α1…αk,且该序列满足如下条件:对于每个i=1,…,k,存在某个栈st∈St,使得序列αi包含的所有规则δ∈Δpop都形如(s,st,a,s),则多栈下推系统的运行c0δ→2c2…δ→ncn是k-阶的.c1因此,在一个k-阶的运行中,执行pop操作的栈至多切换k-1次(阶-切换).如果经过一个k-阶的运行可到达某个状态,则该状态是k-阶可达的.阶定界可达性问题描述为:给定多栈下推系统M,目标状态集合T和正整数k∈,确定经过k-阶的运行,T中的某个状态是否到达.多栈下推系统的阶定界可达性问题是可判定的,其时间复杂度与状态数目呈指数关系,与阶的数目呈双指数关系[11].3递归程序转换为多栈下推系统本节给出一种递归队列程序到多栈下推系统的转换方法,基于该转换方法可构造模拟良序排队的递归队列并发程序执行的多栈下推系统,并将基于良序排队的递归队列并发程序的上下文切换定界可达性问题转换为多栈下推系统的阶定界Page6可达性问题.给定递归队列并发程序R=(S,s0,Π,Γ,{Tp}p∈P),可构造多栈下推系统=(S,s0,St,ΓM,Δ)来模拟良序排队的递归队列并发程序R的k-上下文切换定界执行,其中S是有限的状态集合;s0∈S是初始状态;St={stw∪{stp}p∈P∪{stq}q∈Q}是栈集合,其中stw是工作栈,stp是每个进程p∈P对应的局部栈,stq是每个队列q∈Q对应的栈,各个栈初始化为空;ΓM=Π∪Γ是字母表,其中Π是队列对应的栈字母表,Γ是进程对应的局部栈的字母表;迁移关系Δ=Δint∪Δpop∪Δpush,如图3所示,描述了在上下文(p^,q^)内,进程p^可执行的迁移关系转换为多栈下推系统的迁移关系.(s,p^:int,s)∈Tp^(s,p^:int,s)∈Δint(s,p^:send(q,m),s)∈Tp^Sender(q)=p^(s,p^:call,s,γ)∈Tp^(s,p^:call,s,γ)∈Δpush(s,p^:recv(q^,m),s)∈Tp^Receiver(q^)=p^(s,p^:ret,γ,s)∈Tp^(s,p^:ret,γ,s)∈Δpop图3多栈下推系统迁移关系集合Δ的操作语义假定递归队列并发程序R的进程p^的迁移关系集合是Tp^,多栈下推系统的迁移关系集合是Δ=Δint∪Δpush∪Δpop.规则[internal]将p^可执行的内部迁移关系添加到多栈下推系统的内部迁移集合Δint;规则[pushq]和[popq]分别将p^可执行的队列操作相关的迁移关系[Send]和[Receive]添加到Δpush和Δpop;规则[pushp]和[popp]分别将p^可执行的栈操作相关的迁移关系[Call]和[Return]添加到Δpush和Δpop.其中规则[internal]定义进程p^的内部迁移关系集合;规则[pushp]和[popp]构造进程p^的栈操作相关的迁移关系集合;规则[pushq]和[popq]构造进程p^的队列操作相关的迁移关系集合.定理1.给定递归队列并发程序R=(S,s0,Π,Γ,{Tp}p∈P),基于良序排队的情况下,根据上述转换方法构造多栈下推系统=(S,s0,St,ΓM,Δ),能正确模拟递归队列并发程序R的执行.证明.由于递归队列并发程序各个进程的执行的操作取决于接收到的消息,因此正确构造多栈下推系统的关键在于如何保证多栈下推系统正确地模拟递归队列并发程序中各个进程之间通信过程.假设良序排队的递归队列并发程序R中包含进程p,及进程p接收消息的队列q,队列q内的消息序列为m1m2m3…mi(i是正整数,m1是q头部的消息,mi是q尾部的消息),进程p从队列q的头部读取消息,并根据接收到的消息执行相应的操作,进程p的局部栈内容为s1s2s3…sj(j是正整数,s1是局部栈顶部的内容,sj是局部栈底部的内容),进程p从栈中读取内容执行栈相关操作.基于上述假设,构造多栈下推系统的栈stw模拟进程p读取队列q中消息m1m2m3…mi以及读取局部栈内容s1s2s3…sj的过程,由于栈和队列的操作次序是完全相反的,即栈中的内容是先进后出的,队列中的内容是先进先出的.因此,模拟队列的操作次序,需要将队列q中的消息逆序地进行存储,也就是队列的内容必须逆序地存储在栈stw,即栈的底部存储队列尾部的内容.当队列q中的内容m1m2m3…mi在栈stw的存储次序为mi…m3m2m1(mi位于栈stw的底部)时,能正确地模拟递归队列并发程序基于消息队列q的通信过程.其次,上述构造方法通过将局部栈的内容s1s2s3…sj存储在stw中的队列消息m1m2m3…mi之上,保证从stw中读取内容时,首先读取局部栈相关的内容s1s2s3…sj,当局部栈内容完全被读取之后,才能读取栈stw存储的队列q的消息mi…m3m2m1,进而保证多栈下推系统模拟的递归队列并发程序R是良序排队的.由于递归队列并发程序各个进程执行的操作取决于基于消息队列传递的消息,因此可根据递归队列并发程序针对不同队列的迁移关系的操作语义,构造出多栈下推系统相应栈的迁移关系集合的操作语义.命题1.给定递归队列并发程序R,通过构造所得对应的多栈下推系统,则R的k-上下文切换定界可达问题等价于的3k+1-阶定界可达问题.证明.假定当前上下文是(p^,q^),对递归队列并发程序R中的每个进程p∈{P\p^},使用栈stp逆序地存储进程p的局部栈内容,使用栈stq存储每个队列q∈{Q\q^}的内容:队尾指向的内容存储在栈顶,队头指向的内容存储在栈底,栈stp^和栈stq^初始化为空;工作栈stw被划分为顶部和底部两个部分,分别存储上下文(p^,q^)中进程p^的局部栈内容和队Page7列q^的栈内容:栈stw的顶部存储进程p^的局部栈内容,栈stw的底部存储队列q^的栈内容,即队列q^的栈内容存储在stw的底部,进程p^的局部栈内容存储在stw的顶部.多栈下推系统的内部动作模拟R的内部动作;向队列q∈{Q\q^}中写入消息m,即对栈stq执行入栈操作,将符号m写入栈顶;工作栈stw的入栈和出栈操作分别模拟递归过程的调用和返回.当进程p^从队列q^对应的栈中读取消息时,根据良序排队的定义,仅当进程p^的局部栈为空时,从队列q^中读取的消息恰好位于工作栈stw的顶部,将stw顶部存储的消息弹出.在一个上下文内,模拟R执行的多栈下推系统不发生阶切换.当上下文(p^,q^)切换为上下文(p^,q^)时,对工作栈stw的顶部内容和底部内容进行出栈操作,分别存储到栈stp^和stq^中;然后对栈stq^和栈stp^的内容进行出栈操作,分别存储到栈stw的底部和顶部,其上下文切换函数如图4所示.Context_switch((p,q),(p,q)){Inverse_Move(stw,(stp,stq));Move((stp,stq),stw);}//上下文(pi,qi)到(pi,qi)的切换Move((stp,stq),stw){pop(stq);push(stbottom,stq);pop(stp);push(sttop,stp);}//将上下文(p,q)对应的栈内容弹出并存储到stwInverse_Move(stw,(stp,stq)){pop(sttop);push(stp,sttop);pop(stbottom);push(stq,stbottom);}//将stw中的顶部和底部内容弹出并存储到stp和stq基于上述转换方法,基于良序排队的递归队列并发程序的k上下文切换定界可达性问题被转换为多栈下推系统的3k+1阶定界可达性问题,其中k+1个上下文对应k+1个阶,进行k次上下文切换相当于增加额外2k个阶.4上下文切换定界可达性问题本节基于良序排队的递归队列并发程序可判定理论,通过改进Qadeer等的可达算法,提出一种针对多栈下推系统上下文切换定界可达判定算法,如算法1所示.算法对每个下推系统迭代应用标准Post算法,基于良序排队约束控制进程对队列的出队操作,通过上下文切换函数实现上下文间的切换,穷尽地计算多栈下推系统在k次上下文切换内的正向可达格局.算法1.上下文切换定界可达判定算法.输入:多栈下推系统=(S,s0,St,Γ,Δ)和正整数k输出:可达格局集合Reach1.Letcin=〈s0,{σst}st∈St〉;//各个栈初始化为空2.WL··={(〈s0,{σst}st∈St〉,0)};//WL存储待计算的3.Reach··={〈s0,{σst}st∈St〉};//初始化时Reach包4.move〈σp,σq〉intostw;//初始上下文(p,q)对应的5.whileWL≠do//WL非空,继续;否则,输出Reach6.remove(〈s0,{σst}st∈St〉,i)fromWL;7.ifi<kthen//i<k,继续;否则,重新取一个格局项8.forall(q∈QSender(q)==p)9.Ap=Post(Ap);//计算进程p的初始格局10.ifa.δ=(s,stq,a,s)∈Δpush〈s,σp〉∈L(Ap)11.σq··=aσq;L(Ap)=L(Ap)∪{〈s,σp〉};12.ifa.δ=(s,stq,a,s)∈Δpop〈s,ε〉∈L(Ap)13.σq··=σq\a;L(Ap)=L(Ap)∪{〈s,ε〉};14.foralls∈S(Ap)do{15.x··=〈s,update(Ap,s),rename(Ap∈{P\p},16.Insert(x,i+1)intoWL;//将格局项(x,i+17.Reach··=Reach∪{x};//将格局x添加到可18.Context_switch((p,q),(Receiver(q),q));19.}算法的输入是多栈下推系统和正整数k,正整数k限定上下文切换的次数.算法的输出是可达格局集合Reach,该集合存储在至多k次上下文切换执行内正向可达的格局.多栈下推系统的初始格局是cin=〈s0,{σst}st∈St〉,即每个栈st∈St的内容σst为空.WL是工作列表,记录可达格局c及其上下文切换的次数i,其中0i<k,(c,i)称为一个格局项.初始化时,可达格局集合Reach只包含多栈下推系统的初始格局〈s0,{σst}st∈St〉.假定最初的上下文是(p,q),则将队列q和进程p对应的栈内容依次存储到工作栈stw的底部和顶Page8部.若工作列表WL不为空,计算WL的每个格局的可达格局;否则,输出可达格局集合Reach.算法第6行remove操作表示从WL中删除一个格局项(c,i),并返回此格局项的值.对于每个格局项,若其上下文切换的次数i<k,根据接受初始格局cin的下推自动机Ap(即L(Ap)={cin})和迁移关系集合Δp,使用Post算法构造接受初始格局可达的格局集合的下推自动机Ap,即L(Ap)=Post(L(Ap)).若下推系统的迁移关系集合存在迁移关系δ=(s,stq,a,s)∈Δpush,且下推自动机Ap接受格局〈s,σp〉,则向栈stq中入栈消息a,并将格局〈s,σp〉添加到L(Ap).若下推自动机Ap接受形如〈s,ε〉的格局,且存在字母a使得δ=(s,stq,a,s)∈Δpop,则从工作栈stw出栈消息a,并将格局〈s,ε〉添加到L(Ap).S(Ap)={s|σp.〈s,σp〉∈Post(L(Ap))}是下推自动机Ap的状态集合,多栈下推系统至多包含一个下推自动机Ap∈P的初始状态是s.如果下推自动机Ap∈{P\p}的初始状态与状态s相同,使用rename(Ap∈{P\p},s)修改Ap∈{\p}的初始状态为s.update(Ap,s)重命名Ap中除s之外的其他状态,并更新S不包含的状态.最后将修改后的可达格局赋值为x,将格局项(x,i+1)添加到工作列表WL,并将格局x添加到集合Reach.该算法通过图4所示的Context_switch()函数进行上下文的切换.对于每个下推系统的下推自动机Ap∈迭代地应用Post算法,从而穷尽地计算多栈下推系统的正向可达的格局.对于多栈下推系统=(S,s0,St,Γ,Δ)和正整数k,该算法是可终止的,并且该算法的时间复杂度为O(k3(|St||S||Δpush+Δpop|)2k|M|5),其中k是上下文切换次数,|St|是多栈下推系统中栈的个数,|S|是多栈下推系统的状态集合的大小,|Δpush+Δpop|是队列栈相关的迁移关系的个数,|M|是多栈下推系统的大小.定理2.给定多栈下推系统=(S,s0,St,Γ,Δ)和正整数k,k次上下文切换可达算法是可终止的,并能正确求解多栈下推系统的可达性问题.证明.假设Count(i)表示第16行Insert操作被调用的次数,i是下表参数.显然,Count(0)=1,且Count(i+1)=|Sender(q)|×|S|×Count(i),由于第8行和第14行分别限定了Sender(q)和S的大小.因此,对于任意的i,Count(i+1)(|Sender(q)|×|S|)i成立.由此可得算法第16行的Insert语句只可能执行有限次.此外,每次迭代第5行的while循环时将从工作列表WL中删除一个项,则工作列表最终将为空,因此,该算法是可终止的.工作列表WL的格局项〈s,{σst}st∈St〉表示多栈下推系统的格局,其中各个栈st∈St对应的下推自动机接收的字符串为σst,〈s,{σst}st∈St〉k〈s,{σst}st∈St〉表示格局〈s,{σst}st∈St〉是多栈下推系统经过k次上下文切换可到达的,算法的第9行可正确地计算从初始格局项可达的下推自动机接受的语言,算法的第10~15行通过对队列消息操作进行处理,修改相应下推自动机的格局项,第16行将修改后的可达格局添加到可达格局集合Reach.算法迭代调用Post算法计算各个下推自动机接受的语言L(Ap),即多栈下推系统在k次上下文切换内的可达的格局集合Reach.5基于局部性质求解的组合验证为了缩减单次可达求解的搜索状态空间,进一步提高处理复杂程度的问题,增强算法的适用性,可先对局部性质进行可达分析,在此基础上通过组合验证来检验整体性质,本节仅阐述基于局部性质求解的组合验证基本思想.给定并发系统待验证的整体性质,根据其所包含各个局部性质的逻辑组合关系,依次验证各个局部性质,最后通过局部性质可达求解组合验证整体性质是否满足,具体步骤包括:(1)整体性质合取范式表示基于整体性质所包含各个局部性质的逻辑组合关系,将整体性质转换为各个局部性质组成的合取范式.例如系统的待验证性质表示为合取范式F=f1∧f2∧…∧fi(其中i<N,N表示系统中进程或线程的数目),其中F是系统的整体性质对应的逻辑公式(或全局性质),fi(i<N)表示局部性质对应的逻辑公式,可以是一个或多个进程或线程的性质,各个局部性质是不相交的.(2)局部性质可达求解依次调用本文提出的可达求解算法,搜索局部性质fi对应的状态空间,记录所有符合局部性质fi的路径信息和局部性质涉及进程的状态信息,随后选取符合局部性质的状态信息,进行下一次局部性质可达性求解.(3)局部性质的组合根据上一步得到的各个局部性质可达求解的结Page9果,判定符合各个局部性质的执行路径是否满足整体性质.6实例分析本节给出一个基于队列通信的递归并发程序的实例R,详细阐述如何根据本文提出的方法将其转换为可模拟其执行的多栈下推系统,随后根据上下文定界可达算法求解其可达格局集合,最后通过判定目标状态(或者格局)与可达格局集合的判空操作,确定目标状态(或者格局)的可达性.6.1实例描述假定A=(P,Q,Sender,Receiver)是一个体系图5良序排队的实例程序R图6程序R的流图6.2转换为多栈下推系统根据3.3节的转换方法可构造出多栈下推系统=(S,s0,St,Γ,Δ),其中S是递归队列并发程序的有限状态集合;s0=(l)是初始状态,并且l∈{T,F};St={stp}p∈P∪{stq}q∈Q是栈集合,其中P=结构,其中进程集合P={p0,p1,p2},队列集合Q={q0,q1,q2}.函数Sender和Receiver定义如下:Sender(q1)=p0,Sender(q2)=p0,Receiver(q0)=p0,Receiver(q1)=p1,Receiver(q2)=p2.假定R为定义在体系结构A上的递归队列并发程序(S,s0,Π,Γ,{Tp}p∈P),如图5所示,其流图见图6所示.其中l是预先定义的全局共享变量,程序包含3个事件,分别使用字母a,b,c表示,进程p0,p1和p2的动作集合定义如下:Act0={recv(q0,a),send(q1,b),send(q2,c),Act1={recv(q1,b),callg(n),e2··=dequeue(q1),Act2={recv(q2,c),e3··=dequeue(q2),return}.callf(5),e1··=dequeue(q0),x··=f(5),return};m··=g(n),return};}{p0,p1,p2},Q={q0,q1,q2};Γ=Π∪Γ是有限的字母表,其中Π={a,b,c},Γ是进程对应的局部栈的字母表;迁移规则Δ=Δint∪Δpop∪Δpush.程序R对应的下推迁移规则如图7所示.Page10(9)〈(l),(p1_1,e2,m,n)〉→〈(l),(g_0,n)(p1_1,e2,0,0)〉l∈{T,F};m,n∈N;e2∈{a,b,c}(11)〈(l),(p1_2,e2,m,n)〉→〈(l),(dequeue_0,q1)(p1_2,e2,m,n)〉l∈{T,F};m,n∈N;e2∈{a,b,c};图7程序R对应的下推规则6.3计算可达格局集合多栈下推系统的格局是一个元组c=(s,σst∈St),其中s是全局变量的赋值,对于每个进程的栈stp∈St,σst=(C,L),其中C是程序的控制位置,L是局部变量的赋值;对于每个队列对应的栈stq∈St,栈内容σst∈Π;假定全局初始格局s0=((l),σst∈St),即当前全局变量的值是l∈{T,F},其他下推系统对应的栈内容为空.假定初始化时上下文是(p0,q0),多栈下推系统在一次上下文切换内正向可达的格局集合为Reach(1)=Reach((p0,q0))∪Reach((p0,q0)→执行上下文表1可达格局集合犚犲犪犮犺〈(l),ε,ε,ε,a,ε,ε〉;〈(l),(p0_0,⊥,⊥),ε,ε,a,ε,ε〉;〈(l),(f_0,5)(p0_1,⊥,⊥),ε,ε,a,ε,ε〉〈(l,6),(f_0,4)(f_0,5)(p0_1,⊥,⊥),ε,ε,a,ε,ε〉;〈(l,24),(f_0,5)(p0_1,⊥,⊥),ε,ε,a,ε,ε〉〈(l),(enqueue_0,q1,b)(p0_3,a,120),ε,ε,ε,ε,ε〉;〈(l),(p0_3,a,120),ε,ε,ε,b,ε〉〈(l),(enqueue_0,q2,c)(p0_4,a,120),ε,ε,ε,b,ε〉;〈(l),(p0_4,a,120),ε,ε,ε,b,c〉(p0,q0)→(p1,q1)〈(l),(ε,a,120),(p1_0,⊥,⊥,⊥),ε,ε,b,c〉;〈(l),(ε,a,120),(p1_1,⊥,0,0),ε,ε,b,c〉〈(l),(ε,a,120),(g_0,0)(p1_2,0,0),ε,ε,b,c〉;〈(l),(ε,a,120),(p1_2,⊥,1,0),ε,ε,b,c〉(p0,q0)→(p2,q2)〈(l),(ε,a,120),ε,(p2_0,⊥),ε,b,c〉;〈(l),(ε,a,120),ε,(dequeue_0,q2)(p2_1,⊥),ε,b,c〉(p1,q1))∪Reach((p0,q0)→(p2,q2)),其中Reach((p0,q0))是上下文(p0,q0)执行的正向可达格局集合,Reach((p0,q0)→(p1,q1))是上下文(p0,q0)切换到(p1,q1)执行的正向可达格局集合,Reach((p0,q0)→(p2,q2))是上下文(p0,q0)到(p2,q2)切换执行的正向可达格局集合.其中全局共享变量l的赋值为0或者1,符号“⊥”表示变量尚未赋值,符号“ε”表示进程或者队列对应的栈内容为空,或者当前进程的控制位置的值为空(执行结束返回).图5中实例通过计算获得可达格局集合Reach如表1所示.可达格局集合ReachPage116.4可达性判定分析根据正向可达格局集合Reach(k)和给定的目标状态集合S(错误状态集合),进而计算集合Reach和集合T={〈s,σst〉|st∈St.σstΓMs∈S}的交集是否为空:(1)若Reach∩T非空,可断定经过k次上下文切换的运行,某个目标状态s∈S是可达的.则存在一个起始于初始格局的执行路径能够到达该错误状态,进而根据进程在各个状态的局部栈的内容和消息队列的内容,尝试查找产生错误的原因.(2)若Reach∩T为空,则经过k次上下文切换的运行,目标状态s∈S是不可达的.状态s不可达的判断步骤如下:①经过k次上下文切换的运行,搜索的状态空间覆盖度不足以覆盖目标状态,此时可以增大k的值并继续求解,直至耗尽所有可用的计算资源.②若使用①中的方法目标状态仍是不可达的,则得出结论:在现有计算能力下目标状态是不可能出现的,即错误状态不可能出现.7结论随着并发和分布式系统的广泛应用,并发程序的安全性问题面临着严峻挑战.由于并发程序中存在不确定的进程交错,故需通过穷尽地进行可达性分析才能确保并发程序的安全性.并发程序广泛采用基于事件驱动的编程模式,进程间通过共享内存和消息队列进行通信,然而其可达性问题是不可判定的.另外,并发程序引入递归调用后进一步加剧了状态空间爆炸,从而难以通过传统可达性分析确保此类并发程序的安全性.在上下文切换定界和良序排队约束下,递归队列并发程序的可达性问题则为可判定的.本文提出一种基于多栈下推系统的上下文切换定界可达算法,该算法可作为求解递归队列并发程序可达性问题的算法基础.以后将关注于以下方面的工作:(1)是否可以采用On-the-fly技术进行可达性分析?即在构造状态空间的过程中,实时地判定待验证的状态(或者格局)的可达性,避免搜索程序实际运行中不可达的状态空间,减少不必要的存储空间的浪费;(2)给定两个非初始状态(或者非初始格局)集合,是否可以结合正向分析与逆向分析进行可达性问题求解?(3)进一步研究基于局部性质可达性求解的组合验证,增强算法的适用性;(4)开发原型系统.
