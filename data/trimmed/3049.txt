Page1基于否证蕴含的极小一阶不可满足子式求解算法张建民沈胜宇李思昆(国防科学技术大学计算机学院长沙410073)摘要解释公式不可满足的原因在软件分析与验证等众多领域都具有非常重要的理论与应用价值,而极小不可满足子公式能够为公式不可满足的原因提供精炼的解释,帮助应用领域的自动化工具迅速定位错误,准确地诊断问题失败的本质缘由.文中针对极小一阶不可满足子式的求解问题,引入了否证蕴含图及其正向与逆向可达结点的概念,并证明了不可满足子式与否证蕴含图之间的关系.基于二者的关系,提出了基于冲突分析与否证蕴含的极小一阶不可满足子式求解算法,并融合了蕴含图剪枝技术,以提高算法效率.通过实验与当前最优的深度优先搜索算法进行了比较,结果表明:文中的算法显著优于深度优先搜索算法,并且随着公式复杂度的增加,性能优势更加明显.关键词一阶逻辑公式;可满足模理论问题;极小不可满足子式;消解否证;否证蕴含图1引言近年来,命题逻辑的可满足求解技术得到了飞Page2验证[1]、实时系统的验证[2]等;而在另外一些应用中,如汇编代码与RTL级Verilog代码的验证问题[3],布尔逻辑虽然也能够表达与处理,但由于其抽象层次较低,例如字变量会转换为一组无关的布尔变量,因此大大增加了问题的规模,显著提高了空间与时间的开销.而基于非量化一阶逻辑的可满足问题,即可满足性模理论(SatisfiabilityModuloTheories,SMT)问题恰好弥补了SAT技术的不足,迅速成为验证领域的研究热点.可满足性模理论问题源于实际应用需求,例如软件的形式化验证、电子设计自动化与人工智能等众多领域的问题,都能够规约为非量化一阶逻辑公式,采用SMT求解器来解决.当公式不可满足时,通常要求查找不可满足的原因,诊断与定位问题的错误,这就要求移除公式中与不可满足无关的短句,只保留一部分短句,也就是提取公式的不可满足子式.而极小不可满足子式,即其所有真子式都是可满足的,能够给出关于公式不可满足更加精确的解释,迅速地定位错误,应用也更加广泛[4-6].近年来,涌现了众多提取布尔不可满足子式的算法[7-15],成为形式验证领域最活跃的分支之一.然而,自从抽象层次更高、表达能力更强的可满足性模理论出现之后,SAT面临被SMT取代的趋势,并且随着SMT求解技术的飞速发展,SMT求解器已经能够解决实际领域中较大规模的问题,为求解SMT不可满足子式提供了可靠的理论基础与实践平台,因此SMT不可满足子式的求解方法将成为今后研究的重点及主要突破的方向.Cimatti等[16]首次提出了求解SMT不可满足子式的算法LemmaLifting,该算法采用分离的布尔不可满足子式求解算法与SMT求解器相结合的方法,但该算法并不能保证所得到的SMT不可满足子式的极小性.显然,相对于不可满足子式来说,极小不可满足子式的求解难度更大,算法复杂度更高.因此到目前为止,国际上还没有公开发表的针对如何求解SMT极小不可满足子式的研究成果.针对极小SMT不可满足子式的求解问题,本文提出基于冲突分析与否证蕴含的极小SMT不可满足子式求解算法(Conflict-AnalysisandRefuta-tion-ImplicationMinimalUnsatisfiableSubformu-laeExtractor,CARI-MUSE).首先给出否证蕴含图及其正向与逆向可达结点的概念,而后证明它们与不可满足子式的关系.算法基于这些结论,通过记录SMT求解器在证明公式不可满足性的过程中产生的消解否证,同时构造其否证蕴含图,而后依次选择蕴含图中原始短句,通过检测原始短句的正向不可达结点集的可满足性,来确定该短句是否属于极小不可满足子式;若结点集是可满足的,则将该原始短句加入不可满足子式;否则,从否证蕴含图中删除该短句及其冲突短句,构造更小的否证蕴含图;如此反复迭代,直到遍历否证蕴含图中的原始短句,这时就得到极小SMT不可满足子式.为了提高搜索效率,算法中集成了蕴含图剪枝技术,该技术将证明正向不可达结点集的不可满足的步骤,转换为证明正向可达结点集中不存在一条其短句都为假的路径,大大减小了算法的搜索空间.实验结果表明,CARI-MUSE算法的效率明显高于求解极小不可满足子式的深度优先搜索算法DFS-MUSE①;并且随着公式复杂度的增加,性能优势更加显著.2背景知识可满足模理论问题基于不包含全称与存在量词的一阶逻辑公式.根据一阶逻辑的定义,一个n元项τ可以表示为其中x表示个体变元或常元,f表示n元函数变元或常元.而非量化一阶逻辑公式φ表示为φ··=P(τ1,…,τn)|τ0=τ1|﹁φ0|φ0∨φ1|φ0∧φ1其中τi为项,1in,P为n元谓词变元.定义1(可满足性模理论问题).给出一个非量化的一阶逻辑公式φ以及一个赋值模型M,M包含一个非空域|M|,其中对于n元函数变元f,M(f):f→n|M|,对于谓词变元P,M(P)|M|n,对于个体变元x,M(x)∈|M|;公式φ中一个项τ的赋值为M[x]=M(x),M[f(τ1,…,τn)]=M(f)(M[τ1],…,M[τn]).那么,Mφ定义为MP(τ1,…,τn)(M[τ1],…,M[τn])∈M(P);Mτ0=τ1M[τ0]=M[τ1];M﹁φ0M|≠φ0;Mφ0∨φ1Mφ0或Mφ1;Mφ0∧φ1Mφ0且Mφ1,如果存在这样的赋值模型M,使得Mφ,那么称公式φ是可满足的;否则,称公式φ是不可满足的.可满足性模理论问题实际上是解决非量化一阶①DFS-MUSE算法及其实现见http://www.ssypub.org/~Page3逻辑公式的可满足性问题,其公式中的函数变元与谓词变元通常基于一些特定的理论域,而这些理论域都源于应用领域中实际问题的抽象.目前比较常见的理论域包括整数集/实数集上的线性算术(LIA/LRA)、整数集/实数集上的差分逻辑(IDL/RDL)、等式与未解释函数(EUF)、数组(AR)以及位向量(BV)等.SMT求解技术经过近几年的快速发展,相继出现了Eager方法、Lazy方法以及最新的DPLL(T)算法[17],同时SMT求解器也逐渐走向成熟与完善,目前已经能够解决实际应用中较大规模的问题,为求解不可满足子式奠定了基础.定义2(SMT不可满足子式).给出一个不可满足的非量化一阶逻辑公式φ,ψ=∧n的一个SMT不可满足子式当且仅当ψ是不可满足的,并且ψφ,即i,1in,若Ci∈ψ,则Ci∈φ,其中Ci表示短句.定义3(极小SMT不可满足子式).给出不可满足的非量化一阶逻辑公式φ及其一个不可满足子式ψ,那么ψ是极小SMT不可满足子式当且仅当ψ,使得是可满足的.对于SMT公式来说,如果其某个不可满足子式的所有真子式都是可满足的,那么它是极小不可满足子式.显然,相对于不可满足子式来说,极小不可满足子式的求解难度更大,算法复杂度也更高.但是极小不可满足子式能够给出关于公式不可满足原因更加精确的解释,迅速诊断与定位错误,在实际应用中具有更重要的理论与应用价值.由于在SMT求解器中,都将输入公式转换为合取范式形式从而证明其可满足性,因此可以利用CNF公式的消解理论来提取极小不可满足子式.下面给出消解的定义与消解原理.定义4(消解).设Ci与Cj为两个短句,若li∈Ci与lj∈Cj是一对互补的文字,则称(Ci\li)∨(Cj\lj)为Ci与Cj的消解式,其中li和lj称为消解基,Ci和Cj称为消解母式.引理1[18].若短句C为Ci与Cj的消解式,则(Ci,Cj)C.引理2[18].若Ci=li与Cj=lj为两个单元短句,并且li和lj是一对互补的文字,则Ci与Cj的消解式为空短句,即(Ci,Cj)⊥.定义5(消解序列).设S为短句集,且C为短句,若存在短句的有穷序列C0,…,Cn,满足(1)Cn=C;(2)令0in,则短句Ci至少满足下列两个条件之一:(i)Ci∈S;(ii)j,k,使得(Cj,Ck)Ci,其中0j,k<i,那么称短句C为S的消解结果,表示为S|-|-C,并将C0,…,Cn称为由S导出C的消解序列.引理3[18].设S为短句集,且C为短句,若S|-|-C,则SC.引理4(消解原理)[18].短句集S为不可满足的当且仅当S|-|-⊥.3算法原理如果根据定义3的方法求解极小SMT不可满足子式,假设一个不可满足子式|ψ|=n,那么要进行2n-2次可满足性的判断,才能确定ψ的极小性.所以算法的复杂度非常高,执行效率也比较低.经过分析,能够得出下面的结论.引理5.给出不可满足的非量化一阶逻辑公式φ,及其一个不可满足子式ψ=∧n句,那么ψ是极小SMT不可满足子式,当且仅当从ψ中删除任意一个短句i,Ci∈ψ,1in,都使得ψ\Ci是可满足的.采用反证法易证引理5,这里不再赘述.根据该结论,算法只需将不可满足子式删除其中任意一个短句后,测试剩余短句构成公式的可满足性,只需进行n次可满足性判断,即可确定其极小性,从而大大简化了求解极小SMT不可满足子式的过程,降低了算法复杂性.根据消解原理,若短句集是不可满足的,那么经过有限步消解可以得到空短句,因此将消解序列的概念延伸,得到消解否证的定义.定义6(消解否证).给出一个不可满足的SMT公式φ,令集合Cla(φ)={C|C为φ中的短句},若{C0,…,Cn}是Cla(φ)导出的消解序列,且Cn=⊥,则称R={C0,…,Cn-1,⊥}为公式φ的一个消解否证.为了能够高效地求解极小不可满足子式,需要将SMT求解器产生的从原始公式到空短句的消解过程记录并转换为一种简洁清晰的数据结构,因此引入了短句蕴含图的概念.定义7(短句蕴含图).给出一个不可满足的SMT公式φ,G(V,E)为一个有向无环图.假设V=Vr∪Vc,其中Vr是由G中所有始发结点构成的集合,即Vr中结点的入度为0,并且vi∈Vr,结点viPage4对应的短句Ci∈φ;而Vc是由G中所有非始发结点构成的集合,由消解结果短句与理论求解器返回的学习短句构成,称为冲突短句,记为D={Cc2,…,CcCc的短句};(1)Vr=Cla(φ),其中Cla(φ)={C|C为φ中(2)对于每一个冲突短句Cc序列Si={Ci1,Ci2,…,Cij,Cc(i)k,1kj,Cik满足下列两个条件之一:①Cik∈Cla(φ);②1li,Cc应于Cim→Cc(ii)m,1mj,在E中存在唯一的边eim,对短句蕴含图.(3)出度为0的最终结点对应的短句为Cc若满足上面的条件,则G(V,E)称为公式φ的而不可满足子式本质上反映的是短句蕴含图中结点之间的逻辑关系,因此引入短句蕴含图中正向可达结点与逆向可达结点的概念.定义8(正向可达结点).给出SMT公式φ,G(V,E)为φ的一个短句蕴含图,如果从结点α经过n(n0)条边能够到达结点β,即存在一条α到β的路径,那么称β是α的正向可达结点.在G(V,E)中,从结点α出发所有正向可达结点构成的集合表示为FRv(G,α);而从结点α出发所有正向不可达的结点构成的集合表示为FRv(G,α).定义9(逆向可达结点).给出SMT公式φ,G(V,E)为φ的一个短句蕴含图,如果从结点β经过n(n0)条边能够到达结点α,即存在一条β到α的路径,那么称β是α的逆向可达结点.在G(V,E)中,到达α的所有逆向可达结点构成的集合表示为BRv(G,α);而不可到达α的结点构成的集合表示为BRv(G,α).定理1.给出一个不可满足的SMT公式φ,存在一个φ的消解序列R={C0,…,Cn-1},当且仅当存在一个对应于R的短句蕴含图G(V,E).证明.首先证明充分性,针对消解序列R所当n=1时,R只包含1个短句,显然成立;当n=3时,假设R={C0,C1,C2},则消解过程为(C0,C1)C2,且C0,C1∈φ;根据定义7,Vr={C0,C1},Vc={C2},E={e1,e2},其中边e1与e2分别由C0与C1指向C2,构成G(Vr∪Vc,E),满足短句蕴含图的定义,因此结论成立;包含的短句数n采用数学归纳法证明.i∪{Cj},Vc=Vc假设nm,结论成立;当n=m+1时,R产生最终消解结果Ck的步骤表示为(Ci,Cj)Ck,根据定义7构造短句蕴含图,此时存在两种情况:第1种情况.Ci与Cj中只有一个是原始短句,这里假设Cj∈φ;而Ci的消解序列Ri={C0,…,Ci}包含至多m个短句,符合假设条件,那么存在一个对应于Ri的短句蕴含图Gi(VrVr=Vr中e1与e2分别由Ci与Cj指向Ck,构成G(Vr∪Vc,E),满足定义7,因此G(Vr∪Vc,E)为短句蕴含图.第2种情况.Ciφ,且Cjφ,假设Ci与Cj的消解序列分别为Ri和Rj,其包含的短句数记为ni与nj.由于km,且Ciφ,Cjφ,因此nim-1,njm-1,符合假设条件,那么存在Ri与Rj对应的短句蕴含图Gi(Vr后,令Vr=VrEj∪{e1,e2},其中e1与e2分别由Ci与Cj指向Ck,从而构成G(Vr∪Vc,E),满足定义7,因此G(Vr∪Vc,E)为短句蕴含图.所以,给出一个消解序列R,则必定存在一个对应于R的短句蕴含图G(V,E).下面证明结论的必要性,假设存在一个短句蕴含图G(Vr∪Vc,E),那么针对结点数|V|采用数学归纳法进行证明.当|V|=1时,G只包含一个空短句,显然成立;当|V|=3时,根据定义7,Vc={C2},Vr={C0,C1},且(C0,C1)C2,那么对应于G的消解序列R={C0,C1,C2};假设|V|m时,结论成立;当|V|=m+1时,假设G的最终结点为Ck,且(Ci,Cj)Ck,eik:Ci→Ck,ejk:Cj→Ck,那么将G中的结点Ck以及边eik与ejk删除,那么剩余的结点和边分别构成两个子图Gi(Vi,Ei)与Gj(Vj,Ej),符合定义7,Gi和Gj为短句蕴含图,并且满足|Vi|m,|Vj|m.根据假设条件,可以得到Gi与Gj的消解序列Ri和Rj;那么令短句集合R={C|C∈Ri或C∈Rj或C=Ck},由于(Ci,Cj)Ck,且Ci∈Ri,Cj∈Rj,因此R构成Ck的消解序列.所以,给出一个短句蕴含图G(V,E),则必定存在一个对应于G的消解序列R.综合上面充分性与必要性的证明,得到结论:存在一个φ的消解序列R,当且仅当存在一个对应于R的短句蕴含图G(V,E).Page5在证明输入公式不可满足性的过程中,通过修改SMT求解器,使其记录所有冲突结点的消解序列,以及空短句的消解否证,同时逐步构造短句蕴含图G(V,E).通常来讲,并不是G(V,E)中所有短句都参与到消解空短句的过程,仅是空短句的逆向可达结点集BRv(G,⊥)才参与该过程.因此能够将G(V,E)化简,把所有与空短句消解无关的结点及其边都删除,只保留消解否证中的结点,那么这种非冗余的短句蕴含图称为否证蕴含图.下面给出否证蕴含图的定义.定义10(否证蕴含图).给出不可满足公式φ,及其一个短句蕴含图G(V,E),如果从G中的每个短句C出发,都至少存在一条路径到达空短句⊥,那么G为否证蕴含图,记为GR(V⊥,E⊥).如果将定理1的结论扩展到否证蕴含图与消解否证上,是否仍然成立?经过分析,给出下面的结论.定理2.给出一个不可满足的SMT公式φ,存在一个φ的消解否证R={C0,…,Cn-1,⊥},当且仅当存在一个对应于R的否证蕴含图GR(V⊥,E⊥).证明.将定理1中的消解序列的概念扩展到消解否证,而短句蕴含图的概念相应地延伸到否证蕴含图,根据定义6与10,易证.给出一个不可满足的SMT公式φ以及φ的一个短句蕴含图G(V,E),那么否证蕴含图GR(V⊥,E⊥)=GR(Vr∪Vc,E⊥)的构造方法为:其结点集合V⊥={vi|vi∈BRv(GR,⊥)},即短句蕴含图中所有空短句⊥的逆向可达结点集,其中Vr=V⊥∩φ,图1公式φ的否证蕴含图Vc=V⊥-Vr;而边的集合E⊥={eij:vi→vj|vi,vj∈BRv(GR,⊥)},即E⊥由所有始点与终点均在BRv(GR,⊥)中的边构成.那么,根据公式φ的否证蕴含图GR(V⊥,E⊥),如何得到SMT不可满足子式?下面的结论给出解决方法.定理3.给出不可满足SMT公式φ的一个消解否证R,以及R对应的否证蕴含图GR(V⊥,E⊥),那么BRv(GR,⊥)∩φ中的短句合取构成的公式是φ的一个不可满足子式.证明.假设ψ为BRv(GR,⊥)∩φ中所有短句通过合取构成的公式.那么C∈ψ,由于C∈BRv(GR,⊥),根据定义9与10,表明从短句C对应的结点出发,存在一条路径到达空短句⊥,也就是说C参与到空短句的消解过程;根据引理4,Sψ|-|-⊥,其中Sψ表示由公式ψ中短句构成的短句集,则ψ是不可满足的.并且证明过程基于C∈φ,所以ψφ,且ψ是不可满足的,根据定义2,ψ为φ的一个不可满足子式.下面通过一个例子来说明否证蕴含图及其与不可满足子式的关系.假设一个CNF形式的SMT公式φ为φ=(a∨﹁(x<0)∨(y1))∧﹁(x<0)∧(a∨(x<0)∨(y1))∧(﹁a∨(x+y>3))∧(a∨(x<0)∨﹁(y1))∧((x<0)∨(x+y>3))∧(﹁a∨﹁(x+y>3))(3)公式φ基于整数集上的线性算术(LIA)理论域,其中x和y为个体变元,a是命题变元.图1给出了公式φ的一个否证蕴含图GR(Vr∪Vc,E⊥).根Page6据定义10,Vr={C1,C2,C3,C4,C5,C6,C7},Vc={C8,C9,C10,C11,C12,C13,⊥},并且Vr∪Vc中的所有结点到空短句都是可达的,即Vr∪Vc=BRv(G,⊥).在图1中,短句C4的正向可达结点集为FRv(GR,C4)={C4,C9,C11,C12,C13,⊥},而短句C12的逆向可达结点集为BRv(GR,C12)={C1,C2,C3,C4,C5,C8,C9,C11,C12}.根据定理3,φ的不可满足子式为x=C1∧C2∧C3∧C4∧C5∧C6∧C7.4基于否证蕴含的求解算法求解极小SMT不可满足子式的CARI-MUSE算法基于定理3的结论,其主要过程为:通过保存SMT求解器在证明公式不可满足性时产生的一系列消解步骤,构成消解否证,并转换为一个否证蕴含图;但是定理3只能从否证蕴含图中提取不可满足子式,并不保证其极小性,因此算法需要进一步地推演.首先依次选择蕴含图中的原始短句,删除该短句及其相关的冲突短句,将否证蕴含图中的剩余结点构成一个子公式,调用SMT求解器检测其可满足性,此时通过蕴含图剪枝技术加速该过程;若子公式是可满足的,则将当前的原始短句加入到不可满足子式中;否则,表明原始短句不属于极小不可满足子式,因此将该短句及其冲突短句对应的结点与边从蕴含图中移除,同时保证非冗余性,从而构造一个更小的否证蕴含图;而后不断循环,直到遍历否证蕴含图中的所有原始短句,此时就得到极小SMT不可满足子式.CARI-MUSE算法的伪代码如图2所示.CARI-MUSE算法的输入为SMT-LIB格式的公式φ,目标是得到φ的极小不可满足子式.首先,算法解析输入公式,并利用SMT求解器来求解其可满足性,并保存所有的消解步骤,同时构造一个短句蕴含图G(V,E),但当前的G(V,E)对于空短句的消解过程来说可能是冗余的,因此需要将其化简为一个非冗余的短句蕴含图,即否证蕴含图.这里令GR(V⊥,E⊥)=GR(Vr∪Vc,E⊥)表示一个否证蕴含图,其中Vr是指GR中所有始发结点的集合,对应于原始公式φ中的短句,而Vc代表所有非始发结点构成的集合,即中间产生的消解结果短句与理论求解器输出的学习短句.而后算法利用函数ChooseClause选择VU中的一个原始短句Cα,检测其是否属于极小SMT不可满足子式.在算法构造否证蕴含图G(V,E)的过程中,同时求解结点α的正向不可达结点集合FRv(GR,α).根据定义8,正向不可达结点集FRv(GR,α)是指在G(V,E)中从α出发所有不可达的结点构成的集合.为了检测结点α对应的短句Cα是否属于极小不可满足子式,从GR(Vr∪Vc,E⊥)中删除α的正向可达结点集合FRv(GR,α),即令FRv(GR,α)中结点对应的短句构成的公式作为输入,调用SMT求解器求解的可满足性.由于GR(V⊥,E⊥)是否证蕴含图,因此空短句⊥总是属于α的正向可达结点集合FRv(GR,α),也就是,从α出发经过有限条边最终总能到达结点v⊥,所以空短句⊥不会包含在公式中.那么,算法以FRv(GR,α)转换后的公式作为输入公式,要么证明是可满足的,要么最终产生空短句.算法.极小SMT不可满足子式的求解算法CARI-MUSE输入:SMT公式φ输出:极小不可满足子式MinimalUS1.解析公式φ,转换为内部数据结构;2.记录SMT求解器的消解过程SR;3.根据SR为公式φ构造一个短句蕴含图G(V,E);4.将G(V,E)化简为否证蕴含图GR(Vr∪Vc,E⊥);5.MinimalUS=;6.VU=Vr;7.while(VU≠)do8.Cα=ChooseClause(VU);9.M=FRv(GR,α);10.将M转化为子公式;11.if(SMTsolverreturnissatisfiable)then12.MinimalUS=MinimalUS∪{Cα};13.VU=VU-{Cα};14.else15.记录求解器的消解过程SM;16.根据SM构造的短句蕴含图GM(Vr17.VrN=Vr-{Cα};18.VcN=FRv(GR,α)∪Vc19.EN={E⊥-EFRv(GR,α)}∪EM;20.转换为φ的短句蕴含图GN(VrN∪VcN,EN);21.将GN化简为φ的否证蕴含图GP(Vr22.GR(Vr∪Vc,E⊥)←GP(Vr23.VU=Vr24.returnMinimalUS.如果SMT求解器证明FRv(GR,α)对应的公式是可满足的,令φ\Cα表示从原始公式φ中移除短句Cα后的子公式,那么表明能够得到φ\Cα的可满足赋值模型,所以短句Cα属于极小SMT不可满足子式,将Cα加入MinimalUS集合中,而后跳转到VU中的下一个原始短句.如果SMT求解器返回公式是不可满足的,表示Cα不属于当前所求解的极小不可满足子式,此时算法从否证蕴含图GR(V⊥,E⊥)Page7中移除Cα及其冲突短句所对应的结点;但是必须保证删除这些结点与边后,GR仍为一个否证蕴含图,即算法要基于FRv(GR,α)中的结点构造一个更小的但完整的否证蕴含图,下面介绍其构造方法.由于公式是不可满足的,因此求解器返回一个消解过程SM,而后算法构造一个公式的短句蕴含图GM(Vr所有始发结点必须是原始公式中的短句,而GM的所有始发结点集合Vr因此GM仅为的短句蕴含图,而不构成原始公式φ的短句蕴含图,不能将其作为算法后面循环的输入.但是,GM(VrGR(V⊥,E⊥)中的冲突短句,并且从结点α出发是不可达的,因此可以从集合Vr\Cα中提取这些冲突短句的始发结点,并且将原始图GR(V⊥,E⊥)中那些从结点vi∈Vr\Cα到vj∈FRv(GR,α)的边:vi→vj添加到GM中,就能够保证其始发结点对应的短句都属于φ,从而把GM扩展为一个短句蕴含图.一个新的短句蕴含图GN(Vr集合VrM,边的集合是EN=(E⊥-EF)∪EM,其中EF表Vc示所有起点或终点属于FRv(GR,α)的边.由于GN(Vr的否证蕴含图,因此要将GN化简为否证蕴含图GP(Vr始短句也可能会被删除,因此在每次检测到一个原始短句Cα不属于极小不可满足子式时,算法不仅要删除Cα,而且可能移除其它一些原始短句.而后算法P是否为空,若不为空,算法通过函数Choose-检VrClause选择下一个原始短句,继续循环;否则,算法终止,此时MinimalUS即为公式φ的极小SMT不可满足子式.另外,改变ChooseClause函数的选择策略,以不同的顺序输出短句,能够得到不同的极小SMT不可满足子式.根据前面的步骤,CARI-MUSE算法能够构造N=Vr\Cα,冲突短句集合VcN∪VcP∪Vc根据定理3的结论,算法仅能从SMT公式的否证蕴含图中提取不可满足子式,而不能保证其极小性,因此算法必须在否证蕴含图的基础上进一步演绎,才能得到极小SMT不可满足子式.下面给出图2所示的CARI-MUSE算法的正确性证明.定理4.给出一个不可满足SMT公式φ,那么CARI-MUSE算法的最终结果MinimalUS为φ的一个极小SMT不可满足子式.证明.根据定理3,算法的1~4行得到了φ的一个不可满足子式,即否证蕴含图GR(Vr∪Vc,E⊥)的结点集Vr对应的所有短句的合取,记为ψ.而后算法从Vr中移除短句Cα,将FRv(GR,α)转换后的公式作为求解器的输入.这时存在两种情况:第1种情况(11~13行):是可满足的,即ψ-{Cα}是可满足的,而ψ是不可满足子式,根据引理5,Cα属于极小不可满足子式,保存到MinimalUS中;第2种情况(15~23行):是不可满足的,即从ψ中移除Cα不改变ψ的最终消解结果,所以Cα不属于极小不可满足子式;而后算法移除Cα及其相关的冲突短句,构造一个更小的短句蕴含图GN(VrN,EN),并将其化简为φ的否证蕴含图GP(VrVcP,EP);由于保证了下一次循环的输入始终为非冗Vc余的否证蕴含图,GP保留了构成极小不可满足子式的短句,那些在化简过程中删除的原始短句对于空短句的消解来说是冗余的,因此它们不属于极小不可满足子式.算法继续循环,直到ψ为空.由于MinimalUSψ,根据上面的证明,每次加入的短句Cα都是必要的,而删除的短句都是冗余,所以,MinimalUS为φ的一个极小SMT不可满足子式.以式(3)给出的公式φ为例来说明CARI-MUSE算法的执行过程.假设函数ChooseClause返回的短句是C1,那么算法检测C1是否属于极小不可满足子式.而FRv(GR,C1)={C2,C3,C4,C5,C6,C7,C9,C10,C11},那么子公式为=C2∧C3∧C4∧C5∧C6∧C7∧C9∧C10∧C11.将作为SMT求解器的输入,那么得到是不可满足的,并返回的短句蕴含图GM(VrM={a∨(x<0),a,⊥},令C14=a∨(x<0),C15=Vca,C16=⊥,ei,j:Ci→Cj,则EM={e2,14,e11,14,e14,15,e7,15,e10,16,e15,16}.但是Vr公式φ,因此算法将其扩展为公式φ的短句蕴含图GN(VrN∪Vc简单,GN(Vr算法从φ的初始否证蕴含图GR(Vr∪Vc,E⊥)中移除了结点{C1,C8,C12,C13}.而后算法以GN(VrN,EN)作为输入,继续循环.VcPage8图3移除短句C1后的否证蕴含图5蕴含图剪枝技术为了提高CARI-MUSE算法的效率,实现了一种基于否证蕴含图的剪枝技术(RefutationImplica-tionGraphPruning,RIGPruning).该优化方法的基本思想是:给出一个不可满足的公式φ,将其划分为两个子公式φ=∧ψ,那么当一个部分赋值模型M使=true时,则ψ=false.那么算法求解FRv(GR,α)对应的公式的可满足性赋性时,只要搜索FRv(GR,α)中所有从结点α到空短句的路径,证明不存在一条这样的路径:该路径上的所有短句都为false,那么就可以表明是不可满足的,这样能够显著地减小变元赋值的搜索空间,加速公式可满足性的判定过程.下面给出蕴含图剪枝技术原理的证明过程.定理5.给出不可满足的SMT公式φ及其否证蕴含图GR(V⊥,E⊥),若一个部分赋值模型MFRv(GR,α),那么存在一个从α到空短句的路径P={α,…,v⊥}FRv(GR,α),M使得S={Cα,…,⊥}中的所有短句都为false.证明.采用反证法,假设不存在从α到空短句的路径P={α,…,v⊥}.根据定义8与假设,空短句⊥对应的结点v⊥不包含在α的可达结点集合中,即v⊥∈FRv(G,α).由于MFRv(G,α),即部分赋值模型M使得FRv(G,α)中的所有短句都为true,那么FRv(G,α)中存在一个结点割集Vs,其对应的短句通过合取构成的子公式φs是可满足的.但是空短句v⊥∈Vs,根据引理4得到,φs是不可满足的,产生矛盾.所以,假设错误.结论成立.根据定理5的逆否命题:如果某个赋值模型M使得FRv(G,α)中从结点α到空短句的某条路径上的每个短句都为false,那么MFRv(G,α),即M为FRv(G,α)的可满足赋值模型.蕴含图剪枝技术利用定理5的逆否命题,如果证明GR(V⊥,E⊥)中不存在这样的路径P:P上所有短句都为false,那么就说明FRv(G,α)是不可满足的.通常来说,FRv(G,α)所包含的短句数远远大于FRv(G,α)的短句数,因此在大多数情况下采用这种方法能够大大简化求解FRv(G,α)的可满足性的过程,从而提高算法的效率.以式(3)给出的公式φ为例来说明定理5的结论,GR(Vr∪Vc,E⊥)为φ的否证蕴含图,则FRv(GR,C5)={C1,C2,C3,C4,C6,C7,C8},那么使得FRv(GR,C5)可满足的部分赋值模型M={a,﹁(x+y>3),﹁(x<0)},那么存在一条路径P={C5,C10,C13,⊥}FRv(GR,C5),M使得P中的每个短句都为false.函数RIGPruning实现了否证蕴含图的剪枝技术,集成于SMT求解器中.RIGPruning的基本运行过程为:首先,将FRv(G,α)中所有结点α到结点v⊥的路径构成一个子图,记为Gα.而公式由FRv(GR,α)中所有结点对应的短句的合取构成,而后求解器以与Gα作为输入,以深度优先的搜索方式查找Gα中未被赋值的变元,并令其为false.如果在赋值过程中,产生了真值为true的短句或冲突短句,那么就将变元的赋值回溯.求解器在Gα的每条Page9路径上不断地搜索,直到下面的两种情况之一出现:①产生一个部分赋值模型M,M使得Gα中的某条路径上的短句都为false,那么求解器继续搜索未赋值的变元,直至得到FRv(G,α)的可满足赋值模型;②遍历完整个Gα,表明Gα中不存在其上所有短句都为false的路径,表明公式是不可满足的;此时SMT求解器继续搜索,直到产生的消解否证.6实验结果与分析为了验证算法的有效性,采用业界标准的SMTCompetition2007测试集作为基准测试向量;SMTCompetition测试集是一年一度的国际计算机辅助验证CAV会议中针对SMT求解器进行性能评估与竞赛的测试标准,其所有公式都来源于实际的工业应用.基于测试集中的公式将基于冲突分析与否证蕴含的算法CARI-MUSE与深度优先搜索算法DFS-MUSE进行了对比与分析,二者的输入都是SMT-LIB格式的公式,算法的运行环境是2.5GHz表1CARI与DFS算法在SMT测试集上的实验结果bad_echos_ascend.basesc_init_frame_gap.basegood_frame_update.induction894398.5820829.0016125.6723.21161good_frame_update.base8946720.5640272.8131160.0354.65311windowreal-safe2-2windowreal-safe-2lpsat-goal-1lpsat-goal-2lpsat-goal-3windowreal-no_t_deadlock-15219293345.202198176.961351148.64130.961351windowreal-no_t_deadlock-16233312852.362342208.131441173.09151.901441windowreal-no_t_deadlock-17247332373.112485293.381531245.61211.331531windowreal-no_t_deadlock-18261351985.022627347.241622288.68246.481622windowreal-no_t_deadlock-192753714112.572764463.781712381.24324.641712windowreal-no_t_deadlock-202893909715.202897547.441802440.80372.951802图4给出了CARI-MUSE算法与DFS-MUSE算法基于SMTCompetition2007测试集中的4组典型公式的实验结果,其中横坐标轴表示原始公式所包含的短句数,而纵坐标轴表示算法的运行时间,单位为s,图中的两条曲线分别表示CARI-MUSE算法与DFS-MUSE算法随公式的短句数递增时运行时间的变化趋势.图4(a)是基于inf-bakery-mutex测试集,其公式所包含的短句数范围是65~1053;的Athlon2CPU,内存2GB,操作系统为Linux的机器.求解极小SMT不可满足子式的CARI-MUSE算法采用C++与STL实现.算法中公式的可满足性检测过程基于一个开源的SMT求解器ArgoLib①,它基于DPLL(T)算法,目前支持的理论域包括线性算术(LRA/LIA)与差分逻辑(RDL/IDL).两种算法的运行时限都设置为1800s.表1给出了CARI-MUSE算法与DFS-MUSE算法基于测试集中15个典型公式的实验结果.表中第2列数据是每个公式所包含的变元数;第3列表示每个公式所包含的短句数;第4、5列给出了求解SMT不可满足子式算法(LemmaLifting+AMUSE)[16]的结果短句数与运行时间,该算法不保证不可满足子式的极小性.第6、7列分别是深度优先搜索算法(DFS-MUSE)的运行时间与所提取极小不可满足子式包含的短句数.第8、9列分别是基本冲突分析与否证蕴含算法(不包含蕴含图剪枝的优化过程)与完整CARI-MUSE算法的执行时间对比;最后一列是基本与完整CARI-MUSE算法得到的极小不可满足子式的长度.表中所有公式的运行时间都是以s为单位.时间/s结果短句数图4(b)对应于windowreal-no_t_deadlock测试集,其公式包含的短句数范围是203~3908;图4(c)是基于pursuit-safety测试集,其公式短句数的范围是113~1763;而图4(d)的测试集是gasburner-prop3,其短句数范围是28~522.①MaricF,JanicicP.ArgoLibusermanual.http://www.Page10图4CARI-MUSE与DFS-MUSE基于4组SMT测试集的对比图5给出了CARI-MUSE算法与DFS-MUSE算法基于SMTCompetition2007测试集中200个公式的实验结果,运行时限为1800s,其中横坐标轴表示冲突分析与否证蕴含算法CARI-MUSE的运行时间,纵坐标轴表示深度优先搜索算法的DFS-MUSE的运行时间,二者都采用了对数(lg)坐标,时间单位为s.图5CARI-MUSE与DFS-MUSE基于SMT从表1、图4与图5的实验结果可以看出,CARI-MUSE算法能够有效地求解SMT公式的极小不可满足子式.从表1以及图4(a)~(d)中能够直观地看出,CARI-MUSE算法明显优于深度优先搜索算法DFS-MUSE.根据表1的结果,完整CARI-MUSE算法的运行时间小于去除蕴含图剪枝过程的基本算法,因此蕴含图剪枝技术能够加速算法的可满足性判定过程.另外从表1可以看出,CARI-MUSE算法得到的极小不可满足子式的短句数显著小于LemmaLifting+AMUSE算法得到的不可满足子式,但运行时间要大于后者;而在实际应用中,极小不可满足子式能够给出关于公式不可满足更加精确的解释,迅速地定位错误,应用也更加广泛.在图5中,所有测试集中的公式都位于对角线的上方,但为了数据在图中分布的均匀性,采用了对数坐标系,因此两个算法性能的比值接近于对角线,但是同样能够表明CARI-MUSE算法明显优于DFS-MUSE算法.其主要原因是CARI-MUSE算法采用了一种更为有效的机制来移除公式中的冗余短句,它每次从否证蕴含图的原始短句集合中删除的短句数为n1,DFS-MUSE算法每次循环都只从原始公式中删除一个短句.另外,根据表1的实验结果,对于测试集中的SMT公式,极小不可满足子式所包含的短句数远远小于原始公式的短句数,通常占公式总短句数的1%~50%左右,所以极小不可满足子式能够给出公式不可满足原因更加精确的Page11解释,更加迅速地诊断与定位错误.根据图4(a)~(d)的实验结果分析,可以发现当公式所包含的短句数与变元数较少时,尽管CARI-MUSE算法优于DFS-MUSE算法,但是两种算法的性能差距并不十分显著;而后随着公式复杂度的增大,即其短句数与变元数逐渐增加时,CARI-MUSE算法与DFS-MUSE算法的运行时间差距越来越大.表1的实验结果也在一定程度上反映了这个规律.而在图5中,随着运行时间的推移,也就是说公式的复杂度越来越大,CARI-MUSE与DFS-MUSE算法的性能比值的总体趋势是越来越偏离对角线,表明CARI-MUSE与DFS-MUSE算法的性能差距越来越显著.综上所述,可以给出一个结论:CARI-MUSE算法明显优于DFS-MUSE算法;并且随着公式包含的变元数与短句数不断增加时,CARI-MUSE算法的性能优势更加显著.这主要是由于当公式较小时,当把短句蕴含图化简为否证蕴含图时,通常每次只能删除一个原始短句,CARI-MUSE算法的优势并没有体现出来;但是当公式的复杂度增加时,当短句蕴含图进行约简时,多数情况下会删除多个原始短句,那么就会提高构造极小不可满足子式的效率,而DFS-MUSE算法每次循环通常都只从原始公式中删除一个短句,因此这时CARI-MUSE算法的性能优势就更加明显.7结束语本文针对极小SMT不可满足子式的求解问题,引入了否证蕴含图及其正向与逆向可达结点集的概念,并证明了它们与不可满足子式的关系;提出了基于冲突分析与否证蕴含的极小SMT不可满足子式的求解算法.该算法首先为输入公式构造否证蕴含图,而后选择并移除一个原始短句,通过检测该短句的正向不可达结点集的可满足性,从而确定它是否属于极小不可满足子式.算法融合了蕴含图剪枝技术,从而显著地减小了算法的搜索空间.实验结果表明,CARI-MUSE算法优于深度优先搜索算法DFS-MUSE,并且随着公式逐渐增大,CARI-MUSE算法的性能优势更加显著,并通过实验证明了蕴含图剪枝技术的有效性.致谢感谢ArgoLib的作者FilipMaric提供了求解器的所有源代码,并针对本文的算法提出了许多建议!
