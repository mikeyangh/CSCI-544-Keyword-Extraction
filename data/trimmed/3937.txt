Page1面向驱动配置的自动日志插入方法研究刘虎球1)马超1)白家驹2)1)(清华大学计算机科学与技术系北京100084)2)(西安电子科技大学计算机学院西安710126)摘要驱动的可靠运行对于操作系统至关重要,驱动的长久稳定运行依赖于正确的驱动配置.由于硬件本身存在大量约束条件,对系统进行修改,或者对驱动、内核升级,或者对设备更新换代时容易发生驱动配置错误,而该类错误尚无法通过现有的方法直接进行定位和解决.文中设计并实现了AiLsDc(AutomaticallyinsertingLogsystemforDriverconfiguration)自动日志插入辅助检错系统,能够根据参数配置规范文档中的规则进行驱动配置检查.AiLsDc首先按照定义的驱动配置规范规格XML文档对驱动源码进行插装和修改,运行时动态检查驱动的配置是否满足配置规范文档的要求.当出现参数违例时,日志记录模块将会自动记录可能引起该违例的错误原因和错误位置.通过对比和检查日志,能够在出错时快速定位从而辅助纠错,提高开发效率.实用性评测表明,系统能够捕获配置异常,而性能评测结果表明,AiLsDc系统在提高驱动的可靠性的同时,带来的开销很小.关键词操作系统;可靠性;驱动配置错误检查;日志注入1引言在当前的通用操作系统中,驱动常常以模块的形式加载到内核中运行,并且代码量大.在Linux中,驱动占据了操作系统70%的代码.然而,该部分代码所含错误是内核的3~7倍[1],在Windows中,85%的系统崩溃和驱动的错误相关[2],因而驱动的可靠性对系统至关重要[3].统计表明,在驱动代码中,驱动配置相关代码占据了字符驱动51%代码,配置的正确性直接决定设备能否正常工作,研究驱动的正确配置对提高驱动可靠性具有重要意义.由于设备驱动的开发常常和系统开发是分离的,因此内核扩展功能发生的细微改变都可能引起驱动出现不稳定现象.另外,许多驱动开发者违反内核扩展使用规范,当操作系统配置发生改变时,该种违例将无法提供正确的服务给驱动程序,引起设备不稳定工作,甚至崩溃.寄存器接口配置规范是驱动配置的关键组成部分,设备对系统的DMA地址等配置参数存在严格约束.以USB主机控制器中的帧基址寄存器为例①,图1中描述的即为UHCI(UniversalHostControllerInterface)主机控制器(HCD)驱动的帧基址寄存器(frame_dma_handle)的数据结构.1.2.3.4.5.frame_dma_handle的值即为帧基址的DMA地址参数,需要写入UHCI控制器的帧基址寄存器,查看UHCI设备手册得到帧基址寄存器的相关约束条件如表1所示.表项名称FLBASEADD地址基地址+(08-0B)H属性可读可写宽度32bitUHCI硬件手册[UHCIrevision1.1section2.1.5]指出帧基址寄存器要求低12位对齐,在实际写入时必须保证低12位为0,即大小为4KB.驱动开发者在此处使用内核扩展的内存管理接口时,应注意使用alloc_page或alloc_pages扩展,如果使用kmalloc,则在内存调试开启尾对齐时可能引发错误,使得设备不能正常工作.另外,在USB的UHCI驱动,TD(TransactionDescriptor)和QH(QueueHeader)的缓冲区则要求16字节对齐.根据设备手册要求,填入设备的DMA地址必须是物理内存地址,不能使用内核的线性地址.但是在部分系统实现机制中,内核的1GHz以内线性地址和物理地址一致,因此当页表扩充或配置表发生改变时,没有转换的线性内存地址直接填入DMA将可能引起系统崩溃.同时,程序员对自己的程序常常足够自信,测试周期较短.而设备驱动的功能和正确性测试常常依赖于具体的硬件,测试场景偏少,通常仅仅关心驱动功能实现,因而没有过多考虑系统环境配置等相关的功能测试.除了系统环境方面以外,还存在大量的设备相关的潜在约束,驱动配置都需要考虑.在数组的使用和配置上,同样存在大量的隐形约束.例如USB设备的语言ID(LANGID)数组要求非NULL结束,是以UNICODE编码,因此一个大小为N个字节的数组实际只能存储N-2个字节.在PCI的设备手册中②,还列出了大量空间范围约束,如在PCI配置地址空间中,对寄存器的配置空间存在隐性地址约束,PCI内存映射地址的物理对齐,寄存器地址的OFFSET在BASE的基础上不能超过256个字节.在本文中,作者把一些由于设备交互参数不规范或者设备返回值引起的差错以及上述提到的错误等统一归纳为驱动配置错误.由于配置常常与语义相关,研究难度大,当前很少有研究者针对驱动相关的配置进行研究.Kadav和Swift[4]指出,以往的驱动可靠性研究中人们常常关注声卡、存储、网络设备的驱动代码错误检查,而大量的驱动配置中的错误没有得到重视.并且这些配置相关的错误常常引起设备出现异常并且难以定位,该类错误并不能通过ShadowDriver[5]等技术予以解决.在以往的驱动可靠性研究中,人们常常通过快速重启设备等方法对驱动进行错误隔离与恢复,或者通过静态分析的方法对驱动错误进行检查.但是,①②Page3这些方法均无法直接解决配置相关的驱动错误.而且配置错误一旦发生,将对设备的正确运行产生致命影响.比较常见的错误如打印机错误,UHCI、EHCI(EnhancedHostControllerInterface)异常反复重启等.驱动配置与语义存在一定关系,因此仅从源码上检查是不够的.本文设计的驱动配置检查一方面依赖于驱动源码本身的编程规范,另一方面还依赖于驱动的配置规格文件.在源码中可以利用变量名和注释等语义信息提取配置的正确性要求,而配置规格文档部分可以通过在设备正确运行时辅助生成,也可以通过设备手册生成.驱动配置错误常常发生在系统管理员对系统进行修改,或者对驱动、内核升级,或者设备更新换代时.由于该类错误不能通过重启等方法解决,因此必须依赖于一些调试方法进行快速定位.在此情形下,日志是一种有效的调试和错误诊断方案,通过查看和对比日志信息能够快速定位到由硬件或系统环境变化引起的驱动错误位置.本文旨在设计一个驱动配置的正确性检查模型,并在模型基础上实现自动日志插入辅助检错系统(AiLsDc).系统按照配置规格文档,对配置的参数进行检查,通过在可能出错的部位插入相关的日志,运行时动态检查,出错时对比和检查日志,使得能够快速定位错误从而辅助检纠错,进而提高系统的可靠性.本文首次针对驱动配置问题提出了一种可行的解决方案,在提高驱动可靠性的同时,对系统性能等的副作用影响较小.本文第2节主要介绍当前的国内外关于驱动可靠性和配置相关的研究现状;第3节重点介绍针对驱动配置问题提出的AiLsDc模型;第4节主要介绍根据AiLsDc模型实现的AiLsDc系统,就系统结构和重点功能模块进行详细阐述;第5节给出系统的实用性评测结果;第6节给出系统的性能评测结果;第7节对全文进行简要总结.2相关工作驱动的错误检查,主要包括静态检查和动态检测两大类.其中静态检查主要包括Mondrix[6]、SafeDrive[7]、KINT[8]、CFix[9]、Dingo[10-11]、BGI[12]等.然而,已有的静态检查方法无法对带有特殊语义的配置参数进行解析.Dingo[10]是针对文档不规范和语义混淆等问题,提出的一种基于协议状态自动机的描述设备协议的语言Tingu,辅助驱动开发.但是该方法一方面要求驱动全部重写,工作量巨大,直到Termite出现该问题才得到了部分缓解[11];另一方面,仍不能解决环境发生变化时引起的驱动配置问题.CFix[9]等针对的是具体的错误,如并发问题的解决,与驱动配置相关的错误相关性更是较小.在动态隔离与恢复上,主要有Swift组的Nooks[13]等一系列研究成果.Nooks通过对Wrapper等接口进行检查转换,并通过语言的安全规范、虚拟内存保护、降低执行权限等机制实现隔离、恢复、兼容现有系统等目标.此方法通过动态隔离与检测机制有效防止了系统崩溃,但是仍旧不能解决因为系统环境改变或者用户输入改变而引起的错误定位以及错误恢复的问题.ShadowDriver[5]、FGFT[14]等方法则将驱动的可靠性研究集中在驱动的错误隔离与恢复上.该类方案旨在解决硬件的短暂性错误和突发错误.其中,ShadowDriver主要有active和passive两种工作模式.在passive工作模式中,主要是记录OS为驱动提供的具体数据内容,当偶发性错误发生时,驱动进入active模式,重启设备,利用passive记录的数据对对设备进行初始化,即可使设备重新正常运行.但是,配置引发的错误并不属于短暂性和突发错误的范畴.该类错误一旦发生,则需要对系统环境或者驱动本身进行修改才能解决.另外还有一些通过用户态和虚拟化等技术实现的Micro-Driver[15]、XEN[16]等方法.虚拟化方法能够有效防止驱动的恶意攻击,并且驱动崩溃不会对宿主系统造成致命影响.该技术能够通过快照等方法对环境出现的问题进行回滚,但是并不能有针对性地定位和解决这些问题.用户态驱动则主要是为了方便用户调试,并且从安全角度来看,配置错误几乎不在该类驱动的涉及范畴之内.已有的一些配置相关的工作[17]主要关心的是驱动的灵活性配置和加载的实现,甚至更多关注的是一个具体的设备驱动配置,如打印机驱动配置文件的更新[18].IComment[19]巧妙地通过对程序的注释进行学习,从注释中提取程序员标注的隐含信息,如数据格式和数值范围等,进而检查注释和程序自身的不一致性问题.该方法能够检查出一些程序错误,但是对配置错误的检查并不普适.事实上,由于系统环境或者内核改变而引起的Page4驱动配置相关的错误,可以通过对内核扩展的使用规范来进行检查并辅助解决.但是该类错误常常存在相关的语义信息,如DMA地址的对齐问题.程序在大多数系统上可能运行正常,但是当系统的硬件配置出现改变或者内核扩展使用不规范时则可能带来隐患甚至运行错误.在理论上,符号化执行技术能够从一定程度上解决配置错误问题.而实际上,由于配置的语义正确性在符号化执行中并不便于定义,因此符号化执行技术一直未能用于解决该类问题.SymDrive[20]尽管使用了符号化执行技术,但是主要是为了实现在没有设备的情况下,也可以对设备驱动进行符号化测试.因此,目前很少有方法能够有效地解决驱动配置问题.驱动配置一方面需要依赖于驱动本身的语义信息,该信息需要从设备手册或者源码的有效变量名等内容上获取;另一方面,还需要能够在出现错误时,及时发现和定位错误.本文提出AiLsDc系统对设备驱动的配置进行规范处理,另外还设计了一种通用的可转换的XML格式配置规格文档,用于在运行时对配置内容进行动态检查.该系统对一些需要约束的寄存器值以及敏感的数据结构的参数值域进行检查,阻止驱动使用错误的配置参数,及时发现可能的错误并记录相应的日志信息,以便于程序员快速定位错误并找到错误发生的原因.3驱动配置敏感模型驱动的配置主要针对设备的寄存器或者总线进行,如DMA基址寄存器的配置、打印机属项设置等.这种配置的数据常常包含相关的基址、掩码、长度限制及可能的返回值等.因此需要设计一种通用的正确的参数规格规范用于对驱动进行动态的配置检查.本节的3.1节给出一种规范的配置文档格式,3.2节给出系统依赖的检测标记插装方法,3.3节给出AiLsDc驱动配置模型.3.1参数配置规范文档的规格描述,具体规范如表2.为了便于扩展,使用XML格式进行参数配置项目文档声明〈?xmlversion="1.0"encoding="GB2312"?〉注解格式〈!-thisisanotation!--〉配置内容〈标记名属性名="属性值"…〉以文中提到的UHCI帧基址寄存器为例,基本约束条件为低12位尾对齐,转换为XML描述则如图2所示.〈?xmlversion="1.0"encoding="GB2312"?〉〈!--USBFLBASEADDregister,withlow12bitsreservedtozero!--〉〈USBFLBASEADDaddress="%UHCI_BAR_BASE%+08H",type="UINT_32",kind="W",mask=00000FFF,action="log"〉在图2中,标记名为FLBASEADD,地址约束为相应的寄存器地址.需要注意的是,%UHCI_BAR_-BASE%表示该值由系统决定,属于变量,实际上该变量即为PCI配置空间的BAR基址.type定义了该标记名的数据类型,UINT_32表示无符号32位数,而kind则表示输入输出的方向,mask表示低位无效,并执行强制检查.属性的值域具体含有的类型和属项则如表3所示,表项允许缺省.表项address寄存器地址typekindmask数值大小与type一致,对应位为1表示改位数值有length字符串长度域,type域长度等ret--缺省不检查;0非负值检查action可能违例时执行动作,默认为日志具体的语义信息规范依赖于具体的设备文档或者源码中蕴含的规格说明.在程序编码中,程序员总是会利用特殊的类型或特殊的变量名来表示特定的语义信息.因此本文欲采用源码的变量分析方法来提取部分配置规格描述XML标签内容,同时结合注释加以修正,对于不能利用该种方式规范的参数配置则从设备手册中提取.3.2配置检测标记随着计算机设备的极大丰富,驱动更是显得复杂多变,一个设备可能同时存在多个驱动,而一个驱动同样也可能兼容多款设备.兼容性的出现减少了驱动开发的工作量,但由于测试较少和协议兼容问题,同样也带来了可靠性隐患.在3.1节中已经定义了配置可以检查使用的规范文档格式,但是如何生成该类文档则成了首要的Page5问题.设定配置检查规则可辅助生成参数规范规格配置文件.在驱动中,存在大量需要规范的配置参数,该类参数包括配置的返回结果.例如,当驱动设备相关的输入函数的返回值为负时,会自动插入日志信息;对中断处理函数进行检测,检测是否出现中断风暴或者中断丢失;在DMA地址中根据SIZE进行尾对齐检查;以及定时器、设备文件、锁等规范检查,以提高驱动的可靠性.以配置相关函数返回值为负值或void返回NULL时执行日志的自动插入为例,首先需要自动定位驱动调用的可疑关键函数的返回位置的关键函数,插装检测标记,供动态运行时使用.当驱动运行时发现驱动的参数或返回值不符合参数配置规范中的描述时,则将该处的返回值和文件位置等有效信息作为日志予以记录.如DMA地址分配函数dma_alloc失败时会返回NULL,通过在驱动程序中定位dma_alloc,并插入检测标记,检查返回值是否非空,为空时则插入日志记录.同样,Linux的驱动和内核代码质量虽然良莠不齐,但是编程规范上依旧存在较多可取之处,例如变量名中可以提取出大量语义信息.IComment利用程序中的注释信息,通过自然语言处理模型分析其中源码和注释不一致时的信息.从变量名中提取语义信息则相对更为规范和有效,并且辅助进行类型检查,提取的语义信息可以用于生成配置规范XML文档,并对该变量插入检测标记,运行时根据检测标记对该变量进行跟踪分析,出现异常时执行定义的action操作.3.3AiLsDc模型AiLsDc模型由系统状态、符号集、XML规范集、初始状态、结束状态、操作集、转换函数构成,下面将分别进行描述.系统状态:模型在针对不同符号输入转移到的可能的一种执行状态,使用符号q表示,状态的集合使用Q表示.符号集:模型接受的输入符号集合,针对一个XML规格的规范文档可以提取出的具体符号作为模型的输入,具体的一个符号使用s表示,而符号的集合使用S集合表示.其中每个输入符号一般伴随一些访问方式存在,如读、写、执行等,结合具体的操作可以描述为sops.XML规范集:模型对应的配置规范规则,每个规范分离出不同规格的规范符号集,使用符号R表示,而一个配置规范规则r包含较多的属性,针对具体的属性存在不同的运算,使用符号p(r)来表示.初始状态:模型转换的初始状态,是Q的一个特殊元素,使用符号q0表示.结束状态:模型转换的结束状态,同q0一样是Q的一个特殊状态,使用符号qe表示.操作集:指针模型在转移到不同状态时可能执行的一些操作,使用符号a表示一个具体的操作,使用符号A来表示操作的集合.转换函数:用于描述模型的状态转移变化,使用符号f表示,在输入集的作用下根据规则集发生不同的状态转换,并执行不同的操作,转换函数的集合使用符号F来表示.转移函数的输入输出可以形式化描述为其中qn为模型的当前状态,此时遇到符号sops,并根据定义在规则r上的p运算结果为true时转移到状态qn+1,并执行操作a.综上,则AiLsDc模型可以表示为七元组:通过AiLsDc模型能够将XML配置规格规范文档转换成驱动源码中的检测标记,并在运行时针对检测标记执行对应的操作.以图1的XML配置规范为例,规定了驱动在对USBFLBASEADD寄存器进行赋值时,需要检查尾对齐.下面将结合AiLsDc模型进行具体阐述.其中符号FLBASEADD本身可能包含的访问方式有读和写,因此使用swrite,sread表示,为了便于描述约定va=%UHCI_BAR_BASE%+08H,而null表示不执行任何操作.F={(q0,(swrite,p1(raddress)))×f→(q1,null),上述函数转换表示,当针对一个具体的读操作时,只要地址合法即可,不执行任何操作.当遇到一个配置请求时,则需要和规格书中的掩码进行&操作,如果结果不为0则执行log操作.Page64AiLsDc系统AiLsDc系统在AiLsDc模型的基础上实现.主要包括XML配置规范文档、检测标记和运行时辅助日志记录等功能模块.通过对变量名、文档等进行分析,提取有效信息合成XML配置文档,并根据文档要求在驱动的合适位置插入相应的检测标记,最后在运行时对配置信息进行检测.当出现异常时,及时捕获出错信息,并记录日志,方便进行错误定位.通过静态分析和规则分析等方法生成驱动配置规格规范XML文档,AiLsDc系统根据XML文档对源码进行检测标记的插装,在运行时执行既定的配置参数检查.本章节将就系统的架构、XML的生成方案、日志规范记录以及动态检查的具体实现等进行详细探讨.4.1系统架构图AiLsDc系统通过对驱动配置规格规范XML文档进行分析,对设备驱动的配置源码进行自动修改,实现辅助日志记录功能.如图3所示,主要包括静态插装和动态检查两部分,前者完成源码的静态检测标记的插装,后者则是在运行时按照配置参数的要求在检测标记处执行检测操作,出现异常则自动记录其日志.图中左侧边框表示规范生成的功能范围,右侧上下虚边框内分别对应静态和动态检查的功能范畴.其中实线表示系统功能模块的数据流控制关系.同样,为了更细致地阐述系统的实现过程,下面结合AiLsDc模型进行阐述.仍以图1的XML配置规范为例,针对USBFLBASEADD寄存器的配置源码进行修改,修改前的源码[linux2.6.38,uhci-hcd.c,loc185]如图4所示.177.……184.185.…201.从图4可以看出,USB-HCD(主机控制器)对帧基址寄存器执行DMA地址的配置功能.AiLsDc对源码进行分析时,首先检查到swrite操作,并且地址为uhci->io_addr+USBFLBASEADD,执行p1(raddress)为真,故转移至q2状态,并对驱动的配置执行p2(rmask)检查,作为检测标记的形式实现在驱动源码中,由于模型本身支持对参数进行变换,因此插装的检测代码位于参数配置执行之前,修改后的源码如图5所示.177.…184.185.186.187.…203.staticvoidconfigure_hc(structuhci_hcduhci)上述伪源码实现后,对代码进行模块编译和加载后.当动态运行到此位置后,将会在第185行执行驱动配置的参数检查,如果参数配置不符合规范,将执行AiLog(AssistinsertLog)函数,具体实现的方案在4.2节细述.4.2参数与日志规范AiLsDc模型依赖于XML驱动配置规范,驱动配置规范的提取方法是模型的重要输入基础,对此,规范生成办法中包含静态分析和规则分析两种途径.其中静态分析是指通过对源码进行分析,提取其中有效的配置规范,利用变量名、函数名等提取关键的配置参数,生成XML配置规格文档.同时,可以参考IComment的实现方案,从注释中提取配置的有效语义信息.中断的出现大大提高了系统的执行效率,但是同样带来了中断风暴和中断缺失等问题.当驱动的配置发生改变后,可能引发中断风暴等问题,一旦设备发生该类问题,设备将无法正常完成相应的功能.中断风暴容易引起部分任务的处理器饥饿,而中断Page7缺失则可能造成相关进程无限等待.在Linux的驱动中,中断处理函数大都包含返回值类型irqreturn_t,函数名中包含_interrupt或_irq字段.通过分析函数名及其返回值特征,利用AiLsDc模型,在源码上插入检测标记,运行时动态检查系统的中断处理频率,在一定周期内,如果中断处理函数的频率过高,则记录可能的日志信息.如果一直没有发生中断处理请求,就可能存在中断缺失问题,同样执行异常日志记录操作.由于中断的输出日志信息可能会严重降低磁盘类驱动的性能,因此为了检查方便,对中断缺失和中断风暴记录的日志信息只包含一条日志表示已经发现中断缺失问题.当中断再次来临时,显示中断缺失已解决.在此过程中,不再输出中断缺失相关的日志.对中断风暴的处理,一旦检测到中断风暴,输出日志显示检测到中断风暴,当频数降低到规格的阈值以下时,则输出中断风暴已结束.在此过程中,不输出任何的中断风暴信息.在4.1节中已经讲述了AiLsDc的驱动配置参数检查流程.最终会根据是否违例来调用AiLog函数.日志的规范表述对于后续的日志分析具有重要意义,因而在此给出AiLog函数的实现的伪码示例,如图6所示.1.2.3.4.5.6.7.#defineAiLog(path,loc,value,type)\if(type==INT(32/16/8)orUINT(32/16/8))//数值\printk(KERN_AILSDC"AILSDC:%s%d%d\n",elseif(type==string)//字符串\printk(KERN_AILSDC"AILSDC:%s%d%s\n",else//指针等\printk(KERN_AILSDC"AILSDC:%s%d%p\n",该类型和XML中预定义的数值类型、字符串、指针类型一致.当驱动对配置的寄存器的参数不符合规范时,会执行日志记录.在传入的参数中,path由__FILE__宏决定,而loc则由__LINE__宏决定,该方案使得出现错误时,通过查看日志能够快速定位到出现问题的位置.5实用性评测实用性评测中主要针对一些提出的XML配置规则,构造测试用例,观察系统能够捕获异常.本文中使用了针对性错误注入和随机错误注入两种方法构造驱动配置异常测试情景,进而观测AiLsDc系统能否捕获该类异常行为.5.1错误注入测试为了对AiLsDc模型的检测能力进行评估,本文将使用针对性错误注入和随机错误注入等方法对Linux的驱动进行测试.其中,被测Linux版本为2.6.38,GCC编译器版本为4.3.0,测试依赖环境Fedora14.分别选择RTL8169、85567LF-3、HDA、USB驱动进行错误注入测试.对于RTL8169独立网卡和85567LF-3集成网卡驱动,针对网络MAC地址配置进行检查,当用户改变网卡地址时,能够在驱动中发现并记录日志或者输出提示信息.对于HDA声卡驱动,通过错误地修改其DMA缓存地址,使其无法正常播放,然后检测其中的错误,同时检测中断的处理频率.针对USB-HCD和USB设备驱动,则通过修改帧地址寄存器的DMA为非对齐,检查是否能够捕获该类异常等.在此基础上再进行随机错误测试,通过修改或者删除部分配置参数,使其配置逻辑发生改变,检测是否能够捕获与之相关的错误类型并记录异常日志,错误注入的测试结构如表4所示.设备驱动RTL8169网卡针对性错误注入82567LF-3针对性错误注入HDA声卡针对性错误注入USB-HCD针对性错误注入USB设备针对性错误注入需要指出的是,表4中列出的均是异常相关的错误,从而验证AiLsDc是否能够捕获该种异常.根据PCI手册,驱动配置到硬件的地址相关参数均要求物理地址对齐,同时还存在大量的隐形约束等.针对该类约束进行了正确性评测,从表4的结果看出,AiLsDc模型能够捕获到预期的异常,便于发现和快速定位相关错误.5.2注入检测分析AiLsDc系统根据驱动配置规范对驱动配置进行检查,其中包括常规的寄存器的参数检查、软硬件Page8地址检查、中断频度检查等.系统同样支持按照定义的检测规则对驱动源码自动注入检测标记,在运行时记录日志.针对Linux2.6.38的驱动部分源码进行了日志注入检查,其中主要包括,插入中断频度检测标记、关键寄存器参数检查标记、DMA地址参数检查等.从表5中可以看出,根据自定义的规则,累计插入了198处检测标记,网络相对较多.对插入检测标记后的源码进行检查,没有发现不合理的日志注入.在插入过程中,进行了严格的匹配,防止误报发生.在寄存器的参数检查中,经过检查,没有发现漏报.但是在中断频度检测钩子的检测标记的插入中,部分书写不规范的驱动将无法通过规则检测的方式注入检测标记,需要程序员增加注解,目前AiLsDc对该类问题未进行处理.5.3相关技术比较配置引起的错误常常是由于使用者改变了系统环境,或者驱动移植的环境发生了变化.在传统的可靠性问题研究中,ShadowDriver等机制通过重启驱动的方法来解决驱动出现的突发性或短暂性问题,但是并不能解决该类配置问题,也不能辅助驱动开发者快速定位和解决该错误.FTGT利用驱动的电源管理功能,按照事务性对驱动的配置进行备份,当出现错误时直接将设备状态恢复到正常状态.该方法虽然相比SD有了更高的效率,但是当系统环境变化时,之前的驱动状态将不再可用,直接恢复将会引起致命错误甚至设备的永久性损坏.例如,对DMA地址的直接配置,则可能污染系统的关键区域内存,引起系统不稳定,出现破坏系统的关键数据的现象.6性能评测由于一个具体的驱动配置规则对一个驱动的影响较小,并不能很好地评估AiLsDc的性能开销,下文中将主要针对中断风暴和中断缺失的异常日志记录开销进行评估.主流的Linux驱动都是用中断的方法与设备进行数据交换,从而提高效率,因此性能开销的评估具有代表性和普适性.本文采用标准的netperf和postmark工具对网卡和硬盘驱动进行性能测评;针对声卡,则采用录音和放音软件进行测评,针对USB控制器和USB设备则用USB存储的吞吐率和CPU占用率等指标进行对比分析.由于测试的硬件环境为X86体系结构,因此在源码arch目录下只有x86源码在统计和修改范畴之内.由于驱动性能测试与硬件实验环境息息相关,并且网络测试中需要使用服务器,因此一并给出测试的硬件环境参数,如表6所示.OSFedora14(2.6.38)Fedora14(2.6.35)CPUPentium(R)Dual-CoreCPUCache2048KB内存2GBDDR2硬盘500GB7200r/min200GB7200r/min网卡RealtekRTL-8169GigabitNetperf目前已经被广泛用于测试网络的吞吐量和资源消耗评测,并支持对TCP和UDP两种协议测试,支持RR参数测试系统的时延,同时支持STREAM测试网络系统的吞吐量.在组合测试过程中,单次测试时间均为30s,每个项目累计测试10次,并使用最小值、最大值、平均值作为实际的评测依据,使用的netperf版本号为2.6.0.RR参数测试以请求和回复的吞吐量为基准.在TCP测试中,每次收发的报文中均只有一个字节,发送缓冲区大小分别为16384Bytes,接收缓冲区大小为87380Bytes.在UDP_RR测试中,发送和接收缓冲区大小默认都是114688Bytes,同样每次接收和回复的报文中只有一个字节的数据.图7和图8分别展示的是TCP_RR、UDP_RR参数在集成网卡上的吞吐量和CPU占用情况的统计分析结果.图中的“Linux”是原始的Linux操作系统测试结果,“AiLsDc”则是在Linux上修改实现的AiLsDc图7TCP_RR和UDP_RR测试的吞吐量对比分析图Page9系统.而min、max和ave分别对应特定测试参数下的最小值、最大值和平均值.图8TCP_RR和UDP_RR测试的CPU占用率从图中可以看出,AiLsDc系统相比Linux在吞吐率上存在细微损失,虽然增加了少量的CPU利用率,但是整体性能影响均非常小.Netperf的TCP_STREAM和UDP_STREAM参数可以分别对系统TCP和UDP吞吐量进行测评.其中TCP_STREAM的接收缓冲区大小为87380Bytes,发送缓冲区的大小为16384Bytes,系统每次发送的消息长度等于发送缓冲区大小.在UDP_STREAM中,socket套接字缓存大小为114688Bytes,消息长度为65507Bytes.图9和图10分别展示的是TCP_STREAM、UDP_STREAM参数在集成网卡上的吞吐量和CPU占用情况的统计分析结果.图9TCP_STREAM和UDP_STREAM测试的吞吐量图10TCP_STREAM和UDP_STREAM的CPU占用率从图中可以看出,AiLsDc相比Linux系统的吞吐量并没有受到影响,CPU利用率相比Linux提高了3%左右,在可以接受的范围之内.本文主要通过3种途径对硬盘驱动进行评测.分别是,通过dd测试硬盘的读速度、写速度、和混合读写速度,结果如表7所示.针对文件系统则使用iozone测试文件系统的吞吐量,使用postmark测试文件系统的并发性能.评估项目读速度Linux131AiLsDc131从表7中可以看出,在Linux和AiLsDc上,dd的访问速率并没有明显降低.在计算机中,磁盘并不直接提供给上层应用使用,而是需要经由文件系统进行管理.因此这里用postmark对Linux系统和AiLsDc系统的并发性进行评测、对比和分析.测试参数设置如下,设置文件的大小为10000~20000Bytes;事务数分别为30000,50000,80000次;并发文件数从1000到4000,每隔200进行一次测试,然后针对访问速度绘制曲线图.图11和图12分别绘制的是postmark针对Linux和AiLsDc系统在不同的事务数随着并发文件数增长时,系统的Page10读写速率变化曲线图.图中“Linux(30000)”、“AiLsDc(30000)”分别展示Linux系统和AiLsDc系统在事务数为30000个时访问速度伴随并发文件数的变化趋势,图中的其它4种标识符以此类推.当事务数参数一定时,取图中对应的两条曲线分析,可以发现,AiLsDc系统相比Linux系统,性能并未受明显影响.两个系统的整体变化趋势一致,表明性能影响较小.为了测试系统改进后对流媒体的播放支持,同样对声卡驱动进行改进.声卡驱动测试主要利用rhythmbox程序播放一分钟歌曲,观察声卡驱动的CPU利用率的变化.测试结果表明,声音在AiLsDc系统上播放连续,CPU利用率和Linux系统相当,变化曲线如图13所示.在上文中提到,设备驱动除了PCI驱动,还有大量的USB串行传输驱动,因此本文针对USB驱动则主要通过对U盘的读写速度进行测试,通过hdparm工具对U盘进行读写测试.表8中展示了hdparm对三星和金士顿两款具体的设备的测试结果.两款不同厂商的U盘评测速度均表明,AiLsDc系统并没有对系统性能造成影响,读取访问速率基本一致.系统三星读写速度/(MB·s-1)Linux1189.6425.601146.5915.84AiLsDc1123.7425.591128.1115.85上面的性能评测表明,AiLsDc系统按照预定义的驱动配置规范实现后,相比Linux系统,性能上并未产生大的影响.AiLsDc系统在实现驱动配置规范检查的同时,保持了较优的性能.7总结驱动配置错误常常发生在系统管理员对系统进行修改,或者对驱动、内核进行升级,或者设备更新换代时.该类错误由于不能通过重启等方法解决,因此必须依赖于一些调试方法进行快速定位.本文设计了一个驱动配置的正确性检查模型,并在模型基础上设计并实现了AiLsDc系统,能在可能出错的部位插入相关的日志,通过对比和检查日志,使得出错时能够快速定位从而辅助纠错.实用性评测和性能评测结果表明,AiLsDc系统不仅保持了较好的性能,而且提高了驱动的可靠性.致谢本文作者得到了清华大学计算机科学与技术系操作系统实验室的老师和同学们的许多帮助和建议,在此表示感谢.同时也感谢审稿人对本文提出宝贵意见和建议!
