Page1基于模型对比和组合的软件产品线领域需求建模聂坤明1)张莉1),2)1)(北京航空航天大学软件工程研究所北京100191)2)(北京航空航天大学软件开发环境国家重点实验室北京100191)摘要软件产品线作为系统化的软件复用方式,可以提高软件的开发效率和质量.软件产品线变化性建模是软件产品线的关键技术,通过建立变化性模型以记录软件产品线成员产品的共性和变化性.目前的软件产品线变化性建模方法大都通过领域专家进行分析建立,这种方法过度依赖于领域专家的分析能力,在系统规模较小的情况下,变化性分析比较容易,但是如果系统规模变大,则系统的规模对于变化性分析的影响会越来越大.文中提出一种半自动的软件产品线领域需求建模方法,基于关注点分离的思路,利用特征模型表示软件产品线中系列产品的不同方面的特征信息,通过特征模型的对比和组合实现领域需求模型的构建.为有效地实现特征模型对比与组合,文中提出一种基于标记和结构的特征模型对比方法,同时,文中实现了基于约束的特征模型组合.基于公开的特征模型,文中对提出的方法进行了验证,实验结果表明,文中提出的领域需求建模方法能够在一定准确率的情况下有效地实现领域需求模型的构建.关键词模型对比;模型组合;特征模型;领域需求模型;需求工程;软件产品线1引言软件产品线有不同的实现策略,分别为:基于再工程的软件产品线开发方法、瀑布式的软件产品线开发方法和增量式软件产品线开发方法.对于基于再工程的开发方法,在建立软件产品线时,如果有遗留系统存在,则基于已有的软件系统分析其共性和变化性来设计软件产品线;如果没有遗留系统,则软件产品线开发方法采用传统的瀑布式软件开发生命周期模型,设计与实现一个新的软件产品线;在已经实现产品线的情况下,如果有新的软件产品需求提出,则逐步扩充当前的软件产品线,这属于增量式开发方法.在3种策略的实现过程中,分析已有的软件系统并建立软件产品线的方式是最常见的方式[1].因为现实中的软件产品线往往都是在一系列独立的领域应用基础上随着领域的逐渐成熟而出现的,因此再工程对于软件产品线方法的实际应用具有十分重要的意义.主要问题是如何在多个领域遗留系统需求的基础上通过共性和变化性分析获取领域特征模型,即领域需求模型(3.1节)[2].本文采用面向特征的领域需求组织方式,将特征作为领域需求空间的一阶实体,利用领域特征模型表示领域需求模型.基于再工程技术的软件产品线开发方法需要从遗留系统的文档或者代码中,分析不同产品间的共性和变化性.不同的产品往往会有不同的项目负责人,并且文档或代码由不同的管理人员负责.当文档或代码规模非常大以及文档或代码结构不同的时候,建模人员从中识别共性和变化性特征将会变得非常困难.不同的产品具有的特征和特征数目不同,而且产品线往往包含成千上万个可变部分(特征)和大量的约束,识别这些可变特征可能会花费数月的时间[3].在产品线中的产品系列数目少的时候,产品线建模人员还可以较容易的实现产品线变化性建模,获得变化性模型.但是当产品数目变得越来越多时,通过直接对所有不同的产品进行对比分析,集中建立软件产品线的变化性模型就变得非常困难.缺少变化性分析与建模方法及相关工具的支持,变化性建模过程过度的依赖于建模人员的经验和理解[4],导致变化性建模的效率较低,而且建立的变化性模型存在的错误较多.因此,迫切需要一种辅助产品线建模人员的变化性分析与建模方法,提高变化性建模的效率,并改进变化性模型的质量.软件产品线领域需求模型记录了不同软件产品的共性和变化性,是软件产品线变化性模型的重要组成部分.领域需求模型是变化性建模的输出制品之一.本文将领域需求模型的变化性建模称之为领域需求建模.随着软件产品线建模技术的发展,基于多视图的建模和模型组合的建模方法成为一种重要的建模方法.首先,不同建模人员可以从不同的角度实现一系列系统的不同方面的建模,然后在不同建模人员的模型的基础上进行模型组合实现软件产品线模型的构建.本文提出了一种基于模型组合的领域需求建模方法,该方法利用特征模型实现软件线中的系列产品的不同的关注点的建模,实现了基于属性图的特征模型对比和基于约束的特征模型自动组合.本文提出的方法可以在两种场景下应用:第1种场景是软件产品具有不同演化版本的产品线领域特征模型构建,由于技术变更、客户需求变化或者代码发生重构,软件产品线中的单个软件产品可能出现演化,并且具有不同的版本,此时,具有演化版本的同一软件产品可以利用特征模型建模,并基于模型组合技术建立不同软件产品的领域特征模型;第2种场景是建立多产品线领域特征模型,该方法可以用于实现多个软件产品线的领域特征模型建模,系统的系统(SoS)等大型系统往往由不同的子系统组成,不同的子系统对应不同的软件产品线,而系统的系统的产品线称为多产品线,基于多产品线的领域特征模型可以更好的实现不同子系统的定制,此时,利用特征模型实现单个软件产品线的建模,然后基于模型组合技术构建多个软件产品线的领域特征模型.本文第2节介绍相关工作,对变化性建模和模型的对比与组合工作进行分析;第3节给出基于模型对比与组合的领域需求建模方法;第4节给出实验结果,对于本文提出的方法进行了验证;最后对全文的内容进行总结.2研究现状2.1变化性建模变化性分析与建模一直是软件产品线研究的热点,本文主要对于手动、半自动、自动的变化性建模方法的研究现状进行分析.Zhang等人[5]对于软件产品线变化分析的方法进行了调研,包含FAST方法(Family-OrientedAbstraction,Specification,andTranslation)和PuLSE-Eco方法.FAST方法利用包Page3含文本和表格的领域分析文档捕获共性和变化性,基于SCV分析(Scope、Commonalities、Variabilities)实现共性和变化性的分析;PuLSE-Eco方法利用表格、产品地图来分析与区分每个产品的功能性资产的组合与关联.FAST、PuLSE-Eco等方法主要是利用表格等对于不同产品的共性和变化性信息进行对比,进而实现变化性建模.deAlmeida等人[6]基于一组不同特征对应的不同场景,提供了一种启发式的软件产品对比技术,首先寻找所有产品的共同场景,并匹配共同场景中的交互步骤,然后进行不同场景的对比.该方法同样是一种基于手动的分析建立变化性模型的方法.Wang等人[7]提出一种基于用例分析的特征模型建模方法:该方法首先定义一系列基于用例的模型抽取规则,构建单个软件系统的应用程序特征模型(AFM);然后,在AFM构建的基础上,通过一系列操作实现多个软件系统的领域特征模型(DFM)的构建.Xing[8]、Xue[9]等人提出基于抽取的变化性模型建模方法:首先,定义了产品特征模型(PFM),并将每一个产品表示成PFM;然后,利用模型对比算法实现产品线模型的建立.该方法建立的PFM只是表示了单个产品的特征信息,在识别可变特征后,需要手动建立变化性模型.本文提出的方法与Wang等人提出的方法的不同之处在于,Wang等人基于聚类构造AFM,但是模型的构造过程中缺少对于模型元素属性和模型元素依赖关系的考虑,并且没有实现模型的对比.本文提出的方法与Xing等人提出的方法的不同之处在于,该方法只提出了一种模型对比方法,而没有实现模型组合.2.2模型对比与组合模型对比的方法可以分为4类,包含基于特征的模型对比、基于标记的模型对比、基于相似度的模型对比和基于语言的用户定制模型对比[10].Xue等人[11]将模型对比看作是寻找两个类型属性图的最大通用子图(MaximumCommonSubgraph).Xing等人[12]实现了类图的对比,该方法基于结构相似度实现了对比,但是主要的应用对象为类图.Mandelin等人[13]指出同一个软件的不同版本的软件体系结构模型往往不同,该方法将体系结构模型转换成图,利用贝叶斯模型实现模型的对比.Koegel等人[14]指出基于相似度和基于操作对比是两种重要的模型对比方法,而且两种方法都无法区分概念层次的差异,只能实现语法层次的对比.模型组合是一种非常重要的模型分析方法[15],在数据库集成、WebServices组合、状态图组合、产品线模型组合、UML模型组合、过程模型组合、面向方面建模等领域都有应用[16].Nejati等人[17]针对电信领域的层次状态机模型,实现基于Match算子和Merge算子的变化性模型对比与组合,Match算子基于启发式方法寻找模型中的匹配元素,Merge算子实现模型元素的自动组合.Apel等人[18]提出将软件程序的层次结构表示成特征结构树,然后利用模型的叠加技术实现模型的组合,该方法在大规模程序上的应用效果还需要进行深入研究.Acher等人[19]利用插入和组合两种操作算子实现特征模型组合,并定义了每个操作算子的语义.模型组合有基于规则的模型组合、基于逻辑表达式的模型组合等不同的方法.虽然目前有多种不同的模型对比与组合方法,但是由于应用领域不同,许多方法都无法直接应用于特征模型的对比与组合.特征模型组合分为基于规则的组合方法[20]和基于逻辑表达式的组合方法等方法.基于规则和基于逻辑表达式的组合方法各有优缺点[21],基于逻辑表达式的方法的缺点是不易保持模型的层次结构,而且时间复杂度是指数级的,因此本文采用基于规则的组合方法实现模型的组合.参考Acher等人的方法,本文定义了插入算子和组合算子,实现特征模型组合,同时,本文提出一种基于约束规则的模型组合方法.3基于模型对比与组合的领域需求建模软件产品线中一般包含多个不同的软件产品,并且不同软件产品的软件组件可能涉及不同的专业.例如,在舰船指挥控制系统等软件密集型系统中,硬件系统可能跨越不同的专业领域,针对不同的硬件对象,软件系统中具有不同的功能组件(界面显示、算法处理等)与之相关联.不同的硬件对象及相应的功能组件等往往由不同专业的人员开发,该专业相关的工程人员掌握这些硬件和软件组件的信息,比较容易实现相关模型的建模.同时,由于软件产品跨越不同的专业,需要不同专业的领域专家之间的协同建模,才能更好的实现整个软件产品的建模.基于关注点分离的思路,不同专业领域的建模人员关注系统的不同方面并实现建模.不同于传统Page4的基于领域专家调研的领域分析与建模方法,本文提出一种半自动的领域需求建模方法:首先,不同建模人员对于软件产品线中的一系列系统的不同方面进行建模,建立特征模型;然后,在建模人员建立不同的特征模型后,基于特征模型的对比和组合算法辅助建立软件产品线的领域需求模型.基于本文提出的方法,建模人员首先建立一系列系统的不同方面的特征模型,建模人员可以在遗留系统逆向工程的基础上建立系统的不同方面的特征模型.由于特征模型由不同的建模人员分别建立,其特征模型之间可能出现重叠,因此如何识别两个特征模型的重合特征是一个需要解决的问题.在识别出两个特征模型的重合特征后,如何准确的实现两个特征模型的组合是另一个需要关注的问题.如图1所示,在建立特征模型后,利用本文提出的模型对比算法实现不同模型的对比,可以分析出不同模型的差异.基于不同模型的差异,并且利用模型的组合算法,对于不同的模型进行组合,实现领域需求模型的半自动构建.对于同一个特征,不同的领域专家表达方式可能不同,导致专业背景不同的领域建模人员建立的模型无法直接进行对比.为了避免在建模过程中出现建模词汇不一致的情况,在建立特征模型之前,首先建立软件产品线的领域词汇表,然后建模人员基于领域词汇表,建立特征模型.3.1特征模型在软件产品线建模过程中,领域需求模型是领域分析过程输出的一种重要制品.特征模型是捕获特定领域可复用软件需求的一种重要技术手段.领域需求模型可以利用特征模型表示,本文利用特征模型描述不同软件产品中的某一个方面的特征和它们之间的关系.领域特征模型描述了该领域内所有产品的共性和可变的特征信息,通过记录领域内的一组相对稳定的特征以及特征之间的关系反映该领域的软件共性和可变需求.特征模型可以通过该领域内的领域专家提供,也可以利用逆向工程建模.图2是特征模型的元模型,一个特征模型是特征的层状结构,特征模型中的每个特征都具有唯一的名称.特征模型必须包含根(Root)特征.每个特征都能够分解为子特征.父特征和子特征之间的变化性关系具有4种,分别为强制性(Mandatory)表示当父特征被选中后,该子特征必须被包含在所有的产品中;可选择性(Optional)表示该子特征是可选的,在软件产品的配置过程中,可以选择该特征,也可以不选择;选择性(Alternative)表示父特征有多个可选的子特征,在软件产品的配置过程中,如果父特征被选中,只有一个子特征可以被选中并包含在最终的产品中;多选性(Or)表示在软件产品的配置过程中,可以从父特征的多个子特征中选择多个特征.除了父特征和子特征之间的变化性关系,特征模型的特征之间还存在约束关系:依赖和互斥.依赖(ARequireB)表示包含特征A的产品也必须包含特征B,互斥(AExcludeB)表示包含特征A的产品必须不能再包含特征B.3.2特征模型对比在特征模型中,如果特征模型中具有大量的约束关系,则特征模型形成一种图状结构,因此传统的基于树对比的模型对比方法不能直接用于实现特征模型的对比.属性图(AttributedGraph)是在传统的图的基础上考虑了每个节点的属性的图.本文在实现模型对比的时候,将特征模型表示为属性图,完整的表达模型元素的属性和类型,将特征模型中的变化性关系利用属性图中的属性表示.其中,将特征模型中的约束关系表示为属性图中的边.本文的模型对比分析主要实现不同的特征模型之间的重合特征和变更特征的识别,以便基于分析结果实现特征模型组合.定义1.属性图.属性图G可以标记为三元组G=(V,E,A),其中,V表示N个节点的集合,E={(vi,vj)|1i,jN,i≠j}是边的集合,A={a1,a2,…,am}是与V中的节点相关联的m个属性的集合,以描述节点的属性.节点集合V中的每个Page5节点v的属性都可以用长度为m的属性向量犃(v)={a1(v),a2(v),…,am(v)}描述.其中,aj(v)是节点v的第j个属性的属性值.基于图2所示的元模型,本文将特征模型中的每个模型元素的相关信息,利用Type、Name、Attribute进行标识.Type表示元模型中定义的模型实体类型,包含Feature、LeafFeature;Name是特征模型中节点的名字;Attribute包含特征模型元模型中定义的4类变化性关系:Mandatory、Optional、Alternative、Or,同时Attribute中也记录了特征模型元素具有的属性信息.本文将特征模型中边的信息利用Type、Name、Src、Dst进行标识.边的Type类型为Require、Exclude,即将特征模型中的Require和Exclude约束关系利用边的属性进行区分.定义2.节点与边的标记.节点的标记(signa-ture)包含Type、Name信息,设n是图中的一个节点,signature(n)=Type(n)/Name(n),如果一个节点没有名字,则标记中的名字对应为空字符串.设e是图中的一条边,它的源节点和目的节点分别是src和dest,则边的标记包含Type、Name、Src、Dst信息,它的标记为signature(e)=signature(src)/Type(e)/Name(e)/signature(dest).定义3.节点的标记相似度.给定两个需要进行对比的特征模型M1和M2,其中,M1为基础模型,M2为对比模型.设v1和v2分别是两个模型中的任一节点,则两个节点间的标记信息匹配signature(v1)=signature(v2),当且仅当两个节点的标记字符串相同.基于标记的边对比的计算方法相同.定义4.节点的结构相似度.给定两个模型M1和M2,设v1和v2分别是两个模型中的节点,v2和v1的结构相似度为v2和v1的匹配的边的数目.对基础模型中的每一个节点,利用基于节点标记的模型对比算法计算模型元素的相似度.在对比过程中,有可能一个模型元素对应多个相似度较高的元素,即包含多个候选元素.此时,利用基于结构的对比方法实现候选元素的选择,即从候选节点中选择结构相似度最大的节点.模型的差异一般分为3种:元素增加、元素删除、元素变更,借鉴DSMDiff[22]的模型对比结果,本文实现的特征模型的对比结果包含:特征增加、特征删除、特征变更.相应地,特征模型中变化性关系的对比结果包含:变化性关系增加、变化性关系删除、变化性关系变更.算法1为基于标记和结构的特征模型对比算法,由于篇幅原因,模型对比算法中没有给出边的对比部分.在算法的实现过程中,如果存在某个节点为增加的节点,则可以进行该节点的子孙节点的对比.如果子孙节点的所有节点在基础模型中都没有出现,则将其子孙节点也都标记为增加的节点.在特征模型对比算法中,首先根据待对比的基础特征模型和对比特征模型,构建属性图baseGraph和compGraph,然后初始化基础模型节点集合baseSet和待对比模型节点集合compSet以及节点增加集合nodeAddSet,节点删除集合nodeDeleteSet和节点变更集合notChangeMap.对于基础模型节点集合中的每个节点baseNode,利用基于标记的方法计算相似度.如果找到与baseNode匹配的唯一节点,则加入节点匹配集合.如果找到多个与baseNode匹配的节点,则利用结构相似度计算方法,寻找与baseNode相似度最高的节点.在对比完成后,如果待对比模型节点集合compSet不为空,则将其所有节点加入到节点增加集合.对于节点匹配集合中的每一组节点,计算其属性的相似度,并将特征属性发生变更的节点加入节点变更集合.算法1.特征模型对比算法.输入:基础特征模型M1和对比特征模型M2输出:特征模型的对比结果1.readbasemodelM1andcomparemodelM2;2.initbaseGraphandcompGraph;3.setbaseSet,compSet,nodeMappingMap,nodeAddSet,4.FOREACHbaseNode∈baseSet5.FOREACHcompNode∈compSet6.result=signatureSimilarity(baseNode,7.IFresult=18.number=numebr+1;9.ENDFOR10.IFnumber=111.addmap(v1,v2)intonodeMappingMap;12.deletev1frombaseSet,deletev2fromcompSet;13.ENDIF14.IFnumber=015.addv1intonodeDeleteSet,deletebaseSetfromv1;16.IFnumber>117.Ver=maxStructureSimilarity(baseNode,18.addVer(v1,v2)intonodeMappingMap;19.deletev1frombaseSet,deletev2fromcompSet;Page620.ENDIF21.ENDFOR22.IFcompSet〈〉NULL23.addallnodeincompSetintonodeAddSet;24.ENDIF25.FOREACH(node1,node2)∈nodeMappingMap26.sim=attributeSim(node1,node2);27.IFsim>028.addnodeintonodeChangeMap;29.ENDIF30.ENDFOR在特征模型对比算法中,signatureSimilarity()实现了基于标记的节点相似度对比,对比方法采用字符串匹配的方式实现.maxStructureSimilarity()实现了基于结构的节点相似度对比.attributeSim()利用基于标记的对比方法实现了属性相似度的对比.模型对比的输出结果为两个属性图的对比结果.假设两个不同的模型为M1和M2,匹配的模型元素和关系的集合为M,不匹配的模型元素和关系的集合为{I1,I2},其中,I1和I2分别代表模型M1和模型M2中的元素.不匹配的元素集合中包含:{增加的模型元素、减少的模型元素、变更的模型元素}.如果存在多个特征模型,则可以采用增量的模型对比和组合方法,首先对比两个模型,然后逐渐增加模型,实现多个模型的对比.在模型的对比结束后,会得到模型的匹配元素和各个模型的不匹配的元素,然后利用模型组合规则实现模型的组合,最终得到软件产品线领域特征模型.3.3基于插入与组合算子的模型组合在不同建模人员建立多个产品的不同方面的特征模型后,基于模型组合建立领域特征模型.由于模型组合可以分解为一系列两个模型的组合,因此,在模型组合的过程中,首先选择一个基础模型,然后其余的模型都与此模型进行对比并进行组合.基于模型对比的结果,模型组合对于增加、变更的特征和增加、变更的特征关系进行处理,在模型的组合过程中,如果不考虑模型中的约束,则增加一个特征,必然增加相应的父子特征关系,因此只对于模型中增加的特征进行处理即可.但是由于特征模型中约束的存在,需要对于具有约束的特征模型进行单独的处理,对于模型中约束的处理,将在3.4节介绍.由于减少的特征很难直接判断其组合语义,无法通过自动的方式进行组合,则需要在模型组合完成后进行人工的调整.模型组合主要实现将待组合模型准确地组合到基础模型中,同时保持模型的语义不发生变化.对于特征模型的组合,主要实现特征模型元素变化性关系和约束关系的变更.基于模型组合过程中的不同组合需求,同时参考Acher等人[19]的工作,本文定义了两种算子,分别是插入算子和组合算子,并且基于两种算子实现特征模型的组合.定义5.插入算子(Insert).插入算子的目的在于将模型新增的元素插入到基础模型中.如图3所示,插入算子主要针对待插入模型中的新增加的元素,将新增的元素插入到基础模型中的对应位置.该算子主要应用于基础模型和待插入模型没有重合元素的情况.插入运算符(算子)的语法定义如下:Insert(insertFeature:Feature,insertpointFea-插入算子需要3个输入:待插入基础模型的目标特征、基础模型的待插入子特征位置的特征和插入算子,其中,insertFeature指定了待插入到基础模型中的模型的目标特征;insertpointFeature是基础模型中的特征,表明待插入特征的插入位置;在待插入特征插入到基础模型后,operator算子实现基础模型元素变化性关系的调整.在该插入算子的实现过程中,要求待插入模型和插入模型没有交集,以保证两个模型在插入过程中不会出现冲突,如果两个模型存在交集,则需要首先将该模型的公共子模型插入到基础模型中.模型元素的插入规则如表1所示,Base列表示insertpointFeature与其子特征之间的关系,Leaf行表示该特征没有子特征.Insert行表示insertFeature与其父特征的关系.Null列表示insertFeature特征Page7没有父特征.在模型元素插入过程中,基于表1的插入规则,实现模型元素插入过程中模型元素变化性关系的调整.BaseLeafMandatoryOptionalMandatoryOptionalOptionalMandatory/OptionalMandatoryOptionalMandatoryOptionalOptionalAlternativeAlternative/OrMandatoryOrMandatoryOrOr基于特征模型中的变化性关系和约束关系,特征模型可以表示为一系列不同配置的集合,以表示该特征模型可能配置出的不同产品,一个配置对应从特征模型中选择的一系列特征.在模型元素插入的过程中,插入规则是为了尽量保持基础模型中的变化性关系不变,同时将待插入模型插入,即基础模型的配置的集合至少是插入后的模型的配置集合.设{BaseFM}是基础模型配置的集合,{InsertFM}为待插入模型配置的集合,{InsertedFM}为插入后的特征模型配置的集合,插入后的特征模型应该满足条件{BaseFM}{InsertedFM}.为了使得基础模型的配置集合能够将待插入模型补充进来,需要保证{BaseFM}{InsertFM}{InsertedFM},其中AB={a∪b|a∈A,b∈B},a和b分别为A和B中的集合.如果待插入特征不具有父特征,则直接将该元素插入到基础模型中.如果插入一个与父特征关系为Alternative或Or的特征,为了保持其变化性关系,则将该特征的变化性关系变更为Mandatory或Optional后插入.在待插入特征与父特征变化性关系为Manda-tory,而插入位置的特征与子特征变化性关系为Alternative的情况下,会发生冲突.如果保持待插入特征的Mandatory关系,则Alternative关系遭到破坏,而如果保持基础模型的Alternative关系,则待插入特征的Mandatory关系会破坏,此时,需要用户指定模型元素插入后的变化性关系类型.根据上述插入规则的基本原则,定义表1中的插入规则.如果基础模型中待插入特征位置为叶子节点,则Mandatory和Optional节点插入后的元素变化性关系不变,而如果插入位置的特征与子特征变化性关系为Alternative和Or,则插入后,元素变化性关系为Mandatory和Optional.在基础模型中插入位置的特征与子特征变化性关系为Mandatory或Optional的情况下,如果待插入特征的变化性关系为Alternative或者Or,则插入基础模型后,基础模型的元素变化性关系变为Mandatory和Optional.如果基础模型中插入位置的特征与子特征变化性关系为Alternative,则除了待插入特征的变化性关系为Mandatory关系,任何待插入特征在插入基础模型后,元素变化性关系都为Alternative.如果基础模型中插入位置的特征与子特征变化性关系为Or,在待插入特征的变化性关系为Mandatory和Alternative情况下,基础模型的变化性关系变更为Mandatory.定义6.组合算子(Merge).组合算子的目的是组合两个模型的重合部分到一个模型中,实现两个模型的集成.组合算子主要针对两个模型中共享部分特征的情况,如图4中,“操作系统”和子特征之间的关系,左边模型为Alternative关系,右边模型中为Or关系,而两个模型组合后,OS和子特征之间的关系变更为Or.组合运算符(算子)的语法定义如下:Merge(mergeFeature:Feature,baseFeature:组合算子需要3个输入:待组合模型中的待组合特征、基础模型的组合位置和组合算子.其中,baseFeature是基础模型中的特征,表明待组合模型的组合位置;mergeFeature指定了待组合模型的待组合特征;operator实现待组合模型组合到基础模型后,基础模型元素变化性关系的调整.当待组合模型组合到基础模型中时,有两种不同的模型组合策略:一种组合策略是基础模型中的模型元素被保留,同时待组合模型中的元素被添加到基础模型中;而另外一种组合策略是保留基础模型和待组合模型两个模型元素中的共同部分.本文Page8采取第1种组合策略,因为第2种组合策略在组合过程中会丢失一部分特征.在特征模型组合后,特征模型的变化性关系发生变化,其可能的配置会发生变化.为了保证基础模型和待插入模型组合后不丢失正确的配置,基础模型和待插入模型的配置集合必须是组合后的模型的配置集合的子集.设{BaseFM}是基础模型配置的集合,{MergeFM}为待组合模型配置的集合,{MergedFM}为组合后的特征模型配置的集合,组合后的特征模型应该满足条件{BaseFM}∪{MergeFM}{MergedFM}.模型元素的组合规则如表2所示.如果基础模型中的特征与子特征之间的变化性关系是Mandatory,则组合具有Mandatory、Optional、Alternative和Or关系的模型后,特征与子特征之间的变化性关系为Mandatory、Optional、Alternative和Or.如果基础模型中的特征与子特征之间的变化性关系是Optional,则组合后的模型的变化性关系全是Optional.如果基础模型中的特征与子特征之间的变化性关系是Alternative,则组合后的模型的变化性关系为Or、Optional、Alternative和Or.如果基础模型中的特征与子特征之间的变化性关系是Or,则组合后的模型的变化性关系为Or、Optional、Or和Or.BaseMandatoryMandatoryOptionalAlternativeOrOptionalOptionalOptionalOptionalOptionalAlternativeOrOptionalAlternativeOrOrOrOptionalOrOr本文的组合操作实现基于结构的模型组合,对于在组合过程中变化性关系发生变化的节点,利用组合算子进行变化性关系的变更.首先将变化性关系变更为对比模型的变化性关系,然后利用插入算子对应的算法,将对比模型中的节点依次加入到基础模型中.模型组合算法的实现步骤如算法2所示.在模型组合算法中,首先获取特征模型的对比结果,对于节点变更集合中的每个节点nodeChange,判断该节点是否有子孙节点属于节点变更集合,如果没有节点属于节点变更集合,获取nodeChange节点在基础模型中的组合位置,并基于表2计算模型组合后的节点变化性关系变化iOp,将基础模型的插入位置的节点变化性关系变更为iOp.对于节点增加集合的每个节点nodeAdd,如果该节点具有约束,并且nodeAdd节点的子孙特征中存在增加的节点nodeChildAdd,则以递归的方法实现nodeChildAdd节点为根的模型的组合.获取待插入模型中的增加节点,并依次将这些节点插入到基础模型中.如果nodeAdd节点具有约束关系,则在nodeAdd节点组合完成后,利用算法3实现约束关系的处理.算法2.特征模型组合算法.输入:基础特征模型和待组合特征模型输出:组合后的特征模型1.FOREACHnodeChange∈(nodeChangeMap∩2.IFnodeChildChangeisdescendantofnodeChange3.modelMerge(baseModel,MergeModel:4.ENDIF5.gettheinsertpositionmFeatureofnodeChangein6.iOp=computeOperator(mFeature,nodeChange);7.changeBaseModelOperator(iOp);8.deleteNodeFromChangeMap(nodeChange);9.IFnodeChangehasconstraint10.mergeWithConstraints(baseModel,MergeModel,11.ENDIF12.ENDFOR13.FOREACHnodeAdd∈(nodeAddSet∩MergeModel)14.gettheinsertpositionmFeatureofnodeAddin15.IFnodeChildAddisdescendantofnodeAdd16.modelMerge(baseModel,MergeModel:17.ELSE18.modelInsert(baseModel:mFeature,MergeModel:19.ENDIF20.IFnodeAddhasconstraint21.mergeWithConstraints(baseModel,MergeModel,22.ENDIF23.deleteNodeFromAddSet(nodeAdd);24.ENDFOR3.4基于约束关系的特征模型组合由于特征模型的特征之间具有约束关系,在特Page9征模型规模比较大的时候,待组合的两个特征模型的约束关系可能存在冲突.在特征模型组合过程中,如果不考虑约束关系,则在特征模型组合后,会出现错误的模型组合结果.因此,特征模型组合算法需要考虑特征模型元素之间的约束,并处理特征模型的约束冲突.基于约束关系的模型组合算法如算法3所示,算法是约束关系为Require情况下的组合算法.参考文献[7]提出的模型组合方法,在特征模型组合过程中,依次判断基础模型和组合模型中的所有约束关系,并根据约束关系在待组合模型和基础模型中的不同情况进行约束关系的处理.算法3.基于约束的模型组合算法.输入:基础特征模型和待组合特征模型输出:基于约束的模型组合结果1.IFnode∈MergedModelexistRequire〈node,n〉2.IFndonotinbaseModelMergedModeldonot3.delete〈node,n〉fromMergedModel;4.ENDIF5.IFninbaseModel6.IFMergedModeldonotcontainRequire〈n,node〉,7.IFMergedModeldonotcontainRequire〈node,n〉,8.delete〈node,n〉fromMergedModel;9.ENDIF10.ENDIF11.IFbaseModelcontainRequire〈n,node〉12.delete〈node,n〉fromMergedModel;13.delete〈n,node〉frombaseModel;14.ENDIF15.ENDIF16.ENDIF在基于约束的模型组合算法中,对于约束关系Require〈node,n〉,算法的第2~4行实现约束关系Require在基础模型中不存在情况的处理,算法的第5~14行实现约束关系Require在基础模型中存在情况的处理.4实验为验证本文提出的特征模型对比和组合方法的有效性,基于现有的特征模型,本文对于提出的方法进行了验证,首先对于算法的复杂度进行分析,然后对于算法的准确率和召回率进行对比分析.本文基于开源特征建模工具FeatureIDE①实现特征模型的建模.4.1实验数据来源实验所需的特征模型一部分从软件产品线在线工具SPLOT②中获取,另外一部分从相关公开的文献中获取.如表3所示,第1组数据(图5)来自于文献[20],第4组数据来自于文献[23].第2组和第3组数据从SPLOT中获取.第5至第7组数据也是从SPLOT获取,这3组特征模型中包含的特征数目分别为60,88和168.另外,由于现有的特征模型中,包含的约束数目较少.领域特征模型特征模型11MobilePhone15021811142InsurancePolocy20202301203AndroidSPL40204403394BerkeleyDB30003501305SmartHomeV2.260205001456ModelTransformation80008500737FM_Test150440156010153第1组实验数据如图5所示,两个特征模型既存在相同的特征,也存在不同的特征.其中,特征USB和特征SMS都具有属性.第2个特征模型中具有特征“游戏”依赖于特征“Java支持”的约束关系.除了第1组数据可以直接用于实验分析,其余进行模型对比的两个模型,都需要进行构造,将特征模型分拆为两个不同的特征模型.在特征模型分拆①②Page10为两个不同的特征模型后,两个特征模型之间既有共同的特征,也有存在差异的特征.将构造的两个不同的特征模型作为需要组合的特征模型,然后对比实验结果.表3为特征模型对比与组合的实验数据集,“特征模型1”和“特征模型2”为模型对比与组合的输入.其中“特征模型1”和“特征模型2”的特征个数不同,存在的约束数目也不同,“特征匹配数目”列表示两个不同的特征模型中相同特征的数目.4.2模型对比实验(1)时间复杂度分析在模型对比算法中,设每个模型的节点的个数为N,在算法中,基于结构的对比的算法部分的复杂度为O(N×logN).因为在算法的执行过程中,极端情况下,每个模型中的节点,都要进行基于结构的对比,因此,算法的时间复杂度为O(N2×logN).(2)准确度对比为分析模型对比算法的实验结果,借鉴文献[11]提出的实验结果评价方法,设两个特征模型分别为M1和M2,其中,期望的模型对比结果表示为Me=〈f1,f2,changetype〉,实际的模型对比结果表示为Mr=〈f1,f2,changetype〉,其中f1是M1中的特征,对应的M2中的特征是f2,changetype表示对应的变更类型.利用准确率和召回率实现模型对比的评价,准确率和召回率的计算公式分别为:准确率的计算公式为Mr∩Me/Mr;召回率的计算公式为Mr∩Me/Me.表4为本文提出的方法在4组实验数据集中的实验结果,模型对比实验结果较好的原因是用于模型对比的特征模型中都没有命名差异.数据集(3)不同方法的对比将本文提出的方法与其余的3种方法进行对比,分别是GenericDiff[8]、SiDiff①和TReMer+[17].其中,GenericDiff基于类型属性图实现模型的匹配,但是并没有实现模型的组合方法.SiDiff基于模型元素的匹配实现模型对比,模型的位置改变也考虑在内.TReMer+实现可变的特征规格的对比.不同方法数据集准确率/%召回率/%GenericDiffSiDiffTReMer+从表4和表5中可以看出,所有的模型对比方法的实验结果都比较好,这是因为对比的模型之间没有复杂的约束关系.对于实验数据集2,GenericDiff和TReMer+的实验效果都比其它实验数据集差,这是因为本文提出的方法能够实现具有约束关系的边的检测,而其他方法都没有实现此功能.TReMer+主要用于层次状态机模型的对比,因此在实现特征模型对比过程中,错误率比较高.4.3模型组合实验模型对比完成后,利用模型组合算法实现模型的组合,本文对模型组合的时间复杂度进行评价.在模型组合过程中,待组合的节点根据模型对比的结果确定.因此,设两个模型具有差异的节点个数为常数K,节点个数为N,在组合过程中,需要遍历图寻找待组合节点的父节点,该分析的时间复杂度为O(K×N×logN).在模型组合过程中,基于约束规则的组合算法的时间复杂度为O(N2).对实验数据集中的第5至7组数据(表3),利用本文的模型组合算法进行实验,并对于时间效率进行对比,如图6所示.其中,横轴为两个模型中匹配的模型元素数目,纵轴为模型组合的执行时间,单①SiDiffprojectwebsite[EB/OL].http://pi.informatik.Page11位为ms.3个特征模型的模型规模,即包含的特征数目分别为60,88,168.从图6可以看出,随着特征模型的特征数目的增加,所有模型的组合时间都缓慢的增加,这与时间复杂度分析的结果一致.当模型中匹配的元素数目相同,规模大的模型的时间花费比规模小的模型的时间多.5结论传统的软件产品线领域需求建模方法大都依赖于领域专家的分析,在模型比较复杂或者开发者对于模型并不熟悉的情况下,变化性分析难以手动实现.尤其是在领域内的模型非常庞大或者软件产品线中包含非常多的产品数目时,变化性分析变得非常困难.本文提出一种基于模型对比和组合的领域需求建模方法,实现基于属性图的特征模型对比方法,并实现基于约束规则的特征模型组合.本文提出的领域需求建模方法能够在一定准确率的情况下有效的进行领域需求模型的构建.但是,本文提出的模型组合方法,在特征模型的约束关系较为复杂的情况下,模型组合的错误率会比较高,本文将继续对于复杂约束条件下的模型组合技术进行深入的研究.致谢匿名审稿人对本文提出的宝贵修改意见,在此表示感谢!
