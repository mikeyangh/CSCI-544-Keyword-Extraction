Page1一种面向传感器网络应用程序的有效测试方法孙玉霞1),2)HARROLDMaryJean3)张成志4)汤庸5)1)(中山大学计算机科学系广州510006)2)(暨南大学计算机科学系广州510632)3)(乔治亚理工大学计算机学院美国亚特兰大30332)4)(香港科技大学计算机科学与工程系香港999077)5)(华南师范大学计算机学院广州510631)摘要无线传感器网络是物联网的基本组成部分.随着传感器网络的广泛应用,其软件质量的问题日益突出.传感器网络应用程序中的瞬态错误很难被发现,这是因为它们由偶然交织的事件处理逻辑所触发,而且有效的自动测试预言往往不可得.基于区间的测试方法将传感网程序的执行过程划分为若干区间,并检测包含瞬态错误的区间,但是这种方法可能产生大量的误报.文中详述了对这些误报进行深入研究的结果,并进而提出一种有效的基于区间的测试方法,用于检测传感网程序应用级组件中的瞬态错误.此方法的主要特点是采用新的区间划分策略和程序行为选择策略.这些策略用于排除被分析区间中的良性偶然交织行为.文中提出了一种区间识别算法,并在此基础上实现了该方法的一个原型工具.文中给出了一组实验来评估原型工具的效果和效率.实验结果表明,此工具能够有效而高效地检测被测程序中的瞬态错误.关键词物联网;无线传感器网络;瞬态错误;基于区间的测试;误报1引言无线传感器网络是物联网感知事物和传输数据的重要手段,具有大规模、自组织、拓扑动态变化和节点资源受限等特征.随着物联网的兴起,无线传感器网络的应用日益广泛.然而,如何开发高质量的软件仍是目前制约传感网应用的难题之一[1].实际的传感网应用系统常常因为软件错误而出现各种不可预期的故障[2-3].当人们把传感网部署到实际环境(特别是人难以到达的环境)之后,受环境条件所限,往往很难进行软件的查错和排错.因此,部署前的程序分析与测试对传感器网络十分重要,本文的研究内容属于此范畴.传感网程序具有数据流驱动的特征,因此我们在动态测试传感网程序时,往往需要将程序的执行轨迹划分成区间,通过检测包含错误程序行为的区间来发现程序中的错误.本文称这类测试方法为“基于区间的测试方法”.每种基于区间的测试方法都包括以下4个关键策略:(1)“区间的划分策略”:测试方法在划分程序的执行轨迹时,所使用的区间可能是某类数据的处理区间,或者某类操作的连续两次执行点之间的区间等;(2)“程序行为的选择策略”:测试方法在捕获发生在一个区间中的程序行为时,可以有选择地捕获其中的部分程序行为,比如只捕获那些处理某类数据的程序行为;也可以捕获所有的程序行为;(3)“程序行为特征的选取策略”:对一个区间而言,测试方法所选取的程序行为特征可以是指令执行的计数、指令执行的序列、函数调用的序列、或内存位置的访问序列等;(4)“错误区间的检测策略”:测试方法为了检测包含错误行为的区间,在已知错误模式时可采用模式匹配等技术;而在未知错误模式时可采用数据挖掘、机器学习或统计的技术,找出可能包含错误行为的区间,并以人工检查辅助判断.本文所关注的是,如何采用恰当的策略(1)和策略(2)来提高基于区间的测试方法的有效性.传感网应用程序是事件驱动的网络嵌入式系统,它通过协同的事件处理逻辑来实现[4].当具有隐式依赖关系的处理逻辑在执行中偶然交织时,就可能产生瞬态错误,并可能导致严重的失效[5].这些错误的显现很短暂,而且用于揭示它们的有效的自动测试预言(TestOracle)往往不可得,因此这些瞬态错误很难被发现,从而很容易残留在部署后的代码中.TinyOS操作系统是传感器网络在节点级编程的事实上的标准平台,其应用程序采用nesC语言,基于组件编写而成[6].TinyOS系统级的组件被广泛地使用并得到频繁的测试.因此在TinyOS的应用开发中,我们通常需要重点测试其应用级的组件.本文研究如何有效地检测这些应用级组件中的瞬态错误.为了发现传感器网程序中的瞬态错误,Zhou等学者[5]提出了一种基于区间的测试方法Sentomist.此方法在对程序的执行轨迹进行区间划分时,采用的是指定中断的中断事件处理区间.Sentomist方法的基本思想是:在上述区间中,程序处理同类型的中断事件(即指定的中断事件),因此这些区间中所发生的正常程序行为应当具有统计相似性,而偶然的程序行为则很可能是瞬态错误的表现.Sentomist的程序行为选择策略是捕获发生在每个区间中的所有程序行为,而程序行为的特征是指令的执行计数.Sentomist根据指令计数对这些区间进行聚类,把对应着聚类离群点的区间看作可能包含瞬态错误的区间,而且离群值越大的区间越可疑;它使用一种异常检测算法对这些区间进行自动排序,区间的排序越靠前表示其包含瞬态错误的可疑度越高.在Sent-omist方法中,如果一个“正确区间”(即实际上不包含瞬态错误的区间)排在某个“错误区间”(即实际上Page3包含瞬态错误的区间)之前,那么前者就是这种方法的误报.对于瞬态错误而言,错误区间的个数非常有限.本文根据Sentomist方法对这些错误区间的排序结果来衡量该方法的有效性.当我们将Sentomist方法用于检测传感网程序在应用组件中的瞬态错误时,发现它产生了大量的误报.这种误报需要通过人工检查来排除,而人工检查是耗时而高成本的.比如根据我们在实验中的经验,检查一个区间往往需要查看100(甚至1000)个以上的包含程序执行信息的字符串,而让一个测试者一次检查20个以上的区间通常都是困难的.因此,降低误报是该方法的重要目标.我们实现了新测试方法的一个原型工具,并执行了一组实验来评估它的效果.在所有这些实验中,我们的方法都将错误区间排在了最靠前或很靠前的位置.实验结果表明,和现有的测试方法相比,(1)本文测试方法明显地改善了误报问题.例如,它可将错通过分析误报产生的原因,我们发现此方法的有效性高度依赖于区间划分策略,无效的划分策略会导致大量的误报.Sentomist方法所使用的区间是底层系统级事件(即中断事件)的处理区间.然而,发生在此区间的程序偶然行为未必就代表应用组件中的瞬态错误,而有可能是良性的偶然行为(详见第3节).我们还发现此方法的有效性也受程序行为选择策略的影响.Sentomist采用了捕获区间中“所有程序行为”的策略,其背后的假设是“正确区间内的所有程序行为都具有相似性”.然而,在上述“指定类型事件的处理区间”中,也有可能发生处理各种其它类型事件的行为;而在正确区间中所发生的、“处理不同类事件的行为”未必具有相似性.为了解决上述的误报问题,我们提出了一种新的基于区间的测试方法.根据测试者所指定的“应用级事件”(即在应用级组件中定义的事件),新方法采取以下两个新策略来排除被分析区间中的良性偶然行为:(1)“新的区间划分策略”是新方法的关键,它利用指定的应用级事件的处理区间来划分程序的执行轨迹.其结果是,和现有的方法相比,我们的方法能有效地降低误报;(2)对于在使用上述新策略后仍存在误报的情况,我们进而使用“新的程序行为选择策略”,它仅捕获那些处理指定应用级事件的程序行为,即仅捕获指定类型事件的处理过程、而忽略其它类型事件的处理过程.我们的实验表明,通过采用此策略能进一步地减少甚至消除误报.本文的贡献在于:(1)通过实验,报告并深入分析基于区间的测试方法在检测传感网应用程序的瞬态错误时的误报问题,并指出其产生误报的原因.(2)提出一种新的基于区间的测试方法,用于检测传感网程序在应用级组件中的瞬态错误、缓解TestOracle问题.此方法的特点是利用应用级事件的处理区间,分析由这些事件所触发的程序行为,提出一种高效的区间识别算法,并在此基础上实现了新方法的一个原型工具.(3)通过实验评估新工具的有效性,并与现有的方法进行比较.结果表明,新工具能有效地报告错误区间,并能减轻测试者在人工检查单个区间时的负担.(4)通过实验评估新工具的在线处理效率,并与现有的工具进行比较.结果表明,新工具的在线处理过程具有更高的时空效率.误区间的排序从第22位提升到第1位;(2)本文方法所报告的可疑区间具有明显更短的长度,从而能大大减轻人工检查阶段的工作.例如,它可以将所报告区间的平均长度减少53%.基于区间的测试方法在线地识别被测程序的各个区间并收集运行时信息,因此我们关注其在线处理过程的效率.本文提出了一种新的区间识别算法,我们的原型工具是基于此算法而实现的.我们执行了一组实验来评估该工具的在线处理效率.实验结果表明,和现有的测试工具相比,我们测试工具的在线处理过程具有更低的时空耗费.本文第2节介绍现有的基于区间的测试方法以及相关的概念;第3节通过一个实际例子,分析发生在中断处理区间中的良性偶然行为;第4节详细描述我们的基于区间的测试方法;第5节通过实验评估和分析我们方法的效果和效率;第6节介绍相关工作;第7节总结全文并展望未来的工作.2背景介绍2.1相关概念TinyOS应用程序是基于组件的程序,其系统级组件由TinyOS服务包提供,而其应用级组件包括应用特定的用户组件和应用相关的路由协议组件.组件中的nesC模块包括如下形式:中断处理模块(Interrupt-Handler)、任务(task)、nesC事件Page4(event)函数、nesC命令(command)函数和C函数[6].其中,nesC事件函数是非中断事件的事件处理模块(Event-Handler),关键字event和signal分别用于声明和调用它.一个异步的(async)nesC事件函数从中断处理模块中抢占式地执行,而一个同步的nesC事件函数则只能从任务中执行.当一个中断事件发生时,微控制器单元(MCU)将自动调用相应的应用逻辑以处理此事件,文献[5]称这种应用逻辑为“事件过程”(Event-Procedure).一个典型中断事件的事件过程包括立即执行的中断处理模块和一些延迟执行的任务[5].由于nesC模块之间相互依赖、复杂交织,TinyOS程序的动态执行过程难以理解、容易出错.TinyOS程序中的事件处理模块可分为中断事件处理模块和非中断事件的处理模块,其中后者包括应用级事件的处理模块.最底层的硬件中断触发中断处理模块的执行,在执行过程中可通过signal操作向上触发一系列的非中断事件处理模块.典型的处理链依次涉及字节级组件、包级组件、消息级组件,最后可能到达应用级组件[7].每个应用级事件类型都有一个“相应的”中断类型,即触发向上处理链的那个中断的类型.表1列出了3种典型TinyOS应用程序的3个应用级事件的类型及其相应的中断类型.其中,应用程序Osilloscope是一个采集传感器数据的程序,它使用单跳技术传送数据包;TestBlink实现了数据包的多跳传送;TestCTP使用一种汇聚树路由协议传送传感读数.这些程序来自TinyOS2.x软件包①或者Sentomist工具的软件包②.第2列的应用级事件以“应用级组件名.接口名.事件名”的形式表示,其中的AdcMessageC和BlinkToRadioC是用户自定义的组件,而CtpForwardingEngineP是路由协议组件.这些应用级事件分别对应3种典型的硬件中断,即ADC中断、SPI中断和定时器中断.表1典型应用程序的应用级事件及其对应的中断应用程序OscilloscopeAdcMessageC.Read.readDoneADCTestBlinkBlinkToRadioC.Receive.receiveSPITestCTPCtpForwardingEngineP.0.2.2Sentomist方法Sentomist方法[5]用于检测传感网程序中的瞬态错误,其基本假设是:在同一中断的各个中断处理区间中,所发生的正常程序行为应当具有统计相似性,而异常的程序行为则很可能是瞬态错误的表现.Sentomist方法输入二进制的程序代码、程序的测试场景以及测试者所指定的中断事件类型,并运行这些测试以获取程序的执行轨迹.Sentomist是一种基于区间的测试方法,它根据测试者指定的中断类型,将程序的执行轨迹划分成此类中断事件的处理区间.它使用一个N元向量,捕获发生在每个区间中的所有程序行为(其中,N是程序机器指令的总数,而第i个向量元素表示第i条指令在此区间的执行次数);与此同时,它记录发生在每个区间的函数调用序列,以备人工检查.此方法在获得基于区间的运行数据之后,使用one-classSVM[8]作为异常检测算法,根据区间向量的异常情况对区间进行排序:一个向量越异常,就意味着它包含瞬态错误的可疑度越高,而其排序也越高.最后,测试者按区间排序从高到低逐个检查区间的函数调用序列,直至找到瞬态错误.3举例分析Sentomist方法使用中断事件的处理区间,分析发生在这些区间中的所有程序行为.然而,发生在这些区间中的偶然行为未必就代表应用组件中的瞬态错误.本节将以表1中的TestBlink程序为例,对这些行为进行分析.图1所示的代码片段是TestBlink程序中与SPI(串行外部设备接口)中断的事件过程相关的部分代码.SPI中断会触发Mica2平台的射频芯片CC1000的功能③.图中的系统级组件HplCC1000SpiP实现底层的功能,例如访问CC1000总线的中断处理模块;而组件CC1000SendReceiveP实现发送和接收CC1000射频信号的功能.事件处理模块的一次完整的执行轨迹就是一个事件过程实例.在图1中,一个SPI中断事件的过程实例始于SPI中断处理模块的入口(第H1行);此模块在执行第H2行时、通过组件CC1000SendReceivedP的接口HplCC1000Spi调用第C1行,而组件CC1000SendReceivedP被连接到组件HplCC1000SpiP.于是,SPI的中断事件过程实①②③Page5例就延伸到了组件CC1000SendReceiveP.沿着执行轨迹H1-H2-C1-C6-C9-C11-C15-C16,如果第C16行的任务提交是成功的,那么第C19行的任务将被执行、并成为一个SPI事件过程实例的一部分;否则,该任务将不会被执行,也不是SPI事件过程实例的一部分.HplCC1000SpiP.nc://系统级组件/SPI中断处理模块/H1:AVR_ATOMIC_HANDLER(犛犐犌_犛犘犐){…H2:signalHplCC1000Spi.dataReady(temp);H3:}CC1000SendReceiveP.nc://系统级组件C1:asynceventvoidHplCC1000Spi.dataReady(uint8_tdata)C2:{…C3:switch(radioState){C4:default:break;C5:caseSYNC_STATE:syncData(data);break;C6:caseSENDING_ACK:ackData(data);break;C7:…}C8:}C9:voidackData(uint8_tin){C10:if(++count>=ACK_LENGTH){…C11:packetReceiveDone();}C12:elseif(count>=ACK_LENGTH-sizeofackCode)C13:callHplCC1000Spi.writeByte(…);C14:}C15:voidpacketReceiveDone(){…C16:postsignalPacketReceived();C17:…C18:}C19:taskvoidsignalPacketReceived(){…C20:pBuf=signalReceive.receive(…);C21:…C22:}BlinkToRadioC.nc://应用级组件B1:eventmessage_tReceive.receive(…){…B2:if(TOS_NODE_ID==TARGET){…B3:postuartSendTask();}B4:else{…B5:callAMSend.send(…);}B6:…B7:}B8:taskvoiduartSendTask(){B9:if(callSerialSend.send(…)!=SUCCESS){…}B10:…B11:}图1TestBlink程序中与SPI中断事件过程有关的图2示例了TestBlink程序中与SPI中断事件过程有关的部分执行轨迹.图中的每个矩形节点表示一个被执行的函数:若此函数在图1中有相应的代码,则其节点以代码行号为前缀,否则其节点以Nodei(1i2)为前缀;带有实线圆角矩形的Endi(1i5)节点表示相应的执行轨迹在字节级或包级结束,而带有虚线圆角矩形的Endi(6i7)节点表示相应的执行轨迹延伸到“应用组件级”(简称“应用级”);有向边代表节点的执行顺序.于是,图2中的每条路径对应SPI中断事件过程的一种执行轨迹,它始于前缀为H1的节点,而终于一个Endi(1i7)节点.图2TestBlink程序中与SPI中断事件过程有关的在图2中,有5个执行轨迹,即以Endi(1i5)结束的轨迹,不涉及任何应用级的事件;有4个执行轨迹,即以Endi(1i4)结束的轨迹,执行系统级功能,例如介质访问控制、低功耗监听和通用控制等功能.上述执行轨迹中的程序行为仅仅由系统级组件完成,而与应用级组件的执行无关.以End5为终点的轨迹,终止于一个失败的系统任务提交操作.此轨迹的行为都是由系统级的函数来执行,而与特定的应用无关.总之,上述的执行轨迹均不涉及应用级Page6的事件.而这样的执行轨迹在TinyOS程序中是常见的,这是因为:(1)系统级的功能,如介质访问控制等功能,是大部分应用程序的共同基础;(2)在程序执行中,失败的系统任务提交操作是常见的,特别是当中断发生的频率较高时.根据我们的实验结果(见第5.3节),在一个TinyOS程序的一次运行中,不涉及应用级事件的执行轨迹可以高达99%.在图2中,分别以End6和End7为终点的两个轨迹都包含一个应用级事件BlinkToRadioC.Receive.receive(对应前缀为B1的节点).在前缀为H1的节点和Node1节点之间的程序执行段,发生在所有的应用级事件触发之前.系统级的组件决定了此执行段的行为;而发生在此执行段之后的应用级事件(例如前缀为B1的节点)并不会影响此执行段的行为.这些系统级的行为都是与应用级组件无关的.发生在前缀为B1的节点与End6(或End7)节点之间的程序执行段、是由应用级事件BlinkToRadioC.Receive.receive所触发的.此执行段的程序行为可被看作是由应用级事件所直接驱动、而由SPI中断事件所间接驱动的.本文研究如何揭示传感网程序的应用级组件中的瞬态错误.在一个中断事件的处理区间中,不涉及应用级组件执行的偶然行为有可能是无错的,即良性的.在图2中,这些良性行为的例子包括:(1)发生在以Endi(1i5)为终点的执行轨迹中的偶然行为;(2)发生在前缀为H1的节点和Node1节点之间的执行段中的偶然行为.此外,具有相同事件类型的事件过程会共享变量或者共享事件处理逻辑.根据我们的编程经验,数据依赖和控制依赖大量地存在于这些事件过程之间,而具有不同事件类型的事件过程之间往往较少存在依赖.因此,由不同事件类型的事件过程交织而造成的偶然行为很可能是良性的.例如,在图2的任何执行轨迹中都可能发生这种良性行为.直观地看,为了在基于区间的测试中减少误报,我们需要排除被分析区间中的良性偶然行为.为此,我们提出了一种新的基于区间的测试方法,下一节将详述我们的方法.4基于区间的测试方法为了有效地发现传感网应用级组件中的瞬态错误,我们提出一种基于“应用级事件的处理区间”的测试方法.本节首先给出应用级事件的处理区间的定义,然后描述如何识别这些区间,最后阐述我们的测试方法的具体步骤.4.1定义在一个nesC程序中,设EH是在应用级组件中定义的一个事件处理模块,则EH所处理的事件e称为一个应用级事件.下面给出应用级事件的相关定义.定义1.事件过程(Event-Procedure).EH(或e)的事件过程由以下3种nesC模块的静态代码组成:EH、EH所调用的模块和EH的任务.其中,(1)EH所调用的模块是这样一个函数,它被EH、EH所调用的模块或者EH的任务所调用;(2)EH的任务是这样一个任务,它被EH、EH所调用的模块或者EH的任务所提交.定义2.事件过程实例(Event-Procedure-Instance).EH(或e)的一个事件过程实例,简称实例,是“EH的事件过程”的一次执行.此实例所调用的模块是指在此次执行中所包含的“EH所调用的模块”.此实例的任务是指在此次执行中所包含的(也即被成功提交的)“EH的任务”.定义3.事件过程实例的区间(Interval).EH的一个事件过程实例的执行时间称为此事件过程实例的区间,也称事件e的处理区间.直观看来,一个事件过程实例包括一个EH运行部分和若干个(零个或多个)任务运行部分;事件e的一个处理区间始于其事件过程实例的起点(即EH的入口执行点),而终于此实例的终点(即此实例的EH的出口执行点、或者此实例的最后一个任务的出口执行点).在定义1中引入了“EH所调用的模块”,这是因为当EH的实例所调用的模块成功地提交了一个任务时,此任务将来的执行也成为此实例的一部分.在定义2中只考虑被成功提交的任务,这是因为一个任务提交操作未必会成功:例如在TinyOS2中,当一个任务在队列中等待执行时,其它同名任务的提交操作都会失败[6].假设e是一个中断事件,而IH是e的中断处理模块,那么将上述3个定义中的EH全部替换为IH,就可得到中断事件的所有相关定义.为了更直观地说明上述的概念,图3示例了“应用级事件”的处理区间和“相应的中断事件(含义见2.1节)”的处理区间.图中的EH是应用级事件的处理模块,其事件过程实例用黑实线表示;IH是相应的中断事件的处理模块,其事件过程实例用灰实线表示.应用级事件可分成异步事件和同步事件两种类型,子图(a)和(b)分别示例这两种情况下的实例执行情况.如图所示,在这两种情况下,应用级事件的处理区间都是相应中断事件处理区间的子区间.Page7图3应用级事件及其对应中断事件的处理区间4.2区间的识别方法实现基于区间的测试方法的关键之一是识别相应的区间.识别给定事件的处理区间,就是在被测程序执行时识别这些区间的起点和终点.我们用i表示被测程序当前执行的机器指令.当i是给定的中断处理模块的入口指令时,给定中断的一个事件过程实例开始执行,该指令就是给定中断的一个处理区间的起点.我们开发了算法1来识别此区间的终点.算法1.区间终点的识别.全局变量:堆栈instS,存放所有活动实例的实例信息;队列instQ,存放所有待执行任务的实例信息输入:一个区间的起点所对应的指令i输出:此区间的终点所对应的指令j1.found=false;//尚未找到此区间的终点2.inst=创建i的实例信息;3.curInst=inst;//设置当前实例4.DO{5.j=取得下一条待执行的指令;6.执行j;7.SWITCH(j){8.开始执行一个中断处理模块:9.instS.push(curInst);//保存中断前的实例10.curInst=创建j的实例信息//重置当前实例11.成功地提交一个任务:12.curInst入队列instQ//保存此任务的实例13.开始执行一个任务:14.curInst=instQ首元素出队列;15.结束执行一个中断处理模块:16.IF((curInst==inst)&&(inst不在instQ中))17.found=true;//找到此区间的终点18.curInst=instS.pop();//恢复中断前的实例19.结束执行一个任务:20.IF((curInst==inst)&&(inst不在instQ中))21.found=true;//找到此区间的终点22.Default:23.}24.IF(found)25.RETURNj;//返回此区间的终点26.}WHILE(!found);各种中断的各个事件处理区间复杂地交织在一起.为了识别每个中断处理区间,我们需分析所有中断的事件过程实例的切换情况.算法1跟踪处理4种实例切换点:中断处理模块的入口点(第8行)和出口点(第15行)、任务运行函数的入口点(第13行)和出口点(第19行).其中,任务运行函数的一个例子是图2所示的BlinkToRadioC.uartSendTask.runTask().为了识别各个任务提交操作是否成功,我们还需跟踪系统postTask函数中与任务提交成功相对应的指令(第11行);此指令在系统postTask函数中的偏移地址是个常数.算法1使用全局堆栈instS保存当前正在运行的各个事件过程实例的信息.当一个中断抢占发生时,一个中断处理模块开始执行,该中断的实例开始运行,因此算法1创建此实例的信息(包括实例编号),并放入堆栈instS(8~10行).当此中断处理模块结束运行时,程序的执行将转回被抢占的实例中,因此算法1从instS中恢复中断前的实例信息(第18行).为了在任意一个任务开始运行时识别它是哪个实例的任务,算法1使用一个全局队列instQ来保存程序在运行时的所有待执行任务的实例信息:每当有任务被系统成功提交时,算法1就把当前的实例信息(即此任务的实例信息)入队(第12行);而每当一个任务开始运行时,就将实例信息队列的首元素出队,此元素就是开始运行的这个任务的实例信Page8息(第14行).可见在被分析程序运行的任一时刻,如果某个实例有n个“被成功提交且尚未执行”的任务(即“待执行的任务”),那么在instQ队列中就有n个元素的值是此实例的信息.因此在任一时刻,如果某个实例的信息不存在于instQ中,那么这个实例必然无“待执行的任务”.从4.1节所述可知,在一个实例的EH出口执行点,或者此实例的一个任务的出口执行点,若此实例无待执行的任务,则这个出口执行点就是此实例的终点.在算法1中,当j为一个中断处理模块的出口点(第15行)或者任务运行函数的出口点(第19行)时:如果当前实例的信息就是指令i的实例信息inst(第16和20行),那么j的实例就是i的实例;而如果此时inst不存在于instQ队列中(第16和20行),那么如前一段所述,i的实例必然无“待执行的任务”.综上可知,此时的j就是i的实例终点(即区间终点),因此算法1在此时找到了所要的区间终点(第17和21行).可见,算法1能在实例终点指令执行时,实时地将其识别为实例终点.算法1不仅可识别给定中断事件的区间,也可用于识别给定应用级事件的区间.当我们使用算法1来识别给定应用级事件的区间时,我们需要把给定的应用级事件看作是一个“虚拟的中断事件”:(1)在调用算法1之前的静态扫描阶段,将此应用级事件处理模块的入口地址与一个自设的虚中断号(如999)相关联;(2)在调用算法1来识别“此应用级事件”的区间时,将给定的事件设为“中断号为999的中断事件”.4.3本文基于区间的测试方法当使用现有的方法时,测试者通过中断号指定一个中断事件类型;而使用本文方法时,测试者通过应用级事件名指定一个应用级事件类型.和现有的基于区间的测试方法相比,本文方法在以下3个方面采取了新的策略:区间的划分、程序行为的选择和函数执行信息的记录.新的区间划分策略用于减少那些不涉及应用级组件执行的良性偶然行为,而新的程序行为选择策略用于排除事件类型不同的事件过程之间的良性交织.这两个策略旨在解决基于区间测试的误报问题.对于测试者所指定的应用级事件类型,第1个策略将被分析程序的运行时间划分成这些应用级事件的处理区间;而第2个策略仅捕获由这些应用级事件所触发的行为,即仅捕获这些应用级事件的事件过程实例,而忽略其它中断事件的事件过程实例.值得注意的是,和现有的方法相比,第2个策略并未改变所分析的程序行为特征,即所分析的仍为指令的执行计数.TinyOS应用程序在应用级提交一个任务后,未必会检查此次的任务提交是否成功;而测试者往往会关注任务提交操作成功与否.因此,我们通过第3个策略为测试者提供每一个任务提交操作的结果,旨在帮助测试者更有效地进行人工检查.为了判断“一条指令的执行”(即一个程序行为)是否应该被捕获,我们只需判断此指令的事件过程实例所对应的事件是否为给定的事件.因为程序行为捕获的过程交织在区间识别的过程中,所以我们通过修改算法1来实现上述的判断.图4直观地描述了我们对算法1的修改,其中灰底的部分表示原算法1的内容,其它部分表示修改后用于捕获程序行为的内容,具体的修改如下:(1)将算法1中保存实例信息的数据结构设为INST〈instNum,ofE〉,其中instNum表示实例编号,而ofE表示这个实例“是否为给定事件的实例”.(2)在算法1的第2行创建给定事件的实例信息时、将ofE字段设为TRUE;同时可判定:“指令i的执行应当被捕获”.(3)在第10行创建某个事件的实例信息时,根据“此事件的中断号等于(或不等于)给定事件的中断号”,将ofE字段的值设为TRUE(或FALSE).对于给定的应用级事件,给定的事件中断号就是4.2节所述的虚中断号.(4)在第23和24行之间,取得指令j的实例curInst的ofE字段值;如果此字段值为TRUE,则可判定:“指令j的执行应当被捕获”.修改后的算法1.区间终点的识别+程序行为的捕获.数据结构:INST〈instNum,ofE〉:用于保存实例信息…2.//创建i的实例信息inst=〈++instNum,TRUE〉捕获指令i的执行3.curInst=inst;//设置当前实例…10.//创建j的实例信息,并重置当前实例IF(此中断处理模块的中断号==给定事件的中断号)11.成功地提交一个任务:…23.}捕获指令j的执行24.IF(found)…IF(curInst.ofE)Page9对于测试者所指定的应用级事件类型,我们的测试方法包括以下3个步骤:(1)以这些应用级事件的处理区间为单位,在线收集被测程序的运行时数据.它具体包括以下3个子过程:①识别这些应用级事件的处理区间;识别所选的行为(即由这些应用级事件所触发的行为);识别与函数执行相关的信息,其中包括任务提交操作的信息.②用一个变长向量记录发生在每个区间中的所选程序行为.每个向量元素表示一条指令在此区间中的执行次数,每个元素包括两部分:指令的地址和指令的执行次数.这些向量用于离线的区间排序.③用一个字符串序列记录发生在一个区间中的与函数执行有关的信息.每个字符串表示一个函数调用,或者表示一个任务提交操作的结果为成功(或失败).字符串的值是函数名,或者以“@PostOk”(或“@PostFail”)为后缀的任务名.(2)采用现有测试方法的离线排序技术,对收集到的区间进行排序.(3)从高到低,人工检查各个区间的函数执行信息,直至找到瞬态错误.因为应用级事件的处理区间比相应的中断事件的处理区间短,所以我们的方法在人工检查阶段只需检查更短的函数执行信息.5实验研究5.1研究的问题为了揭示应用级组件中的瞬态错误,现有的测试方法报告包含上述错误的中断处理区间;而我们的测试方法采用新的区间划分策略和程序行为选择策略,报告包含上述错误的应用级事件处理区间.针对应用级组件中的瞬态错误,我们围绕下5个问题展开实验研究:RQ1:现有的测试方法在报告包含错误的区间时是否存在误报问题?现有方法中的区间筛选策略对测试效果有何影响?RQ2:我们的测试方法能否有效地报告包含错误的区间?和现有的方法相比,我们的方法是否有更少的误报?的可疑区间是否具有明显更短的长度?RQ3:和现有的方法相比,我们的方法所报告RQ4:如果RQ2的答案是肯定的,那么我们方RQ5:在实际中,我们测试方法的“在线处理过法中的两个策略对于降低误报有何作用?程”在时空方面的开销如何?在上述问题中,RQ2~RQ4研究我们测试方法的效果,而RQ5研究其效率.5.2实验设置5.2.1原型实现与运行环境我们用Java语言开发了两个原型工具,分别实现我们的测试方法和现有的测试方法.这两个工具都采用相同的区间识别算法(即算法1),并使用Sentomist工具(参见第2.1节脚注②)的离线分析模块对区间进行排序.上述工具运行于传感网的指令级模拟器Avrora[9]之上,它们利用Avrora所提供的插装机制来插装被测程序的指令;当Avrora解释执行被测程序时,被插装的探针也随之执行.我们在实验中发现,传感网模拟器的版本差异会对工具的运行结果产生一定的影响.为了在对比工具的运行结果时减少这种影响,我们所有的实验都运行于同一版本的模拟器(即Avrora1.7.113①)之上.实验所用的模拟平台为Mica2、微控制器为ATmega128②.实验所用的传感网操作系统为TinyOS2.1,它运行于WindowsXP和Cygwin③平台上.实验所用的计算机是一台具有2.7GHzIntel双核处理器和1GB内存的台式计算机.5.2.2被测程序与运行设置我们在实验中所用的被测程序如表2第1列所示,它们是表1所示的3种典型的TinyOS应用程序或其变体.其中,被测程序Sub1~Sub3分别是程序Osilloscope的3个变体,Sub4是程序TestBlink的变体,而Sub5即TestCTP程序(参见第2.1节脚注①②).被测程序Sub1源节点Sub2源节点Sub3包覆盖Run51Avrora的缺省设置10Sub4中继节点Sub5停止数据①②③Page10被测程序Sub1~Sub5的应用级组件中包含瞬态错误,其症状如表2的第2列所示.这些错误症状在传感网程序中是常见的,并曾被TinyOS社区①所讨论或被现有的实验研究[5,10]所引用.其中,Sub1~Sub2中的错误是源节点的丢包错误,原因是源节点在发送数据包时没有缓冲机制,当采样频率较高时就会有数据包因无法及时发出而丢失;错误的最大显现次数在Sub1中为1次、而在Sub2中为3次.Sub3中存在一个如下的包覆盖错误:应用级组件中的一个异步事件将传感数据封装成包,并提交一个任务来发送此包,如果在此任务的“成功提交点”与“运行调度点”之间,又有一个异步事件形成新的数据包并提交了另一个任务来发送此包,那么新数据包会完全覆盖上一个数据包的内容,而新的任务提交操作则会失败.Sub4中的错误是中继节点的丢包错误,原因是中继节点因忙而无法转发新接收的数据包;Sub4的错误显现次数是一个变量,它随运行时间和源节点的采样周期而变化.Sub5使用汇聚树路由协议CTP传送传感读数,同时使用另一个协议在节点间传送其它数据,这两个协议有可能争用资源;由于CTP未能正确地处理上述竞争,而造成了停止发送数据的错误.瞬态错误在传感网程序运行时未必会显现出来,其显现与否和显现次数都会受程序运行设置(包括程序的运行时间和源节点的采样周期)的影响.被测程序Sub1~Sub5的瞬态错误可以通过表2所示的测试运行显现出来.表2的第3列给出了这些测试运行(Test-Run)的编号.第4列报告了瞬态错误在各个测试运行中的显现次数,并记为#BM(即NumberofBugManifestation).第5、6列分别给出了每个测试运行中源节点的采样周期(以ms为单位)和在Avrora上模拟运行的时间(以s为单位).例如在Run1中,Sub1被执行了5次,每次的执行时间都是10s,而5次的源节点采样周期分别为20ms,40ms,60ms,80ms和100ms.TestCTP由节点2、4、6、8采样传感数据,其中节点8的采样周期为400ms,而其余节点的采样周期为550ms.被测程序Sub1~Sub4和现有实验研究的被测程序都是源于程序Osilloscope和TestBlink,但是Sub1~Sub4具有以下特点:(1)程序的运行设置对应更多种情况的运行场景,即不仅包含采用多个采样周期的情况(如Run1、Run3、Run7和Run8),而且包含采用单个采样周期的情况(如Run2);(2)程序的瞬态错误不仅包括单次显现的错误(如Run1~Run2,Run5~Run7),而且包括多次显现的错误(如Run3~Run4,Run8~Run9);(3)程序中的应用级事件不仅包括同步事件,而且包括异步事件(即Run5~Run6).我们在运行基于中断区间的测试工具时,所指定的中断类型为表1第3列所示的中断,即ADC中断(用于Sub1~Sub3)、SPI中断(用于Sub4)和定时器中断(用于Sub5).而我们在运行基于应用级事件区间的测试工具时,所指定的应用级事件类型为AdcMessageC.Read.readDone(用于Sub1~Sub2)、AdcMessageC.mySensor.dataReady(用于Sub3)、BlinkToRadioC.Receive.receive(用于Sub4)以及CtpForwardingEngineP.0.RetxmitTimer.fired(用于Sub5).5.3效果的研究5.3.1现有方法的区间排序效果本节研究问题RQ1.现有的测试方法在对区间进行排序之前,可以使用“区间筛选策略”,即筛选出包含指定字符串的区间,然后仅对这些区间进行排序(参见第2.1节脚注②).如5.2.1节所述,我们实现了现有测试方法的原型工具,该工具使用Sentomist工具的离线分析模块对区间进行排序.为了使用区间筛选策略,我们在区间排序之前启用Sentomist工具的“区间筛选功能”,并指定筛选用的字符串为5.2.2节最后一段所示的应用级事件名(即我们的测试方法所用的应用级事件类型的名字).我们分别在“不使用”和“使用”区间筛选策略的情况下,将现有测试方法的原型工具应用于表2所示的各个测试运行上,并检查工具对错误区间(即实际上包含瞬态错误的区间)的排序,其结果如表3所示.其中,第1列是表2所示的测试运行的编号.第2列给出了每个测试运行中的错误区间总数#BI(即NumberofBuggyIntervals).因为在这些测试运行中,每个错误区间只包含一个错误,所以每个测试运行的错误区间总数#BI和它的错误显现次数#BM(如表2的第4列所示)相等.第3列表示测试者运用现有的测试方法时,所指定的中断类型.第4和5列分别报告在“不使用”和“使用”区间筛选策略的情况下,运用现有的测试方法时所得的错误区间的排序号.①http://www.tinyos.net/community.html2012,5,1Page11运行编号#BI中断Run11ADC839Run21ADC626Run33ADC909,950,97821,23,711,2,3Run43ADC926,931,93613,20,281,2,3Run51ADC1Run61ADC1Run71SPI206Run83SPI167,168,1692,3,41,2,3Run93SPI107,108,1092,3,81,2,3Run101Timer0Run111Timer0从第4列可看出,在不使用区间筛选策略时,对于大部分的测试运行,现有的测试方法不能将错误区间排在前列、产生了大量的误报:它将9个测试运行(即Run1~Run4和Run7~Run11)的错误区间在第100位之后.可见,其区间排序效果有很大的改进空间.而第5列表明,在使用区间筛选策略之后,现有测试方法的误报问题明显得以缓解;但是误报问题仍然存在:大部分测试运行(即Run1~Run4和Run8~Run11)的排序结果仍有待提高,其中有些排序结果(如Run3~Run4和Run10~Run11)高于20.比如对于Run11,测试者需手工检查22个可疑区间才能找到错误区间.上述的实验结果表明:在使用现有的测试方法检测应用级组件中的瞬态错误时,使用区间筛选策略能明显地改善测试效果.另一方面,在使用此策略之后,现有方法的测试效果仍有改进的空间,即仍然存在误报问题.5.3.2本文方法的区间排序效果本节研究问题RQ2.如前所述,我们开发了一个原型工具实现我们的测试方法.在本节我们将此工具应用于表2所示的各个测试运行上,得到的错误区间排序结果如表3的最后一列所示.从此列可看出,对于所有的测试运行,我们的测试方法都能够有效地将错误区间排在前几位:它将Run10的错误区间排在第5位,而将其余11个测试运行的错误区间都排在第1位.这意味着,通过使用我们的方法,测试者只需手工检查1个或者5个可疑区间就能发现错误区间.我们在对比了Run10和其它测试运行之后发现:Run10和Run11从多个节点、而其它的测试从单个节点收集区间,且Run10所收集的区间数(190)远少于Run11所收集的区间数(502).这个结果说明当从多个节点收集区间数据时,所收集的区间数可能会影响排序的效果.通过对比表3的最后两列,我们可以看出:本文测试方法能将Run10的错误区间排序从第20位提高到第5位,而将其余10个测试运行中待改进的排序结果都提升到最佳,即第1位.上述的实验结果表明:本文测试方法能够有效地报告包含瞬态错误的区间.和使用区间筛选策略的现有方法相比,本文方法能有效地降低误报,甚至消除误报.5.3.3本文方法的区间长度效果本节研究问题RQ3.本文方法使用“应用级事件的处理区间”(记作EInterval),而现有的方法使用“中断的处理区间”(记作IInterval).一个应用级事件的EInterval是“触发该事件的那个中断”的IInterval的子区间.如5.3.1节所述,在使用区间筛选策略之后,现有测试方法所排序的区间都是“包含应用级事件处理”的IInterval.我们通过实验比较这两种区间的实际长度.对于每一个测试运行Runi(1i11),表4比较我们的方法和现有的方法所生成的区间长度,这些长度包括:最大长度、最小长度和平均长度.其中,一个区间的长度是指该区间所包含的字符串的个数:在现有的方法中,一个区间的字符串序列由“在该区间被调用的函数”的函数名组成;而在我们的方法中,此序列除包括上述的函数名之外,还包括“在该区间被提交的任务”的提交操作结果(详见4.3节我们方法的步骤(1)之子过程③).表4的最后一列表示用我们的方法替代现有的方法后,区间的平均长度的下降率.运行编号Run14665713130856253Run24665713030856252Run34615713231856253Run44615713231856253Run51501592171446512542Run61501592061446512241Run75412123161725315651Run84542123111575315450Run94542123111575315351Run105801493183863620336Run115911493143893619737表4表明,本文方法所报告的可疑区间具有明显更短的长度,比如平均长度的下降率在36%和53%之间.这说明我们的方法能明显地减轻测试者在人工检查单个区间时的负担.另外由表4可知,在Page12两种方法中,区间的平均长度一般都大于100,而最大长度甚至会大于1000.因此,测试者必须手工检查多于100(甚至1000)个表示执行信息的字符串、才有可能判断一个区间是否包含错误.这说明,无论采用哪种方法,当需要检查较多的区间时,人工检查都将变得非常费力、难以完成.上述的实验结果表明:和使用区间筛选策略的现有方法相比,我们的方法所报告的可疑区间具有明显更短的长度.这意味着,我们的方法能显著地减轻测试者在人工检查单个区间时的负担.5.3.4本文方法中的两种策略的作用接下来,我们研究问题RQ4.本节通过实验,比较我们方法中的两种策略(即新的区间划分策略和程序行为选择策略)对解决误报问题的各自贡献.我们测试方法的原型工具同时实现了这两种策略.通过对此工具进行修改,分别得到了另外两个新工具,它们分别只实现上述的策略之一.其中,“只使用新的程序行为选择策略”的工具仍然沿用给定中断事件的IInterval区间,但是仅捕获由给定中断事件所触发的程序行为;“只使用新的区间划分策略”的工具仍然不加选择地捕获任意事件所触发的程序行为,但是使用应用级事件的EInterval区间.我们将这两个新工具分别应用于前述的11个测试运行中,所得的结果如表5的第2和3列所示.为作对比,最后一列给出使用本文方法时所得的结果.表5分别使用本文两种策略时的区间排序结果运行编号Run1827Run2624Run3907,908,9097,10,111,2,3Run4926,927,9284,7,8Run51Run61Run7204Run8167,168,1691,2,3Run9107,108,1091,2,3Run10345Run11611比较表3的第4列和表5的第2列可看出:通过单独使用我们的程序行为选择策略,错误区间的排序有所提升;但是对于大部分的测试运行(即Run1~Run4和Run7~Run11),错误区间的排序仍超过100,即仍存在大量的误报.从表5的第3列可看出:通过单独使用我们的区间划分策略,针对3个测试运行(即Run7~Run9)的排序结果都达到了最佳;而针对另外6个测试运行(即Run1~Run4和Run10~Run11)的排序结果都“小于20”.可见,通过单独地使用我们的区间划分策略,可以有效地减少误报.而通过比较表5的最后两列可知:如果不使用程序行为选择策略,那么对于Run1~Run4和Run10~Run11,其错误区间的排序结果无法进一步提高.因此,我们的程序行为选择策略对降低误报也有重要的贡献.以上的实验结果表明:本文测试方法的有效性同时得益于两种策略.接下来,本文将举例分析:这两种策略是如何减少误报的?以Run11为例,模拟器所配置的传感网包含9个节点,每个节点都运行被测程序Sub5:节点0是目标节点,节点2、4、6和8每隔一段时间通过CTP协议传送传感读数,节点1、3、5、7和8每隔一段时间通过一个消息交换协议HeartBeat向邻居节点发送心跳消息.这两个协议都使用ActiveMessageC组件的AMSend接口发送消息包到主动消息层,因此它们共用radio.CTP的CtpForwardingEngineP组件在实现发送任务时,只考虑了使用本协议的各个clients之间争用radio的情况,并未考虑本协议的client与其它协议争用radio的情形①:如图5的第13~20行所示,该组件的发送任务sendTask在调用SubSend.send()时,对返回值为FAIL或EBUSY的情形未做任何处理.在Run11的节点8上就出现了这种情形:CTP协议触发RetxmitTimer.fired事件(图5第7行),并沿着执行路径7-8-10-12-13(图5CtpForwardingEngineP.nc:1:genericmoduleCtpForwardingEngineP(){2:usesinterfaceAMSendasSubSend;3:usesinterfaceTimer〈TMilli〉asRetxmitTimer;4:…}5:implementation{6:…7:eventvoidRetxmitTimer.fired(){…8:postsendTask();}9:10:taskvoidsendTask(){11:…12:error_tsubsendResult;13:subsendResult=//错误:以下代码未处理返回值为FAIL和EBUSY时的情况14:if(subsendResult==SUCCESS){…15:return;}16:elseif(subsendResult==EBUSY){/donothing/}17:elseif(subsendResult==EOFF){18:radioOn=FALSE;}19:elseif(subsendResult==ESIZE){…20:postsendTask();}}21:…}}①Thecollectiontreeprotocol(CTP)[EB/OL].http://Page13中的行号)调用函数SubSend.send();SubSend.send()试图发送数据,而此时AM层正忙于传送HeartBeat协议的数据,因此SubSend.send()函数的返回值为FAIL.此后,节点8因上述的FAIL状态未被处理而无穷等待相应的SubSend.sendDone信号,CTP数据传送中止.在Run11中,节点2、4和6上都未出现CTP中止传送的错误.测试工具从节点2、4、6和8收集程序的运行信息.在Run11中,现有方法所收集的是Timer0中断处理区间中所发生的全部程序行为.当现有方法不使用区间筛选策略时,错误区间被排在第755位(表3第4列).在这754个误报的中断处理区间中,有3种类型的程序行为并不属于CtpForwarding-EngineP.0.RetxmitTimer.fired事件的处理过程:(1)发生在不调用此事件函数的中断处理区间中的行为.例如排序为第1的区间中的行为,其中的部分执行序列如图6(1)所示.这些行为收集自节点2,节点2通过Timer0中断,触发对CTP的路由更新,并在路由重建之后直接提交一个sendTask()任务来发送数据;在此过程中并未调用函数CtpFor-wardingEngineP.0.RetxmitTimer.fired().在节点2上未出现CTP发送中止的错误,因此该区间是误报.(2)发生在调用函数CtpForwardingEngineP.0.RetxmitTimer.fired()的中断处理区间之中、且发生在此函数开始执行之前的行为.例如在排序为第6的区间中的行为,其中的部分执行序列如图6(2)所示.VitualizeTimerC定时器先后触发以下两个事件处理函数的执行:函数BlinkToRadioC.TimerSense.fired()和函数CtpForwardingEngineP.0.Retxmit-Timer.fired();而在前一个函数的执行中并不处理RetxmitTimer.fired事件.此区间收集自节点6,而在节点6上并未出现CTP错误,因此该区间是误报.(3)其它中断的处理行为.这些行为不是Timer0中断的处理行为,因此也不会属于RetxmitTimer.fired事件的处理过程.由于中断发生的随机性,这种行为可能随机交织进Timer0中断处理区间的任何非原子的执行段.图6所示的每个示例区间中都包含有SPI中断的处理行为.我们的目标是发现CtpForwardingEngineP.0.RetxmitTimer.fired事件处理过程中的偶然行为.当我们使用现有的方法,从包含有上述3类行为的程序执行中寻找目标偶然行为时,会受到这3类行为的干扰.对于Run11,当现有的方法使用“区间筛选策略”,并将过滤用的字符串指定为CtpForwardingEngineP.0.RetxmitTimer.fired时,可以消除待排序区间中的(1)类行为,但是仍然不能消除(2)和(3)类行为的干扰.其结果是Run11的错误区间排序为22(如表3第5列所示),即仍然存在21个误报区间.(1)包含1类行为的执行序列:(2)包含2类行为的执行序列:〈TIMER0中断发生〉AlarmToTimerC.0.Alarm.firedVirtualizeTimerC.0.Timer.firedCtpRoutingEngineP.0.BeaconTimer.firedCtpRoutingEngineP.0.updateRouteTask.postTaskCtpRoutingEngineP.0.sendBeaconTask.postTaskCtpRoutingEngineP.0.updateRouteTask.runTask〈SPI中断处理〉CtpRoutingEngineP.0.Routing.routeFoundCtpForwardingEngineP.0.UnicastNameFreeRouting.routeFoundCtpForwardingEngineP.0.sendTask.postTaskCtpRoutingEngineP.0.sendBeaconTask.runTask〈SPI中断处理〉〈SPI中断处理〉CtpForwardingEngineP.0.sendTask.runTaskCtpForwardingEngineP.0.SendQueue.empty…〈TIMER0中断发生〉AlarmToTimerC.0.Alarm.fired〈SPI中断处理〉VirtualizeTimerC.0.Timer.fired()BlinkToRadioC.TimerSense.fired()BlinkToRadioCSendsendCtpForwardingEngineP0SendsendCtpForwardingEngineP0SendQueueenqueueCtpForwardingEngineP0RetxmitTimerisRunningVirtualizeTimerC.0.updateFromTimer.postTask()VirtualizeTimerC.0.updateFromTimer.runTask()VirtualizeTimerC.0.Timer.fired()CtpForwardingEngineP.0.RetxmitTimer.fired()CtpForwardingEngineP.0.sendTask.postTask()CtpForwardingEngineP.0.sendTask.runTask()〈SPI中断处理〉CtpForwardingEngineP.0.SubSend.send()〈返回值为SUCCESS〉〈SPI中断处理〉…〈TIMER0中断发生〉AlarmToTimerC.0.Alarm.firedVirtualizeTimerC.0.Timer.firedCtpForwardingEngineP.0.RetxmitTimer.firedCtpForwardingEngineP.0.sendTask.postTaskCtpForwardingEngineP.0.sendTask.runTask〈SPI中断处理〉CtpForwardingEngineP.0.SubSend.send〈返回值为FAIL〉…(3)包含错误行为的执行序列:对于Run11,我们在使用新的区间划分策略之后,就从被分析区间中同时消除了上述的(1)和(2)类行为,从而将错误区间的排序提高到第19位(表5第3列).然而,在这些被分析的区间中仍然存在(3)类行为.图6(3)示例了包含错误的中断区间的执行序列,其中黑体部分的执行序列也出现在“使用新的区间划分策略后所得的错误区间”之中.这个Page14错误区间是应用级事件的处理区间,并不包含(1)和(2)类行为.然而如图6(3)所示,在此错误区间中交织了SPI中断的处理行为,即包含(3)类行为.此外,在其余大部分的正确区间中也交织了SPI中断或ADC中断的处理行为.总之,在这些被分析的应用级事件区间中仍然存在(3)类行为.我们通过使用新的程序行为选择策略,进一步消除了这些(3)类行为的干扰,从而将Run11的排序结果提高到第1位(如表5最后一列所示).在分析应用级事件的处理行为时,被分析区间中的上述3类行为可视为噪声.这些噪声行为的数量越多,它们干扰区间排序结果的可能性就越高,因此通过消除它们来减少误报的可能性也就越高.而我们的实验结果表明,(1)和(2)类行为在中断区间的全部行为中所占的比率很高:其比率分别等于(采用我们的区间划分策略之后)待排序区间的个数减少率和长度减少率,分别如表6的最后一列和表4的最后一列所示.从这两列可看出:对于除Run5~Run6之外的9个测试运行,(1)类行为的比率为27%~99.6%;而对于11个测试运行,(2)类行为的比率为36%~53%.Run5~Run6中不存在(1)类行为,这是因为所指定的应用级事件为异步事件;而在TinyOS的应用程序中,大部分的应用级事件都是同步事件.此外,因为在被测程序运行时,各种中断会随机产生,所以第(3)类行为会随机地出现在被分析的区间中.运行编号Run11497Run21203Run31639Run41800Run5Run6133Run727742Run827826Run921182Run10705Run111590综上所述,本文测试方法的有效性同时得益于新的区间划分策略和新的程序行为选择策略.这两种策略降低误报的原因是:排除了待排序区间中的3种程序行为的干扰,而这些程序行为并不属于指定应用级事件的处理过程.5.4效率的研究5.4.1实验设置在本节,我们研究RQ5.如前所述,我们基于算法1实现了新测试方法的工具,简记作“Ours工具”.我们研究Ours工具的在线处理效率,并和Sentomist工具进行比较.每种工具的在线处理过程包括识别区间和收集区间中的程序执行信息,而其离线处理过程对收集到的信息进行离线的分析.对于每种工具,我们只评估其在线处理过程的时空开销,而不启动其离线处理功能.我们仍使用前述的Sub1~Sub5作为被测程序,监测它们在单个节点上的运行开销,这些开销可能随运行时间的增加而递增.表7的第2列报告了被测程序的9组测试运行的设置.每个测试运行组Ri(1i9)由4次测试运行组成,每次运行分别对应以下4个运行时长:10s、50s、100s和150s.因此,第2列共包括9×4=36个测试运行.源节点的采样周期也可能影响某个节点的运行开销.表7的第3栏列出了每个测试运行组中、源节点的采样周期.对于每一个采样周期可变的被测程序(即Sub1~Sub2和Sub4),我们分别使用两个不同的采样周期(其中一个较长,另一个较短)来运行被测程序.Sub3的采样周期由Avrora的默认值确定.第4栏列出了每个运行组的被监测节点.表7用于效率评估的被测程序及其运行设置被测程序运行组号采样周期/ms被监测的节点Sub1R1Sub2R3Sub3R5Avrora的缺省值源节点Sub4R6Sub5R8由TestCTP设置正常的节点我们将每个工具分别应用于表7所列的每次测试运行,并测量工具的在线处理部分的运行时开销.为了计算每个工具用于在线处理的空间开销,我们用工具运行时所消耗的内存量减去模拟器运行时所消耗的内存量;为了计算每个工具用于在线处理的时间开销,我们以减速因子(slowdownfactor)为单位,测量因工具的在线处理而造成的程序运行减速情况.减速因子等于工具的在线处理过程的执行时间与被分析程序的运行时间之比率.Page155.4.2实验结果与分析图7和图8对比显示了两种工具用于在线处理过程的开销.浅灰色柱体表示Ours工具的开销,而黑图7用两种方法进行在线处理的空间开销图8用两种方法进行在线处理的时间开销在图7中,柱体代表在线处理的空间开销,其柱体高度表示以MB为单位的内存使用量.从图中可以看出:两种工具的空间开销都会随模拟时间的延长而增加.从单个测试运行来看,Ours的空间开销低于或等于Sentomist的空间开销.从所有的测试运行来看,Ours的最大开销低于70MB.与此相反,当运行时间达150s时,Sentomist的最小开销都超过120MB;而当运行时间不少于50s时,Sentomist应用在R2和R4上的开销甚至超过220MB.以上结果表明:我们工具的在线处理过程具有更低的空间开销;而且两种工具的开销差别随运行时间的延长而愈加明显.图8显示了减速情况的实验结果.为了分析时间开销随运行时间变化的平均趋势,我们以具有相同运行时间的测试运行组为单位,计算每组中9个测试运行的平均时间开销.每个测试运行的减速因子和每组的平均减速因子分别用柱体和虚线表示,柱体或虚线的高度代表减速因子的值.从图中可看色柱体代表Sentomist工具的开销.每一个测试运行占据水平轴的一个位置,而36个测试运行按照其模拟运行的时长(即10s,50s,100s和150s)被分为4组.出:两种工具的时间开销都会随运行时间的延长而增加,但是从每个测试运行来看,Ours都比Sentomist的时间开销低.对所有的测试运行而言,Ours的减速情况都是相近的,即无论运行时间有多长,每组测试运行的平均减速因子都是1.1倍;相比之下,Sentomist的减速趋势随运行时间延长而愈加明显,在运行时间为10s、50s、100s和150s时的减速因子分别为1.7倍、4.7倍、8.5倍和11.4倍.例如,当被测程序的运行时间为150s(即大约2.5min)时,Ours的在线处理过程只需要165s(即大约3min)、而Sentomist的在线处理过程则需要1710s(即大约30min).总之,以上的实验结果表明:和已有的测试方法相比,我们的测试方法用于在线处理的时间开销和空间开销都有明显的降低,特别是时间开销的降低尤为明显;而且这种降低随着运行时间的延长而愈加显著.另一方面,当被测程序的运行时间较短时,现有工具的在线处理效率仍是可接受的;而新工具Page16的效率优势主要体现在需要较长时间地运行被测程序时.新工具在时空开销上的优势主要得益于其区间识别技术的两个特点:(1)只使用两个长度很小的数据结构(即堆栈instS和队列instQ)来动态地存储少量的信息,而不是使用列表增量地保存大量的信息;(2)能够实时地识别区间的终点.这种区间识别技术在效率上的优势,使得它有可能运用在更多潜在的基于区间的测试方法中,尤其是运用在需要实时地分析区间数据的场合.6相关工作随着无线传感器网络的应用和研究的增多,出现了越来越多的软件测试、验证与调试技术.下面分类简介其中的部分工作.而文献[2]从更广泛的视角对这些技术进行了综述.基于数据挖掘的测试与调试.Sentomist[5]是基于指令级模拟器的测试技术,它利用one-classSVM作为异常检测算法分析指令的执行计数,以发现程序的瞬态错误.为了帮助测试者识别错误的原因,Diagnostic-simulation[11]利用扩展的TOSSIM模拟器记录系统运行中的事件序列,并对这些事件日志进行频繁模式挖掘;Dustminer[12]和SNTS[13]利用日志引擎[14]捕获系统在正常与故障两种运行情况下的事件历史,并对两种情况下的事件日志进行判别规则挖掘.文献[15]系统地综述了运用数据挖掘来测试和调试WSN程序的技术.基于静态分析的测试.Lu等人[16]研究了上下文感知应用程序中基于数据流的测试覆盖准则.Lai等人[4]基于上下文间(inter-context)的流图,提出了一种用于nesC程序的测试覆盖准则,此图捕获由中断驱动的组件内交互行为.Le等人[17]基于中断间的流图和一个懒抢占(lazy-preemption)模型,提出了一种基于路径的全程序分析方法.FSMGen[18]通过静态分析生成了TinyOS程序的状态机模型,可帮助测试者理解应用逻辑,从而有助于发现错误.验证与检测.T-Check[19]和KleeNet[20]基于模拟器对程序的状态进行深度搜索.其中T-Check利用模型检测和随机测试来发现错误,而KleeNet通过建立非确定性事件模型和符号分析来查找错误.Anquiro[21]和文献[22]中的模型检测技术用于验证Contiki操作系统上的应用程序.运行时检查与调试.Harbor[23]、SafeTinyOS[24]和Neutron[25]检查违反内存安全、类型安全和并发安全的错误.Interface-contract[26]检查组件接口错误.Marionette[27]和Clairvoyant[28]提供类似GDB的功能、用于在节点级进行交互式调试;EnviroLog[14]能记录和重放在底层产生的事件以用于性能评估和调试;Declarative-Tracepoints[29]和NodeMD[30]利用简单的批注和日志记录来发现和排除严重的程序错误.ADA[31]采用自适应的源码级追踪和重放技术对部署后的程序进行错误诊断,可分析和调试属性违反错误,且能有效地控制调试中的时空开销.7结论本文提出了一种新的基于区间的测试方法,以有效地检测传感网应用级组件中的瞬态错误.此方法的主要特点是采用了基于应用级事件的区间划分策略和程序行为选择策略.与现有的方法相比,这两个策略可降低甚至消除待排序区间中的良性偶然行为,并报告更短的可疑区间.我们提出了一种高效的区间识别算法.基于此算法,开发了一个原型工具以实现我们的方法.通过实验评估了我们测试方法的有效性.实验结果表明,我们的方法能够有效地将错误区间排在前列,并能明显地减轻测试者在人工检查单个区间时的负担,从而有效地缓解了TestOracle问题.我们通过实验评估了我们测试工具的运行效率.实验结果表明,和现有的工具相比,我们的测试工具的在线处理过程具有更高的时空效率.现有的基于区间测试方法包括4个关键策略,即区间的划分策略、程序行为的选取策略、程序行为特征的选取策略和错误区间的检测策略.新方法虽然只是对现有方法的前两个策略进行改进,但是能明显地改善错误检测的有效性.我们的后续工作包括:尝试改变上述的后两种策略,并研究这种改变对测试效果的影响;用更多样的被测程序和测试用例来检验新方法的有效性;探讨在单个区间中包含多个错误时的测试方法;以及针对非瞬态错误,开发新的基于区间的测试技术.致谢审稿专家和编辑为本文提出了宝贵的意见和建议,作者在此表示衷心感谢!Page17
