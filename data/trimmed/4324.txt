Page1基于完备抽象解释的性质强保留抽象研究钱俊彦1),2)赵岭忠2)蔡国永2)1)(武汉大学软件工程国家重点实验室武汉430072)2)(桂林电子科技大学广西可信软件重点实验室广西桂林541004)摘要在模型检验中,抽象是解决状态空间爆炸问题的重要方法.通常的抽象是非强保留的,即可能存在时序性质在抽象模型不满足而在具体模型满足的情况.文中首先系统地构造μ-演算Lμ语义模型的安全抽象,在此基础上,转换为通用Kripke结构下的安全抽象.然后基于抽象解释框架及完备抽象解释和性质强保留之间的关系,构造使得Lμ性质强保留的最小抽象模型精化,并转换为抽象解释中抽象域的最小完备精化.依据此完备抽象域求得性质强保留的最优抽象状态划分,从而构造出性质强保留且最优的抽象状态转换系统.关键词抽象解释;模型检验;性质强保留;完备性;精化1引言模型检验[1]是一种通过有限状态空间搜索来保证软硬件设计正确性的形式化自动验证技术,能在模型不满足规格时给出反例.其应用面临的主要问题是状态空间爆炸.由于系统模型的有穷状态数量往往随其模型的并发分量增加呈指数增长,因此,在复杂系统建模时,其可达的状态空间常常难于在计算机存储器中全部构建,从而无法进行模型检验.为此,学术界提出两种解决方案:一种途径是基于模型状态空间的结构特点来缓解状态空间爆炸问题,主要方法包括符号化模型检验、对称模型检验、偏序模型检验、On-the-fly模型检验等.另一种途径是通过抽象和分解把复杂系统验证转化成模型检验可处理问题,主要方法包括抽象、组合等.抽象技术的主要思想是在具体模型中去除与待验证性质无关的信息,获得简化模型,从而减小模型检验时的问题规模,其目标是从具体模型中抽象所期望的性质,构造系统的抽象模型,使之足够小而能有效分析.抽象必须满足:若具体模型具备所验证性质,则简化的模型亦具备该性质.抽象模型检验已经在硬件验证领域取得巨大成功,特殊情况下能验证有101300可达状态的ALU电路[2].通常,典型的抽象转换系统构造如下:(1)确定抽象状态空间:通过抽象关系获得与具体状态相对应的抽象状态,抽象关系可能是任意的,例如谓词抽象[3]或数据抽象;(2)在抽象状态空间确定转换关系,从而得到抽象转换系统;(3)此方法是安全的,即保留了所验证的时序逻辑性质,但不能保证是完备的.现阶段抽象模型检验的难点是抽象转换系统通常不能自动构造,需要用户参与,并且对特定抽象方法的理解及其改进也相当困难.例如文献[4]中谓词抽象和对称缩减方法仅仅在于选择抽象状态空间的不同.本文主要目标是自动构造性质强保留的抽象系统,避免抽象模型因抽象过于粗糙而反复精化.弱保留抽象因无需保留具体模型的所有性质,故其抽象模型相对强保留抽象较小.从抽象状态空间而言,强保留抽象不如弱保留抽象,但从效率上比较,强保留抽象强于弱保留抽象.实际上,μ-演算Lμ性质强保留抽象也不是保留具体模型的所有性质,而是仅仅保留所有与Lμ相关的性质.文献[5-6]给出了完备抽象域与具体域之间的关系及抽象效果,且从下文中也可看出,仅令抽象域对于{,pre[R]}两个操作算子完备即可获得强保留抽象,故强保留抽象对具体模型而言,其抽象效果是明显的.基于抽象解释框架,无穷域空间可抽象为有穷域,在一般情况下,构造仅对{,pre[R]}算子完备的强保留抽象与其弱保留抽象而获得的抽象状态空间不会有数量级的差距.且当弱保留抽象过于粗糙时,由于缺乏完备性,可能产生不合理反例,需反复精化抽象模型,最坏情况下,其反复精化后的模型也是完备的.为了能自动构造性质强保留的抽象模型,本文首先基于抽象解释的理论及μ-演算语义,系统地构造μ-演算Lμ语义模型的安全抽象,转化为通用的Kripke结构.然后基于抽象解释理论[7]及抽象完备性,根据完备抽象解释和性质强保留之间的关系(即如果抽象域对μ-演算算子是完备的,则相对应的抽象划分是性质强保留的),抽象模型使得Lμ性质强保留的最小精化,可转换为抽象解释中抽象域的最小完备精化.通过抽象域的最小完备精化,获得性质强保留且可划分的抽象闭包,构造完备抽象模型,且强保留模态μ-演算公式Lμ.并依据此抽象域求得Lμ性质强保留的最优抽象状态划分,最后构造出Lμ性质强保留且最优的抽象状态转换系统.2基础知识2.1基础符号定义1.幂集.设X是一个集合,X的幂集(X)是X所有子集的集合,定义为(X)={S|SX}.定义2.笛卡儿集.设X,Y是两个集合,X和Y的笛卡儿集X×Y定义为X×Y={(x,y)|x∈X∧y∈Y}.定义3.二元关系.设X,Y是两个集合,ρX×Y是X到Y的二元关系,其中X称为定义域,Y称为值域.如果X=Y,则称ρ是X上的二元关系(x1,x2)∈ρ又记做“x1ρx2”.定义4.关系合成.ρ1X1×X2和ρ2X2×X3是两个二元关系,ρ1和ρ2的合成ρ1ρ2是X1到X3的二元关系,且ρ1ρ2={(r,t)|(r,s)∈ρ1∧(s,t)∈ρ2}.定义5.偏序关系.设X是一个集合,对于所有X上的a,b,c,X上的二元关系满足:(1)自反性:aa;(2)反对称性:ab,baa=b;(3)传递性:ab,bcac.则称(X,)为偏序集.假定任意集合X和偏序集(Y,),函数f,g:Page3X→Y,则函数存在偏序关系fg当且仅当对所有x∈X,f(x)g(x).定义6.上界和下界.设(X,)为偏序集,SX,u,v∈X,u是集合S的一个上界当且仅当x∈S,xu;v是集合S的一个下界当且仅当x∈S,vx.定义7.上确界和下确界.设(X,)为偏序集,SX,u,v∈X,u是集合S的上确界,记做S,当且仅当u是集合S的一个上界,且对S的任意上界v,uv;w∈X是集合S的下确界,记做S,当且仅当w是集合S的一个下界,且对S的任意下界t,tw.定义8.格.假定(X,)是偏序集,如果X的任意有限子集S均存在上确界S和下确界S.则称偏序集(X,)是一个格.定义9.完备格.假定(X,,)是完备格,当且仅当X的任意非空子集S都有最小上界S和最大下界S,其中=X=是X的最小元,=X=是X的最大元.定义10.链.假定(X,)是偏序集,如果X中的任意两个元素之间均可比较,即x1,x2∈X,x1x2∨x2x1,则称X是为链.定义11.单调映射.设(X,)和(Y,)是两个偏序集,f:X→mY被称为单调映射当且仅当x1,x2∈X,x1x2f(x1)f(x2).定义12.连续映射.设(X,)是偏序集,f:X→cX被称为向上连续映射(简称连续映射)当且仅当对任意链X1X,X1存在,且f(X1)=f(X1).定义13.可加函数或join同态.设(X,)和(Y,)是两个偏序集,f:X→aY被称为可加函数当且仅当对任意集合X1X,如果X1存在,则f(X1)=f(X1),也就是说函数保留任意集合的最小上界.定义14.函数的不动点.设(X,)是偏序集,f:X→X为函数,如果f(x)=x,则x∈X是f的不动点.定理1.Tarski不动点[8].设(X,,,,,)是完备格,f∈X→cX是连续映射,则f存在最小不动点且lfp(f)={fn()|n∈},其中是X的最小元,f0(x)=x,fi(x)=f(fi-1(x)).定理2.设X,,,,,是完备格,f:X→mX是单调映射,则最小不动点lfp(f)={x|f(x)x},最大不动点gfp(f)={x|xf(x)}.μ(y);定义15.划分.X是非空集合,X1,X2,…,Xm(Xi≠,i=1,2,…,m)是它的子集,满足:(1)Xi∩Xj=(i≠j);(2)X1∪X2∪…∪Xm=X.则称P={X1,X2,…,Xm}为X的一个划分,而X1,X2,…,Xm称为这个划分的块.下文用符号Part(X)表示X的划分集.通常集合上的一个等价关系可确定一个划分,同样,集合的一个划分亦可确定一个等价关系,例如,如果≡X×X是等价关系,那么P≡∈Part(X)是对应的划分.反之,如果P∈Part(X)是一个X的划分,那么≡P表示对应在X上的等价关系.令符号表示补集,则SX的补集(S)=X\S.定义16.向上闭包运算.设(X,,,,,)是完备格,μ:X→X是向上闭包运算,则μ满足如下性质:(1)单调的:假设x,y∈X,若xy,则μ(x)(2)幂等的:μ=μμ;(3)扩展的:对任意x∈X,xμ(x).假定完备格X,uco(X)表示通过向上闭包运算获得的所有闭包集合,且具有偏序关系,即〈uco(X),〉.对任意μ,η∈uco(X),μη当且仅当η(X)μ(X).如果〈X,μ(x),∨,∧,,〉是完备格,那么〈uco(X),,,,λx.,λx.x〉也是完备格.在不产生岐义的情况下,也用μ表示μ(X),故根据上下文μ某些地方作为函数,某些地方作为集合.μ∈uco(X)可通过不动点集合唯一确定,即μ(X){x∈X|μ(x)=x}.当SX对并操作封闭时,即S=M(S){∧Y|YS}(其中∧=∈S),则S是Moore簇.假定μ:X→X是向上闭包运算,则μ(X)是一个Moore簇.2.2模态μ-演算定义17.μ-演算公式.假定Var是变量集,AP是原子命题集,μ-演算公式Lμ是满足如下语法的所有公式集合其中p∈AP,z∈Var,μz.φ(z)表示最小不动点.假定μ-演算公式Lμ,与其直接相应的语义模型为=(Σ,(p)p∈AP,对每个p∈AP,p属于Σ,Lμ的解释是公式Lμ到状态集合Σ上的映射,即·:Lμ→(Σ),例如φ=XΣ表示满足公式φ的状态集合.Lμ在模型上的解释表示为·,在不产生歧义情况下,简写为·.Page4公式φ在结构上的解释φσ归纳定义如下:pσpzσσ(z)φ∧ψσφσ∩ψσφσφσμx.φσlfp(λS.φσ[x→s])φσ其中σ:Var→Σ表示对自由变量的对象赋值,lfpf是函数f的-最小不动点.通常系统建模采用Kripke结构.Kripke结构是一个有限状态自动机,原子命题标签其状态表示此状态满足原子命题的性质.由于Kripke结构能极好地表示基于操作语义的程序模型,诸如数据流、Statecharts、进程等,故本文把Lμ公式的解释应用于Kripke结构.定义18.Kripke结构.Kripke结构是一个四元组=(AP,Σ,I,R),其中AP是原子命题集合,Σ是状态集,I:AP→(Σ)是原子命题到Σ子集的映射,R:Σ→Σ是转换函数.参考文献[1],转换函数R在(Σ)上的前向/后向转换定义如下:(1)pre[R]λX.{s∈Σ|t∈X.s→Rt};(2)p槇re[R]pre[R]=pre[R](珡X)=λX.{s∈Σ|t∈Σ.s→Rtt∈X};(3)post[R]λX.{t∈Σ|s∈X.s→Rt};(4)p槇ost[R]pre[R]=λX.{t∈Σ|s∈Σ.s→Rts∈X};直观地,post[R](S)表示状态集S的后继集合∪s∈SR(s)与Σ有一个非空的交集,pre[R](S)表示状态S的前驱集合.通过Kripke结构=(AP,Σ,I,R)导出Lμ模型()=(Σ,(p())p∈AP,I(p),定义为φφ().2.3抽象解释标准抽象解释框架理论中,抽象域可通过Galois连接/Galois入射或闭包操作来获取,两者是等价的.本节也给出了二元关系ρ导出Galois连接.定义19.Galois连接.完备格(C,,,,,)和(A,,,,,)分别表示具体域和抽象域,二者之间的Galois连接是一个序偶(α,γ),其中α∈C→A和γ∈A→C为完全映射,满足c∈C.a∈扩张的);A.α(c)acγ(a).α和γ分别称为该连接的抽象和具体化映射.给定完备格C和A,为了描述方便,后面章节使用(C,α,γ,A)表示为Galois连接.参考文献[9],Galois连接具有如下性质.命题1.假定(α,γ)是(C,)和(A,)之间的Galois连接,则以下结论成立:(1)αγ:A→A满足:a∈A.αγ(a)a(αγ是收缩的);(2)γα:C→C满足:c∈C.cγα(c)(γα是(3)α是单调映射,即c1,c2∈C.c1c2α(c1)α(c2);(4)γ是单调映射,即a1,a2∈A.a1a2γ(a1)γ(a2).命题1中,(1)说明抽象性质的具体化过程不损耗任何信息;而(2)则表明具体性质的抽象过程包含信息的损耗.并可证明:命题1的逆命题成立,即:命题2.假定α:C→A和γ:A→C为单调映射,a∈A.αγ(a)a且c∈C.cγα(c),则(α,γ)是(C,)和(A,)之间的Galois连接.命题3.(C,)和(A,)之间的Galois连接(α,γ)具有以下性质:(1)a∈A:γαγ(a)=γ(a);(2)c∈C:α(c)=αγα(c).命题4.假定(α,γ)为(C,)和(A,)之间的Galois连接,则:(1)α是满射当且仅当γ是一一映射当且仅当a∈A.αγ(a)=a,在此情况下Galois连接被称为Galois满射;(2)α是一一映射当且仅当γ是满射当且仅当c∈C.γα(c)=c,在此情况下Galois连接被称为Galois入射.命题5.(C,)和(A,)之间的Galois连接(α,γ)定义了如下闭包运算:(1)αγ是向下闭包运算,即αγ是单调、收缩和幂等的;(2)γα是向上闭包运算,即γα是单调、扩展和幂等的.下文描述二元关系ρ导出Galois连接.给定任意具体集X和抽象集Y,ρX×Y是安全的二元关系,对于x∈X,y∈Y:xρy读为yρ-近似x.具体化函数γ:Y→(X)表示抽象元素映射到与其对应的具体元素集,即γ(y){x|xρy}.如果把Y中的元素Page5作为性质来看,诸如“正的”或“奇数的”,那么γ(y)是满足性质y的具体元素集合.具体化函数γ在Y上有一个近似序ρ满足y1ρy2γ(y1)γ(y2).抽象函数α:(X)→Y表示具体元素映射到其最好的近似,即xρyyYα(x)和x∈γ(y)yYα(x).通过二元关系ρ导出Galois连接的性质[15]如下.命题6.给定X和Y是状态集合,安全关系ρX×Y,那么(post[ρ],p槇re[ρ])是((X),)和((Y),)之间的Galois连接.同理,通过Galois连接也能导出二元关系.命题7.给定X和Y是状态集合,如果(α,γ)是((X),)和((Y),)之间的Galois连接.则存在唯一关系ρX×Y,且满足α=post[ρ],γ=p槇re[ρ].假定(α,γ)为〈C,〉和〈A,〉之间的Galois连接,让f:C→C表示在复杂语义规约中任何语义函数,f#:A→A表示抽象语义函数,其中A∈uco((Σ)).如果αff#α,则〈A,f#〉为安全的抽象,或者说f#是f相对于A的正确近似.如果αf=f#α,则〈A,f#〉是完备的.由于αff#ααfγf#,那么f相对于抽象域A最正确的近似fb=αfγ.并可得到如下结论[5]:给定A,存在f#满足〈A,f#〉是完备的当且仅当〈A,fb〉是完备的.这表明,完备是抽象域的性质,故而引出如下问题:抽象域能否被最小精化或简化,获得完备抽象域.下面使用向上闭包运算来描述抽象域,给定具体域C,μ(C)表示抽象域.在uco(C)上的序表示抽象域的精确性,例如A1比A2更精确(具体)当且仅当A1A2.最小上界和最大下界分别表示比一簇抽象域中更粗糙的抽象和更精化的抽象.抽象域的Shell精化和Shell核算子定义如下.定义20.Shell精化[10].假定(C,,,,,)是完备格,uco(C)是抽象域性质,μ,σ∈uco(C),那么σ是μ的-Shell精化,需满足如下条件:(a)σ∈,(b)σμ,(c)如果η∈且ημ,那么ση.给定任意μ∈uco(C),如果(μ)是完备的,则算子:uco(C)→uco(C)称为完备精化算子.定义21.Shell核.假定(C,,,,,)是完备格,uco(C)是抽象域性质,μ,σ∈uco(C),那么σ是μ的-Shell核满足:(a)σ∈,(b)μσ,(c)如果η∈且μη,那么ησ.给定任意完备域μ∈uco(C),如果(μ)是最小完备的,则算子:uco(C)→uco(C)称为完备核算子.3模态μ-演算的安全抽象本章节首先描述模态μ-演算公式在Lμ语义模型的安全抽象,即如果抽象模型满足Lμ公式,则具体模型满足Lμ公式,然后把此安全抽象应用于Kripke结构上.给定模型模拟获得抽象模型.本节主要描述将基于Galois连接(α,γ)的模拟关系(称为(α,γ)-模拟)和基于关系ρ的模拟关系(称为ρ-模拟)以及它们之间的关系.(p是((Σ),)和((Σ),)之间的Galois连接,则定义22.(α,γ)-模拟.给定模型)p∈AP,说(α,γ)如果是定义23.ρ-模拟.给定模型)p∈AP,(p关系ρΣ×Σ,那么ρρpre(如果的ρ-抽象或命题8.给定模型)和Σ×Σ,存在((Σ),)和((Σ),)之间的Galois连接(α,γ),满足命题9.给定模型=(Σ,(p和和((Σ),)之间的Galois连接(α,γ),存在关系ρΣ×Σ,满足通过命题8和9,可得ρ-模拟与(α,γ)-模拟是一致的,并根据参考文献[11],采用安全关系来描述安全抽象.给定具体模型象模型状态集合,存在安全关系ρeΣ×Σ,满足pre(ρeρepre(((Σ),αe,γe,(Σ)),其中αe=post[ρe],γe=p槇re[ρe].为了描述状态集合之间的抽象关系,定义安全关系ρs(Σ)×(Σ)表示(Σ)ρs-近似(Σ).Page6假设T∈(Σ)和S∈(Σ)是抽象和具体状态的集合,形式化描述ρs如下SρsTa∈T,c∈γe(a)∩S.cρea.并可得抽象函数为αs(S)c∈γe(a)∩Tαe(c).为了描述Lμ公式在具体模型的解释近似于抽象模型中,扩展安全关系ρs为ρi.ρi的形式化描述如下:·如果Lμ公式在抽象模型的解释·模型的解释·模型ρm给定Lμ模型,考虑操作符,可确定一般模态公式的解释,扩展安全关系ρs为ρ,形式化描述如下:Y∈γs(X):对应的抽象函数α描述如下:α(定理3.给定Lμ公式,)是具体模型,象模型,如果存在安全关系ρeΣ×Σ,满足ρe证明.为了证明证明φ∈Lμ:φρippρe-近似c∈pa∈p(p(p(p(p(p(p通过上述,给定具体模型((((的抽象模型此基础上,求解基于状态集合和操作符的安全抽象关系ρi和ρ.(2)由于p∈AP,pρ-近似)ρm-近似具体模型(3)获得具体模型(αi(p然而系统通常采用Kripke结构建模,下面将描述Kripke结构的安全抽象.假定具体Kripke结构=(AP,Σ,I,R),抽象Kripke结构Σ,I,R),其中Σ通过Galois连接((Σ),α,γ,(Σ))获得.Kripke结构上的安全关系ρk可通过Lμ模型上安全关系ρm获得,构造如下:(ρk类似地,通过定理3,在Kripke结构上的安全关系ρ可被分解到Kripke结构的转换关系上,形式化描述如下:ρk其中转换函数的近似关系ρt为对应的抽象函数αt描述如下:αt(pre[R])(X)Y∈γ4可划分的完备抽象模型通过上节所描述的方法,可构造出Lμ模型的安全抽象,并应用于Kripke结构中.然而此抽象不能保证性质强保留,文献[5,12]指出当抽象缺乏完备性,可能导致不合理反例.为了消除不合理反例,本节介绍抽象模型的最小可划分完备精化.首先定义闭包集合和抽象关系ρ之间的关系.定义24.闭包集合和安全关系ρ之间的关系描述如下[9]:(1)给定状态集Σ和Σ,ρΣ×Σ是抽象关系,则((Σ),post[ρ],p槇re[ρ],(Σ))是Galois连接,且μρp槇re[ρ]post[ρ]∈uco((Σ))是闭包运算.(2)让Σ是状态集合,μ∈uco((Σ))是闭包,那么通过抽象关系ρμ的状态划分Σμ定义如下Σμ{μ({c})∈(Σ)|c∈Σ},其中〈c1,μ({c2})〉∈ρμμ({c1})=μ({c2}).抽象Kripke结构Σ×Σ是抽象关系,则((Σ),αe,γe,(Σ))是Galois连接,其中αe=post[ρe],γe=p槇re[ρe].定义f:(Σ)→m象解释为〈语义函数.文献[8]指出f是f的正确近似,即αefαeαefγef,当fb=αefγe:(Σ)f→(Σ),fb是f相对于抽象域(Σ)的最优近似.当αef=fαe,〈γe=αefγe=fb是最优完备近似.给定抽象域假定具体Kripke结构Page7,fb〉是完备的,而fb的完备性依赖于抽象域的(Σ),存在f使得〈〈性质.为了描述抽象解释〈包运算μ=γeαe∈uco((Σ))表示(Σ).定义25.完备性.让(Σ)→m如果μf=μfμ,那么μ对f是完备的.如果F(Σ)→m么μ对F来说是完备的.给定任意函数F(Σ)→mF){μ∈uco((Σ))|f∈F,μf=μfμ}.当F={f}时,简写为Γ((Σ),f),并根据文献[6]可得到如下推论.推论1.对于完备性有如下性质:(1)λx.x∈Γ((Σ),F);(2)如果μ∈Γ((Σ),F〉,δμ,那么δ∈Γ((Σ),F);(3)如果μ∈Γ((Σ),F〉,δμ,ημ,那么δη∈Γ((Σ),F).定义26(完备核与完备精化).给定F(Σ)→m(Σ),μ∈uco((Σ)),μ的完备核F(μ):uco((Σ))→uco((Σ))和最小完备精化F(μ):uco((Σ))→uco((Σ))定义为F(μ){η∈uco((Σ))|μη,η∈Γ((Σ),F)},F(μ){η∈uco((Σ))|ημ,η∈Γ((Σ),F)}.从定义26可以看出,F(μ)是所有比μ更抽象的完备域的上确界,而F(μ)是所有比μ更具体的完备域的下确界.由于F(μ)∈Γ((Σ),F),则称F(μ)为μ的完备核;F(μ)∈Γ((Σ),F),则称F(μ)为μ的最小完备精化.对任意f:(Σ)→(Σ),Y∈(Σ),根据参考文献[6],定义集合Y对函数f的依赖集定义为Y{X∈(Σ)|f(X)Y},并且可得如下定理.Hf定理4.设F(Σ)→cuco((Σ)),那么μ∈Γ((Σ),F)μ{Y∈(Σ)|∪f∈FHf(Σ)|∪f∈FHf给定连续函数集F(Σ)→c算子映射F:uco((Σ))→uco((Σ)),精化算子F:uco((Σ))→uco((Σ))如下:μ∈Γ((Σ),F)F(μ)μμF(μ),则定理4能重新描述表示为根据上述,使用映射F和F可重新定义26,描述如下.定义27.完备核与完备精化.给定F(Σ)→m(Σ),μ∈uco((Σ)),μ的完备核F(μ)和最小完备精化F(μ)定义为:F(μ){η∈uco((Σ))|F(μ)η}=μF(μ),F(μ){η∈uco((Σ))|ηF(μ)}=μF(μ).假定μ∈Γ((Σ),F),根据定理4可得F(μ)μF(μ),通过推论1(3),则μF(μ)∈Γ((Σ),F),故μ的完备核F(μ)是μ和F(μ)的上取界.对于任何μ∈uco((Σ)),因为μF(μ)F(μ),则μF(μ)∈Γ((Σ),F),故μ的最小完备精化F(μ)是μ和F(μ)的下确界.定理5.F(Σ)→mμ的完备核F(μ)和最小完备精化F(μ)总是存在的.证明.根据定义容易可得μ的完备核F(μ)和最小完备精化F(μ)总是存在的.证毕.定理5证明了抽象域μ的完备核和最小完备精化存在,然而本文主要关注抽象域的最小完备精化.下面将描述对补集和前向转换pre[R]的最小完备精化.文献[13]的定理4.4指出可划分闭包对补集是完备的,故首先求解可划分精化.给定抽象域μ∈uco((Σ)),由抽象解释((Σ),αμ,γμ,μ)获得,相对应的抽象Kripke结构μ=(AP,Σμ,Iμ,Rμ),其中RμΣμ×Σμ是在抽象状态空间Σμ的抽象转换关系.抽象状态空间Σμ=par(μ)是Σ关于抽象域μ的状态划分.为了便于描述,设ucoP((Σ))表示所有可划分的闭包集合,定义par:ucoP((Σ))→Part(Σ)表示从可划分的闭包获得一个划分,par(μ)={[s]μ|s∈Σ}.因此par(μ)∈Part(Σ)表示与抽象域μ∈ucoP((Σ))相对应的划分.参考文献[14],可得如下命题.命题10.让μ∈uco((Σ)),那么μ∈ucoP((Σ))当且仅当μ是可加的,且{μ({s})}s∈Σ是Σ的一个划分,即par(μ)={[s]μ|s∈Σ}.为了描述方便,集合采用紧缩形式描述,比如{12,3}表示{{1,2},{3}}.给定Σ={1,2,3},μ1={1,12,13,123},μ2={,1,2,123},μ3=({1,2,3}),μ1和μ2不是可划分的闭包,因为{μ1({s})}s∈Σ={1,12,13}和{μ2({s})}s∈Σ={1,2,123}不是状态集Σ的一个划分.然而对于闭包{,12,3,123}是可划分的,其划Page8分为{12,3}.假定=(AP,Σ,I,R),μ∈uco((Σ))是通过(Σ)获得的抽象域,可把μ看作所期望的性质,par(μ)的状态表示具体结构中不能被闭包μ区分的状态,也就是说这些状态属于闭包μ的同一集合划分.根据定义24(2),等价关系≡μ(Σ)×(Σ)满足:X∈(Σ),Y∈(Σ):X≡μY当且仅当{μ(x)∈(Σ)|x∈X}={μ(y)∈(Σ)|y∈X},显而易见≡μ是关于性质μ的计算行为是等价的.当{x}≡μ{y}时,简写为x≡μy.上述部分已描述了如何获得不完备的抽象划分,为了得到对补集和前向转换pre[R]的最小完备精化,参考文献[10,14],定义可划分精化算子如下.定义28.可划分精化.给定任意状态集Σ,可划分精化算子:uco((Σ))→uco((Σ))定义如下:(μ)λY∈(Σ).{x∈Σ|y∈Y.x≡μy}.显而易见,算子是良式的,也就是说对于μ∈uco((Σ)),(μ)是封闭的.实际上精化算子也可采用算子来描述,即(μ)=(μ),表明可划分闭包对补集是完备的.根据命题10,(μ)是可加的且(μ)∈ucoP((Σ)).例如上例中的μ1={1,12,13,123}是不可划分的,其划分精化为(μ1)={,1,2,3,12,13,23,123}.为了描述μ对前向转换pre[R]的完备精化,根据定义27,F(μ)=μF(μ)=μ∪(∪f∈F,Y∈μHf是μ对操作F的最小完备精化,从而可求解μ对pre[R]的最小完备精化,其中Hpre[R]μ(pre[R]({x}))μ(pre[R](Y))}.为了进一步描述,定义算子pre[R].定义29.假定=(AP,Σ,I,R),定义算子pre[R]:uco((Σ))→uco((Σ))如下:pre[R](μ)λY∈(Σ).{x∈Σ|μ(pre[R]({x}))显而易见,算子pre[R]是良式的,即对μ∈uco((Σ)),pre[R](μ)是封闭的.定义30.假定=(AP,Σ,I,R),算子pre[R](μ)=pre[R]:uco((Σ))→uco((Σ))定义如下:pre[R](μ)λY∈(Σ).{x∈Σ|y∈Y.pre[R]({x})≡μ通过定义30,可知对任意μ∈uco((Σ)),pre[R](μ)是可划分闭包,且是可加的.让pre[R](μ)=μpre[R](μ),其最大不动点λμ.gfp(pre[R])就是μ对前向转换的完备精化.考虑可划分和完备精化组合,能通过求解最大下确界而得,根据定义27定义如下.定义31.假定=(AP,Σ,I,R),精化算子{,pre[R]}(μ):uco((Σ))→uco((Σ))定义如下:μpre[R](μ)(μ)=μpre[R](μ)(μ).定理6.对μ∈uco((Σ)),λμ.gfp({,pre[R]})是μ的最小可划分且完备精化闭包.证明.通过定义29、30和31容易证明.证毕.5构造划分且强保留的抽象模型).基于抽象解释框架,抽象语义结构〉,其中假定p∈AP属于原子命题集,f∈OP={∧,,}是模态μ-演算的操作算子.Lμ公式的具体解释采用语义结构来描述(AP,Σ,I,R)表示具体Kripke结构,·(Σ)是Lμ公式在具体语义域(Σ)上的解释函数,表示具体语义域中Lμ公式为真的状态集.对于原子命题p,其解释函数p于操作算子f,其解释函数f其中n>0,即∧pre[R].通过上述,对于含有操作算子的Lμ公式时,其解释函数f(φ1,…,φn)φn·结构,抽象域(Σ)通过抽象解释((Σ),αe,γe,(Σ))获得,由(Σ)导出的抽象语义函数·Lμ→(Σ)类似于具体语义函数,仅表示的语义域不同.对p∈AP和f∈OP,其解释函数pI(p)∈(Σ),f=∩,∧得f(φ1,…,φn)假定抽象域μ∈uco((Σ))以及具体语义解释,则由抽象域μ导出的最优的近似fμfμf数fμ:Lμ→μ,抽象语义函数·μ可通过具体语义函数最正确近似定义如下:f(φ1,…,φn)μ=fμ(φ1μ,…,φnμ)=假定状态分区ΣP∈Part(Σ),抽象域μP=pcl(ΣP)∈ucoP((Σ))由Galois连接((Σ),αP,γP,μP)获得,其中抽象映射αP:(Σ)→μP使得αP(S){B∈ΣP|B∩S≠},而γP:μP→(Σ)使Page9得γP(X)=∪B∈XB.抽象Kripke结构P=(AP,ΣP,IP,RP),其中RPΣP×ΣP是在抽象状态空间ΣP的抽象转换关系,并且抽象Kripke结构总能导出对应的抽象语义函数·p:Lμ→μP,Lμ公式的抽象语义值是划分ΣP中块的并,即φp={∪B|B∈P且Bφ}.如果划分ΣP对Lμ公式是强保留的,则抽象语义·p与具体语义·定理7.如果ΣP∈Part(Σ)对Lμ是强保留的,那么φ∈Lμ,φ证明.假设μ=pcl(ΣP),令φ∈Lμ,根据抽象语义函数·p的最正确近似,采用结构归纳证明如下:μ((φ定义33.强保留闭包.·定义32.强保留.给定Lμ公式和Kripke结构(1)φ≡p∈AP:φp=μ(p(2)φ≡φ:φp=μ((φp))=(3)φ≡z:zpσ=μ(σ(z))=σ(z)=z(4)φ≡φ∧ψ:φ∧ψp=μ(φp∩ψp)=(5)φ≡φ:φp=μ(pre[R](φp))=(6)φ≡μz.φ(z):μz.φ(z)p=μ(lfp(λZ.μ(φμ(pre[R](φφp∪zp))=μ(lfp(λz.φlfp(λz.φ=(AP,Σ,R,I),假设体语义结构,其中·〈P,·p〉是抽象语义结构,其中抽象Kripke结构P=(AP,ΣP,IP,RP),抽象域μP=pcl(ΣP)∈ucoP((Σ)),·p:Lμ→μP是对应·象语义函数.对任意SΣ和φ∈Lμ,如果Sφ是强保留的.μP∈ucoP((Σ))对Lμ和·相对应状态划分ΣP∈Part(Σ)是对Lμ和·保留[15].具体语义函数,对任意SΣ,Sφ当且仅当s∈S,sφ当且仅当S·包μB:(Σ)→(Σ)定义如下:μB(S){T∈(Σ)|φ∈Lμ,SφTφ}.推论2.μ∈uco((Σ)),那么μ对Lμ是强保留的当且仅当μμB.证明.假设μ对Lμ强保留,对任意S,TΣμ(S)φp,那么·p对Lμ和·当·p对Lμ和·和φ∈Lμ,满足Sφμ(S)φ(或Sφμ(S)φμ),Tφμ(T)φ(或Tφμ(T)φμ).由于SST,根据定义33,则μ(S)μB(S),从而可证μμB;假设μμB,根据定义33,则μ(S)μB(S),因μB是强保留闭包,满足SφμB(S)φμB,从而可证Sφμ(S)φμB,即μ对Lμ强保留.实际上μB是最优的强保留抽象域,即最抽象的强保留闭包或最小的强保留抽象闭包.μB={μ∈uco((Σ))|μ是对Lμ强保留},对应最优的强保留状态划分ΣB=par(μB).根据文献[15]可知如下命题.命题11.让μ∈uco((Σ)),f∈OP是Lμ上的算子,则闭包μ相对于f的最小完备精化OP(μ)就是对Lμ最优的强保留闭包μB,即OP(μ)=μB.为了求解μ相对于f∈OP的最小完备精化,只需满足μ对Lμ上的标准算子集OP={,∧,}是完备的.定理8.假定算子集OP={,∨,},μ∈uco((Σ)),μ是OP-完备的当且仅当μ是{,pre[R]}-完备的.证明.为了证明μ是OP-完备的当且仅当μ是{,pre[R]}-完备的,只需证明μ对OP中算子的完备性可用μ对算子{,pre[R]}的完备性表示.(1):根据语义函数完备当且仅当μμ=μ;(2)∨:μ是-完备的,则μ∈ucop((Σ)),根据命题10,μ是可加的,即S=∪s∈Sμ({s})μ(∪s∈Sμ({s}))=μ(S)=μ(∪s∈S{s}).故μ是∪-完备的;(3):为了证明μ是完备的,则需证明μμ=μ.根据语义函数μμpre[R]μ=pre[R]μ.定理6给出λμ.gfp({,pre[R]})就是μ的可划分且完备的精化闭包,即对{,pre[R]}完备.因此,可得μ的最优可划分且完备精化{,pre[R]}(μ)=gfp(λη.μpre[R](η)(η))),也就是对Lμ最优的强保留闭包.在有限状态系统中,算子λη.μpre[R](η)(η):uco((Σ))→uco((Σ))是平凡的ω连续,其不动点能通过Kleene迭代序列计算.由于状态集Σ是有限的,则其递归定义为μ0μ,μ1μpre[R](μ0)(μ0),对i∈,μi+1μipre[R](μi)(μi),那么存在n∈,使得{,pre[R]}(μ)=μn.命题11和定理8从抽象解释角度描述了对Lμ最优的强保留闭包精化算法,为了能自动构造性质Page10强保留的抽象模型,构造改进算法步骤如下:(1)首先确定初始抽象关系ρ,自动构造μ-演算的安全抽象.按照状态上具有相同标签的状态抽象为一个抽象状态,从而确定抽象关系ρ;(2)然后根据定义24(1),获得初始闭包μ0μρ=p槇re[ρ]post[ρ];(3)依据命题11和定理6,通过迭代序列μi+1μipre[R](μi)(μi),可得μρ的最优可划分且完备精化{,pre[R]}(μρ)=gfp(λη.μρpre[R](η)(η)),从而自动构造对Lμ最优的强保留闭包μB={,pre[R]}(μρ);(4)求解μB={,pre[R]}(μρ)的相应最优抽象划分PB=par(μB)=par({,pre[R]}(μρ));(5)确定抽象状态转换关系,使抽象Kripke结构P=(AP,ΣP,IP,RP)强保留Lμ公式.设B1,B2∈ΣP,B1∈pre[RP]({B2})当且仅当B1pre[R]({B2}),也就是B1pre[R]({B2})当且仅当B1为B1pre[R]({B2})当且仅当B1RP=R,且IP=λX.{B|I(X)∈B},从而可得抽象Kripke结构P是强保留Lμ公式.6实例分析下面将通过两个例子来描述本文的算法.例1.给出一个简单交通控制灯的程序,如图1(a)所示,可获得图1(b)中所示的初始模型Kripke结构=(Σ={1,2,3},R,AP,L),其中状态1表示绿灯,状态2表示黄灯,状态3表示红灯,原子命题集AP={stop,go}.根据状态上相同标签自动确定抽象关系ρ={(1,12),(2,12),(3,3)},可自动抽象获得抽象结构,如图1(c)所示.根据抽象关系ρ获得闭包μρ=p槇re[ρ]post[ρ]={,12,3,123}.由定理6和命题11可知,求解最优的强保留的最优可划分闭包μB只考虑μρ在{,preR}上的最小完备精化.假定μ0=μρ,通过Kleene不动点计算{,pre[R]}(μ0).(1)μ0=μρ={,12,3,123}.(2)(μ0)=μρ.根据定义30知道闭包pre[R](μ0)是可加的,所以可对单一的元素{y}计算pre[R](μ0)({y}),然后相加获得pre[R](μ0).考虑pre[R](μ)({y})={x∈Σ|μ(pre[R]({x}))=μ(pre[R]({y}))},故先对每一元素计算pre[R],得pre[R]({1})=3,pre[R]({2})=1,pre[R]({3})=2.因此有pre[R](μ0)({1})={1},pre[R](μ0)({2})={23},pre[R](μ0)({3})={23},则pre[R](μ0)={,1,23,123}.则μ1=μ0pre[R](μ0)(μ0)={,12,3,123}{,1,23,123}={,1,2,3,12,23,123}.(3)(μ1)={,1,2,3,12,13,23,123}.有pre[R](μ1)({1})={1},pre[R](μ1)({2})={2},pre[R](μ1)({3})={3},则pre[R](μ1)={,1,2,3,12,13,23,123}.则μ2=μ1pre[R](μ1)(μ1)={,1,2,3,12,13,23,123}.(4)同理可得,(μ2)=μ2,pre[R](μ2)=μ2(不动点达到).通过上述计算,μρ的最小完备精化{,pre[R]}(μρ)=μ2={,1,2,3,12,13,23,123}.根据命题11,可得最优的可划分闭包μB={,1,2,3,12,13,23,123}以及PB=par(μB)={1,2,3}.通过上节,使用R求得抽象转换关系,获得一个对Lμ性质强保留的抽象Kripke结构,对于这个简单的例子来说,性质强保留的抽象结构就是自己本身.例2.假设原子命题集AP={p,q},Kripke结构=(Σ={1,2,3,4,5},R,AP,L),如图2(a)所示.根据状态上的标签获得抽象关系ρ={(1,123),(2,123),(3,123),(4,45),(5,45)}自动抽象获得抽象结构,如图2(b)所示.初始闭包μρ={,123,45,12345},假定μ0=μρ,通过Kleene不动点计算{,pre[R]}(μ0).(1)μ0=μρ={,123,45,12345}.(2)(μ0)={,123,45,12345}.Page11pre[R]({1})=,pre[R]({2})=12,pre[R]({3})=12,pre[R]({4})=35,pre[R]({5})=25,有pre[R](μ0)({1})={1},pre[R](μ0)({2})={23},pre[R](μ0)({3})={23},pre[R](μ0)({4})={45},pre[R](μ0)({5})={45},则pre[R](μ0)={,1,23,45,123,145,2345,12345}.可得μ1=μ0pre[R](μ0)(μ0)={,1,23,45,123,145,2345,12345}.(3)(μ1)={,1,23,45,123,145,2345,12345}.有pre[R](μ1)({1})={1},pre[R](μ1)({2})={23},pre[R](μ1)({3})={23},pre[R](μ1)({4})={45},pre[R](μ1)({5})={45},则pre[R](μ1)={,1,23,45,123,145,2345,12345}.可得μ2=μ1pre[R](μ1)(μ1)={,1,23,45,123,145,2345,12345}=μ1(不动点达到).通过上述计算,μρ的最小完备精化{,pre[R]}(μ0)=μ1={,1,23,45,123,145,2345,12345},则最优的抽象划分PB=par(μB)=par(μ2)={1,23,45}.通过上节,使用R求得抽象转换关系,获得一个对Lμ性质强保留的抽象Kripke结构,如图2(c)所示.上述两个例子相对比较简单,主要是为了说明性质强保留抽象模型如何自动构造.从例1可以看出,当验证性质为:总是最终能达到state==stop,通过模型检验弱保留抽象所得的抽象模型,如图1(b)所示,存在一条无限抽象路径〈stop,go,go,…〉不满足此性质,然而此路径是不合理的,产生的原因就是抽象对于算子{,pre[R]}不是完备的,即不是Lμ性质强保留的,故需要对抽象模型精化,精化后将得Lμ性质强保留的抽象结构.而当验证性质为:总是最终能达到state==go,则弱保留抽象所得的抽象模型将不会产生不合理反例,也可认为图1(b)所示的抽象模型对所验证的性质是强保留的.这启发了下一步工作将主要研究依赖所验证时序公式的强保留抽象,而不是依赖Lμ公式的强保留抽象,进一步缩减抽象状态空间.7相关工作典型的抽象模型检验是基于状态划分和抽象Kripke结构的,给定具体状态转换系统或Kripke结构,通过抽象映射获得抽象模型.而在抽象解释框架[16]下,则依据具体状态幂集的抽象解释(Galois连接或闭包操作)导出近似于具体语义的抽象语义.抽象方式主要有两种:弱保留抽象和强保留抽象.性质弱保留抽象保证时序性质若在抽象模型满足则其也在具体模型满足,通常分为向下近似抽象和向上近似抽象.而性质强保留抽象保证时序性质在抽象模型满足当且仅当其在具体模型满足.性质强保留是高期望的,且获得最优的强保留抽象模型是困难的.近几年来,已有许多研究人员对抽象模型检验进行了研究,并在许多方面做了改进[2-6,9-26].当前已有一些成功的抽象技术应用于软件系统的模型检验,例如Clarke[27-28]采用向上近似抽象方式,基于不合理反例引导精化抽象(CounterExample-GuidedAbstractionRefinement,CEGAR)的思想进行抽象模型检验,还有诸如验证Java程序的Bandera[29]和JavaPathFinder[30],验证C语言的SLAM[31-32],MAGIC[33-34]和BLAST[25-26].上述方法都属于弱保留抽象,采用抽象解释的特殊形式———谓词抽象,通过反例引导精化抽象模型验证程序的安全性.此方法的缺点在于抽象谓词选取和抽象关系确定比较困难,而抽象谓词的不适当选取可能导致抽象模型多次精化.Giacobazzi和Ranzato[35]在2010年提出利用基于抽象解释框架下的路径引导抽象简化(Example-GuidedAbstractionSimplification,EGAS)的思想消除抽象模型中的冗余数据,达到精化抽象域的目的,该方法可集成在CEGAR算法中.抽象解释框架[16]使用Galois连接(或闭包操作)在具体性质域和抽象性质域之间建立联系,且证明对任意具体性质,存在唯一的最优抽象近似.虽然强保留和完备抽象解释是不相关的,但Giacobazzi[5,12]首先给出了性质强保留和完备抽象解释之间的关系,并指出如果抽象缺乏完备性,则产生不合理反Page12例.为了消除不合理反例,可通过最小精化使抽象解释完备.Giacobazzi[5]的研究表明抽象解释的完备性不依赖抽象语义算子,而仅仅依赖于抽象域,故抽象解释的最小完备化可转化为抽象域最小完备精化.Ranzato和Tapparo[10,14,22-23]在完备抽象解释和强保留抽象模型之间建立了精确的一致性原则,并指出抽象域的完备精化总是存在的,并可用不动点对其性质进行刻画.2007年Ranzato[36]在文献[15]基础上给出了一个扩展版本.Qian和Xu[13]基于完备抽象解释的理论,通过抽象域的最小完备精化,构造了一个抽象状态划分且强保留CTL性质的抽象模型.本文主要目的是自动构造μ-演算性质强保留且完备的抽象模型,避免抽象缺乏完备性而产生不合理反例,从而消除反复精化的时间开销.其次运用一些已有的结论,根据完备抽象解释和强保留抽象模型之间的关系,在文献[15,36]的基础上,针对μ-演算公式,提出抽象域仅对{,pre[R]}两个操作算子完备即可获得强保留抽象,并给出求解最优的完备精化闭包算法,从而获得Lμ性质强保留的最优抽象模型.8结论抽象模型检验是一种实用且成功解决状态空间爆炸问题的验证方法[37].典型的抽象模型检验是通过合并一些无法用时序语言区分的状态,获得近似具体模型的抽象Kripke结构.本文基于抽象解释的理论,首先系统地构造Lμ模型的安全抽象,并应用于Kripke结构=(AP,Σ,I,R).然后基于完备抽象解释和性质强保留之间的联系,让Σ的幂集(Σ)表示具体语义域,通过Galois连接或闭包操作获得抽象域,并使抽象域最小完备精化,从而构造出性质强保留且可划分的抽象闭包.并依据此抽象域求得Lμ性质强保留的最优抽象状态划分,最后获得抽象状态转换系统.通过例1,启发我们下一步工作将主要研究依赖所验证公式的强保留抽象模型检验,而不是依赖验证的时序语言,达到缩减抽象状态空间的目的,并进一步研究通过所依赖所验证公式获得的强保留抽象模型与CEGAR精化算法所得的抽象模型之间的关系.
