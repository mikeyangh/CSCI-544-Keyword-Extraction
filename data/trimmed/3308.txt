Page1抗适应性选择身份攻击的匿名HIBE方案王皓徐秋亮(山东大学计算机科学与技术学院济南250101)摘要构造了一个新的匿名基于身份加密(IBE)方案,并将其扩展为一个匿名分等级基于身份加密(HIBE)方案.新方案的构造中使用了合数阶双线性群,利用相同子群中的元素对公共参数和密文进行盲化,从而实现方案的匿名性;利用不同子群中的元素构造用户私钥,从而达到正确解密的目的.其安全性证明使用了Lewko和Waters提出的构造双系统加密的新技术.新的匿名HIBE方案具有较短的密文,并且能够在标准模型下达到抗适应性选择身份攻击安全,而此前的匿名HIBE方案仅能达到抗选定身份攻击安全.关键词匿名分等级基于身份加密;抗适应性选择身份攻击;短密文;无随机预言机;合数阶双线性群1引言IBE)系统[1]是一种特殊的公钥加密系统,加密者仅需要使用接收者的身份信息和一系列全局公共参数即可完成加密,而不再需要使用接收者的公钥,从而基于身份的加密(Identity-BasedEncryption,避免了管理公钥证书带来的开销.在该系统中,密钥Page2生成中心(KeyGenerationCenter,KGC)持有主密钥,用来为已认证用户颁发其身份对应的私钥.然而,当系统中用户数量较多时,KGC对用户密钥管理花费的开销是非常昂贵的.为了解决这一问题,同时为了给具有等级结构的组织提供一种更为实用的加密系统,Horwitz和Lynn在EUROCRYPT2002上提出了分等级基于身份加密[2](HierarchicalIBE,HIBE)的概念.在HIBE中,一个处于较高等级的用户,可以使用自己的私钥为处于较低等级的子孙用户生成私钥,因此,密钥生成中心只需管理第1等级上用户的私钥,而更低等级用户的私钥可由其祖先节点上的用户(包括KGC)进行管理.IBE与HIBE自提出以来一直受到广泛的关注,相关研究涉及到密码学与网络安全的许多领域,利用(H)IBE为基础构造的大量应用被相继提出.其中一个重要的应用是“有关键字搜索的公钥加密”[3](Public-keyEncryptionwithKeywordSearch,PEKS),该加密机制能够在保护数据机密性的同时保持对数据的可搜索性.Abdalla等人在CRYPTO2005上提出了匿名IBE以及匿名HIBE的概念[4],并给出了一个从匿名IBE到PEKS的转换技术.在一个匿名IBE方案中,密文不会暴露接收者的身份信息,而这一性质正可以用来构造PEKS系统,从而保持关键字的“匿名性”.在匿名HIBE方案中,分等级的身份能够在提供密钥可委托性的同时保持密文的匿名性.利用匿名HIBE可以构造许多新的应用,例如,有临时关键字搜索的公钥加密,有关键字搜索的基于身份加密等.第一个匿名HIBE方案是由Boyen和Waters在文献[5]中给出的,该方案中公共参数及用户私钥的长度为O(l2),密文长度为O(l),其中l表示方案中等级的最大深度.随后,Shi和Waters在文献[6]中给出了一个匿名HIBE方案的一般化构造,称为可委托隐藏向量加密(delegatableHidden-VectorEncryption,dHVE),在该方案中,公共参数、用户私钥以及密文的长度均为O(l).由于Boyen及Shi的方案中各类效率参数均与l有关,因此,它们并不适用于等级深度较大的系统.第一个具有短密文的匿名HIBE方案是由Seo等人[7]在PKC2009上提出的,其密文由4个群元素组成,与系统中等级的最大深度无关,这在很大程度上提高了匿名HIBE方案的实用性.然而Seo的方案及以上两个方案都是在较弱的选定身份模型[8](selective-IDmodel)中证明安全性的.在该模型中,敌手必须在系统建立之前,公布其将要用于挑战的身份,因此,该模型不能恰当地刻画真实环境中敌手的行为,在该模型中被证明安全的方案,仅能称为抗选定身份攻击安全的(selective-IDsecure).因此,在标准模型中,构造具有短密文的匿名HIBE方案,并使其达到抗适应性选择身份攻击安全(fulladaptive-IDsecure)是本文的目的.本文中,我们首先构造了一个匿名IBE方案,然后对其进行了扩展,给出了一个具有短密文的匿名HIBE方案.这两个方案都可以在标准模型中,被证明达到匿名、抗适应性选择身份和选择明文攻击安全(ANON-ID-CPA).新方案使用了合数阶双线性群[9]实现密文的匿名性,同时使用了双系统加密技术[10-11]证明方案的安全性.第2节给出匿名HIBE方案及其安全性的形式化定义,介绍有关合数阶双线性群的背景知识,并给出用于安全性证明中的6个静态假设;第3节给出一个匿名IBE方案,并证明其相应的安全性;第4节是本文的重点,在第3节的基础上,对匿名IBE方案进行扩展,给出一个匿名HIBE方案,并证明其相应的安全性;第5节将本文提出的匿名HIBE方案与已有的方案在效率及安全性上进行全面对比,并给出全文的总结.2背景及相关定义2.1符号说明本文中,Z表示整数环,Z0表示非负整数集,对于正整数k,Zk表示模为k的整数环.当a表示某一特定的值,ν表示一个变量时,符号ν←a表示将a的值赋予变量ν.当X表示某个集合或某个代数结构时,符号x←X表示在集合X(或代数结构X)中随机选取元素x,并且我们用x1,…,xk←X表示x1←X,…,xk←X.此外需要特殊说明,在本文中,当多个属于相同代数结构的元素使用同一个字母表示时,如果该元素属于Zk,则用带有中括号的符号表示,例如a[i],如果该元素属于其它代数结构,则用带有下脚标的符号表示,例如gi,其中i为该元素的标签.当A表示某个算法时,符号A(a1,…,am)→b1,…,bn,表示算法A以a1,…,am为输入,输出b1,…,bn.2.2HIBE方案一个HIBE方案由5个算法构成:建立(Setup)、密钥提取(KeyGen)、密钥委托(Delegate)、加密Page3(Encrypt)、解密(Decrypt).Setup(λ,l)→PK,MSK.建立算法以安全参数λ、等级的最大深度l为输入,输出为公共参数PK和主密钥MSK.KeyGen(PK,MSK,犐)→SK犐.密钥提取算法以公共参数PK、主密钥MSK和一个身份向量犐为输入,输出该身份向量对应的私钥SK犐.Delegate(PK,SK犐,I)→SK犐:I:密钥委托算法以公共参数PK、深度为d的身份向量犐对应的私钥SK犐和一个身份元素I为输入,输出深度为d+1的身份向量犐:I对应的私钥SK犐:I,其中犐:I表示在d维向量犐的末端增加一个元素I,使其成为d+1维向量.Encrypt(PK,M,犐)→CT.加密算法以公共参数PK、明文消息M以及接收者的身份向量犐为输入,输出密文CT.Decrypt(PK,CT,SK犐)→M.解密算法以公共参数PK、密文CT、私钥SK犐为输入,输出明文M,当且仅当加密时使用的身份向量与私钥对应的身份向量相同.解密算法要求密文和私钥对应的身份向量相同.如果解密者持有的私钥所对应的身份向量是密文对应的身份向量的前缀,那么他可以调用密钥委托算法生成解密所需的私钥.2.3匿名HIBE的安全性定义本小节给出匿名HIBE的安全性定义,与文献[6]中类似,需要记录密钥的生成和委托的过程.首先,定义一个挑战者与敌手之间进行的游戏.建立.挑战者运行建立算法,将公共参数PK给敌手.挑战者同时初始化一个集合S=,用来记录已经被创建但尚未泄露的私钥.阶段1.敌手可以重复进行如下3类查询:创建.敌手发送给挑战者一个身份向量犐.挑战者创建该向量对应的私钥,但并不直接返回给敌手,而是将它添加到集合S中,将集合S的索引返回给敌手.委托.敌手指定集合S中的某个私钥SK犐,并给挑战者一个身份元素I.挑战者运行密钥委托算法Delegate(PK,SK犐,I),生成新的私钥SK犐:I,并将其添加到集合S中,将更新后的索引返回给敌手.泄露.敌手指定集合S中的某个元素SK,挑战者将其从集合S中删除,并将它返回给敌手.在对密钥进行泄露查询后,将不再需要对该私钥进行委托查询,因为敌手可以自己运行密钥委托算法.挑战.敌手提交两个长度相等的消息M0和M1,两个身份向量犐0和犐1,要求在阶段1中查询的每个私钥对应的身份向量犐不能是犐0或犐1的前缀.挑战者进行随机投币,得到两个随机比特β,γ(β,γ∈{0,1}),然后使用身份向量犐γ对消息M密,并将得到的密文CT返回给敌手.阶段2.重复阶段1中的各类查询,要求每个被查询的私钥对应的身份向量犐不能是犐0或犐1的前缀.猜测.敌手输出对(β,γ)的猜测(β,γ).在这个游戏中,敌手的优势定义为定义1.一个HIBE方案是匿名性的、抵抗适应性选择身份和选择明文攻击安全的(ANON-ID-CPA),当且仅当任何多项式时间的敌手在上面游戏中的优势都是可忽略的.我们省略了IBE方案及其安全性的形式化定义,因为IBE方案是一种特殊的HIBE方案,其等级的最大深度l=1.此外,IBE方案中没有密钥委托算法,相应的安全性定义中没有委托查询,因此我们可以认为,当敌手对某个身份I进行查询时,挑战者直接将该身份对应的私钥返回给敌手,而无需在S中保存.2.4合数阶双线性群合数阶双线性群是在文献[9]中被提出的,本文利用一个群发生器(可视为一个群生成算法)对其定义.该算法以安全参数λ为输入,输出一个对双线性群G的描述.本文中,的输出为一个四元组(N=p[1]·p[2]·p[3]·p[4],G,GT,e),其中p[1],p[2],p[3],p[4]分别是4个安全素数,G和GT为两个N阶循环群,并且有双线性映射e:G×G→GT,满足(1)双线性性.对于任意的g,h∈G,a,b∈ZN,有e(ga,hb)=e(g,h)ab;(2)非退化性.存在g∈G,使得e(g,g)在GT的阶为N.我们进一步要求在群G和GT中的运算以及双线性映射e都是多项式时间可计算的.同时,假设对群G和GT的描述中包含了二者的生成元.令Gp[1],Gp[2],Gp[3],Gp[4]分别表示群G的p[1],p[2],p[3],p[4]阶子群.当hi∈Gp[i],hj∈Gp[j],且i≠j时,e(hi,hj)是GT中的单位元.例如,h1∈Gp[1],h2∈Gp[2],g表示群G的生成元.由于gp[2]·p[3]·p[4]为子群Gp[1]的生成元,gp[1]·p[3]·p[4]为子群Gp[2]的生成Page4元,因此一定存在α和β,使得h1=(gp[2]·p[3]·p[4])α,h2=(gp[1]·p[3]·p[4])β,从而得到e(h1,h2)=e(gp[2]·p[3]·p[4]·α,gp[1]·p[3]·p[4]·β)这种性质,称为子群Gp[1],Gp[2],Gp[3],Gp[4]的正交性,是本文中构造方案的一个重要工具.2.5复杂性假设本小节给出文中用到的复杂性假设,这些假设将用于证明文中方案的安全性.它们全部为静态假设(不依赖于方案中等级的深度以及安全游戏中敌手能够进行查询的次数),并且当群的阶(大整数)难以分解时,在一般群模型中是成立的.这些假设均可以通过Katz等人在文献[12]中提出的理论进行证明.他们的工作同样用到了合数阶双线性群并且提供了一种通用框架用以证明这类假设的安全性.在下面的假设中,我们用Gp[1]p[2]等表示G中p[1]·p[2]阶子群.假设1.给定一个群发生器,我们定义如下分布:(λ)→犌=(N=p[1]·p[2]·p[3]·p[4],G,GT,e),Adv1,(λ)T1←Gp[i]p[2],T2←Gp[i],i∈{1,3,4}.我们定义敌手打破假设1的优势为|Pr[(犇,T1)=1]-Pr[(犇,T2)]=1|.如果对于任意多项式时间的敌手,Adv1,(λ)都是可忽略的,我们就说群发生器满足假设1,即假设1成立.假设2.给定一个群发生器,我们定义如下分布:(λ)→犌=(N=p[1]·p[2]·p[3]·p[4],G,GT,e),我们定义敌手打破假设2的优势为Adv2,(λ)|Pr[(犇,T1)=1]-Pr[(犇,T2)]=1|.如果对于任意多项式时间的敌手,Adv2,(λ)都是可忽略的,我们就说群发生器满足假设2,即假设2成立.假设3.给定一个群发生器,我们定义如下分布:(λ)→犌=(N=p[1]·p[2]·p[3]·p[4],G,GT,e),我们定义敌手打破假设3的优势为Adv3,(λ)|Pr[(犇,T1)=1]-Pr[(犇,T2)]=1|.如果对于任意多项式时间的敌手,Adv3,(λ)都是可忽略的,我们就说群发生器满足假设3,即假设3成立.假设4.给定一个群发生器,我们定义如下分布:(λ)→犌=(N=p[1]·p[2]·p[3]·p[4],G,GT,e),X1←Gp[1],X2,Y2,Z2←Gp[2],X3←Gp[3],犇=(犌,X1,Z2,X3,X4,Xα我们定义敌手打破假设4的优势为Adv4,(λ)|Pr[(犇,T1)=1]-Pr[(犇,T2)]=1|.如果对于任意多项式时间的敌手,Adv4,(λ)都是可忽略的,我们就说群发生器满足假设4,即假设4成立.假设5.给定一个群发生器,我们定义如下分布:(λ)→犌=(N=p[1]·p[2]·p[3]·p[4],G,GT,e),X1←Gp[1],X2,Y2,Z2←Gp[2],X3←Gp[3],犇=(犌,Z2,X3,X4,X1X2,Xα我们定义敌手打破假设5的优势为Adv5,(λ)|Pr[(犇,T1)=1]-Pr[(犇,T2)]=1|.如果对于任意多项式时间的敌手,Adv5,(λ)都是可忽略的,我们就说群发生器满足假设5,即假设5成立.假设6.给定一个群发生器,我们定义如下分布:(λ)→犌=(N=p[1]·p[2]·p[3]·p[4],G,GT,e),X1,Y1←Gp[1],X2←Gp[2],X3←Gp[3],犇=(犌,X1,X3,X4,Xκ我们定义敌手打破假设6的优势为Page5Adv6,(λ)|Pr[(犇,T1)=1]-Pr[(犇,T2)]=1|.如果对于任意多项式时间的敌手,Adv6,(λ)都是可忽略的,我们就说群发生器满足假设6,即假设6成立.3匿名IBE方案本节将给出一个新的匿名IBE方案,其安全性证明使用了双系统加密技术.该方案构造中使用了合数阶双线性群,阶为N=p[1]·p[2]·p[3]·p[4],其中p[1],p[2],p[3],p[4]分别为4个安全素数,并且方案中的“身份”是在ZN中定义的.该方案在结构上与LW-IBE[11]非常相似,但是在公共参数以及密文中添加了子群Gp[4]中的随机元素,从而实现了密文的匿名性,这一思想是受到Seo的匿名HIBE[7]的启发.与LW-IBE类似,子群Gp[2]不出现在实际方案中,它仅用于构造半功能的(semi-functional)密钥和密文,当密钥和密文中包含Gp[2]中的分量时称为半功能的.本方案中,解密将通过密钥元素与密文元素的对运算(pairing)进行,这种解密方式将提供一个重要功能:当一个正规(normal)密钥解密一个半功能密文时或者一个正规密文被一个半功能密钥解密时,由于Gp[2]中的分量在对运算下正交于Gp[1],Gp[3],Gp[4]中的分量,因此解密得以正常进行.当对运算在半功能密钥和半功能密文间进行时,会有一个额外的扰动分量(Gp[2]中的分量)出现在盲化因子中,因此解密无法正常进行.3.1匿名IBE方案Setup(λ,l=1).建立算法选择一个双线性循环群G,阶为N=p[1]·p[2]·p[3]·p[4],其中p[1],p[2],p[3],p[4]分别是4个安全素数.令Gp[i]表示G中的p[i]阶子群,gp[i]表示子群Gp[i]的生成元,g表示群G的生成元.它随后随机选取u,v,w←Gp[1],Ru,Rv,Rw←Gp[4],α←ZN,并计算U=u·Ru,V=v·Rv,W=w·Rw,E=e(v,v)α.公布公共参数:PK={N,gp[3],gp[4],U,V,W,E}.保存主密钥:MSK={u,v,w,α}.KeyGen(PK,MSK,I).密钥提取算法随机选择r←ZN,R3,R3←Gp[3],构造身份I对应的密钥:SK犐={K1,K2},其中K1=vrR3,K2=vα(uIw)rR3.Encrypt(PK,M,I):加密算法随机选择s←ZN,R4,R4←Gp[4],并计算密文:CT={C0,C1,C2},其中C0=M·Es,C1=(UIW)s·R4,C2=Vs·R4.Decrypt(PK,CT,SKi).解密算法计算盲化因子:Es=e(K2,C2)/e(K1,C1),从而解密消息:M=C0/Es.3.2匿名IBE方案的安全性证明为了证明本匿名IBE方案的安全性,我们使用了文献[11]中介绍的构造双系统加密的新技术,定义了两个额外的结构:半功能密文和半功能密钥.它们并不出现在实际的方案中,仅用于方案的安全性证明.半功能密文.令gp[2]表示子群Gp[2]的生成元,我们通过如下步骤得到一组半功能密文:首先,调用加密算法得到一组正规的密文C0,C1,C2;然后,随机选取x,z[c]←ZN,并将C0设置为C0,C1设置为p[2],C2设置为C2gxC1gx·z[c]半功能密钥.我们通过如下步骤得到一组半功能密钥:首先,调用密钥提取算法得到一组正规的密钥K1,K2;然后,随机选取y,z[k]←ZN,并将K1设置为K1gy如果一个半功能密钥用于解密一个半功能密文,那么盲化因子中将出现一个额外的扰动分量e(gp[2],gp[2])x·y·(z[k]-z[c]).但当z[c]=z[k]时,解密仍然能够正常进行.在这种情况下,我们称该密钥是象征性(nominally)半功能的:它含有Gp[2]中的分量,但是仍能成功解密半功能密文.方案的安全性证明依赖于2.5节中给出的假设1~5.我们使用了混合争论(hybridargument)技术,借助一系列两两不可区分的游戏(GameReal,GameRestricted,Game0,…,Gameq,GamePre-Final,GameFinal)证明方案的安全性.第1个游戏,GameReal,是真实的游戏,即第2.3节匿名(H)IBE的安全性定义中所描述的游戏.第2个游戏,GameRestricted,与GameReal仅有一处区别,敌手不能对那些与用于挑战的身份(ZN中的元素)modp[2]相等的身份进行私钥查询.这是一个比真实游戏中更强的限制,真实游戏仅要求用于挑战的身份与被查询的身份modN不等.后面定义的一系列游戏都保持这个较强的限制.进行这个限制的原因,我们将在引理3的证明中说明.下一个游戏,Game0,与GameRestricted仅存在一处区别,在Game0中挑战阶段返回给敌手的密文是半功能的.令q表示在阶段1和阶段2中敌手能够进行私钥查询的最大次数.下面我们定义q个游戏,{Gamek}k∈[1,q],与Game0仅存在一处区别,在Gamek中返回给敌手的前k个私钥为半功能的,其Page6它的私钥仍为正规的.也就是说,在Game0中,返回的密文是半功能的,而返回的所有密钥都是正规的;在Gameq中,返回的密文以及所有的密钥都是半功能的.倒数第2个游戏,GamePre-Final,与Gameq仅存在一处区别,在GamePre-Final中,返回给敌手的是对一个随机消息加密得到的半功能密文.最后一个游戏,GameFinal,与GamePre-Final仅存在一处区别,在GameFinal中,返回给敌手的半功能密文是使用一个随机身份对一个随机消息进行加密所得的.我们利用下面的5个引理证明以上游戏是两两不可区分的.引理1.假设存在算法(敌手)使得GameRealAdv-GameRestrictedAdv=ε,那么我们可以构造算法以大于等于ε/3的优势打破假设1.证明.算法利用X1,X3,X4作为输入,能够模拟GameReal.若能够以概率ε生成身份I和用于挑战的身份I[γ](γ∈{0,1}),使得I≠I[γ]modN,同时p[2]整除I-I[γ],则可以利用这两个身份,计算a=gcd(I-I[γ],N),从而得到一个N的非平凡因子.令b=N/a.由于p[2]整除a,同时N=ab=p[1]·p[2]·p[3]·p[4],因此可能存在3种情况:p[1]整除b;p[3]整除b;p[4]整除b.至少有一种情况发生的概率大于等于ε/3.在每种情况中,都能用下面的方式打破假设1:给定X1,X3,X4,T,能够通过验证Xb确定p[i](i∈{1,3,4})是否整除b,进而验证Tb是否为单位元.如果是单位元,则T∈Gp[i],否则T1∈Gp[i]p[2].引理2.假设存在算法(敌手)使得4,Ru=Ra那么我们可以构造算法以ε的优势打破假设2.证明.利用X1,X3,X4,T作为输入,模拟GameRestricted或Game0.它设置公共参数如下:随机选取a,b,α,δ←ZN,并设置v=X1,u=va,w=vb,Rv=XδU=u·Ru,V=v·Rv,W=w·Rw,E=e(v,v)α}返回给.每当被查询身份I[i]对应的私钥时,它随机选取r[i],s[i],t[i]←ZN,并返回K1=vr[i]Xt[i]K2=vα(uI[i]w)r[i]Xs[i]给发送两个消息,M0,M1,和两个身份I[0],I[1].选择两个随机比特β,γ(β,γ∈{0,1}),产生密文如下:C0=M如果T∈Gp[1]p[2]p[4],那么这是一个半功能密文,其中z[c]=aI[γ]+b.由于z[c]modp[2]是一个与amodp[1]及bmodp[1]无关的值,因此它的分布是恰当的.如果T∈Gp[1]p[4],那么这是一个正规的密文.因此,可以用的输出来区分T的不同可能.引理3.假设存在算法(敌手)使得那么我们可以构造算法以ε的优势打破假设3.证明.利用X1,X3,X4,Y1X2Y4,Y2Y3,T作为输入,模拟Gamek-1或Gamek.它随机选取a,b,α,δ←ZN,并设置v=X1,u=va,w=vb,Rv=Xδv,Rw=RbRav·Rv,W=w·Rw,E=e(v,v)α}发送给.当进行第i次私钥查询时(针对身份I[i]):对于i<k的情况,生成一组半功能密钥.它随机选取r[i],s[i],t[i]←ZN,并返回:K1=vr[i](Y2Y3)t[i],K2=vα(uI[i]w)r[i](Y2Y3)s[i].对于i>k的情况,生成一组正规的密钥.它随机选取r[i],s[i],t[i]←ZN,并返回:K1=3,K2=vα(uI[i]w)r[i]Xs[i]vr[i]Xt[i]对于i=k的情况,设置z[k]=aI[k]+b,随机选取s[k]←ZN,并返回:K1=T,K2=vαTz[k]Xs[k]发送给两个消息M0,M1和两个身份I[0],I[1].随机选取β,γ←{0,1}.构造密文如下:C0=MC2=Y1X2Y4.令vs=Y1,RsS4是子群Gp[4]中的随机元素.因为f(I[γ])=aI[γ]+bmodp[2]是一个两两无关的函数,因此对于I[k]≠I[γ]modp[2],可将z[k]和z[c]看作是随机分布的(amodp[2]以及bmodp[2]与它们modp[1]的值是不相关的).如果I[k]≡I[γ],的查询不合法,这正是我们对模数做额外限制的原因.虽然z[k]和z[c]之间的关系对是隐藏的,但是这种关系对我们的证明是至关重要的:如果试图通过“自己生成一个用I[k]加密的半功能密文并尝试解密”这种方法来测试SKI[k]是否为半功能的,那么无论SKI[k]是否为半功能的,解密都能正常工作,因为z[k]=z[c].换言之,模拟器仅能生成一个象征性(nominally)半功能密钥.Page7如果T∈Gp[1]p[3],那么正确地模拟了Gamek-1.如果T∈Gp[1]p[2]p[3],那么正确地模拟了Gamek.因此,能够利用来区分T的不同可能.引理4.假设存在算法(敌手)使得那么我们可以构造算法以ε的优势打破假设4.证明.利用X1,Z2,X3,X4,XαT作为输入,模拟Gameq或GamePre-Final.随机选择a,b,δ←ZN,并设置v=X1,u=va,w=vb,Rv=4,Ru=RaXδ{X3,X4,U=u·Ru,V=v·Rv,W=w·Rw,E=e(vαX2,v)}.当查询身份I[i]的密钥时,生成对应的半功能密钥.它随机选取r[i],s[i],t[i],x[i],y[i]←ZN,并返回:K1=vr[i]Zx[i]vα(uI[i]w)r[i]Zy[i]给两个消息M0,M1,和两个身份I[0],I[1].随机选取β,γ←{0,1},并返回密文:C0=β·T,C1=(XsM令z[c]=aI[γ]+b,RsGp[4]中的随机元素.在这里,z[c]仅与其modp[2]的值有关,由于u=va,w=vb是Gp[1]中元素,所以当a和b是在ZN中选取时,amodp[1]以及bmodp[1]与z[c]=aI[γ]+bmodp[2]是无关的.如果T=e(X1,X1)α·s,那么以上密文是消息β对应的半功能密文.如果T为GT中的随机元M素,那么该密文是对一个随机消息加密得到的半功能密文.因此,可以用的输出来区分T的不同可能.引理5.假设存在算法(敌手)使得GamePre-FinalAdv-GameFinalAdv=ε,证明.利用Z2,X3,X4,X1X2,Xα那么我们可以构造算法以ε的优势打破假设5.1Z2Z4,GT,T作为输入,模拟GamePre-Final或XsGameFinal.随机选取a,b←ZN,并设置V=X1XδU=Va,W=Vb.它将公共参数{X3,X4,U,V,W,E=e(Xα的密钥时,生成对应的半功能密钥.它随机选取r[i],s[i],t[i],x[i],y[i]←ZN,并返回:K1=(X1X2)r[i]Zx[i]K2=Xα发送给两个消息M0,M1,和两个身份I[0],I[1].随机选取CR←GT,γ←{0,1},并返回密文:C0=CR,C1=(T)aI[γ]+b,C2=Xs令z[c]=aI[γ]+b,Rs群Gp[4]中的随机元素.如果T=Xs密文是一个使用身份I[γ]对一个随机消息加密的半功能密文.如果T是Gp[1]p[2]p[4]中的随机元素,那么该密文是一个使用随机身份对一个随机消息加密的半功能密文.因此,可以利用的输出来区分T的不同可能.IBE方案是ANON-ID-CPA的(定义1).至此,我们得到如下定理.定理1.如果假设1~5成立,那么我的匿名证明.根据以上5个引理得知,如果假设1~5成立,那么真实游戏GameReal与GameFinal是不可区分的.又因GameFinal中β与γ对敌手是完全隐藏的(信息论意义上的),所以敌手在GameFinal中的优势为0,从而得知在GameReal中敌手的优势是可忽略的.4匿名HIBE方案我们在第3节提出的匿名IBE方案的基础上进行扩展,给出一个具有短密文的匿名HIBE方案.新方案仍然是在合数阶双线性群中构造的,群的阶为N=p[1]·p[2]·p[3]·p[4].与匿名IBE方案类似,本匿名HIBE方案使用了子群Gp[4]中的元素对公共参数和密文进行了盲化处理,并且将子群Gp[2]用于方案的安全性证明.4.1匿名HIBE方案Setup(λ,l).建立算法选择一个双线性循环群G,阶为N=p[1]·p[2]·p[3]·p[4],其中p[1],p[2],p[3],p[4]分别是4个安全素数.令l表示HIBE方案中等级深度的最大值,Gp[i]表示G中的p[i]阶子群,gp[i]表示子群Gp[i]的生成元,g表示群G的生成元.它随后随机选取u1,…,ul,v,w,f←Gp[1],Ru,1,…,Ru,l,Rv,Rw,Rf←Gp[4],α←ZN,并计算U1=u1·Ru,1,…,Ul=ul·Ru,l,V=v·Rv,W=w·Rw,F=f·Rf,E=e(v,v)α.公布公共参数:PK={N,gp[3],gp[4],U1,…,Ul,V,W,F,E}.保存主密钥:MSK={u1,…,ul,v,w,f,α}.KeyGen(PK,MSK,犐=(I[1],…,I[j])).密钥提取算法随机选择r[1],r[2],s[1],s[2],t[1],t[2]←ZN,P3,0,P3,1,P3,2,Q3,j+1,…,Q3,l←Gp[3],构造身份犐对应的密钥:SK犐={Kd,Kr},其中,Page8Kd=[vr[1]P3,0,vr[2]P3,1,vα(uI[1]j+1Q3,j+1,…,ur[1]ur[1]Kr=[[vs[1],vs[2],(uI[1][vt[1],vt[2],(uI[1]Delegate(PK,SK犐,I[j+1]):密钥委托算法以身份向量犐=(I[1],…,I[j])对应的私钥SK犐={[a0,0,a0,1,a0,2,b0,j+1,…,b0,l],[a1,0,a1,1,a1,2,b1,j+1,…,b1,l],[a2,0,a2,1,a2,2,b2,j+1,…,b2,l]}为输入,生成犐=(I[1],…,I[j],I[j+1])对应的私钥SK犐.它随机选择γ[1],γ[2],γ[3],δ[1],δ[2],δ[3]←ZN,R3,0,R3,1,R3,2,S3,j+2,…,S3,l←Gp[3].新的密钥产生如下:1.密钥委托过程:Kd←[α0,0αγ[1]β0,j+2βγ[1]Kr←[[αγ[2][αγ[3]SK犐={Kd,Kr}.2.重随机过程:I[j],I[j+1]).SK犐是完全随机的,它仅依赖于身份向量犐=(I[1],…,Encrypt(PK,M,犐=(I[1],…,I[j])).加密算法随机选取s←ZN,R4,1,R4,2,R4,3←Gp[4],并计算密文:CT={C0,C1,C2,C3},其中C0=M·Es,C1=(UI[1]Fs·R4,3.Decrypt(PK,CT,SK犐).假设解密算法的输入中,密钥Kd=[a0,0,a0,1,a0,2,b0,j+1,…,b0,l]和密文CT={C0,C1,C2,C3}对应着相同的身份向量犐=(I[1],…,I[j]).如果密钥对应的身份向量为犐的前缀,那么解密算法首先调用密钥委托算法产生犐对应的私钥,然后计算盲化因子:Es=e(a0,2,C2)/[e(a0,0,C1)·e(a0,1,C3)],从而解密消息M=C0/Es.4.2匿名HIBE方案的安全性证明方案的安全性证明依赖于假设1~6.我们首先定义3个额外的结构:半功能密文、半功能密钥以及仿制的(dummy)半功能密钥.它们并不出现在实际方案中,仅用于方案的安全性证明中.半功能密文.令gp[2]表示子群Gp[2]的生成元,通过如下步骤得到一组半功能密文:首先,调用加密算法得到一组正规的密文C0,C1,C2,C3;然后,随机选取x[0],x[1],z[c]←ZN,并设置:C0=C0,C1=C1gx[0]·z[c]p[2],C2=C2gx[0]半功能密钥.通过如下步骤得到一组半功能密钥:首先,调用密钥提取算法得到一组正规的密钥SK={[a0,0,a0,1,a0,2,b0,j+1,…,b0,l],[a1,0,a1,1,a1,2,b1,j+1,…,b1,l],[a2,0,a2,1,a2,2,b2,j+1,…,b2,l]};然后,随机选取x[j+1],…,x[l],y,z[k]←ZN(j∈[1,l-1]),并设置半功能密钥为SK={[a0,0gy[a1,0,a1,1,a1,2,b1,j+1,…,b1,l],[a2,0,a2,1,a2,2,b2,j+1,…,b2,l]}.当一个半功能密钥用于解密一个半功能密文时,盲化因子中将出现一个额外的扰动分量e(gp[2],gp[2])x[0]·y·(z[k]-z[c]).如果z[c]=z[k],解密仍然能够正常进行.在这种情况下,我们称该密钥是象征性(nominally)半功能的.仿制的半功能密钥.通过如下步骤得到一组仿制的半功能密钥:首先,调用密钥提取算法得到一组正规的密钥SK={[a0,0,a0,1,a0,2,b0,j+1,…,b0,l],[a1,0,a1,1,a1,2,b1,j+1,…,b1,l],[a2,0,a2,1,a2,2,b2,j+1,…,b2,l]};然后随机选ξ[m,n],ζ[m,n]←ZN,其中m,n∈[0,2],n∈[j+1,l],j∈[1,l],并设置仿制的半功能密钥为SK={[a0,0gξ[0,0]b0,lgζ[0,l]b1,j+1gζ[1,j+1]2,2,bζ[2,j+1]aξ[2,2]p[2]],[a1,0gξ[1,0]仿制的半功能密钥可以正确解密所有正规密文,但在任何情况下均不能解密半功能密文.仿制的半功能密钥与半功能密钥之间的唯一区别是,在某些特定的情况下(z[c]=z[k]),半功能密钥可以定义为象征性的(nominally),但是仿制的半功能密钥却不行.我们仍然使用了混合争论(hybridargument)技术,借助一系列两两不可区分的游戏(GameReal,Page9GameReal,GameRestricted,Game0,…,Gameq,GamePre-Final-1,GamePre-Final-2,GameFinal)证明方案的安全性.第1个游戏,GameReal,是真实的游戏.第2个游戏,GameReal,与GameReal仅有一处区别,在GameReal中不再允许敌手进行委托查询,也就是说在GameReal中所有的密钥查询只调用密钥提取算法,而不再调用密钥委托算法.因此我们可以认为,在GameReal中,当敌手对某个身份向量犐进行查询时,挑战者直接将该身份对应的私钥返回给敌手,而无需在S中保存.第3个游戏,GameRestricted,与GameReal仅有一处区别,敌手不能对那些与用于挑战的身份向量的前缀modp[2]相等(各分量modp[2]相等)的向量进行私钥查询.下一个游戏,Game0,与GameRestricted仅存在一处区别,在Game0中挑战阶段返回给敌手的密文是半功能的.令q表示在阶段1和阶段2中敌手能够进行私钥查询的最大次数.下面我们定义q个游戏,{Gamek}k∈[1,q],与Game0仅存在一处区别,在Gamek中返回给敌手的前k个私钥为半功能的,其它的私钥仍为正规的.也就是说,在Game0中,返回的密文是半功能的,而返回的所有密钥都是正规的;在Gameq中,返回的密文以及所有的密钥都是半功能的.下一个游戏,GamePre-Final-1,与Gameq仅有一处区别,在GamePre-Final-1中,返回给敌手的是对一个随机消息加密得到的半功能密文.倒数第2个游戏,GamePre-Final-2,与GamePre-Final-1仅有一处区别,在GamePre-Final-2中,所有返回给敌手的密钥都为仿制的半功能的.最后一个游戏是GameFinal,它与GamePre-Final-2仅存在一处区别,在GameFinal中,返回给敌手的半功能密文是使用一个随机身份对一个随机消息进行加密所得的.我们利用下面的7个引理证明了以上游戏是两两不可区分的.引理6.对于任何算法(敌手),GameRealAdv=GameRealAdv.证明.对于某个确定的身份向量,我们有两种方式为其生成对应的密钥,一种是使用密钥提取算法,另一种是使用密钥委托算法(需要其祖先身份对应的密钥).无论使用哪种方式,密钥的分布相同.因此,对于敌手来说,以上两个游戏并无区别.引理7.假设存在算法(敌手)使得GameRealAdv-GameRestrictedAdv=ε,那么我们可以构造算法以大于等于ε/3的优势打破假设1.证明.见引理1.引理8.假设存在算法(敌手)使得那么我们可以构造算法以ε的优势打破假设2.证明.利用X1,X3,X4,T作为输入,模拟GameRestricted或Game0.它设置公共参数如下:随机选取a[1],…,a[l],b,c,α,δ←ZN,并设置v=X1,ui=va[i],w=vb,f=vc,Rv=Xδv,Rf=Rcv,其中i∈[1,l].它将公共参数{X3,X4,RbU1=u1·Ru,1,…,Ul=ul·Ru,l,V=v·Rv,W=w·Rw,F=f·Rf,E=e(v,v)α}返回给.每当被查询身份(I[1],…,I[j])对应的私钥时,它随机选取r[1],r[2],s[1],s[2],t[1],t[2],x[j+1],…,x[l],y[1],y[2],y[3]←ZN,并置密钥为Kd=[vr[1]Xy[1]ur[1]j+1Xx[j+1]Kr=[[vs[1],vs[2],(uI[1][vt[1],vt[2],(uI[1]给发送两个消息,M0,M1,和两个身份犐0=(I[0,1],…,I[0,i]),犐1=(I[1,1],…,I[1,j]).选择两个随机比特β,γ←{0,1},产生密文如下:C0=MC2=T,C3=Tc.如果T∈Gp[1]p[2]p[4],那么这是一个半功能密文,其中z[c]=a[1]I[γ,1]+…+a[h]I[γ,h]+b.如果T∈Gp[1]p[4],那么这是一个正规的密文.因此,可以用的输出来区分T的不同可能.引理9.假设存在算法(敌手)使得那么我们可以构造算法以ε的优势打破假设3.证明.利用X1,X3,X4,Y1X2Y4,Y2Y3,T作为输入,模拟Gamek-1或Gamek.它随机选取a[1],…,a[l],b,c,α,δ←ZN,并设置v=X1,ui=va[i],w=vb,f=vc,Rv=Xδ中i∈[1,l].将公共参数{X3,X4,U1=u1·Ru,1,…,Ul=ul·Ru,l,V=v·Rv,W=w·Rw,F=f·Rf,E=e(v,v)α}发送给.当进行第i次私钥查询时(针对身份犐[i]=(I[1],…,I[j])):对于i<k的情况,生成一组半功能密钥.它随机选取r[1],r[2],s[1],s[2],t[1],t[2],m[1],m[2],m[3],n[j+1],…,n[l]←ZN,并设置密钥为Page10Kd=[vr[1](Y2Y3)m[1],vr[2]Xm[2](Y2Y3)m[3],ur[1]Kr=[[vs[1],vs[2],(uI[1][vt[1],vt[2],(uI[1]对于i>k的情况,调用密钥提取算法生成一组正规的密钥.对于i=k的情况,假设设置z[k]=a[1]I[1]+…+a[j]I[j]+b,随机选取r[1],r[2],s[1],s[2],t[1],t[2],x[j+1],…,x[l],y[2],y[3]←ZN并设置密钥为Kd=[Tr[1],vr[2]Xy[2]Tr[1]a[j+1]Xx[j+1]Kr=[[vs[1],vs[2],(uI[1][vt[1],vt[2],(uI[1]发送给两个消息M0,M1以及两个身份犐0=(I[0,1],…,I[0,i]),犐1=(I[1,1],…,I[1,j]).随机选取β,γ←{0,1}.构造密文如下:C0=MC1=(Y1X2Y4)a[1]I[γ,1]+…+a[h]I[γ,h]+b,C2=Y1X2Y4,C3=(Y1X2Y4)c.令vs=Y1,Rsa[h]I[γ,h]+b,其中S4是子群Gp[4]中的随机元素.因为第k个密钥对应的身份向量与用于挑战的身份向量的前缀modp[2]不等(各分量modp[2]不等),所以z[k]和z[c]对可看作是随机分布的.然而,z[k]和z[c]之间的关系是至关重要的(尽管这种关系对是隐藏的):如果试图通过“自己生成一个用犐[k]=(I[1],…,I[j])加密的半功能密文并尝试对其解密”这种方法来测试第k个密钥SK犐[k]是否为半功能的,那么无论SK犐[k]是否为半功能的,解密都能正常工作,因为z[k]=z[c].换言之,模拟器仅能生成一个象征性(nominally)半功能密钥.如果T∈Gp[1]p[3],那么正确地模拟了Gamek-1.如果T∈Gp[1]p[2]p[3],那么正确地模拟了Gamek.因此,能够利用来区分T的不同可能.引理10.假设存在算法(敌手)使得GameqAdv-GamePre-Final-1Adv=ε,证明.利用X1,Z2,X3,X4,Xα那么我们可以构造算法以ε的优势打破假设4.T作为输入,模拟Gameq或GamePre-Final-1.随机选择a[1],…,a[l],b,c,α,δ←ZN,并设置v=X1,ui=va[i],w=vb,f=vc,Rv=XδRf=Rcv,其中i∈[1,l].它给发送公共参数{X3,X4,U1=u1·Ru,1,…,Ul=ul·Ru,l,V=v·Rv,W=w·Rw,F=f·Rf,E=e(Xα(I[1],…,I[j])的密钥时,生成对应的半功能密钥.它随机选取r[1],r[2],s[1],s[2],t[1],t[2],m[1],m[3],n[j+1],…,n[l],x[j+1],…,x[l],y[1],y[2],y[3]←ZN,并计算密钥:Kd=[vr[1]Zm[1]vαX2(uI[1]ur[1]Kr=[[vs[1],vs[2],(uI[1][vt[1],vt[2],(uI[1]令Rs给发送两个消息M0,M1以及两个身份犐0=(I[0,1],…,I[0,i]),犐1=(I[1,1],…,I[1,j]).随机选取β,γ←{0,1}.构造密文如下:C0=MC2=Xsa[h]I[γ,h]+b,其中S4是子群Gp[4]中的随机元素.在这里,z[c]仅与z[c]modp[2]有关,由于u1=va[1],…,ul=va[l],w=vb是子群Gp[1]中元素,所以当a[1],…,a[l],b在ZN中选取时,a[1],…,a[l],bmodp[1]与z[c]modp[2]是无关的,故z[c]对可看作是随机分布的如果T=e(X1,X1)α·s,那么以上密文是消息β对应的半功能密文.如果T为GT中的随机元M素,那么该密文是对一个随机消息加密得到的半功能密文.因此,可以用的输出来区分T的不同可能.引理11.假设存在算法(敌手)使得GamePre-Final-1Adv-GamePre-Final-2Adv=ε,那么我们可以构造算法以ε的优势打破假设6.证明.利用X1,X3,X4,Xκ1X2,Y1X2Y4,GT,T作为输入,模拟GamePre-Final-1或GamePre-Final-2.随机选取a[1],…,a[l],b,c,α,δ←ZN,并设置v=X1,ui=va[i],w=vb,f=vc,Rv=XδRw=Rb{X3,X4,U1=u1·Ru,1,…,Ul=ul·Ru,l,V=v·Rv,W=w·Rw,F=f·Rf,E=e(v,v)α}发送给.查询身份(I[1],…,I[j])对应的密钥时,设置z[k]=a[1]I[1]+…+a[j]I[j]+b,并随机Page11选取r[1],r[2],s[2],t[2],x[j+1],…,x[l],y[1],y[2],y[3]←ZN,返回密钥:Kd=[(Xκvα(Xκ1X2)r[1]·a[j+1]Xx[j+1]Kr=[[T,Ts[2],Tz[k]Tc·s[2],Ta[j+1],…,Ta[l]],[T,Tt[2],Tz[k]Tc·t[2],Ta[j+1],…,Ta[l]]].如果T∈Gp[1],以上密钥是半功能的.如果T∈(XκGp[1]p[2],以上密钥是仿制的半功能的.发送给两个消息M0,M1以及两个身份犐0=(I[0,1],…,I[0,i]),犐1=(I[1,1],…,I[1,j]).随机选取CR←GT,γ←{0,1}.并生成密文:C0=CR,C1=(Y1X2Y4)a[1]I[γ,1]+…+a[h]I[γ,h]+b,C2=Y1X2Y4,C3=(Y1X2Y4)c.令vs=Y1,Rsa[h]I[γ,h]+b,其中S4是子群Gp[4]中的随机元素.如果T∈Gp[1],那么正确地模拟了GamePre-Final-1.如果T∈Gp[1]p[2],那么正确地模拟了GamePre-Final-2.因此,能够利用来区分T的不同可能.引理12.假设存在算法(敌手)使得GamePre-Final-2Adv-GameFinalAdv=ε,证明.利用Z2,X3,X4,X1X2,Xα那么我们可以构造算法以ε的优势打破假设5.1Z2Z4,GT,T作为输入,模拟GamePre-Final-2或XsGameFinal.随机选取a[1],…,a[l],b,c←ZN,并设置V=X1Xδ[1,l].它将公共参数{X3,X4,U1,…,Ul,V,W,F,E=e(Xα(I[1],…,I[j])的密钥时,生成对应的半功能密钥.它随机选取r[1],r[2],s[1],s[2],t[1],t[2],x[j+1],…,x[l],y[1],y[2],y[3]←ZN,并计算密钥:Kd=[(X1X2)r[1]Xy[1]Xα(X1X2)a[j]I[j](X1X2)b)r[1](X1X2)cr[2]Xy[3](X1X2)a[j+1]r[1]Xx[j+1]表1匿名HIBE方案效率及安全性对比文献公共参数的长度私钥的长度密文的长度解密中对运算的个数复杂性假设(静/非静态)安全模型文献[5]l2+5l+73l2+(14-k)l-3k+152l+6文献[6]2l+6(l-k)(k+5)+k+3l+4文献[7]l+4本文l+4注:l表示等级的最大深度;k表示身份所处的深度;w/oRO表示无随机预言机;f-ID表示适应性选择身份模型;s-ID表示选定身份模型.Kr=[[(X1X2)s[1],(X1X2)s[2],((X1X2)a[1]I[1]…发送给两个消息M0,M1以及两个身份犐0=(I[0,1],…,I[0,i]),犐1=(I[1,1],…,I[1,j]).随机选取CR←GT,γ←{0,1}.并生成密文:C0=CR,C1=(T)a[1]I[γ,1]+…+a[h]I[γ,h]+b,C2=Xs令Rsa[h]I[γ,h]+b,其中S4是子群Gp[4]中的随机元素.如果T=Xs份犐γ对一个随机消息加密的半功能密文.如果T是Gp[1]p[2]p[4]中的随机元素,那么该密文是一个使用随机身份对一个随机消息加密的半功能密文.因此,可以利用的输出来区分T的不同可能.至此,我们得到如下定理.定理2.如果假设1~6成立,那么我的匿名HIBE方案是ANON-ID-CPA的(定义1).证明.根据以上7个引理得知,如果假设1~6成立,那么真实游戏GameReal与GameFinal是不可区分的.又因GameFinal中β与γ对敌手是完全隐藏的(信息论意义上的),所以敌手在GameFinal中的优势为0,从而得知在GameReal中敌手的优势是可忽略的.5结论表1将目前现有的匿名HIBE方案与我们的新方案,在效率及安全性方面进行了全面对比.通过对比发现,我们的匿名HIBE方案与Seo的匿名HIBE方案[7]在效率上是相同的,但是新方案的安全性基于静态假设,并且可以在更强的适应性选择身份模型中证明安全性.2(l+2)Page12本文构造了一个匿名IBE方案和一个匿名HIBE方案.新方案均能够被证明在标准模型中(无随机预言机)达到匿名、抗适应性选择身份和选择明文攻击安全(ANON-ID-CPA).我们的匿名HIBE方案中,密文的大小仅为4个群元素,而不依赖于等级的深度.公共参数及私钥的长度也是现有匿名HIBE方案中最小的(与Seo的匿名HIBE相同).在文本的最后,我们留下一个公开问题,即如何在素数阶双线性群中构造抗适应性选择身份安全的匿名HIBE方案,并且在方案的安全性证明中使用更为标准的假设,这也是我们后续工作的一个方向.
