Page1RM树:一种支持字符串相似性操作的索引王金宝1)高宏1)李建中1)杨东华2)1)(哈尔滨工业大学计算机科学与技术学院哈尔滨150001)2)(哈尔滨工业大学基础与交叉科学研究院高性能计算中心哈尔滨150001)摘要字符串相似性操作在很多领域中被广泛应用,如数据清洁、信息集成等.现有研究工作主要为基于q-Gram和倒排索引的内存方法,在处理大量数据时具有以下缺点:内存消耗大、更新效率低、支持操作类型有限.现有的外存索引Bed树无法将相似的字符串聚类,在查询处理过程中导致了较大的I/O代价.该文设计了支持多种字符串相似性操作的RM树索引,消除了现有内存方法的缺点,并通过字符串聚类的方法提高了相似性操作的效率.该文通过大量实验结果证明了RM树的有效性.关键词字符串;相似性;索引;查询处理;连接处理1引言字符串相似性操作包括相似性查询操作和相似性连接操作.这些操作被广泛应用于众多领域,如数据清洁、信息集成、拼写校验以及生物信息处理等.当前,随着信息生成速度的增加和信息存储能力的增长,大规模数据集合日益普遍.字符串数据是其中的重要组成元素.Google拥有的N-Gram数据集合包含1T条元组;在生物信息方面,GeneBank数据集合大小达到416GB,包含超过100万条记录.在如此庞大的字符串数据集合中,定位相似性操作涉及的数据是一项具有挑战性的任务.当前,针对字符串相似性操作的研究工作主要集中在两个方面:字符串相似性查询和字符串相似性连接.大部分研究工作基于q-Gram以及倒排索引.这些方法在处理大规模字符串数据集合时有以下劣势:(1)内存消耗过大.现有的基于q-Gram和倒排索引的方法都针对内存设计,没有给出有效的外存算法.(2)存储代价过大.即使将q-Gram以及倒排索引存储在磁盘上,其存储代价将与原有数据大小不相上下,甚至超过原始数据.(3)更新代价大.对原始数据的每一次更新,都需要修改若干Gram对应的倒排链表.在实际应用中,倒排链表的长度与数据集合的大小成正比,因此更新若干倒排链表的代价不容忽视.(4)支持查询的类型有限.只能支持范围查询以及连接操作,其它复杂查询如top-k查询等则无法直接支持.Bed树是一种树形索引结构,用于支持字符串相似性操作,这也是与本文工作最为相关的工作.Bed树为字符串数据设定一维的顺序,将数据排序并按照该顺序建立B+树索引存储数据.Bed树中使用3种字符串排序,分别为Dic-tionaryOrder、GramCountingOrder和GramLo-cationOrder.在查询过程中,不同的字符串排序方法分别结合了不同的过滤器用以选择包含查询结果的子树.然而,使用一维顺序排列字符串无法有效地将相似的字符串聚类,降低了过滤器的效果.因此,Bed树在处理查询时,即使查询结果很少,查询处理也会引起很多I/O操作.本文设计了一种支持字符串相似性操作的索引结构RM树.RM树将相似的字符串聚类在一起,减少了Bed树中使用一维排序方法引起的昂贵的查询处理I/O开销.RM树通过字符串的Gram集合,将相似的字符串组织到相近的叶节点中.字符串首先被转换成固定维度的Gram向量,并使用与R树类似的方法管理和操作这些Gram向量.不同于R树,RM树在每个节点中加入该子树中Gram集合的signature,进一步刻画该子树中字符串的内容,增加查询处理过程中,子树之间的过滤能力.由于在R树中加入位图Bitmap作为signature,本文设计的索引命名为RM树.RM树支持多种字符串相似性操作包括范围查询、top-k查询、连接操作.实验结果表明,RM树有效地降低了字符串相似性操作过程中的I/O代价,减少了时间开销.本文的主要贡献在于:(1)本文提出了一种新的索引结构RM树,用于支持多种字符串相似性操作.RM树节点中保存Gram向量和位图信息用于削减搜索空间.(2)本文给出了RM树的构建方法,即适用于字符串数据的插入目标选择方法,节点分裂方法.(3)本文设计了RM树中处理多种字符串相似性操作的方法,包括范围查询、top-k查询以及连接操作.RM树在查询处理过程中利用节点中存储的Gram向量和位图信息有效地削减了搜索空间.(4)本文通过大量实验测试了RM树处理各种字符串相似性操作的代价,包括I/O代价和时间开销.实验部分还测试了建立RM树的时间开销.本文第2节介绍各种字符串相似性操作的定义.第3节给出RM树的结构以及RM树的插入算法.RM树处理各种字符串相似性查询的方法在第4节中给出,包括范围查询处理、top-k查询处理以及连接操作的处理方法.第5节简介RM树基于其它字符串相似性度量的应用.第6节通过真实数据和人工合成数据上的实验验证了RM树索引结构的有效性.第7节介绍RM树的相关工作.最后,第8节给出本文结论.2背景知识本节介绍编辑距离、q-Gram、字符串相似性操作的定义,包括字符串相似性查询和连接操作.2.1编辑距离和狇-Gram给定字母表Σ,字符序列s∈(Σ)定义为Σ中字符串,记s[i]为字符串s的第i个字符,|s|为s的长度.编辑距离(也叫做EditDistance),是指两个字符串之间,由一个转成另一个所需的最少编辑操作次数.其中,编辑操作包括将一个字符替换成另一个字符,插入一个字符,删除一个字符.字符串s和字符串t的编辑距离记为ED(s,t).设字符α,βΣ,在s的开头加上q-1个α,在s的末尾加上q-1个β,Page3得到字符串s.字符串s中所有长度为q的子串组成s的q-Gram集合,简称Gram集合,记为GS(s).字符串s拥有|s|+q-1个q-Gram,如果两个字符串s和t的编辑距离不大于k,则它们至少拥有max{|s|,|t|}-1-(k-1)×q个相同的Gram,这是现有工作中广泛使用的过滤条件之一.例1.表1给出了包含3个字符串的集合S.其中,字符串s1=“JimGrey”和s2=“JimGray”的编辑距离ED(s1,s2)=1,字符串s1中的第7个字符e替换成字符a就可以得到字符串s2.IdContentIdContent1JimGray3StoneBreaker2JimGrey2.2字符串相似性操作给定字符串数据集合S={s1,s2,…,sN},范围查询Q(s,θ)返回结果为S={s|s∈S,ED(s,s)θ},即数据集合中与给定字符串s的编辑距离不大于阈值θ的所有字符串.在S中执行范围查询Q(s1,1)将得到结果{s1,s2}.Top-k查询Q(s,k)返回S中与给定字符串s编辑距离最小的k个字符串组成的集合.在集合S中执行top-2查询Q(s2,2)的结果为{s1,s2}.2.3字符串相似性连接给定字符串集合S={s1,…,sN}和R={r1,…,rM},字符串相似连接操作Join(R,S,θ)返回J={(s,r)|s∈S,r∈R,ED(s,r)θ}.即所有满足以下条件的字符串对:(1)字符串对中一个来自S,另一个来自R;(2)二者的编辑距离不大于给定的阈值θ.执行表1中集合S与表2中集合R的连接操作Join(R,S,1)的结果为空集,执行连接操作Join(R,S,3)的结果为{(J.Gray,JimGray)}.3RM树索引本节介绍RM树索引结构及其构建方法.3.1节介绍RM树的索引结构,3.2节给出RM树的构建方法.将字符串s插入RM树前,需要计算Gram向量、MBR及Bitmap,它们的定义如下.定义1(字符串s的d维Gram向量).给定正整数q和从字符串集合到正整数集合[1,d]的Hash函数hV,字符串s的q-Gram集合记为GS(s).字符串s的Gram向量犵狏(s)是一个d维向量,该向量的第i个分量犵狏(s)[i]的值为|{g∈GS(s),hV(g)=i}|.定义2(字符串集合S的MBR).字符串集合S中所有字符串的d维Gram向量组成的d维区间称为S的MBR(MinimalBoundingRegion).定义3(字符串s的Bitmap).给定从字符串集合到整数集合[1,L]的Hash函数hB、字符集ΣΣ和字符c,字符串s的Bitmap为一串0-1序列,记为B(s),其中第i位为1当且仅当以下两个条件中至少有一个成立,(1)g∈GS(s)∩(Σ)而且hB(g)=i;(2)g∈GS(s),g(Σ),将g中不属于Σ的字符替换成c得到g,hB(g)=i.将g中不属于Σ的字符替换成c的转换记为T(g)=g.RM树中,Σ为字母集合,不包含标点和特殊符号,这样可以大幅降低Bitmap中1的个数,增加Bitmap过滤的作用.L为Bitmap的长度.定义4(字符串集合S的Bitmap).字符串集合S的Bitmap记为B(S),定义为其中所有字符串的Bitmap的或(“|”)操作结果.即B(S)的第i位为1当且仅当S中存在s,满足B(s)的第i位为1.3.1RM树索引结构RM树具备高度平衡性质,即所有叶子节点都在同一层上.RM树节点与磁盘页一一对应,并被存储在磁盘上.RM树节点分为内节点和叶节点两类.RM树通过字符串的Gram向量来组织数据存储,将相似的字符串存储在相同或相近的叶节点中.在查询处理过程中,RM树使用Gram向量、MBR和Bitmap作为过滤信息,削减搜索空间,提高查询处理效率.RM树内节点的存储格式为(PageId,MBR,Bitmap,LengthRange,ChildrenSet),其中PageId是内节点对应磁盘页的编号,MBR是以该节点为根的子树中存储的字符串集合的MBR.Length-Range为该子树中字符串长度的范围.Bitmap为该子树中存储的字符串集合的Bitmap.内节点的ChildrenSet包括若干儿子记录,儿子记录格式为(PageId,MBR,Bitmap,LengthRange).其中,PageId为儿子节点对应的磁盘页编号,MBR,Bitmap,LengthRange分别为以该儿子为根的子树中包含的字符串集合的MBR、字符串所有Bitmap以及长度范围.图1所示为RM树内节点的结构.RM树叶子节点的存储格式为(PageId,MBR,Bitmap,LengthRange,DataSet).其中,PageId是Page4叶子节点对应的磁盘页的编号,MBR是该节点包含的字符串集合的MBR,LengthRange为该节点内字符串的长度范围,Bitmap为该叶子节点中包含的字符串集合的Bitmap,DataSet是该叶子节点包含的字符串数据集合.在RM树中内节点NI的MBR、Bitmap、LengthRange通过该节点的所有儿子的MBR、Bitmap、LengthRange计算得到.其中,NILengthRange的下界为NI所有儿子的LengthRange的下界的最小值,其上界为NI所有儿子上界的最大值.NIBitmap[i]=1当且仅当存在NI的儿子N,使得NBitmap[i]=1.在RM树中叶子节点NL的MBR、Length-Range和Bitmap通过NL中包含的字符串计算获得.其中,NLLengthRange=[mins∈NL.DataSet{s},maxs∈NL.DataSet{s}].NI.Bitmap[i]=1当且仅当存在s∈NL.DataSet使得B(s)[i]=1.在RM树节点中存储字符串集合的MBR和Bitmap信息,有助于查询处理过程中的搜索空间削减.增加MBR的维度和Bitmap的长度可以提高其过滤能力,但是也降低了RM树节点的度,增加查询处理的I/O代价,因此取值需要折中选取,本文实验部分测试了MBR维度和Bitmap长度对RM树性能的影响.定理1和定理2描述了MBR和Bitmap削减搜索空间的作用.在介绍定理1和定理2之前,首先介绍以下定义.定义5(字符串s与字符串t的Gram向量距离).字符串s和字符串t的d维Gram向量距离定义为DG(s,t)=∑d和t的d维Gram向量各个位之差的和.定义6(字符串s与字符串集合S的Gram向量距离).字符串s的Gram向量记为犵狏(s),字符串集合S中的所有字符串的Gram向量确定了S的MBR.字符串s与字符串集合S的Gram向量距离定义为,DG(s,S)=∑犵狏(s)[i]>S.MBRUP[i]S.MBRUP[i]).即通过MBR可以判断不属于GS(S),但属于GS(s)的Gram个数.定义7(字符串s与字符串集合S的Bitmap距离).字符串s的Gram集合记为GS(s),字符串集合S的Bitmap记为B(S),s与S的Bitmap距离DB(s,S)=|{g|g∈GS(s),g=T(g),B(S)[hB(g)]=0}|,即通过Bitmap可以确定s中不存在的GS(S)中的Gram的个数.下面介绍定理1和定理2,其中定理1说明了若两个字符串的编辑距离小于给定的阈值,则它们的Gram向量距离也小于某一阈值.由此,Gram向量距离可以用来在RM树中,判断某一子树中是否包含与目标字符串编辑距离小于某阈值的字符串.定理2说明了如果一个字符串s和一个字符串集合S的Bitmap距离大于给定阈值,则S中的所有字符串与s的编辑距离不小于某一阈值.由此,Bitmap距离也可以用来判断子树中是否包含与s编辑距离不超过给定阈值的字符串.定理1.如果字符串s1和字符串s2的编辑距离不大于θ,则s1和s2的Gram向量距离不大于2θ×q,其中q为Gram长度.证明.由于字符串s1和字符串s2的编辑距离不大于θ,可知s1的q-Gram集合与s2的q-Gram集合的差中至多有θ×q个元素,即|GS(s1)/GS(s2)|θ×q.对称地,不等式|GS(s2)/GS(s1)|θ×q也成立.由Gram向量距离的定义可知,在计算字符串s的d维Gram向量时,不同的Gram可能被散列到同一个维度进行计数.记GSi(s)为字符串s的被映射到第i个维度的Gram组成的集合.字符串s1和字符串s2的Gram向量在第i个维度上的差为|犵狏(s1)[i]-犵狏(s2)[i]|,它的数值不大于|GSi(s1)/GSi(s2)|+|GSi(s2)/GSi(s1)|.对这两个数值在维度从1到d上取和,可以得出两个字符串的Gram距离向量满足如下不等式:DG(s1,s2)|GS(s1)/GS(s2)|+|GS(s2)/GS(s1)|.由此得证DG(s1,s2)2θ×q.证毕.定理2.如果字符串s和字符串集合S的Bit-map距离大于θ×q,则不存在t∈S使得字符串s和t的编辑距离不大于θ.Page5证明.由字符串s和字符串集合S的Bitmap距离大于θ×q,可知字符串s的Gram集合GS(s)中至少有θ×q个Gram组成集合G,满足g∈G,必不存在t∈S使得g∈GS(t).因此,对于t∈S,字符串s中包含多于θ×q个字符串t中不存在的Gram,因此s与t的编辑距离不小于θ.即S中不存在与s编辑距离不大于θ的字符串.证毕.算法1.ChooseChild.输入:字符串s,RM树内节点N输出:作为插入目标的儿子编号j1.fori=1to|NChildrenSet|2.i’sENLARGE(i)=(MOEnlarge(s),BEnlarge(s))3.jisthechildwithleastenlargevalue4.returnj3.2RM树插入方法RM树的插入过程从根节点开始,从上而下选择子树插入,直到最终选择一个叶子节点作为插入目标.随后,字符串s被插入到叶子节点中,叶子节点判断是否需要处理溢出,并更新叶子节点的MBR,Bitmap等信息.如果作为插入目标的节点产生分裂或者形状变化,则分裂和形状变化作为插入结果,返回给父亲节点,并在父亲节点中进一步处理,如果父亲节点也由此产生分裂,则该父亲节点也向它的父亲节点返回插入结果.根节点的分裂将产生新的根节点,并增加树的高度,这与B树等的插入过程相似.RM树的插入过程与其它索引树的不同在于插入目标的选择和节点分裂的过程.算法1的ChooseChild和算法2的SplitIndex分别描述了插入目标选择和内节点的分裂过程,算法4的SplitLeaf描述了RM树叶子节点的分裂过程.算法1用于在节点N中选择字符串s插入的子树.对于N的每个儿子节点i,ChooseChild计算在i中插入字符串s产生的ENLARGE数值(第1~2行),并选择该数值最小的节点来完成s的插入(第3~4行).儿子节点i的ENLARGE数值由两部分组成,分别为MOEnlarge和BEnlarge.其中,MOEnlarge描述在i中插入s后MBR与其它儿子节点的MBR相交部分的增量,而BEnlarge描述了在i中插入s后,节点i的Bitmap中从0变成1的位的数量.使用MBR的相交增量作为首要排序元素,减小了插入目标节点的MBR与其它儿子节点的MBR的相交之和,以此减少查询过程中多个儿子被访问的可能性,从而达到减低I/O操作的目的.由于Bitmap在RM树中用作MBR之后的过滤条件,因此次要排序元素使用Bitmap,其中Bitmap从0~1的位的数量描述了Bitmap过滤能力的损失大小.为了提高查询处理的效率,ENLARGE二元组越小越好.算法2.SplitIndex.输入:RM树内节点N输出:索引项集合p1,p21.dim=chooseSplitDimension(N)2.sortNChildrenSeton〈MBR[dim]low,3.fori=mtoM-m4.partitionN.entryListintop1andp25.cost[i]=〈MbrOverlap(p1,p2),BSum(p1)+6.choosepartitionstrategyjwithminimalcost7.partitionN.entryListintop1andp28.return(p1,p2)RM树节点的MBR为多维区域,在节点分裂过程中,将多维区域划分到两个集合的方法,在R树及其诸多改进工作中被广泛研究.与R树不同,RM树节点中包含字符串集合的MBR和Bitmap两类信息,而且这两类信息不能组成一个多维区域.算法2描述了RM树内节点分裂的过程.与R树节点分裂的过程类似,算法SplitIndex首先调用chooseSplitDimension方法(第1行)确定划分维度,该算法与R树中选择划分维度的算法相似(算法3描述了选择划分维度的过程,与R树的不同,每种划分的代价的值为一个二元组,两个维度分别为分裂后产生的两个MBR的相交体积和两个Bitmap中1的个数之和(第5行)).随后,算法2在选中的维度上把所有索引项排序(第2行),并计算所有可行划分的代价,从中选择代价最小的划分(第3~6行),其中m和M为节点中索引项的最小、最大数目.最终,算法2按照代价最小的划分策略将所有索引项划分成两组(第7行).在节点分裂算法中,RM树在选择划分维度,以及生成可行划分策略时使用的排序使用MBR,由于相似的字符串集合的MBR也会相似,通过MBR划分节点中的索引项可以将相似的字符串组织到相近的子树中.不同的Gram可能被哈希到同一个Gram向量的维度,而被视作相同的Gram.在查询处理过程中,Bitmap中包含的更精确的Gram信息可以用作进一步过滤来排除不相干的Gram.算法3.chooseSplitDimension.输入:RM树内节点N输出:划分维度dim1.fori=1tod2.sortNentryListon〈MBR[d]low,MBR[d]up〉3.forj=mtoM-m4.partitionNentryListintop1,p2Page65.cost=(MOverlap(p1,p2),BSum(p1)+6.choosejwithminimalcost7.cost[i]=subcost[j]8.choosedimwithminimalcost9.returndim算法4描述了叶子节点的分裂过程,与内节点分裂方法类似,RM树的叶子节点分裂时同样将字符串排序,然后计算可能的划分策略的代价,最后选择代价最小的划分策略进行分裂操作.算法4.splitLeaf.输入:RM树内节点N输出:字符串集合p1和p21.dim=dimensionwithlargestlength2.sortstringsonthedim-thvalueofGramvector3.fori=mtoM-m4.partitionstringsintop1andp25.cost[i]=〈Area(p1)+Area(p2),BSum(p1)+6.choosepartitionstrategyjwithminimalcost7.partitionstringsintop1andp2RM树叶子节点的分裂过程与内节点分裂过程的不同之处在于:(1)在选择划分维度的时候,叶子节点使用长度最长的维度进行划分,这是因为每个字符串都是Gram向量空间中的点,任何维度上的划分都能将叶子节点的MBR分裂成两个不相交的划分.选择长度最长的维度划分,可以得到各个维度长度更为平衡的叶子节点.(2)每种划分方法的代价是一个二元组,由新生成的两个叶子的MBR体积之和以及Bitmap中1的数量之和组成.在划分过程中选择产生体积小、Bitmap中1的数量小的策略,有助于提高查询处理过程中的剪枝能力,减少查询处理的I/O代价.4RM树中的查询处理算法本节介绍RM树中的查询处理算法.4.1节给出字符串相似性查询的处理算法,4.2节介绍字符串相似性连接的处理算法.在介绍具体查询处理算法前,本节首先给出RM树使用的节点过滤方法.图2描述了RM树在处理字符串相似性操作时,节点过滤的功能框架.目标字符串s首先被转换成Gram集合GS(s),随后生成s的Gram向量犵狏(s)和BitmapB(s).对于给定的编辑距离阈值θ,RM树通过3个过滤器来判断以给定节点N为根的子树TN中是否可能包含字符串t,使得ED(s,t)θ.3种过滤器及其使用方法如下:(1)长度过滤器(LengthFilter),记s的长度为Ls,TN中最短的字符串长度为LLOWTN,TN中最长的字符串的长度为LUPTN,如果Ls<LLOWTN-θ或者Ls>LLOWTN+θ,则TN中所有字符串与s的编辑距离都大于θ.(2)Gram向量过滤器(GramVectorFilter),由定理1可知,如果字符串s与N的Gram距离大于q×θ,则TN中所有字符串与s的编辑距离都大于θ.(3)Bitmap过滤器(BitmapFilter),由定理2,如果字符串s与N的Bitmap距离大于q×θ,则TN中所有字符串与s的编辑距离都大于θ.通过上述3种过滤器,RM树可以判断给定子树中是否可能存在与目标字符串的编辑距离不大于θ的字符串.算法5.filter.输入:字符串s,RM树节点N,编辑距离阈值θ输出:是否通过过滤器1.if(Ls<LLOW2.returnfalse3.if(DG(s,N)>θ×q)4.returnfalse5.if(DB(s,N)>θ×q)6.returnfalse7.returntrue将Gram向量过滤器与节点N的Bitmap结合使用,取得优于单独使用Gram向量过滤器时的过滤效果.首先计算s与节点N的Gram向量距离,记为Dist1.随后,对于目标字符串s的Gram集合GS(s)中的每个元素g,如果Bitmap中对应的数值为0,而且s的Gram向量犵狏(s)对应的位的数值不大于N的MBR中对应维度的上界,则Dist1的数值加1.最后,如果Dist1的数值大于q×θ,则TN中不包含与s的编辑距离不大于θ的字符串.算法5用于判断TN中是否可能存在字符串t,使得ED(s,t)θ,不可能存在时返回false.其中DG(s,N)为使用结合N的Bitmap的Gram向量过滤器计算而得的数值.RM树的过滤功能不会随字符串长度的增加而减弱.首先,RM树使用长度过滤器,在长字符串集合中,字符串长度差异较大,因此长度过滤器效果会Page7更好.其次,RM树使用的Gram过滤器在长字符串组成的数据集合中也会取得更好的效果,这是因为不同的Gram向量个数增加了.4.1字符串相似性查询处理算法RM树支持字符串相似性范围查询和top-k查询,本小节首先介绍RM树处理字符串相似性范围查询Q(s,θ)的算法,然后介绍处理top-k查询Q(s,k)的算法.RM树中的查询处理算法使用先过滤后验证模式,算法首先找到查询结果的候选字符串,然后通过计算编辑距离来验证该候选字符串是否属于查询结果集合.算法6.RangeQueryProcessing.输入:RM树内节点N,字符串s,阈值θ输出:字符串集合Result1.Result=2.if(Nisaninternalnode)3.foriinN.childrenSet4.if(filter(s,i,θ))5.Result=Result∪RangeQueryProcessing(i,s,θ)6.else7.foriinN.dataSet8.if(ipassesfilter)9.if(ED(i,s)θ)10.Result=Result∪{i}11.returnResult4.1.1范围查询处理算法RM树的范围查询处理从根节点开始,逐层向下选择可能包含查询结果的子树,最终查找到包含查询结果的叶子节点,并验证这些叶子节点中的字符串是否属于查询结果集合.算法6描述了RM树节点N处理范围查询的过程,算法6调用算法5filter来排除不可能包含查询结果的子树.如果节点N是一个内节点(第2行),算法6调用filter方法考察N的每个儿子(第4行),排除不可能含有查询结果的儿子节点.对于可能含有查询结果的儿子节点,算法6递归调用自身,并合并结果(第4~5行).如果N是一个叶子节点,则算法6逐个检查N中包含的字符串是否与目标字符串拥有足够多的公共Gram(第8行),如果是则计算它们之间的编辑距离,并返回编辑距离不大于阈值θ的字符串(第9~10行).根据之前介绍的RM树使用的过滤器的功能可知,在根节点调用算法6能找到RM树中与目标字符串s的编辑距离不大于阈值θ的所有字符串.4.1.2Top-k查询处理算法RM树处理字符串top-k查询时采用分支界限策略,并维护长度为k的结果缓存.假设当前结果缓存ResultBuffer中保存了当前搜索到的与字符串s的编辑距离最小的k个结果,top-k查询处理算法确定下一步需要搜索的子树,并在其中搜索与s的编辑距离小于ED(s,ResultBuffer[k])的字符串,若找到若干满足条件的结果,查询处理算法更新ResultBuffer,并开始下一轮确定子树及搜索过程,直到未被搜索过的子树中都不可能包含与s的编辑距离小于ED(s,ResultBuffer[k])为止.算法7的Top-KQueryProcessing描述了RM树处理top-k查询Q(s,k)的过程,RM树调用在根节点调用算法7来处理top-k查询Q(s,k),其中root是RM树的根节点.算法7.Top-KQueryProcessing.输入:RM树内节点N,字符串s,整数k输出:字符串集合R1.R=2.insertn’childrenintomin-heapH3.while(H≠)4.popminimalnfromH5.if(nisaninternalnode)6.fori=1tonumberofN’schildren7.i’skey=max{DG(s,n)/θ,DB(s,n)/θ}8.if(|R|<korkey<ED(s,R[k]))9.insertiintoHaccordingtokey10.else11.refineR,Hwithstringsinn12.returnR算法7中,1~2行初始化结果缓存R和最小堆H.其中R用于保存当前与查询目标字符串s编辑距离最小的k个结果;H用于保存处理查询时需要访问的RM树节点.H不为空时算法逐轮运行(3~4行),返回结果.如果当前处理节点为内节点,5~9行计算每个儿子包含的字符串与s的最小编辑距离,并以此为key,将需要访问的儿子节点插入最小堆H中.如果当前处理节点是叶子节点,算法(10~11行)通过叶子节点中的字符串完善当前top-k结果,并去除H中无需访问的节点.最后,在H中没有节点的情况下,算法返回R,此时,R包含了以N为根的子树中的top-k查询处理结果.4.2字符串相似性连接算法假设两个字符串集合R,S被存储在两个RM树中,记为TR和TS.RM树字符串相似连接操作从TR和TS的根节点开始,递归地在可能产生连接结果的子树之间进行连接操作.具体执行过程由算法8的Join所描述,R和S之间的字符串相似连接需要Page8调用Join(TR.root,TS.root,θ).算法8.Join.输入:RM树内节点R、S,编辑距离阈值θ输出:字符串对集合Result1.Result=2.if(R,Sarebothinternalnodes)3.foriinR.childrenSet,jinS.childrenSet4.if(DG(i,j)θ×qandDBθ×q)5.Result=Result∪Join(i,j,θ)6.elseif(Risinternalnode)7.foriinR.childrenSet8.if(DG(i,S)θ×qandDB(i,S)θ×q)9.Result=Result∪Join(i,S,θ)10.elseif(Sisinternalnode)11.forjinS.childrenSet12.if(DG(R,j)θ×qandDB(R,j)θ×q)13.Result=Result∪Join(i,S,θ)14.else15.foriinR.dataSet,jinS.dataSet16.if((i,j)passesfilter)17.if(ED(i,j)θ)18.Result=Result∪{(i,j)}19.returnResult算法8描述了以节点R和S为根的子树之间进行字符串相似连接的过程,针对R和S的不同节点类型进行处理.第1行初始化结果集合Result为空集.当R和S都是内节点的时候(2~5行),所有R的儿子和S的儿子组成的子树对(i,j)都被检查,如果可能产生连接结果,即子树i和子树j中存在字符串对(s,r),满足r∈R,s∈S且ED(s,r)θ,则算法递归调用Join(i,j,θ),并将递归调用的结果加入Result.如果R和S中有一个为内节点,另一个为叶子节点(6~13行),则检查内节点的每个儿子和叶节点组成的子树对,如果可能产生连接结果,则在该子树对中递归调用Join算法并将结果加入连接结果集合.如果R和S都是叶子节点(14~18行),则检查R中的字符串和S中的字符串组成的每一个字符串对(r,s),如果r和s的编辑距离可能小于θ,则计算r和s的编辑距离,如果ED(s,r)θ,字符串对(r,s)被加入结果集合Result.算法8在检查两个子树R和S是否能产生连接结果时,计算R和S的Gram向量距离和Bitmap距离(第4行,第8行,第12行),并根据定理1和定理2中编辑距离和Gram向量距离、Bitmap距离的关系进行剪枝,排除不可能生成连接结果的子树对.5RM树应用扩展本节介绍使用其它字符串相似性度量时,RM树支持各种相似性操作的方法,包括DiceSimilari-ty,CosineSimilarity,JarccardSimilarity和Nor-malizedEditDistance.给定字符串s1和s2这些字符串相似性度量如下所述:DICE(s1,s2)=2×GS(s1)∩GS(s2)COSINE(s1,s2)=GS(s1)∩GS(s2)JAD(s1,s2)=GS(s1)∩GS(s2)NED(s1,s2)=ED(s1,s2)对于上述相似性度量,RM树的使用在查询处理过程中存在区别,而插入过程没有区别,只需修改RM树中字符串和索引节点的相似性界限估计方法即可.对于DiceSimilarity,使用目标字符串与索引节点MBR和Bitmap估计分子的上界,而后用s1和s2的长度估计分母的下界,最终计算得到DiceSimilarity的上界,以此作为剪枝的依据.其它相似性度量的估计方法DiceSimilarity类似,RM树中节点的MBR、Bitmap和字符串集合长度范围使得RM树能够支持上述相似性度量.6性能评价和分析6.1实验设置本节通过实验测试RM树的性能,我们用Java语言实现了RM树索引结构以及查询处理算法,JDK版本为Java(TM)SERuntimeEnvironment(build1.6.0_22-b04).实验平台为一台PC机,配置为双核CPU,主频2.93GHz,2GB内存,320GB硬盘.实验使用的真实数据从DBLP数据集合中提取,分别为Title数据集和Author数据集.其中,Title数据集中包含1644932条字符串记录,Author数据集包含967810条字符串.对RM树的性能测试内容包括查询处理性能和RM树维度、Bitmap长度的关系,RM树处理范围查询、top-k查询和连接操作的性能以及建立RM树的时间开销.实验部分比较了RM树和Bed树的性能,其中Bed树使用GramCountingOrder,这是由于GramCountingOrder在文献[13]的众多测试中都能获得较好的性能,因此本文将其作为比较对Page9象.测试过程中使用的参数如表3所示,其中粗体的数值为参数默认值,测试中Gram的长度为2.DistanceThresholdθTop-kParameterkDimensionofMBR6.2维度和Bitmap长度对剪枝能力的影响本部分测试RM树的性能与RM树的MBR维度以及Bitmap的长度之间的关系,通过范围查询的性能评价不同MBR维度和Bitmap长度组合.实验在Title和Author数据集合中测试了维度为3、4、5,Bitmap长度为0、128、192、256和320时,测试了RM树处理范围查询的I/O代价,本部分实验缓存大小设置为0.图3(a),(b)和(c)为Title数据集合中,RM树的维度分别为3,4和5时,范围查询处理的I/O代价.I/O代价的大小反映了RM树在处理范围查询图3位图长度的影响图3(d)~(f)给出了Author数据集合中,不同维度的RM树,使用不同长度的Bitmap时的剪枝能力.从图3(d)~(f)中可见,在各个维度的RM树中加入Bitmap都增加了RM树的剪枝能力,这是由于Author数据集合中的字符串由名字组成,RM树的叶子中含有不同的Gram数量较少,故较短的Bitmap也可以增加RM树的剪枝能力.对于Title和Author两个数据集合,我们选出3维、4维和5维性能最好的RM树进行比较,以此时的剪枝能力,I/O代价越小,剪枝能力越强.如图3(a)所示,3维的RM树在Bitmap长度增加时,剪枝能力没有提高,反而略有下降.这是因为RM树的维度过低,导致过多的字符串具有相同的Gram向量,因此在同一个叶子节点中,存在不同Gram的个数较大,这使得Bitmap的过滤能力大幅下降甚至失效.因此,3维的RM树中,加入Bitmap导致节点中包含条目数量的降低,从而降低了索引的效率.从图3(b)中可见,在4维的RM树中增加Bitmap的长度,剪枝能力先降低后增长,并在Bitmap长度为256时取得最优的剪枝能力.这是由于4维的RM树中,叶子节点包含的不同Gram数量大多少于200个,因此长度256的Bitmap可以提供较好的剪枝能力.长度为128、192的Bitmap由于剪枝能力不足,又降低了内节点中索引条目的个数,导致了索引效率的降低.长度320的Bitmap具有更高的剪枝能力,但是过多地降低了内节点的度,因此效率低于长度256的Bitmap,但是由于其它长度的Bitmap.图3(c)中所示内容与(b)相似.确定后续实验使用的RM树维度和Bitmap长度.如图4(a)所示,在Title数据集合中构建的3维、4维和5维的RM树,取得最好性能的Bitmap长度分别为320、256和256.通过比较3种组合可见,4维的RM树使用长度为256的Bitmap可以获得最好的剪枝效果.类似的,图4(b)中列出了Author中3维、4维和5维的性能最好的RM树,其中4维RM树使用长度为256的Bitmap可以取得最好的剪枝效果.在后续实验中,RM树的维度和BitmapPage10长度分别确定为4和256.6.3范围查询性能分析本部分测试RM树处理范围查询的I/O代价和时间代价,从Title和Author中随机抽取100个字符串作为查询目标,并计算查询处理的平均I/O代价和时间开销.如图5所示,RM树处理范围查询的I/O代价和时间开销随编辑距离阈值的增加而增加.在Title和Author中的实验表明,与Bed树相比,RM树具有更好的剪枝能力,减少了索引节点访问次数,有效地降低了I/O代价并减少了查询处理时间开销,查询处理延时降低了25%~59%.图5范围查询性能与编辑距离的关系(16MBbuffer)图6中列出了RM树处理范围查询的I/O代价和时间开销与缓存大小的关系,其中编辑距离阈值为2.I/O代价和时间开销随缓存的增加而减少,并在缓存大小达到256MB时显著减小.这是由于缓存页面减少了磁盘读取次数,因此也降低了时间开销.从图6(a)~(d)可见,RM树在不同缓存大小情况下,性能都优于Bed树.对比Title和Author对应的I/O代价和时间开销可见,时间开销降低幅度小于I/O代价.原因为加大缓存可以降低磁盘读取次数,但是不能减少编辑距离的计算次数,因此时间开销不能获得与I/O代价同幅度的降低.6.4Top-犽查询性能分析本部分测试RM树处理top-k查询的效率,实验从Title和Author中随机抽取100个字符串作为查询目标,并测试参数k的值为1、2、4、8,缓存大小为16MB时,查询处理的I/O代价和时间开销.如图7所示,在Title中建立的RM树在回答top-k查询时,k=1的查询处理代价小于其它情况,而k的取值为2、4、8时,处理代价基本不变.这是由于Title数据集合中,字符串之间相差较大,选取top-2、top-4和top-8的字符串集合也会访问很多索引节点.在Author数据集合上的测试结果与Title数据集合中的测试结果相似,k取值从2~8时,查询处理代价都保持稳定.这是因为Author数据集合中,字符串长度差距较小,导致与目标字符串具有相似Gram向量的字符串大量存在,因此top-k查询在k较小的时候也会访问大量索引节点以获取足够的字符串进行剪枝.由于树剪枝能力不及RM树,在k的取值变化时,Bed树处理top-k查询的效率在Title和Author两个数据集合上都不及RM树.在真实的数据集合中,与Bed树相比,RM树降低了21%~39%的查询处理延时.图8给出了RM树处理top-k查询的代价与缓存大小的关系,其中参数k的值为4.RM树和Bed树处理top-k查询的I/O代价和时间开销都随缓存的增加而减少.Title数据集合中的top-k处理I/O代价大于Author数据集合中的I/O代价,这是由于Title中不同字符串相差更大,获取k个最相似的字符串需要访问更多的索引节点,造成更大的I/O代价.时间开销的降低幅度不及I/O代价的降低幅度,这也是因为增加缓存只能降低I/O代价,而无法降低字符串之间编辑距离的计算次数.Page11图7Top-k查询处理性能与k值大小的关系(16MBbuffer)图8Top-k查询处理性能与缓存大小的关系6.5连接操作性能分析本部分测试RM树处理字符串相似性连接的效率,缓存大小设为16MB.直接使用Title和Author进行相似性连接会产生过多的连接结果(与原始数据同量级),为了控制生成结果的大小,本部分实验使用的数据集合为Title和Author的子集.实验分别从Title和Author中抽取的105条字符串与5×105条字符串,作为测试数据.如图9所示,在Title和Author中,随着编辑距离阈值的增加,RM图9连接操作性能与编辑距离的关系(16MBbuffer)树和Bed树处理字符串相似性连接操作的时间开销也增加.在Title和Author中的测试结果显示,RM树在处理连接操作时,性能优于Bed树,RM树降低了29%~41%的查询处理延时.6.6索引构件时间本部分测试了RM树索引构建时间,分别测试了不同缓存大小情况下,使用Title和Author两个数据集合构建RM树的时间开销.其中,Title数据集中包含1644932条字符串记录,Author数据集包含967810条字符串.如图10所示,RM树在Title和Author中的构建时间都长于Bed树的构建时间.通过加大缓存,可以减少RM树的构建时间,但是减小的幅度小于Bed树的减小幅度,这是因为RM树在插入节点选择、节点划分过程中需要大量计算,加大缓存只能减少磁盘读取时间,无法减少计算时间.Bed树构建过程中计算次数远小于RM树,因此可以通过加大缓存的方法有效地减少构建时间开销.虽然RM树的构建时间长于Bed树,但是RM树在处理查询和连接操作时,效率均优于Bed树,因此一次性的构建过程不影响RM树的有效性.图10索引构建性能与缓存大小的关系(16MBbuffer)6.7合成数据上的测试结果本文在人工合成的数据集合中测试了RM树的性能.人工合成数据集合包括Author和Title中的字符串,以及随机修改其中字符串内容所得的合成数据.对Author和Title中的每个字符串,我们随机修改若干字符,生成与原有字符串的编辑距离为1~5的合成数据.合成数据的大小是原有数据大小的6倍,在合成数据上建立的索引大小为3.1GB,超过了内存的大小.本部分实验使用的缓存大小为16MB.由图11可见,RM树在合成数据集合中处理范围查询的I/O开销和时间代价随编辑距离增加而变大.增加编辑距离阈值导致更多的索引节点被访问,这与真实数据集合上的实验结果一致.图12描述了RM树在合成数据集合中处理top-k查询的性能.RM树处理top-k查询的I/O代价和时间开销随查询参数k增长.当k的取值在1~4时,查询代Page12价增长非常缓慢.当k的取值为8时,查询代价显著大于k值为1,2和4时的查询代价.这是由于合成数据集合中,对于每个字符串s,都存在与之编辑距离为0~5的字符串数据.因此,获取与之最近的1个,2个和4个字符串不需要访问大量节点,而只需访问与s存储位置相近的叶子节点即可.当k=8时,查询结果中包含与s的编辑距离较大的字符串,因此查询处理将访问大量的索引节点,造成较大的查询代价.如图11和图12所示,在人工合成数据集合中,RM树的性能也优于Bed树,降低了查询的I/O代价,并减少了35%~50%的时间开销.图12Top-k查询处理性能与k值大小的关系7相关工作现有研究工作设计了多种字符串相似性度量指标,并基于这些度量指标进行字符串相似性操作.本文主要使用编辑距离度量字符串的相似性,因为它不需要对语言理解的直观度量.文献[1]设计了计算两个字符串s1和s2之间编辑距离的算法,其时间复杂度和空间复杂度都是O(|s1||s2|),|s1|和|s2|分别为字符串s1和s2的长度.其后续研究工作将提高计算编辑距离的效率或者通过近似计算降低时间代价[2-4].现有基于编辑距离的字符串相似性操作的工作主要使用q-Gram和倒排索引结构,将字符串相似性转换为两个Gram集合的相似性.这些工作针对相似性查询和相似性连接操作,使用filter-verify框架.它们首先通过过滤技术构建结果候选集合,然后计算相应的编辑距离,得到最后的结果.文献[5]针对字符串相似性连接操作,提出了counting-filter、positional-filter和length-filter技术,用于识别连接操作的候选集.其它过滤技术包括prefix-filter[8],mismatch-filter[9]等.文献[6-7]使用堆来合并多个Gram对应的倒排链表,从中选取相似性操作结果的候选集合.文献[10]通过去除部分Gram的倒排链表并改变过滤条件来减少空间代价.文献[11]研究字符串索引的增量式更新方法.以上方法在处理大量字符串数据时,有以下劣势:(1)空间代价巨大,Gram对应的倒排表大小与原始数据大小相当;(2)更新代价大,对一个字符串的更新引起多个Gram链表的更新.(3)支持查询类型有限,无法直接支持top-k等复杂查询.与上述工作不同,本文设计的RM树在磁盘上索引字符串数据,支持多种字符串相似性操作,减少了数据更新代价,并避免了存储Gram对应的倒排表所需昂贵的存储代价.现有处理字符串相似性操作的树形索引包括MHR树[12]和Bed树[13].其中,MHR树用于处理谓词中包括空间条件和字符串相似性条件的搜索.MHR树在R树节点中加入字符串集合的Min-Hash签名,支持近似地空间字符串相似性搜索,并可以估计查询的选择度大小.文献[13]提出了Bed树,Bed树将字符串排序后存储在B+树中,减少了q-Gram结合倒排索引引起的空间代价和更新代价,并能支持多种相似性操作.然而,一维的排序无法有效的将字符串按照相似性聚类,不能有效减少查询处理的I/O代价.本文设计RM树,通过字符串的Gram向量进行聚类,并使用节点中存储的Bitmap进一步过滤,以此减少字符串相似性操作的I/O代价.8结论本文提出了一种支持字符串相似性处理的树形索引RM树,RM树通过字符串的Gram向量将相似的字符串组织到相近的叶子节点中,并使用位图作为过滤工具,能够有效地支持字符串相似性范围查询、top-k查询和相似性连接操作.本文给出了RM树的构建方法、范围查询处理、top-k查询处理和连接处理算法.在真实数据上的实验结果表明,与Bed树相比,RM树在处理各种字符串范围查询、top-k查询和连接操作时有效地降低了磁盘I/O操作次数,并分别将时间开销降低了25%~59%、21%~39%和29%~41%.在人工合成的数据集合上,与Bed树相比,RM树减少了35%~50%的查询处理时间开销.真实数据集合和人工合成数据集合中的实验结果验证了RM树的有效性.Page13
