Page1一种针对Camellia的改进差分故障分析赵新杰1)王韬1)郭世泽2)1)(军械工程学院计算机工程系石家庄050003)2)(北方电子设备研究所北京100083)摘要查找S盒是分组密码设计中的一种重要操作,也是防御传统线性和差分分析的有效手段,但是当考虑到密码实现泄露的物理效应信息时,其却成为了密码系统最脆弱的一部分.文中对使用S盒的分组密码故障攻击进行了研究,给出了一种针对Camellia的改进差分故障分析方法.首先,将针对使用S盒的分组密码差分故障分析归结为求解S盒输入和输出差分问题,给出了基本的差分故障分析模型并演化出了SPN和Feistel结构分组密码的差分故障分析模型.然后,提出了针对Camellia的改进差分故障分析方法,对攻击复杂度进行了分析,并通过仿真实验进行验证.结果表明,由于扩散函数的可逆性和Feistel结构,Camellia易遭受深度差分故障分析,16次和24次故障注入即可分别恢复Camellia-128和Camellia-192/256主密钥.最后,分析了密码设计中的查找S盒操作和针对密码实现物理效应的攻击之间的矛盾,并讨论了分组密码故障攻击可能的发展趋势.关键词Camellia;分组密码;差分故障分析;查找S盒;SPN结构;Feistel结构1引言1.1相关工作密码学由密码术和密码分析术两方面组成,密码术主要用来设计和发展一些基于数学的算法、协议以保障信息安全,而密码分析术则是对这些算法和协议安全进行分析从而促进和提高密码术安全的学科.传统的密码分析将密码实现当成一种黑盒,通过观测密码实现的输入和输出,利用线性和差分数学分析方法去推测密钥.随着密钥长度和设计复杂度的增加,密码算法的安全性得到了很大提升,传统的数学分析已远远不能在有效时间和空间复杂度内完成攻击.然而在密码算法实现过程中,由于其实现需依附一个物理设备平台,加解密过程中会泄露出如时间[1]、故障[2]、功耗[3]、电磁[4]、声音[5]等额外物理效应信息,而这些物理效应和密钥紧密相关,可被用来进行密钥破解,利用这些物理效应信息进行的密码攻击国际上称之为“针对密码实现的攻击”,简称“实现攻击”(ImplementationAttack,IMA).目前大部分密码算法的实现安全性均遭此类攻击严重威胁,随着先进的测试仪器和计量手段的出现和发展,实现攻击已经具备实际攻击可行性.本文对Camel-lia分组密码的故障攻击技术进行了研究.Boneh等人于1996年率先提出了故障攻击[2],并用这种方法成功攻破了RSA签名算法.之后,Biham和Shamir将这种攻击思想进行改进,在1997年提出了著名的差分故障分析方法[6],成功攻破了DES算法,为密码算法故障分析提供了思路.后来,研究者利用差分故障分析又分别提出了对ECC[7]、3DES[8]、AES[9-17]、Camellia[18-19]、ARIA[20]、CLEFIA[21-22]、SMS4[23-26]、MIBS[27]、RC4[28-29]、Trivium[30-31]等其它密码算法的攻击手段及相应的对策.可见不论是公钥密码算法、分组密码算法还是流密码算法,无一幸免,都面临着故障攻击的严重威胁.Camellia[32]是由NTT和Mitsubishi电子公司在2000年联合提交的一个分组密码,2003年被选择成为欧洲NESSIE计划[33]的获胜者,2005年被选择成为XML安全URIs[34]、SSL/TLS密码套件集[35]、IPsec[36]等的IETF标准算法.2009年3月,Camellia被集成到OPENSSL-1.0.0-beta1[37]密码库中,2009年5月Camellia的CTR模式、CCM模式被IEFT标准化成为RFC5528,2009年6月IEFT标准OpenPGP协议加入Camellia算法成为RFC5581,2009年7月加入成为Linux2.4和2.6内核IPsec的一部分,其影响力越来越大.近年来,各国的密码研究结构对其安全性进行了大量的分析,在Camellia故障分析方面的主要进展如下:周永彬等[18]提出了一种针对Camellia的故障攻击方法,将Shamir针对DES的差分故障分析方法[6]引入到Camellia中,通过在Camellia第r轮左寄存器导入1个随机单字节故障恢复第r轮1个等效轮密钥字节,理想情况下,64个和96个故障可分别恢复Camellia-128和Camellia-192/256主密钥.由于在相同字节位置连续导入两次故障方可恢复一个等效轮密钥字节,恢复一轮64位等效轮密钥需至少注入16次单字节故障,恢复Camellia-128主密钥需注入64次故障获取后4轮等效轮密钥,恢复Camellia-192/256主密钥需注入96次故障获取后6轮等效轮密钥.对于使用和不使用FL/FL-1混淆层的Camellia算法,该故障分析方法均适用,但实际情况下,由于注入故障字节位置的随机性,应用该方法比理论上需要更多的故障注入次数.李玮等[19]也对Camellia进行了故障分析,通过在Camellia第r-1轮P混淆层前导入1个单字节故障恢复第r轮多个等效轮密钥字节,通过在Camellia加密倒数2~7轮分别注入多次单字节故障,共30次故障注入可恢复Camellia-128和Camellia-192/256主密钥.文献[19]的单字节故障模型并没有涵盖将故障注入到第r-1轮左寄存器这种情况,如果单字节故障被注入到第r-1轮左寄存器中,由于第r轮右寄存器中存在单字节故障,其分析方法并不直接适用;另外,其认为恢复Camellia-128/192/256均需获取后6轮等效轮密钥,对于攻击使用了FL/FL-1混淆层的Camellia算法,由于在倒数第7轮注入的故障经过FL/FL-1混淆层传播后会变得十分杂乱,其分析方法将会失效,导致无法获取倒数第6轮等效轮密钥,因此根据其论文描述,其攻击仅适用于没有使用了FL/FL-1混淆层的Camellia算法,而在实际分析中我们发现,恢复Camellia-128主密钥仅需获取最后4轮等效扩展密钥即可,这点在文献[18]中也得到认同.1.2本文的贡献本文对Camellia抗故障攻击安全性也进行了独立的研究工作,初步研究结果已被国际密码协会在线电子读物eprint收录为2009/585报告[38].同样基于Camellia第r-1轮P混淆层前导入1个随Page3机单字节故障模型,本文提出了一种文献[18]的Camellia改进差分故障分析方法,16次和24次故障注入即可分别恢复Camellia-128和Camellia-192/256主密钥,降低了攻击所需故障注入次数,提高了密钥分析效率.同文献[19]相比,本文的故障模型涵盖了其故障模型,第r-1轮左寄存器是否导入单字节故障均可;我们将所有针对使用S盒的分组密码故障分析归结为求解S盒输入差分和输出差分问题,攻击者在对每轮等效轮密钥进行分析时,只需关注求解该轮S盒输入和输出差分即可,简化了差分故障分析的过程;在对Camellia主密钥进行分析表1本文方法和现有Camellia故障分析工作比较Camellia密钥长度分析方法Camellia-128Camellia-128Camellia-128Camellia-192/256文献[18]第13~18轮左寄存器Camellia-192/256文献[19]第11~17轮P函数输入(左寄存器输入无故障)Camellia-192/256本文4.4节第11~17轮P函数输入(左寄存器有无故障均可)×Camellia-192/256本文4.4节第12~17轮P函数输入(左寄存器有无故障均可)1.3结构组织本文结构组织如下:第2节给出故障攻击原理和Camellia算法介绍;第3节给出通用的差分故障分析模型;第4节提出针对Camellia的改进差分故障分析方法,对攻击复杂度进行理论分析,并通过软件仿真实验进行验证;第5节分析传统密码设计中的查找S盒操作和针对密码实现物理效应的攻击之间矛盾,并讨论针对使用S盒的分组密码故障攻击可能的发展趋势;第6节为结束语.2相关知识2.1故障攻击故障攻击一般由故障诱导(也称故障植入)和故障分析两部分组成.故障诱导的主要工作是在某个合适的时间将故障注入密码运行中的某中间状态位置,其技术实施和实际效果严重依赖于攻击者的工作环境与所使用的设备.常用的故障诱导条件包括电压、时钟、温度、辐射、强光、涡流等因素的突然变化等.故障分析的主要内容是利用错误的结果,使用特定的分析方法恢复出全部或部分密钥信息.故障分析依赖于密码系统设计与实现、密码算法规范、所诱导的故障类型,并且在大多数条件下,故障分析都会同传统的密码分析方法相结合.典型的故障分析方法包括差分故障分析(DifferentialFaultAnalysis,时,我们认为,恢复Camellia-128主密钥只需得到最后4轮等效扩展密钥即可,并给出了具体的主密钥恢复算法,本文的故障分析方法直接适用于攻击使用和未使用FL/FL-1混淆层的Camellia-128算法以及未使用FL/FL-1混淆层的Camellia-192/256算法,此外,本文故障模型同文献[18]中故障模型结合,也可适用于攻击使用FL/FL-1混淆层的Camellia-192/256算法;最后,结合Camellia密码差分S盒和P函数扩散度特性,对攻击复杂度进行了分析,并通过仿真实验进行了验证.本文方法和现有Camellia故障分析工作比较见表1.故障位置DFA)[6]、碰撞故障分析(CollisionFaultAnalysis,CFA)[12]、不可能故障分析(ImpossibleFaultAnal-ysis,IFA)[29]、浮动故障分析(FloatingFaultAnalysis,FFA)[30]等.在分组密码故障分析方面常用的分析方法是Biham和Shamir在1997年提出的差分故障分析,分析对象主要为S盒查表操作.本文主要对Camellia分组密码差分故障分析方法进行研究,故障诱导的问题不是本文的主要研究对象,其在很多文献中都有讨论,如文献[39],本文在此不再赘述.2.2Camellia算法对Camellia算法的完整介绍可参考文献[32-33],下面仅对本文中用到的Camellia算法特性进行描述.加密过程.Camellia是一个迭代型分组密码,分组长度为128bits,支持128,192和256bits3种规模的密钥长度,采用Feistel整体结构.为提高安全性,在第一轮前和最后一轮后分别做前期和后期白化,即子密钥加,同时每隔6轮增加一个不规则轮,即FL/FL-1混淆函数层.设Lr和Rr为第r轮输入,则轮变换可表示为其中kr为第r轮的子密钥,F=PS为轮函数,S和P定义如下:S:F64l1(8)‖l2(8)‖l3(8)‖l4(8)‖l5(8)‖l6(8)‖l7(8)‖l8(8)→Page4l1(8)‖l2(8)‖l3(8)‖l4(8)‖l5(8)‖l6(8)‖l7(8)‖l8(8)l1=s1(l1),l2=s2(l2),l3=s3(l3),l4=s4(l4),l5=s2(l5),l6=s3(l6),l7=s4(l7),l8=s1(l8).P:F64z1(8)‖z2(8)‖z3(8)‖z4(8)‖z5(8)‖z6(8)‖z7(8)‖z8(8)→z1(8)‖z2(8)‖z3(8)‖z4(8)‖z5(8)‖z6(8)‖z7(8)‖z8(8)z1=z1z3z4z6z7z8,z2=z1z2z4z5z7z8,z3=z1z2z3z5z6z8,z4=z2z3z4z5z6z7,z5=z1z2z6z7z8,z6=z2z3z5z7z8,z7=z3z4z5z6z8,z8=z1z4z5z6z7密钥扩展算法.首先由初始种子密钥和64位常量Σi(i=1,2,…,6)经过几个轮函数F生成4个128位变量KL、KR、KA和KB,KA和KB生成过程如图1所示.白化层子密钥kwi(64)、普通轮密钥ki(64)、FL/FL-1函数层子密钥kli(64)均由KL、KR、KA和KB循环移位而成,详见文献[32-33].3差分故障分析模型为增强分组密码抗线性和差分分析能力,现代分组密码大都使用S盒查表操作提高密码非线性度,同时使用S盒查找表访问Cache又可提高算法软件实现执行效率,但是恰恰是由于差分S盒的分布特性,导致其面临严重的故障攻击威胁.假如在分组密码查表时,在最后一轮对未知查表输入值a导入随机字节故障f,一般来说,攻击者可得到密文差分字节f,且满足通过一定分析可获取最后一轮S盒输入值a,该值常同扩展密钥紧密相关,结合密文可获取相关扩展密钥.a求解方法如下,假设a为一个8位字节,根据f值是否为已知可将a求解问题分为下面两种情况:(1)f已知.这种情况常适用于Feistel结构分组密码故障分析,分析方法比较简单.以Camellia最后一轮故障攻击[18]为例,在Camellia加密最后一轮左寄存器Lr-1导入单字节故障f,故障传播如图2所示.易见,通过对密文差分进行分析可得到最后一轮查找S盒的输入和输出差分,故障位置也可直观得到.将a(a=L0式(3),满足等式的值作为a的有效候选值,由于S盒的雪崩性,对于给定的f和f,一般可得到a的2~4个候选值.由于L0半部分C0L.多次导入不同索引位置故障可恢复64位密aC0钥krkw3,然后通过在其它轮导入故障,经分析得到足够的相关密钥恢复初始主密钥.(2)f未知.这种情况常适用于SPN结构分组密码故障分析,由于S盒输入差分f未知,分析方法要稍显复杂.下面给出如何利用差分S盒分布特性求解输入差分f的方法.以ARIA为例,图3是ARIA的S盒和差分S盒(Δ=1)按照大小值递增的分布图,灰色方块表示覆盖到的值,白色方块表示没有覆盖到Page5的值,易见,ARIAS盒覆盖到了所有256个候选值,而差分S盒没有完全覆盖,仅有127个左右.如果经故障导入后得到的S盒输出差分f恰好为白图3ARIAS盒和差分S盒值(Δ=1)按大小值递增分布一般来说,在SPN结构分组密码第r-1轮P函数前注入单字节故障f,经P变换f可扩散至m个故障字节(m>1),且这m个字节差分均和f线性相关(大部分情况这m个字节差分均相同,如ARIA分组密码),可用f的线性函数Li(a,f)表示(1im),再经第r轮查找S盒运算和白化操作,得到m个错误密文差分,通常也是第r轮查找S盒输出差分.图4为ARIA分组密码第r-1轮P函数前单字节故障传播图,易见P函数线形扩散度m=7,第r轮S盒输入差分f共有255个(非0),首先为每个输入差分f利用Li(a,f)Li(a,0)计算m种差分S盒(每个差分S盒256个元素),然后检查这m个S盒输出差分是否同时位于其对应的差分S盒中,只有这m个输出差分均同时位于其对应的差分S盒中,f值保留,否则可排除掉f,通过255次迭代分析得到有限的f候选值.一般来说,基于差分S盒的分布特性,对于扩散度为m的P函数,f经排除分析后可大约得到255×2-m个候选值.这样,SPN结构分组密码的f未知故障分析问题可转化为f为有限解的Feistel结构分组密码故障分析问题,经分析得到a和S[a],显然扩展密钥kr的m个字节可通过分析S[a]和密文得到.多次导入不同位置故障可恢复kr,然后通过在其它轮导入故障,经分析得到足够的相关密钥恢复初始主密钥.色方块的值,则可以断定输入差分不为1,这样就得到了SPN结构下利用差分S盒分布特性求解输入差分f的一种简便方法.我们认为,对于使用S盒的分组密码故障分析,可抛开密码总体设计结构,将其归结为求解S盒输入和输出差分的问题,该方法有如下特点:(1)基于不同故障模型条件下,通过分析分组密码故障传播过程,观察某轮S盒输入和输出差分是否可求解,可以验证对该分组密码故障分析的可行性.(2)如果可行,通过结合算法S盒和P扩散函数特性对S盒输入、输出差分个数以及单次故障注入可恢复密钥字节个数进行精确分析,就可以得到恢复每轮相关扩展密钥所需的故障注入次数;然后通过分析密钥扩展算法得到恢复主密钥所需相关扩展密钥的轮数,最终得到恢复主密钥所需的理论故障注入次数.Page64Camellia改进差分故障分析4.1基本假设和符号标记基本假设:(1)攻击者每次诱导中间变量值的存储单元发生任意单字节错误,但故障字节索引和故障差分未知.(2)对于同一个选定明文P,攻击者可得到在同一个密钥K作用下的正确密文C和错误密文C.(3)攻击所需的满足理想故障模型下的错误密文样本可预先得到.如何精确地注入故障不是本文的研究重点,本文假定攻击者具备从大量的错误密文样本中找出攻击所需的理想错误密文样本的能力.(4)在一次成功的攻击过程中,加密主密钥不变.符号标记:(1)kr:第r轮扩展密钥.(2)Kr:表示第r轮等效扩展密钥[18],常为后白化密钥和第r轮扩展密钥的异或结果.对于Camellia-128来说,K18=k18kw3、K17=k17kw4、K16=k16kw3、K15=k15kw4.(3)Lr-1,Rr-1:第r轮64位左半部分和右半部分输入.(4)ΔILir,ΔIRir:第r轮左半部分和右半部分输入差分第i个字节(i∈[0,7]).(5)ΔOLri,ΔORri:第r轮左半部分和右半部分输出差分第i个字节(i∈[0,7]).(6)ΔSir,ΔPir:第r轮S函数和P函数的输出差分第i个字节(i∈[0,7]).(7)ΔCLi,ΔCRi:密文左半部分和右半部分差分第i个字节(i∈[0,7]).4.2攻击基本思想故障模型.本文故障模型为在Camellia第r-1轮P函数输入前注入单字节故障,故障诱导位置分为A、B两种类型:A类型.第r-1轮左寄存器Lr-2的一个字节产生故障,此时第r轮的左右寄存器均产生故障;B类型.第r-1轮左寄存器Lr-2没有故障,但第r-1轮P函数输入产生单字节故障,故障诱导位置有3种可能:(1)对第r-1轮扩展密钥kr-1进行故障诱导;(2)对第r-1轮Lr-2同kr-1异或操作进行故障诱导;(3)对第r-1轮查找S盒输出进行故障诱导.故障攻击过程.1.对Camellia第r-1轮进行故障诱导,推断第r轮等效扩展密钥Kr.(a)选择明文P,经加密获取该明文对应的正确密文C.(b)选择同样的明文P,在加密过程中对第r-1轮进行单字节故障诱导,获取错误的密文C.(c)使用差分故障分析方法推断Kr的5~6个密钥字节.出来.(d)反复执行步骤(a)~(c),直至Kr所有字节均被恢复2.对Camellia第r-2轮进行故障诱导,推断第r-1轮等效扩展密钥Kr-1.(a)选择明文P,经加密获取该明文对应的正确密文C.(b)选择同样的明文P,在加密过程中对第r-2轮进行单字节故障诱导,获取错误的密文C.(c)使用差分故障分析方法推断Kr-1的5~6个密钥字节.复出来.(d)反复执行步骤(a)~(c),直至Kr-1所有字节均被恢3.同样的,使用上述相同方法对Camellia加密第r-3、r-4等轮进行故障诱导,推断Kr-2,Kr-3等对应轮等效扩展密钥.5.对预测的Camellia密钥正确性进行验证.4.通过对最后4轮等效扩展密钥Kr-3,Kr-2,Kr-1,Kr进行分析推断Camellia-128密钥,通过对最后6轮等效扩展密钥Kr-5,Kr-4,Kr-3,Kr-2,Kr-1,Kr进行分析推断Camellia-192/256密钥.4.3Camellia-128改进差分故障分析Camellia-128进行故障攻击的过程.本节将介绍根据4.2节攻击基本思想对在第17轮注入故障恢复犓18在Camellia-128第17轮P函数输入值注入单字节故障,以A类型第17轮左寄存器L16故障、B类型第17轮轮密钥k17故障为例,假设故障注入索引均为0,其故障传播过程分别如图5(a)和图5(b)所示.K18的具体恢复方法如下:(1)确定故障注入索引位置.不同索引位置的第17轮P函数输入故障会使得密文产生不同位置的故障,具体来说,CL会受其影响产生不同位置的5~6个字节故障,而CR的8个字节均会产生故障.第17轮P函数输入不同单字节故障索引和CL的故障字节索引关系如表2所示.可见故障索引位置为0~3时,CL均产生5个字节故障,故障索引位置为4~7时,CL均产生6个字节故障.Page7图5Camellia第17轮故障传播图第17轮P函数输入故障字节索引CL故障字节索引5~6个故障字节.(2)计算第18轮S盒输入差分ΔIL18.显然,ΔIL18等于密文左半部分差分ΔCL,其有(3)计算第18轮S盒输出差分ΔS18.第18轮的左半部分输出差分ΔOL18可通过密文右半部分差分ΔCR得到.对于A类型故障模型,ΔOL18的8个非0字节等于ΔS18的5~6个字节经P函数变换结果同ΔIR18的1个字节的异或结果值,ΔS18可表示为ΔS18=P-1(ΔOL18ΔIR18)=P-1(ΔCRΔIR18)ΔS18可由下面两种方法进行恢复:方法1.将ΔIR18的1个字节所有候选值代入式(4)并进行P-1变换,如果得到的ΔS18值的非0索引值和表2中的ΔCL对应非0索引值相同,其它2~3个索引值均为0,则可求解出ΔIR18的1个故障字节同ΔS18的5~6个故障字节值,实验中发现只有1个ΔIR18候选值满足上述条件.方法2.通过求解ΔOL18的8个方程,可得到ΔS18的5~6个非0字节和ΔIR18的1个非0字节值.例如当故障索引为0时,ΔS0ΔS718,ΔIL0ΔOL0ΔOL1ΔOL2ΔOL3ΔOL4ΔOL5ΔOL186=ΔS2ΔOL7Page818=ΔOL218=ΔOL518=ΔOL118=ΔOL118=ΔOL3ΔS0ΔS1ΔS2ΔS4ΔS7ΔIL0方法1的求解过程比较通用,8种不同位置的故障分析均可使用P-1函数和ΔIR18的1个字节有限候选值经分析判断得到;方法2则需为每种位置的故障分别求解8个方程,其本质和方法1相同.对于B类型故障模型,第18轮P函数输出差分ΔP18=ΔOL18,由于第18轮右寄存器没有故障导入,ΔS18=P-1(ΔCL),求解十分简单.(4)恢复K18.通过步(2)和(3)分析可得到第18轮S盒输入差分ΔIL18和输出差分ΔS18,应用第3节Feistel结构分组密码故障分析模型,可恢复第18轮5~6个S盒索引字节Likiw3=Ciw3(i=0,1,2,4,7)可被恢复出来.通过多次在kiCamellia-128第17轮P函数输入值其它索引位置注入单字节故障,应用上面的分析方法,可获取K18全部字节值.在第16轮注入故障恢复犓17在Camellia-128第16轮P函数输入注入单字节故障,故障索引为0,A类型故障传播过程如图6所示.K17的具体恢复方法如下:(1)计算第17轮输出差分ΔIL18和ΔIR18.第17轮左半部分输出差分ΔIL18等于ΔCL,结合前面求解K18和密文,可求解第17轮右半部分输出差分ΔIR18.ΔIR18=ΔCRP(S(L17k18))P(S(L17k18))=ΔCRP(S(CLK18))P(S(CLK18))(2)确定故障注入索引位置.显然,求解出ΔIR18值后,可根据ΔIR18非0字节位置,并参考表2推断第16轮P函数输入故障字节索引.(3)计算第17轮S盒输入差分ΔIL17.显然,ΔIL17等于前面求解的ΔIR18.(4)计算第17轮S盒输出差分ΔS17.第17轮的左半部分输出差分ΔIL18可通过密文左半部分差分ΔCL得到.对于A类型故障模型,ΔIL18的8个非0字节等于ΔS18的5~6个字节经第17轮P函数变换结果同ΔIR17的1个字节的异或结果值,ΔS17可表示为ΔS17=P-1(ΔIL18ΔIR17)=P-1(ΔCLΔIR17)应用前面两种方法可求解ΔS17和ΔIR17.(5)恢复K17.通过步(3)和(4)分析可得到第17轮S盒输入差分ΔIL17和输出差分ΔS17,应用第3节Feistel结构分组密码故障分析模型,可恢复第17轮5~6个S盒输入索引字节LiL16P(S18)kw4=CR,S18=S[CLK18],CL和K18已知,则5~6个密钥字节Ki1,2,4,7)可被恢复出来.多次在Camellia-128第16轮P函数输入其它索引位置注入故障,应用上面的分析方法,可获取K17全部字节值.Page9在第15轮注入故障恢复犓16,在第14轮注入故障恢复犓15应用前面方法通过在第15轮注入故障恢复K16,在第14轮注入故障恢复K15.分析的关键在于利用前面密钥分析结果去计算攻击轮的S盒输入和输出差分,然后结合第3节故障分析模型去恢复等效轮密钥.恢复Camellia-128主密钥通过故障分析可获取最后4轮等效扩展密钥K15,K16,K17,K18,结合Camellia算法设计文档,可表示为K18=(KA<<<111)L(KL<<<111)RK17=(KA<<<111)R(KL<<<111)LK16=(KA<<<111)L(KA<<<94)RK15=(KA<<<111)R(KA<<<94)K18‖K17=(KA<<<111)(KL<<<47)K16‖K15=(KA<<<111)(KA<<<30烍烌(K16‖K15)<<<17=KA(KA<<<47)KL=((K18‖K17)>>>47)(KA<<<64烍烌根据式(8)可推断出128位变量KA(KA<<<47),然后根据下面算法可恢复KA.犓犃恢复算法.SearchingKA(SK,C)unsignedcharKP[128],cTempSK←Foreachifrom0x00to0x01{KP[0]←iForeachjfrom0to127{}应用上面的算法,最多可得到2个KA候选值,甚至可得到唯一KA值,结合式(8)可恢复初始主密钥KL.验证Camellia-128主密钥通过对相同明文利用预测密钥加密,同采集的正确密文比较验证Camellia-128主密钥KL正确性.4.4Camellia-192/256改进差分故障分析恢复犓13,犓14,犓15,犓16,犓17,犓18对Camellia-192/256的改进差分故障分析方法同Camellia-128类似.需要说明的是,对于攻击没有使用FL/FL-1混淆函数层的Camellia-192/256算法,应用4.3节方法可直接恢复K13,K14,K15,K16,K17值.但是对于使用FL/FL-1混淆函数层的Camellia-192/256算法,由于FL/FL-1混淆函数层的存在,在第12轮注入单字节故障经FL/FL-1混淆函数层传播到第13轮时,故障传播变得十分复杂,很难进行分析,因此应用4.3节方法通过在第13~17轮注入单字节故障,可恢复K14,K15,K16,K17,K18字节,同时应用第3节在第13轮注入单字节故障恢复第13轮单个等效轮密钥方法(也可参考文献[18]方法)可恢复K13值.恢复RetrievetheinitialCamellia-192/256key结合Camellia算法设计文档,K13,K14,K15,K16,K17,K18可表示为K18=(KB<<<111)L(KL<<<111)RK17=(KB<<<111)R(KL<<<111)LK16=(KB<<<111)L(KA<<<94)RK15=(KB<<<111)R(KA<<<94)LK14=(KB<<<111)L(KR<<<94)RK13=(KB<<<111)R(KR<<<94)K18‖K17=(KB<<<111)(KL<<<47)K16‖K15=(KB<<<111)(KA<<<30)K14‖K13=(KB<<<111)(KR<<<30KAKR=((K16‖K15)(K14‖K13))>>>30KB=F(F((KAKR),Σ5(64)),Σ6(64))KL=(K18‖K17)>>>47(KB<<<64根据式(9)可直接恢复KAKR,由于KAKR和常量Σ5,Σ6为已知,根据Camellia-192/256密钥扩展算法(也可参考图1),可计算出KB,然后进一步得到KL和KR值,最终得到Camellia-192/256主密钥.4.5攻击复杂度分析受攻击者能力限制,精确地注入故障分析所需的理想深度和宽度的故障十分困难,所以故障攻击所需样本量下限分析显得十分重要.下面,我们将对本文改进故障分析方法攻击复杂度进行分析:(1)单字节S盒输入和输出差分密钥分析效率分析以在Camellia-128最后一轮注入单字节故障为例,如图2所示,故障分析需满足下式:Page1017k0S[L0L017k0w3=C0k018k0S[C0K0结合S0盒特性,将C0,ΔIL0所有候选值代入式(10),可得满足上式的K0计分析表,如表3所示.Camellia算法使用了S0,S1,S2,S34种S盒,其它3种S盒的故障分析效率同S0盒相同.可见,单个S盒字节经1次故障分析可将K0个,两次故障注入即可以高达98.8%的概率恢复唯一的K0k数目出现次数出现概率2164505600.98441.96884总数167116801(2)第4节改进差分故障攻击密钥恢复效率分析第r-1轮注入单字节故障索引i和恢复的第r轮等效扩展密钥Kr字节索引值j的关系如式(11)所示,Mij=1表示i对应的Kr第j个字节可被恢复出来.易见,i∈[0,3]时,一次可恢复5个Kr字节,i∈[4,7]时,一次可恢复6个Kr字节,至少3次故障注入可对Kr的8个字节均分析两次,则可以说,至少3次故障可恢复一轮等效扩展密钥.在对S盒同一索引字节位置故障进行两次分析可获取1个字节的S盒输入索引前提条件下,将故障注入次数n和故障注入索引所有可能值利用式(10)进行穷举统计分析,可得到故障注入次数和直接恢复Kr的成功率统计,见表4.表4故障注入次数和直接恢复犓狉成功率的关系故障注入次数n成功次数所有次数成功率/%345678163783761677721697.62将故障注入次数、故障注入索引所有可能值、表3中单字节故障密钥分析效率统计值利用式(10)进行穷举统计分析,可得到故障注入次数n和Kr平均搜索空间的成功率统计,见表5.可见,如果n次故障索引均不重复,4次故障注入理论上即可将Kr平均密钥搜索空间降低到25.446.表5故障注入次数犿和犓狉平均密钥搜索空间的关系故障注入次数n3504178.07512131759.97456720971442.24209715233.428167772081.11167772164.4854.6实验结果比较与分析在普通PC机(CPU为Athlon643000+1.81GHz,内存为1GB)上使用C++语言编程实现了本文给出的Camellia故障攻击,其中故障诱导过程是通过计算机软件模拟的.Camellia-128故障攻击的一组数据见附录A.首先给出在Camellia第r-1轮P函数输入值注入单字节故障恢复Kr的实际数据统计,图7为5万次故障攻击中不同故障注入次数n的Kr平均密钥搜索空间统计,可以看出,该实际攻击值同表5理论值基本一致.图7不同故障注入次数时Kr平均密钥搜索空间统计图8为5万次故障攻击中不同故障注入次数n对应的K18平均密钥空间频率统计,可以看出,实际攻击中K18候选值为1的出现频率和表4基本一致,当n4时,K18密钥候选值个数大部分情况下均在8个以内.图9为5万次故障攻击中对直接成功恢复Kr所需故障注入次数出现的频率统计,可以看出当n4时,就能以34.6%的概率直接恢复Kr.攻击恢复Camellia-128和Camellia-192/256主密钥所需样本量如前面表1所示.对于攻击使用和没有使用FL/FL-1混淆函数层的Camellia-128Page11图8不同故障注入次数时Kr平均密钥空间出现频率统计图9成功恢复Kr所需故障注入次数出现频率统计算法,在第14~17轮每轮注入4次单字节故障共16次故障注入,应用4.3节方法即可恢复128位主密钥.对于攻击没有使用FL/FL-1混淆函数层的Camellia-192/256算法,在第12~17轮每轮注入4次单字节故障共24次故障注入,应用4.4节方法即可恢复Camellia-192/256主密钥;但是对于使用FL/FL-1混淆函数层的Camellia-192/256算法,由于FL/FL-1混淆函数层的存在,在第12轮注入单字节故障经FL/FL-1混淆函数层传播到第13轮时,故障传播变得十分复杂,很难进行分析,因此应用4.3节方法通过在第13~17轮分别注入4次单字节故障,可基本恢复后5轮扩展密钥字节,同时在第13轮注入12次单字节故障,应用第3节方法可恢复K13值.同现有故障攻击相比,本文方法具有以下特点:(1)同文献[18]和文献[19]相比,本文故障模型中故障宽度同其相同,均基于单字节故障模型,故障索引位置和故障值未知.(2)同文献[18]在第r轮左寄存器注入单字节故障恢复Kr的1个字节不同,本文的故障注入位置比文献[18]要深,单次故障注入恢复的密钥字节数要多,1次第r-1轮单字节故障分析可恢复Kr的5~6个密钥字节,将文献[18]密钥分析效率提高了5~6倍.此外,本文故障攻击模型比文献[18]要广,可适用于对第r-1轮扩展密钥进行故障攻击等情况,而文献[18]方法仅适用于对第r轮左寄存器故障进行密钥分析,并不适用于对第r轮扩展密钥注入故障等情况进行密钥分析(第r轮S盒输入差分无法求解).(3)本文故障模型深度同文献[19]相同,但故障位置适用范围要广,文献[19]中故障模型并没有涵盖将故障注入到第r-1轮左寄存器这种情况,如果单字节故障被注入到第r-1轮左寄存器中,由于第r轮右寄存器中存在单字节故障,其分析方法并不直接适用,而本文故障模型则涵盖了在Camellia第r-1轮P函数输入注入故障的所有情况;另外,文献[19]认为恢复Camellia-128/192/256均需获取后6轮等效轮密钥,对于攻击使用了FL/FL-1混淆层的Camellia算法,由于在倒数第7轮注入的故障经过FL/FL-1混淆层传播后会变得十分杂乱,其分析方法将会失效,导致无法获取倒数第6轮等效轮密钥,因此根据其论文描述,攻击仅适用于没有使用FL/FL-1混淆层的Camellia算法,而本文故障分析研究则表明,恢复Camellia-128主密钥仅需获取最后4轮等效扩展密钥即可,并给出了具体的Camellia-128主密钥恢复算法,这点在文献[18]中也得到认同.5攻击讨论5.1传统密码查找S盒设计和实现攻击之间矛盾的分析在分组密码设计中,密码设计者常使用S盒来增加算法非线性度,并以此来抵御差分和线性密码分析.S盒对于防御传统的差分和线性分析确实十分有效,但当考虑到密码算法实现主动和被动泄漏的物理效应信息时,其面临了前所未有的挑战,S盒往往成为密码系统破解被突破的第一道防线.通常来说,S盒输入索引常和明文/密文、相关密钥、物理效应紧密相关,在采集到这些物理效应信息后,结合明文/密文信息和各种分析方法,即可快速恢复相关密钥信息.下面,我们将讨论利用物理效应信息和S盒进行分组密钥破解的典型攻击.(1)Cache计时攻击大量的分组密码设计采用S盒查表访问Cache提高软件实现效率,但是Cache访问命中和失效时间差异信息却恰恰构成了天然的Cache信息泄露源,而操作系统多线程共享Cache机制又为恶意线程监视密码线程Cache访问信息搭建了时间信息泄露隐通道.根据攻击者采集的时间信息不同,通常将Page12针对分组密码的Cache计时攻击分为时序驱动、访问驱动、踪迹驱动3种.在时序驱动攻击中,攻击者主要采集一次完整的加密时间,使用大量的样本来推断某次查找表是否发生Cache命中,并利用这些碰撞信息结合明文或密文信息预测密钥;在访问驱动攻击中,攻击者常使用一个恶意进程在加密前清空数据Cache,然后触发加密操作,之后通过对其私有数据访问的命中和失效信息推断加密过程中查找S盒访问的Cache组地址信息,并转化为查表索引信息,结合明文或密文信息预测密钥;在踪迹驱动攻击中,攻击者能够采集到每次查找S盒访问Cache的命中和失效序列信息,并结合明文或密文信息预测密钥.(2)差分旁路攻击在差分旁路攻击中,攻击者首先通过示波器、接收机等设备采集到加密过程中泄露的功耗和电磁信息,然后将密钥搜索空间分成多个子密钥块,将每个子密钥块的候选值同明文或密文信息结合,预测可能的查表Hamming重量或Hamming距离,并和真实的功耗或电磁曲线中的每个点进行相关性匹配,对于正确的密钥候选值来说,每条匹配曲线中常会出现尖峰,否则匹配曲线将会比较平坦.这样,S盒查表操作的非线性特性恰好构成了差分旁路分析中的天然区分器.(3)模板攻击在模板攻击中,攻击者首先使用已控制的密码设备,利用其加密过程中泄露的信号信息为每个子密钥块的所有候选值构建一个唯一的区分器,搭建好模板;然后采集到目标密钥设备加密过程中泄露的信号信息,并和前面搭建的模板进行相关性匹配,最匹配的模板对应的密钥候选值常为正确密钥.同样,S盒查表操作的非线性特性也恰好构成了模板攻击中的天然区分器.(4)差分故障攻击根据本文第3节分析可以发现,针对使用S盒的分组密码故障分析的主要研究对象就是S盒查表操作.只要在故障注入后,某轮S盒的输入和输出差分是已知或为有限值的,攻击者就可恢复S盒输入索引或查表结果,并用于相关密钥破解.由于S盒可提供很好的非线性度,对于256个元素的差分S盒来说,差分S盒的元素不能覆盖到所有的256个候选值,对于SPN分组密码,一旦攻击者根据密文差分获取到最后一轮查表的输出差分,并检查这些差分值是否位于某个差分S盒中,如果不在则可排除掉其对应的输入差分,这样可以得到有限的S盒输入差分值用于相关密钥破解;即使差分S盒的分布特性是完美的,即覆盖到所有的256个候选值,对于攻击Feistel结构分组密码,攻击者常可得到唯一的S盒输入和输出差分,那么此时可能直接就可获取到唯一的相关密钥值.综上,我们不难发现,S盒的非线性度已经成为针对密码实现物理效应攻击中的天然区分器,传统的密码设计和针对密码实现的攻击确实存在较大的矛盾,通过掩码、噪声随机化、多次校验等方法能够在一定程度上防御密码实现攻击,但所有的防御措施都是要以牺牲加密速度为代价的,所以如何在速度和安全性这一对矛盾的指标上进行平衡选择也是目前密码实现所面临的巨大挑战.5.2分组密码故障攻击现状和发展趋势分析通过对已发表的针对使用S盒的分组密码故障攻击文献进行分析,我们发现目前现有攻击本质上来说都是基于求解S盒输入和输出差分问题,然后基于各种故障模型结合SPN、Feistel等密码结构特性进行差分故障分析.下面我们将通过对现有文献分析,探讨分组密码故障攻击的可能发展趋势.(1)硬件攻击是趋势,攻击代价越来越小.从近年来对密码故障攻击专业会议———密码故障诊断与容忍FDTC会议2004年~2010年的统计来看,硬件故障攻击文章越来越多,硬件故障攻击的代价也由2000年初激光注入故障的几百万美元降低到目前使用“函数任意波形发生器”产生脉冲注入故障所需的3万元人民币,攻击的代价越来越小.(2)拓展故障宽度较实用.最初针对DES的故障攻击[6]中,故障宽度为1位,这主要由于DES是一个基于位进行置换的分组密码;后来在针对AES的故障攻击中,故障宽度也是1位,如文献[9].由于在实际故障攻击物理实验中,故障宽度一般很难精确控制,常为1个或多个字节,故之后大部分针对AES和其它分组密码的故障攻击中故障宽度均为基于1个字节,近年来,也逐渐出现了一些针对多字节故障的故障攻击,如文献[15-16].(3)延伸故障深度可提高攻击效率.最初故障攻击中,注入故障的深度一般比较浅,对于Feistel结构分组密码,攻击者常在第r轮查找S盒前注入故障来恢复第r轮相关密钥,如文献[18,21,23],后续逐渐出现了在第r-m轮(m1)注入故障的故障分析,如文献[22,24-27,38];而对Page13于SPN结构分组密码,攻击者常在第r-1轮P函数前注入故障来恢复第r轮相关密钥,如文献[10,20],随着差分故障分析研究的深入,故障深度得以加深,后续逐渐出现了在第r-m轮(m2)注入故障的故障分析,如文献[11,13-14].(4)组合故障分析.在实现攻击中,除了故障分析以外,还有计时分析、功耗分析、电磁分析方法,如果能将这3种方法和故障分析结合起来,可能会减少攻击所需样本量,提高分析效率;另外,随着新的数学统计分析理论的发展,新的分析方法同故障分析的结合,也是一个可能的发展方向.6结束语在故障攻击方面大体有3个研究方向:故障注入、故障分析、故障攻击检测与防护.本文主要对分组密码故障分析进行了研究,并通过软件仿真进行了验证,故障攻击硬件物理实验方面我们拟在后续研究工作中开展.本文给出了针对使用S盒的分组密码差分故障攻击通用模型,并由此演化出SPN和Feistel结构两种具体攻击模型,然后以Camellia分组密码为例,基于单字节故障模型,给出了一种改进的Camellia差分故障分析方法,对攻击复杂度进行了理论分析,并通过软件仿真实验进行了验证.实验结果表明,由于其Feistel结构和差分S盒特性,Camellia易遭受深度故障攻击,最好的实验结果为16次故障导入可恢复Camellia-128主密钥,24次故障注入可恢复没有使用FL/FL-1混淆层的Camellia算法,32次故障注入可恢复使用FL/FL-1混淆层的Camellia算法,本文中故障分析方法也可为其它分组密码差分故障分析提供一定思路.
