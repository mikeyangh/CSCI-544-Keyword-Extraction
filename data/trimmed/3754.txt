Page1低代价锁步EDDI:处理器瞬时故障检测机制王超1)傅忠传1)陈红松2)崔刚1)1)(哈尔滨工业大学计算机科学与技术学院哈尔滨150001)2)(北京科技大学计算机与通信工程学院北京100083)摘要随着ULSI工艺步入深亚微米时代,处理器内部组合逻辑的瞬时故障敏感性迅速提高,文中在设计初期将硬件寄存器纠检错能力和系统软件检错能力纳入考虑,兼顾处理器内组合逻辑、时序逻辑两类部件,设计应用级“低代价锁步EDDI(ErrorDetectionbyDuplicatedInstructions)”机制.创新如下:(1)提出基于概率论的故障漏检率量化估计方法,为纠检错与性能折中进行指导.以往的应用级检错机制在设计过程中并没有考虑到下层操作系统的检错能力,这会造成可靠性估计不足而带来性能损失.文中依照指令流经的部件将故障划分为不同子类,并将操作系统纳入考虑,提出基于概率论的故障漏检率量化估计方法,理论估计与故障注入结果拟合良好.(2)低代价锁步EDDI机制,结合硬件纠检错能力,兼顾处理器内组合逻辑和时序逻辑两类部件,大幅降低了性能代价.提出独特的低代价锁步指令复制规则,并通过编译链前端的寄存器分配,大幅减少了寄存器预留数,有效缓解了寄存器压力,降低了访存代价,提高了寄存器的性能.寄存器预留也保证了本机制无需修改编译器传参规则,无需重新编译系统库,提高了通用性.(3)采用单比特故障模型,基于SPARC体系结构,选取处理器中代表性部件:解码(DecoderUnit)单元、地址生成(AddressGENUnit)单元、算逻单元(ALU)进行故障注入,对低代价锁步EDDI实现代价进行详细评测.与全复制EDDI相比,低代价锁步EDDI仅以故障漏检率SDC(SilentDataCorruption)平均升高0.8%的代价,换取了动态执行指令数平均减少36.1%,执行时间平均降低35.2%的性能优势.关键词EDDI;故障漏检率;组合逻辑;瞬时故障;SEU1引言瞬时故障(transientfault),常被称为软故障(softerror),主要由宇宙射线和封装中的α粒子引发,通常导致器件暂时性失效或状态改变,不会产生物理性损伤.瞬时故障对于组合电路和时序电路的影响有所不同.α粒子或宇宙射线进入内存单元或动态寄存器,引发比特翻转(bit-flip)或不确定故障(indeterminationfault),一经锁存就会持续到重新写入或刷新.除此之外,还会诱发组合逻辑产生干扰脉冲[1].组合逻辑对此类脉冲虽有屏蔽能力,但随着特征尺寸的缩小、供电电压的降低和工作频率的提升,故障易感性将越发提升.文献[2]预计2011年组合逻辑故障易感性将会与时序逻辑持平,之后将超过后者.瞬时故障并非由设备内因引起,受环境因素影响较大,具有随机性,这无疑对诊断提出了挑战.2000年美国在线和ebay曾暂停服务,原因在于所使用的UltraSPARC-II服务器中的SRAM对瞬时故障防护不足[3].2005年LosAlamos国家实验室一台2048-CPU的惠普超级计算机因太空辐射引发的软故障频繁崩溃.Cypress半导体公司也在2004年公布了一系列瞬时故障事件[4].目前,硬件提供的瞬时故障纠检错机制主要有ECC、校验和.该类方法对时序逻辑瞬时故障行之有效,却无法覆盖组合逻辑.高端机型一般采用多模冗余或多机备份的方式对组合逻辑进行保护,如惠普的non-stop[5]、IBM高端大型机[6].但硬件代价是一般商用机型无法承受的.在这个方面,软件冗余以其灵活性和低硬件代价的特点格外具备竞争力.软件冗余一般通过在编译的前、后端增加组件自动实现冗余功能.主要包括增加控制流软件签名、复制指令备份数据以及软件EDAC等方式.实现的过程中,处处存在着可靠性与性能的折中,例如软件签名代价较低但是只对控制流有效,指令复制会导致内存占用翻倍,访存代价过高等.不同体系结构下,EDDI机制的移植工作也存在亟待解决的问题.例如,SPARC属窗口寄存器体系结构,具有独特的寄存器环结构,这与在ARM、MIPS等平面寄存器体系结构下的移植工作相比,机制的移植工作面临完全不同的问题与挑战.例如,编译器传参规则的修改,系统库的重新编译等工作,严重降低了机制的通用性.Page3基于以上分析,本文提出了一种软硬件混合的冗余方式———低代价锁步EDDI机制.期望最大化利用普遍使用的硬件纠检错机制,同时将处于应用层之下的系统软件纠检错能力(如段越界检查、非法指令检查等)纳入考虑,对指令复制机制进行裁剪和设计,以达到整个系统的可靠性与性能高效结合.本机制主指令与影子指令以锁步(lock-stepped)方式执行,以编译选项的形式集成在编译链后端,创新如下:(1)本文依照指令流经的部件将故障划分为不同子类,经过对每种子类故障详细分析给出基于概率论的故障覆盖率量化估计方法,为故障覆盖率与性能的折中提出指导.经实验验证,理论估计与故障注入结果拟合良好.(2)以往的应用级检错机制在设计过程中并没有考虑到下层操作系统的检错能力,这通常会造成可靠性估计不足而带来性能损失.在本机制设计初期将操作系统因素纳入考虑.(3)提出低代价锁步的指令复制规则和寄存器分配方式.锁步规则结合硬件纠检错机制,既兼顾组合逻辑、时序逻辑两类部件,又大幅降低了性能代价.同时,编译前端实现的寄存器分配方式,大幅减少了寄存器预留数、有效缓解寄存器压力,降低了访存代价.寄存器预留机制的引入也保证了机制实现无需修改编译器传参规则,无需重新编译系统库,提高了本机制的通用性.(4)实验验证阶段,选择单比特故障模型,在SPARC体系结构平台,选取处理器中代表性部件:解码(DecoderUnit)单元、地址生成(AddressGENUnit)单元和算逻单元(ALU)进行故障注入.本文第2节介绍国内外相关工作;第3节阐述故障覆盖率理论估计方法;第4节对低代价锁步EDDI机制进行描述;第5节介绍故障注入实验和性能测试并对结果进行分析;最后得出结论.2相关工作SIHFT(SoftwareImplementedHardwareFaultTolerance)采用软件手段实现硬件故障容错,源于美国斯坦福大学,并于1999年进行星载实验,引起广泛关注[7-9].SIHFT包括多种技术:针对存储系统故障提出的软件EDAC,针对处理器内瞬时故障引发控制流错误的CFCSS(ControlFlowCheckingbySoftwareSignatures)、针对引发的数据流错误的EDDI(ErrorDetectionbyDuplicatedInstructions)技术以及针对永久故障的ED4I[10-13]等.国内外本领域的相关工作一直较为活跃.普林斯敦大学提出了SWIFT(SoftwareImplementedFaultTolerance)来检测处理器内发生的数据流错误与控制流错误,并设计相关优化策略[14].法国TIMA实验室提出具有全覆盖能力的DSM检错技术[15].近年来国内多个课题组对此展开跟踪研究[16-19].EDDI/CFCSS/ED4I等技术通常在编译链后端实现,与体系结构和ISA紧密相关,可移植性受到制约.Yu等人[20]基于LLVM编译工具链,在SSA高级中间代码表示级别对应用进行加固,并提出多种优化机制降低实现代价,成功解决了可移植性问题.但是,该方法与编译链前端耦合紧密,开发周期长,且随编译器不同版本的发布,需频繁修改.3可靠性理论估计提出锁步机制目的在于追求整体故障检测能力最大化,同时将机制间故障覆盖能力的重叠降到最低,以此降低性能代价.为实现这个目标,需要综合考虑操作系统、固件以及硬件具备的故障检测能力,并在此基础上设计指令复制规则.本节提出了基于概率论的故障覆盖率估计方法,用于指导故障覆盖率与性能的折中策略.本文主要针对处理器内瞬时故障,故障发生后,经微结构级、结构级蔓延,传播至操作系统,最终在应用层外显.故障的传播路径涵盖多个层级,各层级的特点决定了它们在故障纠检错方面的不同角色.据此,本文采用面向部件的故障分类方法,以紧密结合耦合路径的故障覆盖特性对覆盖率进行准确估计.本文选择了单比特故障模型,并以SPARCV9指令集为例进行验证,本文方法适用于所有RISC指令集.3.1故障分类首先,将指令集分为计算指令(computationalinstruction)、访存指令(memoryaccessinstruction)、跳转指令(branchinstruction)和其它类指令(otherinstruction).其中,计算指令包括所有算术运算、逻辑关系运算和赋值指令.访存指令包括取数、存数和内存栅栏指令.跳转指令包括无/有条件跳转和函数调用(call)指令.其它类指令是除了计算指令、访存指令、跳转指令以外的指令集合,同时为涵盖故障引Page4发的正常指令转为非法指令的情况,此处将非法指令纳入其它类指令中.每种指令发生的故障仅包括两种情况:操作码故障和操作数故障.据此,将故障类型细分为14子类,基于SPARCV9的指令分类及故障类型详见表1.表中各故障类型发生概率由故障源所在部件和指令集编码决定,例如,解码部件故障涵盖全部类型.但是同类型(C→C、M→M、B→B和OT→OT)转化概率明显高于类型间转化,这一点由图1给出的指令集编码可知.类别符号指令类型故障类型计算指令C访存指令M跳转指令B其它指令OT如果故障源自算逻部件,只可能触发C→C一类,发生概率为100%.由此可知同类型故障能否良好覆盖,对系统的纠检错能力起关键作用,因此在表1中重点标示.3.2故障模型瞬时故障在组合逻辑诱发后,在多级逻辑门传输路径中蔓延,被微结构级(锁存器、触发器)时间窗口捕获后,通常导致多比特故障.但我们采用微结构级单比特故障模型,主要因为:(1)目前尚无统一的多比特故障模型.因为故障传播特性与设计细节,如结构/微结构级、门级,乃至设备级,耦合紧密;(2)由于多比特模型增大了出错的概率,实验中会更容易被容错机制(如EDDI机制)检测到,从而导地址生成部件地址生成部件计算得出当前指令和下条指令地址(PC/NPC),由取指逻辑访存将指令取回.该部件属组合逻辑部件,故障触发将直接影响PC/NPC,发生概率为100%.此类故障引发控制流错误,包括C→B、M→B、B→B和OT→B类型.这也是指令复制类容错机制覆盖能力相对薄弱的方面.然而,操作系统对此提供了强大覆盖能力(具体数据见5.2节).地址翻转发生在低位,会导致字未对齐,引发总线故障;发生在高位,通常造成段越界访问,引发段错误.对于后者,具体的故障覆盖能力取决于程序规模.这些现象在故障注入过程中表现十分明显.解码部件解码部件负责解析存放于指令队列中,等待进入流水的指令操作码.解码完成后负责将生成的控制信号送到相关执行部件,如算逻单元.该部件故障包括全部14种类型.由计算指令引发的4种类型,发生概率最大的是C→C,该类故障无法由硬件和操作系统覆盖,因此需要在机制中将计算指令复制和锁步比较.其余10类故障经估计和实验验证,会以较高概率被操作系统捕获(具体数据见5.2节).如对剩余部分有覆盖要求,则需复制全部指令,完全拷贝数据段、堆栈段等程序信息.而在程序实际执行过程中相当一部分不会被执行到,却会造成访存次数增多、执行时间增长、内存空间浪费等后果.关于覆盖率与性能折中的详细分析见5.2、5.3节.致过高地估计容错机制带来的可靠性提高.出于对用户负责的角度,我们有理由选择后者.单比特模型假设系统同一时刻只触发一次瞬时故障,故障经传播到达微结构/结构级引发单比特翻转.不同部件发生故障的概率依部件复杂度服从均匀分布(本文假设各部件单比特故障触发概率相等).3.3部件模型算逻单元计算指令经复制、锁步比较,绝大多数会被覆盖.但需要指出,有一类计算指令引入的比较指令无法覆盖,否则会引发循环锁步的情况.寄存器文件本文假设寄存器文件有ECC或校验和保护,在该部件触发的单比特故障都会被检出,即系统对寄存器文件的故障漏检率为0.因此,有理由在后续实验中省去对该部件的故障注入,直接将其故障漏检Page5基于上述指令分类和详细的部件分析,下面进率带入统计.其它部件其它部件,如处理器核外的各级缓存、内存以及这些部件间的关键数据通路、胶合逻辑,它们的物理实现一般配有不同的校验机制.虽然无法保证这些部件的原发性故障都被检出,但是对这些部件的瞬时故障易感性与性能、功耗的折中具有显著、积极的作用[20].由于处理器外的部件故障不属本文的研究范围,因此,本文假设核外的各级缓存、内存与之间的胶合逻辑是无故障的.至于从处理器流出的漏检指令或者数据,可归类到以上几个部件触发的故障类型中.3.4估计方法行理论估计.我们将A类指令由于单比特翻转而转变为B类指令,定义为A→B类故障,其中A和B可能为同类指令.n表示故障类型总数,m表示故障部件总数,故障发生在部件j的事件用Uj表示,Y表示故障漏检事件.SDC(SilentDataCorruption)表示故障未被硬件、操作系统和EDDI机制检测到,并且最终导致程序错误的故障比例.则P(SDC)=∑mP(SDCj|Uj)=δj×P(Y|Uj),δj=NSDCjNSDCj+NCRj其中,NSDCj为测试基准中结果为SDC的总数,NCRj为测试基准中出现正确结果的总数.解码部件故障漏检率估计用Xi表示发生于解码部件的第i类故障事件,则P(Y|Uj)=∑n如果用N表示测试基准总指令数,Ci表示由解码部件触发的第i类故障的指令集合,nb为指令位数,Wi指第i类故障的故障比特所在的指令域宽度,则在解码部件发生第i类故障的概率为其中,P(O|Xi)指第i类故障发生后操作系统检测不到的概率,则式中,P(b)为引发总线错误的概率;P(s)为引发段错误的概率;P(i)为引发非法指令的概率.P(珚O|Xi)表现了系统软件纠检错的能力.考虑其中的段越界(segmentationfault)和总线错误(buserror):段越界一般发生在指令/数据地址的高位,具体区域取决于应用程序编译后各个段大小(Lseg);总线错误往往是由单比特故障引起的字不对齐引发,取决于指令/数据字长(Lword).因此,可得P(b)+P(s)=log2Lseg-log2Lwordna=log2Lseg/Lwordna其中,na为地址域宽度.对于A→B类故障,Cii表示合法的A指令单比特故障发生后没有对应的合法的B指令的集合,Cai表示合法的A指令的集合,得操作系统漏检指令会蔓延至应用层,这些指令都处于Ci集合内,其中部分指令一定不会被低代价锁步EDDI算法所覆盖,这些指令的集合称为Ci;而在Ci-Ci集合中,如果故障发生在特殊的指令比特,又不能被覆盖,这些特殊的指令比特总数称为Wi.P(Y|O|Xi)指第i类故障发生后操作系统检测不到的条件下,低代价锁步EDDI算法检测不到的概率,则P(Y|O|Xi)=α1+α2×Ci其中,α1、α2和α3为0或者1,取决于具体的故障类型.对于A→B类故障,考虑下面一段代码:1.sethi%hi(.LL0),%g1//未复制2.add%g1,%g0,%g2//影子指令3.add%g1,%g0,%g1//主指令4.cmp%g2,%g3//比较5.bneerror1、3为主指令,如果A→B类故障导致控制流出错,而跳转到指令3、4时,该故障可被算法检出;如果跳到指令1、2、5处,则检测不到.此种情况下Wi/Wi采用如下的估计方法:令Neddi表示经EDDI机制加固后的程序指令数,Ncopy表示未加固测试基准需要复制的指令数.可以近似得到Page6综上,可得P(SDCj)=δj×P(Y|Uj)×P(Uj),jisDecoder其中,δj=NSDCjNSDCj+NCRj地址生成部件故障漏检率估计对于地址生成部件,估计方法如下:综上,可得其中,P(O)为地址生成部件发生故障后,操作系统漏检的概率,计算方法与式(5)相同.P(SDCj)=δj×P(Y|Uj)×P(Uj),jisAGEN其中,δj=NSDCjNSDCj+NCRj算逻单元故障漏检率估计算逻单元的估计方法与解码、地址生成部件稍有不同,部件的原发性故障无法被系统软件检出.设未被覆盖的指令集合为Ci,Ci为未处理的源程序中cmp指令集合,可得P(Y|Uj)=|Ci|P(SDCj)=δj×P(Y|Uj)×P(Uj),jisALU/FPU其中,δj=NSDCjNSDCj+NCRj4低代价锁步EDDI机制设计本节给出了具体的指令复制原则,并以SPARC架构为目标平台提出了寄存器预留方法.4.1指令复制原则低代价锁步EDDI影子指令生成原则如下:(1)计算指令(C类指令)复制,即进入算逻单元的指令.(2)同步指令不复制.同步指令包括:访存指令(M类指令),跳转指令(B类指令).(3)主指令与影子指令按照严格锁步方式执行,在主指令与影子指令之间不能有其它指令,且在主指令与影子指令执行之后立即比较执行结果.(4)影子指令在主指令之前执行.4.2寄存器预留基于上述的指令复制原则,本机制只需预留数目确定的少数几个寄存器,用于保存影子指令的执行结果和状态寄存器的内容.本文以SPARC架构为目标平台,将寄存器预留方法说明如下:为整型应用预留两个全局寄存器,一个作为影子指令目的寄存器,一个用于保存整型状态寄存器(icc/xcc)的内容.对于浮点运算,可能出现128位的结果,需要预留4个32位浮点寄存器.SPARC有4个独立的浮点状态寄存器(fcc),预留其中一个保存运算状态.4.3影子指令生成规则本文针对整型和浮点运算分别提出了具体的影子指令生成规则,并成功解决了SPARCV9指令集中副作用影子指令的生成问题.浮点运算影子指令与主指令状态寄存器相互独立,使得浮点运算影子指令生成不涉及副作用问题,直接按指令复制原则操作即可.摘自MiBench中FFT典型代码片段如下:fdivd%f10,%f8,%f28//影子指令fdivd%f10,%f8,%f10//主指令fcmpd%fcc3,%f10,%f28//比较指令fbne,pn%fcc3,.error//错误处理整型运算由于SPARC架构对于整型运算没有提供多份状态寄存器,因此我们单独预留了一个全局寄存器用于保存/恢复指令状态.整型运算影子指令具体生成规则如下:来自spec2000gzip代码片段如下:addcc%o3,-1,%g2//影子指令addcc%o3,-1,%o3//主指令rd%ccr,%g3cmp%o3,%g2//比较指令bne,pn%xcc,.errornopwr%g3,%g0,%ccr//恢复状态寄存器(1)非复制指令对于副作用指令,必须先保存状态,并在后续其它副作用指令执行之前恢复状态.来自spec2000mcf代码片段例子如下:cmp%o4,%i4//主指令rd%ccr,%g3//保存状态寄存器st%o2,[%l0+64]//主指令wr%g3,%g0,%ccr//恢复状态movl%icc,%i4,%o4//主指令(2)复制指令对于副作用指令,需将影子指令放在主指令前执行,在主指令后保存状态,并在后续使用icc的指令之前恢复icc.Page7bne,a,pt%icc,.LL53综上,本文分别针对整型运算与浮点运算,提出了独特的指令复制规则,并成功解决了副作用指令生成问题.通过寄存器预留成功实现主指令与影子指令对寄存器的分割,寄存器预留比远小于全复制EDDI寄存器分半的50%.本机制通用性强,无需传参规则的修改,无需系统库的重新编译.5实验5.1实验环境故障注入系统编译工具链选择GCC4.2.1,通过对体系结构文件的重配置,实现编译器支持的寄存器预留、分配和后端优化.为避免编译器指令调度破坏主、影子指令间严格锁步,我们在编译、汇编之间插入指令复制规则的具体实现.故障注入通过对结构级全系统模拟器SAM[21]的修改实现,目标架构为UltraSPARCT2,指令集为SPARCV9.评测环境本文将低代价锁步EDDI实现代价与全复制EDDI进行比较[20],后者实现方法为:主指令、影子指令各占用一份寄存器;计算指令复制并在同步指令之前比较,同步指令包括load,store,跳转,函数调用,函数返回;跳转指令不复制;访存执行一次,若是取数指令需将取来的数据写入影子寄存器.测试基准的选取故障注入的目的是观察实验平台运行测试基准时,注入故障引发的种种表现.广泛使用的spec系列测试基准,主要用于性能测试,运行时间较长(从数分钟到数小时不等,在模拟器上更要高出几个数量级),而且应用个数较多(通常有20个左右).因此,研究人员通常采用运行指定代码片段、记录trace的方式进行试验.然而,这种方式与瞬时故障模型的随机性相悖[22],故本文没有采用spec系列测试基准.文献[23]将MiBench与SPEC进行了对比,MiBench的指令类型和吞吐量等方面不逊于SPEC,完全满足故障注入的要求.而且,MiBench输入集较小,运行时间大大缩短,有利于提高故障注入样本空间.因此,本文采用MiBench测试基准,应用包括FFT、stringsearch、dijkstra和basicmath,采用标准输入集.5.2可靠性评测故障注入方式在SAM模拟器进行故障注入,分别模拟处理器组合逻辑的代表性部件:解码单元、地址生成单元和算逻单元发生瞬时故障,蔓延至部件输入/输出锁存引发的单比特翻转.每种故障类型每个测试基准注入100次.令Tload表示测试基准在SAM上运行时长,在[0,Tload]区间随机生成时刻Tinject.地址生成单元故障SPARC处理器除了包含程序计数器PC外,还具有NPC(NextProgramCounter).此寄存器包含下一条要执行指令的地址.本文对NPC寄存器注入单比特故障来模拟地址生成单元故障.解码单元故障对SAM指令缓存中即将进入执行段的指令注入单比特故障,模拟解码单元瞬时故障经蔓延引发的微结构级单比特翻转.因为指令缓存中的故障指令可能被后续过程中执行到,所以在故障指令执行结束后需恢复.算逻单元故障算逻单元的故障模拟与上述两个部件不同.计算指令进入算逻单元后,流经部件均为故障蔓延的潜在路径.如图2所示,可能的故障源有5处,从寄存器文件读取操作数时,经①数据通路读入②输入锁存,经③组合逻辑运算生成结果,通过④输出锁存和⑤数据通路被写回寄存器文件.据此可将故障归为3类:(1)操作数在数据通路引发翻转和输入锁存受辐射翻转,最终都会导致输入锁存单比特翻转.(2)运算过程中组合逻辑故障,与输入锁存单比特翻转导致的故障表现类似.(3)同理,输出锁存故障和写回过程中数据通路故障,三者也可用输入锁存单翻转模拟.由上述分析可知,本文在SAM执行过程中随机选择算术指令,并在此算术指令读取源操作数寄Page8存器时注入单比特故障.故障漏检率估计表2给出了解码单元(Decoder)、算逻单元(ALU)和地址生成单元(AGEN)故障漏检率的估计和实际值的对比.其中,实际正确结果项为故障注入后,未经硬件、系统软件以及EDDI检出,而且程序结果仍然正确的比例.本文假设寄存器文件有硬件保护,该部件故障漏检率为0.因此,对4个部件故障漏检率依故障发生概率加权求和,可得低代价锁步机制对处理器(system)的总体故障漏检率(本文假设各部件单比特故障触发概率相等).总体故障漏检率估计值为3.1%,实际漏检率为2.8%.估计表2故障漏检率估计漏检率/%漏检率/%测试实际正确结果fftdijkstra0.30.454.70.1029.23.12.112.80.90.624.2stringsearch0.80.954.00.10.531.52.32.318.20.80.925.9basicmath10.39.737.10.20.94.112.88.79.35.84.812.6average4.14.146.20.10.621.88.26.311.93.12.820.0对于算逻单元,估计值低于实际值,主要原因是故障注入到运算指令操作数寄存器后可能被逻辑屏蔽.例如:and%g1,1,%g2//影子指令and%g1,1,%g1//主指令and指令将寄存器g1的值和立即数1逻辑与,并将结果赋给目的寄存器.若故障发生在g1,仅当g1末位发生单比特翻转,才会影响执行结果,其它情况均导致逻辑屏蔽.对于地址生成部件,估计漏检率高于实际值的主要原因是:测试基准中的部分访存指令,访问地址由计算得出(间接寻址等),致使理论估计无法精确计算操作系统检错能力,导致估计的漏检率偏高.故障注入结果与分析测试基准在SAM注入故障之后,将故障实例的输出与标准输出进行对比.根据故障表现的不同,可将注入结果分为以下5类:(1)正确结果(Correctresult):运行结果的输出和标准输出一致.(2)EDDI检测(EDDI):故障被EDDI机制检测到.(3)操作系统检测:包括段错误(SegmentationFault)、非法指令(IllegalInstruction)、总线错误值与实际值拟合良好.估计值偏高的主要原因在于间接寻址方式导致操作系统检错能力被低估,从而最终使总体故障漏检率估计值偏高.但对于不同的部件其估计值表现不同,具体如下:在SPARC体系结构中,解码部件的估计值略低于实际值,原因是测试基准中某些运算指令实现的特殊性,使得故障注入到这些指令后被屏蔽,例如mov指令(该指令将源寄存器值赋给目的寄存器)的一个源操作数为%g0(SPARC架构g0值恒为0),若故障导致寄存器号改变为g1,恰好g1的值还是0,则不影响执行结果.此种情况在故障注入试验中发生频率较高.估计SDC(BusError).导致操作系统重新启动.(4)操作系统崩溃(OSPanic、HighOS):故障(5)错误结果:运行结果和无故障结果不一致.其中操作系统崩溃和错误结果之和为漏检比例,称为SDC(SilentDataCorruption).图3显示原测试基准、全复制EDDI加固、低代价锁步EDDI加固后分别在解码单元、算逻单元和地址生成单元注入故障的结果.与未加固测试基准相比,EDDI机制带来的容错性能提升十分明显操作系统的故障覆盖能力也相当可观.全复制EDDI整体SDC为2.0%,低代价锁步EDDI为2.8%.对于解码部件故障,未加固测试基准正确结果为60.2%,操作系统检测比例为24.9%,SDC为14.9%.全复制EDDI加固后SDC平均值为1.9%,经本文锁步EDDI加固后SDC平均值为4.1%.而锁步EDDI的SDC高于全复制EDDI的原因主要是前者没有对测试基准中cmp指令进行加固.在SPARC体系结构中,cmp指令是由目的操作数为g0的subcc指令实现,如果注入的故障修改了目的操作数域,会导致g0以外的寄存器误写入.若该寄存器影响程序数据流,就会引发错误结果.但此种情况对整体检错性能贡献并不明显,而全复制EDDI为覆Page9图3故障注入结果盖cmp指令,也付出了寄存器分半的代价.由此带来的性能下降十分明显,具体分析见5.3节性能评测.对于地址生成部件,没有EDDI加固的测试基准结果SDC平均值为8.6%.全复制EDDI加固后SDC平均值为6.1%.经本文低代价锁步EDDI加固后SDC平均值为6.3%.其中略高于全复制EDDI,主要原因是本机制复制指令原则是影子指令和主指令源操作数都来自同一个寄存器.图4性能代价静态指令代价全复制EDDI静态指令总数平均值是原测试基准指令总数的4.63倍,而低代价锁步EDDI则是原测试基准指令总数的2.29倍.主要原因是:(1)比较原则.全复制EDDI在同步指令之前比较值和地址,store带来至少两次的比较(值、地址)和对标志寄存器ccr的保存和恢复,函数调用会带来和参数个数相同数量的比较,跳转指令之前还需比较标志寄存器.而低代价锁步EDDI只比较运算指令结果,对于标志寄存器也只是在修改时保存,使用时恢复,而对于算逻单元,经本文低代价锁步EDDI加固后,SDC平均值从无EDDI加固的19.6%降低为0.6%.全复制EDDI为0.1%.5.3性能评测本节从静态指令数、动态指令数和执行时间3个方面对比了低代价锁步EDDI与全复制EDDI机制的性能表现.所列数据均为与未加固测试基准规格化的结果,如图4所示.此原则在寄存器有保护的情况下,不会带来容错性能的下降.与低代价锁步EDDI相比,全复制EDDI的比较指令高出121.1%.(2)寄存器压力.全复制EDDI主指令、影子指令各占用一份寄存器,使程序中可分配的通用寄存器变少,这样就增加了程序中访存指令和运算指令的比例.与低代价锁步EDDI相比,全复制EDDI访存指令比例平均增加33.8%,运算指令数平均增加41.3%.其中FFT的访存指令增加比例达到69.1%,可知低代价锁步EDDI对于诸如FFT这类寄存器负载较高的应用,Page10带来的性能提升尤其明显.需要指出的是,访存指令的增多会进一步提高全复制EDDI的比较代价.动态性能代价全复制EDDI动态执行指令数是原测试基准的2.37倍,执行时间是原测试基准的1.92倍.与低代价锁步EDDI相比,全复制EDDI平均执行的比较指令增加253.5%,运算指令增加50.1%,访存指令增加8.7%,其中FFT的访存指令增加比例达到18.3%.总之,由于本文低代价锁步EDDI独特的复制原则和在编译前端实现的寄存器预留两个,减少了寄存器预留数、有效缓解寄存器压力,降低了访存代价,同时也降低了插入指令总数.与全复制EDDI相比,低代价锁步EDDI在性能上提高显著:平均执行时间缩短35.2%,平均动态执行指令则减少36.1%.这充分证明了本文代价互锁EDDI在性能上的优势.6结论本文在设计初期将硬件和系统软件的故障纠检错能力纳入考虑,针对处理器内瞬时故障,设计应用级“低代价锁步EDDI”.主要内容如下:(1)设计了低代价锁步EDDI机制,提出低代价锁步的指令复制规则和寄存器分配方式.本机制结合硬件纠检错能力,兼顾处理器内组合逻辑、时序逻辑两类部件.与传统EDDI将寄存器分半不同,通过编译链前端寄存器分配大幅减少了寄存器预留数,有效缓解寄存器压力,降低了访存代价,减少了性能损失.无需修改编译器传参规则,无需重新编译系统库,提高了通用性.(2)基于概率论提出故障漏检率量化估计方法,为纠检错与性能折中进行指导.通过对处理器中代表性部件:算逻单元、解码单元和地址生成部件进行故障注入,验证理论估计方法的有效性.(3)选择单比特瞬时故障模型,对机制故障注入实验结果、静态性能代价,与动态性能代价进行详细评测.与全复制EDDI相比,低代价锁步EDDI仅以SDC平均升高0.8%的代价,换取了平均执行时间缩短35.2%,平均动态执行指令则减少36.1%的性能优势.
