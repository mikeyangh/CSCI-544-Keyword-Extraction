Page1面向三维多核片上系统的热感知硅后能耗优化方法1)(华北电力大学电气与电子工程学院电子与通信工程系河北保定071001)2)(中国科学院计算技术研究所计算机体系结构国家重点实验室北京100190)摘要高能效(Energyefficiency)已成为目前嵌入式多核片上系统(System-on-Chips,SoCs)设计中的首要优化目标.基于电压/频率岛设计的三维多核片上系统能够为构建高能效系统提供一种有力的解决方案.然而,不断增加的工艺偏差导致制造后芯片中电压/频率岛的性能参数偏离其额定值.在较大偏差的影响下,可能无法满足任务的截止时间约束.另外,已有的研究工作大多针对二维平台,无法很好地解决因三维集成而不断恶化的发热问题.面向采用电压/频率岛设计的三维多核SoC,文中提出一个硅后优化框架,在最小化系统能耗的同时,能够满足任务截止时间和系统热约束.除了能效感知的任务调度和电压/频率分派方法,提出的优化框架还采用任务迁移平衡核栈的功耗以实现热优化.实验结果表明,与已有的热平衡方法比较,文中提出的方法能减少平均18.6%的能耗.同时,与经典的能耗优化方法比较,文中提出的方法能降低平均5.6的峰值温度.关键词系统能耗;三维多核片上系统;工艺偏差;电压/频率岛;任务调度;热优化1引言集成电路制造工艺的不断进步大大增加了硅片上晶体管的集成密度.相应的,嵌入式系统设计开始转向多处理器/多核片上系统(Multi-Processor/Multi-coreSystem-on-Chip,MP/Multi-coreSoC).一般来说,多核SoC中包含多种处理芯核,例如通用处理器、数字信号处理器、图形处理器和低功耗处理器等.通过将不同类型的处理芯核集成到一个硅片,多核SoC能够提供完整的系统功能.对于不断增加的种类繁多的应用程序而言,多核SoC无疑具有广阔的应用前景.对于高性能、高端片上系统而言,三维多核结构极具吸引力[1-2].一方面,三维集成能够克服传统二维芯片上普遍存在的全局互连延迟和功耗瓶颈问题.另一方面,多核结构不仅能提高系统吞吐量,还能够提高偏差影响下的系统鲁棒性.正是因为结合了上述优点,三维多核SoC非常适合用于复杂系统以解决未来种类繁多的应用需求.由于嵌入式SoC经常采用电池供电,高能效、低能耗就成为一个重要的设计目标.近年来,人们向二维多核设计引入电压/频率岛(Voltage/FrequencyIsland,VFI)以优化系统能效[3-5].VFI是将芯片上的处理芯核划分为不同的电压/频率域.每个VFI都可以运行在各自最优的电压和频率下.通过与任务调度相结合,上述设计方法能够实现细粒度的能耗管理和优化,且满足任务的截止时间约束.然而,随着晶体管特征尺寸的不断缩小,芯片制造过程中引入的工艺偏差(ProcessVariation,PV)也日益严重,给多核SoC设计带来严峻挑战[6-7].在工艺偏差影响下,制造后的SoC芯片上处理芯核的性能参数(如频率、功耗)常常偏离设计阶段所指定的额定值且应被看作是随机变量.因而,对于量产SoC芯片而言,处理芯核的性能参数表现为统计分布.相应的,多核SoC所执行的应用程序的执行时间等参数同样具有了概率特征.这种执行时间的不确定性无法保证程序的执行在各种工艺拐点(processcorner)处都能满足系统的实时性约束.已有的研究工作通常是在设计阶段对VFI进行划分,或者假定芯片具备每核VFI的配置.然而,随着工艺偏差日益恶化,芯片制造后VFI的性能参数可能偏离设计额定值.因此,很难保证设计阶段所制定的VFI划分方案在硅后仍然是最优解.另一方面,对于大规模多核芯片来说,每核电压/频率域(即每核VFI)配置很难实现.随着处理芯核数目的增加,每核VFI需要更多的片外电压规整器(regulator)或片上电压规整器.前者数量的增加会极大地提高封装成本;而后者功率传输效率较低[8].由此可见,对于大规模多核芯片,每个VFI包含多个处理芯核较为实际.再者,与二维芯片相比,面向采用电压/频率岛设计的三维多核芯片进行能耗优化还需要解决一些新的挑战.例如,三维集成导致芯片的散热问题日益严峻.不断增加的功耗密度恶化了热斑(hotspot),同时在芯片上产生高温[9].工作负载的异质性(heterogeneous)则会在处理芯核间造成功耗偏差,导致芯片上出现热梯度(thermalgradient).高温和热梯度不仅会降低系统性能和可靠性,而且将会抵消优化系统能耗的努力.为了解决上述问题,面向采用VFI设计的三维多核SoC,本文提出一个硅后优化框架,在最小化系统能耗的同时,满足任务截止时间和系统热约束.首先,根据硅前确定的VFI划分方案以及工艺偏差造成的性能参数偏差,提出能效感知的任务调度算法.该算法统一考虑后续的电压/频率分派以最小化任务的执行能耗.随后,提出任务迁移算法,在任务图的执行过程中实现核栈间的功耗平衡,降低芯片温度.实验结果表明,与已有的热平衡方法比较,本文提出的方法能减少平均18.6%的能耗.同时,与经典的能耗优化方法比较,本文提出的方法能降低平均5.6的峰值温度.2相关研究现状面向采用VFI设计的多核芯片优化能耗方面,Ogras等人[10]提出了VFI划分与静态电压/频率分派的混合方法优化二维NoC的系统能耗.他们首先将每个处理芯核看成是单独的VFI,按照任务调度的结果确定每个处理芯核的最低操作电压.随后将处理芯核进行合并以形成新的VFI.VFI的数目取决于系统设计约束.考虑通信能耗,文献[11-12]提出了电压调节和任务调度算法相结合的方法优化二维多核芯片的能耗.其中,文献[11]整体考虑任务的执行能耗和通信能耗,提出了有效的启发式算法进行任务的调度.文献[12]则将任务调度完成后的处理芯核电压分派模型化整数线性规划问题进行求解.面向二维NoC,Jang等人[13]提出了VFI感知的能Page3耗优化框架,通过在设计阶段确定最优的处理芯核映射以及路由算法来优化系统能耗.假定多核芯片具有每核电压/频率域的配置,Zhang等人[14]提出了动态电压/频率调节和任务调度相结合的方法优化系统能耗.然而,他们的方法不适合大规模多核芯片.另外,由于热特性的差异,上述文献提出的方法无法直接应用于三维芯片.面向三维多核芯片,Cheng等人[15]提出了考虑热约束的任务分配和调度算法优化通信能耗.然而,他们的工作忽略了计算能耗的优化.在三维芯片的热优化方面,也有许多有价值的研究工作.硬件方面,Goplen等人[16]提出插入热过孔来加速三维芯片的散热.针对三维芯片特定的面积,他们借助表面元素分析迭代计算热过孔的插入位置以及调整热传导性,从而有效地降低芯片温度.Wong等人[17]提出温度感知的热过孔布局方法来降低芯片温度.基于随机行走算法,他们构建了一个新的热分析模块,而热分析的结果则被用来指导确定热过孔的插入位置.Bakir等人[18]提出采用流体冷却方法帮助三维芯片散热.他们的方法集成了电气、光和微流体互连.软件方面,文献[19]提出动态热管理技术处理程序运行时的热紧急(thermalemergency)情况.他们提出Adapt3D算法,通过考虑处理芯核的热历史信息以及三维芯片特性来平衡芯片温度.Zhou等人[20]提出均衡线程分配算法,通过图1目标平台和目标应用示意图目标应用为具有高确定性的通信任务图.如图1(b)所示,通信任务图表现为有向非循环图.图中,顶点表示任务.很多工业级基准任务图中都给出了每个任务在不同类型处理芯核上执行的功耗和延迟.图中有方向的边则表示任务间的控制和数据依赖关系.即某一任务必须在其所有前继任务执行完成且完成数据通信后才能开始执行.有向边上标示的数字表示任务间的通信量.一般情况下,每一个叶节点处均会有一个截止时间约束(如图1(b)中的Td(3)和考虑线程间的热差异进行线程分组并调度到核栈上,以实现三维多核芯片的热均衡.Zhu等人[21]提出结合任务调度和电压调节实现三维多处理器SoC的热优化.通过考虑工作负载和异构处理芯核本身的热差异,提出了操作系统级的动态热管理技术.然而,上述研究工作均只关注热优化,忽略了系统能耗的优化.3背景知识介绍3.1目标平台和应用参考商用多核处理器以及目前对于三维多核芯片的研究工作,本文中的目标平台定义如下.如图1(a)所示,目标平台为三维同构多核SoC.平台包含多个处理芯核层[1,22].每一层采用格状(tile)结构,每个格内包含一个集成私有高速缓冲存储器(Cache)的处理芯核以及一个路由器[5].采用片上网络(Network-on-Chip,NoC)实现格间通信.同一层NoC为网状(mesh)结构;层间通信通过硅通孔(ThroughSiliconVia,TSV)总线实现.本文假定处理芯核可以工作在几个不同的离散电压/频率范围内.VFI由片外电压规整器支持.每个电压规整器支持一个VFI的电压域.每个处理芯核假定拥有自己的数字锁相环(DLL)部件以实现独立的频率域.不同VFI间的数据同步由VFI边界处的混合电压/频率先入先出(FIFO)缓存支持.Td(5)).表示这一任务通路(由多个任务串联组成,一般由初始任务节点开始到某一叶节点任务结束)所规定的最晚完成时间.3.2能耗模型根据上述对目标平台和目标应用的描述,可以将系统能耗Esys表示为计算能耗与通信能耗之和:式(1)中,Ecomp和Ecomm分别表示计算和通信能耗.计算能耗主要源自任务在处理芯核上的执行.Page4对于包含n个处理芯核的芯片,Ecomp可以表示为式(2)中,NCj表示任务的执行周期数,Ci表示核i每周期的平均开关电容,Vi表示核i的操作电压.为了计算总的通信能耗,参考文献[10,15],首先定义由核i到核j传输一位所消耗的位能耗:Ebit=∑式(3)中,ER连线消耗的位能耗,EFIFO消耗的位能耗,nV表示根据路由算法得到的核i到核j的跳数(hop),Vi表示VFIi的工作电压.根据计算所得的位能耗,包含m个通信事务的任务图总的通信能耗可以表示为其中,Qk表示核i与核j之间通信事务k的数据通信量.3.3延迟模型基于任务j的执行周期NCj,该任务在操作频率为fi的核i上的执行时间可以表示为对于通信事务k,通信延迟表示为式(6)中,NCR表示一个位片(flit)经过一个路由器及外部互连所需的时钟周期数,NCFIFO表示位片经过混合电压/频率FIFO所需时钟周期数,W为系统带宽.很明显,式(6)中的前两项表示头片(headerflit)的传输延迟.最后一项表示数据串行化延迟.3.4热模型图2给出了三维多核芯片的热模型示意图[23].该模型将芯片面积划分为网格.每个格对应一个热模型元素,包含热电阻、热电容和一个电流源.格内的温度假定为均匀的.这种细粒度的格状热模型可以很容易地与HotSpot[24]软件进行结合以计算芯片温度.参照此热模型图,核2和核3的温度可以计算如下:式(7)中,P2和P3表示核2和核3的功耗,Rinter表示垂直方向上核2与核3之间的热电阻,Rhs表示处理芯核与周围材料之间的热电阻,Tamb表示周围环境温度.由式(7)可以看出,假定热电阻参数为常量的情况下,处理芯核执行程序时的温度主要取决于它的功耗.另外,如文献[23]所示,不同层的处于垂直方向的处理芯核之间有着较强的热相关(Rintra16Rinter).由此可见,在垂直方向的核栈间保持功耗平衡能够有效地平衡芯片的温度.3.5统计偏差模拟出于实验的需求,我们借助统计偏差模拟分析和计算参数偏差影响下三维多核SoC中处理芯核的频率和功耗分布以及分布的相关性信息.偏差模拟首先从模型化晶体管一些典型物理参数(如沟道长度和阈值电压)的偏差开始.在模拟中,片间随机性偏差、片内随机性和具有空间相关性的系统性偏差全部予以考虑.其中,同一层的硅片里器件的参数偏差主要取决于片内偏差.由于三维芯片不同层的硅片一般来自于不同的晶圆(wafer).因此,模拟中,不同层的硅片间的片间偏差假定为独立的.按照上述约定,某一层硅片中晶体管的某一参数的偏差可以表示为式(8)中,ΔPinter表示片间随机性偏差,ΔPsys表示片内系统性偏差,ΔPran表示片内随机性偏差.模拟中,首先按照多核芯片的版图,将整个硅片面积划分成许多相等尺寸的网格(grid).在每一个格内,均包含唯一一个表示片间随机性偏差、片内系统性和随机性偏差的随机变量.随机变量假定服从标准正态分布.同时,我们采用文献[25]提出的VARIUS模型来刻画片内系统性偏差分布的空间相关性.根据VARIUS模型,任意两个网格内片内系统性偏差分布的空间相关性可以表示为Page5式(9)中,φ表示任意两个网格内器件的参数分布相关性变为零的物理距离范围,r表示两个网格的物理距离,ρ(r)∈[0,1],表示空间相关性的程度,ρ(r)取值越接近于1,表示参数分布的空间相关性也就越大.反之,越接近于0,则表示参数的分布相关性越小,更适合表现为独立分布.基于上述的偏差模型,我们采用蒙特卡洛模拟来获取晶体管沟道长度和阈值电压的统计分布数据.随后,将参数的偏差分布数据送入关键通路模型[7,25]以获取不同类型处理芯核的频率和功耗分布信息.关键通路模型以四扇出标准与非门为基本逻辑单元,借助HSPICE电路仿真确定不同工艺节点下,不同类型的处理芯核所对应的逻辑门的级数.一个处理芯核内所包含的关键通路数目则可以将处理芯核的版图面积除以具有高度相关性的单位面积(如文献[25]建议采用0.02mm2)获得.图3提出的优化框架示意图4.1能效感知的任务调度面向多核平台,以优化能耗为目的的任务调度已被证明为NP困难问题[11].为了有效地优化能耗,必须统一考虑任务调度与接下来的处理芯核电压/频率分派.即任务调度算法必须为后续的电压/频率调节保留尽可能多的优化空间.为了实现上述目的,本文采用任务的最低操作电压/频率实现任务调度与电压/频率调节的有机统一.任务的最低操作电压/频率表示为了最小化任务执行能耗且同时满足截止时间约束,执行任务的处理芯核运行时所需的最低电压和频率.本文提出的任务调度算法将具有相同最低操作电压/频率的任务尽量分配到同一个处理芯核上.这种调度策略可以保证处理芯核采用所调度的任务的最低电压和频率运行,从而为后续的电压/频率调整保留最大的优化空间.算法1为所提出的任务调度算法的伪代码.4优化框架图3给出了本文提出的优化框架的示意图.如图所示,面向已完成VFI划分的三维多核平台,首先采用能效感知的任务调度算法将任务分配到处理芯核上.与已有的研究工作不同,本文提出的任务调度算法在调度任务时即考虑为后继的处理芯核电压/频率分派保留优化空间.因此,在算法中采用任务的最低操作电压和频率作为指导参数对任务调度和电压/频率分派进行统一.同时,任务调度后,任务图的整个执行时间被划分为许多连续的时间片段.以这些时间片段为参考,任务迁移算法在处理芯核间迁移或交换少量已调度的任务,在整个任务图执行期间实现核栈的功耗平衡.与已有的在线任务迁移方法不同,本文提出的任务迁移同样是在设计阶段,即任务实际开始执行前完成的.这样就避免了在线任务迁移所引入的性能和硬件方面的开销.算法1.能效感知的任务调度算法.输入:任务图,可用离散的电压/频率范围输出:任务调度结果,执行时间序列(ETS)预处理步骤:1.额定电压/频率下,为每个任务计算Ecomp;2.为任务图中每条任务通路计算总的slack和Ecomp;3.FOR每个任务Ti4.FORTi所在的每条通路Pj5.Tslack(i,j)=[Ti_Ecomp/Pj_Ecomp]×Pj_slack;6.Ti_slack=min(Tslack(i,j));//若某个任务处于多条7.记录Ti_start,Ti_finish,Ti_deadline;//计算任务开始执8.FOR每个任务9.计算任务的最低操作电压及剩余slack;任务调度:/FTL:全任务列表,RTL:就绪任务列表,rt:就绪任Page6务,ACL:可用处理芯核列表,ac:可用处理芯核,STL:调度时间列表,st:调度时间点/10.WHILE(!FTL.IsEmpty()){//全任务列表不空,表11.st=STL.GetHead();//获得当前调度时间节点12.RTL.Add(当前st下rts);ACL.Add(当前st下acs);13.WHILE(!RTL.IsEmpty()){//当前就绪任务列14.rt=RTL.GetHead();//取出就绪任务列表中第15.IFACL中所有ac不具备与rt相匹配的最低电压16.将rt调度到空闲的ac,标记ac.V/F为rt.V/F;17.ELSE18.将rt调度到具有最大通信量的匹配ac;19.STL.Add(rt.deadline);STL.Del(st);20.根据任务调度结果生成ETS;//对齐任务执行时间,算法首先执行预处理步骤.这一步骤首先为每个任务分配执行时间余量(slack)以及计算任务的最低操作电压/频率.在我们提出的算法中,任务的执行能耗越大,所分配的执行时间余量越多.为高能耗任务分配较多的执行时间余量能够提供更大的电压/频率调节空间,从而更大程度地降低执行能耗.任务执行时间余量的分配过程如下.首先,计算每个任务在额定电压/频率下的执行能耗(行#1),即该任务在额定电压/频率下的功耗和执行时间的乘积.同样,为任务图中每一条任务通路(任务串联组成的通路,由任务图中某一个初始任务节点开始一直到某一个叶节点结束)计算总执行能耗和总执行时间余量(行#2).其中,任务通路的总能耗等于该通路上所有任务计算能耗之和;而任务通路的总执行时间余量可表示为该条通路叶节点上的截止时间约束与通路上所有任务额定执行时间总和之间的差值.可用如下公式表示:式(10)中,Pi_slack表示任务通路i总的执行时间余量,Pi_deadline表示任务通路i叶节点上的截止时间约束,Ti_exetime表示任务i在额定电压/频率下的执行时间,m表示任务通路上的任务数目.随后,对于每条通路上每一个任务,按照该任务与所在任务通路的总能耗比值分配执行时间余量(行#3~5).对于处于多条任务通路交叉点上的任务,按每条任务通路计算所得的执行时间余量可能不同.这种情况下,取计算所得的执行时间余量中最小值作为该任务的执行时间余量(行#6).随着执行时间余量的分配,任务的开始时间、结束时间和截止时间约束均可确定(行#7).同时,对任务的最低电压/频率也可进行计算(行#8~9),过程如下.任务的执行时间余量为其截止时间和执行时间之差,可表示为Texe-NC/fi.其中,Texe表示任务的执行时间;NC表示任务的执行周期;fi表示任务所在处理芯核工作频率.由上述公式可知,随着处理芯核工作电压/频率的降低,任务执行时间将增加,而执行时间余量则会减少.因此,执行时间余量接近或等于零时的电压/频率则确定为任务的最低操作电压/频率.接下来,在每一个调度时间节点,算法将就绪任务调度到处理芯核上.每次一个任务调度完成,该任务的截止时间即被加入到调度时间列表中成为新的调度时间节点.在每个调度时间节点,当前的就绪任务和空闲处理芯核分别被加入到就绪任务列表和空闲处理芯核列表中(行#11~12).就绪任务表示该任务调度前,其所有的前继任务均已调度完毕.在全部任务图调度的初始阶段,一般会有一些处理芯核从未被分配任务.这时,对于某个就绪任务,如果当前所有的空闲处理芯核(即从未被分配任务的处理芯核)均没有被标记为与就绪任务相同的最低操作电压/频率,则该任务将被调度到任意一个空闲处理芯核上.随之,按调度的任务的最低操作电压/频率标记该处理芯核(行#15~16).相反,如果有些处理芯核已被标记为与就绪任务相同的最低操作电压/频率,则就绪任务将被调度到与该任务有最大通信量的处理芯核上(行#17~18).与某一就绪任务有最大通信量的处理芯核是指所有已经调度到这个处理芯核的任务与该就绪任务有最大通信量.根据通信能耗的计算公式(式(4)),将就绪任务调度到与它有最大通信量的处理芯核上可以有效地降低通信能耗.这是因为数据的通信不需经过片上网络.确定最大通信量处理芯核的方式则是按照通信任务图中定义的数据相关性(即任务间的通信数据),计算该就绪任务与每个处理芯核上已经调度的任务之间的通信量,最后找到有最大通信量的那个处理芯核.上述任务调度过程不断重复,直到成功调度完任务图中的所有任务.根据任务调度结果,算法随即生成执行时间序列(行#20).在执行时间序列中,任务图的执行过程被划分成许多连续的执行时间片段.执行时间片段Page7的划分采用一种粗粒度方式进行.通过简单地对齐处理芯核上所调度的任务的执行时间划分执行时间片段.图4(a)展现了将一个含16个任务的任务图调度到4个处理芯核时划分所得的执行时间序列.执行时间序列包含7个时间片段(t1~t7).调度的任务以矩形表示.矩形的高度表示任务的执行功耗.填充矩形的颜色则表示处理芯核所运行的最低操作电压/频率.每个时间片段的划分尽量对齐任务的执行时间.即每个时间片段内尽量有尽可能多的同时执行的任务;相邻时间片段之间有尽可能少的重叠执行的任务.4.2任务迁移算法任务迁移算法在处理芯核之间迁移或交换已调度的任务.目的是在每个执行时间片段中平衡核栈的功耗,以降低芯片温度.迁移任务时,算法主要利用处理芯核空闲时间以及任务经过电压/频率调节后的剩余执行时间余量.这里需要说明的是,本文所提出的任务迁移算法并非传统意义上的在线任务迁移.本文中的任务迁移与任务调度算法相似,均是在设计阶段,即实际任务执行之前完成.目的是为了平衡核栈间的功耗,实现芯片的热平衡并且降低芯片温度.任务图实际执行期间,即可按照预先确定的任务-处理芯核对应关系进行任务的分配.算法2给出了任务迁移算法的伪代码.算法2.任务迁移算法.输入:任务调度结果,电压/频率分派结果,核栈,执行输出:任务迁移及最终调度结果/co:处理芯核;CS:核栈;CSL:核栈链表;te:执行时间片段;ΣP:核栈总功耗;LPT:核栈中某个核上的高功耗任务;SPT:核栈中某个核上的低功耗任务;IT:空闲时间;ET:执行时间/1.FORETS中每个执行时间片段te{2.为每个CS计算ΣP,计算总功耗标准差ΣP.σ;3.IFΣP.σ>阈值{//如果标准差大于设定的阈值,4.将CSL中所有CSs以ΣP按降序排列;5.i=0;j=CSL.GetLengh();CSh=CSL.GetAt(i);6.WHILE(1){7.CSt=CSL.GetAt(j);8.IFCSt.co.IT与CSh.co.SPT.ET相匹配//低功耗核栈处理芯核的空闲时间9.10.ELSEIFCSh.SPT和CSt.LPT能够交换11.12.ELSE13.j=j-1;}14.从CSL中移除CSh和CSt;15.IFCSL.GetLenth()>=216.在每个执行时间片段,对每个核栈计算总功耗ΣP.同时,计算所有核栈总功耗的标准差ΣP.σ.如果标准差大于指定阈值(例如实验中取5%),则启动任务迁移.首先,将所有核栈按总功耗大小按降序排列.随后,针对具有最大总功耗的核栈CSh,找出具有最小总功耗的匹配核栈CSt.这里,匹配的含义有两层:(1)匹配的核栈其中一方能够为另一方提供空闲时间以供任务迁移;(2)匹配双方可以交换任务.如果条件1满足,CSh中的低功耗任务(SPT)将被迁移到CSt上(行#8~9).如果条件2满足,CSh中的低功耗任务将与CSt中的高功耗任务(LPT)进行交换(行#10~11).本次任务迁移完成后,从CSL中移除CSh和CSt.上述过程不断重复,直到在所有执行时间片段内都进行了任务迁移(行#14~16).以图4(a)调度的任务图为例.如图4(b)所示,Page8处理芯核1、4和2、3各组成两个核栈.现在我们考虑时间片段t3中的功耗情况.在没有采取任务迁移之前,t3期间,包含处理芯核1和4的核栈总的功耗为任务3和任务4总功耗之和.很明显,这个总的功耗远远大于包含处理芯核2和3的核栈的总功耗(即任务2的功耗).因此,为了在执行时间片段t3中平衡核栈的功耗,任务3可以从核1迁移到核2.原因在于任务1和任务6之间的空闲时间能够容纳任务3的执行.同理,为了平衡时间片段t6中的功耗,任务10可以从核2迁移到核4.从而保证两个核栈中均有一个执行的任务,以实现在t6中的功耗平衡.图5任务迁移前后功耗和温度对比5实验及讨论5.1实验配置说明5.1.1实验平台实验在一个格状NoC-总线结构的三维多核SoC模拟平台上进行.平台拓扑设为4×4×2,即两层处理芯核堆叠,每层处理芯核数目设定为16个.同一层的处理芯核采用网状结构NoC互连.而不同层的处理芯核之间则通过多TSV总线进行通信.芯片绑定方式假定为面向背(Face-to-back)绑定策略.处理芯核假定为TILE64多核处理器中采用的VLIW处理器[26].处理芯核在1.0V额定操作电压下的操作频率设为500MHz,可运行在五个不同的电压级别下[0.7V,0.8V,0.9V,1.0V,1.1V].通过将处理芯核模型化为4扇出与非门链,采用基于值得注意的是,原本任务2与任务9之间的空闲时间不足以容纳任务7的执行.幸运的是,任务7的前继任务,即任务2在电压/频率调节后仍保留有一定的执行时间余量.因此,迁移算法减少任务2的执行时间余量(并没有造成违背任务截止时间的现象),将任务7的执行时间提前,从而可以将任务7从核4迁移到核3.图5展示了施行任务迁移前后两个核栈的功耗以及生成的温度.很明显,任务迁移算法有效地在所有执行时间片段中平衡了核栈的功耗.相应的,功耗平衡不仅平衡了核栈温度,而且有效地降低了芯片温度.45nmPTM晶体管模型[27]的HSPICE仿真来评估处理芯核在不同供电电压下的最大操作频率.路由器采用4级流水线结构,包含5个端口.除了用于二维平面中东、西、南和北方向通信的4个端口外,第5个端口用于连接垂直总线以实现垂直方向上的数据交换.相同格内的处理芯核和路由器假定具有相同的操作频率.采用确定性x-y-z路由算法来避免活锁和死锁.在VFI边界处采用混合电压/频率FIFO实现数据同步.式(3)中的位能耗参考文献[15]计算.5.1.2任务图实验中采用两组任务图.第1组取自工业级基准任务图E3S①.E3S中的任务图均给出了所包含①DickR.EmbeddedSystemSynthesisBenchmarksSuitesPage9的任务在各种实际的处理芯核上执行时的功耗和延迟.不过,E3S中的任务图所包含的任务数目一般小于实验平台中的处理芯核数目.因此,参照实验平台中处理芯核的数目,实验中将基准程序中多个任务图组合成新的任务图.第2组采用TGFF①生成6个伪随机任务图(TG1~TG6),每个任务图包含80~100个任务.任务图生成过程中,通过更改任务的入度、出度以及通信量来覆盖不同类型的任务.表1列出实验采用的任务图统计信息.任务图ConsumerAuto-industryNetworksTelecommTG1TG2TG3TG4TG5TG65.1.3偏差影响下的VFI划分图本文采用文献[25]提出的VARIUS模型对参数差偏差进行建模.标准偏差设为参数期望值的10%,并进一步分为6%的片间偏差和8%的片内偏差.片内偏差平均分为系统性和随机性偏差两部分.刻画芯片二维平面上系统性偏差相关性的最大物理距离设为0.5[25].整个芯片面积划分为64个网格.每个处理芯核占据一部分网格并被模型化为100条四扇出的与非门链.通过应用VARIUS模型,借助HSPICE蒙特卡洛模拟获得处理芯核的频率分布数据.将频率分布的均值作为处理芯核的额定操作频率.同样,5种供电电压下处理芯核的操作频率也采用HSPICE进行评估.根据获得的处理芯核的5种电压/频率组合,实验中采用文献[10]提出的方法划分VFI.VFI划分采用两层统一的方式.也就是说,同一个VFI可能包含垂直方向上位于不同层的处理芯核.划分过程中,操作电压/频率相接近的处理芯核会被划归于一个VFI.每个VFI中包含的处理芯核数目可能不同.VFI的划分从每核VFI开始,随后两两合并,直到最终所有处理芯核同属一个VFI结束.对所有划分粒度的VFI方案,取能耗最低的那一个作为最终VFI划分方案.表2列出与各任务图对应的VFI划分结果.5.1.4热模拟方法采用HotSpot5.0计算任务执行时的芯片温度.该软件支持基于网格的三维芯片热模拟[24].热模拟参数参考文献[15]中的数据,具体值如表3所示.模拟所需的功耗痕迹(trace)文件通过计算每个调度间隔任务的平均执行功耗获得.温度计算中只考虑处理芯核的静态温度及芯片的峰值温度.5.2实验结果出于比较目的,本文修改并实现了文献[20]提出的热平衡算法,使之适用于基于VFI设计的三维多核平台.文献[20]考虑任务间的热特性差异,在每个调度时间节点将高功耗和低功耗的任务组合在一起调度到一个核栈上.在本文后续的内容中将文献[20]提出的方法称为TB算法.同时,本文还实现了文献[10]提出的能效感知的任务调度算法.他们的方法通过考虑赋予不同能耗任务以不同的优先级指导任务的分配和调度.而在VFI划分过程中,他们首先将每个处理芯核看成是单独的VFI,按照任务调度的结果确定每个处理芯核的最低操作电压.随后将处理芯核进行合并以形成新的VFI.VFI的数目取决于系统设计约束.在本文的后续内容中将文献[10]提出的方法称为EAS算法.5.2.1能耗优化结果图6给出采用3种方法后的能耗优化结果及优化过程中的芯片峰值温度数据.为了更为清晰地展①Available:http://ziyang.eecs.umich.edu/~dickrp/tgff/Page10示结果对比,EAS和本文提出的方法所取得的能耗优化结果均以TB方法取得的结果为参照进行归一化处理.由图6(a)可见,在能耗优化方面,本文提出的方法以及EAS算法的表现明显优于TB算法.相比较与TB算法,本文提出的方法能减少平均18.6%的能耗.上述结果得益于本文提出的能效感知的任务调度算法.通过将具有相同最低操作电压/频率的任务调度到同一个处理芯核,处理芯核可运行在所调度的任务的最低电压/频率上,从而最大程度地降低任务执行能耗.相反,TB算法将高功耗和低功耗任务组合在一起调度到同一个核栈上.这种做法虽然可以实现核栈间的功耗平衡,但却难以对能耗的优化产生积极作用.另一方面,由图6所示,虽然在能耗优化方面,本文提出的方法与EAS算法的效果相当.然而,相比较于EAS算法,本文提出的方法在优化能耗的同时可以有效地降低芯片温度.如图6(b)所示,实施本文提出的方法时,芯片温度略低于TB算法.在达到几乎相同的能耗优化结果的前提下,实施本文提出的方法所产生的芯片温度大大低于EAS算法.与EAS算法比较,本文提出的方法能降低平均5.6的峰值温度.以上对于温度的优化效果主要得益于本文提出的任务迁移算法.通过在核栈间交换或迁移少量的任务,以较小的影响能耗优化为代价,本文的方法可以实现有效的功耗平衡,同时降低了芯片温度.由上面两方面的比较结果可知,相对于TB和EAS算法,本文提出的方法可以在能耗优化和降低温度两方面取得最佳的平衡.5.2.2热优化结果图7给出了采用3种优化方法后的任务图执行过程中的芯片平均温度数据.实验中,两组共10个任务图一个接一个的连续执行.每个任务图的执行时间被均匀地划分为10个执行时间片段.随后,将总共100个时间片段内的功耗痕迹(powertrace)送入HotSpot以计算所有核栈的平均温度.如图7所示,TB算法和本文提出的方法均能在核栈间实现温度平衡,达到较为理想的热优化效果.比较图7(a)和(c),采用本文提出的方法后,芯片平均温度还略低于TB算法.另一方面,由图7(b)所示,采用EAS方法后,芯片温度出现明显波动偏差.这是因为EAS算法在优化能耗的过程中并没有考虑热优化问题.上述数据也表明,面向三维芯片的能耗优化方法必须将热问题考虑在内.图710个任务图连续执行时的平均温度数据统计6结论面向采用VFI设计的三维多核SoC,本文提出一个硅后优化框架,在最小化系统能耗的同时,满足任务截止时间和系统热约束.提出的优化框架统一考虑任务调度和电压/频率分派,通过识别任务的最低操作电压/频率指导任务调度策略.同时,通过任务迁移算法平衡核栈的功耗,以达到降低芯片温度的目的.实验结果表明,本文提出的方法能够在降低系统能耗的同时,有效降低芯片温度.Page11
