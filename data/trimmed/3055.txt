Page1犔犚(犽)任意文法位置的断点调试方法许福金茂忠李虎宋淼(北京航空航天大学软件工程研究所北京100191)摘要LR(k)文法能描述所有确定型上下文无关语言,广泛应用于各类分析器生成器中.传统的LR(k)文法断点调试方法仅支持在产生式右部末尾设置断点(后文简称尾部断点),不支持在产生式右部中间位置设置断点(后文简称中间断点),这给分析器的开发和调试带来了不便.文中提出了一种新颖的LR(k)文法断点调试方法,不但支持传统的尾部断点,还支持中间断点.该方法可显著增加可利用的断点数量,可以跟踪到更细粒度的文法成分,从而帮助用户更好地进行文法调试,降低分析器的开发难度.关键词LR(k)文法;文法调试;断点调试1引言LR(k)文法广泛应用于计算机语言的语法定义,它只要求向前看k个符号即能做正确的自左至右的语法分解,在各类分析器生成器中有广泛应用.由于分析器开发的复杂性,目前绝大多数分析器都是通过分析器自动生成工具生成的,越来越多的普通软件开发者利用分析器生成器来构造各种程序分析工具[1].与分析器设计领域的专家不同,普通开发LL(k)文法采用自顶向下的递归下降分析方法,文法和分析器间有明显的结构对应关系,可以借助传统的源码调试工具(如GNUgdb[2])进行调试.然而,对于LR(k)文法,却没有类似的源码调试工具可用.这是因为LR(k)文法采用自底向上的分析方法,文法和分析器间没有明显的结构对应关系,利用源码调试工具难以实现分析器源码和对应文法的直观结构映射关系.LL(k)文法只是LR(k)文法的Page2子类,与LL(k)相比,LR(k)可以处理左递归,能描述所有确定型上下文无关语言,因而绝大多数的分析器生成器均基于LR(k)(或其子类)文法,因此有必要研究适用于LR(k)文法的调试技术.2基本定义本文假定读者具有文法、语言和程序分析方面的基础知识,有关内容可参见文献[3-6].下面介绍本文用到的几个相关定义.定义1.上下文无关文法.上下文无关文法是一个四元组G=(N,T,P,S).其中,N是非终结符的有限集,T是终结符的有限集,T∩N=;P是形如A→β的(重写)规则的有限集,A称为规则左部,β称为规则右部;S∈N,是文法的开始符号.定义2.LR(k)文法.LR(k)文法是上下文无关文法的真子集,可以描述所有确定型上下文无关语言,它采用自底向上的移进-归约分析方法,只要求向前看k个符号即能做自左至右的语法分解.定义3.文法位置、主要位置、衍生位置.文法位置是一个二元组[i,j],其中i表示产生式编号,j表示产生式右部第j个符号后的位置,j的取值范围为0j(产生式i右部符号数目).文法开始符号所在的产生式编号为0,其它产生式采用非重复的递增顺序编号.文法位置[0,0]和[i,j](j1)称为主要位置,文法位置[i,0](i1)称为衍生位置.图2给出了图1文法对应的文法位置.定义4.项目、初始项目、主要项目、衍生项目.文法G的项目是一个三元组[i,j,γ],其中[i,j]表示文法位置,γ表示向前看符号集.项目[i,j,γ]也可以表示为A→α·β{γ}.[0,0,$]称为文法的初始项目.项目[i,j,γ]是一个主要项目当且仅当[i,j]是一个主要位置,项目[i,j,γ]是一个衍生项目当且仅当[i,j]是一个衍生位置.定义5.空非终结符.空非终结符是一个特殊的非终结符,它唯一出现在文法中的某条规则左部,该规则右部为空字符串ε.3断点类型判定算法传统的LR(k)文法断点调试方法仅支持尾部断点,不支持中间断点,这是LR(k)分析方法的一个固有属性,因为断点可被视为特殊的语义动作,而标准的LR(k)分析方法只支持在产生式末尾(即在执行归约动作时)调用语义动作,不支持在产生式右部中间位置调用语义动作[3],这给分析器的开发和调试带来了不便.在产生式右部中间位置设置断点,是很多程序设计语言分析和处理中的一个常见需求,例1给出了一个例子.例1.图3是一段典型的C语言if判断语句,其对应的汇编代码如图4所示.其中的a‖b为逻辑表达式语句,C语义规定,先计算a的值,如果a为真,则逻辑表达式a‖b也为真,不再进一步计算b的值,图4地址0040D43D和0040D441处的语句说明了这点.“cmpdwordptr[ebp-4],0”,首先比较“dwordptr[ebp-4]”(即变量a)的值是否为0,如果不为0,则表达式a‖b的值为真,直接执行“jnemain+39h(0040d449)”,跳转到地址0040D449处,执行“movdwordptr[ebp-0Ch],1”(即执行语句c=1).图5给出了a‖b对应的逻辑表达式语句的产生式规则.若要开发一个C语言动态分析程序,计算逻辑表达式a‖b的值,就需要在‖前设置断点(图6).Page3通过对文法进行简单变换,给其引入空非终结符,则可以使标准的LR(k)分析方法支持产生式右部中间位置的断点调试.比如,对于图5所示文法,可以在第一个expr后插入一个空非终结符X,然后在新添加的产生式(图7中的规则2)末尾设置断点.空非终结符只推导出空串ε,因此插入空非终结符后得到的文法与原始文法识别的语言相同.然而,并不是所有的文法位置都可以插入空非终结符,在LR(k)文法的某些文法位置插入空非终结符,可能会引入分析冲突,导致变换后的文法不是LR(k)文法,造成分析算法识别失败,例2给出了一个例子.例2.图1所示文法是LR(1)文法,如果在“规则1”右部的符号E之前插入空非终结符X,将导致变换后的文法不再是LR(k)文法(图8).由语义处理需要而插入的空非终结符,如果导致了语法分析冲突,一般有两种处理策略:(1)只执行与分析树(分析森林)构造有关的语义动作,延迟执行其它语义动作,待分析树(分析森林)构造完毕后,进行第2遍处理,执行其它语义动作.有文献称这种策略为“两遍编译”(two-passcompiling)[7];(2)改写文法消除分析冲突.YACC[8]采用这种处理策略.如果插入语义动作后引入了分析冲突,YACC要求改写文法消除冲突,否则采用YACC的缺省冲突处理规则处理:①移进-归约冲突,选择移进;②归约-归约冲突,选择先声明的产生式执行归约.对断点调试来讲,这两种处理策略均不合适.第1种策略的缺陷在于,必须在分析树(分析森林)生成完毕后才能执行相应的语义动作,而断点调试要求在语法分析过程中执行语义动作,这时分析树(分析森林)尚未生成完毕;第2种策略的缺陷在于,普通软件开发者难以掌握并熟练应用文法改写技巧.文法改写是一项高度专业并十分困难的软件开发活动,改写过程中要遵循复杂的等价变换规则,并且改写文法极易出错,导致改写前和改写后的文法定义的语言不一致,而这种不一致性无法通过程序自动验证判断,因为文法的等价性在形式语言理论中属于不可判定问题[4].此外,断点本质上不是文法的有效组成部分,调试完毕后,由于断点调试需要而插入的空非终结符,还需要从文法中删除,这需要再次修改文法.从上面的分析可看出,通过修改文法解决插入断点造成的分析冲突,在断点插入和删除后需要两次修改文法,工作量很大,因而是不可取的.综上,通过简单的文法变换,插入空非终结符,并在新添加的产生式末尾添加断点,不能解决中间断点的文法调试问题.因此,需要设计相应的算法来区分不同的断点位置,以判断哪些位置能插入断点,哪些位置不能插入断点.本文引入了两个新的概念:有效断点位置和无效断点位置,来区分不同的断点类型.定义6.有效断点位置、无效断点位置.对于LR(k)文法G,令为不包含文法位置[i,j]的其它任意文法位置的集合,=∪[i,j],在插入空非终结符后得到文法G,在插入空非终结符后得到文法G.文法位置[i,j]是一个有效断点位置,当且仅当对所有的,要么文法G和G都是LR(k)文法,要么都不是.如果文法位置[i,j]不是有效断点位置,则称其为无效断点位置.简单来说,如果在文法位置[i,j]处插入断点,不会造成分析冲突,则[i,j]是有效断点位置,否则[i,j]是无效断点位置.根据定义6,算法1给出了一种直观的断点类型判定算法.算法1.直观断点类型判断算法(计算所有文法位置).输入:LR(k)文法G=(N,T,P,S)输出:文法G的每个文法位置的断点类型判定,即有步骤:1.在文法G[S]的文法位置[i,j]处,插入空非终结符X,得到扩展文法G[S];2.为文法G[S]生成LR(k)分析表.检查分析表中是否存在冲突,如果不存在冲突,则说明位置[i,j]为有效断点位置,否则为无效断点位置;文法位置的断点类型.3.对所有文法位置,重复执行步1和步2,计算出所有根据定义6可知,算法1是正确的.算法1的缺Page4陷在于速度太慢,因为对每个文法位置,都要构造一次LR(k)分析表.文法规模一大,计算开销将迅速增加.以本文第5部分提及的Java1.4文法为例,其LALR(1)文法包含278条产生式,2690个文法位置,生成一次LALR(1)分析表平均耗时0.057s.根据算法1,计算完2690个文法位置共需要:2690×0.057s=153.33s.考虑到Java文法很规整,在程序设计语言文法中属中等复杂度文法,如果是C++等复杂语言文法,耗时会更长,因此,算法1不能满足交互式断点调试的需要.如果文法是固定不变的,可以仅执行一次计算,把断点类型信息存储到一个表中.以后每次调试时,不再执行计算,直接查询该表,就可以获知每个位置是否是有效断点位置.然而,文法调试的主要动机就是修正文法中可能存在的错误,这个阶段,文法一般还未定型,需要频繁修改.因此,这种方法也不可行.另外一种可能的解决办法是,只对用户实际设置断点的文法位置进行计算判断,而不是像算法1一样,对所有的文法位置进行计算,如算法2所示.算法2.直观断点类型判断算法(计算用户实际插入断点的文法位置).输入:LR(k)文法G=(N,T,P,S)输出:文法G中用户插入断点的文法位置类型判定,即步骤:1.在用户设置断点的文法位置[i,j]处插入空非终结符X,得到扩展文法为G[S];2.为文法G[S]生成LR(k)分析表.检查分析表中是否存在冲突,如果不存在冲突,则说明位置[i,j]为有效断点位置,否则为无效断点位置;即可判定出所有插入断点位置的断点类型.3.对所有插入断点的文法位置,重复执行步1和步2,算法2仅计算实际设置断点的文法位置,不计算所有文法位置,因而,算法2比算法1执行速度快.算法2的不足有两点:(1)当用户设置的断点数目较多时,计算开销也会很大,因为每个断点都需要生成一次LR(k)分析表,难以满足交互式调试的时间响应需求;(2)断点只能在调试开始前预先设置好,调试过程中不能动态添加断点.这是因为,调试前仅判断了用户插入断点的文法位置,没判断其它文法位置,如果调试过程中添加断点,可能引入新的分析冲突,造成分析失败.本文算法可以解决算法1和算法2的不足,仅生成一次LR(k)分析表即可计算出所有文法位置的断点类型,调试前和调试过程中可以动态添加、删除断点,拥有较高的时间性能,能满足交互式调试的时间需求.本文算法借鉴了Purdom等提出的部分状态位置图[9],利用部分状态位置图来区分不同的断点类型.在正式介绍算法前,先介绍几个相关的定义.定义7.前驱决定结点、直接前驱决定结点.对于有向图G=(V,A,r),其中V表示顶点集合,A表示有向边集合,r表示开始结点,V中除了开始结点r外的其它结点都可以从r经过一条或多条有向边到达.如果从结点r到结点v的每一条路径都经过结点w,则称结点w为结点v的前驱决定结点.如果p和q是G的结点,p是q的前驱决定结点当且仅当从r到q的每一条路径都经过p.结点p是结点q的直接前驱决定结点当且仅当p是q的前驱决定结点,并且q除了p以外的其它任何前驱决定结点也是p的前驱决定结点.定义8.部分状态(x,α).对于给定的状态x,(x,α)表示状态x的部分状态,其中x是状态编号,α是向前看符号,(x,α)表示状态x中以α为向前看符号的所有项目的集合.任何一个状态都由一个或多个部分状态组成.每个部分状态(x,α)包括下述项目:(1)任何可移入某个终结符或者用某条产生式归约的项目d;(2)任何可推导出d的主要项目(令这些主要项目的集合为M);(3)任何在M的闭包[5-6]中并且可以推导出d的项目.定义9.部分状态位置图.对于每个部分状态(x,α),都存在一个对应的部分状态位置图(PartialStatePositionGraph,PSPG).PSPG由一个初始结点(用I表示),一个或多个终止结点(用E表示),一个或多个动作结点以及一个或多个中间结点组成.PSPG是一个有向图,其中的有向边表示项目间的ε转换关系.比如,有向边a→b(其中a、b既不是初始结点,也不是终止结点,而是PSPG中的中间结点或动作结点),表示结点a通过一次ε转换可变换到b.从初始结点I到M(M的含义见定义8)中的每个元素都有一条有向边,从d(d的含义见定义8)到终止结点E也有一条有向边.除初始结点和终止结点外的每个结点(即中间结点和动作结点)都对应一个文法位置.图9是一个算术表达式文法,表1给出了该文法的初始状态0对应的LR(1)分析表.从表1可看出,状态0共包含两个部分状态:(0,i)和(0,(),其对应的部分状态位置图如图10和图11所示.Page5State项0T→.TP{$+}S5S6174S→.E${ε}E→.E+T{$+}T→.T{$+}T→.P{$+}T→.i{$+}E→.(E){$+}图10部分状态(0,i)对应的部分状态位置图图11部分状态(0,()对应的部分状态位置图部分状态位置图中的结点可分为两大类:特殊结点和中间结点.(1)特殊结点包括3个子类:①初始结点I,图10中对应结点0;②终止结点E,图10中对应结点8;③动作结点,可能的执行动作包括3类:shift、reduce、accept,图10中的动作结点为结点7.(2)中间结点根据中间结点和动作结点的关系不同,可把中间结点分为两个子类:①动作结点的前驱决定结点,图10中对应结点1,3,6;②动作结点的非前驱决定结点,图10中对应结点2,4,5.根据结点是否包含自旋(可以推导出自身的结点为自旋结点,否则为非自旋结点),可把中间结点分为两个子类:①自旋结点,图10中对应结点2;②非自旋结点,图10中对应结点1,3,4,5,6.定理1.对于LR(k)文法G[S],其部分状态位置图中的自旋结点对应的文法位置为无效断点位置.证明.根据定义,自旋结点可以推导出自身,因此自旋结点对应的项目可以抽象为E→.Eγ(其中γ为一个、多个终结符或非终结符的组合),令该产生式编号为i,则自旋结点对应的文法位置为[i,0].在文法位置[i,0]处设置断点,需要插入空非终结符X,变换后得到的产生式为E→.XEγ.产生式E→.XEγ迭代n次后可得到句型Xnβγnη,其中β、η为一个、多个终结符或非终结符的组合.若β恒为空串ε,说明γ和E能且只能推导出ε,因此,规则E→Eγ蜕化为E→E和E→ε,E→E是有害规则[6],不应出现在文法定义中,因此,β不恒为ε.同理,γ也不恒为ε,否则E→Eγ蜕化为E→E,为有害规则.令添加空非终结符X后得到的文法为G[S].因为Xnβγnη是文法G[S]的句型,若G[S]是LR(k)文法,则可通过向前看k个符号识别句型Xnβγnη中的Xn.而句型Xnβγnη要求Xn后必须要跟着βγn,因为β、γ不总为ε,因此,至少要向后看n+1个符号才能识别Xn.产生式E→.XEγ迭代次数n可为任意次,而k为固定值.令n>k,则实际向前看符号长度k小于识别Xn必须的n+1,因而G[S]不是LR(k)文法.因此,自旋结点对应的文法位置为无效断点位置.对于LR(k)文法,Purdom证明了在PSPG的动作结点的非前驱决定结点位置插入语义动作,可能会引入分析冲突,也可能不会引入分析冲突[9].根据本文的断点类型定义,这些位置都是无效断点位置(定理2).定理2.部分状态位置图中,动作结点的非前驱决定结点对应的文法位置为无效断点位置.Purdom方法中,除自旋结点和动作结点的非前驱决定结点外,其它位置都归类为自由位置,可自Page6由插入语义动作而不会引入分析冲突.这个结论是不正确的,因为一个状态可能有多个PSPG,在这些PSGP中独立应用Purdom方法,有时会得出矛盾的结论.比如,图12文法的LR(1)分析表初始状态有两个PSPG(图13).根据Purdom方法,图13(a)中的结点2不是动作结点的前驱决定结点,因而结点2处不能插入语义动作;图13(b)中,结点10不是自旋结点,且结点10是动作结点的前驱决定结点,因此结点10处可插入语义动作.实际上,结点2和结点10是同一结点,但从同一状态的两个PSPG中,却得出了矛盾的结论,其原因在于,没有把结点2和结点10在所有PSPG中比较判断.对于某个结点n,若n为非自旋结点,且n在所有PSPG中均为动作结点的前驱决定结点,结点n处才可插入语义动作,即有效断点位置.合并某一状态的所有部分状态位置图中的相同结点得到的图称为状态位置图(StatePositionGraph,SPG)[17].比如,合并图13中的两个PSPG,可得到图14的SPG.图14合并PSPG中的相同结点得到SPG的过程定理3证明了,结点n在所有PSPG中均为动作结点的前驱决定结点,当且仅当n在SPG中是所有动作结点的前驱决定结点.这样,计算有效断点位置转化为查找SPG中的所有动作结点的前驱决定结点.定理3.对于LR(k)文法G[S],结点n在SPG对应的所有PSPG中都是动作结点的前驱决定结点,当且仅当结点n是SPG中动作结点的前驱决定结点.证明.充分性.若n是SPG中动作结点的前驱决定结点,则在SPG对应的PSPG中n也是各个动作结点的前驱决定结点.根据SPG定义,SPG由各个PSPG合并得到,因而各个PSPG是SPG的子图.若n是SPG中动作结点的前驱决定结点,则n也必然是各个子图动作结点的前驱决定结点,PSPG是SPG的子图,因而n也是各个PSPG中的动作结点的前驱决定结点.必要性.若n是各个PSPG中动作结点的前驱决定结点,则在SPG中n也是动作结点的前驱决定结点.根据前提条件,n是各个PSPG中动作结点的前驱决定结点,因此,在某个PSPG中,从初始结点I到动作结点A,存在一条路径p1,且n是路径p1上的一个结点.SPG由各个PSPG合并得到,因此,动作结点A也是SPG的动作结点,且p1路径存在于SPG中.假定n不是SPG中动作结点A的前驱决定结点,则从SPG的初始结点I到动作结点A存在另外一条路径p2,且p2不经过结点n.因为p1和p2都包含动作结点A,因此它们在同一个PSPG中.因为n不是p2路径上的结点,路径p2中从初始结点I到动作结点A不经过n,因此,n不是该PSPG中动作结点A的前驱决定结点,这与前提条件矛盾.因此,n是SPG中动作结点的前驱决定结点.证毕.从定理1~3可看出,可采用算法3来计算算法3.断点类型判断算法(基于SPG).输入:LR(k)文法G=(N,T,P,S)输出:文法G中所有文法位置的断点类型判定,即有LR(k)文法的断点类型.步骤:1.为LR(k)文法生成LR(k)分析表;2.为LR(k)分析表中的每个状态构造SPG;3.对步2中每个SPG,重复执行步4~6;Page74.对某个SPG(令其为M),计算M中的自旋结点,把自旋结点对应的位置标记为无效断点位置;5.计算M中动作结点的前驱决定结点,把动作结点的非前驱决定结点位置标记为无效断点位置;6.把M中其它未标记位置标记为有效断点位置.下面对算法3各步骤采用的具体算法及每个具体算法的时间复杂度做一下介绍和分析.步1,生成LR(k)分析表,具体算法可参考文献[5].随着k的增大,分析表的状态空间在最坏状态下为指数增长[4],分析速度也会变慢.因此,实际中一般取k=1,生成LR(1)分析表可在线性时间内完成[4].步2,为每个状态生成SPG,SPG的具体构造算法见算法4,算法4也可以在线性时间内完成.步4,查找SPG中的自旋结点,执行速度取决于图中的顶点数|A|和有向边的数目[V],本质上是侦测图中的环路,是一个线性复杂度算法[10].步5,计算动作结点的前驱决定结点,可采用图论中的决定结点查找算法(dominatorsearching)[11].Purdom使用了一个近线性时间(almostlinear-time)算法,速度较慢.Harel[12]、Alstrup[13]、Buchs-baum[14]等提出了一系列改进算法,然而,这些算法仍存在一定缺陷.2004年Georgiadis和Tarjan提出了一个改进的线性时间算法[15],修正了以前算法的不足,本文采用该算法作为动作结点的决定结点查找算法.步6,标记其它所有未标记结点,需要的时间取决于SPG中的结点数,也可以在线性时间内完成.通过上述分析可看出,算法3的每个步骤均可在线性时间内完成,算法3是一个线性时间复杂度算法.算法4.状态位置图(SPG)构造算法.输入:LR(k)文法G=(N,T,P,S)及其LR(k)输出:每个状态对应的SPG步骤:1.对M中的每个状态n,执行步2~4;2.为状态n创建SPG的初始结点In;3.为状态n中的每个主要项目mi创建新结点Nmi,从初始结点In到Nmi添加一条有向边;4.检查步3中的每个主要项目mi,从算法4可看出,构造SPG的过程和LR(k)分析表的生成过程类似,只是增加了生成初始结点、动作结点和终止结点的过程.如果把SPG的构造过程合并到LR(k)分析表的生成过程,则一些公共步骤,如计算项目(集)闭包等,只需要计算一次,这样可获得更好的时间性能.从算法4可看出,除了增加特殊结点外,构造SPG的时间,与生成LR(k)的分析表生成时间相当.4支持中间断点和尾部断点的文法断点调试方法标准的LR(k)分析方法不支持在产生式右部中间调用语义动作,要支持产生式右部中间位置的断点调试,必须在相应位置插入空非终结符.这些空非终结符应该由调试器自动添加.考虑到添加空非终结符可能会引入分析冲突,造成转换后的文法不是LR(k)文法,导致LR(k)分析方法失效,因此,调试器应该利用算法3来判别断点类型,计算哪些位置可以插入断点,哪些位置不可以插入断点.算法5给出了同时支持中间断点和尾部断点的LR(k)文法断点调试算法.算法5.支持中间断点和尾部断点的文法断点调试算法.输入:LR(k)文法G=(N,T,P,S)和用户设置的断点步骤:1.利用算法3计算所有有效断点位置集合M;2.在集合M的每个中间断点位置插入空非终结符,为了区分不同的断点位置,插入的空非终结符名称应各不相同,令插入非终结符后得到的文法为G;Page83.为G生成LR(k)分析器;4.调试器加载步3生成的分析器执行调试,对输入串进行分析,直至遇到归约动作.检查归约动作对应的产生式p和用户设置的断点集合B,若产生式p中的文法位置不在集合B中,则说明用户没有在p中设置断点,继续分析过程.若p中的某个文法位置[i,j]在集合B中,检查[i,j]是否在集合M中,若[i,j]在M中,则说明其为有效断点位置,调试器暂停分析过程,显示调试信息.若[i,j]不在M中,则说明用户设置了一个无效断点,调试器提示用户,同时忽略该断点,继续分析过程;调试器应根据实际断点设置动态更新集合B.5.调试过程中,根据需要用户可动态添加或删除断点,算法步2之所以在每个有效的中间断点位置都插入空非终结符,主要是为了支持调试过程中动态添加断点.从算法5可看出,插入空非终结符后得到的文法是G,调试用的分析器是根据文法G生成的,在所有有效的中间断点位置都插入空非终结符,可以确保用户在调试前或调试过程中设置在有效断点位置的断点,总能被有效暂停.在调试开始前,若只在用户实际设置断点中的有效中间断点处插入空非终结符(令变换得到的文法为G),调试过程中将不能动态添加断点,因为若动态添加断点,则新得到的变换文法为G,G不同于G,而调试器加载的是G对应的分析器,因此需要停止分析过程,重新为G生成分析器.除步2外,算法的其它步骤均直观易懂,此处不再赘述.5实验结果一个实用的调试器必须有足够快的响应速度.从算法3、算法4和算法5可看出,LR(k)分析表生成,SPG构造和断点类型判定是任意文法位置断点调试的3个核心子算法,本文进行了3组实验来测试其性能①.5.1犔犚(犽)分析表自动生成性能与LALR(k)分析表相比,LR(k)分析表往往包含数目巨大的状态空间.尽管LALR(k)识别能力比LR(k)弱,但状态空间小得多,且识别能力接近,因此,LALR(k)在实际中应用更广.我们选择实际应用最广的LALR(1)分析表,来测试其自动生成性能.Earley证明了图15文法的LR(k)分析表状态数随着n的增大呈指数级增长[16].该文法很适合测试分析表的自动生成性能,表2给出了该组文法在n=2~8时的LALR(1)分析表的自动生成时间.表3给出了Java1.4文法的LALR(1)分析表自动生成时间.n状态CPU时钟2257413443784255586817507829662997278956990971031468143093218835131888599946893579.6477状态448典型的程序设计语言文法,其LALR(1)分析表一般包含几百个状态,即使是比较复杂的C++文法,其LALR(1)分析表也仅包含约1200个状态[17],与表2中文法n=5和n=6的状态数相当,与Java文法的状态数基本在同一数量级,其分析表的自动生成时间与Java文法具有可比性.从表2和表3可推断出,典型的程序设计语言文法,其LALR(1)分析表的自动生成时间大约在0.1s左右,可以满足交互式调试的时间响应需求.5.2SPG构造性能表4给出了图15文法在n=2~8时的SPG构造时间,表5给出了Java1.4文法的SPG构造时间.从表4和表5可看出,与Java1.4文法规模相当的程序设计语言文法,其SPG构造时间大约在0.005s左右,可以满足交互式调试的时间响应需求.n状态CPU时钟225583613378111912842555960010586825990414629971167589837103145897130208351312176746289①3组数据均在我们研制的VPGE分析器自动生成器原型系Page9状态4485.3断点类型判定算法性能在断点类型判定算法中,有两个问题是重要的:一个是算法的执行速度有多快;另一个是对于典型的程序设计语言文法,该算法可以增加多少可用断点.对于第1个问题,本文测试了Java、C、Pascal3种常用程序设计语言文法的断点类型分类算法执行时间,表6给出了实验结果.因为断点类型判定采用的决定结点查找算法是线性的,从表6可推断出,和Java规模类似的文法,断点类型判定时间大约在0.03s,可以满足交互式断点调试的时间响应需求.表63种常用文法的断点类型判断算法性能Java4482782690232636448364310.0032C4872412178146071856381290.0037Pascal3271951592128131137451860.0025对于第2个问题,从表6可看出,在Java文法中,有效断点和无效断点的百分比分别是86.47%和13.53%.一般情况下,每条产生式右部平均至少有两个符号,即每条产生式平均至少有3个断点位置.传统的断点调试方法只支持尾部断点,因此最多有33%的可用断点位置.考虑到平均情况下产生式右部符号一般远多于两个,因此传统断点调试方法可利用的断点数量一般远低于33%.以表6的Java文法为例,其LALR(1)文法共包含278条产生式,利用传统断点调试方法,最多有278个可用断点,有效断点位置占所有断点位置的百分比为10.33%.采用本文断点调试方法,可利用的断点数目是2326,远高于传统方法的可用断点数量.6结论本文的文法断点调试方法,不仅支持传统的尾部断点,还支持中间断点,可显著增加可供调试的断点数目.可用断点数目增加带来的益处是可以跟踪到更细粒度的文法成分,从而帮助开发者更好地理解语法分析过程,有效降低分析器的开发难度.本方法的另一个优点是很容易集成到现有的各种LR(k)(及子类)分析器生成器中,具有较为广阔的实际应用价值.7进一步工作当用户启动调试器调试文法时,与前次调试过程相比,即使只添加、删除或修改了一条产生式,LR(k)分析表生成、SPG构造和断点类型判定也必须重新执行.对于复杂的大型文法,每次的计算开销会很大.因此,在后续的工作中,需要开发增量的LR(k)分析表生成、SPG构造和断点类型判定算法.这样,当变更少量文法产生式时,采用增量算法可以获得更好的时间性能.
