Page1基于有限约束满足问题的溢出漏洞动态检测方法陈恺1),2)冯登国2)苏璞睿2)1)(中国科学院信息工程研究所信息安全国家重点实验室北京100195)2)(中国科学院软件研究所北京100190)摘要溢出型漏洞是最为普遍且最具危害的漏洞类型之一,溢出漏洞检测也是目前国内外研究的热点问题.目前漏洞检测方法主要分为白盒测试和黑盒测试两类.前者主要针对程序指令进行漏洞分析,但存在效率较低、检测结果不准确等缺点;后者难以保证程序覆盖的全面性与测试数据的针对性.文中提出了一种基于有限约束满足性问题(ConstraintSatisfactionProblem,CSP)的溢出漏洞动态检测方法.在程序执行过程中,结合动态污点传播和动态循环分析,选取可能产生溢出漏洞的语句并生成CSP表达式,表达式包括语句的执行条件和漏洞产生条件两部分;通过对此CSP表达式化简求解,验证漏洞的存在性与漏洞的触发条件.该方法可直接分析可执行程序,解决了间接跳转、多态代码等静态分析中难以解决的问题.为了验证该方法的有效性,作者开发了一套原型系统并进行相关实验,结果表明该方法缩小了漏洞分析范围,提高了分析效率.关键词计算机安全;漏洞检测;动态检测;CSP;可执行程序1引言未知漏洞是黑客与软件开发者希望率先掌握的第一手资料.对于黑客,获取一定数量的未知漏洞,可以进入存在相应漏洞的计算机,进行权限提升,甚至可以进一步产生更大的破坏.在2005年6月17日晚,美国万事达信用卡国际公司宣布,一名黑客侵入了“信用卡第三方付款处理器”的网络系统,造成包括万事达、Visa、AmericanExpress和Discover在内各种信用卡高达4000多万用户的数据资料被窃,其中万事达信用卡用户高达1390万,Visa信用卡的客户则高达2200万.随着网络的不断发展以及各种软件数量和种类的不断增多,未知漏洞产生的危害更为明显.危害巨大的蠕虫几乎都是未知漏洞的产物.例如,众所周知的冲击波利用了微软的MS03-026漏洞,震荡波利用了微软的MS04-011漏洞,SQL蠕虫王利用了微软SQLServer的漏洞等等.因此,如何检测未知漏洞,成为软件安全工作的重中之重.目前主要的漏洞检测方法分为白盒测试和黑盒测试两类.前者多针对源程序进行静态漏洞检测,但由于多数软件不提供源程序,限制了这类分析方法的检测范围.人们试图将基于源程序的漏洞检测方法移植到可执行程序上,但可执行程序本身的不确定性降低了分析结果的准确性,例如间接跳转、指针别名[1-2]等都是目前静态分析中难以解决的问题,软件保护技术亦增加了分析的难度,例如多态、变形、加密等方式迫使静态分析甚至不能反编译出有效的代码.后者能够对可执行程序进行直接测试,但难以保证程序覆盖的全面性与测试数据的针对性.本文提出了一种面向可执行程序的溢出漏洞动态检测方法.在程序的执行过程中,对可能产生溢出漏洞的赋值语句生成CSP表达式,表达式包括语句的执行条件和漏洞的产生条件两部分.语句的执行条件指程序流程能够到达这条赋值语句及保持其符号表达形式所依赖的条件集合;漏洞的产生条件指漏洞被触发的条件,典型地,例如堆管理结构和栈中存放的子程序返回指针被破坏.最后通过对CSP表达式的化简求解确认漏洞的存在性.本方法采用在虚拟环境下执行的方式,可以准确地提取程序的执行环境,包括内存、寄存器等信息,避免了可执行程序本身的不确定性和软件保护措施带来的反编译问题.语句的执行条件仅依赖于当前语句执行路径上的条件集合,可由汇编语义表示,因此避免了源程序的使用.结合污点传播和循环分析的方式对CSP表达式进行化简,提高了分析效率.本文主要做了如下贡献:(1)提出了一种动态的溢出漏洞检测方法.在程序的执行过程中对程序可能引发溢出漏洞的程序点建立检测条件,并结合当前语句的执行条件建立CSP表达式.对表达式进行分析化简并求解验证,验证成功的结果可以直接作为漏洞的触发条件.避免了源代码的使用以及静态分析中由软件保护和二进制程序本身不确定性带来的问题.(2)提出了一个检测点筛选算法.本算法在建立程序分析树的基础上,结合动态污点传播和动态循环判定,选出数据依赖于外部输入的赋值语句或者循环控制节点依赖于外部输入的循环内赋值语句作为检测点.实验表明,此方法有效减少了检测范围,提升了分析效率.(3)建立了一套漏洞分析原型系统.本系统采用虚拟环境执行方式,直接对可执行程序进行动态漏洞分析.在此原型系统的基础上,我们进行了循环个数、污点传播效率、空间效率、时间效率和检测效果方面的测试.实验表明本系统缩小了漏洞分析的范围,提高了分析效率.本文第2节介绍漏洞检测的国内外现状;第3节详细介绍污点传播、检测点的选取、CSP表达式的构建与化简等内容;第4节针对原型系统进行相关实验并作分析;最后总结全文并讨论未来的研究方向.2相关工作漏洞的检测主要分为两类:一类是白盒测试,即对程序进行直接分析,从中寻找可能出现漏洞的检测点并进行验证;另一类是黑盒测试.此外,对漏洞利用代码进行被动捕获分析,从而有选择地确认程序中的漏洞[3-4]也是一种漏洞检测方法.白盒测试通过对程序进行直接分析进行未知漏洞检测.静态缓冲区溢出检测是应用较早也较为普遍的漏洞检测方法之一.BOON[5]在C语言源代码的基础上利用整数界限的方法检测未知漏洞.ARCHER[6]在Linux源代码以及其它源程序中发现过许多内存访问冲突,但是由于没有对指针进行建模,所以分析范围被限制.SPLINT和LCLINT[7]在源代码基础上进行了漏洞检测,为了提高准确性,Page3它们需要在源代码上增加注解,而且存在误报率较高的问题.Nguyen等人[8]使用了数据流分析消除程序运行时可能存在的错误,例如数组长度问题等,但是它需要20%左右的额外开销.Rugina等人[9]尝试分析程序内存访问时的指针值,但是此方法的分析结果不精确.Shankar等人[10]使用类型的分析方法进行了格式化字符串漏洞的检测,但不能分析整数溢出等其它因素引发的溢出问题.Cova等人[2]将输入标记为污点并进行传递,同时确定可能引发漏洞的点,当两者相遇时标记为漏洞,但这种方法存在大量的误报.UNO[11]使用ctree扩展编译器,对每个过程调用产生语法树,从而实现对未知漏洞的检测.Akritidis[12]使用编译器扩展方式对源代码进行标记修改并重新链接,利用运行时信息进行漏洞检测.这类方式需要对源代码重新编译才能发现漏洞,不仅方法复杂,而且在多数情况下不具备重新编译程序的条件,通用性不强.VEX[13]使用静态数据流分析方法对流模式进行更细致的定义,从而对浏览器插件进行源代码级别漏洞检测.Xie等人[14]将漏洞挖掘转换为SAT可满足性问题,利用已有针对可满足性问题的算法进行求解,但其对循环以及指针指向集的判断不精确,并且依赖于源代码的建模分析.EXE[15]利用动态方法进行了一定改进,但没有对检测点加以选择也没有进行路径条件化简,效率较低.KLEE[16]在其基础上对所有内存进行跟踪,引入表达式重写、约束独立性分析等多种优化算法进行优化求解,提高了检测效率与程序覆盖率.AEG[17]以KLEE为基础对文件进行符号化,并对网络等其它资源符号化,使用源代码进行漏洞静态分析并对可执行程序运行时内存结构进行动态分析,利用STP进行漏洞检测与自动化地生成利用代码.IntScope[18]将二进制程序转换为一种中间表达形式,使用静态符号执行方法对潜在整数溢出漏洞进行检测.夏一民等人[19]使用基于条件约束的越界访问检查方法.本类方法:多基于源代码检测,但是多数商业软件不提供源代码,例如Windows、Oracle等等,限制了此类方法的适用范围;多为静态检测,在指针别名、间接跳转的处理过程中,或多或少地存在误报率高、漏报率高、效率低下等缺点.本文提出的方法针对可执行文件,可以在缺乏源代码的条件下对二进制代码直接分析,解决了指针别名和间接跳转的问题,同时可以避免代码加壳、多态代码等抗反编译手段的影响.黑盒测试[20]将程序看作是黑盒,通过变换不同的输入,观察程序是否会出现异常,从而进行漏洞检测.这类方式由于不需要对程序进行分析,而仅对程序进行运行测试,所以速度较快.但是大多数情况下,此类方法仅能穷举有限个输入,并不能对所有的输入都进行测试,因此通过此方法验证程序多存在覆盖率低和输入数据针对性不强等缺点.Bisht等人[21]采用黑盒方式对网络应用程序服务端进行漏洞检测,在测试数据集生成过程中对客户端源代码进行分析,提高输入数据测试的有效性.Godefroid等人[22]通过对路径约束条件逐一反向变化并求解的方式进行路径覆盖,在此基础上进行黑盒测试,增加程序覆盖范围.Wang等人[23]提出校验和感知导向的黑盒测试技术,结合混合符号执行与细粒度动态污点跟踪技术,绕过校验和机制进行漏洞检测,解决了传统方式下遇到校验和防护机制时难以检测的问题,提高了黑盒测试的针对性和有效性.SmartFuzz[24]对多类整数漏洞进行检测,使用白盒方式对程序进行分析指导测试数据生成,结合黑盒方式进行漏洞测试,提高了测试效率与程序覆盖面.本文采用对程序本身进行分析的方法,因此很大程度上减小了漏报的可能性.通过捕获攻击从而对漏洞进行检测是一种被动的检测方式,这种方式主要用来检测已知但是未公开的漏洞.Pax、LibSafe[25]和e-NeXSh[26]通过修改操作系统,使得存在漏洞的软件即使在漏洞触发也不会引发危害.但其局限于开源的操作系统,并且一旦操作系统版本发生变化,这类软件本身也需要重新修改,通用性不强.文献[27]中提出了将子程序返回地址保存在处理器而非内存中,这样即使漏洞触发,漏洞利用程序也无法修改处理器中的返回地址.这种方法需要硬件的支持,适用范围较小.文献[28]中提出了一种基于数据流完整性检测的方法对程序进行保护.当攻击发生时,程序的完整性被破坏,Castro对比前后程序状态从而对攻击进行检测.此方法仍然需要对源代码进行分析,且不能解决指针的间接跳转问题.Kiriansky等人[29]提出了程序监管的概念,监视控制流的转移,当发现控制流与安全策略冲突时,确认攻击的存在.Bhatkar等人[30]使用了程序地址随机化的方法改变代码和数据对象的原地址,使漏洞不能被正常利用.Vigilante[3]使用信息流方式检测蠕虫等攻击,同时产生SCA通知其它的系统,但是它对系统的保护范围相当有限.MemSherlock[4]使用信息流方法,在攻击发生时确认漏洞可能发生的位置,但它也需要对源代码进行Page4预分析.值得注意的是,Vigilante和MemSherlock都不能对系统内核进行分析.此类漏洞检测方式为被动方式,仅能发现别人已发现的漏洞,并不能对未知的漏洞进行检测.本文所述系统使用虚拟环境,可以在不修改操作系统和计算机硬件的前提下,主动发现指定应用程序和系统内核本身的漏洞.3方法与基本原理3.1概述缓冲区溢出指程序向缓冲区内填充的数据超过了缓冲区的容量,从而覆盖了合法数据.这主要是在赋值过程中,未考虑缓冲区边界造成的,因此缓冲区边界检测成为了溢出漏洞检测的必要条件.传统方式主要从源代码角度进行缓冲区边界检测,但由于多数软件并不提供源代码,因此限制了这种方式的使用范围.继而人们以可执行程序为目标直接进行分析,但多延用传统的静态分析方法.静态方法难以解决可执行程序本身的不确定性问题,也无法处理软件保护手段所带来的反编译问题,造成了分析结果不准确、效率低下等缺点.为了克服上述缺点,我们采用动态方式进行可执行代码的分析.图1是漏洞分析结构图,包括虚拟环境和漏洞分析器两大部分.漏洞分析器是分析的核心模块,它由污点数据分析器、检测点选择器、CSP表达式生成器和循环检测器4个部分组成.具体的分析过程如下:首先在虚拟环境中加载待分析程序.使用虚拟环境进行分析,可有效隔离待分析程序与漏洞分析器,避免了两者处于同一执行环境中带来的相互影响;漏洞分析器也可以透明地从虚拟环境内部提取所需代码和数据,提高分析的可靠性.当待分析程序启动时,污点数据分析器为其分配影子内存.影子内存是真实内存的镜像,其中每一位表示真实内存是否依赖于外部输入.例如图1中,当待分析程序把接收到外部输入INPUT放入变量var时,var对应的影子内存即被置位.在程序执行过程中,影子内存是可传递的.在图1的分支语句中,mem依赖于var,所以mem对应的影子内存也被置位.在待分析程序执行过程中,检测点选择器选择合适的程序检测点,并由CSP生成器构造CSP表达式进行漏洞验证.为了减少漏报,需增加程序检测点的覆盖面;但是过多的检测点又会影响分析效率.我们使用污点传播方式和动态循环识别方式减少检测点的选取.污点传播由污点数据分析器进行管理,而循环识别由循环识别器在程序的分析过程中自动完成.最后进行CSP表达式的化简并求解.为了减少CSP表达式中的条件个数,CSP生成器分析条件表达式的组成部分,并选取与检测点直接相关部分进行求解(见3.6节).利用这种方式,可以避免使用效率低下的切片分析方法.由于分析过程是动态的,可以将CSP表达式中不依赖于外部输入的变量替换成为立即数进行化简.如果表达式可解,则漏洞存在,并且此解可以直接作为漏洞的触发条件.3.2污点传播污点传播[31]是一种有效确认变量之间是否相关的分析方法.由于漏洞检测点的选取过程中仅需要知道变量与输入之间的关系,因此这里选用影子内存进行配合分析.当程序变量与输入相关时,在影子内存上增加标记,标明其关系即可.传统分析过程中一般使用切片方法进行变量间关系的判别.程序切片是MarkWeiser在其博士论文中提出,对程序变量之间的依赖关系进行分析的方法.典型的有数据流切片[32]和基于图可达性[33]的切片方法,但方法复杂,效率较低.污点传播和影子内存相结合的方式可以避免使用程序切片,适合于动态分析.本文中,污点数据包括从网络、硬盘文件或者用户输入等外界获得的数据.因此污点源可以是网卡、硬盘或者是键盘等.这里我们在虚拟硬件层设置污点源,从操作系统底层直接进行操作,避免污点数据的遗漏.影子内存是真实内存的镜像,它的每一字节标志着真实内存对应位置的字节是否依赖于污点数据.同时我们在影子内存最前端扩充出若干字节,表Page5示CPU中的寄存器是否也依赖于污点数据.污点数据通过数据传送、算术操作、逻辑操作等指令进行传递的过程称为污点传播.不同的指令具有不同的传播方式,针对不同的方式,我们制定了相应的污点传播规则.以下是部分有代表性指令的污点传播规则,其它指令类似.数据传送指令:movop1,op2:T(op1)←T(op2)算术操作指令:addop1,op2:T(op1)←T(op1)∨T(op2);T(μ(add,PSW))←T(op1)∨T(op2)逻辑操作指令:andop1,op2:T(op1)←T(op1)∨T(op2);T(μ(and,PSW))←T(op1)∨T(op2)栈操作指令:pushop:T(esp)←T(op)其中T(op)→BOOL,表示op所指向的操作数是否为污点数据;PSW表示机器状态字;μ(op,PSW)→,表示op操作引发PSW中变化的位置,例如add操作会引起C、P、A、Z、S、O等标志位的改变;表示地址所对应的内存.注意add、and等算术指令会影响PSW的值,这里也必须引入,因为cmp等比较指令会依赖于PSW的值.值得注意的是,一些编译器为了增加效率,并不直接使用mov指令产生某些常数,而会使用一些效率较高的计算方法.例如为了产生常数0,编译器通常会生成“xoreax,eax”指令.此时即使T(eax)=1,也不需要将eax再次设置为污点数据.相反地,需要设置T(eax)=0.此类语句还有“subeax,eax”、“andeax,0”、“oreax,1”等.使用上述方法时,依赖于控制依赖关系的赋值操作会阻碍污点数据的传播,例如:switch(var1){case‘a’:var2=‘a’;case‘b’:var2=‘b’;break;…}假设var1是污点数据,以上的赋值操作并不能将污点数据传播到var2上.对于此类特殊情况,我们判断T(ξ(op,PSW))的值,其中ξ(op,PSW)→表示op依赖于PSW中的位置.在汇编程序中,op通常为jz等条件跳转语句.假设T(ξ(op,PSW))=1,则所有控制依赖于op操作的赋值语句都作为污点数据进行赋值.控制依赖具有一定的范围,计算方法如下.定义1.自然后继.语句Ii的自然后继表示此语句的下一标号所在语句Ii+1.定义2.跳转后继.语句Ii的跳转后继表示此语句跳转目标所在语句Iop.这里使用S:→表示语句的跳转后继,表示语句的标号.例如下面代码片段:1:jmp32:addeax,13:addeax,2语句1的自然后继为2,但是跳转后继为3.假设op所在语句为Im,当T(ξ(op,PSW))=1时,目前计算的被控制依赖影响的语句标号范围如下:[mini(P(m,i)),mini(i>m∧P(m+1,i)∧P(S(m),i))],P(i,j)→BOOL表示语句i和j之间是否存在通路.通过此方法就可以尽量避免由于控制依赖引起的条件遗漏问题.3.3CSP表达式的构造在程序的分析过程中,顺序语句具有这样的特性:程序流程始终是从顺序语句的第一条进入,最后一条流出,且这些顺序语句具有相同的执行条件.因此顺序语句可以当作一个整体看待.我们有如下定义.定义3.程序基本块.程序基本块是指由不包含或者仅在基本块末尾包含流程跳转指令的指令序列.后面简称为基本块,由B表示.块B分为4种类型:基本块,用CB表示.基本块,为J型基本块,用JB表示.块,为R型基本块,用RB表示.(1)出口语句为子程序调用的基本块,为C型(2)出口语句为直接跳转或者条件跳转语句的(3)出口语句为子程序调用返回语句的基本根据基本块出口语句类型的不同,可以将基本(4)其它基本块,为S型基本块,用SB表示.通过这种方式,基本块中的语句即可共享一个入口条件.在CSP构建过程中,我们使用动态方式进行循环识别,以增加检测过程对多态等抗反编译手段的分析能力.对于程序内不含子程序调用的每个基本块,我们按照其执行顺序进行标记,第1个基本块记为B1,并以此类推.如果一个基本块Bi在同一程序中被执行两次,则第2次仍保持原有标记,同时清除标记Bj(j>i),并对这些基本块次数重新计数.当有子程序调用时,在子程序内部,对基本块重新计数,并增加当前执行环境层次.当子程序返回时,继续子程序调用前的基本块序号,同时减少执行环境的层Page6次.我们使用S表示程序中出现的循环,t:B→n表示基本块B执行的次数,在程序执行过程中,有以下定理.定理1.在同一层次内,mini(t(Bi)=2)→Bi∈S且Bi是循环中的第一个基本块.证明.假设Bi不在循环中,则由于t(Bi)=2以及标记的顺序,存在两个节点j和k,使得j=i-1且k=i-1,因此j=k,则j是满足t(Bj)=2的最小标号,与题设矛盾,因此Bi在循环中.易知,Bi为循环中的第1个基本块.按照定理1可以很容易地在程序运行过程中判断某个基本块是否在循环S中.根据S本身的性质,可以将S使用如下特性进行表示:S(p,sp,σ,τ,χ,δ),其中p表示将被赋值的起始位置,sp表示关键数据域的位置,例如对于栈,sp表示子程序栈底的位置;对于堆sp表示堆管理结构的位置,σ表示循环步长,τ表示循环次数,χ表示每次循环进行覆盖的字节数,δ表示循环方向,如果是向着sp方向,δ=1,否则δ=0.根据这些信息,可以构造基本的溢出型CSP表达式.栈溢出和堆溢出是缓冲区溢出的两种基本形式,也是主要的漏洞形式.现在以IntelCPU为例,可以构造栈溢出表达式.定理2.栈溢出表达式:pi+1-pi>0∧(χ+σ)τ<sp-p,其中pi表示第i次被赋值的位置.证明.pi+1-pi>0δ=1,而(χ+σ)τ<sp-p保证了赋值操作不会超越栈基.因此栈溢出表达式是程序不含漏洞的必要条件.证毕.这里有两点值得注意:(1)对于栈仅考虑向栈基方向赋值,因为栈基方向存储着返回地址等程序运行过程中的重要信息,而且赋值点与栈基方向的距离较小,更容易产生溢出漏洞;而栈尾方向一般与赋值点距离很大,溢出概率小,即使发生溢出,也难以造成危害.(2)我们观察到,大多数情况下循环赋值的步长具有一致性.因此,为了简化分析过程,我们假设每次循环赋值的步长一样.如果要进行更精确的分析,仅需对于不一致的循环步长增加一项CSP表达式即可.对于堆溢出,需要监控待分析程序运行过程中的堆申请函数以确定堆H的起始位置和大小Hsize.由此可以构造堆溢出CSP表达式.定理3.堆溢出表达式:(pi-pi+1>0∧(χ+σ)τ<p-sp)∨(pi+1-pi>0∧(χ+σ)τ<Hsize-p),其中pi-pi+1>0δ=1,pi+1-pi>0δ=0,注意这里和栈溢出的方向区别,栈底一般在高地址,而堆管理结构一般在低地址.由于本分析方法是在汇编语言上分析,所以可以避免高级语言中由于整数类型不一致而产生的漏洞.例如下例是Linux内核XDR有符号整数溢出漏洞,第3行代表漏洞引发的原因,由于p是无符号数指针,如果其值过大,当将其内容转为有符号数时,会产生负数,自然通过第4行的界限判断,但是在第6行赋值操作时会引发漏洞:1.staticinlineu32decode_fh(u32p,structsvc_fh2.intsize;fh_init(fhp,NFS3_FHSIZE);3.size=ntohl(p++);4.if(size>NFS3_FHSIZE)5.returnNULL;6.memcpy(&fhp->fh_handle.fh_base,p,size);……}但是由于汇编语言本身就有有符号跳转与无符号跳转,因此仅需要对其跳转指令进行条件判断即可,不需要专门判断整数溢出产生的堆栈溢出问题.对于格式化字符串漏洞,当有恶意输入被写入时,本方法也能通过污点传播的方式检测出.将程序划分为基本块进行分析,同时保留其分析结果,当再次遇到已分析过的基本块时不用重新计算基本块内条件集合.这样每个基本块仅需分析一次,可以显著提高分析效率.堆栈表达式仅仅是赋值时所产生的表达式,多数情况下,为了判别此表达式的漏洞信息,还需要将此语句的执行条件加入CSP表达式.在程序执行过程中,漏洞分析器维持条件Sc,每当碰到新的条件语句C,即将C并入Sc,得到新的条件Sc∧C.但是当条件过多的时候,Sc会变的很大,因此需要对其进行分析选择合适的C,控制CSP表达式的长度.例如当得到CSP=p1∧p2∧…∧pn时,对于pi,如果x(x∈pi→T(x)=0),则可以直接删除pi,因为pi≡true,否则程序不能运行到此处.最后,将获得的CSP表达式使用STP[15]求解.若有解,则存在漏洞,并且其解可作为漏洞的触发输入.为了验证漏洞的有效性,可将此解作为输入重新运行程序观察漏洞触发情况.3.4检测点选取在程序中参与赋值运算变量的集合U中,仅有小部分变量UU可能造成堆栈溢出.因此选取合适的范围U,使UU且|U|尽量小就成为了提Page7高分析效率的途径之一.为了确定U的范围,检测点的选取分为两个步骤:首先进行静态分析,选取可能出现漏洞的位置并构造相应的输入使程序能够到达检测点;其次使用这个输入进行动态分析,对其路径上的语句进一步地选取检测点.静态分析时,使用DJ图[34]的方式对程序的循环进行分析,选取循环中的赋值语句作为初始检测点进行测试输入生成.多种方法可用来进行检测点选取,文献[35]提出可以根据不同版本间的差异进行选取,但由于我们直接分析可执行程序且不易获得版本间差异信息,因此这里我们选用一种启发式的方法,对于最复杂的循环优先检测,循环的复杂性通过循环中的语句数量及子程序调用数量判断,利用文献[22]中所述方法产生到达检测点的输入数据并以此为基础进行后续的动态分析.动态分析时,我们构建程序分析树T(V,E).其中,V为节点,代表每个基本块B;E为有向边,当E(Vi,Vj)=1时,表示存在Bi到Bj的程序流程.根据基本块的不同,可以定义3种类型的边:调用边μ:vi,vj∈V,μ(vi,vj)=1Bi∈CB∧E(vi,vj);返回边ρ:vi,vj∈V,ρ(vi,vj)=1Bi∈CR∧E(vi,vj);跳转边φ:vi,vj∈V,φ(vi,vj)=1(Bi∈JB∨Bi∈SB)∧E(vi,vj).算法1是程序分析树的构建算法.树的构建过程随着程序的启动开始,当程序结束时,分析过程结束.对于每个基本块Bi,根据基本块的类型分别建立树节点与不同类别的边.由于建立节点的时间为常数,利用建立分析树过程中每增加一个子节点构造一条指向其父节点指针的方式,也可以在常数时间内找出其父节点,因此假设当前程序执行路径P的基本块数量为nB,则算法1的复杂度为O(nB).如果程序的基本块总数量为NB,在一般情况下有nBNB.算法1.程序分析树构建算法ConsTree().输入:程序P输出:程序分析树T1.创建根节点R;2.创建子节点V0;3.μ(R,V0)=1;4.for基本块Bi∈Pdo5.switchBido6.caseBi∈CB7.增加子节点Vj;8.μ(Vi,Vj)=1;9.end10.caseBi∈RB11.i=当前层次;12.在i-1层找到其父节点Vk;13.增加Vk的兄弟节点Vj;14.ρ(Vi,Vj)=1;15.end16.caseBi∈JB‖Bi∈SB17.增加兄弟节点Vj;18.(Vi,Vj)=1;19.end20.end21.end通过程序分析树,可以选取尽量小的程序检测点集合进行分析,提高效率.设树中层次使用L表示.定义函数Lo:V→2L,表示包含某节点v的循环在树中的层次.当v属于多个循环时,返回层次集合;当Lo(v)=时,表示不存在循环.对于树中第l层的任意一个节点v,对应的基本块中有语句I:α←β,则算法2根据v所处的循环控制节点所依赖的变量p和α本身是否为污点数据决定I是否成为程序检测点.其中T(α)函数返回输入参数是否为污点数据,其复杂度为常数;Lo(v)函数通过该节点及该节点后续反回边可以向上遍历,其最坏可能性为树的高度,即O(log(nB)),但在实际运算过程中,由于每一层基本块的数量较多,且通过调用方式产生循环的数量更少,因此可假定需要分析的数量基本为常数,不妨设置为C,实验表明绝大多数情况下C<5.综上,算法2的复杂度为O(C).算法2.检测点选取算法PointerChecker().输入:程序分析树T,程序语句I:α←β输出:0,11.ifT(α)=1then2.return1;3.else4.ifLo(v)=then5.return0;6.else7.foralll∈Lo(v)do8.p=l层循环控制节点依赖的变量;9.ifT(p)=1then10.return1;11.else12.continue;13.end14.endPage815.return0;16.end17.end本文所述方法与基于多路径分析的全路径漏洞检测方法相比,本方法可以根据检测点的设定动态地对多条路径进行检测,如果检测点分布在各条路径上,即可对所有路径进行分析.该方法避免了对于没有检测点的路径进行分析的过程,减少了分析的路径数量,扩大了应用范围.3.5程序间漏洞检测算法由于基本块在程序内经常被共用,所以保存每个基本块的信息以备将来使用可以提高分析效率.以上CSP表达式构造算法并没有对程序间调用与基本块的信息重利用进行处理.本小节将介绍程序间的漏洞检测算法,能够重用已有信息,提高效率.相对于高级语言,汇编语言程序间的参数传递具有一定的特殊性:传递方式依靠寄存器与内存,没有高级语言中的形参和实参,所以分析过程中仅需要关心寄存器和内存即可.算法3随着程序启动开始执行,每次取当前执行的基本块B.如果B未被分析,则先计算B本身的CSP表达式并保存.当B中存在函数调用时,需递归地对其子函数进行处理.其次,使用Pointer-Checker算法选取B中的检测点并结合语句执行条件C生成CSP表达式.最后根据B的出口条件修改当前执行条件C并传递到下一个基本块.初始时,C=NULL.虽然算法3在第9行位置进行了递归调用,但每个子函数在分析完成后即将其状态记录,因此每个函数仅分析一次,其复杂度为O(nI),其中nI表示路径P中的指令数量.根据文献[36](参考3.6小节),化简CSP表达式的复杂度为O(nI).设nI/B表示基本块B中的指令数量,nCSP/B表示基本块B中的检测点数量,算法3的复杂度为O(nB×(nI/B+nCSP/B×(C+nI)))=O(nI+nCSP×(C+nI))=O(nCSP×nI),其中nCSP表示设置的检测点数量.算法3.程序间漏洞检测算法VulFinder().输入:程序P,标记mark,基本块信息集合Info,入口输出:CSP表达式集合R1.WhileP未结束do2.取当前基本块B;3.ifmark(B)==0then4.mark(B)=1;5.ifB∈CBthen6.F=目标函数;7.ifmark(F)==0then8.mark(F)=1;9.VulFinder(F,mark,Info,C);10.end11.CSP2=F的CSP表达式;12.将CSP2加入Info(B);13.end14.forallI∈B∧kill(I)≠do15.使用定理2和定理3建立堆栈溢出表达式16.将CSP1加入Info(B);17.end18.end19.forallCSP∈Info(B).CSP1∪Info(B).CSP2do20.I=CSP所在的语句;21.ifPointerChecker(I)==1then22.CSP=CSP∧C;23.化简CSP并加入R;24.end25.end26.ifB∈JBthen27.C=B的跳转条件;28.ifC==truethen29.C=C∧C;30.else31.C=C∧C;32.end33.end34.执行基本块B;35.end36.returnR;3.6CSP表达式的消减当程序较大时,CSP表达式也会相应增大,此时需要对CSP表达式进行化简.利用污点传播方法可以仅选取与外部输入相关的条件语句作为CSP表达式(EXE[15]方法),但该表达式仍然可以进一步简化.例如若节点1是分支语句,节点4是其后必经节点,节点2和节点3是从节点1到4间不同路径上的节点.设节点1的入口条件是C,两个分支条件为e和e-.现有分析方法在程序运行时,会记录程序运行过程中所有不能静态确定分支方向的条件集合,即CSP表达式中的条件会变为C∧e或C∧e-.假设检测点在节点2或3时,以上分析过程是没有冗余的,因为条件e或e-保证了检测点的运行条件.但若检测点在节点4处,条件e和e-的必要性并不明显,因为它们并未保证此时程序的运行条件.这类情况在循环中以及子程序调用过程中也会同样出现.Page9因此正确选择分支条件,可以减少分支的数目和路径表达式的长度.本文参考了文献[36],对路径条件进行分析,确定其基本组成部分,选取运行条件与值依赖条件进行求解,缓解了传统方式下由于路径条件过于复杂而难以求解的问题,提高了漏洞检测的效率.4实验与分析为了测试本方法的有效性和性能,我们以QEMU0.9.0为虚拟环境实现了漏洞分析的原型系统.计算机硬件使用Dell计算机,配以Intel奔腾IV3GHzCPU,1.5GB内存,安装QEMU的操作系统平台为Linux2.6.11.安装的虚拟操作系统为WindowsXP.目前的原型系统对数据转移类指令、算术操作指令、逻辑操作类指令和堆栈类指令进行了污点传播;实现了栈溢出和堆溢出漏洞的检测;污点源设置为从硬盘读取的文件与网络传递的数据.考虑到和黑盒测试方法差别较大,不易比较,本文选用白盒测试方法进行比较.EXE方法虽然针对源代码,但其思想最接近本文方法,本文选用其方法进行实现并比较.首先我们将从循环个数、污点传播的效率、内存的变化、时间效率等方面测试基于CSP的动态漏洞分析方法在效率和性能上的提升.程序执行过程中,为了判别当前基本块是否处于循环过程中,需要判断当前基本块是否在已知的循环集合内.已知循环集可以通过静态和动态两种MediaPlayer10223844AcrobatReader7221605Word2003168140Messenger119341Outlook200350985Excel200374482为了更加清楚地认识在污点传播过程中影子内存所占用的空间大小,我们记录了IE6等软件在分析过程中影子内存的空间占用量,并与EXE方法对比,单位是KB,如图3所示.图中发现在分析过程中,本方法对应用软件使用影子内存机制所占用的内存空间(包括堆栈)均不超过10MB,平均内存占用率仅为4.7MB.由于采用实时的影子内存记录机制,所以原型系统不需要使用整个进程空间的内存表1对比了InternetExplorer6等7款软件在执行过程中,内存存储操作的数量和在循环操作下以及引入污点传播模式产生的内存存储操作数量,从表中可以看出,引入污点传播模式下的内存存储操作数量平均仅占内存存储操作总数量的0.969%.由此说明污点传播过程虽然占用了一些运行时内存,但是极大地缩小了分析范围,提高了整个分析过程的效率.表1循环/污点传播效率表程序名称写内存数量循环中的写内存数量含污点数据的循环中写内存数量含污点数据的循环中写内存所占比例/%IE6方法求出,这个集合越小,对比判别的速度就越快.图2对比了InternetExplorer6等7款软件在静态分析和动态分析中所需比较的循环个数.为了分析静态过程中的循环个数,我们使用DJ图[34]的方法计算.从图中看出动态分析过程中的循环个数少于静态分析中的循环个数,提高了循环分析的效率.由于静态循环分析方法依赖于反编译部分的工作,因此还会受到多态代码等方法阻碍反编译的进行,导致正确率下降.动态分析方法的使用避免了上述缺点.1472682604166321221301770大小作为影子内存,而仅需要维护动态的堆栈内存即可;并且当目标程序退出时,相应的影子内存也会随之释放.因此,本原型系统具有较高的空间利用效率和更好的适应性.实验发现本文方法和EXE方法占用内存数量相同,其原因在于本文方法并不需要增加影子内存的使用量进行额外分析.图4是以IE6为例,记录了分析过程中影子内存大小(包括堆栈)随时间变化图.从图中可以看出,堆栈变化较为Page10平缓,因此可以花费较少时间在影子内存的管理上.图5是被检测软件在QEMU系统下、本原型系统以及EXE方法下的时间对比(时间单位为s),测试发现应用软件在本原型系统下的执行时间约是在QEMU环境下执行时间的3~4倍左右,本文方法与EXE方法分析时间相差并不大,由此说明本文方法对CSP表达式分析与化简并未占用大量的时间.由于本系统运行时间依赖于虚拟环境QEMU本身执行时间,任何虚拟环境效率的提升也会提高本系统的效率.选用效率更高的虚拟环境,例如Xen也是提高分析效率的方法之一.为了测试原型系统的实际分析效果,我们选用InternetExplorer6、MircosoftWord2003等软件作为测试对象,分别测试生成CSP表达式的个数、经删减无效条件后的检测表达式平均长度与使用EXE方法检测表达式平均长度的比值、检测出漏洞的个数、验证成功漏洞个数和漏洞误报个数.测试效果如表2所示.程序名称CSP长度比IE61470.27110MediaPlayer2680.19110AcrobatReader726040.35110Word200316630.11220Messenger21220.24000Outlook20031300.23000Excel200317700.12220从表2中可以看出,检测出的漏洞数量均为有效漏洞,没有误报,但是检测出漏洞个数少于公布出的漏洞个数.例如IE6.0,截至2008年4月8日,IE6已被发现327个漏洞,这里分析数量较少,原因有如下几个:(1)IE6百余漏洞中缓冲区溢出漏洞并不多,即使计入整数溢出,也只有30余个,并且多数并不是IE本身的问题,而是其它插件产生的漏洞.本原型系统目前仅分析堆栈缓冲区溢出漏洞,在未来的研究过程中将对其它漏洞类型进行分析.(2)在理想状况下,如果所有存在漏洞的路径被执行,所有缓冲区溢出漏洞都将被检测出;但本实验仅选取vgx.dll中可能的漏洞检测点相关路径进行检测,若想进行更全面的分析,可以放宽检测点选取规则,选取尽量多的检测点,例如将各模块中的赋值语句作为检测点进行计算.5结论本文在对可执行程序动态分析的基础上,通过将漏洞引发条件转换为CSP表达式并求解的方式进行程序的溢出漏洞检测.本方法可以在缺乏源代码的情况下进行漏洞分析,解决了静态分析过程中难以处理的多态代码等软件保护手段带来的问题和间接跳转等二进制代码本身的分析问题.实现了一个漏洞分析原型系统,对InternetExplorer6等7款软件进行了实际分析,发现了其中若干漏洞,且未产生误报,同时对相关性能做了测试,验证了本方法的有效性与高效性.Page11在今后的工作中,将会对检测点选取规则进一步分析优化,进行更全面、更高效的漏洞检测.此外,目前检测的漏洞类型为缓冲区溢出漏洞,今后将会对多次/二次指针释放、空指针读取、格式化字符串等其它类型的漏洞做出处理.
