Page1基于实体描述属性技术的XML重复对象检测方法李亚坤王宏志高宏李建中(哈尔滨工业大学计算机学院哈尔滨150001)摘要由于XML文档越来越广泛地被用于信息交换与集成,其数据质量问题引起了人们的关注.解决由数据质量引发的问题,实体识别技术非常关键.当实体识别被应用于XML数据中时,最为关键的操作是实体数据对象的匹配.为了克服现有方法的不足,在海量XML数据上进行高效的重复对象检测,文中提出一种基于实体描述属性技术的高效XML重复数据对象检测方法.它将所有标签属性与结点统称为属性,用实体来描述属性,通过属性的属性结点表的构建,快速地找到在某个属性上相同的所有实体对象,然后比较它们是否重复.此方法的优势体现在无需比较所有实体对象,只需要比较在属性结点表中同一位置的结点,大大节省了时间.此外,我们提出的Max-Merge算法,在兼顾相似对象传递性与独立性的基础之上,将所有相似对象进行聚类,大大提高了算法的精确率与召回率.关键词XML;数据集成;数据质量;实体识别1引言主要标准,其主要原因是其良好的可扩展性,以及其结构的灵活性.由于使用日趋广泛,XML文档的数据质量问题引起了人们的关注,如输入错误、各数据XML已经成为Web上数据交换与数据集成的源中数据的结构差异、表达方式不同等因素令XMLPage2文档中存在着大量的数据冗余,从而对数据发布、数据交互、数据集成及数据挖掘等操作产生不良影响[1].为了克服由数据质量引发的问题,研究人员已经提出许多技术[2-5],其中实体识别起着重要作用.实体识别是找到那些指向相同实体的数据对象.当实体识别被应用于XML数据时,最为关键的操作是实体数据对象的匹配.实体数据对象匹配是指判断两个数据对象是否指向同一真实世界的实体,如当两家书店合并以后,需要合并所有图书资料,可是有些图书可能分别存在于原来的两个数据源中,数据表现形式可能不同.〈booktitle="IntroductiontoAlgorithms,ThirdEdition"〉〈/book〉〈booktitle="IntroductiontoAlgorithms"edition="ThirdEdition"〉〈/book〉图1一个脏数据片段实体识别技术的许多方法已经在关系数据上提出并使用[6-9],但是由于XML数据结构多样,致使这些方法并不适用.近年来,一些在XML数据上识别实体的方法被提出来.第1种方法[10]为了解决元素多样性问题,先通过采用XQuery语言将结构不同的XML数据元素变换成统一的结构,再将同一层次的内容合并为一个元素来处理.但这种方法使原本具有不同标签的数据之间也进行相似性计算,因此得到的精度不高.第2种方法[1,11]将XML数据抽象形成为一个树,通过计算树之间的编辑距离得出对象相似度.这种方法的时间复杂度在O(|T(e)|×n2)数量级上,其中e为实体对象元素,n为实体数量.若实体的描述信息庞大,这种方法的效率将会非常低.第3种方法[12]将具有相似结构的XML元素进例1.图1是一个集成后的脏数据片段,在这个数据源中,4个元素都指向同一实体,但它们的表现形式有很大不同.不仅数据内容不尽相同,数据组织结构也有很大差异.如:元素1的书名中加入了版本号;元素2中的作者被写到了一起,publishdate以属性的形式给出;元素3中增加了版本属性、作者不全且多了一个publish结点;元素4中多了lan-guage、page、rank子结点.各元素的price中的数值也各不相同,并且还有些简单的拼写错误存在于各属性及属性值当中.〈booktitle="IntroductiontoAlgorithms"〉〈/book〉〈book〉〈title〉IntroductiontoAlgorithms〈/title〉〈author〉ThomasH.Cormen〈/author〉〈author〉CharlesE.Leiserson〈/author〉〈author〉RonaldL.Rivest〈/author〉〈author〉CliffordStein〈/author〉〈ISBN〉0262033844〈/ISBN〉〈price〉63.8〈/price〉〈publisher〉TheMITPress〈/publisher〉〈publishdate〉2009-9-30〈/publishdate〉〈language〉English〈/language〉〈page〉1312〈/page〉〈rank〉136663〈/rank〉〈/book〉行合并,提出了三类启发式聚类算法,分别使用全部比较聚类、选择比较聚类、M树聚类方法来实现重复元素的合并.主要不足在于没有解决XML数据结构多样性的问题.总而言之,现有方法的缺点可以归纳为三点:第一,这些方法需要将所有实体对象一一比较,效率不高;第二,这些方法不能区别对待各个属性及结点,从而产生的精确度不高;第三,现有方法可扩展性差,不适用于海量数据.为了克服现有方法的不足,在海量XML数据上进行高效的重复对象检测,我们提出一种基于实体描述属性的高效XML重复数据对象检测方法.这种方法将待识别元素定义为实体对象,将标签、属性和子元素都看作实体属性,用实体属性来辨识实体.通过属性结点表的构建,可以快速地找到在某个Page3属性上相同的所有实体对象,从而达到发现描述同一实体的不同数据对象的目的.此方法的优势体现在仅需比较在某些属性上值相同或相似的元素,而无需比较所有的实体对象,从而提高了效率.这种方法还通过抽取属性与结点值降低了XML数据中描述实体对象结构的复杂性.在本文的方法中,各个属性的权值根据其区分实体对象的能力确定,当得到两个候选对象后,将所有相似的属性的权值累加,若大于阈值则以二元组的形式输出.再通过使用Max-Merge算法,在兼顾相似对象的传递性与独立性的基础之上,将所有相似的对象进行聚类.本文的贡献如下:(1)提出了基于实体描述属性技术的高效XML重复对象检测算法.两个数据对象如果描述同一个真实世界的实体,那么它们很难在所有相应属性上都不同,因此我们重点考虑在所有不同属性中有若干属性相同或相似的情况.通过实体对象的改造、插入属性结点表、查询属性结点表进行重复对象的检测.使用这种算法进行XML数据的重复对象检测架构对于删除冗余是有效且实际的.(2)提出了有效的实体对象改造方法.经过改造,其结果适用于具有多种结构的XML文档上的实体识别.(3)提出了高效的用于实体识别的聚类算法MaxMerge.它兼顾了各个实体对象之间相似的传递性与独立性,是一种快速有效的聚类方法.(4)通过实验,我们证实了本文提出算法的效率和有效性,并对其参数影响进行了验证.本文第2节介绍为了使输入数据满足算法要求而对数据进行的改造的方法.基于实体描述属性的重复对象检测算法将在第3节提出.为了将输出的重复对象二元组进行聚类,我们将在第4节提出MaxMerge算法,并对算法进行分析.结论将在第5节给出.2实体对象改造在实体识别过程中,XML数据不规则可能会引发一系列问题.例如,没有主键便无法直接定位到对象,两个不同的XML数据源中对某个属性的属性名表述可能不同,而两个相同的属性名在不同的数据源中可能代表不同的意义,对象的父级及以上的结点降低了对象的检索速度.如在图2中的两个实体对象中,两个book路径不一致,难以唯一定位到实体对象;结点1中作者这一属性的属性名为name,而在结点2中为author;结点1中的属性名name与结点2中的属性名name分别代表对象的作者和书名这两个不同的属性;结点2中属性结点edition与子结点edition的属性值完全相同,它们对于对象的描述意义冗余;结点1中的父结点与结点2同处于一个层上,检索对象结点时不属于同一个结果集,降低了检索的效率.〈books〉〈booktitle="IntroductiontoAlgorithms"〉〈/book〉〈/books〉〈bookname="IntroductiontoAlgorithms"edition="ThirdEdition"〉〈/book〉为了支持有效的实体识别,需要对XML数据进行预处理,使其具有适用于实体识别的结构.我们首先基于XML数据的特征提出了4条数据源改造规则.规则1使对象结点检索具有唯一性;规则2统一了不同数据源中的属性名;规则3消除了冗余的属性对;规则4令所有实体对象结点处在数据源中的同一层上,极大地方便了对象的检索.以下是这4条规则的详细描述,其中对于实体对象a和b,path(a)表示对象a的XQuery路径,height(a)表示a到根结点的高度,path(a)=path(b)表示a与b的路径完全相同,a=b表示是同一个对象.对于属性名namea,mean(namea)代表namea所代表属性的语义,mean(namea)=mean(nameb)表示两个属性名所代表的意义相同.规则1.对于实体对象a和b,path(a)=path(b)a=b.Page4规则2.对于属性名namea∈a,nameb∈b,namea=namebmean(namea)=mean(nameb).规则3.对于实体对象a,属性对〈name,value1〉∈a∧〈name,value2〉∈avalue1≠value2.规则4.对于实体对象a,height(a)=1.为了使待处理XML数据满足上述条件,需要对其进行预处理,该处理主要包含如下4个步骤.第1步.使对象具有唯一性.由于XML数据中没有主键这一概念,可以存在部分甚至完全相同的实体对象,因此实体对象具有不唯一性.而我们的算法需要将对象的唯一标识插入属性结点表,并通过这一标识来检索对象,因此需要将实体对象改造为具有唯一标识的元素.改造的方法可以为把实体对象的标签改成字母+数字的形式,通过遍历各个实体对象结点,将各对象的标签名字中的数字部分逐一增加.第2步.统一属性名.两个不同的XML数据源中对某个属性的属性名表述可能不同,而两个相同的属性名在不同的数据源中可能代表不同的意义.我们希望通过相应属性上的属性结点表来定位实体对象,因此有必要在开始阶段将对应的属性名进行统一.令所有代表相同意义的属性名相同,所有代表不同意义的属性名不同.第3步.消除冗余的属性对冗余的属性对是指在一个实体对象当中属性名和属性值都完全相同的属性对.如果存在冗余的属性对,它们对实体的描述价值可以由其中之一替代,因此我们可以直接删除冗余的属性对.第4步.使所有对象结点处于同一层上实体对象的具有的复杂层次结构降低了对象的处理效率,我们可以将其祖先和父亲改造成为对象的子结点,表示其对对象的描述.如果事先已经得知对象的部分或全部父级上的结点对其并无描述的意义,那么我们可以直接删去这些结点,把对象结点上提到根结点的直接子结点的位置上.经过以上的4步改造,XML数据中的对象具备了标识唯一性和属性统一性,消除了冗余属性对,且使得属性处在了同一层,从而满足了上面所提出的4条规则.例2.下面我们使用这4步对图2中的两个结点进行预处理.第1步.将两个结点的标签分别改为book1和book2,使其具有唯一性.第2步.将结点1中的属性名name改为author,将结点2中的属性名name改为title.第3步.删除结点2中的属性结点edition.第4步.删除结点1的父结点,将结点1上提经过4步预处理后,改造后的两个结点为图3到与结点2同一层的位置上.中的两个结点.〈book1title="IntroductiontoAlgorithms"〉〈/book1〉〈book2title="IntroductiontoAlgorithms"〉〈/book2〉3重复对象检测两个数据对象如果描述同一个真实世界实体,尽管它们很可能在某些属性的表现形式上有所不同,但是它们的某些属性值可能相似.因此,我们提出了重复对象模型检测算法.该算法按照属性组织对象,把在某个属性上相同的对象放到同一个属性结点表中的相同位置上,这样就可以通过一次对数据源的遍历操作,把各个对象的唯一标识插入到其各属性结点表中的相应位置上,然后只比较在对应属性上相同的对象.本小节首先给出算法的基本模型,接着介绍将实体对象插入到其各个属性的属性结点表的方法(3.1节),然后再利用已得的属性结点表进行重复对象的检测工作,得到描述同一实体的对象对(3.2节),其中用于利用对象对求得最终实体识别结果的MaxMerge算法将在下一部分详细介绍.Page53.1将对象插入属性结点表我们的方法需要按照属性组织实体对象.因此,我们提出了属性结点表用于实现XML数据上的实体识别.本小节将介绍该数据结构与其维护方法.属性节点表分为两个部分,分别是属性名表与对象表.首先介绍属性名表,由于我们的算法把描述实体对象的所有〈文本元素标签,文本元素值〉及〈元素属性名,属性值〉都看成属性对,从而得到的属性名的个数较多,且事先无法预知其具体数目,因此需要为所有属性名建立一个属性名表,这样我们可以通过查询此表而得知某属性是否已经出现过,并能得到它的唯一序号.如图5所示,属性名表中的每个位置上的链表中的每一项包含属性名、属性序号、属性出现的次数与指向下一项的指针.当我们遍历到实体对象的某个属性对时,为了确定将实体对象插入到哪个对象表中,需要查询属性名表获得这一属性的序号.首先检查一下这个属性名是否已经存在于属性名表当中,如果存在,那么返回这个属性的属性序号;如果不存在,就要把这个属性名插入到属性名表当中,并得到唯一的属性序号.然后我们将实体对象的唯一标识插入到得到的属性序号的属性结点表中.算法如下.算法1.属性序号计算算法.输入:所有属性名attrName输出:属性序号1.whilegetattrNameandattrValue;2.hashattrNameintoanumber;3.number=number%attrNameIndexSize;4.ifattrNameinattrNameIndex[number]5.attrName.times++;6.getattrOrder;7.else8.addattrNameintoattrNameIndex[number];9.attrName.times=1;10.getattrOrder;11.endif;12.endwhile;当我们得到属性名的属性序号后,我们就可以把当前对象的唯一标识插入对象表中相应位置上.首先通过一个字符串散列函数把当前属性值散列成一个数值,再用这一数值模上对象表的尺寸,然后把当前对象的唯一标识插入到对象表中的这一数值的位置上.插入算法如下.算法2.实体对象唯一标识插入算法.输入:所有属性名序号attrOrder与属性值attrValue输出:对象表1.getattrOrderandattrValue;2.ifattrValuehasnotbeeninserted;3.hashattrValueintoanumber;4.number=number%attrValueIndexSize;5.adduniqueIdentifierto6.attrValueIndex[attrOrder][number];7.endif;将所有对象的标识插入到对象表后,最后得到的对象表如图6所示.3.2重复对象检测过程在遍历完所有实体对象,把它们的唯一标识分别插入到其相应对象表中后,基于实体对象表进行重复对象的检测,获得可能描述同一实体的对象对.该过程分为如下两个步骤.3.2.1计算各属性权值由于不同的属性对于对象的描述重要性可能不同,为了更加精确地识别实体对象,需要根据属性描述对象的重要性赋予不同的权值.在将所有实体对象分别插入到各个属性结点表中后,每个属性出现的次数已经被记录下来,我们认为在所有对象中出现次数较多的属性更能够描述对象.因此我们选择出现次数最多的属性的次数T作为计算各个属性权值的基值,各个属性的权值(Weight)定义为其出Page6现次数除以基值所得的商,可表示为Weighti=TiTMAX,其中Ti是各个属性自己出现的次数,TMAX是出现次数最多的属性的次数.3.2.2得到候选对象及其相似性比较所示.首先我们介绍一下用到的符号和缩写,如表1Similarity∧OiattriWeightiKγiSize(O1[attri])O1中attri中属性值的个数SimilarM为了找出数据源中的重复对象对,检测的过程如下:首先遍历第1个属性的属性结点表,若表中某一位置的标识数为0或1,则跳过该位置,继续遍历下一位置;若此位置的标识数大于等于2,则取出所有标识.通过第1个标识,取出其所代表的节点,创建一个包含所有出现过的属性名的链表数组,将此节点的所有属性值分别插入到对应位置的链表中.然后创建一个相同大小的链表数组,将第2个标识代表的节点的所有属性分别插入到此链表数组中.开始比较之前,相似度(Similarity)为0.从第1个属性进行比较,将第1个对象的此属性名内的所有属性值分别与第2个对象的此属性名内的所有属性值进行字符串相似性(Similar)比较,由于在XML数据中同一属性名可能对应多个不同的属性值,而我们的算法认为只有当两个对象在同一属性对应所有属性值相等情况下,才能达到此属性原本的权值,若只有部分属性值对应相同,设此对应相同的属性值总数为K,对象O1、O2中此属性名attri下的属性值个数分别为Size(O1[attri])、Size(O2[attri]),则此属性权值的累加值γi应为γi=Weighti×若两个对象此属性内所有值都不相同,则累加值γ=0.将所有h个属性的累加值加到一起,便可得到两个对象的相似度(Similarity)若两个对象的相似度大于我们输入的阈值M,则认为它们是重复的,输出这两个对象.该算法依次扫描所有对象表,得到所有描述同一实体的数据对象对.例3.使用该算法对已经改造并插入到属性结点表后的图1中的数据集合进行重复对象检测过程如下.先检测title属性的对象表,发现O2、O3、O4处在此表中的同一位置上,根据其插入的唯一标识取出这3个结点,对O2与O3的所有对应属性进行相似性比较,得到其相似度大于M,输出(O2,O3);然后以同样的方法比较O3与O4、O2与O4,输出相似度大于M的对象对.然后检测author属性的对象表,发现O1与O4同时出现在4个位置上,其中两个位置上还有O2,依次进行各个对象的两两比较,输出相似的对象对.再检测下一个对象表直至结束,得到了所有的相似对象对.3.3算法分析实体对象改造与插入属性结点表两步可以在扫描数据一次之内完成,因此在预处理时只需要扫描数据1次.设数据源中实体结点的个数为n个,所有实体对象共有g个不同的属性,其中i个用于生成属性结点表,每个属性结点表包含s个元素,在遍历属性结点表的某一位置时,得到的候选对象的平均个数为m,考虑到在真实数据中冗余的概率很低,若选取建立属性结点表的属性恰当、Hash函数的冲突率足够低、属性结点表的尺寸足够大的话,属性结点表中的很多位置的候选对象数都为0或1,考虑到在对象数为0或1的位置上不存在可以比较的候选对象对,因此计算平均候选对象时只考虑对象个数大于等于2的候选组.设候选对象数大于等于2的位置的平均数量为q,故有iqmng,且m2,qs.每得到一组候选对象,就要对其每个结点的所有信息进行一次扫描,抽取出其各属性值,一共需要访问iqm个结点.每两个候选结点的每个对应的属性之间都需要进行一次比较操作,共需要比较的次数为giqC2m.设访问一个实体结点所需要的平均时间为t1,比较两个属性值所需要的平均时间为t2,则整个算法所需要的时间T为由此可得在属性结点表尺寸s不变的条件下,候选对象数大于等于2的位置数量为q越小、平均候选对象数m越小,我们算法运行所需要的时间越少.即当对象在属性结点表的冗余度越小,我们的算法的效率越高.由tqmng可以得到此算法运行所Page7需要的最大时间为TMAX=nt1+ngt1+n2g3当结点属性表中所有位置均为0或1,即没有冗余或冗余很少时q=0,此时达到算法的最高效率,代入式(1)得到算法运行所需要的最小时间为TMIN=nti.考虑到真实数据中冗余通常较低,插入到属性结点表后候选对象大于等于2的位置较少且平均候选对象很少,因而我们的算法在大多数情况下效率较高,算法时间复杂度是O(n).4MaxMerge算法重复对象检测工作完成以后,我们只输出了两两重复的实体对象对,而我们希望得到的结果是元素的聚类,每一类中的元素描述同一实体,因此我们需要对重复对象检测工作输出的结果进行合并,让所有相似的元素聚类到一起.为了实现快速地合并,我们提出了MaxMerge算法,它兼顾了各个实体对象之间相似的传递性与独立性,是一种快速有效的聚类方法.4.1MaxMerge算法模型在该算法中,我们首先用一个实体对象信息表(infoBook)来记录所有实体对象的基本信息(info).根据对象的唯一标识可以得到其在对象信息表中的位置(position),如对象a246的信息应当插入到实体对象信息表中的第246的位置上.所需要插入的对象信息如下图所示,其中含有对象的名字(name)、对象是否已经出现过(show),对象被归并到的所有的聚类的编号(clusterNO),及其在此聚类中出现的次数(time),聚类的编号与其出现的次数合称为聚类信息ClusterInfo.当算法扫描到一个二元组的实体对象(a,b)时,首先判断它们是否已经出现过.若两个对象都未出现过,我们新建一个聚类,并把此聚类的编号存入两个对象的信息当中,此聚类出现的次数都为1,两个对象是否出现过的标记改为true;若两个对象中只有一个出现过,那么取出出现过的对象中出现次数最多的聚类编号,然后把它存到未出现过的对象的信息中,设置其次数为1,把它的标记改为true;若两个对象都出现过,则检测这两个对象中的聚类编号中是否有重复,如有重复,则增加此重复的聚类编号次数,如果没有重复的,那么把两个对象中各自出现次数最多的聚类编号增加到对方信息中,并设置其次数为1.在扫描完所有二元组的实体对象后,新建一个聚类表,开始遍历每个实体对象的信息,将对象插入到聚类表中自己所有聚类编号中出现次数最多的编号的位置上.在插入聚类表完成后,输出整个聚类表作为聚类结果.算法3.MaxMerge算法.输入:所有相似对象二元组输出:聚类结果1.whileapairofobjects2.getnumsandnamesfromobjects;3.ifneithershowedthen4.addnewclustertoitem1anditem2;5.makebothofthemshowed;6.elseifjustoneshowedthen7.addthemaxClusteroftheshowedtotheunshowed;8.maketheunshowedshowed;9.elseifbothofthemhaveasameclusterthen10.thetimeofthesamecluster++;11.else12.addthemaxClustertoeachother;13.endif;14.endwhile;15.whiletraversetheinfo_book16.ifnameBook[i]showedthen17.maxCluster=theMaxClusterofitem;18.addthenametocluster_table[maxCluster];19.endif;20.endwhile;4.2MaxMerge算法分析文献[4]中使用了传递闭包的方法来进行重复元素对的聚类,它仅仅考虑到了相似的传递性,如果元素1与元素2、元素2与元素3重复,那么元素1与元素3必重复.但是这种方法忽略了各相似对的判断是独立的,并且有可能由于一个相似的元素对,而导致两个指向不同实体的元素聚类聚到一起.当重复的元素规模增大时,会导致重复检测方法的精确率变低.在MaxMerge算法中,同时兼顾了相似的传递性与独立性,主要体现在如下两个方面:元素由于相似次数的增加而不断增加自己某个聚类编号的出现次数,一个元素必然与自己所属聚类中的多个元素相似,而这些相似的元素会不断增加此元素中相应Page8的聚类编号出现的次数,这是MaxMerge算法中传递性的体现;而最后把元素分别插入到各个聚类中时,仅考虑它的所有聚类编号当中出现次数最多的那个,对于元素中出现次数不多的聚类编号直接忽略,把元素放到自己最可能所属的聚类中,这是MaxMerge算法中独立性的体现.在文献[4]中的传递闭包方法中,当检测到两个元素重复时,就需要将所有之前与这两个元素重复的元素聚类,所以检测是非线性的,而在MaxMerge算法中,当检测到两个元素重复时,只对两个元素的结构信息进行改变,无需修改之前与它们重复的元素,因此检测过程是线性的.因此MaxMerge算法运行所需要的时间仅为扫描一次二元组文件与扫描一次内存中对象信息表所需要的时间.5实验验证本文所提出的基于实体描述属性技术的算法可快速地找到可能相似的候选对象,然后再在候选对象中进行任意一种核心的实体识别算法即可.本实验内采用的核心实体识别算法为一般的基于规则的实体识别算法.为了验证本算法的有效性并测试影响效率的主要因素,我们进行了大量的实验,并对实验结果进行相关的分析.为了验证MaxMerge算法的运行效率,还进行了一系列的对比实验.实验采用的硬件环境为IntelPentium4CPU,内存1GHz,操作系统为WindowsXP,系统代码用Java实现,软件开发环境为Eclipse3.4.1.5.1算法效率实验在本实验中,我们利用数据生成系统生成6个含有不同数量实体对象的XML数据集合.前3个数据集合分别为,S1含有4k实体对象,S2含有8k实体对象,S3含有16k实体对象,这3个数据集合中冗余程度相近且适中.S4、S5、S6也分别含有4k、8k、16k个实体对象,但数据中的冗余程度较低.数据集合中的每个实体对象的结构中不存在孙级以下的结点.子级、孙级结点共由8~11个属性组成,这些属性或以结点属性的形式给出,或以结点的子、孙结点的形式给出,其中cluster属性的值代表其实体对象真实归属的聚类,不参与重复对象检测过程,但用于统计精确率与召回率.其它7~10个属性用来参与实体对象的重复对象检测,每个属性由6~12个英文字母组成,如图8中的两个对象结点.〈bookcluster="11"〉我们的算法运行于4k、8k、16k个结点的数据集合上进行重复对象检查时,所需要的时间如图9所示,分别为2.58min、11.54min、61.55min.可见,当数据中冗余的对象比率大致相同时,数据集合的尺寸增大,重复检测所需要的时间显著增加.运行结果如图10所示,精确率都接近100%,召回率也都在90%以上,这验证了算法的有效性.Page9由图11可得,当数据的冗余度较低时,处理数据所需要的时间显著减少.并且在低冗余度时,当处理的数据量为原来的2倍时,所需要的时间呈线性增长.由此可得,算法在低冗余时的时间复杂度小于O(n2),接近O(n),这验证了我们之前对算法的高效性分析.5.2数据冗余程度的影响为了测试数据冗余程度对算法的影响,我们生成了10个数据集合,其中每个数据集合都含有4096个对象,每个数据集合中指向相同实体的对象的集合叫做一个聚类,数据集合D1中的所有实体对象共可以划分为100个聚类,D2可划分为200个聚类,依次类推,D10可划分为1000个聚类,并且在数据集合当中所有的实体对象平均分配到各个聚类当中.算法在冗余程度不同的数据集合当中的运行效率如图12所示.可以看出,算法在运行10个冗余程度不同但实体对象总数同为4k的数据集合时,聚类数量最少的D1所需要运行的时间最多,其它数据集合所需要运行的时间随着聚类数量的增多而减少.由于在数据集合当中所有的实体对象是平均分配到各个聚类当中的,在实体对象总数不变的前提下,聚类数量越多,算法的冗余度越低.所以可以得数据集合中的实体对象的冗余程度越低,算法的运行效率越高.这也验证了我们之前对算法进行的分析.图13是算法在冗余程度不同的数据集合当中运行后的精确率与召回率.易看出,算法的精确率一直稳定在将近100%,而召回率也一直浮动于80%以上,召回率的浮动与数据集合中数据本身有关.召回率与精确率都很高,这验证了算法的有效性.5.3数据的结构复杂度的影响我们所测试的是3个除平均深度不同外,叶结点与属性结点互相完全相同的含有4k个结点的数据集合.也就是说这3个数据集合S1、S2、S3只是从对象结点到叶结点的路径长度不同,其中S1、S2、S3到叶结点的平均路径长度分别为1、10、20.由图14可以看出,当实体对象的结构变得复杂时,算法运行的时间明显增多,这表明算法执行过程中的相当大的一部分时间被用来遍历描述实体的结点与属性,对于结构越简单的实体,算法的执行效率越高.5.4MaxMerge算法的对比实验表2是MaxMerge算法与文献[4]中的传递闭Page10包算法的对比实验结果.分别使用两个算法处理数据总量为1k、2k、4k的数据集合,得到的结果如下.容易看出,MaxMerge算法所需要的时间都略低于传递闭包方法,并且精确率与召回率都有显著的差距.由于兼顾了相似的传递性与独立性,MaxMerge算法是一种高效且有效的方法.时间/s精确率召回率数据量1K0.28110.945730.3280.851100.699942K0.47110.902210.4730.717010.485104K0.62010.946140.6310.833030.69661实验结果总结:本文提出的算法在XML数据集合当中可以快速有效地检测重复实体,且当数据集合中冗余的程度很低时,算法的时间复杂度接近于O(n).算法运行中的大部分时间被用来遍历对象的结点与属性,当描述实体的XML对象的数据结构很简单时,算法的运行效率会很高.用于对重复的数据对象进行聚类的MaxMerge算法,由于其扫描时是线性的,所花费的时间要略小于传递闭包方法.由于其兼顾了相似的传递性与独立性,其精确率与召回率都显著的优于传递闭包方法,是一种高效精确的聚类方法.6结论本文提出的使用实体描述属性的XML数据对象实体识别方法,通过使用属性结点表快速定位在某个属性上相同的实体对象,大大减少了所需要的比较次数,再通过使用MaxMerge算法对输出的重复对象二元组进行聚类,同时考虑了相似的传递性与独立性,显著提升了算法的精确率与召回率.大量的实验验证了我们的方法是高效且有效的.WANGHong-Zhi,bornin1978,associateprofessor,Ph.D..Hisresearchinterestsincludedataquality,XML
