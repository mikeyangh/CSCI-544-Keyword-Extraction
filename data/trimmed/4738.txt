Page1抽象精化和可满足性结合的EFSM模型测试用例优化生成1)(苏州市职业大学计算机工程学院江苏苏州215104)2)(上海大学计算机工程与科学学院上海200072)3)(上海市计算机软件测评重点实验室上海201112)摘要基于模型的测试是测试自动化的重要手段,通常采用模型检验技术从系统模型自动生成测试用例集,但生成的测试用例集往往存在冗余,这将影响测试用例执行的性能和成本.该文以扩展有限状态机(ExtendedFiniteMachine,EFSM)为建模工具,根据公式簇建立状态等价关系,构建抽象模型,采用模型检验技术生成抽象反例(测试用例);给出了判定生成的抽象反例是否为伪反例的方法;采用反例引导的方法精化抽象模型,删除伪反例;最后,使用我们之前提出的基于可满足性的测试用例生成方法在抽象模型上生成约简的测试用例集.实验表明:该方法的测试用例数目约简比例最高达76%(警报侦测组件EFSM),总长度约简比例最高达68%(ATMEFSM),同时不会影响测试用例集的迁移覆盖率和查错能力.关键词测试用例约简;扩展有穷状态机;公式簇;抽象;反例引导的精化;可满足性1引言软件测试是发现软件错误,保证软件质量的一种重要手段.传统软件测试方法所需成本占软件开发总成本的50%以上[1].测试自动化是一种能够降低测试成本的有效方法.测试用例的自动生成是测试自动化的一个重要环节和体现.基于模型的测试使测试自动化成为可能.它根据指定的测试覆盖准则从软件的行为模型自动生成测试用例(抽象测试用例),然后对测试用例进行实例化,最后在实际系统上执行测试用例,观察系统运行的结果是否与测试用例的预期行为一致.有时根据指定的测试覆盖准则,从软件行为模型生成的测试用例集规模庞大,导致测试成本高、效率低.因此,测试用例集约简是软件测试的一项重要工作.模型检验[2]是一种自动验证有穷状态系统的方法,在很多领域有着广泛的应用.近年来,有人把它应用到软件测试中.在模型检验器验证可达性性质的过程中,如果该性质不成立,会生成一条反例作为证据序列,它与覆盖测试目标的测试用例极其相似,所以可以应用模型检验技术自动生成测试用例.但使用模型检验技术生成测试用例的一个最主要缺点是生成的测试用例集会存在大量冗余,这增加了测试生成和执行成本.抽象是能够约简测试用例的主要技术之一,其主要思想是构造软件行为模型的抽象模型,使状态数和迁移数大大约简.抽象模型中的状态称为抽象状态,通过抽象得到抽象模型的软件行为模型称为具体模型,具体模型中的状态称为具体状态.抽象移除或简化那些与验证性质无关的细节.验证抽象模型比验证具体模型有效,但是在抽象过程中会丢失一些信息,在验证抽象模型的过程中可能会导致错误的结果[3].抽象分为欠近似和过近似两种.欠近似抽象减少了具体模型中的一些行为,在抽象模型中不成立的性质在具体模型中也不成立;过近似抽象具有性质保留性,即在抽象模型满足的性质在具体模型也满足,它在抽象模型中引入一些额外的行为,因此,当抽象模型违反某一性质时,模型检验器生成的反例可能是抽象模型引入的额外行为,不能说明具体模型也违反该性质,这样的反例我们称为伪反例(spuriouscounterexample).为了能够更准确地验证性质,专家学者提出了反例引导的抽象精化(CounterExample-GuidedAbstractionRefinement,CEGAR)框架[4].模型检验器在抽象模型生成反例时,需要判定在具体模型中是否存在对应的反例,一旦为伪反例,则对抽象模型进行精化以删除伪反例.本文采用反例引导的抽象精化框架抽象具体模型,在抽象模型上生成优化的测试用例集.本文主要完成的是:(1)构造待测软件的抽象模型.将EFSM模型中迁移上的谓词(监护条件)划分成公式簇(FormulaCluster).根据公式簇建立状态的等价关系,获得抽象状态,然后分几种情况讨论如何合并相关迁移,最后构造初始抽象模型.(2)反例判定和模型精化.对每个测试目标,用LTL表示成一个陷阱性质(TrapProperty),使用模型检验技术在抽象模型上为测试目标生成反例,判定具体模型中是否存在对应的具体反例.如存在,则说明抽象反例可以作为测试用例;否则,采用反例引导的精化框架精化抽象模型,删除伪反例,继续为该测试目标反例,直到抽象模型不存在伪反例.(3)约简的测试用例集生成.使用我们先前提出的基于可满足性的测试用例优化方法[5]在最终的抽象模型上生成约简的测试用例集.本文第2节介绍文中用到的一些基本概念;第3节介绍我们之前提出的基于可满足性的测试用例优化方法;第4节给出公式簇的概念和抽象的形式Page3定义;第5节为测试用例方法;第6节是判定伪反例和精化抽象模型的方法;第7节是实验及结果;第8节是相关工作;最后是总结和进一步工作.2基本概念模型检验需要构造系统模型和描述系统性质.我们用EFSM[6]作为建模工具,用线性时序逻辑(LinearTemporalLogic,LTL)[7]描述系统性质.定义1[6].EFSMM是一个六元组(S,init,图1EFSM模型示例定义2.EFSM中长度为n的路径是一个状态序列π=〈s0,…,sn〉,其中0in-1:(si,si+1)∈T,s0∈init,T是EFSM中的迁移集,si和si+1分别是ti∈T的开始状态和结束状态.定义3[7].LTL的语法可表示为∷=true|falsep1∧21∨21其中,p是原子命题,1和2是LTL公式,时序算子X,F,G,U分别表示下一状态、将来的某个状态、将来的所有状态和直到某个状态.测试覆盖准则是设计测试用例的依据,它表示测试用例执行的基本单元.在基于模型的测试中主要有状态覆盖准则、迁移覆盖准则和迁移对覆盖准则等[8].这里我们只考虑迁移覆盖准则.在基于模型的测试中,测试用例是一条可以覆盖某个测试目标的有穷状态(迁移)序列.模型检验中的可达性分析用来验证可达性性质在模型中是否成立,即是否存在一条有穷状态序列能够到达某个模型元素,这样的状态序列和测试用例很相似,所以可以把模型检验技术用于测试用例的自动生成.在用模型检验技术生成测试用例[9]的过程中,根据测试覆盖准则,列出测试目标,把测试目标表示成陷阱V,I,O,T),其中S是一个有穷状态集;init是初始状态集;V是有穷上下文变量集;I是有穷输入集;O是有穷输出集;T是有穷迁移集.迁移t∈T是一个五元组(ss,i,g,op,st),其中ss是迁移t的起始状态;i∈I是输入消息,它可能包含输入参数;g是谓词;op是顺序操作,它包括赋值语句和输出消息;st是迁移t的结束状态.在g和op中可以同时包含输入参数和上下文变量.本文只考虑确定的EFSM.图1是一个EFSM模型的例子,将用它解释本文的方法.性质(可达性性质的否定).如迁移覆盖准则中的一个测试目标是能够到达迁移ti,用陷阱性质表示“在模型中不存在到达迁移ti的路径”,对应的LTL公式为G(siXsi+1).状态si和si+1分别是迁移ti的开始状态和结束状态.模型检验器验证陷阱性质,事实上,模型中存在到达迁移ti的路径,所以,模型检验器生成一条到达ti的反例来证明这种情况,从而构成了能够覆盖迁移ti的测试用例.3基于可满足性的测试用例优化方法用模型检验生成测试用例时,要为每个测试目标的陷阱性质生成一条测试用例.这样做可能会导致出现重复的测试用例或一条长的测试用例包含一条短的测试用例的情况,这些重复的或被包含的测试用例是冗余的.比如,为迁移t5生成的一条测试用例是tc1=〈s0,t1,s1,t3,s2,t5,s3〉(这里给出迁移是为了区分不同的路径),为迁移t3生成的一条测试用例是tc1=〈s0,t1,s1,t3,s2〉,测试用例tc1包含tc2,tc2是冗余的.通过约简冗余的测试用例可以降低测试生成和执行的代价.为了不再为已被已有测试用例覆盖的陷阱性质生成测试用例,通过可满足性理论Page4约简冗余的测试用例.限界模型检验[10]主要是基于可满足性(SAT)理论[11]判定模型是否满足时序逻辑性质,与传统的模型检验不同,它不用搜索状态空间.它把系统行为表示成形式模型,要验证的性质表示成LTL公式,设定边界上界k,状态间的迁移关系和LTL公式的否定通过合取构成BMC公式,把BMC公式编码成SAT实例(CNF公式),通过SAT工具进行求解.如果该实例有解,则找到反例;反之,如果不可满足,则说明模型在运行k步后满足性质.这里,我们把SAT理论应用于约简模型检验器生成的测试用例.首先,根据测试覆盖准则(如迁移覆盖),列出所有测试目标,从中选择一个测试目标,把它表示成陷阱性质,通过模型检验器验证该陷阱性质是否成立.如果不成立,则生成一条测试用例,表示存在一条状态序列可以到达该测试目标(迁移),即这条测试用例可以覆盖该测试目标(迁移),把那些还未被覆盖的测试目标表示成陷阱性质,对于每个陷阱性质,把它和测试用例的合取转换成CNF公式,通过SAT工具求解该公式的可满足性.如果该公式不可满足,根据定理1可知,这条测试用例能够覆盖这个陷阱性质所对应的测试目标,不需再调用模型检验器为该测试目标生成测试用例,从而可以约简测试用例的数目和测试用例集的总长度.根据什么样的次序选择测试目标来生成测试用例会很大程度的影响测试用例约简的效果,在以往的工作中,都是随机选择测试目标.在SAT理论中,子句长度越短满足子句的难度就越大[11],基于此,我们根据系统模型M与陷阱性质的合取式转换得到的CNF公式的难度来选择测试目标.定义4.设CNF公式中子句数为n,第i个子句中的文字数为li,则CNF公式的难度h:对于每个陷阱性质,把它与模型进行合取,转换得到相应的CNF公式,然后计算每个CNF公式的难度,得到的难度集合为H.测试目标根据他们对应的CNF的难度按升序排列,得到测试目标集RTG.从RTG中顺序地选择测试目标生成测试用例.对于具有相同难度的测试目标,我们随机地进行选择.h的值越小,生成的测试用例长度越长,这样,避免生成与已有测试用例相同的或被它包含的测试用例.使用SAT理论检查已生成的测试用例是否覆盖测试目标集中其余目标的方法主要基于以下定理.定理1.设对于测试目标tg1,生成测试用例·=〈s0,…,st〉,在测试目标集TG中选择未被覆π·盖的测试目标tg2,如果π∧Gtg2转换得到的CNF公式是不可满足的,则测试用例π覆盖测试目标tg2.证明.因为π∧Gtg2转换得到的CNF公式是不可满足的,那么也就是π/Gtg2,从此可以看出π是Gtg2的反例,因而π可以作为覆盖测试目标tg2的测试用例.使用SAT理论约简测试用例集的具体过程见算法1和算法2.算法1.TestSuiteReduction(M,TG,TS).输入:模型M,测试目标集TG输出:约简的测试用例集TSBEGINH={};FOReachtestgoalinTGDOBEGINi=1;//生成M∧的CNF公式f=GenerateCNF(M∧);//计算每个CNF公式f的难度h(i)=ComputeHardness(f);//得到难度集合HH=H∪h(i)i=i+1;END//按CNF的难度排列测试目标RTG=RankAscending(TG,H);TS={};WHILERTG!=emptyDOBEGINSelectatestgoalfromRTG;RTG=RTG-{};//在模型M检测测试目标的陷阱性质π=ModelChecking(M,);IFTS={}THENTS=TS∪{π};//使用测试用例集TS检查π,检查它是否ELSETS=Winnow(TS,π)FOReachremaintestgoalφinRTGDOBEGINPage5f=GenerateCNF(π,φ);//使用SAT求解CNF公式fresult=SAT(f);IFresult=unsatisfiableTHENRTG=RTG-{φ};ENDENDEND算法2.Winnow(TS,π).输入:已有的测试用例集TS和新生成的测试用例π输出:新的测试用例集BEGINFOReachtestcaseζinTSDOBEGIN//对于新生成的测试用例π和测试用例集的测试用//例ζ,求两个测试用例的长度的较小值j=MinLength(π,ζ);FORi=1tojDOBEGIN//检查两个测试用例中的第i个状态是否相同IF!Match(π(i),ζ(i))//如果不同则说明新的测试用例不是冗余的THENTS=TS∪{π};EXIT;//如果ζ被π包含ELSEIF(i==j)and(Length(π)>Length(ζ))//在测试用例集中删除ζ并把π添加进去THENTS=TS-{ζ}∪{π};ENDENDEND下面采用归纳法分析算法1的正确性和终止性,假设测试目标的数目为n.(1)当n=1时,只有一个测试目标,通过模型检验生成一条测试用例;(2)假设当n=p时,算法能够正确的约简测试用例;(3)那么当n=p+1时,算法先为每个测试目标生成相应的CNF公式,然后计算每个CNF公式的难度,假设针对前p个测试目标,约简后得到的测试用例数为m(设该用例集为TS),从这m条测试用例中选择一条,生成该测试用例与第p+1个测试目标的CNF公式,通过SAT求解器检查这条测试用例是否覆盖这个测试目标,如果覆盖,算法终止,最终测试集中有m条测试用例,如果不覆盖,取TS中的下一条测试用例,直到取完TS中的所有测试用例,最终的测试集中有m+1条测试用例,所以算法1能够正确的约简测试用例集并终止.算法1的主要操作有模型检验、生成CNF公式、SAT求解CNF公式可满足性、计算CNF公式复杂度、排序测试目标以及Winnow过程,其中计算CNF公式复杂度、排序测试目标和Winnow过程的时间复杂度都是线性的,模型检验的时间复杂O(|M|×2||),生成CNF公式和SAT求解的时间复杂度也是O(|M|×2||),设测试目标数为n,算法1的时间复杂度为O(n2×|M|×2||).在使用SAT求解器求解CNF公式的可满足性时,由于设定了边界上界为k,所以在公式满足或者不满足时,SAT求解过程都能在k步内终止.4抽象模型抽象的目的是使模型的状态数和迁移数减少,但同时保留要验证的性质.本文采用EFSM模型中迁移上的谓词来抽象原始模型.在给出抽象过程之前,下面列出一些需要用到的概念.抽象函数α是一个满射α:S→Sα,Sα是抽象状态集.抽象函数α定义了状态集S的一个等价关系≡α,令s,s∈S,那么s≡αsiffα(s)=α(s)[12].给定原子公式f,var(f)是出现在公式f中的变量集合.例如var(x==y)是{x,y}.对于原子公式集合F,var(F)=∪f2是干扰的iffvar(f1)∩var(f2)≠.原子公式f∈F的等价类称为f的公式簇,记为[f].如果var(f1)∩var(f2)≠,有[f1]=[f2].也就是说,一个变量v不能出现在属于两个不同公式簇的公式中.称两个状态s,s∈S是等价的,iff∧sf.也就是说两个状态是等价的当且仅当它们不能被公式簇中的公式区分[12].对于EFSM模型,我们采用迁移上的谓词定义等价状态.假设tg表示的是迁移t上的谓词集合,tss是迁移t的起始状态.令ti和tj是两条迁移,如果var(tig)∩var(tjg)≠,并且状态tiss和tjss不能被tig所属的公式簇中的公式区分,称两个状态等价,即tiss≡αtjss.特别地,如果tiss≡αtjss,tist和tjst都没有输出迁移,那么tist≡αtjst.定义5.假设EFSMM=(S,init,V,I,O,T)和Mα=(Sα,initα,Vα,Iα,Oα,Tα).Mα是M的抽象,其中:(1)Sα是关于α的等价类集合;Page6(2)initα=init∪{s|s∈S·s0∈init∧α(s0)=(3)Vα=V;(4)Iα=I;(5)Oα=O;(6)Tα={tα:(sα其中T(ss,st)表示状态ss和st间的迁移.对于抽象状态间的迁移tα,分几种情况讨论:(1)如果存在两条迁移ti和tj满足α(tiss)=α(tjss)=tαvar(tjg)≠且tig∧tjg≠false则保留两条迁移,两条迁移上的操作作为它们目标状态的内部动作.(2)或者假设ti的谓词不为空,而tj的谓词条件为空即认为是true,ti和tj的开始状态和结束状态分别都等价,那么保留两条迁移,两条迁移上的操作作为它们目标状态的内部动作.(3)或者ti和tj的谓词条件都为空,并且它们的开始状态和结束状态分别都等价,如果tiin≠tjin,那么保留两条迁移,否则,合并这两条迁移,tαtiin,tα结束状态的内部动作.(4)两条迁移ti和tj上的谓词有共有变量,但谓词条件存在矛盾即tj∧tig∧tjg=false,并且tiin=tjin,那么对这两个迁移进行合并,tαg=tig∨tjg,两条迁移上的操作作为它们目标tα状态的内部动作.迁移的输入序列、谓词条件和操作可以为空.根据状态等价的定义,我们可知在图1中的状态s0,s2,s4等价,α(s0)=α(s2)=α(s4)=sαs3等价,α(s1)=α(s3)=sα价类,α(s5)=sα5测试用例生成得到抽象模型后,采用模型检验技术在抽象模型上生成测试用例.抽象约简了具体模型的状态数和迁移数,但验证的性质在抽象模型上仍保留.定理2.假设两个EFSMM和Mα,Mα是M的抽象,是LTL公式,Mα,那么M采用模型检验生成测试用例的过程是:根据测试覆盖准则,列出测试目标,把每个测试目标表示成陷阱性质,模型检验器验证陷阱性质,为每条陷阱性质生成一条反例,这些反例可作为测试用例集.这里,我们在抽象模型上生成抽象测试用例,使用抽象精化方法对测试用例优化的同时要保证:(1)抽象测试用例能够对应具体模型上的具体测试用例;(2)满足抽象模型测试覆盖的抽象测试用例也满足具体模型的测试覆盖.上述的第(1)点将在下一节讨论.在分析第(2)点之前我们假定第(1)点已经满足.根据定义4,一个抽象状态对应一个具体状态集,设β是抽象函数α的逆,通过β(sα)={s|s∈S}求出与抽象状态对应的具体状态集,所以能够覆盖所有抽象状态的测试用例能够覆盖所有具体状态.抽象函数对谓词变量属于同一公式簇且谓词条件矛盾的迁移进行了合并,对其他迁移进行了保留.对于迁移覆盖准则,我们定义抽象迁移tα上的投影函数Proj(tα)={(β(sαβ(sαt)},其中i表示抽象迁移的谓词由i个具体迁移的sα谓词合并得到,通过这样的投影操作,能够把抽象迁t))|sα移还原成具体模型上的迁移,加上那些保留的迁移,抽象迁移集经过投影操作后可以还原得到所有具体迁移.从抽象模型生成的抽象测试用例是抽象状态的序列,对状态序列中的每个抽象状态使用函数β求出它所对应的具体状态集,然后对抽象状态间的每条抽象迁移,通过投影函数Proj还原成具体状态间的具体迁移集,就得到了与抽象测试用例对应的具体测试用例集.例如,为图3中的模型生成了一条抽象测试用例〈sα具体状态集分别β(sα抽象迁移t1和t8通过投影函数Proj还原得到的具体迁移集分别是Proj(t1)={t1,t2}和Proj(t8)={t8},可以得到两条具体测试用例〈s0,t1,s1,t8,s4〉和〈s0,t2,s1,t8,s4〉.根据迁移覆盖准则为图3中的模型生成了8条抽象测试用例,经过上述过程得到11条具体测试用例,这11条测试用例可以覆盖图1中的所有具体迁移.所以可知与满足抽象模型迁移覆盖的抽象测试用例集对应的具体测试用例集也满足具体模型的迁移覆盖.其他的覆盖准则我们也可以进行类似地分析.Page76反例判定和模型精化如果Mα/,那么模型检验器就会返回一个抽象反例πα=〈sαM/,需要判定在具体模型中是否存在一个与πα对应的具体反例π.如果存在这样的具体反例π,那么πα就可以作为抽象模型的一个测试用例,称这样的πα为有效反例;否则就认为πα是一个伪反例,它不能作为抽象模型的一个测试用例,需要对抽象模型进行精化以获得它的测试用例集.6.1反例判定由于πα的每个状态sα集,因此,πα对应具体模型M中路径的集合,用path(πα)表示:path(πα)={〈s0,s1,…,sn〉|∧β(sαi)=si∧s0∈init∧∧πα是一个有效的反例当且仅当path(πα)≠.可以通过迭代的方法判定path(πα)≠是否成立.用RSi表示sαinit,对于任意状态s∈RSi,存在RS0中的某一状态到达s的一条路径.可以通过公式RSi+1=β(sα{s|s∈β(sα象状态中的可达具体状态集.那么,判断一条抽象反例是否是有效反例可以通过定理3完成.定理3.path(πα)≠0in:RSi≠.证明.先证“”,path(πα)≠说明存在一条具体路径〈s0,s1,…,sn〉,每个状态都属于一个抽象状态0in:si∈β(sα,假设RS0≠且si∈β(sα义有si+1∈β(sα得RSi+1=si+1≠.再证“”,0in:RSi≠,可以从每个RSi中选择满足T(si,si+1)∈T且si∈β(sα同时满足初始状态为s0来构造具体路径〈s0,s1,…,sn〉,则path(πα)≠.在图2中的抽象状态对应的具体状态集分别为0,sα0={s0,s2,s4},βαβ例为〈sα具体状态集分别为RS0={s0},RS1={s1},RS2=,〈sα0,sα在出现伪反例的情况下,必须对模型进行精化以删除伪反例.6.2模型精化根据定理2,出现伪反例是因为:(1)存在某个i+1)中的状态.那么称像β(sαi(0in),0ji:RSj≠∧RSi+1=,并且在抽象状态sαi,s从初始状态是可达的,但是s不能到达β(sαsα中的状态,而s从初始状态不可达,不过s可以到达β(sα死路状态(dead-endstate),称像β(sα态为坏状态(badstate),称β(sα坏状态的状态为无关状态(irrelevantstate);(2)初始状态initα和状态sαβ(initα)和β(sα删除伪反例,对于第1种情况,需要把死路状态和坏状态划分到不同的抽象状态中;对于第2种情况,增加抽象状态s0,并在s0和initα添加迁移{t|t∈T(s0,β(initα))}.使用抽象函数α重新定义等价关系,它是原有抽象函数α的精化.定义6[13].称抽象函数α是α的精化当且仅当s1,s2∈S:(α(s1)=α(s2)α(s1)=α(s2)).为了把死路状态和坏状态划分到不同的抽象状态中,定义抽象函数α:s1,s2∈β(sαα(s2)(s1,s2∈β(sαs2)∈T)∨(s∈β(sαT)),其中β是α的逆.也就是说,状态s1和s2是等价的,当且仅当s1,s2同时有或者没有到达β(sα样,抽象函数α将β(sα分到了不同的抽象状态.为了去除图2中的伪反例〈sα是一个死路状态,s3是一个坏状态,使用α将它们划分到两个不同的抽象状态,精化后的状态等价关系是α(s0)=α(s2)=α(s4)=sα2,α(s3)=sαsα如果模型中仍然存在伪反例,可以继续使用上述步骤对模型进行精化,直到生成的所有反例能够Page8满足具体模型的测试覆盖准则.例如,对于迁移覆盖准则,如果为某一迁移对应的测试目标生成的反例是伪反例,那么精化模型,在精化后的模型上再为该迁移对应的测试目标生成反例,直到生成能够覆盖该迁移的真反例.可知图3中是图1最后的抽象模型.根据迁移覆盖准则,图1(具体模型)中有11条迁移,根据通过模型检验技术生成测试用例的方法,需要为每个迁移生成一条覆盖它的测试用例,故总共生成11条测试用例,例如,对于迁移t7,生成测试用例〈s0,t1,s1,t3,s2,t5,s3,t7,s4〉;图3(抽象模型)中有8条抽象迁移,那么需要8条测试用例,例如,对于抽象模型中的迁移t7,生成测试用例〈sαt7,sα2〉因为能够覆盖所有抽象迁移的抽象测试用例也能覆盖所有具体迁移,所以这8条迁移能够覆盖图1中的所有迁移;下面对在图3的抽象模型上采用基于可满足性的方法生成测试用例的过程进行详细描述.表1中是8个测试目标所对应的CNF公式的难度及排名,根据排名升序排列测试目标,我们首先为迁移t8生成测试用例〈sα试目标集中删除t8对应的测试目标,然后再把该测试用例与余下的每个测试目标进行合取得到CNF公式,使用SAT求解器Yices①求解每个CNF公式的可满足性,可得到该测试用例覆盖迁移t1,从测试目标集中删除t1对应的测试目标,重复以上过程,直到所有的测试目标都被测试用例覆盖(即最后的测试目标集为空),最后生成6条测试用例.测试目标Gt1Gt2Gt3Gt4Gt5Gt7Gt8Gt10由此可见,对具体模型进行抽象精化后,测试用例确实得到了约简,结合基于可满足性的测试用例生成方法可以更好地约简测试用例.下面以更为详细的实验进行说明.7实验及分析我们用5个EFSMs[1]进行实验分析,然后对自控镇痛泵系统②中的警报侦测组件所包含的EFSM模型进行实例分析.本文使用模型检验工具NuSMV2.5.4③生成反例(测试用例).在实验中,主要讨论以下几个问题:(1)在满足迁移覆盖准则的情况下,以模型检验技术生成的测试用例(Testcasegenerationbasedonmodelcheckingfromconcretemodel,称为传统方法)为基线,分析使用抽象精化方法(Testcasegenerationbasedonabstractionrefinementfromabstractmodel,称为AR方法)生成的测试用例数目和总长度的约简情况;(2)比较我们之前提出的基于可满足性的测试用例生成方法[5](Testcasegenerationbasedonsatifiabilityfromconcretemodel,称为SAT方法)和AR方法,分析哪种方法能够更有效地约简测试用例集;(3)结合SAT方法和AR方法(SAT+AR)是否比单独使用其中一种方法能够更有效地约简测试用例集;(4)在约简测试用例集的同时,SAT、AR和SAT+AR方法的迁移覆盖率是否会减低?(5)SAT+AR方法的查错能力是否会减低?实验中使用的5个EFSM是:FlightSafetySystemEFSM,TransportProtocolEFSM,LiftSystemEFSM,ATMEFSM和InresinitiatorEFSM.它们的具体模型如图4~图8.①②③Page9图4~图6中模型的具体迁移描述参见文献[1].实验主要包括以下几个步骤:(1)在具体模型上采用基于模型检验技术生成测试用例.把模型中的每一个迁移(测试目标)表示成一个陷阱性质,然后通过模型检验器为每一个迁移生成一条覆盖它的反例.(2)在具体模型上采用我们在文献[5]中提出的SAT方法生成测试用例.文献[5]中的实验表明SAT方法对测试用例有很好的约简效果.图7ATMEFSM(3)使用本文中提出的抽象精化过程为每个EFSM模型构造抽象模型,然后在抽象模型上采用模型检验方法生成测试用例(AR方法).实验表明AR方法也可以很有效地约简测试用例.Page10图8InresinitiatorEFSM(4)用AR和SAT结合的方法来生成测试用例.采用抽象精化过程为每个EFSM模型构造抽象模型,在抽象模型上采用SAT方法生成测试用例集.图9~图13是根据本文提出的抽象精化方法为图4~图8生成的抽象模型.图9FlightSafetySystemEFSM的抽象模型表2给出了采用本文给出的使用抽象精化过程前后5个EFSM模型中模型元素的变化情况.其中FSS、TP、LS、ATM和II分别代表FlightSafetySystemEFSM,TransportProtocolEFSM,图10TransportProtocolEFSM的抽象模型FSSTPLSATMIILiftSystemEFSM,ATMEFSM和InresinitiatorEFSM.Page11图12ATMEFSM的抽象模型图13InresinitiatorEFSM的抽象模型在表3中列出了使用这4种方法为5个EFSM生成测试用例的情况,包括测试用例的数量(表示为N)和测试用例的总长度(表示为L).在表中传统方法用M表示.模型FSS3150TP2054LS2443ATM301331782IIPage12从表3中可以看出,SAT、AR、AR+SAT对测试用例的数目和总长度有很好的约简效果.对于5个EFSM模型,AR方法都对具体模型进行了一定程度的抽象.对于FlightSafetySystem模型,AR方法生成的测试用例数和测试用例总长度要比传统方法小,并且也比SAT方法的小.对于LiftSystem模型、TransportProtocol模型和ATM模型,AR方法都对传统方法生成的测试用例集进行了很大的约简,而对于Inresinitiator模型,AR方法约简效果不佳.并且对于除了FlightSafetySystem和ATM以外的其他模型,它的约简效果要比SAT的差,这是因为模型中迁移的共有变量很少,即使迁移有共有变量,但是它们的谓词条件不矛盾,导致它们不能合并,AR方法对这几个模型没有很好的约简,所以造成测试用例的约简效果不佳;而SAT方法生成的测试用例较长,通过可满足性分析不再生成与已有测试用例相同或被它包含的测试用例,所以对于这3个不能得到很好抽象的模型,它生成的测试用例数和测试用例总长度都要比AR方法的小.AR+SAT方法具有最佳的约简效果,它首先对模型进行抽象精化,这样,抽象精化对模型的状态和迁移有了一定的约简,然后通过SAT方法生成数目更少、总长度更小的测试用例集.表4是3种方法的测试用例约简比例.对于FlightSafetySystem和ATM模型,AR方法对测试用例的约简比例比SAT方法高.对于其他3个模型,SAT方法对测试用例的约简比例比AR方法高.对于所有模型,AR+SAT方法在AR方法和SAT方法的基础上对测试用例进一步约简.模型FSSTPLSATMII为了在约简的同时保证测试用例集的质量,我们从迁移覆盖率和查错能力两方面对约简的测试用例集进行分析.基于模型检验技术的测试用例生成方法为每个迁移都要生成一条测试用例,所以它的迁移覆盖率为100%,在此基础上,我们分析SAT、AR、AR+SAT这3种方法生成的测试用例集是否降低了迁移覆盖率.在此之前,首先对本文第5节中提到的能够覆盖所有抽象迁移的抽象测试用例也能够覆盖所有具体迁移进行分析.使用AR方法分别为5个EFSMs的抽象模型生成满足迁移覆盖的抽象测试用例集,然后从抽象测试用例集得到对应的具体测试用例集,分析抽象测试用例集对具体模型中具体迁移的覆盖情况.实验结果见表5.表5抽象测试用例集对具体迁移的覆盖情况模型FSSTPLSATMII从表5可知,满足抽象模型迁移覆盖的抽象测试用例集也能满足具体模型的迁移覆盖.因而,针对AR和AR+SAT方法我们可以在抽象模型上分析抽象测试用例的迁移覆盖.表6是3种方法生成约简的测试用例集针对5个EFSM抽象模型的迁移覆盖率.模型FSSTPLSATMII从表中可知3种方法并未降低针对EFSM模型的迁移覆盖率.在文献[5]的实验中我们采用变异分数来衡量测试用例集的查错能力.在模型上采用变异操作在状态和迁移中植入错误,通过比较测试用例集在约简前后发现错误的百分比来分析约简的测试用例集的查错能力是否降低.实验结果表明SAT方法在约简测试用例同时,查错能力和传统方法相同,同时抽象模型的迁移集保留了具体模型的迁移或者由具体模型的多个迁移合并而来,因而AR+SAT方法的测试用例集的查错能力也与传统方法相同.下面我们对自控镇痛泵系统中的警报侦测组件所包含的EFSM模型进一步对上面得到的实验结果进行论证.警报侦测组件由4个并行子状态机组成:警报侦测控制器、第1层警报侦测组件、第2层警报侦测组件和警告侦测组件.警报侦测控制器接收由其他子状态机报告的警报、警告并且决定什么通知应该报告给状态控制器.第1层警报侦测组件Page13接收来自系统模型的传感信号输入,检查信号值的正值表示泵出现关键性失效的这类信号子集,当任何信号子集的值为正时把第一层警报报告给警报侦测控制器.第2层警报侦测组件接收来自系统模型的传感信号输入,检查信号值的正值表示当前注射液没有被正确传输的这类信号子集,检查信号值的正值表示泵出现关键性失效的这类信号子集.警告侦测组件接收来自系统模型的传感信号输入,检查信号值的正值表示泵出现某些异常但仍能安全工作的这类信号子集.4个子组件的EFSM模型在这里不再给出.图14~图17分别是对4个子组件的EFSM模型通过本文的抽象精化方法得到的抽象模型.图18是4个抽象模型的并行组合.图14警报侦测控制器组件EFSM抽象模型图15第1层警报侦测组件EFSM抽象模型图16第2层警报侦测组件EFSM抽象模型表7是抽象精化前后并行EFSM模型中状态数和迁移数的变化情况.表7抽象精化前后并行模型元素的变化情况状态数迁移数表8是4种方法为警报侦测组件的并行EFSM生成的测试用例情况.模型并行EFSM119729614429668629284从表8可以看出,SAT方法、AR方法和AR+SAT结合的方法都在很大程度上约简了测试用例数目和总长度.SAT方法的约简效果要比AR方法的好,主要原因是AR方法进行抽象精化时,得到的等价状态较多,但是能够合并的迁移不多,所以导致AR方法约简效果比SAT方法差.但是,通过AR方法对各个子组件进行抽象精化后再并行组合,使得覆盖某些抽象迁移的测试用例缩短,所以AR+SAT方法在SAT方法的基础上进一步很好的约简了测试用例数目和总长度.表9是3种方法为警报侦测组件的并行EFSM生成的测试用例的约简比例.模型并行EFSM49在表3中的数据表明,针对那5个EFSM模型,SAT方法的约简比例要比AR方法的高,表9可得出同样的结论.与前面的5个EFSMs相比,在并行组合的模型上AR+SAT能够约简更多的测试用例数目,同时也能很好的约简测试用例总长度.最后,3种方法的迁移覆盖率都是100%,查错能力也与传统方法相同.8相关工作有关测试用例优化的研究有很多.Hamon等人[14]在模型检验器SAL中集成了测试用例生成,最后得到的测试用例集虽然在测试用例的数目上会减少,但它的总长度不一定会减少,并且也没说明哪Page14图18警报侦测组件的并行EFSM抽象模型些测试用例可以扩展.Ammann等人[15]把生成的测试用例表示成模型,在该模型上模型检验余下的测试目标,来判定它们是否被该测试用例覆盖,这涉及到频繁地从测试用例到模型的转换及对模型检验器的调用.Fraser等人[16]在生成测试用例后,使用LTL重写规则消除目前已被覆盖的测试目标.Zeng等人[13]结合CTL重写规则进行了测试目标约简和测试用例集约简.其中都没有给出选择测试目标次序的方法,这恰恰会直接影响测试用例约简的效果.在文献[5]中我们提出一种在测试用例生成时约简的方法,根据CNF公式的可满足性约简冗余的测试用例.章晓芳等人[17]提出了一种基于测试需求的测试用例约简方法.郭曦等人[18]使用谓词抽象约简测试用例,使用谓词抽象划分等价状态,从抽象模型生Page15成测试用例,文中的建模工具是有限状态机模型并且文中没有考虑出现伪反例求精模型的情况.Gong等人[19]基于覆盖矩阵和路径向量约简的方法来约简为程序生成的测试用例集,该方法只分析了约简的测试用例集的查错能力但没有分析它的覆盖情况.Quentin等人[20]基于事件序列的组合覆盖准则进行测试用例约简,并在GUI应用上评估了他们的方法.Ng等人[21]使用形式概念分析获得模型中实体的包含关系,从状态机模型生成约简的测试用例集,文中只分析了测试用例集的迁移覆盖但没有分析它的查错能力.Wu等人[22]使用商空间理论对测试集进行划分,使用最小测试集生成算法生成最小测试集,文中没有对提出的方法进行实验评估.Kumar等人[23]使用模糊分簇把相似的测试用例分配到相同的簇,找到冗余的测试用例,该方法是在生成测试用例集后再进行约简.Harald等人[24]使用模型检验技术从UML状态图生成测试用例集,然后合并相关用例对得到约简的测试用例集,该方法会为生成那些冗余的测试用例而调用模型检验器,增加了测试用例生成的成本.文献[25-26]把测试用例集约简问题看成是优化问题.此外,有很多研究工作(例如文献[27-28])把启发式算法应用到测试用例集选择,即从已有的测试用例集中选择一个子集.本文以EFSM作为建模工具,根据公式簇建立状态等价关系,使用抽象精化方法构建抽象模型,结合SAT方法在生成测试用例的过程中约简测试用例集,一方面减少了调用模型检验器的次数,节省了测试用例生成的成本,另一方面有效地约简了测试用例集,缩减了测试用例执行的成本,此外,在约简测试用例的同时并未降低它的迁移覆盖率和查错能力.9总结与进一步工作本文将迁移上的谓词划分成公式簇,根据公式簇建立状态的等价关系,分几种情况讨论了如何合并相关迁移,进而构建初始的抽象模型.在抽象模型上通过模型检验技术生成测试用例,并说明了满足抽象模型覆盖的测试用例也能满足具体模型的覆盖.给出了判定伪反例和精化模型的方法.在最终的抽象模型(没有反例的抽象模型)上使用基于可满足性的测试用例生成方法生成反例.实验表明与传统方法、SAT方法、AR方法相比,结合AR和SAT方法能最有效地约简测试用例的数目及总长度,与此同时,并未降低迁移覆盖率和查错能力.最后并行组合模型的实例也说明,SAT+AR方法相比单独使用AR方法和SAT方法都具有更好的约简效果.本文的方法既节省了测试用例生成的成本,又缩减了测试用例执行的成本.将来,我们将把本文的方法应用到一个较大的实际系统,并开发一个抽象精化和SAT结合的测试用例优化工具.研究更好的抽象精化过程,获得更约简的抽象模型,从而更好地约简测试用例集.
