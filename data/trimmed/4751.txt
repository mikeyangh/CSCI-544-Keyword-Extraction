Page1形状图理论的定理证明张昱陈意云李兆鹏(中国科学技术大学计算机科学与技术学院合肥230026)(中国科学技术大学苏州研究院软件安全实验室江苏苏州215123)摘要验证操作易变数据结构的指针程序仍面临很多挑战.数据结构中严重的指针别名显著地复杂化对操作这些结构的程序的推理.为分析和验证操作易变数据结构的指针程序,文中提出了形状图逻辑.形状图是描述程序中静态声明的堆指针变量和动态分配的结构体中指针域变量的指向的一种有向图,能准确表达指针的有效性和指针之间的相等性,可用于判断两个访问表达式是否是别名.形状图逻辑是Hoare逻辑的一种扩展,是一种直接将形状图作为程序中指针断言集的程序逻辑.该文研究形状图的等价理论和蕴含理论以及它们的判定方法和应用.首先,把形状图及其等价规则和蕴含规则分别类比为代数项及其等式规则和重写规则,像研究代数规范的理论那样来研究形状图理论.该文定义了形状图的语法理论和语义理论,定义了形状图重写系统及其终止性、局部合流性和合流性,然后得到基于形状图重写的形状图等价判定和蕴含判定的方法.其次,提出循环不变形状图和递归函数前后形状图的自动推断方法.借助形状图理论的判定方法,该文把一个基于抽象解释的推断循环不变式的一般方法改编成推断循环不变形状图的方法.由于计算终止的递归函数总有非递归的出口,可以先通过非递归路径得到函数的后形状图的初值,然后再在递归路径上迭代求解.从而,可以像推断循环不变形状图那样来推断递归函数的前后形状图.第三,参照Nelson-Oppen框架,提出形状图理论和整数理论组合的一种判定方法.对易变数据结构,除了关心数据结构各节点是否连成预定的形状外,往往还关心数据在这些节点间的排列等特性,它们不能脱离易变数据结构的形状特征而单独验证.为此,所提出的组合判定方法针对这类程序的验证条件的特点,利用程序分析阶段得到的形状图对验证条件的前件中的符号断言按形状图的节点分组;然后运用整数理论为各节点推导出尽可能多的性质;最后才交由定理证明器Z3去自动验证.这种方式有效地避免验证条件证明过程的不终止.基于形状图逻辑以及文中的工作,我们所开发的程序验证系统原型减轻了自动定理证明器的负担,并且能验证易变数据结构上较为复杂的程序,如有序循环双向链表、二叉排序树、伸展树、树堆、二叉平衡树和AA树的插入和删除函数.关键词形状图逻辑;形状分析;程序验证;自动定理证明;循环不变式的推断1引言形式验证(包括抽象解释、模型检测和演绎验证等途径)是提高软件可信程度的重要方法,并在工业界已经逐步得到应用,尤其是抽象解释和模型检测.例如,空客公司在A400M军用运输机以及A380和A350客机的开发上,已经用形式验证取代了部分安全攸关嵌入式软件的测试.和单元测试相比,单元证明降低了投入,主要是因为它方便了维护[1].演绎验证在工业界的应用虽有限但也在拓展,达索航空公司在健壮性的形式验证方面,已有约15%的断言是用演绎验证方式证明的[1].在演绎验证方法中,有关自动程序验证的大部分研究按这样的途径开展:程序员提供函数前后条件和循环不变式,系统对程序采用某种正向或逆向Page3的演算来产生验证条件(即把对程序满足某些性质的证明转化为对一些验证条件的证明),然后用自动定理证明器来证明验证条件,如Ynot[2]、Spec#[3]和ESC/Java[4].有些研究依靠符号计算及其过程中的定理证明来避免验证条件的生成,如smallfoot[5]和jStar[6].无论用哪种策略,演绎验证方法都使用严谨的方式对软件系统进行数学推理,并且都借助定理证明软件,如定理证明器Isabelle/HOL[7]、定理证明辅助工具Coq①、SMT(SatisfiabilityModuloTheories)求解器Z3[8].基于演绎推理的自动形式验证方法对自动定理证明器的能力有较高期待.首先,定理证明器在程序验证过程中频繁使用.大到验证条件的证明和循环不变式的推断,小到下标变量的别名判断和数组边界检查,都需要或可以使用定理证明器.其次,需要能够应对各种领域专用逻辑的定理证明.应用程序的代码中可能涉及多种数据类型,操作系统的代码依赖于硬件特性,为完成对这些程序的验证,需要定理证明器能够覆盖这些领域专用逻辑的定理证明.第三,需要定理证明器能处理各种理论的组合.例如面向数组类型的数组逻辑,它由下标逻辑和元素逻辑组成.对于操作数组的程序的验证,定理证明器要能证明这两种逻辑的相应理论(可能还包括等式理论和未解释函数理论)组合后形成的组合理论上的定理.组合理论的问题复杂性在于:即使两个理论分别可判定,其组合理论未必可判定[9].数组理论就是这样的例子.本文研究操作易变数据结构(包括单/双向链表、循环单/双向链表②和二叉链表示的二叉树)的指针程序的自动验证中的一些定理证明问题.这类程序的验证非常困难.首先,难以给出表达程序性质的函数前后条件,尤其是循环不变式.因为它们涉及所操作的数据结构的结构性质(常使用带量词的命题和可达性谓词来表达)以及在数据结构中各节点内的数据的性质,而后者的描述可能紧密依赖于数据结构的结构性质,例如平衡二叉树节点的平衡因子和AA树节点的level值.其次,难以证明这类程序的验证条件,因为在验证条件中经常出现对数据结构所有节点的某种全称量化.这导致不能使用像Nelson-Oppen框架[9]这样仅适用于无量词理论的传统的理论组合.Z3虽然通过使用E-graph匹配技术能够处理量化公式,但也难以适应复杂的量化公式.除了要用量词刻画性质以及涉及的理论组合之外,验证条件的证明可能还要用到数据结构的归纳理论.例如,对于用根节点的中序前驱(其左子树中最右下的节点)代替根节点的、删除二叉排序树根节点的函数,若要证明结果仍然是二叉排序树,则需要用到二叉排序树的两个性质:左子树中任何节点的值一定小于右子树中各节点的值,左子树中最右下节点的值大于左子树中其他节点的任何值.它们都是二叉排序树的归纳性质,但是基于演绎推理的自动定理证明器不可能从二叉排序树的归纳定义推导出这些性质,因而无法证明依赖这些性质的验证条件.为验证操作易变数据结构的指针程序,我们提出了形状图逻辑[10].形状图是描述程序所操作的静态声明的指针型变量(简称声明指针)和动态分配的结构体中指针型域变量(简称域指针)的指向的一种有向图.它准确表达了指针的有效性(指针有效是说该指针指向已分配且尚未释放的内存块)和指针的相等性,因而可作为指针程序中指针有效性和相等性的断言.形状图逻辑就是一种直接把形状图作为程序中指针断言集的程序逻辑.它是Hoare逻辑的一种扩展,为指针操作语句设计了专门的推理规则,这些规则用图形方式描述指针操作语句引起的形状图上被关注部分的变化.利用形状图还可以方便地消除访问路径别名,使易变数据结构上数据性质的验证仍可用Hoare逻辑的规则进行推理.本文补足文献[10]所缺少的部分理论和算法.文献[10]主要围绕程序逻辑层面,提出把形状图作为指针断言,并在此基础上设计了推理指针程序的形状图逻辑和检查形状合法性的形状系统.本文围绕作为指针断言的形状图,研究形状图的等价理论和蕴涵理论以及它们的判定方法和应用.本文的贡献有如下3点:(1)提出形状图理论的一种判定方法.本文把形状图及其等价规则和蕴涵规则分别类比为代数项及其等式规则和重写规则,像研究代数规范的理论那样来研究形状图理论.本文类似地定义形状图的语法理论和语义理论,定义形状图重写系统及其终止性、局部合流性和合流性,最后得到基于形状图重写的形状图等价判定和蕴涵判定的方法.(2)提出循环不变形状图和递归函数前后形状①②Page4图的自动推断算法.借助形状图理论的判定方法,本文把一个通过迭代推断循环不变式的一般方法[11]改编成一个推断循环不变形状图的方法;进一步设计该方法的一个变种来迭代推断递归函数的前后形状图.(3)提出形状图理论和整数理论组合的一种判定方法.对易变数据结构,除了关心数据结构各节点是否连成预定的形状外,往往还关心数据在这些节点间的排列特性,它们不能脱离易变数据结构的结构特点而单独验证.于是需要研究形状图理论和整数上线性算术理论(假定节点数据是整型)组合的判定问题.本文针对验证条件的特点,利用程序分析阶段得到的形状图,参照Nelson-Oppen框架,提出形状图理论和整数上线性算术理论组合的一种判定方法.本文第2节简要回顾文献[10]提出的形状图、形状图变换规则和形状图逻辑;第3节介绍形状图理论的判定方法;第4节介绍循环不变形状图的推断和递归函数前后形状图的推断;第5节介绍形状图理论和整数理论组合的判定方法;第6节是验证实例;第7节是和相关研究工作的比较;第8节是总结.2形状图和形状图逻辑2.1形状图的结构体中域指针的指向关系的一种有向图.形状图是描述程序中静态声明指针和动态分配形状图的顶点(也称节点)有6种,其图形化语法形式见图1.其中声明节点和结构节点分别表示静态声明指针和动态分配的结构体.null节点和悬空节点的用意稍后会提到.浓缩节点是若干个结构节点和它们之间的有向边的浓缩表示,其灰色矩形下侧的表达式e和断言a分别表示被浓缩的结构节点的个数以及对e的取值范围的约束.若灰色矩形下无e和a,称为无约束浓缩节点,它表示被浓缩的结构节点个数任意,可以是0个.谓词节点代表满足指定谓词的若干节点和它们之间的有向边,其矩形节点下侧标有谓词名name,还可能有与浓缩节点含义一致的表达式e和断言a.指向谓词节点的有向边以及该节点下侧的e和a是该节点所代表的谓词的变元,例如图2给出了几种用形状图定义的数据结构,以单链表为例,图中谓词节点的变元和左侧的符号谓词list(s,e,a)的变元是一致的.形状图中的有向边表示声明指针和域指针的指向,指向同一个节点(悬空节点除外)的指针相等.有向边及其连接的节点满足如下语法约束:(1)声明节点.只有唯一的出边,没有入边,出(2)结构节点和浓缩节点.有入边和出边,其中出边的条数与结构节点所代表的结构体的域指针个数一致,各出边的标记分别是各域指针名.边的标记就是声明指针名.(3)null节点、悬空节点和谓词节点.有入边,没有出边.null节点和悬空节点分别用来表示指向它们的有向边代表null指针和悬空指针.形状图的定义:(1)节点和有向边满足上述语法约束,各声明节点出边标记相异,且边被视为无向时则连通的图形是形状图;(2)若形状图G1,G2,…,Gn的声明节点出边标记集两两相交都为空,则由逻辑合取符号∧连接的G1∧G2∧…∧Gn也是形状图.Page5其中,不含符号∧的形状图G被称为形状子图;(3)若形状图G1,G2,…,Gn的声明节点出边标记集都相同,则逻辑析取符号∨连接的G1∨G2∨…∨Gn也是形状图.从文献[10]有关形状图的语义知道,一个不含析取符号并且没有浓缩节点和谓词节点的形状图是程序状态中指针型数据的图形表示,不含析取符号的一般形状图G则是程序状态集的图形表示.G1∧G2中的G1和G2各代表程序状态的不同部分.G1∨G2中的G1和G2则代表不同的程序状态集.若无特别说明,符号G仅表示不含符号∨的形状图.图2给出基于形状图定义的单链表(域指针nt是下文next或nxt的简称,本文不区分这3个名称)、双向链表和二叉链表示的二叉树(系统还支持的循环单链表和循环双向链表的定义见文献[10]).在图2中,定义式最左边的dlist(s,e,a)等符号表示是为了便于在文中引用.可以看出,把dlist(s,e,a)的2个定义中的e和a部分略去,再用符号∨连接它们,就得到dlist(s)的定义.若用符号谓词表示,图2的二叉树定义相当于tree(s)s==NULL∨s!=NULL∧tree(s→r)∧tree(s→l).图3(循环)单链表的等价规则的3个例子2.2形状图的等价和蕴涵规则等价规则是保持形状图语义等价的变换规则.图3列出了在文献[10]的2.3节中定义的(循环)单链表的部分等价规则.第3节还会列举一些等价规则.除了等价规则外,形状图还有蕴涵规则,蕴涵规则是保持形状图语义蕴涵的变换规则.文献[10]中2.3节定义的形状图蕴涵规则分成三部分.(1)从等价规则WW1∨W2可得W1W和W2W两条蕴涵规则.例如,从图3(3)的等价规则可以得到两条蕴涵规则.(2)若等价规则W1W2的副条件是((e1==e2∧a1)a2)∧((e2==e1∧a2)a1),则有蕴涵规则W1W2和W2W1,其副条件分别是((e1==一个形状图的某形状子图中用点划线方框标明并满足下面条件的部分称为窗口,窗口描述形状子图上被关注的那部分,形状图的其余部分称为窗口的上下文.不得与窗口的方框边界相交.(1)形状图的各节点处于窗口内或上下文中,(2)窗口内各节点之间的边都位于窗口中.(3)表达窗口中节点与上下文中节点联系的、穿越方框边界的边属于窗口,这些边的另一份副本在上下文中.窗口W和上下文G[]的匹配就是检查穿越W边界的边和G[]中的副本边能否重合,重合后得到的形状图用G[W]表示.在形状图变换规则中出现的窗口有如下的缩写约定:对窗口中的某节点而言,若要求从窗口外指向该节点至少要有一条边(如图3的p1),则可能还有的、指向该节点的其他边(可以是0条)用一条标记为pk的边统一表示.窗口用来定义形状图的等价规则和蕴涵规则(见文献[10]的2.3节)及形状图逻辑的推理规则(见文献[10]的3.1节).e2)∧a1)a2和((e2==e1)∧a2)a1.例如,从图4的每条等价规则都可得到两条蕴涵规则.图4对浓缩节点的约束数据进行变换的部分等价规则(3)将等价规则中有约束浓缩节点改成无约束浓缩节点而得到蕴涵规则.例如,图5中蕴涵规则Page6(3)和(4)分别从等价规则(1)和(2)得到.蕴涵方向的选择(称为定向)取决于规则的左右两边谁蕴涵谁.以浓缩节点所代表的结构节点的个数n来直观解释,(3)和(4)的定向分别基于n==1n>=1和n>=1n>=0.图6指针赋值语句的一条规则需要注意的是,由于u、v代表访问路径,为便于描述推理规则,图6采用2.1节中窗口概念的一种扩展表示:将标记u和v等放在边的下方,以表示u和v等是访问路径,而不是边的标记(边的标记放在边的上方);它们要求在应用规则到某形状图时,形状图上应有相应的访问路径.例如,使用图6的规则图7指针赋值语句的另一条规则图8是两个表示单链表的形状图.假定head指向的单链表至少有一个表元,程序片段ptr1=head;ptr=head→next;while(ptr!=NULL){2.3形状图逻辑的推理规则在形状图逻辑中,有关指针操作语句的推理规则都是相应语句操作语义的图形表示.因为推理规则体现语句执行前后形状图的变化,而形状图是程序状态的图形表示,因此形状图的变化自然就是相应语句引起的程序状态变化.这里以指针赋值语句u=v的部分推理规则为例,介绍形状图逻辑中指针操作语句的推理规则.其中u、v代表从声明指针名出发、经若干条域指针边组成的访问路径,如q或p→next→next.图6是u指向null节点、v指向(循环)单链表结构节点时的推理规则(v指向浓缩或谓词节点的规则类似).从赋值前形状图G到赋值后形状图G的变化就是让u也指向v原来指向的节点.图6花括号中的不是形状图,而只是其中被所关注的若干个窗口.若图6中的4个窗口自左向右依次用W11、W12、W21和W22表示,则对任意能够使G[W11,W12]成为形状图的上下文G[],有推理规则其中G[W11,W12]上的窗口W11和W12无重迭部分.因此,严格说图6只是规则的窗口而不是规则,简单起见仍称为规则.时,G[W11,W12]要有从某声明节点到达W11中节点的访问路径,访问路径上各边的标记顺次连接构成u.图7是u指向(循环)单链表结构节点、v指向null节点时的推理规则(v指向浓缩或谓词节点的规则也类似).若赋值前只有u指向结构节点,则报告内存泄漏.ptr1=ptr;ptr=ptr→next;}的循环不变形状图就是图8(1).当ptr!=NULL为真进入循环时,利用图3(3)的规则,把ptr指向的浓Page7缩节点展开成两种情况,其一与ptr!=NULL矛盾被略去,另一种情况就是图8(2)的形状图.把语句ptr1=ptr当作语句序列dummy=ptr;ptr1=NULL;ptr1=dummy;dummy=NULL,按图6和图7的规则逐步修改图8(2),其中dummy是初值为NULL的虚拟局部指针变量.引入dummy主要是为了避免为某些特殊的指针赋值情况设计复杂的专用规则,见文献[10]的3.1节.对ptr=ptr→next也继续用类似的方法修改形状图,再把得到的形状图用类似图3(3)的规则,把ptr1原先指向的结构节点逆向折叠进左边的浓缩节点,得到图8(1).3形状图理论的判定方法形状图的等价推理规则集由文献[10]中2.3节的形状图等价规则(不包括那些推导形状图析取G1∨G2的规则,例如本文图3(3))和任何等价推理系统都有的自反、对称和传递规则组成.该规则集可用来证明形状图之间的等价性.若等价形状图的集合E是封闭于可证明的,即G1G2蕴涵G1G2∈,则把叫做形状图的一个语法等价理论.类似地可以定义形状图相应的语义等价理论,即G1G2蕴涵G1G2∈.由文献[10]中2.4节关于等价规则的性质定理,不难证明G1G2当且仅当G1G2.类似地根据形状图的蕴涵规则,可以定义形状图的语法蕴涵理论和语义蕴涵理论及证明G1G2当且仅当G1G2.本节介绍形状图的重写系统和这两种理论的判定方法.3.1形状图的等价重写系统形状图的等价重写系统可比照代数项的重写系统[12]来讨论.它用于形状分析和验证过程中对形状图进行等价化简.形状图等价规则限制为单向后得到的蕴涵规则就是一条形状图重写规则.一组形状图重写规则构成一个形状图重写系统.不能用该系统的规则再进行归约的形状图称为最简形状图.不存在无穷归约序列的系统称为具有终止性的系统.可以参照项重写系统继续定义系统的临界对(criticalpair)、局部合流性和合流性.仿照Knuth-Bendix完备化过程[13],可以把文献[10]中2.3节的等价规则集变换成一个与之等价并且终止与合流的形状图重写系统.下面先以一个简单的项重写系统为例来熟悉项重写系统的一些概念,然后说明项重写和形状图重写之间的主要异同.例如,代数等式x+0=x,x+(-x)=0,(x+y)+z=x+(y+z)是属于包含0、加和一元减的自然数等式系统中的等式,把它们从左到右定向,得到3条重写规则x+0→x,x+(-x)→0,(x+y)+z→x+(y+z)项x+(y+(-y))的子项y+(-y)与第2条规则的左部匹配,因此x+(y+(-y))可用第2条规则重写成x+0,再依据第1条规则重写为x.不难证明这3条规则构成的重写系统是终止的.要证明合流性,需要考察临界对.第3条规则左部的子项x+y和该规则左部(x+y)+z(加撇号以便区别)合一,得到临界对〈(x+y)+(z+z),(x+(y+z))+z〉该临界对中的两个项都能归约到x+(y+(z+z)).可以类似地计算该重写系统的其它临界对并证明每一临界对中的两个项都能归约到同一个项,所以该系统具有局部合流性.再由终止性可得该系统具有合流性.在上述项重写系统中,规则的左部和右部都是项,被重写的也是项.而形状图系统与项重写系统相比,最大的区别是:规则的左部和右部都是窗口,被重写的是形状图.产生该区别的根源在于形状图是二维的.基于同样的原因,合一和匹配的描述也有区别.但是两个系统的本质概念和方法是一致的.下面先给出节点相同和形状图相同的定义.定义1.节点n1和n2若满足下面两个条件,则称n1和n2相同:(1)n1和n2是同类节点,并且若都是声明节点、结构节点或浓缩节点,则有同样的出边及其标记;若都是谓词节点,则谓词名相同.(2)若n1和n2是同类浓缩节点或谓词节点,且分别带e1与a1和e2与a2,则必须满足(e1==e2∧a1)a2并且(e1==e2∧a2)a1.其中,无约束浓缩Page8节点在此都被视为带m与m>=0的浓缩节点.下面讨论判定方法时也作如此假设.定义2.形状子图G1和G2若满足下面两个条件,则称G1和G2相同.(1)G1和G2的节点一一对应.(2)G1和G2的对应节点都是相同节点,并且若它们有出边,则标记相同的出边所指向的节点是对应节点.定义3.形状图G1和G2若满足下面的条件,则称G1和G2相同.G1和G2的形状子图一一对应并且相同.在从形状图的等价规则构造重写系统时,可以忽略如图4那样仅替换浓缩节点的e和a的那些等价规则,因为定义1已把替换前后的浓缩节点定义为相同.在完备化过程中,文献[10]中2.3节的(循环)单链表、(循环)双向链表和二叉树的等价规则按照节点数减少的方向定为重写规则,例如图9的等价规则(1)和(2)定向为从右向左的重写规则.规则(1)和(2)其实是同一条规则,只要把其中一条规则中边上的标记r和l对调一下就可看出,这里写成两条是为了便于下面理解和讨论临界对.对那些两边节点数相等的各种等价规则,可按下面的方式之一定向:(1)对于1个结构节点和e等于1的浓缩节点之间的等价规则,定向为向浓缩节点的重写,例如图9(3)定向为从左向右.按这个方向定向是便于若干个相邻的结构节点归约成浓缩节点.(2)对于出自链表定义的等价规则,定向为向谓词节点的重写,例如图9的规则(4)和(5)定向为从右向左.形状图的归约一定会终止,因为每次归约都会使节点数减少或保持不变,而节点数保持不变的重写情况受上面两条的限定,因此归约一定会终止.的合流性可以参照项重写系统合流性的证明方法来证明.首先考虑临界对,例如,由图9的等价规则(1)和(2)得到两条重写规则R1和R2.R1和R2的左部(对应图9等价规则(1)和(2)的右部)经两种方式合一,得到2个临界对,分别是图10的(1)和(2)与图10的(3)和(4),它们分别都能化简到相同的窗口.其余的临界对也都是由于规则的窗口中有(循环)单链表、(循环)双向链表或二叉树的浓缩节点而产生的,例如对应图3(1)和(2)的相应重写规则也会产生2个临界对.很容易检查它们都可归约到同样的窗口,因而证明是局部合流的.再根据的局部合流性和终止性可以证明是合流的.基于形状图等价重写系统以及图4这样的规则,参照代数项上的证明方法,不难证明下面的定理.定理.形状图G1和G2等价,即G1G2,当且仅当它们化简后的最简形状图G1和G2相同.3.2犌1,1∨…∨犌1,犿犌2,1∨…∨犌2,狀的判定方法抽象地说,判定G1,1∨…∨G1,mG2,1∨…∨G2,n可以先用3.1节的等价重写系统把两边所有的形状图分别化简,然后比较两边的各个最简形状图是否都能在对方找到相同的形状图.但是3.1节的Page9等价重写系统并未考虑个数不同的形状图之间的等价性,为此需要利用文献[10]中2.3节里的WW1∨W2等价规则(如图11)展开形状图,以期建立个数不同的形状图之间的等价性.结合应用场合的特点,本文讨论的等价式中各形状图的声明变量集都相同,等价式的判定方法如下:(1)若G1,1和G2,1的声明变量集不同则该等价式不成立.否则继续下面步骤.(2)将上式中所有的形状图,用3.1节介绍的形状图重写系统把它们归约到最简形状图.仍用原来的符号G1,i(1im)或G2,j(1jn)代表各形状图的最简形状图.(3)若某个G1,i(1im)的某条尽可能长的且不经过浓缩节点的访问路径是某个G2,j(1jn)的某条不经过浓缩节点的访问路径的真前缀,并且若G1,i中的这条访问路径指向的节点可以用WW1∨W2的等价规则展开,则将其展开.反之亦然.直到不存在这样的路径或者虽存在但不能展开为止.为防止滥用WW1∨W2这类等价规则,需要从访问路径的比较上加以限制.例如,若G1,i中有不能再延长的二叉树访问路径p→l,G2,j中有访问路径p→l→r,且在G1,i中p→l指向谓词节点,则可以根据图11的二叉树等价规则将G1,i展开,其中等价规则中的s是占位符,可以通配访问路径p→l中的l.该规则由图2的二叉树定义得到.文献[10]中2.3节里的所有的WW1∨W2都像图11这样,右边W1或W2中指向谓词节点或浓缩节点的访问路径比W的多一个结构体的指针域,因此不会出现等价式左右两边的形状图不断交替展开而不终止的情况.经过这样的展开,原等价式变换成G1,1∨…∨G1,mG2,1∨…∨G2,n.(4)对每个G1,i(1im),若存在某个G2,j(1jn),使得G1,i和G2,j相同,并且反之亦然,则G1,1∨…∨G1,mG2,1∨…∨G2,n,否则该式不成立.显然,若上述方法中涉及的由整型线性表达式之间的关系式所构成的断言都可判定,则G1,1∨…∨G1,mG2,1∨…∨G2,n可判定.3.3犌1,1∨…∨犌1,犿犌2,1∨…∨犌2,狀的判定方法该判定方法用于程序分析和验证过程中对形状图蕴涵关系的判定,例如第4节的循环不变形状图和递归函数前后形状图的推断算法需要用到该方法.先定义节点相容和形状图相容.n1相容于n2(与定义1的区别仅在条件(2)).定义4.节点n1和n2若满足下面的条件,则(1)n1和n2是同类节点.并且若都是声明节点、结构节点或浓缩节点,则有同样的出边及其标记;若都是谓词节点,则谓词名相同.(2)若n1和n2是同类浓缩节点或谓词节点,且分别带e1与a1和e2与a2,则必须满足(e1==e2∧a1)a2.定义5.形状子图G1和G2若满足下面3个条件,则称G1相容于G2.(1)G1的节点集N1到G2的节点集N2有一对一的函数f,使得N2-f(N1)若非空,则其中只有浓缩节点并且每个浓缩节点的(e==0)∧a可满足,即这些浓缩节点可以有e等于0的情况.(2)对任何n∈N1,n相容于f(n).(3)对任何n∈N1,若n和f(n)的某标记相同的出边分别指向节点n1和n2,则n2经过m个(m0)属于N2-f(N1)的浓缩节点后所到达的n2和n1满足f(n1)=n2.对于图12的G1和G2,G1的那个浓缩节点经f函数映射到G2最右边的那个浓缩节点.因为G2左边两个浓缩节点的m和k都可以等于0,所以G1相容于G2.则称G1相容于G2.定义6.形状图G1和G2若满足下面的条件,G1和G2的形状子图一一对应并且G1的每个形状子图相容于G2中对应的形状子图.在证明形状图之间的蕴涵时,需要考虑在用等Page10价重写系统化简形状图后,适当地使用形状图的蕴涵规则.所使用的蕴涵规则是2.2节中第(1)类蕴涵规则,即由WW1∨W2得到的W1W和W2W;而对于第(2)和(3)类蕴涵规则,由于它们都是针对浓缩节点的e和a的规则,其效果已体现在节点相容的定义中,因而不必作为重写规则.G1,1∨…∨G1,mG2,1∨…∨G2,n的判定方法可通过略微修改3.2节的等价式判断方法中的(3)和(4)两点即可得到:(3)若某个G2,j(1jn)的某条尽可能长的且不经过浓缩节点的访问路径是某个G1,i(1im)的某条不经过浓缩节点的访问路径或其真前缀,但不是指向同类节点,则尝试使用上面提到的蕴涵规则对G1,i进行重写.例如,若图11规则右部两个窗口之一和左部窗口分别出现在G1,i和G2,j中的上述位置,则使用相应蕴涵规则重写G1,i,把窗口中内容归约成谓词节点.(4)对每个G1,i(1im),若存在某个G2,j(1jn),使得G1,i相容于G2,j,则G1,1∨…∨G1,mG2,1∨…∨G2,n,否则该蕴涵式不成立.4循环不变形状图和递归函数前后形状图的推断本节应用第3节的形状图理论判定方法来推断循环不变形状图.该推断方法的一个变种可用来推断递归函数的前后形状图.形状图是指针有效性和指针相等性断言的集合的图形表示,循环不变形状图就是循环不变式中有关指针断言的那部分不变式,函数前后形状图就是函数前后条件中有关指针的那部分断言.面功能之一:对易变数据结构的处理,循环语句通常完成下(1)寻找数据结构中的操作位置或依次对各节点上数据进行操作.这时,除了某些声明指针的指向在节点间移动外,形状图没有其他变化.(2)循环体的每次迭代都在对数据结构进行节点插入或删除.循环体执行过程中虽然破坏了数据结构的形状,但每次到达循环体结束点时,形状得到恢复,仅节点个数发生变化.(3)循环体的每次迭代都在对数据结构某些节点的边的指向进行调整,并且有可能出现这样的情况:每次迭代结束时形状并未得到恢复,但在整个循环执行结束时形状得到恢复.例如文献[10]中例2使用的双向链表倒置算法.对于这类循环,在循环体的每条执行路径上,声明指针在形状图上的移动引起的形状图变化主要体现在浓缩节点所代表的节点个数的变化上.4.1循环不变形状图推断算法的框架根据基于抽象解释的循环不变式推断框架[11],循环不变形状图的推断算法框架如图13.为表达简单起见,本节用字母表示可以出现形状图析取的形状图.对于循环while(B)S(1)计算循环前条件0=pre.i=0.(2)根据形状图逻辑的规则计算i+1,使得(3)应用抽象规则计算i+1,使得i+1i+1.(4)若i+10∨…∨i,则0∨…∨i是循环不变形状下面对图13的算法框架做一些解释:(1)算法第(2)步根据形状图逻辑的规则计算i+1,i∧B代表形状图i和符号断言B的合取[11].若碰到引起内存泄漏的操作、悬空指针或null指针脱引用(dereference)操作,则无规则可用,报告错误.(2)算法第(3)步的抽象是指:对形状图上随循环迭代次数变化而变化的浓缩节点(指其代表的结构节点数随迭代次数变化而变化),把其代表结构节点数的表达式换成能概括多次(甚至全部)迭代情况的表达式.应用的抽象规则是采用文献[10]中第2.3节的蕴涵规则.(3)算法第(4)步i+10∨…∨i的证明是采用3.3节的判定方法.以2.3节的那段单链表代码(假定至少有一个表元)的循环不变形状图(图8(1))的推断为例.各程序点的形状图见图14,图中j是形状分析系统引入的虚拟变量.第1次迭代后G1G0不成立,但第2次迭代后能证明G2G0∨G1,因此G0∨G1是循环不变形状图.由于G0G1,因此G0∨G1可简化为G1.由于没有程序变量可以替代G1中的虚拟变量j,则略去j,得到结果就是图8(1).4.2算法终止的讨论图13算法终止取决于下面3点:(1)算法第(3)步的抽象能够成功.(2)算法第(4)步的蕴涵式的证明因得到结果而终止或因形状检查发现错误而终止.Page11蕴涵式最终会成立.(3)若形状检查没有发现错误,算法第(4)步的该算法终止的理由概述如下:(1)本文为循环体S的每条执行路径都安排累计该路径执行次数的虚拟变量.选择一种合适的虚拟变量命名方式,能应对出现并列和嵌套循环的情况以及循环体中出现并列和嵌套条件语句的情况.在增加虚拟变量时,还要把表达虚拟变量之间关系的等式或不等式加到相关形状图中.通过增设虚拟变量,结合下面(2)有关浓缩节点的e表达式为线性的讨论,算法第(3)步的抽象就能够成功,即可以把浓缩节点所概括的节点数抽象为用含相应虚拟变量的线性表达式来表示.(2)从第3节知道,形状图蕴涵关系判定方法的终止性依赖于判断浓缩节点之间蕴涵与否的(e==e∧a)a的证明的终止性.下面是相关的分析.对于循环体S的任意一条执行路径,对于除第1次迭代计算以外的其他各次迭代计算的结果形状图,若与上次迭代计算的结果形状图相比,某浓缩节点所代表的节点数发生变化,则再次迭代计算引起的变化与本次迭代计算的变化相同.若循环前某浓缩节点代表ax+b个节点,第1次迭代时,个数变化是d,随后各次迭代的个数变化是c,则该路径执行y(y>1)次结束时,该浓缩节点代表的节点数是(ax+b)+(cy+d),由于(ax+b)在循环执行过程中不变,因此在图13算法中证明形状图之间的蕴涵时可当成常量.这样,在每次迭代计算过程中,浓缩节点所代表节点的个数本质上可用该路径的虚拟变量的线性表达式来表示,这就保证了该浓缩节点的表达式e维持为线性.类似的分析可知a中的整型表达式也是线性.这就保证(e==e∧a)a的证明会终止.图14例子的迭代过程体现了这里所说的对浓缩节点的抽象.另一方面,在有p=p→next这样指针赋值的情况下,除第1次迭代计算外,若一次迭代计算的结果形状图中出现无声明节点指向的结构节点,但又不能折叠成(或并入相邻)浓缩节点.则表明该结构节点的出边的指向不符合数据结构定义的要求,先前关于循环语句的3种用法中不会出现这样的情况.因此,若经抽象后,相邻2个声明指针所指向的节点之间的结构和浓缩节点的个数大于3(简称节点个数约束),则在循环体结束点的形状检查[10]会报告错误并终止迭代.例如,对于各节点都有指针域l和r的双向非空链表,用循环依次将各节点的l域置为NULL且r域的指向不变.代码如下:p=head;while(p→r!=NULL){p=p→r;p→l=NULL;}这相当于废弃l域,用r来构成一个单链表.图15(1)是循环入口的形状图,图15(2)是经过3次迭代的形状图.本算法无法把已经遍历过的结构节点折叠为浓缩节点,因为双向链表没有相应的规则.形状检查会因两个相邻声明节点超出节点个数约束而报告错误.Page12图15循环不变形状图推断过程报告错误的例子(3)由于声明指针的个数有限,再加上(2)提到的节点个数约束,在循环体结束点能形成的不等价形状图有限.若未见报告程序错误,则一定存在i,使得i+10∨…∨i成立.4.3递归函数前后形状图的推断对于非递归函数,可以从函数前形状图自动推断函数后形状图.但该方法难以用到有指针型形参且返回值是指针的递归函数,因为推断递归函数前后形状图时要用到该函数的前后形状图.若仅有指针型的形参,或仅有指针型的返回值,根据形状系统对函数调用点和返回点的形状约束,函数的递归性并没有给形状分析带来困难.倘若形参和返回值都是指针型,则虽有形状系统的约束,在函数返回点也不能确定实参指针和返回指针之间的关系,因而不能确定函数后形状图.关注实参指针是因为它的值在被调用函数中虽不变,但其指向的节点在数据结构中的位置可能会变.为此,函数的前形状图增设虚拟变量来表示实参指针,它与形参指针指向同一个节点,并据此来推断函数后形状图.可以像推断循环不变形状图那样迭代推断函数后形状图.因为计算会终止的递归函数总有非递归的出口,可以先通过非递归路径得到函数后形状图的初值,然后再在递归路径上迭代求解.对于直接递归函数,若函数体中的循环语句里面没有递归调用(通常如此),则函数前后形状图的推断方法概述如下:(1)通过程序分析,确定函数体中非递归执行路径和递归执行路径的语句序列.这里所说的执行路径把无递归调用的循环语句看成一个语句,把两个分支都有(或都无)递归调用的条件语句也看成一个语句,以减少要考虑的路径数.为叙述方便,假定非递归和递归的执行路径各一条,语句序列分别是Snon和Srec.(2)从函数前形状图entry和Snon通过形状图逻辑的规则得到0,使得{entry}Snon{0}.令i=0.(3)根据形状图逻辑的规则计算i+1,使得{entry}Srec{i+1}.其中entry和i作为Srec中出现的递归函数调用的前后形状图.(4)应用抽象规则计算i+1,使得i+1i+1.(5)若i+10∨…∨i,则0∨…∨i是函数后形状图;否则,i=i+1,转(3).除了推断递归函数的函数前后条件需先分析函数的非递归和递归的执行路径外,本算法与图13算法没有本质上的区别,把本算法的第(2)到(5)步与图13算法的第(1)到(4)步比较就可以看出这一点.5形状图理论和整数理论组合的判定方法在程序验证器原型中,验证条件生成器所产生的验证条件的一般形式是:(G1,1∧Q1,1)∨…∨(G1,m∧Q1,m)(G2,1∧Q2,1)∨…∨(G2,n∧Q2,n)其中Q代表符号断言的合取,并且其中没有指针相等性断言和有效性断言.验证条件的证明是形状图理论和整数线性算术理论的组合的判定问题.首先,形状图之间蕴涵的证明要根据形状图理论.其次,Q中像p→d<q→nxt→d这样的断言,需要根据形状图来判断p→d和q→nxt→d分别是属于哪个节点的数据.注意,在形状图中,浓缩节点和谓词节点可能附带e和a.这表明形状图理论内部涉及线性整数算术理论.它与本节讨论的理论组合的判定问题没有联系,因为系统原型限定e和a只依赖整型声明变量,不依赖于节点的数据.因为e和a是决定该浓缩节点或谓词节点所代表的链表(段)的长度、或者所代表的二叉树片段的高度的表达式和断言,通常在实际编程中不会把决定某种数据结构的长度或高度的信息存放在该数据结构节点的域中.本节讨论组合理论的两种证明方式.5.1易变数据结构上被关注性质的描述通常关注易变数据结构3个层次的性质:(1)各个节点是否连接成预定的形状该性质的验证在形状分析阶段完成,程序员只要像声明类型那样声明形状即可.这仅是形状图理论上的问题.Page13(2)与形状有关的性质例如链表的长度、树的高度、二叉树的两边是否平衡和节点之间的可达性等.这些性质很容易归纳定义,虽然循环链表的长度的归纳定义会略显复杂.(3)与各节点上数据排列有关的性质当数据需按序排列时,一个数据存放到哪个节点依赖于对数据结构上节点的定序.线性链表上节点之间的定序比较简单,二叉树上节点之间有多种定序方式.这样,数据是否有序的比较必定涉及数据所属节点在数据结构上的位置.在定义上述性质时,比较简单的方式是用以指针为参数(可能还有其他参数)的归纳谓词.另一种方式是先定义节点之间的可达关系,然后基于此再使用量词来定义所需的性质.用这两种方式描述性质都比较有利于对操作易变数据结构的递归程序的验证.本文的系统原型针对形状图上浓缩节点的特点,还提供使用量词来概括数据性质的方式,以方便操作易变数据结构的循环程序的验证.例如有序单链表可定义为SortedList(Nodep)m:.(p(→nxt)m==NULL∧i:1..m-1.p(→nxt)i-1→d<=p(→nxt)i→d)其中Node类型由typedefstructnode{intd;structnodenxt}Node给出,其中p(→nxt)i代表p→nxt…→nxt,共i个“→nxt”.在该定义中,量词的约束变元出现在访问路径的上角标中.这种直接基于编程语言中访问路径语法的定义显得比较直观.5.2符号断言语言语言的抽象语法描述在图16.几点说明如下:为便于下面的讨论,将系统原型所使用的断言id∈Identifier(程序中的标识符集)tn∈Sidentifier(程序中结构体类型的名字集)predicatedefinitionpd∷=predicateid(pp1,…,ppk)=apredicateparameterpp∷=tidparametertypet∷=int|tnpropertytheorempt∷=theorema1a2|theorema1a2assertion(boolexp是布尔表达式,其产生式略去)a∷=boolexp|id:d.a|id:d.a|(a)domain(intexp是整型表达式,其产生式略去)d∷=||l-valuelv∷=…|lv(→id)intexp(1)图16前一部分是自定义谓词以及这些谓词之间性质定理的语法,后一部分是断言的语法.谓词应用可出现在布尔表达式中,因而可出现在断言中.(2)程序员用图16的文法编写的断言中出现的变量,若不是程序变量,则称之为逻辑变量.(3)量词约束变元的论域只能是整数域或它的某个区间,因而禁止使用指针型约束变元.在需要由存在量词来约束指针型变元的地方,可以用指针型逻辑变量来代替.下面用有序单链表来解释为什么需要提供性质定理.有序单链表的归纳定义如下:SortedList(Nodep)p==NULL∨p→nxt==NULL∨p→d<=p→nxt→d∧SortedList(p→nxt)在一个子句中,若出现以p为前缀的访问路径,则默认有断言p!=NULL.SortedList的定义从表尾向表头方向归纳.但是,在遍历有序单链表时,例如图17单链表插入函数中的循环代码(暂且不关心图17中的断言),其遍历方向是从表头向表尾,因此还需要用下述表段谓词和性质定理.SortedListSeg(Nodep,Nodeq)p==q∧q!=NULL∨p→d<=p→nxt→d∧SortedListSeg(p→nxt,q)和SortedListSeg(p,q)∧q→d<=q→nxt→dSortedListSeg(p,q→nxt)这个性质定理保证已扫描过的表段再加入下一个被扫描的节点,结果仍然是表段.如下性质定理也是验证时不可缺的:SortedList和SortedListSeg两个谓词之间的SortedListSeg(p,q)∧SortedList(q)SortedList(p)上述2个性质定理都需要程序员提供,因为它们的证明需要基于表段的长度进行归纳,基于演绎推理的自动定理证明器难以发现这样的性质.SortedList谓词出现在函数的前后断言中,而SortedListSeg谓词出现在循环不变式中.后者的定义只要能支持函数前后条件的证明就足矣,没有必要选择最一般的定义,即把被验证函数中不会出现的情况也囊括在内,以免给验证增添不必要的麻烦.在断言文法及其类型系统的基础上,还要限制断言中的整型表达式必须是线性表达式.Page14typedefstructnode{structnodenxt;intd;}Node;/singly-linkedlist//@assertionm==length(head,nxt)∧oldhead==head∧i:1..m-1.(head(→nxt)i-1→d<=head(→nxt)i→d)oldhead是为记住实参指针的值而引入的逻辑变量/Nodeinsert(Nodehead,intdata){Nodeptr;Nodeptr1;Nodep;intj;p=malloc(Node);p→d=data;p→nxt=NULL;if(head==NULL){head=p;}elseif(p→d<=head→d){p→nxt=head;head=p;}else{ptr1=head;ptr=head→nxt;j=1;/@loop_invariantptr!=NULL∧i:1..j-1.(head(→nxt)i-1→d<=head(→nxt)i→d)∧ptr1→d<=ptr→d∧ptr1→d<p→d∧j>=1∧oldhead==head∧i:1..m-j-1.(ptr(→nxt)i-1→d<=ptr(→nxt)i→d)∨ptr==NULL∧i:1..j-1.(head(→nxt)i-1→d<=head(→nxt)i→d)∧ptr1→d<p→d∧j>=1∧oldhead==head/while((ptr!=NULL)&&(ptr→d<p→d)){ptr1=ptr;ptr=ptr→nxt;j=j+1;}p→nxt=ptr1→nxt;ptr1→nxt=p;}returnhead;}/@assertionlength(head,nxt)==m+1∧i:1..m.(head(→nxt)i-1→d<=head(→nxt)i→d)∧oldhead==NULL∨head→d<=oldhead→nxt→d∧oldhead==head→nxt∧length(oldhead,nxt)==m∧i:1..m-1.(oldhead(→nxt)i-1→d<=oldhead(→nxt)i→d)∨length(head,nxt)==m+1∧i:1..m.(head(→nxt)i-1→d<=head(→nxt)i→d)∧oldhead==head/图17单链表的插入函数5.3验证条件的证明方法对于验证条件(G1,1∧Q1,1)∨…∨(G1,m∧Q1,m)(G2,1∧Q2,1)∨…∨(G2,n∧Q2,n),在形状分析阶段已经证明了即对每个G1,i(1im),存在G2,j(1jn),使得G1,iG2,j.现在仅需要证明:对每个G1,i∧Q1,i,存在G2,j∧Q2,j(其中G1,iG2,j已经证明),使得G1,i∧Q1,iQ2,j.可把G1,i看成Q1,iQ2,j的证明环境,写成G1,iQ1,iQ2,j.实际证明时,还有程序员提供的谓词定义和性质定理可用,用字母T表示,因此下面仅关注G,TQQ的证明方法.G,TQQ的证明有两种方式:第1种是常规的方式,把形状图理论和整数理论组合的判定转换为整数理论上的判定.它通过引入一些未解释函数,把G转换成符号断言P,然后把(P∧T∧QQ)交给Z3.具体把形状图转换为符号断言的方法见文献[14].这种方式的缺点是,在推理Q中涉及节点数据的断言时,指针符号断言P不能像形状图G那样提供对形状的全局把握,从而某些验证条件用Z3证不出.举例说明如下:例1.单链表的插入函数,代码和断言见图17.该例的循环不变形状图是根据4.1节的算法自动推断的.为可读起见,断言都出现在注释中.图18是return语句之前程序点形状图G1,1∨G1,2∨G1,3∨G1,4(分别对应只有新插入节点、插在表头、插在表中和插在表尾4种情况)中的G1,3,其中head是为表示实参指针而增设的虚拟变量,对应的Q1,3是下述符号断言,其中有序性用全称量化断言表示:i:1..j-1.(head(→nxt)i-1→d<=head(→nxt)i→d)∧ptr1→d<p→d∧p→d<=ptr→d∧j>=1∧i:1..m-j-1.(ptr(→nxt)i-1→d<=ptr(→nxt)i→d)G1,3转换成的符号断言如下:head==head∧ptr1==head(→nxt)j-1∧p==ptr1→nxt∧ptr==p→nxt∧ptr(→nxt)m-j==NULL∧length(head,nxt)==j-1+2+m-j由G1,3转换得到的断言是一些有关有效指针相等、指针等于NULL和链表长度的断言,它们是形状图所包含信息的符号表示.其他信息,例如p==head(→nxt)j可以从这些断言推导.显然,这些断言和Q1,3的合取能蕴涵函数后条件中的第3种情况(即图17中的最后一行,记为Q2,3).把这些符号断言转换成Z3能接受的形式的转换方法见文献[14].Page15用Z3证明不了这样的蕴涵.原因是在符号断言中,Z3难以发现Q1,3中4个断言的前后衔接次序.若有图18的形状图,通过把这4个断言分别标注到相关节点上,则很容易发现它们合并后就是Q2,3中的全称断言.采用第1种方式的另一个问题是,若与某个归纳谓词定义相对应的某条展开规则对验证来说是需要的,则容易引起Z3不停地用该展开规则去展开断言中出现的谓词应用,导致证明不终止.第2种证明方式是把形状图直接用于G,TQQ的证明.参照Nelson-Oppen框架[10],本文提出的G,TQQ的证明方法概述为如下3步:(1)将Q(形式为Q1∧…∧Qm)中所有与节点相关的Qj(1jm)都标注在G中相关的节点上.①相关的节点是指断言中的指针型访问路径(包括整型访问路径的最长指针型前缀)所到达的节点.例如,例1中Q1,3的断言ptr1→d<=p→d标注在图18中ptr1和p指向的节点上,断言p→d<ptr→d标注在图18中p和ptr指向的节点上.②全称断言经常标注在某个浓缩节点上.若在一个全称断言中,约束变元的取值集合使得该断言与多个节点相关,则把该断言同时标注在这些节点上.例1中Q1,3的全称断言i:1..m-j-1.(ptr(→nxt)i-1→d<=ptr(→nxt)i→d)标注在图18中ptr指向的节点上,断言i:1..j-1.(head(→nxt)i-1→d<=head(→nxt)i→d)标注在图18中head和ptr1指向的两个节点上.对于有两个指针变元的谓词应用,情况与全称断言的类似.(2)把能推导出的性质继续标注在G的相关节点上,一直到G的节点都不会再增加新的性质为止.①新性质的相关节点若都不在G中,则无须标注这类新性质,这有利于保证推导过程的终止.②对于标注有全称断言的浓缩节点,注意它与相邻节点之间是否可以利用((i:m..n-1.P(i))∧P(n))i:m..n.P(i)等等价性来使得全称断言的约束变元的取值范围扩大.(3)对Q(形式为Q1∧…∧Qk)中的每个Qj(1jk),检查QQj是否成立.①若Qj是节点相关的断言.不论是谓词应用、全称断言还是整数断言,若Qj从相关节点的断言以及Q中与节点无关的断言可推导,则QQj成立,否则不成立.节点数据之间的关系可能通过与节点无关的断言来传递,因此这里强调包括Q中与节点无关的断言.例如,若p→d==m且p→nxt→d==n且m<n,则p→d<p→nxt→d.②若Qj是节点无关的断言.若Q不能从Q推导,则QQj不成立.若对每个Qj(1jk),QQj都可证,则G,TQQ得证.可以证明,若整数域上断言的证明都可终止,则该证明过程终止并且可靠.这个方法专用于面向操作易变数据结构的程序的验证.与Nelson-Oppen框架不同的是,这里没有交错使用两个理论不断推出新性质并进行传播的过程,而是在形状分析阶段先用形状图理论完成形状图蕴涵关系的证明.这里只是利用形状图来把符号断言分组,一方面便于推导更多对验证有用的性质,另一方面防止出现无止尽地推导.另一个不同是,Nelson-Oppen框架限定被组合的理论为无量词的一阶理论,而这里允许量词断言出现在操作易变数据结构的程序的规范中.6实例分析基于形状图逻辑所实现的程序验证器原型(可从http://kyhcs.ustcsz.edu.cn/SGL下载)[14]的流程分成下面3个阶段.(1)预处理阶段.该阶段为源代码生成抽象语法树并像编译器那样完成通常的静态检查;(2)形状分析阶段.生成各程序点的形状图,包括推断循环不变形状图和递归函数的前后形状图;(3)程序验证阶段.该阶段通过正向演算生成验证条件,并用Z3证明它们.程序员在编程时,需要提供有关节点数据的函数前后条件和循环不变式.程序员可以定义一些归纳谓词,用以描述递归数据结构的数据特点,以方便写函数前后条件和循环不变式.程序员需要提供这些谓词之间的、与程序有关的归纳性质,供自动定理证明器使用.因为基于演绎推理的证明器推导不出这类性质.该原型可以验证易变数据结构上较为复杂的程序,如有序循环双向链表、二叉排序树、伸展树、树堆(treap)、二叉平衡树和AA树的插入和删除函数.有关这些例子的统计数据见表1.其中的验证时间是在Windows7PC,IntelCorei5-24003.1GHzCPU和4GB内存的机器上实测获得.这些程序大Page16多包括插入和删除函数,以及被它们调用的函数.操作二叉平衡树的程序的函数最多,因为除了插入和表1有关形状图和验证条件的统计数据有序单链表:插入、倒置、合并二叉排序树:递归和非递归插入、删除00021330表1各例的循环不变形状图都是用本文方法自动推断的.其中有序双向链表的倒置函数虽只有两个循环,但验证时间明显高于其他链表程序.这是因为在用循环代码倒置双向链表过程中,链表被分成正向和逆向两部分,需要多次迭代才能得到循环不变形状图,并且循环不变形状图是8种情况的析取.表1各例的递归函数的前后形状图也都是用本文方法自动推断的.二叉排序树插入函数的前后形状图分别在图19的(1)和(2)中,其中函数后形状图分成插入前实参指向非空表和空表两种情况.从此例可以看出形状图上出现对应形参指针p的实参指针p的必要性.其他二叉树的插入函数的后形状图也都这样.表1中二叉排序树的验证时间远低于列在其后的4种二叉树,这是因为二叉排序树仅需要验证有序性,而其他几种二叉树还需要验证平衡性或类似平衡性的性质.伸展树的代码没有递归,函数个数和验证条件也不算多,但验证时间远高于其他二叉树.这是因为其splay函数的循环不变形状图是20多种情况的析取,形状分析阶段和程序验证阶段的耗时都大大增加.下面再介绍1个规模不大但能帮助理解本文的删除函数外,还有左旋、右旋、左平衡和右平衡等函数.例子.例2.二叉排序树的递归插入函数,代码和断言见图20,程序断言中的y和z是整型逻辑变量.本例引入的谓词定义如下:(1)sorted(Nodep)p==NULL∨(2)gt(intm,Nodep)p==NULL∨(3)lt(intm,Notep)p==NULL∨其中Node的定义见图20.在函数前后条件中分别有y>data∧gt(y,p)和gt(y,p),它们是说:若y大于被插入的数据并大于参数树上的所有数据,则y大于结果树上的所有数据.z的含义与y类似.typedefstructnode{structnodel;structnoder;intd;}Node;/@assertionsorted(p)∧y>data∧gt(y,p)∧z<data∧lt(z,p)/Nodeinsert(Nodep,intdata){if(p==NULL){p=malloc(Node);p→l=NULL;p→r=NULL;p→d=data;}elseif(p→d>data){p→l=insert(p→l,data);}elseif(p→d<data){p→r=insert(p→r,data);}returnp;}/@assertionsorted(p)∧gt(y,p)∧lt(z,p)/引入的性质定理有:(1)x<y∧lt(y,p)lt(x,p)(2)x>y∧gt(y,p)gt(x,p)在函数出口点产生的验证条件包括下述蕴涵式,它表示图20中第1个递归调用后的断言蕴涵函数后条件:sorted(p→r)∧lt(p→d,p→r)∧y>p→d∧gt(y,p→r)∧z<p→d∧lt(z,p→r)∧Page17y>data∧z<data∧p→d>data∧sorted(p→l)∧gt(y,p→l)∧lt(z,p→l)∧gt(p→d,p→l)sorted(p)∧gt(y,p)∧lt(z,p)其中蕴含式的前件中的前三行断言是从调用点前延续到调用点后,后两行断言是从函数后条件得到.在递归调用结束后,能得到第5行gt(p→d,p→l)的原因是:在递归调用点前,有p→d>data与gt(p→d,p→l),因此p→d可与被调用的递归函数的前、后条件中的逻辑变量y匹配.图19(2)两种情况分别都属于该蕴涵式的证明环境.按照第5节所提出的直接把形状图用于证明G,TQQ的方法,把该蕴涵式前件的断言分别对图19(2)两种情况的形状图标注如下:(1)根节点:gt(p→d,p→l),lt(p→d,p→r),(2)左子节点:sorted(p→l),gt(p→d,p→l),(3)右子节点:sorted(p→r),lt(p→d,p→r),再把利用谓词定义和性质定理能推导出的断言增加到这些节点上:(1)根节点:sorted(p),gt(y,p),lt(z,p);(2)左子节点:无增加;(3)右子节点:无增加.该蕴涵式在这两种情况下都得证,因为其后件的断言都已经标注在根节点上了.Z3在未能得出待证断言有效或不可满足时,总试图继续推导出更多的性质.一种情况是它不断地把归纳谓词展开,导致证明过程不终止.针对操作易变数据结构的程序的验证,直接把形状图用于验证条件的证明可以有效地阻止这种不终止.从例2可以看出,在生成验证条件的演算过程中,符号断言中的谓词断言的展开和形状图上谓词节点的展开本质上是同步的.从例1也可以看出,全称断言的展开(指从x:m..n.φ(x)(m<=n)变换成φ(m)∧x:m+1..n.φ(x)(m<=n)等情况)和形状图上浓缩节点的展开也是同步的.由此可知,在证明验证条件时,在把断言按节点分组和推导新性质的过程中,若谓词展开式中与节点有关的断言在形状图上没有可挂靠的节点,则该谓词展开也不会给证明带来什么帮助,因而不必展开.本文并没有把第5节所提出的形状图理论和整数理论组合的证明方法实现到Z3中,而是在验证器原型中根据该方法的思想对验证条件进行预处理后再交给Z3,扩大了可证的范围,并减少了Z3不终止的情况.7相关工作比较分离逻辑是验证堆操作程序(操作易变数据结构的指针操作程序是其重要部分)的最流行的手工或半自动推理的程序逻辑[15].除了分离逻辑外,还存在一些其它逻辑,如匹配逻辑[16],也是用于手工或半自动的推理.分离逻辑引入一种专用的分离符号(),用它把不能混淆到一起推理并且不能被忽略的断言分离开来.分离逻辑的优点和缺点都源自其引入的分离概念.分离的好处之一是避免了访问路径别名给程序验证带来的困难;其缺点是分离切断了不同堆块之间的信息联系,给需要全局信息才能推断的程序性质的验证带来困难.例如,分离逻辑难以发现对某堆块的一个指针域的赋值引起另一个堆块的泄漏.对于堆操作程序的验证,通常允许用户定义的归纳谓词.在分离逻辑的环境下,必须另行设计归纳谓词的展开或折叠策略,否则因归纳谓词的展开没有控制而导致验证条件的证明可能不终止.因此,分离逻辑的证明辅助工具经常是启发式且不完备的[17].最近也出现了一些小的判定片断[18-21].其中文献[20]提出了一种有效、可靠和完备的自动定理证明器,用于检查带表段谓词的分离逻辑公式之间蕴涵的有效性,但它只能用于操作单链表的程序.文献[21]提出分离逻辑一个较小的可判定片段与其他可判定的一阶理论的组合理论的判定方法.形状图逻辑的最大特点是,形状图既是机器状态中有关堆部分的抽象表示,又是指针相等性断言和有效性断言等的图形表示,它总揽了分离性和整体性[10],至少带来下面的好处:(1)形状图逻辑无须使用分离合取算符,避免了引入分离合取算符给定理证明带来的复杂性.在形状图上,关联到不同节点的断言,就是分离逻辑中用分离合取算符隔开的断言.(2)形状图提供了全局信息.①用形状图逻辑很容易发现对某堆块的一个指针域的赋值引起另一个堆块的泄漏.②形状图可用来指导验证条件证明过程中与易变数据结构有关的归纳性质的展开,以避免证明过程的不终止.Page18分离逻辑优于形状图逻辑的重要一点是它适用于汇编语言级的程序推理[22].使用分离逻辑,但验证条件的证明策略类似本文方法的是Chin等人的论文[23].他们设计了一个蕴涵检查过程,该过程使用展开和折叠推理,能够处理可能是归纳定义的良基谓词.其中的创新点是他们找到了一种在有用户定义归纳谓词情况下,保证过程可靠和终止的充分条件.该过程把验证条件简化到标准的逻辑理论.该过程能够处理的易变数据结构超越了树.用符号堆也是把握程序状态中的指针信息以避免使用分离逻辑,从而可自动推理的办法.Madhusudan等人[24]使用节点集合和声明变量集合,还有代表有向边集、节点到值的映射和声明变量到值的映射的若干函数来描述程序状态.该文的内存印迹(footprint)由符号堆和DRYAD公式组成,它们分别对应到本文的形状图G和数据结构所需满足的除了形状以外的性质Q.DRYAD是分离逻辑的一种方言,本质上是堆上无量词一阶逻辑,并用多个类型的归纳定义来增强,这些类型是为其下有树结构的存储单元定义的.它用一个可靠且终止的过程,来证明用命令式语言编写的树结构上很多递归算法的功能完全正确性.Qiu等人[25]使用集合论,把DRYAD翻译成带递归的经典逻辑,并提出一种自然证明技术来证明验证条件.这种技术提供在手工证明中常用的证明策略来帮助验证,并把这些策略自动部署到代码中.Pek等人[26]为利用VCC框架[27],把自然证明策略翻译成嵌在VCC标注中的幽灵代码,促成VCC获得采用可判定理论的自然证明.经过这些努力,他们的工具能够验证多种常见的、包括用递归或迭代方式实现的、操作易变数据结构的程序.本文与Qiu和Edgar等方法的主要区别有3点.首先,有关易变数据结构的形状的验证,本文是基于形状图蕴涵理论,直接在形状图上而不是在符号断言上验证.其次,有关归纳谓词的展开策略,他们采用由程序员提供证明策略的方式,而本文所设计的方法是利用已经建立的形状图来指导归纳谓词的展开和折迭.最后,他们的方法必须由程序员提供完整的循环不变式,而我们的方法自动推断有关形状部分的循环不变式.研究全自动推理的逻辑的目标是研发快速、可靠和完备的判定过程.为达到该目标,这些逻辑的表达力通常受到严重的限制.对于堆操作程序的验证逻辑来说,使用可达性谓词是一种避开分离逻辑的常用简便方式,但表达能力上受到较大限制.具体例子有在一阶逻辑上扩展可达性的若干逻辑、LISBQ[28]、CSL[29]及组合树逻辑和整数逻辑的STRANDdecLISBQ逻辑提供一种带受限的可达性谓词和量化的推理.这种逻辑有完全自动、可靠、完备和终止的判定过程.虽然这是一个高效的判定过程,但是在描述归纳数据结构性质时表达力上非常有限.STRANDdec也是一种这样的逻辑,它能够应对某些数据结构的性质,并且通过组合可判定的树理论和算术理论,容许可判定的片断.然而它在表达力上极其有限.这些逻辑都不足以描述诸如平衡二叉树的平衡性和堆中的一组键值在通过一段程序后没有改变等复杂性质.在有关指针性质的循环不变式推断上,Magill等人[31]提出了一种用分离逻辑推断单链表操作程序的循环不变式的方法.他们使用符号执行机制,并且给出一组重写规则来交互地计算不动点.所实现的原型仅完成了计算表长、求各节点数据的和、以及链表的删除、倒置、合并和拆分这几种简单的单链表操作函数的循环不变式的推断.Distefano等人[32]提出了一种类似的基于分离逻辑的形状分析方法.和文献[31]一样,它使用了专为单链表的展开和折叠而设计的单链表谓词,也需要关于易变数据结构形状的先验知识,并且也使用符号执行机制.但是它的单链表谓词和文献[31]的不同,与文献[28]相比,它还能计算循环单链表操作函数的循环不变式,例如循环单链表的删除函数和过滤器函数.Guo等人[33]提出了一种基于分离逻辑的过程间形状分析,它执行归纳的递归综合,以自动推断有类似树骨架的任意递归形状不变式.其主要特点是从循环体的固定迭代次数的符号执行中抽取循环不变式,但是只能用于树骨架的形状.对于单链表、循环单链表和二叉树,Qin等人[34]不仅能推断有关形状的循环不变式,而且能推断有关相邻节点数值数据的循环不变式,推进了他们先前的工作[23],也使得他们的结果优于其他人的结果.他们也采用符号执行机制,对循环体进行迭代计算,其特点是使用专门设计的最小上界算子和加宽算子来保证收敛到不动点.本文和文献[34]相比,两者循环不变式的推断算法都是基于文献[11].我们的特点是采用本文的形状图蕴涵理论,在形状图上直接推断循环不变形状图,文献[34]的特点是还能推断有关相邻节点数值数据的循环不变式.在保证收敛到不动点上,我们Page19采用形状图上的蕴涵规则[10],并且用该文的形状系统来保证算法的终止.就推断有关形状的循环不变式而言,文献[34]能推断操作单链表、循环单链表和二叉查找树的代码的循环不变式,而我们还能推断操作双向链表、循环双向链表和伸展树的代码的循环不变形状图.从第6节及表1可知,本文推断循环不变形状图的能力远胜于上面几项工作.这是由于本文的推断得到形状系统的支持.也正是由于形状系统的支持,本文还能推断递归函数的前后形状图.据我们所知,尚未有这方面论文的发表.图逻辑或形状逻辑一般是指推导图(或有向图、形状图)性质的空间逻辑[35-36].其中图是用符号公式来描述而符号公式的语法由简单文法来定义,要推导的图上的性质也用符号公式来表示,推导规则也还是基于符号公式的.超边替换文法(hyperedgereplacementgrammar)[37]是一个实例.它用超图为堆状态建模,把双向的图规则用于超图的变换.但是该文法只是作为动态数据结构建模的一种直观的形式方法,超图和规则等还是用符号公式来表示的.本文所用的形状图逻辑与它们有根本的区别:形状图直接作为逻辑公式,出现在程序逻辑的推理规则中,并且还可以和符号公式一起演算.从规范语言的综述[38]和工业界的使用[8]看,迄今为止尚无像本文这样采用形状图或采用其他非符号方式来表达程序的部分性质,并与表达程序其余性质的符号断言一起作为程序的规范并一起演算的.8总结随着面临越来越复杂系统的定理证明,逻辑系统也面临逻辑公式复杂、推理规则复杂和自动定理证明困难等问题.为降低难度,从本文的经验看,把其中适合于用图形表示的领域专用逻辑图形化,形成符号逻辑和图形逻辑的组合,是一条可以尝试的途径.下一步将考虑怎样在目前基础上设计实用性大大提高的形状图逻辑和形状系统.首先,充实基本形状集,并分成单态基本形状和多态基本形状.单态基本形状的特点是,易变数据结构中各节点的类型相同,各节点所含指针数相同并且它们指向的类型都是节点本身的类型.本文谈及的单链表等5种形状都属于单态基本形状.多态基本形状的特点是,易变数据结构中各节点的类型相同,各节点所含指针数可以不同但它们指向的类型都是节点本身的类型.节点的多态性依靠节点类型中的共用体域来体现.例如编译器中常用的抽象语法树就可以设计成多态基本形状.其次,规定复杂形状的构造方式,并相应地修改形状系统中的形状推断规则和形状检查规则.复杂形状至少有嵌套形状、含内部附加指针的形状和含外来附加指针的形状这样三类,它们在构造方式上的特点分别是:各节点都有指向同种内嵌形状的指针(例如双向链表的节点都有指针指向各自的单链表)、各节点都有指向本形状节点的附加指针(例如带父节点指针的二叉树)、来自形状外部的附加指针(例如队列可以看成带一个这种附加指针的单链表,附加指针指向链表的最后一个节点).用基本形状集加上复杂形状的几种构造方式,可以控制住易变数据结构的复杂性,并满足大部分应用对易变数据结构的需求,同时也使得扩展形状图逻辑来自动验证操作复杂易变数据结构的程序成为可能.致谢感谢刘刚、张志天、宋艳辉、孟建超、韩亚慧和郝韛等研究生,他们为实现系统原型做出了贡献!
