Page1基于语义相似度的数据库自适应查询松弛方法孟祥福1)严丽2)马宗民1)张富1)王星1)1)(东北大学信息科学与工程学院沈阳110819)2)(东北大学软件学院沈阳110819)摘要为了解决数据库空查询结果问题,提出了一种基于语义相似度的数据库自适应查询松弛方法.首先,基于初始查询条件和数据分布推测用户对查询指定属性的重视程度,据此提出了一种属性权重评估方法;然后,通过考察属性值的特征信息,分别提出了分类型属性值之间和数值型属性值之间的语义相似度评估方法;在此基础上,根据松弛阈值、属性权重和属性值之间的语义相似度,提出了一种自适应查询松弛重写算法.对于满足松弛查询的近似查询结果,按照它们对初始查询的满足度进行排序.实验结果表明,提出的属性权重和属性值之间的语义相似度评估方法性能稳定,评估结果合理,提出的查询松弛方法具有较高的查全率,能够较好地满足当前用户的需求和偏好.关键词Web数据库;查询松弛;属性权重;语义相似度;查询结果排序1引言随着WorldWideWeb的不断发展,网络上可访问的在线数据库越来越多.随着这些数据库中所蕴含信息量的快速增长,通过Web查询接口访问这些数据库已成为人们获取信息的重要手段.然而,现有的数据库查询处理模式大都采用结构化查询语言并仅支持严格查询匹配,而实际上用户对数据库的结构和内容并不了解,这种情况下,即使用户使用明确的查询条件,数据库仍有可能返回过少甚至空查询结果,此时大多数普通用户希望系统能够自动放松初始查询来提供近似匹配的查询结果;此外,普通用户的查询意图本身可能就是模糊或不精确的,而现有的数据库查询处理模式又要求用户必须明确地表达查询需求,这种情况下,系统返回的查询结果可能不够全面,此时用户希望系统能够自动为其提供更多与初始查询语义上接近的相关信息.鉴于上述两方面需求,解决用户在数据库查询中面临的空查询结果问题,以及为他们提供更多语义上相关的信息就显得尤为重要.查询松弛是解决上述问题的关键技术.为此,本文将从满足普通用户需求和偏好的角度入手,研究基于语义相似度的数据库自适应查询松弛方法.下面,用一个例子描述查询松弛的研究动机和解决方法的基本思想.例1.考虑Yahoo!Autos网站的二手车销售数据库,它包含一个关系表CarDB(Make,Model,Price,Color,Engine,Year,Mileage),其中每条元组代表一条待售的二手车信息.基于CarDB,用户可能提出查询:Q··-CarDB(Model=Camry∧Price<5000).对于该查询,系统返回的查询结果为空(在CarDB中,虽然存在型号为“Camry”或价格低于$5000的二手车,但却不存在价格低于$5000的“Camry”二手车,即查询Q中的两个基本查询条件之间不存在交集).这种情况下,为了给用户提供与初始查询相关的信息,需要对初始查询Q进行松弛处理.现有的查询松弛方法大都以相同的程度放松初始查询中的每一个基本查询条件[1-4];而在实际应用中,提出该查询的用户可能更关注二手车的价格Price(相对型号Model而言).因为在CarDB中很少有价格低于$5000的二手车,而Model为“Camry”的二手车却相对较为普遍,所以根据信息检索中的IDF思想(即,在一个文档集或语料库中,经常出现的关键词要比不经常出现的关键词传达较少的用户需求信息,因此应该被分配较小的权重)可推测出该用户更关心二手车的价格(即Price)属性,相应地对指定在Price属性上的基本查询条件的放松程度也就应该小于指定在Model属性上的基本查询条件的放松程度,这样才能确保松弛后得到的查询结果与用户查询意图和偏好最为相关.由此可见,在放松初始查询过程中,应该考虑不同属性对用户的重要性,越重要的属性,对指定在其上的基本查询条件的放松程度就应该越小.此外,对于查询松弛后得到的查询结果,还需按照它们对初始查询的满足程度进行排序.为了处理数据库空查询结果问题,本文在我们以前研究工作[5]的基础上,提出一种基于语义相似度的自适应查询松弛和结果排序方法———QRRR(QueryRelaxation&ResultsRanking),该方法不依赖于任何特定领域和用户,它能够自适应地放松初始查询要求,并对查询松弛后得到的近似查询结果进行自动排序.本文第2节介绍相关研究工作;第3节给出查询松弛基本思想和定义;第4节提出属性权重评估方法;第5节提出属性值之间的语义相似度评估方法;第6节给出查询松弛重写算法和近似查询结果排序方法;第7节验证所提方法的效果和性能;最后是总结与展望.2相关工作查询松弛是指在初始查询上去掉或放松某个(些)基本查询条件而得到一个涵盖范围更宽泛的查询的处理过程.最早利用查询松弛思想解决数据库空查询结果(或查询失败)问题的研究工作,是由Kaplan在1982年提出的CO-OP系统[6].CO-OP的基本思想是通过识别并去除失败查询(failedquery)中的错误假设来避免空查询结果问题.例如,考虑一个查询“查找在Microsoft公司月薪少于$15k并且在R&D部门工作的所有员工”,该查询的结果为空.导致该查询失败的原因有两种可能情况:一种是Microsoft公司的R&D部门没有任何员工月薪低于$15k;另一种是Microsoft公司根本不存在R&D部门.前一种是由于基本查询条件之间存在矛盾而导致的空查询结果,而后一种是由于错误假设(假设Microsoft公司存在R&D部门)而导致的空查询结果.CO-OP方法侧重于找出初始查询中Page3存在的错误假设,它把初始查询转换成一个图形化的查询并用连通子图代表查询中的假设.基于CO-OP思想,Motro在1990年提出了FLEX系统[7].FLEX系统通过在失败查询上生成一个更为宽泛的查询集合使系统能够判断查询失败原因属于哪一种情况:如果是上述第一种情况,它将提供一个与初始查询相似的、非失败的查询(non-failingquery);如果是上述第二种情况,它将识别并消除用户查询中的错误假设,即该系统以迭代方式逐步去除初始查询上的基本查询条件从而实现对失败查询的高度容错.然而,CO-OP和FLEX系统在识别一个假设时通常需要在整个数据库上执行大量查询,而且需要计算和测试的假设数量很多,计算代价太高是它们的严重不足.为了确保运行时间可接受,Motro提出了限制搜索的启发式方法[8].Gaasterland随后又提出了一个相关的方法[9],该方法利用基于语义查询优化技术的启发式方法控制查询松弛处理的规模.Godfrey于1997年在理论上证明了该类算法能在多项式时间内找到一个最大成功的子查询,但是找到所有或部分最小失败和最大成功子查询集合的计算复杂度却是NP-hard问题[10].随着数据库在Web中的大规模应用,基于Web应用的数据库查询松弛技术近年来受到了研究者的关注.Muslea于2004年提出了一种基于决策树算法的Web数据库查询松弛方法———LOQR[11].该方法分成两个处理阶段:第1阶段,LOQR利用C4.5算法在一个小型的、随机选取的原始数据子集上进行机器学习,从中提取出领域知识进而得到决策规则集合,这些规则体现了一个属性值能否满足失败查询中的某个基本查询条件;第2阶段,LOQR使用最近邻技术找到与失败查询最为相似的规则,然后使用该规则中的属性值修改失败查询.然而,当训练数据集很小的情况下,LOQR方法的学习效果并不理想.为此,Muslea等人于2005年又提出了一种基于贝叶斯网络的查询松弛方法———TOQR[4].该方法与LOQR类似但弥补了LOQR的缺点,它能够在很小的训练样本上产生与失败查询非常类似的松弛查询.但应当指出的是,LOQR和TOQR方法对于每一个到来的查询,都需要在每一个数据样本上执行非常复杂的数据挖掘算法,因此计算代价较高.2006年,Nambiar等人在自己研究工作[12]的基础上,提出了一种Web数据库不精确查询回答方法———AIMQ[13].在预处理阶段,AIMQ从Web数据库中随机抓取一小部分样本数据集,在该数据集上利用TAN算法获取近似函数依赖和近似关键字,据此评估关系中每个属性的重要程度;在查询处理阶段,AIMQ先将最初的不精确查询紧缩成一个精确查询,然后把数据库中满足该精确查询的每条元组都作为一个查询,再根据属性重要程度依次去除这些查询上的基本查询条件,最后在数据库上执行这些松弛查询获得相关查询结果.然而该方法的不足之处在于,它们利用近似函数依赖和近似关键字在预提取的数据集上获取的属性权重是固定不变的,不能随着用户偏好和查询要求的变化而变化.实际上,不同用户对同一属性的重视程度是不同的,而且同一用户在不同的查询上下文条件下,对同一属性的重视程度也是不同的.因此,利用该类方法得到的查询结果也就不能很好地满足当前用户的需求和偏好.此外,当初始查询结果为空时,由于没有结果元组作为查询松弛的对象,因而AIMQ方法将会失效.通过对上述数据库查询松弛方法研究现状的分析可以发现,查询松弛方法主要是通过消除查询中的错误假设或不重要属性上的基本查询条件来避免空查询结果问题.但应当指出的是,上述方法在查询松弛处理过程中,很少考虑由基本查询条件之间彼此存在矛盾而导致的空查询结果问题,更很少考虑当前用户的偏好,而实际上用户偏好在很大程度上影响到查询松弛的效果.当前,充分体现用户偏好的查询松弛方法研究在国际上基本上还是空白.3查询松弛基本思想和定义3.1查询松弛基本思想本文所提查询松弛方法的基本思想是,对于一个给定查询Q,通过放松Q上的限制而生成一个松弛查询珟Q.首先,评估初始查询Q指定属性的权重;然后,根据属性权重和初始查询的松弛阈值,计算对应每个基本查询条件的子松弛阈值,越不重要属性上的基本查询条件的子松弛阈值越低(即,该基本查询条件的放松程度越大);进而,根据属性值之间的语义相似度和每个基本查询条件的子松弛阈值,把相似度高于子松弛阈值的属性值添加到每个基本查询条件所指定的查询范围中;最后,通过查询重写实现对基本查询条件的松弛处理,合取所有的松弛基本查询条件最终形成松弛查询珟Q.基于信息检索中的IDF思想,属性权重评估的直觉是,对于查询Q中的每一个基本查询条件,如果数据库表中存在很多能满足该条件的元组,则说明该条件的选择性弱,Page4那么对于用户来说,该条件所对应属性的重要程度就低;反之,如果数据库表中只有很少能满足该条件的元组,则说明该条件的选择性强,那么对于用户来说,该条件所对应属性的重要程度就高.3.2查询松弛定义定义1(查询松弛).令R为数据库中一个包含n条元组{t1,…,tn}的关系,其模式由m个分类型和数值型相混合的属性A={A1,A2,…,Am}构成,Q为R上的一个合取查询,形式为Q=σ∧i∈{1,…,k}Ci,其中2km,Ci的形式为Aiθai,θ∈{>,<,=,,,between},如果θ是操作符between,则ai用区间[ai1,ai2]表示且Aiθai的形式为“Aibetweenai1andai2”.基本查询条件“Aiθai”中的每个属性Ai都是属性集A中的属性,ai包含于属性Ai的值域当中.通过放松初始查询Q,可形成一个相对于初始查询Q的松弛查询珟Q.通过在R上执行珟Q,使得查询结果中的任一元组对初始查询Q的满足程度都高于指定的松弛阈值Tsim∈(0,1],表示为珟Q(R)={t|t∈R,Satisfaction(t,Q)>Tsim}(1)其中,珟Q(R)是R中满足松弛查询珟Q的查询结果集,Tsim由系统或用户给定.4属性权重分配不同用户具有不同的偏好,对不同用户来说属性权重也就不尽相同.基于引言所述的属性权重评估直觉,下面将根据用户查询中指定的属性值在数据库中的分布情况来分配查询指定属性的权重.4.1分类型属性权重评估IDF(InverseDocumentFrequency,逆文档频率)是信息检索中一种常用的关键词(Keyword)权重评估技术[14].它利用统计方法评估一个关键词在整个文档集(或语料库)中的重要性,关键词的重要性随着它在文档集中出现的频率成反比下降.IDF的主要思想是:在一个文档集或语料库中,经常出现的关键词要比不经常出现的关键词传达较少的用户需求信息,因此应该被分配较小的权重.它的公式定义为log(n/F(w)),其中n是语料库中的文档总数,F(w)是n个文档中包含关键词w的文档个数.如果关系R中仅包含分类型属性,则每条元组可看作是一个文档,R中每一个不同的〈属性,值〉都作为一个关键词,因此可使用IDF方法量化对应分类型属性Ai的属性值v在R中的权重.根据上述IDF思想,属性值v的IDF权重定义为其中,n代表R中的元组数,Fi(v)代表R中满足条件“Ai=v”的元组数.一个〈属性,值〉可看成是一个等值查询条件“Ai=v”,即属性值v是用户指定在分类型属性Ai上的查询值,因此可把式(2)所示的属性值v的IDF权重作为其对应属性Ai的权重,它体现了用户对该属性的重视程度.值得注意的是,如果R中不存在满足查询条件“Ai=v”的元组(即Fi(v)=0),则说明该查询条件是错误假设,那么消除该查询条件.4.2数值型属性权重评估对于数值型属性值的权重评估,不能直接应用IDF方法,因为数值型数据具有一定的连续性,如“29999”与“30000”在数值上是接近的,然而却被认为是两个截然不同的文本值,从而产生了不合理的出现频率统计.因此需要改进IDF方法,使其能够适用于数值型属性值的权重评估.这里,借鉴了KernelDensityEstimation技术[15].令{v1,v2,…,vn}为数据库表中属性A的所有取值集合,对于查询中指定的数值v,IDF(v)定义为其中,h=1.06σn-1/5(在实际应用中,属性值域中的值通常服从正态分布),σ是关系R中该属性上所有值的标准差,n为R中的元组总数,vj代表R中属性Ai值域上的一个属性值.式(3)中的分母代表了对于值v的“出现频率”概念在数值方面的扩展,即对于值v的“贡献”之和来自于关系R中该属性上所有其他的属性值vj.这些“贡献”服从高斯分布,所以vj与v的差距越大,来自vj对v的贡献就越小.从式(3)可以看出,如果关系R中在数值型属性Ai上的每个属性值都与v相差很多,则说明v处的数据分布稀疏,那么IDF(v)就较大,因此值v也就比较重要;如果关系R中在数值型属性Ai上的每个属性值都与v比较接近,则说明v处的数据分布比较稠密,那么IDF(v)就较小,因此值v的重要性也就较低.很明显,这与传统的IDF思想是一致的.同理,把式(3)所示的属性值v的IDF权重作为其对应属性Ai的权重.注意,如果R中没有任何元组满足查询条件“Ai=v”,则说明该查询条件是错误假设,那么消除该查询条件.此外,如果查询条件的形式为范围查询条件Page5“AiINVi”,其中,Vi是多个分类型值的集合(如果Ai是分类型属性),或者是一个数值区间[vmin,vmax](如果Ai是数值型属性),那么IDF(Vi)定义为Vi中的值所对应的IDF权重中的最大值,即在实际应用中,一个查询通常会同时在多个属性上指定基本查询条件,因此需要对多个指定属性的权重进行规一化处理.具体方法是,用每个指定属性的IDF权重除以所有指定属性的IDF权重之和,即属性Ai的权重wi可由下式计算:其中,k代表查询指定的属性个数,IDFi(v)代表属性Ai的IDF权重.至此,利用上述方法,可根据用户查询中指定的值在数据库表中的分布情况,自适应地评估查询指定属性的权重.为了加快在线查询处理速度,可在预处理阶段计算出所有不同分类型值的IDF权重,并将其存储在属性值IDF权重表中,结构为(AttName-属性,AttVal-属性值,vIDFWeight-IDF权重),在AttName和AttVal上建立索引以便于检索.对于数值型属性,由于不同的数值型值很多且具有连续性,因此不能预计算所有数值型值的IDF权重.对此,本文采用了两种优化策略,一是在预处理阶段计算出查询历史中经常指定的数值型值(或数值区间)的IDF权重,将它们存放在属性值IDF权重表中;二是通过直方图划分技术,将数值上相接近的数值划分到一个区间并用一个IDF权重表示,这样当查询指定的值落在该区间时,就可用该区间的IDF权重替代当前查询值的IDF权重,从而减少在线查询处理时间.4.3实例分析下面用例子分析属性权重分配方法的合理性.表1给出了CarDB上对应于不同查询条件下的属性权重分配结果.考虑查询:Q··-CarDB(Price<5000∧Model=该查询隐含的意思是购买者关注价格较便宜且较新的二手车,正如所愿,算法为属性Price和Year分配了较大权重(在CarDB中,Model为“Camry”的二手车比较常见,而Price低于$5000的二手车却很少,并且出厂日期为“2009”年的也相对较少),属性Model被分配了较小的权重.相反,考虑查询:Q··-CarDB(Model=BMW330∧Pricebetween由于12k~15k是一个常见的价格区间并且在CarDB中有大多数二手车的价格在该范围内,这说明购买者具有一定的购买能力,而CarDB中Model为“BMW330”的二手车却不常见,因此与基本查询条件“Pricebetween13kand15k”相比,基本查询条件“Model=BMW330”的选择性更强.由此可以推测,购买者实际上更多地关注二手车的Model属性,从表中可以看出,属性Model被分配了较大权重,而属性Price将不再分配较大权重.PriceModelYear5属性值间的语义相似度评估本节分别提出分类型值之间和数值型值之间的语义相似度评估方法,属性值之间的语义相似度为查询松弛重写提供了知识支持.5.1分类型值间的语义相似度对于一个分类型属性值,关系表中其它属性上所有与之关联的多个〈属性,值〉可视为对该值特征的描述,一个〈属性,值〉由一个属性和它对应的值构成,如“Model=Camry”.一个元组中不同属性上的值之间具有关联关系.例如,在CarDB中,给定一个元组t={Toyota,Camry,25k,Black,2.4L,2008,80k},则〈属性,值〉“Model=Camry”与〈属性,值〉“Make=Toyota”、“Price=25k”、“Color=Black”、“Engine=2.4L”、“Year=2008”和“Mileage=80k”相关联.对于同一属性上的两个〈属性,值〉之间的相似性,可通过计算关系表中所有与这两个〈属性,值〉相关联的〈属性,值〉集合之间的相似性来衡量.具体来讲,一个〈属性,值〉可视为指定在关系表中单个属性上的一个等值查询条件,通过执行该查询可得到所有满足该〈属性,值〉的元组集合,该集合用语义表表示.语义表是一个两栏结构,由属性(Attributes)和包(Bags)两列构成.例如,表2和表3分别给出了CarDB上对应于“Model=Camry”和“Model=Accord”的语义表.Page6属性MakePriceColorEngineYearMileage10k~25k:18;20k~30k:25;…表3CarDB上对应于“Model=Accord”的语义表属性MakeHonda:116Price5k~15k:30;15k~20k:38;20k~30k:48ColorBlack:21;Silver:27;Gray:33;White:35Engine2.0L:49;2.2L:32;2.4L:35Year2009:20;2008:51;2006:18;2005:27Mileage10k~20k:42;20k~30k:38;30k~45k:36某个〈属性,值〉的语义表包含了关系表中除该属性之外的其它属性及其对应的一组关键字的集合.对于分类型属性,每一个不同的属性值就是一个关键字;对于数值型属性,通常将其值域划分成若干数值区间,其中每个数值区间都作为一个关键字.为了使关键字能够体现语义,本文用关键字和它在关系表中对应的元组个数(即,〈关键字:元组个数〉)代表关键字的语义,并将对应于同一属性的所有〈关键字:元组个数〉称为包(Bags).例如,在表2中,Price上的包为“5k~15k:36,15k~20k:42,…”,包中的关键字分别是“5k~15k”、“15k~20k”等,其中关键字“5k~15k”对应的值为36,这表明CarDB中有36辆Camry车的价格在5k~15k之间.下面讨论如何为关系R中的数值型属性划分数值区间.直方图(histogram)是划分数值区间的常用技术,在关系数据库中该技术的基本思想是把关系表中一个数值型属性的值域划分为多个块(Bucket),然后根据每个块中维护的统计信息来估算属性的实际值和它们的频率(数据分布).目前两种最常见的直方图是等宽(equi-width)和等深(equi-depth)直方图,等宽直方图中每个块的划分区间相同,等深直方图中每个块中所包含的元组个数相同.由于现实应用中数据分布的稠密程度不同,使用等宽直方图划分方法将导致每个等宽数值区间内的元组数分布不很均匀,进而影响到Jaccard系数的评估准确性,因此本文选用了等深直方图划分方法,目的是使每个数值区间所对应的元组数大致相同,进而确保语义相似度评估算法的合理性.实现算法如下(算法1).算法1.数值型属性的数值区间划分算法.输入:数值型属性Ai和它的取值范围,关系R和R中输出:n个数值区间的上界集合U={u1,…,un}1.令U为一个大小为n的数组,用于存储每个数值区2.令属性Ai在R上的取值范围为[alow,aup);3.设置λ=|R|/n;4.令数值区间下界low=alow,数值区间上界up=aup;5.do6.用条件“lowAi<up”查询R并记录结果元组7.if(cλ)then8.记录up的值并将其按序存入U中;9.设置low=up,up=aup;10.else11.设置up=low+(up-low)/2;12.while(low<aup)13.returnU.算法1首先确定每个数值区间所包含的元组数阈值λ,该值为关系R中的元组数与设定的数值区间数之比(第3步),并设置最初的数值区间下界low和数值区间上界up的值分别为属性Ai取值范围中的最小值和最大值(第4步);然后,用条件“lowAi<up”查询R并记录结果元组个数c(第6步),如果c小于阈值λ,记录up的值并将其存入数组U中,否则,缩小查询范围重新查询R,直到c小于阈值λ,这样每个数值区间中的元组数都会不超过阈值λ(第7~12步);最后,返回数值区间的上界集合U.利用该算法,可为R中每个数值型属性划分数值区间,并将其作为构建语义表的数值型属性划分标准.下面讨论如何为一个〈属性,值〉构建相应的语义表.令T代表关系R中所有包含该〈属性,值〉的元组集合.语义表中的属性与包之间是11的关系,每个包都包含若干〈关键字:元组个数〉.如果包对应的是一个分类型属性,则对于该属性中的每个值,包中都有一个相应的〈关键字:元组个数〉表示该值在T中的个数;如果包对应的是一个数值型属性,则对于该属性中的每个数值区间,包中都有一个相应的〈关键字:元组个数〉表示该区间在T中所包含的元组个数.语义表构建算法描述如下(算法2).算法2.语义表构建算法.输入:关系R中的属性集合A,T和T中的元组个数|T|,输出:语义表STPage71.for每一个属性Ai∈Ado2.if(Ai是分类型属性)then3.for每一个属性值aij∈DomT(Ai)do4.用“Ai=aij”查询T并记录结果元组个数c;5.添加(aij,c)到包Bagsi中;6.endfor7.if(Ai是数值型属性∧在T上取值范围为[alow,8.forj=n-1,…,0do9.if(U[j]alow)10.设置数值区间下界low=U[j];break;11.endfor12.设置数值区间上界up=U[j+1];13.do14.用“lowAi<up”查询T并记录结果元组个数c;15.添加(low,up,c)到包Bagsi中;16.j++;17.设置low=up,up=U[j+1];18.while(upaup)19.ST←〈Ai,Bagsi〉;20.endfor21.returnST.通过使用算法2可为关系R中任一〈属性,值〉生成一个相应的语义表.由于语义表中包含了对应于每个属性的包,并且每个包中又包含一组〈关键字:元组个数〉,因此可用Jaccard系数计算两个不同语义表中相对应的两个包之间的语义相似度.两个不同分类型值之间的语义相似度,是两个语义表中所有对应包之间相似度的平均值,用下式计算:VSim(v1,v2)=∑m其中,v1和v2是同一属性上的两个不同分类型值;S1和S2分别是对应v1和v2的两个语义表;Bagsi是语义表中属性Ai对应的包;J()是Jaccard系数(式(7)):利用上述方法,可计算出关系R中同一属性上所有不同分类型值对之间的一个相似度矩阵.由于Sim(v1,v2)=Sim(v2,v1),因此该矩阵是对称的,只需计算上半矩阵.相似度矩阵的创建算法如下(算法3).算法3.分类型值之间的相似度矩阵创建算法.输入:分类型值个数n,属性个数m,属性的包Bags输出:相似度矩阵Matrix1.Matrix←;2.fori=1…n-1do3.iBags=getAttributeBags(i);4.forj=i+1…ndo5.jBags=getAttributeBags(j);6.fork=1…mdo7.Sim[k]=Sim(iBags[k],jBags[k]);8.endfor9.SimDegree=∑m10.Matrix[i][j]=SimDegree;11.Matrix[j][i]=Matrix[i][j];12.endfor13.endfor14.returnMatrix.本文把在关系R中计算出的所有不同分类型值之间的语义相似度存储在结构为:(AttName-属性,AttValPair-属性值对,Simlarity-相似度)的分类型值相似度表中,并在AttName和AttValPair上建立索引以便于检索.5.2数值型值间的语义相似度对于数值型属性,本文借鉴模糊集理论的基本思想评估数值型值之间的语义相似度.根据模糊集理论,给定一个数值Y,在数值上接近Y的数构成了一个模糊集合,用“closetoY”表示.根据文献[16],它的隶属函数在论域U上定义为其中,u为论域U上的一个元素;.μclosetoY(u)代表元素u隶属于“closetoY”的程度;β为一个调节值,β越大,对于同一个u来说,u隶属于“closetoY”的程度越大.模糊集“closetoY”的隶属函数如图1所示.基于该思想,令Ai为关系R中的一个数值型属性,其值域为{v1,v2,…,vn},根据上述“closetoY”的隶属函数,两个数值型值v和q之间的语义相似度可由下式计算:其中,q代表查询条件指定的值;v代表属性Ai中的Page8任一属性值;β=1.06σn-1/5(其中σ是关系R中数值型属性Ai上所有值的标准差,n为R中的元组总数).从式(9)可以看出,v与q在数值上越接近,则NSim(v,q)的值越接近1.根据上式,给定一个子松弛阈值,就可计算出满足该子松弛阈值的v所对应的最小值vmin和最大值vmax.例如,假设查询Q在属性Ai上指定的基本查询条件为“Ai=q”,令ψi为该基本查询条件的子松弛阈值,则根据式(9)可得松弛后的查询区间为若基本查询条件中的q为一个数值区间[q1,q2],则松弛后的查询区间为注意,对于数据库中存在多个相关联的基本表的情况,本文的解决方法是先为这些相关联的基本表创建一个综合逻辑视图,该视图中包含了这些基本表中的属性,然后在这个视图上执行上述算法.6查询松弛和结果排序根据属性权重、属性值之间的语义相似度和松弛阈值,可将初始查询重写为一个范围更为宽泛的松弛查询.然而,执行松弛查询后很可能产生多个查询结果.因此,本节主要讨论查询松弛重写算法和松弛查询下的结果排序方法.6.1查询松弛重写算法在关系R上给定一个合取查询Q=σ∧i∈{1,…,k}Ci,令wi代表基本查询条件Ci所对应属性Ai的权重,k代表查询Q指定的属性个数,Tsim代表给定在Q上的松弛阈值.根据属性权重和松弛阈值,可由下式计算出查询Q中每个Ci的子松弛阈值ψi,即注意,如果某个基本查询条件的子松弛阈值大于1,则将其置为1.根据式(12)可知,属性权重越大,指定在其上的基本查询条件的子松弛阈值越高,该基本查询条件的放松程度相应地就越小.需要说明的是,式(12)中虽然含有k个变量,但实质上其中的k-1个变量都可由k个变量中的某个变量表示,因此只要根据公式求出该变量的值,其它变量的值就容易求出.例如,给定查询指定了3个属性,假设利用式(5)得到这3个属性的权重分别为0.5、0.3和0.2,设它们对应的子松弛阈值分别为ψ1、ψ2和ψ3,这样式(12)中的第一个子式就可表示为则ψ2和ψ3都可用含ψ1的式子表示,即ψ2=0.3ψ1/0.5,ψ3=0.2ψ10.5,把这些量代入式(12)中的第2个子式就可求出ψ1的值,进而可求出ψ2和ψ3的值.根据初始查询Q、松弛阈值Tsim、属性权重W以及分类型值相似度表KB,可形成如下的查询松弛重写算法(算法4).算法4.查询松弛重写算法.输入:初始查询Q,松弛阈值Tsim,属性权重W(w1,输出:松弛查询珟Q1.do2.根据W和Tsim计算Q中每个Ci的子松弛阈值ψi;3.for每一个基本查询条件Ci∈Qdo4.珟Ci←Ci;5.if(Ci对应的属性Ai是分类型属性)then6.for每一个v∈Dom(Ai)do7.if(VSim(ai,v)>ψi)then8.添加v到珟Ci的查询范围中;9.if(Ci对应的属性Ai是数值型属性)then10.用q-h1-ψi11.珟Q←珟Q∪珟Ci;12.endfor13.珟Q(R)←在R上执行松弛查询珟Q得到的查询结果;14.Tsim←Tsim-0.1;15.while(珟Q(R)≠)16.return珟Q(R).算法4首先根据松弛阈值Tsim和属性权重W,计算出Q中每个基本查询条件Ci的子松弛阈值ψi(第2步);然后,对于每一个基本查询条件Ci,从对应属性Ai的值域中获取与Ci指定的值相似度高于ψi的属性值,并将其加入到Ci的查询范围中,从而形成松弛的基本查询条件珟Ci(第3~10步),合取所有的珟Ci最终形成松弛查询珟Q(第11步);在关系R上执行松弛查询珟Q,获取并判断查询结果返回情况,如果在给定的松弛阈值Tsim下查询结果仍然为空,则系统以步长0.1递减方式自动调整阈值(第13~14步),然后重新计算每个基本查询条件的子松弛阈值并进行查询松弛重写,该过程直到查询结果非空为止.Page96.2近似查询结果排序在数据库上执行松弛查询珟Q后,可能产生大量查询结果.如果把查询结果中的元组随机地返回给用户,用户将不得不对大量的结果元组逐一进行对比分析,这是一件枯燥并且费时费力的工作,因此对松弛查询下的查询结果进行排序有着重要意义.本文给出一种按元组对初始查询满足程度的查询结果排序方法,元组t对初始查询Q的满足程度用下式评估:Satisfaction(t,Q)=∑kVSim(t.Ai,Q.Ai),Domain(Ai)=Categorical烅烄NSim(t.Ai,Q.Ai),Domain(Ai)烆其中,k代表查询Q指定的属性个数,wi代表属性Ai的权重,VSim(t.Ai,Q.Ai)代表查询Q在分类型属性Ai上指定的值与元组t在Ai上的取值之间的语义相似度,NSim(t.Ai,Q.Ai)代表查询Q在数值型属性Ai上指定的值与元组t在Ai上的取值之间的语义相似度.注意,式(1)定义的元组t对初始查询Q的满足程度Satisfaction(t,Q)与式(13)相一致.7实验结果与性能分析本节通过实验来验证所提方法的效果和性能,对实验结果进行讨论,并与现有方法进行对比.7.1实验环境数据集.测试数据使用了两个不同应用领域的数据集,一个是从Yahoo!Autos网站①随机抽取的1000000条二手车信息记录,合成关系表CarDB(Make-厂商,Model-型号,Year-出厂日期,Color-颜色,Engine-引擎,Price-价格,Mileage-里程),其中Make、Model、Engine和Color是分类型属性,其余是数值型属性.另一个是从Yahoo!RealEstate网站②随机抽取的237620条房产信息记录,合成关系表HouseDB(City-城市,Price-价格,SqFt-面积,Bedrooms-卧室数,Bathrooms-浴室数,Schooldis-trict-学区,View-景观,Neighborhood-临区,Build-year-建筑年份),其中City、Schooldistrict、View和Neighborhood是分类型属性,其余是数值型属性.所有实验都在P43.2-GHz处理器,1GBRAM和内置160GB硬盘驱动器,运行WindowsXP和MicrosoftSQLServer2005的环境下进行,用Java和SQL语言实现所有算法,以JDBC方式连接RDBMS,Web服务器使用Tomcat5.5.算法对比.将提出的查询松弛和结果排序(QueryRelaxation&ResultsRanking,QRRR)方法与文献[13]提出的AIMQ方法进行对比.虽然两者解决的问题不同,但AIMQ将不精确查询紧缩成精确查询后,需要将满足精确查询的每条结果元组作为一个查询并进行松弛处理,然后得到与精确查询近似匹配的有序查询结果.因此,本文将QRRR与AIMQ的查询松弛效果进行比较.下面简述AIMQ方法:给定一个不精确查询,AIMQ首先将其紧缩成一个精确查询,然后把数据库表中满足该精确查询的每一条元组作为一个查询.接着,AIMQ对这些查询进行松弛处理,它利用近似函数依赖(Approxi-mateFunctionsDependencies,AFDs)和近似关键字(ApproaxiamteKeys,AKs)在预提取的数据集上评估属性权重,并依次从最不重要的属性上去除基本查询条件.最后,AIMQ在数据库上执行这些松弛查询获得相似度高于给定阈值的查询结果.对于查询结果的排序,AIMQ按照结果元组与不精确查询之间的相似度作为排序依据.另外,本文还采用随机算法(RANDOMalgo-rithm)获取相关结果并随机排序,该算法为QRRR和AIMQ之间的比较提供了一个基准.7.2IDF权重评估算法测试该实验目的是在不同领域和大小的数据集上,测试IDF权重评估算法的合理性和稳定性.在HouseDB和CarDB数据集上,利用IDF权重评估算法分别在1M、2M和4M大小的数据量上计算不同属性值的IDF权重.表4给出了CarDB和HouseDB上不同属性值的IDF权重计算结果.表4CarDB和HouseDB上不同属性值的IDF权重属性分类型值Make(CarDB)Color(CarDB)Price(CarDB)①②Page10属性分类型值City(HouseDB)View(HouseDB)Price(HouseDB)从表4可以看出,在数据集当中经常出现的属性值被分配了较小的权重(如“Color=Black”),而在数据集当中很少出现的值被分配了较大权重(如“Make=Buick”);而且,数值型值的IDF权重与其本身大小及其所在数据区域的数据分布情况相关,如“Price=12000”,CarDB中Price属性上与该值大小相近的数值较多,因此它的IDF权重相对较小;而对于“Price=30000”,CarDB中Price属性上与该值大小相近的数值很少,因此它的IDF权重相对较大.还可看出,数据集中一些常见的分类型值和数值型值的IDF权重之间相差不大,这说明数值型值的IDF权重评估算法是合理的.由此可见,对于分类型值和数值型值,本文所提的IDF权重评估算法是合理的.此外,还可看到,在不同大小(1M、2M和4M)的数据集上,每个属性值的IDF权重相差不大,因此该算法是稳定的.这同时也说明,属性权重评估可以在小样本数据集上进行,因此提高了权重评估算法的效率.7.3语义相似度评估算法测试该实验的目的是在不同领域和大小的数据集上,测试分类型值之间的语义相似度评估算法的执行时间、合理性和稳定性.(1)语义相似度评估算法的执行时间在HouseDB和CarDB数据集上,分别使用2M和4M大小的数据量评估相似度评估算法的执行时间.分类型值之间的语义相似度计算所需时间仅依赖于从数据库表中提取的〈属性,值〉个数,时间复杂度为O(mk2),其中,m代表分类型属性的个数,k代表每个分类型属性所包含的不同属性值个数的平均值.表5和表6分别给出了在2M的HouseDB数据集和4M的CarDB数据集上,对应于不同分类型属性的语义表生成时间和不同分类型值之间的语义相似度计算时间.表5HouseDB上的语义表生成和相似度计算时间属性不同分类型值CitySchooldistrict287ViewNeighborhood76Totaled表6CarDB上的语义表生成和相似度计算时间属性不同分类型值MakeModel328ColorYearEngineTotaled470由于HouseDB和CarDB中所包含的不同分类型值个数很多,因此相似度评估算法的执行时间较长.注意,不同分类型值之间的语义相似度在离线阶段周期性进行计算,因此不会影响在线查询处理速度.(2)相似度评估算法的合理性和稳定性基于HouseDB和CarDB,表7给出了在不同大小的数据集(1M、2M和4M)上,分别与分类型值“Make=Ford”、“Model=Camry”和“View=Greenbelt”相似的前3个属性值.表7不同大小数据集上的语义相似度计算结果分类型值相似的值Make=Ford(CarDB)Model=Camry(CarDB)View=Greenbelt(HouseDB)从表7可以看出,该算法得到的分类型值之间的语义相似度是合理的.例如,对于“Ford”,属性值“Honda”,“Toyota”和“Nissan”与其相似.在现实中,这4种车也是相似的,因为它们在价格、引擎、排量和其他特征等各方面都很接近.此外,虽然在1M和2M的数据集上获得的语义相似度低于从4M的数据集上获得的语义相似度,但是两者相差不大.因此,该算法是稳定的,也就是说可以在小样本数据集上评估语义相似度,从而提高算法执行效率.Page117.4查询松弛效果测试该实验以用户调查方式测试查询松弛方法的效果.邀请了15位测试者(分别是教师、公务员、企业管理者、公司职员和学生),每位测试者根据自己的需求和偏好,对CarDB和HouseDB分别提出各1条测试查询.对于CarDB,每条查询平均指定了3.2个属性;对于HouseDB,每条查询平均指定了3.4个属性.每条查询都将导致空或少量(不超过10条)查询结果.由于要求测试者从整个数据集中查找所有与查询相关的元组是不现实的,因此采用了如下策略:对于HouseDB和CarDB上的每个测试查询Qi,生成一个相应的数据集Hi,Hi中包含了30条与该查询相关的和不相关的适当元组组合(这些元组组合是通过RANDOM、AIMQ和QRRR方法分别获得的前10条结果元组去掉重复并添加少量随机选择的元组而合成的).然后,将所有测试查询和对应的数据集提供给每个测试者,他们的任务就是从数据集Hi中标出与测试查询Qi最为相关的10条元组.在此基础上测试查询松弛方法的效果.采用查全率作为查询松弛效果的评价标准,查全率是指查询结果中的相关元组数与数据集中的相关元组总数之比,表示为基于CarDB和HouseDB,图2分别给出了QRRR与AIMQ和RANDOM在查全率方面的对图2QRRR、AIMQ和RANDOM方法分别在CarDB和HouseDB上的查全率对比(Tsim=0.6)图3CarDB上QRRR和AIMQ在不同松弛阈值下的查全率比(QRRR和AIMQ的Tsim都设置为0.6).可以看出,QRRR的查全率始终高于AIMQ和RANDOM.对于CarDB数据集,QRRR的平均查全率为0.92,而AIMQ为0.77;对于HouseDB数据集,QRRR的平均查全率为0.88,而AIMQ为0.74.这是因为AIMQ在预提取的数据集上利用近似函数依赖关系确定的属性重要程度是一成不变的,不能随着查询要求和用户偏好的变化而变化;实际上,由于用户偏好不同,不同用户对同一属性的重视程度是不同的,并且同一用户在不同查询上下文条件下,对同一属性的重视程度也是不同的.相比之下,QRRR的属性权重分配能够自适应不同的查询要求和用户偏好,并且属性值之间的语义相似度评估结果也是符合实际的,所以QRRR方法在查全率方面优于AIMQ方法.此外,在CarDB和HouseDB数据集上分别测试了QRRR和AIMQ两种方法在不同松弛阈值下的查全率,如图3和图4所示.从图3和图4可以看出,松弛阈值越低,QRRR和AIMQ的查全率越高.但该实验的目的主要是为了说明以下两点:(1)在不同的松弛阈值下,QRRR的查全率都要高于AIMQ;(2)当松弛阈值接近0.6时,QRRR方法的整体查全率趋于稳定,并且平均查全率分别达到0.9(对于CarDB)和0.88(对于HouseDB)以上,从而为松弛阈值的设定提供了一个参考值.Page12图4HouseDB上QRRR和AIMQ在不同松弛阈值下的查全率7.5响应时间测试查询松弛处理过程主要包含离线预处理和在线查询处理两个部分.离线预处理部分包括两个模块:分类型值之间的语义相似度评估模块和属性值IDF权重计算模块.在线查询处理部分包括三个模块:查询松弛重写模块、元组对初始查询的满足程度计算模块和查询结果排序模块.查询松弛重写模块的时间复杂度为O(k),其中k代表查询指定的属性个数;元组对初始查询的满足程度计算模块的时间复杂度为O(n),其中n代表查询结果元组数;查询结果排序模块的时间复杂度为O(nlogn),其中n代表查询结果元组数.所以,在线查询处理阶段的总体时间复杂度为O(nlogn).图5给出了在CarDB和HouseDB数据集上,查询指定了不同属性个数下的查询松弛重写算法的执行时间(取10次查询松弛重写执行时间的平均值).测试查询是随机选取的,每个测试查询都同时在分类型属性和数值型属性上指定了基本查询条件.图5查询指定了不同属性个数下的查询松弛算法执行时间图5显示,查询松弛重写算法的执行时间随着查询指定属性个数的增多而逐渐增长.这是因为当查询指定属性个数增加时,算法需要查找相关数据库表(如属性值IDF权重表和分类型值相似度表)和计算数值型值之间语义相似度的工作量就会增加,因此查询松弛重写所需时间也就相应地有所增长.此外,当松弛阈值发生变化时,查询松弛重写算法的执行时间并无明显变化,原因是松弛阈值的变化仅影响查询条件的放松程度,而几乎不影响查询松弛重写算法对相关数据库表的访问代价.图6给出了在CarDB和HouseDB数据集上,QRRR方法在不同查询结果元组数下的查询响应时间.从图中可以看出,QRRR的查询响应时间随着查询结果元组数的增加几乎呈线性增长趋势.图6QRRR在不同查询结果元组数下的查询响应时间8结论与展望本文针对数据库空(或少量)查询结果问题,提出了一种领域和用户独立的自适应查询松弛和结果排序方法———QRRR.该方法首先根据初始查询条件和原始数据分布推测当前用户偏好,据此分配查询指定属性的权重;然后,根据属性值的特征信息,分别对分类型属性值之间和数值型属性值之间的语义相似度进行评估;根据松弛阈值、属性权重和属性值之间的语义相似度,对初始查询进行松弛处理;最后,通过在数据库上执行松弛查询得到近似匹配的查询结果,并将查询结果按其对初始查询的满足程度进行排序.在两个不同应用领域的数据集上进行测试的结果表明,提出的属性权重和属性值之间的语义相似度评估方法性能稳定、评估结果合理;小规模的用户调查结果表明,QRRR方法具有较高的查全率,返回的相关查询结果能够较好地满足当前用户的需求和偏好.Page13
