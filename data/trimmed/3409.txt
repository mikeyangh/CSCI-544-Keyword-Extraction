Page1复杂软件的级联故障建模王健1),2)刘衍珩1),2)刘雪莲3)1)(吉林大学计算机科学与技术学院长春130012)2)(吉林大学符号计算与知识工程教育部重点实验室长春130012)3)(吉林大学软件学院长春130012)摘要软件复杂性的增加直接导致软件故障的复杂性增加.从系统科学的角度出发,采用复杂网络等方法和技术在整体上研究复杂软件的级联故障特性是研究软件质量的一个新视角.以函数为节点、以调用关系为边,提出了使用有向边和边权表述函数间的调用关系和紧密程度的拓扑模型.通过引入函数容错能力和软件故障强度建立复杂软件的级联故障模型,模拟软件运行时的故障传播行为.对3个实际软件网络的实验结果表明,弱的故障强度、少的初始故障节点和高的容错能力均会减缓故障的传播速度和缩小故障的波及范围.分析了部分软件节点最终未被感染的原因,文中模型有助于为软件工程人员准确检测复杂软件的复杂性和容错性提供新的思路.关键词复杂网络;软件复杂性;软件容错性;级联故障;软件度量1引言随着人们对软件功能的需求越来越高,软件结构也日益复杂,函数与函数、模块与模块、系统与系统等实体之间的互联互通与相互作用使软件整体结构表现出一些全新的特性,研究人员陆续发现软件系统的拓扑结构可以抽象成网络结构,并且具有小世界和无标度等复杂网络特性.由于动态性和开放性的增加,复杂软件时刻受到各种故障和攻击的威胁.例如,1996年6月4日,阿丽亚娜5型火箭由于整型加速度值产生溢出,造成以加速度为参数的速度、位置等变量计算错误,程序只得进入异常处理模块,引爆自毁;2009年9月12日,MSN美国总部服务器瘫痪超过1小时,导致全球900万用户受到影响;2010年1月初,由于一个软件兼容性故障导致美国约有8000至10000台GPS接收机失效.图1给出了故障在SNLC①(作者单位用于编译原理教学的一个简单但功能完整的SNL语言编译器)传播的情况.对于给定的输入目标文件,首先记录在整个执行过程中每个函数在每个时刻的正确输出值,然后在SNLC源代码中随机地挑选一定数量的函数注入人为错误,对比正常函数在后续的执行过程中的输出值与之前的正确输出值,以此观察故障的传播特性.图1的横坐标为以函数为单位的执行步骤,纵坐标为发生故障的函数数目.从图1中可以看出,如果一个或者少数几个函数发生故障,该故障可能会随着调用和依存关系传播至其它函数而引发其它函数无法正常运行,最终导致部分或者整个系统的崩溃,称之为“级联故障”[1].复杂软件作为典型的复杂系统可以运用复杂网络理论进行建模和分析,但是,目前却很少有人直接从软件工程的角度系统地研究复杂软件的质量特征.因此,有必要从复杂网络的视角,结合软件工程实践,对复杂软件的级联故障特性进行深入研究.在软件工程界,多种软件质量度量方法已经被提出,但大部分是建立在分析源代码的基础上.2002年,Valverde等人[2]首先将软件结构抽象为网络拓扑,发现软件网络具有“小世界”和“无标度”现象,符合复杂网络的特点.此后很多研究人员使用复杂网络理论建模和分析软件内部结构,借助复杂网络的数学理论和方法分析软件网络的各种统计特性,对软件进行质量度量及优化.2004年,美国卡内基·梅隆大学软件工程研究所发布了复杂巨系统软件专项调研,试图解决复杂巨系统的软件工程问题[3].2005年,13个跨国IT公司(包括IBM、HP、Nokia等)宣布合作研制网络化软件.2006年,我国学者何克清和李德毅等人将复杂网络理论和方法引入到软件工程的设计之中[4-5].Cai和Yin[6]将软件系统的执行过程视为一个演化的有向复杂网络结构,引入了软件镜像图概念,并发现虽然在拓扑层面上软件执行过程表现出小世界现象,但在时间角度上不再体现小世界特征,其度分布可以表示为幂律分布也可以表示为指数函数.目前,基于复杂网络理论对软件系统的研究工作大多集中在从不同方面和粒度对各类软件系统的复杂特征进行分析,揭示结构性特性,缺少从复杂网络角度研究软件质量特征的工作.另外,目前常用的软件网络模型[7]虽然能够表示软件函数间的相互调用关系,但是无法表示该关系的紧密程度.事实上,各函数被调用次数的差异从复杂网络的角度可以被认作是节点间相互作用的差异.为了表示这种紧密程度,本文提出了一种具有边权的软件网络模型,用以表征函数调用关系和紧密程度;并在此基础上引入了软件故障强度和函数容错能力,设计了一种级联故障模型;同时,对实际软件网络、随机网络和无标度网络的大量实验揭示了故障触发方式、故障强度、初始故障数量、容错能力等对级联故障的影响,并分析了其中的原因,讨论了部分软件网络节点最终未被感染的原因.本文第2节介绍软件复杂性和容错性的相关工作;第3节详细地给出软件网络模型和级联故障模型;第4节通过大量实验对比分析级联故障在实际软件网络中的传播情况以及各模型参数对级联故障的影响,并给出部分软件网络节点最终未被感染的原因;最后总结全文.①SNLC.http://www.hackchina.com/en/cont/136801,Page32相关工作2.1软件复杂性在软件工程领域,已有多种方式对软件复杂性进行度量.代码行数度量法以程序的总代码行数作为程序复杂性的度量值,但比较粗糙,实际中也很少应用.McCabe度量法[8]以图论为工具,先画出程序图,然后用该图的环路数作为程序复杂性的度量,但其实质上是对程序控制流复杂性的度量,并不考虑数据流,因而其科学性和严密性有一定的局限.Halstead度量法[9]通过计算程序中的运算符和操作数的数量对程序的复杂性加以度量,但只考虑了程序的数据流而没有考虑控制流,因而也不能从根本上反映程序的复杂性.复杂网络的出现,为描述软件系统的复杂性提供了一个新的途径.复杂软件系统的拓扑结构可以从服务、构件、模块、包、接口、类、函数等不同粒度进行网络拓扑建模,将上述元素视为组成网络结构的节点,这些元素之间的作用关系如调用关系、继承关系、聚合关系、包含关系、协作关系等视为边.目前,相关研究人员主要是通过复杂网络的理论和方法对软件系统进行研究,研究对象主要是开源软件,采用逆向工程等方法,从开源软件源代码中抽取出软件类图,再建立软件网络模型进行分析,进而发现各种统计特性,并针对研究现象得出一些客观规律.Valverde等人[2]使用复杂网络方法描述软件拓扑结构,将面向对象软件的类图作为研究对象,提取类之间的继承和关联关系作为边,构造了软件结构的复杂网络拓扑图.Alessandro等人[10]提出了一种分析C语言源程序的方法,并分析了Linuxker-nel等开源软件,忽略来自外部的库文件.此后,国内外学者对大量的开源软件进行了分析,进一步验证了软件结构的复杂网络现象[11-13].随着研究的深入,研究人员认为无向图不能确切表示诸如类的继承、调用等关系,转而使用有向图进行建模[14-16].本文提出一种使用加权有向图建模软件结构的方法,能够更加准确地描述软件内部实体之间的依赖关系.2.2软件容错性软件的容错性是指故障出现后,软件系统通过自身调节不致崩溃且仍能正常工作的能力.对软件漏洞进行分类是实现软件容错性的前提,它决定软件容错的方式.软件漏洞是在硬件、软件、协议的具体实现或系统安全策略上(主要是人为)存在的缺陷,从而可以使攻击者能够在未授权的情况下访问或破坏系统.目前,很多大型安全机构分别对软件漏洞进行分类,有Microsoft公司①、CVE安全组织②和FortifySoftware公司[17]等,本文采用FortifySoft-ware的分类策略,对软件漏洞的分类以代码缺陷为基础,通过对代码缺陷的分类,间接地实现了对软件漏洞的分类.同类代码缺陷引起的软件漏洞为一类,并在两个层次上进行归纳:(1)在程序编码层次上归纳出软件的实现过程中的各种代码缺陷;(2)根据漏洞攻击特征,把具有相同特征的代码缺陷归为一类.由此,把代码缺陷分为8类,根据重要性高低依次排序为:(1)输入有效性和表示;(2)API滥用;(3)安全功能;(4)时间和状态;(5)错误;(6)代码质量;(7)封装;(8)环境.如果对一个软件漏洞发起攻击或该漏洞在特定运行环境下出现异常,将可能会引起软件网络的大规模级联效应.复杂网络的级联动力学研究表明[18],故障传播特性、系统抗毁性与网络拓扑结构密切相关,即:无标度网络对随机故障具有很好的鲁棒性,但在基于度的蓄意攻击下存在脆弱性.但是,目前从复杂网络角度评估软件容错性的研究还很少,因此有必要揭示复杂软件网络的级联故障传播规律,有助于软件的开发和部署,运行过程中因势利导,使漏洞得到有效控制和防护.3系统模型大量研究人员集中在探讨软件系统的结构特性[7,10-11,19]、形成机理[2,20]、演化模型[4,21]和软件复杂性度量[10,22-24],本文在对软件进行网络拓扑建模的基础上,进一步构建级联故障模型,探讨故障在软件网络中的传播情况.3.1网络拓扑模型将软件网络表示为具有n个节点,e条边的加权有向图G,记为G=(V,E),其中V是节点集合,V中的每个元素vi代表软件源代码中的一个函数,E是边集合,E中的每个元素〈vi,vj〉是一个有序对,当且仅当vi调用vj时,〈vi,vj〉∈E,即vi→vj.在现有的大多数基于函数实体的软件网络模型中,节点间只有“相连”和“不相连”两种连接方式对应着函数间的“调用”和“不调用”两种关系,但这并①②inCVE.http://www.cve.mitre.org/docs/vuln-trends/index.html.May,2007Page4不能准确地反映软件函数间的调用关系,实际上不同函数间连接的紧密程度也是不同的.因此,为每条有向边设置一个权重wij,用以表征函数间的调用频度,wij∈[1,).同时,定义一个n×n的邻接矩阵[aij],如果在源代码中,函数vi调用函数vj共wij次则aij=wij,否则aij=0.节点集合V不包括库函数.3.2级联故障模型漏洞被触发后称之为故障,故障发生时对软件系统正常运行的影响程度称之为故障强度,实验中采用FortifySoftware公司[17]对代码漏洞的分类方式定义故障强度,记为λ,λ∈[1,8],等级越高,意味着故障影响到其它函数的可能性越大.软件网络中每个节点(函数)对故障的处理能力称为节点容错能力,记为ρ.实际测试过程中采用的函数质量评估方法应与漏洞分类方法相一致,因此参考故障强度,容错能力也被划分为8个等级,即ρ∈[1,8],等级越高表示节点容错能力越强,越不易被软件故障所影响.本文设定两种容错能力分配方式:随机分配,各函数的容错能力符合均值为ρ的泊松分布;优先分配,各函数的容错能力与它拥有的调用关系数目(度)和调用关系紧密程度之和(强度)成正比例关系,即其中,ki和si分别表示节点i的度和强度(权重和),kmax和smax分别表示网络中最大度和最大强度.触发漏洞有两种方式:随机触发,在图G中随机地选取q个节点作为初始故障节点,例如,由于运行环境的偶然变化导致函数功能异常;恶意触发,从图G中选择入度最大的前q个节点作为初始故障节点,例如,黑客发起的攻击.在软件系统运行的过程中,如果函数i出现故障,例如内存溢出,那么该故障可能通过函数间的调用或依赖关系以某一概率传播至函数j,而后者容错能力的强弱决定着该故障能否导致函数j失效,继而影响着调用和依赖函数j的其它函数.不失一般性,假定软件运行时一个或多个函数会同时发生强度相同的初始故障,当容错能力为ρi的函数i调用已发生强度为λj的故障的函数j时,本文规定当λjρi时,函数i是否会受到该故障的影响仅依赖于函数i和函数j之间调用关系的紧密程度;当λj<ρi时,故障能否感染函数i则依赖于两个函数的紧密程度和故障强度与容错能力之比的共同作用.因此,节点i的故障感染概率Pi表示为其中,wmax为图G的最大权重,即最大的调用次数,Wij表示函数i与函数j的调用关系在软件网络中发生的概率,即调用关系的紧密程度,这样设计的原因是因为函数被调用的次数越多意味着它具有的漏洞越易被触发,Wij∈(0,1].发生故障的函数只有当被其它函数调用时才有可能将故障传播出去,因此,故障的一次传播规则定义如下:遍历所有已发生故障的节点,如果指向故障节点有向边的起始节点是非故障节点,则根据式(3)计算感染概率,并以此概率感染该节点,直至所有非故障邻居节点计算完毕.4实验分析本文实验选取了3款大小和用途各异的开源软件SNLC[1]、Sockets①和NotePad++②.Sockets是Berkeley大学提供的一个套接字库,NotePad++是一款出色的代码编辑器.表1列出了SNLC、Sock-ets和NotePad++的函数网络拓扑统计信息.从表1中可以看出,SNLC中各节点之间的联系(2.28)较Sockets(1.68)和NotePad++(1.97)更为紧密.为便于理解,附录A、B和C中分别给出了规模最小的SNLC的原始函数调用关系网络、处理后的拓扑网络和节点编号与函数名称的对应关系.从附录B所示的拓扑图中可以发现,整个软件网络被88号函数分割为两个大的社团,而88号函数正好是main函数.表1SNLC、Sockets、NotePad++节点和边的统计信息软件名称节点(函数)数边(调用关系)数平均出(入)度SNLC297Sockets710NotePad++3117表2给出了3个软件网络弱连通图内的节点数和占总节点数的比例.从表中可以看出,Sockets网络属于弱连通图的节点比例为69%,这是Sockets软件性质决定的.Sockets是一个套接字库,多数函数实现独立功能,不需要依赖于其它函数,同时,Sockets提供了很多测试函数,也是“独立”于其它函①②Page5数的,因此不属于弱连通图.NotePad++实际网络属于弱连通图的节点比例为73%,分析其源代码发现,NotePad++借助了一个插件scintilla,它提供的函数仅有一部分被NotePad++使用,但是网络建模时包括了scintilla的所有函数,因此弱连通图节点比例为73%.初始故障节点从弱连通图中选取,每次实验的循环次数为500,每次模拟的最终结果对应着50次实验的平均值.软件名称弱连通图节点数所占比例/%SNLCSocketsNotePad++4.1故障触发方式与容错能力分配方式图2给出了故障触发方式和容错能力分配方式对级联故障在3种软件中传播的影响.使用I(t)表示t时刻发生故障的节点比例.可以看出,恶意触发的故障传播速度略大于随机触发的故障传播速度.这是因为恶意触发选择的初始故障节点是入度大的节点,这些节点与更多的节点相连,故障更易快速传播;而在随机触发下的初始故障节点是随机选择的,这些节点的入度平均分布,因此在“一跳”内,故障传播的范围小于恶意触发,导致传播速度没有恶意触发快.同时可以发现,容错能力优先分配的软件网络比随机分配的软件网络具有更强的容错性,这表明图2故障触发方式和容错能力分配方式对级联那些具有高节点度(调用关系)和高强度(紧密程度)的函数对整个系统稳定性贡献更大.这里说明一点,恶意攻击选择的初始目标仅是入度大的,而优先分配法则同时考虑节点度和强度,因此,恶意攻击选择的节点不一定是容错能力强的节点.软件系统在故障被恶意触发、容错能力被随机分配的情况下,表现出最差的稳定性.因此接下来考察在该情况下各模型参数对系统稳定性的影响.4.2故障强度图3给出了故障强度对级联故障在SNLC、Sock-ets和NotePad++3种网络结构中传播的影响.3种软件对故障强度表现出一致的反应,即故障强度的增加会促使级联故障传播速度加快,对于规模大的软件而言(例如:NotePad++),也会导致最终发生故障的节点数目也相应地增加.但在各种故障强度下,即便是最高的8级,最终的感染规模也不超过20%.图3故障强度对级联故障的影响(q=32,ρ=4)4.3初始故障数目图4给出了初始故障数目对级联故障在SNLC、Sockets和NotePad++的3种网络结构中传播的影响.少数的初始故障节点并不会诱发级联故障的大规模爆发,这也说明软件内部是允许存在少量错误的,他们的触发并不会对软件的正常工作带来巨大的影响,但当初始故障节点数目增加时,级联故障会逐步蔓延开来,但最终被感染的节点比例依然不会超过20%.Page6图4初始故障数目对级联故障的影响(λ=8,ρ=4)4.4容错能力图5展示了容错能力对级联故障在SNLC、Sockets和NotePad++的3种网络结构中传播的影响.级联故障在3种软件网络中对于提升的容错能力均表现出了相似的规律,即节点平均容错能力越大,故障传播速度越慢,稳态时感染节点的个数越少.这也说明加强函数异常处理功能将提升软件整体质量和容错性,即便发生异常情况时,也不会影响大多数其它函数或模块的正常运行.图6SNLC不同时刻的级联故障传播快照(q=32,λ=8,ρ=4.从左至右依次为t=0,50,100和200)图7Sockets不同时刻的级联故障传播快照(q=32,λ=8,ρ=4.从左至右依次为t=0,50,100和200).图5容错能力对级联故障的影响(q=16,λ=5)4.5故障传播快照图6~8分别给出各软件网络在故障被恶意触发、容错能力被随机分配情况下,当t=0,50,100和200时的级联故障快照,便于更加直观地观察级联故障的传播过程,隐藏了节点间的连接关系.从中可以看出,一旦漏洞被触发,发生软件故障后,该故障会随着函数间的调用关系逐渐扩散,最终演变为级联故障.对比各软件图中故障节点(浅色)增加的比例可发现,级联故障在3种软件网络中的前50次迭代传播最为迅速.Page7图8NotePad++不同时刻的级联故障传播快照(q=32,λ=8,ρ=4.从左至右依次为t=0,50,100和200)4.6节点最终未被感染的原因分析实验过程中发现,有一些节点虽属于连通图,但直到级联故障传播稳定后,依然没有被感染.本文通过对规模最小的SNLC在q=16,λ=5,ρ=4随机触发下的故障传播数据进行跟踪分析后,发现了如图9所示的4种具有代表性的宏观原因.更细致的微观原因可以试图从这4种宏观原因入手分析,将在后续研究工作中给出结果.(1)节点自身容错能力强,如图9(a)所示.例如,编号为38的节点,容错能力为7,具有较强的容错能力,而故障强度为5,所以不易受故障传播的影响;(2)周围节点的容错能力强,如图9(b)所示.节点65的容错能力为4,它的两个邻居节点79和100的容错能力分别为6和5,具有较强的容错能力,所以故障传播到节点65处为止,使调用79和100节点的其它容错能力弱的节点也不会被感染;(3)没有入度的节点,如图9(c)所示.节点176将故障传播给节点216,节点216的容错能力为2,图9节点未被感染的原因示例(圆圈代表节点,里边的数字为“节点号:容错能力”,对比附录A、B和C可以找到各节点的编号、函数名和连接关系)本应该继续传播故障,但该节点没有入度,即没有其它函数调用216号函数,所以级联故障传播到216号处为止;(4)有限的迭代次数,这种情况在NotePad++这种规模较大的软件中更为明显.观察图9(d),当故障传播到节点5后,它的容错能力为3,但模拟时间已到,故障不再继续传播.图9节点未被感染的原因示例.圆圈代表节点,里边的数字为“节点号:容错能力”,对比附录A、B和C可以找到各节点的编号、函数名和连接关系.5结束语本文基于软件函数间的调用关系,引入故障强度和容错能力对复杂软件的级联故障进行建模,模拟软件运行时的故障传播行为.通过对3个实际软件网络的大量模拟实验,揭示了触发方式、容错能力分配方式、故障强度、初始故障数目和容错能力大小等因素对级联故障传播的影响,并分析了造成这些影响的原因,也探讨了节点未被最终感染的可能原因.模拟结果揭示出级联故障的传播速度和范围同故障强度、初始故障数目、容错能力密切相关,即:弱的故障强度、少的初始故障数目和高的容错能力均会减缓级联故障的传播速度,缩小波及范围,提高软件质量.对复杂软件的级联故障进行建模有助于增进对软件复杂性和容错性的认识,为提高软件质量提供帮助.在本文的级联故障模型中,故障强度在整个传播过程中始终保持不变,但由于各函数容错能力的作用和差异,该故障的强度应随着函数的调用而产生变化,例如,如果某函数没有异常处理环节,那么该故障传播至此后强度应该被增加,反之则减弱.下一步工作将设计故障强度的更新规则,基于本文的研究结果,并结合具体的软件工程开发与测试技术,开发复杂软件容错性的检测工具.Page8
