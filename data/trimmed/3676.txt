Page1路网环境下访问序列受限的多标签路线查询算法张金增文洁孟小峰(中国人民大学信息学院北京100872)摘要随着移动互联网、地理定位技术和智能终端设备的迅速普及,产生了大量的位置信息和其对应的标签(tag)描述信息.路线搜索是人们出行时经常进行的活动,但面临多个任务需求时,寻找最佳路线是一项极为耗时的工作.此外空间对象本身的访问权限和用户指定的限制一定程度上制约了对象的访问次序.针对上述情况,文中提出了一种路网环境下访问序列受限的多标签路线(MTROC)查询,该查询的目标是找出一条从源点到目标点、经由与查询中给定的tag相匹配的空间对象且满足序列约束的最短线路.文中证明了MTROC查询问题是NP-hard,并基于增强的路线叠置-关联目录(EROAD)索引提出了3种近似算法.路线扩展RE-Greedy算法和路线渐增插入RII-Greedy算法通过局部更新获得满足需求的路线,而全局路线优化算法GROA为MTROC查询提供一个全局近似最优解.使用真实和合成数据集对文中提出的算法的有效性和可扩展性进行分析评估,实验结果表明3种算法都能有效地完成MTROC查询,其中GROA算法可扩展性最好,而RII-Greedy算法返回的路线质量最高.关键词路网;路线查询;序列约束;签名文件;标签1引言随着地理定位技术GPS、WiFi和智能移动设备的普及以及移动互联网的迅速发展,出现了大量的本地搜索、地理社交网络和在线地图服务,比如GoogleMap、BingLocalSearch、Foursquare、Flicker等.使用各种基于位置的服务,人们可以随时随地进行以下活动:记录位置和活动信息并将这些资源上传,标记在地图上;利用tag或者tweet对空间对象以及其它实体进行描述,为其提供丰富的语义内容;搜索满足用户查询需求的场所或者路线.在日常生活中,大多数用户外出时都有多个任务,不管对该城市是否熟悉,根据这些任务需求手动地制定出行计划和行程路线,都是一项费时费力的工作.因此为用户提供一条经由多个空间对象具有最小代价(距离或者时间花费最短)、满足多个需求的路线是非常必要的.此外,空间对象会受到用户指定的访问或者权利限定(比如银行的营业时间为早9:00~下午5:00)的制约,因此在规划路线时,需要考虑制约因素对访问顺序的影响.考虑图1所示的例子,假设从开会地点回酒店的路上,Mary需要给汽车加油,去中国银行办理业务,到肯德基吃饭,买手机充电器.此外,有两个次序的约束:(1)吃饭前先去银行;(2)买充电器前先去加油.Mary想要找到一条满足上述需求和约束条件的最短路线(实线箭头显示).因此本文提出了一种新的空间查询:路网环境下访问序列受限的多标签(tag)路线(MTROC)查询.在该查询中,用户使用多个tag指定要访问的各个空间对象以及它们之间的访问序列约束,查询的源点由用户提供,或通过移动设备自带的GPS来识别,而终点由用户指定.查询目标在于找到一条从源点到终点、经由与每一个查询tag匹配的空间对象并满足序列约束的最佳路线.目前,与路线搜索相关的工作有以下两类.首先,已有的在线Web地图服务(GoogleMap、BingMap、百度地图)以及空间关键字查询[1-5]方面的研究工作不能很好地回答MTROC查询.在线地图服务使用关键字或地址搜索出任意两个位置之间的线路,而空间关键字查询[1-5]是以一个位置和关键字集合作为参数,检索出离查询点最近并匹配查询关键字的对象.如果利用上述的方法回答图1中的查询,用户首先需要查询附近的一些加油站和中国银行,定位出几个邻近的肯德基和卖充电器的商场,然后将找到的这些空间对象根据序列限制进行组合,最终找出一条满足用户需求的路线.这种方法需要列举出所有候选路线,从中找到最短的路线,显然该方案效率低,费时费力.其次,已有的路线搜索方法[6-9]根据空间对象所属的类别指定路线需求,如果采用此类方法解决MTROC查询,将得到图1虚线箭头所显示的路线,该路线中的对象“中国工商银行”和“川菜馆”虽然属于银行类和餐饮类,但并不满足用户的需求,不适合本文提出的查询.因此亟需设计有效的查询策略回答MTROC查询.构建查询路线存在以下挑战性问题:一方面Web上的空间对象数据快速增长,另一方面次序限制仅仅是对查询需求的部分约束,这就要求找出满足约束的所有全序序列,从得到的大量候选路线中挑出最短的路径,对于路线查询处理来说代价很高.此外,旅行商(TSP)问题可以看作是路网环境下访问序列受限的多tag路线(MTROC)查询问题的特例,所以MTROC查询问题是NP-hard(详细证明见第4节).为了回答该查询,本文提出了3种近似算法.本文的主要贡献在于:(1)定义了一种路网环境下访问序列受限的多tag路线(MTROC)查询,并证明MTROC查询问题是NP-hard.(2)采用哈斯图表示序列约束集,利用拓扑排序将约束关系和查询算法相结合处理MTROC查询.(3)为了回答MTROC查询,首先提出两种局部算法,路线扩展RE-Greedy算法和路线渐增插入RII-Greedy算法.由于局部算法在构建路线的过程中,仅考虑对其中某一段路线的影响,为此提出了一种全局路线优化算法GROA.(4)采用真实和合成数据集对提出的算法进行充分的实验评估,实验结果表明3种算法都能有效地完成MTROC查询,其中算法GROA可扩展性最好,而RII-Greedy算法返回的路线质量最高.Page3本文第2节对MTROC查询进行形式化定义;第3节介绍一种增强的路线叠置-关联目录索引EROAD;第4节详细阐述3种查询处理策略;第5节通过实验对算法进行评估,并对结果进行详细的对比分析;第6节对全文进行总结并对未来研究工作进行展望.2问题描述形式上,空间数据集D是由路网中的空间对象组成.D中的每一个对象o用〈p,t〉表示,p代表对象o的位置;t是o对应的tag描述集合.路网用无向图G(N,E)表示,N是节点ni(交叉口)的集合;E表示任意两节点ni、nj链接边的集合.两节点之间的距离dist(ni,nj)是ni到nj之间的最短路网距离,采用经典的Dijkstra算法计算.MTROC查询采用一个四元组Q={s,e,Ψ,Θ}表示,其中s和e表示用户给定源点和目标点;Ψ表示查询tag集{φ1,φ2,…,φm};φi表示第i个查询tag;Θ表示有效的序列约束集合.定义1.序列约束.一条序列约束是一个查询tag对(φi,φj),它表示用户必须在访问完一个匹配φi的对象之后才能到达匹配φj的对象,也就是φi是φj的直接前驱,φj是φi的直接后继,记为φiφj.为了找到满足需求的路径,将序列约束集合Θ表示成一个哈斯图ΗΘφi,有向边表示节点间的序列约束〈φi,φj〉.Θ是有效的序列约束集合当且仅当ΗΘ是一个有向无环图.而如果ΗΘ存在环,则不可能找出满足Θ的路线,因为两个查询tag是彼此的前序的情况是不成立的.当存在一条哈密顿通路时,Θ中的查询tag是全序关系.定义2.候选路线.给定查询Q{s,e,Ψ,Θ},路径r={s,ox1,ox2,…,oxk,e}(oxi∈D,km)是一条候选路线当且仅当对于任意查询tagφj,至少存在一个空间对象oxi∈D满足φj∈oxi.t,而且路线r中对象的访问顺序满足序列约束集合Θ.所有的候选路线集合记为.可以看出路线r是任意两个连续的对象点通过最短路径链接起来的,因此路线r的长度L(r)=dist(s,ox1)+∑k-1定义3.MTROC查询.访问序列受限的多tag路线(MTROC)查询Q{s,e,Ψ,Θ}是从候选路线集合中找出一条最佳路线r,使得长度最短,匹配查询tag集Ψ,并满足序列约束Θ,即r=argminr∈3增强的路线叠置-关联目录索引为了有效地回答MTROC查询,搜索出满足用户需求的最佳路线,本节构造一种增强的路线叠置-关联目录(EROAD)索引结构方便查询处理.它基于可扩展区域子网分层结构[11](如图2所示),将路网数据和空间对象分开存储,并对该结构进行必要的调整,使其适合本文提出的查询算法.EROAD采用几何方法[12-13]和Kernighan-Lin算法[14]对整个路网按层次进行划分,每一层由相互连接的区域子网组成.在图2中,首先路网空间N被划分为两个区域子网R1和R2,每一个Ri又被划分为两个更小的区域子网Ria和Rib,子网之间公有的节点(比如n1,n2,n3,n4)为边界节点.然后以自底向上的方式构造区域子网的对象摘要(Objectabstract)和它们之间的捷径(Shortcut).对象摘要包括两部分:包含在区域子网中的对象集合和对应的tag概要信息.上层子网的对象摘要是下层孩子摘要的并集,捷径是区域子网边界点之间的最短路径.而对于那些不包含任何空间对象的区域子网,在遍历的过程中可以直接剪掉.为了实现该结构,采取路线叠置(RouteOver-lay,RO)和关联目录(AssociationDirectory,AD)分别索引存储路网数据和空间对象.路线叠置利用B+树对路网节点进行索引,其键值为节点ID,每一个叶子项指向一个路网节点以及对应的捷径树,如图3所示.非边界节点(比如s)的捷径树只有一项,存储该节点到其邻近节点的边以及长度(比如(s,n1),(s,na));而边界节点(比如n2)的捷径树按照该点所在区域子网的层次进行构造,该树非叶子节点存储Page4同一层包含该节点的区域子网(比如R1b,R2a)以及每个子网的捷径边(比如S(n2,n1),S(n2,n4)),叶子节点存储到它邻近节点的边(比如(n2,nb),(n2,nf),(n2,ng)).对于MTROC查询,需要不断地更新当前查询点s,所以与s相邻的节点对应的捷径树需要更新,只需在该点捷径树的底层添加一条边即可.关联目录作为对象查找结构,采用B+树对空间对象进行索引,如图4所示.键值为节点的ID,叶子节点包含路网节点和区域子网两类.若为路网节点,存储两项额外信息:(1)与该节点相邻的对象的距离信息;(2)与该节点相邻对象的tag描述信息,采用签名文件[15]存储.而区域子网节点存储其对象摘要,其tag概要信息是该区域子网包含的所有对象tag签名文件的叠加.如果查询tag的签名文件与对象或者区域子网对应的签名文件不匹配,可以直接剪掉该区域子空间.4查询处理算法题是NP-hard问题.在分析和提出解决方案之前,给出以下结论.定理1.访问序列受限的多标签路线查询问证明.经典的旅行商问题(TSP)是NP-Com-plete问题[16-17].为了证明访问序列受限的多tag路线查询问题是NP-hard,需要构造一个多项式转化将TSP问题规约到本文提出的问题.其中查询tag集合为{φ1,φ2,…,φm},每一个tag都和一个空间对象集合相关联,假设路线中的每一个空间对象唯一地匹配查询集合中的tagφi,那么TSP问题可以看作是访问序列受限的多tag路线查询问题中始点s等于终点e,并且序列约束为空的情况.由此可以得出,访问序列受限的多tag路线查询问题是NP-hard问题.可以看出,不存在多项式时间的算法处理MTROC查询,因此本节提出了两种局部贪婪算法和一种全局优化算法.4.1局部贪婪算法在这一部分,提出两种不同的局部算法回答MTROC查询.首先介绍算法中使用的一些符号:qt(o)表示对象o对应的查询tag;sig(ti)表示tagti的签名文件;Po(ti)表示包含tagti的空间对象集合;PRj(ti)表示第j层匹配ti的区域子网集合,R(oi)表示包含对象oi的区域子网,Po(ti)、PRj(ti)和R(oi)通过遍历关联目录索引得到.为了降低路线r中最短距离的计算代价,减少查询处理中精确路网距离的计算次数,本节利用路线长度下边界dist-(r)和路线长度上边界dist+(r)估计路线r的长度,仅当路线r变成候选结果时再计算其精确的路网距离,由于在索引结构中边界点之间的距离已知,路线准确距离只需计算出对象到所在区域子网的边界点距离即可得到.路线中任意两个对象之间距离下边界和上边界的定义如下.定义4.距离边界dist-,dist+.给定路线r中任意两个点oi和oj,假设包含oi和oj的最底层的区域子网分别为Rma(nf1,nf2)和Rmb(ng1,ng2),其中m表示区域子网所在的层次,nf1,nf2为Rma的左边界节点和右边界节点,ng1,ng2为Rnb的左边界点和右边界点.因此下边界距离dist-(oi,oj)=dist(nf2,ng1),上边界距离dist+(oi,oj)=dist(nf1,ng2).4.1.1路线扩展RE-Greedy算法路线扩展算法是一种发现最短路线的启发式算法.给定一个查询Q{s,e,Ψ,Θ},该算法首先通过对哈斯图ΗΘ进行拓扑排序[18],获得入度为0的tag集合Δzero.然后渐增地向部分候选路径r(s,ox1,…,oxl,e)(l<m)的最后一段线段中添加对象o,使得o的tag描述与Δzero中的某个查询tagφi相匹配,即sig(φi)&sig(o)=sig(φi),并且插入对象o后线段(oxl,e)长度变化最小,即o=argmino∈Po(Δzero){dist(oxl,o)+dist(o,t)}.由于向候选路径中每添加一个对象,都Page5需要|Po(Δzero)|次线段长度的计算,为了降低计算代价,给出以下定理.定理2.给定两个对象oi和oj,oi和oj均与Δzero中的某个tag匹配,如果则oi不可能被添加到候选路径Cr中.证明.由于dist(oxl,oj,e)<dist+(oxl,oj,e),dist(oxl,oi,e)>dist-(oxl,oi,e),根据条件dist-(oxl,oi,e)dist+(oxl,oj,e),显然,dist(oxl,oi,e)>dist(oxl,oj,e),故oi不可能添加至Cr中.算法1.路线扩展RE-Greedy算法.输入:MTROC查询Q{s,e,Ψ,Θ},输出:满足序列约束Θ且匹配查询tag集合Ψ的最短1.r←{s,e};cur_q←s;2.buildHasseDiagramΗΘusingΨandΘ;3.Δzero←tagswithindegree=0inΗΘ;4.whileΔzero≠do5.foreachtagti∈Δzerodo6.searchAD(sig(ti));7.Po(ti)←{o|sig(o)&sig(ti)=sig(ti)};8.PR(ti)←{R|sig(R)&sig(ti)=sig(ti)};9.P(Δzero)←∪iPo(ti);10.randomlyselectanobjectoj;11.U.enqueue(oj,dist(cur_q,oj,t));12.foreachobjectoinP(Δzero)do13.if(dist-(cur_q,o,t)<dist(cur_q,oj,t))<(dist+(cur_q,o,t)14.U.enqueue(o,dist(cur_q,o,t));15.elseifdist(cur_q,oj,t))>(dist+(cur_q,o,t)16.U.enqueue(o,dist-(cur_q,o,t));17.Cur_best=U.dequeue();r←r.insert(Cur_best);18.Cur_q=Cur_best;updateRO;19.removetiformQ.ΨandΔzero;20.updateΔzero;21.returnr.算法1给出了路线扩展RE-Greedy算法的处理过程.首先,路线r初始化为{s,e},并设置当前的查询点Cur_q为s(第1行).使用Ψ和Θ构造哈斯图ΗΘ,并得到Δzero,将不在Θ中的tag项也添加到Δzero中(2~3行),通过遍历关联目录索引AD得到包含Δzero中tag的对象和区域子网(5~9行).维护一个优先队列U,对象按dist-(cur_q,o,e)递增的顺序存储,不满足定理1条件的节点将其下边界距离值更新为精确值dist(cur_q,o,e),上下边界距离值的计算通过访问路线叠置索引RO得到(12~16行).每次循环都可以得到一个最优的对象点cur_best,并将其插入到路线r中(第17行).更新路线覆盖索引RO的当前查询点为cur_best以及其相邻节点对应的捷径树,同时采用拓扑排序的方法更新Δzero(18~20行).整个过程迭代执行,当Δzero为空时,满足用户需求的最短路线r返回.4.1.2路线渐增插入RII-Greedy算法RE-Greedy算法每次向路线r中添加新对象时,仅考虑对当前查询点到目标点线段长度的影响,造成路线快速达到目标点.但在很多情况下,当前查询点到目标点那段路线可能并不是对象的最佳插入位置.因此,本节提出一种路线渐增插入RII-Greedy算法,它允许将匹配Δzero中某个tag的对象插入到r中满足序列约束的任何线段中.假设一条部分候选路线r={s,ox1,…,oxl,e},共l+1段.RII-Greedy算法每次处理一个查询tagφi,从Po(φi)中挑选出一个对象o,并将其插入到满足限制条件线段集合SegΘ的某一段中,使得添加o后对该线段长度影响最小,(k,o)=argmino∈Po(i)∧k∈SegΘ为了确定每个φi匹配对象的插入位置,需要构造一张Po(Ψ)前序表,表中的每一项Po(φi)记录其对应的前序项,这些前序项通过遍历哈斯图HΘ获得,假如φi的序列限制为{φ1φi,φ2φi},那么Po(φi)的前序项为{Po(φ1),Po(φ2)}.当处理φi时,需要检查Po(φi)对应的前序项,找出ox1∈Po(φ1)和ox2∈Po(φ2)在路线中位置索引最大的点,该点之后的那些线段即是SegΘ.当路线r成为完整路径时,整个迭代过程结束,最短路线返回.与RE-Greedy方法相比,本节提出的算法向r中插入空间对象的处理方式不同,需要对算法1中4~16行的代码进行如下修改,由于降低计算路线精确距离的方法与算法1相同,所以不再重复给出.替换算法1第4~19行的代码createapreordertablePOTbyΗΘ;foreachtagφiinΔzerodosearchforpreorderofPo(φi)inPOT;findSegΘ(φi);foreachobjectoinPo(φi)dofindasegment(oxk-1,oxk)ofSegΘ(φi)suchthatinsertointo(oxk-1,oxk);min{dist(oxk-1,o)+dist(o,oxk)};4.2全局路线优化算法GROA以上提出的两种局部算法在寻找最短路线过程Page6中只考虑对某一段路线的影响,是局部最优解.本节提出一种全局路线优化算法GROA,每一次都要考虑从源点经由满足需求的对象点到终点的路线长度.GROA算法首先找出一条满足查询Q相对较短的全局候选路线r,初始化路线长度的阈值Τv为r的长度L(r),将那些到当前查询点距离大于Τv的对象点去掉,利用序列约束依次更新路线r中经由的对象点,直到路线长度达到最短,并匹配给定的查询tag集合.为了找出路线r,首先对每一个查询tagφi,遍历关联目录索引找出φi对应的Po(φi).然后从对应的Po(φi)中检索出一个对象oxi使得dist(s,oxi)+dist(oxi,e)的值最小,得到对象集合O{ox1,…,oxk}.然后每次都从O入度为0的对象集合O(Δzero)中挑选出离当前查询点最近的对象插入到r中.当Δzero为空时,就得到了路线r.接下来介绍如何利用r和O获得更短的路线r.由于MTROC查询访问顺序的限制,造成最短路线的长度随着已满足的查询tag集发生变化.对路线r的每次更新,需要找出已匹配的查询tag集合-satΨ和以-satΨ为前缀的对象集合OS,对于每一个对象o∈OS,需要计算出从o经由尚未匹配的查询tag对象oxi∈O到目标点e的距离,记为dist-e(o),该距离通过遍历路线覆盖索引得到.如果当前路线r的长度小于Τv,则更新路线r和阈值Τv.为了找出以-satΨ为前缀的对象集合,为Po(Ψ)中的对象构建一张前缀-距离邻接表PDL,表中的每一项记录对象o∈Po(Ψ)的前缀查询tag序列和相应的dist-e(o)值.假设查询tag集合为{φ1,φ2,φ3,φ4},其序列约束为{φ1φ2,φ1φ3,φ2φ4,φ3φ4},相应的哈斯图和查询tag对象集如图5所示.根据拓扑排序方法[18],得到查询tag的全序集Γ({φ1,φ2,φ3,φ4},{φ1,φ3,φ2,φ4}).其前缀-距离邻近表如表1所示,比如对象o21的前缀分别为{φ1}和{φ1,φ3},从o21到t路线有两条:(1)经由顺序(φ2,φ3,φ4)的路线,距离为dist(o21,o31,o41,t);(2)经由顺序(φ2,φ4)的路线,距离为dist(o21,o41,t).对象o前序o21φ1o22φ1o31φ1o41φ1,φ2,φ3dist(o41,t)算法2描述了全局路线优化算法GROA处理流程.初始化线路r=r={s,e},构建哈斯图ΗΘ并获得拓扑序列Γ(1~3行).按照Γ找出每个对象对应的查询tag前缀序列,并通过遍历路线覆盖索引RO得到dist-e(o),从而得到前缀-距离邻近表PDL(第4行).首先找出全局最短路线r(5~14行),然后迭代更新获取新的最短路线r(12~23行).在每一次循环遍历的过程中,从PDL中查找前缀为-satΨ的链表项,得到相应的对象集合OS,将OS中dist(Cur_q,o)+dist-e(o)值最小的对象o插入r中,如果当前路线r的长度L(r)<阈值Tv,r就变成当前最短的路线(16~22行).当所有的查询tag均匹配时,最短路线r返回.算法2.全局路线优化算法GROA.输入:MTROC查询Q{s,e,Ψ,Θ},Ψ={φ1,…,φm},输出:满足序列约束Θ且匹配查询tag集合Ψ最短路线r1.r={s,e};r={s,e};Cur_q=s;2.buildHasseDiagramΗΘusingΨandΘ;3.Γ←TopologicalSort(ΗΘ);4.createPrefix-DistanceadjacencylistPDLbyΓandRO5.forifrom1tomdo6.searchB+tree(AD,sig(φi));7.Po(φi)←{o|sig(o)&sig(φi)=sig(φi)};8.findanobjectoxiinPo(φi)suchthatmin(dist(s,9.O←∪{oxi};10.pickanobjectoxjinO(Δzero)withsmallest11.insertoxjintorandr;12.whileΔzero≠do13.o=NN(oxj,O(Δzero));14.insertointor;updateΔzeroandO(Δzero);15.-satΨ←{qt(oxj)};Cur_q=oxj;Τv←L(r);16.while-satΨ<>Ψdo17.OS={o|prefixofoisequalto-satΨinPDL};18.findanobjectoinOSsuchthatargmin{dist(Cur_19.L(r)=dist(s,Cur_q)+dist(Cur_q,o)+dist-e{o};20.ifL(r)<Τvthen21.insertointor;Cur_q=o;Τv←L(r);22.-satΨ←∪{qt(o)};23.returnr.Page75实验结果与分析5.1实验设置在本节中,通过大量的实验评估本文提出的3种算法RE-Greedy、RII-Greddy和GROA的有效性和可扩展性,并进行对比分析.所有实验采用Java实现,运行环境为Intel?Core2DuoCPUT7500@2.66GHz、4GBRAM和运行32位的Windows7操作系统.本文使用合成和真实数据集对提出的算法进行评估.首先从DCW①获取两个城市的真实路网数据,分别是Oldenburg(OL)和California(CA),OL包含6150个节点和7035条边,CA包含21048个节点和22830条边.为了产生合成数据集OL,使用空间节点生成器随机产生100000个对象点,将其均匀地分布在路网边上,然后从del.ic.ious②中抽取出300000个tag,与OL中的空间对象组合生成合成数据集.对于真实数据集CA,从OpenStreet-Map③获得California(CA)的空间对象(POI)集合,包含100000个POI,每个POI对应有2~5个tag图6查询tag数的影响查询tag数对算法性能的影响.该组实验测试了随着查询tag数的变化,3种算法的平均运行时间和路线质量的变化情况,实验结果如图6所示.描述信息,并将POI数据集和路网数据合并.随机产生5个查询集,每个查询集包含50个查询,每个查询的源点和目标点从路网数据集的节点中随机选择,查询tag集合从POI数据集中对象对应的tag集中随机挑选,分别为2,4,6,8,10,而序列约束集合由查询tag集合随机产生.测试过程使用的参数如表2所示,在每一组实验中,仅变化一个参数的取值而其它参数取缺省值,其中受限查询tag比率PCT表示受到约束限制的查询tag数占总的查询tag数的比率.查询tag数m2,4,6,8,10受限tag比率PCT0.0,0.25,0.5,0.75,1.00.5数据集大小|D|100000~10000001000005.2查询性能分析本节分别在真实数据集和合成数据集上测试了RE-Greedy、RII-Greedy和GROA算法的有效性,并对可扩展性进行评估,采用查询平均运行时间和路线质量作为评价指标,路线质量采用路线长度度量.性能测试内容包括以下3个方面.①②③Page8图6(a)和6(b)给出了查询tag数的不同取值对算法平均运行时间的影响情况.可以看出,3种算法的平均运行时间随着查询tag数m的增大而增加.因为当m变大时,为了回答MTROC查询所有的算法需要访问更多的空间对象和计算更多的路网距离.其中GROA运行效率最高,RE-Greedy算法次之,RII-Greedy算法运行时间最长.原因在于相对于GROA算法而言,RII-Greedy算法不仅需要访问更多的空间对象,还需要寻找最佳的插入位置.所有算法的运行时间不超过0.36s.图6(c)和6(d)给出查询tag数的变化对路线质量的影响情况.可以看出,随着查询tag数的增加,3种算法的路线长度都随之增加,这是因为需要访问更多的空间对象.RII-Greedy算法得到的路线质量最优,而GROA优于RE-Greedy算法.受限查询tag比率PCT对算法性能的影响.该组实验的目的是评估受限查询tag率变化时,查询算法的时间代价和路线质量.如图7所示.图7(a)图7受限查询tag率的影响总的来说,当PCT0.5时,RII-Greedy算法的时间代价略高,最长的运行时间为0.089s,但路线质量始终最好,因此该算法的整体性能较高,适用于查询序列约束较多的情况,而算法GROA适合于对查询响应时间要求较高的情况.空间对象数量对算法的影响.该组实验通过变化空间对象数据集的大小,在合成数据集OL上对本文提出的3种算法的可扩展性进行评估.数据集和(b)给出了受限查询tag比率PCT取不同值时,3种算法的时间开销.可以看出,随着PCT变大,算法运行时间减少.这是因为在每次迭代循环过程中,一个更高的PCT值减少了遍历空间对象的数目,降低了搜索空间.还注意到GROA算法的运行时间最小,并且变化不太明显,而算法RE-Greedy和RII-Greedy的运行时间急剧下降.当PCT0.75时,3种算法的运行时间相当,都不大于0.04s.图7(c)和7(d)给出了PCT不同取值对路线质量的影响情况.可以看出,随着受限tag比率PCT的增加,路线长度增大.这是因为PCT越大,序列约束限制就越多,从而造成产生的路线更长.在两个数据集上的测试RII-Greedy算法的路线质量都要优于其它两种算法,且路线长度最短.此外,可以看到OL数据集的路线长度均小于CA数据集的路线长度,这是因为OL数据集中的空间对象的密度较高,分布集中,而CA数据集的对象分布比较稀疏.大小的变化范围为200000~1000000,空间对象采用空间数据产生器随机产生.实验结果如图8所示.从图8(a)和8(b)可以看出,随着空间对象数量的增加,所有的算法的平均运行时间随之增加.其中GROA的可扩展性明显优于RE-Greedy算法和RII-Greedy算法.这是因为对象个数越多,需要计算的对象的空间距离就越多.但总体上看,所有算法最长运行时间也不超过2s.Page9图8空间对象数据集大小的影响6结束语本文研究了路网环境下访问序列受限的多标签路线(MTROC)查询.形式化定义了MTROC查询问题,并依据增强的路线叠置-关联目录(EROAD)索引提出了3种查询处理算法:路线扩展RE-Greedy算法和路线渐增插入RII-Greedy算法.通过对路线局部更新获得满足用户需求的线路,而全局路线优化算法GROA提供了查询的全局最优近似解.本文使用真实和合成数据集对提出的3种算法性能进行分析评估,实验结果表明GROA算法的时间代价和可扩展性要优于RE-Greedy和RII-Greedy算法,但返回的路线质量相对较差.而RII-Greedy算法查询响应时间虽然偏长,但最坏情况也不超过2s,而且该算法可以返回高质量的最短路线.在未来的工作中,我们把工作扩展到动态路网中,在规划路线的过程中考虑实时交通信息(比如交通拥堵、访问时间等).此外,访问序列受限的多标签连续路线查询也是一个非常有挑战性问题.
