Page1左侧带权凸二分图动态权值匹配1)(同济大学软件学院上海201804)2)(华东师范大学上海市高可信计算重点实验室上海200062)摘要动态匹配问题是指在图结构变更的情况下求解某特定匹配,包括添加和删除图中顶点和边的更新操作以及计算匹配信息的查询操作.凸二分图是一类特殊二分图,在其顶点二划分(X,Y)中,Y顶点集为一个全序集,每个x∈X的邻点集在Y中形成一段连续区间.已有的凸二分图动态基数匹配算法不能求解权值匹配,因而该文研究左侧顶点带权凸二分图中动态最大权值匹配问题.文中提出一种问题求解的框架:在更新操作中维护参与匹配的顶点集合,继而在查询操作中计算相应的匹配信息.文中基于交错路定义了可替换集,并证明可通过计算可替换集来维护参与匹配的顶点集;提出紧致子图的概念,证明可替换集的求解等价于紧致子图的求解,从而将传统的通过寻找交替路求解匹配的方法改进为通过寻找子图结构来求解匹配.文中利用凸二分图的凸性质将紧致子图的计算转化为查找该子图中最大或最小y顶点操作,进而结合隐性表征技术在增广平衡二叉查找树数据结构中快速求解,继而设计动态匹配算法在O(log2|V|)平摊时间下维护更新操作,在最坏线性时间下维护查询操作.较之于已知最好的解决不带权凸二分图动态基数匹配问题的方法,该文提出的方法能在与之相同的时间复杂度下解决难度更高的左侧带权问题.关键词凸二分图;动态匹配;交错路;紧致子图;隐性表征;平衡二叉查找树1引言二分图中的匹配问题[1]是一类重要的组合优化和图论问题,现实生活中很多实际问题可以基于二分图匹配问题来求解,如调度和指派问题[2]、模式识别和Web服务中的文本语义分析[3-4]、生物计算[5]和网络安全问题[6]等.二分图中的动态匹配问题是在图结构动态变更的情况下维护某一特定匹配.当图结构规模较大时,对于图的不断变更,若用已有的静态算法来维护特定匹配,则效率较低,故需相应的动态算法以解决这类问题.二分图可形式化描述为图G=(X,Y;E),其中顶点集V=X∪Y,X和Y是V的一个二划分,边集EX×Y.若Y上有一全序序列,每个x∈X的邻居在Y的全序序列中形成一段连续区间,则称图G为凸二分图(convexbipartitegraph);对于任一x∈X,若(x,y1)和(x,y2)属于边集E,其中y1和y2属于Y且y1<y2,则对每个y∈Y且y1<y<y2,(x,y)∈E.若X中每个x附属一权值,则称G为左侧带权凸二分图,其中每条边的权值等于其x端点的权值.左侧带权凸二分图上的最大权值匹配问题对应着一类经典的调度问题[2]:给定任务集合和时间片集合,其中每个任务有释放时间、期限和权值,且执行时间为单位时间,其调度目标是寻找最大权值的可行调度任务子集.凸二分图动态匹配问题在基因染色体比较[7]、频谱拍卖[8]和大规模传感器信道分配[9]等问题中都有广泛的应用.凸二分图上静态匹配问题的研究相对完备.文献[10]最早提出凸二分图上的最大基数匹配问题,并给出一种贪心算法:按递增序列遍历Y集合,对每个顶点y,在与其相连且当前未匹配的x顶点集中选取结束期限最小的顶点与之相匹配;基于快速优先级队列[11],算法可在OY+Xloglog间复杂度下求解.随后,文献[12]将该问题转换成为最小脱机问题[13](off-lineminimumproblem),进而基于并查集[14](Union-Find)数据结构在接近线性时间复杂度下求解.最终,文献[15]通过将图划分为独立分支(distinctcomponent)进而在()间复杂度下求解该问题.权值匹配问题一般比基数匹配问题难度更高.根据边的权值的定义不同,凸二分图上的最大权值(匹配问题有3种变型.在右侧带权凸二分图中(每个y顶点关联一权值),文献[16]给出一贪心算法,在OE+Ylog权值匹配.在左侧带权凸二分图中(每个x顶点关联一权值),文献[12]基于拟阵理论给出了一种OX2+[2]基于一种层次数据结构在OX+klog2平摊时间复杂度下求解,其中kminX,{近期,文献[8]指出在普通带权凸二分图中(每个顶点关联一权值),可在OVlog2下求解最大权值匹配,并针对左侧带权问题,给出了(一种OVlog凸二分图动态匹配问题通过更新操作和查询操作维护某类特定的匹配,其中更新操作包括添加和删除顶点和边,查询操作包括查询某顶点是否已匹配,以及查询某已匹配顶点的相匹配顶点.在此类问题中,一个顶点或一条边的更新可能会导致已有匹配中所有的边的改变,以至于维护动态匹配的难度Page3很高.文献[17]继而指出:“即使在平摊时间,也不可能在次线性(sub-linear)时间下维护最大匹配的显性表征”.通过隐性表征的技术,文献[17]设计了一种算法解决了凸二分图的最大基数动态匹配问题,该算法基于二叉计算树数据结构[18],在Olog2(摊时间复杂度下维护更新操作,在最坏接近线性时间复杂度下维护查询操作.当顶点带权时,不仅需维护匹配的最大边数,而且还需考虑匹配权值的可增广性,这使得动态维护权值匹配有更高的难度.本文研究左侧带权凸二分图中最大权值动态匹配问题,发现解决该问题的关键在于维护最大权值匹配所对应的已匹配顶点集合,而维护该集合的关键在于计算从某个未匹配的顶点通过交错路可达的已匹配顶点集合,或称为可替换集.进一步地,我们提出紧致子图的概念(该子图蕴含有完美匹配),并证明了可替换集的求解等价于紧致子图的求解,同时针对凸二分图结构找到了一种快速求解该子图的方法.在此基础之上改进二叉计算树数据结构,结合隐性表征设计算法,使其在Olog2(时间复杂度下维护查询操作.进而与文献[17]所考察的不带权问题相比,在与其相同的时间复杂度下解决了难度更高的左侧带权问题.本文第2节介绍基本定义和研究问题;第3节界定所提出的可替换集和紧致子图的概念,证明相关的性质和定理,并给出凸二分图中快速求解紧致子图的方法;后面三节设计并分析动态匹配算法和数据结构;最后第7节进行总结.2基本定义与问题描述设G=(X,Y;E)是一个二分图,V=X∪Y,X(G)=X,Y(G)=Y;NG(v)表示顶点v的邻集;NG(V)表示顶点集VV中所有顶点的邻集的并;G[V]表示顶点集VV的导出子图.匹配是图中不相邻的边组成的集合.设M是G的一个匹配,若顶点v是M中某条边的端点,则称v是M饱和的,或称M饱和v;用X(M)和Y(M)分别表示G中所有M饱和的x顶点和y顶点集合.M交错路指其边在E-M和M中交替出现的路;若一条M交错路的起点和终点都是M非饱和的,则称其为M增广路[19].由G的某一匹配M中所有的边的x端点组成的集合称为G的一个X匹配集,用MX表示.给定二分图G的X集合上的一个全序关系,下面定义G的最优X匹配集:定义1.二分图G的最优X匹配集是指G的X匹配集MX={x1,…,xk},x1>…>xk,使得对任一G的X匹配集MX={x1,…,x},x1>…>x,满足以下性质:k,而且i∈[1,],xixi.设G=(X,Y;E)是一个左侧带权凸二分图,G中每个y顶点表示为一个唯一的整数.定义Y集合上一种全序关系为y1<y2.对Y集合中的任意子集Y,Y.min和Y.max分别表示Y中最小的和最大的y顶点.G中每个x顶点用一个四元组(x.id,x.s,x.e,x.w)表示,其中x.id为一个唯一的整数,x.s和x.e分别表示x的邻集中最小的和最大的y顶点,x.w是一个表示x的权值的整数.定义X集合上的3种全序关系:定义start-id序列为(x.s,x.id)的字典序;定义end-id序列为(x.e,x.s,x.id)的字典序;定义weight-id序列为(x.w,-x.e,-x.s,-x.id)的字典序.在左侧带权凸二分图G中,我们根据weight-id的全序关系定义最优X匹配集.对G的任意x∈X,y∈Y,若x.syx.e,则(x,y)∈E,即给定X顶点集和Y顶点集,边集可由顶点集隐性表征,故左侧带权凸二分图可用二元组(X,Y)表示.对一个x顶点xX,用G+x表示左侧带权凸二分图G=(X,Y),其中X=X+x,Y=Y.同理,G+y表示在G中加入顶点yY.在左侧带权凸二分图动态匹配问题中,若某x顶点的权值为负,则该x必然不属于任一最大权值匹配.因带负权值的x顶点容易识别并去除,故本文假设x权值为非负.根据文献[20]中的引理2可推出,在权值非负的左侧带权凸二分图中,任一饱和最优X匹配集的匹配M都是一个最大权值匹配,故本文动态匹配算法在更新操作中维护最优X匹配集.算法维护的更新操作包括:(1)insert(x^):添加顶点x^X,对于Y中每个满足x^.s<y<x^.e的顶点y,y与x^相连.(2)insert(y^):添加顶点y^Y,对于X中任一满足x.s<y^<x.e的顶点x,x与y^相连.(3)delete(x^):删除顶点x^∈X;图中所有与x^相连的边隐性删除.(4)delete(y^):删除顶点y^∈Y,y^不等于任一x∈X的x.s或x.e;图中所有与y^相连的边隐性删除.删除任意边的操作将破坏凸性质,因而边的更新操作需加以限制.通过相应顶点的更新操作来完成边的加入或删除,即添加边(x,y)通过先删除x顶点,继而重新加入已修改x.s或x.e的x顶点来实Page4现;删除边的操作与之类似.算法维护的查询操作包括:(1)status(v):查询顶点v的匹配状态.(2)pair(v):查询已匹配顶点v的相匹配顶点.3紧致子图与可替换集本节界定二分图上的可替换集和紧致子图的概念,证明其性质以及它们之间的关系,并针对凸二分图结构给出一种快速求解紧致子图的方法.3.1可替换集在二分图G中,当x顶点x^不能增广MX时,即MX+x^不是G的X匹配集时,我们定义x^的MX可替换集如下.定义2.在二分图G=(X,Y;E)中,对于X匹配集MX和顶点x^∈X-MX,设M为饱和MX的任一匹配,若x^不能增广M,则称从x^出发的M交错路可达的MX中的顶点集R(x^,MX)为x^的MX可替换集.例如,图1中MX={x1,x2,x4},从x^出发的M交错路可达x1和x2,x^的MX可替换集R(x^,MX)={x1,x2}.由以下命题可知x^的MX可替换集仅与X匹配集MX相关,与具体饱和MX的匹配无关.命题1.对于二分图G=X,Y;(集MX和顶点x^∈X-MX,若x^不能增广MX,即MX+x^不是G中X匹配集,则对于任一饱和MX的匹配M,x^的MX可替换集相同.证明.设M1,M2为饱和MX的任意两个匹配,即XM()1=XM()2=MX.由文献[1]中定理1可知对称差G=M1M2包含由M1和M2中边交替出现的圈或迹.若可证明x^所有的邻点都属于G中的圈,则命题可证.任取x^的邻点y1,y1是M1饱和且M2饱和的,否则x^,y()1可增广M1或M2,与前提相矛盾.令x1,y(x2,得证.若x1≠x2,从y1出发经过x1的路径必然可沿M1和M2中的边交替延伸,且:(1)中间经过的y顶点必然是M1饱和的,否则x^增广M1;(2)中间经过的x顶点必然是M2饱和的,因为M2饱和MX.易推知该路径必然最终延伸回到顶点y1.故而,所有从x^出发的M1交错路可达的x顶点都可被从x^出发的M2交错路可达.下面两个命题刻画了不同X匹配集之间的转换关系以及最优X匹配集的性质,为证明定理1做准备.命题2.若MX,MX在二分图G中是X匹配集,其中MX=s,MX=r,且s>r,则存在X匹配集MX,满足MX=s,MXMX,且MX-MXMX-MX.证明.设M1,M2分别为G中饱和MX,MX的任意两个匹配,则在M1M2中必然存在至少s-r条顶点不相交的M2增广路(文献[1]中定理1).故而M2可增广至M3,其中M3=s,XM()2XM()3且XM()3-XM()2XM()1-XM()2.证毕.命题3.设MX在二分图G中是最优X匹配集,则对x∈X-MX,MX在G=G-x中也是最优X匹配集.证明.(反证法)假设MX不是G-x的最优X匹配集,令MX≠MX为最优.设MX={珚x1,…,珚xm},MX=x1,…,xMX在G中是X匹配集,且珚xi>xi,与MX在G中是最优X匹配集矛盾.本文的动态算法通过维护最优X匹配集以维护最大权值匹配,以下定理给出了一种通过可替换集维护最优X匹配集的方法.定理1.设二分图G=X,Y;(配集为MX,对于顶点xX,若MX=MX+x为G=G+x的X匹配集,则MX为G的最优X匹配集;否则,令Rx,(集,x为Rx,(小元素,则MX+x-x为G的最优X匹配集.证明.(1)先证明:若MX=MX+x为G=G+x的X匹配集,则MX为G的最优X匹配集.(反证法)假设MX不是G的最优X匹配集,令MX≠MX为最优.若MX>MX,则MX-x在G中是X匹配集,且MX-x>|MX|,与已知MX在G中是最优X匹配集相矛盾,故而MX=MX.若xMX,则MX在G中是X匹配集且MX>MX,矛盾,故而x∈MX.设MX=Page5珚x1,…,珚x{xm},其中x1>…>xm,由MX是G的最优X匹配集,可知:i∈[1,m],珚xixi.(集合示意关系参看图2)令珚xk=x,xj=x,可推知kj,否则珚xk=xj<xk,与MX最优相矛盾.可推知i∈[j,k-1],珚xixi+1,即对于MX[j,k)和MX(j,k]中的相同序列元素,前者不小于后者.故对于序列MX-x=MX[1,j)+MX[j,k)+MX(k,m)={珚x1,…,珚xm-1}以及序列MX-x=MX[1,j)+MX(j,k]+MX(k,m)=x1,…,xm[1,m-1],珚xixi,这与已知MX是G中最优X匹配集矛盾,故而MX为G的最优X匹配集.证明.(2)若MX+x不是G=G+x的X匹配集,则MX=MX+x-x为G的最优X匹配集,其中x为Rx,(下的最小元素.(反证法)假设MX不是G的最优X匹配集,令MX≠MX为最优.假设xMX,由命题3,MX在G中是最优X匹配集,若MX=MX,则x=x,MX=MX,矛盾;若MX≠MX,与已知MX最优相矛盾,故可得x∈MX.若MX>MX,根据命题2,存在X匹配集槇且槇珚x=x,即MX+x是G的X匹配集,与已知相矛盾.若珚x≠x,即MX+珚x是G的X匹配集,与MX在G中最优矛盾,故而MX=MX.设MX={珚x1,…,珚xm},其中珚x1…珚xm;设MX={x1,…,xm},其中x1…xm;设MX={x1,…,xm},其中x1…xm.MX-MXMX-MX,设珚x∈可证明xMX.(反证法)假设x∈MX,令x和x在MX中序列分别为l和k,即珚xl=x,珚xk=x.可推知MX1,k[k,珚xi>xi,使得MX1,k[集,且与MX是G中最优相矛盾.对于G中X匹配集槇配集槇MX=MX1,[]k和MX,根据命题2,存在X匹MX使得槇MX-其中珚x∈MX[k,m],即珚x∈R(x,MX)∪x且珚x<x,与已知相矛盾.故而xMX.若x=x,由上述证明可知x∈MX且xMX,矛盾.若x>x,即MX=MX+x-x.设在MX中,xk=x.由MX最优可知,ik,珚xixi.若ik,珚xi>xi,则MX[1,i]-x在G中是X匹配集,且与MX是最优相矛盾,故而ik,珚xi>xi.由MX≠MX,设r>k为最小的整数使得珚xr>xr=xr.(如图3所示)考察MX1=MX[1,r]和MX2=MX[1,r-1],x,珚x{MX2可与x或珚xr增广一个单位.若珚xr可增广MX2,则MX2+珚xr在G中是X匹配集,且珚xr>xr,与MX在G中是最优相矛盾.若x可增广MX2,考察MX和MX2+x,根据命题2,MX2+x可增广至MX3,MX3=MX,且MX3-MX2-xMX-MX2-x=MX[r,m],可推知MX-MX3=珟x<x,MX3-MX=x,即珟x∈R(x,MX)且珟x<x,与已知相矛盾.故MX是G的最优X匹配集.3.2紧致子图与可替换集二分图中一类特殊的子图与可替换集有密切的联系,下面先给出紧致子图的定义.定义3.二分图G中满足下列性质的子图H称为紧致子图:H是一个蕴含完美匹配的点集非空的导出子图,且x∈X(H),NG()xY(H).更为确切地说,二分图G=X,Y;(点子集XX,其中X=|NG(X)|,且对于任意XX,都满足X|NG(X)|,则称导出子图Page6G[X∪NG(X)]是G的紧致子图.对于G的紧致子图G和G,若()XGX(G),则称G覆盖G.根据Hall定理[21],易推知满足上述关系的子图蕴含完美匹配.我们有如下命题.命题4.对于二分图G的匹配M和紧致子图G,若()XGX(M),则()YGY(M).证明.假设()YGY(M),即Y1=()YG-()YM≠,任选y1∈Y1.令Y2为()XG中的x顶点在M中相匹配的y顶点集合,易知|Y2|=|X(G)|且Y2()YM.因此Y2+y1NG()NG())XG>|X(G)|,与定义矛盾.证毕.(定义4.在二分图G=X,Y;(匹配集MX,顶点x^∈X-MX,NGx()^≠,若G是G的紧致子图,其中()XGMX且NGx()^()YG,则称G是图G中x^的MX紧致子图.若不存在另一x^的MX紧致子图G使得G覆盖G,则称G为图G中x^的MX最小紧致子图.例如图4所示,图G中X=x1,x2,x3,x{Y=y1,y2,y则G=G[X∪Y]是图G的紧致子图,G也是图G中x^的MX紧致子图;令X={x1,x2},Y={y1,y2},则G=G[X∪Y]是x^的MX最小紧致子图.由命题4的证明可知,若G是x^的MX紧致子图,对于饱和MX的任一匹配M,NGx()^()YGY(M).下面的命题刻画了最小紧致子图的唯一性.命题5.设MX是二分图G中一个X匹配集,对于顶点x^∈X(G)-MX,且NGx()^≠,若图G中存在x^的MX紧致子图G,则存在唯一的x^的MX最小紧致子图.证明.假设存在不止一个x^的MX最小紧致子图,设其中任意两个为G1和G2,G1≠G2.令Y1=YG()1,Y2=YG()2,易知Y1≠Y2,否则XG()1=XG()2,G1=G2.因此,Y1∩Y2≠,Y1Y2,Y2Y1.令Y3=Y1∩Y2,可得Y3Y1,Y3Y2.根据x的MX紧致子图定义,NG()xY3.设M为任一饱和MX的匹配.令X3MX包含M中与Y3中y顶点相匹配的x顶点集合,可推知X3XG()1∩XG()2,否则集合XG()1XG()2中存在未匹配的x顶点.令Y3=NGX()3,珚Y=Y3-Y3.根据紧致子图定义,珚YY1∩Y2;根据Y3定义,珚YY1∩Y2,故而珚Y=,可得NGX()3=Y3.因为X3=Y3,可得G3=G[X3∪Y]是x^的MX紧致子图,且被G1和G2覆盖,与假设相矛盾.下面的关键引理刻画了匹配的可增广性与紧致子图的存在性之间的关系.引理1.对于二分图G=X,Y;(集MX和顶点x^∈X-MX,且NGx()^≠,x^不能增广MX当且仅当存在x^的MX紧致子图.证明.(必要性)设x^不能增广MX,R(x^,MX)为x^的MX可替换集,令M为饱和MX的任一匹配.令X=R(x^,MX),Y=NG(X).可推知NGx()^Y成立,否则对于y∈NGx()^-Y,(x^,y)是一条M增广路.若X<|Y|,则必有y∈Y未匹配,且存在从x^到y的M增广路,矛盾,因此|X||Y|.可知MXMX,|MX||NG(MX)|,而XMX,故X|Y|.因此,X=|Y|,G[X∪Y]是x^的MX紧致子图.(充分性)设G=G[X∪Y]是x^的MX紧致子图,令M为饱和MX的任一匹配.由反证法,假定x^可增广MX,即存在从x^到某未匹配y顶点y的增广路珚P.因为Y中所有顶点均匹配,因此yY.故珚P从x^出发,进入NGx()^Y,返回X,如此前进直至最终从某个x∈X达到某个yY,矛盾,因为x∈X,NG()xY.由引理1可得出下面关于可替换集和紧致子图之间的重要关系.推论1.对于二分图G=X,Y;(集MX和顶点x^∈X-MX,若x^不能增广MX,x^的MX可替换集Rx^,(中x^的MX最小紧致子图.证明.根据引理1可知存在x^的MX紧致子图,设G^=G[X^∪Y^]为x^的MX最小紧致子图,M为饱和MX的任一匹配.令X=R(x^,MX).XX^成立,因为任一从x^出发的交错路不能延伸出G^.下面证明X^X.初始,令Y=NG(x^),X=NG[M](Y),其中G[M]为M的边导出子图.因为G^是x^的MX紧致子图,YY^,可得XX^,因此X|NG(X)|且NG()XY^.可推知XX^始终满足,故可递归赋值:Y=NG()X,X=NG[M](Y),直到X=Page7|NG(X)|.此时,若X=X^,引理得证.若XX^,G[X∪Y]是一个x^的MX紧致子图且为G^所覆盖,与G^是x^的MX最小紧致子图相矛盾.证毕.3.3紧致子图在凸二分图中的求解在凸二分图中,由于图的凸结构性质,图中的紧致子图含有一些特殊性质.命题6.设MX是凸二分图G=X,()Y中一个X匹配集,对于顶点x^∈X-X(M),NGx()^≠,若图G中存在x^的MX紧致子图G,则()YG是Y上的一个连续区间.证明.设M为任一饱和MX的匹配.令Y0=NGx()^,Xi=NG[M]Y()i,即Xi是M上与Yi中y顶点相匹配的x顶点集合,Yi+1=NGX()i.下面用归纳法:显然Y0在()YG上连续,假设Yi在()YG上连续,证明Yi+1在()YG上连续.初始地令Y=Yi.遍历Xi,对于每个顶点x∈Xi,扩充Y=Y∪NG(x).根据凸性质以及已知x在M中相匹配顶点y∈Y,即NG()x∩Y≠,可知在每次扩充后Y在()YG上连续.因此Yi+1在()YG上连续.当Yi=()YG时,定理得证.进而可利用凸性质在凸二分图中快速判断和求解紧致子图.定义5.给定凸二分图G=(X[1,n],Y[1,m])和某一X匹配集MX,定义:αi,(dαi,(βj,()MX=m-j+1-βj,(dβj,(若dαk,(若dβk,(以下引理刻画紧致点与紧致子图间的关系.引理2.对于凸二分图G=X,()Y中X匹配集MX,若k为α-MX紧致点,则[]GV是紧致子图,其中V=MX[1,k]∪Y[1,k],MX按end-id序列排序;若k为β-MX紧致点,则[]GV是紧致子图,其中V=MX[|MX|-m+k,|MX|]∪Y[k,m],MX按start-id序列排序.证明.由凸二分图的凸性质以及紧致点、紧致子图定义即可得证.下面界定一些特殊的紧致点,它们与求解最小紧致子图相关.定义6.给定凸二分图G=X,()Y中X匹配集MX和顶点y∈Y,若存在α-MX紧致点k且Y[k]y,则称其中最小的k为αPosty,(致点;若存在α-MX紧致点k且Y[k]<y,则称其中最大的k为αPrey,(β-MX紧致点k且Y[k]y,则称其中最大的k为βPrey,(Y[k]>y,则称其中最小的k为βPosty,(引理3和引理4给出了在凸二分图中,对于几种特殊的x顶点,根据紧致点判断X匹配集的可增广性和求解可替换集的方法.引理3.设MX为凸二分图G=X,()Y中X匹配集,对于顶点x^X,当x^.sY.min,或存在x∈MX,使得从x^出发的MX交错路可达x且x.sY.min时,在图G+x^中,若不存在α-MX紧致点i且Y[i]x^.e,则x^可增广MX;若存在这类紧致点,令k为αPostx^.e,(可替换集Rx^,(end-id序列排序.证明.令j=miniY:Y[i]x^.察情况:x^.sY.min.在图G+x^中,MX仍为X匹配集,若存在x^的MX紧致子图G,根据紧致子图的定义则有Y[1,j]()YG.又根据命题6可知,()YG是Y上的连续区间,令Y[k]=()YG.max,则()YG=Y[1,k].再根据紧致子图的定义,可知|X(G)|=k,且x∈()XG,x.eY[k].根据α-MX紧致点的定义可推知,k是一个α-MX紧致点,且[]Ykx^.e.因此,若不存在α-MX紧致点i且Y[i]x^.e,则不存在x^的MX紧致子图,此时,根据引理1,则x^可增广MX.若存在α-MX紧致点i且[]Yix^.e,令k为x的α-MX最小紧致点.根据定义和引理2不难证明,GMX[1,k]∪Y[1,k其中MX按end-id序列排序.因此,根据推论1,可得Rx^,([再考察x可被x^出发的MX交错路可达,且x.sY.min,即在图G+x^中x∈R(x^,MX).若存在x^的MX紧致子图,令G是x^的MX最小紧致子图,则根据推论1,有x∈R(x^,MX)=X(G),Y[1]()YG且Y[j]()YG.根据命题6,()YG是Y上的连续区间,则()YG=Y[1,k],其中Y[k]=Y(G).max.后面的证明与x^.sY.min情况下相类似.对称地,对应于β-MX最大紧致点情形有如下引理,证明与引理3类似.引理4.设MX为凸二分图G=X,()Y中XPage8匹配集,对于顶点x^X,当x^.eY.max,或存在x∈MX,使得从x^出发的MX交错路可达x且x.eY.max时,在图G+x^中,若不存在β-MX紧致点i且Y[i]x^.s,则x^可增广MX;若存在这类紧致点,x^的MX可替换集R(x^,MX)=MX[|MX|-|Y|+k,|MX|],其中k为βPrex^.s,(MX按start-id序列排序.证明.略.本节研究了在求解左侧带权凸二分图动态匹配问题中所涉及到的一些关键的概念和定理.下文将研究具体的动态匹配算法,包括动态算法和数据结构的设计与分析.4改进的二叉计算树二叉计算树数据结构最早由文献[18]提出以解决凸二分图上的并行匹配问题.随后文献[17]基于该结构结合隐性表征,解决不带权凸二分图上的动态匹配问题.本节改进二叉计算树隐性表征结构,使其可支持带权问题的求解.4.1改进的二叉计算树数据结构二叉计算树是增广的平衡二叉查找树(如红黑树,参阅文献[22]).给定左侧带权凸二分图G=X,()Y,将集合S=x.s:x∈列,进而S可表示为s1,…,s{1.进而Y可划分为k个连续区间:[si,si+1-1],1ik.在二叉计算树中,从左往右第i个叶子节点与子图G[Xi∪Yi]相关联,其中Xi={x∈X:x.s=si},Yi=[si,si+1-1].令P为某中间节点,L为其左孩子节点,R为其右孩子节点.节点P关联子图G[XP∪YP],其中XP=XL∪XR,YP=YL∪YR.故而,根节点关联图G.每个节点P中增广数个辅助集合,如表1所示.XPYPFXP游离集,FXP=x∈XP:x.e>Y.MXPUXP未匹配集,UXP=x∈XP-FXP-MX对于节点P中的辅助集合,算法维护一些循环不变式,其中关键的两个为:(1)1:MXP是子图GP^中的最优X匹配集.(2)2:不存在x∈MXr[图GMXP∪YlMXlP,且在end-id排序下x<x.由1可推知当P为树中根节点时,MXP即为图G的最优X匹配集.2决定MXP的划分,在动态更新操作中保证了算法效率(下文5.1节论及).4.1.1节点内部表征二叉计算树中每个节点的辅助集合同样基于增广的平衡二叉树来表征,因此整体结构是二维树结构.节点P中的数据结构表征包括:(1)对于辅助集合MXlUXP,每个集合有一颗对应的树结构表征;(2)一颗α树表征GMXr(3)一颗β树表征GMXl辅助集合表征:辅助集合树结构的表征方法以集合MXr节点对应一个x∈MXr排序,即叶子节点所关联的关键字为(x.e,x.s,x.id).对于树中每个节点u,增广数个辅助域,包括u.size=|leaves(u)|,其中leaves(u)表示以u为根节点的子树中所包含的叶子节点集合;u.maxe,u.mins,u.minw分别表示集合所关联的x集合中,end-id排序下最大的x,start-id排序下最小的x,weight-id排序下最小的x.其他辅助集合的树结构可同理表征.α树表征:在α树中,每个叶子节点对应一个y∈P.叶子节点的关键字为所关联的y顶点,按照yYr的增序排列.从左往右第i个叶子命名为yi,叶子yi对应Yr对于中间节点,u.d的初值为0,对于叶子节点yi,u.d的初值为i(下一小节将会讨论:每次基本操作至多影响3条从根节点到叶子节点的路径,使得其中的节点所对应的d的值发生改变).定义d(u,v)=n.d,其中v是u的祖先节点,犘[u,v]代表从∑n∈犘[u,v]u到v的不包含v的路径.对于节点u,定义()du=du,()root,root代表α树中根节点.这样,对于叶子yi,dy()i=dαi,MXr个节点u增广辅助域dmin,其值为min{dk,()u:k∈leaves(v)}.因此,对于节点u,等式()du+u.dmin=min()dv:v∈个整型域σ,初值为0,随后在每次使用前更新为()du.每个节点u增广辅助域maxy,表示{Page9的y集合中最大的y.β树结构可同理表征.4.2基本操作在上述表征的基础上,二叉计算树数据结构支持如下操作:(1)在辅助集合树结构中查询某子集中的最大或最小元素以及更新集合的操作;(2)在α树查询αPrey,MXr紧致点,以及更新集合的操作;(3)在β树查询βPrey,MXl紧致点以及更新集合的操作.该小节分别以一种情况为例,描述和分析这几类基本操作的算法及其时间复杂度.辅助集合查询和更新:考虑在MXr满足x.ey的条件时weight-id排序下最小元素的操作,即寻找x^=minw{x∈MXrP树中,根据域maxe,自顶向下遍历路径犘(root,MXrl),其中l代表满足x.ey中最大的叶子节点;对于路径中每个节点u,若存在u的左兄弟节点v且在weight-id排序下v.minw<x^,置x^=v.minw,其中x^.w的初值置为+.令叶子l所关联的x顶点为x.若在weight-id排序下x^>x,则返回x.否则,自下而上遍历路径犘[l,root],直到遇到第1个满足下述条件的节点u:u的左兄弟节点v中v.minw=x^.以v为根节点的子树包含对应x^的叶子节点,根据域minw可定位该叶子.故而在MXrweight-id排序下最小元素的操作,至多遍历从根节点到某叶子节点的路径3次.在MXr个新x顶点时,同样可根据域maxe定位加入的叶子节点,进而完成添加操作;若其中涉及到树的平衡操作(如旋转),每个节点中所对应的辅助域可在常数时间内进行调整.α树查询:基于α树可实现在子图G(顶点y的αPosty,MXrαPosty,MXr在x的紧致点,故假设yYP.max.在α树中,根据域maxy,自顶向下遍历路径犘(root,y),对于路径中每个节点u,更新u.σ.定位到y之后,自下而上遍历路径犘[y,root],直到遇到第1个满足下述条件的节点u:u的右兄弟节点v中v.dmin+v.d+u.parent.σ=0.若不存在这样的节点,则当前α树中不存在x的紧致点;否则,以v为根节点的子树包含对应x的α-M最小紧致点k的叶子节点yk,即足dy()i=0的最小叶子节点yi.以如下方法确定从v到yk路径,对于路径中每个节点u,更新u.σ,并从u的两个孩子节点中选择满足u.σ+vd+v.dmin=0的孩子节点v(优先选择左孩子节点).当定位到yk之后,即可通过相似的方法求解yk在Yr的序列位置,即为k的值.查找x^的α-M最小紧致点k的操作遍历从根节点到叶子节点的路径至多3次.αPrey,MXr树中,βPrey,MXl以类似求解.α树更新:MXr与上述讨论类似.通过x^.e即可找到对应的叶子节点y,将y.d减1,然后自下而上遍历路径犘[y,root],对于路径中的每个节点u,若u有右兄弟节点v,则v.d减1,同时对于路径中的每个节点更新其dmin域的值.例如图5所示,每个叶子节点下面的数值代表d域的初值,设x^.e对应第2个叶子节点,树中的深色节点表示d域更新的节点.更新α树的操作遍历从根节点到叶子节点的路径至多2次.若P中发生替换操作,即x^替换了其中某个x,则MXr涉及从x^.e和x.e两个叶子节点到根节点的更新值操作,方法类似.在β树中的更新和替换操作同理可实现.引理5.改进的二叉计算树中的基本操作的时间复杂度为Olog(证明.在辅助集合对应的树结构中,查询和更新操作至多遍历从根节点到某叶子节点的路径3次,在每个节点中操作为常数时间复杂度,故而可在对数时间复杂度下完成.在α树以及β树中的查询紧致点和更新树的操作同样至多遍历从根节点到叶子节点的路径3次,对于树中每个节点中的操作为常数时间,故而可在对数时间复杂度下实现.证毕.本节我们基于二叉计算树,设计了支持左侧带权凸二分图动态匹配的数据结构,给出了其隐性表征结构,以及该数据结构支持的基本操作.下一节将研究动态匹配算法.Page105动态匹配算法动态匹配算法的设计基于改进的二叉计算树数据结构.本节详细描述并证明图中添加新的x顶点的动态更新操作,其他更新操作可类似求解;动态查询操作可采用我们已有方法[23]来实现.5.1犻狀狊犲狉狋(狓)更新操作动态更新操作保证二叉计算树的每个节点P中的辅助集合满足相应的循环不变式,即维护子图GP^=G(XP-FXP)∪Y首先定义相对于节点P的可替换集.定义7.设MXP为二叉计算树中节点P所对应子图GP^=G(XP-FXP)∪Y集,给定顶点xXP且x.eYP.max,若x不能增广MXP,即MXP+x不是GP^=G[(XP-FXP+x)∪YP]的X匹配集,则称图GP^中x的MXP可替换集为x在节点P中的可替换集,记为RSx,()P.当不致混淆时,简记RSx,()P为()RSx.易知x∈RS(x,P),MX=MXP+x-x为子图GP^的一个X匹配集.以下推论由给出了在GP^中维护最优X匹配集的方法.推论2.设MXP为二叉计算树中节点P所对应子图GP^=G(XP-FXP)∪Y集,给定顶点xXP且x.eYP.max,若MXP=MXP+x为GP^=G(XP-FXP+x)∪Y配集,则MXP为GP^的最优X匹配集;否则,令rx为RSx,()P∪x中按weight-id序列排序下的最小元素,MX+x-rx为GP^的最优X匹配集.证明.由定理1直接推论可证.更新操作的计算遍历二叉计算树中从某个叶子节点到根节点的路径,对于该路径中的每个节点,依次进行更新操作,且路径中每个父节点中的操作依赖于其子节点的操作计算结果,该结果用消息机制进行传递.在一个五元组X+,MX+,MX-,FX+,UX点P传递给其父节点,其中X+表示当前加入的x顶点,MX+和MX-分别表示加入和移除出MXP集合的x顶点,FX+和UX+类似定义.五元组中元素的值可能为空,用符号Λ表示.5.1.1叶子节点中加入x算法1是在一个叶子节点中操作.令加入的x顶点为x^,根据x^.s来定位到相应的叶子节点P(因为x∈XP,x.s=x^.s=YP.min).若x^.e>YP.max,x^属于FXP集合.否则,在α树中查找αPostx^.e,MXr则MXr存在,则可根据其值来确定可替换集RSx^,()P.进而在该叶子节点中维护循环不变式,即维护相对应于该节点子图GP^+x^的最优X匹配集.上述情况都涉及相关的辅助集合更新以及相应的msg消息的赋值;若P有父节点,则msg作为参数向上传递.算法1.InsertXinLeafx()^.输入:新加入的x顶点输出:msg消息1.XP←XP+x^,msg.X+←x^2.IFx^.e>YP.3.FXP←FXP+x^,msg.FX+←x^4.ELSEIF/αPostx^.e,MXr5.MXr6.ELSE7.α←MXr8.RSx^,()P←{x∈MXr9.rx←minwx∈RSx^,()P∪x10.MXr11.msg.MX+←x^,msg.MX-←msg.UX+←rx12.RETURNmsg以下定理保证了算法1的正确性.定理2.算法InsertXinLeaf(x^)在二叉计算树中的叶子节点中维护了循环不变式,时间复杂度为Olog(证明.叶子节点P中,YlMXrP.已知加入x^之前MXP是子图GP^=G[(XP-FXP)∪YP]中的最优X匹配集,现证明加入x^之后MXP是子图GP^=G(XP-FXP+x)∪Y优X匹配集.根据引理3,通过αPostx^.e,MXr算结果,即可判断x^是否可增广MXP.若不能增广,则可通过MXrRSx^,()P(MXr论2,从中替换weight-id序列排序下的最小元素即可求解最优X匹配集.根据引理5,在算法1中,每一步的操作都可基于辅助集合对应的树结构在对数时间复杂度下实现,故而在叶子节点中加入x的操作可在对数时间复杂度实现.若加入的x^的x^.s{x.s:X-x^},则二叉计算树的结构会发生变化,产生新的叶子节点,而Page11调整平衡操作的开销使得算法效率成为平摊时间复杂度.5.1.2中间结点中加入x在二叉计算树中,添加x顶点的动态更新算法是以自下而上的方式进行计算,即沿着某个叶子节点到根节点的路径进行计算.考虑从右孩子R到父节点P的路径,算法2描述了在这种情况下在P中加入x节点x^的更新操作.算法2.InsertXinR2P(msg).输入:msg消息输出:msg消息1.x^←msg.X+2.IFx^.e>YP.3.FXP←FXP+x^4.ELSEIF(msg.UX+=x^||msg.UX+∈MXr5.P节点中集合更新以及msg设置均与R节点相同6.ELSEIF/αPost(x^.e,MXr7.MXr8.ELSE9.α←MXr10.x1←minsx∈MXr11.β←MXl12.RSx^,()P←{x∈MXl13.rx←minwx∈RSx^,()P∪x14.更新相关辅助集合与msg15.RETURNmsg以下定理保证了算法2的正确性.定理3.对于从右孩子R到父节点P的情况,算法InsertXinR2P(msg)在节点P中维护了循环不变式,时间复杂度为Olog(证明.中间节点P中,MXP=MXl已知加入x^之前MXP是子图GP^=G[(XP-FXP)∪YP]中的最优X匹配集,现证明加入x^之后MXP是子图GP^=G(XP-FXP+x)∪Y配集.与叶子节点类似,若x^.e>YP.max,x^属于FXP集合.若x^.eYP.max,有两种情况下P节点中的操作与R节点相同,故可直接根据消息中的信息来计算.第1种情况是msg.UX+=x^,表明x^不能增广MXR,且在weight-id序列下,x^小于R中x^的可替换集中的最小元素.可证明若x^在孩子节点中不能增广匹配,则在父节点中也不能增广匹配,且x^的可替换集的最小元素单调递增.故而在P节点x^仍然替换x^自身,与R节点相同.第2种情况是msg.UX+∈MXr节点中x^替换x=msg.UX+,且可推知x^的可替换集在P中与R中相同,故而P节点中x^仍然替换x,与R节点相同.若上述两种情况都不满足,即msg.UX+=Λ或者msg.UX+≠x^&&msg.UX+MXr情况下,若P中存在αPostx^.e,MXr存在x∈FXL加入到图GMXr和x^之间存在一条交错路.故而根据引理3,x^不可增广MXr集.考虑若P中不存在αPostx^.e,MXr设x^在P中不可增广匹配,因为msg.UX+=Λ,即x^在R中可增广匹配,则在P中必存在x∈FXL加入到图GMXr一条交错路,根据引理3,存在α-MX紧致点i且[]Yix^.e,与前提矛盾,故而若P中不存在(x^.e,MXrαPost的分析类似.因此,通过αPostx^.e,MXrP)即可求解x1在GMXl在P中是否可增广匹配;若不可增广,根据引理3,通过MXrP]中的可替换集,并在其中取x.s最小的元素x1,Yr且可推知x1.s<YP.mid.由引理4,根据βPreMXl由2可推知,在MXlx.e>α,意味着x1在GMXl与x^的相同,于是x^在P中的可替换集RSx()^可确定.根据推论2,从RSx()^∪x^中替换weight-id序列排序下的最小元素即可求解对应于子图GP^的最优X匹配集.需注意的是,在更新相关辅助集合时,需维护不变式2.根据引理5,在算法2中,每一步的操作都可基于辅助集合对应的树结构在对数时间复杂度下实现,故而在从右孩子到父节点的情况加入x顶点的动态操作可在Olog|V(考虑从左孩子L到父节点P的路径,算法3描述了此时在P中加入x顶点x^的动态更新操作.算法3.InsertXinL2Pms()g.输入:msg消息输出:msg消息1.x^←msg.X+2.IFx^.e>YP.3.FXP←FXP+x^Page124.ELSEIFmsg.UX+=x^||msg.UX+∈MXr5.P节点中集合更新以及msg设置均与L节点相同6.ELSEIF(/βPre(x^.s,MXl7.MXl8.ELSE9.β←MXl10.x1←maxex∈MXl11.α←MXr12.x2←minsx∈MXr13.IFx2.s<β(14.β←MXl15.RSx^,()P←{x∈MXl16.rx←minwx∈RSx^,()P∪x17.更新相关辅助集合与msg18.RETURNmsg以下定理保证了算法3的正确性.定理4.对于从左孩子L到父节点P的情况,算法InsertXinL2P(msg)在节点P中维护了循环不变式,时间复杂度为Olog(证明.除了对于可替换集的求解,算法3与从右孩子到父节点的算法2情形类似.下面仅证明算法3中求解可替换集的过程.若在子图G[MXlP]中存在βPrex^.s,MXlYl集合{x∈MXl中的可替换集,选取其中end-id排序下最大的元素x1.可证明,x1.eYP.mid,且子图GMXr必然存在x1的α-MX最小紧致点.再根据引理4,通过α=MXr图G[MXrα},该集合也即x^在子图G[MXr换集.若该集合中按start-id排序下最小的元素x2的x2.s<β,即存在一条从x^出发的交错路可达小于β的y顶点,需根据x2.s更新β,进而求解出x^在P中的可替换集RSx()^.与从R到P的计算类似,更新辅助集合时需维护不变式2.根据引理5,在算法3中,每一步的操作都可基于辅助集合对应的树结构在对数时间复杂度下实现,故而在从左孩子到父节点的情况下,在节点P中,insertx()^操作的时间复杂度为Olog(5.1.3算法实例图6为一个顺次加入的x顶点的四元组信息,中间的3个方框代表二叉计算树中的树节点,节点旁边列出了相应的辅助集合.设初始状态存在4个y顶点,对应计算树中唯一的节点P.当加入第一个x顶点x1时,因为x1.s=3≠YP.min=1,P节点分裂并生成新的叶子节点L和R.算法1先尝试在R节点中加入x1,根据α树计算得出不存在x1.e的αPostx1在R中成功增广匹配,加入X匹配集MXr步,因为R是P的右孩子,调用算法2,尝试在P节点加入x1;由于P节点中同样不存在x1.e的αPost致点,故而x1增广X匹配集MXr类似的,x2,x3,x4都顺次成功加入P的X匹配集中;其中x4在节点L中进入FXL集合,因为x4.e=4>YL.max=2,再根据算法3,在P节点x4增广匹配成功.对于x5,算法1在R中尝试添加x5;根据α树计算αPostR)={x1};由于x1.w=7>x5.w=5,故而rx=x5,R中匹配未增广成功,x5被加入UXR集合.继而算法2在P节点尝试加入x5,由于msg.UX+=x^=x5,在P节点中仍然不能增广匹配,x5加入UXP集合.下面描述加入x6的过程,图6中节点P和R的辅助集合中的箭头分别指出在此过程中集合的变化情况.首先根据x6.s定位到R节点,根据算法1,在R节点加入x6成功.继而调用算法2,在P节点中加入x6.根据α树计算可得αPostx6.s,MXr侧的可替换集中找到x.s最小的x顶点x4(参考算法2第10行和图7),计算βPrex4.s,MXlPage13出可替换集RSx6,(weight-id排序最小的x顶点为x2,故而x6在P的X匹配集中替换x2.6算法复杂度分析与实验仿真在维护最优X匹配集的基础上,动态查询操作可采用文献[17]或[23]中的方法求解.我们基于文献[23]中的分离匹配区间(disjointmatchinginterval)方法,在最坏()Ok时间复杂度下求解动态查询操作,其中kminX,{算法,我们给出以下定理.定理5.左侧带权凸二分图的最大权值动态匹配问题可在Olog2(更新操作,在常数时间复杂度下查询是否匹配,在最坏()Ok时间复杂度下查询某已匹配节点的相匹配节点,其中kminX,{证明.根据定理2~4,算法中每一步操作都可基于辅助集合对应的树结构在对数时间复杂度下实现,故而在中间节点中加入x的操作在对数时间复杂度实现.加入x顶点的计算包含至多logV次加入二叉计算树中某节点的操作,因此可在O(log2|V|)平摊时间复杂度下求解.其他动态操作同理可在相同时间复杂度下进行维护.针对不带权凸二分图的最大基数动态匹配问题,文献[17]设计了一种算法在Olog2(复杂度下维护更新操作,在最坏常数时间复杂度下查询某顶点是否已匹配,查询某已匹配顶点的相匹配顶点操作的最坏时间复杂度为O(min{klog2|X|+log|X|,|X|log|X|}),其中k<min{|X|,|Y|},或者为O槡Xlog2权凸二分图的最大权值动态匹配问题之前一直未被解决,直到我们在文献[23]中提出一种方法在Olog3(坏()Ok时间复杂度下维护查询操作,其中kminX,{下面的表2中,呈现了文献[17,23]和本文的工研究问题凸二分图动态最大基数匹配动态更新Olog2(摊时间动态查询最坏接近线性时间作结果的时间复杂度比较.本文基于C++实现了左侧带权凸二分图的最大权值动态匹配算法.实验评估过程运行在一台Lenovo-X1笔记本上,其CPU型号为IntelCorei5-5200,主频2.2GHz,内存8GB,操作系统是64位Windows8,程序运行环境是VisualStudio2013.其中数据集是随机生成.图8显示了运行的结果,其中横坐标表示当前图的规模,如1000表示图中含有1000个x节点和1000个y顶点,纵坐标表示在当前规模的图上,新加入一个x节点所花的时间,单位是ms.7结论本文研究左侧带权凸二分图的最大权值动态匹配问题.发现该问题的求解的关键在于维护最优X匹配集以及求解可替换集合,提出紧致子图的概念,证明可替换集合的求解等价于紧致子图的求解,将求解匹配问题转换成为求解子图问题.同时研究凸二分图结构中的凸性质,找到一种快速求解该子图的方法.在此基础之上,基于改进的二叉计算树数据结构和隐性表征技术,设计算法在Olog2(摊时间下维护图的更新操作,在最坏线性时间复杂度下支持顶点匹配信息的查询操作.进而在与文献[17]解决不带权问题的相同时间复杂度下,解决了难度更高的左侧带权问题.
