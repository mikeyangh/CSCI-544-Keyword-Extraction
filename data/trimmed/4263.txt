Page1基于结构体随机化的内核Rootkit防御技术辛知陈惠宇韩浩茅兵谢立(南京大学软件新技术国家重点实验室南京210093)(南京大学计算机科学与技术系南京210093)摘要内核Rootkit对于操作系统来说是个严重的威胁.入侵者通过植入内核Rootkit,修改一些关键的内核结构体,实现恶意进程隐藏、日志文件删除、私密信息窃取等恶意行为.由于Rootkit主要通过篡改内核结构体对象来实现控制流截取,因此我们试图通过结构体随机化来防御这些入侵.在文中,作者提出了一种基于编译器的自动结构体随机化技术,解决了包括结构体的可随机化识别,随机化语义不变保护以及自动随机化等多个技术难题,最终利用随机环境下攻击者无法预知结构体域排列的特点,实现对内核Rootkit的防御.在实验环节,我们在被随机化的Linux系统中测试了已知的5种不同原理的8个真实的Rootkit,结果展示了我们的方法以几乎零负荷的代价防御了全部的Rootkit加载.关键词计算机安全;内核Rootkit;随机化;结构体;操作系统;网络安全;信息安全1引言Rootkit是入侵者隐藏对系统资源访问与窜改Page2威胁①.早期的Rootkit以应用级别和库级别为主,为了掩人耳目,常常篡改一些系统已有的常用审计工具[1],如ls、ps、netstat等,或者作为系统中动态链接库而存在.因而,如果系统管理员使用了一些具有高级权限的工具,例如,通过比较用户空间和内空间状态的不一致,将很容易检测到这两种Rootkit.然而这种方法却对内核Rootkit无能为力,因为它篡改的就是信息的源头,并不存在状态不一致的问题.本文针对的就是内核Rootkit.首先,由于C语言贴近底层并且代码效率高,大部分操作系统内核都由其编写完成,包括Linux、Windows等.以Linux内核源代码为例,它通过定义C语言中的结构体(Struct)来实现面向对象风格的编程②,实现包括内存管理、API调用等多种重要功能,内核结构体是内核中控制控制流的关键对象.LinuxRootkit的作者同样观察到了这一点,采用两种方式篡改内核结构体,一种是运行时的代码重写,另一种是可加载的内核模块(LoadableKernelModule,LKM).第一种方式在最新的内核(如Linux2.6)中已经被禁止而基本杜绝,因此现有的可行的注入方式只有LKM,这是Linux内核为以后方便添加驱动级别程序而预留的接口,其它操作系统中也有类似的机制.从构造原理来看,可以将它们分为以下5类③:Proc文件系统、系统调用表(SystemCallTable)、中断向量表(InterruptDescriptorTable)、DKOM(DirectKernelObjectModify)以及硬件寄存器中断(registerbreakpoint).它们的根本区别在于试图篡改不同类型的内核结构体.以Proc文件系统为例,它是内核向用户空间集中发布信息的平台,Linux平台上的很多工具都是在这里读取内核的信息,比如ls从proc_root中读取当前正在运行的进程的信息,netstat从proc_net中读取关于网络链接的信息.一旦Proc文件系统相关的结构体遭到篡改,这些信息流也会遭到劫持和篡改.现有的针对内核Rootkit的检测方法主要有:(1)加载时进行二进制分析,匹配已有的签名[2];(2)各种重要结构体的完整性检查[3-5],其中一些针对内核启动后就不再改变的静态的全局数据[5],如系统调用表与中断调用表;另一些主要针对内核在运行过程中生成的动态数据[4],如时时刻刻都在变化的与进程有关的task_struct;还有针对内核数据结构不变量的检测[3].其不足之处在于,这些检测方法大多基于重型的虚拟机,需要巨大的额外性能,而且往往只能检测针对某一类别结构体的Rootkit,但事实上内核中还有许多其它的结构体会影响到内核安全[6].基于内核结构体在内核Rootkit防御方面的重要性,本文提出了一种基于编译器的自动内核结构体随机化技术,提供一个针对内核级别Rootkit的全面的、高效的防御解决方案.简单来说,结构体随机化就是在编译时随机调整结构体中各个域(field)的排列顺序.与之前的其它随机化方法[3,7-8]相比较,结构体随机化的难点在于结构体本身是程序语义的一部分,直接的结构体随机化可能会引起原有程序的语义错误.在之前的工作中,Lin等人[9]首先研究了结构体随机化防御内核Rootkit的方法,但他们的方法存在两个明显地缺陷:(1)依赖于关键字来定义需要被随机化的结构体对象,无法做到自动化;(2)他们的方法无法保证被随机化的结构体不会破坏原有的语义.为此,我们设计了一整套结构体可随机性化分析的方案,保证我们的随机化不会干扰程序原有的语义,并且完全实现了自动化的结构体随机化.我们之前的工作[10]探讨了这种技术在恶意代码分析领域的应用,在这里我们将一步探讨针对内核Rootkit防御的情况.首先,我们收集内核中Rootkit可以篡改的结构体对象的集合.然后利用我们的分析工具分别对操作系统内核以及不同原理的Rootkit进行分析,找出它们共同使用的结构体集合作为需要随机化的目标集合,在编译过程中对其随机化.这些域的随机化方案是入侵者所不知道的,因此当入侵者编译生成自己的Rootkit时通常只能按照源代码中结构体已有的定义或自行挑选的任意域分布.然而在整个结构体域排列的随机化空间中,只有一种排列是正确的,因此当这样的Rootkit被注入到内核中并进行加载时,绝大多数情况下将以失败告终,并产生警告引起系统管理员的注意,以后的尝试也很难继续进行.经过实验证实,我们的方法成功地阻止了Linux2.6.15内核上的8个基于5种不同原理的Rootkit加载,并几乎没有增加任何额外的负荷,展①②③Page3示出了良好的防御能力与性能上的极大优势.另外,由于我们的方法基于通用的GCC编译器,因此原则上可以被应用到所有具有源代码的操作系统上,包括各种Unix系统以及移动平台.本文第2节将对结构体随机化系统做一个概述,概括描述各个部分的功能;第3节细致地讲述了可随机化分析的策略与实现,并重点说明了映射机制的建立与有技巧的随机化的原理;第4节通过实验结果展示了我们的工具在有效性以及性能上的优势;第5节系统地描述了相关工作;第6节讨论我们工作的局限性与未来的工作;最后一节给出了本文的结论.2系统描述我们的系统是编译器的一个扩展.图1是结构体随机化系统的框架,从随机化的工作流程上将系统分为3个部分:(1)目标集合TargetStructList的分析与生成;(2)可随机化的分析;(3)结构体的自动随机化.首先,假设所有Rootkit能篡改的内核结构体的集合为(R),因为新的攻击方法层出不穷,所以这个集合无法精确确定,但我们会从两个角度来构建这个集合,以求在已有条件下最大限度地解决这个问题:首先,我们会总结出已有的、已经非常普遍的5类内核Rootkit作为这个集合必备的一部分;另外,我们确保接口开放,任何新发现的、不同原理的Rootkit都可以通过我们的工具方便地提取所使用的结构体,并加入到候选集合中.我们利用StructAnalyzer这个组件对所针对Rootkit的源代码进行分析,提取出他们使用的结构体的集合为RootkitStructList(Q),同样对操作系统源代码进行分析提取出结构体的集合KernelStructList(W)然后我们提取这两个集合的交集(S),且满足RS=Q∩W,(S)就是那些Rootkit所使用的内核中的结构体的集合,即我们所针对的目标集合TargetStructList.接下来,基于这个集合,我们仍然需要对结构体的可随机化进行判断,即根据结构体在内核源代码中被声明、定义以及使用的情况,评估随机化会对语义造成的潜在的影响,我们将这些影响的情况分为3类:(1)顺序依赖访问;(2)链接一致性;(3)特殊语法.第1类问题由C语言特殊的结构体初始化以及指针算术引起,我们通过映射组件(Mapping)调整值与域的对应关系,保证初始化的正确性,但不对指针算术做随机化;第2类问题由多文件中的同一个结构体,以不同方式随机化引起,我们通过中间文件传导同一个结构体被随机化时的域排列来实现统一;针对最后一个特殊语法,我们不对其进行随机化,详细的解释见第3节.另外,被随机化的结构体的域分布将被存储在随机化排列池(RandomizationSchemePool)组件中,它主要有两方面的作用,一方面可以辅助自动随机化组件(Randomization)进行随机化;另一方面,作为所有结构体域排列的记录,它将成为以后内核中正常加载LKM驱动级别程序的不可缺少的组成部分.最后,这些分析结果将被传递给系统的自动随机化组件(Randomization),按照各自的情况分别进行处理,最大限度地完成各个结构体随机化.3设计与实现我们的所有代码均在GCC4.2.4中完成,整个GCC主要可以分为GENERIC、GIMPLE、SSA以及RTL四种中间语言.我们的代码大部分是基于GENERIC层,另有一些关于指针算术的分析是基于GIMPLE,整个工程量为大致2500行的C语言代码以及500行左右的Perl脚本.在后续部分,我们将就如何实现目标集合的提取、结构体的可随机化分析以及如何自动地进行结构体随机化展开讨论.3.1目标集合的提取为实现集合的提取,我们修改GCC中负责处理结构体生成的GENERIC函数c_parser_struct_or_union_specifier,通过它提取在编译中遇到的各种结构体,并写入到独立的文件中.将从内核与Rootkit中提取的集合做交集作为我们的目标集合.3.2可随机化分析3.2.1顺序依赖访问之结构体初始化这部分主要针对那些操作与结构体域的顺序紧Page4密相关的情况.在这些情况下,任何域的潜在的重新排序都可能引起语义错误,这样的情况包括结构体初始化与指针算术.初始化如图2情况(a),结构体变量foo1的各个域,按照声明的顺序依次赋值为a=10,b=20,c=30,在域随机化的情况下a可能图2随机化在结构体初始化中带来的问题以及解决方法图2(b)给出了这种映射的示意图,ac意味着在a原来的内存位置上现在实际存储的是c,根据箭头的格式可以同时对照右边的内存分布.从图2(c)的第3种情况可以看出,尽管在内存的分布上已经被随机化,但a,b,c仍然得到了正确的初始化值.这种映射的提供是本系统所面对的技术挑战之一,因为在具体的程序中可能会面对非常复杂的多层嵌套的情况,如图2(d)例子所示,结构体exa8嵌套了exa6以及exa7.为了应对这种复杂的情况,在设计上我们有两个选择:(1)构建一个影子栈,伴随着GCC内部对嵌套的压弹栈处理,添加自己的数据结构来跟踪随机化在多个栈帧中的调整;(2)转化多层嵌套到一个简单的值的序列.最终,我们实现了第2个方法.如图2(d)所示,我们的映射机制将1-(2-3)-(4-5-6)自动调整为1-3-2-5-6-4的序列,实现机制如算法1所示.算法1.域的映射.1.CreateTempSeq(sfield)输入:sfield为结构体2.fieldsNum=calculateFieldNum();3.Bitmap=findBitmapScheme(field.name,被赋予10,20,30中的任意一个值,图2(c)的第2种情况展示了随机化可能引起的语义错误,在这个例子中a被初始化为30,针对这种情况,我们提供域映射机制,将正确的初始化值映射到对应的域,保证语义正确.4.curNode=linkHead5.FOREACHcurNode->next&curNode->6.indexNode=curNode;7.curNode=curNode->next8.ENDFOREACH9.i=0;10.FOREACHi<fieldsNum;DO11.tempField=field;12.j=0;13.FOREACHBitmap[j]!=ido14.tempField=TREE_CHAIN(tempField);15.j=j+1;16.ENDFOREACH17.newLinkNode=newlinkNode(tempField);18.insertLinkNode(curNode,newlinkNode);19.i=i+1;20.ENDFOREACH21.indexNode=indexNode->next;22.FOREACHindexNode&&indexNode!=23.IFTREE_TYPE(indexNode->field)==24.THENCreateTempSeq(indexNode->field);Page525.ENDIF//递归子结构体算法1以随机化后结构体的第一个域field作为输入.首先,根据编译器提供的field类型名从随机化排列池(RandomizationSchemePool)中读出随机化方案Bitmap.接着根据field的chain信息可以顺序地找到该结构体下的所有的域,结合Bitmap信息,就可以对随机化后的域序列进行逆处理,将各个域随机化之前的顺序存储在以linkHead为头结点的单向链表中.最后,还需要对存在嵌套结构体的情形进行递归处理,将代表子结构体的域作为新的节点插入到嵌套子结构体之前.3.2.2顺序依赖访问之指针算术还有一类顺序依赖的情形是指针算术.结构体图3指针算术、链接一致性以及特殊语法可能造成的问题3.2.3链接一致性链接不一致的问题主要是由于同一个结构体变量可以被定义在不同模块或不同文件中,而编译时由于不在一个处理周期(compilingunit)中,所以很有可能被随机化为不同的域排列形式,当这些文件、模块链接到一起时就会发生错误.这个问题主要以2种形式出现:全局变量和全局函数参数(extern).如图3(d)中所示,我们随机化编译Bar1.c,同时正常编译Bar2.c.从呈现增长的内存地址可以看出,全局变量foo1的域排列正常,但是域值匹配错误,如b被赋予了1而不是2,a被赋予了3.为了避免这种错误的发生,我们对这些类型的结构体进行有技巧的随机化:不同文件、模块中同一个结构体全局变量或者参数按照同一种随机化排列进行编译.我们指针可以被强制类型转化,并赋给一个基本类型的指针,如(int),然后基于这个指针的偏移运算可以被用于索引这个结构体中的域,如图3(a)中的foo2所示,int类型的指针smallp得到了它的地址,希望去索引a域.从图3(b)来看,在正常的情况下,表达式smallp=1应该会让a被赋值为1,但在这个随机化例子中c被错误的赋予了1.这个问题与前面初始化的问题类似,但却不可以用同样的域映射来解决,因为当前问题本质上是别名分析(AliasAnalysis),一个不可判定问题,根据相关的程序分析理论,现有的分析技术只能提供一个候选集合,不能精确到某个具体的域.因此我们不对涉及了指针操作的结构体进行随机化.通过保持唯一一个中间文件记录每一种结构体第一次被随机化时的域排列来告知编译器,以后采用同样的排列.3.2.4特殊语法C99标准的一个特殊语法———可变数组成员,允许且只允许结构体的最后一个域是可变长数组,如图3(c)中的charc[].如果我们不加处理的进行随机化,就可能把这个只能位于末端的变长数组移动到其它位置,从而造成编译错误“error:flexiblearraymembernotatendofstruct”.因此,我们选择进行有技巧的随机化:固定最后一个域的位置且只对除之以外的域进行随机化.3.2.5可随机化分析总结表1是根据以上分析总结出的结构体可随机化Page6分析规则.在实际分析过程中,一些结构体可能同时属于表中几个类型的集合,我们在判断一个结构体是否可以随机化时按照如下的函数来进行判断:RandA(x)=其中RandA(x)表示对一个结构体x进行可随机化判断,根据x属于的不同集合,RandA(x)函数返回Y(直接随机化)、M(伴随着映射的随机化)、S(有技巧的随机化)或N(不可以随机化).顺序依赖访问(A)1.结构体初始化链接一致性(B)1.不同文件分布的符号有技巧随机化(S)特殊语法(C)变长数组成员有技巧随机化(S)3.3自动结构体随机化结构体内存的分配方式主要有堆分配、栈分配和静态存储区分配3种,但是不管是哪种分配方式,内存分配都发生在变量的声明阶段,也就是说,直观上我们看到的随机化是结构体域顺序的变化,本质上是内存上各个域所占的空间的重新调整.这种调整可以进一步被理解为域起始位置的互换.当各个域的长度不同时,就可能造成互相覆盖.假设现在存在一个结构体,它包含3个域依次为char、int和double3种类型,未进行随机化时这个结构体的内存布局如图4(a)所示,在这一内存区域中它们分别占1字节、4字节和8字节.对这个结构体进行随机化,假设随机化之后域的顺序变成int、double、char,此时的内存实际为图4(b),int域位于0到4内存段,而double位于1到9内存段,这两个域已经发生了覆盖,同样double和char两个域也发生了覆盖.我们可以看到,仅仅顺序上的调整并不能解决域之间的互相覆盖问题.鉴于以上分析,我们在随机化的过程中采用有选择的随机化方案,只对占有相同大小内存空间的域进行随机化.在此,我们要对可能出现的数据类型所占的内存空间有一个全面的了解.GCC将C语言中的类型分为5类:int、char、long等基本类型归为INTEGER_TYPE,结构体类型为RECORD_TYPE,指针类型归为POINTER_TYPE,数组类型为ARRAY_TYPE,最后Union类型为UNION_TYPE.由于指针类型、数组以及Union类型的大小难以确定,因此我们随机化的时候主要考虑除这三者之外的INTEGER_TYPE、RECORD_TYPE的两种类型的域,大部分结构体属于这个范畴.INTEGER_TYPE代表的类型涵盖了几个不同的基本类型,而这些基本类型所占的内存空间大小也是各不相同的,我们在比较2个INTEGER_TYPE时再引入该类型的一个属性TYPE_SIZE,TYPE_SIZE标识着该类型在内存中所占的空间大小.另外,对于同是结构体类型RECORD_TYPE,我们引入另外2个属性来进一步确定:一个是结构体类型的类型名字TYPE_NAME;另一个是结构体类型所含有域的数目fieldsNum.只有类型名相同而且拥有的域数目也相同的结构体才能进行随机化.算法2展示了对一个结构体进行随机化的处理过程.首先,算法根据结构体第一个域顺序将找到其他域并存储在一个tree类型的数组fieldArray中,同时计算域的数目fieldsNum.接着,createAdjList遍历fieldArray,构造一个邻接表,表头为listHead.邻接表的横向链节点保存的是fieldArray数组中具有相同类型(占内存空间相同)的域,纵向链表邻接的是每个横向链表的第一个节点.邻接表构造完成后,算法分别遍历邻接表的每个横向链表,计算出相同类型域的数目rowFieldsNum,随机数序列生成函数根据rowFieldsNum产生随机排列的0到rowFieldsNum-1的自然数,作为横向链表上域的随机策略rowBitmap,并结合邻接表节点的属性index将子随机化策略反映到整个域的随机化策略bitmap上,所有横向链表遍历完成后,bitmap也构造完成了,算法根据bitmap随机化策略对结构体的域进行中排序,即完成随机化.Page7算法2.自动随机化.ReverseBySet(name,field)输入:name是结构体的名称1.fieldsNum=0;2.FOREACHt=fieldDO3.fieldArray[fieldsNum]=t;4.t=TREE_CHAIN(t);5.ENDFOREACH6.IFreadSameType(schemeFile,name)!=1THEN7.createAdjList(fieldArray,listHead);8.t=listHead;9.FOREACHt!=NULLDO10.tNode=t;11.FOREACHtNode=tNode->rowNext;DO12.nodeArray[rowFieldsNum]=tNode;13.rowFieldsNum=rowFieldsNum+1;14.ENDFOREACH//生成随机化排列rowBitmap15.rowBitmap=bitmapGen(rowFieldsNum);16.i=0;17.FOREACHi<rowFieldsNumDO18.//根据随机化排列调整各个域的排列进行19.bitmap[nodeArray[rowBitmap[i]]->20.i=i+1;21.ENDFOREACH22.ENDFOREACH23.ENDIF24.j=0;25.FOREACHj<fieldsNum-1do表2可随机化分析目标集合7845Rootkit结构体类型总数防御效果Adore-ng0.56表3Rootkit测试结果Int3HookEnyelkm-1.3KbdvSynapsys-0.4TaskigtDRProc文件系统26.TREE_CHAIN(fieldArray[bitmap[j]])=27.j=j+1;28.ENDFOREACH4实验我们使用8个具有代表性的Rootkit来验证系统的有效性与性能,它们分别基于5种不同的原理,包括修改Proc文件系统[8,11]、DKOM[15]、基于硬件断点[12]、系统调用表[13]以及修改中断描述符表[10].实验结果显示这些Rootkit在随机化的内核上都无法正常加载和运行,成功实现了防御.实验的平台配置为Ubuntu6.06,测试Linux内核为2.6.15,运行的平台是Inter(R)Core(M)2DuoCPUE84003.00GHz以及512MBRAM.我们将分3个部分展示实现结果,首先是可随机性分析,然后是Rootkit防御的有效性,最后是系统性能.4.1Rootkit可随机化分析测试根据前面的可随机化分析的规则,我们总结了实验过程中的目标集合的数量以及经过可随机化分析筛选后,仍然被随机化的数量.经统计,Linux2.6.15内核中结构体类型,即KernelStructList(W),共为8850种.另外,5个类型8个Rootkit分别含有的结构体的类型数可以在表3第2列“结构体类型总数”中查到,我们将这些结构体做一个并集一共得到462种结构体,即RootkitStructList(Q).最后我们通过计算S=Q∩W,得到的目标集合(TargetStructList(S))共为78种,亦表明其中有384种结构体是Rootkit自定义的,对篡改内核制流没有影响.如表2有45种类型有结构体初始化的情况,需要做映射;有68种链接一致性(B)DKOMDKOMPage8结构体出现类型转换与指针算术问题,无法被随机化.套用我们在前面3.2.5小节定义出来的筛选规律,最后我们得到结论,有10种结构体可以被安全地编译用于防御Rootkit的Linux内核.4.2Rootkit防御有效性测试基于前面的分析,我们安全地随机化了Linux内核,并用这个内核进行了防御Rootkit的有效性实验.表3展示了防御效果,并且进一步给出了引起这些Rootkit失败的关键结构体名以及关键的变量名.下面我们就这几个例子做一些深入的探讨.Adore-ng0.56①是一个具有代表性的VirtualFileSystem相关的Rootkit.Proc文件系统中包含了很多系统信息,比如说proc目录下可以看到pid信息,子目录net下可以看到系统当前的网络连接状态等等.一些管理员工具(如ps、netstat等)都是直接从该目录下查看系统实时运行状况的.Linux2.6.15内核是通过结构体变量proc_root来访问该目录的,因而Adore-ng通过篡改proc_root中的文件操作函数集proc_iops达到隐藏指定进程、网络端口等目的.但是,经过随机化处理后,我们内核中proc_root结构体类型对象proc_dir_entry中域的排列已经发生了变化,引发Adore-ng加载失败,不仅防止了这次攻击,还通过触发syslog的记录通知了管理员.Taskigt②的情况同理.与Adore-ng不同,Enyelkm③是通过对系统调用进行篡改来劫持系统控制流的.Enyelkm通过在系统符号表中匹配特殊的字符串来定位系统调用表在内存中的地址.一些系统调用常常是实现ls、ps等命令的关键,如getdents64、read、write等,Enyelkm正是通过篡改这些系统调用来执行恶意代码的.由于系统调用表是以数组的形式存在于内存中的,而我们的随机化目前还不能直接针对系统调用表这样的数组类型进行随机化.但特别要指出的是,我们的方法对Enyelkm仍然有效,虽然我们的方法目前并不能随机化系统调用表这样的数组,但经过实验我们发现Enyelkm用到了一个名为mod-ule的结构体,这个结构体与加载直接相关,攻击者不可以省略,而我们正是通过随机化这个结构体最终达到了防御系统调用表型Rootkit的目的.这也是Synapsys0.4④、Int3Hook⑤(中断描述符类型)以及DR⑥(硬件断点类型)加载失败的原因.HP⑦(hideprocess)是一类DKOMRootkit的代表,在Linux系统中,各个进程的进程描述符是通过一个双向链表组织起来的,每个节点都是task_struct类型的描述符变量,该结构体中包含一个list_head类型的tasks字段,这个类型的prev和next分别指向前面和后面的task_strcut节点.HP正是利用这个宏在加载模块时将指定进程描述符从链表中删除,从而达到隐藏进程的效果.而我们的系统能够对task_struct结构体进行随机化,调用宏时将索引到不可预知的域中,从而起到防御这种Rootkit的功能.Kbdv的情况与之类似.4.3性能测试我们使用UnixBench-4⑧作为Benchmark全面地测试内核的性能,以观察结构体随机化对内核运行产生的性能影响.如表4所示,UnixBench进行了包括算术运算、进程创建、文件拷贝、系统调用负荷等11项测试任务,并最终给出一个得分(FinalScore)做了对性能的整体评价,得分越高说明系统性能越好.我们分别3次编译了正常与随机化Linux2.6.15内核,并在每个内核上都进行了3次性能测试.就实验数据的平均值来看,正常的内核的性能与随机化内核性能基本一致.从原理上来说,结构体的随机化只是调整了各个域在内存中的分布,改变了相关指令的偏移,几乎不会为系统运行带来任何额外的性能损耗,实验结果符合这种判断.另外,虽然我们的方法在编译上会多花少许时间,但针对这个问题来说,编译的时间并不重要.因此可以说我们的方法是极其高效的.5相关工作5.1Rootkit防御Rootkit的防御工作主要从分析、检测以及预防3个方面展开.Rootkit分析专注于理解其运作机制,包括恶意操作指令[11],钩子函数[14]以及对内核数据的修改操作[15].Rootkit检测的方法主要包括:(1)加载时的二进制分析[2];(2)完整性检查,包括①②③④⑤⑥⑦⑧Page9表4UnixBench性能测试内核类别第1次编译645.3642.6640.3642.7627.9650.2640.1639.4第2次编译644.2646.1643.4644.5642.5641.1646.0643.2第3次编译638.7639.8641.2639.9640.4638.6643.5640.8最终平均静态数据完整性[4,16-17]、动态数据完整性[5,12]或针对一些关键的内核数据结构不变量的检测[3].Rootkit预防方法有监控执行中的异常情况[18-20],防止Rootkit代码在内核态中执行.然而,上面提及的方法都有其自身的缺陷:分析的方法有助于更好地理解Rootkit但不能起到防御的作用;检测方法需要巨大的系统额外损耗,而且只能检测已知的、针对特定结构体的Rootkit;预防的方法也存在监控系统负荷过大的问题,另外采用代码重用技术的Rootkit[21]甚至可以避开这种预防.与这些方法相比,我们的工作不针对特定方法入侵的Rootkit,对所有篡改内核结构体的Rootkit都具有良好的防御效果,并且在性能上存在优势.5.2随机化技术随机化技术是一种增加程序可靠性的可行方案,Collberg[22]已经描述过各种不同的随机化方案,地址随机化[8]引入了内存地址空间布局的多样性,破除了内存侵蚀攻击所需的内存先验知识;指令随机化[7]首先对指令进行加密并在指令执行之前对其进行解密,因此外来注入的指令由于没有经过加密,将在解密时出现错误;操作系统随机化[13]对系统API和库函数的位置进行重新分布,攻击者如果希望通过return-to-libc攻击来重用这些库函数时将会发生错误.Lin等人[9]在结构体随机化方面做出了第一个尝试,但是这个工作的不足也很明显:必须对要随机化的结构体进行手动标注,而且不能解决那些可能出现语义错误的情况,而我们的工作很好的解决了这两个问题.6局限性与未来的工作我们的工作仍然存在一定的局限性,主要表现在随机化的粒度与随机化集合的大小.目前我们只采用的是“域重排序”的随机化方法,下一阶段我们可以继续探索垃圾域的插入、结构体拆分等手段进一步增强随机化的空间,使猜测攻击更加难以奏效;另外,我们当前进行随机化的目标集合仍然是全部内核结构体的一个子集,但Rootkit作者正不断地尝试着利用新的结构体对内核造成伤害[6],因而我们希望能够让被随机化的结构体空间扩大到全体内核结构体,实现对已知和未知结构体的全面防御.7结论本文中,我们提出了一个新的基于结构体随机化的内核Rootkit防御技术,作为常用编译器GCC的一个扩展而实现.我们的系统可以自动地完成可随机化分析,区分哪些适合直接做随机化,哪些适合做有技巧的随机化,哪些需要域的映射以及哪些根本不适合做随机化,在这样完善的可随机分析的基础上自动完成结构体随机化.实验表明,随机化后的Linux内核对8个基于5种不同原理的Rootkit进行了有效的防御,并几乎没有为内核的运行增加额外的损耗.致谢我的老师茅兵教授对我进行了指导,在此表示感谢!
