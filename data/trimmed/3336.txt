Page1体系结构层状态型方面的建模和编织———基于LTS的方法杨春花1),2)王海洋1)1)(山东大学计算机科学与技术学院济南250100)2)(山东轻工业学院信息科学与技术学院济南250353)摘要状态型方面是一种封装反应式关注点的方面,它需要专门的切点机制来跟踪系统的执行历史.然而当前在体系结构层还缺乏支持状态型方面建模的有效机制.针对这一问题,提出一种体系结构层状态型方面的建模和编织方法.它以标记转换系统(LabelledTransitionSystem,LTS)为底层形式化,建立了用于识别系统运行轨迹中特定模式的切点机制,并定义了支持多种通知类型的编织运算.该方法当前已在一个基于FSP规范的原型编织工具上实现,并用一个实例说明了该方法的有效性.关键词方面;状态型方面;编织;标记转换系统;面向方面的软件开发1引言面向方面的软件开发(Aspect-OrientedSoftwarePage2状态型方面(statefulaspects)[1]是这样一类方面:其通知的触发条件不是单个的关联点,而是一组关联点的序列.换言之,该类方面的触发执行依赖于系统的计算历史.例如,某个额外的行为需要在执行一组事件后执行就是一个典型的状态型方面.本质上说,状态型方面封装的是反应式(reactive)的关注点[2].这类关注点是软件设计和编程经常需要面临的一类关注点,它们强烈地依赖于系统的运行历史.而由于基本系统(thebasesystem)一般提供基于过程的、面向对象的或基于组件的分解,并没有提供合适的表示和实现反应式系统的抽象形式[2],造成这类关注点不能有效地模块化.与常规的方面相比,状态型方面需要专门的切点机制来跟踪系统的执行历史和确定通知的触发点.当前,在代码层已经提出许多支持状态型方面编程的方法,典型的如EAOP[1]、JAsCo[3]、DEP(Declar-ativeEventPatterns)[4]等.这些方法采用基于有限状态机的切点机制对程序运行历史中的特定事件模式进行识别,当模式识别后,通知的代码被激发.然而在体系结构层,当前提出的面向方面的建模方法,如DAOP/ADL[5]、ABC/ADL[6]、AAM方法[7]、PRISMA[8]等,仅关注于常规方面的建模和编织,并没有提供支持状态型方面建模的有效机制.针对上述问题,吸取代码层状态型方面建模的某些思想,提出了一种体系结构层状态型方面建模和编织的方法.它采用标记转换系统(LabelledTransitionSystem,LTS)[9]为底层形式化,建立了识别系统运行迹中特定模式的切点机制,定义了支持多种通知类型的编织运算.该方法已在一个原型编织工具———LTSbAW①上获得实现.本文第2节给出方法原理;第3节是方法的实现和实例研究;第4节分析相关工作;第5节是结束语.2基于LTS的状态型方面的建模和编织考虑图1所示的一个国际旅行社代理例子[10].该代理可以为其分支机构提供检索旅行目的地信息(queryInfo)以及订购旅行项目(book)的服务.为激励其分支机构提高业绩,该代理制定一项奖励措施:若在使用这些服务后最终订购了(book)一个旅行项目,将得到一个奖励(bonus).奖励是一个方面,而且其是否应用依赖于系统执行轨迹.例如,若某次执行的轨迹为login,queryInfo,queryInfo,queryInfo,logout,则奖励方面不能应用;反之,若运行轨迹中含有book动作时,如login,queryInfo,book,queryInfo,logout可应用.因此,奖励是一个状态型方面.标记转换系统(LabelledTransitionSystem,LTS)[9]是建模和分析体系结构行为的常用形式化,本文以LTS为基础进行了适当扩展,建立了支持状态型方面建模的切点机制,并定义了相应的编织运算.下面首先介绍LTS的相关概念,然后详细阐述本文方法.2.1LTS相关概念念,其定义如下:本文采用文献[11-12]中给出的LTS的相关概设States是一个状态全集,Labels是一个动作标记的全集.定义1.一个标记转换系统(LabelledTransi-tionSystem,LTS)P是一个四元组(S,L,T,sinit),其中,SStates是一个有限的状态集,LLabels是一个有限的标记集,T(S×L×S)是一个状态间的标记转换关系,sinit∈S是初始状态.一个LTSP=(S,L,T,sinit),对s∈S,若可以通过转换(s,,s)∈T到达状态s,则称P从状态s经过一步执行到达状态s,记为s→s.设σ=1,…,k(k0)是集合L上一个标记序列,用s→σs表示存在s0,…,sk使得s=s0,s=sk,和si→i+1si+1(0i<k).用s→σ表示s∈S·s→σs;并用s→表示∈L,s∈S·s→s.一个LTS的语义是从其初始状态开始可以执行的标记序列的集合.定义2(运行迹,trace).已知LTSP=(S,L,T,sinit),π=1,…,k(0k)是集合L上一个标记序列,若s∈S·sinit→πs,则π是P的一个运行迹(trace).①Beavailableat:http://code.google.com/p/ltsaspectweav-ing/downloads/listPage3定义3(强模拟等价,strongbisimulationequiv-alence).已知两个LTSP=(SP,LP,TP,sinitP)和Q=(SQ,LQ,TQ,sinitQ)且LP=LQ,P和Q是强模拟等价的,如果(SP,SQ)被包含进某个模拟关系RSP×SQ,该关系对任意的∈LP,sp∈SP,sq∈Sq,有下式成立:(1)((sp,sq)∈R)∧(sp→sp)(sq∈Sq·sq→sq∧(sp,sq)∈R).(2)((sp,sq)∈R)∧(sq→sq)(sp∈Sp·sp→sp∧(sp,sq)∈R).强模拟等价记为P~Q.定义4(并发组合,parallelcomposition).已知两个LTSP=(SP,LP,TP,sinitP)和Q=(SQ,LQ,TQ,sinitQ),并发组合(‖)是一个操作符且P‖Q是LTS(SP×SQ,LP∪LQ,T,(sinitP,sinitQ)),其中T((SP×SQ)×(LP∪LQ)×(SP×SQ))由图2所示规则导出.2.2基本系统定义本文将封装业务关注点的系统称为基本系统(thebasesystem).基本系统由组件构成,其相关定义如下.定义5(组件,component).一个组件是一个LTSe=(S,L,T,sinit),其中L是其与外部环境进行交互的通信动作集.组件通过通信动作与外部环境进行交互,而组件之间通过共享的通信动作进行交互,交互遵循LTS之间的并发组合(‖)规则.定义6(基本系统,thebasesystem).一个基本系统PB是n个组件e1,…,en的并发组合:PB=(e1‖…‖en)(n∈N).性:确定性和进展性.定义7(确定性).一个LTSP=(S,L,T,sinit)是确定的(deterministic)当且仅当∈L·((s,,s1)∈T∧(s,,s2)∈T(s1=s2)).定义8(进展性).一个LTSP=(S,L,T,sinit)是可进展的(progressive)当且仅当s∈S.(sinit→s)(s→).一个合理的基本系统应当满足如下的语义特定义9(良定义的,well-defined).如果一个LTS是确定的和可进展的,则称该LTS是良定义的.2.3基于犳LTS的切点机制状态型方面的切点根据基本系统的运行轨迹来确定通知的触发点-关联点.本文对LTS概念进行扩展,提出了fLTS概念和扩展的并发组合运算(∝),并以此为基础,给出了切点的定义.定义10.一个fLTS是一个五元组P=(S,L,T,f,sinit),其中,(S,L,T,sinit)是一个LTS,f:T→{0,1}是一个函数.fLTS中的函数f是一个关联点标记函数.给定转换t,若f(t)=1,则该转换被标记以关联点,也就是通知的触发点.对于一个fLTSP=(S,L,T,f,sinit),定义一个辅助一元运算获得其LTS:(P)=(S,L,T,sinit).另外,定义一个扩展的并发组合操作(∝)实现对一个LTS和fLTS的并发组合.定义11(扩展的并发组合,extendedparallelcomposition).已知一个LTSP=(SP,LP,TP,sinitP),和一个fLTSQ=(SQ,LQ,TQ,fQ,sinitQ),则扩展的并发组合(∝)是一个操作符且P∝Q是fLTS(SP×SQ,LP∪LQ,TPQ,fPQ,(sinitP,sinitQ)),其中TPQ((SP×SQ)×(LP∪LQ)×(SP×SQ))和fPQ:TPQ→{0,1}是由图3所示规则导出的.定义12(切点,pointcut).已知一个基本系统PB=(SB,LB,TB,sinitB),PB上的切点(pointcut)是一个满足下列条件的fLTSPpc=(Spc,Lpc,Tpc,fpc,sinitpc):(1)(Ppc)是良定义的;(2)LpcLB;(3)(PB∝Ppc)~PB.其中,条件1保证切点fLTS的特性;条件2保证切点跟踪基本系统的trace,没有额外的通信动作;条件3保证切点是基本系统的观察者,它和基本系统组合后得到的LTS和基本系统语义等价,不改变基本系统的行为.Page4依据定义12,并吸取EAOP[1]中事件模式的思想,下面给出基本系统运行迹模式的概念(定义13)以及根据此模式来获取切点的具体方法(定义14和定理1).定义13(运行迹模式).已知基本系统PB=(SB,LB,TB,sinitB),若si,si,s∈S,i∈L∧(αi∈L∧αi≠i)(1in)使得sinitB→α1s1→1s1→α2s2→2s2…→αnsn→ns成立,则称12…n为基于PB的运行迹的模式,其中→αi表示连续经过若干个标记αi的转换.定义14(识别运行迹模式的fLTS).已知12…n为基于基本系统PB=(SB,LB,TB,sinitB)的运行迹的模式,则Pp=(Sp,Lp,Tp,fp,sinitp)是一个识别模式12…n的fLTS,其中Lp=LB,Sp={sinitp,s1,s2,…,sn-1},Tp={(sinitp,1,s1),(s1,2,s2),…,fp:TP→{0,1}满足(tp=(sp,p,sp)∈Tp∧sp≠sp∧fp(tp)=1)∧(t∈Tp-{tp}∧fp(t)=0).定理1.识别基本系统PB运行轨迹模式的证明.设12…n为基于基本系统PB=(SB,LB,TB,sinitB)的运行轨迹的模式,fLTSPp=(Sp,Lp,Tp,fp,sinitp)是识别模式12…n的fLTS.fLTS是PB上的切点.由定义14,容易得出设(PB∝Pp)=(SBp,LBp,TBp,sinitBp),并定义关系R={〈(sB,sP),sB〉|(sB,sP)∈SBp,sB∈SB,sP∈SP}SBp×SB,则对〈(sB,sP),sB〉∈R,有下列式(2)、(3)成立:对(sB,sP)→l(sB,sP)∈TBp,则必然sB∈SB使得sB→lsB∈TB,根据R定义知〈(sB,sP),sB〉∈R;对sB→lsB∈TB,根据定义14,必然sP∈SP,使得sP→lsP∈Tp,则(sB,sP)→l(sB,sP)∈TBp,且根据R定义知〈(sB,sP),sB〉∈R.根据~定义和式(2)、(3),得根据定义12和式(1)、(4),得Pp为PB上的切点.以图1所示基本系统为例,booklogout是其运行迹模式,图4是识别该模式的fLTS,其中1logout/→JP0表示转换1log→out0的f函数值为1,而其余转换的f函数值都为0.则根据定理1,该fLTS是奖励方面的切点.图4中每个状态上的环状转换在ConcurrentEAOP[13]中称为等待环(waitloops).2.4通知和方面定义一个通知可以是一个观察者,它仅在特定事件发生后插入额外的动作而不改变基本系统的运行轨迹;也可以是一个辅助者,使得基本系统转到另外的状态[14].观察者的例子有tracing,debugging,logging[15]等,而辅助者方面如存取控制[7]、恢复方面[16]等.令WT={bef-seq,aft-seq,choice,bef-branch,aft-branch,bypass,replace}是一个预定义的通知类型的集合.其中,顺序型(bef-seq和aft-seq)通知插入到关联点之前或之后;选择型(choice)通知在关联点被激发,并使基本系统转向一个特定状态;分支型(bef-branch和aft-branch)通知在关联点被激发,并有条件地使系统转向一个特定状态;旁路型(bypass)通知在关联点对应的源状态和目的状态之间加入通知;而替换型(replace)通知替换原有的关联点.定义15(通知,advices).一个通知(advice)是一个元组Ad=(type,S,L,T,sinit,Sfinal),其中type∈WT是通知的类型,(S,L,T,sinit,Sfinal)是一个描述通知行为的扩展LTS.Sfinal={s|s∈S∧s∈S·(s,a,s)∈T}是一个终结状态集,且当类型type=[bef-seq,aft-seq,bypass,replace,choice]时|Sfinal|=1,而当类型type=[bef-branch,aft-branch]时|Sfinal|=2.另外,(S,L,T,sinit,Sfinal)是确定的且除了终结状态之外的所有状态都是可进展的.Page5定义16(方面元素,aspectlet).一个方面元素(aspectlet)是一个元组(Ppc,π,Pad),其中Ppc是切点,Pad是通知,π是基本系统的一个trace,用来标识一个特定的状态,且当Pad.type=[bef-seq,aft-seq,bypass,replace]时,π为空;否则非空.定义17(方面,aspects).一个方面是一个方面元素的集合A={e|e是一个方面元素}.2.5方面编织切点和基本系统的组合(∝)得到一个和基本系统等价的fLTS,其所有关联点都已确定,可以织入通知.对于一个fLTSP=(S,L,T,f,sinit),定义辅助运算select(P)获得其关联点集合:另外,已知两个状态集合S1和S2含有互相区分的状态,定义一个Union函数返回S1和S2的合并状态集:Union(S1,S2,{s11→s21,…,s1n→s2n})={s|({s11,…,s1n}S1∧{s21,…,s2n}S2)∧(s=s1∧s1∈S1-{s11,…,s1n})∧(s=s2∧s2∈S2)∧(s=s2x∧s1x∈{s11,…,s1n}∧x∈{1,…,n})}.首先,定义一个微运算,将通知插入到一个fLTS的某个关联点.定义18.已知一个fLTSPM=(SM,LM,TM,fM,sinitM),一个关联点tjp=(sjp,jp,sjp)∈select(PM),一个通知PAd=(typead,Sad,Lad,Tad,sinitad,Sfinalad),一个traceπ.令sjp是π确定的状态:PM→πsjp.则运算在tjp处织入PAd并返回一个fLTS:PM(tjp,π,Ad)=(SC,LC,TC,fC,sinitC),其中,LC=LM∪Lad;fC(t)=fM(t),t∈TM,sinitC=sinitM;SC和TC的取值依赖于通知PAd的类型:(1)若typead=bef-seq,则SC=Union(Sad,SM,{sinitad→sjp});TC=(TM-{tjp})∪Tad∪{(sadfinal,jp,sjp)},(2)若typead=aft-seq,则SC=Union(Sad,SM,{sadfinal→sjp});TC=(TM-{tjp})∪{(sjp,jp,sinitad)}∪Tad,(3)若typead=bypass,则SC=Union(Sad,SM,{sinitad→sjp,sadfinal→sjp}),其中sadfinal∈Sfinalad;其中sadfinal∈Sfinalad;其中sadfinal∈Sfinalad;其中sadfinal1,sadfinal2∈Sfinalad;其中sadfinal1,sadfina12∈Sfinalad;其中sadfinal∈Sfinalad;TC=TM∪Tad.(4)若typead=replace,则SC=Union(Sad,SM,{sinitad→sjp,sadfinal→sjp}),TC=(TM-{tjp})∪Tad.(5)若typead=choice,则SC=Union(Sad,SM,{sinitad→sjp,sadfinal→sjp}),其中sadfinal∈Sfinalad;TC=TM∪Tad;(6)若typead=bef-branch,则SC=Union(Sad,SM,{sinitad→sjp,sadfinal2→sjp});TC=(TM-{tjp})∪Tad∪{(sadfinal1,jp,sjp)},(7)若typead=aft-branch,则SC=Union(Sad,SM,{sadfinal1→sjp,sadfinal2→sjp}),TC=(TM-{tjp})∪{(sjp,jp,sinitad)}∪Tad.令函数clone(Ad)返回一个通知Ad的克隆,且约定每次克隆得到的克隆通知都具有不同的状态名,而且克隆通知的状态名和动作名与基本系统的相区别.一个方面元素的编织就是利用微运算,将其克隆通知插入到基本系统和切点组合得到的fLTS的所有关联点的过程.定义19.已知一个方面元素AL=(Ppc,π,Pad)和一个基本系统LTSPB=(SB,LB,TB,sinitB),则运算∠AL将AL织入PB,得到一个LTS:PB∠ALAL=(…((PB∝Ppc)(tjp1,π,clone(Pad))(tjp2,π,clone(Pad)))…(tjpn,π,clone(Pad))),其中,select(PB∝Ppc)={tjp1,…,tjpn}(n1).而方面的编织就是逐个织入其方面元素的过程.定义20.已知一个基本系统PB和一个方面A={AL1,…,ALn}(n1),则运算∠将方面A织入PB,得到一个LTS:PB∠A=(…(PB∠ALAL1)…∠ALALn).编织前,对基本系统的特性进行了一定限制,下面的定理2说明编织后得到的系统仍然保持这种特性.定理2(确定性和可进展性的保持).设一个良定义的基本系统PB和一个方面A,则PB∠A也是良定义的.方面编织可能会对基本系统产生各种影响.人们一般期望两个基本系统P1和P2是语义等价的,则应用一个方面到P1和P2的结果(语义上来讲)也Page6是等价的[16].本文用LTS之间的强模拟等价关系表示这种语义等价关系.下面的定理3说明编织后得到的系统仍然保持这种特性.定理3(语义等价性的保持).给定两个基本系统P1和P2,一个方面A可应用到P1和P2,则P1~P2P1∠A~P2∠A.定理2和定理3的证明见附录.从以上两个定理看出,方面编织运算∠保持了系统的确定性、可进展性和语义等价性.也就是说,编织后的系统和编织前的系统一样,可以参与进一步的并发组合(‖)运算或编织运算(∠).因此,编织运算∠可以看成是与并发组合(‖)相对应的一种新运算符,编织运算∠支持LTS和方面的组合,而并发组合(‖)支持LTS和LTS的组合.3实例研究3.1实现我们开发了一个基于FSP(FiniteStateProces-ses)[17]的原型编织工具———LTSbAW,实现本文的方法.FSP是一种进程代数风格的语言,支持LTS建模.在FSP中,一个进程P对应了一个LTS,该进程及其局部进程构成了该LTS的状态集,而P是该LTS的起始状态.例如,图5是图1所示基本系统的FSP描述.进程B由局部进程B1构成,(“->”)和(“|”)是动作前缀和选择操作符.B=(login->B1),B1=(book->B1|queryInfo->B1|logout->B).LTSbAW在FSP规范的基础上进行扩展,支持方面描述.图6是LTSbAW支持的Bonus方面的描述.其中,Aspect是保留字,Bonus是方面的标识.A1是一个方面元素,PC和AD分别是其切点和通知,BeforeSeq代表AD的类型Bef-Seq.进程PC描述了图4所示的fLTS.注意,在PC的描述中,其所有的等待环(waitLoops)由LTSbAW动生成.将基本系统和方面规范输入LTSbAW后,可得到编织后的组合系统描述,它仍然满足FSP规范,可在支持FSP语法的工具———LTSA[17]上进行模型展示和分析.图7是将图5和图6的规范输入LTSbAW后得到的组合系统描述,而图8是其在LTSA中的展示结果,从中可以清晰地看出Bonus编织后系统的行为.B_PC=(login->B1_PC),B1_PC=(logout->B_PC|queryInfo->B1_PC|book->B1_PC1=(book->B1_PC1|queryInfo->B1_PC1|bonus->AD_1_New1=(logout->B_PC).图8Bonus方面编织后系统在LTSA中展示3.2实例分析下面以我们建立的一个电子商务系统为例说明本文方法的应用以及与其它方法的分析比较结果.该系统实现顾客网上购物功能,图9是其基本系统描述.它通过4个组件的交互实现系统的业务功能:顾客(Customer)、商店(Shop)、支付中心(PaymentCenter)和商品发送中心(DeliveryCenter).顾客在登录(login)系统后,可以浏览商品(browse-Products),浏览促销广告(browsePromotions),确认收货(confirmDelivery),申请退款(refund),加入购物车(addToCart),然后可通过购买(buy),确认订单(confirmOrder)和确认付款(confirmPayment)后完成一次购买过程.支付中心在顾客确认付款后接收顾客付款,然后在发送商品成功(deliverySuccess)和顾客确认收货(confirmDelivery)后付款给商店或在发送商品失败(deliveryFail)和顾客申请退款(refund)时退款给顾客.该系统需要面临3种方面需求:(1)顾客对促销广告的敏感度评定.根据顾客进入系统后的行为轨迹评定其对促销广告的敏感程度:高敏感度顾客,进入系统后首先浏览促销广告,Page7然后进行其它操作;中等敏感度顾客,进入系统后首先浏览商品,然后浏览促销广告;不敏感顾客,从不浏览促销广告.(2)订单日志.每当顾客确认订单或取消订单||ECommerceSys=(Customer||PaymentCenter||DeliveryCenter||Shop).图9电子商务系统的基本系统描述根据上述方面需求,采用本文的方法对方面进行建模,得到如图10所描述的5个方面.其中Highpromotionpronecustomer,Mediumpromotion-pronecustomer和Promotioninsensitivecustomer用于实现需求R1.以Highpromotionpronecustomer为例.其切点PC用于跟踪高敏感度顾客的执行LogOrder和TimeLimits方面分别实现需求(2)和(3).LogOrder方面用切点PC标识动作con-图10各方面描述时,记录日志.(3)付款限时.从发送商品成功到顾客确认收货需要时间限制,超过时间限制且客户还未确认收货时,系统自动付款给商家.轨迹:首先执行login进入状态PC1,然后执行browsePromotions进入状态PC2,在状态PC2可以执行其它动作,最后通过logout退出系统,此时触发通知.若在状态PC2执行了除browsePromo-tions之外的其它动作,则转回到状态PC.AspectPromotioninsensitivecustomer{DEFA1=〈BeforeSeq,PC,AD〉PC=(login->PC1|browsePromotions->PC),PC1=(browsePromotions->PC|browseProducts->PC2|addToCart->PC2|buy->PC2|logout->PC2|login->PC2|browseCart->PC2|confirmDelivery->PC2|refund->PC2|browse->PC2|editCart->PC2|backToCart->PC2|confirmOrder->PC2|confirmPayment->PC2|cancelOrder->PC2),PC2=(logout/JP->PC|browsePromotions->PC).AD=(promotioninsensitivecustomer->EndAD).}AspectLogOrder{DEFA1=〈AfterSeq,PC,AD〉PC=(confirmOrder/JP->PC|cancelOrder/JP->PC).AD=(logOrder->EndAD).}AspectTimeLimits{DEFA1=〈AfterSeq,PC1,AD1>PC1=(deliverySuccess/JP->PC1).AD1=(starttimer->EndAD1).PC2=(confirmDelivery/JP->PC2).AD2=(timeout->EndAD2).DEFA2=〈Bypass,PC2,AD2〉}firmOrder和cancelOrder为关联点,并在其后顺序织入通知AD,记录日志.TimeLimits方面含有A1Page8和A2两个方面元素,前者在关联点deliverySuccess之后,顺序织入通知AD1,用于启动定时器(start-timer);而后者在关联点confirmDelivery织入一个旁路型通知AD2,用于限时(timeout).由于各方面编织后得到的组合系统状态数较多,限于篇幅,没有列出.通过对编织结果进行分析,它们都满足相应的方面需求.EAOP[1]是一种典型的状态型方面编程方法,其ConcurrentEAOP[13]模型通过在并发组合的基本系统和方面中添加同步事件来实现方面编织.表1本文方法与CurrentEAOP方法的比较结果CurrentEAOP可否建模组合系统状态数HighpromotionpronecustomerMediumpromotionpronecustomerPromotioninsensitivecustomerLogOrderTimeLimitsConsistency由于基于的底层机制不同,很难将本文方法与其余体系结构层的面向方面建模方法进行实现对比.我们分析了AAM[7]、DAOP/ADL[5]、ABC/ADL[6]、AO-ADL[18]等几个典型方法对上述实例中5个方面的支持能力.前3个顾客促销广告敏感度方面是状态型方面,由于这些建模方法没有提供相应的跟踪系统执行轨迹的切点机制,因此很难对它们建模.LogOrder和TimeLimits方面的切点依赖于系统的单个动作,这在上述这些方法中都能找到相应的支持机制.从通知类型上看,LogOrder方面的为AfterSeq,这在ABC/ADL和AO-ADL中可以用After通知类型来实现,在DAOP/ADL可以用OutputAspects来实现,在AAM中可以用组合指令实现.TimeLimits方面的通知类型为Bypass,这在DAOP/ADL可以用eventaspects来实现,在AAM中可以用组合指令实现,而在ABC/ADL和AO-ADL中没有找到相应的支持机制.通过对上述实例的研究可以看出:本文方法可以有效地建模状态型方面和常规方面,而且支持比其它建模方法更丰富的通知类型.由于编织后组合系统的状态数较少,将给以后在组合模型上的分析工作带来效率方面的优势.3.3讨论该方法不仅适用于状态型方面,而且支持常规ConcurrentEAOP也采用FSP描述,因此可以和本文方法进行实现对比.基于上述电子商务系统实例中的5个方面以及ConcurrentEAOP中的Consistency方面[13],用本文的方法和ConcurrentEAOP方法进行了分别实现,表1是两种实现的对比分析结果.可以看出,本文方法方面编织得到的组合系统的状态数远远少于ConcurrentEAOP,而且提供了比ConcurrentEAOP更强的方面建模能力.51673552523510方面的建模和编织.已知基本系统PB=(SB,LB,TB,sinitB),设fLTSP={{s},LB,{s→/JPs,s→αs},s},其中∈LB,α∈LB∧α≠.显然P是PB的切点,且在P和PB的组合P∝PB中所有标记的转换都为关联点,可以在其上进行通知编织.因此,该方法可以建模每当动作发生时进行某种操作的方面.方面应用的一个重要问题的是方面干扰.已知两个方面A1和A2,和一个基本系统P,若单独编织每个方面都是可行和正确的,而两个方面都编织时不可行或不正确,则存在方面干扰.这里的可行指可以进行编织,正确则指达到了应有的效果(如获得应有的系统属性等).方面干扰可以分为语法层的干扰和语义层的干扰.若P∠A1和P∠A2可行,而(P∠A1)∠A2(或(P∠A2)∠A1)不可行,则称存在语法干扰.这种干扰主要是由于A1(或A2)的编织使得A2(或A1)的切点失效.当编织(P∠A1)∠A2可行(即不存在语法干扰),而A2的编织却改变了A1的应用效果时,例如A1的编织使(P∠A1)获得了属性φ,而(P∠A1)∠A2违反了属性φ,称存在语义干扰.语法层的干扰可通过编织运算∠本身进行检测,而语义层的干扰,则可以应用工具,如LTSA等,对(P∠A1)∠A2予以分析处理.Page94相关工作当前体系结构层面向方面的建模方法主要关注于常规方面的建模问题.从对方面的处理方式上可将这些方法分为3类.第1类方法在传统的基于组件的体系结构描述中引入方面机制对横切关注点模块化,根据方面中的切点信息通过织入的方式实现方面和组件组合.DAOP/ADL[5]、ABC/ADL[6]、基于XYZ/ADL[19]的AO-ADL[18]等都属于这类方法.第2类方法将方面视为一种体系结构视图,通过方面和基本体系结构模型的合并,得到系统的集成视图.典型的如AAM方法[7]、PCS框架[20]等.第3类方法将方面视为基本的构造块,通过搭积木的方式形成复杂的系统,如PRISMA[8]、ArchitectureViewsofAspects[21]等.上述这些方法都没有提供跟踪系统运行轨迹的切点机制,因此无法建模状态型方面.本文的方法属于第1类,它与DAOP/ADL、ABC/ADL和XYZ/ADL方法的主要区别是:(1)提供了跟踪系统运行轨迹的切点机制,可以建模状态型方面;(2)支持更多的通知类型,而ABC/ADL,XYZ/ADL和DAOP/ADL支持类似于AspectJ的before、after、around通知类型,不支持本文的替换和旁路型通知;(3)基于不同的形式化.本文的方法基于LTS,而ABC/ADL和DAOP/ADL基于XML机制,XYZ/ADL基于时序逻辑语言XYZ/E.编程层状态型方面建模的相关研究包括:EAOP[1]和JAsCo[3]利用有限状态机识别一组系统允许的执行trace,当特定的trace模式出现时,执行通知行为.声明事件模式(DEPs)[4]方法用事件模式声明系统执行中的一系列事件,并指定当模式被识别时采取的特定动作.每个事件模式对应一个事件分析器———一个下推式自动机.这些方法在编织时需要在程序中切点自动机事件出现的地方添加额外的指令来引起切点自动机的状态转换.本文方法的切点思想和这些方法类似,但是实现机制不同.它通过切点和基本系统的组合来确定关联点,其优点是不需要添加额外指令,从而产生的组合系统的状态数少.文献[16]提出一种状态型方面的建模方法.它用Mealy自动机建模切点,通知是在关联点状态和目标状态之间增加的转换.该方法适用于反应式系统.本文方法的提出受到此方法的启发.与之不同的是,本文方法针对一般的软件系统,而且除了可以建模文献[16]中提出的两种方面之外,还提供了对其它类型方面的支持.在需求层,文献[22]提出基于继承性消息顺序图(HierarchicalMessageSequenceCharts,HMSCs)的语义编织算法,其切点指定一个出现在基本HMSC中的部分行为,它在编织后被替换为通知的行为.由于切点表示了基本系统执行的部分语义,因此该方法的方面在一定程度上可看成一种状态型方面.其编织是基于HMSC组合上的转换规则,这一点类似于本文基于LTS组合上的编织.但是该方法不能处理本文的顺序、分支和选择型方面.另外,文献[2]提出用一个状态机分解语言对基本系统进行分解,用模块规范来表示状态型方面,从而实现方面和基本模块之间更好的耦合.但是该方法没有提供形式化的描述.文献[10]将状态型方面引入工作流,提出一个基于有限状态自动机的编织策略将历史跟踪信息代码织入工作流.5结束语针对当前体系结构层缺乏支持状态型方面建模有效机制的问题,本文提出了一种基于LTS的状态型方面建模和编织的方法,建立了识别系统运行轨迹模式的fLTS切点机制,定义了支持顺序、选择、分支、替换、旁路型通知的编织运算,基于FSP开发了支持该方法的原型编织工具,并结合一个电子商务实例与其它方法做了对比分析.结果表明,该方法可以有效地对状态型方面和其它常规方面进行建模.未来的研究工作包括进一步丰富本文的编织模型使之支持方面间的组合以及对方面间的语义干扰进行分析.
