Page1缫丝排序算法杨帆王箭柳亚男曹蕊(南京航空航天大学计算机科学与技术学院南京210016)摘要文中提出一种改进的排序算法,弥补了快速排序在大规模下堆栈低效及合并排序在小规模下优势不明显的问题.算法扩展了合并排序思想,从一种特殊的蚕茧缫丝工艺得到启发,使用2~6个滚轴分离待排序列中的有序片段,在滚轴始末端扩展新数据,从而达到在合并操作前增加有序子序列长度的目的.理论推导表明,缫丝排序中的基本操作数量较合并排序减少4.75N,相当于将待排序列缩小至原有规模的1/4;效率测试实验表明,缫丝排序在各种规模下均能获得相比最快经典排序算法10%~15%的稳定优势,相比前人的改进排序算法具备相当的互补性,并能有效降低排序库函数自适应选择算法的实现复杂度.关键词缫丝排序;快速排序;自底向上合并排序;随机序列;有序片段1引言排序的意义在于建立索引以简化统计、查询和搜索工作.其评价标准取决于对算法普适性及其应Page2插入、交换、选择、合并(以下简称Merge)和分布[3].合并思想认为排序是多个有序列归并为一个有序列的“阶段性”工作,这种思想实际上包含前3类出发点并正好站在分布思想的对立面,因而具有重要意义;插入思想是一个较长有序列和一个单独数据的“合并”操作,但其不平衡合并相对低效;交换思想相当于两个长度始终为1的子序列的“合并”,这种合并更为精巧但数据结构的选择对性能影响较大;选择相当于合并的一个步骤,合并的策略只保证数据在局部最小因而大大减少了选择操作的数量;分布思想“实际上恰与合并相对立”[3],以树形结构来看,两者只是所使用的分布型不同,这使得合并的效率取决于当前的树形规模,而分布(基数排序)则取决于可取的树形规模,可取规模较小时,基数排序更有效.本文在总结最优经典排序算法快速排序[1](以下简称QuickSort)和合并排序[1](以下简称BottomUpSort)及一些改进方案的优缺点之后,提出一种基于随机序列因素分析思想的改进排序算法,这是一个符合克努斯框架的普适性串行排序算法.2研究现状研究表明,大N下堆排序的计算复杂度[4]较合并排序更多[2],递归版本的合并排序较之非递归的BottomUpSort同样在大N下出现了无法容忍的递归代价,Martínez等人[5]对QuickSort的元素移动次数进行了详细研究,Vallée等人[6]则进一步认为QuickSort的确切时间代价应为O(Nlog2N).简单的实验证明,BottomUpSort在N>500000时速度最快,而QuickSort在N<500000时优势非常明显,相比其他经典算法更快.在排序算法的改进工作方面,近年来国内外仍不断有针对经典单线程内部排序算法的改进方案出现:祁建宏等人[7]针对插入排序中比较操作利用率不高的问题,提出了一种改进的双插入排序算法,可以在一轮比较中获得2个数据的插入位置;Wang等人[8]提出的改进堆排序算法使用N个存储空间获得了NlogN-N的平均时间效率;唐开山[9]提出的ASH改进堆排序算法和基于该算法的二次堆排序算法减少了堆排序中重构堆的比较次数,获得了相比原始堆排序80%的速率提升,但都无法解决堆排序在大N下相对其他最优算法低效问题;Mansi提出了一些针对QuickSort的改进[10],当待排数据值较小且不等时,其中的一种在N=10000的小规模下可比原始QuickSort节省约40%的运行时耗[11];Kim等人[12]研究扩展了Bentley和Sedgewick的多键值QuickSort,提出一种针对相同键值较多情况的改进方案,但在随机输入下不比原始算法快;武汉大学的杨锋英等人[13]将快速排序算法与插入排序结合,提出了改进的快速排序算法,在数据受限条件下可以获得相比原有QuickSort50%的时间优势;西南大学的胡继宽等人[14]提出了一种基于QuickSort的海量数据快速分组排序算法,在分组数较多时有很好的优势,而当分组较少时则不如快速排序.BottomUpSort和QuickSort这两种最快的排序算法分别在大N和小N下取得了成功,而其不足之处也十分明显.BottomUpSort以稳定的高速特征取胜,但QuickSort的基本操作数量通常比BottomUpSort更少;QuickSort中低效堆栈问题成为其大规模排序的瓶颈,两者都无法在大N或小N下保持最快.ReelingSort能同时在大N和小N下超越更快的一方,正是由于它对实际情况和理论框架的兼顾,利用随机序列的固有特征,以生成尽量长的有序子序列,而后回到纯粹的理论最坏假设,像BottomUpSort那样保证算法的理论最坏上界.3缫丝算法(ReelingSort)3.1算法思想在桑蚕缫丝(Reelng)工艺中,存在一种绕取方法解决双茧(两只蚕在一处结成的一种特殊蚕茧)的缫丝问题.操作者双手各持一根短棍(滚轴),同时将两股蚕丝绕取在不同的滚轴上.这种绕取工作可以类比为一种含有两个影响因素的简单随机序列分离操作,它给出了一种不错的排序思路.缫丝算法(以下简称ReelingSort)的思想可以这样描述:在合并前按照影响因素的不同把数据分离在不同子序列中,加长初始有序列长度以减少合并轮数.排序方案吸收了合并的思想,其着眼点在于设法增加合并排序中初始子序列的长度,并通过设立多个可供新数据扩展的子序列(滚轴)实现,数据扩展仅在序列的两端进行,从而避免了相对低效的插入操作.简单的实验可以发现,大于等于因素个数的滚轴数量足以将原始序列从头至尾梳理完毕,但在滚轴数量较少时,子序列长度显然不能伸展到序列末端.这个问题构成了缫丝排序研究的关键:滚轴查找操作会增加开销因而应当加以限制,如何确定滚轴数量以达到最佳加速比是值得研究的.Page33.2算法过程首先说明ReelingSort的设计思路.设立2~6个一维数组作为滚轴(4滚轴ReelingSort为最优,见2.3节),对于待排序列中的每个数据,顺序考察其是否能够在当前活动滚轴的两端扩展,具体方式如下:如果考察数据比当前滚轴最小数据(第1个键值)小,则添加在该子序列首部,若比最大数据(最后一个键值)大,则添加在该子序列尾部,否则考察下一个活动滚轴;若最后一个滚轴仍无法添加数据,则需新建滚轴存放它,并将第1个滚轴由活动状态转为待合并状态,不再接受新的数据,当待合并滚轴数量达到4个时(对4滚轴ReelingSort而言),采用Merge操作将4个子序列整理有序后送回内存并记录其始末位置,滚轴清空后可循环使用;“缫丝”完毕后,根据有序子序列始末位置信息进行Merge操作生成最终有序序列.一个用伪代码描述的算法步骤如下.算法1.ReelingSort.输入:n个元素的数组sr[n]输出:按非降序排列的数组sr[n]寄存器说明:flag[n/36]是辅助标志位数组,记录sr中有序子序列的终止位置,buffer[8][40]是8个容量为40的滚轴(始终只有4个处于可扩展状态),Merge函数返回本次合并生成的子序列在sr数组中的终止位置,pre[8]和aft[8]分别记录滚轴当前最小和最大有效数据位置,初始值为20,FOR_MERGE和FOR_REEL宏分别代表待合并状态和活动状态;1.buffer[0][20]←sr[1],j←2,t←0,p←0转步2;2.whilejn,fork←ttot+3k++考察buffer[k],若sr[j]buffer[k][pre[k]]且buffer[k]未溢出,buffer[k][--pre[k]]←sr[j++],转步3;若sr[j]buffer[k][aft[k]]且buffer[k]未溢出,buffer[k][++aft[k]]←sr[j++],转步3;若没有滚轴可以添加该数据或buffer[k]已满,转步4;3.若jn,转步2,否则转步5;4.buffer[t]_mark=FOR_MERGE,t=(t+1)mod8,buffer[t]_mark=FOR_REEL,buffer[t][20]←sr[j++];若t=3(此时buffer[4]~buffer[7]标记为FOR_MERGE,可供合并),flag[p++]←Merge1(sr,buffer[4],buffer[5],buffer[6],buffer[7])-1;若t=7(此时buffer[0]~buffer[3]标记为FOR_MERGE,可供合并),flag[p++]←Merge1(sr,buffer[0],buffer[1],buffer[2],buffer[3])-1;转步3;5.Merge2(sr,sr,flag).算法中的两个Merge操作稍有差别,Merge1(sr,buffer,buffer,buffer,buffer)将4个滚轴中的有序子序列合并后保存在数组sr中,返回有序子序列的终止位置用于flag标志位寄存器标示,Merge2(sr,sr,flag)在“缫丝”完毕后根据flag标志位提供的有序子序列末端位置,套用经典合并操作将sr数列中的数据合并为最终整体有序,并保存在sr中.另外,程序定义了8个滚轴而不是4个,这是一种程序实现上的设置,当考察数据无法在当前4个活动滚轴上扩展时,它将导致一个新的滚轴被使用,同时处于顶部的第1个活动滚轴将标记为FOR_MERGE,直接将序列写回内存较为浪费,等它们达到一定数量时(例子中为4个),通过Merge合并后写回内存.根据这个算法步骤进行的“缫丝”实例如图1,为加快演示进度,随机数据已经进行了特殊组织以缩短序列长度.3.3滚轴数量的确定缫丝算法实际上将待排序数据视为不同主导因素影响下的随机样本序列,使用滚轴尽量分离这些数据以得到更长的有序子序列片段.BottomUpSort合并模式的保留使得其最坏情况仍然是O(NlogN)的,因而比QuickSort更稳定.显然,ReelingSort算法的时间代价取决于滚轴可以绕取的子序列平均长度,而该数值又取决于滚轴数量.ReelingSort算法的关键是要获得滚轴数量的折中.一方面,更多的滚轴能够增加子序列平均长度,但会导致查找这些子序列的代价增加;另一方面,少量的子序列固然可以忽略查找代价,但选择余地的减少又会使子序列长度降低.在使用不同微机进行了大量序列规模不等的测试后发现:使用2个滚轴时,ReelingSort平均花费2.2N的代价可以使子序列平均长度达到6;使用4个滚轴时,3.2N次比较可以使子序列平均长度达到10;使用6个滚轴时,3.8N次比较则能构造平均长度为14的子序列.通过计算不难发现,2轴的ReelingSort并不具有实际意义,其基本操作数量为1.75Nlog(N/3)+1.4N,其中N=3×2k+2,与BottomUpSort基本持平,而6轴的ReelingSort虽然理论速度更快(其基本操作代价为1.75Nlog(N/21)+4.3N,其中N=21×2k+2),但实际的效率测试表明其寄存器变量查找代价已经开始超过序列长度增加节约的合并排序代价,因此4轴ReelingSort是当前兼具理论代价优势和优良实际表现的选择,其基本操作代价将在后面详细说明.Page4图1ReelingSort滚轴绕取数据情况演示3.4滚轴数据结构ReelingSort的由前至后顺序查找方式可以保证找到的第1个可添加位置必定是最佳位置,图2示例性地说明了这一过程.4个滚轴当前的使用情况如图2:滚轴1上最小的数据是12,最大的数据是876,其它滚轴类似,滚轴长度定性地表现了元素跨越的数值范围,它们是层级包含的,下级滚轴包含于上级滚轴.滚轴两端的无框数值标示了数据可以扩展的8个位置.假设需要添加的数值为276,贪心逻辑搜索至最后一个滚轴(滚轴4)仍然无法扩展它(219<276<354),这将导致位置9上新建一个滚轴,并使滚轴1由FOR_REEL转为FOR_MERGE状态.当数值为68的数据到来时,贪心逻辑同样从位置1开始查找,第1个可添加位置为5(68107).这种添加位置的选择方式能够保证新数据在当前最优位置上扩展,能够保证子序列长度最大化,不难说明这种数据添加方式将始终保持层级包含特征,并且较长的FOR_MERGE状态滚轴应当是方差较小的优良子序列.但是使用贪心逻辑确定数据添加位置的方式并不是最优的.图2的8个可扩展位置实际上将数轴分成了9段:……12……34……107……219……354……543……783……876……,因此使用二分查找确定数据的添加位置将加快定位速度,前文提到的平均3.2N查找代价是选择二分查找后优化的结果.4算法效率分析4.1时间复杂度选择BottomUpSort自底向上非递归合并排序作为4轴ReelingSort的理论时间复杂度比较对象,分析显示,ReelingSort比BottomUpSort平均节省约1.8N的基本操作代价.为方便比较,令N=10×2k+2.BottomUpSort共需k+5轮合并;ReelingSort在缫丝完成后恰好需k轮合并操作,缫丝过程中每个数据平均需3.2次比较绕取在滚轴上,因而比较代价为3.2N;4个滚轴上Page5数据的平均长度为10,两轮两两合并操作共需进行N/40轮;从内存逐个读写一次数据,因此赋值次数表1BottomUpSort和ReelingSort理论代价详表最多比较次数BottomUpSort∑k+3ReelingSort2j(2j-1)+24×2k+2-410+2.4N+12j(2j-1)+24×2k+2-410+2.4N+1将上述理论代价相减后易得,4轴ReelingSort将比BottomUpSort节省基本操作(最少最多平均):1.75N2.275N1.775N,这里将赋值和比较视为等代价操作.4.2空间复杂度ReelingSort算法的空间复杂度为O(N),与BottomUpSort持平,与其他最优排序算法相比使用了典型的空间换时间策略.与合并排序类似,缫丝排序需要一个大小为N的辅助存储器实现Merge操作中数据的轮转缓存;另外,程序中用于指示有序子序列末端位置的flag标志位平均数量为N/40个,由于大小在N数量级,对其进行的赋值操作不能视为寄存器赋值;4轴ReelingSort用于绕丝的滚轴为寄存器中的一个8×40二维数组,在规模N较大时该部分空间代价可以忽略不计,因此ReelingSort所需存储空间总共约为1.025N.4.3效率测试实验本节将通过实际的C++编程实现测试Reel-ingSort算法和其它最优排序算法的效率表现,实验结果显示ReelingSort相比小规模下更快的Quick-Sort和大规模下更快的BottomUpSort始终能保持10%~15%的稳定优势.在N<500000时将ReelingSort与QuickSort比较,之后与更快的BottomUpSort进行比较;S定为N的100倍;在5×104~50×104区间,测试实验每次对规模N增加5×104,50×104~500×104区间以50×104递增,500×104~5000×104之间以500×104递增.根据ReelingSort与QuickSort实验数据绘制的时耗折线图如图3.显然两者的时耗随着规模增大都是线性稳定的,而ReelingSort相比QuickSort存在约15%的稳定运行时间优势.为2N;另外,flag寄存器的使用数量为N/40个,因此缫丝部分赋值代价总共为2N+N/40.根据ReelingSort与BottomUpSort实验数据绘制的时耗折线图如图4(a)、(b).同样地,两者的时耗随着规模增大线性稳定,这说明实验程序执行是有效可控的,而ReelingSort相比BottomUpSort同样存在约10%的稳定运行时间优势.4.4结果分析与数值修正以上分析表明,ReelingSort的理论基本操作数Page6量比BottomUpSort平均减少1.8N左右,实际运行耗时相比小N下最快的QuickSort减少约15%,相比大N下最快的BottomUpSort减少约10%,且优势稳定.这表明ReelingSort在任意规模下都是一个表现良好的算法.不难发现缫丝算法的理论优势和实际优势间存在一定差异,以N=500000时测试结果为例,理论推导的ReelingSort运行时耗应比BottomUpSort减少5.6%,但实验数据显示其相比后者减少9%左右,这是由于实际的比较和赋值操作不完全等价造成的.定义操作A与操作B在相同软硬件上运行消耗时间的比值为A与B的时耗比,简单的实验证明两者准确的时耗比应为12.由4.1节可知,ReelingSort的比较操作比BottomUpSort多1.2N,而赋值操作比后者少2.975N,缫丝算法将更多的处理代价花在了相对更为省时的比较操作上,考虑比较和赋值操作权值后的新比例式为ReelingSort基本操作数量BottomUpSort基本操作数量=(34NlogN(4NlogN3≈N=5000000.907.修正的理论时耗比0.907与实验数值0.91非常接近;此时ReelingSort将比BottomUpSort节约4.75N单位耗时(赋值操作为2个单位耗时),计算BottomUpSort中前两轮的合并操作代价为N2(第1轮比较代价)+2.5×N2N(第1轮赋值代价)+2N(第2轮赋值代价)=5.125N.这部分耗时与ReelingSort节约的4.75N耗时接近,BottomUpSort在前两轮合并中将数列规模缩减为1/4,因此从这个角度看,ReelingSort的优化相当于把原有数列规模缩小为1/4.4.5与其它改进方案的比较本节将以经典算法效率为基准,通过缫丝算法与其他改进排序算法的相对比较说明算法的现实优势.比较结果显示:ReelingSort作为一种普适性最优排序算法,相比双插入排序[7]这样的非最优算法优势非常明显;与唐开山[9]提出的二次堆排序算法相比在大规模输入下更快,但在小规模时不如后者,因而具有良好的互补性;与杨锋英等人[13]提出的改进快速排序算法和胡继宽等人[14]提出的改进快速排序算法相比,开销在满足后两者输入要求的情况下基本持平,但在算法普适性方面则有明显优势;Wang等人[8]提出的改进堆排序算法以及Mansi[10-11]、Kim[12]等人对QuickSort的改进相比其它改进稍慢或出发点类似,在此不做详细比较.祁建宏等人[7]提出的双插入排序算法是一种针对小规模下链表插入排序算法的改进,推得其实际效果相当于将排序代价缩减为原插入排序的3/4.在主频2.8GHz的CPU上运行小规模的N=10000~N=100000原始插入排序C语言程序和缫丝程序,按上述理论代价比值推导得改进算法的运行时间,结果显示该方法虽然对插入排序的改进效果明显,但与包括缫丝排序在内的最优排序算法相比效率差距仍然明显,如图5.图5ReelingSort与推导的双插入排序时耗折线唐开山[9]提出的二次堆排序算法获得了相比原始堆排序80%的速率提升.同样在PC机上运行原始堆排序和缫丝排序程序,参考唐给出的比较值后推出改进的时间开销如图6(a).实验数据显示,在较小规模下,二次堆排序的效率明显优于缫丝排序,但二次堆排序与堆排序的时耗比随规模增大呈上升态势(从N=10000规模下的0.23增至N=75000规模下的0.28);相反地,避免堆操作代价使得缫丝排序与堆排序的时耗比是减小的(N=1×104时为0.62,N=7.5×104时为0.60,N=1000×104时仅为0.30).唐的研究没有给出大规模下测试数据,假设其时耗比在短区间内线性变化,推导得二次堆排序的时耗比将在N=10×104时达到0.30,则缫丝排序的效率将在N=10×104~1000×104之间超越二次堆排序,两者在不同规模排序工作中是具备互补性的,如图6(b).武汉大学的杨锋英等人[13]提出了改进快速排序算法,可获得相比原有QuickSort约50%的时间优势,这种优势是在“数据变化有一定的限度,并围绕该限度上下波动”[13]的受限条件下获得的,而在随机序列情况下的表现则不如原始的QuickSort.随机输入时的比较结果如图7,可见这种改进对于Page7图7随机输入ReelingSort与改进快速排序时耗折线普适条件下的随机输入情况不如缫丝排序.西南大学胡继宽等人[14]提出了快速分组排序算法,在分组数较多时相比QuickSort有优势,而当分组较少时则不如快速排序.推导得该方案在所要求的较好情况下与原始QuickSort的时耗比约为0.89,此时的比较结果如图8,可见在分组数较多的小规模排序时,改进与缫丝排序的效果类似,但在考图8ReelingSort与推导的分组排序时耗折线虑包含分组数较少的随机情况并增大排序规模后,缫丝排序将优于分组排序算法.综上所述,ReelingSort相比其它改进在普适性方面具有明显优势,当数据规模增大后该优势尤其明显.4.6与自适应排序库函数的比较根据不同的排序规模自适应地选择排序算法是当今主流库函数的典型特征,而ReelingSort可以明显降低这类自适应选择算法的实现复杂性.以python中的sort实现[15]为例说明Reeling-Sort对自适应排序算法的简化作用.Python语言内置的排序方法是一种典型的自适应排序,当规模N<50时,直接使用插入排序;一旦排序规模增大,方案在进行简单的顺逆序检查后使用二分法插入排序(binaryinsertion),这种方法使用二分查找确定新数据的插入位置,从而将查找代价从O(N)降低为O(logN);若排序规模继续增大(N>200),方案将转变为二次抽样排序(samplesort),这种方案汲取了基数排序的思想,但在“分桶”前先进行两轮抽样以保证数据“分桶”的均匀性.因此python的排序时耗曲线是分3段拟合的.实验数据显示Reeling-Sort的时间代价只在排序规模N<50时略高于python选择的插入排序,而当排序规模增大后,ReelingSort的时间代价将始终优于python当前选择的自适应算法,如图9(a)、(b).这意味着使用ReelingSort将能够明显简化python的自适应排序实现:在N<50时使用经典的插入排序,而当N>50以后,可以始终选用ReelingSort.Page85结束语本文从古老的“双茧”缫丝工艺得到启发,根据随机序列主导因素的不同,使用多个扩展序列先行分离待排数据,提出了一种改进的普适性排序算法,设计完成了同时具备可控理论优势和现实意义的4轴缫丝程序,并对如何确定程序中滚轴数量和滚轴选择方式做了详细说明.效率测试表明,算法可以获得相比现有经典算法10%以上的稳定优势,在等价意义上将基本操作中的一部分赋值操作转化为比较操作,进一步降低了算法的实际运行耗时,与其它改进相比具有明显的普适性优势,可用于降低主流排序库函数自适应选择算法的实现复杂性,是一种在较大和较小规模下同时具备良好性能的排序算法.致谢衷心感谢林佳骝博士研究生在本论文编写过程中给予的悉心指导和大力协助!
