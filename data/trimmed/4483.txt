Page1X10程序的差别分析方法陈雨亭1),3)杨威1)赵建军1),2),3)1)(上海交通大学软件学院上海200240)2)(中国科学院软件研究所计算机科学重点实验室北京100190)3)(上海市计算机软件评测重点实验室上海201112)摘要程序差别分析是程序调试的常见手段,其主要用于分析程序不同版本之间的差异信息.然而,将现有程序差别分析算法扩展到并行程序语言还面临众多挑战.其主要原因在于并行程序复杂性较高,且存在支持并行活动的特殊机制,如地址(或线程)、活动、同步等,从而为有效进行程序差别分析设置了障碍.文中研究基于PGAS模型的X10并行程序的程序差别分析方法,并设计了一种语句级的、针对X10程序的程序差别分析算法X10Diff.X10Diff包括下列步骤:(1)匹配原程序和修改后程序中的类、接口、方法及地址;(2)为待分析程序片段构建基于地址的程序流图,并建立相应简化图;(3)迭代扩展并比较简化图,并将差别信息定位到代码中.关键词程序差别分析;X10;程序流图;软件测试;程序调试1引言要的程序调试技术[1],主要用于分析不同程序或程序不同版本之间的差异信息,如程序修改位置、程序相对于原版本所做出的修改类别(增加、删除、修改)等.程序差别分析(ProgramDifferencing)是一种重本文研究X10并行程序的差别分析方法.X10Page2是IBM为并行编程开发的语言①,采用分布式全局地址空间(PartitionedGlobalAddressSpace,PGAS)模型.目前,存在针对C、Java等语言的程序差别分析算法,但几乎没有针对并行程序语言(包括X10)的程序差别分析算法.一方面,程序差别分析算法是语言相关的,不易在不同程序范型(面向过程、面向对象、并行等)之间实现算法迁移.例如BMAT[2]不能识别与面向对象特性(如异常、继承结构)相关的程序差别信息;Semanticdiff[3]及Horwitz的技术[4]用于分析面向过程的程序,不能用于分析面向对象程序中的差别信息等.另一方面,现有程序差别分析算法难以扩展至X10等并行程序语言中,主要原因在于并行程序复杂性较高,多线程编程方式及同步、异步并行机制对差别分析造成困难,具体包括:(1)对X10程序的差别分析不仅需要涵盖与类、方法、语句等程序语法或结构相关的差别,也需要考虑程序活动(Activity)与地址(Place)的差别.其中,活动可被看成是轻量级线程,地址用于存储数据及提供活动范围,待分析程序之间活动或地址存在差别也意味着程序语义上存在差异.例如,程序员通过重构技术将单个逻辑地址上的活动拆分为多个逻辑地址上的并行活动,对重构前后程序之间进行基于语法树的差别分析不能得出程序从顺序向并行、分布式执行方式的转变.我们需要考虑X10程序中与并行相关的活动及地址信息,进行基于语义的程序差别分析.(2)基于语义的程序差别分析通常依赖于程序流图的匹配.这里的难点包括为X10程序建立支持并行活动的程序流图、判断两个程序流图是否存在同构关系、及对同构流图实现匹配与比较等.本文设计了一种针对X10并行程序的程序差别算法X10Diff,用于实现两个X10程序(或程序版本)语句级差别分析.X10Diff包含下列步骤:(1)匹配两个程序的地址、类、接口及方法;(2)为待分析程序构建扩展程序流图,并将其简化为简化图.这里采用基于分布式地址的程序控制流图,以描述X10中的并行机制;(3)迭代扩展、比较简化图,将差别定位至代码中.本文设计的程序差别算法对X10程序的维护、测试等具有意义.在程序维护过程中,程序变更可能导致程序多个方面受到影响,可以对程序进行变化影响分析以确保程序的正确性.在该过程中,程序差别分析定位X10程序改变的具体位置,而影响分析进一步分析程序哪些部分会受到改变的影响.关于回归测试用例选择的研究中,程序差别信息可以帮助测试人员评估X10程序修改轮廓信息[2],决定哪些测试用例需要在修改后的程序版本上重新测试运行,以减少测试的代价.本文主要贡献和创新点包括两方面.首先,大多数程序差别分析技术是针对顺序程序或者面向对象程序而言的,而本文将差别分析技术扩展至并行程序分析中.其次,现有程序差别分析技术主要针对于程序文本或语法结构,而X10Diff是一种基于语义的程序差别分析技术:对X10程序进行基于语义的差别分析有助于辨识程序的全局行为差异及各逻辑地址上的活动差异.2X10语言X10是IBM为在分布式系统上通过共享内存而进行并行计算所设计的编程语言,其采用分布式全局地址空间PGAS模型.PGAS是并行编程模型,其假设一个全局地址空间是逻辑分布的,每一个逻辑地址对应一个本地处理器.X10利用了活动和派生的概念来描述并行执行的软件行为.在X10中,一个计算被拆分为若干活动(Activity)到多个地址(Place)中并行完成;一个活动可以在本地或者远程派生出多个子活动,子活动也可以派生出更多子活动.async(place)S语句表明在地址place中创建一个异步活动,S为活动中执行的语句.一个活动在其生命周期中,仅能在一个地址中被执行,且仅能直接访问在同一地址中的数据,对远程数据(即不在同一地址中的数据)的访问只能通过在远程地址中派生新活动实现.图1中QSort2显示了一个描述快速排序算法的X10程序片段:第25行的partition函数将待排序的数组data分割成独立的两部分,从索引left到index的数据比从index到right的所有数据都要小;第27~28行对从left到index的数据进行快速排序;第30~31行对从index到right的数据进行快速排序.QSort2是一个并行算法.假设当前活动为A1,活动地址为place1.A1在第28行派生一个异步活动(假设活动名为A2,地址为place2).A2和A1分别对索引index前后的数据快速排序.第26行关键字finish指明活动A1和A2完成后排序任务结束.①http://x10-lang.org/Page324.staticdefqsort(data:Rail[int],left:int,right:int){25.index:int=partition(data,left,right);26.27.if(left<index-1)28.qsort(data,left,index-1);29.if(index<right)30.qsort(data,index,right);31.}24.staticdefqsort(data:Rail[int],left:int,right:int){25.index:int=partition(data,left,right);26.finish{27.if(left<index-1)28.asyncqsort(data,left,index-1);29.30.if(index<right)31.qsort(data,index,right);32.}33.}图1排序算法QSort1与其并行版本QSort23程序差别例子本节首先采用一个简单例子说明X10程序间的差别.图2中,程序APPTest2的foo方法是程序APPTest1的foo方法经过重写(修改语句、插入语句或者删除语句)所得.可以得到APPTest1和APPTest2中节点对应关系及差别信息,如表1所示.这里,G1、G2分别为目标程序(如APPTest1与APPTest2)的程序流图(见本文第4节);节点号对应程序语句行号;APPTest1与APPTest2存在三处差别,含两处语句修改和一处语句插入.图2具有差别的程序APPTest1,APPTest2无差别节点及差别①(修改节点)G1节点(2)修改至G2节点(3)差别②(修改节点)G1节点(6,7)修改至G2节点(7)差别③(插入节点)G1节点(无)修改至G2节点(1)图2介绍了一个简单的X10程序差别的例子,并未涉及地址及活动等更为复杂的情况.这里回顾图1的例子以说明与语义相关的程序差别.图1中提供了两个快速排序的代码片段:QSort1与QSort2的差别不仅在于后者使用了async和finish关键字,更在于QSort2通过两个并行活动完成快速排序.表2显示了QSort1与QSort2的差别信息,既包括两段程序语句之间的对应关系,也包括与活动相关的三处差别,包括一处活动缩减,一处活动新建及一处活动同步关系的建立.无差别节点及差别①(缩减活动)G1节点(27,28,29,30)修改至差别②(新建活动)G1节点(无)修改至G2节点(27,28)差别③(新建同步)G1节点(无)修改至G2节点(26)4X10程序程序流图的同构关系本文设计一种基于程序流图的、针对X10程序的程序差别方法X10Diff.传统上,一个程序流图G可定义为一个四元组(N,E,START,END),其中:N是节点集合;E是有向边集合;START和END是程序流图唯一的入口点和唯一的出口点,且START∈N,END∈N.此外,程序流图中,如果一个节点有多个后继节点,其为决策节点(例如,条件谓词对应的节点),从该节点发出的边称之为分支;如果一个节点存在0或1个后继节点,其为处理节点.上述定义并不能有效表示X10语言中分布存储的特性.研究中采用多泳道的概念来扩展程序流Page4图,以对不同地址中的活动进行描述:每一个泳道对应程序一个逻辑地址,并包含一个或多个子程序(活动)流图.例如,图1中QSort2程序对应的程序流图如图3(a)所示,其包含两个并行活动,分别处于不同泳道中.当程序活动与地址相关时,程序流图的构建依赖于对活动驻存地址的计算.我们此前提出一种基于约束的地址分析技术Leopard(LocalityAnalysesofPartitionedGlobalAddressSpacePrograms)[5],以精确识别程序单个地址(泳道)中的活动和对象:Leopard定义了对象、活动和地址之间的约束关系,并计算每一个地址表达式的可能值;Leopard进一步分析程序中的指向关系,建立位置约束图来计算每一个实际地址中的可能活动与对象.基于Leopard,我们将活动对应流图指定至不同泳道中,建立包含地址信息的程序流图.程序差别分析中的一个重要步骤是匹配程序结构.本文基于集簇的概念建立简化程序流图,以确立两个程序流图的同构关系.令一个多泳道的程序流图的节点集合N中有子集C,N\C为N中C的补集.如果C满足如下条件,则称其为G中的集簇:(1)C中所有节点属于同一泳道;(2)在C中有入口点STARTc,其为C中唯一由N\C中节点所指向的点;(3)在N\C中有ENDc,其为N\C中唯一被C中节点所指向的点.四元组〈C∪{ENDc},(C∪{ENDc})×(C∪{ENDc})∩E,STARTc,ENDc〉则构成一个程序子图.用单个节点替代程序流图中的一个集簇,所获得的流图被称之为简化图.例如,图3(a)可以被简化为4个节点的简化图,如图3(b)所示.设G1=〈N1,E1,START1,END1〉和G2=〈N2,E2,START2,END2〉为两个程序流图(或简化图),B1和B2为相应的分支集合.定义1定义G1和G2的同构关系.定义1.带标记的程序流图的同构关系.当且仅当以下条件满足时,映射f:N1→N2是G1和G2的同构关系:(1)对于N1中任意n1,存在唯一的n2∈N2使得nl(f(n1))=nl(n2);(2)对于N1中任意m、n,(f(m),f(n))∈E2当且仅当(m,n)∈E1;(3)对B1中分支(d1,n1),存在唯一的分支(d2,n2)∈B2,使得al(f(d1),f(n1))=al(d2,n2).定义中,nl、al为相应的标记函数:如果N1或者N2中节点n对应一条程序语句,nl(n)为相应的程序语句;如果n对应一个集簇,那么nl(n)对应标记MOD;al(b)将决策节点中的每一个分支b赋予不同标记(例如,对于条件语句,默认将边标记设为TRUE或FALSE).5程序差别计算X10Diff的主要思想在于为修改前后的X10程序分别建立多泳道的程序流图,将其简化为多泳道的简化图,迭代扩展简化图并完成同构简化图的比较.5.1建立同构简化图图G1和G2,并识别出相同数量的集簇,使得:对应;给定程序版本P1和P2,建立多泳道的程序流(1)对于G1中的集簇,G2中有且只有一个集簇(2)当每个图中的集簇被单个节点所代替时,对于扩展的程序流图G1和G2,首先匹配程序两图中的节点一一对应.Page5流图中的泳道(即活动地址),匹配中遵循如下原则:(1)相似名匹配.如果G1和G2中两个泳道P1i和P2j具有相似的标签,则匹配P1i和P2j.例如,图4(a)中,P11和P21展现相似名匹配的情况;(2)相似流图匹配.如果G1和G2中两个泳道P1i和P2j中包含的活动(或子流图)相似,则匹配泳道P1i和P2j.例如,图4(b)中,P11和P22具有相似的集簇,可以对它们实现匹配;(3)复杂匹配.如果G1中泳道P1包含的活动(或子流图)对应G2中泳道P21~P2n的活动(或子流图),将P1分解为n条泳道P11~P1n,并与P21~P2n分别匹配,反之亦然.例如,图4(c)中,由于部分活动地址变更,P11与P21和P12与P22不能完全匹配.我们将各泳道中的活动进一步分割,得到匹配关系为〈P111,P211〉、〈P112,P213〉、〈P121,P22〉和〈P122,P212〉.对应于匹配泳道内的程序子图G1和G2,如果G1中的节点无法与G2中的节点对应,则对程序子图执行如下3个操作:(1)重新标记.将某个节点标记改成MOD;(2)折叠节点.如果C是一个节点集簇,则用标记为MOD的节点替代C;(3)移除节点.当确定程序修改是在原程序中移除一组唯一入口点和唯一出口点的指令集以后,可在相应程序流图上移除节点.如果C是一个集簇,C中节点及相关的边可从图中移除.如算法Find_Isomorphism所示,对程序子图G1和G2中的一个或多个节点进行上述操作后,将其简化为同构简化图SG1和SG2.同构简化图为程序差别计算的基础.算法1.Find_Ismorphism.输入:匹配泳道中的程序子流图G1、G2输出:匹配的简化图SG1、SG2BEGINFOR(G1或G2上的任意决策节点n)DOEND算法2.Search_and_Reduce.输入:集簇C1,C2输出:集簇RC1,RC2BEGINFOR(C1和C2中的决策节点n)DOIF(C1和C2无法形成同构)THENENDPage6用图2中程序APPTest1和APPTest2以说明算法,图5是匹配过程中相应的简化图G11~G16以及G21~G26.具体匹配过程如下:(1)将两程序流图中的决策节点转换为集簇,得到简化图G11和G21;(2)使用简化算法Search_and_Reduce对两个图进行深度优先访问,并采用折叠节点操作,将图分别简化为G12和G22;(3)对G12和G22归导,使其在全局范围内同构;若无法同构,则对图折叠,在折叠集簇中建立对应关系.例子中,G12和G22中折叠集簇的起始点临时标记“while(count<size)”.因为节点1“sum:int=0”在图5程序流图G11~G16以及G21~G26根据定义1,G16和G26同构.算法正确性和复杂性分析Find_Ismorphism是图同构关系的构建算法,其算法正确性主要表现为两个方面:建立简化图步骤的正确性和迭代扩展简化图并建立同构关系步骤的正确性.前者依赖于简化图的定义,对于一个多泳道的程序流图,其最小简化图唯一,从而保证算法正确性.后者正确性依赖于程序节点、子图等的相似度:对分析程序中相似节G12中无对应匹配,保留G12,并在G22中去掉节点1,得到了G23.因此,G12=G13;(4)重新标记G13中节点2“count:int=1”和G23中节点3“count:int=0”为MOD,得到G14和G24;(5)由于匹配的折叠集簇需保留尽可能多的标签,还原图至G15和G25;(6)比较G15中集簇C1={3,4,5,6,7,8}和G25中集簇C2={4,5,6,7,8},发现对应while循环代码不一致.前者中的语句6、7被后者中的语句“sum··=sum+num1num2”所替代,因此折叠G15中的节点6、7,重新标记G25中节点7,得到G16和G26.点进行节点移除、节点折叠和标记节点、扩展节点等基本操作,从而完成同构图的匹配.算法复杂性的最坏情况为O(n2),这里,n为程序流图的节点数目.一个节点数为n的程序流图简化的最坏情况是程序流图得不到简化,因此要求两个程序流图所有节点进行一一匹配;假设判断两个节点是否匹配的代价为常量,匹配的复杂性为O(n2).算法复杂度的最好情况为O(n).程序一开始简Page7化为单个节点,然后最多经过n次扩展,实现同构图匹配.最好情况下,每次扩展过程中,被扩展节点均实现精确匹配.5.2节点匹配下面给出匹配算法Match,以在同构简化图的基础上建立节点匹配.算法中,用户自定义相似度标准S,以决定两个节点是否相似;Comp(n1,n2,LH,S,R)根据相似度标准S对节点n1和n2匹配,如果实现匹配,则将带标记的节点对加入集合R并返回TRUE,否则返回FALSE;succ(Set)计算Set中每个节点的后继节点并以节点集合的形式返回;EdgeMatching(n1,n2)返回配对的边.算法3.Match.输入:源程序中的节点n1;输出:布尔值resultBEGINresult=FALSE;图6待比较的示例程序P,PENDWHILERETURNresult;END考察图6中的例子,图7显示了修改前后的程序流图.算法将出口节点〈3,3〉添加到配对节点集中,将节点对〈1,1〉压栈到ST中.在while第一次循环中,调用Comp(1,1,2,0.5,R)进行比较,将〈1,1〉设为匹配并放入R中.由于1、1节点均只有一条出边,且两条边匹配,将节点对〈2,2〉压入工作表.1.publicclassA{2.publicdefm1():void{3.…4.}5.}6.7.publicclassBextendsA{8.publicdefm1():void{9.…10.}11.publicdefm2():void{12.…13.}14.}15.16.publicclassD{17.publicdefm3(vara:A):void{18.a.m1();19.…20.}21.}Page8图7简化图节点间匹配将节点2、2扩展为两个子图.算法配对起始点对〈4,4〉、出口点对〈7,7〉,并将〈5,5〉、〈6,6〉压入至ST1中.算法接下来将节点对〈5,5〉配对并压入R1中,将后继节点对〈7,7〉压入至ST1.依次比较节点对〈6,6〉、〈6,7〉、〈7,6〉,因为均不匹配,则添加节点对〈6,6〉到R1中,标记为“MODIFIED”,将后继节点对〈7,7〉压入至ST1.因为大多数节点在子图中都被标记为“UNCHANGED”,而设定相似度标准S为0.5,故两个流图匹配.因此,Comp(2,2,2,0.5,R)返回TRUE,将节点对〈2,2〉加入至R,并标记为“UNCHANGED”.算法对简化图剩余部分继续完成匹配.上述例子包括了简化图节点匹配的多种情况,包括节点的匹配、向前读入节点、流图扩展等.算法正确性和复杂性分析.Match算法用于判断两个节点是否匹配.算法正确性主要取决于:(1)匹配节点与流图中其他节点之间控制依赖关系的建立,即如果节点依赖的节点集能与另一个程序中节点依赖的节点集形成相似匹配关系,则为这两个节点建立匹配关系;(2)相似度取值,如果相似度要求高,则不易为两个程序的节点匹配,反之则容易匹配.单个节点匹配算法复杂性最坏情况为O(n2),n为待匹配的流图节点数.当该节点与其他所有节点都有控制依赖,最坏情况下需要检查每一条控制边是否连接到相应的节点上.然而,由于设立了相似度,实际计算中当不满足相似度要求后计算会结束.同理,针对流图所有节点匹配算法复杂性最坏情况为O(n4),在此情况下,需要对两个流图中所有节点进行一一匹配.5.3差别分析结合匹配算法,设计X10程序差别方法如下.这里,将修改前后的程序版本P1和P2作为输入,并接收另两个参数:LH是差别分析中匹配节点时向前读入的最大节点数;S用于计算两个程序流图的相似值.输出为类对集合CP、接口对集合IP、方法对集合MP、地址对集合PP及以〈〈node,node〉,status〉形式的节点对集合NP.X10Diff首先完成在类与接口级别的对比,然后进行方法级别的对比及节点级别的对比.(1)对比P1和P2中的类,将匹配的类成对放入类对集合CP中.在进行类的对比的时候,算法会寻找P1中与P2中名字相似的类,并输出匹配类对集合(CP).那些未被加入CP的P1中的类,是被删除的类,而P2中未被加入CP中的类,是新增类.(2)对比P1和P2中的接口,并采用类似类匹配的方法判断删除或新增接口,将匹配的接口成对放入集合IP中.(3)在每一对类或者接口中继续匹配方法.算法匹配P1与P2中具有相同(或相似)签名的方法,并输出匹配方法对集合(MP).P1中未出现的在MP中的方法为在后一版本中被删除的方法,反之则为后一版本中新增的方法.(4)节点匹配过程中,算法为匹配好的方法对〈m1,m2〉创建控制流图G1和G2及建立扩展的程序流图,并实现程序流图中泳道的匹配,将匹配成功的活动地址对〈place1,place2〉加入到PP中.将每一对匹配的泳道中的程序子流图分别折叠到一个节点.接下来,利用Match算法匹配简化图,创建节点对集NP.算法结束时,会输出成对节点的集合,也会返回匹配成功的类对CP、接口对IP和方法对MP、地Page9址对PP.5.4X10Diff支撑工具架构我们基于上述算法开发了X10Diff工具,以识别程序之间的差别.X10Diff工具以两个X10程序为输入,输出报告为这两个程序的差别信息.图8展示了X10Diff工具的开发框架.针对目标程序,X10Diff基于WALA(Watson分析库①)对其进行语法分析,生成抽象语法树,并在抽象语法树的基础上完成类、接口和方法的匹配与差别分析.X10Diff接下来进行程序语义分析,生成控制流图.我们也利用WALA框架为程序源码生成控制流图,并利用Leopard地址分析算法分析程序中地址、活动与对象信息.接下来,X10Diff在多泳道程序控制流图的基础上,利用匹配算法完成两个同构图匹配与活动内语句的差别分析,生成程序差别信息.5.5实验效果研究中选择X10程序样例程序②进行实验,以检验X10Diff的效果.实验中安排两组独立的参与人员:程序差别植入者负责在X10程序中植入若干程序差别,程序差别分析者采用X10Diff对程序差别予以识别.实验主要步骤包括:(1)植入程序差别.程序差别植入者针对被分析程序,手工植入若干差别,即对程序进行修改,并在植入过程中对修改点予以记录.手工植入的程序差别类型包括对类、方法、地址、语句等各级别的修改,并保证每个程序的修改程度小于10%,以使得程序不同版本之间得到匹配.这里将植入的程序差别集合记为Diff1.这一步骤后,可以获得修改前后的程序版本供程序差别分析.注意的是,实验中未能够严格保证修改后的程序是能够被执行的.(2)程序差别分析.程序差别分析者独立采用X10Diff进行识别差别,从而识别出程序中的类、方法、地址、语句等的匹配关系及程序差别.我们将识别出的程序差别集合记录为Diff2.实验结束后,实验参与者对比Diff1和Diff2,以验证X10Diff的效果.实验结果如表3所示.这里,我们将(Diff1-Diff2)记录为差别漏报,将(Diff2-Diff1)记录为差别误报.识别率X10DiffRate=#(Diff1∩Diff2)/#Diff1,误报率FalsePositiveRate=#(Diff2-Diff1)/#Diff2.实验结果表明,X10Diff可以识别程序中83%的差别,但也存在17%的漏报率和17%的误报率.程序手工植入ArrayCopy1地址11000MontePi11语句210050MontePi22类、语句310033MontePiAsync2地址、表达式1500MontePiAsync22表达式21000MontePiCluster2方法、地址21000MontePiCluster22表达式、地址1500合计12/10(识别)+进一步的分析表明,被疏忽的差别主要来源于地址的计算,即静态计算不能获取准确的地址,对地址的匹配会存在失误.而误报主要原因在于语句进行了次序调整,例如,在植入错误的时候被记为1处差别,但在分析过程中被记为多处差别.6相关工作典型的程序差别分析方法可以分为两类:基于程序语法的和基于程序语义的.前者强调以程序文本、程序结构、语法树为基础,实现程序差别分析.GNUDiffutils③是一个用来定位文件差别的工具①②③Page10集,通过使用diff命令,用户可以定位两个文件(包括程序)之间区别,并采用按行输出的方式输出这些区别.Duley等人[6]提出针对VerilogHDL语言的程序差别算法,该算法可以将Verilog特定的变化类型以语法形式报告出来.Tsantalis等人[7]开发了一个基于网络的差别分析工具WebDiff,其核心算法为树差别算法VTracker,该算法可以将XML文档表示为偏序树,并进行差别分析.UMLDiff是一个用于UML类图的差别分析工具,可以识别出UML类图中对类的增、删、改等操作[8].然而,程序是具有语义的,上述基于语法或程序结构的程序差别分析方法并不能识别程序语义上的差异.基于语义的程序差别分析方法需要根据目标语言来设计.对于传统顺序程序语言(如C)和面向对象程序语言(如C++、Java等),目前均已存在程序差别算法并已经被广泛应用到程序分析中.例如BMAT[2]、Semanticdiff[3]及Horwitz的技术[4]等主要用于处理面向过程的程序.Term提出的差别分析算法[9]主要针对Java程序.Grg等人[10]提出了针对AspectJ程序的面向方面程序差别分析方法等.Loh和Kim开发了一个逻辑结构差别分析工具LSdiff[11-12],可以自动将程序结构差别识别为一组与变化相关的逻辑规则.CloneDifferentiator是一个用于对程序克隆实现差别分析的工具[13],其从程序依赖图中获取克隆中的语义信息,并使用图形匹配技术计算精确的克隆差别.对于基于PGAS模型的X10语言,其程序分析方法并不成熟.本文针对X10这一高性能计算语言,研究相关程序差别分析方法.X10Diff是一个基于语义的程序差别分析方法.就目前所检索到的文献资料而言,几乎没有基于语义的并行程序差别分析方法,而X10Diff则对此方面进行了探索.此外,X10Diff在差别分析过程中结合了逻辑地址计算和活动匹配方法,有效地提高了分析的精度.7结束语对并行程序中程序差别的识别对于并行程序分析、测试、理解和维护有很重要的作用.本文提出了比对两个X10程序并寻找语句级差别的算法X10Diff:给出两个X10程序,识别匹配的类与方法,建立每一个匹配方法对和地址对,并比较活动、语句等方面的差别.本文所提出的方法对其他并行语言的程序分析同样有启示作用,比如说CrayInc.开发的Chapel或是Sun开发的Fortress语言.进一步的工作主要包括:现在对Place的处理方法仍不能识别比较复杂的程序机制,如时钟、原子块等,需要进一步解决这些机制基础上的并行程序的差别分析;将X10程序差别分析的工具集成到X10集成开发工作中;进行综合实验,以检验算法的实际效果等.
