Page1基于马尔可夫模型的软件错误定位方法张云乾1),2)郑征3)季晓慧2)张文博4)张震宇1)1)(中国科学院软件研究所计算机科学理论国家重点实验室北京100190)2)(中国地质大学计算机科学与技术系北京100083)3)(北京航空航天大学自动化科学与电气工程学院北京100191)4)(中国科学院软件研究所软件工程技术研究开发中心北京100190)摘要软件调试是软件开发的重要环节.统计错误定位技术通过分析程序执行频谱来估计程序中错误所在的位置.针对不同类型的程序频谱,此类技术建立不同的启发式模型描述程序行为.已有研究表明,其准确度同目标错误和程序类型相关,且不存在某种普遍有效的技术.文中从单元测试的特性出发,探讨预测错误类型的可行性,并采用马尔可夫过程对错误类型进行预测,从错误定位技术备选集中选择适合的技术来实施.实验表明文中方法能够更快地定位程序错误.关键词软件错误定位;软件错误类型;错误类型预测;马尔可夫模型1引言计算机的应用越来越多地深入到人们的日常生活中,然而计算机软件还远没有达到零错误的要求.提高软件质量已经成为软件工程领域亟待解决的重要问题.软件调试,作为一种提高软件质量的重要手段而备受重视.在软件的开发生命周期中,软件调试Page2是一个耗时耗力的过程,已成为软件开发的瓶颈之一[1].因此,改进、改善软件调试技术变得十分迫切与重要.调试一个软件错误通常包括两个步骤:对错误进行定位和对错误进行修复.为修复一个软件错误,开发者必须先要对其进行定位,因此,针对软件错误定位技术的研究具有十分重要的现实意义与作用[2].统计错误定位技术[3]通过建立启发式模型来描述程序特征频谱上的动态程序行为,例如程序的覆盖信息[1]、语句的执行次数[4]等,并使用启发式算法预测程序中错误所在的位置.近年来,人们用不同规模、不同语言及不同领域的程序对此类技术的错误定位准确度进行实验,取得了令人满意的成果[1,3,5-10].统计错误定位技术往往是针对不同的错误类型或程序特征而设计的.例如,Yu等人[8]提出了用于定位分支错误的统计错误定位技术.Minus技术针对的是Java程序的Jimple代码中的错误.我们之前的研究[11]是针对谓词进行动态程序频谱分析,进而准确定位软件错误.已有的研究结果表明,应用错误定位技术对软件错误进行定位的准确度与错误模式[7]、测试用例集分布[8]以及其它很多影响因素都相关.举例来说,Wang等人[7]对巧合一致性问题进行了研究,就常见错误类型的数据及控制流模式进行分析,对程序覆盖信息进行调整以有效地定位程序错误.文献[9]提出了FOnly技术,该技术适用于仅有失败测试用例的情况(例如用户反馈的错误报告);在同时可以参考成功测试用例的情况下,优势相比同类技术并不明显.大部分此类实验研究都表明,一项错误定位技术在针对特定类型的错误时,有可能比其它技术更有效;然而,任何一项技术都未被证实在任意目标错误类型和程序特征下都具有比其它技术更高的定位准确性(或是在一般意义上比其它技术更有效)[4-6,8,11].在现代软件研制过程中,由于新的开发技术、开发过程以及编程环境等的影响,程序特征及错误类型愈来愈多,进而增加了选择错误定位技术的难度.在这种情况下,如果随机挑选,可能导致定位错误的效果很差,而选择所有的技术进行尝试则代价过大也不可行.因此,如何根据不同的错误类型或者程序特征选择适合的自动化软件错误定位技术是值得研究的.据了解,相关工作还没有系统地展开.本文提出一种应用马尔可夫模型的辅助错误定位的新方法.我们对错误进行分类,评价备选集中的各个错误定位技术对于各类错误的定位准确度,使用马尔可夫模型预测目标错误的类型,从而从备选集中选择最佳的错误定位技术来实施.本文的创新点及贡献包括:(1)分析了单元测试过程中对错误类型进行预测的可行性,设计实现了基于马尔可夫模型的错误类型预测模型;(2)提出使用错误定位技术备选集进行错误定位的方法,并实现了原型系统;(3)使用通用的Siemens数据集和真实的Unix工具程序对本文提出的方法进行实验验证,结果表明,相比6种典型的错误定位技术的单独使用,本文的方法能够更快地定位到软件错误;(4)分析了本文方法应用在不同类型、不同粒度级别错误定位技术及应用在混合类型、混合粒度级别错误定位技术时的效果.结果表明,本文方法在应用于相同类型、相同粒度级别的错误定位技术时有效;更适用于较粗粒度的错误定位技术,且在基于语句的错误定位技术上显示出最佳的错误定位效果.本文第2节对单元测试中的错误类型预测进行可行性分析,解释本文错误定位方法的动机;第3节介绍基于马尔可夫模型的错误定位方法;第4节使用Siemens数据集和Unix工具程序进行实验验证;第5节总结并探讨未来的方向.2研究动机实践经验告诉我们,单元测试中发现的错误的类型和属性往往是相关的.首先,单元测试专注于某一个待测程序,同一程序中存在的错误会继承类似的属性.例如,科学计算库的程序实现包括大量的浮点计算语句和函数调用.高可靠性应用领域的程序往往具有更多的条件语句、分支语句和边界检查.此类程序中的错误更可能存在于谓词上.其次,同一待测程序中存在的多个错误可能是由同一程序员注入的.程序员固有的编程习惯有可能导致其编码的错误具有相似的语义结构或逻辑结构.第三,由于单元测试专注于某一个待测程序,在单元测试中发现的多个程序错误很大程度上来自于同一函数或程序模块.受到相同程序结构的影响,程序中存在的错误也将具有相似的类型.最后,程序员常常针对特定类型的错误而设计测试用例集.例如,程序员会为定位内存泄露错误而专门设计测试用例集.为专有目的服务的测试用例Page3集的使用,使得在测试中发现同类错误的可能性被提高.通过以上原因的分析,我们认为,在单元测试的实践过程中发现的多个错误更有可能具有同样或类似的类型.因此,当某种错误定位技术能够准确定位某个错误时,对于同一待测程序中存在的其它错误往往也具有较好的定位效果.如果我们把单元测试中出现的错误看作是一个随机事件序列,那么各个事件并不彼此独立,而是具有很大程度的相关性.我们由此得知单元测试过程中出现的错误类型具有相关的属性.因此,对其进行预测是可行的.本节分析了在单元测试中预测错误类型的可行性.各个错误间因具有类似的属性而(在使用某个特定技术对其定位时)呈现相近的定位难度.因此,可以通过对错误类型的预测来选择最有效的错误定位技术.然而,这样的初步解决方法仍存在具体的操作问题和不详尽之处.例如,如何科学地描述错误类型?使用何种机制来预测错误类型?如何选择适合的技术来实施?在本文的下一节中,我们将对这些问题进行解释,给出本文提出的基于马尔可夫模型的错误定位方法的步骤及其复杂度分析.3基于马尔可夫模型的错误定位方法本节首先阐述问题设定,然后提出错误定位模型,并进行复杂度分析.3.1问题设定统计错误定位问题通常使用如下的问题设定.假设X是错误程序的语句集,F∪S是测试用例集,F表示失败的测试用例集,S表示成功的测试用例集.当程序运行一个测试用例t(t∈F∪S)时,语句x(x∈X)被执行的次数表示为E(t,x).错误定位的目标是得到一个可疑语句列表L(即X的一个排列),L中的语句按照其错误可疑度进行降序排列[9].假定有m个此类技术作为备选集供使用,表示为T1,T2,…,Tm,其中Ti代表第i个此类技术.B0,B1,…,Bn-1表示最后n个被定位和修复的错误,其中Bj代表第j个错误.在前n个(最后n个)错误被定位到后,基于这样的先验知识我们可以知道每个技术Ti在定位每个错误Bj时的定位准确度(用Yj表示).Yj准确度越高.在本文中,利用错误类型预测技术来对下一个错误Bn进行定位的目标是找到一个Ti,使得Tk,Yn3.2本文提出的错误定位方法基于对错误类型的预测,本文提出的错误定位方法具有如下的步骤:(1)利用历史中已定位到的错误类型序列建立一步转移概率矩阵;(2)预测下一个错误类型并选择最佳的错误定位技术;(3)依据所选用技术的输出进行错误定位,根据定位到的错误进一步更新历史信息.下面我们对每个步骤进行详细阐述.步骤1.错误定位技术在对程序运行进行分析后,输出L表示可疑的语句列表.已有的研究工作(例如文献[3-4,7-9,11-12])常使用错误在L中的位置来计算评价指标Yj语句列表能够有效地辅助定位错误.鉴于不同技术在定位不同类型错误时的准确度不同,且目前尚无通用的错误类型描述手段,本文不失一般性地使用错误定位技术的种类对错误进行分类.错误Bj的类型标示为定位错误Bj的最佳技术Cj.我们将软件开发过程中出现错误的类型视作一个离散时间随机过程,并选用通用的马尔可夫模型[13]来对错误类型进行预测.这里,Q是软件开发过程中发现的错误类型的观测序列.根据观测序列Q,可以建立用于预测错误类型的一步转移概率矩阵[13].该一步转移概率矩阵用犘表示如下.其中,pu,v表示在观察到出现类型u错误后紧接着出现类型v错误的条件概率.特别地,pu,u表示连续两次出现类型u的错误的条件概率.按照一步转移概率矩阵的计算方法,pu,v计算如下.pu,v=nu,v=sizeofCjCj=u,Cj+1=当无法从历史信息估计转移概率时,分配相同的转移概率.Page4步骤2.根据建立的一步转移概率矩阵和上次错误的类型,预测当前的错误类型,并选用适当的错误定位技术.当前错误的类型珟Cn计算如下:按照预测的错误类型珟Cn,我们选择错误定位技术T珟Cn来实施.特别地,当珟Cn不唯一时,我们选择编号最小的技术来实施.这时,我们采用如下的方式计算:步骤3.在程序员使用选定的错误定位技术TCn对错误进行定位后,即确定了程序中错误所在的语句.这时,我们根据错误所在的语句来计算各个错误定位技术Ti在定位该错误Bn时的定位准确度Yn确定错误的真实类型:类似地,当Cn不唯一时,我们选择编号最小的类型标注.这时,采用如下的方式计算Cn:在求得错误Bn的类型Cn后,我们将观测序列Q更新为Q=〈C0,C1,…,Cn-1〉,并相应地更新一步转移概率矩阵犘.3.3复杂度分析本文提出的错误定位方法的复杂度是同其使用的错误定位技术的复杂度相关的,表示为O(|X|·m·n·O1).|X|代表语句的数目,m是技术的数目,n是已定位到的错误的数目,O1是使用的错误定位技术的复杂度.由于在历史记录的积累过程中犘可以被增量更新,模型的复杂度可以进一步减少到O(|X|·m·O1).受到篇幅限制,这里不叙述具体的推导过程.表1用于实验的错误定位技术(名称、作者、年代、出处、类型、粒度级别)错误定位技术作者年份Tarantula[3]Jones等2002InternationalConferenceofSoftwareEngineeringFOnly[9]CBI[16]SOBER[6]DES-CBI[11]Zhang等2010DES-SOBER[11]Zhang等20104.2实验设计我们按照错误版本的顺序对其进行排列,使用排列生成的错误序列来模拟软件测试的过程.为评价本文方法预测错误Bj类型的准确度和定位错误4实验验证本节采用Siemens程序包和Unix工具程序对本文的算法进行验证和比较.4.1实验对象Siemens程序包[14]由西门子公司开发,专用于评价软件测试技术的准确度,在之前的研究工作中被广泛使用[1,3-4,6,11,15-16].Siemens程序包共包含7个程序,为了充分验证本文的错误定位方法,我们选用其中错误版本数目最多的程序包tcas.程序包tcas共有41个错误版本,每个错误版本中均含有一个人工注入的错误语句.由于每个错误版本存在微小差异,tcas的程序中大约包括135行左右的可执行代码.程序包tcas共有1608个测试用例.Unix工具程序是演化中的真实程序,在前期工作中被广泛用于评价错误定位技术的效果[11,17].举例来说,sed包括从1.18~3.02等5个演化版本,共包括16个错误版本,每个错误版本中均包含一个错误.其程序规模从4756~9289不等,共有370个测试用例.使用这样中等规模的程序进行试验,能够反映本文方法在真实程序上的应用效果.用于实验的错误定位技术有6种,分别为Tarantula[3]、FOnly[9]、CBI[16]、SOBER[6]以及DES-CBI[11]和DES-SOBER[11].这6项技术均为代表性的统计错误定位技术,其中Tarantula和FOnly为基于语句的错误定位技术,CBI和SOBER为复合表达式粒度级别的基于谓词的错误定位技术,DES-CBI和DES-SOBER为原子表达式粒度级别的基于谓词的错误定位技术.表1中列出了这些实验技术的作者、发表年代、出处、类型和粒度级别.出处Bj的准确度,实验中使用前j个错误作为错误定位的历史记录.进而,按照第3节中方法的实施步骤预测错误类型,实施相应的错误定位技术.由于用于实验的6项技术分别属于2种不同类Page5型和3种不同粒度级别的错误定位技术,我们设计了10个实验来对本文方法进行多维评估.实验1.使用实验程序(Siemens程序),将基于语句的错误定位技术Tarantula与FOnly作为实验对象对本文提出的错误定位方法进行评估.实验2.使用实验程序(Siemens程序)复合表达式粒度级别的基于谓词的错误定位技术CBI与SOBER作为实验对象对本文提出的错误定位方法进行评估.实验3.使用实验程序(Siemens程序),将原子表达式粒度级别的基于谓词错误定位技术DES-CBI与DES-SOBER作为实验对象对本文提出的错误定位方法进行评估.实验4.使用实验程序(Siemens程序),将基于语句的错误定位技术Tarantula与FOnly以及复合表达式粒度级别的基于谓词的错误定位技术CBI与SOBER作为实验对象对本文提出的错误定位方法进行评估.实验5.使用实验程序(Siemens程序),将复合表达式粒度级别的谓词错误定位技术CBI与SOBER以及原子表达式粒度级别的谓词错误定位技术DES-CBI与DES-SOBER作为实验对象对本文提出的错误定位方法进行评估.实验6.使用真实程序(Unix程序),将基于语句的错误定位技术Tarantula与FOnly作为实验对象对本文提出的错误定位方法进行评估.实验7.使用真实程序(Unix程序),将复合表达式粒度级别的基于谓词的错误定位技术CBI与SOBER作为实验对象对本文提出的错误定位方法进行评估.实验8.使用真实程序(Unix程序),将原子表达式粒度级别的基于谓词错误定位技术DES-CBI与DES-SOBER作为实验对象对本文提出的错误定位方法进行评估.实验9.使用真实程序(Unix程序),将基于语句的错误定位技术Tarantula与FOnly以及复合表达式粒度级别的基于谓词的错误定位技术CBI与SOBER作为实验对象对本文提出的错误定位方法进行评估.实验10.使用真实程序(Unix程序),将复合表达式粒度级别的谓词错误定位技术CBI与SOBER以及原子表达式粒度级别的谓词错误定位技术DES-CBI与DES-SOBER作为实验对象对本文提出的错误定位方法进行评估.实验1、6的目的在于分析本文错误定位方法用于基于语句的错误定位方法上的可行性和准确度;实验2、7的目的在于分析本文错误定位方法用于复合表达式的基于谓词的错误定位方法上的效果;实验3、8的目的是分析本文方法用于原子表达式上的基于谓词的错误定位方法的有效性;实验4、9的目的在于分析本文错误定位方法用于混合类型错误定位技术的可行性与效果;实验5、10的目的在于分析本文错误定位方法用于混合粒度错误定位技术的效果.4.3评价指标我们使用预测正确率(Correctness)、查准率(Precision)和查全率(Recall)来评估错误类型预测的准确度.预测正确率定义为对n个程序错误进行类型预测的平均正确率.利用如下公式计算.某类型C的查准率定义为错误被预测为类型C时正确预测的比例,某类型C的查全率定义为类型C的错误被预测为类型C的比例.本文方法的查准率为各个类型查准率的平均值,本文方法的查全率为各个类型查全率的平均值.查准率和查全率使用如下的公式进行计算.Precision=1Recall=1我们用定位代价(Expense[3,9])来评估错误定位的准确度.某个错误Bj的定位代价定义为:使用选定的错误定位技术定位该错误时,错误存在于该错误定位技术输出可疑语句列表L中的位置.本文方法的定位代价为定位各错误的定位代价的平均值,用如下公式进行计算.4.4实验结果分析我们依据实验步骤进行实验验证,并使用评价指标对实验结果进行分析.为了更直观地观察实验结果,我们将各技术及本文方法的定位准确度用图形方式表示并进行比较和结果分析.实验1.图1表示了Tarantula、FOnly及本文方法在定位实验程序中的41个错误时的定位代价.在图1中,x轴表示错误序列,共包括41个错误,y轴表示不同技术定位错误的准确度,用Expense评价指标Page6度量.图中的三角形表示Tarantula定位各个错误时的准确度,圆形表示FOnly定位各个错误时的准确度.连线表示本文方法对错误类型的预测以及对相应的方法(Tarantula或FOnly)的选用.图1错误定位方法的预测准确度与定位准确度分析以连线的前5段为例进行说明,在定位第一个错误时,由于没有历史数据供参考(错误类型观测序列Q为空集),一步转移概率矩阵中的概率均为0.50,此时的一步转移概率矩阵如下所示:在此情况下选用了Tarantula技术来实施错误定位,Tarantula技术使用1.73%的定位代价定位到了这个错误.我们后验地检查FOnly对此错误的定位效果,发现FOnly技术使用了8.09%的定位代价定位到了这个错误.因此判定此错误为0型错误,并更新错误类型观测序列为Q=〈0〉.在对第2个错误进行定位时,情况类似,依然选择了Tarantula技术来实施.同时,定位到的错误依然为0型错误,错误类型观测序列被更新为Q=〈0,0〉.这时,由于前两次连续出现了0型错误,此时的一步转移概率矩阵如下式所示:在对第3个错误进行定位时,依照一步转移概率矩阵的建议选用Tarantula技术,预测正确.在对第4个错误进行定位时选用了Tarantula技术.然而结果表明FOnly技术能够更有效地定位该错误,该错误为1型错误;因此对第4个错误进行的类型预测失败.第5个错误被预测为1型错误,预测失败.第6个错误被预测为0型,预测正确.总体来看,用本文方法在41次预测中,26次预测正确,15次预测错误,正确率为63.7%,查准率为61.3%,查全率为61.3%.Tarantula的定位代价为14.9%,FOnly的定位代价为16.4%,本文方法的定位代价为14.1%.通过比较以上数据得知,本文方法比单独使用Tarantula或FOnly技术的定位代价小.结果表明,将本文方法用于基于语句的错误定位技术能够有效预测实验程序中的错误类型,并能以较高的准确度定位程序错误.实验2.图2表示了CBI、SOBER及本文方法在定位实验程序中的41个错误时的定位代价.图中的三角形表示CBI定位各个错误时的准确度,圆形表示SOBER定位各个错误时的准确度.连线表示本文方法对错误类型的预测以及对相应的方法(CBI或SOBER)的选用.图2的结构和图例与图1相同,限于篇幅限制不再赘述.图2错误定位方法的预测准确度与定位准确度分析图2表明,用本文方法在41次预测中,24次预测正确,17次预测错误,正确率为58.5%,查准率为56.0%,查全率为55.9%.查准率和查全率相比使用基于语句的错误定位技术时有所下降.CBI的定位代价为26.5%,SOBER的定位代价为29.3%,本文方法的定位代价为26.0%.通过以上数据得知,本文方法比单独使用CBI或SOBER的定位代价小.结果表明,将本文方法用于基于谓词的错误定位技术能较有效地预测实验程序中的错误类型,并能够相对准确地定位程序错误.实验3.图3表示了DES-CBI、DES-SOBER及本文方法在定位实验程序中的41个错误时的定位代价.图中的三角形表示DES-CBI定位各个错误时的准确度,圆形表示DES-SOBER定位各个错误时的准确度.连线表示本文方法对错误类型的预测以及对相应的方法(DES-CBI或DES-SOBER)的选用.图3Page7的结构和图例与图1和图2相同,限于篇幅限制不再赘述.图3错误定位方法的预测准确度与定位准确度分析(DES-CBI和DES-SOBER技术技术用于实验程序)图3表明,用本文方法在41次预测中,23次预测正确,18次预测错误,正确率为56.1%,查准率为45.2%,查全率为47.1%,查准率和查全率低于50%.DES-CBI的定位代价为26.4%,DES-SOBER的定位代价为22.0%,本文方法的定位代价为24.6%.比较得知,本文方法比单独使用DES-CBI的定位代价小,但是比单独使用DES-SOBER的定位代价大.结果表明,将本文方法用于原子表达式粒度级别的错误定位技术效预测实验程序中的错误类型效果不明显,且定位错误的准确度不高.实验4.图4表示了Tarantula、FOnly、CBI、SOBER及本文方法在定位实验程序中的41个错误时的定位代价.图中的三角形表示Tarantula定位各个错误时的准确度,圆形表示FOnly定位各个错误时的准确度,方形表示CBI定位各个错误时的准确度,叉表示SOBER定位各个错误时的准确度.连线表示图4错误定位方法的预测准确度与定位准确度分析(Tarantula、FOnly、CBI和SOBER技术技术用于实验程序)本文方法对错误类型的预测以及对相应的方法(Tarantula、FOnly、CBI或SOBER)的选用.图4的结构和图例与图1、图2、图3相同,限于篇幅限制不再赘述.图4表明,用本文方法在41次预测中,13次预测正确,28次预测错误,正确率为22.0%,查准率为21.1%,查全率为19.2%.查准率和查全率有明显下降.Tarantula的定位代价为14.9%,FOnly的定位代价为16.4%,CBI的定位代价为26.5%,SOBER的定位代价为29.3%,本文方法的定位代价为23.5%.通过比较以上数据得知,本文方法比单独使用CBI或SOBER的定位代价小,但是比单独使用Tarantula、FOnly技术的定位代价大.结果表明,将本文方法用于混合类型的错误定位技术不能有效预测实验程序中的错误类型,且定位程序错误的准确度较低.实验5.图5表示了CBI、SOBER、DES-CBI、DES-SOBER及本文方法在定位实验程序中的41个错误时的定位代价.图中的三角形表示CBI定位各个错误时的准确度,圆形表示SOBER定位各个错误时的准确度,方形表示DES-CBI定位各个错误时的准确度,叉表示DES-SOBER定位各个错误时的准确度.连线表示本文方法对错误类型的预测以及对相应的方法(CBI、SOBER、DES-CBI或DES-SOBER)的选用.图5的结构与图1、图2、图3、图4相同,限于篇幅限制不再赘述.图5错误定位方法的预测准确度与定位准确度分析图5表明,用本文方法在41次预测中,13次预测正确,28次预测错误,正确率为31.7%,查准率为22.6%,查全率为14.3%.查准率和查全率明显偏低.CBI的定位代价为26.5%,SOBER的定位代价Page8为29.3%,DES-CBI的定位代价为26.4%,DES-SOBER的定位代价为22.0%,本文方法的定位代价为24.7%.通过比较以上数据得知,本文方法比单独使用CBI、SOBER、DES-CBI的定位代价小,但是比单独使用DES-SOBER技术的定位代价大.结果表明,将本文方法用于混合粒度的错误定位技术不能有效预测实验程序中的错误类型,且定位程序错误的准确度不高.实验6.图6表示了Tarantula、FOnly及本文方法在定位真实程序中的16个错误时的定位代价.图中的三角形表示Tarantula定位各个错误时的准确度,圆形表示FOnly定位各个错误时的准确度.连线表示本文方法对错误类型的预测以及对相应的方法(Tarantula或FOnly)的选用.图6的结构与图1相同,限于篇幅限制不再赘述.图6错误定位方法的预测准确度与定位准确度分析图6表明,用本文方法在16次预测中,13次预测正确,3次预测错误,正确率为81.25%,查准率为75.5%,查全率为79.2%.Tarantula的定位错误的平均代价是13.6%,FOnly的定位代价为3.43%,本方法的定位代价为2.44%.通过比较以上数据得知,本文方法比单独使用Tarantula或FOnly技术的定位代价小.结果表明,将本文方法用于基于语句的错误定位技术能够有效预测真实程序中的错误类型,并能够准确定位程序中的错误.实验7.图7表示了CBI、SOBER及本文方法在定位真实程序中的16个错误时的定位代价.图中的三角形表示CBI定位各个错误时的准确度,圆形表示SOBER定位各个错误时的准确度.连线表示本文方法对错误类型的预测以及对相应的方法(CBI或SOBER)的选用.图7的结构与图2相同,限于篇幅限制不再赘述.图7错误定位方法的预测准确度与定位准确度分析图7表明,用本文方法在16次预测中,11次预测正确,5次预测错误,正确率为68.75%,查准率为36.7%,查全率为45.8%.查准率和查全率均低于50%.CBI的定位代价是17.8%,SOBER的定位代价为22.9%,本方法的定位代价为18.3%.通过比较以上数据得知,本文方法比单独使用CBI定位代价大,但比单独使用SOBER技术的定位代价小.结果表明,将本文方法用于复合表达式粒度级别的基于谓词的错误定位技术能够预测真实程序中的错误类型,然而定位程序错误的准确度受到影响.实验8.图8表示了DES-CBI、DES-SOBER及本文方法在定位真实程序中的16个错误时的定位代价.图中的三角形表示DES-CBI定位各个错误时的准确度,圆形表示DES-SOBER定位各个错误时的准确度.连线表示本文方法对错误类型的预测以及对相应的方法(DES-CBI或DES-SOBER)的选用.图8的结构与图3相同,这里不再介绍.图8错误定位方法的预测准确度与定位准确度分析(DES-CBI和DES-SOBER技术用于真实程序)Page9图8表明,用本文方法在16次预测中,9次预测正确,7次预测错误,正确率为56.25%,查准率为30%,查全率为44.4%.查准率和查全率进一步降低.DES-CBI的定位代价是19.6%,DESSOBER的定位代价为20.4%,本方法的定位代价为20.6%.通过比较以上数据得知,本文方法比单独使用DES-CBI或DES-SOBER技术的定位代价大.结果表明,将本文方法用于原子表达式粒度级别的错误定位技术预测真实程序中的错误类型的效果不明显,且定位程序错误准确度受到影响.实验9.图9表示了Tarantula、FOnly、CBI、SOBER及本文方法在定位真实程序中的16个错误时的定位代价.图中的三角形表示Tarantula定位各个错误时的准确度,圆形表示FOnly定位各个错误时的准确度,方形表示CBI定位各个错误时的准确度,叉表示SOBER定位各个错误时的准确度.连线表示本文方法对错误类型的预测以及对相应的方法(Tarantula、FOnly、CBI或SOBER)的选用.图9的结构和图例与图4相同,限于篇幅限制不再赘述.图9错误定位方法的预测准确度与定位准确度分析(Tarantula、FOnly、CBI和SOBER技术用于真实程序)图9表明,用本文方法在16次预测中,3次预测正确,13次预测错误,正确率为18.75%,查准率为10.8%,查全率为12.3%.查准率和查全率明显偏低.Tarantula的定位代价为13.6%,FOnly的定位代价为3.4%,CBI的定位代价为17.8%,SOBER的定位代价为22.9%,本文方法的定位代价为14.6%.通过比较以上数据得知,本文方法比单独使用CBI或SOBER的定位代价小,但是比单独使用Tarantula或FOnly技术的定位代价大.结果表明,将本文方法用于混合类型的错误定位技术不能准确预测真实程序中的错误类型,且定位程序错误的准确度不高.实验10.图10表示了CBI、SOBER、DES-CBI、DES-SOBER及本文方法在定位真实程序中的16个错误时的定位代价.图中的三角形表示CBI定位各个错误时的准确度,圆形表示SOBER定位各个错误时的准确度,方形表示DES-CBI定位各个错误时的准确度,叉表示DES-SOBER定位各个错误时的准确度.连线表示本文方法对错误类型的预测以及对相应的方法(CBI、SOBER、DES-CBI或DES-SOBER)的选用.图10的结构与图5相同,限于篇幅限制不再赘述.图10错误定位方法的预测准确度与定位准确度分析(CBI、SOBER、DES-CBI和DES-SOBER技术用于真实程序)图10表明,用本文方法在16次预测中,5次预测正确,16次预测错误,正确率为31.25%,查准率为20.8%,查全率为12.5%.查准率和查全率明显偏低.CBI的定位代价为17.8%,SOBER的定位代价为22.9%,DES-CBI的定位代价为19.6%,DES-SOBER的定位代价为20.4%,本文方法的定位代价为20.5%.通过比较以上数据得知,本文方法比单独使用SOBER技术定位代价小,比单独使用CBI、DES-CBI或DES-SOBER技术的定位代价大.结果表明,将本文方法用于混合粒度的错误定位技术不能准确预测真实程序中的错误类型,且定位错误准确度不高.4.5实验结论表2总结了实验1~实验10的观察结果,通过4.4节中对实验结果的观察与分析,结合表2,我们得到4点初步结论.Page10表2错误定位方法效果总结定位效果小型程序(Siemens实验程序)有效(Unix真实程序)有效中型程序综合结果结论1.结合实验1和实验6的分析,我们观察到,在应用基于语句的错误定位技术时,本文方法的错误预测准确度和错误定位准确度优于单独使用某个基于语句的错误定位技术.因此得出结论:本文方法适用于基于语句的错误定位技术.结论2.结合实验2、实验3、实验7和实验8的分析,我们观察到,在应用基于谓词错误定位技术时,本文方法在应用基于复合表达式的错误定位技术时能够有效预测错误,且错误定位准确度有所提高,但在应用基于原子表达式的错误定位技术时效果不佳.因此得出结论:本文方法用于基于谓词的错误定位技术时有效,但更适用于粗粒度的错误定位技术.结论3.结合实验4和实验9的分析,我们观察到,在应用相同类型错误定位技术时,本文方法的错误预测准确度和错误定位准确度表现优于应用混合类型的错误定位技术.因此得出结论:本文方法更适用于应用于相同类型的错误定位技术.结论4.结合实验5和实验10的分析,我们观察到,在应用相同粒度级别错误定位技术时,本文方法的错误预测准确度和错误定位准确度优于应用混合粒度级别错误定位技术的情况.因此得出结论:本文方法更适用于应用相同粒度级别的错误定位技术.4.6实验有效性分析实验有效性分析主要从以下几个方面进行:首先,本文评价了文中提出的错误类型预测模型的预测准确性.为了科学地评价错误类型,本文提出使用错误定位方法来甄别错误的类型.这样的好处在于:(1)能够无偏差地断定错误类型;(2)在对错误进行分类时,不需要考虑错误的内在逻辑和语言特性;(3)更便于备选错误定位技术的选择.我们依据软件开发实践和错误定位技术的研究提出这样的方法,其前提假设是大多数错误定位技术只对定位某类或某几类错误有效.对这一点的实验研究与分析能够更好地为本实验结论提供有效性保障.其次,本文提出的错误定位方法可将其它错误弱效弱效弱效定位技术组成备选集,通过评价备选集中的各个备选技术对不同类型错误的定位准确度,结合对错误类型的预测结果,选择适合的错误定位技术来实施.对备选集中的错误定位技术会影响到实验结论的有效性.为了验证本文提出的错误定位方法,我们采用了同原理错误定位技术(包括不同粒度的错误定位技术和基于不同类型频谱的错误定位技术)对本文提出的错误定位方法进行评估.在采用不同原理错误定位技术(例如将基于频谱的错误定位技术与结合静态分析技术的切片错误定位技术混用)时,我们预期有可能得到不同的实验结果.另外,本文采用公认的Siemens数据集和中型的真实UNIX工具程序对本文方法进行了实验验证.使用其它类型的程序、其它语言的程序及其它领域的程序作为实验程序将有可能得到不同的实验结果.此外,将本文的错误定位方法与其它错误定位方法结合.举例来说,Agrawal等人[18]确定可疑区域并利用切片技术分析错误位置.本文方法可与类似的错误定位技术相结合,用以确定可疑区域,并利用切片技术跟踪分析错误位置.将本文的错误定位方法与其它错误定位方法结合时有可能得出不同的实验有效性结论.最后,本文通过对各个实验的分析,得出定性的结论.这样更便于理解和对本文提出的错误定位方法的使用给出指导.在未来工作中,我们计划使用更大型的受控实验来评价本文提出的方法,并汇报定量的分析结果来提供客观评价.5总结与展望为了对软件错误进行自动化定位,人们提出了统计错误定位技术.此类技术的错误定位准确度同目标错误类型和程序特征紧密相关,如何选择适合的技术并将其实施于错误定位中,是需要解决的实际问题.本文分析了单元测试的特性及对软件错误类型进行预测的可行性,采用马尔可夫过程建立预测模Page11型,根据判定的错误类型从错误定位技术备选集中选择合适的错误定位技术来实施.实验表明,相比使用单一技术的错误定位方法,本文提出的方法能够更快地定位到程序中存在的软件错误.同时,在实验验证中,我们发现本文方法更适用于应用相同类型或相同粒度级别的错误定位技术,在应用粗粒度级别的错误定位技术时效果更好,且在基于语句的错误定位技术上效果最佳.我们相信这一发现能够有效地指导本文方法在实际中的应用.在未来的工作中,我们将研究如何有效地对本文方法进行改进,使其能够工作在不同粒度级别的错误定位技术上,并研究如何有效地对程序中存在的多个错误进行同时定位.
