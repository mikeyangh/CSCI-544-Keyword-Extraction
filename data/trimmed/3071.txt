Page1犱-子树划分问题蔡延光1)章云1)钱积新2)1)(广东工业大学自动化学院广州510006)2)(浙江大学工业控制技术国家重点实验室杭州310027)摘要边赋非负权无向简单图的一簇顶点两两不相交的子树称为它的一个d-子树划分(d为非负实数),如果这些子树的顶点集的并等于此图的顶点集,且每棵子树的直径不超过d.图的d-子树划分问题就是求它的一个含子树数最少的d-子树划分及其所含的子树数.d-子树划分问题在有线通信网络、道路交通网络、城市供水网络、电力传输网络等网络的运行管理、维护与测试中具有很强的应用背景.文中证明了对任意正实数d,边赋非负权二分平面图的d-子树划分问题是NP-完全问题;提出了求解边赋非负权树d-子树划分问题的一个线性时间算法,详细地讨论了算法的实现策略.所提出的算法具有简明易实现、耗费时间少等特点.关键词d-子树划分;子树划分;NP-完全;树;算法;复杂度1引言定义1.设G=(V,E)是一个边赋非负权的无向简单图,顶点数为n=|V(G)|,d0为实数.如果G中m棵顶点两两不相交的子树T1,T2,…,Tm满足∪mi=1V(Ti)=V(G),d(Ti)d(这里d(Ti)=maxu,v∈V(Ti)d(u,v)为Ti的直径,i=1,2,…,m),则称{T1,T2,…,Tm}为G的一个d-子树划分.G的含子树数最少的d-子树划分称为G的最小d-子树划分;最小d-子树划分所含的子树数称为G的d-子树划分数,记作πd(G).所谓G的d-子树划分问题就是求πd(G)和G的一个最小d-子树划分.d-子树划分问题在有线通信网络、道路交通网络、城市供水网络、电力传输网络等网络的运行管理、维护与测试中具有很强的应用背景.例如,在对某种有线通信网络进行维护时,需要把该通信网络中的结点划分为尽量少的组,使得每组中的结点可用一个直径不超过预定值d的树型子网通信.这就是一个d-子树划分问题.理论上看来,d-子树划分问题是路划分问题[1](pathpartitionproblem)、k-路划分问题[2](k-pathpartitionproblem)、ω-路划分问题[3](ω-pathparti-tionproblem)等的推广.如果将子树限定为路径,d为非负实数ω,则d-子树划分问题成为ω-路划分问题;当G是(边)非赋权图,ω是一个正整数k时,ω-路划分问题就是k-路划分问题;当kn-1时(实际上对路径的长度无限制),k-路划分问题简称为路划分问题.d-子树划分问题可进一步推广为图聚类问题(graphclusteringproblem),包括直径有限的子图划分问题[4].从Hamilton路的NP-完全性容易看出路划分问题属于NP-完全问题.由于k-路划分问题、ω-路划分问题是路划分问题的直接推广,因此它们也均属于NP-完全问题.到目前为止,仅对于树[5](tree)、圆弧图[6](circulararcgraph)、区间图[7](intervalgraph)、仙人掌[8](cactus)、上比较图[9](cocompara-bilitygraph)、块图[1,10-11](blockgraph)、二分置换图[10](bipartitepermutationgraph)、上图[12-13](cograph)、距离遗传图[14](distance-hereditarygraph)、P4-稀疏图[15](P4-sparsegraph)以及块为完全图、圈、完全二分图的图[16]等获得了多项式时间算法求解路划分问题.对于k-路划分问题,仅对树[17]、二分置换图[2]和仙人掌[18]等获得了多项式时间算法.对于ω-路划分问题,仅对树和森林[3]获得了多项式时间算法.由于d-子树划分问题的问题结构更加复杂,因此求解起来亦非易事.本文证明了对任何固定的d>0,边赋非负权二分平面图的d-子树划分问题是NP-完全问题.这表明即使对结构非常简单的边赋非负权图,d-子树划分问题也是非常困难的.树是一类特殊的二分平面图,也是理论研究和实际应用中最常见的网络拓扑结构之一.本文提出了求解边赋非负权树d-子树划分问题的一个线性时间算法;为了进一步提高算法的效率,还详细地讨论了算法的实现策略.所提出的算法具有简明易实现、耗费时间少等特点.定义2.考虑边赋非负权的无向简单图G=(V,E).(1)设(u,v)∈E(G),以w(u,v)表示边(u,v)的权.(2)设u,v∈V(G),以d(u,v)表示u,v之间的距离;如果P是u,v之间的最短路且d(u,v)=d(G),则称P为G的直径路;以(u~v)表示u到v的一条路径,分别以V(u~v)、E(u~v)表示(u~v)的顶点集和边集.(3)设v∈V(G),如果v的顶点度d(v)=1,则称v为G的端顶点.(4)设H,KG,以HK表示在H中删除V(K)以及与V(K)相关联的所有边而形成的子图.(5)设v∈V(G),G1是G-v的一个连通分支,称导出子图G[V(G1)∪{v}]为v(点)的一个分支;任取x∈V(G1),以G(v,x)表示v的包含x的分支.显然,x≠v,|V(G(v,x))|2.(6)设G1,G2G,V(G1)∩V(G2)={v},记G1○vG2=G1∪G2,称G1○vG2为G1,G2在v的粘合子图.显然,若G1,G2为树,则G1○vG2也是树.除非特别声明,本文所提及的图、树、路径分别指边赋非负权的无向简单图、树、路径,并分别简称为图、树、路径.约定空树也是树、空树的直径为0.文中未定义的术语和记号与文献[19]一致.为了表述方便,算法采用C语言风格设计.2犱-子树划分问题的计算复杂性分平面图的d-子树划分问题是NP-完全问题.定理1.对任意d>0的实数,边赋非负权二证明.利用平面图的顶点覆盖问题的NP-完Page3全性[20-21].设G=(V,E)是一个平面图,V={vi|i=1,2,…,n}.构造新图G1=(V1,E1)如下:V1={vi,xi,yi|i=1,2,…,n}∪E1={(vi,xi),(xi,yi)|i=1,2,…,n}∪{zij|(vi,vj)∈E(G),i<j;i,j=1,2,…,n};{(vi,zij),(zij,vj)|zij∈V(G1);i,j=1,2,…,n};对任意e∈E1,定义w(e)=d/2(见图1).容易看出,因为G是平面图及G1不含奇圈,故G1是一个边赋非负权的二分平面图.一方面,设S是G的任意最小顶点覆盖集,不妨设S={vi|i=1,2,…,m}(mn).构造G1的d-子树划分{T1,T2,…,Tm+n}如下:Ti={vi}∪{zij|zij∈V(G1),j=1,2,…,n}的导出子图(实际上是以vi为中心、直径不大于d的一颗星),i=1,2,…,m;Tm+i={xi,yi}的导出子图(实际上是K2,直径为d/2),i=1,2,…,m;Tm+i={vi,xi,yi}的导出子图(实际上是以xi为中心、直径为d的一颗星),i=m+1,m+2,…,n.因此,πd(G1)β(G)+n,其中β(G)为G的顶点覆盖数.另一方面,对G1的任何最小d-子树划分,因为其中每棵子树的直径不大于d,故含有y型顶点(这里,y型顶点是形为yi的顶点,i=1,2,…,n.以下提及的v型顶点有类似的解释)的子树必不含z型顶点(z型顶点是形为zij的顶点,zij∈V(G1);i,j=1,2,…,n);且对一切i≠j,i,j=1,2,…,n,含有yi的子树不含yj.因此,G1的任何最小d-子树划分中不含z型顶点的子树数至少为n.然而,我们有:存在G1的一个最小d-子树划分Π,使得其中任何含有z型顶点的子树恰好含一个v型顶点.事实上,设Π={T1,T2,…,Tm}是G1的任意最小d-子树划分,从Π出发,分两步构造Π.第1步.构造G1的一个最小d-子树划分Π,使得其中任何含有z型顶点的子树至少含有一个v型顶点.在Π中,如果有某棵子树譬如T1含有zij而不含v型顶点,此时必有V(T1)={zij}.考虑G1中与zij相邻的顶点vi,不妨设vi所在的子树为T2.在T2中,vi的顶点度d(vi)必等于1(否则,如果d(vi)>1,则T2是一个以vi为中心的直径为d的一颗星;因此,{T2∪(zij~vi),T3,…,Tm}是G1的一个d-子树划分,与Π的最小性相矛盾.对于d(vi)=0可类似讨论).下面分两种情形讨论.情形1.若T2不含z型顶点,则{(zij~vi),T2-vi,T3,…,Tm}是G1的一个最小d-子树划分,但其中含有z型顶点而不含有v型顶点的子树少了一棵.情形2.若T2含有z型顶点,并不妨设为zis(i<s),此时T2必含有vs(否则应有T2=(zis~vi),于是{(zij~vi)∪(zis~vi),T3,…,Tm}是G1的一个d-子树划分,与Π的最小性相矛盾),于是{(zij~vi),T2-vi,T3,…,Tm}是G1的一个最小d-子树划分,但其中含有z型顶点而不含v型顶点的子树少了一棵.重复使用上述方法,即可得到Π.第2步.从Π构造Π.设Π={T1,T2,…,Tm}.在Π中,如果有某棵子树譬如T1含有zij且含两个v型顶点(因为T1的直径不大于d,T1不可能含有两个以上的v型顶点),此时T1=(vi~zij~vj),不妨设含xi的子树为T2(显然,T2=(xi~yi)),于是{(zij~vj),T2∪(vi~xi),T3,…,Tm}是G1的一个最小d-子树划分,但含有z型顶点且含两个v型顶点的子树少了一棵.重复使用此方法,就可获得Π.在Π中,不妨设含z型顶点的子树为T1,T2,…,q,对应的v型顶点分别为v1,v2,…,vq.显然,T{v1,v2,…,vq}是G的一个顶点覆盖集,即β(G)q.但是πd(G1)=Π中含z型顶点的子树数+Π中不含z型顶点的子树数q+nβ(G)+n.因此,πd(G1)=β(G)+n.因为求β(G)为NP-完全问题,故求πd(G1)也是NP-完全问题.3边赋非负权树的犱-子树划分问题标号D.设T是一棵树,n=|V(T)|1,任选v0∈V(T).T的每个顶点v标号为l(v):l(v)=d(v,v0),称l(v)为v的标号.通过标号D标号的树T可以看作是一棵以v0为根的(倒立的)有根树;这样,我们就可使用与有根Page4如果d(v)3,则将v置于Q之首(即v进栈Q);第2步.对每个刚刚在第1步获得标号的顶点u,依次对u的每个子女v标号:l(v)=l(u)+w(u,v),如果d(v)3,则v进栈Q;树有关的一些术语,如根(顶点)、双亲(顶点)、子女(顶点)、祖先(顶点)、后代(顶点).如无特别说明,本节所论及的树T均是指按标号D对所有顶点进行标号的以v0为根的有根树.注1.标号D可在线性时间内完成.事实上,在用标号D对T的顶点进行标号时,还可建立一个包含根v0和T的所有使d(v)3的顶点v组成的有序集Q(Q实际是一个栈).Q的构造方法如下:初始,Q={v0},l(v0)=0;第1步.依次对v0的每个子女v标号:l(v)=w(v0,v),…第k步.对每个刚刚在第k-1步获得标号的顶点u,依次对u的每个子女v标号:l(v)=l(u)+w(u,v),如果d(v)3,则v进栈Q;…继续这一过程,直至T的所有顶点均已标号.因为T的每个顶点用标号D恰好标号一次,故标号D可在O(n)时间内完成.显然,如果T是路径,则Q只包含根v0;否则,Q的首元素(即栈顶元素)是使|E(v0~v)|最大的d(v)3的顶点v,即Q的栈顶元素v是T的深度最大的使d(v)3的顶点.定义3.设v∈V(T),T(v,x)是v的一个分支,如果v0V(T(v,x)-v)(即T(v,x)的顶点或者为v、或者是v的后代),则称T(v,x)为v的后代分支.注2.对于v∈V(T),v的后代分支与v的子女形成一一对应的关系.可以把v的子女看作是从左到右排列的,即把v的后代分支也看作是从左到右排列的.显然,若T(v,x)是v的一个后代分支,则存在T的端顶点y∈V(T(v,x)),y≠v,使y是T(v,x)中标号最大的顶点.把T的所有顶点分为3类:未检查、已检查和待检查,T的每个顶点属于且仅属于其中某一类.定义4.设v∈V(T),T(v,x)是v的一个分支,如果T(v,x)-v的所有顶点均为已检查顶点,则称T(v,x)为已检查(的)分支;否则称T(v,x)为未检查(的)分支.将T(v,x)标为已检查是指将T(v,x)-v的所有顶点标为已检查.特别地,如果T(v,x)是v的一个后代分支,则T(v,x)为已检查分支当且仅当v的所有后代均为已检查顶点;将T(v,x)标为已检查是指将T(v,x)中的v的全部后代标为已检查.定义5.设v∈V(T),T(v,xi)(i=1,2,…,k,k0)为v的全部(不同的)已检查的后代分支,其中xi(i=1,2,…,k)为T的端顶点且是T(v,xi)中具有最大标号的顶点,l(x1)l(x2)…l(xk);记Tv为v的全部已检查的后代分支在v的粘合子树,即Tv=T(v,x1)○vT(v,x2)○v…○vT(v,xk).定义v处的二元组(v(1),v(2))如下:当k1时定义v(1)=x1,否则v(1)=v;当k2时定义v(2)=x2,否则v(2)=v.注意,当k=0时,Tv=,d(Tv)=0.特别地,因为端顶点(除v0外)没有后代分支,故对于任意端顶点v(v≠v0):v(1)=v,v(2)=v,Tv=.3.1算法对于树T,算法1通过自底向上检查d(v)3的顶点v(即自顶向底检查栈Q中的元素)、从左到右考虑v的最左边的未检查的后代分支T(v,x)等方法求解πd(T)及T的一个最小d-子树划分Πd(T).主要步骤如下:1.初始时,将T的所有端顶点v(v≠v0)标为待检查,其余顶点标为未检查.因此,初始时,对于一切v∈V(T),有v(1)=v,v(2)=v,d(Tv)=0.但算法1只用到了v∈Q和v为端顶点的(v(1),v(2))及d(Tv);因此,算法1在执行过程中仅更新这些顶点的(v(1),v(2))及d(Tv).2.取Q的栈顶元素v,考虑v的最左边的未检查的后代分支T(v,x),转步3.当不存在未检查的后代分支T(v,x)时,如果v=v0则d(T)d,T作为Πd(T)的一个元素,结束;否则将v标为待检查,并从Q中删除v,转步2.3.如果d(T(v,x))>d,则从T(v,x)中找出Πd(T)的一个元素,并进行相关的更新,转步2;否则转步4.4.如果d(T(v,x)○vTv)>d,则T(v,x)-v、T(v,v(1))-v中必有某一个可作为Πd(T)的一个元素,辨出之,并进行相关的更新,转步2;否则转步5.5.将T(v,x)标为已检查,并进行相关的更新,转步2.以上步3、4需要计算相关子树的直径,常规方法计算树的直径需要线性时间(例如见文献[22]).这里提供了一种方法,用常数时间计算相关子树的直径(见算法1及3.2节、3.3节的讨论),从而计算所有的相关子树的直径才耗费线性时间.具体算法如下.算法1.求解边赋非负权树的d-子树划分问题.输入:树T(n1),常数d0.输出:πd(T)及T的一个最小d-子树划分Πd(T).Page5初始化:πd(T)=0;Πd(T)=;将T按标号D标号并构造Q;//片段1将T的所有端顶点v(v≠v0)标为待检查,其余顶点对于一切v∈Q或v为端顶点,v(1)=v,v(2)=v,d(Tv)=0;whileV(T)≠{取Q的栈顶元素v;//对应引理1如果不存在v的未检查的后代分支//片段4{}取v的最左边的未检查的后代分支T(v,x);//片段7取T(v,x)中的待检查顶点u(u≠v);如果l(u(1))-l(v)>d//对应引理6{}//以下处理l(u(1))-l(v)d的情形如果l(u(1))+l(v(1))-2l(v)>d//对应引理4、引理7{}//以下处理l(u(1))-l(v)d且l(u(1))+l(v(1))-{}{}}//循环结束输出πd(T)、Πd(T);结束.3.2算法的正确性除非特别声明,本小节及3.3节所讨论的T、Q分别指算法1执行过程中任何阶段的T、Q;T0、Q0分别为算法1初始时的T、Q.性质1.设T1为T的子树,v∈V(T),T(v,x)为v的任意分支,则T1(T(v,x)-v)是树.特别地,如果T是以v0为根的有根树,T(v,x)为v的任意后代分支,则T(T(v,x)-v)是以v0为根的有根树.证明.记T=T1(T(v,x)-v).因为T不含有圈,故只需证明T连通.反证,设存在y,z∈V(T),y,z在T中不存在路径相连.因为y,z在T1中有路径相连,故存在路径P=(y~z),PT1但P/T.因此,P含有T(v,x)-v中的顶点u.又因vV(T(v,x)-v),故u≠v.因为T1是树,且y,zV(T(v,x)-v),故从y到u先必经过v才能达到u,从u到z也必须最后经过v才能离开T(v,x).这样,P(y~v)∪(v~u)∪(u~v)∪(v~z).但(v~u)∪(u~v)含有圈,与P是路径相矛盾.因此,Page6T是树.特别地,取T1=T,T=T1(T(v,x)-v)=T(T(v,x)-v)是树.而当T是以v0为根的有根树、T(v,x)为v的后代分支时,因为T(v,x)-v的所有顶点都是v的后代,故v0V(T(v,x)-v),即v0∈V(T(T(v,x)-v)),从而T(T(v,x)-v是以v0为根的有根树.由此,容易得到性质2~性质4.性质2.设v∈V(T),u为v的后代,则l(u)=l(v)+d(u,v).性质3.设v∈V(T),T(v,xi)(i=1,2)为v的任意两个不同的分支,则对任意yi∈V(T(v,xi))(i=1,2),d(y1,y2)=d(y1,v)+d(y2,v).特别地,如果T(v,xi)(i=1,2)为v的任意两个不同的后代分支,则对任意yi∈V(T(v,xi))(i=1,2),d(y1,y2)=l(y1)+l(y2)-2l(v).性质4.树的直径不小于其任何子树的直径.性质5[22].设|V(T)|2,u,v∈V(T),v是T的端顶点且使d(u,v)=maxx∈V(T)d(u,x)(即v是离u最远的顶点),则存在T的直径路P使v∈V(P).引理1.若V(T)≠,则v0∈V(T),v0∈Q.证明.算法1对T的更新是在片段5通过置T=(更新后的T不满足引理的条件)、在片段10、片段12、片段14通过运算进行的.由性质1,通过运算更新后的T仍有v0∈V(T).Q是在片段1(指算法1的片段1,下类同.不再一一说明)建立的,初始的Q满足v0∈Q.对Q的更新仅在片段6进行.显然,直至算法1结束仍然有v0∈Q.引理2.设v为Q的栈顶元素,T(v,x)为v的未检查的后代分支,则(1)在T(v,x)中,存在唯一的待检查顶点u,且(2)对一切y∈V(u~v)(y≠u,y≠v),都有y(3)u的全部后代分支均是已检查分支.证明.(1)首先证明u的存在性.设u是T(v,x)中使|E(u~v)|最大的非已检查顶点(即u是T(v,x)中深度最大的非已检查顶点.u可能是待检查顶点,也可能是未检查顶点).由|E(u~v)|的最大性知,u的所有后代分支都为已检查分支.因此,u≠v.而u为v的后代表明u≠v0.由引理1知v0∈V(T),故u不是孤立点.u≠v,u≠v0,u不是孤立点;为未检查顶点且d(y)=2;我们有:u必定是待检查顶点.反证,设u是未检查顶点.首先,uQ0.否则,u∈Q0.因为v是Q的栈顶元素、u为v的后代,故uQ.因此,按算法1,u或者标为待检查(片段6),或者标为已检查(片段13、片段16),与u是未检查顶点的假设相矛盾.其次,对uQ0,u不会是端顶点,因为算法1将端顶点(除v0外)或者标为待检查(片段2、片段11),或者标为已检查(片段13、片段16).因此,u不是端顶点,且uQ0.u不是端顶点也不是孤立点表明u至少有一个后代u(注意u是已检查顶点).按算法1,u成为已检查顶点必定是在考虑离u最近的祖先w∈Q0时,将w的u所在的后代分支标为已检查所致.作为w的后代u也将同时标为已检查(片段13、片段16),与u是未检查顶点的假设相矛盾.因此,u必定是待检查顶点.下面证明u的唯一性.设u1≠v,u2≠v,且u1,u2为T(v,x)上的两个待检查顶点.情形1.u1位于u2的某个后代分支上.按算法1,当u2标为待检查时,必定有它的所有后代均为已检查顶点,故u1为已检查顶点.矛盾.类似讨论u2位于u1的某个后代分支上的情形.情形2.u1不在u2的任何后代分支上,且u2不在u1的任何后代分支上.此时路径(u1~v)、(u2~v)必在T(v,x)-v上相交,设y是标号最大的交点.因此,d(y)3,即y∈Q0.因为v是Q的栈顶元素、y为v的后代,故yQ.因此,按算法1,y要么是已检查顶点,要么是待检查顶点.不论是何种情况出现,作为y的后代,u1,u2均是已检查顶点.矛盾.综上所述,在T(v,x)中,存在唯一的待检查顶点u,且u≠v.(2)先证明对一切y∈V(u~v)(y≠u,y≠v),都有y为未检查顶点.反证,设存在y∈V(u~v)(y≠u,y≠v),y是待检查顶点或是已检查顶点.情形1.y是待检查顶点.按算法1,y要么是端顶点(但y有后代u,矛盾),要么y∈Q0(此时,类似上面的分析可得,y的所有后代均为已检查顶点,但其后代u却是待检查顶点,矛盾).因此,y不是待检查顶点.情形2.y是已检查顶点.按算法1,y成为已检查顶点必定是在考虑离y最近的祖先w∈Q0时,将w的y所在的后代分支标为已检查所致.因为y的Page7后代u也是w的后代,u将同时标为已检查.矛盾.因此,y为未检查顶点.再证明d(y)=2.反证,设存在y∈V(u~v),y≠u,y≠v,使d(y)≠2.因为y有后代u,故y不是端顶点、也不是孤立点.从而d(y)3,即y∈Q0.类似上面的分析可得,y要么是已检查顶点,要么是待检查顶点.不论是何种情况出现,y的后代u必为已检查顶点.矛盾.(3)上述证明过程(1)已经证明.证毕.注3.v、T(v,x)如引理2所设.算法1只对除v0外的端顶点、Q0中的元素标为待检查,且v0永远是未检查顶点.因此,引理2中的u要么是端顶点,要么是Q0中的元素;u(1)为T和T(v,x)的端顶点且是T(v,x)中具有最大标号的顶点.此外,根据引理2(2),可通过以下方法在v的未检查的后代分支T(v,x)中寻找唯一的待检查顶点u:从v出发,如果v的唯一子女x1为待检查顶点,则u=x1;否则考虑x1的唯一子女x2.如果x2为待检查顶点,则u=x2;否则考虑x2的唯一子女x3,…,最后必能找到待检查顶点u.根据引理2(2)和性质5,易得下面性质.性质6.设v为Q的栈顶元素,T(v,x)为v的未检查的后代分支,u为T(v,x)中的待检查顶点,则d(T(v,x))=max{d(Tu),l(u(1))-l(v)}.引理3.设v为Q的栈顶元素,T(v,x)为v的未检查的后代分支,u为T(v,x)中的待检查顶点.(1)如果l(u(1))l(v(1)),则d(T(v,x)○vTv)=max{d(T(v,x)),l(u(1))+l(v(1))-2l(v)}=max{d(Tu),l(u(1))+l(v(1))-2l(v)}.(2)如果l(u(1))<l(v(1))且l(u(1))l(v(2)),则d(T(v,x)○vTv)=max{d(Tv),l(u(1))+l(v(1))-2l(v)}.d(Tv).(3)如果l(u(1))<l(v(2)),则d(T(v,x)○vTv)=证明.根据性质4有后代分支上.由性质3有情形1.V(Tv)≠.此时u(1),v(1)在v的不同d(u(1),v(1))=l(u(1))+l(v(1))-2l(v)(3)由d(T(v,x)○vTv)d(u(1),v(1))知d(T(v,x)○vTv)l(u(1))+l(v(1))-2l(v)(4)情形2.V(Tv)=.此时v(1)=v.由性质2,d(u(1),v)=l(u(1))-l(v).故式(3)成立,从而式(4)仍然成立.(1)因为l(u(1))l(v(1)),故u(1)为T的端顶点且是T(v,x)○vTv中具有最大标号的顶点,即u(1)是T(v,x)○vTv中离v最远的端顶点.由性质5知,存在T(v,x)○vTv的直路径(u(1)~y),d(T(v,x)○vTv)=d(u(1),y),其中y∈V(T(v,x)○vTv).情形1.y∈V(T(v,x)).因为u(1)∈V(T(v,x)),故d(T(v,x))d(u(1),y)=d(T(v,x)○vTv).结合式(1)有d(T(v,x)○vTv)=d(T(v,x));再结合式(4)有d(T(v,x))l(u(1))+l(v(1))-2l(v).从而d(T(v,x)○vTv)=max{d(T(v,x)),l(u(1))+l(v(1))-2l(v)}.情形2.y∈V(Tv).因为y=v可归为情形1,不妨设y≠v.从而y在v的某个已检查的后代分支中.由性质3有d(u(1),y)=l(u(1))+l(y)-2l(v).因为l(v(1))l(y),故l(u(1))+l(v(1))-2l(v)l(u(1))+l(y)-2l(v)=d(u(1),y)=d(T(v,x)○vTv).结合式(4)有d(T(v,x)○vTv)=l(u(1))+l(v(1))-2l(v);再结合式(1)有l(u(1))+l(v(1))-2l(v)d(T(v,x)).从而d(T(v,x)○vTv)=max{d(T(v,x)),l(u(1))+l(v(1))-2l(v)}.由性质6,d(T(v,x))=max{d(Tu),l(u(1))-l(v)}.又因v(1)是v的后代,故l(v(1))l(v),即得l(u(1))-l(v)l(u(1))+l(v(1))-2l(v).从而d(T(v,x)○vTv)=max{d(T(v,x)),l(u(1))+l(v(1))-2l(v)}=max{d(Tu),l(u(1))-l(v),l(u(1))+l(v(1))-2l(v)}=max{d(Tu),l(u(1))+l(v(1))-2l(v)}.结论(1)得证.(2)因为l(u(1))l(v),再由条件l(u(1))<l(v(1))有l(v(1))>l(v),故v(1)≠v,即Tv是非空的树,v(1)是T(v,x)○vTv中离v最远的端顶点.由性质5知,存在T(v,x)○vTv的直路径(v(1)~y),d(T(v,x)○vTv)=d(v(1),y),其中y∈V(T(v,x)○vTv).情形1.y∈V(T(v,x)).由性质3,d(v(1),y)=l(v(1))+l(y)-2l(v).因为l(y)l(u(1)),故d(T(v,x)○vTv)=d(v(1),y)l(v(1))+l(u(1))-2l(v).结合式(4)有d(T(v,x)○vTv)=l(v(1))+l(u(1))-2l(v);再结合式(2)有d(T(v,x)○vTv)=max{d(Tv),l(u(1))+l(v(1))-2l(v)}.Page8情形2.y∈V(Tv).因(v(1)~y)是Tv中的路径,d(T(v,x)○vTv)=d(v(1),y)d(Tv).结合式(2),d(T(v,x)○vTv)=d(Tv);再结合式(4)有d(T(v,x)○vTv)=max{d(Tv),l(u(1))+l(v(1))-2l(v)}.(3)由条件l(u(1))<l(v(2))知l(u(1))<l(v(1)),即v(1)为T(v,x)○vTv中离v最远的端顶点.由性质5知,存在T(v,x)○vTv的直路径(v(1)~y).我们有yV(T(v,x)).否则,由性质3,d(v(1),y)=l(v(1))+l(y)-2l(v)l(v(1))+l(u(1))-2l(v)<l(v(1))+l(v(2))-2l(v)=d(v(1),v(2))d(Tv),即d(T(v,x)○vTv)=d(v(1),y)<d(Tv),与式(2)相矛盾.因此,y∈V(Tv),即(v(1)~y)是Tv中的路径,d(T(v,x)○vTv)=d(v(1),y)d(Tv);再结合式(2)有d(T(v,x)○vTv)=d(Tv).证毕.注4.v、T(v,x)、u如引理3所设.算法1在片段16将T(v,x)标为已检查后,引理3表明,算法1正确地计算了d(Tv)的新值.其中,引理3(3)表明,若l(u(1))<l(v(2)),d(Tv)保持不变.引理3(1)、(2)表明,若l(u(1))l(v(2)),按l(u(1))l(v(1))是否成立,片段17、片段18分别正确地计算了d(Tv)的新值;且d(Tv)的新值只与其原值或d(Tu)以及l(u(1))+l(v(1))-2l(v)有关.而在计算d(Tv)的新值时,d(Tu)是已知的.事实上,因u为待检查顶点,若u是端顶点,算法1在片段3和片段11,正确地置d(Tu)=0;若u∈Q0,算法1也事先计算了d(Tu).此外,不难看出,片段16执行后,对于w∈V(T)∩Q0,w≠v,Tw无变化.利用引理3及性质4,可进一步得到下面性质.性质7.设v为Q的栈顶元素,T(v,x)为v的未检查的后代分支,u为T(v,x)中的待检查顶点,则d(T(v,x)○vTv)=max{d(Tu),d(Tv),l(u(1))+l(v(1))-2l(v)}.引理4.设v为Q的栈顶元素,T(v,x)为v的未检查的后代分支,u为T(v,x)中的待检查顶点.记T为v的、除T(v,v(1))外的全部已检查的后代分支在v的粘合子树.如果d(Tv)d,l(u(1))+l(v(1))-2l(v)>d,则d(T(v,x)○vT)=max{d(Tu),l(u(1))+l(v(2))-2l(v)},l(u(1))>l(v(2)).证明.首先,l(v(1))+l(v(2))-2l(v)d(Tv)d.再由引理条件l(u(1))+l(v(1))-2l(v)>d,得l(u(1))>l(v(2)).考虑v的后代分支T(v,x)和v的、除T(v,v(1))外的全部已检查的后代分支T(v,v(2)),…,因为l(u(1))>l(v(2))…,应用引理3(1)得d(T(v,x)○vT)=d(T(v,x)○vT(v,v(2))○v…)=max{d(Tu),l(u(1))+l(v(2))-2l(v)}.注5.v、T(v,x)、u如引理4所设,并设d(Tv)d.算法1在片段13将T(v,x)标为已检查、片段14将T(v,v(1))-v通过运算删除后,引理4表明,算法1的片段15正确地计算了d(Tv)的新值.且d(Tv)的新值只与d(Tu)以及l(u(1))+l(v(1))-2l(v)有关.而在计算d(Tv)的新值时,d(Tu)是已知的(参考注4).此外,不难看出,片段13、片段14执行后,对于w∈V(T)∩Q0,w≠v,Tw无变化.性质8.若V(T)≠,v∈V(T),则d(Tv)d.证明.情形1.v为端顶点且v≠v0.显然,d(Tv)=0d.情形2.v∈Q0.应用归纳法原理证明.初始阶段,d(Tv)=0d.考虑到算法1的操作,d(Tv)仅当v的某个后代分支标为已检查、或者v的某个已检查的后代分支中的除v外的所有顶点通过运算被删除时才会发生变化.因此,按照注4、注5的说明,仅需证明:对于Q的栈顶元素v,若T(v,x)为v的未检查的后代分支、u为T(v,x)中的待检查顶点,如果在算法1的片段13、片段14、片段16执行前有d(Ty)d(一切y∈V(T)),则执行后仍然有d(Tv)d.为方便,这里将上述相关片段执行前、后的d(Tv)分别记作d(Tv)、d(Tv).(i)片段13、片段14执行后.片段13、片段14执行前满足l(u(1))+l(v(1))-2l(v)>d,l(u(1))<l(v(1)),d(Tu)d、d(Tv)d(归纳法假设).由引理4,片段13、片段14执行后,d(Tv)=max{d(Tu),l(u(1))+l(v(2))-2l(v)},而l(u(1))+l(v(2))-2l(v)<l(v(1))+l(v(2))-2l(v)d(Tv)d,因此,d(Tv)<d.(ii)片段16执行后.片段16执行前满足l(u(1))+l(v(1))-2l(v)d,d(Tu)d、d(Tv)d(归纳法假设).那么,当片段16执行后,若l(u(1))l(v(1)),由引理3(1),d(Tv)=max{d(Tu),l(u(1))+l(v(1))-2l(v)}d.若l(u(1))<l(v(1))且l(u(1))l(v(2)),由引理3(2),d(Tv)=max{d(Tv),l(u(1))+l(v(1))-2l(v)}d.Page9若l(u(1))<l(v(2)),由引理3(3),d(Tv)=d(Tv)d.情形3.v不是端顶点,且vQ0.v不是端顶点表明v有唯一子女y(因为V(T)≠,由引理1,v0∈V(T);由vQ0知v≠v0.即v不是孤立点).(i)y是已检查顶点.按算法1,y成为已检查顶点必定是在考虑离v最近的祖先w∈Q0时,将w的v所在的后代分支标为已检查所致.因此,TvTw.由性质4及情形2,d(Tv)d(Tw)d.(ii)y是未检查顶点或待检查顶点.此时Tv=,d(Tv)=0d.注6.按照性质8,引理4中的条件d(Tv)d是冗余的,可以去掉.引理5.若V(T)≠,如果v0的所有后代分支均为已检查分支,则d(T)d.证明.因为v0的所有后代分支均为已检查分支,故Tv0=T,d(T)=d(Tv0).再由性质8知,d(T)d.引理6.设v为Q的栈顶元素,T(v,x)为v的未检查的后代分支,u为T(v,x)中的待检查顶点.如果l(u(1))-l(v)>d,则在路径(u~v)中存在两个相邻的顶点z,z1,使(1)l(u(1))-l(z)d,l(u(1))-l(z1)>d;(2)存在T的最小d-子树划分Πd(T),使T(z1,u(1))-z1∈Πd(T);(3)πd(T)=πd(T(T(z1,u(1))-z1))+1;其中z1为z的双亲.证明.(1)把路径(u~v)表示为顶点序列,即(u~v)=y0y1y2…yryr+1,其中y0=u,v=yr+1.故d(u(1),yi)=d(u(1),yi-1)+w(yi-1,yi)(i=1,2,…,r+1).而w(yi-1,yi)0,故d(u(1),y0),d(u(1),y1),…,d(u(1),yr+1)是非减序列.但由性质8,d(u(1),y0)=d(u(1),u)d(Tu)d.由性质2和引理条件有d(u(1),yr+1)=d(u(1),v)=l(u(1))-l(v)>d.因此,必存在两个相邻的顶点z=yi,z1=yi+1(i=0,1,2,…,r),使d(u(1),z)d,d(u(1),z1)>d(显然,z,z1∈V(u~v),(z,z1)∈E(u~v),z1≠u,z1≠u(1),z1为z的双亲).由性质2,d(u(1),z)=l(u(1))-l(z),d(u(1),z1)=l(u(1))-l(z1).于是l(u(1))-l(z)d,l(u(1))-l(z1)>d.(2)记T1=T(z1,u(1))-z1.注意,T(z1,u(1))是z1的后代分支,且由引理2(2)知T1=Tu∪(u~z);由引理2(1),u不是孤立点.情形1.d(u)2.此时|V(Tu)|2.T1中离z最远的端顶点是u(1).由性质5,即知T1的直路径或者是Tu中的一端为u(1)的直路径、或者是(u(1)~z),即d(T1)=max{d(Tu),d(u(1),z)}=max{d(Tu),l(u(1))-l(z)},由性质8和结论(1)有d(T1)d.情形2.d(u)=1.此时Tu=,即u=u(1).因此,T1=(u~z)=(u(1)~z),d(T1)=d((u(1)~z))=d(u(1),z)=l(u(1))-l(z);由结论(1)有d(T1)d.综合情形1、情形2,即得d(T1)d.设{T1,T2,…,Tm}是T的一个最小d-子树划分,不妨设u(1)∈V(T1).对于任意y∈V(T),yV(T1),因为T1=T(z1,u(1))-z1,故路径(u(1)~y)必经过z1.于是d(u(1),y)=d(u(1),z1)+d(z1,y),故d(u(1),y)d(u(1),z1)>d,即yV(T1).可见V(T1)V(T1).记T2=T2T1,T3=T3T1,…,Tm=TmT1.由性质1知TiTi(i=2,…,m)是树.由性质4,d(Ti)d(Ti)d(i=2,…,m).显然,T1,T2,…,Tm顶点两两不相交.又∪mi=1V(Ti)=V(T1)∪(∪m=V(T1)∪(∪m=V(T).因此,{T1,T2,…,Tm}是T的一个d-子树划分(从而是T的一个最小d-子树划分),结论(2)成立.(3)由结论(2)的证明过程得知,{T2,T3,…,Tm}是树T(T(z1,u(1))-z1)=TT1的一个d-子树划分.因此,πd(T(T(z1,u(1))-z1))πd(T)-1,即πd(T)πd(T(T(z1,u(1))-z1))+1.另一方面,如果{T2,T3,…,Tm}是T(T(z1,u(1))-z1)的一个d-子树划分,则{T(z1,u(1))-z1,T2,T3,…,Tm}是(T(T(z1,u(1))-z1))∪(T(z1,u(1))-z1)=T-(z1,z)的一个d-子树划分,于是{T(z1,u(1))-z1,T2,T3,…,Tm}是T的一个d-子树划分,即πd(T)πd(T(T(z1,u(1))-z1))+1.从而πd(T)=πd(T(T(z1,u(1))-z1))+1.这样就获得了结论(3).注7.v、T(v,x)、u如引理6所设.由性质6,d(T(v,x))=max{d(Tu),l(u(1))-l(v)}.又d(Tu)d.因此,引理6的条件l(u(1))-l(v)>d等价于d(T(v,x))>d.引理7.设v为Q的栈顶元素,T(v,x)为vPage10x)-v∈Πd(T);1)-v∈Πd(T);v(1)的未检查的后代分支,u为T(v,x)中的待检查顶点,l(u(1))-l(v)d,l(u(1))+l(v(1))-2l(v)>d.(1)如果l(u(1))l(v(1)),则①存在T的最小d-子树划分Πd(T),使T(v,②πd(T)=πd(T(T(v,x)-v))+1.(2)如果l(u(1))<l(v(1)),则①存在T的最小d-子树划分Πd(T),使T(v,②πd(T)=πd(T(T(v,v(1))-v))+1.证明.首先,据注7及条件l(u(1))-l(v)d,有d(T(v,x))d.其次,v(1)≠v,否则l(u(1))+l(v(1))-2l(v)=l(u(1))+l(v)-2l(v)=l(u(1))-l(v)d,与条件l(u(1))+l(v(1))-2l(v)>d相矛盾.设{T1,T2,…,Tm}是T的一个最小d-子树划分,由性质3有d(u(1),v(1))=l(u(1))+l(v(1))-2l(v),据引理条件即得d(u(1),v(1))>d,这意味着不存在i(i=1,2,…,m)使v(1)∈V(Ti),且u(1)∈V(Ti).因此,不妨设v(1)∈V(T1),u(1)∈V(T2).记T1=(T1(T(v,x)-v))∪(T(v,v(1))-v),T2=(T2(T(v,v(1))-v))∪(T(v,x)-v),T3=T3(T(v,v(1))-v)(T(v,x)-v),…,Tm=Tm(T(v,v(1))-v)(T(v,x)-v).注意T(v,v(1))-vT1、T(v,x)-vT2.由性质1,T1(T(v,x)-v)是树.但v(1)∈V(T1(T(v,x)-v))∩V(T(v,v(1))-v),故T1是树.我们有d(T1)d.事实上,任取y,z,使y,z∈V(T1),只要证明d(y,z)d.分4种情形讨论.情形1.y,z∈V(T1(T(v,x)-v)).d(y,z)d(T1(T(v,x)-v))d(T1)d.情形2.y,z∈V(T(v,v(1))-v).d(y,z)d(T(v,v(1))-v)d(T(v,v(1)))d(Tv)d.情形3.y∈V(T1(T(v,x)-v))且z∈V(T(v,v(1))-v).不妨设yV(T(v,v(1))-v)(否则归为情形2),即y,z在v的不同分支上,于是路径(y~z)必经过v.又由性质2,d(v,z)=l(z)-l(v).因y,v(1)∈V(T1),故d(y,v(1))d(T1).由性质3,d(y,z)=d(y,v)+d(v,z)=d(y,v)+l(z)-l(v)d(y,v)+l(v(1))-l(v)=d(y,v)+d(v(1),v)=d(y,v(1))d(T1)d.情形4.y∈V(T(v,v(1))-v)且z∈V(T1(T(v,x)-v)).仿情形3的证明,可得d(y,z)d.d(Ti)d(Ti)d.类似,可以证明:T2是树,且d(T2)d.对于i=3,…,m,由性质1、Ti是树且由性质4,易见T1,T2,…,Tm顶点两两不相交,且∪mi=1V(Ti)=V(T).因此,{T1,T2,…,Tm}是T的一个d-子树划分(从而是T的一个最小d-子树划分).(1)当l(u(1))l(v(1)),记T1为V(T1)∪V(T2(T(v,x)-v))的导出子图.首先,T1是树.分两种情形证明.情形1.V(T2(T(v,x)-v))=.显然,T1是树.情形2.V(T2(T(v,x)-v))≠.任取y∈V(T2(T(v,x)-v)).注意T(v,x)-vT2.在T2中,y要到达T(v,x)-v中的顶点必经过v,即v∈V(T2);但vV(T(v,x)-v),故v∈V(T2(T(v,x)-v)),即v∈V(T1).又T(v,v(1))-vT1,故V(T1)∪{v}的导出子图是连通的.另外,由性质1,T2(T(v,x)-v)是树.从而T1中的任意顶点经v可到达y,于是T1是连通的,即T1是树.其次,d(T1)d.任取y,z,使y,z∈V(T1),只要证明d(y,z)d.分4种情形讨论.情形1.y,z∈V(T1).d(y,z)d(T1)d.情形2.y,z∈V(T2(T(v,x)-v)).d(y,z)情形3.y∈V(T1),z∈V(T2(T(v,x)-v)).显然,zV(T1),zV(T(v,x)-v).因此,路径(u(1)~z)必经过v.又由上面的讨论易知,路径(y~z)必经过v.注意T1=(T1(T(v,x)-v))∪(T(v,v(1))-v).(i)y∈V(T(v,v(1))-v).此时d(y,v)d(v(1),v).故d(y,z)=d(y,v)+d(v,z)d(v(1),v)+d(v,z)=l(v(1))-l(v)+d(v,z)l(u(1))-l(v)+d(v,z)=d(u(1),v)+d(v,z)=d(u(1),z)d(注意z,u(1)∈V(T2)).(ii)yV(T(v,v(1))-v).此时必有d(y,v)d(u(1),v).否则d(y,v)>d(u(1),v),因y、v(1)、u(1)在v的不同分支上,由性质3,d(y,v(1))=d(y,v)+d(v,v(1))>d(u(1),v)+d(v,v(1))=d(u(1),v(1))=l(u(1))+l(v(1))-2l(v)>dd(T1),即d(y,v(1))>d(T1);与y,v(1)∈V(T1)相矛盾.从而d(y,z)=d(y,v)+d(v,z)d(u(1),v)+d(v,z)=d(u(1),z)d.情形4.y∈V(T2(T(v,x)-v)),z∈d(T2(T(v,x)-v)d(T2)d.Page11V(T1).仿情形3的证明,可得d(y,z)d.最后,容易验证{T1,T(v,x)-v,T3,…,Tm}是T的一个d-子树划分(从而是T的一个最小d-子树划分),于是结论1)成立.因为{T1,T3,…,Tm}是树T(T(v,x)-v)的一个d-子树划分,故πd(T(T(v,x)-v))πd(T)-1,即πd(T)πd(T(T(v,x)-v))+1.另一方面,如果{T1,T2,…,Tm-1}是T(T(v,x)-v)的一个d-子树划分,则{T(v,x)-v,T1,T2,…,Tm-1}是(T(T(v,x)-v))∪T(v,x)的一个d-子树划分(T(T(v,x)-v)中含有v).而V((T(T(v,x)-v))∪T(v,x))=V(T).因此,{T(v,x)-v,T1,T2,…,Tm-1}也是T的一个d-子树划分,即πd(T)πd(T(T(v,x)-v))+1.从而πd(T)=πd(T(T(v,x)-v))+1.这样就获得了结论2).(2)当l(u(1))<l(v(1)),因由引理4知l(u(1))>l(v(2)),故l(v(1))>l(u(1))>l(v(2)).若将T(v,x)、1)换位,以下就可类似(1)证明,不再赘述.T(v,v(1)注8.v、T(v,x)、u如引理7所设.由性质7,有d(T(v,x)Tv)=max{d(Tu),d(Tv),l(u(1))+l(v(1))-2l(v)}.又d(Tu)d,d(Tv)d.因此,引理7的条件l(u(1))+l(v(1))-2l(v)>d等价于d(T(v,x)Tv)>d.根据性质1,引理1~引理7,我们有定理2.算法1正确地求解边赋非负权树的d-子树划分问题.3.3算法的复杂性定理3.算法1在O(n)时间内完成,其中n=|V(T0)|.证明.算法1的执行时间主要取决于片段1~片段4、片段7~片段10、片段12~片段18以及循环.(1)片段1、片段2、片段3.根据注1,片段1可在O(n)时间完成;而片段2、片段3也可在标号D进行时同时进行,所耗时间也为O(n).(2)片段4、片段7.参考注2的说明,考虑到循环(见下面关于循环次数的讨论,下同),总的时间耗费为O(n).(3)片段8.根据注3的讨论,在一次循环中,为了找到u,片段8把(u~v)(u,v如算法1或引理2约定)上的所有顶点(除v外)均访问了一次;但下一次循环片段8可能还会访问(u~v)上的某些顶点,这样片段8可能重复访问(u~v)上的某些顶点.不过,应用下面的策略,即使考虑到循环,(u~v)上的顶点(除v外)被片段8恰好访问一次.片段9.我们可以从u出发沿着(u~v)、通过逐个顶点验证方式来寻找z,z1(z,z1如算法1或引理6约定).由于u的所有后代分支均为已检查分支(引理2),从而l(u(1))-l(u)d(Tu)d(性质8).在(u~v)上取u的(唯一)双亲x1,如果l(u(1))-l(x1)>d,则z=u,z1=x1;否则,在(u~v)上取x1的双亲x2,如果l(u(1))-l(x2)>d,则z=x1,z1=x2;…依此方法,最后必能找到z,z1.因此,片段9访问(u~z1)上的每个未检查顶点一次;但随后的片段10进行的运算将删除这些访问过的顶点(除z1外).在片段11,当z1是端顶点且z1≠v0,z1将标为待检查,此时,我们可以直接转到片段8后面一行的条件判断(取u=z1.注意,片段8不需访问此种待检查顶点u)而无需从循环的入口处开始下次循环,避免了片段8重复访问(u~v)上的顶点;若z1不是端顶点,必有z1=v(意味着前面片段10进行的运算删除了v的一个分支).根据以上讨论,我们可得到:算法1直至结束,片段8不访问已检查顶点,待检查顶点可能被片段8访问一次,不在Q0中的未检查顶点被片段8访问一次,不访问Q0中的未检查顶点.片段9不访问已检查顶点和待检查顶点,不在Q0中的未检查顶点被片段9访问一次,Q0中的未检查顶点v被片段9访问至多d(v)次(若v≠v0,v的每个后代分支各对应一次,共d(v)-1次;若v=v0,v0的每个后代分支也各对应一次,共d(v)次).因为已检查顶点、待检查顶点、未检查顶点分别至多有n个,故考虑到循环,片段8、片段9访问的顶点总数不超过(n+n)+n+∑v∈Q0,v≠v0(4)片段10、片段12、片段14.主要时间耗费在运算.考虑到循环,全部运算所耗费的时间为O(n).(5)片段15、片段17、片段18.分别参考注5、注4的说明.考虑到循环,总的时间耗费为O(n).(6)片段13、片段16.实际上,片段13、片段16只需把不是已检查顶点的顶点标为已检查(即路径(u~v)中除v外的顶点,引理2).注意,任何顶点只要标为已检查后,不可能标为未检查、待检查.考虑到循环,总的时间耗费为O(n).(7)循环.每次循环将处理T中对应Q的栈顶元素的顶点的一个后代分支,该顶点的某个后代分Page12支每多处理一次,表明前次循环刚刚得到了Πd(T0)的一个元素.因此,循环次数不超过πd(T0)+∑v∈Q0,v≠v0综上所述,算法1的时间耗费为O(n).证毕.4算例例.求图2所示树T的3-子树划分问题,其中顶点旁的数字为顶点编号(例如顶点编号1表示顶点v1、顶点编号10表示顶点v10),标在边的上方或右边的数字为对应边的权值.解.现用算法1求解.置d=3.(1)初始化.π3(T)=0;Π3(T)=.取v0=v1,将T按标号D标号(见图2,顶点的标号写在顶点编号后面的括号中),Q={v5,v1}.把所有的端顶点标为待检查,其余顶点标为未检查(见图2,未检查顶点、已检查顶点、待检查顶点分别用白色、黑色、半白半黑小圆圈表示.下同).对i=1,3,5,6,7,8,10,置v(1)(2)取Q的栈顶元素v5,v=v5,取v5的最左边的未检查的后代分支T(v5,v6),取T(v5,v6)中的待检查顶点u=v6.因为l(u(1))-l(v)=l(v(1)3=1<d,且l(u(1))+l(v(1))-2l(v)=l(v(1)2l(v5)=l(v6)+l(v5)-2l(v5)=4+3-2×3=1<d,故将T(v5,v6)标为已检查.又因l(u(1))=l(v(1)l(v(1))=l(v(1)d(Tv5)=max{d(Tu),l(u(1))+l(v(1))-2l(v)}=max{d(Tv6),l(v(1)3}=1;v(2)=v(2)T(v5,v6)标为已检查,d(Tv5)=1,v(1)(3)继续考虑Q的栈顶元素v5,v=v5,取v5的最左边的未检查的后代分支T(v5,v7),取T(v5,v7)中的待检查顶点u=v7.类似(2)可得:T(v5,v7)标为已检查,d(Tv5)=2,5=v7,v(2)v(1)(4)继续考虑Q的栈顶元素v5,v=v5,取v5的最左边的未检查的后代分支T(v5,v8),取T(v5,v8)中的待检查顶点u=v8.类似(2)可得:T(v5,v8)标为已检查,d(Tv5)=3,5=v8,v(2)v(1)5)-2l(v5)=l(v10)+l(v8)-2l(v5)=6+5-2×3=5>(5)继续考虑Q的栈顶元素v5,v=v5,取v5的最左边的未检查的后代分支T(v5,v9),取T(v5,v9)中的待检查顶点u=v10.因为l(u(1))-l(v)=l(v10l(v5)=6-3=3=d,但l(u(1))+l(v(1))-2l(v)=l(v10l(v(1)d,l(u(1))=l(v(1)即l(u(1))>l(v(1)),故Π3(T)=Π3(T)∪{T(v5,v9)-v5}={{v9,v10}}(为了简明起见,Π3(T)中的子树用该子树的顶点集表示.下同),π3(T)=π3(T)+1=1,T=T(T(v5,v9)-v5)(见图3).(6)继续考虑Q的栈顶元素v5,v=v5,v≠v0且不存在v5的未检查的后代分支,于是将v5标为待检查;Q=Q-{v}={v1}.(7)取Q的栈顶元素v1,v=v1,取v1的最左边的未检查的后代分支T(v1,v2),取T(v1,v2)中的待检查顶点u=v3.类似(2)可得:T(v1,v2)标为已检查,d(Tv1)=3,v(1)v3,v(2)1=v1.(8)继续考虑Q的栈顶元素v1,v=v1,取v1的最左边的未检查的后代分支T(v1,v4),取T(v1,v4)中的待检查顶点u=v5.易得Π3(T)={{v9,v10},{v5,v6,v7,v8}},π3(T)=2;v4标为待检查,v(1)(9)继续考虑Q的栈顶元素v1,v=v1,取v1的最左边的未检查的后代分支T(v1,v4),取T(v1,v4)中的待检查顶点u=v4.易得T(v1,v4)标为已检查,Π3(T)={{v9,v10},{v5,v6,v7,v8},{v2,v3}},π3(T)=3;d(Tv1)=1,v(1)(10)继续考虑Q的栈顶元素v1,v=v1,v=v0且不存在v1的未检查的后代分支,于是Π3(T)=Π3(T)∪{T}=Π3(T)∪{(v1,v4)}={{v9,v10},{v5,v6,v7,v8},{v2,v3},{v1,v4}},π3(T)=π3(T)+1=4,T=.从而Π3(T)={{v9,v10},{v5,v6,v7,v8},{v2,v3},{v1,v4}},π3(T)=4.算法1结束.Page135结束语由于对结构非常简单的图,d-子树划分问题是一个NP-完全问题,因此,研究一般图的d-子树划分问题的多项式时间近似算法非常有必要.当然,寻找在实际应用中常见网络类型或理论上有较大价值的特殊类图(如区间图、仙人掌图)的d-子树划分问题的多项式时间精确算法也值得重视.
