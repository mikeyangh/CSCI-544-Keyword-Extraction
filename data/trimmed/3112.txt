Page1任意图支配集精确算法回顾路纲1)周明天2)唐勇2)吴振强1)裘国永1)袁柳1)1)(陕西师范大学计算机科学学院西安710062)2)(电子科技大学计算机科学与工程学院成都610054)摘要该文综述了任意图支配集精确算法分析和设计的新进展.支配集问题是经典NP完全问题,很多问题都能与它相联系.我们针对最小支配集、最大独立集、最小独立支配集、最小连通支配集、最小加权支配集问题提供了详尽算法描述和实例说明,以使文章自包含方便阅读.文中还讨论了诸如分支简化策略、复杂度分析、测度分析、记忆等技术.自ClaudeBerge首次准确阐述现代图支配概念后,经过很长一段时期的沉寂,关于指数时间精确算法设计的研究热情在过去五年中显著增涨.除回顾这些最新成果之外,作者还盼望国内研究团体能更加重视这个快速发展的研究领域.关键词支配集;精确算法;计算复杂性;图;测度分析技术1引言自ClaudeBerge在20世纪60年代初首次描述现代图的支配概念至今(2010),整整50年过去了,支配集及其各种变形问题已成为图论、组合数学、计算机科学等领域被广泛研究和重视的问题之一,发表的相关论文数以千记,文献[1]综述了20世纪90年代前约1200多篇支配集相关文章的内容.不仅限于理论研究,支配集问题同样有着重要的实用价值:通信基础设施的布局、城市交通路线规划、测量及地理信息系统、系统控制和机构优化管理、编码理论、图像处理、数值分析、VLSI设计、信息检索、超级计算机的CPU阵列布局和通信机制、生物学、材料学、物理学、军事学等众多领域的一些重要问题都可归结为某种形式的支配集问题.人们在20世纪70年代就认识到任意图最小支配集问题及其变形如最小独立支配集、最大独立集等问题的NP-难性质,在P=NP这个目前被广泛认为不大可能的结果出现之前,要获得问题的准确解只能求之于某个指数O(cn)时间的算法,其中c是大于1的常数,n是图顶点数,本文简称这类指数时间的准确解算法为精确算法.精确算法设计有着悠久的历史.非平凡精确算法的历史可以追溯到1962年Held和Karp发表的TSP问题动态规划算法[2]———迄今仍是最快算法之一(O(2nn2));Tarjan等[3]在1977年提出O(2n/3)最大独立集算法,规则描述多达十几页.令人困惑的是,就最小支配集问题来说,直到2004年前后才由一些独立研究者如Fomin、Grandoni等人突破2n这个平凡界限.2004年以来精确算法研究逐渐形成一个热潮———本文主要工作就是介绍这期间的重要成果.再次引起重视大致有以下原因:经过20世纪90年代的沉寂后,精确算法近期(1)受计算复杂性理论制约,指数时间算法是目前获得精确解的唯一可行选择.(2)近似算法不一定都能满足需要,并且许多NP难问题没有或很难获得近似算法.例如,著名的3-SAT问题,要么为真要么为假,采用近似算法毫无意义.(3)设计近似算法时,如果能事先获得一些小规模网络的精确解感性认识,将对设计大有助益.(4)如果能使精确算法的时间底数降低,例如c降至槡c,可解决问题规模将翻倍.当问题规模不是很大且c接近1时,精确算法甚至比某些高次多项算法表现更好.(5)计算机硬件技术的进步、计算资源的普及促进了精确算法的研究和使用.(6)增进人们对计算复杂性理论的理解,激发一些组合优化理论和算法设计方面的新成果诞生.除了算法本身外,另一个同样重要的方面是复杂度分析技术.最新成果表明似乎没有必要设计过多规则,过去那种多达几十上百条规则的设计风格不但违背人思维习惯,也没有给复杂度带来更理想结果.这方面的重要进展是Measure&Conquer技术,它归功于Fomin和Eppstein等人的工作.本文中,我们将看到分支搜索技术(Branch&Reduce)、记忆(Memorization,实际是一种数据库技术)、动态规划等技术在精确算法设计中的应用,文末处还提供了这些精确算法的实测效果.我们尝试通过提供详细算法描述和示例来记述近几年的重要研究成果.本文第2节介绍术语和一些理论成果;第3节介绍最小支配集、最大独立集、最小独立支配集、最小连通支配集和最小加权支配集问题的精确算法、设计思想、复杂度等;第4节列表总结重要算法,介绍一些技术发展趋势,并提供了算法实测效果;第5节结束全文.为保持文章主体层次清晰,我们将部分内容置于文尾附录中.2准备工作2.1符号及术语G=(V,E):G代表图,V,E分别表示该图的点和边集;|S|为集合S的势(cardinality),即S中非空元素个数,例如|V|=n,|E|=m;N(u)为点u的开邻集,即所有与u之间存在一条边的点集合;N[u]为u的闭邻集,即N(u)∪{u};Δ(G)、δ(G)分别代表图G的最大度和最小度,表示为maxu∈V|N(u)|和minu∈V|N(u)|;G[S]为G中只保留集合S中的点及两端点都属于S的边,得到的诱导子图;G-{S}为G中去掉点集S及与S中任一点连接的边而得到的导出子图.通常用大写字母表示集合,用小写字母表示某一元素.支配集DS(DominatingSet)表示图G中点集DSV,满足对u∈V,要么u∈DS要么u是DS中某点的邻节点,则称DS为支配集.γ(G)表示图GPage3的|DS|.最小支配集MDS(MinimumDS)表示图G所有DS中|DS|最小者.连通支配集CDS(ConnectedDS)表示G[DS]导出图连通.最小连通支配集MCDS(MinimumCDS)表示CDS中|CDS|最小者.独立集IS(IndepdentSet)表示点集ISV,且IS中任一对点间不存在边.最大独立集MIS(MaximumIS)表示IS中|IS|最大者.独立支配集IDS(IndependentDS)表示某点集IDS既是IS又是DS.最小独立支配集MIDS(MinimumIDS)表示IDS中|IDS|最小者.最小加权支配集MWDS(MinimumWeightedDS)表示顶点具有权值时的MDS;顶点(或边)覆盖是指给定一个顶点(或边)集合,使图中任一边(或点)都与该集合的某点(或边)相接,则称该集合为图G的一个顶点(或边)覆盖.O,O为复杂度记号,后者省略了多项式因子,O(cn)=O(poly(n)·cn).2.2理论基础DS相关概念较早见于19世纪,那时人们研究棋盘上最少需要多少个王后才能攻击所有的方格,可要求王后之间互相不能攻击,以及符合条件的放置方法最大数量,用现代数学观点来看分别是集合图13-SAT归约到支配集给定变量集合U={u1,u2,…,un},ui取0或1;子句集合C={C1,C2,…,Cm},三元子句Cj={up,ui,ul},其中ui表示ui取反,p,l∈[1,n].对U中每个变量ui建立一个三角形△uiuivi,如图1所示,如果ui为真用黑色点表示,为假则将ui用黑色点表示.对每个Cj,如果含某ui则在图中以边连接uiCj(此图k=n).(3)首先需说明,如果存在C为真的一种安排G含支配集|S|(=n),按如下规则构造集合S:如ui为真则加入S,反之将ui加入S.我们断言S一定是G的支配集,因为:①每个三角形恰有一个点属于S,三角形点被支配;②根据假设C为真知:每个Cj必与某黑色点连接(支配).(4)反过来我们需表明,如果G存在支配集|S|C为真(即每个Cj为真),则覆盖、独立支配集和独立支配集最大数目的问题.现代DS概念最早由ClaudeBerge在文献[4]中提出,Ore在文献[5]中首次使用了支配集(domi-natingset)这个术语.Cockayne在一篇综述文章[6]中首次使用γ(G)来表示支配集的势(=|DS|),这个记号已被广泛使用.Johnson[7]在1979年表明了DS问题的NP-完全性质(确切说文献[7]证明的是顶点覆盖问题,可转换为DS问题).题[1,7].所谓DS问题即,给定一个图G和正整数k,问题(P):G是否存在一个DS,使得|DS|k.这个问题的性质涉及支配集算法设计中最重要的理论基础,我们有必要简单回顾一下.定理1.DominatingSet问题是NP完全问证明.(1)给定任意点集SV,|S|k,验证S是否为G的一个支配集仅需多项时间,即PDS∈NP.(2)已知3-SAT问题为NP完全问题(由Karp于1972年证明),图1将3-SAT变换为支配集问题(PDS).①每个三角形恰含一个vi,且vi已经被支配,因此支配集S的大小至少为n,换句话说每个三角形内有一点属于S,|S|至少为n;②按(3)步的方法构造S,然后使与Cj相交的三条边中至少有一条连接黑色点,这种安排的结果必然使C为真.(5)最后,图的构造方法表明,转换到DS算例只需建立3-SAT算例时间的常数倍.证毕.Chang[8]等人证明即使在偶图中,MDS问题仍为NP-完全问题.近似算法方面,对任意图MDS、MCDS问题来说,有任意常数ε>0,使得除非NPDTIME(nO(loglogn)),否则在多项时间内不存在一个近似比(即近似精确解大小之比)小于(1-ε)lnn的近似算法[9-10],对于MIDS问题,文献[11]表明除非P=NP否则不存在近似比在n1-ε之内的算法.文献[12]表明,多项时间内MIS问题不存在近似比Page4低于N1-O(1)的近似算法.下面列举了关于γ(G)的主要定理.它们的证明方式几乎如出一辙:采用某种策略从G中选点加入集合S,当S成为DS时计数其势的上界,以此估算γ(G),因而基本上是存在性定理,通常不易用来设计算法.凡事都有例外,第3节中第一个突破2n界限的MDS算法就利用了定理2的性质.定理2[13].在含n个点、δ(G)3的图中,存在一个DS,其γ(G)3n/8.定理3(Arnautov,1974).δ(G)=k的图中,存在一个DS,其γ(G)1+ln(k+1)N/2.定理4[5].一个图如果没有孤立点则γ(G)定理5[13].n定理6[14].对于任意图,γ(G)(n+1-(δ(G)-1)Δ(G)定理7.对任意n3的连通图G,γc(G)n-2[15];n时γc(G)3n/4-2,当δ(G)4时,γc(G)3n/5-2[17].定理8.对任意连通图有γc(G)n-Δ(G)[4];γc(G)3γ(G)-2[18].2.3关于DS历史如2.2节记述,Berge和Ore是目前学界公认引入现代DS概念的先驱.在文献[1]等众多文献中,西方学界认为更早的DS相关概念来自19世纪对国际象棋(Chess)里某些问题的讨论.按照这个逻辑,中国古代产生DS思想不比西方晚.诞生于约2500年前的围棋(Go),追求以最少的子支配尽可能多的面积,和最小支配集思想一致.围棋中任给一个图,判断某点是否为黑或白方支配,最坏情况需至终局才能肯定,尽管此时搜索范围不超过一个常数(围棋博弈树复杂度为10360,状态空间复杂度为10170),但此常数比宇宙中已知原子数(1077,不计暗物质)还多得多;反观国际象棋,王后支配范围为确定的横竖斜,任给一个图,我们容易在多项时间内判断某点是否被攻击(国际象棋博弈树复杂度为10123,状态空间复杂度为1048);围棋将是人与AI角逐的最后阵地之一.另外我国古代军事学说常提到兵家必争之地,现代观点可看做求一个战场图的最小加权支配集,也包含DS思想;等等.3支配集构造技术对于任意图,我们总能够通过枚举比较所有可能的点组合来获得任一支配集问题的精确解,由此导致平凡的O∑n杂度.3.1求最小支配集的FKW搜索算法FKW分别是文献[19]中3位作者名的开头字母,该算法用于计算图的MDS.算法思想:利用2.2节定理2.为此,需将原始图G改造成δ(G)3的图G.对于零度点只需加入DS集合即可;对于1度点u,必然有一个MDS含u的邻节点v而不含u;对于2度点,例如u来说,有下面的结论.结论1[19].设N(u)={v,w},如果MDS是任意点集XV的最小支配集,则下述三者之一成立:①v∈MDS,uMDS;②u∈MDS,{v,w}MDS;③vMDS,uMDS,w∈MDS.当0度、1度和2度点都被消去后,剩下的子图满足定理2的要求:δ(G)3.此时通过枚举所有点组合,给出G的最小支配集,进而得到原图的MDS,即深度图理论(deepgraphtheory).算法.fkw(G,S,X).输入:图G、S=、X(表示待支配的点集合,初始可令输出:一个MDS1.如u∈G且d(u)=0;如果u∈X,返回fkw(G-{u},S∪u,X\u);否则,返回fkw(G-{u},S,X);2.如果u∈G且d(u)=1,令N(u)=v;如果u∈X,返回fkw(G-{u,v},S∪v,X\N[v]);3.如果u∈G且d(u)=2,令N(u)={v,w}.如果uX转步4,否则,转步5;4.形成3个分支,返回:(1)fkw(G-{u,v},S∪v,X-N[v]);(2)fkw(G-{u,v,w},S∪u,X-v-w);(3)fkw(G-{u},S,X);5.形成3个分支,返回:(1)fkw(G-{u,v},S∪v,X-N[v]);(2)fkw(G-{u,v,w},S∪u,X-u-v-w);(3)fkw(G-{u,w},S∪w,X-N[w]);6.如果以上条件都不满足,则δ(G)3,枚举法求出并返回当前子图的最小支配集;7.比较所有分支结果,选择一个最小支配集S做最后的输出.Page5复杂性主要由6步决定,定理2表明最多只需枚举n()1+…+nx!=x()e20.955)n.n为子图点数,不超过n,算法突破了O(2n)界限.图2是该算法示例,其中,图2(a)为初始输入图,图2(b)显示一个MDS.人们形象地称此类算法图2FKW算法示例B&R是Davis和Putnam[20]在40多年前开发的技术,是解决NP难题最常用的方法.其核心思想是应用一系列简化规则将问题分解为小规模的子问题,然后递归地在子问题上应用同样规则直到问题分解为基问题(basecase).尽管最早突破O(2n)界限,fkw仍难令人满意,如果图中无低于2度的点,算法又回到平凡的枚举.下面的Grandoni算法是目前最好的MDS算法之一.3.2求最小支配集的Grandoni算法原算法[21]给出的是|MDS|而非具体MDS,本文稍做改动,给出具体MDS.算法的复杂度[22]为多项空间O(20.61n),指数空间为O(20.598N).用自然语言描述算法如下.算法.Grandoni(S,S).输入:初始化S={N[v]|v∈V},S=输出:S(图G的MDS)为搜索树(SearchTree)或分支简化(Branch&Reduce,以下简记B&R)算法,见图2(c).当子问题只含一种情况时,称为简化规则(reducerules),例如fkw算法的步1、步2,搜索树不产生分支;如果子问题含多种情况,称此时采取的策略为分支规则(branchrules),例如算法的步4、步5,搜索树产生至少两个分支.图2(c)中我们让程序描绘算法每一个简化点和分支点,得到一个搜索过程树,树中含13493个叶结点.算法在每个叶子所代表的子图里执行枚举(步6).输入节点编号见图2(d).1.|S|=0,则返回S;2.当前S中寻找子集SiSj,返回Grandoni(S\Si,3.寻找u∈Si,要求u的出现频率为1.返回Grandoni(S-S);(Si),S∪Si);4.寻找S中具有最大势的Si,判断:如果|Si|2,调用最大匹配算法直接给出S;//多项时间(Si),S∪Si)};否则,返回min{Grandoni(S\Si,S),Grandoni(S-说明,S-()表示从每个子集Si中都去除元素{},S\Si表示仅从S中删除子集Si.步4当|Si|2时,需要构造一个图G,这个图的点集为U={u∈Si|Si∈S},如果某Si=(u,v),则uv为G的边.求出该图的最大匹配M后,每个M中的边对应一个Si,再将孤立的点所对应子集加入S.任意图最大匹配问题多项时间算法[23]最早由Edmond(1964)提出,当时复杂度为O(n4),后被改进到O(n3).Page6Grandoni算法获得优势原因有三:(1)将MDS问题转化为集合覆盖问题(初始化).(2)特定条件下覆盖问题转换为最大匹配在多项时间内解决.(3)应用MeasureandConquer(M&C)复杂度分析技术.B&R技术广泛应用后的相当长一段时间内(20世纪70、80年代),人们倾向于设计更多更复杂的规则,其数量动辄几十上百,然而用来度量规则所产生子问题规模的测度却非常简单,例如当前图点数,我们称此类测度为常规测度.“M&C”思想是用更复杂的非常规测度来衡量每一个分支规则的影响.做个比喻:假设身高体重是健康的常规测度,1.75m体重85kg算健康,然而这个测度只说明他大致健康,健康到何种程度,是优良中还是及格?还需做更细致的检测分析,包括测量肌肉重量和脂肪重量、腰部重量和臀部重量、肢体重量、器官重量,等等,它们之间的比率要适当才算健康,一个人如果细胳膊细腿却粗身子,就算85kg也枉然.在得到这些更细致的“重量”后,把它们作为一个整体系统中的子系统而分别赋予一个“恰当”的权值,求和后就得到一个衡量健康的更精确参数,使最终结论更接近(而非到达!)真实健康值.设计更多规则不一定导致算法更快的道理容易理解,例如用不规则开口桶来盛水,水的高度不会超过桶的最低处,同样O(3n,2n)=O(3n),算法复杂度取决于最慢规则的复杂度.过多(分支)规则有时反而增加复杂性,例如导致巨大的隐藏系数.搜索树复杂度常规分析技术使用递归方程(recurrenceequations)的特征多项式.以本节算法为例,用L(k)表示算法分支产生的叶子节点数,U表示子集中待覆盖的点,常规测度k=|S|+|U|.算法只在步4当|Si|>2时产生两个分支,第1个分支S不含Si,则S-Si,此时k=k-1;第2个分支|Si|至少为3,k|S|-1+|U|-3;所以有L(k)L(k-1)+L(k-4),取方程x4-x3-1=0的最大正根后有20.465(|S|+|U|)=20.93n,获得最坏情况下的一个上界.如果有多个这样的方程,取所有解中的最大正实根.当去掉的|Si|较大时算例规模下降较快,反之下降较慢,常规测度(权值都为1)没有刻画这些更细致的特征.M&C针对|Si|的不同,权重化测度为k=∑i1αiS+∑j1βjU,αi,βj∈[0,1].还可进一步对αi,βj做一些假设以简化分析过程(例如限制i,j6时αi,βj=1等),最终得到形如xk=xk-Δi+xk-Δj的方程,其中ΔiΔj分别为含αi,βj的函数.这是一个多元递归方程,这种方程可以同时有很多个,求解它们可利用Eppstein、Amenta等人关于quasi-convexprogramming的工作[24],伪凸规划是广义的线性规划,多元变量被看做是一个关于|S|等参数线性组合的单变量,求得解与真实值只差一个多项系数.M&C在选定一个初始向量狑及允许误差后不断微调其值(类似多重梯度下降),然后利用伪凸规划求解方程,最后得到原算法时间的一个(非紧致)上界,更细致的描述请参考原文献.利用M&C重新计算Grandoni算法复杂度为多项空间内O(20.305(|S|+|U|)=20.61n),与前段常规分析结果O(20.93n)相比进步显著,而算法本身没有任何变动,完全得益于分析技术的进步!Grandoni算法还可进一步改进.Robson介绍了Memorization技术[25]用于精确算法设计,核心思想是以空间换时间:某子问题已被解决,将结果(G,algo(G))存入库,其中algo()代表算法计算结果;此后算法在处理任何子图问题前,先检查库中是否已包含该算例G,如果有则直接取出结果.原始G的子图最多有2n个,排序后查找某子图只需对数时间,故在线性O(n)时间内我们可找到某子图(或者知道库中不含此子图).让我们大致观察一下这种做法对复杂度的影响,以前面例子L(n)L(n-1)+L(n-4)示意说明:Lh(n)表示当前子问题的数量,并且这些子问题的h点导出图已在前面算法过程中被解决.有Lh(n)20.465(n-h),G的h导出图共()n子图最多被算法计算一次,有Lh(n){min20.465(n-h),()}nh;对()n大时ncn-1/槡2→1,c为某正常数.20.465(1-α)≈αα(1-α)1-α,h=αn,求此方程零点,可得α=0.0865,所以最终复杂度为O×(22×0.465(1-α)n=20.85n),小于前面常规方法得到的O(20.93n).更细致的分析[22]表明Grandoni算法应用Memorization后复杂度为O×(20.598n).3.3求全部支配集的LMDS(ListingMinimal1DominatingSets)算法很多时候人们希望知道一个图的所有MDS,文Page7献[26]之前未见除穷举外其他算法.LMDS计算所有的最小支配集,同前面3.2节算法一样也是先将问题转换为集合覆盖.设计算法规则时遵循:如果确定集合Si对覆盖的贡献可由其它集合替代,那么不让Si出现在解集合中;换个方式表达即,如果集合S是图中所有点的最小覆盖且子集Si∈S,则Si至少含一元素u不属于S中任何其它子集.算法把符合这样规则的所有集合都搜索出来.文献[26]中没有显式给出算法,我们将其整理如下.说明:算法lmds步10依据的是如果S1S2∈S,且S1\S2=u,S2\S1=v,则其余Si∈S既不能含u也不能含v.假如含u,则可从S中去除S1,违背了前面提到的设计规则,步9依据同理.算法复杂度为O(20.8235n).附录中的附表1根据算法lmds列出了图2(a)的所有最小支配集,共56个.算法1.lmds(U,S,S).输入:初始化U=V,S=N[v](v∈V),S=输出:S(图G的所有MDS)0.(暂时为空)1.U或S为空则返回S;2.寻找u∈U,要求u在集合S中出现的频率为1.设u∈Si,返回lmds(U-{Si},S-(Si),S∪Si);3.寻找u∈U,要求{u}=S1=S2=…=Sr,r2,且u仅属于这些集合.算法在这里产生r个分支:令S=S\(Si),其中i遍取1,2,…,r;然后依次返回lmds(U-{u},S,S∪Si);4.寻找|Si|5.设Si={u1,u2,…,ur},产生两个分(1)lmds(U,S\Si,S);(2)lmds(U-{Si},S-(Si),支,返回:S∪Si);5.寻找|Si|=4.处理方式类同步4;6.寻找u∈U,要求u在集合S中出现的频率为2.设Si,Sj包含u,且|Sj||Si|,判断:如果|Si|=1,返回:(1)lmds(U-{Si},(S\Si)\Sj,S∪Si);(2)lmds(U-{Sj},(S\Si)-(Sj),S∪Sj);如果|Si|2,接着判断,如果SiSj,返回两分支,(1)lmds(U-{Si},(S\Sj)-(Si),S∪Si);(2)lmds(U-{Sj},(S\Si)-(Sj),S∪Sj);否则,产生3个分支,返回:(1)lmds(U-{Si},(S\Sj)-(Si),S∪Si);(2)lmds(U-{Sj},(S\Si)-(Sj),S∪Sj);(3)lmds(U-{SiSj},S-(SiSj),S∪Si∪Sj);7.寻找|Si|=3.处理方式类似步4;8.寻找SiSj.返回两分支:(1)lmds(U,S\Sj,S);(2)lmds(U-{Sj},S-(Sj),S∪Sj);9.寻找u∈U,要求u在集合S中出现的频率为3.设Si包含{u,ui},i=1,2,3,产生下面7个分支:(1~3)lmds(U-{Si},S-(Si),S∪Si);//共3个分支(4~6)lmds(U-{两Si}、S\所有含两ui之一子集,S∪(两Si));//共3个分支…//两Si表示下标i任取两个数组合.从S中除去含任(7)lmds(U-{Si,i=1,2,3},S-(Si,i=1,2,3),S∪(Si,i=1,2,3));//一个分支10.寻找|Si|=2.设Si={u,v},用SuSv表示除Si外其它分别包含u,v的集合.产生3个分支:(1)lmds(U,S\Si,S);(2)lmds(U-{Si},S\Si\Su,S∪Si);(3)lmds(U-{Si},S\Si\Sv,S∪Si);支配集表.11.算法停后将具有最小势的集合覆盖S转化为最小在基本算法基础上,本文进一步优化该算法,思路很简单,将算法lmds的步0变为:如果待搜索分支的|S||当前最小覆盖|,标记该分支搜索结束,|当前最小覆盖|初始化为无穷大,并随搜索过程动态更新.这样操作对复杂度没有影响,因为最坏情况下可能首先搜索到势最大的解集,或者所有解集同势.然而通常情况下,这样做将为算法节省指数级的时间,因为我们总将子集加入覆盖集合(递增),一旦搜索出某覆盖集合的势为k,则从势k+1~n的分支不必继续搜索.本文对图2算例进行实测,添加步0使运行时间减少近一个数量级.前节Grandoni算法、本文中介绍的其它算法适当处理后都可添加此步(以下不再重复).敏锐的阅者立即意识到,这里使用的是α-β剪枝技术(KnuthandMoore,1975).算法lmds规则复杂,该算法进化版本ls在文献[27]中提出,见附录2.ls去掉lmds中的一些规则,并且每次选择具有最大势的子集来产生分支,复杂度降至O*(20.78n),针对图2的具体算例,实测结果比lmds的快一倍多.3.4最大独立集MIS精确算法有了支配集基本概念后,人们尝试给DS加上一些属性限制,于是当属性为G[DS]———不含边、连通、完全图、包含汉密尔顿圈、权重最小时,对应IDS、CDS、DominatingClique、HamiltonCycleDS、MWDS,另外还包括DN(DomaticNumber,即图G是否可分为k个顶点两两互不相交的极小支配集———其真子集不是支配集)等,我们统称这些为条件支配集.类似地,属性也可以用来限制点集{V-DS},例如要求每个dominatee至少被支配k次以满足容错需求.多个属性可以组合,关于这方面的更多内容,我们推荐参考文献[1].本节介绍的MIS相当于给DS赋予属性:|DS|最大且G[DS]不含边.Page8我们说MIS一定为DS是由于:如果点u未被支配,则u与MIS中点形成IS,MIS∪u是一个比MIS更大的IS,这与MIS是最大独立集矛盾.MIS算法研究历史悠久:Tarjan等在1977年提出O(20.3333n)MIS精确算法[3];TangJian[28]在1986年将算法改进到O(20.3039n);同年Robson[25]发表了两个算法分别使用多项、指数空间,对应时间复杂度为O(20.292n)和O(20.276n);上世纪最快算法由Beigel获得[29],为O(20.29n)及多项空间.本节要介绍的文献[30]中算法复杂度为O(1.221n=20.288n)是目前多项空间内最简单、最快的———其优势获得原因有三:一是应用了两个重要规则“镜像”和“折叠”;二是得益于M&C分析技术;三是应用了M&C设计思想.镜像(mirror).设某点v有一个2跳邻节点u,令点集S=N(v)-N(u),如果G[S]为完全图或空,则称u为v的镜像.u可能不只一个,此时用M(v)表示v的镜像点集合.镜像性质.如果某G的所有MIS不含v,则MIS也不含M(v).原因如下:设所有MIS不含v,则d(v)2(否则v为零度或1度点,此时必有一个MIS含v),且N(v)中至少两个邻点属于MIS(否则假设N(v)中z∈MIS,v替换z后|MIS|不变);由于G[S]为完全图,最多只能含一个MIS中点,所以定有一点w∈S=N(v)∩N(u)属于MIS,于是我们肯定uMIS.同理M(v)MIS.折叠(folding).果N(v)中不含势为3的独立集,则称v是可折叠的.设uiuj…构成N(v),折叠操作由4个步骤组成:①如果任意一对(uiuj)之间不存在边,产生一个新点uij;②每对uij之间添加一条边(只有一个uij则不添边);③在每个{(N(ui)∪N(uj))\v}点与uij之间添加一条边;④G-N[v].下面给出的mis算法是文献[30]作者修改后的版本,删除了文献[30]中一些复杂的判断条件.mis复杂度为O(20.287N),我们进而做稍许改动使其给出一个具体MIS(原算法mis计算的是|MIS|).算法2.mis(G).输入:图G=(V,E)输出:一个最大独立集MIS1.如果G中点数|V|1,返回{V};2.如果G中有一个独立连通组元C,返回mis(C)∪mis(G-C);3.如果v,w满足N[w]N(v),返回mis(G-{v});4.如d(v)=2;如果uijmis(^G),返回mis(^G)∪v;否则返回mis(^G)\uij∪N(v);5.选择G中具有最大度的点v,返回max{mis(G-v-M(v)),mis(G-N[v])}.算法经过前3步后在步4折叠时,v只有一种形式,见图3.不难看出折叠后的图^G恰比原图G的|MIS|小1.M&C原理表明,使子图规模下降快的规则对降低精确算法(更确切说是B&R算法)复杂度,从长远看,是有利的.因此mis算法步5从当前图中选取最大度点产生两个分支:其一含不含v点,利用镜像性质知,如果解集不含v则也不含M(v),故mis(G-v-M(v));其二包含v点,根据独立集的特性,如果解集含v则一定不含N(v),故mis(G-N[v]).这种设计思路在Grandoni算法和ls算法中广泛使用,取得很好效果,我们认为可以作为今后算法设计的规则而确定下来.mis算法简洁优雅,与20世纪70、80年代十几页近百规则的算法相比,几乎完胜.计算示例在图4中.3.5最小连通支配集MCDS算法文献[7]表明MCDS问题的NP难性质.CDS问题等价于寻找图G的一个生成树,要求该树的叶子节点数达到最大.问题的难点在于连通的G[S]需要全局知识,类似这样需全局知识的有著名的TSP问题(最小代价遍历完全图所有节点)和Steiner最小树问题(连接{V-Steiner}点的最小代价树).以前提到的算法规则无法直接应用到CDS问题中;在文献[31]之前没有算法突破O(2n)平凡界限.文献[31]中MCDS算法的设计思想:猜测某条边可能属于MCDS,这样的猜测最多有O(n2)个,因Page9此算法主体必须要运行同样次数.假设计算某次猜测需指数级别复杂度O(·),重复多项次其复杂度仍将是O(·)级别,至此,只要在实现猜测过程中应用某些规则来替换穷举,就能突破O(2n)界限,“规则”以始终保持导出图G[S]连通为准来设计.文献[31]介绍的算法较复杂,列于附录3中,复杂度为O(20.9566N),计算示例见图5.尽管突破O(2n)界限且是目前最快的,该MCDS算法并不实用(参看本文第4节的数据),其中原因值得深入思考.无线移动网络中,连通支配集在广播、数据融合、安全等方面有着特殊重要的应用价值.构造CDS所采用近似算法大都是先建立一个独立支配集或极大独立集,而后再连接成CDS.3.6最小独立支配集MIDSKarp在1972年证明独立集问题是NP-完全性质的.文献[32]所介绍的MIDS算法(参考附录4)思想新颖之处在于利用了一种称做标记图的性质.标记图(markedgraph).图的节点被分为F、M两类,分别代表自由、标记节点.最初所有节点都是自由节点,当算法产生分支时,例如某2度点u的两个邻节点为v1,v2,产生三个分支,解集S依次含u,v1,v2,那么在第3个分支时,我们可以认为S中不含v1,因为在第2个分支的解集S中已经考虑了含v1的情况(第2分支解集仍可能含v2),因而在第3分支中,标记v1点,将其加入M集合.标记某点相当于前面已经考虑了可能含该点的情况,这种“记忆”随即被传递给后面分支.图的F点集导出子图G[F]可能含多个连通组元C,一些连通组元的特殊性质可以加以利用:当C为团(clique)时,显然任何MIDS恰含1个C中元素;当C构成完全二分图(C=X+Y,且点集X的每个点都连接点集Y的所有点)时,算法产生两个分支分别含X,Y(最终返回分支势小者).当前面条件都不满足时,算法选择一个具有最小F度的点u产生分支.尽管规则略多,却都比较简单,容易望文知义,最后得到|MIDS|=8.只需稍加改造就可直接输出一个具体MIDS,见图6.利用M&C技术分析算法复杂度为O(20.441n).3.7最小加权支配集MWDS算法某地区需要布设信号发射设备,问怎样布局才能以最低代价让信号覆盖整个区域?由于在不同地点架设成本不一样,此时问题归结为寻找一个地区图的MWDS.前面3.3节算法lmds(及ls)可改造用于计算MWDS,回忆在算法lmds中,所有能成为DS且每个Si都不可能被其它子集替代的解集被一个不落的搜索出来,这样,只要去掉步0,或将其判断条件改为当前最小权重,就能给出图G的所有MWDS,复杂度不变.假设图2(a)中点权重为V→R+:weight=2d(v)(2的该点度次方),计算结果见图7(weight=64).如果只需要一个MWDS,则算法复杂度可进一步降低至O(20.658n),这是因为当所有|Si|2时,由这些Si可构造一个新图G(方法见3.2节算法第4步的说明),G是二分图,将G转换为完全二分图后(用匈牙利算法)返回其最小加权完美匹配,这只要多项时间即可.目前最快MWDS算法来自文献[33],用一句话概括算法思想:结合B&R技术与动态规划技术的优势.原因:当前图中点度数较大时利用B&R产生分支将迅速降低子问题规模,一旦子问题规模降到较小阶段(图的树宽较小时),继续分支规则将使问题复杂化,此时动态规划技术表现良好.限于篇幅这里仅概述算法流程:类似lmds将最小支配集问题转换为集合的最小覆盖问题,建立相同的数据结构如果|S|=0则返回空某u∈Si频率为1,将Si加入解集;所有|Si|3,由剩余子集Si及其中元素构造一个新图GS,执行路径分解后利用动态规划技术计算并返回该二分图的所有最小加权支配集;选择一个最大的|Si|,解集中Page10要么含Si要么不含,产生两个分支,返回二者中权值最小的.最终算法给出所有的MWDS,复杂度为图7图2(a)的所有最小加权支配集4小结与展望表1列出常被引用及最新(截至2010年)的DS相关算法.其中,文献[34]于2009年提供了目前最快的MDS算法,比本文介绍的Grandoni算法复杂度降低一个几乎可以忽略的值,但其规则极为复杂.表1中最后一列是编程复杂度,分简单、中等、复杂三个等级,由于没有公认衡量标准,我们以算法规则数量来评价,仅供参考.目前寻求包括MDS等在内的NP完全或NP难题精确解方法以B&R为主,此外常见的还包括动态规划(dynamicprogramming)、预处理技术(preprocessingthedata)、局部搜索技术(localsearch,从某个可行解出发,过渡到较近的另一个可行解,最终遍历整个可行域空间,这种邻近通常会随具体问题而不同,例如Hamming距离);另外还有一种策略即随机算法(randomization),它的思路是随机选择问题的某些参数或随机选择节点加入的顺序.这样无疑会导致某些时候走在错误的方向上,因此同样的算法需重复多次以使错误概率减小(重复足够次时,成功的概率接近1),确切地说,假设完成每次选择需时间t,成功的概率为p,为使算法最终出错的概率不超过e-c((1-p)c/p),需要重复c·t·p-1次.这方面有大量文章是关于k-可满足性等问题的,虽然我们介绍的是支配集问题,但文章开篇表明我们可以将支配集转换为3-SAT.怎样进行随机操作可使错误的概率降低也是一个很令人感兴趣的研究课题,这方面的综述可参考文献[40-41]等.再有就是我们现在常见到的那些著名智能优化计算方法,如遗传算法、人工神经网络等等,这些方法在求解TSP等NP难问题方面都有令人信服的O(20.6355n),计算结果与lmds的一致,见图7.表现.B&R方向上,最近有人尝试用计算机来自动地、机械化地发现规则,这样规则数目将达万记,如何使用这些规则、编程等都可作为进一步的研究方向.最后值得一提的是随着多核心计算能力的普及,并行算法的重要性日益突出,B&R算法树状结构天然适合多线程多处理器的执行方式,随着核心数量的增多,计算时间线性降低.本文介绍的是DS算法,稍加变化就可用于其它NP完全或NP难问题.例如在任意图中寻找最大团(clique)也是NP完全问题,3.4节MIS算法不需任何改变就可用来求图的最大团,只需将图G转换为补图G,然后求G的最大独立集;这个问题还等价于补图的最小顶点覆盖.细心观察,这样的例子将非常多.精确算法研究可为近似算法设计提供理论指导,至少可以避免浪费精力去追求一些理论上已经证明不可能达到的近似度(除非在P=NP这个关键问题上有突破).关于DS问题近似算法有两点情况值得重视:一是贪心策略实际效果良好,所得某类支配集|XDS|值接近精确解的值;二是近似算法所得结果与精确结果相比的实测平均近似度远好于理论近似度,这种差异产生的原因尚未明了.最后,我们对文中介绍的算法进行了简单测试,考察精确算法解决问题规模,即图顶点数.实验在一台Dell家用笔记本电脑上进行,配置为:CPU,IntelYonah1.6GHz;内存,2.5GBDDR2667;操作系统为WindowsXP.实验结果见表2.表2中,我们限制算法运行不超过一天的工作时间,输入为无线网络应用领域所常用的任意无向图UDG(应用广泛)、GG、DTG、MST等[42],为节约空间只列出最终统计结果.Page11表1一些重要的最小支配集及相关问题精确算法列表timeO(20.61n)O(20.598n)O(20.276n)Furer,2006,[36]O(20.3063m-n)polynomialMeasurem-nMWDS(all)weightedISthenumberofmaximumMinDominatingCliqueKratsch,2006,[38]O(20.4212n)Exis.DominatingCliqueMaxDominatingCliqueMinDominat.Clique问题种类及算法8小时内可解决MDS[21]LS[27]MIS[30]MCDS[31]MIDS[32]MWDS[27]关于表2做两点说明:(1)问题的性质依赖输入图的类型.对于某些问题,当输入是MST(最小生成树)时,问题性质可能退化为一个多项时间内就能解决的问题,例如MDS算法只产生简化点,不产生分支点,表2最终统计结果中排除了此类现象;(2)限定时间内可解决问题规模严重依赖于图的平均邻节点度,过大(接近完全图)或过小(接近树)实际上都导致可解决问题规模迅速增加,远超表2中值,此类结果被排除.参考表2,同为NP难题,为什么有的问题可以获得较快的算法,而有的却不能?值得思考.在可预见时期内,我们难以指望摩尔定律对解决问题提供多大帮助,追寻更快的算法、更好的复杂度分析技术、组合优化理论将是未来一段时期内的主要研究方向.ComplexitypolynomialexponentialpolynomialexponentialRecurrenceequationscomplicated5后记文中提供的算法经过了校验和测试.就作者所知,迄今(至2010年),文中介绍的算法仍是同类问题算法中最快的之一[43].附录5提供例图(图2(a))点坐标及生成方法,读者可自行检验.限于水平,我们的理解难免存在谬误,欢迎指出,我们将及时改正.致谢挪威UniversityofBergen的FedorV.Fomin教授和AlexeyA.Stepanov博士的耐心帮助使本文工作得以进行,谨致敬意并衷心感谢!
