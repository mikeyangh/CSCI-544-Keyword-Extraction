Page1Camellia访问驱动Cache计时攻击研究赵新杰王韬郑媛媛(军械工程学院计算机工程系石家庄050003)摘要Camellia是NESSIE计划中128位分组密码的最终获胜者.现有的针对Camellia的Cache计时攻击大多基于时序驱动模型,需百万计的样本在几十分钟内完成.文中研究表明,由于频繁的查找表操作,Camellia对访问驱动Cache计时攻击也是脆弱的,攻击所需样本量比时序驱动要小.首先,基于访问驱动方式,给出了一种通用的针对对称密码S盒的分析模型,指出Camellia加密过程中的轮函数易泄露初始密钥和轮密钥的异或结果值,密钥扩展中的左移函数使得Camellia安全性大大降低.然后,给出了多例针对Camellia-128/192/256的访问驱动Cache计时攻击,实验结果表明:500和900个随机明文样本可恢复Camellia-128、Camellia-192/256密钥,文中的攻击可被扩展到针对已知密文条件下的解密过程或远程环境中进行实施,3000个随机明文可在局域网和校园网环境下恢复Camellia-128/192/256密钥.最后,分析了Camellia易遭受Cache计时攻击的原因,并为密码设计者提出了防御该攻击的一些有效措施.关键词Camellia-128/192/256;分组密码;访问驱动;Cache计时攻击;旁路攻击;远程攻击;F函数;查找S盒;左1引言1.1相关工作近来,随着旁路攻击的引入,各类密码算法均面临严峻威胁.传统来说,密码算法的安全性取决于数学函数EK[P]→C,攻击者试图根据明文或密文信息,利用线性和差分数学分析方法去推测密钥K.随着密钥长度和设计复杂度的增加,密码算法的安全性得到了很大提升,传统的数学分析已远远不能在有效时间和空间复杂度内完成攻击.然而,最近的研究表明在密码算法的执行过程中,可能会泄露出执行时间、能量消耗、电磁泄露、故障输出等物理效应信息,通常称之为旁路信息.实际上,确切的密码算法实现函数应该为EK[P]→(C,L),旁路信息L和加解密密钥K紧密相关,通过一定的分析方法,结合明文或密文,攻击者可快速推测出密钥K.本文所描述攻击用到的是通过数据Cache部件单元泄露出来的时间旁路信息.Cache计时攻击是一种新的旁路攻击方法,其可行性首先由Kocher[1]和Kelsey等[2]在1996年提出,其假定攻击者可以通过一个合法的用户来测量时间信息进而预测Cache访问信息,而这些条件在现实中往往是可行的.Page[3]等在2002年仿真实现了针对DES的Cache计时攻击;随后,Tsunoo等[4-5]等提出了首例实际的针对DES和Camellia的Cache攻击;2004年Yoshitaka[6]等对Tsunoo攻击进行了改进;2005年Bernstein[7]与Osvik,Shamir和Tromer[8-9]两个小组在各自的研究中发现,AES也易遭受Cache计时攻击,这极大地引发了密码界对Cache计时攻击研究的热情,后续的研究有对前人攻击验证[10-11]、攻击改进[12-15]、攻击防御[16-18].目前的Cache计时攻击主要针对DES和AES,防御方法也主要定位在密码算法实现过程中,只有Tsunoo[5]和Yoshitaka[6]对Camellia-128进行了Cache计时攻击研究.在Tsunoo攻击中,从228个随机明文中挑选出218个加密时间较短的样本,经35分钟左右分析后恢复Camellia-128密钥.Yoshitaka在Tsunoo攻击基础上,使用221.4个明文22分钟左右成功恢复Camellia-128密钥,上述两例攻击都是通过测量整个加密时间并分析密码某次查S盒运算中Cache访问碰撞带来的时间关系推断密钥,攻击属于时序驱动方式,一般需百万计的样本恢复密钥,而且在远程攻击条件下,即使是传输时延的抖动时间都要远大于整个加密时间,所以他们的攻击在真正远程环境中很难实现.本文提出了多例针对Camellia-128/192/256的访问驱动Cache计时攻击,使用了一个间谍程序来采集Camellia加密中访问的Cache组集合信息,经一定的分析来预测密钥,实验结果表明,无论是已知明文、已知密文、本地和远程条件下,针对Camellia-128/192/256的访问驱动Cache计时攻击都可在3000样本量以内经1秒钟的分析完成,攻击对象为2009年7月最新发布的OPENSSL-1.0.0-beta3中的Camellia算法实现.1.2本文的贡献本文研究的主要贡献如下:(1)给出了一种通用的针对使用S盒的对称密码的访问驱动Cache计时分析模型.该模型可被应用到AES、SMS4、Camellia、ARIA、HC-128、HC-256等使用S盒的对称密码攻击中,并且可用于对这些算法抗Cache计时攻击能力进行评估测试.(2)指出Camellia的F轮函数可能会泄露密钥相关信息.Camellia的F函数中进行了多次查表操作,查表索引值和初始密钥、扩展密钥紧密相关,经访问驱动Cache计时分析可获取这些相关密钥信息,具体来说,加密中的F函数可泄露初始密钥和扩展密钥的异或结果值,而密钥扩展中的F轮函数则可直接泄露初始密钥或扩展密钥值.(3)Camellia密钥扩展中使用的左移函数使得Camellia安全性大大降低.攻击者如果找到对同一密钥相关变量左移前和左移后的一个异或碰撞,就很容易恢复该变量值,然后结合算法设计快速破解密钥.本文实验结果表明仅仅通过分析Camellia-128密钥扩展中一个初始密钥相关的左移15位函数就可将其搜索空间由2128降低到2.Camellia-192/256的密钥扩展设计也存在缺陷,其第3、4轮和第5、6轮扩展密钥分别根据对KA和KR左移15位生成,通过对Camellia加密Page3前6轮进行Cache计时攻击,可直接获取密钥扩展第5个F函数的输入值KAKR,然后得到密钥扩展第6个F函数的输出值KB,经进一步分析,可直接获取Camellia-192/256初始密钥.(4)提出并实现了多例针对Camellia-128/192/256的访问驱动Cache计时攻击.本文设计实现了多例针对Camellia-128/192/表1针对Camellia的Cache计时攻击结果比较文献[5]给出的攻击文献[6]给出的攻击第4节给出的攻击第6节给出的攻击第7节给出的攻击第5节给出的攻击第6节给出的攻击第7节给出的攻击(5)探讨了针对Camellia的访问驱动Cache计66444666时攻击原因并给出了可能的防御措施.针对Camellia的访问驱动Cache计时攻击根本原因在于Camellia算法自身,其F函数和密钥设计存在Cache计时信息泄露安全缺陷,并可用于快速恢复密钥.因此,本文在第8节探讨了密码设计者如何提高Camellia抗Cache计时攻击的能力.1.3结构组织本文第2节给出了针对Camellia的Cache计时攻击相关背景知识;第3节提出了基本的攻击模型,并阐述了如何将该模型应用到Camellia的F函数分析中;第4小节和第5小节分别给出了针对Camellia-128和Camellia-192/256的已知明文访问驱动Cache计时攻击;第6和第7小节分别给出了已知密文和远程条件下的Camellia攻击;第8小节对针对Camellia的访问驱动Cache计时攻击进行了讨论分析,并向密码设计者提出了防御该类攻击的一些可能防护措施;第9节为结束语.2相关知识2.1符号标记:异或操作.‖:两个变量的连接.<<<n:左移n位.S1,S2,S3,S4:OPENSSL-1.0.0-beta3中Camellia实现中的4个S盒,分别对应其中的SBOX1_1110,SBOX2_0222,SBOX3_3033,SBOX4_4404.256的访问驱动Cache计时攻击,实验结果表明,即使是使用了混淆层函数FL/FL-1的Camellia算法,实现也易遭受访问驱动Cache计时攻击,攻击可被扩展至已知密文甚至是远程环境条件下,3000个样本左右可在局域网或校园网环境下快速恢复Camelia-128/192/256密钥.表1给出了本文攻击结果同前人攻击比较.XL,XR:128位变量X的左半部分和右半部分数据.K,KE:Camellia加解密初始密钥和扩展密钥.sri:第r轮F函数的第i个32位输入.δ:一个Cache块中的Cache元素数量.2.2Cache计时攻击Cache计时攻击主要利用从Cache中加载数据到CPU寄存器要比从RAM中要快的特性进行密码分析.通过测量密码算法实现过程中由于Cache访问带来的时间差异信息,攻击者可以推测密码算法实现的内部状态信息.下面,我们将阐述Cache成为计时旁路攻击隐通道的原理.Cache工作机制现代微处理器大都使用高速缓存Cache来解决CPU与主存之间速度不匹配问题.假设整个Cache包括S个Cache组,每个组有W个Cache行,每个行有δ个元素(B字节),则整个Cache大小为S×W×B字节.主存地址和Cache之间的映射关系如下:特征1.CPU读取主存中一个字A时,首先将A地址放入主存地址寄存器,Cache控制逻辑依据地址判断A当前是否在Cache中,如果是则地址变换成功,发生“Cache命中”;否则发生“Cache失效”,把包括A在内的一整块数据都从主存中读出来,装载到Cache中去.特征2.在组相连Cache中,每一个主存块只能被映射到固定的Cache组中,具体来说,Cache地址为a的内存块只能被映射到Cache组[a/B]mod/S中.Page4由特征1可知同样一条访问存储器的指令在目标数据不在Cache内需访问主存时就可能产生延迟,而这种延迟的表现就是程序较长的运行时间或较大的能量消耗,就典型处理器来说,“Cache命中”时直接访问Cache需要2~4个时钟周期,而“Cache失效”时访问主存则需要12~100时钟周期,因此Cache为密码实现提供了时间信息泄露源.由特征2可知,不同进程在对自身数据进行内存访问时,这些数据可以被映射到同一Cache组中进而共享Cache存储空间,恶意进程可以通过对自身数据Cache访问时间或者能量消耗差异来监测其它进程的Cache组访问特征,故Cache也为密码实现提供了时间信息泄露隐通道.据上可知,攻击者可能获取到密码算法实现过程中访问的Cache组集合信息,在本地攻击中,这些采样信息噪声比较小,而在远程攻击中,由于网络发包拆包本身要对Cache进行大量的访问,带来的系统噪声比较大,但通过多次采集或增加样本数量,仍可获取有效的Cache采样信息.需要注意的是,虽然Cache内容受存储器保护,攻击者无法直接获取,但其元数据会泄露Cache访问地址信息,而这些地址信息和分组密码查找S盒索引有密切关系,可被攻击者用来进行密码分析攻击分类及可行性分析根据计时攻击部件不同,可将Cache计时攻击分为针对数据Cache、指令Cache两种.由于现代分组密码大多使用S盒查找表访问数据Cache,所以目前利用数据Cache进行攻击的对象主要为分组密码;同样,现代公钥加密系统大都使用了大量的指令访问操作,其加解密过程中由于密钥位值不同所要进行的指令访问操作数目有很大的区别,此时会导致对指令Cache访问次数及时间存在很大区别,所以目前利用指令Cache的攻击对象主要是公钥加密系统.根据所采集的时间信息不同,又可将Cache计时攻击分为时序驱动、访问驱动、踪迹驱动3种方式.时序驱动攻击采集的是密码进程整个加解密时间,采集方法简单,平台适用性强,但所需样本量大,一般都要百万计,离线分析方法比较复杂.更重要的是,在远程环境中,网络传输时延甚至是抖动时延都要远大于加密时间,采集到精确的加密时间显得极为困难,远程攻击适用性不强.访问驱动攻击主要利用间谍进程采集密码进程加解密中访问的Cache组集合信息,采集方法比时序驱动稍显复杂,但分析方法比较简单,在木马植入技术日趋成熟的今天,攻击本地和远程实现可行性比较强.踪迹驱动攻击比访问驱动攻击信息采集精度更高,攻击方需精确采集密码进程一次加解密过程中每次查表Cache访问的命中和失效信息,通过计时手段很难实现,一般都通过功耗检测手段进行,需物理接触密码设备,因此攻击不论在本地还是远程通过计时实现可行性都不强.基于访问驱动Cache计时攻击的可行性:我们选择访问驱动作为攻击模型,Camellia分组密码作为攻击对象,显然,攻击属于数据Cache计时攻击.2.3Camellia算法Camellia[19]是由NTT和Mitsubishi电子公司在2000年联合提交的一个分组密码,在2003年被选择成为欧洲NESSIE计划的获胜者,2009年3月,Camellia被集成到OPENSSL-1.0.0-beta1[20]密码库中,对Camellia算法的完整介绍可参考文献[19,21],下面仅对本文中用到的Camellia特性进行描述.加密过程.Camellia是一个迭代型分组密码,分组长度为128比特,支持128、192和256比特3种规模的密钥长度,采用Feistel整体结构.为提高安全性,在第1轮前和最后一轮后分别做前期和后期白化,即子密钥加,同时每隔6轮增加一个不规则轮,即FL/FL-1混淆函数层.设Lr和Rr为第r轮的输入,则轮变换可表示为其中kr为第r轮的子密钥,F=P·S为轮函数,S和P定义如下:S:F642→F64l1(8)‖l2(8)‖l3(8)‖l4(8)‖l5(8)‖l6(8)‖l7(8)‖l8(8)→l1(8)‖l2(8)‖l3(8)‖l4(8)‖l5(8)‖l6(8)‖l7(8)‖l8(8)l1=s1(l1),l2=s2(l2),l3=s3(l3),l4=s4(l4),l5=s2(l5),l6=s3(l6),l7=s4(l7),l8=s1(l8).2→F64P:F64z1(8)‖z2(8)‖z3(8)‖z4(8)‖z5(8)‖z6(8)‖z7(8)‖z8(8)→z1(8)‖z2(8)‖z3(8)‖z4(8)‖z5(8)‖z6(8)‖z7(8)‖z8(8)z1=z1z3z4z6z7z8,z2=z1z2z4z5z7z8,z3=z1z2z3z5z6z8,z4=z2z3z4z5z6z7,z5=z1z2z6z7z8,Page5z6=z2z3z5z7z8,z7=z3z4z5z6z8,z8=z1z4z5z6z7.密钥扩展算法.首先由初始种子密钥和64位常量Σi(i=1,2,…,6)经过几个轮函数F生成4个128位变量KL、KR、KA和KB,白化层子密钥kwi(64)、普通轮密钥ki(64)、FL/FL-1函数层子密钥kli(64)均由KL、KR、KA和KB循环移位而成,详见文献[19].3攻击模型3.1通用攻击模型现在软件实现的分组密码大都使用许多S盒查表访问Cache来提高效率,在S盒查表过程中,常满足其中,α表示明文、密文或中间状态的一部分,常为1个字节;β表示同密钥和扩展密钥相关的密码参量;γ表示查表结果或索引值;⊙表示加密查表α和β之间的逻辑操作,常为异或操作.式(1)可转换为由2.2节可知,攻击者通过访问驱动方式采集Cache计时信息,可获取到密码算法实现过程中访问过和未访问过的Cache组集合,并转换为查表索引或结果γ,由于α通常已知,根据式(2),不难预测β候选值,进而计算出密钥K,分析过程通常采用下列策略.策略1.分析查表中未访问过的Cache组集合.通过分析Cache组集合和S盒索引值的映射关系,未访问过的Cache组集合可转化为不可能的查表索引或结果γ,结合α和式(2),可得到一组β的不可能候选值,多个样本排除分析后可获取正确的β值,然后推断出密钥K.策略2.分析查表中可能访问的Cache组集合.首先为每个β候选值设置一个计数器,然后固定α值,产生一些随机样本P进行加密,得到加密访问的共同Cache组信息,转化为多个可能的γ候选值,根据式(2)得到β的多个候选值,并为每个β候选值对应计数器加1,由于加密密钥是唯一的,正确的β值每次都被预测到,多次预测后,出现频率最高的β值即为正确的β值,然后经进一步分析推断出密钥K.由于每一个加密没有访问的Cache组关联δ个(通常δ等于16)查表索引和结果值,使用策略1时每一个加密没有访问的Cache组可排除δ个β候选值,同策略2相比,分析效率要比较高,故下文中我们主要采用策略1对Camellia进行Cache计时分析.3.2针对CamelliaF函数的攻击模型根据2.3节,Camellia每个F函数执行8次查找表操作,对4种S盒分别进行2次查表操作.图1给出了OPENSSL-1.0.0-beta3中CamelliaF函数的C语言实现代码.#defineCamellia_Feistel(_s0,_s1,_s2,_s3,_key)do{\1registeru32_t0,_t1,_t2,_t3;\2\3_t0=_s0(_key)[0];\4_t3=S4[_t0&0xff];\5_t1=_s1(_key)[1];\6_t3=S3[(_t08)&0xff];\7_t2=S1[_t1&0xff];\8_t3=S2[(_t016)&0xff];\9_t2=S4[(_t18)&0xff];\10_t3=S1[(_t024)];\11_t2=_t3;\12_t3=RightRotate(_t3,8);\13_t2=S3[(_t116)&0xff];\14_s3=_t3;\15_t2=S2[(_t124)];\16_s2=_t2;\17_s3=_t2;\}while(0)图1OPENSSL-1.0.0-beta3中CamelliaF函数C语言代码假定输入值_s0,_s1,_s2,_s3可表示为其中,_s表示_s0,_s1,_s2或_s3;α表示明文或已知中间状态变量;β1和β2分别表示初始密钥K和扩展密钥KE的一个字节.根据代码第4,6,7,8,9,10,13,15行,可知查找Sn表的索引值为其中,φ函数表示返回32位值的第n个字节值.由于γ的不可能候选值可通过访问驱动Cache计时攻击采集阶段获取到,α和n已知,则β1β2的不可能候选值可以被预测并排除掉,使用更多的样本进行分析,正确的β1β2可被获取到.4Camellia-128攻击4.1前4轮攻击假定X为明文P和128位加密密钥K(也可表Page6示为KE0,KE1,KE2,KE3)的异或结果,在Camellia加密第1轮的F函数中,式(3)和(4)中的β1可表示为KE0,KE1,则可得到第1轮8次查表索引γ1=P0KE0,0KE4,0,γ1=P7KE1,3KE5,3,γ2=P1KE0,1KE4,1,γ2=P4KE1,0KE5,0,γ3=P2KE0,2KE4,2,γ3=P5KE1,1KE5,1,γ4=P3KE0,3KE4,3,γ4=P6KE1,2KE5,2其中,γn表示查找Sn的查表索引值,其不可能候选值可通过攻击信息采集阶段获取到,由于明文P已知,根据式(5)可得到KE0KE4和KE1KE5的不可能候选值,多次分析得到正确的KE0KE4和KE1KE5,并恢复第1轮F函数的8次查找S盒的输入索引值和结果值.则第1轮右半部分的输出2,s13可表示为其输入值同多个查表结果值的异值s1或结果,如式(6)所示,并可用于第2轮分析.s12=2S2[P4KE1,0KE5,0]S3[P5KE1,1KE5,1]s1S4[P6KE1,2KE5,2]S1[P7KE1,3KE5,3]S1[P0KE0,0KE4,0]S2[P1KE0,1KE4,1]S3[P2KE0,2KE4,2]S4[P3KE0,3KE4,3],s13=s13S2[P4KE1,0KE5,0]S3[P5KE1,1KE5,1]S4[P6KE1,2KE5,2]S1[P7KE1,3KE5,3]S1[P0KE0,0KE4,0]S2[P1KE0,1KE4,1]S3[P2KE0,2KE4,2]S4[P3KE0,3KE4,3]RightRotate(S1[P0KE0,0KE4,0]S2[P1KE0,1KE4,1]S3[P2KE0,2KE4,2]S4[P3KE0,3KE4,3],8)同样,根据Camellia加密第2轮F函数,可得到其中第2轮8次查表索引γ1=P8KE2,0KE6,0,γ1=P15KE3,3KE7,3γ2=P9KE2,1KE6,1,γ2=P12KE3,0KE7,0γ3=P10KE2,2KE6,2,γ3=P13KE3,1KE7,1γ4=P11KE2,3KE6,3,γ4=P14KE3,2KE7,2应用3.2节F函数分析模型,正确的KE2KE6和KE3KE7可被预测出,第2轮的右半部分输出同样可表示为第2轮的右半部分输入同多个查表结果值的异或结果s22=s22S2[P12KE3,0KE7,0]S3[P13KE3,1KE7,1]S4[P14KE3,2KE7,2]S1[P15KE3,3KE7,3]S1[P8KE2,0KE6,0]S2[P9KE2,1KE6,1]S3[P10KE2,2KE5,2]S4[P11KE2,3KE6,3],s23=s23S2[P12KE3,0KE7,0]S3[P13KE3,1KE7,1]S4[P14KE3,2KE7,2]S1[P15KE3,3KE7,3]S1[P8KE2,0KE6,0]S2[P9KE2,1KE6,1]S3[P10KE2,2KE5,2]S4[P11KE2,3KE6,3]RightRotate(S1[P8KE2,0KE6,0]S2[P9KE2,1KE6,1]S3[P10KE2,2KE5,2]S4[P11KE2,3KE6,3],8)成功分析密钥KL值需对Camellia-128进行至少4轮攻击,应用3.2节攻击模型,结合前两轮攻击结果,可进一步得到第3、4轮的攻击结果,这样前4轮攻击结果如表2所示.加密轮1KE0KE4‖KE1KE5((KL<<<0)L(KA<<<0)L)2KE2KE6‖KE3KE7((KL<<<0)R(KA<<<0)R)3KE0KE8‖KE1KE9((KL<<<0)L(KL<<<15)L)4KE2KE10‖KE3KE11((KL<<<0)R(KL<<<15)R)4.2密钥扩展分析在对Camellia-128进行4轮攻击后,可获取到128位变量C=(KL<<<0)(KL<<<15),经下面算法分析可获取KL值:KL搜索算法.SearchingKL(SK,C).unsignedcharKP[128],cTempSK←Foreachifrom0x00to0x01{KP[0]←iForeachjfrom0to127{}}应用上面算法,最多可得到2个KL候选值,在某些情况下甚至可直接得到唯一的KL值.Page74.3攻击实验我们在64位AMD处理器上对OPENSSL-1.0.0-beta3中的Camellia实现进行了访问驱动Cache计时攻击实验,其中计时功能是通过调用RDTSC指令获取系统自上电以来的时间戳值实现的,加密功能是通过黑盒方式调用OPENSSL库中函数来进行的,图2给出了一个KE0KE4密码字节密钥搜索空间和样本量的关系,可见400个样本左右即可恢复一个KE0KE4密码字节.图2KE0KE4每个字节密钥搜索空间和样本量(N)的关系通过对Camellia前4轮进行攻击,利用4.2节方法对密钥扩展进行分析,可进一步得到128位初始密钥,实验结果表示大约500个样本即可快速恢复完整的Camellia-128密钥.5Camellia-192/256攻击Camellia-192/256加密过程同Camellia-128基本相似,不同的就是比Camellia-128多调用了6次轮函数和1次FL/FL-1函数.Camellia-192/256的密钥扩展算法比Camellia-128要复杂,对Camellia-128密钥扩展的密钥分析方法并不适用于Camellia-192/256,但这并不意味着Camellia-192/256要比Camellia-128安全.下面给出针对Camellia-192/256的分析和实验过程.5.1前6轮攻击应用3.2节CamelliaF函数访问驱动Cache计时攻击模型,Camellia-192/256前6轮攻击结果如表3所示.加密轮1KE0KE4‖KE1KE5((KL<<<0)L(KB<<<0)L)2KE2KE6‖KE3KE7((KL<<<0)R(KB<<<0)R)3KE0KE8‖KE1KE9((KL<<<0)L(KR<<<15)L)4KE2KE10‖KE3KE11((KL<<<0)R(KR<<<15)R)5KE0KE12‖KE1KE13((KL<<<0)L(KA<<<15)L)6KE2KE14‖KE3KE15((KL<<<0)R(KA<<<15)R)5.2密钥扩展分析通过对Camellia-192/256前6轮攻击,分析第3、4、5、6轮攻击结果,可获取密钥扩展中第5轮输入状态值(KA<<<15)(KR<<<15),由于Σ5为已知常量,根据密钥扩展算法,第6个F函数的输出值即KB(KE4,KE5,KE6,KE7)可得到,根据表3,KL和KR可被恢复出来,最终得到Camellia-192/256完整密钥.5.3攻击实验图3给出了Camellia-192/256一个KE0KE4字节密钥搜索空间同样本量的关系,可见600个样本可分析获取KE0KE4密钥字节,比Camellia-128所需的400个样本要大些,这主要是由于Camellia-192/256查表所用的192次要大于Camellia-128的144次,攻击采集到的加密没有访问到的Cache组数量要少些造成的.图3Camellia128and192/256中KE0KE4每个字节通过对Camellia前6轮进行攻击,利用5.2节方法对密钥扩展进行分析,实验结果表示大约800~900个样本即可快速恢复完整Camellia-192/256初始密钥.6已知密文攻击第4、5节给出了针对Camellia加密过程的已知明文Cache计时攻击,根据Camellia的对称密码特性,攻击者也可针对Camellia解密过程进行已知密文Cache计时攻击.6.1Camellia-128攻击攻击者首先采集到Camellia-128解密过程中的Cache组集合信息,根据式(4),通过对前4轮解密过程攻击,恢复相关密钥结果如表4所示.通过分析第3轮和第4轮攻击结果(KA<<<111)(KA<<<94),参考4.2节密钥恢复方法,可恢复1~2个KA候选值,然后进一步得到初始密钥KL.Page8解密轮1KE48KE44‖KE49KE45((KA<<<111)L2KE50KE46‖KE51KE47((KA<<<111)R3KE48KE40‖KE49KE41((KA<<<111)L4KE50KE42‖KE51KE43((KA<<<111)R6.2Camellia-192/256攻击攻击者首先采集到Camellia-192/256解密过程中的Cache组集合信息,根据式(4),通过对前6轮解密过程攻击,恢复相关密钥结果如表5所示.通过分析第3、4、5、6轮攻击结果,可恢复KAKR值,参考5.2节密钥恢复方法得到KB,KL,KR,进而得到初始密钥K.表5Camellia-192/256前6轮解密攻击结果解密轮1KE64KE60‖KE65KE61((KB<<<111)L2KE66KE62‖KE67KE63((KB<<<111)R3KE64KE56‖KE65KE57((KB<<<111)L4KE66KE58‖KE67KE59((KB<<<111)R5KE64KE52|KE65KE53((KB<<<111)L6KE66KE54‖KE67KE55((KB<<<111)L6.3攻击实验在4.3节环境下,我们对Camellia-128/192/256进行了Cache计时攻击实验,使用6.1节和6.2节分析方法,500和900个左右样本1s左右可分别恢复Camellia-128和Camellia-192/256密钥.图4本地攻击中一个样本Cache组访问时钟周期图图5远程攻击中一个样本Cache组访问时钟周期图7远程攻击在本地攻击实验中,我们在程序中通过黑盒方式调用OPENSSL密码库来进行攻击实验,攻击程序和加密服务之间并没有直接进行交互.为了表明本文攻击对远程环境下的适应性,我们将攻击程序和解密程序分开,在局域网和校园网环境下进行了远程攻击实验,实验结果良好.远程攻击实验使用了3个程序,攻击程序(AP)、Camellia服务程序(CSP)、间谍程序(SP).SP和CSP被部署在同一电脑上,SP通过观测访问自身数据命中、失效信息采集访问驱动Cache计时信息,攻击步骤如下:1.AP通知SP清空CSP所在电脑数据Cache,初始化Cache为一个固定状态;2.AP向CSP发送加密请求,CSP加密后将密文反馈给AP;3.AP收到密文后,通知SP再次访问Cache,根据命中失效信息采集CSP加密过程中访问过和没有访问过的Cache组集合信息.之后,SP将所采集信息发送给AP.计时信息对密钥K进行离线分析.4.利用相应的分析方法,AP对采集的访问驱动Cache远程攻击实验中我们发现,和本地攻击相比,远程攻击由于信息采集过程中网络发包拆包需多次访问Cache,带来一定的噪声,攻击样本量比本地大.本地和局域网环境下AES访问驱动Cache计时攻击一个样本中间谍程序对所有Cache组采样分别如图4、图5所示,其中横坐标表示Cache组序号,纵坐标表示Cache组访问时钟周期,易见,Camellia的4个S盒分别对应的起始Cache组为261,277,293,309,本地攻击中由系统进程和其它用户进程对Page9Cache访问带来的噪声比较小,对攻击影响不大,而远程攻击中网络发包拆包确实给攻击带来很大影响,但AES加密过程中查找多个表访问Cache组信息(方框选择区域中访问时钟周期较小的Cache组)仍可被采集到,攻击仍可成功实现,只是需要更多的样本量而已.实验结果表明3000个样本左右可恢复Camellia128/192/256完整密钥.8攻击分析与防护措施8.1攻击分析8.1.1和其它分组密码访问驱动Cache计时攻击我们对典型的几个分组密码进行了访问驱动Cache计时攻击实验,如AES、SMS4、Camellia,实验结果良好,证明文中3.1节攻击模型十分有效.(1)AES[22].对AES进行访问驱动Cache计时攻击只需获取任何一轮扩展密钥即可.在AES加密第1轮中,根据采集的加密访问Cache组集合信息及其转化的查表索引值,结合明文经分析可直接获取初始密钥;在AES最后一轮中,根据加密访问的Cache组集合信息及其转化的查表结果值,结合密文分析可恢复第10轮扩展密钥,根据AES可逆的密钥扩展结构,可直接恢复初始密钥.(2)SMS4[23].对SMS4进行攻击需要获取前4轮或最后4轮的扩展密钥.在SMS4第1轮攻击中,查表索引值等于3个32位明文字和第1轮扩展密钥rk0异或值,根据加密访问的Cache组集合信息及其转化的查表索引值,结合明文可恢复rk0,进一步可计算出第2轮的输入值.用同样方法恢复第2、3、4轮扩展密钥rk1,rk2,rk3,结合密钥扩展算法恢复128位SMS4初始密钥.同样,通过对SMS4最后4轮进行分析,可恢复rk28,rk29,rk30,rk31,结合密钥扩展算法恢复128位SMS4初始密钥.(3)Camellia.对Camellia进行访问驱动Cache计时攻击要比AES和SMS4复杂一些,因为Camellia查表索引值并不是简单的和初始密钥相关,而是同初始密钥和轮密钥的异或结果值相关,并且Camellia的密钥扩展过程也要比AES和SMS4复杂,但是由于其密钥扩展过程中使用了大量的左移函数,为Camellia密钥分析提供了极大的便利.8.1.2攻击成功原因分析Camellia的F函数可泄露加解密密钥和扩展密钥异或结果,CamelliaS盒在Cache中的不对齐分布特性极大地加速了初始密钥和扩展密钥异或结果值的恢复,Camellia密钥扩展中的左移函数严重影响了其安全性.(1)CamelliaS盒在Cache中的不对齐特征假设O代表Camellia第一个查找表第一个字节在Cache组中的起始位置(0~15),根据O=0和O≠0两种情况进行如下分析:①Ol=0如果查找表第一个字节在Cache组中是对齐的,即其恰好对应Cache组的第一个字节,那么利用所采集的样本加密没有访问的每个Cache组将对应着16个高4位相同、低4位连续的索引字节,每次将排除掉16个高4位相同、低4位连续的密钥字节不可能值,而正确的密钥字节值不可能被排除;同样,同正确的密钥字节高4位相同、低4位不同的另外15个密钥字节也是不可能被排除掉的,这种情况下每个相关密钥字节候选值最多可从256降低到16.②Ol≠0那么如果查找表第一个字节在Cache组中不是对齐的,那么加密没有访问的每个Cache组将对应着两个查表行,第1个查表行对应16-O个索引,其高4位相同、低4位连续,第2个查表行对应O个索引,其高4位相同、低4位连续.这样每次排除的16个密钥和索引一样,均对应两个密钥行,第1个行对应16-O个值,高4位相同、低4位连续;第2个行对应O个值,高4位相同、低4位连续,易见,这两个行的数量越接近,即O=7、8时,排除效果越好,攻击所需样本量也小.以上可知,当Ol=0时,很难直接恢复Camellia初始密钥和扩展密钥的异或结果值,但是大部分情况下,Camellia查找表在Cache中是不对齐的,该特征极大地加速了Camellia的密钥恢复效率.(2)密钥扩展设计问题很多分组密码在密钥扩展中使用了左移和右移函数来产生扩展密钥,如Camellia、ARIA[24].①Camellia.Camellia-128的扩展密钥通过左移KL和KA产生,而Camellia-192/256的扩展密钥则通过左移KL,KR,KA和KB产生.我们称获取到某一个128位密钥相关状态值和其移位后的状态的异或结果为一个碰撞,那么一旦攻击者找到这样一个碰撞,应用4.2节分析方法,可快速恢复该128位密钥相关状态值.对于Camellia-128来说,第3、4轮攻击结果可找到KL的一个碰撞,初始密钥KL密钥Page10搜索空间可由2128降低到2;而对于Camellia-192/256来说,通过对第3、4轮分析可得到(KL<<<0)(KR<<<15),第5、6轮分析可得到(KL<<<0)(KA<<<15),进一步分析可直接得到KAKR,凑巧的是KAKR也是Camellia-192/256第5个F函数的输入值,进而可快速恢复KB、KL和KR.②ARIA.ARIA算法是韩国国家分组密码加密标准,常被应用到轻量级的密码设备中,分组长度为128位,支持128、192、256位3种密钥长度.在其加密过程中,查表索引值等于一个已知的中间状态值和轮密钥rkr的异或结果,通过访问驱动Cache计时攻击,可获取ARIA每轮的扩展密钥rkr,并不能直接获取初始密钥K.但在ARIA密钥扩展中,13轮扩展密钥均通过对4个128位变量W0,W1,W2,W3的经简单移位操作而得,通过分析前4轮的攻击结果,攻击者可找到W0的一个碰撞,然后直接获取初始密钥W0.因此,密钥设计者在密钥扩展设计中使用移位函数时一定要谨慎.8.1.3同前人远程Cache计时攻击比较在远程攻击方面,目前国内外已公布针对AES的Cache远程计时攻击只有Bernstein[7]和Acimez[14]两例,攻击均属时序驱动Cache计时攻击.(1)Bernstein远程攻击.攻击端和加密服务端虽部署在不同的PC机上,但负责采集从加密开始到完成时间信息并回传给攻击端的却是远程加密端,绝对消除了网络传输时延,使用227.5个样本恢复出128位AES密钥,这在实际攻击中是不现实的,攻击实际上仍属本地计时攻击.(2)Acimez远程攻击.攻击端和加密服务端部署在同一台PC机上,攻击端负责采集从加密开始到加密完成时间,也是在消除了网络传输时延的条件下,使用226.66个样本才恢复出完整密钥,验证了理想条件下进行时序驱动远程计时攻击的可行性.在真实远程条件下,网络传输时延本身甚至其抖动时延一般远大于加密时间,时序驱动Cache远程计时攻击信息的精确采集十分困难.本文实现的访问驱动Cache远程计时攻击,在很大程度上避开了时序驱动远程计时攻击中网络传输时延干扰比较大的问题,在局域网甚至不同教学楼之间的远程环境下将攻击端和加密服务端分别部署在不同的PC机上,同时将间谍程序植入到加密服务器上,受远程攻击端操控执行正常的数据访问操作采集Camellia加密过程中的Cache旁路信息,结合明文/密文对信息开展密钥分析,在有限样本下快速恢复完整Camellia密钥,攻击样本量和所需时间相对比较小.8.2防护措施本节只讨论从算法设计角度对Camellia访问驱动Cache计时攻击的防护措施.(1)使用多个密钥相关变量(至少3个)作为查找S盒的输入索引值.对于AES和SMS4分组密码,查表操作仅仅使用了一种密钥相关变量(初始密钥或扩展密钥),经过访问驱动Cache计时分析,攻击者可直接恢复初始密钥或扩展密钥.但Camellia查找表使用了两个密钥相关变量(初始密钥和扩展密钥),如果不对Camellia密钥扩展进行分析,将不能直接获取初始密钥,如果在Camellia加密查找S盒时,输入索引和3个以上密钥变量相关,则会大大增加攻击者分析的复杂度.(2)在相邻的两个或多个F函数之间插入FL/FL-1混淆层.在Camellia原有设计中,通过在每6轮插入由与、或、异或简单逻辑操作组成的FL/FL-1混淆层可大幅度提高非线性度和算法安全性.值得提出的是,由于Camellia中函数FL/FL-1混淆层存在,攻击者很难对第6轮后的其它轮进行成功攻击,但不幸的是攻击前6轮便足以恢复Camellia-128/192/256完整密钥.如果攻击者增加FL/FL-1混淆层的使用频率,如每隔两轮就插入FL/FL-1混淆层,则会大大增加攻击复杂度.(3)在扩展密钥生成过程中除了移位操作以外使用更多的其它线性逻辑操作,如异或、列混淆等.通过移位操作来产生轮密钥实现效率较高,但安全隐患比较大,一旦攻击者找到了对同一个密钥变量的一个异或碰撞,将很容易获取该密钥变量,经进一步分析获取初始密钥.在目前的Camellia实现中,仅使用了移位一种操作来生成扩展密钥,如果能在扩展密钥生成过程中增加更多的简单逻辑操作如与、或、异或等操作,也会在某种程序上大大增加攻击复杂度.另外,在Camellia-192/256密钥扩展算法设计中,我们也建议其在对KA和KR进行的移位操作位数不要相同.9结束语本文就当前最安全的Camellia分组密码算法Page11访问驱动Cache计时攻击进行了一些相关研究,研究结果表明此类针对Camellia的计时攻击手段对信息安全将带来突出威胁:首先,Camellia是目前欧洲和日本占主导地位的128位分组加密算法,因此,攻击产生的影响将是广泛而深远的;其次,实施攻击并不需要物理地获得密码执行部件以测量泄漏信息,在网络环境下也可成功获取远程加密服务器密钥;还有,此类攻击能够作用于一切实现于“Cache-Memory”层次存储结构计算机设备上软件形式的AES算法,从而危害到服务器、桌面以及嵌入式等各种主流的计算机系统.因此,应对这类攻击予以充分的关注.致谢感谢评审老师们的辛勤工作、郑天明硕士在Camellia密钥扩展分析中的精彩讨论、国家现代通信实验室罗岚副研究员对本文提出的宝贵建议以及美国麻省理工学院计算机科学与人工智能实验室的TromerEran博士对攻击分析和远程实验的建议!
