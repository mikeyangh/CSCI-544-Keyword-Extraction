Page1基于交互冲突的服务互操作匹配性检测公帅1),2)熊锦华1)刘志勇1),3)1)(中国科学院计算技术研究所网络数据科学与工程研究中心北京100190)2)(中国科学院大学北京100190)3)(中国科学院计算技术研究所计算机体系结构国家重点实验室北京100190)摘要随着互联网中包含多个交互的复杂服务的大量出现,如何有效检测服务之间的匹配性至关重要.与传统的业务流程互操作匹配性验证不同,在互联网环境下匹配性检测,一方面要面临如何实现快速检测的挑战,另一方面要解决如何准确地检测完整且精确的不匹配原因以便及时修正.为此,文中提出了一种基于交互冲突的服务互操作性检测方法,该方法利用局部交互之间的行为约束关系检测复杂服务互操作的匹配性,并形式化证明了该方法能够获得与经典的互操作匹配性检测方法一致的检测结果.与经典的互操作匹配性检测方法相比,该文方法时间复杂度低且检测结果可以确切地给出完整、精确的互操作不匹配的原因.关键词Web服务;业务流程;互操作;匹配性检测;行为约束关系1引言互联网正逐步从信息网络演化为应用程序或服务的网络.服务组合利用大量已有的服务构造满足用户个性化需求的应用.多个Web服务之间通过交互满足一个复杂业务功能,如何验证组合服务之间交互操作的匹配性是一个重要的研究课题.服务间的互操作匹配性可以分为语法、语义和行为匹配性[1].语法匹配性主要指服务之间消息格式的匹配性.语义匹配性主要指参与互操作的服务能否正确地理解传递的消息.行为匹配性主要是指服务间对于发送或者接收消息的顺序和条件能否达成一致[2].文中提到的服务间互操作的匹配性,无特别说明时指行为匹配性.有效验证互操作的匹配性可以确保为用户推荐正确的服务或组合服务以避免组合服务运行时出错造成损失.服务间互操作的行为匹配性主要指服务的业务协议间的匹配性.服务的业务协议(BusinessProtocol)定义了该Web服务所支持的接收或发送消息的顺序[3],并可以由业务流程建模语言表示.现有的很多研究工作[1,4-13]关注服务和业务流程间互操作的匹配性,然而目前研究工作主要存在以下两方面的不足,因而无法满足互联网环境下的Web服务互操作匹配性检测的要求:(1)对互操作匹配性的快速检测算法研究不多.首先,与传统的业务流程建模不同,通过服务组合形成的个性化服务不会长时间运行,并且经常是为了满足用户突发需求而实现的.其次,在服务组合过程中为用户推荐互操作匹配的服务也需要快速完成,越来越多的研究工作正试图解决这个问题[11-12].因此,快速检测服务之间的互操作匹配性十分必要.(2)由于服务组合技术能够很好地满足最终用户的个性化需求,服务间互操作匹配性检测的最终结果不应仅仅是简单的“匹配”或“不匹配”[5,13].用户往往需要明确地知道服务之间互操作不匹配的原因.具体来说,互操作不匹配的原因是指业务流程中哪些活动或交互造成了互操作不匹配.确定造成互操作不匹配原因的好处在于,一方面便于最终用户修改业务流程[14-15],另一方面也便于自动构造交互适配器[3,16].因此,为最终用户提供完整且精确的互操作不匹配的原因对于及时修正互操作不匹配至关重要.如何解决以上两个问题具有挑战性.首先,传统的业务流程互操作匹配性的检测工作需要将参与互操作的业务流程合并后[1,17]转化为Petri网,并判断Petri网是否弱良好[18-19].判断Petri网是良好(Soundness)或弱良好(WeakSoundness)需要构造可达标识图[20],时间复杂度高[11].其次,现有的研究工作[1,4-5,8,10]无法有效确定发生不匹配的原因,即哪些交互造成了业务流程的不匹配.文献[1]仅能得到发生不匹配时的业务流程执行轨迹.文献[5]同样指出了剔除出错时执行轨迹中的冗余信息,从而获得造成互操作不匹配的精确原因十分必要.文献[8]仅能发现第一个造成互操作不匹配的交互.文献[10]仅能在业务流程是部分匹配时,获得可完成交互的信息.文献[13]在不匹配发生时,为业务用户提供详细的业务分析报告,但其中并不包含造成互操作不匹配的详细技术原因.为了解决以上两个问题,本文提出了一种不依赖于业务流程全局状态的互操作匹配性检测方法,从而降低互操作匹配性检测的时间复杂度.本文首先获得任意交互之间的行为约束关系[14,21],行为约束关系有效抽象出业务流程的运行情况.在此基础上本文通过判断局部交互对之间是否冲突最终获得业务流程间互操作的匹配性.这种方法降低了算法的时间复杂度,判断互操作匹配性不再依赖于业务流程的全部状态,仅需要判断局部交互对之间是否有冲突.在发现所有相互冲突的交互后,为了提供精确且完整的互操作不匹配原因,本文提出了关键冲突交互集合概念.将识别关键冲突交互集合的问题转化为发现最小点覆盖集合的问题,并使用经典的匈牙利算法[22]来进行求解.本文主要贡献在于:(1)提出了一种行为约束关系模型刻画业务活动之间的局部行为特征,不仅仅有助于实现互操作匹配性的快速检测,并且可以应用在业务流程分析领域的其它问题中;(2)基于局部交互间的行为约束关系来判断它们是否相互冲突,从而检测业务流程间互操作的匹配性,无需遍历业务流程的全局状态,时间复杂度低;(3)进一步提出了采用匈牙利算法[22]发现造成互操作不匹配的精确原因以便及时修正;(4)形式化证明了由该方法得到的业务流程的匹配性,与经典的匹配性检测工作[1]等价,并在公开的SAP参考模型集合[23]上进行了评估.SAP参考模型数据集合已广泛应用在业务流程分析的研究工作中[19],并且其中包含的业务流程具有实际的业务含义.与已有研究工作相比,本文提出的方法能够给出完整且精确的互操作不匹配的原因,从而有助于及时修正互操作不匹配;同Page3时,本文方法比已有的方法在时间复杂度上有所降低.本文第2节介绍相关研究工作;第3节形式化描述行为约束关系、相关概念以及本文的重要假设;第4节详细介绍基于交互冲突的业务流程互操作匹配性的检测方法,并形式化证明该方法与经典的匹配性检测工作[1]等价;第5节给出实验的设置以及实验结果;最后是本文工作总结.2相关工作Web服务的业务协议通常可以由业务流程建模语言表示[2].本文研究工作主要涉及Web服务以及业务流程间互操作的匹配性检测工作[1,4-13].文献[9]对业务流程间互操作的匹配性进行了形式化的定义,但没有提出具体的检测方法.文献[1,4-5,7,11-12]采用Petri网模型检测业务流程间互操作的匹配性.文献[1]通过合并互操作的业务流程形成独立的Petri网并判断合并后的Petri网是否弱良好来检测匹配性.文献[11]通过在着色Petri网的模型中使用弱良好的概念检测服务间互操作的匹配性.文献[12]通过判断合并后的Petri网中是否包含死锁检测匹配性,并检测Petri网中是否存在非空的最小siphon结构来判断是否存在死锁.文献[6,8]使用进程代数模型并通过逐一匹配流程间的接收和发送消息检测匹配性.文献[10]采用状态机模型检测业务流程间互操作的匹配性,其通过构造完全执行树和交互树来判断匹配性.文献[13]主要关注业务流程高层次的业务交互,并且提出了一种基于场景的方法来检测业务流程间互操作的匹配性.近期的研究工作[5]解决不同业务流程之间具有对应关系的活动之间的匹配性问题,属于不同业务流程的活动之间的交互,也是对应关系的一种.下面本文主要针对现有研究工作在匹配性定义、检测方法的时间复杂度以及检测结果的精确性与完整性几方面进行详细讨论.2.1匹配性的定义服务间互操作的匹配性是业务流程检测中关注的一个重要属性.现有的研究工作对匹配性的定义没有完全统一.文献[18]定义了Petri网表示的工作流模型是良好(Soundness)的概念.良好的业务流程需要具备以下3个条件:(1)可结束的;(2)正确的结束;(3)无死迁移.文献[1]在此基础上使用弱良好的概念来定义业务流程间互操作的匹配性.文献[19]总结了业务流程良好概念的各种扩展,弱良好、k良好(ksoundness)、最大k良好(up-to-ksoundness)等.弱良好与良好的区别在于弱良好仅需要满足条可结束的(条件1)条件即可.文献[12]使用无死锁概念来定义匹配性,将参与互操作的服务合并为单一的Petri网模型后无死锁时服务是匹配的.文献[8]对互操作的匹配性定义模糊,只要参与互操作的业务流程不失败,则业务流程是匹配的.文献[9]定义了不同严格程度的匹配性,完全的匹配性和无死锁、无指定接收的匹配性.文献[10]定义了完全匹配和部分匹配的概念.文献[1]定义的业务流程互操作的匹配性具有良好的形式化基础,故本文形式化证明了基于交互冲突的业务流程互操作匹配性检测技术能够获得与文献[1]等价的匹配性.2.2检测方法的时间复杂度业务流程间互操作匹配性的检测与业务流程本身的检测工作密切相关.而检测一个业务流程是否良好的算法时间复杂度高.通过将工作流模型简单扩展,文献[18]使用Petri网理论中有界和活性的概念[20]判断业务流程是否良好.文献[5,18]在假设业务流程模型是自由选择网(Free-ChoicePetrinet)的情况下,证明了检测业务流程是否是良好,可以在多项式时间内完成.然而自由选择网的假设在实际中往往得不到满足.当自由选择网的假设不成立时,证明Petri网是有界的和活的,需要构造该Petri网的可达标识图[20],算法时间复杂度为指数.文献[24]总结了现有业务流程建模工具对流程良好性检测的支持.现有的工作流建模工具能够很好地支持语法层面的检测,包括格式是否良好,网关活动是否匹配等,并能在模型中直观地标注出错的位置,但对于死锁、缺乏同步等错误无法有效检测[24],其主要原因在于检测业务流程的良好性所需的时间复杂度高.文献[1]通过检测合并后的业务流程是否弱良好来确定匹配性.根据弱良好的定义,判断业务流程是弱良好的需要判断合并后的业务流程模型是否可结束,而判断Petri网可结束的算法时间复杂度为指数级.文献[11]通过判断合并后的Petri网模型中最小siphon结构是否为空来判断业务流程的匹配性,尽管寻找Petri网中最小siphon结构存在多项式时间复杂度的算法,但文献[11]定义的匹配性与弱良好相比较松弛,包含“未指定接收”错误的业务流程仍然是匹配的.文献[10]使用有限状态自动机表示Web服务的业务协议,通过构造完全交互树Page4判断业务流程间互操作的匹配性.文献[10]构造完全交互树的算法复杂度为O(S3),S表示Web服务业务协议的状态总和.随着业务流程规模的增加将面临状态爆炸的问题,状态数量远大于交互数量.文献[8]将服务编舞语言(WSCI)转化为进程代数模型,然后逐个匹配业务流程间的接收和发送消息直到发现无法匹配或者匹配结束,算法时间复杂度为O(N2),其中N表示参与互操作的交互活动、局部选择活动(localchoice)和全局选择活动(globalchoice)的总和,等价于业务流程中的节点数量总和.通过对实际数据的分析(图4)我们发现,业务流程的节点数量远大于交互数量.本文提出的基于交互冲突的业务流程匹配性检测方法的时间复杂度为O(|I|2),其中I仅包含发送或接收消息的活动,并不包含其它控制流活动.因此|I||N|且|I||S|,基于交互冲突的匹配性检测方法的时间复杂度小于现有的方法.检测结果对比见表1.基于Petri网模型[1,4-5,7,11-12]模型[10]O(S3),S表示状态总数完全匹配、部分匹配、基于有限状态机基于进程代数模型[8]O(N2),N表示活动和本文方法2.3检测结果的精确性与完整性文献[13]提出了需要对业务流程检测结果进行详细分析从而得到造成业务流程互操作不匹配的原因,而不仅仅是“匹配”或“不匹配”.文献[13]主要关注高层次的交互,并通过基于场景的技术为业务用户提供详细的业务分析报告,并不包含造成互操作不匹配的详细技术原因.文献[1,4-5,7,11]匹配性检测的结果仅仅是“匹配”或“不匹配”,没有指明互操作不匹配的原因.文献[10]通过构造业务流程间的完全交互树来判断业务流程间的互操作完全匹配或部分匹配.当业务流程是部分匹配时,至少可以得到一个完全交互树.完全交互树表示可以完成的交互集合.然而当业务流程间不是部分匹配时,该方法无法判断哪些交互是可以完成的,哪些交互不能完成.文献[8]递归匹配业务流程间的接收、发送消息的活动直到不能匹配时停止.文献[8]仅能获得造成互操作不匹配的一个原因.综上所述,现有的检测业务流程互操作匹配性的研究工作时间复杂度高且检测的结果不能给出完整、精确的互操作不匹配的原因.因此,不适合用于检测互联网环境下服务间互操作的匹配性.3形式化基础3.1基本概念和假设本文将业务流程表示为二元组P=〈T,BCR〉,T表示具有业务含义的活动(并不包括业务流程中的网关活动).行为约束关系BCR(BehaviorConstraintRelation)表示业务活动之间的二元行为约束关系BCRT×T.本文在下一节中详细讨论行为约束关系.业务流程间的一次消息传递定义为流程间的一次交互.交互可形式化地表示为序偶i=〈t1,t1〉,其中t1表示发送消息的活动,t1表示接收消息的活动,且t1和t1属于不同的业务流程.两个业务流程间的交互集合表示为I(P,P).业务流程的一次执行称为运行实例,可以形式化地表示为流程活动集合上的有序子集,记为ins.业务流程模型P的所有运行实例集合记为INS(P).函数index为定义在集合T以及集合INS(P)上的函数index:T×INS(P)→[0,N].函数值index(t,ins)表示业务活动t在流程实例ins中第index(t,ins)个被执行.基本概念及其形式化表示见表2.运行实例集合本文中一个重要的假设如下:本文中判断业务流程间互操作不匹配时,假设参与互操作的业务流程都是良好的,这是因为验证独立的业务流程模型是良好的已经得到了很好的解决[7,18-19],本文主要关注服务间互操作不匹配的检测.另外,本文主要关注两两业务流程间的匹配性检测,多个业务流程间的匹配性检测问题可在本文基础上参照我们以前的研究工作[21]解决.业务流程中活动之间的行为约束关系为集合T上的二元关系,在良好[13]的业务流程中,不同业务活动之间的关系有且只有一个.业务活动之间的行Page5为约束关系主要依据它们在流程实例中的共现情况和执行顺序或者通过遍历业务流程模型获得.我们的前期的研究工作[14,21]提出了6种行为约束关系,本文进一步对行为约束关系进行了简化,仅包括以下4种关系,分别为顺序前(Pre)、顺序后(Post)、并行(PL)、互斥(EX),不区分顺序前和部分顺序前以及顺序后和部分顺序后[14].这种简化在发现交互冲突时能够得到与简化行为约束关系前相同的结果,并且简化后提取行为约束关系的算法[21]复杂度也相应降低.行为约束关系有效抽象出了业务流程的执行情况,具有很强的推广性,不仅可以用来发现交互冲突[10]也可以用来度量业务流程的行为相似度[25].3.2行为约束关系抽象假设业务流程是良好的[18-19],根据业务流程模型或业务流程的运行日志活动间的行为约束关系可以形式化定义如下,这些定义主要用来从业务流程中抽取活动间的行为约束关系[21].业务流程的行为约束关系如图1所示.活动t1在t2之前执行,则t1Pret2.定义1.对所有包含活动t1、t2流程运行实例,ins∈INS(P),t1∈ins∧t2∈ins→定义2.对所有包含t1、t2的流程运行实例,活动t1在t2之后执行,则t1Postt2.ins∈INS(P),t1∈ins∧t2∈ins→定义3.对所有的流程运行实例,活动t1、t2总是同时出现且t1与t2并行执行,则t1PLt2.ins∈INS(P),index(t1,ins)=index(t2,ins).定义4.对所有的流程运行实例,活动t1、t2都没有同时出现过则t1EXt2.3.3Petri网Petri网既能描述系统的结构,又能模拟系统的运行[20].Petri网广泛使用在业务流程以及工作流管理系统的形式化分析中[18-19],并且许多研究工作将业务流程建模语言转化为Petri网来进行分析.本文使用Petri网来定义交互冲突,并基于Petri网理论证明本文中的无交互冲突的业务流程与文献[1]中定义的互操作匹配性等价.从形式上看,Petri网是一个没有孤立结点的有向二部图.之间的连线集合.中的几个重要概念如下[20]:定义5.Petri网是一个三元组(P,T,F):P是有限库所集合;T是有限迁移集合;F(P×T)∪(T×P),F是连接库所和迁移为便于读者阅读,本文中用到的Petri网理论(1)在任何时刻一个库所包含0个或多个令牌,令牌在库所中的分布情况就表示为Petri网的一个标识,可以形式化地表示为函数M:P-->{0,1,2,…}.(2)对于迁移t,若p∈P,p∈t→M(p)1,则说迁移t在标识M有发生权记为,M[t〉,t表示所有输入迁移t的库所.(3)若存在t使得,M[t〉M,则称M为从M直接可达.(4)若存在变迁序列t1,t2,…,tk和标识序列M1,M2,…,Mk使得M[t1〉M1[t2〉M2…Mk-1[tk〉Mk则称Mk为从M可达.从标识M可达的所有标识集合记为R(M).文献[1]扩展了基本的Petri网用来表示工作流模型,它引入了两个特殊的库所in和o,库所in表示业务流程的开始,库所o表示业务流程的结束.4基于交互冲突的服务互操作匹配性检测本节中详细讨论基于交互冲突的业务流程互操作匹配性检测方法.本节首先形式化定义了交互冲突,并基于此定义来判断任意两个交互在不同行为约束关系的情况下交互是否冲突,从而得到交互冲突判定表(表3).为了确保提供给用户完整且精确的业务流程互操作不匹配的原因,本文提出了关键冲突交互集合的概念,使用最小点覆盖集合发现算法来确定关键冲突交互集合.最后,本文形式化证明了基于交互冲突的业务流程匹配性检测方法能够得到与文献[1]等价的互操作匹配性.4.1交互冲突与互操作匹配性业务流程互操作匹配性表示了整个流程间互操Page6作是否匹配,而交互冲突表示了局部交互之间是否相互约束导致某个交互失败.考虑到局部交互之间相互制约导致交互失败,本文基于Petri网来形式化定义交互冲突.定义6.交互冲突.任意两个交互i1=〈t1,t1〉和i2=〈t2,t2〉(或者i1=〈t1,t1〉,i2=〈t2,t2〉)是无冲突的满足下面的条件:假设活动t1、t2属于流程P,活动t1、t2属于流程P.由于P和P是良好的(见3.1节的假设),根据文献[18],在流程P中存在标识M1[t1〉,M2[t2〉,在流程P中存在标识M1[t1〉,M2[t2〉,有M2∈R(M1)→M2∈R(M1)或者M1∈R(M2)→M1∈R(M2).在获得局部交互是否冲突后,本文定义业务流程互操作的匹配如下.定义7.业务流程互操作匹配.任意两个业务流程互操作匹配是指两个流程间的交互集合上不存在冲突的交互对.以上定义了基于交互冲突的互操作匹配性,本文在4.4节形式化证明了该定义与经典的互操作匹配性定义[1]定价.4.2交互冲突的发现本文根据任意两个交互之间的不同行为约束关系和定义6来判断交互是否无冲突,并在此基础上依据定义7检测业务流程间的互操作匹配性.由于参与互操作的业务流程本身是良好的,则任意两个交互之间在同一个业务流程中仅能得到无歧义的单一行为约束关系.又由于本文主要关注两两业务流程间互操作的匹配性,任意两两交互之间仅存在两个行为约束关系.下面本文判断当两两交互之间出现不同行为约束关系时,它们是否冲突.假设业务流程P和P之间存在两个交互i1=〈t1,t1〉,i2=〈t2,t2〉并且t1∈P,t1∈P,t2∈P,t2∈P.标识M1[t1〉,M2[t2〉,M1[t1〉,M2[t2〉.(1)当交互之间关系为(Pre,Pre)或(Post,Post)时,彼此不冲突.假设两个交互i1、i2之间的行为约束关系在流程P中为t1Pret2,在流程P中同样是t1Pret2.根据定义1可知同时包含t1、t2的P流程实例中t1总是先于t2执行,因此在业务流程P中可以得到M2∈R(M1).同理在流程P中也能得到M2∈R(M1).因此,根据定义6可以得到交互i1、i2是无冲突的.同理当两个交互i1、i2之间的行为约束关系在流程P中为t1Postt2,在流程P中同样是t1Postt2时,i1和i2也是无冲突.(2)当交互之间关系为(PL,Pre)或者(PL,Post)或者(PL,PL)时,彼此不冲突.假设两个交互i1、i2之间的行为约束关系在流程P中为t1PLt2,在流程P中为t1Pret2.根据定义3,在流程P的运行实例中t1和t2总是同时被执行,那么存在一个标识M同时使得交互M[t1〉且M[t2〉,即M1=M2=M,M2∈R(M2),R(M2)=R(M1).根据定义1,在同时包含t1、t2的P流程实例中,t1总是先于t2执行,因此M2∈R(M1).根据定义6可以得到交互i1、i2是无冲突的.同理当两个交互i1、i2之间的行为约束关系在流程P中仍为t1PLt2,而在流程P中为t1Postt2时,i1和i2也是无冲突.同理当两个交互i1、i2之间的行为约束关系在流程P中仍为t1PLt2,而在流程P中是t1PLt2时,i1和i2也无冲突.(3)当交互之间关系为(EX,EX)时,彼此不冲突.假设两个交互i1、i2之间的行为约束关系在流程P中为t1EXt2,在流程P中是t1EXt2.根据定义4,不存在流程P的运行实例同时包含t1、t2,因此M2R(M1),M1R(M2).同样不存在流程P的运行实例同时包含交互t1、t2.因此,M2R(M1)M1R(M2),其中M1[t1〉并且M2[t2〉.根据定义6可得,交互i1和i2是无冲突的.(4)当交互之间关系为(Pre,Post),彼此冲突.假设两个交互i1、i2之间的行为约束关系在流程P中为t1Pret2,在流程P中是t1Postt2.根据定义1可知,在流程P中同时包含t1、t2的流程实例中t1总是先于t2执行,因此M2∈R(M1).而根据定义2可知,在流程P中同时包含t1、t2的流程实例中t2总是先于t1执行,因此M1∈R(M2).根据定义6可知,交互i1、i2是有冲突的.同理当两个交互i1、i2之间的行为约束关系在流程P中为t1Postt2,在流程P中是t1Pret2时,交互i1和i2也是有冲突的.(5)当交互之间关系为(EX,Pre)或者(EX,Post)或者(EX,PL)时,彼此冲突.假设两个交互i1、i2之间的行为约束关系在流程P中为t1EXt2,在流程P中是t1Pret2.根据定义4不存在流程P的运行实例同时包含t1、t2,故M2R(M1),M1R(M2).根据定义1,在流程P中同时包含t1、t2的流程实例中t1总是先于t2执行,因此M2∈R(M1).根据定义6,交互i1、i2是有冲突的.同理当两个交互i1、i2之间的行为约束关系在流程P中为t1EXt2,流程P中是t1Postt2时,i1和i2也是有冲突的.同理当两个交互i1、i2之间的行为约Page7束关系在流程P中为t1EXt2,流程P中是t1PLt2时,i1和i2也是有冲突的.综上所述,任意两个交互之间的两个行为约束关系在不同组合情况下交互是否有冲突即能获得,总结为表3.因此,在获得交互之间的行为约束关系之后,交互是否有冲突不再需要定义6来判断,仅仅通过表3即可获得,既缩短了发现交互冲突所需的时间,也保证了交互冲突判定的有效性.在获得任意两个交互之间的行为约束关系后,判断任意两个交互是否冲突所需的时间复杂度为O(1).由于行为约束关系有效抽象出了业务活动之间的执行情况,该方法具有推广性.在判断交互冲突时,不再需要遍历业务流程中可能出现的所有状态.表3交互冲突判定表(依据两两交互之间的不同行为约束关系判断交互冲突:0表示交互不冲突;1表示交互冲突)P\PPrePostPLEXPre0101Post1001PL0001EX1110业务流程间的任意两个交互之间是否冲突可以通过表3判定,业务流程间所有相互冲突的交互对集合记为完整冲突交互对集合CIMS(CompleteInteractionMismatchpairSet).由于交互之间是否冲突的是对称的,为了获得CIMS需要检测C2n次交互对是否冲突,n表示两个流程间的交互数量|I(P,P)|,算法的时间复杂度为O(|I(P,P)|2).由于算法需要保存任意两个交互之间的行为约束关系,该算法的空间复杂度为O(|I(P,P)|2).操作匹配,否则服务互操作不匹配.4.3互操作不匹配精确原因的发现在获得业务流程间所有冲突的交互后,CIMS集合中包含了所有造成业务流程不匹配的交互对.然而CIMS中包含冗余的冲突交互.如图2所示,交互i1与i3之间冲突,交互i2与i3也冲突,在CIMS中i3出现2次.为了提供完整且精确的互操作不匹配的原因,需要对CIMS进一步分析剔除冗余的交互.为此本文提出了关键冲突交互集合的概念记为KMIS(KeyMismatchInteractionSet),关键冲突交互集由若干交互组成(非交互对),这些交互覆盖了所有相互冲突的交互对,并且包含的交互数量最少.可以形式化地定义如下:KMIS∈{I|(〈i1,i2〉)(i)(II(P1,P2)∧最后根据定义7,若CIMS为空,则服务间的互|KMIS|=argminI(|I|).首先构造流程间的交互冲突矩阵犃,若交互i与交互j冲突,则犃i,j=1,否则犃i,j=0.由于交互之间是否冲突是对称的,矩阵犃可以表示为无向图的邻接矩阵.本文将关键冲突交互集合的发现问题转化为发现由犃作为邻接矩阵表示的无向图中寻找最小点覆盖集合的问题.现有解决最小点覆盖问题的方法主要针对二分图进行.若由邻接矩阵犃表示的无向图可能包含奇数条边的回路时,该无向图不能构造为二分图进行最小点覆盖集合的求解.因此,当犃表示的无向图中出现奇数条边的回路时,本文对该回路进行处理,增加一个交互i,将其与回路中任意两个相邻交互相连.最后,从关键冲突交互集合中剔除交互i.在此基础上,本文使用深度优先遍历算法构造出二部图,并使用匈牙利算法[22]求解最小点覆盖集合.深度优先遍历由犃表示的无向图的时间复杂度为O(|犃|2),使用匈牙利算法求解最小点覆盖集合的算法时间复杂度为O(|犃|3).由于|犃||I(P,P)|,识别关键冲突交互集合的算法时间复杂度为O(|I(P,P)|3).由于算法运行中需要存储邻接矩阵犃,该算法的空间复杂度为O(|I(P,P)|2).综上所述,基于交互冲突的互操作不匹配检测算法可以总结如下.算法.算法1.基于交互冲突的互操作不匹配检测输入:业务流程模型P、P输出:关键冲突交互集合KIMSExtractControlFlowRelations(P,P);foreachinteractionpairi1,i2inI(P,P)if(isConflict(i1,i2)//根据交互冲突判定表CIMS.add(i1,i2);graph=BuildGraph(CIMS);//构造二部图KIMS=MinCover(graph);//最小点覆盖集合4.4匹配检测的有效性由于文献[1]定义的业务流程匹配性具有良好的形式化基础,本文形式化地比较了本文定义的互操作匹配性(定义7)与文献[1]定义的匹配性.从而Page8形式化证明了基于交互冲突的业务流程互操作匹配性检测方法的有效性.定义8[1].业务流程之间是匹配的当且仅当将参与互操作的业务流程合并后的Petri网模型是弱良好的,即[o]∈R(M),其中o表示Petri网的结束库所.在合并业务流程P和P时,将每个交互转换为库所,并按消息传递的方向连接代表发送和接收消息活动的迁移,然后为合并后的业务流程增加公共的开始库所in.in分别连接业务流程P和P的开始库所in1、in1以及公共的结束库所o.o分别连接业务流程P和P的结束库所o1、o1,并且满足若存在标识M,使得M(o1)1,M(o1)1,则M[t〉M,M(o)1.引理1.业务流程是匹配(定义8)的当且仅当它们之间每个交互都是可完成的,即对任意一个交互i1=〈t1,t1〉在合并后的流程中都有M1[t1〉M1[t1〉.证明.充分性.若业务流程间任意一个交互都是可以完成,则合并后的业务流程是弱良好的.假设合并后的业务流程不是弱良好的,则存在一个标识M使得[o]R(M),根据业务流程P,P是良好的则必然有(1)若存在可以完成的交互i1=〈t1,t1〉,其中M1[t1〉M1[t1〉满足M1∈R(M),因此有[o1]R(M1)或[o1]R(M1),由于交互i1是可以完成的,M1[t1〉M1[t1〉,R(M1)=R(M1)∪M1,又因为业务流程P和P是良好的,则有[o1]∈R(M1),[o1]∈R(M1),[o1]∈R(M1),[o1]∈R(M1).这与[o1]R(M1)或[o1]R(M1)矛盾.(2)若不存在可以完成的交互i1=〈t1,t1〉,其中M1[t1〉M1[t1〉满足M1∈R(M),则必然有[o1]R(M),[o1]R(M),这与业务流程P和P是良好的矛盾.充分性得证.必要性.若合并后的业务流程是弱良好的,则任意一个交互都是可完成.根据弱良好的定义对于任意一个标识M,[o]∈R(M).假设存在一个交互不能完成即在业务流程P中存在M1[t1〉,在P中存在M1[t1〉且M1R(M1).由于业务流程P和P良好,因此[o1]∈R(M1),[o1]∈R(M1),[o1]∈R(M1)R(M1).根据合并规则o1和o1共同完成时,才能到达标识[o],必有[o]R(M1).与任取标识M都有[o]∈R(M)即合并后的业务流程是弱良好的矛盾,故假设不成立,必要性得证.证毕.理1等价.下面证明无交互冲突的业务流程(定义7)与引定理1.若业务流程根据引理1是匹配的当且仅当流程间任意两两交互都是无冲突的.证明.充分性.若任意两个交互都是无冲突的,则业务流程是匹配的.若业务流程P和P是不匹配的,根据引理1存在一个不可完成的交互i1=〈t1,t1〉满足M1[t1〉M1,M1[t1〉且M1≠M1,M1R(M1),M1R(M1).设业务流程P和P之间存在另外一个交互i2=〈t2,t2〉是可以完成的,则有M2[t2〉M2[t2〉.由于i1与i2不冲突,根据定义6可以得到两种情况:(1)若M1∈R(M2),则M1∈R(M2).根据M1R(M1),则M1R(M2).根据M1[t1〉M1,M1∈R(M1).可得M1∈R(M2)=R(M2)∪M2,M1≠M2.M1∈R(M2)与M1R(M2)矛盾.(2)若M2∈R(M1),则M2∈R(M1).由于M1R(M1),则M2R(M1)=R(M1)-M1.交互i2是可以完成的即M2[t2〉M2[t2〉,则可以得到M2R(M1)=R(M1)-M1.M1≠M2,故M2R(M1)与假设矛盾.充分性得证.必要性.若两个业务流程是匹配的,则不存在冲突的交互对.假设业务流程P和P之间的两个交互i1=〈t1,t1〉,i2=〈t2,t2〉是冲突的,根据定义6可以得到M2∈R(M1)→M2R(M1)或者M1∈R(M2)→M1R(M2).若M2∈R(M1)→M2R(M1)由于业务流程是匹配,根据引理1则任何一个交互都是可完成的包括i1、i2.故M1[t1〉M1[t1〉,M2[t2〉M2[t2〉.又因M2∈R(M1)R(M1)=R(M1)∪M1,则M2∈R(M1).由于交互i2是可完成的R(M2)=R(M2)∪M2,则有M2∈R(M1).这与M2R(M1)矛盾.若M1∈R(M2)→M1R(M2),同理可以得到矛盾.必要性得证.综上所述,基于交互冲突的业务流程匹配性检测方法能够获得与经典的匹配性检测工作[1]等价的互操作匹配性.5实验本文采用SAP参考模型集合[23]对基于交互冲突的业务流程匹配性检测方法的有效性进行评价.5.1SAP参考模型集合SAP参考模型集合[23]是一个公开的数据集合,其中包含了604个有实际意义的EPC(EventdrivenPage9ProcessChain)业务流程模型.现有的许多研究工作[19]使用该数据集合进行业务流程的形式化分析.EPC业务流程模型包括3种类型的节点分别是Function、Event和Connector.Function表示业务活动,Event表示业务活动的前置或后置条件,Connector表示控制流的与、或和异或.由于SAP参考模型集合中并没有涉及业务流程间的互操作,因此本文通过合理的方法来模拟业务流程间的互操作.文献[16]为服务构建交互适配器时,将消息名称相同的输入、输出活动连接构造业务流程间的交互适配器.因此,本文也使用这种方法模拟互操作的业务流程.本文将不同业务流程包含相同名称的Function视为一次交互.图3显示了模拟出的业务流程对中包含的交互数量.图4显示了模拟出的业务流程互操作集合中交互数量与业务流程节点数量的对比.从图中可以看出,业务流程之间的交互数量远小于业务流程的节点数量.5.2行为约束关系的提取与以前的研究工作[21]类似,本文采用深度优先遍历EPC模型来模拟业务流程的执行过程,并根据生成的遍历序列获得业务活动间的行为约束关系.EPC流程模型中Function等价于业务活动的概念,若不同的Function在同一遍历序列中出现,则根据出现顺序确定为Pre或Post.若不同的Function没有在同一遍历序列中出现,则根据它们所在的遍历序列获得最近的公共前序Connector,确定行为约束关系为EX或PL.最终根据Connector的类型判断业务活动间的关系.其它图形表示的业务流程模型如BPMN,BPEL均可以通过上面的方法[21]获得业务活动间的行为约束关系.5.3实验结果为了评估本算法在实际应用中的有效性,并考虑到测试数据的规模和交互的复杂性(见图3)以及另外两种对比算法的运行时间,本文仅从SAP数据集合的模拟结果选择交互次数为3的115个业务流程对作为测试集合.该集合中每个业务流程平均包含7.9个Function节点、29.7个Event节点.本文实现了现有研究工作中基于Petri网模型[1]和有限状态机模型[10]的匹配性检测算法,从而对比这两种算法与本文提出的检测算法在运行时间和能否准确定位冲突两方面的差异.虽然业务流程是自由选择网[5,18]时,匹配性检测的算法时间复杂度低,但是实际的业务流程往往不能满足自由选择网的假设.因此基于Petri网模型的检测算法采用文献[1]中的方法实现.首先将参与交互的业务流程合并,然后使用约简规则改善算法的时间复杂度.基于有限状态机的方法通过构造完全交互树来检测匹配性.为了有效评估基于交互冲突的匹配性检测算法,图5中表示的交互冲突的匹配性检测算法的实际运行时间包括行为约束关系抽取以及算法1的运行时间.图5基于Petri网和行为约束关系的匹配性检测算法运行时间基于有限状态机模型的匹配性检测算法运行时间较长,针对该115个业务流程对的平均运行时间Page10超过了5min(见图6),由于基于Petri网的匹配性检测算法采用了约简规则,因此其实际运行时间远小于基于有限状态机模型的检测算法.图6显示了随着测试集合中参与交互的业务流程中节点数目(Function和Event数量总和)增加,基于有限状态机模型的检测算法的平均运行时间的快速增加.文献[24]中给出了采用Petri网模型的匹配检测算法针对一个包含28个节点的YAML流程进行良好性检测所需的时间,在最好情况下为4s,而在我们的实验中发现使用该算法检测相当规模的业务流程模型的互操作匹配性运行为2s,考虑到测试环境的不同,本文实现的对比算法和原文献[24]中算法相符.基于Petri网模型和行为约束关系模型的检测算法运行时间对比见图5.图5显示了随着测试集合中参与交互的业务流程中节点数目(Function和Event数量总和)增加,两种匹配检测算法的平均运行时间的变化.从图5中可以看出,基于Petri网模型的检测算法运行时间较长,并且随着业务流程中节点数的增加而快速增长.而基于行为约束关系模型的匹配检测算法实际运行时间较短,基本稳定.如图5所示,基于交互冲突的检测算法的运行时间并不会随业务流程中活动数量的增加而增加.这是因为基于行为约束关系的检测算法的时间复杂度与交互数量相关而不是与业务流程包含的节点数量相关.为了确保提供给用户完整且精确的业务流程互操作不匹配的原因,本文提出了关键冲突交互集合的概念.为了评估关键冲突交互集合的有效性,并同样考虑到测试数据的规模和交互的复杂性(见图3),本文采用交互数量在2~5之间互操作业务流程作为测试集合.测试结果中包含23个互操作不匹配的业务流程对,检测结果中CIMS和KMIS所包含的交互对数量对比情况见图7.在这23个业务流程对中,KMIS中交互的数量平均是CIMS交互数量的50%.从图7中可以看出关键冲突交互集合中包含的交互数量较少.相对于CIMS,KMIS能够更精确地指出造成互操作不匹配的原因.这也便于用户进一步修改业务流程模型或者寻找可替换的业务流程.图7不匹配业务流程的完整冲突交互对集合(CIMS)和6结论本文针对互联网环境下的服务间互操作匹配性的检测问题进行研究,利用局部交互之间是否冲突来判断整个业务流程间互操作的匹配性.这种方法具有时间复杂度低、检测结果包含完整且精确的互操作不匹配原因两个特点.同时,本文形式化证明了通过上述方法得到的业务流程的匹配性与经典的匹配性检测工作[1]等价.最后本文使用公开数据集合[23]评估了本文中提出的匹配性检测方法.实验结果表明,在算法检测速度方面,本文提出的方法具有显著的优势,满足互联网环境下服务间匹配性的快速检测需求,可以应用于云计算模式中大量的业务流程与组合服务匹配性检测场合;并且,当业务流程不匹配时,本文提出的方法能够完整且精确地确定造成互操作不匹配的原因.本文研究工作可从以下方面进一步扩展:(1)当业务流程间互操作不匹配时,研究如何进行交互不匹配的自动或半自动修正,并保证修正结果尽量满足用户需求.(2)由于业务流程和服务的大量出现,研究如何利用行为约束关系模型更加合理地度量服务之间的相似性同样十分必要,初步的研究工作参Page11见文献[25-26],这有助于解决服务模型检索和推荐等领域的问题.
