Page1一种基于加权软件行为图挖掘的软件错误定位方法苏小红王甜甜杨劭君马培军(哈尔滨工业大学计算机科学与技术学院哈尔滨150001)摘要已有错误定位方法通常仅给出可疑语句排序而缺少必要的上下文信息,导致难于理解软件失效的产生原因.为了解决该问题,定义了加权软件行为图来表示成功和失败的程序执行路径,由于图中边的权重表示了路径的执行频率,因此与LEAP方法相比,可以较好地分析与循环和递归等结构相关的软件错误.在此基础上,执行基于分支限界搜索的加权软件行为图挖掘算法,识别成功和失败执行之间最有差异的子图来获得错误签名,不但可以有效定位错误位置,还能输出缺陷语句相关的执行路径,从而提供失效产生的上下文.分析Siemens基准测试集和flex程序的结果表明,在检查相同百分比的语句的情况下,文中方法可以比Tarantula方法和LEAP方法定位到更多的错误.特别是对于冗余代码、缺失代码和变量替换,以及会直接改变执行路径类的错误,文中方法具有较高的定位精度.关键词错误定位;软件行为图;图挖掘;错误签名;分支限界搜索1引言随着计算机行业的不断发展,软件也日趋庞大和复杂,软件失效发生的概率也随之增高,这使得软件的质量越来越难以保证.在软件失效发生以后,调试软件(定位导致错误产生的代码语句并且修复错误)往往需要消耗大量的时间和人力.而自动化错误定位技术,可以显著减少其中的人力和时间消耗,从而提高软件的质量.目前已存在很多不同的软件错误定位方法,例如基于程序状态修改的方法[1-2]、基于程序行为特征对比的方法[3-6]以及基于程序依赖关系的方法[7-9]等.这些错误定位方法的结果大多数都是一个语句的可疑值序列,其中按照可疑值降序的顺序列出了不同语句的可疑值,以指导开发者对错误进行修改.但是,单独检查给出的可疑语句,通常并不足以令开发者判断该语句是否是正确的.开发者往往需要更多的上下文信息,才能够理解错误是如何产生的,并修正程序.因此,Hsu等人[10]提出了能够从成功和失败的程序执行路径中识别错误签名的RAPID方法.错误签名是一个程序实体序列,当按顺序执行其中的程序实体时,就很可能会导致错误产生.错误签名不但可以指示错误的所在,还能够提供错误产生的上下文.Cheng等人[11]根据程序执行路径构造软件行为图,提出了利用图挖掘算法来识别错误签名的LEAP方法.本文则进一步改进了软件行为图,考虑了语句的执行频率对错误定位效果的影响,提出了加权软件行为图,以及适用于挖掘加权图的新函数,得到了错误定位精度更高的错误签名.最后与Tarantula方法[3]和LEAP方法[11]进行了实验比较,讨论了不同错误类型对错误定位精度的影响.本文第2节介绍目前的相关工作和本文的研究动机;第3节介绍本文方法的总体思想;第4节介绍加权软件行为图的构造以及相应的图挖掘算法;第5节通过实验分析本文的方法;第6节讨论本文方法的局限性和可改进之处;最后总结全文.2相关工作及研究动机目前的软件错误定位方法大致可以分为:程序状态修改、程序行为特征对比、程序依赖关系分析[12]和错误签名方法等.程序状态修改方法,通常在程序执行时收集程序状态信息,并对程序状态进行修改,然后观察修改后的执行结果是否发生变化,据此找到与错误相关的关键语句.Cleve和Zeller[1]提出的DeltaDebugging方法,采用分治的思想找到成功的测试输入和失败的测试输入间的最小差别,再跟踪成功和失败执行之间的状态差异,找到错误语句.Zhang等人[2]通过在运行时强制修改谓词的取值结果,使得失败的执行变为成功的执行,并依此识别错误所在.这类方法的算法复杂度一般都较大,对小规模程序效果比较理想,但处理复杂程序时效率会大大降低.程序行为特征对比方法,一般认为成功执行和失败执行的程序行为特征是不同的,它们之间的差异可以用于指导错误定位.这些方法通常统计语句和谓词被每个测试用例覆盖的信息来衡量每条语句出错的可能.Jones和Harrold[3]提出的基于语句覆盖的方法Tarantula,认为错误语句应该在失败的执行中大量的出现,而在成功的执行中少量出现.之后研究人员提出了大量的覆盖分析方法,文献[4-5]对这些方法的等价性和精度进行了理论上的分析比较,文献[6]提出了利用机器学习方法结合多种覆盖分析错误定位方法,期望取得更准确的定位结果.然而此类方法往往只考虑了语句或谓词的覆盖信息,缺少对程序结构和执行信息的分析,会影响错误定位精度,而且难以给出与错误相关的上下文信息,开发者仍然需要做许多工作才能够修复错误.程序依赖关系分析方法,侧重于根据程序实体间的控制依赖关系或数据依赖关系,给出语句的可疑值,还能提供额外的上下文信息,供开发者理解错误的产生.Baah等人[7]分析了程序的控制依赖和数据依赖,产生程序依赖图.再通过执行测试,计算节点间的条件概率,建立了概率程序依赖图,可以有效的应用于错误定位和错误理解.苏小红、龚丹丹等人[8-9]定义了联合依赖概率模型,在定位过程中分析程序元素间的控制依赖、数据依赖以及语句执行状态.这类方法的结果仍可能包含大量信息,这些冗余信息会造成难以找到与错误相关的信息.Hsu等人[10]提出了识别错误签名的RAPID方法,通过增量的分析失败的程序执行路径的公共序列,将挖掘得到可疑语句序列作为错误签名,辅助开发人员定位和理解软件错误.Cheng等人[11]对错误签名方法进行了改进,本文将其称为LEAP方法,首先利用程序执行路径构Page3造软件行为图,再通过LEAP图挖掘算法,利用信息增益作为目标函数,从成功测试用例和失败测试用例的软件行为图集合中挖掘出Top-K个在失败的执行中出现很频繁,而在正确的执行中比较少见的最优局部软件行为图作为可疑语句序列.该方法能够给出失效产生的上下文且避免了冗余信息,因此有助于定位和理解软件错误.然而存在的一个不足之处是软件行为图中所有的控制流路径具有相同的重要程度,而没有考虑语句执行频率与软件失效之间的关联.例如错误的条件表达式或循环体内的某些缺陷语句,可能导致循环执行路径和次数的改变,进而导致软件失效.对于这种情况如果采用LEAP方法进行分析,那么执行了多次循环的测试用例和只执行1次循环的测试用例可能具有相同或相似的软件行为图,如果这两个软件行为图分别对应于成功和失败测试用例的软件行为图,则图挖掘算法将因无法在这两个软件行为图中区分成功执行和失败执行的差异而失效,从而不能有效定位到软件错误.类似地,错误的递归也可能导致函数执行路径的改变.由于循环和递归是编程语言的基本元素,需要提供一种机制来表示程序执行路径的转移概率,使之可以有效区分成功和失败执行路径.本文第4节中用实图1基于加权软件行为图挖掘的错误定位方法的基本流程软件测试和调试过程通常协作来检测和定位软件缺陷,如果在测试过程中获得了测试用例的路径信息,则可直接执行构造加权软件行为图和挖掘错误签名.同大多数错误定位方法一样,本文假设测试用例集提供了充分的用以错误定位的测试覆盖信息,能够保证测试覆盖率,错误定位方法的研究重点例进行了详细分析.综上所述,目前大多数方法在错误理解方面做的还不够完善,要么只提供可疑语句的列表,缺少可以用于理解错误产生原因的有效上下文信息,要么提供了过多的信息,开发者难以从中找到与错误相关的信息,都不利于开发者理解错误是如何产生的.错误签名能够较好的平衡过多和过少的信息,但仍需要考虑程序执行路径的统计学意义,而不仅仅是频繁图的挖掘.本文的研究动机就是如何结合统计信息和图挖掘方法进一步提高错误签名的错误定位精度.3方法概述3.1方法框架输入是待测程序P,以及相应的测试用例集合.根据程序P执行测试用例的实际输出结果,可以将测试用例分为两类:成功的测试用例(P的实际输出结果与预期输出结果相同)和失败的测试用例(P的实际输出结果与预期输出结果不同).本文方法主要包含3个步骤:获取程序执行路径、构造加权软件行为图和挖掘错误签名,其流程如图1所示.主要放在如何在这一前提条件下快速准确地定位错误所在的语句.3.2本文方法与LEAP方法的差异LEAP方法将测试用例的执行路径表示为软件行为图,不区分路径的执行频率,因此对应的图挖掘算法仅是挖掘成功和失败测试用例集合执行路径中Page4的频繁子图.方法是采用信息增益作为目标函数,用LEAP算法挖掘出区分失败执行和正确执行差异的频繁子图.而本文定义的加权软件行为图不但表示了程序软件执行路径,还用边的权重表示了程序路径的执行频率,表示了程序执行的统计信息,在本质上区别于软件行为图.此外,本文方法在基于图挖掘定位软件缺陷时,需要考虑路径的权重,即路径执行的统计信息,因此,采用了不同于LEAP的目标函数和图挖掘算法.具体方法如图1所示,用Fisher得分作为目标函数,用分支界限搜索方法挖掘错误签名,并且提出了一系列用来提高挖掘效率和准确率的剪枝和去冗余等算法.4关键技术4.1获取程序执行路径为了得到程序的执行路径,需要对待测程序的源代码进行插桩.插桩是在保证待测程序原有逻辑和功能不变的条件下,向程序源代码中插入探针语句,用来在程序被执行时输出程序执行信息.本文实现语句级别的程序插桩,即跟踪程序中语句的执行信息,每当执行到一条语句,就将被执行语句的行号作为执行路径输出.首先,需要对待测程序进行词法分析和语法分析,将源代码转换为等价的抽象语法树,然后对抽象语法树进行分析,找到适合插入探针语句的位置,以保证额外的语句不会影响到现有的程序逻辑和功能.例如对于C语言中的条件语句和循环语句,由于它们需要在每次执行条件判断时输出行号信息,因此利用逗号表达式直接将探针语句插入到条件表达式中;对于跳转语句,由于它们会立即改变程序的表1findmaxIndex程序的测试用例以及其执行路径序号1234.2构造加权软件行为图表1中的测试用例2执行了两次循环结构,因此路径中包含了两组语句序列3,4,6,7,9,导致其执行路径长于测试用例1的执行路径.实际程序中,循环可能会执行若干次,且如果循环结构中包含较多的执行语句,则会导致过长的执行路径.特别是当程序中包含大量循环结构的时候,分析起来会非常执行路径,因此必须在其之前插入探针语句.接下来将插入探针的抽象语法树反向生成相应的程序代码,即可得到插桩后的程序.最后,当执行插桩完毕的待测程序时,插入的探针语句也会被执行,从而输出程序的执行路径.如果探针语句将当前正在执行语句的行号输出,那么得到的程序执行路径中,每个节点就表示待测程序中的一条语句.以图2所示的findmaxIndex程序为例,它是在数字数组中找到最大值首次出现的位置.main函数中调用了findmaxIndex函数.为了避免冗余说明,本文将main函数中的n和nums的读取用了伪代码描述.3组不同的测试用例及其相应的程序执行路径如表1所示.当执行到main函数中的函数调用语句findmaxIndex(n,nums);时,程序的执行路径发生转移,执行findmaxIndex函数中的语句,执行完findmaxIndex后,返回到main函数中第19行.1.voidfindmaxIndex(intn,intnums){2.inti=0,maxIdx=-1;3.while(i<n){4.if(maxIdx==-1){5.maxIdx=i;6.}elseif(nums[i]>=nums[maxIdx]){7.maxIdx=i;8.}9.i++;10.}11.printf("%d",maxIdx);12.}13.voidmain()14.{15.intn,nums;16.read(n);17.read(nums);18.findmaxIndex(n,nums);19.}困难,需要消耗大量的空间和时间.而且,由于其中包含的信息过多,很难从中提取关键信息,因此很有必要对程序执行路径进行进一步处理.为了解决这一问题,Cheng等人[11]提出了软件行为图.软件行为图是一幅有向图,图中的顶点对应于程序执行路径中包含的语句,顶点间的边对应于程序语句执行时的顺序关系.软件行为图有效地压Page5缩了程序执行路径,在保留了程序执行路径的特征信息的同时,去除了很多冗余信息,可以有效减少数据量,节省时间和空间,而且更有利于进一步的处理.例如表1语句3,4,6,7,9,在测试用例2中被循环执行了2遍,但是行为图中通过将其表示为控制流图的循环结构形式,使这些节点只出现一次,有效压缩了该路径的表示,如图3(b)所示.同理如果其他测试用例执行多次该循环结构,节点3,4,6,7,9,仍只需表示一次.图3findmaxIndex程序各个执行路径的软件行为图软件行为图可以认为是与特定执行相关的控制流图.如果执行路径覆盖到了所有的语句和所有可能的语句执行顺序,那么软件行为图就与控制流图是相同的;如果执行路径仅覆盖到了部分语句,或者未能包含全部可能的语句执行顺序,那么就只包含控制流图的一部分.当存在函数调用时控制流图可通过增加函数调用边和返回边来表示为过程间控制流图,同样软件行为图也可以类似地表示函数调用关系[11].但是,软件行为图中只包含了语句是否被执行以及语句执行顺序的信息,而没有考虑到语句执行频率对错误定位结果的影响,不能很好的处理循环和递归等结构.例如,对于表1,成功测试用例1和失败测试用例3的执行路径是不同的,但是却具有相同软件行为图表示,如图3(a)所示.如果比较测试用例1和3的软件行为图则因无法区分成功执行与失败执行之间的差异而无法有效定位缺陷语句.基于以上分析,本文提出了加权软件行为图.定义1(加权软件行为图).加权软件行为图是一个四元组(V,E,L,W),其中V是顶点集合,包含程序执行路径中出现的所有程序实体,EV×V是有向边的集合,L是边与其标签的映射,W是边与其权重的映射.边〈vi,vj〉∈E的标签,可能是“调用”、“转移”或“返回”之一:如果vi调用了vj,〈vi,vj〉就被标记为“调用”.如果从vi返回到了vj,则将〈vi,vj〉标记为“返回”.否则将〈vi,vj〉标记为“转移”,表示vj紧跟在vi之后执行.这3种标签表示了程序实体间的3种可能的控制流关系.每条边还附加有一个权重w.由于在待测程序的不同执行中,同一条语句的执行次数可能会有很大区别,因此直接将语句执行次数作为权重并不合适,而是采用语句的执行概率作为权重.若图中某条边ei的起始顶点和结束顶点分别为pk和pj,pk的出边(以pk为起始顶点的边)集合E={e1,e2,…,en},其中每条边在执行路径中出现的次数分别为ci,则边ei的权重计算公式为权重wi表示了在此次执行中,顶点pk被执行后,顶点pj会被执行的概率.对于同一个顶点的出边,它们的权重和为1,即有含有条件判定的语句可能有多条执行路径分支,边的权重代表了各个路径的执行频率.如图4(a)所示,对于测试用例1的路径1,其语句3有两个分支3→4和3→11,它们在循环中的执行次数分别为3和1,因此边3→4的权重为3/(3+1)=0.75,边3→11的权重为0.25.不同执行频率的路径意味着不同的执行上下文,也可能导致不同的执行结果(成功/失败).图4(a)成功测试用例1和图4(c)失败测试用例3的加权行为图中的边3→4,3→11,4→6,4→5,6→9,6→7的权重不同,有效区分了成功测试用例和失败测试用例的软件行为图,尤其是对与缺陷语句相关的执行路径做出了很好的区分.有了程序执行路径,只要不断的将执行路径中出现的边添加到有向图中,就可以得到软件行为图.按照式(1)计算边的权重,就得到了加权软件行为图.其算法如算法1所示,使用V(G)表示加权软件行为图G的顶点集,使用E(G)表示加权软件行为Page6图4findmaxIndex程序各个执行路径的加权软件行为图图G的边集.算法1.构造加权软件行为图.输入:待测程序的执行路径输出:相应的加权软件行为图G1.G=;2.last=NULL;3.FOR执行路径中的每条语句s4.IFlast不为NULL5.V(G)=V(G)∪{s};6.E(G)=E(G)∪{〈last,s〉};7.Count〈last,s〉=Count〈last,s〉+1;8.Sumlast=Sumlast++;9.ENDIF10.last=s;11.ENDFOR12.FORG中的每个顶点v13.FOR以v为起始顶点的每条边〈v,k〉14.〈v,k〉的权重为Count〈last,s〉/Sumlast15.ENDFOR16.ENDFOR17.RETURNG;4.3识别错误签名使用不同的测试用例多次执行待测程序,可以得到一个加权软件行为图的集合G.根据执行的测试用例是成功的还是失败的,可以将G划分为两个子集,一个包含与成功的测试用例对应的加权软件行为图,记为Gpass;另一个包含与失败的测试用例对应的加权软件行为图,记为Gfail,G=Gpass∪Gfail.在理想情况下,有在理想情况下,Gfail即为需要分析的可能包含缺陷语句的子图,然而,现实情况下,失败测试用例和成功用例常常执行一些公共的程序语句(既可能包含正确也可能包含缺陷语句).因此,Gpass与Gfail的交集不一定为空.例如图4例子中Gpass={子图(a)},Gfail={子图(b),子图(c)},Gpass∩Gfail≠包含了图4中所有语句节点.加权软件行为图的挖掘目标,是在G中找到一个最优的子图g,使得g可以指出错误所在,并提供与错误相关的上下文信息.而这个最优的子图g,就被称为错误签名.例如图4例子中的最优子图即错误签名为6→7.通常认为,错误语句应该被失败测试用例大量的执行,而被成功测试用例少量的执行,即错误语句在Gfail和Gpass中的出现频率应当有显著的区别.那么,可以设计一个目标函数F(g),来评价子图g对成功的执行和失败的执行间差异的辨别能力.该问题就转化为在G中,寻找一个最优子图g,使得F(g)最大的优化问题.本文采用Fisher得分作为目标函数F(g)的判据,Fisher得分以最大化类间离散度和最小化类内离散度为目标准则[13].在Gfail中出现频率普遍较高,而在Gpass中出现频率普遍较低的子图,会具有更高的Fisher得分,它也可以更好的指出成功和失败的执行间的差异.令G1,G2,…,Gm表示m次不同的执行对应的加权软件行为图,对于特定的子图g,其边集E={e1,e2,…,en},使用fj率,其定义为Page7其中,wj和结束顶点的边的权重.使用μ频率的均值:使用(σpass出现频率的方差:运用Fisher准则,得到边ei的Fisher得分为最后,将g中所有边的Fisher得分求平均数,得到目标函数F(g)的计算公式为4.3.1剪枝策略由于G中可能包含指数级别的子图,因此直接进行搜索会消耗大量的时间,需要对搜索过程运用剪枝策略.对于某一子图g,它在Gpass和Gfail中出现的频率一定不小于其超图的出现次数.即g的超图在Gpass中出现的次数大于等于零,且小于等于g在Gpass中出现的次数;在Gfail中出现的次数大于等于零,且小于等于g在Gfail中出现的次数.因此,g的超图的得分具有一个上限值,可以通过判断该上限来进行剪枝.边ei的Fisher得分上限为g的超图的目标函数值上限为4.3.2子图的选择和去冗余在加权软件行为图中,并不是所有子图都可能是错误签名.首先,错误签名应当是有一定实际意义的子图,能够表示错误的上下文,即如果按照子图给出的顺序执行程序,就很可能导致错误产生.包含复杂分支的子图,如图5所示,反而会让开发者难以理解其表示的意义,不利于理解错误产生的原因.因此,可以作为错误签名的子图,应当具有执行顺序,需要在选择子图时予以保证.其次,方法的调用与方法的返回是一一对应的,即如果方法a调用了方法b,那么一定会从方法b中返回到a.如果方法c也调用了方法b,那么也一定会从b中返回到c.将该执行过程转换为软件行为图,结果如图6所示.这里有效的子图只有a→b→a和c→b→c,而子图a→b→c和c→b→a都是无效的子图,不可能在实际运行中出现.在选择子图的时候必须将无效的子图去除,否则可能会影响错误定位的结果.过滤子图的算法如算法2所示,使用堆栈来检查调用边是否与返回边一一对应.例如对于有效的方法调用返回序列a→b→c→b→a而言,首先调用边a→b入栈,调用边b→c入栈,接下来分析返回边c→b,此时栈顶是b→c与c→b对应,为有效路径,栈顶b→c出栈,a→b变为栈顶,此时分析b→a与栈顶对应,a→b出栈,判定路径有效.如果当前分析的返回边e与栈顶对应,则栈顶出栈,否则说明所分析的路径为无效路径,于是在清空堆栈后返回.算法2.过滤无效子图.输入:需要检测是否有效的子图g输出:子图是有效的还是无效的1.stack=;2.FORg中的每条边e3.IFe为调用边4.stack.push(e);5.ELSEIFe为返回边6.IFstack.top与e不对应7.stack=;8.RETURN无效;9.ELSEPage810.stack.pop();11.ENDIF12.ENDIF13.ENDFOR14.RETURN有效;最后,在挖掘得到的多个错误签名之间,可能具有包含关系,因此定义下列规则,来合并相互包含的错误签名,减少冗余.对于两个存在包含关系的错误签名M和N(无论MN还是MN):若F(M)F(N),则删去N.这样,存在包含关系的错误签名中,只会保留得分更高的错误签名,可以有效地减少冗余信息.4.4基于分支限界搜索的加权软件行为图挖掘本文采用如算法3所示的分支限界搜索算法来挖掘错误签名.在错误定位中,仅仅报告唯一的最佳错误签名,往往并不足以提供足够的信息.按照可疑度降序给出多个不同的错误签名,更有助于开发者理解错误,因此算法3会返回Top-K个错误签名.算法3.挖掘Top-K错误签名.输入:加权软件行为图集合G,结果数K输出:Top-K错误签名g1.S={G中只包含一条边的子图};2.g=;3.WHILES≠4.从S中选择g,S=S\{g};5.IFg未检查过且有效6.用式(8)和(10)计算F(g)和Fmax(g);7.IFF(g)>min8.g=g∪{g};9.移除g中的冗余结果.10.IFg包含的错误签名数量大于K11.移除g中得分最小的错误签名12.ENDIF13.ENDIF14.IFFmax(g)>min15.扩展g的最后一个节点并将其加入S;16.ENDIF17.ENDIF18.ENDWHILE19.RETURNg;为了选择具有执行顺序的子图,算法3每次只会扩展子图的最后一个节点,而不是在任意位置进行扩展.该策略在提高了执行效率的同时,也保证了子图能够具有执行顺序.最后得到的Top-K错误签名,就可以作为错误定位的依据,错误签名中包含的节点对应于可能导致错误发生的语句,可以用于进行错误理解.4.5错误签名实例以SiemensSuite[14]中的replace程序版本9为例展示本文方法挖掘得到的错误签名.该程序的dodash函数中,存在如图7(a)所示的缺失代码错误:第3行代码中包含一个缺失代码错误,if语句的条件中缺失了一个条件,导致在某些情况下,本应执行第10行else语句块内的代码,但实际执行的却是第5行的for循环,从而产生错误.图7replace程序版本9的代码片段及其得到的错误签名本文定位方法得到的错误签名如图7(b)所示,错误签名中的每个数字都与图7(a)所示代码片段的语句行号对应.该错误签名表示错误语句就在第2、5、9和12这4行代码之中,而且如果按照语句2、5、9、12的顺序执行代码,就很可能会导致错误.开发者就可以根据错误签名给出的执行顺序,去理解为什么会产生错误,找到并修正真正引起错误的语句.注意到产生错误的原因,是因为没有满足条件src[i-1]<=src[i+1],因该条件缺失导致改变了程序的执行路径,即本应执行语句10却执行了语句5.而此时,必有src[i-1]>src[i+1](因缺失的条件src[i-1]<=src[i+1]未被满足),所以有k=src[i-1]+1>src[i+1],这样for循环的条件k<=src[i+1]一定为假,因此会跳过循环体直接执行语句9,最后执行语句12.因此,实际产生错误的执行路径是2→5→9→12,与图7(b)所示的错误签名是相同的.这个例子说明,错误签名与实际产生错误的执行路径是相同的,因此错误签名相当于指出了错误的执行路径,有了这样的错误上下文信息,我们就可Page9以通过分析为什么会执行这个错误的路径,原因一定是分支的判断条件限制不够严格,从而发现真正产生错误的语句是语句2.显然这比单纯地给出最可疑的语句是语句2更有助于开发者理解错误产生的原因,也更有利于开发者修正错误.5实验采用C#语言实现了C语言词法语法分析工具CParser、程序插桩工具和本文方法、LEAP、Tarantula方法.5.1实验建立本文方法采用被广泛应用于评价软件错误定位方法有效性的SiemensSuite[13]和UNIX程序集flex(下载于http://sir.unl.edu)作为测试数据.Siemens测试集全部采用C语言编写,程序规模较小,并且由人工注入错误,每个程序都包含了数千个测试用例.flex是UNIX系统下的一个真实的C语言程序,其规模较大,而且其中包含的错误都是生产过程中真实产生的,但测试用例数量较少.表2描述了Siemens测试集和flex的程序信息,包括程序名称、错误版本数、代码行数、测试用例数及其描述.程序print_tokensprint_tokens210replacescheduleschedule2tcastot_infoflex表中列出了132个Siemens错误版本,但由于其中一些版本没有错误测试用例,或者错误位于头文件中,或者运行时产生了段错误,因此只采用了其中的121个错误版本.再加上flex程序的23个错误版本,本文实验最终使用144个错误版本进行实验.实验的运行环境是CPUInter?Pentium?Dua4-Core3.2GHz;内存2GB.5.2评价指标实验选择与Tarantula[3]方法和LEAP[11]方法进行比较.Tarantula是一种实现比较简单的基于覆盖的错误定位方法,它的错误定位效果较好,常被用来作为错误定位方法的比较对象.LEAP则是一种基于图挖掘的错误定位方法.由于Tarantula方法会产生语句的可疑值列表,因此采用文献[3]使用的错误定位方法精度评价指标Score.如果开发者从可疑值最高的语句开始,按照可疑值降序的顺序检查,直到找到了错误所在的语句为止,那么Score就表示了在找到错误之前需要检查的代码百分比.它的计算方法如式(11)所示.其中,N表示在找到错误之前需要检查的语句行数,Lines表示可执行语句的行数.由于本文方法和LEAP方法产生的是Top-K错误签名,因此按照前K个可疑值降序的顺序检查每个错误签名,将找到错误语句前需要检查的语句百分比作为Score.代码检查率的计算类似于Score,是按照定位结果可疑度排序从高到低检查的代码行数占程序中可执行语句行数的百分比.两者的区别是:在计算代码检查率时可能定位到也可能没有定位到缺陷语句,而Score是在定位到缺陷语句的情况下计算的.5.3实验结果总体分析图8展示了Siemens测试集上,本文方法与Tarantula方法和LEAP方法的总体错误定位精度折线图,横轴表示需要检查的语句百分比,纵轴表示检查相应百分比的语句时,能够找到错误的错误版本百分比.横轴是从1%开始的,表示只检查1%的语句,可以找到错误的错误版本百分比.可以看到,在检查相同百分比的语句时,本文方法总是可以比Tarantula方法和LEAP方法定位到更多的错误,而且至多只需要检查65%的代码,本文方法就可以定位到所有的错误.图9是Siemens测试集中单个程序的错误定位结果.可以很明显的看到,对于不同的程序,错误定位的精度有较大的差异.Page10图9单个程序的错误定位精度比较对于print_tokens、print_tokens2和replace程序,所有错误定位方法的效果都较好,而本文方法效果最好;对于schedule程序,错误定位效果也比较好,但是LEAP方法表现较差;对于schedule2和tot_info程序,仍然是本文方法的错误定位精度最高,但明显无法与前4个程序的错误定位精度相比;Page11而对于tcas程序,则是Tarantula方法的错误定位的精度要更高些,本文方法的错误定位精度略高于LEAP方法.图10则是flex程序的错误定位精度比较,可以看到3种方法的错误定位精度都较高,而且仍然是本文方法效果最好,其次是LEAP方法,最后是Tarantula方法.为了找到不同程序上的错误定位精度差异较大的原因,我们在下面的实验中进一步按照不同的错误类型分别对错误定位结果进行分析.5.4针对不同错误的结果分析实验使用的144个错误版本,按照错误类型进行分类,总计包含14个冗余代码错误(添加了多余的代码),32个缺失代码错误(删除了部分代码),34个运算符变异错误(运算符发生了改变),46个常量变异错误(常量值发生了变化),11个变量替换(使用的变量发生了改变)和7个其他错误.采用箱式图显示每种错误类型的错误定位结果.箱式图描述了数据的统计结果,它由数据样本的五个重要数据统计点组成:最大值,最小值,四分之一位数,四分之三位数和中位数.这里以Tarantula方法作为比较的基准,将Tarantula方法与本文方法的Score之差作为纵轴,记为ScoreChange,如式(12)所示.ScoreChange=ScoreTarantula-Score本文方法(12)若ScoreChange大于零,表示本文方法检查更少的代码就能定位到错误,定位精度优于Tarantula方法;若ScoreChange小于零,则表示本文方法需要检查更多的语句才能定位到错误,定位精度比Tarantula方法要差.从图11可以看到,对于冗余代码、缺失代码和变量替换错误,本文方法大多都只需要检查更少的语句,就能够定位到错误,而少部分精度变差的,也小于9%.而对于运算符变异、常量变异和其他错误,本文方法则有优有劣,约有47%的错误定位精度变差了,但变差幅度大于10%的只占9%.再考虑另一种错误分类方式.部分错误可能会直接导致程序的执行路径发生改变,例如if语句中的条件发生了错误,会直接令程序执行路径发生变化.而另一些错误则不会直接导致程序执行路径发生改变,例如变量赋值中发生了错误,程序执行路径并未立刻发生变化,只有之后再用到该变量时,程序执行路径才可能发生变化.按照这一方式来分类,实验使用的144个错误版本,包含59个会直接导致程序执行路径发生改变的错误,85个不会直接导致程序执行路径改变的错误,同样使用箱式图显示两类错误的定位结果,如图12所示.可以发现,对于会直接改变程序执行路径的错误,本文方法基本都是优于Tarantula方法的,而对于不会直接导致程序执行路径发生变化的错误,本文方法同样是有优有劣,约有47%的错误定位精度变差了,而变差幅度大于10%的约占7%.图12是否直接改变执行路径的错误的ScoreChange分布综合分析以上两个实验,可以发现本文方法对不同的错误类型,定位精度有比较明显的不同:对于冗余代码、缺失代码和变量替换错误,以及会直接改变执行路径的错误的定位精度明显更高.如果将这Page12些错误类型记为优势错误,将剩余的错误类型(不会直接改变执行路径的运算符变异、常量变异和其他错误)记为劣势错误,那么优势错误有92个,劣势错误有52个,优势错误和劣势错误的ScoreChange对比结果如图13所示.可以看到,对于优势错误,本文方法的定位精度大多都优于Tarantula方法,而对于劣势错误,本文的定位精度则普遍要略差于Tarantula方法.图14所示的优势错误和劣势错误的错误定位精度比较也证明了这一点,而且LEAP图13优势错误和劣势错误的ScoreChange分布图14优势错误和劣势错误的错误定位精度比较方法也具有相同趋势,并且无论是对优势错误还是劣势错误,本文方法都比LEAP方法的错误定位精度高.5.5性能分析表3给出了3种方法定位分析每个错误版本的平均时间.Tarantula是基于语句覆盖的分析因此具有较高的时间效率,本文方法和LEAP方法均涉及到图的分析,两者时间开销相近.程序print_tokensprint_tokens2replacescheduleschedule2tcastot_infoflex6讨论6.1本文方法的不足根据本文方法与Tarantula方法对比实验的结果,可以得到以下结论:本文的错误定位方法对冗余代码、缺失代码和变量替换错误,以及会直接改变执行路径的错误的定位精度明显提高,而对不会直接改变执行路径的运算符变异、常量变异错误的定位精度的提高则不明显.分析产生这种情况的原因,是由于本文方法会在成功的执行和失败的执行之间找到加权软件行为图差异最大的子图,即当程序的执行路径出现明显差异时,本文方法比较有效.反之,因本文方法的特点不能被有效利用,而使得其错误定位的优势不明显.文献[15]的研究表明,一条语句的错误可能会影响到程序状态,而随着程序的继续执行,被影响的程序状态可能会被进一步传播.也就是说,程序的执行路径发生变化的位置,并不一定是真正导致错误的语句,而可能是其他语句的错误,通过程序状态不断传播,直到导致程序的执行路径发生改变.也就是说,本文方法对于在错误语句附近就能够观察到程序执行路径发生改变的错误,一般都能具有比较好的定位精度.而对于会将错误传播出去很远才发生执行路径变化的错误,往往只能定位到执行路径发生变化的位置,虽然该位置与实际的错Page13误语句也具有一定的相关性,但因其并不是真正产生错误的语句,从而导致错误定位的精度下降.6.2可改进之处针对5.1节中本文方法的适应性问题,可以尝试捕获更多的程序状态,如谓词的真假等信息,而不仅仅是程序的执行路径.在进行图挖掘时,可以综合考虑更多的信息或融合其他的错误定位算法,来提高对劣势错误的定位精度.对于错误传播对错误定位精度的影响,单独的应用图挖掘算法可能难以解决这一问题,因此可以尝试分析程序的控制依赖或数据依赖,并依此对错误的传播进行分析,进而可能减少错误传播带来的影响.7讨论本文提出了一种新的基于加权软件行为图挖掘的错误定位方法.与Tarantula方法和LEAP方法相比,本文方法具有更高的错误定位精度,而且更适合于定位冗余代码、缺失代码和变量替换错误,以及会直接改变执行路径的错误.本文的主要贡献是:(1)提出了加权软件行为图的概念和构造方法,并将其用于错误定位.与软件行为图相比,加权软件行为图使用语句执行概率作为边的权重,有效地利用了路径执行的统计信息,因此可以更好地分析与循环和递归等结构相关的软件错误.(2)提出一种基于分支限界搜索的加权软件行为图挖掘算法,识别成功和失败执行之间最有差异的子图来获得错误签名,不但可以有效定位错误位置,还能输出缺陷语句相关的执行路径,从而提供失效产生的上下文,有助于错误理解.(3)从理论和实验两个方面分析了基于加权软件行为图挖掘的错误定位方法的适应性,通过对错误进行分类,讨论了本文方法对不同错误类型的错误定位精度的影响.
