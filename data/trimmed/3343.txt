Page1SOC应用系统中基于信用的QoS保证机制殷宪振蒋静潘振宽夏佰强(青岛大学信息工程学院山东青岛266071)摘要针对目前面向服务计算(SOC)系统中QoS保证机制没有充分考虑系统服务组件的动态性问题,提出了SOC系统中的信用模型与信用函数,采用信用值量化系统服务组件的动态性,同时提出了信用值驱动的服务调度、服务预留和服务备份的QoS保证机制.最后对QoS保证机制中的主要算法进行了仿真验证,结果显示该QoS保证机制可以有效地降低网络服务组件的动态性对QoS的影响,提升了系统的服务质量.关键词面向服务计算;信用模型;服务调度;服务预留;服务备份1引言面向服务计算(ServiceOrientedComputing,SOC)是将动态的、多自治域的虚拟组织中的信息、计算能力等各种资源封装成为具有统一的外观和标准调用方法的服务,提供给系统或用户使用,并通过对独立开发、部署、发布的各种基本服务的查询、调度等过程,将所需的服务组合成为某一任务量身定制的特定应用[1-2],从而整合各种动态的、分布的、多自治域的、虚拟组织内的资源,以达到协同进行问题求解的目的.关于面向服务计算(SOC)的研究涉及到很多方面,其中一个重要的问题就是服务质量保证(QualityofService,QoS).所谓的QoS保证机制就是在服务计算模式下,协调属于不同组织与机构的各种服务,协同进行问题求解过程中保证服务的质量.这是构建一个健壮、高效的SOC应用系统所必需解决的关Page2键问题.如果SOC应用系统的服务质量得不到保证,那么资源共享的意义将会大打折扣.与传统的Web服务技术相比,在面向服务计算的应用系统中,用户对QoS的要求主要包括高效性和高可用性两个方面.其中高效性主要包括任务截止时间、任务结果的精度等服务性能上的要求,即保证服务能够按时而且高质量地完成,属于对系统性能鲁棒性的要求[3].另一方面,高可用性要求服务在整个服务期限内保持较高的可用性,不会因为SOC系统动态性引起服务组件的失效而影响服务的连续性,即要求系统具有一定的稳定鲁棒性.目前大多数的QoS保证机制都把主要精力放在了保证服务的高效性上,而对系统服务动态性引起的服务可用性的问题没有太多的关注.实际上,在服务生命期内任何一个服务组件的失效都会使整个服务不再可用.同时由于构成服务的各个服务组件可能来源于不同的机构或虚拟组织,导致由此引发的服务失效几率会远远大于传统基于Web环境的应用系统.所以在设计QoS保证机制过程中要充分地考虑系统的动态性,以保证服务的稳定鲁棒性.因此,本文提出了一个基于信用的服务调度、服务预留和服务备份的QoS保证机制模型.在该模型中,引入与量化信誉度的信用值概念,建立信用值在服务调度过程中的驱动机制,将QoS保证机制对服务性能方面的要求在服务调度阶段实现,采用信用函数将系统服务的动态性量化为信用记录中的信用值,并作为服务调度过程中的主要参数用来实现风险规避.同时,提出一种通过服务预留和服务备份策略实现对用户透明的服务组件的动态重构,将系统动态性对服务可用性的影响降至最低.本文第2节介绍有关QoS方面的研究现状,详细分析现有的QoS保证机制存在的缺陷及其对SOC应用系统服务管理的影响;第3节系统定义SOC应用系统中的信用模型以及信用函数如何将系统动态性对服务可用性的影响进行量化,并在信用记录中体现;第4节详细阐述QoS保证机制在信用记录的驱动下进行服务调度而且实现风险规避以及通过服务预留和服务备份算法实现服务组件动态重构的详细流程;第5节设计本文QoS保证机制的仿真实验,并分析实验结果;最后,对本文的算法和模型进行总结.2相关工作QoS对于SOC应用系统的重要性,使该问题成为当前十分热门的一个研究领域.主流观点认为,SOC应用系统的QoS需求主要包括性能QoS和安全QoS.性能QoS主要涉及服务是否可用以及性能能否满足任务的需求,如服务组件的连通性、网络传输状况、服务提供者的硬件配置和软件部署等内容.安全QoS则重点关注服务调用过程中的安全问题,如避免服务提供者的服务欺骗和服务请求者对资源的恶意使用等问题.关于QoS保证机制,目前存在两种比较著名的体系结构.一种是Foster等人[4-6]提出的Globus预留和分配体系结构GARA(GlobusArchitectureforReservationandAllocation).该体系结构采用层次化的观念利用各级API、Globus网格安全体系框架(GSI)和网格资源管理器(GRM),通过统一的接口完成对服务的预留、控制和监视,从而保证端到端的QoS.另一种是英国的Cardiff大学Al-Ali等人[7]提出的网格QoS管理体系结构G-QoSM(GridQoSManagementArchitecture).它提供了3个主要的功能来实现OGSA环境下的服务预留和自适应调节的QoS管理:基于QoS属性的服务发现;SLA(ServiceLevelAgreement)协议;已分配服务的自适应调节.对于这两种QoS保证机制的体系结构,GARA使用Globus安全框架增强了系统安全性,而G-QoSM则更侧重于如何在服务管理和调度过程中实现QoS保证机制.除了上述有关体系结构的研究外,其它大部分工作都集中在如何量化任务对QoS的需求以及保证QoS的服务调度算法方面,Maheswaran等人[8]提出了QoS驱动的资源管理策略,利用效益函数量化服务质量等级,采用作业级动态调度算法来保证性能QoS中最终服务期限和优先级.为了更好地适应服务计算环境下的动态性和自治性,丁箐等人[9-10]在文献中通过定义效益函数,将一组相互独立作业重复映射到不同的服务上以保证最终服务期限等性能QoS需求.文献[11]通过以传统的Min-Min作业调度启发式算法为基础,对其进行了改进并使其具有自适应的、性能QoS驱动的特性.文献[12-13]深入研究了基于性能QoS的服务管理与调度算法,探讨了多服务质量约束的复合服务调度机制在工作流(workflow)中的应用.Azzedin与Maheswaran等人[14]针对服务计算系统对安全QoS的需求,将“信任”引入了服务管理系统.Humphrey等人[15]则对具有信任意识的服务计算模型进行了深入研究.张伟哲、方滨兴等人[16]兼顾服务提供者和服务请求者Page3的行为对系统安全QoS的影响提出了一种基于信任QoS增强的网格服务调度算法.综合上述理解我们认为,目前QoS保证机制以及基于QoS的服务调度算法的研究,对于安全QoS和性能QoS问题中的服务性能、最终服务期限、网络传输状况等问题给予了大量的关注,但是却忽略了服务稳定性对服务质量的影响.在SOC系统中服务或服务组件随时可能会由于某些有计划的或是意外的原因导致下线和失效,而且这种行为对服务质量的影响往往是灾难性的.例如:系统中一个正在为某个任务提供服务的服务组件由于自身故障等原因突然掉线,并且导致任务没能来得及保存现场时,系统就必须要消耗一定资源对任务进行再次调度,而且更重要的是在此过程中造成的时间损失必将影响任务能否按时交付.3相关概念及问题描述基于上述分析,我们提出了一个根据当前和过去最近一段时间的信用记录及其变化趋势来量化系统服务动态性的信用模型,采用信用值驱动的服务调度、服务预留和服务备份的方法降低其对系统QoS影响的算法模型.下面给出相关的定义和假设以及问题的描述.3.1基本定义一般由以下几个方面引发:定义1.服务组件动态性.服务组件的动态性(1)服务提供者提供服务的意愿动态变化,在SOC系统中服务分属不同的组织和机构,随时有可能撤离系统.设该种情形导致的服务下线几率为Pp.(2)服务本身动态变化,包括服务器负载、软硬件配置等条件的变化引发服务功能、性能、可用性的变化.设该种情形导致的服务下线几率为Ps.变化等.设该种情形导致的服务下线几率为Pn.(3)网络环境动态变化,包括网络传输速率的则由服务组件动态性引发的服务总的下线几率为常规的QoS保证机制一般采用实时监测上述具体指标(Pp,Ps,Pn),产生可以量化各种动态性的函数值(Q(Pp),R(Ps),S(Pn)),赋予不同的权重(k,l,m),并计算产生可以量化服务QoS的参数V(QoS),来为任务选择可以保证QoS的服务.V(QoS)=k·Q(Pp)+l·R(Ps)+m·S(Pn).此类QoS管理策略重点关注引发服务组件动态性的原因,需要耗费大量的资源用以实时监测各种具体的QoS指标以及计算QoS的量化参数,而且各类具体指标在QoS量化参数中所占权重的设定也比较困难.本文设计的QoS保证机制则重点关注生命期内调度到服务上的任务的完成情况以及服务动态性引发的后果,然后采用信用模型对其进行量化,并以信用记录的形式表示,系统根据服务的历史信用状况对未来生命期内的QoS状况进行预测.采用信用记录这一抽象层次较高的指标衡量服务的QoS状况,仅关注服务组件的整体动态性所引发的结果,而无须了解造成动态性的具体原因,可以一定程度上降低QoS管理的难度与系统开销.定义2.信用.在服务计算系统中信用包含两个方面:其一是SP(ServiceProvider)信用,服务提供者在注册服务的时候实际上做出了一种可以提供某种能力的承诺,所谓信用就是指在服务生命期内服务提供者能否持续、安全地提供这种能力.与之相对应的另一方面是SD(ServiceDemander)信用,服务请求者能否在服务生命期内以申请服务时所承诺的方式调用服务,并在随后及时地支付账单.定义3.信用记录值CR(CreditRecord).是服务提供者和服务请求者信用状况的历史记录,初始化时所有主体的CR值均为零.我们主要关注SP信用中的服务稳定性,即服务提供者能否在服务生命期内保证服务的持续在线.因此本文中的信用记录值同样被用来重点反映服务提供者在服务稳定性方面的信用状况.在上述定义的基础上,给出信用模型的定义.定义4.信用模型.服务计算系统中的信用模型是一个四元组(P,D,R,f),其中P是所有服务提供者的信用记录值集合;D为所有服务请求者的信用记录值集合;R为当前系统中存在的服务关系集合R={r1,r2,…,ri,…,rn},是从P到D的映射关系;f表示信用函数,对于R中每一个服务关系的删除,f都会根据服务质量对服务关系双方的CR进行相应的调整.定义5.服务关系.R:P→D是从服务提供者集合到服务请求者集合的映射,反映当前系统中存在的服务关系.每一条服务关系都是随着服务调度系统根据特定的策略为服务请求者匹配服务成功而建立,并随着服务生命期的结束而从R中删除.信用模型根据R可以掌握系统中所有的服务关系,并Page4对服务生命期内的关系双方的信用状况进行记录.定义6.信用函数.根据服务生命期内,具有服务关系双方的信用状况对双方的信用记录做出相应的调整.f:CR=CR+w,w∈W={w1,w2,w3,w4,…}.集合W代表信用事件集CE(CreditEvent)相对应的权值集合,CE即在服务生命期内可能发生的所有与SP和SD相关的信用事件.与信用事件相对应w值的正负和大小反映了该信用事件对服务关系双方信用记录的影响权重.当w>0时,表示该信用事件对信用记录有增益;相反当w<0时,表示该信用事件对QoS有不良影响,引发该事件的主体应受到相应处罚;当w=0时,表示该信用事件在系统稳定鲁棒性的承受范围内,即对QoS没有影响.3.2基于服务预留和服务备份的QoS保证机制为了提高SOC应用系统的稳定鲁棒性,我们采取了基于信用的服务调度、服务预留与服务备份的QoS保证机制.该机制基于以下基本原理和假设.假设1.主体的信用状况在一定时期内具有持续性.假设1的主要依据是:导致服务组件意外失效的原因主要有不可靠的硬件配置、软件的逻辑错误、网络传输的中断等.这些因素客观上来说可能具有一定的重复性,即某一服务组件一旦失效,那么在未来一段时期内它再次失效的概率将会明显增大.因此,在QoS保证机制中,我们将服务生命期内可能发生的所有事件均纳入信用事件集合CE中,根据其对系统稳定鲁棒性的影响大小赋予不同的权值形成权值集合W,通过信用函数f捕获信用事件并对SP信用记录值进行相应的调整,使得SP的信用记录能反映该服务在服务生命期内因各种原因而失效的几率大小.在服务调度阶段我们参考服务提供者的信用记录值并为其授予不同的优先级,保证高可靠性的服务可以得到优先的调度,从而实现风险规避.定义7.服务预留.当服务提供者在注册服务的时候,明确设定预留时间t(t0),即SP在未来的t时间内保证服务的可用性;当t=0时,表示该服务不提供服务预留随时可能会下线.对于支持预留的服务,在调度过程中会被优先考虑甚至可以在价格上予以奖励.当然如果服务提供者没有保证服务在预留时间内可用,则将会受到相应的惩罚并反映在信用记录上.采用服务预留策略,可以明显提高对于服务持续性比较敏感或者服务截止时间比较严格的任务的服务质量.服务预留主要基于以下事实.假设2.服务提供者能够准确地估计可以持续、稳定的提供服务的时间,或者说是服务提供者能够确定在未来多长时间内服务不会因为个人原因而下线.假设2主要依据:面向服务的计算系统中服务都是由网络中的资源经过封装、抽象而来,而多数情况下资源的拥有者都能确定资源在什么时间会空闲,并对外提供服务.定义8.服务备份.当正在提供服务的服务组件不满足该任务对服务质量的要求时,系统会选择一个可以替换当前组件的新服务组件作为该组件的备份,并限制该组件被调度给其它任务.当前组件不能继续提供服务时,可以将任务打包并进行任务迁移,第一时间在备份的服务组件上重新部署该任务.下面两种情况将会引发服务备份:(1)支持预留的服务组件的预留时间已经到期(2)对服务质量要求很高的任务,却被匹配到定义9.任务迁移.当正在提供服务的服务组件性能变得不再满足该任务需求或服务提供者向服务管理、调度系统申请服务下线时,将会引发任务迁移.任务的执行现场将会被打包,并迁移到备份服务或是系统重新调度的服务上部署并继续执行.信用记录驱动的服务调度实现风险规避;服务预留和服务备份实现风险控制;任务迁移实现风险补救.通过上述3个策略以期在该QoS保证机制中将服务组件失效引起服务中断的风险降至最低.4服务调度、预留、备份算法(倒计时t变为0时)而任务仍未完成.信用记录较低的服务.为了实现本文的QoS保证机制,我们提出了支持信用机制的服务调度、预留、备份算法的服务管理模型,以便实现风险规避、控制和补救,确保系统服务质量.图1给出支持信用管理的服务调度与管理模型.该信用机制由3部分组成:(1)信用记录数据库,用于记录面向服务计算系统中所有服务提供者和服务请求者的信用记录;(2)服务关系数据库,记Page5录当前系统中存在的所有服务关系;(3)信用管理模块,为系统提供信用信息,并根据系统中主体在服务生命期内的信用状况对信用记录进行调整.定义10.服务.我们将面向应用系统中的服务定义为一个五元组(SP,SFD,SPD,SCM,t),其中SP表示服务提供者,用于对服务标识和定位;SFD表示服务功能性描述,服务调度与管理系统根据其信息对服务进行分类;SPD表示服务性能性描述,服务调度系统根据其信息进行服务匹配;SCM表示服务调用方式,说明服务的具体使用方式(如服务的标准接口与底层网络端口的映射关系等);t表示服务的预留时间.所有服务都具有4种状态:State(s)=Unready(未就绪状态)/Ready(就绪状态)/Serv(服务状态)/Backup(预留状态),系统中所有注册的服务我们以集合S={s1,s2,…,sn}表示.定义11.服务请求(任务).相应的服务请求我们也定义为一个四元组(SD,DFD,DPD,SU),其中SD表示服务请求者;DFD表示服务请求的功能性描述,服务请求分发器根据其信息将其分发给相应的服务调度器;DPD表示服务请求的性能性描述;SU表示涉及到对服务调用细节的具体要求.所有的服务请求都具有4种状态:State(d)=Unsub(未提交状态)/Sub(提交状态)/Serv(服务状态)/Finish(完成状态),系统中所有已经提交的服务请求我们以集合D={d1,d2,…,dn}表示.系列算法.下面,将给出基于信用的QoS保证机制中的一算法1.信用记录调整算法.由于本文主要关注服务提供者的行为对QoS的影响,所以这里的信用记录调整算法主要针对服务提供者.设定服务提供者的信用事件集CE以及与W的对应关系:其中的数值表示6种不同的事件,类似于操作系统中的中断向量表用以捕获服务组件动态性所引发的结果,根据不同事件对系统QoS的影响程度被赋予不同的权重:w∈W={w1=-1,w2=-0.8,w3=-0.5,1.w1=-1:t≠0∩State(d)=Serv∩(State(s)=Serv→State(s)=Unready).事件类型1.当一个正在提供服务而且预留时间还没有到期的服务组件,由于某些原因突然失效,而且没有留出足够的时间使任务保存现场并进行任务迁移.2.w2=-0.8:t=0∩State(d)=Serv∩(State(s)=Serv→State(s)=Unready).事件类型2.一个正在提供服务但是预留时间为零的服务组件,由于某些原因突然失效,而且没有留出足够的时间使任务保存现场并进行任务迁移.3.w3=-0.5:t≠0∩(State(d)=Serv→State(d)=Sub)∩(State(s)=Serv→State(s)=Unready).事件类型3.一个正在提供服务而且预留时间还没有到期的服务组件,向服务管理系统申请下线,并留出足够的时间使任务完成现场保存和任务迁移.4.w4=0:t=0∩(State(d)=Serv→State(d)=Sub)∩(State(s)=Serv→State(s)=Unready).事件类型4.一个正在提供服务而且预留时间为零的服务组件,向服务管理系统申请下线,并留出足够的时间使任务完成现场保存、打包和任务迁移.5.w5=1:(State(d)=Serv→State(d)=Finish)∩(State(s)=Serv→State(s)=Unready).事件类型5.一个提供服务的服务组件在保证运行于其上的任务完成以后,申请下线或由于意外原因而失效.6.w6=1:(State(s)=Serv→State(s)=Finish)∩(State(s)=Serv→State(s)=Ready).事件类型6.一个提供服务的服务组件在保证运行于其上的任务完成后,进入服务就绪状态.这里主要定义了6个会触发服务关系改变的信用事件以及相应权值集合,在实际应用中可以根据系统对服务质量具体需求进行扩充和调整.算法过程如下:输入:导致服务关系被撤销的信用事件CE输出:返回调整后的服务提供者CR值Page61.持续监听服务关系R以捕获信用事件;2.Repeat3.If(捕获到一条服务关系ri的撤销)4.获取其信用事件代码CE;5.Switch(CE)6.Case1:w=w17.运行信用函数Break;8.Case6:w=w69.运行信用函数Break;10.EndSwitch11.返回调整后的SPi的CR值,并对信用记录数据12.Endif13.UntilR=算法首先持续监听服务关系R,确保可以捕获所有引起服务关系变更的信用事件,然后查询已经定义的信用事件集合CE并确定该信用事件的代码;步5~13根据返回的信用事件代码和相对应的权值集合W调用信用函数对引发该信用事件的SP的CR值进行调整;最后更新信用记录数据库中对应的CR.这样信用调整算法经过一段时间的运行,随着服务提供者信用记录的累积,服务的稳定性将会明显地在服务记录值的大小上得到体现,使得服务调度系统可以轻松地区分不能提供稳定服务的服务组件.算法2.基于信用的服务管理算法.输入:服务注册请求、任务提交请求、服务行为引发的输出:服务注册、服务调度方案、风险处理方案A.服务注册算法:1.持续监听服务注册接口;2.Repeat3.For(服务注册队列中的每一个服务注册请求)4.根据服务描述信息中SPID查询CRDDatabase5.SetState(s)=Ready;6.If(t>0)7.设定计时器RT=t并开始倒计时;8.Endif9.Endfor10.Until服务注册队列为空B.任务提交及服务调度算法:1.持续监听任务提交接口;2.For(每一个任务提交请求)3.根据任务描述信息中DFD将其插入相应服务池4.Endfor5.Repeat6.For(每一个任务)7.获取其DPD信息;8.对服务队列中按CRD值由高到低的顺序排列服9.If(SPD/DPD>Available)10.SetState(s)=Serv;11.SetState(d)=Serv;12.生成一条服务关系r,并将其加入R中;13.通知服务关系的双方开始任务部署;14.Endif15.Endfor16.Until任务队列为空C.服务预留和服务备份算法:1.持续监听预留行为和服务调度行为;2.For(t>0→t=0)3.探询SP是否延长服务时间;4.If(SPSett=NewT)5.RT=t,重设倒计时器;6.Else//SP无响应或不愿延长预留时间7.If(State(s)==Serv)8.引发服务备份;9.Endif10.Endif11.Endfor12.For(R中每一条服务关系的添加)13.If(服务的CRD<任务的CRD需求)14.引发服务备份;15.Endif16.Endfor服务备份:17.For(每一个服务备份请求)18.查询与该服务对应的服务队列;19.If(SPDiSPD)20.SetState(s)=Backup;21.Endif22.Endfor23.If(任务完成)24.SetState(s)=Ready;25.EndifD.任务迁移1.持续监听服务行为引发的信用事件;Page72.For(一个服务申请下线)3.If(服务上有任务正在运行)4.对其现场进行打包;5.If(存在一个备份的服务)6.Set(State(s)=Backup→State(s)=Serv);7.将打包的任务数据传输过去开始任务部署以8.Else//没有备份服务9.将任务插入对应服务调度器任务队列的队头;10.任务调度后向目的服务传输打包的任务数据;11.Endif12.Endif13.SetState(s)=Unready.5仿真实验结果与分析我们对上述基于信用的QoS保证机制的一系列算法进行了仿真验证.模拟面向服务计算应用系统中的服务调度过程,记录系统中服务提供者的CRD变化,以验证信用记录算法在区分不稳定服务方面的有效性和成功率.同时通过固定系统中的服务,设定提交的任务的数量和规模,记录每个被提交任务完成时所被调度的次数,以此来验证算法在降低服务动态性对QoS影响方面的效率.仿真实验1.本实验中重点验证信用模型中信用记录调整算法能否准确地捕获信用事件,信用记录能否真实地反映服务的QoSLevel.因此在模拟的服务计算应用系统中我们定义了100个独立的服务,在进行服务注册时由系统随机地将它们赋予不同的QoSLevel:1、2、3,并分别对应0.01、0.005、0.003的服务下线几率,由系统不断地随机产生一系列的服务请求(设服务请求周期为T),并将其调度到相应的服务上执行,最后每隔一段时期记录系统中所有服务提供者的CRD并计算对不同QoSLevel的服务组件区分的成功率.由于在正态分布情况下QoSLevel1和QoSLevel3的样本过少,从而导致信用模型对少数极端样本完全识别的几率过高且所需的时间过短,导致仿真实验无法准确评估算法对服务组件QoSLevel的区分成功率.本仿真实验中所有服务的QoSLevel的概率分布采用了平均分布,而非更符合现实情况的正态分布.如图2中所示,系统初始化时所有服务均没有任何信用历史,设定初始值CRD=0,因此服务调度系统现在并不能区别不稳定的服务组件,此时的信用记录驱动的服务调度算法与非信用记录驱动的没有区别.在系统运行20个服务请求周期后我们可以看出,服务提供者的CRD值已经被信用记录函数根据服务提供者在生命周期内的表现进行了相应的调整.此时的CRD值并不能精确反映服务的QoSLevel,但是已经呈现出一定的规律性,即服务QoSLevel较高其CRD值也相对较高.此时系统对不同QoSLevel服务组件的区分成功率较低,仅为37%,如图3所示.随着系统的继续运行,服务提供者的CRD值对服务QoSLevel的反映越来越准确.通过图4可以清楚地看到,系统运行t=60T以后,服务的CRD值基本上分化为两个明显的区间,而且对稳定性低的服务,其区分成功率达到了93%.此时,CRD值驱动的服务调度算法在进行服务匹配的时候,在有可选服务的情况下基本上可以避免给服务请求分配下线几率较大的服务.系统运行到t=280T时(图5),系统通过CRD值对不稳定的服务即QoSLevel=1的服务的区分成功率达到100%,当服务请求与注册服务匹配时,Page8就可以规避下线几率较高的服务.但是对普通服务和优质服务的区分还不是特别的明显.图5t=280T时,QoSLevel与CRD对照图随着时间的推移,CRD值较高的优质服务和普通服务也开始逐渐分化为两个区间.如图6所示,优质服务的CRD值比普通服务的CRD值增加趋势更为明显.图6t=680T时,QoSLevel与CRD对照图在图7中可以看到当t=1880T时,系统中服务QoSLevel的不同可以在服务提供者CRD值上得到非常明显的体现,服务QoSLevel的3个不同等级直接被反映到了CRD值的3个不同区间,系统对各种不同QoSLevel的服务区分成功率达到100%.此时以CRD驱动的服务调度程序具有可选服务的情况下,将任务由于服务组件下线而被中断的几率由原来的8降低到了3.图7t=1880T时,QoSLevel与CRD对照图结果表明:随着系统运行时间的增加,信用记录调整算法对不同QoSLevel的服务的区分成功率不断提高.当系统运行至t=1880T时,信用模型对服务的区分成功率达到100%,不仅可以区分出劣质服务,而且对于QoSLevel等级最高的优质服务的区分成功率也达到了100%,尽管优质服务与普通服务的下线几率相差很小.仿真实验2.本实验重点验证基于信用的服务调度算法能否有效降低任务由于服务动态性而引起的再调度次数,该仿真实验分为两个仿真过程.仿真过程1.固定服务数量、固定任务数量、不同规模的任务.在模拟的服务计算系统中随机生成了300个独立的服务,随机赋予不同的性能和功能参数,由系统中的信用模型根据它们的信用状况,对服务的QoSLevel进行区分,并将它们按照CRD值降序排列.通过仿真系统在一定时期内随机生成100个不同规模(任务完成所需时间:50T、100T、200T、500T、1000T,T为仿真实验中服务行为周期)的一系列服务请求,并利用基于信用的服务调度算法和传统的非信用记录驱动的调度算法将其调度到相应的服务上执行,最后记录系统中所有提交的服务请求完成时被调度的次数.通过对比两种服务调度算法对同样的任务队列中每个任务的调度次数来分析算法的效果.由图8~13所示的6个图中可以看出,本文的CRD驱动的服务调度算法与常规的非信用驱动的服务调度算法相比,显著降低了任务的调度次数.尤其是当任务规模不是特别大时,从1.40~1.82降低至1.02~1.10.但是随着每个任务完成所需的时间即任务规模的不断增加,CRD驱动的服务调度算Page9图12任务时间为1000T时,调度次数对比法和传统服务调度算法对于任务的调度次数都有所增加.当设定的任务规模特别大时,常规的服务调度算法的调度次数变化不大,从1.80(DT=500T)增加到1.82(DT=1000T),CRD驱动的服务调度算法则有一个明显的增加,从1.10(DT=500T)增加到1.49(DT=1000T).由图12我们也看出调度次数的增加主要来自于后面的任务调度次数.原因在于当任务规模很大时,每个任务完成所需的时间很长,导致已经分配出去的优质服务持续繁忙无法释放,所以后面的任务便只能被调度到QoSLevel较低的服务上运行,因此导致调度次数迅速增加.这表明CRD驱动的服务调度算法,只有存在一定数量可选服务时才能达到较好的效果.同时,也表明对于QoSLevel较低的服务,不会由于服务质量得不到保证而被系统拒绝调度,从而打击服务提供者提供服务的积极性,只是被赋予较低的优先级.仿真过程2.固定服务数量、不同数量的任务、不同规模的任务.在模拟的服务计算系统中随机生成了300个独立的服务,随机赋予不同的性能和功能参数,由系统中的信用模型根据它们的信用状况,对服务的QoSLevel进行区分,并将它们按照CRD值降序排列.通过仿真系统在一定时期内生成随机规模、不同数量(任务数量:50、100、200、300、500)的一系列服务请求,并利用基于信用的服务调度算法和传统的非信用记录驱动的调度算法将其调度到相应的服务上执行,最后记录系统中所有提交的服务请求完成时被调度的次数.通过对比两种服务调度算法对同样的任务队列中每个任务的调度次数来分析算法的效果.Page10通过系统随机生成固定数量的随机规模任务的任务队列,来考察CRD驱动的服务调度在最接近现实应用的情况下,对降低系统中任务调度次数的效率.实验结果显示,在调度不同长度任务队列时,CRD驱动的服务调度算法对任务的平均调度次数均保持在1.1~1.2之间,而且明显地低于常规的服务调度算法.在设定的5种长度的队列调度过程中,常规调度算法的平均调度次数为1.32(n=50)、1.49(n=100)、1.545(n=200)、1.81(n=300)、1.836(n=500),有比较明显的增加,最后基本稳定在1.85附近.CRD驱动的服务调度算法的平均调度次数为1.16(n=50)、1.21(n=100)、1.2(n=200)、1.177(n=300)、1.108(n=500),基本维持在1.1~1.2之间.同时我们通过图19也发现,随着提交的任务队列长度的增加,CRD驱动服务调度算法在平均服务调度次数上有一个很缓慢的下降趋势.其原因主要在于,调度程序的服务选择策略主要依赖于信用模型对服务的区分成功率,而随着任务队列长度的增加,系统的运行时间也被延长,同时信用模型的运行时间也同步增加,使得信用模型对服务的区分成功Page11率越来越高,因此CRD驱动的服务调度算法为用户选择优质服务的成功率也相应地增加.通过上面对比较接近现实应用环境的任务调度过程仿真,结果显示CRD驱动的服务调度算法在系统具有可选服务的情况下,可以显著降低任务的平均调度次数,有效降低了由于服务动态性引发的任务中断所发生的概率,提升了系统的QoS.本文上述的仿真实验中对系统中服务组件的动态性进行了较为接近实际情况的模拟,服务的QoSlevel是由系统随机生成但在整个仿真过程中均不再变化,而当服务的QoS状况发生变化后,根据服务原始信用记录的累积情况,系统可能需要运行相当一段时间以对服务的原始信用记录进行充抵以后,其QoS状况才能在信用记录中得以体现.为进一步提高算法的抗扰动能力,在实现时可以采用以下策略:(1)每当服务组件撤离系统时便对其信用记录清零,当其再次加入时开始重新累积;(2)每隔一段时间便对系统中所有服务组件的信用记录进行清零;(3)对信用记录进行扩展:CRD→(CRD,wquery),其中wquery为一个长度为n(n的大小可以根据算法情况设定)的循环队列,用以记录该服务组件最近n次触发的信用事件对应的权值,系统可以根据该队列值的变化趋势对其CRD值进行调整,以按照一定的倍数E放大服务组件某一个时期内的动态性,即按照原有的权值的一定倍数对服务的信用记录进行增益或惩罚,使其在尽量短的时间内能够反映服务变化后的QoS状况;(4)当服务的QoS有较大的变化时(例如配置了高性能的硬件等),服务提供者以向系统提出申请注销以前的信用记录值,初始化以后重新开始积累信用记录.对于上述4种策略:第1种和第2种策略实现简单,适用于服务组件QoS变化周期较长的环境,对动态性过强系统灵敏度仍不够高;第3种策略需要对算法中的信用记录表示方式进行扩展,通过加入权值队列记录服务组件最近一段时期内的QoS变化趋势,实现与第1、2种策略相比有一定复杂度,但是通过n值的大小和动态性放大倍数E的调整,算法可以获得很高的灵敏度和抗扰动能力;最后一种策略实现简单,但是需要用户交互提出初始化申请.6总结考虑到现有的QoS保证机制没有充分考虑服务组件动态性对服务质量影响的问题,本文提出了一种基于信用的服务预留和服务备份机制,定义了SOC系统中的信用模型、信用记录以及对信用记录进行调整的信用函数、信用事件集和对应权值集合,量化服务组件行为对系统服务质量的影响,使信用记录值反映服务组件的稳定性.设计了信用记录驱动的服务调度、服务预留和服务备份算法,并进行了仿真实验.结果显示该QoS机制可以明显地提高SOC应用系统的服务质量.今后的工作将在此研究的基础上将用户行为对服务质量的影响纳入信用模型,建立高效的任务迁移算法,进一步完善该QoS保证机制,并将其应用到SOC原型系统的设计工作中.
