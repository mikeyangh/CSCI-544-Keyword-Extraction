Page1基于路径相关性的回归测试数据进化生成1)(中国矿业大学计算机科学与技术学院江苏徐州221116)2)(中国矿业大学信息与电气工程学院江苏徐州221116)摘要尽管回归测试是一种重要的软件测试方法,但是,如何选择测试目标,并充分利用已有的测试数据,目前尚缺乏有效的方法.文中基于路径相关性,研究求解回归测试数据生成问题的新方法,以高效地进化生成可用于回归测试的测试数据集.该方法根据路径与节点的相关矩阵,首先进行目标路径排序,并基于路径相关性,建立新的覆盖影响路径的回归测试数据生成问题的数学模型;其次,结合遗传算法对上述模型求解时,利用穿越已有目标路径的测试数据,编码后取代进化种群的部分个体.将所提方法应用于多个基准和工业程序的测试,并与其他回归测试数据生成方法比较,最后实验结果表明,所提方法能够有效提高生成测试数据的效率.关键词回归测试;测试数据生成;路径相关性;路径排序;遗传算法1引言在软件生命周期中,开发人员需要经常对软件进行维护,维护的内容包括:新增代码、删除不必要的代码以及修改原来的代码等.上述工作在满足新需求的同时,也可能引入新的缺陷或错误.因此,有必要对维护后的软件重新测试,以提高软件的可信度.所谓回归测试,是指确认维护的软件修正正确且没有引入新的缺陷而进行的测试[1].已有统计表明,回归测试占软件维护费用的50%以上[2].这说明,研究合适的方法,提高回归测试效率,对降低软件维护成本是非常必要的.回归测试流程如下:首先,识别受影响的程序片段;然后,选择已有的部分测试数据,或基于现有测试数据,再生成新的测试数据,使得这些数据的执行路径能够覆盖影响的程序片段;最后,以这些测试数据为输入,执行维护后的程序,以验证其正确性[3].与其他测试方法相比,已有测试数据集包含测试信息的利用,是回归测试的关键.因此,如何有效利用已有测试数据集,以提高测试效率,是回归测试的重要研究内容.到目前为止,关于利用已有测试数据集的研究工作,主要集中于已有测试数据集的选择和扩展等2个方面,其中,在已有测试数据集的选择方面,侧重于确定已有测试数据集中数据的优先级[4-5];在扩展已有的测试数据集方面,主要针对待覆盖的目标,如语句、分支以及路径等,运用搜索的方法,例如遗传算法,再生成新的测试数据[2].遗憾的是,已有方法仅是将测试数据的再生成,看作覆盖受影响程序元素的测试数据生成问题,而没有充分利用已有测试数据集的信息,这造成了大量有用信息的不必要浪费.近年来,采用遗传算法,生成覆盖路径的测试数据,得到国内外学者的广泛关注,主要做法是:首先,把测试数据生成问题,转化为单目标或多目标优化问题;然后,基于待优化目标,定义用于遗传算法进化种群个体评价的适应度函数;最后,对由测试数据编码形成的种群进化一定代数,即可得到满足测试需求的测试数据.容易看出,遗传算法的进化种群能够携带穿越多个目标路径测试数据的信息,因此,执行一次遗传算法,能够得到覆盖多条目标路径的测试数据[6-10].本文研究回归测试数据生成问题,在充分利用已有测试数据的基础上,通过执行一次遗传算法,迅速生成穿越所有受影响路径的测试数据.为此,首先,根据修改节点与目标路径的相关矩阵,对目标路径排序,并基于路径相似度,构建覆盖影响路径的测试数据生成问题的数学模型;然后,选用遗传算法求解前述模型时,利用覆盖已有目标路径的现有测试数据,编码后替代进化种群的部分个体.本文的贡献主要体现在如下3个方面:(1)基于路径相似度和差异度,给出路径相关性的度量方法,并根据路径修改情况以及路径复杂度,对应当覆盖的目标路径排序,建立可用于回归测试数据集优化生成问题的数学模型;(2)利用遗传算法进化生成测试数据时,根据覆盖目标之间的路径差异度,将满足条件的已有测试数据编码,替代进化种群的部分个体;(3)将所提方法应用于6个规模不等的基准和工业程序测试中,并与多个已有方法比较,以检验本文方法生成回归测试数据的性能.本文第2节是相关工作综述;第3节通过路径相关度,对需要覆盖的目标路径排序,并建立回归测试数据生成问题的数学模型;第4节阐述采用遗传算法求解上述模型时,已有测试数据的利用;第5节给出所提方法在基准和工业程序的应用与对比实验;最后,第6节对本文工作总结,并指出下一步工作计划研究的问题.2相关工作我们知道,对一个软件维护后,需要对软件受影响的部分进行快速、全面的回归测试.到目前为止,与回归测试相关的研究工作主要包括测试需求约简、测试数据选择以及测试数据集扩大等.由于在回归测试时,已经存在一个测试数据集,因此,采用合适的方法,有效利用已有测试数据,以提高测试效率,是成为回归测试的关键.在测试需求约简方面,Tallam等人[11]提出基于概念格分析的测试需求约简方法,缩减已有测试数据集的规模.Zhang等人[12]基于测试需求之间关系,约简测试需求,并将约简后的测试需求作为测试数据集生成和约简的基础,实现测试数据集优化.Sun[13]分析错误对应的前提条件之间的蕴含关系,减少需要满足的前提条件,以约简满足前提条件的测试数据.Zhang等人[14]通过研究程序对应的控制Page3流图,减少与修改点无关的分支,以覆盖约简分支后构成的路径为目标,生成测试数据.上述方法通过减少测试需求,降低了需要生成的测试数据数目,使得回归测试数据生成的效率提高.但是,这些方法没有充分利用约简后测试需求之间的关系,生成覆盖受影响路径的测试数据.关于回归测试已有测试数据的利用,已有研究工作主要包括已有测试数据集的选择和扩展等2个方面.Nachiyappan等人[15]利用搜索的方法构造用于再测试的数据集时,将已有测试数据作为进化算法初始种群的一部分,选择测试目标覆盖率高且执行成本较少的已有测试数据.Ye等人[16]通过分析程序修改前后的活动图,根据程序更新对路径的影响,对路径分类,并基于已有测试数据覆盖分类后路径的情况,选择需要修改的测试数据.Kumar等人[17]对比修改前后程序的路径,选择新增加和发生改变的路径,作为应该覆盖的目标,基于路径选择方法,达到选择测试数据的目的.Sampath等人[18]针对目前的测试数据集的优化问题,包括测试数据选择、约简、优先问题给出测试数据优化问题的统一模式,并给出多评价准则下的测试数据的选择方法.在上述测试数据选择方法中,Nachiyappan等人选择测试数据的过程繁琐、耗时;Ye与Kumar等人均基于路径选择方法,根据程序更新前后路径的变化,先选择目标路径,然后选择生成测试数据;Sampath等人提出的方法只从现有测试数据集中,选择满足多个评价准则的测试数据,忽略了生成新的测试数据.Taneja等人[19]提出一种受影响路径的识别方法,并仅针对影响输出的路径进行测试.Shin等人[20]先检验现有测试数据是否失效,然后,利用现有数据,并对输入空间中搜索到的测试数据评价,生成新的满足覆盖目标的测试数据.Santelices等人[21]研究生成测试数据覆盖更新影响的语句时,分析程序的数据流和控制流,选择与修改点具有依赖关系的路径,生成测试数据覆盖上述路径.Xu等人[22]提出的测试数据集扩大方法,基于已有测试数据运行修改后的程序,以找出发生改变的语句,对这些语句深度优先排序后,利用已有测试数据,生成新的测试数据.在上述测试数据集扩大方法中,Taneja等人通过减少受影响的路径,缩短生成测试数据需要的时间;Shin等人利用验证后的原有测试数据,通过启发式方法再生成测试数据,但该方法得到的测试数据集具有冗余,还需要进一步约简;Santelices等人给出的方法,未考虑已有测试数据的利用;而Xu等人在测试数据再生成时,没有建立选择已有测试数据的准则.这意味着,这些方法均没有充分利用已有测试数据提供的有用信息.另外,Xu等人[23]运用遗传算法,生成满足覆盖分支准则的测试数据时发现,不同算法、不同的测试目标执行顺序以及是否利用新生成的测试数据,对测试数据生成的效率有很大影响,但是,他们没有利用影响测试数据生成的因素,提高回归测试数据生成效率.Bueno和Maragathavalli等人[24-25]在单元测试中,采用遗传算法生成覆盖多路径的测试数据时,以穿越的路径相似为准则,选择部分已生成的测试数据,以帮助生成覆盖其他目标路径的测试数据.但是,如果在回归测试中,采用该方法选择测试数据,需要满足已穿越的路径与待覆盖的目标路径,具有以首节点为起点的多个相同连续节点.遗憾的是,该方法遗漏了虽然没有满足上述条件,但与待覆盖的目标路径具有较大相关度的已穿越路径对应的测试数据,使得测试数据仅能在较小的输入域里选择;另一方面,在回归测试中,该方法并没有考虑到程序结构的变化,没有利用程序结构变化的信息来选择已有测试数据,帮助生成测试数据.由上述可以看出,在回归测试中,虽然有不少方法或多或少用到已有测试数据信息,但是,这些方法主要存在以下问题:(1)没有利用路径的变化情况以及没有利用已覆盖的路径与未覆盖路径之间的关系,选择已有测试数据.(2)没有合理设定需生成测试数据覆盖的目标路径的次序,导致未能充分利用测试数据生成过程中的信息.(3)缺乏有效的指标选择已有测试数据,利用已有的未失效数据品质不高.如果在采用遗传算法生成满足测试需求覆盖的测试数据时,解决以上问题,充分利用已有的测试数据,构成进化种群的部分个体,那么,将无疑会进一步发挥遗传算法生成测试数据的潜能,进而可以高效的进化生成回归测试数据.3回归测试数据生成问题的数学模型本节首先定义一些与程序路径相关的基本概Page4念;然后,根据路径相关性,确定目标路径的覆盖次序;最后,建立回归测试数据生成问题的数学模型.3.1基本概念定义1.节点.记被测程序为G,程序G的一个节点,记为d,是该程序的一个语句块,满足在程序G的运行中,要么一起执行,要么都不被执行.节点可以是一个循环结构的循环条件,也可以是一个判断结构的判断条件,还可能是一或多条连续语句.每个节点有相应的前置约束条件表达式,包含该条件表达式的节点,称为分支节点.定义2.路径.程序G的一条路径,记为p,为程序G在一组输入上运行时,控制流经过的节点序列d1d2…dn,其中,n为路径p的长度.定义3.路径相关.记p1和p2为程序G的2条路径,对应的节点序列分别为d11,d12,…,d1|p1|和d21,d22,…,d2|p2|,其中,p1和p2分别为p1和p2包含的节点数.如果p1∩p2≠,那么,称这2条路径是相关的;否则,称这2条路径不相关.特别的,当p1=p2时,称这2条路径完全相关.为了考察2条路径是否相关,需要对程序的路径统一编码.为此,首先,对程序控制流图的所有分支节点广度优先遍历,记录这些分支节点的序号;然后,对程序插桩,并记录某路径在不同分支节点处,穿越真假分支的情况,穿越真分支记为1;否则,记为-1,如果没有穿越该分支结点,记为0;最后,根据这些真值,对路径进行编码,编码长度等于分支节点数.如图1所示,某程序包含如下4条路径p1、p2、p3以及p4,这些路径包含的节点分别为{1,2,4,5,7},{1,2,4,6,7},{1,3,4,5,7},{1,3,4,6,7}.采用上述编码方法,这些路径的编码分别为11、1-1、-11以及-1-1.与采用节点序列表示某路径相比,采用编码表示路径,需要的编码长度更短,且所有路径的编码长度均相同,这使得考察路径的相关性更容易.定义4.路径相似度.对于程序G的2条路径p1和p2,从首节点开始,这2条路径相同编码的序列长度,与路径编码总长度的比,称为路径p1和p2的相似度,记为S(p1,p2),那么,S(p1,p2)可以表示为其中,αl(p1,p2)=由定义4可以看出:(1)当0<S(p1,p2)<1时,路径p1和p2至少存在1个从首节点出发的相同节点;(2)S(p1,p2)越大,这2条路径的相关性越大;特别的,当S(p1,p2)=1时,路径p1和p2完全相关.定义5.路径差异度.对于程序G的2条路径p1和p2,这2条路径真值不同的分支节点数与路径编码总长度的比,称为路径p1和p2的差异度,记为D(p1,p2),那么,D(p1,p2)可以表示为其中,βl(p1,p2)=由定义5可以看出:(1)当0<D(p1,p2)<1时,p1和p2至少存在一个相同的分支节点;(2)D(p1,p2)越小,这2条路径的相关性越大;特别的,当D(p1,p2)=0时,p1和p2完全相关.路径相似度和差异度均能从某一侧面,反映2条路径p1和p2的相关度.对于待覆盖的一条目标路径以及任意一个测试数据,由定义可以得出:(1)路径相似度可表明从第一个节点开始,测试数据穿越的路径对目标路径的接近程度.在程序中,由于前面的节点往往对后面的节点具有占优关系,所以,在生成覆盖目标路径的测试数据过程中,路径相似度可用于评价测试数据从程序入口开始,依次满足目标路径分支节点真值的序列长度.(2)与路径相似度相比,路径差异度更能反映2条路径所有分支节点的差异.测试数据穿越的路径与目标路径的差异度,反映了测试数据没有满足Page5的目标路径上的分支节点真值的个数.如果不同的测试数据覆盖相同的分支,这说明,这些测试数据的值或相互关系可能具有某些共同的特征.例如,不同测试数据的值,同时都满足一定的谓词条件,那么,这些测试数据能够覆盖相同的分支.显然,2条路径的差异度越小,这些路径之间的相关性就越高,从而穿越这两条路径的测试数据覆盖相同的分支与节点数越多.如果能从与目标路径具有相关性的路径中提取尽可能多的测试数据信息,这意味着,可以引导测试数据的执行轨迹逐渐向目标路径收敛,进而得到覆盖目标路径的测试数据.基于以上分析,本文在构建测试数据生成问题的数学模型时,选择路径相似度作为目标函数,而在选择已有测试数据时,基于路径差异度.3.2基于相关性的目标路径排序鉴于存在多条需要覆盖的目标路径,且生成覆盖不同路径的测试数据,需要的计算资源不同,因此,合理的目标路径覆盖顺序,能够有效提高测试数据生成效率.现有的确定目标路径覆盖顺序的方法有随机法和深度优先搜索法等[23].鉴于回归测试中已存在原有的测试数据集,而不同的目标路径与已有测试数据集覆盖的路径具有不同的相关度,如果利用路径相关性,确定被覆盖的目标路径顺序,那么,将会利用已有的测试数据集提供的信息,提高测试数据生成效率.记程序G所有修改的节点构成的集合为C={c1,c2,…,cm},所有需要覆盖的目标路径构成的集合为P={p1,p2,…,ps},其中,m和s分别为修改节点和目标路径数,根据修改节点与目标路径的关系,可以构造如下相关矩阵,记为γ(C,P):式中,γij∈{0,1},且γij=1表示路径pj经过修改节点ci;γij=0表示pj不经过ci.根据式(2),容易知道,如果一个目标路径包含的修改节点越少,那么,该路径与程序修改之前的某一条或几条路径的路径相关性就越大,进而穿越这些路径的测试数据,对生成覆盖该目标路径的测试数据越有利用价值.鉴于此,基于γ(C,P),提取反映程序变动前后,目标路径pj变动的节点数,记为N(pj,C),其表达式为此外,根据式(1),在程序G中,第1个修改节点的位置越靠后,该路径与程序修改之前的某一条或几条路径的相关性就越大,那么,使用已有测试数据求解,较容易生成覆盖该路径的测试数据.基于γ(C,P),第1个修改节点的位置,记为F(pj),可以表示为对待覆盖的目标路径排序时,还应考虑目标路径包含的节点数.一般而言,一条目标路径包含的节点数越多,那么,生成的测试数据应当满足的分支谓词条件越多,从而生成能够覆盖该路径的测试数据越困难.这表明,该目标路径在排序中应该越靠后,使得在生成覆盖该目标路径的测试数据过程中,可以利用更多已经得到的覆盖其他路径的测试数据,而覆盖程序G其他路径的测试数据,包含的满足分支谓词条件的相关信息,可以用来提高覆盖节点数较多的目标路径的测试数据生成效率.综合上述因素,目标路径pj被覆盖的优先级,记为PR(pj),可以表示为PR(pj)=-w1N(pj,C)+w2F(pj)-w3|pj|(6)式中w1、w2以及w3分别为N(pj,C)、F(pj)以及|pj|的权值,且w1w2w3>0.根据式(6),能够得到所有目标路径的覆盖优先级.这样一来,对于所有需要覆盖的目标路径P,按照覆盖优先级从大到小排列[26],即可得到排序后的目标路径,记为P={p3.3测试数据生成问题的数学模型测试数据生成问题可以描述为:对于修改后的程序G,输入向量为狓,输入域为X,在X内生成测试数据x1,x2,…,xs,且以x1,x2,…,xs为程序G的输入,执行G之后,穿越的路径分别为p对于程序G的某一输入向量狓,记狓穿越的路径为p(狓).根据前述路径相关性定义,如果p(狓)与第j个目标路径p测试数据.此时,在输入域中,S(p(狓),p值,D(p(狓),p标路径pS(p(狓),p题.考虑程序G靠近程序入口的节点,对后面的节点具有占优关系,本文以路径相似度作为优化问题的目标函数.因此,对于所有目标路径而言,生成覆盖目标Page61,p路径p求取S(p(狓),p最大值问题,其数学模型为式中,fj(狓)=S(p(狓),p由式(7)可以看出,本文的测试数据生成问题建模为一个多目标优化问题,使得生成的测试数据集能够覆盖所有的目标路径.但是,该问题与传统的多目标优化问题又有很大区别,主要体现在:(1)传统的多目标优化问题在决策变量所在的域中,寻找一个Pareto解集,使得该解集中任一解对应的所有目标同时达到最优;式(7)表示的优化问题是在测试数据所在的域中,寻找一个测试数据集,使得该集合中任一测试数据仅针对某一目标达到最优;(2)传统多目标优化问题的目标函数求解没有先后顺序;式(7)表示的优化问题的目标函数求解具有先后顺序,具体的讲,只有生成使得fj(狓)最大的测试数据,才进一步生成使得fj+1(狓)最大的测试数据,直到生成使得fs(狓)最大的测试数据.这样做的动机是,充分利用已覆盖其他路径测试数据的蕴含信息,提高生成测试数据的效率.4基于遗传算法的测试数据生成本节主要阐述式(7)描述优化问题的求解方法,思想是:基于遗传算法,采用传统的遗传策略进化种群,按照式(7)的目标函数顺序,依次生成使得这些目标函数值最大的测试数据;在种群进化过程中,按照路径差异度准则,利用部分已覆盖路径的测试数据,编码后替换当前进化种群的个体,使得执行一次遗传算法,生成所有覆盖目标路径的测试数据.4.1覆盖已有路径的测试数据选择采用遗传算法求解优化问题时,如果进化种群的性能高,那么,将有利于得到期望的最优解.因此,生成覆盖某一目标路径的测试数据时,采用合适的方法,提高进化种群的性能,是十分必要的.如第2节所述,Bueno和Maragathavalli等人[24-25]采用遗传算法生成覆盖多路径的测试数据时,以穿越的路径相似为准则,选择部分已生成的测试数据,替换进化种群的个体,以生成覆盖其他目标路径的测试数据.但是,该方法并没有充分利用已有测试数据.如图1所示,假设待覆盖的目标路径由语句1、3、4、6以及7组成,其余路径均有测试数据覆盖.如果以路径相似度作为测试数据选择的准则,那么,只能选择1条与待覆盖的目标路径相似度为0.5的路径对应的测试数据,该路径由语句1、3、4、5以及7组成;如果以路径差异度作为选择的准则,那么,将能选择2条与待覆盖的目标路径差异度均为0.5的路径对应的测试数据,其中,第1条路径由语句1、2、4、6以及7组成,而第2条路径由语句1、3、4、5以及7组成.虽然这2个准则都能够利用已有的测试数据,提高进化种群的性能,但是,以路径差异度作为测试数据选择的准则,显然能够利用更多已覆盖路径对应的测试数据.特别是,当程序修改节点的位置在控制流图中比较靠前时,使用路径相似度准则,很难找到满足条件的已有测试数据;而使用路径差异度准则,却容易找到满足条件的已有测试数据.现在分析路径与输入向量之间的关系.记程序G的所有分支节点包含的条件表达式构成的集合为{H1(狓),H2(狓),…,Hn(狓)},将p(狓)与p相同的分支节点条件表达式前移,能够得到一个新的分支节点条件表达式序列,该序列可以表示为H1(狓),…,Hn(狓),其中,Hj取值不相同的分支节点条件表达式,而H与pH的分支节点条件表达式.进一步,统计HnD(p(狓),pnD(p(狓),pH越小,满足目标路径的分支条件表达式的输入分量1(狓),…,H就越多.在回归测试中,一旦被测程序确定,那么,H变的.因此,路径差异度D(p(狓),p值越小,此时,通过种群进化求解的输入分量个数就越少.根据上述分析,选择覆盖程序修改后路径的测试数据方法如下:首先,生成并更新覆盖部分目标路径的已有测试数据构成的集合,记为T,该集合包含的元素为:(1)覆盖程序修改没有影响的目标路径的测试数据;(2)程序修改之后,在测试数据生成过程中,获取的穿越待覆盖目标路径的测试数据;然后,对于须覆盖的目标路径p数据覆盖的路径与p或等于某一阈值的测试数据,替换当前进化种群的部分个体.Page74.2进化种群部分个体的替代当种群进化以生成覆盖目标路径p据时,记当前种群需要替代的个体数为e,采用第4.1节给出的方法,从集合T中选择多个覆盖已有路径的测试数据,替换当前种群的e个个体.记集合T中满足已覆盖路径与p的测试数据个数为e,那么,存在以下2种情况:(1)e<e;这说明,集合T中满足条件的测试数据不够.此时,选择上述e个覆盖已有路径的测试数据,与随机生成的e-e个测试数据一起,替换当前种群的e个个体.(2)ee;这说明,集合T中满足条件的测试数据比较多.此时,需要从e个测试数据中选择e个,替换当前种群的部分个体.鉴于新生成的测试数据满足修改节点的分支条件表达式,因此,选择e个用于替换个体的测试数据时,优先考虑新生成的测试数据.针对上述2种情况,首先,构造集合T的数据结构为带头结点的链表,链表中的数据为能够覆盖修改后程序目标路径的原有测试数据,当生成覆盖目标路径的新的测试数据后,更新集合T,在头结点指向的位置插入新生成的测试数据.可以看出,集合T在链表中的测试数据穿越路径的顺序与问题模型的目标路径顺序相反;其次,进化种群部分个体的替代策略,如算法1所示,从头结点开始,按照第4.1节设定的标准,从集合T中依次选择满足条件的测试数据,编码后对当前种群Pop的前e个个体替换,如果集合T的元素遍历完毕,且替换的个体数e<e,那么,随机生成e-e个测试数据,编码后置换余下的个体.算法1.进化种群部分个体替代的伪代码.输入:&Pop,e,&T输出:替换后的种群BEGIN1.e=0;i=0;2.WHILE(e<e&&!EOF)2.1狓=GetElem(T,i)2.2IF(D(p(狓),p2.2.1Pop[e]=Code(狓);2.2.2e++;3.i++;4.ENDWHILE5.WHILE(e<e)5.1Pop[e]=Code(Random());6.ENDWHILEEND执行替代算法后的种群由以下个体组成:(1)e个来源于集合T中满足差异度阈值的测试数据,该部分个体穿越的路径与p关度,对应的测试数据满足p达式.(2)当e<e时,随机生成的e-e个个体.(3)替代前,生成覆盖目标路径p由种群构成可以看出,执行替代算法后,既可利用原有测试数据和新生成的测试数据引导种群进化,又可利用生成覆盖目标路径p在种群的信息,那么,执行替代算法后,种群的性能将明显提升,且具有较好的多样性.4.3路径差异度阈值的设定考虑到不同程序中,目标路径数与集合T包含的测试数据数不同,本文的差异度阈值设定如下:由式(8)可以看出:(1)当z等于1-1/n时,要求已穿越的路径与目标路径,至少有一个节点相同,此时,这些路径具有相关性.因此,集合T中所有穿越与目标路径具有相关性路径的测试数据,均可以作为选择的测试数据;(2)当z等于11/n,此时,要求已穿越的路径与目标路径,最多有一个节点不相同,那么,这些路径与目标路径将具有最大的相关性.因此,选择集合T中穿越这些路径的测试数据.进一步,|P|越大于e,那么,z的值越小,此时,要求从集合T中选择的测试数据覆盖的路径,与目标路径的相关性越大.需要说明的是,通过式(8)的差异度阈值,本文提供了一种已有测试数据的利用方法,使得从集合T中选择的测试数据覆盖的路径,与当前目标路径具有较大的相关性.但是,该方法设定的差异度阈值未必是最优的,还可以通过其他的方式,设置更加合理的差异度阈值.关于这方面的内容,已经超出本文的范围.4.4性能分析对遗传算法每一代种群的进化过程分析,由于对种群中个体计算适应度时需要执行被测程序,因此,算法的时间复杂度主要由适应度函数的求解次Page8数和复杂度决定.假设种群规模为h,目标路径节点数为n,任一个体计算适应度需调用被测程序,且与被测程序的n个节点对比路径相似度,因此,传统方法计算所有个体的适应度的时间复杂度为O(h×n).在种群进化过程中,当使用本文方法生成穿越新的未覆盖目标路径的测试数据时,进化种群需要替换部分个体,此时,需额外计算集合T中测试数据所覆盖路径与目标路径的差异度,令路径差异度的计算复杂度为θ,可以得到,本文方法的最大时间复杂度为O(h×n)+T×O(θ).而集合T中测试数据穿越的路径已知,可以直接根据式(2)计算路径差异度,并不需要运行被测程序,那么,θ为常量,因此,本文方法的最大时间复杂度为O(h×n)+T×O(θ)=O(h×n).和传统方法比较,本文方法并没有增加算法的时间复杂度.算法每一代进化过程的空间复杂度主要取决于种群中所包含的个体数目,因此,传统遗传算法的空间复杂度可以表示为O(h).由图2可以看出,使用本文方法,当进化种群进行部分个体替代时,需要存储集合T中的测试数据,空间复杂度可以表示为O(h+T).但是,进化过程中,种群中的个体数目并未增加,对于替换部分个体后种群的进化过程,每一代的空间复杂度仍为O(h).极端情况下,当T中测试数据能够覆盖所有目标路径时,本文方法每一代的空间复杂度,最坏情况下为O(h+p),但很明显的是,此时已得到覆盖所有目标路径的测试数据.这也说明,T越大,越有利于降低算法的执行代数.可以看出,和传统遗传算法相比,采用本文方法并没有增加算法的时间复杂度,虽然,在种群替换过程中,需要额外的存储空间,但是,这提升了种群的性能,从而降低了进化代数,提高了遗传算法求解问题的效率.4.5算法步骤本文提出的采用遗传算法生成回归测试数据的步骤如下:(1)生成覆盖修改后被测程序目标路径的测试数据构成的集合T,同时,初始化遗传算法的运行参数.(2)判断目标路径集P={p为空,如果是,那么,算法结束;否则,选择P中下标最小的未覆盖的路径,作为当前目标路径,按照第4.2节的方法,替代进化种群的部分个体.(3)以式(7)的目标函数作为评价进化个体性能的适应度函数,如果期望的测试数据已经生成,或进化代数大于设定值,那么,将当前目标路径从P中删除,转步(2).(4)运行遗传算法,进行选择、交叉、变异操作,转步(3).5实验为了评价本文提出的回归测试数据进化生成方法的性能,选择多个基准和工业程序,作为被测程序进行实验.首先,以三角形分类程序、冒泡排序为例,说明本文方法的步骤与效果;接着,针对选择的被测程序,考察本文方法生成测试数据需要的时间、目标路径覆盖率以及已有测试数据利用率等,并与其他方法比较;然后,对上述实验结果进行分析,并回答如下4个问题:问题1.与基于路径相似度相比,基于路径差异度选择测试数据,能否更有效地利用已有的测试数据?问题2.与基于未排序的目标路径建立问题的数学模型相比,本文基于确定覆盖目标路径优先顺序建立的模型,能否提高生成测试数据效率?问题3.与其他方法相比,本文方法能否花费更少的时间达到更高的目标路径覆盖率?问题4.在不同程序的不同修改版本中,本文方法是否具有通用性?最后,选择三角形分类程序,进一步考察不同差异度阈值以及不同修改版本,对本文方法的影响.实验的硬件环境为IntelDue-Core2.0GHzCPU和2GBRAM内存.所有方法均采用VC++6.0实现.5.1实例分析本小节以三角形分类程序、冒泡排序为例,说明本文方法的步骤与效果.对三角形分类程序进行修改,三角形分类程序的2个实现版本,如图2所示,一个作为修改前程序,有4条可行路径;另一个作为修改后程序,有19条可行路径,输入分量的取值范围为[0,2047].由图2容易看出,与修改前程序相比,修改后的程序增加了11条路径.由于这2个程序的功能相同,因此,覆盖修改前程序路径的测试数据,仍能覆盖修改后程序的部分路径,这些测试数据对修改后程序路径的覆盖率为21.1%.Page9图2三角形分类程序的2个实现版本首先,按照第3.1节所述,对修改后程序的分支结点,广度优先遍历,将所有路径编码为分支节点序列条件表达式的真值,19条路径的编码如表1所列,表中,粗体显示的路径,为利用修改前程序的测试数据能够覆盖的路径.目标路径编码1111001-111001-1-1100-111100-11-1100-1-11100-1-1-1100111-1-101-11-1-101-1-1-1-10-111-1-10-1-11-1-10-1-1-1-1-10131-11-11-11-1-1-11-11-1-1-11-1-1-11-11-1-1-1-1-11-118-1-1-1-111接着,采用第3.2节的方法,得到这19条路径的优先级,并对这些路径按照优先级排序,其序号如表1的“路径序号”所列.基于排序后的路径,按照式(7)建立该程序回归测试数据生成问题的数学模型.基于该模型,将图2修改前程序的测试数据,保存在集合T中.从表1可以看出,对于第1条目标路径,集合T中包含4个测试数据.随着覆盖目标路径测试数据的不断生成,集合T包含的元素个数逐渐增加.然后,按照第4.5节的算法步骤,运行遗传算法,取交叉和变异概率分别为0.8和0.15,用于生成覆盖每个目标路径测试数据的种群最多进化5000代,种群规模为50,需要替代的个体数e=20.根据e的值和目标路径数,由式(8)可以计算出,示例程序的差异度阈值为5/6.按照第4.1节所述,在运行遗传算法过程中,从集合T中选择穿越与目标路径具有相关性路径的测试数据,替换当前种群的部分个体.最后,统计实验结果,包括已有测试数据利用的个数、时间消耗以及目标路径覆盖率.由于三角形程序简单,本小节采用进化代数衡量时间消耗.由表1可知,对于三角形分类程序,生成所有测试数据,需要的进化代数为15129代,目标路径覆盖率为84.1%,已有测试数据利用的个数平均为6.3.这说明,本文方法已有测试数据的利用率高,使得需要很少的进化代数,即可生成具有高目标路径覆盖率的测试数据.以4个数冒泡排序为例,在包含循环嵌套结构的程序中,验证本文方法的实用性.如图3所示,冒泡排序的输入分量的取值范围为[0,63],代码第5行语句由for(j=1;j<3-i;j++)修正为for(j=1;j<4-i;j++).Page10在语句6之后插桩,记录循环体每次执行,语句6的分支谓词取值,由图3容易得出,程序修改前共有3个分支结点,6条有效路径;修改后程序共有6个分支结点,24条有效路径.由于这2个程序的功能相同,因此,覆盖程序修改前路径的测试数据,仍能覆盖修改后程序的部分路径,这些测试数据对修改后程序路径的覆盖率为25%.按照三角形分类程序实例分析描述的步骤以及参数,实验结果如表2所示.需注意的是,与三角形分类程序实例不同,在4个数的冒泡排序实例中,由于目标路径的修改结点位置以及数目都相同,所以,采用第2节所述方法,目标路径的优先级相等.因而,冒泡排序实例中的目标路径顺序,是按照本文提出的路径编码方法编码后的默认顺序,但是,在该情况下,目标路径间的差异度值较小,可利用的测试数据增加.从表2可以得出,采用本文方法,已有测试数据利用的个数平均为12.4,显著高于三角形分类实例中的已有测试数据的平均利用数,同时,目标路径覆盖率达到95.8%,生成所有测试数据,需要的进化表3被测程序与实验设置被测程序三角形分类冒泡排序huffcodetcasreplaceflex实验中,对于不同的程序,进化个体采用不同的编码方式.对这些被测程序进行修改,将仍能穿越改后程序待覆盖路径的测试数据,加入到集合T.集合T覆盖6个被测程序的目标路径数分别为6、24、120、32、70以及100.算法所需参数的取值与第5.1节完全相同.对于每一被测程序,实验结果均为20次实验的平均值.目标路径编码-1-1-1-1-1-1-1-11-1-1-1-1-11-11-1-1-11-111-11-1-1-1-1-11-11-1-1-111-1-1-1-111-11-1-111-111-1111-1-1-11111-1-1111111-1-1-1-1-1131-11-1-1-11-11-11-11-11-11111-1-1-1-111-11-1-1111-1-1-1111-11-1111-1111111-1-111111-1111111代数为5532代.可以看出,在4个数的冒泡排序实例中,本文方法充分利用了已有测试数据,体现了较高的效率,这也说明本文方法对于包含循环嵌套结构的程序也是适用和高效的.5.2对比实验结果为了验证本文方法的有效性,除了三角形分类程序之外,还选用了6个数的冒泡排序程序、赫夫曼编码,flex词法分析器以及西门子工业程序集中的2个程序,上述程序广泛应用于验证不同测试方法的有效性[27-28],其基本信息如表3所列.输入范围[0,2047][0,63][0,10000][0,10000][0,128][0,128]首先,为了评价本文采用的测试数据利用准则的性能,与使用路径相似度准则[25-26]选择测试数据比较,并采用了如下指标评价不同准则的性能:(1)利用数,指在遗传算法生成测试数据过程中,分别使用路径差异度和路径相似度,作为选择测试数据的准则,生成覆盖每条目标路径的测试数据时,利用的已有测试数据的个数.Page11(2)适应值提升率,指替换当前种群的部分个体后,种群适应值变大的目标函数个数,与所有利用已有测试数据的目标函数个数的比值.(3)命中率,指通过已有测试数据生成测试数据时,能够有测试数据覆盖的目标路径数,与所有目标路径数的比值.然后,为了评价本文方法,记为PSEGA的有效性,将该方法与传统的回归测试数据生成方法(NGA)[25]、优先策略方法(PRGA)以及使用已有测试数据的方法(EGA),应用于基准和工业程序的测试,并从生成测试数据需要的时间、目标路径覆盖率以及通用性等方面进行对比.其中,NGA直接采用遗传算法,按照随机覆盖目标路径的顺序,生成测试数据;PRGA先根据本文提出的方法,确定目标路径的覆盖次序,然后,利用遗传算法,依次生成覆盖图4不同已有数据比例下,EGA与本文方法生成测试数据的目标路径覆盖率5.3实验结果分析本节对上述实验结果进行分析,并回答前面提出的4个问题.(1)对问题1的回答由表4可以得出,与使用路径相似度准则相比,采用本文的方法,可以更有效地利用已有数据.①对于每一被测程序,使用路径差异度,作为测试数据选择准则,生成覆盖目标路径的测试数据时,利用的已有测试数据均多于或等于使用路径相似度准则.②与使用路径相似度准则相比,本文方法的命表4基于路径相似度标准和路径差异度标准已有测试数据的利用情况测试对象三角形分类冒泡排序huffcodetcasreplaceflex命中率/%85.690.5100.092.692.871.3目标路径的测试数据;EGA首先随机设定目标路径的覆盖顺序;接着,求出测试数据覆盖的路径与目标路径的差异度,并筛选有用的测试数据,替换当前种群的部分个体;最后,利用更新后的种群进化生成测试数据.上述方法生成覆盖目标路径需要的时间和目标路径覆盖率,如下文5.3节表5所列,表中,某方法需要的时间越少,且目标路径的覆盖率越高,那么,该方法的性能就越优.由表5可知,本文方法和EGA是效率较高的2种,这2种方法都用了已有测试数据,替换当前种群的部分个体.最后,针对被测程序的不同修改版本,考察集合T中已有测试数据覆盖的目标路径数,与所有目标路径数的比值,对目标路径覆盖率的影响,并与EGA方法比较,结果如图4所示.中率平均提高了6.1%.这说明,与使用路径相似度准则选择测试数据相比,采用本文的方法,使用已有测试数据的效率更高.需要说明的是,采用本文的方法,选择已有的测试数据,生成覆盖目标路径的测试数据,在替换部分个体之后,种群的适应值并没有都提高.这是因为,本文方法以路径相似度,作为进化个体的适应度,而程序中存在与目标路径相关性较高,但路径相似度较低的路径.使用本文的方法,有助于选择穿越这些路径的测试数据.Page12(2)对问题2的回答由表5可以得出,与基于未排序的目标路径生成测试数据相比,基于排序后的目标路径生成测试数据,能够减少时间,并提高路径的覆盖率.①与采用未排序的NGA相比,PRGA的测试数据生成时间明显少于NGA,平均减少了18.2%的时间开销。这是因为,排序后的当前目标路径,与下一路径具有一定的相关性,使得生成覆盖当前目标路径的测试数据之后,当前种群的个体对下一目标也具有较好的适应值.在实验中,我们也发现,NGA在生成测试数据测试对象三角形分类冒泡排序huffcodetcasreplaceflex表5不同方法需要的时间和目标路径覆盖率覆盖率/%63.280.196.889.772.537.7(3)对问题3的回答由表5容易看出,本文方法能够在较短的时间内,生成具有较高目标路径覆盖率的测试数据.①与其他方法相比,对于三角形分类、冒泡排序、replace以及flex,本文方法均需要最短的时间,并取得最高的目标路径覆盖率.与传统遗传算法相比,本文方法的目标路径覆盖率平均提高了22%,消耗的时间平均降低了43%.②对于程序huffcode和tcas,与耗时最少的PRGA相比,本文方法的耗时最高多5.1s.这是因为,被测程序的控制结构简单,路径数多,而本文方法和EGA均需要对已有测试数据评价.但是,与其他方法相比,本文的方法取得了最高的目标路径覆盖率.在注重软件可靠性的回归测试中,本文方法显然更具有应用价值.这说明,在测试结构简单且路径多的程序时,需要减少已有测试数据的使用率,并优化参与进化的已有测试数据.③在较大规模的flex程序中,本文方法明显优于其他3种方法,与NGA相比,本文方法减少了70.6%的时间开销,覆盖率提高50.5%.这说明,本文方法对于较大规模的程序是适用且高效的.(4)对问题4的回答由图4可以看出,与EGA相比,针对被测程序的不同修改版本,本文方法需要较少的已有测试数据,即可达到较高的目标路径覆盖率.对于各被测程时,如果满足当前目标路径约束条件的输入域在整个输入域中占的比值较小,那么,种群将容易丢失多样性,使得生成覆盖后继目标路径的测试数据耗时较长,甚至难以生成覆盖后继目标路径的测试数据.在上述情况下,PRGA的目标路径覆盖率略高于NGA.②由表5可以得出,与未排序的EGA相比,本文方法生成测试数据需要的时间明显减少,且目标路径覆盖率平均提高了5.4%,最大提高了10.2%.这是因为,目标路径排序之后,需要先覆盖的目标路径,与已有测试数据覆盖的路径具有较高的相关度,这有助于利用已有的测试数据.序,已有测试数据覆盖目标路径的比例为50%时,本文方法能够达到95%的目标路径覆盖率;对于EGA而言,上述比例为70%时,才达到95%的目标路径覆盖率.这说明,本文方法适用于不同程序的不同修改版本.当上述比例接近100%时,这两种方法都覆盖了所有的目标路径.可以看出,对于本文建立的用于回归测试的数据生成问题模型,采用新生成的测试数据,替换当前种群的部分个体,是完全正确的.5.4参数敏感性分析为了进一步考察不同的差异度阈值、程序不同修改版本包含不同的已有测试数据比例,对本文方法的影响,选择三角形分类程序进行实验.首先,针对图2修改的程序,按照第4.1节设定的标准,列出不同差异度阈值下,生成测试数据需要的进化代数和目标路径覆盖率,如表6所列.其中,第1行数据表示遗传算法的进化种群不使用任何已有的测试数据;差异度阈值为1,表示遗传算法的进化种群使用所有已有的测试数据;其余差异度阈值下的实验结果表示,使用符合第4.1节标准的集合T的部分数据.由表6可以看出:(1)不使用已有的测试数据,遗传算法的运行代数多,且目标路径的覆盖率低;使用已有的测试数据,目标路径的覆盖率显著增加.这说明,利用已有的测试数据,本文方法能够提高测试数据生成Page13的效率.(2)当差异度阈值由0变化到1/6和2/6时,使用已有测试数据替代进化种群的个体数增加,从而降低了进化代数,提高了目标路径覆盖率;当差异度阈值由2/6变化至3/6和4/6时,已有测试数据替代进化种群的个体数没有明显增加,导致进化代数和目标路径覆盖率的差别较小;当差异度阈值由5/6变化至1时,用来替代进化种群的新个体穿越的路径与目标路径没有相关性,因此,进化代数增多,目标路径覆盖率低.差异度阈值-01/62/63/64/65/61这说明,如果集合T中可利用的已有测试数据增多,且该测试数据穿越的路径与目标路径有一定的相关性,那么,将能够提高进化种群的性能.(3)当差异度阈值为5/6或1时,进化代数的标准差较大,超过了最大进化代数.这说明,当差异度阈值较大时,本文方法的随机性也较大.这就要求,当被测程序包含的目标路径和已有测试数据均较多时,设定的差异度阈值,应保证优先选择穿越与目标路径具有较大相关性路径的测试数据.可以看出,第4.3节设定的差异度阈值是合适的,且对于三角形分类程序也是最优的.在图2修改后程序的基础上,进一步对程序修改,集合T覆盖目标路径的比例如表7所列.由表7可以看出,当集合T覆盖目标路径的比例较高(79.0%)时,在表6目标路径覆盖率较高的2种差异度阈值下,所提方法进化20代左右,就能够生成覆盖所有目标路径的测试数据.这说明,本文方法在已有测试数据比例较高时是高效的.另外,如果存在可利用的已有测试数据(21.1%~79.0%),本文方法在两种差异度阈值下,均能够获得较高的目标路径覆盖率,其中,差异度阈值为5/6时,本文方法的覆盖率最小值为92.1%,进化代数也较少.这说明,如果存在已有的测试数据,本文方法生成测试数据的效率将很高.表7不同的已有测试数据比例下,生成测试数据已有测试数据比例/%021.142.157.979.06总结本文研究生成回归测试数据,以覆盖程序维护影响路径时,测试数据进化生成问题的数学模型及其求解方法.为此,首先,通过路径的差异度和相似度,衡量不同路径的相关性;然后,基于修改节点和目标路径集合的相关矩阵,得到目标路径覆盖优先级,并基于覆盖优先级排序后的目标路径,建立覆盖被测程序目标路径的测试数据生成问题的数学模型;最后,采用遗传算法求解上述模型时,以路径相似度作为评价个体性能的适应度函数,并利用穿越与目标路径具有相关性的路径的测试数据,替换进化种群的部分个体,以提高种群的性能,从而提高测试数据生成的效率.为了验证所提方法的有效性,对多个基准和工业程序测试,并与传统回归测试数据生成方法、利用已有测试数据的测试数据生成方法等比较,最后的实验结果表明,本文方法利用已有的测试数据生成期望的测试数据时,耗时少,且目标路径覆盖率高.我们发现,不同的被测程序,包含的路径数目、输入个数以及输入类型往往有差异.如果对于不同的被测程序,采用相同的遗传算法参数设置,那么,利用遗传算法生成测试数据的效率将有很大差别.根据被测程序的特征,选择合适的遗传算法控制参数,是需要进一步研究的问题.此外,利用其他的方法选择已有的测试数据,以替换当前种群的部分个体,也将会提高测试数据生成的效率,这也是需要进一步研究的问题.致谢各位审稿专家对本文提出了宝贵评审意见,这些评审意见对提高论文水平具有很大的帮助;编辑也付出了辛勤工作.在此一并致谢!
