Page1安全协议逻辑程序不停机性快速预测的动态方法周倜1),2)李梦君1)李舟军3)1)(国防科学技术大学计算机学院长沙410073)2)(北京航天飞行控制中心软件室北京100094)3)(北京航空航天大学计算机学院北京100083)摘要基于一般逻辑程序停机性刻画的动态方法,研究了解形式不动点不停机的一种动态刻画方法,给出了安全协议Horn逻辑扩展模型解形式不动点不停机性的一个充分条件.基于这个充分条件给出了一种不动点计算不终止的预测方法,该方法能够根据新产生的解形式逻辑规则,预测不动点计算的不终止性,同时定位模型中导致解形式不动点无穷计算的解形式逻辑规则.解形式不动点不停机性的预测结果将作为选择精确验证方法或者抽象验证方法验证安全协议的基本依据.相关实验结果表明文中给出的预测算法是高效的.关键词安全协议;验证;不动点计算;不停机性;预测1引言基于逻辑程序的安全协议验证方法[1-5]能够高Page2方法不保证验证过程的停机性.例如,对于Need-ham-Schroeder共享密钥协议、Woo-Lam共享密钥单向认证协议的版本II3等,基于逻辑程序的安全协议验证方法的验证过程都不停机[5].抽象解释理论[7-10]是Cousot等人于1977年提出的构造和逼近程序不动点语义的理论,它为计算机科学中的不可判定问题和复杂问题的逼近求解提供了系统性的构造方法和有效算法.抽象解释本质上是在计算效率和计算精度之间取得均衡,以损失计算精度求得计算可行性,再通过迭代计算增强计算精度的一种逼近方法.基于抽象解释理论,文献[11]提出了一个停机的安全协议抽象验证过程,该抽象验证过程基于变种depth(k)抽象域[12]对安全协议Horn逻辑扩展模型解形式不动点进行可靠的抽象逼近(抽象不动点是解形式不动点的上界逼近).基于逻辑程序的安全协议验证方法和抽象验证方法各有利弊,一方面,基于逻辑程序的安全协议验证方法不能保证验证过程停机,但是该方法对于多数安全协议是停机的,验证过程不需要迭代精化计算;另一方面,抽象验证方法保证验证过程停机,但是它基于抽象和精化的迭代验证过程,在多次迭代计算后才能够验证安全协议正确或者构造出反例,对于解形式不动点停机的安全协议,它们的抽象验证过程也是基于抽象和精化的迭代验证过程,而且为了构造出反例,必须用未被抽象的规则再验证一次安全性质.为了充分发挥两种验证方法的优势并克服它们各自的不足,在实际验证过程中可以综合两种验证方法以提高验证效率,即对于解形式不动点停机的安全协议使用基于逻辑程序的协议验证方法,对于解形式不动点计算过程不停机的安全协议使用抽象验证方法,解形式不动点计算过程的停机性是选择验证方法的基本依据.因而,安全协议Horn逻辑扩展模型解形式不动点的停机性预测是一项重要的研究工作.本文借鉴了一般逻辑程序停机性刻画的动态方法[13],给出了安全协议Horn逻辑扩展模型[14-15]解形式不动点计算不终止的一个充分条件,根据这个条件给出了不停机性判定的一个简单有效的预测算法.一般逻辑程序停机性刻画的静态方法借助于逻辑规则原子公式中项的大小以及其它的一些静态信息刻画停机性,而动态方法借助于逻辑推导树结构中的相关动态信息刻画停机性[13].文献[13]中目标关于一般逻辑程序的推导问题采用了SLDNF-推理方法,基于广义的SLDNF-树给出了一个目标关于一般逻辑程序的推导过程停机性刻画的动态方法.本文基于解形式不动点计算过程的特点,给出了解形式不动点停机性的预测算法.与文献[13]中的停机性刻画方法相比较,本文的方法能够定位模型中导致解形式不动点无穷计算的逻辑规则,并且使得本文的停机性预测算法更加精确,也具有更高的计算效率.文献[13]中的停机性刻画的动态方法用于判定一个目标关于一般逻辑程序推导过程的停机性,本文停机性预测方法用于判定解形式不动点的停机性,解形式不动点停机性的预测结果将作为选择安全协议验证方法的基本依据.为了解决文献[16]中的一些可导致不动点计算不停机的协议的验证问题,文献[17]给出了通过静态语法检查给存在形如“…P(f(x))…→P(f(g(x)))”的规则前后件原子公式加标记的方法防止不停机情况的出现.这种方法依赖于人的主观认识,并且如果模型中没有这样的结构,则文献[17]不会做保证计算终止的处理.同时,由于在安全协议逻辑模型中存在以P(f(x))的实例为逻辑后件的规则,该规则表示协议运行时有某个主体发出了P(f(x))θ的实例所描述的动作,由该规则与形如“…P(f(x))…→P(f(g(x)))”的规则进行消解,得到以P(f(g(x))的实例为逻辑后件的规则,新规则又可与形如“…P(f(x))…→P(f(g(x)))”的规则进行消解,……这样的行为循环往复,从而造成不动点计算不终止的情况.而正则逻辑程序中产生的规则不一定会存在此种形式,所以该方法只针对安全协议的逻辑程序,对一般逻辑程序则难于用此方法消除不停机性.本文通过研究安全协议不停机的动态特性,给出了一种动态刻画方法.根据逻辑程序本身存在的不停机特征,该方法在协议验证过程中给出协议验证的不停机预测.动态预测算法独立于人的主观意识,在验证过程中动态的检测新生成的规则,对不动点计算是否停机做出一定的预测.事实上,文献[17]用静态语法检查发现的不停机性只是一种特殊情况,而本文给出的预测方法完全包含了这种特例.同时,由于本文给出的动态预测算法是独立于安全协议模型、根据不动点计算出的规则特征而进行不终止预测的,因此该预测方法不仅适用安全协议逻辑程序的不停机预测,也可用于正则逻辑程序的不停机预测,为是否选择抽象验证以及如何进行局部抽象验证提供理论依据.首先可采用文献[14-15]提出的协议验证方法进行不动点计算,每次迭代计算结束时采用本文给出不停机性预测算法进行不停机性Page3预测.如果预测不动点计算不终止,则启动文献[11]中的抽象验证算法,否则继续进行迭代计算与预测过程,直到得到验证结果或发现计算不终止的证据为止.由于本文给出的预测算法还能精确定位导致不终止计算的规则,因此还可以进行局部抽象验证[18],即只对逻辑程序中导致不动点计算不终止的规则进行抽象,而其它规则仍然按精确验证的方法进行消解.局部抽象验证可以有效地减少抽象-精化迭代的次数,节省总的验证时间.本文第2节描述安全协议Horn逻辑扩展模型;第3节描述安全性质的验证方法,它们是基于逻辑程序的安全协议验证方法中协议模型以及验证方法的变型;第4节研究协议验证过程的动态特性,并给出解形式不动点不停机性的预测算法;第5节采用不停机性预测算法,对典型安全协议Horn逻辑扩展模型解形式不动点的停机性进行预测,实验结果表明预测算法的有效性;第6节对本文内容进行小结,阐述进一步的研究工作.2安全协议基于Horn逻辑的扩展模型安全协议基于Horn逻辑扩展模型的语法描述如表1所示.在Horn逻辑扩展模型语法中,如果原子公式attacker(role(〈M,N,tag〉,M))、begin(M,M)、end(M,M)中的项M中没有变量,则称它们为闭原子公式.原子公式begin(M,M)和end(M,M)是对应性断言序偶,用于描述认证性,其中M是对应性断言标识符.严格按照协议描述进行消息交换和消息处理的角色称为诚实角色,除了安全协议攻击者之外的所有角色都是诚实角色;安全协议攻击者在安全协议形式化分析中扮演两种角色:其一是诚实角色,其二是攻击者角色,扮演攻击者角色表达式tag∷=0,1,2,…M,N,U,V,S,T∷=x,y,za[M1,…,Mn]f(M1,…,Mn)F,C,A∷=attacker(role(〈M,N,tag〉,M))attacker谓词begin(M,M)End(M,M)R,R∷=F1∧…∧Fn→F时进行消息处理和消息交换的行为由Dolev-Yao模型刻画.2.1安全协议诚实角色模型对应于安全协议描述中每一个诚实角色A的每一个消息发送动作,假设发送的消息为M,则生成一条逻辑规则:attacker(role(〈M1,A,k〉,M1))∧…∧attacker(role(〈Mn,A,k〉,Mn))→attacker(role(〈A,N,k〉,M));其中,根据安全协议描述的上下文,A认为消息M的接收者为N(理想接收者),M1,…,Mn是A在发送消息M之前应该依次接收到的消息序列,并且根据安全协议描述的上下文,A认为消息Mi(i=1,2,…,n)的发送者(理想发送者)为Mi.安全协议描述中A生成的每一个新鲜值(nonce)和新鲜加密密钥(freshencryptionkey)都被Skolem化为一个同名的Skolem函数,Skolem函数的参数包括:一个会话标识符变量,A生成新鲜值或新鲜加密密钥之前应该依次接收到的消息序列,k表示该规则是加入到诚实角色模型中的第k条规则.在诚实角色模型中,逻辑规则前件中形如attacker(role(〈M,N,tag〉,M))的原子公式中tag的取值均为大于0的整数,以方便定位基于Horn逻辑扩展模型中导致解形式不动点计算过程出现无穷计算的逻辑规则.2.2安全协议攻击者模型攻击者进行消息处理和消息交换的行为由Dolev-Yao模型刻画,描述为以下的一组逻辑规则:(1)设S表示安全协议的公共知识集合,对每一个M∈S,生成如下的一条逻辑规则:→attacker(role(〈host(kI[]),host(v),n〉,M));它表示的含义是:攻击者能够向任何参与者发送属于公共知识集合的消息M.(2)攻击者具有生成新鲜值的能力,用下面的一条逻辑规则刻画:→attacker(role(〈host(kI[]),host(v),n〉,NI[i]));攻击者生成的新鲜值被Skolem化为Skolem函数NI[i],其中i是自然数集合上的变量,上述逻辑规则的含义是:攻击者能够生成无穷多个新鲜值,并能向任何参与者发送生成的新鲜值.(3)对于安全协议中的每一个构造算子f,攻击者具有使用f构造新消息的能力,用下面的逻辑规则刻画:attacker(role(〈host(v1),host(kI[]),n〉,x1))∧…∧attacker(role(〈host(vn),host(kI[]),n〉,xn))→attacker(role(〈host(kI[]),host(v),n〉,f(x1,…,Page4xn)));构造算子包括消息组合算子和加密算子等.上述逻辑规则的含义是:攻击者能够利用接收到的消息构造新的消息,并能够向任何参与者发送构造的新消息.(4)对于安全协议中的每一个析构算子g和g的每一个消减式g(M1,…,Mn)=M,攻击者具有使用g析构消息的能力,用下面的一条逻辑规则刻画:attacker(role(〈host(v1),host(kI[]),n〉,M1))∧…∧attacker(role(〈host(vn),host(kI[]),n〉,Mn))→attacker(role(〈host(kI[]),host(v),n〉,M));析构算子包括消息分解算子和解密算子等.上述逻辑规则的含义是:攻击者能够析构接收到的消息,得到新消息,并能够向任何参与者发送析构得到的新消息.在攻击者模型中,tag取值为n表示逻辑规则是Horn逻辑扩展模型中的第n条逻辑规则.描述保密性时,扩展模型中不出现原子公式begin(M,M)和end(M,M);描述认证性时,begin(M,M)只出现在逻辑规则的逻辑前件中,end(M,M)只出现在逻辑规则的逻辑后件中.2.3安全性质描述和R2=H2attacker(role(〈M1,N1,tag1〉,M1)),C2=attacker(role(〈M2,N2,tag2〉,M2)),或者C1=end(M,M1),C2=end(M,M2),则R1逻辑蕴涵R2,记作R1R2,当且仅当:存在置换θ使得M1θ=M2,并且对每一个H11,…,H1m},存在H2{H1j〉,Mj))∈{H21,…,H2n},对每一个H1tag2Mi)∈{M11,…,H2n},使得Miθ=Mj.{H2定义2(逻辑可推导).设F是一个闭原子公式,B是一组逻辑规则,F关于B逻辑可推导当且仅当存在满足以下条件的一棵有限树:(1)除了根结点外,每一个结点均用B中的一条逻辑规则标记,并且每一条边均用一个闭原子公式标记;定义1(逻辑蕴涵).设R1=H1(2)若树中的一个结点用R标记,结点的入边用闭原子公式F0标记,n条出边分别用闭原子公式F1,…,Fn标记,则RF1∧…∧Fn→F0;(3)根结点有唯一一条出边并且用闭原子公式F标记;满足上述条件的有限树称为F关于B的逻辑可推导树.定义3(保密性).设P是安全协议Horn逻辑扩展模型,F=attacker(role(〈M,N,tag〉,M))是一个闭原子公式,如果F关于P逻辑不可推导,则称安全协议关于M满足保密性.认证性用对应性断言begin(M,M)和end(M,M)刻画,令Bb={→begin(M1,M1),…,→begin(Mn,Mn)}.定义4(认证性).设P是安全协议Horn逻辑扩展模型,begin(M,M)和end(M,M)是刻画认证性的对应性断言序偶,end(M,M)是一个闭原子公式,如果end(M,M)关于P∪Bb逻辑可推导,那么begin(M,M)∈Bb,称安全协议关于begin(M,M)和end(M,M)满足认证性.3安全协议验证方法定义5(消解).设R=H→F和R=H→F是两条逻辑规则,如果F=attacker(role(〈M1,N1,tag1〉,M1))(或F=end(M1,M1)),并且H中存在原子公式F0=attacker(role(〈M2,N2,tag2〉,M2))(或F0=end(M1,M2)),使得M1能够与M2进行合一化,则R与R的消解记作R·R,定义为(H∧(H-F0))θ→Fθ,其中θ=mgu(M1,M2)是M1和M2的最一般合一化算子.定义6(目标).逻辑规则前件中形如attacker(role(〈M,N,tag〉,x))(x是任意一个变量)和begin(M,M)的原子公式称为假目标,形如attacker(role(〈M,N,tag〉,M))(M不是变量)和end(M,M)的原子公式称为目标.定义7(解形式逻辑规则).设H→C是一个逻辑规则,如果H中的原子公式都是假目标,则称H→C是解形式逻辑规则.用SolvedForm表示解形式逻辑规则集合,用UnSolvedForm表示非解形式逻辑规则集合.定义8(X-消解).设R=H→F和R=H→F是两条逻辑规则,R∈SolvedForm,R∈UnSolvedForm,F=attacker(role(〈M1,N1,tag1〉,M1)),F0=attacker(role(〈M2,N2,tag2〉,M2))是H中满足M1能够与M2进行合一化的目标,则R与R的X-消解记作RR,定义为(H∧(H-F0))θ→Fθ,其中θ=mgu(M1,M2).Page5设R表示一个逻辑规则,B表示一个逻辑规则Rule0(P)∩UnSolvedForm;R∈T0(P),R∈C0(P)};Rulen(P));集合,定义addRule(R,B)如下:IfR∈B,RR,thenaddRule(R,B)=B;elseaddRule(R,B)={R}∪{R|R∈B,R/R}∪{marked(R)|R∈B,RR}并且定义addRule({R1,…,Rn},B)=addRule({R2,…,Rn},addRule(R1,B)).上述定义中,marked(R)表示逻辑规则R不再参与X-消解计算,本文用Marked表示不再参与X-消解计算的逻辑规则的集合,UnMarked表示不属于Marked的逻辑规则的集合.设R=F1∧…∧Fn→C,Fi=attacker(role(〈Mi,Ni,tagi〉,Mi))(i=1,…,n),定义elimdup(R)为满足以下条件的逻辑规则R:(1)如果对任意的j<i,Mj≠Mi,则Fi是R逻辑前件中的一个原子公式;(2)C是R的逻辑后件.设P是安全协议Horn逻辑扩展模型,归纳定义:Rule0(P)={elimdup(R)|R∈P};T0(P)=Rule0(P)∩SolvedFormC0(P)=X_Resolution1(P)={elimdup(R)|R=RR,Rulen+1(P)=addRule(X_Resolutionn+1(P),Tn+1(P)=Rulen+1(P)∩SolvedForm;Cn+1(P)=Rulen+1(P)∩UnSolvedForm;X_Resolutionn+1(P)={elimdup(R)|R=RR,R∈Tn(P),R∈Cn(P)}.定义9(解形式不动点).设P是安全协议Horn逻辑扩展模型,定义fixpoint(P)=∪{Tn(P)|n0}∩UnMarked,fixpoint(P)称为P的解形式不动点.设P是安全协议Horn逻辑扩展模型,R是一个逻辑规则,B是一个逻辑规则集合,对于保密性,定义derivablerec(R,B,P)如下:ifR∈B,RR,thenderivablerec(R,B,P)=elseifR=→C,thenderivablerec(R,B,P)={→C}elsederivablerec(R,B,P)={derivablerec(elim-dup(R·R),{R}∪B,P)|R∈fixpoint(P)}.对于认证性,定义derivablerec(R,B,P)如下:ifR∈B,RR,thenderivablerec(R,B,P)=elseifR=begin(M1,M1)∧…∧begin(Mn,Mn)→end(M,M),thenderivablerec(R,B,P)={R}elsederivablerec(R,B,P)=∪{derivablerec(elim-dup(R·R),{R}∪B,P)|R∈fixpoint(P)}.对于形如attacker(role(〈M,N,tag〉,M))和end(M,M)的闭原子公式F,定义derivable(F,P)=derivablerec(F→F,,P).定理1[15].设P是安全协议Horn逻辑扩展模型,F是一个闭原子公式,则derivable(F,P)的计算过程停机.定理2[15].设P是安全协议Horn逻辑扩展模型,则①保密性:若F是形如attacker(role(〈M,N,tag〉,M))的闭原子公式,则F关于fixpoint(P)逻辑可推导当且仅当→F∈derivable(F,P).②认证性:设F是形如end(M,M)的闭原子公式,F关于fixpoint(P)∪Bb逻辑可推导,begin(M,M)∈Bb当且仅当:存在H1∧…∧Hn→F∈deriv-able(F,P),其中Hi∈Bb均为形如begin(Mi,Mi)的原子公式,并且begin(M,M)∈{H1,…,Hn}.4不停机性的动态预测设P是安全协议Horn逻辑扩展模型,由定理1可知,只要P的解形式不动点的计算过程停机,则安全协议的验证过程一定停机,下面将给出安全协议逻辑模型中解形式不动点计算过程的不停机性预测方法.安全协议Horn逻辑扩展模型中的逻辑规则数目是有穷的,解形式不动点计算不停机的原因在于安全协议逻辑程序模型中的一些逻辑规则被无穷次地应用于计算X-消解.设A和B是两个原子公式,如果删除A中增加的函数符号、名和变量,原子公式A就是原子公式B或B的变量换名,则称A是B的递归增加.一条逻辑规则被无穷次地应用于计算X-消解,由最一般合一化算法可知,将表现为逻辑规则中一些原子公式的变量换名在解形式不动点中无穷次地出现,或者一些原子公式在解形式不动点中无穷次地递归增加[13].解形式不动点中的规则都是解形式逻辑规则,解形式逻辑规则逻辑前件中的原子公式都是形如attacker(role(〈M,N,tag〉,x))(x是任意一个变量)和begin(M,M)的简单原子公式,因而解形式不动点不停机将表现为:安全协议Horn逻辑扩展模型中的一些逻辑规则的逻辑后件的变量换名在解形式不动点中无穷次地出现,或者这些逻辑规则的逻辑后件在解形式不动点中无穷次地递归增加.Page6定义10(符号字符串).设T是一个项(或是形如attacker(role(〈M,N,tag〉,M))的原子公式),则T的字符串S是T(或M)中的函数符号、名、变量按照从左到右的顺序连接在一起构成的字符串,T的符号字符串ST是将S中的所有变量全部用新符号χ替换后得到的字符串.符号字符串按照从左到右的顺序依次抽取出原子公式中的函数符号、名和变量,并将变量用新符号χ替换.例如,对于原子公式attacker(role(〈host(kSS[]),host(kBS[]),n〉,encrypt(2tuple(host(kAS[]),2tuple(host(kAS[]),2tuple(host(kAS[]),v6))),kBS[]))),它的符号字符串为encrypt·2tuple·host·kAS·2tuple·host·kAS·2tuple·host·kAS·χ·kBS,其中“·”表示字符串的连接.定义11(投影).设ST1和ST2是两个符号字符串,如果ST1是将字符串ST2中的0个或多个符号删除得到的字符串,则称ST1是ST2的投影,记作ST1projST2.投影关系用于刻画一个原子公式A是原子公式B的变量换名,或者原子公式A是原子公式B的递归增加.例如,原子公式attacker(role(〈host(kSS[]),host(kBS[]),13〉,encrypt(2tuple(host(kAS[]),2tuple(host(kAS[]),v6)),kBS[])))的符号字符串是attacker(role(〈host(kSS[]),host(kBS[]),13〉,encrypt(2tuple(host(kAS[]),2tuple(host(kAS[]),2tuple(host(kAS[]),v6))),kBS[]))))的符号字符串的投影.定义12(循环到).设A1=attacker(role(〈M1,N1,tag1〉,M1))和A2=attacker(role(〈M2,N2,tag2〉,M2))是两个原子公式,如果SA1projSA2并且tag1=tag2,则称A1循环到A2,记作A1loopA2.与文献[13]中的定义不同,本文中循环到的定义增加了约束条件tag1=tag2,tag1=tag2约束原子公式A1和A2必须是安全协议Horn逻辑扩展模型中同一个逻辑规则的逻辑后件的不同实例.定义13(规则的长幼关系).若规则Ri=Hi→Fi(i=1,2,3)满足R3=R1R2,则R1,R2与R3之间具有长幼关系R1R3,R2R3,在不引起歧义时可写作F1F3,F2F3.用c表示的传递闭包.定义14(循环目标).设Hj→Aj,Hi→Ai均为解形式规则,如果AicAj且AiloopAj,则称Aj是Ai的循环目标.引理1[13].设{Ai}i=1是有穷字母表∑上字符串的一个无穷序列,则存在一个无穷的递增整数序列{ni}i=1,使得对于任意的i,均有AniprojAni+1.定理3.n∈N,Rulen(P)为有限集.证明.用归纳法证明.(1)当n=0时,因为安全协议的逻辑程序模型P是有限集,所以Rule0(P)={elimdup(R)|R∈P}是有限集,所以当n=0时,结论成立.(2)假设当n=k时结论成立.当n=k+1时,由归纳假设,Rulek(P)是有限集,所以其子集Tk(P),Ck(P)均为有限集,则由两个有限集进行X-消解得到的新规则集X_Resolutionk+1(P)={elimdup(R)|R=RR,R∈Tk(P),R∈Ck(P)}为有限集,所以Rulek+1(P)=addRule(X_Resolutionk+1(P),Rulek(P))为有限集.综上所述,n∈N,Rulen(P)为有限集.证毕.定理4.设P是一个安全协议的逻辑程序模型,如果存在无穷解形式逻辑规则序列H1→A1,…,Hg1→Ag1,…,Hg2→Ag2,…,Hgi→Agi,…,Hgi+1→Agi+1,…,其中Agi+1是Agi(i=1,2,…)的循环目标,则P的解形式不动点计算不终止.证明.假设P的解形式不动点计算终止,则m∈N,使得Tm(P)=Tm+1(P),Cm(P)=Cm+1(P).则n∈N且n>m,Rulen(P)=Rulem(P).又由定理3知,Rulen为有限集.所以∪{Rulen(P)|n0}=∪m与题设中存在无穷解形式逻辑规则序列矛盾.所以假设不成立,即必有P的解形式不动点计算不终止.定理4给出了不动点计算不终止的一个充分条件,该条件表明安全协议Horn逻辑扩展模型解形式不动点计算过程的不停机性可以刻画为:存在无穷选择序列A1,…,Ag1,…,Ag2,…,Agi,…,Agi+1,…,使得对于任意的i1,Agi+1是Agi的循环目标.检测满足上述条件的无穷选择序列是不现实的,为了可在计算机中实现,可以采用近似的思想:选定一个正整数k作为阈值,检测安全协议逻辑程序解形式不动点的计算过程中是否存在选择序列A1,…,Ag1,…,Ag2,…,Agk,使得对于任意的i(1ik),Agi+1是Agi的循环目标.将满足上述条件的选择序列称为不停机条件.如果满足不停机条件,则预测安全协议Horn逻辑扩展模型解形式不动点的计算过程不停机,否则预测解形式不动点的计算过程停机.显然,k值越大,预测的准确度越高,需要的时空代价越高;反之,预测速度越快,预测的准确度越低.如果满足上述条件Page7的选择序列中原子公式的tag项的取值均为n0,则预测安全协议Horn逻辑扩展模型中第n0条逻辑规则是导致解形式不动点无穷计算的逻辑规则.此时也可针对标号为n0的规则进行局部抽象验证,这样可以更加逼近精确模型,减少抽象-精化迭代的次数,从而降低验证一个协议所需花费的总的时间开销.5实验采用本文提出的不停机性预测算法,选取阈值Needham-Schroeder共享密钥协议表2协议验证的预测结果不停机表2中的总时间是指解形式不动点计算、安全性质检测、反例构造等阶段的全部时间开销.需要说明的是,公钥Kerberos协议认证服务阶段的验证过程是终止的,但是在构造反例时,由于derivable函数的可选择性多,造成了组合爆炸,完成反例构造需要的时间过长,因此表中不能给出总时间.Needham-Schroeder共享密钥协议、Woo-Lam认证协议版本II3以及AndrewsecureRPC协议的解形式不动点被预测为不停机,实验中预测计算花费的时间非常少,以至于计算机近似认为时间为0s.其它安全协议的解形式不动点被预测为停机,由于停机的协议在达到不动点时才停止预测,因此预测所检测的规则数比不停机的协议要多得多,所以SPVT能计算出预测时间.从表中可以看出,验证一个协议的总时间开销比预测时间多得多,所有协议的停机性预测花费的时间基本上可以忽略不计.上述实验结果表明:安全协议的逻辑模型的解形式不动点计算过程的停机性在选取阈值k=3时,使用本文的不停机性预测算法得到的判定结果都是正确的,从而表明停机性预测算法的实用性.下面以Needham-Schroeder共享密钥协议(简称为NS协议)为例,说明不停机性预测算法的具体应用.NS协议的形式化描述如下:k=3,基于安全协议验证工具SPVT,在Intel(R)Pentium(R)D2.66GHzCPU和1GB内存的PC机上,对典型安全协议的Horn逻辑扩展模型解形式不动点的停机性进行了预测.实验过程在计算安全协议逻辑程序解形式不动点的同时检测不停机条件是否满足,如果不停机条件得到满足,则预测解形式不动点不停机,如果不停机条件不满足,则继续迭代计算解形式不动点,直到完全计算出解形式不动点,或者预测解形式不动点不停机.表2列出了采用预测算法帮助协议验证的实验结果.不停机不停机(1)A→S:A,B,Na;(2)S→A:{Na,B,Kab,{Kab,A}Kbs}Kas;(3)A→B:{Kab,A}Kbs;(4)B→A:{Nb}Kab;(5)A→B:{Nb-1}Kab.由于消息(4)、(5)会导致消解过程中不断出现形如{Nb-1-…-1}Kab的消息,从而造成不动点计算不终止.在NS协议的逻辑程序的不动点计算过程中,SPVT产生了如下逻辑程序规则:规则4.〈Ready〉:Begin(Aparam[(host(key(kas())),s1)])∧Attacker(LKerb(host(key(kss())),host(key(kas())),“4”,encrypt((Na(s1),host(key(kbs())),x4,YM),key(kas()))))∧Attacker(LKerb(host(key(kbs())),host(key(kas())),“4”,encrypt(x3,x4)))→Attacker(LK-erb(host(key(kas())),host(key(kbs())),“4”,encrypt(minus(x3),x4))).规则37.〈Ready〉:Begin(Aparam[(host(key(kas())),z16)])∧Attacker(LKerb(host(key(kbs())),host(key(kas())),“4”,encrypt(z7,Akey((host(key(kas())),host(key(kbs())),Na(z16)),z2))))→Attacker(LKerb(host(key(kas())),host(key(kbs())),“4”,encrypt(minus(z7),Akey((hostPage8(key(kas())),host(key(kbs())),Na(z16)),z2)))).规则43.〈Solved〉:Begin(Aparam[(host(key(kas())),z16)])→Attacker(LKerb(host(key(kas())),host(key(kbs())),“4”,encrypt(minus(Nb(encrypt((Akey((host(key(kas())),host(key(kbs())),Na(z16)),z2),host(key(kas()))),key(kbs())),z6)),Akey((host(key(kas())),host(key(kbs())),Na(z16)),z2)))).规则45.〈Solved〉:Begin(Aparam[(host(key(kas())),z16)])→Attacker(LKerb(host(key(kas())),host(key(kbs())),“4”,encrypt(minus(minus(Nb(encrypt((Akey((host(key(kas())),host(key(kbs())),Na(z16)),z2),host(key(kas()))),key(kbs())),z6))),Akey((host(key(kas())),host(key(kbs())),Na(z16)),z2)))).规则46.〈Solved〉:Begin(Aparam,(host(key(kas())),z16))→Attacker(LKerb(host(key(kas())),host(key(kbs())),“4”,encrypt(minus(minus(minus(Nb(encrypt((Akey((host(key(kas())),host(key(kbs())),Na(z16)),z2),host(key(kas())))key(kbs())),z6)))),Akey((host(key(kas())),host(key(kbs())),Na(z16)),z2)))).规则4是安全协议模型中的初始规则,描述的是协议中的第(5)条消息,即Alice将收到的Nb-1再发给Bob.随着不动点计算的进行,规则4逐步消除前件中的目标而变成规则37.非解形式规则37与解形式规则43进行X-消解得到解形式逻辑规则45,规则45继续与规则37进行X-消解得到解形式规则46.而规则46的逻辑后件是规则45的逻辑后件的循环目标,规则45的逻辑后件是规则43的逻辑后件的循环目标.事实上,规则37还能继续和规则46进行X-消解生成新的解形式逻辑规则,且新规则的逻辑后件是规则46的逻辑后件的循环目标.这个过程会一直进行下去而不断地生成新的解形式规则.事实上,这些规则的逻辑后件都是规则4的逻辑后件的具体实例.根据本文的预测算法,NS协议的解形式不动点的计算过程不停机,并且标记为4的第4条逻辑规则是模型中导致解形式不动点计算过程不停机的逻辑规则.6结束语借鉴文献[13]中一般逻辑程序停机性刻画的动态方法,本文给出了安全协议Horn逻辑扩展模型解形式不动点计算不停机性的预测算法,该算法为验证工具自动选择精确验证或抽象验证提供了依据.停机性算法同时能定位模型中导致解形式不动点无穷计算的逻辑规则,在这种精确定位的帮助下,可对协议进行局部抽象验证,即只对造成不停机原因的规则进行抽象,而其他规则不进行抽象.局部抽象验证模型更接近精确模型,因而可以有效地减少抽象-精化迭代的次数.相关实验结果表明了本文提出的预测算法是实用、高效的.进一步的研究工作包括:继续深入研究安全协议Horn逻辑扩展模型解形式不动点停机性的动态刻画方法,最终给出不动点计算不终止的充要条件;研究反例构造的启发式算法,尽量减少组合爆炸;对实用安全协议(如Kerberos协议等)进行验证.
