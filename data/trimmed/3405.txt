Page1运行时异常对软件静态测试的影响研究金大海宫云战杨朝红肖庆(北京邮电大学网络与交换技术国家重点实验室北京100876)摘要当程序的执行过程中出现运行时异常,控制流动态地变更可能会产生非预期的执行逻辑,由此引入的缺陷将给软件静态测试工作带来巨大的挑战.针对这一问题,提出一种结合运行时异常的静态测试方法,将缺陷检测及控制流扩展交替执行,通过扩展分析路径达到提高测试充分度的目的.以异常模式状态机描述运行时异常行为,在包含运行时异常的控制流上,应用迭代方程得到运行时异常控制流序列,将在传统控制流上的一次缺陷检测过程扩展为在异常控制流序列上的多次检测.实验结果表明,结合运行时异常的静态测试方法虽然增加了时间开销,且引入一定的误报,但却可以发现传统测试方法所遗漏的缺陷,这点在航空、航天等高可信领域尤为重要.关键词软件测试;静态分析;运行时异常;异常模式;异常控制流1引言与传统的软件测试方法不同,面向代码缺陷的静态测试技术首先从软件的代码层面上总结缺陷,将其抽象成相应的缺陷模式,然后对程序中相关表达式的取值进行近似计算,最后将计算结果应用于缺陷检测.自2000年以来,面向代码缺陷的软件静Page2态测试技术[1-5]正逐渐受到软件业界的青睐,已成为美国等一些国家的一种主流的软件测试技术.目前具有代表性的代码缺陷检测工具主要有Coverity①,CodeSonar②,FindBugs③,K8④和Fortify⑤等等,对比检测工具的测试结果表明,现有工具均存在不同程度的误报及漏报情况.为了能够处理一些非预期的情况,Java语言提高对两类异常的支持:检查型异常和运行时异常.编译器强制要求对检查型异常进行处理,而对运行时异常却难以限制.当运行时异常发生后,系统会按照方法调用关系的逆序逐级上抛,直到相应异常被捕获,否则终止程序或线程.运行时异常的影响对于被终止的程序或线程是明显的,但若在上抛过程中被捕获到,程序或线程并不会终止,但可能会影响其正常执行逻辑,由此造成难以检测及定位的错误.由于异常处理机制的引入,使程序的控制流变得更为复杂,给静态分析及测试工作带来更大的挑战.目前许多专家学者虽然就此进行研究,但对于“当一个运行时异常发生后,它是否会导致其它新的运行时异常?这些运行时异常对静态测试结果产生哪些影响?”等问题却是难以回答.目前所有的代码缺陷检测技术及工具均没有考虑到该问题,由此引起的路径分析不充分是导致缺陷漏报的主要原因之一.因此,本文就运行时异常对Java程序静态测试的影响进行进一步研究.2问题描述面向代码缺陷的静态测试技术从理论上可描述为对问题D={P,M,A}的求解,这里P代表被测程序;M是与P对应的代码缺陷模式集合;A是缺陷检测算法,用于计算P中相关表达式的取值信息.算法描述为A={S,ρ(L,X),σ(F)},其中S为程序P中的路径;ρ为近似地计算相关变量X的取值信息,L为P的执行位置,X为P执行到L处的相关变量;σ为方法的摘要信息,近似地表示对P中被调用方法F的抽象.由于运行时异常的引入,将受其影响的控制流路径S扩展为S1,而在S1上又可能发生新的运行时异常,经过如此迭代过程后,可得到一个路径集合[S1,…,Sn],其中Si是由Si-1上发现的新运行时异常扩展而成,且Si-1Si,由此对A的描述转化为A={S∪[S1,…,Sn],ρ(L,X),σ(F)}.在静态测试过程中,如果忽略了对运行时异常的处理,即在A中遗漏了分析路径[S1,…,Sn],则会有{ρ(L,X)|S}{ρ(L,X)|S∪[S1,…,Sn]},由此会导致缺陷漏报情况的出现,即x,x∈{ρ(L,X)|S}∧D(P,M,A)x,x∈{ρ(L,X)|S∪[S1,…,Sn]}∧D(P,M,A其中D(P,M,A)表示由于变量X的取值x引起M,D(P,M,A)表示变量X的取值x不会引起M,FN(X)表示对变量X的漏报.以下Java代码片段包括三级方法调用,f3调用f2,f2调用f1.如果不考虑运行时异常的影响,现有测试方法可以很容易地检测到第7行p的空指针异常(尽管它可以被捕获到).但除此之外还存在其它的问题吗?结合运行时异常对路径的影响后,答案显然是否定的,实际结果应为(1)如果第5行的条件为真,则程序执行到第7行时会抛出一个空指针异常,且它在第9行被捕获.(2)第3行的q初始值为空,当出现结果1的情况时,会略过第8行对q的资源分配操作而执行第9行的异常捕获,这样会在第10行触发q的空指针异常,且由于未被捕获而抛出f1.(3)当出现结果2中的情况时,会在第10行抛出空指针异常,则原本在第11行释放资源r的操作被略过,造成对r的资源泄漏.(4)当出现结果2中的情况时,第17行的f1会抛出空指针异常,由于此异常不能被18行捕获,从而造成16行对q分配的资源泄漏.(5)由于在27行捕获了所有类型的异常,使运行时异常不能传播到程序入口而终止线程过进程,因此以上问题会隐藏起来,难以检测及定位.classtest{1.FileInputStreamp,r;2.voidf1()throwsIOException{3.FileInputStreamq=null;4.try{5.if(p==null)6.System.out.println("null!");7.p.mark(0);8.q=newFileInputStream("output");9.}catch(NullPointerExceptione){}10.q.close();11.r.close();①②③④⑤Page312.}13.voidf2()throwsIOException{14.FileInputStreamq=null;15.try{16.q=newFileInputStream("input");17.f1();18.}catch(IOExceptione){19.q.close();20.return;21.}22.q.close();23.}24.voidf3(){25.try{26.f2();27.}catch(Exceptione){}28.}}3运行时异常描述及检测3.1异常描述问题D={P,M,A}中的缺陷模式M是求解D的基础,如何将运行时异常特征包含于M之中是首先需要解决的问题,本文采用异常模式状态机对其进行统一描述如下.定义1.异常模式状态机定义为一个三元组EM=〈N,T,C〉.N为状态集合,包括一个异常模式中所有可能达到的状态,N={Nstart,Nexception,Nend}∪Nother.T={〈ni,nj〉|ni,nj∈N}是状态转换集合,表示状态机可以从状态ni转换到状态nj.C是状态转换条件,T:N×C→N.由于运行时异常的发生模式多种多样,所以不同类型的异常由不同的异常模式状态机来描述,但所有异常模式状态机间的共有状态有{Nstart,Nexception,Nend}.Nstart是状态机的唯一入口,Nend是状态机的唯一出口,Nexception代表发生运行时异常的状态.Nother表示除以上3种状态之外的其它状态,随异常类型的不同而不同.在给定某种异常模式状态机的所有状态后,状态间的转换集合T及其对应的转换条件C需要手工设定.图1是一个空指针异常模式状态机,除了共有的状态Nstart、Nend和Nexception外,还具有代表非空的状态Nnot和代表可能为空的状态Nmay.经人工分析,与空指针异常相关的状态转换条件有C1(确定对象可能空),C2(确定对象非空),C3(引用对象内容),C4(超出对象作用域),C5(自动转换),C6(其它),与其相关的状态转换集合为T1:Nstart×C6→Nstart,T2:Nstart×C1→Nmay,T3:Nstart×C2→Nnot,T4:Nmay×C6→Nmay,T5:Nmay×C3→Nexception,T6:Nmay×C4→Nend,T7:Nmay×C2→Nnot,T8:Nnot×C6→Nnot,T9:Nnot×C4→Nend,T10:Nnot×C1→Nmay,T11:Nexception×C5→Nend.对于其它类型的异常模式描述,是一个与上述空指针异常模式类似的手工生成过程:首先确定异常相关状态,然后分析所有状态间的转换条件,最后生成不同状态间的转换集合.在异常模式状态机上进行状态转换时,需要结合具体变量X的取值信息ρ(L,X)及状态转换条件C来完成,下面给出状态机实例的概念.定义2.针对变量X创建的异常模式状态机EM称为对应X的异常模式状态机实例EM(X).EM(X)上的实际状态转换为ni={nj×C|ρ(L,X)},结合具体变量X在位置L处的取值信息,通过状态转换条件C可将EM(X)的当前状态nj转换为状态ni.对独立变量X的异常模式状态机实例描述为EM(X),对程序P所对应的异常模式状态机实例可做如下描述.定义3.假设程序P包括n种既定的运行时异常模式{EM1,EM2,…,EMn},受P中的相关变量X影响,每种异常模式EMi最多对应m种异常模式状态机实例{EMi(X1),EMi(X2),…,EMi(Xm)},则程序P对应的所有异常模式状态机实例构成P的异常模式状态机实例矩阵,记作(EMij)n×m=EMi(Xj)=表示变量Xj与异常模式EMi无关,不需要为Xj创建该类状态机实例.对于(EMij)n×mPage4中所有非空状态机实例,表示需要为程序P中的变量Xj创建异常模式状态机实例.在所有非空的状态机实例中,相同的状态为{Nstart,Nexception,Nend},至于其它的中间状态Nother和状态转换条件C随EMi的不同而各异.3.2异常检测有了以上对运行时异常进行描述的方法后,可以为程序中与特定异常模式EM相关的变量X创建异常模式状态机实例EM(X),应用缺陷检测算法A={S,ρ(L,X),σ(F)},结合与X相关的取值信息及状态转换条件实现状态转换.当EM(X)中出现异常状态Nexception时,表示在位置L处可能发生运行时异常.ρ(L,X)的计算原理是以传统的数据流迭代方程为基础,在遍历控制流每一个节点的过程中,计算相关变量的取值信息.这个过程的详细信息可参考文献[6-8],这里仅以Java代码片段中4~8行为例,简单描述对运行时异常的检测过程.为p创建空指针异常模式状态机实例后,异常检测过程如图2所示.其中控制流节点序号对应代码片段中的行号,unknow表示对象取值未知,all表示对象取值为空或非空,null表示对象取值为空.应用p的取值信息及状态转换条件,异常模式状态机实例EM(p)的状态从控制流节点4上的Nstart状态逐步转换到控制流节点8上的Nend状态,且在节点7上发现异常状态Nexception.图2异常模式状态机实例在f1片段上的状态转换以上过程表明控制流节点7所对应的语句可抛出空指针异常,即为可抛出运行时异常的语句;若该运行时异常不能被当前方法所捕获,则当前方法为可抛出运行时异常的方法.由于第2节程序中第7行抛出的运行时异常会在第9行被捕获,因此方法f1在此处不能抛出该异常.但在第7行异常触发的条件下,第10行也会抛出空指针异常,而该异常不会被f1捕获,由此f1为可抛出运行时异常的方法.为了能够准确应用运行时异常信息,定义异常定义4.异常向量用于描述在静态测试过程中检测到的运行时异常,包括运行时异常发生的位置P及对应的异常类型T,表示为犜犘.向量的模|犜犘|表示异常相关变量的当前取值信息.应用异常向量,通过异常模式状态机实例及缺陷检测算法检测发现运行时异常的过程可描述为EM(X)A(X)→犜犘,其中向量的位置P由算法A(X)中的L确定,向量的类型T与EM(X)相关,向量的模|犜犘|与ρ(L,X)相关.当运行时异常被触发后,若方法F内的控制结构可以捕获到,则该异常不会传播出方法;否则该异常会被抛出方法F,所有此类异常构成方法可抛出的异常向量,记作犉=∪犜犘.4运行时异常控制流4.1与传统控制流的区别传统方法在构建程序控制流时,除了包含显式抛出异常的语句和方法外,也包含隐式抛出异常的方法,如Java语言中的检查型异常,但对于可抛出运行时异常的语句和方法却很少涉及.运行时异常控制流是描述包括运行时异常处理的程序有向图,它在程序原控制流的基础上,增加了描述运行时异常处理结构的点集和边集,包含的信息有{N,E,Ner,Nef,Ere}.其中N是节点集,每个程序语句都对应图中的一个节点.除了传统控制流图中的节点外,Ner是包括可抛出运行时异常语句的节点,Nef是包括可抛出运行时异常方法的节点.边集E={〈ni,nj〉|ni,nj∈N},表示节点ni对应的语句执行后,可能立即执行节点nj对应的语句.Ere为Ner和Nef节点的一条输出边,对应被抛出运行时异常的处理:被捕获的运行时异常通过Ere连接到相应的捕获节点,未被捕获的运行时异常通过Ere连接到控制流的异常退出节点.N={Ner,Nef}∪Nother,Nother表示传统控制流中的节点,E={Ere}∪Eother,Eother表示传统控制流中的边.基于以上描述,运行时异常控制流与传统控制流区别总结如下:向量如下.(1)为了便于定位运行时异常,每个语句作为一个控制流节点,而不是一个语句块;(2)每一个能够抛出运行时异常的方法,都有一个异常退出节点作为所有方法内未被捕获异常的Page5后继节点.为了保证控制流中出口的唯一性,每一个控制流增加一个正常退出节点,它和异常退出节点的后继节点为控制流的退出节点;(3)对应每一个可抛出运行时异常的节点Ner或Nef,通过边Ere连接到与其类型对应的异常捕获节点,或没有与其对应的异常退出节点.4.2异常控制流序列当运行时异常被触发时,它会动态地扩展当前控制流,而在被扩展的控制流上又可能出现新的运行时异常,这个运行时异常对控制流的扩展和在扩展的控制流上发生新运行时异常的迭代过程会产生一个控制流序列,其定义如下.定义5.异常控制流序列表明运行时异常行为与扩展的控制流之间的交互关系,包括运行时异常对控制流的扩展和在扩展的控制流上检测新的运行时异常以及如此重复迭代的过程,表示为一个四元组EC=〈RS,ES,G,T〉.RS是一个控制流有序集合{RS0,RS1,…,RSn},表示受运行时异常的影响,控制流从RS0开始逐步扩展到RSn;ES={ES0,ES1,…,ESn}是一个与RS对应的集合,由若干异常向量集合构成,犜犘∈ESi表示在RSi上可发现的异常向量;G是从RSi上生成ESi的规则,T是通过ESi将RSi转化为RSi+1的规则.在规则G下,ES0=∪N∈REC0M,A)|RS0}包括两部分内容,其一是控制流RS0中所有包括方法调用的节点所抛出的异常向量;其二是在控制流RS0上对问题D(P,M,A)求的有效解.D中的M为定义3中的状态机实例矩阵(EMij)n×m,在计算过程(EMij)n×m×A中,EM1(X1)EM1(X2)…EM1(Xm)熿EM2(X1)EM2(X2)…EM2(Xm)……EMn(X1)EMn(X2)…EMn(Xm燀∑ni=1∑mj=1∑m当变量Xj与异常模式EMi无关时EMi(Xj)A(Xk)=,另外,当j≠k时EMi(Xj)A(Xk)=.EMi(Xj)A(Xj)≠表示对非空实例EMi(Xj)应用算法A(Xj),结合EMi的状态转换条件C实现状态转换.当在RS0的节点N得到EMi(Xj)的异常状态Nexception时,即有EMi(Xj)A(Xj)→犜犘,其中位置P对应到RS0中的节点N,类型T对应到EMi表示的异常类型,|犜犘|对应到Xj的取值ρ(N,Xj).在规则T下,RSi+1=RSi×ESi,应用ESi中记在规则G下,Ek={D(P,M,A)|RSk}是在异常控制流RSk上对问题D(P,M,A)求的新有效解.M为状态机实例矩阵(EMij)n×m,对于M中的任一实例EMi(Xj)所对应的变量Xj,算法A(Xj)在路径S∪∪kl=1Sl上的不同执行位置L对Xj的取值信息进行计算,最后得到控制流RSk上所有可能抛出的新异常集合ESk=∑n录的异常∪sum(ESi)标记抛出运行时异常的节点Ner,应用类型Tj添加相应异常处理边Ere,最后将其扩展为RSi+1,sum(ESi)为ESi中异常向量的数量.通过对异常生成规则G和控制流转换规则T的反复迭代,可以实现异常控制流集RS的生成.迭代方程表示如下,假设RS0已知,迭代过程从t=1开始,直到ESt=结束.RSt=RS0,t=0烅烄烆ESt=∪N∈RS0烄烅{(EMij)n×m×A|RSt}-∑t-1烆基于以上描述,异常控制流序列与传统异常控制流间的区别如下:(1)传统异常控制流节点中与异常相关的节点只有抛出显式异常和隐式异常的节点,而运行时异常控制流中除了这些节点外,还包括抛出运行时异常的Ner和Nef节点以及处理运行时异常的边Ere;(2)在传统异常控制流RS0上进行静态测试时,只能报告当前发现的运行时异常信息E0以及与此相关的非异常问题;而应用异常控制流序列的方法,从传统异常控制流RS0开始,通过迭代方程将其扩展为{RS0,RS1,…,RSn},这样可发现更多的运行时异常{ES1,…,ESn}以及其它非异常问题.5异常控制流序列生成算法5.1算法描述下面以前面介绍的迭代方程为基础,给出异常控制流序列的生成算法.算法的输入为方法F对应的不包含节点Ner和Nef的传统异常控制流RS0、异Page6常模式状态机实例矩阵(EMij)n×m以及用于计算相关内容取值信息的方法[6-7],输出为异常控制流集RS和对应的异常向量集ES.1.begin2.I=0;ES[I]=;3.RS[I]=CFG(F);4.foreachNinRS[I]do5.ifF∈NthenES[I]=ES[I]∪F;6.endfor7.foreachEMi(Xj)in(EMij)n×mdo8.ES[I]=ES[I]+{EMi(Xj)A(Xj)|RS[I]};9.endfor10.whileES[I]≠do11.ES[I+1]=12.foreach犜犘inES[I]do13.RS[I+1]=RS[I]+犜犘;14.endfor15.foreachEMi(Xj)in(EMij)n×mdo16.ES[I+1]=ES[I+1]+17.endfor18.I++;19.endwhile20.foreachEreinRS[I].Nexcp_exitdo21.add(F,Ere);22.endfor23.end第4~6行首先统计F中所有被调用方法F的异常向量犉,并将其累加到ES[0]中;7~9行遍历方法F的状态机实例矩阵(EMij)n×m,应用方法A在控制流RS[0]上检测异常向量,也将结果累加入到ES[0]中;若经过前面的处理后ES[0]不为空,则从第10行开始应用迭代方程求解RS[I+1],指导ES[I+1]=终止.第10~19行为主迭代过程,直到在当前控制流上没有新的异常向量产生才终止循环.其中第12~14行首先计算ES[I]中的异常向量犜犘对RS[I]的变更,即应用位置P在RS[I]中标记异常抛出节点Ner或Nef,应用异常类型T在RS[I]中加入异常处理边Ere,由此得到RS[I+1];接下来的15~17行再次遍历(EMij)n×m,在RS[I+1]上应用算法A对所有状态机实例进行状态转换,以发现新的异常向量犜犘,并加入到ES[I+1]之中.通过10~19行的while循环,可以逐步迭代出RS中的所有成员,直到没有最新异常出现,即ES[I]=.最后,为了得到当前方法F所能抛出的所有异常向量,第20~22行将当前控制流中所有连接到异常退出节点Nexcp_exit的边加入到其对应的异常向量犉中.以上算法循环条件是以控制流的扩展为基础的,对它的有限性证明如下:(1)假设方法F中有m条语句,则最坏情况下的循环次数为m次,因此总迭代次数是有限的;(2)将RS映射成函数RS={y|y=f(x)}后,对于f(x)定义域x∈[0,m]内的任意两点x1及x2,且x1小于x2,则恒有f(x1)f(x2),因此函数f(x)在区间x∈[0,m]上是单调增加的.根据上面(1)、(2)可得,单调有界的函数f(x)必定是有极限的,因此求解异常控制流集RS的循环次数是有限的.5.2应用举例下面以代码片段中方法f1为例,对以上算法在软件静态测试中的应用步骤进行举例说明.以方法f1作为当前分析单元,其输入信息包括f1的初始控制流图RS[0],如图3(a)所示.其中每个节点上的序号对应源代码的行号,为了避免对资源泄漏的过多误报,控制流中屏蔽了close方法的检查型异常.假设对f1检测的缺陷模式有如下两种:空指针模式EMnpd和资源泄漏模式EMmlf,由于资源泄漏不会引起运行时异常,因此不需要为其创建异常向量.首先为f1创建的状态机实例分别为EMnpd(p)、EMnpd(q)、EMnpd(r)、EMmlf(q)、EMmlf(r),限于篇幅,状态机实例的创建方法不在本文讨论.这些实例共同构成f1的状态机实例矩阵(EMij)2×3=EMnpd(p)EMnpd(q)EMnpd(r)EMmlf(p)EMmlf(q)EMmlf(r中与资源泄漏模式无关,故EMmlf(p)=,r与空指异常无关,故EMnpd(r)=.对控制流RS[0]和ES[0]进行初始化操作后,得到初始控制流RS[0]为方法f1的基本控制流(图3(a))以及初始异常向量集合ES[0]=.除库函数外,f1没有调用其它子函数,算法4~6行执行完成后,当前异常向量集ES[0]=.算法7~9行在控制流RS[0]上执行(EMij)2×3中的非空实例EMnpd(p)、EMnpd(q)、EMmlf(q)、EMmlf(r),在RS[0]的节点7上得到EMnpd(p):Nexception,将异常向量犜npd犘7加入到集合中,得到ES[0]={犜npd犘7}.算法12~14行判断ES[0]非空后,应用ES[0]中的异常向量扩展RS[0],首先标记节点7为异常[Page7抛出节点,然后在节点7上增加一条抛出空指针异常的边,且该边连接到异常捕获节点9.经此操作得到RS[1],如图3(b)所示.算法15~17行在控制流RS[1]上执行(EMij)2×3中的非空实例EMnpd(p)、EMnpd(q)、EMmlf(q)、EMmlf(r),在RS[1]的节点10上得到新异常状态EMnpd(q):Nexception,将新异常向量犜npd犘10加入到集合中,得到ES[1]={犜npd犘10}.算法12~14行判断ES[1]非空后,应用ES[1]中的异常向量扩展RS[1],首先标记节点10为异常抛出节点,然后在节点10上增加一条抛出空指针异常的边,由于该异常没有被捕获而连接到异常退出节点12.经此操作得到RS[2],如图3(c)所示.算法15~17行在控制流RS[2]上执行(EMij)2×3中的非空实例EMnpd(p)、EMnpd(q)、EMmlf(q)、EMmlf(r),在RS[2]的退出节点上可得到新异常状态EMmlf(r):Nexception,由于资源泄漏模式不会抛出运行时异常,因此不需要为其创建异常向量,得到ES[2]=而结束循环.在算法的最后,当前控制流为RS[2],连接到它的异常退出节点的边有两条:从节点8抛出的检查型异常、从节点10抛出的运行时异常Enpd,因此需要将这两种异常加入到方法f1对应的异常向量中,供分析其调用者时使用.6实验环境及结果6.1实验环境为了对比应用异常控制流序列前后对静态测试可以决定异常模式状态机的数量.定每种异常模式状态机需要创建实例的数量.的影响,实验过程在北京邮电大学自主研发的软件缺陷检测系统DTS(DefectTestingSystem)①上展开,DTS的测试架构如图4所示,主要包括如下内容:(1)配置文件用于确定需要检测的缺陷类型,(2)通过分析Java源文件中的相关对象,可确(3)抽象语法树以源文件为基础创建,它是对程序分析的基础.(4)控制流图中存放每个分析单元的控制流信息,它是缺陷检测的基础.(5)符号表中存放作用域、符号声明及使用、表达式类型推导等信息,它从抽象语法树结构中获取.(6)函数间分析过程一方面从抽象语法树和符号表中收集信息,通过函数间的调用关系确定分析次序;另一方面对于分析完成的方法,保存其可抛出的异常信息,用于其调用者的分析过程.(7)区间运算对程序中相关变量的取值信息进行近似计算,它依赖于抽象语法树、控制流图和符号表等数据结构.(8)当前分析单元的状态机实例创建完成后,需要在控制流的每个节点上运行该实例进行状态转换.原DTS测试框架在获得分析单元的必要信息后,根据既定的缺陷模式及单元内容确定需要创建的状态机实例数量,然后逐一遍历控制流的节点,在每个控制流节点上应用函数间分析和区间运算技术计算所有状态机实例的状态,当遇到缺陷状态时,报告缺陷并退出相关状态机实例.应用异常控制流序列后,相当于在DTS的控制流遍历过程中修改如下内容:增加对方法抛出异常的处理,在分析前扩展初始控制流;在初始控制流上检测并保存运行时异常,①http://www.dtstesting.com/Page8将新运行时异常应用于对初始控制流的扩展;在扩展后的初始控制流上继续进行运行时异常的检测及控制流扩展的工作,直到没有新异常出现为止.以上过程将控制流序列的生成算法集成到DTS的测试过程中,将在初始控制流上的一次遍历过程转变为在控制流序列上的多次遍历过程.6.2实验结果实验选取9个开源Java工程作为测试对象,选取空指针异常模式(NPD)及资源泄漏模式(MLF)作为测试目标,对比应用异常控制流序列前后的过程数据及结果数据.设定DTS(A)不应用异常控制流序列,DTS(B)应用该方法.对比测试结果如表1所示.状态机类型有NPD表1对9个Java开源程序的测试结果对比控制流数量C(A)C(B)areca-7.1.1aTunes-1.8.230652603321012521393183200136/23157/42cobra-0.98.14496953728941240127132534835/644/14freecol-0.7.334311483875632304275411911358345/53374/71freemind-0.8.1509102112465718322077818911245/18259/27jstock-1.0.4megamek-0.32.2535177512168234719515156796032363/25389/47robocode-1.623353408306814721645234267185/33201/48SweetHome3D-1.815459943256410931182238255116/10131/25时间开销的增加是应用控制流序列技术的一个代价,其另外一个代价是误报率的增加.表中的IP表示总检测记录数,FP表示经人工判断后的误报数.DTS(A)IP(A))i/9×100%=14.14%,而引入控制流序列后,DTS(B)IP(B))i/9×100%=20.09%,较DTS(A)增长了5.95%.引入误报的主要原因在于若ES[I]中出现了误报的异常,则会在RS[I+1]中引入不可达路径,由此可能导致一系列的误报出现.虽然这种方法增加了时间开销及误报率,但是它带来的效果是增加了缺陷的报告,将DTS(A)报告的1470个缺陷增长为1500个,((D(B)i-D(A)i)/D(A))i/9×100%=∑9i=12.18%,其中D(X)i=IP(X)i-FP(X)i.经人工分析后,由于未捕获运行时异常,其中有8个缺陷发生后程序会异常终止,而剩下的22个缺陷发生后则不和MLF两类,建立状态机实例的数量共48766个,平均需要为每个工程建立5418个状态机实例.DTS(A)创建的基本控制流共16809个,而应用了控制流序列后,DTS(B)中将控制流扩展为18631个,总增长率为[C(B)-C(A)]/C(A)×100%=10.8%,C(A))i/9×100%=10.14%.由此带来的开销是DTS(B)的总体分析时间较DTS(A)增长了[T(B)-T(A)]/T(A)×100%=8.01%,平均增长率为(T(B)i-T(A)i)/T(A))i/9×100%=i=(1∑99.24%.会出现这种情况,即它们可以较深地隐藏在程序的执行过程中.虽然此类缺陷的数量不是很大,但是通过与其它同类测试工具对比,新发现的缺陷在其它工具的报告中是未曾出现的.这也是这种方法的价值所在———以可承受的代价尽可能多的发现软件中存留的问题,这点在航空、航天等高可信领域尤为重要.7相关工作比较运行时异常对软件静态测试提出了新的问题,本文提出的应用异常控制流序列的方法结合了运行时异常行为与控制流扩展间的迭代关系,具有如下优点:(1)扩展传统异常控制流,将抛出运行时异常的边加入其中,在此基础上支持对新异常及缺陷的检测;(2)在静态测试过程中,通过迭代方程将在初始控制流上的一次遍历过程转变为在控制流序列上的多次遍历过程.Page9目前有许多文献都涉及了异常处理机制对控制流、数据流或静态测试的影响,有些文章也包括了有关运行时异常的内容,主要有如下几种:Fu等人[9]在对网络服务应用进行健壮性测试时,综合考虑了Java程序中的显式异常及JDK库所抛出的隐式检查型异常;Mao等人[10]在研究面向对象程序的健壮性和可靠性时,在C++异常处理模型的基础上,提出了一种应用静态异常分析方法提高程序的健壮性.以上研究虽然考虑到不同语言中的显式异常和隐式异常,但会由于缺少对运行时异常分析而遗漏某些特殊路径,从而影响程序的健壮性.Sinha[11-12]等人在进行程序分析的过程中,描述了异常发生及传播机制,从过程内和过程间两个方面介绍了异常处理对控制流的影响,并给出异常处理机制对构建测试及覆盖技术的影响,但在他们所提出的异常处理结构和标准中仍然缺少与运行时异常相关的内容,因此难免影响测试覆盖的充分度.为了能够充分有效地支持程序分析,Choi等人[13]提出一种控制流表示方法,叫做要素控制流图FCFG方法.该方法将程序中潜在抛出运行时异常的语句(PEI)都加入到控制流中.虽然FCFG方法可以处理运行时异常,但由于潜在异常抛出点都是预先确定的,而并非通过计算求得,因此采用此技术的静态测试方法必然会出现较高的误报率.Weimer等人[14]提出一种数据流分析方法来检测由于异常处理不当导致的资源泄漏问题,该方法包含了传统显式、隐式及运行时异常对控制流的影响以及由此导致的资源泄漏问题.他们的方法虽然考虑了运行时异常,但仅限于过程内的影响,未涉及运行时异常在过程间的传播,且仅限于研究运行时异常的直接影响,其影响对控制流的扩展以及在扩展后的控制流上是否能出现新的异常则没有研究,因此采用此技术的静态测试方法可能会出现一定的漏报情况.Chatterjee等人[15]为面向对象程序提供了一个异常处理的模型,可以确定某个运行时异常在过程间传播后可以达到什么程序位置,同时开发了一个静态分析工具Jex处理本地异常和全局异常.他的方法同样也由于没有考虑运行时异常与控制流扩展之间的交替影响而出现漏报情况.8结束语本文提出一种迭代的代码缺陷检测方法,将运行时异常对控制流的扩展及在扩展的控制流上检测新运行时异常这两个迭代的过程相结合,用于研究运行时异常对软件静态测试的影响.实验结果表明,由于控制流的扩展,会导致分析时间的成倍增长;另外在生成控制流序列的过程中还会引入部分不可达路径,这使得误报率也有所增长.但以上代价所带来的效果是深入地检测出传统方法所遗漏的缺陷,这些遗漏的缺陷在航空、航天、电信、金融等高可信领域具有重要的价值.因此,对于如何提高分析效率以及如何降低误报率将是以下一步研究的主要内容.
