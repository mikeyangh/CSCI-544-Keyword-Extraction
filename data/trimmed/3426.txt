Page1提升小波变换的数据并行计算方法研究钟升1),2)沈绪榜1)郑江滨2)王艳玲1)1)(西安微电子技术研究所西安710065)2)(西北工业大学计算机学院西安710072)摘要研究了基于SIMDPE阵列对G级像素帧进行9/7提升小波变换的数据并行计算实现方法.首先,在分析9/7提升小波变换运算公式的局部计算特点的基础上,提出了PE状态标识法和基于PE标识的条件计算方法;其次,提出了SIMDPE阵列的虚拟化实现方法.研究表明,该方法提高了计算的并行度和规则性,并行度仅受限于阵列的规模且具备可裁减性和通用性,很适合于MPP系统芯片实现.关键词数据并行;提升小波变换;SIMDPE阵列1引言1998年,Daubechies和Sweldens提出了一种新的基于提升算法的小波变换,又叫做快速提升小波变换(FastLiftingWaveletTransform,FLWT)[1-2].目前,该算法已用于JPEG2000标准中[3].针对图像预处理的实时性需求,小波变换的数据并行实现方Page29/7提升小波变换在PE阵列上的实现方法,该方法具备一定的通用性,可有效地应用于其它变换处理,如DCT变换等,具体参考文献[7].提升(Lifting)小波变换是在空域中构建的.给定一个信号x=(xi)(i=1,2,…,N),假设N是2的幂次方.首先将其分裂成两个不相交的集合:偶信号集合xe=(x2n)与奇信号集合xo=(x2n-1),1nN/2.给定一个预测器P(Predictor),并求解一个细节值(detail),最简单的预测器P就是其两个相邻奇信号值的平均,其细节值就是:d2n=x2n-(x2n+1+x2n-1)/2,1nN/2,s2n-1=x2n-1+U(d2n),1nN/2,计算与记录一个细节值的操作叫做一个提升步(Liftingstep).使用更新器U(Updateoperator)对细节值进行操作,并通过x2n-1+U(d2n)来获得平滑值s(smoothedvalue),而后用该值去取代x2n-1.不管预测P与更新U是如何选择的,此方案总是可逆的.从应用上说,9/7提升小波变换有分解变换与重构变换.我们假定被处理的对象是大小为N×N的图像Pixel[i][j](i=1,2,…,N,j=1,2,…,N).小波变换可以是多层的,先是分解变换,然后依应用需求进行滤波,最后是重构变换.为了使讨论具体起见,这里只讨论3层的情况,分解变换产生的结果顺表19/7提升小波变换分解计算公式第1步.分裂(split)第2步.预测1(predict1)第3步.更新1(update1)第4步.预测2(predict2)第5步.更新2(update2)第6步.尺度变换(scalingtransform)由于真实图像是具有边界的,边界处理将会影响重构图像的质量,小波变换时必须考虑边界效应.边界的处理仅需对表1中的计算公式稍作修改即可,读者可自行推导.t=-(Wk-1)/2∑(Wk-1)/2其中,k为处理层数,本文中k=1,2,3,σε为高斯白噪声方差的先验统计值[9-12].计算窗口的形状及大序是Pixel→(L、H)→(LL1、HL1与LH1、HH1)→(LL2、HL2与LH2、HH2)→(LL3、HL3与LH3、HH3),而重构变换的要处理的数据顺序为(LL3、HL3与LH3、HH3)→(LL2、HL2与LH2、HH2)→(LL1、HL1与LH1、HH1)→Pixel.在讨论提升小波变换计算方法之后,第2节讨论小波变换的过程与计算公式;第3节讨论小波变换的数据并行实现方法;第4节是SIMDPE阵列的虚拟化实现方法;第5节是结束语.2小波变换的过程与计算公式9/7提升小波变换的分解变换是由4个提升步(Predict1、Update1、Predict2、Update2)和2个尺度变换(ScalingTransform)步组成的[8],各层的分解变换是先行变换,然后对行变换后的结果进行列变换,行列分解变换的公式是相同的;后面层的变换仅是对前面层变换的结果LLi(i=1,2,…)进行的,因此,每层的提升变换之前,需要有一个分裂(split)步.但是由于在本文中采用了状态位的表示方法,所以只需要对每层的输入数据进行一次分裂计算,具体计算公式如表1所示.公式中的系数取值[8]为α=-1.58613432,β=-0.05298011854,γ=0.8829110762,δ=0.443506822,=1.149604398[2-3].为了描述方便,用s0表示odd集合中的原始像素值,d0表示even集合中的原始像素值.小波子带系数处理,以基于方向窗口的Wiener滤波[9-12]为例,小波子带系数处理具有较高的处理精度.文献[13]给出一种易于并行化的滤波窗,该算法在PE阵列中的实现公式为s=-(Wk-1)/2小的选择,对处理精度是有影响的[14],其大小及形状因分解层的不同而不同,但实现上的差异只是编Page3程的不同而已.提升小波的重构变换又叫做逆提升小波变换(InverseLiftingWaveletTransform,ILWT),计算表29/7提升小波的重构变换计算公式第1步.尺度逆变换(InverseScalingTransform)for[-1n(N/2)+2]do:{d2(2n)=H(2n);s2(2n+1)=(1/)L(2n+1)};第2步.逆更新2(IinverseUpdate2)第3步.逆预测2(InversePredict2)第4步.逆更新1(InverseUpdate1)第5步.逆预测1(InversePredict1)重构变换从分解变换的最后一层开始,首先对所有的列进行,其结果作为行重构变换要处理的数据.行重构变换后即完成本层的重构,其结果作为下一层重构变换的要处理的数据,各层的重构过程是相同的,此处不再赘述.3提升小波变换的数据并行实现方法第1层分解变换是对一幅图像的所有像素值Pixel[i][j]进行的,如图1(a)所示,变换后的结果如图1(b)所示.第2层变换是仅对第1层分解后的1/4的数据LL1进行的,变换后的结果如图1(c)所示.第3层变换是仅对第2层分解后的1/4的数据LL2进行的,变换后的结果如图1(d)所示.3.1分解变换的数据并行实现方法为了讨论方便起见,下面将先讨论分解变换后的数据在PE阵列中位置的表示方法,然后再讨论分解变换的数据并行实现方法.由于SIMDPE阵列的规模可依据应用需求进行裁减.为具体起见,我们假定SIMDPE阵列的大公式如表2中所示.重构变换中的边界处理与分解变换的边界处理是类似的,仅需对表2中的计算公式稍作修改即可,读者可自行推导.小与图像帧的大小一致(以16×16为例),图像帧中的像素Pixel[i][j]是放在PE阵列的处理元PE[i][j]中,i,j表示像素在图像帧中的位置,也是在PE阵列中的位置.阵列中各PE之间的互连关系,是按东西南北4个方向进行互连(DWDE和DNDS)的,如图2所示,PE之间只有相邻的局部通信.该阵列中,处理元PE由数据处理部件以及相应的路由器与缓冲器三者组成,路由器和缓冲器构是通信的功能部件,此处限于篇幅不做深入讨论.在SIMDPE阵列上对一幅二维图像进行提升小波变换,就是对存放像素值的所有PE单元,先按行方向进行数据并行计算处理,计算后的结果放入对应的PE单元中,然后按列方向再进行数据并行计算处理,计算后的结果(即子带系数)就存放于PE阵列中.3.1.1分解变换后的数据在PE阵列位置的状态提升小波变换的数据在处理元中的位置可以按处理元的位置坐标事先确定,即分裂步是可以事先完成,并用状态位标识的.对于分裂步,就是用状态位b0=1与b0=0分别表示奇数列与偶数列;b1=1与b1=0分别表示奇数行与偶数行.其它各层的状态位也是在这个分裂步上求出来的.第1层分解变换是对图像帧的所有像素值进行的.先对所有的行按表1的公式进行数据并行计算,计算结果为子带系数L1和子带系数H1,如图3(a)8×8的PE阵列中所示.PE阵列的每个奇数列上均为L1,每个偶数列上均为H1,将第1层行分解变换后的所有的奇数列构成的集合统称为odd1c列集合;所有偶数列构成的集合统称为even1c列集合,分别在状态位b0=1与b0=0的PE单元中;然后针对行处理后的结果,即子带系数L1和H1,同时对所有的列按表1的公Page4图2SIMDPE阵列体系结构(LS-MPP)图3第1层变换后的子带系数位置的分布情况举例式进行数据并行计算.变换后的结果为子带系数LL1、LH1与HL1、HH1,如图3(b)所示.PE阵列的每个奇数行上均为LL1与LH1,每个偶数行上均为HL1与HH1,将第1层列分解变换后所有的奇数行构成的集合统称为odd1r行集合;所有的偶数行构成的集合统称为even1r行集合,分别在状态位b1=1与b1=0的PE单元中.第2层分解变换是仅对第1层分解后的子带系数LL1(即第1层变换后的四分之一)的数据进行的,如图1(b)所示.在SIMDPE阵列上,子带系数LL1是分布在i=2n-1和j=2n-1(1nN/2)的位置上的.LL1所在单元是用状态位b2=1表示图4第2层变换后的子带系数位置的分布情况举例第3层分解变换是仅对第2层分解后的子带系数LL2,即第2层变换后的四分之一的数据,如图1(c)所示,进行分解变换的.在SIMDPE阵列上,子带系数LL2是分布在i=4n-3和j=4n-3(1n的,非LL1所在单元是用b2=0表示.LL1的位置坐标为i=1,3,5,7与j=1,3,5,7,如图3(b)所示.由于对LL1进行的变换也是要奇偶分裂,所以重新设置这些位置坐标为i=1,2,3,4,…,N与j=1,2,3,4,…,N,如图4(a)中所示.第2层行分解变换后的结果为子带系数L2与H2,与第1层变换类似,分别在b2b3=11与b2b3=10的PE单元中;然后对它们按表1的公式进行数据并行计算.计算后的结果为子带系数LL2、LH2与HL2、HH2,如图4(b)所示,它们分别在b2b4=11与b2b4=10的PE单元中.对于b2=0的单元,它们的b3、b4均为不管(don’tcare)位.N/4)的位置上的,如图4(b)所示,LL2所在单元是用状态位b5=1表示的,非LL2所在单元是用b5=0表示的.由于对LL2进行的变换也是要奇偶分裂的,所以重新设置这些位置的坐标为i=1,2,…,NPage5与j=1,2,…,N,如图5(a)8×8的PE阵列中所示.第3层行分解变换后的结果是子带系数L3与H3,将所有奇数列构成的集合统称为odd3c列集合,将所有偶数列构成的集合统称为even3c列集合,分别在b5b6=11与b5b6=10的PE单元中;然后对行变换后的子带系数L3和H3,同时对所有的图5第3层变换后的子带系数的位置的分布情况举例各层的状态位表示如表3中所示.读者不难推出更多层分解变换的状态位表示情况.表3犘犈[犻][犼]状态寄存器PSR的设置情况表输入状态位第1层无第2层b2=1第三层b5=13.1.2分解变换的数据并行程序实现方法在SIMDPE阵列中,不是每条指令都在每个PE上能同时执行的,就存在所谓的自治(automations)问题,也就是条件计算问题.在分解变换中,程序是以状态位为条件,采用条件传送语句与条件算术语句等描述的[15].因为条件语句是在条件成立时才执行相应的操作,条件不成立时执行NOP操作的.这样,对应于各层的分解变换就可以对整个N×N的阵列进行,第1层分解变换是先完成分裂步,求出各层所用的状态位.第2层及以后的分解变换均没有分裂步,而是从预测1开始的.本文约定原始像素值存储在PE[i][j]的寄存器r0中,表1中计算公式的提升系数作为立即数处理,状态位的值是存放在状态寄存器中的,不占用单独的单元,在第1层提升小波行分解变换中,对所有列进行分解变换,分解变换后的子带系数为LL3、LH3与HL3、HH3,如图5(b)所示,将所有奇数行构成的集合统称为odd3r行集合,将所有偶数行构成的集合统称为even3r行集合,分别在b5b7=11与b5b7=10的PE单元中.对于b5=0的单元,它们的b6、b7均为不管(don’tcare)位.的行进行处理的程序段如表4所示.计算步骤序号及名称预测1的程序实现更新1的程序实现预测2的程序实现更新2的程序实现尺度变换ifr0=(b0==0)?{(1/)×r0}:NOP;根据表1的计算公式,预测1的程序实现方法,如表4所示.第1条语句将状态位b0=1的所有PE单元的寄存器r0的值乘以系数α,得到的结果放入r1中;第2条语句将b0=1的PE单元的r1的值送入其右邻的PE单元的r2中,第3条语句将b0=1的PE单元的r1的值送入其左邻的PE单元的r3中;第4条语句将b0=0的PE单元的r2和r3的值相加,结果放入r4中;第5条语句将b0=0的PE单元的r4的值与r0的值相加,便得到预测1的Page6细节值d1,放入r0中.更新1的程序实现方法,第1条语句将状态位b0=0的所有PE单元的寄存器r0的值乘以系数β,得到的结果放入r1中;第2条语句将b0=0的PE单元的r1的值送入其右邻的PE单元的r2中,第3条语句将b0=0的PE单元的r1的值送入其左邻的PE单元的r3中;第4条语句将b0=1的PE单元的r2和r3的值相加,结果放入r4中;第5条语句将b0=1的PE单元的r4的值与r0的值相加,得到第一步更新后的平滑值s1,放入r0中.预测2和更新2的程序实现方法,是分别与预测1和更新1类似的,只是用到系数分别为γ和δ最后是尺度变换,第1条语句将b0=0的单元r0的值乘以系数1/,结果为子带系数H1;第2条语句将b0=1的单元r0的值乘以系数,结果为子带系数L1.L1与H1在是分别存放在状态位b0=0与b0=1的单元中的.第1层列分解变换,与行分解变换类似,仅需在表4中,用i代替j,用b1代替b0即可.第2层分解变换与第1层是类似的,只是所用到的状态位不同.在对行的分解变换中,用b2b3==11代替b0==1,b2b3==10代替b0==0,i代替i,j代替j;在对列的分解变换中,用b2b4==11代替b1==1,b2b4==10代替b1==0,用i代替j,j代替i.依此读者不难推出第3层以及更多层分解变换的数据并行程序实现方法.3.2Wiener滤波的数据并行计算方法基于小波变换的Wiener滤波图像去噪,在各个分解层上,是仅对LH、HL和HH这3个子带系数进行的.本节仅以第3分解层的处理为例,讨论在3×3的方形窗口中对相邻的9个子带系数:HL3、LH3和HH3进行滤波的数据并行实现方法.现以子带系数HH3为例,说明去噪公式(1)和(2)的并行计算过程.公式(1)是一种局部运算,对于所有的初始HH3,首先进行求平方,求平方后得到的每个HH3都与其相邻的8个求平方后的HH3求和,并除以9求均值以及求均值与σ2与0的最大值,便得到公式(1)的结果PE[i][j].公式(2)是一种点运算,首先求PE[i][j]与σ2和,然后用这个和除PE[i][j],最后与HH3相乘,便得到公式(2)的结果PE[i][j].子带系数HL3、LH3的处理与此类似.第1、2分解层的处理与第3分解层也是类似的,不再赘述.不难看出,公式(1)和(2)的编程与分解变换的编程类似,由第3节内容可知,对各个子带系数处理均可采用基于PSR状态标识位的条件执行语句来实现.在完成了所有3层的子带系数去噪处理后,将进行下节中讨论的重构变换,便可获得去噪后的图像.其它去噪方法与此类似,具体参见文献[16].3.3重构变换的数据并行计算方法与分解变换一致,重构变换也只讨论3层的情况.在各个分解层上,对LL、HL与LH、HH4个子带系数进行,是先对所有的列,然后对所有的行按表2的公式进行数据并行计算.第3层重构变换的数据位置分布,也是用PE单元的PSR状态位表示的,即b5b7=10与b5b7=11表示细节值d2与平滑值S2的位置;b5b6=10与b5b6=11表示细节值d1与平滑值S1的位置.重构变换后的结果为子带系数LL2,若无误差即为LL2,位置分布情况如图4(b)中所示.依此类推,第2层与第1层的重构变换都是与第3层类似的,不再赘述.4SIMDPE阵列的虚拟化实现利用现在的深亚微米技术,很难实现与G级像素帧同样大小的SIMDPE阵列,特别是在嵌入式应用中,实际的物理阵列是远小于G级像素帧的大小的,上节的讨论是建立在SIMDPE阵列的虚拟化设计基础上的.SIMDPE阵列的虚拟化实现可以有许多方案,这里分别对不同物理阵列规模的3种情况进行分别讨论,并在最后给出基于1024×1024处理元情况下的性能分析与仿真结果.4.1一个处理元的虚拟PE阵列的单处理元的虚拟就是在PC机上验证本文的数据并行方法,虚拟方法是设定图像帧的每个像素单元是由像素值与状态字组成的.每条数据并行语句用一个子程序实现,用户只需编写表4所示的程序段即可.PC机的一个处理器,对整个像素帧的计算,实际上是从第一个像素开始,根据其状态位值的判断,来决定对该像素单元进行相应的计算或空操作,依次对每个像素进行计算,直至整帧图像处理完毕.小波变换的行变换和列变换的差别在于,相邻像素的地址间隔不同,读者不难从第2节的讨论中推导.4.2一行处理元的虚拟对N×N的图像帧来说,就是假定有一行处理元在像素帧的单元中,仍然假定每个单元是像素值Page7与状态字两者组成的.阵列的大小用户可以通过参数设定,对整个像素帧的仿真,行处理元从起始位置开始移动,计算完一行后,转向下一行,直至整帧图像处理完毕.与单处理元不同的是,每次操作可完成对与行处理元个数相等的像素的处理.换句话说,在进行行变换时,系统可一次处理一行中与处理元个数相等的像素值,在进行列变换时,则是对各个列中的对应的像素单元同时进行处理,这样可大大提高数据处理的并行度.行处理元中,行变换和列变换的相邻像素的地址间隔相同.4.3阵列处理的虚拟及性能分析本文主要讨论了基于SIMDPE阵列的9/7提升小波变换数据并行计算方法,并给出了基于小波分解的Wiener滤波在SIMDPE阵列上的数据并行计算方法.表5针对5层提升小波分解变换,给出了各层变换所需的计算量和PE间的通信次数.表5和表6针对各个分解层,分别给出了各层的小波变换和Wiener滤波所需的计算量和PE间的通信次数.由于重构变换在计算量和通信量方面与分解变换是一致的,在此不再赘述.在阵列大小与图像帧的大小一致的情况下,该统计值与图像的规模无关,适用于各种大小的图像帧,也就是说,当阵列规模足够大时,是适合于G级像素帧的.表5提升小波分解变换的计算量及通信次数分解层数12345分解层数1142103104656由于当前的IC设计在工艺、集成度以及指令周期长度的设置等方面,均存在很大的差异,难以针对同一算法从运行时间上进行比较.因此,本文针对当前工艺,基于一些合理的假设,采用最小指令周期数的准则,相较于常规串行处理方式,在不同规模像素帧处理的情况下,对本方案所能获得的加速比进行评析.其中,加速比Sp的定义为Sp=T1/Tp,T1与Tp分别为采用单处理器的执行时间和采用p个处理元的并行执行时间,一次乘累加运算或单次相邻PE单元间通信均为最小指令周期,且取最小指令周期为时间单位.表7给出了各分解层相对于常规串行处理的加速比.图6给出了加速比-像素帧规模的变换曲线.其中,横坐标为像素帧的规模,纵坐标为规格化的加速比.由此不难看出,随像素帧规模的增大,其加速比迅速增大,且其效率值渐线性或亚线性,说明该并行实现方法是可扩放的[15].当图像的规模达到G级时,其加速比可观,满足大多数大图像帧处理的实时处理的要求.帧规模64×6435265.7310.76128×1281408262.9243.04256×25656321051.68172.18512×512225284206.70688.701024×10249011216826.82754.834.4阵列处理的仿真验证本文采用的验证平台为IntelPentium4(2.8GHz)处理器,内存:1GB,L1dataCache:8KB,L1UnifiedCache:1024KB,采用的仿真软件为Parallaxis-Ⅲ.其中,对PE的阵列的规模和互联结构是使用Parallaxis-Ⅲ中的(CONFIGURATION)和(CONNECTION)命令来定义的.PE间的数据交互,是使用系统函数MOVE进行模拟仿真的.对分辨率为1024×1024的灰度图像(灰度级为256)进行了5层分解,各分解层的窗口大小(按层数由低到高的顺序)分别设定为(27×27)、(9×9)、(9×9)、(3×3)、(3×3).采用Daubechies小波进行了基于本实现方案下的小波变换及Wiener滤波仿真验证,其输出PSNR约为26.98.图7(a)给出了1024×1024像素50dB的含噪图像,图(b)给出了去噪后的图像.通过上述的仿真,验证了实现方法的正确性.Page8图7图像去噪效果5结束语本文针对G级像素图像帧实时处理,研究了提升小波的分解变换、Wiener滤波与重构变换在SIMDPE阵列上的数据并行计算的实现方法以及SIMDPE阵列的虚拟化实现方法.小波变换的数据并行实现方法的好处,从软件上讲,并行度不受算法限制,采用状态位表示法以及条件语句,不仅省去了下标表示法的计算量,而且使得分裂步的计算为零时间;其余各计算步的处理程序,如文中所示,不但简短,而且所用到的语句都仅仅是计算与传送语句;数据并行算法的数据处理方式非常规则,可理解性好,通用性强.从硬件上讲,并行度仅受PE阵列大小的限制,并行性是随SIMDPE阵列的大小而变化的.由于SIMDPE阵列具有可剪裁性,因此,阵列的大小是容易随应用的并行性要求而变化的;特别是,随着芯片集成度的提高,不仅阵列可以扩大,还可以小型化,符合微电子技术发展方向.本文提出用状态位来标识所要处理的PE单元,而状态位的值是预先可以确定的,这样可以避免每一次处理时进行的分裂计算,大大提高了系统运行效率,该方法还可有效地应用于其它具备一定并行度的变换处理,如DCT变换等.本文提出的3种SIMDPE阵列的虚拟化实现方法,前者是在普通的PC机上实现的,适合于不同大小的图像帧,通用性强;向用户提供的指令集,操作简单且容易理解,同时能够验证各条指令设置的合理性以及应用方法的正确性.后者在一行和阵列处理元上实现,提高了数据处理的并行度,能够在执行效率等方面体现出并行算法的优势,同时也可以验证子程序的合理性与正确性.
