Page1基于频繁概念直乘分布的全局闭频繁项集挖掘算法柴玉梅张卓王黎明(郑州大学信息工程学院郑州450001)摘要基于概念格的集中式数据挖掘算法,不能充分地利用分布式计算资源来改善概念格构造效率,从而影响了挖掘算法的性能.文中进一步分析了Iceberg概念格并置集成的内在并行特性;以频繁概念直乘及其下覆盖为最小粒度,对Iceberg概念格并置集成过程进行分解和分布式计算;在对其正确性理论证明的基础上,提出了一个新颖的异构分布式环境下闭频繁项集全局挖掘算法.此算法利用Iceberg概念格的半格以及可并置集成特性,充分发挥了分布式环境下计算资源的优势.实验证明,在稠密数据集和稀疏数据集上,该挖掘算法都表现出较好的性能.关键词Iceberg概念格;分布式数据挖掘;并置集成;异构数据库;闭频繁项集1引言自从德国的Wille教授[1]于1982年提出概念格以来,形式概念分析作为有效的数据分析和知识表示工具被广泛地应用于软件工程、知识发现与数据挖掘、机器学习、信息检索等多个领域.由频繁概念组成的Iceberg概念格作为频繁项集的精简表达已经应用于频繁项集的挖掘过程中[2-4].然而在基于FCA的应用任务中,无论是构造完备概念格,还是剪枝后的Iceberg概念格,较高的空间和时间复杂度是一直以来制约着其应用的主要因素.另一方面,在分布式异构环境下[5],传统的串行挖掘算法[6-8]不仅不适于该环境下的挖掘工作,更不能充分利用计算资源,提高挖掘效率.针对这种情况,本文以文献[3]工作为基础,进一步发掘Iceberg概念格并置集成构造过程的潜在并行性,提出新颖的Iceberg概念格分布式构造理论,进而以此为指导提出基于频繁概念直乘分布(frequentconceptdirectproductiondistributed)的Iceberg概念格分布式构造算法Frecodipd,并使用该算法完成分布式异构环境下的全局闭频繁项集挖掘任务.该算法克服Icegalamera算法应用到分布式环境下并行粒度较大(以节点Iceberg概念格为最小粒度)和集成计算时部分节点空闲的问题,其使用频繁概念及其下覆盖为最小域分解粒度,在集成的每个阶段充分利用空闲节点的计算资源,提高了异构分布式环境下闭频繁项集挖掘的并行性与效率.本文同时给出Icegalamera算法的并行化版本Icegalamera-ED(EnsembleDistributed),其使用节点Iceberg概念格为最小分布粒度,并作为评估Frecodipd算法分布式性能的基准.最后通过多个数据集下的对比实验,验证了Frecodipd算法在分布式异构环境下挖掘闭频繁项集的完备性与高效率.2相关研究目前,关于概念格并行构造方面研究主要集中在对现有的概念或者概念格串行构造算法的并行化改造.1997年Njiwoua等人[9]以Bordat算法[10]为基础提出了一个多项式时间复杂度的概念格并行构造算法,其利用Bordat算法在计算当前概念最大后继时过程独立的特点,对Bordat算法进行并行化改造,因此该并行算法依然保持Bordat算法批处理构造的特点,并且为了克服其各个节点搜索空间重叠的问题,在计算新概念时都需要与中心节点同步,同时其自顶向下的构造使得该并行算法不适于异构分布式环境(数据域的自然分解)下的概念格构造;2004年Fu等人[11]针对NextClosure算法[10]提出了以字典序划分属性的数据域分解方法,避免了节点间搜索空间的重复,同时也减少了通信的代价,但是该并行方法最终只能产生形式概念,没有建立概念间的偏序关系;2005年Franois等人[12]提出了基于概念格并置的并行构造算法DAC-ParaLax,该算法以概念格并置集成构造算法[13]为基础,利用子格并置集成可并行化的特点,并且在集成过程中进一步进行子任务分解,充分使用空闲节点,该算法从数据域分解、任务域分解、通信、聚集和映射多个层面并行化概念格的并置集成过程.国内的有2005年齐红、刘大有等人[14]提出的基于搜索空间划分的并行概念生成算法.该算法是以基于搜索空间划分的概念生成算法为基础[15],通过并行化改造完成形式概念的并行构造任务.因为数据与任务分解的方式不同,并不是所有的并行算法都适应于分布式异构环境.现有的Icerberg概念格并行或者分布式构造算法均不很高效.文献[16]提出的基于Iceberg概念格叠置半集成的全局闭频繁项集挖掘算法,通过采取额外措施,来弥补Iceberg概念格叠置集成构造全局Iceberg概念格过程中的不足,从而影响了该算法的执行效率.本文提出的Frecodipd算法采用并置集成方式构造全局Iceberg概念格,具有较高的执行效率.在串行Iceberg概念格构造方面,2002年Stumme等人[17]提出一个基于weight函数的计算闭系统算法TITANIC,并用其批处理式的构造Iceberg概念格;2004年Rouane等人[18]给出了基于对象的Iceberg概念格渐进式维护算法Magalice,该算法通过剪枝时预留jumper概念使得Iceberg概念格可以在线维护;2005年Nehme等人[19]给出基于属性的渐进式最小产生子(MinimalGenerator)构造算法IncA-Gen,其也可以用来增量式构造Iceberg概念格;2007年Hu等人[4]使用改进后的Godin算法[10]构造Iceberg概念格,并使用该算法挖掘频繁项集;2007年文献[3]提出基于并置集成的Iceberg概念格构造算法Icegalamera,并使用Iceberg概念格完成闭频繁项集挖掘任务,同时由于Iceberg概念格的集成构造过程的并行性,使得该算Page3法具有并行化和分布式改造潜力.以下详细给出由文献[3]中的Icegalamera算法扩展到异构分布式环境下而产生的集成分布算法(EnsembleDistributed,ED)的说明.3集成分布算法集成分布算法(ED)是文献[3]中的Icegalamera算法的分布式版本.其主要思想是各个节点在挖掘本地Iceberg概念格后,节点Iceberg概念格两两并置,直到得到全局Iceberg概念格.因此,Icegalamera算法与ED算法的异同点在于:①ED算法在对全局Iceberg概念格构造时不需要再把全局形式背景划分成各个节点形式背景.因为这是已经自然划分好的,因此其只需把各个节点Iceberg概念格两两集成即可.但是各个节点内部构造节点形式背景的节点Iceberg概念格时仍然需要使用Icegalamera算法.②ED算法在由各个节点Iceberg并置集成到全局Iceberg概念格的过程中,是自底向上地逐级构造.因此需要加入角色分配、任务控制和消息传递等过程.③抛弃具体流程的不同,从整体上看两种算法由各自子Iceberg概念格层层集成构造所形成的集成树却是相同的.这一方面验证了文献[3]中关于Icegalamera算法可以应用到分布式环境下的结论;另一方面也决定着ED的性能,其最小的域分解粒度是Iceberg概念格,而当一个节点把自己所拥有的Iceberg概念格传递给其它节点作为集成的一个输入实参时,这个节点也就退出了运算并处于空闲状态,造成了资源浪费.例1.如果分布式概念格有7个节点,两两并置集成分配情况如图1所示:在阶段0各个节点独立完成节点Iceberg概念格的并置集成任务;阶段1~3逐级完成节点间的Iceberg概念格分布式并置集成,最终得到全局Iceberg概念格,其中○为执行集成任务的服务节点(servernode),△为空闲结点(idlenode).可以看到随着集成阶段的提高,空闲节点的数量也在增加.如果分布式Iceberg概念格有n个节点的话,那么就需要进行log2n阶段的节点间集成过程,每阶段的集成过程都需要一次通信,最终得到全局Iceberg概念格后还要把它传给其它的n-1个节点.虽然每次需要传输的局部Iceberg概念格的数量减半,但是要传输的局部Iceberg概念格的大小却在逐渐增加.并且每个阶段的集成过程都会有节点,因为角色的转变而退出集成运算,而处于空闲状态.ED算法的形式化描述如算法1所示.算法1.Icegalamera-ED.输入:节点形式背景Ki=(O,Ai,Ii);输出:全局Iceberg概念格珚Lα1.珚Lα2.Levels=log2(NodesNum);3.for(stage=0;stage<Levels;stage++)4.Role←PlayRole(NodesNum,NodeID,Stage);5.ifRole==Server;6.珚Lα7.珚Lα8.珚Lα9.endif10.ifRole==Task11.dest=my_rank12.MPI_Send珚Litodest;13.break;14.endif15.endfor16.ifRole==Server17.珚Lα18.Broadcast珚Lα19.else20.珚Lα21.endif上述算法Icegalamera-ED描述中的Icegalamera和AppositionMerge分别是文献[3]中的Icegalamera算法和其集成函数AppositionMerge.为了充分地利用每个节点上CPU的计算资源,集成构造算法就需要在更小粒度上划分集成计算过程.正是基于这样的考虑,本文提出基于频繁概念直乘分布算法Frecodipd,完成全局Iceberg概念构造同时完成全局闭频繁项集挖掘任务.4频繁概念直乘分布算法为了准确、简洁地描述异构分布式环境下,频繁Page4概念直乘分布算法的集成过程,下面首先给出该过程所涉及到的术语的形式化定义.定义1.异构分布式形式背景.对于一个拥有n个节点的分布式环境,其中每个节点都拥有各自的形式背景Ki=(Oi,Ai,Ii),并且任意两个节点的形式背景Ki和Kj满足Oi=Oj,Ai∩Aj=,那么所有节点的形式背景的集合KD={K1,K2,K3,…,Kn}称之为异构分布式形式背景.其中每个节点的形式背景Ki称之为异构分布式环境下的节点形式背景.而由节点形式背景Ki根据用户指定的某一支持度阈值α所产生的Iceberg概念格称之为节点i的α-节点Iceberg概念格[16],表示为Lαi.Ai∩Aj≠的情况[20]本文不进行深入探讨.另外,由于多值形式背景可以通过标尺技术[1]概念扩展为单值形式背景,因此以下所有形式背景皆为单值形式背景,便于阐述.当然直接泛化地构造概念格[21],然后经过基于支持度α的裁剪得到Iceberg概念格也是可以的.本文只局限于Iceberg概念格分布式环境下并置集成的讨论.下面给出形式背景和Iceberg概念格并置集成操作定义.定义2.异构分布式形式背景并置.对于异构分布式形式背景KD={K1,K2,K3,…,Kn},其节点形式背景两两并置集成[1],得到的形式背景KG=i=0Ai,∪n(O,∪n置,即KG=K1|K2|K3|…|Kn.集成后的形式背景KG称之为异构分布式环境下的全局形式背景.而全局形式背景所对应的Iceberg概念格称之为全局Iceberg概念格,表示为G.全局Iceberg概念格也可以通过节点Iceberg概Lα念格并置构造产生.文献[3]中已经证明了子Iceberg概念格集成所得到的Iceberg概念格Lαm与子Iceberg概念格对应的子形式背景并置后的形式背景所对应的Iceberg概念格Lαk同构,即LαmLαk.也就是说,这里的α节点Iceberg概念格Lαi、Lα的Iceberg概念格Lαi,j与节点i、j的节点形式背景的并置Ki,j所对应的Iceberg概念格LαKi,j同构.定义3.节点Iceberg概念格并置.对于用户指定的某一支持度域值α,由异构分布式形式背景KD={K1,K2,K3,…,Kn}中任意两个节点形式背景Ki=(O,Ai,Ii)和Kj=(O,Aj,Ij)所对应的α节点Iceberg概念格Lαi、Lα点Iceberg概念格Lαi、LαIceberg概念格表示为Lαi,j.因此,异构分布式形式背景KD并置后对应的全局形式背景KG的Iceberg概念格LαG与KD的节点Iceberg概念格并置后的全局Iceberg概念格LαD同构,即LαGLαD.本节的重点就是如何高效地通过节点Iceberg概念格并置构造全局Iceberg概念格.下面详细说明这一过程所涉及到的概念与引理.4.1算法理论框架在Iceberg概念格的并置运算过程中最重要的信息是直乘概念组n及其它的下覆盖,即{n,Covl(n)},n∈Lα×,Lα×=Lαi×Lα射过程中,它们为依次完成3个主要的计算任务提供信息:①进行基于支持度的剪枝,即R(n)α·O;②判断R值等价类的最小元素,即min([n]R);③生成Covl(θ(n))的外延部分.对具体过程感兴趣的读者可以参看文献[3].频繁概念直乘分布算法的提出就是基于以上情况,该算法的基本设计思想为:以子概念格直乘中的直乘概念组n及其它的下覆盖,即{n,Covl(n)},n∈Lα×,作为最小的域分解粒度;每个阶段的集成节点(也就是Server节点,需要接受其它节点的Iceberg概念格)根据它所能控制的空闲节点数划分Lα×,把{n,Covl(n)},n∈Lα×传给任务节点(也就是Task节点);任务节点负责完成上述3个主要的计算任务,再把产生的集成后Iceberg概念格Lαm中的概念c及covl(c)发送到集成节点;集成节点根据概念间的偏序关系构造出完整的Lαm.另一方面,从观察上就可以判定,随着集成的层数增加,Lα×的规模就越大,可利用的空闲节点就越多,任务被并行的程度就越高.这样大大降低了Lα×的规模对算法效用的负面影响,提高了算法的整体性能.根据文献[13]Covl(n)={c1×Covl(c2),Covl(c1)×c2},其中n=c1×c2∈Lα×,Lα×=Lαi×Lαc1∈Lαi,c2∈Lαn∈Lα×可以由Lαi,Lα相乘获得.这样对Lα1×Lα2矩阵的分解,进一步减少通信量和通信次数.使得算法在每级集成过程中,域分解和任务分解以后更加充分地利用空闲节点,大幅度提高了算法的计算效率.而概念c及其下覆盖Covl(c)作为重要的数据结构,构成特定的概念,定义如下.定义4.概念粒度包.由概念c及其下覆盖Covl(c)所组成的集合称之为一个概念粒度包,表示Page5为Bagc.也就是说Bagc(c)={c,Covl(c)}.定义5.概念粒度包集合.对于形式背景K所产生的概念格L=(Ck,),格L中所有概念c所构成的概念粒度包的集合称之为这个概念格L的概念粒度包集合,表示为SBag.即SBag={∪Bagc(c)|c∈L}.因此,概念格L中的概念与其概念粒度包集合中的Bagc之间存在双向映射关系,映射函数定义如下.定义6.函数ν:C→SBag,ν(c)=c∪Covl(c)=Bagc(c),c∈L.定义7.函数ω:SBag→C,ω(Bagc)=Max(Bagc)=c.进一步观察,它们之间的映射关系(ν函数和ω函数)为一对一的映射.因此,概念格L按照计算关系组织的概念粒度包Bagc的集合SBag仍然蕴含格之间的偏序关系.根据Bagc的定义,一个概念粒度包中存在局部偏序关系.这样通过Bagc可以知道c和Covl(c);而偏序关系又具有可传递性;因此,我们不仅可以求出概念格L包含的所有概念Ck,而且可以通过整个形式背景的概念粒度包集合SBag构造出概念格L.引理1.概念格L与其概念粒度包集合SBag同构,即LSBag.证明.(1)L与SBag都是集合;(2)维数相同,L=SBag;(3)上界和下界运算均保持不变,ν(a∨b)=ν(a)∨ν(b),ν(a∧b)=ν(a)∧ν(b);偏序关系保持不变,即abMax(ν(a))Max(ν(b));其中a,b∈L.但是,需要注意的是,Iceberg概念格并置集成运算使用的概念粒度包Bagc是经过基于支持度阈值α剪枝的.那么,这些经过剪枝后的Bagαc以及它们的集合是否保持原有Iceberg概念格的性质呢?下面给出相应的定义和引理.定义8.频繁概念粒度包和频繁概念粒度包集合.对于形式背景K所产生的Iceberg概念格Lα=(CαCovl(c)所构成的集合称之为频繁概念粒度包,表示为BagαLα},半格Lα中所有频繁概念c的频繁概念粒度包c的集合称之为这个Iceberg概念格Lα的频繁概Bagα念粒度包集合,表示为Sαc∈Lα}.c,即BagαIceberg概念格Lα是通过支持度裁剪后的上半格,并没有改变概念格的偏序关系.但是由于只有上半格,所以任意两个概念都存在唯一的上确界,而不一定有下确界,即存在∨运算.Bagαc也是经过支持度裁剪后的概念粒度包,因此函数ν、ω同样适用于Lα和Sα引理2.Iceberg概念格Lα与其频繁概念粒度包集合同构,即LαSα证明.(1)Lα和Sα合;(2)Lα=Sαabmax(ν(a))max(ν(b));a,b∈Lα.证毕.Iceberg概念格的并置集成需要子Iceberg概念格的直乘运算.下面讨论按照计算关系分解后的概念粒度包对直乘运算的影响.引理3.直乘后的Iceberg概念格Lα×与其频繁概念粒度包集合Sα证明.根据文献[10],L×=L1×L2是两个概念格的直乘[1](directproduct),并且是个完备格,所以根据引理1,L×与S×Bag同构;而Lα两个子Iceberg概念格的直乘,又根据引理2,L×与×Bag同构.Sα根据引理3,可以看出按照计算关系组织分解后的概念粒度包并不影响直乘后的Iceberg概念格Lα×.那么,这些子Iceberg概念格按照计算关系组织的概念粒度包集合之间的直乘对子Iceberg概念格之间的直乘产生什么影响?下面的引理给予说明.引理4.ν(Lα证明.假设n=(c1,c2),n∈Lα2,则ν(n)={n,Covl(n)},其中Covl(n)={{(c1,c)Lα|c∈Covl(c2)}∪{(c,c2)|c∈Covl(c1)}};另一方面ν(c1)={c1,Covl(c1)},ν(c2)={c2,Covl(c2)};又因为c1×Covl(c2)={(c1,c)|c∈Covl(c2)},Covl(c1)×c2={(c,c2)|c∈Covl(c1)},所以ν(c1)×ν(c2)=[c1,Covl(c1)]T[c2,Covl(c2)]{c1×c2,c1×Covl(c2),Covl(c1)×c2}=ν(n).根据引理4,Iceberg概念格直乘Lα1、Lα度包集合Sα格Lα得.根据引理2,Sα2=m2.这样,频繁概念直乘分布算法可以在这Lα个m1×m2的矩阵上对n个处理器进行域分解.以上讨论的都是粒度分解对Iceberg概念格并置集成运算之前的概念格、Iceberg概念格及它们之间直乘的影响.下面讨论粒度分解对Iceberg概念Page6格并置集成运算的影响.首先需要说明的是,本文虽然以Iceberg概念格并置为基本的操作,而该过程却是以概念格并置[13]为基础.因此,现将部分概念格集成过程中的函数列出,便于以下讨论与证明.具体详细的解释可参考相应文献.定义9.函数ψ,C×→C[13]:ψ(((X1,Y1),(X2,Y2)))=(X1∩X2,(X1∩X2)).定义10.函数θ,C×→C[3]:θ(((X1,Y1),(X2,Y2)))=(X1∩X2,Y1∪Y2).定义11.函数R,C×→O[13]:R(((X1,Y1),(X2,Y2)))=X1∩X2.函数ψ完成概念格直乘L×的并置集成运算,产生集成后概念格Lm中的形式概念.但是函数ψ需要形式概念分析中的伽罗瓦运算[1].函数θ同样完成概念格直乘L×并置集成运算,但是只有满足min([n]R),n∈C×的概念直乘组经过θ运算后得到的概念才是集成后概念格Lm中的形式概念[3].该函数避免了ψ函数中的伽罗瓦运算,提高了计算效率.函数R是概念直乘组到对象集合的映射,为θ运算提供服务.我们非常关心Iceberg概念格的直乘Lα×的概念粒度集合Sα对应关系,也就是说如何从Sα本文的目标.下面给予说明.引理5.Iceberg概念格的直乘Lα度集合Sα粒度集合Sα证明.根据引理3,Lα置集成后的Iceberg概念格,则根据引理2,LαmBag同构.已证明LαSαmBag同态.Sα根据引理5,按照计算关系对参与集成运算的Iceberg概念格进行分解,并不影响其并置集成运算过程.因此,文献[3]中的关于Iceberg概念格并置集成的运算可以直接应用到Iceberg概念格的概念粒度集合上.这样,Sα义如下.定义12.函数δ,Sαδ(BagαCovl(θ(n))={c|c∈max(ψ(Covl(n))),cα·O},BagαCovl(n)=BagαR(Covl(n)),其中X=Ext(c1)∩Ext(c2).通过δ映射得到集成后的Iceberg概念格Lα概念粒度集合Sα递性,就可以构造出Lα综上所述,两个Iceberg概念格的集成过程2→LαLα1×Lα算关系粒度分解后可以转化为Sα的集成映射过程.具体引理应用和映射过程如下:根据引理2,完成Lα的映射;根据引理4,由Sα据定义12,使用δ函数完成Sα基于以上按照概念粒度包集合SαBag1×Sα置集成映射过程,概念粒度包集合进一步进行域分解,以适应动态的分布式环境.根据引理2、引理4和函数ν的定义,频繁概念粒度包集合的矩阵SαBag2可以由频繁概念矩阵LαSα预先求出放入内存.这样不仅节约了内存,而且同时对Sα个Iceberg概念格直乘(Lα4.2算法描述频繁概念直乘分布算法采用单程序多节点模式,每个节点执行相同的算法.根据节点ID的不同,使用角色分配函数PlayRole在分布集成过程中分配不同的角色.节点根据角色的不同执行相应的任务.角色可以分为服务节点(servernode),任务节点(tasknode)和空闲节点(idlenode).首先各个节点根据各自的节点形式背景独立构造节点Iceberg概念格Lα函数负责全局的Iceberg概念格的集成.该函数实际上也负责了整个分布式集成过程的流程控制.形式化描述如算法2所示.算法2.Frecodipd.输入:节点Iceberg概念格Lα输出:全局Iceberg概念格Lα1.levels←log2n;2.Lα3.for(stage=0;stage<Levels;stage++)4.Role←PlayRole(NodesNum,NodeID,Stage);5.switch(Role)6.caseServer:Page77.sourceList←GetSourceList();8.ReceiveLα9.Lα10.ServerAssign(Lα11.Lα12.Lα13.break;14.caseTask:15.dest=NodeID16.ifNodenotsendedLα17.SendLα18.endif19.DestRole←PlayRole(NodesNum,dest,stage);20.if(DestRole==Server)21.TaskHandle(dest,α·O);22.endif23.break;24.caseidle:25.break;26.endfor27.ifRole==Server28.Lα29.BroadcastLα30.else31.Lα32.endif如果分布式计算环境一共有N个节点,那么就要进行log2(N)级的集成过程.每级集成过程开始时,各个节点独立决定自己的角色.每阶段的服务节点和任务节点数都不同,在同一级中,服务节点和它所支配的任务节点可以组成独立的计算单元.但是当集成进入下一阶段,计算单元合并时就需要同步了.不过参与同步的仅仅是所要合并的计算单元的服务节点,并不影响其它节点.服务节点负责根据它所支配的任务节点数(sourceList)划分Lα阵,发送给相应的任务节点.这个任务划分过程由ServerAssign函数负责,描述如下.函数1.ServerAssign.输入:节点Iceberg概念格Lα输出:Null1.P←DivideLα2.index←0;3.foreach(subLα4.dest←sourecList(index++);5.Send(v(subLα6.endfor各个任务节点接收到数据后总体上实际负责完Bag1×Sα成Sα据各自发回给相应的服务节点.这部分任务的函数是TaskHandle,描述如下.函数2.TaskHandle.输入:计算后返回数据的目标节点dest;输出:Null1.ReceiveSα2.foreachPartSα3.PartSα4.endfor5.SendPartSα服务节点从各自所支配的任务节点接收到mBag(所有PartSαPartSα函数ω和偏序关系的传递性完成Sα射.ServerCollect函数描述如下.函数3.ServerCollect.输入:任务节点列表sourceList输出:集成后的Iceberg概念格Lα1.foreachId∈sourceList2.Sα3.endfor4.foreachBagα5.Lα6.endfor这样服务节点就得到了本阶段的Iceberg概念格Lαmiddle.Lα任务节点所拥有的节点形式背景并置所对应的Iceberg概念格.当stage==log2(N)时,就意味着服务节点计算得到了全局Iceberg概念格Lα后,服务节点发送Lα务节点接收到Lα另外,函数PlayRole和GetSourceList对整个算法非常重要.不同的角色分配策略将导致不同的流程模式,需要相应的GetSourceList函数配合.它们都是以分布式环境下的总节点数、本节点的ID和集成阶段这些公共信息作为输入的参数.每个节点独立决策,没有交互过程,这样大大减少了通信的代价.下面分别给出它们的描述.函数4.PlayRole.输入:分布式环境下总节点数NodesNum;Page8输出:角色类型Role1.if(NodeId%(2<<stage)==0)2.if(NodesNum>(NodeId+(1<<stage)))3.Role←Server;4.else5.Role←Idle;6.endif7.else8.Role←Task;9.endif实际上服务节点也可以参与TaskHandle的任务运算,只需要在生成的资源列表中加入相应的服务节点ID,并且把TaskHandle函数加入到Frecodipd函数中的Server情形中.本文为了讨论的方便,不再考虑这种计算模式.GetSourceList函数描述如下.函数5.GetSourceList.输入:分布式环境下总节点数NodesNum;输出:任务节点列表sourceList.1.start←NodeId+1;2.end=NodeId+(2<<stage);3.end=(end>NodesNum)?NodesNum:end;4.for(index=start;index<end;index++)5.sourceList←index;6.endfor函数PlayRole和GetSourceList使得Frecodipd算法的集成树与ED算法的集成树相同.下面例2说明7个节点情况下的Frecodipd算法集成情况.例2.如果分布式概念格有7个节点,两两并置集成分配情况如图3所示:在阶段0各个节点独立完成节点Iceberg概念格的并置集成任务;阶段1~3逐级完成节点间的Iceberg概念格分布式并置集成,最终得到全局Iceberg概念格,其中○为Server节点,●为Task节点,△为Idle.与例1比较发现,在同样分布式集成环境下(7个节点),Frecodipd算法充分利用了集成过程中的空闲节点,可以推断Frecodipd算法具有更好的分布式计算效率.5实验与结果分析我们使用STL和MPI(Messagepassinginter-face)在GNU环境下用C++语言分别实现了Icegalamera,Icegalamera-ED和Frecodipd算法.数据集采用了UCI的HouseVotes84、mushroom和由IBM数据产生器产生的稀疏数据集T25I1D10K.数据集具体说明如下:(1)数据集1:UCI数据集HouseVoting84(1984UnitedStatesCongressionalVotingRecordsDatabase).原始数据集有17个属性,概念扩展(conceptualscaling)后有34个属性,435个事务.(2)数据集2:UCI数据集mushroom.原始数据集有22个属性,概念扩展(conceptualscaling)后有8124个事务,128个属性.(3)数据集3:T25I1D10K测试数据由IBM数据产成器产生,数据集含有10000个事务,1000个属性项,每个事务平均拥有25个属性.在使用数据集1和2的情况下,支持度测试点选择0.9、0.8、0.7、0.6、0.5、0.4、0.2、0.1;在数据集3的情况下,支持度测试点选择0.1、0.05、0.03、0.02、0.01、0.008、0.005、0.003;分布式挖掘时,测试节点个数分别为2、4、5、6、8、10;数据集需要进行预处理,相应地拆分为以上节点情况的异构分布式数据集.整个实验是分为集中式挖掘和分布式挖掘.集中式挖掘是为了获得串行算法的性能指标,最终用来计算分布式算法的执行性能加速比,由Icegal-amera算法分别在数据集1、2、3上集中挖掘,获得不同支持度下Iceberg概念格的大小(如图4、图5所示)和执行时间;分布式挖掘使用Icegalamera-ED算法与Frecodipd算法对比,分别在不同节点和不同支持度情况下,分别获得执行时间、通信量和Iceberg概念格的大小(同样数据集和同样支持度情况下,无论节点多少最终产生的Iceberg概念格大小是相同的,这可以用于算法正确性检查).下面就对实验结果进行说明和分析.从图4我们可以看出,由于数据集1是稠密数据集,其Iceberg概念格大小随支持度的减少成指数倍增加的趋势明显,在0.1的支持度下产生的Iceberg概念格包含45817个概念;而数据集2本来是稠密数据集,但在预处理时由于通过概念扩展,数Page9据集的密度大大降低,从而使其呈现稀疏数据集的特性,在0.1的支持度下产生的Iceberg概念格包含4885个概念.图4不同支持度下Iceberg概念格的大小(数据集1和数据集2)数据集3是稀疏数据集,当支持度足够小时,其Iceberg概念格大小随支持度的减少而成指数倍增加的趋势明显,如图5所示.图5不同支持度下Iceberg概念格的大小(数据集3)由于ED和Frecodipd的执行时间性能数据是在不同数据集、不同节点、不同支持度情况下获得的.在这里这两种算法的时间性能数据在3种数据集下,分别都是1个6×8的矩阵(6种节点情况,8种支持度参数).矩阵的每列数据分别除以相应数据集下Icegalamera算法对应支持度的时间性能,就得到这两个算法在相应数据集、相同支持度下,不同节点的时间性能加速比;照此依次计算每种支持度参数,最终得到3个不同节点、不同支持度情况下的6×8加速比矩阵.在分布式环境下,我们更关心的是不同节点情况下的时间性能如何,因此,对加速比矩阵相同节点、不同支持度的加速比求算术平均,即对矩阵的每一行求平均,最终得到3个6维平均加速比向量,分别对应3个数据集.其实从统计的角度来看,求得相同节点情况下时间性能的平均加速比,更能反映在这种节点情况下算法的执行性能.下面就分别说明ED和Frecodipd算法在3个数据集上的性能表现.如图6所示,在稠密数据集上当节点数增多时,ED和Frecodipd的性能均出现下降的趋势,ED算法尤其突出,甚至出现了10个节点情况下的性能不如2个节点下的性能.每种节点环境下均进行了相同的多种支持度参数的挖掘过程,那么出现这种情况的原因主要是通信量;下面我们看看数据集1情况下的通信量.如图7所示.图6不同节点情况平均加速比S(n)(数据集1)图7不同节点情况下的通信量对比(数据集1)因为对通信量的影响主要是Iceberg概念格的大小,所以我们主要看支持度为0.2、0.1时不同节点环境下通信量的变化.如图7所示,无论是ED还是Frecodipd算法,其通信量都与节点个数成正比,与支持度成反比.Frecodipd的通信量大小对支持度要比ED敏感;相同支持度下Frecodipd算法的通信量大于ED算法.由于Frecodipd算法即使在整体的通信量比ED大的情况下,平均加速比依然优于ED,可以判定Frecodipd算法优于ED.另外在稠密数据集下,由于Iceberg概念格的增长速度过快,使得通信量的负荷过大,影响了其分布式计算性能.如图8所示,在数据集2上,无论ED还是Frecodipd都体现出分布式性能的提升;Frecodipd的性能尤其突出.另一方面,从图中可以看出,两个算法都在节点5、10时出现平均加速比与各自前者Page10节点相比略微下降的情况,这是因为集成树各自增加了一层.在相同集成层次的节点情况下(如5、6、8都为3层),平均加速比与节点的多少成正比.虽然集成的层次对性能有影响,但是整体上随着节点的增加平均加速比逐渐增大.集成层次的影响也是由于多了一层集成过程而通信量随之增大引起的.图8相同节点情况不同支持度平均加速比(数据集2)ED和Frecodipd算法在数据集2不同节点以及0.1、0.2支持度情况下的通信量(如图9所示)除了总量明显小于数据集1以外(这是因为相同支持度下数据集1产生的Iceberg概念格大于数据集2产生的Iceberg概念格),其变化趋势与数据集1相同.另外图9与图8对比可以看出,当通信量增幅对算法性能的负面影响大于节点增加对性能提升的正面影响时,算法的整体性能随之下降.图9不同节点情况下的通信量对比(数据集2)因为数据集3是稀疏数据集,如图10所示,两种算法的分布式性能表现介于前两个数据集之间,变化趋势也相同,只是平均加速比的增加趋势平缓,这与稀疏数据集概念格产生的特性相关(概念的多少随着形式背景的增大更趋近于多项式级增加).如图11所示,在数据集3上ED和Frecodipd算法的通信总量也介于前两个数据集之间;另一方面,通信量的变化趋势也很平缓.整体的变化趋势与前两个数据集相同.图10相同节点情况不同支持度平均加速比(数据集3)图11不同节点情况下的通信量对比(数据集3)下面比较相同节点、不同支持度下ED和Frecodipd算法的通信量.如下图12所示,数据集2情况下,节点2和节点10,在不同支持度下的通信量与以上描述的变化趋势相同.这进一步验证了通信量的大小与节点成正比与支持度成反比的结论.图12不同支持度情况下的通信量对比(数据集2)综上所述,无论是稠密数据集还是稀疏数据集,Frecodipd算法在分布式执行性能上都优于Icegal-amera的分布式版本ED算法.其性能与节点成正比与通信量成反比.Frecodipd算法的理论基础和流程就决定着其通信量必定大于ED算法,即使如此,其加速比也高于ED算法;反之,如果尽可能地减少Page11通信量,那么将大大提高Frecodipd算法的性能.6结论通过以上的理论论证和实验验证,全局闭频繁项集的挖掘可以通过分布式构造全局的Iceberg概念格来实现.在基于频繁概念直乘分布的全局Ice-berg概念格构造过程中,因为以频繁概念直乘及其下覆盖作为最小的域分解粒度,使得节点Iceberg在集成时可以充分利用空闲节点的计算资源,从而大大提高了构造全局Iceberg概念格的效率,最终达到了提高全局闭频繁项集的挖掘性能.另外,Frecodipd算法本身还有待改进,比如,概念压缩表示、矩阵的棋盘划分(目前使用带状划分)等等.
