Page1基于上下文偏好的Web数据库查询结果Top-犓排序方法孟祥福1)马宗民2)李昕3)张霄雁1)王星1)1)(辽宁工程技术大学电子与信息工程学院辽宁葫芦岛125105)2)(东北大学信息科学与工程学院沈阳110819)3)(辽宁工业大学计算中心辽宁锦州121001)摘要为了解决Web数据库多查询结果的问题,该文提出了一种基于上下文偏好的查询结果top-k排序方法.首先提出了一种带偏好程度的上下文偏好模型:i1i2,d|X,表示在上下文条件X下,项i1与i2相比,用户偏好项i1的程度为d(0.5d1),带偏好程度的上下文偏好通过在查询历史中使用关联规则挖掘获得.基于上下文偏好,提出了一种查询结果top-k排序方法,给出了相应的元组排列创建、聚类和top-k排序算法.实验结果表明,提出的上下文偏好模型具有较强的偏好表达能力,top-k排序方法能够较好地满足用户需求和偏好并且具有较高的执行效率.关键词Web数据库;上下文偏好;元组聚类;top-k排序1引言随着Internet的普遍应用和Web数据库中蕴含信息量的快速增长,访问Web数据库已成为人们获取信息的重要手段[1].由于Web数据库通常蕴含海量数据,如果用户查询不很严格,则会导致多查询结果的问题,这种情况下大多数用户希望Web数据库查询系统能够对查询结果进行排序,并且快速返回前k个最为相关的结果.因此,查询结果top-k排序方法的研究具有十分重要的意义.近年来,一些研究者提出了基于用户偏好的查询结果排序方法[2-6].这些方法在排序中考虑了用户偏好,但却没有考虑产生偏好的上下文条件,而实际上用户偏好与上下文密切相关,在不同的上下文条件下,偏好及其程度通常有所不同;文献[7-8]的排序方法考虑了用户偏好的上下文条件,但偏好模型只能表达二元偏序关系而不能体现出偏好程度,这将导致大量偏好共存的情况下,很难协调多个偏好之间的矛盾.本文提出一种带偏好程度的上下文偏好(简称上下文偏好)模型,其形式为i1i2,d|X,表示在上下文条件X下,项i1与i2相比,用户偏好项i1的程度为d(0.5d1).下面给出一个上下文偏好例子.例1.给定一个来自Yahoo网站的二手汽车销售数据库,其关系模式为CarDB(Make,Model,Price,Color,Engine,Year,Mileage),CarDB中的每条元组代表一个二手车.对于CarDB,假设有如下上下文偏好:{Model=AccordModel=Camry,0.6|Price{Model=CamryModel=Accord,0.8|Price上述偏好表明,在“价格为13000~15000美元”的情况下,Accord与Camry相比,Accord更受偏好(程度为0.6);在“价格为10000~12000美元”的情况下,Camry更受偏好(程度为0.8).该例说明在不同上下文条件下,人们对某个实体的偏好及其程度是不同的,因此实体的排序与产生偏好的上下文条件密切相关.本文利用带偏好程度的上下文偏好对查询结果进行top-k排序.该方法分为两个处理阶段:在离线处理阶段中,利用关联规则从Web数据库系统的查询历史(queryhistory)中获取用户的上下文偏好,这些偏好用于创建元组预排列,然后通过聚类方法保留其中少数代表性排列,每个代表性排列对应一个上下文集合.在在线处理阶段中,对于一个给定查询,首先评估该查询与上下文条件集合之间的相似性,然后利用阈值算法(ThresholdAlgorithm,TA)快速提供尽可能满足代表性排列的top-k个有序查询结果.对于一个大型Web数据库来说,通常会存在大量的上下文偏好并且偏好之间可能存在回路和矛盾.这种情况下,对于查询结果的排序处理,一方面需要协调上下文偏好之间的矛盾,另一方面还要考虑如何在大量偏好共存的情况下确保排序的执行效率.本文第2节介绍相关工作;第3节定义上下文偏好,给出上下文偏好的获取和处理方法;第4节定义查询结果排序问题并给出解决方案;第5节给出查询结果top-k排序的实现算法;第6节是性能与效果实验评价;第7节是结论与展望.2相关工作工作可分为如下几类:Web数据库查询结果排序方法的代表性研究(1)基于用户相关反馈的排序方法.文献[9-12]利用用户相关反馈评估查询与结果之间的相似度并以此对查询结果进行排序.相关反馈在一定程度上体现了用户偏好,但用户偏好的表达受到了很大限制(如用户偏好只能用简单模糊词标记元组或属性的方式表达),并且反馈过程需要用户参与,从而导致查询效率不高.(2)基于显式用户偏好的排序方法.用户偏好的表示方法可分为两种:一种是定性方法,元组之间的偏好关系直接以二元偏序关系表示;另一种是定量方法,元组之间的偏序关系通过对元组打分而间接体现.Kieβling[13]首次提出了定性偏好模型,该模型定义了基本偏好构造符以及由它们构成的复杂偏好.Chomicki[14]使用了一套完整的逻辑框架实现偏好的形式化表示并将其嵌入到结构化查询语言中.文献[15]在现有定性偏好模型基础上提出了定性偏好的表示与推理方法,能够表示复杂偏好关系并能对偏好之间的隐含关系进行推理.Koutrika等人[16-18]提出了定量偏好模型,允许用户在每个属性值上关联一对数值表达其原子偏好,通过原子偏好的结合可实现复杂偏好的表达.文献[19-20]在定量用户偏好模型基础上提出了关系数据库(特别是高维情况下)的top-k个性化查询方Page3法.上述偏好表示与处理方法为后续研究和实际应用奠定了坚实基础.然而,定性和定量方法都存在各自不足,定性方法使用二元偏好关系表达偏好的方式过于严格并且不能体现偏好程度,定量方法使用打分函数定义的偏好关系虽能够体现偏好程度,但一些复杂的偏好关系又很难通过打分函数捕获.此外,现实中显式的用户偏好很难获取,因为用户不想或根本不能准确指定他们的偏好(如果他们能够准确表达偏好,那么就能形成合适的查询,进而也就无需对查询结果进行排序和分类)[21].基于上述原因,挖掘隐式用户偏好并以此对查询结果进行排序的研究开始受到研究者的关注.(3)基于隐式用户偏好的排序方法.文献[2]提出了在查询历史中挖掘隐式用户偏好对查询结果进行排序的方法;文献[3]在查询历史中利用概率信息检索模型挖掘隐式用户偏好,然后根据以往用户在未指定属性上的偏好区分多个查询结果元组;文献[22]认为用户对于结果元组的相关性评估通常需要综合考虑多个属性(包括被查询指定的属性和未被查询指定的属性),提出了一种基于KL距离的查询结果排序方法.文献[23-24]从查询历史中利用关联规则挖掘隐式用户偏好,然后根据用户偏好和数据内容对数据库中的元组进行归类并提取各类数据的特征信息,最后根据特征信息与用户偏好之间的相关性对查询结果排序.文献[25]从查询历史、用户背景信息以及用户与系统之间的交互动作中获取隐式用户偏好并以此对关键字查询结果进行排序.(4)Top-k检索方法.近年来与排序密切相关的top-k检索技术得到了广泛而深入的研究.top-k检索的目标是从大量查询结果中快速检索到与当前查询最为相关的前k个结果.为了实现高效的top-k检索,Fagin等人[26]首先提出了阈值算法(ThresholdAlgorithm,TA),该算法的最大特点是不需要检查所有结果元组就能够快速识别出前k个具有最高排序分数的结果元组.文献[27-30]研究了大规模数据下基于用户偏好和TA算法的top-k检索方法.Top-k排序问题还在Web信息检索[31]、不确定/概率数据库查询[32-33]以及XML查询[34]背景下也得到了广泛的研究与讨论,相应地也有多种实现算法被提出.文献[35]对top-k检索技术作出了详细的分析和总结.通过对上述排序工作的分析可以发现,虽然已有大量的研究工作致力于用户偏好的表示与处理,但显式用户偏好很难应用到实际中,挖掘隐式用户偏好并将其应用到查询结果排序中的研究最近几年逐渐增多,但这些方法在偏好的表示与处理以及结合偏好的查询结果排序算法的执行效率等方面大都存在各自的不足.3上下文偏好3.1上下文偏好定义定义1.上下文偏好.给定关系模式R(A1,A2,…,Am),包含n条元组{t1,t2,…,tn},Dom(Ai)为属性Ai的值域,为R上的偏序关系,则称为R上的上下文偏好,其中X=∧j∈l(Ajθaj),ai1,ai2∈Dom(Ai),l{1,2,…,m},θ∈{>,<,=,≠,,,between}且aj∈Dom(Aj),d代表偏好程度(即项ai1与ai2相比,用户偏好项ai1的程度为d(0.5d1).任给一个偏好p和关系表R中的一对元组(ti,tj),根据偏好p,元组ti和tj之间存在3种关系:(1)元组ti比tj更受偏好,用titj表示;(2)元组tj比ti更受偏好,用tjti表示;(3)元组ti和tj不存在偏好关系,用ti~tj表示.因此,偏好p定义在任意一对元组(t,t)上的偏好程度dpref可表示成其中,d表示t与t相比,t受偏好的程度.3.2上下文偏好获取本文通过在Web数据库查询系统的查询历史上使用关联规则获取上下文偏好.查询历史是以往使用过系统的用户提交过的查询记录集合,可看成是一个关系表,其中包含了多条历史查询记录.上下文偏好的获取方法为:如果Conf(Xa)>Conf(Xb),则其中,Conf(Xa)是指在查询历史关系表中属性值a在上下文条件X下出现的概率(也就是关联规则Xa的信任度),即Conf(Xa)=Sup(X∪a)Sup(X∪a)是指在查询历史关系表中属性值a与上下文条件X共同出现的概率.式(3)表明,当Page4d>0.5时,说明在上下文条件X下,属性值a比b更受偏好,受偏好的程度为d.例2.给定关系表CarDB,假设CarDB中包含了表1所示的元组并存在如下的上下文偏好.TidModelColorEngine/LMakePriceYeart1AccordSilver2.4Honda309992008t2AccordBlue3.5Honda319992007t3CR-VBlack3.0Honda325002007t4CamryBlue3.5Toyota229992007t5MatrixGray3.3Toyota239992007p1={Model=AccordModel=CR-V,0.7|Make=Honda∧Pricebetween30000and33000}p2={Color=SliverColor=Black,0.6|Make=Honda∧Pricebetween30000and33000}p3={Engine=3.0LEngine=2.4L,0.9|Make=Honda∧Pricebetween30000and33000}p4={Model=CamryModel=Matrix,0.8|Make=Toyota∧Pricebetween22000and25000}偏好p1表明,在上下文条件“Make=Honda∧Pricebetween30000and33000”下,元组t1和t2比t3更受偏好,t1和t2受偏好的程度为0.7;在相同的上下文条件下,p2表明t1比t3更受偏好,t1受偏好的程度为0.6;p3表明t3比t1更受偏好,t3受偏好的程度为0.9;在上下文条件“Make=Toyota∧Pricebetween22000and25000”下,p4表明t4比t5更受偏好,t4受偏好的程度为0.8.3.3偏好类划分对于任意两个上下文条件X1=∧j∈l1(Ajθaj)和X2=∧j∈l2(Ajθbj),l1,l2{1,2,…,m},当且仅当l1=l2=l并对于j∈l,θaj=θbj时,称上下文条件X1和X2等价.对于两个偏好p1={Ai=ai1Ai=ai2,d1|X1}和p2={Aj=aj1Aj=aj2,d2|X2},如果X1=X2=X,则称p1和p2属于同一个偏好类.同一个偏好类中,所有偏好的上下文条件都相同,本文用X表示某个偏好类的上下文条件,PX表示相应的偏好类.例如,假设上下文条件X1={Make=Honda∧Pricebetween30000and33000},X2={Make=Toyota∧Pricebetween22000and25000},则偏好p1,p2和p3都属于偏好类PX1,而偏好p4属于偏好类PX2.一个偏好类PX将关系表中的所有元组分成两个集合:一个是与偏好类相关的元组集合,另一是与偏好类无关的元组集合.对于元组t,如果p∈PX,使得t≠t,dpref(t,t,p)≠⊥,则称t与偏好类PX相关;对于元组t,如果p∈PX,使得t≠t,dpref(t,t,p)=⊥∧dpref(t,t,p)=⊥,则称t与偏好类PX无关.在一个偏好类中,如果存在一个或多个偏好显式地把元组t与其他元组相比较,那么t与该偏好类相关;否则,t与该偏好类无关.例如,表1中的元组t1,t2和t3明确地被偏好类PX1中的一个或多个偏好所指定,则t1,t2,t3是与偏好类PX1相关的元组,而t4则是无关元组.3.4有效偏好支持度虽然根据偏好可以确定元组之间的排序关系,但由于用户对于不同元组的偏好程度存在差别,因此需要量化偏好p定义在一对元组上的偏好程度及其在偏好类中的重要程度.对于任意一对元组(t,t),偏好类PX中的偏好为其定义了有效偏好支持度Peff-p(t,t,PX),表示偏好类PX中的一个偏好支持tt的程度在PX中所有偏好支持下所占的比例.下面分3种情况讨论:(1)对于任意一对元组(t,t),若p∈PX,使得dpref(t,t,p)+dpref(t,t,p)=1,则Peff-p(t,t,PX)=∑p∈PX(2)对于任意一对元组(t,t),若/p∈PX,使得dpref(t,t,p)+dpref(t,t,p)=1,则Peff-p(t,t,PX)=Peff-p(t,t,PX)=1(3)对于任意一对元组(t,t),若t和t在PX下不存在偏好关系,则以表1所示CarDB上的偏好类PX为例,这里X={Make=Honda∧Pricebetween30000and33000},按照上述计算方法,可得元组的有效偏好支持度为:(1)Peff-p(t1,t2,PX)=Peff-p(t2,t1,PX)=1/2;该情况表明,虽然元组t1和t2是PX所涉及的元组,但PX中并不存在明确指定在这两个元组任何属性值上的偏好.(2)Peff-p(t1,t3,PX)=(0.7+0.6+0.1)/3=7/15,Peff-p(t3,t1,PX)=(0.3+0.4+0.9)/3=8/15;该情况表明,虽然p1和p2都表明元组t1比t3更受偏好,只有p3表明t3比t1更受偏好,但有效偏好支持度却表明t3比t1更受偏好,这是因为每个偏Page5好的程度不同,偏好程度对调节多个偏好之间的矛盾起着重要作用.3/10.(3)Peff-p(t2,t3,PX)=7/10,Peff-p(t3,t2,PX)=(4)对于所有其他元组,Peff-p(…,…,PX)=⊥.上述情况表明,对于任意一对与偏好类PX相关的元组(t,t),如果它们之间存在偏好关系,则Peff-p(t,t,PX)的值介于[0,1]之间;否则,表示用户对元组t和t的偏好程度是相同的,规定其有效偏好支持度为1/2.3.5偏好关系图根据元组之间的偏好关系,属于同一偏好类的元组可构成一个偏好关系图.给定关系R和其上的一个偏好类PX,偏好关系图GX(VX,EX)可定义为:节点是由关系R中所有与PX中的偏好相关的元组构成,对于每一个节点有序对(t,t),存在一条带有权重的有向边e(t→t)∈EX,边的权重为且wX(t→t)+wX(t→t)=1图1给出了在上下文条件X={Make=Honda∧Pricebetween30000and33000}下,偏好p1,p2和p3在关系表CarDB上的偏好关系图(偏好类PX中的偏好不涉及到元组t4和t5).4Top-犽排序本节首先定义查询结果排序问题,然后提出基于上下文偏好的查询结果top-k排序解决方案.4.1排序问题定义给定关系模式R(A1,A2,…,Am),包含元组{t1,t2,…,tn},令R上的一个合取查询为Q=σ∧j∈{1,2,…,k}Cj,其中Cj代表一个基本查询条件,并且km,Q(R)R是R上满足查询Q的结果元组.本文要解决的问题是根据上下文偏好对查询结果进行排序,问题定义如下.问题1.查询结果排序问题:给定关系R上的一个偏好集合Π={PX1,…,PXm}和一个合取查询Q,找出在查询结果集Q(R)上的一个排列τ,使得τ=argmaxτ∑m其中,Agree(τ,PX)=∑(t,t):τ(t)<τ(t)Peff-p(t,t,PX).式(7)的含义是找到一个对于查询结果的排列τ,使其尽最大可能满足所有偏好.排列τ对偏好的满足程度受到偏好所基于的上下文条件X与查询Q之间的相似度影响.为了解决问题1,需要量化查询Q与上下文条件X之间的相似度.首先构造向量空间模型:统计关系R中所有不同的〈属性,值〉,它们构成了集合Δ={〈Ai,a〉|i∈{1,2,…,m}且a∈Dom(Ai)}.由于Dom(Ai)是属性Ai的值域,所以集合Δ的基数为有限集,故可令N=|Δ|,即集合Δ中所有不同〈属性,值〉的个数.令OD是对于Δ中所有〈属性,值〉的一个随机排列,在该排列中每个〈属性,值〉都有一个固定位置,用Δ[i]表示Δ中按OD排列的第i个元素.基于此,分别构造X和Q的向量表示.X=∧j∈l(Ajθaj)的向量表示是一个包含N个元素的二元向量犞X,向量犞X中的第i个元素对应Δ中的〈属性,值〉Δ[i].如果Δ[i]满足X中的一个基本条件,则VX[i]=1;否则VX[i]=0.同理,Q的向量表示是一个包含N个元素的二元向量犞Q,向量犞Q的第i个元素对应OD中的〈属性,值〉Δ[i].如果Δ[i]满足Q中的一个基本条件,则VQ[i]=1;否则VQ[i]=0.下面根据下式计算X与Q之间的相似度:在此基础上,查询Q和上下文条件集合χ之间的相似度定义为利用式(7)对查询结果元组进行排序,对于关系R中的每一对元组,任何算法都需要遍历所有偏好.假设R中包含n条元组,m条偏好,则算法的时间复杂度为O(n22m),即指数级的.由此可见,对于一个包含海量数据并且具有大量偏好的Web数据库来说,这样的时间复杂度是不可接受的,为此本文基于文献[7]提出如下解决方案.Page64.2解决方案解决方案分为3个步骤:元组排列创建、元组排列聚类(选取代表性排列)和top-k排序.前两个步骤在离线阶段完成,在线阶段进行top-k排序.步骤1.对于每个偏好类PXi,从R中找出一个对于相关元组的排列τi,使其满足对于m个不同的偏好类,该步输出一个包含m个〈上下文,排列〉的集合,这里把〈上下文,排列〉表示为〈Xi,τi〉,其中Xi是偏好的上下文条件,τi是(近似)满足式(10)的一个元组排列.根据输出的元组排列,每个元组t在它对应的排列τi中都具有一个与其位置相关的排序分值,即元组t在排列τi(τi对应于上下文条件Xi)中的排序分值为其中,τi(t)代表t在τi中的位置.步骤2.为了减少步骤1输出的〈Xi,τi〉个数,从m个最初的〈Xi,τi〉集合中,找出l个代表性排列2,…,τ-1,τ-τ-集合划分成l个子集,每个子集i可由排列τ-交的上下文条件集合珡Xi{X1,X2,…,Xm}表示,使得对于任一Xj∈珡Xi,排列τi是对原始排列τi的最佳替代.选取代表性排列问题也可看成是排列聚类问题.对于代表性排列τ-i(t)代表t在τ-其中,τ-步骤3.对于给定查询Q,使用步骤2的输出,得到查询结果Qk(R)Q(R)R,其中|Qk(R)|=k,使得对于t∈Qk(R)和t∈(R-Qk(R)),都有Score(t,Q)>Score(t,Q),其中,Score(t,Q)代表元组t对于查询Q的最终排序分值,定义为Score(t,Q)=∑珡Xi5实现算法5.1元组排列创建考虑最大无环子图问题,对于一个加权有向图G,从中找出具有最大权重的无环子图是一个NP-hard问题.实质上,通过偏好关系图,可将创建元组排列问题与发现最大无环子图问题联系到一起.对于一个给定的偏好关系图GX(R,EX),找出关系R={t1,t2,…,tn}上所有元组的一个排列τ,该排列能够产生一个无环子图GT(V,ET),使得ET中边的权重之和最大.这是一个在偏好关系图GX上发现最大无环子图的问题,因此创建元组排列问题与发现最大无环子图问题属于同类问题.在一个加权有向图上发现最大无环子图问题是一个NP-hard问题.由于最大无环子图问题既满足最优子结构性质也满足贪心选择性质,因此采用贪心算法解决元组排列创建问题.算法1.创建元组排列的贪心算法.输入:关系R={t1,t2,…,tn},偏好类PX输出:〈X,τ〉,其中τ是对于R中与偏好类PX相关元组1.S={t1,t2,…,tn}2.rank=03.FORALLi∈{1,2,…,n}DO4.p(ti)=∑n5.ENDFOR6.WHILES≠DO7.rank+=18.tv=argmaxtu∈Sp(tu)9.τ(tv)=rank10.S=S-{tv}11.FORALLt∈SDO12.p(t)=p(t)-wX(t→tv)13.ENDFOR14.ENDWHILE算法1首先计算每条元组ti(即在偏好关系图中的节点)在给定偏好类下的出度之和p(ti)(第3~4步),这里称为综合偏好程度.元组的综合偏好程度越大,说明它对这个偏好类下所有偏好的满足程度越大,在排列中的位置就越靠前.然后,循环计算每条元组的排序分值,每次循环首先选出剩余元组中具有最大综合偏好程度的元组tv(第8步),并赋予一个排序分值(第9步),接下来把tv从元组集合中去除(第10步),重新计算每条剩余元组的综合偏好程度(第11~13步),重复上述过程,直到所有元组都被选出为止.每次重新计算综合偏好程度时,每条剩余元组都要减去它对上一次选出元组的出度.该算法的时间复杂度为O(n2),其中n为关系R中与偏好类PX相关的元组数.5.2元组排列聚类5.2.1元组排列聚类问题由于欧式距离是常用的向量之间距离的评估方法,因此这里使用欧式距离来衡量在相同元组集合上的两个排列τ和ρ之间的距离,dE代表距离函数:Page7根据欧式距离的性质可知,dE满足三角不等式,即如果τ1,τ2和τ3是任意3个在n个对象上的排列,则如下不等式成立基于上述定义,步骤2中的元组排列聚类问题可定义为:假设输入由m个〈Xi,τi〉构成,令Tm是在R元组上的m个排列的集合:Tm={τ1,τ2,…,τm},在Tm中选取l个排列Tl={τ-最小.一个排列τ与排列集合T之间的距离定义为d(τ,T)=minρ∈Td(τ,ρ).式(15)Tl中的排列称为代表性排列,并且每个代表性排列τ-合珡Xj相关联:5.2.2元组排列聚类算法排列聚类问题实质上是k-median问题,观察k-median问题的解会发现,解中的任意单个代表性元组排列均与Tm中的若干个其他排列(用集合珡Ti表示)连接,它们的连接关系类似星形结构,称其为Star[36].在此基础上,用如下方法解决元组排列聚类问题:令U是对于Tm中所有排列的Star集合,即U={〈τi,珡Ti〉|τi∈Tm,珡TiTm}.每个Stars〈τi,珡Ti〉∈U的代价表示为cs=∑τj∈珚Ti表性价比.问题的目标是,寻找价值之和最小的一组Star集合S(SU),使得S中至多出现l个不同的代表性元组排列,且保证任一原始排列τj∈Tm至少出现在一个Stars∈S中.在求解前,需要有一个预处理步骤,预先为Tm上的每个排列τi∈Tm构建一个有序序列li={τi1,τi2,…,τim},其中li中的排列依照它与τi之间连接代价由小到大排列,即dE(τi,τi1)dE(τi,τi2)…dE(τi,τim),这样在建立所有Star的集合U时就不必处理所有的组合,只需处理代价较小的前i个Star即可(i可以由阈值确定).预处理算法时间复杂度是O(m2logm),其中|Tm|=m.算法2.元组排列聚类算法(Greedy-RF算法).输入:原始排列集合Tm={τ1,τ2,…,τm},U={〈τi,珚Ti〉|输出:l个代表性排列的集合Tl={〈τ-1,珚T1〉…〈τ-l,珚Tl〉}1.令B={}为一个能够存储m个〈τi,珚Ti〉的缓存2.WHILE(Tm≠∧l>0)DO3.B←4.FORALLτi∈TmDO5.从Ui={〈τi,珚Ti〉|珚TiTm,|珚Ti|=[2,|Tm|-6.B←B+{si}7.ENDFOR8.从B中选出具有最小rs的s=〈τi,珚Ti〉9.Tm←Tm-珚Ti-{τi}10.Tl←Tl+s11.l←l-112.ENDWHILE13.RETURNTl该算法把输入的m个原始排列作为候选代表性排列;然后,每次循环都从当前的候选代表性排列中移除一个对总代价增长影响最小的排列;当找出的代表性排列个数为l或集合Tm为空集时,算法停止.在返回的结果集中,每个代表性排列都对应一个它所代表的排列集合和相应的上下文集合.经过预处理后聚类算法时间复杂度为O(ml),其中m为原始排列数,l为代表性排列数.除了上述方法,使用反贪心算法也可获得代表性排列.Furthest算法的基本思想是:从原始排列中随机选取一个排列作为代表性排列,并将其从原始排列中移除;然后,从剩余排列中找出与上一次移除的排列距离最大的排列作为下一个代表性排列,循环执行此过程直到l个代表性排列全部找到;最后,对于剩余的每一个原始排列,把它分配给代表性排列中与其距离最小的那个排列.算法3.元组排列聚类的反贪心算法———Furthest.输入:原始排列集合Tm={τ1,τ2,…,τm}输出:l个代表性排列的集合Tl={τ-1,τ-2,…,τ-l}1.Tl≠2.从Tm中随机选取一个排列τ-3.Tl←Tl∪{τ-}4.Tm←Tm-{τ-}5.FORi=1tol-1DO6.τ-=argmaxτd(τ,Tl)7.Tl←Tl∪{τ-}8.Tm←Tm-{τ-}9.ENDFOR10.FOREACHτ-∈TmDO11.将其分配给Tl中与其距离最小的那个代表性排列12.ENDFOR5.2.3Top-k排序Top-k排序所要解决的问题是根据排列聚类产生的代表性排列及当前查询与每个偏好类对应上下文的相似度,计算出每条结果元组在每个偏好类偏好作用下的分数,然后计算出每条元组的总体排序Page8分值,最后基于Fagin的TA算法[26]返回前k个最能满足用户偏好的结果元组.通过元组排列聚类,可得到关系R上的l个代表性排列,每个代表性排列τ-珡Xi{X1,X2,…,Xm},形成l个〈珡Xi,τ-t(t∈R)在每个〈珡Xi,τ-义的排序分值s(t|珡Xi).因此,可使用TA算法检索出top-k个结果元组(算法4).算法4.Top-k排序算法.输入:代表性排列Tl={τ-1,τ-2,…,τ-l},每个τ-i对应的上输出:Top-k个结果元组1.令B={}是一个能够存储k个元组的缓存2.令L是个一个大小为l的数组,存储来自每个排列3.REPEAT4.FORALLi∈{1,2,…,l}DO5.从排列τ-i中检索下一个元组t6.计算元组t的分数:7.用元组t在排列τ-i中的分数更新L中对应于元8.IFt∈Q(R)THEN9.通过随机访问方式,获取元组t在其他排列10.tscore(t,Q)←所有检索到的分数之和11.按照降序方式,将〈t,tscore(t,Q)〉插入到缓12.ENDFOR13.UNTILB[K].tscore∑l14.RETURNBTA算法提供两种访问数据模式:随机访问和顺序访问.算法4的具体处理过程分成以下3步:(1)循环访问每个代表性排列.在每次循环过程中,当一个元组t(t∈Q(R))在某个排列τ-现时,计算它在该排列中的分数,计算公式为该分数由两部分构成:一部分是sim(Q,珡Xi),表示查询Q与上下文集合珡Xi之间的相似度;另一部分是s(t|珡Xi),表示元组t在〈珡Xi,τ-的排序分值.然后,通过随机访问获取该元组在其他j中的分数,这些分数之和就构成了元组t对排列τ-于查询Q的总体排序分值,由式(18)计算:tscore(t,Q)=∑珡Xi(2)令s(tj|珡Xi)为第j次循环结束后,在每个排i中最后被访问元组的分数.TA算法的阈值列τ-threshold确定为threshold=∑珡Xi即,阈值threshold为第j次循环结束后数组L中的分数之和.当缓存B中存在k个元组且它们的总体排序分值都不小于该阈值时,算法停止.通过设定阈值threshold,使得第1步无需要遍历每个代表性排列中的所有元组.(3)在所有被发现的元组中,输出前k个具有最高总体排序分值的元组.注意,当第2步完成后,对于任一个没有在循环访问中被发现的元组t,它的总体排序分值都将小于设定的阈值,即tscore(t,Q)<threshold.算法4的复杂度与输入的元组排列数呈线性关系.考虑关系R(A1,A2,…,Am),若令Dom(Ai)代表每个属性的值域且基数为|Dom(Ai)|,则将存在2|Dom(A1)|+|Dom(A2)|+…+|Dom(Am)|个不同的上下文条件.如果每个上下文都对应一个不同的元组排列,则TA算法的时间复杂度为O(2|Dom(A1)|+|Dom(A2)|+…+|Dom(Am)|).本文通过聚类将2|Dom(A1)|+|Dom(A2)|+…+|Dom(Am)|个元组排列减少到l个代表性排列,top-k排序算法的时间复杂度最终降低到O(nl),其中n为代表性排列中的元组数,l为代表性排列数.因为该算法的最坏情况是计算出所有元组的总体排序分值后才能确定前k个最高分数元组.6效果与性能实验评价6.1实验环境数据集.测试数据使用了两个不同应用领域的数据集,一个是从Yahoo.Autos网站随机抽取的1000000条二手车记录,合成数据集CarDB(Make,Model,Year,Color,Engine,Price,Mileage),其中Make、Year、Model和Color是文本型属性,Engine、Price和Mileage是数值型属性;另一个是从Yahoo.Realestate网站随机抽取的237620条房产信息,合成数据集HouseDB(City,Price,Area,Bedrooms,Bathrooms,Schooldistrict,View,Neigh-borhood,Buildyear),其中City,Schooldistrict,View和Neighborhood是文本型属性,Price,Area,Bedrooms,Bathrooms和Buildyear是数值型属性.偏好类.邀请同事和学生基于数据集提交查询,得到一定规模的查询历史,通过在查询历史上使用1.2节的上下文偏好获取方法,分别为CarDB和HouseDB获取上下文偏好和划分偏好类,用于下面的实验测试.在获取偏好类的过程中,分别将信任度Page9阈值设置为0.5、0.45、0.4、0.35、0.3、0.25和0.2,然后观察不同阈值情况下,每个偏好类所包含的偏好数量以及偏好的合理性.在本文实验环境下,当信任度阈值设置较高时(0.4以上),会导致某些偏好类包含的偏好数量太少,这将导致偏好类所涉及的相关元组过少而使结果元组的排序分值不能得到有效区分;如果信任度阈值设置过低(0.2以下),又会导致一些不合理的偏好产生,由于这些不合理偏好也会与合理偏好一起参与结果元组排序分值的计算,因此会在一定程度上影响到排序效果.本文把信任度设置为0.25.6.2偏好模型表达能力测试该实验目的是测试本文提出的带偏好程度的上下文偏好模型与文献[7]提出的不带偏好程度的上下文偏好模型在偏好表达能力上的差别.偏好模型的表达能力体现在同类偏好下,通过偏好模型建模后,所有与该偏好类相关的元组在有效偏好支持度上的区分度,区分度(Difference)使用具有不同有效偏好支持度的元组数与所有与该偏好类相关的元组数的比值表示.区分度越高,说明偏好模型对不同偏好的区分能力越强,进而在此基础上计算出的排序结果越贴近用户偏好.在有效偏好支持度上的区分度可由下式表示,即Difference(A)=#tuplesassertedbydifferenteffective#relevanttuplesassertedbypreferences其中,A代表偏好模型,A={带偏好程度的偏好模型,不带偏好程度的偏好模型}.首先在CarDB的偏好类中随机选出15个偏好类,实验的测试数据使用这15个偏好类下的所有偏好以及CarDB中与这15个偏好类相关的所有元组.在该实验环境下,将每个偏好类中的偏好划分为10组,每组的偏好个数分别为10,20,30,40,50,60,70,80,90,100;然后,使用两种偏好模型对这些偏好建模,得出与每个偏好类相关的每条元组的有效偏好支持度,统计出具有不同有效偏好支持度的元组个数,然后用式(20)进行计算;最后对这15个偏好类上相同偏好个数情况下得到的区分度求平均,得出如图2(a)所示的比较结果.HouseDB上的比较结果如图2(b)所示.实验结果表明,提出的带偏好程度的偏好模型在两个不同应用领域测试数据集上的区分度都明显优于不带偏好程度的偏好模型,其主要原因是带偏好程度的偏好模型既能体现元组之间的二元偏序关系,又能表达用户对不同元组的偏好程度.实验结果还表明,在相关元组数固定的情况下,偏好数越少区分度越小.这是因为在偏好数较少的情况下,明确被偏好指定的元组数就较少,不具有偏好关系的元组数就较多,从而具有相同有效偏好支持度(Peff-p(t,t,PX)=1/2)的元组数就较多.但是,偏好数过多也会导致区分度有所下降,这是因为当多个偏好共存的情况下,它们之间容易产生矛盾进而造成元组之间具有相同的有效偏好支持度.6.3元组排列聚类算法测试该实验目的是测试元组排列聚类算法产生的代表性排列的准确性.首先使用以下步骤产生本实验的测试数据集:每个数据集包含4个参数:n,m,l和noise,其中n是每个排列中的元组数,m是输入的排列数,l是聚类完成后的排列数.首先,在n个元组上随机产生l个排列,用集合L表示,这l个排列就构成了l个聚类中心.给定一个聚类中心,来自这个聚类的所有排列可以看做是在聚类中心上加入一定数量的噪声(noise)而产生的.本实验中的noise是通过交换一些元组的排序位置来实现的,noise的数量就是交换的元组数,使用此方法来产生试验数据集S.使用本文聚类算法(Greedy-RF)、贪心算法(GreedyAlgorithm)和反贪心算法(FurthestAlgo-rithm)分别在数据集S上产生聚类排列,然后比较由不同算法产生的聚类排列与原排列L的距离.通过比较这个距离来衡量算法的准确性.Page10在CarDB和HouseDB上,使用具有如下参数的数据集来进行试验:n=300,m=600,l={8,16},noise={2,4,8,…,128}.使用F(A)/F(Inp)表示算法的准确性,其中A={GreedyAlgorithm,FurthestAlgorithm,Greedy-RF},F(A)表示算法A产生的聚类排列与原排列的距离,F(Inp)表示产生测试数据的基准聚类的距离.两个排列的距离使用式(15)计算.F(A)/F(Inp)的值越接近1,表示由聚类算法产生的代表性排列与生成测试数据的基准排列越接近,则聚类算法越准确;反之,F(A)/F(Inp)的值越大,则聚类算法越不准确.图3给出了在代表性排列数l分别取8和16的情况下,上述3种聚类算法对应于不同交换数(swaps)的准确性.从图中可以看出,Greedy-RF算法的准确性最高.6.4返回top-犽个元组的准确性测试该实验的目的是测试利用本文元组排列聚类算法产生的代表性排列检索到的top-k个元组的准确性.同时,还与利用Greedy算法和Furthest算法产生的代表性排列检索到的top-k个元组的准确性进行对比.也就是说,该实验要测试在压缩了多个原始排列后,排序结果的准确性丢失程度,使用Jaccard系数量化top-k排序算法的准确性:J(R(Opt,k),R(A,k))=|R(Opt,k)∩R(A,k)|其中,R(Opt,k)代表使用所有可用的元组排列产生的top-k个元组的集合,R(A,k)代表只使用代表性元组排列产生的top-k个元组的集合,R(Opt,k)∩R(A,k)表示两个集合中相同的元组数.Jaccard系数的值在0~1之间,值越高表明两个集合中相同元组数越多.该实验使用的测试数据集的产生方法与聚类算法的准确性实验中测试数据集的产生方法相同.这里,令聚类后的代表性排列个数l={8,16},固定噪声值noise为64个交换(swaps),n和m的值被分别固定为300和600.然后在CarDB和HouseDB上,分别测试对应于不同k值情况下,由3种不同聚类算法产生的代表性排列得到的top-k个元组的平均准确性.实验结果如图4所示.从图4可以看出,在Greedy-RF算法产生的代表性排列基础上,产生的top-k个元组的准确性优于Greedy算法和Furthest算法,并且当l取8和16时,准确性差异并不明显.此外还可看出,随着k值增大,平均准确性逐渐提高;但即使在k值很小的情况下,top-k排序的准确性也很高.6.5Top-犽排序算法的性能测试该实验主要从两个方面考察top-k排序算法的性能:一是代表性排列数与top-k排序算法执行时间的关系;二是top-k中的k值与top-k排序算法执行时间的关系.Page11(1)代表性排列数的改变对top-k排序的影响.首先将k值固定(这里设置k=100),然后对于每种代表性排列数(包括6,12,25,50,100,200,400),分别在CarDB和HouseDB上进行10次测试查询,并由系统记录查询的响应时间,最后取其平均值作为统计结果.图5给出了代表性排列数与top-k排序算法执行时间的关系.图5不同代表性排列数下的top-k排序算法执行时间排序算法执行时间的增长几乎是线性的.由图5可见,随着代表性排列数的增加,top-k(2)Top-k中的k值改变对top-k排序的影响.在该实验中,将CarDB和HouseDB两个数据集中的代表性排列数都固定为30个.在此基础上,测试top-k排序算法对应于每一个k值情况下的执行时间,执行时间取10个测试查询执行时间的平均值.图6分别给出了在CarDB和HouseDB上不同k值情况下top-k排序算法的平均执行时间.图6不同k值下的top-k排序算法执行时间从图6可以看出,top-k排序算法随着k值的增大而性能逐渐下降.这是因为当k值增大时,top-k排序算法需要处理的每个代表性排列中的元组数就会相应地增加.此外还可发现,top-k排序算法在CarDB上的执行时间在很大程度上高于HouseDB上的执行时间,这是因为CarDB中的元组数相对较多,而每个代表性排列又都包含了CarDB中的所有元组ID及其分数,因此增加了top-k排序算法的顺序访问和随机访问执行时间,从而导致算法执行时间增加.7结论与展望本文主要围绕带偏好程度的上下文偏好建模及基于上下文偏好的查询结果top-k排序问题展开了深入具体的研究.结合定性和定量偏好表示方法,提出了带偏好程度的上下文偏好模型以及上下文偏好的获取和处理方法;在此基础上,给出了基于上下文偏好的查询结果top-k排序解决方案,以及相应元组排列创建、聚类和查询结果top-k排序算法.实验结果表明,提出的偏好模型具有较强的偏好表达能力,排序方法具有较高的排序质量和执行效率.本文主要贡献为:(1)提出了带偏好程度的上下文偏好模型及其处理方法;(2)提出了基于上下文偏好的查询结果top-k排序方法.下一步将研究如何有效地对Web数据库多查询结果进行个性化分类,并将排序与分类方法相结合解决Web数据库查询中出现的信息过载问题.
