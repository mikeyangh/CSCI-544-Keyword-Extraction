Page1基于星型模式的一个多路top-犽join算法曹立新高宏(哈尔滨工业大学计算机科学与技术学院哈尔滨150001)摘要top-kjoin查询返回用户最感兴趣的k个连接结果.近来top-kjoin已经成为一个重要的研究课题,且在Web数据库、信息抽取和数据挖掘中均有应用.星型模式的数据仓库在实际应用中也存在top-kjoin查询,如有时决策者只想查询星型连接结果中他最感兴趣的k个.然而,现有top-kjoin算法不适合星型模式.为了在星型模式上有效地支持top-kjoin查询,文中提出两类索引并基于这两类索引提出一个适用于星型模式的多路top-kjoin算法.该算法通过采用一个比现有算法更优的上界和一个剪枝策略获得了更高的效率.此外,实验也表明文中的算法比现有算法效率更高.关键词数据仓库;星型模式;星型连接;top-k;多路top-kjoin算法1引言top-kjoin查询返回用户最感兴趣的k个连接结果.近来top-kjoin已经成为一个重要的研究课题,且在Web数据库、信息抽取和数据挖掘中均有应用.在数据仓库应用中,星型模式是最常用的数据表示模型,包括一个事实表和多个维表.SSBM[1](StarSchemaBenchmark)数据集中,存在星型模式,如图1所示:事实表LINEORDER和4个维表CUSTOMER、SUPPLIER、PART和DATE.在基于星型模式的OLAP(OnlineAnalyticalProcessing)查Page2询中,涉及最多的操作就是维表和事实表的连接,又被称为星型连接.星型连接返回连接的全部结果,是OLAP查询中代价最高的操作之一.星型模式的数据仓库的实际应用中也存在top-kjoin查询.如有时决策者只想查询星型连接结果中他最感兴趣的k个.例如,在图1所示的星型模式中,决策者只想查看那些订单时间距今较短、供应商地址距离公司较近、客户信誉较好、配件品牌较好、订单采购量较大的k个订单,其对应的查询如例1所示.例1.SELECTFROMLineorderF,CustomerC,SupplierS,PartP,WHEREF.custkey=C.custkeyandF.suppkey图1SSBM数据集中的星型模式本文的主要贡献如下:查询,本文提出了两类索引;(1)为了有效地支持星型模式上的top-kjoin(2)基于这两类索引,本文提出了一个适用于星型模式的多路top-kjoin算法.该算法通过采用一个比现有算法更优的上界和一个剪枝策略获得了更高的效率.本文第2节介绍相关工作;第3节介绍问题定ORDERBYF.squantity+C.scredit+S.saddress+STOPAFTERk;对于该查询,一个直观的做法是先生成星型连接的结果,再对这些结果排序得到上述的top-kjoin查询结果.由于星型连接的结果极多,故此方法效率极低.但如果我们在数据仓库中创建一些索引并应用top-kjoin算法,那么无需产生连接的全部结果就能得到top-kjoin查询结果.故基于星型模式的top-kjoin问题的研究具有重要意义.更重要的是,我们发现现有top-kjoin算法因没有充分考虑星型模式的固有特点而不适合星型模式,因而本文提出一个基于星型模式的多路top-kjoin算法.义以及相关索引的数据结构;第4节给出基于星型模式的多路top-kjoin算法;第5节通过实验验证该算法的效率;第6节对全文进行总结.2相关工作通常,top-kjoin算法中有如下3个假设:(1)每个元组包含若干打分属性(scoreattribute).打分属Page3性为度量某种语义的属性,如一个关于酒店信息的关系表中,可能含有若干分别表示酒店的卫生程度、交通便利程度等的打分属性.(2)数据访问模型(dataaccessmodel)分为数据有序访问模型和(或)数据随机访问模型.数据有序访问是指数据可按照打分属性值的大小被顺序访问;数据随机访问是指数据的任何一个元组可以被随机访问.(3)算法的打分函数一般只考虑线性单调函数.top-kjoin问题已经有很多的研究成果,相关工作按照输入数据的确定性、数据访问模型种类、打分函数的性质、连接的类型、输出结果的精确性可以分成若干类.不失一般性,本文的研究算法以确定数据作为输入,数据访问模型为一个表只支持有序访问,其它表同时支持有序访问和随机访问,打分函数取线性单调函数,只考虑等值连接并输出精确结果.rank-join[2]、PBRJ[3]和FPRA[4]均以确定数据作为输入,数据访问模型为大部分表只支持有序访问,小部分表同时支持有序访问和随机访问,打分函数取线性单调函数,只考虑等值连接并输出精确结果.rank-join是基于关系数据库的多路top-kjoin算法,其一般化算法[2]利用某些表对随机访问的支持以获得更小的上界.PBRJ[3]和FPRA[4]考虑打分函数在每个表中取多个打分属性作为输入.FPRA是PBRJ的后续改进算法.虽然FPRA的IO很少,但其计算复杂度非常高.而且当打分函数在每个表只取一个打分属性作为输入时,FPRA退化为rank-join.此外,FPRA有个限制:所有输入必须按照打分函数值的上界降序排列.这也就是说当打分函数在每个表取e(e2)个打分属性作为输入时,FPRA必须预先知道打分函数.这在ad-hoc查询中是不可能的.和rank-join相比,J[5]考虑的连接条件更宽泛,不局限于等值连接.但在等值连接时,相比于rank-join,J因中间结果集较大而效率较低.Je-approx[5]产生近似的top-kjoin结果.OPTU-Topk[6]、MS_Topk[7]是在不确定数据上的top-kjoin算法.此外,还有一类研究问题被称为top-kselection,其相当于top-kjoin问题的一种特例.它假设每个表包含的元组都来自同一组对象集合.NRA[8]、TA[8]、CA[8]、Upper/Pick[9]、Mpro[10]都属于这一类问题的算法.综上所述,rank-join、PBRJ和FPRA这3个算法与本文研究的算法相近.FPRA是PBRJ的改进算法,其IO虽然很少,但计算复杂度却非常高,而且当打分函数在每个表中取e(e2)个打分属性作为输入时,FPRA必须预先知道打分函数,这在ad-hoc查询中是不可能的.当e=1时,FPRA退化为rank-join.故本文只考虑将rank-join作为对比算法.rank-join经过一些修改可以适合星型模式,但在实验中我们发现其效率较低.3问题定义与索引结构3.1问题定义定义1(星型模式).m维的星型模式包含一个事实表F和m个维表D1,D2,…,Dm.其中事实表包含3类属性:(1)主键;(2)对应维表的外键;(3)度量属性.维表包含两类属性:(1)主键;(2)描述属性———描述维详细信息的属性.维表中的这两类属性在本文中被统称为维属性.定义2(扩展星型模式).在m维的星型模式中,为了支持其上的top-kjoin查询,对于决策者感兴趣的每个度量属性a和维属性b,我们在相应的事实表和维表中引入新属性sa,sb,分别度量a和b语义的分值,称之为打分属性.打分属性值的大小∈[0,1],表示决策者对a和b的感兴趣程度.打分属性值越大表示决策者对其相应属性值的感兴趣程度越高.本文称上述加入打分属性之后的星型模式为m维的扩展星型模式.打分属性值大小可由决策者指定,也可由相应的度量属性或维属性计算得到.如在SSBM数据集中,系统可根据维属性DATEKEY的值计算其对应的打分属性值.基于m维的扩展星型模式,本文考虑的打分函数以若干打分属性作为输入项.对应决策者的不同查询,这些打分属性可能来自事实表,也可能来自维表,并且同一个维表或事实表中可取e(e0)个打分属性作为打分函数的输入.当e2时,系统可以先将这e个打分属性的打分函数值计算出来,然后将这个函数值看做一个打分属性.这样打分函数在一个维表或事实表中取多个打分属性作为输入的问题就可以转化为取一个打分属性作为输入的问题.所以接下来本文考虑的打分函数的形式为Score(s1,s2,…,sn,sn+1),其中的n+1(n∈{1,2,…,m})个打分属性分别来自不同的维表和事实表.该打分函数记作Score.例1即为以sum为打分函数的top-kjoin查询,其中的F.squantity、C.scredit、S.saddress、P.sbrand1、D.stime分别代表订单采购量、客户信誉、供应商地址、配件品牌和订单时间对应的打分属性.Page4为了方便叙述,本文不失一般性地假设打分函数中的打分属性s1,s2,…,sn和sn+1分别来自D1,D2,…,Dn和F,称n为打分函数中输入的维数.根据上述描述,本文研究问题的形式化定义如下.定义3(问题定义).给定m维的扩展星型模式,其上的top-kjoin问题以一个n+3元组(F,D1,D2,…,Dn,Score,k)为输入,输出按打分函数值降序排列的前k个连接结果,每一个结果∈((FD1)D2)…Dn.其中:(1)F支持有序访问,D1,D2,…,Dn支持有序访问和随机访问;(2)打分函数Score的形式为上述的Score(s1,s2,…,sn,sn+1);(3)0<k|((FD1)D2)…Dn|.3.2索引结构显然,一个数据库中支持有序访问和(或)随机访问的表越多,top-kjoin算法的打分函数值上界就会越优.因此,我们尽可能最大化m维的扩展星型模式中支持有序访问和(或)随机访问的表的数目.息索引.定义4(维信息索引).给定一个m维的扩展星型模式,一个打分属性sj(sj∈Di)对应一个维信息索引DIj一个三元组(score,key,count),其中:(1)score表示Di中的打分属性sj,且DIj序排列;(2)key表示打分属性score对应的Di主键;(3)count被称为频率属性,记录key在事实表中作为外键出现的频数.实际应用中,对应决策者在维表中感兴趣的每个打分属性,系统分别建立一个维信息索引.图1中SUPPLIER的打分属性saddress对应的维信息索引的形式如表1.其中saddress为SUPPLIER中维属性address对应的打分属性,用来度量供应商地址距离公司的远近.为了使维表支持有序访问,本文提出一类维信表1SUPPLIER中狊address对应的维信息索引saddress0.57352210.5735119同理,为了使事实表支持有序访问,本文提出一类事实表信息索引.定义5(事实表信息索引).给定一个m维的扩展星型模式,一个打分属性si(si∈F)对应一个事实表信息索引FIi(FactinformationIndex).FIi为一个m+2元组(score,key,FK1,FK2,…,FKm).其中:(1)score表示F中的打分属性si,且FIi中元组按score值大小降序排列;(2)key表示打分属性score对应的F主键;(3)FKi是key对应Di的外键,i∈{1,2,…,m}.实际应用中,对应决策者在事实表中感兴趣的每个打分属性,系统分别建立一个事实表信息索引.图1中LINEORDER的打分属性squantity对应的事实表信息索引的形式如表2.其中的squantity为LINE-ORDER中度量属性quantity对应的打分属性;orderkey和linenumber为LINEORDER的主键;其它属性为外键.表2LINEORDER中狊quantity对应的事实表信息索引squantityorderkeylinenumbercustkeysuppkeypartkeyorderdate0.5437236357214313441890199507180.542412843519765172315639019980821因为本文考虑的打分函数在同一个维表或事实表中只取一个打分属性作为输入.故为了方便叙述,下文中的DIj由于事实表通常较大,其对应事实表信息索引也较大(一般不能被读入内存),因此事实表不支持随机访问.而维表一般较小(在scalefactor=1的SSBM数据集中,维表大小不到事实表的4%),其对应的维信息索引也较小,所以维信息索引DI1,DI2,…,DIm可支持随机访问.因为top-kjoin算法中需要的打分属性、主键等均在维信息索引中,所以维信息索引支持随机访问也就相当于维表支持随机访问.通过Di(i∈{1,2,…,m})的主键(记作KEYi)对DIi随机访问的方法为:系统对应每一个维信息索引DIi建立一个位置转换表POSi.该表用于将KEYi转换为其在DIi中的索引位置(记作orderi).索引位置表POSi为一个Hash表,包括两项:(1)KEYi;(2)orderi.基于位置转换表POSi,系统可通过KEYi随机访问DIi而得到DIi在orderi的详细信息(记作DIi[orderi]).4基于星型模式的多路top-犽join算法4.1算法相关概念与原理基于维信息索引和事实表信息索引,本文提出一个适用于星型模式的多路top-kjoin算法:MTJS.算法采用一个优先级队列(记作Q)来保存算法的中间结果,Q中最小的打分函数值记作Smin.当MTJS顺序访问事实表信息索引中的一个元组时,就将该元组外键在相应维信息索引中对应Page5的count值减1.基于count值的更新,我们给出若干定义如下.定义6(上边界位).设DIi为m维的扩展星型模式上的一个维信息索引,其对应的上边界位Hi=max{p|DIi[p].count≠0}.其中:(1)p表示DIi中索引项的位置(简称为索引位置),且p∈[0,Card(DIi)-1].p越小的项的打分属性值越高,Card(DIi)表示DIi中key的基数.(2)DIi[p].count表示DIi在p的频率属性值.定义7(维最高分).设DIi为m维的扩展星型模式上的一个维信息索引,其对应的维最高分DIi.max=DIi[Hi].score(i∈{1,2,…,m}).其中DIi[Hi].score表示DIi在Hi处的打分属性值.MTJS通过顺序访问FI得到元组t并随机访问相应的DIi来构成连接结果.由于DIi中count值为零的元组在将来不会再与顺序访问FI得到的元组构成连接结果,所以DIi.max为当前未见连接结果在DIi上的最高可能打分属性值.定义8(维上界).DIi中p处的维上界upperbound(p,i)=Score(FI.latest,DIi[p].score,DI1.max,…,DIi-1.max,DIi+1.max,…,DIn.max).其中:(1)FI.latest表示MTJS对FI最近一次顺序访问得到的打分属性值;(2)p表示DIi中的索引位置;(3)DIi[p].score表示DIi在p处的打分属性值;(4)DIj.max(j∈{1,2,…,n}andj≠i)表示DIj的维最高分.定义9(下边界位).设DIi为m维的扩展星型模式上的一个维信息索引,其对应的下边界位Li=min{p|upperbound(p,i)>Smin}.其中:(1)upperbound(p,i)表示DIi中p处的维上界;(2)Smin为中间结果中最小的打分函数值.根据上述定义,我们有如下定理.定理1.给定m维的扩展星型模式,设t为FI中元组,FKi为t对应DIi的外键,orderi为DIi中主键为FKi元组的索引位置,在MTJS算法中,如果存在orderi>Li(i∈{1,2,…,n}),则t一定不是最终结果之一.证明.根据定义8,DIi中orderi处对应的维上界upperbound(orderi,i)=Score(FI.latest,DIi[orderi].score,DI1.max,…,其中因为FI中被顺序访问过的元组不会再构成新的连接结果,故FI.latest表示当前未见连接结果在FI的最高可能打分属性值,又因为DIj.max表示当前未见连接结果在DIj的最高可能打分属性值,进而根据打分函数的单调性可知upperbound(orderi,i)是DIi中orderi处的打分属性在当前所构成连接结果的打分函数值上界.再根据Li定义和orderi>Li有upperbound(orderi,i)Smin,即t构成的连接结果的打分函数值上界小于或等于Smin,故t一定不是最终结果之一.本文基于定理1提出一个剪枝策略:当MTJS顺序访问FI得到一个元组t时,如果t对应的某个外键在其维信息索引中的索引位置大于该外键所在维信息索引的下边界位,则MTJS可以不必随机访问维信息索引以生成t对应的连接结果并计算该连接结果的打分函数值.根据定理1,该剪枝策略不会剪去任何一个最终结果,故其是正确的.设Li处频率属性值为c,维数为m,那么根据定理1,只要Li增加1,就最多可能有c×m次随机访问和c次打分函数值计算被剪枝.而维信息索引中的频率属性值一般较大,故该剪枝策略具有重要意义.top-kjoin算法中,通常有一个上界用于表示当前未见连接结果的打分函数值上界,本文称之为总上界.引理1.MTJS的总上界为Score(FI.latest,DI1.max,…,DIn.max).证明.因为FI.latest,DI1.max,…,DIn.max均为当前未见连接结果在FI,DI1,DI2,…,DIn的最高可能打分属性值,故根据打分函数的单调性,Score(FI.latest,DI1.max,…,DIn.max)是MTJS的总上界.定理2.在n个维信息索引DI1,DI2…,DIn上,MTJS按定义更新Li、Hi和Q.只要某时刻有一个上、下边界位满足Li<Hi,MTJS就可以结束并返回正确的top-kjoin结果.当Li<Hi时,由下边界位定义可知upper-bound(Hi,i)Smin(式(1)).其中upperbound(Hi,i)=Score(FI.latest,DIi[Hi].score,DI1.max,…,DIi-1.max,DIi+1.max,…,DIn.max),而DIi[Hi].score=DIi.max,故upperbound(Hi,i)=Score(FI.latest,DI1.max,…,DIn.max)(式(2)).由引理1,Score(FI.latest,DI1.max,…,DIn.max)为MTJS的总上界.于是根据式(1),式(2)有MTJS的总上界Smin,故此时MTJS可以结束,并且当前Q中的k个连接结果为正确结果.4.2算法描述MTJS的主要思想是:首先,算法根据维信息索引中的频率属性值来更新上边界位,从而使总上界在维信息索引上对应的维最高分得到更新.其次,根Page6据定理1,算法利用下边界位过滤不必要的随机访问和计算.最后根据定理2,当存在某个上边界位大于其对应的下边界位时,算法结束.MTJS分为两步;第1步初始化相关变量;第2步计算top-kjoin的结果.第2步中,MTJS首先顺序访问事实表信息索引得到一个元组,并更新该元组外键在相应维信息索引中对应的频率属性值;接下来重新确定上、下边界位;然后依据定理1判断是否可以剪枝;如果不能剪枝,则算法生成该连接结果并考虑其能否成为中间结果.如此下去,直到存在一个维信息索引的下边界位小于其上边界位时算法结束.为了避免在每次更新频率属性值之后都重新计算每一个下边界位对应的维上界和判断能否更新各个下边界位,MTJS中引入最佳维的概念.定义10(最佳维).如果DIbest在该时刻位于其下边界位处的维上界在所有维信息索引中最小,称best为某时刻的最佳维.MTJS只需考虑更新DIbest中Lbest处对应的维上界和Lbest,原因如下:(1)在被选为最佳维时,最佳维下边界位Lbest处的维上界最小,故Lbest将来被更新的可能性最大,进而MTJS可获得较好的剪枝效果;(2)不考虑其它下边界位的更新,算法也可正确结束.因为如果某时刻MTJS的总上界Smin(式(1)),那么一定有Lbest<Hbest,进而根据定理2,算法可正确结束.假设如果此时Lbest不小于Hbest,那么有upperbound(Lbest,best)MTJS的总上界(式(2)),故可由式(1)、式(2)推出upperbound(Lbest,best)Smin(式(3)).而根据下边界位定义和式(3),Lbest会一直更新至Hbest-1,故假设失败,算法此时可正确结束.MTJS的输入为一个四元组(k,G,P,Score),称之为扩展星型模式下top-kjoin的输入四要素.其中:(1)k为查询结果大小;(2)G为top-kjoin查询相关的维信息索引和事实表信息索引的集合;(3)P为对应G的位置转换表集合;(4)Score为2.1节中的打分函数.为了方便下面的算法描述,本文接下来不失一般性地假设G={DI1,DI2,…,DIn,FI},P={POS1,POS2,…,POSn}.MTJS的详细内容如下.算法1.MTJS.输入:扩展星型模式下top-kjoin的输入四要素输出:((FIDI1)DI2)…DIn中打分函数值最第1步.初始化.1.初始化相关数据结构:Q,DI1,DI2,…,DIn,FI,2.foreachi(1in)3.while(Q.size()k)//先生成k个连接结果4.根据定义计算Smin,Hi,DIi.max,FI.latest,Li;5.best=Min();//Min()返回当前的最佳维第2步.计算top-kjoin结果.6.if(L1<H1orL2<H2or…orLn<Hn)then返回Q中top-kjoin结果;endif7.顺序访问FI得到下一个元组t,更新FI.latest;8.foreachi(1in){orderi=POSi(t.FKi);9.foreachi(1in)//更新上边界位{while(DIi[Hi].count=0andLiHi)10.更新最佳维在Lbest的维上界upperbound(Lbest,11.if(upperbound(Lbest,best)SminandLbestHbest)12.if(order1>L1ororder2>L2or…orordern>Ln)13.读取DI1[order1].score,…,DIn[ordern].score和t14.if(t对应连接结果的打分函数值>Smin)15.goto6.4.3算法分析(1)若在m维的扩展星型模式上利用上述索引应用rank-join的一般化算法,其总上界大于MTJS的总上界.Rank-join的总上界为以FI.latest和每个维信息索引的第一个打分属性值DIi.top作输入Page7得到的打分函数值:Score(FI.latest,DI1.top,…,DIn.top).因为DIi.max会随着频率属性值的更新而不断更新,而DIi.top固定不变且DIi.topDIi.max,所以根据打分函数的单调性,rank-join的总上界大于MTJS的总上界.因为总上界更小,故和rank-join相比,MTJS具有更少的顺序访问次数.(2)参考Theorem3[2]关于rank-join近似最优(instanceoptimal[8])的证明,不难得出MTJS也是近似最优的.近似最优的定义如下.定义11(近似最优).“设是一类算法,是一类数据库,对应算法A∈和数据库D∈,算法代价函数cost(A,D)返回在D上应用A导致的代价,称一个算法B在和上是近似最优的,如果B∈,并且对于任意A∈和任意D∈,cost(B,D)=O(cost(A,D))成立.即对于任意A∈和任意D∈,存在常数c,c>0,使cost(B,D)c×cost(A,D)+c.c被称为最优比(optimalityratio)”[8].定理3.设是m维的扩展星型模式,包括1个只支持有序访问的事实表,m个既支持有序访问又支持随机访问的维表,是一类算法,其在上产生正确的top-kjoin结果.cost(A,D)=SumCost(A,D),则MTJS在和上是近似最优的.其中,算法代价函数SumCost(A,D)度量算法A(A∈)在D(D∈)上对FI顺序访问和对DIi(i∈{1,2,…,n})随机访问的总代价.下面用CS(A,D),CR(A,D)分别表示A在D上应用导致的对FI的顺序访问次数和对DIi的随机访问次数.因为随机访问速度(内存读写速度)大约是顺序访问速度(磁盘读写速度)的103倍,所以我们令SumCost(A,D)=CR(A,D)×0.001+CS(A,D).虽然0.001很小,但是因为CR(A,D)很大且打分函数值的计算次数和CR(A,D)成正比,故SumCost中不能忽略CR(A,D).下面给出定理3的详细证明.证明.设A为中任意算法.如暂不考虑CR(A,D)的代价,参考Theorem3[2]的证明,显然MTJS的最优比至多为1,故有CS(MTJS,D)CS(A,D)+c(式(1))成立.本文考虑MTJS中的一次顺序访问在D中至多对应m次随机访问,故SumCost(MTJS,D)(1+0.001×m)×CS(MTJS,D)(式(2)).再根据式(1)有(1+0.001×m)×CS(MTJS,D)(1+0.001×m)×CS(A,D)+c(式(3)),又因为CS(A,D)SumCost(A,D),故(1+0.001×m)×CS(A,D)+c(1+0.001×m)×SumCost(A,D)+c(式(4))成立,综合式(2)、式(3)和式(4)可知SumCost(MTJS,D)(1+0.001×m)×SumCost(A,D)+c,即MTJS是近似最优的且最优比为1+0.001×m.5实验结果与分析5.1实验配置数据集.因为top-kjoin算法一般只访问每个表的前一部分就能结束,所以数据集的大小不作为其实验参数之一[4].本文使用scalefactor为1的SSBM数据集作为实验数据集.对应m维的扩展星型模式,我们在SSBM数据集上做了一个修改:在每个维表和事实表中分别引入一个打分属性.按照打分属性值分布的不同,本文的实验数据集分为指数分布的数据集和正态分布的数据集,简称为指数分布数据和正态分布数据.指数分布中λ=2、正态分布中μ=0.6,σ=0.2.此外,实验考虑了Bruno等人[9]在ICDE2002中提出的相关系数cf(correlationfactor)对算法性能的影响.按照DIi(i∈{1,2,…,n})与FI的相关系数的不同,指数分布数据和正态分布数据又分别对应一组实验数据集.相关系数的定义如下.定义12(相关系数).设L是按打分属性Ls降序排列的表,R是按打分属性Rt降序排列的表,R的外键是L的主键,对于L任意一个主键key,其在L中对应的Ls值为s,在R中对应的Rt值为t,cf∈[-1,1],我们称L与R正相关,如果cf0,且t∈[max(0,s-(1-cf)),min(1,s+(1-cf))];称L与R负相关,如果cf<0,且t∈[max(0,1-s-(1-|cf|)),min(1,1-s+(1-|cf|))].cf被称为L与R的相关系数.相关系数的含义为,key在L中打分属性值和key在R中打分属性值的相关程度.观察定义12,当cf=0时,t∈[0,1],即t的大小与s无关.因为打分属性值高低与排序位置相关,故此时key在R中的对应元组可以出现在R中任意位置.当cf>0时,s如果越高,t就可能越高.如s=0.5,cf=0.9,则t∈[0.4,0.6].此时key在L排得越靠前,那么key在R中排得也越可能靠前.故L与R正相关时,顺序访问R中元组而生成的连接结果的打分函数值会较高(打分属性值高的元组连接打分属性值高的元组),此时top-kjoin算法相应地会较快结束.反之,当cf<0时,key在R排得越靠前,那么key在L中排得越可能靠后.故此时顺序访问R中元组而生成的连接结果的打分函数值会较低(打分属性值高的元组连接打分属性值低的元组),此时Page8top-kjoin算法相应地会结束较慢.实验环境.主机CPU:P43.4GHz;磁盘大小:80GB;磁盘读写平均速度:50MB/s;操作系统:WindowsXP;编译环境:vs2005;内存大小:1GB.测度.我们以执行时间(记作time)和SumCost的函数值为测度衡量实验中算法的性能.对比算法.为了使rank-join适合星型模式的特点,本文将其修改如下(修改后的rank-join记作RJ_Adapt):(1)rank-join没有必要顺序访问DIi(i∈{1,2,…,n}),因为顺序访问DIi得到的元组之间不能连接,故会产生若干不完整的连接结果,而这些结果不可能被输出,因为它们只是维信息索引中的一个元组,故其打分函数值下界必定小于或等于1,而其总上界一般大于n.此外,顺序访问DIi不能降低其总上界.(2)由修改(1),rank-join没有必要考虑对DI1,DI2,…,DIn和FI顺序访问的优先次序.5.2MTJS与RJ_Adapt的性能比较不失一般性,实验中的打分函数取线性加权函数(其它线性单调函数的实验也表明MTJS的效率较高,但由于篇幅所限,这里略去).权值的赋值可分为两种情况,即或者事实表打分属性的权值较大,或者维表打分属性的权值较大,故我们用后者与前者的比值大小来表示权值的不同赋值,本文称之为相对权值,记作W.这里我们分别在不同的打分属性值分布、相关系数(cf)、查询结果大小(k)、相对权值(W)与打分函数中输入的维数(n)下进行实验.默认设置打分属性值分布为正态分布,cf=0.5,k=100,W=1,n=4.之所以DIi(i∈{1,2…,n})与FI的cf默认取0.5,是因为一般DIi和FI正相关.例如,如果一个订单的供应商地址距离公司越近,客户信誉值越高,那么一般该订单的采购量也越大.5组实验的详细对比结果如下.5.2.1打分属性值分布的影响图2比较了Join、RJ_Adapt、MTJS3个算法在打分属性值取不同分布时的性能差异.图中Normal代表正态分布,Exp代表指数分布.Join是最直观的做法,先连接再排序得到top-kjoin结果.由图2可知,Join的效率很低,所以本文在下面的对比实验中忽略此算法.和RJ_Adapt相比,MTJS的性能更优:在指数分布中,其SumCost的值有32%左右的减少,time有34%左右的减少;在正态分布中,其SumCost的值有15%左右的减少,time有18%左右的减少.其time的减少多于SumCost的值的减少是因为:MTJS除减少了顺序访问次数和随机访问次数之外,还避免了多次打分函数值的计算,且使用了最佳维等方法.5.2.2相关系数(cf)的影响.图3比较了RJ_Adapt、MTJS在DIi(i∈{1,2,…,n})与FI的cf不同时的性能差异.当cf<0时,因为DIi与FI负相关,Hi对应的维主键一般在FI中的索引位置较大,故当顺序访问FI的次数较少时,Hi处的频率属性值一直不能被更新至零.此时,MTJS的Hi更新得较少,其总上界相应地更新得也较少,所以MTJS和RJ_Adapt的性能基本持平:如cf=-0.5时,和RJ_Adapt相比,MTJS的SumCost的值大约减少1%,time大约减少1%.反之,当cf>0时,MTJS的Hi会更新较多,其总上界相应的更新也较多,故和RJ_Adapt相比,MTJS的性能更优:如cf=0.75时,其SumCost的值大约减少24%,time大约减少26%.Page95.2.3查询结果大小(k)的影响:由图4可知,在k(k10)较小时,两个算法的性能基本持平.因为在k较小时,两个算法返回得都很快.此时MTJS顺序访问FI的次数较少,所以Hi更新得较少,其总上界相应地更新得也较少,因而二者的性能差异不大.如k=10时,和RJ_Adapt相比,MTJS的SumCost的值有3%左右的减少,time有4%左右的减少.相反,在k较大时,MTJS的Hi有了较多的更新,其总上界相应地更新得也较多,所以MTJS的性能和RJ_Adapt相比有了较大提升.如k=1000时,SumCost的值有28%左右的减少,time有30%左右的减少.5.2.4线性加权函数中相对权值(W)的影响:图5比较了在线性加权函数中相对权值不同时两个算法性能的差异.这里相对权值W分别取五组数据:0.25,0.5,1,2,4.W较小时,因为事实表打分属性的权值较大,故MTJS的总上界大小更依赖F.latest,而F.latest与FI中当前未见的打分属性值的误差更小,故此时两个算法的总上界都较优,进而两个算法一般都会很快结束.由于MTJS很快结束时,频率属性值更新得较少,上边界位相应地更新得较少,其总上界相应地更新得也较少,故两个算法的性能差异不大.如W=0.5时,和RJ_Adapt相比,MTJS的SumCost的值有大约0.5%的减少,time有大约1%的减少.反之,W较大时,根据上边的分析,两个算法都不会很快地结束.因而MTJS对FI的顺序访问次数较多,Hi随之更新得也较多,其总上界相应地更新得也较多,故此时MTJS的性能优势较为明显.如W=2时,和RJ_Adapt相比,MTJS的SumCost的值有大约34%的减少,time有大约36%的减少.5.2.5打分函数中输入的维数(n)的影响:图6比较了在n不同时两个算法的性能差异.为完成n=5时的实验,我们在SSBM数据集中添加了一个维,n=6时同理.当n较小时,两个算法的总上界中取最高可能打分属性值的项数都较少,所以它们的总上界都相对较小,故两个算法都较早结束.因此,MTJS的Hi更新得较少,其总上界相应地更新得也较少,故其和RJ_Adapt的性能差异并不大.如在n=3时,和RJ_Adapt相比,MTJS的SumCost的值减少了2.5%左右,time减少了3%左右.反之,当n较大时,MTJS的Hi更新得较多,其Page10总上界相应地更新得也较多,故其性能优势明显.如在n=5时,和RJ_Adapt相比,MTJS的SumCost的值减少了31%左右,time减少了33%左右.6结论本文考虑基于星型模式的数据仓库上的top-kjoin查询,提出两类索引并基于这两类索引给出一个适用于星型模式的多路top-kjoin算法.该算法通过采用一个比现有算法更优的上界和一个剪枝策略而获得了更高的效率.以执行时间和一个算法代价函数的值为测度,我们对本文算法和rank-join的一个适应算法进行了若干组对比实验.这些实验验证了本文算法的性能优于对比算法.
