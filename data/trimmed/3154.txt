Page1列存储数据区级压缩模式与压缩策略选择方法王振玺1)乐嘉锦1)王梅1)刘国华1),2)1)(东华大学计算机科学与技术学院上海201620)2)(南京大学计算机软件新技术国家重点实验室南京210093)摘要压缩技术是列存储数据管理的重要研究内容之一.目前多数方法对同一列数据使用单一压缩方法进行压缩,忽略了数据的局部分布特性,极大地影响了压缩性能.该文提出一种区级压缩模式,并在此模式下提出基于学习的压缩策略选择方法.首先该文将数据列进一步划分为区,并分别定义相邻区信息与区所在列的统计信息为参照信息,进而通过学习参照信息与当前区之间的相似性和差异性进行策略推荐.最后该文对区进行局部学习从而对推荐压缩策略进行修正,保证压缩策略的有效性.在数据仓库基准数据集SSB上的实验结果验证了该文方法的有效性.关键词列存储;数据压缩;区级压缩模式;压缩策略选择1引言随着数据仓库技术的不断发展,数据仓库中包Page2进行存储,数据表记录中的同一属性值被存储在一起.在进行查询的时候,列存储数据仓库系统只需要将需要的列读入内存,一定程度上减少了读入的数据量,使得系统的查询效率得到提高[1].然而,数据仓库需要处理的数据量是非常庞大的,这造成查询时大量的I/O.由于CPU处理与磁盘访问发展的不平衡,造成了I/O成为了查询的瓶颈.因此,减少I/O的次数能显著提高查询的效率.而数据压缩则能在一定程度上减少I/O的次数,因此,数据压缩成为了一个研究的热点.对于列存储来说,数据具有相同的数据类型,增加了相邻数据之间的相似性,使得列存储系统和传统的行存储系统相比具有更好的压缩效率.数据压缩一直以来是数据管理领域长期关注的研究问题,目前存在众多的压缩方法,如Huffman编码[2]、算术编码[3]、字典编码(Dictionary-basedcompression)、空值抑制(NullSuppression)[4]、游程编码(Run-LengthEncoding)[5]、LZ系列编码等[6].Oracle,DB2,SQLSever2008等基于行存储的数据库管理系统主要采用字典编码、空值编码等压缩方法来实现压缩.C-Store[7-8]等列存储系统则主要采用游程编码、字典编码、空值编码等压缩方法.研究表明:不同压缩方法对同种数据类型的压缩效果是不同的,同样相同压缩方法对不同类型数据的压缩效果也是不同的.因此,对不同的数据类型采用不同的压缩方法十分必要.然而目前在压缩策略选择方面的研究非常少.Abadi等人[7-8]通过实验提出了一个决策树,通过该决策树进行压缩策略选择,然而这种压缩是建立在整个列上面的,即该方法将一个列的数据采用同一种压缩方式进行压缩.但是该方法忽略了局部数据在分布上存在着差异性.如图1所示,一个列中第101个和第102个区的数据的特点相似,可以采用游程编码,但是第301个区中的数据与上面两个区的差异就比较大,如果采用游程编码,压缩效率就非常低.对该区采用字典编码则可以很好地解决这个问题.由此看来在较小的粒度上面进行压缩可以提高压缩率.然而,为每个区进行学习时间复杂度高,并不可行.针对上述问题,本文提出一种区级压缩模式下的基于学习的压缩策略选择方法.首先本文将数据列进一步划分为区,并分别定义相邻区信息与区所在列的统计信息为参照信息,在此基础上提出两种不同的压缩策略选择方法:基于相邻区的参照学习方法通过定义连续区之间的相似因子来判定连续两个区中数据分布的相关性和差异性,从而预测当前区中数据的分布特点,得到推荐的压缩策略;基于统计参照区学习方法通过估计当前区和区所在列的整体分布相似性进行策略推荐.在此基础上,本文对区进行局部学习从而对推荐压缩策略进行修正,保证压缩策略的有效性.上述两种方法都有效地利用数据的局部分布特点进行压缩,并降低了单独为每个区进行学习的额外开销.在数据仓库基准数据集SSB上与C-Store的方法进行比较,经过实验验证本文的方法较C-Store决策树的压缩率有较大的提高.本文第2节介绍相关工作;第3节介绍本文定义的一些变量和概念;第4节介绍基于学习的压缩策略选择方法的详细内容;第5节描述本文提出的两种方法在数据仓库基准数据集SSB上进行的实验,并对实验结果进行详尽的分析和说明;最后一部分是总结和展望.2相关工作列存储思想的出现可以追溯到1975年[9].后来,Wong等人提出了移项文件[10]的技术用于解决对大型科学数据库的检索速度问题.他提出将一个关系的不同列的值存放在不同的文件中,并且对这些列值进行了压缩以节省空间.这是列存储的雏形.Copeland等人提出了DSM(DecompositionStorageModel)[11]存储模型的概念.Ailamaki在DSM存储模型的基础上提出了PAX(PartitionAttributesAcross)[12]技术,这种技术通过将数据块分割为小的数据区,在每个数据区中存储一个属性的值,提高了数据的查询性能.Ramamurthy等人提出了碎片镜像(FracturedMirrors)技术[13],这种方法实质上是一种行存储和列存储的折中,通过在一个系统中Page3保存两种版本(NSM存储模型和DSM存储模型)的数据副本来提高查询性能.后来,Abadi等人提出了C-Store[7-8]存储架构并且实现了一个实验性质的系统C-Store,这个系统的特点是上层查询执行仍然采用行存储即元组的方式执行而在磁盘上采用列存储的方式存储数据,在上层和底层之间有一个称为TupleMover的组件用于上层和下层数据之间的迁移.由于列存储数据是以属性或列为单位进行存储的,数据具有相同的数据类型,使得列存储系统和传统的行存储系统相比具有更好的压缩效率.压缩技术成为列存储数据管理的重要研究内容之一.适用于数据库上面的压缩方法有很多,主要有空值悬挂[4]、游程编码[5]、位图编码、字典编码[4]以及LZ系列的字典编码[6]等,如表1所示.从压缩粒度的角度来说,目前压缩主要在以下5种不同的粒度中进行:表级、块级、元组级、属性级以及比特级压缩[1].表级粒度下的压缩方案,具有代表性的是IBM公司的DB29(又名DB2Viper),DB29中采用全表级数据库压缩方案,但是全表级压缩方案使得在解压记录时需要大量的I/O.其中元组级的压缩方案很少见.块级粒度下的压缩方案就比较多了.Eggers,Shoshani提出了一种对多维稀疏数组进行数据页级压缩的方法,其具有forwardmapping和backwardmapping这种mappingcomplete性质;Goldstein等人给出了基于frameofreference的数据页级压缩算法,该算法找出每一页中元组之间的共同信息,称之为frameofreference,其它数据参照此进行压缩,将多个压缩数据页结合起来就形成了文件级的压缩;Oracle的压缩算法采用了基于字典的压缩方法[14],其将字典和数据放在同一页中,但是这种方法的压缩效率相对全表级压缩来说,压缩率较低.比特级粒度下的压缩方案也有很多,但是应用的领域有限制.Wong等人给出了基于Bit级压缩的BitTranspositionFile(BTF)系统[15],该系统针对科学统计数据库中属性的候选集有限的特点,将属于相同列的Bit存放在同一数据块中实现压缩;而对于那些不能压缩的属性,BTF仍然按照Bit列存储.BTF只考虑了单表的查询操作,没有给出连接操作.除了在行存储上面取得了很多的研究成果之外,列存储上面的数据压缩研究也取得了一定的成果[7-8,16-17].Abadi等人提出一种按属性列存储、读优化的、压缩的数据库管理系统C-Store[7-8],主要采用游程编码、字典编码、位图编码、LZ系列编码等压缩方法.以哈尔滨工业大学的李建中教授为首的研究小组针对科学与统计数据库的特点提出了一个比特级压缩方案[17].该方案对于值域有限的属性,采用K-of-N+Unary进行压缩编码,并将编码结果按照Bit列存储,实现压缩;对于主键属性采用Double-Key-Btree按属性列存储;对于其它属性则按照Tu-pleID-Btree按属性列存储.但是该压缩方案将一个数据库表拆分为两个数据库表的方式使得插入、删除和更新操作的执行变得十分复杂,使得该拆分压缩方案的使用范围过于狭窄.在压缩技术不断发展的同时,对压缩策略选择的研究也在不断的发展.Abadi等人提出了的数据库管理系统C-Store[7-8].它通过建立一个决策树来判定一个列采用何种压缩算法.但是这种方法忽视了数据在局部上的特殊性,过于粗糙,造成压缩率相对比较低.序号压缩算法1字典编码2游程编码字符(串),数值,日期,布尔3位图编码字符(串),数值,日期,布尔4空值编码字符(串),数值,日期,数值,文本5整数编码6LZ编码3定义和符号给定关系模式R={A1,A2,…,An},其中n表示关系的目的度,Ai表示第i个属性列.在列存储中,任意一个列Ai中的数据在逻辑上对应一个数据段Si∈S.本文中将段分为若干个区,区是一系列连续块的集合.第i个属性列对应的段记为Si={ei1,ei2,…,ein},其中ej-1和ej是两个连续的区.区由16个连续的数据库块构成.区中的第一块是区的控制块,保存区中所有块的控制信息.区的结构如图2所示.区中存放着连续的列值,每一个列值称为一个项(item).本文为每一个区定义一组统计信息,记为集合T={r,s,a,d,n,c,l},其中r表示第i个区中item的数目,s表示区中相同值的数目,a表示区中相同值的总的item条数,d表示区中不同值的数Page4目,n表示区中空值的数目,c表示区中相同值连续的平均数目,l表示区中item的平均长度.基于上述统计信息,本文为每一个区定义了一组统计量qi={q1i,q2i,q3i,q4i,q5i},qi描述了第i个区的数据分布的一些特点,详细如下:定义统计量1:q1i表示区中相同值所占的百分比,q1i=a×100/r.定义统计量2:q2i表示区中空值记录所占的百分比,q2i=n×100/r.定义统计量3:q3i表示区中相同值连续的平均数目,也就是q3i=c.定义统计量4:q4i表示区中不同值的数目,也就是q4i=d.定义统计量5:q5i表示区中item的平均长度,也就是q5i=l.例如,一个区中共有r=1000条的记录,其中相同值的数目s=20,相同值的总记录条数为a=960,区中不同值的数目d=30,区中空值的数目n=10,区中相同值连续的平均数目c=5,区中item的平均长度l=10,那么,q1i=960×100/1000=96,q2i=10×100/1000=1,q3i=5,q4i=30,q5i=10.令压缩算法集合m={m1,m2,…,mn},n为算法数量,mi中的压缩算法分别取自表1中的算法.定义函数f:T→mT表示根据区的统计信息T得到适合区中数据分布的最优压缩算法mT.4区级压缩模式与基于学习的压缩策略选择方法如前所述,在一列上采用单一的压缩算法进行压缩忽略了数据的局部分布特点,因此本文提出区级压缩模式.所谓区级压缩模式是指压缩的基本单位是区.不论采用什么类型的压缩算法,这种算法针对的对象是一个区中的数据.例如对于字典编码来说,字典的建立是在对区中的数据进行统计之后得到的,这个区和另一个区的字典的内容是不一样的,字典存放在区控制块中;对于位图编码来说,区中的不同值的数目决定了要采用的位图编码的向量的数目.然而,列中数据分布的一致性和相似性决定了为每个区单独学习会造成巨大的时间和空间的浪费.为此,本文提出基于学习的压缩策略选择方法,通过学习当前区与参照区之间的相关性和差异性,进行策略推荐,从而在得到较优压缩策略的同时减少时间复杂度.4.1基于相邻参照区的压缩策略选择基于相邻参照区的压缩策略选择方法的基本思想是:局部连续区之间的数据分布一般情况下具有一致性和相似性,可以采用相同压缩方法.因此,本文首先利用区的统计量估计相邻两区数据分布的相似性.为此,这里定义连续区ri和ri+1的相似因子为S={S1,S2,…,S5},其中j∈{1,2,…,5}.若Sj区近似,可以用相邻区进行策略推荐,可得到mi=mtemp,其中推荐压缩方案为mtemp.否则则认为两者不相似,需要对当前待压缩区进行局部学习,从而对压缩策略进行修正.临界值是不同的,其最优值需要在实验中确定.如下.这里的δi∈δ为一些临界值,不同的q对应的基于相邻参照区的压缩策略选择的算法总结算法1.FunctionCompression_Strategies(segments)输入:s需要压缩的段输出:压缩是否成功(0:失败,1:成功)1.设置i=1为段s的第1个区的区号2.设置m1=0,推荐压缩策略mtemp=m13.whileei不是最后一个区4.ifi==15.计算统计信息Ti={ri,si,ai,di,ni,ci,li}6.mtemp=f(Ti)7.else8.根据mtemp,获得ri,si,ai,di,ni,ci,li中的相关信息9.根据式(1)计算对应的相似因子Sj10.ifSj11.mtemp=mi-112.else13.获得当前区的统计信息Ti={ri,si,ai,di,ni,ci}14.mtemp=f(Ti)15.endif16.endif17.mi=mtemp18.按照mi的压缩方式对本区的数据进行压缩19.i=i+120.endwhile21.endFunction步3~步20是算法的主要部分,实现整个列的压缩.步4~步6统计第一个区的统计信息,并获得第一个区的压缩算法.步7~步17处理列中其它区的信息:步8根据推荐压缩算法来推断需要统计的信息;步9计算出相似因子,如果相似,则本区的压Page5缩算法就采用推荐的压缩算法,否则就重新统计区中的相关信息并得到压缩算法.以图1中的数据为例,比较适合第101个区中的压缩算法为游程编码,那么第102个区的推荐压缩算法也就为游程编码,那么判断游程编码是否适合第102个区,只需通过统计第102个区中相同值连续的平均数目即可,如果不小于4,则适合采用游程编码,否则需要重新进行学习,对推荐压缩算法进行修正.根据图1所示,第102个区的数据可以采用游程编码.以此类推,当到第301个区时,不满足游程编码的条件,因此这个区需要重新学习,从而得到第301个区的压缩方案为字典编码.那么下一个区的推荐压缩方案为字典编码.上面的f是通过统计量获得合适压缩算法,这里令f=Get_Compression_Method,算法如下:算法2.FunctionGet_Compression_Method(统计信息Ti)输入:当前区的统计信息Ti={ri,si,ai,di,ni,ci}输出:压缩策略1.推荐压缩策略mtemp=不压缩2.计算qi={q1i,q2i,q3i,q4i,q5i}的值3.if区中的数据是布尔类型4.if数据是有序的5.mtemp=游程编码6.else7.mtemp=位图编码8.endif9.elseifq2i>σ110.编码方式为空值编码11.elseifq1i>σ512.ifq3iσ213.mtemp=游程编码14.elseifq4iσ315.mtemp=位图编码16.else17.mtemp=字典编码18.endif19.elseif区中的数据是整数类型20.mtemp=整数压缩编码21.elseifq5i>σ422.mtemp=LZ23.else24.mtemp=不压缩25.endif26.Returnmtemp27.endFunction算法中的σ1,σ2,σ3,σ4,σ5是用来估计压缩算法的阈值,其具体取值在实验部分给出.例如算法第9步q2i>σ1表示区中空值大于一定阈值,则推荐压缩算法为空值压缩.这里的空值编码是指对于item的值为空值时,数据库将不分配空间,只是给一个标记用来表示item的值为空.整数编码采用的是文献[2]的算法.算法的步3~步8是处理布尔类型的数据,这是因为布尔类型的数据只有两个值,那么统计量q1i=100,q4i=2或q5i=1,因此需要特殊处理.当数据是有序的情况下,则意味着区中的数据的结构为图3中的3种类型中的一个,因此,用游程编码是最合适的;当数据是没有排序的情况下,采用位图编码是比较合适的.算法的步9~步10是用来处理区中空值比较多的情况.步11~步18是用来处理区中公共值比较多的情况的.其中步12~步13用来处理区中的公共值大多是连续出现的情况的,因此采用游程编码;步14~步15则是针对不同值相当少的情况的,同时也避免了数据是经过排序的情况,因此采用位图编码还是比较好的选择;在其它情况下,则采用字典编码,这就是步16~步17的内容.步19~步20则处理数值类型中既没有太多的空值,又没有太多的相同值的情况下的压缩,这种时候采用整数压缩编码还是很好的选择.4.2基于参照列的压缩策略选择基于参照列的压缩策略选择的基本思想是:数据在整个列上的分布具有一致性,因此可以用整个列的统计信息作为参照推断待压缩区的数据分布,从而进行策略推荐.这里从待压缩的段中随机抽取若干个区(如段中区的数目的1/20)作为样本,将这些抽取出来的区中数据的分布代表整个段中的数据的分布特点.通过对这些抽取出来的区的数据进行统计,得到与统计信息相匹配的压缩算法,从而确定这个段的推荐压缩方式.与该段中统计数据分布相似的区,将采用推荐的压缩策略压缩,否则将重新学习来确定压缩算法.这里将随机抽取的区中的数据的相关统计信息记为T={r,s,a,d,n,c},统计量为q={q1,q2,q3,q4,q5},这里定义了当前区ri和样本区r的相似因子为S={S1,S2,…,S5},推荐压缩方案mtemp=f(T),其中T为抽取出来的区的统计信息.Page6若Sj似,可以进行策略推荐,可得到mj=mtemp.否则则认为两者不相似,需要对当前待压缩区进行局部学习,从而对压缩策略进行修正.其中δi∈δ为一些临界值,和4.1节相同.那么通过算法2获得合适的压缩方法.基于参照列的压缩策略选择的算法如下.算法3.FunctionCompression_Strategies(segments).输入:s需要压缩的段输出:压缩是否成功(0:失败,1:成功)1.设置m1=0,推荐压缩策略mtemp2.从段s中随机挑选出约1/20的区3.获得这些区的统计信息T={r,s,a,d,n,c}4.得到推荐压缩算法mtemp=f(T)5.whiles中的数据没有压缩完毕6.根据mtemp,获得ri,si,ai,di,ni,ci,li中的相关信息7.计算相似因子Si8.ifSj9.采用mtemp进行数据压缩10.else11.获得当前区的统计信息Ti={ri,si,ai,di,ni,ci}12.调用f(Ti)来得到合适的压缩算法并压缩数据13.endif14.i=i+115.endwhile16.endFunction算法的步2~步4主要是获得随机区中的数据并进行统计得到推荐压缩算法.步5~步15则是对每一个区的处理过程.步8~步9是对与段的数据分布相同的区的压缩算法采用推荐压缩算法,而与段的数据分布不相同的区的处理则是在步10~步13中.以图1中的数据为例,通过对抽取一部分随机的区的数据的分析,可以得出这个段的推荐压缩方案为游程编码.在处理第101个区时,推荐压缩方案为游程编码,而第101个区的数据分布的特点满足游程编码的要求,因此不用进行学习.当处理到第301个区时,统计分析的结果不满足右侧很难过编码的特点,因此第301个区需要重新学习,从而得到适合的压缩方案为字典编码,但是此时下一个区的推荐压缩方案仍为游程编码,而不是字典编码,这和算法1有着明显的区别.5实验验证(1)实验环境Intel(R)Pentium(R)4CPU2.80GHz,内存DDR512MB,缓存L1:8KBytes,L2:12Kuops,L3:512KBytes.软件环境操作系统为WindowsXPProfessionalVersion2002ServicePack3,开发环境为MicrosoftVisualC++6.0.本文用C语言实现了基于学习的压缩策略选择方法,在此基础上,设计了两个实验,用来和C-Store的决策树进行相比,从压缩率和压缩所需要的时间两个方面进行对比.(2)数据集描述本文实验的数据是采用数据仓库基准数据集SSB中的customer表的数据.本文选择customer表的mktsegment列来进行测试.这是因为在数据库使用的压缩方法中,字典编码、游程编码和位图编码是最常用也是最重要的3种压缩方法.在mktsegment列中一共只有5个不同的值.根据观察可以看出,如果基于C-Store决策树的方法,那么根据C-Store决策树分析,应该采用位图编码来对数据进行压缩.而本文提出的基于学习的区级压缩模式下的策略选择方法则可以采用的压缩方案为字典编码、位图编码和游程编码.因此本文提出的两种实现方法和基于C-Store决策树的方法就可以很好地在同样的数据中进行比较,由此看来mktsegment列有很强的代表性.本实验中采用的区的大小为16KB,可以存放大约2000个左右的数据.本文分别对660KB,1980KB,3300KB,4620KB,5940KB,7260KB,8580KB,9900KB,11220KB9种不同大小的数据进行了测试.根据不同压缩算法的特点,本文方法中涉及的一些参数取值如下:σ1=30,σ2=4,σ3=4,σ4=20,σ5=20,δ1=5,δ2=5,δ3=1,δ4=3,δ5=5.(3)实验结果与分析本文从以下两个方面对3种不同压缩策略选择方法:基于学习的压缩策略选择方法、基于统计分析的压缩策略选择方法和基于C-Store决策树的压缩策略选择方法进行比较:a)压缩率比较.通过在同一种数据类型(这里为字符串类型)不同数据量上进行比较,如图4所示.图中的数据不包含槽的长度(每一个项(item)对应一个槽,每个槽的长度为13B),指的是每一个Page7item压缩之后的长度.从图4可以看出,本文提出的两种压缩策略选择方法要比基于学习的区级压缩模式下的策略选择方法的压缩效果好.这是因为,当数据量大的时候,数据的整体的特点虽然变得比较清晰,但是在局部的地方,数据的分布和整体还是有很大的区别.并且随着数据量的增大,和整体数据具有不同分布的局部变得越来越多,这也就造成了这些局部的数据需要用更加合适的方法进行压缩,才能提高压缩率.在实验中,基于C-Store决策树的压缩策略选择方法为整个列得到的压缩方法为位图编码,而本文提出的策略选择方法采用局部学习获得的压缩方案包括位图编码、游程编码和字典编码.绝大部分的区的压缩方案为字典编码,一少部分区的压缩方案为位图编码和游程编码.表2显示的是一个item在一部分压缩方案压缩之后的表示形式以及压缩之后的占用的空间的大小.其中X为0或者1,N表示参与位图编码的不同值的数目.例如customer表的mktseg-ment列中共有5个不同的值,采用位图编码的话,那么这里的N就为5.显然,采用字典编码更节省空间(位图编码还有另外一种实现方式,用一个位来表示压缩之后的数据,这样有一个缺点,很难定位一个item,不利于查询,如果再用一条记录来标记位置的话,占用的空间则更大).压缩方法压缩之后的结构压缩之后占用的空间字典编码(字典编号)位图编码(XXXXXXXX)N个字节游程编码(value,begin_id,len)Length(value)+8+8基于学习的压缩策略选择方法和基于统计分析的压缩策略选择方法的压缩效果相差不大.但是随着数据量的增大,前者的压缩效果要稍优于后者.这是因为基于学习的压缩策略选择方法在每一个区上都实现了最大限度的压缩,而基于统计分析的压缩策略选择方法则是通过随机抽取一定量的区的统计信息来得到整个列的统计信息,从而得到推荐压缩方法,这也就意味着这种方法在采样随机性的影响,因此,无法保证对每一个区上的推荐压缩算法是适当的压缩算法,造成了压缩比稍低于前者.b)压缩时间的比较.主要是指对同样大小的数据,完成压缩所需要的时间.如图5所示.从图5可以看出,在数据量比较小的时候,3种方法所用的压缩时间相差不大,而当数据量增大的时候,基于C-Store决策树的压缩策略选择方法需要的时间要稍长于本文提出的两种压缩策略选择方法.这是因为,基于C-Store决策树的压缩策略选择方法需要对整个列的数据的全部统计信息进行统计,而本文提出的两种区级压缩模式下的压缩策略选择方法则不同,在大部分区中只需要统计部分的统计信息来验证本区适合采用推荐的压缩算法,只有在不满足推荐压缩算法的区才统计全部的统计信息,这样一来,随着数据量的增大,这种差别就变得比较明显.从图5中可以看出,本文提出的基于学习的压缩策略选择方法和基于统计分析的压缩策略选择方法在压缩相同大小的数据时需要的压缩时间相差很小,偶尔后者需要的压缩时间要稍大于前者,这是因为后者采用的是通过随机抽取一定数量区的数据作为样本来估计整个列的数据分布,从而推测出最适合这个列的压缩方法,但是有时会发生估算错误,也就意味着样本数据的分布特点和这个列的数据分布特点不相符,这就意味着更多的区需要学习,也就会造成时间的浪费.6结论通过第5节的分析可以看出,本文提出的两种区级压缩模式下的压缩策略选择方法要优于基于C-Store决策树的压缩策略选择方法.本文的两种区级压缩模式下的策略选择方法通过对局部数据的学习来推断后面的数据的分布,并通过对下一部分的数据的统计信息进行分析来验证是否符合推荐压缩方式的特点,从而对压缩算法进行校正,找到适合本部分的压缩方法,这也就意味着,每一个部分都得到了较好的压缩,从而表现出优于基于C-Store决策树的压缩策略选择方法的特点.通过压缩比和压缩时间的比较,本文提出的基于学习的压缩策略选择方法要优于基于统计分析的压缩策略选择方法.Page8虽然在压缩比和压缩时间上表现出比C-Store决策树更优的性能,但是区的大小也是一个影响压缩效果的重要因素.区过大或者过小多是不利于压缩的.因此需要更进一步的实验来确定区的大小,并对数据仓库最重要的两类查询:范围查询和聚集查询进行测试.另外本文的算法中使用到了一些阈值,这些阈值在下一步的工作中进行测试确定.
