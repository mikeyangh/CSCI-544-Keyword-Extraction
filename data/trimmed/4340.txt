Page1基于概率SLCA的XML过滤张晨静1)王晓玲2),3)周傲英2),3)1)(上海海洋大学信息学院上海201306)2)(华东师范大学软件学院上海200062)3)(复旦大学上海市智能信息处理实验室上海200433)摘要不确定数据管理逐渐成为一个重要的研究方向.作为网络交换重要标准的XML数据的不确定管理也成为一个研究热点.基于关键字的概率XML检索是其中一个重要的分支.目前对于概率XML关键字检索的研究,都只考察了结点之间的独立(IND)关系和互斥(MUX)关系.由于更普遍的结点依赖关系在表述和计算上的复杂性,较少有工作讨论.文中讨论概率XML模型PrXML{exp,ind,mux}中基于SLCA语义的关键字过滤.这种模型中通过EXP结点描述更普遍的结点依赖关系.文中在定义了子树中关键字概率分布表tab及其相关的运算后,分别给出了模型中不同类型结点关键字概率分布表的计算方法,并给出了不需要构造可能世界直接求解SLCA结点概率的算法.文章通过实验评估了算法的特性和性能.关键词不确定数据;概率XML;关键字过滤;SLCA;关键字概率分布表1引言不确定数据在众多数据处理应用中出现,不确定数据管理成为一个重要的研究方向.有很多因素导致数据的不确定性,例如由于监测设备的局限,传感器数据本身具有不确定性;由于人的主观因素,医疗数据本身存在的不确定性;不同来源的数据存在冲突或者不一致,导致数据的不确定性;使用爬虫从网络自动提取数据时或者在数据挖掘系统中出现的数据不确定性.在这些不确定数据中,很多时候数据来源本身具有树形结构,或者可以使用父子关系描述数据间的依赖关系.这些应用中的不确定数据的管理可以归属于概率XML数据管理.目前,概率XML数据管理的研究主要集中在不确定模型的研究和数据检索等方面.关于概率XML模型的研究工作,主要有文献[1-7].目前有几种概率XML数据模型的表示方法.例如文献[5]给出了使用不同符号表示的3种标签(tag),分别是概率值tag、与概率值对应的数据值tag、普通tag.但是文献[5]没有给出数据具体表示形式的示例,而且其中只考虑了互斥关系的概率分布.文献[3]使用有向无环图描述概率XML,使用六元组(probabilisticinstance)来表示半结构化实例中对象的信息以及对应概率,用孩子结点集合来描述孩子结点之间的依赖关系.文献[6]使用“模糊树”描述概率XML,树中的每个结点与一组概率事件变量的联合有关.一个概率XML文档记作p-document,其中包含两种结点:distributional结点和ordinary结点(ORD结点).ordinary结点来自源XML文档的结点,distributional结点用来表示源XML文档中兄弟结点之间的关系.distributional结点有5种类型:IND,MUX,DET,EXP和CIE.两方面特征进行区分[8]:概率XML文档p-documents模型,主要通过(1)概率XML文档p-documents中使用的(2)是否直接在distributional结点之间构建distributional结点的类型.层次.文献[8]定义了distributional结点之间不存在直接层次的文档类型distributional-hierarchy-free(DHF):每一个distributional结点只有ordinary类型的孩子结点的数据模型.例如,给定概率XML数据模型PrXML{ind,mux}指的是只包含“IND”和“MUX”类型的distributional结点.而PrXML{ind,mux}仅包含“IND”和“MUX”类型的distributional结点并且distributional结点只有ordinary类型的孩子结点的数据模型.很多地方直接根据包含distributional结点的类型进行数据模型的分类.文献[7]根据distributional结点的类型将p-document的家族定义为PrXMLC,C{IND,MUX,DET,EXP,CIE}.关于概率XML数据检索,文献[8-12]进行了结构化查询的研究.相比结构化查询,关键字检索更容易被用户接受.概率XML关键字检索方面的研究有文献[13-16]等.从XML关键字语义的角度看,文献[13]讨论了概率XML中基于ELCA语义的关键字检索.在文献[14]中指出,ELCA语义包含了SLCA语义,因此尽管ELCA语义会有更丰富的结果信息,而SLCA语义的结果更精确.文献[15-16]讨论了概率XML中基于SLCA语义的关键字检索.文献[15]采用倒排索引的方式实现类似SLCA语义的概率范围关键字查询.文献[16]讨论了数据集中场景下PrXML{ind,mux}模型中基于SLCA语义的关键字查询.然而文献[15-16]包括文献[13]只考察了概率XML中兄弟结点间的独立、互斥依赖关系.尽管在文献[2]中提到,概率XML的很多重要应用中不要求结点之间的任意依赖关系.然而,还有一些常见而且有用的数据依赖值得考察.例如,一篇XML文档的两个作者:Hung和Tommy都存在不确定性,而且Tommy出现的时候,Hung以一定概率出现(例如师徒关系或者合作关系).XML数据之间的这种依赖关系很常见,而且这种数据依赖的存在对于维护数据准确性和查询正确性都很有价值.本文讨论概率XML环境下,具有更通用的兄弟结点依赖关系的模型PrXML{exp,ind,mux}中基于SLCA(SmallestLowestCommonAncestor)的关键字过滤问题,给出概率XML中SLCA结点的定义、结点成为SLCA结点的概率计算方法、以及结点概率计算封闭性证明,最后通过实验评估算法的效率.2问题定义本文要解决的问题是在概率XML中求解SLCA结点及其作为SLCA结点的概率.本节将给出概率XML中SLCA结点的定义.确定XML中Page3SLCA结点的语义要求:子树中包含全部关键字,并且子孙结点不具备前述条件.由此,定义1给出概率XML环境中SLCA结点的语义.为SLCA结点要满足两个条件:定义1.在概率XML环境中,一个结点v成(1)以结点v为根结点的子树SubT(v)的可能世界中包含全部关键字的概率大于常数C(0C1).(2)任何结点v的子孙结点不满足前述条件(1).以结点v为根结点的子树SubT(v)的可能世界中包含全部关键字的概率就是结点v作为SLCA结点的概率,它包括两部分:结点v存在的概率Pr(pathr→v)(r表示XML文档的根结点,结点存在的概率与从根结点到当前结点的路径上所有结点的概率都有关);子树SubT(v)中包含所有关键字的概率Prlocal(v).这个概率可以用式(1)来表示.因此,求解SLCA结点及其成为SLCA结点的概率存在两个主要的挑战:(1)如何计算当前结点v的存在概率.(2)如何计算当前结点v为根结点的子树SubT(v)中包含全部关键字的概率.为了解决第1个挑战:结点v的存在概率,需要得到从根结点到当前结点路径上的所有结点的条件概率.以往工作中,p-document中仅包含ORD、IND、MUX结点的情况下,所有结点的条件概率是已知的,但是在包含EXP结点的情况下,EXP结点的孩子结点以集合概率的形式存在,没有单独的条件概率.3.3.1小节将讨论EXP结点对当前结点v存在概率的影响,并给出结点v存在概率的计算方法.为了解决第2个挑战:结点子树中包含全部关键字的概率,本文设计了基于stack的自底向上的方法,利用下层结点中关键字分布情况的概率表计算上层结点的关键字概率分布表.为此,3.2节定义了结点v为根结点的子树SubT(v)中关键字分布概率表tab,定义tab上的·、+、×运算,给出了不同类型结点概率分布表的计算方法,并证明了这些计算的封闭性.本节给出了本文要解决的主要问题,以及存在的挑战.下一节给出这些问题的解决方案.3解决方案上一节指出本文要解决的问题和解决这个问题的两个挑战.本节首先给出问题的整体解决方案,然后详细介绍求解过程中需要的算子,以及如何解决存在的两个挑战.3.1总体方案本文设计了自底向上处理p-document的方案,求解SLCA并计算SLCA结点的概率.具体方案是:自底向上扫描文档,对于叶子结点,结点存在概率和结点包含关键字的概率分布都能够简单得到,再利用式(1)得到其成为SLCA结点的概率;对于非叶子结点,根据不同结点类型,结合子孙结点包含关键字的概率,利用不同的公式得到当前结点包含关键字的概率.此概率比C大,当前结点是SLCA结点,从而实现定义1中的第(1)个条件;在自底向上扫描XML文档时,下层结点如果是SLCA结点,这一信息将传递给上层结点,阻止上层结点成为SLCA结点,保证定义1中的第(2)个条件.由此,求解SLCA并计算SLCA结点概率.结点成为SLCA结点的概率包含在结点关键字概率分布表tab中.在整个计算过程中,需要求解不同类型结点的tab.因此,下文首先定义结点关键字概率分布表tab,然后定义不同类型结点tab计算时涉及到的tab上的运算算子,最后,给出不同类型结点tab的计算方法.3.2算子定义结点成为SLCA结点的概率包含在结点关键字概率分布表中.因此,需要定义结点v为根结点的子树SubT(v)包含关键字的概率分布表tab.tab的构成如定义2.定义2.tab信息:每个结点v的tab信息tabv见式(2):itemi=〈bitvectori,Probi〉,0Prob1,∑itabv描述了结点v对应子树SubT(v)中各种关键字包含情况的概率分布信息.它包含若干项,每一项是一个二元组〈bitvector,Prob〉.bitvector中的每一个二进制位代表一个关键字,记录在子树SubT(v)中出现的关键字;Prob表示当前bitvector表示的关键字组合在子树中出现的概率.例如,查询中包含两个关键字,那么bitvector∈{“00”,“01”,“10”,“11”},①为了区别下文中定义的“·”运算符,本文中用“”表示标量Page4在计算上层结点的概率分布表时需要将当前结点v的概率分布表与一个概率值(例如v的存在概率)相乘.定义3描述了这种乘法.定义3.tab信息的点积(·):tab·p={〈Bt,Prob〉|〈Bt,Prob0〉∈tab,一个结点的tab信息与一个浮点数p求点积,就是将tab信息中的每个项中的概率Prob值放大p倍,每个项中的bitvector不变.引理1.tab上的点积运算具有封闭性.证明.根据定义3,〈Bt,Prob〉∈tab·p,有〈Bt,Prob0〉∈tab,那么Bt来自tab,并且0Prob01,二元组中的Bt在运算中封闭.已知0p1,Prob=Prob0pp1,因此运算中概率计算也封闭.因此,tab上的点积运算封闭.在计算当前结点v的概率分布表时,根据结点v的孩子结点之间的依赖关系(例如相互排斥),可能需要将v的孩子结点的tab信息累加,定义4给出tab上的求和运算:tabv中的一个项〈“01”,0.3〉表示在子树SubT(v)中,两个关键字中第一个关键字出现,这种仅出现第一个关键字的概率是0.3.定义4.tab信息求和(+):S1={〈Bt,Probitemi+Probitemj〉|〈Bt,Probitemi〉∈tab1∧〈Bt,Probitemj〉∈tab2},S2={〈Bt,Probitemi〉|〈Bt,Probitemi〉∈tab1∧(j,itemj∈tab2∧Bt≠bitvectoritemj)},S3={〈Bt,Probitemj〉|〈Bt,Probitemj〉∈tab2∧(i,itemi∈tab1∧Bt≠bitvectoritemi)}(4)给定两个结点的tab信息tab1和tab2,tab1+tab2由若干项组成:tab1和tab2中bitvector值相同的项保留bitvector值并将概率相加得到新的项;只出现在tab1中的bitvector值,连同其Prob值一起作为结果集中的一项;只出现在tab2中的bitvector值同样连同Prob值一起作为结果集中的一项.假定tab1={〈“01”,0.3〉,〈“00”,0〉,〈“10”,0〉,〈“11”,0〉},tab2={〈“01”,0.1〉,〈“10”,0.5〉,〈“00”,0〉,〈“11”,0〉}.那么tab1+tab2={〈“01”,0.4〉,〈“10”,0.5〉,〈“00”,0〉,〈“11”,0〉}.在计算当前结点v的概率分布表时,根据结点v的孩子结点之间的依赖关系(例如相互独立),可能需要将v的孩子结点tab信息相乘.tab之间的乘法(笛卡尔积)运算如定义5.定义5.tab信息的笛卡尔积(×):tab1×tab2={itemi×itemj|itemi∈tab1∧itemj∈tab2}(5)itemi×itemj={〈newBt,newProb〉|newBt=bitvectoritemi|bitvectoritemj∧newProb=ProbitemiProbitemj}给定两个结点的tab信息tab1和tab2,tab1×tab2表示,tab1中所有的项和tab2中所有的项分别进行bitvector的位或运算得到新的bitvector,对应概率相乘得到新的概率.在式(5)的结果中会将式(6)中得到的bitvector相同的项合并(概率相加).假定tab1={〈“01”,0.3〉,〈“00”,0〉,〈“10”,0〉,〈“11”,0〉},tab2={〈“01”,0.1〉,〈“10”,0.5〉,〈“00”,0〉,〈“11”,0〉}.那么tab1×tab2={〈“01”,0.03〉,〈“11”,0.15〉,〈“00”,0〉,〈“10”,0〉}.本文的算法中,只有满足特定关系tab才能进行+、×运算.后文中关于父结点包含关键字概率分布的计算中,会证明运算的封闭性.tab上的多种运算之间的优先级如定义6.定义6.定义tab上运算符的优先级:+,×,·运算优先级依次递增.通过运算化简和转化的方法可以避免构造概率文档的可能世界,优化运算.为此引理2证明tab上+、×运算的分配律.引理2.任给tab1、tab2、tab3,tab1×tab3+tab2×tab3=(tab1+tab2)×tab3.证明.假定查询中有两个关键字(任意个数的关键字同样方式可以证明),那么bitvector的取值{“00”,“01”,“10”,“11”}.设3个tab信息如表1.(“00”,p1,0)(“00”,p2,0)(“00”,p3,0)(“01”,p1,1)(“01”,p2,1)(“01”,p3,1)(“10”,p1,2)(“10”,p2,2)(“10”,p3,2)(“11”,p1,3)(“11”,p2,3)(“11”,p3,3)要证明tab1×tab3+tab2×tab3=(tab1+tab2)×tab3,只需要证明左边结果集合与右边结果集合的项完全相同.首先证明任给左边集合中的一项,在右边集合中有同一项.根据定义4和定义5可知,在左、右两边结果集合中包含且仅包含2#Keywords项,每一项的bitvector取值用0~2#Keywords-1之间的数对应的二进制数表示.任取一个bitvector的值,假定取“01”,Page5考察tab1×tab3+tab2×tab3中bitvector为“01”的项的概率.tab的求和“+”只针对项中bitvector相同的项进行概率的算术累加,因此tab1×tab3+tab2×tab3中的bitvector为“01”的项中的概率是tab1×tab3和tab2×tab3中的bitvector为“01”的项中的概率的和.表2给出了tab1和tab3进行×运算能得到“01”bitvector值的组合.tab1(“00”,p1,0)(“01”,p3,1)(“01”,p1,0p3,1)(“01”,p1,1)(“01”,p3,1)(“01”,p1,1p3,1)(“01”,p1,1)(“00”,p3,0)(“01”,p1,1p3,0)表3给出了tab2和tab3进行×运算能得到“01”bitvector值的组合.tab2(“00”,p2,0)(“01”,p3,1)(“01”,p2,0p3,1)(“01”,p2,1)(“01”,p3,1)(“01”,p2,1p3,1)(“01”,p2,1)(“00”,p3,0)(“01”,p2,1p3,0)因此,tab1×tab3+tab2×tab3中的bitvector为“01”的项是(“01”,p1,0p3,1+p1,1p3,1+p1,1p3,0+p2,0p3,1+p2,1p3,1+p2,1p3,0).(tab1+tab2)×tab3中bitvector为“01”的项,是如表4所示的3个tab中的项混合运算的结果.tab1tab2tab3(tab1+tab2)×tab3(“00”,p1,0)(“00”,p2,0)(“01”,p3,1)(“01”,(p1,0+p2,0)p3,1)(“01”,p1,1)(“01”,p2,1)(“00”,p3,0)(“01”,(p1,1+p2,1)p3,0)(“01”,p1,1)(“01”,p2,1)(“01”,p3,1)(“01”,(p1,1+p2,1)p3,1)将表4中3个结果相加,得到(tab1+tab2)×tab3中bitvector为“01”的项是:(“01”,(p1,0+p2,0)p3,1+(p1,1+p2,1)p3,0+(p1,1+p2,1)p3,1).由此可见,在(tab1+tab2)×tab3)中有一个和tab1×tab3+tab2×tab3中的bitvector为“01”的项相同的项.同样可以证明等式左边其他的项在右边都有相同的项存在.同理也可以证明右边集合中任意一项在左边也都有相同的项对应.因此,tab1×tab3+tab2×tab3=(tab1+tab2)×tab3在含有两个关键字时成立.同样的方式可以证明在任何关键字个数情况下,tab1×tab3+tab2×tab3=(tab1+tab2)×tab3成立.3.3结点成为SLCA结点的概率计算上一小节给出了运算中需要的算子,本小节给出求解结点成为SLCA结点的概率时存在的两个挑战的解决方法.图1所示是模型PrXML{exp,ind,mux}中的一个XML文档树.其中包含ordinary结点、EXP结点和MUX结点.图中缺少IND类型distributional结点.因为IND结点和ordinary结点的处理方式相同[16],此图省略了这种类型的distributional结点.边上的数据表示孩子结点(或孩子结点集合)在父亲结点存在时的条件概率,缺省条件概率是“1”.图1中,结点“Paper”是ordinary结点,其孩子结点“Author”和“Year”之间相互独立,即“Author”结点的存在概率与“Year”结点存在的概率无关.“MUX”结点表示其孩子结点是互斥关系,即“Year”=2008和“Year”=2009的情形互斥.“EXP”结点表示其孩子结点“Tommy”和“Hung”这两个作者之间不是单纯的独立或者互斥关系,可能因为某种原因(例如师徒关系等)存在相互依存关系,这种比较复杂的依赖关系用“EXP”结点表示,用结点集合的概率来描述.图中的“EXP”结点有两个孩子结点,孩子结点集合分别是{Tommy},{Hung}和{Tommy,Hung},对应的集合概率分别是0.3、0.2和0.5.下面用如例1所示的关键字查询说明结点作为SLCA结点的概率计算过程.例1.关键字查询:Tommy,2008.3.3.1结点存在的概率Pr(pathr→v)p-document中每个结点都是概率存在的,可以使用贝叶斯公式计算概率XML文档树中结点存在的概率.结点存在的概率只跟从根结点到自身的路径上所有结点的条件概率有关.IND、MUX类型结点的孩子结点的条件概率是已知的.EXP结点,已知的是孩子结点集合条件概率,不是单个结点的条件概率.因此,要讨论EXP结点的存在对结点存在概率计算的影响.Page6EXP结点在当前结点的子孙中出现.从根结点到当前结点v路径上没有EXP结点,那么该路径上所有结点的条件概率都是已知的,可以直接使用路径上各个结点的条件概率累乘得到v的存在概率.EXP结点在当前结点的祖先中出现.从根结点到当前结点v路径上有EXP结点,那么EXP结点的孩子结点也在这个路径上,要先根据孩子结点集合的条件概率计算每个孩子结点的条件概率,才能进一步计算当前结点存在的概率.如图1,ordinary结点“Author”存在的概率恰好等于其条件概率“0.7”.结点“2008”存在的概率为“0.610.2=0.12”.结点“Tommy”是EXP结点的孩子结点,通过集合概率计算得到结点“Tommy”的条件概率是“0.3+0.5=0.8”,最后计算得到结点“Tommy”存在的概率是“0.56”.3.3.2子树中包含关键字的概率Prlocal(v)概率XML文档中,在没有子孙结点是SLCA的情况下,当前结点v成为SLCA结点的概率就是子树SubT(v)包含所有关键字的可能世界的概率和.因此,计算当前结点v包含关键字的概率要用到子孙结点包含关键字的概率信息.本文自底向上遍历结点,利用下层结点关键字包含情况的概率计算上层结点包含关键字的概率,可以在一遍扫描数据时得到SLCA结点及其作为SLCA结点的概率.要从孩子结点包含关键字的不确定性得到父亲结点包含关键字的不确定性,存在两个问题:(1)结点需要传递什么信息给父亲结点?(2)父亲结点如何处理来自各个孩子的信息,从而得到以自身为根结点的子树包含关键字的概率信息?本文用包含多种概率信息的二元组〈prob,tab〉来解决第1个问题.针对第2个问题,根据不同结点类型,本文构造了利用孩子结点传递来的信息计算当前结点tab信息的计算公式.下面给出这两个问题的解决方案.传递给父亲结点的元组.在概率XML中,每个结点传递给父亲的信息是一个二元组〈prob,tab〉.prob是孩子结点的条件概率,tab是孩子结点对应子树中包含关键字的信息,见定义2.图1中,“Tommy”是叶子结点,直接包含第1个关键字.子树SubT(Tommy)包含关键字情况的概率tabTommy如表5所示(所有叶子结点的tab信息都可以直接得到).000那么结点“Tommy”传递给父亲结点的信息是二元组〈0.8,tabTommy〉.叶子结点“2008”的tab信息如表6所示.结点“2008”传递给父亲结点的信息是〈0.2,tab2008〉.000为了节省存储空间,只需要记录tab中Prob非0的项.父亲结点对孩子元组的汇总.任何类型的非叶子结点接收到孩子结点的信息后进行的概率计算可以使用下述步骤进行:累加.所有可能世界的概率.(1)根据孩子结点之间的关系,计算孩子结点(2)计算各个可能世界中包含关键字的概率.(3)将所有可能世界中包含关键字情况的概率以上步骤得到的就是当前结点的tab信息,然后将这些信息向更上一级传递.为了避免构建孩子结点所有可能世界,针对IND(和ORD)、MUX、EXP类型结点的概率计算,本文通过公式转化与化简,在不构造可能世界的情况下计算结点的tab,降低计算的时间复杂度.MUX结点.任给结点M是MUX类型的distributional结点.设它有n个互斥的孩子结点X1,X2,…,Xn,每个结点的条件概率是Pi,结点Xi存在时对应子树SubT(Xi)包含关键字的情况表记作tabXi.不包含任何孩子结点的可能世界的概率是Pn+1=1-∑1in是tabn+1={〈“00”,1〉}.那么MUX结点M包含关键字情况的概率表tabM可以表示为式(7).附录中引理3证明了式(7)计算得到的概率分布表符合定义2中对于结点包含关键字的概率分布表的要求.利用式(7),单遍扫描孩子结点数据就可以得到MUX类型结点的tab信息.在图1中,根据孩子结点“2008”和“2009”的tab值,结点“MUX”的tab值tabMUX如表7所示.Page7000.8EXP结点.不确定数据的概率分布是多粒度多级别的[17-18],概率XML中的概率分布也是一样.给定的IND类型和MUX类型结点的条件概率都是结点级别的概率.而EXP类型结点给定的是孩子结点集合条件概率,是集合级别概率.给定任意EXP结点E,每个孩子结点的tab值已经计算得到,有m个孩子结点子集,对应的概率分别是Pi(1im).每个孩子结点集合中的结点、这些结点的子孙结点和结点E一起构成一个SubT(E)的可能世界.假定当前孩子结点集合包含n个结点,对应的tab值分别是tab1,tab2,…,tabn,那么SubT(E)的当前可能世界包含关键字情况概率表tabpw用式(8)表示:以图1中结点“EXP”为例,SubT(EXP)有3个可能的世界,pw1={EXP,Tommy},pw2={EXP,Hung},pw3={EXP,Tommy,Hung}.tabpw1=tabTommy,tabpw2=tabHung,tabpw3=tabTommy×tabHung.根据式(8)计算得到3个可能世界的tab值分别见表8、表9和表10.000001000附录中引理4证明式(8)中涉及到的tab上的×运算封闭.根据附录中引理4可知,式(8)中的tabpw符合定义2.如果计算得到SubT(E)的所有可能世界包含关键字情况概率表分别是tabpw1,tabpw2,…,tabpwm.那么子树SubT(E)关键字包含情况概率表用式(9)表示:tabE=P1·tabpw1+P2·tabpw2+…+Pm·tabpwm,附录中引理5证明了式(9)中计算得到的“EXP”结点的概率分布表tabE符合定义2.以图1中结点“EXP”为例,由式(9)可得子树SubT(EXP)包含关键字情况概率表tabEXP=0.3·tabpw1+0.2·tabpw2+0.5·tabpw3,见表11.000.2实验中,EXP结点的子集信息和对应概率信息也作为结点属性存储在文档中.IND结点和ORD结点.给定IND类型或者ORD类型的结点,有n个互相独立的孩子结点X1,X2,…,Xn.所有孩子结点的联合分布是P(X1,X2,…,Xn)=P(X1)P(X2)…P(Xn)(10)由式(10)可以得到孩子结点所有可能世界的概率,共2n个.每一个可能世界中各种关键字包含情况概率可以用如式(11)表示:P(X1)·tabX1×P(X2)·tabX2×…×P(Xn)·tabXn(11)结点Xi(1in)存在的概率P(Xi=1)是给定的,那么可得P(Xi=0)=1-P(Xi=1).结点Xi存在时,对应的结点Xi的tab信息已经由Xi的孩子结点信息计算得到.如果结点Xi不存在,对应的tab信息tabXi=0={〈“00”,1〉,〈“01”,0〉,〈“10”,0〉,〈“11”,0〉}.用tabXi表示tabXi·P(Xi)(1in),式(11)转化为式(12).父亲结点的tab信息tabIND.然后,所有可能世界的结果累加就是IND类型tabIND=∑X1,X2,…,Xn由引理2可知,式(13)可以转化成式(14):tabIND=∑X1附录中引理6证明了式(14)计算得到的“IND”结点的概率分布表tabIND符合定义2.如果是ORD类型的结点,因为它本身可能包含关键字,上述式(14)中要增加ORD结点本身包含关键字的信息tabORDlocal,最终子树SubT(ORD)中包含关键字信息tabORD用式(15)计算.tabORD=tabORDlocal×∑X1附录中引理7证明了式(15)计算得到的“ORD”Page8结点的概率分布表tabORD符合定义2.由式(14)和(15)可以看出,通过一遍扫描孩子结点信息,计算各结点tab信息的笛卡尔积,就得到IND类型或ORD类型父亲结点的tab信息.图1中的结点“Paper”是ORD类型结点.tabPaper=(0.7·tabAuthor+0.3·{〈“00”,1〉})×(0.6·tabYear+0.4·{〈“00”,1〉}).而tabAuthor=tabEXP,tabYear=tabMUX.tabEXP和tabMUX见表11和表7.计算得到tabPaper见表12.000.38720.49280.05280.0672表12中“11”对应的概率0.0672表示当前结点“Paper”子树SubT(Paper)中包含全部关键字的概率是0.0672.结点“Paper”成为SLCA结点的概率是0.0672.本节针对本文的目标和挑战,给出了详细的解决方案.下一节将会给出相应的算法分析.4算法上一节介绍了求解SLCA结点及其概率的方案以及概率计算过程中涉及到的运算、公式.本节给出相应的算法分析.在SAX解析XML文档时,为每一个XML结点(ordinary结点和distributional结点)保留一条(level,id,bt,nProb,type,expInfo,tab)信息.level,id,bt分别表示当前结点的深度、结点ID和包含关键字的信息.nProb记录当前结点在父亲结点存在时的条件概率.type记录当前结点的类型,可以取的值包括ORD、IND、MUX、EXP、SLCA,type=“SLCA”表明当前结点或者当前结点子孙结点已经是SLCA结点,这个信息向上传递阻止祖先结点成为SLCA结点.expInfo是为EXP类型的结点记录孩子结点子集的信息.tab是当前结点所在子树中包含关键字的信息.当XML文档前序遍历的时候,遍历到的所有结点的信息入栈.当子孙结点处理结束,子孙结点的信息会传递给上级结点来更新栈中的信息,一旦发现SLCA结点就及时反馈.文档解析完毕,所有的计算结束.4.1算法描述算法1描述了文档中SLCA结点及其概率的计算过程.算法1.FindSLCA.输入:XMLtreenoden,tabn输出:trueifhasfoundSLCAnode,falseotherwise1.found=false;2.IFnisleafnodeTHEN3.computetabn;4.IFtheprobofallkeywordsappearingintabnis5.outputnodenanditsprobability;6.found=true;7.ENDIF8.ELSE9.FOReachchildnodencDO10.IFFindSLCA(nc,tabnc)istrueTHEN11.found=true;12.ENDIF13.ENDFOR14.IFfound==falseTHEN15.computetabnusingallchildren’stabtabnc16.IFtheprobofallkeywordsappearingin17.outputnodenanditsprobability;18.found=true;19.ENDIF20.ENDIF21.ENDIF22.RETURNfound;算法1中以文档根结点为输入,递归调用自身,计算文档树的SLCA结点及其概率,如果找到SLCA结点,算法返回true,否则返回false.算法输入一个文档树结点,以及该结点的tab信息tabn(作为输入参数,tabn此时为空,在算法中会被赋值).算法第2行首先判断结点n是否是叶子结点,如果是叶子结点,可以直接得到结点的tab信息tabn(算法第3行);用tabn中的信息可以判断结点n是否是SLCA结点,如果是SLCA结点,输出结点信息并返回true.如果结点n不是叶子结点(算法第8行),对于结点n的每个孩子结点nc,计算其tab信息tabnc(算法第9行).如果任何一个孩子结点nc的子树中发现了SLCA结点,置变量found为true(算法第11行).如果所有的孩子子树中都没有发现SLCA结点,利用所有孩子结点的tab信息,并根据结点n的类型使用上文中提到的计算方法计算结点n的tab信息tabn(算法第15行).如果tabn中的相关概Page9率显示n是SLCA结点,输出结点n及其概率,置found为true(算法第17~18行).最终,算法返回found的值(算法第22行).4.2算法复杂度分析算法的时间复杂度主要与文档中结点的个数、结点的类型有关.整个算法,在针对概率XML的一次扫描中,对不同类型的结点进行处理,处理的过程就是结点之间tab信息的×、+运算.ORD、IND、MUX类型的结点在处理过程中只需单遍扫描;EXP类型的结点,因为同一个结点会出现在不同的集合中,需要访问多次.若文档的结点个数是n,只考察ORD、IND、MUX结点时,由于算法使用stack后序处理概率文档,利用已得到的下层结点的概率表计算上层结点的概率表,所以可以仅扫描一遍就得到结果.因此,算法的时间复杂度是Ο(n).如果同时考察EXP结点,EXP结点孩子结点的个数是m1个,EXP结点孩子结点的集合的个数是s个,平均每个集合中结点的个数是m2个.所以EXP结点的孩子结点被扫描的次数是sm2,算法的复杂度是Ο(n+sm2-m1).因此,在文档尺寸固定的情况下,如果EXP类型的结点个数多、EXP类型结点的孩子集合多、孩子集合中的结点个数多,都会影响算法的时间效率.5实验本节对概率XML中基于SLCA的关键字过滤算法进行实验评估.实验分别对算法在数据集特征、查询特征、结果集合大小等方面的特征和性能进行考察.实验程序使用Java语言编写.使用的硬件环境是双核2G内存的台式机.实验数据集采用真实DBLP数据集.数据的大小包括5M、10M、30M、50M、131M.对于每一个采用的数据集,按照文献[8,16]所述的方法产生不确定数据.采用前序遍历的方式扫描源文档中的数据,对于每一个被访问的结点v,按照5%~20%的概率随机产生IND、MUX或者EXP类型的结点作为v的孩子结点.选择一些结点v原来的孩子结点作为新产生的distributional结点的孩子结点,并赋以随机的概率分布.如果是MUX类型的结点,孩子结点的概率之和不超过“1”.EXP类型的子集合的概率和等于“1”,平均每个EXP结点有2个孩子结点子集合.对于包含EXP结点的文档,要预先计算孩子结点的单结点概率保存在文档中.对应的不确定数据集的特征如表13所示.IDsize/M#IND#MUX#EXP#OrdinaryS16.24701673660130047S26.6464348544763130047S312.413492141730251581S413.1921393449113251581S537.241325424370765889S639.4277492868728162765889S762.2693837216601286098S865.84684148489464151286098S9160.0830878643003332130S10164.05582557390556483332130S11164.017954118729903332130S12168.01211721246531212683332130S13173.026181227145703332130S14177.01762281814381756243332130S15180.034389335629003332130实验中的查询使用文献[16]中的一部分查询,如表14,另外还采用了文献[19-20]中查询(标记为kN-L-H)的产生方式,产生指定频率的随机查询.其中kN是查询中关键字的个数.L和H是关键字出现的最低频率和最高频率.每个查询中,仅有一个关键字的频率取到最低频率L,其他所有关键字的频率都是最高频率H.随机产生一组查询并反复执行5遍.以下实验图中记录的是每条查询的平均运行时间.IDD1D2D3D4D5数据集特征的影响.本节从数据结点特征(distributional结点的比例)、数据集尺寸两个方面考察数据集对查询效率的影响.为了观察distributional结点数量的变化对查询性能的影响,本组实验选用的distributional结点的比例为5%、10%、14.5%和20%,对应文档S9、S11、S13、S15.使用表14给出的5个查询.对于不含有EXP结点的文档,在处理的时候可以采用优化算法.图2给出了不同查询在不同数据集上分别采用优化和无优化算法运行的平均查询时间.数据显示,针对同一个查询,随着distributional结点数量的增加查询处理时间基本成线性增长.虽然Page10distributional结点的处理会花费一定的时间,但这并不是主要原因.主要原因在于随着distributional结点比例的增加,整个需要处理的文档的尺寸增长了,算法需要处理的文档尺寸增大,处理时间增长.经过优化的算法,在节省存储空间的同时,避免了无关结点的处理,从而节省了查询处理时间.图2distributional结点比例变化对查询效率的影响图3考察了数据尺寸对于平均查询时间的影响.采用数据S1,S2,…,S10,随机产生一组查询,查询类型是2-100-100.数据表明平均查询时间与数据查询基本成线性关系,这也说明了算法的时间复杂度主要与文档中结点的数目有关.查询特征对于查询效率的影响.在关键字查询实验中,往往考察查询关键字频率、关键字个数、查询数量对于查询性能的影响.图4记录了不同关键字频率的查询处理时间.采用的文档是S11和S12,随机产生查询,类型如图4中横坐标所示.数据显示,在查询关键字的频率从100增长到10000的过程中,查询处理的平均时间并没有太大的变化.因此,算法对于查询关键字的频率不敏感.使用文档S11和S12,图5考察了算法对于查询关键字个数变化的影响.关键字个数从2增长到4,关键字的频率是100-100.数据显示随着关键字个数的增长,查询处理时间线性变化.无论数据集的大小,本文的算法都需要且仅需要扫描解析一遍数据.在数据固定的情况下,图6考察查询个数的变化对于平均查询性能的影响.使用数据集S11和S12,随机产生查询,查询类型是2-100-100.图6显示,随着查询数量的增大,平均查询时间逐渐减少并趋于平稳.Page11不同C值的影响.在定义1中指出,包含全部关键字的概率要大于常数C.本段给出改变C值对算法的影响.使用数据集S11和S12,随机产生查询,查询类型是2-100-100.图7显示,不同C值,查询处理时间有毫秒级变化,总体看C的变化没有明显影响平均查询时间.因为,算法中所有概率的计算与C值没有关系,C仅与结点包含全部关键字的概率进行了比较,断定该结点是否是SLCA结点.因此C的改变没有明显影响查询处理时间.与以往技术的比较.在以上实验中,算法扫描一遍文档得到需要的SLCA结点及概率,影响本文算法时间的主要因素是问题的规模.在4.2小节中指出,设文档结点个数为n,本文算法使用stack后序处理概率文档,利用已得到的下层结点的概率表计算上层结点的概率表,所以可以仅扫描一遍就得到结果.因此,在不考虑EXP结点情况下,算法的时间复杂度是O(n).同样,设文档结点个数为n,而文献[16]中算法PrStack,首先扫描一遍文档得到关键字结点列表(包含结点条件概率),然后通过在关键字结点间进行Dewey码匹配计算SLCA结点,该步骤扫描结点个数不少于n.对于这些SLCA结点,利用下层结点的概率自底向上计算该结点的概率分布表.假定有t个这样的SLCA结点,平均每个结点子树中包含d个子孙结点,那么在计算SLCA结点的概率时,需要扫描的结点个数是td.从问题规模的角度看,文献[16]中算法PrStack复杂度是Ο(n+td).另外,本文除了读取文档,所有的计算不涉及外存访问;而文献[16]中算法将关键字结点列表等信息以索引形式在外存存储,因此,除了读取文档之外,计算过程中也涉及外存访问.因此,在同样只考虑IND,MUX结点的情况下,本文算法在时间上较有优势.6总结本文讨论了概率XML模型PrXML{exp,ind,mux}中基于SLCA的关键字过滤.该模型中不仅考察了结点间的独立(IND)、互斥(MUX)关系,也考察了结点间更普遍的依赖关系(用EXP结点描述).文章给出了结点子树包含关键字的概率分布表tab、tab上的各种运算,并证明了运算的封闭性,给出了各种类型结点tab的计算方法,进而给出了自底向上计算子树包含关键字概率的算法,从而在单遍扫描数据并且不构造可能世界的情况下求解SLCA结点及其成为SLCA结点的概率.实验数据表明,算法在数据类型、数据尺寸、查询数量等方面有一定的扩展性,尤其对于查询关键字的频率变化不敏感,适合高频的关键字过滤.未来,我们会在概率XML模型和不确定数据检索方面进行深入研究.
