Page1命令式模糊程序语言的语义吴恒洋(杭州电子科技大学信息工程学院杭州310018)(华东师范大学上海市高可信计算重点实验室上海200062)摘要文中关注计算机语言的形式语义学,旨在建立一种命令式模糊程序语言的指称语义与最弱(线性)前置条件语义.首先,借助模糊逻辑中的三角模、三角余模、非、蕴含以及模糊关系的合成等成功地完成了这两种语义的建模.这种方法为形式语义学的研究提供了一个新的视角.其次,证明了该语言的一些重要性质并讨论了最弱前置条件语义与最弱线性前置条件语义之间的关系.最后,证明了指称语义与最弱(线性)前置条件语义之间的对偶,该对偶表明了这两种语义可以相互诱导.关键词模糊程序语言;命令式语言;指称语义;最弱(线性)前置条件语义;模糊逻辑1引言计算机语言的形式语义学是计算机科学与技术的重要研究内容之一,其研究成果对于编译技术、软件安全以及分布式计算等计算机分支领域有重要的Page2不一定.本文关注非经典计算机程序语言的语义,概率程序语言是一种非经典语言,其在语义方面的研究已经较为成熟,见文献[2-7]等.模糊程序语言是另一种非经典语言,可以描述模糊算法及模糊控制规则,已经大约有30年的发展历史,见文献[8-12]等.最近,接受模糊语言机器的研究也达到了很高的水平,如李永明关于模糊自动机与模糊图灵机的研究[13-14].尽管在这些研究中有些工作涉及了语义,如Alvarez等人在文献[11]中研究了一种命令式模糊程序语言的操作语义,然而通过与概率程序语言的研究相比较,我们发现模糊程序语言在语义方面的研究有两个问题没有涉及:(1)没有抽象地研究模糊程序语言的指称语义;(2)研究中没有涉及公理语义与最弱(线性)前置条件语义.本文将重点关注这两个问题.Bueno等人在文献[9-10]中分别给出了模糊程序语言L与XL,XL是L的扩充,允许无限循环语句(while).与其它的模糊程序语言相比较,例如,HALO[8],这两个语言的主要特征是它们的简单性;与经典程序语言以及概率程序语言相比较,它们的主要特征是引入了模糊赋值语句X··=FUZZ(X).下面是L与XL语言的抽象版本,是一种命令式语言:S∷=skip|X··=FUZZ(X)|S1;其中模糊赋值语句X··=FUZZ(X)连接一个模糊关系P,b是一个布尔条件,即从状态空间到{0,1}的映射.其它的语句在命令式语言中都是常见的.本文的中心工作是建立上面的命令式模糊程序语言的指称语义与最弱(线性)前置条件语义.指称语义是状态空间X上的模糊关系,而最弱前置条件语义是从状态空间X上的模糊集(X)到自身的一个泛函,且该泛函是同态的并且是析取的.证明了该语言的一些重要性质并且指出了这两种语义之间的对偶,此对偶表明从一个语句的指称语义可以诱导相应的最弱(线性)前置条件语义,反之亦然.在研究中,模糊逻辑是基础,其中标准非、三角模、相应的三角余模及→分别被用来模拟模糊非、合取、析取及蕴含.2预备知识这一部分回顾本文所用到的一些知识,主要有模糊逻辑、模糊集以及模糊关系.模糊程序语言的逻辑基础是模糊逻辑.用符号,,及→分别模拟模糊逻辑中的非、合取、析取及蕴含,其中是标准非,即对任意的a∈[0,1],a=1-a,是一三角模,是相应的三角余模,即对于任意的a,b∈[0,1],ab=1-(1-a)(1-b),而→既是S-蕴含也是剩余蕴含:即对于任意的a,b,c∈[0,1],且abc当且仅当ab→c.可以看出只需要连接词与即可以描述该模糊逻辑.基于ukasiewicz三角模与Fodor-Wang三角模0的模糊逻辑满足上面的条件.之所以称为Fodor-Wang三角模,是因为该三角模首先被Fodor在文献[15]中提出,几乎同时也被王国俊教授在文献[16]中独立地提出.对于任意的a,b∈[0,1],本文结论在这两种逻辑下都是成立的,将在后面解释为什么使用这样的模糊逻辑.模糊集是从某个论域X到单位区间的映射.X上的所有模糊集记为(X),其序是点式的,即对任意的A,B∈(X),AB当且仅当对于任意的x∈X,A(x)B(x).模糊集的最小上界与最大下界定义为:设Ai∈(X)(i∈I),x∈X,清楚地,(X)是完备格,其最小元与最大元分别是0与1,满足对于任意的x∈X,0(x)=0,1(x)=1.点模糊集ηx为:若y=x,则ηx(y)=1;否则为0.对于任意的r∈[0,1],常值模糊集r满足:对于任意的x∈X,r(x)=r.另外,对于任意的A,B∈(X),x∈X,定义:特别地,(rA)(x)=rA(x).清楚地,对于任意的模糊集A,A=x∈XA(x)ηx.关系可以描述程序语言的语义,如经典的二元关系可以描述经典程序的语义,概率关系可以描述概率程序的语义.本文使用模糊关系描述模糊程序的指称语义.给定两个状态空间X,Y,从X到Y的模糊关系P正是积空间X×Y上的模糊集,其序是点Page3式的.最大元与最小元分别记为⊥与⊥,满足对于任意的(x,y)∈X×Y,⊥(x,y)=1与⊥(x,y)=0.模糊关系的最小上界与最大下界定义为:设{Pi|i∈I}是X×Y上的模糊关系集,对于任意的(x,y)∈X×Y,X×X上的恒等关系Id定义为对于X×Y上的模糊关系P及Y×Z上的模糊关系Q,模糊关系的合成P·Q是X×Z上的模糊关系,定义为:对于任意的(x,z)∈X×Z,(P·Q)(x,z)=supy∈YP(x,y)Q(y,z).3指称语义先看一个模糊程序语言应用的例子[10].模糊程序语言可以描述模糊控制规则.考虑下面的规则其中S与M是图1与图2所示的模糊集.此规则是控制一个抽象进程的部分系统,例如教室的灯光自动控制系统.下面给出描述该规则的程序.这两个模糊集对应的隶属函数是μA:Z+→[0,1].这样有一个分明的程序,其输入是Z+中的任意元素,输出是隶属度(0→0,0.1→1,0.2→2,…,1.0→10).对应于S与M的程序:S_set=(1,1,T),T如下:S;beginifX1>0andX110thenX2··=X1fi;ifX1>10andX120thenX2··=20-X1fi;X1··=X2endM_set=(1,1,N),N如下:M;beginifX1>30andX140thenX2··=X1-30fi;ifX1>40andX150thenX2··=50-X1fi;X1··=X2end需要为一个模糊预程序函数建立算法:(1)标识符FUZZ0连接ψ01定义为(2)标识符FUZZi(i=1,…,r)连接下面的函数Ii(x,y)=li,y=x主要的程序使用一个微指令FLATTEN(X1,X2),定义为:FLATTEN连接程序R=(2,1,V),其代码V是FLATTEN;beginifX2=1thenX1··=FUZZ1(X1)fi;ifX2=2thenX1··=FUZZ2(X1)fi;ifX2=rthenX1··=FUZZr(X1)fiend现在可以显示主要的程序P=(1,1,Q),其代码如下FUZZCON;begin1.X2··=S(X1);2.ifX2≠0thenX1··=FLATTEN(X2,X1)fi;3.X1··=0;X2··=0;4.whileM(X1)=0do5.X1··=suc(X1);6.od;7.whileM(X1)≠0do8.ifX4≠1then9.X2··=M(X1);10.X4··=FUZZ0(X1);11.ifX4··=1then12X3··=FLATTEN(X1,X2);13.fi;14.fi;15.X1··=suc(X1);16.od;17.ifX4≠1then18.X1··=pred(X1);19.X2··=M(X1);Page420.X3··=FLATTEN(X1,X2);21.fi;22.X1··=X3end假定输入X1=12,可以得到输出是Z+上的模0.1/31+0.2/32+…+0.7/37+0.8/38+0.8/39+0.8/40+0.8/41+0.8/42+0.7/43+…+0.2/48+0.1/49.此模糊集解释了该控制规则,如图3所示.糊集:从该程序可以看出:(1)赋值语句有两种情况:经典的与模糊的.例如,经典赋值语句X1··=suc(X1)(后继),它可以看成关系P,定义为:若y=x+1,则P(x,y)=1;否则为0;模糊赋值语句X1··=FUZZ2(X1)可以看成模糊关系R,定义为:若y=x,则R(x,y)=0.2;否则为0.因此经典赋值语句是模糊赋值语句的特殊情形.(2)出现在这程序中的语句包括:赋值语句、顺序语句、条件语句以及循环语句,添上常见的跳过语句,即skip,则得到下面的命令式模糊程序语言:S∷=skip|X··=FUZZ(X)|S1;下面将借助模糊逻辑与模糊关系的合成,通过指称语义与最弱(线性)前置条件语义解释该语言.指称语义表明程序运行的结果,是一种前向语义,即给定一个输入,考察输出是什么.从上面的程序可以看出,对于一个输入,输出是状态空间上的一个模糊集.因此,对于任意一个指令S,它的指称是S:X→(X).这可以等价地看成状态空间X上的模糊关系,即S:X×X→[0,1].在注释1中解释使用模糊关系的好处.下面是用递归的方法给出的语义链:skip=Id;X··=FUZZ(X)=P,其中P是X··=FUZZ(X).连接的模糊关系S1;S2=S1·S2;ifbthenS1elseS2(x,y)=b(x)S1(x,y)b(x)S2(x,y);whilebdoS=μF,其中μF是泛函F的最小不动点,F:(X×X→[0,1])→(X×X→[0,1])定义为:对于任意的R∈(X×X→[0,1])与(x,y)∈X×X,因为Fn(⊥)=F(Fn-1(⊥))且F0(⊥)=⊥.因为模糊关系集(X×X→[0,1])是完备格,且F是单调泛函,所以有下面的命题.命题1.泛函F有下面的性质:(1)F保并.(2)F有最小不动点μF=n∈ωFn(⊥),其中证明.(1)证明是直接的,忽略.(2)首先n∈ωFn(⊥)是泛函F的不动点,这是F(n∈ωFn(⊥))=n∈ωF(Fn(⊥))=n∈ωFn+1(⊥)=n∈ωFn(⊥)(由于F0(⊥)=⊥),其次,假定R是任一不动点,即F(R)=R.由于⊥R且泛函F是单调的,所以对于任意的n∈ω,Fn(⊥)Fn(R)=R.进一步,n∈ωFn(⊥)R.这样证明了n∈ωFn(⊥)是泛函F的最小不动点.证毕.例1.模糊赋值语句X··=FUZZ(X)连接一个模糊关系P,定义为取状态空间为正整数集,当输入x=3时,输出为一个模糊集A=1/2+0.5/1,此模糊集也可以理解为状态空间X上的一个可能性分布.这样,X··=FUZZ(X)(3,2)=1的意思是输入3,输出2的可能性是1,而输入3,输出不是2与1的可能性是0.注1.(1)若定义指称S:X→(X),则顺序语句S1;S2不能直接合成,需将S2提升至S2:(X)→(X),从而定义S1;S2=S2S1.使用模糊关系的合成避免了提升.(2)本文b取值0或1,也有些工作b在单位区间中取值,如Jones在文献[3]中关于概率程序的研究与Vetterlein等人在文献[12]中关于模糊程序语言FAS的研究.本文的结果能否推广到单位区间是将来要考虑的问题.Page54最弱前置条件语义最弱前置条件语义(wp)是Dijkstra在文献[17]中提出的,是刻画程序运行的一种重要的公理化方法.它支持对程序进行推理,是一种后向语义,即给定一个后置条件(输出应当满足的),去推理前置条件(输入应当满足的),例如,对于指称语义一节中的引例,为了达到预期的控制效果,可以借助最弱前置条件语义去推理输入应当是怎样的.下面是用递归的方式给出的语义链:wp(skip,B)=B;wp(X··=FUZZ(X),B)=λx.supy∈XP(x,y)B(y);wp(S1;S2,B)=wp(S1,wp(S2,B));wp(ifbthenS1elseS2,B)=bwp(S1,B)bwp(S2,B);wp(whilebdoS,B)=μG,其中G:(X)→(X)且G(A)(x)=b(x)wp(S,A)(x)b(x)B(x).有下面的定理.定理1.wp(S,B)有下面的性质:(1)严格性.wp(S,0)=0.(2)单调性.wp(S,B1)wp(S,B2)若B1B2.(3)同态性.wp(S,rB)=rwp(S,B),其中r∈[0,1].(4)析取性.wp(S,i∈IBi)=i∈Iwp(S,Bi),其中{Bi:i∈I}(X).证明.证明的方法是归纳S的结构,本文只证明S=whilebdoS的情形.选取同态性证明,其它的性质可以类似证明.对于任意的A∈(X),由于对S的归纳,有wp(S,rA)=rwp(S,A).现在证明:wp(whilebdoS,rB)=rwp(whilebdoS,B).设G:(X)→(X)满足G(A)(x)=b(x)wp(S,A)(x)b(x)B(x),G:(X)→(X)满足G(A)(x)=b(x)wp(S,A)(x)b(x)只需证明:对于任意的r∈[0,1],μG=rμG.首先,易证G(rA)=rG(A).因此,G(rμG)=rG(μG)=rμG,即rμG是G的不动点.下面证明rμG是G的最小不动点.假设C是G的任一不动点.对于任意的r∈[0,1],由于r(r→C)C,所以由G的单调性,有G(r(r→C))G(C)=C.又由于G(r(r→C))=rG(r→C),所以rG(r→C)C,因此G(r→C)r→C.根据Tarski不动点定理(见文献[18],第50页):μG={A∈(X)|G(A)A},有μGr→C,故rμGC.这样rμG是G的最小不动点,即μG=rμG.证毕.定理2.对于任意的指令S及任意的模糊集B,有证明.证明的方法是归纳S的结构,只证明S=whilebdoS的情形.由于对S的归纳,已有wp(S,B)=λx.supy∈XS(x,y)B(y).现在只需证明:是泛函G(上面式(1))的最小不动点,这又等价于证明:是泛函G的最小不动点,其中F的定义见第3节.事实上,(n∈ωFn(⊥))(x,y)B(y)supy∈X=supy∈Xsupn∈ωFn(⊥)(x,y)B(y)=supy∈Xsupn∈ωFn+1(⊥)(x,y)B(y)=supn∈ωsupy∈XFn+1(⊥)(x,y)B(y)=supn∈ωsupy∈XF(Fn(⊥))(x,y)B(y)=supn∈ωsupy∈X(1-b(x))Id(x,y)]B(y)[supy∈X=supn∈ω(1-b(x))B(x)][supy∈X=supn∈ωB(y)](1-b(x))B(x)][supz∈X=supn∈ωB(y)](1-b(x))B(x)][b(x)supz∈X=supn∈ω(1-b(x))B(x)][b(x)wp(S,An)(x)(1-b(x))B(x)],=supn∈ω其中An=λz.supy∈XFn(⊥)(z,y)B(y),可以验证A0=0且An+1=λz.b(z)wp(S,An)(z)(1-b(z))B(z).这样wp(whilebdoS,B)=n∈ωAn.G(n∈ωAn)(x)=n∈ωG(An)(x)=n∈ωb(x)wp(S,An)(x)(1-b(x))B(x)=(n∈ωAn+1)(x)=(n∈ωAn)(x)(由于A0=0).其次,n∈ωAn是G的不动点.这是因为Page6最后,假设C是G的任一不动点.可以用数学归纳法证明n∈ωAnC,即n∈ωAn是G的最小不动点.(1)n=0,清楚地A0C,(2)假设n=k,AkC.则Ak+1(x)=b(x)wp(S,Ak)(x)(1-b(x))B(x)b(x)wp(S,C)(x)(1-b(x))B(x)=G(C)(x)=C(x).因此对于任意的n,AnC,故n∈ωAnC.证毕.例2.继续例1,希望程序运行后,输出的结果是“接近3”,那么输入应当怎样呢?假定该模糊程序语言使用的是ukasiewicz逻辑,“接近3”定义为模糊集B=0.6/1+0.8/2+1/3+0.8/4+0.6/5.这个问题实际上就是计算wp(X··=FUZZ(X),B),经过计算可以得到wp(X··=FUZZ(X),B)=0.6/2+0.8/3+1/4+0.8/5+0.6/6+0.1/7.wp(X··=FUZZ(X),B)(4)=1,意思是输入4得到输出“接近3”的可能性是1,而wp(X··=FUZZ(X),B)(7)=0.1,意思是输入7得到输出“接近3”的可能性是0.1.5最弱线性前置条件语义最弱前置条件语义(wp)描述全正确的程序,即程序运行后一定终止.为了描述部分正确的程序,即程序运行后不一定终止,需要最弱线性前置条件语义(wlp),下面是其定义:wlp(skip,B)=B;wlp(X··=FUZZ(X),B)=λx.infy∈XP(x,y)→B(y);wlp(S1;S2,B)=wlp(S1,wlp(S2,B));wlp(ifbthenS1elseS2,B)=bwlp(S1,B)bwlp(S2,B);wlp(whilebdoS,B)=νT,其中νT是T的最大不动点,T:(X)→(X)且T(A)(x)=b(x)wlp(S,A)(x)b(x)B(x).有下面的定理.定理3.wlp(S,B)有下面的性质:(1)终止性.wlp(S,1)=1.(2)单调性.wlp(S,B1)wlp(S,B2),若B1B2.其中r∈[0,1].其中{Bi:i∈I}(X).(3)→同态性.wlp(S,r→B)=r→wlp(S,B),(4)合取性.wlp(S,i∈IBi)=i∈Iwlp(S,Bi),证明.证明方法与定理1类似,忽略.定理4.对于任意的指令S及任意的模糊集B,有证明.证明方法与定理2类似,忽略.下面的定理指出了最弱前置条件与最弱线性前置条件之间的关系,这一关系表明:对于任意的指令S与任意的模糊集B,某个输入x使程序S运行后终止在某个状态,且该状态满足B或者B的可能性加上程序不终止的可能性是1.定理5.对于任意的指令S与及任意的模糊集B,有wp(S,B)+wlp(S,B)=1.证明.注2.定理1的证明需要蕴含→是剩余蕴含,而定理5的证明需要蕴含→是S-蕴含,这就是本文一开始作这样要求的原因.使用这样的模糊逻辑可以得到确定型经典程序与确定型概率程序都有的大部分结果,至于使用其它的模糊逻辑能否得到本文的全部结果,还需要进一步的考虑.6对偶与逻辑通常,在指称语义与最弱前置条件语义之间有和谐的对偶关系,该对偶表明指称语义可以诱导相应的最弱前置条件语义,反之亦然.Hoare在文献[19]中证明了经典程序语言的这种对偶;Jones在文献[3]中证明了其概率程序语言的这种对偶.这一节,将证明命令式模糊程序语言的这种对偶.给定一个泛函T:(X)→(X),它是同态的并且是析取的,即T满足T(rA)=rT(A)且T(i∈IAi)=i∈IT(Ai),其中A,Ai(i∈I)∈(X),r∈[0,1].定义T:X×X→[0,1],使得对于任意的(x,y)∈X×X,Page7给定模糊关系R:X×X→[0,1],定义R°:(X)→(X),使得对于任意的A∈(X),x∈X,清楚地,R°是同态的并且是析取的.定理6.(R°)=R且(T)°=T.证明.首先,对于任意的(x,y)∈X×X,因此(R°)=R.其次,对于任意的A∈(X),x∈X,因此(T)°=T.此时称R与R°以及T与T是对偶的.通过这个对偶可以看出逻辑与语义之间的关系:模糊程序S的语义被定义为模糊关系X×X→[0,1],而最弱前置条件语义是泛函(X)→(X),它是同态的并且是析取的,这样语义S对偶于最弱前置语义给出的泛函,即λA.wp(S,A),这在符号上可以表示为S°=λA.wp(S,A),而且根据定理6也有(λA.wp(S,A))=S.这种对偶如图4所示.其中Com是指令集,即模糊程序,Sem是指令集的指称语义,即X上的模糊关系,Log是同态的并且是析取的泛函(X)→(X).类似地,也可以证明指称语义与最弱线性条件前置语义之间的这种对偶关系,此时Log是→同态的并且是合取的泛函(X)→(X).7结论及未来工作本文关于模糊程序语言语义的研究,借鉴了概率程序语言语义研究的中的一些思想与方法.对于概率程序而言,程序的指称从输出的结果看,有两种情况:一是确定型,即一个输入对应一个概率分布输出;二是不确定型,即一个输入对应多个概率分布输出,这种不确定性由概率幂域[3,7]来模拟.另一方面,由于概率分布可以直接定义在某个状态空间上[4]或定义在该状态空间的某种子集上[3,5],所以指称语义的模型又有离散与连续两种情况.本文对于一个输入,输出是状态空间上的一个模糊集(或称可能性分布),是一种离散的确定模型.这种研究思路在以往关于模糊程序语言语义的研究中并没有得到很好的体现.文献[9-10]虽然也是离散模型,但并没有抽象地研究命令式语言的指称语义,更没有研究最弱前置条件语义,而且在研究的过程中也没有区分全正确程序与部分正确程序.正是考虑到这些问题,本文借鉴概率程序的研究思路,并结合模糊逻辑中的各种算子恰当地建立了这些语义模型,这也是本文最显著的特点.下一步的工作重点是连续模型.事实上,已在文献[20]中给出了一种连续的确定模型,而在文献[21]中已给出了基于Hoare幂域的连续的不确定模型.下面重点要解决的是基于Smyth幂域的连续的不确定模型.
