Page1基于动作空间的三维装箱问题的确定性高效率求解算法何琨黄文奇(华中科技大学计算机科学与技术学院武汉430074)摘要三维装箱问题要求将有限个三维矩形物体尽可能多地装入到一个三维矩形箱子中,使得箱子的填充率即体积利用率最大.在求解三维装箱问题的穴度算法的基础之上,进一步做了以下改进:(1)将当前剩余空间中可能放入的每个体积最大的三维矩形虚拟物体所对应的空间定义为动作空间,在动作空间内放入物体并使穴度的定义体现放入物体与动作空间的吻合程度;(2)在物体放入位置的选择上直接体现“金角银边草肚皮”的思想,每一步只选择最靠近箱子边缘的一个动作空间来装载物体;(3)结合捆绑策略,将形状大小相同的物体捆绑为一个较大的矩形块进行放入,对捆绑块形状大小的选择为在不超出动作空间的前提下尽量用物体填满该空间的两至三个维度.实验结果表明,改进后的穴度算法在付出很少的开销代价的情况下显著地提高了箱子的填充率.关键词三维布局;装箱;启发式;动作空间;穴度1引言Packing问题(布局问题)是高复杂度的典型的NP难度问题,在现实生活中有着广泛的应用.本文研究三维欧氏空间中一种典型的Packing问题———装箱问题(containerloadingproblem),即已知一个形状大小任意给定的长方体形的箱子和有限个形状大小分别任意给定的长方体形的物体,要求确定一个可行的装箱方案,使得箱子的填充率即{(∑放入物体的体积)/箱子的体积×100%}最大.物体的放置要求满足以下约束:放入的物体完全被包含在箱子内,棱平行于箱子的棱,且任意两物体均无重叠.在实际应用中,特定的装箱问题还需要考虑一些其他的约束,例如方向约束和稳定性约束.本文考虑方向约束,即物体的某些放置方向被禁止使用.在现实生活中,当待放物体内为装满液体的瓶子时会有此类约束.本文不考虑稳定性约束,其原因在于:(1)国内外文献中对稳定性约束的定义并不一致,有的要求每个物体必须得到其他物体或箱子底部的完全支撑,有的要求被支撑的底面积达到一定的比率,有的则仅要求物体的几何重心得到支撑即可;(2)当箱子的填充率很高时,稳定性会成为高密度放置的一种自然的结果;(3)可以在少量的空隙中填入海绵、橡胶或其他填充物以保证整个装载的稳定.从国内外的相关研究中可看出,启发式方法已成为求解三维装箱这一NP难度问题的有效方法.目前国内外研究者多采用构造型启发式算法与邻域搜索算法相结合的方式来求解此问题.其中构造型算法多借助人类在砌砖、砌墙、货物堆放及下围棋等方面的实践经验,求解方法主要包括砌墙法[1-9]、块排列法[10-12]、极大空间法[13-14]、堆构造法[15]、穴度法[16]等.在此基础上,可进一步结合遗传[3-4,15]、退火[5,9,11]、禁忌[5,10,12]、树搜索[6,16]、随机搜索[7-8,13]、变结构邻域搜索[14]等算法以进行邻域搜索.基于拟人途径,在求解二维矩形Packing问题的穴度算法的基础之上[17],我们提出了求解三维装箱问题的穴度算法[16],通过“穴度”来统一评价当前物体与其他已放入物体及箱子的紧密程度,并取得了很好的计算结果.然而,穴度算法的计算时间较长.例如,对于有100个形状大小不同的待放物体的装箱实例,其计算时间约为2h~3h.这使得沿原方案进一步改进算法的性能变得比较困难.另外,穴度算法尚未利用形状大小有较多相同的弱异构型算例的特点,因此对弱异构型算例的求解质量不够高.本文受极大空间法的启发[13-14],将当前剩余空间中每个体积最大的三维矩形空间定义为动作空间,给出了动作空间的明确定义,并改进穴度的定义使之体现放入物体与动作空间的吻合程度.然后,进一步结合捆绑策略以利用弱异构型算例的特点,从而得到了基于动作空间的改进型穴度算法ICDA(ImprovedCavingDegreeAlgorithm).对于7组共700个著名的装箱实例[1]的计算结果表明,改进后的穴度算法同时具有求解质量高和计算时间短的优点.特别是对于其中的2组共200个算例,新算法得到了高于前人的平均填充率,将Parreo等人于2010年最新发布的最好纪录分别提高了0.12和0.10个百分点.2基于动作空间的改进型穴度算法改进的穴度算法包括构造型算法和邻域搜索算法两部分.其中构造型算法每一步将形状大小相同的长方体捆绑成一个大的长方体块,并挑选一个靠近箱子边缘的体积较大的动作空间来放入该捆绑块.而邻域搜索算法则是在构造型算法的基础上加以回溯处理.下面依次给出动作空间的定义、动作空间待放角区的选择方法、动作空间的选择方法以及放入到动作空间中的捆绑块的生成和选择方法,最后给出求解三维装箱问题的构造型算法和邻域搜索算法.2.1动作空间设在当前格局下,箱子中已经放入了0至多个长方体.我们用若干个动作空间来描述当前格局下剩余的空闲空间.定义1.动作空间.在当前格局下,若往箱子中合法地放入一个虚拟的长方体,该长方体的上、下、左、右、前、后6个面均与已放入的物体或箱子的壁相贴(即重合的面积大于0),则该虚拟长方体所占的空间称为当前格局下的一个动作空间.图1所示为在箱子的左下后角放入一个物体后当前格局下的3个动作空间,它们分别在该物体的右方、前方和上方.Page3图1动作空间可见,动作空间代表了当前剩余空间中可能放入的每个最大长方体的形状和位置.动作空间之间可以有重叠.而且,在动作空间中放入物体,只要不超出该空间,就可以保证该物体不会与其他已放入的物体或箱子的壁重叠.2.2动作空间的待放角区每个动作空间均为三维的矩形空间,因此有8个角区.将捆绑块放入到一个动作空间时,我们选择8个角区中最靠近箱子边缘的一个角区来放入该块.具体做法是:动作空间的每个角区与箱子有一个对应角,如图2所示.分别计算动作空间的每个角区与箱子对应角在x、y、z方向的距离,并从小到大排列为三元组,称为该角区的角距离.然后依字典序比较不同角区角距离的大小,并选择角距离最小的一个角区作为该空间的待放角区.算法对动作空间的8个角区编号,并依次考查每一个角区.下面给出选择动作空间待放角区的子算法.算法1.SELECT_CANDIDATE_CORNER.输入:动作空间space输出:该空间的candidateCorner1.Begin2.待放角区candidateC←NULL(初值为空);3.FORi=1to8:4.对动作空间space的每一个角区Ci:5.计算该角区的角距离;6.IFcandidateC=null,THEN7.candidateC←Ci;8.ELSE9.依字典序比较candidateC与Ci的角距离;10.IFCi的角距离较小,THEN11.candidateC←Ci;12.ENDIF13.ENDIF14.ENDFOR15.space.candidateCorner←candidateC;16.ENDSELECT_CANDIDATE_CORNER.2.3动作空间的选择每个动作空间都有一个待放角区.当动作空间选定后,物体待放的角区也就随之而定.我们总是选择待放角区最靠近箱子边缘的一个动作空间来放入物体.下面给出挑选动作空间的子算法,其中传入参数为当前格局下的动作空间列表.算法2.SELECT_ACTION_SPACE.输入:ListactionSpaces输出:candidateS1.Begin2.候选空间candidateS←NULL(初值为空);3.FORi=1toactionSpaces.size:4.对actionSpaces中的每一个动作空间Si:5.IFcandidateS=NULL,THEN6.candidateS←Si;7.ELSE依字典序比较candidateS与Si的以下参数:8.IFSi优于candidateS,THEN9.candidateS←Si;10.ENDIF11.ENDIF12.ENDFOR13.RETURNcandidateS;14.ENDSELECT_ACTION_SPACE.2.4捆绑块的生成对于给定的一个动作空间,可根据当前格局下箱子外剩余长方体的尺寸、数量和可行的放置方向,由程序自动捆绑生成各种不超出该动作空间的长方体块并放入到其待放角区.将一个捆绑块放入到动Page4作空间待放角区的动作称为一个占角动作.捆绑块的具体生成方法是:对于形状大小不同的每类长方体和该类长方体的每种可行的放置方向,按xyz、yxz、xzy、zxy、yzx和zyx这6种方式生成大的长方体块.其中xyz是指按当前的放置方向放入长方体,首先尽量填满x方向,再尽量填满y方向,然后z方向放一层得到一个长方体块、z方向放二层得到一个长方体块、…、最后z方向尽量填满得到一个长方体块;即根据此类长方体的数量,在x、y方向尽量填满,然后z方向填入一层至多层以得到不同的捆绑块.其他捆绑方案依此类推.图3捆绑块的生成2.5捆绑块的选择由于构成捆绑块的长方体类型、放置方向和捆绑方式的不同,在当前格局下可能有多个不同的放入动作.我们定义穴度来评价不同的放入动作的优劣,并从中选择一个穴度最大的放入动作来做.穴度越大,说明捆绑块与当前的动作空间吻合得越好.本文将整个捆绑块视为一个物体,给出了3种穴度的定义.定义2.贴面数ki.捆绑块有多少个面与动作空间相贴即重合的面积大于0.定义3.贴面率ri.捆绑块与动作空间相贴的定义4.它贴面数pi.其他已放入的块及箱子定义5.邻近度ad1面积与捆绑块的总表面积之比.的壁有多少个面与捆绑块相贴.间体积的比率以及组成块的小长方体的数目即捆绑数ni决定:ad1i=13n槡i其中Li、Wi、Hi为捆绑块的三边边长,LD、WD、HD为动作空间的三边边长.动作空间的体积利用率越大,ad1i为动作空间的平均填充率.ad1i越大;组成块的捆绑数越小,ad1定义6.邻近度ad2贴面的最小距离di和捆绑块三边边长的几何平均值决定:ad2图3所示分别为在当前动作空间中放入的3个捆绑块.设当前选定了箱子左半部的动作空间且其待放角为左后下角,又设形状大小相同的某类待放长方体有25个.若以竖立的方向放入到此动作空间中,按照xzy的捆绑方式,则可以在x方向捆绑4个、z方向捆绑2个形成一个长方体组件,然后将此组件在y方向分别捆绑1层、2层或3层得到3个不同的捆绑块.虽然在y方向可以放入4层,但由于此类长方体只有25个,而放入3层后已经使用了24个,所以无法在y方向放入4层以构成新的捆绑块.定义7.邻近度ad3i.由捆绑块与动作空间未贴面的最小距离di和捆绑块三边边长的算术平均值决定:ad3i=exp定义8.穴度Ck数、邻近度和贴面率决定.根据不同的邻近度定义,相应地有三种穴度的定义.穴度的比较即依字典序比较此穴度四元组的大小.穴度越大,说明放入块与动作空间相贴的面越多,贴住的其他放入块或箱子的壁越多,对动作空间占满的程度越大,被贴的面积比率越大,从而与动作空间的吻合程度越好.下面给出捆绑块的选择子算法.根据不同的穴度定义,分别有3个子算法SELECT_BLOCKk(k∈{1,2,3}).其中的传入参数为待放的动作空间和当前格局下箱子外剩余的不同类型长方体的尺寸和数量.算法3.SELECT_BLOCKk.输入:ActionSpaceS,ListitemSets输出:candidateB1.Begin2.捆绑块列表blockList←null;3.FORitemSets中的每种长方体类型和数量:4.FOR此类长方体的每种合法的放置方向:5.按xyz、yxz、xzy、zxy、yzx和zyx这6种捆绑Page56.ENDFOR7.ENDFOR8.去掉blockList中形状大小完全相同的捆绑块;9.选择的捆绑块candidateB←NULL;10.FORblockList中的每个捆绑块Bi:11.IFcandidateB=NULL,THEN12.candidateB←Bi;13.ELSE依字典序比较candidateB与Bi的以下参数:14.IFBi优于candidateB,THEN15.candidateB←Bi;16.ENDIF17.ENDIF18.ENDFOR19.RETURNcandidateB;20.ENDSELECT_BLOCKk.2.6基于动作空间的构造型穴度算法在当前格局下,每一步选择一个最靠近箱子边缘的动作空间(待放角区随之而定),再选择一个与当前空间吻合程度最好的捆绑块放入,然后更新动作空间列表,包括去掉已用的动作空间,加入新生成的动作空间以及更新与放入块有重叠的动作空间,从而得到一个新的格局.如此不断迭代,直至终止格局.根据3种穴度的定义,相应地有3种构造型算法CONSTRUCT_SOLUTIONk(k∈{1,2,3}),其传入参数为当前格局下的动作空间列表和箱子外剩余的不种类型长方体的尺寸和数量.算法4.CONSTRUCT_SOLUTIONk.输入:ListactionSpaces,ListitemSets输出:箱子的填充率1.当前动作空间S←NULL;2.WHILEactionSpaces不为NULL3.选择一个动作空间:4.为空间S选择一个捆绑块:5.IFcandidateB=NULL,THEN6.ELSE7.将candidateB放入S的待放角区;8.更新actionSpaces并计算更新空间的候选角;9.更新箱子外的剩余长方体集itemSets;10.ENDIF11.ENDWHILE12.计算并返回箱子的填充率;13.ENDCONSTRUCT_SOLUTIONk.2.7基于动作空间的树搜索算法在构造型算法的基础上,加入带回溯的树搜索方法,从而得到最终的确定性求解算法.下面首先给出动作的价值度定义.定义9.价值度Vk角动作,得到一个新的格局.从新格局开始,执行构造型算法CONSTRUCT_SOLUTIONk,算法终止时箱子的填充率称为该动作的价值度.本文分别用3种构造型算法进行回溯,从而得到3种穴度定义下箱子的填充率,然后从中选择填充率最高的一个布局作为最终的结果输出.算法5.TREE_SEARCH.输入:Containerc,ListitemSets输出:最终布局1.Begin2.初始化:生成唯一的一个动作空间S0并选定其候选角;3.空间列表actionSpaces←S0;4.FORk=1to3:5.actionSpacesk←复制actionSpaces;6.itemSetsk←复制itemSets;7.WHILEactionSpacesk不为NULL:8.选择一个动作空间:9.生成此空间可放入的各种捆绑块blockListk;10.计算这些捆绑块放入后的穴度Ck11.记当前格局为Fk;12.价值度Vbest←0;13.FORblockListk中的每一个捆绑块Bk:14.从格局Fk开始,将Bk放入Sk的候选角区,15.IFVk16.ENDFOR17.在格局Fk下将Vbest对应的块放入Sk的候选角区;18.更新actionSpacesk并计算更新空间的候选角区;19.更新箱子外的剩余长方体集itemSetsk;20.Fk←新格局;21.ENDWHILE22.resultk←按价值度Vk23.ENDFOR24.从3个最终布局中选择填充率最大的一个输出;25.ENDTREE_SEARCH.Page6树搜索算法的执行过程如图4所示.其中图4(a)所示为内层循环中在当前格局下用回溯的方式计算价值度Vk图4树搜索算法3实验计算我们将基于动作空间的改进型穴度算法ICDA用Java语言实现,在Intel(R)Xeon(R)CPU2.33GHz的计算机上进行了实验计算,并与国内外代表性求解算法的计算结果进行了比较.3.1测试算例实验采用的测试数据为Bischoff和Ratcliff于1995年提出的7组共700个弱异构型算例[1],依次称为BR1,BR2,…,BR7.这7组测试数据为国内外引用得最多的算例集.其中每个算例待放长方体的数目约为130个,不同尺寸的长方体类型从3种表1不同算法的计算精度比较算例集(类型数)H_BR(1995)83.3783.5783.5984.1683.8982.9282.1483.37H_B_al(1995)81.7681.7082.9882.6082.7681.5080.5181.97GA_GB(1997)86.7788.1288.8788.6888.7888.5388.3688.30TS_BG(1998)92.6392.7092.3191.6290.8690.0488.6391.26HGA_BG(2001)87.8189.4090.4890.6390.7390.7290.6590.06PGA_GB(2002)88.1089.5690.7791.0391.2391.2891.0490.43PTS_B_al(2003)93.5293.7793.5893.0592.3491.7290.5592.65PH_M_al(2004)93.70(3)94.30(3)94.54(2)94.27(3)93.83(3)93.34(3)92.50(2)93.78(3)MFBGRASP(2005)89.0790.4390.8690.4289.5789.7188.0589.73H_BCHGRASP(2009)93.2793.3893.3993.1692.8992.6291.8692.94HSAVNSICDA示为外层循环中用3种价值度分别计算得到不同的最终格局,并从中选择填充率最高的作为最终的计算结果输出.(BR1)到20种(BR7)不等,待放长方体的总体积接近于箱子的体积,其最优解未知.3.2计算结果对这700个著名的三维装箱算例,国内外许多的研究者进行了实验计算.作为比较,本文包括了其中代表性的算法H_BR[1]、H_B_al[2]、GA_GB[15]、TS_BG[10]、HGA_BG[3]、PGA_GB[4]、PTS_B_al[12]、PH_M_al[5]、MFB[6]、GRASP[7]、H_B[8]、CH[9]、GRASP[13]、HSA[11]和VNS[14].表1给出了这些算法与改进型穴度算法ICDA的计算结果.其中包括每组算例的平均填充率(%)以及全体算例的平均填充率(%).表中标出了每组平均填充率最高的前3个数据,且平均填充率最高的数据用粗体显示.Page7可见,在这16个算法中,平均填充率最高的前3个算法依次为Parreo等人于2010年最新发布的VNS算法、我们的ICDA算法和Mack等人于2004年提出的PH_M_al算法.其中ICDA算法对每组算例的平均填充率的排名依次为2、2、3、2、2、1和1,且在BR6和BR7这两组算例上的填充率要高于目前已见发表的最好结果.一般而言,随着算例异构性的增强,即长方体的类型越来越多,同类长方体的数量越来越少时,由于长方体对齐的难度增加而不可避免地产生各种空隙,因此算法求解的优度呈下降的趋势.对于ICDA算法,在待放长方体的类型较多同时每类长方体的数目也较多的情况下,可生成的不同捆绑块的种类较多,从而有可能找到与当前动作空间吻合程度高的块放入,因此在一定程度上缓解了算例异构性增强带来的不利影响.从表1中可看出,VNS算法在最好结果与最坏结果之间的差距为1.66,而ICDA算法的仅为0.96.这使得ICDA算法在BR6和BR7这两组算例上得到了好于VNS的结果.表2给出了其中的若干个算法实验计算时所用的机器配置和运行的时间.ICDA算法在全体算例上的平均计算时间为53.90s.可见,ICDA算法的计算精度较高,同时计算的时间很短,是一个高效率的确定性快速求解算法.算法PGA_GBPTS_B_al4×2.0PH_M_al4×2.0GRASPCHGRASPHSAVNSICDA4结论本文基于当前可能放入的最大虚拟长方体所对应的动作空间重新定义了穴度,并在放入位置的选择上直接体现“金角银边草肚皮”的思想,使新算法克服了原有穴度算法计算时间较长的弱点.对700个BR算例的计算结果表明,新算法的空间填充率很高,同时计算的速度很快.由于NP难度问题不存在多项式时间的确定性精确求解算法,除非P=NP.因此,本文提出的求解三维装箱这一NP难度问题的快速高效的确定性算法具有较高的理论与实际价值.
