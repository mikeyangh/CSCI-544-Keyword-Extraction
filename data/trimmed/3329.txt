Page1网络协议的自动化模糊测试漏洞挖掘方法李伟明张爱芳刘建财李之棠(华中科技大学计算机学院武汉430074)摘要随着网络应用越来越复杂和重要,对网络协议的安全性要求也越来越高.模糊测试(FuzzTesting)作为一种重要的测试手段,通过大量数据的注入来测试网络协议的安全,能够发现拒绝服务、缓冲区溢出和格式化字符串等多种重要漏洞.但是手工进行FuzzTesting需要精确了解网络协议细节并需要繁重的工作来构造大量测试数据集,导致覆盖率有限,效果也不好.为了解决这个问题,文中结合网络协议逆向工程和FuzzTesting技术,提出了一种能够自动化识别各种网络协议并产生模糊器进行FuzzTesting的漏洞挖掘方法.这种方法通过报文分类、多序列比对、特定域识别、模糊器生成多个阶段,自动识别网络协议报文结构并进行FuzzTesting.经过测试FTP、TNS、EM、ISQLPlus等多种已知和未知网络协议,结果表明这种方法在漏洞挖掘方面效果超过手工分析,并显著提升了测试效率,为提高网络协议的安全性提供了良好的基础,具有重要的应用价值.关键词协议逆向工程;模糊测试;漏洞挖掘1引言传输的敏感信息.但是如何测试网络协议安全性一直是个非常困难的问题.特别是测试未公开网络协议(closedprotocols)的安全性对于网络安全有着重要的意义,因为大量厂商并没有公开自己软件系统网络协议只有安全的设计和实现才能保护用户Page2使用的网络协议细节,例如MicroSoft的网络文件共享SMB协议、Oracle数据库访问的TNS协议、各种IPTV和及时通信软件使用的协议.这些未公开网络协议在网络中被大量使用,一旦其未公开漏洞被攻击者利用,将产生巨大的危害.因此,本文提出了一种自动化识别各种网络协议报文结构并进行模糊检测(FuzzTesting)的方法,能够找到协议中拒绝服务、缓冲区溢出和格式化字符串等多种重要漏洞,既可以避免手工测试带来的繁重工作和低效率,又能深入测试网络协议的安全性.本文第2节介绍网络逆向工程以及模糊检测漏洞挖掘方法的研究现状,并提出本文的总体思路和实现结构;第3节介绍数据报文分类方法;第4节详细介绍如何对未知网络协议进行识别,并对采用的多序列比对中的渐进比对和遗传算法进行比较,提出改进的渐进比对算法和优化的NeedlemanWunsch算法;第5节则进一步介绍如何自动化识别网络协议的特定域;第6节描述如何将识别出的网络协议转化为Fuzzer,构造针对目标协议的模糊测试器;第7节是实验测试,通过具体数据分析自动化漏洞挖掘方法的有效性;第8节对工作进行总结和展望.2介绍在网络协议逆向工程领域,国内外进行了较为深入的研究,主要分为两个大的方向:一个方向是单纯利用网络流量来推测网络协议,这类方法也称为基于“NetworkTrace”的方法;另外一个方向是对实现网络协议的服务器程序进行二进制的动态跟踪分析,通过跟踪二进制文件对报文的处理流程对报文进行解析,这种方法也称为基于“TaintedData”的方法.基于“NetworkTrace”的方法,典型的有2004年由MarshallBeddoe启动的“ProtocolInformaticsproject”分析未知或者未公开的网络协议的结构①.这个项目的目标是类比生物学从DNA中查找产生氨基酸的蛋白质的算法,通过对大量网络流量进行对比分析,最终分析协议结构.具体方法是首先读取目标协议的抓包文件形成序列集.然后通过局部序列比对算法计算这些序列之间的相对距离,形成距离矩阵.接着使用非加权成对群算术平均法(unweightedpairgroupmethodwitharithmeticmean),构造一棵向导树,实现序列的聚类,每一类中的序列被认为是具有很大相似性.最后,针对每一个聚类,利用渐进比对算法遍历系统树,完成多序列比对.根据比对结果,就可以区分固定不变的区域和动态改变的区域.但是这种方法仅仅提取了协议中的可变和不可变域,划分粒度很粗,同时分析结论也对流量的依赖性很强.另外,其聚类方法以LCS(LongestCommonSubsequence)匹配数量作为参考标准,因此无法区分和提取序列中相对简短的协议域.总之PI项目只是处于初步阶段,算法还很不成熟.2005年CorradoLeita、KenMermoud和MarcDacier提出使用PI项目改造Honeyd,实现Honeyd配置脚本的自动提取[1].文章的主要设计思路由4个步骤组成:首先从网络抓包文件中获取数据包的Message序列,然后分析这些序列,为每个请求维护一个状态机,记录客户端和服务器之间的信息交互过程.然而,此时的状态机没有进行任何的语义分析,不能完成实际的交互动作,因此需要优化状态机,最后完成脚本的自动生成.同样Cui和Paxson等人提出了一种网络协议识别和自动恢复的解决方案RolePlayer[2].其设计思路是,在获取用户输入参数的条件下,通过分析少量样例数据流,采用算法定位终端信息(IP、hostname)、用户参数、长度域、Cookie、任意域,然后根据这些信息生成交互脚本.此后,该系统根据这些脚本信息识别任意一段新的流量是否符合已经学习的协议,并且可以通过关键域替换,实现自动交互的效果.在另外一篇论文中[3],他们结合HoneyFarm和上面提到的Role-Player技术,实现了一种全新的恶意代码捕获框架GQ:所有进入的流量,首先进行匹配,如果发现是已知协议,则直接由RolePlayer响应,一旦发现未知协议,则将这些流量重定向到高交互蜜罐中并扮演代理服务器的角色,以便捕获到最新的恶意代码和恶意攻击.连续4个月的测试中,GQ捕获了66种不同的蠕虫,这充分说明,RolePlayer在GQ中确实发挥了重要而且有效的作用.但是这种方法没有分析协议结构,可变性不高,流量稍微有点变化就导致无法正常响应.在随后的研究中,他们引入了Discover系统[4],试图从大量的网络报文中识别出同类型报文,然后分析报文格式,这种方法显然比RolePlayer更加实用,但是文章缺乏对于Discover所采用方法的精确定义.①Networkprotocolanalysisusingbioinformaticsalgorithms.Page3基于“TaintedData”的协议识别方法是建立在动态污点分析技术基础之上的.动态污点分析技术是近几年兴起的一种解决方案,它可以在二进制代码层实现对不可信数据的传播情况的跟踪和分析,Argos[5]和TaintCheck[6]就是两个典型的实例.基于“TaintedData”的协议识别方法将所有网络传输数据作为不可信数据源,通过监控服务器处理这些不可信数据的流程,获取协议结构信息,因此其准确性要好于第一种方法.例如服务器程序在污点数据中搜索非污点数据“Username”,那么就可以肯定污点数据中的“Username”是报文结构中的一个关键字.Wondracek详细描述了这种方法的机制[7]:利用网络报文作为输入的TaintedData,在指令级对其进行监控,然后根据监控信息分析对应报文的语义特征.最后根据多次监控的分析结果,将所有相同格式报文的语义信息融合,提取出一个通用的报文结构.Caballero等人提出的Polyglot系统也是基于类似的思想实现的[8].Comparetti设计的Prospex[9]在引用以上方法识别单个报文结构的同时,也利用污点数据跟踪过程中获取的统计特征(包括系统调用特征、文件系统操作特征等)对报文进行聚类.此外,文中还引入状态机识别机制并简化,最终将客户机和服务器的交互过程以DFA的方式显示出来,达到解析交互流程和报文结构的目的.然而这种基于“TaintedData”的方法也存在一些限制:它需要得到服务器程序并让其在指定环境中运行;其次,跟踪复杂程序运行也会产生大量数据需要分析并且降低服务器性能.关于FuzzTesting的研究也很活跃.FuzzTesting是一种通过外部输入数据影响内部程序执行的测试技术.它的基本原理是将尽可能多的可能导致程序出现问题的错误数据注入应用程序中,观察运行结果,通过观察和分析程序运行的错误来挖掘软件的脆弱点.FuzzTesting看似简单并且需要大量数据和注入点,但它却能揭示出程序中的重要漏洞,而且通过FuzzTesting挖掘到的漏洞通常都比较严重.Miller[10]用FuzzTesting测试了大量的Unix程序,结果发现超过40%的命令行程序可以出现内存出错和死循环,同样超过40%的X-Windows程序也会出错,显示了FuzzTesting的有效性.在此基础上Forrester[11]采用类似的方法对WindowsGUI程序进行FuzzTesting,测试数据注入点是键盘鼠标输入和消息,同样使21%的程序内存出错和24%的程序陷入死循环,说明了FuzzTesting对不同平台程序都是有效的.现在FuzzTesting已经发展成为一种模块化的测试方法,典型的软件是SPIKE[12].SPIKE是Immunitysec公司的DaveAitel写的一个黑盒安全测试工具,主要可以测试应用程序输入和网络协议报文.微软的GodefroidPatrice在FuzzTesting方法中引入了白盒测试的方法,使得Fuzz更加精确,覆盖率也更高[13].国内研究者张玉清教授分别对MP3播放器、TFTP客户端进行了FuzzTesting[14-15].FuzzTesting的主要问题在于它是一种盲注入的方式,手工进行FuzzTesting工作量过大,甚至几乎无法进行比较全面的测试,导致FuzzTesing的实用价值受到很大影响.本文提出的方法建立在这两个领域的研究基础上,提出一个适用于FuzzTesting的网络协议自动识别的方法.由于FuzzTesting需要输入大量数据,为了避免在服务器端产生过量的二进制执行信息,本方法基于“NetworkTrace”,但是也引入了简单的服务器监控机制.重点在通过分析网络协议的报文,自动化精细识别网络报文中各个域,并推断其数据类型.然后根据域的划分,自动产生SPIKE所需的FuzzTesting脚本,对每个域进行注入测试.测试过程中仅仅对服务器端运行结果进行监控,一旦发现服务器端出现拒绝服务或者溢出错误则记录相应的输入和输出.通过这种方式来发现网络协议设计和实现中的漏洞.经过对典型的公开和未公开网络协议的测试,证明这种方法是非常有效的,其主要的系统结构如图1所示.图1描述了本方法的核心流程.本方法主要部分都采用自动化的方法,但是需要一个手工截获报文的阶段,即使用Tcpdump或者WireShark等工具,截获网络协议的报文.这个阶段需要用户对网络服务多次使用(一般3~4次),然后将每次截获的报文保存到一个PCAP文件中,以多个PCAP文件作为自动化阶段的输入.这个阶段不需要进行协议识别或者测试工作,因此易于操作和实现.在自动化部分主要分为两个阶段:协议识别和FuzzTesting.在协议识别阶段,首先采用类型匹配,将不同的PCAP文件中同类型的报文序列提取出来,作为一个报文组.然后对这个报文组进行多序列比对,将不变域和可变域分离出来,得到一个初步的报文域划分.报文域识别模块再进行进一步的ANSII字符串域、Unicode字符串域、二进制域、长度域的识别,得到一个较为准确的报文格式.报文格式得到后,可以根Page4图1系统结构图据此格式生成SPIKE脚本,由SPIKE根据脚本构造实际的报文对服务器进行测试.而服务器主要安装FaultMon等监控软件,一方面监控内存使用情况,监控内存异常和系统服务状态;另外一个方面是记录被测试服务程序的异常和日志.通过这两个部分的信息,可以反推漏洞可能的类型和存在的位置.在这样的系统结构下,可以实现自动化地对网络服务器进行FuzzTesting,测试网络协议在设计和实现上的安全性.3报文聚类为了能够识别未知网络协议,首先需要人工对网络协议进行多次访问,每次访问为一个Session,每一个Session的报文都截获保存到一个PCAP文件中.为了提取同类型报文,需要对多个PCAP文件中的报文进行聚类,将相同类型的报文序列组成一个报文组,属于同一个报文组的报文被认为是网络协议中相同格式的报文,它们将被作为多序列比对算法的基本输入.具体方法为,提取PCAP文件中的非空负载报文,每个报文以各自原始序号标记,具有相同序号的报文作为一组.此时的报文组,并不能保证它们是相同类型的,因为考虑到网络传输中可能出现丢包、乱序等情况,甚至相同类型的数据包的内容也极有可能有很大差异.因此需要对每个报文组进行进一步分析.对每个报文序列的每个字节识别相应的类型,如果是可打印字符用‘A’表示,非可打印字符用‘B’表示,此时这个报文序列对应的类型就形成一个由若干‘A’、‘B’组成的字符串.考虑到字符串长度是可变的,我们将连续的‘A’合并成一个‘A’,如此形成一个新的序列,我们称这个序列为类型序列(TypeSquence).对类型序列进行聚类的算法如下.defclusterSequences(typeSquences)typeCompare=FalseforseqintypeSquencesdodoneiftypeComparedoelsedoneforseqintypeSquencesdodone算法判断如果是纯文本的协议通过查找报文之间的最频繁最长共同串(longestcommonstring),找到具有共同类型序列的报文.而具有不可打印字符的报文,说明不是纯文本协议,通过找到最频繁的类型序列,发现具有共同类型的报文,移除不符合要求的报文.4多序列比对已有的多序列比对算法大体分3类:精确比对Page5算法、渐进比对算法和迭代比对算法[16].精确比对算法最为经典的是多维NeedlmanWunsch算法,但其可行的计算维数为3,CarrilloLipman算法通过减小计算空间,将计算维数提高到10.渐进比对算法由Hogeweg首先提出,Feng和Taylor又加以完善,被广泛使用的多序列比对软件包CLUSTALW就是基于渐进比对思想构建.近年来,迭代比对算法被越来越多地用于求解多序列比对问题,基于模拟退火、遗传算法、HiddenMarkovModel、Gibbs抽样等的多序列比对算法被广泛应用于多序列比对问题的求解.由于网络报文的多序列比对具有序列很长、报文数量多的特点,精确匹配需要大量的计算时间和内存空间,因此我们放弃了精确比对,主要考虑了基于序列长度的渐进比对算法和基于遗传算法的迭代比对算法.通过比较这两种算法,我们发现简单的基于序列长度的渐进比对算法在效果和效率上大大优于后者,所以最终选择渐进比对算法作为协议分析的多序列比对算法.在本节,分别介绍我们对这两种算法的改进,以及对两种序列比对算法的效果和性能测试.4.1基于遗传算法的迭代比对算法本文利用基于遗传算法的多序列比对算法对多个数据包进行比对,得到反映这些报文共性和差异的比对结果.具体的遗传算法设计如下.目标函数.在序列比对结果中,每个序列插入的空位(Gap)数量越少越好,因此目标函数加大了对Gap的惩罚力度,设多个序列为seqs={s1,s2,…,sn},经过遗传算法填充序列长度相等都为len,则SP(seqs)=∑lenSPCol(c1,c2,…,clen)=∑i=lenCmp(c1,c2)=式(1)即为Sum-of-Pairs目标函数的评分规则(简称SP),注意如果遇到全部为Gap的列,直接删除,不计算分数.可以看出,对于空位Gap的限制比其它字符要大,因此,最终比对结果中出现的Gap数量也相应减少.遗传算子.这里实现了9种遗传算子,假设每个个体包含N个序列,下面分别简要介绍[17].(1)CrossOver.随机选择两个个体p1和p2,然后将p1的前i个序列和p2的后(N-i)个序列进行组合,形成新的个体.(2)Mutate.随机选择一个个体及这个个体中的一个序列,删除这个序列中所有的空格,然后随机插入相同数量的空格,形成新的个体.(3)LocalShuffle.随机选择一个个体及这个个体中的一个序列,将这个序列中的一个Gap和相邻字符交换.(4)BlockShuffle.随机选择一个个体及这个个体中的一个序列,将这个序列中的一个Gap和相邻字符串交换.(5)InsertGap.随机选择一个个体及这个个体中的一个序列,随机删除这个序列中的一个Gap并随机插入一个Gap.(6)DeleteGap.随机选择一个个体及这个个体中的一个序列,随机删除这个序列中的一个Gap,并在序列末尾添加一个Gap.(7)Union.随机选择一个个体及这个个体中的一个序列,将这个序列中两个相邻的字符串合并,即删除一个连续的Gap串,然后在相邻字符串的左边或右边插入相同数量的Gap.(8)Division.随机选择一个个体及这个个体中的一个序列,将这个序列的一个字符串拆分,即随机删除一个Gap,然后随机插入一个Gap到这个字符串中.(9)CleanUpGapColumn.检查是否存在全为Gap的列,如果存在的话,将此列删除并在每个序列的末尾添加一个全为Gap的列.动态退出流程.在遗传算法的实现中,所有序列的长度都是固定的(默认设置为最大长度的1.2倍).在编程实现中,采用轮盘赌算法随机选择SP值比较大的个体进入下一代种群的演变.我们知道,轮盘赌算法中,对应的特征值不能为负值.但是根据以上算法计算的目标函数很有可能是一个小于0的整数.为了避免出现负值的现象,在进行轮盘赌选择的时候,需要将所有值转换为正值,然后进行选择.目前实现了9中遗传算子.但是这些遗传算子的一个特点在于,它们随机性较强,增加了种群的多样性,不过这也是它们的一个缺点,即如果进入一个Page6很差的解空间,有可能一直在这个空间内迭代,无法再优化.为了得到更优的结果,本文从每次产生的最优个体中提取免疫因子,通过免疫因子,产生新个体.实验测试表明,免疫算子可以在很大程度上优化比对的结果.在程序中增加实现了两种免疫算子:单一免疫因子和多免疫因子.单一免疫因子每次提取最优个体中最长的连续的相同的列作为免疫因子,产生新个体,而多免疫因子则提取最优个体中多个连续的相同的列为免疫因子,产生新个体.遗传算法测试.为了测试遗传算法在多个报文序列对比中的效果,本文设计了6组测试数据,每组数据包含4个相似的网络报文,对每组数据进行基于遗传算法的多序列比对,共测10次,取平均结果.表1为测试数据描述,表2左侧是不引入免疫因子的测试结果,右侧为引入免疫因子后的实验结果.报文组平均报文长度1200字节左右每行大约0~10个字节发生不同2200字节左右每行大约10~20个字节发生变化3200字节左右每行大约0~10个字节发生变化,4200字节左右每行大约10~20个字节发生变化,5200字节左右每行大约0~10个字节发生变化,6200字节左右每行大约10~20个字节发生变化,普通遗传算法测试结果平均SP值报文组1793.346639.6446.511206.248839.4727.7250048020.8448.82962.745829.7666.33353.352084.6494.23816.751674.6770.24-64.737862.4381.84695.352858.6775.25570.952065.8508.451096.857300.78296212.638786.7389.86906.570889.5985.9总体而言,遗传算法实现多序列比对还是存在一些不足.首先,遗传算法本身存在很大的随机性.即便是相同的序列,多次比对的结果也并不一定相同,最佳分析结果得到的SP值也较低.而在协议自动分析中,对序列比对结果要求极为苛刻,任何错误的比对,都将直接影响后续分析工作.此外,遗传算法消耗的时间相对比较长,当序列数量或者序列长度达到一定阈值之后,运行时间甚至无法忍受.因此遗传算法不适合用于协议自动分析的多序列比对中.4.2基于序列长度的渐进比对算法渐进比对算法建立在二维NeedlemanWunsch算法基础上,基于相似序列通常具有进化相关性这一假设,它的思想是通过迭代地利用双序列动态规划比对算法,先由两条序列的比对开始,逐渐添加新序列,直到所有序列都加入为止.但是不同的添加顺序会产生不同的比对结果.因此确定适合的比对顺序是渐进比对算法的一个关键问题.渐进比对算法主要由3个步骤组成:(1)计算距离矩阵;(2)构建向导树;(3)依据向导树进行渐进比对.针对报文序列比对的特点,我们实现了一种优化的NeedlemanWunsch算法.优化的NeedlemanWunsch算法.NeedlemanWunsch算法属于动态规划算法,算法结束时通过回溯得到一个全局的比对结果,根据该比对的结果计算出的序列相似度值最大.算法有两个步骤:(1)根据状态转换函数计算两个序列的相似分值,得到一个相似度矩阵.(2)根据相似度矩阵,按照动态规划的方法回溯寻找最优的比对.核心的状态转换函数定义如下:其中,Mij表示当前状态得分,Sij是字母匹配得分(如果不匹配就是罚分),w是加入空位的惩罚.因为空位不属于原始报文,为了保持报文长度和增加匹配的可信度,应该尽量少加入空位,所以我们设置字母匹配Sij得分为2,不匹配Sij罚分为-1,w=-2.这样的设置在大部分情况下有效,但是经典的NeedlemanWunsch算法的每个状态仅仅基于上一个状态得到,没有考虑对于连续匹配进行奖励,因此可能出现为了避免增加空位导致不能对齐的现象.图2上侧截取了两个互相比对的报文中的部分序列,采用经典的NeedlemanWunsch算法匹配后,发现这两个序列没有正确地对齐字符串Referer:ht-tp://192.168.1.1/,这是因为为了避免过多的插入空位,算法宁可选择字符串不匹配.那么最终得到的FuzzTesting报文模板不会把这个部分作为不可变域,影响分析效果.因此我们修改了NeedlemanWun-sch算法的状态转换函数,增加对于连续匹配的奖励.Mij=max其中,n是连续匹配的字母数目,b为连续匹配奖励,Page7设定为2,这样鼓励算法将连续的字母比对在一起,即使插入更多的空位也不会产生比对的碎片,达到如图2下侧的效果,虽然插入了更多的空位,但是实际上更加符合网络报文匹配的要求,得到的结果更便于发现报文中的变化域.即Referer:http://192.168.1.1/在两个报文中正确地匹配在一起,而客户端识别的图2优化算法前后效果对比(用下划线代替空位)渐进比对算法流程.由于通过了报文聚类,我们认为剩下的报文应该是相似的,而且长度决定了报文变化的大小.因此我们提出了基于报文长度的渐进比对算法.算法的核心就是构建一棵二叉树,通过比较报文的长度,将长度最为接近的报文两两编组,defConstructTree(seqs)forseqinseqsdonode=newTreeNode(seq)nodeList.append(node)donewhile(len(nodeList)>1)node1,node2=newNode=newTreeNode()newNode.seq,node1.gapList,node2.gapList=newNode.left=node1newNode.right=node2nodeList.append(newNode)donereturnnodeList[0]算法的核心是每次查找最短的两个序列作为二叉树的叶子节点,然后进行Needleman-Wunsch算法比对,返回的三个值,第一个是插入Gap较少的比对结果,后两个是两个比对结果相对原始序列需要插入的Gap位置列表,这样递归下去,直到根节点.另外一个算法是构建多序列比对结果:defSequenceResult(treeNode,resultSeqs)iftreeNode.gapList!=nulldoGapListStack.push(treeNode.gapList)SequenceResult(treeNode.left)SequenceResult(treeNode.right)文件类型和服务器端的页面路径被标识出来,这两个区域可以分开进行FuzzTesting,增加了检测的粒度,容易触发更多漏洞,而且这样的报文更加容易通过服务器的格式检查.当然增加了连续奖励会增加算法的复杂度,因为必须更新状态,记住连续匹配是否产生以及匹配的字符个数.GapListStack.pop()doneiftreeNode.left=nullandtreeNode.right=nulldonewSeq=resultSeqs.append(newSeq)doneSequenceResult是从根节点开始,递归调用,将所有的gapList都应用到叶子节点,最终形成结果序列保存在resultSeqs中.测试结果.为了测试渐进比对算法的效果,我们采用了和遗传算法同样的测试集合,进行了同样的测试.表3显示了对第6个报文组的测试结果.算法平均时间/s最佳SP值平均SP值免疫遗传算法>601187906.5渐进比对算法1.98517821782.0表3中数据显示,同样的程序多次分析同样的序列,渐进比对算法比对结果明显优于遗传算法结果.协议自动分析需要数据包序列中每个字节严格同序列中相同含义的字节对齐,否则分析无法成功进行.另外遗传算法还存在很大的随机性,每次执行的结果可能不一致,这意味着如果采用遗传算法进行序列分析的话,最终的协议结构也可能是不一致的.这在协议自动分析中是无法接受的.此外,遗传算法所消耗的时间也明显比渐进算法长.测试文件6中序列在200字节左右,最长运行时间已经达到4分1秒.随着序列长度的增加,比对时间也急剧增加.综上所述,我们得出结论:在协议自动分析中不适合使用遗传算法实现多序列比对.因此在研究中Page8采用渐进比对算法作为协议自动分析中的多序列比对算法.5协议自动识别技术为了方便描述,我们将数据包结构中的各个有意义的组成部分称为“域”(Field).通过多序列比对,可以将多个报文进行对齐,然后根据每一列字节的变化,识别出不变域和可变域,其中不变域中每个字节对应的变化率都为0.从类型上看,域又可以分为二进制域和字符串域,其中字符串域对应可打印文本串.此外,还需要识别出两种特殊的域:长度域和Unicode编码域.长度域记录数据包中若干连续域的长度,而Unicode编码域指的是由Unicode编码的文本域.由于我们的识别目标是应用层协议,而在下层协议中已经提供了校验和,因此就没有考虑在应用层出现校验和域的情况.总体而言,我们希望通过协议自动分析,能够准确地识别出协议报文中的不变二进制域、可变二进制域、不变字符串域、可变字符串域、不变Unicode编码域、可变Unicode编码域和长度域.识别各种域之后,域的集合就构成了数据包的模型,称为PacketModel,而若干数据包模型和交互控制信息构成了目标ProtocolModel.为了得到ProtocolModel,需要完成以下步骤:根据多序列比对结果划分域;进行类型纠错;按照类型划分标准数据包;识别Unicode编码;识别长度域;类型细粒度划分;格式化序列;输出PacketModel.另外还要强调一点,为了方便使用PacketModel产生模糊器,本文要求在参与比对的数据包中,必须有一个是进行漏洞测试的主机之间的流量抓包文件.而这个数据包对应的序列称为默认序列,它是PacketModel对应的一个模板.5.1根据多序列比对结果划分域在进行多序列比对时,为了能够使序列最大程度对齐,在必要的情况下需要插入空位,即前面提到的Gap.在比对完成之后,每个序列具有相同的长度.统计每个序列中相同偏移的字节,计算对应的变化率.如果相同偏移的所有字节数值都相等,则变化率为0;如果不相等,计算不同数值的数量,它和序列个数的比值作为变化率.根据变化率识别出不同的域,相同变化率的字节构成一个域,其中包括不变域和可变域.接着识别每个域的类型.对于每个域,除去Gap以外,如果找到一个不可打印字符,则表示这个域是二进制域,否则该域为可打印字符域.5.2Unicode编码识别这里的Unicode编码,指的是在每个字符添加一个“00”作为前缀或后缀,例如字符‘A’的Unicode编码为“4100”.很显然,Unicode字符串的一个很明显的特征在于每个可打印字符之间以“00”间隔,这也是我们识别Unicode编码的标准.遍历每个序列,查找连续间隔出现“00”、而每两个“00”之间是可打印字符的字节范围.根据“00”相对可打印字符的位置确定Unicode编码类型.然后将这个字节范围的字节合并成一个整体,作为一个Unicode域.整个识别过程中,忽略Gap信息.如果进行扩展可以识别报文中的汉字,例如IIS的FTP服务器采用UTF-8传输汉字.5.3类型纠错前面的处理中可以根据字节的数值,确定一个域类型为二进制域或字符串域,但是这种方法在某些情况下是不正确的.例如,对于数值0x40,它既可以解释成‘@’字符,但是也可以表示一个二进制数值.在这种情况下,很难直接通过数值来判断数值的类型.考虑到每个字节和前后字节序列之间存在一定的联系,因此可以根据字节所处环境来判断.这里假定所有的可打印字符域有一个最小长度值,所有长度小于这个阈值的字符串域,都被认为是二进制域.理论上讲,这种策略并不是很精确,因为我们无法保证所有的字符串域的长度都大于或等于这个阈值,但是却可以在大多数情况下能够正确识别出域类型.在实现中,我们将这个阈值作为一个参数供用户配置,默认值为4.5.4长度域识别在多序列比对时,已经向序列中插入Gap,这些Gap在计算长度域时不应该存在.为了保留细粒度划分片段所需要的信息,此时保存默认序列的Gap信息及各字节的变化率信息,然后删除所有的Gap.长度域用来描述数据包某一部分的长度,实际上也就是表示若干连续的序列片段长度之和.在实际网络中,如果一个数据包中的长度域出现错误,那么极有可能是传输错误而要求重传,因此长度域的确定是协议结构自动分析的一个很重要的部分.长度域的识别过程相当复杂,而且最终的分析结果可能遗漏,甚至不能保证分析结果一定是正确的.长度域的识别策略基于以下几个假设:(1)首先,不考虑一个报文分为多个数据包到达的情况,此外数据包乱序到达也应该排除.(2)其次,长度域用于记录若干连续序列片段的长度之和.而长度域都是1~2个字节长度的二Page9进制数值,而且高位在前.暂时不考虑以明文方式表示的长度域,例如EM协议中请求报文中存在“Content-Length:95”的长度域.(3)长度域不可能出现在它所标记的序列片段范围之后.实际上,SPIKE框架也不支持这种情况.长度域的识别思路如下:对每个参与比对的序列,在已经识别的域的基础上,穷举所有可能的位置连续的域,并计算其长度,位置连续的域称为连续域集合.然后在整个序列的二进制域中搜索长度信息,一旦发现二进制域中存在匹配的连续域长度,就记录下来,这个信息成为长度向量(采用相对位移表示).每个序列都会产生一个长度向量集,对所有的长度向量集求交集,在解决长度向量交集的冲突之后,剩下的长度向量就代表最终的长度域.下面为详细识别过程.在进行长度域定位之前,已经完成域的类型识别、类型纠错、Unicode编码识别,这几个阶段的准确率直接关系到长度域定位的准确度.为了最大限度查找到长度域,需要穷举所有可能的连续的序列片段组合,计算每种组合的长度值.假设每个序列的域数量为n,那么总共可能出现的组合数量为1+2+…+n=n(n+1)/2.当在二进制域中搜索到匹配的值时,就表示这个值可能记录了对应的域的长度.但是不能排除这是一种巧合,需要将所有匹配的信息以(起始域序号、终止域序号、长度域所在二进制域序号、长度域所在二进制域内偏移,长度域长度)的形式记录下来,形成一系列的长度向量,一个序列的所有长度向量组成一个长度向量集.一个长度向量集表示了在对应序列中可能出现长度域的组合.对所有的序列的长度向量集求交集.由于长度向量采用的是相对偏移,和具体序列无关,因此交集中的每个长度向量意味着它所标记的长度域在所有的序列中都是符合的.在实际测试中,我们发现长度域交集中可能存在冲突的现象.主要表现为(1)一个长度域标记多个连续域集合;(2)一个连续域集合可能被多个长度域标记;(3)长度域本身重叠.例如,“00ff”可以作为长度域标记一个连续域集合,但是“ff”本身也可能作为长度域标记另一个连续域集合.遇到第1种冲突情况,总是优先选择距离长度域近的连续域集合作为长度范围.第2种冲突在实际数据包中出现过,因此被认为是一种正常情况,无须解决冲突.第3种冲突中优先选择2个字节长度域,而删除一个字节的长度域信息.当所有冲突解决之后,此时的长度向量集合的每一个向量,都标志着一个识别出来的长度域.前面已经提过默认序列的概念.默认序列是需要进行漏洞挖掘的主机之间的数据包序列.从序列组中提取出默认序列,然后利用长度向量集,划分默认序列的二进制域,将长度域独立出来,并记录对应的片段组合信息.此时默认序列是我们进一步分析的对象,其它序列信息已经可以删除.5.5格式化输出在报文序列的可打印字符串序列中,还可能出现一些特殊字符,例如“(”、“)”、“:”、“,”、“=”等,这些字符作为分隔符而存在.例如在报文中常出现“userName=sys”的情况,得到的是不变域“user-Name=”、可变域“sys”.相对来说,我们更希望得到的结果是不变域“userName”、不变域“=”、可变域“sys”.因此这一步操作就是将分隔符从默认序列中独立出来,从而更细粒度划分字符串域.在格式化默认序列之后,就完成了协议自动识别过程.默认序列分析结构将以HTML的方式输出,称为PacketModel.而进行模糊测试器也是在PacketModel的基础上完成的.表4为Oracle数据库的非公开协议TNS经过自动分析后,在默认序列上形成的PacketModel.序号域属性0LengthField(2):0~42x00xff1Binary-constant2LengthField(2):5~42x00xc53LengthField(2):0~4x00x3a4Binary-constant5String-constant(6String-constantDESCRIPTION7String-constant=(8String-constantCONNECT_DATA9String-constant=(10String-constantSERVICE_NAME11String-constant=12-0String-variableorcl13String-constant)(14String-constantCID15String-constant=(16String-constantPROGRAM17String-constant=18-0String-variableF18-1String-variable:18-2String-variable\oracle\19String-constant10.2.0\db_1\bin\Page10序号域层性20String-constant)(21String-constantHOST22String-constant=23-0String-variable3226663CCD3D49224String-constant)(25String-constantUSER26String-constant=27-0String-variableAdministrator28String-constant)))(29String-constantADDRESS30String-constant=(31String-constantPROTOCOL32String-constant=33String-constantTCP34String-constant)(35String-constantHOST36String-constant=37-0String-variable192.168.1.7838String-constant)(39String-constantPORT40String-constant=41String-constant152142String-constant)))图3根据PacketModel自动生成的TNS协议第4个报文的SPK脚本6构造模糊器本文在SPIKE框架的基础上,自动生成模糊测试器Fuzzer.SPIKE是一个对网络协议进行FuzzTesting的通用框架,也是使用最为广泛并且被人所熟知的模糊测试框架之一.SPIKE使用数据块的网络协议分析测试方法,通过这种方法,可以自动完成数据块长度的计算和填充,提高了测试成功率,同时也使开发过程相对简单.Fuzzer,实际上是进行Fuzzing测试的程序.在SPIKE框架下,它由两部分组成:主控程序和数据包构造程序.主控程序负责和目标服务程序进行交互操作,例如发送、接收数据包等.数据包构造程序可以通过SPK脚本的形式实现.SPK脚本存放着构造相应数据包的语句,主控程序根据SPK脚本构造具体的数据报文.本文分析目标网络协议,得到了两方面的信息:Page11其一,默认序列,它反映了数据包的交互过程,可以通过读取默认序列了解网络协议的类型、IP地址、端口、主机名、报文交互过程等特征.另外一个是PacketModel,它记录了数据报文应该如何构造以及报文中哪些部分是可以变化的.因此可以从默认序列自动化产生主控程序,而从PacketModel自动化产生SPK脚本.这样来产生SPIKE框架所需要的所有信息.根据TNS协议第4个报文的PacketModel产生的SPK脚本如图3所示.7实验测试为了测试系统的运行效果,我们选择了多种协议进行了深入测试.通过对不同协议的测试,检验本方法对不同报文格式和数据类型的适应性.为了分析比较,目标协议首先经过人工分析,设计出数据包构造脚本和交互控制信息,利用SPIKE挖掘相关协议漏洞.然后在没有任何人工干预的情况下,利用协议自动分析技术,自动生成SPIKE模糊器,再次挖掘协议漏洞.通过比较两次漏洞挖掘情况,来验证自动化方法的有效性.7.1FTP协议测试FTP协议是一个公开的协议,它的应用也非常广泛.在FTP服务器软件ServU4.0上存在两个远程缓冲区溢出漏洞.其中一个是列目录LIST命令:LIST-l:ParamString.如果ParamString是一个超长的字符串,那么就会导致缓冲区溢出.另一个存在溢出漏洞的是MDTM命令,格式为MDTMtime+timezoneremote-filename,当“+”后面timezone的参数是超长字符串时,也会导致溢出.通过对FTP协议进行自动化分析,能够正确地建立LIST和MDTM两个命令的报文格式,例如MDTM命令经过分析产生PacketModel,并生成SPIKE构造脚本如图4所示.图5自动识别和手工识别的可变域经过实际测试发现,当“20151207233859”或“ZZZ”被超长字符串替换的时候,都将导致服务器进程直接发生溢出异常而停止服务,即无论溢出“+”前面的时间还是“+”后面的时区都存在溢出漏洞.而LIST超长参数溢出漏洞也能够被正确地检测到.因此自动化FuzzTesting漏洞挖掘方法对于FTP协议取得了很好的测试效果.7.2TNS协议测试分析TNS协议是Oracle数据库管理系统服务端和客户端通信的协议,暂时没有官方文档进行详细介绍,属于一种未公开协议.TNS协议传输可以使用多种方式传输,包括TCP/IP协议、SSL的TCP/IP协议、命名管道和IPC等,其中TCP/IP协议传输部分使用明文传送.根据观察,TNS有10多种不同的报文格式,属于比较复杂的协议,而且不同的Oracle版本的TNS协议也有一定的差异,说明该协议仍然处于不断开发和改进中,同时也容易存在未公开漏洞,因此本文选择Oracle10g2版本进行分析测试,既可以检验自动化FuzzTesting漏洞挖掘方法对未公开网络协议的测试效果,又具有一定的应用价值.TNS协议在完成三次握手之后,从第4个数据包开始和服务器交互,在第18个数据包以明文的方式发送用户名到服务器,而在第20个数据包以密文的方式发送密码.由于加密报文无法有效地进行FuzzTesting,本文主要对TNS的前20个数据包进行了分析(图3为第4个数据包的PacketModel),采样的报文一共是7组.首先手工分析该协议,构造SPIKE测试脚本进行测试.另外,利用自动化FuzzTesting漏洞挖掘方法,同样产生了相应的脚本信息,进行自动化测试.对两次的分析结果如图5所示.Page12图5中左侧为自动化识别出来的各种可变域,右侧为手工识别出来的各种可变域.可以看出自动化识别的可变域数量远远小于手工识别数量,主要是因为自动化识别的报文变化不够大,局限在一定的范围,导致很多可变域不能识别.人工分析时,可以根据分析者的经验,识别可以测试的域.对这些可变域分别进行测试,结果如表5所示.报文序号4000000600000080000001029112021215610113011000160110001801100020112000总和41822303表5中手工分析发现的漏洞而言,长度域导致的漏洞为4个,其它的异常均由于二进制域引发,而字符串则没有测试出任何异常情况,总的发现漏洞个数远大于自动化分析发现的3个漏洞.由于自动化分析的可变域和不可变域是根据采样的报文得到的,因此很可能很多不可变域其实是可变的,因此可以进一步地采样,当采样的报文组达到15组的时候,可以看到自动化识别的可变域增加非常显著,如图6所示.根据图6,在自动化识别的大量可变域中进行FuzzTesting,可以得到如表6所示的漏洞挖掘结果.数据包手工分析40000000060000000080000000010290112911212150616071301010101160101010118010101012011020101总和418022319123实验数据表明,协议自动分析发现的漏洞为23个,已经超过手工分析发现的22个漏洞.就漏洞数量而言,二者性能基本类似,只有少量数据包中存在差别.这充分说明,利用协议自动分析技术来替换手工分析完成数据包的分析和Fuzzer的构造是可行的.通过分析两种方法发现漏洞的差异,可以进一步地了解各自的优势.首先,在对第10号数据包进行分析的时候,协议自动识别发现了一个字符串产生的漏洞,而手工分析遗漏该漏洞.分析数据包构造脚本可以发现,在手工分析时,将字符串”NTLMSSP”作为二进制数据处理,虽然对这个域进行了测试,但是却遗漏了这个漏洞.而在协议自动识别中成功地识别这个结构并且进行了测试分析.实际上,在我们进行TNS协议测试中,这是唯一的一个由字符串引发的漏洞,而且这个字符串导致的是缓冲区溢出漏洞,可能会导致非常严重的安全问题.在第20号数据包的分析中,协议自动识别产生的Fuzzer遗漏了一个长度域造成的拒绝服务漏洞.我们通过对比二者产生的数据包构造脚本分析产生这种情况的原因.在手工分析中,在传输“SessionKey”的时候,有两个前置的长度域,这两个长度域由3个字节的0x00分隔.而在协议自动识别过程中,这个结构完全被破坏:首先,传输的SessionKey被认为是字符串,而SessionKey对应的长度0x40刚好被认为是“@”字符(也就是图7中第1行表示的字节),这样处理的主要原因是这两个0x40分别在两个字符串的末端.正是由于协议自动识别中将这个结构破坏了,所以导致最终遗漏这个长度域引发的漏洞.图7手工分析的20号报文SessionKey结构Page13图8自动化分析的20号报文SessionKey结构另外在第12个数据包的环境中,自动化识别的划分粒度比人工识别的划分粒度更小,也导致自动识别报告的漏洞数量大于人工识别的数量.7.3其它协议测试分析利用自动化网络协议漏洞挖掘方法,本文继续测试了Oracle数据库的EM和ISQLPlus协议.Oracle服务器本地可以通过SQLPlus登录数据库并执行数据库操作.为了方便管理,Oracle服务器也提供了HTTP方式管理数据库.在Oracle10G2版本中,通过基于HTTP的EM协议登录远程服务器并执行管理操作,ISQLPlus则是执行数据库语句的接口.这两个服务都是基于HTTP的,而且传输过程没有加密,包括用户名和密码,本文仅对每个协议的第一个数据包进行了漏洞挖掘,测试结果表明协议自动识别能够正确地识别协议中的域.在EM协议中共测试出2个拒绝服务漏洞,在ISQLPlus中测试出3个拒绝服务漏洞.8结论和展望本文描述了自动化识别网络协议并产生模糊器对网络协议进行FuzzTesting的漏洞挖掘方法,并用这种方法对多种公开和未公开网络协议进行了测试.结论是这种方法具有快速、准确的优点.同时无需预先了解网络协议的语法,配置非常简单,能够节省大量的手工分析时间.在网络协议安全性检测、网络风险分析、模拟网络服务的蜜罐系统方面,具有重要的应用价值.本文主要做出的工作包含如下部分:首先提出了自动化网络协议FuzzTesting的完整方案;其次,在网络报文多序列比对过程中提出了基于报文长度的渐进比对和连续匹配奖励的NeedlemanWunsch算法,这两个方法在实验中比基于免疫的遗传算法要优越很多,适合网络报文的比对;对网络报文特殊域的识别做了较为深入的研究,例如长度域、Unicode域和特殊分隔符等,并提出了二进制和文本网络协议应该区分处理,相比之前的研究成果更加深入和细致.最后,在测试部分,针对公开和未公开的FTP、TNS、IM、ISQLPlus进行了深入测试,给出了详细的测试结果.在实验中,我们也发现本方法的效果依赖于采样报文本身的多样性,需要对网络协议多次采样,并尽量保证每次用不同参数来使用网络协议.如何以尽量少的采样次数得到最好的网络协议识别结果是我们未来需要深入研究的工作.
