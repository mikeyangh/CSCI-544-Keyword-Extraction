Page1基于shell命令和多重行为模式挖掘的用户伪装攻击检测田新广段毅程学旗(中国科学院计算技术研究所网络科学与技术重点实验室北京100190)摘要伪装攻击是指非授权用户通过伪装成合法用户来获得访问关键数据或更高层访问权限的行为.近年来,伪装攻击检测在保障网络信息安全中发挥着越来越大的作用.文中提出一种新的用户伪装攻击检测方法.同现有的典型检测方法相比,该方法在训练阶段改进了对用户行为模式的表示方式,通过合理选择用户行为特征并基于阶梯式的序列模式支持度来建立合法用户的正常行为轮廓,提高了用户行为描述的准确性和对不同类型用户的适应性;在充分考虑shell命令审计数据时序特征的基础上,针对伪装攻击行为复杂多变的特点,提出基于多重行为模式并行挖掘和多门限联合判决的检测模型,并通过交叉验证和等量迭代逼近方法确定最佳门限参数,克服了单一序列模式检测模型在性能稳定性和容错能力方面的不足,在不明显增加计算成本的条件下大幅度提高了检测准确度.文中提出的方法已应用于实际检测系统,并表现出良好的检测性能.关键词网络安全;伪装攻击;入侵检测;shell命令;异常检测1引言入侵者假冒或伪装成合法用户进入信息系统的入侵行为称为伪装(masquerade)[1-3].近年来,伪装攻击在网络信息安全事件中的比例不断增长[3-5],成为对系统破坏最为严重的攻击方式之一.伪装攻击检测是当前网络安全领域关注的热点.由于合法用户的行为本身是变化的,且伪装用户的行为可能看起来是正常的,这种不确定性使得伪装攻击检测比传统的网络入侵检测更为困难[4].目前的伪装攻击检测系统大多采用异常检测技术,这种技术对合法用户的正常行为进行建模,通过被监测用户的实际行为与合法用户正常行为之间的比较或匹配来检测入侵(攻击);其优点是不需要过多有关入侵行为的先验知识,且能够检测出未知的攻击类型[5].近年来,国内外已经开展了数据挖掘、机器学习、支撑向量机、神经网络等技术在用户伪装攻击检测中的应用研究[2-9],研究目标主要是提高检测的准确性、实时性、高效性以及自适应性,其中一些研究成果已经接近或达到了实用化水平.Schonlau等人研究了基于统计理论的伪装攻击检测方法[7],并利用AT&TShannon实验室的shell命令数据对不同类型的统计方法进行了实验和综合对比.Maxion等人对Schonlau的检测方法进行了改进[8],引入了贝叶斯分类算法,较大程度地提高了检测准确度.Lane等人开展了基于机器学习的伪装攻击检测研究[9],利用特定的相似度函数计算行为模式之间的相似度,并将加窗平滑后的相似度曲线作为检测用户异常行为的依据.Tian等人在Lane的基础上改进了相似度赋值方式[10],并采用可变窗长度进行相似度平滑滤噪,进一步改善了检测性能.连一峰等人提出一种基于模式挖掘的用户行为异常检测方法[11],该方法利用数据挖掘中的关联分析和序列挖掘技术对用户行为进行模式挖掘,并采用了基于相关函数的模式比较算法.此外,Kim等人研究了基于支撑向量机的伪装攻击检测方法[4],Szymanski等人提出了基于递归数据挖掘的检测方法[5],这两种方法均具有较高的检测效率,但对用户行为变化的适应性不强[2],仅适用于训练数据较为充分的场合.在以上工作的基础上,本文提出一种新的用户伪装攻击检测方法.该方法利用shell会话中用户执行的shell命令作为原始审计数据,基于实际检测系统[12]的实例分析和已有研究结论[2-9],改进了对用户行为模式的表示方式,通过合理选择用户行为特征并基于阶梯式的序列模式支持度来建立合法用户的正常行为轮廓,提高了用户行为描述的准确性和对不同类型用户的适应性;在检测阶段,充分考虑了shell命令审计数据的时序特征以及伪装攻击行为复杂多变的特点,通过多重行为模式并行挖掘来得到多个参考判决值,采用多门限联合判决的方式对被监测用户当前行为的异常程度进行分析,并通过交叉验证和等量迭代逼近方法确定最佳门限参数,克服了基于单一序列模式的检测模型[5,7-9]在检测性能稳定性和容错能力方面的不足.实验表明,同现有的典型检测方法相比,本文的方法在不明显增加计算成本的条件下大幅度提高了检测准确度,具有很强的实用性.该方法已应用于文献[12]所述发明专利的检测系统,并表现出良好的检测性能.2审计数据的分析及预处理目前,基于主机数据的入侵检测研究有两个主要的分支[3-5,13],分别是以系统调用为审计数据的程序行为异常检测和以shell命令为审计数据的用户行为异常检测.相对用户行为而言,程序行为比较单一,利用系统调用可以对程序行为特别是特权程序的行为建立较为稳定简洁的模型[14],但是,系统调用来自系统的核心层,获取过程比较复杂,耗用的系统资源较多,而且,基于系统调用的程序行为异常检测不能直接检测出用户帐号假冒等系统内部的攻击行为[13].由于用户行为复杂多变,使得用户正常行为模型的建立变得较为困难;国内外大都倾向于使用比较完整的审计事件来对用户行为进行建模.在Unix系统环境下,shell是终端用户与操作系统之间最主要的界面,很大比例的用户活动都是利用shell完成的;shell命令在系统用户层比较容易获取,而且能够直接反映出用户的行为模式.因此,基于shell命令的用户伪装攻击检测在近些年得到了较多的研究[2,4-5,7-9].与文献[4-5,7-9]中的伪装攻击检测方法相同,本文的检测方法采用Unix平台上的shell命令作为审计数据.在训练和检测阶段,需要对用户的原始shell命令数据进行预处理.预处理的方式主要有两种,第1种方式如文献[7-8]所述,预处理时只保留shell命令的名称,滤除命令参数和时间等信息.第2种方式如文献[2,9]所述,预处理时滤除shell命令中的主机名、网址等信息,保留shell命令的名称及Page3参数;各命令符号按照在shell会话中的出现次序进行排列,不同的shell会话按照时间顺序进行连接,每个会话开始和结束的时间点上插入了标识符号.例如,某用户的一个shell会话数据:>cd~/private/docs>ls-laF|more>catfoo.txtbar.txtzlg.txt>~/tian/zly>mailxtianxg@sina.com>exit经预处理后成为如下shell命令序列:(SOF,cd,〈1〉,ls,-laF,|,more,cat,〈3〉,>,〈1〉,mailx,〈1〉,exit,EOF),其中SOF和EOF分别是会话开始和结束的标识符号,〈1〉、〈3〉为目录名(地址)符号.经过以上两种方式预处理后的原始shell命令数据在形式上均表现为shell命令序列(按时序排列的若干个shell命令符号).相对于第1种方式,第2种方式预处理后的数据中互不相同的shell命令符号明显增多,但能够更加精确地反映用户行为.3训练用户伪装攻击检测的具体实现过程可分为训练和检测两个阶段[4-5].训练阶段的主要工作是根据训练数据对我们所关心的合法用户的正常行为进行建模.同程序行为相比,用户行为具有一些不同的特点,尤其是在行为的稳定性方面.因此,在程序行为异常检测中具有良好性能的训练和检测模型并不一定适用于用户行为异常检测[15].在用户行为异常检测中,由于用户行为的多变性,我们得到的训练数据往往不够充分,这就要求训练和检测模型应当具有一定的容错性、泛化能力以及对用户行为变化的适应性[2].如何利用相对不够充分的训练数据来尽可能精确地描述用户的正常行为轮廓,以及如何利用该正常行为轮廓进行异常检测是我们研究的重点.在现有的基于机器学习和基于数据挖掘的检测方法中[5,9,11],一般都采用单一长度的shell命令短序列来表示用户的行为模式(行为模式是指用户操作过程中体现出的某种规律性).但实际中,不同用户所具有的行为模式存在差异,同一用户在完成不同行为模式时所执行的shell命令个数也不尽相同,因而,采用单一长度的shell命令序列往往难以全面准确地反映用户的行为轮廓,而且,这种方法在实际应用中也不容易估算针对具体用户的最佳序列长度[7,9];例如,文献[9]主要采用实验方法来确定最佳序列长度,所需的计算量很大,而且其性能缺乏稳定性.我们针对以上不足进行了改进和修正,采用多种长度不同的shell命令短序列来表示用户行为模式,通过合理选择用户行为特征并基于序列模式的支持度来建立合法用户的正常行为轮廓,提高了用户行为描述的准确性和对不同类型用户的适应性.训练阶段的工作主要有以下几部分:(1)获取合法用户的正常行为训练数据.设正常行为训练数据为R=(s1,s2,…,sr),它是对该合法用户在历史上正常操作时所执行的原始shell命令数据进行预处理所得到的shell命令序列(其长度为r),其中sj表示按时间顺序排列的第j个shell命令符号.(2)定义W种长度不同的shell命令短序列,用于表示该合法用户的各种行为模式.设定义的短序列长度的集合为C={l(1),l(2),…,l(W)},其中l(i)表示第i种shell命令短序列的长度,且l(1)<l(2)<…<l(W).在W确定的情况下,C可有不同的选择.例如W=3时,C可以为{1,2,3}(即3种序列的长度分别为1,2,3),也可以为{3,6,9}或其它组合.W和C对检测性能有直接影响,在选择它们时,除了要充分考虑合法用户的行为特征之外,还需考虑检测系统的复杂度及检测效率(W和l(i)越大,检测系统的存储量和工作中的运算量也会越大).(3)由训练数据R生成W个短序列长度分别为l(1),l(2),…,l(W)的shell命令短序列流.这里,分别用S1,S2,…,SW表示由R生成的短序列长度分别为l(1),l(2),…,l(W)的W个shell命令短序列流,其中Si是短序列长度为l(i)(1iW)的shell命令短序列流,它包含r-l(i)+1个shell命令短序列;Si=(Sij=(sj,sj+1,…,sj+l(i)-1),SiSi点的长度为l(i)的短序列(1jr-l(i)+1).(4)对于1iW,计算Si中每个shell命令短序列在Si中的支持度.定义1.一个长度为l(i)的shell命令短序列+在shell命令短序列流Si中的支持度等于该序列Si在Si中的出现次数除以Si中的序列总数(1iW),即support(Si式中number(Si个shell命令短序列中的出现次数,support(SiPage4示短序列Si了短序列Si(5)设置W个最小支持度minsup(1),minsup(2),…,minsup(W),其中minsup(i)是针对shell命令短序列流Si中长度为l(i)的短序列而设置的(1iW).考虑到长序列模式对短序列模式的相容性,我们采用了阶梯式支持度,要求minsup(1)minsup(2)…minsup(W).(6)从W个shell命令短序列流中,分别按照序列的支持度提取正常行为模式序列.对于1iW,将Si中支持度大于或等于minsup(i)的短序列提取出来,构成满足支持度要求的序列库L(i).设Si中支持度大于或等于minsup(i)的短序列共有K(i)个,分别记为SiK(i)+(这里K(i)r-l(i)+1),则满足支持度要求Si的序列库L(i)={Si(7)建立W个序列库来描述该合法用户的正常行为轮廓.将W个满足支持度要求的序列库L(1),L(2),…,L(W)存储起来,建立用于异常检测的正常序列库L.这里,L={L(1),L(2),…,L(W)},它用于描述该用户历史上的正常行为轮廓.4检测检测阶段的工作是根据训练阶段所建立的合法用户正常行为轮廓,利用特定的检测模型来识别被监测用户当前行为中的异常(伪装或假冒行为).在检测阶段,我们充分考虑了shell命令审计数据的时序特征和短时相关性,针对伪装攻击行为复杂多变的特点,提出了基于多重行为模式并行挖掘和多门限联合判决的检测模型,并通过交叉验证和等量迭代逼近方法确定最佳门限参数,与文献[4-5,9]中的检测模型相比,在不明显增加计算成本的条件下大幅度提高了检测准确度,并且增强了检测性能的稳定性和容错能力.检测阶段的工作包括以下几部分:(1)获取用于检测的审计数据.获取该用户在被监测的时间内执行的原始shell命令审计数据,并将其预处理成shell命令序列的形式.设预处理后得到的shell命令序列为珚R=(s-1,s-2,…,s-r-),其中s-j表示按时间顺序排列的第j个shell命令符号,r-为该命令序列的长度.在实时检测(在线检测)的情况下,珚R中的各个shell命令是按照时间顺序依次得到的.(2)由审计数据珚R生成W个短序列长度分别为l(1),l(2),…,l(W)的shell命令短序列流.分别用珚S1,珚S2,…,珚SW表示由珚R生成的短序列长度分别为l(1),l(2),…,l(W)的W个shell命令短序列流,其中珚Si是短序列长度为l(i)(1iW)的shell命令短序列流;珚Si=(珚Si其中珚Si命令s-j为终点、长度为l(i)的短序列(l(i)jr-).珚Si中共有r--l(i)+1个shell命令短序列.需要指出,在训练阶段利用训练数据生成shell命令短序列流时,采用了滑动窗前向截取短序列的方式;而在检测阶段利用审计数据生成shell命令短序列流时,采用了滑动窗后向截取短序列的方式,这样便于实时检测.(3)对W个shell命令短序列流进行多重行为模式匹配与挖掘.对于1iW,将shell命令短序列流珚Si=l(i),珚Si(珚Si(s-j-l(i)+1,s-j-l(i)+2,…,s-j)同相应的序列库L(i)={Si1+,Si列珚Sij与序列库L(i)中的某个短序列相同(即珚SiL(i)),则将短序列珚Siclass(珚Si短序列都不相同(即珚Si为异常行为模式序列,并记class(珚Si序列匹配,对于每一个shell命令短序列流珚Si=(珚Sil(i),珚Siclass(珚Si(4)计算判决值.根据国内外现有的研究结论,进行伪装攻击的用户在短时间内的行为可能与合法用户的正常行为没有太大差别,但在较长时间段内表现出的行为特征通常会较大程度地偏离合法用户的正常行为轮廓.考虑到用户伪装攻击的以上特点,我们并不直接利用class(珚Si参考判决值,进而对被监测用户的行为作出判决.在对每个shell命令短序列流珔Si进行模式匹配与挖掘之后,可对相应的序列(class(珚Siclass(珚Si式中,e为窗长度,Di(j)表示shell命令短序列珚Si应的判决值,且e+l(i)-1jr-.Di(j)反映了以Page5j为终点的e个shell命令短序列中正常行为模式序列的比例.shell命令短序列流珚Si=(珚Si珚Sir-)中第e+l(i)-1个短序列及其后面的每个短序列都分别对应一个判决值.对于W个shell命令短序列流珚S1,珚S2,…,珚SW,我们可以并行计算出判决值D1(j),D2(j),…,DW(j),其中j的增长步长为1.(5)利用判决值对被监测用户的当前行为进行判决.在利用上述判决值对被监测用户的行为进行判决时,有以下两种方案可供选择:第1种判决方案.根据合法用户的行为特点,在判决值D1(j),D2(j),…,DW(j)中选取一个Dk(j)作为最终判决值(这里1kW).对于一次以珚R=(s-1,s-2,…,s-r-)为审计数据的检测过程,当Dk(j)中的j变化(增大)时,k是固定不变的.在利用Dk(j)进行判决时,首先设定一个判决门限a.如果Dk(j)>a,将被监测用户的当前行为判为正常行为;如果Dk(j)a,将被监测用户的当前行为判为异常行为(这里,被监测用户的“当前行为”是相对于珚R=(s-1,s-2,…,s-r-)中shell命令s-j对应的时间点而言的,它是指以s-j为终点的e+l(k)-1个shell命令所对应的行为,即s-j-e-l(k)+2,s-j-e-l(k)+3,…,s-j所对应的行为).在该方案中,je+l(k)-1;也就是说,被监测用户执行完第e+l(k)-1个shell命令后才能对其行为做第一次判决.第2种判决方案.设定W个判决门限a1,a2,…,aW,在并行计算出判决值D1(j),D2(j),…,DW(j)之后,按照以下步骤对被监测用户的当前行为进行判决.1.设定k··=1.2.如果Dk(j)ak,则将被监测用户的当前行为判为异常行为,并不再执行以下步骤.3.如果k<W,则k··=k+1(k的值增加1),并返回执行步2.如果k=W,则执行步4.4.如果Dk(j)ak,则将被监测用户的当前行为判为异常行为;否则,将被监测用户的当前行为判为正常行为.在第2种判决方案中,如果对于1kW,存在一个Dk(j)小于或等于ak,则将被监测用户的当前行为判为异常行为;如果对于1kW,所有的Dk(j)均大于ak,则将监测用户的当前行为判为正常行为(被监测用户的“当前行为”是相对于珚R=(s-1,s-2,…,s-r-)中shell命令s-j对应的时间点而言的,它是指以s-j为终点的若干个shell命令所对应的行为).在该方案中,je+l(W)-1.j的值每增加1,都要执行以上步骤来对被监测用户的当前行为做一次判决.对于第1种判决方案,在窗长度确定的情况下,虚警概率和检测概率不仅受判决门限的影响,而且还取决于最终判决值Dk(j),如何从W个参考判决值D1(j),D2(j),…,DW(j)中选取最佳的最终判决值Dk(j)是第1种判决方案的关键.根据现有的研究成果和我们的检测实例分析,对于不同的合法用户,由于行为特点不尽相同,最佳的判决值Dk(j)往往是不同的,而且,对于同一合法用户,针对不同伪装用户异常行为的最佳判决值Dk(j)也是不同的,所以,在实际应用中不太容易确定最佳的Dk(j),特别是在对伪装(异常)行为先验知识缺少了解的情况下.相比之下,第2种判决方案对不同合法用户和不同伪装(异常)行为具有较强的适应性,多模式并行挖掘和多门限联合判决保证了在用户行为复杂多变的情况下也能够获得很高的检测准确率,其代价是一定程度上增加了检测阶段的计算成本.5参数确定与特点分析对于检测阶段的两种判决方案,如何选择判决门限是实际应用中的关键问题.我们可参照文献[7]中交叉验证的方法来确定第1种判决方案中的判决门限a,将获得的正常行为训练数据反复交叉地按固定比例分成两部分,一部分用于训练,另一部分用于测试虚警概率和判决门限,在测试中通过调整判决门限来得到不同虚警概率与不同判决门限的对应关系,并将期望虚警概率所对应的判决门限作为实际检测时的门限.第2种判决方案中的各个判决门限a1,a2,…,aW的选择相对复杂,可基于第1种判决方案中交叉验证的方法并通过等量迭代逼近的方式确定.具体步骤如下:4.设定i··=1.对于1kW,令ak(i)=p(k).5.设定判决门限的增量b.6.i··=i+1.对于1kW,令ak(i)=p(k)+b.1.设定k··=1,并设定期望虚警概率的上限q.2.使用Dk(j)作为第1种判决方案的最终判决值,并令q(k)=q/W(这里q(k)表示Dk(j)作为最终判决值时此种判决方案所容忍的最大虚警概率),然后利用获得的训练数据通过交叉验证的方法来得到第1种判决方案下期望虚警概率q(k)所对应的判决门限p(k).3.k··=k+1(k的值增加1).如果kW,返回执行步2.如果k>W,执行步4.Page67.将a1(i),a2(i),…,aW(i)作为第2种判决方案中的W个判决门限(其中ak(i)与Dk(j)相对应),然后利用训练数据通过交叉验证的方法测试第2种判决方案的虚警概率u(i).8.如果u(i)>q,则对于1kW,令ak=ak(i-1).如果u(i)=q,则对于1kW,令ak=ak(i).如果u(i)<q,则返回执行步6.基于以上方法确定两种判决方案的判决门限,我们可以对虚警概率进行控制(训练数据越充分,对虚警概率的控制就越精确),而实际检测中对伪装(异常)行为的检测概率则受多种因素影响.此外,窗长度e也是一个重要参数,e越大,检测准确率往往越高,但判决延迟也越大;根据实例分析和同类检测方法的实验结论,一般将e控制在50~150之间为宜.需要指出,在实时检测(在线检测)的情况下,检测阶段中被监测用户所执行的shell命令的获取和预处理、shell命令短序列流的生成、行为模式匹配与挖掘、判决值的计算以及对用户行为的判决都是同步进行的.当获得审计数据珚R=(s-1,s-2,…,s-r-)中的第j个shell命令s-j之后,就可以生成以s-j为终点的长度分别为l(1),l(2),…,l(W)的W个shell命令短序列珚S1配,计算出判决值D1(j),D2(j),…,DW(j),进而对被监测用户的当前行为做一次判决.6实验设计与结果分析作者利用普度大学和AT&TShannon实验室的两组shell命令实验数据分别对以上方法的性能进行了实验.普度大学的数据包含8个Unix用户在两年时间内的活动记录(实验数据的详细说明见文献[9]或文献[2]).实验中采用了其中的4个用户user1、user2、user3、user4的数据,并且将user1、user2、user3设为伪装用户,将user4设为合法用户.每个用户的shell命令流中各有15000个命令,user4的前10000个命令作为训练数据用于正常行为建模,而每个用户的后5000个命令作为测试数据用于性能测试.实验的参数设置为W=3,C={1,2,3},minsup(1)=minsup(2)=minsup(3)=0.0002,窗长度e=151.在采用第1种判决方案时,使用D3(j)作为最终判决值,判决门限a=0.5.在采用第2种判决方案时,3个判决门限分别为a1=0.86,a2=0.64,a3=0.48.为了方便与同类方法进行检测准确度的比较,实验中将上述两种判决方案的期望虚警概率分别设定为0.06%和0%,在此基础上确定相应的判决门限,然后根据判决值分别计算两种判决方案的检测概率.在AT&TShannon实验室的shell命令实验数据中(该数据的详细说明见文献[5]或文献[7]),我们选择前4个用户user1、user2、user3、user4的数据进行实验,每个用户有5000个shell命令,实验时将其中user4设为合法用户,该用户的前4000个命令作为训练数据用于正常行为建模,后1000个命令作为测试数据用于测试虚警概率;其他3个用户设为伪装用户,其中每个用户的5000个shell命令均作为测试数据用于测试检测概率.实验的参数设置为W=3,C={1,2,3},minsup(1)=minsup(2)=minsup(3)=0.0005,窗长度e=100.在采用第1种判决方案时,使用D3(j)作为最终判决值,判决门限a=0.35.在采用第2种判决方案时,3个判决门限分别为a1=0.62,a2=0.37,a3=0.34.图1给出了采用普度大学数据进行实验时判决值D3(j)的曲线,图中上方的细实线为合法用户user4对应的曲线,下方的两条虚线和粗实线分别是伪装用户user1、user2、user3对应的曲线.图2给出了采用AT&TShannon实验室数据进行实验时判决值D3(j)的曲线.可以看出,两个图中合法用户对应的判决值曲线同伪装用户对应的判决值曲线具有良好的可分性.在图1中,合法用户user4对应的判决值全部大于0.48,而伪装用户user3对应的判决值全部小于0.57,只有user1、user2对应的少量判决值在0.57之上.在图2中,合法用户user4的判决值曲线能够同伪装用户user2、user3的判决值曲线很好地区分开来(仅有很少量的判决值出现交叠),但同user1判决值曲线的可分性稍差一些,说明两者的某些行为具有较高的相似度.Page7图2AT&TShannon实验室数据对应的判决值曲线同时,作者还利用以上两组shell命令实验数据分别对文献[4]中基于支撑向量机的检测方法、文献[9]中基于机器学习的检测方法以及文献[2]中基于齐次Markov链模型的检测方法进行了实验,并同本文的方法在检测准确率和计算成本两个方面进行了对比.表1给出了利用普度大学shell命令数据所做实验的结果.本文第1种判决方案的实验结果0.0680.53587本文第2种判决方案的实验结果083.02711文献[4]中检测方法的实验结果0.1674.08510文献[9]中检测方法的实验结果0.5275.813146文献[2]中检测方法的实验结果0.3375.93465表2给出了利用AT&TShannon实验室shell命令数据所做实验的结果.表2ATTShannon实验室数据对应的实验结果本文第1种判决方案的实验结果0.0485.26135本文第2种判决方案的实验结果084.91173文献[4]中检测方法的实验结果0.3280.87120文献[9]中检测方法的实验结果083.60934文献[2]中检测方法的实验结果0.1981.92108根据表1和表2的实验结果,本文所提出方法的检测准确率明显高于文献[2,4,9]中的检测方法,而第2种判决方案的检测结果又优于第1种判决方案.表中的实验时间是指实验中进行训练(正常行为建模)和检测所需要的时间,该指标与检测方法的计算成本成正比,并在一定程度上反映了检测的实时性.由实验结果可见,采用第2种判决方案时本文方法的计算成本略高于文献[2,4]中的检测方法,但远低于文献[9]中的检测方法.可见,本文中检测方法的综合性能优于文献[2,4,9]中的检测方法.此外,我们还利用普度大学和AT&TShannon实验室两组数据中不同用户的shell命令数据进行了反复交叉实验,实验结果表明,当采用第1种判决方案时,最佳的判决值Dk(j)是与具体用户相关的,因此实际检测中用于行为判决的最佳Dk(j)主要基于已有的训练数据并通过预先实验来确定;而第2种判决方案对不同用户具有更好的适应性,总体上也有更高的检测性能.为了进一步验证第2种判决方案的检测准确率,我们在上述实验的基础上对判决门限进行了调整,得到不同虚警概率条件下的检测概率.图3给出了采用普度大学数据进行实验时反映虚警概率与检测概率对应关系的ROC曲线,图4给出了采用AT&TShannon实验室数据进行实验时的ROC曲线.从两组实验数据对应的ROC曲线可以看出,相对于文献[2,4,9]中的检测方法,本文方法中第2种判决方案的检测准确率具有明显的优势.图4AT&TShannon实验室数据对应的ROC曲线7结束语目前的伪装攻击检测方法存在的主要问题是对用户行为变化缺乏适应性,检测性能的稳定性和容Page8错能力不够强,检测准确度也有待提高.本文提出一种新的基于shell命令和多重行为模式挖掘的伪装攻击检测方法,该方法基于实际检测系统的实例分析和已有研究成果,充分考虑了审计数据和用户行为的特点,改进了用户行为模式和行为轮廓的表示方式,提出了基于多重行为模式并行挖掘和多门限联合判决的检测模型,在不明显增加计算成本的条件下大幅度提高了检测准确度,并且增强了检测性能的稳定性和对用户行为变化的适应性.需要指出,在该方法的实际应用中,通过优化行为模式序列的表示及存储方式,还可以进一步提高其检测效率.
