Page1一种基于多约束组合的多租户系统配置测试技术侯可佳白晓颖周立柱(清华大学计算机科学与技术系北京100084)(清华大学信息科学与技术国家实验室北京100084)摘要通过灵活配置实现在线软件定制是多租户(Multi-TenancyArchitecture,MTA)软件即服务(Software-as-a-Service,SaaS)系统的一个重要特征.由于参数和行为配置的复杂多样,配置错误是系统质量所面临的主要风险之一.对各种配置的组合测试,是MTASaaS系统测试的一个重要内容.该文针对配置之间的约束依赖关系,提出建立约束依赖图,利用图搜索算法获取具有依赖关联的配置项集合,采用组合测试算法,生成不同的配置测试场景,满足多配置组合覆盖率要求.实验以多租户游戏系统为例,对比多种测试生成算法,实验显示该方法在检测由约束违反引起的系统缺陷方面有显著改善效果.关键词约束组合;多租户系统;配置测试;数据生成;组合测试算法1引言针对特定的领域应用,多租户软件即服务(Multi-TenancySoftware-as-a-Service,MTASaaS)提供基于共享的、可重用的基础数据和基础代码,定制特定的应用系统的服务,其目标是在保证用户个性化的同时尽可能地将资源共享最大化.这种多租户资源共享、租户应用定制和隔离的模式,可以大幅度减少用户构建和维护系统的代价,成为云计算软件服务系统的一个主要发展趋势[1].例如Salesforce.com作为目前最具代表性的SaaS提供商之一,其用户关系管理(CustomerRelationManagement,CRM)服务在云平台上能够同时对全球超过100000家企业提供业务支持.1.1SaaS系统可配置性分析设计良好的MTASaaS系统可在数据、行为、用户界面等多个层面支持用户的定制需求[2].例如,Salesforce利用元数据驱动方法,实现了共享数据库和数据模式[3];GoogleAppEngine①采用命名空间机制来区分租户的数据和行为.MTA架构通常包括两个部分:(1)通用的基础代码,基础代码中包含有丰富的领域知识,包括元数据和业务规则等内容;(2)定制机制,该机制能够满足不同用户的特定需求.可配置性是MTA设计的基础,与大多数软件系统中简单直接的参数配置相比,MTASaaS的配置需要更加灵活、动态地在基础代码中注入数据、条件规则和行为,实现应用的定制,其配置测试也面临着用户种类和配置场景复杂、缺乏内置的可测试性等挑战.传统可配置软件和MTASaaS的具体区别包括:(1)传统软件的可配置项主要是简单的参数配置,并且大部分配置项均提供候选项供用户选择,可配置项的数量也非常有限.MTASaaS则存在大量的可配置项,这些配置项将不再局限于简单的参数值的修改,用户甚至可以根据自己的需求增加数据项,对服务提供的API进行重新组装以完成特定任务等.(2)传统软件的配置参数在软件编译时即被固化在软件代码中.多租户系统中,除静态编译的参数配置外,还支持系统行为动态的配置.这些配置内容,独立于系统的基础代码,在系统运行过程中,动态载入.这样,既保证了基础代码对所有租户的一致性,又可保证租户可以配置其特定的应用行为;且租户特定的行为更改时,不会影响基础代码,保证了不同租户之间的隔离.例如,客户关系管理系统(CRM)是Salesforce公司在Force.com平台上提供的SaaS服务,它为用户提供了丰富的可配置选项,用户根据各自的需求和喜好对这些可选项进行配置,即可获得满足其需求的应用实例.Force.com的CRM服务配置包括:(1)用户界面的配置.对于以表格为主体的界面,例如联系人列表界面,用户可以选择显示或隐藏其中的某些列,或者改变列的顺序,或者通过编写过滤规则,选择需要显示的记录;对于其他类型的界面,例如联系人详细信息界面,用户可以通过自己的喜好更改页面布局,例如改变页面组件的位置、颜色、形状等.(2)用户管理.服务管理员可以根据人员组织结构为服务添加用户、为用户分组、为用户分配不同的角色,根据角色的不同,为用户赋予不同的使用权限.(3)数据管理.Force.com是元数据驱动体系架构,因此数据配置是Force.com的核心内容.用户通过增加自定义对象来存储组织用户特有的数据,自定义对象创建成功后,便能够进一步创建自定义选项卡、报表、仪表板等,使用户能够对自定义对象进行交互操作.Force.com并没有为用户数据创建实际的数据库表格,而只是存储相关的元数据,在服务运行时,利用这些元数据动态的生成用户数据表格.(4)应用程序管理.当Force.com平台所提供的服务无法满足用户需求时,用户还可以在自定义对象的基础上,利用平台提供的API开发所需服务,完成用户需要的特殊服务.1.2SaaS系统故障模式分析MTA共享/隔离机制可能给系统的质量、性能和安全带来风险[2].SaaS平台的可靠性、可用性和安全性等对大量多租户应用的可靠安全至关重要,因此,在各种租户场景下,验证和测试系统行为的正确性、鲁棒性,是MTASaaS系统开发的一个重要环节.基于对多租户体系架构的分析,MTASaaS的故障能够划分为如下4类:MTA数据库故障、通用①GoogleAppEngine.http://code.google.com/appengine/Page3基础代码故障、配置故障以及运行故障.(1)数据库故障.多租户数据库的设计对于确保公共共享数据和应用专用数据的完整性、正确性和安全性至关重要[4].不同租户数据的共享和隔离均可能引发不可预见的故障.(2)通用基础代码故障.通用基础代码对于所有的租户都是一致的,其中包含了系统的规则和行为等内容.通过对基础代码的重用,能够大大降低每个应用程序的开发和维护费用.同时,基础代码的质量也成为SaaS系统质量的基础.(3)配置故障.丰富多样的可配置组件是实现MTASaaS的关键,同时,配置的多样性和动态性又是极易引发故障的因素.配置故障是本文的主要研究重点,且会在论文的后续部分进行详细讨论.(4)运行故障.不同租户应用实例的执行均可能会对彼此产生影响,特别是当存在大量不同的租户配置时,运行行为更加难以预料和控制.在以上4类MTASaaS系统的故障类型中,本文将着重研究配置故障.分析研究表明,配置故障主要由以下几方面原因引起:(1)未能合理满足系统的约束条件.设定配置参数常常需要大量的系统领域知识,以满足特定的约束条件,部分约束条件为系统的隐含假定,或是内嵌在基础代码中,由于文档不完善、理解错误、或是系统安全保护不够等原因,常常由于约束条件不符合而造成租户应用错误.(2)未能满足多配置之间的依赖关系.多参数的配置常常相互制约相互影响,参数的配置除了满足本身的限制之外,还需保持全局的合理性;而一组相互关联的参数之间,由于配置的不匹配所造成的错误,也是系统故障的主要原因之一.这种依赖关系的定义通常分散在各个参数的定义中,或是隐含的系统假设中,容易被忽视从而导致出错.1.3主要贡献针对上述问题,本文从以下两个方面提出了一种新的MTASaaS系统配置测试方法.(1)提出了约束依赖图(ConstraintsDependencyGraph,CDG),作为约束条件的分析工具.CDG模型识别主要的配置项及其约束条件,并将其相互关联起来.每个配置项可能定义多种约束条件,每个约束条件可能包含多个配置项.这样,CDG的每个连通子图就构成了一组相互依赖的配置项.测试设计转化为可达图搜索问题,并设计生成测试用例以满足每个连通子图上的所有约束依赖关系.(2)提出了约束的组合测试方法.当参数和约束条件较多、依赖关系复杂时,全覆盖测试常常会引起组合爆炸问题.本文采用组合测试的思想,设计对于约束条件的组合方法,以便在较小的测试代价下达到较高的覆盖率要求,并能有效的提高系统缺陷检测能力.本文第2节以一个游戏系统为例,分析了MTASaaS的配置测试问题,并对问题进行形式化定义和描述;第3节提出约束依赖图;第4节讨论约束组合测试方法;第5节报告实验过程及其结果;第6节对相关工作进行总结和讨论;最后,第7节是对本文研究工作的总结讨论.2问题定义2.1案例分析电子游戏制造器(ArcadeGameMaker,AGM)是一个教学系统①,用于学生实践生产线体系架构(Product-LineArchitecture,PLA).本文将其重构后,形成一个在线的MTASaaS系统MTA-AGM,其可在同一游戏平台上,支持配置静止物体、移动物体、物体碰撞规则、游戏得分规则等多种特性,动态生成多种类型的游戏应用.图1对比了PLA和MTA两种不同的体系架构实现方法.PLA设计中,所有游戏产品共享同一个核心程序包,不同的游戏产品对基础程序包进行扩展,形成不同的单独编译图1AGM系统PLA与MTA体系结构对比①ArcadeGameMakerPedagogicalProductLine.http://Page4的游戏程序包.MTA系统则只包含一个代码程序包,通过系统配置,在线生成不同的游戏实例.游戏中物体行为的配置利用了Java的反射机制实现动态重新加载类和动态编译.AGM游戏定义了一系列静止物体和移动物体,移动物体包含可控移动物体和不可控移动物体.游戏者通过控制可控移动物体,使其与其他物体发生碰撞从而得分.租户可以根据各自的需求设置不同的物体行为和游戏机制来实现游戏的个性化定制.MTA-AGM游戏系统的可配置项包括:(1)游戏背景属性.游戏背景限定了移动物体的可移动范围.在游戏过程中,当移动物体超出游戏背景的范围时,游戏者失败,游戏结束.游戏背景可以设置为不同的大小和颜色.(2)物体属性.静止物体和移动物体包含一组通用属性,例如物体位置、大小、颜色等.除此之外,移动物体还有一些独特属性,例如移动速度和移动方向等.(3)物体行为.碰撞规则定义了每个物体在碰撞之后的行为.对于静止物体而言,碰撞之后物体的动作包括消失和不变;而移动物体,除了消失和不变之外,还有3种动作行为,即垂直反弹、水平反弹、以及全反弹.(4)游戏机制.游戏机制包括碰撞动作的具体定义、游戏者的得分规则等等.本研究将在实验过程中,将这些配置项设置为固定取值,主要针对上述3类配置项进行配置测试,考察这些配置项之间不同的取值组合对测试的影响.2.2问题定义给定一个多租户系统MTA-Service={v1,v2,…,vk},其中vi(1ik)为系统的可配置项,该系统共包含k个可配置项,为配置项赋值分为两种情况:(1)从系统给定的候选值中选择;(2)由用户直接赋值.租户根据各自不同的需求对多租户系统进行配置,从而得到满足其要求的应用实例,如租户ti对该系统进行配置得到的应用实例表示为C(S,ti)={ai1,ai2,…,aik},其中vj=aij(1jk),aij是租户ti为第j项配置项设定的配置值.每个配置项通常具有多个可选取值,配置项的取值个数通常有以下几种情况:(1)配置项的取值是有限并且少量的.例如在上述碰撞游戏中,物体状态配置项的可选取值只有两个,即移动和静止.(2)配置项的取值是有限的,但数量非常大.例如在800×600的背景中,物体起始位置横坐标的范围为[0,800),如果要求坐标为正整数,则横坐标可能的取值有800个.(3)配置项的取值是无限多个.同样以上述横坐标为例,如果其值为正实数,在800×600的背景中,可能的取值个数就为无限多个.这些配置项的不同取值组合能构成不同的配置场景,产生不同的多租户应用实例,为保证多租户系统在各种配置场景下行为的正确性,就必须进行充分的配置测试.多租户系统的各配置项之间往往存在各种约束依赖关系,对系统进行配置时,如果违反这些约束条件,则可能引发系统故障.因此在测试过程中,配置项之间的约束条件就需要作为一项重要指标进行考察,尤其是多个约束条件的组合,更容易导致系统故障,需要进行重点测试.假设被测系统S的k个配置项之间具有m条约束条件:c1,c2,…,cm,每条约束条件有多个可能的取值,不同约束条件的不同取值能产生若干不同的约束组合,此研究的目标就是为被测系统的k个配置项求解N种不同的配置情况,即其中,要求X能够实现对m条约束条件强度为2的组合覆盖.该组合覆盖要求的具体定义为:m条约束条件中的任意两条约束条件ci和cj的每一组取值组合,至少要被一组参数配置所覆盖.3约束依赖图3.1约束模型本文基于多租户系统领域模型,提取系统约束模型,约束条件包括参数约束条件、动作约束条件以及状态-动作约束条件,即Constraints=〈Data-Cons;Action-Cons;St-Act-Cons〉.参数约束条件Data-Cons定义了参数之间的约束限制关系,包括对单个参数的约束条件以及多个参数之间的约束条件的定义.(1)单参数约束条件C(di),约束条件中仅包含一个配置参数,在参数数据类型的基础上描述参数取值方面的约束限制条件,例如对数值型数据的取Page5值范围的限制、对字符串型数据的长度和模式的限制等;(2)多参数约束条件,约束条件中包含多个配置参数,其表示这些参数之间的约束依赖关系,约束条件中可以包含数学运算符、谓词逻辑符等等:①简单约束,仅包含两个参数和一个二元关系符的约束条件,即C(di,dj)=direldj,其中rel为二元关系符,如>、<、=等,能够表达两个参数之间大于、小于、等于等关系;②复杂约束,包含了两个或两个以上参数以及多个常量数据的约束条件,这些参数和常量之间通过多个运算符或关系符等进行连接.多租户系统通常存在大量可供选择的动作行为,有些动作之间互不相关,而有些动作之间却存在某些约束依赖关系.动作约束条件Action-Cons=〈AS;AE;Sequence-Cons〉利用集合定义系统动作的约束依赖关系,包括起始动作、终止动作定义以及动作之间的顺序约束关系等:(1)AS为起始动作集.所有动作序列均需以该集合内的动作开始,若为空,则动作序列可以系统任意动作开始;(2)AE为终止动作集.所有动作序列均需以该集合内的动作结束,若为空,则动作序列可以系统任意动作结束;(3)顺序约束条件Sequence-Cons=〈{Afteracti{Parallelacti约束利用两类集合定义了动作顺序执行约束和并行执行约束,顺序执行约束Afteracti作acti之后顺序执行的动作集合,并行执行约束Parallelacti状态-动作约束关系St-Act-Cons定义了系统状态与相关动作之间的约束依赖关系,例如系统的某些行为动作只有在系统达到某种特定状态时才能够执行,而在其他状态下则不能执行.因此我们将状态-动作约束关系定义为一种状态到动作集的映射关系集,即{St→{Ai}},该映射关系表示当系统处于状态St时,集合{Ai}中的动作均能够正常执行,而集合外的其他动作则不能在此状态下进行.3.2约束依赖图本文利用参数的约束依赖图(ConstraintsDependencyGraph,CDG)来表示参数之间的约束依赖关系,该约束依赖图中包含两类对象P和C:P为服务参数对象P={p1,p2,…},C为约束条件对象C={c1,c2,…},CDG的具体定义及其性质如下:(1)CDG=〈V,E〉,为定义在被测系统配置参数P和约束条件C上的约束依赖图;(2)V为节点集,并且V=P∪C;(3)E为无向边集,E={(pi,cj)},其中pi∈P,cj∈C,其表示约束条件cj中包含参数pi,表达参数pi受到约束条件cj限制的含义,不存在连接两个参数对象或者两个约束条件对象的边,即如果边e=(pi,pj)或e=(ci,cj),则eE;(4)参数节点的度D(pi)为与参数pi相关的约束条件的数量,并且D(pi)0,若D(pi)=0,说明参数pi不受任何约束条件的限制;(5)约束节点的度D(ci)为约束条件ci中包含的参数个数,并且D(ci)>0;(6)若参数节点pi和pj之间仅经过一个约束节点c相连,即pi和pj之间存在路径L=picpj,则说明参数pi和pj出现在同一条约束条件c中,即pi和pj之间存在直接约束依赖关系;若节点pi和pj之间经过多个约束节点相连,即pi和pj之间存在路径L=pic1p1…ck-1pk-1ckpj(k>1),则说明参数pi和pj之间通过其他参数p1,…,pk-1等产生联系,存在间接约束依赖关系;(7)若参数节点ci和cj之间存在一条路径L=cipcj,说明约束条件ci和cj包含相同的参数p.构建参数约束依赖图的过程如算法1所示.算法1.数据约束依赖图构造算法.输入:系统参数和参数之间的约束条件输出:数据约束依赖图LetGbeagraphwithnoverticesoredges;FOR(eachconstraintci)GenerateaverticevciaccordingtoconstraintciENDFORFOR(eachparameterpi)GenerateaverticevpiaccordingtoparameterpiENDFORFOR(eachverticevci)IF(constraintcicontainsparameterpj)Thengenerateanedgeebetweenvciandvpj,e=(vci,vpj)ENDIFENDFOR图2为一个简单的参数约束依赖图,包含2个参数和3条约束条件.其中约束条件0x<800和0<l800的度均为1,表示约束条件中仅包含1个参数,约束条件0<x+1800中包含2个参数,且该约束节点的度为2,表示两个参数之间的约束依Page6赖关系.2个参数节点的度均为2,表示参数x,l均受到两条约束条件的限制.合理的参数取值能够使与其相关的约束条件为真,如果图中包含的所有参数的取值使全部约束条件均为真,则称这组参数取值为合理参数值,能够激发被测系统的正常运行情况.CDG的连通性表达了图中所包含的参数以及约束条件之间的相关性,相关性包括以下3种类型:(1)参数之间的相关性.两个参数之间存在路径相连通,则称这两个参数相关,表现为这两个参数同时存在同一条约束条件,或者这两个参数通过其他参数间接相关;(2)参数和约束条件之间的相关性.参数和约束条件之间存在路径相连通,则称该参数和约束条件相关,表现为约束条件直接包含该参数,或者约束条件中的其他参数与该参数相关;(3)约束条件之间的相关性.两条约束条件之间存在路径相连通,则称这两条约束条件相关,表现为这两条约束条件包含相同参数,或者相关参数.对于多租户系统中一组具有相关性的参数,生成其中一个参数的取值时,必须同时考虑其他参数的取值情况,与这些参数相关的约束条件则是判定这些参数取值合理与否的根据.从被测系统参数的CDG中能够很容易的判定参数以及约束条件之间的相关性,依据CDG的连通性将其划分为多个连通子图G1,G2,…,每个子图中包含的参数以及约束条件之间均存在相关性,而存在于不同子图中的参数或者约束条件之间则不存在相关性.每个子图中包含的参数和约束条件就是每次生成参数取值时需要考虑的参数及约束条件的最小集合.CDG连通子图的性质包括:(1)对于任意子图Gi中的任意两点v,v,存在路径P=ve1v1e2v2…eniv连接两点;(2)对于任意两点,v∈Gi,v∈Gj,i≠j,不存在边e=(v,v);(3){v|v∈Gi}∩{v|v∈Gj}=,i≠j.4约束组合测试方法4.1配置参数生成本研究针对CDG的每个连通子图,考察其中包含的约束条件,生成约束条件的不同取值组合,利用组合约束为测试生成定义目标函数,并采用模拟退火搜索算法实现参数取值的生成.本研究仅考虑两种类型的约束条件,枚举类型的约束条件和布尔表达式类型的约束条件.枚举约束的取值将直接确定测试用例中相应参数的取值,约束条件的取值个数与参数可选的取值个数相同;布尔约束的取值个数为两个,即真和假.每个连通子图中参数的生成过程如算法2所示,每组约束组合的目标函数将可能存在多种定义形式,算法需要针对每种目标函数定义生成一组测试数据:算法2.配置参数生成算法.输入:系统约束依赖图输出:测试数据LetPbethesubsetoftheconfigurationparametersLetC={c1,c2,…,ck}bethesetofalltheconstraintsLetVibethesetofallthevaluesofconstraintciGeneratevaluecombinationsofCusingcombinatorialLetCi={c1=vi1,c2=vi2,…,ck=vik}betheithvalueFOR(eachvaluecombinationCi)Constructobjectfunctionsobj1,obj2,…,objwforPFOR(eachobjectfunctionobjj)GeneratevaluesforPusingSimulatedAnnealingENDFORENDFOR算法2中每组约束组合包含多条约束条件,因此其目标函数也由多个子目标函数组成,每个子目标函数对应约束组合中的一条约束条件,当子目标函数存在多种定义形式时,则总目标函数也会存在多种定义.枚举类型的约束条件直接确定参数取值,因此与其对应的子目标函数值为0,在目标函数生成算法中着重考虑布尔类型的约束条件.对于每条布尔类型的约束条件ci,如果其取值为0,则首先将其取反,即ci=1,然后将ci或ci转换为等价的析取范式形式,即()ci=p1+p2+…+pi,其中包含Page7i个乘积项,因此与约束条件ci/ci对应的子目标函数将拥有i种不同的定义,那么该约束组合也将至少有i种不同的目标函数定义.如果在某一组约束组合中,超过一条约束条件拥有多个乘积项,也就是说超过一个子目标函数拥有多种定义形式,则在定义总目标函数时需要再次利用组合测试的方法.对于每一组约束组合,其目标函数的具体生成过程如算法3所示.算法3.目标函数定义算法.输入:系统约束依赖图输出:目标函数Letv1tovkbeanassignmenttoconstraintsc1tockFOR(eachBooleanconstraintci)IF(ci=0)THENci=ciENDIFConvertcitoitsequivalentdisjunctivenormalformFOR(eachtermpjinci)Constructsub-objectfunctionobjijaccordingtopjENDFORobjihasdifferentdefinitionsobji1,obji2,…ENDFORFOR(eachenumerativeconstraintci)obji=0ENDFORUsingcombinatorialtestingmethodonobj1,obj2,…,objktoconstructobjectfunctionobj=obj1+obj2+…+objk下面以图2所示的约束依赖图为例,简单介绍利用正交试验设计方法[5]生成参数取值的过程.图2中包含的约束条件及其可能的取值定义如表1所示,其中取值为1表示该约束条件为真,取值为0表示该约束条件为假.可能的取值12针对表1,利用正交试验设计方法生成的约束组合,如表2所示.组合号1234表2中每一行就是一组约束组合,其中第一行对应的约束组合为该约束组合中包含3条约束条件,因此总目标函数定义为obj=obj1+obj2+obj3,由于每一条约束条件均只包含一个乘积项,因此每个子目标函数均只有一种定义方式,即(1)obj1=(2)obj2=(3)obj3=最后基于上述目标函数定义,利用模拟退火搜索算法能够生成一组测试数据.4.2动作序列生成多租户系统不仅为用户提供系统参数配置,还为用户提供系统动作行为方面的配置,用户能够根据需求配置不同的动作序列,完成不同的系统功能.因此配置测试也应当包含动作配置测试,以确保系统在不同动作配置下能够正常运行.从系统提供的n个候选动作中选取其中n个动作,生成目标动作序列,能够产生nn种不同的动作序列,这显然是难以实现的,因此本文采用正交试验设计方法从候选动作中选取部分动作生成动作序列.为此我们定义两个集合,候选动作集合和目标动作序列集合.(1)候选动作集合Action={acti|i=1,2,…,n},即系统提供的所有系统动作的集合;(2)目标动作序列集合S={Si|i=1,2,…,n},即租户对系统候选动作进行选择排列得到的动作序列的集合.第j个目标动作序列Sj包含有nj个动作,Sj=〈s1,s2,…,snj〉,其中,si=acti,i∈[1,nj],i∈[1,n].在正交试验设计中,将动作序列Sj中的各预期动作作为试验因素,因素水平根据动作约束条件定义.如果被测系统对起始动作或终止动作有特殊要求,则动作序列Sj中的起始动作s1或终止动作snj定义为两水平因素,s1的两水平分别为起始动作集合Page8AS以及除起始动作之外的其他动作Action-AS,同理snj的两水平分别为AE和Action-AE.动作序列中的其余动作均为三水平因素,因素水平的定义依赖于前一个动作,例如对于Sj的动作si,其三水平分别定义为AftersParellels没有特殊要求,则起始动作为一水平因素,其水平为动作集合Action,终止动作的因素水平与序列中其余动作的水平定义相同.动作序列生成的具体过程如算法4所示.算法4.动作序列生成算法.输入:候选动作集合,动作约束条件输出:目标动作序列集合LetAction={acti|i=1,2,…,n}bethesetofallthesystemactionsLetASbethesetofstartactions,andAEbethesetofendactionsLet〈s1,s2,…,sn〉bethetargetactionsequenceIF(ASisnotnull)THENs1hastwolevelsAsand表3动作序列的因素水平表试验因素水平12Action-AS35实验与评估5.1实验设置本文选取的单人游戏系统中包含大量可配置元素,实验主要关注游戏中物体特征配置和物体行为配置,并且本实验仅讨论包含两个静止物体和两个移动物体的情况,因为这种情况已经足以表达物体与边界之间、静止物体之间、移动物体之间、以及静止物体和移动物体之间的各种关系.游戏背景通过背景的长、宽、颜色定义,为固定值,即L=800,H=600,Color=Blue.静止物体和移动物体的配置参数分别如表4和表5所示.静止物体S1S2移动物体横坐标纵坐标长度宽度颜色速度方向M1M2ELSEs1hasonelevelActionENDIFFOR(eachsi(1<i<n))sihasthreelevelsAftersENDFORIF(AEisnotnull)THENsnhastwolevelsAEandELSEsnhasthreelevelsAftersENDIFUsingcombinatorialtestingmethodtoconstructaction对起始动作和终止动作均有特殊要求的被测系统,动作序列的因素水平定义如表3所示,对于具体的因素水平定义选取合适的正交表来安排动作序列.Action-Afters5.1.1不考虑约束条件的实验设计本实验以正交试验设计方法为例,考察在不考虑约束条件的情况下,生成测试数据的质量和效率.传统的正交试验设计直接将参数及其可能的取值作为组合测试考察的因素,参数可能的取值必须是有限个,并且数量尽可能少.本研究的被测系统中有多个参数的取值是某一规定范围内的正整数,虽然是有限个,但数量巨大,因此无法直接将参数取值作为组合测试的因素.对于这类参数,本研究将取值区间作为组合测试的因素,将配置参数根据静止物体和移动物体分为两类进行测试生成.静止物体各参数的合法取值区间如表6所示,两个静止物体相关参数的可能取值如表7所示,其中非法取值以从非法区间中选取的两个具体数值作为代表.合法取值区间[0,800)[0,600)(0,800](0,600]利用正交表L12(28)安排表7中的参数及其取值,共生成12组区间组合.在生成参数具体取值时,Page9表7两个静止物体相关参数可能的取值12如果遇到参数取值为区间时,则从该区间随机选取一个值作为测试数据.分别为每组区间组合生成8组测试数据,共为静止物体生成96组参数取值.移动物体各参数的合法取值区间如表8所示,两个移动物体相关参数的可能取值如表9所示.表9两个移动物体相关参数可能的取值[0,800)12-10/810-10/610-10/810-10/6103利用正交表L36(28×32)安排表9中的各参数及其取值,共生成36组区间组合,为每组区间组合生成8组测试数据,共为移动物体生成288组参数取值.5.1.2基于约束组合的实验设计MTA-AGM游戏系统对租户的配置行为有以下的约束条件限制:(1)S1在边界内:(0xs1<800)∧(0ys1<600)∧(0<ls1800)∧(0<hs1600)∧(0<xs1+ls1800)∧(0<ys1+hs1600).(2)S2在边界内:(0xs2<800)∧(0ys2<600)∧(0<ls2800)∧(0<hs2600)∧(0<xs2+ls2800)∧(0<ys2+hs2600).(3)S1与S2不重叠:a,b,0als1,0bhs1,((xs1+a<xs2)∨(xs1+a>xs2+ls2))∨((ys1+b<ys2)∨(ys1+b>ys2+hs2)).(4)M1在边界内:(0xm1<800)∧(0ym1<600)∧(0<lm1800)∧(0<hm1600)∧(0<xm1+lm1800)∧(0<ym1+hm1600).(5)M2在边界内:(0xm2<800)∧(0ym2<600)∧(0<lm2800)∧(0<hm2600)∧(0<xm2+lm2800)∧(0<ym2+hm2600).(6)M1与M2不重叠:a,b,0alm1,0bhm1,((xm1+a<xm2)∨(xm1+a>xm2+lm2))∨((ym1+b<ym2)∨(ym1+b>ym2+hm2)).(7)M1的运动方向有3种:水平方向、垂直方向和其他方向.(8)M2的运动方向有3种:水平方向、垂直方向和其他方向.(9)由于物体颜色对本实验结果的影响非常有xs2[0,800)-10/810合法取值区间xm2[0,800)-10/810-10/610-10/810-10/610限,因此将所有物体的颜色均设置为白色.约束条件1~6均为布尔类型约束条件,约束条件7和8为枚举类型的约束条件,分别包含3个可选取值,约束条件9为固定值约束,在测试生成时将该约束条件中定义的配置参数设定为固定值即可.上述约束条件中包含多个配置参数,直接为这些参数生成约束依赖图将会大大增加运算复杂度,因此我们提高了约束依赖图的抽象层次,以物体为单位构造约束依赖图,如图3所示.根据图的连通性将该图划分为两个子图G1和G2,G1是关于静止物体的约束条件,G2是关于移动物体的约束条件.确定约束条件以及约束条件可能的取值后即可利用组合测试方法生成约束组合,并为每组约束组合生成配置参数的具体取值.本实验除了生成配置参数还要为物体设置Page10碰撞后的动作,移动物体动作集合为M-Action={verticalRevese,horizontalReverse,allReverse,M-appear,M-disappear},静止物体动作集合为S-Action={S-appear,S-disappear}.碰撞过程由两个物体参与完成,包括移动物体与静止物体的碰撞以及移动物体与移动物体的碰撞.物体碰撞后的动作是同时发生的,因此这些动作均为并行执行,动作配置约束条件仅针对移动物体与移动物体的碰撞,包括:(1)ParellelVertical={M-appear,verticalReverse,allReverse,M-disappear,S-appear,S-disappear}.(2)ParellelHorizontal={M-appear,horizontal-Reverse,allReverse,M-disappear,S-appear,S-disappear}.由于被测系统动作数量有限,并且动作之间的约束条件简单,因此可以直接为两个移动物体构造如表10所示的4组动作组合,移动物体与静止物体碰撞后的动作进行随机配置.verticalReverseverticalReversehorizontalReverse本实验将现有的组合测试算法应用于MTASaaS服务的配置测试中,直接将服务的约束条件作为算法的组合元素,为MTASaaS服务生成若干配置场景,与现有方法相比,本方法主要有以下几点创新:(1)传统组合测试通常应用于参数的生成,而本实验则扩展了组合测试算法的应用范围,不仅利用组合测试算法生成参数,还生成了服务的动作序列;(2)在处理服务约束条件方面也有所不同,现有算法主要分为两种:一种是在生成参数组合前考察约束条件,避免在生成过程中产生非法的参数组合;另一种是在生成参数组合后考察约束条件,用以剔除非法参数组合.而本实验则直接将约束条件作为组合测试算法的组合元素,参数的具体取值则是在约束组合的基础上利用模拟退火算法生成;(3)在生成参数取值时,本方法面临多条约束条件对参数的共同约束,因此将传统模拟退火算法的目标函数定义为多个子目标函数之和,每个子目标函数对应一条约束条件,总目标函数则对应于一组约束组合.5.2实验结果5.2.1对约束组合的覆盖比较游戏系统中静止物体和移动物体的参数约束条件组合均通过正交试验设计、IPO算法[6]以及one-row-at-a-time[7]算法生成,由于静止物体配置参数数量少、约束条件简单,因此3种算法生成的测试数据在数量、质量上均无显著差异.本文将着重分析上述4种算法为移动物体生成的配置参数对约束条件的覆盖情况.本节将系统的约束条件概括为以下4类:(1)物体是否出界;(2)两移动物体是否重叠;(3)两移动物体的运动方向组合约束;(4)两移动物体的碰撞动作组合约束.对比基于约束组合的3种组合测试方法和不考虑约束条件的正交试验设计方法生成的测试数据,能够得出如下结论:(1)传统的正交试验设计方法生成的测试数据数量最多,基于约束组合的正交试验方法次之.在基于约束组合的3种测试方法中,正交试验设计方法生成的测试数据数量远远大于其他两种组合测试方法,大约是其他两种方法测试数据数量的2.4倍,因为正交试验设计除了要满足强度为2的组合覆盖要求,还要满足正交性等特有的要求.传统正交试验设计方法生成的测试数据数量最多,但其中有效数据的数量非常有限,仅占全部测试数据的13%.(2)对单一约束条件的覆盖能力基本一致.基于约束组合的测试方法均能覆盖上述4种约束条件的各种取值情况,约束条件覆盖率为100%;传统正交试验设计方法能够覆盖运动方向组合约束中的5种情况以及其余约束条件的所有取值情况,约束条件覆盖率约为93%.这4种方法生成的测试数据与单一约束条件的覆盖能力对比如表11所示.(3)对约束组合的覆盖能力相差较大.基于约束组合的3种测试方法对约束组合的覆盖能力明显优于传统正交试验设计方法,传统正交试验设计方法仅能覆盖50%的约束组合;基于约束组合的3种测试方法中,正交试验设计和one-row-at-a-time算法对约束组合的覆盖能力优于IPO算法,前两种方法均能覆盖100%的约束组合,而IPO算法仅能覆盖75%的约束组合.约束组合的覆盖能力对比如表12所示,各约束组合的含义为:Page11表11对单一约束的覆盖约束条件1234约束组合1234(verticalReverse,horizontalReverse)(horizontalReverse,ParallelHorizontal)①组合1:两物体均在界内,不重叠,运动方向组合为(other,other)、(horizontal,other)或者(vertical,other),碰撞动作组合为(verticalReverse,allReverse)或(horizontalReverse,allReverse);②组合2:两物体均在界内,不重叠,运动方向故障类型子故障类型表13被测系统配置故障类型(1)参数配置故障(2)行为配置故障个移动物体的碰撞行为Rerverse时,就会发生故障Rerverse时,就会发生故障基于约束组合的测试IPO54数量83016223210612222214101020组合为任意组合,碰撞动作组合为包含动作appear的任意动作组合;③组合3:两物体均在界内,重叠;④组合4:两物体均在界内,不重叠,运动方向组合为任意组合,碰撞动作组合为(verticalReverse,horizontalReverse).5.2.2对错误检测能力的比较针对被测系统的参数配置和行为配置,我们将配置故障进一步划分为以下7类,表13列出了MTA-AGM系统可能的配置故障及其在被测系统中的具体表现.Page12(1)参数配置故障类型.定义如下3种故障类型,{PFi|i=1,2,3}:①PF1违反对单个配置参数的取值约束.例如物体的坐标超出了系统对其约定的取值范围;②PF2违反多个配置参数之间的约束条件.例如判定物体是否出界的约束条件中就包含了多个配置参数,有物体的横坐标、纵坐标、物体长度以及物体宽度等;③PF3违反系统约束.例如,要求每个游戏实例必须包含一个可控移动物体,如果游戏中不包含可控移动物体,则该游戏无法进行.(2)行为配置故障类型.定义如下4种故障类型,{BFi|i=1,2,3,4}.①BF1动作绑定故障.系统将动作绑定到错误的物体,例如,对于两个发生碰撞的物体A和B,将A碰撞后的动作设置为verticalReverse,B碰撞后的动作设置为allReverse,但由于配置系统故障,将动作verticalReverse错误的绑定到物体B,而且将动作allReverse绑定到物体A;②BF2两个发生碰撞的移动物体的动作配置冲突.例如,对于两个发生碰撞的移动物体A和B,如果A的碰撞动作设置为verticalReverse,则B的碰撞动作就不能设置为horizontalReverse;③BF3动作配置违反物体行为约束.例如,物体碰撞动作受到碰撞面的约束,当物体的碰撞面为左/右侧面时,动作不能设置为verticalReverse,否则游戏将出现运行故障;④BF4动作配置违反系统约束.例如,可控移动物体在碰撞之后的动作不允许设置为disappear,否则游戏将无法继续.仅覆盖单一约束条件的测试数据能够发现的故障类型比较简单,而复杂的故障则要利用能够覆盖约束组合的测试数据来发现.例如表13中的故障(2.1.1)、(2.1.2)要利用能够覆盖约束组合1的测试数据才能发现,故障(2.3.3)由能够覆盖约束组合2的测试数据发现等等.测试数据故障检测能力的差别主要由对约束组合的覆盖能力引起,基于约束组合的正交试验设计和one-row-at-a-time(ORAT)算法均能发现上述15种系统故障,IPO算法能发现11种系统故障,传统正交试验设计只能发现9种系统故障,4种方法的故障检测能力对比如图4所示,分别为100%、73%、100%以及60%.5.2.3算法复杂度分析被测服务约束模型中包含k个参数p1,p2,…,pk以及m条约束条件c1,c2,…,cm,约束条件ci中包含的参数个数用|ci|表示.数据约束依赖图构造算法首先为每个参数和每条约束条件生成相应的节点,共生成m+k个节点.然后为每个约束节点添加边,每个约束节点的边的数量为该约束条件中包含参数的个数,共添加∑多包含k个参数,因此该算法的时间复杂度最多为O(m×k).正交试验设计方法的优势是正交表均已计算完成,可以直接使用,目前已有工具可以自动将确定好的实验因素、水平映射到正交表中,列出实验方案,但实验因素和水平的确定,以及正交表的选择仍需人工手动完成,难以实现自动化.正交试验设计对实验因素及其水平个数的要求也比较严格,并不是所有测试均能利用该方法.IPO算法和one-row-at-a-time算法则能够实现自动化计算,对于m条约束条件,假设这些约束条件均为布尔类型,则每条约束条件均有2个可能的取值,则生成约束组合时,IPO算法的时间复杂度为O(23m2log(m)),one-row-at-a-time算法的时间复杂度为O(24m2log(m)).对于已生成的约束组合,假设共有M组约束组合,每组约束组合中包含m条约束条件,布尔类型的约束条件ci中包含λi个项,则每组约束组合的目标函数中将包含m个子目标函数,对应于约束条件ci的子目标函数共有λi种定义方法,因此目标函数定义算法的时间复杂度最多为O(M×∑5.3局限性分析(1)约束的正确性、完整性和一致性本方法的一个前提条件是能够获取相应的领域Page13知识,以建立被测系统正确、完整、一致的约束模型,领域知识的完整性和正确性是保证约束模型质量的基础.完整准确的约束模型能够提高测试生成的质量和效率,从而更全面的发现系统的隐藏错误.然而,由于领域知识目前存在多种不同的描述形式,并且其内容的完整性和准确性也难以保证,因此领域知识的获取和被测系统建模仍然是一个需要大量人力投入的过程,难以实现自动化,被测系统的模型质量在很大程度上依赖于测试人员的经验和技术水平,尤其对于大规模系统,此问题更加突出.(2)生成算法的复杂度通常情况下,系统的某个特性由多个参数共同决定,这些参数之间通常存在多种约束依赖关系,而描述不同特性的参数之间一般不存在约束依赖关系.因此,对于有大量配置参数的系统,根据参数之间是否存在约束依赖关系能够将参数分为多个参数组,属于同一组的参数之间存在约束依赖关系,而不同组的参数之间不存在约束依赖关系.这样,在生成参数取值时能够更有针对性的考察约束条件的满足情况,并且分组后,每个参数组中包含的参数数量少,约束条件相对简单,所以,能够保证参数取值的生成效率和质量.如果被测系统包含大量参数,并且这些参数之间存在错综复杂的约束依赖关系,难以分组,测试生成时需要考察的参数及约束条件的数量就会大大增加,从而提高算法的复杂度,严重影响测试生成的效率和质量.6相关工作6.1SaaS测试技术多租户体系架构使得SaaS软件的用户量有了前所未有的增长,基于庞大的用户群,SaaS软件也具有了相当可观的规模和复杂度,同时也为SaaS软件测试带来了新的挑战[8].SaaS应用软件的测试技术不同于传统的软件测试,云计算减少了软、硬件的投入,能够降低SaaS测试的成本;SaaS软件测试需要实现自动化持续在线测试,并且具有一定的可扩展性,能够满足多租户需求[9].文献[8]提出在传统软件测试领域,软件测试活动通常在所有开发活动全部结束后才开始.但是,这样的开发-测试模式显然无法满足快速发展的SaaS以及MTA的需求.因此,该文献提出一种双层数据库分区技术来支持SaaS定制需求,并利用元数据的约束作为测试用例来实现SaaS软件的持续测试.文献[9]则介绍了几种现有的SaaS可扩展性测试的评价标准,并提出了一种新的评价标准,结合该标准和数据挖掘技术实现了SaaS的可扩展性测试.Salesforce.com作为软件即服务(SaaS)的先驱,首先为用户提供了按需CRM服务.在提供按需开发服务的同时,为确保服务质量,Salesforce.com也需要为开发者或用户提供按需服务平台的测试方法.按需服务平台的测试需要解决以下3个主要问题:(1)用户定制的正确性;(2)应用程序的正确性;(3)应用程序新版本的正确性.Force.com提供了一种Apex测试框架,这种测试框架能够实现自动化单元测试以及自动化功能测试[10].6.2组合测试技术在组合测试中,采用覆盖率标准来评价测试的完备性.对于有n个参数的被测服务,强度为t(1tn)的覆盖要求生成的测试用例能够覆盖任意t个参数的所有取值组合.在定义覆盖率标准时也可以加入参数语义信息,并且在组合测试时对合法取值和非法取值区别对待[11],根据测试需求为合法取值和非法取值分别定义覆盖率标准.范畴(category)划分测试方法[12]针对被测系统每个能够单独测试的功能单元,将参数和环境变量的范畴划分成多个选择(choice),通过组合这些选择为被测单元生成测试用例.分类树方法[13]是针对黑盒测试提出的一种测试方法,该方法借鉴了范畴划分方法的思想,并对其进行了改进,将测试相关信息组织成树形结构.以分类树为表头建立组合表,选择不同的叶节点组成测试用例.Cohen等人[11]将所有参数随机排序,按照参数顺序依次为参数赋值,要求所选取值能够覆盖最多未被覆盖的组合,从而生成满足某种覆盖率要求的测试数据.IPO算法[6]为被测服务的前两个参数生成所有取值组合,并在此基础上分别进行横向和纵向扩展生成满足两两覆盖的测试用例集.IPOG算法[14]是对IPO算法的改进,能够为被测服务生成满足覆盖强度为t(t>2)的测试用例集.Mandl[5]首次将正交拉丁方引入软件测试领域,应用正交拉丁方为测试Ada编译器生成测试数据,并达到两两覆盖标准.Williams等人[15]介绍了正交拉丁方的构造方法,并提出了正交拉丁方适用Page14范围的要求:(1)所有参数的取值数量相同;(2)参数之间不存在依赖关系;(3)对于相应的参数数量和取值数量存在足够的正交拉丁方用以构造测试.但在实际应用中,以上要求均难以满足,因此Williams等人通过为较少取值的参数增加重复取值以及对参数取值进行组合来扩展正交拉丁方在软件测试领域的适用范围.在正交数组的基础上,Williams[16]提出了覆盖数组的构造方法,通过对小型的正交数组进行相应的运算能够获得基础数组以及简化数组,对原始正交数组、基础数组以及简化数组进行适当的组装得到覆盖数组,覆盖数组能容纳几倍于正交数组的参数,并能够达到两两覆盖的要求.传统组合测试的目标是尽可能多的发现由参数交互作用引起的服务失效[7],但在参数组合时却恰恰缺少对参数之间交互作用的考察和应用,因此难以保证测试生成的质量.本文没有直接利用传统的组合测试方法来生成测试数据,而是提取系统参数的约束条件,生成约束组合,并在约束组合的基础上生成参数取值.该方法在生成测试数据时目标明确,因此提高了测试生成的效率和质量.在实验设计中,采用了正交试验设计方法、IPO算法以及one-row-at-a-time算法等.由于参数之间的约束依赖关系是测试数据生成的一个重要因素,如果在组合测试中忽略这些约束条件,则会生成大量无意义的测试数据.文献[17]利用断言(genericpredicate)定义两个参数的取值组合,利用约束条件检验断言,找出不合理的取值组合.文献[18]在输入参数模型的基础上介绍了几种处理参数约束的方法,抽象参数法和子模型法都是在构建输入参数模型时去除所有可能的冲突.对于逐个选取参数取值的组合方法,文献[19]将非法的取值组合标记为已覆盖组合,从而在构建测试用例的过程中避免了对非法取值组合的选取.也可以在测试用例生成完成后,将不合法的测试用例用合法的测试用例取代.文献[20]将参数约束条件分为硬约束和软约束,该方法根据约束条件为测试用例定义优先级,优先级高的测试用例会得到优先测试的机会.现有对约束条件的处理技术均是在参数取值离散并且取值个数较少的情况下,采取一定的措施避免选择到不合理的参数取值组合,对于参数取值连续、取值数量巨大的情况,缺少相关讨论和研究.在对被测服务或软件进行鲁棒性测试时,非法的参数取值和取值组合同样会起到非常重要的作用,因此在测试数据中包含一定数量的非法数据是非常必要的.本文利用参数之间的约束依赖关系来指导参数取值的生成,布尔表达式是这些约束条件的主要形式之一.目前在布尔表达式测试领域已有许多成熟的策略,例如多重唯一真点策略(MultipleUniqueTruePoint,MUTP),唯一真点和邻近假点对策略(CorrespondingUniqueTruePointandNearFalsePointPair,CUTPNFT)[21],多重邻近假点策略(MultipleNearFalsePoint,MNFP)[22]以及MUM-CUT[22]策略等.在本文的实验设计中,当遇到布尔表达式类型的约束条件时,将采用MUTP策略生成相应的测试数据.7总结配置测试是验证多租户系统能否正确应对配置过程中各种突发情况的有效手段,本文通过对多租户系统的分析、研究,总结了多租户系统的故障模型,并提出了一种多约束组合的配置测试方法,对约束条件进行组合测试,并在此基础上生成满足约束条件的测试数据.实验结果表明,该方法能够有效发现参数配置以及系统行为配置方面的多种配置故障,且可从约束条件覆盖率和故障检测率两方面提高测试效率.
