Page1基于犽近邻最弱前置条件的程序多路径验证方法1)(华中农业大学信息学院武汉430070)2)(武汉电力职业技术学院电力工程系武汉430079)3)(软件工程国家重点实验室(武汉大学)武汉430072)4)(佐治亚理工学院计算机科学系亚特兰大30332美国)摘要程序多路径验证方法是对软件性质进行发掘的重要方法之一,现有的验证方法主要通过求解路径条件或者自动构造不同的输入来触发生成不同的路径,从而分析程序中潜在的安全问题,但存在对路径条件不加选择地进行多路径扩展而生成缺乏针对性的路径的问题,另外由于路径条件过长而难以求解也限制了它的使用范围.该文提出基于k近邻最弱前置条件的程序多路径验证方法,该方法通过后向符号分析对程序调用图的构建过程进行改进,同时对指定的程序检测点生成最弱前置条件,并以该最弱前置条件为引导信息使用符号执行的方法在保证检测点可达的前提下有针对性地生成对程序性质进行验证的精简路径集合.实验结果表明,该方法可以提高程序验证的精度和准确性,并减少误报.关键词程序验证;静态分析;最弱前置条件;符号执行;控制流图1引言程序分析的目的是为了验证系统代码是否满足给定的安全准则,以达到对程序所具有的性质进行验证的目的.传统的人工分析方法由于效率较低且容易出现误报和漏报等现象,故自动化的程序验证方法和错误检查方法成为当前主流的研究方向,如定理证明[1]、约束求解[2]、模型检验[3]等.程序验证的重点是对程序属性的分析,例如程序中某条语句是否可达,多线程程序中是否存在竞争或互斥等逻辑属性.目前程序属性验证工具的主要目标是判断程序中是否存在违反待验证属性的执行路径,即判断该工具是否会生成对应的反例程序.路径可行性判定问题是程序验证中的重要问题[4],它指的是对于一条指定的程序执行路径,通过符号执行[5](SymbolicExecution,SE)和约束求解等方法判断该程序的输入变量是否存在一组初始取值,使得程序能够沿着该路径执行.由于属性验证工具大多都采用对源代码进行抽象的方法来生成反例,故源代码对应的抽象模型会直接影响到反例的正确性.最弱前置条件[6](WeakestPrecondition,WP)作为一种后向符号分析方法(BackwardSymbolicAnalysis),能够可靠地对程序的执行语义进行建模,并减小静态分析过程中对程序状态进行抽象操作所带来的验证精度上的损失.但最弱前置条件分析在实际应用过程中,往往由于程序对应的控制流图(ControlFlowGraph,CFG)规模较大,其路径条件的解空间与程序分枝数量呈指数关系,即存在路径搜索空间爆炸的问题.此外最弱前置条件在计算过程中依赖循环变量,故可能存在死循环等问题影响验证的效果.目前程序多路径分析与验证存在的主要问题是分析效率较低,在分析过程中容易产生大量不可达或不能对性质进行验证的无用路径,同时大多数分析方法仅用求解器对路径约束条件进行优化求解,缺乏对程序检测点和路径条件之间关联关系的深入研究,导致由于没有足够的路径引导信息而产生较多缺乏针对性的程序执行路径,从而降低对性质进行验证的精度与效率.本文针对以上问题,以程序路径的可满足性为研究对象,提出k近邻最弱前置条件(kWP)的多路径程序验证方法:在分析过程中不立即对路径条件进行求解,而是加入后向符号分析所生成的路径信息,当遇到程序的检测点的时候,根据路径信息有针对性的生成执行路径并进行筛选,从语义上对路径表达式进行简化与合并,减少待分析的路径数量,并减少求解器的误报与漏报.具体的过程是通过对程序的控制流图进行改进,消除循环结构,使得每条执行路径都可以表示成惟一的语句串;通过引入因子k,可以得到一个与待分析的路径的编辑距离(EditDistance)不超过k的路径集合,对该集合中的每条路径进行kWP运算并对运算结果进行析取操作,这样就可以得到对输入变量的一个近似的取值,通过不断优化调整k的大小,可以得到更为精确的变量输入值,从而引导程序执行到待验证的检测点,并减小路径空间爆炸在程序验证过程中所带来的影响,故kWP是对传统的最弱前置条件的一种近似.基于kWP的路径可行性问题是需求驱动(demanddriven)的,符号分析的结果可以及时反馈于符号执行过程中的程序分支路径的选择,故与传统的符号执行相比,本文的方法在路径搜索过程中有更强的针对性.本文的主要贡献是:(1)在程序调用图的构建过程中加入后向符号分析,使得后向符号分析的结果能够引导程序调用图的构建,从而避免生成与待验证性质无关的程序调用图,提高验证的精度与效率.(2)提出基于k近邻最弱前置条件的程序多路径分析方法,通过计算程序中断言的最弱前置条件并调整k的取值,从而生成有针对性的可行路径并对待验证的性质进行判定.本文第2节介绍与论文相关的概念,给出最弱前置条件和过程间程序调用图的计算方法;第3节给出kWP的形式化定义和k近邻路径生成算法;Page3第4节从输入域的角度对本文方法的有效性进行证明,并给出本文方法的分析过程;第5节介绍实验环境和系统的框架,并对基准测试集的结果进行分析;第6节给出相关研究进展和对比;第7节总结全文并展望下一步研究工作.2最弱前置条件的生成方法定义1.控制流图(ControlFlowGraph,CFG).程序的控制流图是由节点和边组成的有向图,可以形式化地表示为〈N,E〉.其中N是节点的集合,每个节点代表程序中指定位置的语句,边的集合EN×N表示程序在执行过程中节点间可能的流向.定义2.CFG路径的可行性.它表示为N×N→{T,F}的计算过程,对于一对节点(ni,nj),若存在一个节点序列π·E,其中0k|π|-1,n0=ni,n|π|-1=nj,那么这一对节点之间存在可达的路径;反之若不存在节点序列,则表示不存在可达路径.用(n0,n1,…,nk]表示所有以n0的后继节点为起点,以nk为终点的路径;用[n0,n1,…,nk)表示所有以n0为起点,以nk的前驱节点为终点的路径,使用|π|表示当前路径的长度.定义3.路径条件(PathCondition).它是在控制流迭代过程中产生分支路径的数据流值.在CFG中,新的路径只会在条件语句与循环语句的判断条件处产生,故在CFG中节点的路径条件为此处条件分支或循环分支的约束所组成的一阶逻辑公式(First-OrderLogic,FOL).在本文方法的分析过程中,可以将CFG的表示形式扩展为〈N,E,Ninfea,φ〉.其中Ninfea表示程序的可行路径不能到达的节点的集合;φ表示待验证路径所表示的状态,即断言的集合.程序从CFG的起始节点开始,依据路径的可行性定义运行到待验证的位置,若要验证程序在该处的断言φ成立,则需要验证程序以不同的执行路径达到该处时,该断言φ都要成立.定义4.静态单赋值(StaticSingleAssignment,SSA).静态单赋值是程序的一种中间表示(IR)形式,在程序中若出现了对变量a的多次赋值,即该变量存在多处定义,则通过对变量a采用下标的方式(a0,a1,…)来区分a在每处的定义,同时在程序的控制流图中加入一个φ函数节点:a=φ(a0,a1,…),使得每个变量ai均有惟一的一处定义,同时变量ai也只有惟一的一条到达该定义的路径.在计算过程内最弱前置条件之前,需要将程序转换为其对应的静态单赋值形式,使得程序的过程内控制流图中每一个基本块(BasicBlock)最多代表一条语句,同时过程内控制流图拥有惟一的入节点(Entrynode)和出节点(Exitnode).静态单赋值操作可以有效地区分程序中的变量与其存储位置,使得程序控制流图中每条边代表一次路径条件的运算过程,若程序中存在异常退出等情况,则有一条指向出节点的边,以提高后向符号分析的效率.定义5.最弱前置条件(WeakestPrecondition,WP).它是保证程序中一条语句正常执行并满足结果断言(后置条件)的限制最小的前提条件.它表示为一组谓词公式:WP(S,R),其中R是语句S执行后所期望的结果断言.在证明程序正确性过程中,以程序的执行结果作为最后一条语句的后置条件,通过该后置条件和最后一条语句可以计算出最后一条语句的最弱前置条件,以此类推到程序的开始,第一条语句的前置条件即为满足结果断言所需的条件.若该条件包含在程序的输入中,则可证明程序是正确的.表1列举了程序中常见类型语句的最弱前置条件的转换方法,当过程内控制流图中的节点有出边的时候就需使用该转换方法.其中φ[s1/s2]表示使用语句s2去替换语句s1,谓词get和set分别表示获取和设置变量的值.语句sv=uv=u1opu2v=u.mv.m=uu[i]=v(u≠null)∧(i0)∧(i<get(length))∧φ[v/get(u,i)]v=u[i](u≠null)∧(i0)∧(i<get(length))∧φ[get(u,i)/v]v=(T)vassumev算法1是过程内最弱前置条件的生成算法.对于程序中的每一条语句s和它对应的后置条件φpost,该算法计算过程内控制流图中每个节点的符号状态的集合S,并对结果进行简化(simplify),同时在其基础上进行合并(merge)操作.简化操作是基于最弱前置条件所具有的析取性质:WP(s,φ1∨φ2)=WP(s,φ1)∨WP(s,φ2).它是状态集合中被选取的条件的析取范式(DisjunctiveNormalForm,DNF).Page4下面给出该算法所采用的合并策略,即对当前的符号状态进行重写操作,例如merge(φ∧a,φ∧a).其中谓词get可同时用来判断数组是否出现越界现象,谓词typeOf与subType用来处理程序的类型判断与类型转换语句.此外在合并过程中还使用了常量折叠(constantfolding)的分析方法,该方法作为程序优化中的一种技术可以将程序中的常量表达式存入常量表,以减少最弱前置条件计算过程中求解器对常量表达式的计算求值次数,同时该方法可以增加程序中需要多次被调用的过程的分析结果的重用率.算法1.过程内最弱前置条件(WPintra)的生成算法.输入:CFG,φpost输出:intraproceduralweakestprecondition1.varF:{Formula}←Statement;2.varList:pairof(Statement,Formula);3.s∈Statement,F(s)←;4.List←{(ExitNode,φpost)};5.WHILEList≠DO6.(s,φpost)←selectfromList;7.WHILE(s,s)∈EofCFGDO8.φpre←merge(F(s),simplify(WP(s,φpost)));9.IFφpre≠falseTHEN10.F(s)←F(s)∪φpre;11.List←List∪(s,φpre);12.ENDIF13.ENDWHILE14.ENDWHILE15.RETURNF(EntryNode)对于过程间的最弱前置条件WPinter,本文采用上下文敏感的分析方法,其过程间控制流图(ICFG)由多个过程内控制流图连接而成.对于一个调用v=u.f(…)(此处省略其参数列表),WPinter首先将条件φpost映射到被调用的函数f(…)的命名空间,得到函数f(…)在出节点ExitNode处的分析结果,然后通过上述过程内最弱前置条件算法WPinter获得函数f(…)在入节点EnterNode处的最弱前置条件φpre,即产生从后置条件到前置条件的一个映射:φpost以引导程序获得出节点ExitNode处的后置条件φpost,最后不断通过过程内控制流图的传递计算出控制流图的前置条件φpre.在得到过程间最弱前置条件的基础上,由于程序中存在大量的过程调用,此时若直接依据过程间的关系生成调用图,则会产生较多无用的调用关系,影响程序验证的效率.本文在过程间最弱前置条件生成过程中,使用后向符号分析的结果来引导程序调用图的构建,从而生成与待验证的兴趣点相关联的过程调用图.算法2.带过程间最弱前置条件(WPinter)的程序调用图生成算法.输入:CFG,φpost输出:callgraphunderWPintercallGraphWithWP(CFG,φpost)1.varCG←WPinter(CFG,φpost);2.varCG←{cg∈CG|cgcanbesolved};3.IFCG=4.FOREACHm∈CGDO5.selectonemethodfromm;6.selectssubroutinesinmethod∧7.IFsdoesnotexist8.CONTINUE;9.ENDIF10.CFG←CFG+s;11.RETURNcallGraphWithWP(CFG,φpost);12.ENDFOR13.ELSE14.RETURNCG;算法2中第4~11行通过判断过程内控制流图的函数调用关系来扩展程序中的调用关系,并使用递归运算得出与兴趣点相关的程序调用图.由于该精简的调用图删除了与待验证性质无关的函数调用集合,故可以在此基础上生成有针对性的路径验证集合.图1表示一个程序片段(图1(a))以最弱前置条件为引导信息的程序验证过程.程序第10行存在一条断言语句,若该语句被触发即表示验证过程失败.文献[7]指出:若程序中一条具体的执行路径不可行,那么其临近路径也是不可行的概率较高.本文据此理论采用后向符号分析方法,使用最弱前置条件和断言得到的具体执行路径来构建有限符号分析树,并生成与此路径临近的尽可能多的可行路径来Page5图1带最弱前置条件的符号分析树对程序进行验证.在最弱前置条件的计算过程中的两个主要的规则表示如下:WP(x·WP(if(c)s1elses2,Q)=图1(b)~(d)表示该程序片段所对应的符号分析树,程序中()表示该处的验证条件可能为true也可能为false,在分析过程中主要的问题就是如何使用这些规则来产生路径条件对应的合取公式.在符号分析过程中,求解器会在每一个分支位置对路径条件进行计算以删除那些冗余的或者不可解的路径条件.图1(b)表示后向符号分析的第1阶段,其中在每个节点处加入了最弱前置条件:τ1:s06;τ2:s06;τ5:s17;τ6:s17;τ9:s28,例如τ6:s17可以通过WP(s2=s1+1,s28)计算得出,注意此处采用了SSA方法的表达形式.图1(c)表示后向符号分析的第2阶段,在第9行由于符号状态s0=0∧s1=s0+1∧s2=s1+2→s28,故在此处可以使用上述simplify与merge操作来对路径分析的结果进行约简,其中虚线箭头表示被包含的路径.类似地,在图1(d)中由于(s0=0∧s1=s0+2)→s17,故通过该分析方法之后,符号分析树的规模与分支的数目呈线性关系,有效地减少了分析空间的规模.3犽近邻路径生成方法设程序Prog在其对应的过程间控制流图中的执行路径为集合Paths,为了验证Prog的可达性,需要在程序中待分析的检测点设置断言φ,通过计算φ与此处的路径条件(PathCondition,PC)的逻辑包含关系来对Prog进行验证,PC是程序能执行到此处的由约束条件所组成的一阶逻辑公式.定义6.编辑距离(EditDistance).它是指两个串(S,T)之间,由一个串通过替换、插入、删除操作转换成另一个串的最少操作次数.在实际应用过程中,常采用动态规划的方法来计算编辑距离,其动态规划公式为(1)i==0&&j==0,edit(i,j)=0;(2)i==0&&j>0,edit(i,j)=j;(3)i>0&&j==0,edit(i,j)=i;(4)i>0&&j>0,edit(i,j)=min(edit(i-1,其中edit(i,j)表示S的子串[0…i]到T的子串[0…j]的编辑距离,f(i,j)表示S中第i个字符S[i]转换到T中第j个字符T[j]所需要的操作次数,若S[i]==T[j],则f(i,j)=0;否则f(i,j)=1.本文使用编辑距离计算两条执行路径的相似度,因子k用来指导生成一个与当前分析路径l相似的路径集合L,其中每条路径与l的编辑距离相差不超过k,显然LPaths:其中算子△用来计算待分析的路径与当前生成的路径之间的编辑距离.kWP的定义如下:kWP:{(s,pc,path,k)∈Prog×PC×Paths×k→PC}.上式所得到的是经最弱前置条件计算后的更新的路径条件集合,通过SMT求解器[8]可得到路径l所对应的输入变量的近似值.对于程序中常见的循环语句,其执行路径在过程间控制流图中表示为一个带回边的节点集合.图2是一个带循环的控制流Page6图及其对应的消除循环节点的控制流图CFG.图中每条边都有一个符号与其对应,这样每条执行路径都有一个特定的符号串,即该路径的编码.对于循环体执行n次的某条执行路径,其路径编码可以记录为CFGn,显然CFGn是CFG的一个子图.算法3是计算与指定路径的编辑距离不超过k的执行路径集合的生成算法.图2循环结构过程间控制流图及其ICFG形式算法3.k近邻路径生成算法.输入:k,ICFG,l输出:Pathswithkdistancetol1.G←reverseArcs(ICFG);2.l←reverse(l);3.Paths←;4.q.append(l[0],〈〉);5.WHILEq≠DO6.〈v,p〉←q.dequeue();7.IF(v=l[|l|-1])∧(△(p,l)k)THEN8.Paths←Paths∪{p};9.ENDIF10.index←min(|p|-1,|l|);11.IF△(p,l[0,index])2kTHEN12.p.append(v);13.selectnfromV;14.q.append(〈n,p〉);15.ENDIF16.ENDWHILE17.RETURNPaths其中算子△用来计算两个路径串之间的编辑距离,对于一条执行路径l,变量|l|表示l中节点的个数,l[i,j]是路径l的子串(0i<j|l|-1),l[|l|-1]表示l中最后一个节点.该算法通过对参数ICFG所表示的控制流图和待分析的执行路径的指向进行翻转,若生成的执行路径与l的编辑距离不超过2k,则不断扩展搜索的路径,在能够到达程序入节点的路径中,若k的值不能更小,则保留该执行路径.故对于距离执行路径l的编辑距离不超过k的路径集合中,存在对应的CFGn.值得注意的是该算法可能生成不可达的执行路径,例如程序的循环次数超过了设定的一个阈值,那么在随后的符号分析过程中,符号执行工具所采用的求解器会对当前的谓词集合进行求解以确定其可满足性.例如对于α<3∧α=5这样谓词集合不存在解,故对应的条件在传递到下一个节点前会被删除.对于最后所生成的可执行路径集合L,其kWP是各路径最弱前置条件的析取:kWP(Prog,PC,Paths,k)=∨当k=0时,kWP对当前待分析的路径进行分析;随着k的增大,算法3将会生成越来越多的符合条件的路径.在k→的情况下,kWP的计算方法与传统最弱前置条件的计算方法存在如下关系:kWP(Prog,PC,Paths,k)=WP(Prog,PC),limk→当k值发生变化的时候,算法会生成不同的路径集合,这样就需要在分析精度和分析的规模之间进行权衡,以获得最优的分析结果,本文的方法比传统的最弱前置条件分析方法能更加有效地获得反例程序.4犽WP的有效性为了验证本文方法的有效性,从路径可满足性的角度提出验证方法.对于程序Prog,其输入域为I,对应的值域为O,则程序可以表示为输入集合到输出集合上的映射I→O.对于输入i(i∈I),其对应的执行路径记为l,待验证的断言为φ,一条可满足的路径可以表示为Prog(i)φ.定义7.失效路径输入域Iinfea={i|i∈I,Prog(i)φ}.上节分析到kWP可能会生成不可达的路径,故使用Iinfea表示那些不能被满足或者不能到达指定位置的路径所对应的输入值.本文的方法生成与设定的因子k相关的路径集合,在此阶段可以不断调整k的取值,以发掘类似的可达路径集合.定义8.kWP可达路径输入域IfeaI\Ifea,Prog(i)φ}.本文可达路径输入域是在已知可满足的路径的基础上通过kWP计算得出的,其结果是对程序的可达路径输入域Ifea的一种逼近,显然Ifea这几种输入域之间的包含关系,IfeakWPIfea,理想情况下有IfeaPage7表示kWP生成的路径集合中那些无效的路径集合或者不能对性质进行验证的路径集合,在最后生成的可行路径集合中需要将该无效路径集合删除.在定义4中,记那些在kWP计算过程中对应输入i所生成的不可达路径为Pi定义9.kWP程序验证问题.设待分析的程序Prog,它的一条可执行程序路径l对应的输入为i,待验证的条件为φ,经kWP计算得到与l的编辑距离不超过k的路径集合及其对应的前置条件WP,对于其中的可达路径,以WP为引导条件对程序进行符号执行操作所得到的后置条件记为P,通过计算逻辑蕴含P→φ来判断路径的可满足性.对于k的不同取值所生成的路径集合,为了比较所生成的路径可行性的程度,可以对k的优化取值做出如下定义.定义10.k的优化取值问题.对于不同的k值所生成的可行路径后置条件Pk1、Pk2,以及所生成的不可行路径所对应的输入域Iinfeak2更加优化,当且仅当Pk1逻辑蕴含Pk2,且IinfeaIinfea2的子集,即k1k2(Pk1→Pk2∧Iinfea下面给出本文验证程序可行性所采用的计算方法:exeSE(Prog,kWP(Prog,PC,exe(Prog(i)),k)∧PC).(1)上式中的exe(Prog(i))函数表示以数据i为输入来执行程序Prog,获得指定的路径l;(2)kWP(Prog,PC,exe(Prog(i)),k)在计算过程中采用本文的方法生成与l的编辑距离不超过k的路径集合,并计算出最弱前置条件RWP;(3)最后使用RWP作为引导条件进行符号执行的操作,获得程序的后置条件P,通过计算路径可满足性验证条件δ:P∧PC来验证生成的路径的可达性,即采用逻辑蕴含的方法来判断P→PC是否成立,如果成立,则表示生成的路径是可达的;如果不成立,则可以生成一组对应的路径条件,表明当前的路径不可达,并生成相应的程序输入数据.定理1.程序过程内控制流图中一条可行路径l的起始节点和末尾节点分别记为nh和nt,在nt处待验证的断言为φ,若使用本文方法生成的路径可满足验证条件δ是不可满足的,则在程序的过程间控制流图中流经l的执行路径在nt处可使得φ成立.证明.本文计算路径可满足的验证条件δ是在nt处程序的路径条件pc与φ的合取操作:pc∧φ.若验证条件δ是不可满足的,则表示(pc∧φ)成立,即δ→(pc∧φ).依据命题逻辑可得(pc∧φ)pc→φ,故pc→φ也成立,即在程序的过程间控制流图中流经l的执行路径在nt处可使得φ成立.5实验与分析本文采用k近邻最弱前置条件和符号执行的方法来分析程序的路径可行性问题,通过比较kWP与传统的符号执行在发掘程序可行路径方面的数量与效率来验证本文方法的有效性.本文以WALA①作为实验平台,使用平台提供的T.J.WatsonLibraries作为程序过程内和过程间分析的工具,并构建程序的控制流图与调用图,在因子k的作用下生成待分析的路径集合,并使用CVC3工具[9]对本文算法1过程中所得到的路径谓词进行计算,保留那些可以求解的路径谓词集合,最后符号执行工具JavaPathFinder[10]以该谓词集合作为前置条件引导程序运行,并对路径的可行性进行验证.在实验过程中涉及到的验证性质包括缓冲区溢出、悬空指针、内存泄漏、类型状态属性等.实验的整体分析流程如图4所示.本文的实验环境是IntelCorei52.5GHz的CPU,内存大小为4GB,操作系统采用Ubuntu12.04,内核版本为3.2.0-24,Java运行时的版本为JRE6.①http://wala.sf.netPage8本文采用的测试基准程序集合来自DaCapo[11]和常见的开源JAVA程序,如表2所示.其中hedc和weblech分别是网络爬虫和网站下载工具,lusearch是文本索引工具,sunflow是照片渲染工具,avrora是微控制器仿真分析工具,hsqldb是一款关系数据库引擎,antlr是一款支持结构化文本和二进制文件的扫描器生成工具,batik是一个基于Java的支持可缩放矢量图的浏览器.这些程序的主要特点是规模较大,具有较多的分支语句和循环语句,可较为方便地设置待验证的断言并验证本文方法的有效性.测试程序hedcweblech2793167lusearch2934121sunflow5210371avrora4761423hsqldb3593287antlrbatik本文所提出的kWP方法由于是对最弱前置条件的一种近似,故k的值越大,其分析精度也越高,相应的时间开销也会越大,在验证程序路径的可行性方面,由于最弱前置条件是一种后向符号分析方法,故需要将kWP的结果反馈于符号执行工具,以引导其发掘可行性路径.本文的主要贡献在于通过使用kWP方法更加高效地通过当前的失效路径来发掘尽可能多的失效路径,而不用像单纯的符号执行工具那样去分析整个程序状态空间.在实验过程中,主要考察本文方法对符号执行工具在发掘可行路径方面的效率,主要考察指标为本文方法的运算时间以及因子k的取值对可行路径数量的影响.测试基准程序的相关信息如表2所示,其中圈复杂度[12](CyclomaticComplexity,CC)表示程序中判定节点的个数,它是一种代码复杂度的衡量标准,其值表示的是可行路径的条数,即为了验证程序的某个断言所需的最少路径条数.圈复杂度越大,表明程序可能存在的错误数量越多,从而其验证的难度也相对较大.圈复杂度的计算方法为CC(G)=e-n+2,其中e表示控制流图中边的数量,n表示节点的数量.断言表示程序中待验证的路径所到达的位置需满足的条件,即待验证的兴趣点.对于不同的断言,有一个对应的k值来表示对当前路径可行性的判定,表中kmax和kmin分别表示在待验证的断言集合中k的最大取值与最小取值,平均运行时间是在各自程序k的取值范围内对断言集合进行验证的运行时间的平均值,这样可以从整体上对比本文方法的时间开销.在图5中我们定义了加速比(SpeedupRatio)的概念,它表示在不同k值的影响下,对于当前待分析的一条失效路径,本文方法在发掘与其近邻的失效路径集合所使用的时间(TkWP)与直接采用符号执行的方法(TSE)所使用的时间的比值(TkWP/TSE).为了更加直观地体现本文方法的效果,对于每一个测试基准程序的不同兴趣点在同一个k值的约束下采用取平均值的方式来计算该处的加速比的值.从图可看出加速比的值域为(0,1),并没有出现加速比大于1的情况,表明本文的方法由于在路径搜索过程中加入了与失效路径相关的最弱前置条件,在发掘失效路径过程中消耗的时间较单纯的符号执行时间要少.加速比的值越小,表明时间开销也越少.从图5可以看出,加速比的值随k的取值的增大而增大,反映出发掘失效路径的时间开销会不断增加.尤其在k值较小的时候,加速比上升的幅度较快,当k的值逐渐增加,其加速比的值趋向于1,即表明本文方法的效率逐渐下降,趋向于单纯使用符号执行方法所得到的结果.这是由于随着k值的增加,最弱前置条件在计算过程中所分析的路径谓词也越多,根据本文第3节kWP与传统最弱前置条件之间的关系,其分析精度也趋向于单纯使用符号执行工具的结果.当k的取值较小的时候,加速比上升较快的现象反映出与失效路径的编辑距离较近的路径会较快地被符号执行工具检测出来,体现为加速比有较小的值,同时也验证了距离失效路径较近的路径其失效的概率也较高的结论.对加速比有直接影响的是程序内部的控制流结构的复杂程度以及数据流的对象数量,从本组实验可以看出程序lusearch的加速比值最小为0.73,即表明本文的方法相对于传统Page9的符号执行方法最多有0.73的加速比;而程序weblech的加速比值为0.91,其原因是程序中有较多的全局变量和环境变量作为路径分支的判断条件,对程序的控制流结构的影响较为明显.另外在kWP分析过程中,由于SSA对变量的重命名以及上下文敏感的分析过程导致产生了较多需要识别的新对象,从而对kWP的时间和空间复杂度带来了一定的影响,但是从图5中可以看出,由于kWP为符号执行工具提供了与待验证性质相关的路径引导信息,故能够对控制流结构以及数据流对象进行约减,使得加速比值能够小于1(TkWP/TSE<1),即表明本文的方法相对于传统的符号执行分析方法有更高的执行效率.图6表示在路径可行性验证过程中,在符号执行工具JavaPathFinder运行前加入kWP分析的可行路径百分比对比图.柱状图中的黑色部分表示只使用JavaPathFinder的可行路径占所生成路径集合的百分比;灰色部分表示加入kWP分析后,可行路径所占的百分比相对于加入之前的增加幅度;斜纹部分表示加入kWP分析后,不可行的路径或者冗余的路径所占的比例.从图6可以看出基于符号执行的路径搜索方法在加入kWP后,能较大幅度地提高路径可行性的验证效率,同时误报和漏报数量均相应减少.在实际分析过程中,JavaPathFinder存在循环条件的计算较为复杂难以求解,导致容易在设定时间阈值内出现死循环的现象,故对于程序中的循环变量,本文中采用图2的方法将循环结构展开,并逐渐增加k的取值来调整循环体执行的次数,通过计算不可解的循环条件来生成对应的反例程序来引导生成可行的路径.影响可行路径百分比的因素与影响加速比的因素类似,不同之处在于加速比突出的是在某个k值的作用下本文方法与传统符号执行方法在时间开销方面的比较;而可行路径百分比强调的是能够发掘的可行路径的数量.如图6所示,本文方法在发掘与兴趣点相关的路径集合方面相对于传统符号执行方法有大的性能提升,程序lusearch的提升幅度最高,幅度约为41.2%;提升幅度最少的为程序avrora,其提升幅度约为17.1%.测试基准程序集的平均提升幅度为27.6%,表明本文的方法kWP在发掘程序可行路径方面有较高的精度提升.图7表示因子k的取值与测试基准集的可行路径之间的关系:随着k取值的增加,所能生成的可行路径的数量也在不断增加.在本文方法中k的取值对分析的精度与生成的可行路径数量有直接的影响,即因子k的取值可以平衡程序的分析规模以及分析的精度,故在实验过程中,我们主要从发掘不可行路径效率的角度出发,在设定的执行时间阈值内来分析k的取值.另外本文方法在执行过程中,可能存在引入新的不可解路径条件的现象,故本文结合测试基准集的实际分析效果,设定k的取值一般不超过20.若k的取值继续增大,则可能导致分析时间过长而超时或者符号执行工具和求解器开销过大而内存资源耗尽.从图7中可以看出对于有的测试基准程序,其可行路径数量在因子k的某个取值区间内无变化,其原因是循环结构的执行次数在不断增加,或者求解器在求解过程中出现了不可解的情况.图7因子k的取值对可执行路径数量的影响6相关工作对比可信计算是信息安全领域的重要研究方向,TCG(TrustedComputingGroup)对可信的定义是:若一个实体是可信的,那么该实体在实现预定目标Page10过程中,其行为也是符合预期的.文献[13]认为:可信≈可靠+安全,故需要对软件的可信性进行验证.目前,程序验证过程中通常使用定理证明和模型检验的方法,ESC/JAVA[14]采用定理证明的方法验证函数是否满足给定的前置条件和后置条件,但该方法需要人工地在程序中增加注释来引导其分析过程.模型检验的方法可以对程序属性的正确性进行证明,SLAM[15]采用逐步精化的方法对程序待验证的性质进行近似,然后以目标制导的方式进行抽象精化;BLAST[16]采用惰性抽象和基于反例的抽象求精的方法对程序属性进行验证,但是这些方法常常遇到状态空间爆炸或者由于抽象所带来的分析精度较低等问题.在通过验证来发现软件缺陷方面,文献[17]从程序漏洞溢出的角度提出一种基于有限约束满足性的检测方法,可在无源代码的情况下直接分析可执行程序.Metal[18]是一个采用局部数据流分析的上下文不敏感错误检测工具,但它采用的分析方法是路径不敏感的,故其分析精度有限.PREFix[19]依据CFG图采用自底向上的方法来构建近似的过程摘要(proceduresummary),但是它不能描述函数的输入域,故其采用保守的方式来预测程序的行为,相比之下本文的方法由于是一种基于需求驱动的路径敏感分析方法,其分析过程有较强的针对性.PSE[20]是一款使用过程间后向符号分析对程序的缺陷进行验证的工具,但是由于该工具不能获得程序所有的路径条件,故常需对程序的堆栈进行摘要操作,而该工具并没有提出相应的近似分析方法.ESC/Java也是一种基于最弱前置条件的分析方法,但是它采用的只是过程内的分析方法,依赖用户的注释来推理程序中的调用关系.DSD-Crasher[21]通过使用ESC/Java生成测试用例作为程序反例,但是该工具通过符号分析所生成的最弱前置条件中的一个子集可能会被其它变量消除,从而导致整个最弱前置条件无法求解.文献[7]也采用最弱前置条件的方法引导符号执行操作来对程序缺陷进行修复和验证,但是没有对生成的最弱前置条件进行化简与合并.文献[22]采用基于路径的最弱前置条件来定位并纠正函数中的错误语句,其分析过程类似本文方法中的k=0的情况,相比之下本文的方法可以调整k的取值来扩展分析范围,具有更好的灵活性.7结论及将来工作路径可行性是验证程序安全性质中的主要内容,但是由于在验证过程中容易出现状态空间爆炸等问题而生成较多无用的路径,且大量的路径缺乏针对性.本文在文献[23]的工作基础上,提出一种改进的最弱前置条件与符号执行相结合的多路径程序验证方法,首先对程序的控制流图进行改进,使得路径的分析不再依赖于程序中的循环变量,从而每一条执行路径都有惟一的路径编码,这样就可以在其基础上使用最弱前置条件的方法生成引导信息供符号执行生成与验证性质相关的路径集合.本文方法通过分析与可行路径近邻的路径集合来生成程序近似的有效输入域,从而避免对所有路径的最弱前置条件进行计算,为高效地分析程序的路径可满足性提供了一种思路.实验结果表明本文的方法较传统的符号执行方法能够在较短时间内针对路径的可满足性问题生成更加精简而高效的路径集合,同时在分析效率上有较大提高.本文的方法还存在需要改进的地方,主要体现在对浮点运算,按位操作等语句的语义还不能较为精确地进行分析,此外还不能处理并发程序,在以后的工作中可以采用诸如线程逃逸的方法进行研究;另外的一个研究方向是对本文的方法进行扩展,建立起程序的功能属性与非功能属性之间的关联关系,通过对功能属性的分析来对非功能属性进行间接地验证.致谢感谢美国佐治亚理工学院计算机科学系的AlessandroOrso教授和审稿专家对本文提出的修改建议!
