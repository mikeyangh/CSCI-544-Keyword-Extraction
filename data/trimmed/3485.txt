Page1模糊对象的空间Co-location模式挖掘研究欧阳志平王丽珍陈红梅(云南大学信息学院计算机科学与工程系昆明650091)摘要空间co-location模式表示的是空间对象的实例在一个相同的区域内频繁地空间并置.过去人们已经对确定及不确定数据的co-location模式挖掘问题进行了一些研究,但是针对模糊对象上进行的研究还没有.模糊对象在许多领域里都有着非常重要的应用,比如生物医学图像数据库和GIS.该文研究模糊对象的空间co-location模式挖掘问题.首先,定义模糊对象上空间co-location模式挖掘的相关概念,包括模糊参与率、模糊参与度等.其次,提出FB算法挖掘模糊对象的co-location模式.接着,提出了3种改进算法,包括剪枝对象、减少实例间连接、改进剪枝步,以提高挖掘性能、加快co-location规则的产生.最后通过大量的实验说明FB算法及其改进算法的效果和效率.关键词模糊对象;co-location模式;空间数据挖掘;模糊参与率;减少连接1引言空间co-location模式代表了一组空间对象的Page2“半湿润常绿阔叶林”生长的地方80%会有“兰类”植物生长[1].在现实世界中,模糊对象无处不在,比如“漂亮的女人”、“高大的树”等,同时模糊对象在许多应用中也起着十分重要的作用,目前对模糊对象的研究范围十分广泛,但对co-location模式的研究还没有,针对这一情况,本文研究模糊对象上的co-location模式挖掘问题.本文第2节为相关工作;第3节是相关定义及性质;第4、5节为算法和实验;第6节为结论.2相关工作空间co-location模式挖掘问题是空间数据挖掘领域的一个重要研究方向,人们对确定数据上的co-location模式挖掘问题进行了深入的研究,并提出了很多算法,比如join_based算法[2]、partial-join算法[3]、join-less算法[4]、CPI-tree算法[5]、order-clique-based算法[6]等.在文献[2]中,给出了co-location模式挖掘相关的一些定义,包括邻近关系、空间co-location模式、行实例、表实例、参与率、参与度以及co-location规则和条件概率等.近年来,对不确定数据上的co-location模式挖掘的研究也越来越多,文献[7]提出了不确定集上的UJoin_based算法.文献[8]研究了从区间数据表示的不确定对象中挖掘co-location模式.虽然目前空间co-location模式挖掘算法很多,但对模糊对象的co-location挖掘算法还未见报道.模糊对象[9]的研究目前主要集中在模糊对象的建模上,比如基本的类型和操作模型等.文献[10-13]在GIS中对模糊对象做了大量的研究.文献[14]研究模糊对象的KNN查找问题,提出了AKNN和RKNN算法.3相关定义及性质本部分首先对模糊对象、模糊概率阈值、空间距离、模糊参与率以及模糊参与度进行定义,其次给出本文定义的模糊参与率及参与度所满足的一个性质.3.1相关定义定义1(模糊对象).本文中的模糊对象,表示为一个空间中离散点的集合,定义如下:A={〈a,μ(a)〉|μ(a)>0},其中A表示模糊对象,a表示实例,μ(a)表示实例a属于模糊对象A的隶属度.图1所示为一个模糊对象A,实例a1、a2属于A的隶属度分别为0.6,0.01.从图1中可以看出,实例a2属于模糊对象A的隶属度非常低,对于这样的实例,我们希望计算co-location模式时把它排除,因为在现实生活中,我们认为隶属度非常低的实例对于模糊对象来说没有多大意义.例如老年人,假设80岁隶属度为0.8,50岁为0.02,对于50岁,我们认为它对于老年人这个对象贡献相当少,所以在有些应用中可以把它排除,而只关注那些符合实际应用的期望隶属度值条件的实例,于是我们有以下定义.定义2.给定一个用户自定义的概率阈值f_threshold,称为模糊度阈值,集合Af_threshold={a|μ(a)f_threshold},表示满足用户自定义模糊度阈值的实例集.如图1中,A0.2={a1}.定义3(空间邻近关系R).设a,b分别为模糊对象A,B的实例,它们之间的距离用欧几里德距离计算,表示为d(a,b)=‖a-b‖.由此可以定义空间邻近关系R:若两个实例之间的欧几里德距离小于等于阈值dis_threshold,即d(a,b)dis_thresh-old,则表示它们邻近.当两个空间实例a和b之间满足空间邻近关系R时,称这两个空间实例R邻近,记为R(a,b),并在图中用线段连接它们(如图2所示).一个空间co-location模式表示的是一组空间对象的集合.co-location模式的长度称为此co-location模式的阶,即co-location模式里空间对象的个数.例如co-location模式c={A,B,C},则称模式c是3阶co-location模式.设有空间实例集I={i1,i2,…,il},如果有{R(ij,ik)|1jl,1kl},则称I是一个团Page3(clique).如果团I包含了co-location模式c中的所有对象,并且I没有任何一个子集可以包含c中的所有对象,那么I是co-location模式c的一个行实例(称为co-location实例).co-location模式c的所有行实例的集合称为表实例,记为table_instance(c).例如图2中,co-location{A,B,C}的表实例为{{a2,b1,c1},{a2,b3,c1}}.定义4(模糊参与率).设fi为某个空间模糊对象,fi在k阶的co_location模式c中的模糊参与率表示为FPR(c,fi),它是fi的实例在空间co-location模式c的表实例中不重复出现的实例的隶属度之和与fi中总实例个数的比率,公式如下:FPR(c,fi)=∑1×μ(a)其中a∈∏fi影操作.定义5(模糊参与度).模糊对象的空间co-location模式c={f1…fk}的模糊参与度表示为FPI(c),是模式中所有空间对象FPR值中的最小值,公式表示如下:设min_prev是用户给定的最小参与度阈值,当FPI(c)min_prev时,称模糊对象的co-location模式c是频繁的.例1.图2所示为3个空间模糊对象A={(a1,0.2),(a2,0.4),(a3,0.6),(a4,0.8)},B={(b1,0.3),(b2,0.6),(b3,0.8)},C={(c1,0.1),(c2,0.7)},R关系用连线表示,假设min_prev=0.2.则在co-location模式c={A,C}中,FPR(c,A)=(1×0.4+1×0.8)/4=0.3,而FPR(c,C)=(1×0.1)/2=0.05,则FPI(c)=min{0.3,0.05}=0.05,co-location模式c为非频繁模式.定义4说明:假设模糊对象A有4个实例,图3表示的是A的一个实例a1的模糊参与率与其隶属度的关系.横坐标表示a1属于对象A的隶属度值,纵坐标表示模糊参与率值,从图中可以看出,当实例a1的隶属度增加时,它的模糊参与率也会相应增加,因为a1的模糊参与率值为a1的隶属度与对象A的总实例个数的比率.当隶属度为0时表示a1不属于对象A,这时模糊参与率自然为0,隶属度为1时表示a1完全属于对象A,这时它的模糊参与率与传统定义的值一样,为0.25.3.2性质定理.模糊参与率与参与度满足如下的一个引理和引理1.模糊参与率(FPR)和模糊参与度(FPI)随着co-location模式阶的增大单调递减.证明.假设某个模糊空间对象的实例包含在co-location模式c的实例中,那么当有co-location模式c1c,这个模糊空间对象的实例也一定包含在模式c1的实例中,反之则不然,所以模糊参与率是单调递减的.由于模式的模糊参与度取它包含的对象中最小参与率值,当模式的阶增大时,由于模糊参与率是递减的,所以co-location模式的模糊参与度也是单调递减的.定理1.如果k阶co-location模式c是频繁的,那么它的任意k-1阶的子co-location模式也是频繁的.证明.根据引理1,k阶co-location模式c的模糊参与度,要小于其k-1阶子co-location模式,所以若k阶co-location模式c是频繁的,则k-1阶的子co-location模式肯定也是频繁的.利用定理1可以对候选模式进行剪枝处理,具体的剪枝过程见4.4节.4模糊对象co-location模式挖掘算法首先给出一个模糊对象的co-location挖掘的基本算法———FB算法,接着在其基础上提出3种改进算法,包括剪枝模糊对象、减少实例间的连接、优化剪枝步.算法中模糊对象的实例按照实例的模糊度非递增排序.4.1FB算法FB算法采用的是经典join_based算法的思想,循环执行以下4个步骤:(1)产生候选co-location模式(包括连接步和剪枝步);(2)产生候选co-location模式的表实例;(3)剪枝(利用用户自定义的参与度阈值min_prev进行剪枝);(4)产生co-location规则.具体过程如算法1所示.Page4算法1.FB算法.输入:空间模糊对象集SF,空间实例集SFI,参与度阈输出:co-location规则集FP变量:k:co-location模式的阶,Ck:k阶co-location候步骤:1.F,FI=gen_fdata(SF,SFI,f_threshold);2.P1=F,FP=;3.for(k=2;Pk-1≠;k++)do4.returnFP.步1是根据文中定义的模糊度阈值得到满足条件的模糊对象和实例集;步2为初始化;步3迭代地生成频繁co-location模式集和规则集,其中,步3.1为生成k阶co-location候选模式集,步3.2为生成k阶co-location候选模式的表实例集,步3.3生成k阶频繁co-location模式集,步3.4生成k阶co-location规则集;步4返回结果.4.2剪枝模糊对象由于co-location挖掘算法需要对模糊对象的大量实例之间进行距离计算以及连接操作,因此我们应当尽可能剪掉那些不可能存在于co-location模式中的模糊对象.基于以上思考,论文提出一种有效的剪枝规则.定理2.对于一个模糊对象A,若它最大模糊参与率值小于给定的最小参与度阈值,则对象A不可能存在于任意的频繁co-location模式中.证明.反证法.假设模糊对象A存在于某个频繁的co-location模式c中,则我们可以得到FPR(c,A)min_prev.模糊对象A在c中的最大参与率为它的所有实例均在co-location模式c的表实例中,根据模糊参与率的定义,最大模糊参与率值等于模糊对象A的所有实例的隶属度之和与对象A的实例数目的比率,由定理条件可知,它小于给定的最小支持度阈值,这时可以得到FPR(c,A)<min_prev,与假设矛盾,所以对象A不可能存在于任意的co-location模式中.例2.图2中,设min_prev=0.6.假设模糊对象C的所有实例均在co-location模式的行实例中,C的最大参与率值等于0.1/2+0.7/2=0.4<0.6,由定理2可知,C不可能存在于任意的co-location模式中,这时把对象C剪枝掉.利用定理2,可以在模式挖掘前对对象进行初步剪枝,降低算法的时间复杂性.具体见算法2,其中步骤1为计算每一个模糊对象的最大参与率.算法2.剪枝模糊对象算法.输入:模糊对象集F,实例集FI,参与度阈值min_输出:剪枝模糊对象后的F,FI步骤:1.forallfuzzyobjectf∈Fdo2.returnF,FI.4.3减少实例间连接尽管通过3.2节中的改进算法可以减少实例之间的计算量,但co-location模式挖掘过程中仍然有大量实例之间的连接操作,相当耗时.在FB算法基于参与度的剪枝过程中,首先要生成候选模式的表实例,再基于参与度阈值来对候选模式进行剪枝.我们在研究中发现,可以在表实例生成最开始阶段就对某些不可能满足参与度阈值的候选模式进行剪枝,避免表实例之间大量不必要的连接操作,大大提高算法的效率.下面给出定理3,它是减少实例间连接算法的依据.定理3.在co-location模式c中,假设模糊对象A∈c,如果A在c的表实例中的实例满足max{μ(a)}<min_prev,其中a是对象A的实例,则co-location模式c可以被剪枝掉.FPR(c,A)∑n证明.因为所以当max{μ(a)}<min_prev时co-location模式可以被剪枝(假设模糊对象A的实例数是n).例3.图2中,考虑2阶co-location模式c={A,B},每个对象的实例序按隶属度非递增进行排序,假设min_prev=0.7.对象A与对象B实例的RPage5关系中,a4与B的实例不存在R关系,与B存在R关系的最大隶属度实例为a3,而a3的隶属度为0.6<min_prev,所以模式c={A,B}可以被提前剪枝,这样就不用计算实例a2,a1与对象B的实例之间的关系.从定理3可知,只要模式中任何一个对象,它在模式表实例中的实例的最大模糊度小于参与度阈值,则可以对该模式进行剪枝.于是可以得到减少实例间连接的改进算法,具体见算法3,其中变量max_flag为判断是否最大模糊度实例条件,因为对象的实例顺序已经按照实例模糊度非递增排序,所以在实例连接过程中,第一次实例间的连接即为模式每个对象具有最大模糊度的实例间的连接.算法3.减少实例间的连接算法.输入:频繁k阶模式p1k,p2k,模式p1k,p2k的表实例输出:候选模式c3k+1的表实例集t3k+1步骤:1.max_flag=true;2.for(i=1;it1k.count;i++)2.1.for(j=1;jt2k.count;j++)2.1.1.if((t1k[i].instance1=t2k[j].instance1…2.1.1.1.if(max_flag=trueandgotoloop1;2.1.1.2.else2.1.1.3.max_falg=false;3.loop1:returnt3k+1.4.4优化剪枝步这一小节,本文将提出一种新的改进算法,对FB算法中生成候选模式过程中的剪枝步进行优化,在FB算法中剪枝步的做法如下:删除所有Ck中这样的候选模式c,c的k-1阶子集不是频繁的.本文根据第2部分中的定理1提出一种新的剪枝策略,它不用去比较c的每一个k-1阶子集是否频繁,就可以对候选模式进行剪枝.实验和理论分析表明,新的剪枝步策略要比传统的策略具有更好的时间复杂性.对候选k阶模式Ck增加一个相应的计数数组.该计数数组产生的过程和功能简单描述如下:当频繁模式进行连接产生候选co-location模式时,增加一个计数数组.连接过程中每产生一个候选co-location模式,数组就相应地增加一位,用来存储该候选模式的频繁k-1阶子模式的个数.由定理1可知,每一个k阶候选模式,其(k-1)阶子模式都是频繁的且为k个,所以最后可以根据数组相应位的值来判断对应的候选模式是否频繁.以下是具体的处理方法和过程.图4(a)中,假设已得到2阶频繁模式为P2={AB,AC,AD,BC,BD},这时基于P2连接产生3阶候选模式过程为:首先增加一个计数数组CR,对于P2中的模式,计算AB,由于C3为空,所以对数组CR不做任何处理.接着AB开始与P2中其它频繁模式连接产生候选模式,AB和AC连接产生候选Page6模式ABC,这时相应地将数组CR增加1位,并将其值加1.AB与AD连接产生候选模式ABD,数组CR增加1位,并将其值加1.AB连接完成,开始考虑AC,先扫描3阶候选模式,由于AC是ABC的子集,所以CR[1]加1.接着AC与AD进行连接产生候选模式ACD,CR[3]加1,依此循环,直到P2中所有频繁模式连接完成,详细过程见图4(b).最后C3={ABC,ABD,ACD,BCD},数组CR={3,3,2,2},由于ACD和BCD计数位不为3,所以对其进行剪枝.对于每一个k阶候选模式,若其频繁子模式个数不为k,则对其进行剪枝.通过证明,新的剪枝步策略比传统的具有更好的时间复杂性,以下给出证明.证明.假设Ck中有m个模式,Pk-1中有n个频繁(k-1)阶模式,在传统剪枝步中,每一个k阶模式有k个(k-1)阶子模式需要与Pk-1进行比较,其时间复杂度为k×m×n,而在新的剪枝策略中,只需对Pk-1中每一个模式扫描一遍Ck,其时间复杂度小于m×n,由此可知新策略的时间复杂度更优.改进算法的伪代码见算法4.算法4.优化剪枝步算法.输入:k阶频繁模式集Pk,存储对应的候选模式的频繁输出:k+1阶候选模式集Ck+1步骤:1.for(i=1;iPk.count;i++)1.1.forallCk+1[x]∈Ck+1if(Pk[i]中对象都在Ck+1[x]中)thenCR[x]=CR[x]+1;1.2.for(j=i+1;jCk.count;j++)if(Pk[i].object1=Ck+1=Ck+1∪{Pk[i]joinPk[j]};2.forallCk+1[y]∈Ck+1ifCR[y]≠kthenremoveCk+1[y]fromCk+1;3.returnCk+1.5实验与分析在本节中,本文做了大量实验来验证所提出的FB算法和改进算法的有效性,并用文中提出的算法与传统算法的挖掘结果进行了实验比较.所有算法均采用C#编写,并在AMDAthlon1.8GHzCPU和512MBmemory的计算机上运行.实验所采用的实例数据均是随机产生的并均匀分布在100×100空间里,模糊对象的数目为10,模糊度的值从0到1,也是随机产生的.表1给出了实验的参数以及默认值.5.1FB算法与其改进算法的性能比较在这一小节中,本文将对模糊对象co-location挖掘算法(FB)与其改进算法进行比较,改进算法包括剪枝对象算法(PO)、剪枝对象基础上的减少实例间连接的算法(PO_RI)、剪枝对象且减少实例间连接基础上的优化剪枝步算法(PO_RI_PC).5.1.1实例数目对算法的影响首先考查实例数目对算法的影响,实例数目从500增加到5000.从图5可以看出,随着实例数目增加,所有算法的运行时间都增加,因为随着实例数目的增加,算法实例间距离计算、连接操作也会增加.PO_RI和PO_RI_PC算法由于采用了减少实例间的连接改进算法,故随着实例数目的增加,它的处理时间上升的幅度比较小,这也说明了减少实例间连接改进算法的高效性.5.1.2参与度阈值对算法的影响下面研究参与度阈值对算法的影响,参与度阈值的变化从0.8到0.2.从图6中可以看出,FB算法和PO算法的运行时间随着参与度阈值的降低而急剧上升,而PO_RI算法和PO_RI_PC算法的运行时间一直保持平稳,这是因为随着参与度阈值的降低,更多的co-location模式满足参与度阈值条件,Page7使得FB和PO算法运行时间急剧上升,而PO_RI和PO_RI_PC算法由于采用了减少实例间的连接改进算法,所以运行时间一直较平稳.从图中还可以看出当参与度阈值在0.4到0.2区间时,FB和PO算法运行时间基本一样,这是因为PO算法采用的是剪枝模糊对象改进算法,它依赖于参与度阈值,当自定义的参与度阈值非常低时,算法很难剪枝掉很多的模糊对象,所以两个算法的运行时间相差不大.5.1.3距离阈值对算法的影响接下来考虑距离阈值对算法运行时间的影响,距离阈值变化从10~40.从图7中可以看出,类似于实例数目对算法的影响,随着距离阈值增大,FB和PO算法运行时间快速上升,而PO_RI和PO_RI_PC算法上升较平稳.5.1.4模糊度阈值对算法的影响本组实验的最后考虑模糊度阈值对算法的影响,模糊度阈值从0到0.5变化.从图8中可以看出,当模糊度从0到0.2时,4个算法的运行时间均上升,而在0.2以后,4个算法的运行时间又开始下降,这是因为把模糊对象的那些不满足模糊度阈值的,具有低模糊度的实例剪去后,剪枝掉实例的对象的参与率值会增大,这时满足参与度阈值条件的模式数目会增多,使得算法运行时间上升.但是随着模糊度阈值的不断增大,要剪去对象的实例也越多,这就意味着一个对象具有的实例数目越来越少,就会减少模式产生的数目,使得算法的运行时间下降.5.2模糊挖掘算法与传统算法的比较在这一小节,本文用模糊对象co-location挖掘算法,与传统挖掘算法的结果进行实验比较.这里传统算法采用的是co-location挖掘算法中最为经典的join_based算法[2].考虑实例个数、参与度阈值、距离阈值、模糊度阈值对两种算法的影响,其中模糊对象co-location模式挖掘算法采用的是PO_RI_PC算法.5.2.1实例个数对算法的影响首先,考虑实例个数对两种不同算法的影响,实例数目从500增加到5000.从图9中可以看出,两种算法的模式数目都随着实例数目的增加而增加.Join_based算法产生的模式数目远大于PO_RI_PC算法,这是因为PO_RI_PC算法模式参与度的计算是根据实例的模糊度来计算的,而传统算法中没有区分实例之间模糊度的差别,这导致了后者的参与度要高于前者,在相同参与度阈值条件下,后者频繁模式数目要明显高于前者.5.2.2参与度阈值对算法的影响接下来考虑参与度阈值对算法的影响,阈值变化从0.8到0.2.从图10中可以看出两种算法的模Page8式数目随着阈值降低都在增加,在低参与度阈值条件下,比如阈值为0.2,两者的频繁模式数目比较接近.5.2.3距离阈值对算法的影响接下来考虑距离阈值对算法的影响,距离阈值的变化从10~40.从图11中可以看出,两种算法的模式数目都上升,但PO_RI_PC算法上升较慢,因为限制频繁模式个数的因素还有参与度.5.2.4模糊度阈值对算法的影响最后来看模糊度阈值对算法的影响,模糊度阈值的变化从0~0.5.从图12中可以看出,Join_based算法的模式个数保持不变,因为模糊度没有参与模式参与度的计算中.而PO_RI_PC算法生成的模式个数开始上升,后来出现下降,原因可以见实验5.1.4节中的分析.6结论尽管空间co-location模式挖掘是一种非常有价值的空间挖掘,而且模糊对象也经常出现在许多重要的应用中,但是目前对于模糊对象的co-location模式挖掘的研究还未见报道.本文针对模糊对象的空间co-location模式挖掘问题,提出了一种基本挖掘算法———FB算法,为了提高算法的挖掘效率,文中提出了3种改进算法,包括剪枝对象、减少实例间连接、改进剪枝步.通过大量的实验表明,本文提出的算法及改进算法是非常有效的.下一步的工作将在此论文的基础上,考虑模糊度阈值在一个范围内变化时的空间co-location模式挖掘问题.
