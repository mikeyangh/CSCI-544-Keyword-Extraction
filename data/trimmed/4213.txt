Page1基于谓词执行信息分析的自适应缺陷定位算法郝鹏1)郑征1)张震宇2)高乙超1)宫成1)薛云志3)1)(北京航空航天大学自动化科学与电气工程学院北京100191)2)(中国科学院软件研究所北京100190)3)(中国科学院软件研究所基础软件测评实验室北京100190)摘要查找程序中缺陷代码所在的位置是一项值得深入开展的研究,同时也是实际软件调试过程中所面临的一个难题,这一过程往往需要耗费大量的时间和人力资源.研究软件缺陷定位的一类重要方法是基于谓词的统计学缺陷定位方法(简称PBSFL).PBSFL通过比较程序运行成功与失败时谓词的执行信息差异来获得谓词与缺陷的关联程度.然而实验研究发现,固定算法中信息利用的强度会造成信息利用不足或过分利用现象的发生,导致现有PBSFL方法对某些缺陷定位不够准确.针对这一问题,文中设计了一种基于谓词执行信息分析的自适应缺陷定位算法,该算法通过分析测试用例运行时谓词的执行情况来动态地为每个谓词选择合适的信息利用强度.实验结果表明,该方法在Siemens和space两个程序包上表现出很好的定位效果以及定位稳定性.关键词统计学缺陷定位;谓词执行信息;自适应;软件测试;程序分析1引言现代软件和软件系统中仍会不可避免地存在缺陷,而软件调试则是一个查找软件缺陷的有效手段.为了定位并且修复软件缺陷,一种常用的做法是调试失效的程序.由于手工调试存在耗时、易错等缺点,因此研究人员一直致力于开发自动化或半自动化的软件缺陷定位技术.近几十年里,软件缺陷定位领域研究活跃,一批统计学缺陷定位(StatisticalFaultLocalization,SFL)方法被相继提出[1-14].SFL方法通过收集大量成功与失败测试用例运行时程序元素(例如语句[1-4]、谓词[5-8]、分支[9]或信息流[10])的动态信息,然后利用这些动态信息与程序失效之间的关联性为每个程序元素计算可疑度值.从直观上理解,如果关联性越强,该程序元素的可疑度值就越大.最后,程序开发人员按照可疑度值由大到小的顺序依次检查程序元素的排位表,直到最终找到存在缺陷的程序元素.尽管SFL方法可以取得很好的定位效果,但是该类方法的有效性仍会受一些因素的影响.例如,在之前的研究中,我们曾指出,基于谓词的统计学缺陷定位(Predicate-BasedStatisticalFaultLocalization,PBSFL)方法的定位效果会受谓词执行信息量多少的影响[8].对谓词执行信息利用不足或过分利用都会削弱缺陷相关谓词与程序失效之间的关联性,造成PBSFL方法无法有效区分缺陷谓词与非缺陷谓词,从而影响定位精度.谓词执行信息量是指程序运行时谓词实际可以提供信息的数量,谓词提供的信息包括谓词分别判断为“真”或“假”的次数以及判断的顺序.由于程序执行剖面不同,导致不同谓词在每次程序运行时提供信息的数量也存在着差异.从直观上理解,谓词执行的次数越多,可以提供的信息数量也就越多.谓词执行信息利用强度是指对谓词执行信息提取多与少的衡量.如果提取的信息量超过谓词实际可以提供的信息数量,则会造成过分利用谓词执行信息的现象;相反,则会导致信息利用不足.现有PBSFL方法对程序中所有插桩谓词都采用统一且固定的信息利用强度,无法做到根据程序实际运行情况充分利用谓词的执行信息,这也促使我们对如何有效利用谓词执行信息来提高PBSFL方法的定位精度以及适应性进行深入研究.在本文中,我们提出一种新的谓词执行信息利用方法,该方法根据测试用例运行时每个谓词的执行情况,动态地选择适合于每个谓词的信息利用强度.因为不同测试用例运行时程序的执行谱不同,导致程序中谓词的执行情况也不尽相同,最直观表现为不同谓词在相同测试用例运行时取值为“真”或“假”的顺序以及次数不同.如果对所有谓词均采用相同的信息利用强度,则会不可避免地对某些谓词存在信息利用不足或过分利用的情况.只有充分利用每个谓词的执行信息,才可能达到提高算法定位精度的目的,因此需要根据每个谓词执行信息量的变化有针对性地选择信息利用强度,即让算法的信息利用强度适应于谓词执行信息量的变化.为了验证这一想法,我们提出一种基于谓词执行信息分析的自适应缺陷定位算法(Self-adaptiveFaultLocalizationAlgorithmbasedonPredicateexecutioninformationAnalysis,以下简称Safla).与现有PBSFL方法的流程类似,Safla也是先收集缺陷程序运行时谓词的执行信息,然后进行信息的提取和转换,再根据缺陷关联度公式计算每个谓词的可疑度,最后给出谓词可疑度的排序.与现有方法固定信息利用强度的做法不同的是:Safla采取分析失败测试用例运行时谓词的执行情况,动态地选择适合于每个谓词的信息利用强度,确保谓词执行信息的利用更加充分有效.为了验证Safla的定位效果,我们选取CBI[5]、SOBER[6]、Mann-Whitney、Wilcoxon、F-test、t-test[7]以及Nbit-Pesla[8]算法进行对比,并在Siemens和space程序包上进行实验.实验结果表明,Safla在Siemens和space两个程序包上表现出很好地定位效果以及定位稳定性.本文贡献总结如下:(1)提出自适应选择信息利用强度的思想,并设计了一种具体的选择方法.(2)基于上述思想,提出了一种新的基于谓词的统计学缺陷定位方法.本文第2节简单介绍基于谓词的统计学缺陷定位方法的研究现状;第3节给出研究动机;第4节对Safla的基本思想和详细步骤进行介绍;第5节给出Safla分别在Siemens和space程序包中进行实验的结果,并与多个典型算法进行比较分析,得出结论;第6节对实验结果的有效性进行讨论;第7节是对本文的总结和展望.2相关研究近十年里,关于使用统计学方法进行缺陷定位Page3已有大量的研究.统计学缺陷定位方法通常要求具备3个要素:大量测试用例、相应测试用例的执行剖面以及测试用例的运行结果(成功或失败).其中,执行剖面包含测试用例经过每条可执行语句、分支或插桩谓词时的覆盖信息.由于本文所讨论的方法属于基于谓词的统计学缺陷定位方法范畴,因此本节主要对现有的几种基于谓词的统计学缺陷定位方法进行简单的介绍.CBI[5]算法提出者认为,程序运行失败与程序中缺陷谓词被判断为“真”有关.因此,该算法建立的统计学模型是比较程序运行成功与失败时相应谓词被判断为“真”的概率.若概率数值差异越大,则认为该谓词越可疑.在此之后提出的SOBER[6]算法弥补了CBI模型上的一些缺陷,如CBI模型没有考虑分布情况,而只是单纯地将谓词的两个不同期望值相减.若遇到两种分布具有相同的期望而方差不同的情况时,CBI算法将无法发挥很好的定位作用.SOBER模型通过比较谓词evaluationbias(程序一次运行过程中谓词被判断为“真”的概率)在成功与失败分布中的差异来寻找缺陷相关谓词.实验证明,考虑分布情况的SOBER算法的定位效果要优于CBI算法.但后来大量实验表明,SOBER模型中谓词在成功与失败测试用例下服从正态分布的假设并不合理,这也直接影响了SOBER算法的最终定位效果.于是,Zhang等人[7]提出,在总体分布未知的前提下,应使用统计学中非参数假设检验法来比较谓词evaluationbias在成功与失败两类分布中是否相同.实验结果显示,非参数假设检验法能定位到更多的缺陷.在此之前的研究中,我们曾提出Nbit-Pesla算法[8],并在实验中证明,2bit-Pesla算法的定位精度要明显优于SOBER算法和非参数假设检验法,但扩展算法(例如:3bit-Pesla、4bit-Pesla等)的定位精度反而呈现出下降的趋势.为此我们提出一种解决办法,采取对不同缺陷版本程序使用不同“N”值的Nbit-Pesla算法进行计算,最终定位效果获得了提高.但是该方法对同一程序中的所有谓词采用相同的信息利用强度,对一些谓词执行信息的利用仍然不够合理,因此定位精度的提高有限.3研究动机在本节中,我们在对Nbit-Pesla算法基本思想进行讨论的基础上,归纳出本文的研究动机.假如谓词P在两个测试用例下的执行情况分别为“10011100”和“10001101”,P判断为“真”记为“1”,判断为“假”记为“0”.可以发现,在上述两次运行中,谓词判断为“真”和判断为“假”的次数是相同的,但其判断顺序不同.SOBER算法虽然比较了这两次执行中P被判断为“真”和“假”的次数,但是忽略了判断顺序,因而无法找到其中的差别.相比之下,考虑谓词判断顺序的Nbit-Pesla算法则可以发挥很好的定位作用,有关该算法的详细描述参见文献[8].然而,该算法没有考虑谓词执行信息量多少与算法信息利用强度大小这两者之间是否能够动态匹配的问题,导致在某些情况下定位精度不高.例程序,从以下两个角度阐述本文的研究动机:为此,我们将借助Siemens程序包中的一个实(1)程序运行时谓词提供信息的能力存在着差别.这主要表现在两个方面:①不同谓词在同一次运行中提供信息的能力不同;②同一谓词在不同运行中提供信息的能力也不同.图1是“replace”程序包v17版本的部分代码,共包含5个谓词.其中,缺陷位于第7行,右侧注释为正确的代码.L1:charesc(chars,inti){L2:charresult;L3:if(s[i]!=@)L4:result=s[i];L5:else{L6:if(s[i+1]==\0)L7:result=10;/fault:result=@/L8:else{L9:i=i+1;L10:if(s[i]==n)L11:result=10;L12:else{L13:if(s[i]==t)L14:result=9;L15:elseL16:result=s[i];}}}L17:returnresult;}上述各谓词在所有成功和失败测试用例下的执行情况分别如图2和图3所示.为了便于展示,我们对执行次数采取以2为底的对数运算.其中,“Max”表示最大的执行次数,“Min”表示最小的执行次数,“Mean”表示执行次数的平均值.从图中我们可以直观地看到,不同谓词之间执行情况不同.例如P2和P5,无论是在成功测试用例还是在失败测试用例下,这两个谓词的执行情况都相差较大.Page4即使是同一个谓词,在不同测试用例下的执行情况也存在着很大的差异.例如,图4总结了谓词P5在所有24个失败测试用例下的执行次数情况(横坐标表示测试用例号,纵坐标表示执行次数).可以看到,执行次数分布跨越的范围很大.如果以执行次数多少来衡量谓词提供信息的能力,可以看到,由于程序执行剖面不同,不同谓词在实际程序运行时提供信息的能力存在着差别.(2)对所有谓词采用固定信息利用强度不合理.通过分析图1中的程序,我们发现,谓词P2和P5与缺陷直接相关,我们希望缺陷定位方法能够将这两个谓词都排在排位表中相对靠前的位置.在使用Nbit-Pesla算法进行缺陷定位(N=1,2,3,4,5)时,1bit-Pesla算法或2bit-Pesla算法对P2的定位效果最优(均将P2排在第1位).但是,无论是1bit-Pesla算法还是2bit-Pesla算法对P5都无法取得很好的定位效果(1bit-Pesla算法将P5排在第57位,2bit-Pesla算法将P5排在第63位).相反,增大算法中信息利用的强度,使用5bit-Pesla算法反而可以取得最优的定位效果(将P5排在第33位).通过以上实验结果,我们可以发现,在谓词提供信息能力有强弱差别的前提下,按照之前做法对所有谓词采用相同的信息利用强度是不合理的,这将会造成信息的浪费或信息冗余,降低缺陷相关谓词与程序失效之间的联系,从而影响算法的定位精度.因此,针对每个谓词选择合适的信息利用强度是十分必要的.此外,由于程序运行之前很难对谓词的执行情况进行静态分析,如何提高算法对不同谓词执行情况的适应性也是一个需要解决的难题.在本文中,我们通过对测试用例运行后每个谓词的执行情况进行分析,得到谓词执行次数分布情况来动态地选择适合于每个谓词的信息利用强度.4基于谓词执行信息分析的自适应缺陷定位算法4.1基本定义定义1(谓词执行序列).设Pi是程序中第i个谓词,在使用一个测试用例tl来执行程序时,谓词Pi的执行序列是一个n维向量,可表示为其中,oj(j∈[1,n])运行到谓词Pi所在语句时该谓词的取值,即定义2(信息利用强度).谓词Pi的谓词执行序列犛(Pi,tl)的第j个ω(ωn)维连续子向量称为犛(Pi,tl)的第j个长度为ω的子序列,表示为其中ω称为信息利用强度.例如,执行序列犛(Pi,tl)=(1,1,1,0,1),其子序列长度可为1到5,即其信息利用强度可取1到5.在已有方法中,SOBER算法对于信息的利用强度为1,Nbit-Pesla算法对信息的利用强度为N.定义3(值集合).长度为ω的子序列共有2ω上例中长度为2的子序列可能的取值为(0,0),种取值,其集合{v1,v2,…,v2ω}称为值集合.(0,1),(1,0),(1,1),则值集合为Page5定义4(执行信息向量).对于执行序列犛(Pi,tl),信息利用强度为ω时,向量犖ω其中nk=sizeofj|犛j化后的向量称为执行信息向量,表示为犈ω在上例中,可以根据定义4得到犖21,2),犈2需要注意的是:(1)如果选择的信息利用强度ω大于执行序列的长度n,执行序列与值集合中对应取值相比,将会有ω-n位的取值未知.而由于每个未知位取值为“0”或“1”的概率各占0.5,因此,在这种情况下,执行信息向量中相应位置的nk=1(2)如果谓词在某个测试用例运行时没有被执行到,则由该测试用例得到的执行信息向量中各位均为零.定义5(缺陷关联度).谓词Pi的缺陷关联度定义为在信息利用强度ω下,所有成功测试用例中Pi的执行信息向量总和均值ESω用例中Pi的执行信息向量总和均值EFω离,用2-范数计算为1其中,ESωTotalFailed∑TotalFailed测试用例,TotalFailed表示所有失败测试用例.4.2两个性质及其证明在本节中,我们将在提出并证明两个性质的基础上,对谓词执行信息量和信息利用强度之间的关系进行一定程度的理论分析.性质1.假设谓词Pi在失败测试用例下执行序列的长度均为n位,并且执行序列都相同,而成功测试用例均没有经过谓词Pi.如果选择信息利用强度m进行信息提取,则谓词Pi的缺陷关联度RPi满足如下性质:证明.我们将m和n的关系分为如下3种情况进行分析.情况1.m>n.假设信息利用强度为m=n+x(1x<+),长度为m的子序列共有2n+x种取值,则失败测试用例tl下执行信息向量犈n+x由于失败测试用例下执行序列的长度均为n位,在信息利用强度m下,n+x维子序列中共有x位的取值未知,按照定义4中等概率赋值的操作,在nk(k∈{1,2,…,2n+x})的取值中,将会有2x个取值为12x,其余位均为0,即犈n+x所有失败测试用谓词Pi执行信息向量总和均值EFn+xPi=1由于成功测试用例没有经过谓词Pi,那么成功测试用例tl下执行信息向量犖n+xTotalPass∑TotalPassRPi=ESn+x1只有一位为1,其余位为0情况2.m=n.在这种情况下,长度为n的子序列共有2n种取值,失败测试用例tl下执行信息向量犈nn2n).由于失败测试用例下执行序列的长度均为n位,则在n维子序列2n种取值中,有且仅有一个取值与失败测试用例下的执行序列相对应,即犈n(n1,…,n2n烐烏烑)∑TotalFailed犈nl=1RPi=ESn情况3.m<n.假设信息利用强度为m=n-x(1xn-1),长度为m的子序列共有2n-x种取值,则失败测试用例tl下执行信息向量犈n-x于信息利用强度m<n,在该信息利用强度下,最多可以形成x+1个n-x维的子序列,根据定义4,Pi,tl=n1x+1,…,n2n-x犈n-x例中谓词Pi执行信息向量总和均值EFn-xTotalFailed×∑TotalFailed1Pi=0,所以而ESn-xPage6RPi=ESn-xx()+1槡2=又因为n1+…+n2n-x=x+1,而nj∈{0,1,…,x+1},j∈{1,2,…,2n-x},因此,RPi1.证毕.从性质1可以看出,当m=n时,谓词Pi的缺陷关联度RPi的计算值最大.虽然性质1具有较强的假设,但是根据该性质,我们可以推断出:在谓词提供信息量固定的前提下,过分利用谓词执行信息或是对谓词信息利用不足,都将会导致缺陷谓词的可疑度计算值降低.性质2.假设谓词Pi在失败测试用例下执行序列的长度均为n位,并且执行序列全部相同.谓词Pj在失败测试用例下执行序列的长度均为n+x(1x<+)位,并且执行序列全部相同.而成功测试用例都没有经过谓词Pi和谓词Pj,如果选择信息利用强度m进行信息提取,则谓词Pi的缺陷关联度RPi满足如下性质:谓词Pj的缺陷关联度RPj满足如下性质:5种进行分析.证明.我们将m和n以及x的关系分为如下情况1.m<n.如果信息利用强度m<n<n+x,则Pi,tl=n1n-m+1,…,n2m犈mPj,tl=n1n+x-m+1,…,n2m犈m依据性质1中情况3的讨论,同理可以推断出情况2.m=n.如果信息利用强度m=n<n+x,则可疑度RPi1,RPj1.依据性质1中相应情况的讨论,同理可以推断出可疑度RPi=1,RPj1.情况3.n<m<n+x.如果信息利用强度n<m<n+x,则Pi,tl=n1,…,n2()犈mPj,tl=n1n+x-m+1,…,n2m犈m依据性质1中相应情况的讨论,同理可以推断出可疑度RPi<1,RPj1.情况4.m=n+x.如果信息利用强度m=n+x>n,则依据性质1中相应情况的讨论,同理可以推断出可疑度RPi<1,RPj=1.情况5.m>n+x.如果信息利用强度m>n+x>n,则依据性质1中相应情况的讨论,同理可以推断出可疑度RPi<1,RPj<1.从性质2可以看出,对于谓词Pi,当m=n时,缺陷关联度RPi的计算值最大.但对于谓词Pj,当m=n+x时,缺陷关联度RPj的计算值最大.虽然性质2的假设较强,但是根据该性质,我们可以推断出:在不同谓词提供信息量有差异的前提下,针对每个谓词选择恰当的信息利用强度是获得最佳缺陷关联度计算值的必要条件.借助这两个性质,我们可以发现,谓词执行信息量和信息利用强度都是影响缺陷定位的重要因素,这两者均会对缺陷定位过程产生影响(这一结论将会在实验部分进一步得到验证).因此,基于谓词执行信息进行软件缺陷定位的算法需要根据程序实际运行时谓词提供的信息量合理地选择信息利用强Page7度,才能发挥较好的定位作用,这也是Safla算法的基本思想.4.3算法基本流程Safla的实现分为数据收集、数据分析、数据处理和数据统计4个部分:(1)数据收集部分.本文选择对if/while/for这3类分支语句以及函数返回值语句(return语句)进行插桩,然后输入程序的全部测试用例,收集插桩谓词的输出结果.(2)数据分析部分.针对谓词Pi,通过对所有失败测试用例运行时谓词Pi的执行情况进行分析,确定对Pi所采用的信息利用强度.(3)数据处理部分.根据确定的信息利用强度,对所有成功测试用例下Pi的谓词执行序列集合INFOs和所有失败测试用例下Pi的谓词执行序列INFOf进行变换处理,得到执行信息向量总和均值ESω不断重复数据分析和数据处理两部分的工作,直到计算出所有谓词的缺陷关联度.大小排序,输出最终的谓词排序结果.Pi和EFω(4)数据统计部分.将谓词按照缺陷关联度的下面我们给出Safla的算法描述,具体如下.算法1.Safla算法.输入:INFOs,INFOf输出:谓词的最终排序结果符号:TotalPass:成功测试用例数目;TotalFailed:失败测试用例数目;P:程序中所有插桩谓词的集合;犛(Pi,tl):测试用例tl运行时,谓词Pi的谓词执行序列;Pi,tl:测试用例tl运行时,在信息强度ω下,谓词Pi的犈ω执行信息向量;evaluate(INFOf):根据谓词在所有失败测试用例下的执行情况,选择信息利用强度大小的函数;stat(犛(Pi,tl),ω):根据信息利用强度ω,计算谓词Pi执行信息向量的函数;1.ForallPi∈Pdo2.ω←evaluate(INFOf)3.ForallINFOsandINFOfdo4.If犛(Pi,tl)∈INFOsthen5.犈ω6.else7.犈ω8.EndFor9.ESωpi←110.EFωpi←111.RPi=ESω12.EndFor13.根据缺陷关联度的大小对所有谓词进行排序4.4自适应数据分析与处理技术本节主要是对上述算法中所涉及的自适应数据分析与处理技术进行论述,相关技术主要体现在滑动窗口的选择与操作上.为了直观反映对谓词执行信息的利用强度,我们设计滑动窗口来对谓词执行序列中蕴含的信息进行提取,如图5所示.参数ω是滑动窗口的大小,控制着信息利用的强度.滑动窗口每次只可沿着谓词执行序列移动一位.在设计滑动窗口大小选择方案时,考虑到失败测试用例对于缺陷定位的重要作用[13],Safla选择谓词在失败测试用例下的执行情况作为分析对象,从中挑选出现频率最高的执行次数,并根据该执行次数选择滑动窗口ω的大小,具体方案如下:其中,W表示挑选出的执行次数,Wd和Wu分别是滑动窗口的下限和上限.按照该方案选择滑动窗口的大小,可以使信息利用的粒度最大化,对谓词执行信息的提取也更加充分,同时尽量避免文献[8]中等概率赋值情况的出现.需要说明的是,和大多数自适应策略一样,如何选择信息利用强度的大小是一种启发式的策略.因此,虽然本文的方法在制定信息利用强度选择策略时重点考虑失败测试用例,但是也可以存在其它操作情形.例如,综合考虑成功测试用例以及失败测试用例下的执行情况选择信息利用强度,或者当遇到成功测试用例较少的情况时,我们可以选择根据成功测试用例下的执行情况选择信息利用强度.对于这些策略的深入分析和比较,将是我们下一步的研究工作.对滑动窗口的操作包括以下两步:(1)将滑动窗口放在谓词执行序列犛(Pi,tl)的Page8起始位置,逐位移动滑动窗口,共获得δ=Len(S)-ω+1个长度为ω的子序列(其中Len(S)表示谓词执行序列犛(Pi,tl)的长度,要求Len(S)ω).(2)针对滑动窗口中长度为ω的子序列的值集合中每一种可能取值,统计其在δ个子序列中出现的次数,进行归一化处理,便构成信息强度ω下的执行信息向量犈ω中“0”和“1”分别出现的次数n0、n1,则执行信息向量为犈1evaluationbias;当ω=2时,记录滑动窗口中“00”、“01”、“10”和“11”分别出现的次数n00、n01、n10、n11,则执行信息向量为犈25实验Pi,tl=n0在本节中,我们将进行如下3部分实验:(1)信息利用强度选择有效性验证实验;(2)多种算法定位效果比较实验;(3)算法稳定性实验,以此来充分证明Safla的优越性.首先,我们对实验中使用的目标程序、算法评价准则以及实验设置进行描述,随后对实验结果展开分析.5.1目标程序参照大量相关工作,本文选取Siemens程序包中的全部7个程序以及一个实际程序space作为目标程序进行实验.表1中列举了目标程序的主要信息.所有这些程序以及缺陷版本都是由Software-artifactInfrastructureRepository(SIR)网站上下载①.程序描述版本数可执行代码数测试用例数print-tokens(2个程序)词汇分析器17341~3554130schedule(2个程序)优先排队19261~2942710replace模式识别32505~5185542tot-info信息测量23272~2741052tcas高度分离41133~1371608spaceADL解释器386218134965.2评价方法本文选用P-score[9]作为比较各算法定位精度的主要评价方法.首先给出P-score的计算公式:其中,L为目标程序中的谓词数量,P表示程序中与缺陷最为相关的谓词,indexofP为该谓词在算法输出的谓词排位表中所排的位置.P-score可以解释为所需检查的谓词数量越少,则算法的定位精度越高.5.3实验设置Siemens程序包一共包含132个缺陷版本,在本文实验中共排除掉21个缺陷版本.其中,replace-v27和schedule2-v9没有失败测试用例,其余19个版本由于无法清晰确定缺陷谓词的位置,因此也予以排除,分别是print_tokens-v4,v5,v6;replace-v12;tcas-v7,v8,v13,v14,v16,v17,v18,v19,v33,v36,v38;tot_info-v6,v10,v19,v21.按照相同的原则,在space程序包中共排除掉10个缺陷版本,分别是v1,v2,v25,v26,v30,v32,v34,v35,v36,v38.本文选用文献[7]所采用的最相关谓词的选择策略:首先确定缺陷位置,若缺陷在可执行语句上,标记该可执行语句;若缺陷为可执行语句的缺失,则标记相距缺失语句最近的下一条可执行语句.其次,根据标记的可执行语句,选择距离该可执行语句最近的谓词作为程序中与缺陷最相关的谓词.通常,该谓词所在分支语句与标记的可执行语句之间不超过3行代码.在设置滑动窗口上下限时,由于窗口打开方能进行谓词执行信息的提取,因此设置Wd=1.另外,由于当ω6时,算法的时间复杂度太高,对一些程序而言,运行时间难以接受,所以在实验中我们设置Wu=5.5.4实验结果分析5.4.1信息利用强度选择有效性验证实验在研究动机中,我们指出,针对每个谓词选择合适的信息利用强度,不仅可以充分利用谓词的执行信息,还能够提高算法的定位精度.因此,在本节中,我们通过对Safla与Nbit-Pesla算法[8](N=2,3,4,5)的定位效果进行比较,来验证Safla中加入的动态信息利用强度选择方案的有效性.在各统计节点处,我们首先给出Nbit-Pesla算法分别在Siemens和space程序包上算得的P-score的最大值、最小值以及平均值结果,分别如图6和图7所示(图中横坐标表示所需检查谓词占全部谓词的百分比,纵坐标表示发现缺陷占全部缺陷的百分比.之后各图横纵坐标所表示的物理意义均与本图相同,故不再赘述).由于space程序包较大,其中①http://sir.unl.edu/portal/index.phpPage9包含的谓词数量较多,而且当检查少量谓词时就可以发现大部分的缺陷,因此图中space与Siemens的横坐标设置不同.图6Safla与Nbit-Pesla算法在Siemens上定位效果对比图7Safla与Nbit-Pesla算法在space上定位效果对比在此基础上,我们又给出Safla的定位结果.由图6和图7我们可以看到,只有在图7的10%统计节点处,Safla的定位效果不如Nbit-Pesla算法中的最优结果.但是,如果考虑到如下两个因素:(1)对于space程序而言,检查排位表中前10%的谓词就意味着需要检查大约91个谓词(10%×914=91.4),代价较大;(2)当检查前5%的谓词时,就可以发现超过85%的缺陷(24/28=0.8571),继续增加检查的谓词数量,所发现的缺陷数量却增加并不明显.我们可以认为,Safla的定位效果在整体上能够接近甚至超出Nbit-Pesla算法(N=2,3,4,5)中最优的定位效果.上述实验验证了本文所提出的针对不同谓词选择信息利用强度的方法是有效的,它能够较好地适应谓词在不同测试用例上的执行情况,大大提高算法的适应性,并能在一定程度上提高算法的定位精度.5.4.2算法定位效果比较实验在本部分中,我们将给出Safla、CBI[5]、SOBER[6]、Mann-Whitney、Wilcoxon、F-test、t-test算法[7]应用在Siemens程序包以及space程序包上得到的整体定位效果对比,分别如图8和图9所示.这些参与比较的算法都是近年来研究者所提出的基于谓词的统计学缺陷定位算法.图8各算法在Siemens上整体定位效果对比由图8我们可以发现,在9个统计节点中,相比其它的6种算法,Safla的定位效果都是最好的.举例说明如下:当检查10%的谓词时,Safla可以定位出35.14%的缺陷,其它6种算法中表现最好的Wilcoxon也仅能定位出17.11%的缺陷.Safla定位到的缺陷数量接近Wilcoxon的2倍,Mann-Whitney的5倍,是其它算法的7~30倍.由图9可以看出,在space程序包上,Safla总体定位效果接近非参数假设检验方法中最好的Mann-Whitney和Wilcoxon,远高于其它的4种算法.当检查少量谓词时,例如检查1%的谓词时,Safla定位到的缺陷数量略少于Mann-Whitney(平均少定位出1个缺陷),而在2%节点处,Safla可以取得相比其它所有比较算法最好的定位效果.图10还给出了Safla、CBI[5]、SOBER[6]、Mann-Whitney、Wilcoxon、F-test、t-test[7]算法在Siemens7个独立程序上的定位效果对比.可以看到,除了在schedule(2programs)上的定位效果还有待提高外,在其它程序上Safla都能取得很好的定位效果.Page10图107个算法在Siemens程序包各独立程序上的定位效果对比5.4.3算法稳定性实验在本节中,我们主要对7种算法在单个缺陷版本上定位效果的差别进行实验比较,这些实验反映了算法在不同类型程序和缺陷上定位效果的稳定性.在表2中,“Min”表示使用相应算法定位缺表2各种算法在Siemens和space程序包上定位效果的详细对比F-test/%SiemensspaceMin1.590.110.890.113.450.114.440.774.500.773.700.110.910.77Max100.0045.51100.0046.78100.0048.46100.0095.40100.0094.97100.0095.68100.0094.97Mean29.175.2946.915.6653.385.5767.7126.4070.7425.8160.6417.2358.5825.81Stdev26.2412.2435.7115.2630.5615.7929.0926.9628.2326.9532.0631.1834.3426.95中,Safla都是表现最好的算法,即使用Safla进行定位缺陷时,可以在很大程度上获得更高的定位精从表2中可以看出,对于Siemens程序包的111个缺陷版本,在“Mean”和“Stdev”这两个指标陷时所得到的最小P-score;“Max”表示最大的P-score;“Mean”表示P-score的均值;“Stdev”表示P-score的标准差.在这4个指标中,后两个体现了算法在定位不同缺陷时所表现出的稳定性,其值越小,表明该算法的稳定性越好.Page11度.对于space程序包中28个缺陷版本,相比于CBI[5]、SOBER[6]、Wilcoxon、Mann-Whitney、F-test和t-test[7]这6种算法,Safla无论是在定位精度上还是在定位稳定性上都具有很大的优势.6有效性讨论影响本文结论有效性的因素主要有以下3个:(1)各算法的复现是否正确.(2)P-score评价方法是否有效.(3)目标软件的选取是否合适.首先,对于CBI算法和SOBER算法,本文按照文献[5-6]所述步骤进行复现,并用文献[7]中所列举的例子验证了其正确性.对于Wilcoxon、Mann-Whitney、F-test,t-test算法,我们直接利用ALGLIB数理统计软件进行实现,并用文献[7]中公布的实验数据进行了验证.因此可以认为本文对于各算法的复现应该是正确的,所得到的实验结果和数据也是有效的.P-score[9]是由Zhang等人于近几年提出,主要适用于基于谓词的方法,而本文所提出的算法以及选取出作为比较对象的算法均属于基于谓词的方法.因此,选用P-score作为评价各算法定位精度的标准也是合理的.Siemens程序包一直以来就是研究软件缺陷定位必选的实验对象之一,但是由于其中所包含的缺陷都为人工植入,很难代表真实的软件缺陷.而且代码行较少,属于小型程序.为此,本文增加了space程序包作为实验对象,得到了相同的结论,但这依旧不能排除对于其它实验对象,本文的研究会得到不同实验结果的情况.因此,在今后的研究中,考虑增加更大规模的程序作为实验对象仍旧是一个重要的方面.7结束语软件缺陷定位在软件调试过程中是一项异常费时费力的工作,在现有方法中,基于谓词的统计学缺陷定位方法在定位精度上已有良好的表现.但之前方法中信息利用的强度相对固定,无法针对谓词执行信息量的变化进行动态调节,这样就会不可避免的导致信息利用不足或过分利用情况的发生,从而影响定位精度的提高.在本文中,我们提出一种基于谓词执行信息分析的自适应缺陷定位算法,并用实验证明,根据测试用例运行时每个谓词提供信息量的多少来选择算法中信息利用的强弱是有效而且必要的.由于需要对不同谓词选择不同的信息利用强度,因此,针对不同谓词,如何更加公平地比较不同信息利用强度下的计算结果以及完善信息利用强度选择方案将是我们下一步研究工作的重点.
