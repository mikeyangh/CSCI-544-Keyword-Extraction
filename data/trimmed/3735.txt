Page1针对简化版Trivium算法的线性分析孙文龙1)关杰1)刘建东2)1)(信息工程大学电子技术学院郑州450004)2)(北京市2857信箱四室北京100085)摘要流密码Trivium算法是欧洲密码工程eSTREAM的7个最终获选算法之一.该文针对初始化为288轮的简化版Trivium算法进行了线性分析,更正了Turan等人给出的关于密钥、初始化向量和密钥流比特的表达式,并给出了当允许选取特殊的密钥和犐犞时,搜索最佳线性逼近式的算法.据此算法,找到了3个线性偏差为2-25的线性逼近式,改进了Turan等人给出的线性偏差为2-31的线性分析结果.关键词密码分析;线性分析;Trivium;流密码1引言为了发展安全快速的流密码算法,欧洲ECRYPT(EuropeanNetworkofExcellenceforCryptology)在2004年启动了eSTREAM[1]工程,Trivium[2]是7个最终获选的算法之一.以eSTREAM为代表的流密码评选工程的进行,极大地促进了流密码标准的制定进程.因此,作为流密码的杰出代Page2击、滑动攻击、立方攻击和猜测决定攻击等.Maximov和Biryukov[3]对Trivium进行状态恢复攻击和统计测试,恢复Trivium的内部状态需要的计算量为c·283.5,其中常数c是求解线性方程组的复杂度.Raddum[4]通过求解一个线性方程组来恢复288bit的初始状态,其计算复杂度为O(2164).Priemuth-Schmid等人[5]针对Trivium算法提出了滑动攻击,指出Trivium算法有多于239个滑动对.Dinur和Shamir[6]针对767个时刻的初始化Trivium算法实施了立方攻击,所需的计算复杂度为245比特操作.孙国平等人[7]通过错误注入的方法改变Trivium内部状态中的52bit,提出了一种基于选择差分的Trivium猜测攻击,攻击的计算复杂度为245.Turan等人[8]对初始化为288轮的简化版的Trivium算法进行了线性分析,找到了1个线性偏差为2-31的线性逼近式.贾艳艳等人[9]运用多线性密码分析理论,对文献[8]的结果进行了改进,提出了一种更有效的区分攻击算法.本文针对初始化为288轮的简化版Trivium算法进行线性分析,更正了Turan等人给出的关于密钥、初始化向量和密钥流比特的表达式,并给出了当允许选取特殊的密钥和犐犞时,搜索最佳线性逼近式的算法.据此算法,找到了3个线性偏差为2-25的线性逼近式,改进了Turan等人提出的线性偏差为2-31的线性分析结果.2Trivium算法描述2.1符号说明犓:80bit密钥,犓=(k1,k2,…,k80);犐犞:80bit初始化向量,犐犞=(iv1,iv2,…,iv80);st(i):第t时刻内部状态的第i比特,1i288;st:第t时刻288bit内部状态,st=(st(1),st(2),…,st(288));ti:更新比特,1i3;zi:第i时刻的输出密钥流比特;+:GF(2)上的加法运算;·:GF(2)上的乘法运算.2.2算法描述Trivium算法分为初始化算法和密钥流生成算法两部分:在初始化阶段,系统在t时刻使用特定位置的15bit内部状态更新t+1时刻的3bit内部状态,然后运行初始化算法4·288个时钟周期,不输出任何密钥流;在密钥流生成阶段,由3个移位寄存器的各2比特异或生成密钥流.具体算法用伪代码描述如下:(s1,s2,…,s80)←(k1,…,k80,0,…,0),(s94,…,s177)←(iv1,…,iv80,0,…,0),(s178,…,s288)←(0,…,0,1,1,1),fori=1toNdozi←s66+s93+s162+s177+s243+s288t1←s66+s91·s92+s93+s171t2←s162+s175·s176+s177+s264t3←s243+s286·s287+s288+s69(s1,s2,…,s80)←(t3,s1,…,s92)(s94,s95,…,s177)←(t1,s94,…,s176)(s178,s179,…,s288)←(t2,s178,…,s287)endfor3288轮Trivium的线性分析3.1基础知识线性密码分析[10]是Matsui在1993年欧洲密码年会上提出的一种对迭代型分组密码算法的已知明文攻击方法,其基本思想是通过寻找分组密码算法的一个有效的线性逼近来破译密码系统.线性密码分析的方法是寻找一个给定密码算法的具有下列形式的“有效的”线性表达式:P[i1,i2,…,ia]C[j1,j2,…,jb]=K[k1,k2,…,kc](1)其中,i1,i2,…,ia,j1,j2,…,jb和k1,k2,…,kc表示固定的比特位置,并且对随机给定的明文P和相应的密文C,等式(1)成立的概率p≠1/2,用p-1/2来刻画等式(1)的有效性,称p-1/2为线性偏差ε.如果p-1/2是最大的,将对应的线性表达式称为最佳线性逼近式.针对多轮的分组密码[11],首先对不同轮的非线性函数进行逼近,然后将各个逼近有效地组合,最终得到有效的线性逼近.分组密码的线性逼近的概率与每一轮线性逼近的概率都有关,可由下面的堆积引理来计算形如式(1)成立的概率.量,Pr(Xi=0)=pi,Pr(Xi=1)=1-pi,则引理1[11].设Xi(1in)是独立的随机变任意一个流密码都可以看作布尔函数Fi:FkPage32→F2,i=1,2,…的集合,其中Fi为由k比特密钥Fv和v比特iv生成第i个输出密钥流比特zi的函数.目前已经有人把针对分组密码提出的线性分析方法用于流密码算法的分析上[8,12],基本思路如下:流密码算法的初始化过程一般都是由相同的状态函数迭代一定的圈数实现内部状态变量的更新,为了便于寻找Fi的线性逼近,将初始化阶段分成n轮,其中第i轮有ti个时钟,对每一轮进行线性逼近,然后将每一轮的线性逼近进行有效组合,最终得到整个密码算法的线性逼近.由Matsui的线性密码分析理论[10],线性分析的成功率为3.2主要结论3.2.1修正方程有下式成立[8]:对于初始化为288轮的简化版Trivium算法,通过迭代,z1关于第144轮内部状态的方程如下所示:z1=s144(6)+s144(16)·s144(17)+s144(31)·s144(32)+s144(33)+s144(57)+s144(82)·s144(83)+s144(84)+s144(96)+s144(97)·s144(98)+s144(99)+s144(111)+s144(129)+s144(142)·s144(143)+s144(144)+s144(150)+s144(162)+s144(163)·s144(164)+s144(165)+s144(186)+s144(192)+s144(208)·s144(209)+s144(210)+s144(231)+s144(235)·s144(236)+s144(237)+s144(252)由堆积引理,式(5)以27·0.258=2-9的线性偏差逼近下式:z1=s144(6)+s144(33)+s144(57)+s144(84)+s144(96)+s144(99)+s144(111)+s144(129)+s144(144)+s144(150)+s144(162)+s144(165)+s144(186)+s144(192)+s144(210)+s144(231)+s144(237)+s144(252)对于式(6),将等式左边的密钥流比特z1通过迭代用密钥和初始化向量比特表示出来,经过分析我们发现文献[8]附录中Turan等人给出的密钥流比特z1关于密钥和犐犞比特的表达式有误,下面给出说明:(1)没有出现s0(79)这个变量,因此,z1关于密钥和犐犞比特的表达式中不存在二次项s0(77)·s0(79);(2)用二次项s0(76)·s0(77)表示的,只有s144(144)和s144(237)这两项,因此,两项异或后z1关于密钥和犐犞比特的表达式中不存在二次项s0(76)·s0(77);(3)用三次项s0(146)·s0(147)·s0(148)和s0(146)·s0(147)·s0(149)表示的只有s144(6)一项,因此,z1关于密钥和犐犞比特的表达式中存在三次项s0(146)·s0(147)·s0(148)和s0(146)·s0(147)·s0(149);综合(1)、(2)和(3)的分析,z1关于密钥和犐犞比特的表达式中不存在二次项s0(76)·s0(77)和s0(77)·s0(79),而三次项s0(146)·s0(147)·s0(148)和s0(146)·s0(147)·s0(149)是存在的.对于式(6)中第144轮的内部状态变量,通过迭代用密钥和犐犞比特表示出来,在这些表达式中:故对于式(6),文献[8]附录中Turan等人的表达式有误,进一步,我们使用MATLAB软件编程验证了(1)、(2)和(3),z1关于密钥和犐犞比特的正确表达式如下所示:z1=1+s0(3)+s0(6)+s0(15)+s0(21)+s0(27)+s0(30)+s0(39)+s0(54)+s0(57)+s0(67)+s0(68)+s0(69)+s0(72)+s0(96)+s0(99)+s0(114)+s0(117)+s0(123)+s0(126)+s0(132)+s0(138)+s0(144)+s0(165)+s0(171)+s0(4)·s0(5)+s0(13)·s0(14)+s0(13)·s0(41)+s0(13)·s0(119)+s0(14)·s0(40)+s0(14)·s0(118)+s0(16)·s0(17)+s0(19)·s0(20)+s0(19)·s0(47)+s0(19)·s0(125)+s0(20)·s0(46)+s0(20)·s0(124)+s0(22)·s0(23)+s0(25)·s0(26)+s0(28)·s0(29)+s0(34)·s0(35)+s0(37)·s0(38)+s0(37)·s0(65)+s0(37)·s0(143)+s0(38)·s0(64)+s0(38)·s0(142)+s0(39)·s0(40)+s0(40)·s0(119)+s0(41)·s0(118)+s0(43)·s0(44)+s0(45)·s0(46)+s0(46)·s0(125)+s0(47)·s0(124)+s0(49)·s0(50)+s0(52)·s0(53)+s0(58)·s0(59)+s0(58)·s0(164)+s0(59)·s0(163)+s0(61)·s0(62)+Page4s0(63)·s0(64)+s0(64)·s0(65)+s0(64)·s0(143)+s0(64)·s0(170)+s0(65)·s0(142)+s0(65)·s0(169)+s0(67)·s0(68)+s0(70)·s0(71)+s0(103)·s0(104)+s0(106)·s0(107)+s0(118)·s0(119)+s0(124)·s0(125)+s0(127)·s0(128)+s0(130)·s0(131)+s0(133)·s0(149)+s0(134)·s0(148)+s0(142)·s0(143)+s0(147)·s0(148)+s0(151)·s0(152)+s0(154)·s0(155)+s0(160)·s0(161)+s0(163)·s0(164)+s0(166)·s0(167)+s0(13)·s0(39)·s0(40)+s0(14)·s0(38)·s0(39)+s0(19)·s0(45)·s0(46)+s0(20)·s0(44)·s0(45)+s0(37)·s0(63)·s0(64)+s0(38)·s0(39)·s0(40)+s0(38)·s0(39)·s0(41)+s0(38)·s0(39)·s0(119)+s0(38)·s0(62)·s0(63)+s0(39)·s0(40)·s0(118)+s0(44)·s0(45)·s0(46)+s0(44)·s0(45)·s0(47)+s0(44)·s0(45)·s0(125)+s0(45)·s0(46)·s0(124)+s0(62)·s0(63)·s0(64)+s0(62)·s0(63)·s0(65)+s0(62)·s0(63)·s0(143)+s0(63)·s0(64)·s0(142)+s0(133)·s0(147)·s0(148)+s0(134)·s0(146)·s0(147)+s0(146)·s0(147)·s(148)+s0(146)·s0(147)·s0(149)3.2.2最佳线性逼近式的搜索算法观察可知,式(7)中共有79个非线性项:57个二次项和22个三次项,如果令式(7)中所有的非线性项均为0,则我们找到了该式的一个线性逼近:z1=1+k3+k6+k15+k21+k27+k30+k39+k54+k57+k67+k68+k69+k72+iv3+iv6+iv21+iv24+iv30+iv33+iv39+iv45+iv51+iv72+iv78由堆积引理,式(8)由式(7)逼近的线性偏差为278·(0.25)57·(0.375)22=2-67.13.综合式(5)~(8),由堆积引理,式(8)成立的线性偏差为ε=2·2-9·2-67.13=2-75.13<2-|K|/2=2-40(|犓|表示密钥规模,对Trivium而言,密钥规模犓=80).但是这个偏差太小,对于线性密码分析没有意义.此时,可以通过选择特殊的密钥和犐犞的方法来增大式(8)成立的线性偏差.设Ω犓={ki|ki=0,1i80}表示选择为0的密钥比特组成的集合,Ω犓表示Ω犓的规模;Ω犐犞={ivi|ivi=0,1i80}表示选择为0的犐犞比特组成的集合,Ω犐犞表示Ω犐犞的规模;n1和n2分别表示选择Ω犓和Ω犐犞之后式(7)中剩余二次项和三次项的数量,则式(8)成立的线性偏差ε为ε=2·2-9·2(n1+n2)-1·(0.25)n1·(0.375)n2=(0.5)n1+9·(0.75)n2经分析,对于式(7),选择不同的Ω犓和Ω犐犞将会影响式(7)中二次项数量n1和三次项数量n2,进而影响到式(8)成立的线性偏差ε的大小,但是文献[8]和文献[9]中并没有给出Ω犓和Ω犐犞的选择准则.下面,我们就这一问题给出搜索最佳线性逼近式的算法1.算法1.最佳线性逼近式的搜索算法.Ω犓和Ω犐犞初始化为空集;输入:Ω犓选择的规模n犓,Ω犐犞选择的规模n犐犞;1.集合Ω和Π初始化为空集,统计式(7)的所有非线性项中各个比特的频次,将频次最大的比特存入到集合Ω中;2.1.若Ω=1,判断Ω中比特类型,若为密钥则存入Ω犓中,否则存入Ω犐犞中;2.2.若Ω2,统计Ω中各个比特涉及到的二次项的频次,将频次最大的比特存入到集合Π中;2.2.1.若Π=1,判断Π中比特类型,若为密钥则存入Ω犓中,否则存入Ω犐犞中;2.2.2.若Π2,则任选Π中一个比特,判断该比特类型,若为密钥则存入Ω犓中,否则存入Ω犐犞中;3.根据选择的Ω犓和Ω犐犞,重新计算式(7);4.if(Ω犓<n犓)&&(Ω犐犞<n犐犞返回步1;elseif(Ω犓=n犓)&&(Ω犐犞≠n犐犞则停止搜索密钥比特,返回步1,继续搜索满足条elseif(Ω犓≠n犓)&&(Ω犐犞=n犐犞则停止搜索犐犞比特,返回步1,继续搜索满足条件elseif(Ω犓=n犓)&&(Ω犐犞=n犐犞输出:(Ω犓,Ω犐犞),()ε.定理1.当给定选择为0的密钥和犐犞比特的规模时,算法1搜索到的是最佳线性逼近式.即设定算法1搜索到的密钥和犐犞比特为0后,式(8)成立的线性偏差ε最大.证明.当Ω=1,将该比特设定为0,则消掉Page5的非线性项数量最多,显然式(8)成立的偏差最大.当Ω2,不妨设Ω={a,b},设比特a和b的频次为n,分别统计比特a和b涉及到的二次项频次,记为m1和m2(不妨设m1>m2),设未选择a或者b为0之前,式(7)中有r个二次项、t个三次项.若把a设定为0,式(8)成立的线性偏差为εa=(0.5)r-m1+9·(0.75)t-(n-m1);若把b设定为0,式(8)成立的线性偏差为εb=(0.5)r-m2+9·(0.75)t-(n-m2),显然εa>εb,因此欲使偏差最大,应选择a=0.应的最大偏差.表1(Ω犓,Ω犐犞)对应的最大偏差εΩ犐犞2—————————2-38.412-37.413———————2-39.412-37.412-35.412-34.414———————2-372-352-332-325——————2-382-352-332-312-306—————2-392-362-342-322-302-297—————2-382-352-332-312-292-288—————2-372-342-322-302-282-279————2-39.412-362-332-312-292-272-2610————2-38.412-352-322-302-282-262-2511———2-39.412-37.412-342-312-292-272-252-2412———2-38.412-36.412-332-302-282-262-242-2313———2-37.412-35.412-322-292-272-252-232-2214——2-39.492-36.412-34.412-312-282-262-242-222-2115——2-38.492-35.412-33.412-302-272-252-232-212-2016——2-37.492-34.412-32.412-292-262-242-222-212-2017—2-39.152-36.492-33.412-31.412-292-252-242-222-212-2018—2-38.152-35.492-32.412-30.412-292-252-242-222-212-2019—2-37.152-34.492-31.412-29.412-292-252-242-222-212-20202-39.982-36.152-33.492-30.412-28.412-292-252-242-222-212-20注:“—”表示在Ω犓和Ω犐犞取相应值时的偏差ε<2-40.根据表1的结论,攻击者可以依据攻击能力的大小利用算法1选择最佳的Ω犓和Ω犐犞.例如,若攻击者仅能够选择犐犞,则可以得到线性逼近式的最大线性偏差为2-39.98;若攻击者能够选择10个密钥比特和15个犐犞比特,则可以得到线性逼近式的最大偏差为2-20.附录1中给出了利用算法1搜索到的最佳密钥和犐犞比特的部分实例.特别地,根据算法1,如果选择如下10个特定的密钥比特和10个特定的犐犞比特时,有以下结论.表2(Ω犓=10,Ω犐犞=10)对应的最佳Ω犓,Ω()犐犞及εiv25iv31iv40iv50iv54iv58iv62iv67iv70iv73根据表2中Ω犓的不同选择,我们找到了如下3个线性逼近式,其线性偏差均为2-25:算法1就是按照这样的准则搜索满足要求的密钥和犐犞比特的.因此,当设定算法1搜索到的密钥和犐犞比特为0后,式(8)成立的线性偏差最大,即算法1搜索的是最佳线性逼近式.此外,我们给出的最佳线性逼近式的搜索算法具有普适性,可以把它进一步推广,用于其它密码算法的线性分析中.根据算法1,表1给出了不同的Ω犓和Ω犐犞对Ω犓z1=1+k3+k6+k15+k21+k27+k30+k39+k54+k57+k68+k69+k72+iv3+iv6+iv21+iv24+iv30+iv33+iv39+iv45+iv51+iv72+iv78;z1=1+k3+k6+k15+k21+k27+k30+k39+k54+k57+k67+k69+k72+iv3+iv6+iv21+iv24+iv30+iv33+iv39+iv45+iv51+iv72+iv78;z1=1+k3+k6+k15+k21+k27+k30+k39+k54+k57+k67+k68+k69+k72+iv3+iv6+iv21+iv24+iv30+iv33+iv39+iv45+iv51+iv72+iv78.特别地,如果选择10个特定的密钥比特和13个特定的犐犞比特时,我们可以找到如上的3个线性逼近式,其线性偏差均为2-22.3.2.3结果对比文献[8]中Turan等人选择规模为Ω犓=10和Ω犐犞=10的Ω犓和Ω犐犞,找到了1个线性偏差为2-31的线性逼近式;文献[9]中贾艳艳等人在文献[8]的Page6基础上,选择规模为Ω犓=10和Ω犐犞=13的Ω犓和Ω犐犞,找到了另一个线性偏差为2-31的线性逼近式;本文选择规模为Ω犓=10和Ω犐犞=10的Ω犓和Ω犐犞,找到了3个具有相同线性偏差2-25的线性逼近式;另外,若选取规模为Ω犓=10和Ω犐犞=13的Ω犓和Ω犐犞,可得到3个具有相同线性偏差2-22的线性逼近式.因此,本文的分析结果优于Turan和贾艳艳等人的结果,对比如表3所示.Turan等人[8]的结果(10,10)2-31126297.77本文的结果(10,10)2-25325097.77贾艳艳等人[9]的结果(10,13)2-31226197.77本文的结果(10,13)2-22324497.774结束语本文针对初始化为288轮的简化版Trivium算法进行了线性分析,更正了Turan等人给出的关于密钥、初始化向量和密钥流比特的表达式,并给出了当允许选取特殊的密钥和犐犞时,搜索最佳线性逼近式的算法.据此算法,找到了3个线性偏差为2-25的线性逼近式,改进了Turan等人提出的线性偏差为2-31的线性分析结果.此外,该搜索算法可以进一步推广到其他密码算法的线性分析中.如何对更多轮的Trivium算法进行线性分析是值得进一步研究的问题.
