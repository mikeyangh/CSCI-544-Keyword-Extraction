Page1一种基于程序变异的软件错误定位技术贺韬1),2)王欣明3)周晓聪1)李文军3)张震宇4)张成志2)1)(中山大学信息科学与技术学院广州510275)2)(香港科技大学计算机科学及工程学系香港)3)(中山大学软件学院广州510275)4)(中国科学院软件研究所北京100190)摘要发现软件不能正常运行后,如何定位错误代码在程序中的位置是软件开发一个众所周知的难点.最近许多软件自动调试技术通过分析成功和失败测试用例的覆盖信息辅助程序员定位错误代码,但这些技术的准确率会受到偶然性成功测试用例的影响.偶然性成功测试用例执行了错误代码,但却没有引发失败的测试结果.研究表明这种测试用例在实际测试中广泛存在,而它们的存在会显著降低错误定位的准确率.针对此问题,文中提出一种称为Muffler的技术.Muffler使用程序变异分析来修正错误代码定位结果,以提高定位的准确率.文中利用8个在错误代码定位研究领域广泛使用的基准程序验证了Muffler的有效性.实验结果表明,与传统错误代码定位技术相比,Muffler能减少程序员50.26%的错误定位代价.关键词软件调试;错误定位;程序变异分析;软件工程1引言最近许多软件自动调试技术通过分析成功和失败测试用例的覆盖信息辅助程序员定位错误代码,例如Jaccard[1]、Tarantula[2]、Ochiai[3]和χDebug[4]等.这些技术统称为基于覆盖信息的错误代码定位(Coverage-BasedFaultLocalization,CBFL[5])技术.CBFL技术通常从成功和失败测试用例的运行中收集程序代码的覆盖信息(分析代码的粒度可有不同选择,如语句[1-4,6-7]、分支[8-9]或函数等),然后根据这些覆盖信息,为每段代码计算错误疑似度,也即程序代码的覆盖信息与失败运行结果的关联度.直观地说,一段代码如果经常被失败用例覆盖,但却很少被成功用例覆盖,则这段代码的错误疑似度就很大.程序员可按照错误疑似度由高至低的顺序检查程序代码以找到错误位置.尽管CBFL技术取得了初步成功[7,10-11],但其准确率仍受到许多负面因素影响.已有研究[10,12]指出,偶然性成功测试用例(CoincidentalCorrectness)是最重要的负面因素之一.偶然性成功测试用例指的是这样的成功测试用例:它覆盖了程序的错误代码,但却未引发失败的运行结果[13].偶然性成功测试用例的出现会显著影响CBFL技术的准确率,因为它们的出现降低了错误代码和失败运行结果的关联度.同时研究[5,14-15]指出,偶然性成功在实际测试中广泛存在.因此降低偶然性成功测试用例对提高CBFL技术的准确率很有意义.然而降低偶然性成功测试用例的负面影响是一个很困难的问题,因为很难准确区分哪些成功测试用例是偶然性成功用例,除非已经知道程序错误代码的位置,但这正是调试的目标.目前仅有少量工作尝试解决此问题.Wang等人[15]提出一种使用上下文模式来提炼覆盖信息.他们假设程序员预先知道程序的错误类型并通过这些错误类型的模式来排除偶然性成功用例引入的错误代码覆盖.但在实际开发中,该假设不一定成立.Masri等人[16]提出一种区分偶然性成功测试用例的启发式方法.但该方法并不十分准确,实验结果表明该方法会产生超过41.3%的错判率,以致对提高错误代码定位技术准确率没有明显的帮助.针对已有工作的不足,本文提出一种新的思路,不需要程序员预先判断程序的错误类型,也不需要区分哪些成功测试用例是偶然性成功测试用例.我们的核心想法是利用程序变异分析(MutationAnalysis)降低偶然性成功测试用例的影响.该想法基于这样的观察:对于一个成功测试用例,假如变异程序的错误代码后再执行它(即把原来的代码替换为另一段不同的代码),那么不管它是否是偶然性成功测试用例,测试结果趋向于不变,因为这只是将一个错误改为另一个错误,并没有增加程序的错误数;然而,若变异程序的正确代码,那么这个用例的测试结果很可能就从成功变为失败,因为这时程序多了一个额外错误,也就增加了出错的概率.根据这种观察,我们认为不同代码段变异后引发的由成功变为失败的测试用例数提供了新的错误定位线索.相比于代码覆盖,这种线索较少受偶然性成功测试用例的影响,用它修正代码覆盖所推导出的结果,可减少偶然性成功测试用例的负面影响,从而更准确地评估代码的错误疑似度,提高错误定位的准确率.我们开发了一套称为Muffler的软件实现了上述想法,应用在错误定位研究中广泛使用的Siemens基准程序集[14]的7个程序共123个错误程序版本上,并与多个CBFL技术进行了实验比较.实验结果表明,与目前最好的CBFL技术相比,Muffler把平均代码检查率从19.34%降到9.62%,减少比例为50.26%(=100%-(9.62%/19.34%)).我们还使用了一个实际应用程序space及其真实错误版本,展示Muffler在实际应用中的有效性.本文的主要贡献有两方面:(1)提出一种利用程序变异分析提高错误定位准确率的方法;(2)报告了一组实验及其结果,说明本文的方法比现有CBFL技术能更准确地定位程序的错误代码.本文第2节简述现有错误定位技术和程序变异技术;第3节在使用完整例子说明本文方法基本思想的基础上,给出Muffler系统的总体工作流程和在变异分析方面的设计要点;第4节给出验证Muffler系统有效性的比较实验及其结果;第5节总结全文并展望下一步工作.2研究背景近年来出现了许多CBFL技术,例如Tarantula[2]、Ochiai[3]、χDebug[4]和Naish[17]等.CBFL技术的核心部分是根据程序代码的覆盖信息和测试结果计算程序代码错误疑似度的公式.代码覆盖信息的分析粒度可以是语句、分支或函数等,但多数CBFL技术针对程序语句进行分析.Naish等最近的研究[17]表Page3明,他们提出的公式比30多种现有公式能更准确地定位程序错误.其公式的定义如下:SuspNaish(Si)=Failed(Si)×(TotalPassed+1)-Passed(Si)(1)其中,SuspNaish(Si)是语句Si的错误疑似度,Failed(Si)和Passed(Si)分别是覆盖语句Si的失败和成功测试用例数,TotalPassed是成功测试用例总数.由于大部分CBFL技术仅在疑似度计算公式上不同,本文以4种知名的CBFL技术,即Tarantula、Ochiai、χDebug和Naish,作为代表进行分析比较,更多技术可参阅文献[17].程序变异测试与分析(ProgramMutationTes-tingandAnalysis)是由Hamlet[18]和DeMillo等人[19]提出的一种基于错误植入的软件测试技术.这种技术主要用于衡量测试用例集发现错误的有效性.变异测试通过在程序中逐个引入符合语法的变化,把原始程序变异成若干变异程序,以检验测试用例集的错误检测能力.本文主要利用变异测试技术的错误植入能力,在指定程序语句上产生符合语法的程序错误,并利用随之带来的测试结果变化预测该程序语句存在错误的可能性.程序变异测试与分析在原始程序上应用变异算子(MutationOperator)以植入错误.根据变异对象的类型,变异算子可分为语句、运算符、变量、常量等类型[20];根据变异的行为,可分为替换、插入、删除3种类型.若原始程序和变异程序之间只应用了一次变异算子,则称为一阶变异;若应用了多次则称为高阶变异.为设计简明与更清晰的分析,本文仅使用一阶变异.Papadakis和Traon在文献[21]中,尝试利用程序变异提高错误定位的准确率.其方法是对于程序中的每一个可执行语句S应用不同变异算子生成若干变异程序,然后对每个变异程序运行CBFL算出一个S的错误疑似度,最后把其中的最大值作为S的最终错误疑似度.该研究在Siemens程序集上进行了实验,比较了不同程序以及不同规模测试集上的结果,说明了其方法在不同场景下的有效性.不过,文章并没有解释为何从不同变异程序中得到的最大疑似度赋给各个语句后会具有可比性,也并未深入探讨其方法起作用的原因.本文提出的Muffler技术根据语句变异前后测试结果的变化,尝试去解决现有CBFL技术的主要缺陷———偶然性成功的测试用例,不仅提高了现有CBFL技术的准确率,也因此解释了其作用的内部机理.3基于变异分析的错误定位技术这一节首先结合一个例子详细说明基于变异分析的错误定位技术的基本思想,然后给出Muffler系统的设计与实现,并重点说明Muffler系统针对错误定位的要求对程序变异所做的优化.3.1基本思想图1给出了各种错误定位技术(包括本文提出的技术)对Schedule程序的v2版本中一个程序片段所有语句错误疑似度的计算,以说明CBFL技术的应用和本文提出的方法的基本思想.图1第一部分给出了该程序片段,注意语句S2和S3上有一个错误,导致错误的队列下标n.但错误的n值不总是会触发导致错误的程序输出,产生失败的测试结果.实际上,执行语句S2和S3的1592个测试用例中,只有210个失败测试用例,其余1382个测试用例均为偶然性成功.图1第一部分也给出了成功和失败测试用例总数及覆盖每条语句的成功和失败测试用例数,例如2440个成功测试用例有1798个覆盖S1,而210个失败测试用例都覆盖S1.图1第二部分给出了Tarantula、Ochiai、χDebug和Naish的语句错误疑似度计算结果,其中susp列是每个语句的错误疑似度,r列是每个语句按错误疑似度由高至低排序的排名.错误语句的排名一定程度上度量了程序员定位到这个错误需要的代价[22].从图1我们可看出,这些CBFL技术都需要检查88%的语句才能定位到错误语句S2和S3,因为若按照错误疑似度从高到低的顺序检查语句,除S1外其它语句都需要检查,也即检查语句的总数占总语句数的88%(≈7/8).从此例可看到高偶然性成功测试用例率(此例是1382/2440=56.6%)对CBFL技术准确率存在着负面影响.图1第三、四部分给出了本文提出的在程序变异分析基础上的语句错误疑似度的计算.图1第三部分给出该程序片段每条语句的变异示例及其影响.该程序片段中有8条语句S1~S8,分别变异这8条语句,每条语句产生5个变异程序,总共产生5×8=40个变异程序,对40个变异程序重新运行原先的测试用例,得到原本成功而变异后失败的测试用例数,如图1第三部分的“Changep→f(MSi,j)”所示.例如,将语句S1中的变量“block_queue”加上逻辑非“!”得到对应该语句的第1个变异程序MS1,1,对应地有Changep→f(MS1,1)=1644个原先成功的Page4测试用例在MS1,1上运行变为失败测试用例.又例如,Changep→f(MS3,2)=1116表示有1116个原先成功的测试用例在语句S3的第2个变异程序MS3,2上运行变为失败测试用例.注意,图1第三部分变异示例仅给出了每条语句的一个变异,其它4个变异受篇幅所限没有一一列出.图1第四部分“Impact”列统计了变异每条语句后成功测试用例变化的平均数,我们将其定义为对应语句Si的变异影响Impact(Si):图1各种错误定位技术对“schedule”程序的错误版本v2的一个程序片段的错误疑似度计算根据这种观察,我们认为在计算疑似度的时候引入变异影响可提升CBFL技术的准确性.为此,我们在Naish错误疑似度计算式(1)的基础上加入变异影响,得到如下计算公式:SuspMuffler(Si)=SuspNaish(Si)-Impact(Si)(3)式(3)是我们开发的Muffler软件目前采用的公式.实际上,也可将变异影响用于其它CBFL技术的计算公式.图1第四部分的Susp列给出了例子程序片段,每条语句用式(3)计算出的错误疑似度,而r列给出了对应的排名.按照该排名,只检查25%的语句即可定位到错误语句S2和S3,比前述CBFL技术88%的错误定位代价有显著提高.3.2Muffler系统设计我们设计并实现了名为Muffler的原型系统.该系统可以自动地生成变异程序、嵌入监控代码、运其中m是每条语句的变异个数,在这里的例子中m=5.过去的研究[23]与我们的初步实验显示,m=5的抽样已经能得到接近全部变异程序的结果.可以看到错误语句S2和S3的变异影响比其它语句低,这印证了前面所说的基本观察:变异错误的程序语句更趋向于保持成功测试用例的测试结果,而变异正确的程序语句则更趋向于改变成功测试用例的测试结果.行测试用例并收集覆盖信息.Muffler利用变异影响计算每个可执行语句的疑似度,给出疑似度由高至低的语句排序列表.图2给出了Muffler原型系统的数据流图.类似其它错误定位工具,Muffler接收错误程序和对应的测试用例集为输入,最终输出帮助定位错误的疑似语句排序列表.Muffler的工作流程如下:(1)给定一个错误程序和相应的测试用例集,Muffler首先运行测试用例,并收集覆盖信息和测试结果;(2)基于减少变异语句数目、提高运行效率的考虑,Muffler选出覆盖最多失败用例的语句作为变异候选语句;(3)对每个变异候选语句,Muffler逐个应用变异算子以生成所有可能的变异程序,然后从中随机选择固定数量的一部分来衡量该语句的变异影响;(4)MufflerPage5在测试用例集上运行每个被选择的变异程序,收集测试结果的变化,计算每个语句的变异影响;(5)Muffler基于变异影响和原始程序的覆盖信息,计算每个语句的错误疑似度.3.3Muffler系统中变异分析的优化针对错误定位的需要,Muffler系统对需要变异的语句数进行了控制,并对初步变异后的程序进行抽样以减少需要运行测试用例的变异程序数从而提高整个系统的效率.我们的研究目标是要提升CBFL技术的准确率,因此只对那些错误疑似度排在错误语句之上的正确语句感兴趣,而没有必要考虑程序中所有的可执行语句.例如,对于没有被任何失败用例覆盖的语句,并没有必要做变异分析,因为它们不可能是错误语句.CBFL技术对这些语句也总是赋予最低的错误疑似度.目前,Muffler系统的筛选策略是选出被超过K个失败测试用例覆盖的语句进行变异分析;K可以由程序员根据触发失败用例的错误个数指定.若程序员明确知道所有失败用例由同一个程序错误触发,例如在本文的实验中,K就可以取失败用例总数TotalFailed.此策略可显著减少做变异分析的语句数,从而提高整个Muffler系统的效率.根据一条语句中语法单元的不同,可用的变异算子也不同,产生的变异程序数目也不同.为统一变异每条语句生成的变异程序数,Muffler使用由Acree[6]和Budd[24]提出的变异程序抽样技术.变异程序抽样技术首先会生成所有可能的变异程序,然后随机选出x%的变异程序运行.Mathur和Wong的研究[23]指出,测试时使用10%的抽样率已经能得到和使用全部变异程序接近的结果.初步的实验也表明,此结论对于程序调试同样有效;并且基于选择变异技术[25],仅使用全部变异算子的一个有效子集,实验结果比使用全部变异算子的结果略差,我们发现这是由于对于部分错误语句无法生成对应的变异程序.因此,Muffler中对每个可执行语句应用所有变异算子,随机选出m=5个(抽样率约等于10%)变异程序进行实验.4Muffler系统的实验评估本节报告Muffler与CBFL技术的4个代表(Tarantula[2]、Ochiai[3]、χDebug[4]和Naish[17])的实验比较结果.这里首先给出用于实验的目标程序和实验环境,然后给出实验结果及相应的分析,并讨论了Muffler系统的时间效率,最后给出在一个实际应用程序和真实错误上对Muffler系统的实用性和准确性所做的进一步验证.4.1实验目标程序与实验环境我们使用Siemens程序集的7个程序,分别是tcas,tot_info,schedule,schedule2,print_tokens,print_tokens2和replace.同时还使用真实的程序space观察Muffler方法在真实错误上的有效性.之前的错误定位研究[5,7,22,26-27]也使用这些程序进行实验比较与分析.所有程序及其错误版本均从软件基础设施库的网站[28]下载.表1列出了这些程序的基本情况.程序集版本数可执行语句数测试用例数LOCtcas4163~671608133~137tot_info23122~1231052272~273schedule9149~1522650290~294schedule210127~1292710261~263print_tokens7189~1904130341~343print_tokens210199~2004115350~355replace32240~2455542508~515space383633~3647135855882~5904Page6Siemens程序集总共包含132个错误程序版本,但我们排除了其中9个版本:程序replace的版本v27和程序schedule2的版本v9因为没有失败测试用例而被排除;程序schedule的版本v1、v5、v6和v9,程序print_tokens2的版本v10,程序replace的版本v19和v27因为失败用例发生了段错误(SegmentationFault)未能收集到完整的覆盖信息而被排除.最终我们使用123个错误版本进行实验.对于变异程序运行测试用例时发生的段错误,我们将该测试用例标记为失败.我们的实验环境是一台配置2.93GHzIntelCorei3CPU和4GB物理内存的计算机;操作系统是Ubuntu10.04.2LTS,使用2.6.32-29-generic版本的Linux内核.我们使用Python2.6.5编写Muffler系统的核心代码,调用gcc4.4.3和gcov4.4.3编译程序和收集覆盖信息.我们利用Proteum[29]提供的所有变异算子生成变异程序并使用变异程序抽样技术筛选出m=5个变异程序作为代表.4.2实验结果与分析Naish等人观察到Naish公式在现有的CBFL疑似度计算公式中最为有效[17].为简化本文,我们仅比较Muffler和近期引用较多且最为有效的4种方法:Tarantula、Ochiai、χDebug和Naish.图3给出了Muffler和这些CBFL技术的全面比较.图3描述了在123个错误版本中,有多少比例的错误版本可在检查低于某个比例的代码后即检查到程序错误.纵坐标是错误版本的比例,横坐标是按错误疑似度从高至低检查语句的比例.从图3可看到,检查1%的语句,Naish技术可找到17.07%程序版本的错误,而Muffler技术可找到28.46%程序版本的错误;当检查的语句数增至5%时,Naish技术可找到47.15%程序版本的错误,而Muffler技术可找到60.16%程序版本的错误.总览图3中全部[0%,100%]的代码检查区域,可看到,Muffler总比Naish能定位到更多错误,并且在超过60%语句被检查前,定位到所有错误.表2给出了在某个代码检查比例下,各技术能定位到的错误数.例如对于Muffler系统,检查不多于1%的代码,可找到35个错误版本的错误.表2各技术在给定代码检查比例时可定位的错误数代码检查比/%TarantulaOchiaiχDebugNaishMuffler1141819213553848565874105463686885155765808094206067848499307988919211040929898991175098991011021216099103105106123701011071171191238011412212212312390123123122123123100123123123123123从表2和图3可看出,Muffler方法结合了覆盖信息和变异影响两种信息的优势,在每个代码检查量下,都比现有的错误定位技术能更准确和有效地定位错误.表3进一步概括了各技术有效性统计数据.以Muffler为例,在找到错误前,程序员最少需要检查0%的程序语句,最多需要检查55.38%的程序语句;检查语句比例的中位数和平均值分别为3.25%和9.62%,标准差为13.22%.Min0.000.000.000.000.00Max87.8984.2593.8578.4655.38Median20.339.527.697.323.25Mean27.6823.6220.0419.349.62Stdev28.2926.3624.6123.8613.22从表3可看到,在5种技术中,Muffler总能在语句检查比例的最小值(Min)、最大值(Max)、中位数(Median)和平均数(Mean)上有最好的结果,且Muffler有更低的标准差(Stdev),这意味着此技术的表现将会更加稳定.总的来说,Muffler技术相比现有最好的Naish技术平均减少50.26%(=100%-(9.62%/19.34%))的代码检查量.注意到MufflerPage7技术和Naish技术的唯一区别在于Muffler技术额外考虑了变异影响这一因素,因此实验结果明确地支持了我们的结论,即使用变异影响修正CBFL技术的结果可以提高错误定位的准确率.4.3Muffler系统的时间效率分析上述实验说明通过结合程序覆盖信息和变异影响,Muffler技术能比现有CBFL技术更有效地定位错误.但同时Muffler也带来额外的时间开销,因为它需要在测试用例集上运行大量变异程序以收集语句的变异影响.若程序包含w个可执行语句,变异每个语句产生m个变异程序,对应的测试集包含n个测试用例,则总共可能需要运行n+w×m×n次程序.我们通过控制被变异语句的数目(减少w)和变异程序抽样(减少m)来降低Muffler方法的时间开销.在实际应用中,用户可以调节这两个参数在准确率和时间开销之间做出权衡.表4给出了Muffler技术和CBFL技术在每个目标程序上的平均时间开销.其中统计的时间主要包含了嵌入监控代码、执行测试用例和收集覆盖信息的时间开销.可看到,相对于CBFL技术,Muffler平均需要花费近62.59倍的时间.表4CBFL和Muffler在每个目标程序上的时间开销目标程序tot_infoscheduleschedule2print_tokensprint_tokens2replaceAverage表5给出了Muffler在时间开销方面更详细的信息,包括被变异的可执行语句数、总共的可执行语句数、生成的变异程序数和在测试用例集上执行每个变异程序的时间开销.例如程序tcas每个错误版本,平均有40.15个可执行语句被Muffler变异,平均每个错误版本有65.10可执行语句,平均生成了199.90个变异程序,在测试用例集上运行每个变异程序需要4.26s.目标程序变异语句数语句总数变异程序数运行时间/stcas40.1565.10199.904.26tot_info39.57122.96191.872.92schedule80.60150.20351.607.59schedule275.33127.56327.785.32print_tokens67.43189.86260.299.49print_tokens286.67199.44398.6712.54replace71.14242.86305.9313.30Average56.52142.79256.907.92可以看到,即使在采用了变异语句数量控制和变异程序抽样这两个策略后,Muffler系统仍然需要比较多的时间开销.作为提高错误定位效率的代价,这些时间开销主要花费在执行变异程序上.作为一个未来的研究方向,我们会尝试引入一些更进一步的策略提高系统的时间效率,例如忽略变异前未覆盖待变异语句的测试用例以及并行化执行变异程序等.4.4Muffler系统有效性在真实错误上的验证我们进一步利用真实世界中的space程序验证Muffler技术的有效性.表2也给出了space程序的基本信息.space程序提供了1000个测试用例集,每个测试用例集包含约150个测试用例.我们随机选择了一个包含153个测试用例的测试用例集,并选择了10个错误程序版本,代表不同的偶然性成功测试用例比例,以模拟真实的程序调试环境.表6给出了不同偶然性成功测试用例比例的错误版本的结果.此表的“CC%”列表示偶然性成功的测试用例占总的成功测试用例的比例.“代码检查行数”表示在遇到错误前需要检查的代码行数,分别列出了Naish和Muffler两种方法的结果.例如,版本“v6”的成功测试用例中有6.92%的偶然性成功测试用例,在遇到错误语句前,Naish技术需要检查40条语句,而Muffler技术仅需检查7条语句,代码检查代价减少量为82.5%=100%-(7/40).错误版本CC/%v5v20v21v10v11v6v9v1730.92v2848.57v2999.32从真实错误上的结果可看到,相比Naish技术,Muffler总是检查较少的代码就可以查到程序的错误.同时也可看到即使Naish技术已经取得了不错的效果时,即检查语句数低于50时,Muffler可以把检查语句数目进一步降低到更符合实际调试的级别,即检查少于10行或者20行语句.且当偶然性成功比例较高时,检查代码的减少量更加显著,这说明程序变异分析对于降低偶然性成功测试用例的负面Page8影响确实有显著作用.5结论与展望基于代码覆盖信息的错误定位技术(CBFL)分析成功和失败测试用例的覆盖信息以辅助程序员定位错误代码.在实际环境中常见的偶然性成功测试用例会显著降低CBFL技术的准确率.本文提出了一种结合程序变异分析和覆盖信息的错误定位方法来解决这个问题.此方法避开了之前方法的各种局限性,如需要程序员了解程序中的错误类型等,因此具有更广泛的应用.我们实现了一个原型错误定位系统Muffler,在7个程序的123个错误版本上将Muffler技术和现有的4个代表性CBFL技术进行了比较.结果显示,Muffler技术显著减少了定位到程序错误的平均代码检查量.实际环境中space程序的真实错误也进一步验证了Muffler的有效性.在未来工作中,我们计划将本文方法推广到多个程序错误的定位,并考察不同变异算子对于错误定位是否有不同影响,研究如何减少变异语句与变异程序数以进一步提高Muffler的效率.
