Page1路由协议的符号化测试生成邢熠1),2),3)叶新铭2)谢高岗1)1)(中国科学院计算技术研究所北京100190)2)(内蒙古大学计算机学院呼和浩特010021)3)(中国科学院研究生院北京100049)摘要协议一致性测试用于验证协议实现的正确性.文中根据路由协议的消息复杂特点,提出基于on-the-fly策略符号测试生成与动态执行的算法:建立了一种新的统一符号语义模型,该模型把数据操作和控制都抽象为动作行为;以该语义模型为基础,扩展了行为之间的关系以及一致性测试关系;给出了基于on-the-fly策略符号测试生成与符号动态执行的算法,在符号动态执行中,使用了统计的聚类算法来进行符号的数据选择.论文最后用具体的测试例说明该算法在OSPFv3协议一致性测试上的应用.关键词协议一致性测试;统一语义模型;符号测试生成;符号执行;数据选择1引言一致性测试可以有效地衡量网络协议的实现与协议规范说明的行为保持一致的程度,主要包括测试生成、执行.手工进行测试生成与执行具有效率低和覆盖不全面的缺点,自动化测试是改进这些缺陷的一个有效途径.协议规范的形式化模型是自动化测试基础,可以充分描述协议的行为与属性;通过形式化模型就可以定义被测实现与规范说明一致性的Page2标准,也就是一致性关系;根据一致性关系就可以产生抽象测试套,然后转化为可执行测试套,在测试执行系统上执行来验证被测实现是否满足一致性关系.在协议测试实践中,由于协议自身的复杂性,对形式化模型、一致性关系、测试生成、测试执行提出了更多的挑战.路由协议的突出特点是消息数据与行为的极大相关性.根据消息数据的不同属性字段,会产生完全不同的行为.如OSPFv3协议在建立邻居关系时,只有当收到期望的标识符,同时回应相应的响应才可能建立关系.所以在路由协议的一致性测试时就要充分考虑这种数据对控制行为的影响,行为和数据是不可分的.这些新的特点要求建模时就要统一考虑控制行为和消息数据.现有的路由协议测试研究主要集中在两个方面,一个是基于控制行为的测试生成.状态机[1-4]或标记变迁系统[5]模型进行测试生成主要关注协议说明的控制行为,而忽略了消息的处理,需要人工根据生成的抽象测试套加入消息数据形成最终的测试套,由于人工的介入,造成了测试套覆盖的主观性和不全面性.另一个是符号技术的测试产生.文献[6-9]在测试生成时,同时关注了控制行为和消息数据,而且消息数据采取了符号化的技术,但是对数据的处理和行为处理仍然采取独立的策略,同时忽略了符号化数据的选择问题.由于已有测试模型不能有效地解决路由协议测试,本文的工作围绕以下3个方面展开:第1个方面是基础,提出了一种新的路由协议的需求模型,集中在操作语义层面,给出了扩展的符号化输入输出变迁系统EIOSTS(ExtendedInput-OutputSymbolicTransitionSystem),主要拓展了行为的范围,不仅包括控制行为,而且涵盖消息数据上的操作,使得控制行为和数据操作采取统一的形式进行描述;从扩展语义模型出发,提出新的一致性关系,即扩展的符号一致性关系.第2个方面关于测试生成,本文采取on-the-fly和符号推迟策略来进行产生符号测试套,从而极大地减少了状态空间的容量.最后是关于符号测试套的执行,符号的实例化通过统计的聚类方法实现.根据以上的思路,文章按如下方式进行组织:首先提出协议操作语义模型,主要包括EIOSTS模型和相关的符号一致性关系;然后是符号化模型EIOSTS下测试框架,给出了该框架下的符号测试生成和符号测试执行算法,同时提出了基于聚类的数据选择算法;最后通过OSPFv3协议实例给出该生成算法的说明.2EIOSTS模型协议规范和被测实现的操作语义模型是产生测试的基础,本文使用扩展输入输出符号变迁系统EIOSTS描述协议规范和被测实现的行为活动和符号一致性关系.下面是该模型的语法和标记.2.1EIOSTS的语法和语义为了方便研究,本文使用的消息数据采取变量的定义.X表示变量集合,元素记为x,y,….F表示数值计算函数的集合,是从变量x到数值v的函数,记为ρ,ρ[v/x]表示把变量x换成数值v后得到的结果.对于路由协议,计算函数ρ包括解包Unpack、打包Pack、提取字段变量Get、变量赋值Entail、变量比较Choice、变量计算Com.Exp表示表达式的集合,记为e,它可以包含变量x和数值v,ρ(e)代表在表达式e上进行的计算.定义1.EIOSTS(InputOutputSymbolicTran-sitionSystems)是一个6元组EIOSTS=〈S,L,X,Σ,T,s0〉.其中(1)S表示系统的可数状态集.(2)s0表示初始状态.(3)X表示数据变量集,变量具有有限的值域.(4)L表示接口集.为了讨论方便,假定接口L分成输入接口LI和输出接口LO.(5)系统活动Σ={LI?x,LO!e,ρ(e)}∪τ,ΣO={LO!e|e∈Exp},ΣI={LI?x|x∈X},τ表示内部动作,Σm=ρ(e)表示消息数据的处理.(6)TS×Σ×S是变迁关系.简记为S→ΣS表示系统从状态S经历活动Σ后到达新的状态S.对于该模型,本文假定是强收敛的,即不会执行无限的内部活动.同时弱输入是可能的,即在任何情况下都不能拒绝输入活动.输入输出符号变迁系统可以图示为有向标记图,节点对应状态,标记边对应符号变迁.2.2EIOSTS的行为描述具备了以上的语义模型,就可以给出基于EIOSTS的行为描述.为了讨论上的方便,采用如下标记:P=〈S,L,X,Σ,T,s0〉;s,s∈S;a,a1,a2,…,an∈Σ;Page3ε表示空活动;σ∈(Σ)表示活动序列,ΟΣ表示活动集的子集.定义行为如下:(1)s→ρ(e)s表示系统在状态s进行数据处理ρ(e)后进入状态s.(2)sas≡defs1,s2∈S,sεs1→as2εs系统从状态经过可观察活动a到达状态s.(3)safterσ=def{s∈S:sσs}表示状态s经历某个可观察活动序列σ到达的某些状态s集.(4)safterσrefuseO=defs:sσsandinit(s)∩O=状态s经历可观察活动序列σ到达状态s,在状态s,系统不可能进行任何包含在活动集O中的活动.(5)safterσdeadlocks=defafterσrefuseΣ状态s经历可观察活动序列σ到达状态s;在状态s,系统不可能进行任何活动,进入死锁.2.3EIOSTS上的一致性关系为了便于讨论,被测实现、协议规范、测试器都建模为EIOSTS同时采取如下标记:u,i,s∈EIOSTS.文献[10]中定义了符号化一致性关系eiosconf,下面是该定义的形式化描述.定理1.i,s∈EIOSTS(ΣI,ΣO),ieiosconfsiffσ∈(ΣO∪ΣI∪Σm):out(iafterσ)out(safterσ)该定理表明,对于任意由输出、输入、数据计算形成的行为迹σ,如果在实现i执行所产生的输出包含在相应的规范上执行所产生的输出,就认为实现i与规范s满足一致性关系.3测试生成与执行3.1测试框架在协议规范和被测实现的模型以及符号化一致性关系eiosconf基础上就可以进行测试例的生成.我们仍然把测试例建模为符号变迁系统,根据文献[9]中测试例特性,采用如下的测试例定义.Σ,T,s0,υ〉,其中号变迁系统,而且只有有限的活动.定义2.测试例是一个7元组,t=〈S,L,X,(1)〈S,L,X,Σ,F,T,s0〉是确定的输入输出符(2)测试例在任何状态t只能在输入活动、输出活动、数据计算、等待或者静止中选择一种.(3)υ:S→{pass,fail}是断言函数.测试套T是测试例t的集合.3.2测试生成与执行基于符号变迁模型和变迁图的同构关系,本文采用变迁图的强连通图来产生测试例.由于数据处理行为直接影响了测试的选择和执行,本算法采取了动态生成和执行的两步策略.算法1是符号测试套的动态生成算法.输入是协议规范和测试目的,测试目的的作用就是在测试生成的过程中裁剪掉与之无关的分支,从而大大降低了状态空间,输出结果是符号化的测试套,符号化的数据还没有进行数据选择.算法2是符号测试的动态执行,输入是算法1的输出,即符号化测试套,在执行过程中动态地进行数据选择,从而实例化符号化数据,这样就可以裁剪掉与具体数据无关的分支,降低了时间和空间规模.算法1首先生成协议说明和测试目的的组合图,然后根据测试目的选择性地生成测试套.根据文献[11-12]给出图1的符号测试生成算法,输入是协议说明和测试目的的笛卡尔积,表示成符号变迁模型,即符号变迁图,测试目的增加了Accept和Reject状态便于测试选择.使用的数据结构Dfs_Stack:保存搜索过程中当前遍历序列的堆栈,Scc_Stack保存当下的联通分量Scc中所有已经访问的状态.节点s是个结构化的变量State.包含act:到达节点(状态)s的图边;number:访问编号;lowlink:根节点编号;L2A:LeadingtoAcceptstate.过程Adj_Set(p)··={(a,q)|(p,a,q)∈T}计算与状态p相连的状态和边的集合.SCC的构建过程中,遍历的边可以分为以下4类:tree-arc到达新状态的边,如果在同一个SCC中,就是tree-arcin,不同的SCC中,表示为tree-arcout;fronds从子孙到祖先的边;short-cut从祖先到子孙的边,同样分为short-cutin,short-cutout;cross-link从一个子树到另一个子树的边,细化为cross-linkin,cross-linkout.算法2根据符号数据的实例化对算法1得到的符号化测试套进行裁剪,形成最终可执行测试套.输入是符号化测试套Ts,输出是经过数据选择的实例化测试套TD.数据变量的实例化主要通过函数来实现:DataSelect().根据文献[13-18]数据说明SP的穷尽测试集exhaustive(SP)是数据项所有可能的实例化集合.通常exhaustive(SP)太大,并不实用,所以可以对被测实现的活动增加更强的假设来减少必要测试的数量,这些假设通称为选择假设,最常用的包括一致性假设和规则性假设.数据实例化的过程Page4可以采取两种策略,一种是用数据代数的所有可能值首先实例化,然后再进行数据值的选择;另一种策略是在实例化的过程中就采取一定的策略进行实例化,从而避免了后面的测试选择过程.本文中采取后一种策略.算法1.测试套生成:TG(State:pstart∈S×TP)/depthfirstsearch/State:psource,ptarget,ppred;Adj_set:Adjsource,Adjtarget,AdjpredbeginInit(Dfs_Stack);Init(Scc_Stack);pstart.number··=pstart.lowlink··=i··=i+1;pstart.act=ε;pstart.L2A··=pstart∈Accept;if(pstart∈Reject)thenremoveall(pstart,a,p)fromtransitionsTPush((pstart,Adj_Set(pstart)),Dfs_Stack);Push((pstart),Scc_Stack);whilenotemptyDfs_Stackdobegin(psource,Adjsource)··=top(Dfs_Stack);ifnotemptyAdjsourcethenbeginifptargetisn’tnumberedthenbegin/tree-arc/elsebegin/nottree-arc,isfrondorcross-linkin/if(ptarget.number<psource.number∧ifptarget.number<psource.numberthenelsebegin/Adjsourceempty/ifpsource.lowlink=psource.numberthenbeginifnotempty(Dfs_Stack)thenbeginendend算法2.测试套裁减:TD(State:Pstart∈Ts)/breadthfirstsearch/State:psource,ptarget.beginInit(Bfs_Stack);Init(TC_Stack);push((pstart,Adj_Set(pstart)),Bfs_Stack);whilenotemptyBfs_Stackdobegin(psource,a,ptarget)··=Pop(Bfs_Stack);endendend消息的数据选择过程采用了基于统计的聚类选因为在执行过程中动态生成和执行测试例,所以必须有相关的支持环境.过程getmessage(m),CheckConstraint(m),DataSelect(a,m),Outmes-sage(m)都是执行系统提供的支持服务.下面只介绍数据选择算法的架构.3.3数据选择算法择方法,使用框架法来表示消息.为了提高数据值的真实性,我们采取了基于网络监测的统计方法来生成数据框架的具体值.数据的来源是网络中实际运行节点所交换的各种消息样本.由于现实网络中消息中每个字段取值的多样性,采取聚类的方法将那些看上去会自然落在一起的样本集合在一起,形成相应的数据分类.最终的数据值会存入框架数据库中,以备后来的数据选择.现有的聚类算法主要是以下几种,即k均值聚类算法、递增聚类算法和基于概率的算法.由于协议消息字段都是数值类型,同时聚类的目标是寻找数据的最有可能的聚类,所以采取基于统计的聚类算法.统计聚类的基础是建立在一个称为有限混合的统计模型上.混合是指用x个概率分布代表x个聚Page5类,对每个具体数据实例,每个分布会给出它实属这个聚类的概率,每个聚类都有不同的分布.各个聚类并不是同等可能的,概率分布可以反应这种差异.这种算法的前提条件是已经知道了数据实例的概率分布和分布参数,通过贝叶斯公式很容易计算数据属于某个聚类的概率.假设论域上有m个聚类ω1,ω2,…,ωm;x是数据实例,x属于聚类ωi的概率如下:其中p(ωi)表示聚类ωi的先验概率.P(x/ωi)表示当输入x属于聚类ωi,x出现的条件概率.P(ωi/x)表示给定输入x,x属于聚类ωi的后验条件概率.它表明x发生的相对频率,值越大,表示发生的相对频率越高.贝叶斯聚类法则:若存在i∈{1,2,…,m},使得对所有的j(j=1,2,…,i-1,i+1,…,m)均有因为本文中处理的数据只有一个正整数属性,所以根据大数定理可以假定每个聚类呈正态分布.算法的输入取自网络监测中的协议消息样本,我们以OSPFv3消息的数据聚类为例在图3中说明算法3.数据聚类算法:DataCluster(m)输入:m={x1,x2,…,xn}是消息字段集,xi={di1,di2,…,din}是字段的样本数据集DataCluster(m){Prepare(m)/获得消息样本,并进行预处理,满足聚类的输入要求/swith(m.type){casehello:/邻居发现的聚类处理/{for(i=1;i<=n;i++){}caseDatabaseDescription:/数据库描述的聚类处理/{…}…}BsyesCluster(x){/基于贝叶斯统计的聚类算法x={d1,d2,…,dn}/Init_D={D1,D2,…,Dn}While(n>1){p(ωi/x)=f(x;ui,σi)×p(ωi)//根据正态分布的贝叶斯聚类式(2)计算聚类概率}p=max{p(ωi/x)}Di=Di∪{x}/合并聚类集合/}了算法.经过上述贝叶斯聚类算法,就可以形成每个字段的实际数据的聚类分析.只要把每个聚类的平均值存入框架数据库,在进行数据选择时,就可以根据聚类的种类来指导测试数据的生成.如在OSPFv3协议hello消息的helloInterval和Router-DeadInterval字段就可以通过聚类算法来获得实际的参考值.3.4算法分析在算法1的测试生成阶段,根据图论的结论,复杂度可以控制在O(n+|e|)以内.关于效率,首先由于测试目的的介入,大大减少了符号化测试例的数量,根据我们的实验研究,可以减掉80%以上的无用边,只留下了与测试目的相关的状态和变迁,形成了导向正确终点和错误终点的连通图.在算法2的测试执行阶段根据数据的动态选择策略,随机地执行变迁序列,从而裁剪了不可达的变迁,最终形成了测试变迁序列.与已有的符号化测试方法比较而言,TGV是提供了符号化的测试生成算法,但是在数据建模上,仍然采取了与控制行为不同的方式,如一阶逻辑等方法,这样就割裂了数据与行为之间的天然联系,所以在生成阶段数据只是符号的表示,没有充分体现数据的重要作用,并且没有延伸到符号的执行,形成了执行的空白.另一个工具是Torx,它提供了测试生成与执行的同步,但是没有考虑生成过程中数据的建模和执行过程的数据选择问题,而且在执行时都是随机选择执行序列,增加了测试的不确定性.本文在已经研究的基础上,统一了数据处理与控制行为的系统建模,在测试生成算法过程中采取了on-the-fly策略从而大大减少了测试例数量,最后在执行算法过程中引入了基于聚类的动态数据选择,又进一步减少了测试例的数量.4应用举例下面通过OSPFv3协议作为实例来说明上面提出的测试生成算法.OSPFv3协议规范说明SOSPFv3=〈Ss,Ls,Xs,Σs,Ts,ss0〉,测试目的TP=〈STP,LTP,XTP,ΣTP,TTP,sTP0〉.SOSPFv3用图4表示.该协议图表示在收到hello消息后,经过one-way状态进入到two-way状态,hello代表hello数据包,DD表示数据库描述符包.测试目的STP用图5来说明,该协议通过发送hello数据包建立双向关系.协议规范与测试目的的笛卡尔积在图6中给出.Page6执行算法1、2后所得到的测试例如图7所示,测试例中引入了Pass、Fail状态.图7中Hello_T1和Hello_T2消息都是测试器动态实例化后所得到的数据包,图8是以我们自己设计的测试例描述语言进行描述,该种描述语言已经移植到商业应用.在上述描述中,有些字段是通过聚类算法获得的取值,有些字段没有取确定的数值,而是用变量来表示,主要是为了方便用户的测试.用户可以在测试前和测试中根据具体值来实例化该字段,这种方法增加了执行时的灵活性.数据包格式:packetHello_Init{headerOSPF{Version=3//版本类型}OSPFChecksum}5结论现实协议的测试需求引入了符号化的测试模型,现有的基于符号化模型在进行测试生成时,截然分成两个阶段,第1个阶段是生成符号化的测试例,根据生成的策略,又可进一步分成静态生成和动态生成;第2个阶段是符号化测试套的执行,根据符号实例化的时机,也可以分成静态赋值和动态赋值.本文根据协议的现实需求,把测试生成和测试执行集成在一起,而且都采取了动态策略,这样就充分体现Page7了符号化模型的优势,避免了由于数据引入所造成的空间爆炸,在很早的阶段就裁剪了无用的分支,从而节约了空间和时间,极大地提高了效率.当然,在我们的实践中,对模型进行了一些假设,这不可避免地与现实有一些差距,主要是在数据的选择上不够智能化,希望在以后的工作引入学习机制,可以更好地选择与实际接近的数据.
