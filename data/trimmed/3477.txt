Page1一种优化关系型溯源信息存储的新方法王黎维1)鲍芝峰2)KOEHLERHenning3)周晓方3),4)SADIQShazia3)1)(武汉大学国际软件学院武汉430072)2)(新加坡国立大学计算机学院新加坡117417)3)(昆士兰大学信息技术与电子工程学院澳大利亚4072)4)(数据工程与知识工程教育部重点实验室(中国人民大学)北京100872)摘要现代数据管理必须处理来源不同、质量各异的数据,因此从系统层面支持数据溯源,让用户了解数据的来源及派生过程成为当前至关重要的一个研究课题.基于标注的方法是支持数据溯源的基本方法之一.这种方法的主要问题是存储空间开销,因为溯源信息可能会超过实际数据的大小.在该文中,作者提出了一个用与查询结构匹配的溯源树来表达和存储溯源信息从而避免数据派生过程中冗余存储的基本框架.基于这个框架,作者提出了一系列针对关系型查询的存储优化方法,选择查询树部分节点来存储溯源信息.这些优化算法对于查询大小是多项式时间,对于溯源信息大小是线性时间,在溯源信息的跟踪和优化方面均不会产生巨大的开销.这一框架是数据溯源研究的一个新思路,有着广泛的应用前景.关键词溯源树;溯源表;存储优化;最优削剪;规则I&II削剪1引言随着互联网和数据自动采集设备的快速发展,人们可利用的数据源以及数据量在过去的十多年里成指数倍增长,然而,数据的质量却每况愈下,究其原因,大量数据由传感器网络、RFID读入器和机器识别系统生成以及从网上自动收集,数据的完整性、一致性以及正确性无法得到保证.而许多科学应用和大规模数据管理应用通常需要收集和处理大量不同来源的数据,数据来源复杂,质量参差不齐,使得这些应用的数据和结果的可信度受到质疑.在系统层面上支持数据溯源,提供对数据来源及处理步骤有效方便地查询支持可以帮助用户理解数据和结果的可信度[1].数据溯源信息(provenance)描述数据的来源和派生过程,在数据库环境中,数据派生过程是指查询过程,而科学应用环境中的派生过程则可用整个工作流图表示.溯源信息对于判断结果的正确性以及可信度至关重要[2].在数据库环境中,它可以帮助解释意想不到的结果,并有助于数据集成[3].在科学应用环境中,它有助于诊断实验执行过程中的错误,探索未知的实验结果[4].在不确定性数据库中,它可以用来追踪概率变量之间的关联[5].数据溯源研究从类型上大致分为数据级溯源和过程级溯源,而数据库领域的研究侧重于前者[6].从溯源信息的存储粒度上分为粗和细两个粒度.在粗粒度层次上完成对溯源信息的追踪时,整个数据集的工作流图或查询过程作为数据派生过程存储.在细粒度层次上,每一个“对象”(可能指在实验中派生的单个结果,或者在数据库中一个元组或属性的值)都需要记录与它关联的溯源信息.粒度选择往往根据应用需求而定.虽然存储粗粒度的溯源信息不必过于关注存储空间,细粒度的溯源信息存储则带来一系列的挑战,因为细粒度溯源信息的空间需求往往远超过实际数据的存储大小[7].处理这个问题的方法之一是只有需要数据集的溯源信息时才通过逆过程(inversion)计算出它们,从而避免预先存储溯源信息导致的高昂存储代价[8].然而这一方法的缺点是如果没有高效的逆过程,计算代价会很高,同时它也可能需要存储查询中间结果来帮助计算溯源信息[9].本文主要关注关系数据库查询中溯源信息有效存储的问题,提出了一个类似于查询树的“溯源树”的数据结构用于溯源信息存储.在此结构中,具有相同派生过程但不同输入的元组被分在一个组,因此避免有关派生过程信息的冗余存储.虽然本文只陈述了关于数据库查询的溯源信息的存储方法,当任意派生过程能表示成树型结构时,这种存储溯源信息的方法也能适用.另外,由于“溯源树”这种存储结构具有较强的灵活性,文中也探讨了降低溯源信息存储成本的优化方法,即选择查询树中的部分节点而非全部节点来存储溯源信息.由于在一个节点中不存储溯源信息可能会导致其它节点溯源信息存储规模的增长,因此,考虑在哪些节点中存储是非常重要的,也是本文论述的重点.本文第2节描述“溯源树”以及总体框架;第3节讨论选择查询树中的部分节点来存储溯源信息的优化方法;第4节简要概述相关的工作;第5节进行实验测试以及结果分析;第6节总结全文.2溯源树本文主要考虑数据库查询的溯源信息.溯源信息可以在数据库中以不同粒度的形式存储,即数值粒度、元组粒度或表粒度.对于大多数数据库查询(不涉及用户自定义函数的查询),数值粒度的溯源信息可以以一种有效的方式从元组粒度的溯源信息派生.元组粒度的溯源信息也可以通过重新执行查询从表粒度的溯源信息中派生,或使用文献[9]中所述的逆过程派生.然而,涉及大数据集和复杂查询时,通过表粒度这种方法计算元组的溯源信息代价比较大,因此,通常存储元组粒度的溯源信息.目前已提出了许多不同的方式存储元组粒度的溯源信息,最常用的方法是将数据库查询的子查询作为溯源信息的一部分存储,然而,如果有多个元组共享相同的转换过程,那么在存储空间方面将产生巨大的开销.本文通过使用具有嵌套数据类型的树结构来存储溯源信息有效地解决了这个问题.定义1(溯源类型/元组/表).一个溯源类型(provenancetype)是通过基本类型tupleID构成的元组类型和集合类型的嵌套而构成.它的值域包含对元组的引用和一个特殊的空值⊥.(1)tupleID是一个基本溯源类型,简称为基本类型,表示一个基本元组的类型.(2)如果T1,…,Tn是溯源类型,那么(T1,…,Tn)是一个元组溯源类型,简称为元组类型.(3)如果T是一个溯源类型,那么{T}是一个集合溯源类型,简称为集合类型.Page3一个溯源类型的值被称为溯源元组(provenancetuple),类型为T的溯源元组的集合形成了一个类型为T的溯源表(provenancetable).(1)引用数据元组或者溯源元组的元组和⊥是类型为tupleID的溯源元组.(2)如果t1,…,tn分别是类型T1,…,Tn的溯源元组,那么(t1,…,tn)是类型(T1,…,Tn)的溯源元组.(3)如果t1,…,tm是类型T的所有溯源元组,那么{t1,…,tm}是类型{T}的溯源元组.例1.ri表示对元组的引用,那么(r1,{(r2,⊥),(r3,r4)},{{r5,r6,r7}}),是一个溯源元组,它的溯源类型为T=(tupleID,{(tupleID,tupleID)},{{tupleID}}).表1是一个类型为T的溯源表.r1r2一个数据元组的溯源信息可由一个溯源元组描述.由于中间结果表中的所有数据元组都以同样的方式派生,即使用相同的操作,因此相应的溯源元组将拥有相同的溯源类型,所以,可以将他们存储在一个溯源表中.所有的中间结果或最终的结果的溯源表形成了一个溯源树(provenancetree).定义2(溯源树).假设一个拥有节点集N和根节点R的查询树Q,Q的一个溯源树表示成一个二元组P=(PN,PO),其中PN是从节点N到该节点的溯源表的部分映射,其中,N中的叶节点(即基本关系表)没有被映射.PO是Q中的输出元组到PN(R)中的溯源元组的全部映射.例2详细阐述了溯源树的定义,其中,一个溯源树不包含数值,只包含对(数据或溯源)元组的引用.图2溯源树这里只存储溯源树,而不存储中间结果.例2.表2表示关系PropertyForRent,其中“ID”表示引用元组的数据库内部分配的元组号.IDP.1P.2P.3下面的SQL语句选择出租房产多于一处的机SELECTp.BranchNo,p.PropertyNoFROMPropertyForRentp,(SELECTBranchNo,PropertyNoFROMPropertyForRentGROUPBYBranchNoHAVINGcount()>1)sWHEREp.BranchNo=s.BranchNo图1是该查询对应的查询树,括号中的数字构和房产信息.〈·〉用于标识节点.图2显示了例2执行的中间结果以及对应的溯源树.其中,执行的中间结果显示在左边的树中,相应的溯源树显示在右边的树中.节点4中ID为4.1的元组,它的溯源元组为({P.1,P.2}).节点3中ID为3.1的元组,它的溯源元组为(4.1).节点1中ID为1.1的元组,它的溯源元组为(2.1,P.1).Page4定义3(完全/冗余树).一个溯源树P是完全(complete)的,如果每个输出数据元组被映射到一个溯源元组上,并且P中的溯源表上的每个不等于空值⊥的tupleID类型的数据项引用(1)P中的一个溯源元组,或者(2)对应于一个叶节点的基本表中的一个元组.与输出数据元组不关联的溯源元组被称为冗余元组,即该溯源元组从没被引用过.如果P中包含任何冗余元组叫树P是冗余的,否则就是非冗余的.例如,例2中显示的溯源树是完全的,但是冗余的,因为溯源元组4.2没有被引用过.本文在以下的论述中将仅仅考虑完全的溯源树.2.1溯源树的构造本节描述了一个简单的方法构造完全非冗余的溯源树.首先假设使用关系代数操作生成了一个查询树,为了迎合业界的SQL标准应该:(1)允许使用任意的选择函数.(2)使用多集(允许冗余)而不是集合.在多集上的投影操作并不能消除冗余元组.(3)引入一个聚集操作α,下标表示聚集的属性和分组函数.(4)引入一个替代操作β,用一些其它的元组代替关系(多集)中的每个元组.这些扩展不会对溯源信息的存储问题造成影响.而集合上的投影操作能表达为先进行多集上的投影操作,然后再对投影之后的结果进行聚集操作.并操作和交操作也是多集操作的一种.每个操作的初始溯源树都能直接被构造.每个操作的溯源类型在以下标出,即与使用这个操作派生的查询结果相关联的溯源表的溯源类型.(1)选择(selection)σ:tupleID;(2)投影(projection)π:tupleID;(3)差(minus)tupleID;(4)替代(replacement)β:tupleID;(5)并(union)∪:(tupleID,tupleID);(6)连接(join)(7)交(intersect)∩:(tupleID,tupleID);(8)聚集(aggregation)α:{tupleID}.本文阐述的溯源的概念与文献[6]中的术语“why-provenance”非常类似.这表示溯源信息需要获取每个输出元组的所有输入元组.对于选择、投影、差和替代操作,每个输出元组实际上都是从一个输入元组中计算得到.对于连接和多集交操作,每个输出元组由两个输入元组创建.对于并操作,一个元组由两个表中的其中一个拷贝得到,通过使用一个二元组,并用⊥值描述另一个源元组的缺失,能结构化的标识一个元组来自哪个输入关系.多集交操作能被表达为先进行聚集操作用于消除冗余,然后进行集合交操作.对于聚集操作,每个输出元组通过一组输入元组派生,因此,需要将所有这些元组存储起来.当然,如果聚集操作是求最大最小值,那么只需要将最大最小的元素存储起来即可.总之,执行查询时,首先自底向上构造初始的溯源树.然后采用自顶向下的方式,消除多余的溯源元组.这种方式获得的溯源树是完全非冗余的,也是进一步优化的出发点.例如,将图2中多余的溯源元组4.2删除,便可得到完全非冗余的溯源树.2.2溯源树的存储溯源树可以使用支持复杂类型,尤其是支持元组和集合类型嵌套的存储系统直接存储.如果需要在关系数据库系统中存储溯源树,即无需使用外部结构直接处理溯源信息的计算、存储和查询,那么可以采用文献[10]中类似的方法,将溯源树的节点对应的溯源表映射成关系表的来存储溯源树.例如,如果溯源表R中有一个元组t,({r1,…,rk})是t的溯源信息,也即溯源元组,那么,关系表R中将存储k个元组t1,…,tk,其中每个ti对应一个ri,1ik.这里的ri通过元组的行号来引用元组.本文主要探讨的是可以通过“溯源树”这种数据结构来存储溯源信息,而不是探讨溯源信息具体的物理存储,且本文的实现主要基于Java开发的一个关系查询引擎,因此,本文未着重关注溯源信息的物理存储结构.3优化溯源树只在查询树的部分节点而非全部节点中存储溯源信息将会使得存储更高效.3.1极端的解决方法当前的应用通常使用两种对立且极端的溯源信息储存方法.第1种方法称为“存储最终”,它只使用一个溯源表记录最终结果元组与基本元组之间的引用关系.第2种方法称为“存储全部”,这是另一个极端,因为它为每一个中间结果,即查询树的每个节点都存储一个溯源表.一些现有的方法可以归纳到以上的两种类别中.这些方法存储每次“转换”之后的溯源信息,这些信息是任意粒度的[11-12].将整个查询作为一个转换等同于“存储最终”.查询也可以使用σ,π,作来构成,如果将每个操作作为一个转换,那么就等同于“存储全部”.当然,也可以将查询分解成子查Page5例4.考虑一个查询R1询,对待每一个子查询作为一个转换.因此,关键是找到一个很好的分解,将其划成子查询.首先要分析存储最终和存储全部在总体性能上都比较差.例3.考虑一个查询σ1(σ2(…(σn(R))))由n个连续的选择操作构成(或者其它具有tupleID类型的操作).那么“存储全部”的方法所需的存储空间是“存储最终”的n倍.以至于r1和r2分别包含n个元组,r2中所有的元组被聚集成一个元组t2,并且r1中所有的元组都和t2连接.那么“存储全部”方法仅仅需要节点α(R2)上的n个引用,加上最终节点R1用,然而,“存储最终”方法需要在最终节点上n2个引用.因此,“存储最终”方法需要n存储空间.结合以上的两个例子,如σ1(σ2(…(σn(R1α(R2))))),两种极端的方法都不能产生很好的结果.由于这两种方法总体上都不是很好的解决方法,下面将探讨另一种方法,它只在查询树上的几个但不是所有的节点上存储溯源表.这里的关键问题是选择哪些节点存储溯源表.3.2基于规则的溯源树削剪对于削剪方法,首先根据2.1节的描述来构造“存储全部”的溯源树.然后通过将多个表中的溯源图3削剪的溯源树左右两个削剪的溯源树虽然形式不同,但却是同构的,因此,可以将溯源表移动到溯源树上不同的节点中存储,并重新命名引用,但不能改变它的内容.为了避免过于复杂的同构的定义,首先将溯源树转换成引用树(referencetree),然后定义引用树之间的同构概念.定义4(子类型/子元组).溯源类型(元组)之间的子类型(子元组)关系<P(<T)是以下规则的传递扩展.信息合并为一个溯源表来改进它.通过复制溯源元组,而不是引用它们来合并溯源表,显然有益于存储空间.这就引入了以下规则.规则I.当一个溯源表中的所有元组最多被引用一次时,复制所有元组的溯源信息而不是引用它们.规则II.当引用一个tupleID类型的溯源表时(即被引用的元组只包含一个引用),复制被引用元组的溯源信息.规则I表示不引入任何冗余,并避免存放额外的溯源表.考虑规则II的原因是引用一个tupleID类型的溯源信息不会比复制它所用的存储空间更小,同时也避免了存储额外的溯源表.引用被复制后,立即删除不再被引用的溯源元组,也就是不与输出元组对应的元组.构建削剪的溯源树的方法一般包括3个步骤:1.构造初始的溯源树.2.移除不被引用的溯源元组.3.使用规则I和规则II合并溯源表.对于最后一步,规则I和II可以以不同的顺序应用,这导致了不同的结果.根据2.1节,初始的溯源树是完全非冗余的,因此,将图2中的溯源元组4.2删除后得到的是初始的溯源树,再对该树以不同的顺序应用规则I和II,可以得到图3中显示的两个削剪的溯源树.其中,左面的树是先应用规则II得到的,而右边的树是先应用规则I得到的.(1)pi<P(p1,…,pn);(1)ti<T(t1,…,tn);(2)p<P{p};如果一个子类型(元组)直接遵循以上规则,而不是通过传递扩展得到,那么称它为直接子类型(元组).定义5(引用树).溯源树P的引用树是一个有向无环图(DAG),它由以下方式构建.每个被引用的基本元组为一个节点.对每个溯源元组t增加一个节点,节点上标记它所在溯源表的位置,同时,Page6为t的每个子元组增加一个无标号的节点.最后,在每个被引用的元组和引用它的元组之间增加一条弧,同时也为每个直接子元组关系增加弧.对于形式(1)中的直接子元组关系,用子元组在溯源元组t中的相应的位置i来标记弧.将图3中削剪的溯源树转换成了引用树,如图4所示.虽然在图4中,无标记的节点·似乎是没必要的,但是,当溯源元组包含嵌套的集合类型时却非常重要.例如,({tupleID},{tupleID}).定义6(同构).P1和P2是同一个查询树上的两个溯源树,双射:tupleID→tupleID是P1和P2的同构映射,如果(1)是P1和P2的引用树之间的一个图同构映射,其中P1和P2的引用树保留弧标记且与节点标记相容,即节点有相同的标记.节点有相同的标记当且仅当通过的映射,两节点同像;(2)固定基本(输入)元组,并且每个输出元组t被映射到相应的溯源元组:(P1(t))=P2(t).如果存在一个这样的,那么称P1和P2是同构的.容易看出同构是一个等价关系,如果12是P1和P2的同构映射,23是P2和P3的同构映射,那么2312是P1和P3的同构映射.定理1.P是一个溯源树.以任意的顺序应用规则I和规则II削剪P,直到不能再应用任何规则为止,那么由此产生的削剪的溯源树是同构的.证明.规则I和II的应用,可以被看作是同构的溯源树上的削剪步骤.根据著名的Church-Rosser定理[13],当两个不同的削剪步骤应用到同构的溯源树上并由此产生不同的溯源树时,可以通过进一步应用削剪步骤使它们达到同构.每一个削剪步骤(即规则I和II的应用)与一个非空的溯源表相关联,并且应用削剪步骤到相应的溯源表保留了溯源树之间的同构关系.接下来对一个溯源树进行削剪,使之产生一个不同但同构的溯源树.现在,假设P1和P2是两个同构的溯源树,δ1、δ2是两个分别应用到P1和P2中的溯源表T1、T2上的削剪步骤.如果T1和T2不邻近,也就表示T1和T2之间没有直接引用关系,那么δ1和δ2并不冲突,即δ1的应用不会阻碍随后δ2的应用,反之亦然.因此,应用δ2到δ1(P1)以及应用δ1到δ2(P2)可以获得同构的溯源树.最后,假设T1和T2邻近,且T1→T2.如果T1中的每个元组仅被引用一次(δ1使用规则I),δ2的应用不可能改变这个性质,所以δ1和δ2并不冲突.同样的,如果T2的溯源类型是tupleID(δ2使用规则II),δ1的应用也不能改变这个性质,因此δ1和δ2仍然是不冲突的.同理,应用δ2到δ1(P1)以及应用δ1到δ2(P2)可以获得同构的溯源树.还需要考虑一种情况,如果T1具有类型tupleID(δ1使用规则II),同时,T2中的每个元组被仅仅引用一次(δ2使用规则I),那么,应用了δ1之后,T2中的元组可能被引用多次,因此,规则I不能被应用.同样的,当应用了δ2之后,新产生的T1不具有类型tupleID,因此,规则II不能被应用.所以,δ1和δ2是冲突的.然而,δ1(P1)和δ2(P2)已经是同构的:与它们相关的同构映射能被构造成=Δ,其中Δ将T2中每个元组的tupleID类型映射到引用这个元组的T1中的元组的tupleID类型上.削剪一个溯源树可以在O(N)时间内完成,其中N是初始的溯源树中元组引用的总数.3.3最优溯源树削减虽然上面所述的削剪规则算法执行速度快且容易实现,但由此产生的削剪溯源树可能不是最优的.3.3节将描述一个多项式时间算法,当溯源树的确是一个树,而不是一个任意的DAG时,该算法采用了动态规划方法来寻找最优解.查询树中除根和叶节点之外的每个节点都必须考虑是否需要存储溯源表,需要存储的节点称为物化节点.这里采用tupleID类型的数量来衡量溯源表的大小,因此每个溯源表的大小是指向每个最近的物化的后代节点中元组的tupleID数量的总和.决定是否物化一个节点N时,只需要考虑其最近的物化祖先以及最近的物化后裔,而不必考虑任何兄弟节点,因为祖先的大小将受到N的影响,而后裔会影响节点N的大小.这里称任何非祖先非后代的节点为兄弟节点.虽然兄弟节点的物化,可能会影响到一个共同的最近的物化祖先的大小,但这种物化对祖先表大小的影响是相互独立的.首先介绍一些概念.定义7(子树).T是一个树,N1,N2是T上的节点,N1是N2的一个祖先(考虑每个节点都是它自Page7己的祖先和后裔),表示为N1→N2.集合(N1,N2)包含除N1和N2之外的N1的后裔和N2的祖先.T[N1]为T的子树,包含N1的所有后裔,同时T[N1→N2]为T[N1]的子树,包含所有N2的祖先和后裔.假设T中节点的一个集合S,并且s1,s2∈S,如果s1→s2,s1≠s2,并且不存在s∈S\{s1,s2},s1→s→s2,那么s1是s2的直接祖先,表示成s1→ds2.例5.图5从左到右显示了树T以及它的两个子树T[N2]和T[N2→N5].对于S={N1,N4,N5,N8},节点N1是N4的直接祖先,是N5、N8的祖先但非直接祖先.定义8(部分结果).P是初始的溯源树,N1和N2是P上的节点且N1→N2.ref(N1,N2)表示N1的溯源表对N2中的溯源元组引用的数量.假设需要物化P中节点的一个集合,S的代价是如果S包含一个子树P的根和所有叶节点,那么称S对于P是有效的.opt(N1)表示在P[N1]的所有有效的节点集合中最小化cost(S)的集合S,opt(N1,N2)表示在P[N1→N2]的所有有效的节点集合中最小化cost(S)的集合S且S∩(N1,N2)=,即N1和N2之间没有任何物化节点.可以将opt(N,N)简写成opt(N).现在需要寻找opt(root),其中的root是溯源树的根,即需要寻找一个物化节点集使得溯源信息的存储成本最小.定理2.N1是N2的祖先,N是一个节点.(1)如果N2是一个叶节点(基本表),那么opt(N1,N2)={N1,N2}.(2)如果N不是一个叶节点,那么opt(N)=opt(N,C1)∪…∪opt(N,Ck),其中C1,…,Ck是N的孩子节点.(3)如果N1≠N2并且N2不是一个叶节点,那么opt(N1,N2)={N1}∪opt(N2)或者opt(N1,N2)=opt(N1,C1)∪…∪opt(N1,Ck),其中C1,…,Ck是N2的孩子节点.证明.(1)根据定义8,opt(N1,N2)一定包含节点N1和N2,并且N1和N2之间没有任何物化节点,因为,N2是一个叶节点,因此opt(N1,N2)只包含节点N1和N2.(2)因为N不是一个叶节点,因此,根据定义8,opt(N)表示包含根节点N和N的所有后裔节点集合中最小化cost(S)的集合S.同时,opt(N,Ci),1ik,表示包含根节点N以及Ci的所有后裔节点集合中最小化cost(Si)的集合Si,并且N和Ci之间没有任何物化节点,cost(Si)··=∑si1ik,且si1和si2是N∪{Ci的所有后裔节点集}.那么cost(S)··=∑k可得,cost(S)··=∑kS1∪…∪Sk.(3)根据定义8,opt(N1,N2)是包含节点N1以及N2的所有后裔节点中的最优解,又因为N1≠N2,且N2不是一个叶节点,如果最优解中包含N2,那么,opt(N1,N2)={N1}∪opt(N2);如果最优解中不包含N2,结合定理2(2),那么opt(N1,N2)=opt(N1,C1)∪…∪opt(N1,Ck).这个定理可以转换成算法1,该算法能通过存储opt(N1,N2)和cost(opt(N1,N2)),而不是重新计算来找到最小物化节点集.算法1.DP-opt.输入:P,N1,N2输出:opt(N1,N2)1.如果N2是一个叶节点,那么返回{N1,N2}.2.O2··=DP-opt(P,N1,C1)∪…∪DP-opt(P,N1,Ck).3.如果N1=N2,那么返回O2.4.O1··={N1}∪DP-opt(P,N2,N2).5.如果cost(O1)cost(O2),那么返回O1.6.否则返回O2.引理1.n表示节点的数量,N是初始溯源树中元组引用的数量.算法1能在O(n·N)时间内计算出具有最小存储代价的溯源树.证明.给定一个节点N,以自顶向下的方式计算出节点N对任何后裔表N中每个元组的引用数量,对每个后裔表,计算总的引用数量,得到ref(N,Ν),这需要O(N)的时间.为所有的祖先-后裔对计算ref(N1,N2)可能需要O(n·N)时间.然后,每次算法DP-opt的调用可在固定时间内进行.如果存储算法1的中间计算结果,那么最多需要花费O(n2)时间完成算法的调用,将以上3个时间求和,显然,O(n·N)是算法1完成的时间复杂度.以上提出的动态规划方法只适用于树型查询图.今后将进一步探讨是否存在优化任意查询DAGPage8存储空间最小.些削剪规则:的一个多项式时间算法.3.4对比研究本节将探讨由简单的削剪规则获得溯源表的存储大小是否接近3.3节中的最优解.考虑如下存储溯源信息的策略:(1)最优削剪.在部分节点上存储溯源表,使得(2)基于规则的削剪.对所有的溯源表应用一①完全削剪.仅在根节点上存储溯源表.②不削剪.在所有节点上存储溯源表.③使用规则I和/或规则II的削剪.不同削剪规则之间的区别可能很大,见例3和例4.显然,最优的削剪方法至少不能比任何基于规则的削剪方法差.为了简化分析,假定存储引用的集合(类型为{tupleID}的一个值)需要至少相当于一个额外的单独引用的存储空间.假设不同的(合理的)大小可以影响将在以下确立的存储空间因子的范围,但仍然在一个固定的有限边界内.定理3.基于规则II的削剪方法需要少于最优削剪方法2倍的存储空间.证明.规则II应用到溯源树中后,每个被引用的溯源元组都具有元组类型或者集合类型,称这个削剪的溯源树为PII.考虑PII中至少被引用了两次的溯源元组.考虑最优削剪方法,删除这样的元组并不能降低整体存储空间,可以假设它们仍出现在最优削剪的溯源树上.因此,所有对这些元组的引用也必须出现在最优削剪的溯源树上.同样,对基本元组的引用也是不可避免的,称对基本元组的引用或被引用多次的元组的引用为不可避免引用,所有其它引用为可避免引用.由于PII中每个可避免的溯源元组引用了至少两个其它的元组(根据刚才所述,假设集合类型的数据项需要一个额外的单独引用的存储空间),这里可以形成一个引用的有向无环图,其中可避免的引用数量小于不可避免的引用数量.因为最优的削剪算法只能消除可避免引用,或者说,通过消除不可避免的引用并不能减少引用总数,那么剩余的引用数量是基于规则II削剪算法得到的引用数量的一半以上.正如以上所述,仅使用规则II已经达到了最优溯源存储的近似2倍.在此基础上应用规则I,可以进一步减少存储成本,但不降低理论边界.4相关工作目前,溯源信息的存储、管理和查询变得越来越重要,涌现了大量的研究工作.溯源信息追踪主要包括标记(annotation)和逆过程(inversion)两种方法.逆过程主要是应用逆向查询或者逆向函数,由结果数据溯源到其源数据.而标记的方法则是将一个数据的派生历史搜集起来作为元数据,与数据一起存放在数据库中.这里仅仅给出简要概述,详细的内容请参见文献[2,14].4.1溯源的语义对于溯源的语义,文献[4,6]分别给出了不同的解释.文献[6]主要从数据库的角度来定义“溯源”,认为“溯源”是数据源以及数据如何出现在数据库中的描述,并提供了对溯源语义的分类,将“Why-provenance”和“Where-provenance”严格区分开,其中“Why-provenance”描述了哪些源元组参与了结果元组的派生,例如,为什么元组出现在结果集里,“Where-provenance”仅仅提供了对源元组中属性值的引用,描述了结果元组的值从哪里拷贝而来.文献[4]将“溯源”定义成一种元数据,用于记录实验工作流的过程,是对实验过程的标记.文献[15]提出派生一个数据值所应用的转换过程也同样重要,并引入了基于数据值(而不是基于元组)的“Why-provenance”的变体叫“What-provenance”.文献[14]给出了“溯源”的一般性说明,认为“溯源”是一个数据的派生信息,它主要包括两个重要的特征:派生这些数据的源数据以及经历的转换过程.从数据库的角度而言,转换过程也就是查询.本文探讨了关系型溯源信息的存储以及元组出现在结果集中的原因,因此,主要关注的是“Why-provenance”.另外,很多研究工作[16-19]也将溯源的语义扩展到解释为什么查询的结果集中没有出现所希望的元组.4.2标记当前,大部分的溯源信息管理系统采用标记来进行溯源信息的追踪.文献[10,20]为元组中的每个属性添加一个额外的列,用于存储属性值的标记信息,其中文献[10]将SQL扩展成了包含标记信息的PSQL,允许用户使用PSQL说明如何跟踪和迁移标记信息,即执行查询时,源元组属性上的标记信息会自动地迁移到结果元组的相关属性上.PERM[21]将标记的迁移作为常规的SQL查询的一部分,通过在关系表中存储额外的溯源属性以及查询重写来实现溯源信息的跟踪.文献[20]则更深入地探讨了关系代数操作的各种标记信息的迁移规则.具体而言,对于选择和投影操作,结果元组上属性值的标记信息也就是源元组上对应的属性值;对于连接操作,结果元组上属性值的标记信息可能来自于多个源元组Page9上对应的属性值.对于聚集操作,由于聚集操作的结果并非拷贝而来,而是通过计算得到,因此,结果元组上属性值的标记信息来自所有涉及计算它的源元组上的属性值.然而,以上这种存储标记信息的方法显然需要非常大的存储空间,通常要超出数据本身的存储大小,并且这种方法仅仅能处理属性级别上的标记信息,而不能处理元组或关系级别上的标记信息.在科学应用中,GridDB[12]也采用了类似的溯源信息跟踪方法,它通过存储每一个处理步骤的标记信息,并使用递归查询来检索源数据.CHIMERA系统[22]以推导图的形式跟踪整个数据集的溯源信息,它使用虚拟数据语言构造工作流,在执行过程中,工作流为每个计算程序自动创建触发对象,触发对象连接输入数据和输出数据,它们一起构成了表示数据派生过程的标记模式,因此,必要时可用于重新生成这些数据集.另外,一个通用的用于跟踪和查询溯源信息的半环模型在文献[23-24]中被提出.文献[6]以树形结构(如XML)存储溯源信息,并使用根节点到特定数值节点的路径作为溯源信息.然而,这个方法并没有探讨溯源信息查询处理的高效性和存储代价.和本文的工作类似,文献[7]提出了高效的溯源信息存储方法,但目标是要存储科学应用产生的复杂数据的溯源信息.由于这些数据具有相似或者相同的结构信息,因此结构继承、可选节点分解等优化技术可用于最小化溯源信息的存储.这些优化技术虽然并不适用于数据库查询,但其节点和参数分解技术具有与本文所提出的溯源树存储模型类似的目标.文献[25]探讨了专业数据库的溯源信息管理,由于专业数据库的内容通常需要专业科学家从不同的数据源中手动拷贝,为了追踪构建专业数据库的用户行为(溯源信息),该文提出了自动追踪数据源到目标数据库的方法,将用户行为,也即目标数据的拷贝路径记录在一个溯源表中,并采用多种存储优化技术对此溯源表进行优化.显然,该方法跟踪的溯源类型与本文论述的溯源类型非常不同,因此这个优化技术并不适用于解决本文提出的这个问题.4.3逆过程逆过程(包括逆查询和逆函数)从存储角度看,特别对大量细粒度的数据似乎是更佳的选择.文献[7]中首先探讨了通过逆函数计算溯源信息,而不是将溯源信息预先存储起来的思想.逆过程方法虽然减少了细粒度溯源信息的存储代价,但其适用性被限制在具有高效的逆过程中.如果没有这样的逆过程,该方法等价于重新执行查询.文献[26]将与关系数据库查询相关的溯源信息的逆查询显示存储起来,用于实现高效的数据源查询.然而,这种方法仅仅当存在这样一个逆查询时才有用.文献[9]研究了关系型ASPJ视图中逆查询用于溯源信息跟踪的方法,其基本思想是通过物化中间结果,确保了逆查询的存在,并利用结果元组中的属性值执行逆查询来跟踪数据源.之后,文献[3]对此进行了改进,将其扩展到更一般的转换操作中.以上的方法使用逆查询作为核心,而不是标记,与本文的工作有很明确的相似之处,物化中间结果类似于本文提出的溯源表.与本文方法不同的是,首先,这个方法用属性值而不是元组引用作为溯源信息;其次,这个方法的执行效率取决于结果元组中可用的属性值的多少以及逆查询的关系操作类型;最后,这个方法只有当需要结果元组的溯源信息时,才实时产生逆查询,当数据量很大时,其效率可能不高.这个方法和本文所提出的方法都只选定查询树的部分节点存储数据,只是节点的选择策略并不相同,因此,本文中所提到的优化技术可以被纳入文献[3,9]的方法中,反过来也一样.具体来说,如果需要标识一个元组的源元组的集合,而这个元组是对一些数据值使用聚集方法得到的一个聚集的结果.如果这些源元组是基本关系中的元组,采用以上方法可能比维持元组引用集合更高效.探讨以上两种方法的混合策略是今后的主要研究工作.4.4其它研究一些研究工作将数据值的溯源信息和数据的不确定性结合起来.TRIO系统[11]不仅跟踪数据的溯源信息,也表达数据的不确定性.其中,溯源信息在查询(或程序运行)时被计算出来,然后存储在一个单独的溯源信息关系中,对每个数据元组,存储一个溯源元组.关于结合溯源信息和不确定性的进一步的研究[5]是基于源数据的概率值和结果元组的溯源信息计算出结果元组正确的概率值.以上方法的难点是设计一个包括数据精确性和溯源信息的简单数据模型以及一个扩展的SQL查询语句处理数据精确性和溯源信息的管理和查询.另外,有些研究工作也使用标记信息来判断数据的可信度.文献[27]使用标记信息完成不同数据库间可靠数据的迁移,也即源数据库的数据根据映射关系迁移到目标数据库时,需要通过标记信息判断目标数据库是否信任该数据,不信任的数据不能进行迁移.同样,在文献[28]中,标记信息用于跟踪用户关于数据的信任度.文献[29]也提出一个模型来追踪用户标记信息的可信度.Page105实验评估本文实验的目标主要是讨论第3节中提到的不同优化模式下的溯源信息存储需求,它们分别是最优的削剪、使用规则I的削剪和使用规则II的削剪、不削剪、完全削剪.最后,实验评估了溯源信息跟踪和优化方法的效率.实验建立.本文使用Java建立了一个关系查询引擎,它实现了主码和外码属性上的Hash连接以及基于B树索引的连接,其中,溯源元组和溯源表都是作为Java中的一个对象存储.因为本文主要评估溯源信息的存储代价,因此目前关系查询引擎的实现还未考虑查询优化.该查询引擎支持执行所表3数据集conservation_sts(cs_conservation_status,cs_conservation_status_desc)redlist_species(rs_red_list_category,rs_wwf_species_id)cn(cn_cn,cn_si)cs(cs_cs,cs_csd)es(es_ec,es_si)e(e_ec,e_en,e_cs,e_rc)ecoregions(e_ecoregion_code,e_ecoregion_name,rc(rc_rc,rc_r)rs(rs_rlc,rs_wsi)h(h_pn,h_hn,h_x)hosp(h_prov_number,h_hospital_name,h_xstate)hm(hm_pn,hm_hn,hm_x,hm_mr,hm_np)从表3中可以看出所使用的数据集不太大,这是因为实验主要是测试本文所提出的方法的正确性以及不同优化模式下的溯源信息存储代价.查询和查询计划是根据实验目的设计的,其目标是获得“实际”的查询和避免“不好”的查询计划.查询的设计主要考虑连接操作和聚集操作,因为这两个操作是影响溯源信息存储代价的主要因素.同时,查询计划也只针对树型结构设计,以便于高效地使用算法1计算出最佳的解决方案,并将此作为实验中比较的基准.系统原型的源代码、实验中所使用的数据集和查询集在文献[30]中可以找到.5.1溯源信息的存储代价当评估优化方法的成效时,不直接比较本文的方法与现有的方法对于溯源信息存储的研究结果,其原因如下,首先,有些方法并不是专门为关系查询设计的,如果将查询简单当成工作流的查询会产生巨大的开销,也会使得比较不公平;其次,有些方法也探讨了关系查询的溯源信息的追踪,它们主要使用“标记”或“逆过程”的方法.“标记”方法的侧重点并非讨论溯源信息的存储,而是探讨溯源信息的使需的SQL风格的查询以及在查询执行过程中溯源树的建立,并且已实现了第3节中提出的所有削剪方法.实验运行在2.0GHz双核2GBRAM内存的Windows7机器上.查询引擎返回的查询结果的正确性已通过MySQL5.1核实.数据集和查询集.本文选择了两个数据库:Wildfinder数据库(www.worldwildlife.org)和医疗数据集(www.medicare.gov).实验采用了Wild-finder数据库的6张表,分别是动物名称表cn、动物保护状态表cs、动物生态区物种表es、动物生态区表e、领域表rc、濒危物种表rs;以及医疗数据集中的2张表,分别是医院名称表h、医院死亡率表hm.详细的数据集见表3.表模式用和管理,因此,在存储上是将溯源信息作为数据本身的一部分来存储,根据4.2节的分析,这个方法的弊端显而易见.而“逆过程”方法虽然其思想与本文有相似之处,但其侧重点也是探讨逆过程的产生,通过逆过程计算出溯源信息,而非溯源信息的存储.下面将详细陈述6个有代表性的查询的结果,wwf1,med1,med2为复杂的查询,而wwf2,wwf3,wwf4只是连接查询.图6显示了各个查询对应的查询树,为了简单表达查询树,部分投影操作的投影属性以及连接操作的连接属性没有在查询树中具体描述.详细的查询集信息可以在文献[30]中找到.其中wwf1主要是查询大洋洲濒危动物的名字、个数、它所属的生态区名字以及保护状态,涉及多达8个投影、2个选择、7个连接和1个聚集操作;med2主要是查询病人数不小于100且平均死亡率不小于150的医院名称;med2主要是查询因心脏病发作引发死亡率大于平均死亡率的医院名称.wwf2,wwf3,wwf4只是分别连接Wildfinder数据库中的3张表、5张表和6张表.Page11图66个样例查询的查询树表4记录了6个查询的溯源树被初始构建时,删除冗余的元组后(不削剪)、完全削剪、使用规则I和/或规则II削剪及最优削剪后溯源树的大小.溯源树的存储需求可以通过溯源树中的所有溯源表中的元组引用的数量来衡量.本文所提出的这种方法的存储空间需求的上下界值可以通过不削剪、完全削剪方法来确定.削剪规则wwf1wwf2wwf3wwf4med1med2初始的树12091332203224901221765124不削剪41703322032249039340827完全削剪816224912701494109477530规则I20682491270149410913609规则II30283322032249017521353规则I&II19502491270149410913609最优187516650849810913367从以上的表中我们可以观察到:(1)基于规则I及II的削剪方法得到的结果往往是接近于最优解的,并且基于规则I及II的削剪明显优于不削剪和完全削剪.(2)即使单独使用规则I的效果并没有进行理论的分析和保证,但在实际中,它往往取得比单独应用规则II更好的效果.(3)在许多情况下,基于规则I和II的解决方案确实能取得最优.这主要归因于这个事实:出现在实际和本文的查询集合中的大多数连接是键值连接.(4)虽然不削剪会带来明显的开销且难于取得最优解,但开销也不会到达一个极端值,通常是最优解的2~4倍(存储代价因子为2~4).出现这个稳定性的理由是代价因子的大小被查询树的高度界定.(5)完全削剪有时可以取得最优解(简单的查询更容易产生),但也可能会导致极高的存储成本.这种极端的情况通常涉及一个聚集操作后面出现一个连接操作.除此以外,本文还做了大量的查询测试,完整的查询集在文献[30]中可以找到.表5给出了整个查询集的测试结果,因为不同的查询对存储溯源信息的空间需求相差很大,因此表5总结了相对于最优解的不同方法的存储空间,同时给出了平均和最大(最坏情况)的结果.规则I&II削剪5.2算法的效率本文还需要测试方法的时间效率.前面已经证明了方法的时间复杂度的理论界限:所有算法是所访问元组数目的线性或近线性时间算法,是查询树的大小,即节点数量的低阶多项式时间算法.对于以上每一个样例查询,可以将时间划分为SQL查询执行时间、初始溯源树构建时间以及各种削剪策略的处理时间.这6个样例查询的时间如图7所示,时间是log规模的.Page12从图7中我们可以看到:(1)初始溯源树的构建需要与查询执行大致相同的时间.这是可以预料的,因为在初始的溯源树中的溯源元组的数量实际上是中间结果和最终结果中数据元组的总数.(2)所有的削剪方法比查询执行花费的时间更少,虽然这主要依赖于查询,但通常查询执行时间是削剪方法所用时间的一个或两个数量级.其主要原因是初始溯源树中冗余元组的删除使得时间大大的缩短.(3)最优削剪算法明显比基于规则I&II的削剪算法慢,但从来不会超过一个量级.这是因为本文提出的动态编程方法的多项式时间的性质决定的,如引理1所示.整个查询集合[30]的结果在表6中显示,是以查询执行的代价作为基准,仍然用平均和最大(最坏情况)的结果来评估.结果可以解释为由跟踪或优化溯源信息而间接导致的计算负载.本文所提出的优化溯源信息存储的方法是正交于查询执行的,可以无缝地整合到现有的数据库引擎中.规则I&II的削减查询执行初始溯源树最优削剪整个实验可以得到以下的结论.对于基于削剪的优化,两个比较突出的方法是基于规则I&II的削剪和最优削剪.由于计算效率通常不是一个问题,当查询是树型结构时,最优削剪方法的效果最好,而基于规则I&II的削剪方法能取得与最优结果最接近的结果.6结论本文介绍了一种关系数据库中溯源信息存储的新方法,即通过一个与查询结构匹配的初始溯源树来表达和存储溯源信息.考虑到溯源信息存储代价,本文提出了基于规则I&II的削剪方法,并证明了该方法能达到最优溯源存储的近似2倍,因此能够普遍适用于支持溯源信息的应用.此外,本文也提出了一个多项式时间的最优削剪算法,该算法能为树状结构的查询计算出一个最优解.实验结果表明本文提出的方法可以显著减少存储需求,同时溯源信息的跟踪和优化的计算开销也是合理的.
