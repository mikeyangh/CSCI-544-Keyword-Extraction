Page1具有强匿名性的网关口令认证密钥交换协议魏福山马传贵(信息工程大学信息工程学院信息研究系郑州450002)摘要网关口令认证密钥交换协议允许用户和网关在服务器的协助下建立起一个共享的会话密钥,其中用户和服务器之间的认证通过低熵的口令来完成.已有的网关口令认证密钥交换协议对用户的匿名性研究不足.该文基于Diffie-Hellman密钥交换提出了具有强匿名性的网关口令认证密钥交换协议,并且在随机预言模型下基于标准的DDH假设证明了协议的安全性.新协议可以抵抗不可检测在线字典攻击并且计算效率高,安全性和计算效率都优于已有的同类协议.关键词口令认证;网关;匿名性;随机预言模型;DDH假设1引言在很多实际的应用中,如网上银行、移动支付和无线漫游接入等,服务提供商由前置的网关和后端的验证服务器组成.网关是提供协议转换、网间连Page2个三方口令协议,使得用户和网关在服务器的协助下建立一个认证的会话密钥.服务器和用户之间共享口令用于认证用户身份,但是会话密钥是在用户和网关之间建立的.由于GPAKE协议的模型贴近实际,在很多场景中都具有巨大的应用潜力,因此成为轻量级口令协议研究的一个热点问题.2005年,Abdalla等人[1]提出了GPAKE协议的安全模型,设计了第一个在随机预言模型下安全的GPAKE协议并且将该协议进一步推广到门限的形式.但是在2006年,Byun等人[2]指出Abdalla等人所设计的GPAKE协议易遭受不可检测在线字典攻击[3].一个恶意的网关可以反复对用户的口令进行在线的猜测,然后从服务器端得到验证,直到猜测出正确的口令为止,而服务器检测不到这种恶意的攻击.Byun等人提出了一个改进的协议,要求用户和服务器在执行GPAKE协议之前运行一次安全的两方口令协议,预先建立一个用于认证消息的共享密钥,并且通过给用户发送的消息增加消息认证码的方式来保护口令.但是在2008年,Shim发现[4]Byun等人的改进协议实际上依旧不能抵抗不可检测在线字典攻击,敌手可以重放增加认证码的消息从而对用户的口令进行在线的猜测.Shim采用类似于Byun等人的改进方式,要求用户和服务器执行一次安全的两方口令协议从而建立起共享的加密密钥,利用对称加密体制掩盖口令的信息并提出了S-GPAKE协议.同年,Abdalla等人[5]提出了一个可以利用私密信息检索(PrivateInformationRetrieval)协议[6-7]实现用户匿名性的GPAKE协议.他们同时提出了一个更强的安全模型,该模型允许对参与者进行腐化从而实现了前向安全性.2010年,Yoon等人[8]指出Shim提出的S-GPAKE协议存在设计上的错误,协议无法正常执行,并且计算效率较低.他们对Shim设计的协议进行改进,提出了称为最优的O-GPAKE协议.2011年,Wei等人利用RSA体制设计了GPAKE协议[9],并进一步对该协议进行了改进,提出了效率更高并且可以利用私密信息检索协议实现用户匿名性的GPAKE协议[10].此外,他们还分别在随机预言模型和标准模型下提出了可以抵抗不可检测在线字典攻击的GPAKE协议[11-12].GPAKE协议适用于移动通信环境,如GSM和3GPP等.由于移动通信网络不能像传统的有线网络那样通过物理隔离来保护用户隐私信息的数据包,并且敌手更易于窃取用户认证时所提交的身份信息和服务器对用户身份标识的询问,增加了对用户隐私信息保护的难度.实现用户匿名性在保护用户的个人隐私的同时还可以减少对用户仿冒攻击的几率,因此研究具有匿名性的GPAKE协议有非常重要的现实意义.但是,具有匿名性的GPAKE协议的研究成果很少,目前只有由Abdalla等人[5]和Wei等人[10]分别基于Diffie-Hellman密钥交换和RSA体制提出的两个匿名GPAKE协议.已有的匿名GPAKE协议都采用网关和服务器共同执行私密信息检索协议的方法来实现用户的匿名性,只能保证用户身份对服务器的匿名性,网关和攻击者都可以得到用户的真实身份,匿名性较弱;此外,已有的匿名GPAKE协议的计算效率较低,需要进一步地提高,并且Abdalla等人的匿名GPAKE协议[5]还存在安全漏洞,不能抵抗不可检测在线字典攻击.针对已有的匿名GPAKE协议存在的不足,本文采用匿名认证协议的设计思想,基于Diffie-Hellman密钥交换设计了一个具有强匿名性的GPAKE协议,并且在随机预言模型下利用标准的DDH假设证明了协议的安全性.与已有的匿名GPAKE协议相比,新协议可以抵抗不可检测在线字典攻击并且实现了用户和服务器之间的双向认证,因此具有更强的安全性;在匿名性方面,新协议实现了对用户身份的强匿名保护,无论是攻击者、网关还是服务器都无法得到用户的真实身份;最后,在与已有同类协议具有相同通信效率的情况下,新协议在计算效率方面具有明显的优势.因此,本文所提出的匿名GPAKE协议具有更强的安全性和更高的效率,更符合移动通信环境的应用需求.第2节回顾GPAKE协议的安全模型;第3节介绍具有强匿名性的GPAKE协议并且给出协议的安全性证明;第4节给出与已有匿名GPAKE协议的性能比较;第5节对全文进行总结.2安全模型本节简单介绍由Abdalla等人在2005年提出的GPAKE协议的安全模型,对于安全模型的详细介绍参见文献[1].2.1安全模型协议参与方.GPAKE协议的参与者由用户C∈、网关G∈以及服务器S∈组成.用表示所有参与者组成的集合,即集合=∪∪.用U∈表示GPAKE协议中的任意一个参与者.通信模型.在GPAKE协议中,通常假设用户和Page3网关之间的通信是不安全的,通信被敌手完全控制,敌手可以对用户和网关之间传递的消息进行窃听、删除、修改和延迟发送等操作.但是网关和服务器之间的信道是认证的私人信道,即敌手无法窃听网关和服务器之间发送的消息,也不能对网关和服务器之间发送的消息进行修改.另外,用户无法和服务器直接进行通信,用户和服务器之间的消息必须经过网关进行传递.长期密钥.每个用户C∈都拥有一个与服务器共享的用于认证的口令pwC.每个服务器S∈都持有一个口令列表pwS=〈pwC〉C∈S,其中每条记录对应一个在服务器S处进行注册的用户C的口令pwC.pwC和pwS分别称为用户C和服务器S的长期密钥.敌手能力.敌手的攻击能力通过预言询问来刻画.在协议执行的过程中,敌手可以针对某个参与者产生多个并行的会话实例.用Ui来表示用户U的第i次会话实例.敌手可以进行的预言询问有以下几种:(1)Execute(Ci,Gj)询问.此询问模拟敌手进行的被动攻击,其中敌手对用户实例Ci和网关实例Gj之间进行的一次协议执行过程进行窃听.对此询问的回答是将本次协议执行过程中用户和网关之间传输的所有消息返回给敌手.(2)Send(Ui;m)询问.此询问模拟敌手进行的主动攻击.其中敌手伪造一个消息m并且将消息m发送给用户实例或者网关实例Ui.敌手将得到实例Ui在接收到消息m后根据协议描述返回的消息.(3)Test(Ui)询问.此询问不刻画敌手的攻击能力,只是用来衡量参与者实例Ui的会话密钥的语义安全性.如果实例Ui的会话密钥没有定义,那么返回一个未定义的符号⊥.否则,如果b=1就将真实的会话密钥返回给敌手,如果b=0则返回一个与会话密钥等长的随机数,其中b是在攻击游戏开始运行之前选择的随机比特.(4)TestPair(Ci,Gj)询问.此询问不刻画敌手的攻击能力,而是用来定义会话密钥对于服务器的密钥私密性.如果用户实例Ci和网关实例Gj之间没有建立共享的会话密钥,那么返回一个未定义的符号⊥.否则,如果b=1就将真实的会话密钥返回给敌手,如果b=0则返回一个与会话密钥等长的随机数,其中b是在攻击游戏开始运行之前选择的随机比特.Abdalla等人[13]的安全模型采用了ROR(Real-Or-Random)模型的定义方式.敌手可以进行多次Test询问,所有Test询问的回答都由一个随机比特来决定.即敌手得到的可能全部是真实的会话密钥或者全部是与会话密钥等长的随机数.在FTG(Find-Then-Guess)模型中常见的Reveal询问在ROR模型中不存在,但是由于FTG模型中只允许敌手进行一次Test询问,ROR模型实际上比FTG模型强.关于ROR模型和FTG模型的更多比较,参见文献[13].2.2安全定义本小节给出安全模型中的安全性定义.如果一个实例生成会话密钥并且完成协议运行,则称该实例接受.我们通过会话标识和伙伴标识来定义伙伴.一般定义会话标识为协议执行结束后所有消息的级联.一个实例Ui1的伙伴标识则为其想要与之通信的实例Uj2.定义1(伙伴).用户实例Ci和网关实例Gj被称为伙伴,如果:①Ci和Gj都接受;②Ci和Gj有相同的会话标识;③Ci的伙伴标识为Gj,反之亦然;④除了Ci和Gj外,不存在其它接受实例的伙伴标识为Ci或Gj.敌手只能对新鲜的实例进行Test询问,否则敌手可以轻易赢得攻击游戏.新鲜性定义就是为了防止敌手可以通过平凡的方式赢得攻击游戏.定义2(新鲜性).一个用户实例Ci或者网关实例Gj是新鲜的,如果该实例接受协议运行并且生成了会话密钥.在Abdalla等人的安全模型中有3个安全目标,包括语义安全性、密钥私密性和口令保护.其中会话密钥的语义安全性保证了一个外部敌手不能够区分真实的会话密钥和与会话密钥等长的随机数;针对服务器的密钥私密性要求用户和网关之间建立的会话密钥对于诚实而好奇的服务器是不可区分的;针对网关的口令保护是指恶意网关通过协议运行不能得到用户口令的任何信息.下面我们分别给出这3个安全目标的严格定义.考虑一个对GPAKE协议进行攻击的敌手,给敌手提供Execute,Send询问以及对新鲜会话进行多次Test询问的能力.敌手的目标是猜测Test询问中所使用的随机比特b.我们用Succ来表示敌手成功猜测到b这一事件.定义3(语义安全).当口令是从字典空间中随机选择的时候,定义敌手攻破GPAKE协议的语义安全的优势为Page4Advake-ror定义GPAKE协议的语义安全的优势函数为上式中的最大值遍历所有计算时间至多为t,消耗的资源(询问不同预言的次数)至多为R的敌手.如果一个GPAKE协议语义安全的优势函数,(t,R)至多比kn/大一个可忽略的量,Advake-ror那么称GPAKE协议是语义安全的,其中n是敌手进行主动攻击的次数,表示字典空间的规模,k是一个常数.一般k=1是最优的结果,因为每次敌手进行主动攻击至少可以排除一个错误的口令.考虑一个对GPAKE协议进行攻击的敌手,给敌手提供所有用户的口令、Execute询问以及对伙伴会话进行TestPair询问的能力.敌手的目标是猜测TestPair询问中所使用的随机比特b.我们用Succ来表示敌手成功猜测到b这一事件.定义4(密钥私密性).当口令是从字典空间中随机选择的时候,定义敌手攻破GPAKE协议的密钥私密性的优势为Advake-kp定义GPAKE协议的密钥私密性的优势函数为上式中的最大值遍历所有计算时间至多为t,消耗的资源(询问不同预言的次数)至多为R的敌手.称一个GPAKE协议实现了密钥私密性,如果其密钥私密性安全的优势函数Advake-kp相对于安全参数的一个可忽略函数.考虑一个恶意的网关猜测用户的口令,然后通过与服务器执行协议来验证口令是否正确.如果一个错误的猜测没有被服务器检测到,则认为恶意的网关成功.我们用Advake-uoda网关成功的优势.定义5(口令保护).称一个GPAKE协议实现了对恶意网关的口令保护,如果恶意的网关成功的优势Advake-uoda略的量,其中n是敌手进行主动攻击的次数,表示字典空间的规模,k是一个常数.对于协议的匿名性,我们采用文献[14]中的定义方法.称一个GPAKE协议是匿名的,如果在用户和网关建立会话密钥的过程中,用户除了证明自己是合法的成员外,不泄露任何身份信息给网关和服务器.定义6(匿名性).对于两个用户Ci和Cj,分别用P(Ci,G,S)和P(Cj,G,S)表示两个用户执行协议的消息抄本.称一个GPAKE协议实现了用户匿名性,如果有Dist[P(Ci,G,S)]=Dist[P(Cj,G,S)],其中Dist[P(C,G,S)]表示P(C,G,S)的概率分布.3具有强匿名性的AGPAKE协议3.1协议描述设Gq是一个阶为大素数q的循环群,g,h为随机选择的Gq的两个生成元,且h关于g的离散对数是难解的;设H,Hi:{0,1}→{0,1}l(i=0,1,2,3)是相互独立的Hash函数,其中l是安全参数.假设系统中总共有n个用户,每个用户Ci分别与服务器共享一个口令pwi.不失一般性,假设口令已经映射q中的元素.协议的参与者有用户、网关和服务为Z器,网关和服务器之间是安全的认证通道.协议的描述见图1,具体的步骤如下.1.用户Ci选择随机数x,r1∈Zq,计算X=gx以及R1=gr1hpwi,最后用户发送消息(C,X,R1)给网关G,其中C是系统中所有用户的身份.2.网关G接收到消息(C,X,R1)后,随机选择y∈Zq并且计算Y=gy,然后将Y连同接收到的消息一起发送给服务器S.3.服务器S接收到网关发送的消息(C,X,R1,Y)后,随机选择r2∈Zq和MS∈{0,1}l,然后计算R2=gr2.对于每一个用户Cj(1jn),服务器首先计算R1,j=R1/hpwj和Kj=(R1,j)r2,然后利用Kj对MS进行掩盖,即计算Zj=H(j,Kj)MS.最后服务器利用随机数MS计算认证值VS1=H1(ID1ID2MS)和VS2=H2(ID1ID2MS),其中ID1=(C,G,X,R1,Y),ID2=(R2,{Zj}1jn).服务器发送消息(ID2,VS1,VS2)给网关.4.网关G接收到消息(ID2,VS1,VS2)后,先储存VS2用于验证用户身份,然后转发消息(G,Y,ID2,VS1)给用户.5.用户Ci接收到消息(G,Y,ID2,VS1)后,首先从{Zj}1jn找到对应于自己的Zi,然后计算Ki=Rr12和MS=ZiH(i,Ki).用户Ci利用MS验证VS1是否有效.如果无效则拒绝协议,否则计算认证值VS2=H2(ID1ID2MS)和VS3=H3(ID1ID2MS)以及Diffie-Hellman密钥K=Yx.最后用户Ci计算会话密钥sk=H0(ID1ID2K),发送消息(C,VS2,VS3)给网关并且接受协议运行.6.网关接收到消息(C,VS2,VS3)后,首先验证用户Ci发送的VS2是否等于所储存的VS2.如果验证通过,则网关接受协议运行并计算Diffie-Hellman密钥K=Xy=gxy以及会话密钥sk=H0(ID1ID2K);否则,网关拒绝协议运行并终止.最后,网关发送消息(C,VS3)给服务器,服务器验证VS3是否有效.如果验证通过,说明认证请求确实是一个诚实的用户发送的;否则,认证请求很可能来自一个恶意网关对用户的在线仿冒攻击,服务器将采取进一步的措施以保护用户口令.Page5图1匿名的AGPAKE协议3.2安全性证明本小节给出匿名的AGPAKE协议的安全性证明.协议的安全性基于DDH假设,下面给出DDH假设的定义.DDH假设.假设Gq为阶为素数q的循环群,g为Gq的一个生成元.假设ddh是一个概率多项式时间的敌手,模拟者首先随机选择u,v,w∈Zq,并且计算U=gu,V=gv和W=gw,然后随机选择一个比特b∈{0,1},如果b=1,那么将(gu,gv,guv)给敌手,否则将(gu,gv,gw)给敌手.敌手需要猜测随机比特b的值,如果敌手猜测正确就认为敌手成功,记此事件为Succ.定义敌手的优势为Adv(ddh)=2·Pr[Succ]-1.如果对于任意的概率多项式敌手,上述优势都是可忽略的,那么称循环群Gq中DDH假设成立.定理1(语义安全).假设是一个运行时间为t,并且进行了qSend次Send询问的概率多项式敌手.如果DDH假设在群Gq中成立,那么敌手破坏AGPAKE协议的语义安全的优势至多为其中neg(l)表示关于安全参数l的一个可忽略函数.证明.我们采用混合实验的方法来证明协议的语义安全性,证明思路是通过一系列攻击实验对模拟规则逐渐进行改变,直到敌手的优势为可忽略的函数为止.我们用事件Succ表示敌手正确猜测出了在Test询问中所使用的随机比特b,用Adv(,Pi)表示敌手在第i个混合实验中的优势.实验P0:此实验模拟在随机预言模型下的真实协议运行,在试验中敌手可以多次进行Execute、Send和Test询问.根据定义有实验P1:在这个实验中,我们通过维持哈希列表来模拟随机预言函数Hi(i=0,1,2,3)以及H.另外我们还模拟私有的随机预言函数Hi(i=0,1,2,3)以及H,这5个私有的随机预言函数将在后面的实验中用到.随机预言函数的模拟规则如下.(1)Hi查询列表∧Hi(i=0,1,2,3).对于每一次随机预言询问Hi(m),如果列表∧Hi中存在记录(i,m,r),则返回r;否则,随机选择r∈{0,1}l,将r返回给询问者,并且将记录(i,m,r)添加到列表∧Hi.Page6(2)Hi查询列表∧Hi(i=0,1,2,3).对于每一次随机预言询问Hi(m),如果列表∧Hi中存在记录(i,m,r),则返回r;否则,随机选择r∈{0,1}l,将r返回给询问者,并且将记录(i,m,r)添加到列表∧Hi.(3)H查询列表∧H.对于每一次随机预言询问H(m),如果列表∧H中存在记录(m,r),则返回r;否则,随机选择r∈{0,1}l,将r返回给询问者,并且将记录(m,r)添加到列表∧H.(4)H查询列表∧H.对于每一次随机预言询问H(m),如果列表∧H中存在记录(m,r),则返回r;否则,随机选择r∈{0,1}l,将r返回给询问者,并且将记录(m,r)添加到列表∧H.除了模拟随机预言函数外,我们还根据协议描述模拟所有的Execute、Send和Test询问.由模拟的规则可知实验P2:为了方便后面的分析,在此实验中我们排除一些发生碰撞的会话.具体来说,如果会话中消息抄本发生碰撞,或者随机预言函数的输出发生碰撞,那么我们取消该次会话的运行.由生日攻击原理可知,实验P2和实验P1是不可区分的,因此有Adv(,P2)-Adv(,P1)neg(l).实验P3:从此实验开始,我们修改对Execute询问的模拟.具体来说,我们在被动会话中将Hash函数H以及H1,H2,H3分别替换为实验P1中定义的私有随机预言函数H和H1,H2,H3,并且随机选择随机预言函数中的输入Kj以及MS.我们现在来证明实验P3和实验P2是不可区分的.敌手如果想要区分实验P3和实验P2,由于在H1,H2,H3中的输入只有MS是秘密的值,其余的都是公开值,因此对于某一次被动会话,敌手如果正确恢复出MS则可以区分实验P3和实验P2.由于Zj=H(j,Kj)MS,因此对于任意的1jn,敌手需要计算出一个正确的Kj才可以正确恢复出MS.但是因为会话是被动的,并且R1对应于用户Ci,因此实际上敌手需要恢复出正确的Ki.用事件PassiveAskH表示敌手正确计算出Ki并且向随机预言函数H进行了相应的询问,显然如果PassiveAskH事件发生,那么敌手可以区分实验P3和实验P2;用PassiveAskHi表示在PassiveAskH事件没有发生的情况下,敌手用正确的MS向随机预言函数H1,H2,H3进行相应的询问.如果PassiveAskH没有发生,那么敌手不可能知道正确的MS,因此事件PassiveAskHi的概率是可忽略的.我们现在来证明,PassiveAskH发生的概率至多为敌手破解CDH问题的优势,即敌手区分实验P3和实验P2的优势是可忽略的.给定一个CDH实例(U,V),我们定义一个额外的实验P3.在实验P3中,当我们模拟Execute询问时,令用户Ci计算R1=Ua1ga2×hpwi,服务器计算R2时令R2=Vb1gb2,其中a1,a2,b1,b2∈Z模拟规则和实验P3完全相同.注意虽然实验P3和实验P3的模拟规则不同,但是分布却完全相同.如果事件PassiveAskH发生,我们可以从∧H列表中提取Ki=CDH(Ua1ga2,Vb1gb2)=CDH(U,V)a1b1·Ua1b2·Va2b1·ga2b2,由于a1,a2,b1,b2已知,因此可以得到CDH(U,V)=(Ki/(Ua1b2·Va2b1·ga2b2))-a1b1,从而得到了CDH问题的解.由CDH问题的困难性假设可知事件PassiveAskH发生的概率是可忽略的.由上面的分析可知实验P3和实验P2是不可区分的,因此有实验P4:在这个实验中,我们继续修改对Execute询问的模拟.我们修改用户和网关的会话密钥的计算方式,即使用私有的随机预言函数H0来计算会话密钥sk.这样的修改使得被动会话中会话密钥sk完全与随机预言函数H0以及Diffie-Hellman密钥K无关.由于在上一个实验中,我们令用户和服务器之间的认证值完全与MS无关,因此在此实验中可以简化模拟规则,在模拟被动会话时直接从Gq中随机选择R1和R1,j以及Kj的值.在实验P4中,所有的被动会话中的认证值和会话密钥都是随机选择的,并且口令在被动会话中也完全没有用到,因此敌手在区分被动会话的会话密钥时没有任何优势,也不能通过被动会话得到口令的任何信息.需要说明的是,在主动攻击的会话中,模拟规则依然和真实的实验一样.通过和实验P3类似的分析可知实验P4和实验P3是不可区分的,敌手区分这两个实验的优势至多是破解CDH问题的优势,因此有实验P5:在这个实验中,我们处理敌手通过Send询问进行的被动攻击,也就是说敌手只是诚实转发消息,不对消息进行任何改动.具体来说,对于这些貌似主动实际还是被动的特殊会话,我们用私有的随机预言函数来计算认证值以及会话密钥,修改的规则和实验P4中对被动会话的处理完全相同,并且通过类似的分析有Page7Adv(,P5)-Adv(,P4)neg(l).实验P6:在这个实验中,我们开始处理敌手通过Send询问进行的主动攻击.对于敌手的(Ci,Gj,start)询问,我们首先随机选择R1∈Gq并计算X=gx,然后返回消息(C,X,R1)给x∈Z敌手,并且当敌手返回消息(G,Y,ID2,VS1)的时候,我们令用户实例拒绝接受并且终止协议运行.实验P6与实验P5是不可区分的,除非对于(Ci,Gj,start)询问返回的消息(C,X,R1),敌手向随机预言函数H询问输入为(i,Ki)的值,其中Ki=(R1/hpwi)r2并且R2=gr2,我们记此事件为AskHWithC.显然有Adv(,P6)-Adv(,P5)Pr[AskHWithC6].实验P7:在这个实验中,我们最后一次处理敌手通过Send询问进行的主动攻击.对于敌手的Send(Gj,(C,X,R1))询问,我们返回消息(G,Y,ID2,VS1),其中VS1是通过私有的随机预言函数H1计算得到的,其秘密输入为一个随机选择的MS.另外,Zj(1jn)的值我们也随机选择.当敌手返回消息(C,VS2,VS3)的时候,我们令网关实例直接拒绝并且终止协议运行.注意到Kj在模拟中没有用到,因此我们可以简化协议的模拟,取消对Kj的计算.显然,实验P7与实验P6是不可区分的,除非敌手计算出某一个正确的Kj值,然后恢复出正确的MS,最后对随机预言函数H1,H2,H3进行询问.敌手区分的关键在于计算出一个正确的Kj值并且向随机预言函数H询问(j,Kj),我们记此事件为AskHWithG.显然有Adv(,P7)-Adv(,P6)Pr[AskHWithG7].在实验P7中,我们现在来计算事件AskHWithC7和AskHWithG7的概率,并且在此基础上进一步计算敌手破坏协议语义安全的优势.首先注意到在实验P7中,我们在模拟的时候完全没有用到口令的任何信息,口令可以在模拟的最后阶段来选择.所有被动会话的会话密钥都是随机选择的,而敌手进行主动攻击的会话都会被拒绝接受.根据上面的分析可知,敌手在实验P7区分真实的会话密钥和随机数不会有任何优势,因此有Succ7=1/2.事件AskHWithC7实际上对应着敌手冒充网关欺骗诚实用户的攻击,由于敌手产生的认证值VS1唯一对应着一个MS,相应的唯一对应于一个口令值pwi,由于我们在实验P3中已经排除了随机预言函数的碰撞,因此有类似的,事件AskHWithG7对应于敌手冒充用户来欺骗网关的攻击,类似于事件AskHWithC7的分析,我们有综上,定理1得证.定理2(密钥私密性).假设是一个运行时间为t,并且进行了qExecute次Execute询问的概率多项式敌手.如果DDH假设在群Gq中成立,那么敌手破坏AGPAKE协议的密钥私密性的优势至多为证明.假设kp是运行时间至多为t,进行了qExecute次Execute询问和qTest次TestPair询问的概率多项式敌手.下面我们通过调用kp来构造一个可以解决DDH问题的敌手DDH.设DDH实例(U,V,W)是给DDH的输入.DDH首先根据口令空间的分布为所有的用户选择口令.DDH随机选择一个随机比特b用于模拟TestPair询问,然后DDH将所有的口令告诉敌手kp并且开始模拟协议的运行.为了模拟Execute(Ci,Gj)询问,DDH首先随机选择四个随机数a1,a2,b1,b2∈Zq,计算X=Ua1ga2和R1=gr1hpwi.DDH然后将消Z息(C,X,R1)发送给网关.网关接收到消息(C,X,R1)后,计算Y=Vb1gb2并且发送(C,X,R1,Y)给服务器.DDH正常模拟协议剩余的步骤直到计算Diffie-Hellman密钥K为止,DDH设置Diffie-Hellman密钥K=Wa1b1·Ua1b2·Wa2b1·ga2b2,DDH按照协议的描述完成剩余的模拟.为了模拟TestPair(Ci,Gj)询问,DDH首先检查敌手kp是否进行过相同的询问.如果是,则返回与上次相同的回答;否则DDH检查Ci和Gj是否是伙伴,如果不是,则返回错误的符号⊥.在Ci和Gj是伙伴的情况下,如果随机比特b=1,那么DDH返回真实的会话密钥sk给敌手kp,如果随机比特b=0,那么DDH返回一个与会话密钥等长的随机数给敌手kp.如果DDH实例(U,V,W)是一个Diffie-Hellman三元组,那么上面的模拟是完美的,因此DDH输出1的概率为1Page8(U,V,W)是一个随机的三元组,那么无论b为0或者1,返回给敌手kp的都是随机数,因此不会泄露关于b的任何信息,此时DDH输出1的概率为1综上,定理2得证.定理3(口令保护).假设是一个运行时间为t,并且进行了qSend次Send询问的概率多项式敌手,那么敌手对AGPAKE协议进行不可检测在线字典攻击成功的优势至多为证明.考虑一个恶意网关冒充诚实用户并且发送接入请求给服务器.根据协议的描述,服务器应该随机选择r2∈ZR2=gr2.对于每一个用户Cj(1jn),还需要计算R1,j=R1/hpwj和Kj=(R1,j)r2以及Zj=H(j,Kj)MS.最后服务器利用随机数MS计算认证值VS1=H1(ID1ID2MS)和VS2=H2(ID1ID2MS),其中ID1=(C,G,X,R1,Y),ID2=(R2,{Zj}1jn).服务器发送消息(ID2,VS1,VS2)给网关.恶意网关为了欺骗成功,需要相应地返回一个认证值VS3=H3(ID1ID2MS).如果恶意网关对用户的口令猜测错误,那么计算出的Ki是错误的,相应的也无法正确恢复出MS的值.除非敌手能够在不询问H3(ID1ID2MS)的条件下猜测出VS3,否则服务器在接收到认证值VS3后将会拒绝.但是由于H3为随机预言函数,因此在不询问H3(ID1ID2MS)而正确猜测到VS3的值的概率是可忽略的.如果恶意网关对用户的口令猜测正确,那么很容易根据协议描述计算出正确的VS3.但是注意到恶意网关从服务器发出的消息(ID2,VS1,VS2)至多排除一个口令,因此恶意网关猜测口令正确的概率至多为qSend因此,恶意网关对AGPAKE协议进行不可检测在线字典攻击成功的概率至多为定理4(匿名性).匿名的AGPAKE协议实现了用户身份的匿名性,并且一个恶意服务器至多以1/n的概率破坏用户的匿名性.证明.对于用户Ci(1in)发送的第一条消息(C,X,R1),因为x,r1是从Z因此(C,X,R1)在集合C×Gq×Gq上是均匀分布的;由于所有的Zj(1jn)中使用相同的MS,因此用户Ci发送的消息(C,VS2,VS3)不会泄露用户身份的信息.对于两个用户Ci和Cj,显然有Dist[P(Ci,G,S)]=Dist[P(Cj,G,S)],因此AGPAKE协议实现了用户身份的匿名性.考虑一个恶意的服务器试图通过协议运行获得用户身份.在用户发送消息(C,X,R1)给服务器后,服务器如果真实地执行协议,由于R1是随机的,并且由于所有的Zj(1jn)中都使用相同的MS,那么服务器不可能有任何优势区分用户的身份.根据协议的描述,服务器只能通过用户返回的消息(C,VS2,VS3)来对用户身份进行猜测,注意到认证值VS2,VS3中只有一个秘密输入MS,因此服务器只有针对不同的用户Ci选择不同的秘密值MSi才能区分用户,但是协议中要求服务器在返回消息的时候计算出一个认证值VS1,但是此时服务器不知道用户身份的任何信息,因此服务器只能以1/n的概率来猜测用户的身份并且返回相应的认证值VS1.由于用户将对认证值VS1进行验证,那么服务器猜测的认证值VS1将以n-1户将拒绝协议运行.因此恶意服务器破坏协议中用户匿名性的优势至多为1/n.4性能分析本节给出本文提出的协议与已有的匿名GPAKE协议在计算效率和安全性方面的比较.我们分别用AIP协议和WMC协议来表示文献[5]和文献[10]中的协议.假设系统中总共有n个用户.在计算复杂性方面,只考虑模指数运算而忽略其余的运算(如哈希函数、模乘等运算),用edh表示Diffie-Hellman模指数运算,用ersa表示RSA的模指数运算.一般认为在相同的参数规模下,这两种模指数运算具有近似的计算代价.在通信复杂性方面,从协议的通信轮数来比较.在安全性方面,主要从是否可以抵抗不可检测在线字典攻击、匿名性的强弱、是否实现双向认证以及安全性证明基于的困难性假设几方面进行衡量.用UODA表示不可检测在线字典攻击,用PCDDH表示基于口令的选择基判定性DDH假设[5],用RSA表示RSA假设.AGPAKE协议效率和安全性比较的结果见表1和表2.Page9比较的协议计算复杂度AIP协议[5]4edh3edh3nedh4WMC协议[10]4ersa2ersa2nersa8AGPAKE协议4edh2edh(n+1)edh6比较的协议UODA匿名性双向认证困难性假设AIP协议[5]否弱否DDH,PCDDHWMC协议[10]是弱是RSAAGPAKE协议是强是DDH从上面的比较可以看出,在计算代价方面,AGPAKE协议在用户端和网关端的计算量和已有协议大致相同,但是在服务器端AGPAKE协议只需要n+1个指数运算,远少于AIP协议和WMC协议中所需要的指数运算.通常在服务器进行注册的用户个数n都比较大,因此AGPAKE协议的计算效率与已有的匿名GPAKE协议相比具有明显的优势.在通信轮数方面AGPAKE协议比WMC协议少两轮.但比AIP协议多了两轮.在安全性方面,AGPAKE协议可以抵抗不可检测在线字典攻击、实现了双向认证并且具有强匿名性,具有最强的安全性.AIP协议不能抵抗不可检测在线字典攻击并且匿名性较弱,如果AIP协议想要达到与AGPAKE协议相同的安全性,至少还需要增加两轮通信.最后,AGPAKE协议还有一个优势,即安全性基于标准的DDH假设,而AIP协议还需要用到非标准的PCDDH假设.5结语本文研究如何设计具有强匿名性、安全高效的GPAKE协议.利用匿名认证协议的思想,基于Dif-fie-Hellman密钥交换设计了一个具有强匿名性、安全高效的GPAKE协议.与已有协议相比,新协议可以实现用户身份对恶意敌手、网关和服务器的强匿名保护,可以抵抗不可检测在线字典攻击,并且实现了双向认证,因此具有更强的安全性;此外,新协议在相同通信效率的条件下,在计算效率方面具有明显的优势.
