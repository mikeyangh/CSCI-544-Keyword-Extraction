Page1基于启发式on-the-fly的扩展TGBA模型检测算法王曦1),2)徐中伟1)1)(同济大学电子与信息工程学院上海201804)2)(江西理工大学信息工程学院江西赣州341000)摘要以广义Büchi自动机为研究对象,对其作判空检测能为解决系统的状态空间爆炸问题提供有效途径.但广义Büchi自动机难以适用于安全苛求计算机系统中,只需满足某个可接受条件子集便可作出非空性判断,进而能判断出系统的安全性的情形.文中提出了基于启发式on-the-fly的扩展TGBA模型检测算法,该算法采用ETGBA模型,通过启发式on-the-fly判空检测方法对ETGBA作判空检测时,加强了对不能构成其可接受运行的结点的处理,节省了内存空间,提高了检测效率,从而能较快地作出非空性判断.通过算法的正确性证明及复杂度分析、实验比较与实例研究验证了所提出算法的正确性与实际可行性.与已有算法相比,该算法的通用性更强,当应用于广义Büchi自动机的判空检测时,其时空性能均优于已有算法.关键词模型检测;广义Büchi自动机;on-the-fly算法;安全性分析1引言在安全苛求计算机系统(safety-criticalcomputersystem)[1]研究领域中,如何保障系统的安全性和可靠性成为日益紧迫的问题.基于自动机理论的模型检测[2]具有简洁明了和自动化程度高的优点,为系统的安全性、可靠性、活性等属性分析提供了完整的验证框架,其算法和应用研究成了人们关注的热点之一.在该类模型检测算法中,关于时序逻辑公式取反并转化生成标准Büchi自动机的算法[3-4]及如何对自动机作同步积运算的算法[2]已有深入研究,on-the-fly判空检测算法通常用于标准Büchi自动机的判空检测,主要分为嵌套的深度优先搜索和基于强连通子图的搜索算法[5-9],但检测过程中容易引起状态空间的爆炸问题.对广义Büchi自动机作判空检测,能有效地减少系统状态空间的搜索.文献[10-12]对广义Büchi自动机的判空检测进行了研究.其中文献[10]采用基于强连通子图的搜索算法对广义Büchi自动机GBA(GeneralizedBüchiAutomaton)作判空检测,以下简称Gaiser算法.文献[11]以GBA为研究对象,提出了嵌套的判空搜索算法,以下简称Tauriainen算法.文献[12]研究了带有迁移标识的广义Büchi自动机TGBA的判空检测算法,以下简称Couvreur算法.在通常情况下,Gaiser算法、Tauriainen算法和Couvreur算法都需要满足广义Büchi自动机所有的可接受条件才能作出非空性判断.在安全苛求计算机系统的安全性分析与验证中,系统的安全性约束条件通常表征为多个最小割集的或运算,每个最小割集通常为多个故障树底事件的合取式,只要系统模型中有任意一个最小割集的全部底事件发生时,该系统便视为不安全的系统.当采用基于自动机理论的模型检测方法对安全苛求系统进行安全性分析与验证时,只需要判断系统模型是否满足由某个最小割集构成的可接受条件子集,便可得到安全性验证结果,因此,已有的广义Büchi自动机判空检测算法难以适用于安全苛求系统的安全性分析与验证实践中.在本人前期的研究工作[13]中,对广义Büchi自动机进行扩展,定义了ETGBA模型,将基于场景的形式化模型生成方法与故障注入技术相结合,在系统的有穷状态机模型与基本安全需求模型作同步积运算产生ETGBA模型的基础上,通过扩展的启发式广义Büchi自动机判空检测子算法对ETGBA模型的安全性进行验证,但限于篇幅,该子算法没有对ETGBA模型的判空检测算法进行具体描述与分析.鉴于此,本文结合安全苛求系统的安全性分析与验证实践,以ETGBA的判空检测为研究对象,提出基于启发式on-the-fly的扩展TGBA模型检测算法MCA_ETGBA(heuristicon-the-flymodelcheckingalgorithmforextendedTGBA).MCA_ETGBA算法在对ETGBA的状态空间进行搜索时,通过结合启发式on-the-fly判空检测方法和强连通子图检测算法,能优先找到满足ETGBA可接受运行条件的结点序列,从而能对ETGBA的非空性较快而准确地作出判断.在ETGBA为空的最坏情况下,MCA_ETGBA算法的时间复杂度为O(l+k),空间复杂度为O(k|T|+k),其中ETGBA所包含的迁移关系数和状态结点数分别为k和l,存储ETGBA中迁移关系Ti(Ti∈T)所需最大空间为|T|.通过理论分析与证明、实验比较和实例研究验证了MCA_ETGBA算法的正确性与实际可行性.与当前判空检测算法相比,MCA_ETGBA算法的通用性与实用性更强,当对广义Büchi自动机作判空检测时,在通常情况下MCA_ETGBA算法所需访问的状态数与迁移数更少,所需检测时间和内存空间更少.2MCA_ETGBA算法MCA_ETGBA算法中有关ETGBA模型的相关定义以及极大非平凡SCCs的具体描述参见文献[13].假设要验证的ETGBA为C=〈珦A,Q,ξ,F—,q0,T〉,其中珦A,Q,ξ,F—,q0的含义同文献[13]中的定义5.为简单起见,将T简化为T∈Q×2F-×Q.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,且T∈Q×2F-×Q,MCA_ETGBA算法的基本思想为从遍历C中初始结点q0开始,访问q0并以q0为最近访问结点,若在q0的所有后继迁移中,存在qij=(q0,a0,qi),a0∈2F-且a0≠,则优先访问qij及相应后继结点qi,并以qi为最近访问结点q,否则任意访问一个后继迁移tij及相应后继结点ti,并以ti为最近访问结点q.根据以上过程进一步访问q的后继迁移和后继结点,若在访问C时,发现有结点qk的后继为空,以qk为要删除的结点,对qk做删除操作后,并进Page3一步判断qk的父结点qk-1,若qk-1所有的后继结点都过做删除操作,以qk-1为要删除的结点,重复上述删除过程,做了删除操作的结点以后不需要再处理;在搜索过程中若发现有某个非平凡SCCs存在,判断其是否满足某个F—i∈F—,使得F—if成立,其中f为其包含的可接受条件,如果满足,则输出“Yes,非空的ETGBA”,并终止算法,否则,进一步判断其是否为C的一个极大非平凡SCCs,若是,则对其做删除操作;若访问C已完毕,没有找到满足某个F—i∈F—的无穷迁移序列,则在输出“No,ETGBA为空”后,退出算法,否则,按上述过程选择新的结点继续搜索.2.1MCA_ETGBA算法描述输入:ETGBAC=〈珦A,Q,ξ,F—,q0,T〉;输出:如果找到满足C非空的可接受运行序列,输出“Yes,非空的ETGBA”,否则输出“No,ETGBA为空”.Q,q=state,(q,a,q)∈T}〉的后继迁移关系(q,a,q).node2∈Q,BOOLEANnode2_label〉;初始化定义如下:Trans,temp:stackof〈TQ∈{(q,a,q)|state∈栈Trans,temp用来临时存放最近访问结点qPath:arrayof〈node1∈pre(node2),act∈2F—,Path是数组,其中node2域表示最近访问的状态结点,act域表示迁移关系(node1,act,node2)上的迁移标识,node1表示node2的父结点,布尔型变量node2_label表示结点node2的访问标志.志1写入Path[1]中;length:length∈N,且1lengthPath.size();length为记录数组Path长度的整型变量,其中N为自然数集,Path.size()为数组Path的长度;MCA_ETGBA算法主要由ETGBACheck子算法、Search子算法、Delete子算法、TransPartition子算法和Emptycheck子算法组成,以下将详细描述各个子算法.(1)ETGBACheck子算法ETGBACheck子算法从访问ETGBA的初始结点q0开始,将q0及其访问标志1保存在数组单元Path[1]中,对q0后继的搜索通过调用Search子算法实现.具体描述如下.ETGBACheck()1.{length=1;2.Path[length]=(,,q0,1);//将q0和访问标3.Search(q0,1);//调用Search子算法对ETGBA继续搜索;4.}(2)Search子算法Search子算法对最近访问结点q的后继结点继续搜索,该子算法通过启发式on-the-fly判空检测方法,能较快地判断出ETGBA的非空性.具体算法如下.ProcedureSearch(NODEq,BOOLEANq_label)1.{BOOLEANb;//定义布尔型变量b;2.IF(post(q)==)THENDelete(q);//若q没有后继,调用Delete子算法做对q做删除操作;3.ELSETransPartition(q);//调用TransPartition子算法做对q的后继迁移作划分;4.WHILE(Trans≠)DO//当栈Trans非空时;5.{(s,c,s)=Trans.top();//读Trans栈顶的迁移关系;6.Trans.pop();//弹出Trans栈顶元素;7.j=Path.node2.find(s);//查找目标结点s是否已访问过,若已访问过,读出其在Path中的位置给j,否则j为-1;8.IF(j==-1)THEN//j为-1,是未访问过的结点9.{length=length+1;10.Path[length]=(s,c,s,1)//将迁移关系(s,c,s)及的s的访问标志1写入Path中;11.Search(s,1)};//以s为最近访问结点,递归调用Search子算法继续搜索;12.ELSEEmptycheck(s,c,s,s_label,j,length);}//若s是已访问过的结点,调用Emptycheck子算法作判空检测;13.IF(Trans==)THENEXIT“No,ETGBA为空”;//若栈Trans为空,算法终止并输出“No,ETGBA为空”;}//ENDSearch(NODEq,BOOLEANq_label)(3)Delete子算法Delete子算法对没有后继输出的结点q实施删除操作,并对q的父结点q_pre作判断,若q_pre的所有后继结点都带删除标志,则删除q_pre.算法描述如下.ProcedureDelete(q)1.{i=Path.node2.find(q);//读出q在path中的存储位置给i;2.Path[i].node2_label=0;Path[i].act=;//对q做删除操作:将path[i]中的迁移标识act置为,将q的访问标志置0;Page43.q_pre=Path[i].node1;//读出q的父结点q_pre;4.BOOLEANtp=TRUE;//布尔变量tp赋值为5.(s,c,s)=Trans.top();//读出Trans中的栈TRUE;顶元素;6.IF(q_pre≠s)THEN//q_pre与s不是同一结点,说明q_pre的后继结点都已访问过;7.{FORALLt∈post(q_pre)DO//选取q_pre的一个后继结点t;中的存储位置赋值给j;8.{j=Path.node2.find(t);//读取t在Path9.IF(Path[j].node2_label==1)//Path[j]中t的访问标志位为1,t是不带删除标志的结点;10.THEN{tp=FALSE;BREAK;}//tp赋值为FALSE,跳出FOR循环;11.}//ENDFORALLt∈post(q_pre)12.IFtpTHENDelete(q_pre);//tp为TRUE,调用Delete子算法,对q_pre做删除操作;13.}//endIF(q_pre≠p)14.}//endDelete(q)(4)TransPartition子算法TransPartition子算法对最近访问结点s的所有后继迁移做划分,若后继迁移的迁移标识不为,暂时存放在栈temp中,否则存放在栈Trans中,对s的后继迁移划分完毕后,将temp中的迁移关系合并到Trans中,并清空栈temp.具体算法描述如下.ProcedureTransPartition(NODEs)1.{FORALL(s,a,t)∈TDO2.{IF(a≠)THENtemp.push(s,a,t);//若s的后继迁移(s,a,t)包含可接受条件,则将其存放在栈temp中;3.ELSETrans.push(s,a,t);//否则,将(s,a,t)存放在栈Trans中;4.}//ENDFORALL(s,a,t)∈T5.WHILE(temp≠)DO//当temp非空时;6.{Trans.push(temp.top());//将temp的栈顶迁移关系压入Trans中;7.temp.pop();//弹出temp的栈顶元素;8.}//endWHILE(temp≠)9.}//endTransPartition(NODEs)(5)Emptycheck子算法Emptycheck子算法对已发现的非平凡SCCs包含的可接受条件进行计算,计算结果为f,若F—i∈F—,且F—if,说明此SCCs至少包含了ETGBA可接受条件集F—中的一个元素F—i,则终止算法并输出“Yes,非空的ETGBA”;否则,进一步判断并对极大非平凡SCCs做删除操作,反之则将(s,f,s)及s的访问标志1存入数组Path中,为以后形成更大非平凡SCCs的可接受条件的计算提供方便.具体算法描述如下.Emptycheck(s,c,s,s_label,INTs_position,length)1.{IF(s_label≠0)THEN//已访问过的目标结点s不带删除标志,说明有非平凡SCCs存在;2.{f=;f=f∪c;k=s_position+1;3.Forj=ktolengthDO4.f=f∪Path[j].act;//对非平凡SCCs包含的可接受条件作合并运算;5.IFF—i∈F—ANDF—if//非平凡SCCs包含ETGBA可接受条件集F—中的一个元素F—i6.THENEXIT“Yes,非空的ETGBA”;//终止算法并输出“Yes,非空的ETGBA”,检测出ETGBA非空;7.ELSE{i=s_position;(p,a,q)=Trans.top();8.IFALLt∈path[i..length].node2.post()ANDt≠q//若非平凡SCCs是不满足ETGBA可接受运行条件的极大非平凡SCCs;9.THEN{Path[i..length].act=;10.Path[i..length].label=0;}//则对此极大非平凡SCCs做删除操作;11.ELSE{Length=length+1;12.Path[length]=(s,f,s,1);}//否则,将(s,f,s)及s的访问标志1存入Path中;13.}//ENDELSE{i=s_position;(p,a,q)=Trans.top();14.}//ENDIF(s_label≠0);15.}//END.2.2算法实例算法的主要过程.以图1为研究实例,完整地描述MCA_ETGBA图1中结点A为初始状态,可接受条件集F—={{a,b,c};{a,c,d}},其中F—1={a,b,c},F—2={a,c,d}.MCA_ETGBA算法的判空检测过程如下,数组Path和栈Trans中数据的相应存放情况如表1所示.Page5表1数组犘犪狋犺和栈犜狉犪狀狊中数据的存放过程stepnode1A(,,A,1)2B(,,A,1)(A,,B,1)3X(,,A,1)(A,,B,1)(B,d,X,1)4Y(,,A,1)(A,,B,1)(B,d,X,1)(X,,Y,1)5Z(,,A,1)(A,,B,1)(B,d,X,1)(X,,Y,1)(Y,c,Z,1)6(,,A,1)(A,,B,1)(B,,X,0)(X,,Y,0)(Y,,Z,0)7F(,,A,1)(A,,B,1)(B,,X,0)(X,,Y,0)(Y,,Z,0)(B,c,F,1)(B,,C)(B,,K)(F,,G)(F,,H)8H(,,A,1)(A,,B,1)(B,,X,0)(X,,Y,0)(Y,,Z,0)(B,c,F,1)9J(,,A,1)(A,,B,1)(B,,X,0)(X,,Y,0)(Y,,Z,0)(B,c,F,1)10I(,,A,1)(A,,B,1)(B,,X,0)(X,,Y,0)(Y,,Z,0)(B,c,F,1)11G(,,A,1)(A,,B,1)(B,,X,0)(X,,Y,0)(Y,,Z,0)(B,c,F,1)12K(,,A,1)(A,,B,1)(B,,X,0)(X,,Y,0)(Y,,Z,0)(B,,F,0)13L(,,A,1)(A,,B,1)(B,,X,0)(X,,Y,0)(Y,,Z,0)(B,,F,0)(F,,H,0)(H,,J,0)(H,,I,0)(F,,G,0)(B,,K,1)(K,b,L,1)(B,,C)(K,,P)(L,,M)14M15N16O1718P19Q20f={a,b,c},F—1f,输出“Yes,非空的ETGBA”并终止算法1.访问A,将(,,A,1)存入数组Path中;2.从Trans中读取(A,,B)为搜索目标,将(A,,B,1)存入Path中,B为最近访问结点;3.读取(B,d,X)为搜索目标,依次将(B,d,X,1)、(X,,Y,1)、(Y,c,Z,1)存入Path中(对应表1中的步骤3~步骤5);4.读取(Z,a,X)为搜索目标,发现存在非平凡SCCs,其包含的可接受条件为{c,a},不满足ETGBA的可接受运行,为极大非平凡SCCs,对X、Y、Z做删除操作;5.读取(B,c,F)为搜索目标,依次将(B,c,F,1)、(F,,H,1)、(H,,J,1)存入Path中(对应表1中的步骤7~步骤9);6.J为没有后继的结点,依次对J、I、H、G、F做删除操作;7.从Trans中读取(B,,K)为搜索目标,依次将(B,,K,1)、(K,b,L,1)、(L,,M,1)、(M,c,N,1)、(N,,O,1)存入Path中(对应表1中的步骤12~步骤16);8.从Trans中读取(O,,B),发现存在非平凡SCCs,其包含的可接受条件为{b,c},将(O,{b,c},B,1)存入Path中;9.从Trans中读取(K,,P),依次将(K,,P,1)、(P,,Q,1)存入Path中(对应表1中的步骤18~步骤19);10.读取(Q,a,M)为搜索目标,发现存在非平凡SCCs,其包含的可接受条件为{a,b,c},满足ETGBA的可接受运行,输出“Yes,非空的ETGBA”并终止算法.表1中step表示操作步骤,node表示最近访问的结点,数组Path和栈Trans中数据的存放顺序为从左到右,从上到下.Page63正确性证明及复杂度分析定义1.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,p∈Q,q∈Q,将q是p的后继结点记为q=post(p),将p是q的父结点记为p=pre(q).定义2.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,p∈Q,q∈Q,且q=post(p),称由结点p到结点q之间存在状态转换关系,记为p→q.定义3.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,若C中存在qi→qi+1,qi+1→qi+2,…,qj-1→qj,则称qi到qj可达,记为qi→attqj.定义4.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,且T∈Q×2F—×Q,若C中与qi→attqj相应的迁移转换序列为(qi,ai,qi+1),(qi+1,ai+1,qi+2),…,(qj-1,aj-1,qj),则称(qi,ai,qi+1)到(qj-1,aj-1,qj)可达,记为(qi,ai,qi+1)→att(qj-1,aj-1,qj).引理1.在MCA_ETGBA算法中,若Path[i].node2_label≠0,Path[j].node2_label≠0,i<j,则Path[i].node2→attPath[j].node2成立.证明.假设MCA_ETGBA算法对ETGBA进行搜索时,最近访问的结点为qi-1,相应迁移关系(qi-2,ai-1,qi-1)已存放在Path[i-1]中,当Search子算法搜索qi-1的后继时,先调用TransPartition子算法划分qi-1的后继迁移并存放在Trans中,然后从Trans中读取一个未访问过的后继迁移,设为(qi-1,ai,qi),执行程序行7~10,将(qi-1,ai,qi)写入Path[i]中,并以qi作为最近访问的结点,在程序行11递归调用Search子算法,重复以上过程,继续搜索,当读取(qj-1,aj,qj)时,将(qj-1,aj,qj)写入Path[j]中,故(qi-1,ai,qi)到(qj-1,aj,qj)可达,即(qi-1,ai,qi)→att(qj-1,aj,qj),qi→attqj成立,即Path[i].node2→attPath[j].node2成立.证毕.定理1.设SCCsi为ETGBA的非平凡SCCs,Path[i].node2=q,(s,c,s)=Trans.top(),且Path[i].node2_label=0,Path[i].node1≠s,i为数组Path的长度,若qk不是SCCsi中结点,且对SCCsi不可达,则MCA_ETGBA算法能删除qk.证明.由Path[i].node2=q及i为数组Path的长度知,q为最近访问的结点.由Path的数据结构知,pre(q)=Path[i].node1.MCA_ETGBA算法调用Search子算法对q的后继进行搜索时,若q没有后继输出,则调用Delete子算法对q做删除操作,将其访问标志置为0.由Path[i].node2_label=0知,最近访问的结点q没有后继且已做过删除处理.由引理1知,最近访问结点q的所有后继迁移及pre(q)所有未访问过的后继迁移都存放在Trans中.当Delete子算法从Trans中读取栈顶元素(s,c,s)时,由q没有后继且Path[i].node1≠s可知,pre(q)的后继结点都已访问过.在Delete子算法的程序行7~11对pre(q)的后继结点作判断,若pre(q)所有的后继结点都带删除标志,则将pre(q)作为要删除的结点q,递归调用Delete子算法,对其做删除操作,进而删除不能到达和不能构成SCCsi的结点qk.定理2.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,C的可接受条件集为F—={F—1,F—2,F—3,…,F—n},对于C作为输入,若MCA_ETGBA算法输出“Yes,非空的ETGBA”,那么F—i∈F—,fSCCsk,使F—if,且q0→attSCCsk,其中SCCsk为C中的非平凡SCCs,1in,f为SCCsk包含的可接受条件,因此C具有可接受运行序列,C非空.证明.在MCA_ETGBA算法中,由Search子算法的程序行7~8,12知,当目标结点s是已访问过的结点时,调用Emptycheck子算法对C作判空检测.在Emptycheck子算法中,若s不带删除标志,则发现有非平凡SCCs存在,可将其记为SCCsk,计算其包含的可接受条件f,即有fSCCsk,由程序行5~6知,算法输出“Yes,非空的ETGBA”的前提是存在某个F—i∈F—,且F—if,说明SCCsk满足F—i.假设F—i={a1,a2,…,an},SCCsk包含的迁移序列为(si,a1,qi),(qi,a2,qi+1),…,(qj,an,si),当MCA_ETGBA算法访问SCCsk时,由引理1知,si→attqj成立,且qj→si,由此形成无穷运行的迁移序列为TS:((si,a1,qi),(qi,a2,qi+1),…,(qj,an,si))(其中“”表示无穷多次运行).由TS可知,F—i在SCCsk的无穷运行迁移序列中无穷多次出现.在ETGBACheck子算法中,在程序行2将(,,q0,1)写入Path[1]中,在程序行3调用Search子算法对C进行搜索的过程中,依次将所访问的迁移序列及相应访问标志写入Path数组单元,当访问到迁移关系(si-1,ai,si)时,将(si-1,ai,si,1)写入Path[j]中,其中ji>0,由引理1知,q0→attsi,又由si∈SCCsk知,q0→SCCsk.从以上证明可知,定理2成立.证毕.定理3.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,若C存在可接受运行,则MCA_ETGBA算法输出Page7“Yes,非空的ETGBA”,判断C非空.证明.假设MCA_ETGBA算法输出“No,ETGBA为空”,由Search子算法知,Trans=是算法输出“No,ETGBA为空”后终止运行的唯一条件,此时算法已对C中所有状态结点和迁移关系进行了访问,此前唯一能够终止MCA_ETGBA算法的语句是Emptycheck子算法的程序行5~6,因此,MCA_ETGBA算法输出“No,ETGBA为空”的前提条件是搜索了C以后,没有发现存在非平凡SCCs满足某个F—i∈F—,使得F—if成立,即C的可接受运行序列不存在,与题设条件相矛盾,故本定理成立.引理2.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,MCA_ETGBA算法对C中的状态和迁移关系至多搜索一次.证明.在ETGBACheck子算法中,先访问q0,然后调用Search子算法对q0的后继进行搜索,若最近访问结点q没有后继,则调用Delete子算法对q做删除操作,由定理1知,Delete子算法能进一步判断q的父结点并做相应的删除操作,使得Search子算法以后不再搜索这些结点.在Search子算法的程序行5~6,从Trans栈顶读取一个迁移关系后,将其出栈,以后不再访问,若目标结点没有访问过,则程序行10将该迁移关系及访问标志1写入数组Path中,然后以此目标结点为最近访问结点,重复上述过程继续搜索;若读取的目标结点已访问过,则程序行12调用Emptycheck子算法作判空检测.在Emptycheck子算法中,若目标结点带有删除标志,则对其不做处理,返回到Search子算法中,继续从Trans栈顶读取新的迁移关系,重复以上过程;若目标结点已访问过且未作删除标志,此时发现有非平凡SCCs存在,若发现存在某个F—i∈F—且F—if,终止算法并输出“Yes,非空的ETGBA”,否则,继续执行程序行7~8,进一步判断此SCCs是否为极大非平凡SCCs,若是,在程序行9~10对此SCCs中所有结点做删除标志,以后再遇到这些结点时无需处理,否则,执行程序行11~12,将相应迁移关系(s,f,s)及s的访问标志1写入Path中,然后返回到Search子算法中,此时若Trans栈非空,继续从Trans栈顶读取新的迁移关系,重复以上过程.综上所述,算法对C中已访问过的状态和迁移关系没有重复搜索,因此,MCA_ETGBA算法对C中的状态和迁移关系至多搜索一次.定理4.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,对于C作为输入,在C为空的最坏情况下,MCA_ETGBA算法的空间复杂度为O(k|T|+k),其中C所包含的迁移关系数为k,存储C中迁移关系Ti(Ti∈T)所需最大空间为|T|.证明.MCA_ETGBA算法在搜索过程中,使用栈Trans,temp,数组Path和整型变量length作为辅助数据结构.栈Trans和temp用来存放最近访问结点的后继迁移关系.从TransPartition子算法的执行过程可知,栈Trans和temp所占用的空间最后只需考虑栈Trans占用的空间即可.在Search子算法的程序行5~12,先读出Trans栈顶元素中的迁移关系(s,c,s),然后作出栈操作,若目标结点s没有访问过,则将(s,c,s,1)存入Path数组单元中,若s已访问过且未做删除标志,在Emptycheck子算法的程序行12,将(s,f,s,1)存入Path数组中,这一过程表明Path数组中存放的迁移关系与Trans栈中弹出的元素具有对应关系.搜索完C后,Trans栈为空,故栈Trans、temp和数组Path所占用总空间的计算最后只需考虑Path占用的空间即可.在最坏情况下,C中不存在可接受运行序列,MCA_ETGBA算法需要搜索C的整个状态空间,由引理2知,MCA_ETGBA算法需要对C中所有的状态结点搜索一次.由引理1知,已访问结点的所有后继迁移都曾经存放栈Trans中,又由上述Search子算法的搜索过程可知,数组Path的长度为C中的迁移关系数k.由于|T|为存储C中迁移关系Ti(Ti∈T)所需最大空间,故数组Path中存放的迁移关系占用的空间大小为k|T|.每个Path数组单元中存储布尔型访问标志占用的空间大小为1,因此,搜索完C后,数组Path占用的空间大小为k|T|+k.整型变量length用来记录数组Path的长度,其占用的空间大小为某个常数c.综上所述,MCA_ETGBA算法在最坏情况下占用的空间大小为k|T|+k+c,其空间复杂度为O(k|T|+k).定理5.C=〈珦A,Q,ξ,F—,q0,T〉为一个ETGBA,对于C作为输入,在C为空的最坏情况下,MCA_ETGBA算法所用时间为O(l+k),其中C所包含的迁移关系数和状态结点数分别为k和l.证明.由定理4知,MCA_ETGBA算法在最坏情况下,对C中所有状态和迁移关系都要搜索一次.C包含的状态和迁移关系个数之和为l+k,因Page8此,MCA_ETGBA算法的时间复杂度为O(l+k).4实验4.1实验比较本文在ThinkVisionPC机(3.20GHzIntel?CoreTMi5-3470CPU、4.00GB内存)上,采用C++语言编程实现了MCA_ETGBA算法.实验分为两组,第1组实验根据文献[14]提供的benchmark数据,从中选取不同大小的10类广义Büchi自动机,运用MCA_ETGBA算法和Tauriainen算法、Couvreur算法、Gaiser算法作判空检测,实验结果见表2和表3.第2组实验根据广义Büchi自动机的主要结构特征,随机构造7类广义Büchi自动机:源数据的状态空间表2各类算法检测10类benchmark数据所需遍历的状态空间Couvreur算法statestransitionsstatestransitions604631539565837758377576241458105844220119758173329198506132286322862985977283323311136773912129188581512915429154285235669529185792102967256857296824758247581557356624854925088825518928357721862318639185743527618623581068623618138455361808118081179764516418083755542278159406090715940159401035440225159409253093394113392676811336113361128426632114564090711931915062697150615061080183215164542122911462085114611541122204111472906712表3各类算法检测10类benchmark数据需要的时间(time)与空间(memory)time/smemory/KB源数据的状态空间statestransitions604631539564.30745468581618.3613363005201809.74731737430.001042730832919850612.3686130407548.053633469969924.69714427750.000711885829188581512.1896123431455.991812602950239.03900312170.000431252825685729681.88681255548.271942130530477.59691356870.001971675618928357721.2016025273548.021013363311639.47342418990.001791241518138455361.0839926758245.70856519849918.07984577290.00049685715940609071.0009130093130.77982644918401.04505989180.00488985711339267680.7604523799180.01369363394041.40339367070.0025910511150626970.1004946413.809885533285.2856865340.000214570114620850.0940466855.865597104表4各类算法对广义Büchi自动机作出非空性判断的有效性判空检测算法Gaiser算法检测正确检测正确检测正确检测正确存在失效检测正确检测正确Couvreur算法存在失效检测正确检测正确检测正确检测正确存在失效检测正确Tauriainen算法检测正确检测正确检测正确检测正确检测正确检测正确检测正确MCA_ETGBA算法检测正确检测正确检测正确检测正确检测正确检测正确检测正确分析表2、表3和表4可知,MCA_ETGBA算法与Tauriainen算法检测的准确性比较高,但Tauriainen算法需要更多的检测时间和内存空间,MCA_ETGBA(1)广义Büchi自动机中存在带有后向迁移的更大无环子图(称为TGBA1&GBA1);(2)广义Büchi自动机的可接受条件分布在多个不同的SCCs中,且这些SCCs有一个共同的根结点(称为TGBA2&GBA2);(3)广义Büchi自动机的所有可接受条件分布在一个简单的非平凡SCCs中(称为TGBA3&GBA3);(4)广义Büchi自动机的可接受条件分布在嵌套有子SCCs的非平凡SCCs中(称为TGBA4&GBA4);(5)广义Büchi自动机的可接受条件分布在由多个子SCCs交织构成的非平凡SCCs中(称为TGBA5&GBA5);(6)广义Büchi自动机中存在带有后向迁移且不满足可接受运行条件的极大非平凡SCCs(称为TGBA6&GBA6);(7)空的广义Büchi自动机(称为TGBA7&GBA7).对这7类广义Büchi自动机进行检测后,实验结果如表4所示.算法与Couvreur算法相比,MCA_ETGBA算法检测的准确性及时空性能均优于Couvreur算法,MCA_ETGBA算法与Gaiser算法相比,MCA_ETGBAPage9算法进一步提高了判空检测的全面性与有效性,在通常情况下作出非空性判断所需访问的状态空间更少,时空性能更高.当对广义Büchi自动机作判空检测时,由于本文提出的MCA_ETGBA算法具有启发式on-the-fly判空检测的优点,在结构上对广义Büchi自动机的迁移关系作了化简,在算法中加强了对不能到达和不能构成非平凡SCCs的结点及不满足广义Büchi自动机可接受运行条件的极大非平凡SCCs的处理,因此,在通常情况下,MCA_ETGBA算法对广义Büchi自动机能作出有效的判空检测,且非空性判断所需遍历的状态空间较少,时图2各子系统功能行为的FSP模型采用文献[13]中图8作为系统的基本安全需求模型,对系统的子系统模型及基本安全需求模型在模型检测工具LTSA中作组合运算后生成扩展的广义Büchi自动机模型,采用MCA_ETGBA算法对其作判空检测,检测结果为“No,ETGBA为空”,所需时间约为0.0084s,所需空间为9252KB,该模型为空,说明系统设计满足安全性要求.若在系统的道岔部件(Switch)中注入故障事件:系统发出锁闭道岔命令(switchLock)后,道岔没有执行指令,锁闭失效(switchLockFail),则注入故障后Switch和ILController的相应FSP模型,如图3和图4所示.将图2中(a)、(b)、(e)子图和图3、图4所示模型与系统的基本安全需求模型在LTSA中作组合空性能更优,使得MCA_ETGBA算法具有明显的优势.4.2实例研究根据文献[13]所描述的铁路车站计算机联锁系统中基本进路建立的需求场景,相应的系统设计可由用户操作(User)、联锁控制中心(ILController)、道岔管理(Switch)、轨道区段(Section)及信号灯控制(LED)这几个子系统组成,各子系统功能行为的FSP模型如图2所示,图2由子图(a)、(b)、(c)、(d)、(e)组成,其中各个动作行为的具体含义如文献[13]中的表1所示.运算,新生成的模型包含的状态结点数为177,迁移数为336,采用MCA_ETGBA算法对其作判空检测,检测结果为“Yes,非空的ETGBA”,形成相应反例为routeSelect→routeOccupied→antiRouteCheck→noAntiRouteBuilt→routeCheck→routeEmpty→switchCheck→checkOK→antiRouteLock→switch-Lock→switchLockFail→enableLED→openLED→ledOpened→routeBuiltOK→trainComing→close-LED→dismissSwitchAll→switchUnlock→routeSelect,Page10图4注入故障后ILController相应的FSP模型根据系统的基本安全需求模型,此反例违反了子条件集{routeSelect,switchLockFailure,routeBuiltOK}与{routeSelect,routeOccupied,routeBuiltOK},说明系统中不能存在道岔锁闭失效的情况下仍能建立进路的危险情形,否则,该系统为不安全的系统.以上实例的检测结果与铁道行业标准[15]中规定的基本联锁功能中的要求相一致,因此,本文提出的MCA_ETGBA算法是实际可行的.5结论本文从安全苛求计算机系统的安全性分析与验证实践出发,提出了MCA_ETGBA算法,从理论上证明了算法的正确性,并对算法的时空复杂度作了分析.MCA_ETGBA算法通过启发式on-the-fly判空检测,克服了传统的广义Büchi自动机判空检测过程中存在的盲目搜索问题,在对ETGBA模型的状态空间进行搜索的过程中,加强了对没有后继输出结点的删除操作及其父结点的判断与相应处理,并对不满足ETGBA可接受运行条件的极大非平凡SCCs进行了相应的判断与处理,从而使得MCA_ETGBA算法在检测过程中再次遇到不能构成ETGBA可接受运行序列的结点时无需再处理,提高了检测效率,节省了系统所需的内存空间,能较快地判断出ETGBA的非空性.通过铁路车站联锁系统中基本进路建立的安全性验证实例验证了本文所提出算法的实际可行性.与已有算法相比,MCA_ETGBA算法的通用性与实用性更强,当对广义Büchi自动机作判空检测时,在通常情况下MCA_ETGBA算法能对广义Büchi自动机进行有效的检测,且非空性判断所需遍历的状态空间较少,时空性能更优.MCA_ETGBA算法为安全苛求计算机系统的形式化安全防护分析与验证评估提供了新方法.
