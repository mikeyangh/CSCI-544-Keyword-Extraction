Page1一种面向大规模URL过滤的多模式串匹配算法刘燕兵1),2)邵妍3)王勇4)刘庆云1),2)郭莉1),2)1)(中国科学院信息工程研究所北京100093)2)(信息内容安全技术国家工程实验室北京100093)3)(北京邮电大学计算机学院北京100876)4)(国家计算机网络与信息安全管理中心北京100029)摘要对大量有害的URL进行过滤,是目前网络安全应用系统中所亟需的关键技术.使用经典的串匹配算法检测庞大的URL规则集,需要消耗大量的计算资源和存储资源,性能十分低下.该文设计了一种适合于大规模URL过滤的多模式串匹配算法———SOGOPT.该算法在经典的SOG算法基础上,针对URL规则的特点,提出了最优窗口选择、模式串分组规约这两种优化技术,大幅度提高了SOG算法的匹配速度,在大规模URL规则集上效果尤其显著.该文设计的算法非常适合于大规模(100万级)URL实时在线匹配的应用环境.关键词多模式串匹配;URL过滤;最优窗口选择;模式串分组规约;信息安全;网络安全1引言所谓多模式串匹配(后文简称串匹配)是指:给定字符串集合P={p(1),p(2),…,p(r)},其中p(i)=2…p(i)p(i)1p(i)入文本串T=t1t2…tn,找出P中的字符串在T中的所有出现位置.称P为模式串集合,称p(i)为模式串,称T为文本.串匹配技术在网络信息安全领域有着广泛的应用,典型的应用包括:入侵检测/防御系统(IDS/IPS)、反病毒和反垃圾邮件检测(AV/AS)、网络带宽管理和服务质量(QoS)、统一威胁管理(UTM)等等.与此同时,串匹配技术在文本检索、搜索引擎、语言翻译、拼写检查、计算生物学等领域也发挥着关键的作用.对大量有害的URL进行过滤,是目前网络安全应用系统中所亟需的关键技术.目前有七类典型应用需要进行URL过滤,包括:色情内容、垃圾邮件、恶意软件、漏洞利用、网络钓鱼、代理和可能不受欢迎的应用.对这些造成巨大危害的URL进行过滤,可以有效地对人们上网浏览非法、有害、不良信息内容进行控制与管理,创造绿色洁净的网络空间环境.在海量的网络数据中检测庞大的URL规则集,需要消耗大量的计算资源和存储资源,如何保证串匹配算法仍然能够高效实时地运行,是我们当前面临的一个重大难题.本文设计了一种适合于大规模URL过滤的多模式串匹配算法———SOGOPT.该算法在经典的SOG算法基础上,针对URL规则的特点,提出了最优窗口选择、模式串分组规约这两种优化技术,大幅度提高了算法的匹配速度,在大规模URL规则集上效果尤其显著.实验结果显示:在100万URL规则上,SOGOPT算法的匹配速度是原始SOG算法的4.33倍,并且性能远远优于其它经典串匹配算法(AC[1]、SBOM[2]、KR[3]、WM[4]).本文设计的算法非常适合于大规模URL实时在线匹配的应用环境.本文第2节介绍串匹配的相关工作;第3节介绍本文提出的面向大规模URL过滤的串匹配算法———SOGOPT;第4节将本文提出的匹配算法同其它经典串匹配算法进行实验比较;第5节是本文的总结.2相关工作根据多模式串匹配算法的特点,我们将已有的算法分为三大类:基于自动机的匹配算法、基于散列的匹配算法和基于位并行的匹配算法.(1)基于自动机的匹配算法采用自动机作为基本的数据结构,用自动机识别模式串的前缀或者子串.AC[1]和SBOM[2]是这类算法的典型代表.自动机类型匹配算法的优点是适应性好,在不同类型的数据集上的性能稳定.其缺点是自动机需要消耗巨大的存储空间,无法支持大规模串匹配.例如,对于100万个长度为10的字符串,AC自动机大约需要消耗106×10×1KB≈10GB的存储空间.(2)基于散列的匹配算法采用散列表作为基本的数据结构,用散列表记录模式串的散列值,并与待匹配文本的散列值进行比对,以检测模式串和文本是否匹配.KR[3]和WM[4]是这类算法的典型代表.散列类型算法的优点是存储空间较小,在大字符集随机数据上的匹配速度很快.但是对于字符集较小并且字符分布极不均匀的数据(例如URL、Email等),这类算法的实际性能很差.(3)基于位并行的匹配算法采用位向量来模拟串匹配自动机的匹配过程,将自动机的状态跳转表示为位向量的运算,并通过机器字来高效执行.Shift-AND/Shift-OR[5]和BNDM[6]是这类算法的典型代表.这类算法的优点是存储空间小,匹配速度快,在普通PC上甚至能达到1GB/s的匹配速度.但是受限于机器字宽的限制,位并行算法只适合于小规模(几个~十几个模式串)串匹配.近年来,国内外研究者在模式串匹配方面提出了一些新的结果[7-15].文献[7]和文献[8]结合AC算法和跳跃的思想,提出了改进的多模式串匹配算法.不同的是,前者采用QuickSearch的思想进行跳跃,而后者汲取BM算法中跳跃的特性,采用后缀树算法得到最大跳跃值.当模式串数量较少时(千级),这两个算法的匹配效率相比AC算法有较大提高.但是,对于大规模模式串(10万级以上),这两个算法的跳跃能力基本退化至零,匹配效率与AC算法相当.文献[9]提出了一种时间复杂度最优的串匹配算法LDM.该算法综合使用后缀自动机DAWG和AC自动机同时进行反向和正向匹配,其最坏时间复杂度和平均时间复杂度均达到理论最优.但是,该算法需要存储两个自动机,庞大的存储开销更是无法支持大规模串匹配.文献[10]利用散列函数和BloomFilter技术存储模式串的摘要信息,使得大部分的数据访问都局限在缓存之中,提高了缓存命中率.该算法本质上是WM[4]算法的变体,只适合于大字符集和较长模式串的匹配.文献[11]提出了Page3基于q-gram技术的匹配算法SOG.该算法利用q-gram技术快速排除掉不可能匹配的文本,对剩下可能匹配的文本和模式串进行比对.随机数据集上的实验表明,该算法能够有效地进行1万~10万规模的串匹配,但是在URL数据集上的实际效果不佳.文献[12]从URL过滤的应用目的出发,提出了一种URL散列与多模式串匹配算法相结合的方法,以达到较高的查找速度和有效的内存利用率.但是该方法只支持分节URL前缀匹配,并不支持子串匹配功能,因而限制了其应用范围.综上所述,已有的算法比较适合中小规模的串匹配,当模式串规模为几千时,现有算法的匹配效率很高.但是当模式串规模达到10万以上时,这些算法存在存储空间过大或匹配速度降低的问题,无法完全满足实际应用的需求.同时,现有的匹配算法研究主要是针对一般的模式串(随机串、中文、英文等)进行优化,针对特定类型模式串(如URL、Email等)的研究工作很少.因此,需要进一步研究针对大规模URL过滤的高效匹配算法.3大规模URL串匹配算法———SOGOPT本节提出一种面向大规模URL过滤的多模式串匹配算法———SOGOPT.该算法在经典的SOG算法[11]的基础上,针对URL的特点进行专门优化,以适应大规模URL匹配的需求.本文主要通过如下两种优化技术来提高串匹配算法的速度:(1)以最大二部图匹配理论为基础,为URL模式串选择最优的窗口,以减少哈希函数的冲突,使得URL散列更加均匀;(2)对URL模式串进行分组规约,在同一个机器字内并行执行多组SOG算法,以达到减少校验次数、提高匹配速度的目的.在3.1节中,我们首先介绍原始SOG算法的基本思想,并分析其对大规模URL进行过滤时的不足之处.针对原始SOG算法的缺点,3.2节和3.3节分别介绍本文提出的两种优化技术.3.1SOG算法的基本思想及其不足SOG算法是Salmela等人[11]提出的面向10万规模模式串的匹配方法.在随机数据集上的测试表明,该算法优于众多其它经典串匹配算法.该算法的基本思想是:首先,将模式串集合P={p(1),p(2),…,p(r)}规约为一个通配形式的模式串p;然后,使用位并行串匹配算法Shift-OR[5]对p进行搜索;最后,对于可能出现的匹配位置,使用二级哈希和二分搜索进行校验,以报告所有真正匹配的结果.本质上,SOG算法是一种过滤型串匹配算法,适合于模式串命中较少的应用场景.直接使用SOG算法进行大规模URL匹配,其匹配速度比较低下.究其原因,存在如下两个方面的不足:(1)哈希函数严重聚集与冲突:SOG算法与KR[3]、WM[4]等算法一样,都使用哈希函数对可能出现的匹配位置进行校验,以报告所有真正匹配的结果.当模式串长度不相等时,算法需要从每个模式串中选取一个长度为m的子串作为待查找的目标,这里m是最短模式串的长度.选取的长度为m的子串称之为窗口.通常的窗口选择方法是从每个模式串中选取长度为m的前缀或者后缀.但是,URL分布极不均匀,往往具有大量的相同前缀或者后缀,从每个模式串中选取的长度为m的子串往往出现大量重复,导致哈希函数的严重聚集与冲突.大量的模式串散列到相同的位置,散列表中某些链表过长,大幅度增加了校验的代价.针对这一缺点,3.2节提出最优窗口选择方法,为模式串选择合适的窗口子串,使得哈希函数的冲突达到最小.(2)较高的校验次数:SOG算法是一种过滤型算法,需要对可能出现匹配的位置进行校验.校验是极费时间的操作,校验次数越多,算法匹配速度越慢.随着模式串集合的增大,SOG算法的校验次数越来越高,算法匹配速度下降.针对这一缺点,3.3节提出模式串分组规约方法,大幅度减少了SOG算法的校验次数.3.2最优窗口选择如上节所述,当模式串长度不相等时,SOG、WM、KR等算法需要从每个模式串中选取一个长度为m的子串作为待查找的目标,这里m是最短模式串的长度.选取的长度为m的子串称之为窗口.对于模式串集合P={p(1),p(2),…,p(r)},其中p(i)=2…p(i)p(i)1p(i)在经典的串匹配算法中,并没有考虑窗口选择的问题.在SOG、WM、KR等算法中,通常是截取每个模式串中最左(或者最右)的m个字符作为模式串的窗口,然后对这些窗口计算哈希值(不是对整个模式串计算哈希值),将模式串插入到散列表中.URL这种字符分布极不均匀的模式串,往往具有大量的相同前缀或者后缀,如果简单地选取最左(或者最右)的窗口进行散列,必然导致大量的URL散列Page4到同一个桶中,导致严重的哈希冲突,哈希表的查找性能也十分低下.为了减少串匹配算法中哈希表的冲突,本文提出一种最优的窗口选择方法,使得哈希表的均匀性最好.该方法的基本思想是选出模式串中最独特、最具有区分度的子串,使得它能唯一代表该模式串,即寻找模式串集合与其子串之间的一一对应关系,使得每个模式串尽可能对应不同的子串,从而最大程度地减少哈希函数的聚集与冲突.通过为每一个URL模式串选择合适的窗口,每个窗口唯一代表该URL,避免了相同前缀的URL散列到同一个桶中.因为每个模式串有mi-m+1种可供选择的窗口,模式串集合P={p(1),p(2),…,p(r)}上共有∏r(mi-m+1)种不同的窗口选择组合,简单的枚i=1举搜索显然是不可行的.我们将上述最优窗口选择形式化为最大二部图匹配问题:设二部图为G=(V1,V2,E).模式串集合P={p(1),p(2),…,p(r)}中的模式串组成顶点集V1.模式串所有长度为m的子串组成顶点集V2.二部图G中存在一条连接左侧顶点u∈V1和右侧顶点v∈V2的边e=(u,v)∈E,当且仅当v是u的子串.显然,模式串p(i)=p(i)mi在二部图中对应于mi-m+1条边.于是,模式p(i)串的最优窗口选择问题等价于求解二部图G的最大匹配问题,即为V1中的每一个顶点寻找一条边,使得V2中的顶点出现的最多.利用最大二部图匹配理论选择最优窗口的过程如算法1所示.首先,根据模式串集合P构造二部图(算法1的第1~8行),然后使用经典的最大流算法求解最大二部图匹配(算法1的第9行),最后根据二部图匹配的结果为每个模式串选择最优的窗口(算法1的第10行).算法1.基于最大二部图匹配的最优窗口选择方法.输入:模式串集合P={p(1),p(2),…,p(r)}输出:各模式串的最优窗口OptimalWindowSelection(P={p(1),p(2),…,p(r)})1.m←minp∈P|p|2.V1←P,V2←,E←3.FOReachpatternp(k)=p(k)4.FOReachsubstringvi=p(k)5.E←E∪{(p(k),vi)}6.V2←V2∪{vi}7.ENDFOR8.ENDFOR9.R←MaxBipartiteMatching(G=(V1,V2,E))10.foreachpair(p(k),v)∈R,substringvisthe基于最大二部图匹配的窗口选择方法虽然能得到理论上的最优解,但是算法1的时间复杂度很高,不适合在实际工程中应用.为此,我们设计了一种快速的近似算法来进行窗口选择,以降低计算的代价.近似算法的基本思想是:首先统计所有模式串中可能出现的长度为m的子串的出现频率(算法2的第1~7行).子串出现频率越低,说明该子串是不常见的字符串,因而适合被选作模式串的窗口.对于特定的模式串,选择其窗口为它所包含的长度为m的子串中出现频率最低者(算法2的第8~11行).近似算法的步骤如算法2所示.算法2.近似最优的窗口选择方法.输入:模式串集合P={p(1),p(2),…,p(r)}输出:各模式串的近似最优窗口NearOptimalWindowSelection(P={p(1),p(2),…,p(r)})1.m←minp∈P|p|2.count[]←3.FOReachpatternp(k)=p(k)4.FOReachsubstringvi=p(k)5.count[vi]←count[vi]+16.ENDFOR7.ENDFOR8.FOReachpatternp(k)=p(k)9.vmin←argmin{count[vi]|vi=p(k)10.vministhenearoptimalwindowforpatternp(k)11.ENDFOR算法1和算法2的时间复杂度和空间复杂度分析如下.定理1.算法1的时间复杂度为O(r2L2),空间复杂度为O(rL),其中r是模式串的个数,L为模式串的平均长度.证明.根据最大流算法的理论,最大二部图匹配的时间复杂度为O(|V||E|),空间复杂度为O(|V|+|E|),其中|V|是二部图的顶点数,|E|是二部图的边数.算法1的主要时间开销为计算最大二部图匹配,二部图的顶点数|V|=(Or+∑rO(rL),边数|E|=(O∑r此算法1的时间复杂度为O(|V||E|)=O(r2L2),空间复杂度为O(|V|+|E|)=O(rL).证毕.Page5定理2.算法2的时间复杂度为O(rLlogrL),空间复杂度为O(rL),其中r是模式串的个数,L为模式串的平均长度.证明.算法2中主要的时间代价是统计长度为m的子串的出现频率.模式串集合P中总共有∑r(mi-m+1)=O(rL)个长度为m的子串,如果i=1用平衡二叉树来实现子串的频率统计(算法2中的第5行),一次计数的时间代价为O(logrL).算法2中3~6行的时间代价为O(rLlogrL),8~9行的时间代价也为O(rLlogrL),因此算法2的时间复杂度为O(rLlogrL).因为平衡二叉树具有线性的空间复杂度,因此算法2的空间复杂度为O(rL).证毕.为了度量窗口选择方法对降低哈希函数冲突、改善哈希函数均匀性的效果,我们采用文献[16]中定义的“信息查询性能测度”作为评价哈希函数均匀性的指标.“信息查询性能测度”定义为1其中Ni是哈希表中第i个桶的链表长度,N=∑M是哈希表中元素的总数,M是哈希表的大小.“信息查询性能测度”的物理意义是:假设查询每个URL的概率均为1哈希表的“信息查询性能测度”(测试数据集中最短URL长度为犿=6,哈希表的大小为犕=224)表1不进行窗口选择、基于最大二部图匹配的最优窗口选择(算法1)、近似最优窗口选择(算法2)3种情况下URL规模不进行窗口选择基于最大二部图匹配的最优窗口选择(算法1)近似最优窗口选择(算法2)2万条URL5万条URL10万条URL633.582710需要说明的是,本节提出的窗口选择方法是一种针对串匹配算法的通用优化技术,不限于优化SOG算法,同样可以应用于KR[3]和WM[4]等散列类型的串匹配算法,并能显著提高匹配算法的匹配速度.相关测试结果见4.2节中的表4.3.3模式串分组归约SOG是一种过滤型匹配算法,它将模式串集合P={p(1),p(2),…,p(r)}规约为一个通配形式的模式串,然后利用该通配模式串进行粗过滤,排除掉不可能匹配的文本位置.对于剩下的可能出现匹配的文本位置,逐个进行校验,以报告真正的匹配结果.随着模式串集合规模的增大,SOG算法的过滤效果越来越差,需要进行校验的次数越来越多,大幅度降低了算法的匹配速度.为了解决这个问题,本文采用模式串分组归约的方法来改进SOG算法的过滤效果.2,因此查询N个URL的平均代价为Ni(Ni+1)Ni(Ni+1)N∑M1i=1知,“信息查询性能测度”越小,查询URL的平均时间代价越小,哈希表对URL的散列越均匀.本文测试了窗口选择方法对降低哈希函数冲突、改善哈希函数均匀性的效果.我们在骨干路由器上采集了100GB的URL数据,对数据进行去重,然后从中随机选取了2万条、5万条和10万条URL作为模式串,评估窗口选择对哈希表的“信息查询性能测度”的影响.在实验中,分别统计了不进行窗口选择、基于最大二部图匹配的最优窗口选择(算法1)、近似最优窗口选择(算法2)这3种情况下哈希表的“信息查询性能测度”,得到的测试结果如表1所示.从实验结果可以看出,不进行窗口选择时的测度值最大,近似最优窗口选择的测度值次之,基于最大二部图匹配的最优窗口选择的测度值最小.因此,进行窗口选择大大改善了哈希表的均匀性和查询性能.此外,近似最优窗口选择方法的效果与基于最大二部图匹配的最优窗口选择方法的效果很接近.鉴于求解最大二部图匹配非常耗时,在实际应用中采用近似最优窗口选择方法就能取得非常好的效果.1.0000001.0000001.000000模式串分组归约的基本思想是:将模式串集合P平均分为G组P=P1∪P2∪…∪PG,每一组模式串Pj单独规约为一个通配形式的模式串^pj(1jG),然后将这G个通配模式^pj拼接到一个机器字中,使用SOG算法进行并行搜索.设机器字位宽为w,因为每个通配模式^pj需要m-q+1比特位来表示,因此最多可以将模式串集合划分为G=wm-q+1组.算法3是应用模式串分组规约技术的SOG算法.算法分为预处理和搜索两个阶段.在预处理阶段(算法3的第1~12行),位图表B[c1c2…cq]记录每个q元字符串c1c2…cq∈Σq在模式串中的出现位置.模式串p(k)被分在第g=kmodG组,因此p(k)的所有q元字符串的信息都被记录在Page6位图表B[·]的第g(m-q+1)比特位和g(m-q+1)+m-q比特位之间.对于模式串p(k)的第i个q元字符串p(k)i+q-1]的第g(m-q+1)+i-1个比特位设置为p(k)0,表示q元字符串p(k)个模式串的位置i出现过.在SOG算法中,用比特0表示某个字符串出现、比特1表示不出现,这样表示的目的是为了减少搜索阶段位操作的次数,是位并行算法中的一种常用优化技巧.在搜索阶段(算法3的第13~19行),用位向量犇记录当前的匹配状态,通过与位向量表B[·]和掩码Mask、Clear进行位操作,来检测是否发生匹配.由于G个模式串分组的信息都记录在宽度为w的位图之中,可以在一个机器字内完成,因此,对模式串进行分组规约并不会增加搜索过程的时间复杂度.算法SOGPartition中的Mask←(10m-q)G表示二进制字符串10m-q重复G次,Clear←(1m-q0)G的含义与此相同.算法3.基于模式串分组规约的SOG算法.输入:模式串集合P={p(1),p(2),…,p(r)}、待匹配文本输出:模式串在待匹配文本中的出现位置SOGPartition(P={p(1),p(2),…,p(r)},T=t1t2…tn)Preprocessing:1.m←minp∈P|p|,G←w2.FOReachgramc1c2…cq∈ΣqDO3.B[c1c2…cq]←1w/每个q元字符串对应于一个4.ENDFOR5.FORk←1torDO6.g←kmodG7.FOReachq-gramp(k)8.settheg(m-q+1)+i-1bitofB[p(k)9.ENDFOR10.ENDFOR11.Mask←(10m-q)G/Mask掩码用来检测当前状12.Clear←(1m-q0)G/Clear掩码用来防止位移操Searching:13.D←1w14.FORi←1ton-q+1DO15.D←((D<<1)Clear)|B[titi+1…ti+q-1]16.ifDMask≠MaskDo17.checkcurrenttextpositionagainstpatternsinP18.ENDIF19.ENDFOR为了评价模式串分组规约的效果,定义“校验概率”为SOG算法中进入校验过程的概率.校验概率越大,算法匹配速度越慢.定理3证明,算法3的校验概率小于原始SOG算法的校验概率,因而算法3的匹配速度更快.定理3.在字符独立且等概率分布的前提下,SOG算法的校验概率为p(r)=r的校验概率为p(r,G)=1-(1-p(r/G))G.当G>1且q<m时,p(r,G)<p(r).其中r=|P|是模式串的个数,σ=|Σ|是字符集的大小.证明.SOG算法中,当且仅当文本中的m-q+1个q元字符串都出现在模式串中,才需要进行校验.1个q元字符串出现在模式串中对应位置的概率为rσq,m-q+1个q元字符串出现在模式串中对应位置的概率为r入校验过程的概率.采用模式串分组规约后,模式串集合被平均分为G组,每一组模式串的个数为r/G,因此,每一组的校验概率为p(r/G).只要任何一组需要校验,算法3就需要进入校验过程.G组中有任何一组需要校验的概率为1-(1-p(r/G))G,此即为算法3的校验概率.因为p(r,G)=1-(1-p(r/G))G≈G·p(r/G)=1Gm-qp(r,G)<p(r).定理4是对算法3的时间复杂度和空间复杂度分析.定理4.算法3预处理阶段的时间复杂度为O(r(m-q+1)),搜索阶段的时间复杂度为O(n(1+p(r,G)logr)),空间复杂度为O(w|Σ|q).证明.在预处理阶段,算法需要对每个模式串中的每一个q元字符串设置相应的比特位.模式串的个数为r,每个模式串包含m-q+1个q元字符串,因此,预处理阶段的时间复杂度为O(r(m-q+1)).在搜索阶段,对位向量犇的更新仅需要常数时间(算法3的15行).如果可能发生匹配,那么需要Page7将模式串集合P与当前文本位置进行比对,检查是否真的匹配.进入校验阶段(算法3的17行)的概率为p(r,G),如果采用二分搜索进行校验,那么一次校验的时间复杂度为O(logr).综上,搜索阶段的时间复杂度为O(n(1+p(r,G)logr)).在空间复杂度方面,位图表B[·]消耗主要的存储空间.位图表B[·]中总共有|Σ|q种可能出现的q元字符串,每个q元字符串对应于一个宽度为w的位图,因此空间复杂度为O(w|Σ|q).证毕.表2是算法3与原始SOG算法的比较.可以看出,算法3在校验概率和搜索阶段时间复杂度方面优于原始SOG算法,两者在预处理阶段时间复杂度表2基于模式串分组规约的SOG算法与原始SOG算法的校验概率、时间复杂度和空间复杂度比较预处理时间原始SOG算法p(r)=r模式串分组规约p(r,G)=1-(1-p(r/G))GO(r(m-q+1))O(n(1+p(r,G)logr))O(w|Σ|q)表3不同机器字位宽下、模式串分组数不同时进入位宽w3(不分组)8(unsignedchar)16(unsignedshort)32(unsignedint)64(unsignedlonglong)217904542236.48128(SSEregister)425941792027.424实验评估本文从匹配速度和存储空间两个方面,将SOGOPT算法与原始的SOG算法[11]以及多种串匹配算法AC[1]、SBOM[2]、KR[3]、WM[4]、DTM[13]进行了对比测试.此外,本文还测试了窗口选择和分组规约技术对算法匹配速度的影响.4.1实验数据和环境我们从骨干路由器上采集了约100GB的URL数据,对采集数据去重后,得到约2000万条(2.06GB)URL,将这些URL作为待扫描文本.我们选取两类URL数据作为模式串集合:一类是某在线应用系统的URL规则,包括约17.5万条URL;另一类是从上述2000万条URL数据中随机抽取的URL作为模式串,规模分别为25万、50万、100万、500万和1000万,URL长度范围[6,512].相同,而原始SOG算法的空间复杂度较低.本文对模式串分组归约方法的效果进行了测试.我们从骨干路由器上采集了约100GB的URL数据,去重后得到2.06GB、约2000万条URL,将这些URL作为文本进行扫描.用某在线应用系统的17.5万URL规则作为模式串.最短模式串长度m=6,q-gram参数q=4.在不同机器字位宽w下,对模式串集合进行分组规约后,算法进入校验阶段的次数对比如表3所示.测试结果表明,随着机器字位宽w的增大,分组数增多,校验次数显著降低.当位宽w达到128时,校验次数已降低到不分组时的27.42%.实验的软硬件环境如下.CPU为IntelXeonE5520,2.27GHz,2路4核;内存为8GB;Cache为32KBL1数据Cache,32KBL1指令Cache,256KBL2Cache,8MB共享L3Cache;操作系统为Windows7Ultimate,64位;编译平台为VisualStudio2010.算法均用C++实现并单线程执行.4.2实验结果和分析(1)匹配速度比较SOGOPT算法与SOG、AC、WM、SBOM、KR、DTM等算法的匹配速度对比如图1~图4所示.表4是更完整详细的测试结果.从图1~图4中可以看出,SOGOPT是最快的算法,且优势非常明显.无论是17.5万的在线系统URL规则集,还是更大规模的URL规则集,SOGOPT算法都表现优异.随着URL规则集的增大,SOGOPT算法相对于其它算法的优势越来越明显.当模式串规模增大到100万时,SOGOPT算法的匹配速度是其它算法的3~4倍.值得注意的是,在17.5万URL规则集上,尽管AC算法的匹配速度较快,与SOGOPT算法的差距较小,但AC算法消耗的内存超过5GB.当URL规模增大到25万时,AC算法由于无法申请到足够内存而停止运行了.我们还测试了SOGOPT算法在500万和1000万URL规则集上的性能(表4).SOGOPT算法的匹配速度在10MB/s~20MB/s,而其它算法的匹配速度均低于1MB/s.Page8图1串匹配算法匹配速度对比(17.5万条URL图2串匹配算法匹配速度对比(25万条URL模式串,图3串匹配算法匹配速度对比(50万条URL模式串,图4串匹配算法匹配速度对比(100万条URL模式串,(2)内存用量比较SOGOPT算法与SOG、AC、WM、SBOM、KR、DTM等算法的内存用量对比如表4所示.在内存用量方面,经典的AC算法消耗的内存最大,SOGOPT算法次之.1000万URL规则时,SOGOPT算法的内存使用量为1946MB,其中包括模式串本身占用的1266MB存储空间.算法实际使用的内存为680MB,控制在合理的范围之内,可以满足实际工程应用的要求.随着URL规模的增大,SOGOPT算法的内存使用量会比较平稳地上升.(3)窗口选择和分组规约对算法匹配速度的影响我们测试了窗口选择和分组规约技术对算法匹配速度的影响,如图5~图8所示.其中,SOG-W表示在SOG算法基础上运用窗口选择技术,SOG-W-P(即SOGOPT)表示在SOG算法基础上运用窗口选择和分组规约技术.WM-W和KR-W分别是WM算法和KR算法采用窗口选择技术后的优化算法.从实验结果可以看出,SOG-W、WM-W和KR-W的匹配速度均快于相应的原始算法,验证了窗口选择方法的有效性.SOG-W-P算法快于SOG和SOG-W算法,验证了分组规约方法的有效性.总体来看,窗口选择方法对匹配速度的提升效果更加明显.图5窗口选择和分组规约对算法匹配速度的影响图6窗口选择和分组规约对算法匹配速度的影响Page9图7窗口选择和分组规约对算法匹配速度的影响(50万条URL模式串,最短模式串长度为6.WM算法因匹配速度太慢(<1MB/s)而没有实验结果)表4SOGOPT与多种串匹配算法在URL模式串上的匹配速度、内存用量、预处理时间比较(当URL规模达到25万时,AC算法由于消耗过多的内存(超过8GB)而无法运行出结果.表中其它标示“—”的测试项是因为算法匹配速度太慢(<1MB/s)而没有实验结果)17.5万URL模式串(某在线应用系统的规则)25万URL模式串50万URL模式串100万URL模式串500万URL模式串1000万URL模式串5总结多模式串匹配是计算机科学中的一个经典问题.对大量有害的URL进行过滤,是目前网络安全应用系统中所亟需的关键技术.本文设计了一种适合于大规模URL过滤的多模式串匹配算法———图8窗口选择和分组规约对算法匹配速度的影响(100万条URL模式串,最短模式串长度为6.WM和KR算法因匹配速度太慢(<1MB/s)而没有实验结果)SOGOPT.该算法在经典的SOG算法基础上,针对URL规则的特点,提出了最优窗口选择和模式串分组规约这两种优化技术,大幅度提高了算法的匹配速度,在大规模URL规则集上效果尤其显著,非常适合于大规模URL实时在线匹配的应用环境.经典串匹配算法设计,主要基于“模式串和文本字符服从均匀分布”[17]的假设,并且主要在随机数Page10据集上进行评测,然而URL等真实模式串并不满足上述条件.为了更好地反映模式串和文本的概率特征对匹配速度的影响,本文的下一步工作将考虑研究基于概率分布的串匹配算法.
