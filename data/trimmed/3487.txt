Page1基于轨迹点局部异常度的异常点检测算法刘良旭1)乐嘉锦2)乔少杰3)宋加涛1)1)(宁波工程学院电子与信息工程学院浙江宁波315016)2)(东华大学计算机科学与技术学院上海200051)3)(西南交通大学信息科学与技术学院成都610031)摘要随着大量的定位数据被收集在应用服务器,如何从大量定位轨迹数据挖掘异常信息已逐渐成为一个令人关注的研究课题.针对当前流行的、以轨迹片段表示局部特征的异常点检测算法存在的问题,文中提出了以轨迹点表示局部特征的异常点检测算法TraLOD.该算法不仅提出了将每个轨迹点赋予一个0~1的值来表示其局部异常程度,而且还引入了相对距离来计算轨迹片段之间的不匹配性.此外,针对数据挖掘算法效率低的缺点,TraLOD引入了R-Tree和距离特征矩阵来提高算法效率.性能分析和实验都证明了TraLOD的有效性.关键词轨迹数据;异常点检测;局部异常度;距离特征矩阵;R树索引1引言随着GPS定位、传感器网络和无线通信等应用Page2属性组成,对象之间的距离一般通常以各个属性差值的加权和表示[1-5];而在轨迹数据中,独立对象是由若干个相互联系的点组成的轨迹,因此,现有的轨迹数据异常点检测都是针对异常轨迹的检测.Knorr等人[1]将轨迹转变成一个由位置、方向和速度等3个独立属性组成的对象.然后运用传统距离函数计算轨迹间距离以检测异常轨迹.该方法的优点是可以利用传统的异常点检测算法,但它的缺点在于:仅比较了轨迹的整体特性,而忽略了其局部特征.而随着轨迹越来越长,这种方法的缺点也日益明显.为了解决这个问题,Li等人[6]提出了基于motifs的异常检测算法,它使用k-means算法从滑动窗口中收集k-代表模式(motif),然后使用分类器思想来检测异常轨迹.其缺点在于:实际应用领域很难找到标准的训练数据集.Lee等人[7]提出了TRAOD算法.该算法先将轨迹划分成线段,以线段表示轨迹局部特征(本文称之为基本比较单元),然后使用线段Hausdorf距离计算每两个线段之间的距离以表示其间的不匹配性,从而确定异常轨迹.此外,为了提高算法效率,TRAOD中还给出了一种二阶段划分方法来提高算法效率,即先将轨迹划分成粗粒度的轨迹片段,同时用轨迹片段的起始点和终点的连线表示其局部特征,寻找异常的粗粒度轨迹片段;然后再将异常的粗粒度轨迹片段进行线段划分,寻找其中的异常线段.TRAOD很好地解决了长轨迹之间不匹配性的计算,但它存在以下几个问题:首先,随着轨迹变得越来越长,线段并不能有效地表示轨迹的局部特征.例如,应用1中的两条轨迹Tr1和Tr2尽管拥有不同的运动特征,但构成其的线段集合却极其相似;其次,TRAOD使用线段的CPU时间Hausdorff距离表示两个线段之间的不匹配性,这可能使得算法存在如应用2那样描述的问题;第三,二阶段划分方法的局限性在于要求粗粒度轨迹片段内每个线段的方向要和该片段的开始点和终止点连接而成的线段方向基本保持一致.显然,对于复杂轨迹来说,这个条件往往很难得到满足.应用1.给定两条轨迹Tr1={l1,l2,l3,l4,l5,l6,l7,l8}和Tr2={l2,l4,l1,l5,l7,l6,l3,l8},其中构成Tr2的li表示其拥有与Tr1的li(0<i<9)相同的长度和方向(即除了位置稍微有点不同之外,li拥有与li相同的特征)(如图1所示).从图中可以看到,尽管两条轨迹拥有完全不同的运动特征,但如果用线段集合来表示轨迹,却发现线段集合拥有几乎相同的运动特征,这显然不是我们所期望的结果.因此,对于更长更复杂的轨迹来说,用线段表示其局部特征可能会产生与现实完全不同的实验结果.应用2.如图1所示,某个邻域内3条轨迹Tr1,Tr2和Tr3.从图中可以发现,Tr1和Tr3拥有较相似的运动特征.而Tr2处在离Tr1更近的位置.如果采用TRAOD中的线段Hausdorff距离那样的绝对距离,就会得到Tr2、Tr1具有更高的相似度.这显然与实际意义不符.针对这些问题,本文提出了一种通过确定每个轨迹点的局部异常程度来确定轨迹中异常的新算法———基于局部异常度的轨迹异常点检测算法(TrajectoryOutlierDetectionBasedonLocalOut-lierDegree,TraLOD).TraLOD主要创新点在于:(1)提出了局部异常度的概念,即赋予每个轨迹点一个0~1的值以表示该点相对于其邻域内轨迹点的异常程度;(2)引入相对距离的概念.参照基于平移的Hausdorff距离的思想,定义了基于相对距离的轨迹之间的距离函数,并在此基础上定义了轨迹点的局部异常度;(3)提出了基于R-Tree和距离特征函数的算法优化方法以提高算法效率.2距离函数和局部异常度的定义随着定位技术和用户需求的日益提高,数据挖掘算法所面对的轨迹数据集也在不断地发生变化.一方面,每条轨迹的时间和空间区间不断变大.例如,飓风经过海洋、陆地、岛屿等区域时会出现不同的运动规律;另一方面,用户和系统对轨迹的精度要求也在不断提高.这些都会导致轨迹变得越来越复Page3杂.针对这种现象,本文引入了局部异常度的概念.这里的局部包含两层含义:一是每个轨迹点仅和同一条轨迹上的若干个轨迹点有关联,即轨迹间的比较单位是若干个相邻的轨迹点组成;二是每个轨迹点的异常程度的计算仅涉及到其邻域内的轨迹点构成的基本比较单元,即基本比较单元仅和其邻域范围内的基本比较单元相比较,而不是整个数据空间.而Lee采用线段表示轨迹的局部特征,然后根据MLHD来计算轨迹线段之间的距离,但是对于复杂轨迹,线段很难有效表示轨迹的局部特征.本文采用的基本比较单元是长度为k的轨迹片段.这使得两个基本比较单元就变成了两个点数为k的点集.单从数据构成上看,两个基本比较单元之间的距离计算类似于图像识别中的距离计算,但是轨迹数据具有一些不同于图像数据的特征.首先,轨迹检测算法需要检测大量的基本比较单元之间的距离,Hausdorff距离的计算复杂度太高;其次,Hausdorff距离是无序的,这符合图像匹配的特征,然而轨迹点是有序的.最后,按照轨迹特征,基本比较单元仅与其邻域内的基本比较单元相比较,而不是整个数据空间.接下来,我们按照基于平移的最小Hausdorff距离的思想,并结合轨迹数据的特点来分析轨迹点在其所在基本比较单元中的局部异常度.假设轨迹数据集S={Si|1in},|Si|=mi,其中Si表示任一轨迹,n表示数据集包含的轨迹数目,mi表示轨迹Si包含的轨迹点数目.Sip={sip,…,si(p+k-1),p+k-1mi},Sjq={sjq,…,sj(q+k-1),i≠j,p+k-1mj}分别表示轨迹Si和Sj任一基本比较单元.首先,由于轨迹点是有序的,且基本比较单元长度相同,因此,我们可以将dist(si(p+t),sj(q+t))(1tk)作为轨迹点si(p+t)与基本比较单元Sjq的距离,这不仅可保证每个轨迹点有序这个特征,而且其平移变量t可以用其所有轨迹点si(p+t)到其对应点sj(q+t)的平均差值t-=1/k∑k-1示.因此,轨迹点si(p+t)在基本比较单元Sip与Sjq的异常度LOk(Si(p+t)|Sip,Sjq)定义如下:LOk(si(p+t)|Sip,Sjq)=(dist(si(p+t)-sj(q+t))-1k∑k-1其中,dist()表示一种距离函数,如L1,L2…(本文采用L2).显然这个距离是基于平移的最小Hausdorff距离的简化,它可以消除相似轨迹之间的公共偏差,但它仍然无法检测出方向相反的异常轨迹.为了解决这个问题,下面引入了邻域点集的概念.定义1.给定一个邻域阈值ω,一个轨迹点sip,对于任一其它轨迹上的点sjq,如果(sip-sjq)ω,那么sjq包含在sip的ω-邻域点集,表示为sjq∈Nω(sip).定义2.对于两个基本比较单元Sip和Sjq,如果Sjq所有轨迹点都满足sj(q+t)∈Nω(si(p+t))(1tk-1),那么称Sip和Sjq是相近基本比较单元,(Sip,Sjq)被称为相近的基本比较单元对.按照前面的分析,基本比较单元只和其邻域范围内的其它基本比较单元做比较,因此,轨迹点si(p+t)在相近的基本比较单元对sip与sjq的局部异常值定义如下.定义3.给定不同轨迹的两个基本比较单元Sip和Sjq,Sip的轨迹点sir在这个相近基本比较单元对(Sip,Sjq)的局部异常值LODk,ω(Si(p+t)|Sip,Sjq)定义如下.LODk,ω(sir|Sip,Sjq)=dist(sir-sj(q+r-p))-1k∑k-1烄烅当Sip和Sjq相近0,当Sip和Sjq烆其中,dist()表示向量的距离值,如L1,L2,…(本文采用L2).定义3给出了轨迹点在其所属的基本比较单元与其相近的基本比较单元的局部异常程度,如果这两个基本比较单元不是相近的,那么该轨迹点的局部异常值在这两个基本比较单元是没有意义的(定义3中用0代替其值,然后再结合定义4、定义5实现这个思想).定义4.假设轨迹点sir表示轨迹Si中的第r个轨迹点,Sip={sip,…,si(p+k-1)|max(0,r-k+1)pr}表示包含轨迹点sir的任一基本比较单元,Sjq={sjq,…,sj(q+k-1)|j≠i,sj(q+t)∈Nω(si(p+t),0tk-1}表示与Sip相近的某一基本比较单元,Nu表示与Sip相近的基本比较单元Sjq的个数.那么轨迹点sir在基本比较单元Sip的局部异常值为LODk,ω(sir|Sip)=min(LODk,ω(sir|Sip,Sjq)),当Nu≠0烅烄0,烆定义5.设sir表示轨迹Si的第r个轨迹点,Page4Sip={sip,…,si(p+k-1)|max(0,r-k+1)pr}表示任一包含轨迹点sir的基本比较单元,Np表示与Sip具有相近的基本比较单元的轨迹数目.那么轨迹点sir局部异常值为LODk,ω,λ(sir)=烄p=max(1,r-k+1)LODk,ω(sir|Sip)/(Np×max(1,r-k+1)),烅(Np×ω+∑r烆∑r其中,相近阈值λ表示与轨迹点所在的基本比较单元的轨迹数目.按照定义4,当该点所在的基本比较单元都找不到一个相近的基本比价单元时,该轨迹点的局部异常值为ω,即它具有最高的局部异常度.由于相近的两个基本比较单元的任何一对轨迹点之间的距离都小于邻域阈值ω.那么轨迹点在这个相近基本比较单元对的局部异常值总是满足LODk,ω(Si(p+t)|Sip,Sjq)ω,因此,我们可以推出LODk,ω(Sir)的取值范围为[0,ω].当LODk,ω(Sir)=ω则表示该轨迹点所在基本比较单元无相近的基本比较单元或是该点在包含该点的所有相近的基本比较单元对的局部异常值都为ω;当LODk,ω(Sir)=0则表示该点在包含其的所有相近基本比较单元对的局部异常值都为0,即对于每个相近的基本比较单元对,平移之后的该点与其对应点相重合.将等式(2)进行归一化处理,就可以得到归一化的局部异常度:LODk(sir|Sip,Sjq)=(1/ω)(dist(sir-sj(r+q-p))-(1/k)∑k-1烄烅0,烆轨迹点在其所在基本比较单元的局部异常度:LODk(sir|Sip)=1/Numin(LODk,ω(sir|Sip,Sjq)),当Nu≠0烅烄0,烆轨迹点的局部异常度为LODk,λ(sir)=(烄p=max(1,r-k+1)LODk,ω(sir|Sip(Np×max(1,r-k+1)),烅(Np+∑r烆3Naive算法假设轨迹数据集S={Si|1in},|Si|=mi表示每条轨迹的长度,Sip为Si的任一基本比较单元,Sjq为Sj的任一基本比较单元.Naive算法就是将每条轨迹的每个基本比较单元与其它轨迹的每个基本比较单元作比较,计算其每个轨迹点在这两个基本比较单元的局部异常度,最后求其平均值就是该轨迹点的局部异常度.图2给出Naive算法的伪代码.实现思想就是对每条目标轨迹Si,逐一计算Si的每个基本比较单元的局部异常度(即与其它轨迹的基本比较单元逐一比较,数组outlier用来存放目标轨迹每个点的累计局部异常度值和该点对基本比较单元对的局部异常度个数)(第2~8行);接着,根据outlier和定义计算轨迹点的局部异长度(第9~14行).NaiveCompLOD(S,k,ω)1.foreachtrajectorySido2.Initializearrayoutlier[mi]3.foreachtrajectorySj(i≠j)do4.foreach(Sip,Sjq)5.ifSipisclosedtoSjqthen6.foreachpointsi(p+t)inSipdo7.outlier[p+t].val+=LODk(sir)|Sip,Sjq);8.outlier[p+t].num++;9.foreachpointsitinSido10.ifoutlier[t].num!=0then11.LODk(sit)=outlier[t].val/outlier[t].num;12.else13.LODk(sit)=1;14.OutputLODToFile(sit,LODk(sit))下面以距离计算为主要代价分析其计算复杂度.对于一条轨迹Si,其所包含的长度为k的基本比较单元数目为mi-k+1,那么对于两个轨迹Si和Sj,需要比较的基本比较单元次数为(mi-k+1)·(mj-k+1),而比较两个基本比较单元的计算复杂度为u(1uk),因此,对于两个轨迹Si和Sj,用Naive算法检测其是否全局匹配的计算复杂度cost(Si,Sj)为Page5cost(Si,Sj)=(mi-k+1)×(mj-k+1)×u(8)轨迹挖掘的数据量通常比较大,我们不考虑缓存先前计算得到的距离.因此,Naive算法的总计算复杂度为cost(S)=∑n假设每条轨迹长度相同,即mi=m,那么等式(9)转化为cost(Si,Sj)=n(n-1)(m-k+1)2×u(10)4基于R-Tree的异常轨迹检测算法对于数据量及其庞大的轨迹数据集来说,Naive算法的计算代价是昂贵的.在传统数据挖掘领域,引入索引是常用的算法优化方法.但是,空间索引算法R-Tree并不适合用来索引时空数据.尽管很多研究者提出了一些有效的索引结构(如TPR-Tree[9],LUR-Tree[10]),但当前还不存在一种公认有效的时空数据索引结构.因此,直接对时空数据建立索引并不可行.TRAOD[6]引入的二阶段划分尽管加速异常轨迹的检测,但这种方法的局限性在于它必须保证粗粒度的轨迹片段的方向与其内部的细粒度轨迹片段的方向保持一致,否则算法的准确性将明显下降.但这个局限性使得二阶段划分并不适合在复杂轨迹数据集使用.此外,由于TraLOD中轨迹片段是相互重合的,二阶段划分方法会导致某些轨迹片段丢失.由于在TraLOD中,每个轨迹点的局部异常度仅取决于同一条轨迹的相邻轨迹点以及其对应的邻域点集内的轨迹点相比较,即仅与目标轨迹点的邻域内的轨迹相关.而且,我们并不考虑轨迹点的绝对时间,即该轨迹数据集可以看成空间数据集.因此,除了将轨迹数据集按照轨迹顺序存放之外,TraLOD框架还引入R-Tree来索引所有轨迹点以实现快速地找出所有可能相近的基本比较单元对.TraLOD主要实现过程分为两个阶段:首先,算法利用R-Tree和两条轨迹的距离特征矩阵找出相近的基本比较单元对,然后确定其中每个轨迹点在这个基本比较单元对的局部异常度.4.1数据存储结构TraLOD采用的数据结构主要由三个部分构成:存储轨迹点的数据文件、根据轨迹号索引所有轨迹点的B+-Tree和按空间位置索引所有轨迹点的R-Tree.即所有轨迹数据按照轨迹编号和点的顺序存放在一个二进制文件中.系统在轨迹编号和点序号上建立B+-Tree索引,并为了实现对R-Tree的支持,对轨迹点的经纬度坐标建立R-Tree索引.相对于Naive算法,这种数据结构多了一个R-tree索引(作为空间数据索引技术的典型算法,R-Tree通常都被会存储轨迹数据的数据库支持).此外,由于R-tree是一个以矩形框为单元的索引算法,而轨迹点的ω-邻域区域是一个圆形区域,因此,进行R-tree查询时,必须经过一定的距离计算来确定轨迹点的领域点集.4.2距离特征矩阵为了方便描述,在描述TraLOD实现过程之前,先引入距离特征矩阵的概念.假设给定两条轨迹A={a1,…,an}和B={b1,…,bn},那么A、B间的距离特征函数可以用一个由元素(ai,bj)组成的矩阵来表示.对于给定阈值ω,将矩阵中dist(ai,bj)>ω的元素置成0,那么,对于大多数复杂轨迹来说,它们之间的距离特征矩阵通常都是稀疏矩阵.下面给出正对角序号和正对角相邻的概念.定义6.矩阵中元素(ai,bj)的正对角序号是其行号和列号之差,表示为pssn(ai,bj)=i-j.定义7.假设矩阵的两个元素(ai,bj)和(ax,by)的正对角序号相同,如果满足|i-x|=1,那么称(ai,bj)和(ax,by)是正对角相邻.按照上面的定义,两个相近的基本比较单元其实就是这两条轨迹构成的距离特征矩阵中k个正对角相邻的非0元素.4.3算法实现按照上一节的分析,搜索相近的基本比较单元就转变为搜索目标轨迹与其它轨迹的距离特征矩阵中所有k个正对角相邻的非0元素.因此,TraLOD的实现思想如下(伪代码如图3所示):首先,针对每条目标轨迹,借助于R-tree找出该轨迹中所有轨迹点的邻域点集{(sip,sjq)|dist(sip,sjq)ω},将其放入一个按(比较轨迹Sj编号,正对角序号,点在轨迹中位置)排序的堆栈stackNeigh(当该堆栈中元素过多时,部分元素会保存在磁盘文件)(第1行,由函数QueryRTree实现).接着,由于距离特征矩阵中正对角相邻的元素在堆栈中的存放位置肯定是相邻的,所以,要逐一从堆栈中取出栈顶元素,判断其和之前取出的元素是否处在同一个距离特征矩阵、是否是正对角相邻,并作相应的处理,计算轨迹点在相近的基本比较单元对的局部异常度(第3~15行);Page6最后,按照前面计算的轨迹点在相近基本比较单元对的局部异常度计算每个轨迹点的局部异常度(第16~21行).ComputingLOD(k,ω)1.ForeachSi,do2.Initializeoutlier;3.ComputingLODofOne(Si,k,ω);ComputingLODofOne(Si,k,ω)1.stackNeigh=QueryRTree(Si,ω);2.cur_traj=-1,cur_pos=-1,cur_pssn=-MAXVAL;3.while(stackNeighisn’tNULL)do4.curEn=stackNeigh.RevTop();5.If(curEn.traj!=cur_traj)or(curEn.pssn!=6.if(CloseUnitSet.Size()k)then7.CompLODofSeg(CloseUnitSet,outlier,k,ω);8.if(curEn.traj!=cur_traj)then9.cur_traj=curEn.TrajID;10.cur_pssn=curEn.pssn;11.elseif(curEn.pssn!=cur_pssn)then12.cur_pssn=curEn.pssn;13.CloseUnitSet.Size()=0;14.CloseUnitSet.addEntry(curEn);15.curPos=curEn.pos;16.foreachpointsirinoutlierdo17.if(outlier[r].num!=0)18.LOD(sir)=outlier[r].val/outlier[r].num;19.else20.LOD(sir)=1;21.OutputLODToFile(sit,LODk(sit));CompLODofSeg(CloseUnitSet,outlier,k,ω)1.closeUnitArray=GetCloseUnit(CloseUnitSet,k);2.foreachentryCloseUnitinCloseUnitArraydo3.CompLODofUnit(CloseUnit,outlier,k,ω);算法中,函数CompLODofSeg用来计算其中目标轨迹点在相近基本比较单元对的局部异常值,其包含4个输入参数:相邻元素数组CloseUnitSet用来存放正对角相邻的基本比较单元对;两个参数k,ω;局部异常度数组outlier.该函数从CloseUnitSet取出相近基本比较单元对(个数为CloseUnitSet数组个数-k+1,每个相近基本比较单元对对应k个正对角相邻的数组元素);然后对每个相近的基本比较单元对,按照等式(5)计算每个轨迹点在该基本比较单元对的局部异常度,并保存其的最小局部异常度值(由函数CompLODofUnit实现).4.4性能分析本节将以轨迹点之间的距离计算作为主要代价来分析算法性能.由于在搜索过程仅有R-Tree搜索需要距离计算,因此我们仅考虑R-Tree搜索和计算阶段的计算代价.各个参数说明如表1所示.假设轨迹数据集S={Si|1in},|Si|=mi表示每条轨迹的长度,轨迹数据空间的整个区域为L×L,且轨迹点在整个数据空间均匀分布,则轨迹Si每个点的单位区域内且不属于Si的轨迹点数目为变量名Sω-ERSω-IRNtpiNi单位面积中包含的轨迹点数目(不包含轨迹Si)Ntotal_point总的轨迹点数目Ntotal_bcu总的基本比较单元对数目首先,ω-邻域是圆形区域,而R-Tree是矩形区域搜索,因此,对于每个轨迹点,算法必须检查其ω-圆形邻域的内接矩形和外接矩形之间的点是否处在ω-邻域之内,则搜索Si的每一轨迹点的计算复杂度为Ntpi=(Sω-ER-Sω-IR)/L2×Ni=2ω2/L2∑j≠i,j=1…n搜索R-Tree的计算复杂度为costq=Ntotal_point×Ntpi=∑n其次,在计算阶段,由于每个非Si的轨迹点处在Si的某个轨迹点的ω-邻域之内的概率为πω2/L2,Si的某个基本比较单元Sip存在一条相近的基本比较单元的概率为(πω2/L2)k.而总的基本比较单元对的数目为Ntotal_bcu=∑ncostc=Ntotal_bcu×k×(πω2/L2)k计算阶段的总代价为根据等式(13)和等式(15),该算法总的计算代价为cost=costq+costc=∑n假设每条轨迹的长度相同,即mi=m,又由于ωL,且k2,则等式(16)可以简化为cost=n(n-1)(m2)2ω2Page7n(n-1)(m-k+1)2k(槡πω/L)2k=n(n-1)m2ω2≈2n(n-1)m2ω2/L2由于复杂轨迹长度mk,根据等式(10)和等式(17)得到TraLOD和Naive算法的性能之比由于ωL,u≈L,所以TraLOD性能要大大优于Naive算法,下面实验也证实了该结果.5实验结果基于本文提出的轨迹检测算法,笔者开发出异常轨迹检测系统TrajDetector.该系统的开发环境是VisualC++6.0,操作系统为WindowsXP.实验硬件环境为:CPU为Centrino22.6GHz,内存为512GB.R-Tree采用的是Beckmann[11]提出的R-tree①.实验数据集来自真实的飓风数据②,该数据包括飓风的经纬度位置信息、最大中心风力、中心压力等,本文抽取其中的经度、纬度的数据项作为实验数据.本文采用的实验数据有两个:(1)东太平洋飓风数据集.该数据集记载了1949年到2006年的东太平洋上飓风移动数据,包括35986个点组成的813条轨迹;(2)西太平洋飓风数据集.该数据集记载了1949年到2008年的西太平洋上飓风留下的移动轨迹,包括17691个点组成的565条轨迹.5.1参数影响TraLOD涉及到3个参数:邻域阈值ω、基本比较单元的长度k和相近阈值λ.下面我们来讨论这图4不同ω(k或λ)值的CPU时间3个参数对算法性能和轨迹点的局部异常度LOD的影响.实验数据集采用东太平洋飓风数据集.5.1.1参数对算法性能的影响邻域阈值ω、基本比较单元的长度k和相近阈值λ对算法性能的影响是不同的.对算法性能影响最大的参数是邻域阈值ω.图4显示了随着ω,k或λ的变化(ω从1~10,k从6~15,λ从6~15),算法所花费的CPU时间(默认参数值ω=5,k=10,λ=10).从图中可以看到,影响最大的是参数ω,因为它的变化会直接影响轨迹点的邻域点集中的点数.当ω等于1时,算法的执行时间极少(仅有5s),这是因为此时每个轨迹点的邻域点集包含的点都很少,其所在基本比较单元的相近基本比较单元更少,从而导致算法的执行时间大大降低,但随着ω的增大,算法的执行时间快速增大,当ω等于10时,算法的执行时间已经接近1000s.因为它要检索所有可能的基本比较单元.参数k对算法性能的影响就比较少.图4(a)显示了改变参数k值(ω=5,k=6~15,λ=10)时,算法执行时间的变化情况.显然,随着k的增加,算法的执行时间稍微有点减少,这是因为k的增大会导致每个轨迹点所在基本比较单元所对应的相近基本比较单元会减少,从而导致算法的计算阶段中的计算时间减少.该值变化不大的原因是:如算法性能分析中所述的,算法的主要计算时间主要集中在R-Tree的查找阶段.图4(b)同样也显示了随着参数k变化(从6~15,ω=5,k=10,λ=6~15)算法执行时间的情况.从图中可以发现,参数λ对算法性能几乎没有影响,这是因为λ的变化只是在最后计算LOD值时使用,它对算法中的R-Tree搜索和计算阶段都没有任何影响.①②Page85.1.2参数对局部异常度的影响轨迹点的局部异常度(LOD)值会随着邻域阈值ω、基本比较单元的长度k和相近阈值λ3个参数的变化而变化.为了比较不同参数对LOD值的影响,我们从数据集中随机取100个轨迹点进行分析.图5显示了不同ω值时(ω=3,5,7,10,k=10,λ=10),100个随机轨迹点的LOD值的变化情况.从图中可以看到,随着ω值的增大,轨迹点的LOD值逐渐减小,而且其趋势是越来越慢.其原因是:随着ω值的增大,越来越多的轨迹点被包含在该点的邻域点集中,这使得相近的基本比较单元对逐渐增加,当拥有相近基本比较单元的轨迹数目少于λ时(由于不足的局部异常度是由1代替),局部异常度迅速减少,当其值大于等于λ时,局部异常度的变化开始变小.从图中也可以看到大多数轨迹点在ω=7和ω=10的变化很小.图6显示了不同k值时(ω=5,k=5,7,10,15,λ=10),100个随机轨迹点的LOD值的变化情况.尽管k的变化对算法性能影响不大,但对LOD的值影响还是挺大的.从图中可以看到,随着k值的增大,轨迹点的LOD值逐渐增大,而且其趋势是越来越快.其原因是:由于ω保持不变,那么每个轨迹点的邻域点集内的轨迹点数目保持不变,随着k值的增大,要求基本比较单元的长度增加,这导致对应的相近基本比较单元减少,从而使得LOD值慢慢增大.当具有相近的基本比较单元的轨迹数少于λ时,由于与ω变化时同样的原因,LOD值开始快速增大.图中显示:当k=15时,轨迹点的LOD值都开始快速向1靠近.图7显示了不同λ值时(ω=5,k=10,λ=5,7,10,或15),100个随机轨迹点的LOD值的变化情况.从图中可以看到,λ值的变化对大多数轨迹点的LOD值没有影响,只有在极个别轨迹点,其LOD值会随着λ值的增大而逐渐增大.这是因为λ是用来限制拥有相近基本比较单元的最少轨迹数,即具有与轨迹点所在基本比较单元相近的基本比较单元的轨迹数目.当该数目大于多于λ,按照等式(7),其LOD值不会变化,否则,其LOD值会随着λ值的增大而增大.综上所述,最主要参数是ω,它不仅明显地影响算法的执行时间,还会明显地改变轨迹点LOD值,参数ω的选择尤为重要.其次,参数k对算法执行性能的影响并不明显,但其对轨迹点的LOD值的影响相当明显.而参数λ对算法的影响,不管是在性能还是在LOD值,几乎可以忽略(仅当LOD值接近边缘值时,产生影响).因此,对于用户来说,可以根据下面的方式来确定3个参数:首先根据应用邻域的特点确定ω值,然后再设定基本比较单元的长度参数k;最后根据用户对稀疏区域轨迹点的局部异常度的要求来设定参数λ.5.2与TRAOD的对比和分析由于TraLOD的距离定义与TROAD有较大不同,两种计算方法的计算量差别也很大.因此,在算法性能上两者之间不具有直接的可比性.因此,本文在实验最后部分仅对TraLOD与TRAOD在算法效果上进行简单对比和分析.图8(a)显示了TraLOD使用LOD=0.7检测出来的轨迹异常情况,粗线表示轨迹的异常片段.图8(b)显示了文献[6]在网上提供的实验结果(http://netfiles.uiuc.Page9edu/jaegil/www/icde08).浅色线段表示正常的轨迹,粗线表示异常的轨迹片段.从两个图中可以发现,TraLOD不仅可以像TRAOD算法一样挖掘出那些明显偏离大多数轨迹运动规律的异常,而且还可以挖掘出那些虽然不明显偏离但具有明显异常的(如图8中2#异常片段)、运动规律与其局部区域相似但也与别的区域相似(如图8中1#轨迹片段)图8TraLOD与TRAOD的实验结果对比6结束语随着物联网、3G技术的迅猛发展,对轨迹数据进行数据挖掘日益成为人们感兴趣的研究课题.而异常点检测作为数据挖掘的一个重要研究方向,轨迹数据挖掘领域同样具有很重要的理论和实际意义.为了克服当前流行的、以轨迹片段表示轨迹局部特征所存在的不足,本文提出了以轨迹点表示轨迹局部特征的异常轨迹点检测算法.该算法不仅引入局部异常度来表示轨迹点的异常情况,而且在距离函数中引入了相对距离的思想,使得距离度量更加符合实际意义.另一方面,在算法效率角度,TraLOD采用R-Tree索引和局部特征矩阵(由两条轨迹的每对点之间距离组成)来提高算法效率.实验和性能分析都证实了TraLOD不仅具有很高的计算效率,而且按照LOD值检测出来的异常轨迹片段具有很高的理论和实际意义.
