Page1面向服务的可信软件体系结构代数模型赵会群孙晶(北方工业大学计算机系北京100144)摘要针对面向服务体系结构(ServiceOrientedArchitecture,SOA)在形式化和可信属性建模方面的不足,用代数学方法对服务、服务组合以及服务体系结构的属性和行为特征进行抽象,把服务组合解释成组件“运算”实现,并结合进程代数中算子概念,定义了多种服务组合运算,从而建立SOA的代数模型.在代数模型基础上,进一步对SOA可信属性建模,提出多种SOA可信范式,为可信SOA软件设计提供理论支持.最后介绍了一个应用案例.关键词服务;服务组合;服务体系结构;抽象代数;进程代数1引言可信软件是指正确、安全和可靠的软件[1].目前软件的可靠性和安全性不能令人满意.软件设计缺陷、软件系统被恶意攻击都给计算机系统的正常运Page2用框架,该模式需要具有灵活、安全和无逢地处理异构、异质的内、外资源的能力①.IBM、Microsoft、Gartner等IT领军企业,先后提出了自己的SOA解决方案②③④,OASIS(OrganizationfortheAd-vancementofStructuredInformationStandards,OASIS)提出了SOA参考模型1.0[2],OSOA(OpenServiceOrientedArchitecture)给出了SOA编程模型SCA(ServiceComponentArchitecture,SCA)等⑤.SOA研究已经成为热点问题.最能够体现软件服务质量的指标之一就是可信.而有关可信SOA的基础理论和相关技术研究还有较大的研究空间,表现在以下几个方面:(1)可信SOA建模目前仍处在经验阶段.OASIS的参考模型给出与服务相关的概念以及服务过程中与用户的交互描述[2].主要的贡献是明确了SOA中的基本概念以及概念间的相互关系.OSOA给出的SCA模型,对软件体系结构中组件和连接器概念进行了扩展,提出组件不仅是一个计算逻辑,也包括计算逻辑的开发与支撑环境;连接器不仅是对组件连接的参数传递,同时也包括通过网络交互的协议等.SCA的贡献是给出了SOA软件的实现范例.文献①②③也提出了自己的SOA参考模型,对SOA建模理论研究有所贡献.但上述研究并没有深入讨论可信问题,没有对服务、交互和行为属性进一步分类,没有给出形式化描述,没有建立严格的理论体系,这对可信SOA研究的指导意义不明显.文献[5]用进程代数对Web服务的合成与替换建模,并提出替换一致性检测算法;文献[6]采用进程代数对Web服务建模,并导出性能模型.上述研究虽然都采用进程代数作为建模工具,但都没有结合SOA特性对进程代数进行扩展.另外,上述研究是针对Web服务的建模,而Web服务仅是SOA的一种表现形式,所以可信SOA的建模型问题还没有很好地解决.(2)可信软件体系结构建模研究有待深入.SOA作为软件体系结构(SoftwareArchitecture,SA)的特例,其可信属性建模应属于SA建模范畴.文献[7]综述了10年来SA的研究进展,从软件生命周期各个阶段诠释了SA的作用.不仅如此,还指出:“随着网构软件的复杂程度增加,进一步加大了对网构软件结构的理解、分析和开发的难度;如何界定SA在网构软件整个生命周期中的角色,将是一个值得关注和研究的课题;其中主要研究点包括:对网构SA描述与分析的方法、基于体系结构的网构软件的质量属性保障机制等”.目前,对SA建模方法的研究还是集中在软件体系结构描述语言(ArchitectureDescriptionLan-guage,ADL)方面.较著名的ADL有ACME、C2、Darwin、Rapide和Wright等[8].UML(UnionModelLanguage,UML)是广泛使用的软件系统建模语言,虽然对SA的描述能力不足,经过改进后可以作为一种ADL[9].Taylor提出了一种可信SA描述语言xADL,通过明确主题、资源、特权、安保和策略等相关概念,描述访问控制等安全事务[10].ADLs采用形式化的方法描述SA,但并未对组件、连接器和SA的属性和行为给出一致的定义和描述.文献[8]提出一个具有普遍意义的SA框架,但未对框架中的组件、连接器以及SA的属性和动态行为给出抽象化的描述,未对不同的连接方式进行分类,未讨论各类SA间的相互关系.从系统分析角度,SA建模方法还应该提供对质量属性的描述能力,而上述ADLs不具备这些功能.Taylor提出的xADL虽然对可信软件建模有指导意义,但并没有涉及SOA的概念,也存在着形式化描述不够、对组件连接方式分类不明确等问题.为此,用数学理论建立完备的可信SOA模型,并在此基础上研究可信SOA的描述、检测和评价等问题,还有较大的研究空间.本文从软件体系结构建模入手,用进程代数对可信SOA的建模方法进行研究,通过对传统的进程代数扩展,提出多种服务组合运算,建立SOA的代数模型,并在此基础上研究SOA的可信设计问题,为可信SOA设计提供理论支持.2SOA代数模型下面用进程代数解释服务组件、服务组合以及服务体系结构等概念,最后给出SOA代数模型.①tionIssue-Service-OrientedArchitecture.http://www.zd-②ice-OrientedArchitecture,CBDIForum.http://www.mi-③④⑤Page32.1服务组件把服务解释成:“一个具有服务能力的、可按照一定的策略和特性(如可信性)组合的组件集合,这些组件可以是一个正在执行的程序代码段、也可以是程序运行的系统环境.”下面分别给出服务组件、服务组合和服务体系结构的形式化描述以及服务同态、同构概念.定义1.服务组件(简称组件)可以是一段程序代码,可以是实现程序代码的语言,可以是语言的运行环境等计算单元,也可以是数据、数据的处理结果的数据单元.它由组件接口和组件实现模块组成.组件接口是组件与外部接触点的集合,即〈Port1,Port2,…,Portn〉,而每一个接触点Porti是一个八元组〈ID,Publi,Extni,Privi,Behai,Msgsi,Consi,Non-Funci〉.其中:ID是组件的标识;Publi是第i个接触点提供给环境或其它组件标示构成;达式构成;的功能(活动)集合,活动执行记为x;下同.件的功能(活动)集合;Extni是第i个接触点运行所需环境或其它组Privi是第i个接触点私有功能(活动)集合;Behai是第i个接触点行为语义描述,由谓词表Msgsi是第i个接触点所有消息的集合,由事件Consi是对第i个接触点行为约束,它通常包括组件运行的初始条件、前置条件和后置条件,有时为了明确表示这3个条件可把它写成Cons(init,pre-cond,post-cond),init、pre-cond和post-cond分别表示初始条件、前置条件和后置条件的集合;Non-Funci是组件第i个接触点非功能说明,包括组件的服务策略、合同、安全性、可靠性说明等.下面给出组件相等和组件进化概念.定义2.设A、B是论域Dom(U)中的两个组件,U为组件集合,下同.如果A、B满足下列条件烄烅烆则称A、B相等,记作A=B.‘’为逻辑等价,‘’为永真蕴涵,下同.定义3.设A和B是论域Dom(U)中的两个服务组件,如果A和B满足下列条件,则称B是A的一个进化,记为Evolve(B,A).(1)Dom(A)=Dom(B)烄(2)Publ(B)Publ(A)(3)Extn(B)Extn(A)(4)Priv(B)Priv(A)(5)Beha(B)Beha(A)烅(6)Msgs(B)=Msgs(A)(7)(Cons(B)=Cons(A))or(Cons(B)Cons(A))(8)(Non-Func(B)=Non-Func(A))or(Non-Func(B)Non-Func(A烆2.2服务组合下面结合服务软件特点,对进程代数中的算子进行扩展,把服务组合解释成服务组件连接运算的实现.件,若x∈Extn(A)∧y∈Publ(B)使得定义4.设A、B是论域Dom(U)中的两个组[pre-cons(A)∧pre-cons(B)∧(xy)]∧[Msgs(x)→Msgs(y)],即组件A通过发送一个消息“激发”组件B中的Publ(B)来实现功能需求,就称组件A,B进行了一次“激发”运算,记作AB.特别地把AB记为xy.AB仍然是一个组件,它满足下列性质:(1)Dom(AB)=Dom(A)∪Dom(B)烄(2)Publ(AB)=Publ(A)∪Publ(B)(3)Extn(AB)=Extn(A)∪Extn(B)(4)Priv(AB)=Priv(A)∪Priv(B)(5)Beha(AB)Beha(A)∧Beha(B)烅(6)Msgs(AB)=(Msgs(A)∪Msgs(B))(7)Cons(AB)Cons(A)∧Cons(B)(8)Non-Func(AB)Non-Func(A)∧Non-Func(B烆定义5.设A、B是论域Dom(U)中的两个组件,若x∈Extn(A)∧y∈Publ(B)使得[pre-cond(A)∧pre-cond(B)∧(xy)]∧[y∈Priv(A)],即组件A通过“使用”组件B中的Publ(B)来实现功能需求,就称组件A,B进行了一次“使用”运算,记作AB.特别地把AB记为xy.AB仍然是一个组件,它满足下列性质:Page4(1)Dom(AB)=Dom(A)∪Dom(B)烄(2)Publ(AB)Publ(A)∪Publ(B)(3)Extn(AB)Extn(A)∪Extn(B)(4)Priv(AB)=Priv(A)∪Priv(B)(5)Beha(AB)Beha(A)∧Beha(B)烅(6)Msgs(AB)=(Msgs(A)∪Msgs(B))(7)Cons(AB)Cons(A)∧Cons(B)(8)Non-Func(AB)Non-Func(A)∧Non-Func(B)烆“使用”和“激发”运算是最基本的服务组合运算.在不需要区分二者的环境下,可以把二者统称为“调用”运算,记为AB.可以证明“调用”运算满足结合率[13].定义6.设A、B是论域U中的两个组件,若x∈Extn(A),对y∈Publ(B),若[(xy)∧((pre-cond(A)∧pre-cond(B))]∧[Msgs(y)∈Msgs(A)],则称A与B进行一次带有“反馈”的调用运算.显然,反馈运算依赖“使用”或“激发”运算,所以反馈本身一定与这两种运算一起构成表达式.如A激发B后把结果反馈给A.把反馈运算记为AB↑,特别地把AB↑记为xy↑.定义7.设A、B是论域U中的两个组件,若x∈Publ(A),y∈Extn(B)使得[(pre-cond(B))∧(y)((pre-cond(A))∧(x)],反之x∈Extn(A),y∈Publ(B)使得[(pre-cond(A))∧(x)((pre-cond(B))∧(y)].则称组件B与组件A协同运算,记作AΘB.H=pre-cond(A)∩pre-cond(B)称为协同条件集.特别地把AΘB记为xΘy.显然,“协同”运算满足交换率.这里xy并没有限定协同运算的交互方式,所以协同运算依赖于“使用”或“激发”运算.定义8.设A、B是论域U中的两个组件,若x∈Publ(A),y∈Extn(B)可以有[(pre-cond(B))∧(y)((pre-cond(A))∧(x)]成立,反之x∈Extn(A),y∈Publ(B)可以有[(pre-cond(A))∧(x)((pre-cond(B))∧(y)]成立,但服务过程中pre-cond(A)∩pre-cond(B)=,则称组件A与组件B并行,记作A‖B.特别地把A‖B记为x‖y.显然,并行运算是协同运算的特例,并都满足交换率.定义9.设A、B是论域U中的两个组件,x1∈Publ(A),y1∈Extn(A),x2∈Publ(B),y2∈Extn(B),若[(post-cond(A)∧pre-cond(B))∧(y1x2)][(post-cond(B)∧pre-cond(A))∧(y2x1)],则称A与B重复,记为A·B.特别地,当A=B时,称A重复执行,记为x1·A,简记:·A.“反馈”与“重复”的区别在于,“反馈”只是结果的返回,而“重复”需要重复执行原组件方法x.显然,“反馈”与“重复”都依赖“使用”或“激发”两种运算.可以证明“重复”满足交换率.定义10.设A、B是论域U中的两个组件,若x∈Publ(A),y∈Publ(B)使得[pre-cond(A)∧(x)]∨[pre-cond(B)∧(y)],则称组件A与组件B选择执行,记为A+B.特别地把A+B记为x+y.定义6~10中的运算也有与式(3)类似的性质.这里略.可以证明“选择”运算满足交换率.“反馈”、“重复”、“激发”与“使用”、“协同”与“并行”运算对“选择”运算满足分配率.下面仅就“重复”对“选择”的分配律加以证明,其它证明略.定理1.“重复”运算对“选择”运算满足分配律,即证明.要证明式(1)成立,只要证明等式的左边和等式右边满足定义2中的8个条件即可.为此,我们有代表性的证明第2个和第5个条件成立,其它证明同理.首先,对·和+运算,都有Publ(AOPiB)=Publ(A)∪Publ(B)性质,所以对x∈Publ((A+B)·C),有x∈Publ(A)∨x∈Publ(B)∨x∈Publ(C),可得x∈Publ(A·C+B·C).同理,对y∈Publ(A·C+B·C)有y∈Publ((A+B)·C).因此,有Publ((A+B)·C)=Publ(A·C+B·C),定义2的性质(2)成立.首先,对·运算,有Beha(A·B)Beha(A)∧Beha(B)性质;而对+运算,有Beha(A+B)Beha(A)∨Beha(B)性质.由Beha((A+B)·C)(Beha(A+B))∧Beha(C)(Beha(A)∨Beha(B))∧Beha(C)(Beha(A)∧(Beha(C))∨(Beha(B)∧(Beha(C))Beha(A·C+B·C),则Beha((A+B)·C)Beha(A·C+B·C)).定义2的性质(5)成立.以上借鉴进程代数中算子概念,对组合进行分类,下面进一步讨论服务组合相关的概念.定义11.服务组合是组件运算的实现.它是Page5集合.一个六元组〈ID,Role,Beha,Msgs,Cons,Non-Func〉.其中:ID是组合的标识.Role为服务组合与组件的交互点的集合,每个Role=〈Id,Action,Event,LConstrains〉组成.其中:Id是Role的标识;Action是Role活动的集合,每个活动由事件的连接(谓词)组成;Event是Role产生的事件集合;LConstrains是Role的约束集合.我们把Role从组合的其它属性分开来描述的目的是突出组合的多态性,即一个组合可同时与多个组件组合.Msgs是组合中各Role中事件产生的消息的Beha是组合行为的语义描述.Cons是组合约束的集合,它包括组合的初始条件、前置条件和后置条件,有时为了明确表示这3个条件可把它写成Cons(init,pre-cond,post-cond),init,、pre-cond和post-cond分别表示初始条件、前置条件和后置条件的集合.Non-Func是组合的非功能说明,包括按何种策略、合同、安全性和可靠性组合等.2.3服务体系结构代数模型下面给出服务体系结构的定义.定义12.设论域为U,(1)组件是一个服务体系结构;(2)组合是一个服务体系结构;(3)由组件经有限次组合(组件运算)后是服务体系结构.服务体系结构,记为S=〈C,O〉,简称服务.其中C表示组成服务的组件集合,O表示组件运算的集合.与服务组合后仍是一个服务.由定义12可得服务体系结构的性质如下:(1)封闭性.即组件与组件、组件与服务、服务(2)层次性.即服务可由组件组合而成,而服务(3)可扩充性.即一个满足条件的新组件可以从组合是组件运算实现角度,可以进一步证明又可以再经过组合组成新的更大的服务.通过组合加入到服务中.SOA对任意一个运算构成代数系统.每一个组合运算都构成代数系统.定理2.设S=〈C,O〉是服务,则S对O中的证明.由服务组合运算的封闭性可得定理2的正确性.为此,把S=〈C,O〉称为SOA的代数模型,也称SOA的代数表达式.在SOA代数模型定义基础上,可以进一步利用代数学方法挖掘SOA的代数性质,为SOA基础理论研究奠定基础.定义13.设S1=〈C1,O1〉,S2=〈C2,O2〉是两个不同服务,若x∈C1总有y∈C2,使得y与x对应,则称S1与S2之间存在着一个映射,记为f:S1→S2,或y=f(x).若映射是满射,则称服务间映射为满射;若映射是一对一的,则称服务间为一一映射.定义14.设S1=〈C1,O1〉,S2=〈C2,O2〉是两个服务,f是S1到S2的一个映射,若对x∈C1和y∈C1有f(xOPiy)=f(x)OPjf(y),其中OPi∈O1、OPj∈O2.则称f为从S1到S2的同态,也称S1与S2同态;若f是单射,则称f是从S1到S2的单一同态;若f是一一映射,则称f是从S1到S2的同构,也称S1与S2同构.用同态与同构概念可以进一步描述基于SOA软件的进化性、服务之间的关系等概念,这里仅给出后者.定义15.给定两个服务S1=〈C1,O1〉、S2=〈C2,O2〉,构造一个新的服务S1×S2=〈C1×C2,OPk〉.其中C1×C2是组件集合的笛卡尔乘积,而OPk定义成对x1,x2∈C1和y1,y2∈C2有〈x1,y1〉OPk〈x2,y2〉=〈x1OPix2,y1OPjy2〉,OPi∈O1,OPj∈O2.称S1×S2是S1到S2的积结构,而S1和S2是S1×S2的因子,这里的OPi、OPj和OPk运算是任意组件连接运算.在定义15的基础上可以定义服务间的关系.定义16.对x1,x2∈C1和y1,y2∈C2,在定义15中,所有满足〈x1OPix2〉的(x1,x2)的任意一个子集合称为运算OPi的一个关系;所有满足〈y1OPjy2〉的(y1,y2)的任意一个子集合称为运算OPj的一个关系.3SOA可信属性建模可信是评价软件服务质量重要的指标之一.基于SOA代数模型,讨论如何通过建立SOA的可信范式对SOA可信属性建模.3.1可信性模型定义17.设S=〈C,O〉是一个服务,若Y∈C;X∈C都有XOpiY,则称Y为服务S的候选核(CandidateCore),若候选核多于一个时,可选定其Page6中一个作为主核(PrimaryCore).其中,Opi为组合运算.定义18.设S=〈C,O〉是一个服务,若任意一个组件在执行时,都至少与另一个组件发生组合,则称A满足第一范式,记为1NF.循环结构来编码[11].引理1.任何一个程序可以只用顺序、分支和定理5.任意一个S=〈C,O〉的代数表达式都显然,1NF是SOA软件设计的最基本的要求.定义19.设S=〈C,O〉是一个服务,若A中结合组合运算定义可以证明,“使用”运算组合存在核,则称A满足第二范式.记为2NF.是可信性最低的一种组合.定理3.设S=〈C,O〉是一个服务,若对X,Y∈C有XOpiY,Opi是“使用”组合,则XOpiY的可信性依赖组件Y的可信性,进一步有X的可信性依赖Y.证明.根据“使用”组合运算定义,有x∈Extn(X)∧y∈Publ(Y)使得(xy)∧(pre-cond(X)∧pre-cond(Y))∧(Beha(X)Beha(Y))成立;若y失效,即Beha(Y)为假,则Beha(X)Beha(Y)为假,Beha(X)为假,XOpiY组合失效.因此,XOpiY和X的可信性依赖组件Y的可信性.这里的y失效是指被恶意攻击或软件故障.证毕.定义20.设S=〈C,O〉是一个服务,若A满足第一范式或第二范式,并且A中的组合运算均为“激发”组合,则称A满足可信基础范式,记为RNF.第一范式是典型的分布式软件结构,而第二范式是典型的集中式结构.这两种范式的可信性有所不同,可以证明在非“使用”组合下,第一范式比第二范式的可信性要高.定理4.设S=〈C,O〉是一个服务,若S中有核Y,则S的可信性依赖Y的可信性.证明.设S=〈C,O〉是一个服务.根据核的定义,Y∈C,X∈C都有XOpiY.若y失效,则XOpiY失败.因此,XOpiY的可信性依赖组件Y的可信性.定义21.设S=〈C,O〉是一个服务,若S满足第一范式和RNF范式,则称S满足可信一型范式,记为R1NF;若S满足第二范式和RNF范式,则称S满足可信二型范式,记为R2NF.下面讨论基于“协同”和“并行”运算的可信范式模型.可以写成下面的标准型.S=a1C1↑+a2C2↑+…+akCm↑(2)或简写成其中ai∈Cj;Cj∈C,i=1,2,…,K,j=1,2,…,M,i,j可能不等,是“使用”或“激发”运算.证明.用归纳法证明.假设k=0时成立,此时S只有一个组件构成,S=a1C1↑表示该组件的启动、运行与反馈的状态转换.现假设K=n-1时成立,去证明K=n时成立.即S=a1C1↑+a2C2↑+…+an-1Cn-1↑(ai∈Cj;Cj∈C,即i,j=1,2,…,K,i、j可能不等)成立,去证明S=a1C1↑+a2C2↑+…+an-1Cn-1+anCn↑.(1)“选择”运算时显然成立.S=a1C1↑+a2C2↑+…+an-1Cn-1↑+anCn↑(2)证明“重复”运算成立.设an∈C,有S=(a1C1↑+a2C2↑+…+an-1Cn-1↑)·anCn↑;由↑满足对+和·的分配律得,S=((a1C1+a2C2+…+an-1Cn-1)·anCn)↑;又由于由·满足对+的分配率,则S=(a1C1·anCn+a2C2·anCn+…+an-1Cn-1·anCn)↑;设xi∈Publ(Ci),则S=(a1x1·anCn+a2x2·anCn+…+an-1xn-1·anCn+C)↑;构造bi=aixi·an,bnCn=C(一个空调用),则S=b1C1↑+b2C2↑+…+bn-1Cn-1↑+bnCn↑,即定理在“重复”运算下成立.(3)证明“顺序”运算成立.设an∈C,Cn∈C,为或运算,有S=(a1C1↑+a2C2↑+…+an-1Cn-1↑)anCn↑;由↑满足对的分配律得,S=((a1C1+a2C2+…+an-1Cn-1)anCn)↑;由对+运算满足分配率,有S=(a1C1anCn+a2C2anCn+…+an-1Cn-1anCn)↑;设xi∈Publ(Ci),则S=(a1x1anCn+a2x2anCn+…+an-1xn-1anCn+C)↑;构造bi=aixian、bnCn=C(一个空调用),则S=b1C1↑+b2C2↑+…+bn-1Cn-1↑+bnCn↑,即定理在“顺序”运算下成立.根据引理1得定理5成立.推论1.在只考虑服务组件内部行为过程时,任意一个S=〈C,O〉的代数表达式都可以写成下面的标准型.或简写成Page7其中,ai∈Ci(i=1,2,…,K).证明.与定理5的证明过程相似,略.在只考虑服务组件内部活动时,有ai∈Ci,i=1,2,…,K,“”运算条件均满足“·”运算条件,所以aiCi↑可以通过ai·Ci↑实现,即aiCi↑=ai·Ci↑;又由于只在组件内部活动,所以ai·Ci↑=ai·Ci.因此,推论1成立.标准型(4)的物理意义为:ai是行为明确的活动,如安全性确认等可信活动等,所以可以把ai看成是常量;而Ci为服务功能组件,可以看成是变量.从可信角度,如果ai是为了实现可信性保证的活动,则标准型(4)可以看成是一种可信范式.把标准型(4)称为第三可信范式,记为3NF.定义22.设S=〈C,O〉,S=a1·C1+a2·C2+…+ak·Ck.其中ai∈Ci;Ci∈C.如果ai是明确的,为了实现可信性保证的活动,则称S=a1·C1+a2·C2+…+ak·Ck为第三可信范式,记为3NF;ai称为可信常量.下面讨论“协同”组合的可信范式.根据CCS中组合算子的扩展规则和隐藏内部活动规则[12]以及提出的协同运算定义有以下规则.并行组合运算扩展规则.设F=a1·f1+a2·f2+…+ak·fk;G=b1·g1+b2·g2+…+bk·gk是两个服务组件,那么FΘG=(a1f1ΘG)+…+(amfmΘG)+其中ai、bj为协同常量对,aiΘbj记为ε;ai·fi简写为aifi;Σ(aiΘbj)·fkΘgk表示多项选择.上述规则表明,两个协同的服务可以通过代数表达式描述.下面进一步给出协同表达式的化简规则.协同常量aiΘbj为明确的服务可信保障行为,所以在分析服务软件的可信性时可以忽略协同可信常量,把分析重点放在没有实现可信保障的行为中,为此有下面隐藏规则.隐藏内部协同常量规则εΘF=F;aΘεΘF=aΘF.在服务代数模型表达式中,有些项可能与所讨论的问题无关或对讨论的问题不产生干扰,所以可以把这些项消去,为此有限制规则.限制规则.在式(6)中,如果把常量ai(i=1,2,…,m)或bj(j=1,2,…,n)列入限制范围,那么式(6)的扩展式中aifiΘG和FΘbjgj可以消去.个递归表达式.那么,哪些项可以被列入限制范围呢?要根据问题域来确定.本文把内部协同的可信常量对列入限制范围.下面给出定理6.定理6.设ai(i=1,2,…,m)和bj(j=1,2,…,m)是可信协同常量对,则在式(6)中aifiΘG和FΘbjgj可以消去.证明.先对aifiΘG证明.设G=b1g1+b2g2+…+bkgk,由“Θ”运算定义,则一定存在一个常量bj是ai的可信协同常量伴侣,使得aifiΘG=aifiΘbjgj=(aiΘbj)·fiΘgj,该项已经在式(6)中的多项选择中出现,所以该项在式(6)中可以消去.同理可证FΘbjgj也可以消去.为了分析服务系统的可信性,下面给出两个相关概念———死锁与活锁.组件功能,则称系统出现“活琐”.定义23.如果一个服务无限循环执行某几个“活锁”表现为服务代数表达式中包括递归.定理7.“活锁”表现为服务代数表达式是一证明.定理显然成立.定义24.对一个服务软件系统,如果服务总能到达,那么称该服务系统有活动性;如果一个服务调用在执行某个组合运算后非法终止,则称该服务系统出现“死锁”,记为#.“终止”动作#是一种正常的组件行为,但#出现在需要继续执行的调用行为中时,就会引起“死锁”.根据定义24,显然有定理8成立.定理8.在有“终止”动作#的服务软件系统中,其服务表达式中某项的常量只有#.证明.反证法.假设服务表达式S=a1C1+a2C2+…+akCk,其中ai为#,记有S=a1C1+a2C2+…+#Ci+…+akCk.根据#的定义,一定不存在x∈Ci与#发生调用运算和反馈运算,所以#Ci=#,定理成立.例1.F=aG+bF;G=cG+dG.G无限自循环,系统出现活琐.X=aY+bX;Y=cY+dX+#.如果网络Y执行常量#,那么系统进入终止状态.定义25.如果一个服务代数表达式中没有出现“活锁”和“死锁”,则称该服务是可信服务,所形成的代数表达式称为协同可信范式.4应用研究提出的SOA代数模型和可信范式理论可以直Page8接应用到以下领域:(1)SOA的形式化描述;(2)SOA软件体系结构设计;(3)SOA可信属性分析等.由于篇幅有限,这里仅介绍在SOA可信属性分析图1可信协同组合S1行为描述:服务组件S1向服务组件S2发送可信协商报文(记为A1),并启动时钟(记为T);如果在指定时间内没有得到可信确认报文(记为B1),则重发可信协商报文(仍记为A1),此过程重复多次,直到得到可信确认报文.S1的SOA代数模型如下:其中S11是一个临时服务组件.S2行为描述:服务组件S2接收可信协商报文(该活动记为A2);如果该报文是正确的报文,则向服务组件S1发送可信确认报文(记为B2);如果报文有错,则丢弃协商报文(记为D).S2的SOA代数模型如下:在上述描述中,A1与A2、B1与B2为两对可信确认活动对,而D和T是为了完成可信确认的辅助活动,所以均可认为是明确的可信活动.基于第三可信范式的可信设计验证过程如下:S=S1ΘS2=(A1·S11)Θ(A2·(D·S2+B2·S2))=A1·(S11Θ(A2·(D·S2+B2·S2))+A2·(A1·S11Θ(D·S2+B2·S2))+ε·(S11Θ(D·S2+B2·S2))图2非可信协同进程中的应用.“?”表示需要对接收的报文进行可信验证.案例分析1.一个可信服务协同组合过程如图1所示.//ε=(A1·A2),(A1·A2)是内部协同可信活动,列入有限.根据限制规则,第一、二项可以削去.下同.=S11Θ(D·S2+B2·S2)//根据式(8),把S11代入上式.=(T·A1·S11+B1·S1)Θ(D·S2+B2·S2)=T·A1·S11Θ(D·S2+B2·S2)+B1·(S1Θ(D·S2+B2·S2))+D·((T·A1·S11+B1·S1)ΘS2)+B2·((T·A1·S11+B1·S1)ΘS2)+(B1ΘB2)·(S1ΘS2)入有限.//ε=(B1·B2),(B1·B2)是内部协同可信活动,列=[T·A1·(S11Θ(D·S2+B2·S2))]+[D·((T·A1·S11+B1·S1)ΘS2)]+[ε·(S1ΘS2)]根据S1和S2描述中对活动的定义,上述SOA表达式中的T·A1、D、ε均为可信活动,所以式(10)满足第三可信范式的定义,是可信设计.案例分析2.一个非可信服务协同组合过程如图2所示.Page9在案例1基础上,如果对S2错误地设计成如下行为过程:“不进行确认检测(在图2中用√表示),直接返回可信确认报文”,其它描述不变,则行为描述如下:下面给出基于第三可信范式的非可信设计验证过程:S=S1ΘS2=(A1·S11)Θ(A2·B2·(D·S2+S2))=A1·(S11Θ(A2·B2·(D·S2+S2))+A2·(A1·S11ΘB2·(D·S2+S2))+ε·(S11ΘB2·(D·S2+S2))//ε=(A1·A2),(A1·A2)是内部协同可信活动,列入有限=S11ΘB2·(D·S2+S2)//根据式(8),把S11代入.=(T·A1·S11+B1·S1)ΘB2·(D·S2+S2)=T·A1·S11Θ(B2·(D·S2+S2))+B1·(B2·(S1Θ(D·S2+S2))+D·((T·A1·S11+B1·S1)ΘS2)+((T·A1·S11+B1·S1)ΘS2)+(B1ΘB2)·(S1ΘS2)//ε=(B1·B2),(B1·B2)是内部协同可信活动对,列入有限.=[T·A1·(S11Θ(B2·(D·S2+S2))]+[D·((T·A1·S11+B1·S1)ΘS2)]+[(T·A1·S11+B1·S1)ΘS2]+[ε·(S1ΘS2)]=[T·A1·(S11Θ(B2·(D·S2+S2))]+[D·(S11ΘS2)]+[S11ΘS2]+[ε·(S1ΘS2)]//利用式(8)把T·A1·S11+B1·S1还原成S11.其中第3项[S11ΘS2]没有进行可信活动就进入协同过程,所以不满第三可信范式.因此,是一种不可信的SOA设计.5相关研究比较及结论以上用代数方法对面向服务的可信软件体系结构进行了讨论,给出服务组件、服务组合和服务体系结构的形式化定义,提出了SOA的代数模型.在该模型基础上,给出了可信范式概念,并提出多种可信SOA范式,为基于SOA的可信软件开发提供理论支持.上述研究中一个重要观点是把服务组合解释成服务运算的实现,由此可以用进程代数进一步讨论可信SOA的建模问题.上述研究与文献[5-6]的不同在于,本文对进程代数中的算子进行了扩展,并结合面向服务的软件特性对算子的物理意义加以解释.利用进程代数讨论软件体系结构中的行为描述问题,作者在文献[13]中曾经采用过,并取得较好的研究效果.本文的研究思路与文献[18]相似,但有较大改进,主要表现在:增加了“选择”、“协同”、“并行”、“重复”和“反馈”运算,并进一步明确了上述运算与“使用”和“激发”运算的关系.不仅如此,在代数模型基础上,还讨论了SOA的可信属性建模问题;而文献[13]仅讨论了“使用”和“激发”两种运算的情况,而且没有讨论SOA相关内容.可信SOA代数模型为进一步研究SOA的可信问题奠定了基础.然而,可信软件系统是一个复杂的系统,仅凭一个模型无法描述所有的特征,我们将继续研究其它形式的建模方法.另外,可信性测试也是可信性保证的重要研究内容之一.由于篇幅有限,本文仅介绍了可信SOA的建模方法,并没有给出该模型的应用,我们将在以后的研究中,进一步表现该模型的应用价值.
