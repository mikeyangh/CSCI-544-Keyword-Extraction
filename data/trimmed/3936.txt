Page1基于安全规则变异的WebServices安全性测试方法陈锦富1),3)李青1)毛澄映2),3)詹永照1)黄如兵4)陈加梅1)1)(江苏大学计算机科学与通信工程学院江苏镇江212013)2)(江西财经大学软件与通信工程学院南昌330013)3)(斯文本科技大学信息和通信技术学院墨尔本VIC3122澳大利亚)4)(华中科技大学计算机科学与技术学院武汉430074)摘要针对已有变异测试研究中仅考虑对SOAP(SimpleObjectAccessProtocol)消息输入参数的变异处理,而缺乏对SOAP消息安全规则变异的研究,文中从消息机密性、完整性及身份认证等方面对安全规则进行归类,提出了一种基于安全规则变异的WebServices安全性测试方法.首先给出一种安全规则变异测试框架,研究变异点判定规则库,设计出相应的变异操作算子、漏洞判定准则以及基于优先级与权重策略的变异算子选择方法.然后提出一种基于安全规则变异的测试用例生成算法,依照算法生成违背安全规则的SOAP消息,从而揭露WebServices的安全类故障.最后实现了一个WebServices安全性测试工具WSSTT(WebServicesSecurityTestingTool),在工具的基础上进行实验和对比分析,验证了文中提出的基于安全规则变异的WebServices安全测试方法的可行性和有效性.关键词WebServices;SOAP消息;安全规则变异;变异测试;变异算子;原型工具1引言随着计算机技术的飞速发展,WebServices作为实现SOA(Services-OrientedArchitecture)系统的重要方式之一,已经得到产业界和学术界的广泛关注和高度重视[1].在WebServices得到广泛应用和实践的同时,WebServices的安全问题显得越来越重要.由于WebServices包含了诸多企业关键业务,若其安全出现问题将造成重大损失与严重危害.WebServices测试是保证其质量的一种重要技术手段[2].由于WebServices一般位于服务提供者的远程站点,其内部结构和代码对请求者来讲是透明的.常用的WebServices功能性测试方法是基于WSDL(WebServicesDescriptionLanguage)规范和XML(ExtensibleMarkupLanguage)文档的测试方法,而较有效的安全性测试方法是对WebServices进行变异测试.相关研究方法通过分析WSDL描述文件对输入参数进行变异,该类方法在考虑数据通信上下文环境方面存在欠缺,对安全类故障暴露能力较弱.通常WebServices在传送或接受远程服务单元的数据时,该数据以SOAP(SimpleObjectAccessProtocol)协议格式进行封装.一个SOAP消息交互元素可以抽象表示为输入参数和安全控制规则两部分.在现有的变异测试研究中,主要考虑的是针对输入参数的变异处理,尚未见到有效的对SOAP消息安全规则变异的测试方法.本文针对安全规则这一特有的消息成份,从消息机密性、完整性及身份认证等方面进行归类,研究变异点判定规则库,设计相应的变异操作算子和漏洞判定准则,并提出一种基于安全规则变异的测试用例生成算法,最终生成违背安全规则的SOAP消息,进而揭露WebServices的安全类缺陷.2相关工作目前国内外针对WebServices功能测试的研究较多,主要集中在基于WSDL规范和XML文档的WebServices测试方面,也有学者研究了WebServices可靠性和鲁棒性测试方法.Martin等人[3]从扩展WSDL的定义来增强其描述能力的角度展开研究,开发了一个Web服务测试工具,该工具能够依据WSDL文档产生Java客户端测试代码,并将生成代码中的封装类转送到Java测试数据生成工具中,最终生成Web服务测试数据;Sneed等人提出通过扩展WSDL文档,增加WSDL的描述能力,然后结合WSDL树结点并用扩展的刻面约束和前置条件来生成相应的测试数据[4];Jiang等人[5]提出了一种基于合约变异技术的测试数据生成方法,该方法能产生int、float和double的3种变量变异测试数据;Bai等人[6]提出了基于WSDL自动生成测试用例的方法,将WSDL文件解析成结构化的DOM(DocumentObjectModel)树,从测试数据和测试操作两个角度来产生测试用例;Hanna等人[7]通过WSDL建立数据类型的抽象模型,根据WSDL的定义利用随机法和边界值法生成基本数据类型的测试数据,但该方法没有考虑复杂数据类型的结构,无法将简单数据有效地组合成复杂数据.在基于XML建模的Web服务测试研究领域,Offutt工作组在SOAP消息形式化描述的基础上扩展出基于RTG(RegularTreeGrammar)的一套模型[8],并针对XMLSchema提出一套RPC(RemoteProcedureCall)干扰算子用于Web服务测试;此后他们接着提出一套扩展的干扰算子,基本可分为insert、delete、change三大类[9].deAlmeida等人[10]基于相关研究又增添了一些SOAP变异算子,并且直接应用于SOAP消息生成测试用例.这种方法不依赖XML模式,并且能直接修改SOAP消息,减少运行时间.基于RTG模型,deMeloAna等人[11]提出了扩展数据值干扰(添加无效值)和数据通信干扰(关系策略)算子,在数据通信干扰中扩展了变异算子(增加了minoccus、allandchoice)并且扩大了其使用范围,同时适用于RPC和DocumentPage3两种通信类型.此外,针对WebServices测试中Oracle不能确定的场景,Sun等人[12-14]提出了基于自适应测试和蜕变测试技术的WebServices测试方法,并通过实例验证了其在Oracle未知的情况下具有一定的测试效果.Hanna等人[15]提出了一个用于WebServices服务质量的鲁棒性测试框架,该框架建立在测试用例生成规则的基础之上,对特定领域的WebServices具有一定的测试效果.Bozkurt等人[16]调研了以往关于WebServices测试方面的相关知识,分析了当前WebServices测试的优劣和劣势,并依据应用错误的级别将基于错误的WebServices测试分为XML(SOAP)消息扰动、网络层错误注入和WebServices规格说明变异3类.Laranjeiro等人[17]指出了在SOA环境下的WebServices鲁棒性验证存在的主要问题,并提出了一种基于相关鲁棒性测试的方法,能对SOA框架下的简单WebServices进行鲁棒性验证.现有的研究主要是针对WebServices整体架构提出的功能性测试方法,虽已有部分对安全属性测试的研究,但也仅是将传统的Web应用程序的脆弱性和攻击类型映射到WebServices中的相应方面,并未考虑到WebServices的特殊架构下的安全性,测试不够完整和规范.因此,本文基于SOAP消息的安全规则研究WebServices的安全性测试方法具有重要的理论价值.3安全规则变异测试框架针对安全规则这一特有的SOAP消息组成部图1安全规则变异测试框架当给定安全规则及定义一套变异算子,在给定一个消息请求集的情况下,基于原始的和变异后的安全规则评估每个请求,相应请求的评估将产生两分,从消息机密性、完整性及身份认证等方面进行SOAP安全属性归类,首先给出一种安全规则变异测试框架,然后基于该测试框架研究变异点判定规则库,并设计相关的安全规则变异操作算子及漏洞判定准则,最后给出一种基于优先级和权重策略的变异算子选择方法.3.1变异测试框架变异测试框架主要用来指导WebServices安全性测试过程,进一步提高测试活动的规范性,并减少测试活动的盲目性,增加测试效能.安全规则变异测试框架如图1所示.核心模块及流程如下:(1)Mutator(变异体生成器)在SOAP请求消息安全规则上分别应用变异算子,产生出大量的变异体.此处每个变异算子对原始的安全规则只做较小的语法或语义的改动,并且保证生成的变异体在语法上的正确性和一致性.(2)Analyzer(变异体检测分析器)这个变异体检测分析器能够对比和分析在原始SOAP请求响应消息安全规则和变异体SOAP消息安全规则上运行的同一个测试用例产生的测试结果,并依据漏洞判定准则进行安全性分析,判定是否存在漏洞以及为何种漏洞.如果测试结果不同,则变异体被杀死;否则,需要通过可视化的对比分析,人工判断和区分是否为等价变异体.充分性评估报告器)(3)TestAdequacyEvaluation&Report(测试全部测试用例执行之后,由测试充分性评估报告器负责收集测试结果进行分析,并得出测试充分性评估的结论,最终评价WebServices的安全性.种响应结果.如果这两种响应结果是不同的,我们就说这个安全规则变异体被杀死,否则没有被杀死.最后依据漏洞判定准则进行安全性分析,判定是否存Page4在漏洞以及为何种漏洞.3.2变异规则库及变异算子设计3.2.1变异点判定规则定义1.安全规则变异点是指该处由于某种原因可能存在不安全性因素、很容易引起非预期的安全问题的位置.定义2.ST-UnT(SecurityToken-Username-Token)变异点是指当WebServices使用用户名令牌认证机制时,则该令牌即为变异点.定义3.ST-KeT(SecurityToken-Kerberos-Token)变异点是指当WebServices使用Kerberos票据认证机制,则该票据即为变异点.定义4.ST-XT(SecurityToken-X.509Token)变异点是指当WebServices使用X.509证书认证机制时,则该证书即为变异点.定义5.TS(Timestamp)变异点是指当WebServices使用时间戳技术时,则该时间戳元素即为变异点.定义6.Ent(Encrypted)变异点是指当WebServices使用加密技术时,则该加密元素即为变表1安全规则变异点判定规则库编号判定规则1ST-UnT安全令牌变异点当WebServices使用用户名令牌认证机制时,则该令牌成为变异点2ST-KeT安全令牌变异点当WebServices使用Kerberos票据认证机制,则该票据成为变异点3ST-XT安全令牌变异点当WebServices使用X.509证书认证机制时,则该证书成为变异点4TS5Ent6Sin7U-Role用户类型变异点当WebServices使用用户角色技术时,则该角色成为变异点8U-Att用户属性变异点当WebServices使用用户属性技术时,则该属性成为变异点9PrP隐私策略变异点当WebServices使用隐私策略技术时,则该策略成为变异点10SHSecurity报头块变异点当WebServices中使用WS-Security安全规范时,则该Security报头块成为变异点时间戳变异点当WebServices使用时间戳技术时,则该时间戳成为变异点3.2.2变异算子设计定义12.安全规则变异算子τ是指针对变异点生成测试用例的规则.对任意变异点Ω,都可以选用适当的安全规则变异算子τi,生成测试用例集{e1,e2,e3,…,en}.定义13.安全规则变异算子可以进行复合运算,记为π.设τ1和τ2是两个安全规则变异算子,变异算子τ1和τ2的复合运算记作τ1πτ2,表示τ1处理后的结果再由τ2进行处理,由此生成新的测试用例.设计安全规则变异算子的关键在于根据变异点的特性来构造最有效的测试用例,使其能够尽可能多地引发WebServices的安全漏洞.安全规则变异算子生成的测试用例主要是非正常的数据,但也可能异点.定义7.Sin(Signature)变异点是指当WebServices使用签名技术时,则该签名元素即为变异点.定义8.U-Role(User-Role)变异点是指当WebServices使用用户角色技术时,则该角色即为变异点.定义9.U-Att(User-Attribute)变异点是指当WebServices使用用户属性技术时,则该属性即为变异点.定义10.PrP(PrivacyPolicy)变异点是指当WebServices使用隐私策略技术时,则该策略元素即为变异点.定义11.SH(SecurityHeader)变异点是指当WebServices中使用WS-Security安全规范时,则该Security报头块即为变异点.通过对WebServices运行特点和各类SOAP消息安全类型漏洞的分析,可以总结归纳出WebServices中可能存在的各种安全问题的编码模式,从而归纳出变异点判定规则,形成安全规则变异点判定规则库(表1).包含一些非正常的操作.经过对各种WebServices的安全漏洞特点的仔细分析以及深入研究攻击者利用漏洞入侵Web服务系统的各种手段,可以归纳出有效的安全规则变异算子,并利用算子的复合运算来表示一些复杂的测试用例生成规则.安全规则变异算子如表2所示.随着对WebServices技术的不断更新,可以设计新的算子加入到变异算子表中.运用表2中的安全规则变异算子,可以针对不同的变异点来构造错误注入测试用例集.通常对一个变异点要根据其特性综合运用不同的变异算子来生成测试用例集,以保障测试的充分性.表3还给出了对一个变异点进行测试时,对其结果进行分析以判定是否存在安全漏洞的准则.Page5表2安全规则变异算子编号1CUT(ChangeUsernameToken)改变用户名令牌修改用户名令牌使其无效2CKT(ChangeKerberosTicket)篡改Kerberos票据篡改Kerberos票据的某些值,产生错误的Kerberos票据等3CXT(ChangeX.509Expires)改变X.509证书的有效期改变有效期,使其过期等4MEE(ModifyEncryptedElement)5MEEH(ModifyEncrypted6CEA(ChangeEncryptedAlgorithm)修改加密的算法尝试使用不同的加密算法7MSE(ModifySignatureElement)修改签名元素增加签名元素的个数(例如过载签名)、减少签名元素的个89CSA(ChangeSignatureAlgorithm)修改签名的算法尝试使用不同的签名算法10CHS(ChangeHeaderSecurity)改变Security报头块的个数增加、减少Security的个数,以跳过安全性验证11CT(ChangeTimestamp)12CUR(ChangeUserRole)13CUA(ChangeUserAttribute)14CPP(ChangePrivacyPolicy)表3漏洞判定准则判定规则ST-UnTST-KeTST-XTTSEntMEE、MEEH、CEA如果接受了错误的加密元素,则存在漏洞.SinMSE、MSH、CSA如果接受了错误的签名元素,则存在漏洞.U-RoleU-AttPrPSHCHS、CHSπCT、CHSπMSE如果不能识别错误的Security块,未进行限制或对错误做出反馈而泄露重要信息,则存在漏洞.因篇幅有限,下面仅给出几种常用变异算子的变异方法和过程(仅列出SOAP消息的主要编码部分).如果用户访问内容超出了自己的访问权限,则存在漏洞.如果用户访问内容超出了自己的访问权限,则存在漏洞.如果用户访问内容超出了自己的访问权限,则存在漏洞.例1.CUT变异.用户名令牌用〈wsse:UsernameToken〉表示,作为验证用户名和可选密码信息的方式,WebServices某种情况下部分SOAP消息变异前及变异后结果如下.CUT变异前:01〈wsse:UsernameToken〉02〈wsse:Username〉Lq〈/wsse:Username〉03〈wsse:Password〉liq0045〈/wsse:Password〉04〈/wsse:UsernameToken〉CUT变异后:01〈wsse:UsernameToken〉02〈wsse:Username〉LQ〈/wsse:Username〉03〈wsse:Password〉liqing0045〈/wsse:Password〉04〈/wsse:UsernameToken〉个数、改变加密元素的上下文位置等数、改变签名元素的上下文位置等修改时间戳元素的有效期使其过期、结合soap:role属性跳过时间戳限制例2.MSE变异.WebServices某种情况下部分SOAP消息变异前及变异后结果如下.MSE变异前:01〈wsse:Security〉02…03〈ds:ReferenceURI="#CreditCard"〉04…05〈/ds:Reference〉06…07〈soap:Bodywsu:Id="CreditCard"〉08…09〈/soap:Body〉10…MSE变异后:01〈wsse:Security〉02…Page603〈ds:ReferenceURI="#CreditCard"〉04…05〈/ds:Reference〉06…07〈wrapper〉08〈soap:Bodywsu:Id="CreditCard"〉09…10〈/soap:Body〉11〈/wrapper〉12〈/soap:Header〉13〈soap:Bodywsu:Id="ChangedBody"〉14…15〈/soap:Body〉16…例3.MEE变异.WebServices某种情况下部分SOAP消息变异前及变异后结果如下.MEE变异前:01…02〈xenc:EncrytedDataxmlns:xenc="http://www.03〈xenc:CipherData〉04〈xenc:CipherValue〉…〈/xenc:CipherValue〉05〈/xenc:CipherData〉06〈/xenc:EncrytedData〉07…MEE变异后:01…02〈xenc:EncrytedDataxmlns:xenc="http://www.03〈xenc:CipherData〉04〈xenc:CipherValue〉…〈/xenc:CipherValue〉05〈/xenc:CipherData〉06〈/xenc:EncrytedData〉07〈xenc:EncrytedDataxmlns:xenc="http://www.08〈xenc:CipherData〉09〈xenc:CipherValue〉…〈/xenc:CipherValue〉10〈/xenc:CipherData〉11〈/xenc:EncrytedData〉12…3.2.3变异算子选择方法严重性和优先级是Web服务测试缺陷的两个重要因素,一般地严重性程度高的Web服务缺陷应赋予较高优先级,并需要及时处理;而严重性程度低的Web服务缺陷应该赋予较低优先级,可以稍后再做处理.对于WebServices安全性测试而言,本文使用优先级及权重策略作为选择何种变异算子的依据.每种变异类型对应着相应的变异操作算子,确定了变异类型的优先级后,即可确定相应的变异算子的优先级.根据Web服务系统安全需求,定义了如下几条确定各种变异类型优先级的准则.准则1.根据待测WebServices强调的安全需求,确定相应属性的变异类型为最高优先级,定制用户需求优先级高于一般用户需求优先级.的安全需求优先级.准则2.确定的安全需求优先级高于不确定准则3.导致Web服务系统主要功能错误或者造成服务崩溃、数据丢失的变异类型为最高优先级.为较高优先级.低的变异类型为较高优先级.准则4.影响Web服务安全性能的变异类型准则5.Web服务测试响应时间快、资源消耗准则6.导致Web服务功能和性能一般缺陷准则7.对Web服务安全影响非常轻微或出的变异类型为一般优先级.现几率很低的变异类型为低优先级.其中准则1和准则2根据Web服务安全需求便可以确定选择的变异类型和变异算子.而准则3到准则7则是基于历史Web服务测试结果作为选择变异类型及其变异算子优先级的根据.此外,对于WebServices的安全性测试,判断是否进行了充分的测试取决于测试用例集的选择.综合考虑所需时间和费用的问题,通常无法执行全部测试用例,这就需要构造一个子集来进行测试.评价子集的测试充分性,或者说其揭示漏洞的能力,需要考虑该子集包含测试用例的数量,同时还需要评价各类测试用例的重要性和其在测试用例子集中的分布情况.设待测WebServices集合为WS={WS1,WS2,…,WSn},变异类型的向量犕犜=(MT1,MT2,…,MTk),MTi表示待测WebServices的第i种变异类型,对于任意WebServicesWSi={WSi1,WSi2,…,WSik},其中1in,WSij表示WebServicesWSi第j种变异类型的值,用Wi来代表变异类型MTi的权值,表示该变异类型对发现该WebServices的安全漏洞的重要程度,称为该变异类型的权重,权重向量为犠=(W1,W2,…,Wk).定义14.Gst(1sm,1tk)是第s个测Page7试用户根据个人的经验为变异类型MTt所指定的等级(等级从1开始,等级用连续正整数来表示,1表示最高等级,数值越大,等级越低),Gt表示第t种变异类型的统一等级,采用均值法计算出每种变异类型的最终统一等级.其中,Gi表示第i(1ik)种变异类型的最终统一等级,m表示测试用户的个数.定义15.若变异类型对应的变异算子发现的错误数越多,即有效率越高,则该变异类型对发现WebServices安全性漏洞越有效.客观上采用随机统计法(多次随机选取一定数目的WebServices)计算每一种变异类型变异算子的有效率,作为客观描述变异类型对于发现当前WebServices安全漏洞的重要性.Cij(1jk)表示第i次第j种变异类型的变异算子发现错误的数目,Cj表示第j种变异类型的最终发现错误的数目,使用均值法计算出每种变异类型最终发现错误的个数.其中,Cj表示第j(1jk)种变异类型最终发现错误的个数,m表示选取的次数.根据式(1)得到的主观等级向量犌=(G1,G2,…,Gk)和式(2)得到的客观变异类型发现的错误数向量犆=(C1,C2,…,Ck),最终得到计算变异类型的权重向量犠=(W1,W2,…,Wk).此处0<Wi1.证明如下:式(a)+式(b),得到同时除以2得到0<4安全规则变异测试算法通常WebServices以SOAP协议格式传送或接受远程服务单元的数据,而一个SOAP消息可以抽象表示为输入参数和安全控制规则两部分.在原有的变异测试研究中,主要考虑的是针对输入参数的变异处理,尚未见到对SOAP消息安全控制规则变异的研究,并且有效的WebServices安全性测试方法和技术也不多见.本节基于变异测试框架及相应的安全变异规则集,给出一种自动生成安全性测试用例的算法TCSRM(TestCasesgenerationbasedonSecurityRulesMutation).4.1TCSRM算法框架TCSRM算法主要分为以下两个阶段.阶段1.首先动态解析WSDL文件得到普通SOAP消息,并将待测WebServices的安全类型分解为一系列原子安全类型.然后依据实际服务要求确定调用安全策略处理的顺序,最终生成符合待测WebServices安全策略需求的正确的SOAP请求消息,并发往服务端.此阶段对应着ASTC(AdaptiveSecurityTestCases)子算法.阶段2.首先根据变异优先准则和权重大小策略确定变异类型、变异顺序及生成测试用例的数目,然后将安全规则变异运用到第一阶段生成的正确的SOAP请求消息,最后生成变异后的安全性测试用例.此阶段对应SRMTC(SecurityRulesMutationTestCases)子算法.图2给出了TCSRM算法的步骤图.4.2TCSRM生成测试用例算法TCSRM主算法、ASTC子算法和SRMTC子算法的具体描述分别如算法1、算法2及算法3所示.约定1.记WebServices安全策略的集合为WSSeP,加密策略为EnP,签名策略为SiP,安全令牌策略为StP,时间戳策略为TsP,角色策略为RlP,属性策略为AtP,隐私策略为PrP,则WSSeP={EnP,SiP,StP,TsP,RlP,AtP,PrP},任一种安全策略记为p∈P,则有p∈WSSep.普通原始的SOAP消息记为OriginalMessage,生成的符合待测WebServices安全策略需求的正确的SOAP请求消息记为TempMessage.Page8图2TCSRM算法步骤图onSecurityRulesMutation).算法1.TCSRM(TestCasesgenerationbased输入:OriginalMessage输出:SecuritytestcasessetS={e1,e2,…,en}1.TempMessage=OriginalMessage;2.if(TempMessagedon’tsatisfysecurityrequirement)3.callASTCalgorithm;4.callSRMTCalgorithm;5.outputthetestcasessetS={e1,e2,…,en}.算法2.ASTC(AdaptiveSecurityTestCases).输入:OriginalMessage,P={p1,p2,…,pj,…,pk},输出:TempMessage1.foreachpifromp1topkdo2.{if(piisEnP)then3.{callEncryptalgorithm;4.TempMessage=TempMessage+encryptedmessage;}5.if(piisSiP)then6.{callSignalgorithm;Page97.TempMessage=TempMessage+signmessage;}8.if(piisStP)then9.{callAddTokenalgorithm;10.TempMessage=TempMessage+addtokensmessage;}11.if(piisTsP)then12.{callAddTimestampalgorithm;13.TempMessage=14.if(piisRlP)then15.{callAddRolealgorithm;16.TempMessage=TempMessage+addrolemessage;}17.if(piisAtP)then18.{callAddAttributealgorithm;19.TempMessage=20.if(piisPrP)then21.{callAddPrivacyPolicyalgorithm;22.TempMessage=23.}24.returnTempMessage.ASTC算法中涉及7个子过程,其中Encrypt为消息加密过程,Sign为消息签名过程,AddToken为添加安全令牌过程,AddTimestamp为添加时间戳过程,AddRole为添加角色过程,AddAttribute为添加属性过程,AddPrivacyPolicy为添加隐私策略过程.这些子过程中的参数可以为整个消息,也可以为消息中的某些元素.这些过程均采用符合WebServicesSecurity语法规范的常用安全操作的处理方法.其中,消息加密过程Encrypt及消息签名过程Sign采用的是经典的加密和签名算法,目的是为了保证处理后的SOAP消息符合常用的安全规范.其它的如AddToken过程、AddTimestamp过程、AddRole过程、AddAttribute过程及AddPrivacy-Policy过程均参照WebServices安全规范增加相应的安全属性,为后面的SOAP消息安全规则变异做准备.SRMTC算法对ASTC算法生成的符合安全规范的SOAP请求消息进行安全规则变异,生成变异后的安全性测试用例.为了方便描述SRMTC算法给出以下约定和符号说明.约定2.记安全令牌变异操作为StM,加密变异操作为EeM,签名变异操作SiM,时间戳变异操作为TsM,角色变异操作为RoM,属性变异操作为AtM,隐私策略变异操作为PpM,Security报头块变异操作为SeM,变异操作类型WSMT={StM,EeM,SiM,TsM,RoM,AtM,PpM,SeM},则当前待测WebServices中含有的变异类型集合为M={m1,m2,…,mj,…,mk},1jk8,则有MWSMT.依据3.2.3小节描述的原则确定待测WebServices中变异类型的优先级序列为pm={pm1,pm2,…,pmj,…,pmk},1jk8,其中pmj表示变异类型mj对应的优先级.则有PWSSep,变异类型的权重为wm[]={wm1,wm2,…,wmj,…,wmk},1jk8,其中wmj表示变异类型mj对应的权重,一种变异类型对应一个优先级,也对应着一个权重值.算法3中StS={CUT,CKT,CXT},EnS={MEE,MEEH,CEA},SiS={MSE,MSH,CSA},TsS={CT},RoS={CUR},AtS={CUA},PpS={CPP},SeS={CHS}.算法3.SRMTC(SecurityRulesMutationTestCases).输入:TempMessage,mi,wm[],输出:TestcasessetS={e1,e2,…,en}1.determinemutationpointsbelongtowhatkindof2.while(pm≠)do3.{mi=Max(pm);//返回pm中具有最大优先4.if(miisStM)then5.{invokeStS;//调用安全令牌算子集6.togeneratetestcasesaccordingtowmi;}7.if(miisEeM)then8.{invokeEnS;//调用加密算子集9.togeneratetestcasesaccordingtothewmi;}10.if(miisSiM)then11.{invokeSiS;//调用签名算子集12.togeneratetestcasesaccordingtothewmi;}13.if(miisTsM)then14.{invokeTsS;//调用时间戳算子集15.togeneratetestcasesaccordingtothewmi;}16.if(miisRoM)then17.{invokeRoS;//调用角色处理算子集18.togeneratetestcasesaccordingtothewmi;}19.if(miisAtM)then20.{invokeAtS;//调用属性处理算子集21.togeneratetestcasesaccordingtothewmi;}22.if(miisPpM)then23.{invokePpS;//调用隐私策略处理算子集Page1024.togeneratetestcasesaccordingtothewmi;}25.if(miisSeM)then26.{invokeSeS;//调用security报头块算子集27.togeneratetestcasesaccordingtothewmi;}28.DeleteMax(pm);//从队列中删除具有最大优29.}30.returnthesetoftestcasesS={e1,e2,…,en}.框架的分析执行器执行算法生成安全测试用例,并根据漏洞判定准则分析检测WebServices安全漏洞.为方便在理论上分析算法TCSRM的复杂性,假定待测WebServices中含有安全策略的种类数为s,方法有m个,每个方法平均有p个参数,消息的长度为n,变异点的个数为q,每次生成的测试用例的个数为t.TCSRM算法的复杂性主要由两个算法决定:(1)ASTC子算法.时间主要消耗在加密和签名算法上.而在执行效率方面,典型的对称加密算法DES的时间复杂性为O(n),签名算法MD5的时间复杂性为O(n),所以时间复杂性为O(2×m×p×s×n)=O(m×p×s×n);(2)SRMTC子算法.其时间复杂性为O(q×t).故基于以上分析可得出TCSRM算法的时间复杂性为O(m×p×s×n)+O(q×t).5实验分析5.1实验环境为了验证本文提出的安全规则变异测试方法的可行性以及TCSRM算法的有效性,设计并实现了一个基于SOAP消息安全规则变异的WebServices安全性测试工具WSSTT(WebServicesSecurityTestingTool).实验环境是:内存4GB、CPUIntel?Core(TM)i3-2120@3.30GHz、硬盘500GB的兼容机、Windows7操作系统,开发工具及技术采用MicrosoftVisualStudio2008、.NETFramework及WCF(WindowsCommunicationFoundation).WSSTT整体的工作流程如下:(1)扫描服务描述WSDL文件,并动态解析WSDL文件生成普通SOAP消息;(2)根据安全规格说明书,配置密钥与加密算法,对SOAP消息进行安全令牌处理、加密处理、签名处理等操作,生成符合待测WebServices安全需求的加密SOAP消息、签名SOAP消息、SAML(SecurityAssertionMarkupLanguage)断言消息、包含安全令牌的SOAP消息或具有多种安全需求的组合消息;(3)对已生成的符合待测WebServices安全需求的正确的SOAP请求消息,通过安全规则变异,调用相应的测试用例生成算法产生测试用例;(4)将这些消息发送到待测WebServices,观察其响应结果;(5)根据漏洞判定准则对WebServices进行安全性分析与评价,最后给出测试报告.整个测试流程如图3所示.5.2实验评价方法对于变异测试充分性的评价,因变异测试也属于错误注入测试的一种,故借鉴一般的错误注入方法进行评价.一般的错误注入测试评价是通过注入错误总数和覆盖的错误注入点数量来衡量.本文在此基础上分别定义有效率、注入率和单元开销3个指标来进行综合评价.定义16.设注入错误的总数为m,注入后WebServices产生安全问题的错误数为n,n/m称为有效率,记作θ=n/m.定义17.设被测试WebServices中错误注入点的总数为m,已经注入错误的注入点的数量为n,n/m称为注入率,记作η=n/m.定义18.设由定义16得到的有效率为θ,所花费的时间为t,则θt称为单元开销,记作c=θt.那么当有效率的数值越大时,可以认为变异算子越有效,WebServices越不安全;当注入率越大时,测试结果越可靠.综合这两个指标,在注入率满足对测试可靠性要求的前提下,在制定测试计划时根据实际情况可以设定当注入率达到一定值时,停止测试.此时可以计算变异算子的有效率,评价该WebServices的安全性.最后通过计算c来描述有Page11效率达到一定值时所需要的测试时间开销,评价算法的性能.5.3实验结果分析由于目前支持WS-Security规范的公共可访问WebServices比较少,因此我们设计开发(含二次开发)了20个支持WS-Security规范的WebServices用于实验分析.20个待测试WebServices的信息如表4所示.表4待测试的WebServices信息编号WS1WS2WeatherforecastWS3WS4BookfindingWS5DomainfindingWS6PetinformationWS7WS8WS9QQcheckonlineWS10QueryresultsWS11ProducedorderWS12WS13MaxdivisorWS14WS15ReversestringWS16StringcopyWS17StringlengthWS18WS19WS20Echoinformation为了便于实验分析统计,在实验过程中进行如下处理:(1)对于同一个WebServices使用不同的变异算子可能会发现同一个漏洞,在此只计算一次;(2)对于同一个变异算子产生的不同的测试用例也可能发现同一漏洞,在此也只计算一次.表5给出所表5所有服务变异算子产生测试用例的个数测试用数个数WSWS13005320002222223WS20030007322200019WS30081615471166325487WS40400005322200018WS55008620003225437WS60304420002200017WS70063430002300021WS80308846644300046WS94003335434336445WS106001310314725334575WS110407748656550057WS12600171570006533264WS133008740004423338WS140507730004420032WS150035420002200018WS164000006522232127WS170305520003200020WS186004430002256436WS190045534433300034WS200309940004300032合计372524127116556249296857323629746有被测WebServices通过每一种变异算子产生的测试用例的数量,表6给出测试后每种变异算子发现漏洞的数量及WebServices实验平均注入的安全缺陷总数.Page12表6Web服务变异算子发现漏洞数漏洞数CUTCKTCXTMEEMEEHCEAMSEMSHCSACHSCTCURCUACPP合计WSWS110010000010011512WS200100020010000412WS3002331220211222160WS40000001101100049WS5200430000100121329WS60101100000000038WS700201000001000412WS801010010010000415WS900001011000111616WS10200321200101111431WS11000110211211001022WS12100321000220111345WS130000100001000026WS1401012000011000621WS150000100001000025WS1640000011000111930WS1701011100000000413WS1820011000010022941WS1900111011100000619WS2001022000021000825合计125623234137218851011147431为了计算变异算子的有效性问题,定义了公式OE=EF/TC,其中EF表示发现的漏洞数;TC表示变异算子产生的测试用例的总数.图4给出了各变异算子的有效性.图5给出了20个被测试WebServices测试效果.图4可以看出大部分变异算子可以较好地发现WebServices存在的安全漏洞,CPP算子效果最好为0.379,但某些变异算子如CSA仅为0.069,说明其仅针对某种特定服务类型才会有更好的效用.图5中OEw为EFw/TCw,表示每个Web服务测试的有效率,其中EFw表示每个Web服务被发现的漏洞数,TCw表示每个Web服务被注入的安全缺陷总数.其中WS11的OEw为0.455,测试效果最好,所有被测试WebServices的平均测试效果为0.341.5.4对比分析目前国内外有效可行的WebServices安全性测试技术研究甚少,对于WebServices安全性全面系统性的测试方法研究并不多见.本文主要对Web服务脆弱性测试工具WSVTT工具[18]、基于SOAP消息的Web服务测试工具SOAPUI①和本文设计的WSSTT工具分别从测试工具的测试效率(有效率)θ及测试工具的性能几个方面进行对比分析.其中,WSVTT是一种基于SOAP消息数据变异的Web服务脆弱性测试工具.SOAPUI是一种公开访问的Web服务功能性测试工具,通过修改WebServicesSOAP消息参数来测试WebServices实现的功能是否正确.实验对比1.SOAPUI、WSVTT和WSSTT3种工具的测试效率θ对比.为了全面分析3种工具的错误检测能力,被测试Web服务事先随机植入了一些功能性错误及安全性缺陷.测试过程中,在注入率满足对测试可靠性要求的前提下,我们设定当注入率达到95%时停止测试.3种工具的测试效率对比如图6所示.①SOAPUI,SmartBearSoftware,availableathttp://www.Page13图6SOAPUI、WSVTT和WSSTT3种工具的测试效率对比从图6可以看出这3种工具的测试效率均随着测试用例数目的增加而增加,而WSVTT优于SOAPUI工具,WSSTT优于WSVTT,能发现较多的功能性错误及安全缺陷.由于目前支持WS-Security规范的公共可访问WebServices比较少,论文中待测试WebServices都是我们自己设计开发的,故实验数据很大一部分取决于WebServices的选取及植入的错误.由于WebServices不同,变异算子不同,所以发现的缺陷数也不同,但从图6可以看出本文提出的变异算子和安全规则变异方法比WSVTT工具和SOAPUI工具在检测WebServices特定安全问题时更有成效.实验对比2.SOAPUI和WSSTT时间性能对比.由于WebServices安全性测试的大部分时间消耗在生成加密与签名的测试用例方面.因此在实验中,我们针对典型操作如签名、加密、签名和加密组合等不同的安全部署进行了实验.实验中由于WSVTT处理签名、加密及其组合运算的SOAP消息时耗时较大,且时间消耗不稳定,故没有和WSVTT进行时间性能对比分析,只给出了SOAPUI和WSSTT的时间性能对比分析结果.定义19.设待测WebServices在使用特定的安全部署之后生成测试用例的时间为LWSSDeployment,例如LWSSSignature表示在执行签名操作时生成测试用例的时间;不执行任何安全部署时的生成测试用例的时间为LNoWSS,则生成测试用例时间增长率为LIP=(LWSSDeployment-LNoWSS)/LNoWSS×100%.本文以学生成绩查询服务Queryresults为例比较WSSTT工具与SOAPUI工具在时间性能方面的差异.该服务要求采用用户名令牌认证并签名加密消息,并且能够提供SOAP消息请求和响应,并支持WS-Security规范中的SOAP消息签名和加密处理.基本的服务流程是:由客户端向服务器发送查询学生成绩的SOAP请求,服务器将经过加密或签名后的消息返回给客户端.图7至图9分别为两种工具实施加密、签名、加密和签名组合安全操作后的LIP对比图.图8签名时的测试用例生成时间增长率对比图图9加密和签名时的测试用例生成时间增长率对比图根据图7至图9所示的对比曲线可以看出:(1)实施安全操作后,生成测试用例的时间都显著增长,而且在签名验证上花费的时间要比在加密解密上多.这是因为在执行加密操作时,仅加密SOAP消息的body内信息,而签名除对body内信息进行操作外,还需要对header内部的时间戳以及路由等信息进行签名;(2)当测试用例个数增加时,WSSTT工具和SOAPUI工具生成测试用例的时间都随着增加,但是WSSTT工具没有SOAPUI工具增长的幅度大,从而说明WSSTT工具有较好的性能.需要说明的是,实验中图7、图8、图9反映出WSSTT工具和SOAPUI工具中的LIP变化趋势比较相似.为了进一步分析LIP受不同被测Web服务的影响,我们测试了一些典型的符合安全规范Page14(具有签名、加密及其组合操作)的Web服务,实验结果表明WSSTT工具和SOAPUI工具中的LIP变化趋势均较相似,表明针对不同的被测试Web服务LIP无显著性差异.6总结通过对WebServices运行特点和各类SOAP消息安全类型漏洞的分析,提出了一种安全规则变异的测试框架,归纳出安全规则变异点判定规则库,并设计了相应的安全规则变异算子和漏洞判定准则.通过安全性测试用例生成算法TCSRM生成变异测试用例对WebServices进行安全性测试,实验结果表明提出的方法对WebServices一般的安全类缺陷具有一定的检测效果.WebServices安全性测试是一个复杂而重要的研究课题,有待今后进一步的研究完善.未来我们主要的研究工作有:(1)安全规则变异算子的完备性还有待于进一步的扩充和论证;(2)进一步对访问权限、地址绑定及编码方式等几个安全属性进行归类与研究,并设计出相对应的安全规则变异操作算子;(3)加大实验力度,设计并收集更多的WebServices,特别是收集一些第三方的满足WS-Security规范的公共可访问Web服务.此外,随着WebServices迅速的发展,一些新的安全技术规范势必会陆续的发布并应用,我们将继续对新技术保持关注,并运用新的技术及时对提出的方法进行优化和完善.致谢感谢课题组的王环环、苏晨飞及赵小磊等同学在实验系统实现和Web服务测试上所做的工作.感谢江苏大学周从华等老师们的有价值的建议和讨论.同时也要感谢审稿专家们所提出的宝贵意见,促使论文质量得到进一步提升!
