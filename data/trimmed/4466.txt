Page1一种基于OpenFlow的SDN访问控制策略实时冲突检测与解决方法王鹃1),2)王江1)焦虹阳1)王勇1)陈诗雅1)刘世辉1)胡宏新3)1)(武汉大学计算机学院武汉430072)2)(教育部空天信息安全与可信计算重点实验室武汉430072)3)(克莱姆森大学克莱姆森29634美国)摘要软件定义网络SDN(Software-DefinedNetworking)是由美国斯坦福大学CleanSlate研究组提出的一种新型网络创新架构,可通过软件编程的形式定义和控制网络,其控制平面和转发平面分离及开放性可编程的特点,为新型互联网体系结构研究提供了新的实验途径,也极大地推动了下一代互联网的发展.OpenFlow是SDN的主要协议,定义了SDN控制器与交换机之间的通信标准.目前,很多基于OpenFlow的SDN设备已经在实际中得到了部署.但是,基于OpenFlow的SDN却面临很多安全挑战.其中一个重要的挑战是如何建立一个安全可靠的SDN防火墙应用.由于OpenFlow协议的无状态性,现有的SDN防火墙可以被通过改写交换机中的流表项轻松绕过.针对这一安全威胁,作者提出了基于Flowpath的实时动态策略冲突检测与解决方法.通过获取实时的SDN网络状态,能够准确地检测防火墙策略的直接和间接违反,并且一旦发现冲突,可以基于Flowpath进行自动化和细粒度的冲突解决.最后,作者在开源控制器Floodlight上实现了一个安全增强的防火墙应用FlowVerifier,并基于Mininet对FlowVerifier的性能进行了评估.结果表明FlowVerifier能够检测和自动化地解决SDN网络中由于流表改写而引入的策略冲突及其带来的安全威胁.关键词软件定义网络;OpenFlow;策略;冲突检测与解决;访问控制1引言软件定义网络SDN(Software-DefinedNet-working)是由美国斯坦福大学CleanSlate①研究组提出的一种新型网络创新架构,可通过软件编程的形式定义和控制网络,被认为是网络领域的一场革命.SDN的本质特点是控制平面和数据平面的分离以及开放可编程性.通过分离控制平面和数据平面以及开放的通信协议,SDN打破了传统网络设备的封闭性.此外,南北向和东西向的开放接口及可编程性,也使得网络管理变得更加简单、动态和灵活.OpenFlow是目前SDN的主流协议,其定义了SDN控制器与交换机之间的通信标准.SDN控制器通过OpenFlow协议②对OpenFlow交换机中的流表进行控制.控制器会为特定的工作负载计算最佳路径,从而对交换机的数据转发定义路径.控制器可以是一个设备,一个虚拟机或是一个物理服务器.目前基于OpenFlow的SDN已经在美国斯坦福大学、Internet2、日本的JGN2plus等多个科研机构中得到部署,一些网络设备生产商也推出了支持OpenFlow的有线和无线交换设备.Google等公司已经在其云数据中心部署了SDN.国内,清华大学、中国科学院、北京邮电大学等以及一些知名企业,如华为、百度、腾讯、阿里等也都开始研究和部署SDN实验平台.根据美国著名市场研究公司Infonetics的调查数据,未来几年SDN的市场价值将超过30亿美元.Gartner在2013年发布的IT十大战略性技术趋势报告中也将SDN列为未来五年的十大关键技术之一.随着SDN的发展和相关网络设备的应用,基于OpenFlow的SDN网络也面临很多新的安全挑战,其中一个重要的挑战是如何建立一个安全可靠的防火墙.由于OpenFlow协议几乎是无状态的,当主机或网络设备发送信息时,只有当前流的第一个包会被控制器检测,而接下来的包都会直接通过交换机.因此,攻击者可以通过改写交换机中的流表项而轻松绕过SDN防火墙.针对上述安全威胁,我们提出了一种基于Flow-path的实时动态策略冲突检测与解决方法.通过获取实时SDN网络状态,能够准确地检测防火墙策略的直接和间接违反,并且一旦发现冲突,可以基于Flowpath进行自动化和细粒度的冲突解决.最后,我们在开源控制器Floodlight③上实现了一个安全增强的防火墙应用FlowVerifier,并在Mininet下对FlowVerifier进行了性能评估.结果表明Flow-Verifier能够检测和自动化地解决SDN网络中由于流表改写而引入的策略冲突及其带来的安全威胁.论文的主要贡献如下:(1)分析了SDN中的安全威胁和挑战.通过两个安全策略冲突的例子描述了目前OpenFlow网络中安全策略违反的威胁并分析了引起防火墙安全策略被绕过的的主要原因.(2)提出了一种基于Flowpath的SDN策略动态冲突检测方法.该方法通过获取实时的SDN网络状态,并比较防火墙的安全策略空间和对应的①②③flow.org/documents/openflow-spec-v1.1.0.pdf2014,4,30tation/2014,4,30Page3Flowpath空间,对防火墙的安全策略进行动态的冲突检测.(3)提出自动化的冲突解决机制.一旦检测到策略冲突,根据不同情况基于Flowpath对冲突进行自动化的解决,如可以通过在交换机的入口或出口插入特殊的阻断流表来阻止恶意的信息流,进行冲突解决.(4)实现与评估.基于Floodlight实现了一个安全增强的SDN防火墙应用FlowVerifier.同时,对FlowVerifier的性能进行了评估.结果表明Flow-Verifier能够有效地解决由于策略冲突带来的安全威胁.2SDN网络的安全挑战SDN作为一种新型的网络架构,出现时间较短.作为其核心协议,OpenFlow规定了控制器和交换机通信的数据标准.控制器向交换机发送符合OpenFlow标准的命令.一个OpenFlow交换机可能会包含多个流表,一个流表可能包含多个流表项.一条流表项包含包头域、计数器域和操作域.包头域指出了需要匹配的数据包的信息,包括输入端口,源、目的MAC地址,源、目的IP地址等;计数器域则表示匹配到此条流表项的数据包的个数或者匹配到此流表项的某个类型的数据包的个数或字节数;操作域则是一个集合,包含转发、丢弃、修改等操作.当数据包被转发时,它将与交换机中的流表项进行匹配,如存在多个可以被匹配的流表项则仅匹配优先级最高的那个.当流表中没有可以匹配的流表项时,那么交换机则把数据包以Message-In的形式发图1重写操作导致安全策略被绕过送给控制器,由控制器通过广播信息进行MAC地址学习,找到转发的数据通路.流表项中的Set-Field操作可以对数据包的包头进行重写,从而达到对网络结构的灵活控制和可编程目的.SDN网络的这种灵活性导致其面临一些新的安全挑战[1-2].首先,OpenFlow协议几乎是无状态的.当一条信息流在交换机中没有找到流表项与之匹配时,控制器只接受该信息流的第一个数据包并对其进行检查.随后数据包会通过交换机直接转发.因此,攻击者可以利用流表项的Set-Field操作构造一个可以绕过SDN防火墙安全策略的恶意流,如图1所示.图1的网络拓扑中有4台主机、3台交换机和1台控制器.位于控制器的防火墙应用定义了一条安全规则,阻止主机A(IP:10.0.1.12)和主机C(IP:10.0.3.32)进行通信.假设A、D为企业内部网络的主机,B为外部网络的主机,但通过了企业的认证,C为外部网络未通过企业认证的主机.现在主机A的恶意使用者可以通过以下3个交换机的流表项(如图1所示),将企业内部的机密信息发送到外部网络未通过验证的C主机.具体实现过程如下:第1台交换机的流表项把源地址为10.0.1.x且目的地址为10.0.2.x的数据包的源地址改为10.0.4.x;第2台交换机的流表项把源地址为10.0.4.x且目的地址为10.0.2.x的数据包的目的地址改为10.0.3.x;最后一台交换机的流表项转发源地址为10.0.4.x且目的地址为10.0.3.x的数据包.在这种情况下,主机A(10.0.4.22)可通过给主机B(10.0.2.22)发送数据包而绕过防火墙.该数据包可以绕过防火墙是因为它和防火墙的安全策略不匹配,但是通过上文所述的流表操作这个数据包最终会被发到主机CPage4而不是主机B.这样,主机A实现了绕过防火墙与主机C通信的目的.通过这个例子,我们可以看到目前基于OpenFlow的SDN网络存在防火墙被通过改写流表而绕过的安全威胁.其次,现有的SDN防火墙忽略了流表项之间的依赖性,从而使得由于流表项之间的依赖关系而导致防火墙的安全策略违反.如图2所示,假设网络中一个应用程序已经把一条流(Flow1)的3个转发规则安装到交换机.第1台交换机中第1条流表项匹配从10.0.4.x到10.0.2.x的数据包并将其源地址改成10.0.1.x.第2台交换机中第1条流表项匹配从10.0.1.x到10.0.2.x的数据包并将数据包的源地址由10.0.1.x改成10.0.4.x,目的地址由10.0.2.x改成10.0.3.x.第3台交换机中的第1条流表项匹配从10.0.4.x到10.0.3.x的数据包并直接转发.通过这3条流表,类似于图1,主机A(IP:10.0.1.12)借助于主机B(IP:10.0.2.22)将信息发送给了主机C(IP:10.0.3.22).此时,假设还有另外一个应用程序把另外一条流(Flow2)的策略安装到交换机,此策略只包含3条转发规则,都是把来自主机A(IP:10.0.1.12)的数据包转发到主机B(IP:10.0.2.22).我们可以进一步假设Flow2中的策略优先级比Flow1的优先级低.在第1台交换机中,数据包转发正常.当数据包到达第2台交换机时,由于两条流表项都是匹配从10.0.1.x到10.0.2.x的数据包,而由假设可知,无论是来自Flow1还是来自图2规则依赖导致安全策略被绕过Flow2的数据包,都会按照第1条流表项进行处理.所以来自Flow2的数据包原本应该从主机A(IP:10.0.1.12)发到主机B(10.0.2.22),结果却发到了主机C(10.0.3.32).这是我们发现的一种由于流表的优先级关系而导致防火墙规则被违反的情形.因此,即使所有不同流定义的策略都不违反防火墙安全策略,但是他们之间的依赖关系可能会导致安全策略违反情况的发生.针对第1种防火墙安全策略被绕过的情况,美国德克萨斯农工大学安全通信和计算机系统实验室的研究小组在“ASecurityEnforcementKernelforOpenFlowNetworks”论文中设计了一种增强安全的SDN操作系统内核,其中提出了基于别名集的SDN安全策略冲突检测方法.该方法将通信中源地址和目的地址分别放到两个地址集合中,并将Set-Field操作中被修改的地址也加入到上述两个集合,然后将源地址集合和目的地址集合与防火墙的安全规则进行比较从而发现策略冲突.别名集方法可以找到一些简单的由于修改流表造成的安全策略冲突.然而,因为它并不基于网络的实时状态,所以在一些复杂的实例中会产生误报.以图1中的网络拓扑为例,防火墙规则为禁止A与C通信,假设3个交换机中的流表项如下:S1:Match(src=A,dst=B)→Set(src=D,dst=B)S2:Match(src=D,dst=B)→Set(src=D,dst=C)S3:Match(src=D,dst=C)→Set(src=D,dst=B)Page5S1交换机匹配源地址是A且目的地址是B的数据包,然后把它的源地址改为D;S2交换机把源地址是D且目的地址是B的数据包的目的地址改为C;S3交换机把源地址是D且目的地址是C的数据包的目的地址改为B.按照别名集的冲突检测算法,会得出(A,D)→(B,C)之间存在冲突,即A与C之间存在冲突.但事实上,A发给B的数据包,最终到达了B,而没有到达C,即别名集算法发生了误报.针对上述问题,我们提出了一种基于Flow-path的SDN安全策略动态检测和解决方法.通过比较ShiftedFlowpathSpace和防火墙DenyAuthorizationSpace,对防火墙安全策略进行动态冲突检测和自动化的冲突解决.3基于Flowpath的SDN安全策略动态冲突检测方法3.1全网的FlowpathFlowpath指的是SDN中每个Flow的转发路径,我们所提出的SDN安全策略动态冲突检测和解决方法建立在Flowpath探测的基础上.Flowpath的建立基于HeaderSpaceAnalysis(HSA)[3-4]算法.HSA提供了一个数据包路径计算模型.数据包的包头可以看做一个HeaderSpace空间{0,1}L中的一个点,L为包头最大长度.网络设备的转发操作可以根据HeaderSpace空间的转发规则描述成一个转换函数T.这个转换函数T可以模拟转发操作,例如接收数据包动作,然后将其转发到相应的输出端口,即例如,定义a和b之间的转换函数为Ra→b=∪a→bpaths{Tn(Γ(Tn-1(…(Γ(T1(h,p)…)))))},所以,a和b之间的路径是一些转换函数的组合,每个组合的形式如下:具体实现时,我们将a和b之间的路径(Flowpath)描述为如下(switch,rule)序列,其中rule是交换机的处理规则.获取Flowpath的主要流程如算法1所示.我们获取头节点的头部作为一条Flowpath的起点,根据网络的拓扑结构即可得到下一跳(交换机),然后获取交换机中的流表项的头部信息,将它们转换成二进制向量.将头结点头部信息中的目的地址和下一跳头部信息中的源地址进行二进制交运算,若交集不为空,则将下一跳加入到Flowpath中,这样我们就找到了一条Flowpath的一部分.接下来,通过网络拓扑获得下一跳交换机,同样,比较上一跳头部信息中的目的地址和下一跳的源地址,若存在交集,那么我们又找到了这条Flowpath的另外一部分,重复这个过程,直到找到目的节点,一条Flowpath就形成了.算法1.Flowpath探测算法.输入:flowtable;topology输出:flow_path[]find_flow_path(flowtable;topology)flow_path.path[]←[]flow_path.src←first_flow_entry.src;switch_linked_list=null;flow_path.dst←last_flow_entry.dst;returnflow_path[];3.2算法复杂度分析假设topology中有m个主机,n个交换机,平均每个交换机中的流表项数目为k.根据算法1的描述,从m个主机中任选一主机开始遍历,根据拓扑结构获取到该主机连接的交换机,并查找交换机中的流表条目与主机、端口进行匹配.执行1次.行k次.流表对算法复杂度的影响:(1)最佳情况:第一次就匹配成功,匹配操作只(2)最坏情况:最后一次匹配成功,匹配操作执(3)平均情况:匹配操作执行k/2次.拓扑结构对算法复杂度的影响:(1)若n个交换机排列成线型网络,则路径的探测算法最多要经过n个交换机,最少经过1个交换机,平均经过n/2个交换机.(2)若n个交换机排列成网状,经由的交换机Page6最多小于n,最少为1.度为(3)若n个交换机排列成树状,情况与网状类似.综上,找出全网络中所有Flowpath的时间复杂最坏情况:m×k×n次比较平均情况:m×(k/2)×(n/2)次比较最佳情况:m次比较3.3重写的Flowpath空间与Deny授权空间本文中关注的是防火墙安全策略的间接违反,即每一条流表的策略都没有直接违反防火墙的策略,但是通过若干条流表的修改和转发,最终却绕过了防火墙的安全策略.由于防火墙安全策略的间接违反必须通过修改流表项才能成功,因此我们在进行冲突检测时只需要关注那些存在重写操作的Flowpath,我们称之为ShiftedFlowpath,所有的ShiftedFlowpath构成ShiftedFlowpathSpace.由这些ShiftedFlowpath组成的图称作为ShiftedFlowpathGraph.此外,防火墙中的Deny规则也构成了Deny授权空间(DenyAuthorizationSpace).在检测防护墙策略的间接违反时,我们需要比较DenyAuthorizationSpace和ShiftedFlowpathSpace.4冲突检测与解决4.1方案概要通常情况下,防火墙规则包含5个域:源地址、源端口、目的地址、目的端口和协议.Flowpath的入口头部包含3个域:源地址、源端口和协议.Flow-path的出口头部包含两个域:目的地址和目的端口.为了检测防火墙规则是否与OpenFlow交换机中的流表规则冲突,我们从防火墙规则中提取源地址和目的地址,并且根据该规则计算与之对应的ShiftedFlowpath.如果存在与防火墙规则源地址和目的地址对应的ShiftedFlowpath,则可以确定防火墙策略和流表策略之间存在冲突.在检测策略冲突时,我们还需要考虑不同的情况,如添加新的防火墙规则和更新防火墙规则以及添加新的流表项和更新流表项,以便在防火墙规则发生改变时和网络状态发生改变时重新检测防火墙策略空间与流表策略空间的冲突.一旦安全策略的冲突被检测出来,这些冲突需要自动化地解决,因为在一个较大的网络里,由管理员手工解决冲突是非常困难的.由于安全策略的违反可能是完全的也可能仅是部分违反,因此需要根据不同的情况进行不同的冲突解决.对于完全的策略违反,我们可以将这条Flowpath直接从网络中移除或者拒绝那些完全违反安全策略的流表项插入交换机.对于部分安全策略违反,不能够直接移除Flowpath或者拒绝流表项的插入,因为它们可能与其他的流存在依赖关系,从而可能会影响其他的SDN应用.针对这个问题,我们可以通过添加更高优先级的Deny规则来解决策略的部分违反.具体在冲突解决时,也需要考虑以下各种不同的情况,从而进行自动化和细粒度的冲突解决.4.2添加防火墙规则和更新防火墙规则向防火墙中添加新的规则可能会导致防火墙策略与交换机流表策略之间的新的冲突.如果新的防火墙规则不是Deny规则,那么它们就不会导致被绕过的威胁.所以,在冲突检测时我们仅考虑Deny规则.在检测冲突之前,需要重新确定DenyAuthorizationSpace,通过检查新加入的防火墙规则和现有的防火墙规则间的依赖关系,确定新的DenyAuthorizationSpace.然后我们获取与之对应的ShiftedFlowpathSpace,将新的DenyAuthorizationSpace和得到的ShiftedFlowpathSpace进行比较以检测冲突的发生.此外,在更新现有防火墙规则的时候也可能会改变内部表依赖关系而导致DenyAuthorizationSpace的改变.因此,在更新防火墙规则时也应该更新DenyAuthorizationSpace,像添加新的防火墙规则一样,重新计算DenyAuthorizationSpace,然后与对应的ShiftedFlowpathSpace进行比较,检测是否存在冲突.在添加新的防火墙规则或者更新防火墙规则时,当新的防火墙规则被添加到DenyAuthorizationSpace中,相应的ShiftedFlowpath就会建立.在ShiftedFlowpathSpace中记录着与新的防火墙规则相关的Flowpath的源地址和目的地址.而且,通过直接比较ShiftedFlowpathSpace信息和防火墙DenyAuthorizationSpace信息可以检测出策略的冲突.如果ShiftedFlowpathSpace比防火墙的DenyAuthorizationSpace小,那么ShiftedFlowpath就可以被移除.但是如果ShiftedFlowpathSpace比新的防火墙DenyAuthorizationSpace大,我们就需要阻止ShiftedFlowpathSpace中与防火墙冲突的部分信息流.图3展示了一个例子,当一个新的规则被添加到防火墙中,防火墙发现ShiftedFlowpathSpace比新的DenyAuthorizationSpace大.因此防火墙通过插入更高优先级的阻断流表的方式,在头交换机和尾交换机处拒绝了Flowpath中冲突的那部分信息流.Page7图3从头尾交换机添加流表解决冲突4.3添加流表项和更新流表项当网络应用程序或者控制器向交换机流表中添加新的流表项或者更新流表项时,网络的状态会发生改变,从而可能引入与防火墙策略相违背的新冲突.因此,在流表项发生改变时,需要更新流地址空间,重新计算ShiftedFlowpath.此时没有必要再重新构造全网的ShiftedFlowpath,而只需图4拒绝流表项添加解决冲突要对插入新的流表项的交换机的那个局部ShiftedFlowpath进行更新.然后,我们再将新的ShiftedFlowpathSpace和DenyAuthorizationSpace进行比较,检测是否存在冲突.一旦检测出冲突,我们冲突解决模块会拒绝这些流表项的添加或者更新请求.图4展示了一个例子,当一个新的流表项被插Page8入到Table3中,我们检测出在防火墙策略和这条新的流表项之间存在冲突.ShiftedFlowpathSpace(1110→x100)比防火墙的DenyAuthorizationSpace(1110→xx00)小.所以添加这条新的流表项的请求被拒绝.当ShiftedFlowpathSpace比DenyAuthorizationSpace大时,冲突部分将会在头尾交换机处被阻断(如图4所示).5实现与评估5.1实现我们在Ubuntu12.04LTS下使用Mininet模拟SDN网络资源,通过虚拟机中运行Mininet搭建网络拓扑结构.使用Floodlight-0.9.0版本作为网络的后台控制器,我们在控制器中实现了Flowpath探测模块,冲突检测模块和冲突解决模块.Flow-path探测模块可以构建ShiftedFlowpath.基于ShiftedFlowpath,冲突检测模块可以通过比较防火墙的DenyAuthorizationSpace和ShiftedFlowpathSpace检测安全策略的间接违反.当检测到策略冲图5FlowVerifier的实现框架5.2评估为了评估FlowVerifier的效果和性能,我们将实验系统搭在四核IntelCorei5-3230M2.6GHzCPU和4GB内存的Ubuntu12.04LTS主机上,并针对防火墙策略被绕过的实例1(图1)和实例2(图2)进行测试,针对这两种情况,FlowVerifier可以找到安全策略冲突并自动解决这些冲突,检测冲突和冲突解决的耗时如表1所示.冲突检测的时间包括建立ShiftedFlowpath和比较防火墙Deny突时,冲突解决模块将根据不同情况进行自动化的冲突解决.如图5所示,控制节点主要包含Floodlight及Flowpath探测模块、冲突检测、冲突解决模块.这些新的功能构成了安全增强的SDN防火墙FlowVerifier.控制器通过JavaAPI提供的拓扑管理服务获取、存储拓扑信息.同时,它通过JavaAPI函数读取每个MininetSwitch里的流表,并生成Flowpath图,存储起来.我们可以通过Floodlight控制器平台提供的JavaAPI获取所有流的信息,同时我们在控制器平台实现了一个新的JavaAPI获取所有防火墙规则的信息.当应用程序或者控制器往MininetSwitch里添加新的流表项时,Flowpath图就会做相应更新.当冲突检测模块检测到Flowpath和防火墙规则之间存在冲突时,它将调用冲突解决模块自动化进行冲突解决.为了优化我们所开发的应用程序的性能,我们将源地址和目的地址转换成二进制向量.然后,通过直接比较二进制位计算出防火墙DenyAuthorizationSpace和ShiftedFlowpathSpace的交集,大大提高了冲突检测的效率.AuthorizationSpace和ShiftedFlowpathSpace的时间.表1FlowVerifier在实例1和实例2中的耗时实例冲突检测时间/ms冲突解决时间/ms实例1实例2此外,我们还实现了在FortNox[5]中提到的别名集冲突检测方法,并将我们的方法和他们的方法Page9作了对比.针对上面设计两种方案,我们比较了两种方法的有效性和误报情况,结果如表2所示.表中所填结果的第1个属性值代表有效性,第2个属性值代表是否存在误报.根据结果显示,在实例1中,两种方法的检测结果都是有效的且不存在误报,但是在实例2中,两种方法虽然都检测出了结果,但是别名集冲突检测方法存在误报情况.当Flow2没有插入到交换机时,误报出现了.此时,没有从主机A到主机C的信息流,只有主机B到主机C的信息流.别名集冲突检测方法存在误报是因为它仅仅将被修改的地址加入到别名集中,将源地址集合和目的地址集合与防火墙规则进行对比.它并没有考虑到网络中的实时流状态,相反,我们的方法基于实时的Flowpath并且通过比较防火墙DenyAuthorizationSpace和ShiftedFlowpathSpace空间,能够精确地检测策略冲突.方法FlowVerifier有效检测出冲突,FortNox有效检测出冲突,考虑到网络拓扑的复杂度和流表项的数量会成为影响FlowVerifier系统性能的两个主要因素,我们创建了简单网络拓扑结构(图6)和复杂网络拓扑结构(图7).简单网络拓扑包括3台交换机(S1,S2,S3)和4台主机(h1,h2,h3,h4);复杂网络拓扑结构包括8台交换机和64台主机.这些交换机中的流表构成了Flowpath.同时,这些交换机通过OpenFlow协议与控制器通信.如果交换机中的某条流表项更改我们也比较了添加不同数量的候选流表项到交换机,原版Floodlight控制器和带有FlowVerifier图7复杂网络拓扑了,交换机会发送一个Flow-Removed类型的消息到Floodlight控制器.因此,Floodlight控制器可以实时地更新网络拓扑结构,与此同时,冲突检测模块也会及时检测冲突.在这个实验中,我们的目标是在不同数量的流表项情况下测试FlowVerifier的性能,为了实现这个目的,我们专门编写了计算并记录延迟时间的函数,将系统获取防火墙规则和所有流表项所用的时间排除在外.我们预先在防火墙模块中配置了防火墙规则,将它们分别与100,200,300,…,1000条候选流表项对比检测.我们在两种网络拓扑中分别进行了测试,结果如图8所示.从结果我们可以看出,随着候选流表项的增加,冲突检测计算所用时间线性增长.而且,我们还可以观察到,两种网络拓扑结构在耗时上的差异,通过这种差异对比,我们可以知道拓扑结构的复杂程度对于冲突检测时间是有影响的,但是我们同时也可以看到复杂拓扑与简单拓扑在添加1000条流表项的冲突检测时间相差仅3ms左右,因此可知在较复杂网络拓扑的情况下FlowVerifier也能在较短时间内计算出冲突.模块的控制器所用时间,在这个实验中,我们使用网络拓扑结构为图6所示的简单拓扑结构,我们添加Page10图8不同数量的流表项情况下FlowVerifier的性能流表项的条数为10,100,1000,分析结果如图9所示.由结果我们观察到,随着流表项条数增加,添加流表时间近乎线性增加,与此同时,我们也可以观察到FlowVerifier模块所占用耗时也渐渐增多,但是,在流表项条数可控的情况下,延迟是在可接受范围内的.图9比较Floodlight与FlowVerifier添加10,100,与此同时,我们还测试了多种情况下原版Floodlight控制器和带有FlowVerifier模块的控制器在CPU开销上的差异,实验网络拓扑如图7所示,每种情形我们都做了10次重复实验,每次实验取最高结果,把10次实验数据作平均,测试结果如表3所示.表3Floodlight和FlowVerifier在多种情况下的启动时输入10条流表项12.7输入50条流表项26.4输入100条流表项50.1输入500条流表项125.9输入1000条流表项147.8由表3可知,在不同状况下Floodlight和FlowVeri-fier的CPU占用率是不相同的,我们可以看到的是FlowVerifier相较于原版Floodlight在CPU开销上的差异不是很大.6相关工作随着SDN技术的快速应用与发展,有关SDN安全话题备受关注.在OpenFlow和SDN网络自身的安全性方面,FlowVisor[6]建立了一个网络虚拟化平台,其网络分片技术通过在控制层和数据层增加一层,实现虚拟网络隔离从而提供一定的安全保障.FLOVER[7]是一个可以检测部署在OpenFlow网络中的流表策略是否违反了网络的安全策略的新型检测系统,它可以检测出由于出错导致无效和不可见的路由,但是它并没有考虑到防火墙策略.Pyretic[8]提出了一种高级语言用于应用程序策略的合成.它通过一个策略合成器将防火墙策略和流表策略合成到一起,然后将合成后的策略推送到每一台SDN交换机的流表空间中.该方法可以检测防火墙策略和流表策略的直接冲突,但是无法检测它们之间由于流表重写或流表间依赖关系而导致的策略间接违反.此外,该方法将合成后的策略推送到交换机中,但是SDN交换机使用三态内容寻址存储器(TCAM)存储流表,其存储空间非常有限,因此当防火墙规则较多时,这种推送到每台交换机的方式是不实用的.再者,如果流表策略完全而不是部分违反了防火墙策略,在实际当中可以直接将其丢弃,也不需要将违反的防火墙策略安装到SDN交换机中.Anteater[9]利用SAT解析器将数据平面的信息转换成布尔表达式,然后将需要检测的策略属性转换成SAT问题,从而检测策略的属性,如一致性.FlowChecker[10]将网络策略转换成逻辑表示,然后利用二进制决策图(BinaryDecisionDiagram)检测网络策略的属性.但上述两种方法对网络策略的检测是静态的,没有获取和描述网络的策略的动态变化,因此无法检测防火墙策略的间接违反.Veri-Flow[11]利用图搜索技术描述网络的状态和验证网络的性质,如可达性,从而可以潜在地检查安全冲突,但是却不能自动和实时地解决冲突.Floodlight包含了一款开源的基于OpenFlow标准的SDN防火墙应用,但是该防火墙仅仅是把传统防火墙的包过滤功能应用到了SDN控制器中,仅能够检测策略的直接违反.Page11与我们的研究工作最相近的是Shin等人给出的一种安全增强的SDN控制器FortNox,在Fort-Nox中他们针对现有防火墙容易被绕过的问题,提出了别名集策略检测方法,该方法通过将流表中被修改过的源地址和目的地址加入到IP地址集合中,然后与防火墙策略中的IP地址进行比较来检测策略违反.该方法能够检测出部分策略违反,但由于缺乏跟踪数据流路径的机制,从而导致该方法存在误报.针对上述问题,我们提出了基于网络状态的实时动态策略冲突检测与解决方法.通过获取实时的SDN网络状态,我们的方法能够更准确地检测防火墙策略的直接和间接违反.同时,与FortNox不同,我们基于SDN网络状态初步给出了自动化的冲突解决方法.7结论SDN的开放性和动态性使得网络管理变得更加灵活和智能,然而这些特性也使得SDN面临新的安全威胁.本论文针对现有的SDN防火墙可以被通过改写交换机中的流表项轻松绕过这一安全问题,提出了基于Flowpath的实时动态策略冲突检测与解决方法.通过获取实时的SDN网络状态,并比较防火墙DenyAuthorizationSpace和ShiftedFlowpathSpace,我们的方法能够准确地检测防火墙策略的间接违反,并且一旦发现冲突,可以基于Flowpath进行自动化和细粒度的冲突解决.最后,我们在开源控制器Floodlight上实现了一个安全增强的防火墙应用FlowVerifier,并在Mininet下对FlowVerifier进行了性能的评估.结果表明FlowVerifier能够检测和自动化地解决SDN网络中由于流表改写而引入的策略冲突及其带来的安全威胁,并且其性能开销在可接受范围内.
