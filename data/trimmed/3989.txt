Page1一种多核间内存公平调度模型刘虎球赵鹏(清华大学计算机科学与技术学院北京100084)摘要计算机的发展已进入多核时代,在共享内存的计算机系统中,内存需要为多核提供公平的服务.文中提出一种在多核环境下的内存公平调度模型,将多核调度问题转化为一个数学模型,极大地拓展了研究多核调度的思路,然后通过启发式算法求解,得到了一个性能较优的公平调度算法FQ-SJF.基准soplex的实验结果表明,相比FR-FCFS调度算法,平均读取延迟比FR-FCFS减小了10.6%,有效验证了提出的多核调度模型.关键词多核内存调度;多核调度模型;公平队列调度1引言近年来,CPU的多核技术得到了大力发展,在共享内存的多核体系结构中,多个处理器需要访问同一部分系统内存,因此内存调度的重要性日益明显,逐渐成为国内外的研究热点[1-2].人们也希望通过设计较好的内存体系结构来解决处理器和内存之间的发展速率差[3-4].在内存调度中,主要完成的是接收内存请求队列中的请求,然后在算法控制下执行被选中的请求,本文首先提出了一个通用的内存公平调度模型.并通过理论上论证,目前的多种调度算法均为该模型的一个解,并且通过设置不同模型参数,使得该模型具有不同的代表意义.随后,通过使用启发式算法为模型构造了一个解,并通过模拟仿真实现该内Page2存调度算法,通过修改M5模拟器,并在M5模拟器上运行各种待测试的基准应用,与现行的几种多核调度算法进行性能上的综合比较并验证了模型的可用性.2相关工作2.1存储系统为了有效定位和说明内存调度,首先简要地对计算机的基本组成和软硬件构造予以说明.现代计算机都以存储器为核心,这与古典的冯·诺依曼结构有所不同,从程序员的角度,计算机要开始工作,必须把程序装载到计算机的内存中.该过程可以归为存储管理过程.在程序执行过程中,中央控制器所需要的指令从存储器中读取,运算器所需要的数据同样从内存中读取,执行完的结果同样需要写回到内存中,在当前的主流系统结构中,IO设备也可以直接和存储器进行数据交换,可见存储器已经成为计算机的核心部件.对于内存调度,从操作系统的层次上看,主要由硬件完成,这是因为当前的体系结构中,存储器内部结构对于存储管理是透明的.当CPU将读取内存的请求交由内存控制器[7]后,此时完全由内存调度来完成,其中包括从内存请求队列中获取内存请求,然后按照内存调度算法处理该请求队列,待请求被执行完时,通知CPU可以继续执行,因而对于操作系统来说,是完全透明的.在当前的多核系统中,各处理器通过共享内存资源完成一些混合应用,同时也通过内存共享完成部分核间数据共享和通信[8-9].因此内存调度更需要均衡地响应各个处理器的内存读写请求,从而有效提高各个处理器的利用率.但内存调度仍旧完全由存储器内部控制器完成,从操作系统角度看,属于硬件内部的逻辑.2.2时序约束通过前面的描述,可以知道,内存调度通过有效的管理Cache和主存的数据,从而提高系统的Cache命中率,缩短存储器的访问周期.但是目前Cache和DRAM均受到物理材料的限制,受到综合的时序约束,下面将首先简要介绍一下在内存调度中主要考虑的一些时序约束.Cache是当前存储体系中访问速率较高的存储芯片,当CPU发出读请求时,存储系统首先会根据CAM(ContentAddressableMemory)检查Cache是否命中,若命中则直接读取,否则将访问请求提交至内存访问队列中.主存DRAM作为存储系统的重要核心部件,内存调度在执行内存请求时将内存中的数据及时推送到存储器中,为了完成有效的内存调度,内存控制器需要对存储器的时序进行规划,当处理完毕时,及时返回数据给CPU,防止等待时间过长.2.3多核内存调度算法从前文的介绍可以看出,尽管内存调度不属于操作系统范畴,但是对存储器系统性能有着非常重要的作用.和存储系统一样,内存调度同样存在调度目标,其中包括吞吐率、平均等待时间、公平性、Cache命中率等[10-11],下面将简单地进行介绍.(1)吞吐率.在存储系统中,吞吐率是指在一段时间内,系统的单位时间的吞吐量,是一种访问速率的量度,该指标主要从CPU的角度进行设计,实际中常常使用每个总线周期指令条数(InstructionsPerClock)IPC指标代替.(2)平均等待时间.内存请求平均访问的等待时间,该参数较小则表示系统的访问速度较快,同样存储器的访问周期也越小.(3)公平性.表示各个内存请求的延迟是否公平,在目前的多核调度中,是考虑的另一个重要因素,主要是防止个别请求过长等待,保证公平性和服务质量.(4)Cache命中率.通过有效的调度可以提高Cache的命中率,提高访问速度,该部分目前逐渐被引入到调度系统中.目前的调度算法主要考虑了上述因素,而上述指标同样常常用于测试基准的评价指标[12],下面将分别从上述角度对已有的一些多核调度算法做一些简单的介绍.2.3.1通用多核调度算法在计算机的调度算法中,经典的调度算法占据着重要地位,其中包括先来先服务(FCFS)、优先级调度算法、最长时间未被访问(LRU)、最小频率访问(LFU)等,其中FCFS算法后来衍生了一个系列的算法,具体在第2小节中予以详细介绍.而优先级调度算法使用并不多,针对内存请求队列,内存控制器通过识别请求的优先级标签,从而有效地调度内存,为有实时性要求的请求提供服务保障.2.3.2基于FCFS衍生的多核调度算法FCFS调度算法实现最为简单,人们在研究多核调度时,同样构造了一些基于FCFS的衍生算法,其中包括FR-FCFS(FirstReady,FirstComeFirstPage3Service)、FR-VFTF(FirstReady,VirtualFinishTimeFirst)等,FR-FCFS,即从请求的就绪队列的队头中获取内存请求,该算法有效地减少了内存控制器在获得内存请求后的就绪等待时间,但是该算法可能引起部分请求等待过长[13].FR-VFTF算法和FR-FCFS存在细微区别,主要是因为FR-VFTF需要估算内存访问请求的虚拟结束时间,优先执行就绪队列中最早结束的访问请求.2.3.3基于替换策略系列调度算法在前面的内存存储体系结构中,Cache容量尽管受限,但是对存储系统的性能却有着不可忽略的作用.因此很多调度算法重点考虑了私有Cache和共享Cache的存储情况[13],提高Cache的命中率,即对一些进入Cache的数据行优先考虑,具体的现行基于替换策略的算法主要有按顺序、优先级、行打开、行关闭、最多等待、最少等待等[14-15].2.3.4基于FQ系列调度算法在前面的多核调度算法中,都较为关注系统的吞吐率,但是对系统的线程级别的延迟并未量化,调度算法中还出现了一部分以公平策略为核心的调度算法[16-17],其中主要体现在各个请求的延迟均等或各个线程访问延迟一致,当然该类算法对系统的性能也有一定影响,一般体现在系统的吞吐率有所下降,不同算法在性能和公平性上侧重点略微不同.FQ(FairQueue)算法以FQ-VFTF[13](FairQueue,VirtualFinishTimeFirst)最为典型,即从就绪队列的头部选择最早完成的请求执行调度.需要注意的是,该算法的最早完成时间使用虚拟完成时间进行估算,各个CPU等比例使用内存.在调度的过程中,尽量使各个CPU发出的各个请求延迟在统计意义上均等,同时始终保证在任何时刻,各个CPU得到的服务仅和当前的请求现状有关,而和历史上的请求没有关系.3多核调度模型实际中,在很多情况下,调度算法需要为应用程序提供较高的吞吐率,但是还需要保证提供QoS(QualityofService).在网络中,曾经有FairQueue的概念,在多核内存调度领域中,尽管引入了该思想,但是算法大都基于请求来考虑.另外,目前的多核调度算法的研究大都从传统算法进行构造,然后使用模拟器反复验证.实际上,作为一个多核调度问题,完全可以将其抽象成一个具体的数学模型,从而通过使用数学模型的求解方法直接求解出高效的多核调度算法.3.1模型假设由于实际中内存时序相对较为复杂,不利于进行实际中的抽象建模并分析,因此在本次研究中,以简化的DDR2时序为背景做出一定的模型假设来进行理论建模分析,鉴于研究需要,参考文献[13]对模型先做出如下假设:(1)内存的物理结构和上文中描述的一致,即主要包括Channel、Rank、Bank、Row、Col,并且允许在Bank上进行并行调度,其中Bank和Channel调度器的调度算法可以不一致.(2)同一个进程或线程的请求需要按序完成,即一个线程的第k个内存访问请求必须建立在第k-1个请求已经完成的基础上,该假设主要是为了保证CPU执行指令的线程级有序性.(3)内存控制器可以通过请求直接获得该请求对应的CPU、线程、请求发起时间、优先级等,在后文中也称为贴标签.(4)内存访问请求有序进入内存请求的队列,内存控制器可以自由地执行队列中的任意请求,同时执行完毕时将数据返回到Cache,然后通知CPU访问该数据.(5)内存调度关注的是目前通用的调度场景下的情形,忽略了各种特殊应用场景下的其它时序和延迟要求.例如在一些嵌入式系统中,对实时性要求相对较高,而对吞吐率却并不严格,此种情况未予以考虑.3.2符号约定为了后面描述模型的方便,需要对Bank、Chan-nel等时间进行符号化约定,因此对访问的队列也进行符号化约定,此外还对描述模型所需的符号进行了初步约定,具体如表1所示.符号NcpuCPU个数Nthread线程个数Nirequest线程i的请求个数i第i个Channel对应的Bank数目NbankNchannel内存系统的Channel数目i第i个线程的第k个内存请求mki第mkaki第mkLktRCD内存的行寻址到列寻址延迟时间tRP内存行地址控制器预充电时间tRFC内存的行刷新周期时间tRAS一个行地址从激活到复位的时间Page4符号Bjl.Lki第mkBjl.SkiBjl.Fkii第mkCl.Lki第mkCl.Ski第mkCl.FktCLtWLtWR3.3多核调度优化模型根据前面的介绍,目前的主流算法大都关注了吞吐率和公平性,实际中这两个评价指标也足以概括当前的主流调度算法.表2对模型使用的符号做了进一步的补充说明.符号λ1吞吐率的加权系数λ2公平性的加权系数F公平性,其中该值越大越好T吞吐率,其中该值越大越好Wtotal.mkWready.mkWqueue.mkWbank.mkWchannel.mki第mkl.mkSj使用层次分析法的建模方法,得到最优化模型,模型以吞吐率和公平性为目标函数,满足内存访问和调度的一些时序约束.综合上文描述,具体模型如下所示:s.t.F=minT=∑Nthread,NiLki=Bj3.4模型验证及其说明首先对上述模型的合理性进行解释说明,F和T分别概括了多核内存调度算法的公平性指标和吞吐率指标.在此处,吞吐率使用了在一个周期内完成的有效的访问时间数和总的请求访问时间总数之比.为了使上述目标加权平均值最大化,调度算法一方面需要尽量提高内存请求的访问速率,保证吞吐率;另一方面控制来自不同处理器的访问请求的等待时间应当尽量均匀,从而保证公平性.模型对内存访问的细微时序没有直接给出约束的表达式,这是因为内部实现对于不同的物理结构可能不一致,实际中主要包括访问的Bank的行是否命中时需要的等待时间、行刷新时间、行充电、激活时间等,不同硬件存在不同约束,因而没有直接给出明确的约束条件,另外在等待时间上被细分成了就绪前等待时间、队列中等待进入Bank队列的时间、Bank中等待时间、Channel中等待时间等,因此方程(6)、(9)分别给出了Bank、Channel对请求的服务开始和结束时间约束.3.4.1参数设置3.4.1.1模型加权系数从前面的模型中可以看出,模型的目标函数中包括公平性和吞吐率两个指标,在公平性和吞吐率两个指标的计算上可以看出两者模式基本一致,并且已经包括了归一化过程.现对模型的加权系数λ1和λ2增加一致性约束条件,即对于不同的应用场景,用户可以通过配置不同的λ1、λ2来表明对不同策略的侧重性.当λ1=1时,表示系统唯独关心各个请求的公平性,即模型的结果会尽量使各个请求的等待时间相对访问时间均等;同理,当λ2=1时,系统仅关心系统的吞吐率,此时系统会尽量减少将被执行的请求的等待时间,如优先发长度较长或访问频率较高的请求等,而实际中,如果对此没有过多的侧重,可以将λ1、λ2设置相当即可,否则按照具体需要实际配置即可.Page53.4.1.2模型度量周期在模型中,细化思考即可知道,调度可能发生在任意时刻,而上述模型的计算需要一定的参考周期,即考虑一个多大范围内的内存访问请求的公平性和系统吞吐率.总体上说,调度周期主要为:调度的实际队列、一个测试周期T、从开机至调度时刻,其中最后一种方式充分利用了调度的历史消息,同时被评价的请求可以限制是当前尚未运行结束的线程发出的访问请求,从而防止因为过多不相关的历史流量带来的持续影响,本文使用该策略.3.4.2模型验证调研发现,在目前的FCFS、FQ系列算法中,均以吞吐率和公平性为指标[18],其中吞吐率在优化中更为常见,本文中的模型通过最小化评测周期内各请求中最大的等待时间所占比例,来保证各个请求的等待时间尽量均等.同时,通过计算各个线程完成的传送量和需求量之比来表示评测周期内系统的吞吐率,通过将其最大化,有效地提高系统的吞吐率.因此,模型的优化目标概括了调度算法的主要性能指标.该模型有效地将计算机内存调度问题抽象为一个数学建模问题,从而将对调度算法的研究转化为求解模型,此时用于求解模型的一些方法均可以借鉴到该数学模型中,其中包括求解复杂模型的启发式算法.也可以通过计算机模拟的方法求解本模型,当然具体的构造方法依赖于具体问题.下一节中,将对模型进行求解.3.5模型改进在此模型中,对预取没有详细的说明和约束.实际中,合理地使用预取甚至分段技术[19-20]能够极大提高多核性能,同时也可以有效地减少访问的延迟.另外,硬件的Cache架构、容量也会对内存系统性能产生较大影响[21].在本文的研究中,我们在同等条件下进行比较,忽略了硬件带来的影响.在本模型中,主要是在请求和线程的角度进行优化.实际上,在必要的场合,我们更期待CPU的利用率更高,因此从CPU的角度进行量化和评价将产生更好的结果.调度的复杂性也在一定程度上得到减弱.另外,当前的模型没有考虑优先级和实时性等问题,因此改进空间仍旧非常大.4模型求解与验证4.1算法提出从第3节中介绍的模型可以知道,为了获得模型的较优解,在减少每个请求的访问时间的同时需要关注各个请求、CPU、线程的平均延迟情况,这是因为请求的延迟相差较大将影响调度的公平性.4.2内存控制器在对内存控制器结构进行阐述之前,首先简要描述一下内存控制器的作用,从前文描述可以知道,内存控制器主要完成的是维护内存请求队列,同时从队列中选择合适的请求交由下层硬件执行,因此控制器的一个重要功能即为调度和决策.为了完成该项任务,内存控制器需要一定的存储空间来缓存上层的内存访问请求.另外,在前文介绍的内存体系结构中,已经说明了内存的Row、Bank、Rank、Channel内部层次关系,因此内存控制器同样需要完成Row、Bank、Rank、Channel级别的调度控制,为了设计简单,在各个调度器中使用的算法均一致.从图1可以看出,相比文献[13]的内核控制器结构,该内存控制器中存在“内存访问请求缓冲+综合调度”区,进入该区域的请求已经被贴上了时序、CPU、线程的标签.在实现时,该区域被循环使用,为了控制方便,使用了链表进行组织.该区域的大小对系统的性能存在一定的影响,这是因为如果该区域填充满后,CPU将出现空闲等待.调度算法的主要工作在于综合调度,然后将要执行的内存访问请求交由Bank调度器对应执行,Bank执行完毕后由Channel完成最终的数据传输,在图中除了“Cache行缓冲区”上的数据总线外,其余总线均为控制总线.此外,在图1中没有明确区分读写请求.Page6另外,需要注意的是,在内存控制器中也没有详细介绍SDRAM数据总线和地址总线,实际上由Channel调度控制器管理的地址总线还需注意时序问题.在图1中,可以看出,和处理器的数据交互均通过Cache的行缓冲区来完成.4.3算法描述根据前面的模型介绍,利用启发式算法,同时参考现有的一些算法,通过综合考虑优先级等因素,利用模型可以构造出如下算法1.算法1.FQ-SJF.1.若存在优先级不等的请求,则选择优先级最高的请求;否则转步2;2.在定义公平性指标下,找到最不公平的访问请求,若其指标在容忍区间内则转步3;否则执行该次访问;3.从队列头部找到数据已经在Cache的行缓冲区的请求,执行该请求;否则转入步4;4.从队列中选取一个所需执行时间最短请求.对于调度算法,若行缓冲区较大,则还存在较为关键的一项决策,即替换问题,需要选择一行用于新的内存请求换入.从以前的研究情况来看,LRU算法在换出方面具有较好的性能,因此在本算法中,选取替换最长时间未被使用的行.4.4仿真测试使用M5模拟器对该内存调度系统进行测试,其中开发测试的环境架构主要为:在WindowsXP上运行VMware7.0虚拟机,然后在VM中运行ubuntu,进而在ubuntu中运行M5模拟器并采集Trace.模拟器的参数和真机环境具体介绍如表3所示.属性CPU主频内存/外存缓存系统真机参数单核2GHz2GB/250GB4MBXP5.1.2600虚拟机VM参数2GHz512MB/20GB缺省VM7.0M5参数4核2GHz128MB/无限制缺省M5.opt2.0整体上使用M5模拟器,但是实际中,为了保证测试的数据Trace始终一致,在初次测试的同时,将请求队列中的Trace保存下来,测试其它算法时直接使用Trace作为调度对象,然后计算出性能评价所需的关键结果等.其中上层运行的基准应用为SPEC2000,通过该方案,有效提高了测试的速率,同时保证了各个算法测试的数据的一致性.下面对单一应用的Trace进行简单的分析,并且针对各算法进行一个初步的比较和运算,在本次测试中,采集和测试的Trace主要包括如下几个:gcc、mcf、sphinx、astar、bzip2、crafty、gap、gzip、h264ref、soplex、vortex、vpr等,首先选择gcc应用作为研究对象进行简要的Trace分析.首先查看Trace的抵达时刻和次序关系,前300000个访问请求的抵达时刻分析图如图2所示,从图中可以看出,该应用的Trace到达时刻较为均匀,并且和次序呈线性关系,由于数据较多,放大前30000个Trace分析,其次序如图3所示,从图中可以看出Trace仍旧具有较好的线性时序关系.需要指出的是,该Trace没有区分指令和数据Trace,而是混合在一起进行测试.其中读请求共268840个,写请求31160个.下面将分别介绍FR-FCFS和FQ-SJF算法的运行结果,由前面的Trace分析结果可以看出,整个过程中内存请求间隔较为均匀,因此下文主要针对前30000个访问请求的Trace进行调度模拟分析.评测指标选用平均访问延迟,并选取FR-FCFS的前30000个访问请求的平均访问延迟作为归一化的参考值,针对每相邻的100个请求取平均访问延迟,归一化后绘制平均访问延迟图例.Page7在图4中描述了负载较小时,两种调度算法对gcc的内存访问请求的处理延迟大体一致,表明算法在轻负载时表现较优.而随着负载增加,在图5、图6中可以看出较重负载时,FQ-SJF算法的读取延迟均要比FR-FCFS小,性能上提高了接近10%,并且随着负载增加,提升空间越大.当然,随着负载的增加,会受到总线等限制,访问延迟也会极大增加.图4gcc基准FR-FCFS和FQ-SJF平均读取延迟图5vortex基准FR-FCFS和FQ-SJF平均读取延迟图6gap基准FR-FCFS和FQ-SJF平均读取延迟图7gzip和vpr混合内存访问平均读取延迟图7展示了在多个测试基准混合运行时的平均读取延迟分析图.从图中可以看出,测试结果表现较优,性能得到提升.一些其它基准的测试结果如表4所示,FQ-SJF相对FR-FCFS的平均读取延迟同样减小了许多,单个soplex基准平均访问延迟减小了10.6%,在多个基准的同等混合性能测试中,延迟减小了6.1%.测试基准加速比减少延迟/%测试基准加速比减少延迟/%vortex1.0524.9astar1.1019.2soplex1.11810.6gcc1.0000h264ref1.1029.3bzip21.17614.9gap1.0646.0gzip,vpr1.0656.14.5算法改进算法上,FQ-SJF仅为模型的一个普通解,通过进一步求解,将可以获得性能更佳的调度算法,从Trace分析来看,到达时刻和次序基本呈现线性关系,另外,在负载较高时,FQ-SJF性能会降低,同时调度开销相对较大,因此此处可以通过改进FQ-SJF,使得在必要时将FQ-SJF退化为FR-FCFS算法,此时内存控制器的调度开销将大为减小.在内存控制器一节已经提到,对于Bank和Channel的调度直接和核心调度算法一致.实际上,在Bank级别和Channel级别可以做出一些改进,也可以引入对Cache行的刷新和替换控制,从而加速特定的基准应用.另外,部分系统可能对实时性存在要求,此时算法需要综合权衡各大指标,并将优先级高的请求优先调度.需要特别指出的是,复杂的调度算法常常伴随着增加了内核控制器内部实现该算法的复杂性.Page85结论本文提出了一个多核间内存调度模型,该模型将多核调度的实际问题直接转化为一个数学模型中的优化问题,从而在构造算法时可以参照数学模型,求解的方法快速衍生出高效合理的内存调度算法,并对模型进行了初步的求解验证,得到了一个模型解.从测试结果上看,相比传统的FR-FCFS算法,系统吞吐率和延迟均有较大改善.致谢本文作者得到了清华大学计算机科学与技术系操作系统实验室的老师和同学们的许多帮助和建议,在此表示感谢!
