Page1基于递推链代数与迭代序列敛散性的死循环检测姬秀娟杨巨峰许静李晓虹封磊(南开大学计算机与控制工程学院天津300071)摘要该文针对两大类循环分别给出了非终止性判定的数学方法.首先,针对基本迭代关系为线性或几何性的循环提出了基于递推链代数的分析方法.通过递推链代数将循环变量进行统一表示,根据运算规则推导出循环条件关于迭代次数的闭形式函数,然后通过约束求解以及单调性判断循环的非终止性.其次,针对一元非线性循环提出了基于迭代序列敛散性的分析方法.根据迭代函数以及不动点判断迭代函数产生的迭代序列的敛散性来判断循环的非终止性.实验部分采用Velroyen[20]的52组循环、文献[18-19,21-23]的23组循环、文献[3]以及自组的13组循环进行分析验证,结果表明该文所提出的方法能有效地判断循环的非终止性:若循环无法终止,可以推导出循环无法终止的变量约束;若循环可终止,则可以估算循环的迭代次数.关键词死循环检测;静态分析;递推链代数;迭代函数收敛性;软件工程1引言随着软件系统规模和作用不断扩大,如何保证软件的正确性受到越来越多的重视.正确的程序必须是终止的,因此程序终止性作为软件正确性的一个重要组成部分,一直以来都是软件研究中的关键问题,学者们已经开展了大量研究工作.程序终止性问题可以归结为停机问题,根据图灵的理论可知,程序的停机性证明是一个不可判定性问题,从而必不存在一种通用的终止性判定方法.即使循环体中所有赋值语句都是线性形式,它的停机性问题仍然是不可判定性的.对于存在多路径和循环嵌套的循环程序,验证它们的停机性更加困难.但是并非所有程序的终止性都无法判断.事实上,针对很多实际程序而言,可以通过严格的数学方法分析程序的终止性.程序无法终止是软件非常严重的故障,导致程序无法终止的原因有多种,如死锁、递归以及死循环等,其中循环结构是影响程序终止性的一大原因.因此,死循环检测是程序终止性分析的重点.采用有限的测试用例很难判断循环是否无法终止.因此,目前循环终止性的研究工作主要采用理论分析的方法.关于循环终止性检测的一种研究是将循环问题分类,针对性质较好的类给出判定方法,如Tiwari[1]针对简单线性程序提出了根据赋值矩阵的特征向量进行终止性判定的方法.但是在实际应用程序中,规整的线性程序比例很小.因此一些研究[2]通过线性变换、引入新变量等方法,将程序转换成对应的简单线性程序.但是转换过程往往非常复杂甚至不可行,这一类方法适用范围较小.姚勇[3]针对单重While非线性循环程序提出了基于不动点的判定方法,但是循环体中只能包含一个变量,因此适用性也受到了较大限制.目前许多研究是基于经典的Ranking函数方法[4].Ranking函数本质思想是证明程序的迁移关系是一个良基关系.将程序状态通过Ranking函数映射到良序集,根据Ramsey选择公理,良基域中不可能存在无穷递减的序列.故可断定程序不存在无穷的程序状态序列,从而证明程序是终止的.基于Ranking函数方法[5-16]的研究成果非常多,但没有本质上的变化.Ranking函数方法证明过程简单.但其局限性也非常明显.有的程序根本没有Ranking函数;或者即使存在,但找到Ranking函数的过程非常困难.基于SCT(Size-ChangeTermination)[17]的方法类似于Ranking函数方法.通过证明程序的每个计算都将导致某个有最小值的数据值递减来验证其终止性.但Size-change图的生成复杂且不存在统一算法.针对具体的程序,生成的Size-change图可能呈指数增加.基于计数器的方法[18-19]也是循环终止性分析的一种方法.该方法的关键是在循环体内找到设置计数器的位置,并且为每个循环确定一个合适的中间断言.综上所述,目前关于循环的终止性研究多集中于证明程序最终是终止的,而本文研究是设法找到导致循环无法终止的情况,尽可能找出循环无法终止的变量约束.如果判断循环是终止的,通过迭代关系计算循环次数.针对比较复杂的情况,本文采用了部分近似求解,因此不是针对所有的循环都可以给出精确的结果.本文针对两种类型循环给出了非终止性的数学判定方法.首先针对基本迭代关系为线性或几何性以及在它们基础上的多项式运算的循环,通过递推链代数将循环条件中所有变量统一表示,运用相应运算规则推导出循环条件关于循环迭代次数的闭形式函数;每个循环的分析结果保存为循环摘要,用于嵌套循环分析;在此基础上判断循环迭代结果是否越来越“远离”循环出口条件.使用该方法对Velroyen[20]的52组循环以及文献[18-19,21-23]的23组循环进行分析验证,不仅可以有效地检测出循环的非终止性,还可以给出导致循环无法终止的变量约束区间.其次,针对一元非线性循环提出了根据迭代序列敛散性判断循环非终止性的分析方法.使用该方法对文献[3]以及自组的13组循环进行分析验证,结果表明它可有效地分析循环的非终止性.2基于递推链代数的While循环分析定义1.在循环体的每次迭代中增加或者减少固定数值,或者与循环迭代次数存在一定的数学解析关系的变量为循环归纳变量,本文简称循环变量.V=v1,v2,…,vn为循环变量全集,vi为循环变量(i=1,2,…,n).定义2.L为循环迭代次数,即L∈N,N表示自然数.EXP(X|XV)∈Ω表示循环条件,EXP(X)表示由部分或全部循环变量构成的循环条件表达式.EXP(X)L表示EXP(X)的第L次迭代结果.Page3While循环可简单描述为:WhileEXP(X|XV)∈Ωdo{循环体}.当循环条件一直被满足,循环体不断被执行,即可认为出现死循环.只要X0(X0为循环变量X的初值),循环体迭代任意次后,循环条件仍满足,即可判断该循环无法终止.定义3.死循环模式为M_InfiniteLoop={X0,L,EXP(X0)L∈Ω|XV,L∈N}.即存在某些循环变量X0迭代任意L次后其循环条件表达式EXP(X0)L仍属于Ω区间,或者说随着循环迭代次数L的增加,循环迭代产生的结果越来越“远离”循环出口条件,那么即可认为该循环无法终止.循环变量X迭代L次后,EXP(X)和迭代次数L的关系可采用递推链代数进行推导和求解.2.1递推链代数本部分将详细介绍循环分析的基础框架递推链代数.递推链(ChainsofRecurrences,CR)[24]记号体系与代数规则最初由Zima提出.利用数学格相邻结点之间的递推关系计算某个函数的值,主要是为了减轻在某个区间内部一系列有规律的点上该函数的计算代价.由于While循环第L次迭代结果由第L-1次迭代结果和循环体赋值函数确定.因此,CR形式适于表示循环变量在相邻迭代次数之间的递推关系.下面通过递推链代数对所有循环变量进行统一符号表示,按照递推规则推导出EXP(X)L与迭代次数L的关系.一个基本的CR形式可表示为ΦL={φ0,⊙,f1}L,φ0为初值,⊙为“+”或“”算子,f1为递归步长函数.CR形式表示了从初始值φ0开始,每次迭代都在当前值加上(⊙=+)或者乘以(⊙=)步长函数f1.例如如下简单循环:whilex>1do关于循环变量x,用CR形式表示为xL={x0,+,1}L.x0为循环变量初值,迭代步长为1,迭代算子为“+”,即第L次迭代结果是在第L-1次迭代结果基础上加1,根据CR逆规则(CR-1)可推导出循环变量迭代L次后的结果为x0+L.如果迭代步长f1不是常数,而是另外一个CR形式,则可以表示为ΦL={φ0,⊙1,{φ1,⊙2,{φ2,…,⊙k,{φk}L}L}L}L,通常可写成其平坦形式为ΦL={φ0,⊙1,φ1,⊙2,…,⊙k,φk}L.例如如下循环:whilex+y>10do{x=x-1;循环变量x的迭代关系是基本的CR形式,即xL={x0,+,-1}L,而循环变量y每次迭代的步长不是一个常数,而是关于变量x的CR形式,因此它的CR形式为yL={y0,+,2{x0,+,-1}},其平坦形式为yL={y0,+,2x0,+,-2}.上述例子中循环变量较少,且迭代步长比较简单,所以其迭代L次结果比较容易计算.若循环体中包含多个循环变量,很难直接推断出它们与迭代次数L的关系.但是通过递推链代数,对循环体中的循环变量进行统一表示和符号操作,经过相应的运算规则可将循环条件表达式最后表示成一个CR形式,进而利用CR代数系统中运算、简化和逆运算等规则推导出循环条件EXP(X)L关于迭代次数L的闭形式函数.根据循环体是否嵌套循环,可以将循环分为单重While循环和多重While循环.前者即循环体中没有嵌套循环;后者循环体中嵌套一层或多层循环.此外,循环体内可能包含多条路径,即对循环变量进行条件更新,本文简称为包含分支的循环.下面分别针对单重循环以及多重循环给出了分析方法.每个单重循环分析结束都将产生循环摘要(Loopsum-mary),用于多重循环分析.2.2单重While循环分析对于单重While循环,本节将针对不含分支路径、含有分支路径、循环变量初值确定以及循环变量初值不确定的情况分别分析.况,可描述为:最简单的单重While循环为不包含分支的情whileEXP(X)∈Ωdo{V··=V⊙f}V=x1,x2,…,xn为循环变量全集,XV为部分或全部循环变量,EXP(X)为循环条件中关于循环变量X的表达式,Ω为一个区间,循环体中通过V··=V⊙f对循环变量进行迭代重定义.f为变量或常数,⊙为“+”或“”算子,“-”和“/”运算可以转换为“+”或“”算子.对于此类循环,因为不包含分支,因此只要收集循环体中所有循环变量V的迭代关系,并根据其迭代关系统一表示为CR形式,根据CR运算或化简规则推导出循环条件表达式EXP(X)的CR形式,然后可求得EXP(X)L关于循环迭代次数L的函数.最后结合约束求解器以及其单调性即可判断EXP(X)L是否超越Ω区间,从而判断循环的非终止性.下面程序片段源于文献[18].Page4whilexydo{x=x+1;由此可知,循环变量V={x,y},循环条件为xy,将其转换为x-y0,那么EXP(X)=x-y,Ω=[0,+).x的CR形式为{x0,+,1}L,变量y的迭代步长是x的CR形式,即变量y的第L次迭代结果取决于yL-1与xL,即yL=yL-1+xL.因此y的CR形式为{y0,+,{x0,+,1}L}L,其平坦形式为{y0,+,x0,+,1}L.运用CR运算规则计算,xL=x0+L,yL=y0+x0×L+(L2+L)/2,由此可知EXP(X)L=(x-y)L=xL-yL=-L2/2+(1/2-x0)L+x0-y0.由此可知,随着L逐渐递增,必有xL-yL<0,因此该循环无论x与y取任何初值都将终止.2.2.1循环体内包含分支路径程序中的循环多数都包含有分支,即循环体内存在多条可执行的路径.While循环若包含m个分支,可描述为:whileEXP(X)∈Ωdoc1→p1:X··=X⊙f1;c2→p2:X··=X⊙f2;…cm→pm:X··=X⊙fm;c1…cm为每个分支路径的约束条件,p1…pm为该约束条件满足时所执行的路径,X··=X⊙fm为该路径对循环变量X的迭代关系.对于包含分支的循环,本文采用基于路径的分析方法.要考虑所有分支路径的组合关系,即不同路径可能交替执行,因此产生死循环的机率大大增加.针对上述包含m个分支路径的循环,可能出现的死循环路径为(p+1p+2…p+m)(其中,符号“+”表示0次或有限次重复,“1+”表示1次或有限次重复,“”表示无限次重复).具体的分析方法如下:假设p1…pm分别迭代的次数为L1…Lm,整个循环的迭代次数为L.首先基于每条路径p1…pm收集关于循环变量X的迭代关系,对其采用CR进行统一表示并求其关于迭代次数L1…Lm的闭形式函数.然后依次将p1的闭形式函数作为初值代入p2路径的CR形式,将p2的闭形式函数作为初值代入p3,依次类推,可求得(p+1p+2…p+m)关于L1…Lm的闭形式函数.然后分别根据L1…Lm的情况考虑可能出现的所有死循环情况.下面程序片段源于VelroyenBenchmarks[20],其控制流图CFG(ControlFlowGraph)如图1所示.alternDiv(inti){while(i!=0){if(i<0){else{}}该循环包含一个分支,即两条路径p1与p2,当i<0时,沿着路径p1执行,当i>0时沿着路径p2执行.分别收集路径p1与p2的迭代关系并采用递推链求解,假设p1路径迭代L1次,p2路径迭代L2次,可能出现死循环的4种路径模式为p1,p2,(p1+与(p1+2p1+根据分析,当i0<0时,首先沿着路径p1执行,迭代结果的闭形式函数为iL1=-i0+L1,迭代一次之后不再满足iL1<0,因此不存在p1的死循环路径模式.同理,不存在p2的死循环路径模式.对于(p1+2)来说,当i0<0时,首先执行路径p1,再执1p1+行路径p2,迭代L次的结果为i0-L1-L2(L=L1+L2),由于L1与L2都大于0,因此iL将永远满足iL<0,因此将陷入死循环.同理,对于(p1+i0>0先执行路径p2,再执行路径p1,迭代L次的结果为i0+L1+L2(L=L1+L2),由于L1与L2都大于0,因此iL将永远满足iL>0,因此将陷入死循环.2.2.2循环变量初值确定通过递推链代数将循环表达式转换成迭代次数L的闭形式函数后,如果已知循环变量的初值,可以Page5判断循环是否终止.若判断循环是终止的,可以根据闭形式函数估算循环执行次数.例如如下循环:i=0;j=3;m=2;whilei2+j-m>0do{i++;其中循环变量V={i,j,m},EXP(X)=i2+j-m,Ω为区间(0,+),循环体中通过i=i+1;j=j+2;m=m2分别对循环变量i,j和m进行迭代重定义.首先将变量i,j和m统一表示成CR形式,即Φi={0,+,1}L,Φj={3,+,2}L,Φm={2,,2}L.然后按照CR运算规则计算Φi2+j-m的CR形式.计算过程如下:Φi2+j-m=ΦiΦi+Φj-Φm={0,+,1}L{0,+,1}L+{3,+,2}L-{2,,2}L={0,+,1,+,2}L+{3,+,2}L-{2,,2}L={3,+,3,+,2}L-{2,,2}L.根据CR-1求逆规则,其闭形式函数:L2+2L+3-2L.由此可知,循环表达式EXP(i2+j-m)L关于迭代次数L的闭形式函数为L2+2L+3-2L.因此循环约束条件即可转换为L2+2L+3-2L>0.当L2+2L+3<2L时即退出循环,由此可计算循环迭代5次之后,即L=6时循环约束条件不满足,即退出循环.目前,静态分析技术为了简化分析复杂度以及减少路径数目,对循环的处理多是指定循环次数,一般采用循环迭代1次.这样显然会降低分析的准确度,尤其是与循环迭代次数相关性比较大的属性分析,如内存故障类型中的内存溢出和内存重复释放.采用上述递推链代数可估算循环迭代次数,对提高静态分析时的精度有很重要的意义.2.2.3循环变量为待输入值当循环变量初值不是某个具体值,而是函数中的一些形参或者符号值时,根据递推链代数可以推导出循环变量关于迭代次数L的闭形式函数,从而可一定程度上了解导致循环无法终止的变量关系.如下程序来源于VelroyenBenchmarks[20]:Middle(inti,intj){while(i!=j){i--;首先假设i0和j0为变量i和j的符号值,分别写出循环变量i和j的递推链形式,然后根据递推链运算规则计算EXP(i-j)L的闭形式函数.其计算过程如下:Φi-j=Φi-Φj={i0,+,-1}L-{j0,+,1}L由此可知,循环条件i!=j可转换为(i0-j0)-2L≠0,即当输入值i0和j0满足(i0-j0)≠2L时循环将无法终止.2.3多重While循环分析多重While循环结构比较复杂,由于其各层循环均可修改归纳变量,同时归纳变量的重定义对各层循环的迭代次数也会造成影响,因此本文提出循环摘要(Loopsummary)记录每个循环的分析结果,从而用于多重While循环分析.定义4.Loopsummary可描述为如下四元组:其中,V为循环变量;V0为循环变量V的初值;fV为循环变量V的递推关系;CR_V为循环变量V的CR形式.多重循环的分析过程如下:(1)首先自顶向下分析各层循环,收集各层循环变量V、它们的初始值V0以及循环体内V的递推关系fV;(2)再自底向上分析各层循环,并计算各个变量V的CR_V;(3)根据CR-1规则计算Φexp(X)(XV).例如如下循环:x1=a;x2=b;y1=c;y2=d;A:whileEXP(X)doB:whileEXP(Y)do由程序可知,循环A嵌套循环B,因此:(1)自顶向下分析循环A,收集循环变量信息,得到的信息为(x1,a,fx1,NULL)与(x2,b,fx2,NULL).分析循环B,得到如下信息:(y1,c,fy1,NULL)与(y2,d,fy2,NULL).(2)自底向上分析循环B,计算闭形式函数,完善元素(y1,c,fy1,CR_y1)、元素(y2,d,fy2,CR_y2);再分析循环A,完善元素x1(x1,a,fx1,CR_x1)、元素x2(x2,b,fx2,CR_x2).(3)根据CR_y1和CR_y2计算EXP(Y)关于迭代次数L的闭Page6形式函数;根据CR_x1和CR_x2计算EXP(X)关于迭代次数L的闭形式函数.3一元非线性循环非终止性判定如果迭代函数是一元多阶或者其他形式的非线性迭代关系,采用递推链代数有些困难.因此特别针对一元非线性循环提出了基于迭代序列敛散性的非终止性判定方法.一元非线性循环可描述为whilex∈Ωdox=f(x).f(x)为一元多阶或其他形式的非线性函数.定义5.对于给定初值x0∈Ω,反复作用于同一个函数,x1=f(x0),x2=f(x1),…,xL=f(xL-1),从而迭代生成一个序列{xL}.其中f(x)称为迭代函数,xL=f(xL-1)称为迭代关系,L=1,2,….迭代过程中,xL+1由xL和初值x0决定.迭代序列是否收敛以及收敛速度取决于迭代函数f(x)和初值x0.迭代函数的收敛性很难用统一的方法进行判断.下面分别对迭代函数加以不同的限制给出了循环非终止性判定的4个规则.3.1闭区间上自映射迭代函数的收敛性如果迭代函数f(x)是闭区间[a,b]上的自映射连续函数,即x∈[a,b],f(x)∈[a,b],则该迭代函数产生的迭代序列永远在区间[a,b]内,此时该循环一定无法终止.规则1.若迭代函数f(x)是区间[a,b]上的连续函数且存在唯一不动点x#,f(x)在[a,b]内可导,|f(x)|<1,则f(x)是区间[a,b]上的自映射连续函数.证明.设ψ(x)=x-f(x),由于x#是迭代函数f(x)在[a,b]上的唯一不动点,即x#=f(x#),因此ψ(x#)=x-f(x#)=0,即x#是ψ(x)=x-f(x)在区间[a,b]上的唯一解,由于f(x)在[a,b]内可导且|f(x)|<1,因此ψ(x)=1-f(x)>0,即ψ(x)在[a,b]上递增且存在唯一解x#,则ψ(a)=a-f(a)0,ψ(b)=b-f(b)0.由于ψ(x)=x-f(x)在区间[a,b]上递增,在x#有零点,因此x∈[a,x#],ψ(x)=x-f(x)0,则xf(x),由此可得af(x).x∈[x#,b],则ψ(x)=x-f(x)0,则f(x)x,由此可得f(x)b.所以x∈[a,b],f(x)∈[a,b],f(x)为[a,b]上的自映射连续函数.实例:while1x2dox=2+槡x循环迭代函数为xL+1=2+x槡L,循环条件区间Ω为[1,2],f(x)=2+槡x.f(x)在[1,2]上存在唯一不动点x#=2,由于f(x)=1/22+槡x,x∈[1,2],f(x)<1,因此f(x)=2+槡x是区间[1,2]上的自映射函数,那么产生的迭代序列在区间[1,2],因此该循环无法终止.3.2任意区间单调性迭代函数的收敛性如果循环条件不是某个闭区间,而是任意区间Ω(-,+),迭代函数f(x)在Ω区间上具有某种单调性,且比较容易求其不动点,则可以根据迭代函数的单调性(单调递增或单调递减)来判断迭代序列的收敛性.规则2.如果迭代函数f(x)是单调递增的,计算迭代函数f(x)在区间Ω上的不动点x#,根据迭代关系求得x1与x2.如果满足x1x#且x1x2,那么迭代序列{xL}是单调递增序列且x1x2…xnx#.如果满足x1x#且x1x2,那么迭代序列{xL}是单调递减序列且x1x2…xnx#.实例:whilex1dox=4-3槡x由循环体可知循环迭代函数f(x)=4-3槡x,显然f(x)在(-,1]单调递增,且存在不动点x#=1.由迭代函数可知x1=1,x2=1;由此可知,迭代序列同时满足规则2的两种情形,即x1x2…xnx#且x1x2…xnx#,因此x#=x1=x2=…=xn=1.因此当循环变量x初值为1时循环无法终止.规则3.如果迭代函数f(x)是单调递减的,计算迭代函数f(x)在区间Ω上的不动点x#,根据迭代关系求得x1,x2与x3.如果它们之间满足x1x#且x3x1时,那么迭代序列{x2L}是单调递增数列,迭代序列{x2L+1}是单调递减数列,且x1x3…x2n+1…,x2x4…x2nx#.如果它们满足x1x#且x3x1时,那么迭代序列{x2L+1}是单调递增数列,迭代序列{x2L}是单调递减数列,且x2x4…x2nx#…,x1x3…x2n+1.3.3任意区间非单调性迭代函数的收敛性如果循环条件是任意区间Ω(-,+),但迭代函数f(x)在Ω区间上的单调性不容易判断,则可根据迭代函数f(x)的不动点进行判断.规则4.若循环迭代函数f(x)在Ω(-,+)内连续,且迭代函数f(x)存在不动点x#,如果|f(x#)|>1,则迭代序列{xL}发散;如果|f(x#)|<1,则迭代序列{xL}必收敛于x#.Page7实例:r>0;whilex>0dox=rx(r-x)由循环体可知循环迭代函数为xL+1=rxL(r-xL),循环条件区间Ω为(0,+),f(x)=rx(r-x).首先求解f(x)不动点x#,即x=rx(r-x)的解,得出x#=r2-1/r,又f(x)=r2-2rx,因此可得|f(r2-1/r)|=|2-r2|,当|2-r2|>1时,即得-1<r<1或者r>槡3或者r<槡-3,因为程序中r>0,因此当0<r<1或r>槡3时,|2-r2|>1,此时迭代序列{xL}发散.当|2-r2|<1,可求得1<r<槡3,迭代序列{xL}收敛,且收敛于r2-1/r.例如当r=槡2时,迭代数列收敛于1/槡2,且1/槡2∈Ω,因此循环将无法终止.3.4迭代函数区间分阶段单调的循环终止性判定如果迭代函数f(x)在区间Ω(-,+)不具有单调性,但是在区间Ω上分阶段内具有单调性.例如区间Ω可以分为多个区间段I1,I2,…,Ik,I1∪I2∪…∪Ik(-,+),f(x)在每个区间段I1,I2,…,Ik分别具有不同的单调性.如果f(x)在任意区间段Ij迭代收敛,则取其中某个值进行迭代产生的迭代序列仍属于该区间段Ij,此时该循环将无法终止.如果f(x)在I1,I2,…,Ik呈现周期性变化,则序列可能收敛于周期点,如果周期点仍属于区间Ω,此时该迭代序列虽然无法收敛,但是它也将无穷迭代下去,因此该循环将无法终止.表1对VelroyenBenchmarks的实验分析及对比结果编号程序名V[20]LA[25]1ex01√√√Ii0<027alternDivWide—√√Ii0<-5∨i0>52ex02√√√Ii0528alternDivWidening—√√Ii0<-5∨i0>53ex03√√√Ii0529twoFloatInterv√√√I1<i0<404ex04√√√I任何初值30upAndDownIneq√√√I0i0105ex05√√√I任何初值31whileIncrPart√√√Ii0>36ex06√√√I-5i0532upAndDown√√√I0i0107ex07√√√I任何初值33alternatingIncr√√√Ii0>08ex08√√√Ii0>034narrowKonv√√√I0i0209gauss√√√In0<035complInterv2√√√Ii0-5∨i0510Even√√√Ii0<036complInterv3√√√Ii0>5∨i0<-511Fib12lcm13Flip√√√Ii0≠0∧j0≠039moduloLower√√√In0%5=014flip2—√√Ii0>0∧j0>040complxStruc—√———15plait—√√Ii0>0∧j0>0∧k0>041whileNested√√√Ii0<1016sunset√√√Ii0=2542whileNestedOffset√√√Ii0<1017narrowing√√√I0i02043alternKonv√√———18ex09half—√√Ii0>044moduloUp19trueDiv√√√I任何初值45whileIncr20marbie1√√√Ii0>246whilePart21marbie2√√√I任何初值47whileDecr22alternDiv√√√Ii0≠048whileSingle√√√Ii0223cousot√√√I任何初值49whileBreak√√√Ii03024middle√—√Ii0-j0≠2L50doubleNeg——√Ii0<0∧j0<025whileSum——√Ii0+j0>051complInterv√—√Ii02>926collatz————4验证结果及分析本文针对两种循环进行了以下3组实验,3组样本集涵盖了各式循环结构,包括带有分支结构的循环、嵌套循环以及一元非线性循环.4.1对VelroyenBenchmarks的实验分析实验1是在Velroyen文献[20]给出的一组Benchmarks上进行分析.这组Benchmarks包括52个While循环程序,主要用于死循环检测.每个程序代码行不多,但是包含了软件中常见的各式循环结构,如分支较多的循环等.采用本文方法对该组Benchmarks分析,并与Velroyen[20]方法(表中简称V)以及张健开发的LoopAnalyzer[25](表中简称LA)进行对比,结果如表1所示.第1列为程序编号,第2列为程序名,第3、4列分别为V[20]与LA[25]工具的分析结果,第5列为本文分析结果,共包括3项:是否可判断非终止性,是否终止以及导致程序非终止的约束条件.其中“√”表示可以判断程序的非终止性,“—”表示无法判断,“”表示需要对程序进行一定的调整.I(Infi-nite)表示循环无法终止.针对无法终止的循环,后面一列给出循环无法终止的变量取值区间.F(Fi-nite)表示循环终止,后面一列相应给出循环最大迭代次数.编号程序名V[20]LA[25]本文结果52whileTruePage8表1中符号L表示迭代次数,其它符号均表示源程序中的变量名.通过对比分析表明,表中V[20]或LA[25]无法检测的程序,如14、15、18等程序,本文方法可以检测.主要是因为本文运用CR以及相应规则可推导EXP(X)的关于L的闭形式函数,因此可以比较精确地描述循环变量与迭代次数之间的关系.然后通过约束求解和单调性判断可判断循环是否终止.对于无法终止的循环,可给出导致死循环的变量约束.对于可终止的循环,可根据闭形式函数估算循环迭代次数.从表1可以看出,V[20]可以对40个程序给出判定结果,其中40个程序存在死循环,检出率为40/52≈77%.但对于唯一具有终止性的whileDecr程序却无法给出检测结果.LA[25]可以成功检测47个程序,检出率为47/52≈90%.本文的方法可以成功检测49个程序,检出率为49/52≈94%.V[20]方法是采用动态逻辑定理证明器逐步提炼不变式的方法来判断循环是否终止.由于在产生不变式时设置了50作为最大迭代次数并限制了不变式参数的复杂度,因此在具有复杂控制流或循环涉及多个变量时,V[20]方法处理起来比较困难,例如mirrorIntervand,plait与complxStruc程序.一些程序中使用了模运算与除运算(%与/)对分析也会造成困难,如ex09half.如果程序中含有非线性赋值、布尔变量或者嵌套循环都会造成该方法无法得出正确的结果.LA[25]方法基于循环展开和路径可行性分析技术,判断出程序是否存在一组测试数据能让程序在某种程度上一直执行下去.它可以处理一些控制结构复杂以及含有嵌套循环的程序.由于它是通过测试数据划分子集,因此是一种近似的判定方法.其中干扰路径的存在可能会造成死循环模式的漏报和误报.另外,该方法所采用的后端路径分析工具暂时不能处理非线性运算以及取模和整除运算,因此程序中含有这些情况的循环将无法处理.本文方法的思想是基于循环体内的每条路径,收集循环变量的递推关系,从而找出循环变量与迭代次数之间的关系,最终判断循环的非终止性.对于含有多条分支路径的循环,由于需要分析多条分支之间的交替执行,所以特别复杂的控制流结构会给分析造成一定困难.如complxStruc循环中包含5个分支,共32条路径,在判断多条路径是否存在交替执行时对约束求解要求非常高.此外对于V与LA方法都不能判断的模运算与除运算,本文做了近似处理,使其可以对whileSum以及类似的循环进行判断.在本组Benchmark中,3个工具均无法判断collatz程序,对于它能否终止至今是个尚未解决的问题.collatz程序如下:collatz(inti){while(i>1){if(i%2==0){i=i/2;}else{i=3i+1;}}}collatz中包含一个分支,即两条路径,若x为偶数,则执行路径p1:x=x/2.若x为奇数,则执行路径p2:x=3x+1.根据递推链求得的(p+1p+2)的闭形式函数为x3L2/2L1+L2,(p+2p+1)的闭形式函数为x(3L2+L2)/2L1,L1与L2分别为p1与p2循环迭代次数.针对x(3L2+L2)/2L1与x3L2/2L1+L2目前无法判断其结果是否永远大于1.4.2对自组样本集1的实验分析由于标准样本集中最多包含1个嵌套循环,且嵌套内外层循环没有数据依赖关系.因此我们补充了自组样本集的实验.自组样本集来源于文献[18-19,21-23]中给出的23组循环,结果如表2所示.第1列为程序编号,第2列为程序名;第3、4列为本文方法分析结果,其中给出了终止性以及终止时估算的迭代次数,由于结果均符号化,因此计算所得的结果可能不是正整数,表中“[]”表示取整符号,“┓”表示向上取整,以得到实际的整数.编号程序名终止性迭代次数估算/次1test1(文献[18])Fn+m-x0-y02test2(文献[18])F3test3(文献[18])F4test4(文献[18])Fm-y0,(m-n>y0-x0)5test5(文献[18])Fm+n-x0-y0-16test6(文献[18])F7test7(文献[18])F8test8(文献[19])F9test9(文献[19])F-2y0-1+2y0+12+8槡n10test10(文献[21])FmaxId-idifid()==011test11(文献[21])FPage9编号程序名终止性迭代次数估算/次12test12(文献[21])F13test13(文献[21])Fn[]m+n-n[]mm14test14(文献[21])F15test15(文献[22])F16test16(文献[22])F-2y0-1+2y0+12+8(n-x017test17(文献[22])F18test18(文献[22])F19test19(文献[23])F20test20(文献[23])F21test21(文献[23])F0,22test22(文献[23])F23test23(文献[8])F表2符号均表示源程序中的变量名.通过递推链可以精确地表示循环变量关于迭代次数的闭形式函数.因此由表2结果可见,采用本文方法估算所得的迭代次数比较精确.从准确度指标而言,对test1和test2,文献[18]的方法计算得到的循环迭代上界分别为Max(0,n-x0)+Max(0,m-y0),Max(0,n-x0)+Max(0,n-y0);test21由文献[23]的计算结果是0,对比,本文的计算结果更加精确.4.3对自组样本集2的实验分析由于前两组样本集中不包含一元非线性循环,因此为了验证一元非线性循环的分析方法,本文补充了自组样本集2.自组样本集2共包含13组循环,其中前3个循环来源于文献[3],后10组循环由本文按照实际软件可能出现的情况自行编写,其中迭代函数包括常见的非线性运算如二次、三次乘方运算、指数运算、对数运算与开方运算等,分析结果如表3所示.第1列为编号,第2列为程序名,第3、4列为本文方法分析结果,其中给出了终止性以及无法终止时的变量约束.“—”表示无法给出分析结果.由表3可看出本文方法可比较有效地分析一元非线性循环的非终止性.针对非终止性循环给出导致死循环的变量区间.但是针对可终止的循环,目前本文的方法无法估算迭代次数,这也将是未来我们的研究方向.编号程序名终止性1loop1Ix0>(1+211/2)/22loop2I3loop3I4loop4I5loop5I6loop6I7loop7I8loop8I9loop9I10loop10I11loop11F5相关研究关于程序是否终止的研究主要分为两大类,程序的终止性证明和程序的非终止性证明.程序的终止性证明设法证明程序是终止的.而程序的非终止性证明设法证明程序是无法终止的.因为终止性是软件所希望的程序行为,所以证明程序是终止的看起来更有吸引力.大部分研究都集中在这一问题上.20世纪90年代,终止性研究多集中在项重写系统的停机性问题[2],关于项重写系统至今都保持着一些非常活跃的研究团体.后来,一些研究设法将函数程序等翻译转换为项重写系统进行终止性研究,但是由于产生的项重写系统太大,造成它的终止性证明非常困难.由于程序转换过程是不完全的,有可能将本来终止的程序转换为非终止的项重写系统.不同于项重写系统,命令式程序的终止性研究主要是基于Ranking函数.最早Colon和Sipma在文献[4]中将线性Ranking函数引入到程序停机性证明中.Ranking函数方法通过Ranking函数将程序状态映射到一个良序集合,由于良序集不存在无穷递减序列,因此程序执行状态序列必定是有穷的,程序必将终止.如何构建Ranking函数是该方法的核心问题.如文献[6]主要研究了针对线性程序以及多项式程序发现Ranking函数的方法.Podelski和Rybalchenko在文献[8-9]中给出了推导线性Ranking函数的一种完备方法.DISCOVERER[26]使用一种半代数迁移系统获得目标程序的Ranking函数.但是有的程序不存在Ranking函数,即使存在,其形式也可能大相径庭.要为程序找到单一的Ranking函数非常困难,所以目前主要研究思路从Page10构造单一Ranking函数转移到构造一组Ranking函数.其中具有代表性的是微软实验室Cook等人开发的TERMINATOR[7],通过抽象解释、符号执行、分离逻辑以及模型检测技术产生一组Ranking函数从而证明程序的终止性.上述这些方法都是设法证明程序是终止的.当无法给出明确的分析结果时,至多给出可能出现问题的路径.相对于程序的终止性分析来说,设法证明程序无法终止的研究相对较少.近些年随着验证技术的发展,一些研究开始用形式化方法查找程序中的死循环.本文受上述思路的启发,设法找出循环程序中存在无限环,从而说明循环是无法终止的,并且给出循环变量输入值在哪些情况可能造成循环无法终止.这些信息在查找故障以及修复故障时是至关重要的.关于循环非终止性的研究,中国科学院的张健取得了一定的研究成果,文献[27]给出了一种能检测出简单循环无法终止的充分条件.文献[25]通过循环展开和路径可行性分析技术,生成大规模路径,然后检验路径判断是否满足死循环模式.由于它采用了近似判定方法,可能受干扰路径影响,会产生漏报,但是可以对控制流相对比较复杂的循环进行有效分析.Velroyen[20]方法采用动态逻辑定理证明器逐步提炼不变式的方法来判断循环是否无法终止.由于在产生不变式时设置了循环迭代次数(50次),并且限制了不变式参数的复杂度,因此在面对复杂控制流或循环涉及多个变量时,处理起来比较困难.本文方法是通过循环体内对循环变量的迭代操作找出循环变量与迭代次数的关系,从而证明循环产生的迭代序列是增加的、减少的或有周期变化的.Ranking函数方法是假定程序状态达到一个特定的最小值时循环终止.而本文是假定循环迭代结果越来越“远离”循环终止条件或者永远满足循环条件,从而判断循环无法终止.6总结循环的终止性验证是一个不可判定的问题.但是对于某些特定类型的循环可以给出有效的终止性验证方法,或者对循环加以限制,即可给出循环无法终止的数学验证方法.本文分别针对两大类循环给出了非终止性的数学分析方法.首先针对基本迭代关系为线性或几何性的循环提出了基于递推链代数的分析方法.其次,针对一元非线性循环提出了基于迭代序列敛散性的分析方法.针对基本迭代关系为线性或几何性的循环,如果循环无法终止,可给出循环无法终止的变量约束;如果循环可以终止,可估算循环迭代次数.针对一元非线性循环,如果循环无法终止,可给出循环无法终止的变量约束.与其他工作相比,本文的方法能够计算得到较精确的循环复杂度上界.因此未来可以将其与符号执行结合,总结循环迭代次数与循环归纳变量之间的关系,从而帮助在静态分析中对循环的处理.将来的工作主要有3个方面:(1)目前本文只是针对循环体进行分析,将来需要将其进行扩展实现对整个程序或者软件的处理.(2)针对非线性运算系统总结循环非终止性的判定方法,目前仅限于手工完成,接下来需将其自动化.(3)针对并行程序分析循环的非终止性.由于并行性需要考虑并行执行线程之间所有可能,因此进一步增加了分析的难度.
