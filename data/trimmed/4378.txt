Page1无标度网络上名字无关的紧凑路由研究唐明董1),2)刘建勋1)张国清2)杨景3)1)(湖南科技大学计算机科学与工程学院湖南湘潭411201)2)(中国科学院计算技术研究所北京100190)3)(中国移动通信研究院北京100053)摘要紧凑路由是一类可扩展路由方法,能够在使用较短路径路由的同时,大幅降低节点路由表的空间开销.为解决Internet的路由扩展问题,无标度网络上的紧凑路由最近引起了关注.然而,以往的紧凑路由方法大多是名字有关的,即必须对网络节点重新命名或编址,这对于真实网络是不太实际的.针对无标度网络提出了一种名字无关的紧凑路由方法,即不需要显式改变节点的名字,任何节点只需要知道目的节点的原始名字就可以将包送达,因此具有更好的实用性.该方法在名字有关的紧凑路由方法基础上,引入一种名字映射系统.路由过程一般分为两个阶段:先由目的节点的原始名字查询其隐藏的地址,然后根据该地址路由.为了优化路由的性能指标,选择无标度网络中度最大的部分节点作为路由用的地标,并在这些地标上均匀且分布地为所有节点建立名字到位置的映射.分析和仿真表明,该路由方法可以在无标度网络上取得很高的路由性能,与以往最优的名字无关紧凑路由方法相比,在拉伸系数和路由表大小方面都有显著提高.关键词紧凑路由;路由方法;无标度网络;名字无关;拉伸系数1引言路由是通信网络的一项基本功能.一个路由方法的好坏主要由两个指标来衡量,即节点路由表的大小和路径的质量.但这两个指标通常是互相矛盾的.传统的最短路径路由方法,保证在任何两个节点之间路由都使用最优路径,但是每个节点需要存放到所有其它节点的路由信息,路由表项数为Ω(n)(即至少与网络规模n成线性比例),n代表网络规模.当n很大时,路由表规模将成为限制网络扩展的瓶颈.以Internet为例,域间路由系统是以选择最优路径为基础的,因此核心路由表近年来急剧膨胀,路由条数目前已在30万以上①,引起的内存和计算开销大大加重了路由器的负担,使当前的Internet面临严重的扩展问题②.即使路由器硬件技术能够跟上路由表的扩张速度,由此产生的高能耗也将对网络扩展构成巨大挑战[1].因此,缩减路由表规模已经成为Internet可扩展路由的一个重要目标[2-3].紧凑路由(compactrouting)为解决Internet的路由扩展问题提供了一种候选的方案[4].紧凑路由是指产生的路由表规模为o(n)的一类路由算法(即保证路由表规模随网络规模n呈亚线性增长),能够大幅压缩路由表的空间开销.然而压缩路由表可能会引起路径的拉伸,即可能使用非最短路径路由,从而降低了路由的效率.为此,各类紧凑路由研究都旨在尽可能同时优化路由表规模和路径的质量.路径的好坏通常用拉伸系数(stretchfactor)来衡量,即实际路径相对于最短路径的拉伸程度.任何紧凑路由方法的拉伸系数可以用(a,b)来表示,指从任意节点u路由到另外一个节点v所使用的路径长度最多为ad(u,v)+b,其中d(u,v)为u和v之间的最短路径长度.如果b=0,称路由方法具有倍数型拉伸系数a.显然,a和b的值越小,拉伸系数越优.紧凑路由问题在一般的网络和特定结构的网络上都得到了广泛研究,提出了许多通用或专用的紧凑路由方法[5].已有的紧凑路由方法根据节点是否根据网络拓扑编址,而分为名字有关(name-dependent)的和名字无关(name-independent)的.前者需要根据网络拓扑对节点重新命名(或编址),节点的新名字需要嵌入拓扑信息,以便指导路由;后者指节点名字可以是任意的,路由方法仅使用节点的原始名字就可以路由成功.近年来的研究发现,包括Internet在内的许多真实网络都是无标度网络,即节点的连接度k满足幂律分布P(k)~k-γ(γ>0).为了研究在Internet这类网络拓扑上的路由扩展性,无标度网络上的紧凑路由问题最近得到关注[6-11].然而以往针对无标度网络的紧凑路由方法大都是名字有关的.名字有关的路由方法一般被认为在真实网络上不太实用,原因是需要对节点进行重新命名,并且拓扑的改变导致节点的名字也必须更新.事实上,大多数互联网路由专家认为,为了可扩展性、灵活性和移动性的需要,未来的互联网路由系统应该使用拓扑无关(亦即提供商无关)的地址[4].本文针对无标度网络提出了一种名字无关的、基于高度节点的地标路由方法———NIHDLR(Name-IndependentHighest-DegreeLandmarkRouting).NIHDLR使用的包首部长度为O(logn)③比特,取得的拉伸系数为min{(3,0),(2,d)},这意味着在任意两个节点之间路由,路径长度不超过其最短路径的3倍以及最短路径的2倍加一个增量d(d是由网络拓扑结构决定的参数).使用随机幂律图(randompower-lawgraph)理论进行分析发现,d可以取较小的常数,且本文的紧凑路由方法产生的路由表平均大小不超过珟O(n1/2)比特(珟O(f(n))是O(f(n)logcn)的缩写,c为常数).在无标度网络模型以及真实的Internet拓扑图上的仿真实验表明,①②③Page3NIHDLR的实际路径长度和路由表大小均要远低于通用的最优名字无关紧凑路由方法.2相关工作自20世纪90年代以来,许多通用的紧凑路由方法被提出,大多数是名字有关的.其中,Cowen方法[12]和TZ方法[13]是两种最具代表性的名字有关紧凑路由方法.Cowen方法是第一个将拉伸系数降至(3,0)的通用紧凑路由方法,在每个节点上产生的路由表大小为珟O(n2/3)比特.TZ方法是Cowen方法的改进,在拉伸系数等于(3,0)的情况下,节点路由表大小降为珟O(n1/2)比特.Cowen方法和TZ方法均是基于地标的,即需要使用少数节点作为路由用的地标.地标路由算法中,往往只在节点路由表中存放到邻居和所有地标的路由信息,因此如果是以这些节点为目的地,包可以沿最短路径交付,否则包将沿最短路径向离目的地最近的地标转发.如果到达该地标,将由它转交给目的节点.Cowen方法和TZ方法的区别仅在于地标选择方法的不同.前者使用贪心算法来构造图的支配集,由此得到地标集;而后者则使用一种随机化的技术来选择地标.进入21世纪以来,名字无关的紧凑路由方法开始引起关注.代表工作有Arias等人[14]提出的路由方法和Abraham等人[15]提出的路由方法.Arias方法在任意的网络上可以保证拉伸系数不超过(5,0),路由表大小不超过珟O(n1/2)比特.Abraham方法产生的拉伸系数和路由表大小分别为(3,0)和珟O(n1/2)比特,与TZ方法取得了近乎相同的理论界限.由于Gavoille和Gengler证明不存在路由方法在任意网络上使倍数型拉伸系数低于3且每个节点的路由表大小为o(n)[16].因此Abraham方法和TZ方法一样都是近乎最优的通用紧凑路由方法.上述紧凑路由方法都是针对任意拓扑结构网络的.然而,真实的网络往往呈现特定的拓扑结构特征,针对特定拓扑结构定制的紧凑路由方法往往比通用的方法具有更好的性能,包括树(tree)、平面图(planargraph)等[17-19].现实中,许多网络(包括互联网、WWW、非结构化P2P网络等)都是无标度网络[20-25].这类网络中,多数节点度很小,而少数节点度很大.这些大度节点在网络连通性和通信方面常常扮演了十分关键的角色.无标度网络(或称幂律网络)上的紧凑路由算法最近引起了许多关注.对它们的综述如下.文献[6]分析和仿真了TZ方法在幂律网络上的性能,发现在产生很小路由表的同时平均拉伸度仅为1.1左右,远低于理论上的拉伸系数(3,0).文献[10]提出了一种贪心的地标选择方法,通过实验发现在幂律网络上实际的倍数型拉伸系数不超过2.文献[11]针对无限变异幂律图(infinite-variancepower-lawrandomgraph)提出了改进的紧凑路由方法.文献[26]提出使用k-核分解的办法来选择Internet拓扑图中的核心节点作为地标,可以进一步提高紧凑路由算法在Internet拓扑图上的性能.文献[7-8]提出了具有增量型拉伸系数(1,d)的名字有关紧凑路由方法,路由表大小上限为O(elog2n)比特,实验发现在幂律网络上d和e都可以取较小的值.上述工作都没有在幂律网络上针对路由指标给出严格的理论界限.文献[9,27]使用随机幂律图理论分析了提出的紧凑路由方法的性能,证明在随机幂律图上路由表的大小具有比一般网络上低得多的上限,而拉伸系数仍为(3,0).文献[28]提出在稀疏的网络上(包括幂律网络)可以进一步将拉伸系数降至(2,0),代价是转发时间增加至珟O(n1/2).以上针对无标度网络的紧凑路由方法都是名字有关的.针对无标度网络的名字无关的紧凑路由方法尚不多见.文献[29]提出了一种名字无关的紧凑路由方法,具有拉伸系数(2,2d),其中d在随机幂律图上可以取常数,路由表平均大小不超过珟O(n1/2)比特.本文的工作通过在路由时引入握手机制(handshaking)不仅进一步优化了路由的拉伸系数上限,而且实际的路径拉伸度比[29]也有显著的降低.3NIHDLR方法3.1原理名字无关的紧凑路由方法一般是在名字有关的紧凑路由方法之上加上一个节点名字/地址映射系统.除非特别说明,本文中节点名是指节点固有的与网络拓扑无关的名字,节点地址是指重新赋予的与拓扑有关的名字.路由过程一般包含两部分:先利用名字/地址映射系统根据目的节点名查询其地址,然后利用名字有关的路由算法根据目的地址将包转发至目的节点.与名字有关路由方法相比,名字无关方法的设计更加复杂,表现在:名字无关的方法在路由时增加了查询目的节点地址的过程,而维护节点名字到地Page4址的映射则增加了节点的内存开销.一般来说,这里存在一个折中(trade-off)问题.如果每个节点都存储整个网络所有节点的名字/地址映射,那么源节点在本地就可以查询到任意目的节点的地址,不会引起额外的路径开销,但是此时每个节点需要增加珟O(n)比特的存储空间;另一方面,如果将映射表分割成n块均匀地分散到n个节点上存放,那么节点的存储开销基本上没有多少增加,但是查询目的节点地址可能需要很长的路径.上述这两种极端情况都是不可取的.映射系统的设计必须保证既不能在某些节点上占用太多的空间又必须保证查询目的地址不能引入太多的路径代价.为了平衡映射系统引起的查询路径长度和空间开销,Abraham方法[15]将节点名字/地址映射表分成槡n份,每个节点维护一份,保证每个节点附近的珟O(n1/2)个邻居拥有一份完整的节点名字/地址映射.这样保证了较小范围内就可以查询到任何目的节点的地址.Abraham方法在任意拓扑类型的网络上产生的包首部长度为O(log2n/loglogn)比特,拉伸系数为(3,0),节点的内存开销为珟O(n1/2)比特.NIHDLR方法利用了无标度网络的结构特征.在无标度网络上,少数大度节点扮演网络和路由hub的角色,多数节点与这些大度节点所形成的核心(core)直接相连或只有很少的跳数;而且大度节点之间往往也具有很小的距离[30-31].在这种情况下,如果把名字/地址映射表均匀地分散存放到这些大度节点上,而在其它节点不需要存放,直觉上,查询目的地址引起的路径开销不会太大.并且,这样做仅仅会引起少数高度节点的内存开销增大.而如果选择的高度节点足够多,比如为槡n,那么高度节点上增加的空间开销也会很小.NIHDLR方法在底层使用的名字有关的紧凑路由方法,是改编自经典的TZ方法[13],称为TZ方法.不同于TZ方法,TZ方法选择网络中的大度节点作为地标.下面对TZ方法进行介绍.3.2一种名字有关的紧凑路由方法设网络用无向无权图G=(V,E)表示,V是节点集合,E是边的集合.设|V|=n,|E|=m,LV表示地标集合.对任意节点u∈V,定义节点u的ball为B(u)={v∈V|d(u,v)<d(u,L)},其中d(u,L)代表u到所有地标的最小距离.定义节点u的cluster为C(u)={v∈V|u∈B(v)}.下面以图1为例进行说明.假设节点a,b,c,d是地标,那么节点u,v,w,s,t的ball和cluster如表1所示.图1说明TZ方法的例子(填充的节点a,b,c,d代表地标.从节点u发送一个包至节点v,实线箭头代表使用的路径,虚线箭头代表最短路径)B(){u,v}{s,t}C(){v}{v}{s}{s}TZ方法的设计分预处理部分和转发算法部分来介绍.预处理部分包含如下过程:(1)地标集构造.选择G中前nx个度数最大的节点作为地标集L,其中0<x<1是可以由用户设置的参数.(2)地址分配.对每个非地标节点u∈V-L,分配地址(u,L(u),eL(u)(u)),记为AddressTZ(u).其中L(u)是离u最近的那个地标的名字,而eL(u)(u)代表L(u)到u的最短路径上与L(u)相连的端口.对每个地标,就用它的名字作为地址.(3)路由表设置.对每个非地标节点u∈V-L,它的路由表设置为TableTZ(u)={(v,eu(v))|v∈L∪C(u)∪B(u)},即存储到L,C(u)和B(u)中每个节点的最短路由信息,其中eu(v)代表u的与它到v的最短路径相连的端口.而对每个l∈L,其路由表只需要包含到其它地标的路由信息,即TableTZ(l)={(v,el(v))|v∈L-{l}}.值得说明的是,TZ方法在每个非地标节点u上产生的路由表为TableTZ(u)={(v,eu(v))|v∈L∪C(u)}.因此与TZ方法相比,TZ方法增加了到B(u)的最短路由信息.它的作用是降低NIHDLR方法的拉伸系数.以图1为例,节点u的路由表只包含到{a,b,c,d,s}的路由信息,节点v的路由表只包含到{a,b,c,d,s,t}的路由信息.考虑到TZ方法与TZ方法的地址分配过程、路由表构造过程采用的算法基本一致,这些过程的详细设计这里不再介绍.TZ方法的转Page5发算法与TZ方法也基本相同.设包首部含有目的节点v的地址(v,L(v),eL(v)(v)),在收到包的每个节点u上执行如下转发操作:(1)如果u=v,那么包到达终点.(2)否则,如果u=L(v),那么使用本地端口eL(v)(v)转发包.(3)否则,如果TableTZ(u)中有到v的路由信息,那么使用eu(v)转发包.(4)否则,在TableTZ(u)中查找到L(v)的路由信息,用eu(L(v))转发包.以图1为例,从节点u发送一个包到v,根据上面的转发算法,使用的路径将是u-w-b-t-v.但是u和v之间的最短路径是u-s-v.因此,同其它紧凑路由方法一样,TZ方法也可能使用非最短路径路由.3.3基本设计分预处理和转发算法两部分来介绍NIHDLR方法的设计.建立在TZ方法的基础上,NIHDLR方法的预处理过程描述如下.(1)像TZ方法那样选择连接度最大的那些节点作为地标.取x=1/2,即使用G的前槡n个最大度节点构造地标集L.(2)像TZ方法那样对每个节点分配地址和构造路由表.对节点u分配的地址和构造的路由表仍然分别用AddressTZ(u),TableTZ(u)表示.(3)构造节点名字/地址映射表,将映射表分布地存放在所有地标上,使每个节点都能够查询任意目的节点的地址.预处理过程的关键是如何建立节点名字/地址映射.我们设计了一种Hash函数H,它将一个节点v映射到一个地标,记为H(v).每个节点都可以为任意目的节点v计算H(v).在地标H(v)上存放v的名字和地址对,即(v,AddressTZ(v)).为了使每个地标存放的名字/地址对数量比较均匀,我们让每个普通节点随机选择一个地标.根据Chernoffbound定理[32],当地标数量为槡n时,这样做可以保证每个地标存储的名字/标记数在珟O(n1/2)中.对Hash函数设计的描述如下.设每个节点都知道所有地标的名字,可以按地标名的字母顺序使用0,1,2,…,槡n-1等数字对地标编号.因此Hash函数H可以使用[0,槡n-1]中的数字作为输出值,每个数字可以唯一确定一个地标.因此,如果使用{0,2,…,n-1}中的数字作为节点名字,Hash函数H的设计将十分简单:设节点名字用logn比特编码,那么从节点名字中抽取(logn)/2位作为输出结果即可,如节点名字的低(logn)/2位.为了便于理解,图2给出了一个当n=16时H的设计举例.设节点名字取自于{0,1,…,n-1},设4(槡4=16)个地标节点的名字是{3,8,11,15}.如果取节点名字的低(logn)/2位作为Hash结果,那么如图2中所示,节点{1,6,7,9,12}的Hash结果将分别是{1,2,3,1,0}.根据地标名字的大小顺序,输出值0,1,2,3将分别对应地标3,8,11,15.这就将每个节点和地标对应了起来.如果节点可以使用任意的字符串作为名字,Hash函数H的设计可以借鉴文献[15]中的随机化构造策略,同样可以在常数时间内完成映射,且保证最多将珟O(n1/2)个节点映射到同一个地标上.具体的构造过程参考文献[15],这里不再赘述.最短路径发送到v.一个节点上转发包的决策过程如下:设源节点为u,目的节点为v,NIHDLR方法在(1)如果v在u的路由表中,那么u可以将包沿(2)否则,u计算H(v),确定存放v的位置信息的地标.(3)u将包发送给H(v).根据路由表构造策略,H(v)在u的路由表中,因此包可以沿最短路径路由到H(v).注意,在此过程中,如果中间节点w的路由表中包含到v的路由信息,那么w将沿到v的最短路径来转发包.因此可能使用一条不经过H(v)的捷径来交付包.(4)当包到达H(v)后,H(v)查询v的地址(v,L(v),eL(v)(v)),用它重写包首部,然后按照TZ方法的转发算法将包发送至目的节点v.以上的路由过程在最坏情况下所使用的路径如图3中的实线箭头所示(为了清楚起见,没有画出节点之间的连接).此时的路径长度为dR(u,v)=d(u,L(u))+d(L(u),H(v))+d(L(v),v).下面提出对NIHDLR的路径质量进行优化的方法.Page6图3NIHDLR方法的路由过程的说明(带阴影的节点3.4优化为了进一步优化路径质量,我们为NIHDLR引入了握手机制(handshaking):当以v为目的地的包到达L(v)时,L(v)将查询v的地址(v,L(v),eL(v)(v)),并将其封装成一个消息返回给源节点u.返回该消息可以有多种路由方式.例如,L(v)可以先将消息发送给H(u),然后由H(u)根据u的地址把封装目的地地址的消息发送给u.这样就完成了一次握手.完成握手后,u在与v通信时可以直接沿最短路径将包发送给L(v),然后由L(v)转交给v.这个过程可以由图4中的实线箭头来描述.可见,握手后最坏情况下的路径长度为dR(u,v)=d(u,L(v))+d(L(v),v).后面我们将证明最坏情况下的拉伸系数.图4握手后的路由过程的说明(带阴影的节点代表地标,L(v)代表离节点v最近的地标,H(v)代表存储节4性能分析下面分析NIHDLR方法的包首部长度、拉伸系数、路由表大小、预处理时间和转发时间等指标的性能.4.1包首部长度NIHDLR方法产生的包首部长度为O(logn)比特,理由如下:对任意节点v,它的地址为(v,L(v),eL(v)(v)),由于节点名、端口号都可用O(logn)比特表示,故地址长度为O(logn)比特.包首部一开始只包含目的节点的名字,后来用目的节点的地址重写,不论哪一种情况,包首部长度都在O(logn)比特中.而Abraham方法产生的包首部长度为O(log2n/loglogn)比特,因此NIHDLR方法的在包首部产生的开销方面要优于Abraham方法.4.2拉伸系数这里对NIHDLR方法分别在没有握手机制和具有握手机制的情况下,产生的拉伸系数进行分析.定理1.不考虑握手机制时,NIHDLR方法在任意图G上具有不超过(2,2d)的拉伸系数,其中d=max{d(u,v)|u,v∈L∧u≠v},即图G中所有不同地标对之间的最大距离.证明.设源节点u发送一个包给目的节点v.如果v∈L∪C(u)∪B(u)那么可以直接使用v的名字沿最短路径路由到v.否则,路由过程如图3所示.因此,从u到v的路径长度dR(u,v)一定满足dR(u,v)d(u,H(v))+d(H(v),L(v))+d(L(v),v).根据三角形不等式原理,显然有d(u,H(v))d(u,L(u))+d(L(u),H(v)),所以dR(u,v)d(u,L(u))+d(L(u),H(v))+因为v不在Table(u)中,所以d(u,v)>d(u,L(u))且d(u,v)>d(L(v),v)成立,故dR(u,v)2d(u,v)+d(L(u),H(v))+d(H(v),L(v)).又因为d(L(u),H(v))d,d(H(v),L(v))d,所以因此NIHDLR方法的拉伸系数等于(2,2d).定理2.考虑握手机制,握手后NIHDLR方法在任意图G上具有min{(3,0),(2,d)}的拉伸系数,d的定义如定理1.证明.握手后,从源节点u发送一个包给目的节点v,最坏情况下的路由过程如图4所示.因此,从u到v的路径长度dR(u,v)一定满足根据三角形不等式原理,显然有dR(u,L(v))d(u,v)+d(L(v),v),所以因为vB(u)∪C(u),所以d(u,v)>d(L(v),v),故有dR(u,v)3d(u,v).Page7下面证明dR(u,v)2d(u,v)+d.根据三角形不等式原理,亦有d(u,L(v))d(u,L(u))+d(L(u),L(v)).故有dR(u,v)d(u,L(u))+d(L(u),L(v))+d(L(v),v).再次考虑到d(u,v)>d(u,L(u))且d(u,v)>d(L(v),v),所以有dR(u,v)2d(u,v)+d(L(u),L(v))2d(u,v)+d.结合dR(u,v)3d(u,v)和dR(u,v)2d(u,v)+d,可以得出NIHDLR方法具有最大拉伸系数min{(3,0),(2,d)}.在无标度网络上d到底能取什么样的值,我们将通过Lu[30]和Chung等人[31]提出的随机幂律图模型及相关理论来分析.假设幂指数的取值在2<γ<3中,事实上多数无标度网络都是满足该假设的.下面给出随机幂律图的定义[30-31].定义1.设G(狑)表示由度序列狑=(w1,w2,…,wn)产生的随机图集合,其中wi表示节点vi的期望度,任意两个节点vi,vj之间存在一条边的概率等于wiwj∑n布,即P(wi)~w-γi,那么称G∈G(狑)为随机幂律图[30-31].设k-Core为G(狑)中期望度大于或等于k的那些节点集合.那么它导出的子图的直径具有以下的性质.引理1.设G是G(狑)的一个采样,给定t(nδ0<δ<3-γ图有1-n-2的概率直径不超过(1+o(1))lognk=1证明.请参考文献[30]第62页的Lemma12和文献[31]的Claim4.1.过程略.证毕.引理1意味着当n很大时,由随机幂律图中的少数最大度节点导出的子图具有的直径趋近于常数.该子图可以看成是幂律图的核(Core).于是我们可以得到以下的推论.推论1(引理1的推论).设G是G(狑)的一个采样,地标集L由G(狑)的前nx(0<x<1)个期望度最大的节点构成,那么d有1-n-2的概率具有常数上限.证明.设G(狑)的期望度分布满足P(k)~k-γ,从而可得累积度分布公式为P(zk)=ck1-γ,其中c可取常数.现在计算L中节点的最小期望度τ.根据累积度分布公式有cτ1-γ≈nx/n,因此有cτ1-γ≈nx/nlogc-(γ-1)logτ其中c1是依赖于γ和c的常数.导出的子图的直径有1-n-2的概率不超过L可以看成是G(狑)的τ-Core.根据引理1,L(1+o(1))logn(1+o(1))(γ-1)logn由于γ、c和x都可以取常数,这个表达式具有常数上限.根据d的定义,d将小于或等于L导出的子图的直径.因此d具有常数上限.4.3路由表大小NIHDLR方法产生的路由表大小分地标和非地标节点两种情况来分析.对每个地标l,它的存储开销包含两部分.一部分是到所有其它地标的路由信息,即{(v,el(v))|v∈L-{l}},另一部分是节点名字/地址映射信息,即{(v,AddressTZ(v))|v∈V∧H(v)=l}.当地标数量取槡n时,每个地标存放的节点名字/地址映射信息为珟O(n1/2)比特,因此每个地标的路由表大小不超过珟O(n1/2)比特.每个非地标节点的路由表设置为Table(u)=TableTZ(u)={(v,eu(v))|v∈L∪C(u)∪B(u)}.非地标节点不需要存储节点名字/地址映射信息.因此要求出路由表大小的界限,关键是计算出B(u)和C(u)的大小.为此,我们仍然使用了随机幂律图理论来进行分析.引理2.设β=γ-2β(γ-2)+(2γ-3)ε2(γ-1)γ-2lnn的任意正实数(显然ε=o(1),即当n足够大时,ε将非常小).设G是G(狑)的一个采样,对所有u∈V(G),至少有1-3/n-2的概率满足|B(u)|=|{u∈V(G):d(u,u)<d(u,τ-Core(狑))}|其中τ=nβ.证明.请参考文献[9]的第9页,Lemma7.具体过程略.推论2(引理2的推论).设G是G(狑)的一个采样,L是地标集,即狑的前nx(0<x<1)个期望度最大的节点,对所有u∈V(G),至少有1-3/n-2的概Page8率满足|B(u)|=O(nα),其中α=(1-x)(γ-2)ξ,ξ足够小.证明.根据推论1已知,L的最小期望度τ=c1n(1-x)/(γ-1),进一步可转换为τ=n1-xo(1)足够小.根据引理2可知:α=1-x(2γ-3)εγ-1,即α=(1-x)(γ-2)2)ε+(2γ-3)ε所以ξ也可以取很小的值.对所有u∈V(G),我们通过推论2给出了|B(u)|的理论上限.遗憾的是|C(u)|无法像|B(u)|那样通过从u开始的邻域扩张法(neighborhoodexpansion)来统计分析它的界限.C(u)中包含哪些节点严格依赖于u及其邻居的距离信息,而这些必须在具体的图产生后才能计算出.然而,我们可以计算出对全部u∈V(G),C(u)的平均大小的上限.引理3.对任意图G,有即|C(u)|和|B(u)|具有相同的平均大小.证明.根据C(u)和B(u)的定义,对任意v∈B(u),必有u∈C(v),反过来亦成立.由于这样的u,v总是成对出现的,所以引理3成立.证毕.根据以上的分析,我们可以得出以下的重要结论.定理3.设G是G(狑)的一个采样,设L是地标集,即狑的前nx(0<x<1)个期望度最大的节点,对所有非地标节点u∈V(G),平均的路由表大小至少有1-3/n-2的概率满足|Table(u)|=珟O(nx+nα),其中α=(1-x)(γ-2)证明.因为|L|=O(nx),|B(u)|=O(nα)且|C(u)|=|B(u)|=O(nα),而每个路由表项可以用O(logn)编码,所以很容易推出|Table(u)|=珟O(nx+nα).推论3(定理3的推论).NIHDLR方法可以使平均路由表大小|Table(u)|在随机幂律图上具有上限珟O(槡n)比特.证明.因为2<γ<3,故α=(1-x)(γ-2)ξ(1-x)/2+ξ,所以非地标节点的平均路由表大|Table(u)|具有上限珟O(槡n).而地标节点的路由表大小也具有上限珟O(槡n),最后可以得出全部节点的平均路由表大小一定在珟O(槡n)中.证毕.4.4预处理时间与转发时间定理4.设G是G(狑)的一个采样,设L是地标集,即狑的前nx(0<x<1)个期望度最大的节点,使用NIHDLR路由方法,预处理时间至少有1-3/n-2的概率为O(mnx+n1+αlogn),其中α=(1-x)(γ-2)γ-1+ξ,ξ足够小.在每个节点上的路由转发时间为O(1).假设使用集中式的算法进行预处理.为了选择度最大的前槡n个最大度节点构造地标集,可以用一次宽度优先搜索算法搜索整个网络G,然后再对所有节点按度数排序,因此需要的时间为O(m+nlogn).用TZ方法对节点u编址的时间取决于搜索其最近的地标所需要的时间,实际上也等于计算B(u)所需要的时间.在随机幂律图上计算B(u)所需要的时间T(B(u))如引理4所示.引理4[9].设G是G(狑)的一个采样,使用NIHDLR路由方法,对所有u∈V(G),T(B(u))至少有1-3/n-2的概率满足T(B(u))=珟O(nα),其中α=(1-x)(γ-2)证明.根据参考文献[9]的第9页,Lemma7,可以知道B(u)的内部连接数E(B(u))有1-3/n-2的概率在O(nαlogn)中.而使用宽度优先搜索B(u)所需要的时间为O(E(B(u))),所以得证.证毕.用TZ方法对节点u创建路由表,B(u)和C(u)部分所需要的时间等价于计算B(u)的时间,因此也是O(nαlogn).可见,为所有节点编址和创建到B(u)和C(u)部分路由表项的时间开销为O(n1+αlogn).为了完成为所有节点创建到L的路由表项,可从L中的每个地标发起宽度优先遍历,时间开销为O(mnx).以上是使用TZ方法进行预处理的时间开销.下面分析创建节点名字/地址映射表的时间开销.这里的主要开销来自于为每个节点计算Hash函数H.由于H的计算时间复杂度可以是常数O(1),所以创建节点名字/地址映射表的时间开销应当为O(n).综上所述,NIHDLR方法的总的预处理时间应当为Page9O(m+nlogn)+O(n1+αlogn)+O(mnx)+O(n),即O(mnx+n1+αlogn),其中α=(1-x)(γ-2)ξ足够小.定理4得证.处理时间可以控制在O(mn1/2)中.推论4(定理4的推论).NIHDLR方法的预证明.因为2<γ<3,故α=(1-x)(γ-2)ξ(1-x)/2+ξ,所以NIHDLR方法的预处理时间为O(mnx+n(3-x)/2+ξlogn).当x=1/2时,可以得该预处理时间的上限O(mn1/2).如同以往的工作一样[12-14],我们假设路由表项是用标准Hash表[33]的方式来存储,可以保证查询通往目的节点的端口号可以在常数时间内完成.类似地,根据目的节点名查询存放其地址的地标,以及在地标上查询目的节点的地址也是使用Hash表实现.故在路由过程中,每个节点的决策和转发时间也是常数.5仿真为了验证提出的方法在无标度网络上的实际性能,我们在随机幂律图模型和真实的InternetAS(AutonomousSystem,自治系统)图上开展了仿真实验.我们使用不同的幂指数γ和网络规模n来产生随机幂律图,其中γ取{2.1,2.2,2.3,2.4,2.5}中的值,n取{1000,2000,…,10000}中的值.我们为每对γ和n生成10个随机幂律图,仿真结果是在10个随机幂律图上进行平均所得.InternetAS图使用CAIDA①的Skitter项目测量的AS拓扑数据(γ≈2.25),其中节点数n=9204,连接数m=28959.仿真中设置地标集的大小为|L|=槡n.仿真测试了NIHDLR的平均路由表大小,平均拉伸系数等指标.其中平均拉伸系数等于所有不同节点对之间的实际路径长度与最短路径长度之比的平均值.我们还将NIHDLR与最优的通用名字无关紧凑路由方法———Abraham方法进行了比较.5.1拉伸系数图5给出了随机幂律图上d的测试结果.可以看到,d随网络规模的变化大致保持稳定(波动源于不同规模的随机幂律图的连接密度有差异),这与我们的分析结果基本相符.对于γ=2.1的情况,d的平均值稍大于4.而随着γ的增加,d有所变大,当γ=2.5时,d平均值稍大于8.这可以解释为,随着γ的增加,大度地标的平均度和它们之间的连接密度下降,故直径也随之增大.我们也在InternetAS图上进行了仿真.对于AS图,d仅为2,原因来自两个方面.一方面是InternetAS图中存在少数度很大的节点,另一方面是InternetAS图存在Rich-Club现象[34],即度较大的节点之间倾向于互相连接,这些都会导致d比同等条件下的随机幂律图要小.图6和图7比较了NIHDLR方法和Abraham方法在幂律图上产生的平均拉伸系数.对于NIHDLR,我们分别测试了原始方法的平均拉伸系数和使用握手机制优化后的平均拉伸系数.可以看出,NIHDLR方法的平均拉伸系数显著低于Abraham方法.特别是对于优化后的NIHDLR方法,平均拉伸系数一般在1.1以下.图6还给出了Abraham方法和NIHDLR方法在AS图上的测试结果.前者的平均拉伸系数为1.50左右,而后者在优化后只有1.09.从图7还可以观察到,随着幂指数的增加,原始NIHDLR方法的平均拉伸系数在增长,而Abraham方法的平均拉伸系数有所降低.这是因为,NIHDLR方法是将节点的位置信息放在地标上,当幂指数增大时,度分布越均匀,地标之间的连接越松散,即地标之间的距离越大,导致定位和路由过程需要付出更多的路径代价,从而使整体的平均拉伸系数变大;而Abraham方法将位置信息放在节点的邻域中,这就比较适应度相对均匀的网络,当幂指数增大时,网络平均距离增大,反而可以降低平均拉伸系数.优化后的NIHDLR方法产生的平均拉伸系数则似乎随幂指数的增加没有多少变化,原因是不需要在握手后再去查询目的地址,所以较少受到地标之间距离增大的影响.①TheCooperativeAssociationforInternetDataAnalysisPage105.2路由表大小图8比较了NIHDLR方法和Abraham方法在幂律图上产生的平均路由表大小(注意:原始NIHDLR和优化后的NIHDLR在路由表设置方面并没有差别).为了简单起见,我们使用项数作为路由表大小的单位.原因是路由表项使用的比特数取决于实际的编码方法,不同的编码方法可能导致结果不一样.可以看出,NIHDLR方法产生的平均路由表大小远小于Abraham方法产生的平均路由表大小.在10000个节点的随机幂律图上,NIHDLR方法的平均的路由表项数仅为106左右,而Abraham方法的平均的路由表项数接近1500.在AS图上,NIHDLR方法和Abraham方法的平均路由表项数分别为101和1465左右.NIHDLR方法能产生很小路由表的原因是,在幂律图上对每个节点u∈V(G),由于u与大度节点有很高的概率直接相连或者只有很少的跳数,B(u)和C(u)的规模都可以很小.而Abraham方法为了保证在一个节点的邻域内就能查询到任意目的节点的地址,往往导致较大的邻域.而节点的路由表必须维护到邻域节点的路由信息,因此路由表也较大.6讨论目前我们的工作聚焦于为静态网络设计路由算法,即假设网络拓扑不会发生变化.然而实际网络的拓扑结构可能会发生变化,如Internet会存在链路或者节点失效的情况,失效的节点和链路也可以重新恢复.拓扑变化对本文提出的路由方法的影响和可能的应对策略讨论如下:(1)拓扑变化可能会引起某些节点地址的失效,因而需要对节点重新编址.因为节点的地址取决于离其最近的地标以及地标上与它连接的端口,因此拓扑变化可能也会引起这些部分的变化.一种方法是让所有地标定期地广播消息对网络进行宽度优先遍历,在消息中携带距离和端口号.每个节点在收到所有地标的消息后,选择最小距离的地标名及相应端口,对地址进行更新.(2)拓扑变化可能会引起某些节点路由表项的失效,因此需要利用变化后的拓扑进行更新.例如,节点到地标的最短路径和到其附近节点(即其ball和cluster中的节点)的最短路径均可能会因为拓扑变化而改变,因此对应的路由表项也应该更新.更新节点到地标的路由,可以通过上述的由地标发起的周期性网络遍历来完成.为了更新节点到其附近节点的路由,可以由该节点在其ball内发起小范围内的宽度优先遍历,同样在消息中携带距离和端口号,收到消息的节点在更新路由表的同时,可以对源节点发送一个应答,便于让源节点更新到它的路由表项.(3)地标失效的问题.由于地标充当了查询目的地址和路由转发的核心作用,因此地标失效也会引起路由失败.一种解决方法是在地标上存放冗余的节点名字/地址映射信息,一个节点可以映射到多个地标.当因为原来的地标失效导致路由失败时,源节点可以通过使用替代的地标来查询目的地址或者转发消息.Page11不可避免地,上述问题和措施会造成路由算法的复杂性增加和更多的性能开销.最近已经有工作考虑了如何在动态网络拓扑上改编紧凑路由算法以提高其适应性和实用性,并且通过实验证明改编的紧凑路由算法在拓扑变化时可以产生比传统路由算法(如链路状态路由算法)更低的消息开销[35].然而,它是针对无线传感器网络的.无标度网络上的动态紧凑路由算法可能成为未来紧凑路由研究的一个热点.7结论本文针对类Internet拓扑结构的无标度网络提出了一种名字无关的紧凑路由方法.分析表明,该方法可以在无标度网络上取得比较优化的路由表大小和拉伸系数等性能指标.在无标度网络模型和真实InternetAS级拓扑图上的仿真实验表明,实际的拉伸系数和路由表大小均要显著优于最优的通用名字无关紧凑路由方法.我们注意到,最近有许多互联网专家认为,互联网路由系统应当采用位置符/标识符分离(Locator/IDSeparation)的编址和路由方案①.从本质来看,名字无关的紧凑路由方法可以看成是这类设想的一个实现.目前我们对NIHDLR的评估仅局限它在静态网络拓扑上的性能.在动态网络拓扑上,如何改编NIHDLR以提高它的动态适应性和实用性是我们下一步要考虑的工作.致谢评审专家对本篇论文提出了宝贵意见,他们的建议对于提高本文的质量很有帮助.编辑老师付出了辛勤劳动,在此一并表示感谢!
