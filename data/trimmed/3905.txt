Page1一种列存储数据仓库中的数据复用策略王梅周娇玲乐嘉锦(东华大学计算机科学与技术学院上海201620)摘要数据复用是数据仓库管理中节约存储空间、提高查询效率的重要手段.列存储技术将来自同一属性的数据连续存储,极大地提高了数据仓库等分析型应用软件的性能,同时增加了复用的可行性和灵活性.为此,提出了一种列存储数据仓库中的数据复用策略.首先,利用模式匹配技术发掘候选可复用列,排除大量无法复用的数据列,在此基础上对候选可复用数据进行筛选和过滤,大大降低复用数据检测的复杂度.针对确定的可复用数据,提出了基于列存储的复用实现策略,分别给出了原始数据列、压缩数据列及索引数据列的复用实现方法.最后提出了基于复用数据的查询实现技术.在大规模数据仓库基准数据集上的实验结果验证了数据复用策略在减少存储量、节省数据装载时间及提升查询性能方面的有效性.关键词数据复用;数据仓库;列存储;模式匹配;可复用数据1引言随着社会信息化不断推进,目前数字信息量呈Page2传统数据仓库底层存储结构大都采用行存储方式,将每条记录作为一个整体顺序存储在介质中.由于不同数据集的数据模式间存在差异,很难找到两条完全相同的记录,因此在存储层次上原始数据的重复率不高,不易于复用.目前,行存储中往往考虑基于视图或查询产生的中间结果的复用.通过重用连接、投影、分组等复杂处理的中间结果,满足及时响应用户查询和联机分析处理等应用的要求.这种策略虽然能在一定程度上改善查询效率,但由于分析型数据应用中包含海量数据,查询执行过程中产生的可被重复访问的中间结果也具有“海量”特点,在缓冲区有限的情况下,极易发生内存争用问题[1].由此产生的重用度估计、额外的缓冲区调度策略等都会影响复用的性能.另一方面,查询结果的重用主要针对同一数据集,对于多个数据集的数据复用问题并未过多考虑.相较于行存储,列存储技术在物理上将关系中的元组按属性拆分,来自同一属性的数据连续存储.这种存储方式极大地提高了分析型查询的效率[2].由于列存储在分析型应用中的卓越性能,近年来针对列存储数据仓库的研究引起了人们广泛的兴趣.不同的表模式,或者说现实世界的不同实体,往往具有相同的属性,反映在列存储中就是相同或相近的列.因此列存储中数据的冗余度更高.另外,传统行存储在查询执行时每次选取关系中一个完整的元组进行运算.此时重用的粒度是一整行或投影后的可用列,匹配条件更严格,重用代价较高.反之列存储查询执行以包含部分同列数据的块作为操作对象,增加了复用的可行性和灵活性.然而,相比较行存储,列存储数据仓库还不太成熟,对其复用技术的研究仍较少,部分现有工作仍旧关注于同一数据集中的物化视图及查询的中间结果,针对不同数据集的数据冗余在存储层面上的有效数据复用策略并不多见.重复数据,如产品信息、客户信息、地理信息、日期信息等.数据复用技术充分利用重复数据之间的关系,减少系统存储量、缩短用户响应时间,已成为数据仓库管理的重要研究内容.针对上述问题,本文提出了一种列存储数据仓库中的数据复用策略.首先,利用模式匹配技术发掘候选的可复用列,排除大量无法复用的数据列,大大缩小复用数据的检测空间和复杂度;进而根据复用的条件对候选可复用列进行筛选和过滤,得到确定的可复用数据;针对上述数据,提出了基于列存储的复用实现策略,分别给出了原始数据列、压缩数据列及索引数据列的复用实现方法;并在此基础上给出基于复用数据的查询实现过程.最后在大规模数据仓库基准数据集TPCH①和SSB②上进行实验,验证本文所提策略在减少存储量、节省数据装载时间及提升查询性能方面的有效性.本文第2节介绍本文相关工作;第3节介绍相关定义和符号;第4节详细介绍本文提出的复用策略,包括复用数据的检测、基于列存储的复用实现以及复用数据上的查询实现;第5节给出本文所述方法的实验验证;最后是总结和展望.2相关工作2.1数据复用数据复用(datareuse)又称数据重用.早期的数据复用技术主要为硬件存储服务,通过重复使用访问频率较高的数据节约内存消耗.20世纪90年代以来,随着人们对缓存查询结果的广泛研究,数据复用逐渐应用于传统行存储数据仓库中,其复用对象主要是物化视图及查询的中间结果.近几年,对物化视图的研究着重围绕视图的选择、维护而进行.常见的FPUS[3]算法通过计算单位存储空间视图的查询频率,每次物化查询频率最高的视图.MVPP[4]算法比较每个视图的代价和增益,并利用贪心算法选择具有最小代价的多查询优化.对于内存中中间结果的复用,早期仅限于一些特定查询的中间结果复用.随后Roy等人提出了查询自动缓存系统Exchequer③.该系统引入缓存管理和优化机制,可以自动重用任意查询的中间结果.Markl等人[5]提出了POP方法,进一步通过重优化查询处理保证中间结果能够更好地被重用.列存储技术在物理上以列为单位进行存储,在查询过程中只需读入查询相关列,从而极大地提高了分析型查询的效率,同时列存储对复杂查询的灵活快速响应及为压缩带来的存储优势也使其在数据仓库方面具有良好的发展前景,代表性系统包括MonetDB/X100[6]、C-Store[7]等.在列存储的基础上,Ivanova等人[8]提出了中间结果的重用策略,主①②③Page3要关注多查询计划间的中间结果重用.然而相对于单一查询计划,多查询计划间差异较大,重用性不高.后来,张琦等人[9]针对列存储数据仓库,提出了单一查询计划执行过程中的中间结果重用策略.该策略根据模型估计的结果执行缓冲区调度算法,使产生的中间结果能够更好地被重用,以提升查询性能.可以看到,目前对列存储数据仓库中数据复用的研究仍关注于同一数据集中的物化视图及查询的中间结果,针对不同数据集的数据冗余在存储层面上的有效数据复用策略并不多见.2.2模式匹配系统模式匹配[10]被广泛用于多数据源集成时在两个或多个模式元素之间产生映射关系,使得数据集成后能够在统一的模式下进行查询和分析.模式匹配方法目前存在较多的研究成果,按照匹配内容的不同可分为元素自身信息、模式结构信息和数据实例信息3种类型.早期对模式匹配的研究大多基于元素自身信息,如COMA[11]方法,但该方法只能发掘11匹配且需要多次扫描整个模式,时间复杂度高.模式中元素间的相互关系构成了模式的结构信息.常用的SF[12]方法和Cupid[13]方法均利用模式结构信息来辅助匹配.然而,如果模式中定义的结构信息不够丰富(如关系数据库中结构信息仅为元素间的主外键关系),就会对匹配准确度产生一定的影响.数据实例信息是模式描述的对象,能够最真实地反映元素的信息.目前已经有很多模式匹配方法利用数据实例信息提高匹配的准确度,比较典型的有iMAP[14]方法.它利用不同类型的搜索器搜索候选匹配,然后选取相似度值最高的元素作为最终匹配.iMAP可以很好地发掘1:1匹配和复杂匹配,但由于每个搜索程序都要对所有的候选匹配进行检索,导致需要检索的候选匹配规模太大,影响匹配效率.随后在iMAP基础上提出的CM[15]方法,通过预处理过滤掉部分不合理的候选匹配,在一定程度上缩小了候选匹配空间.3基本定义和符号定义1.数据仓库.给定数据仓库D={S1,S2,…,Sn},由一系列相互关联的物理表构成,其中S表示关系表,n表示关系的数量.定义2.关系表.关系表Si={Ai1,Ai2,…,Aim},其中m表示关系Si的目的度,Aij表示Si中第j个属性.定义3.数据段.列存储中,任意一列Ai中的数据在逻辑上对应一个数据段Segi∈Seg,其中Seg是所有数据段的集合.每个数据段由一系列连续的数据块构成.若blk表示数据块,r表示块的总数,则第i个数据段Segi={blki1,blki2,…,blkir}.定义4.目标表.等待被装载到D中的关系表定义为目标表T,其中T={A1,A2,…,Ak},k表示T的目的度.Ai,在D中寻找可复用数据并合理利用的过程.定义5.数据复用.对于T中的每一个属性定义6.源属性集.D已有的关系表中能够被复用的属性集合记为源属性集Cols,Cols={Ai1,Ai2,…,Aij},集合中的每一项称为源属性.定义7.目标属性集.目标表T中能够复用源属性的属性集合记为目标属性集Colt,Colt={A1,A2,…,Aj},其中Ai又称为目标属性.4复用策略4.1复用分类针对不同的应用需求,数据复用有多种分类标准.我们主要考虑基于属性基数的复用标准.属性基数是指参与复用的属性数目.根据属性基数,可以将数据复用分为11复用和复杂复用.与11复用不同的是,复杂复用要求参与复用的对象不仅仅是源属性集和目标属性集中的某个属性,至少有一个属性组.4.2复用数据的检测模型复用数据的检测是数据复用的关键环节,它直接关系到能否找到可重用数据以及如何根据数据之间的映射关系设计复用算法.复用数据的检测主要分为两个步骤:(1)寻找候选复用数据;(2)筛选候选复用数据.下面我们将分别介绍这两个方面的内容.4.2.1数据的匹配要想找到T中目标属性的可重用数据首先必须检测D中是否存在符合条件的属性或属性组.若直接进行检测,则需穷举所有属性及属性组的可能匹配,在计算上并不可行.在此,我们借助更为高效的模式匹配算法.模式匹配可以发掘一个模式中某些特定元素与另一个模式中某些特定元素间的映射Page4关系.已有的模式匹配方法大多着重发掘模式元素间的11匹配.然而模式之间还包括许多复杂匹配.文献[14-15]中提出的iMAP和CM方法都能很好地发掘11和复杂匹配.但iMAP检索候选匹配空间的时间复杂度可能达到O(2nm),时间效率不高.CM在iMAP基础上增加预处理单元,事先过滤掉部分不合理的候选匹配,从而缩小候选匹配空间,加快列与列之间映射关系的寻找.因此,我们选择基于数据实例信息的CM模式匹配方法.模式匹配的最终目标是寻找属性之间的映射关系f,这是复用的根本依据.CM匹配框架主要由4个单元组成:预处理器、匹配产生器、相似度估价器和匹配选择器.具体的匹配算法表述如下.算法1.SchemaMatching(D,T).输入:D,T输出:M=(Colt,Cols,F)1.S=;M=;2.ListCandidatelist;3.SimilarMatrixMatrix;4.InitList(Candidatelist);5.WHILE(S=D.getNextTable())6.Preprocess(S);/根据属性的数据类型将S中的各个属性存7.Preprocess(T);/根据属性的数据类型将T中的各个属性存表1模式匹配发掘的映射关系4.2.2数据的筛选由模式匹配得到的映射关系在一定程度上反映了数据的相关性,确定了复用的类型.但许多关于模式匹配的研究表明,其查准率和查全率都不能达到100%[16].因此存在映射关系仅仅是复用的必要不充分条件,候选数据能否被复用还必须经过进一步的筛选.引入两个变量sum1,sum2,其中sum1为目标表T的元组数,sum2为D中关系表S的元组数.候选数据的筛选算法如下.8.ListInsert(Candidatelist,s_unit[i],t_unit[i]);9.Candidatelist=Search[m](Candidatelist);/Search[m]是一个函数指针数组,每个函数10.Matrix=SimilarityEstimate(Candidatelist);11.f=SelectThreshold(Matrix),将最优匹配f及属12.RETURNM.上述算法步5每次选取D中的一张表与T进行匹配,其中D中的表与T可来自两个不同的数据集.步6~7通过预处理,按照属性的数据类型过滤掉部分不合理的候选匹配.步9应用标准的搜索策略搜索初步缩小的候选匹配空间,产生11匹配和复杂匹配(匹配基数决定了复用的类型).步10、11应用贝叶斯分类器对候选匹配进行估价并由匹配选择器选择出较优的候选匹配.算法的输出是一个包含所有确定映射关系的三元组M=(Colt,Cols,F),F是映射关系f的集合,Colt与Cols分别是f的原像集和像集.不同的匹配基数对应不同的映射关系f.对于11匹配,Colt中的目标属性在Cols中有唯一确定的源属性与之对应,记为f:Ai→Aij,(A∈Colt,Aij∈Cols).对于复杂匹配,至少存在一个属性组合,记为f:(Ai,…,Aj)→(Aik,…,Aim),((Ai,…,Aj)Colt,(Aik,…,Aim)Cols,(i-j)2+(k-m)2>0),属性组合一般来自于同一张关系表.常见的映射关系f主要有6种,如表1所示.算法2.Filter(M).输入:M(Colt,Cols,F)输出:M(Colt,Cols,F)1.对于M中每个映射关系f2.colt=f中来自T的属性或属性组合,统计sum13.cols=f中来自S的属性或属性组合,统计sum24.inti=0;5.WHILE((itemt=colt.getNextItem())Page56.IF(f(itemt)==items)i++7.ELSE8.M=M-(colt,cols,f)GOTO19.ENDIF10.ENDWHILE11.IF(i==sum1sum1<sum2)12.M=M-(colt,cols,f)GOTO113.ENDIF14.M=M15.RETURNM.算法中统计量i表示满足映射关系的数据项总数.步8说明一旦检测出某个数据项不满足映射关系,候选数据就不能复用,必须将该候选匹配剔除.步11通过比较i与sum1、sum2的大小,确定复用的完整性.可以看到,i等于colt与cols记录条数的最小值.理想情况下i=sum1=sum2,对于目标属性来说数据恰恰完全复用;如果i=sum2<sum1,目标属性的数据真包含源属性的数据,此时除了复用源属性外还必须从外部导入剩余的(sum1-i)条数据,称之为部分复用.假若i=sum1<sum2,说明源属性中还有部分数据在目标属性中无法找到原象,即不是满映射,也必须剔除该候选匹配.经过筛选最终得到满足复用条件的新三元组M(Colt,Cols,F).例如,根据4.2.1节的SchemaMatching()算法得到M=({name},{agent_name},{name=agent_name}),其中sum1=10500,sum2=10000.调用Filter()算法得到i=10000,映射关系f成立,name列复用agent_name的整列数据,并导入额外的500条记录.4.2.3复用检测模型的有效性分析上述过程利用模式匹配技术发掘候选可复用列,排除大量无法复用的数据列,在此基础上对候选可复用数据进行筛选和过滤,可极大减少检测空间和复杂度.分析如下:假设D中共有n张关系表,平均每张表有m个属性,目标表T中有k个属性.关系表的平均记录条数为t.如果直接进行数据的筛选,所有可能的候选匹配个数X1可由式(1)计算得到,筛选候选匹配的规模X2可由式(2)计算得到CM匹配框架通过模式匹配得到确定的映射关系,其候选匹配个数X3及筛选规模X4为上式中,X2的时间复杂度为O(2nmk),X4的时间复杂度为O(2mk).显然,模式匹配大大缩小了候选匹配空间,特别当表的记录数t十分庞大时,筛选的规模大幅度地降低,极大地提高了复用的效率.4.3基于存储的复用实现4.3.1原始数据的复用如何标记源属性是否被重用,关系到如何访问重用数据的问题.列存储中,每个段用一个段控制块来保存段的特征信息.因此,我们在段控制块中引入标示符flag,flag=0表示此段未被复用,flag=1表示此段已被复用.用一张复用信息表RTable存放相关的元数据信息,RTable的结构如表2所示.名称coltcoltColt来自T的属性或属性组colscolsCols来自S的属性或属性组ffF,目标属性colt与源属性cols之间的映射关系sum1表T的记录总数sum2表S的记录总数blk_id_list映射关系中每列的数据块信息链表RTable中每条记录由一个映射关系f及对应属性的信息构成,其中colt,cols共同构成RTable的主键.cols对应的数据段称为原始段,colt对应的数据段称为目标段.blk_id_list是一张链表,每个节点存放源属性的列id,起始数据块块号blk1和终止数据块块号blkr.首先将新三元组M中的所有信息添加到RTable表,然后给出基于原始数据的复用算法.算法3.Dataload_Reusing(T).输入:T1.FORallA∈TDO2.colt=A;3.cols=findSimilarData(RTable,colt);4.IF(cols==null)5.blk1=load(A,1,sum1);6.blkr=getLastBlk(blk1);7.addListNode(A,blk1,blkr);8.ELSE9.flag=1;10.blk_id_list=getBlkList(cols);11.IF(sum1>sum2)12.blk_id1=load(A,sum1-sum2,sum1);13.blk_id_list.blkr->next_id=blk_id1;14.blk_id_list.blkr=getLastBlk(blk_id1);15.ELSE16.blk_id_list.blkr->next_id=0;17.ENDIF18.addListNode(A,blk1,blkr);19.ENDIF20.ENDFORPage6算法中步3首先判断该属性能否复用源属性.步5~7表示如果不能复用,则加载该属性.addListNode()函数将当前列id,起始数据块blk1和最后一个数据块blkr添加到blk_id_list中.步11判断目标属性是否为部分复用,若是则加载时必须申请新的数据块存储剩余的(sum1-sum2)条数据(见步12),然后将原始段与新数据块串联起来.串联时令原始段最后一个数据块的后继指向新分配的第一个数据块(见步13).需要注意的是,复用的实质是目标属性与源属性共享存储空间,串联改变了原始段的存储结构.因此针对部分复用,查询时如果访问源属性则令blkr->next_id=0,说明该段为原始段,且最后一个数据块为blkr.如果访问目标属性,则blkr->next_id=blk_id1,即该段是串联后的目标段.若多个目标属性复用同一源属性,即RTable表cols相同,colt不同时,对colt中的每个目标段都会进行形如算法3中步10~16的操作,从而实现多段复用.4.3.2压缩数据的复用目前压缩主要分为表级、块级、元组级、属性级以及比特级压缩.列存储中连续存储的数据均来源于同一个属性,即同一个值域,因此属性级压缩在数据压缩方面具有很大的优势.但系统在首次压缩时需要耗费一定的CPU代价[17].为此我们可以对已压缩数据进行复用,从而减少上述开销,提高系统性能.压缩数据复用的基本思想:由于源属性与目标属性共享存储空间,因此只要源属性进行了压缩,目标属性就可以复用其压缩数据.算法如下.算法4.compress_Reusing(T).输入:T1.FORallA∈Tdo2.colt=A;3.cols=findSimilarData(RTable,colt);4.IF(cols==null)5.cmp_blkid=compress(A,1,sum1);6.cmp_blkid1=0;7.ELSE8.cmp_blkid=getCompBlk(cols);9.flag1=1;10.IF(sum1>sum2)11.cmp_blkid1=compress(A,sum1-sum2,sum1);12.ELSE13.cmp_blkid1=0;14.ENDIF15.ENDIF16.insertCompBlk(A,cmp_blkid,cmp_blkid1);17.ENDFOR在存储结构上,每个属性同时对应一个压缩段id,即起始压缩块地址,根据压缩段id可以读取压缩数据.同样在压缩段的段控制块中引入标示符flag1,flag1=0表示压缩段未被复用,flag1=1表示该压缩段已被复用.步3首先从RTable表中寻找原始数据复用信息.步8显示一旦存在复用信息,就获取源属性的压缩段id.否则必须压缩整列数据,如步5.compress()函数涉及3个参数,分别是属性名、起始行号(从1开始计数)和终止行号.若是部分复用,如步10、11所示,则压缩剩余数据,用cmp_blkid1记录新压缩块id,反之cmp_blkid1为0.步16将两部分的压缩段id赋值给目标属性,完成压缩数据的复用.4.3.3索引数据的复用列存储中元组重构与多表连接是影响查询性能的重要因素.而要提高查询的效率,最简单、最有效的方法就是在数据表相应的列上建立索引.对索引数据的复用可以减少复用数据的索引创建时间,其复用实现的基本思想与4.3.2节类似:对于T中等待创建索引的列Ai,查询RTable表,如果存在可重用的源属性且源属性已创建索引则将源属性的索引信息赋值给目标索引,完成索引数据的复用.4.4基于复用的查询实现基于复用的查询实现包括4个主要的部分:查询匹配、查询重写、查询执行和结果整合.查询匹配是指查询RTable表,判断用户查询的字段是否重用;查询重写是指如果存在重用的字段,则根据映射关系重写原查询语句;查询执行是指将查询语句提交给查询引擎执行;结果整合是指对查询结果进行适当的转换,生成用户需要的查询结果集.现有数据仓库D={S1},加载目标表T前,首先根据SchemaMatching()算法与Filter()算法,得到新三元组M.然后将M的相关信息保存到RTable表中,如表3所示.最后调用Dataload_Reusing()算法,完成原始数据的装载.目标属性源属性A1A2A3现有基于表T的查询Q1如下(其中const1与const2表示任意常量):SELECTA1,A2,A3,A4FROMTWHEREA1>const1ANDA2>const2;下面在复用数据的基础上实现查询Q1.Page7(1)查询匹配.通过查询RTable表可知T中A4无法找到复用信息,而A1,A2,A3均能在S1中找到可重用数据;(2)查询重写.为了保证查询结果的准确性,首先应确保查询语句等价.Q1中对于A1>const1,由于A1=A11,即两列数据完全等价,选择条件无需改变.而对于A2>const2,A2与A12的数据之间存在转换关系,此时选择条件是否需要改变取决于目标数据的来源.已知sum1,sum2分别为T和S1的记录总数.若sum1=sum2,A2完全复用A12,则根据f原查询语句重写为Q1:SELECTA1,A2,A3,A4FROMTWHEREA1>const1ANDA2>(const2/0.1).反之当sum1>sum2时,数据来源于两部分,A12中的可重用数据及外部导入的数据.对于外部导入的数据,选择条件仍为A2>const2,查询语句不变.而对于可重用数据,查询重写为Q1;(3)查询执行.对于完全复用,直接执行Q1.对于部分复用,如4.3.1节所述,查询按照数据来源的不同被分解为两部分.由〈colt,cols〉对应的blk_id_list中可以得到每个复用关系中两部分数据的起止数据块.对于可重用数据执行Q1,对于外部导入的数据仍然执行Q1;(4)结果整合.读取可重用数据中满足条件的数据项,然后根据colt=f(cols)分别进行转换,最后整合转换后的数据并输出最终结果.4.4.1中间结果的复用数据仓库支持各种可能的查询,但是有许多查询是非常复杂的,涉及大量的数据,而且要对这些数据进行选择、投影、连接等复杂处理.这样的查询过程在传统数据库中时间开销很大,这在决策支持系统中是不能容忍的.因此数据仓库便针对可能的查询对原始数据进行连接、投影、分组等预处理,并将得到的中间数据保存到物理磁盘中,当遇到相同的查询时,可以直接重用物化的中间结果.下两个查询:同样,复用数据也能重用中间结果.例如给定如Q2:SELECTFROMS1,S2WHERES1.key=S2.key;Q3:SELECTFROMT1,T2WHERET1.key=T2.key;Q3与Q2的查询流程相同,都是对两张表进行连接,且存在如下映射关系f:T1.key=S1.key,T2.key=S2.key.传统情况下如果预先执行T1.key=T2.key且连接结果result驻留在缓冲区或存储到磁盘上,再执行Q3时可以直接重用result.复用情况下如果预先执行S1.key=S2.key或T1.key=T2.key,连接结果均能重用.复用数据中间结果的重用具体分为以下几种情况(设预先执行S1.key=S2.key,且连接结果为result1):(1)T1.key,T2.key均完全复用.查询重写模块判断两条语句的数据均来源于可重用数据,且连接条件相同,因此直接复用result1;(2)T1.key部分复用,T2.key完全复用.结果集由两部分组成,T1.key中复用成功的部分复用连接结果result1,而T1.key中从外部导入的部分继续与T2.key进行连接,得到result2,两者再取并集;(3)T1.key完全复用,T2.key部分复用,同(2).容易看出,对于数据量相对庞大的原始数据,经过预计算可以大大减少数据量,快速响应复杂查询,从而节约用户的查询时间,提高数据库的性能.但中间结果的重用与具体的查询相关,重用机率有限.而数据复用使得中间结果与源属性或目标属性均相关,增加了中间结果的重用机率,有利于大数据的查询.5实验5.1实验环境实验运行的硬件环境为IntelCoreTM2DuoCPUP8700@2.53GHz,内存2GB,操作系统为Windows7.开发环境为MicrosoftVisualC++6.0.实验中列存储其底层列存储方式为(rowid,value)二元表,rowid是为了重构元组而在每一列数据前附加的行号,每个value都与一个rowid相关.存储单元从大到小依次为段、区和数据块.列存储中一列就是一个段,每个段包括904个区,每个区包含16个数据块,每个数据块的大小为8KB.5.2数据集实验采用的数据来源于工业界和学术界都普遍采用的大规模基准数据集TPCH和SSB.TPCH中共有8张表,包含两张事实表lineitem和orders,其为雪花模式,SSB则对TPCH在模式上进行一定修改,使其成为标准的星型模型.因此,两数据集中包含许多相似属性,如lineitem和lineorder表的l_orderkey、l_linenumber列,part表的partkey、type、size列,customer表的custkey、name、phone列等,可用来进行数据复用的实验.不失一般性,我们使用SSB中事实表lineorder以及TPCH中事实表lineitem数据进行测试.实例数据集的大小由增量因Page8子SF控制.当SF=1时SSB中事实表lineorder及TPCH中事实表lineitem的数据量均为6000000行.5.3实验结果与分析假设数据仓库D已包含SSB数据集中的lineorder表,即D={lineorder},TPCH中的lineitem表为目标表.已知lineorder表共17列,lineitem表共16列.当SF相等时,两张表的记录条数相同.复用检测模型发掘出两张表属性之间的映射关系如表4所示,可以看到lineitem表中共有7列满足11完全复用,其中l_discount,l_tax列均与源属性存在单位异构,而l_receiptdate列与源属性存在日期格式异构.表4犾犻狀犲狅狉犱犲狉表与犾犻狀犲犻狋犲犿表属性间的映射关系目标属性源属性l_orderkeylo_orderkeyl_orderkey=lo_orderkeyl_linenumberlo_linenumberl_linenumber=lo_linenumberl_partkeylo_partkeyl_partkey=lo_partkeyl_discountlo_discountl_discount=lo_discount×0.01l_taxlo_taxl_tax=lo_tax×0.01l_receiptdatelo_commitdatel_shipmodelo_shipmodel_shipmode=lo_shipmode用ω表示目标表T的复用率,a表示T中复用成功的属性数目,b表示T中复用失败的属性数目,则由式(5)可知,lineitem表的复用率为7/16=43.75%.5.3.1存储量比较实验1分别采用未复用策略和本文提出的复用策略将lineitem表加载到D中,比较随着SF的增加,不同策略下lineitem表所占用的存储量.图1给出了存储量的比较结果,其中图中每组数据值均以复用后的存储量为基准进行归一化处理,如图1所示.从图1可以看出,随着表中记录条数的增长,两种策略的总存储量均按比例增长.但两者之间消耗存储空间的比例趋于稳定,未复用时占用的存储量大约是复用时的1.52倍.实际上,存储量=记录数×字段总长度.假设数据集中decimal数据类型占用4个字节,系统中附加的rowid占用4个字节.根据表的模式定义可以得到lineitem表中记录本身占用137B,所有的rowid占用4×16=64B,其中可复用的列占用42B,同时节约的rowid共占用4×7=28B,则复用情况下每条记录可以节约42+28=70B.当选择相同的SF时,理论上未复用时lineitem表占用的存储量是复用的(137+64)/(137+64-70)=1.53倍.这也间接证明了图1的合理性.5.3.2加载时间比较在实验1的基础上,我们比较不同策略下,装载lineitem表所花费的时间,同样对每组数据按复用后数据导入时间进行归一化处理.从图2中可以明显看出,不论SF如何取值,复用情况下lineitem表导入时间减少的百分比趋近于常量,大约为未复用时的45%.由于减少的百分比与目标表的复用率ω相关,当复用率较高时,复用能够节省大量的数据导入时间.5.3.3查询时间比较实验3我们比较随着SF的变化查询执行器在执行标准查询语句时执行时间的差异.选取的查询语句Q4如下:SELECTl_orderkey,l_suppkey,l_discountFROMlineitemWHEREl_orderkey<100ANDl_discount=0.01;根据4.4节提出的查询实现方法,在复用数据上实现此查询可分为如下几步:(1)由表4中的映射关系可知,Q4的目标列表中l_orderkey与l_discount列可以完全复用,Page9l_suppkey无法找到匹配列;f重写选择条件,得到Q4:(2)由于l_discount列存在单位异构,则根据SELECTl_orderkey,l_suppkey,l_discountFROMlineitemWHEREl_orderkey<100ANDl_discount=1;(3)执行Q4;(4)将返回的l_discount列的数据均乘以0.01,其它数据不变.下面我们观察随着数据集的增加,查询开销的增长趋势.如图3所示,依次将SF设定为0.5、1、2、3,分别在这些数量级的未复用数据及复用数据上执行查询,记录平均查询时间.可以观察到,当数据量比较小时,用户对两种策略的响应时间差别可能并不敏感.但当数据量逐渐增大时,复用策略由于创造了更多的重用机率,在一定程度上缩短了查询的响应时间.这种优势会在多查询语句组中体现更充分.数据仓库中查询语句的一般形式为将维表与事实表根据主外键进行连接,然后在特定维度层次上对事实表中的度量信息进行聚集.据此,我们在两个数据集中分别选取一条查询语句构成查询语句组G1:Q5:SELECTlo_part.p_brand,SUM(lo_quantity)FROMlineorder,lo_partWHERElineorder.lo_partkey=lo_part.p_partkeyGROUPBYlo_part.p_brand;ORDERBYlo_part.p_brand;Q6:SELECTl_part.p_brand,SUM(l_quantity)FROMlineitem,l_partWHERElineitem.l_partkey=l_part.p_partkeyGROUPBYl_part.p_brand;ORDERBYl_part.p_brand;可以看到这两条语句的选择性都不高,这也正符合了分析型应用中查询语句的特点.继续观察随着SF的变化,查询开销的增长趋势.由于SSB数据集中lo_part表记录数与SF呈对数关系(200000×floor(1+log2SF)),即当lineorder表为6000000行时,lo_part表为200000行,因此如图4所示将SF更改为1、2、4、8.G1的平均执行时间为两条语句执行时间和的平均值.从图中可以看到,未复用情况下顺序执行Q5,Q6,其查询时间与单独执行每条语句的时间之和相差不大.然而在复用情况下,执行Q5后接着执行Q6时由于连接条件中涉及到的两列均参加复用,因而连接产生的部分中间结果及聚集结果可以被重用,这样相当于减少了Q6的执行时间,则语句组的总时间就大大减少.从上面的过程容易看出不论是相同数据集或不同数据集,在本文方法的基础上均可再应用传统的中间结果优化方法,从而带来复用效率的进一步提升.6总结与展望本文根据列存储的特点,提出了列存储数据仓库中不同数据集之间的数据复用策略.利用模式匹配技术发掘候选可复用列,排除大量无法复用的数据列,在此基础上对候选可复用数据进行筛选和过滤,大大减少复用数据检测的复杂度.针对确定的可复用数据,提出了基于列存储的复用实现策略,以及基于复用数据的查询实现技术.实验结果验证了本文所提策略能够有效利用数据之间的冗余,在减少存储量、节省数据装载时间及提升查询性能方面具有较高效率.未来的工作将继续完善本文提出的数据复用策略,主要是优化候选数据的筛选并扩大复用策略的适用范围.
