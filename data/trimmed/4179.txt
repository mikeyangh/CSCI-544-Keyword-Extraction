Page1一种基于文法压缩的日志异常检测算法1)(中国科学院信息工程研究所信息内容安全技术国家工程实验室北京100093)2)(中国科学院大学计算机与控制学院北京100049)摘要近年来日志挖掘是一种广泛使用的检测应用状态异常的方法.现有的异常检测算法需要大量计算,或者它们的有效性依赖于测试日志满足一些预先定义的日志事件概率分布.因此,它们无法用于在线检测并且在假设不成立时会失效.为了解决这些问题,该文提出了一种新的异常检测算法CADM.CADM使用正常日志和待检测日志之间的相对熵作为异常程度的标识.为了计算相对熵,CADM充分利用了相对熵和文法压缩编码大小之间的关系而不是预先定义日志事件概率分布的族.通过这种方式,CADM避免了对日志分布的预先假设.除此之外,CADM的计算复杂度为O(n),因此在日志较大的情况下有较好的扩展性.通过在仿真的日志和公开日志集上的评测结果可以看出,CADM不仅可以应用在更广泛的程序日志上,也有更高的检测精度,因此更适合在线日志挖掘异常检测的工作.关键词异常检测;文法压缩;日志挖掘;相对熵1引言随着互联网的不断发展,各类网络应用在生产生活中发挥着越来越重要的作用.但与此同时,针对网络应用的攻击不断涌现,如各类病毒、蠕虫等①.另一方面,随着网络应用规模的不断增大以及为节省成本使用廉价机器部署服务的趋势的发展,程序的执行路径难以预测,并且硬件环境不再可靠,因此难以在部署前发现所有可能的错误.一旦针对网络应用的攻击得手或者网络应用自身出现异常,将给应用的所有者及用户带来不可估量的损失②.攻击和错误发现得越早,所能采用的补救措施就越多,造成的损失就会越少.因此,在线异常检测受到了学术界和工业界的广泛重视.常用的异常检测方法是分析应用的日志.在应用运行的过程中,应用本身和监控程序都会产生各类日志来记录应用的状态、重要的运行事件和网络流量,因此日志包含应用运行的动态信息,适合用于异常检测[1].传统日志分析通过人工检验或者使用事先定义好的异常规则来实现.当日志大小有限以及异常类型可知时,这些方法十分有效并且也比较灵活,但是对于当前程序产生的百万行规模的日志,人工检测很难实现[2],提前获取所有可能的异常也很困难[3],并且难以实时在线感知异常的发生.因此,业界使用异常检测来实现程序的自动化分析.通过建模正常日志并对待测试日志与正常模式的偏离进行检查,异常检测算法可以自动地发现可能的问题,包括未知的异常.异常检测算法通常使用一类针对离散序列的异常检测方法来分析日志.这类算法将日志所蕴含的事件序列分为段,并赋予每一段一个异常得分.之前的序列异常检测算法大都基于统计模型或者马尔可夫模型[4].但是,它们都依赖于特定的假设:(1)正常的日志事件满足一个特定的分布.(2)各个日志事件的出现互相独立.(3)日志事件的出现满足马尔可夫性质,即一条日志事件只与它之前有限个日志事件相关.但是这些假设并不总是成立.如果日志事件之间有较复杂和隐式的关系[3],这些方法就会忽略掉这些关联或者无法正确地描述这些关联[5].因此,当预先的假设不成立时,基于统计模型和马尔可夫模型的方法就会有较高的误差.为了解决上述问题,本文提出了一种基于压缩的异常检测方法(Compression-basedAnomalyDetectionMethod,CADM),这种方法不依赖于日志事件分布的假设.CADM选择相对熵作为评分标准对正常日志和异常日志进行区分[6].相对熵是一种对概率分布相似程度的度量.相对熵越大,那么测试日志的事件分布和训练日志的事件分布的区别也就越大,测试日志为异常日志的可能性也越大.但是,由于正常日志和异常日志的事件分布都是未知的,直接计算相对熵是不可行的.因此,CADM利用相对熵与压缩的关系来估计相对熵的大小.由于CADM中所需的操作仅有时间复杂度较低的压缩,因此CADM可以实现实时异常检测.综上所得,本文的贡献包括:(1)提出了一种基于压缩估计相对熵的在线异常检测方法CADM.CADM不需要提前假设日志项分布,因此,它可以应用到更广泛的场景.(2)选择并改造了一种通用的压缩方法,即文法压缩来提供更好的相对熵估计.改造后的算法具有更低的计算复杂度并且更适合用于异常检测.(3)提供了CADM的理论分析,证明了它的正确性、高效性以及可扩展性.(4)设计和实现了一个原型系统并对CADM进行评估,实验结果表明CADM具有更高的适用性和检测正确率,因此更适合用于日志异常检测.本文第2节讨论离散序列异常检测问题的相关研究;第3节描述CADM的背景;第4节详细描述CADM的设计与实现;第5节通过实验评估CADM;第6节总结本文且提出未来的研究计划.2相关工作异常检测在许多领域都有很重要的应用[7].其中,用于检测异常序列的方法被广泛地应用在日志挖掘中.文献[4]综述了现有的离散序列异常检测方法.大部分异常检测算法基于统计模型或马尔可夫模型实现.其中,基于统计模型的检测方法又可分为两类:第1类方法假设正常日志满足含参分布P(x)并使用参数估计的方法根据训练日志确定参数值,然后采用假设检验的方法去评估测试日志是否异常.例如,文献[8]提出了一种基于χ2统计量的异常①②Page3检测算法.第2类方法假设在序列中出现的日志事件独立同分布,然后通过比较待测试序列和正常序列中各事件出现的频率来确定测试序列是否异常.文献[9]采用前述频率来近似概率分布,然后通过比较两个分布的相对熵来检测测试序列是否异常.文献[10]又进一步在经验相对熵上使用χ2估计.文献[11]将PCA方法应用到频率统计向量上,如果残余方差较大,就将测试日志标记为异常.虽然基于统计模型的方法易于实现,但是如果它们的预先假设不成立,它们的准确性会比较低.在基于马尔可夫模型的方法中,最基本的方法是采用马尔可夫链来建模日志事件序列,即使用事件的频率和转移频率来估计相应的概率,然后通过计算测试日志的出现概率来判断其是否异常.文献[12]提出了一种基于一阶马尔可夫链的检测方法.虽然使用更高阶的马尔可夫链可以提高模型描述能力,但是模型参数个数随着阶的提升指数增长,因此需要更多的训练日志以及更大的内存.为了解决这一问题,学术界提出了一些马尔可夫链的变种[13-14],如可变阶马尔可夫链等,但是,此时最高的阶仍是固定的.另一类基于马尔可夫模型的方法使用隐马尔可夫模型[15-17].尽管隐马尔可夫模型比马尔可夫链描述能力更强,但是它对初始参数比较敏感,并且这些参数不易设置[4].所有基于马尔可夫模型的方法的最大问题是如果日志不满足马尔可夫性质,这些方法的检测精度会比较低[5].除以上两类方法外,也有一些方法不需要对日志事件的分布作预先假设.其中一类方法是基于核的方法.离散序列最常用的核是nLCS[18-19].但是,基于核的方法需要计算所有训练序列和测试序列的编辑距离,因此会有较高的计算复杂度[4].另外一种基于压缩的方法是文献[20]中提出的基于压缩的相异测度(CompressionbasedDissimilarMeasure,CDM).CDM是距离的一种,因此可以被广泛用于分类和聚类.但是,当CDM用于在线异常检测时,它对应我们方法阈值设为0的一个特例,因此只适用于有限的场景.3背景3.1日志转换在日志文件上应用序列异常检测方法之前,首先需要从日志中提取出各记录所对应的事件,从而将整个日志转换为一个事件序列.但是,从文本中解析出相应事件类型并不容易.传统上,有4种可能的方法:(1)无监督聚类方法.通过聚类方式将日志转化为事件需要大量计算,而且如果距离函数选择的不合适,聚类的效果也会比较差.(2)启发式算法.该算法将日志记录中的数字、路径或IP地址视为参数并将去掉参数后的消息模板视为事件.该方法比较简单易行,但是无法处理格式复杂的日志.(3)代码分析.通过分析二进制代码或者源代码[1],可以获得比启发式算法更精确的消息模板.比如,如果日志用C风格的输出,那么我们可以直接从printf的调用中区分出消息模板和参数.(4)使用领域特定的知识.在一些日志中,事件可能已经明确记录在日志中,或可以通过行号等信息准确推算出.但是,这种方式需要手工分析训练日志.3.2文法压缩文法压缩由文法转换和文法编码[21]两步组成.在文法转换中,序列会被转换成一种足够紧凑以利于压缩的上下文无关文法,即容许文法[9].文法编码使用容许文法来编码序列.文献[22]中提出的顺序压缩算法是文法压缩的一种.对于文法转换,顺序压缩算法采用了一种有效的贪心算法,该算法通过在转换过程中保持以下断言来实现:(1)如果s→αβ是一个产生式,那么s在所有产(2)所有子序列αβ只能在所有的产生式右侧出(3)所有不同的变量s1和s2展开的字符串均不生式右侧至少出现两次.现一次,除非α=β且有一个3元组ααα.相同.在每一步中,算法首先从后续序列中截取当前文法可表示的最长子序列,并将代表该子序列的终结符或非终结符拼接在产生式s0的尾端.此时有3种情况可能会出现:(a)前述3个断言均未违反;(b)新出现的模式αβ违反断言(2).算法将生成一个新的表达式s→αβ并用s代替αβ.(c)同(b)类似,但新添加的表达式导致断言(1)会被表达式s→α破坏.算法将使用α替换s,但最多只需要替换3次.Page4以上3种情况都能够在常量时间内处理.上述文法转换算法的结果是一种容许文法.在文法编码阶段,零阶自适应算术编码被用来对文法转换中每一步识别出的最长子序列对应的符号进行编码.可以证明,顺序压缩算法对所有稳定遍历的信源都是通用的,即可以将该信源产生的序列压缩至熵率.4CADM算法的设计本节将详细讨论CADM算法的设计.如图1所示,CADM算法一共包括以下3步:(1)使用背景中讨论的方式将整个日志转化为一个离散事件序列.(2)使用训练日志所转化的序列来训练CADM的模型.CADM所需要使用的训练日志为正常日志.(3)将待测试日志分段,并使用异常评分公式为每一段的异常程度进行评分.对于第1步中的日志转换,CADM结合使用方法2,3和4.大部分场景下启发式算法对异常检测任务来说已经足够精确,如果有需要,还可以通过对源码或二进制分析来精确找出所有的事件类型.最后,如果事件类型无法从消息模板中推断,那么还需要结合领域相关的知识来完成日志转换.下文将详细讨论将日志转化为事件序列后进行检测的过程,其中所用到的主要符号如表1所示.D(Q‖P)Pn或Pn在分布P与Q下长为n的事件序列的概率分布En所有长为n的事件序列,其中的事件取自事件uc()将事件看作字符并使用某种通用压缩算法压uc(m)或uc(Mm)单独压缩事件序列m或Mm所产生的编码的uc(m|M)uc(Mm)-uc(m)4.1异常评分公式本节将描述CADM所使用的异常评分公式,并对该公式给出理论分析.CADM首先将从日志转换中获取的事件序列分段.一个日志文件所对应的事件序列可以被分为若干段,每一段包含一定数量的事件.在CADM中可以使用任意的分段策略,一般情况下,CADM使用等事件数目的方式进行段的划分,即事件缓冲区中的事件个数到达指定段长时,就将事件缓冲区中的所有事件作为一段并使用评分公式进行评分.如果有可以直接利用的段的语义,如将某个用户一次会话作为一段,CADM也可以使用这种语义进行分段.段是异常检测的最小单位,每一段都会根据式(1)获得一个异常程度的评分.我们假设所有可能的事件来自一个有限但不能预知的集合E.同时,假设在当前待检测段之前,所有正常日志对应的事件序列为M,而当前待检测段的事件序列为m.那么,CADM对m的评分公式为Score(m)=1式(1)中Mm代表序列M和m按字符串拼接方式进行的连接.如果Score(m)是正值,那么当前段m就会被识别为异常.Score(m)的值越大,就说明该段异常的可能性越高.在式(1)中,λ是用来控制是否异常的阈值.整个检测过程如算法1所示.算法1.在线异常检测算法.输入:ctx:压缩过之前所有正常事件序列的压缩器输出:当前段是否异常过程:PROCEDUREDETECT(ctx,segment)Page5下文将分析式(1)的有效性.从概率的角度看,如果产生某个段的事件概率分布与其它正常段不一致,那么该段应该被识别为异常.为了衡量这种不一致性,我们采用了相对熵的概念.假设正常事件序列的联合概率分布为P而待检测段的联合概率分布为Q,那么Q和P之间的相对熵被定义为相对熵是Q和P不一致性的一种合理度量.首先,当且仅当Q≡P时,D(Q‖P)=0,否则将有D(Q‖P)>0.另外,根据Sanov定理[6],对于一个由分布Q产生的序列S,有对任意高阶的马尔可夫过程均成立.因此,D(Q‖P)的值越大,当前待检测段是由正常事件序列分布P产生的概率就越小,因此,如果D(Q‖P)超过某一特定的值λ,那么待检测的段就可以被认为是异常.另外,在CADM中,D(Q‖P)并不要求一定收敛.如果D(Q‖P)为正无穷大,那么该段也将被认为是异常.下文首先对式(1)分类错误的概率进行分析.使用相对熵,异常检测问题可以被转化为使用如下假设的假设检验问题:假设事件序列M和m的长度分别为N和n.首先假设分布P满足阶为k或更低的马尔可夫性质,最终这一假设将被消除.在P和Q未知的情况下,文献[23]中给出了针对该类异常检测问题的一个判别函数,它的主要定理如下.定理1.假设s=E1E2…Ek是长度为k的事件序列.定义qm(s)为子序列s在序列m中出现的频率,qm(e|s)为事件e在子序列s后出现的频率,即对于任意两个序列x和y定义Hs(qx,qy)=-∑S其中Hs(qx)为事件集合E相对子序列集合S的条件熵,则使用判别函数h(M,m,λ)=N+n判别假设检验问题(3),在D(Q‖P)λ+ε和NCn的情况下,正常日志误判为异常日志和异常日志误判为正常日志的概率分别为limn→∑EN即如果N大于n的一个常数倍,判别函数(4)的漏检率和误检率都很低.由于一般情况下,待检测段的长度n是固定的而当前正常事件序列的长度N是不断增长的,因此N>Cn是成立的.可以证明,判别函数(4)与P和Q已知时的最优判断函数的效果是近似的[23].但是,对于日志事件序列异常检测来说,马尔可夫假设不一定成立.另一方面,计算Hs(qMm)需要穷尽所有长为k的子序列,随着k的增长,将面临状态爆炸的问题.为了解决以上问题,在判别式(1)中Hs(qMm)被使用如下公式近似:下文将说明近似式(5)的有效性.由于CADM采用的是通用压缩算法[23],因此,对任意分布Plimn→Px1而根据Kraft不等式,随着n的增大,log(1/P(x))同时也是uc(x)的下界,因此uc(Mm)~-logP(Mm)=-∑n因此,随着n的增大,可得1N+nuc(Mm)~-limn→limn→由极限的唯一性,可以得到当n增大时,近似式(5)成立.另外,由于uc(Mm)>(N+n)Hs(qMm),因此使用判断函数(1)漏检和误检的概率满足limn→P(M,mScore(M,m,λ)>0)Page6limn→∑EN因此,判断函数(1)漏检和误检的概率有限并接近最优.事实上,从直观上看,CADM的核心是使用压缩大小来估计正常序列与待检测序列之间的相对熵.如果在错误的概率估计基础上对一个序列进行压缩,那么每一个事件压缩后相对于最优压缩的冗余l=limn→即该值等于实际概率分布与错误概率分布之间的相对熵.因此可以将CADM评分公式中的下文将分析这种估计的误差.首先,由log函数看作是对相对熵的估计而λ则是异常的阈值.的凹性及Jensen不等式,可知由Mm与M及m中各状态频率的关系可知(N+n)Hs(qMm)=NHs(qM,qMm)+nH(qm,qMm).由文献[24]及遍历定理,对k阶马氏过程有Dn(Qn‖Pn)=1n∑En=∑sqm(s)∑e=N+nnHs(qMm,qM)-N且有Dn(Qn‖Pn)>D(Q‖P)+1另一方面,使用压缩编码大小来估计Dn(Qn‖Pn)的误差为Dn(Qn‖Pn)-λ^=N(Hs(qm,qM)-1(nHs(qM)-1N(=Hs(qm,qM)-1(Hs(qm)-1(=Hs(qm,qMm)-1(Hs(qm,qM)-Hs(qm,qMm))-(Hs(qm)-1对于第1项,由于顺序压缩算法具有在线性,它编码Mm前半部分和编码M的过程一致,因此相对于经验熵产生的冗余更高.由此可知uc(Mm)-(N+n)Hs(qMm)>uc(M)-NHs(qM),所以uc(mM)=uc(Mm)-uc(M)对于第2项,由于(N+n)Hs(qMm,qM)(N+n)Hs(qMm),因此nHs(qm,qM)=(N+n)Hs(qMm,qM)-NHs(qM)另一方面,Hs(qm,qM)-Hs(qm,qMm)对于第3项,由文献[22]可知,对于任意序列s使用顺序压缩算法编码满足Hs(qs)1因此,用压缩编码大小来估计Dn(Qn‖Pn)的误差中,第1项为负,后两项为正.由于Nn,式(7)接近0,并且对Mm进行编码时式(8)收敛的程度远比对m进行编码时高.因此Dn(Qn‖Pn)-λ^中决定结果正负并占主导的项为综上,h(M,m,λ)+λλ^Dn(Qn‖Pn)D(Q‖P),D(Q‖P)-λ^=OloglognPage7于式(4),式(1)的误分类率的界略差,但实际上其对相对熵的估计更精确.另外,估计的误差主要来自n较小时对m进行压缩式(8)未能完全收敛,这与本文实验2的结果一致.为了解决这一问题,本文采用了将m进行复制压缩的策略,该策略将在实验2中描述和验证.最后,虽然理论上D(Q‖P)是非负的,但实际中使用一个负数作为λ值也是有意义的.4.2压缩算法的修改本节讨论CADM对压缩算法的选择和改造.CADM选择了一类压缩算法———文法压缩来估计相对熵.实际上,在文法压缩之前,有许多满足通用性的压缩算法.传统上它们可以被分为两类:基于显式概率估计的自适应压缩算法和基于字典的压缩算法.但是,这些算法均不适合直接用于异常检测.自适应压缩算法如算术编码一般只对符合有限阶马尔可夫性质的事件序列是通用的.在基于字典的算法中,LZ77及其变种一般使用滑动窗口来降低空间和时间开销.但是,使用滑动窗口会导致之前学习的正常模式被丢弃,从而提高了假警率.LZ78算法则已被证明是文法压缩算法的一种.CADM选择了第2节中描述的顺序压缩算法.这种算法被证明对任意平稳遍历分布均是通用的,而且相对于LZ78有更高的压缩率[22],因此可以提供更准确的相对熵估计.虽然顺序压缩算法为CADM提供了通用压缩算法的基本框架,但是由于无损压缩算法通过降低压缩率来保证唯一可译,因此需要改造以提供更好的相对熵估计.另一方面,由于异常检测不需要使用最终的编码,因此可以通过改造来降低运行时间.包括顺序压缩算法在内的所有上述压缩算法都假设所有事件的集合E在压缩开始前是已知的,但对于异常检测,在检测开始前获取所有可能的事件类型是很困难的,除非采用分析二进制代码或源码的日志转换方法.尽管存在针对未知事件集合的文法压缩算法[25],但它们依赖于关于事件分布的先验知识,因此很难在实际中实现和应用.另一方面,顺序压缩算法假设事件集合中的所有事件在压缩开始前均出现过一次来避免分母为零的问题,而事实上它们并没有出现,这种措施会降低相对熵估计的准确度,尤其是在序列较短的情况下.为了解决以上问题,在顺序压缩每一步计算频率时,CADM忽略未知事件的频率,并且只当一个事件第一次出现时才假设它们之前出现过一次来避免分母为零的问题.使用这种方式CADM避免了预知事件集合E的要求,并且提高了估计准确度.顺序压缩的第2个问题是计算算术编码的长度涉及到精确浮点数运算,从而造成很大的时间开销,尤其是当正常事件序列长度比较长时.算术编码将整个事件序列表示成[0,1]的子区间,该区间随着系统的增加而变小.假设当前事件序列对应的子区间的长度为s,新事件出现的频率为b(b∈[0,1]),那么代表整个事件序列的区间长度变为b·s.最终编码的长度与区间的长度有关,即编码一个长为s的区间需要-log2s+1位,因此算法需要维护区间的长度信息.由于精确浮点数计算使用字符数组来表示浮点数,随着事件序列的不断增长,s不断变小,表示s所需的位数也不断增加,计算b·s的复杂度也不断提高.为了解决这个问题,CADM在处理每一段时将代表之前正常事件序列的区间被重置为[0,1].这样虽然会丢失整个事件序列的长度信息,但估计相对熵仅需要使用该段序列的增量长度.这种近似对区间增量长度计算的影响非常小.假设当前段所有事件频率的乘积是B,那么采用近似方法计算区间长度导致的误差e^为e^=-log2B+1-1--log2B-1+log2s·B+log2s=-1.使用类似的方式,还可以证明e^2.因此与每一段的长度相比,在估计相对熵时e^是可以忽略不计的.但是,近似方式可以大大加快算术编码部分的速度.在顺序压缩[22]的基础上采用如上改造,最终得到的算法如算法2所示.算法2.压缩算法.输入:ctx:压缩过之前所有正常事件序列的压缩器输出:使用ctx压缩当前段的编码大小过程:PROCEDURECOMPRESS(ctx,segment)将当前段的大小估计重置为1WHILE当前段中还有事件DOsymbol←longest_match(ctx,segment)grammar_transform(ctx,symbole)arithmetic_coding(ctx,symbol)更新ctx中symbol的频率ENDWHILERETURNlog2(ctx.number)+1Page84.3计算加速与复杂度本节将描述CADM检测算法实现的细节,并分析算法的计算复杂度.在算法2中,一个比较耗时的步骤是寻找与当前所有表达式匹配的最长事件序列.如果直接采用逐个表达式进行比较的方式,该步所需的时间将随着表达式的增多而增加.为了加速这一过程,我们采用了Tire树为所有表达式建立索引.由于在顺序压缩算法中大多数表达式仅包含两个符号,因此一个表达式所表示的序列通常是另一个表达式所表示序列的前缀.使用Tire树,我们可以合并匹配这些表达式所需的计算,从而充分利用这种前缀特性.可以看出,使用Tire树索引匹配最长序列所需的时间随着最终匹配的序列长度线性增长.另一个比较耗时的步骤是发现当前段存在异常后将模型恢复到检测当前段之前的状态.一个简单的实现是在每检测一段之前复制模型,并在发现当前段存在异常后使用复制的模型代替当前模型.这种方法所需的时间会随着文法增多而变长.实际上,检测一段事件序列仅涉及到一小部分文法表达式.因此,一种更好的方法是记录下检测过程中模型发生的变化,并在检测到异常时采用与变化相逆的过程进行恢复.在顺序压缩算法中,只有当进行一次最长匹配并且代表匹配后的事件序列的符号被拼接到文法中时,模型才会发生变化,在下文中每一次这种变化被称为一小步.对于文法来说,只有新添加的表达式、在被延长的表达式以及使用这些表达式对应的非终结符的表达式需要被记录.如第2节中所述,每一小步中这3类表达式的数目均为常数.对于算术编码器,我们使用独立的Hash表来记录每一个符号出现频率发生的变化,同样,每一小步中这些变化的数量也是常量.综上所述,在每一小步中,模型发生的变化以及记录这些变化所需要的时间随着所处理的事件序列的长度线性增长.由于恢复模型仅仅是处理本段时模型变化的逆过程,因此恢复模型所需的时间也正比于所处理的事件序列长度.在模型变化和恢复的过程中,为加快匹配速度所建立的Tire树索引也需要维护.对于Tire树索引,存在3种可能的操作,即添加一条新表达式的索引、扩展一条表达式时修改索引以及模型需要恢复时将索引进行恢复.为了快速使用以上3个操作,并且考虑到在Tire树中不需要删除一个中间节点,CADM使用动态数组来存储所有的节点.从顺序压缩算法的第2种和第3种情况可以看出,当一条新表达式被添加或一条原表达式被延长时,只有新拼接的事件序列所对应的节点需要被添加到Tire树中,而该事件序列恰好是最长匹配所对应的序列,因此前两种操作的时间复杂度正比于匹配序列的长度.对于Tire树索引恢复的操作,由于新添加的节点恰好位于存储Tire树节点的动态数组的后部,因此使用单个变量来记录动态数组的末尾,可以在常数时间内完成恢复.恢复时的另一部分工作是将被删除节点从它们父节点的索引中删除.由于在每一小步中,只有一个节点位于新旧节点的边界,因此需要删除的索引数目相对于所处理的事件序列长度至多是线性的.从上述讨论可以看出,相对于事件序列的长度,异常检测算法中每一步都仅需要至多线性的时间复杂度,因此CADM的整体时间复杂度为O(n).这说明CADM具有较好的可扩展性,而且异常检测延迟不会随着事件序列的增加而增长.另一方面,CADM进行异常检测所需要的数据仅为已知的正常日志序列,因此CADM是一种线性时间复杂度的在线异常检测算法.5实验与分析本节将描述为证明CADM有效性所作的实验.我们首先在人工生成的日志进行实验并对CADM进行深入的分析,然后在公开数据集DARPA98BSM审计数据上对比CADM和其它方法.我们的原型系统使用Python2.7编写,约有3000行代码.所有实验均在一台3GB内存和1.7GHz双核笔记本电脑上进行.在实验中,我们使用公式中的测度来衡量检测精度.我们使用了ROC曲线来比较不同的方法.ROC曲线描绘了召回率与假阳性比例之间的关系,这种关系可以通过设置不同的异常阈值来获取.另外,CADM在应用到具体的场景中时,还需要首先确定所使用的分段方式.5.1马尔可夫信源在本实验中,我们在随机生成的事件序列上对CADM进行验证.本实验所用到的事件序列是由一Page9个两状态的一阶马尔可夫链生成的,该马尔可夫链的状态转移矩阵为其中p是一个可配置的参数.对于正常事件序列和异常事件序列,我们使用不同的p,因此它们符合不同的分布.异常检测算法负责将异常序列从正常序列中识别出来.我们使用两类不同的序列对CADM算法进行评估.对于第1类序列,如果马尔可夫链在两类状态下分别输出字符“0”和“1”.而对于第2类序列,两种状态下的输出分别变为“30”和“31”,因此马尔可夫生成器的状态轮换无法直接从最终生成的事件序列中获取.对于每一类序列,我们设计了两个测试用例,在每个测试用例中,马尔可夫生成器选取特定p值生成10000个事件作为训练序列.待测试的序列包含16000个事件.在待测试的序列中,前8000个序列为生成器使用与训练序列相同的p值,因此前8000个事件应被识别为正常;后8000个序列则使用不同的p值生成,因此应被识别为异常.我们将正常序列的p值记作pn,异常序列的p值记作pa.另外,我们采用等事件数分段的方式,每一段的事件数设为80.在每个测试用例中,针对较易检测和较难检测两种场景,我们分别选取pn=0.2,pa=0.8以及pn=0.5,pa=0.8两组值作为代表.作为比较,我们首先将文献[12]中提出的马尔可夫模型应用到这两个测试用例上.该方法首先使用训练数据来训练一个一阶马尔可夫模型,并使用该模型来判断每一段出现的概率,如果概率较小则视为异常.将马尔可夫模型应用到两个测试用例上的结果如图2所示.对于第1个测试用例,当pn和pa差距较大时,马尔可夫模型对正常序列和异常序图2马尔可夫模型对人工生成数据进行异常检测的结果列的概率估计有明显的差异,因此可以将这两类序列分辨开.但是,当pn=0.5,pa=0.8时,由于差距比较小,马尔可夫过程没能将这两类序列分辨开.对于第2种测试用例,无论pn和pa的值是什么,马尔可夫模型均无法将两类序列分辨开来.这说明马尔可夫的性质不仅与测试场景的难度有关,当序列不符合马尔可夫性质时,即使在测试场景比较简单的情况下,马尔可夫过程也无法将序列分辨开.然后,我们将CADM算法应用到这两个测试用例上,测试结果如图3所示.对于第1种情形,CADM的结果不比马尔可夫模型差.但是,对于第2个测试用例,当序列上的马尔可夫性质不成立时,传统的马尔可夫模型无能为力,CADM仍然有效.这是因为CADM不依赖于序列概率分布上的假设.因此,CADM可以被应用到更广泛的场景下,并且在没有关于序列概率分布的先验知识时会有更优的检测结果.图3CADM对人工生成数据进行异常检测的结果5.2参数调优与分析在本实验中,我们将CADM应用到上一节中的马尔可夫生成器生成的更多测试用例上以对CADM进行评估和分析.我们采用等事件个数的分段方式并首先将每一段大小设为80,并且将异常检测阈值和学习阈值均设为0.由于在前一实验中,CADM在pn=0.5,pa=0.8的测试用例中表现较差,本实验中采用相似的测试用例进行测试,并使用易测试的用例pn=0.2,pa=0.9作为对比.上述实验的结果如表2所示.在这个表格中,还列出了正常序列与异常序列概率分布的真实相对熵值.从表2中,我们发现在当前参数下,CADM在一些测试用例中召回率特别低.另外,召回率与正常事件序列及异常事件序列的相对熵存在联系.当正常序列与异常序列的相对熵差距较小时,算法将失效.为了找出算法失效的原因,我们在图4中描绘了Page10pn=0.2pa=0.40.15180.8000.0420.0500—0pn=0.2pa=0.50.321390.9750.2040.1070—0pn=0.2pa=0.60.5511611.0000.8390.1830—0pn=0.5pa=0.70.1190—00.0390—0pn=0.5pa=0.80.27841.0000.0210.092110.003pn=0.5pa=0.90.531351.0000.1900.1770—0pn=0.2pa=0.91.6521921.0001.0000.55037111部分测试用例的详细结果.由于CADM算法的本质是使用增量压缩的大小uc(m|M)和单独压缩的大小uc(m)的差来估计相对熵,每一段的uc(m|M)和uc(m)的大小对估计和检测的准确度至关重要.因此,对于一些测试用例,我们在图4中描绘了每一段增量压缩大小和单独压缩大小.在图4中,左上角的图描绘了最理想的情况:对于正常的段,uc(m|M)和uc(m)十分接近,因为D(Q‖P)等于0;对于异常的段,uc(m|M)有一个明显的增量,因为异常的段是在错误概率估计的基础上进行压缩.利用这个差异,算法可以很容易地将正常序列和异常序列区分开来.但是,从其它几幅图可以看出,当相对熵较小时,uc(m)的冗余超过了使用错误概率压缩时uc(m|M)的增量,从而导致了漏检.因此,算法失效主要是由于对m进行压缩时结果编码相对于信源熵率冗余过大.另外,从左下角图片还可以看出错误学习假阴性的序列会导致对正常事件序列的概率估计发生偏移,从而加重漏检的情况.图4对于特定测试集单独压缩和增量压缩大小的关系对于错误学习的问题,可以通过使用较高的学习阈值来解决.另一方面,可以通过增加每一段的事件数W来增加压缩率.通过使用较长的段,测试序列中的重复结构可以被充分利用,其单个事件压缩后的大小会更加接近信源的熵率,从而提高了相对熵估计的精确度.使用不同窗口大小的效果如表3左半部所示.对于每一个测试用例,我们列出了不同窗口大小下所有异常序列的相对熵估计λ^=1/n[uc(m|M)-uc(m)]的平均值.另外需要指出的是,在段的长度不同的情况下进行实验时,训练序列的长度应该随着段的长度线性增长,因为定理1中要求正常序列大小和段的大小满足条件NCn.从表中,我们可以看出相对熵估计值和理论值之间的差异随着段的长度增大而减小,因此使用较长的段有利于提高召回率.表3不同窗口大小及是否采用重复对估计精度的影响测试段长度pn=0.2,pa=0.4-0.104-0.069-0.062-0.0490.01230.0230.0320.056pn=0.2,pa=0.50.2160.0740.0560.1350.2230.2980.2410.241pn=0.2,pa=0.60.2460.2480.2710.3660.4090.3900.4190.477pn=0.5,pa=0.7-0.192-0.174-0.124-0.139-0.030-0.027-0.006-0.031pn=0.5,pa=0.8-0.0630.0220.0590.0610.0820.1300.1520.162pn=0.5,pa=0.90.1330.1800.2550.3320.2940.3470.4060.424但是,实际中段的长度无法设置得非常大.首先,段越长,每一个警告所能提供的信息就越小,因为管理人员需要通读整个段的日志来确定异常发生的原因.其次,在实际日志中,异常相关的信息在日志中可能不是连续的,如果使用较长的段可能导致异常信息引起的相对熵的差异被周围正常的日志所湮没.最后,如前所述,使用较长的段意味着必须使用更长的训练日志.Page11为了解决段长度的矛盾,CADM使用了另外一种方法来加速单独压缩时的压缩大小的收敛过程,即将该段的日志复制一份拼接到该段之后,然后使用处理后的段的压缩大小的一半作为对压缩大小的估计.对于文法压缩来说,这种方式使前半部分创建的表达式规则在后一段中充分使用,因此可以提高相对熵估计的精确度.使用这种方法后对不同段的长度的估计值如表3右半部分所示.可以看出,复制的方法可以使用一个较小的段长度,从而避免段过长带来的问题,也可以减少估计误差.即使使用复制的策略,当正常序列与异常序列的实际相对熵过小时,仍然会发生错误分类的情况.但是,实际中异常对应事件序列与正常序列之间的相对熵一般可以满足检测的要求.如果不能,就需要更换日志转换的策略,使用更多的信息来增大异常序列与正常序列的实际相对熵.5.3DARPA98日志检测在本节中,我们使用DARPA98BSM测试集①对CADM进行验证.DARPA98BSM测试集是一个开源入侵检测测试集,它的数据来自于一个Solaris集群9周内的BSM审计日志.在DARPA98测试集中,所有的BSM审计日志都被划分为会话,每一个会话对应于两台服务器之间的一次TCP连接.不同的会话可能属于不同的服务.每一个会话的系统调用序列被记录在了审计日志中.会话是BSM审计日志的最小单位并且标注了是否异常,因此我们将每个会话视为测试日志中的一段,对每一个会话的异常程度进行评估.在本实验中,我们仅使用了会话中的系统调用类型信息.整个测试集中一共有50种系统调用.在原始数据中,不同服务的会话是混合在一起的.我们首先根据会话所属的服务对会话进行分类.然后,我们选择那些有足够数量正常会话与异常会话的服务作为测试集.一共有4种服务满足我们的要求,即FTP、SMTP、Telnet、Finger,因此整个测试包括4个测试用例.在某些测试用例中,我们注意到一些被标记为攻击的会话与某些标记为正常的会话有相同的系统调用序列,这说明这些攻击的检测无法仅通过调用类型信息实现.在本实验中,我们移除这些会话.另一方面,BSM审计日志中的每一个会话均由包括多个进程的调用序列组成,这些序列也是混合在一起的.我们重排了每一个会话中调用事件的顺序,使得来自同一个进程的调用事件彼此相邻.之后,对于移除重复会话后的剩余会话,我们以天为单位随机地将所有正常会话平分,分别作为训练集和正样本集.最终形成的测试集的信息如表4所示.测试集训练日志Finger第1周FTP第1~3周,T1,T3第4~7周233Telnet第一周星期1,3,5第一周星期2,4113SMTP第一周星期1,2第一周星期3,4,5120我们选择马尔可夫模型[12]和统计模型[9]作为对比.3种方法都会对每一段的异常程度进行评分.但是,原文中马尔可夫模型假设各个段的长度是相同的,这一性质在本实验中并不成立.因此,原始马尔可夫模型倾向于将长的段标记为异常.为了解决这一问题,我们使用如下公式对马尔可夫模型的评分进行正规化:最终的测试结果如图5所示.从图5中可以看出,虽然4个测试集难度不同,但在所有测试集中,CADM的结果都优于其它两种方法.这说明独立性假设和马尔可夫假设在这些测试集上都不成立.为了进一步说明统计方法和马尔可夫方法失效的原因,我们选择Telnet测试用例并在图6中画出了每一个系统调用及相邻的系统调用对出现的频率.根据统计方法和马尔可夫方法依赖的假设,上述频率是这两种方法进行异常检测时所依赖的所有信息.如果正常序列和异常序列从这些频率信息上无①Darpa89测试集http://www.ll.mit.edu/mission/commu-Page12法分辨,则可以预期这两种方法无法有效工作.从图6中可以看出,正常序列和异常序列的这两种频率分布基本相似,这就解释了马尔可夫模型和统计模型失效的原因.图6系统调用和相邻系统调用对的频率的统计类似BSM审计日志,现实日志中事件的概率分布可能比较复杂,使用简单直观的假设将无法捕捉到异常日志的特征.从以上实验中,我们可以看出,通过去移除对这些假设的依赖,CADM可以在更大范围的日志上有更好的效果.因此,CADM更适合用于日志的在线异常检测.5.4可扩展性在本实验中,我们对CADM的运行效率进行评测.我们使用5.1节中的马尔可夫生成器生成不同长度的日志,然后以一种离线的方式测量CADM在这些日志上的运行时间.最终测试的结果如图7所示.从该图可以看出CADM是一种线性时间复杂度的算法,无论已经运行多长时间,CADM检测到异常的时间延迟都不会增长.因此,CADM有较好的可扩展性,更适合于在线异常检测.图7CADM在不同大小日志上的运行时间6结论本文提出了一种新的离散序列异常检测方法CADM,并且给出了这种方法的理论分析和实验评估.CADM选择相对熵作为测试日志与异常日志的度量并且使用压缩后的编码大小来估计相对熵.从实验中可以看出,与其它方法相比,CADM不依赖于关于概率分布的先验知识并且具有线性时间复杂度,因此更适合于在线异常检测.本文进行日志转换时使用了现有的方法.由于日志转换对整个异常检测过程的准确度非常重要,因此在未来我们将研究针对专用的文本和高维数据的序列转换方法.
