Page1GR犽NN:空间数据库中组反犽最近邻查询宋晓宇于程程孙焕良许景科(沈阳建筑大学信息与控制工程学沈阳110168)摘要反k最近邻(Reversek-Nearest-Neighbor,RkNN)查询是在k最近邻(k-Nearest-Neighbor,kNN)查询问题的基础上产生的,获得将查询对象作为kNN的数据对象集合,RkNN可以用于评价查询对象的影响力.根据实际应用中需要查询一组对象的RkNN,如评价连锁店或商业区的影响.文中提出了针对空间数据库的组反k最近邻(GroupRkNN,GRkNN)的概念,并设计了相关算法.查询点集合是一组邻近的空间对象,计算查询对象的最小覆盖圆,将最小覆盖圆中的对象作为一个整体进行过滤,设计了基于R树的剪枝方法,通过提炼获取了最终的GRkNN结果.针对真实数据集进行的大量实验表明,提出的GRkNN算法的效率明显优于目前最好的RkNN算法.关键词反最近邻;GRkNN查询;R树;最小覆盖圆1引言随着位置传感装置的广泛发展(如GPS接收),基于位置的服务得到了广泛的应用[1],RkNN查询Page2群就是RkNN查询所要找的影响集.RkNN查询可以分为单色RkNN(monochromaticRkNN)和双色RkNN(bichromaticRkNN),单色RkNN就是查询点所在数据集和查询结果所在数据集是一个数据集,而双色RkNN处理两个数据集.现有的对于RkNN查询的解决方案[2-7]均是针对单个查询点进行处理.考虑一个实际情况,查询一个商业区(由一组空间对象组成)的RkNN结果,或查询一个连锁店的RkNN结果.针对这一应用需求,本文提出一种新的针对空间数据库的RkNN查询———GRkNN查询(GroupRkNN,GRkNN),该查询可以用于评价一组对象的影响.解决该问题的直接方法是计算单个查询对象的RkNN,再求出所有查询结果的并集,即为查询点集合的RkNN结果.显然,当组内对象较多时,由于未能利用组内对象的紧邻关系进行查询,查询效率会较差.本文采用R树[8]索引空间对象,采用过滤-提炼的框架模型.在过滤阶段,计算包含所有查询点的最小覆盖圆,以该圆为整体结合一组数据集子集S来计算该组查询点RkNN的搜索区域,在这个查询区域的所有对象都是该GRkNN查询的候选集,而计算这个搜索区域的算法是CINCH;在提炼阶段,对Range-k验证方法[2]进行改进应用到GRkNN查询中,去除非GRkNN查询结果的候选者,从而最终得到查询结果.实验结果表明,提出的GRkNN算法的效率明显优于目前最好的RkNN算法.本文第2节介绍相关工作;第3节是问题定义;第4节具体介绍GRkNN查询算法;第5节介绍双色GRkNN算法实现;第6节介绍本文所提出的算法的性能测试;第7节总结全文.2相关工作Korn和Muthukrishnan[3]提出了RNN查询的概念,即(RkNN,k=1),并给出了求解RNN的查询方法.设计了一个新索引结构RNN树以求得查询对象q的反最近邻.为了解决两个索引结构的问题,Yang和Lin[4]提出了将这两个索引结构合并在同一个称为RdNN树的索引结构中,其叶节点存储了数据点的邻接圆,中间节点存储了子树中的点到其最近邻的距离的最大值.以上方法依赖于预计算,近年来有许多学者已经提出了一些解决方法[5-7],均使用了过滤-提炼的模型框架,过滤阶段剪枝确定不包含候选者的部分,提炼阶段去除错误项.2.1过滤方法2.1.160度剪枝法由Stanoi[5]等人提出的60度剪枝法,其主要思想是:将围绕一个RNN查询点q的空间等分为6个区域(S1,S2,…,S6),然后在每个区域中,只有q的最邻近位置才可能是q的反邻近位置.由此,q的RNN候选者被限制在6个区域中q的最邻近位置上.该方法不需要特殊的索引结构,避免了数据点更新时频繁的计算和修改索引结构,相对于文献[3-4]效率较高.同时,可以处理移动对象的RkNN,也可以扩展到k>1的情况.但是随着空间维数的增加,需要搜索的区域空间会成指数增长,甚至在3维情况下,其效率会变得很低.2.1.2TPL剪枝法Tao[6]等人提出的TPL剪枝法,其基本思想如图1所示:查询点q与P中任意点p做垂直平分线,分空间为q-half-plane与p-half-plane(也称为q--half-plane),在p-half-plane内的点不可能是q的RNN.TPL过滤过程如下:用广度优先的方法遍历R树,再以节点到查询点q的距离的升序堆中检索潜在候选者,因为RNN(q)很可能在q的附近,半平面的概念用来剪枝不存在候选者的MBRs.每次被剪枝的条目被加入到提炼集Srfn中,在提存阶段,Srfn中的条目被用来排除错误项.TPL剪枝法比60度剪枝法有更强的剪枝能力[6].同时,TPL剪枝技术也可扩展到k>1的情况.与前面介绍的方法相比,该方法效率提高了,但是该方法只适用于静态查询点的情况.此外,TPL方案花费了相当多的时间去寻找可用于剪枝的对象.2.1.3INCH空间缩减法Tan[7]等人也采用过滤-提炼的模型框架,在TPL的提示下提出了INCH空间缩减法算法,它的基本思想是:计算出一个RkNN查询的搜索范围(从查询结果候选者中确定),这个搜索区域约束了搜索空间,并且每当一个新的结果候选者被找到的时候这个搜索区域都会被缩小,最终确定出候选者集合.具体INCH缩减过程如下:首先找到一个数Page3据集的子集S,每个子集与查询点做垂直平分线从而将空间划分成多个多边形,然后根据多边形所在的q--half-planes的个数来计算每个多边形的水平值,将所有多边形水平值小于k的连接起来形成搜索区域.INCH空间缩减法利用TPL剪枝的基本原理,将单个用于剪枝的对象扩展到一个对象集,减小了搜索区域,提高了查询效率.根据实验和分析的结果显示出,INCH空间缩减法比TPL剪枝法有更好的空间剪枝能力[7].但是该方法也只针对单一查询点的剪枝法.2.2提炼方法提炼方法包括两种:(1)基础kNN法,主要是在文献[5]中使用,计算每个候选点的kNN,并查看结果是否为查询点,如果有,则该候选点为给查询点的RkNN的查询结果,反之,则不是.(2)Range-k验证法,对每个候选点进行核对,判断核对的候选点到查询点的距离比到其它候选点的距离小的个数是否小于k,如果是,则该候选点为该查询点的RkNN的查询结果,反之,则不是.这个方法被提出在文献[2]中,虽然它是针对解决连续RkNN查询的,但是Range-k验证法比基础kNN方法更有效.现有的解决方法均是针对单个查询对象的RkNN,本文采用过滤-提炼的框架模型设计了新的算法实现了GRkNN查询.过滤阶段利用了INCH空间缩减法的基本原理,但不同的是将查询点集合的最小覆盖圆作为整体来确定搜索区域,从而避免了当查询点集是一组邻近的数据对象时搜索区域的频繁重叠情况,提高了查询效率.提炼阶段则采用Range验证法来排除错误项.3问题定义本节给出kNN、RkNN等查询的基本概念,从而引出GRkNN查询的定义.给定二维空间数据集P和R,其中包含形如p(x,y)的数据点,dist(p,q)代表两个点p、q之间的距离.定义1.kNN(q,k,P)[9](k最近邻查询).给定数据集P,当且仅当一个对象p∈P满足{o∈P|dist(o,q)<dist(p,q)}<k时,p是kNN(q,k,P)的一个结果.kNN查询实际就是查找离查询对象最近的k个对象,它的查询结果一定是k个.定义2.单色RkNN(q,k,P)[3].给定一数据集P和一个查询点q,若对象p的kNN包含q,则对象p是RkNN(q)的查询结果.具体定义形式为RkNN(q,k,P)={p∈P|q∈kNN(p,k,P)}.单色RkNN查询是获得给定的数据集中将查询点作为k最近邻的一个结果的点的集合.查询对象q可以是数据集P中的点,也可以不是.定义3.双色RkNN(q,k,P,R)[2].它包含两种数据集P和R,P是查询点q所在的数据集,R是查询结果所在的数据集,对于每个r(r∈R)的kNN(r,k,P)中,如果包含q,则此r即为双色RkNN(q,k,P,R)的一个结果.具体定义形式为BRkNN(q,k,P,R)={r∈R|q∈kNN(r,k,P)}.双色RkNN查询是获得查询数据集中将查询点作为k最近邻的结果集中点的集合.定义4.Range-k(p,k,r)[2].判断p点周围的点到p的距离小于r的点的个数是否小于k,如果{o|dist(p,o)<r}<k成立,则返回true,否则返回false.本文在过滤阶段使用Range-k验证法来排除错误项.定义5.GRkNN(GroupRkNN).给定一组查询点集Q={q1,q2,…,qn}和一个数据集P,当一个对象p∈P在P上的kNN的结果包括Q中的任意一个时,p就是GRkNN(Q,k)的一个结果,具体定义形式为GRkNN(Q,k)={q∈Q,p∈P|q∈kNN(p,k,P)}.对于GRkNN的查询,不论在单色或是双色的情况下,结果就是查询点集中每个查询点的RkNN或BRkNN结果的并集.查询点集Q中的查询点可以是数据集P中的点,也可以不是.4GR犽NN查询算法本文采用R树作为索引结构,受TPL空间剪枝法以及INCH空间缩减法的启发,本文GRkNN查询采用过滤-提炼的框架模型,过滤阶段以查询点集合的最小覆盖圆为整体确定最小覆盖圆的RRkNN的搜索区域从而得到GRkNN的候选集合,提炼阶段采用Range-k验证法排除错误项,从而得到最终结果集.4.1最小覆盖圆给定点集的最小覆盖圆,即包含给定点集且半径最小的圆,如图2所示,圆O就是点集{q1,q2,q3,q4}的最小覆盖圆.本文采用汪卫和王文平在文献[10]中所提出的计算给定点集的最小覆盖圆的方法Page4来计算查询点集的最小覆盖圆.下面我们给出圆的一些相关定义、定理及其证明,从而作为以查询点集合的最小覆盖圆为整体来进行过滤剪枝的理论依据.定义6.点与圆的垂直平分线.某点p与一个以点c为中心r为半径的圆O的垂直平分线,就是直线l(p,c)与圆的交点m与p的垂直平分线,用⊥(p,O)表示.l(p,c)表示p与c两点形成的直线.如图2所示,圆O与p的垂直平分线就是⊥(p,O).一个点p与一个以点c为中心r为半径的圆O间做垂直平分线将空间分成两部分,包含点p的半平面叫作点p-half-plane(也统称为珚O-half-plane),包含圆O的半平面叫作圆O-half-plane.定义7.点到圆的距离.某点p到一个以点c为中心r为半径的圆O的距离记为d(p,O),当dist(p,c)>r时,d(p,O)=dist(p,c)-r;当dist(p,c)r时,d(p,O)=0.如图2所示,以点c为中心r为半径的圆O外有一点x,点x到圆O的距离d(x,O)=dist(x,n),n是直线l(x,c)与圆O的交点.定理1.给定点p和以点c为中心r为半径的圆O,在p-half-plane内的点(不包括p)不可能是圆O内任意点的R1NN.证明.本文通过反证法来证明定理1.如图2所示,圆O与点p做垂直平分线,根据定义2,实际上是直线l(p,c)与圆的交点m与p的垂直平分线,假设O-half-plane内存在一点x使得dist(x,p)<d(x,O),其中x存在两种情况,一是x在圆O内或边界上时,d(x,O)=0,可推出dist(x,p)<0,这与事实dist(x,p)0相矛盾,因此假设不成立;另一种情况是x在圆O外时,圆心c、点m和点x形成一个三角形,而dist(c,x)=dist(n,x)+dist(n,c)=d(O,x)+r,dist(c,m)=r,其中d(O,x)>0,根据两边之差大于第三边的几何原理,则有dist(c,x)-dist(c,m)=d(O,x)<dist(x,m),而根据假设dist(x,p)<d(x,O),则有dist(x,p)<dist(x,m),由于假设与事实dist(x,p)>dist(x,m)相矛盾,假设不成立.即得证.根据定理1可知,在p-half-plane内的点不包括p,不可能是圆O的R1NN的结果,因为相对于圆O来说p-half-plane内的点离p更近.4.2过滤过程GRkNN查询采用过滤-提炼框架模型,过滤阶段需要快速剪枝一些对象而得到一组候选集合.如果将所有查询点分开考虑会将问题复杂化,因此将所有查询点的最小覆盖圆作为整体考虑,然后进行剪枝.首先计算GRkNN查询点集Q的最小覆盖圆O,将圆O作为一个整体,利用给定的空间数据集子集SP,做S中每个点与圆O的垂直平分线,将空间分割成多个多边形,如图3(a)所示,其中S={p1,p2,p3,p4,p5}.然后再计算每个多边形level值,多边形的level值就是该多边形所在的珚O-half-planes个数,如图3(b)所示,如果多边形的level值小于k(GRkNN查询的k值)就说明该多边形至多在k-1个珚O-half-planes内,而这样的多边形就有可能包含该圆内所有点的RkNN结果,将这样的多边形放在一起就形成了圆O内所有点的RkNN的候选区域,如图3(c)所示的粗黑色边框区域.由于候选区域包含的是圆O内所有点的RkNN结果,而GRkNN查询的查询点集Q都在圆O内或圆O上,因此该区域也是查询点集Q的GRkNN的结果候选区域,而这也解释了为什么将查询点集合的最小覆盖圆而不是任意一个包含所有查询的圆作为一个整体来考虑解Page5决GRkNN查询问题的原因,由于包含所有查询点的圆越大,计算所得的搜索区域就可能越大,候选集合就越大.由于由多个多边形组成的候选区域不利于存储利用,因此形成如图3(d)所示红色边框的凸外包多边形,这个凸外包多边形就是GRkNN的搜索区域.在搜索区域内的所有数据对象和S都是查询的候选者.4.3CINCH:以圆为整体计算GR犽NN的搜索区域本文基于过滤-提炼框架模型实现GRkNN查询.过滤阶段确定的搜索区域,实际上是最小覆盖圆内所有点的RkNN查询的搜索区域,由于GRkNN的查询点集包含在圆内,因此该搜索区域内的数据点也是GRkNN查询的候选者,所以该搜索区域也是GRkNN查询的搜索区域.最后再在提炼阶段将非GRkNN查询结果的错误项排除.本文提出的CINCH(CircleINtersections’ConvexHull)算法就是将所有查询点的最小覆盖圆作为整体来计算GRkNN的搜索区域的算法.CINCH算法的基本思想是:给定一个对象集SP,P是整个数据集,对于S中所有对象分别做它们与该GRkNN最小覆盖圆O的垂直平分线,从而将空间分为多个多边形,计算每个多边形所在的珚O-half-planes个数,数值小于k的多边形组成的外包凸多边形即为该GRkNN的搜索区域.搜索区域内的对象和S的并集就是GRkNN的候选集.CINCH算法的伪代码如算法1所示.算法1.CINCH(O,k,S).输入:整个数据集合P的子集S,SP输出:以凸多边形的形式返回查询的搜索区域1.计算S中每个对象与O的垂直平分线;2.计算交点;3.计算每个交点的level值;4.把level值小于k的交点放入集合I中;5.计算返回I内所有点形成的凸外包多边形区域.第1步.分别做S中所有点与O的垂直平分线,将整个空间分为多个多边形,如图3(a)所示.第2步.计算垂直平分线间的交点和垂直平分线与空间边界的交点以及空间边界间的交点,如图3(b)所示交点{a,b,d,…,n,r,…,x}.第3步.计算每个交点的level值,某交点的level值等于该点所在的珚O-half-planes的个数,不包括形成这个点的垂直平分线相应的珚O-half-planes.例如,在图3(b)中,level(v)=0;level(d)=1.第4步.把level值小于k的交点放入集合I中.第5步.利用集合I内的点形成的多边形就是候选区域,如图3(c)所示的{d,e,x,g,h,w,j,k,v,u,t,s,y}区域,但由于候选区域是由多个多边形组成,在计算候选时不便于存储利用,因此形成如图3(d)所示的粗边框{d,e,g,h,j,k,u,s}凸外包多边形,这个凸外包多边形就是搜索区域.如果S中对象的个数小于k,则搜索区域就是整个空间.定理2.CINCH算法的复杂度是O(m2log(m)),其中m是S中对象的个数.证明.第1步计算垂直平分线的代价是O(m).第2步计算交点的代价是O(m2).第3步计算交点的level值是O(m2),因为S中的对象是逐个加入的,对于计算交点level值是随交点增加而计算和更新的.第4步集合I的代价大小至少是O(m2).计算凸多边形的复杂度是O(nlog(n)),n是形成凸多边形点的个数;因此第5步的代价至少是O(m2log(m)).定理3.CINCH算法不会误拒结果对象.证明.只需证明CINCH算法所确定的搜索区域之外不包含任何结果.根据文献[7]提出的定理2,给定一个数据集P、一个RkNN查询RkNN(q,k)及一个数据对象子集SP,设C为由算法INCH(q,k,S)所计算形成的搜索区域,对于在P-S内的任意点p,当且仅当p在C内或边界上时,有level(p)<k.本文提出的定理1说明CINCH算法与文献[7]提出INCH算法依据的原理相同,由此该定理也适用于CINCH算法.既当C为算法CINCH(O,k,S)计算形成的搜索区域时,该定理同样成立.根据文献[7]提出的定理2,对于在P-S内的任意点,当p在C外时p的level值一定不小于k,即p所在的珚O-half-planes的个数大于等于k,p就不可能是圆O内任一点的RkNN结果;换句话说,在搜索区域C外一定不包含结果对象.因此该定理也证明了CINCH算法的正确性,这里不再赘述.4.4过滤算法过滤阶段,根据给定的GRkNN(Q,k)和一组数据对象SP,首先计算查询集Q的最小覆盖圆O,然后利用CINCH算法计算查询的搜索区域SR.基于S和SR,查询候选集合就是S∪S,其中S是SR∩(P-S).S的选择能影响查询候选集的大小,还能影响接下来从S∪S中排除错误候选者的提炼阶段的效率.而对于利用CINCH算法计算而得的搜索区域Page6有以下性质:(1)随着S中对象的增加,搜索区域会越来越缩减.(2)将距离圆O更近的对象加入到S中,搜索区域会更小.根据以上两个性质采用迭代的方法,首先令S为空,然后初步依次增加圆O外距离圆O最近的数据对象到S中,从而缩减搜索空间.我们利用R树实现过滤算法,对于扩展S的方法是给圆O更近的点更高的权限来加入S.使用R树作为数据的索引结构,广度优先遍历R树,数据以升序排列,在圆O外的数据对象依次加入S中,这个具体的以R树作为索引结构的Filter算法的伪代码如算法2所示.算法2.FCINCH-Filter(O,k).输入:包含查询点集的最小覆盖圆O输出:包含查询结果的候选集合1.S··=;Scnd··=;SR··=整个数据空间;2.H为(e,key)的最小堆;3.插入(R树根节点,0)到H中;4.while(H不为空){5.从H中提取出一个(p,key);6.if(p.MBR与SR相交)then7.if(p是一个索引节点)then8.for(p中每个子节点m)9.if(m.MBR与SR相交)then10.插入(m,min-dist(m,c))到H中;11.elseif(p是叶子节点)then12.for(p中每一数据对象n)13.if(n与SR相交)then14.插入(n,dist(n,c))到H中;15.else{Scnd··=Scnd∪{p};16.if(key>0)then{17.S··=S∪{p};18.SR··=CINCH(O,k,S);}//endif}}19.returnScnd,S.算法FCINCH-Filter为了广度优先遍历R树,设置了一个形为(p,key)的最小堆H,其中p既有可能是R树的一个索引节点,也可能是R树的叶子节点,或是一个数据对象;key则是p与圆O的圆心c的最小距离,r是圆O的半径.S初始化为空,用来存放形成搜索区域SR所用到的数据集,Scnd初始化为空,用来存放候选者的集合(第1步).将R树根节点插入H中对H进行初始化(第2步),遍历R树的过程中,通常从H中选择离圆心c最近的对象或是项目(第5步),每当从H中选择出的一个数据对象p时就将p加入到Scnd中(第15步),如果p对应的key值大于0(即p点在圆O外),则将p加入到S中(第17步),因为圆O内所有数据对象都是一个整体,找圆O外的数据对象加入S中才有意义(key=0表示在圆内或在圆上),同时CINCH算法将搜索区域缩减(第18步).也就是说候选者集合Scnd是S和圆O内所有数据点的集合.由于搜索空间是随着数据对象不断地加入到S中而迭代缩减的,由此CINCH算法中每当有新的数据对象加入到S中时,就需要更新维护搜索区域和相关信息(例如,垂直平分线、交点和它们的level值),并且优化计算量,也就是将第17步进行优化.4.5提炼阶段提炼阶段,排除在过滤阶段得到的GRkNN的结果候选集Scnd的错误项,提炼算法伪代码如算法3所示.算法3.FCINCH-Refine(Q,O,k,S,Scnd).输入:查询点集Q输出:GRkNN结果集1.SR··=CINCH(O,k+1,S);2.for(Scnd中每个数据对象p)3.if(p不在SR内)then4.Scnd··=Scnd-{P};5.for(Scnd中每个数据对象p){6.if(p∈Q)then7.r··=min{dist(p,{Q-p})};8.else9.r··=min{dist(p,{Q})};10.if(Range-k(p,k,r})returnfalse)then11.Scnd··=Scnd-{P}};//endfor12.returnScnd.候选者提炼分为两个阶段:第1个阶段是(第1~4步),用算法CINCH(O,k+1,S)计算新的区域来排除错误项.当一点p被选择加入到S中,Snew是p加入到S后S的数据集,Sold是p没加入S之前S的数据集,它们的关系式Snew-Sold={p},p在以Sold为参数计算而来的搜索区域中,也就是说p是在至少k-1个珚O-half-planes内,随着不断地有新的数据对象加入到S而最终变成现在的S,p所在的珚O-half-planes的个数就很有可能大于k-1个,而p又一定在它自己的p-half-plane内,如果p是错误项,则需要满足p至少在k+1个珚O-half-planes内的条件,因此我们计算k+1条件下的搜索空间用来排除错误项.第2个阶段是(第5~11步),使用Range-k验证法分别验证每一个候选对象来进一步Page7排除错误项.候选集合Scnd中有可能包括查询点集Q中的一个或多个,因为Q中某一查询点可能是另一查询点的RkNN,因此当候选者是查询点时(第6步),函数Range-k的参数r为min{dist(p,{Q-p}}(第7步),其中min{dist(p,{Q-p}}是p到数据集{Q-p}中所有点的距离的最小值,因为p是查询点,它距离除它之外的哪个查询点最近,就可能是那个查询点的RkNN;如果候选者不是查询点,则函数Range-k的参数r为min{dist(p,Q)}(第9步),其中min{dist(p,Q)}是p到查询点集Q中所有查询点的距离的最小值,p距离Q中哪个查询点更近,p就可能是那个查询点的RkNN.5双色GR犽NN查询算法本节介绍了如何将FCINCH算法扩展来解决双色GRkNN查询的问题.双色GRkNN查询算法也是采用过滤-提炼框架.相对于GRkNN查询,双色GRkNN查询有两个数据集P和R,P是包含查询点集合Q的数据集,R是包含查询结果的数据集.例如,r∈R,如果Q中任意一个查询点是r在P上的kNN中的一个,则r是双色RkNN的一个查询结果.而对于双色GRkNN查询也是将Q的最小覆盖圆O作为整体考虑计算.双色GRkNN查询算法如算法4所示.在数据集P上应用FCINCH-Filter算法计算得到查询点集为Q的GRkNN所形成搜索区域的集合S(第1步),然后用CINCH算法计算搜索区域SR(第2步),从而也确定了在数据集R上寻找候选者的搜索区域SR,第3步就找到候选者集合R,以上就是双色GRkNN的过滤阶段.在数据集P上应用Range-k验证法判断每个候选者是否为查询结果,从而最终得到结果集T,该过程是双色GRkNN的提炼阶段.算法4.FCINCH-B(O,k,P,R).输入:查询点集Q的最小覆盖圆O输出:组BRkNN查询的结果集1.S··=数据集P上FCINCH-Filter(O,k)的S;2.SR··=CINCH(O,k,S);3.R··=数据集R内找到包含在SR内的数据的集合;4.T··=;5.for(R中每个对象r)6.if(P上的Range-k(r,k,min{dist(r,Q)})return7.T··=T∪{r};8.returnT.6算法性能测试本节将测试所提出的计算GRkNN查询的FCINCH算法和计算双色GRkNN查询的FCINCH-B算法的性能.测试在查询点集大小相同情况下,查询点集形成的最小覆盖圆大小对算法效率的影响;测试当k变化、查询点集合大小变化、R树页容量变化的影响下对算法效率的影响,然后同FINCH算法相比较.算法采用Java实现,实验在处理器为P42.4GHz,内存为1GB,操作系统为WindowsXP的微机上进行.测试中使用到北美居民点NAp、北美文化地标NAp这两个点的数据集[8],将它们分别以4096个字节的页容量用R树建立其索引,数据集的详细信息如表1所示.数据集本文以实际运行时间作为性能指标.运行时间包括CPU时间和I/O时间.下面的图中FINCH的运行时间则都是每个查询点的运行时间之和,而候选结果也是每个查询点的候选结果之和.6.1GR犽NN查询结果如图4所示,设定查询点数量是5,k=5,而随着5个查询点形成的最小覆盖圆越来越大(用圆的半径来衡量,半径取其近似值),FCINCH算法也有其使用范围,如图当半径大于0.8时,FINCH算法的性能就优于FCINCH算法,因为FINCH算法计算每个查询点的性能相似,有几个查询点就会使计算这组查询点的RkNN的运行时间成倍数增加,与这些查询点的位置无关.因此当查询点个数相同时,运行时间基本相同.但FCINCH却不同,它是与查询点的位置相关的,在查询点个数确定的情况下,查询点集所形成的最小覆盖圆越大,算法的性能就越低,因为该算法是以查询点集最小覆盖圆为整体进行剪枝的,同时整个圆也将划入搜索区域,圆越大搜索区域越大,候选结果就越多,如图5所示,FCINCHPage8算法随着圆越来越大,候选者也越多,而FINCH却变化不大.但是当查询点间相距较近的时候,FCINCH算法就会比FINCH算法的性能更好.如图6所示,在数据集NAp上,给定5个查询点,随着k值从1~10,算法在NAp数据集上执行的性能对比.图7是相同查询的候选者数量的比较,随着k的增大,FINCH得到的候选集合比FINCH更多.这两个图显示出在处理查询点间相距较近的GRkNN问题时FCINCH比FINCH更有效.因为给定的5个查询点如果用FINCH算法思想解决,则是一个一个计算其搜索区域从而得到其候选集合,但当查询点较近时,会有搜索区域相重叠,而每个查询点的候选集合也会有很多重复,这样就降低了算法性能,而FCINCH算法避免了这样的问题发生,当查询点间的相近程度达到某种程度的时候,将其划定在它们的最小覆盖圆内,将这个圆作为整体考虑就避免了重复查找相同候选者的可能.因此在这种情况下,处理GRkNN问题时FCINCH比FINCH更有效.如图8所示,在数据集NAp上,当k=5、查询点数量不同时(所有查询点在某一较小范围内),FCINCH的性能优于FINCH的查询性能,因为在FCINCH算法中查询点都放在它们的最小覆盖圆内做整体考虑,所有查询点都在一个较小的范围内,每个查询点搜索区域交叠情况频繁,因此剪枝后形成的搜索区域基本相同,所以当查询数量增大时,并没有对性能造成影响,但FINCH却不同,每计算一个查询点的时间基本相同,而随着查询点增加时,其运行时间将成倍数增加.如图9所示,在数据集NAp上给定5个查询点(所有查询点在某一较小范围内),查询的k值为5,随着形成的R树的页容量不同,运行性能并没有相差很多,但仍可看出,FCINCH性能优于FINCH.6.2双色GR犽NN查询结果如图10所示,给定5个查询点,查询点所在集合为NAc,结果集为NAp,最小覆盖圆半径小于0.2,随着k值增大,可看出FCINCH-B的性能优于FINCH-B.k值越大,FINCH-B的每个查询点的搜索区域重叠的就越多,候选结果就越多,如图11所示.Page9而当查询点距离较近时,FCINCH-B与FCINCH相同,都能发挥将查询点最小覆盖圆作为整体考虑减值的优势,因此相对于FINCH-B来说,FCINCH-B的算法性能随着k值的增大却使得候选者数量较少.图10k值对算法性能的影响(双色GRkNN)图11k值对候选者数量的影响(双色GRkNN)7结论根据实际应用需求提出了GRkNN查询的概念及相关算法.采用R树[8]索引结构,利用过滤-提炼的模型结构来实现GRkNN查询.在过滤阶段,将查询点集的最小覆盖圆作为整体考虑剪枝,利用CINCH算法确定搜索区域,最终确定了结果候选集合.在提炼阶段,采用Range-k验证[2],排除错误结果的数据点,最终得到结果集合.并采用真实数据集对算法的性能进行了测试,实验表明所提出算法的效率在查询点集是一组邻近的空间对象时优于直接算法.GRkNN查询具有重要的实际应用价值,可以用于评价集合对象的影响力,为决策支持提供了新的方法.致谢感谢文献[7]的作者提供的FINCH的算法源码!
