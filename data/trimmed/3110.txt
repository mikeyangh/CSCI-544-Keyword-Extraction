Page1Paillier陷门函数的两个变体的比特安全性分析苏东王克吕克伟(中国科学院研究生院信息安全国家重点实验室北京100049)摘要文中对Paillier陷门函数两个变体———Rabin-Paillier和RSA-Paillier进行了比特安全分析.对于Rabin-Paillier陷门函数,文中证明了从密文计算其明文的32槡n/2+log2n个最高有效位与对这个函数求逆一样困难,其中n为RSA模数N的二进制长度.该结论的证明基于Boneh等人提出的素数域上的隐藏数问题的一个变体.文中使用Malykhin在2007年得到的指数和的界把该变体扩展到了Paillier模数N2的情况.对于RSA-Paillier陷门函数,该文完善了Morillo等人对于该函数明文最低有效位的困难性证明.通过设计一个随机化的算法使得Morillo等人提出的明文恢复算法在使用不完美的LSB预言机的时候也能工作.关键词比特安全;Paillier;Rabin-Paillier;RSA-Paillier;指数和的界;隐藏数问题1引言单向(陷门)函数的存在是现代密码学的基础.称一个函数是单向的,如果它是求值容易而求逆困难.与单向函数紧密相关的一个概念是hard-core谓词,是由Blum和Micali[1]在1984年提出的.一个多项式时间算法B:{0,1}→{0,1}被称为是单向函数f的hard-core谓词,如果已知可计算的函数f(x),对于任意的有效算法,它猜对B(x)的概率仅比1/2多出一个可忽略的量.换句话说,如果x是随机选取的,即使已知f(x),B(x)也是随机的.BlumPage2在1999年欧密会上,Paillier[6]提出了一个和Micali[1]证明了对于有限域p和其乘法群生成元g,离散指数函数的Exp(x)=gxmodp的输入x的最高有效位(MostSignificantBit,MSB)是一个hard-core谓词,这就把离散指数函数的求逆问题归约到以不可忽略的优势猜测x的最高有效位上.在1988年,Alexi、Chor、Goldreich和Schnorr[2]证明了RSA/Rabin加密消息的最低有效位(LeastSignificantBit,LSB)是一个hard-core谓词.在2000年,Fischlin和Schnorr[3]给出了一个更为高效的RSA/Rabin函数求逆算法.Hstad和Nslund[4]证明了RSA/Rabin加密消息的所有比特都单独是hard-core比特.而在1989年,Goldreich和Levin[5]证明了每个单向函数都有一个hard-core谓词.尽管已经有这样的一般性结果,对于特定的单向函数,依然有必要寻找它们的hard-core谓词.上新的同态陷门置换PN,g(·,·),其中N为RSA模数,g为该置换构造了一个概率公钥加密方案.为了加密一个消息c∈N,先选择一个随机的整数y∈计算w=gcyNmodN2.c被称为w相对于N和g的类(Class),记作ClassN,g(w).文献[6]已证明,如果已知N的分解,计算ClassN,g(w)=c是容易的.对于N和g,Paillier定义了计算合数剩余类问题,记作Class[N,g].此问题是,已知N,g和w,计算类c.Paillier假定这个问题是困难的,称作计算合数剩余类假设.为了方便起见,也把它称作标准Paillier假设.Paillier单向陷门函数的一个重要性质是同态性,即PN,g(c1,y1)PN,g(c2,y2)≡PN,g(c1+c2,y1y2)modN2.该性质使得Paillier单向陷门函数在构造密码协议方面有着广泛的用途.在2001年,Catalano,Gen-naro和Howgrave-Graham[7]分析了Paillier陷门函数的比特安全性并且证明了在假设计算合数剩余类是困难的情况下,类c的LSB是一个hard-core谓词.他们也证明了Paillier陷门函数同时隐藏了n-b(或者说O(n))个类比特.这一同时安全性的结论所基于的假设是:如果c<B=2b,从随机的w∈计算c依然是困难的.这个假设也被称为B-困难假设,它比标准Paillier假设要强.在2001年,Catalano、Gennaro、Howgrave-Grahm和Nguyen[8]提出了Paillier陷门函数的一个高效的变体,称为RSA-Paillier陷门函数.它是基于置换其中N为两个等长的不相同的大素数的乘积,e∈N,gcd(e,λ(N2))=1.为了加密消息m∈N,首先选择随机数r∈密文w,如果知道私钥d或者N的分解,ed≡1modλ(N2),则可以首先算出r=(wmodN)d,然后计算m=L(wr-emodN2).该置换的单向性和对RSA函数求逆的困难性等价[9].基于这个置换的加密方案在选择明文攻击下的语义安全性是由判定的小e次剩余假设所决定的[9].至于同态性,RSA-Paillier陷门函数则没有Paillier陷门函数那么好的性质了,但是,它还是保持了部分的同态性:EN,e(r,m1)EN,e(1,m2)≡re(1+(m1+m2)N)modN2,EN,e(r1,m)EN,e(r2,0)≡(r1r2)e(1+mN)modN2.对于RSA-Paillier陷门函数的比特安全性,Moril-lo、Rfols和Soler[10]首先声称该函数明文的LSB是一个hard-core比特.然而,他们的证明是不完善的.他们的明文恢复算法,也称为MRS算法,只在LSB预言机能够以概率1正确回答查询时才能工作.因此,当预言机只能相对于随机猜测以一个不可忽略的优势正确回答LSB时,该函数明文的LSB的困难性依然是一个有待进一步研究的问题.在2003年,Galindo、Mollevi、Morillo和Vil-lar[11]提出了另外一个变体,称作Rabin-Paillier陷门函数.它是基于置换其中QN为模N的二次剩余集合,QN2={x+yN|x∈QN,y∈N}.其中N为两个等长的大素数的乘积,e∈N,gcd(e,λ(N))=1.为了加密消息m∈N,首先选择随机数r∈QN,然后计算w=FN,e(m,r).对于密文w,如果知道私钥d和N的分解,ed≡1modλ(N),则可以首先算出r≡(wmodN)2-1dmodN,然后计算r≡w-r2emodN2.Galindo等人[11]证明了它的单向性与分解Blum整数等价.基于这个置换的加密方案在选择明文攻击下的语义安全性是由判定的小2e次剩余假设所决定的[11].虽然在Paillier陷门函数变体中,Rabin-Paillier的单向性是最强的,但是它完全丧失了同态性.这也就限制了该变体在密码系统构造上的应用.因此对于其比特安全性的研究来说,传统的“零化和移位”的方法也对其失Page3效.在本文中,我们使用研究比特安全的另一种工具———隐藏数问题,来分析Rabin-Paillier陷门函数的比特安全性.隐藏数问题(HiddenNumberProblem(HNP))首先由Boneh和Venkatesan[12]于1996年中提出.他们使用这个模型证明了在Diffie-Hellman密钥交换协议中,计算出秘密密钥的O(槡n)个MSB与计算出整个秘密密钥一样困难,其中n为素模数p的二进制长度.他们首先设计了一个隐藏数问题,p-HNP:已知d个数对(ti,MSBk([αti]p)),i=1,2,…,d,其中k>0以及t1…td∈R隐藏数α∈p.然后构造了隐藏数恢复的算法并把它应用到Diffie-Hellman密钥交换协议上.作为p-HNP的一个自然扩展,他们也提出了一个含有两个未知数的隐藏数问题变体,p-HNP-2U:已知(ti,MSBk([αti+β]p)),i=1,2,…,d,恢复出α,β∈p.隐藏数问题在研究很多密码系统的安全性上发挥着重要的作用[13].在2007年,Garefalakis[14]把文献[12]的模素数隐藏数问题扩展到了无平方因子合数模数(square-freecompositemoduli)情况.记号和约定令a←A表示从有限集A中随机均匀地选取一个元素a.对于一个整数x,令[x]N∈[0,N)记xmodN最小的非负剩余,令LSB(x)表示x的最低有效位,MSB(x)记为x的最高有效位.对于x∈我们的贡献首先,对于Rabin-Paillier陷门函数,我们使用了Malykhin[15]证明的p-HNP-2U扩展到了Paillier模数N2的情况.这是一个带平方因子的合数模数.然后应用这个新的隐藏数问题变体证明了计算Rabin-Paillier陷门函数明文的32槡n/2+log2n个最高有效位和对整个函数求逆一样困难.其次,对于RSA-Paillier函数,我们完善了文献[10]的关于明文LSB困难性的证明.通过为RSA-Paillier函数设计一个能够放大不完美LSB预言机的预测优势的随机化算法,使得文献[10]中的明文恢复算法在使用不完美的预言机时也能工作.本文的结构本文第2节简要介绍hard-core谓词,Paillier加密方案、RSA-Paillier加密方案和Rabin-Paillier加密方案.第3节给出Rabin-Paillier陷门函数的比特安全性分析.在第4节中,我们讨论RSA-Paillier陷门函数的比特安全性.N2,我们使用ordN2(x)来记x模N2的乘法阶.令Nn表示n比特长的合数N=PQ的集合,其中P和Q为两个等长的大素数.令Pn表示对〈N,g〉的集合,其中N∈Nn,并且g为乘法阶为N的非零整数倍.我们使用log来表示以2为底的对数函数.我们使用ε(n)来表示一些不可忽略函数,即对于某个多项式p(n),ε(n)>1/p(n).为了简单起见,我们使用ε来替代ε(n).我们用关系P1P2(P1P2)来表示问题P1可以被多项式时间归约到(等价于)问题P2.按照传统,向量以列形式存在,并且用粗体小写字母表示,比如狌.第i个分量记作狌i.向量狌的长度可以用欧式范数表示:狌=狌T槡狌.令φ(·)表示欧拉函数,并且令λ(·)表示Carmichael函数,它的定义如下λ(n)=对于N∈Nn以及gcd(e,φ(N))=1,用RSAN,e来表示RSA函数,用RSA[N,e]来表示RSA问题.类似的,对于N=PQ、P≡Q≡3mod4以及P≠Q,我们用RabinN来表示Rabin函数,用Rabin[N]来表示Rabin问题.2预备知识2.1几个基本的密码学定义定义1[15].Hard-Core谓词.对于函数f:{0,1}→{0,1},它的hard-core谓词为一个布尔谓词B:{0,1}→{0,1},满足1.概率多项式时间算法A,满足x∈{0,1},A(x)=B(x);2.概率多项式时间算法G,常数c,k0,k>k0,Pr[G(f(x))=B(x)]<1/2+1/kc.对于一个单向函数f,一种证明谓词B为hard-core谓词的方法是:假设存在一个高效的算法A,它能够从y=f(x)以高于1/2的不可忽略的概率猜出B(x)的值,则我们能够构造另一个高效的算法A,它能够在概率多项式时间内从输入y以不可忽略的概率计算出x.2.2Paillier加密方案在文献[6]中,Paillier提出了一个新的概率加满足Page4密方案.这一方案是基于群为一个RSA模数.该方案是同态的,在选择明文攻击下是语义安全的,而且有高效的解密运算.具体地说,对于〈N,g〉∈Pn,考虑如下映射:Paillier证明了PN,g为一个单向陷门置换.陷门信息是N的分解.由Pn为双射,已知〈N,g〉∈Pn,对于一个元素w∈足w=gcyNmodN2.c被称为w相对于N和g的类,记作ClassN,g(w).定义计算合数剩余类问题为已知w计算c,并认为这个问题是难解的.Paillier加密方案的具体描述如下.密钥生成.已知一个安全参数n,随机选择两个不同的n/2比特长的素数P和Q,选择一个整数N2,满足N|ordN2(g),则公钥为〈N,g〉,其中g∈N=PQ;私钥是〈P,Q〉.我们用Paillierpk(n)来记安全参数为n的该方案的公钥的集合.加密.对于明文c∈N,选择一个随机值y∈N.通过计算w=PN,g(c,y)来对c进行加密.我们把这个加密过程记作PEncN,g(c).y的选择可以看作这个加密过程的随机掷币.解密.可以通过L(wλmodN2)/L(gλmodN2)来从密文恢复出明文c,其中L(u)=(u-1)/N且λ(N)=lcm(P-1,Q-1).定义2[7].计算剩余类的困难性.称计算函数ClassN,g(·)是困难的,如果对于任意的概率多项式时间算法A,都存在一个可忽略函数negl(·),满足Pr[〈N,g〉∈Paillierpk,c←N,y←w=gcyNmodN2;A(N,g,w)=c]negl(n).如果N=PQ的分解已知,则函数ClassN,g(·)是可以计算的.令λ=λ(N)=lcm(P-1,Q-1),则ClassN,g(·)=L(wλmodN2)/L(gλmodN2),其中L(u)=(u-1)/N.另一方面,如果N的分解未知,到目前为止还没有找到计算ClassN,g(·)的多项式时间算法.因此,有如下假设.假设1[7].计算合数剩余类假设.如果N的分解未知,则不存在概率多项式时间算法能够解计算合数剩余类问题.我们把PN,g的单向性记为Paillier1[N,g].这也就是计算合数剩余类的困难性,即Paillier1[N,g]Class[N,g].上述Paillier加密方案也存在一个确定性的变体,即把随机掷币y也做成消息的一部分.这样对于消息m∈N2,m=m1+m2N,其中m2∈通过计算w=gm1mN2modN2来实现对m的加密.把这个加密方案的单向性记作Paillier2[N,g],有如下定义.定义3.对于任意的概率多项式时间算法A,都存在一个可忽略的函数negl(·),使得Pr[〈N,g〉∈Paillierpk,m1←N,m2←w=gm1mN2modN2;A(N,g,w)=(m1,m2)]negl(n).Paillier[6]也证明了,对于〈N,g〉∈Paillierpk,Class[N,g]RSA[N,N]Fact[N]Paillier1[N,g]Paillier2[N,g].2.3RSA-Paillier加密方案在2001年,Catalano等人[8]提出了Paillier加密方案的一个高效的变体.其加密的效率近似于RSA加密方案.他们首先定义了RSA-Paillier陷门函数.定义4[8].RSA-Paillier陷门函数.其中N=PQ为RSA模数,e∈N,满足gcd(e,λ(N2))=1和e>2.Catalano等人[8]证明了EN,e是一个陷门置换,并且构造了如下的RSA-Paillier加密方案.密钥生成.给定一个安全参数n,随机选择两个n/2长的不同的素数P和Q.选择一个整数e∈N,满足gcd(e,λ(N2))=1且e>2,则公钥是〈N,e〉,其中N=PQ.私钥是〈P,Q,d〉,其中d∈ed≡1modλ(N2).用RSA-Paillierpk(n)来记安全参数为n的公钥集合.加密.对于消息m∈N,选择一个随机值r∈解密.消息m可以通过计算r=(wmodN)d和EN,e的单向性,记作RSA-Paillier[N,e],定义定义5.对于任意的概率多项式时间算法A,N,计算w=EN,e(r,m).m=L(wr-emodN2)恢复出来.如下.都存在一个可忽略的函数negl(),使得Pr[〈N,e〉∈RSA-Paillierpk,m←N,r←w=(1+mN)remodN2;A(N,e,w)=m]negl(n),此外,Catalano等人[8]定义了一个计算困难问题,称作计算小e次剩余问题(CSeR).Page5定义6[8].计算小e次剩余问题的困难性.对于任意的概率多项式时间算法A,都存在一个可忽略的函数negl(),使得Pr[〈N,e〉∈RSA-Paillierpk,m←N,w=memodN2;Catalano等人[8]证明了对于〈N,e〉∈RSA-Paillierpk,CSeR[N,e]RSA-Paillier[N,e]RSA[N,e].此外,Catalano等人[8]提出了Hensel-RSA问题,对于〈N,e〉∈RSA-Paillierpk,已知c=remodN,计算remodNlforl>1.更为正式地讲,他们定义了Nl的映射Hensel-RSA[N,e,l](remodN)=到remodNl.并证明了,Hensel-RSA[N,N,3]RSA[N,N]和Hensel-RSA[N,N,2]Class[N,g].2.4Rabin-Paillier加密方案在2003年,Galindo等人[11]提出了Paillier陷门函数另外一个变体,称作Rabin-Paillier陷门函数.他们首先定义了Rabin-Paillier陷门函数.定义7[11].Rabin-Paillier陷门函数其中QN为模N的二次剩余集合,QN2={x+yN|x∈QN,y∈N}.N=PQ为一个RSA模数,e∈足gcd(e,λ(N))=1和e>2.Galindo等人[11]证明了FN,e是一个陷门函数并且构造了如下的Rabin-Paillier加密方案,密钥生成.已知一个安全参数n,随机选择两个不同的n/2长的随机数P和Q,满足P≡Q≡3mod4.选择一个整数e∈1和e>2.则公钥为〈N,e〉,其中N=PQ.私钥为〈P,Q,d〉,其中d∈Rabin-Paillierpk(n)来记安全参数为n的公钥集合.加密.令m∈N,选择一个随机值r∈QN,然解密.消息m可以通过如下计算来恢复,t=RSA-1N,e(wmodN),r=Rabin-1N(t),m=(w-r2emodN2)/N.后计算w=FN,e(m,r).Rabin-Paillier方案的构造是基于Rabin-Wil-liams函数的:这个函数在分解假设下是陷门单向置换.FN,e单向性,记作Rabin-Paillier[N,e],可以按如下定义.定义8.Rabin-Paillier陷门函数的单向性.对于任意的概率多项式时间算法A,都存在一个可忽略的函数negl(),使得Pr[〈N,e〉∈Rabin-Paillierpk,m←N,r←QN;w=mN+r2emodN2;A(N,e,w)=m]negl(n).Galindo等人[11]也定义了Hensel提升问题的另外一个版本,称作Hensel-RW问题:对〈N,e〉∈Rabin-Paillierpk,已知r2emodN,对于l>1,计算r2emodNl.这个问题也可以记为Hensel-RW[N,e,l].他们也证明了对于〈N,e〉∈Rabin-paillierpk,我们把上文中出现的主要的困难问题总结到图1中.该图蕴含了一个有意思的公开问题:Catal-ano等人[9]指出问题Class[N,g]与问题RSA[N,N]的困难性也许并不等价.由于Hensel-RSA[N,N,3]RSA[N,N],Hensel-RSA[N,N,2]Class[N,g],Hensel提升问题的第3个参数也许是Class[N,g]和RSA[N,N]困难程度的指示器.3Rabin-Paillier陷门函数的比特安全性分析在本节中我们使用隐藏数问题来分析Rabin-Paillier陷门函数的比特安全性.对于整数k1,定义MSBk(t)为满足下列不等式的非负整数(MSBk(t)-1)N2/2ktmodN2MSBk(t)N2/2k.不正式地讲,MSBk(t)为tmodN2的前k个MSB所对应的整数.为了研究Rabin-Paillier的比特安全性,我们把隐藏数问题的变体p-HNP-2U[12]扩展到模N2的情况.首先使用一个指数和的界的最新结果[15]和中Page6定义9.固定N和k,对于任意的α,β∈国剩余定理来估计分布的x∈λx≡ymodN2,y∈[r+1,r+h].剩下的就是按照文献[17]中的证明框架来构建新的隐藏数问题变体.我们的新隐藏数问题变体的正式定义如下.令Oα,β(·)为一个隐藏数预言机,输入是整数t,输出是αt+βmodN2的k个MSB,Oα,β(t)=MSBk(αt+βmodN2).任务是利用预言机Oα,β(·),在期望多项式时间内计算隐藏数αmodN2和βmodN2.根据文献[12],已知随机整数t1,…,td∈首先用下述矩阵犕来构造一个d+2维的格LN2(t1,…,td),犕=称犕的前d个行向量为N2-向量.这个格是整个隐藏数恢复算法的关键.接下来,使用文献[15]给出的指数和的界来把文献[12]的模素数隐藏数问题的结论扩展到Paillier模数N2的情况.一个子群,而且#G=t.记引理1[15].令p为一个素数,G为如果tp,则S(G)=0;否则S(G)=(p7t26)1/36,p7/10<t<p3/4(logp)-1,烄p1/9t5/6(logp)1/9,p3/4(logp)-1<t<p7/9,烅(p5t17)1/24(logp)1/12,p7/9<t<p4/5,p3/8t1/2,p4/5<t<p烆令Mλ(r,h)为方程λx≡ymodN2的解的个数,其中x∈Mλ(r,h)接近于其期望值φ(N2)h/N2=φ(N)h/N.引理2.对于任意的ε>0,都存在δ>0,满足界max0r,h<N2-1容易看出,Mλ(r,h)可以使用指数和来进行计数,这是因为其中,m和u为任意整数.我们有Mλ(r,h)=1因此,Mλ(r,h)-φ(N)h如果gcd(c,N2)=1,可以使用引理1中的界以及中国剩余定理来估计上述和式在x∈x=M(a)exp2πia在c∈N\献[18]中第3章的练习11.c来进行估计.a=1∑M(a)+P(a)-1∑m-1其中m为一个整数,m>1.函数M(a)和P(a)取整数值,而且对于a=1,2,…,m-1,P(a)>0.因此,0r,h<N2Mλ(r,h)-φ(N)hmax(1N2∑c∈N2∑x∈∑c∈N2\Z=1N2(φ(N2)N7/8(2logN)+N(P+Q-1)(2logN)2)=N7/81-1()P1-1()Q(2logN)+P+Q-1<O(N7/8logN)=O(N1-δ),其中δ为一个大于零的常数.有了这个引理就可以证明唯一性定理了.它的证明类似于文献[17]中引理3.2的证明.为了本文的完整,我们也把全部的证明写在这里了.稍有不同的是,要对μ和k稍加放大.这是为了使得在新的隐藏数问题中隐藏数恢复算法的成功概率依然能够充Page7分地大.定理1.唯一性定理.令d=22槡n,μ=2槡n+3,δ>0.令α,β∈选择整数t1,…,td.则对于满足任意的向量狌=(u1,…,ud,0,0),满足的所有的向量狏=(v1,…,vd+2)∈LN2(t1,…,td)可以至少以概率1-2-2槡n具有形式狏=([αt1+β]N2,…,[αtd+β]N2,α/N2,β/N2),其中α≡αmodN2,β≡βmodN2.证明.首先定义两个整数a和b在模N2下的距离distN2(a,b)=minc∈Za-b-cN2令t为一个从可知,对于任意的a1≠a2modN2和b1≠b2modN2,事件distN2(a1t+b1,a2t+b2)>N22-μ+1发生的概率为1-2-μ+2+O(N-δ)1-5/2μ.因此,对于任意的a1≠a2modN2和b1≠b2modN2,其中概率取自从t1,…,td.固定整数t1,…,td,mina1≠a2modN2b1≠b2modN2令狏为满足狏-狌N22-μ的向量.由于狏∈LN2(t1,…,td),则有整数α,β,z1,…,zd,满足狏=(αt1+β-z1N2,…,αtd+β-zdN2,如果α≡αmodN2和β≡βmodN2,则对于所有的i=1,2,…,d,我们有αti+β-ziN2=[αti+β]N2,否则会存在一个j∈[1,d],满足vj-uj>N22-μ.现在假设α≠αmodN2和β≠βmodN2,我们有这个就与假设相矛盾了.因此条件(1)至少可以以概率1-2-2槡n成立.ti,si=MSBk(αti+β(A(t1,…,td;s1,…,sd)=(α,β[定理2.令d=22槡n,k=32槡n/2+log2n,则存在一个确定的多项式时间算法A,满足对于任何整数α,β∈N2,已知2d个整数A都能以概率Prt1,…,td成功地输出隐藏数α和β.证明.本定理的证明借鉴了文献[17]中引理3.3的证明.已知随机整数t1,…,td∈量狉=(r1,…,rd,0,0),其中ri=siN2/2k,i=1,2,…,d.然后把矩阵犕的第(d+1)行向量(t1,…,td,1/N2,0)乘上α,把犕的(d+2)行(1,…,1,0,1/N2)乘上β.把上述乘法的结果减去N2-向量的相应倍数,然后得到一个格点狌α,β=(u1,…,ud,α/N2,β/N2)∈LN2(t1,…,td),满足ui-ri<N22-k,i=1,2,…,d.现在使用文献[14]的引理4提到的LLL算法来在多项式时间内找到一个格向量狑=(w1,…,wd+2),满足狑-狉2(d+2)/4min{狕-狉,狕∈LN2(t1,…,td)}其中μ=2槡n+3.由于已经有狌α,β-狉N2d1/22-kN22-μ-1,因此狑-狌α,βN22-μ.应用定理1,可以以概率1-2-2槡n得到狑=狌α,β.因此也就能够从狑最后的两个分量得到α和β.定理3.令k=32槡n/2+log2n,d=22槡n,〈N,e〉∈Rabin-Paillierpk.存在一个概率多项式时间算法B,已知公钥和w∈用预言机Oα,β22槡n次,至少以概率1-2-2槡n计算出值mmodN2和r2emodN2.证明.令α··=mNmodN2和β··=r2emodN2.可以构造算法B:Page82,…,d;1.选择随机数t1,…,td∈2.查询预言机,并得到si··=Oα,β(ti),i=1,3.调用定理2的多项式时间算法A;4.输出α和β;5.m··=α/N,r2e··=β;应用定理2,上述算法能够至少以概率[PrA(t1,…,td;s1,…,sd)=(α,β返回m和r2e.定理4.令k=32槡n/2+log2n,〈N,e〉∈Rabin-Paillierpk.对于Rabin-Paillier陷门函数,计算明文m的前k个MSB和分解Blum整数N是一样困难的.证明.()如果敌手能在多项式时间内分解Blum整数N=PQ,则它能够计算d∈1modλ(N).因此,所有的私钥都能够被计算出来.()敌手的目标是分解N.在预言机Oα,β的辅助下,它首先调用定理3中的多项式时间算法B.当算法B返回m和r2emodN2,敌手需要找到r来分解N,即敌手已知r2emodN,需要对Rabin-Williams函数求逆.敌手依照文献[11]中的命题6来完成剩下的攻击.算法B能够模拟预言机Hensel-RW[N,e,2].敌手首先从QN中随机选取一个数a,计算r2ea2emodN.然后,敌手至少能够以概率(1-2-2槡n)21-2-2槡n+1知道r2emodN,r2emodN2和μ2e=(ar)2emodN2,其中μ=armodN.因此存在一个z∈N,满足把这个等式升到2e次幂,敌手得到等式a2er2e≡μ2e(1+2ezN)modN2.从这个式子就能计算出z,因为其它的值都已经知道了.最后,敌手可以利用文献[9]中的定理1的证明中的格约减算法来解等式(2)从而得到r.这一步约用时O(log4N).证毕.4RSA-Paillier陷门函数的比特安全性分析在本节中,我们研究RSA-Paillier陷门函数明文的比特安全性.Morillo等人在文献[10]中声称RSA-Paillier陷门函数的明文的最低有效位(LSB)是hard-core比特.他们的证明采用的是反证法:如果明文的LSB不是困难的,即存在一个预言机,输入给它密文它能返回对应明文的LSB.则可以用这个预言机构造一个算法,它能够在概率多项式时间内对RSA-Paillier函数求逆.换句话说,已知w∈N2,满足w=EN,e(r,m).任务是在预言机O(w)=LSB(m)的帮助下,在概率多项式时间内恢复出明文m.证明通常依据预言机能否正确回答查询而分为两种情况.在第一种情况是假定敌手拥有一个完美的LSB预言机,Prw[O(w)=LSB(m)]=1.Mo-rillo等人考虑了这种情况并且给出了一个借助完美LSB预言机恢复明文的算法,称作MRS算法.但是他们的证明忽略掉了不完美LSB预言机的情况,Prw[O(w)=LSB(m)]1/2+ε(n),其中ε(n)>1/p(n),p(n)为某个多项式.我们通过构造了一个随机化算法来使得MRS算法在不完美预言机下也能工作,从而完善了RSA-Paillier明文LSB的安全性证明.4.1完美预言机的情况MRS算法类似于经典的二分搜索算法.这个算法寻找一个值t,t=N-m-1,而不是先找未知的明文m.循环不变量是:在每次while循环的开始,有β=α+d和αN-m-1β.当算法终止时,while循环终止于β=α.目标值是t=α,则有m=N-α-1.MRS算法运行时间是O(logN).这是由于在每次迭代中,α和β的距离减半,而它们的初始距离是(N-1)/2.图2给出了这个算法的详细描述.4.2不完美预言机的情况在本节中,我们展示如何使用一个不完美的预言机来恢复出明文.关键的技术就是使用随机化方法来放大这个预言机猜测比特的统计优势.首先给出我们的结论.定理5.令〈N,e〉∈RSA-Paillierpk.已知w∈N2,如果假定函数EN,e(·,·)为一个陷门置换,则wPage9对应明文的LSB是函数EN,e(·,·)的一个hard-core谓词.证明.在这种情况下,上一节中的算法无法使用,因为不能保证在MRS算法(图2)的任意一个循环中b就是正确的比特.这就需要使用一个随机化的过程,称为随机化查询算法(图3),来放大这个预言机在猜测比特上的统计优势.所以我们使用随机化查询算法来替换掉MRS算法中预言机调用的步骤(图2第3行).对于w=(1+mN)remodN2,由于m与r独立,可以利用RSA-Paillier函数的部分同态性分别对它们进行随机化.具体地说,首先随机化r.已知m←N,s←w1se≡(rs)emodN.然后通过计算w^≡w2(1+mN)≡(1+(m+m)N)(rs)emodN2来实现m的随机化.随机化要重复l次,来输出一个对LSB的投票,进而以很高的概率得出LSB的正确的值.这个投票的过程也称为多数决策.并且每次for循环(图3行3~13)的调用被称为一次度量.l的取值将在下文中得到解释.下面是使用不完美预言机的明文恢复算法的概率和时间分析.对于i=1,2,…,l,定义取值为0和1的随机变量Xi,表示在随机化查询算法中第i次查询的是否出错,即Xi=1iffO(w^)≠LSB(m+m).由于m和s在每次测量中的选取是相互独立的,则Xi之间也是相互独立的.由于Prw[O(w)=LSB(m)]1/2+ε(n),可以有E[Xi]1/2-ε.一个多数决策是错误的,只有当(1/l)∑l等价地(1/l)∑lMAJErrs=(1/l)∑l误概率的上届可以使用Chebyshev不等式来估计:Pr[MAJErrs]Pr1k=1Xi/[]l=∑l最后一个不等式成立时因为Var∑l如何确定测量的次数l?只要每次随机化查询算法都返回正确的比特,m就可以被正确地计算出来.这个事件发生的概率大于(1-1/lε2)n>1/2.因此如果取l=2n/ε2,则上述条件可以满足.因此,明文恢复算法可以在调用预言机O(logN·2n/ε2)=O(n2/ε2)次后找出m.5结论及展望本文分析了Paillier陷门函数两个变体的比特安全性.对于Rabin-Paillier陷门函数,我们使用了隐藏数问题证明了计算明文的32槡n/2+log2n个MSB和计算整个明文一样困难.对于RSA-Paillier陷门函数,本文给出了明文LSB困难性的完整的证明.本文的研究还有若干个未解决的问题.对于Rabin-Paillier陷门函数,能否把困难比特的数目由O2槡()n提升到()On.对于RSA-Paillier陷门函数,构造出新的隐藏数问题的变体来研究明文连续比特困难性也是一个有意思的问题.
