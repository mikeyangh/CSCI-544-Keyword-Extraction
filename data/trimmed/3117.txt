Page1合取范式3可满足问题的局部搜索近似算法朱大铭马绍汉张平平(山东大学计算机科学技术学院济南250101)摘要合取范式最大可满足问题是理论计算机科学的核心问题.局部搜索被许多求解实践证明是解答合取范式最大可满足问题十分有效的方法,但未见关于局部搜索算法解答该问题性能分析的结果.文中讨论最大3可满足问题(Max-(3)-Sat)的局部搜索算法并分析算法性能.证明Max-(3)-Sat问题的一位跳变局部搜索算法的近似性能比为4/3;证明一位跳变局部搜索后跟有条件全体跳变算法,解答Max-(3)-Sat问题的近似性能比为5/4.设计一位跳变加全体跳变的新局部搜索算法,证明新算法解答Max-(3)-Sat问题的近似性能比为8/7.将8/7-近似局部搜索算法推广为解答Max-(k)-Sat问题的局部搜索算法,证明算法的近似性能比为(2k+2)/(2k+1),k4.设计解答Max-(k)-Sat问题的两位跳变局部搜索算法,证明两位跳变局部搜索算法的近似性能比为1+1/(2k+1+k(k-1)/(n-k)),k4.局部搜索算法经多次运行可进一步提高求解性能.文中结果显示,局部搜索算法在合取范式最大可满足问题求解实践中表现出高性能,有其必然性.关键词算法;复杂性;近似性能比;可满足性;局部搜索1引言合取范式最大可满足问题是理论计算机科学的核心问题.由布尔变量集合与项(clause)集合给定的布尔表达式即是合取范式.合取范式最大可满足问题要求计算布尔变量赋值,使可满足的项数目最大.该问题简称为Max-Sat.因Max-Sat是NP-Hard[1],且是Max-SNP-Hard[2],因此其近似算法和实用算法设计研究成为该问题研究的重心.Johnson最先设计了解答Max-Sat问题的近似算法,并证明算法的近似性能比为2[3].Chen、Friesen、Zheng证明Johnson算法的近似性能比实际为3/2[4].Yannakakis于1994年给出解答Max-Sat问题的随机算法,平均近似性能比为4/3.Goemans与Williamson利用线性规划松弛法,给出一个更为简单的随机近似算法[5],其近似性能比仍为4/3.限制项含有字母数的Max-Sat子问题,在Max-Sat问题研究中占有重要位置,也是计算机科学工作者最早尝试讨论算法与复杂性所研究的问题之一.本文将每个项含有不多于k个字母的Max-Sat子问题称为Max-k-Sat问题;将每个项含有不少于k个字母的Max-Sat子问题称为Max-(k)-Sat问题.早在1974年,Johnson就设计了Max-(k)-Sat问题的组合近似算法,近似性能比为2k/(2k-1)[3].实际上,为每个布尔变量以1的方法,解答Max-(k)-Sat的平均近似性能比即为2k/(2k-1)[6].Goemans与Williamson于1995年给出了解答Max-2-Sat问题的1.139-近似随机算法[7],他们所采用的半定规划松弛法突破了原有近似算法的设计,进一步提高了算法性能.Feige与Goemans利用同样方法进一步将算法的近似性能比改进为1.074[8].利用半定规划松弛法也可适当改进解答Max-Sat问题的算法性能.Goemans与Williamson将解答Max-Sat问题算法的近似性能比改进为1.32[7],Asano与Williamson又将算法近Trevisan、Sorkin、Sudan与Williamson将Max-3-Sat归约为Max-2-Sat,得到Max-3-Sat问题的1.248-近似算法[10],Trevisan又将解答Max-3-Sat问题的近似性能比改进为1.211,并将解答Max-Sat问题的近似性能比改进为1.25[11].另一方面,Hastad证明:若P≠NP,则每个项均含有恰好3个字母的Max-Sat子问题不能多项式时间近似到小于8/7[12].因此若P≠NP,则Max-3-Sat问题和Max-(3)-Sat问题均不能多项式时间近似到小于8/7.而为布尔变量随机赋值的简单算法解答每个项均含有3个字母的Max-Sat子问题,恰好使平均近似性能比达到8/7.Karloff与Zwick给出解答Max-3-Sat问题的半定规划松弛法,解答可满足Max-3-Sat实例的近似性能比能够达到8/7[13],后来他们证明该方法解答任意Max-3-Sat实例的近似性能比也为8/7[14].Halperin与Zwick又给出了解答Max-4-Sat问题的半定规划松弛算法,近似性能比为1.147[14].Johnson算法是我们所知解答Max-(3)-Sat问题性能最好的确定近似算法;Karloff与Zwick给出的半定规划松弛法是我们所知解答Max-3-Sat问题性能最好的随机近似算法.实际上前述近似算法中,仅有Johnson算法为确定算法.其他算法均为随机近似算法,因此算法近似性能比均为平均近似性能比.因为随机算法去随机过程的时间复杂性太大,这些算法的实用性仍显不足.似性能比改进为1.254[9].以寻找问题精确解为目标的实用算法设计研究在Max-Sat求解实践中同样显示出活力,这样的算法可分为回溯搜索法和局部最优搜索法两大类.回溯算法要得到精确解,总不能摆脱指数时间或弱指数时间复杂性[15-16].多数程序设计者更倾向于采用局部搜索方法设计解答Max-Sat、Max-k-Sat及Max-(k)-Sat问题的求解算法,这是因为局部搜索算法步骤简单,且实际求解经验表明,局部搜索算法的求解性能往往十分理想.最早的Max-Sat局部搜索算法研究可追溯到Page3Gu[17]与Selman等[18]的求解实验以及Papadimitri-ou[19]与Koutsoupias[20]的理论分析.Max-Sat问题局部搜索算法的基本步骤为:(1)随机为布尔变量赋初值;(2)重复修正部分布尔变量赋值,以改善当前解质量,直到不能修正为止.这种局部搜索算法需要重新选择初始赋值,多次运行,才能保证以较大概率获得Max-Sat精确解[21].另一类局部搜索算法,其修正布尔变量赋值的步骤也是随机的,可保证算法只需选择一次初始赋值,就可概率为1地获得Max-Sat精确解[22].合取范式可满足问题的算法及其复杂性的其他研究结果可见文献[23-25].虽然实践表明局部搜索算法的求解性能十分理想,但未见有人给出过局部搜索算法解答Max-Sat问题及其子问题的性能分析结果.本文研究解答Max-(3)-Sat问题的局部搜索算法,并分析算法的求解性能.证明一位跳变局部搜索算法解答Max-(3)-Sat问题的近似性能比为4/3;证明一位跳变加全体跳变的局部搜索算法解答Max-(3)-Sat问题的近似性能比为5/4;在前述性能分析的基础上,设计一个解答Max-(3)-Sat问题的新局部搜索算法,证明新局部搜索算法的近似性能比为8/7.我们可针对3个算法分别给出Max-(3)-Sat实例,使算法解答它们的近似性能比恰好达到前面所证明的近似性能比.根据Hastad的反面结果,新算法所能达到的近似性能比‘8/7’,是多项式时间能够逼近Max-(3)-Sat问题的最好近似性能比.另外可将解答Max-(3)-Sat问题的8/7-近似局部搜索算法推广为解答Max-(k)-Sat问题的局部搜索算法,近似性能比为(2k+2)/(2k+1),k4.最后设计解答Max-(k)-Sat问题的两位跳变局部搜索算法,证明算法近似性能比为1+k4.本文局部搜索算法可以运行多次,从中寻找最好的解.因为每次运行的近似性能比最大为8/7,所以多次运行后,算法得到的解往往十分接近最优或已经是最优解.Johnson算法虽然解答Max-(3)-Sat问题的近似性能比也为8/7,但算法每次运行只能得到同样的解.随机算法虽然通过去随机过程可以保证算法能够达到其平均近似性能比8/7,但去随机的时间复杂性太高,影响算法的实用性.第2节给出解答Max-(3)-Sat问题的一位跳变局部搜索算法,证明其近似性能比为4/3;第3节给出Max-(3)-Sat问题的一位跳变后跟全体跳变局部搜索算法,证明其近似性能比为5/4;第4节仍然利用一位跳变和全体跳变,设计解答Max-(3)-Sat问题的新局部搜索算法,证明其近似性能比为8/7;第5节利用解答Max-(3)-Sat问题的局部搜索方法,设计解答Max-(k4)-Sat问题的局部搜索算法;第6节分析两位跳变局部搜索算法的性能.2一位跳变的4/3-近似局部搜索算法Max-(3)-SAT问题形式化描述为实例.布尔变量集合U={u1,…,un},项集合C={C1,…,Cm},每个项均含有不少于3个布尔变量字母.Ct={x[t,1],…,x[t,kt]},其中x[t,j]∈{u1,…,un,u-询问.求U中布尔变量的赋值a:U→{T,F},最大化|{Ct:a(x[t,1])∨…∨a(x[t,kt])=T}|.在Max-(3)-SAT实例中,ui和u-变量字母,ui(u-母,1in.布尔变量赋值也称为布尔变量字母赋值.a(x[t,j])表示由a为U中布尔变量赋值后,布尔变量字母x[t,j]的取值.为表述简单,我们总是假设每个项含有3个布尔变量字母,并只针对这种问题实例给出算法和性能分析.适当修改算法即可用于解答那些每个项含有不少于3个字母的Max-(3)-Sat实例,近似性能比分析的结论仍然成立.设U的赋值a使a(x[t,1])∨a(x[t,2])∨a(x[t,3])=T,则称Ct被a满足.下面也直接称Ct被满足为Ct满足,Ct不被满足为Ct不满足.若一个项同时含有ui和u-被满足,因此下面总是假设Max-(3)-SAT实例中,任意项均不同时含有ui和u-定义1.给定布尔变量赋值a(U),若项Ct含有布尔变量字母ui且a(ui)=T,或Ct含有布尔变量i且a(ui)=F,称Ct被a(ui)满足;若项Ct含字母u-有布尔变量字母ui且a(ui)=F,或Ct含有布尔变量i且a(ui)=T,称Ct不被a(ui)满足.将Ct被字母u-a(ui)满足简记为a(Ct,ui)=T,Ct不被a(ui)满足简记为a(Ct,ui)=F.若Ct不含有布尔变量字母ui,则记a(Ct,ui)=N.Ct被a(ui)满足,则Ct肯定被a(U)满足.考虑Page4如下的局部搜索方法:先任意选择U中布尔变量的赋值,然后选择一个布尔变量将其赋值取反,以增加C中被满足的项数目.重复选择布尔变量并将赋值取反的步骤,一直进行到不存在布尔变量,将其赋值取反可增加C中被满足的项数目为止.将这种方法称为解答Max-(3)-Sat问题的一位跳变算法.设C[j,T]表示被a(uj)满足,但不被其它布尔变量赋值满足的项集合,C[j,F]表示不被a(uj)满足,且不满足的项集合,即C[j,T]={Ct|a(Ct,uj)=T,a(Ct,ux)∈{F,N},x≠j},C[j,F]={Ct|a(Ct,uj)=F,a(Ct,ux)∈{F,N},x≠j},1jn.为布尔变量赋值的一位跳变局部搜索算法如下.算法1.one-flip(U,C).1.a(uk)←Rand{T,F},1kn;2.While(存在uj,使|C[j,T]|<|C[j,F]|)do3.a(uj)←a(uj);4.EndWhile5.Returna(U).算法中,Rand{T,F}表示随机选择‘T’或‘F’的函数.算法的While循环中,执行一次语句3的变量赋值取反操作,则C[j,F]中的项由不满足变为满足,C[j,T]中的项由满足变为不满足,满足的项数目至少增加1.因C中只有m个项能被满足,所以算法While循环一定能够结束.对于每个布尔变量,计算C[·,T]和C[·,F]的时间复杂性为O(m),所以算法在While循环中找到一个uj满足|C[j,T]|<|C[j,F]|的时间复杂性为O(mn).每循环一次,被满足的项数目至少增加1,所以算法时间复杂性为O(m2n).下面分析算法的性能.引理1.算法结束时,得到布尔变量赋值a(U),对于每个uj,1jn,总有|C[j,T]||C[j,F]|.证明.若存在uj,满足|C[j,T]|<|C[j,F]|,由While循环的条件可知算法循环不会结束.引理2.设算法结束时,被a(U)满足的项集证明.设Ct={x[t,1],x[t,2],x[t,3]}∈合为S[a],则|S[a]|∑nS[a],x[t,j]∈{u1,…,un,u-若Ct中至少有两个布尔变量字母取值为T,则x[t,1],x[t,2],x[t,3]中每个字母赋值取反,Ct仍然满足;其它字母赋值取反,不影响Ct的可满足性.所以由C[j,T]的定义可知,CtC[j,T],1jn.若Ct中只有一个布尔变量字母取值为T,不妨设a(x[t,1])=T,则仅当x[t,1]赋值取反时,Ct由满足变为不满足.设x[t,1]∈{uj,u-C[j,T],但对于x≠j,CtC[x,T],即Ct最多出现在一个C[j,T]中,所以|S[a]|∑n引理3.设算法结束时,不被a(U)满足的项集合为NS[a],则∑n证明.我们证明NS[a]中的每个项在C[1,F],…,C[n,F]中至少出现3次,即任意Ct∈NS[a],存在至少3个正整数j1,j2,j3,使Ct∈C[j1,F],Ct∈C[j2,F],Ct∈C[j3,F].设Ct={x[t,1],x[t,2],x[t,3]}∈NS[a],a(x[t,1])=F,a(x[t,2])=F,a(x[t,3])=F.x[t,1]或x[t,2]或x[t,3]赋值取反,Ct会由不满足变为满足,a(Ct,x[t,1])=a(Ct,x[t,2])=a(Ct,x[t,3])=T.设x[t,1]∈{uj1,u-{uj2,u-Ct∈C[j2,F],Ct∈C[j3,F].所以∑n3|NS[a]|.合为S[a],则|S[a]|3定理1.设算法结束时,被a(U)满足的项集j2},x[t,3]∈{uj3,u-证明.由引理2、引理1和引理3得|S[a]|∑n所以,|C|=|S[a]|+|NS[a]|4即|S[a]|3(3)-Sat问题的近似性能比不大于4/3.由定理1可知,算法one-flip(·)解答Max-例.U={u1,u2,u3},C={C1={u1,u2,u3},C2={u-u2,u-3}}.当a(u1)=a(u2)=a(u3)=F时,算法one-flip(·)得到一个局部最优解,C1不能被a(U)满足,C2,C3,C4均被满足,算法解答这个实例的近似性能比恰为4/3.若Max-(3)-Sat实例中,某些项含有多于3个布尔变量字母,算法one-flip(·)并不需要任何改Page5变,即可解答这样的实例,近似性能比仍为4/3.3一位跳变加全体跳变5/4-近似局部搜索算法一个项Ct被满足,其中的3个布尔变量字母可能有1个字母赋值为T,或有两个字母赋值为T,或有3个字母赋值为T.还可观察到,前面定义的C[j,T](1jn)中仅含有一个字母赋值为T而被a(U)满足的项.为更准确地度量被满足的项数目,我们根据一个项中含有的被赋值为‘T’的字母数目,进一步将项分类.定义2.给定Max-(3)-Sat实例U,C,设a:U→{T,F}为布尔变量赋值,Ct∈C为任意含有kt(3)个字母的项.对于j,0jkt,若Ct中有j个布尔变量字母赋值为T,另外字母赋值为F,则称Ct关于a(U)是j-满足的.一个项是0-满足即这个项不被满足;一个项是j(1)-满足的,则这个项肯定被满足.若一个项含有的所有布尔变量字母均被赋值为T,则称这个项为全满足的;若一个项被满足,但不是全满足的,则称这个项为半满足的.利用全满足和不满足的项可以因布尔变量赋值全体跳变而相互转化,可给出解答Max-(3)-Sat问题性能更好的算法.下面仍然假设每个项总含有3个布尔变量字母.设a(U)为U的赋值,仍然设S[a]和NS[a]分别表示被a(U)满足和不被a(U)满足的项集合,其中设S[a,1]、S[a,2]、S[a,3]分别表示关于a(U)是1-满足、2-满足和3-满足的项集合.显然S[a]=S[a,1]∪S[a,2]∪S[a,3].引理4.任给布尔变量赋值a(U),a-(U)是a(U)中每个布尔变量赋值均取反得到的布尔变量赋值,则S[a,1]=S[a-,2],S[a,2]=S[a-,1],S[a,3]=NS[a-],NS[a]=S[a-,3].证明.考察Ct={x[t,1],x[t,2],x[t,3]},若Ct∈S[a,1],不妨设a(Ct,x[t,1])=T,则a(Ct,x[t,2])=F,a(Ct,x[t,3])=F.将U中布尔变量赋值全部取反,得到a-(Ct,x[t,1])=F,a-(Ct,x[t,2])=T,a-(Ct,x[t,3])=T.所以Ct关于a-(U)是2-满足的.每个关于a-(U)为2-满足的项均可由关于a(U)为1-满足的项其布尔变量赋值取反得到.所以S[a,1]=S[a-,2].同理可证:S[a,2]=S[a-,1],S[a,3]=NS[a-],NS[a]=S[a-,3].推论1.任给布尔变量赋值a(U),则必有|S[a,3]||NS[a]|或|S[a-,3]||NS[a-]|.证明.若|S[a,3]||NS[a]|,则结论成立.否则由引理4的结论立即得到|S[a-,3]|=|NS[a]|>|S[a,3]|=|NS[a-]|.证毕.由引理4和推论1,可以在一位跳变局部搜索结束后,利用所有布尔变量赋值全部取反,进一步改善算法性能.算法2.all-flip(U,C).1.调用one-flip(U,C)得到布尔变量赋值a(U);2.If(|S[a,3]||NS[a]|)thenb(U)←a(U);3.Elseb(U)←a-(U);4.Endif5.Returnb(U)因为算法one-flip(·)一定结束,所以该算法也必定结束.调用one-flip(·)得到布尔变量赋值a(U),计算S[a,1]、S[a,2]、S[a,3]、NS[a]的时间复杂性为O(m),所以执行算法步2~5的时间复杂性为O(m).所以算法时间复杂性与one-flip(·)的时间复杂性相同,为O(m2n).m,n分别为Max-(3)-SAT实例中项数目和布尔变量数目.下面分析算法all-flip(·)的性能.引理5.设算法all-flip(·)得到的布尔变量赋值为b(U),则|S[b,1]|+|S[b,2]|3|NS[b]|.证明.设调用算法one-flip(·)得到的布尔变量赋值为a(U),由C[j,T]的定义可知,对于任意j,1jn,有S[a,3]∩C[j,T]=且S[a,2]∩C[j,T]=,S[a,1]中的每个项包含在一个且仅一个C[j,T]中,所以引理2的结论可更确切地表示为|S[a,1]|=∑n|S[a,2]|∑n得到|S[a,1]|+|S[a,2]|3|NS[a]|.由引理4和推论1知,|S[b,1]|+|S[b,2]|=|S[a,1]|+|S[a,2]|,|NS[a]||NS[b]|.所以|S[b,1]|+|S[b,2]|3|NS[b]|.定理2.设算法all-flip(·)得到的布尔变量赋值为b(U),S[b]和NS[b]为被b(U)满足和不被b(U)满足的项集合,则|S[b]|4Page6证明.由算法2~4步的条件语句和推论1可知,|S[b,3]||NS[b]|.由引理5,|S[b,1]|+|S[b,2]|3|NS[b]|.所以|S[b]|=|S[b,1]|+|S[b,2]|+|S[b,3]|4|NS[b]|.所以|S[b]|45|C|.为5/4.由定理2可知,算法all-flip(·)的近似性能比例.U={u1,u2,u3},C={C1={u1,u2,u3},C2={u-3},C5={u-u-F时,算法all-flip(·)得到一个局部最优解,C1不被a(U)满足,C2、C3、C4和C5均被a(U)满足,算法解答这个实例的近似性能比恰为5/4.若Max-(3)-Sat实例中存在含有多于3个字母的项,则在算法all-flip(·)中,应比较全满足与不满足的项数目,决定是否将所有布尔变量赋值取反.所有布尔变量赋值有条件取反的步骤,使得全满足项的数目不少于不满足项的数目,且不改变半满足项的数目,半满足的项数目仍然不少于不满足项数目的3倍.所以算法解答这种实例的近似性能比仍不大于5/4.4一位跳变加全体跳变8/7-近似局部搜索算法前面算法考虑的布尔变量赋值所满足的项,仍然未能包括2-满足的项.下面假设每个项均含有3个布尔变量字母,我们利用一位跳变,最大化1-满足和2-满足项集合的局部搜索方法,改善算法性能.给定布尔变量赋值a(U).选择任意一个布尔变量赋值取反,任意项Ct的可满足性变化有如下性质:2-满足或不满足,不可能变为3-满足;1-满足,不可能变为2-满足或3-满足;(1)若Ct∈NS[a],则Ct仍为不满足或变为(2)若Ct∈S[a,1],则Ct仍为1-满足或变为(3)若Ct∈S[a,2],则Ct仍为2-满足或变为(4)若Ct∈S[a,3],则Ct仍为3-满足或变为由此,设C[j,0]表示将a(uj)取反,由不满足变为1-满足的项集合;C[j,1]表示将a(uj)取反,由2-满足,不可能变为1-满足或不满足.1-满足或3-满足,不可能变为不满足;1-满足变为不满足的项集合;C[j,2]表示将a(uj)取反,由2-满足变为3-满足的项集合;C[j,3]表示将a(uj)取反,由3-满足变为2-满足的项集合.即C[j,0]={Ct|Ct∈NS[a],a(Ct,uj)=F}(2)C[j,1]={Ct|Ct∈S[a,1],a(Ct,uj)=T}(3)C[j,2]={Ct|Ct∈S[a,2],a(Ct,uj)=F}(4)C[j,3]={Ct|Ct∈S[a,3],a(Ct,uj)=T}(5)其中,1jn.一个布尔变量赋值取反跳变,最大化1-满足和2-满足项集合的算法如下.算法3.oneflip-max3sat(U,C).1.a(uk)←Rand{T,F},1kn;2.While(存在uj,使|C[j,1]|+|C[j,2]|<3.a(uj)←a(uj);4.EndWhile5.Returna(U)算法的While循环中,执行一次语句3的变量赋值取反操作,则C[j,0]中的项由不满足变为1-满足;C[j,3]中的项由3-满足变为2-满足;C[j,1]中的项由1-满足变为不满足;C[j,2]中的项由2-满足变为3-满足,1-满足与2-满足的项数目之和至少增加1.因C中只有m个项,所以算法While循环一定能够结束.对于每个布尔变量,计算|C[j,·]的时间复杂性为O(m),所以算法在While循环中找到一个uj满足|C[j,1]|+|C[j,2]|<|C[j,0]|+|C[j,3]|的时间复杂性为O(mn).每循环一次,1-满足和2-满足的项数目至少增加1,所以算法时间复杂性为O(m2n).下面再分析算法的性能.引理6.设算法oneflip-max3sat(U,C)得到布尔变量赋值a(U),则对于任意uj,有|C[j,1]|+|C[j,2]||C[j,0]|+|C[j,3]|.证明.若存在uj,满足|C[j,1]|+|C[j,2]|<|C[j,0]|+|C[j,3]|,由算法的循环条件可知While循环不会结束.引理7.设算法结束时得到布尔变量赋值a(U),则|S[a,1]|+|S[a,2]|=∑n∑n|C[j,2]|.j=1证明.设Ct={x[t,1],x[t,2],x[t,3]},x[t,j]∈{u1,…,un,u-S[a,1],不失一般性,设a(x[t,1])=T,a(x[t,2])=a(x[t,3])=F.当且仅当x[t,1]赋值取反时,Ct变为不满足,其它布尔变量赋值取反,Ct仍为1-满足或Page7引理8.设算法结束时得到布尔变量赋值变为2-满足,设x[t,1]∈{uj,u-但对于x≠j,CtC[x,1],即Ct出现在一个且仅一个C[j,1]中,所以|S[a,1]|=∑n证|S[a,2]|=∑n|S[a,2]|=∑na(U),则3|S[a,3]|+3|NS[a]|=∑n∑n|C[j,0]|.j=1证明.我们证明任意Ct∈NS[a],存在3个且仅3个正整数j1,j2,j3,使Ct∈C[j1,0],Ct∈C[j2,0],Ct∈C[j3,0].设Ct={x[t,1],x[t,2],x[t,3]}∈NS[a],a(x[t,1])=a(x[t,2])=a(x[t,3])=F.只有x[t,1]或x[t,2]或x[t,3]赋值取反,Ct会由不满足变为1-满足,即a(Ct,x[t,1])=a(Ct,x[t,2])=a(Ct,x[t,3])=T.设x[t,1]∈{uj1,u-{uj2,u-Ct∈C[j2,0],Ct∈C[j3,0],而对于任意x{j1,j2,j3},有a(Ct,ux)=a(Ct,u-C[x,0].所以∑n∑n|C[j,3]|=3|S[a,3]|.所以,∑n∑n|C[j,3]|=3|NS[a]|+3|S[a,3]|.证毕.j=1定理3.设算法结束时得到布尔变量赋值a(U),则|S[a,1]|+|S[a,2]|6min{|NS[a]|,|S[a,3]|}.|S[a,1]|+|S[a,2]|=∑n证明.由引理7、引理6和引理8得j2},x[t,3]∈{uj3,u-j=1定理得证.由定理3,若|S[a,3]||NS[a]|,则算法one-flip-max3sat(·)得到的解a(U),使1-满足与2-满足的项数目之和至少为不满足项数目的6倍.但若|S[a,3]|<|NS[a]|,如|S[a,3]|=0,则算法得到的解只能保证1-满足和2-满足的项数目不少于不满足项数目的3倍.在算法中增加所有布尔变量赋值有条件取反的步骤,可使算法的近似性能比达到8/7.算法4.allflip-max3sat(U,C).1.调用oneflip-max3sat(U,C)得到布尔变量赋值2.If(|S[a,3]||NS[a]|)thenb(U)←a(U);3.Elseb(U)←a-(U);4.Endif5.Returnb(U)该算法的时间复杂性仍为O(m2n),我们不再具体分析算法的时间复杂性.引理9.设算法allflip-max3sat(·)得到的布尔变量赋值为b(U),则|S[b,3]||NS[b]|.证明.观察算法allflip-max3sat(·)的步2~4,由引理4和推论1即得|S[b,3]||NS[b]|.定理4.设算法allflip-max3sat(·)得到的布尔变量赋值为b(U),则|S[b]|7证明.设调用算法oneflip-max3sat(·)得到的布尔变量赋值a(U).由引理4和推论1得,|S[b,1]|+|S[b,2]|=|S[a,1]|+|S[a,2]|,由引理9,|NS[b]|=min{|S[b,3]|,|NS[b]|}.所以由定理3我们得到|S[b]|=|S[b,1]|+|S[b,2]|+|S[b,3]|6min{|S[b,3]|,|NS[b]|}+|S[b,3]|7|NS[b]|.所以|S[b]|7能比为8/7.定理4说明算法allflip-max3sat(·)的近似性例.设U={u1,u2,u3,u4,u5,u6},C={C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15,C16}.每个项的布尔变量字母集表示如下:NS[a]C1={u1,u2,u3},C2={u4,u5,u6}.S[a,3]C3={u-1,u-2,u-3},C4={u-4,u-5,u-6}.S[a,1]C5={u-1,u4,u5},C6={u-2,u5,u6},C7={u-3,u6,u4},S[a,2]C11={u1,u-4,u-5},C12={u2,u-5,u-6},C13={u3,u-6,u-4},当a(u1)=a(u2)=a(u3)=a(u4)=a(u5)=a(u6)=F时,算法得到局部最优解,NS[a]={C1,C2},S[a]={C3,…,C16},S[a]=7法的最优解可使所有项都被满足,算法解答这个实Page8例的近似性能比恰为8/7.若Max-(3)-Sat实例中存在含有多于3个字母的项,则在算法oneflip-max3sat(·)中,应利用一位跳变最大化半满足的项,从而可证明局部最优解得到的布尔变量赋值所产生的半满足项数目,不少于全满足和不满足项数目总和的3倍.因此在算法allflip-max3sat(·)中应比较全满足与不满足的项数目,决定是否将所有布尔变量赋值取反.所有布尔变量赋值有条件取反的步骤,使得全满足项的数目不少于不满足项的数目,且不改变半满足的项数目.因此半满足项与全满足项数目之和不少于不满足项数目的7倍,算法近似性能比仍不大于8/7.5Max-(犽)-Sat问题(2犽+2)/(2犽+1)-近似算法每个项均含有不少于k个布尔变量字母的Max-Sat子问题即为Max-(k)-Sat问题.不难推知,算法one-flip(·)解答Max-Sat问题的近似性能比为2,解答Max-(2)-Sat问题的近似性能比为3/2.算法all-flip(·)解答Max-(2)-Sat问题的近似能比为4/3.本节考虑k4的情况,利用类似于解答Max-(3)-Sat问题的局部搜索方法,给出解答Max-(k)-Sat问题的一位跳变后跟全体跳变的局部搜索算法,使其近似性能比达到2k+2设k4,且假设Max-(k)-Sat问题实例中,每个项均含有k个布尔变量字母.不再讨论实例中存在含有多于k个字母项的情况.设Ct={x[t,1],x[t,2],…,x[t,k]},给定布尔变量赋值a(U).延用前面项关于(被)布尔变量赋值j-满足的概念,0jk,其中0-满足为不满足;k-满足为全满足;[1~k-1]-满足均为半满足.另设S[a,j]为关于布尔变量赋值a(U)是j-满足的项集合.S[a]和NS[a]为被a(U)满足和不被a(U)满足的项集合.给定Max-(k)-Sat问题实例的布尔变量赋值a(U),一个布尔变量赋值取反,任意项Ct的可满足性变化有如下性质:(1)若Ct∈NS[a],则Ct仍为不满足或变为1-满足,不可能变为j(2)-满足.(2)若Ct∈S[a,j],1jk-1,则Ct仍为j-满足或变为(j+1)-满足或(j-1)-满足,不可能变为(j+x)-满足或(j-y)-满足,2xk-j,2yj.(3)若Ct∈S[a,k],则Ct仍为k-满足或变为(k-1)-满足,不可能变为(k-x)-满足,2xk.一个布尔变量赋值取反,对于满足2jk-2的j,j-满足的项不可能变为不满足或k-满足;不满足或k-满足的项也不可能变为j-满足.由此我们仍然假设C[j,0]表示将a(uj)取反,由不满足变为1-满足的项集合;C[j,1]表示将a(uj)取反,由1-满足变为不满足的项集合;C[j,k-1]表示将a(uj)取反,由(k-1)-满足变为k-满足的项集合;C[j,k]表示将a(uj)取反,由k-满足变为(k-1)-满足的项集合.即C[j,0]={Ct|Ct∈NS[a],a(Ct,uj)=F}(7)C[j,1]={Ct|Ct∈S[a,1],a(Ct,uj)=T}(8)C[j,k-1]={Ct|Ct∈S[a,k-1],a(Ct,uj)=F}C[j,k]={Ct|Ct∈S[a,k],a(Ct,uj)=T}(10)其中,1jn.下面给出一个布尔变量赋值取反跳变,最大化1-满足至(k-1)-满足的项集合,然后所有布尔变量赋值有条件取反的算法.算法5.flip-maxksat(U,C).1.a(uk)←Rand{T,F},1kn;2.While(存在uj,使|C[j,1]|+|C[j,k-1]|<3.a(uj)←a(uj);4.EndWhile5.If(|S[a,k]||NS[a]|)thenb(U)←a(U);6.Elseb(U)←a-(U);7.Endif8.Returnb(U).在算法While循环条件中,仅比较了1-满足转化为不满足和(k-1)-满足转化为k-满足项,与不满足转化为1-满足和k-满足转化为(k-1)-满足项的数目,这是因为2-满足至(k-2)-满足的项不可能因一个布尔变量赋值取反转化为不满足或k-满足,反之亦然.算法的While循环中,执行一次语句3的变量赋值取反操作,则C[j,0]中的项由不满足变为1-满足;C[j,k]中的项由k-满足变为(k-1)-满足;C[j,1]中的项由1满足变为不满足;C[j,k-1]中的项由(k-1)-满足变为k-满足,[1~k-1]-满足的项数目至少增加1.因C中只有m个项,所以算法While循环一定能够结束.注意,执行一次语句3的变量赋值取反操作,1-满足和(k-1)-满足的项数目未必一定增加,这是因为1-满足的项可能变为2-满足;(k-1)-满足的项可能变为(k-2)-满足.对于每个布尔变量,计算C[j,x]的时间复杂性为Page9O(km),1jn,x∈{0,1,k-1,k}.算法在While循环中找到一个uj满足|C[j,1]|+|C[j,k-1]|<|C[j,0]|+|C[j,k]|的时间复杂性为O(kmn).每循环一次,[1~k-1]-满足的项数目至少增加1,所以算法时间复杂性为O(km2n).下面分析算法的近似性能比.引理10.设算法flip-maxksat(U,C)步1~4的While循环结束时,得到布尔变量赋值a(U),则对于任意uj,|C[j,1]|+|C[j,k-1]||C[j,0]|+|C[j,k]|).证明.若存在uj,满足|C[j,1]|+|C[j,k-1]|<|C[j,0]|+|C[j,k]|,由算法While循环条件可知,While循环不会结束.引理11.给定布尔变量赋值a(U),所有布尔变量赋值均取反得到a-(U),则S[a-,1]∪…∪S[a-,k-1]=S[a,1]∪…∪S[a,k-1],NS[a-]∪S[a-,k]=NS[a]∪S[a,k].证明.所有布尔变量赋值取反,j-满足的项变为(k-j)-满足,因1jk-1,所以S[a-,1]∪…∪S[a-,k-1]=S[a,1]∪…∪S[a,k-1].同理NS[a-]∪S[a-,k]=S[a,]∪S[a,k].证毕.推论2.设算法flip-maxksat(·)得到布尔变量赋值b(U),则|S[b,k]||NS[b]|.证明.由算法步5~7和引理11可知,|NS[b]|=min{|NS[a]|,|S[a,k]|},|S[b,k]|=max{|NS[a]|,|S[a,k]|}.所以|S[b,k]||NS[b]|.引理12.设算法结束时得到布尔变量赋值b(U),则∑k-1k-1|.时,得到的布尔变量赋值a(U)满足∑k-1∑n|C[j,1]|+∑n设Ct={x[t,1],…,x[t,k]},x[t,j]∈{u1,…,un,u-失一般性,设a(x[t,1])=T,a(x[t,2])=…=a(x[t,k])=F.当且仅当x[t,1]赋值取反时,Ct变为不满足,其它布尔变量赋值取反,Ct仍为1-满足或变为2-满足.设x[t,1]∈{uj,u-C[j,1],但对于x≠j,CtC[x,1],即Ct出现在一个且仅一个C[j,1]中,另外C[j,1]中仅含有S[a,1]证明.先证明算法步1~4的While循环结束j=1中的项,所以|S[a,1]|=∑n|S[a,k-1]|=∑n∑n|C[j,1]|+∑n由引理11,∑k-1引理13.设算法结束时得到布尔变量赋值j=1理得证.b(U),则k|S[b,k]|+k|NS[b]|=∑n∑n|C[j,k]|.j=1证明.先证明算法步1~4的While循环结束时,得到的布尔变量赋值a(U)满足,k|S[a,k]|+k|NS[a]|=∑n设Ct={x[t,1],…,x[t,k]}∈NS[a],a(x[t,1])=…=a(x[t,k])=F.Ct中每个布尔变量字母赋值取反,Ct会由不满足变为1-满足,即a(Ct,x[t,1])=…=a(Ct,x[t,k])=T.设x[t,y]∈{uj[y],u-意x{j[y]:1yk},有a(Ct,ux)=a(Ct,u-N,所以CtC[x,0].所以∑n同理可证∑n0]|+∑n+|S[b,k]|,所以引理得证.b(U),则∑k证明.由引理12、引理10和引理13得∑k-1|S[b,j]|∑nj=1由引理11得,|NS[a]|+|S[a,k]|=|NS[b]|定理5.设算法结束时得到布尔变量赋值j=1由推论2,|NS[b]||S[b,k]|,所以∑k-1j=1Page10j=1且有∑k(2k+1)|NS[b]|,所以∑k由定理5可得,算法flip-maxksat(·)的近似性能比为2k+26两位跳变局部搜索算法直观想法告诉我们,每次将多个布尔变量赋值取反的局部搜索方法,能够尝试更多可能的布尔变量赋值,因而可能获得更好的解.现在讨论每次选择两个布尔变量赋值取反,解答Max-(k)-Sat问题的局部搜索方法.将这种方法称为两位跳变的局部搜索算法.下面叙述中总假设k3,每个项均含有k个布尔变量字母.给定Max-(k)-Sat问题实例:U、C和布尔变量赋值a(U),C中的项分为1-满足,…,k-满足和不满足,共k+1类,S[a,j]为j-满足的项集合,1jk,NS[a]为不满足的项集合.另外假设C[i,j,x]表示布尔变量ui和uj赋值取反,由x-满足变为不满足或k-满足的项集合;C[i,j,0]表示布尔变量ui和uj赋值取反,由不满足变为x-满足的项集合;C[i,j,k]表示布尔变量ui和uj赋值取反,由k-满足变为x-满足的项集合,其中1xk-1.为方便,假设S[a,1~k-1]=∪k-1C[i,j,1~k-1]=∪k-1S[a,i]∩S[a,j]=,所以|S[a,1~k-1]|=∑k-1|S[a,j]|,|C[i,j,1~k-1]|=∑k-1j=1对于k=3和k4两种情况,S[a,1~k-1]和C[i,j,1~k-1]中的项无法用统一形式表示,因而算法性能也有所不同.我们先给出两位跳变解答Max-(k)-Sat问题算法的统一描述形式,再分k=3和k4两种情况分析算法的性能.算法6.twoflip-maxksat(U,C).1.a(uk)←Rand{T,F},1kn;2.While(存在uj,使|C[i,j,1~k-1]|<|C[i,j,0]|+|C[i,j,k]|)do3.a(ui)←a(ui);a(uj)←a(uj);4.EndWhile5.If(|S[a,k]||NS[a]|)thenb(U)←a(U);6.Elseb(U)←a-(U);7.Endif8.Returnb(U).算法的While循环执行一次,需要针对两个布尔变量ui,uj分别计算项集合S[a,1],…,S[a,k],NS[a]和C[i,j,0],…,C[i,j,k],可在O(km)时间内完成.每执行一次变量赋值取反操作,S[a,1~k-1]中的项数目至少增加1.因C中只有m个项,所以算法While循环一定能够结束.算法在While循环中找到两个布尔变量ui,uj满足|C[i,j,1~k-1]|<|C[i,j,0]|+|C[i,j,k]|的时间复杂性为O(kmn2).每循环一次,[1~k-1]-满足的项数目至少增加1,所以算法时间复杂性为O(km2n2).下面所采用的符号与前面相同,总假设S[a,·]和NS[a]表示算法While循环结束时,被赋值a(U)满足的项集合和不被a(U)满足的项集合;S[b,·]和NS[b]表示算法结束时,被赋值b(U)满足的项集合和不被b(U)满足的项集合.另外我们下面只给出结论的简要证明.引理14.布尔变量赋值a(U)满足:|C[i,j,1~k-1]||C[i,j,0]|+|C[i,j,k]|,i≠j,1i,jn.证明.若存在ui,uj,满足|C[i,j,1~k-1]|<|C[i,j,0]|+|C[i,j,k]|,由算法While循环条件可知,While循环不会结束.(1)解答Max-(3)-Sat问题的性能分析引理15.布尔变量赋值b(U)满足(n-2)|S[b,1]|+(n-2)|S[b,2]|证明.每个S[a,1]中的项在C[i,j,1~2]中出现1+(n-3)=n-2次;每个S[a,2]中的项在C[i,j,1~2]中出现1+(n-3)=n-2次.所以(n-2)|S[a,1]|+(n-2)|S[a,2]|由引理11可知,|S[a,1]|+|S[a,2]|=|S[b,1]|+|S[b,2]|.所以引理结论为真.引理16.布尔变量赋值b(U)满足3(n-2)|NS[b]|+3(n-2)|S[b,3]|证明.每个NS[a]中的项在C[i,j,0]中出现Page113+3(n-3)=3(n-2)次;每个S[a,3]中的项在C[i,j,3]中出现3+3(n-3)=3(n-2)次.所以3(n-2)|NS[a]|+3(n-2)|S[a,3]|由引理11可知,|NS[a]|+|S[a,3]|=|NS[b]|+|S[b,3]|,所以引理结论为真.证毕.定理6.算法结束时得到布尔变量赋值b(U),则|S[b]|7证明.由引理15、引理14和引理16得(n-2)|S[b,1]|+(n-2)|S[b,2]|=∑n-1i=1∑n∑n-1i=1∑n=3(n-2)|NS[b]|+3(n-2)|S[b,3]|(14)又由算法5~7步的条件语句可知,|NS[b]||S[b,3]|,所以|S[b,1]|+|S[b,2]|6min{|NS[b]|,S[b,3]|}|S[b]|=|S[b,1]|+|S[b,2]|+|S[b,3]|由|C|=|S[b]|+|NS[b]|,即得|S[b]|78|C|.由定理6我们知道,选择两个布尔变量赋值取反跳变的局部搜索算法,在解答Max-(3)-Sat问题时,近似性能比仍为8/7.(2)解答Max-(k)-Sat(k4)问题的性能分析引理17.布尔变量赋值a(U)满足(n-k)|S[a,1]|+|S[a,2]|+|S[a,k-2]|+(n-k)|S[a,k-1]|=∑n-1次.所以结论为真.证明.若k=4,则①每个S[a,1]中的项在C[i,j,1]中出现n-②每个S[a,2]中的项在C[i,j,2]中出现2次;③每个S[a,3]中的项在C[i,j,3]中出现n-4若k5,则①每个S[a,1]中的项在C[i,j,1]中出现n-②每个S[a,2]中的项在C[i,j,2]中出现1次;③每个S[a,k-2]中的项在C[i,j,k-2]中出4次;k次;现1次;(1-现n-k次.所以结论为真.④每个S[a,k-1]中的项在C[i,j,k-1]中出引理18.布尔变量赋值a(U)满足(k(n-k)+C2k)|NS[a]|+(k(n-k)+C2k)|S[a,k]|=∑n-1i=1∑nj=i+1证明.每个S[a,0]中的项在C[i,j,0]中出现k(n-k)+C2k次;每个S[a,k]中的项在C[i,j,k]中出现k(n-k)+C2k)次.所以结论为真.证毕.当n5时,只须枚举n个布尔变量的25种取值,可得到Max-(4)-Sat问题的精确解.另外若n=k,则只要m<2k,即可给出布尔变量赋值,使所有项都满足,而若m=2k,则任意布尔变量赋值均为Max-(k)-Sat问题的精确解.因此,下面总假设Max-(k)-Sat问题实例满足:①n6;②若k5,则nk+1.我们在下面的定理证明中,要求Max-(k)-Sat实例总满足这个关于布尔变量数目的假设.定理7.布尔变量赋值b(U)满足|S[b]|2k+2+k(k-1)/(n-k证明.因n-42,所以算法解答Max-(4)-Sat实例时,可由引理17得到(n-4)(|S[a,1]|+|S[a,2]|+|S[a,3]|)(n-4)|S[a,1]|+2|S[a,2]|+(n-4)|S[a,3]|=∑n-1i=1∑n又因若k5,则nk+1,所以算法解答Max-(k)-Sat问题实例时,由引理17得到(n-k)(|S[a,1]|+|S[a,2]|+|S[a,k-2]|+|S[a,k-1]|)(n-k)|S[a,1]|+|S[a,2]|+|S[a,k-2]|+(n-k)|S[a,k-1]|=∑n-1i=1∑n因此对于k4,总有(n-k)(|S[a,1]|+|S[a,2]|+|S[a,k-2]|+|S[a,k-1]|)∑n-1由不等式(19)、引理14和引理18得(n-k)(|S[a,1~k-1]|)(n-k)(|S[a,1]|+|S[a,2]|+|S[a,k-2]|+|S[a,k-1]|)∑n-1i=1∑nPage12j=i+1∑n-1i=1∑n=(k(n-k)+C2k)|NS[a]|+(k(n-k)+C2k)|S[a,k]|再由引理11可得到(n-k)(|S[b,1~k-1]|)(k(n-k)+C2k)|NS[b]|+(k(n-k)+C2k)|S[b,k]|即|S[b,1~k-1]|k+k(k-1)|S[b,k]|).因|NS[b]||S[b,k]|,所以|S[b,1~k]|k(k-1)(1-2k+2+k(k-1)/(n-k由定理7可知,算法twoflip-maxksat(·)的近似性能比为1+
