Page1云计算系统中基于伴随状态追踪的故障检测机制饶翔1)王怀民1)陈振邦1)周扬帆2)蔡华3)周琦3)孙廷韬3)1)(国防科学技术大学并行与分布处理国家重点实验室长沙410073)2)(香港中文大学深圳研究院深圳)3)(阿里巴巴云计算公司计算平台部杭州310011)摘要在运行时检测分布式系统内所产生的故障需要事先获得故障特征模型.构造故障特征模型的常见做法为将故障注入系统并根据随后系统内所产生的特征症状(如异常事件日志)建模.已有建模方法通常使用从故障发生到给定时间窗口之内的特征症状.然而,根据真实系统观察,不同故障的传播影响时间相差很大,且故障特征会在故障传播过程中发生改变.因此,已有方法对检测时间窗口之后发的故障特征症状不能识别或会产生大量错误报警.为了解决此问题,文中提出一种基于故障注入测试的故障特征提取方法,该方法主要由3步组成:(1)过滤噪声日志;(2)构造1个故障识别器识别不同故障的早期特征;(3)为每类故障构造限状态追踪器追踪该故障的后期传播状态,从而在故障被识别出来后持续跟踪故障传播状态.通过在企业级云计算系统中进行实验验证,与已有方法相比该文方法具备更高的故障检测精确度.关键词事件日志;故障检测;故障注入;故障特征提取;云计算系统1引言企业级分布式系统往往需要同时处理数以百万计的用户请求,其承载的巨大业务量以及复杂的系统运行环境导致在日常运营中会遇到大量故障.如根据为期1年的观察统计,即使在阿里巴巴云计算公司的一个内部小集群中,平均每天也会遇到近100条各类故障报警.为了保证应用系统7×24的可用性,企业级分布式系统在设计之初都会考虑一些可信保障机制以容忍系统运行时遇到的故障,ECA(Event-Condition-Action)是该类机制的常用模式:通过持续监视系统的异常行为,并在运行时定位导致系统异常的故障原因,然后执行所对应容错、调度操作.如,一旦检测出系统当前大量错误日志由某进程实例崩溃造成,则重启该进程实例并恢复状态;当进一步发现该进程实例持续崩溃,次数过多以至于超过了设定阈值,则将所有与该进程实例相关的所有其它进程实例全部重启,甚至重启相关主机[1].由于故障定位结果为系统执行上述策略的输入或者直接触发条件,所以故障定位方法的准确性非常重要.准确的故障定位结果除了能够方便系统运维人员准确地了解系统行为,对系统进行管理之外,更重要的是能避免由于错误触发相关容错、调度机制给系统带来的扰动,并造成系统可用性、可靠性的影响.系统日志信息为分析系统行为的天然数据源,与专用的监视机制相比,日志信息往往为各类系统的标准配置,基于日志信息的研究方法往往具备通用性,因此大量相关工作以日志信息作为研究对象,尝试从中直接提取故障特征或者分析故障原因[2-5].其中,一种典型提取故障特征的方法为故障注入法,通过将故障注入系统,并且观察随后产生的日志序列,从中提取故障特征.如,通过人为使某进程实例崩溃,将之后出现的特殊类型日志作为该进程实例崩溃故障的特征,则在运行时一旦观察到这几类日志出现,则可以认为该进程实例崩溃发生,从而触发相应的操作,如重启该进程.为了提取故障特征模型,相关工作往往基于故障特征时间窗口的方法.该类方法假设故障特征会在某设定的时间窗口内出现,只需要分析该时间窗口内的信息即可以提取相关特征.该特征时间窗口往往取自故障注入起始时间至某个给定时间点,而此检测时间窗口之后的故障特征信息往往被忽略.然而,基于在阿里巴巴云计算公司的生产系统管理实践中发现,不同故障其传播影响时间非常不同,其产生故障特征的时间窗口差异也很大.如,在目标系统中,不同故障特征的差异从30s到600s不等.随着规模和复杂性的日益增长,现代大规模系统中不同类型故障存在较大差异的现象非常普遍.如果简单将时间窗口设定为最大故障特征的时间窗口,则很可能会遗漏在最大特征时间窗口内发生的其它类型故障,而选取最小特征时间窗口则会错误地识别在特征窗口之外的残余特征.相关工作往往通过选取对所有故障特征识别率最高的时间窗口作为最终的检测窗口,该窗口大小介于最大特征窗口与最小特征窗口之间.因此,使用传统检测窗口故障建模方法的直接结果为:对于一类故障所产生的故障特征信息只能确定其早期的故障特征,而之后的特征将可能会被错误识别,造成误报或者被忽略造成漏报,直接影响系统的故障管理机制,造成系统可用性不必要的抖动.如,当某服务进程实例崩溃,但是除了第1个特征检测窗口正确识别之外,其残余特征影响了之后的检测结果,并被错误地识别为其它类型的故障,系统管理员观察到某台主机上多个不同类型的进程发生崩溃,很可能错误地将该机器重启,严重影响系统的可用性.针对不同类型故障特征持续时间不同的问题,并针对基于固定检测时间窗口故障特征建模机制的不足,本文提出基于伴随状态追踪的故障定位机制,记为CST(CompanionStateTracer).该方法可以识别当前时间窗口内的日志项特征是由新的故障所引起还是之前发生的故障引起,从而消除故障定位结果的误报、漏报.通过将CST部署于阿里巴巴云计算公司的测试集群中,我们对CST的有效性进行了验证.实验结果表明,与传统固定故障特征窗口方法相比,CST能够以更细粒度的方式追踪故障特征的状态变化从而降低系统报警的误报率和漏报率.本文第2节对基于伴随状态的故障追踪问题进行描述,包括相关定义、实际系统的观察以及故障特征提取问题的前提假设;第3节介绍基于决策树模型的主特征建模方法;第4节详细介绍伴随状态追踪器的构造方式;第5节给出基于伴随状态追踪的故障定位方法整体框架;第6节为实验与分析;第7节为相关研究工作;最后,第8节总结本节的工作及主要贡献.Page32问题描述2.1基本观察为了建模系统内的故障特征,我们手动向系统中重复多次注入故障,并使用[ts,ts+Tw]时间窗口内的日志信息对故障特征进行建模[4,6],具体过程如下:(1)手动将故障f于时刻ts注入系统,之后可能观察到请求失效的情况.(2)在请求失效后第1个成功请求发生时刻将被记为故障恢复时刻,记为te.(3)Ei,1=〈e1,e2,…,em〉为在第i轮测试中故障特征窗口[ts,ts+Tw]内收集的日志类型特征向量信息,并假设这些日志信息与故障f相关,因此将Ei,1的故障特征类型标识为f.其中ej代表日志类型j在故障特征窗口[ts,ts+Tw]内的出现情况,1代表出现而0代表不出现.(4)对有被标识故障特征类型的日志类型特征向量使用C4.5决策树模型[4]构建方法,从而得到一个基于规则的故障分类器.图1不同时间窗口下的F-Measure值现象1.最优检测时间窗口出现在故障传播初期.为了更清晰地了解最优故障特征时间窗口的选取情况,我们将图1(a)的前部分进行放大得到图1(b).可以观察,最大wFmeasure所对应的Tw为6s(对应时间戳为2),这也意味着故障的早期特征的确能有效区分不同故障.现象2.随着故障特征窗口逐渐增大,故障模型的准确率收敛非常快.从图1(a)可以看出,在36s(对应时间戳为12)之后,故障特征的有效性基本不再改变.现象3.只有早期的故障特征能够被识别出来,而故障特征会随着故障传播的阶段而发生变化.为了解释上述现象,我们尝试分析文件系统以进程崩溃故障为例,图3展示了设定不同时间窗口Tw所得到的故障模型有效性.基于10折交叉验证方法,我们衡量了所有类型进程崩溃故障的精确率(正确检测与所有检测出结果的比例)和召回率(正确检测与所有注入故障的比例)以及精确率和召回率的调和平均值F-Measure.如式(1)所示,tp、fp和fn分别代表真正(truepositive)、假正(falsepositive)和假负(falsenegative).而所有故障特征F-Measure的平均值记为wFmeasure,我们最终使用wFmeasure来衡量故障特征的整体有效性.为了找到能获得最大wFmeasure值的最优检测窗口Tw,我们使用了常用的迭代法[6-7]:首先将Tw值设定为很小的值,然后逐步增大(如每次增加3s),以最长故障传播时间为最大时间窗口限制.如图1(a)所示,x轴为代表故障注入后的最初Tw秒(即检测窗口).我们使用测试用例中最长的故障传播时间作为Tw的最大值,即FSmr将近600s的故障特征持续时间.由于空间限制,图1(a)只显示了前50个时间戳(以3s为间隔).对于故障传播时间小于Tw的故障,则直接使用其整个故障传播周期[ts,te]内的数据.master进程(FSmr)崩溃的故障特征.FSmr失效后的自动恢复时间为大约600s,其影响在日志信息中展现的模式如图2所示.图2中,x轴为以3s为单位所记录的时间戳,开始时间为FSmr进程实例崩溃的时间,结束时间为该服务正常响应请求的时间;y轴为在每个采样时间窗口内出现的日志类型数量,其中不同类型的日志信息使用了不同的颜色进行标识.precision=tprecall=tpPage4由图2可以观察,在故障特征的不同阶段,日志类型的出现有明显的变化规律.故障早期有几类特殊的日志出现,但是出现的总类型数量不多,而且出现规律比较杂乱;在故障中期,虽然出现的日志类型较多,但是与初期的日志类型有较大差异,且规律比较稳定;在故障后期,出现日志类型明显减少,规律也比较稳定.图2FSmr崩溃故障的日志类型特征向量变化模式示例为了验证使用固定故障特征窗口所构建故障特征的有效性,我们将不同故障特征窗口所创建的故障特征识别规则应用于FSmr故障持续的整个周期,并衡量了识别结构的误报率(falsepositiverate),结果如图所示.在图3中,x轴为间隔为3s的故障特征窗口Tw值,y轴误报率.可以观察:对于所有故障特征窗口取值,由于仅仅只有第1个故障特征窗口(即[ts,ts+Tw])中的日志信息被正确识别为FSmr,而其它检测窗口则被错误识别为其它故障类型.虽然误报率度会随着Tw的增大而降低,但是这种增长是由分母(故障传播周期内的采样数量)变小造成的,与模型的好坏无关.综合以上观察,我们发现:虽然每类故障特征的规律可能不一样,但是结合图3以及图1(a)我们不难看出,故障特征的快速收敛性意味着后期的故障特征相对初期故障特征显著性较底.由于后期故障图3最优故障特征模型应用于FSmr故障持续周期的识别率特征往往由故障恢复、状态同步等行为展现,而并非单纯故障本身的影响,因此可能与其它故障的后期行为区别较小,其行为也与故障早期的行为差别很大.所以,一方面,使用早期故障模型不足以识别后期故障模型,另一方面,后期故障特征对故障特征显著性的提升作用较小.这种现象最终造成的影响为:故障特征窗口方法不足以识别故障特征窗口之外的故障特征.如果不解决此问题,则会造成故障定位结果存在大量错报或误报,很难将基于故障特征的故障定位方法运用于系统在线故障管理之中.2.2相关定义对故障特征进行“持续建模”的关键为从原始日志信息中提取故障传播的状态变化规律.通常基于事件日志信息提取状态变化规律会从日志信息的事件特性入手,从日志序列中提取事件日志的因果规律.如相关工作通过日志分析函数调用序列[3,8-9],从而构造事件序列模型用于异常检测和故障定位.然而,由于分布式系统中不同主机的CPU时钟并不同步,导致很难直接推导出日志事件粒度的因果关系模型.虽然在目标系统通过网络时间同步协议使得时间误差在秒级以内,但是对于使用微秒粒度记录的日志来说仍然存在较大误差.我们通过将系统状态变化模型抽象为以特定采样窗口为粒度的日志类型特征向量变化序列模型,来降低事件序列分析问题的维度,进而在相对粗粒度的情况下构建较为准确的故障特征变化模型.在整个方法中,我们将日志类型特征向量作为故障行为特征抽象的基本单元,定义如下.定义1(日志类型特征向量).给定故障类型f,日志类型标识集合T={1,2,…,m},日志监视时间窗口Tw,故障f第i轮测试第j个检测窗口内的日志类型特征向量犈i,j=〈e1,e2,…,em〉.其中et∈{1,0},t∈T表示日志类型t的出现情况:1代表出现,0代表未出现.定义2(主要特征).给定故障类型f,日志监视时间窗口Tw,故障注入的起始时间ts,故障恢复时间te,主要特征为从[ts,ts+Tw]中出现的日志项中提取的故障特征.定义3(伴随特征).给定故障类型f,日志监视时间窗口Tw,故障注入的起始时间ts,故障恢复时间te,伴随特征即从(ts+Tw,te]中出现的日志项中提取的故障特征.我们通过对所有故障的主要特征进行统一建Page5模,然后再对每类故障伴随特征进行独立建模,从而在初始定位某类故障后使用伴随特征对该类故障的状态进行持续追踪.具体本文所使用的相关符号与定义见表1所述.fRmT={1,2,…,m}日志类型集合,其中所有日志类型进行排ts,teTwTfthSet犈i,j=〈e1,e2,…,em〉故障f第i轮测试第j个检测窗口内的Pi,j=〈t1,t2,…,tk〉Pi,j_ex=〈Pi,j,round_id_list〉Sf,i=〈Ei,1,Ei,2,…,Ei,k〉故障f第i轮测试的伴随状态序列SSf=Sf,1+Sf,2+…+Sf,NStfTf,i2.3问题描述为了解决传统基于故障特征窗口的建模方法对故障特征窗口之外的故障行为不能正确识别的问题,本文通过将故障特征窗口建模方法扩展为以基本监视窗口为粒度的故障日志类型特征向量特征序列追踪方法,从而实现对故障特征的持续监视,有效降低了传统故障定位方法的误报与漏报.本节将在如下假设中进行故障定位:(A1)系统在故障注入测试阶段存在持续的请(A2)所有的日志已经分类;(A3)只研究都能在日志中留下特征的故障;(A4)在故障特征提取阶段,一个故障的影响周期内不会发生另一个故障.对于(A1),在面向互联网应用的7天×24小时系统应用背景下,系统几乎持续处于请求响应状态为该类应用的基本假设.通过使用日志属性LogPath和SourceProcess作为分类依据可以保证(A2),同时由于我们研究的基本对象为具有类型标求调用;识的日志信息,所以本文的方法可以很方便地扩展到其它已有的日志分类方法中.对于(A3),虽然可能存在某些故障不会在错误日志中留下踪迹,但是这种情况实际非常少见,与我们基于日志提取故障特征的目标不相符.(A4)为故障独立性假设,不失一般,基于故障注入的故障特征提取相关研究工作通常都做故障独立性假设.3基于决策树模型的主特征建模方法给定故障类型f、日志监视时间窗口Tw、故障注入的起始时间ts、故障恢复时间te、为了识别整个故障传播过程中所出现的所有特征,我们首先将事件日志分为两组,一组为主要特征日志,即[ts,ts+Tw]中出现的日志,另一组为伴随特征日志,即(ts+Tw,te]内出现的日志.基于此划分,完整的故障特征提取方法由3步组成:构造一个基于规则的故障分类器.(1)过滤[ts,te]阶段出现的噪声日志.(2)对于主要特征日志,使用C4.5决策树模型(3)对于伴随特征日志,基于日志项建模其变化模式.对于步骤(1),由于我们采用基于故障注入方式对日志特征进行建模,因此首先需要确定使用与注入故障最为相关的日志信息作为特征提取对象.本文使用两个启发式方法来过滤不相关的日志信息:①在[ts,te]阶段新产生的日志类型将被保留,②对于在故障注入阶段之前已经产生的日志类型,那些不符合其出现规律的日志将被删除.从因果关系分析的角度,那些只有在注入故障之后才出现的日志类型最可能与所注入故障相关;如果注入故障能够影响某些日志类型出现的规律,则这些日志也可能与注入故障相关.因为最可能与注入故障相关;为了过滤这些噪音日志,我们设计了一种基于时间序列相似度的日志预处理方法SBF.SBF独立对每类日志按照其在给定采样间隔内出现的数量将其建模为时间序列.通过在ts之前设定一个噪音采样窗口Tf,SBF对比了[ts-Tf,ts]阶段所收集噪音模板与[ts,te]中相同日志类型的时间序列的相似度,将与噪声采样模板相似的日志当作噪音进行过滤.对于第2步,对主要特征日志进行建模,构造主特征识别器.主特征识别器为一个分类器,通过一个Page6目标函数(targetfunction)将日志类属性映射为预先设定的故障类型标识.常用的分类器包括决策树分类法、基于规则的分类法、神经网络、支持向量机和朴素贝叶斯分类法.其往往需要使用一种学习算法确定分类模型,从而拟合学习样本数据中类型标识与属性集之间的映射关系,并进一步基于此分类模型正确地预测未知样本的类标号[10].构造分类器的一般学习算法需要将数据划分为训练集和检验集.训练集由已经标识了类型的数据记录组成,用于建立分类模型;检验集由类型标识未知的记录组成,用于检验分类器的有效性.有效性的衡量方式可以使用精确率和召回率,具体可以参考式(1),这里不再重复叙述.3.1决策树模型决策树是一种简单有效而被广泛使用的分类技术,常用于解决多属性数据的分类问题.决策树是一种由结点和有向边组成的层次结构,具体包含3种节点[10]:(1)根节点.没有入边,但是有零条或多条出边;(2)内部节点.有一条入边和两条或多条出边;(3)叶节点.只有一条入边,没有出边.根节点与内部节点都用来表示属性测试条件,用于区分不同特性的记录,而叶节点用来表示类型标识.当基于训练集数据构造完分类器之后,从树的根节点开始将其应用于检验集,根据条件判断结果选择不同的分支,最终到达叶节点,则叶节点对应的类型标识即为该检验记录的类型标识,从根节点到该叶节点所经历的路径即决策过程.决策树仅有单一输出,若欲有复数输出,可以建立独立的决策树以处理不同输出.在没有任何剪枝的情况下,决策树模型的规模往往可以达到指数级,因此其构造时间不可控,为了能在合理的时间内构造一个可用的决策树模型,很多经典启发式算法(如贪心算法),往往通过使用一系列局部最优策略构造决策树.经典的决策树构造算法采用递归的方式,每个决策树可以依靠对源数据库的分割进行数据测试.因此,决策树归纳算法设计主要考虑如何分裂训练集,以及如何停止分裂过程.因为决策树生成过程中的每一步都需要选择一个属性判断条件,从而将训练集分裂为较小子集.算法必须提供对不同类型属性的判断方法,并提供每种判断条件的度量方式.而整个决策树过程必须有结束条件,保证递归构造过程的收敛性.获取最佳分裂的策略往往根据划分后子女节点不纯性的程度而来,不纯的程度越低,类分布就越倾斜,也越方便进行划分.常用不纯性度量方法包括信息熵(entropy)、基尼系数(ginicoefficience)以及分类错误(classificationerror).经典的决策树算法为Hunt算法,给定与节点n相关的训练数据集合Rn,其决策树生成过程递归步骤如下:1.如果Rn中的任一元素e同属一类,则创建一个叶子节点n并终止递归;2.否则节点n为属性条件判断阶段节点,依据分裂启发式选择一个属性作为分裂标准,并创建属性分裂判断条件.基于此分类条件,将Rn划分为互不相交的m个集合{Rn,1,Rn,2,…,Rn,m};离散变量;3.对于Rn,i(i∈m)递归执行步1,2.ID3算法通过随机选择Rn的一个子集W,使用Hint生成分类树Ttemp,通过顺序扫描Rn收集Ttemp中无法确定的训练样本集合Exp,然后W与Exp合并形成新W重新验证,直到不再出现异常训练样本.为了保证生成的决策树最小,ID3算法使用的分裂策略选取使生成字数的熵最小的特征进行分裂.ID3算法虽然对生成树的规模进行了有效的控制,但是在实际使用时却有很多局限:(1)ID3算法要求目标数据的所有属性必须为(2)训练集数据中的所有属性信息必须都被(3)每个训练样本必须进行确定标识.为了解决ID3算法在实际应用中存在的上述问题,Quilan提出了C4.5算法.C4.5算法继承了ID3算法的优点,并在以下几方面对ID3算法进行了改进:(1)对熵的计算加上了子树信息,用信息增益率来选择属性,克服了选择属性时偏向选择取值多的属性的不足;赋值;过程中进行剪枝;(2)聚类和剪枝两个步骤合二为一,在树构造(3)能够完成对连续属性的离散化处理;(4)能够对不完整数据进行处理,训练集中的记录不需要所有属性值都被赋值,但是类型标识必须确定;(5)C4.5算法的优点比较明显:产生的分类规则易于理解,准确率较高.其缺点是:在构造树的过程中,需要对数据集进行多次的顺序扫描和排序,因而导致算法低效.此外,C4.5只适合于能够驻留于Page7内存的数据集,当训练集太大无法在内存容纳时程序将无法运行.3.2基于C4.5决策树模型的主特征建模方法为了提取主故障特征,我们使用主特征时间窗口内出现的日志类型特征向量作为基本分析单元.故障f第i轮测试第j个检测窗口内的日志类型特征向量犈i,j=〈e1,e2,…,em〉,其中et∈{1,0},则主故障特征日志类型特征向量为j=1时的日志类型特征向量,即Ei,1.通过将主特征检测时间窗口内的所有日志信息抽象为1条记录(日志类型特征向量),可以有效降低问题分析的维度.通过对所有故障注入测试时收集到日志数据的主特征项进行人为标识,我们可以得到基于日志类型特征向量的主特征训练集.假设系统内总共存在m类日志,则代表一个主故障特征有m维属性,每一个维度属性的取值都为离散值,即{0,1}或者{NO,YES},代表该类型日志的出现与故障发生的关联性.我们选用了C4.5决策树的著名实现Weka的J48决策树模块作为我们提取主故障特征的工具.Weka[11]的全名是怀卡托智能分析环境(WaikatoEnvironmentforKnowledgeAnalysis),由新西兰怀卡托大学的研究小组基于Java环境编写的开源机器学习及数据挖掘工具.虽然工具本身受限于Java实现,其计算效率受到一定制约,但是由于其功能全面,使用方便,最重要的是完全开源,所以一经发布即广泛受到学术界的热捧,近年来大量与数据挖掘相关的研究工作均选用Weka作为基本平台.在Weka中使用C4.5的相关配置参数如表2所示.图4故障主特征决策树示例binarySplits是否使用二叉方法分裂名词性属性FalseconfidenceFactor用于剪枝的置信因子(小于该值minNumObj每个叶节点所支持的最小实例数numFoldsreducedErrorPruning是否使用”减少-误差”方式剪枝,seedunpruned是否需要对结果树进行剪枝False由于我们使用C4.5的剪枝算法,所以numFolds、reducedErrorPruning、seed均不需要设置,原始数据所有属性已经为2维,所以不再需要进行2进制转换,因此binarySplits也不需要设置.C4.5算法会在运行过程中自动剪枝,所以unpruned的设置实际上不会起作用.因此,比较重要的参数为confidenceFactor及minNumObj,其具体含义见表2所示.由于我们最终的研究目标为对故障特征的状态进行跟踪,所以在本节中没有仔细讨论不同参数设置对主特征模型精确率的影响,在整个实验过程中,均使用Weka的默认推荐参数,并由实验验证其有效性.图4为主故障特征决策树在10次测试数据中所得结果示例(Tw=6s),其中为了方便阅读,我们将日志属性取值{0,1}映射为{NO,YES},代表该日志是否出现.实验过程中总共出现的日志类型为164类,最后提取为主故障特征模型的日志类型只有19类.这也从另一个角度说明,在主故障特征窗口之外的确还有很多故障特征待挖掘,而且Page8使用主故障特征很难直接识别主故障特征窗口之外的日志特征.4基于伴随特征追踪的故障定位方法为了识别整个故障传播过程中所出现的所有特征,在上一节我们详细介绍了主要特征日志,即[ts,ts+Tw]中出现的日志中如何提取故障特征的方法.本节将介绍如何从伴随特征日志,即(ts+Tw,te]内出现的日志提取故障特征的方法.4.1伴随状态追踪器总体框架在模型训练阶段,经过预处理之后的事件日志按照检测时间窗口Tw分成两部分:第1部分[ts,ts+Tw]被用来构造主要特征;第2部分[ts+Tw,te]被用来构造伴随状态特征,如图5所示,主要包含3个过程:态识别器;1.图5中第1~3步:提取伴随状态集合并构造伴随状(a)在第i轮测试中,从伴随日志窗口(ts+Tw,te]中以Tw为采样间隔提取日志类型项,并形成日志类型项序列Sf,i,然后将所有Sf,i的项聚集在一起,形成故障f的日志项序列集合SSf=Sf,1+Sf,2+…+Sf,m.(b)为每一类故障f,基于最小支持度阈值min_support=thS×N(其中thS∈[0,1],N为总测试轮数),提取候选伴随状态集合,并为每个伴随状态赋予唯一标识.(c)基于C4.5决策树构造一个伴随状态识别器Stf,用于识别当前所观察到的日志处于故障f特征的什么伴随状态下.2.图5中第4~6步:基于伴随状态序列构造伴随状态(a)重新将Sf,i中的每一个日志类型特征向量犲m映射为Stf中的一个状态,从而获得了一个Sf,i的状态序列Tf,i.(b)基于所有收集到的状态序列集合{Tf,1,Tf,2,…,Tf,N}构造一个有限状态自动机FSMf作为故障f的伴随状态验证器.验证器;3.图5中第7~9步:运行时伴随状态追踪;(a)在运行时刻,将当前时间窗口Tw内收集到的日志项序列使用Stf进行分类,获得相应的伴随状态标识Ci.态是否仍然符合故障f的伴随特征.(b)将伴随状态标识Ci输入FSMf以检验当前伴随状从以上步骤可以看出,伴随状态追踪器的主要挑战在于如何提取伴随状态集合以及构造伴随状态转换模型.以下将着重阐述这2个问题的解决方法.4.2基于prefixSpan的伴随状态集合提取为了寻找针对特定故障f相应的特征向量全集,一种比较直接的方式为使用频繁项挖掘方法找到故障f传播影响过程中出现的频繁日志类型特征向量组合,将其确定为候选伴随状态集合.的数量会呈指数增长;加后都需要重新扫描全数据库;于频繁模式挖掘,但是在使用中存在一些缺陷:(1)prefixSpan算法Apriori作为模式挖掘的经典算法被广泛使用①容易产生大量的候选模式;②需要多次扫描数据库,候选模式长度每次增③不易发现长模式,因为长度增加,候选序列④计算中间过程会产生很大的数据开销.相比之下,prefixSpan[12]算法采用分而治之的思想,先将数据集分割为互不相交的数据子集,然后再在数据子集上进行序列挖掘,只检测前缀序列并构造后缀序列的投影数据库.而在每个投影数据库中,也只检测局部频繁模式,避免了生成候选序列的开销.具体算法描述如下.算法.prefixSpan(a,l,D|a)[12].输入:数据集D,最小支持度阈值min_support,a为长输出:D中的所有频繁序列模式1.扫描D|a一次,找出一个频繁项b,使得b可以添加到a的最后一个元素中,或者〈b〉可以附加到a的最后一个元素之后;2.由b形成长度为l+1的序列模式a;3.构造a的投影数据库D|a;4.递归调用prefixSpan(a,l+1,D|a).需要指出的是,prefixSpan算法本身适用于序列挖掘的场景,本节将其应用于频繁项挖掘场景,需要对输入日志类型特征向量做如下修改.定义4(日志类型项).Pi,j=〈t1,t2,…,tk〉为故障f第i轮测试第j个检测窗口内的日志类型特征向量,其中k代表第j个检测窗口内出现的日志类型总数量,ti∈T,且ti按照日志类型标识按升序排序.与Ei,j相比,Pi,j的长度不再固定,而且其中组Page9成元组为日志类型标识,而不再是{0,1}.Pi,j中的每一个元组相当于prefixSpan算法中长度为1的项.日志类型项Pi,j为已经为组成元组进行排序且不会有重复日志类型标识的项,所以也不会由于元组相对顺序问题影响模式挖掘效果.基于日志类型项,我们可以进一步构造日志类型项序列Sf,i(如图6所示).通过将所有Sf,i聚集在一起可以形成故障f的日志项集合SSf=Sf,1+Sf,2+…+Sf,m.最终prefixSpan算法的输入序列集合为SSf.(2)2维prefixSpan算法基本的频繁项挖掘过程并不足以构造一个有效的状态集合,因为直接使用prefixSpan对SSf进行模式提取所得到的结果中存在大量冗余状态.与整个故障影响周期时间相比,采样窗口Tw可能非常小,某些干扰模式可能仅仅在某几轮测试中以高频率的方式出现,导致非常容易超越min_support阈值并被识别为频繁项,而我们的目标是将那些出现次数较多,而且在很多轮测试中都出现过的模式挖掘出来.为了实现这个目标,我们首先扩展了经典的频繁项挖掘算法prefixSpan,使其支持2维空间中的频繁项搜索.即,只有同时在两个维度上都频繁才是满足要求的候选频繁项.首先,将每个日志类型项Pi,j∈Sf,i转换为2维项Pi,j_ex=〈Pi,j,round_id_list〉,其中round_id_list为此Pi,j出现过的测试轮数id列表,每一个日志类型项的初始round_id_list为其初始出现的测试轮数id.如,日志类型项(A,B,C)在故障f的注入测试的第1,3,5轮测中出现,则(A,B,C)的初始2维项为〈(A,B,C),{1}〉〈(A,B,C),{3}〉〈(A,B,C),{5}〉.经过频繁项集挖掘过程中得到的中间结果为〈(A,B,C),{1,3,5}〉,假设min_support阈值为2,即(A,B,C)至少要在2轮测试中出现,而|{13,5}|=3>2,所以此时(A,B,C)才会被最终识别为频繁项.简言之2维prefixSpan的具体修改方法为①对于故障f的第i轮测试所观察到的某一日志类型项Pi,j_ex而言,如果其被观察到出现,则对于Pi,j_ex的支持度(support)加1,且如果i不在round_id_list列表中,则追加i.②Pi,j_ex只有在其出现次数的支持度和round_id_list列表长度都大于min_support阈值时才会被加入投影数据库.(3)语义冗余状态过滤仅使用2维频繁项挖掘方法得到的频繁项状态集合并不足以构造一个有效的状态集合,因为其中还包含了过多的语义冗余状态信息.由于Apriori特性的存在,如果日志类型项(A,B,C)为频繁项,则其所有的子项都会被识别为频繁项并出现在频繁项集挖掘的结果中.如果A,B,C三类日志总是同时出现,则(A,B,C)所有子项都是冗余的:包括(A),(B),(C),(A,B),(A,C)和(B,C).为了在状态字典中去除冗余项,我们通过分析日志类型之间的关联规则[13]来确定状态集合中的语义冗余.本文使用了基于置信度的评估方法来评估事件日志之间的因果关系.置信度(式(2))评估了两类事件在所有事务中同时出现的概率:假设SSf中总共有n个日志项,其中m个日志项中包含事件A,k个日志项中同时包含A和B,则P(A)=m/n,P(AB)=k/n.置信度的计算方法如式(2)所示.另一个常用的评估函数支持度(式(3))评估了A,B同时出现的概率与A,B相互独立的期望值之间的比例.通常置信度和支持度越高,则规则A→B越可能成立.在目标场景中,我们仅仅使用置信度度量.因为如果A→B的置信度超过特定阈值,则意味着项(A)通常不会独立出现,而是随着项(B)一起出现,所以项(A)会被认为是冗余项被删除.即使此时(A,B)的支持度很低,即事件B的出现数量远高于A的数量,同样不会影响我们判断(A)为冗余状态的结果.常用场景中,使用支持度的目的为判断A与B的关联性假设是否成立:如,若(A,B)的置信度高于某一阈值,则认为A与B是相互关联的,而如果该假设成立,则可以将事件A与B在一起过滤或作等同处理.由于我们判断A与B是否需要同时过滤的结论同样可以由AB得出,即A→B且B→A.所以,本文仅使用置信度这一种关联分析度量方式Page10具体而言,本文基于置信度关联规则分析方法,即可.采用如下2个启发式对状态进行消减:①将所有由关系所确定的单日志类型项聚集在一起,形成”语义族”,而属于”语义族”中的所有子日志类型项将被识别为冗余状态而被删除.例如,如果AB且BC,则(A,B,C)为一个”语义族”,则日志类型项{A,B,C,(A,B),(B,C),(A,C)}将被认为是冗余状态项而被删除.②(A,(B,C))为”半语义族”A→(B,C),当且仅当如下2个条件之一成立:(a)如果A→B且B→C.(b)如果A→B且A→C,则半语义族中所有为(A,x)模式的项都需要被删除(x为B和C的组合,如(A),(A,B),(A,C)).如果符合以上两个启发式中的任意一个,则最终只有项(A,B,C)留在伴随状态集合中,符合”语义族”及”半语义族”的所有项将被删除.有了伴随状态集合,将每个伴随状态标识为独立一类,基于C4.5分类器我们可以得到伴随状态识别器Stf,通过将其应用于原始日志类型项序列,我们最终可以得到一个伴随状态序列.如图6所示,图下方的序列.〈S1,S2,S2,S3,S3,S2,S2,S4〉为FSwr故障崩溃后最终提取的伴随状态序列.基于C4.5分类器提取随状态识别器Stf的构造过程与第3.2节介绍的过程完全相同,这里不再赘述.4.3伴随状态验证器为了根据伴随状态变化序列构建模伴随状态变化模型,本文采用概率正则文法[14](StochasticRegularGrammar,SRG)为每类故障f构建一个概率状态迁移模型.概率正则文法为统计自然语言处理领域中的一种常见方法.SRG基于训练集中不同状态迁移的出现频率为每类状态迁移设定一个概率值,该方法可以被用来提取软件行为模式以及识别函数调用结构图7FSwr崩溃故障伴随状态变化概率自动机示例异常,相关工作如Magpie[9]、Pinpoint[8]均使用类似文法从程序调用序列中提取系统行为模型.使用SRG的优点在于可以提高系统对不同伴随状态序列的容忍程度,提高模型的鲁棒性.一个概率正则文法由四元组(V,T,P,S)组成,其中V为字符集,T为状态集合,P为包含概率信息的产生式集合,S为特殊的开始标记.在本文中,字符集对应于伴随状态id,产生式则代表状态之间的转换概率矩阵.由于我们需要判断状态转换是否正常的基本假设是”存在即合理”,即只要在状态机中出现转换路径都为正常情况,因此在使用时我们并没有使用概率正则文法产生的状态转换概率信息,仅仅使用其状态转换模型.在具体应用过程中,本文使用了SRG经典的构造算法Algeria[14].通过将故障f所对应训练集的所有状态序列构造为前缀树,Algeria以递归的方式将前缀树中所有可以合并的状态节点进行合并,最后生成最终的产生式集合.Algeria用于判断两个子状态序列是否能合并的方法如式(4)所示.其中n1与n2分别代表后缀树中包含给定节点Q1和Q2的所有序列数量,f1与f2代表终止于Q1和Q2的状态字个数或者能从Q1和Q2状态执行某个迁移的接收字个数.α为[0,1]之间的参数.如果式(4)返回的为真,则代表状态节点Q1和Q2的差异不大,可以合并,否则不可以合并.图7为FSwr失效时的一个伴随状态变化序列以及其相应的SRG模型示例.f1n1-f2n215故障持续追踪整体框架由3步组成:CST整体框架如图8所示,整个特征提取方法(1)过滤[ts,te]阶段出现的噪声日志.(2)对于主要特征日志,使用C4.5决策树模型Page11图8基于伴随状态追踪的故障持续识别整体框架构造一个基于规则的故障分类器.化模式.(3)对于伴随特征日志,基于日志项建模其变与此相应,运行时故障识别过程由两步组成:(1)使用主要特征识别器识别故障的主要特征;(2)基于伴随状态追踪器跟踪故障状态.如果故障特征变化与所学特征不相符,则退出.6实验本实验在系统运行时人为注入故障(进程崩溃),从而根据之后收集的系统日志信息比较不同方法的故障识别效果.目标实验平台为阿里巴巴云计算公司一个用于进行小文件处理的大规模分布式平台,由100台主机节点组成.该系统是由多层Master-Worker风格构建的大规模分布式软件系统,包括DataEngine服务、FileSystem服务、Schedule服务、Naming服务、Monitor服务以及CommunicationAgent.除了CommunicationAgent外,每类服务都由一个Master进程实例和多个Worker进程实例构建而成,除Master进程部署在单独节点之外,其余所有节点都同构地部署所有类型的Worker进程.为了方便标识,本文使用DBwr、表4冗余状态过滤情况(犜狑=3s,狋犺犛=0.8)测试用例oriFreq2dFreqseGpsemiGpratiosgNumseNumsemiNum100.9522DBwr1951941260.8813DBmr30.9912FSwrFSmr64718331341561310.992630.73SSwr10.86SSmr20NLwrMSmr20.520CA得到的状态数量,seGp为在2维prefixSpan所得表4中,oriFreq为使用1维prefixSpan之后结果基础上,使用”语义族”启发式删除冗余状态后得到的结果,2dFreq为使用2维prefixSpan后所DBmr、FSwr、FSmr、SSwr、SSmr、NLwr、MSwr、MSmr以及CA标识各个服务,其中wr为worker进程的缩写,mr为master进程的缩写.6.1测试用例实验总共运行了30轮fail-over测试,每轮测试包含10个测试用例,收集了2800973条错误日志(级别为ERROR与FATAL).1轮测试包括10个进程崩溃故障测试用例,分别模拟了不同系统服务进程崩溃的场景.每个fail-over测试过程中分别选择杀掉1个特定服务进程(对于Worker进程和通信Agent进程则随机选取一个).具体测试用例如及其平均持续时间如表3所示.其中DBmr失效测试有2种测试用例.DBmr1使用应用层请求来判断服务的状态,而DBmr2使用内部请求(Worker进程向Master进程更新元信息)来判断服务的状态.MSwr进程负责收集系统信息,相对独立,所以实验没有测试MSwr崩溃情况.测试用例名称6.2冗余伴随状态过滤有效性(1)冗余状态过滤各步骤的效果对比我们首先验证了在构造伴随状态特征识别器时对伴随状态特征提取方法的有效性.表4为在Tw=3s和thS=0.8的情况下每一步处理动作之后所得到的伴随状态数量对比.Page12得到状态数量;semiGp为在seGp基础上使用”半语义族”启发式过滤后得到的结果.过滤率使用公式ratio=1-semiGp效果越好.表4中第2列至第6列分别为这几步状态过滤的结果.对于测试用例FSmr和FSwr,整体过滤比例基本上达到0.99.原因在于其故障影响模式相对复杂,包含的日志类型较多,直接导致初始的频繁项集(oriFreq)过于庞大,这也同样意味FSmr服务和FSwr服务在其实现逻辑以及与各构件之间的依赖关系都比较复杂,一旦FSmr和FSwr失效,则会给系统带来更大的扰动.对于NLwr和CA而言,虽然其伴随状态集本身很小,且整个冗余状态过滤过程对其作用不大,但是这两类服务进程崩溃产生这种现象的原因却完全不同:NLwr为相对独立的服务,特别是在各服务worker进程具备地址缓存功能的前提下,NLwr的失效影响非常有限;CA服务由于负责整个主机所有进程的远程过程调用(remoteprocesscall),一旦失效将影响该机器当前正在处理业务的所有进程.由于每台主机上的服务进程不同时刻响应的请求可能不同,因此CA的失效影响模型相对而言不确定性较大,导致CA的故障特征显著性不明显.注意,由于使用prefixSpan提取的故障特征为相对稳定(频繁)的故障特征,因此最终CA只能捕捉到2个相对稳定的特征,而并不代表CA本身的状态很少.此现象同样可以在图1中的F-Measure曲线中得到验证,通过图1中可以看出CA的F-Measure值较低.表4第7列至第9列分别记录了总日志类型数量(sgNum)、语义族数量(seNum)以及半语义族的数量(semiNum),从中也可以发现,总日志类型数量越多,则可能包含的冗余伴随状态也就越多.(2)监视窗口大小对冗余状态过滤效果的影响不同Tw设置下的冗余状态过滤率的结果如图9所示.注意,在训练阶段,对于每个测试用例而言,如果Tw>(te-ts),则设定Tw=te-ts.从图9我们可以看出,冗余状态过滤的有效性在不同Tw设置下相对比较稳定.虽然MSmr和SSwr的状态过滤率随着Tw的增加而增长,但实际是由于初始频繁项集减少所致,最终的状态集合数量并没有改变.图9监视窗口大小对冗余状态过滤效果的影响为了评估CST方法对最终故障检测的有效性,6.3故障特征有效性评估我们检测了故障f所产生的所有te-ts特征向量,并使用10折交叉验证方法来评估模型对每类故障的精确率(precision)、召回率(recall)及其调和平均值F-Measure.此外,使用F-Measure的平均值wFmeasure作为衡量故障模型整体效果的评估指标.(1)监视时间窗口Tw对故障特征整体有效性评估图10为使用传统故障特征窗口构建的模型有效性评估结果.对应本节的场景,即使用[ts,ts+Tw]中出现的主故障特征识别器,应用于所有te-ts志类型特征向量,判断每个日志类型特征向量是否被识别为故障f.图11为使用伴随故障特征追踪CST方法的有效性评估,目标同样是判断te-ts日志类型特征向量是否都能被识别为故障f.通过对比图10和图11我们可以看出在设定α=0.8,thS=0.8的情况下CST方法的整体有效性(wFmeasure值)比固定故障特征窗口方法平均提高了50.3%.当Tw增大时,总的日志类型特征图10传统固定故障特征窗口方法在不同值时的有效性Page13图11CST方法在不同监视窗口的wFmeasure向量数目ts-te数目也会减少,根据实验数据发现这种改变对不同类型的故障带来的影响并不相同:①一方面,随着日志类型特征向量数目减少,1次故障识别错误对模型效果评定(F-Measure)的影响会随之增加,从而会降低模型精度.如图11中在Tw=50时DBwr的F-Measure值非常之低.②另一方面,随着总日志类型特征向量数目的减少,它也会降低故障识别出错的概率,从而提高模型精度.如图11中MSmr在Tw=50时所示.特别是当Tw>(te-ts)时(如Tw=100及Tw=200),由于此时对于大多数故障类型只有1个日志类型特征向量,正好用于主特征识别过程而不再需要对故障的伴随状态进行追踪,因此在这种情况下可以观察到图10和图11在对应Tw的所计算出的F-Measure值相等.(2)频繁度因子对故障特征有效性的影响此外,我们还评估了CST方法在不同频繁度因子(thS)下的模型有效性,仍然使用wFmeasure作为评估方式.如图12所示,我们总共评估了4组不同thS值在不同时间窗口时的wFmeasure值.通过对比图11可以看出,thS对故障模型有效性的整体影响低于Tw的影响,但是仍然存在一定波动.通过对系统故障模型的深入分析,我们发现thS对不同故障的影响仍然与故障自身的特点相关:①对于故障特征相对稳定的服务,如DBmr、FSmr以及FSwr,当thS增加时对其最终的伴随状态集合影响不大;②对于DBwr和SSmr,当thS增长时其伴随状态集合规模会变小,但是由于其特征的显著性不高,较容易受到噪声日志的影响,所以导致其故障特征有效性会随thS增长而降低.③对于CA,由于本身特征不够显著,所以不同thS对模型有效性基本没有什么影响,维持在较低水平.7相关研究故障检测对于实现云计算系统中的弹性管理十分重要[15-16].基于对故障模型假设的不同,已有相关工作提取故障特征的方法可以被划分为2类.(1)不需要故障重演的故障建模方法.一些相关工作是用统计分析方法来建模分布式系统的正常行为模型[3,5,9,17].有的工作假设可以获得系统的源代码[3],coredump信息[18],甚至使用软件注入方法[5,9]从而挖掘出事件之间函数调用关系以及模块之间的依赖关系模型.虽然基于此类方法能够获得较为细粒度的故障检测结果,但是这类细粒度的依赖关系及因果关系模型并非在所有系统中能够获得,且一些注入操作会对系统带来一定的扰动,这在很多情况下,特别是生产系统中是不允许的.(2)需要故障重演的故障建摸方法.可重复性故障时在系统中可能会重复发生的故障[6-7,19].这类故障往往不能够在系统中很快排除,比如进程崩溃、机器崩溃、网络拥塞.在运行时刻对此类故障进行检测能够为系统的自管理及容错机制等等提供输入信息[15-16].相关工作[6,19]往往使用检测窗口内的观察到的症状信息来提取故障特征而忽略检测窗口之外的症状信息.其带来的直接影响为在运行时故障检测场景下只有早期故障特征能够被正确识别.与已有相关工作相比,本文方法有2个特点:(1)我们使用事件类型项建模故障特征,而不是事件粒度的因果分析;(2)我们提取了整个故障传播周期的特征信息,而不仅仅是检测窗口内的故障特征.Page148结束语在面向互联网应用的大规模企业级分布式系统中的运行时维护中,故障定位结果作为弹性管理和容错技术的输入扮演着极其重要的角色,但是传统方法在使用过程中存在如下问题:一方面,已有相关工作使用固定故障特征窗口内的特征对故障进行建模,但是建模过程中忽略了故障特征窗口外的故障特征信息,导致将模型应用于在线故障定位时仅有早期故障特征能被识别,后期的特征会造成系统误报、漏报,不能实现持续故障定位,会错误引导系统管理人员或相关管理机制对系统的在线运营维护,并最终影响系统的可用性.另一方面,基于日志信息对故障特征进行提取受到分布式系统时间不同步问题的困扰.由于分布式系统中存在时间同步问题,很难按照严格的时序关系构造日志事件粒度的因果关系模型.为了解决上述问题,本文将故障影响周期内出现的日志信息按照时间窗口分割为主故障特征日志和伴随故障特征日志,并且将给定时间窗口之内观察得到的日志类型特征向量以及日志类型项作为故障特征的两种抽象.通过分别对主故障特征使用日志类型特征向量进行建模,伴随故障特征使用日志类型项进行建模,我们提出了一种基于伴随状态追踪的持续故障定位框架CST.CST首先根据主故障特征定位故障,随后切换为对该故障状态变化的追踪器以分析当前系统异常行为是否仍然由之前故障所导致.通过在阿里巴巴云计算公司的生产系统进行的实验表明,CST方法通过使用混合模型建模方法,成功实现了对故障的持续定位,提高了故障模型的有效性.
