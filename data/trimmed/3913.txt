Page1TDTMS:一种面向XML数据的结果子树构建算法周军锋王博田姗姗陈子阳郭景峰(燕山大学信息科学与工程学院河北秦皇岛066004)(河北省计算机虚拟技术与系统集成重点实验室河北秦皇岛066004)摘要构建结果子树是XML关键字查询得以完成的关键步骤之一.针对已有方法求解子树效率低的问题,文中提出一种自顶向下的子树构建算法———TDTMS.TDTMS以自顶向下、深度优先的方式求解满足条件的子树根结点,避免了已有方法求解SLCA结点时存在的公共祖先重复处理问题.对于给定的子树根结点,TDTMS以自顶向下、广度优先的方式构建子树,可以在建树过程中快速裁剪无用结点,从而获得了最小的时间和空间复杂度.最后通过实验验证了TDTMS在时间和空间两方面的性能优势.关键词可扩展标记语言;关键字查询;结果子树;自顶向下处理策略;最低最小公共祖先1引言随着可扩展标记语言(eXtensibleMarkupLan-guage,XML)应用领域的不断扩展,以XML格式表示和存储的数据量不断增大.作为一种简单易用的信息检索机制,基于XML数据的关键字检索技术得到了研究者的广泛关注[1-16].通常情况下,一个XML文档可以看成一棵带有结点标注信息的文档树T.对于给定的关键字查Page2询Q,每个满足条件的查询结果Tv是T的一棵子树,Tv应包含Q的所有关键字且Tv的根结点v需满足特定的语义,如SLCA[4,6]、ELCA[2,9]、VL-CA[11]以及MLCA[5]等.假设v是满足某种语义的一个结点,现有方法主要考虑3种结果子树:(1)完全子树(CompleteSubtree,CSubtree),指从T中抽取的以v为根且未经修剪的原始子树[2,4];(2)路径子树(PathSubtree,PSubtree),指以v为根,由v到全部关键字结点的路径组成的子树[15];(3)匹配子树(MatchedSubtree,MSubtree),指以v为根,满足一致性和单调性的子树[7-8].假设Su表示以u为根的子树中包含的Q中的关键字集合,显然SuQ.直观上看,如果子树Tv是匹配子树,则对结点v的图1XML文档D对应的文档树T(对于查询Q={CS,XML,Tom,VLDB}来说,R表示其对应的完全子树,R1表示其通过例1可知,完全子树R可能包含大量与查询关键字无关的信息,这样的结果对于用户来说意义不大;同样,路径子树R1也可能包含很多无用信息.例如,对于例1的查询Q来说,路径子树是图1中的R1,但R1中编码为1.2.4.10,1.2.14.16及1.2.14.20的3个结点所表示的3篇文章和XML无关,因而会给用户理解查询结果带来额外的干扰因素.事实上,从图1可知,对于CS实验室,由Tom所写并发表在VLDB上,且和XML相关的文章是编码为1.2.4.6的结点所表示的文章.由图1可知,对结点1.2.3,1.2.4和1.2.14来说,S1.2.3={CS},S1.2.4={Tom,VLDB,XML},S1.2.14={VLDB}.由于S1.2.14S1.2.4,根据关键字包含关系,以1.2.14为根的子树应予去除.同样,由于S1.2.4.5={Tom},S1.2.4.6={Tom,VLDB,XML},S1.2.4.10={Tom,任意后代结点u来说,u不存在任何兄弟结点w满足SuSw.我们称这一约束条件为“关键字包含关系”.显然,对于给定的完全子树,可以通过移除不包含关键字的结点得到路径子树.类似地,匹配子树可以通过移除路径子树中不满足关键字包含关系的结点得到.例1.假设用户想从图1所示的文档D中查找CS实验室由Tom所写、且在VLDB会议上发表的有关XML的文章,则可以使用关键字查询Q={CS,XML,Tom,VLDB}检索所需的信息.显然,满足条件的SLCA结点是图1中Dewey编码[10]为“1.2”的“lab”结点,完全子树为R,路径子树为R1,匹配子树为R2.VLDB},可知S1.2.4.5S1.24.6且S1.2.4.10S1.2.4.6.根据结点间的关键字包含关系,应移除以结点1.2.4.5和1.2.4.10为根的子树.因此,通过移除不满足关键字包含关系的结点,可以得到包含所有必要信息的匹配子树R2.与完全子树R及路径子树R1相比,R2更简洁且对查询意图的解释更明确.虽然XML关键字查询的结果是特定的子树,但大多数现有方法[3-4,6,9,12-14]仅关注如何高效计算满足特定语义的子树根结点,如SLCA或者ELCA结点,只有文献[7-8,16]的方法涉及到结果子树的构建问题.事实上,构建子树的代价远高于求解子树根结点的代价.文献[7-8]中的方法首先需要扫描倒排表中的所有结点求解满足条件的SLCA/ELCA结点集;然后基于这些结点重新扫描倒排表中的所有结Page3点来构造最初的结果子树集,这些结果子树需要缓存在内存中并根据关键字包含关系逐个进行剪枝来得到最终的子树结果.从空间代价来看,这一过程需要缓存大量中间结果;从时间代价来看,算法需要反复扫描倒排表中的结点.文献[16]提出了一种只需扫描一次倒排表的单阶段子树构建算法.虽然该方法无需缓存大量中间结果和多次扫描倒排表,但仍需依次处理倒排表中的所有结点.当满足条件的结果数量远小于最短倒排表的长度时,该方法无法利用结点间的位置关系来避免对大量无用结点的处理,因而需要额外的冗余计算.例2.为了直观理解不同方法在求解子树根结点和构建子树过程中的性能差异,我们实现了mergeMatching[16]算法和基于IL[4]的MaxMatch[8]算法,并在582MBXMark数据集上执行查询Q={female,keyword,incategory,cabbage,male}.表1展示了两种算法计算SLCA结点和构建子树的时间比较.可以看出,尽管IL在求解SLCA结果时远比mergeMatching算法高效,但和MaxMatch算法构建子树所付出的昂贵代价相比,使用mergeMatching求解SLCA的代价几乎可以忽略不计.另一方面,尽管mergeMatching的建树过程比MaxMatch高效,但建树过程所耗费的时间仍占总时间的66%.查询算法t1(SLCA)/mst2(子树构建)/mst1/(t1+t2)/%MaxMatch-IL0.5782204.1220.03mergeMatching79.500152.20034.00从例2可知,无论使用哪种方法处理给定的查询,子树构建操作都会耗费大量时间,因而是影响系统性能的关键因素之一.查询处理算法应从求解子树根结点和构建子树两个角度来同时进行优化,以便获取最佳的性能.本文重点解决基于SLCA语义高效构建TM-Subtree[16]的问题.和MSubtree相比,文献[16]提出的TMSubtree是移除冗余信息的MSubtree,从结果表达能力来看,TMSubtree更简洁,对查询意图的解释更明确(参见第2.3节介绍).我们提出一种新的单阶段算法TDTMS,该算法以自顶向下的方式求解SLCA结点,同时直接构建满足条件的TMSubtree.和已有方法[8,16]相比,TDTMS算法同时从求解子树根结点和构建子树两个角度提升系统性能,同时降低了空间复杂度.具体来说,TDTMS的高效性体现在两方面:(1)更低的时间复杂度.求解子树根结点时,TDTMS采用自顶向下、深度优先的方式处理倒排表中的结点,可以利用关键字结点的分布特点来避免对无用结点的处理.例如,基于图1的文档D处理例1的查询Q时,TDTMS算法可直接跳过对于1.25.27.29.30、1.25.27.29.31及1.25.27.29.32这3个结点的处理,而mergeMatching算法需要处理所有关键字结点.构建子树时,TDTMS采用自顶向下、广度优先的方式构建子树,可以在建树的过程中快速裁剪无用结点.例如,基于图1的文档D处理例1的查询Q,在构建满足条件的子树R2时,我们的方法只需扫描编码为1.2.14的结点,便可知道该结点的关键字集合S1.2.14={VLDB},然后通过结点间关键字集合的包含关系实现对结点1.2.14的剪枝,进而避免处理该子树中的其它结点.同样,在处理结点1.2.4.6时,可以直接实现对结点1.2.4.5和结点1.2.4.10的剪枝,从而避免进一步处理以1.2.4.10为根的子树中的其它结点,而mergeMatching算法需要处理子树中的所有结点.对于给定的查询Q={k1,k2,…,km},假设Li表示ki(i∈[1,m])对应的IDDewey倒排表(参见第2.1节),LIDi表示由Li中不同ID值组成的集合,|Lm|表示最长倒排表中包含IDDewey编码的数目,TDT-MS的时间复杂度为O(m·|∪m已有方法的比较和分析参见第2.4节).(2)更低的空间复杂度.TDTMS算法以自顶向下、广度优先的方式建树,任何时候内存中最多缓存一个TMSubtree.TDTMS的空间复杂度为O((|d-m|+2)·m!),这里d为给定XML文档的深度.和文献[16]最多需要缓存d棵子树相比,TDTMS只需缓存1棵子树.本文第2节对相关工作及背景知识进行介绍;第3节介绍本文算法的基本思想;第4节介绍本文提出的TDTMS算法;第5节通过实验对本文算法进行性能验证;最后在第6节总结全文.2背景知识和相关工作通常,一个XML文档可用带有结点标注信息的树来表示,其中结点表示元素或者属性,边表示节点间的直接嵌套关系.如果某个关键字k出现在结点v的名字、属性或者v的文本值中,我们说v直接包Page4含关键字k.图1的D是一棵XML文档树的例子.2.1编码方案为了加速查询处理,已有方法[2,4,6,12,14,16-18]使用Dewey编码[10]来表示不同结点.对于给定的结点v来说,其Dewey编码由其父亲结点的Dewey编码和其本身在兄弟结点中的顺序值组成.和文献[13]类似,我们给图1中每个结点一个唯一的ID值,该值等于以先序遍历方式访问D时该结点的访问次序.相应的,图1中每个结点v的Dewey编码由从根结点到v的路径上所有结点的ID构成,我们称这种由结点ID构成的Dewey编码为IDDewey编码[12].注意本文使用IDDewey的原因是方便介绍算法时可以使用ID来代表一个结点,其它Dewey编码的变体,如MDC[11]、JDewey[19]等,也可用于本文算法.对于给定的两个结点u和v来说,其位置关系包括:文档顺序(d)、相等关系(=)、祖先后代关系(a)、父子关系(p)以及兄弟关系.udv表示在文档中,u位于v的前面,uav表示u是v的祖先结点,upv表示u是v的父亲结点.如果u和v是同一个结点,则u=v,且udv和uav同时成立.2.2查询语义为了从给定的XML文档D中求解满足查询Q={k1,k2,…,km}的结果,需要首先为每个关键字构建倒排索引.本文使用Li表示关键字ki对应的倒排表,Li由所有直接包含ki的结点对应的IDDewey编码组成,这些编码按照文档顺序进行组织.假定S={v1,v2,…,vn}是一组给定的结点,lca(S)=lca(v1,v2,…,vn)表示S中所有结点的最低公共祖先(LowestCommonAncestor,LCA).Q在D中的所有LCA定义为LCA(Q)=LCA(L1,L2,…,Lm)={v|v=lca(v1,v2,…,vm),vi∈Li(1im).例如,对查Q={Tom,VLDB}来说,图1中满足条件的LCA结点是1,1.2,1.2.4,1.2.4.6,1.2.4.10,1.25.27.29.和LCA相比,SLCA(SmallestLCA)[4,6]集合是LCA(Q)的一个子集,其中任意一个元素都不是其它LCA结点的祖先结点,其形式化定义为SLCA(Q)={v|v∈LCA(Q)并且/v∈LCA(Q),使得vav}.对于图1的XML文档D和查询Q={Tom,VLDB}来说,尽管1,1.2,1.2.4是LCA结点,由于它们都是1.2.4.6的祖先结点,因而不是SLCA结点.满足条件的SLCA结点是1.2.4.6,1.2.4.10,1.25.27.29.2.3最紧致匹配子树TMSubtree对于给定的XML文档树T和关键字查询Q,假定SvQ是在以v为根的子树中出现的关键字集合,Sv≠,则子树Tv是一个最紧致匹配子树(TightestMatchedSubtree,TMSubtree)当且仅当Tv的根结点v是一个SLCA结点,并且对于Tv中的每个结点u来说,不存在另一个兄弟结点w满足SuSw.当多个兄弟结点的关键字集合相同时,任意保留其中之一即可.直观上看,TMSubtree就是移除冗余信息的MSubtree,这里的冗余信息指具有相同关键字集合的兄弟结点.对于一个MSubtree来说,如果其中每个结点都与其兄弟结点的关键字集合不同,则该MSubtree是一个TMSubtree.例如,对于图1的R2而言,由于不存在具有相同关键字集合的兄弟结点,R2也是一个TMSubtree.对于给定查询Q={k1,k2,…,km}和任意一个TMSubtreeTv来说,文献[16]通过证明给出了Tv所包含的结点数目上限N(Tv),如式(1)所示.2.4相关算法及分析对于一个给定的查询Q={k1,k2,…,km}和XML文档D,MaxMatch算法[8]分3步计算匹配子树:(1)计算满足条件的SLCA结点集.这一步可通过调用任何已有的SLCA算法来完成,如Stack[4]、IL[4]、IMS[6]、HS[12]、LPSLCA[14]及FwdSLCA[13]算法.完成这一步需要处理一个或者多个倒排表中的所有结点编码;(2)求解每个SLCA结点对应的关键字结点集,即使用每个SLCA结点v在每个倒排表中找v的后代结点;(3)构建满足条件的匹配子树.可以看出,MaxMatch算法无论在时间还是空间方面都存在问题.从空间复杂度来看,MaxMatch算法需要在第1步和第2步缓存所有的中间结果,其空间复杂度为O(d∑mMaxMatch算法需要扫描3次倒排表中的结点,无论其在第1步使用多么高效的算法,MaxMatch算法都需要在第2步重新处理所有的结点编码并将其和对应的SLCA结点进行聚类,这一步的时间复杂度为O(d·m·(∑m并进行裁剪,这一步的时间复杂度为O(min(|D|,Page5i=1d·(∑m兄弟结点间关键字包含关系的代价.假设Max-Match算法第1步的代价小于第2步的代价,其时间复杂度为O(max(min(|D|,d·(∑m2m),d·m·(∑m考虑到MaxMatch算法存在的问题,文献[16]提出的mergeMatching算法可以在仅扫描一遍结点编码的同时构建满足条件的子树.和MaxMatch算法相比,其优势体现在两个方面:(1)由于在任何时候,内存中最多缓存d个TMSubtree,其空间复杂度降为O(d·max(2m!,(d-m+2)m!)).(2)由于merge-Matching算法在一次性扫描倒排表的同时构建子树,其时间复杂度为O(d·m2·∑m其中代价O(d·m·∑m排表中的结点编码,对于每个结点,内存中最多缓存m2个兄弟结点,检测其关键字集合包含关系的代价为O(m2).虽然mergeMatching算法无需缓存大量中间结果和多次扫描倒排表,但仍需依次处理倒排表中的所有结点.实际应用中,当满足条件的结果数量远小于最短倒排表的长度时,该方法无法利用结点间的位置关系来避免对于大量无用结点的处理,图2查询Q={CS,XML,Tom,VLDB}相对于图1中XML文档D的倒排表及KPTree定义1.关键字路径树(KeywordPathTree,KPTree).对于给定的关键字ki来说,其KPTree是因而需要额外的冗余计算.表2列举了本文所用的重要符号及其意义.符号Li关键字ki对应的倒排表LIDiLi中不同ID值组成的倒排表,即文献[13]中的IDListm查询Q包含的关键字数目d给定XML文档的最大深度u,v,w给定XML文档树中的结点Sv以结点v为根的子树中包含的Q中的关键字集合TKPkiki对应的关键字路径树Tv以v为根的子树3算法基本思想本文使用基于结点ID的IDDewey编码.在图1中,XML文档树D中每个结点的IDDewey编码位于该结点的下方.因而,图1中的每个结点既可由其ID表示,也可由其IDDewey编码来表示.例如,图1中最左边的person结点既可以称为结点4,也可以称为结点1.2.4.基于IDDewey编码,我们为每个关键字ki构建了倒排索引Li,该倒排表由所有直接包含ki的关键字结点的IDDewey编码构成,编码间按照文档顺序进行组织.例如,对于例1的查询Q={CS,XML,Tom,VLDB},其所有关键字对应的倒排表如图2中的LCS、LXML、LTom以及LVLDB所示.和XML文档树同根,以Li中所有结点为叶子构成的子树,用TKPki表示.Page6例如,对于查询Q={CS,XML,Tom,VLDB}和图1的文档D,Q中所有关键字对应的KPTree如图2中的TKP第1节介绍的“路径树”指结果树和这里的“关键字路径树”不同.定义2.查询路径树(QueryPathTree,QPTree).对于给定的查询Q={k1,k2,…,km},Q的QPTree是由其所有关键字的KPTree合并在一起构成的子树,其中相同结点只保留一次.例如,对于查询Q={CS,XML,Tom,VLDB}和图1的文档D,Q的QPTree可以通过合并其4个关键字的KPTree得到,如图3所示.图3查询Q={CS,XML,Tom,VLDB}相对于图1中XML文档D的QPTree本文算法的基本思想是:对于给定的查询Q和XML文档D,以自顶向下、深度优先的方式访问Q的QPTree,并在遍历的过程中检测每个被访问的结点是否为SLCA结点.每当找到一个SLCA结点后,以自顶向下、广度优先的方式构建结果子树的每层结点,同时检测兄弟结点间的关键字包含关系,以便及时剪枝,实现子树的快速构建.算法名称为TDTMS,其中TD表示“top-down”,TMS表示TMSubtree,合起来表示以自顶向下的方式求解所有TMSubtree.对SLCA结点的检测问题,基本思想为当以自顶向下、深度优先的方式访问QPTree的结点时,对于遇到的每个结点v,检测以v为根的子树Tv是否包含所有关键字.若是,则说明Tv中至少包含一个SLCA结点.在删除Tv的根结点v后,我们可以得到Tv的子树森林FTv={T1,T2,…,Tn},其中每个子树Ti(i∈[1,n])的根结点是v的孩子结点.基于FTv,我们检测每个子树是否包含所有关键字.如果不存在包含所有关键字的子树,则表示Tv的根结点v是一个SLCA结点;否则,对于FTv中每个包含所有关键字的子树,我们的方法递归计算其对应的子树森林,直到子树森林中不存在包含所有关键字的子树为止.这种处理策略在得到每个SLCA结点v时,就已经知道以v为根的子树中所包含的关键字结点,从而避免了使用SLCA结点去倒排表中查找关键字结点的代价.例3.考虑在图1的XML文档D上处理查询Q={CS,XML,Tom,VLDB}.对于图3的QPTree,由于结点1是根结点,因而以结点1为根的子树肯定包含所有关键字,我们的方法首先访问结点2.当发现结点2也包含所有关键字后,我们的方法继续访问结点3,由于结点3不包含所有关键字,且不存在其它结点包含关键字“CS”,则可知结点2是一个SLCA结点.当构建以结点2为根的TMSubtree时,我们的方法以自顶向下、广度优先的方式建树并检测兄弟结点间的关键字包含关系.对于当前的SLCA结点,我们的方法首先构建结点3.由于结点4的关键字集合为S4={Tom,XML,VLDB},且S3={CS}\S4,我们的方法进而构建结点4.接下来,由于结点14的关键字集合为S14={VLDB}S4,我们的方法直接跳过以结点14为根的子树中的所有结点.接下来的子树构建过程类似,在处理下一层结点时通过检测兄弟结点间的关键字包含关系,可以避免处理以结点10为根的子树中的所有结点.最后,当构建完以结点2为根的TMSub-tree后,由于已经处理完关键字“CS”对应的倒排表中的所有结点,我们的方法直接结束,从而避免处理以结点25为根的子树中的所有结点.4TDTMS算法对于给定的查询Q={k1,k2,…,km},某个倒排表为空或者Q仅包含一个关键字的情况很容易处理,本文不予讨论.算法运行过程中,我们为每个倒排表Li(i∈[1,m])关联一个指向某个编码的指针Ci.后面的讨论中,Ci可以代表其所指的编码或者相应的结点,pos(Ci)用于表示Ci在Li中的位置.假设l是Li中的第x个编码,且Ci指向l,则pos(Ci)=x,l=Ci=Li[x].对l来说,l中第j个整数代表了XML文档树中第j层的一个结点v的ID值idv,因而有idv=l[j]=Li[x][j].后续讨论中,我们用Li[s,e]表示Page7Li中从第s到第e个编码组成的子倒排表,|l|表示l的长度,即其中包含的结点ID的数目.对于给定的查询Q及相应的QPTree中的每个结点v,我们将所有在Tv中出现、且属于Li的所有关键字结点用TvLi表示.Tvlv表示v的IDDewey编码.函数binSearch(TvLi,id,level)用于从TvLi的第level层中找到第1个不小于id的值对应的编码在Li中的位置,并将光标移动到该位置.对隶属于当前子树Tv的所有倒排表来说,函数eof(Tv)用于检测Tv的倒排表中是否存在所有结点已被处理完毕的倒排表.若存在,则eof(Tv)返回TRUE,否则返回FALSE.4.1算法描述如算法1所示,我们首先在第2行将Tv的根结点设为1,并在第3行将所有倒排表中的关键字结点作为Tv的叶子结点,即Tv的初始状态为Q的QPTree.在第4行调用processSubTree(Tv)以自顶向下、深度优先的方式递归处理Q的QPTree中的结点.算法1.TDTMS(Q).1./Q={k1,…,km},0<|L1||L2|…|Lm|/2.Tvlv←13.Tv[L1,L2,…,Lm]←[L1,L2,…,Lm]4.processSubTree(Tv)5.ProcedureprocessSubTree(Tv)6.FOREACH(i∈[1,m])DO7.IF(|TvLi[1]|>|Tvlv|)THENCi←TvLi[1]8.ELSECi←TvLi[2]9.min←minargi{|TvLi|}10.isSLCA←TRUE11.WHILE(eof(Tv))DO12.chLevel←|Tvlv|+113.idch←Cmin[chLevel]14.{isCA,Tch}←getNextTree(Tv,idch,min,chLevel)15.IF(isCA=TRUE)THEN16.processSubTree(Tch)17.isSLCA←FALSE18.ELSE19.binSearch(TvLmin,idch+1,chLevel)20.IF(isSLCA=TRUE)THEN21.tTMS←generateTMSubtree(Tv)22.outputtTMSasaTMSubtree23.FunctiongetNextTree(Tv,idch,min,chLevel)24.isCA←TRUE25.FOREACH(j∈[1,m],j≠min)DO26.binSearch(TvLj,idch,chLevel)27.IF(Cj[chLevel]>idch)THEN28.isCA←FALSE;BREAK29.IF(isCA=TRUE)THEN30.Tch←getSubTree(Tv,idch,chLevel)31.RETURN{TRUE,Tch}32.RETURN{FALSE,NULL}33.FunctiongetSubTree(Tv,idch,chLevel)34.FOREACH(i∈[1,m])DO35.si←pos(Ci)36.binSearch(TvLi,idch+1,chLevel)37.TchLi←Li[si,pos(Ci)-1]38.Tchlch←Tvlvidch39.RETURNTch对于某个包含所有关键字的子树Tv,过程pro-cessSubTree(Tv)首先在第6~8行设定每个光标在相应倒排表中的位置,第9行得到Tv的最短倒排表,第10行用isSLCA标识v是否为SLCA结点.对于Tv来说,只要不存在某个倒排表的全部结点被处理完(第11行值为TRUE),在12~19行,首先从TvLmin的第chLevel层(第12行)得到v的一个孩子结点idch(第13行),并在第14行判断以idch为根的子树是否包含所有关键字结点.如果包含(第15行值为TRUE),则在第16行处理以idch为根的子树Tch,并在第17行将isSLCA置为FALSE,表示v不是SLCA结点.如果第15行值为FALSE,表示以idch为根的子树不包含所有的关键字结点,因而在第19行,我们在TvLmin的第chLevel层找下一个不同的整数(即v的下一个被处理的孩子结点).当Tv中存在某个倒排表的所有结点已被处理完毕后,如果isSLCA仍然等于TRUE(第20行),说明以v的任意孩子结点为根的子树不包含所有关键字结点,因而我们在第21行构建以v为根的TMSub-tree,并在第22行将其返回.算法1在第14行调用getNextTree(Tv,idch,min,chLevel)来判断以idch为根的子树是否包含所有关键字结点,若是则得到该子树的统计信息.其处理思路如下,首先在第24行将变量isCA设为TRUE,然后在第25~28行判断idch是否在每个倒排表的第chLevel层出现.如果所有倒排表均包含idch(第29行值第为TRUE),则表示以idch为根的子树包含所有的关键字结点,然后我们在第30行通过调用getSubTree(Tv,idch,chLevel)来得到以idch为根的子树Tch的统计信息.注意算法1中,第37行使用全局倒排表来得到当前子树对应的局部倒排表,而第19、26、36行中使用Tv的局部倒排表来缩小折半查找的范围.例4.考虑在图1的XML文档D上处理查Page8询Q={CS,XML,Tom,VLDB},相应的倒排表如图2所示.算法1首先使用LCS中的2去探测其它倒排表中是否存在包含2的编码.由于所有倒排表中均有编码包含2,可知以结点2为根的子树包含所有关键字,因而算法1继续使用LCS中的3去探测是否其它倒排表存在包含3的编码.由于第1个被探测的倒排表LXML中不存在包含3的编码,算法1停止探测,并可立即得知结点2是Q的SLCA结点,并调用算法2构建相应的TMSubtree.之后由于LCS中的编码被处理完毕,程序结束.算法1在执行时,可跳过图2中灰色背景覆盖的编码.从例4和算法1的执行过程可知,算法1可以在求解SLCA的时候快速跳过对很多无用结点的处理.当已知某个子树的根结点为SLCA结点后,算法1在第21行调用算法2以自顶向下、广度优先的方式构建TMSubtree树,借助队列queue来暂存部分兄弟结点及其孩子结点.在算法2的第1行,我们将队列queue初始化为空.第2~3行,初始化入队的第1个元素e并在第4行将其入队.其中第2行的eparent是一个指针,指向Tv中e对应的父亲结点,elabel表示e对应的结点编码,eS表示e的关键字集合.只要队列不空(算法2的第5行为TRUE),我们在第6行从队列中移除1个元素e,并在第7行根据e生成一个结点.如果第8行eparent≠NULL,说明v的父结点已经在Tv中,则在第9行将v插入Tv中,否则说明Tv为空树,在第10行将v作为Tv的根结点.算法2.generateTMSubtree(Tv).1.queue←;2.eparent←NULL;elabel←Tvlv;eS←queue;3.e[L1,L2,…,Lm]←Tv[L1,L2,…,Lm]4.addTail(queue,e)5.WHILE(isEmpty(queue))DO6.e←removeHead(queue)7.generateanodevusinge8.IF(eparent≠NULL)THEN9.addvasachildofeparent10.ELSETvroot←v11.nextL←|elabel|+112.[c1,…,cm]←[pos(eL1[1]),…,pos(eLm[1])]13.WHILE(eofL(e,nextL))DO14.idch←minarg{eLi[ci][nextL]}15.eS←16.eparent←v17.FOR(eachi∈[1,m])DO18.starti←ci19.IF(eLi[ci][nextL]=idch)THEN20.eS←eS∪{ki}21.binSearch(eLi,idch+1,nextL)22.endi←ci-123.ELSEendi←starti-124.isConsumed←FALSE25.e←getTail(queue)26.WHILE(eparent=eparent)DO27.IF(eSeS)THEN28.isConsumed←TRUE;BREAK29.ELSEIF(eSeS)THENdeleteefromqueue30.e←getPrev(e)31.IF(isConsumed=FALSE)THEN32.elabel←elabelidch33.FOR(eachi∈[1,m])DOeLi←Li34.addTail(queue,e)35.RETURNTv36.FunctioneofL(e,nextL)37.IF(i∈[1,m],suchthatnotalldistinctintegers38.RETURNFALSE39.RETURNTRUE当处理完e之后,算法2在第11~34行处理v的所有孩子结点,其基本思想为对于当前被处理的孩子结点而言(和算法2中的e对应),依次比较eS(e的关键字集合)与队列中所有兄弟结点关键字集合之间的包含关系(第24~30行),并移除所有被eS包含的兄弟结点(第29行);如果在比较过程中遇到包含eS的关键字集合,则直接终止比较(第27~28行)并忽略对e的处理;对于队列中所有兄弟结点的关键字集合而言,如果在比较完成之后没有发现包含eS的关键字集合(第31行isConsumed=FALSE),则初始化e的其它数据成员并将其放入队列(第32~34行).算法所使用的集合可通过位向量表示,第20、27、29行集合之间的关系运算的代价为O(1).为了得到当前结点的孩子结点,算法2在第11行得到孩子结点的层数,在第12行为e的每个倒排表eLi设定初始光标ci,在第13~34行依次处理v的每个孩子结点.具体来说,算法2在第14行得到v的一个孩子结点(用idch表示),并将其关键字集合在第15行初始用化为空集.在第16~23行,算法2使用idch依次探测每个倒排表,如果被探测的倒排表中包含idch,则记录其范围并将相应的关键字加入eS中.在计算完成e的关键字集合后,算法2在第24~34行检测eS与队列中兄弟结点的关键Page9字集合间的包含关系,其处理思路如上一段所述.例5.继续例4的处理.当已知结点2为SLCA结点后,算法1调用算法2构建基于结点2的TMSubtreeT2.算法2首先在第4行将结点2对应的元素入队列,并通过第5~34行的处理来完成TMSubtreeT2的构建过程.当结点2在第6行出队列后,首先将其作为T2的根结点,然后在第11~34行依次处理结点2的每个孩子结点.对于结点2来说,第1个被处理的孩子是结点3(关键字集合包含“CS”),算法2将其入队列;第2个被处理的孩子是结点4(关键字集合包含“XML,Tom,VLDB”),由于两个兄弟结点的关键字集合之间互不包含,结点4入队列;最后一个被处理的孩子是结点14(关键字集合包含“VLDB”),由于结点4的关键字集合包含结点14的关键字集合,因而结点14不必入队,这一操作避免了处理图2中TKP点,即图2中绿色背景覆盖的结点.下一个出队列的是结点3,由于结点3没有孩子结点,算法2将结点3作为结点2的孩子结点插入T2中.然后结点4出队,并将其作为结点2的孩子插入T2.接下来处理结点4的孩子结点.首先进队列的是结点5(关键字集合包含“Tom”),然后处理结点6(关键字集合包含“XML,Tom,VLDB”).由于结点6的关键字集合包含结点5的关键字集合,我们从队列中删除结点5并将结点6进队列.该层结点中最后一个处理的是结点10(关键字集合包含“Tom,VLDB”),由于队列中结点6的关键字集合包含结点10的关键字集合,结点10无需入队列,这一操作避免了处理图2中紫色背景覆盖的结点.当结点6出队列后,算法2将其作为结点4的孩子插入T2中.最后将结点6的3个孩子依次进队列,并在其出队列后插入T2中作为结点6的孩子结点.注意在显示结果时,如果需要显示TMSubtree中每个结点的名称,一种简单的方式是通过在倒排表中每个IDDewey编码的最后附加该结点对应的路径ID即可,通过该ID值,我们可以在O(1)时间内得到从根到该结点的路径上每个结点的名称.4.2算法分析对于给定的查询Q={k1,k2,…,km},假设IDDewey倒排表的长度满足0<|L1||L2|…|Lm|,LIDi表示Li对应的IDList[13].例如,对于图2中的LTom,总共有4个IDDewey编码,显然,|LTom|=4,LTom中所有IDDewey编码包含的ID个数为19,其中不同ID值的个数为|LID于该关键字的KPTree中的结点数目,即|LID|V(TKPTom)|.我们的方法采用自顶向下的方式处理给定查询Q对应的QPTree中的结点.由于每个QPTree中的SLCA结点必然出现在k1的KPTree中,且对于每个包含所有关键字的结点,算法1在处理其孩子结点时,都是使用其最短倒排表中的数字探测其它倒排表,代价为m·log|Lm|.由于被处理的结点数最多为k1的KPTree中的结点数目,因而用算法1求解所有SLCA结点代价为O(m·|LID1|·log|Lm|).对于构建所有TMSubtree而言,假设最坏情况下,Q的QPTree中的所有结点都需探测兄弟结点间的包含关系,则被处理结点总数为|∪m对于每个被探测的结点而言,其平均处理代价为m·log|Lm|+m2,其中m·log|Lm|是得到该结点倒排表范围和关键字集合的代价,m2为检测包含关系的代价.由于通常情况下,m<log|Lm|,因而最坏情况下构建所有TMSubtree的代价为m·|∪mlog|Lm|.由于|LID1||∪m算法1的时间复杂度为O(m·|∪m由于TDTMS算法以自顶向下、广度优先的方式建树,任何时候,内存中最多缓存一个TMSubtree,且算法所使用的队列中最多缓存该TMSubtree中一层的结点数量(m2个结点),根据文献[16]中对TMSubtree大小的证明,即式(1),可知TDTMS算法的空间复杂度为O((|d-m|+2)·m!),这里d为给定XML文档的深度.和文献[16]需要缓存d棵子树相比,TDTMS需要缓存的结点数量更少.需要说明的是,算法1以自顶向下的方式访问Q的QPTree中的所有结点,随着处理层数的增加,使用二分查找进行探测时所需的查找范围也快速缩小.对于给定的结点,实际中每次探测的范围是其父结点的局部倒排表范围,不是全局倒排表的范围.同时,通过跳过无用结点和在建树过程中及时剪枝,算法1需要处理的结点数量得以快速减少.5实验5.1实验环境本文实验所用机器的基本配置为奔腾双核E75002.93GHzCPU,2GB内存,操作系统为WindowsXP.Page10比较的算法有MaxMatch[8]、mergeMatch-ing[16]以及本文提出的TDTMS算法.对于Max-Match算法,我们分别使用HS[12]、IL[4]以及IMS[6]算法来求解SLCA结点,分别用MaxMatch-HS、MaxMatch-IL和MaxMatch-IMS表示.所有算法均使用VC++实现,本文实验中的运行时间是每个算法重复执行100次的平均时间.5.2数据集和查询本文实验使用的数据集包括XMark①(582MB)和DBLP②(876MB).我们从XMark数据集中选择了30个关键字,这些关键字根据其在数据集中出现的次数(和表3中|Li|列中的数字对应)分为3类:(1)低频关键字(100~1000);(2)中频关键字(10000~40000);(3)高频关键字(300000~600000).基于这些关键字,我们生成了32个查询,如表4所表4基于XMark数据集的查询查询Q1villages,hooksQ2baboon,patients,ArizonaQ3cabbage,tissue,shocks,babbonQ4shocks,necklace,cognition,cabbage,tissueQ5female,orderQ6privacy,check,maleQ7takano,province,school,genderQ8school,gender,education,takano,province14344435257171291070.62Q9bold,increaseQ10date,listitem,emphQ11incategory,text,bidder,dateQ12bidder,date,keyword,incategory,textQ13text,tissueQ14takano,provinceQ15incategory,cabbageQ16check,bidderQ17baboon,patientsQ18tissue,shocks,orderQ19province,bold,increaseQ20cabbage,male,femaleQ21listitem,emph,ArizonaQ22patients,school,genderQ23patients,school,gender,textQ24bold,increase,hooks,takanoQ25male,female,keyword,incategoryQ26emph,Arizona,villages,educationQ27check,bidder,date,baboonQ28school,gender,time,baboon,patientsQ29tissue,shocks,order,province,boldQ30female,keyword,incategory,cabbage,male802384411575366Q31Arizona,villages,education,listitem,emph692066350560451Q32bidder,date,necklace,cognition,check本文实验中,为了测试不同算法在各种情况下的性能特征,我们主要展示基于较复杂模式信息的XML数据集上的实验结果.限于篇幅,DBLP数据集上的实验结果这里不再展示.示,其中,∑犿和,|Lmax|(|Lmin|)表示最长(最短)倒排表的长度,NS表示满足条件的SLCA结点数量,RS=NS/|Lmin|表示结果选择率.关键字|Li|关键字|Li|关键字|Li|tissue384male18441bidder299018baboon725takano17129listitem304969necklace200order16797keyword352121arizona451school23561bold368544cabbage366check36304text535268hooks461education35257time313398shocks596female19902date457232patients382province33520emph350560cognition495privacy31232incategory411575villages829gender34065increase3047528294617423827423665962007423825.3评价标准本文实验的评价标准包括:(1)缓存结点数量,①②Page11用于比较不同算法的空间代价;(2)运行时间,包括总的运行时间、求解SLCA结果的时间以及构建所有子树的时间;(3)扩展性.对于给定的查询,我们将“结果选择率”定义为结果个数除以最短倒排表长度的比值,表4倒数第2列是每个查询的结果选择率.5.4性能比较和分析5.4.1空间代价比较为了比较不同算法的空间代价,我们统计了MaxMatch、mergeMatching以及TDTMS算法在运行过程中需要缓存的中间结点数量.表5为不同算法在处理每个查询时最多需要缓存的结点数量,可以看出,mergeMatching算法需要缓存的中间结点数量远少于MaxMatch.原因在于,MaxMatch算法需要首先将完整的路径子树构建好,在此基础上实施剪枝操作,而mergeMatching算法在顺序处理所有编码的过程中同时实施剪枝操作,因而在内存中最多缓存d个TMSubtree.查询Q1Q2Q3Q4Q5Q6Q7Q8Q9243461Q10465991Q112826470Q123218018Q13Q14Q15Q16Q17Q18Q19Q20Q211441330Q22Q23538832Q24231594Q25Q261331246Q27Q28324085Q29389656Q30623179Q311540236Q32669062和mergeMatching相比,本文提出的TDTMS算法在最好情况下所需缓存的结点数量不到mergeMatching的20%(Q25).原因在于,TDTMS算法以自顶向下、广度优先的方式剪枝,因而可以避免处理很多无用结点的后代结点,从而可以进一步降低需要缓存的中间结点数量.5.4.2求解SLCA结点的性能比较对于子树构建来说,首先要解决的问题是求解所有满足条件的SLCA结点,因此我们首先比较不同算法在求解SLCA结点时的性能.如图4所示,文本提出的方法TDTMS在多数情况下所需时间远少于IL、IMS和mergeMatch-ing,原因是本文方法以自顶向下的方式依次处理每个公共祖先结点,而IL、IMS和mergeMatching算法的基本操作是比较两个Dewey编码中的数字,由于Dewey编码中的每个数字都对应了XML文档中一个结点,且通常情况下,任意结点都可能是很多后代结点的公共祖先结点,因而频繁比较Dewey编码造成了“公共祖先重复处公理问题”[13],而TDTMS则不存在这一问题.即使和HS相比,当结果选择率变小时,TDTMS所需时间也远少于HS算法,原因在于HS需要顺序处理最短倒排表中的IDDewey编码,由于很多编码中存在相同的ID值,HS同样无法避免公共祖先重复处理问题,尤其是在最短倒排表很长而结果个数很少的情况下,即结果选择率变小的时候,HS的性能远不如TDTMS.例如,Q2、Q5~Q8、Q11~Q12、Q14、Q16、Q21、Q25、Q26、Q31.对于已有方法而言,通常情况下HS要好于IL、IMS和mergeMatching,因而在后续讨论中,当需要和MaxMatch算法进行比较时,我们都和Max-Match-HS比较.5.4.3已有方法求解SLCA对查询处理的影响为了深入理解MaxMatch构建子树过程的性能特点,我们在其求解SLCA时分别基于HS、IL和IMS算法实现了3种MaxMatch算法,分别是MaxMatch-HS、MaxMatch-IL和MaxMatch-IMS,三者在求得SLCA结点后构建子树的过程一致.如表6所示,3种算法处理每个查询的时间基本相同,其中MaxMatch-HS所需时间在多数情况下略少于另外两种算法.原因是HS算法在求解SLCA结点时只需处理一个倒排表中的结点,和ILPage12图4求解SLCA结果的运行时间比较及IMS相比,时间复杂度更小.从表6的结果可以看出,无论HS、IL和IMS有多高效,且无论HS比IL和IMS的性能好多少,当用于MaxMatch算法生成子树时,所有算法的性能优势几乎不存在.原因在于:当使用MaxMatch求解结果子树时,相对于建树的代价,求解SLCA结点的代价几乎可以忽略不计.表6不同版本MaxMatch算法运行时间比较查询Q12.340Q22.300Q33.100Q42.703Q54.710Q615.110Q797.120105.45Q8149.300151.00Q9460.600479.70Q103021.7003135.953037.00Q116446.2006468.006443.70Q129067.0009594.009057.00Q1325.130Q1429.400Q1511.400Q1632.570Q175.300Q1893.810Q1928.100Q2038.330Q211909.0001910.201910.00Q2278.300Q234047.6304048.454048.20Q241651.1001651.551652.40Q2526.170Q261344.2001344.551344.50Q2720.200Q281429.3001429.701429.80Q292944.7002945.352945.90Q302204.7002204.702204.70Q312073.3002073.452074.20Q321531.7001532.001531.005.4.4不同子树构建方法的性能比较图5展示了MaxMatch、mergeMatching以及TDTMS3种方法在构建子树时的时间比较.从该图可以看出,虽然在求解SLCA结点时,mergeMatching的性能不如HS、IL和IMS,但其构建子树的性能在多数情况下远好于MaxMatch,而且这部分节省的时间代价要远多于求解SLCA结点时浪费的代价.与此对应,TDTMS算法由于采用自顶向下,按层剪枝的策略,在多数情况下,尤其是当结果选择率较低时,获得的性能优势远好于mergeMatching算法,如Q2、Q5~Q8、Q11~Q13、Q15、Q19~28、Q30~Q32.对于Q9和Q10而言,TDTMS构建所有子树所需的时间仍然多于mergeMatching,原因是:当结果选择率变大后,每个子树中的结点数量相对变少.这时可裁剪的结点数量也相对变少,甚至没有.相对而言,mergeMatching可以更高效的处理每个无需裁剪的结点.5.4.5不同算法整体性能比较图6展示了MaxMatch-HS、mergeMatching以及TDTMS这3种算法求解所有子树所需的整体时间比较.从该图可以看出,多数情况下,mergeMatching的性能远好于MaxMatch-HS算法,原因在于mergeMatching无需反复扫描倒排表中的元素,且在剪枝过程中无需像MaxMatch-HS算法一样先建树后剪枝(需要反复访问树中结点),而是采需用边建树边裁剪的策略,可以快速减少兄弟结点间比较关键字集合包含关系的次数.与此对应,本文提出的TDTMS算法从求解Page13图5构建子树的时间比较图6不同算法整体运行时间比较SLCA和构建子树两个角度进行优化,不但在求解SLCA结点时像IL和IMS一样跳过无用结点,甚至更好,而且在建树过程中通过自顶向下、按层构建的方式快速裁剪无用结点,因而整体性能明显优于MaxMatch-HS和mergeMatching算法.通常情况下,对于很多查询来说(Q2、Q6~Q8、Q11~Q12、Q13、Q15、Q19~Q32),TDTMS比MaxMatch-HS和merge-Matching快10倍以上,最好情况下甚至比MaxMatch-HS和mergeMatching快3个数量级以上,如Q21和Q27.5.4.6扩展性图7展示了不同方法在大小不同的XML文档图7不同文档上执行查询Q7的扩展性比较上执行Q7时的扩展性.可以看出,TDTMS具有较好的扩展性.限于篇幅,其它查询的扩展性不再展示.6结论子树构建是影响XML关键字查询处理性能的重要因素.针对已有方法在求解结果子树时建树代价高(MaxMatch算法),或者无法避免处理无用结点(mergeMatching算法)的问题,本文提出一种自顶向下构建结果子树的高效算法———TDTMS.TDTMS以自顶向下、深度优先的方式求解满足SLCA查询语义的子树根结点,避免了已有方法求解SLCA结点时存在的公共祖先重复处理问题.对于给定的子树根结点,TDTMS以自顶向下、广度优先的方式构建子树,可以在建树过程中快速裁剪不满足条件的结点,因此获得了最小的时间复杂度和空间复杂度.最后通过实验验证了TDTMS在时间和空间两方面的性能优势.本文的后续工作将考虑针对ELCA语义的结Page14果子树构建操作,并设计统一框架来处理基于XML关键字查询的子树求解问题.
