Page1从交互情景出发的需求捕获方法及其支撑工具陈小红1),2)尹斌2)金芝2),3),4)1)(华东师范大学上海市高可信计算重点实验室上海200062)2)(中国科学院数学与系统科学研究院北京100190)3)(高可信软件技术教育部重点实验室(北京大学)北京100871)4)(北京大学信息科学技术学院软件研究所北京100871)摘要需求捕获是需求工程中的重要问题.文中结合情景和问题框架方法,提出一个从交互情景出发的需求捕获方法.其特点是:(1)对问题领域以及软件系统与问题领域间的交互进行分类,以捕获深层需求信息;(2)将情景定义为产生有意义问题领域变化的交互序列,引入交互情景约束,以捕获隐式需求信息.文中构建了支持这个方法的需求描述元模型,提出以该元模型为基础的需求捕获过程.文中还构建了相应的支撑工具,提供各种需求元素的编辑、检测和验证手段,帮助需求提供者正确地表达需求信息.关键词需求捕获;情景;问题领域;问题框架方法1引言需求捕获是需求工程中的重要问题.不同的需求捕获方法蕴含捕获需求的不同思路.面向目标的方法[1]将“目标”作为软件需求的来源和依据,而面向主体和意图的方法[2]以“参与者”为主要线索去识别需求.基于环境建模的方法[3-4]则强调需求存在于未来软件系统将处于的现实环境(问题领域)中,需要从问题领域中去发现软件需求.它认为,软件系统行为的结果只能在其环境中进行观察和评估,而环境的变化又是由于软件系统的作用而引起的.从这个意义上说,软件需求是用户期望对问题领域发生的改变.这种改变通过建立一个软件系统,并使这个系统与问题领域发生交互而实现.问题框架方法[5]是一种典型的基于环境建模方法.它强调对软件系统将要作用的现实世界问题领域进行刻画,并将软件需求的含义指称到与现实世界相关的问题领域描述上.在需求捕获中,它通过识别问题领域和软件与问题领域的交互,定义问题领域的变化,由此定义软件需求.特点在于它以问题领域的变化效果定义需求,因此,需求提供者可以此判断被捕获的需求是否满足他们的真正需要.但是,目前基于问题框架方法的需求捕获缺乏必要和有效的指南和工具支持,需求捕获的结果完全依赖于需求分析员的经验,有必要构建相应的需求元模型和需求捕获启发式,帮助需求工程师系统地进行需求的捕获.基于情景的方法[6]在需求捕获方面有其独特的优势.它从具体的应用情景出发,给出软件系统与环境的主要交互活动的客观描述.它强调,要从用户熟悉的情景中,也就是软件系统与环境的交互活动中去发现需求.将情景作为一种沟通方式,使需求捕获更加直观[7],易于需求提供者理解和识别,便于充分发挥需求提供者的主动性.但是,目前基于情景的方法缺少公认的情景结构,不利于建立有效的情景需求分析方法.结合上述两种方法,我们提出将软件系统与问题领域的交互序列定义为一个情景,其中,一个交互序列可以构成一个情景,如果它描述了软件系统通过交互在问题领域上产生期望的有意义的变化,也就是它实现了需求.我们引入情景结构约束,捕获潜在的需求信息,同时还构建了相应的支撑工具,提供各种编辑、检测和验证手段,引导和帮助需求提供者提供需求信息.本文第2节给出结合情景和问题框架的需求元模型;第3节给出需求捕获过程;第4节给出情景分析方法;第5节给出支撑工具和案例研究;最后,第6、7节讨论相关工作并总结全文.2结合情景与问题框架的需求元模型在深入研究情景与问题框架方法基本概念的基础上,我们提出了一个结合情景与问题框架方法的软件需求描述元模型.图1给出了这个需求描述元模型,它采用了OMT表示法[8],其中,白色结点和它们之间的连线表示问题框架方法中的概念和概念间关联.其含义如下:(1)每个问题(Problem)[9]都要开发(develop)一个软件系统(Machine),处于(beLocatedIn)一组问题领域(ProblemDomain)中,有(hasInt)一组软件系统与问题领域的交互(Interaction),满足(satisfy)一组需求(Requirement).(2)问题可以是基本问题(BasicProblem)或复杂问题(ComplexProblem).(3)问题领域可以是因果领域(CausalDomain)、服从式领域(BiddableDomain)或词法领域(LexicalDomain).(4)每个交互(Interaction)由一个软件系统或者一个问题领域发起(initiate)或接收(receive),交互的内容(hasContent)是一个现象(Phenomenon),现象可以是状态(State)、事件(Event)和值(Value).根据交互内容可以将交互分为状态交互(StateInteraction)、值交互(ValueInteraction)和事件交互(EventInteraction).图1中的灰色结点表示与情景相关的概念,包括情景(Scenario)和交互图(InteractionGraph).情景概念的引入是为了刻画软件系统如何通过交互来实现需求,因此将它指定为问题领域与未来软件系统为满足某个需求而应该进行的一个交互序列[10],表示软件系统通过与问题领域之间的一系列交互,将产生问题领域上预期的变化.每个情景都要关联到一个需求上,表明它将实现(realise)这个需求.每个情景的执行(beConductedBy)由一个交互图来描述,因此每个交互图中应包含(contain)多个交互.表1给出上述概念的层次结构及定义.Page3图1需求描述元模型[10]表1需求描述元模型中概念的层次结构及含义概念问题基本问题存在已知的问题求解模式,存在基本问题类型复杂问题不存在标准的问题求解模式,需要分解为简单软件系统在软件开发中要开发的系统问题领域与软件系统交互的现实世界的实体服从式领域是物理的,缺乏明确的、可预计的内部因果性因果领域在其现象之间存在可预测的因果关系词法领域数据的物理表示需求交互事件交互交互共享的是事件现象状态交互交互共享的是状态现象值交互交互共享的是值现象现象事件某个特定时间点上发生、出现的个体状态因果实体和值之间的关系,可以随时间改变值情景交互图一个有向图,结点是交互,边表示交互间关系3需求捕获过程遵循图1给出的需求描述元模型,我们定义了一个需求捕获过程,如图2所示.它包含4个步骤,即确定系统边界、识别系统行为、定义需求和定义需求实现.3.1确定系统边界交互的问题领域,有两个子步骤:确定系统边界的任务是识别与待开发软件系统(1)标识软件系统.通过命名软件系统,以显式区分软件系统和问题领域.软件系统可以表示为:其中,MacN是软件系统的标识,Des是对软件系统的描述.(2)识别问题领域.问题领域处于软件系统之外,是与软件系统进行交互的现实世界实体.根据问题领域的分类,我们设计了相应的问卷来帮助识别不同类型的问题领域,如表2所示.目的识别服从式领域识别因果领域识别词法领域Page4问卷中每个问题的答案都可以作为一个对应类型的问题领域.需要指出的是,问题领域的识别与待开发的软件系统密切相关,不同的软件系统,有着不同的开发目的,与它进行交互的问题领域就可能是不同的.另外,现实世界中的某些问题领域是复杂的,它可能有多个子问题领域,或多种问题领域类型,如果它的某一部分是可以独立与待开发软件系统进行交互,则这一部分就可以识别出来作为一个问题领域.每个识别出来的问题领域可以表示为:ProblemDomain(DomN,Des,DomTypeSet),其中,DomN是领域标识,Des是领域描述,DomType-Set是领域类型集合.3.2识别系统行为识别系统行为的任务是描述待开发软件系统与问题领域之间允许发生的交互,它有两个子步骤:(1)识别共享现象.不同类型的问题领域,可能与软件系统共享的现象类型也不同.它们之间的关系如表3所示.我们同样可以设计出相应的问卷(如表4所示)来帮助识别共享现象.事件状态值提问对象对每个服从式领域它发出什么事件(包含命令)?对每个因果领域对每个词法领域每个问题领域与软件系统都可能共享一组现象.问卷中每个问题的答案都是一个共享现象.每个识别出来的共享现象可以表示成如下形式:其中,PheN是共享现象的标识,Des是共享现象的描述,PType是它的类型.(2)识别行为交互(Beh).在共享现象的基础上,进一步识别待开发软件系统与问题领域的交互.因为这种交互描述了软件识别出来的交互可以表示为如下形式:系统将允许与问题领域之间发生的交互,表现了软件系统的行为,故称之为行为交互.识别行为交互是在共享现象的基础上进行的,具体地说是要判断一个共享现象的发起者和接收者.Interaction(IntN,Initiator,Receiver,Content),其中,IntN是交互的标识,Initiator是交互的发起者,Receiver是交互的接收者,Content是交互的内容,也就是共享现象.3.3定义需求变化效果,它分为3个子步骤:定义需求的任务是确定需求并定义需求产生的(1)识别需求.这里,需求是对软件系统功能需求的文字表示,表达来自于软件开发任务要求“超过当前”的期望.从基于环境建模的需求工程的角度看,需求来自于对问题领域在引入了待开发软件系统后应该满足的新的约束的期望.据此,我们也设计了相应的问卷(如表5所示)从不同的问题领域类型组合形式去捕获有意义的期望约束.提问对象服从式领域+因果领域每个因果领域软件系统期望它有什么动作?因果领域+词法领域因果领域+因果领域因果领域期望另一个因果领域显示什么信息?服从式领域+词法领域服从式领域要对该词法领域做什么操作?词法领域+词法领域问卷中每个问题的答案可以用自然语言语句给出.每个识别出的需求可以表示为如下形式:其中,ReqN是需求的标识,Des是需求的描述.(2)识别期望交互(Exp).期望交互是需求中表达的变化效果,它是人们“期望”在问题领域上发生的可观察的改变,可以用交互的形式表示,这种交互称为期望交互.针对每种类型的问题领域,我们设计了问卷来帮助发现期望交互,如表6所示.Page5提问对象每个服从式领域,每个需求每个因果领域,每个需求每个词法领域,每个需求形式.识别出的期望交互采用与行为交互相同的表示(3)识别需求引用.对于每个需求,需要识别需求与每个问题领域的期望交互现象之间的关系,分为两种,一般性引用和约束性引用.一般性引用表示该需求仅引用该期望交互的现象,约束性引用表示该需求不仅引用该期望交互的现象,而且规定关于该期望交互现象的发生.需求引用表明了在一个需求作用下问题领域的变化集合.需求引用表示为:Reference(ReqN,Ini,Rec,Phe,RefType)其中,ReqN是需求,Ini是该引用的期望交互的发起者,Rec是该引用的期望交互的接收者,Phe是该引用的期望交互的现象,RefType要么是一般性引用(Normal),要么是约束性引用(Constraining).3.4定义需求实现定义需求实现的任务是通过构造情景来描述软件系统如何通过交互使得问题领域发生期望的变化,它有3个子步骤:(1)绘制交互图.用交互图来表示情景(即需求的一个实现),首先定义交互图为如下二元组:InteractionGraph··=〈intSet,AssSet〉其中,IntSet=Beh∪Exp是交互的集合,包含该需求涉及的行为交互集合Beh和期望交互集合Exp.AssSet是交互序关系的集合,区分如下5种交互序关系(assTy):①行为序关系(behOrd).Beh→Beh,行为交互与行为交互之间的序关系.②期望序关系(expOrd).Exp→Exp,期望交③行为使能关系(behEna).Beh→Exp,行为④需求使能关系(reqEna).Exp→Beh,期望交⑤同步关系(synchrocity).BehExp,行为交互与期望交互之间的序关系.交互使能期望交互的关系.互使能行为交互的关系.互与期望交互间的同步关系.对每个需求,都要定义一个情景来描述它的实现.情景的定义分为两步.第1步,选取实现需求要进行的交互,作为交互图中的结点.算法1用于进行情景候选交互的选择,主要活动包括从期望集合中找到该需求引用的期望交互和在行为交互集合中查找需求引用的问题领域的行为交互.算法1.情景候选交互的选择算法.输入:行为交互集Beh,期望交互集Exp,引用集合输出:情景的候选交互集合Int1.begin2.在Ref中寻找与ReqN相关的需求引用,构造引用3.forR中的任一引用r4.在Exp中寻找r的期望交互,构造期望交互集合5.Int=Int∪ΕxpN;6.在Ref中寻找r所连接的问题领域E;7.在Beh中寻找E的所有行为交互,并构造行为交互次序关系;8.Int=Int∪BehN;9.返回Int;10.end第2步,确定交互间的序关系,包括①行为序关系.行为交互间的因果关系;②期望序关系.期望交互间的预期发生的先后③行为交互与期望交互间的关系.行为交互与(2)检测交互图类型正确性.交互图展示为实现某个需求,软件系统与问题领域的行为交互、期望交互以及它们之间的序关系.根据情景图中交互序关系的定义,情景中任意一个交互序关系的两个交互的类型是确定的,其对应关系如表7所示.期望交互间的因果关系.assTy(a,b)behOrd(a,b)reqOrd(a,b)behEna(a,b)reqEna(a,b)synchrocity(a,b)a(b)算法2为交互图的类型检测算法,主要包括读取情景图中的任一关系并判断该关系连接的两个交互类型是否正确.Page6算法2.交互图类型检测算法.输入:交互图sce,其中sce=〈Beh∪Exp,AssSet〉输出:交互图sce类型是否正确,否若,返回相应的提示1.begin2.forrelInt(a,b)∈AssSetsce3.查找a连接的问题领域D,b连接的问题领域E;4.switch(relInt)5.casebehOrd:6.ifa∈Beh且b∈Beh;7.else返回a与b不是行为序关系;8.casereqOrd:9.ifa∈Exp且b∈Exp;10.else返回a与b之间不是期望序关系;11.casebehEna:12.ifD==E且a∈Beh且b∈Exp13.else返回a与b之间不是行为使能关系;14.casereqEna:15.ifD==E且a∈Exp且b∈Beh16.else返回a与b不是需求使能关系;17.casesynchrocity:18.ifD==E且((a∈Exp且b∈Beh)或者(a∈19.else返回a与b不是同步关系;20.返回sce类型正确;21.end(3)生成需求描述文档.需求描述文档是需求捕获的结果.从图1的需求元模型出发,一个需求描述文档(Problem)由5部分组成:被创建的软件系统(M)、与软件系统交互的问题领域的集合(DS)、软件系统与问题领域的行为交互和期望交互的集合(IS)、软件系统要满足的需求的集合(RS)和实现需求集合的情景集合(SS).其中每个情景用情景文档来描述.情景文档是对一个情景的详细说明,包括情景名、情景描述、问题领域、实现的需求、行为流及扩展.其中,情景描述只是对情景的一个自然语言描述,问题领域是该情景涉及到的问题领域,实现的需求是指该情景实现的需求,行为流是连续的交互序列,扩展是指对行为流中并发交互段的描述.需求描述文档的软件系统、问题领域、交互和需求集合都是在需求捕获过程中直接获得的,而情景集合中的情景文档中的行为流是从交互图转化而来.如下规则表示如何将交互图表述为一个行为流:①情景中的结点(交互)组成了行为流中的基本单元行为,行为的表述模板为(i)若交互的发起者为软件系统(M),则行为是MinitiateshasContent(a)toreceive(a).(ii)若交互的发起者为问题领域,则行为是MreceiveshasContent(a)frominitiate(a).②交互图中交互间关系与行为流中行为的顺(i)行为交互按行为序关系(behOrd)顺序排序的对应关系是列,这个序关系形成行为流的主干.(ii)对所有的行为使能关系(behEna),其期望交互插在行为交互之后.交互插在行为交互之后.(iii)对所有的需求使能关系(reqEna),其期望③交互图中的并发交互段以一个虚拟行为的方式出现在行为流的主干中,虚拟行为的表述模板为(i)若并发交互的发起者为软件系统(M),则虚(ii)若并发交互的发起者为问题领域,则虚拟拟行为是行为是MreceivesInfofromProblemDomains.④交互图中的并发交互段的具体行为以顺序方式排列在扩展中,其排号与虚拟行为的排号相同.4情景分析情景分析是对交互图进行的一种语义分析,包括情景完整性和情景一致性分析.4.1情景完整性分析情景完整性是指情景中的交互都必须能够发生.具体而言,违背完整性的情景有3种.第1种,存在没有被实现的期望交互,也就是说,这个期望交互与任何行为交互都没有关系,不存在系统的行为可以保证该期望交互的发生.第2种,软件系统需要发起一个值交互,但不存在一个软件系统接收的值交互,作为产生这个值的前提,以支持该行为交互的发生.第3种,对某个情景的某一需求使能关系中的期望交互,不存在该情景的某个行为交互,使得该行为交互和期望交互之间存在行为使能关系,来确保该期望交互的发生.这3种情况可以分别表示为3条完整性约束,分别是约束1、约束2和约束3(如图3所示).Page7约束1:对期望交互的要求前提:P=〈M,DS,IS,RS,SS〉条件:sce∈SS,sce=〈Beh∪Exp,AssSet〉,a∈Exp结论:b∈Beh,使得assTy(a,b)∈AssSet约束2:对软件系统行为的要求前提:P=〈M,DS,IS,RS,SS〉条件:sce∈SS,sce=〈Beh∪Exp,AssSet〉,a∈IS,a是M发起的行为交互且是值交互结论:b∈Beh,使得behOrd(b,a)∈AssSet,或者存c∈Exp,使得reqEna(c,a)∈AssSet约束3:对需求使能关系的要求前提:P=〈M,DS,IS,RS,SS〉条件:sce∈SS,sce=〈Beh∪Exp,AssSet〉,reqEna(a,b)∈AssSet,结论:sce2∈SS,behEna(c,a),使得c∈sce2违背约束1说明软件系统的行为不能保证需求的发生.我们提出策略1进行情景的修正,即通过引入新的领域来提供新的信息来允许该期望交互发生,由此带来对整个问题的精化,包含引入新的交互、新的领域、补充情景等等.策略1.引入新的领域进行问题精化.若问题P=〈M,DS,IS,RS,SS〉中,情景scei中存在期望交互intR未被确定时,当引入一个新领域d之后,可经过如下4大步对P进行精化:(1)将d添加到DS,即DS=DS∪{d}引入d之后,有两种策略来创建d,一种是引入一个服从式领域b(d)作为模型构建器,则DS=DS∪{b(d)},另一个策略是自动的模型构建器;(2)识别涉及d、intR发生的领域与创建d引入的领域的交互,并将它们加入到IS;(3)RS中加入一个新的需求,reqn+1={创建领域d},RS=RS∪{reqn+1};对SS中不满足条件的intR涉及的所有情景进行修正.(4)为需求reqn+1构造情景scen+1,SS=SS∪{scen+1},违背约束2说明不能保证软件系统的行为的发生.我们提出策略2进行情景的修正,即通过引入新的词法领域来提供值信息来允许该行为交互发生,由此带来对整个问题的精化,包含引入新的交互、新的领域、补充情景等等.策略2.引入新的词法领域进行问题精化.若问题P=〈M,DS,IS,RS,SS〉中,情景scei中存在未被支持的软件系统值交互a,当引入一个新的词法领域d之后,可经过如下4大步对P进行精化:(1)将d添加到DS,即DS=DS∪{d}引入d之后,有两种策略来创建d,一种是引入一个服从式领域b(d)作为模型构建器,则DS=DS∪{b(d)},另一个策略是自动的模型构建器;(2)识别涉及d发生的领域与创建d引入的领域的交互,并将它们加入到IS;RS=RS∪{reqn+1};(3)RS中加入一个新的需求,reqn+1={创建领域d},(4)为需求reqn+1构造情景scen+1,SS=SS∪{scen+1},对scei中a构建行为序关系或需求使能关系.违背约束3说明该期望交互并没有发生,需要一个新的需求来保证该期望交互的发生.我们提出策略3进行情景的修正,即通过引入新的需求对问题进行精化和情景补充.策略3.引入新的需求进行问题精化.问题P=〈M,DS,IS,RS,SS〉,intR是需求使能关系中的期望交互,ρ(intR)是intR发生的问题领域,当引入新需求req时,P可经过如下4大步进行精化:(1)引入一个服从式领域b作为ρ(intR)的构建器,DS=DS∪{b};(2)识别涉及b(d)和ρ(intR)的交互,添加到IS中;(3)添加新需求req来创建ρ(intR),即RS=RS∪{req};(4)构造req的交互图sce,在其中使能intR,SS=SS∪{sce}.4.2情景一致性分析情景一致性指交互间的序关系必须满足因果性(hasCausal),而且这种因果性在同一个问题的各个情景中是一致的.具体而言,违背一致性有两种情况,一种是在同一个情景内部,出现环路的,导致交互出现自反.另一种是在不同的情景中出现的两个相同的交互,其因果关系却是不同的.我们提出情景的两条一致性约束分别表示这两个约束,它们是约束4和约束5(如图4所示).违背任何一个约束,都需要需求分析员进行情景的修正.其相应的策略是要提示需求提供者重新验证这个情景的交互流,重新调整交互之间的关系,直到不一致性被完全消除.约束4:对同一个情景的要求前提:给定问题P=〈M,DS,IS,RS,SS〉条件:sce∈SS,sce=〈IntSet,AssSet〉,a∈IntSet结论:hasCausal(a,a)约束5:对同一个问题的不同情景的要求前提:P=〈M,DS,IS,RS,SS〉,sce1,sce2,∈SS,sce1=〈IntSet1,条件:sce1中出现hasCausal(a,b)结论:sce2中出现hasCausal(a,b)AssSet1〉,sce2=〈IntSet2,AssSet2〉,a,b∈IntSet1∩IntSet2Page85工具实现与案例研究5.1工具的实现我们设计并实现了支持上述需求捕获过程的工(1)工具栏.显示需求元素的图形表示,图形与需求元素的对应关系如图6所示.图5支撑工具的界面截图(2)流程控制.嵌入需求捕获过程作为其控制流程,引导需求提供者系统有序地进行需求描述.还将对情景的一致性和完整性约束检测嵌入了流程中,帮助捕获一些潜在的需求信息.(3)画布.有两种形式的画布,一是问题图画布,其中描述了软件系统、问题领域、交互和需求.另一种是情景画布,用来描述情景.图5中间部分展示的是情景.(4)需求断言表.包含交互表、现象表、需求表、需求引用表等,它是在用户提供了需求相关信息之后自动生成的,是需求相关信息的记录.图5右边上部展示了交互表,是交互的集合.具.它支持图形化描述,提供了各种编辑、检测和验证手段,帮助需求分析员指导需求捕获.图5是该工具的界面截图,其中的标记位置是工具界面的5个区域:(5)情景文档.情景文档是情景的详细说明,根据每个情景图生成.图5右边下部展示的是一个情景文档.5.2案例研究本节以邮包投递控制问题[6,10]为例,使用需求捕获的支撑工具对该问题进行需求捕获.该案例的自然语言陈述为:邮包投递器(Router)是一个机械装置,用于把邮包(Package)按目的地(Destination)投递到相应邮箱(Bin).邮包带有条码标签(Label),通过传输带(PackageConveyer)移动,读码工作站读取邮包的标记和目的地给计算机.计算机控制通道开关设置邮包的走向,如果发现错误投递的邮包,及时通过显示器(DisplayUnit)显示错误信息.操作者(RouterOperator)可以通过控制按钮控制计算机停止和启动传输带.问题是要建立控制计算机:(1)服从操作者的命令,(2)通过适当地设置开关将邮包投递到目的地邮箱中,(3)报告错误投递的邮包.5.2.1确定系统边界(1)命名软件系统.可以命名软件系统为邮包投递控制器RC(RouterController).单击工具栏中软件系统图元,在问题图画布中创建软件系统的实例,双击该实例,在弹出的对话框中输入软件系统的名称,如图7中双竖线矩形所示.Page9(2)识别问题领域.根据问题领域识别问卷,操作者RO(RouterOperator)要使用该系统停止和启动传输带,因此增加操作者RO为服从式领域(B).软件系统可以控制的外部物理设备有邮包与投递器PR(Package&Router)、传输带PC(PackageConveyer)和显示器DU(DisplayUnit),它们都是因果领域(C).类似地在问题图画布中添加这些领域,并在对话框中输入问题领域名称、领域类型,结果如图7中矩形所示.5.2.2识别系统行为根据共享现象的识别问卷,可以知道RO引起OnBut和OffBut事件,按下指示传输带启动和停止传送的按钮.单击工具栏中交互图元,然后在画布中点击软件系统RC和问题领域RO,由此创建它们之间的交互,双击该交互,在弹出的对话框中输入:共享的现象OnBut和OffBut,现象类型都是事件,现象都由RO发起,由软件系统接收.类似地可以识别其它行为交互,得到交互表,如图8所示.5.2.3定义需求(1)识别需求.根据需求的识别问卷,可以识别出:①RO需要控制计算机使PC停止(Stopped)或运行(Run-ning);②软件系统通过设置开关方向将邮包PR投递到目的地邮箱;③PR通过DU展示错误投递的邮包.识别出3个需求,需求1(req1)———遵守操作者命令(obeyoperator’scommand),需求2(req2)———正确投递(correctcorrecting)和需求3(req3)———报告错误投递的邮包(reportmisroutedpackage).类似地在问题图画板中添加需求,并编辑它们,结果如图7中虚线椭圆所示.(2)识别期望交互和需求引用.根据期望交互的识别问卷,为了满足需求req1,OP要发起事件OnBut和OffBut,而预期PC的状态变为Running和Stopped.所以可以得到PC和RC共享的期望交互:单击工具栏的需求引用图元,在问题图画布中点击需求req1和问题领域PC,由此创建它们之间的需求引用实例,双击该实例,在弹出的对话框中输入int15和int16作为期望交互,使用类型为约束性引用.类似地,可得到其它的期望交互和需求引用,由此得到需求引用列表,如图9所示.5.2.4定义需求实现由3个需求,自动生成3个情景画布绘制交互图sce1,sce2和sce3,用来表示实现需求req1,req2和req3.(1)绘制交互图.首先是选择候选交互.每个交互图画布都分别列出了所有可能的交互.例如,在sce1的标签中,可以看到sce1中候选的行为交互有int1、int2、int13、int14,期望交互有int13、int14、int15、int16.其次由需求提供者确定交互间关系.例如,RO发出OnBut(int13)命令,期望看到RO发出OnBut(int13)命令给软件系统RC,RC发出OnC(int1)给PC,PC的状态变为Running(int15),因此,int13和int13之间存在同步关系,int13和int1之间存在行为序关系,int1和int15之间存在行为使能关系.期望交互int13和int15之间存在期望序关系.类似地,可以确定其它的交互间关系,点击sce1的标签,编辑sce1中的候选交互间关系,由此得到如图10所示情景sce1.Page10类似地,点击sce2与sce3的标签,确定那些交互间关系,可以得到如图11和图12所示的情景sce2和sce3.(2)检测交互图类型正确性.在sce2的标签中,右键选择对sce2进行检测,检测结果为:“int10与int12不是期望序关系,请重新确定它们之间的关系”.int10与int12都是行为交互,它们之间的关系应该是行为序关系,修正后的检测结果为:“交互图sce2正确”.类似地,检测sce1和sce3,结果显示正确.(3)检测情景的一致性和完整性.该检测由工具自动完成,检测结果为:情景不满足完整性约束:(a)情景sce2和sce3中有未确定期望交互int18,违反完整性约束1;(b)sce2中软件系统发起的行为交互int6和int7缺乏值交互的支持,违反完整性约束2.可以采用策略1来解决检测结果(a)的问题,即增加一个新的问题领域DBM(Destination—BinMapping)来提供关于目的地和邮箱的相关知识,以此根据目的地正确找到邮箱.根据策略1的(1)~(3)步,采用服从式领域DI(DestinationInformant)来创建DBM,由此产生如下的领域、交互、需求引用和需求:Domain(dom5,DI,{biddabledomain})Domain(dom6,DBM,{lexicaldomain})Phenomenon(phe20,EditCommands,{event})Phenomenon(phe21,MappingOperations,{event})Interaction(int20,DI,RC,EditCommands)Interaction(int21,RC,DBM,MappingOperations)Requirement(req4,‘editingdestination-binmapping’)Reference(req4,DI,RC,EditCommands,normal)Reference(req4,DBM,RC,Assoc(d,b),constraining)Phenomenon(phe22,Assoc(d,b),{value})Interaction(int22,DBM,RC,Assoc(d,b))Phenomenon(phe23,Assoc(d,b),{event})Interaction(int23,DBM,RC,Assoc(d,b))根据策略1的第(4)步,构造了新的情景sce4来实现需求req4,其交互图如图13(c)所示.另外,情景sce3发生了改变,将int23插入在int10和int12之间,由它使能期望交互int18.修改后的sce3如图13(b)所示.同样地,情景sce2也随之发生类似的变化.检测结果(b)说明,软件系统要对RP的开关进行设置,必须要先知道关于邮包投递器的布局信息,这些信息不能直接从邮包投递器本身得到,必须来自邮包投递器的一个模型.根据策略2,引入新领域-邮包投递器模型RLM(RouterLayoutModel),并由布局信息提供者LI(LayoutInformant)创建该模型.由策略2的(1)~(3)步,可得到如下描述:Domain(dom7,LI,{biddable})Domain(dom8,RLM,{lexical})Phenomenon(phe24,EditCommands,{event})Phenomenon(phe25,LayoutModelOperations,{event})Phenomenon(phe26,RouterLayoutStates,{state})Interaction(int24,LI,RC,EditCommands)Page11Interaction(int25,RC,RLM,LayoutModelOperations)Interaction(int26,PR,RC,RouterLayoutStates)Requirement(req5,‘routerlayoutmodeling’)Reference(req5,PR,LI,RouterLayoutStates,normal)Reference(req5,RLM,RC,LayoutModelStates,con-straining)Phenomenon(phe27,LayoutModelStates,{state})Interaction(int27,RLM,RC,LayoutModelStates)由策略2的第(4)步,构造新情景sce5实现新需求req5,其交互图如图13(d)所示.另外,随着新领域和交互的引入,需求req2的情景sce2发生了改变,int27使能了int6,int7的发生,它提供关于邮包投递器布局的信息.修改后的sce2如图13(a)所示.(4)生成需求描述文档.完成上述步骤后,工具自动产生邮包投递控制问题的需求描述文档,如图14所示.其中,情景sce1的文档如图15所示.其它的情景文档见附录.PpackageroutercontrolproblemM{RC}DS{PR,RO,PC,DU,DBM,DI,RLM,LI}ISRS{req1,req2,req3,req4,req5}SS{sce1,sce2,sce3,sce4,sce5}6相关工作早期的需求捕获技术包括面谈法和问卷法,提供通用的需求捕获技术.如何有效地实施这些技术需要需求捕获方法的指导,以帮助设计问卷、制定商谈计划等.需求捕获方法还包括用例法和情景实例法.用例法是目前工业界广泛使用的方法.用例(UseCase)从使用系统的角度描述系统中的信息,即站在系统外部察看系统功能,并不考虑系统内部对该功能的具体实现方式.情景实例法的典型工作包括CREWS方法[11],它是一种面向用户的需求工程技术,直接从用户的观点描述系统外部行为.但是,用例法和情景实例法都只捕获了软件系统与问题领域的交互,它们只关注了软件系统和问题领域的接口,但却没有涉及关于问题领域和需求的信息的原始收集,即没有涉及软件需求从哪里来,客户存在什么问题需要解决,为什么客户会期望或者需要软件来帮助它们解决这些问题,他们需要软件帮他们做什么等等问题.现代的需求工程方法提出对面向包含软件及其环境的软件加强型系统的需求捕获,从中识别出或推导出人们对软件的真正需求.代表性的方法包括面向目标的方法和面向主体和意图的方法.每种方法都蕴含自己的看待软件系统的观点.面向目标的方法[1]将“目标”看作是软件需求的来源和依据,以目标为需求捕获的基本线索,诱导需求提供者按目标的分解、精化和抽象关系,逐步构建系统目标与/或树.其代表性工作为基于自动规约的需求获取方法KAOS[12].这种目标驱动的需求获取从追究需求相关者“为什么”要建立系统出发,将原始需求表示为要实现的一组目标,逐步导出建立该系统的关注点和约束条件.面向主体和意图的方法[2]提供一种基于组织层次结构和环境上下文的需求获取和建模思路,其建模理念为刻画“有目的的参与者”.它以“参与者”为主要线索去识别需求,认为系统的参与者是有目标、有信念、有能力和有承诺的自治或者半自治主体,这些参与者之间存在各种各样的关系,包括目标依赖关系、任务依赖关系、资源依赖关系和软目标依赖关系等.其代表性工作i方法[13]的需求获取的主要活动有识别参与者、识别各参与者的目标和任务和识别各参与者之间的依赖关系等.本文提出的方法也是一种面向软件加强型系统的需求捕获方法.与上述方法不同,它认为,软件需求存在于环境中,是用户期望对问题领域发生的改变,这种改变通过建立一个软件系统,并使这个系统与问题领域发生交互而实现.其需求捕获以“问题领域”和问题领域与软件系统的“交互”为主要线索进行.这是它与其它需求捕获方法的根本区别.与面向目标的方法相比,它具有明显的客观性.与面向主体和意图的方法相比,环境的变化效果是有客观依据Page12的,而参与者之间的关系是主观识别的,因此更具有客观性.7结束语需求捕获是需求工程过程的第一阶段,其结果为后续需求分析和规格说明等需求工程活动奠定了基础,其重要性毋庸置疑.本文从交互情景出发,提出了一个结合情景和问题框架方法的需求捕获方法,并开发了支撑工具.该方法的主要特点有:(1)通过对问题领域和交互的分类,设计出相应的问卷指导用户识别问题领域和交互,捕获深层需求信息;(2)通过情景约束,捕获潜在需求信息;(3)情景作为和需求提供者进行沟通的方式,更加直观,易于需求提供者理解和识别;(4)以问题领域的变化效果定义需求,便于需求提供者判断被捕获的需求是否能够满足他们的真正需求.特别地,问卷法的使用和工具的支持使得本方法具备良好的易用性,从需求提供者熟悉的情景出发,描述问题领域以及问题领域的变化效果,使得它具备良好的实用性.需要指出的是,本方法强调对软件系统的环境和软件系统与环境交互的识别,因此可以用于帮助确定软件系统的边界,适用于人机交互系统、嵌入式系统等系统的需求捕获.本文的主要工作包括:(1)构建了需求描述元模型,以帮助需求工程师系统地进行需求捕获.(2)提出了一个需求捕获过程,以需求描述元模型为线索,通过一系列问卷,诱导需求提供者逐步提供需求描述相关信息.(3)提供了对情景的完整性和一致性分析,以帮助需求提供者根据情景完整性约束和一致性约束,发现潜在的需求和检测情景一致性,并提供策略解决不满足的情况.(4)构建了相应的需求捕获支撑工具,提供各种需求元素的识别编辑、检测和验证手段,为需求捕获提供系统的支持.目前,本方法提出的框架中还缺少非功能性需求的捕获方法,从交互或交互情景出发捕获非功能性需求是未来工作的方向.
