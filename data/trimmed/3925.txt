Page1一种基于双仲裁时间片策略的可重构硬件任务调度算法杨志华1)伍卫国1)王涛1)钱德沛2)1)(西安交通大学计算机科学与技术系西安710049)2)(北京航空航天大学中德软件新技术研究所北京100191)摘要在可重构系统中,二维布局模型比一维布局模型具有更高的自由度.然而,二维模型获得较高的资源利用率要以复杂的资源管理和任务调度算法为代价,这不但使调度过程变得复杂,而且导致时间开销大,直接影响系统实时性.针对这一问题,在综合考虑性能和算法复杂度的基础上,提出了一种适用于二维可重构器件的双仲裁时间片可重构硬件任务调度算法DATS(DoubleArbitersTime-Sliced).算法采用两个仲裁器对硬件资源进行管理,并根据空间和时间约束动态裁决任务布局位置;同时设计了双仲裁时间片任务调度模式图,对任务的调度和布局过程进行合理分离,使任务调度和布局过程相对独立并简化处理过程.DATS算法的调度时间复杂度为O(N),单任务布局算法的时间复杂度为O(E),其中N为被调度的任务总数,E(<N)为器件中正在执行的任务数目,实验表明,DATS算法时间开销小,在轻负载情况下任务调度成功率比stuffing算法高1%~2%,在重负载情况下资源利用率保持在80%~85%的水平,与时间复杂度为O(N2)的算法基本一致,所以更适合于实时情况下的任务调度.关键词可重构;时间片;双仲裁;任务调度1引言在传统的SoC或嵌入式系统设计中,具体应用通过软硬件划分[1-3]之后产生多个计算任务,通过专用集成电路等硬件实现任务的计算,速度快,效率高;利用微处理器通过软件实现任务的计算,灵活性高,速度和效率则较差.为了综合使用软硬件的优点,研究人员开始关注可重构计算[4].以FPGA为代表的可重构器件既可以实现硬件任务的高速高效计算,又可以根据资源的使用情况对任务进行动态配置.在任务量较大.资源相对有限的条件下,采用灵活的任务调度算法可以充分利用硬件资源实现对关键任务的加速计算.所以,在可重构系统中,如何实时地对任务进行灵活调度以保持较高的资源利用率和在合理的时间范围内完成对硬件任务的计算,是当前研究的重点和难点之一[4].在可重构系统中,对硬件逻辑资源的管理以及对任务调度算法的设计必须建立在一定的可重构器件资源布局模型基础之上[4-5].目前可重构器件布局模型主要有两种:一维布局模型和二维布局[6-7]模型.这两种模型在Xilinx公司生产的FPGA中均有采用:如SpartanII、Vertex和VertexII采用的是一维布局模型,这些器件的可编程逻辑(重构)资源的配置均按列组织,最小配置单位是4个slice列,一维布局模型下的调度,只需在一维上考虑资源空间位置,若考虑任务配置、执行等因素,最多达到二维的复杂规模.国内外研究人员所设计可重构硬件任务调度算法一般基于一维布局模型[6-7].Xilinx公司的Virtex-4和Virtex-5系列FPGA采用的是二维布局模型.在二维布局的器件模型中,重构资源以二维矩形阵列的方式组织,重构的最小单位为矩形阵列中的一个逻辑单元,一个硬件任务占用阵列中的一个矩形区域,任务布局具有二维自由度.针对一维布局模型的调度算法时空关系简单,但由于内、外部碎片的存在,器件资源利用率普遍较低[7].基于二维布局模型的调度算法,可以实现任务的灵活放置,但考虑到硬件任务的启动、配置、执行、重定位等时间因素,调度算法和资源管理策略将变得十分复杂.针对实时可重构应用,本文提出了一种基于二维布局模型的任务调度算法,在保证任务调度灵活性的同时,提高了资源利用率,缩短了任务集运行时间.本文第2节分析相关研究;第3节对提出的调度算法DATS进行描述;第4节为实验及结果分析部分;第5节对算法的优缺点进行总结并提出了改进的方法和途径.2问题描述及相关工作图1所示为可重构系统的任务划分及调度模型,模型中的应用通过任务划分后被分配给软件和硬件功能部件分别进行处理.通过软件功能部件实现并处理的任务称作软件任务.通过硬件功能部件实现并处理的任务称作硬件任务.二维布局模型下的硬件任务是经过可编程逻辑器件内部布局布线后形成的长、宽固定且不可旋转的矩形逻辑单元块,通常由4个基本维向量犜(w,h,a,e)描述.其中,w、h分别代表硬件任务占用逻辑单元的宽和高,a是任务的到达时间,e是执行时间.软硬件任务的划分是一个NP完全问题[1-3].如图2所示,一个应用实例通过划分形成一个任务图[3],图中圆圈表示通过软件实现的任务,正方形表示需要用硬件实现加速的任务,分别用STi和HTi进行标识.本文只研究针对HTi的调度算法,对任务划分部分不作研究.Page3图1可重构系统任务划分及调度模型可重构系统[7]的硬件任务调度子模型主要包括主处理器和可重构器件两部分,主处理器上运行可重构操作系统,负责对硬件任务进行调度、布局和加载.任务到达处理器后被存储在一个队列中等待进一步处理.可重构资源的管理主要由运行在处理器上的布局器、调度器和加载器来完成.调度器的作用是为硬件任务分配资源和决定各任务的执行时机.布局器的工作方式如下:硬件任务犜(w,h)到达时,调度器询问布局器以确认逻辑器件上是否有足够的空闲资源空间.布局器根据参数w、h尝试分配空闲空间,若成功,则返回给调度器该任务可被布局的位置;若失败,则调度器按照一定的策略,将该任务放入等待队列或者拒绝该任务.布局成功时,调度器按照调度策略在合适的时机调度(布局)该任务,当硬件任务执行结束后,布局器回收该任务占用的空间.任务布局不合理会导致可编程资源碎片问题[7],理想的布局算法能够减少碎片的生成且任务能够得到最大并行化处理.可重构二维器件可以抽象为由H行、W列个可重构配置单元(RCU)组成的二维矩形阵列.调度算法的目的是将到达的任务在一定时间约束条件下映射到二维逻辑器件的合适位置上,同时保证资源高效利用,并尽可能完成任务.基于二维布局模型的任务调度比一维更关注实时性,因为二维逻辑器件下的任务调度因维数的增加会带来新的问题,突出的问题是任务启动、执行以及终止时间与二维空间布局协调的问题,解决该问题需要设计相应的布局算法与调度算法并协调其工作.对任务进行布局本质上是对可重构资源进行管理,主要有两种方式:空闲区管理方式和状态矩阵扫描方式.空闲区管理是通过记录空闲区域来管理资源,其中,最重要的方法是最大空闲矩形法(MER)[8],即记录一个互不交叠的空闲资源矩形列表,通过查找匹配的空闲资源矩形来获得硬件任务的布局位置;状态矩阵扫描方式通过维护一个记录可重构单元(RU)状态的矩阵来管理资源,通过扫描状态矩阵来查找硬件任务的可布局位置,其特点是可以做到资源完全识别,但时间开销较大.目前针对可重构计算硬件任务调度的算法主要是文献[6-7]提出的Horizon和Stuffing算法,这两类算法主要针对1D可重构器件模型而设计,Horizon算法的优点是维护SHL比维护器件所有可用空间要简单,缺点是该算法只能保证新的任务与其他链表任务满足时空不重叠约束条件时将任务插入RL,这样任务只可以放在horizon线的末尾,而在当前时间和interval之间分配的任务则不可能被调度,这会降低任务调度成功率.Stuffing调度算法基本思想是空闲区管理,主要针对1D资源模型,引入了时间维对任务进行调度和布局,算法在调度中对未来资源的利用情况提前规划,是一种较为有效的Page4算法.该算法利用模拟将来时刻任务启动与终止的方法来确定预约任务的启动时间,调度算法与布局算法关联较弱.Stuffing算法采用FSL记录当前未被使用的资源,并按照资源维度值递增排序,与Horizon算法相比,Stuffing由于必须识别所有潜在布局空间并且检查这些潜在空间与已存在于RL中空间是否冲突,所以复杂度较高.此外文献[9-10]还提出了针对二维布局模型的Yoo和CR算法,CR算法是QA[5]布局算法的三维扩展,其时间复杂度与Yoo一样,均为O(G(E+R)),其中,G=W×H是RCU的总数,E是正在运行的任务个数,R是算法预约任务的个数.文献[11]提出了针对一维和二维均可适用的任务间最小空隙调度算法(MGS),该算法借助任务投影和调度代价函数,采用二维时空坐标系协调各硬件任务占用的芯片资源和执行时间.Yoo、CR和MGS不是单纯的调度算法,同时具有布局功能,因此调度与布局过程独立性较差,不利于灵活选择布局策略以提高系统性能.针对二维布局模型的算法主要是从分布式多处理系统(如网格互连并行计算系统[12])中的调度算法演变而来,表1列出5种算法,并给出了算法的分配复杂度[10]和空间复杂度.其中,N表示被调度任务数.调度算法时间复杂度布局算法分配复杂度空间复杂度Horizon[6]O(N)OTF[7]O(E)O(E)Stuffing[7]O(N2)BL[12]O(E3)O(E)Yoo[9]O(G(E+R))FF[13]O(N)O(N)CR[10]O(G(E+R))RBL[14]O(E2)O(E)MGS[11]O(N2)KVIT[15]O(E2)O(E)文献[16]中的调度算法首先为缓冲队列中的硬件任务指定优先级,然后按优先级依次执行任务,但是在离线状态指定优先级本身不符合实时性要求,因而不支持实时调度,且该方案的资源利用率较低.文献[17]提出一种调度和布局相结合的算法,虽能降低布局产生的开销,但在调度方面对任务接收率和资源利用率的改善较小.Stuffing算法主要针对一维布局模型,引入了时间维对任务进行调度,算法在调度中对未来资源的利用情况提前规划,是一种较为有效的算法.该算法利用模拟将来时刻任务启动与终止的方法来确定预约任务的启动时间,这样调度算法与任务布局算法关联较弱,相对独立.另外,Stuffing算法主要对任务的时间属性从调度方面进行着重考虑,结合二维布局模型的布局算法OTF则容易引起布局错误[10],与RBL算法结合的时间复杂度为O((E+R)3).文献[9]将二维网格多处理器系统中的任务调度方法与基本的扫描类布局算法结合,同样引入了预约的概念,通过对未到达的任务预约子区域来实现调度,由于预约的区域不能被新任务占用,会导致资源利用率下降.其它与文献[6,9]类似的算法不管是预约任务还是预约区域,均对任务启动、终止时间等信息的有效使用依赖较大,常出现预约任务不是最佳目标任务和预约区域闲置的情形,导致调度成功率(命中率)和资源利用率降低.Horizon[6]调度算法将文献[9]中的预约概念引入空闲区管理,但是引入预约之后,OTF等简化算法不再适应,且文献中并没有提出高效的空闲区管理算法,因而不能被有效实现.本文的研究是基于FPGA可重构SOC,在实时性方面要求较高,而且基于2D资源模型的调度和布局比1D模型具有更好的灵活性,在这些方面Horizon和Stuffing算法显然可以满足需求,但是这两种算法在布局策略方面均采用BF(BestFit),BF策略基于为后续任务预留更多空间的思想,在调度时总是选择可布局空间中最小的空间放置任务,增加了时间复杂度;采用FF(FirstFit)策略将任务放置在首次搜索到的可布局空间中,减少了搜索和寻优时间,同时符合紧凑原则,同样可以为后续任务预留足够空间,在调度效果上不一定逊色于BF.另外,Horizon和Stuffing算法在空间布局时未考虑二维模型的灵活性,盲目搜索空间放置任务,使任务在空间布局上容易产生冲突,因此设计一种算法减少布局冲突并缩短搜索时间是可行的.图3所示为两种不同布局策略下的布局效果.图3(a)采用BF策略,在任务放置T1后,任务T2紧贴T1放置在最右边,无论是采用Horizon还是Stuffing算法,T3到达时均按照图3(a)效果放置;图3(b)采用了放置方向决策布局策略,降低了任务冲突概率,在任务T1被放置后,任务T2既可沿X轴放置,也可沿Y轴方向放置,通过决策将T2沿Y轴方向放置,接着T3同样放置;任务T4到达后采用BF布局策略会引起冲突,而采用方向决策的布局策略则可以成功放置,显然图3(a)布局方法导致空闲区域分割较小且不连续,不利于后续任务的布局,而图3(b)通过对空闲区边界大小的决策来不断按照X轴方向和Y轴方向放置,降低了任务冲突的概率,使区域在右上角方向保持连续,有利于后续任务放置.Page5图3两种不同布局策略放置效果本文在软硬件划分结果基础上,提出了一种适用于2D可重构器件模型的双仲裁时间片硬件任务调度算法DATS(DoubleArbitersTime-Sliced),采用两个仲裁器对可重构器件资源进行管理,并根据空间和时间约束条件动态裁决任务布局位置;同时设计了双仲裁时间片任务调度模式图,对任务的调度和布局过程进行合理分离,使任务调度和布局过程相对独立并简化处理过程.DATS算法的调度时间复杂度为O(N),单任务布局算法的时间复杂度为O(E),实验表明,DATS算法时间开销小,在轻负载情况下任务调度成功率高,在重负载情况下资源利用率与时间复杂度为O(N2)的算法基本一致,适合于实时情况下的任务调度.3DATS:双仲裁时间片任务调度算法DATS算法通过两个仲裁器对任务的放置位置和执行时间进行动态约束和裁决,从而实现对硬件资源的管理.算法主要引入仲裁器和时间片两个概念,与二维可重构硬件调度模型相结合共同构成基于双仲裁策略的时间片调度模型.算法的执行过程依赖于双仲裁时间片调度模式图.下面首先对双仲裁调度模式图的构建和相关概念进行介绍,然后详细介绍DATS算法.调度算法的设计基于以下5点假设:(1)经过划分后的硬件任务属性集合为{w,h,ta,ts,te,p,s},其中,w、h分别为任务所需矩形区域的宽和高,矩形区域由若干可重构计算单元(RCU)组成.ta表示任务的最早启动时刻,ts表示任务最晚启动时刻,te为任务的执行时间,p为任务的优先级,s为任务所处的状态.(2)调度与布局算法建立在软硬件任务划分方法基础上,但对具体的划分算法不产生依赖,划分算法只要能够产生满足(1)中调度与布局输入任务集属性要求即可,任务执行时只需在合适的时间将配置信息装载到可编程逻辑器件上.(3)调度算法只考虑硬件任务何时开始执行以及何时结束,不考虑软硬件通信耗时问题,软硬件通信耗时由软硬件划分算法考虑.算法涉及的一些符号和概念定义如下.定义1.时间片(Time-Slice)和关键帧(Key-(4)2D可重构资源模型下的任务抽象为不可旋转和平移的矩形区域,不考虑任务间互连导线占用的空间开销.(5)同一启动时间的任务在布局时有先后差别,但延时为零,即同时启动执行的任务,一个任务首先分配资源,同时另一个任务也分配资源,两次分配有先后之分,但是在时间上认为是同一时刻进行资源分配.3.1双仲裁时间片调度模式图双仲裁时间片调度模式图由三部分组成,分别是时间片模式子图,B-Arbiter仲裁记录模式子图和P-Arbiter记录模式子图.如图4所示,时间片模式子图由水平方向的两条时间轴和垂直方向若干关键帧组成,其中一条时间轴是开始时间轴,用来标记任务的启动执行时间;另一条时间轴是结束时间轴,用来标记任务的结束退出时间,关键帧上有任务起始队列和任务终止队列,分别表示同一时刻任务启动执行的顺序和任务结束退出的顺序.B-Arbiter仲裁记录模式子图由X-D和Y-D两项记录组成,每项记录由一条时间轴和对应关键帧的动态变化任务边界值组成.P-Arbiter记录模式子图由对应关键帧的一组任务位置信息节点组成,每个节点除了记录任务的编号外,还记录了任务在二维器件中执行时的位置,这些节点信息会随着任务状态的改变动态添加或删除.Page6图4双仲裁时间片调度模式图Frame,KF).DATS算法中时间片是硬件任务执行所需的最小时间单位,一个时间片的大小叫间隔(interval),任何一个任务执行时间必须是时间片的整数倍.时间片的大小通过任务起止时间归整获得.关键帧是两个时间片相邻的时刻点,硬件任务的启动和结束必须在关键帧处完成.图4中关键帧用虚线表示,并在最上方用数字标注.定义2.任务起止时间归整.通常研究中,一个可重构硬件任务被定义为犜(w,h,ta,ts,te,p,s),满足条件ts>ta.本文引入Δt,且令Δt=ts-ta,Δt称作任务启动松弛时间,任务执行结束时间tend=ta+te,各时间的关系如图5所示.DATS算法要求任务的启动和结束必须是在关键帧处完成,所以必须对任务的开始执行时刻以及执行时间做归整处理,解决该问题时间片间隔值interval的选取十分重要.记IN={0,1,2,…,N},N为调度任务总数;tcycle为初始设置的任务执行最小时间单位,设置为FPGA芯片的一个时钟周期;若i,i∈IN,tcycleTi.ΔtTi.te,则interval=min{Ti.Δt|i∈IN};若i,i∈IN,Ti.Δt<tcycle∩Ti.te<tcycle,则interval=tcycle;否则,取interval=min{min{Ti.te|i∈IN},min{Ti.Δt|i∈IN}}.经过归整处理,任何一个具有启动松弛时间的任务都可以在归整时保证开始执行时刻落在关键帧处,而且执行时间也可以归整为间隔的整数λ倍.在精度允许范围内,间隔interval值也可以选取更小的值,在DATS算法中interval值会影响执行时间所占的间隔数λ,由于interval值选取的是所有被调度任务中启动松弛时间或执行时间的最小值,任务时间参数做归整时不一定刚好取到一个整数,所以随着interval值的改变,λ值会发生变化,对调度效果也会产生一定影响,但通过计算可知这种影响是微乎其微的,原因在于interval取值变小,λ取值会变大,但是任务的启动松弛时间和执行时间基本不会改变.定义3.任务起始点和任务终止点.在双仲裁时间片调度模式图中(图4所示)用空心小圆圈表示任务起始点,在有任务加载的关键帧处,各个任务起始点按照从上到下的顺序排列,这个排列顺序称作任务起始队列,它代表了任务被分配资源后在可重构器件中布局的先后次序.在双仲裁时间片调度模式图中(图4所示)用实心小圆圈表示任务终止点,在有任务执行结束的关键帧处,各个任务终止点按照从上到下的顺序排列,这个排列顺序称作任务终Page7止队列,它代表了任务在可重构器件中执行结束并释放资源的次序.定义4.双仲裁器.双仲裁器包括位置仲裁器(PositionArbiter)和边界仲裁器(BoundaryArbiter),分别记作P-Arbiter和B-Arbiter.双仲裁器不是硬件实体,而是算法中的角色,其作用类似于篮球比赛中的主裁和边裁,两个仲裁器均在关键帧处对发生的事件进行记录,实现对硬件任务的调度和布局.B-Arbiter记录共包括X-D和Y-D两项,用于记录任务边界的变化情况,以X-D为例,在关键帧处,每当有任务启动执行,并占用二维器件空间时,该任务在X维方向产生的新右边界就被记录下来,同样,每当有任务结束退出,并释放二维空间时,所释放任务在X维方向的右边界就要从记录中删除,不对左边界作记录是因为DATS算法决定了任务每次放置必须是紧贴正在执行任务的右边界,这些边界在之前均已经记录.在X-D和Y-D记录中,设置有X-top和Y-top两个指示,它们在任务放置方向决策时,与二维器件规模W(宽度)和H(高度)参数一起为放置决策提供依据,结合图3可知,对X-top和Y-top的灵活使用可以避免任务冲突,减少搜索次数,提高任务调度成功率,甚至可以均衡器件区域的使用频度,避免一个局部区域不断被高频次编程使用而导致可重构器件损坏.DATS算法中X-top和Y-top的确定原则如下:(1)X-top取值为X-D记录中除器件边界值W和所有失败指示边界值后的最大值.(2)Y-top取值为Y-D记录中除器件边界值H和所有失败指示边界值后的最大值.其中W、H为二维逻辑器件的边界值,失败指示边界值指X-top或Y-top不能够成功指示任务放置位置的边界取值.DATS放置方向决策函数如式(1)所示.decisionV(X-top,Y-top)1,X-top采用常规算法进行任务布局时会得到多个可放置位置,而且会造成资源冲突,影响调度成功率,为解决这一问题本文引入了放置方向决策函数来对任务优先沿X轴方向放置还是沿Y轴方向放置进行决策.decisionV函数取值为1时表示沿X轴方向放置,取值为0时表示沿Y轴方向放置,该函数充分利用X-top和Y-top指示任务布局位置,在器件规模有限的情况下,可以降低任务冲突概率,节约搜索时间,提高调度成功率.P-Arbiter用来记录每个正在执行的任务在二维器件中的放置位置,任务位置由矩形的左下角和右上角两个坐标点来确定,每当有任务进入执行,P-Arbiter就在记录中增加一项位置记录,每当有任务执行结束退出时,就从记录中删除相应的位置记录.双仲裁器与时间片的配合使用可以实现对任务的实时调度.定义5.任务状态与任务优先级.任务状态是任务的属性之一,用S表示,任务状态集为其中,IDLE表示任务处于未调度空闲状态,EXE表示任务处于执行状态,WAIT表示任务被调度后布局失败处于重新等待状态,FIN表示任务被调度后成功布局处于执行完毕状态.在程序实现时,使用枚举类型定义任务状态集合,IDLE、EXE、WAIT和FIN分别对应整数值0、1、2和3.任务优先级也是任务的属性之一,在软硬件划分阶段确定,基本方法是在生成任务集时按照优先级进行拓扑排序并编号,值越小的任务优先级越高.双仲裁时间片策略下的抢夺式调度是指在同一关键帧任务起始队列中,高优先级的任务可以排在低优先级任务之前优先布局,同优先级的任务按照调度队列编号顺序进行布局.3.2任务的优先级和状态转换任务调度存在两种情形:一是有串行关系的任务,按照先到先处理的原则处理,在算法中用任务编号进行区别,编号小的比编号大的优先处理;另一种是有并行关系的任务,如图2所示的任务HT1和HT2,二者不存在直接的串行制约关系但是在布局分配资源时,需要根据任务的紧急程度或时间松弛限制赋予高优先级,这样,在DATS算法所定义的关键帧处,高优先级的任务在调度排序时可以剥夺低优先级小编号任务调度权而被优先放置,这样有利于任务的成功放置.在DATS算法中,如定义5所示,可重构系统任务调度共涉及4种状态,分别是IDLE、EXE、WAIT和FIN,任务状态转换图如图6所示.Page8结合图1所示硬件任务调度与布局模型可知,若干任务到达后,形成处于IDLE状态的未调度队列,调度器通过调度算法对任务进行调度,调度算法与布局算法必须协调工作,被调度的任务只有在可重构硬件中布局成功才能够算作成功调度,否则为失败调度.处于IDLE状态的任务被调度后若布局成功则转入EXE状态,在可重构硬件中执行;若布局失败,则失败的任务转入WAIT状态;当终止时间到达时,处于EXE状态的任务执行完成转入FIN状态.一般有两种情况会导致任务布局失败,一种是同一时刻布局任务较多导致资源不足,一种是资源充足但是较为分散未形成可容纳矩形任务的资源区域,通过任务重定位后,任务仍然可以成功布局,因此处于WAIT状态的任务经过重定位或延迟后在调度可以转入EXE状态,继而转入FIN状态完成执行.最简单的重定位方法就是将失败调度的任务重新排队等待调度,如此反复,直到所有任务调度完毕.3.3任务调度指标(1)器件负载率.器件负载率指要加载到器件的所有任务所需空间资源总量与器件可提供资源量的比值,其计算公式如式(2).其中wi、hi分别表示任务Ti占据矩形资源化区域的宽和高,W和H表示二维逻辑器件的宽和高.与1D资源模型不同,后者因为扩展使用了时间维度,器件负载率的定义通常与任务执行时间有关,其本质都是二维坐标下器件的负载情况的反映.(2)调度成功率.任务调度成功率指成功调度的任务与被调度到达器件的任务总数之比,计算公式如式(3).其中,K为任务调度成功率,SucN表示被成功调度的任务数目,num表示被调度的任务总数目.(3)资源利用率.在处理1D可重构器件模型的布局问题时,引入时间维作为纵坐标轴,而过去的时间是不可利用的,因此资源利用率作为衡量指标显得格外重要,而在2D可重构器件模型下,布局算法不再引入时间作为坐标轴即空间可被重复利用,因此资源利用率的重要性降低,但是单位时间内资源利用情况可以反映任务并行执行潜能,因此仍具有指导意义.资源利用率指在一段时间内,可重构逻辑器件上被占用的计算资源面积与器件总面积比例的平均值.单位时间内资源利用率计算公式如式(4)所示.其中,m为在每一时间片内,位置仲裁器中所记录的正在执行的硬件任务的数目.3.4约束条件本的时间和空间约束条件,定义如下:在任务调度和任务布局的过程中,必须满足基(1)时间约束.调度任务集χ={T1,T2,…,TN}中,每个任务均具有时间属性{ta,ts,te},这些时间属性在时间坐标轴上的位置被限制在一定区间或固定时刻点处,约束条件如式(5)所示.i,1i,jN,Ti,Tj∈χ,Ti.ts+Ti.teTj.ts∪Tj.ts+Tj.teTi.ts(5)(2)空间约束.基本的空间约束条件包括任务不重叠约束和资源边界约束,如式(6)和式(7)所示.①任务不重叠约束.假设任务Ti所占据的矩形空间位置用矩形的左下角坐标(Ti.x1,Ti.y1)和右上角坐标(Ti.x2,Ti.y2)唯一确定.器件中处于执行状态的任务集为{T1,T2,…,Tk},待放置任务为Tj,则任务不重叠约束条件如式(6)所示.i,1ik,Ti.x1Tj.x2∪Tj.x1Ti.x2∪②资源边界约束.假设二维逻辑器件规模为W×H,待放置任务为Tj,则资源边界约束条件如式(7)所示.T犼.x10∩Tj.y10∩Tj.y2H∩Tj.x2W3.5算法描述在软硬件划分阶段任务起止时间均为浮点数,DATS算法实现时需要指定时间递增步长最小单位,因此在对任务调度前需要完成任务起止时间归整处理.DATS算法包括调度算法和布局算法两部分,下面对DATS算法进行详细描述.(1)任务起止时间归整给定一组硬件任务集HT={HT1,HT2,…,HTN},且每个任务HTi均可表示为向量(w,h,ta,ts,te,p,s),其中w、h分别为任务所需矩形区域的宽和高,矩形区域由若干个可重构计算单元(RCU)组成.ta表示任务的最早启动时间,ts表示任务的最晚启动时间,te为任务的执行时间,p为任务的优先Page9级,s为任务所处的状态.任务起止时间归整算法Timeinteger描述见算法1.算法1.Timeinteger(HT)1.interval←0;tmin2.foralli∈INwithIN={2,…,N}do3.HTi.Δt←HTi.ts-HTi.ta;4.if(HTi.Δt<Δtmin)then5.Δtmin←HTi.Δt;6.endif7.endfor8.foralli∈INwithIN={2,…,N}do9.if(HTi.te<tmin10.tmin11.endif12.endfor13.interval←min{tmin14.if(interval<tcycle)then15.interval=tcycle;图7Timeinteger算法流程归整处理根据单次调度任务集中各任务的启动松弛时间和执行时间,从全局的角度来对每个任务的开始和执行时间进行归整,从Timeinteger伪代16.endif17.foralli∈{1,2,…,N}do18.Ti.ta←HTi.ta/interval;Ti.ts←HTi.ts/interval;19.Ti.w←HTi.w;Ti.h←HTi.h;Ti.p←HTi.p;20.endfor21.returnT;在Timeinteger算法中,第1步:初始化各变量参数,第2步:求取任务松弛时间最小值(第1个for循环),第3步:求取任务执行时间最小值(第2个for循环),第4步:求取interval值,第5步:生成归整后任务集T={T1,T2,…,TN},且每个任务均具有属性{w,h,ta,ts,te,p,s},ta为归整后任务最早启动时间,ts为归整后任务最晚启动时间,te为归整后任务的执行时间,p为归整后任务的优先级,s为归整后任务所处的状态,其中p和s均保持原值.算法流程如图7所示.码描述易知,算法时间复杂度为O(N).(2)任务调度算法2为双仲裁时间片任务调度算法的伪代码Page10描述.算法2.DATS_Scheduler(T).1.X-top←0;Y-top←0;t=1;Q←NULL;2.B_arbiter[0][0]←0;B_arbiter[0][1]←0;3.P_arbiter←NULL;tmaxend←0;4.foralliwith1i<taskNumdo5.B_arbiter[i][0]←-1;B_arbiter[i][1]←-1;6.Ti.tend←Ti.ts+Ti.te;7.if(Ti.tend>tmaxend)then8.tmaxend←Ti.tend;9.endif10.endfor11.while1ttmaxenddo12.foralliwithTi∈T,1i<taskNumdo13.if((Ti.tend=t)and(Ti.s=EXE))then14.deleteTiFromP_arbiter;15.B_arbiter[i][0]←-1;B_arbiter[i][1]←-116.setX_top;setY_top;17.endif18.endfor19.foralliwithTi∈T,1i<taskNumdo20.if((Ti.tatTi.ts)and21.enQueue(Q,Ti)22.SelectTjfromQwhereTi.pisthehighest23.if(P_arbiter=NULL)then24.if(Tj.wMandTj.hN)then25.tempP.taskid←Tj.taskid;26.Tj.s←EXE;27.B_arbiter[i+1][0]←Tj.w;28.setX_top;setY_top;29.insertnodetempPintoP_arbiter;30.elseTj.s←WAIT;31.endif32.else33.d=decisionBy(X-top,Y-top);34.DATS_place(Tj,d);35.endif36.endif37.endfor38.t++;39.endwhile在DATS_Scheduler算法中,第1步:初始化位置仲裁记录P_arbiter和边界仲裁记录B_arbiter值,P_arbiter初始为空,B_arbiter是一个二维数组,记录执行任务产生的边界值,一维下标对应任务编号,二维下标值为0和1时记录任务产生的上边界和右边界,初始无任务执行,边界指向(0,0)点.第2步:计算所有任务最晚截止时间作为调度和布局的时间片阈值,超过阈值仍不能够成功调度的任务则为调度失败任务.第3步:实现时间片控制.算法在时间片控制中,第1步:实现任务的删除,在算法中对满足结束执行条件的任务先进行删除,这样可以增加后续任务布局的成功率,否则,会降低任务调度成功率,执行完毕的任务从P_arbiter中删除位置信息,从B_arbiter中删除边界信息.setX_top函数实现将X-top滑动到边界记录中除去M值的最大值处,setY_top函数实现将Y-top滑动到边界记录中除去N值的最大值处,当有新任务载入可重构器件执行时,两个函数更新X-top和Y-top以供后续任务进行布局时进行放置方向决策.第2步:对到达和等待的任务进行排队,第3步:从中选取优先级最高的任务进行布局,初始时可重构器件没有任务执行,根据紧凑原则,第1个任务放置在(0,0)处,同时更新位置仲裁记录和边界仲裁记录,并滑动X-top和Y-top,布局不成功的任务转入WAIT状态.如果非第1个任务的后续任务,采用方向决策函数式(1)进行计算,通过变量d传给布局函数DATS_place进行布局,该布局算法通过对两个仲裁记录的分析,将要执行的任务T放置到二维空间中,其本质是为任务分配资源.算法流程如图8所示.DATS_Scheduler算法执行一次,完成对任务集中任务的调度,每个任务的调度根据约束条件完成启动和结束,时间复杂度为O(N).部分,算法3用伪代码对其进行了描述.(3)布局算法布局算法DATS_place是调度算法的重要组成算法3.DATS_place(Ti,decision).1.k←length(P_arbiter)2.if(decision==1)3.forallxxfromtaskNumto1with(X_D[xx]≠4.foralliifrom1totaskNumwith(Y_D[xx]≠5.clashflag1←0;6.TR[k]←[(X_D[xx],Y_D[ii]),7.foralljwith0j<kPage11图8DATS_Scheduler算法流程8.if(!constraint1(TR[k],TR[j])or9.clashflag1←1;break;10.endif11.endfor12.if(clashflag1==0)13.structnodep←TR[k];14.insertpintothetearofP_arbiter/将成15.B_arbiter[i+1][0]←X_D[xx]+Ti.w;16.setX_top();setY_top();17.return1;//放置成功直接退出18.endif19.endfor20.endfor21.if(clashflag1=0)return1;endif22.else23.forallyyfromtaskNumto1with(Y_D[yy]≠24.foralljjfrom1totaskNumwith(X_D[jj]≠25.clashflag2←0;26.TR[k]←[(X_D[jj],Y_D[yy]),27.foralljwith0j<k28.if(!constraint1(TR[k],TR[j])or29.clashflag2←1;break;30.endif31.endfor32.if(clashflag2==0)33.structnodep←TR[k]34.insertpintothetearofP_arbiter/将成功35.B_arbiter[i+1][0]←X_D[jj]+Ti.w;36.setX_top();setY_top();37.return1;//放置成功直接退出38.endifPage1239.endfor40.endfor41.if(clashflag2=0)return1;endif42.endif43.return-1;DATS_Place算法根据调度算法中第33行放置方向决策函数值完成对任务Ti的布局,任务布局成功则返回1,并将位置信息记录在P_arbiter中;任务布局失败则返回-1.在算法伪代码描述中,第2行和第22行通过对放置方向决策函数值的判断对任务进行资源分配,由式(1)知,决策函数值为1时沿X轴方向放置任务;函数值为0时沿Y轴方向放置任务.根据放置方向不同分别处理的两部分代码是类似的,以decision值为0(即沿Y轴放置)进行分析和说明.从调度模式图中可知X-D和Y-D分别是边界仲裁B_arbiter中对所有正在执行任务的右边界和上边界的记录,23~24行只在记录中包含的边界处进搜索可布局的位置,这样减少了对空闲区域的搜索时间,时间复杂度为O(E2),E为Y-D和X-D中记录图9DATS_Place算法流程数目的最大值,即器件正在执行的任务的最大数目.第27行和第28行检查第26行预设矩阵区域是否满足式(6)和(7)的约束条件,不满足则将冲突标志设置为1,重新搜索;满足则将任务载入可重构器件执行,并将位置信息插入P_arbiter中,32~34行完成了这一功能.新任务加载后,35~36行对边界仲裁记录B_arbiter进行更新,并滑动X-top和Y-top,以备后续任务被调度时进行布局决策.DATS_Place算法具体如图9所示:第1步:获取正在执行的任务数;第2步:根据方向函数决定任务布局方向;第3步:按照任务放置方向,搜索可满足放置约束条件的位置,放置任务:①搜索边界记录中可放置的位置;②检查放置位置是否满足约束条件1和2;③若满足,则放置成功,将放置任务添加到位置记录中,并更新边界记录信息,滑动X-top和Y-top;若不满足,则放置失败,返回①继续搜索;④找不到合适的放置位置,则返回放置失败(return-1).特别地,当任务集中矩形任务w、h值均取1时,算法效果会达到最优,但是此时算法的耗时将达到最大.Page133.6调度实例本小节通过一个任务集调度实例来具体介绍双仲裁时间片调度模式图的原理和仲裁调度过程,以方便了解DATS算法所使用的数据结构及算法效率.给定一组已经划分好的硬件任务,如表2所示.任务whtatstepsTASK1122111IDLETASK2343442IDLETASK3252321IDLETASK4333421IDLETASK5434431IDLETASK6224521IDLE假设二维逻辑器件为W×H阵列,W=9,H=10.初始时,B-Arbiter仲裁记录中X-D和Y-D均写入记录0,P-Arbiter仲裁记录初始为NULL.当KF=1(图10(a))时,任务T1{1,2,1,1,1,IDLE}进入,B-Arbiter的X-D记录(图11)中增加图11B-Arbiter仲裁记录模式图图12P-Arbiter仲裁记录模式图当KF=2(图10(b))时,任务T1退出,同时任务T3{2,5,2,2,1,IDLE}进入,按照退出任务优先的原则,T1先退出,然后任务T3再进入,这样有利于资源的充分利用.T1退出,B-Arbiter的X-D记录(图11)中删除边界记录值1,Y-D记录中删除边界记录值2,此时,X-top=0,Y-top=0.同时从P-Arbiter记录(图12)中删除任务T1的位置[(0,0),(1,2)].T3进入,通过公式(式(1))计算结果来决策放置方向,显然X-top/W=Y-top/H=0,X维方向优先放置,所以T3放置位置为[(0,0),(2,5)],P-Arbiter记录中增加任务T3位置记录边界记录值1,Y-D记录中增加边界记录值2,此时,X-top=1,Y-top=2.同时P-Arbiter记录(图12)任务T1放置位置T1[(0,0),(1,2)].T3[(0,0),(2,5)],B-Arbiter的X-D记录中增加边界记录值2,Y-D记录中增加边界记录值5,此时,X-top=2,Y-top=5.当KF=3(图10(c))时,任务T2{3,4,3,4,2,IDLE}和T4{3,3,3,2,1,IDLE}进入,任务T2的优先权比T4大,按照同时到达优先权值大的任务优先放置的原则,先对任务T2分配资源.T2进入,通过公式(式(1))计算结果来决策放置方向,显然X-top/W=2/9<Y-top/H=5/10,X维方向优先放置,搜索X-top边界上的可放置点,即固定X-top=2,P-Arbiter通过Y-D项记录来寻找可放置任务的Page14位置点作为任务的左下角位置,此时Y-D中记录为0、5,(2,0)处可放置,故任务T2放置位置为[(2,0),(5,4)],在P-Arbiter记录中增加任务T2位置记录T2[(2,0),(5,4)],B-Arbiter的X-D记录(图11)中增加边界记录值5,Y-D记录中增加边界记录值4,此时,X-top=5,Y-top=5.紧接着任务T4进入,通过公式(式(1))计算结果来决策放置方向,显然X-top/W=5/9>Y-top/H=5/10,Y维方向优先放置,搜索Y-top边界上的可放置点,即固定Y-top=5,P-Arbiter通过X-D项记录来寻找可放置任务的位置点作为任务的左下角位置,此时X-D中记录为0、2、5,(0,5)处可放置,故任务T4放置位置为[(0,5),(3,8)],在P-Arbiter记录(图12)中增加任务T4位置记录T4[(0,5),(3,8)],B-Arbiter的X-D记录中增加边界记录值3,Y-D记录中增加边界记录值8,此时,X-top=5,Y-top=8.当KF=4(图10(d))时,任务T3{2,5,2,2,1,FIN}退出,同时任务T5{4,3,4,3,1,IDLE}和T6{2,2,4,2,1,IDLE}进入,按照退出任务优先原则,T3先退出,然后任务T5和T6依次进入开始执行.T3退出,从P-Arbiter记录(图12)中查找任务T3的位置为[(0,0),(2,5)],T3的退出会造成边界值的变化,根据P-Arbiter的记录B-Arbiter可以确定删除的边界值,故B-Arbiter在X-D记录中删除边界记录值2,Y-D记录中删除边界记录值5,此时,X-top=5,Y-top=8,然后,P-Arbiter从记录中删除T3的信息.T5进入,通过公式(式(1))计算结果来决策放置方向,显然X-top/W=5/9<Y-top/H=8/10,X维方向优先放置,搜索X-top边界上的可放置点,即固定X-top=5,P-Arbiter通过Y-D项记录来寻找可放置任务的位置点作为任务的左下角位置,此时Y-D中记录为0、4、8,(5,0)处可放置,故任务T5放置位置为[(5,0),(9,3)],在P-Arbiter记录中增加任务T5位置记录T5[(5,0),(9,3)],B-Arbiter的X-D记录(图11)中增加边界记录值9,Y-D记录中增加边界记录值3,此时,X-D记录中出现W值,故X-top取记录次小值5,故X-top=5,Y-top=8.紧接着任务T6进入,通过公式(式(1))计算结果来决策放置方向,显然X-top/W=5/9<Y-top/H=8/10,X维方向优先放置,搜索X-top边界上的可放置点,即固定X-top=5,P-Arbiter通过Y-D项记录来寻找可放置任务的位置点作为任务的左下角位置,此时Y-D中记录为0、4、8、3,(5,3)处可放置,故任务T6放置位置为[(5,3),(7,5)],在P-Arbiter记录中增加任务T6位置记录T6[(5,3),(7,5)],B-Arbiter的X-D记录中增加边界记录值7,Y-D记录中增加边界记录值5,此时,X-top=7,Y-top=8.KF=5时,任务T4退出,双仲裁记录删除相应信息;同样,KF=6时T6退出;KF=7时T2和T5依次退出.在DATS算法中,B-Arbiter和P-Arbiter两个仲裁器通过相互协作对任务进行实时调度,它们记录的数据均具有动态变化的特点,从这一点考虑采用线性链表的数据结构对数据进行存储和增删改查等处理比较合适,但是在可重构实时调度系统中,算法查找时间应该尽量小,且时间因素应当被优先考虑,为了实现对数据迅速查找和定位的功能,B-Arbiter和P-Arbiter仲裁记录应当采用数组数据结构,数组的初始开辟空间会大于链表,但在记录数目动态增加到最大值时,即使是链表也需要开销和数组等同的空间,而且空间不连续,采用指针管理还会增加算法实现的复杂性.因此,在DATS算法中B-Arbiter采用数组结构,P-Arbiter采用动态链表结构.4性能评价4.1实验建立参照文献[7]中的实验模型,可重构器件按照XilinxVirtexXCV1000规模定义,采用96×64=6114个RCU,随机生成模拟任务数据,为了便于对比,参照文献[10]将任务按照面积分为4类,分别记作C10、C30、C40和C50.Cn的宽度和高度在区间[5,n]内均匀分布.任务运行时间在[5,50]个时间单位内均匀分布.任务开始执行时间在[1,100]个时间单位内均匀分布.生成100组任务,每组任务有1000个,多次统计后,结果取平均值.在针对1D可重构器件模型的任务调度与布局研究中,由于建模时扩展使用了时间维度,在对算法指标进行评价时,通常将负载率作为参变量,其他为因变量,而在2D可重构器件模型中,以负载率为参变量会限制任务集合的灵活生成,不利于算法的充分测试,因此实验采用任务规模作为因变量,对算法指标进行衡量和评价.任务规模与器件负载率的关系如图13所示.由图13可见,同一任务规模下的器件负载率随着任务占用空间大小的递增而增大;同一类占用空间大小的任务,器件负载率随着任务规模的递增而增大.Page154.2调度成功率对比给定器件大小时,任务规模对任务的调度成功率影响很大,因而通过任务规模来衡量任务调度成功率十分重要.实验将不同的任务规模的测试用例均赋以空间占用大小属性,共分C10、C30、C40和C504类.参与比较的算法有Horizon、Stuffing和图14性能对比对图14各类任务进行类间对比,可见,随着器件负载率的增加,各类算法的调度成功率也呈现下降趋势.4.3资源利用率分析DATS算法通过对位置仲裁器记录数据的运行时计算可以很容易统计每个时间片内的资源利用率,方便对整个算法在资源利用率方面的性能分析,适合于实时监控的情况.由于C10类任务在负载任务数为5~60间负载率均小于1,在资源利用率评价上不具有参考意义.实验只对负载率大于1的任务集进行测试.图15显示了DATS算法在各类任务测试时可重构器件处于任务稳定执行状态时的各时间片内平均资源利用率情况,虚线显示了不同类任务时,资源利用率的稳定情况,结果表明,DATSDATS算法,在这3个算法中,Horizon算法采用BF布局策略,每一个任务到达时总是寻找最大的空闲区域进行布局;Stuffing采用FF布局策略,只要搜索到任务可放置空间即完成布局.在C10类统计中,各算法调度成功率比较如图14(a)所示,由图13可知这类任务负载率均低于1,因此3个算法均具有100%的调度成功率;在C30、C40和C50类统计中,Horizon算法因按照最优策略识别最大空闲矩阵,而在任务宽与高约束上不一定满足式(6)和(7),所以调度成功率较低;Stuffing和DATS均采用FF布局策略,任务调度成功率较高,随着负载任务数的增加,Stuffing和DATS调度成功率会有所下降,但是DATS因采用了放置方向决策的布局策略,一定程度上避免了任务在空间上的冲突,比Stuffing具有更高的调度成功率.算法在最好情况下的资源利用率保持在0.8左右,而在任务全加载情况下,负载率会达到7左右,可见DATS在高负载情况下仍能保持很高的资源利用率.图15各类任务下不同关键帧处的资源利用率图15显示,在任务集为C50时,在51~56时间片处,资源利用率首先下降然后又迅速提升,这是大Page16面积任务在实时调度时常见的抖动问题,存在这样的问题是因为随机生成的任务集中任务面积约束在较大范围内,C50类任务的面积80%在50~1250之间,在96×64器件规模下,大面积任务在51~56时出现大量执行完毕随即又有大量任务加载的情况,所以资源利用率会出现曲线抖动,要避免抖动发生就要杜绝大量大面积任务集中加载集中结束的情况发生,实验时为了便于分析对所有任务采用同一类面积分配,在任务调度时可以对任务在面积大小上进行适当糅合.值得说明的是,这里的抖动不是任务退出又被重新调用发生的抖动问题,大任务与相对较小任务调度产生的抖动属于任务划分的范畴,而传统意义上的抖动属于调度优化问题.4.4算法运行时间比较算法在2.4GHzPentuim4PC机上通过标准C++实现,对比算法有Horizon、Stuffing和FF算法,Horizon算法不预约任务、速度最快,作为参考的基准,运行时间对比结果如图16所示.图16算法运行时间对比5结论本文针对可重构系统中任务的实时调度问题进行研究,提出了基于边界和位置双仲裁策略的时间片调度算法DATS,设计了双仲裁时间片任务调度模式图,为算法实现和实例演示提供操作方法.DATS算法将任务时间属性划归到时间片区间内,采用两个仲裁器对硬件资源进行管理,并根据空间和时间约束动态裁决任务布局位置;同时设计了双仲裁时间片任务调度模式图,对任务的调度和布局过程进行合理分离,使任务调度和布局过程相对独图16(a)~(d)分别针对C10、C30、C40和C50这4类任务对算法进行对比.结果显示:(1)对于特定一类任务(以图16(a)为例),算法Stuffing具有最短的运行时间,这是因为FF算法以“首次适合”为原则,调度算法时间复杂度为O(N);(2)对于特定一类任务,随着负载率的增加,Horizon算法运行时间急剧上升,说明Horizon算法对器件负载率的依赖较大,在重负载情况下时间开销大,不适合于对实时性要求较高的可重构任务调度;(3)不同类任务下的算法执行时间会随着任务面积的增大而增长,这是因为在同样数目任务同样器件负载率的前提下,面积较大的任务在调度和布局的时候,成功率较低(图14所示),各算法运行时间会趋向最坏的情形;(4)DATS算法采用了双仲裁时间片策略,既具有FF算法“首次适合”的优点,又具备Stuffing算法在任务启动终止时间处理上的优势,因而DATS算法运行时间接近FF算法,同时具有接近Stuffing算法的调度效果.立并简化处理过程.实验表明,DATS算法在相应负载率下的任务调度成功率和资源利用率均可保持在较高水平.针对并行的实时可重构环境,本算法尚有许多值得改进的地方,由于目前的可重构器件在并行配置、快速配置方面还不能满足要求,所以结合配置时间和配置方法的改进是十分必要的,另外算法在设计中没有考虑任务的重定位问题,在后续研究工作中将会补充完善.致谢在此,我们向对本文的工作给予支持和建议的同行以及同实验小组的各位同学和老师表示感谢!Page17
