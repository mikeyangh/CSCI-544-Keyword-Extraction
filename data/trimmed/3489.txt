Page1层次数据上关键字检索的结果聚合胡昊何震瀛(复旦大学计算机科学技术学院上海200433)摘要由于使用方便等优点,数据库上的关键字检索技术使用户可以得到所需信息而不必书写复杂的SQL语句.但大部分现有的检索方法都关注通过连接操作得到包含所有关键字的元组连接树,忽略了对于检索结果的信息整合,这从某种程度上影响了用户对于检索结果的判断.文中提出并实现一种改进的关键字检索系统框架,在具有层次结构的属性指导下对得到的元组连接树结果做聚合操作,通过寻找最低层次最小覆盖聚合将关系更为紧密的元组作为更加相关的检索结果反馈给用户.文中还提出了基本的聚合算法并对其做改进从而减少了系统的响应时间.同时,为了改善用户体验,文中定义并给出了检索结果的摘要问题及其算法,使用户最大程度地了解检索结果.实验数据表明,文中的方法能够以较高的效率和较低的计算代价有效地完成检索结果的聚合和摘要.关键词关键字检索;聚合操作;层次结构;摘要算法1引言作为从结构化和半结构化数据中提取所需信息的一种方法,关键字检索获得广泛关注[1-6].近年来,数据库上的关键字检索方法大量涌现[1,4-5,7-8].为获得包含所有关键字的元组或元组连接树,现有方法往往导致冗余信息或无意义结果的产生.另一方面,这些方法认为同一关系中的元组间相互独立,事实上,这些元组往往具有层次关系.如何利用元组间的图1一个层次关系数据库模式及其实例表1一个可能的检索结果Feature1A0010301C00115~20…,手自一体,涡轮增压一汽丰田丰田汽车(日本)2A0020301C00210~15…,手自一体,涡轮增压广汽丰田丰田汽车(日本)4A0040301C00110~15…,手自一体,涡轮增压一汽丰田丰田汽车(日本)5A0050301C00110~15手自一体,涡轮增压…一汽丰田丰田汽车(日本)6A0060301C00210~15…,手自一体,涡轮增压广汽丰田丰田汽车(日本)7A0070302C00115~20手自一体,涡轮增压…一汽丰田丰田汽车(日本)8A0080302C00225~30…,手自一体,涡轮增压广汽丰田丰田汽车(日本)表1的结果只是简单的将符合条件的元组陈列给用户,这需要用户花费一定的时间来分析结果.为使检索过程更加有效,将具有共同特征的元组聚合可帮助用户更加容易地熟悉返回结果.图2是按照层次关系进行信息整合,为用户提供更好的体验,是研究者需解决的一个主要问题.1.1研究动机例1.图1给出了某汽车销售的数据库,图1(e)是该数据库的模式,图1(a)~(d)是数据库中的实例片段.图1(e)中的有向箭头表示在模式之间存在有主键指向外键的关系.当用户试图检索日系车中配备涡轮增压发动机的产品时,他可能提交的关键字组合为“涡轮增压”和“日本”.表1展示了按现有技术的检索结果.具体的每个公司聚合后的结果,圆圈中数字表示表1中元组的序号,每个圆圈代表一条元组.同时,在每个公司内部,我们也按照层次关系将乘用车(0301)和商用车(0302)区分开来.这样的结果由于特征鲜明更易于被用户接受.当然,用户也有可能比较关心汽车产品的价位,而对于汽车的品牌没有那么敏感.因此,我们的聚合操作也应当能够在价格区间属性上展开.本文中,为使用户获得更好的检索体验,我们利用层次关系数据对检索结果进行信息整合,即聚合Page3和摘要.在考虑这些问题时,我们将遵循以下原则:(1)聚合粒度适当.检索结果集的聚合粒度的过小或者过大,都会影响用户分析结果.(2)摘要集.为使用户能够在短时间内比较全面地了解聚合结果的特性,我们应有针对性地给出具有代表性的k个聚合结果即摘要集.(3)良好的扩展特性.目前已有工作致力于关系数据库上关键字检索问题,为与这些工作结合,我们的改进应尽可能少地改变现有系统.1.2相关工作近十年来,互联网搜索引擎的巨大成功使关系数据库上的关键字检索问题引起越来越多学者的关注,并已在业界许多成熟的商业数据库系统上有简单实现(如MicrosoftSQLServer、Oracle和IBMDB2等).以往的研究更多地关注如何得到连接元组来获得同时包含所有关键字的元组连接树[1,4-5,7,9-16],并基于此提出了DBXplorer[1]、DISCOVER[4]、BANKS[7]、SPARK[5]、SQAK[8]等具体的实现方法.DISCOVER系统是此领域实现较早也较为成功的检索系统,后续在此基础上的SPARK、SQAK等都是对DISCOVER的具有某方面特性的改进工作.为了使本文的方法能更好地与其它关键字检索的方法整合在一个系统中,我们选取DISCOVER作为扩展的基础.该系统利用数据库模式图,在模式图的基础上枚举可能包含查询结果的所有候选网络,然后依据查询表达式生成SQL语句投入数据库中进行处理并取回结果.DISCOVER系统通过枚举所有连接表达式避免了在构造表达式时有可能出现的关键字与多个关系上多个属性值匹配的情况而导致的二义性.对于检索结果的进一步处理等工作包括打分方法和结果聚合也都在文献[3,17-18]中有所研究.Zhou等人在文献[17]中提出关系数据库检索结果的聚合问题,但该研究仅关注于一张表上的聚合操作.然而,实际应用中,信息会依据范式被分解成不同的部分存储于多张表中.若简单的将该方法应用于多张表的问题中会根据连接关系生成一张非常大的表,这是耗时且不实际的.另外,该问题中的属性上并无层次关系.SQAK的工作也对类似的聚集操作予以支持[8],但需要由用户指定在哪些属性上进行聚集操作,这对于不熟悉数据库模式的用户来讲是十分困难的.而且,SQAK中的聚集操作是对结果集进行聚集选择(即计算元组数目或求最大最小值等),并非在此基础上做信息整合.Buranasaksee本文的主要贡献如下:(1)在具有层次关系数据的背景下提出检索结果的最小覆盖聚合和最低上层最小覆盖聚合概念,以此概念帮助用户更好地了解检索结果.我们还在此基础上提出了求解最低层次聚合的基本算法和增强算法.(2)引入针对最低上层最小覆盖聚合族的摘要问题并提出了求解的贪心算法及具有剪枝的优化算法.等人在文献[18]中也提出类似的问题,他们的解决方案是直接使用DISCOVER[4]系统得到结果以后再做聚合,并没有考虑依据关系上的其它特性(例如:层次特性)对结果进行更好的区分.因此,得到的结果有可能使关系不是很紧密的元组聚合在一起;此外,该方案也没有考虑到检索结果集的摘要问题.Roy等人在文献[19]一文中也提到了类似的package的摘要问题,并给出了基于贪心和随机算法的两种解决方案.这与我们的问题类似,但是由于我们的检索结果集合在共有属性上并无交集,因此我们设计了针对该问题的剪枝策略.1.3本文贡献和组织(3)基于DISCOVER提出具有反馈机制的检索系统结构.本文第2节介绍系统概要、数据模型和问题定义;第3节给出求解MaxLMC(S,Q)的Groupby方法和按序连接方法;第4节介绍摘要问题并在Baseline方法上给出3个剪枝条件;第5节介绍实验;第6节总结展望本文工作.2概要与数据模型2.1系统概要展,系统的结构示意如图3所示.该系统由6部分组成.其设计遵循良好扩展特性的原则,最大限度地减少现有系统结构的更改.聚合模块(Aggregator)部分主要负责检索结果的聚合;摘要模块(Summarization)部分则对聚合结果做摘要.此处需注意的是返回结果时并非只返回摘要,而是在返回摘要的基础上先使得用户了解检索结果的特性,而后再返回其它所有结果.检索时,首先由用户将用于检索的关键字集合{k1,k2,…,km}输入系统.依据数据库表项中的倒排索引,对于数据库中的每一张表,我们都可以得到包我们的系统在DISCOVER的基础上进行扩Page4含关键字k1,k2,…,km的元组集合Rk1i,Rk2i,…,Rkmi.其中元组集合Rkji中表示关系Ri中属性上包含关键字kj的所有元组.然后,依据数据库模式图,在这些元组集合的基础上按照完整和无冗余的规则生成连接的候选网络(candidatenetworks).候选网络经由SQLGenerator生成对应的SQL语句并投入数据库管理系统进行检索.我们的系统与DISCOVER不同的一点是我们不会一次将所有的候选网络都生成出来,而是按照候选网络的规模大小(例如,边的数目)分批生成.这是由于先生成的结果可以对后续候选网络或SQL语句的生成是否执行起反馈和指导作用,过早的投入生成会造成计算资源的浪费.对于生成的结果元组分别由Aggregator聚合和Summarization步骤摘要返还给用户.本系统的提出是在DISCOVER的工作上进行的,因此与DISCOVER系统中相同的部分其模型和定义我们不再赘述,这些部分包括Joiningnet-workoftuples、KeywordQuery、MTJNT、JoiningNetworkofTupleSets、CandidateNetwork等定义,请参阅文献[4].我们的工作主要在检索结果的聚合和摘要上,因此,下文分别给出两者定义.2.2聚合和覆盖定义1(划分).设S是一个元组集合,π2S.如果下列条件成立则称π为S的一个划分:①S=∪P∈πP,②对于任意Pi,Pj∈π,若i≠j,则Pi∩Pj=.定义2(聚合关系).设α={S1,S2,…,Sn}是一个有限元组集族,Si(1in)是任意元组集合,是如下定义的二元关系:对于α中任意集合Si和Sj,如果存在一个函数F:π→Sj(π是Si的划分),则称Si和Sj满足,记作SiSj,F称为聚合函数.如果满足下列条件则称为α上的聚合关系:对于α中任意集合Si和Sj,如果SiSj,SjSi,则Si=Sj.引理1.集族α上的聚合关系是一个偏序.证明.从略.例如,α={S1,S2},其中S1为表1中7条元组的集合,S2为图1中AUTO表和COMPANY表做自然连接后的所有元组集合,我们知道,S1中的元组都能够在S2中找到与之对应的(AutoKey相同)但是属性比它本身多的元组.现在将S1中的元组按照公司(CompanyKey)划分,即所有相同的公司共同属于某一划分单元(注意:不同公司之间的元组也可能属于相同划分单元),记此划分为π.定义其上的聚合函数F,我们令F:π→S2当且仅当该划分下所有元组同属于一个国家(即,在S2中NationKey是一致的).此时F是“公司”关于“国家”的聚合函数,我们称S1的划分π满足国家上的聚合关系.显然,满足这样聚合关系的集合很多.例如,从S1中去掉n(n<|S1|)条元组得到的新的集合都满足π上关于国家的聚合关系,因此,我们关心的是如何得到完备的这样的集合,后文中借助于Groupby的方法实现这一点.另一方面,由于可以在不同的属性上构造聚合关系,因此在构造过程中应当注意全面性.一般地,我们将构造聚合关系的过程称为聚合操作.定义3(划分的覆盖).设S是一个元组集合,π={S1,S2,…,Sm},π2S是S上的一个划分.D是S上的字典,QD是S中出现的某些词,谓词contain表示集合中包含词项.则Cov(π,Q)={Si|SicontainQ}是划分π关于Q的覆盖.定义4(最小覆盖聚合,MC).设α={S1,S2,…,Sn}是一个有限元组集族.QD是α中出现的某些词,给定Si和π,π2Si是Si上的一个划分,若Sj∈α,SjSi,不存在划分π2Sj,使得Sj上有划分的覆盖Cov(π,Q),则Si是关于Q的最小覆盖聚合(MC).定义5(层次关系).设H是一个有限集合,是自反的、反对称的和传递的偏序关系,且:对于H中的任意元素hi,若hi非极小元,如果存在一个函数F:hi→H,HH,且F值域中的各个HH互不相交,则称F为分层函数,称是H上的层次关系.例如,CLASS表中的CLASSKEY集合上的包含关系就是一个层次关系.层次关系是针对集合中Page5的元素而定义的,而聚合关系是针对集族中的集合而定义的.一般地,若hihj,我们称hj是hi的上层.为了说明最低上层关系,我们定义运算MH,该运算返回层次集合上子集HH中最小的上层,即H的上确界.形式化表述为:MH(H)={hi|存在hk∈H,hj∈H,j≠k,有hjhk,并且对于所有这样的hk,hi是其中的极小元或者H中的最大元}.由于H中极大元不唯一,实际操作中,我们引入τ,并令h∈H,h是极大元,有hτ.引理2.若MH(H)存在,则必唯一.定义6(最低上层最小覆盖聚合,LMC).设S为关于Q的MC,MH(S)表示S中层次关系属性上的最低上层,若对于任意的S2S,S2中包含所有Q,不存在S1S,且wi∈Q,S1containQ,使得MH(S1)MH(S2),则称S2为关于Q的最低上层最小覆盖聚合(LMC).若同时也不存在s∈S,且S2∪{s}也是LMC,则称S2为MaxLMC,此时S2中所含的元组数目在满足最低上层最小覆盖聚合的条件下达到最多.显然,关于Q的最大最低上层最小覆盖聚合(MaxLMC)是对最小覆盖聚合的一个细分.例如,图2中{1,4,5,7}是在“一汽丰田”公司上的MC,{1,4}和{7}是基于层次关系的LMC,而{1,4,5}则是一个MaxLMC,可以看出,所有MaxLMC是对MC的细分.不同层次关系的最低上层最小覆盖聚合更多地反映了检索结果在认知上的粒度大小,而聚合则反映了检索结果在某一自身属性上的同质.问题1(MaxLMC(S,Q)).给定关系数据库模式Sc及其实例DSc,Q是用户提交的检索,S是对应于检索结果的元组集合.求解:MaxLMC(S,Q),S关于Q的最大最低上层最小覆盖聚合族.2.3摘要尽管我们致力于寻找MaxLMC,而这已经将可能的问题结果LMC大大减少,但是实际情况中MaxLMC(S,Q)的数目仍然有很多.可以想象,日系车中含有涡轮增压的产品数目本身就有许多,为使用户了解检索结果的特性,我们可以根据公司属性聚合结果,也可以根据价位属性聚合结果,这中间重要的一点是许多汽车会在不同的聚合集中有重叠.因此,在计算MaxLMC(S,Q)的基础上,我们应当进一步对结果做摘要,即从中选出k个具有代表性的最小覆盖聚合(一般为5~10个),这使得用户在较短时间内能较全面地了解检索结果的特性.问题2(摘要).给定MaxLMC(S,Q)和k,如何计算MaxLMC(S,Q)的具有代表性的k个最低上层最小覆盖聚合k-MaxLMC(S,Q).换言之,这k个最低上层最小覆盖聚合可以最大限度地表示之前求出的MaxLMC(S,Q).文中,我们称k-MaxLMC(S,Q)为摘要集.摘要的目的是展示给用户一个简短的具有k个最低上层最小覆盖聚合的结果,同时,在这k个结果中可以最大限度地将检索结果元组的集合涵盖进来.3最低上层最小覆盖聚合算法本节讨论如何在检索结果中得到最低层次的最小覆盖聚合.为了将SQL语句的这一特性应用进来,我们可以在系统中SQLGenerator生成语句时添加相应的Groupby语句.为此,我们先定义属性划分.定义7(属性划分).设A是给定关系数据库模式Sc上的属性集合.A=AC∪AP∪AU是关于A的一个划分,其中AC表示分类属性,AP表示具有偏序关系的聚合属性,AU是其补集.AC和AP统称为聚合属性.例如,AUTO表中PriceInterval是分类属性,CompanyKey和COMPANY表中的NationKey等外键是具有偏序关系的聚合属性,这是因为若某汽车属于某公司,其必属于相应的国家,为此,在聚合时应先选择偏序次序较为靠前的属性.我们可以在这两类属性上做聚合操作.而Feature和COMPANY表中的Establish属性则不是分类属性.在生成SQL语句时,我们应选择所有可能用于聚合操作的属性并在其上做Groupby操作.但是这样会增加系统生成的SQL语句数目从而增大开销.因此,我们仅在偏序关系的聚合属性上做Groupby操作,而分类属性上的聚合操作我们将在具体的SQL语句得到结果后进行,此操作只需要简单地遍历一遍结果元组,并将不同的类别元组置于不同的最小覆盖中即可.若SQL语句中涉及到两个或以上的聚合属性AP1,AP2,…,APk,则根据AP的偏序关系选择划分更为细致的属性APi,使得APi,j≠i,有APiAP里使用来表示APi上聚合的结果之间聚合关系的比较,下同).当然,有可能在APi上并无聚合结果,此时根据Feedback机制使SQLGenerator重新生成SQL语句,并选择仅在APi之上(即APi+1)的属性Page6聚合.3.1基于Groupby的方法为求得MaxLMC(S,Q),根据定义,最低上层最小覆盖聚合是对最小覆盖聚合的一个细分,因此我们需要首先计算出最小覆盖聚合.定理1.基于SQLGenerator生成的带有Groupby操作的SQL语句的执行结果为最小覆盖聚合MC.这与选择的Feedback机制有关,证明从略.我们关心的是LMC.假设用户在检索时需要含有特性“a”和“b”的产品,根据候选网络生成SQL语句得到的可能连接结果如表2,这些结果都是在公司C上Groupby得到的.表2一部分可能的连接结果(中间一列为公司)AutoKey层次特征AutoKey层次特征A0010301aCA0020301bA0010301aCA0030302bA0040302aCA0020301bA0040302aCA0030302bA0050301aCA0020301b易知,表中的5条结果已经是最小覆盖聚合,但是若考虑到层次关系,则只有第1,4,5条元组满足最低上层最小覆盖聚合.这是因为第1条元组的最低上层为0301,而第2条元组的最低上层为03,因此我们保留第1条元组.同理,第4,5条元组得到保留.算法1给出求解最大最低上层最小覆盖聚合的Nave方法,其中MH(ti)表示ti元组上层次关系的最小上层.算法1.NaveMaxLMC(S,Q).输入:最小覆盖聚合S输出:MaxLMC(S,Q),结果用R表示,R={RS1,1.R=empty2.foreachtupletiinS3.{Lowest=true4.foreachtupletjwiththesamevalueonjoining5.{if(MH(tj)MH(ti))6.Lowest=false7.}8.if(Lowest=true)9.RMH(ti)=RMH(ti)∪{ti}10.}11.returnR算法1求解最大最低上层最小覆盖聚合,它的输出为MaxLMC(S,Q),每一个MaxLMC中包含了所有相同最低上层的聚合结果.算法的流程是:对于每一条元组都遍历与之连接属性上值相同的其它元组,若其它元组的最低上层层次都不低于该元组,则将该元组加入其自身的最低上层层次的MaxLMC.上例中的结果应为(以序号表示元组):{1,5},{4}.假定在最小覆盖聚合S上共有n条元组,连接属性共有d种同的值,因此平均在每个连接属性的值上有n度为n()dO(n2/d).3.2按序连接方法注意到,上例中连接的结果2、3并未被选用.因此若可以设计一种连接操作时避免生成2、3元组的方法,则将大大减少时间开销.由于结果是由SQL语句生成的,因此有两种方案可供实现改进算法:(1)完全弃用数据库管理系统提供的SQL检索方式,根据层次关系实现系列操作;(2)在SQL语句在做最后一步连接操作前,根据层次上的最低上层选择在做连接时剔除掉部分结果.本文中,我们选取后者.在SQL语句最后做连接之前,有两个待连接的元组集,称之为T1和T2,其中T1和T2中的每条元组分别包含Q的一个子集Q,并且在连接时对于ti∈T1,tj∈T2,则titj的结果必须含有所有的Q,记为Qti∪Qtj=Q.并且,T1和T2中的元组都具有层次关系的属性,若某Ti中没有层次属性,则可认为Ti中的层次为H上的极小元,使得MH(tj)=MH(titj),这样不影响后面的计算.我们的改进算法是基于层次关系的传递性质,即若某ti∈T1,它的层次为MH(ti),则ti的连接结果(用Join(ti)表示)的最低上层MH(Join(ti))满足:MH(ti)MH(Join(ti)).算法开始于两个先按照连接属性排序后按照层次偏序排序(同一层次的排序按字典序)的元组集T1,T2(这可以在SQL中使用Groupby和asc实现).选择层次种类较多的元组集(假设为T1,没有层次属性的待连接元组集层次种类为0),在顺序遍历T1的过程中,对于T1中的每个元组ti,选择连接属性上值相同的tj∈T2,设为{tj0,tj1,…,tjm},顺序遍历这样的tj即可,且从tj0开始,MH(titj)层次较低的连接元组会按序聚合在Page7一起,根据最低上层条件,若对于tjk,MH(titj0)MH(titjk),则tjk以后的元组都不必考虑,因而titjk,titjk+1,…,titjm这些连接操作不必要执行.算法2.MaxLMC(S,Q).输入:待连接元组集T1,T2输出:MaxLMC(S,Q),结果用R表示,R={RS1,RS2,…,1.R=empty2.foreachtupletiinT13.{foreachtupletjinT2withthesamevalueon4.{if(MH(titj0)MH(titjk))5.break6.else7.t=Jion(ti,tj)8.RMH(titj09.}10.}11.returnR定理2.算法2产生与算法1相同的结果.需要说明的是:算法2当其中有一Ti上不具有层次属性时退化为算法1.此时对于Tj中的任一元组,都需要在Ti上连接,因此不节省连接操作.此外,对于没有做连接的元组,在返回结果时我们将直接返回,这保证了返回所有结果按算法2生成的对于某一连接属性的连接元组聚合得到的一系列MaxLMC,我们按照聚合元组数目的降序在其上维护一个优先队列,使得MaxLMC(S,Q)在每一属性上都是有序的,这样的顺序便于用户查看,同时也为我们的摘要算法做好数据准备.4摘要算法直接将所有的MaxLMC(S,Q)返还给用户(如2.4节所述)具有两个缺点.一是MaxLMC(S,Q)的数目非常多;二是各MaxLMC之间有很大比例上的重叠.我们做摘要的目的是找到k个具有代表性的MaxLMC,给用户尽可能全面地提供检索结果并使其可以进一步掌握检索结果.生成摘要的常用方法是聚类算法:我们可以在MaxLMC上定义两两之间的距离函数,然后应用各类聚类算法(例如,k-means).在将MaxLMC(S,Q)分成k类后,从每一类中随机选取一个聚合集即可.但是,在当前的问题中定义距离函数是十分困难的.本文中,我们根据最大覆盖原理设计了一种不同的方法用以求解该问题,目的是找到尽可能完整的覆盖检索结果集的k个代表MaxLMC.直观地看,这k个MaxLMC的并集中所含的元组数目最多,这能够更好地展示给用户检索结果的共有特性.而且,从LMC的角度来看,用户可以从摘要集中构造出更多的LMC.例如,在图4中,实线和虚线框分别代表不同的分类属性上的聚合结果.若k=2,我们的摘要集应为S1,S4,因为S1∪S4中所涵盖的元素数目最多.我们的问题是给定MaxLMC(S,Q),选择其中的k个集合使得这k个集合包含的元素最多.最简单的解法是:对所有可能的k个集合的并集分别计算元素个数,并取使并集中元素个数最多的k个集合.这具有指数的时间复杂度.为解决这一问题,我们给出一个基本的贪心算法.4.1基本(Baseline)方法算法3伪码如下,基本思想是:从最大的集合(元素数目最多)开始,记为I,在每一轮迭代中都选择Si使I∪Si最大.算法在k轮迭代后停止.算法3.GreedySummary.输入:MaxLMC(S,Q)={S1,S2,…,Sn}输出:覆盖I1.I=empty2.LetSmaxbethelargestsetinMaxLMC(S,Q)3.removeSmaxfromMaxLMC(S,Q)4.I=I∪Smax5.iteration=06.Whileiteration<kdo7.Smax=MaxS∈MaxLMC(S,Q){I∪S}8.removeSmaxfromMaxLMC(S,Q)9.I=I∪Smax10.iteration++11.returnI算法3是Maximumk-SetCover问题的经典贪心解法,Maximumk-SetCover问题是集合上最小覆盖问题[13]的最优化问题,是一个经典的NP完全问题.上述贪心解法不能完全正确地求解Maximumk-SetCover问题,但是能给出(1-1/e)的近似率[20].Page8引理3.给定k-MaxLMC(S,Q)问题,令Iopt表示其最优解,Igreedy表示Baseline贪心法的解,C(I)表示I中涵盖的元组数目.则C(Igreedy)/C(Iopt)(1-1/e).e为自然对数的底.4.2改进(Improved)方法观察到我们的问题中在某属性上的聚合结果是互不相交的,即,MaxLMC(S,Q)中的结果按照聚合属性的不同(假设其中涉及到m个聚合属性)可分为m类,其中每类上的最大最低上层最小覆盖聚合集MaxLMC之间互不相交.例如,在图4中,若S1和S3是按照价格区间属性上求MaxLMC的结果,则它们是不相交的,这是因为对于某一汽车,其价格区间唯一,因此其属于且只属于一类中.由于m类中每一类上的MaxLMC是对MC的细分,因此这m类中的集合之间互不相交.形式化的表述为:MaxLMC(S,Q)按照聚合属性归类为{M1,M2,…,Mm},其中每一类Mi={Mimi}中的聚合覆盖互不相交,且前文已述,Mi中的Mi各个MaxLMC(以下简称聚合集)是按照规模降序排列.例2.如图5所示,MaxLMC(S,Q)中有m=2时两类聚合集族a,b,数字表示MaxLMC中元组的数目,每一族上的各个聚合集互不相交.我们先给出算法3的3个剪枝条件,然后分别对照此例阐述.图5m=2时MaxLMC(S,Q)可能的情况,数字代(1)InitialFilter.若初始最大MaxLMC来自1,则若|MiMi立,Mi选择直到出现k≠i使得|Mi2应是下一个选择的MaxLMC,而且可以继续例如,图5中,我们从元组最多的聚合集a1开始选取,当选取第2个集合时,由于a2中元组为19条,比b1要多,因此不必考虑其它聚合集,将a2作为结果输出即可.同样的,a3也因此被输出.(2)InclusiveFilter.若当前摘要集为I,并处于第r次迭代当中.在考察Mi的时候,从Mi1∩I|=t,|I-∪mi|Mi要按序考察x-t+1个MaxLMC.这是基于这样的原理:当按序考察集族a的聚合集时,若某ai与I不相交,它对|I∪ai|的贡献为|ai|,则ai+1以后的集合均不必考虑,因为|ai+1||ai|,其以后的对摘要集的贡献不会多于当前ai.例如,图5中,假设灰色标记的MaxLMC的并集是已经选择的摘要集I,当前为第5次迭代.对于a4来说,假设8条元组中有3条在I中出现(此例中这3条元组来自b1),且I中共有9条元组来自集族b(此例中均来自b1),则在集族a中剩余的集合最多还可能与I相交的数目为9-3=6,因此,在按序的6+1个MaxLMC内必将出现一个不与I相交的集合(抽屉原理),此后的聚合集均不必考虑,因为依据之前分析,一旦找到一条不与当前摘要集I相交的聚合集,以后集合均不必考虑.(3)ExclusiveFilter.若当前摘要集为I,并处于第r次迭代当中.在考察Mi的时候,从Mi1∩I|=t,则在Mi中,我们只需要考察到规模若|Mi1|-t的MaxLMC.为|Mi例如,图5中,当前为第5次迭代,同上例,对于a4,有3条元组在b1中,则a4的贡献为8-3=5,那么我们仅需考察到规模为5的a5即可,因为a5以后的MaxLMC规模都小于5,贡献不可能比a4大.我们的改进的Summary方法即在基本的方法基础上应用上述3种剪枝策略得到.具体伪码略.5实验为了验证文中所提出的关于聚合问题和摘要问题的改进方法,我们分别在真实数据和模拟数据上做实验.真实数据来自电子工业部某研究所的保密数据.为了验证本文方法,我们依照图1(e)中给出的模式生成了模拟数据.如图1所示,该数据库模式上共有4个分类属性和3个具有偏序关系的聚合属性.生成数据时,我们指定了各分类属性和聚合属性上值相同的元组最多为100条,这也就是说,聚合得到的MaxLMC的最大规模不会超过100.在其它属性上我们均是从预先定义的字典中随机赋值.另外,CLASS表的层次最大深度为5,平均深度为3.12;其余三张表的元组数目如表3.Page9AUTO1000005.1数据准备对于真实数据和模拟数据,首先我们在其上做关键字的倒排索引,按照DISCOVER系统的方案生成在分类属性或聚合属性上带Groupby的SQL语句.然后将这些SQL语句投入数据库中.本实验是在VisualStudio2010平台上开发,用C++编写,数据库使用MySQL5.0版本.运行在PC上,IntelCPU,主频2.8GHz,内存8GB.5.2聚合结果真实数据和模拟数据上我们都选取了10组用于检索的关键字.由于聚合操作的两个算法之间涉及到不同的数据库操作,直接比较时间代价是不可行的.因此我们在此比较按序连接方法的节省比,即按序连接方法的连接次数占基于Groupby方法的连接次数的比例.另外,由于有多个聚合属性,我们对每个检索都分别在每个聚合属性上做聚合,然后用总的节省连接次数除以总的连接次数做平均节省比.由于在按序连接方法中我们不需要数据库管理系统来做连接,而是需要待连接元组集(见3.2小节),因此在本实验中,我们将DISCOVER由候选网络翻译成SQL语句时从候选网络的连接操作处断开拆分成为个候选网络,然后分别生成SQL语句投入数据库中得到待连接元组集.对于涉及到两次连接以上的候选网络,我们将指定最晚连接属性并从该连接属性处断开.具体实现时,由于模式图已知,我们事先指定某些外键属性为最晚连接属性.例如,对于本次实验的模拟数据,我们选择自然连接时的公共属性做为最晚连接属性(即例中的ClassKey、Com-panyKey和NationKey属性).需要注意的是,若某候选网络中同时具有两个以上的连接操作,则我们按序从首先出现最晚连接属性的那个连接操作处断开.图6和图7分别是真实数据和模拟数据上的节省比率.图中,横坐标是10次不同的查询,纵坐标则为节省比.在图6中,Q1和Q6的节省为0,这是因为Q1和Q6的关键字分别来自两张不同的表,其中有一张表上没有层次关系,此时算法2退化为算法1,并没有节省连接操作.这在实际情况中时有发生,与具体的数据和检索都有关系.而在模拟数据中,算法退化并不明显,这是由于我们随机赋值,因此包含不同的关键字的元组基本上都可以来自具有层次属性的关系,故而按序连接方法在此处没有完全退化.5.3摘要我们考察当k不同时及MaxLMC中分类M不同时Improved方法的效率差异.真实数据上返回结果的平均元组数目为1743条,针对每个检索,我们都分别选定聚合属性为2个和3个时做摘要算法的比较,平均每次聚合生成223个(m=2时)和421个(m=3时)MaxLMC.模拟数据上返回结果的平均元组数目为5201条,同样的,我们也在2个和3个聚合属性上做聚合,平均每次聚合生成2210个(m=2时)和3102个(m=3时)MaxLMC,这与真实数据差异较大,主要因为模拟数据的关键字分布比较随机,并非真实数据上呈明显的分布区分.在做摘要时,贪心法随着k的增长时间代价增长很快,图8、图9显示了这种情况,上方的曲线为基本的贪心方法随着k值从5~25变化所需的时间花费,其中纵坐标取时间的对数.这是因为在k增长时,每一轮迭代都要遍历所有的元组集合用以判定最大覆盖.图8考察了对2类属性上MaxLMC摘要的结果.上方曲线为Baseline方法随着摘要集规模k的增长摘要时间的增长,下方曲线为具有剪枝的Improved方法时间花费.从数据上可以看出,剪枝以后的时间效率大幅提升.同时,无论在真实数据和模拟数据上,我们的剪枝算法都能保证时间效率.但是随着k的增长,剪枝算法时间代价仍近似指数增Page10长.考虑到实际应用中k值选取一般不会很大,因此我们的剪枝算法可以保证摘要的实时性.图8m=2时真实(上)和模拟(下)数据比较图9考察了对3类属性上MaxLMC做摘要的结果,仍可从中看出剪枝后时间效率的大幅提升.当与图8中m=2时情况对比,可以发现,我们的剪枝算法效率有所下降,但仍然可保证实时性.这是因为我们的剪枝是针对某一个属性上的聚合结果的剪枝,若m值增大,时间耗费也会随之逐渐增大.图9m=3时真实(上)和模拟(下)数据比较6总结本文在具有层次关系的关系数据库上提出了关键字检索结果的聚合问题和聚合结果的摘要问题,我们以DISCOVER作为基础,在其上进行扩展.此外,针对两个问题的基本算法我们又提出了具体的改进算法.分析和实验结果表明,改进算法的时间花费较小,具有明显优势.进一步的工作包括考虑更加有意义的反馈机制和对摘要结果进行打分,用以将聚合结果按照相关顺序返回.
