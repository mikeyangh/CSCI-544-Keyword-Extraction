Page1修改客户操作系统优化KVM虚拟机的I/O性能张彬彬1)汪小林1)杨亮1)赖荣凤1)王振林2)罗英伟1)李晓明1)1)(北京大学计算机科学技术系北京100871)2)(密西根理工大学计算机科学系霍顿美国)摘要目前,运行在虚拟机上的客户操作系统(GuestOS)是面向物理机器开发的普通操作系统,其中存在不适应虚拟化环境的因素,影响虚拟机的I/O性能.作者通过测试发现了影响虚拟机I/O性能的一些问题,针对这些问题提出了优化方法:一方面,通过合并客户操作系统中连续的I/O指令,降低虚拟机的时钟中断频率,从而降低环境切换的开销;另一方面,消除客户操作系统中的冗余操作,包括在虚拟化环境下无效的函数、冗余的I/O调度以及虚拟网卡驱动对NAPI的支持,使虚拟机只执行必要的操作,从而提高系统的性能.关键词I/O虚拟化;KVM;性能测试;优化1引言虚拟机的I/O性能至今没有得到较好的解决.KVM虚拟机(Kernel-basedVirtualMachine)使用Page2问物理硬件,实现对I/O设备的虚拟化.该方法依赖QEMU对设备的模拟,因此实现简洁,但是由于I/O处理流程中涉及多个环境,切换较多,其I/O性能很不理想.虽然KVM较新的版本中已经将一些关键设备的虚拟化进行了优化,但是主要的设备,例如磁盘和网卡虚拟化的性能开销仍旧较大.我们主要从客户操作系统的角度来发现问题.我们测试了KVM虚拟机磁盘和网卡的虚拟化性能,测试结果表明:由于目前运行在虚拟机上的客户操作系统是面向物理机器开发的普通操作系统,其中存在不适应虚拟化环境的因素,影响虚拟机的I/O性能.根据测试结果,我们设计了一组优化方案,通过修改客户操作系统源码及其配置,达到优化KVM虚拟机的磁盘和网络I/O性能的目标.2KVM虚拟化性能测试比较KVM虚拟机系统和非虚拟化系统(Native)的I/O性能,了解KVM虚拟机I/O设备虚拟化开销,并分析其性能特征,其主要方法是分别在客户操作系统和宿主操作系统上运行磁盘和网络I/O的基准测试程序(benchmark).为了进一步了解性能开销可能的分布,我们修改KVM,在基准测试程序运行时,获得指令级的客户操作系统的行为细节.2.1磁盘测试测试环境:IntelCore2QuadQ9550(2.83GHz),4GB内存,SATA硬盘(转速7200),系统版本:KVM-76(默认配置),Linux2.6.27.7.测试内容:在虚拟机上运行bonnie++①,bonnie++使用文件系统调用,分别测试按块读/写的吞吐率和CPU利用率,并与Native环境下的测试结果进行对比.按块写磁盘的性能测试结果如图1所示.从图1中可看出,虚拟机按块顺序写磁盘的吞吐率和CPU利用率都只有Native的一半左右,存在较大的优化空间.按块读磁盘的测试结果如图2所示.读磁盘时,如果缓存命中,就不用发生实际的读盘操作,则虚拟机可以不必陷入VMM进行处理,可以接近Native的性能,而其虚拟化开销主要表现于CPU的开销.因此,图2中,虚拟机按块顺序读磁盘的吞吐率与Native相当,而CPU占用率则比Native高很多.因此,在磁盘I/O方面,一是需要提高写磁盘的性能,二是需要降低读磁盘时CPU的利用率.而性能降低的具体原因,包括较高的虚拟机陷入频率、QEMU模拟性能较低等.2.2网络测试测试环境:物理机器HostA和HostB,分别使用Intel的千兆网卡82566DC和82567LM-2,以千兆网互联.在HostB上用KVM运行一个虚拟机GuestB.实验1.用ping测试虚拟化带来的网络数据包传输延迟.测试内容:(1)物理主机HostAping物理主机HostB;(2)物理机HostBping虚拟机GuestB;(3)物理机HostAping虚拟机GuestB,分别测试之间的往返时延(RTT),测试结果如图3所示.①bonnie++.[Online]http://www.coker.com.au/bonnie++/Page3从测试结果可以大致估计虚拟化带来的额外开销:数据包从GuestB传输到HostA的时间开销,相当于数据包从GuestB传输到HostB的时间加上数据包从HostB到HostA的传输时间.也就是说,虚拟化的开销大致是GuestB到HostB的传输时间,从测试数据上看,这部分的时间开销约为33%.实验2.Netperf测试.Netperf①是用来测试网络吞吐率的开源基准测试程序.主要是通过客户端和服务器端两个应用程序来进行网络数据的发送和接收,并计算出相关网络性能指标.我们主要关心带宽(throughput)和延迟(latency).测试过程:(1)远端主机HostA上运行netperf的网络服务器端;(2)本地主机HostB上运行netperf客户端进行性能测试;(3)设置虚拟机GuestB使用不同的虚拟网卡(虚拟rtl8139网卡或虚拟e1000网卡),分别运行netperf客户端进行测试.测试结果如图4所示.图4中,KVM虚拟机的性能远低于Native,但表1KVM虚拟机运行SPECjbb时的热点函数陷入次数陷入处理时间/s/占总时间的百分比/%10xc041be3f20xc042ffa630xc0407cf940xc041add250xc0407cf7表2KVM虚拟机运行netperf时的热点函数陷入次数陷入处理时间/s/占总时间的百分比/%10xc04ee0fc20xc04ee0d130xc04ee15340xc04edfe450xc0623d05结果显示,I/O操作存在一定的热点效应,也就是说,少数指令导致了较多的虚拟机陷入.我们可以针对热点代码进行优化.此外需要注意的是SPECjbb的测试中,时钟中断(timer_interrupt)引起的虚拟机陷入排到了前五位,可以通过优化时钟中断优化SPECjbb的性能.我们抓取了bonnie++运行时的热点函数,前4个热点函数如表3所示.由于这些热点函数在操作系统中会被多处频繁调用,因此我们还抓取了调用这些热点函数的上一级函数,表中的上层调用函数列出了调用热点函数最频繁的函数.表3中,上层调用函数verify_pmtmr_rate用图4netperf测试,虚拟机使用不同网卡配置是,当虚拟机使用不同的网卡设置时,性能有一定的差异.因此,模拟设备的处理能力对虚拟化环境下网络性能存在很大的影响.如果为客户操作系统选择合适的模拟设备及适当的配置,可以得到相对较高的虚拟机网络I/O性能.2.3指令级测试为了进一步分析性能下降的原因,我们抓取了虚拟机运行SPECjbb②和netperf时发生虚拟机陷入(VMExit)的代码,其中最频繁导致虚拟机陷入的函数我们称之为“热点函数”,前5个热点函数显示在表1和表2中.4.29/17.660.10/0.410.38/1.558.57/35.283.08/12.68101.64/26.0385.33/21.8562.26/15.9444.53/11.400.73/0.19陷入地址发生陷入的函数上层调用函数地址上层调用函数0xc06442ddacpi_pm_read0xc06442e7verify_pmtmr_rate0xc0547047iowrite80xc05e8fe3ata_sff_dev_select0xc0546f3cioread80xc05eaa44ata_bmdma_status0xc05470ffiowrite320xc05ea9c2ata_bmdma_setup于调整主板时钟,该功能在虚拟机环境下冗余,可以消除该函数减少一部分虚拟机陷入.热点函数的测试结果表明,目前的客户操作系统中存在一些操作影响了虚拟机的I/O性能,我们的优化工作主要针对这类问题进行.①②Page43优化方法及其效果基于上一节的测试结果,我们发现,现有的客户操作系统是直接采用针对物理主机设计的操作系统,其中存在一些不适应虚拟化环境的因素,影响虚拟机的性能.根据现有的分析,这些不适应的因素可以分为3类:(1)在虚拟化环境下一些引起短时间内频繁发生虚拟机陷入的操作.优化时,应该尽量降低这类操作发生的频率,或者可以通过批量处理进行优化.(2)冗余的操作.这些操作在虚拟化环境下不发生实际的作用;或者有些操作在客户操作系统和VMM中重复实现.冗余的操作通常可以直接去除.(3)可以由客户操作系统实现,也可以由VMM或者硬件实现的功能.通常情况下,越底层执行效率越高.因此,可以由VMM或硬件完成的功能通常都可以交由它们完成,尽量减少客户操作系统的工作,提高整体性能.因此,我们试图针对KVM虚拟化环境的特征,修改客户操作系统的源码或其配置,达到降低环境切换代价、精简客户操作系统的目的,从而提高KVM虚拟机的I/O性能.针对第3类问题的优化已经有了较多的研究成果(详见4.2节),我们主要针对前两类客户操作系统的问题进行优化,本节讨论几种优化方法,并比较优化前后的性能.3.1降低环境切换代价软件模拟的I/O虚拟化方法的每一次I/O处理过程存在多次环境切换,包括客户操作系统和KVM的切换、内核态的KVM和用户态的QEMU的切换以及QEMU进行系统调用以后用户态和宿主操作系统内核态的切换.其中除了客户操作系统和KVM的切换之外,其它切换都是KVM的设计构架所决定的,而客户操作系统和KVM的切换取决于客户操作系统的行为,且客户操作系统和KVM的切换通常会引起其它几种切换.因此,客户操作系统和KVM的切换频率是降低环境切换次数的关键,如果可以调整客户操作系统的行为,减少其切换到KVM的频率,则可以降低环境切换频率.通过上一节的指令级测试可以看出,KVM的I/O操作存在一定程度的热点效应,有少量客户操作系统的代码引起了较多虚拟机陷入,可以针对这些代码进行优化.目前我们的工作主要包括以下两方面.3.1.1合并连续的I/O指令客户操作系统的磁盘驱动中,存在一些代码段,包含了连续的I/O指令.每当执行到一条I/O指令,都会引起虚拟机陷入,使得这一段代码连续陷入.因此可以将这些指令合并成一个操作,一次陷入KVM进行处理.我们采用了静态合并的方法,将一组I/O指令替换成一个vmcall调用(vmcall类似于操作系统中的系统调用,客户操作系统中调用vmcall之后,将切换到VMM进行处理),一次主动陷入KVM,替换方法是将每条I/O指令的信息,包括in/out、端口、值,依次放入一个数组,该数组的地址和长度作为参数由vmcall传递给KVM处理.KVM反过来从数组中将I/O操作的参数依次取出,逐条进行模拟.例如,/driver/ide/ide-disk.c中的__ide_do_rw_disk函数,存在如下一段代码(代码段1):/driver/ide/ide-disk.chwif->OUTB(tasklets[1],IDE_FEATURE_REG);hwif->OUTB(tasklets[3],IDE_NSECTOR_REG);hwif->OUTB(tasklets[7],IDE_SECTOR_REG);hwif->OUTB(tasklets[8],IDE_LCYL_REG);hwif->OUTB(tasklets[9],IDE_HCYL_REG);hwif->OUTB(tasklets[0],IDE_FEATURE_REG);hwif->OUTB(tasklets[2],IDE_NSECTOR_REG);hwif->OUTB(tasklets[4],IDE_SECTOR_REG);hwif->OUTB(tasklets[5],IDE_LCYL_REG);hwif->OUTB(tasklets[6],IDE_HCYL_REG);hwif->OUTB(0x00|drive->select.all,IDE_SELECT_REG);该段代码包括了11次连续的outb,将会引起11次连续的虚拟机陷入.我们将这11条outb合并为一个vmcall调用,得到如代码段2所示的代码:/driver/ide/ide-disk.cstructio_insnio_out[11];//保存I/O指令信息的数组usignedlongio_gpa,io_len;#defineIO_OUT(x,_type,_val,_port)\io_out[x].type=_type,io_out[x].port=_port,io_out[x].val=_val//把I/O指令的信息依次放入io_insn数组:IO_OUT(0,OUTB,tasklets[1],IDE_FEATURE_REG);IO_OUT(1,OUTB,tasklets[3],IDE_NSECTOR_REG);IO_OUT(2,OUTB,tasklets[7],IDE_SECTOR_REG);IO_OUT(3,OUTB,tasklets[8],IDE_LCYL_REG);IO_OUT(4,OUTB,tasklets[9],IDE_HCYL_REG);IO_OUT(5,OUTB,tasklets[0],IDE_FEATURE_REG);IO_OUT(6,OUTB,tasklets[2],IDE_NSECTOR_REG);IO_OUT(7,OUTB,tasklets[4],IDE_SECTOR_REG);IO_OUT(8,OUTB,tasklets[5],IDE_LCYL_REG);IO_OUT(9,OUTB,tasklets[6],IDE_HCYL_REG);IO_OUT(10,OUTB,0x00|drive->select.all,IDE_SELECT_REG);//由于KVM和客户操作系统所见地址空间不同,需要把io_insn//数组地址转换为物理地址,以便KVM访问:io_gpa=virt_to_phys((unsignedlong)io_out);io_len=11;//I/O指令数vmcall(XKVM_IO_COALESCE,io_gpa,io_len,0);//调用vmcall陷入KVM,其参数包括io_insn的地址和长度Page5原来的11次陷入变成1次陷入,可以极大地降低陷入KVM的频率.我们修改了两个存在连续I/O操作的代码段,对修改前和修改后inb、outb调用点引起的虚拟机陷入数量进行了统计,结果如表4所示,修改后,陷入数量得到了极大的降低.指令地址0xc054fcc00xc054ecf0该方式实际上是借鉴了半虚拟化[1]的思路,通过修改客户操作系统的代码,减少客户操作系统和VMM之间的切换.目前我们只实现了静态的修改,包括静态分析连续陷入的代码、静态合并指令.进一步的,我们可以实现动态的半虚拟化,也就是进行动态的代码段替换,包括在运行时进行动态监控,找到热点的代码段,动态合并指令,生成新的代码片段.然后通过加入跳转指令,或者通过替换包含热点代码的整个函数,实现代码段替换.或者,运行时,当一个I/O操作发生陷入,在KVM中预取客户操作系统的后续操作,当发现多个可以合并的I/O时,则一次模拟执行完毕,再返回客户操作系统.我们比较了该优化前后的I/O性能,结果并不理想,除了CPU利用率有一定的降低,I/O的吞吐率几乎没有变化.我们合并I/O操作的优化方式只减少了环境切换的开销,也就是减少了虚拟机陷入和返回所消耗的时间,并不对陷入之后在KVM和宿主操作系统中的操作进行优化,因此,优化结果说明这部分环境切换的开销还不是I/O性能开销的决定因素.3.1.2控制时钟频率时钟中断是另一个频繁引起虚拟机陷入的原因,每个时钟中断到来时,都会引起虚拟机陷入VMM.对于非实时应用,我们可以通过降低时钟频率,减少虚拟机陷入的频率.最简单的方法是直接修改客户操作系统的配置.我们进一步实现了对客户操作系统透明的降低时钟频率的方法.KVM虚拟机的时钟是由KVM模拟PIT实现的,PIT可以产生clock信号,其频率近似是1193181Hz,每当clock信号到来时,PIT通道0的计数器自动减1,当计数器减到0时,就通过IRQ0向系统产生一次时钟中断.KVM虚拟的PIT也是这样的工作原理.因此,通过修改虚拟PIT通道0计数器的初始值,就可以设定时钟中断的频率,例如,1000Hz的时钟频率,PIT通道0计数器初始值为1193181/1000=1193,100Hz时,则为1193181/100=11932.也就是说,如果修改系统初始化时写入vPIT通道0的计数器值,就可以对客户操作系统透明地修改其时钟频率.具体方法是修改pit_load_count函数中写入vPIT通道0的初始值.我们实验了在客户操作系统时钟频率为1000Hz(vHZ100)的情况下,由KVM将时钟频率实际设定为100Hz(vHZ100),比较了修改前后的虚拟机I/O性能,如图5所示.结果表明,降低时钟频率能够一定程度地提高虚拟机地性能.3.2精简客户操作系统冗余的操作是指在虚拟化环境下不发生实际的作用或者在客户操作系统和VMM或宿主操作系统中重复实现的操作.我们需要找到这些可能冗余的操作,将其从客户操作系统中去除,从而优化KVM虚拟机的I/O性能.3.2.1消除冗余函数一个例子是在磁盘I/O的热点代码分布测试中,表3中的函数verify_pmtmr_rate,该函数的主要工作是调整主板时钟,该操作在虚拟机环境下是多余的.对于这种操作,只需要修改客户操作系统,简单将其去除,就可以适当地提高客户操作系统的运行效率.实验结果如图6所示.比较去除verify_pmtmr_rate函数前后虚拟机Page6图6去除verify_pmtmr_rate函数前后虚拟机写磁盘性能磁盘I/O的性能,可以看到,去掉该函数以后,虚拟机的写性能有了一定的提升.3.2.2消除冗余调度在I/O请求提交驱动之前,操作系统通常要对I/O请求进行调度:通过对磁盘I/O请求的合并和排序,降低磁盘的寻道时间,提高磁盘旋转时读取数据的效率,从而降低I/O操作的总时间,增加单位时间内的I/O操作次数,提高系统整体的I/O效率.KVM基于宿主操作系统的结构,使得客户操作系统的I/O操作总是通过QEMU进行系统调用,在宿主操作系统内核中再逐层向下传递到物理硬件.该流程使得客户操作系统的I/O请求要经过客户操作系统和宿主操作系统的两次I/O调度,客户操作系统中的调度结果必然要由宿主操作系统再次调度,显然冗余.一方面,客户操作系统并不知道物理磁盘信息,这次调度不一定有效;另一方面,当多个客户操作系统同时运行时,通常情况下,所有I/O操作需要由宿主操作系统统一调度以获得整体性能的最大化.基于这两方面原因,我们去掉了客户操作系统中的磁盘I/O调度,使得所有I/O请求都直接提交给驱动,这样,既减少了冗余的操作过程,也使客户操作系统的I/O请求获得立即处理.当宿主操作系统采用默认的CFQI/O调度器①时,经过该优化,虚拟机按块写的性能提高了6.01%;而虚拟机按块读的性能提高了5.64%.但是,由于优化以后,客户操作系统中的所有I/O请求都按照先进先出的顺序进行处理,因此,难以对各进程的I/O带宽进行分配和控制.3.2.3简化客户操作系统网卡驱动网卡的NAPI技术是指以主动查询结合中断的方式降低中断发生的频率.在虚拟化环境中,客户操作系统所看到的是虚拟网卡,虚拟网卡并不能直接产生中断,并可能采用其它特定的事件通知机制代替中断机制.因此,客户操作系统网卡驱动中的NAPI功能多余,反而会浪费CPU时间.因此,我们去掉了客户操作系统网卡驱动中的NAPI功能,并测试比较了优化前后的系统性能,结果如图7所示.图7中可以看到该优化较大程度地改善了网络吞吐率,性能的提升超过了60%.4相关工作比较KVM虚拟机的I/O性能优化包括两方面:降低环境开销和优化客户操作系统.降低环境切换开销主要可以通过两个方面实行:(1)降低环境切换的频率;(2)降低每次切换的开销.降低环境切换频率主要是通过批量化的提交I/O操作,或者在可能的情况下减少设备中断.Sugerman等[2]在VMwareWorkstation上实现了批量发送:当切换的频率超过一定阈值时,可以将客户操作系统每一次发送数据的请求缓存到一个队列中,当下一次中断发生时,一次切换到Host进行中断处理和数据发送.该优化同时能降低虚拟IRQ传送的开销,因为每一批数据传送完成后,只需要传递一个IRQ.同时,Sugerman等[2]考虑优化客户操作系统的驱动协议,设计一个利于虚拟化的调用接口,例如可以节省大量访问设备状态的I/O指令,能避免虚拟机陷入VMM;也可以降低虚拟IRQ的发生率,从而降低VMM和VM的切换频率.借鉴半虚拟化的思路,Russell[3]等提出了virtio,virtio是一种通用的设备驱动,为块设备和网卡提供了相同的处理流程,可以用于多种不同的VMM.其实现主要是在客户操作系统和VMM之间提供一个基于共享内存的环状缓冲区,客户操作系统和VMM分别作为消费者和生产者,通过环状缓冲区进行数据交换,此外,实现了一套事件通知机制,当①AxboeJ.TimeSlicedCFQI/OScheduler.[Online]http://Page7降低每一次切换的开销是要减少切换时所做的工作,Sugerman等[2]修改了VMwareWorkstation上运行的客户操作系统的进程切换:当切换到空闲进程(idleprocess)时,不需要切换进程的页表结构,因为idle是一个内核线程,可以使用任何一个进程的内核页表.该优化把MMU引起的虚拟化开销降低了近一半.Sugerman等[2]还对VMwareWork-station提出了旁路宿主操作系统的优化:因为VMwareWorkstation的每一次虚拟机的I/O操作都要经过客户操作系统-VMM-宿主操作系统之间的切换过程,若由VMM直接访问硬件设备,则能降低至少一半切换开销.切换时的开销还有一方面表现为切换后TLB、Cache等会发生失效.Menon等[4]优化了Xen使客户操作系统支持超大页(superpage)和全局页面映射(globalpagemapping)等高级虚拟内存功能,极大降低了TLB的失效率.此外,如果虚拟机能够直接访问硬件设备,则可极大降低环境切换的开销.近年来,出现了一些新技术和规范,如IntelVT-d①、AMDIOMMU②能够保证虚拟机I/O地址空间的隔离性,并在PCI总线桥上安装一个类似传统MMU的地址转换设备,提供硬件中断转发机制;PCI-SIG提出了SR-IOV和MR-IOV规范③,旨在定义一个可分割共享的I/O设备的规范,按照该规范设计的PCIe设备,将具有统一的、可由多个虚拟机分割共享的界面.目前已经有SR-IOV设备面世,Dong[5-6]等已经实现了虚拟机对SR-IOV网卡的直接访问,并达到了接近Native的性能.这些硬件支持的出现,使得虚拟机能够直接访问物理硬件,从而提高了性能,也简化了I/O设备虚拟化的实现.因此,针对软件的优化应该着重于如何优化客户操作系统,使得它更适应虚拟化环境,或者使客户操作系统、VMM和宿主操作系统配合得更有效.有数据被放到缓冲区以后,作为消费者的一方会接到通知,这套事件通知机制支持屏蔽,因此可以实现批量操作,避免频繁发生环境切换.Ram等[7]对客户操作系统的优化包括3个方面:(1)实现LRO(LargeReceiveOffload),该技术通过将多个数据包中的数据合并成一个TCP/IP数据报,使一次协议栈的处理能处理大量数据.(2)软件预取,每次处理虚拟中断时,通常是循环处理一组数据包,可以在每轮循环中,访问下一轮要处理的数据报的报头,进一步地访问下两轮要处理的数据报的缓存结构,从而降低访存的延迟.(3)降低缓冲区大小,将缓冲区改成半个页面的大小,能够减小缓冲区的工作集,从而降低TLB的失效率.Menon等[4]改进了Xen的虚拟网卡接口,提供了现有的大部分网卡支持的分载(offload)功能(若底层的硬件并不支持分载,则由DriverDomain模拟,也能提高性能),包括散/聚(Scatter/Gather)I/O,TCP/IP校验和分载(TCP/IPChecksumOff-load)、TCP分段分载(TCPSegmentationOffload,TSO).Scatter/GatherI/O支持不连续的内存地址做连续的DMA操作;TSO减少了整个系统需要处理的数据包数量,提高了系统的整体性能;TCP/IPChecksumOffload降低了客户操作系统的负载.我们主要从两个方面进行优化:一是降低环境切换开销,二是消除客户操作系统中的冗余操作.通过修改客户操作系统,使邻近的I/O操作批量陷入VMM,并且降低时钟频率,从而降低虚拟机陷入(VMExit,指虚拟机在执行到敏感指令时从虚拟机运行状态陷入到虚拟机管理器(VirtualMachineMonitor,VMM)的运行状态)频率.通过修改客户操作系统,可以去掉那些只有在非虚拟环境下发挥作用的操作,减少了虚拟机的运算量.我们的优化工作,一方面可以用于要求高I/O性能的环境;更重要的,虚拟机的早期目标仅在于提高物理机器的利用率,考虑的是如何将大量遗产服务器整合到部署了虚拟机的少量主机上,因此,虚拟机上运行的操作系统必须是遗产操作系统,这些操作系统是面向物理机器开发的,包含了一些不适应虚拟化环境从而影响虚拟机性能的因素.但是当虚拟机的应用越来越广泛,虚拟机的用途早已不限于整合遗产服务器,对虚拟机的性能和可用性提出了更高的要求.面向虚拟化环境,需要进一步研究如何裁剪并补充原有的操作系统,使其更适应虚拟化环境.我们已经看到,Linux内核已经在逐渐纳入对虚拟化的支持.但是,什么样的操作系统更适合虚拟化①②③Page8的运行环境?如何构造一个简洁高效的虚拟机操作系统?还没有较为系统的结论.我们的工作表明操作系统中的影响性能的因素分布较散,类型多样,目前还难以提出一种通用的解决方案,本文的工作可以为今后系统性研究提供借鉴.5结束语对KVM虚拟机I/O性能的测试表明,现有的客户操作系统中存在一些不适应虚拟化环境的因素,影响了虚拟机的I/O性能.因此针对KVM虚拟机环境,我们修改了客户操作系统,降低了虚拟机运行时发生环境切换的频率,简化了客户操作系统的操作,优化了KVM虚拟机的I/O性能.现有的硬件虚拟化支持已经极大地提高了虚拟机的性能并降低了虚拟化的实现复杂度,因此,未来的方向应该着重改进操作系统,使得操作系统更加适应虚拟化环境.下一步工作中,我们继续从客户操作系统入手,找到其不适应虚拟化I/O环境的其它因素进行优化.此外还要进一步实现动态优化,从而无需修改客户操作系统的源码,而在其运行时,根据其运行特征,对影响虚拟机性能的操作进行动态的优化和二进制代码替换.WANGXiao-Lin,bornin1972,Ph.D.,associatepro-fessor.Hisresearchinterestsincludesystemvirtualizationandgeographicinformationsystem.YANGLiang,bornin1986,M.S.candidate.Hisre-searchinterestsfocusonsystemvirtualization.BackgroundRecently,virtualizationtechnologyisdevelopingquick-ly.Someexcellentvirtualmachinemonitorsaremoreandmorewidelyused.Viaoptimizationsinsoftwareandexten-sioninhardware,virtualizationofCPUandmemoryisnowmuchimproved.Theperformanceisnearlythesametothe
