Page1群组通信的通用可组合机制田有亮1),3)马建峰2)彭长根3)姬文江1)1)(西安电子科技大学通信工程学院西安710071)2)(西安电子科技大学计算机学院西安710071)3)(贵州大学理学院贵阳550025)摘要在通用可组合框架下研究群组通信问题.首先,作者在UC框架下分别提出群组通信模型的理想函数SAGCOM、基于身份签密模型的理想函数IDSC和群密钥分发模型的理想函数GKD.其次,构造了UC安全的基于身份签密协议πIDSC,同时,证明了基于身份的签密协议πIDSC安全实现理想函数IDSC当且仅当相应的基于身份的签密协议IDSC是安全的.最后,利用基于身份的签密协议πIDSC,提出了一种群组通信机制πSAGCOM,该机制在(IDSC,GKD)-混合模型下能安全实现群组通信的理想函数SAGCOM.关键词通用可组合安全;理想函数;安全群组通信;基于身份签密;多对多群组通信1引言众所周知,多播被广泛有效地用于具有多接收者的通信机制,如一对多、多对多的面向群组的网络应用和公开广播等.然而,多播通信模型的安全缺陷成为阻碍多方安全协议应用的有效性和大规模发展的瓶颈.当前广大学者更多地关注多播通信协议的Page2传统安全定义:单个实例的安全性问题;对于更为复杂的多播群组通信的实例场景没有给予足够的关注.因此,在通用可组合框架(UniversallyCompos-ableframework,UCframework)下,研究多播的群组通信机制是非常有理论意义和实际应用价值的.1.1相关工作Fiat和Naor[1]引入广播加密算法,该算法提供一种安全广播密钥信息的方法;该方法满足只有用户的授权集(privilegedset)能解密信息而任何其他k个用户结盟都不能得到任何有用的信息.Wang和Wu[2]利用双线性对(bilinearpairing)提出基于身份的认证多播方案,并给出方案的安全性证明.然而,Lin等人[3]发现在内部伪造攻击下[2]的方案是不安全的.Mu等人[4]提出另一个基于身份的认证广播加密方案.该方案允许每个发送者动态广播消息给一个群组,其群组成员的秘密密钥是利用一多项式函数构造的.Hur等人[5]基于身份的签密技术提出一种认证群组通信方案.方案的安全性满足适应性选择密文攻击安全性,同时利用基于身份的签密方法解决发送方的身份认证问题.然而,上述所提方案都未在通用可组合框架下研究群组通信机制的安全性问题.因此这些方案不满足通用可组合安全.1.2通用可组合框架通用可组合框架(UniversallyComposableframework,UCframework)[6]为分析密码协议安全性提供了非常强的安全保障.特别是,一个协议在该框架被证明是安全的,则能保证即使该协议和其它协议并行运行或者该协议作为一个大协议的组件,该协议仍然是安全的.在UC框架下理想函数(idealfunctionality)是一个非常重要的安全概念;它用作一个不可攻陷的可信方,并能实现执行协议的具体任务.到目前为止,已有许多基本的理想函数被定义,如消息认证理想函数AUTH、密钥交换理想函数KE、公钥加密理想函数PKE、签名理想函数SIG、承诺理想函数COM、零知识证明理想函数ZK、忘传输理想函数OT、匿名Hash认证理想函数Cred认认证理想函数CDA函数TNC理想函数BAUTH我们在UC框架下,利用基于身份的签密技术研究安全认证群组通信机制.首先我们在UC框架下形式化基于身份的签密模型.接下来在我们的模型下构造了UC安全的基于身份签密协议.由于基于身份的签密协议仅能提供一对一的应用通信机制,我们为多对多的网络应用设计了群组密钥分发的通用可组合模型.在UC框架下,应用基于身份的签名和群组密钥分发的组合,构造了认证群组通信机制并证明它是UC安全的.此外,我们的群组通信机制能保证通信的数据保密性和发送者的身份认证.其主要贡献如下:(1)我们提出一个通用可组合的群组通信模型,包括基于身份签密的理想函数IDSC、群组密钥分发理想函数GKD及安全认证群组通信理想函数SAGCOM.(2)根据IDSC,我们设计协议πIDSC在混合模型下实现基于身份签密的理想函数.同时证明πIDSC安全实现理想函数IDSC当且仅当相应的基于身份的签密协议IDSC是关于IND-IDSC-CCA2和EXT-IDSC-CMA安全的.(3)基于IDSC和GKD,在(IDSC,GKD)-混合模型下,我们构造一个协议πSAGCOM实现安全认证群组通信的理想函数SAGCOM.本文第2节简要介绍UC框架和基于身份的签密方案;在第3节,我们提出基于身份的签密方案理想函数、群组密钥分发理想函数和安全认证群组通信理想函数;UC框架下基于身份的签密方案在第4节被提出;而在第5节,我们提出安全认证的群组通信的UC机制;第6节给出结论.2准备知识在本节,我们简要概述UC框架[6]和基于身份的签密方案[11]等基本概念.2.1UC框架首先,UC框架定义了现实环境(realworld).现实环境描述协议的真实运行情况,其中所有参与者在真实敌手存在的环境下运行真实协议.其次,UC框架定义了理想环境(idealprocess)用来描述密码协议的理想运行情况.在理想环境下,存在虚拟参与者、理想敌手和理想函数.参与者间以及敌手与参与者不直接通信;所有参与者和敌手均与理想函数交互.理想函数本质上是一个不可攻陷的可信角色,用来完成密码协议所需的理想运行环境下满足安全需求的理想功能.在UC框架中,环境用来模拟协议运行的整个外部环境(包括其它并行的协议、攻击者等).可以与所有的参与者以及Page3攻击者和直接通信,不允许直接访问理想函数.定义1(UC仿真).我们称协议πUC-实现理想函数如果对于任何现实环境中的敌手,存在理想环境下的敌手使得对任何环境,至多能以可忽略的概率来区分:存在真实敌手以及真实协议π的现实环境和存在理想敌手以及理想函数的理想环境.即REALπ,,≈IDEAL,,.如果协议π能UC-实现理想函数,我们就称协议π在UC框架下安全实现理想函数,也称协议π是UC安全的.定理1(组合定理).假设协议ρ安全实现理想函数,并且π是-混合模型下的协议.我们称协议πρ/(协议π中的理想函数被协议ρ替代)UC-实现协议π.特别地,在-混合模型下,如果协议π安全实现理想函数ζ,则协议πρ/也安全实现协议ζ.根据组合定理,在UC框架下,一个“大的”协议能够通过一些UC安全的子协议来进行构造,实现指定协议任务的同时保证其安全属性.这点(可组合性质)是非常重要的,因为一个复杂且安全的系统通常被分解成许多子系统,而每个子系统具体实现某个安全任务.2.2基于身份的签密本节基于身份签名方案(Identity-BasedSign-cryptionScheme,IDSC)的相关定义出自文献[11].IDSC方案.基于身份的签密方案IDSC由算法Setup、Extract、Signcrypt和Unsigncrypt组成.这些算法的功能描述如下:(1)Setup算法生成全局公开参数.输入安全参数1k;输出系统主密钥(mastersecretkey)s和相应的系统主公钥(masterpublickey).(2)Extract算法生成用户的密钥.输入系统主密钥和用户的公开身份;输出用户的私钥.(3)Signcrypt算法产生签密消息的密文.输入消息m、签密者的私钥和接收者的公开身份;输出签密密文σ.(4)Unsigncrypt算法验证签密密文的合法性并输出签密密文的明文信息.通过Unsigncrypt算法,接收用户利用他的私钥和签密者的公开身份解签密密文σ并恢复相应的明文m;同时,接收者能验证签密密文σ的合法性.如果通过验证,则输出⊥;否则,输出⊥.安全需求.一个基于身份的签密协议中,保密性(confidentiality)和不可否认性(nonrepudiation)总是被要求的.下面我们通过两个实验来说明这两IDSC,(1k)个主要安全需求.ExpIND-CCA2(s,Ppub)←Setup(1k)(sks,IDs)←Extract(s,Ppub,IDs)(skr,IDr)←Extract(s,Ppub,IDr)(m0,m1,state)←AΟE,Οs,Οu1(IDs,IDr)bσb←AΟE,ΟS,ΟU2(IDs,IDr,m0,m1,σ,state)如果b≠b,则返回1;否则返回0.如果Unsigncrypt(IDs,IDr,σ)≠⊥,则返回1;否则返回0.这里OE,OS和OU分别代表解析(Extract)Ora-cle、签密(Signcrypt)Oracle和解签密(Unsigncrypt)Oracle.第1个实验关注的是消息的保密性,并采用来自于公钥加密的安全概念IND-IDSC-CCA2.胜利如果该实验以不可忽略的概率返回1.第2个实验关注的是消息的不可伪造性,并采用来自于公钥签名的安全概念EXT-IDSC-CMA.胜利如果该实验以不可忽略的概率返回1.接下来我们定义敌手在IND-IDSC-CCA2安全性概念下攻破IDSC协议的优势为IDSC,(1k)=|2Pr[ExpIND-CCA2advIND-CCA2协议IDSC是关于IND-IDSC-CCA2安全的,如果优势advIND-CCA2能力和查询Oracle的次数是关于ε多项式界定的.我们定义敌手在EXT-IDSC-CMA安全概念下攻破IDSC协议的成功率为协议IDSC是关于EXT-IDSC-CMA安全的,如果成功率SuccEXT-CMA攻击能力和查询Oracle的次数是关于ε多项式界定的.3理想函数SuccEXT-CMA本节,我们主要考虑的是在理想环境下安全群组通信和基于身份签密的主要协议任务和安全功能.基Page4于他们的安全需求,我们提出了相应的理想函数.3.1理想函数SAGCOM一个安全通信机制意味着一位参与者R或一群参与者G收到来自于一些参与者S的消息m仅当这些参与者S的确已经发送消息m给R或G,并且敌手和非接收群体成员不能访问和浏览被传送消息的内容.显然,安全认证的群组通信的主要安全性质是保密性和认证性.具体地,所需考虑的安全需求包括信息的保密性、密文的认证性和签名的不可否认性.保密性.消息的保密性防止外部敌手和非群组成员解密群组消息.该性质使得通信参与者之间有效保护通信内容的秘密性.该性质是诸多密码协议的重要和主要性质,特别是加密协议.认证性.密文的认证性使得只有合法目的的接收者能确信:消息是被签名该消息的参与者所加密的;在整个消息传递过程中,一个外部敌手不能够重加密一个发送者的签名消息.这也意味着保证了密文的完整性.不可否认性.签名的不可否认性表示签名一个消息的发送者不能否认、篡改他/她的签名.签名信息也仅能被签名指定的接收者所验证.不可否认性也是许多密码协议的主要安全属性,特别是签名协议、消息认证码(MAC)等.在提出的形式化模型下,理想环境下的安全群组通信协议能形式化为一个混合协议:理想地访问“认证消息传输函数(authenticatedmessagetrans-missionfunctionality)”和“安全消息函数(securemessagefunctionality)”.实现这些功能的理想函数被记为SAGCOM,见图1.理想函数SAGCOM.参数化一些符号:泄露函数(leakagefunction)l:{0,1}→{0,1},一些参与者集合S和R.SAGCOM处理如下:当从一些参与者Si收到输入(Send,sid,T,m),其中Si∈B,BS和TR,如果sid=(B,T,sid)对于一些发送者S的子集,则·发送(Send,sid,T,l(m))给敌手.·产生一秘密延迟输出(Send,sid,m)给Ri,对所有Ri∈T.·记录B发送m给T并停机.·否则忽略该输入.当从Ri收到(Receive,sid,B,m),如果sid=(T,B,sid)对某些接收者集合R,则·发送(Receive,sid,B,l(m))给敌手.·产生公开输出(Received,sid,ok)给Si,对所有Si∈B.·记录T收到来自于B的消息m并停机.·否则忽略该输入.·泄露m给敌手并记录P是被攻陷的.·如果敌手提供m,且P∈S,及还没有输出给接收者,则输出(Send,sid,m)给接收者并记录,并停机.当从敌手处收到(Corrupt,sid,P),其中P∈B∪T,则3.2理想函数IDSC这里,基于第2.2节IDSC方案的安全需求,我们定义基于身份签密的理想函数.该理想函数记为IDSC,其定义见图2.理想函数IDSC.IDSC作如下处理,其中P1,…,Pn是参与者,KGC是密钥生成中心,是理想敌手.当从一被攻陷参与者收到一消息,IDSC转发该消息给,同时当给以回复时,IDSC转发该回复给相应的被攻陷参与者.IDSC.Setup.当收到从KGC消息(IDSC.Setup,sid):·发送(IDSC.Setup,sid,KGC)给.·当从收到(IDSC.Setup,sid,PKs),则输出(IDSC.Setup,sid,PKs)给KGC.·记录(KGC,PKs)并标识其为‘fresh’.IDSC.Extract.当从一些Pi收到第一个消息(IDSC.Extract,sid,PKs),则发送(IDSC.Extract,sid,IDi,PKs)给,其中IDi是Pi的身份.当收到(IDSC.Received,sid),则发送(IDSC.Extract,sid,IDi,PKs)给Pi和KGC.IDSC.Signcrypt.当从Pi收到消息(IDSC.Signcrypt,sid,IDr,PKs,m),则·如果IDr=IDj对某些j,PKs=PKl对某些l且KGC未·否则发送(IDSC.Signcrypt,sid,IDi,IDr,PKs,m)给.当收到来自于的消息(IDSC.Signcrypt.Ciphertext,sid,IDi,IDr,PKs,σ),则·如果为存在记录(IDi,IDr,PKs,m,σ)对某些m,则输出·如果IDr=IDj对某些j,PKs=PKl对某些l和KGC未IDSC.Unsigncrypt.当收到来自于Pj的消息(IDSC.Unsigncrypt,sid,IDs,PKs,σ),则·发送(IDSC.Unsigncrypt,sid,IDs,IDj,PKs,σ)给.当·如果(IDs,IDj,PKs,m,σ)被记录,则输出(IDSC.Unsign-crypt.Plaintext,sid,IDs,IDj,PKs,m,σ)给Pj.·否则,如果IDs=IDi对某些i,PKs=PKl对某些l及sid,IDs,IDj,PKs,⊥,σ)给Pj.·否则,输出(IDSC.Unsigncryp.Plaintext,sid,IDs,IDj,3.3理想函数GKD在本节,为提供可信的“群组密钥分发服务(thegroupkeydistributionservice)”,我们形式化群组密钥分发的理想函数GKD,其详细定义见下页图3.4安全实现IDSC本节提出通用可组合的基于身份签密协议πIDSC,同时在混合模型下证明.4.1协议πIDSC协议πIDSC在图4中被给出.应用基于身份的签密方案IDSC,以一种自然的方式给出协议πIDSC的构Page5造.我们的签密机制不拘泥于任何具体的基于身份签密方案的形式,是一种普遍实用的通用可组合安全的签密机制.理想函数GKD.设P={P1,…,Pn},KGC和分别为参与者、密钥生成中心和理想敌手.GKD处理如下:当从KGC收到输入(GKD.Distribute,sid,s),其中∈2P是访问结构,s是群组密钥,则当从Pi收到输入(GKD.Recover,sid),则·如果存在sid=(KGC,,sid),则1.发送(GKD.Distribute,sid,|s|)给.2.产生一秘密延迟输出(GKD.Distributed,sid,si)给Pi,3.记录(sid,s)并停机.·否则,停机.·一旦(sid,s)被记录,则忽略任何后续的分发输入.·增加Pi到集合T(初始阶段T··=).·如果有一个集合T∈及分发群组密钥s的记录,则1.发送(GKD.Recover,sid,|s|)给.2.产生一秘密延迟输出(GKD.Recovered,sid,s)给T中3.记录(sid,s)并停机.·否则停机.当从收到(Corrupt,sid,Pi),则·增加Pi到攻陷集合C(初始阶段C··=).·如果敌手提供一非法的s,并且(GKD.Recovered,sid,si)未被写入到T中任何未被攻陷的参与者的输入带子·如果敌手提供一非法的s,并且(GKD.Recovered,sid,si)未被写入到T中任何未被攻陷的参与者的输入带子sid,si)给敌手.·否则停机.协议πIDSC.设协议中参与者为P={P1,…,Pn},KGC是密钥生成中心,为现实中的敌手.则πIDSC工作如下:IDSC.Setup.首次输入(IDSC.Setup,sid),KGC运行算法Setup.KGC得到系统公私钥对(s,Ppub),并输出(IDSC.Setup,sid,(s,Ppub)).IDSC.Extract.当首次输入(IDSC.Extract,sid,IDi),Pi运行算法Extract.Pi得到它的私钥ski,并输出(IDSC.Extract,sid,(ski,IDi)).IDSC.Signcrypt.当输入(IDSC.Signcrypt,sid,Ppub,IDr,m),Pi得到σ=Signcrypt(ski,Ppub,IDr,m),并输出(IDSC.Signcrypt.Cipher-text,sid,IDr,m,σ).IDSC.Unsigncrypt.当输入(IDSC.Unsigncrypt,sid,Ppub,IDs,σ),Pi得到m/⊥=Unsigncrypt(IDs,Ppub,ski,σ),并输出(IDSC.Unsigncrypt.Plaintext,sid,m/⊥,σ).4.2协议πIDSC的安全性证明定理2.设IDSC是基于身份的签密方案.协议πIDSC安全实现理想函数IDSC当且仅当IDSC是IND-IDSC-CCA2和EXT-IDSC-CMA安全的.证明.必要性(反证法).假设协议πIDSC安全实现理想函数IDSC,但是IDSC不是IND-IDSC-CCA2和EXT-IDSC-CMA安全的.由于IDSC不是IND-IDSC-CCA2和EXT-IDSC-CMA安全的,那么我们构造环境和现实中的敌手使得对任何理想的敌手,环境能够区分与现实环境下的敌手和现实中的参与者运行协议πIDSC,还是与理想环境下的敌手和愚蠢的参与者(Dummyparties)访问理想函数IDSC.(1)假设IDSC不是IND-IDSC-CCA2安全的,即存在敌手有不可忽略的优势advIND-CCA2协议IDSC.攻击系统描述如下:在ExpIND-CCA2的开始阶段,敌手被给定两个公开身份IDs和IDr分别属于目标发送者和接收者.攻击由两阶段组成:find-阶段算法1和guess-阶段算法2.1选择两个相同长度的消息m0和m1,而2被给以一个挑战密文σ并以1/2+ε的概率猜对b∈{0,1}.环境请求一个IDSC的实例,并作下述处理,并假定KGC是可信的及S和R中的参与者是未被攻陷的.①首先,通过输入(Setup,sid)以激活KGC对于sid=(KGC,sid),得到系统的公钥PKs并转发PKs给.②下一步输入(Extract,sid)以激活S和R对于sid=({S,R},sid),得到他们的公开身份IDs和IDr,并转发IDs和IDr给.③当投递消息m和两个不同的身份S和R(一个是发送者的身份而另一个是接收者的身份),通过(Signcrypt,sid,IDr,IDs,PKs,m)激活S,得到密文σ并转发σ给.④当投递一密文σ和一接收者的身份R,通过(Unsicrypt,sid,IDs,IDr,PKs,σ)激活R,得到明文m并转发m给.⑤当投递一身份IDt,通过(Extract,sid)激活KGC,得到相应的私钥skt并转发skt给.⑥当产生两测试明文(m0,m1),选择b←{0,1},通过(Signcrypt,sid,IDr,PKs,mb)激活S,得到一密文σ,并转发σ给作为测试密文.⑦当返回一猜测b∈{0,1},输出bb并停机.分析,注意他与现实环境中的敌手和协议πIDSC交互,则实例在环境看来,事实上就是与IND-IDSC-CCA2安全的IDSC协议交互.因此,在这种情况下b=b的概率至少是1/2+ε.然而,当与理想环境下的理想函数IDSC和任何敌手交互时,在环境看来,对的实例结果与随机变量b是统计独立的,因此在该情况下b=b的概率为1/2.(2)假设IDSC不是EXT-IDSC-CMA安全的,Page6即实验ExpEXT-CMA不可忽略的.我们构造的一个仿真实例,其中是一个以不可忽略的概率成功伪造签密的攻击敌手.①首先,激活.②接着,输入(Setup,sid)激活KGC对于id=(KGC,sid),得到系统公钥PKs并转发PKs.③当请求身份IDt,通过(Extract,sid)激活KGC,得到相应的私钥skt并转发skt给.④当投递一个消息m及两个不同身份S和R(一个是发送者身份而另一个是接收者身份),通过(Signcrypt,sid,IDr,IDs,PKs,m)激活S,得到密文σ并转发σ给.⑤当利用接收者身份R生成一个成功的伪造密文σ,通过(Unsigncrypt,sid,IDs,IDr,PKs,σ)激活R,得到一明文m并转发m给.⑥如果m不是‘fresh’,则输出0;否则输出接收者R的输出.显然,当与现实环境中的和现实协议πIDSC交互,以不可忽略的概率输出1,因能成功伪造一合法的签密.然而,当理想环境下的敌手和理想函数IDSC交互时,不能输出1.上述分析表明协议πIDSC安全实现理想函数IDSCIDSC是IND-IDSC-CCA2和EXT-IDSC-CMA安全的.充分性.只需证明如果IDSC是IND-IDSC-CCA2和EXT-IDSC-CMA安全的,则协议πIDSC安全实现理想函数IDSC.下面我们证明πIDSC安全实现IDSC.用关于愚蠢敌手(dummyadversary)的安全概念,我们构造理想敌手使得没有环境能以不可忽略的概率区分它是与理想环境下的理想函数IDSC和敌手交互还是与现实环境下的协议πIDSC和愚蠢的敌手交互.假设存在环境能区分这两种现实和理想环境下的交互.我们用该环境构造敌手攻破IND-IDSC-CCA2和EXT-IDSC-CMA安全的基于身份的签密方案IDSC.敌手处理如下,给定解析算法Extract,签密算法Signcrypt和解签密算法Unsigncrypt,并访问解析OracleOE,签密OracleOS及解签密OracleOU.首先随机选择e←{1,…,q}和s←{1,…,p},其中q是整个系统运行过程中参与者被解析的总次数(即访问解析Oracle的总次数),p是系统运行中签密消息的总次数(即访问签密Oracle的总次数).紧接着,仿真运行交互协议πIDSC系统,其中是愚蠢敌手.设mi为在一个运行实例中第i个要求签密的消息.(1)首先,激活.其次,输入(Setup,sid)激活KGC对于sid=(KGC,sid),得到系统公钥PKs并转发PKs给.(2)对于前e-1次被请求解析一些参与者的身份IDi,让解析方KGC输出ski=Extract(IDi).(3)在第e次解析参与者身份IDe,利用一对身份信息(IDe,IDf)查询它的解析OracleOE,其中IDf为上述固定用户的身份信息,并得到测试私钥ske.然后它转发ske给作为参与者Pe的私钥(它的身份是IDe).(4)对于余下的q-e次要求解析一些参与者IDi,让KGC输出ski=Extract(IDf).(5)对于前s-1次请求签密一些消息mi,让签密者返回σi=Signcrypt(mi).(6)在第s次请求签密消息ms,利用消息对(me,mf)查询它的签密OracleOS,其中mf为上述的固定签密消息,并得到测试密文σe.然后转发σe给作为ms的签密密文.(7)对于余下的p-s次请求签密消息mi,让签密方返回σi=Signcrypt(mf).(8)解签密方Pi被输入消息(Unsigncrypt,sid,IDs,IDi,σ)激活,其中IDs为签密方的身份及σ=σi对于某些i,让Pi返回相应的明文mi.如果σ与所有已签密的σi不同,则查询它的关于σ解签密OracleOU,得到一个值v,并让Pi返回给.(9)当停机,输出的输出并停机.这里,对于某些安全参数1k,假设我们有EXECIDSC,,(1k)-EXECπIDSC,,(1k)>ε.接下来分析能成功区分两种环境的概率.设随机变量Xi为环境在理想环境下与理想敌手和理想函数IDSC交互的输出.容易看出,在理想环境下X0和Xq+1是统计接近于的输出,而Xq和Xq+p与的输出是能够被区分的.因此我们能指出在IND-IDSC-CCA2实验ExpIND-CCA22pq概率猜对b,同时实验ExpEXT-CMAε/2q的概率返回1.这就表明,如果IDSC是IND-IDSC-CCA2和EXT-IDSC-CMA安全的,则协议πIDSC安全实现理想函数IDSC.5安全实现SAGCOM在本节,我们提出通用可组合安全认证群组通信机制πSAGCOM并证明该机制在(IDSC,GKD)-混合模型下能安全实现理想函数SAGCOM.Page75.1系统描述我们考虑的网络环境是有一个集中化的密钥服务器和存在多个多播控制者.群组G={G1,…,Gm}中的一个发送者作为多播控制者,负责掌管群组密钥.设R={R1,…,Rn}是普通用户集合.密钥服务器作为一个KGC生成系统的公开参数和网络中发送者群组和用户的密钥.5.2协议πSAGCOM信协议πSAGCOM.协议πSAGCOM详细描述见图5.ProtocolπSAGCOM.πSAGCOM协议参与者包括发送者群组G={G1,…,Gm}、接收者群组R={R1,…,Rn}及密钥服务器KGC,则协议πSAGCOM包括SAGCOM.Setup、SAGCOM.Extract、SAGCOM.Signcrypt和SAGCOM.Unsigncrypt4个算法,具体描述如下:SAGCOM.Setup.当首次输入(SAGCOM.Setup,sid),KGC运行算法Setup:我们在(IDSC,GKD)-混合模型下提出群组通·KGC得到两密钥对(sG,PG)和(sR,PR).·输出(SAGCOM.Setup,sid,(sG,PG),(sR,PR).SAGCOM.Extract.当首次输入(SAGCOM.Extract,sid,ID),Gi∈G(resp.Ri∈R)运行算法Extract:·KGC发送(GKD.Distribute,sid,sG)(resp.(GKD.Dis-tribute,sid,sR))给GKD.·Pi(resp.Ri∈R)从GKD得到他的私钥sGi(resp.sRi).·输出(SAGCOM.Extract,sid,(sGi,IDGi))(resp.(SAG-COM.Extract,sid,(sRi,IDRi))).SAGCOM.Signcrypt.当输入(SAGCOM.Signcrypt,sid,PR,IDR,m),Gi∈G运行算法Signcrypt:·Gi∈G得到σi=Signcrypt(sGi,PR,IDR,m).·Gi∈G发送σi给R.·输出(SAGCOM.Signcrypt.Ciphertext,sid,IDR,m,σi).SAGCOM.Unsigncrypt.当输入(SAGCOM.Unsigncrypt,sid,PG,IDG,σ),Ri∈R运行算法Unsigncrypt:·群签密生成阶段1.Ri发送(GKD.Recover,sid)给GKD.2.Ri得到σ.3.输出(GKD.recover,sid,σ).·群签密验证阶段1.Ri发送(GKD.Recover,sid)给GKD.2.Ri得到m/⊥=Unsigncrypt(IDG,PG,sRT,σ),其中3.输出(SAGCOM.Unsigncrypt.Plaintext,sid,m/⊥,σ).5.3协议πSAGCOM的安全性证明定理3.在(IDSC,GKD)-混合模型下,协议πSAGCOM安全实现理想函数SAGCOM.证明.设是现实中的敌手与现实中的参与者运行的协议πSAGCOM交互.我们构造一个理想敌手使得任何环境不能以不可忽略的概率区分:在(IDSC,GKD)-混合模型(记为REAL)下与敌手和协议πSAGCOM交互,还是在理想模型(记为IDEAL)下与理想敌手和理想函数SAGCOM交互.构造理想敌手.敌手运行的一个仿真副本,因此通常又称为仿真器.来自于环境的任何输入都将转给敌手,同时的任何输出都将拷贝给作为其输出T.(1)仿真KGC.当一个未被攻陷的KGC通过输入(SAGCOM.Setup,sid)被激活,从SAGCOM得到该信息,并为敌手仿真协议πSAGCOM.①当从IDSC得到(IDSC.Setup,sid),发送消息(IDSC.Setup,sid)给,然后转发的回复给IDSC.②当从IDSC得到(IDSC.Extract,sid,ID),发送消息(IDSC.Extract,sid,ID)给,然后转发的回复给IDSC.③当从GKD收到(GKD.Distribute,sid,|s|),发送消息(GKD.Distribute,sid,|s|)给,然后转发的回复给GKD.(2)仿真发送者.当未被攻陷的参与者Si通过输入(Send,sid,T,m)被激活,其中Si∈BS和TR,从SAGCOM得到该信息,同时为仿真协议πSAGCOM.①当从SAGCOM得到(Send,sid,T,l(m)),发送消息(Send,sid,T,l(m))给,然后转发的回复给SAGCOM.②当从IDSC收到(IDSC.Extract,sid,PKs),发送消息(IDSC.Extract,sid,PKs)给,然后转发的回复(IDSC.Received,sid)给IDSC.③当从IDSC收到(IDSC.Signcrypt,sid,IDi,IDr,PKs,|m|),发送消息(IDSC.Signcrypt,sid,IDi,IDr,PKs,|m|)给,然后转发的回复(IDSC.Signcrypt.Ciphertext,sid,IDi,IDr,PKs,σ)给IDSC.(3)仿真接收者.当未被攻陷的参与者Ri通过输入(Receive,sid,B,m)被激活,其中Ri∈TR,BS,从SAGCOM得到该信息,同时为仿真协议πSAGCOM.①当从IDSC收到(IDSC.Extract,sid,PKs),发送消息(IDSC.Extract,sid,PKs)给,然后转发的回复(IDSC.Received,sid)给IDSC.②当从IDSC收到(IDSC.Unigncrypt,sid,IDs,IDj,PKs,σ),发送消息(IDSC.Unigncrypt,sid,IDs,IDj,PKs,σ)给,然后转发的回复(IDSC.Unigncrypt.Plaintext,sid,IDs,IDj,PKs,m/⊥,σ)给IDSC.③当从SAGCOM得到(Receive,sid,B,l(m)),发送消息(Receive,sid,B,l(m))给,然后转发的回复(Received,sid,ok)给SAGCOM.Page8(3)仿真攻陷.当攻陷一参与者,则也攻陷该参与者并将该参与者的内部状态提供给.这里任何参与者均不存在任何秘密的内部状态.IDEAL和REAL的不可区分性.基于我们构造的,我们定义3类事件,同时证明无论哪一个事件发生,REAL和IDEAL均是不可区分的.事件1.当一参与者Pi∈S∪R被攻陷,很容易观察到,在REAL下,根据理想函数IDSC、GKD和SAGCOM的程序规则,能完美仿真协议的操作.因此,在该情况下REAL和IDEAL是不可区分的.事件2.当部分参与者CS∪R被攻陷,如果C∈T则知道密文σ的明文信息m;其他情况下敌手不知道密文σ的明文信息m.根据GKD的功能描述,显然在REAL下能完美仿真协议的操作.因此,REAL和IDEAL是不可区分的.事件3.接收者Ri从SAGCOM得到消息(Received,sid,ok)为写入消息(Incomingmessage)(Send,sid,T,m),其中Ri∈T,然而参与者Si在消息被投递时未被攻陷,并且该参与者已发送了消息(Send,sid,T,m).然而,根据协议和理想函数IDSC、GKD和SAGCOM的程序规则,我们有:首先,接收者应该从IDSC得到一份合法的签密密文,因协议IDSC是IND-IDSC-CCA2和EXT-IDSC-CMA安全的;其次,如果未被攻陷的Si不发送消息(Send,sid,T,m),则消息m没有被IDSC签过密.因此,Ri从SAGCOM能得到(Received,sid,ok).上述分析表明,在(IDSC,GKD)-模型下安全认证的群组通信协议πSAGCOM安全实现其理想函数SAGCOM.6结论在本文,我们首次提出安全认证通信模型的UC框架.分别设计了基于身份的签密理想函数IDSC、群组密钥分发理想函数GKD和群组通信的理想函数SAGCOM.基于此,提出了UC安全的群组通信协议πSAGCOM,并证明在(IDSC,GKD)-混合模型下协议πSAGCOM安全实现理想函数SAGCOM.我们也在UC框架下分析了基于身份的签密模型.证明基于身份的签密协议πIDSC安全实现理想函数IDSC等价于相应的基于身份的签密方案IDSC是IND-IDSC-CCA2和EXT-IDSC-CMA安全的.
