Page1针对泊松流的截止期敏感的复杂事件处理资源分配模型谷峪1),2)于戈1),2)吕雁飞3)王义1)1)(东北大学信息科学与工程学院沈阳110819)2)(医学影像计算教育部重点实验室(东北大学)沈阳110819)3)(北京大学计算机科学技术系北京100871)摘要随着无线射频识别等监控技术的发展,事件流上的复杂事件处理技术得到了广泛的关注.现有的事件流处理技术主要提供尽最大努力(Best-Effort)式的服务来减少平均响应时间,这种方式并不能在确定的时间延迟需求下输出更多的结果.针对监控应用中的确定性服务质量需求,讨论了常见的泊松监控流上的截止期敏感的复杂事件处理最优化资源分配问题.从系统服务角度对事件的到达和复杂事件处理进行了理论分析和建模,提出了复合事件的截止期满足率模型和多事件流处理乱序反馈修正模型,进而给出最优化资源分配模型.通过合理的分配处理资源,保证了在实时限制下产生更多的正确结果,兼顾了复杂事件处理的实时性和正确性.实验结果表明,提出的相关的理论估算模型和资源分配方案是正确和有效的,对于进一步完善复杂应用下的固实时限制复杂事件处理框架具有重要的启发意义和实用价值.关键词泊松流;复杂事件处理;截止期敏感;资源分配模型;无线射频识别1引言在越来越多的应用中,数据是以流的形式产生的,对数据流进行高效实时的管理得到了广泛的关注.事件流是一种特殊的数据流,针对事件流的复杂事件处理技术可以有效地支持各类监控和跟踪应用,例如对人员活动、道路交通和网络访问的监控.与一般的数据流上基于选择、投影、滑动窗口连接和聚集这些关系操作不同,复杂事件处理侧重于从事件的角度探测数据之间的各种复杂的模式[1].当某个满足该模式的复杂事件发生了,就需要立即告知给用户,并作为进一步分析和行动的依据.特别地,随着以RFID(无线射频识别)技术[2]为代表的对象识别和跟踪技术的不断发展并逐渐融入了我们的日常生活,隐含各种监控对象时空信息的分布式的监控流将会高速地产生并大量地存在.例如,在一个RFID智能博物馆监控应用中,每个阅读器负责监控某个展台的人员情况,每个展台的RFID读数就构成了一个高速的事件流.为了查询不同展台监控的事件流之间的模式(如查询满足特定参观路线的游客),这些事件流会被汇聚到一个中央的服务器来执行复杂事件的处理.一方面,基于事件流的应用往往需要面对海量的数据,每个RFID阅读器同时可以感知上千个监控对象,而一个应用场景中可能存在上千个阅读器,因此高速产生的数据对系统的处理能力提出了挑战.另一方面,从服务质量角度来说,监控应用往往有比较高的实时性需求,特别地,除了针对平均延迟的软实时需求外,很多面向关键性任务的监控应用往往会有固实时的需求,即对每个监控结果设定结果有效的截止期.如果超过截止期才给出结果,给出的结果可能没有意义甚至造成危害.目前的复杂事件处理系统只提供尽最大努力式的软实时服务,在这种服务中,本质上,来自不同源的事件流被汇聚到一起,按照所有事件的发生时间进行先进先出式的在线处理,在有明确的延迟上限限制的固实时应用中,无法给出最多的满足条件的结果.因此,本文重点对基于确定性服务质量的复杂事件处理模型进行了研究,旨在现有的资源条件下,通过合理的为各个事件流分配不同的处理时间,从而输出最多的满足截止期要求的结果事件.特别地,由于很多的事件流监控应用都可以用泊松过程来反映数据的到达情况,因此本文通过满足泊松过程的事件到达为例,提出事件等待时间的分布评估方法和截止期的满足率模型.进一步,讨论了由于调度造成的处理乱序和相应的反馈修正模型,给出了相应的复杂事件处理资源分配框架,并用实验验证了本文提出模型和算法的正确性和有效性.2相关工作数据流查询处理已经得到了深入的研究,出现了一些典型的原型系统[3-6].Aurora系统[5-6]是由应用领域专家定义的一组标准化的二维服务质量图,每个服务质量图表示某个性能指标在不同取值时对应的收益,并根据运行时的收益变化实时调整资源分配.可见,这种策略本质上是为了尽可能获得更好的运行时服务质量.Sutherland等人[7]提出了一种数据流上服务质量驱动的适应性调度框架.在该框架中,系统包含一个调度算法池,系统运行过程中适应性地从调度算法池中选择合适的算法进行查询调度.但这种策略仍然考虑的是尽最大努力地查询性能,例如最大化输出速率或者最小化队列大小.QStream[8-9]中提出先验服务质量的概念,通过对数据的到达和处理进行先验的分析,进行针对截止期的可调度性验证.由于QStream是开发在一个实时操作系统之上的,它的服务质量确定性保证大都依赖于底层的实时操作系统环境,故它的服务质量保证具有很大的底层依赖性.事件流可以看做是一种特殊的数据流,但与传统数据流基于关系模型的处理方式不同,事件流定义的操作主要关注对事件之间基于时序和数值的模式匹配,更适合于各种复杂的监控应用场景.事件流Page3及其上的复杂事件处理技术近些年得到了越来越多的关注,已经取得很多代表性的成果.例如美国加州大学伯克利分校开发的原型系统SASE[1,10],其提供扩展的事件语言、事件查询处理器和操作优化策略等,实现了对数据的采集和清洗、基本事件生成、复合事件处理、事件归档以及对事件的查询;美国康奈尔大学开发的Cayuga系统[11-12],其提出了扩展的查询语言,并通过自定义的自动机模型和内部命名方法来高效地探测复合事件,并讨论了相关的系统实现的技术细节;美国德克萨斯大学阿林顿分校开发的EStream系统[13],其在数据流查询器的基础上,集成了连续事件查询器,利用规则检测数据流上的复合事件,考虑了高效的增量维护算法;美国达特莫斯学院开发的PQS系统[14],采用非确定性有限自动机、隐型马尔可夫过程HMM等方法对动态过程建模,以事件流为输入参数,通过对模型求解,从而发现产生这些事件的过程,实现过程查询和检测.此外,文献[15]对分布式环境下的复杂事件处理技术进行了深入的研究,提出了分割查询计划的优化方法.文献[16]提出了一种基于查询树的适应性的复杂事件处理策略,通过有效地调整查询计划来获取更高的查询处理效率.一些工作[17-18]还特别以无线射频识别技术为背景,对复杂事件处理技术和优化方法进行了研究.但是,现有的复杂事件处理工作都只提供针对软实时的尽最大努力的服务.虽然传统的网络监控领域往往只进行比较简单的数据管理操作,但对数据的到达和处理建模和可调度性验证有着广泛的研究,网络演算[19-20]就是其中非常有效的手段.通过网络演算分析网络所得到的结果是确定的和严格的,但往往给出的是以到达上限为基础的到达曲线和服务下限为基础的服务曲线,有着很大的资源预留,并且只要有任何的结果可能超过截止期,就不会通过可调度性的验证.文献[21]将网络演算的服务质量保证理论应用在数据流的查询处理中,为数据流上确定性的服务质量保证提供了一种有效可行的方法.同样这种策略没有关注复杂事件处理的特点,而且只能进行确定性的服务验证,而不是在给定资源的情况下,尽量输出最多的查询结果.排队论[22]在解决服务系统调度问题上提出了很好的理论模型,本文只是在进行截止期满足率统计性计算的时候扩展了在饱和服务状态下的排队论相关结论,因此主体内容并不是对排队论的扩展.此外,本文侧重讨论数据层的管理问题,无法采用实时系统领域的底层实时服务技术.综上,本文针对复杂事件处理应用的特点和资源分配的需要进行了到达和处理的有效建模,并提出了截止期敏感和基于处理乱序反馈修正的分时调度策略,从而给出了固实时限制下的复杂事件处理资源分配最优化的一种解决方案.3事件到达建模对于监控应用,一个基本事件实例可以建模为〈id,lid,ta〉,分别表示监控对象oi的ID、监控地点Υi的ID和事件的时间戳.每个监控地点的读数都属于同一类型的基本事件,用Ei表示Υi产生的事件类型,ei表示类型为Ei的一个实例,eji表示类型为Ei的第j个实例,tia表示ei的到达时间.由于监控数据是不断产生的,因此所有的ei对应一个事件流Si.复杂事件处理往往需要考虑不同类型的事件关联,通过不同类型事件的复合处理得到复合事件Ecompk.所有参与Ecompk匹配的基本事件ei称作Ecompk的子事件,Ecompk中的第一个到达的事件e1称作开启事件,最终导致Ecompk复合完成并输出的基本事件en被称作终止事件.匹配不同类型的事件无法依靠高效的本地处理完成,因此不同逻辑区域的事件流需要汇聚到一个集中的处理系统进行进一步的处理.对于该系统来说,可见的就是基本事件实例.本文就是要研究在集中端的处理系统中如何为各个事件类型分配处理资源.几乎所有的事件流应用都可以被归纳为对监控对象的识别、定位、跟踪和监控,根据基本事件的定义,每个监控地点的事件到达模型可以根据各个物体到达某个地点的情况进行分析.而基于随机过程的统计模型非常适合于描述各个监控对象的到达速率,而一些统计学方法,例如参数估计、假设检验和核密度估计等可以合理地确定相关的参数.特别的,泊松过程(泊松流)在现实应用的服务系统里被广泛地使用来表示长期的独立的用户到达特性,这同样适合于很多的监控应用.例如,图书馆的借书流、超市的付费流、博物馆的参观流和一些交通流都可以看作是一个泊松流.本文将采用泊松流作为典型的事件到达模型.式(1)给出了泊松过程的表达式,其中M(t)代表任意时间间隔t之内的基本事件到达总量.同样的,基本事件到达速率可以根据式(1)进行建模.参数λ可以根据应用特点经验值、学习集和其它约束条件进行确定和修正.Page4在一些特殊的监控应用中,监控对象oi可能存在从某个监控位置到下一个监控位置的最小时间的限制,这是因为某些服务必须要在某个监控位置完成,或者从监控位置Υi到Υj需要在路途上花费一定的时间.对于Ei和Ej,|tia-tja|Tmin,Ei.id=Ej.id表示了这种连续服务约束模型.在特定的应用中考虑这类与时间相关的约束,可以对到达和资源分配建模进行有效的修正.4基于多消耗模式的复杂事件处理建模为了进行高效的资源分配算法的研究,对复杂事件处理的代价进行合理的建模是必要的.本节将讨论复杂事件处理模型,将各种模型转化为近似的顺序操作,并结合监控应用的特点,提出多消耗模式下的操作模型,并对各种模型下的处理代价进行分析.4.1复杂事件处理建模首先,如果不考虑复杂事件处理中对同一类型重复事件的处理方式,定义以下的事件操作代数,该系统是一个闭合的代数系统.包含的操作有(1)时序操作(sequence).标记为SEQ(E1,E2),满足t1a<t2a,表示两个事件先后发生,这是事件流监控应用中最常见也最基本的一类时序操作,通过复合,可以表示成SEQ(E1,E2,…,En),表示多个事件先后发生;对于Ei为复合事件的情况,通过定义tbegin和tend,可以表示复合事件的顺序、重合和包含等关系.(2)非时序操作.包括:①并(conjunction),标记为CON(E1,E2),表示两个事件都已经发生,而不管它们的先后顺序,通过复合,可以表示成CON(E1,E2,…,En);②或(disjunction),标记为DIS(E1,E2),表示两个事件至少有一个已经发生,而不管它们的先后顺序,通过复合,可以表示成DIS(E1,E2,…,En);③非(negation),标记为NEG(Ei),表示事件Ei没有发生,该操作一般需要通过与顺序或时序限制操作一同使用来指定探测的范围.(3)限制操作.包括:①分组限制Partition(Ei,id),将各个监控对象按照id号进行分组后再分别进行探测,例如在RFID应用中,按照标签id分组是非常常见的;②时序限制TCons(Ei,TExp()),其中最常见的为Within(Ei,t1,t2),表示为t1<Ei.tend-Ei.tbegin<t2,用来限制整个复合事件的探测有效时间范围;③数值限制VCons(Ei,VExp()),表示对一个复合事件的数值限制,使用带有非时间属性的关系表达式进行约束;④排斥限制Continuity(Ei,c),表示在该复合事件Ei探测过程中是否不允许出现其它不相关事件,例如Continuity(Ei,ALL)表示不允许出现任何不相关的事件,而Continuity(Ei,Ei)表示不允许出现类型为Ei的不相关事件.以上操作可以混合应用,构成复杂的处理,表达各种复杂的操作语义.不考虑消耗模式,顺序模型SEQ可以用自动机模型五元组〈Q,Σ,δ,q0,F〉来表示,对于其它的操作模型,利用自动机模型,能够近似地转化为顺序模型.图1定义了几种常用操作的自动机表示,从中可以很容易地得出类似于SEQ的转化.监控应用主要用于跟踪监控对象的路径和行为,侧重关注各个原子事件时序模式,因此很少用到非时序操作,最常见的应用是普通的顺序操作和带时序限制的顺序操作.特别在一些应用中,需要单独跟踪各个监控对象,分组的顺序操作提供了这类功能.通过上面提出的转化方法,其它的操作都可以转化为近似的顺序操作,因此本文以SEQ为例进行讨论.4.2自定义消耗模式下的处理建模在事件探测中,为了更好地反映应用语义,还需要一些另外的约束.同一类型的事件在匹配过程中可能连续多次发生,不同的应用对这类重复事件的处理是不同的.另外,已经产生结果的事件是否还进行以后的匹配将会影响查询的结果.该问题即为消耗模式问题,这与主动数据库Snoop等工作[23]提出Page5的上下文环境的概念是类似的.大多数监控应用并不会采用非限制模式进行事件匹配,根据监控应用的特点,定义消耗模式对于解决具体的应用需求,给出正确的代价评估模型是非常重要的.对于同样的查询,在不同的消耗模式下会产生完全不同的结果.本质上,参与复合事件构成的每个事件类型对应一个状态,假设j表示某个事件空间,j={s1,…,sn}表示某个状态空间,si表示一个具体的状态实例.因为自动机从本质上给出了状态的转化,定义转化操作si→sj,转化代价C→的复杂度为O(1).某个状态实例都有一个当前的状态代表元ei∈j,代表元可能会发生变化,对于状态实例si,ekieli,特别是对于聚集模式,∑eki∑eli,其中∑eki可能是复合事件,转化的代价C的复杂度也为O(1).此外,可能发生状态空间的衍生,即ij,i={s1,…,sn}衍生出了状态空间j={s1,…,sn},即产生了新的匹配副本,一般来说,状态衍生的代价是不稳定的.下面以此为基础来定义监控应用中最常见的消耗模式类型.特别的,图2给出了具有稳定操作代价的消耗模式的自动机表示.(1)Recent模式.若有重复事件发生,则前一个重复的基本事件被后一个事件覆盖掉,总是最后一个子事件有机会参加复合事件的检测.即在符合复合事件逻辑的众多子事件中,距离终止事件最近的子事件作为检测结果复合事件的子事件.匹配成功后,在已到来的事件序列记录中那些不能够再参与下一次匹配的基本事件被删除(下一次匹配即与一个新的终止事件相匹配).例如公司保险柜中的财物丢失,总是怀疑是最后那个接近保险柜的人盗走了财物.所以对监控设备读到的多个人接近保险柜的重复事件,只取最后一个参加复杂事件的匹配.该模式需要状态转化和状态代表元转化,但不需要状态衍生.具体实现中,采用增量处理,各个事件流的单个事件的转化代价为一个常数Ctrans,如果考虑分组限制,则需要额外的常数代价Chash,对于终止事件,在某些应用下可能需要进行进一步的封装,因此需要额外的常数代价Ccomp.(2)First模式.若有重复事件发生,则从第2个重复的基本事件开始直到最后一个都忽略掉,总是第1个作为子事件参加复合事件的检测.即在符合复合事件逻辑的众多子事件中,先到先匹配.匹配成功后,在已到来的事件序列记录中删除匹配上的基本事件,不再参加以后的匹配.与Recent模式中对重复事件的处理相反,取的是第1个.例如,对商店关门后安全的监测,只关心谁是第一个破窗而入的人,这个人才是要抓捕盗窃犯,而随后进入商店的人可能是店主或者警察之类无关紧要的人.所以对监控设备读到的多个人进入商店的重复事件,只取第1个参加复杂事件的匹配.该模式只需要状态转化,但由于同一个状态的事件也需要与之前的重复事件进行比较,因此代价模型与Recent模型基本一致.(3)Chronicle模式.若有重复事件发生,每一个重复的基本事件都可以单独参加匹配.与First类型相似,在符合复合事件逻辑的众多子事件中,先到先匹配.在匹配成功后,在已到来的事件序列记录中删除匹配上的基本事件,不再参加以后的匹配.例如,对于集装箱运载安全问题,传送带某处的阅读器对传送带上同类物品集的识读,产生多个重复的事件.集装箱运到目的地,那里的阅读器对装入集装箱中的物品进行一一识读产生多个重复的事件.两处的事件一一对应才表示物品没有丢失.从本质上,该模式需要状态的转化和状态的衍生,不经过优化的处理的代价也是不稳定的.在具体实现中,可以通过设计一个二维的链表结构,一个链表的所有结点都是其它链表的头结点,这些衍生出来的链表表示衍生的状态空间,如图2中Chronicle模式所示,这样,所有的事件都能够确定插入的位置,只需要常数的插入链表的代价Cinsert就能高效地构建这个数据结构.对于终止事件,需要删除相应链表的额外常数代价Cdelete.(4)Cumulative模式.若有重复事件发生,所有重复的基本事件作为一个整体参加匹配.整体的开始时间为第一个事件发生的时间,结束时间为最后一个事件发生的时间.与Chronicle类型相似,在符合复合事件逻辑的众多子事件中,先到先匹配.在匹配成功后,在已到来的事件序列记录中删除匹配上的基本事件,不再参加以后的匹配.与前3种模式对Page6重复事件的处理方式不同,这种模式把每个重复的事件看做是整体的一部分.例如在医院,用监控设备监视病人心脏偷停状况,心脏偷停一次就向识读器发出信号,因此产生重复事件.若在一定时间范围内,重复的事件数量不超过某个上限,则不需要采取任何措施;否则,就需要对病人进行药物或手术治疗.该模式需要状态的转化和聚集的代表元转化,因为聚集的过程可以增量地完成,因此每个事件的处理代价都是常数Ctrans+Caggr.(5)Continuous模式.若有重复事件发生,每一个重复的基本事件都可以单独参加匹配.每个开启事件都能启动一次或多次复杂事件的检测,但终止事件就只有一个.在每次匹配结束后(匹配结果可能有多个),将时间戳在此次匹配的最终结果的终结事件之前的事件全部删除,没有机会再参加以后的匹配.例如,在智能超市里,N件同类商品离开货架,超市的出口处也有N件该种商品出现,却有m个人在结账口处对少于N件这类商品进行付账,那么这m个人都有可能是没有付账的人.该模式需要状态的转化、代表元的转化和状态的衍生,相当于匀速环境下窗口大小为1/vn的非限制模式.对于非终止子事件,只需要稳定地插入和标记指针的代价Cinsert,但对于终止事件,处理代价与流速有关.为了统一处理模型,本文也通过对各个事件流的流速期望表示来获得近似稳定的代价估计.根据推导,可以分析出终止事件的处理代价为k∑n-15截止期敏感的资源分配模型5.1截止期满足率模型根据统计性的到达建模,如果各个事件流的流速均服从泊松过程并且相互独立,在多数情况下,各个事件流的处理代价都是常数的.首先,假设有n个处理器,每个处理器负责处理一个事件流,通过这种模型,可以先不必考虑事件流之间的关系而仅仅侧重分析集中端对每个事件流的处理,实际操作中采用单处理器的分时调度.假设λ为泊松过程的参数,用来表示该事件流的事件平均到达速率.用常数μ表示在当前分配的处理资源下,单位时间能够处理的事件个数,同理tp=1/μ表示单位事件的处理时间.在上述模型的基础上,可以看出该模型可以适用于排队论中的M/D/1模型,其中M代表处理过程为泊松流,D代表服务代价是一个常数.假设ρ=λ/μ,对于每个事件流,假设到达时间为ta,等待时间为tw,处理时间为tp,tiw表示ei的等待时间.下面将逐步给出一些重要的扩展结论.根据排队论,可以证明,如果ρ<1,那么每个事件流上的每个事件的虚等待时间t~都存在,并且无论初始化条件如何,t~满足limx→+P{t~并且W(x)的L-S变换可以证明满足式(3)如果ρ1,那么能够得出式(4)成立.但在这种情况下,tw将不再满足任何的分布.对于M/D/1模型,当ρ<1时,等待时间的期望可以证明等于式(5)从上面的分析可以看出,事件等待时间取决于事件到达速率和事件处理时间,事件到达速率越大,处理时间越长,等待时间就越长.在极端的情况下,平均处理时间要大于平均的到达时间间隔,系统将会一直过载.对于一般系统,ρ<1作为一个先决的条件,应该得到保证.事件响应延迟tl=tw+tp,表示为等待时间和处理时间之和.一般来说,响应延迟反应了系统的实时特性,在监控系统中,经常要处理关键的任务,因此实时性是非常重要的指标,因此一般会规定延迟的上限td,超过这个上限,得到的处理结果就会失去实效性,甚至造成重大的危害.同理截止期ei.tD=ei.ta+td表示某事件必须在tD时刻前处理完毕,本文正是将延迟上限或者截止期作为评估资源分配算法的重要服务指标,td一般都由用户或者应用预先指定.同时,用σ表示能够在截止期内完成处理的事件比率,也称作截止期满足率.因此〈td,σ〉构成了监控应用中重要的服务质量,在分配资源一定的情况下,td越大,满足率σ越高.下式表示了td与σ之间的关系.P{tltd}=P{tw+tptd}=P{twtd-1/μ}σ,式(5)给出的平均等待时间无法分析截止期满足率而式(3)给出的L-S变换又很复杂,很难计算.在接近饱和服务的状态下,根据数学逼近理论,给定处理资源μ,可以证明事件响应延迟tl的概率密度近似估计如式(6)所示.Page7式(7)所示:f(x)=2(λ-λ2/μ)e-2(λ-λ2/μ)(x-1/μ),xtp同理,等待时间tw的分布概率密度估计函数如f(x)=2(λ-λ2/μ)e-2(λ-λ2/μ)(x),x0因此截至期满足率可以通过式(8)计算得到P{tw<td-tp}=∫td-tp如式(9)所示,θσ(μ)表示了给定μ的截止期满足率表达式.同理,给定σ和td,可以求出式(10)所示的最小分配资源.μ1+tdλ-(1+tdλ)2-2(λtdln(1-σ)+2λtd上述分析仅仅针对了单个的基本事件,但对于复杂事件处理,产生的结果是复合事件,需要定义复合事件的延迟上限tseqen是终止事件,直观上因为只有en处理完整个复合事件才能输出,非终止事件的tl与tseq关,复合事件的延迟上限是否满足是由终止事件的tl决定的.这相当于tseq的资源μn的不断增大,截止期满足率应该不断增大.但是实际上,此处没有考虑到在处理时发生乱序的问题,产生的复合事件有很多错误的结果,因此不能够只考虑给en分配尽可能多的处理资源.下节将对此进行讨论.5.2基于处理乱序的反馈修正模型本节首先从两个事件类型入手来分析处理乱序的问题,对于来自不同的事件流的事件,容易证明,某个事件先到达并不意味着它能够先被处理,即t1a<t2a/t1s<t2s,同时t1a<t2a/t1e<t2s,其中ts表示事件开始处理时间,te表示时间结束处理时间.对于SEQ(E1,E2),如果按照严格正常顺序,需要满足lt2w+ti(e1,e2),表示e2需要在e1处理完之后才可t1以开始处理,ti(e1,e2)代表到达时间间隔t1a-t2a.同理,乱序条件为t1根据式(6)和(7)给出的tl和tw的概率密度,可以推导出t1设hi=2λi-2λ2itig(x)=h1h2eh1(-max(t1进一步可得对应的分布函数如式(12)所示:但对于本文介绍的基于多消耗模式的自动机模型,实际上算法在处理e1的第一步都是进行状态的迁移,因此只要e1开始处理,即使没有处理完就开始处理e2,在一般的情况下,也不会造成错误的输出结果.进一步给出放宽的正常顺序限制为t1w<t2w+ti(e1,e2),同理乱序率条件为t1w>t2w+ti(e1,e2).因此可以对式(11)的密度函数进行简化.此时t1w-t2w的密度函数表示为计算可得t1w-t2w密度函数如式(13)所示此时t1w-t2w的分布函数如式(14)所示显然ti(e1,e2)0成立,因此给定ti,e1,e2的乱序率ω(e1,e2)表达式如式(15)所示:Page8假设两事件的到达时间间隔ti服从分布为f(x),此时f(x)受到达流特性、消耗模式、连续服务时间限制、分组限制和时序限制的影响,例如对于泊松流下的Recent模式,可以证明,若λ1>λ2,f(x)近似地服从均值为1/2λ1的负指数分布,反之,近似地服从1/2λ2的负指数分布.对于First模式,若λ1>λ2那么近似地服从均值为1/λ2-1/2λ1的负指数分布,反之,近似地服从1/2λ2的负指数分布;对于Cumulative模式,近似地服从均值为1/2λ2的负指数分布.其它各种情况的f(x)可以通过进一步地分析逐一得到,对于受连续服务时间限制,分组限制和时序限制的应用,可以通过选择积分的上下时间限制和除以分组数目的方式得到最大乱序率和平均乱序率.限于篇幅,具体的论述不在这里给出.给定f(x),可以得到平均乱序率wavg如式(16)所示:ωavg(E1,E2)=∫ωavg(e1,e2)是一个与μ1和μ2有关的函数,因此也可以记为ωavg(μ1,μ2).通过终止事件的截止期满图3满足率和正确率函数曲线(λ1=λ2=1000,μ=3000,td=1ms)i=15.3多事件类型的处理乱序率最小化模型本节将进一步讨论多个事件流参与的一般情况下的乱序率模型.不难得出,假设n个事件到达相互独立,那么n个事件等待时间的联合密度函数为∏ntiw(x),此时乱序率可以表示为ω(E1,E2,…,En)=1-∫∫∫Ω∏n其中的积分区域是在Ω=∧n-1维空间内进行的.可以将上式n重积分展开成n次足率模型,可以得出满足截止期的复合事件的个数,但在这些复合事件中,如果子事件发生处理乱序,产生的复合事件必然是错误的结果.从这种意义上,1-ωavg(μ1,μ2)反映了复合事件的正确率.因此θσ(μ2)(1-ωavg(μ1,μ2))表示了结果正确的并且满足截止期的事件比例.设μ表示所有资源给S1时,单位时间内处理e1的个数,根据处理代价的不同,μ=μ1+kμ2,特别的,如果S1和S2的事件处理代价相同,μ=μ1+μ2.因此两个事件类型的处理乱序的反馈修正模型相当于对下面的目标函数进行最优化求解,从而确定μ1和μ2.具体的,如图3所示,随着μ2的增加,满足率θσ(μ2)的函数值逐渐增加,但由于μ1处理时间较少,t1w增加,导致乱序率增加,1-ωavg(μ1,μ2)逐渐减少,因此θσ(μ2)和1-ωavg(μ1,μ2)相互制约,它们的乘积函数将会在λ2<μ2<μ的某个取值点出现峰值,按照这种结果进行资源分配将会真正满足〈td,σ〉的服务质量.积分的形式,即ω(E1,E2,…,En)=1-∫∫x2+t1,20t1w(x1)dx1.与两个事件类型一样,由于任意两个事件的到达时间间隔是不可知的,在更多的情况下,关心的是平均乱序率.设fi,i+1(x)是事件ei和ei+1到达时间间隔ti,i+1的密度函数,那么平均乱序率可由式(17)求得.Page9ωavg(E1,E2,…,En)=1-∫∫∫Ω与两个事件类型一样,fi,i+1(x)可以通过到达流的特性和消耗模式分析得到,所以上式可以求出.不失一般性,本节分析假设各个事件处理代价相同,当μ=μ1(1<in,μi=0),可得∑1inμi=μ.下节将说明处理代价不同时的标准化操作,当代价不同时并不影响本节的推导过程.因为到达特性是可以事先知道的,那么,函数ωavg是μi的n元函数,通常增大μi会使得处理的效率提高,但是,系统所能提供的总资源是有限的,μi不能过大,那么如何分配每个事件的处理资源μi,以使其平均乱序率最小是需要达到的目标.在实际中,每个事件的处理资源μi也不能分配得过少,最少不能少于事件到达的速度λi,特别是最后一个事件En,为了满足其QoS要求,更是有其最小的资源约束.针对以上分析,对于如何分配资源的问题有下面的定理.定理1.设平均乱序率函数形式为ωavg(μ1,μ2,…,μn),假设其连续并且存在偏导.设总资源是μ,设每个事件要求的最小处理资源是μmini,那么达到平均乱序率最小的资源分配方案μi是下面的方程组的解.μiωavg(μ1,μ2,…,μn)代表函数wavg对μi的证明.此问题实质上是有约束条件的最优化其中,偏导,t是辅助未知数.问题.形式化表示如下:μ1+μ2+…+μnμ约束了总资源消耗量的上限.易知当总资源仍有剩余时可以将剩余资源全部分配给E1事件此时乱序率不会增加,所以此约束可以改写为μ1+μ2+…+μn=μ.当ωavg对μi存在偏导时,由拉格朗日乘数法,构造辅助函数如下:F(μ1,μ2,…,μn)=ωavg(μ1,μ2,…,μn)+t(μ1+μ2+…+μn-μ),其中t是待定系数.F(μ1,μ2,…,μn)的驻点由下式确定:μ1ωavg(μ1,μ2,…,μn)+t烄μ2ωavg(μ1,μ2,…,μn)+t烅…μnωavg(μ1,μ2,…,μn)+t烆函数的最小值将在边界或驻点处取得.易知,降低事件En的资源分配,将会减慢事件En的处理速度,从而降低乱序率.所以,μn=μminn时乱序率最小.代入μn=μminn并化简得到定理得证.该最优化方程可用matlab最优化工具包进行求解,随着事件个数的增加,求解时间也会逐渐增加.由于上式求解过程比较复杂,下面的定理给出了乱序率的一个估算式.定理2.当事件的乱序率比较低,相邻事件乱序可以近似看作独立时,n个顺序事件的乱序率有如下估计式:wavg(E1,E2,…,En)≈1-∏n-1wavg(E1,E2,…,En)=P{Disorder(E1,E2,…,En)}证明.当Disorder(Ei,Ei+1)与Disorder(Ej,Ej+1)中无相同事件时,两事件间是相互独立的.而由定理中条件可知,相邻的乱序事件也可以近似看作独立的,故所有的两两乱序间均相互独立.由相互独立的事件的非事件知,任意的!Disorder(Ei,Ei+1)与!DisorderPage10(Ej,Ej+1)也是近似相互独立的,故有wavg(E1,E2,…,En)≈1-P{!Disorder(E1,E2)}…定理得证.需要说明的是,当事件类型较多,乱序率较大时,该估算式误差很大,不能采用,需要求定理1定义方程的数值解.如表1所示,给出了事件类型数为3和4时,根据最小乱序率模型得出的资源分配方法和乱序率值,其中ωavg表示基于定理1的数值解,而珔ωavg表示基于定理2的估计解.随着事件类型的增加,珔ωavg的误差将会逐渐增大.表1最小乱序率资源分配实例(μ=6000,μ狀=1200)SEQ(E1,E2,E3)μ1μ2μ3ωavg珔ωavg2997180312000.4140.38318521612133612200.7450.6655.4资源分配模型的说明根据上面的分析,对于一般情况下的复杂事件处理下的资源分配模型,相当于对下面的最优化模型表达式求解.该模型直接求解,代价较大,可以在定理1的基础上,考虑采用步长逼近的方法.因为知道函数的单调性,参照两个事件的情况,直到找到拐点值即可确定峰值.Γ表示最大的调整步数,一般Γ=20就可以得到比较准确的解,平均的调整步数只需要Γ/2.可以看出,本文提出的资源分配模型可以自然转化为抢占式分时调度的算法,下面通过分析比较来说明分时调度在解决截止期敏感问题上的优势.FIFO算法的特点是调度代价小,处理事件的吞吐量大,用于RFID事件处理中,可以保证事件处理不发生乱序;但是FIFO仅专注于事件的乱序率,并没有考虑到事件的QoS,是乱序率为0时分时调度的一个特例.分时调度方法兼顾了乱序率与事件的QoS指标,特别地,本文的策略可以通过采用循环控制的方法来避免采用线程调度的开销,所以要优于FIFO.EDF算法优先处理截止期优先的任务,但是事件处理中只有代表复合事件的终止事件带有延时要求,其它事件的截止期不易给出,若将其它事件的截止期定义为其复合事件的截止期,那么EDF算法相当于FIFO.但EDF算法要消耗一定的调度代价,所以效率还不及FIFO.其它的调度方法如短作业优先,优先权调度等没有考虑基于延迟的QoS,因此并不适合本文讨论的截止期敏感的事件处理.综上,本文使用分时调度方法来处理复杂事件.对于事件探测应用,在线到达要求调度具有一定的实时性,海量数据要求调度代价尽量小,而事件探测的语义又要求各事件之间处理尽量均衡以避免乱序的发生.分时调度较好地满足这些方面要求.分时调度方法将一台处理机虚拟地看成多台不同资源的处理机分别处理不同的事件,既能够以较小的调度代价很好地满足事件QoS要求,又能够将乱序率控制在一定的范围之中.另外,也容易将分时调度扩展到监控应用常见的分布式处理或者并行处理的环境中.以上说明都没有考虑到资源的标准化问题.由于各个事件流上的事件处理代价在某些情况下并不相同,因此在进行资源分配前,可能需要进行标准化.如果能够直接测量CPU资源单独运行每个事件流的单位时间的处理个数μ(1),…,μ(n),就可以根据它们的比值来进行标准化.对于不方便进行真实的在线测试的场合,可以根据处理某个类型事件ei的指令数Ins(ei)为依据,假设CPU单位时间能处理κ个指令,那么某个事件ei的处理时间可以表示为Ti=Ins(ei)/κ.此外,真正的R监控应用数据处理系统还要进行数据清洗、数据分析和集成等很多任务,因此只能分配给查询处理有限的处理资源.采用抢占式的分时策略,假设Si的分时周期为ticycle,tcycle为其它非查询处理任务分配的时间,即∑nticycle+tcycle=1,则tii=1ticycle=Ins(ei)/(ti基于本文资源分配模型的分时调度的基本时间分配算法.需要说明的是,因为所有流上的处理代价通过统一的自动机模型可以看作近似的常数,因此在具体实现的过程中,可以直接通过控制循环的次数来模拟分时调度的过程,而不必使用其它线程来控制分时调度,并没有浪费额外的CPU时间.算法1.分时调度资源分配模型算法.输入:CPU每秒处理的指令数目κ,各事件流上单事件输出:单位事件内分给各个事件流的处理时间ticycle1.tiPage112.tn3.iftn4.γ←(tn5.while(tn6.tn7.根据式(9)计算θσ(μn)8.根据或定理1或定理2计算min(ωavg)和9.ifmax(θσ(1-min(wavg)))=TRUE10.returntncycle←Ins(en)/(tn在本文中,仅仅以泊松过程做为典型的到达过程,分析了资源分配的模型.对于事件到达满足其它随机过程的情况,需要在截止期满足率计算方面参考排队论中的G/D/1模型.但由于G/D/1模型在一些情况下只能给出满足率分布的近似结果或者转换形式,需要对结果进行误差的估计和相应的处理.此外,对于多查询的复杂事件处理应用,本文提出的模型假设各个查询之间是相互独立的,并不存在基于查询共享的优化,每个查询都按照各自的资源分配算法来合理地分配资源.分析查询共享对本文模型和算法的影响是我们下一步的工作.6实验评估6.1实验设置本实验的硬件环境是兼容机2.4GHz的Pentium4CPU,主存为1GB,硬盘为120GB.软件图4截止期满足率模型实验结果环境是WindowsXP操作系统,VirtualStudioC++6.0编程环境,算法采用C语言编写.相关的函数求解使用了Matlab工具.我们以RFID智能博物馆监控为背景,模拟了满足泊松过程的事件流.实验涉及到的相关参数包括各泊松流参数λi、延迟上限td、总分配处理资源μ和各个事件流的分配处理资源μi等.本实验将分别验证处理代价模型、截止期满足率模型、乱序率模型的正确性以及基于乱序反馈的资源分配模型和相应的分时调度算法的有效性.在实验中,以应用中比较常见的First模式为例进行测试,并且通过调整分配给复杂事件处理的CPU处理资源比例,灵活地调整μ值.不失一般性,相关的实验结果同样适用于其它的消耗模式和复杂查询.6.2截止期满足率模型实验本实验对基于式(9)的截止期满足率模型进行了验证,因为该模型与事件类型个数无关,所以假设查询为SEQ(E1,E2),通过分别改变分配的单位事件处理时间t2间隔1/λ2的值,来测试实际的截止期满足率和理论值之间的关系.通过图4(a)~(c)的实验结果可以看出,实际值和理论值的误差相对较小而且趋势基本一致,因此基本不会影响资源分配的模型.可以看出,随着t2止期满足率也会逐渐减小.特别的,如图4(d)所示,采用式(5)对平均延迟进行估算,也有着非常小的误差.Page126.3乱序率模型实验本实验对相关的乱序率模型进行了验证.图5(a)给出了SEQ(A,B)的验证结果,可以看出基于式(17)的理论值和实际值有着很小的误差,随着μ2的增大,即μ1值随之减小,乱序率逐渐增大.图5(b)给出了SEQ(A,B,C)的验证结果,对于这类多事件类型的查询,分别采用定理1和定理2得到理论数图5乱序率(w)模型实验结果6.4资源最优化分配模型实验本实验对基于乱序反馈修正的资源分配模型进行了测试.为了更清楚地反映变化的过程,将资源和满足率都控制在较低的水平.Theory-RF和Theory-NRF分别表示采用处理乱序反馈修正和不考虑处理乱序问题的满足率.图6(a)给出了SEQ(A,B)的验证结果,随着μ2的增大,Theory-RF是对真实值的合理估计,并且根据本文模型计算得到的最优资源分配解μ2=1271也与实验结果基本一致.而采用Theory-NRF,由于没有考虑大量存在的处理乱序,图6资源最优化分配模型实验结果值解和近似估算解,与实际运行得到的乱序率相比较,偏差都在可接受的范围之内,特别的,理论数值解有着更好的近似.因为实验中固定μ3=1100,随着μ2增大,μ1逐渐减小.根据本文的模型,在μ2=1259时会出现理论的最小乱序率,与图5(b)的实验结果也是吻合的.估算是不准确的.图6(b)给出了SEQ(A,B,C)的实验结果,通过固定μ3=1100,增大μ2的值,可以得到理论计算出的最优解为μ2=1284,与实验结果一致.图6(c)给出了随着μ增大,按照最优化资源分配方法进行分配后的最优解,可以看出,理论值和实际值是基本吻合的,因此本文的资源分配优化模型是有效的.随着分配资源μ的增大,满足率会逐渐增大,直到趋近为1.图6(d)将资源分配模型对应的分时调度与其它调度进行了比较,与理论分析一致,分时调度RR在解决复杂事件处理截止期满足率问Page13题上要优于FIFO和EDF的调度方法.7结论及未来工作随着以无线射频识别技术为代表的监控技术的发展,产生了大量包含丰富语义的事件流.如何在确定的截止期限制下,通过合理的资源分配,得到更多的满足截止期的复杂事件处理结果,有着广泛的应用需求.本文提出了各种复杂事件处理操作和限制语义,以及其它操作向时序操作的转化模型,并通过对消耗模式的定义和分析,给出了比较完备的代价模型体系.以常见的泊松分布到达模型为例,在代价模型的基础上,建立了基于截止期的复合事件满足率模型,特别的,进一步定义了多事件类型的处理反馈修正模型,进而给出了复杂条件下的最优化资源分配模型.该模型通过合理的资源分配,能够保证在实时限制下结果正确的事件比率达到最大.通过该模型,可以设计相应的分时调度策略,在解决截止期敏感的监控应用上要优于其它的方法.实验证明,本文的处理模型,截止期满足模型和乱序率模型是合理的,真实值和理论值的偏差很小,同时,采用处理乱序反馈修正后的资源分配方案可以大大优化最终的结果满足率,实现资源的最优化配置.在未来的工作中,我们将进一步考虑满足其它随机分布的到达模型,并研究查询共享对模型算法的影响,以及给出针对各种复杂应用语义的存储代价最优化模型和多维QoS的资源分配最优化模型.
