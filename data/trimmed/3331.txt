Page1基于CTMO模型的数据库损坏数据隔离技术戴华秦小麟郑吉平储惠(南京航空航天大学信息科学与技术学院南京210016)摘要为了有效地解决现有数据库隔离技术中存在的合法数据误隔离问题,提高合法数据的可用性,提出了一种基于颜色-时序标记对象(CTMO)模型的数据库损坏数据隔离技术.首先,在事务依赖和影响关系的基础上,提出数据影响关系定义,给出确定损坏数据的理论方法;其次,提出CTMO模型,并给出针对事务及其修改数据的动态CTMO标记算法(DCMA)和基于隔离标记向量的损坏数据实时隔离算法(RDQA);然后,证明了该隔离机制的完全性和正确性;最后,给出包含隔离率、误隔离率和数据可用度的隔离效果评估方法.实验结果表明,该隔离机制具有更低的误隔离率和更高的数据可用度;并且在事务运行的时间、空间性能负载上具有良好的表现.关键词数据库安全;可生存性;损坏数据隔离;颜色-时序标记对象;隔离标记向量1引言数据库安全主要关注数据的机密性、完整性和可用性[1].传统数据库安全机制,如身份认证、推理控制、访问控制、多级事务处理等重点关注数据的机密性,是以预防为中心的被动保护机制.在信息战(informationwarfare)[2]背景下,传统的安全机制无法阻止所有非法攻击,无法满足关键信息系统(如银行、空中交通管制、电子商务等)基本服务不可中断的可生存性[3]要求,特别是对于数据的完整性和可用性保护无能为力.当数据在遭受内部或外部的攻击而受损时,为保证数据的完整性和可用性以及数据访问服务的持续性,需要在保证数据库不中断的情况下,及时对损坏数据进行数据恢复(datarecover)[4-6].完成损坏数据的恢复首先需要对恶意事务(malicioustransactions)以及受其影响的事务进行定位和评估,从而找出所有与这些事务相关的损坏数据,然后通过执行撤销事务实现对损坏数据的全面恢复,恢复的时间消耗随着损坏数据规模的扩大而增长[4-5];但在恢复完成之前对损坏数据的继续使用又将导致损坏传播(damagespreading)[7]的发生,使得更多的合法数据被破坏,甚至造成已恢复数据的二次损坏,这就加大了损坏数据恢复的工作量,延缓了数据库恢复到正常状态的进度.因此,迫切需要研究针对损坏数据的隔离(damagequarantine)技术,以限制和阻止损坏数据的使用,抑制损坏传播,提高数据库的可用性.从对损坏数据的隔离效果来看,隔离方法可以分为如下4种类型[8](SQ和SD分别表示被隔离的数据集和实际损坏的数据集):(1)SQ=SD,精确隔离(accuratequarantine),即不存在损坏数据漏隔离和合法数据误隔离;(2)SQSD,过度隔离(overquarantine),即不存在损坏数据漏隔离,但存在合法数据误隔离;(3)SQSD,隔离不足(notenoughquarantine),即不存在合法数据误隔离,但存在损坏数据漏隔离;(4)SQ∩SD≠SQ∧SQ∩SD≠SD,近似隔离(approximatequarantine),即同时存在损坏数据漏隔离和合法数据误隔离.其中,损坏数据的漏隔离可能造成损坏传播的发生,而合法数据的误隔离则将造成数据库可用性的降低,因此,精确隔离是数据库损坏数据隔离机制研究的主要目标.在已有关于损坏数据隔离技术的研究中,Ammann等提出使用4种不同颜色表示数据损坏和恢复程度实现损坏数据隔离的理论方法[9],但并没有给出界定不同颜色数据的具体标准和方法,实用性不高.Liu等提出基于事务依赖的多阶段隔离方法[8],首先隔离恶意事务执行之后所有被修改的数据(包含损坏数据和合法数据),限制对隔离数据的访问,阻止损坏传播,然后再对隔离数据作进一步处理,通过建立事务依赖,对损坏数据和误隔离合法数据进行多阶段的恢复和释放;Bai等提出利用动态创建事务依赖关系的损坏数据隔离方案[10-11],首先根据恶意事务建立隔离窗(quarantinewindow),并对隔离窗内的修改数据(同样包含损坏数据和合法数据)进行全面隔离,限制对隔离数据的访问,以实现对损坏传播的有效抑制,然后利用动态建立的事务依赖关系对所有隔离数据进行评估,恢复损坏数据、释放误隔离合法数据.可见,文献[8,10-11]中的隔离方法能够实现对损坏数据的全面隔离,不存在损坏泄漏和损坏传播;但由于在隔离过程中都存在合法数据误隔离的问题,使得误隔离合法数据不可用,从而造成数据库可用性的降低;这也表明现有的隔离方法属于过度隔离方法,不能实现对损坏数据的精确隔离.为了解决现有隔离技术中存在的合法数据误隔离问题,实现对损坏数据的精确隔离,本文提出了一种基于颜色-时序标记对象(CTMO)模型的数据库损坏数据隔离机制,其基本原理是通过给出CTMO模型,对执行事务及其修改数据实施运行时的动态CTMO标记,从而为事务与事务之间、事务与数据之间建立影响关系;当检测到恶意事务时①,根据恶意事务的标记信息,确定能够描述损坏数据特征的隔离标记向量,并利用隔离标记向量对损坏数据实施精确隔离.基于该原理,我们提出了针对事务及其修改数据的动态CTMO标记算法和基于隔离标记向量的损坏数据实时隔离算法;此外,通过对基于CTMO模型的损坏数据隔离机制的完全性和正确性证明可知,该隔离机制不存在损坏数据泄漏和合法数据误隔离,是一种精确隔离的方法.最后给出隔离效果对比实验和事务运行的时间、空间性能负载实验.2针对恶意事务的损坏数据确定方法恶意事务的非法修改直接造成数据库合法数据①由于恶意事务检测不是本文的研究重点,此处不作详细讨Page3的损坏,而损坏数据的继续使用带来的损坏传播又将导致更大规模的间接数据损坏,因此,损坏数据隔离机制的首要任务即为对恶意事务造成的直接和间接数据损坏进行准确定位.下面,我们首先给出数据库事务的基本概念[7,12],然后通过引入事务依赖和影响关系[4]给出数据影响关系的定义,并利用数据影响关系给出损坏数据的确定方法.2.1数据库事务基本概念为DB={x1,x2,…,xn}.的偏序关系(用∝i表示偏序关系),满足定义1.数据库是一组数据对象的集合,表示定义2.一个事务T是操作与数据对象之间(1)T{(RT(x),WT(x)|x∈DB)}∪(AT,CT);(2)若RT(x),WT(x)∈T,则RT(x)∝iWT(x)(3)AT∈T当且仅当CTT,或者WT(x)∝iRT(x);其中,RT(x)、WT(x)、AT和CT分别代表事务T读数据x、写数据x、中断退出和提交操作,WT(x)∝iRT(y)表示WT(x)先于RT(y)发生.定义3.TS={T1,T2,…,Tn}表示一组事务集合,一个事务执行历史H是TS上的偏序关系∝H,满足(1)H=∪n(2)∪n在上述基本概念的基础上,我们假设执行事务不包含“盲写”(blindwrite)操作[4],即事务在写数据之前需先读取该数据;同时,事务的执行满足2PL协议要求;另外,由于包含撤销(Abort)操作的事务对数据库数据没有任何影响,对于本文给出的损坏数据隔离策略是透明的,因此不考虑含有撤销操作的事务.2.2事务依赖关系与事务影响关系定义定义4.事务依赖关系(transactiondepend-encyrelation)指对于不同事务Ti、Tj∈H,若Tj依赖于Ti,记为Depend(Tj,Ti),则满足(1)(TiWrite_Set∩TjRead_Set≠)∧(x(x∈TiWrite_Set∩TjRead_Set)→WTi(x)∝iRTj(x));(2)x(x∈TiWrite_Set∩TjRead_Set)→T(T∈H∧T≠Ti≠Tj)(WTi(x)∝WT(x)∝iRTj(x)).其中,TWrite_Set表示事务T的写集,TRead_Set表示事务T的读集.引理1.对于不同事务Ti、Tj∈H和数据x∈DB,若Ti先写x,Tj后写x,且在Ti和Tj之间不存在其它事务写x,则Tj依赖于Ti,即Depend(Tj,Ti)成立.证明.由于事务Tj在写x前,必须先读取x,故Ti写x后,Tj读x,由事务依赖关系的定义可知,Tj依赖于Ti,即Depend(Tj,Ti)成立.证毕.定义5.事务影响关系(transactionaffectionrelation)指对于不同事务Ti、Tj∈H,若Ti影响Tj,记为AffectT(Ti,Tj),满足如下任一条件:(1)Depend(Tj,Ti);(2)TS(TS={Tk,1,Tk,2,…,Tk,n}H∧Ti,TjTS)→Depend(Tj,Tk,n)∧Depend(Tk,n,Tk,n-1)∧…∧Depend(Tk,1,Ti).性质1.事务影响关系的传递性.对于不同事务Ti、Tj、Tm∈H,有如下性质成立:AffectT(Ti,Tj)∧AffectT(Tj,Tm)→AffectT(Ti,Tm).定义6.对于事务T∈H,TAS(T)表示H中所有受T影响的事务集合,则TAS(T)={T|AffectT(T,T)}∪{T},若T为恶意事务,则称TAS(T)中的受影响事务为脏事务(dirtytransac-tions),被脏事务修改的数据均为损坏数据.2.3基于数据影响关系的损坏数据确定方法基于上述事务依赖和影响关系定义,我们给出描述事务与数据之间关系的数据影响关系定义,并利用该数据影响关系给出针对恶意事务的损坏数据确定方法.定义7.数据影响关系(dataaffectionrela-tion)指对于事务T∈H及数据x∈DB,若T影响x,记为AffectD(T,{x}),则满足DB,数据影响关系具有如下性质:AffectD(Ti,{x});性质2.对于不同事务Ti、Tj∈H和数据x∈(1)AffectT(Ti,Tj)∧AffectD(Tj,{x})→(2)x∈Ti.Write_Set→AffectD(Ti,{x}).证明.(1)对于任意T∈TAS(Tj),则AffectT(Tj,T),而已知AffectT(Ti,Tj)成立,则由性质1可知AffectT(Ti,T)成立,因此T∈TAS(Ti),所以TAS(Tj)TAS(Ti)成立,则{T.Write_Set|T∈TAS(Tj)}{TWrite_Set|T∈TAS(Ti)}也成立,又由已知AffectD(Tj,{x})可知x∈{TWrite_Set|T∈TAS(Tj)}成立,则x∈{TWrite_Set|Page4T∈TAS(Ti)}也成立,再由定义7可得AffectD(Ti,{x})成立.(2)由定义6可知TAS(Ti)={T|AffectT(Ti,T)}∪{Ti},所以TiWrite_Set{TWrite_Set|T∈TAS(Ti)},而已知x∈TiWrite_Set成立,所以x∈{TWrite_Set|T∈TAS(Ti)}也成立,则由定义7可知AffectD(Ti,{x})成立.证毕.定义8.对于事务T∈H,TADS(T)表示数据库中所有受T影响的数据集合,则TADS(T)={TWrite_Set|T∈TAS(T)}.引理2.若Bi∈H为恶意事务,则TADS(Bi)中的数据都为损坏数据.证明.由于Bi是恶意事务,由定义6可知,TAS(Bi)中的事务均为脏事务,而被脏事务修改的数据又都是损坏数据,且有TADS(Bi)={TWrite_Set|T∈TAS(Bi)},因此,TADS(Bi)中的数据都为损坏数据.由引理2可知,在数据库中,恶意事务的数据修改操作导致合法数据的直接损坏,而其它合法事务对这些损坏数据的访问,使其受恶意事务影响而成为脏事务,进而造成数据库中更多的合法数据的间接损坏.定义9.损坏数据集合(damagedataset).设B={B1,B2,…,Bm}H为恶意事务集合,数据库中所有受B影响的数据集合即为损坏数据集合,记为DDS(B),则下面,结合例1对上述定义做进一步说明.例1.设有事务B1、T1和T2,其中B1为恶意事务,事务操作执行顺序为RB1(x)∝iWB1(x)∝iCB1∝iRT1(x)∝iRT1(y)∝iWT1(y)∝iCT1∝iRT2(z)∝iWT2(z)∝iCT2∝iRT3(y)∝iRT3(u)∝iWT3(u)∝iCT3,数据x,y,z,u∈DB.由前述定义可知,例1中满足事务依赖关系的有Depend(T1,B1)和Depend(T3,T1),满足事务影响关系的有AffectT(B1,T1)、AffectT(T1,T3)和AffectT(B1,T3),受B1影响的事务集合和数据集合分别为TAS(B1)={B1,T1,T3}和TADS(B1)={x,y,u};由于B1为恶意事务,则T1和T3为脏事务,x、y和u被损坏,因此损坏数据集合DDS(B)=TADS(B1)={x,y,u},而z不受任何影响,仍为合法数据.在例1中,若采用文献[8,10-11]中的隔离方法,则需将B1之后所有事务(包括B1)的写数据全部隔离,即x、y、z和u均被隔离,此时合法数据z也将由于被误隔离而不可用;而本文提出的基于CTMO模型的损坏数据隔离机制将只隔离损坏数据x、y和u,能够实现对损坏数据的精确隔离.3基于CTMO模型的损坏数据隔离机制我们首先给出颜色-时序标记对象(CTMO)模型定义,然后,在该模型的基础上提出针对事务及其修改数据的动态CTMO标记算法和基于隔离标记向量的损坏数据实时隔离算法,最后给出基于CTMO模型的损坏数据隔离机制的完全性和正确性证明.3.1颜色-时序标记对象模型(CTMO模型)定义10.颜色-时序标记对象(Color-TimeMarksObject,CTMO):每一个CTMO对象是一个二元组c=(cs,ts),其中,cs为不同颜色组成的颜色集合属性,记为ccs,ts为时间戳属性,记为cts.定义11.CTMO模型运算操作符:设CTMO集合C={c1,c2,…,cn},则,覆盖关系操作:当且仅当满足cicscjcs∧citscjts时,cjci成立,表示cj覆盖ci,或ci被cj覆盖;=,等价关系操作:当且仅当满足cics=cjcs∧cits=cjts时,ci=cj成立,表示ci与cj等价;,复合运算操作:cicj=(cics∪cjcs,max{cits,cjts}),其中max(t1,t2)表示取较大的时间戳;Ω,基集运算操作:Ω(C)={ci∈C|对于任意cj∈C(i≠j),cicj均不成立},即由C中不能再覆盖其它标记对象的CTMO标记对象构成的集合,称之为C的基集.性质3.设a、b和c为CTMO标记对象,则有如下性质成立:(1)覆盖关系传递性:ab∧bc→ac;(2)等价关系传递性:a=b∧b=c→a=c;(3)等价和覆盖的一致性:ab∧baa=b.证明.(1)由ab可知bcsacs∧btsats,由bc可知ccsbcs∧ctsbts,易得ccsacs∧ctsats,所以ac成立;同理可证(2)也成立;(3)(充分性)由ab∧ba可知(bcsacs∧btsats)∧(acsbcs∧atsbts),则有acs=Page5bcs∧ats=bts,所以a=b;(必要性)由a=b可知acs=bcs∧ats=bts,因此(acsbcs∧bcsacs)∧(atsbts∧btsats)成立,即(bcsacs∧btsAts)∧(acsbcs∧atsbts)成立,所以ab∧ba成立.引理3.设a、b为CTMO标记对象,若c=ab,则ca、cb都成立.证明.由定义11可知c=ab=(acs∪bcs,max{ats,bts}),则有ccs=acs∪bcs和cts=max{ats,bts}成立,易得acsccs∧atscts和bcsccs∧btscts也成立,所以ca、cb均成立.在具体应用中,CTMO模型的实现并不复杂,下面,我们结合CTMO结构示例图(如图1所示)给出模型的一种简单实现方法.在图1中,c1、c2、c3、c4和cn为CTMO对象,ts和cs分别为CTMO对象的时间戳属性和颜色集合属性,其中,ts直接记录时间戳数据(设时间戳t1<t2<t3<t4<tn),cs为颜色集合属性指针,直接指向颜色集合属性字典中的颜色集合属性数据;颜色集合属性字典(ColorsSetAttributesDictionary,CSAD)用来集中存放CTMO颜色集合属性信息,其中的行表示CTMO的颜色集合属性,列si表示颜色集合属性中是否含有某单色元素(例如红色、黄色等,“1”和“0”分别表示含有和不含有),在具体的实现中,CSAD中的颜色属性信息可以使用k个比特位表示(存储时便于压缩,例如某颜色集合属性仅含有si和sj颜色,则只需存储位置i和j即可,由于不是本文的重点,这里不再展开叙述).结合前述定义,图1中的CTMO集合C={c1,c2,c3,c4,…,cn},其中,c1=(t1,{s1}),c2=(t2,{s2}),c3=(t3,{s2}),c4=(t4,{s4}),cn=(t4,{s1,s2,s4}),若颜色属性集合字典中省略的单色元素都为“0”,则易得cnc1、cnc2、cnc3、cnc4和c3c2成立,且有Ω(C)={c1,c2,c4}.在本文提出的损坏数据隔离机制中,CTMO主要用于事务和数据的标记,含有标记的事务和数据将同时具备CTMO模型和事务模型的相关特性(见4.2节),而标记对象的生成遵循CTMO模型中的操作运算规则(定义11),对损坏数据的实时隔离机制正是建立在对事务和数据的动态CTMO标记基础上的,因此CTMO模型是该隔离机制的理论基础.3.2针对事务及其修改数据的动态CTMO标记算法为了全面、及时地确定数据库中的损坏数据,同时保证系统运行的持续性,首先需要对数据库中的事务动态建立事务依赖和影响关系,并为事务及其修改数据建立关联,为此,我们提出了针对事务及其修改数据的动态CTMO标记算法(DynamicCTMOMarkingAlgorithm,DCMA).该算法在事务运行过程中对事务及其修改数据实施动态CTMO标记,利用CTMO模型的定义和特性,为事务与事务之间、事务与数据之间建立影响关系,而隔离算法(见3.3节)则直接利用这些联系实现对损坏数据的实时隔离.我们用xctmo和Tctmo分别表示数据x和事务T的CTMO标记,Tbegin_time表示事务T的开始执行时间,DCMA算法过程如算法1所示.算法1.DCMA算法.输入:数据库事务T输出:事务及其修改数据标记完成1.temp_ctmo=({},0),write_set={};2.temp_ctmots=Tbegin_time;3.获取T的第一个操作o;4.执行当前操作o;5.IFo为RT(x)THEN/读操作/6.temp_ctmo=temp_ctmox.ctmo;7.ENDIF8.IFo为WT(x)THEN/写操作/9.write_set=write_set+{x};10.ENDIF11.IFo为CTTHEN/提交操作/12.IFtemp_ctmocs为空THEN13.temp_ctmocs=get_new_color();14.ENDIF15.IFwrite_set非空THEN16.T.ctmo=temp_ctmo;/标记事务/17.FOREACHx∈write_set18.x.ctmo=temp_ctmo;/标记数据/19.ENDFOR20.ELSE/只读事务的CTMO标记为空/21.设置T.ctmo为空;22.ENDIFPage623.Exit;24.ENDIF25.IFo为ATTHEN/撤销操作/26.Exit;27.ENDIF28.获取下一个操作o,并转步4;注:temp_ctmo表示颜色-时序标记对象变量;write_set表示事务写数据集合变量;get_new_color()表示获取一个未使用过的颜色对象;Exit表示事务退出,下同.在算法1中,首先设置T开始执行时间为CTMO变量temp_ctmo的时序属性;然后,通过复合T读取数据的CTMO,生成temp_ctmo的颜色属性,同时收集被T修改的数据;最后,若事务顺利提交,则直接使用temp_ctmo标记T及T修改的数据,若事务被撤销,则不进行任何标记动作,直接退出.数据之间具有如下关系特性:由DCMA算法过程可知,事务与事务、事务与(1)当事务T执行完成时,T的CTMO标记即被确定下来,且对于T之前完成的事务T,如果TctmoTctmo,则T与T满足事务影响关系,即AffectT(T,T)成立(见引理5).(2)对于事务T修改的数据x,随着T执行完成,x的CTMO标记也随即确定,与事务本身不同,由于数据的共享访问特性,此后其它事务对x的修改可能会造成x的CTMO标记发生变化,但数据x与事务T的CTMO标记始终满足覆盖关系,即xctmoTctmo成立(见引理6).(3)对于事务T和数据库中的任一数据x,如果x与T的CTMO标记满足覆盖关系xctmoTctmo,则T影响数据x,即AffectD(T,{x})成立(见引理7).DCMA算法利用在事务运行过程中对事务及其修改数据实施动态CTMO标记,使得事务的执行不被暂停或中断,保证系统服务的持续性,同时,在实施动态标记的过程中,建立事务与事务、事务与数据之间的影响关系,从而为实现损坏数据的实时隔离创造必要条件.3.3基于隔离标记向量的损坏数据实时隔离算法假设在t时刻,系统检测出恶意事务集合B={B1,B2,…,Bm}.定义12.隔离标记向量(quarantinemarksvectors).B中所有恶意事务的CTMO集合的基集称为隔离标记向量,记为犙犕犞(B),则犙犕犞(B)=Ω({Bi.ctmo|Bi∈B}).定义13.隔离协议(quarantineprotocols).对于数据库中任意数据x∈DB,若存在c∈犙犕犞(B)满足x.ctmoc,则x需隔离,以限制其它执行事务对数据x的访问.定义14.隔离数据集合(quarantinedataset).数据库中所有满足隔离协议的数据集合称为隔离数据集合,记为QDS(B),则QDS(B)=∪Bi∈B{x|x.ctmoBi.ctmo∧x∈DB}.由定义14可知,满足隔离协议的数据均在隔离数据集合中,且都是受恶意事务影响的损坏数据(见定理2),需要及时进行隔离,以限制其它执行事务对损坏数据的读、写访问,抑制损坏传播.对损坏数据的隔离和限制的基本原理就是对执行事务的访问数据进行隔离协议检查,若满足隔离协议,则表明该事务正在请求访问被隔离的损坏数据,此时,立刻中断并撤销该事务,阻止损坏传播.利用该原理我们提出了基于隔离标记向量的损坏数据实时隔离算法(Real-timeDamageQuarantineAlgorithm,RDQA),具体算法过程如算法2所示.算法2.RDQA算法.输入:隔离标记向量犙犕犞(B),数据库事务T输出:实现损坏数据的实时隔离1.获取T的第一个操作o;2.IFo为RT(x)或WT(x)THEN3.IF犙犕犞(B)不为空THEN4.FOREACHc∈犙犕犞(B)5.IFx.ctmocTHEN6.执行AT操作;7.Exit;8.ENDIF9.ENDFOR10.ENDIF11.执行操作o;12.ENDIF13.IFo为CT或ATTHEN14.执行操作o;15.Exit;16.ENDIF17.获取下一个操作o,并转步2.在算法2中,对于执行事务的数据读、写访问操作,在执行前首先检查犙犕犞(B)中是否存在CTMO标记能够被该访问数据的CTMO标记覆盖,若存在,则撤销并退出该事务;若不存在,则操作继续执行.由算法过程可知,若犙犕犞(B)为空,则算法将忽Page7略对事务操作的隔离检查,此时RDQA算法对事务执行没有任何影响.RDQA算法利用描述损坏数据标记特征的隔离标记向量和隔离协议,实现对损坏数据的实时隔离,从而保证了该算法对损坏数据隔离的完全性(见定理1)和正确性(见定理2).3.4隔离机制的完全性和正确性证明为了证明基于CTMO模型的损坏数据隔离机制的完全性和正确性,我们首先给出相关的定义、性质和引理,然后再给出完全性和正确性证明.另外,由于只读事务不修改任何数据,不可能造成数据损坏,因此,只读事务对于本文的隔离策略是透明的,下面给出的证明过程均不考虑只读事务.定义15.全路径事务序列(FullPathTrans-actionSequence,简称FPT序列).对于H中事务执行序列T1T2…Tn,若Tn.ctmo…T2.ctmoT1.ctmo成立,且满足Ti,Ti+1∈H(Ti+1.ctmoTi.ctmo)→T∈H(Ti+1.ctmoT.ctmoTi.ctmo),其中T≠Ti,T≠Ti+1且1i<n,则称序列T1T2…Tn为FPT序列.FPT序列具有如下性质.性质4.若事务执行序列T1T2…Tn为FPT序列,则TkTk+1Tk+2…Tm(1k<n,1<mn)也是FPT序列.由上述FPT序列的定义易得该性质是成立的,证略.引理4.对于事务Ti、Tj∈H,若Tj.ctmoTi.ctmo,且TiTj不是FPT序列,则必定存在事务序列T1T2…Tn(n1)使得TiT1…TnTj为FPT序列.证明(反证法).假设不存在这样的事务序列,而已知Tj.ctmoTi.ctmo成立,则由FPT的定义可知,TiTj满足FPT要求,即TiTj是FPT序列,这与已知条件“TiTj不是FPT序列”相矛盾,故假设不成立,所以必定存在事务序列T1T2…Tn(n1)使得TiT1…TnTj为FPT序列.引理5.对于事务Ti、Tj∈H,Tj.ctmoTi.ctmoAffectT(Ti,Tj).证明.充分性.已知Tj.ctmoTi.ctmo成立,①若TiTj为FPT序列,则由DCMA算法和定义15可知,必定存在数据x,Ti先写x,Tj后读取x,且在Ti和Tj之间没有其它事务写x,故Depend(Tj,Ti)成立,因此AffectT(Ti,Tj)也成立;②若TiTj不是FPT序列,由引理4可知必定存在事务序列T1T2…Tn(n1)使得TiT1…TnTj为FPT执行序列,再由性质4易得TiT1,T1T2,…,TnTj均为FPT行序列,利用①中的结论可知AffectT(Ti,T1),AffectT(T1,T2),…,AffectT(Tn,T1)均成立,则由性质1易得AffectT(Ti,Tj)成立.综合①、②可知Tj.ctmoTi.ctmo→AffectT(Ti,Tj)成立.必要性.已知AffectT(Ti,Tj)成立,由定义5可知,Ti和Tj存在两种可能的状态:①Depend(Tj,Ti)成立,由定义4可知,存在数据x,Ti先写x,Tj后读x,且在Ti和Tj之间不存在其它事务写x,则由DCMA算法易得Tj.ctmoTi.ctmo成立;②存在事务集合TS={T1,T2,…,Tn}H(Ti,TjTS)使得Depend(Tj,Tn)∧Depend(Tn,Tn-1)∧…∧Depend(T1,Ti)成立,则由①中的结论可知Tj.ctmoTn.ctmo∧Tn.ctmoTn-1.ctmo∧…∧T1.ctmoTi.ctmo成立,再由CTMO模型中覆盖关系的传递性(性质3(1))可知Tj.ctmoTi.ctmo成立.综合①、②可得AffectT(Ti,Tj)→Tj.ctmoTi.ctmo成立.引理6.对于事务T∈H及其写数据集T.Write_Set中的数据,x(x∈T.Write_Set)→x.ctmoT.ctmo.证明.对于T.Write_Set中的任意数据x,存在两种可能情况:(1)假设H中不存在任何其它事务写x,则x.ctmo=T.ctmo成立,所以x.ctmoT.ctmo也成立;(2)假设H中存在其它事务写x,设所有写x的事务按执行顺序组成的序列为T1T2…Tm(Tm最后写x),由引理1可知Depend(T1,T)∧Depend(T2,T1)∧…∧Depend(Tm,Tm-1)成立,则由定义5易得AffectT(T,Tm)成立,再由引理5进一步可得Tm.ctmoT.ctmo成立,而Tm为最后写x的事务,则有x.ctmo=Tm.ctmo,所以x.ctmoT.ctmo成立.综合①、②可知x(x∈T.Write_Set)→x.ctmoT.ctmo成立.引理7.对于事务T∈H和任意数据x∈DB,x.ctmoT.ctmoAffectD(T,{x}).证明.充分性.已知x.ctmoT.ctmo成立,假设最后修改x的事务为T,则x.ctmo=T.ctmo,因此T.ctmoT.ctmo成立,由引理5可得AffectT(T,T)也成立;由于T最后修改x,则x∈T.Write_Set,由性质2(2)可知AffectD(T,{x})成立,再由性质2(1)Page8可知AffectD(T,{x})也成立,所以x.ctmoT.ctmo→AffectD(T,{x})成立.必要性.已知AffectD(T,{x})成立,由定义7可知x∈{T.Write_Set|T∈TAS(T)}成立,因此在TAS(T)中至少存在一个事务修改x,而由定义6可知TAS(T)={T|AffectT(T,T)}∪{T},则对于TAS(T)中最后修改x的事务,存在两种可能情况:①假设最后修改x的事务为T,则x∈T.Write_Set,由引理6可知x.ctmoT.ctmo成立;②假设最后修改x的事务为Ti∈{T|AffectT(T,T)},则有AffectT(T,Ti),由引理5可知Ti.ctmoT.ctmo成立,由于Ti最后修改x,则x∈Ti.Write_Set,进而由引理6可知x.ctmoTi.ctmo成立,再由性质3(1)可得x.ctmoT.ctmo也成立.综合①、②可得AffectD(T,{x})→x.ctmoT.ctmo成立.证毕.引理8.对于事务T∈H,数据库中能够覆盖T的CTMO标记的数据集合,与受T影响的数据集合是一致的,即{xi|xi.ctmoT.ctmo∧xi∈DB}=TADS(T)成立.证明.(1)对于任意x∈{xi|xi.ctmoT.ctmo∧xi∈DB},则有x.ctmoT.ctmo,设最后写x的事务为Ti,则x∈Ti.Write_Set,且由DCMA算法可知Ti.ctmo=x.ctmo,因此Ti.ctmoT.ctmo,则由引理5可知AffectT(T,Ti)成立,由定义6可知Ti∈TAS(T),进而由定义8可知Ti.Write_SetTADS(T),所以x∈TADS(T)成立,即x(x∈{xi|xi.ctmoT.ctmo∧xi∈DB})→x∈TADS(T);(2)对于任意x∈TADS(T),由定义8可知TADS(T)={T.Write_Set|T∈TAS(T)},设TAS(T)中最后写x的事务为Ti,则由DCMA算法可知x.ctmo=Ti.ctmo,且对于Ti,由定义6可知Ti=T或AffectT(T,Ti)必有其一成立:①假设Ti=T成立,则x.ctmo=T.ctmo,因此x.ctmoT.ctmo成立;②假设AffectT(T,Ti)成立,则由引理5可知Ti.ctmoT.ctmo成立,而x.ctmo=Ti.ctmo,因此x.ctmoT.ctmo也成立.因此,综合①、②可知,x.ctmoT.ctmo均成立,因此x∈{xi|xi.ctmoT.ctmo∧xi∈DB}成立,即x(x∈TADS(T))→x∈{xi|xi.ctmoT.ctmo∧xi∈DB}成立.综合(1)、(2)可得{xi|xi.ctmoT.ctmo∧xi∈DB}=TADS(T).下面给出基于CTMO模型的损坏数据隔离机制的完全性和正确性证明.设在t时刻,检测到恶意事务集合B={B1,B2,…,Bm}.定理1.隔离的完全性(quarantinecomplete-ness).数据库中所有的损坏数据均被隔离,不存在损坏数据的漏隔离,即证明.对于任意x∈DDS(B),由DDS(B)=∪Bi∈BTADS(Bi),不妨设x∈TADS(Bi),由引理8可知x∈{xi|xi.ctmoBi.ctmo∧xi∈DB},所以有x.ctmoBi.ctmo,则x满足隔离协议(定义13),再由定义14可知x∈QDS(B)成立.证毕.定理2.隔离的正确性(quarantinecorrect-ness).数据库中被隔离的数据都是损坏数据,不存在合法数据的误隔离,即证明.对于任意x∈QDS(B),由QDS(B)=∪Bi∈B{xi|xi.ctmoBi.ctmo∧xi∈DB},不妨设x∈{xi|xi.ctmoBi.ctmo∧xi∈DB},由引理8可知x∈TADS(Bi),由于Bi为恶意事务,则由引理2可知x为损坏数据,因此x∈DDS(B).由定理1和2可知,基于CTMO模型的损坏数据隔离机制是完全的、正确的,隔离的完全性保证了所有的损坏数据都被隔离,不存在损坏数据的漏隔离问题;而隔离的正确性则表明所有被隔离的数据均为损坏数据,不存在合法数据的误隔离问题.因此,该隔离机制是一种精确隔离的方法.4隔离效果评估方法我们用隔离率(positivequarantinerate)、误隔离率(negativequarantinerate)和数据可用度(dataavailablerate)这3个指标来评价隔离机制的效果.其中,隔离率为被隔离的损坏数据占总损坏数据的比例,记为pqr;误隔离率为误隔离的合法数据与总损坏数据的比例,记为nqr;数据可用度为数据库中能够被访问的合法数据占总数据量的比例,记为dar.具体计算公式如(1)、(2)和(3)所示:隔离率=被隔离的损坏数据总量误隔离率=误隔离的合法数据总量数据可用度=能够被访问的合法数据总量Page9假设数据库数据总量为|DB|,且事务执行历史H=T1∝HT2∝H…∝HTn,恶意事务集合为B(BH),则实际损坏数据总量为∪Bi∈BTADS(Bi).下面,我们分别给出文献[8,10-11]中的过度隔离方法(OverQuarantineMethod,OQM)和基于CTMO模型的损坏数据隔离方法(CTMO-basedDamageQuarantineMethod,简称CDQM)在隔离率、误隔离率和数据可用度上的形式化表示:在OQM中,由于不存在损坏泄漏,因此被隔离的损坏数据总量与实际损坏数据总量相同;假设B中最先执行的恶意事务为Tk(1kn),则被隔离的数据总量为∪kjnTj.Write_Set(包含合法数据和损坏数据),其对应的隔离率pqrO、误隔离率nqrO和数据可用度darO分别为nqrO=而在CDQM中,由隔离的完全性和正确性可知,不存在损坏泄漏和合法数据误隔离,因此被隔离的损坏数据总量与实际损坏数据总量也相同,且误隔离合法数据量为0,则对应的隔离率pqrC、误隔离率nqrC和数据可用度darC分别为在下面的章节中,我们将通过实验对CDQM和OQM的隔离效果作对比分析.5实验结果及分析我们从如下两个角度进行实验分析和验证:(1)从损坏数据的隔离效果角度,针对文献[8,10-11]中的过度隔离方法OQM和本文提出的隔离方法CDQM,进行误隔离率和数据可用度的对比模拟实验;(2)从数据库空间负载角度进行性能评估实验;(3)从数据库事务执行时间性能角度,对基于CTMO模型的损坏数据隔离机制进行时间负载的性能评估实验.实验的硬件环境为IntelP8600(双核、2.40GHz)处理器,2GB内存;软件环境为Ubuntu(9.10)操作系统(Linux内核版本为2.6.31-14-generic)、PostgreSQL(1.10.3)数据库系统和gcc(4.4.1)开发工具.实验采用BenchmarkTPC-D[17]数据库测试数据集,TPC-D包含8个关系表,数据集容量由刻度因子(scalefactor,简称SF)控制,具体数据由TPC-D附带的数据产生器DBGEN生成,并根据SF值导入PostgreSQL数据库.TPC-D中8个关系表的数据容量配置情况如表1所示(其中NATION和REGION为固定容量的关系表).5.1隔离效果对比模拟实验由第4节的结论可知,OQM与CDQM的隔离率均为100%,故本实验不考虑隔离率,重点测试这两种方法在误隔离率nqr和数据可用度dar上的对比情况.我们首先给出模拟实验的相关数据及参数说明:(a)选取SF=0.01时的TPC-D数据集为实验数据对象,则数据库总数据量(元组数量)|DB|=86630;(b)n为事务执行历史H的容量,即H中有n个事务,设为T1∝HT2∝H…∝HTn;(c)q为事务写数据量随机因子,对于事务Ti∈H,取其写数据量为整数区间[1,q]中的随机数,且所有事务写数据均不相同;(d)m为H中的恶意事务数量,即H中存在m个恶意事务,且这些事务互不影响,为了实验描述的简洁性,这里假设H中的前m个事务均为恶意事务;(e)p为事务影响随机因子,即在H中受恶意事务Ti(1im)影响的事务总数取[1,p]中的随机数,任意两个恶意事务影响的事务集不相交,所有被影响的事务随机不重复地分布于H中.OQM和CDQM在nqr和dar上的对比实验:下面,根据参数n、q、p和m的不同设置,给出(1)当n=200、q=100、p=10时,以m为自变Page10量(1m10),实验结果如图2所示.由图2(a)和图2(b)可知,当m增大时,OQM的nqr减小,而dar保持不变,为88.04%;CDQM的nqr保持不变,为0%,而dar减小.这是由于随着恶意事务数量的增加,受恶意事务影响的事务也增多,因此损坏数据也增多,且①在OQM中,由于H中的事务总量不变,被隔离的数据总量也不变,因此,dar也保持不变;而被误隔离的合法数据量却随之减小,所以nqr也逐渐减小;②在CDQM中,由于不存在损坏数据误隔离,因此nqr始终为0%;而随着损坏数据的增多,dar也随之减小.该实验表明,在n=200、q=100、p=10时,随着恶意事务数量m的增加,OQM的nqr随之减小,而dar保持不变;CDQM的nqr保持不变,但始终比OQM低,而dar随之减小,但始终比OQM高.(2)当m=10、q=100、p=10时,以n为自变量图2n=200,q=100,p=10,m为自变量时的nqr和dar图3m=10,q=100,p=10,n为自变量时的nqr和dar(200n1000),实验结果如图3所示.由图3(a)和(b)可知,当n增大时,OQM的nqr增大,而dar减小;CDQM的nqr和dar都保持不变,其中nqr为0%,dar为96.04%.这是由于:①在OQM中,随着H中事务总数量的增多,被隔离的数据也增多,但恶意事务及其影响事务均保持不变,因此损坏数据总量保持不变,而被误隔离的合法数据也增多,导致nqr增大;随着被隔离数据量的增大,dar减小;②在CDQM中,由于不存在合法数据误隔离,因此nqr始终为0%;由于恶意事务及其影响事务保持不变,则被隔离的损坏数据也不变,因此dar也保持不变.该实验表明,在m=10、q=100、p=10时,随着事务总量n的增大,OQM的nqr随之增大,而dar随之减小;CDQM的nqr和dar与n无关,均保持不变,其中前者始终比OQM低,而后者始终比OQM高.Page11(3)当n=200、q=100、m=10时,以p为自变量(2p20),实验结果如图4所示.由图4(a)和(b)可知,当p增大时,OQM的nqr减小,而dar保持不变,为89.10%;CDQM的nqr保持不变,为0%,而dar减小.这是由于随着事务影响随机因子的增大,受恶意事务影响的事务数量也增大,损坏数据也随之增加,且①在OQM中,由于H的事务总量不变,被隔离的数据保持不变,因此dar也保持不变;而损坏数据的增多使得误隔离合法数据量减小,导致nqr也随之减小;②在CDQM中,由于不存在合法数据误隔离,因此nqr始终为0%;而随着损坏数据的增加,dar随之减小.该实验表明,在n=200、q=100、m=10时,随着事务影响随机因子p的增大,OQM的nqr随之减小,而dar保持不变;CDQM的nqr保持不变,但始终比OQM低,而dar随之减小,但始终比OQM高.(4)当n=200、m=10、p=10时,以q为自变量(20q200),实验结果如图5所示.图4n=200,q=100,m=10,p为自变量时的nqr和dar图5n=200,m=10,p=10,q为自变量时的nqr和dar由图5(a)和(b)可知,当q增大时,OQM的nqr分布在250%左右,变化不大,而dar减小;CDQM的nqr保持不变,为0%,而dar减小.这是由于随着事务写数据量随机因子q的增大,H中的事务写数据量随之增大,受恶意事务影响的损坏数据量也增大,且①在OQM中,由于事务写数据量增大,但事务总量不变,使得被隔离的数据增多,因此dar随之减小;而由于恶意事务及其影响事务保持不变,事务总量不变,随着事务写数据量的增大,被误隔离的合法数据量也随之增大,导致nqr变化不大;②在CDQM中,由于不存在合法数据误隔离,因此nqr始终为0%;而随着损坏数据的增加,dar随之减小.该实验表明,在n=200、m=10、p=10时,随着事务写数据量随机因子q的增大,OQM的nqr分布在250%左右,且变化不大,而dar随之减小;CDQM的nqr保持不变,但始终比OQM低,而dar随之减小,但始终比OQM高.Page12综合上述四组实验可知,在实验设置的条件下,基于CTMO模型的损坏数据隔离方法与现有的隔离方法相比,具有更低的误隔离率和更高的数据可用度.5.2数据库空间负载实验为了实现对损坏数据的隔离,需要对事务及其修改数据添加CTMO标记信息,这就带来系统额外的空间负载开销,我们将此类需额外存储的数据称为隔离元数据(quarantinemetadata).本实验从数据空间负载角度出发,首先,给出本文的隔离方法和现有的隔离方法在隔离元数据空间占用上的对比实验;其次,给出在本文的隔离机制中,加载CTMO标记信息前后的数据库关系表数据空间负载的对比实验.(1)隔离元数据空间负载对比实验本文的隔离机制中的隔离元数据(CTMOQuar-antineMetadata,CTMO-QM)主要包括三个方面:一是为关系表元组数据建立的CTMO标记数据,二是为执行事务建立的事务ID和CTMO标记数据,三是为CTMO标记建立的颜色集合属性字典数据.图6隔离元数据空间负载对比结果图由图6(a)可知,随着事务数量n的增加,EQM-QM和CTMO-QM的空间负载均有所增长,但增长幅度都很小,其中CTMO-QM的增长速度略快,同时,与EQM-QM相比,CTMO-QM的空间负载增量与事务数量n近似成正比例关系,但增长幅度很小,当事务数量达到1000时,CTMO-QM的空间负载仅比EQM-QM多0.22;由图6(b)可知,随着SF的增大,EQM-QM和CTMO-QM的空间负载均有显著增长,其中CTMO-QM的占用空间略大,同时,与EQM-QM相比,CTMO-QM的空间负载增量随着SF的增大逐渐减小,但减小幅度趋于而现有的隔离机制中的隔离元数据(QuarantineMetadataofExistingQuarantineMethods,简称EQM-QM)主要由两方面组成,其一为执行事务建立的事务依赖记录数据,包含事务ID、事务执行时间戳和依赖事务ID序列;其二为建立事务与修改数据的关联而记录的数据,包括最后修改关系表元组数据的事务ID和事务执行时间戳.为了实验的简洁性,我们将上述隔离元数据中的事务ID、时间戳数据类型设置为整形;设n为实验中事务执行历史H的容量,即H中有n个事务;随机生成满足事务依赖关系的事务对象,设r为事务依赖随机因子,即在H中依赖于事务Ti(1in)影响的事务总数取[1,r]中的随机数,且设置任意依赖于两个不同事务的事务集不相交;用整形数值集合表示颜色集合属性字典中的颜色集合属性.下面,我们分别给出在r=10、SF=0.05,以事务数量n为自变量以及在r=10、n=500,以SF刻度因子为自变量时,隔离元数据的空间负载对比情况,实验结果如图6所示.平缓,当SF=0.1时,CTMO-QM的空间负载仅比EQM-QM多0.05.该实验结果表明,本文的隔离方法与现有的隔离方法在隔离元数据的空间占用上具有类似的特征,都随着事务数量和数据库元组数据规模(SF刻度因子)的增大而不断增大,但隔离元数据的空间负载主要受数据库元组数据规模影响;同时,本文的隔离方法在隔离元数据的占用空间上略大于现有的隔离方法,其空间负载增量随着事务数量的增大而增长,但增长幅度很小,此外,其空间负载增量还随着数据库元组数据规模(SF刻度因子)的增大而逐渐Page13减小,但减小幅度逐渐趋于平缓.(2)关系表数据空间负载对比实验为了实现对损坏数据的及时、有效隔离,需要为数据库关系表数据添加CTMO标记,即为关系表增加两个整型属性列,分别用来表示CTMO的时序和颜色集合属性,这就增加了数据库中存储关系表数据的空间占用开销.下面,在不同SF参数条件下,对比添加CTMO标记前后的数据库关系表数据的实际空间占用的变化情况,并计算添加标记后数据库关系表额外空间负载增加的百分比,实验结果如图7所示.由图7可知,在SF值从0.01~0.1的变化过程中,加载CTMO标记前后的关系表数据占用空间都逐渐增大,但加载CTMO标记后增加的空间负载百分比变化不大,主要分布在4%左右,且变化范围较小,平均仅增加4.12%的空间负载.该实验结果表明,数据库关系表数据中CTMO标记的添加对数据库关系表数据空间负载影响较小.5.3事务运行时间负载实验本实验主要测试基于CTMO模型的损坏数据隔离机制对数据库事务运行时间负载的影响情况,即针对DCMA算法和RDQA算法进行时间负载测试.这里的事务由若干读、写操作组成(且都不访问损坏数据①),事务中的读、写操作分别由数据库中的查询(SELECT)和修改(UPDATE)操作表示.由DCMA算法过程可知,该标记算法的执行与事务读、写和提交操作密切相关,存在于事务执行过程中;而由RDQA算法过程可知,该隔离算法与隔离标记向量密切相关,当隔离标记向量为空时,则跳过对事务操作的隔离检查,直接执行事务操作,可见,在这种情况下RDQA算法对事务执行没有任何影响.基于上述情况,我们设计两组实验:(1)设置隔离标记向量为空,即不考虑RDQA算法,只测试在DCMA算法执行情况下,隔离机制对事务运行时间负载的影响情况;(2)设置隔离标记向量不为空,测试在RDQA和DCMA算法共同作用下,隔离机制对事务运行时间负载的影响情况.在实验中,TPC-D刻度因子SF设置为0.1,生成并导入对应的实验数据,选取其中容量最大的关系表LINEITEM(包含60万条元组,总计约100M)为实验对象;用RC表示读元组数据量、WC表示写元组数据量、QD表示隔离标记向量的容量.(1)DCMA算法对事务运行时间负载的影响假设隔离标记向量为空(QD=0),此时不考虑RDQA算法对事务执行的影响,只测算DCMA算法对事务运行负载的影响情况.分别设置WC和RC为自变量,得到实验结果如图8所示.图8DCMA算法对事务运行时间负载的影响①注:由于访问损坏数据的事务将直接被中断,为了测算DCMAPage14由图8(a)可知,当RC不变、WC增大时,DCMA算法带来的额外时间负载百分比变化不大,平均仅增加1.80%的时间负载;由图8(b)可知,当WC不变、RC增大时,DCMA算法带来的额外时间负载百分比分布在3%左右,变化很小,平均仅增加3.09%的时间负载.该实验结果表明,DCMA算法对事务运行时间负载的影响很小.图9RDQA、DCMA算法对事务执行效率的影响由图9(a)可知,当RC、WC不变、QD增大时,RDQA与DCMA算法带来的额外时间负载近似成正比例增长,隔离标记向量每增加500,系统额外时间负载平均增长约1.92%;由图9(b)可知,当RC、QD不变、WC增大时,增加的时间负载百分比分布在4.5%左右,变化很小,系统平均仅增加4.66%的额外时间负载;由图9(c)可知,当WC、QD不变、RC增大时,增加的时间负载近也随之增长,但增长幅度逐步减小,并趋于平缓,且在实验数据范围内,额外增长的系统时间负载不超过10%.该实验结果表明,事务运行的时间负载主要受QD影响,受RC和WC的影响相对较小.由上述实验(1)和(2)可知,RDQA算法对系统载的影响(2)RDQA与DCMA算法对事务运行时间负假设隔离标记向量非空(QD≠0),测算RDQA与DCMA算法共同执行时对合法事务运行时间负载的影响情况.分别设置QD、RC和WC为自变量,得到实验结果如图9所示.事务运行时间负载影响较大,其影响程度主要取决于隔离标记向量的容量,而DCMA算法对系统运行效率影响较小.6结束语本文通过引入颜色-时序标记对象(CTMO)模型,以解决现有隔离机制中存在的合法数据误隔离问题为主要目标,提出了一种基于CTMO模型的数据库损坏数据隔离机制,其核心算法包括针对事务及其修改数据的动态CTMO标记算法(DCMA)和基于隔离标记向量的实时损坏数据隔离算法(RDQA);同时,通过对该隔离机制的完全性和正确Page15性证明可知,该隔离机制不存在损坏数据泄露和合法数据误隔离的问题,是一种精确隔离的方法.实验表明,与现有的隔离机制相比,基于CTMO模型的损坏数据隔离机制具有更低的误隔离率和更高的数据可用度;并且该隔离机制在时间、空间性能负载上也有良好表现:对数据库数据空间负载的影响较小,而事务运行的时间负载主要受RDQA算法影响,其影响程度主要取决于隔离标记向量的容量,DCMA算法对事务运行的影响较小.本文的后续工作主要有:研究隔离标记向量的快速定位和匹配检查方法,进一步降低隔离机制对事务运行效率的影响;扩展CTMO模型,研究针对恶意事务损坏数据的修复技术等.
