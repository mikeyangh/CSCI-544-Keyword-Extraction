Page1复杂事件模式检测与CEP测试数据生成算法研究赵会群孙晶杨岩坤毛立志(北方工业大学计算机学院北京100144)摘要随着信息技术的快速发展和广泛应用,大数据正以不可阻挡的气势向我们走来.大数据源于信息技术,同时又向信息技术提出挑战.如何征服大数据给信息技术处理能力上带来的挑战是一个广泛关注的课题.由于采用面向流式数据的处理策略,复杂事件处理(ComplexEventProcessing,CEP)技术被认为是一种有希望征服大数据挑战的技术之一.然而,当事件流成为大数据时,目前的CEP模型、事件模式检测和CEP系统测试数据生成的方法和技术都存在很多不足.文章针对这一问题讨论了复杂事件建模、模式检测与测试数据的生成方法.提出一种CEP代数模型,用多种事件算子来表达事件之间的关系和事件流模型.在这里,一个创新的思想是把CEP代数模型表达式解释成算术文法产生式,从而可以用词法分析技术解决复杂事件模式检测问题.为了有效地测试复杂事件模式检测的算法,基于CEP代数模型,提出了一个用于支持上述CEP模式检测的大数据事件集的生成算法.并由此生成了不同量级的测试数据,测试了一个RFID物联网中CEP模式检测引擎.实验结果表明了提出的事件模式检测算法和CEP系统测试大数据事件集生成算法的有效性.关键词复杂事件处理;事件模式检测;测试数据生成;大数据;代数模型1引言大数据已经成为这些年我们耳边频率最高的词汇之一,无论是学术界、工业界,还是政府都在津津乐道地谈论大数据如何改变我们的生活.学术界致力于解决大数据带来的新课题,相关的学术会议和论文比较多;工业界也在加班加点地开发相关技术去抢占市场,如Google、Intel、Baidu等都推出了自己的大数据处理技术框架;一些强势政府更是希望通过大数据处理来解决国家安全、行政管理面临的新问题,如美国、日本、欧盟和中国等都推出了自己的科技发展计划.大数据并非空穴来风,随着信息技术应用范围和规模的不断扩大.一天中互联网产生的全部内容可以刻满1.68亿张DVD;发出的邮件有2940亿封之多;相当于美国两年的纸质信件数量;发出的社区帖子达200万个,相当于《时代》杂志770年的文字量①.传统的数据库已经无法承担如此数量的数据存储任务[1].复杂事件处理(ComplexEventProcessing,CEP)是一个伴随流式数据处理需求增加而出现的一种软件技术,它用于在不同数据源顺序混杂的事件流中发现感兴趣的事件模式[2].CEP引擎需要能够实时分析历史数据,以便发现关注的事件模式,例如股票价格变动趋势、计算机网络入侵实时发现、可疑的信誉卡冒用等等[3]②.随着大数据时代的到来,业界自然希望CEP能够承担解决大数据处理问题的任务.CEP是一种集成技术框架,它包括如下方法和技术内容[3]:(1)事件模式检测;(2)事件抽象;(3)事件过滤;(4)事件汇聚和传输;(5)事件体系结构模型;(6)事件关系发现;(7)事件驱动的处理引擎.然而,在大数据时代,传统的CEP方法和技术遇到了挑战.大数据呈现出数据结构多样性(Variety)、数据体积巨大(Volume)、处理速度要求快(Velocity)和数据有效价值低(Value)[4]等特性.这些特征给大数据下CEP系统的开发和测试提出了极高的要求,而不同业务领域产生的大数据又有其自身的特征.开发者不得不临时借用传统的方法和技术,这样就导致其在正确性、可靠性、有效性等方面都存在缺陷,有待进一步研究.与传统数据处理和测试数据生成技术不同.大数据下的事件关系复杂,数据呈非结构化,导致传统的数据操纵模型无法全面解决复杂事件的建模问题.目前有些研究仍借用传统的模型对复杂事件建模,包括[5]:(1)基于图的CEP模型;(2)基于自动机的CEP模型;(3)基于PetriNet的CEP模型.另一方面,大数据对传统的CEP引擎测试也存在挑战.测试基准(Benchmark技术)是数据处理测试的常用技术,它通过有针对性地生成测试数据来替代真实数据,从而达到测试系统各种指标的目的.传统的测试基准一般强调满足两个基本要求:(1)测试数据应该尽可能少;(2)测试基准数据应该覆盖更广泛的业务类型[6].令人遗憾的是,基本要求(1)不完全适应大数据CEP测试的特殊要求.因此,传统意义上的测试基准技术和基准数据无法直接应用到大数据CEP的测试中.如何把握测试数据集的大小和范围的尺度是大数据CEP测试需要解决的一个科学问题.由于基准测试是对一种技术典型特征的度量,所以测试用例不是根据具体被测实现的功能或者逻辑来生成.也就是说,传统的软件测试用例生成技术,如基于逻辑覆盖、等价分类、边界值等,都无法直接用于基准测试数据生成.针对上述问题,本文探讨复杂事件建模和基于模型的CEP模式检测,以及CEP引擎测试数据的生成方法.研究分4个层次:(1)复杂事件模型研究.明确复杂事件之间关系,通过引入事件“算子”来表达事件之间的关系和结构,论证事件算子的各种运算定律;用代数表达式刻画各种事件流,从而建立CEP工作流的代数模①②Page3型,包括顺序事件流、因果事件流、协同事件流等事件流模型.为进一步研究基于模型的CEP引擎算法和测试数据生成算法提供理论支持.(2)基于模型的复杂事件模式检测算法研究.把CEP工作流代数模型解释成“复杂事件文法”,给出“复杂事件文法”的产生式规则,把复杂事件模式检测转化成基于“事件文法”的算术表达式来分析问题,进而提出基于“复杂事件文法”的复杂事件模式检测算法.(3)大数据CEP引擎测试数据生成算法研究.这里把复杂事件模式检测算法作为CEP引擎的代表,研究一般CEP引擎测试的数据生成方法.研究中结合复杂事件模式发生的概率分布,给出顺序事件流、因果事件流,以及混合事件流模型下满足不同概率分布的业务模式事件流生成算法.其中,均匀、正态、泊松等概率分布作为事件模式的播撒随机概率分布,分别适用于不同的应用场景.(4)RFID物联网复杂事件模式检测与CEP测试应用研究.结合RFID在物流业的实际应用场景,生成不同规模的测试数据集(流),以此检验RFID物流网大数据CEP引擎,评价其处理能力和测试数据集的有效性.本文第1节引言给出本文研究的目的和意义;第2节复杂事件结构给出多种事件运算算子和相关运算定律以及不同事件运算下的事件流模型,建立复杂事件代数模型.在该模型基础上;第3节给出复杂事件模式检测算法和CEP引擎测试的大数据生成算法;第4节实验研究结合RFID物联网的一个应用场景,生成不同尺度的以及不同概率分布播撒事件模式的大数据事件集(流),测试本文提出的基于模型的大数据CEP引擎;第5节相关研究介绍近期有关测试数据生成和大数据测试基准的研究现状;最后通过与相关研究的比较,总结本文研究结论和特点.2复杂事件结构本节研究如何用代数学方法刻画复杂事件模型.首先给出事件定义,归一化不同结构数据;引入事件算子概念,定义事件的顺序、因果、闭包、协同和同生等事件算子,定义复杂事件结构,建立复杂事件代数模型.2.1事件定义和事件算子首先给出原子事件定义.定义1(原子事件).事件是一个七元组〈ID;Domain;Alias;Type;Moment;Stimulation;Location〉,其中:(1)ID是事件的标识符,用它来区分其它事件;(2)Domain是CEP所在的问题域;(3)Alias是事件的名字,它是一个与问题相关的称谓,如RIFD物联网中的EPC编码;(4)Type是事件的类型,它也与问题域有关,开发者可自定义;(5)Moment是事件发生的时刻;(6)Stimulation是事件被激发的条件,如一个集装箱通过RFID识读器时,识读器的感知环境可作为激发条件;如果激发条件为空,该事件不发生.(7)Location是事件发生的位置,与问题域有关;事件一般用大写字母表示,如A,B,C等;如果特别强调是一个具体的事件,可以用小写字母表示,如a,b,c等.例如:一个RFID物联网中的事件E=〈ID001;IoT;Loadedgoods;EPC-96;9:30;SH#5〉.定义1是对事件属性和内涵的精确表达.从实际业务角度,各个事件发生是可管、可控的确定事件,并未形成大数据事件流.因此,事件发生的时刻、地点和激发条件等属性都是清晰可记录的信息.然后,在众多事件流汇聚之后,会出现大数据事件流的现象,而在大数据流的情况下再定义1中事件,其属性可能会因某些因素的干扰而丢失或者混乱,比如事件发生地点的二义性而造成的位置不清晰、网络延迟造成的发生时间不准确等等.本文仅讨论事件发生和处理的基本方法和技术问题,上述干扰所造成的失真情况将在以后研究中继续讨论.定义2(空事件).空事件是一种可以在任何地点、任何时刻均可发生的,任意类型的事件,记为ε.定义3(事件相等和不等).设A和B是两个事件,如果A和B满足下列条件:(1)别名不同;(2)类型不同;(3)激发条件不同;(4)发生的位置不同.则称事件A和事件B不等,记为A≠B.反之,如果上述4个条件中的事件属性均相同,则称A和B相等,记为A=B.下面给出事件算子的概念,用于描述事件之间的关系.定义4(顺序算子).设A和B是两个事件,Page4本命题之前,首先做如下约定:用AB表示A和B按时间顺序发生,“”称为事件的顺序算子.AB是一种事件顺序组合的结果,组合后还是一个事件,所以可以写成C=AB.可以进一步证明顺序算子满足结合律,即(AB)C=A(BC).定理1(顺序算子结合律).顺序算子满足结合率,即(AB)C=A(BC),其中A,B,C是3个不同的事件.证明.设A,B,C是3个不同的事件,在证明AB=〈IDAB;DomainAB;AliasA-B;TypeA∪B;MomentA∪B;StimulationA∪B;LocationA∪B〉,其中IDAB是事件AB的标示;由于事件A和B在同一个问题域内,所以域相同,记为DomainAB;AliasA-B是AB事件的别名,由事件A和B的别名编码连接串构成,即AliasA-B(“-”表示连接符号);TypeA∪B表示事件AB的类型,它是A和B类型的合集,即TypeA∪B={TypeA,TypeB};MomentA∪B表示事件AB的发生时刻,它是A和B发生时刻的合集;StimulationA∪B表示事件A和事件B激发条件的合集;LocationA∪B表示事件A和B发生的地点合集.在上述约定基础上,证明可以从结合律等式的(AB)C=〈IDABC;DomainABC;AliasA-B-C;TypeA∪B∪C;MomentA∪B∪C;StimulationA∪B∪C;Loca-tionA∪B∪C〉.同理,等式右边:A(BC)=〈IDA;DomainA;AliasA;TypeA;MomentA;StimulationA;LocationA〉(〈IDBC;DomainBC;AliasB-C;TypeB∪C;MomentB∪C;Stimu-lationB∪C;LocationB∪C〉)=〈IDABC;DomainABC;AliasA-B-C;TypeA∪B∪C;MomentA∪B∪C;Stimula-tionA∪B∪C;LocationA∪B∪C〉.观察等式左边和右边有(AB)C=A(BC),所以顺序算子的结合律成立.根据该结合律就可以把事件组合进一步扩展到两边展开.等式左边:(AB)C=(〈IDAB;DomainAB;AliasA-B;TypeA∪B;MomnetA;StimulationA∪B;LocationA∪B〉)C.由于集合的“合”运算满足结合律,所以上面的等式可以进一步展开为:多个事件的情形,即E1E2…Em也满足结合律.也就是说,m个事件顺序组合仍然是一个事件.推论1.设E1,E2,…,Em是m个事件,E1E2…Em仍然是一个事件.根据定理1和推论1可以进一步定义顺序事件流.事件顺序算子结合律的作用不仅表现在,可以把两个事件的顺序发生扩展到m个事件情形,从而对m个事件形成的顺序事件流进行表达;还可以刻画顺序事件流的部分子流的表达和处理,即通过加括号,可以优先处理括号中间的顺序事件子流.定义5(顺序事件流).设E1,E2,…,Em是m个事件,用E1E2…Em表示一个顺序的事件流.定义6(闭包算子).设E是一个事件,用E表示事件E顺序重复发生,把“”称为闭包算子.可以看出,重复发生是顺序发生的一个特例.定义7(选择算子).设A和B是两个事件,用A+B表示事件A发生或者事件B发生.“+”称为事件选择算子.定义8(因果算子).设A和B是两个事件,用A~B表示因为事件A的发生导致事件B的发生.“~”称为事件的因果算子.也可以证明选择算子满足交换率、因果算子满足结合换律,即A+B=B+A;(A~B)~C=A~(B~C).由于本文不对选择算子进行更深入地讨论,所以文中不给出相关的定理和证明.由于重点要讨论因果算子所产生的事件流,所以这里给出相关的定理.定理2(因果算子交换律).因果算子满足结合率,即(A~B)~C=A~(B~C),其中A,B,C是3个不同的事件.证明.与定理1证明过程相似,这里略.推论2.设E1,E2,…,Em是m(m是自然数,下同)个事件,E1~E2~…~Em仍然是一个事件.在定理2和推论2基础上,可以定义因果事件流.定义9(因果事件流).设E1,E2,…,Em是m个事件,用E1~E2~…~Em表示m个事件的因果事件流.定义10(协同算子).设A和B是两个事件,用AB表示A和B在某个约定下发生.“”称为协同算子.协同算子是对协同事件关系的抽象.可以分为同步协同和异步协同两种情形,为了简化讨论,本文Page5暂时不作具体区分.另一协同的情况是无约定的协同,即约定条件为空,本文把这种协同关系抽象为“同生算子”.定义11(同生算子).设A和B是两个事件,用A‖B表示A和B在同时发生,但两者没有任何约定.“‖”称为同生算子.显然,协同算子和同生算子满足结合律和交换律.由于篇幅限制,这里直接引用而不给出相关的定义和定理.在结合律和交换律满足的情况下,也可以同顺序算子和因果算子一样,定义协同事件流和同生事件流.即协同事件流为E1E2…Em;同生事件流:E1‖E2‖…‖Em.然而,协同和同生事件往往混杂在顺序或因果事件流中,并不形成独立的事件流.因此,还需要讨论顺序、因果事件流中协同事件的表达和相关处理方法问题.定理3(协同算子对顺序和因果算子的分配率).协同算子对顺序和因果算子分别满足分配率,即A(BC)=ABAC,A(B~C)=AB~AC,其中A,B,C是3个不同的事件.证明.BC=〈IDBC;DomainBC;AliasBC;TypeB∪C;MomentB∪C;StimulationB∪C;LocationB∪C〉,其中元组中的各项解释与定理1中的解释类似,略.证明可以从分配律等式的两边展开.等式左边:A(BC)=A(〈IDBC;DomainBC;AliasB-C;其中,StimulationA∩(B∪C)表示事件A(BC)激发条件,即A的激发条件与(BC)的激发条件同时满足.根据集合运算交运算对和运算满足分配率,有StimulationA∩(B∪C)=Stimulation(A∩B)∪(A∩C).因此等式左边:A(BC)=〈IDA(BC);DomainABC;AliasA-B-C;同理,等式右边:ABAC=〈IDAB;DomainAB;AliasA-B;观察分配率等式的左、右边,如果约定IDA(BC)=IDABAC,则有(AB)C=A(BC),所以分配率成立.同理,也可以证明协同算子对因果算子的分配率也成立,略.在定理3的基础上,可以进一步讨论顺序事件流和因果事件流中协同关系的表达和处理方法.定理4(协同事件流消减定理).设F1=A1A2…Ak;F2=B1B2…Bk是两个顺序事件流,它们的协同事件流:F1F2=Ai1Bi1Ai2Bi2…AimBim其中(i∈[1…k]),AiBi是有协同关系的事件对.证明.因为协同算子对顺序算子的分配率成立,所以F1F2=F1B1F1B2…F1BkAkF2Ak-1F2…A1F2;再根据分配率对上式进一步展开有:F1F2=A1B1A2B1…AkB1A1B2A2B2…AkB2…AkBkAkB1…AkBkAk-1B1…Ak-1Bk…A1B1…A1Bk.上面的等式中并非都是协同事件对,因此可以把非协同事件对消去,只对协同事件对处理,即定理4成立.对因果事件流也可以证明同样的性质,略.定理4表明,当处理协同事件时,可以对顺序事件流进行化简.同时也表明,协同和同生事件流可以驻留在顺序或者因果事件流中,当需要做协同或者同生事件处理时,可以利用定理4进行简化处理.下面给出纵/横/交错事件流模型.定义12(纵/横/交错事件流模型).设U为论域,把m个顺序发生的事件流E1,E2,…,Em-1,Em称为纵向事件模型;把m个因果、协同、同生发生的事件流E1,E2,…,Em-1,Em称为横向事件模型.把由选择算子连接的纵/横事件流称为交错事件流.在上述基本概念基础上,可以进一步定义复杂事件的代数模型.2.2复杂事件代数结构先给出复杂事件结构概念.基于上述讨论,定义复杂事件代数结构如下,首定义13(复杂事件结构).设U为论域,一个Page6件组合运算的结果也是事件结构;(1)一个事件E是一个复杂事件结构;(2)一个事件算子是复杂事件结构.由事件和由2.1节定义的算子,有限次进行事复杂事件结构记为〈E,O〉;其中E是事件集合,O是事件算子集合.由于上述事件算子的运算是封闭的,所以可以证明复杂事件结构〈E,O〉构成代数系统,称其为复杂事件代数结构(ComplexEventAlgebra,CEA),或者复杂事件代数模型(ComplexEventAlgebraModel,CEAM).定理5(复杂事件代数系统).设CEA=〈E,O〉是一个复杂事件代数结构,CEA中E对所有算子的运算O是封闭的.证明.算子集合O中运算的封闭性可以从为了辅助事件流生成,下面给出一种与复杂事2.1节中的定义和定律得出.件代数结构等价的表达方式.复杂事件结构定义为:且仅当可由下面的复杂事件产生式规则生成.定理6(复杂事件产生式).任何一个CEA当E→E1+E2|E1~E2|E1E2|E1‖E2|T;(2a)T→TF|T|F;F→(E)|e|ε其中:E,E1,E2,T和F是事件,e和ε分别是原子事件和空事件,符号“→”表示逻辑蕴含.式(2)也称复杂事件文法.证明.(反证法)设CEA的一个表达式E无法由产生式(2b)产生,则由产生式规则2可知,该表达式E中有非事件算子组合存在,即E1OiE2中的算子Oi并非事件组合算子,这与定义13矛盾.反之,如果一个由事件规则2产生的事件表达式不是一个事件结构,则与事件产生式(2b)不符.因此,定理6成立.例如:一个复杂事件结构的代数表达式e1e2可以由产生式文法产生,即E→TF→FF→e1e2.定义14(CEA模式).令E是一个CEA,如果Em是利用产生式规则(式(2))推出的结果,即E→E1→…→Em,则称Em是一个CEA事件模式,记为EEm;如果有EαEmβ和Emγ,则称γ是Em在αEmβ下的短事件模式;如果EαEmβ和Em→γ则说γ是直接短事件模式.通常把最先出现的短模式称为最左短事件模式.例如:对复杂事件模式e1e2+e3,因为按照产生式规则2有EE1+e3和E1→e1e2,所以e1e2是短模式,同时也是最左短模式.也可以定义算子的优先级.定义15(算子优先级).设O1和O2是两个事件算子,令O1<O2表示O1的运算优先级低于O2的优先级,符号O1>O2表示O1的运算优先级高于O2的优先级,O1=O2表示O1的运算优先级与O2的优先级相同.定义CEA所有算子的优先级如表1所示.+><<<<<<<>~>><<<<<<>>>>><<<<>‖>>>><<<<>>>>>>><<>>>>>>><<>e>>>>>>(>>>>>>>>=)<<<<<<其中:选择算子的优先级最低,闭包的优先级最高.这样约定优先级别与实际事件处理的紧迫性相一致,如顺序发生的事件不能等待协同发生事件.相同类型算子的优先级总是依照左优先的原则.如的优先级高于‖.为了推演方便,这里增加了括号的优先级.通过定理6、定义13、定义14和定义15一个复杂事件流的生成问题可以转化为基于复杂事件文法的模式生成和匹配问题,文法理论和技术可以直接用来解决大数据复杂事件模式的生成,以及快速处理等问题.根据定理6和定义14可以生成不同结构的CEP模式,包括顺序事件流、因果事件流、协同事件流、同生事件流,以及上述混合的事件流.定义16(纵/横/交错CEA模型).设U为论域,一个纵向CEA模型记为T=〈Ev,O〉,其中Ev=(E1,E2,…,Em-1,Em)对每一个k∈[1,m],Ek都是一个纵向事件流,即Ek=(ek1,ek2,…,ekm)是一个顺序事件流,eki(ki∈[k1,km])是事件,O是事件算子的集合;一个横向CEA模型记为T=〈Eh,O〉,其中Eh=(E1,E2,…,Em-1,Em)对每一个k∈[1,m],Ek都是一个横向事件流.即Ek是因果、协同、同生事件流;一个交错CEA模型记为T=〈Ev+h,O〉,其中Ev+h=(A1+B1,A2+B2,…,Am+Bm,)对每一个i,j∈[1,m]Ai是一个纵/横向事件流,Bj也是一个纵/横向事件流.Page7定义16是定义12的扩展.在定义16中把一个事件流作为纵/横/交错事件流中的一个事件表达,从而可以处理高阶事件流的情况,模式的复杂度更高.3事件模式检测与测试数据生成算法本节讨论基于复杂事件模型的事件模式检测算法,以及复杂事件处理引擎测试的大数据自动生成算法.3.1复杂事件模式验证算法复杂事件代数模型不仅刻画了复杂事件之间的关系,也在理论上建立了复杂事件代数模型与事件文法的等价关系,从而可以把复杂事件处理的相关问题变换到基于文法产生式的模式处理上来,利用文法理论和技术解决复杂事件处理中的问题.下面给出利用文法处理技术设计的复杂事件模式验证和模式检测的快速算法.在编译技术中有多种高级程序语言的语法单词验证与检测算法,如自顶向下语法分析中的预测分析法,自底向上的规范式规约和算符优先分析法等等.下面给出基于检测速度较快的算符优先分析法的复杂事件模式检测算法.在提出算法之前,首先证明一个事实.定理7.设E1o1E2o2…EnonEn+1是一个复杂事件模式,其中Ei和oi分别是事件和事件的运算符;如果Eioi…EjojEj+1是E1o1E2o2…EnonEn+1的最左短事件模式,则它一定满足以下条件:(1)oi-1<oi;(2)oi=oi+1=…=oj-1=oj;(3)oj>oj+1.证明.采用反证法,假如条件(1)和(3)不成立,则十分明显地与Eioi…EjojEj+1是最左短语模式矛盾;再假如条件(2)不成立,即有oi+1>oi+2或者oi+1>oi+2成立,这也与Eioi…EjojEj+1是最左短语模式矛盾.因此,定理7成立.基于定理7可推导出复杂事件模式验证算法.算法1.复杂事件模式验证算法.输入:事件模式E1o1E2o2…EnonEn+1和算符优先级表输出:是否为事件模式的裁决1.begin2.k··=H,C=“”,S[k]··=‘#’/H为事件模式的3.repeat4.readC;/读下一个被检测模式中的符号/5.ifs[k]是算子符合thenj··=kelsej··=k-16.dowhiles[j]>C/s[j]的优先级高/7.repeat/找最左短语模式/8.Q··=S[j];9.ifS[j-1]是算子符合thenj··=j-1elsej··=10.untilS[j]<Q;11.Em→S[j+1]…S[k]/用文法产生式左边的复12.k··=j+1;13.S[k]··=Em14.endwhile15.ifS[j]<CorS[j]=Cthen/s[j]优先级低或16.{k··=k-1;S[k]··=C}/符号入栈/17.elsereturnfalse;/检测失败/18.endif19.untilC=“#”;20.returntrue21.end事件模式有两种表现形式:其一是确定的事件模式,这种模式是由业务人员根据实际工作需求指定的、希望捕获的业务模式;另一种是非确定的事件模式,其形成规律需要在大数据中分析和挖掘.算法1仅讨论了第一种确定模式的检测,事件模式的长度H是确定,因此算法1的时间和空间复杂度均为O(H).例1.用算法1验证事件模式E1E2E3E4是否为合法事件模式.解:根据算法1的初始化处理,有s[7]=E1,s[6]=“”,…,s[1]=E4,即栈顶为E1.最内层循环(7)~(10)是确定最左短语模式的右边界,中层循环(6)~(14)完成最左短语模式的规约,步15~16定位最左短语模式的左边界.经过第1次对事件模式的遍历和规约后有E1E2E3E4=E1EmE4,继续上述过程,有#E#.E是事件模式.3.2事件模式检测算法复杂事件模式检测有两种基本形式:一种是在事件流中检测指定的事件模式;另一种是在事件流中归纳可能有用的事件模式.本文仅讨论前者.在事件流中检测指定的事件模式也是复杂事件处理主要任务之一,有很多基于归纳的事件模式检Page8测方法也是由指定事件模式检测方法演变而来的,所以指定事件模式检测是复杂事件模式检测的基础.大数据下复杂事件模式检测的一个技术挑战是事件模式检测的时间问题.由于大数据下复杂事件以流的形式涌入,对统计、归纳和类比相关事件关系有非常紧迫的时间限制.为此,需要设计一种能避免丢失事件,并能够快速检测事件模式的算法.本文提出一种将并行事件流串行化的方法,即对纵/横CEA模型进行串行化处理,避免事件因没有时间处理而丢失;同时再采用并行处理技术实现串行化的事件流的多线程事件模式检测,加快事件模式的检测速度.为此,在提出算法之前,先对复杂事件产生式(2)进行改进,以实现上述检测策略.定理8.由复杂事件产生式(2)产生的复杂事件模式集合与下面产生式(3)推导出的事件模式集合相同.E→E1+E2|E1ME2|TM→εTε|~||‖(3b)T→TF|T|FF→(E)|e|ε证明.首先在式(3)中,用产生式M→~|‖|替代E→E1ME2中的M时,式(3)中的式(3a)与产生式(2a)完全相同,式(3c)和(3d)与式(2)中的式(2b)和(2c)也完全相同,因此,由式(2)推出的事件模式一定也是式(3)的事件模式.反之,因为产生式(3)比产生式(2)只增加了M→εTε,所以仅考虑用M→εTε替换E→E1ME2中的M时所产生的事件模式是否是产生式(2)的事件模式即可.当用M→εTε替换E→E1ME2中的M时,可以推导出如下的事件模式,EE1εTεE2E1εe2…em-1εE2e1εe2…em-1εe2e1e2…em-1em.下面证明该事件模式也可以由产生式(2)推出.用产生式(2)进行推导,有ETTFTF…FFFF…FFe1e2…em-1em.因此,由式(3)推出的事件模式也是式(2)的事件模式.定理得证.在用产生式(3)中的M→εTε替换E→E1ME2中的M时,有EE1εTεE2E1εe2…em-1εE2E1e1…em-1E2,其中有TimeE1<Timee2<…<Timeem-1<TimeE2.如果E1与E2是并行事件(协同或者同生事件对),则产生式M→εTε的物理意义就是在并行的事件流中插入了若干个顺序事件.也就是说,横向事件流中的因果关系、协同、同生事件关系都可以按照事件发生的时间进行顺序化处理.这为CEP事件模式的检测提供了简化的处理方法.基于上述策略,给出事件流中CEA事件模式的检测算法.为了简化讨论,这里仅讨论单一算子模式的检测情况,其它情况类似.算法2.基于CEA模型的事件模式检测算法.输入:事件模式:E1o1E2o2…EnonEn+1和事件流输出:检测率统计结果1.begin2.stringstr[]=“#E1o1E2o2…EnonEn+1#”;3.charitem=“”;/存放一个输入符号/4.stringsub_Str[]=“”;/存放最左直接子模式/5.stringstack[]=“”;/存放待查符合串/6.repeat/遍历事件流/7.j=18.readitem;/读入输入事件流的一个/9.dowhilej<n+110.i=1;11.docase12.caseitem=str[j+1]∧str[j+2]=“~”13.{stack[i]=item;/Ei,压入栈中,待匹配检查/;14.str_sub[i]=str_str[i]+stack[i];15.i=i+1;/栈顶加1,事件模式指针后移/16.stack[i]=“~”;/“~”压栈/;17.str_sub[i]=str_sub[i]+stack[i];18.};19.caseitem=str[n+1]∧str[n+2]=“#”20.i=i+121.stack[i]=En+1/En+1入栈/22.otherwise23.stack[]=“”/E1o1E2o2…未匹配的子模式出栈/24.loop;25.endcase26.j=j+2;27.enddo28.ifstr_sub=“E1o1E2o2…EnonEn+1”29.then{stack[]=“”/E1o1E2o2…EnonEn+1出栈/30.elsestack[]=“”/所有item出栈/31.loopPage932.endif33.untilitem=“#”/文件结束/34.printcount;35.end算法2的时间复杂度是O(HL),其中H是事件模式的长度,L是输入事件流的长度.空间复杂度为O(Hh),这里的h是临时存放输入符号内存的长度.算法2是对基于算符优先文法的词法分析算法的改进.3.3CEP引擎测试大数据生成算法CEP引擎的任务是在不同数据源顺序混杂的事件流中发现感兴趣的事件模式.因此,为了检验CEP引擎对大数据的处理能力,就需要有体积足够庞大,或者不断流入的数据流;同时,大数据中还应该有各种分布的事件模式.本节提出一种基于复杂事件代数模型的CEP测试大数据自动生成算法,来实现对CEP引擎的测试任务和目的.本节提出基于纵/横CEA模型的大数据自动生成算法.生成的大数据集如式(3)所示.其中:〈E11,E21,…,En1〉,〈E12,E22,…,En2〉,…,〈E1m,E2m,…,Enm〉是在P1,P2,…,Pm-1,Pm读取点读到的m个纵向事件流;而〈E11,E12,…,E1m〉,〈E21,E22,…,E2m〉,…,〈En1,En2,…,Enm〉是与上述m个纵向事件流交织在一起的横向事件流.即纵向事件流:E11E21…En1,E12E22…En2,…,E1mE2m…Enm和横向事件流:E1,i1E1,i2…E1,im;E2,i1E2,i2E2,i3…E2,im;…;En,i1En,i2En,i3…En,im.其中,i1,i2,…,im是有因果,或者协同,或者同生事件关系的事件下标,表示上述算子的统称.为了明确区分这些下标,用逗点与矩阵的行下标进行了必要的区分.测试数据生成算法如算法3.算法3.生成CEP引擎测试数据.输入:纵/横CEA模型的维度m和n,以及拟生成事件输出:一个如式(3)所示的事件集合1.begin2.inti,j=1;3.dowhile(1)4.fori=1ton5.forj=itom6.{k=1;7.ifP(X=k)ratioand(m/2)=08.gent_ID(eventsID);/生成标识符/9.gent_Alias(eventAlias);/生成别名,如10.gent_Location(eventsLocation);/事件发11.gent_Type(event’smode);/生成指定事件12.gent_Moment(eventMoment);/生成事件13.gent_Simulation(eventSimulation)/记录事14.else15.gent_ID(eventsID);/生成标识符/16.gent_Alias(eventAlias);17.gent_Location(eventsLocation);18.gent_Type();/非指定事件的类型/19.gent_Moment(eventMoment);/事件发生的20.gent_Simulation(eventSimulation)/事件发21.endif22.}};23.read(n);/初始化n,以便生成n个横向事件流/24.read(event’smode);/新的事件模式类型/25.ifn=0/退出循环,结束生成事件流/26.thenskip27.enddo28.end算法中的P(X=k)满足指定的分布:如PoissonDistribution:P(X=k)=λke-λ/k!,k=0,1,2,…,(3-2).设λ=v×p,其中v是拟生成事件集中事件的数量,这里v=m×n,如TB级,ZB级等,p是一个输入值,它可以是很小的实数,如0.0002,0.00003等;ratio为输入值,表示拟生成某类型事件的比例,如0.0002,0.00003等,ratio表示在某个纵向事件流中拟生成的指定因果事件,或协同(同生)事件的个数,m/2表示在偶数位置上生成指定事件,当然也可以在奇数位置,或者随机的位置上生成,以便体现事件发生的随机性.算法中的外层循环先从n开始,Page10内层循环从m开始,这样方便不同类型事件在不同顺序事件流中的分布,也方便大数据流的形成.即,不断地初始化n值,不断地生成新的事件模式数据,就可以在m个读取点不断地生成事件流.算法的时间和空间复杂性均为O(m×n).算法中一对关键函数gent_Type(event’smode)和gent_Type(),它们分别产生指定事件模式类型下的事件和任意一个事件.事件模式类型包括因果型事件、协同型事件、同生型事件、选择型事件,以及无类型事件,这些模式中事件分布在横向事件流中.例如,一个混合事件模式CEA混合=A~B~CD‖E‖F‖G,对应的横向事件流为E11E12…E17=A~B~CD‖E‖F‖G.为此,gent_Type(event’smode)的求解算法如下.gent_Type(event’smode)/生成指定CEA模输入:CEA模式,如A~BCD‖E‖F‖G,在p1输出:CEA模式下的一个事件1.begin2.ifm=1thenreplaceEi,11withE11/横向事件流3.if[m/2]=0then4.replaceEi,imwithE1m+1/在横向事件流中偶数5.else6.replaceEi,imwithEim;7.endif8.end算法中另一个函数gent_Simulation(eventSimulation)用于生成本事件被激发的动作,在没有指定动作时,可以把事件发生的概率分布作为激发动作;否则应该生成一个具体的激发动作,如事件混合模式:A~B~CD‖E‖F‖G中的B就是一个被因果激发的事件,所以应该生成它的因果算子符号作为激发动作.对应的函数算法如下.gent_Simulation(eventSimulation)/生成事输入:CEA模式,如A~BCD‖E‖F‖G;输出:CEA模式中事件被激发的动作1.begin2.ifm=1thenreplacesimulationwithP/横向事3.if[m/2]=0then4.replacesimulationwithE1m/在横向事件流中当5.else6.replacesimulationwithEim-1;/在横向事件流7.endif8.end算法3中的其它事件子函数没有太多的细节,在实验研究中再给出具体介绍.4实验研究本节以RFID物联网为应用领域背景,检验提出算法的有效性和可行性.4.1RFID物联网应用场景课题组依照EPCglobal标准①设计了一个RFID物联网示范系统,该系统由以下主要部件构成:RFID识读器管理系统,应用层事件过滤系统和电子标签信息系统.该系统的一个应用示意图如图1所示.其中:图1中的客户服务(如图标所示),生产基地(如图标所示)和仓库物流(如图标所示)在电子标签信息系统的控制下完成其各自的功能;RFID识读器管理系统(如图标所示)负责在订货客户库房卸货时进行货物的清点,以及对识读器的管理.应用层事件过滤系统(如图标所示)负责对物品销售数据进行过滤、分析和汇总,最终形成各种报告.应用层事件过滤系统是一个典型的CEP系统,它的事件处理能力,如对业务模式辨析、统计和解释等关系到RFID物联网的应用效果.RFID物联网中的电子标签(ElectronicProductCode,EPC)有多种类型,实验研究中采用EPCglobal标准中的SGTIN-96标签作为物品的标示,格式如表2所示.头滤值比率公司前缀参考值序列号83320~2424~2038头占个二进制位,滤值占3个二进制位,以此类①EPCglobal.Architectureframeworkfinalversion.http://ture_1_4-framework-20101215.pdf,15December2010,Page11推.SGTIG-96是最常用的物品编码,实验中把该标签作为原子事件中的别名.图1RFID物联网工作流模型实验中设计了3个EPC读取点A,B,C.在这3个读取点上分别形成纵向事件流和横向事件流,其中可以有各种事件关系存在,如EA~EB~EC.4.2CEP引擎测试数据生成实验根据图1设计的应用场景以及纵/横CEA模型(式(3)),CEP引擎测试数据集应为n×3的矩阵,其中n是一个可变的纵向事件模型的长度,数字3为应用场景中3个不同的RFID识读器的读取点个数.实验中分别生成了5GB、10GB、15GB、20GB、30GB、40GB和60GB共7组不同规模的测试数据集,用于测试在不同量级下测试复杂事件模式检测的处理能力和效果.按照算法3中采用的事件模式概率分布,在测试数据集中分别播撒了不同数量的事件模式.测试数据的结构如表3所示.算法3实现的数据字典如下:E=ID+Domain+Alias+Type+Moment+Stimu-lation+Location数据量/GB模式类型1015203040601…9;ID=[char,char|num];char=a…z,A…Z;num=Domain={char}Alias={[0,1]}96//采用SGTIN-96编码作为物品Type=[Aggregation,Transaction]//实验中选择EPCglobal标准中规定的集合事件类型、交易事件类型作为事件关系样本.因为这两种事件类型可以根据业务场景产生很多种事件关系组合,如一个集装箱中的所有物品的编码可以构成一个集合事件,当集装箱中的货物在A,B,C这3个不同地点卸货的时候,就会产生A~B~C事件组合,表明B和C事件是因为Page12A的发生而发生.Moment=0…9Stimulation=[possion]//有两种取值:当该事件是在指定的事件模式中,字段取值为事件模式的算子,如事件模式A~B~C中的A,B,C这3个事件的Stimulation字段填“~”;而其它非模式指定事件填写“possion”,简称“PS”.Location={char}//只考虑A,B,C这3个订货商的业务情况.采用Java技术实现数据生成算法,生成的测试数据集如图2所示.图2是基于算法3,并按照图1所示的RFID物联网工作流模型生成的测试数据集截图.其中,各个字段的含义参加数据字典定义.A、B和C这3个事件的标示均为96位EPC,格式参加表2.三者为一个集合事件中的子事件,从编码的格式中可以鉴别,即在表2中只有序列号不同,而具有共同的类型编码,因此它们形成了一个A~B~C事件模式.测试数据集中每个事件的七元组按行存放,3个读取点的并行事件流,依次按行摆放.不同测试数据集生成的时间如图3所示.4.3CEA事件模式检测算法实验为了比较大数据复杂事件处理引擎在不同计算环境下效率,推荐CEA事件模式处理的最佳运行环境,下面分别在单机和集群上实现CEA事件模式检测算法(算法3).在表4所示的实验环境下,分别对A~B~C,AB~C等事件模式进行过滤检测,不同测试数据集的检测结果如表5所示.如,对事件模式A~B~C共分布了250000个,检测到的该事件模式总数目为2499914,发现数量比例为2499914/2500000=99.99656%≈100%,运行时间为9.24min.环境CPUCluster2.4GHzLinuxHadoop-1.0.4PC3.0GHz+4CoreWindowsJava数据量/GB模式类型/数量发现数量比例/%5A~B~C/250000010AB~C/500000015A~BC/750000020A~B‖C/1000000030ABC/1500000040AB~C/2000000060A~BC/30000000有些事件模式的发现率未达到100%,主要原因是随着数据量的增大,数据噪声干扰也不断增加.虽然有漏检情况发生,但检测成功率基本接近100%,所以完全可以达到对事件模式的检测效果.在测试数据生成效率方面与著名的大数据基准FinCos[7]中的数据生成器Pairs进行了比较.Pairs工具在生成同等体积数据集时的耗时明显高于本文基于算法3实现工具的耗时,参见图4中的两条曲线.其原因在于Pairs生成数据集的时候,需要重构工作流模型,应用场景比较复杂.Pairs采用泊松分布作为事件模式的随机促发条件,而本文提出的算法3可以采用泊松分布和正态分布,其生成数据的仿真效果比Pairs手段更丰富.在生成数据多样性方面,由于两者的工作流不同,所以还无法比较其优劣.Page13对事件模式检测算法的运行时间进行了比较实验,分别统计了基于PC机和基于Hadoop集群的运行效率,实验结果如图4所示.其中,在数据量较小的情况下,如5~30GB时,PC机的耗时比较少,而Hadoop集群的耗时较高;当数据量大于30GB时,情况正好相反,Hadoop集群耗时低于PC机的耗时.为了验证这样判断,又对Hadoop集群进行了系统配置调优实验,实验数据参见表6.数据节点任务耗时/s耗时/GB耗时差/s55106.211.2420.33657147.891.5783051020.640.6880.1353071416.580.5526051424.310.4050.0366071626.480.441从表6可以看出,Hadoop-1.0.4在生成30GB数据时,配置7个数据节点(自动配置14个任务)的时候,执行时间会有一个明显的下降,耗时分别为20.64min和16.58min;而在生成5GB数据时,配置7个数据节点并没有比配置5个节点的时候耗时降低.从耗时与数据量的比较,即耗时/GB的值也可以看出,在30GB配置7个数据节点时的比值是0.552,比值最低.另外,7个数据节点比5个数据节点的耗时差随着数据量的增大逐渐变小,所以在大数据量情况下,分配的数据节点作用不明显,而在数据量小的情况下,数据节点多会影响Hadoop平台的效率.上述数据说明在数据量比较小的时候,由于系统在调度上消耗了一定的时间,其性能并不一定是最好的情况,只有在数据量达到一定值的时候(如30GB)的时候,Hadoop平台才进入比较高效的运行状态.5相关研究本节分别综述复杂事件模型、CEP处理技术和CEP测试基准三方面的相关研究成果.Saleh等人[8]的工作与本文研究方法相似,采用代数的理论和方法支持复杂事件的抽样、过滤和加工过程的算法描述,如事件的交集、合集、顺序等事件集合运算.但作者仅利用这些集合运算支持对数据的重排,而没有提供对事件模式的检测和识别.Ogasawara等人[9]以科学实验工作流作为研究对象,研究复杂事件处理的过程优化.采用关系代数作为建模手段,定义了一组关系和关系的运算,如Map、SplitMap、Filter、SRQuery和JionQuery等.这些关系运算用于复杂事件映射、映射分割、过滤和数据检索操作.该研究工作主要解决了复杂事件的处理和事件模式的过滤操作表述问题,没有给出具体的实现手段,比如,对流式数据如何存储和快速处理都没有给出详细的解决方案.Dias等人[10]论述了如何用代数方法建立大数据模型的问题,并通过实验评价代数建模途径的可行性.孟由等人[11]针对大数据状态下,对扩展语义复杂事件处理模型的需求,提出了基于算子的可扩展复杂事件处理模型.该模型能够较好地支持现有各类查询语义,具有较快的识别速度.但研究中对算子的定义并没有给出应有的数学表述,所谓的算子仅解释成一种复合操作函数,文中也没有讨论事件之间关系.但传统的系统建模技术也在复杂事件模型理论中扮演主要的角色.Ma等人[5]对目前在CEP模型研究和开发中使用的传统系统模型进行了分类,包括:(1)基于图的CEP模型[12-13],模型中用叶节点表示原子事件,而父节点表示按一定操作语义对子树事件的汇聚,逐层汇聚直到复杂事件的发生.该模型虽然结构明晰,但并没有对事件汇聚的类型进行分类和阐述,读者不得不根据应用场景临时定义事件的关系操作;(2)基于自动机的CEP模型[14-15].把所有事件映射成自动机的一个状态,事件的发生被看成是状态的迁移,因此一个复杂事件与一个有限状态机模型对应.显然,这种对应没有考虑到大数据流的情况,表达和处理能力有限;(3)基于PetriNet的CEP模型[16].把复杂事件映射成一个PetriNet,其输入是原子事件,输出即是复杂事件,这实际上也是一个自动机模型.事件模式检测是CEP中的一个关键技术,一直Page14是业界研究的焦点.Agrawal等人[17]设计了一个模式检测的一个语义框架,通过定义一些语义规则为模式检测提供最优选择的支持.文献[18-19]对目前事件模式检测技术给出了评价,认为目前的技术只限于在有限的数据集中检测指定的事件模式,而无法适应大数据流的应用场景中,主要是缺乏对事件闭包的有效支持.非确定性的事件处理也是一个重要的研究领域,该领域主要关注对非确定性事件的说明,随机事件模型等复杂的数学建模问题[20-23].由于本文不讨论非确定事件的处理问题,这里不再比较.物联网作为大数据复杂事件处理的典型业务领域,相关研究也非常活跃.Wang等人[22]针对物联网复杂事件处理中的能力不足,提出了高性能的复杂事件流处理方法.该方法采用非确定的有限自动机和活动实例栈解决随机事件模式的检测和过滤问题,但只限于高层物联网事件的处理,没有对细节的设计,实验也是在仿真环境下进行,可再现难度较大.Poul等人[24]提出了一个类似于数据库查询技术的高层事件模式的过滤算法.通过说明模式查询语句实时报告事件模式的查询结果.大数据相关技术研究虽然起步较晚,但也有一些阶段性研究成果可以参考.Yan等人[25]提出了一个并行快速迭代聚类(PowerIterationClustering,PIC)算法,该算法有效地扩展了原PIC算法的对大数据的处理能力.Patel等人[26]报告了利用云技术实现大数据并行处理的实验结果,并给出了肯定的结论.Abad等人[27]利用马尔科夫过程回报模型评价大数据处理的性能,给出了两种生成工作流的算法,一个用于评价常规工作流,另一个用于评价随机工作流的处理性能.下面再来看看CEP测试基准相关研究情况.由于目前大数据处理引擎多采用Hadoop平台实现,因此基于Hadoop的复杂事件处理引擎测试基准研究也相对较多.CloudSuite①是瑞典国家实验室推出的Hadoop测试基准,它提供了8种服务,可以真实地运行被检测系统,从而评价被检测系统的性能.GridMix②是Hadoop自带的一个测试基准,它具备评测大规模数据处理系统所需的各个功能模块,包括:产生数据,生成并提交作业,统计作业完成时间等.GridMix更适合对应用级的Hadoop系统进行评测,而不是针对大数据处理引擎算法的评测.Hive③是基于Hadoop的一个数据仓库工具,可以将结构化的数据文件映射为一张数据库表,并提供简单的SQL查询功能,可以将SQL语句转换为MapReduce任务去运行.其优点是学习成本低,可以通过类SQL语句快速实现简单的MapReduce统计,不必开发专门的MapReduce应用,但只适合数据仓库的统计分析.ICTBench④是中国科学院发布的大数据测试基准,分为大数据测试基准、数据中心测试基准和云平台测试基准.ICTBench通过提供真实数据和一些检查作业来评价大数据处理系统的性能.非Hadoop平台下CEP引擎的测试基准研究和开发也是当今的热点的话题.SPECjms2007[28]是一个针对基于JMS(JavaMessageService,JMS)信息处理中间件的一个测试基准.该基准提供了标准的工作流,以及每个工作流的驱动接口、事件类型和信息数据结构.SEPCjms2007没有提供专用的测试集,测试活动只能在该基准的工作流下完成,是一个典型的过程驱动的测试基准.BEAST[29]是一个面向对象主动数据库系统测试基准,该基准提供了事件发现、事件组合、事件规则过滤和检索等功能,已经成功地用于多个面向对象数据系统的测试工作,如ACOOD、Ode和REACH等.LinearRoad[30]是一个流式数据管理系统测试基准,该基准主要关注流式数据库对流式数据和历史数据检索时间的评价.FinCos[7]是一个基于Java的测试基准工具集,包括测试数据生成和CEP引擎的性能评测工具,FinCos是主要针对股票交易复杂事件处理而开发的一款CEP引擎测试基准.Xiong等人[6]强调了测试基准在大数据研究中的作用,并发现现有的测试基准有很多冗余的数据,并给出了如何清除冗余数据的方法,以便提高测试的效率.测试基准的数据生成与数据处理的工作流密切相关.Shahbaz等人[31]提出一种利用Web搜索引擎自动生成测试数据的方法.该方法虽然不是针对测试基准提出的数据生成方法,但方法新颖,代价低,测试基准中可以借鉴该方法生成测试数据.Aleti和Grunske[32]提出了一种基于遗传算法的测试数据生成方法,此类方法经常用于生成软件可靠性测试的用例.金澈清等人[33]综述了数据管理基准的发展现状,指出了大数据时代数据评测基准的发展趋势.其中对如何生成大规模的模拟数据也给出了概括,归①②③④Page15纳为两种方法:其一是数据驱动方法;其二是查询引导的方法.列举了多款数据生成器软件,如MUDD(aMulti-DimensionalDatagenerator)、QAGen(Query-AwareGenerator)、DSGen(DecisionSupportGenerator)等.然而,这些模拟数据生成器均源于海量数据库的测试基准,对大数据的新特征表现化不完备.Yu等人[34]介绍了自主开发的社交媒体大数据模拟生成系统BSMA-Gen的基本功能和技术原理.该工具采用非齐次泊松过程模型生成测试数据,用于模拟真实社交媒体数据的分布和时间线.实验表明了BSMA-Gen可以确保生成的时间线在转发结构、时序分布、用户消息数等方面符合预先给定的分布和参数.与本文研究方法有些相似,都采用泊松过程模型生成数据;所不同的是本文针对RFID物联网应用领域生成模拟事件流,并且本文给出的数据生成算法基于CEP代数模型和物联网工作流模型,有理论基础和应用背景.随着物联网应用的深入,物联网中复杂事件处理引擎和相关测试基准研究将会逐渐展开.6结论由于不同领域有不同的大数据形态,所以大数据下复杂事件处理和测试显得十分困难.本文在复杂事件建模、复杂事件模式检测和CEP引擎测试大数据生成方面进行了必要的尝试.主要贡献如下:(1)提出了一个复杂事件代数模型.该模型可以刻画复杂事件之间的组合关系,为进一步用事件文法方法分析和处理复杂事件模式检测提供了新的思路.(2)提出了一个基于复杂事件代数模型的CEP引擎测试大数据生成算法.该算法可以生成指定规模的数据集,也可以生成数据流,并且按照不同的概率分布在数据集合中播撒事件模式,用于检验CEP引擎的处理能力.(3)对上述贡献从理论和实践两个方面加以证明和实验检验,均表明提出的模型和算法有一定的理论意义和实际意义.本文介绍的研究工作还有不尽理想的地方,如播撒模式的随机性还需要进一步研究,努力接近或者达到真实数据的测试效果;提出的算法仅仅在RFID物联网场景下的复杂事件模式检测和CEP引擎测试中得以应用,还没有在更广泛领域中实验,所以对其它领域的技术贡献有待验证.
