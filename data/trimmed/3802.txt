Page1基于传播引擎的指针引用错误检测衷璐洁1),2),3)霍玮1)李丰1),3)陈聪明1),3)冯晓兵1)张兆庆1)1)(中国科学院计算技术研究所计算机体系结构国家重点实验室北京100190)2)(首都师范大学信息工程学院北京100048)3)(中国科学院研究生院北京100049)摘要指针在C程序中应用广泛,指针引用错误多发且危害严重.目前代表性的检测工具由于使用方便性和检测精度不足以及难以处理大规模程序等原因,并不能满足实用需求.文中提出一种新型的错误检测方法,该方法基于域敏感、流敏感和上下文敏感的传播引擎,通过定义错误属性格、在源程序中对错误属性格值进行计算和传播来完成错误检测.在开放源码编译器Open64中实现了其原型系统Propagator.以空指针引用错误检测为实例研究内容,使用Apache、OpenSSH、gzip等应用领域广泛的典型应用为实验用例.与Saturn、Splint和Clang-SA进行对比,Propagator的平均检测时间仅为12s,误报率平均仅为13%,远低于对比工具,且没有发现漏报已知错误.上述结果表明,Propagator既提高了检测精度又保证了可扩展性,具有很好的实用前景.关键词空指针引用;错误属性格;上下文敏感;静态检测;传播引擎1引言在C语言程序中指针使用非常广泛,由于其用法灵活,极易在程序中造成错误.在诸多程序漏洞隐患中,指针所引发的安全漏洞屡见不鲜,后果严重.指针引用错误,特别是未赋值的“野”指针、值为空的指针,引用错误出现频率高,危害大.以空指针引用为例,它可能引发拒绝服务攻击、提升内核权限、执行任意内核态代码等安全问题,使应用程序、甚至操作系统内核崩溃.例如图1所示的中国国家信息安全漏洞库①发布的信息:从2004~2011年,空指针引用漏洞数呈现总体上升的趋势.空指针引用漏洞涉及应用面广泛,包括操作系统(如Linux内核、FreeBSD等)、浏览器(MicrosoftIE、MozillaFirefox)、网络协议、服务及应用、文字处理软件(如MicrosoftOffice)等.在国家互联网应急中心2010年的网络安全信息与动态周报中曾报道:Firefox等软件存在的空指针引用等内存漏洞使互联网上的百万服务器受到威胁,这些漏洞可被攻击者利用来执行任意代码或导致主机拒绝服务,对网民的上网安全造成严重影响②.因此,指针引用错误检测对于提高软件可靠性,避免漏洞的发生具有重要意义.对指针相关错误的检测方法通常可分为动态和静态两大类,其中动态方法需要运行程序,依赖于测试用例,只能发现被执行路径上的错误,且测试用例的构建仍然是一个开放问题.相对而言,静态方法直接作用于程序源代码,可以检测程序中所有路径,并且不需要测试用例,具有更好的完备性.本文重点关注静态检测方法.以空指针引用错误检测为例,采用静态分析方法进行空指针引用错误检测并不是一个新问题,在这些采用静态分析的检测方法或工具中,除了使用传统的流分析,还常常与定理证明、模型检测、符号执行等技术相结合,以达到更高的检测精度.其中定理证明和模型检测的方法自身的局限导致可扩展性表现不理想,例如验证条件长度与程序规模呈指数增长[1],穷举遍历程序状态空间的时空开销很大[2-3]等.除此之外,这些形式化方法通常需要用户的参与,需要使用事先定义的规约语言对源程序进行标注或性质描述,如Saturn[4]、Spec#[5]、Calysto[6]等.这些工具的标注往往很难编写.而符号执行方法虽然无需用户直接干预,但其检错能力和效率也往往受制于约束求解工具,同时因为需要对路径进行逐条推理,其时空开销也非常大,如Clang静态分析器[7]分析二十几万行的Apache代码,需要约2个小时左右的时间.可见,目前大多数的采用静态分析的检错方法或工具还不能很好地满足实用需求.经过分析不难发现,指针引用错误主要涉及指针非正常的赋值和引用,其本质实际上是广义上的定值-引用流分析问题.因此我们基于编译技术提出流敏感、域敏感、上下文敏感(下文简称多敏感)的传播引擎,并利用该引擎准确高效地进行错误属性的计算与传播.我们的方法不仅能很好地适用于指针引用错误的检测,对于任何可建模为格值模型的错误类型,均可进行有效的检测.本文提出的基于传播引擎的错误检测方法具有以下优势:(1)将检测过程与编译过程紧密结合,用户无需学习或掌握任何规约语言,在程序进行编译的同时即可完成错误的检测.(2)错误检测精度高,精确的程序分析结果能够带来健壮而准确的程序信息,从而获得高精度的检测结果.(3)可扩展性好,成熟编译器具有有效处①②Page3理百万行以上程序的能力,为高可扩展性提供了坚实基础.本文将重点介绍传播引擎用于空指针引用错误的检测.本文的贡献为:(1)提出基于传播引擎的错误检测方法.该方法定义了错误属性格模型,将错误检测问题转换为错误属性格值的计算与传播.(2)给出了多项式时间的流敏感、域敏感和上下文敏感的错误属性格值计算方法.并在Open64编译器中实现了基于传播引擎的错误检测原型系统Propagator.(3)以空指针引用错误检测为实例研究,对Apache、OpenSSH、gzip等应用领域进行广泛的典型应用实验,结果表明Propagator的平均检测时间为12s,在检测精度方面,Propagator的误报率平均为13%,没有发现漏报已知错误.2相关工作模型检测、符号执行、静态分析是静态检测指针引用错误的典型方法,下面对其中代表性方法和工具进行讨论.Saturn[4]是斯坦福大学开发的研究型静态分析工具的代表,可以用于空指针引用等多种指针错误的检测.它首先对待检测的程序进行建模,然后基于可满足性求解的程序分析框架对建模编码后的程序进行分析,最后按照事先编写好的检测目标文件中指定的步骤完成检测.Saturn将指针建模为条件位置集合(GLS),以表示指针在某个特定程序点在计算出的条件下可能指向的内存位置集合,这样的指针模型在理论上是精确的,但在实际应用尤其是那些具有复杂分支以及可能组合出复杂路径的程序中,条件的表示和约束求解的难度很大,时空开销会因为路径复杂度而急剧增加,导致分析时间过长或根本无法完成.比如Saturn分析15万行的OpenSSH程序就花费了约1小时的时间,而对于SPEC2000中的C程序分析也有近半数无法成功结束.Splint[8]是工业界使用得较为广泛的一个工具,原名LcLint.它采用轻量级静态分析方法实现ANSIC程序漏洞(包括空指针引用错误)的检测.但Splint的误报和漏报较多,这主要是因为Splint仅进行过程内的分析.Clang静态分析器(Clang-SA)[7]①以libAnalysis库的形式内置于LLVM的Clang编译器中.Clang-SA可以检测的错误类型中包含空指针引用在内的多种逻辑错误.Clang-SA利用内部编译器结构查找典型程序错误,使用源代码级的控制流图,对源程序进行过程内流敏感、路径敏感的程序分析以及符号执行,其指针分析采用基于区域(region-based)的内存建模的方法[9].但是因为不能对全局指针、函数指针等有效建模并且过程间分析也不够完善等原因,Clang-SA的检测精度还不甚理想,此外它也同样存在因路径组合带来的时空开销问题.另一些空指针引用错误的检测研究工作基于数据流分析的扩展,例如:Manevich等人[10]提出一种针对空指针引用检测的PSE算法,该算法采用流不敏感的别名分析和后向数据流分析.但该方法由于采用流不敏感的别名分析,因此有较多误报产生.徐厚峰等人[11]基于PSE算法,提出了一种需求驱动空指针引用错误检测的后向数据流分析算法,但同样存在指针分析精度不够带来的误报问题.张冠楠等人[12]提出一种以函数摘要为基础的函数间分析方法,该方法利用状态机对函数间的空指针引用错误进行检测,但他们的方法因为检测算法及空指针错误状态模式不完备等原因不能在实际应用中保证所有类型的函数间的空指针引用故障都被检测出来,漏报率较高.工业界也有一些工具可以用于空指针引用错误的检测,代表性的有KlocworkInsight、Coverity静态分析工具、Logiscope等.其中,Klocwork②是加拿大Klocwork公司开发的一个源代码分析工具,可以用于编码缺陷的检查.Coverity静态分析工具③由美国Coverity公司开发,使用抽象解释对程序源代码中错误进行检测.IBM的Logiscope④是一个静态测试工具,主要以3种独立工具的形式出现,分别完成一项主要功能,包括软件质量分析工具Audit、代码规范性检测工具RuleChecker和测试覆盖率统计工具TestChecker,其中Audit和RuleChecker提供了对软件进行静态分析的功能.这些工具因为属于商业用途,其公开资料缺乏,因此未能对其进行过多的评价.此外,Novillo在2005年提出并实现了一个GCC传播引擎[13].GCC传播引擎实现了一个广义上的传播算法,该算法主要应用于静态单赋值形式①②③④Page4上的条件常量传播、复写传播和值范围传播,仅进行了过程内的分析.该传播引擎的应用领域主要是编译器内信息的传播,其目标是服务于编译优化,保守的程序分析信息不能有效支持程序错误检测.3基于格的多敏感传播引擎3.1研究动机在编译器中有许多变换基于传播的概念:在定值点产生的值被传播到使用这些值的引用点.例如,常数传播是当赋值语句右部是常数时,按照流分析所得的定值-引用链,将常数传播到其左部量的引用点,这样对变量的引用就代替为对常数的引用,达到了优化效果.而很多错误的发生也表现出定值引用的特征,特别是指针引用相关的错误,以空指针解引用为例,一般表现为在程序中某个程序点进行了空指针的定值,而在其它程序点进行解引用时引起空指针解引用错误.类似地,若将未赋值也看成一种特殊的定值的话,那么未赋值的野指针引用也呈现类似特征.此外还有文件打开关闭,内存泄漏等指针相关错误也可归为此类.为此,受启发于传统的编译传播,我们将传播的内容扩展至刻画错误特征的属性值,然后通过对属性值的计算和传播达到错误检测的目的.基于此想法,我们提出基于传播引擎进行错误检测的方法.针对错误检测目标,传播引擎需要解决可扩展性和检测精度的问题.为了获得高可扩展性,我们的传播引擎并没有引入大开销的路径敏感分析,而是设计并实现了多项式时间复杂度的错误属性计算与传播算法进行错误检测.这样做并不会造成很大的检测精度损失,其主要原因在于:(1)并不是所有错误的检测都需要用到路径敏感的信息,例如,那些所有路径都会触发的错误.(2)在指针引用错误检测中,有很多错误可直接通过单分支条件进行识别或排除,对这些错误只需利用简单的策略即可处理.从我们的实验数据看,处于这两种情形的错误所占比例高达86%.而为了更好地支持高精度的错误检测需求,我们的传播引擎还对传统的面向编译优化的保守程序分析进行了多敏感的扩充,在传播引擎中整合了面向错误检测的更为精确高效的程序分析基础设施.并基于全稀疏的SSA框架实现了高效准确的分层指针分析[14],为指针引用错误的检测提供了更好的精度支持.相对地,采用路径敏感分析方法的检测工具为了获得高检测精度,往往需要对逐条路径进行分析和求解路径可行性,分析开销很大,且极易发生路径爆炸等问题,加之受到约束求解器能力的限制,极大地制约了这些方法的可扩展性.另一方面,也正是因为没能完成对程序所有部分的分析,这些检测方法往往也面临精度上的损失.3.2低开销、高精度的传播引擎检测方法本文定义了一个基于格的传播引擎,通过定义特定类别的错误属性格值实例化传播引擎,实现了特定类别错误的高效、准确的检测.错误属性格模型的引入,实现了将错误检测问题变换为错误属性格值的计算问题,这种变换的好处在于能够简洁、清晰地完成错误属性的刻画与检测算法的描述.格上的偏序关系对应了相应的格值计算规则.定义2.程序P中的变量集合记为V,函数集合记为F,表达式集合记为E,E有如下3种形式:直接变量操作v;运算表达式op(e1,e2,…,en);函数我们的传播引擎错误检测方法是一种低开销、高精度的错误检测方法.其输入为待检测程序和错误属性格值模型,基于格的定值-引用类错误属性格值建模实现了简洁清晰的错误属性刻画并为高效的属性格值计算奠定了基础.程序分析基础设施的多敏感扩充提供了更好的精度支持.低开销的多项式时间的多敏感错误属性计算与传播算法在属性格值计算和传播的过程中完成错误检测(其中,过程内的属性格值计算算法基于SSA和域模型对程序中各个函数的属性格相关语句进行属性格值的迭代计算并在有限属性格高度内终止,实现了多项式时间的流敏感、域敏感的过程内属性格值计算.而过程间的属性格值计算是基于高精度的程序分析构建的精确的引用输入和定值输出的函数副作用模型,高效准确地实现了针对不同上下文的多项式时间的过程间属性格值计算).最后,对错误报告进行输出.3.3属性格及格相关语句关联函数(VAL,Fmeet,Funion),其中:义由所要解决的问题确定.定义1.属性格AL是一个代数系统AL=属性格上VAL、函数Fmeet和函数Funion的具体定VAL是刻画某种类型错误的属性格值集合;函数Fmeet:VAL×VAL→VAL是AL上的最大下界函数;函数Funion:VAL×VAL→VAL是AL上的最小上界函数.用于实现从错误属性的计算到格上运算的映射.Page5调用表达式f(e1,e2,…,en),其中v∈V,op表示运算符,e1,e2,…,en∈E,f∈F.语句集合S有如下3种形式:分支语句if(e)thens1elses2;跳转语句gotoe;赋值语句e1=e2,其中e,e1,e2∈E,s1,s2∈S.定义函数Faccess为E→2V,用于计算表达式中直接或间接操作的变量集合(包括仅含单元素的变量集合)的集合.定义3.属性格相关语句关联函数Frelate:S→ALBOOL用于判断源程序中的语句s是否属于属性格相关语句的集合,其中属性格相关语句由具体属性格决定,BOOL为布尔值集合.通常情况下,条件表达式和跳转语句本身不会传播属性格值,因此不会成为属性格相关语句.定义4.格值映射函数Fattr:V→VAL是从源程序变量集合V到属性格AL上格值集合VAL的映射.表示对变量求其格值.3.4过程内流敏感、域敏感的格值计算定义5.语句属性格值计算函数Fcompute:S→BOOL,用于定义源程序语句中所操作的变量的属性格值的计算逻辑,并返回该语句是否会引起变量格值变化的信息.根据属性格值的计算范围,Fcompute具体由过程内格值计算和过程间格值计算构成.根据定义2,对于过程内格值计算而言,属性格相关语句s是赋值语句,记e1=e2,Fcompute的计算规则如下:假设有ve2∈Ve2,Ve2∈Faccess(e2)及ve1∈Ve1,Ve1∈Faccess(e1):(a)若ve2domain(Fattr),则Fattr(ve1)=vAL,其中vAL∈VAL,domain(Fattr)表示Fattr的定义域.(b)若ve2∈domain(Fattr),则(b.1)若Faccess(e2)={Ve2},那么Fattr(ve1)=Fattr(v),v∈Ve2,v为各种形式的直接引用.(b.2)若Faccess(e2)={Ve2i|1in},Ve2i为e2涉及的变量集合,那么Fattr(ve1)=Fmeet(Fattr(τ),Fattr(vt))或者Fattr(ve1)=Funion(Fattr(τ),Fattr(vt)),其中,τ为虚拟的变量,Fattr(τ)=Fmeet(Fattr(vj),Fattr(vk))或Fattr(τ)=Funion(Fattr(vj),Fattr(vk)),vj≠vk≠vt,vj∈Ve2j,vk∈Ve2k,vt∈Ve2t,1j,k,tn.注:函数调用语句的格值计算参见过程间属性格值计算部分.算法1中给出了过程内格值计算算法的描述.其中in_attr用于过程间格值计算.特别地,当in_attr值为NULL时表示对该函数进行上下文无关的过程内格值计算.Sf表示函数f中的语句集合.该算法复杂度受函数f中的语句数n(内层循环上限为需要对函数f中所有的语句进行遍历)和属性格的高度h(while(change)的终止取决于属性格的高度)的影响,因此时间复杂度为O(h×n).基于SSA对函数f内属性格相关语句进行属性格值计算,可以达到流敏感的效果.这是因为SSA保证程序中每一个变量引用都有唯一的变量定值到达,也就说SSA形式上在表示定值引用关系的基础上通过引入不同的变量名来区分同一个变量在不同程序点的定值,这样算法能够自然区分源程序中同一变量在不同程序点的定值情况,从而实现流敏感的分析.同时,该算法的域敏感性体现在实现Faccess函数时基于域模型计算一个表达式直接或间接操作的变量.算法1.过程内格值计算算法:基于SSA对过程内的属性格相关语句进行属性格值的计算.1.procedureintra_compute(f,in_attr)2.boolchange=true;3.while(change)do4.change=false;5.while(s∈Sf)do6.if(Frelate(s)&&Fcompute(s))then7.change=true;8.endif9.endwhile10.endwhile11.end3.5过程间上下文与上下文敏感的格值计算上下文敏感的过程间分析方法可以获得更准确的程序信息,其中的一个重要问题是上下文的刻画以及函数副作用的抽象,典型的上下文包括函数形参和全局量等,当调用点数量众多的时候,分析开销很大.因此,如何有效避免上下文计算规模随调用点个数呈指数增长[15]是关键问题之一.本文提出的传播引擎中实现了一种基于摘要的上下文敏感的格值计算方法,充分利用高精度的程序分析获得准确的定值-引用信息,并在此基础上构建精确的引用输入和定值输出的函数副作用模型,实现了摘要的高效、准确计算.(1)建模.对于属性格值计算与传播中函数副作用的刻画,只需重点关注该函数向上暴露的引用和向下暴露的定值,本文将它们建模为函数的引用输入Use_In集Page6合和定值输出Def_Out集合.定义6.函数f的引用输入Use_In集:该函数中所有向上暴露引用的形式参数和全局量集合.定义7.函数f的定值输出Def_Out集:该函数所有向下暴露定值的返回值和全局量的集合.图2所示的工作机制包含两个阶段:在函数副作用计算阶段,根据引用输入和定值输出,我们为每个函数计算引用输入的“摘要”以获取引用输入在该函数中的引用信息,并为每个定值输出计算具体问题相关的“摘要”以获取定值输出在该函数中的定值信息.根据是否依赖于引用输入分为两种情形:对于不依赖于引用输入的情形,可直接计算完成定值输出的相关属性格值;对于依赖于引用输入的情形,需要在属性格值传播阶段根据具体的上下文进行“摘要”计算的更新:先在实际的调用点处,将上下文传入给被调函数的引用输入,然后对引用输入“摘要”相关的属性格值进行再计算,另一方面,对于依赖于引用输入的定值输出也需重新计算相关变量的属性格值,同时对于定值输出会影响主调函数的情形,还需要进行相应的传出处理,以同步更新调用函数中相关全局量、返回值等的属性格值.(2)上下文敏感的过程间格值计算.定义8.假设函数f中所有被调用函数的调用点的集合为CSf,若存在cs∈CSf,则记Actual_In(cs)是在调用点cs处传入函数f的实参变量或全局量,Actual_Out(cs)是在调用点cs处被函数f返回值修改的变量或在函数f中修改的全局量,ActualIn_VAL(cs)是在调用点cs处传入函数f的属性格值,DefOut_VAL(cs)是在调用点cs由函数f传出的属性格值.Map(VAL,V)表示将属性格值集合VAL赋给变量集合V中对应变量,即Fattr(v)=vAL,其中,v∈V,vAL∈VAL.过程间上下文敏感的格值计算需要增加函数调用点处属性格值的传入和传出的工作.即过程间上下文敏感的格值计算由3个部分组成:将调用点处上下文属性格值传入给引用输入(Map(ActualIn_VAL(cs),Use_In))、函数体内的格值计算(intra_compute(fcs_callee,ActualIn_VAL))以及将定值输出的属性格值传出给主调函数中调用点处(Map(DefOut_VAL(cs),Actual_Out(cs))).规则是:对于函数调用语句e=f(e1,e2,…,en)的计算(a)若Actual_Outdomain(Fattr),则Fattr(ve)=vAL,其中vAL∈VAL,ve∈Faccess(e),格值的确定取决于待解决的具体问题.(b)若Acutal_Out∈domain(Fattr),则Fattr(ve)=Fmeet(Finter_compute(Fattr(Actual_In)))或者Fattr(ve)=Funion(Finter_compute(Fattr(Actual_In))),ve∈Faccess(e),Fmeet或Funion函数的选择取决于待解决的具体问题并且可以按照定义5的(b)中方法处理多元集合的情况.算法2.过程间格值计算(上下文敏感的格值传播)算法.1.procedureinter_compute(P)2.forallf∈Pdo3.intra_compute(f,NULL);4.endfor5.forallf∈Pdo6.forallcs∈CSfdo7.Map(ActualIn_VAL(cs),Use_In);8.intra_compute(fcs_callee,ActualIn_VAL);9.Map(DefOut_VAL(cs),Actual_Out(cs));10.endfor11.endfor12.end算法中第3行处的intra_compute(f,NULL)函数用于为一个函数f计算摘要.第7行处的ActualIn_VAL(cs)可在摘要计算过程中获得.第8行处的intra_compute(fcs_callee,ActualIn_VAL)函数用于在获得具体上下文的情况下对摘要进行实例化计算.fcs_callee表示函数f在调用点cs处所调用的函数,其中cs是函数f中的一处调用点,在该调用点处的被调用函数用fcs_callee表示.在构造函数调用图时我们会使用函数指针分析的结果,将函数指针体现在构造出来的调用图中.而对于递归调用的问题,我们会在将函数调用图归约为强连通的有向无环Page7图,在SCC-DAG上进行过程间的计算来进行处理.假设h为格的高度,n为程序中的语句数.本算法第2~4行对程序中的每一个函数f执行intra_compute(f,NULL),其中第3行的执行次数为h×nf,nf表示函数f中的语句数,而程序中所有函数的语句数的总和为n,因此第2~4行代码段总的执行次数实际为h×n;第5~11行循环次数受到程序中调用点个数的影响,最坏情况下每条语句都是调用语句,此时循环次数为n,而循环内的执行次数同样是不超过h×n,因此总次数不超过h×n2.考虑到实际应用中属性格的高度通常为一个小常数,因此该算法的实际时间复杂度为O(n2).4实例研究:指针引用错误检测很多指针引用错误,如空指针解引用、未赋值引用等都表现为指针变量的定值-引用问题:在特定的定值点发生了定值(未定值、定空值等),而在引用点表现出特定错误(“野”指针、空指针解引用),我们将这类错误称为定值-引用类错误.对于这类错误,我们可以利用本文定义的传播引擎来进行检测.4.1指针引用错误属性格犃犔PTR_ERR定义9.指针引用错误属性格ALPTR_ERR是一个代数系统ALPTR_ERR=(VPTR_ERR,Fmeet,Funion),其哈斯图如图3所示.图4指针定值-引用语法形式4.3指针引用错误格值计算通过使用指针引用错误属性格实例化,本文第3节提出的传播引擎即可完成程序中指针引用错误属性格值的计算.为了简化说明,同时也不失一般性,本节以空指针引用错误(NPD)属性格值的计算为实例对Fcompute函数的具体规则进行描述:在属性格ALPTR_ERR下,Fattr函数的定义域为程序中指针变量集合,即domain(Fattr)={v|v∈V且v为指针变量}.对于v∈domain(Fattr),Fattr(v)的初值为BOTTOM.当存在右部值为NULL的赋值说明:WRONG表示一定指针引用错误;MAYBEWRONG表示可能的指针引用错误;MAYBENULL表示指针值可能为NULL;NULL表示指针值为NULL;WILD表示指针值未被赋值,即“野”指针;NORMAL表示指针值为正常的内存地址值;BOTTOM对应源程序中的初始属性格值.在指针引用错误属性格中,VAL即VPTR_ERR={BOTTOM,NULL,WILD,NORMAL,WRONG,MAYBEWRONG,MAYBENULL,TOP}.4.2指针引用错误的犉relate函数产生指针引用错误的定值主要与赋值语句、函数调用语句有关,所以指针引用错误检测主要关心的是指针相关的定值和引用,Frelate函数对图4所示形式的语句返回真值.#RHS为存储对象#RHS为取变量地址#RHS为动态存储分配,如malloc等#指针变量#指针解引用#数组元素#直接结构体成员访问#间接结构体成员访问#函数名#函数指针解引用操作时,左部指针变量的格值会被更新为NULL,而对于右部为正常地址值的赋值操作,左部指针变量的格值会被更新为NORMAL.对于WILD的情形在空指针引用错误中实际为未做任何赋值时的格值情形.Faccess(e)是域敏感的,其定义如下:(1)Faccess(e)=v或v.field或v[i],如果e为直接变量或域或数组元素访问.(2)Faccess(e)={v}或{v.field}或{v[i]},如果e为指针变量解引用并且{v}或{v.field}或{v[i]}为Page8相应指针变量的指向集合.上述定义.可以通过域敏感的指针分析和副作用分析实现Use_In和Def_Out的定义如下:(1)Use_In为函数中所有向上暴露引用的指针型形式参数或全局指针变量.(2)Def_Out为该函数中所有向下暴露定值的指针型返回值或全局指针变量.以空指针引用错误问题为例,对于赋值语句s:e1=e2;属性格值计算需要考虑的情形,我们从以下两个方面进行刻画:(1)Faccess(e2)是否属于domain(Fattr).(2)定值和引用是一定发生的,还是可能发具体情形参见表1和表2.生的.&y∨&y.a∨&y[i]∨&(y).b∨&(py)[i]y∨y.a∨y[i]op(e1,e2,…,en)libfunc(parm1,…,parmn)(y)∨(y).a∨(py)[i]√func(parm1,…,parmn)√注:将phi看作一种特殊的op.phi是SSA中的分支汇流处理函数.Must:x∨x.a∨x[i]May:x∨(x).a∨(px)[i]可能基于上述表示,NPD的属性格值计算规则如下:规则1.e1:Must_Defe2:Must_Use∧Faccess(e2)domain(Fattr)∧上述规则处理赋值语句左部为一定定值,右部为Faccess(e2)domain(Fattr)的情形(包括右部为取地址形式、直接为NULL以及可能返回NULL的特殊库函数调用的形式),这些情况下,直接将相应的属性格值赋给左部的指针变量.规则2.e1:May_Defe2:Must_Use∧Faccess(e2)domain(Fattr)∧vAL∈{NULL,NORMAL,MAYBENULL}Fattr(Faccess(e1))Fmeet(Fattr(Faccess(e1)),vAL).规则2与规则1的不同之处在于左部为可能定值的形式,此时需将Faccess(e1)中指针变量的属性格值与右部直接获取的属性格值进行Fmeet函数运算,这主要是因为Faccess(e1)中的指针变量是e1可能指向的,若不做Fmeet函数运算,而是直接将右部的属性格值赋给这些变量的话,将可能引起漏报或误报.例如,假设指针变量x之前已有的属性格值为NULL,而此次右部的属性格值为NORMAL,若简单地认为x的属性格值变为NORMAL的话,因为x是可能指向的指针变量,也即有可能不指向,那么x的属性格值将仍是NULL,但却会因为被误认为是NORMAL而引发漏报.类似地,若指针变量x之前已有的属性格值为非NULL,而此次右部的属性格值为NULL,则也可能存在实际属性格值为非NULL,却被误认为NULL而引起误报的可能.规则3.e1:Must_Defe2:Must_Use∧Faccess(e2)∈domain(Fattr)规则3对应左部为一定定值且右部为一定引用的情形,这种情况下只需将右部的属性格值直接赋给左部的指针变量.Faccess(e2)的具体计算规则参考定义5.规则4.e1:Must_Defe2:May_Use∧Faccess(e2)∈domain(Fattr)e2:op(e21,e22,…,e2n),1in-1Fattr(Faccess(e1))Fmeet(Fattr(Faccess(e2i)),上述规则对应左部为一定定值,右部为运算表达式的情形,在这种情况下,需要对参与运算的各个子表达式分别进行Fmeet函数运算,然后再将它们的Fmeet函数运算结果赋给左部的指针变量.在该规则中包含了SSA中分支汇流和函数调用的情形,即将SSA中的分支汇流的phi运算和函数调用看成是特殊的op.Faccess(e2i)和Faccess(e2i+1)具体的计算规则参考定义5.规则5.e1:May_Defe2:Must_Use∧Faccess(e2)∈domain(Fattr)Fattr(Faccess(e1))Fmeet(Fattr(Faccess(e1)),上述规则对应左部为可能定值,右部为一定引Page9用的情形,在这种情况下,为了避免出现规则2中说明的漏报和误报的情形,需要将Faccess(e1)中指针变量的属性格值与Faccess(e2)中指针变量的属性格值进行Fmeet函数运算.Faccess(e2)具体的计算规则参考定义5.规则6.e1:May_Defe2:May_Use∧Faccess(e2)∈domain(Fattr)e2:op(e21,e22,…,e2n),1i,jnFattr(Faccess(e1))Fmeet(Fattr(Faccess(e1)),Fmeet(Fattr(Faccess(e2i)),Fattr(Faccess(e2j))))上述规则对应左部为可能定值,右部为可能引用的情形,在这种情况下,需要综合规则2和规则4其中:ψ表示当前检测环境.IsErrSource(ptr)表示对ptr是否为错误源(在传播过程中最先遇到的那些具有错误属性格值的变量)的判断,IsFirstReport(ptr)用图5NPD判定规则5实验本节以空指针引用错误检测为例,来评估基于传播引擎的错误检测方法的有效性.5.1实验环境实验环境为AMDOpteron6核CPU,主频2.11GHz,内存48GB的服务器做单进程实验.实验用例包括SPEC的CINT2000中gzip、vpr、crafty、parser以及OpenSSH和Apache等实用程序.这些程序涵盖的应用领域广泛,包括网络应用、数据压缩、集成电路辅助设计、游戏程序、文字处理等,总程序代码量超过48万行,其中最大的超过26万行.我们将实验结果与研究型代表工具Saturn(直接使用1.2版本中提供的null.clp检测文件进行分析),工业界代表工具Splint以及同样内置于编译器中的检测工具Clang-SA进行对比,分别从时间开销和检测精度(误报率和相对漏报率)两个方面进行评价.在Open64中我们已实现了多敏感的程序分析,主要包括以下特点:的处理方式,除了需对右部各子表达式的属性格值进行Fmeet函数运算外,还需与Faccess(e1)中指针变量的属性格值进行Fmeet函数运算.Faccess(e2i)和Faccess(e2j)具体的计算规则参考定义5.4.4空指针引用错误检测对空指针引用错误而言,一旦某引用点处指针变量的错误属性格值在检查时被确定为NULL或MAYBENULL(能直接推出WRONG和MAYBE-WRONG),就会报告该指针变量发生了NPD错误或可能发生NPD错误.为避免同源错误的过多提示,本文的错误提示机制增加了同源控制,即对于同源的错误仅给出第一处的提示.图5给出了NPD错误的判定规则.ptr:x∨(x).a∨(px)[i]Fattr(Faccess(ptr))==MAYBENULLIsErrSource(ptr)==TRUEIsFirstReport(ptr)==TRUEψMAYBEWRONG可能空指针解引用错误IsFirstReport(ptr)==FALSE扩展的静态单赋值(SSA)形式,能够在标准SSA上有效地表示别名和间接访存操作.扩展的SSA使用μ函数和χ函数,分别刻画间接访存或者函数调用语句中可能引用和可能修改的变量,并把这些变量作为μ函数和χ函数的操作数进行表示.域敏感、流敏感、上下文敏感的指针分析,按照指向层次逐层进行指向集的计算[14].将多敏感的指针分析与构造SSA形式相结合,在指针分析过程中为每个变量构建扩展的SSA形式.通过层次式分析可以有效构造精确、简洁的SSA形式,消除虚假的引用定值点,从而提高引用定值分析的精度和效率.5.2检测时间开销分析表3给出了OpenSSH、Apache以及SPECCINT2000中部分C程序进行NPD错误检测所需的时间,单位为s.表中每行对应不同检测工具对于同一测试用例所用的检测时间.从检测时间数据上看,Saturn平均耗时958s,Splint平均耗时14s,Clang-SA平均耗时875s,Propagator平均耗时12s.对于全部的测试用例,传播引擎Propagator的检测时间都是最快的.SaturnPage10表3检测时间OpenSSH-4.3p2Apache-2.2.4164.gzip175.vpr186.crafty197.parser几何平均“-”表示无法成功分析结束.注:检测时间是使用该工具检查某种类型错误所需的时间,其中Clang-SA未提供单独的空指针引用错误选项,因此为所有检查的时间.gator,但由于Splint缺乏过程间分析,所以检测精和Clang-SA则耗时较长,分别是Propagator所用度表现不佳,如5.3节实验数据所示.而传播引擎不时间的79倍和72倍.这主要是因为Saturn进行了仅实现了精确的过程间分析,还实现了高效的检测,可满足性求解,Clang-SA进行了符号执行的缘故.它们的方法在理论上是精确的,但由于需要逐条对我们的多项式时间的上下文敏感的检测算法使我们路径进行处理,路径数又是条件分支数的指数级,在在保证检测精度的同时在时间上有明显的优势.实际程序中路径数目往往很大,如SPECCINT20005.3检测精度分析中的gzip虽然程序规模只有8千多行,但路径数达表4给出了不同工具对不同测试用例检测所报告的错误数、实错数、误报数和相对漏报的数据.其到3.49E+11条[16].因此这两个工具在处理实用程序时往往产生很大的时空开销,Saturn甚至因为过中报告数来自于实验收集的数据,实错数、误报数和相对漏报数通过人工分析获得,相对漏报数指的是长的分析时间和过大的存储空间开销,导致不能成功完成分析检测.Splint的分析时间略大于Propa-不同工具间的相对漏报个数.表4报错情况Splint的情况报告实错误报相对漏报程序规模OpenSSH4.3p2155.0514000011211101100Apache-2.2.4268.9----7347121020111010164.gzip8.60000303000000000175.vpr17.72110202120211100186.crafty21.244053217000910910197.parser11.4----523242226420注:表中“-”表示出现错误未成功分析结束;实错包含潜在的实错(诸如特定输入才会触发的可能发生的错误);“”表示同源错误仅作单次统计.通过对表4中实验数据分析后发现,对于空指针引用错误以下4种情况值得注意:(1)特殊控制流问题.在实际程序中经常会存在这样一类处理:对指针变量是否为NULL进行判定,若为NULL则给出错误提示并退出程序执行,因此该指针变量的空指针引用点将不可能到达,如图6中的164.gzip片段所示的情形,本文称这样的问题为特殊控制流问题.这种情况在175.vpr片段,OpenSSH和Apache中也存在.Saturn和Clang-SA均未能处理特殊控制流,这是因为Saturn和Clang-SA对各种控制流进行统一处理,无法区别对待特殊控制流.(2)可能返回NULL的特殊库函数调用问题.一些内存分配函数、字符串处理库函数存在返回值可能为NULL的可能,如图6(b)所示的情形,如果检测工具不能识别这种可能为NULL的返回值,就会引发漏报.Saturn和Clang-SA在186.crafty片段中就因为此原因而存在漏报.(3)汇流点问题.在实际程序中会经常出现如下场景:将局部指针变量在声明时初始化为NULL,之后在分支或循环中进行可能非NULL的定值,之后在分支或循环外进行引用,本文将这样的情形称为汇流点问题.对于汇流点问题,很多情况下即使进行路径可行性判断,往往也会因为路径表达式过大Page11而无法准确判别是否在分支或循环中一定会被定值,如图6(c)所示的186.crafty的程序片段中给指针变量goodmove定非NULL值的循环是否一定执行是不确定的,因此在汇流点处指针变量引用时认为相应指针变量“可能”为NULL,并进而给出“可能”为NULL的提示是一种折中的处理方式.本文的传播引擎即采用了这样的处理方式,虽然可能存在一些的误报,但从开销与收益的综合考虑来说是164.gzip片段:1.p=get_suffix(name);2.if(p==NULL)3.error(“can’trecoversuffix\n”);4.狆=‘\0’;175.vpr片段:1.staticstructs_bbbb_coord_new=NULL;2.if(bb_coord_new==NULL)3.{bb_coord_new=(structs_bb)my_malloc(2pins_per_clbsizeof(structs_bb));}4.if(net_block_moved[k]==FROM)5.update_bb(inet,&犫犫_犮狅狅狉犱_狀犲狑[bb_index],&bb_edge_new[bb_index],x_from,y_from,x_to,y_to);图6实际程序片段(其中粗体下划线表示需特殊处理的部分;粗斜体表示可能存在误报或漏报的指针变量;(d)通过对表5数据的观察不难看出,对于所有的实验用例,Propagator的平均误报率仅为13%,分别为Saturn、Splint和Clang-SA的28%、20%和22%,并且平均相对漏报率为0,检测精度表现理想.而正是因为针对上述4种情况的需求,Propagator进行了精确而有效处理,而其它工具受到统一建模和分析方法的限制未能有效进行处理,从而Propagator较之对比工具表现出了更多的检测精度优势.SaturnSplintClang-SAPropagator相对漏报率=(相对真实错误总数-报告中真实错误数)/注:误报率=(报告错误数-报告中真实错误数)/报告错误总数,6结论与展望本文提出一种基于传播引擎的指针引用错误检测方法,该方法充分利用编译器已有的程序分析技可以接受的.(4)不健全的过程间分析引发的问题:例如图6(d)所示的175.vpr程序片段中,bb_coord_new为NULL时的定值由函数my_malloc的返回值确定,而通过对my_malloc函数分析后发现其返回值不可能为NULL,因此,在程序片段第5行处的关于bb_coord_new的空指针引用错误提示是一处误报.Splint就存在这样的误报.术,实现了流敏感、域敏感和上下文敏感的程序分析,借助流敏感、域敏感和上下文敏感的传播引擎检测框架,获得了很好的检测精度和可扩展性.经过应用领域广泛的超过48万行的典型应用检测,实验结果表明:基于传播引擎的错误检测技术,检测时间平均12s,误报率仅为13%,而且没有相对漏报,达到了既提高检测精度又保证可扩展性的效果,有望发展为实用的检测工具.需要说明的是目前传播引擎主要应用于定值-引用类错误的检测,这些错误表现为在定值点赋予了危险值,而在引用点进行引用时发生错误的情形.例如,未赋值引用、空指针引用、缓冲区溢出等错误的检测.下一步我们会将该方法应用到更多类型的错误检测工作中去,并且尝试在不引入过多时空开销的情况下增加对路径条件的考虑,进一步提高检测精度.
