Page1基于路网的移动对象动态双层索引结构乔少杰1)韩楠2)王超1)祝峰3)唐常杰4)1)(西南交通大学信息科学与技术学院成都610031)2)(西南交通大学生命科学与工程学院成都610031)3)(闽南师范大学福建省粒计算及其应用重点实验室福建漳州363000)4)(四川大学计算机学院成都610065)摘要为了支持对大规模不确定性移动对象当前及将来位置的查询,亟需设计更加有效和高效的索引结构.当前索引算法主要考虑索引建立和维护的效率问题或关注基于索引进行查询时的准确性,对索引建立维护以及查询时性能综合考虑的研究较少.针对已有方法的不足,提出基于路网的移动对象动态双层索引结构DISC-tree,对静态路网信息采用R-tree索引,对实时更新的移动对象运动轨迹采用结点更新代价较小的R-tree进行索引,设计哈希表和双向链表辅助结构对索引协同管理.成都市真实地图数据集上的实验结果表明:相比于经典的NDTR-tree,DISC-tree在索引建立和维护方面时间代价平均减少39.1%,移动对象轨迹查询时间代价平均减少24.1%;相比于FNR-tree,DISC-tree的范围查询准确率平均提高约31.6%.关键词移动对象数据库;路网;索引;范围查询1引言随着无线通信、传感器网络和定位技术的高速发展,人们对持续移动物体所处空间位置的跟踪能力不断加强,推动相关应用领域的研究,如智能交通控制、智能导航和旅游路线推荐等不断深入.此类应用系统往往基于移动对象数据库(MovingObjectsDatabases,MODs).作为移动计算技术的重要分支以及位置服务类应用的底层支撑技术,移动对象数据库技术得到了广泛的关注和研究[1].相比于时空数据库,移动对象数据库不仅支持查询当前时间有效的空间对象,而且可以对随时间而发生位置变化的移动对象的历史轨迹进行管理.对移动对象的位置信息提供高效的索引和查询,在地理信息系统、精确定位技术方面具有很高的科学意义.现实生活中人们真实的运动场景往往被限制在某一固定区域内,即道路交通网络(简称路网),因此研究路网中移动对象索引结构具有现实意义.路网是一个动态复杂的系统,系统中存在规模巨大、种类繁多的移动对象,而且构成网络的街道错综复杂,并不都是汇集成十字型路口,某些道路往往是三分支或者五分支的.利用R-tree或者R-tree对移动对象进行索引,往往忽略了静态路网自身的结构特点,得不到令人满意的查询结果.基于路网的移动对象时空索引和范围查询技术目前是一个充满挑战性的课题.衡量索引性能的主要指标包括:索引建立和维护的效率、轨迹查询时间、时空范围查询的效率和准确性.面临的主要困难是:简单索引结构能够提高索引维护的效率,减少时空范围查询访问结点的I/O代价,但是会降低查询的准确性;复杂索引有助于提高查询准确率,但增加了维护的时间开销.针对当前路网索引结构的不足,本文提出一种新型索引结构DISC-tree(atwo-tieredDynamicIndexStructureofmovingobjectsbasedonConstrainednetworks).相比于具有代表意义的FNR-tree[2],克服了FNR-tree在时空范围查询精度上的不足;相比于NDTR-tree[1],索引更新时间开销和I/O代价更小,克服NDTR-tree对移动对象轨迹查询时间性能上的不足.2相关工作索引技术是移动对象数据库领域的关键研究内容,移动对象的位置查询、基于位置的服务、移动对象位置预测都依赖于移动对象索引[3].移动对象的静态索引已经有比较成熟的技术[4],如R-tree、R+-tree、R-tree、KD-tree等.移动对象索引按照空间范围分为两类:不受空间约束和受限路网中位置索引.不受空间约束是指移动对象的运动不依赖于具体的道路,其可以在空间任意范围内运动.这类索引技术在国内外已经取得一系列研究成果[5].根据移动对象当前位置建立索引的技术瓶颈是提高索引更新的效率,为了解决这一问题,吴岑等人[6]提出了一种基于GRID文件的移动对象索引方法,其优势在于:在结点合并和分裂过程中,分裂位置选择具有随机性,因此索引更新的代价较小.但相比基于R-tree的索引,其查询时间提高不大.为了进一步减少移动对象索引更新的代价,Silva等人[7]提出了一种基于内存的R-tree索引结构RUM-tree,在进行结点更新操作时仅需要一次结点插入操作.Saltenis等人[8]提出TPR-tree对移动对象未来位置进行索引,结点分裂时不仅考虑对象的位置而且考虑包含速度和方向的运动矢量.Tao等人[9]对TPR-tree中结点插入和更新操作进行改进,提出了TPR-tree,借助改进的压缩技术对结点进行删除.Chen等人[10]提出一种动态的称为自调整单元(AdaptiveUnit)的结构来扩展R-tree,根据移动对象的运动特征(位置、速度和方向)对其进行分组,达到预测整组对象运动轨迹的目的.相比于不受空间约束移动对象的索引技术,基于受限路网的索引技术尚处于起步阶段,国内外成果较少,具有代表意义的工作如下:针对Pfoser等人[11]提出的受限公路网络中移Page3动对象索引方法的不足,Frentzos等人[2]提出双层索引结构FNR-tree,由一个2DR-tree和一个1DR-tree森林构成,2DR-tree用于管理整个路网中的边.FNR-tree存在以下两方面不足[5]:(1)上下两层索引的粒度相同,均针对于路网中的边,上层叶子结点记录与下层R-tree的对应关系为11,导致下层R-tree的规模庞大;(2)由于仅存储对象进入和离开边的数据,会遗漏掉在边上运动并停止的移动对象位置信息,导致窗口范围查询结果的准确性较低.MON-tree[12]是对FNR-tree进行改进而提出的索引结构,对道路网络建立索引不再基于直线边,而是基于折线道路,减小了对象跨越不同边的更新代价.不足在于:对路网建立索引是基于道路信息,会造成结点MBR(MinimumBoundaryRectangle)的重合.查询效率随结点MBR重合程度增加而降低.NDTR-tree[1]的上层结构对路网中原子路段建立索引,下层R-tree用于索引在原子路段上运动的移动对象轨迹片段.这一结构的不足在于[5]:(1)索引维护代价较高,每当发生位置更新请求时,需要进行两次结点插入和一次删除操作.此外,每次删除操作均需遍历整个R-tree森林.(2)不支持对移动对象轨迹的高效查询,当查询指定的运动轨迹时,需遍历整个下层R-tree森林.(3)实际路网中道路的相交部分较多,采用R-tree组织索引,结点插入时会产生大量索引空间的重叠,不利于查询.近期移动对象索引研究仍然得到学术界的广泛关注.针对移动对象速度分布的偏离特性,Nguyen等人[13]提出了新型速度划分技术,借助PCA和k-means聚类技术识别DVA(DominantVelocityAxe),然后基于DVA建立索引,提高了移动对象查询的效率.为了查询移动对象过去、当前及未来位置,Zhu等人[14]利用哈希表自下而上对移动对象进行位置更新,对于路网中道路采用邻接矩阵存储每条道路相邻道路信息.但是这一结构没有考虑移动对象频繁更新的索引维护的代价.Appathurai等人[15]利用线性函数刻画移动对象的位置信息,设计了新型结点更新和合并算法,可以在某一时刻处理更多对象的位置更新信息,达到提高结点更新效率的目的.但是,对象速度并不总是遵循线性分布,不能应用于真实的路网环境中.3受限路网中移动对象运动模型本节将介绍DISC-tree中采用的数学模型和主要概念,并给出形式化定义,如下所示.定义1.路网.G=(E,N),E是路网中所有封闭路段的集合,N是路段交点的集合.定义2.道路交点.n=(nid,x,y),nid是道路交点的标识,x和y为交点在二维空间平面上的坐标.定义3.封闭路段.e=(eid,rid,ns,ne,len,w,poss),e表示路网中的一条封闭路段,“封闭”的含义指从路段起点到终点的范围内不含有任何道路的交点,eid是该封闭路段的标识,rid为该封闭路段所在道路的标识,ns和ne表示封闭路段的起点和终点,len为此路段的长度,w=e.len/r.len(r为该封闭路段所属的道路),表示该封闭路段在其所属道路中的比重,poss∈[0,1]为起点在街道中的位置.定义4.道路.r=(rid,S,l),r表示路网中的一条道路,道路通常包含一条或者多条封闭路段,rid为道路的标识,S为该道路所包含封闭路段的集合,l表示道路的长度.本文通过封闭路段、道路、道路交点来描述复杂交通网络和交通网络中的道路联接关系.定义5.移动对象位置更新信息.m=(mid,type,t,v,x,y),mid表示移动对象标识,type为移动对象类型,t为采集运行矢量的时间点,v表示移动对象的速度,x和y为对象所处二维位置信息.定义6.移动对象运行矢量.mv=(mid,type,t,v,rid,pos),mid为移动对象的标识,type表示移动对象类型,t为采集该运行矢量的时间,v表示该移动对象在t时刻的速度,rid为该移动对象所处道路的标识,pos∈[0,1]为对象所处道路的相对位置.已知查询窗口与封闭路段的交点c到封闭路段起点的距离为k,封闭路段长度为e,那么运行矢量中pos取值为移动对象当前位置距离道路起点的长度除以整条道路的长度,计算方法如式(1)所示:其中,poss表示对象初始位置,w为封闭路段在其所属道路中的比重,计算方法见定义3.定义7.移动对象轨迹单元.两个运行矢量之间的线段称为轨迹单元U.连续轨迹单元表示为U(mvs,mve),mvs和mve表示运动矢量的起点和终点.活动运行矢量所形成的轨迹单元是对应点作为端点发出的一条射线,记为活动轨迹单元U(mvn).移动对象的轨迹利用rid×pos×t三维坐标系统描述,如图1(a)所示.随时间的变化移动对象在Page4道路中的位置不断变化,对于rid坐标的每一个切面形成一个pos×t(位置和时间)的坐标平面,表示移动对象在具体道路上的时空轨迹.移动对象可以跨越不同的道路,其轨迹可以表示为一条rid×pos×t图1路网下移动对象三维时空轨迹及二维投影[5]定义8.链表轨迹单元.用LU=(U,uid)表示,U表示为U(mvs,mve)或者U(mvn),uid表示轨迹单元在下层R-tree中的位置标识.链表轨迹单元保存在移动对象所对应的双向链表中,目的是加速下层R-tree索引的建立和维护.4DISC-tree的数据结构4.1DISC-tree双层索引结构DISC-tree分为上下两层,上层是基于xy平面的R-tree索引,用于索引路网中的封闭路段,其叶子结点的数据结构为〈M,id,e〉.M表示包含该封闭路段的最小边界矩形MBR,id为该叶子结点在索引中的标识,e为表示封闭路段.中间结点用〈M,id,p〉表示,M为包含下层结点的最小边界矩形,id为结点在索引中的标识,p为指向下层结点的指针.其中,一个MBR包含一条封闭路段.采用R-tree的主要原因在于,相比于R-tree,在索引建立时,R树不仅考虑了索引空间的“面积”,而且考虑了空间的重叠部分.此外,本文采用“强制重新插入”的方法使树的结构得到优化.图2为交通网络在DISC-tree上层索引中的对应关系,道路r4包含3个封闭路段(r4.a1,r4.a2,r4.a3),于是形成3条记录存储于包含各封闭路段MBR信息的叶子结点中.图2上半部分矩形框示例给出MBR3和MBR4的范围.DISC-tree下层结构是一组与每条道路对应的R-tree索引,基于pos×t平面,用于索引移动对象轨迹单元,根据位置更新信息动态地进行维护.下层三维空间中不断变化的曲线.参考定义7,图1(b)表示移动对象在具体道路上的轨迹,其由若干个轨迹单元构成,虚线部分为活动轨迹单元.叶子结点的数据结构为〈M,id,mvs,mve,o〉,M表示包含该轨迹的最小边界矩形,id为叶子结点的标识,mvs和mve分别表示轨迹单元起始和结束运行矢量,如果为活动轨迹单元,则mve为空.o表示移动对象信息,由对象标识mid和对象类型type组成.中间结点数据结构为〈Mpos×t,id,p〉,Mpos×t是包含下层结点的最小边界矩形,id为中间结点标识,p为指向下层结点的指针.DISC-tree下层结构如图3所示,下层R-tree森林管理移动对象基于pos×t平面的轨迹片段.例如移动对象m1仅在道路r上运动,于是其所有轨迹单元被道路r对应的R-tree管理(参见图3(b)).图3(a)中虚线部分表示活动轨迹单元,如果对象从一条道路运动到另一条道路,那么它的轨迹单元将被两条道路的R-tree管理.DISC-tree上下两层R-tree的对应关系为1n,1代表上层索引仅由一个R-tree构成,n为路网中道路r的数目,下层索引含有n个R-tree.利用上层索引叶子结点中的信息可以搜索到下层索引中的某Page5个R-tree.例如,已知交大路包含两个封闭路段,则上层R-tree叶子结点中有两条记录指向下层索引中属于交大路的R-tree.查询某个时间段Δt内交大路上所有移动对象的轨迹时,首先从上层R-tree自顶向下查询,找到叶子结点中交大路的所有封闭路段,然后定位到下层索引中交大路的R-tree,根据查询条件搜索Δt时间内的下层索引.4.2DISC-tree的辅助结构为了提高索引维护效率,本文采用如下2个哈希表和1个双向链表作为DISC-tree的辅助结构[5].图4(a)中的哈希表RoadHashTable对DISC-tree下层基于道路的R-tree森林进行管理,其中key的值为道路标识rid,value为道路对应的R-tree索引.图4(b)中的哈希表TrajectoryHash-Table用于管理移动对象的轨迹单元,key取值为移动对象标识mid,value为一个双向链表,用linkedlist表示,包含具体移动对象的所有轨迹单元LU,其按时间先后顺序加入到链表中,根据移动对象提供的位置信息不断进行更新.当收到一条位置更新信息时,首先形成轨迹单元U,将其插入到R-tree中,并返回在R-tree中的位置标识uid,形成链表轨迹单元LU(U,uid)插入到linkedlist中,在维护索引的同时对linkedlist和TrajectoryHashTable进行维护.应用本文所提出的辅助结构具有如下优势:(1)因为移动对象轨迹具有不确定性,遍布在整个路网中,导致其轨迹可能被相当多条道路的R-tree索引,如果采用不恰当的数据结构,对移动对象的轨迹查询将是极其低效的.例如,移动对象的运动轨迹跨越了多条道路,为了查询其历史运动轨迹,需要自上向下遍历整个R-tree森林.而采用哈希表和双向链表构成的辅助结构后,仅需将其加载到缓存中进行维护,查找移动对象轨迹不需要遍历R-tree森林,极大地提高了查询的效率.(2)在无哈希冲突的情况下,由LU构成的哈希双向链表插入、查找、删除n个结点的时间复杂度均为O(n),构建哈希双向链表的时间复杂度为O(n),n表示轨迹单元的数量.辅助结构的建立和维护时间代价较低.4.3DISC-tree与NDTR-tree对比分析NDTR-tree的轨迹查询效率不高,查找移动对象的历史轨迹需遍历一个甚至多个R-tree的所有结点,找到移动对象的轨迹单元.DISC-tree采用哈希表加双向链表的数据结构,提高轨迹查找和删除的效率.双向链表中包含移动对象的轨迹单元,当需要访问对象在某些时刻的轨迹信息时,仅需访问哈希表,取出移动对象对应的链表进行查询.此外,双向链表的好处在于可以快速访问某一时刻的前一时刻和后一时刻的轨迹单元,为查询提供便利.DISC-tree结合R-tree和R-tree索引,对静态路网建立R-tree索引,对动态轨迹单元建立R-tree索引.对静态路网,采用更新操作中结点分裂次数较少的R-tree,查询对象将更加高效和准确.R-tree索引建立和维护的计算代价较小,适用于管理频繁更新的移动对象轨迹单元.而NDTR-tree中对变化较小的路网和更新频率较高的移动对象轨迹单元均采用R-tree索引.在NDTR-tree中为了寻找移动对象的前一个运动轨迹单元,需要遍历多条道路所对应的多个R-tree索引.DISC-tree对此做出改进[5]:将每个对象上一次更新后的最后一个轨迹单元在R-tree中的索引标识uid存储到与其对应的链表结点LU中,需要对其操作时可以直接定位到R-tree的某个叶子结点,进而找到轨迹单元,极大地提高了索引维护的效率,第6.3.2节的实验证明了这一点.Page65DISC-tree中应用的算法5.1索引建立和维护算法算法1.DISC-tree的建立和维护算法.输入:移动对象位置更新信息m.输出:更新后的DISC-tree.1.FOR(每条更新信息m=(mid,type,t,v,x,y))2.遍历上层以封闭路段为索引单位的R-tree,3.mv←(mid,type,t,v,rid,pos);4.R←searchRoadTable(rid);5.linkedlist←searchTrajectoryTable(mid);6.t←moveToTail(linkedlist);7.IF(t==null)THEN8.LU←insert(R,U(mv));9.insertLinkedList(LU);10.ELSE11.U(mvn)←t.uid;12.delete(U(mvn));13.LU1←insert(R,U(mvs,mve));14.LU2←insert(R,U(mvn));15.delete(linkedlist);16.insertTail(LU1);17.insertTail(LU2);18.ENDIF19.ENDFORDISC-tree首先利用真实路网数据建立上层静态R-tree索引,“静态”是指路网信息的更新几率远小于移动对象轨迹单元的更新概率,大多数情况下仅需一次构建,不需要频繁更新.然后,根据移动对象提交的位置更新信息建立并维护下层动态索引.“动态”是指整个索引结构不断更新.本文重点关注下层动态索引的建立和维护,DISC-tree建立和维护过程如算法1所示,主要步骤为:(1)根据移动对象位置更新信息m查找基于xy平面的上层索引,进而找到移动对象所处的封闭路段e,取出其相关信息(第1~2行);(2)求取对象在e所属道路r上的位置pos,形成运行矢量mv=(mid,type,t,v,rid,pos)(第3行);(3)通过rid访问辅助结构RoadHashTable,取得道路所对应的R-tree(第4行);(4)根据mid访问哈希表TrajectoryHash-Table,获得轨迹单元链表,访问链表尾结点t(第5~6行);(5)若t为空,表示初次收到该对象位置信息,则插入活动轨迹单元U(mvn)到R-tree中,并记录它在R-tree中的位置uid,通过(U,uid)生成链表轨迹单元LU,并插入到的链尾(第7~9行);(6)若t不为空,根据t中的uid信息找到并删除R-tree中的活动轨迹单元U(mvn).插入连续轨迹单元U(mvs,mve),插入活动轨迹单元U(mvn),LU1,LU2为生成的链表轨迹单元(第10~14行),最后在链表中删除t(第15行);(7)将LU1和LU2相继添加到链表尾部,进而建立索引的同时并维护链表信息(第16~17行).5.2移动对象时空范围查询时空范围查询是衡量移动对象索引结构好坏的指标.本文采用如下所示的时空范围查询算法[5].算法2.移动对象时空范围查询算法.输入:查询区域(Δx,Δy,Δt),索引哈希表RoadHash-输出:满足查询条件的移动对象标识集合S.1.根据(Δx,Δy)查询上层R-tree求得查询窗口与2.(rid,pos)←calculatePos(e,x,y);//通过e中的属3.对每一个交点重复步骤2的计算,得到一系列偶对4.FOREACH(qinQ)5.R←searchRoadTable(rid);6.根据periodi×Δt查询R中叶子结点记录U;7.IF(U∩(periodi×Δt)≠null)8.I←U对应的mid;9.ENDIF10.ENDFOR以成都路网中指定范围查询为例,具体过程:(1)根据查询窗口[(x1,y1),(x2,y2)],搜索上层R-tree,遍历到叶子结点,借助叶子结点中封闭路段信息e,求得查询窗口与封闭路段的交点.对于一个封闭路段,查询窗口与之相交的个数可能不唯一.例如,查询窗口与万和路的交点有2个,形成两条查询信息.从索引文件中读出存储该封闭路段信息的字符数组,反序列化为封闭路段e的信息,交点信息用(e,x,y)表示(第1行).(2)计算出交点在街道中的位置pos(第2行),需要用到定义3中的属性:w,len,poss.(3)查询区域与一个道路可能有多个交点,对应于一个偶对(rid,period)(第3行),其中period包含一个或者多个pos信息.查询区域与多条道路相交,则对应于一组偶对,在rid对应的下层R-tree中查询与(period,Δt)相交的轨迹单元,最终输出轨Page7迹单元对应移动对象的标识(第4~10行).6实验及性能分析6.1实验环境及数据集描述实验采用的数据集来源于成都市真实矢量地图,包含成都二环内的232条主干道,将地图数据进行转换,得到如表1所示的数据格式.标识速度x坐标y坐标移动对象对象7204682645123362在实验中,通过加载Edge(路网边集合)和Node(路网结点集合)两个文件后生成成都市二环内的真实路网.Edge文件包含每个封闭路段边的信息,表示为(i,ns,ne,eid,rid),i为自增字段,ns和ne为封闭路段的起点和终点标识,eid为封闭路段标识,rid为道路标识.Node文件表示为(nid,x,y),nid表示道路交点标识,x和y为二维平面下的横纵坐标.本文通过对文献[16]提出的移动对象轨迹生成器改进后设计实现了一个新的轨迹生成系统,改进之处在于:生成轨迹数据时考虑道路位置信息,不再基于边生成轨迹片段,而是基于道路生成轨迹,使生成轨迹的数据结构与本文所提算法相符.本文中所有算法利用Java程序设计语言实现.实验硬件平台为AMDAthlon5000+,2.6GHzCPU,2GB内存,操作系统平台为WindowsXP.表2给出轨迹生成器的参数设置.实验中主要对比DISC-tree、FNR-tree和NDTR-tree的性能差异,其中FNR-tree是基于路网的移动对象索引方法中性能较好的一种,能支持高效的kNN查询和时空范围查询;NDTR-tree是移动对象时空范围查询性能较好的索引,因此选择这两种索引进行对比实验.NDTR-tree与DISC-tree的索引基于道路构建,FNR-tree的轨迹索引基于封闭路段.为了保证算法可比性,FNR-tree进行轨迹查询时将不会用到表1中移动对象所属道路标识.6.2PathFinder轨迹查询系统简介为了便于比较上述3种索引结构,本文开发了基于路网的移动对象轨迹查询系统PathFinder[5],包含3个主要功能模块:(1)轨迹生成模块,根据静态路网生成均匀分布在整个路网中移动对象的动态运动轨迹;(2)索引构建,构建基于路网的索引结构;(3)对象查询,提供时空范围等查询功能.图5界面左侧为利用轨迹生成器生成的成都二环内路网数据,圆点表示移动对象,利用不同颜色来区分移动对象的类型,例如:红色代表速度较快的移动对象,如小型车.以移动对象时空范围查询模块为例,首先,用户需要确定查询的窗口范围;然后,选择查询的时间片段;最后,点击“开始查询”进行时空范围查询.查询返回结果信息包括:移动对象标识、速度、移动对象所处的街道等,结果在系统界面中输出.本文应用该系统比较DISC-tree、NDTR-tree、FNR-tree进行索引构建和时空范围查询的性能.6.3索引建立和维护代价比较6.3.1索引建立及维护代价理论分析式(2)~式(4)给出了FNR-tree、DISC-tree、NDTR-tree在索引建立和维护过程中结点的访问次数.其中,Ti,Ti和Ti表示3种索引中第i个移动对象的轨迹数目;Ninsert,Ninsert和Ninsert分别表示3种索引进行一次插入操作结点访问的次数;Ndelete,Ndelete,Ndelete表示3种索引进行一次删除操作结点访问的次数;n表示移动对象的数量,mj表示树中第j层包含结点的数目,h为树的高度.NodeAccess(FNR-tree)=∑nNodeAccess(DISC-tree)=∑n2×Ninsert+N(Page8NodeAccess(NDTR-tree)=∑n∑h随着移动对象数量的增加,DISC-tree与NDTR-tree索引建立和维护时结点访问的次数远高于FNR-tree,原因在于:(1)只有移动对象离开封闭路段时FNR-tree才触发一次轨迹更新事件,当移动对象运动在封闭路段上时,其活动轨迹单元没有保存在FNR-tree中.相反,对于DISC-tree和NDTR-tree,不管移动对象是否发生路段转移事件,均需记录对象的全部轨迹信息.对象在FNR-tree的轨迹数目要少于其在DISC-tree和NDTR-tree下的轨迹数目,即式(2)中的Ti值小于式(3)和式(4)中的Ti和Ti值.(2)在DISC-tree与NDTR-tree中,下层索引中的每个树均基于包含多个封闭路段的道路r构建,而FNR-tree的下层索引基于封闭路段e构建,其空间单位较小.由于r与e的关系是1n(n值由r中包含e的个数确定),DISC-tree与NDTR-tree的下层索引中每个树的规模远大于FNR-tree,因此在FNR-tree中进行一次插入操作需要访问的结点数目要小于同样的操作在DISC-tree和NDTR-tree中所访问的结点次数,式(2)中的Ninsert小于式(3)和式(4)中的Ninsert和Ninsert.(3)DISC-tree和NDTR-tree每次更新索引时都需要删除之前的活动轨迹单元,并插入新的活动轨迹单元,FNR-tree无需进行上述操作.6.3.2索引建立及维护代价实验本节统计不同移动对象数量下,FNR-tree,NDTR-tree,DISC-tree索引建立和维护的I/O及时间开销.3种索引基于6.1节介绍的成都二环路路网生成相同的轨迹数据集,避免由于轨迹随机性造成实验环境的不同,结果如图6和图7所示.如图6所示,随着移动对象数目增多,DISC-tree索引建立及维护的性能明显优于NDTR-tree,原因在于:NDTR-tree每次接收到位置更新请求对下层R-tree进行更新时,需要遍历下层R-tree找到移动对象的活动轨迹单元并进行删除,式(4)中∑hj=1mj表示每次遍历过程中NDTR-tree访问结点的数目.移动对象数目越多,下层R-tree规模越庞大,将产生巨大的I/O开销.而DISC-tree采用了哈希表和双向链表辅助结构,寻找移动对象活动轨迹单元仅需访问链表尾结点,查找其在下层R-tree中的位置,删除活动轨迹单元.此操作不需要遍历R-tree,极大地减少了I/O开销.FNR-tree的I/O要远低于其他两种索引结构,图6中几乎显示不出来.当对象数量达到5000时,NDTR-tree的I/O是FNR-tree的262.7倍,是DISC-tree的5.3倍.如图7所示,当移动对象数量规模较小,为500左右时,DISC-tree索引建立时间略低于NDTR-tree.因为DISC-tree采用R-tree索引静态路网,相比于NDTR-tree采用R-tree索引结构,虽然前者的一次建立开销略大于后者,但是采用辅助结构节省删除轨迹单元的时间开销.当移动对象数量增加到1500后,DISC-tree的辅助结构作用明显,极大地节省了删除活动轨迹单元的时间代价.相比于NDTR-tree,DISC-tree在索引建立和维护方面时间代价平均减少39.1%.FNR-tree仍然具有时间性能上的优势,移动对象数量从500增加到5000的过程中,DISC-tree的平均时间约为FNR-tree的5.14倍,NDTR-tree的平均时间约为FNR-tree的9.78倍.FNR-tree索引建立和维护的时间性能优势不如I/O性能优势大的原因在于:FNR-tree需要维护的动态索引树基于封闭路段构建,而NDTR-tree和Page9DISC-tree的动态索引树基于道路构建,一条道路包含多个封闭路段的实际情况导致FNR-tree下层索引中虽然每个树所占空间较小,但是整个森林规模更为庞大,增加了时间开销.6.4移动对象轨迹查询性能比较轨迹查询是指查询在给定道路上所有出现的移动对象的运动轨迹单元.相比于NDTR-tree和DISC-tree,如果移动对象一直没有离开某条封闭路段,FNR-tree不记录其轨迹信息,其所包含的轨迹数量少而且不准确,因此实验中比较NDTR-tree与DISC-tree的轨迹查询性能.为了获取移动对象的运动轨迹,NDTR-tree需要访问下层所有R-tree(n条道路对应n个R-tree),将包含移动对象轨迹单元的所有记录取出,进而得到完整轨迹.而DISC-tree首先根据移动对象标识访问哈希表,取出移动轨迹单元链表,然后访问双向链表,逐一取出链表单元,按时间顺序将轨迹片段连接起来形成完整轨迹.如图8所示,由于DISC-tree无需访问下层R-tree森林,其轨迹查询时间一直维持在一定范围内,当对象数量大于2500(横坐标为5)时,近似呈线性增长;而NDTR-tree的查询时间随对象的增加及R-tree结构增大,变得越来越长.相比NDTR-tree,图9时空范围查询准确性比较DISC-tree的平均查询效率提高约24.1%.6.5时空范围查询性能分析为了比较FNR-tree、NDTR-tree、DISC-tree时空范围查询的准确性和时间效率,实验分别以查询窗口大小占地图的10%、20%、30%、40%范围进行查询,比较查询准确率和时间两个性能指标.6.5.1时空范围查询准确性分析3种索引结构在不同查询窗口下查询结果的准确率如图9所示.虽然NDTR-tree和DISC-tree采用不同的索引结构,但是均基于道路构建双层索引,因此这两种索引得到的查询结果一致,即两种索引的查询准确率曲线重合.FNR-tree基于封闭路段构Page10建索引,查询返回的结果要少于上述两种索引,导致预测不够准确.当查询窗口为地图的10%时,FNR-tree的查询准确率平均为73.2%,而NDTR-tree和FNR-tree的查询准确率较高,维持在95%以上.当查询窗口增大到20%时,NDTR-tree和DISC-tree保持平均98%以上的准确率,FNR-tree的准确率为83%.当查询窗口增大到40%时,3种索引查询准确率相差不大.在小范围窗口下,FNR-tree查询准确率不高的原因在于[5]:其仅保存移动对象进入和离开一个封闭路段时的轨迹信息.假设移动对象o运动到道路r的子路段r.d1则到达目的地,并没有离开该路段,于是o在r.d1上的运动轨迹不会保存在FNR-tree中,当查询窗口较小时包含的路段较少,出现漏查的情况.随着查询窗口的增大,其包含的封闭路段数目将会增多,仍以道路r为例子,查询窗口增大后,可能包含r的多个封闭路段,在r.d1中查不到移动对象o,但在其他路段上可能会查找到o.实验发现:当查询窗口小于10%时,DISC-tree相比于FNR-tree在查询准确率上平均提高约31.6%.6.5.2时空范围查询时间代价分析图10显示了在不同的查询窗口下FNR-tree、图10时空范围查询时间比较NDTR-tree、DISC-tree三种索引时空范围查询的时间开销.可以发现:当移动对象从500增加到5000时,DISC-tree时空范围查询时间性能优于NDTR-tree.原因在于时空范围查询过程中,首先通过指定窗口范围对路网进行查询,由于DISC-tree采用R-tree索引管理路段,查询效率要高于NDTR-tree.然后,通过(period,Δt)遍历指定道路的R-tree索引,这一步中两者查询效率相当.而FNR-tree的下层索引是基于封闭路段构建的R-tree森林,相比于NDTR-tree和DISC-tree基于道路的R-tree森林,其下层索引中包含更多的R-tree,规模较大不利于查询,查询时间与DISC-tree相当.但是FNR-tree下层索引中每个树包含的记录数量小于NDTR-tree和DISC-tree,在查询过程中,NDTR-tree和DISC-tree对树的遍历操作更消耗时间.由于后一因素起主要作用,因此FNR-tree的查询时间优于NDTR-tree和DISC-tree.如图10所示,随着查询窗口的增大,FNR-tree查询时间增加的趋势要大于NDTR-tree和DISC-tree,原因在于NDTR-tree和DISC-tree下层每个R-tree对应的是一条道路,上层叶子结点与下层R-tree的对应关系为n1.而FNR-tree的上层索引基本单位是封闭路段,每个下Page11层R-tree对应一个封闭路段,上层叶子结点与下层R-tree的对应关系为11.随着查询窗口增大,包含的封闭路段增多.例如,查询到道路r的3个封闭路段(r.b1,r.b2,r.b3),在FNR-tree中需要对r.b1,r.b2,r.b3在下层索引森林中的3个树分别进行查询,而NDTR-tree和DISC-tree只需要对下层索引森林中r所在的树进行查询即可.为了进一步比较当移动对象数量规模较大时3种索引查询时间的性能差异,图11给出了查询窗口大小占地图的30%,移动对象数量从5500变化到10000时,NDTR-tree和DISC-tree索引时空范围查询的时间代价.图11大规模移动对象下时空范围查询时间比较实验结果表明:(1)DISC-tree随着移动对象数量增加其查询时间波动没有NDTR-tree剧烈;(2)当移动对象数量规模较大时(从5500变化到10000时),DISC-tree性能优势明显,查询效率可以提高23.5%.原因与本节之前介绍的小规模移动对象数量下的时空范围查询相同.7结论目前路网中移动对象索引技术的研究成果较少,仍处于起步阶段.考虑到现有路网中移动对象索引技术的不足,本文在提高索引建立维护和移动对象轨迹查询性能方面进行了深入研究.针对NDTR-tree在索引维护和轨迹查询方面的不足,FNR-tree针对时空范围查询准确性不高的缺点,提出了新型基于路网的移动对象动态双层索引结构DISC-tree,对更新较少的静态路网信息采用R-tree索引管理,对实时更新代价较高的移动对象运动轨迹采用结点更新代价较小的R-tree进行索引.大量的实验结果证明了DISC-tree在索引维护和查询性能上领先于NDTR-tree,在查询精度上优于FNR-tree.由于DISC-tree建模中没有考虑真实客观环境因素,如红绿灯,高峰路段,车辆限行等,这些因素对路网中移动对象运动趋势会产生影响,未来工作将对影响移动对象运动的主客观因素建模,集成到DISC-tree中,进一步提高查询结果的准确性.
