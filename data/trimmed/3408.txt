Page1基于部分覆盖表的错误交互定位方法周吴杰1),2)张德平4)徐宝文2),3)1)(东南大学计算机科学与工程学院南京210096)2)(南京大学软件新技术国家重点实验室南京210093)3)(南京大学计算机科学与技术系南京210093)4)(南京航空航天大学信息科学与技术学院南京210016)摘要在组合测试定位模型的基础上提出了部分覆盖表的错误交互定位方法,该方法在错误交互个数已知的条件下,通过生成部分覆盖表,利用测试用例运行结果提供的信息来对软件错误交互定位.从理论上证明了部分覆盖表等价于一类特殊的错误定位表,进而研究了部分覆盖表行数的上界,提出生成部分覆盖表的贪心算法,从而给出了定位引发软件故障的错误交互的非自适应算法,并通过实验验证了该方法的有效性.关键词组合测试;覆盖表;部分覆盖表;错误定位表1引言随着计算机技术的飞速发展,软件系统变得越来越庞大,软件测试成为保证这些系统质量的一个关键手段.然而影响系统运行的因素有很多,如何检测各个因素之间的相互作用对系统产生的影响,通常可通过组合测试方法来检测.组合测试作为一种重要的软件测试方法,因能以较少的测试用例来实现对被测试系统进行科学有效的测试而得到广泛的研究和应用.对于那些故障来源于软件系统中一些参数和参数之间的相互作用的系统,这种方法的效果尤其明显.一般地,对于小的软件系统,其因素数很少时,可采取穷尽测试来检测各个因素交互作用,但对于大的软件系统,穷尽测试是不可能的,也是没有必要的.如一个系统有10个因素,每个有4个不同的取值,则穷尽测试需要410=1048576个测试用例.所以我们可以选择测试用例来测试所有因素的两两交互,或者t维交互,这样需运行的测试用例会大大减少.如上例,若采用两两交互测试只需至多25个测试用例.Kuhn等人的研究表明测试两两组合覆盖能发现大约70%的错误,三维组合覆盖能发现90%的错误[1].在组合测试中,由于测试的失败预示系统组件中存在错误,这就需要测试人员找出触发系统故障的错误交互.目前现存的基于组合测试的错误定位方法主要包括分类树法[2]、故障调试法[3]和错误定位表[4-6]等.利用分类树法,系统的错误模式(导致系统故障的是某些参数的特定取值或是这些取值的组合)一般很难被精确地确定[7].采用故障调试定位法通过增加附加测试用例数能够对一些特殊的系统错误得到较为精确的定位,但对于一些大型软件系统,由于系统的交互因素数目众多,一个测试用例包含的模式数目呈指数增长,从而导致触发软件故障的可能模式数目呈指数增长,使得错误定位变得不适用[3].在某些特殊假设下,错误定位表虽然能够对所有软件交互错误都能精确定位,但错误定位表的行数随系统中错误交互数增加呈指数增长,并且对于较为大型软件系统其生成也是一项相当复杂且费时的任务,在实际组合测试中进行错误定位显得低效.因此,当利用组合测试策略来对系统进行测试,发现某些因素的组合导致系统发生故障时,如何定位和侦测哪些因素组合会导致系统故障,一直是组合测试中一个亟待解决的重要课题.本文在研究Martínez等人[5-6]提出的组合测试错误定位表的基础上,提出了一类特殊的错误定位表———部分覆盖表,在错误交互个数与安全值向量已知的条件下,通过生成部分覆盖表,利用测试用例运行结果提供的信息来对软件错误定位.并从理论上证明了部分覆盖表等价于这类特殊的错误定位表,进而研究了部分覆盖表行数的上界,并提出生成部分覆盖表的贪心算法,给出了定位引发软件故障的错误交互的非自适应算法.本文第2节介绍背景及相关研究工作;给出了基本的组合测试模型、故障定位模型以及相关结论;第3节提出基于部分覆盖表的错误定位模型,证明了在某种情形下,错误定位表等价于某种类型的部分覆盖表,并用概率方法证明了部分覆盖表的行数的上界;第4节给出基于逐条生成测试用例的部分覆盖表的贪心算法,估计出利用贪心算法来生成此特殊的部分覆盖表时覆盖表的规模,并进一步给出了局部模拟退火算法;第5节通过实例分析对部分覆盖表生成方法的有效性进行验证;最后是全文总结并讨论未来可进行研究的方向.2背景及相关研究2.1相关研究目前,人们关于组合测试的研究主要集中在组合覆盖测试用例集的生成技术,即如何在满足给定组合覆盖标准的前提下,生成规模尽可能小的测试用例集以节约测试成本.组合测试用例集生成一般是利用传统的代数方法[8-9]求解或者最优化方法来直接搜索或构造覆盖数组.由于这个问题的复杂性是NP完全的,大部分的方法都是局部搜索算法,这些方法不能保证得到最优解,但是处理时间相对较少.这些方法主要包括贪心算法和启发式搜索方法[10-15].另外,有少量的研究采用全局搜索算法,如一些元启发式搜索方法[16-19],能够对一定规模的问题得到较优解.对于生成测试用例规模问题的确定,即对于具体的应用场景,至少生成多少条测试用例才能满足组合覆盖需求,这个问题只有在某些特殊的情况下才能确定,对于一般情形这仍然是个公开问题;Godbole等人[20]采用概率方法来研究生成测试用例规模的上界,Carey等人[21]提出部分覆盖表的概念并研究其行数(测试用例数)的上界.当软件缺陷被检测出后,如何利用运行测试用例所得的信息来进行错误定位是软件测试过程中必不可少的一个环节.目前,对组合测试的结果进行调试和分析的研究还很少.Yilmaz等人[2]采用分类树Page3(classificationtree)的方法分析程序错误的特征(faultcharacterization),触发被测系统错误的参数取值.该项工作主要分析了与系统配置相关的错误(option-relatedfailures),他们采用一个开源中间件ACE+TAO分析了采用覆盖数组的组合测试的错误定位能力.其实验结果表明,如果采用分类树算法对测试结果进行分析,那么,即使是强度较小的组合测试方法,其错误定位能力也与完备测试相当,但采用组合测试无法进一步确定错误发生的具体原因[7].徐宝文等人[3]首先假定“若某个模式是错误模式,则任意包含该模式的其它模式也将引发相同的错误”.在此前提条件下,他们通过分析执行失败的测试用例,生成一批与之类似的附加测试用例,并通过执行附加测试用例,逐步缩小故障模式集合M的范围,直到错误被精确地定位.Colbourn和McClary提出了(d,t)错误定位表及错误侦测表的概念,用这些表来对组合交互错误进行定位[4].随后Martínez等人[5-6]提出了一般的错误定位表,并在此模型下提出了自适应算法来定位错误交互.2.2错误定位表及相关定义侦测技术,这里先给出一些记号和形式化定义.假设影响待测系统(SoftwareUnderTest,SUT)的因素共有k个,因素i有vi(1ik)个可能的取值,用0,1,…,vi-1表示.我们用记号[0,vi-1]表示集合{0,1,…,vi-1}.假设这些参数的取值是相互独立的,即某个参数的具体取值不会影响其它参数的取值或存在性.定义1.设k维向量犜=(T1,T2,…,Tk),其中Ti∈[0,vi-1],i=1,2,…,k,则称这个k维向量犜为第i个因素取值为Ti的测试用例.为了更好介绍基于组合测试的软件故障定位与交互.为了产生交互测试用例,定义覆盖表如下.定义4.如果A是一个n×k表,表中第i列元为了定位交互,引入如下定义.定义2.任取t个因素,设集合I={(i1,ai1),(i2,ai2),…,(it,ait)},其中因素ij互不相等,aij∈{0,1,…,vij-1}(i=1,2,…,t),则称这个集合I为一个t维交互.称集合f={i1,i2,…,it}为交互I对应的因素集,(i1,ai1)称为顶点.定义3.设一条测试用例犜的第ij个因素取值是aij(j=1,2,…,t),即犜(ij)=aij,则称这条测试用例覆盖了t维交互I={(i1,ai1),(i2,ai2),…,(it,ait)}.由定义3可知,一条测试用例覆盖了()k素都取自[0,vi-1],且满足每个可能的t维交互都被表中某一行所对应的测试用例所覆盖,即对任意的{(i1,ai1),(i2,ai2),…,(it,ait)},至少存在一行r,使得A[r,ij]=aij,j=1,2,…,t,则称表A是一个t维混合覆盖表,记此表为MCA(n;t,(v1,v2,…,vk)).t称为覆盖表的强度.给定t和v1,v2,…,vk,称使得MCA(n;t,(v1,v2,…,vk))存在的最小的整数n为混合覆盖表数,记为MCAN(t,(v1,v2,…,vk)),当定义中的v1=v2=…=vk=v时,我们简记为CA(n;t,k,v)和CAN(t,k,v).在不引起混淆的情况下覆盖表或混合覆盖表统称为覆盖表.一般地,人们用覆盖表或混合覆盖表来产生测试用例,表中每一列对应一个因素,k表示因素数目,vi表示每个因素可能取的取值个数,每一行表示一个测试用例,t维覆盖表产生的测试用例集能覆盖到k个因素中任意t个因素所有可能的取值组合,2维覆盖表产生的测试用例集称为两两组合测试用例集,人们希望在不降低测试标准情况下来产生尽可能少的测试用例.例如一个打印系统有两种类型打印机P1,P2,分别用0,1表示;打印的文件格式有3种JPEG,PDF,PS,分别用0,1,2表示,颜色及文件大小如表1所示.打印机文件格式颜色0=P11=P2若对因素的所有可能取值组合进行测试,则需要2×3×2×3=36个测试用例,若只考虑任意两个因素之间的交互作用,则只需要9条测试用例即可,如表2.测试用例打印机文件格式颜色文件大小输出结果10000pass20011fail31012fail41110pass51101pass60102fail70200fail80211pass91212pass假设每条测试用例在运行时只有两个可能结果:通过或失败.假定一个运行失败的测试用例至少Page4包含一个交互错误,否则就运行通过.进一步,假定若一个交互是错误的,则所有包含此错误交互的测试用例运行都是失败的.运行表2中的测试用例,得到输出结果列在表的最后一列.对于那些失败的测试用例,如何才能精确定位是哪个取值组合出了问题?因此,必须对覆盖表进行更深入的研究,最好在测试完之后就能知道哪些交互是错误交互,这在没有额外的假设下很难做到.基于此Colbourn和McClary[4]提出了(d,t)错误定位表及错误侦测表的概念,随后Martínez等人[5-6]提出了一般的错误定位表概念.他们提出的错误定位模型是把待测系统(SUT)中的错误交互看成超图的边,从而构成一个错误交互超图来进行定位.为了简化起见,这里采用交互集合的语言来介绍错误定位表模型.假设某个s维交互导致错误,则所有包含这个s维交互的其它交互也会导致错误,为此只记录极小的错误交互,即其任何的真子集都不再是错误交互.设某个待测系统(SUT)有d个极小错误交互,用Π表示所有的极小错误交互构成的集合,则Π中错误交互都不可能互相包含.如果Π中每个错误交互都有t个元素,记为Πt,如果每个错误交互至多有t个元素,记为Πt-.以后若不特别说明,错误交互集都是指极小的错误交互集.如果一条测试用例没有覆盖Π中任何错误交互,则称这条测试用例避开了Π.定义5.给定t维交互I与错误交互集Πt,如果存在覆盖这个交互I的一条测试用例T避开了Πt\{I},则称这个t维交互I关于Πt是可定位的,并称此测试用例T定位了交互I.如果每个t维交互关于Πt都是可定位的,则称Πt是可定位的.类似地,可以定义:定义6.给定s(st)维交互I与错误交互集Πt-,设I包含的Πt-中的极小错误交互集合为ΓI,如果存在覆盖这个交互I的一条测试用例T避开了Πt-\ΓI,则称这个s维交互I关于Πt-是可定位的,并称此测试用例T定位了交互I.如果每个s(st)维交互关于Πt-都是可定位的,则称Πt-是可定位的.由定义5与定义6知,我们的组合测试方法只能定位可定位的错误交互集Π,如一个待测系统(SUT)中有3个因素,每个因素取值都是二元的,如图1所示,类型1中交互集{{(2,0),(3,1)}{(2,1},(3,1)}}就是不可定位的,因为交互{(1,0),(3,1)}不可定位;类型2中交互集{{(2,0),(3,1)}{(2,1},(3,1)}}也是不可定位的,因为交互{(1,0),(3,1)}不可定位.对于错误交互集Π是否可定位,判断起来比较复杂,如果对于任意一个因素i,都至少存在一个顶点(i,si),错误交互集Π没有覆盖这个顶点,则错误交互集Π是可定位的.定义7[6].如果一个待测系统(SUT)中的错误交互集为Π,且对i∈[1,k],都存在顶点(i,si),使得(i,si)没有被包含在任何交互I∈Π中,则称这个待测系统(SUT)具有安全值,并称(s1,s2,…,sk)为这个待测系统的安全值向量.如果一个待测系统(SUT)具有安全值,则其错误交互集Πt-是可定位的[5].对于可定位的错误交互集Π,可定义错误定位表.定义8[5](错误定位表ELA(n;t,(v1,v2,…,vk))).设待测系统(SUT)中,其错误交互集Πt是可定位的,一个n×k表A,其第i列元素取自[0,vi-1](i=1,2,…,k),且满足:每个t维交互I都能被A的某一行对应的测试用例所定位.则称A是强度为t的错误定位表,记为ELA(n;t,(v1,v2,…,vk)).定义9[5](错误定位表ELA(n;t-,(v1,v2,…,vk))).设待测系统(SUT)中,其错误交互集Πt-是可定位的,一个n×k表A,其第i列元素取自[0,vi-1](i=1,2,…,k),且满足:每个不包含Πt-中任何s(st)维交互I都能被A的某一行所对应的测试用例所定位,则称A是强度至多为t的错误定位表,记为ELA(n;t-,(v1,v2,…,vk)).显然,每个错误定位表ELA(n;t,(v1,v2,…,vk))(ELA(n;t-,(v1,v2,…,vk)))都是MCA(n;t,k,(v1,v2,…,vk)).Martínez等人证明了当Π中错误交互数是k的高阶无穷小时,绝大多数待测系统(SUT)都有安全值[6].利用错误定位表ELA(n;t-,(v1,v2,…,vk)),我们很容易确定错误交互集Πt-.运行错误定位表所形成的测试用例集,对所有通过的测试用例其包含的所有交互都是正确的,只需从所有的s(st)维交Page5互形成的集合中划去包含在某个通过的测试用例中的那些交互,剩下的就是所寻找的错误交互集,再对这个集合中划去所有的非极小错误交互,剩下就是所求的Πt-,具体过程由算法1给出.算法1.由错误定位表得到错误交互集.输入:ELA(n;t-,(v1,v2,…,vk))输出:Πt-beginΠt-=//初始化Πt-为空集运行ELA(n;t-,(v1,v2,…,vk))中每一行所构成的测试用例;fors=1totdoendforΠt-=Πt-∪ΓendforΠt-=Πt-\{非极小错误交互}returnΠt-end对于可定位的Π,错误定位表大小规模有多大?即最多有多少行?Martínez等人用更高强度的覆盖表来构造错误定位表.假设待测系统(SUT)具有安全值,其错误交互集Πt-中错误交互数最多为d,则当t+dk时,每个MCA(n;t+d,(v1,v2,…,vk))都是ELA(n;t-,(v1,v2,…,vk))[6].对于覆盖表,可以估计其行数的上界,若待测系统(SUT)具有安全值,其错误交互集Πt-中错误交互数最多为d,则其ELA(n;t-,(v1,v2,…,vk))的行数满足n=O(d(v)dlogk)[6].所以用MCA(n;t+d,(v1,v2,…,vk))来构造错误定位表,其行数虽然关于因素数是对数阶的,但是关于错误数d则是指数阶的,当d比较大时,其行数会爆炸增长,并且由于需覆盖的交互数呈指数增长,所以构造混合覆盖表MCA(n;t+d,(v1,v2,…,vk))的很多算法也变得不适用,下面我们在安全值已知的条件下寻找另外的组合结构来构造错误定位表.3基于部分覆盖表的错误定位模型我们设待测系统(SUT)具有安全值,且安全值已知,设安全值向量狊=(s1,s2,…,sk),可以对每个因素的取值进行置换,所以不失一般性,我们设每个因素的安全值为0,即安全值向量为狊=(0,0,…,0).另外,为了研究此类错误定位表构造,我们把Carey等人[21]提出部分覆盖表的概念一般化如下.定义10.设Γ是一个t维交互集合,一个n×k表A,如果表中第i列元素都取自[0,vi-1],且满足:每个Γ中的t维交互都被表中某一行所对应的测试用例所覆盖,即对任意的{(i1,ai1),(i2,ai2),…,(it,ait)}∈Γ,至少存在一行r,使得A[r,ij]=aij,j=1,2,…,t,则称表A是一个t维的部分混合覆盖表,记为PMCA(n;t,(v1,v2,…,vk),Γ).给定t和v1,v2,…,vk,Γ,称使得PMCA(n;t,(v1,v2,…,vk),Γ)存在的最小的正整数n为部分混合覆盖表数,记为PMCAN(t,(v1,v2,…,vk),Γ),当定义中的v1=v2=…=vk=v,我们简记为PCA(n;t,k,v,Γ)和PCAN(t,k,v,Γ).有了部分覆盖表的概念,我们得到下面的定理.定理1.设待测系统(SUT)具有安全值,其安全值向量为狊=(0,0,…,0),其错误交互集Πt-中错误交互数最多为d,t+dk,记交互集Γ={{(i1,ai1),(i2,ai2),…,(it,ait),(it+1,0),(it+2,0),…,(it+d,0)}|ai1∈[1,vi1-1],ai2∈[1,vi2-1],…,ait∈[1,vit-1]},则部分覆盖表PMCA(n;t+d,(v1,v2,…,vk),Γ)就是错误定位表ELA(n;t-,(v1,v2,…,vk)).证明.设部分覆盖表PMCA(n;t+d,(v1,v2,…,vk),Γ)为A,则对任意的交互I={(i1,ai1),(i2,ai2),…,(iu,aiu)}(ut),若I没有包含Πt-\{I}中的任何错误交互,对任意的交互I∈Πt-\{I},若I对应的因素集是I对应的因素集的子集,则任何覆盖交互I的测试用例必定不覆盖I.设Πt-\{I}中剩下的交互数为dd,即设{I1,I2,…,Id}=Πt-\{I|I对应的因素集是I对应的因素集的子集},则存在j1,j2,…,jd∈[1,k]\{i1,i2,…,it},使得ji是交互Ii包含的某个顶点对应的因素,即存在aji∈[1,vji-1],i=1,2,…,d使得(ji,aji)∈Ii,不妨设j1,j2,…,jd互不相同.由于A为PMCA(n;t+d,(v1,v2,…,vk),Γ),所以存在某一行所对应的测试用例覆盖交互{(i1,ai1),(i2,ai2),…,(iu,aiu),(iu+1,aiu+1),…,(it,ait),(j1,0),(j2,0),…,(jd,0),(it+d+1,0),…,(it+d,0)},其中iu+1,…,it,it+d+1,…,it+d互不相同且取与i1,i2,…,iu,j1,j2,…,jd不相同的任意因素,au+1,…,at任取非零Page6的合法值,由于这一行不可能覆盖Πt-\{I}中的错误交互,所以这一行定位了交互I.所以Πt-是可定位的,所以表A是一个错误定位表ELA(n;t-,(v1,v2,…,vk)).定理1表明,对极小错误交互数最多为d的待测系统(SUT),具有安全值向量狊=(0,0,…,0),只需构造部分覆盖表PMCA(n;t+d,(v1,v2,…,vk),Γ)作为它的错误定位表即可,根据Γ的定义知,PMCA(n;t+d,(v1,v2,…,vk),Γ)表示一个n×k表,任取t+d列,任何形如(0,…,0,vi1,0,…,0,vi2,0,…,0,vit)的t+d维向量都能被某一行所覆盖,其中vij≠0为对应列所对应因素的合法取值.那么PMCA(n;t+d,(v1,v2,…,vk),Γ)的行数的上界是多少?我们先来研究这个问题,首先我们给出下面定理.定理2.记交互集Γ={{(i1,ai1),(i2,ai2),…,(it,ait),(it+1,0),<itk则部分覆盖表数PMCAN(t+d,(v1,v2,…,vk),Γ)∑1i1<i2<…其中v=max{v1,v2,…,vk}.证明.构造PMCA如下:对每个t维交互{(i1,ai1),(i2,ai2),…,(it,ait)},ai1∈[1,vi1-1],ai2∈[1,vi2-1],…,ait∈[1,vit-1]构造一条测试用例,使得这条测试用例覆盖这个交互且其余因素取值为0,把这条测试用例作为PMCA的一行,所有这些行构成了满足要求的PMCA.该PMCA的行数为∑1i1<i2<…<itk<itk从而PMCAN(t+d,(v1,v2,…,vk),Γ)∑1i1<i2<…其中v=max{v1,v2,…,vk).定理2中估计的部分覆盖表数是关于k多项式增长的,下面我们用Lovszlocallemma来进一步估计部分覆盖表行数的上界.引理1[21](Lovszlocallemma).设A1,A2,…,An是某概率空间的事件,假设事件Ai与余下的除了至多r个事件以外的其它事件互相独立,且P(Ai)p,i=1,2,…,n.如果ep(r+1)1,则P(∩n有了这个引理,我们就采取如文献[21]中方法来估计PMCA(n;t+d,(v1,v2,…,vk),Γ)行数的上界.考虑当v1=v2=…=vk=v情形,我们有下面定理.PCAN(t+d,k,v,Γ)定理3.当t+dk时,下列不等式成立:(v-1)e()t证明.用概率的方法来构造n×k表,设表中PCAN(t+d,k,v,Γ)=O(dt+1logk),d→.元素以概率α取值为0,以概率1-α[1,v-1],设Ai表示第i个t+d列不满足覆盖条件的事件,即某个t+d维向量(0,…,0,vi1,0,…,0,vi2,0,…,0,vit)没有被覆盖.则P(Ai)=P(∪(0,…,0,vi1,0,…,0,vi2,0,…,0,vit)(v-1)tt+d()tP((1,…,烉烇烋1=(v-1)tt+d()t1-αd1-α而每个t+d列取值与其余的至多r个t+d列取值互相有影响,所以Ai与最多r个事件不互相独立,则r+1(t+d)k-1从而,当e(v-1)tt+d()t1-αd1-α时,P(∩t+d,k,v,Γ).设1-αd1-αn-1而q=1-αd1-α到最小值,此时q=1-ttddPMCA(n;t+d,k,v,Γ)的行数为Page7n-1即PCAN(t+d,k,v,Γ)-1其中,q=1-ttdd可得从而有PCAN(t+d,k,v,Γ)(v-1)e()tPCAN(t+d,k,v,Γ)=O(dt+1logk),d→,k→.由定理1及定理3知,对极小错误交互数最多为d的待测系统(SUT),具有安全值向量狊=(0,0,…,0),用部分覆盖表来构造错误定位表其行数关于k是对数增长的,关于d是多项式增长的.4生成部分覆盖表的贪心算法对于生成部分覆盖表,我们可以用生成一般的覆盖表方法来生成部分覆盖表,如贪心算法、智能搜索等,然而用一次只生成一条测试用例的贪心算法来生成部分覆盖表,其生成覆盖表的行数关于d是多项式增长的吗?由定理3中证明知道,设表中元素以概率d的表是部分覆盖表的概率大于零时表的行数最少,所以我们对于一次只生成一条测试用例的贪心算法,如果每次选择的测试用例都是有kdt+[]d个非0,且覆盖了尽可能多的未被覆盖k-kd的t+d维交互,则有可能最后生成的部分覆盖表行数较少,所以我们得到算法2.算法2.一次只生成一条测试用例的贪心算法.输入:t,d,(v1,v2,…,vk),Γ输出:部分覆盖表PMCA(n;t+d,(v1,v2,…,vk),Γ)Abeginift+d>kelseendifreturnAend由算法2,可以推出如下定理.定理4.设v1=v2=…=vk=v,当t+dk,kdt+d为整数时,对于一次只生成一条测试用例的贪心算法2,生成的部分覆盖表的行数n=O(dt+1logk),d→,k→.证明.类似于文献[10]中证明覆盖表行数是因素数的对数阶增长的方法,设在选取第m个测试用例后,集合Uncover中未被覆盖的t+d维交互个数为Dm,则设Φ为包含kd用例集,在选取第m个测试用例后,集合Um={(T,I)|I∈Uncover,T∈Φ,T覆盖交互I}.我们用两种方法计算Um中元素个数|Um|.对每个交互I∈Uncover,由于在Φ中覆盖交互I的测试用例个数为|Um|=Dm·试用例的条数|Φ|=每条测试用例覆盖未被覆盖的t+d维交互数为Page8t+dktk(k-1)…(k-t-d+1)(v-1)t)+1kt从而设生成的部分覆盖表的行数为n,则Dn+1<1,故Dn<D01-ttdd所以再由(log1-ttdd可得n(t+d)t+d(v-1)tlogD0ttdd(t+d)t+d(v-1)tlogk=从而有n=O(dt+1logk),d→,k→.证毕.定理4表明算法2生成的部分覆盖表行数是关于d多项式增长,关于k对数增长,这与文献[6]中结论相比是一个比较大的改进.我们的贪心算法在选择下一条测试用例时,要求在包含kd用例集中,选择一条覆盖了最多尚未被覆盖的t+d维交互的测试用例,这在实践中每次能选到最优的测试用例是不可能的,所以在实际操作中我们用一些启发式方法来选择下一条测试用例,使其尽可能多地覆盖尚未被覆盖的t+d维交互(算法3).算法3.局部模拟退火算法.输入:t,d,(v1,v2,…,vk),Γ输出:部分覆盖表PMCA(n;t+d,(v1,v2,…,vk),Γ)Abeginift+d>kendifUncover=Γ//未被覆盖的t+d维交互集n=0endwhilereturnAend部分覆盖表作为错误定位表与用MCA(n;t+d,(v1,v2,…,vk))来构造错误定位表相比,虽然其行数在理论上是一个大的改进,但是在生成部分覆盖表时,随着d的增大,同样会遭遇需覆盖的交互数呈指Page9数爆炸增长的困难,如何克服这个困难来生成d,k较大时的部分覆盖表?我们准备在未来的工作中采用组群测试中的池设计办法来生成部分覆盖表[22-23].5实例分析假设一个待测系统有5个因素,第2,4因素有3个取值,其余因素有2个取值,系统中有2个两两错误交互{(1,1),(2,2)}{(2,2),(4,1)},具有安全值向量(0,0,0,0,0),错误交互如图2所示.构造部分覆盖表时需覆盖的部分交互集Γ为Γ={{(1,1),(2,1),(3,0),(4,0)},{(1,1),(2,2),(3,0),(4,0)},{(1,1),(2,0),(3,1),(4,0)},{(1,1),(2,0),(3,0),(4,1)},{(1,1),(2,0),(3,0),(4,2)},{(1,0),(2,1),(3,1),(4,0)},{(1,0),(2,2),(3,1),(4,0)},{(1,0),(2,1),(3,0),(4,1)},{(1,0),(2,1),(3,0),(4,2)},{(1,0),(2,2),(3,0),(4,1)},{(1,0),(2,2),(3,0),(4,2)},{(1,0),(2,0),(3,1),(4,1)},{(1,0),(2,0),(3,1),(4,2)},{(1,1),(2,1),(3,0),(5,0)},{(1,1),(2,2),(3,0),(5,0)},{(1,1),(2,0),(3,1),(5,0)},{(1,1),(2,0),(3,0),(5,1)},{(1,0),(2,1),(3,1),(5,0)},{(1,0),(2,2),(3,1),(5,0)},{(1,0),(2,1),(3,0),(5,1)},{(1,0),(2,2),(3,0),(5,1)},{(1,0),(2,0),(3,1),(5,1)},{(1,1),(2,1),(4,0),(5,0)},{(1,1),(2,2),(4,0),(5,0)},{(1,1),(2,0),(4,1),(5,0)},{(1,1),(2,0),(4,2),(5,0)},{(1,1),(2,0),(4,0),(5,1)},{(1,0),(2,1),(4,1),(5,2)},{(1,0),(2,1),(4,2),(5,0)},{(1,0),(2,2),(4,1),(5,0)},{(1,0),(2,2),(4,2),(5,0)},{(1,0),(2,1),(4,0),(5,1)},{(1,0),(2,2),(4,0),(5,1)},{(1,0),(2,0),(4,1),(5,1)},{(1,0),(2,0),(4,2),(5,1)},{(1,1),(3,1),(4,0),(5,0)},{(1,1),(3,0),(4,1),(5,0)},{(1,1),(3,0),(4,2),(5,0)},{(1,1),(3,0),(4,0),(5,1)},{(1,0),(3,1),(4,1),(5,0)},{(1,0),(3,1),(4,2),(5,0)},{(1,0),(3,1),(4,0),(5,1)},{(1,0),(3,0),(4,1),(5,1)},{(1,0),(3,0),(4,2),(5,1)},{(2,1),(3,1),(4,0),(5,0)},{(2,2),(3,1),(4,0),(5,0)},{(2,1),(3,0),(4,1),(5,0)},{(2,1),(3,0),(4,2),(5,0)},{(2,2),(3,0),(4,1),(5,0)},{(2,2),(3,0),(4,2),(5,0)},{(2,1),(3,0),(4,0),(5,1)},{(2,2),(3,0),(4,0),(5,1)},{(2,0),(3,1),(4,1),(5,0)},{(2,0),(3,1),(4,2),(5,0)},{(2,0),(3,1),(4,0),(5,1)},{(2,0),(3,0),(4,1),(5,1)},{(2,0),(3,0),(4,2),(5,1)}}.而生成的部分覆盖表为00101011001001001001001100202010100010100200102100001201200010020000110201001020000211000111000这个部分覆盖表也就是在已知安全值向量狊=(0,0,0,0,0)且已知错误交互数至多为2时的错误定位表ELA(19;2,(2,3,2,3,2)),运行每一行所对应的测试用例,再根据运行的结果,利用算法1就能定位出错误交互集{(1,1),(2,2)}{(2,2),(4,1)}.如果根据定理2,用混合覆盖表MCA(n;2+2,(2,3,2,3,2))来生成ELA(n;2,(2,3,2,3,2)),则行数n36.对于一般情形,我们运行算法3,生成的部分混合覆盖表的规模列表如表3所示.类型PCA(2,2,26)16/1521(2,4,320)763/7604486(2,2,310)119/180159(2,4,415)1235/94516384(2,2,413)361/702508(2,4,515)2207/168082139(2,2,515)743/16801245(3,2,210)47/12056(2,2,610)751/11253237(3,2,314)696/2912922(2,3,220)107/190119(3,2,415)2592/122853064(2,3,320)460/7601266(3,3,210)107/120116(2,3,420)1058/17105516(3,3,315)1686/36403234(2,3,515)1417/168012704(3,3,412)4093/594014284表中(2,2,26)表示t=2,d=2有6个因素,每个因素有2个取值的待测系统,其它类似,PCA对应的强度为t+d的部分覆盖表,PCA的行数栏对应两个数值,线“/”左边表示运行5次算法3取的最小的行数,线“/”右边表示用定理2得到的上界.CA表示对应的强度为t+d的覆盖表.其中CA的行数Page10是引自由CharlieColbourn维护的覆盖表网址①,上面是已知的覆盖表数的最好上界.表中带“”栏中表明用定理2得到行数比算法3得到的行数要小,主要原因是因素数比较少错误交互数比较多时,算法3复杂度较高,其构造PCA行数反而比较多,随着因素数越来越大时,算法3优势才能发挥出来,PCA行数关于因素数k及错误交互数d的渐近性质才能得到显示.从表中可看出用部分覆盖表代替覆盖表来生成错误定位表,测试用例规模大大约简了.6结论及进一步工作本文中我们在Colbourn和McClary[4]及Martínez等[5-6]基础上研究了在组合测试中怎样定位至多t维的错误交互的非自适应算法,即在安全值已知待测系统中,我们用新的组合结构部分混合覆盖表来生成错误定位表.所以我们未来的研究工作主要集中在:(1)定理3中的理论证明了表中元素以概率dt+d取值为0,以概率t分覆盖表的概率大于零时表的行数最少,然而实践上能否支持这一结论,我们准备做一些实验,研究对不同的取值为0的参数α,比较部分覆盖表大小.(2)研究生成部分混合覆盖表的高效算法.因为当d、k比较大时,用生成一般的混合覆盖表的算法移植来生成部分覆盖表时效率很低,因为需被覆盖的交互集Γ的规模呈爆炸式增长,所以我们研究当d、k比较大时部分混合覆盖表生成,以及研究这些算法与组群测试(grouptesting)里的池设计(poolingdesign)之间的关系[22-23].(3)研究对具有安全值但安全值未知的待测系统构造多阶段的非自适应算法,因为本文研究用部分覆盖表来生成错误定位表的前提是已知安全值向量.(4)对于非自适应算法生成错误定位表,然后用算法1就可自动定位触发系统故障的错误交互,当生成的错误定位表比较大,冗余的测试用例较多,尤其在d比较大时,生成错误定位表比较困难,所以我们研究定位错误交互的高效自适应算法,即根据前面的测试用例的运行结果来生成下一条测试用例的算法.
