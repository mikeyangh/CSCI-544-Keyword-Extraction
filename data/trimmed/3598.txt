Page1模糊描述逻辑知识库查询蕴涵的判定方法程经纬1)马宗民1)严丽2)张富1)1)(东北大学信息科学与工程学院计算机应用技术研究所沈阳110819)2)(东北大学软件学院软件工程研究所沈阳110819)摘要大规模领域本体的快速发展对语义Web领域的数据访问提出了更高的要求,而基本的本体推理服务已不能满足数据密集型应用中处理复杂查询(主要是合取查询)的迫切需要.为此,大量的研究工作集中在本体和描述逻辑知识库合取查询算法的设计实现上,并开发出了很多知识库存储和查询的实用工具.近来模糊本体和模糊描述逻辑的研究,特别是它们在处理语义Web中模糊信息方面,得到了广泛关注.文中重点研究了模糊这一族极富表达能力的描述逻辑知识库的合取查询问题,提出了相应的基于推演表的算法,证明了算法对于f-的真子逻辑的可靠性、完备性和可终止性.证明了算法对于f-是可靠的,并分析了导致算法不可终止的原因.对于该问题的数据复杂度,证明了当查询中不存在传递角色时其严格的CONP上限.对于联合复杂度,证明了算法关于知识库和查询大小的CO3NEXPTIME时间复杂度上限.关键词描述逻辑;查询蕴涵;合取查询;知识库;语义Web1引言随着语义Web[1]的发展,作为语义Web基础的本体受到越来越多研究者的关注.为了在语义Web中实现知识的可重用性和高度互用性,通常使用本体来表示领域知识.基于本体的知识库表示和推理是语义Web的重要组成部分.描述逻辑(DescriptionLogics,DLs)[2]是一种形式化表示知识的方法,是OWLDL等本体语言①的理论基础.描述逻辑知识库一般由TBox和ABox组成,其中TBox表示内涵知识,而ABox则表示外延知识.描述逻辑最显著的特征是其内置的推理机制.利用这一机制,可以由知识库中显式存储的知识推导出隐含的信息.为解决语义Web中知识表示的不精确性和不确定性,已有大量的研究工作致力于OWL以及描述逻辑的模糊扩展.Straccia引入Zadeh的模糊集理论[3],提出了f-以及相应的约束传播推理算法[4];Li等人[5]提出了一种支持数量约束的扩展模糊描述逻辑F;Kang等人提出了支持模糊隶属度比较的模糊描述逻辑fc提出了允许传递角色、逆角色、角色层次的表达能力更强的f-;蒋运承等人[8]提出了面向语义Web表示的模糊描述逻辑F,并给出了完整的推理算法;为表示含有自定义模糊数据类型及自定义模糊数据类型谓词的模糊数据信息,王海龙等人[9]提出了F-的自定义模糊数据类型扩展F-SHOIQ(G).模糊DL的综述可见文献[10].模糊DL的标准推理任务包括检查概念可满足性、概念包含、ABox一致性以及知识库可满足性等[4].对于诸如f-这样一类极富表达能力的模糊DL,实现标准推理服务的模糊推演表(tableau)算法具有很高的最坏情况复杂度,但大量的优化技术[11]使得模糊DL推理机的实现变为可能.在理论研究工作的基础上,出现了支持模糊OWLDL子集f-的FiRE[12]、支持模糊OWLLite即f-()的fuzzyDL[13]以及支持f-()的FRESG[14]等模糊DL推理机.除了标准推理服务外,模糊DL推理机还支持一些简单类型的查询,包括:(1)实例检索(instanceretrieval).给定一个模糊DL知识库和一个模糊概念C,以及n∈(0,1],检索使得蕴涵C(o)n(记作C(o)n)成立的所有个体o.(2)实例化(instantiation).给定一个模糊DL知识库和一个模糊概念断言C(o)n,n∈(0,1],判定C(o)n是否成立.事实上,模糊DL推理机通过将这些简单查询转换为标准推理任务来处理它们.例如,利用模糊断言C(o)n的否定C(o)<n,可以将实例检索问题C(o)n转换为知识库∪{C(o)<n}的不可满足性问题,而后者正是模糊DL推理机可以处理的标准推理任务.随着大量大规模领域本体的出现,为用户提供表达能力更强的查询服务显得尤为重要.合取查询(ConjunctiveQueries,CQs)源于数据库领域,近来被视为查询本体(或DL知识库)的理想形式[15].针对模糊DL知识库的模糊合取查询(或称带阈值的合取查询),为用户提供了比实例检索表达能力更强的查询.例如,用户希望查询“距离会场近(隶属度至少为0.9)并且提供便宜(隶属度至少0.7)房间的酒店”,该查询可以形式化表示为模糊合取查询Hotel(x)1∧closeTo(x,venue)0.9∧hasRoom(x,y)1∧Expensive(y)0.7.这里,用户希望得到系统对于变量x的应答(answers),因此x称为应答变量(answervariable)、自由变量(freevariable)或显著变量(distinguishedvariable),而y则称为非显著变①http://www.w3.org/submission/owl11-overview/Page3量(non-distinguishedvariable)或存在量化变量(existentialquantifiedvariable).查找满足模糊合取查询中显著变量元组的所有个体元组称为模糊查询应答(queryanswering)问题.如果一个模糊合取查询中只包含非显著变量,则该查询称为模糊布尔合取查询.此时,对该查询的应答不再是个体元组,而是真或假.给定一个模糊知识库和一个模糊布尔合取查询q,判定q关于是否为真(记作q)称为模糊查询蕴涵(queryentail-ment)问题.作为一个决策问题,模糊查询蕴涵比模糊查询应答更适于算法复杂度分析.因此,本文将重点讨论模糊查询蕴涵问题.由于将查询中显著变量元组用个体元组替换,即可将模糊查询应答问题归约为模糊查询蕴涵问题,因此处理模糊查询蕴涵问题的算法同样适用于模糊合取查询应答问题.然而,现有的模糊DL推理机却无法处理模糊查询蕴涵问题q,原因在于模糊布尔合取查询q的否定不能(如前面实例检索的例子那样)表示为知识库的一部分.因此模糊查询蕴涵问题不能转换为标准推理问题,当然也无法利用现有的模糊DL推理机来直接处理.本文提出针对f-这样一族极富表达能力的模糊DL知识库模糊合取查询蕴涵判定算法.f-模糊描述逻辑包括f-及其子逻辑f-、f-和f-等.f-是f-的扩展,增加了传递角色公理()、角色层次()、枚举()、逆角色()和受限的数量约束()等构件(constructors).首先,本文研究了f-所包含构件对算法的影响,给出了针对模糊合取查询蕴涵问题的新的阻塞条件下处理每个构件的扩充规则.其次,证明了模糊知识库的合取查询蕴涵问题q,可以通过检查的规范模型来完成,而不必检查的所有模型.该问题可以进一步转化为检查q到的完全图的映射的存在与否来完成,从而将复杂的逻辑蕴涵问题归约为更为简单的语法检查问题.第三,证明了算法对于f-、f-以及f-是可靠(sound)和完备(complete)的,对于f-是可靠的.同时,证明了在枚举、逆角色和数量约束不同时出现时算法是可终止的,而这几种构件同时出现将无限延后阻塞条件满足,并导致算法不可终止.最后,在此基础上,证明了只允许简单角色出现在查询角色原子项时,该算法的CONP数据复杂度上限以及CO3NEXPTIME联合复杂度的上限.2模糊描述逻辑犳-本节将简要回顾f-的语法和语义[16],并介绍本文将用到的一些概念和符号及约定.f-推理算法的详细介绍可参考文献[8].2.1犳-语法设NC、NR和NI为两两不相交的可数无限集合,分别代表概念名、角色名和个体名的集合.NR可以划分为NR=NtR∪NnR,NtR∩NnR=,其中NtR代表传递关系名集合,NnR代表非传递关系名的集合.f-角色按如下规则定义:其中RN∈NR,R-为R的逆角色.为简洁起见,定义NR∪{R-|R∈NR}上的函数Inv,若R∈NR,则Inv(R)=R-;若R=S-且S∈NR,则Inv(R)=S.f-RBox由形式为R含公理和形式为Trans(R)的传递角色公理组成,其中R和S均为f-角色.}上的自反传递闭包记为S且SR色又无传递子角色,则称其为简单角色.如果下标在上下文中明确,可以省略.f-概念按如下规则定义:C,D∷=⊥顶概念可以将其中C和D为概念,A∈NC亦称为原子概念,o1,…,on∈NI,R为f-角色,S为简单角色,p∈.限制(受限)数量约束中的角色为简单角色的目的在于保证逻辑的可判定性[17].f-TBox是模糊概念定义公理A≡D、概念特化公理AC以及模糊通用概念包含公理CD的有限集合,其中A∈NC,C和D为f-概念.Page4f-ABox由模糊概念断言C(o)n、模糊角色断言R(o,o)n和不等断言o≠o构成,其中o,o∈NI,∈{,>,,<},表示或>,表示或<.用定义的模糊断言(例如C(o)>0.6)称为肯定模糊断言,用定义的模糊断言称为否定模糊断言.注意,本文只允许肯定模糊角色断言R(o,o)n.尽管允许否定模糊断言(例如R(o,o)n)并不会影响标准推理任务的可判定性,但这却隐含着角色否定(例如R(o,o)1-n)的存在.即便在表达能力稍弱的模糊描述逻辑f-中,这已经导致模糊查询蕴涵不可判定[4,18].定义1.给定模糊概念D和RBox,D的子概念闭包sub(D,)为满足下列条件的f-概念的最小集合:D∈sub(D,),sub(D,)包含D的所有子概念,如果R.C∈sub(D,)且Rsub(D,),sub(D,).如果R.C∈sub(D,)且R定义sub(,)=∪D(o)n∈sub(D,).如果在上下文中明确,则sub(D,)、∪D∈sub(,)和sub(,)可以分别简写为sub(D)、sub()和sub().定义sub()=sub()∪sub().f-知识库由TBox、RBox和ABox构成,记作=〈,,〉.f-的子逻辑f-、f-以及f-的语法定义与f-类似,分别减少了(受限)数量约束构件()、逆角色构件()和枚举概念构件(),并减少了相应的语义解释部分.定义2(-知识库).设为一种模糊描述逻辑语言,则-知识库表示中所有概念和角色的表达能力都不超出所提供的构件.给定-知识库=〈,,〉,犚表示中所有角色的集合,犆表示中所有概念的集合,犐、犐和犐分别表示、和中所有个体的集合,即犐=犐∪犐.2.2犳-语义f-的语义由模糊解释=(Δ,·)给出,其中解释域Δ是非空的个体集合,·是模糊解释函数,它将每个个体名映射为Δ中的不同元素,将概念名A映射为一个隶属函数A:Δ→[0,1],将角色名R映射为一个隶属函数R:Δ×Δ→[0,1].f-概念和角色的语义如下:⊥(o)=Δ,⊥(o)=,(CD)(o)=min{C(o),D(o)},(CD)(o)=max{C(o),D(o)},(C)(o)=1-C(o),({o1,…,on})(o)=1,如果o∈{o1,…,on}(R.C)(o)=infC(o)}},(R.C)(o)=supo∈Δ(pS.C)(o)=supo1,…,op∈Δoi),C(oi))},min1i<jp(pS.C)(o)=infR(o,oi),1-C(oi))},max1i<jpInv(R)(o,o)=R(o,o).由上面枚举概念和概念析取()的语义可知,{o1,…,on}(o)=({o1}…{on})(o).因此,在含有概念析取构件“”的描述逻辑中,只需一个单值集构件{o},就可以充分表达任一枚举概念.例如,概念{o1,…,on}就可以用概念{o1}…{on}来代替.给定模糊解释和模糊概念包含公理CD(或模糊概念定义公理A≡C,模糊概念特化公理AC),若对于任意o∈Δ,C(o)D(o)(或A(o)=C(o),A(o)C(o))都成立,则称是CD(或A≡C,AC)的模型,记作CD(或A≡C,AC).类似地,对于ABox模糊断言,C(o)n当且仅当C(o)n,R(o,o)n当且仅当R(o,o)n,oo当且仅当o≠o.对于RBox公理,RS当且仅当对于任意〈o,o〉∈Δ×Δ,R(o,o)S(o,o);Trans(R)当且仅当对于任意o,o,o∈Δ,R(o,o){min{R(o,o),R(o,o)}}.传递角色的语义supo∈Δ来自于模糊集理论中sup-min传递关系的定义.若模糊解释是模糊知识库中所有公理和断言的模型,则称其为的模型,记作.知识库是可满足的,当且仅当至少有一个模型.知识库蕴涵模糊断言φ,记作φ,当且仅当的所有模型Page5给定一个知识库,可以不失一般性地做出如下(1)所有概念都是否定范式(NegativeNormalForm,NNF)[4],即否定只出现在概念名之前.利用德摩根律,存在限制(R.C)和全局限制(R.C)之间的对偶关系,以及至多限制(pS.C)和至少限制(pS.C)之间的对偶关系,任何概念都可以通过将否定内推,在线性时间内转换为与其等价的否定范式.(2)所有模糊概念断言都是肯定不等价范式[18](PositiveInequalityNormalForm,PINF).通过对模糊否定概念断言应用补操作,可以将其转换为等价的肯定不等价范式.例如C(o)<n可以转换为语义上等价的C(o)>1-n.(3)所有模糊断言都是标准化范式(NormalizedForm,NF).根据文献[19],通过引入一个正的无穷小量,可以将C(o)>n形式的模糊断言转换为其标准化范式C(o)n+.文献[19]还证明了模糊描述逻辑知识库的每个模型也是标准化形式的知识库的模型,反之亦然.(4)TBox中只包含模糊通用概念包含公理.首先,TBox中形如AC的概念特化可以转化为概念定义[20].对于每个概念特化AC,引入一个新的概念名珡A,然后用A=珡AC来代替AC,这样得到的TBox-和具有相同的模型.进而,概念定义A≡C明了可以通过在知识库中用C替换A而消去,这一过程称为知识库扩充.尽管扩充过程是关于TBox大小指数时间的,但若采取如文献[20]所述的“在需要时展开”(lazyunfolding)的方法,则不会对最终的复杂度结果产生影响.同时也是φ的模型.2.3基本假设假设:例1.给定-知识库.1={{CR.C,CS.{a}},{},{C(o)0.8}},根据定义2,由于1包含枚举概念(),因而它是f-、f-和f-知识库,而不是f-知识库.3模糊合取查询语言下面将参照文献[18]给出本文将使用的模糊合取查询语言以及模糊合取查询蕴涵的形式化定义.设NV为变量名的可数无限集合并且与NC,NR,NI两两不相交.项t或是NI中的个体名,或是NV中的变量名.模糊查询原子项是形式为〈C(t)n〉或〈S(t,t)n〉的表达式,其中C∈犆,S∈犚且为简单角色,t和t为项.与模糊断言的定义类似,这两种不同类型的原子项分别称作模糊概念原子项和模糊角色原子项.同时,假定每个模糊概念原子项中的概念都是否定范式,每个模糊概念原子项都是肯定不等价范式,每个模糊查询原子项都是标准化范式.定义3(模糊布尔合取查询).一个模糊布尔合取查询q是模糊查询原子项的有限集合,表示为q={at1,…,atl}或q=at1∧…∧atl,其中ati为模糊概念原子项或模糊角色原子项,1il.用Vars(q)表示模糊布尔合取查询q中所有变量的集合,Inds(q)表示q中所有个体的集合,Terms(q)表示q中所有项的集合,即Terms(q)=Vars(q)∪Inds(q).模糊布尔合取查询q的语义同样由模糊解释=(Δ,·)给出.定义4(模糊布尔合取查询的模型).模糊解释是模糊查询q的模型,记作q,当且仅当存在映射π:Terms(q)→Δ,使得对于每个个体o∈Inds(q),π(o)=o;对于每个模糊概念原子项C(x)n∈q,C(π(x))m成立;对于每个模糊角色原子项R(x,y)n∈q,R(π(x),π(y))m成立,其中x,y∈Terms(q),mn.给定-知识库和模糊合取查询q,蕴涵q(记作q),当且仅当对于的每个模型,q成立.定义5.模糊合取查询的蕴涵问题定义为:给定-知识库和模糊合取查询q,判定q是否成立.除非特别指出,下文中的查询、模糊查询、模糊合取查询和模糊布尔合取查询具有相同的含义.例2.给定模糊查询q1=R(x,y)0.6∧R(y,z)0.8∧S(z,a)显然,例1中1蕴涵q1,即1q1.由CR.C及其模糊解释的定义可得,对于1的每个模型,(R.C)(o)C(o)0.80.6成立.同时,在Δ中存在元素b,使得R(o,b)0.80.6且C(b)0.8成立.类似地,在Δ中存在元素c,使得R(b,c)0.8且C(c)0.8成立.由CS.{a}可得S(c,a)0.8.构造映射π,使得π(x)=o,Page6π(y)=b,π(z)=c,π(a)=a.根据定义5,可以得到1q1.4模糊查询蕴涵算法与基本推理服务和简单类型查询一样,模糊查询蕴涵的判定算法也基于推演表算法.尽管判定单个模糊概念断言的蕴涵问题C(a)n可以通过归约为检查知识库∪{C(a)<n}的(不)可满足性问题,但是,由于(包含角色原子项的)合取查询的否定不能用f-所提供的构件来表示,因此查询蕴涵问题q不能归约为知识库(不)可满足性问题.这样,推演表算法就不足以完成查询蕴涵的判定了.另一方面,知识库可能具有无限数量的无限模型,而推演表算法只能构建知识库的有限模型.根据第3节的定义,只有知识库的所有模型都蕴涵查询q,查询蕴涵q才成立.因而还需要证明,只检查知识库模型的一个子集,即规范模型(canonicalmodel)的集合,足以判定查询蕴涵.与f-的推演表算法[7-8]一样,我们的算法也使用称为完全图(completegraph)的数据结构,它是一种表示知识库的模型集合的有限结构.算法的描述如下:1.首先将的模型表示为一个初始的完全图G;2.然后,通过反复应用扩充规则(expansionrules),不断产生新的完全图,同时引入新的结点.因为的每个模型都保留在扩充得到的某个完全图中,可以通过检查完全的无冲突的完全图集合ccfk(利用每个G∈ccfk(从语义上,这些规范模型的有限集合足以应答给定大小的查询.也就是说,如果存在G不蕴涵q,则不蕴涵q.然后,将证明Gq可以通过一个q的项到G中结点的语法映射来有效地完成.4.1-知识库的完全图-知识库的完全图G由一个包含有限结点的有向标记图,包括结点集合Nodes(G)、边的Arcs(G)、结点和边的标签集合以及结点之间的等价≈和不等价关系的集合构成,形式化表示为五元组G=(Nodes(G),Arcs(G),,≈,).这里假定等价≈和不等价关系是对称的,即如果vv∈G,则vv∈G.完全图中每个结点(或顶点)v的标签是一个三元组的集合(o)={〈C,,n〉},其中C∈sub()∪{lS.C|pS.C∈sub(),l<p},n∈(0,1].完全图中每条边(或弧)〈o,o〉的标签也是一个三元组的集合(〈o,o〉)={〈R,,n〉},其中R为-角色.完全图中对应于犐中个体名的结点称为个体结点,而由扩充规则产生的非个体结点称为生成结点.个体结点和生成结点集合分别记作Inds(G)和Gens(G),则Nodes(G)=Inds(G)∪Gens(G).完全图中结点v到结点v的最短路径称为v到v的距离,记作d(v,v).如果〈o,o〉是完全图中的边,且〈R,,n〉∈(〈o,o〉),RR∈,则称o是o的一个R,n-后继,o是o的R,n-前驱.如果不考虑不等号和隶属度,也可以将o称为o的R-后继,o为o的R-前驱.前驱和后继的传递闭包分别称为祖先和后代.如果o为o的R,n-后继或者Inv(R),n-前驱,则称o为o的R,n-邻结点.给定-知识库=〈,,〉,图1中算法Init()根据输入的ABox初始化并返回完全图G.例3.对于例1中知识库1,G初始化为只包含一个结点o,其标签为{(C,,0.8)}.阻塞条件是保证完全图扩充可终止的关键.-知识库查询蕴涵算法的k-阻塞条件[18]中的k是与模糊查询中模糊角色原子项的个数相关的参数,k值的选择将在4.4节中具体说明.定义6(可阻塞k-图).给定完全图G和G中的生成结点v,k0.结点v的可阻塞k-图Gkv为G的真子图,除结点v之外,Gkv中还包含所有v的与其距离不大于k的生成结点后代w,以及w的所有个体结点后继w.用Nodes(Gkv)表示Gkv的结点集合,则Nodes(Gkv)={v}∪Des(v)∪{w∈Inds(G)|w∈Des(v),w为w的后继},其中Des(v)={w|w∈Gens(G)且d(v,w)k}.如果w在Gkv中无生成结Page7点后继,则称w为Gkv的叶结点.定义7(k-图等价).给定完全图G中的k-图Gkv和Gkv.如果Gkv和Gkv是同态的,即存在双射ψ:Nodes(Gkv)→Nodes(Gkv),使得(1)ψ(v)=v;(2)对于每个结点w∈Nodes(Gkv),(w)=(ψ(w));(3)对Gkv中的每条边〈w,w〉,(〈w,w〉)=(〈ψ(w),ψ(w)〉),则称结点v和v(通过ψ)k-图等价.定义8(图阻塞).设完全图G中两个生成结点v和v(通过ψ)k-图等价,它们的前驱都是生成结点,v是v的祖先,vNodes(Gkv).如果存在一条从v到v的路径,且该路径只包含生成结点,则称Gkv图阻塞Gkv,Gkv中每个结点w图阻塞Gkv中的结点ψ-1(w).定义9(k-阻塞).完全图G中结点v被k-阻塞,当且仅当v为生成结点,并且它被直接k-阻塞或间接k-阻塞.结点v被直接k-阻塞,当且仅当其祖先均未被k-阻塞且v是G中某个被图阻塞的k-图的叶结点.结点v被间接k-阻塞,当且仅当它的一个祖先被k-阻塞,或者它是结点v的后继且(〈v,v〉)=.如果结点v是k-阻塞的,则对于任意lk,它也是l-阻塞的.k-阻塞条件可以看作是知识库一致性检查算法的阻塞条件[7]的泛化:当k=0时,k-阻塞对应于单个结点之间的标签等价阻塞;当k=1时,k-阻塞对应于结点对之间的标签等价阻塞,即对阻塞(pair-wiseblocking).利用一组对应于f-中构件的扩充规则(见表1),对最初的完全图G进行扩充.这些扩充规则在语法上分解结点标签中的概念.如果把结点标签看作是对结点的约束,那么这些扩充规则或是引入新的约束,或是根据这些约束扩充以该结点为根的完全图.k-阻塞用来保证扩充的可终止性.我们用表示扩充得到的完全图集合.规则规则++选择{o}ooNNPage8表1所列规则中,-、-和NN-规则称为生成规则,而、o和o规则称为合并规则.生成规则向完全图中增加新的(生成)结点,而合并规则删除结点,并将与被删除结点相关的信息合并到其它结点中.图2和图3的算法Merge(x,y,G)和Prune(y,G)分别表示将结点y合并到结点x中以及递归地删除结点y及其生成结点后继的步骤.图3中Inv((x,y))表示将(x,y)的每个三元组中角色R替换为Inv(R)得到的角色标签集合,即Inv((x,y))={〈Inv(R),,n〉|〈R,,n〉∈(x,y)}.1.foreachz∈Nodes(G)do2.if(y,z)≠then3.(y,z)··=4.ifz∈Gens(G)then5.Prune(z,G)6.(y)··=7.returnG1.foreachz∈Nodes(G)do2.if(z,y)≠then3.if(z,x)=and(x,z)=then4.(z,x)··=(z,y)5.if(z,x)≠then6.(z,x)··=(z,x)∪(z,y)7.if(x,z)≠then8.(x,z)··=(x,z)∪Inv((z,y))9.(z,y)··=10.foreachz∈Inds(G)do11.if(y,z)≠then12.if(z,x)=and(x,z)=then13.(x,z)··=(y,z)14.if(x,z)≠then15.(x,z)··=(x,z)∪(y,z)16.if(z,x)≠then17.(z,x)··=(z,x)∪Inv((y,z))18.(y,z)··=19.(x)··=(x)∪(y)20.foreachz∈Nodes(G)do21.ifzy22.thenzx23.Prune(y)24.returnG这里需要解释一下处理TBox中通用概念包含公理的-规则.在经典情况[21]中,对TBox中每个通用概念包含公理CD,构造一个全局概念CD,并令模型中每个个体都属于这些全局概念,从而保证模型满足TBox.但在模糊情况下,这种方法并不可行,原因在于模糊集运算并不满足排中律,因而CD无法表达CD的语义.Li等人[22]和Stoilos等人[19]分别提出了处理模糊通用概念包含公理的两种相似的方法.-规则中的N和Nq分别代表ABox和查询q中出现的所有隶属度的集合,即N=X∪{1-n|n∈X},其中X={0,0.5,1}∪{n|C(o)n∈或R(o,o)n∈},Nq={n|C(t)n∈q或R(t,t)n∈q}.此外,对于查询q中模糊概念原子项中每个非原子概念C,向TBox中增加模糊通用概念包含公理CC.这不会对知识库产生逻辑影响,但根据-规则,它保证了将来检查查询到完全图的映射时,对于完全图中任一结点v,若查询中的项映射到v时,或者C(v)n成立,或者C(v)1-n+(即C(v)<n)成立.对于结点o,如果其标签(o)中包含下列情形之一,则称标签中包含冲突(clash):(1)同时包含〈C,,n〉和〈C,,m〉,其中n+m>1;(2)下列三元组之一:〈⊥,,n〉(n>0),〈C,,n〉(n>1);(3)三元组〈pS.C,,n〉,o有p+1个R-,n邻结点o1,…,op+1,其中n+n>1,且对所有的1i<jp+1,oioj.定义10(无冲突完全图).如果完全图G的所有结点都不包含冲突,则称G是无冲突的.定义11(k-完备完全图).如果在k-阻塞条件下,没有任何适用于完全图G的扩充规则,则称G是k-完备的(complete).用ccfk(有k-完备且无冲突的完全图的集合.例4.图4给出了知识库1的2-完备无冲突完全图G1,其中结点标签1={〈C,,0.8〉,〈R.C,,0.8〉,〈R.C,,0.8〉},2={〈C,,0.8〉,〈R.C,,0.8〉,〈R.C,,0.8〉},边标签3={〈R,,0.8〉},4={〈S,,0.8〉}.在G1中,完全图G2o3直接阻塞.4.2完全图的模型与知识库的模型本节将证明知识库的每个模型都保留在某个Page9完备无冲突的完全图G∈ccfk(的模型,并证明对任一的模型,都存在G的模型,使得也是的模型,即蕴涵.这样通过检查的模型来判定查询蕴涵就可以转化为检查G的模型上来.利用模糊知识库的解释=(Δ,·),可以为的完全图G赋以语义.如果把G中的生成结点也看做个体,则G中的个体名、概念名和角色名的解释是的解释的扩展.因而,可以通过扩展的模型来定义G的模型.的一个完全图.=(Δ,·)是的一个模型,即.如果对于G中所有结点v、w,还满足下列条件:定义12(完全图的模型).设G∈(i)若〈C,,n〉∈(v),则C(v)n;(ii)若〈R,,n〉∈(v,w),则R(v,w)n;(iii)若vw∈G,则v≠w.则称是的完全图G的模型,记作G.如果知识库在上下文中明确,则简记为G.型.首先证明最初的完全图G与具有相同的模型.接下来归纳证明ccfk(引理1.G当且仅当.证明.可由完全图的模型的定义直接得到.欲证,需要证明G中所有结点v,w都满足定义12中的条件(i)(ii)(iii).根据完全图的定义,G中每个结点对应于NI中的个体.对于每个个体v∈NI,其在G中的标签(v)={〈C,,n〉|C(v)n∈}.因为是的模型,所以C(v)n,条件(i)成立.类似地,可证条件(ii)(iii)也成立.则,犌为将r应用到G所得到的一组完全图,则对于G的每个模型,存在G∈犌以及的扩展,使得G.引理2.给定G∈证明.下面分类讨论表1列出的规则:(1)确定性、非生成规则.应用此类规则后得到的犌中只有一个完全图G,且不生成新的结点,G的模型也是G的模型.:在G中存在结点x,使得〈CD,,n〉∈(x).对G应用规则得到的G只是在结点x中增加了两个新的标签〈C,,n〉和〈D,,n〉.因为G,所以(CD)(x)n,进而得到C(x)n且D(x)n,则G.+:在G中存在结点x,使得〈S.C,,n〉∈(x),且存在角色R,Trans(R)且R用+规则后,在结点y的标签中新增了〈R.C,,n〉.因为G,由(S.C)(x)n,y为x的R,n-后继且n+n>1,以及R为S的传递子角色,得到(R.C)(y)n,则G详细证明可见文献[7]的推论6.1.+和规则的情况与+的类似.{o}:在G中存在结点x,使得〈{o},,n〉∈(x).本文的模糊描述逻辑中枚举概念仍采用经典情况的语义,因此通过{o}-规则将涉及概念{o}的肯定断言的隶属度设定为1,不会影响模型的等价性.(2)非确定性、非生成规则.:应用规则后,将会产生两个完全图G1和G2,分别在x的标签中新增了〈C,,n〉和〈D,,n〉.因为G,所以(CD)(x)n,进而得到C(x)n或D(x)n,则G1或G2成立.选择:应用规则后,将会产生两个完全图G1和G2,分别在x的后继y的标签中新增了〈C,,n〉和〈C,,1-n+〉.因为G,所以C(y)n或C(y)<n成立,即C(y)n或C(y)1-n+,因而G1或G2.:文献[19]命题1证明了:CD当且仅当对于所有n∈[0,1],所有o∈Δ,C(o)1-n+或D(o)n成立,并通过将n∈[0,1]限制为有限集合,如n∈NA∪Nq,得到可终止的算法.对G中任一结点x,对每个n∈NA∪Nq,应用规则后,将会产生两个完全图G1和G2,由文献[19]命题1可知,G1或G2成立.(3)合并规则.:应用规则后,将把x的两个R,n-后继y和z等同起来.这就要求在此之前y和z没有显式地指定为不等价,即yz,则y=z.在G中只合并了结点y、z,其它标签并未变化(当Merge(y,z)时,涉及z的结点标签和边标签都转移到y中),因此G.o的情况类似.o:完全图G中存在结点x、y,使得〈{o},,1〉∈(x)∩(y).应用规则后得到的完全图G中x和y被合并为一个.因为G,所以{o}(x)1且{o}(y)1.根据枚举概念的语义,x=y=o,这保证了G.{o}的情况类似.(4)生成规则.:由〈R.C,,n〉∈(x)和G可知存在o∈Δ,使得R(x,o)n且C(o)n.应用规则后得到的G,新增了x的R-n后继结点y,并使得〈C,,n〉∈(y).令y=o,则得到的扩展,使Page10最后,证明ccfk(定理1.对于的每个模型,存在G∈ccfk(得G成立.规则的情况与的类似,不同的是新增后继结点的数目.NN:该规则适用于枚举概念()、逆角色()、(受限)数量约束()相互作用的情况,即x为个体结点,存在满足规则中条件的x的Inv(S),n-前驱,〈pS.C,,n〉∈(x).因为G,存在pp,使得x存在p个满足规则条件的S,n-邻结点.通过增加p个新的个体结点x1,…,xp得到完全图G,并令的扩展将其解释为解释域中元素xi=xi(注意,按照之前的约定,个体结点与解释域中元素使用了相同的符号),则G成立.证毕.集就是的所有模型的集合.以及的扩展,使得G.其中k0为任一整数.证明.根据引理1和引理2,对于的每个模型,都存在G∈设Gccfk(而得到扩充的完全图G,并存在的扩展,使得G,依此类推直到无规则可用,此时或者得到一个完全的完全图,或是产生冲突.前者与假设矛盾,后者与G存在模型这一事实矛盾.证毕.4.3在完全图中检查查询蕴涵根据第3节模糊查询蕴涵的定义,判断查询蕴涵成立需要检查知识库的每个模型.根据4.2节定理1,判断查询蕴涵可以转化为检查ccfk(个完全图G的每个模型.下面将说明只需检查ccfk(定义13.给定完全图G和查询q,若对于G的每个模型,q都成立,则称G蕴涵q,记作Gq.定理2.给定知识库和查询q,q当且仅当对于每个G∈ccfk(整数.可知,G的每个模型也是的模型,即G.又由q可知,每个模型都满足q.因此得到Gq.假设/q,则存在的模型,/q.根据定理1,存在G∈ccfk(G.由/q可知/q,因而G/q,矛盾.证毕.接下来说明如何将判定Gq的语义问题转化为q到G的映射这一语法问题,即Gq当且仅当qG成立.证明.对于任一G∈ccfk(定义14(查询到完全图的映射).给定模糊查询q和完全图G,如果存在一个从q中的项到G的结点的映射μ:Terms(q)→Nodes(G),使得(i)对于每个个体名o∈Inds(q),μ(o)=o;(ii)对于每个模糊概念原子项C(x)n∈q,(iii)对于每个模糊角色原子项R(x,y)n∈q,〈C,,m〉∈(μ(x)),其中mn;μ(x)是μ(y)的R-,m邻结点,其中mn,则称q可以映射到G中,记作qG.o3,μ(a)=a,可以构造一个q1到G1的映射μ.例5.通过设定μ(x)=o1,μ(y)=o2,μ(z)=引理3.如果qG成立,则Gq.证明.因为qG,所以存在映射μ:Terms(q)→Nodes(G)满足定义14中条件(i)(ii)(iii).任取G的一个模型=(Δ,·),满足定义12中的条件(i)(ii)(iii).通过μ构建映射π:Terms(q)→Δ,使得对于每个项x∈Terms(q),π(x)=(μ(x))成立,则对于每个模糊概念原子项C(x)n∈q,C(π(x))=C(μ(x))mn满足;模糊角色原子项的情况类似.图5给出了模糊查询蕴涵的完整算法Query-Entail(,q),其中函数AppRules(G)表示将表1中的扩充规则应用于G,返回k-完备无冲突完全图的集合ccfk(引理3说明了算法的可靠性.引理3的逆命题,即算法的完备性将在4.4节证明.事实上,只要知识库的完全图G扩充得足够长(或者说深度参数k足够大),那么只需构建的一个模型,即利用G导出的规范模型(canonicalmodel)G,就足以通过G构造一个从q到G的映射μ.4.4模糊推演表与规范模型利用G构建的规范模型G分两步:首先利用G构造一个模糊推演表(tableau),然后再从该推演表导出规范模型G.G的解释域是由一组(可能无限的)路径组成,其原因在于:如果G中包含被阻塞Page11结点,则的模型可能是无限的,而规范模型G是从完全的无冲突的完全图G构建的,算法的终止性(见第5节)决定了G是一种有限表示.这就要求完全图中某些结点可以表示解释域中多个元素,因此选择路径表示以区分同一结点所表示的不同元素.定义15(模糊推演表[7]).给定知识库=〈,,〉,犚为出现在中所有角色的集合,犐为出现在中所有个体的集合,的模糊表定义为一个四元组T=〈犛,,,!〉,使得犛为一个非空集合,:犛×sub()→[0,1],将犛中的一个元素和sub()中的一个概念映射为这个元素作为该概念的实例的隶属度.:犛×犛×犚→[0,1],将一对元素和犚中的一个角色映射为这对元素作为该角色的实例的隶属度.以及n∈[0,1],T还满足以下性质:!:犐→犛,将犐中的个体映射为犛中的元素.而且,对于所有s、t∈犛,C、D∈sub(),R∈犚(1)对于所有s∈犛,(s,⊥)=0,(s,⊥)=1;(2)如果(s,CD)n,则(s,C)n且(3)如果(s,CD)n,则(s,C)n或(4)如果(s,R.C)n,则(〈s,t〉,R)1-n(5)如果(s,R.C)n,则存在t∈犛,使得(6)如果(s,R.C)n,Trans(R),则(7)如果(s,S.C)n,Trans(R)且R(8)如果(s,pS.C)n,则#{t∈犛|(〈s,(9)如果(s,pS.C)n,则#{t∈犛|(〈s,t〉,(10)如果(〈s,t〉,R)n,R(11)(〈s,t〉,R)n当且仅当(〈t,s〉,(12)如果CD∈,则对于所有s∈犛,n∈N∪(13)如果C(o)n∈,则(!(o),C)n;(14)如果R(o,o)n∈,则(〈!(o),(s,D)n;(s,D)n;或(t,C)n;(〈s,t〉,R)n且(t,C)n;(〈s,t〉,R)1-n或(t,R.C)n;则(〈s,t〉,R)1-n或(t,R.C)n;t〉,R)n,(t,C)n}p;R)1-n+,(t,C)1-n+}p;n;Inv(R))n;Nq,(s,C)1-n+或(s,D)n;!(o)〉,R)n,其中RR;(15)如果oo∈,则!(o)≠!(o);(16)如果(s,pS.C)n,(〈s,t〉,R)1-n+,则(t,C)n或(t,C)1-n+;(17)如果(s,Ao)n,则(s,Ao)1,其中Ao∈{{o},{o}};(18)如果(s,Ao)1,(t,Ao)1,则s=t,其中Ao∈{{o},{o}}.利用G构造模糊推演表的过程如下:犛中的一个元素对应于G中的一条路径.可以将G中的被阻塞结点的前驱与阻塞结点之间的路径视为环,以定义无限路径.更精确地说,路径p是G中的一个结点对序列,即p=[v0/v0,…,vn/vn].此外,定义Tail(p)··=vn,Tail(p)··=vn,用[p|vn+1/vn+1]来表示路径[v0/v0,…,vn/vn,vn+1/vn+1],并将[[p|vn+1/vn+1]|vn+2/vn+2]简记为[p|vn+1/vn+1,vn+2/vn+2].G的路径集合Paths(G)递归定义如下:(i)如果v为G中的个体结点,则[v/v]∈Paths(G);(ii)给定p∈Paths(G),结点w∈Nodes(G).如果w是Tail(p)的R-后继且未被k-阻塞,则[p|w/w]∈Paths(G);如果存在w∈Nodes(G)是Tail(p)的R-后继,且w直接k-阻塞w,则[p|w/w]∈Paths(G).定义16(导出的模糊推演表).由G导出的模糊推演表TG=〈犛,,,!〉为犛=Paths(G),(p,C)sup{ni|〈C,,ni〉∈(Tail(p))},(〈p,[p|w/w]〉,R)sup{ni|〈R,,ni〉∈(〈Tail(p),w〉)},(〈[p|w/w],p〉,R)sup{ni|〈Inv(R),,ni〉∈(〈Tail(p),w〉)},(〈[v,v],[w/w]〉,R)sup{ni|〈R,,ni〉∈(〈v,w〉)},其中v,w为个体结点,v是w的R-邻结点,R代表R或Inv(R),!(xi)=利用的模糊推演表T,可以得到T的规范模型T,然后我们将证明T也是的模型.定义17(模糊推演表的规范模型).设T=〈犛,,,!〉为的一个模糊推演表,T的规范模型T=(ΔT,·T)定义如下:Page12ΔT=犛;对于犐中的所有个体名o,oT=!(o);对于所有s∈犛以及所有概念名A,AT(s)=(s,A);对于所有〈s,t〉∈犛×犛,RT(s,t)=(s,t),R+烄烅max烆SR,S≠R,其中R(s,t)=(〈s,t〉,R),而R+的sup-min传递闭包.引理4.设T为-知识库=〈,,〉的模糊推演表,T的规范模型T也是的模型.证明.定义15中的属性12保证了T是的模型,具体证明见文献[19]中的命题3,属性1~11和13~15保证了T是和的模型,具体证明见文献[7]中的引理5.2和6.5、文献[23]中的引理4和文献[24]中的引理4.4.例6.由定义16和定义17,可以从图4中的完全图G1得到规范模型G.G的解释域是从o到其它结点(包括结点a和每个oi)的路径的无限集合,每条路径由G1中的一系列结点对构成,通过这种路径可以表示出由被阻塞结点引入的环.若一个结点未被阻塞,例如o1,则向路径中增加结点对o1/o1.2-可阻塞图G2o3直接阻塞,若路径经过o6,则向路径中增加结点对o3/o6,并返回到o3的后继.据此,可以得到下面的无限路径集合:p0=[o/o],p1=[a/a],p2=[o/o,o1/o1],p3=[o/o,o1/o1,o2/o2],p4=[o/o,o1/o1,o2/o2,o3/o3],p5=[o/o,o1/o1,o2/o2,o3/o3,o4/o4],p6=[o/o,o1/o1,o2/o2,o3/o3,o4/o4,o5/o5],p7=[o/o,o1/o1,o2/o2,o3/o3,o4/o4,o5/o5,o3/o6],p8=[o/o,o1/o1,o2/o2,o3/o3,o4/o4,o5/o5,o3/o6,p9=[o/o,o1/o1,o2/o2,o3/o3,o4/o4,o5/o5,o3/o6,p10=[o/o,o1/o1,o2/o2,o3/o3,o4/o4,o5/o5,o3/o6,…这一路径的无限集合构成解释域Δ名A,如果(A,,n)出现在pi的最后一个结点的标o4/o4],o4/o4,o5/o5],签中,则A后一个结点是pi的最后一个结点的R-,n后继,则R(pi,pj)n.综上所述,可以从每个G∈ccfk(推演表TG,并通过TG构建一个的G规范模型G.引理5.每个完全图G∈ccfk(一个规范模型G,使得G.其中k1.证明.文献[7]中的引理5.9和6.10、文献[23]中的引理4以及文献[19]中的命题5证明了定义16中由G∈ccfk(定义15中的属性1~15.根据引理4,通过TG构建的规范模型G也是的模型.下面将说明如何通过查询q中的项到G的映射构造一个q到G的映射.定义18(匹配图).给定完全图G∈ccfk(k0以及模糊查询q,且规范模型Gq.π为定义4中定义的q到G的映射,则匹配图Gπ定义为(i)顶点集合V(Gπ)={π(x)∈Δ(ii)弧的集合E(Gπ)={〈π(x),π(y)〉∈Δ|R(x,y)n∈q}.Δ顶点集合V(Gπ)可以划分为Vr(Gπ)和Vn(Gπ),即V(Gπ)=Vr(Gπ)∪Vn(Gπ),Vr(Gπ)∩Vn(Gπ)=,其中Vr(Gπ)={[v/v]|v为G中的个体结点}.定义19(最大q距离).对于任意x,y∈Terms(q),若π(x)、π(y)∈V(Gπ),则用dπ(x,y)表示匹配图Gπ中π(x)和π(y)之间不包含Vr(Gπ)中顶点的最短路径的长度.如果π(x)和π(y)分别位于两个不同的连通子图中,则dπ(x,y)=-1.匹配图Gπ中最大q距离定义为dπ例7.通过设定π(x)=p6,π(y)=p7,π(z)=p8,π(a)=p1,可以构造一个q1到Δ射图Gπ包含顶点p1,p6,p7和p8,其中Vr(Gπ)={p1},Vn(Gπ)={p6,p7,p8},E(Gπ)={(p6,p7),(p7,p8),(p8,p1)}.而且,由dπ(p8,p1)=0,dπ(p6,p7)=dπ(p7,p8)=1,dπ(p6,p8)=dπ(p6,p1)=2,可知dπq1=2.因为本文只考虑由简单角色R构成的模糊角色原子项R(x,y)n,所以dπ(x,y)=1,dπ中nq表示模糊查询q中模糊角色原子项的数目.nq可以作为阻塞条件中k取值的非严格下限,即扩充完全图时,令k-阻塞条件中的k大于或等于nq即可.引理6.给定完全图G∈ccfk(Page13为G导出的模糊推演表的规范模型.如果Gq,则qG成立.证明.根据定义4,因为Gq,所以存在映射π:Terms(q)→ΔC(x)n∈q,C子项R(x,y)n∈q,R接下来利用映射π来构造映射μ:Terms(q)→Nodes(G).为构造映射μ,需要用到匹配图Gπ的子图G,即去除了Gπ中形式为[a/a]的顶点(以及进入和离开该顶点的弧)得到的.图G由一组树形子图G1,…,Gm组成.我们定义每个Gi中被k-阻塞的顶点集合Blocked(Gi),其中每个结点p∈Blocked(Gi)都满足Tail(p)≠Tail(p),对于p在Gi中的每个祖先p,都有Tail(p)=Tail(p).我们还用AfterBlocked(Gi)表示Blocked(Gi)中所有顶点的后代的集合.因为G是k-阻塞的,又根据Paths(G)的定义,如果路径p中包含v/v和w/w两个结点对,且v≠v,w≠w,则这两个结点之间的距离一定大于k.此外,如果路径p以未被阻塞的结点v/v开始,又包含结点w/w,且w≠w,则v/v与w/w之间的距离也一定大于k.下面首先证明Gi的两条性质:(1)如果存在某个Gi,使得π(x)∈After-Blocked(Gi),则Tail(π(x))=Tail(π(x)).若π(x)∈AfterBlocked(Gi),则存在y∈Vars(q),使得Tail(π(y))≠Tail(π(y)),且π(x)是π(y)的后代.也就是说,π(x)的形式为[p|v0/v0,…,vm/vm],且Tail(p)≠Tail(p).假如vm≠vm,则路径π(x)的长度一定大于k.因而,dπ(x,y)>nq,导致矛盾.(2)如果存在某个Gi,使得π(x)∈V(Gi),且AfterBlocked(Gi)≠,xAfterBlocked(Gi),则Tail(π(x))被ψ(Tail(π(x))树阻塞.若AfterBlocked(Gi)≠,则存在y∈Terms(q),使得π(y)∈V(Gi),且π(y)具有一个真子路径p,使得Tail(p)=Tail(p).因为π(x)和π(y)位于同一子图Gi中,则π(x)是π(y)的祖先,或者存在z∈Terms(q),使得π(z)是π(x)和π(y)在V(Gi)中的共同祖先.前一种情况,若Tail(π(x))未被树阻塞,则有dπ(x,y)>knq,导致矛盾.后一种情况,若Tail(π(x))未被树阻塞,则Tail(π(z))也不会被树阻塞,dπ(z,y)>nnq,导致矛盾.可以构造映射μ:Terms(q)→Nodes(G)如下:Tail(π(a))=a;对于Inds(q)中的每个个体a,μ(a)=对于Vars(q)中的每个变量x,π(x)∈V(Gi),(1)若AfterBlocked(Gi)=,则(2)若AfterBlocked(Gi)≠,则μ(x)={Tail(π(x)),若π(x)∈AfterBlocked(Gi)ψ(Tail(π(x))),接着证明μ具有定义14中的属性(i)(ii)(iii):属性(i)可由上述μ的构造定义得到;属性(ii):因为Δπ(x)和π(y)为G中的结点,对应于G中的路径.根据定义15中性质13,对所有C(x)n∈q,(π(x),C)n成立,则〈C,,n〉∈(Tail(π(x)))或(ψ(Tail(π(x)))),即〈C,,n〉∈(μ(x));属性(iii):根据定义15中的性质14,对所有R(x,y)n∈q,(〈π(x),π(y)〉,R)n成立,其中R,则或者R(1)Tail(π(y))是Tail(π(x))的R,n-后继,或者(2)Tail(π(x))是Tail(π(y))的Inv(R),n-后继.情况(1):对于每个连通子图Gi,若After-Blocked(Gi)=,则对于每个使得π(x)∈Gi的项x,Tail(π(x))=Tail(π(x))(事实上,π(x)不包含任何形式为v/v的结点对,其中v≠v).因为Tail(π(y))是Tail(π(x))的R,n-后继,所以μ(y)=Tail(π(y))是μ(x)=Tail(π(x))=Tail(π(x))的R,n-后继.若AfterBlocked(Gi)≠,则分几种情况讨论:(a)当π(x),π(y)∈AfterBlocked(Gi)时,μ(x)=Tail(π(x)),μ(y)=Tail(π(y)).根据性质(1),Tail(π(x))=Tail(π(x)).如果Tail(π(y))是Tail(π(x))的R,n-后继,则μ(y)=Tail(π(y))是μ(x)=Tail(π(x))=Tail(π(x))的R,n-后继.(b)当π(x),π(y)AfterBlocked(Gi)时,Tail(π(x))=Tail(π(x)).否则,将有π(y)∈AfterBlocked(Gi).由性质(2)可知,Tail(π(x))被ψ(Tail(π(x)))树阻塞,Tail(π(y))被ψ(Tail(π(y)))树阻塞.因而,如果Tail(π(y))是Tail(π(x))=Tail(π(x))的R,n-后继,则μ(y)=ψ(Tail(π(y)))是μ(x)=ψ(Tail(π(x)))的R,n-后继.(c)当π(x)AfterBlocked(Gi),π(y)∈Page14AfterBlocked(Gi)时,Tail(π(x))≠Tail(π(x)),而Tail(π(x))=ψ(Tail(π(x)),即π(x)终止于一个被阻塞的叶结点.如果Tail(π(y))是Tail(π(x))的R,n-后继,则μ(y)=Tail(π(y))是μ(x)=ψ(Tail(π(x))的R,n-后继.情况(2)的证明类似.由属性(i)(ii)(iii)的证明可知映射μ满足其定义中的属性,qG成立.例8.Gπ的强连通子图G1的顶点集合为例7中Vn(Gπ)={p6,p7,p8},弧的集合为E(Gπ)={(p6,p7),(p7,p8),(p8,p1)}\{(p8,p1)}.而且,Blocked(G1)={p6},AfterBlocked(G1)={p7,p8}.通过设定μ(x)=ψ(Tail(π(x)))=ψ(Tail(p6))=o3,μ(y)=Tail(π(y))=Tail(p7)=o4,μ(z)=Tail(π(z))=Tail(p8)=o5,可以从映射π得到映射μ.根据定义14,qG.定理3.令knq,则q当且仅当对于每个G∈ccfk(证明.根据定理2,对于任一G∈ccfk(如果q,则Gq.特别是,由G的模糊推演表导出的规范模型Gq.根据引理6,qG成立.根据引理3,如果qG成立,则Gq.根据定理2,q.5可终止性与复杂度分析下面将分别讨论模糊查询蕴涵的联合复杂度和数据复杂度.标准推理任务的算法复杂度,例如概念和知识库的可满足性检查,是以知识库的规模作为输入来度量的,称为联合复杂度.对于查询蕴涵问题,还需要将查询的大小考虑在内,也就是把知识库和查询都作为输入.分析问题的数据复杂度时,只把ABox作为唯一的输入,也就是说TBox、RBox和查询的大小是固定的.当TBox、RBox和查询相对于ABox来说很小时,数据复杂度是评价算法性能的更有效方式,因为它可以给出当ABox中断言数量增加时算法的执行效率.现在假定为f-、f-或f-知识库,f-的情况在本节稍后讨论.给定=〈,,〉和模糊合取查询q,‖,q‖表示编码模糊知识库和模糊查询q的字符串的大小;||表示中模糊断言和不等价断言数目的总和;||表示中角色包含公理的数目;||表示中模糊概念包含公理的数目;犮表示sub()的势;犿表示概念pR.C和pR.C中出现的p的最大值;狉表示犚的势;犱=|N|+|Nq|,其中|N|和|Nq|分别表示和q中不同隶属度的数目.如果采用一进制编码概念pR.C和pR.C中的数字p和隶属度,则犿是关于‖,q‖线性大小的;而当采用二进制编码时,犿是关于‖,q‖单指数大小的.当q和中TBox和RBox的大小固定时,犿关于||是常量.犮、犱和狉是关于‖,q‖线性大小的,而关于||是常量.犐关于‖,q‖和||都是常量.引理7.知识库的一个完全图中非同态的可阻塞k-图的数目最多为Tk=2p(犮,犱,狉,犿)k+1,其中p(犮,犱,狉,犿)为关于犮、犱、狉、犿的多项式.证明.完全图中每个可阻塞k-图的结点v的任一后继都有可能作为可阻塞(k-1)-图的结点.可阻塞k-图中只有个体结点可能会相互连接,而生成结点至多有一个前驱,因此不考虑个体结点间连接的情况下,可以把可阻塞k-图Gkv看作是以v为根结点的树.当结点v的标签中存在R.C或pS.C这样的概念时,会触发-和-等生成规则,并向完全图G中增加新结点.这类概念的数量的上限为犮,也就是说每条生成规则在某一结点上至多可以应用犮次.知识库中至多有狉个角色,对于每个角色R,每条生成规则至多产生犿个R,n-后继.如果通过+-或+-规则,引入结点v与其它结点如v的等价关系v≈v,则不会对v重复使用生成规则.对于每个角色R,最多会在一个结点中出现犮犿个R,n-后继,最多可能有(Tk-1)犮犿个以v的某个后继为根的(k-1)-图,所有以v的后继为根的(k-1)-图共犮犿(Tk-1)犮犿个.以上是每个角色,则对于所有角色,共(犮犿(Tk-1)犮犿)狉个.在所有扩充规则中,只有NN-规则向结点中增加新的枚举概念标签,例如〈{xi},,1〉,而对于f-、f-和f-知识库,NN-规则并不适用.因此,对完全图中任一结点v,其标签(v)sub()×{}×(N∪Nq),而完全图中最多有2犮犱种不同的结点标签.同样,因为(〈x,y〉)犚×{}×(N∪Nq),所以完全图中最多有2狉犱种不同的边标签.综上所述,完全图中可阻塞k-图的根结点最多有2犮犱种,每个结点最多有犮犿个后继,从该结点到其每个后继的边的标签最多有2狉犱种,每个后继都Page15可能作为一个(k-1)-图的根结点,则的一个完全图中非同态k-图数目的上限为令y=犮犿狉,x=犮+狉y,则上式简化为Tk=2x犱1+y(Tk-1)y=2x犱1+y(2x犱1+y(Tk-2)y)y=…(2x犱1+y)1+y+…+yk-1(T0)yk(2x犱1+yT0)yk.因为T0=2犮犱,对于y2(可证当y=1时也成立),Tk(2犮+犮犿狉2犱1+犮犿狉2犮)(犮犿狉)k(22犮+犮犿狉2+(1+犮犿狉)犱)(犮犿狉)k(22犮2+犮2犿2狉3+犮2犿2狉2犱)k+1=2p(犮,犱,狉,犿)k+1.其中p(犮,犱,狉,犿)=2犮2+犮2犿2狉3+犮2犿2狉2犱.证毕.引理8.完全图G∈ccfk(上限为O(|犐|(犮犿狉)d+1),其中d=(Tk+1)k.证明.(i)G的出度上限为犮犿狉.知识库中角色的数目为狉,对于每个角色R,最多会在一个结点中出现犮犿个R,n-后继.因此,G的出度上限为犮犿狉.(ii)G的深度上限d=(Tk+1)k.由于最多有Tk个非同态可阻塞k-图,如果G中存在一条从v到v,长度大于(Tk+1)k的路径,则意味着v出现在连续的Tk+1个无重叠的k-图之后,而其中一个k-图将被阻塞,而不会生成结点v.矛盾.(iii)G中一棵以个体结点为根的树中结点数的上限为O((犮犿狉)d+1)(iv)G中结点数的上限为O(|犐|(犮犿狉)d+1)引理8并不适用于f-知识库,、、3种构件同时出现,会触发NN-规则,从而引入新的个体结点以及解释域中的元素.对新个体结点应用扩充规则,又会生成新的可阻塞k-图,它们可能会与现有的可阻塞k-图不同态,并导致算法不可终止.推论1.如果k是关于‖,q‖线性大小的,则G中结点数的上限是关于‖,q‖三指数大小的;如果q和中TBox和RBox的大小固定,并且k为常量的情况下,G中结点数的上限是关于||线性大小的.定理4(终止性).如果k是关于‖,q‖线性大小的,则将G扩充为完全的无冲突的完全图G∈ccfk(在q、和的大小固定,并且k为常量的情况下,扩充过程在关于||的多项式时间内终止.证明.根据引理8,设G中结点数的最大值M=O(|犐|(犮犿狉)d+1),其中d=(Tk+1)k.下面分别讨论将G扩充为G∈ccfk(规则的次数的上限:(1)对于每个结点,-和-规则至多应用O(犮)次,-,-,+-,+-,-规则至多应用O(犮犿狉)次,则将G扩充为至多有M个结点的G来说,最多需要应用上述规则O(M犮犿狉)次.(2)r应用于G中的根结点,至多应用(3)对于每个结点,-规则应用O(犱||)次,总综上所述,应用规则的总次数为O(M犮犿狉+O(|犐|)次.次数为O(M犱|).|犐|+M犱|).定理5.给定知识库和模糊布尔合取查询q,q中角色均为简单角色,判定q的联合复杂度为CO3NEXPTIME,数据复杂度为CONP.证明.如果/q,则存在完全图G∈ccfk(使得qG不成立.由于非确定性扩充规则的存在,并根据定理4,算法将在关于‖,q‖的非确定性三指数时间内构建完全图G.同时,根据推论1,G中结点数M为关于‖,q‖的三指数大小,对于含有n个变量的模糊查询q,在G中检查映射存在与否比较需要Mn次,是关于‖,q‖的三指数大小的.因此,判定/q的算法联合复杂度为3NEXPTIME,而判定q的算法联合复杂度为CO3NEXPTIME.对于数据复杂度,构建完全图G在关于||的PTIME内完成.G中结点数M为关于||的线性大小,模糊查询q的大小固定,q中变量个数n为常量,在G中检查映射存在与否的比较次数Mn是关于||的多项式大小.因此,判定/q的算法数据复杂度为NP,而判定q的算法数据复杂度为CONP.6相关工作描述逻辑知识库合取查询的研究始于20世纪90年代末,其开创性工作是Calvanese等人[25]提出的描述逻辑reg的首个合取查询算法.随后,Levy和Rousset[26]提出结合DL知识库和规则的框架CARIN,给出判定的合取查询蕴涵问题的决策步骤.Page16近来,易处理的(tractable)①描述逻辑的查询蕴涵和查询应答问题得到了广泛研究.Calvanese等人[27]提出了DL-Lite,其标准推理问题的复杂度为多项式时间,其查询蕴涵问题的数据复杂度为LogSpace.另一个多项式时间推理复杂度的DL是.已证明对于及其角色层次扩展(),合取查询的并(UnionofConjunctiveQueries,UCQs)蕴涵问题的联合复杂度为NP-complete[28],而的UCQ蕴涵问题的数据复杂度为PTIME-complete[15,29].对于极富表达能力DL合取查询算法的研究也取得了很大进展.一方面,在文献[26]的基础上,Ortiz等人[21]给出了表达能力更强的整个一族DL合取查询蕴涵问题的决策步骤,证明了当查询中只允许简单角色时,的所有子逻辑合取查询蕴涵问题的coNP-complete数据复杂度.另一方面,Glimm等人[30-31]提出了判定和知识库上带传递角色合取查询蕴涵问题的决策步骤,证明了算法的coNP数据复杂度上限.语义Web领域模糊信息的表示和查询同样受到了广泛关注.Straccia[32]提出了DL-Lite的模糊扩展f-DL-Lite,并给出了f-DL-Lite本体上的top-k合取查询应答算法.文献[32]使用了与DL-Lite合取查询相同的查询语言(唯一的差别在于引入了权重),其主要缺点在于该查询语言不允许为查询原子项指定阈值.例如“距会场很近(隶属度至少0.8)并且提供便宜(隶属度至少0.9)房间的宾馆”这样的查询就无法用该查询语言来表达.为此,Lukasiewicz和Straccia[33]提出了允许阈值的模糊查询语言,给出了在模糊描述逻辑程序上的top-k检索算法.Mailis等人[18]给出了在CARIN系统模糊扩展上应答带阈值合取查询的决策步骤.Pan等人[34]实现了首个模糊本体上可扩展的查询引擎ONTOSEARCH2,并进一步扩展了文献[18,33]的查询语言,使之允许聚合查询.Cheng等给出了允许否定角色原子项的f-上模糊合取查询蕴涵的判定算法.应当指出的是,上述工作都是针对表达能力较弱的轻量级模糊DL知识库(或模糊本体),所允许的语言构件不足以有效地表达复杂的领域知识.另一方面,现有的工作,如文献[18,36-37],并未详细分析语言构件对算法复杂度的影响.本文所提出的针对极富表达能力的模糊描述逻辑f-一族的模糊合取查询蕴涵算法及其复杂度结果,弥补了这方面研究的不足,并为模糊描述逻辑知识库查询引擎的设计和实现提供了理论指导.7结论模糊描述逻辑作为一种本体表示语言,在语义Web领域的重要性已经得到广泛的重视,模糊本体的查询技术极大地增强了语义Web中基于推理的数据访问能力.此外,随着大规模领域本体的发展,模糊本体的查询技术也被广泛地应用于多个领域,包括数据库访问②、多媒体信息检索[38]、人力资源管理[39]等.现有的模糊描述逻辑推理机,或者不能处理复杂类型的查询(主要是合取查询),如FiRE、fuzzyDL等,或者只适用于表达能力较弱的逻辑,如ONTOSEARCH2等.本文提出了针对极富表达能力的f-一族的判定模糊合取查询蕴涵的决策步骤,证明了算法的可靠性、完备性和可终止性,分析了语言构件对复杂度的影响,证明了数据复杂度的CONP上限和联合复杂度的CO3NEXPTIME上限.我们的工作针对表达能力更强的模糊DL知识库,因而适用于更加广泛的应用领域的建模和查询检索的需要.今后将进一步研究该算法的优化技术,并设计实现相应的系统以验证算法的有效性.下一步还将结合具体领域知识库的特点,开发出相应的模糊本体查询系统.同时,还将研究包括具体域[40]、自定义数据类型[41]等其它构件对算法的影响,并相应扩展现有的算法.为了给用户提供更全面的查询接口,算法扩展还将涉及包括对聚合查询[34]等表达能力更强的查询语言.此外,本文算法并不适用于模糊角色查询原子项中出现传递角色的情况,原因在于所采用的阻塞条件依赖于查询的最大路径,而传递角色可能会令路径无限延伸.因此,下一步的研究重点将是如何处理查询原子项中允许知识库中任意角色的情况.致谢向对本文提出宝贵意见的评审专家表示衷心的感谢!①②Page17
