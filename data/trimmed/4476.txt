Page1具有依赖关系的周期任务实时调度方法黄姝娟1),2)朱怡安1)李兵哲1)陆伟2)1)(西北工业大学计算机学院西安710072)2)(西北工业大学软件与微电子学院西安710072)摘要随着多核技术在嵌入式领域的快速发展,越来越多的功能被集成在同一个平台上,任务之间的关系越来越复杂.而当前大多数的实时周期任务的调度模型都是不考虑任务之间关系的相互独立的任务模型.文中则针对具有依赖关系的周期任务,提出了一种基于ST(Simple-Tree)的实时周期任务调度模型,通过该模型来维护任务之间的依赖关系.此外,为了有效地提高系统利用率以及降低死限丢失率,文中还提出了可延迟时间越短越优先的调度方法并和RM算法、EDF算法进行仿真实验比较,结果表明该方法具有较高的核利用率和较低的死限丢失率.关键词多核;实时调度;周期任务;调度模型;调度算法1引言随着多核技术在嵌入式领域的快速发展,围绕Page2应的依赖关系,那么针对这种具有依赖关系的实时任务如何进行调度就成为了研究的热点问题[6].当前片上多处理器任务调度方法中主要考虑两种模型[7].一种是相互独立的实时周期任务模型.其中典型的是Liu和Layland[8]提出的,其周期任务模型是很多实时任务模型的基础,相应的调度算法有RM(Rate-Monotonous)算法[9],EDF(EarliestDeadlineFirst)算法[2]等;另一种则是考虑任务之间存在约束关系的任务图模型.该模型中的任务之间有很强的制约关系,但却不考虑任务实时性和周期性问题[10-11].本文则针对具有依赖关系的周期性任务提出一种能体现部分依赖关系的ST任务树模型,并针对该任务树模型特征提出基于可延迟时间越短越优先(ProbablyLagTimeShortestFirst,PLTSF)的调度方法.该方法在考虑任务的实时性以及任务之间的依赖关系的基础上进行相应的优先关系定义,并对可并行执行的工作分别采用了PLTSF、RM以及EDF算法.其实验结果表明PLTSF算法在系统整体利用率以及死限丢失率方面都比RM、EDF算法先进.本文第2节介绍ST任务树模型;第3节讲述ST任务树模型中各种优先关系定义以及可延迟时间、延迟界限的计算方法以及处理器预分配算法;第4节讲述仿真实验的方法和性能评测的指标以及实验结果分析;第5节是总结.2ST(Simple-Tree)模型2.1相关定义定义1.ST模型的树型数据结构Tree=(D,R)满足树的基本特征即在任意一棵树中:(1)有且仅有一个特定的称为根的节点;(2)当n>1时,其余节点可分为n(n>0)个互不相交的有限集T1,T2,…,Tn,其中每一个集合本身又是一棵树,并且称为根的子树.定义2.对于任何一棵树而言,每个节点都有层次,根为第1层,根的孩子为第2层.若某个节点在第K层,其孩子就在第K+1层,树的深度为树中节点的最大层次.树T深度为H,用layer(T)=H表示;节点Pi层次为K,用layer(Pi)=K来表示.定义3.对于任意一棵树T,除了叶子节点外,所有节点都只有一个孩子节点的树称为单行树ST(SimpleTree),单行树是一棵每个父节点只有一个孩子节点的树.如图1所示为一棵深度为4的单行树,树中第K层的节点数用Number(K)来表示.ST具有如下特征:ST每层只有一个节点即Number(Ti)=layer(Ti).节点个数就是层数即K=Number(Ti).节点之间都是具有一定的顺序关系的.定义4.ST任务模型中的节点都是暗含死限的实时周期任务节点,即该任务节点为一个二元组{ei,pi},其中ei表示该任务一个最坏执行时间,pi表示该周期任务的周期或死限.以下所提到的ST都是此类性质的树.另外,本文假设ST任务模型中树与树之间都是相互独立的.2.2ST模型考虑一个任务系统Γ的调度集Γ={ST1,ST2,…,STn}为n个相互独立的ST被调度在m2的处理器核上运行.其中STi(1in)为一棵深度为h的任务树,当h=1时,该树就是一个独立的实时周期任务节点.树中每个节点我们称其为该树根节点的子任务即STi={T1赖关系的任务,其中T1T2i,…,Thi为T1为该STi的任务.而其中任何一个任务Tkn,1kh)都是周期任务节点即Tk于其中任何一个任务Tk任务会被周期性地执行和释放,对于其每次执行我们称为一次工作(job).本文假设该工作不可以再划分为更小的可并行执行的粒度.我们把Tk执行记为Tkrki,j,绝对死限为dki,j.由于Tkrki,j+pkSTi(1in)树,其利用率记为USTi=∑h系统Γ的总利用率为Usum=∑ni.任务TkPage3对于同一棵ST而言,由于任务之间有相互依赖关系,那么在执行过程中必然有执行顺序,例如Tk+1i,j一定在Tki,j+1也必须在TkTk此,为了区分它们,将同一周期子任务的上次工作i,j-1称为TkTk工作后继(job),并将与其有依赖关系的上层工作Tk-1i,j称为Tki,j依赖(depend)后继.Tk3可延迟时间以及优先关系确定3.1可延迟时间确定定义5.如果一个工作Tk开始却没有在时刻t完成,那么该时刻t称为子任i,j的延用时刻,该工作称为时刻t未完成工作.务Tk如果t为该工作的绝对死限,则称该工作死限未满足或死限丢失.定义6.在调度算法S下,定义一个时间分配函数为rs(x),该函数表示在一个很小的单位时间间隔Δt内,一个工作x如果被执行,该函数值为1,否则函数值为0.定义7.一个工作Tk内通过调度算法S所能给分配的时间值定义为Runtime(Tk推论1.在调度算法S下,对于一棵STi树中任何一个暗含死限的周期任务Tk有任何外界干扰且STi的根节点T1的情况下,该周期任务的任何一个工作Tk可被调度的最早发布时刻记为Oki,j{=max(j-1)×pnOk(j-1)×pk}i.证明.第1个任务T1以发布时刻为O1由于第2个任务在第1个任务完成之后才能开始执行.因此,第2个任务T2i的第j个job的最早可以发布的时刻为i,j=max{O1O2同样第3个任务在第2个任务的完成之后才能执行,第3个任务T3时刻为以此类推,第k个任务Tk发布的时刻为i,j=max{Ok-1Ok{(=max(j-1)×p1(j-1)×p2i+∑k-1(j-1)×pk-1{=max(j-1)×pn(j-1)×pk}i定理1.在调度算法S下,由ST模型可知第k层节点Tk{T1i,T2i,…,Tk-1i}.在忽略其他额外开销的情况下,从0时刻开始调度根任务,则判断其能否与其前驱结点在同一个处理器上可被调度的必要条件是imax{pnpk证明.如果算法S能成功调度,那么该节点的任何一个工作Tk它的最早开始发布时刻一定小于最迟开始执行时刻i,也就是说如果它的最早开始发布时刻大于dki,j-ek最迟开始执行时刻,则它就不可能在其绝对死限dki,j之前完成,那么必定存在丢失死限情况.因此必须有Oki,j(dki,j-ekOk{[max(j-1)×pnn=1,2,3,…,k]-1,(j-1)×pk}i(dki,j-ek(dki,j-ek(j-1)×pk-1(j×pk(j-1)×pk-1也就是说,j×pk则有Page4j×pkj×pkpkj×pkpk…,j×pkpk因此,可以得到imaxj-1pk当j趋于无穷大时,即ilimj→maxj-1pkpk定理2.在调度算法S下,对于一个单行树模型STi从0时刻开始调度根任务,如果其中一个暗含死限的周期任务Tk在任意一个时间间隔[t1,t2)内,该任务应该被调度的时间值为i,j,t1,t2)=该周期任务的任何一个工作Tk该被执行的时间值为r(Tk0,t1dki,j∧t2<Ok烄i,t2-t1ekek(t2-t1)×uk烅dki,j-t1pkpk()i×eki1-dki,j-t2烆i,j为Tk其中Ok证明.根据推论1和定理1知,一个周期任务的一次作业Tk布时刻为dki,j-ek[t1,t2)的时间段r(Tk情况:第1种情况.如果t1dki,j或者t2<Oki,j的执行不在该范围内则r(TkTk第2种情况.如果t2-t1ekdki,j],那么调度执行时间为ek个时间间隔[t1,t2)内包含有该任务的周期个数为(t2-t1)pkii,j在该时间间隔[t1,t2)内被调度的时间值为Tkr(Tk第3种情况.如果Oki,j在该时间间隔[t1,t2)内被调度的时间值为么Tk第4种情况.如果t1<Oki,j在该时间间隔[t1,t2)内被成功调度的时间那么Tk值为r(Tk由此得证式(2)成立.假设周期任务Tki,j,t1,t2)=ek的第一个工作为Tk则j-1之前的工作(包括第j-1个工作)和h+1之后的工作(包括第h+1个工作)都分别在时间间隔[0,t1)和[t2,)之间执行,而没有在该时间间隔[t1,t2)内执行,所以它们在该时间间隔内被分配的时间值为0.由于第j个任务和第h个任务都是在该时间间隔内最早和最后执行,所以h-j-1个任务在该时间间隔内都执行完毕则执行的时间值i,第j个任务和第h个任务执行的时间值分别为ekpk()i×ek为dki,j-t1i,t1,t2)=∑jlhR(Tk=(h-j-1)ek=(h-j-1)ek=(h-j-1)ek=t2i-t1ekpki=(t2-t1)uk由此得证式(1)成立.Page5定义8.在任意一个时间间隔[t1,t2)内,一个i,j在调度算法S的调度下被推迟执行的时间工作Tk记为lag(Tkr(Tk其中Runtime(Tk间隔内,S调度算法下实际分配给该工作的时间片.若该工作在[t1,t2)时间间隔内没有被调度执行则Runtime(Tk定义9.一个子任务被推迟执行的时间记为lag(Tk=∑j1=R(Tk=(t2-t1)×uk任务Tk率uk定理3.如果某时刻t在调度算法S下是子i的延用时刻,那么Tki和最坏执行时间ek证明.由于t时刻为延用时刻,则一定存在Tk的某个工作Tk结束.考察时间间隔[0,t),假定Tk刻之前开始执行却没有在t时刻完成的工作为第j个工作,那么lag(Tk假设第j个工作释放时刻为rki,j,那么在该时刻之前即在时间段[0,rki,j)内,该子任务所有第i(i<j)个工作在t时刻之前都已经完成.由于从第j个工作开始才出现未完成的工作,因此rki,j<t.令λki,j为截至t时刻分配给工作Tkt,S)=λki,j,那么i,0,t,S)=∑hjlag(Tk=∑h>jlag(Tk=∑h>jr(Tkr(Tk因为第j个工作在t时刻还没有执行,那么在时间间隔[0,t)内不可能执行j以后的工作,所以当h>j时又有Runtime(Tk∑h>jr(Tk而r(Tk故lag(Tki,j,rki,j,t)ek由此得证并记录lagup(Tk定义10.一个工作在时刻t的可延迟时间(ProbablyLagTime,PLT)定义为该工作的绝对死限与该工作在[0,t)延迟时间的差值,结合定义9得到PLT(Tk=dki,j-(r(Tk其中dki,j为该工作的绝对死限.3.2优先级定义定义11.给定属于同一棵任务树的任何两个工作Tw果(1v<j)∧(w=k)或(v=j∧1w<k),则认为i,v顺序执行优先于TkTw(v≠j)∧(w≠k)情况下,如果两个工作的所有前驱都执行完毕则可以并行执行,具体执行顺序可根据不同的调度算法来执行.如果采用PLTSF算法调度并行执行工作则计算PLT(TwPLT(Tk则Twi,vTk定义12.对于不同的两棵单行树中的两个工u,v和Tku,vTk作Tw则Tw则比较两个子任务的延迟界限;若lagup(Twt,S)<lagup(Tk3.3处理器预分配算法首先将ST模型中的每个ST的任务节点按照定理1进行判断是否可以满足可被调度的必要条件.如果满足,则根据任务之间的依赖关系,在m个处理器核上进行分配,预分配算法如下:(1)将任务系统中n个ST树中的第一个工作放入到就绪队列中,根据定义11和定义12进行优先级判定,选择m个高优先级的工作分配到m个核上去执行.如果工作个数n小于m个,则选择n个核来执行.(2)当执行一个单位时间之后,将可并行的任务放到就绪队列中,计算当前核上每个任务的工作所执行的时间值λki,j,如果λki,j=ek执行完毕,则将其在所对应的任务扩展图和就绪队列中删除.如果λki,j<ek则更改该工作需要执行的时间片为ek工作重新放到就绪队列中等待和其他工作一起调度.(3)重新计算就绪队列中的每个任务的优先Page6级,选取m个任务分别分配到m个核上运行.如果工作数n小于m个核则选择n个核去执行.(4)重复步骤(2)~(3),直到所有的工作都能分配到核上去执行.4实验及结果分析本文的仿真实验平台是在4核Intelcore(TM)2QuadCPU2.66GHz内存为3.4GB的硬件环境下运行UbuntuLinux10.042.6.33-29实时内核,采用Codeblocks-v10.05编写仿真测试程序.根据文献[8]中的定理,在实验设计时,选择了处理器核数m与ST树总利用率Usum之间的3种不同的关系:Usum>m,Usum=m,Usum<m,针对随机输入的具有依赖关系的ST树进行了多组实验求得平均值,为了进行实验结果对比分析,定义如下的性能评价指标.定义13.为了在给定时间段内分析上述3种情况下不同调度算法的吞吐量,定义在相同的时间段内某调度算法所能够完成的工作总数为该调度算法的吞吐量.定义14.在算法分配过程中存在某时间段内核处于空闲状态,为了描述核利用情况,定义核总利用率为所有核执行工作的时间片数量与全部时间片数量的一个比值.该比值是ST模型对核利用情况的一个反映.该值越大说明该模型和调度方法对核的利用越充分.定义15.由于ST模型中的工作在调度过程中存在死限不满足的情况,为了考察死限不满足的严重程度,定义死限丢失率为所有丢失死限的工作数量与总工作数量的比值.根据以上的评价指标,对可并行执行的工作分别采用EDF算法、RM算法以及PLTSF算法进行调度,在500个时间片内对系统的吞吐量、核利用率以及丢失死限数进行了统计.图2展示了在3种情况下,每种情况随机输入10组数据得出的系统吞吐量的平均值.从图2中可以看出在负载量较大情况下即Usum>m时,PLTSF算法系统吞吐量明显大于其他两个算法,而在负载量较小的情况下对比不是很明显,因此本文仅针对在负载量较大的情况下,统计3种算法的核总利用率和死限丢失率的情况,分别如图3和表1所示.图3的结果显示出采用PLTSF算法的核利用率效果很好.从表1中可以看出任务的死限不满足率随着时间的持续而增长,但PLTSF算法下增长的趋势较低.分析原因发现由于EDF算法和RM算法都是针对独立任务模型而设置的,优先级是根据自身的参数(死限和利用率)来决定的,并没有考虑任务的实际执行情况,有时会导致一些后面的任务优先级高而没有办法执行的情况(因为前驱没有执行完毕).而PLTSF算法从一开始就考虑任务在实际执行过程中出现的延迟时间以及任务之间前后执行顺序问题,所以效果较好.这说明在ST模型下,PLTSF调度算法比EDF算法和RM算法更加合适.表1固定时间片内3个算法的死限丢失率统计固定时间片/msPLTSF算法EDF算法RM算法1000.001200.001800.002202000.010120.050320.042673000.023100.061600.071204000.032500.125000.132005000.032600.150000.200005结束语本文考虑具有依赖关系的实时周期任务在多核Page7处理器上的调度模型和调度算法,该模型不仅维持了任务之间的部分依赖关系,而且采用了基于可延迟时间越短越优先的调度策略,提高了系统利用率又降低了死限丢失的任务数量.文章首先描述了ST任务树的模型,接着定义了延迟时间、延迟界限以及优先关系,通过将模型图中的ST树进行扩展,根据相应的优先执行关系利用PLTSF调度算法将其映射到相应的核上去执行.仿真实验表明在ST模型下的PLTSF调度算法比RM、EDF算法在吞吐量、核利用率以及死限丢失率方面都较优.不足之处是本文假设ST树与树之间无任何关联关系且所选算法还是存在任务死限丢失情况.未来方向就是研究如何将ST树之间的关联性加入到调度考虑的范围当中以及如何将死限丢失率降到最低限度.
