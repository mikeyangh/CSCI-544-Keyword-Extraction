Page1一种基于Petri网的隐蔽信息流分析方法周从华鞠时光(江苏大学计算机科学与通信工程学院江苏镇江212013)摘要隐蔽信息流分析是开发高等级可信计算机系统必须面对的问题.以Petri网作为开发安全系统的形式化建模工具,给出Petri网中隐蔽信息流存在的判定条件.提出该条件成立的两种网结构,进而可以在语法层次上预先判断隐蔽信息流的存在性,并使由此类结构引起的隐蔽信息流在系统的设计阶段得以避免.开发了一种基于Petri网可达图的隐蔽信息流存在性判定算法,算法遵循无干扰方法的思想,但是避免了无干扰方法中等价状态的区分和展开定理的使用.另外,算法采用深度优先搜索的策略,避免了Petri网全局可达图的构造.对复杂的安全系统,分析了子系统的各种组合运算对隐蔽信息流存在性的影响,降低了大规模系统分析的复杂度.关键词隐蔽信息流;无干扰;Petri网;组合;展开定理1引言保护数据的机密性是安全系统最基本的安全需求.目前,安全计算机系统一般采用自主访问控制和Page2扩散方式通常被称为隐蔽信息流.隐蔽信息流标识[1]一直是开发多级安全系统必须解决的关键问题,同时也是一个难题.目前,已经诞生了一些隐蔽信息流标识方法,可以概括为两类:一类是基于程序结构的静态分析方法,如Kemmerer等人提出的共享资源矩阵法[2]、隐蔽流树法[3],Denning等人[4]提出的语法信息流方法,Tsai等人[5]提出的语义信息流方法,卿斯汉等人[6]提出的回溯方法等;另一类是基于程序动态行为的信息流分析法,如Gouen等人[7-8]提出的无干扰分析法.静态分析方法均是建立在对程序结构分析的基础上,在实际使用中可以发现一些隐蔽信息流,但是这些方法以手工处理为主,而且依赖于以往经验和个人能力,因此使用时不仅工作量大,而且非常容易出错.信息流分析法是一种形式化方法,其本质是一个用户不应当知道他不支配的其他任何用户的任何动作.事实上,不管是直接的信息泄露还是间接的信息泄露,都可以看成系统中信息的流动,因此信息流分析法被认为是一种有前景的方法[1].其主要缺点是使用时依赖“展开定理”[9].本文的一个研究点就是如何在基于状态转换系统的无干扰分析法中避免使用“展开定理”.自Gouen等人提出无干扰分析法以来,研究人员一般基于进程代数和事件系统的形式规约来研究无干扰分析法.采用这两种规约方式的缺点非常明显:进程代数太抽象,不易理解,而且关于进程代数的自动化分析工具不多;事件系统的主要问题在于很难实施归纳证明.目前软件规约大多采用基于状态转换的描述方式.与进程代数与事件系统相比,这种规约方式具有直观自然的优点,同时存在大量的有效的分析工具.因此本文主要研究基于有限状态转换系统的无干扰分析法.我们从基于状态转换的安全系统的形式化规约出发,以Petri网[10-11]作为描述安全系统规范的形式化工具来开展我们的研究.选择Petri网作为安全系统动态行为建模的工具,主要基于以下两点原因:(1)Petri网本身的特点:既有严格的形式化定义,又有直观的图形表示,存在大量设计和分析的算法,有强大的计算机工具来辅助算法的设计与分析,并且可以表示真并发,可以对系统提供不同层次的描述,使得我们的方法可以应用在系统开发的不同阶段;(2)多级安全系统的特性在于用户实施的操作受到安全机制的监控,造成不同安全级用户被允许执行的操作和对程序输出的观察力度是不一样的,安全系统的形式化模型应该具有刻画此特性的能力,在Petri网中通过对变迁和库所进行划分,很容易实现该能力,从而使得信息流的描述更加自然,容易在实际系统中得到应用.文中采用无干扰方法中隐蔽信息流存在的表现形式,从初始状态开始,删除高安全级用户所有的输入(等价于从来没有这些输入),低安全级用户的输出没有任何变化,作为隐蔽信息流存在的充分条件.并将该条件转化为Petri网上的表现形式:存在高安全级用户的单个输入引起安全系统的状态发生变化,且这种变化在低安全级用户所见的库所集上有所反映.在建立系统的Petri描述后,从Petri网的语法层面给出了隐蔽信息流存在的两种主要结构关系:冲突关系和因果关系.这两种关系说明什么样的结构可能会产生隐蔽信息流,这样,在安全系统设计阶段,设计人员就可以考虑避免使用这些结构.文中主要通过计算Petri网的可达图过程来检测隐蔽信息流的存在性,而且检测过程是在计算可达图的过程中实施的,这样可以避免全局可达图的构造,提高了效率,节省了存储空间.与无干扰方法相比,我们方法的优点主要体现在无需区分不同的状态等价类,避免使用展开定理.与基于有限状态转换系统的无干扰分析法相关的研究主要有3个.在文献[12]中訾小超等对无干扰方法进行了改进,提出了一个隐蔽信息流在自动机模型中存在的充分必要条件,并给出了判定算法.但是他们的方法仍然没有避免使用展开定理.在文献[13]中vanderMeyden等对确定型多级安全系统,提出了一种算术的方法来验证无干扰属性.他们首先定义了系统的双构造,然后将无干扰属性的验证问题归约为双构造系统的可达性问题.他们的方法避免了“展开定理”的使用,但是增加了分析的系统规模,具体表现为:令M为一确定型安全系统,|M|表示系统中状态的个数,则M的双构造中状态数为|M|2.与我们的方法相比,主要的不同点体现在两个方面:(1)时间复杂性.文献[13]中提出的方法等价于在M的双构造中进行深度优先搜索,其时间复杂性为O(|M|2),而我们的方法等价于在系统M上进行深度首先搜索,时间复杂性为O(|M|);(2)存储空间.M的双构造中每个状态的存储空间是M中每个状态所需存储空间的两倍.文献[14]提出一种通过考察Petri网中库所的前置集和后置集之间的关系来判断系统是否满足无干扰属性的方法,即如果发现某一库所的前置集中有高安全级的变迁,同时后置集中有低安全级的变迁,则认为系统不满足无干扰安全属性.本文对文献[14]的这项工作进一步精化,提出了变迁之间的冲Page3突关系和因果关系,并分析两者和隐蔽信息流之间的关系.此外,文献[14]只考察了Petri网的语法结构,而没有考虑Petri网的语义,从而导致会发现很多伪的隐蔽信息流.本文通过引入Petri网的L1活性有效地避免了该问题.本文最后还研究了安全系统的组合问题.当多级安全系统规模很大、很复杂时对其直接进行安全性分析是一件十分困难的事情.现在,软件工程领域流行的开发方法是基于模块的开发,即将复杂系统化分成很多个模块,每个子模块单独开发,最后再将这些子模块按照一定的组成规则组合成一个复杂的系统.因此我们在分析安全系统时也可以按照这种思路进行,从而降低大规模系统分析的复杂度.文中在假设单个Petri网不存在隐蔽信息流的情况下,讨论了在各种组合操作下(顺序、循环、并行、选择、共享、同步),无干扰属性是否得到保持,为开发大规模复杂的安全系统提供了指导.2安全系统的Petri网模型2.1Petri网1962年联邦德国的CarlAdamPetri在他的博士论文《用自动机通信》中首次使用网状结构模拟通信系统,这种系统模型就是Petri网的雏形.目前,Petri网的研究相当广泛,在系统建模、分析、模拟、验证方面均获得了有效的应用.定义1.Petri网是一个四元组PN=(P,T,F,M0),其中(1)P表示库所节点集合,T表示变迁节点集合;(2)P∩T=,P∪T≠;(3)F(P×T)∪(T×P),表示库所节点与变(4)M0:P→N为初始状态,这里N为自然数集.对x∈P∪T,令·x={y|(y∈P∪T)∧((y,x)∈F)}和x·={y|(y∈P∪T)∧((x,y)∈F)},称·x和x·分别为x的前置集和后置集.称Token在库所节点上的分布为Petri网的状态,即M:P→N.文中,采用M(pi)表示在库所节点pi上的Token数.变迁t在状态M下是使能的当且仅当p∈·t,M(p)1.使能的变迁t是可以引发的,引发后Petri网的状态发生如下变化:迁节点之间的有向弧集合;给定Petri网PN=(P,T,F,M0),在文章中会用到下面几个记号:(1)M1→tM2:变迁t在状态M1是使能的,且在引发后状态由M1变成M2(按式(1)计算);(2)M1→M2:存在变迁t使得M1→tM2;(3)M1→σM2:变迁序列σ=t1,…,tn-1使得M1→t1M2→t2…→tn-1Mn,并称M2为在M1下输入σ的输出;(4)M1→M2:存在变迁序列σ使得M1→σM2;(5)[M0〉表示PN的可达状态集:[M0〉={M|M0→M};(6)M1→t1M2→t2…→tn-1Mn称为路径.定义2(可达图).Petri网PN=(P,T,F,M0)的可达图RS是一个三元组(S,s0,R),这里S=[M0〉,s0=M0为可达图的初始状态,R:S×T→S定义为s=R(s,t)当且仅当s→ts.称s1→t1s2→t2…→tn-1sn为RS中的一条路径当且仅当1in-1(si+1=R(si,ti)).称Petri网PN是k界的当且仅当M∈[M0〉,p∈P(M(p)k).k界Petri网可以转化为与之等价的1界Petri网.由于很多系统可以用有界Petri网进行描述,因此文中假设所讨论的Petri网PN均是1界的.在后面的讨论中会涉及到Petri网的L1活性,因此下面引入L1活性的定义.定义3(L1活性)[15].给定PN=(P,T,F,M0),称变迁t∈T具有L1活性当且仅当在PN的可达图RS中存在路径s0→s1→ts2,即存在一个从初始状态可达的状态s1,使得在s1下t是使能的.2.2基于等级划分的安全系统的Petri网表示为方便讨论,先约定系统的保密性要求:系统中只存在高安全级(以下简称H用户)和低安全级(以下简称L用户)两类用户,从L用户到H用户的信息流是允许的,而从H用户到L用户的信息流是禁止的.这个保密性要求体现了多级安全策略.这里需要说明的是,本文主要关心的是从高安全级用户到低安全级用户的信息流动.因此和许多文献一样,为讨论的简便,假设系统中只存在两类用户.事实上对存在多个安全等级用户的多级安全系统,从信息流动的角度看,第三方主体可能会担当中间人的角色,即信息从高安全级用户流向第三方主体,再由第三方主体流向低安全级用户.对于满足传递性的信息流安全策略,这种情况可以归约为高安全级用户到低安全级用户的信息流动,因此两类用户的假设把握住了研究的重点,同时又不失一般性的.每个用户都有特定的操作权限和观察能力,有Page4些操作对该用户是禁止的,有些输出对该用户是不可见的.依据L用户的操作和观察能力,输入事件可分为H用户输入事件和L用户输入事件,分别用TH和TL来表示由这些事件构成的集合,且满足TL∩TH=.TL中的事件对L用户是可见的,而TH中的事件对L用户是不可见的,否则就已经形成了相应的隐蔽信息流.L用户到H用户的信息流不违背保密性要求,我们不关心H用户是否能够观察到L中的事件.PL表示L用户所能观察到的库所集,对于T中事件的发生导致的系统状态发生变化,L用户只能通过集合PL上Token分布的变化来观察.从上面的分析看出,对于安全系统,需要区分L用户和H用户的动作,因此为方便起见,以下假设Petri网为一五元组PN=(P,TL,TH,F,M0),这里TL∪TH=T,TL∩TH=.L用户所能观察到的库所集PL定义为PL=∪t∈TL系统的运行受输入事件驱动,但是系统中还存在一类输入事件,比如用户不停观察当前状态,这类事件不会改变系统的当前状态.我们引入记号τ统一表示这类操作,且在任何状态M下τ都能被引发,同时在引发后状态保持不变.为了讨论的方便,在本文的后面部分除非特别强调,否则输入事件均不包含τ.2.3犘犖的用户视图在PN的运行中,由于L用户只能观察到TL中事件的发生和Token在PL上的分布,L用户并不能精确观察到PN的全部执行活动,这相当于L用户只能感受到PN的部分执行,我们把L用户感受到的这一部分称为PN在L用户层面的投影,记作L-RS.定义4(L可达图).给定Petri网PN=(P,TL,TH,F,M0),定义其可达图RS(S,s0,R)在L用户上的投影为L-RS(SL,s0,L,RL),这里:(1)SL={s↓PL|s∈S},其中s↓PL定义为p∈PL,s↓PL(p)=s(p);(2)s0,L=s0↓PL;(3)RL:SL×(TL∪{ε})→SL为状态转换函数,RL(s↓PL,t)=s↓PL当且仅当下面条件中的一个成立:如果t∈TL,则R(s,t)=s;如果t=ε,则t∈TH使得,R(s,t)=s.3隐蔽信息流形成条件在实际系统中,隐蔽信息流形成需要两个阶段:H用户的信息发送和L用户的信息接收.在发送阶段,H用户执行精心设计的操作(或操作组合),这些操作隐含了相应的机密信息,并能以一定的方式影响系统行为;在信息接收阶段,L用户通过观察系统行为,推断H用户对系统所执行的操作,并进一步推出其中所隐含的机密信息.从隐蔽信息流的实际形成来看,这两个阶段缺一不可,而形成这两个阶段的关键在于:L用户能够感知到H用户对系统行为的特定影响.无干扰方法根据L用户观察的系统输出来推断H用户对系统所执行的操作.设w为一个输入序列,它的结尾是L的输入,w/H表示从w中删除所有H的输入后剩下的子序列.在初始状态输入w后,L得到的输出为L(w).显然L(w)刻画的是Token在PL上的分布.本节主要考察在L可达图上隐蔽信息流的表现形式.在此之前,先介绍无干扰方法的核心思想,如定理1.定理1[7-8].H与L之间存在隐蔽信息流当且仅当存在以L的输入为结尾的输入序列w,满足L(w)≠L(w/H).据定理1隐蔽信息流的实际关键在于:L用户能够感知到H用户对系统行为的特定影响,这意味着L用户所感受到的系统行为并不完全由自己的输入所决定,反映在L-RS(SL,s0,L,RL)上就是:对同一L用户的输入序列,存在多条可能的转移路径,而且在系统运行中,L用户能够知道实际是按哪一条路径进行转移的.考察路径s1→l1s2→εs2→l2s3,s1→l1s2→l2s3,在不考虑s3以后发生的状态转换关系的情况下L用户所观察到的是同一条转移路径s1→l1s2→l2s3.因此不能简单地通过路径的长度来判定不同的转移路径,需要通过下面定义的路径观察函数Obs来区分.定义5(路径观察函数).设Path为L-RS(SL,s0,L,RL)中的一条路径,Obs(Path)={s1→ts2|(t∈TL且s1→ts2为Path上的一个状态转换或者(t=ε∧s1≠s2)}称为Path的观察函数.定义6(不同的状态转移路径).路径Path1与Path2是不同的当且仅当Obs(Path1)≠Obs(Path2).以下部分会涉及到在L输入序列σ下L用户的观察,这里的观察指的是对于任意输入序列w,只要w/H=σ,则PN在w下的运行路径均是L用户在输入序列σ下观察到的路径.引理1.PN中存在以L的输入为结尾的输入序列w,满足L(w)≠L(w/H)当且仅当L用户在输入序列w/H下能观察到不同的状态转移路径.证明.()设在输入w和w/H下,状态转移Page5路径分别为Path1,Path2.因为L(w)≠L(w/H),所以Obs(Path1)≠Obs(Path2).()通过对L用户输入序列(不包括τ)的长度进行归纳来证明.(1)设L用户输入序列的长度为0,此时L用户必观察到路径Path1=s1→εs2→ε…→εsn→τsn,且1in-2(si=si+1)∧sn-1≠sn.在状态s0下,L用户可以输入事件τ,并观察到路径Path2=s0→τs0.记w为Path1上的输入序列,则L(w)≠L(w/H).(2)设在L用户输入序列长度为m-1(m1)时结论成立.(3)设在L用户输入序列l1,…,lm∈TL下L用户有不同的观察,且在l1,…,lm-1下L用户没有不同的观察.不妨设两个观察为s1→…→lm-1sn-x→ε…→lmsn→εsn+1→ε…→εsn+u,s1→…→lm-1sj-y→ε…→lmsj→εsj+1→ε…→εsn+v.因为在序列l1,…,lm-1下L用户没有不同的观察,所以必然有sn-x=…=sn-1=sj-y=…=sj-1,sn=sj,路径sn→εsn+1→ε…→εsn+u与sj→εsj+1→ε…→εsn+v上的观察函数值不一样.不妨设存在0iu-1使得(sn+i≠sn+i+1),任意的0j<i(sn+j=sn+j+1).设s1→…→lm-1sn-x→ε…→lmsn中的引发序列为w1,在输入序列w1/H,w1-w1/H下路径为s1→l1…→lm-1sm→lm…→εsn,则因为在序列l1,…,lm-1下L用户没有不同的观察,所以sn=sn.令Path1=s1→l1…→lm-1sm→lmsm+1→τsm+1,Path2=s1→l1…→lm-1sm→lmsm+1→ε…→εsn→εsn+1→ε…→εsn+i→εsn+i+1→τsn+i+1.记Path2上的输入序列为w,则Path1上的输入序列为w/H,且L(w)≠L(w/H).定理2.PN中存在隐蔽信息流,当且仅当在同一引发序列下L用户能观察到不同的状态转移路径.定理2直接由定理1和引理1可得.为加深对定理2的理解,我们首先讨论空输入事件下的状态转移情况.设在s0,L状态下,H用户输入事件序列为h1,…,hn,导致s0,L→ε…→εs1,s0,L≠s1.在事件序列h1,…,hn没有输入的情况下,L用户观察到的是初始状态没有变化;在事件序列h1,…,hn输入的情况下,L用户观察到的是初始状态发生了变化.因此H用户可以通过是否输入事件序列h1,…,hn来控制L用户的观察.下面考虑在单个输入事件下的状态转移情况.设在s0,L状态下,L用户输入事件为l1,H用户输入事件序列为h1,…,hn,导致s0,L→ε…→εs1→l1s2→ε…→εs3,s2≠s3.设当前状态为s2,在事件序列hx+1,…,hn没有输入的情况下,L用户观察到的是s2没有发生变化;在事件序列hx+1,…,hn输入的情况下,L用户观察到的是s2发生了变化.因此H用户可以通过是否输入事件序列hx+1,…,hn来控制L用户的观察.多个输入事件下的状态转移情况考察,类似于空和单个输入事件,这里不再赘述.综上所述,在同一输入下L用户能够观察到不同的输出,也就能够感受到H用户对系统行为的影响,也就能够推导出所隐蔽的机密信息;反过来,若对任意一个输入,L用户只能观察到一种输出(一条转移路径,或者所有转移路径上都具有相同的观察),H用户就不能影响到L用户的观察,也就不能传递机密信息.4隐蔽信息流的判定在第3节中已经给出了隐蔽信息流存在的充分必要条件.因此如何有效地判定该条件就显得尤为重要,这一部分我们将展示如何从PN的网结构和动态行为两个方面进行判定.基于网结构的静态判断可以非常简便地发现PN中有没有隐蔽信息流,从而尽早地引导PN的修改.但该方法是不完全的,因此对于通过网结构判断的PN,还需运用基于可达图的动态判定方法.动态判定是完全的,即通过该判定的PN,肯定不存在隐蔽信息流.4.1基于网结构的隐蔽信息流存在性判定PN中之所以存在隐蔽信息流,是因为H用户的动作可以影响L用户的观察,这反映在PN的结构上就是TH中的变迁和TL中的变迁存在某种牵连关系.我们主要考虑冲突关系和因果关系.定义7(冲突关系).给定PN=(P,TL,TH,F,M0),称PN具有冲突关系当且仅当l∈TL,h∈TH满足·l∩·h≠或者l·∩h·≠.定义8(因果关系).给定PN=(P,TL,TH,F,M0),称PN具有因果关系当且仅当l∈TL,h∈TH满足l·∩·h≠或者·l∩h·≠.为了加深对冲突、因果关系的理解,我们给出了几种典型的冲突结构(如图1(a),(b))和因果结构(如图1(c),(d)).冲突关系的本质在于变迁h的引发导致变迁l无法引发,因果关系的本质在于变迁h的引发导致变迁l可以引发,这样无论是满足冲突关系还是因果关系,H都可以通过是否引发h向L用户传递信息.Page6图1几种典型的冲突和因果关系定理3.如果PN=(P,TL,TH,F,M0)既没有冲突关系,也没有因果关系,则PN中不存在隐蔽信息流.证明.设PN中存在隐蔽信息流.由定理2,在PN的L可达图中,存在输入变迁序列σ=l1,…,lm,使得在该序列下,L用户有不同的观察Obs(Path1),Obs(Path2).由观察函数Obs的定义可知,在路径Path1或者Path2上必存在转换(s1→εs2∧s1≠s2).在状态s1,s2下,L用户能够观察到的是Token在PL上的分布.s1≠s2,所以在状态s1,H用户的输入变迁h的引发导致了PL上的分布发生了变化.由变迁引发的定义,必有·h∩PL≠,或者h·∩PL≠.不妨设l∈{·h∩PL},则存在变迁t∈TL使得l∈·t或者l∈t·.设l∈·t,则·h∩·t≠,与PN没有冲突关系矛盾.定理3也可以从另外一角度理解.PN没有冲突关系,也没有因果关系,说明L用户和H用户之间没有传递信息的媒介.没有媒介,就不可能有信息的传递.定理4.给定PN=(P,TL,TH,F,M0),(1)如果PN满足存在变迁l∈TL,h∈Th使得(·l∩·h≠),h具有L1活性,则PN中存在隐蔽信息流;(2)如果PN满足存在变迁l∈TL,h∈Th使得(l·∩h·≠),h具有L1活性,则PN中存在隐蔽信息流;(3)如果PN满足存在变迁l∈TL,h∈Th使得(l·∩·h≠),l,h具有L1活性,则PN中存在隐蔽信息流;(4)如果PN满足存在变迁l∈TL,h∈Th使得(h·∩·l≠),l,h具有L1活性,则PN中存在隐蔽信息流.证明.我们只证明该定理中的第一个结论,其它结论的证明与该结论的证明类似.变迁h具有L1活性,因此在PN的可达图RS中存在路径s0→s1,且在状态s1下h是使能的.设s0→s1中,L用户的输入序列为l1,…,lm.因为在状态s1下h是使能的,H用户可以决定引不引发h.因此在l1,…,lm下至少可以观察到两条转移路径s0↓PL→s1↓PL和s0↓PL→s1↓PL→εs2↓PL,且Obs(s0↓PL→s1↓PL)≠Obs(s0↓PL→s1↓PL→εs2↓PL).由定理2,可知PN中存在隐蔽信息流.定理3和4说明,在系统的设计阶段应尽量少用这两种结构,从而使得由此类结构引起的隐蔽信息流在系统的设计阶段得以避免.另外,从定理4可以看出隐蔽信息流的存在依赖于PN的初始状态M0.以图1(a)结构为例,设在某个初始状态M0下,变迁l无法被引发,进而h也不可能被引发.这样H就不能通过是否引发变迁h来传递信息.4.2基于可达图的隐蔽信息流存在性判定定理5.Petri网PN=(P,TL,TH,F,M0)中存在隐蔽信息流当且仅当其L可达图L-RS(SL,s0,L,RL)满足:i∈{1,…,n-1}((s1→εs2→ε…→εsn)∧(si≠si+1)))证明.()设PN存在隐蔽信息流.通过对L用户引发序列的长度进行归纳来证明该充分条件.(1)设引发序列的长度为0,由定理2可知存在路径Path1=s0,L→ε…→εs,Path2=s0,L→ε…→εs满足Obs(Path1)≠Obs(Path2).因为Path1与Path2的初始状态相同,所以在路径Path1或者Path2上必然存在状态sx使得sx≠sx+1.不妨设sx在路径Path1上,则Path1满足条件(2).(2)设在输入序列长度为m-1(m1)时结论成立.(3)设在输入序列l1,…,lm∈TL下L用户有不同的观察,且在l1,…,lm-1下L用户没有不同的观察.不妨设两个观察为s1→…→lm-1sn-x→…→lmsn→εsn+1→ε…→εsn+u,s1→…→lm-1sj-y→…→lmsj→εsj+1→ε…→εsn+v.因为在序列l1,…,lm-1下L用户没有不同的观察,所以必然有sn-x=…=sn-1=sj-y=…=sj-1.再由于lm的引发和引发所导致的状态变化只Page7涉及到·lm,lm样,观察不同体现在sn→εsn+1→ε…→εsn+u与sj→εsj+1→ε…→εsn+v上,因此下面的两种情况必有一个成立:(a)e∈{0,…,u-1}(se≠se+1);(b)e∈{0,…,v-1}(se≠se+1).无论哪种情况成立,均有式(2)成立.()设n∈N(s1∈SL,…,sn∈SL,i∈{1,…,n-1}((s1→εs2→ε…→εsn)∧(si≠si+1)))成立.因为s1∈SL,所以存在从初始状态s0,L到s1的转移路径s0,L→s1,不妨设该转移路径上的L用户引发序列为l1,…,lm.则由观察的定义Obs(s0,L→s1)≠Obs(s0,L→s1→ε…si→εsi+1),即在输入序列l1,…,lm下,L用户有不同的观察.定理5表明,隐蔽信息流存在的关键在于,在PN的可达图中存在引发s→hs满足s↓PL≠s↓PL.因此有下面的推论.推论1.Petri网PN=(P,TL,TH,F,M0)中存在隐蔽信息流当且仅当其L可达图L-RS(SL,s0,L,RL)满足:s1∈SL,s2∈SL(s1→εs2∧s1≠s2)(3)4.3隐蔽信息流的on-the-fly判定计算复杂系统的全局可达图是一件十分困难的事情,如何避免计算PN的全局可达图对提高隐蔽信息流的判定至关重要.这一小节,我们将探讨如何在计算PN可达图的过程中判定隐蔽信息流的存在性.由推论1可知,隐蔽信息流的判定关键在于检测H用户的输入变迁有没有引起Token在PL上的分布变化.而分布变化可以通过比较相连状态在PL上的值是否相等来判断.算法的基本思想是采用深度优先搜索策略计算PN的可达图,在计算可达图的过程通过比较相连状态在PL上的值是否相等来完成隐蔽信息流存在性的判定.设s为当前状态,状态s是在s下通过引发t∈T而得到的s的后继.如果t∈TH且s↓PL≠s↓PL,则断定隐蔽信息流存在,否则继续计算s的后继.具体的判定过程如下算法1所示.算法1.Petri网中的隐蔽信息流判定算法.输入:Petri网PN=(P,TL,TH,F,M0)输出:PN中是否存在隐蔽信息流Main(){初始化:置栈stack为空;Search(M0)}ProcedureSearch(s){Enabled(s)=;While(Enabled(s)≠Enable(s)){在集合Enable(s)-Enabled(s)中选择变迁t;s=fire(s,t);如果t∈TH且s↓PL≠s↓PL,则输出:隐蔽信息流存Enabled(s)=Enabled(s)∪{t};将s压入栈stack;Search(s);}检查栈是否为空,如果为空,则输出:隐蔽信息流不从stack中取出栈顶元素s;Search(s);}算法1中的Enable(s)表示在状态s下使能的变迁集合,s=fire(s,t)表示s的计算按照2.1节中的式(1)计算.另外,PN是1界的,所以算法肯定会终止.4.4示例这一小节我们通过一个简单的隐通道示例来说明Petri网中隐蔽信息流的标识.限制进程p不能与进程q通信.然而,进程p和q共享一个临界区,且对临界区均具有写的能力.进程p和q对临界区的写访问满足进程间的互斥关系.进程p通过周期性的对临界区执行写操作可以向进程q传递信息,比如在某个周期,进程p对临界区执行写操作,此时进程q就不能对临界区执行写操作,这样p和q依据事先约定的方式,q可认为p向传递了一个位信息0;相反如果进程q可以对临界区执行写操作,q可认为p向传递了一个位信息1.图2(a)是进程p和q对临界区进行访问的一个抽象模型,其中h1表示进程p对临界区执行写操作,h2表示进程p退出访问,l1表示进程q对临界区执行写操作,l2表示进程q退出访问,p2是临界区是否在执行写操作的标记,p3,p5是进程p对临界区执行写操作的标记,p1,p4是进程q对临界区执行写操作的标记.现在依据算法1标识PN1中的隐蔽信Page8息流.首先计算PN1的可达图,如图2(b)所示,依据算法1,在计算的过程中发现变迁h1的引发导致s0↓PL≠s2↓PL,因此PN1中存在隐蔽信息流.5系统组合下的隐蔽信息流分析大规模复杂系统的分析与验证是经常遇到的难题.通过一些较为简单的小系统利用某种运算或组合而得到较为复杂的系统,且在组合过程中保持某些性质不变,对于分析复杂系统提供了很好的途径.假设单个TCB的隐蔽信息流分析已经完毕,安全系统由多个TCB组合而成.下面讨论各种组合方式(连接、选择、循环、并行、共享合成、同步合成)对系统安全性的影响.为讨论方便,我们先引入标准Petri网的概念.文献[16]指出任何一个Petri网都可以由一个标准的Petri网产生.这样,讨论连接、选择、循环、并行合成方式对安全性的影响可以直接在标准Petri网上进行.定义9(标准Petri网).一个标准Petri网是一个六元组PN=(P,T,F,M0,i,o),这里:(1)P,T,F与定义1中一样;(2)i,o满足:i,o∈P∧·i=∧o·=;(3)M0满足:M0(i)=1,p∈P\{i}(M0(p)=0);(4)x∈P∪T:(i,x)∈F∧(x,o)∈F,其中F表示F的自反传递闭包.为讨论方便,事先引入几个约定:(1)引入记号TL(PN),TH(PN)分别表示PN中L用户,H用户的输入事件集合;(2)无论PN由PN1,PN2以何种方式合成所得,均有TL(PN1)∪TL(PN2)TL(PN),TH(PN1)∪TH(PN2)TH(PN);(3)PL(PN)={·t∪t·|t∈TL(PN1)∨t∈TL(PN2)};(4)下面涉及到的任意标准Petri网PN=(P,T,F,M0,i,o),均有i,o∈PL(PN).定义10(Petri网的顺序合成,如图3)[17-18].设PN1=(P1,T1,F1,M01,i1,o1),PN2=(P2,T2,F2,M02,i2,o2)为标准Petri网,满足P1∩P2=,T1∩T2=.如果PN=(P,T,F,M0,i,o)满足:P=P1∪P2,T=T1∪T2∪{t},t∈TL(PN),F=F1∪F2∪{(o1,t),(t,i2)},i=i1,o=o2,则称PN为PN1与PN2的顺序合成网,记为PN=PN1·PN2.定理6.如果PN1与PN2中没有隐蔽信息流,则PN=PN1·PN2中也没有隐蔽信息流.证明.设PN存在隐蔽信息流,则由定理5在PN的可达图中存在从初始状态s0出发的路径Path1=s0→t1s1→t2…→tnsn满足sn-1↓PL(PN)≠sn↓PL(PN).因为PN1中没有隐蔽信息流,所以t必然出现在Path1中,且0i<n(si↓PL(PN1)=si+1↓PL(PN1)).不妨设t=ti,则PN2在输入ti+1,…,tn下,L用户观察到路径si+1↓PL(PN)→tI+1…→tnsn↓PL(PN).因为sn-1↓PL(PN1)=sn↓PL(PN1),所以sn-1↓PL(PN2)≠sn↓PL(PN2),由定理5这与PN2中没有隐蔽信息流是矛盾的.定义11(Petri网的循环合成,如图4)[17-18].设PN1=(P1,T1,F1,M01,i1,o1)为标准Petri网,如果PN=(P,T,F,M0,i,o)满足P=P1∪{i,o},F=F1∪{(i,t1),(t1,i1),(o1,t2),(t2,o),(o1,t3),(t3,i1)},{t1,t2,t3}TL(PN),T=T1∪{t1,t2,t3},则称PN为PN1上的循环合成网,记为PN=PN1.定理7.如果PN1没有隐蔽信息流,则PN=PN1中也没有隐蔽信息流.证明.设PN存在隐蔽信息流.在初始状态下只有t1可以被引发,且t1∈TL(PN),所以在空输入变迁序列下,L无法观察到这样的路径:s0→εs1→ε…→εsn(n1)满足sn-1↓PL(PN)≠sn↓PL(PN).不妨设在输入σ=t1,t2,…,tn(n1)下导致的路径Path=s0→t1s1→t1TH(PN).如果t2出现在σ中,由PN的网结构可以断定t2=tn,与tn∈TH(PN)矛盾,所以t2不会出现在σ中.另外,PN1没有隐蔽信息流,所以t3一定出现在σ中,不妨假设tj1=…=tjk=t3.将t2,…,tn分成:σ1=t2,…,tj1-1,…,σk+1=tjk+1,…,tn.变迁t3引发造成的后果是使PN1回到了初始状态.因此,每一个σi(1ik+1)均可以在PN1中引发,且在σk+1=Page9tjk+1,…,tn下导致的路径Path1=s0→tjk+1sjk+1→tjk+2…→tnsn满足sn-1↓PL(PN)≠sn↓PL(PN),这与PN1没有隐蔽信息流矛盾.定义12(Petri网的选择合成,如图5(a))[17-18].设PN1=(P1,T1,F1,M01,i1,o1),PN2=(P2,T2,F2,M02,i2,o2)为标准Petri网,满足P1∩P2=,图5Petri网的合成定理8.如果PN1与PN2中没有隐蔽信息流,则PN=PN1+PN2中也没有隐蔽信息流.证明.在初始状态下只有t1,t3可以被引发,且t1,t3∈TL(PN),所以在空输入变迁序列下,L无法观察到不同的状态转移路径.设在序列σ=t1,t2,…,tn下,L用户观察到路径Path1=s0→εs1→ε…→εsn(n2)满足sn-1↓PL(PN)≠sn↓PL(PN).从PN的结构上可以看出t1=t1或者t1=t3,不妨设t1=t1.当t1引发以后,PN就按照PN1的运行轨迹运行,因此在PN1中存在路径Path2=s1→ε…→εsn(n2)且满足sn-1↓PL(PN1)≠sn↓PL(PN1),这与PN1中没有隐蔽信息流矛盾.定义13(Petri网的并行合成,如图5(b))[17-18].设PN1=(P1,T1,F1,M01,i1,o1),PN2=(P2,T2,F2,M02,i2,o2)为标准Petri网,满足P1∩P2=,T1∩T2=.如果PN=(P,T,F,M0,i,o)满足:P=P1∪P2∪{i,o},T=T1∪T2∪{t1,t2},F=F1∪F2∪{(i,t1),(t1,i1),(o1,t2),(t2,o),(t1,i2),(o2,t2)},{t1,t2}TL(PN),i=i1,o=o2,则称PN为PN1与PN2的并行合成网,记为PN=PN1∥PN2.定理9.如果PN1与PN2中没有隐蔽信息流,则PN=PN1∥PN2中也没有隐蔽信息流.证明.设在序列σ=t1,t2,…,tn下,L用户观察到路径Path1=s0→εs1→ε…→εsn(n1),且满足sn-1↓PL(PN)≠sn↓PL(PN).从PN的结构上可以看出,可以将σ=t1,t2,…,tn分别投影在{t1,t2}∪T1和{t1,t2}∪T2上,分别将投影记为σ1,σ2.从PN的结构还可以断定,σ1,σ2的运行互不干扰,因此必有sn-1↓PL(PN1)≠sn↓PL(PN1)或者sn-1↓PL(PN2)≠sn↓PL(PN2).无论哪种情况成立,与PN1,PN2中没T1∩T2=.如果PN=(P,T,F,M0,i,o)满足:P=P1∪P2∪{i,o},T=T1∪T2∪{t1,t2,t3,t4},F=F1∪F2∪{(i,t1),(t1,i1),(o1,t2),(t2,o),(i,t3),(t3,i2),(o2,t4),(t4,o)},{t1,t2,t3,t4}TL(PN),i=i1,o=o2,则称PN为PN1与PN2的冲突合成网,记为PN=PN1+PN2.有隐蔽信息流矛盾.下面我们讨论共享合成与同步合成对隐蔽信息流的影响,为讨论的方便采取的Petri形式为定义1中给出的四元组形式.定义14(共享合成,如图6)[19].设PN1=(P1,T1,F1,M01),PN2=(P2,T2,F2,M02)为Petri网,满足P1∩P2≠,T1∩T2=.如果PN=(P,T,F,M0)满足:P=P1∪P2,T=T1∪T2,F=F1∪F2,若p∈P1∩P2,M0(p)=max{M01(p),M02(p)},若p∈Pi-(P1∩P2),M0(p)=M0i(p)(i∈{1,2}),则称PN为PN1与PN2的共享合成网,记为PN=PN1ΔPN2.定理10.如果PN1与PN2中不存在隐蔽信息流,则PN=PN1ΔPN2中可能存在隐蔽信息流.图6(c)中的Petri网是由图6(a),图6(b)通过共享合成而得.图6(a)中没有L用户,图6(b)中没有H用户,因此两者均不会存在隐蔽信息流,但是图6(c)中却存在隐蔽信息流.定义15(同步合成Ⅰ)[20-21].设PN1=(P1,T1,F1,M01),PN2=(P2,T2,F2,M02)为Petri网,Page10满足P1∩P2=,T1∩T2=.如果PN=(P,T,F,M0)满足:P=P1∪P2,T=T1∪T2,F=F1∪F2,M0(p)=M0i(p)(i∈{1,2}),则称PN为PN1与PN2的同步Ⅰ型合成网,记为PN=PN11PN2.定理11.如果PN1与PN2中不存在隐蔽信息流,则PN=PN11PN2中也不存在隐蔽信息流.证明.设在序列σ=t1,t2,…,tn下,L用户观察到路径Path1=s0→εs1→ε…→εsn(n1),且满足sn-1↓PL(PN)≠sn↓PL(PN).从PN的结构上可以看出,可以将σ=t1,t2,…,tn分别投影在T(PN1)和T(PN2)上,分别将投影记为σ1,σ2.从PN的结构可以断定,σ1,σ2的运行互不干扰,因此必有sn-1↓PL(PN1)≠sn↓PL(PN1)或者sn-1↓PL(PN2)≠sn↓PL(PN2).无论哪种情况成立,与PN1,PN2中没有隐蔽信息流矛盾.定义16(同步合成Ⅱ)[20-21].设PN1=(P1,T1,F1,M01),PN2=(P2,T2,F2,M02)为Petri网,满足P1∩P2=,T1∩T2≠,TL(PN1)∩TH(PN2)=,TH(PN1)∩TL(PN2)=.如果PN=(P,T,F,M0)满足:P=P1∪P2,T=T1∪T2,F=F1∪F2,M0(p)=M0i(p)(i∈{1,2}),则称PN为PN1与PN2的同步Ⅱ型合成网,记为PN=PN12PN2.图7新建和删除特权目录第4节的结论说明在使用Petri网对该系统进行建模时,只需考察高低进程有交互的部分,即特权目录UD.在特权目录中,高安全级进程可以读、写、新建、删除文件,而低安全级进程是不允许的.在Petri网中定义一些变迁来表示高低安全级进程可以执行的操作,如表1所示.注意对于低安全级进定理12.如果PN1与PN2中不存在隐蔽信息流,则PN=PN1PN2中也不存在隐蔽信息流.证明.设在序列σ=t1,t2,…,tn(tn∈TH(PN))下,L用户观察到路径Path1=s0→s1→…→εsn(n1),且满足sn-1↓PL(PN)≠sn↓PL(PN).首先考虑tn∈T1∩T2,因为P1∩P2=,sn-1↓PL(PN)≠sn↓PL(PN),所以必有sn-1↓PL(PN1)≠sn↓PL(PN1)或者sn-1↓PL(PN2)≠sn↓PL(PN2).无论哪种情况成立,与PN1,PN2中不存在隐蔽信息流矛盾.下面考虑tnT1∩T2,不妨设tn∈T1.因为P1∩P2=,sn-1↓PL(PN)≠sn↓PL(PN),所以必有sn-1↓PL(PN1)≠sn↓PL(PN1),与PN1中不存在隐蔽信息流矛盾.6实例分析本小节我们将采用文献[14]中的一个实例来说明如何标识隐蔽信息流.在一个支持强制安全等级的系统中,如UNlX操作系统,当进程新建和删除一个特权目录时就会受到某些限制,图7对这种限制给出了说明.图7(a)和(b)说明如果Lh>Li,则等级是Lh的进程不能创建和删除等级是Li的目录D中的特权目录UD.图7(c)和(d)说明特权目录只能被低安全级的进程创建和删除.程,只有当特权目录中没有任何文件时才能被删除.高安全级进程ReadWrite××NewDelete低安全级进程××CreateRemove××Page11图8是高低进程访问特权目录UD的抽象过程的Petri网模型.在该模型中LCreat和LRemove分别表示低安全级进程创建和删除特权目录UD.HNew,HDelete,HRead/Write分别表示高安全级进程创建文件、删除文件、读和写文件.模型描述的主要访问过程是当UD创建好之后,如果里面没有文件,则可以直接删除,如果高安全级进程创建了文件,则必须等待文件删除后UD才能被删除.图8中的Petri网比较简单,可以直接看出每一个变迁都具有L1活性,且·LRemove∩·HNew≠.由定理4直接可知存在隐蔽信息流.图8高低进程访问特权目录UD的Petri网模型·LRemove∩·HNew≠说明HNew的触发与否直接决定了LRemove能否被触发.直观上的解释就是,当低安全进程创建好UD目录后,高安全级进程可以通过是否创建新文件来向低进程传递信息.如果高安全级进程创建新文件,则低安全级进程不能删除目录UD,此时可以理解为高安全级进程向低安全级进程传递了一个比特信息.如果高安全级进程没有创建新文件,则低安全级进程可以成功删除目录UD,此时可以理解为高安全级进程向低安全级进程传递了另外一个比特信息,从而造成了信息从高安全级进程向低安全级进程的泄漏.7结论隐蔽信息流标识是一个众所周知的难题,目前尚无理论上成熟、实际上可行的标识方法.其中,无干扰方法的主要问题在于必须依靠“展开定理”.本文遵循无干扰方法的思想,以基于状态转换系统的形式化规约为处理对象,使用Petri网作为开发TCB的形式化建模工具,借助Petri网中比较成熟的分析技术对TCB中的隐蔽信息流进行分析,并提出一种基于Petri网可达图的隐蔽信息流存在性判定算法.和无干扰方法相比,该算法的主要优点在于避免了等价状态的区分和展开定理的使用,同时可以直接定位隐蔽信息流的位置.另外,还探讨了导致隐蔽信息流发生的网结构特征,从而使得由此类结构引起的隐蔽信息流在系统的早期设计阶段得以避免.文中最后还提出可以通过组合分析的方法降低大规模可信系统分析的复杂度,并讨论了各种组合操作下隐蔽信息流的存在性.文中采用有界Petri网为TCB建模,因而其可达图也是有限的.对于具有无穷状态的TCB,其Petri网模型将是无界的,因而其可达图是无穷的.如何在无穷的空间上判定隐含信息流的存在性是下一步的主要工作.我们可借助于模型检测技术[22-23]和定理证明器PVS[24]来完成无穷空间上隐蔽信息流的分析:(1)利用模型检测中的抽象技术[25],在保留全部信息流的前提下,建立TCB的有穷状态模型;(2)假设在当前可达空间上隐蔽信息流不存在,利用PVS归纳证明在下一步可达空间上隐蔽信息流也不存在.
