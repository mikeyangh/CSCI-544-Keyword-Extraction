Page1最大不全犽满足问题的局部搜索近似算法咸爱勇朱大铭(山东大学计算机科学技术学院济南250101)摘要合取范式可满足与最大可满足问题是理论计算机科学的核心问题.最大不全满足问题是最大可满足问题的一般化.限制每个子句均含有k(2)个字母的最大不全满足问题又称为最大不全k满足问题.最大不全满足问题的算法进展,以解答该类问题的半定规划松弛法最具代表性.关于最大不全2满足、3满足和4满足问题,目前性能最好的近似算法分别由Goemans与Williamson、Zwick、Karloff与Zwick给出,近似性能比分别为1.139(1/0.878)、1.10047(1/0.9087)和8/7.当k5时,最大不全k满足问题的近似算法则未曾见到.文中给出了一个解答最大不全k满足问题的局部搜索算法,近似性能比可达到2k-1/(2k-1-1),k2;进一步将该方法推广到解答由不少于k个字母的子句构成的最大不全k满足问题,近似性能比亦可达到2k-1/(2k-1-1).利用解答最大不全k满足问题的近似算法,给出了解答最大k可满足问题的新近似算法,近似性能比可达到2k/(2k-1).文中最后证明了若P≠NP,则k4的最大不全k满足问题不能近似到小于2k-1/(2k-1-1),从而说明文中解答最大不全k满足问题的算法近似性能比是最优的.关键词局部搜索;算法;近似性能比;合取范式;可满足性1引言合取范式可满足问题(简称SAT)是理论计算机科学的核心问题.合取范式最大可满足问题(简称Max-SAT)是SAT问题的优化形式,要求根据给定布尔变量字母组成的子句集合,计算布尔变量赋值,使满足的子句(Clause)数目达到最大.早在1971年,Max-SAT就被证明为NP-Hard[1-2].最大不全满足问题是最大可满足问题的一般化[3],要求根据给定布尔变量字母组成的子句集合,计算布尔变量赋值,使满足且不全满足的子句数目达到最大.最大不全满足问题简称为MaxNAE-SAT,当然也是NP-Hard问题[4].MaxNAE-SAT也可看作最大割问题及最大集合分割问题的一般化[3,5].若每个子句含有固定数目的布尔变量字母,则Max-SAT和MaxNAE-SAT演变为它们的一类重要子问题,这类子问题的算法与复杂性研究同样吸引了许多学者的研究兴趣.本文将每个子句含有k个布尔变量字母的Max-SAT子问题称为Max-k-SAT;将每个子句含有不多于k个布尔变量字母的Max-SAT子问题称为Max-[k]-SAT;将每个子句含有不少于k个布尔变量字母的Max-SAT子问题称为Max-(k)-SAT.类似地,将每个子句含有k个布尔变量字母的MaxNAE-SAT子问题称为MaxNAE-k-SAT;将每个子句含有不多于k个布尔变量字母的MaxNAE-SAT子问题称为MaxNAE-[k]-SAT;将每个子句含有不少于k个布尔变量字母的MaxNAE-SAT子问题称为MaxNAE-(k)-SAT.Johnson[6]于1974年最先设计出近似性能比为2的Max-SAT问题近似算法,并设计出近似性能比为2k/(2k-1)的Max-(k)-SAT问题近似算法.为每个布尔变量以1/2概率随机赋值T/F的简单方法,也可使解答Max-(k)-SAT的平均近似性能比达到2k/(2k-1)[7].Yannakakis[8]于1994年给出解答Max-SAT问题的随机算法,其平均近似性能比为4/3.Goemans与Williamson[9]利用线性规划松弛法,给出一个更简单的随机近似算法,近似性能比仍为4/3,1995年,他们采用半定规划松弛法将解答Max-[2]-SAT问题的近似性能比改进到1.139[10],该方法修改后用于解答Max-SAT问题,近似性能比为1.32[9].Asano与Williamson重新分析了Goemans和Williamson的4/3近似算法,利用Feige和Goemans[11]给出的解答Max-[2]-SAT与Karloff和Zwick[12]给出的解答Max-[3]-SAT的半定规划松弛法,将解答Max-SAT问题的近似性能比改进为1.275[13].最大不全满足问题的半定规划松弛法,代表了该问题算法研究的主要进展.解答MaxNAE-2-SAT的半定规划松弛法可由Goemans和Williamson[10]解答Max-[2]-SAT的半定规划松弛法直接得到,近似性能比为1.139;解答MaxNAE-4-SAT的半定规划松弛法则可由Karloff与Zwick[12]解答Max-[3]-SAT的半定规划松弛法直接得到,近似性能比为8/7.Andersson和Engebretsen于1998年给出解答MaxNAE-SAT的半定规划松弛法,近似性能比为1.3812(1/0.7240)[14].Han、Ye与Zhang被称作外部旋转(OutwardRotation)的取整技术将Andersson和Engebretsen的算法的近似性能比加强为1.3335(1/0.7499).Zwick[15]于1999年进一步利用半定规划松弛法和外部旋转取整技术给出MaxNAE-SAT问题猜测近似性能比为1.2536(1/0.7977)的近似算法,并给出MaxNAE-3-SAT近似性能比为1.10047(1/0.9087)的近似算法.2006年,Abidor和Berkovitch等人将解答MaxNAE-SAT的猜测近似性能比改进为1.2079(1/0.8279),并将解答Max-SAT的(无猜测)近似性能比改进为1.25502[3](1/0.7968).所谓猜测近似性能比,是指在文献[15]中给出的一个猜测概率表达式成立时,算法所能够达到的近似性能比.当k5时,目前未见任何解答Page3MaxNAE-k-SAT的半定规划松弛法.虽然半定规划松弛法解答最大可满足与最大不全满足问题获得了求解性能的全面提高,求解Max-[3]-SAT的近似性能比甚至已经达到极限值.然而半定规划松弛法所耗费的运行时间尚不令人满意.因为半定规划松弛法所给出的近似性能比还须经历去随机过程才能准确地达到,目前去随机的时间复杂性仍是一个指数很大的多项式函数,一般不低于O(n30)[16].局部搜索是解答NP-Hard优化问题的典型方法,解答SAT问题的局部搜索算法也不少见.我们所知的SAT问题局部搜索算法有GSAT[17-18]、WSAT[19]、NSAT[20]、TSAT[21-22]、SDF[23]等.目前,局部搜索仍然是人们在实际SAT求解中最常使用的方法[24].目前尚无研究结果用于分析这些在实践中表现优越的局部搜索算法的性能.2010年,朱大铭等人[25]给出Max-3-SAT问题的局部搜索近似算法,近似性能比可达到8/7,算法可推广到解答Max-(k)-SAT,近似性能比为2k+2解答MaxNAE-(k)-SAT[26],近似性能比可达到k+1.另外,Hastad[27]曾证明:若P≠NP,则k3k的Max-k-SAT不能多项式时间近似到小于2k/(2k-1),k3.文献[25]的算法用于解答k4的Max-(k)-SAT,达到的近似性能比与Hastad给出的解答该问题拒绝达到的近似性能比上界仍有较大差距.1994年,Khanna等人[28]提出所谓盲目的(anonymous)局部搜索算法,用于解答Max-k-SAT问题,其近似性能比为2k/(2k-1).该算法解答Max-k-SAT,近似性能比已经达到Hastad关于解答Max-k-SAT拒绝达到的近似性能比上界.然而该方法并不能简单地推广到解答Max-(k)-SAT.2000年,Dantsin等人[29]给出一个解答k-SAT的局部搜索精确算法,时间复杂性为(2-2/(k+1))n.本文讨论MaxNAE-SAT问题的局部搜索求解方法.首先给出解答MaxNAE-k-SAT问题的一个局部搜索算法,算法近似性能比可达到2k-1再将解答MaxNAE-k-SAT的局部搜索方法,推广到解答MaxNAE-(k)-SAT问题,近似性能比也可达到2k-12k-1-1算法,给出解答Max-(k)-SAT的一个新算法,近似性能比达到2k答Max-k-SAT也可以达到同样近似性能比,但不能解答Max-(k)-SAT问题实例.本文算法则可直接用于解答Max-(k)-SAT问题实例.本文最后证明当k4时,MaxNAE-k-SAT不能多项式时间近似到小于2k-12最大不全犽满足问题的局部搜索一个布尔变量u对应两个字母u和u-,分别称为u的正变量字母和反变量字母.给予布尔变量u赋值后,其字母也相应得到确定的布尔值,本文我们并不区分布尔变量赋值与布尔变量字母赋值的不同.一个子句是若干布尔变量字母的集合.设Ct={x[1],x[2],…,x[k]}为一个子句,其中x[1],…,x[k]为布尔变量字母,若赋值函数a(·)使得a(x[1])∨…∨a(x[k])=T,则称Ct是满足的;若a(x[1])∨…∨a(x[k])=T且a(x[1])∧…∧a(x[k])=T,则称Ct是全满足的;若a(x[1])∨…∨a(x[k])=T,且a(x[1])∧…∧a(x[k])=F,则称Ct是不全满足的;若a(x[1])∨…∨a(x[k])=F,则Ct为不满足的.最大不全k满足问题由布尔变量集与k个字母的子句集给定,欲寻求每个布尔变量的真值指派,使给定子句集中不全满足的子句数目达到最大.布尔变量的真值指派也称为布尔变量的赋值(函数).最大不全k满足问题可形式化为:实例:布尔变量集合U={u1,…,un},子句集合C={C1,…,Cm},每个子句均含有k个布尔变量字母.子句Ct可表示为Ct={x[t,1],x[t,2],…,x[t,k]},其中,1tm,x[t,l]∈{u1,…,un,u-1,…,u-目标:求U中布尔变量的赋值函数a:U→{T,F},最大化C中不全满足子句的数目.该问题即为MaxNAE-k-SAT.若求解目标修改为寻求U的赋值函数,使C中满足的子句数目达到最大,则问题变为Max-k-SAT.MaxNAE-k-SAT是Max-k-SAT的一般化,或可将Max-k-SAT看作MaxNAE-k-SAT的子问题,这是因为可将任一Max-k-SAT实例变换为一个MaxNAE-k-SAT实例,并使两个实例有对应等价的赋值函数.变换方法如下:Page4设〈U,C〉是任一Max-k-SAT实例,增加一个布尔变量o,得到U=U∪{o};在每个C的子句中添加布尔变量字母o,得到C.即设Ct={x[t,1],x[t,2],…,x[t,k]}∈C,则Ct={x[t,1],x[t,2],…,x[t,k],o},C={Ct|Ct∈C}.将〈U,C〉视为一个MaxNAE-k-SAT实例,设a(U)为U的赋值函数,若a(x[t,1]),a(x[t,2]),…,a(x[t,k]),a(o)使得Ct不全满足,当且仅当a(x[t,1])a(o),a(x[t,2])a(o),…,a(x[t,k])a(o)使Ct满足,其中“”表示异或运算.因此a(U)使得C中不全满足的子句数目为M,当且仅当a(u1)a(o),a(u2)a(o),…,a(un)a(o)使C中满足的子句数目也为M.因此任一Max-k-SAT实例等价于一个每个子句均含有一个公共字母(例如o)的MaxNAE-(k+1)-SAT实例.本节,每个子句均含有k个布尔变量字母.因一个子句若同时含有一个布尔变量的正变量字母和反变量字母,则该子句总是不全满足的,也是满足的,所以本文总假设每个子句不同时含有一个布尔变量的两个字母.2.1算法及其性能定义1.给定U的赋值函数a(U),若子句Ct含有布尔变量字母uj,且a(uj)=T,或Ct含有布尔变量字母u-满足;若子句Ct含有布尔变量字母uj且a(uj)=F,或Ct含有布尔变量字母u-a(uj)满足或不被uj满足.将Ct被a(uj)满足简记为a(Ct,uj)=T,Ct不被a(uj)满足简记为a(Ct,uj)=F.定义2.给定U的赋值函数a(U),Ct∈C.若Ct中有i个布尔变量字母赋值为T,0ik,另外k-i个字母赋值为F,则称Ct关于a(U)是i-满足的.一个子句是0-满足的,则为不满足的.一个子句是k-满足的,则为全满足的.由a(U)为U中布尔变量赋值后,设Si表示C中所有i-满足的子句集合;再设C[i,j]表示i-满足,且被uj满足的子句集合;N[i,j]表示i-满足,且不被uj满足的子句集合,即C[i,j]={Ct|Ct∈Si,a(Ct,uj)=T},N[i,j]={Ct|Ct∈Si,a(Ct,uj)=F}.因每个子句不同时含有uj和u-赋值取反,则C[i,j]中的子句均由i-满足变为(i-1)-满足,0<ik;而N[i,j]中的子句均由i-满足变为(i+1)-满足,0i<k.任给U的赋值函数a(U),则C中不全满足的子句数目为|S1|+…+|Sk-1|.解答MaxNAE-k-SAT的局部搜索方法需要首先确定一个目标函数,然后利用如下方法,获得布尔变量的赋值:随机为布尔变量赋初值,然后选择一个布尔变量,将其赋值取反,使目标函数值增大,重复该操作直到不能选择布尔变量,其赋值取反可使目标函数值增大为止.将该方法称为一位跳变局部搜索.若直接采用|S1|+…+|Sk-1|做为目标函数,我们并不知道算法能否达到所期望的性能.Khanna等人[28]关于Max-k-SAT的局部搜索算法以|S1|,…,|Sk|的加权和作为目标函数.我们同样建立一个由|S0|,|S1|,…,|Sk|的加权和构成的目标函数,一般地表示为F=α0S0+α1S1+…+αk-1Sk-1+αk|Sk|(1)我们期望利用一位跳变的局部搜索使目标函数F最大化,从而使F达到局部最大时,|S1|+…+|Sk-1|得到不小于(2k-1-1)(|S0|+|Sk|)的取值.在给出系数α1,…,αk-1的取值之前,先讨论选择赋值取反的布尔变量应满足的条件.任意选择uj,将其赋值取反,由i-满足变为(i-1)-满足的子句使F获得增量:(αi-1-αi)|C[i,j]|,1ik;由i-满足变为(i+1)-满足的子句使F获得增量:(αi+1-αi)|N[i,j]|,0ik-1.所以F因uj赋值取反而产生的增量为如果存在一个布尔变量,其赋值取反使得ΔF>0,则将该变量的赋值取反就可增大F的取值.下面给出求解MaxNAE-k-SAT的局部搜索算法,并将算法命名为算法1:MaxNAE-k-SAT(U,C).在算法描述中,a(uj)表示将布尔变量uj由赋值函数a(·)给予的布尔值取反得到的布尔值.算法1.MaxNAE-k-SAT(U,C).1.随机为U中布尔变量赋值,得到a(U);2.While(存在uj,使∑3.a(uj)←a(uj);4.Endwhile5.Returna(U)现在需要给出目标函数F中|Si|前的系数αi的取值.在函数F中,S0,Sk中的子句是不满足和全满足的,所以取α0=αk=0.其他系数αi(1ik)由下Page5述递推关系给出,其中k2.αi=先证明由式(3)给出的系数αi满足对称性质.从而说明由式(3)计算得到的αk=0.性质1.若0ik,则αi=αk-i.证明.由式(3),可以知道另外,αk-i-αk-(i-1)=-所以,当k为偶数时,设γ=到αγ-αγ-1=αγ-αγ+1,所以αγ-1=αγ+1.依此类推,由αγ-j=αγ+j和式(6)可以得到αγ-j-1=αγ+j+1,1jk2-1.当k为奇数时,设γ=αγ-αγ-1=所以αγ=αγ-1.由此利用式(6)可依次推得αγ-j-1=αγ+j,0j综上,对于满足0ik的i,总有αi=αk-i.引理1.任给U的赋值函数a(U),则有nj=1∑|C[i,j]|=iSi,∑证明.设Ct={x[t,1],xt,[]2,…,x[t,k]}∈Si.不失一般性假设a(x[t,1])=a(x[t,2])=a(x[t,i])=T.将{x[t,1],…,x[t,i]}中某一个字母的赋值取反,Ct会由i-满足变为(i-1)-满足,设x[t,y]∈{ujy{jy|1yi},CtC[i,x],即Ct出现在i个且恰好,u-jyi个集合C[i,j]中,所以∑{xt,i[取反时,Ct会由i-满足变为(i+1)-满足,设x[t,y]∈{ujyx{jy|i+1yk},CtN[i,x],所以Ct恰好出现,u-jy在k-i个N[i,j]中,即∑引理2.设算法1结束时得到U的赋值函数a(U),Si为由a(U)为U中布尔变量赋值所产生的i-满足的子句集合,则|S1|+…+|Sk-1|(2k-1-1)(|S0|+|Sk|).证明.当算法结束时,任意布尔变量uj赋值取反,1jn,目标函数F数值均不再增加.那么对于每个j=1,2,…,n,总有k∑i=1(αi-1-αi)C[i,j]+∑将式(8)的n个不等式左右分别相加,得到Page6由引理1,将∑(k-i)Si代入式(9),得到kα1S0+∑kαk-1Sk0由αi-αi-1=2k-1-1kkα1S0+kαk-1Sk=kα1(S0+Sk)于是不等式(10)变为k-1-∑i=1还需要说明不等式(12)左边恰好为|S1|+|S2|+…+|Sk-1|,为此,只需证明(αi-1-αi)i+(αi+1-αi)(k-i)=-1,1ik-1.事实上,(αi-1-αi)i+(αi+1-αi)(k-i)=-2k-1-1-∑(k-i+1)k2k-1-1-∑=-=-()()综上所述,命题得证.因C=S0∪S1∪…∪Sk-1∪Sk,由引理2可得|S1|+…+|Sk-1|k2的MaxNAE-k-SAT任意实例,总有近似性能比为2k-12k-1-1当k=2,3时,算法1的近似性能比分别为2,,并不好于Goemans、Williamson[10]及Zwick[15]43给出的半定规划松弛法.当k=4时,算法1的近似性能比与Karloff、Zwick[12]的半定规划松弛法所达到的近似性能比相同.当k5时,目前未见有确定近似性能比的MaxNAE-k-SAT求解算法.Zwick曾在文献[15]中指出,半定规划松弛法用于解答k5的MaxNAE-k-SAT问题,显得十分困难.本文算法弥补了这一不足.2.2算法的时间复杂性设|U|=n,|C|=m.给定一个U的赋值函数a(U),判定一个子句属于集合S1,…,Sk中的哪一个,需要O(k)时间.判定一个子句属于哪些C[i,j],1ik,1jn及哪些N[i,j],0ik-1,1jn,也需要O(k)时间.因此子句集合C[i,j],N[i,j]和Si可在O(km)时间内得到.找到一个布尔变量uj,1jn,满足ΔF>0,需要O(kn)时间.因此算法1的一个While循环所花费的时间为O(k(m+n)).算法1中While循环的执行次数必然受到目标函数F中的|Si|前面系数αi的影响.当k=2,3,…,9时,分别按照式(3)计算αi,将αi的数值列在表1中.由式(3)不难知道,αi是k的指数函数,但仅与k有关,与MaxNAE-k-SAT实例中的布尔变量与子句数目无关.kα1α2α3α4α5α6α7α8α92123147453631679891278853因目标函数F中每个系数αi均以分数形式给出,所以αi的任何取值误差均可使算法1的近似性能比不能达到2k-1总能达到2k-1数β,使β·αi被放大为正整数,1ik-1.当k较小时,这种系数的整数倍放大对于算法的时间复杂性影响不大.如当k=8时,每个αi乘以24,则均变为正整数,其中24α4=448为最大.此时有0F448m,因此算法1的While循环最多执行448m次,由此可知,算法1的时间复杂性为O(448×8m(m+n)).Page7下面默认β(k)为将βα1,…,βαk-1均放大为整数,且取值最小的正整数,显然β(k)αk/2β(k)αk-1中的最大者,且是k的指数函数.我们计算了k26的所有目标函数的系数,将k取值10~26时,β(k)的数值列在表2中.因αk/22k-1,所以,β(k)αk/22k-1表2将α犻放大为整数需要放大的倍数β(犽)k101112131415下面给出β(k)上界的一个估计值.性质2.设β(k)=min{β|βαi为正整数,1ik-1},其中αi由式(3)给定,0ik,则当k6时,β(k)k/2!.证明.若k为偶数,则k=12k(k-1)…(k-l+1)k/()2()kl表达式中,可将(αi-αi-1)的表达式整理成一个分数和与另一个整数乘积的形式,即(αi-αi-1)=N·M,其中N=M按照如下方式取值:若i=1,则M=1;若i2,则M=(i-1)!.考察N的表达式最后一个分数项,因k6,所以若i=1或i=2,则该分数项的分子部分(k-i)…(k-k/2+1)总能被2整除;若i3,则M=(i-1)!可以被2整除.由此可知,(k/2)!(αi-αi-1)必为整数.由α0=0及性质1立即得到,(k/2)!αi为整数,1ik.因β(k)是满足β(k)αi为整数的最小正整数,1ik-1,所以β(k)(k/2)!.若k为奇数,则烄k烌k-1烎2烆αi-1)=N·M,其中,N=M取值方式如下:若i=1,则M=1;若i2,则M=(i-1)!.由此可知,((k-1)/2)!(αi-αi-1)必为整数.由α0=0及性质1立即得到,k-1()21ik.所以β(k)当k=8时,β(k)=24=4!,由性质2给出的上界等于表1中实际计算出的上界.另外表2中的β(k)取值远小于性质2给出的上界.定理1.算法1解答任意MaxNAE-k-SAT实例的近似性能比均不大于2k-1O(β(k)2k-1k(m+n)m).其中n,m分别为布尔变量数目和子句数目,当k6时,β(k)k/2!.在实际MaxNAE-k-SAT求解中,一般并不需要将F中的系数αi转化为整数,可直接采用小数来表示αi并计算F的数值.我们采用64位浮点数来表示每个系数αi,以Java程序实现算法1,随机产生MaxNAE-k-SAT实例,在各种笔记本及台式机电脑上进行了实际求解测试.在针对k40的随机MaxNAE-k-SAT实例的求解测试中,我们从未遇到算法1的求解性能大于2k-1k=4,5,16,19,28,29,利用算法1的Java程序,将在以酷睿U9400为中央处理器的笔记本电脑上实际求解的运行时间列在表3中.表3给出的测试结果中,最大和最小运行时间分别为随机产生的20个实例的求解时间的最大者和最小者.表3算法1的实际运行时间(|犝|、|犆|表示布尔变量数目和子句数目;Max、Min分别表示算法求解20个实例的最大和最小运行时间,Aver为平均运行时间)k|U|420005200016192829Page8实际测试表明,直接采用浮点数表示目标函数F中的系数αi,并不影响算法1的求解性能.然而算法1仅适合于k为小常数时的MaxNAE-k-SAT求解,如k40.3一般最大不全犽满足问题的局部搜索若MaxNAE-SAT实例不仅含有k个字母的子句,也含有多于k个字母的子句,则问题演变为更一般的最大不全k满足问题,即MaxNAE-(k)-SAT.第2节给出的算法并不能直接用于解答MaxNAE-(k)-SAT实例.下面考虑推广算法1,使之能够解答MaxNAE-(k)-SAT.MaxNAE-(k)-SAT问题的求解目标与MaxNAE-k-SAT的求解目标相同,实例为:布尔变量集合U={u1,…,un},子句集合C={C1,…,Cm},子句Ct={x[t,1],…,x[t,kt]},其中x[t,j]∈{u1,…,un}∪{u-由于MaxNAE-(k)-SAT实例中,每个子句的布尔变量字母数并不相等,所以需要进一步区分C中i-满足但所含字母总数不同的子句集合.给定布尔变量赋值a(U),设S[b,i]表示含有b个布尔变量字母,且为i-满足的子句集合;C[b,i,j]表示含有b个布尔变量字母,为i-满足,且被uj满足的子句集合;N[b,i,j]表示含有b个布尔变量字母,为i-满足且不被uj满足的子句集合.设MaxNAE-(k)-SAT的子句集合C中,每个子句最多含有kmax个字母,则C中子句可含有k,…,kmax个字母.欲增大C中不全满足的子句数目,考虑利用局部搜索盲目地最大化如下目标函数:kmaxG=∑b=k目标函数G是F的推广.分别考虑C中含有k,…,kmax个字母的子句集合,依照式(1)选择解答MaxNAE-b-SAT实例的目标函数,kbkmax,将这些目标函数相加即得到式(14).类似于式(3)中αi的取值,目标函数G中各个系数取值如下:αb,i=由性质1可知式(15)给出的αb,i满足αb,i=αb,b-i,0ib.给定U的赋值函数a(U),将布尔变量uj的赋值取反,S[b,i]中的子句只可能变为S[b,i+1]或者S[b,i-1]中的子句,不会变为S[b,·]中的子句,b≠b.所以,由i-满足变为(i-1)-满足的子句导致G产生增量:∑ik;由i-满足变为(i+1)-满足的子句导致G产生kmax增量:∑是G因uj赋值取反所产生的增量为b=kΔG=∑因此解答MaxNAE-(k)-SAT的局部搜索步骤与算法1完全相同,只需将While循环中uj赋值取反的条件修改为ΔG>0即可,其中ΔG的计算公式由式(16)给出.当算法运行结束时,任意布尔变量uj赋值取反,总有ΔG0.即kmax∑b=k∑b-1∑i=0(αb,i+1-αb,i)N[b,i,j)]0,1jn(17)将算法1中uj赋值取反条件修改为ΔG>0,并将赋值取反条件修改后的算法重新命名为算法2:MaxNAE-(k)-SAT(U,C).引理3.任给布尔变量赋值函数a(U),则有n|C[b,i,j]|=iS[b,i],∑j=1∑(b-i)|S[b,i]|.证明.设C中含有b个布尔变量字母的子句集合为S[b],则有S[b]=S[b,0]∪S[b,1]∪…∪S[b,b],任意布尔变量赋值取反,S[b]保持不变.由引理1可知该引理成立.引理4.设算法结束时得到布尔变量赋值a(U),则∑S[b,b]).证明.当算法结束时,将任意布尔变量uj赋值取反,目标函数G取值均不增加.那么就有式(17)Page9成立.将式(17)的n个不等式左右分别相加,得到∑j=1∑b-1∑i=0kmax∑b=k∑b-1∑i=0由引理3,将∑n|N[b,i,j]|=(b-i)|S[b,i]|代入式(18)得到∑j=1kmax∑b=k{bαb,1S[b,0]+bαb,b-1S[b,b]+b-1∑i=1[(αb,i-1-αb,i)i+(αb,i+1-αb,i)(b-i)]S[b,i}]0由式(15)可知,αb,1=αb,b-1=(αb,i-1-αb,i)=-(αb,i+1-αb,i)=由式(20)、(21)可推得(αb,i-1-αb,i)i+(αb,i+1-αb,i)(b-i)=-1.将αb,1=αb,b-1=αb,i)i+(αb,i+1-αb,i)(b-i)=-1代入式(19),整理后即得到b=k∑kmax∑kmax∑b=k命题得证.已知MaxNAE-(k)-SAT实例中的子句集合为C,则|C|=∑|S[b,i]|b-1kmax∑b=k∑能比为2k-1i=12k-1-1时间复杂性推得.定理2.算法2解答MaxNAE-(k)-SAT实例的近似性能比不大于2k-1kmax(β(b)2b-1b(m+n)O∑尔变量数目和子句数目,β(b)b/2!.b=k例如,若一个MaxNAE-(4)-SAT实例含有4个字母和5个字母的子句,则利用算法2解答该实例的目标函数应为73|S[5,1]|+若将每个系数均放大为整数,则目标函数为7|S[4,1]|+8|S[4,2]|+7|S[4,3]|+12|S[5,1]|+14|S[5,2]|+14|S[5,3]|+12|S[5,4]|.布尔变量uj赋值取反的条件应为-7|C[4,1,j]|-2|C[4,2,j]|+2|C[4,3,j]|+7|C[4,4,j]|+7|N[4,0,j]|+2|N[4,1,j]|-7|N[4,2,j]|-2|N[4,3,j]|-12|C[5,1,j]|-2|C[5,2,j]|+2|C[5,4,j]|+12|C[5,5,j]|+12|N[5,0,j]|+2|N[5,1,j]|-2|N[5,3,j]|-12|N[5,4,j]|>0.分别取3组MaxNAE-(k)-SAT实例,第1组含有4字母和5字母子句;第2组含有5字母、6字母和8字母子句;第3组含有7、10、11字母子句,以Java编程实现该算法,采用64位浮点数表示目标函数中的系数αb,i,将在U9400笔记本电脑上的实际求解运行时间列在表4中.表4MaxNAE-(犽)-SAT实际求解运行时间(Max、Min分别表示算法求解20个随机生成实例的最大和最小运行时间)k4,55,6,87,10,114解答Max-(犽)-SAT的新近似算法Khanna等人[28]给出了解答Max-k-SAT的局部搜索算法,近似性能比为2k用于解答一般最大k可满足问题.本节我们利用解答MaxNAE-(k)-SAT的局部搜索算法解答一般最大k可满足问题.一般最大k可满足问题简记为Max-(k)-SAT.Max-(k)-SAT的实例与MaxNAE-(k)-SATPage10的实例相同,求解目标则为:寻求U中布尔变量的赋值a:U→{T,F},最大化|{Ct:a(x[t,1])∨…∨a(x[t,kt])=T}|.任一Max-(k)-SAT实例亦可看作MaxNAE-(k)-SAT实例.所以算法2可用于解答Max-(k)-SAT实例.然而这样做还不能保证算法的近似性能比达到2kSAT实例作为MaxNAE-(k)-SAT实例以算法2求解,再将得到的解加以改造,即为原Max-(k)-SAT实例的近似性能比为2k任给Max-(k)-SAT实例,以式(14)做目标函数,利用算法2,可给出一个U的赋值函数a(U).由引理4,赋值函数a(U)使得kmax∑b=k∑i=1b-1(2k-2)min∑kmax若∑|S[b,b]|∑b=kkmax∑b=k∑否则,式(24)未必成立.然而可以利用将所有布尔变量赋值取反,使∑立.由此给出解答Max-(k)-SAT问题的算法如下.算法3.Max-(k)-SAT(U,C).//U为布尔变量集合,C为子句集合1.调用MaxNAE-(k)-SAT(U,C),得到a(U);2.If∑thena(U)←a(U);3.Elsea(U)←a-(U);4.Endif5.Returna(U)在算法3中,a-(U)表示将U中每个布尔变量由a(·)赋予的布尔值取反,得到的U的赋值函数.引理5.设算法3返回布尔变量赋值a(U),S[b,i]表示以赋值函数a(U)为U中布尔变量赋值后,C中含有b个字母且为i-满足的子句集合.则kmax∑b=k∑|S[b,i]|i=1b证明.为更确切地表达赋值函数对C中i-满足子句集合的影响,再设S[f(·),b,i]表示以赋值函数f(U)为U中布尔变量赋值后,C中含有b个字母且为i-满足的子句集合,因此有S[b,i]=S[a(·),b,i].若a(U)=a(U),由引理4知式(23)成立.若a(U)=a-(U),则S[b,i]=S[a-(·),b,i]=S[a(·),b,b-i],0ib,所以,kmax∑b=k∑同理,kmax∑b=kkmax∑所以式(23)仍然成立.另外由算法3可知,无论b=ka(U)=a(U)还是a(U)=a-(U),总有所以,由式(23)和(27)可得到kmax∑b=k∑因∑引理得证.算法3与算法2的时间复杂性相同.因此有如下定理.定理3.算法3解答任意Max-(k)-SAT实例的近似性能比不大于2kkmax(β(b)2b-1b(m+n)O∑尔变量数目和子句数目,β(b)b/2!.b=k5最大不全犽满足问题的近似计算复杂性Hastad[27]曾证明,对于任意k3,不存在解答Max-k-SAT的多项式时间算法,近似性能比小于2k,除非P=NP.我们利用该结果证明,对于任2k-1意k4,不存在解答MaxNAE-k-SAT的多项式时间算法,近似性能小于2k-1定理4.对于任意k4,不存在解答MaxNAE-k-SAT的多项式时间算法,近似性能达到2k-12k-1-1Page11证明.将Max-l-SAT问题归约到MaxNAE-k-SAT,k=l+1.设l3,〈U,C〉是Max-l-SAT的任一实例,构造MaxNAE-(l+1)-SAT实例〈U,C〉如下.U包含U的所有布尔变量,仅比U多一个布尔变量o,即设U={u1,…,un},则U={u1,…,un,o}.将C中每个子句均增加布尔变量字母o,形成C的子句.即设C={C1,…,Cm},其中Ct=(x[t,1],…,x[t,l]),则对应每个Ct,构造一个子句Dt=(x[t,1],…,x[t,l],o),1tm,而C={D1,…,Dm}.设有U的真值指派a(u1),…,a(un),使C中M个子句满足.为o赋值a(o)=F,则a(u1),…,a(un)与a(o)必然使C中恰好M个子句不全满足.这是因为若a(u1),…,a(un)使Ct满足,则其中必有一个布尔变量字母取值为T,又a(o)=F,所以Dt是不全满足的;若a(u1),…,a(un)使Ct不满足,又因a(o)=F,所以Dt也是不满足的.另一方面设有U的真值指派a(u1),…,a(un),a(o)使C中M个子句不全满足,则a(u1)a(o),…,a(un)a(o)必然使C中恰好M个子句满足.理由如下:若a(o)=F,则C中不存在全满足的子句,且a(ui)a(o)=a(ui),1in.若a(u1),…,a(un),a(o)使Dt不全满足,则Dt必有一个布尔变量字母x[t,·]取值为T,所以a(x[t,·])使Ct满足.若a(u1),…,a(un),a(o)使Dt不满足,则Ct中每个字母x[t,·]均取值F,所以Ct也是不满足的.若a(o)=T,则C中不存在不满足的子句,且a(ui)a(o)=a(ui),1in.若a(u1),…,a(un),a(o)使Dt不全满足,则Dt必有一个布尔变量字母x[t,·]取值为F,所以a(x[t,·])使Ct满足.若a(u1),…,a(un),a(o)使Dt全满足,则a(x[t,1]),…,a(x[t,l])使Ct不满足.因此,若存在U的真值指派,使C中M个子句满足,当且仅当存在U的真值指派,使C中M个子句不全满足.设OPT(U,C)与OPT(U,C)分别为C和C中最多可满足的和最多能够不全满足的子句数目,则OPT(U,C)=OPT(U,C).若存在解答MaxNAE-k-SAT的多项式时间算法A,对于任意MaxNAE-k-SAT实例〈U,C〉,总能得到U的真值指派a(U),使C中不全满足的子句数目达到A(U,C)C),则由a(u1)a(o),…,a(un)a(o)为U中布尔变量赋值,可使C中满足的子句数目同样为A(U,C)的结论矛盾.定理4说明本文解答MaxNAE-k-SAT的算法所达到的近似性能比,当k4时是最优的.6结束语本文给出MaxNAE-k-SAT问题的局部搜索算法,近似性能比为2k-1NAE-(k)-SAT问题的局部搜索算法,近似性能比亦为2k-12k-1-1问题,近似性能比可达到2k任意k4,不存在解答MaxNAE-k-SAT的多项式时间算法,近似性能小于2k-1法1解答MaxNAE-k-SAT所能达到的近似性能比是最优的,k4.本文算法的时间复杂性仍是k的指数函数,可认为是关于k的参数化算法.能否设计出解答最大不全k满足问题以及最大k可满足问题的局部搜索算法,使其时间复杂性既是布尔变量个数及子句个数的多项式函数,又是关于k的多项式函数,仍是十分有趣的问题.本文将算法目标函数中系数放大为整数时,给出了放大倍数β(k)的上界,然而这个β(k)的上界的估计值距离实际计算得到的数值仍有较大差距.给出一个目标函数系数放大倍数更紧密的上界,有助于更确切地分析算法的时间复杂性,仍然值得进一步研究.
