Page1类规模对面向对象度量易变性预测能力的潜在混和效应:一个元分析卢红敏周毓明徐宝文(南京大学计算机科学与技术系南京210023)(南京大学软件新技术国家重点实验室南京210023)摘要最近的研究表明,类的规模对面向对象(OO)度量的易变性预测能力存在很强的混和效应,因此需要将其作为一个混和变量来考虑,否则有可能会得到误导性的结果.然而,先前的研究仅仅分析了一个软件系统,因此不清楚这个结论是否可以推广到其他系统上.为解决此问题,文中在102个Java软件系统的基础上利用元分析技术检查类的规模对55个OO度量和易变性之间关联关系的潜在混和效应.对每一个OO度量,首先在单个系统上分别计算在控制规模和不控制规模的两种情况下它与易变性的关联强度.然后,利用随机效应元分析模型计算在所有系统上且分别在这两种情况下它与易变性的平均关联强度.最后,在此基础上利用统计方法检测类规模的潜在混和效应.实验结果表明类规模的混和效应是广泛存在的,因此在验证OO度量的易变性预测能力时确实需要将其作为一个混和变量来考虑.关键词类规模;易变性;混和效应;面向对象;元分析1引言类是面向对象系统的基本模块,有可能随着系统的演化而发生变更.在先前的研究中,研究人员试图利用面向对象(OO)度量来预测系统中容易发生变更的类[1-4].预测易变的类具有重要的实际应用价值,它不仅使得开发人员可提早采取预防性措施来降低软件维护的成本和提高软件的质量,而且也可以使得项目经理能够更有效地分配软件开发资源.对于一个给定的OO度量,人们通常用单变量回归方程分析它与类的易变性之间的关系.如果该度量对应的回归系数是显著的,那么就认为它与易变性之间存在关联,否则认为它们不相关[2,4].我们最近的研究结果指出上述单变量分析方法忽略了类规模的混和效应,有可能会得出误导性的结论,其原因是OO度量通常与类的规模之间存在高度的相关性[5].在Eclipse2.0系统上,我们利用统计方法对当前55个主要的OO度量进行了类规模的混和效应检测.我们的结果表明,对80%以上的OO度量而言,类规模的混和效应都是存在的.特别地,我们发现,在不控制类的规模时,许多OO度量与类的易变性呈现高度的相关性.然而,在控制类的规模后,对30%以上的OO度量而言,它们与易变性之间的关联关系或者消失、或者呈现出相反的关联关系.据此,我们建议后续的研究应该将类的规模作为混和变量来考虑,以免得到不正确的实验结论.尽管上述研究结论具有很重要的意义,但我们只分析了一个软件系统,因而不清楚该结论是否可以推广到其他系统上.为解决此问题,本文利用元分析技术和102个Java软件系统重新检查类的规模对OO度量和易变性之间关联关系的潜在混和效应问题.我们对55个OO度量进行了分析,其中包括18个内聚性度量、20个耦合性度量和17个继承相关的度量.对每一个OO度量,我们首先在单个软件系统上分别计算在控制规模和不控制规模的两种情况下它与易变性的关联强度.然后,我们利用元分析中的随机效应模型计算在所有系统上且分别在这两种情况下它与易变性的平均关联强度[6].最后,我们在此基础上利用统计方法检测类规模的潜在混和效应.我们的实验结果证实类规模的混和效应是广泛存在的,因此在验证OO度量的易变性预测能力时确实需要将其作为一个混和变量来考虑.本文第2节介绍元分析技术中的随机效应模型;第3节描述本文所采用的研究方法,包括数据来源、独立变量、依赖变量和数据分析方法;第4节给出详细的实验结果;第5节对本文的工作进行总结并对将来的工作进行展望.2元分析技术元分析是一种用来将多个“研究”的结果进行合并的统计方法[6].其中,“随机效应模型”是最常用的一种元分析模型,它同时考虑“研究内方差”和“研究间方差”.根据文献[6],单个“研究”中的结果称为“可观察效应值”,它是“真实效应值”的一个估算量.对每一个OO度量,本文利用102个Java系统分析类规模对它与易变性之间关联强度的混和效应.此处,每一个Java系统是随机效应模型中的一个“研究”,关联强度是“效应值”.在随机效应模型中,不同“研究”中的“真实效应值”被假定为是不同的,并且服从一个正态分布(下文称它的平均值为“总平均值”).因此,对任一“研究”而言,其“可观察效应值”与“总平均值”之间的偏差由两部分构成:“真实效应值”与“总平均值”间的偏差和“可观察效应值”与“真实效应值”间的偏差.换句话说,每个“研究”的“可观察效应值”的方差可划分成“研究间方差”和“研究内方差”两部分:前者刻画各“研究”间“真实效应值”的差异,后者刻画每个“研究”内部的样本误差.元分析的目标是利用统计方法综合各“研究”的“可观察效应值”,得到一个“平均效应值”,用来估算“总平均值”.最近,元分析技术在软件工程中得到了许多应用[7-10].设k是元分析中“研究”的数目,μ是这些“研究”的“真实效应值”的“总平均值”.对第i个“研究”(1ik),假设Yi、ζi和εi各自表示它的“可观察效应值”、“真实效应值”与“总平均值”μ的偏差以及“可观察效应值”与“真实效应值”的偏差.那么,可得其中,E(εi)=0、Var(εi)=σ2τ2.此处,E(·)代表一个变量的期望值,Var(·)代表一个变量的方差,σ2差”,τ2是“研究间方差”.由此,可知Yi的方差为Var(Yi)=Var(εi)+Var(ζi)=σ2注意,上述公式中Var(Yi)、σ2在实践中要用样本值来代替.具体而言,当用样本值i和T2各自替换式(2)中的σ2s2Var(Yi)的样本估算值Vi:其中Page3在式(4)中,df、Q和C各自表示自由度、总方差和比例因子:其中,Wi=1/s2的“可观察效应值”进行方差倒数加权的方式计算k个“研究”的“平均效应值”M及其方差VM:在上述公式中,Wi=1/Vi为第i个“研究”的权值(1ik).如前所述,随机效应模型假定“可观察效应值”中的方差由真实的方差(“研究间方差”)和样本误差(“研究内方差”)组成.在元分析中,这种真实的方差称作异质性.通常用I2来刻画在“可观察效应值”的方差中有多大比例来源于真实的方差,也就是“研究”间异质性的程度:当I2小于等于25%时,表示具有低的异质性;当I2介于25%与50%之间时,表示具有中等的异质性;类别系统表1102个Java系统的描述性信息科学/工程9100824.630.166579310.0200.2674104329.2197.066474271.1184.9格式和协议1888.0N/A284284284.0N/A287287287.0N/A284284284.0N/A数据库1135715.510.8285866732.0882.5290777773.8888.5284565614.8827.5办公/业务1067917.817.41119178649.3336.51544238781.2483.9110691566.1390.9系统1038816.79.4111878489.1376.01286111520.2404.285169339.9246.0游戏/娱乐313810.32.524352163.799.539578222.7160.319544139.783.2软件开发25139720.326.4142370425.2354.6152785471.3370.5114038351.0295.6通讯937618.310.92187105476.8650.42368104537.2695.42150104440.3644.9多媒体648920.514.5870118459.3281.5885162489.3292.8868110442.2288.7文本编辑器1474747.0N/A475475475.0N/A475475475.0N/A437437437.0N/A因特网17123533.134.2284965621.4823.2360566689.3957.0238143585.4749.4总计102139521.423.1285852507.0544.9360566560.7601.2284538438.7503.3当I2大于等于75%时,表示具有高的异质性[6].3研究方法本节首先给出数据来源,然后介绍独立变量和依赖变量,最后详细描述所采用的数据分析方法.3.1数据来源我们从http://sourceforge.net/上下载了102个开源的Java软件系统作为实验对象.与文献[7]中的方法一致,我们在选择这些系统时对它们的规模和类型事先没有做任何要求,只要求其实现语言是Java.对每个Java系统,我们下载了一个稳定的主版本中的两个子版本.根据文献[2],一个主版本的两个子版本所涉及的变更主要由修正性变更组成,它是由模块的结构特性而不是外部因素驱动的.因此,对每一个Java类,这两个子版本间的代码行变更量实际上反应了由结构特性驱动的变更程度.为方便起见,下文中将版本号小的子版本称为老版本,将版本号大的子版本称为新版本.http://sourceforge.net/将Java开源软件系统分成20个类别,每个类别覆盖若干主题.前9个类别分别为软件开发、因特网、科学/工程、游戏/娱乐、通讯、办公/业务、系统、多媒体和数据库,它们占该网站上全部Java系统的80%以上.特别地,对每个Java系统,http://sourceforge.net/用一个列表给出它所属的类别.换句话说,同一个Java系统可同时属于不同的类别.为简单起见,对每一个系统,本文将其列表中列出的第一个类别作为它的类别.表1给出了这102个Java系统的描述性信息,其中给出了每个类别中系统的数目、开发人员数目的分布、老版本中类的数目的分布、新版本中类的数目的分布以及同时出现在新老版本中类的数目的分布.此处,N/A表示“不能应用”.最大值最小值平均值标准差Page4在每个Java系统上,我们生成一个对应的数据集.因此,总共得到102个数据集.在每一个数据集中,每个数据点表示一个同时出现在老版本和新版本中的Java类,它由如下成分组成:(1)在老版本中该Java类上收集的一组OO度量值;(2)该Java类从老版本向新版本演化时发生的SLOC变更量.为收集上述数据,我们首先利用程序理解工具“UnderstandforJava”扫描老版本和新版本的Java系统,得到两个对应的Understand数据库.这两个数据库各自提供了老版本和新版本Java系统中的实体(如方法、属性和类)和引用(如调用关系和继承关系)信息.然后,我们利用UnderstandforJava提供的Perl接口开发了一个Perl程序,访问这两个Understand数据库,为那些同时出现在老版本和新版本中的Java类收集各种度量信息.对每一个这样的Java类,Perl程序访问老版本系统的Understand数据库计算各种OO度量值.为得到该Java类从老版本向新版本演化时发生的SLOC变更量,Perl程序第1步访问Understand数据库,获得它在老版本和新版本系统中对应的源代码,第2步利用一个UNIXdiff算法变体比较两个版本的源代码,以统计增加的、删除的和修改的源代码行.第3步,Perl程序利用如下规则计算SLOC变量[4]:(1)每一被增加的或者被删除的代码行计为1个SLOC变更;(2)每一被修改的代码计为2个SLOC变更.具体而言,对一个Java类,如果在从老版本系统演化到新版本系统的过程中增加了x行代码、删除了y行代码并且修改了z行代码,那么它所对应的总SLOC变更量为x+y+2×z.此处,每行被修改的代码之所以被记为2个SLOC变更,是因为可以将它看成是先删除一行代码然后再增加一行代码.3.2依赖变量本文的依赖变量是类级的易变性,它是一个非常重要的外部质量属性,指一个类在跨版本演化时所发生的变更程度.与前人的研究一样,我们使用一个类从老版本向新版本演化时发生的SLOC变更量作为易变性的代理变量.当然,也可以采用其他代理变量,例如一个类从老版本向新版本演化时发生的修改次数.然而,用SLOC变更量作为易变性的代理变量不仅能反映每个类的被修改频率,而且也能反应它的被修改程度[2].从这个角度而言,用SLOC变更量作为代理变量更合适.3.3独立变量本文的独立变量由2个规模度量和55个OO度量组成.我们利用NMIMP和SLOC作为规模度量来调查类规模对55个OO度量的易变性预测能力的潜在混和效应.其中,NMIMP是一个类中实现的方法数目,SLOC是一个类中所包含的非注释行、非空白行的源代码行数.这55个OO度量由3个度量维组成,包括18个内聚性度量、20个耦合性度量和17个继承相关度量(请参见附录A).我们之所以选择这55个度量,主要原因在于它们是软件工程文献中被广泛分析的度量[11-14].选择这些主流的OO度量可以使得我们的实验分析结果更具有代表性和实际应用价值.3.4数据分析方法在3.4.1节中,我们介绍在单个软件系统上建模混和效应模型.在3.4.2节中,我们详细描述如何利用元分析方法综合多个系统上的混和效应得到平均的混和效应,并给出其统计上的检测方法.3.4.1混和效应模型假定X是独立变量(一个OO度量)、Y是依赖变量(易变性的代理变量,即SLOC变更量)、Z是第三方变量(类规模度量NMIMP或SLOC).混和效应是指X和Y之间的关联关系被Z扭曲了,它包括两种情况[5,15]:X和Y间存在关联的原因可部分或者全部由Z来解释,或者X和Y之间不存在关联的原因是没有考虑Z的影响.第三方变量Z通常称为混和变量,它可导致人们高估或者低估X和Y之间真正的关联关系.在基于线性回归的混和效应模型中,X、Y和Z之间的关系可以用如下等式描述:其中,β0、β0和β0为回归截距,e、e和e为余差,τ代表不控制Z时X和Y之间的关系,τ代表控制Z时X和Y之间的关系,γ代表控制X时Z和Y之间的关系,β代表X和Z之间的关系.注意,上述参数都是种群值,在实践中要替换为样本值.由上述公式,我们可得到由此可见,第三方变量Z导致X和Y之间关联关系的扭曲程度为βγ.只要β和γ都不为0,那么τ和τ就不相等.在先前的文献中,τ被称为“总效应”,τ被称为“直接效应”,βγ被称为“间接效应”.如果Z导致高估了X和Y间的关联强度,那么它是“正的混和变量”.相反,如果Z导致低估了X和Y之间的关联强度,那么它是“负的混和变量”.在极端情况下,一个负的混和变量不仅会导致关联强度的改变,而且会导致关联方向的改变.Page5为便于描述混和效应的元分析过程,下面假定Xs、Ys和Zs各自是X、Y和Z对应的标准化变量(减去平均值再除以标准差).由式(14)可得其中,τs、τs、βs和γs分别为τ、τ、β和γ所对应的标准化回归系数.对一个给定的数据集,假设N是其数据点数目,rXY、rXZ和rYZ分别为X和Y、X和Z、Y和Z间的样本皮尔森相关系数,那么总效应τs的样本估算值为它的方差为直接效应τs的样本估算值为它的方差为其中间接效应βsγs的样本估算值为它的方差为其中[犪=r2熿cov(rXZ,rXY)var(rXY)cov(rZY,rXY)Φ=cov(rXZ,rZY)cov(rZY,rXY)var(rZY燀对任意2个变量a和b而言,它们的样本皮尔森相关系数rab的方差为对任意3个变量a、b和c而言,两个相关系数rab和rac的协方差为cov(rab,rac)=0.5×(2rbc-rabrac)(1-r2ab-r2ac-r2bc)+r3bc3.4.2混和效应的元分析过程我们使用随机效应模型计算102个系统上平均的“总效应”、“间接效应”和“直接效应”,在此基础上利用统计方法检测规模度量Z是否对OO度量X和易变性度量Y之间的关联存在混和效应.如图1所示,这个元分析过程由3步组成.第1步,对102个数据集(每个数据集对应一个Java系统)进行预处理,排除掉X的非零数据点数目少于6个的数据集(每个数据点对应一个Java类).先前的研究文献也采用了相同的处理方法,原因是一个方差很小的OO度量其预测能力必然很有限.因此,在进行后续的分析前,我们先排除掉这样的数据集.第2步,首先在单个数据集上利用式(16)和(17)计算标准化的总效应及其方差、利用式(18)和(19)计算标准化的直接效应及其方差、利用式(21)和(22)计算标准化的间接效应及其方差.如3.4.1节所述,这些公式都建立在皮尔森相关系数的基础上.皮尔森相关系数要求数据服从正态分布,但我们得到的大多数OO度量数据都与正态分布相差甚远.因此,为解决上述问题,我们不直接计算皮尔森相关系数,而采用通过斯皮尔曼相关系数逼近的方法.具体而言,对一对变量,我们首先计算出它们的斯皮尔曼相关系数ρ,然后利用如下公式来得到它们的皮尔森相关系数r[5]:在得到这些效应及方差后,我们利用随机效应模型计算平均的标准化总效应PSTE、平均的标准化直接效应PSDE以及平均的标准化间接效应PSIE.第3步,检查规模度量Z是否对OO度量X和易变性度量Y之间的关联存在混和效应.如果存在混和效应,进一步识别其方向并判断是否“污染”①了X的验证结果:(1)检查是否存在混和效应.如果平均的标准化间接效应的种群值不为0(即PSIE的p值小于0.05),则Z存在混和效应,否则不存在混和效应.(2)识别混和效应的方向.如果平均的标准化直接效应的种群值为0(即PSDE的p值大于或等于0.05),则Z的混和效应方向为“正”.否则,当平均的标准化直接效应PSDE和平均的标准化间接效应PSIE具有相同的方向时存在“正”的混和效应,①当下述3种情况之一出现时,称X的验证结果被“污染”Page6图1类规模对一个OO度量易变性预测能力的潜在混和效应的元分析过程当它们具有相反的方向时具有“负”的混和效应.(3)判断X的验证结果是否被“污染”.当出现下述3种情况之一时,X的验证结果被“污染”了:①平均的标准化直接效应的种群值为0;②平均的标准化直接效应的种群值不为0,但平均的标准化总效应的种群值为0;③平均的标准化直接效应和平均的标准化总效应的种群值都不为0,但它们的方向相反.我们利用Perl语言编写了一个元分析工具,实现图1所描述的元分析过程.在实际分析时,我们用一个文本文件列出102个数据集的名称,该工具访问该文本文件,依次读入相应的数据集,然后进行预处理和元分析工作,最后报告在每一个规模度量下的混和效应方向以及污染情况.4实验结果4.1节给出混和效应元分析的详细实验结果,4.2节讨论并分析效度威胁.4.1混和效应分析表2汇总了类规模的潜在混和效应的元分析结果.对每一个OO度量:(1)第2列给出了实际参与元分析的“研究”数目;(2)第3列给出了平均的标准化总效应的样本值、它的p值以及异质性度量I2;(3)第4列和第5列分别给出了在规模度量NMIMP和SLOC下的平均的标准化直接效应的样本值、它的p值以及异质性度量I2;(4)第6列和第7列分别给出了在规模度量NMIMP和SLOC下的平均的标准化间接效应的样本值、它的p值以及异质性度量I2;(5)第8列和第9列分别给出了在规模度量NMIMP和SLOC下的混和效应方向.此处,“+”表示OO度量验证结果没有被“污染”的正的混和效应,“”表示OO度量验证结果被“污染”的正的混和效应,“-”表示OO度量验证结果没有被“污染”的负的混和效应,“”表示OO度量验证结果被“污染”的负的混和效应,“0”表示不存在混和效应.由表2,我们可以观察到:(1)内聚性度量.当SLOC作为类规模度量时,Co的平均的标准化间接效应种群值为0.在其他情况下,所有内聚性度量的平均的标准化间接效应的种群值都不为0.因此,对Co而言,当用NMIMP作Page7表2混和效应的元分析结果SLOC面向对象度量kLCOM11020.311(<0.01)LCOM21020.253(<0.01)LCOM31020.248(<0.01)LCOM41020.098(<0.01)Co1020.022(0.099)Co102-0.047(<0.01)LCOM51000.171(<0.01)Coh100-0.254(<0.01)TCC102-0.057(<0.01)LCC102-0.028(0.070)ICH1020.334(<0.01)OCC1020.117(<0.01)PCC1020.101(<0.01)DCD102-0.054(<0.01)DCI102-0.022(0.154)CAMC102-0.297(<0.01)NHD1010.234(<0.01)SNHD101-0.147(<0.01)CBO1020.365(<0.01)RFC1020.307(<0.01)MPC1020.350(<0.01)DAC1020.290(<0.01)ICP1020.349(<0.01)IH-ICP970.063(<0.01)NIH-ICP1020.363(<0.01)ACAIC300.012(0.314)ACMIC430.010(0.390)DCAEC3<0.001(0.995)DCMEC120.030(0.039)-0.006(0.679)I2:81.9920.017(0.178)I2:80.9870.025(0.049)I2:82.7390.012(0.269)I2:83.6780.014(0.199)I2:83.080-0.003(0.772)I2:83.7810.029(0.019)I2:79.302-0.036(0.009)I2:78.9670.013(0.270)I2:84.9600.008(0.512)I2:87.3260.044(0.01)I2:87.267-0.025(0.071)I289.409-0.023(0.074)I2:87.1080.012(0.303)I2:83.7550.008(0.530)I2:86.498-0.020(0.207)I2:87.0310.030(<0.01)I2:73.290-0.012(0.206)I2:73.5620.179(<0.01)I2:91.8560.122(<0.01)I2:90.9300.145(<0.01)I2:88.5560.042(<0.01)I2:84.1280.147(<0.01)I2:89.5070.053(<0.01)I2:89.4830.155(<0.01)I2:89.482-0.014(0.150)I2:64.554-0.009(0.372)I2:68.4210.004(0.792)I2:00.010(0.357)I2:37.042Page8SLOC面向对象度量kOCAIC1020.290(<0.01)OCAEC990.130(<0.01)OCMIC1020.325(<0.01)OCMEC980.064(<0.01)AMMIC970.065(<0.01)DMMEC870.072(<0.01)OMMIC1020.361(<0.01)OMMEC1020.142(<0.01)CBI9100.62(<0.01)DIT102-0.034(0.01)AID102-0.034(0.01)CLD910.049(<0.01)NOC910.048(<0.01)NOP101-0.037(<0.01)NOD910.048(<0.01)NOA102-0.034(0.01)NMO970.041(0.01)NMI980.015(0.290)NMA1020.309(<0.01)SIX970.016(0.253)SPA770.099(<0.01)SPD640.094(<0.01)SP870.130(<0.01)DPA970.040(0.013)DPD860.079(<0.01)DP980.070(<0.01)为类规模度量时存在混和效应.对其余的内聚性度量而言,无论用NMIMP还是SLOC作为类规模度量,总是存在混和效应.在大多数情况下,类规模呈现出“正”的混和效应.对一些内聚性度量而言,这种正0.042(<0.01)I2:84.6050.036(<0.01)I2:83.0660.026(0.084)I2:82.0930.017(0.095)I2:81.7420.052(<0.01)I2:88.6230.029(<0.01)I2:73.2590.152(<0.01)I2:89.2740.026(0.025)I2:84.9880.025(<0.01)I2:69.8260.019(0.076)I2:82.1680.019(0.076)I2:82.1680.025(<0.01)I2:68.7570.025(<0.01)I2:67.2400.011(0.282)I2:79.2400.025(<0.01)I2:67.0410.019(0.076)I2:82.1680.030(0.019)I2:89.0970.052(<0.01)I2:83.672-0.043(0.018)I2:86.8180.021(0.049)I2:83.6320.040(<0.01)I2:79.5020.042(<0.01)I2:71.2080.056(<0.01)I2:80.7280.030(0.018)I2:89.0610.031(<0.01)I2:70.3510.041(<0.01)I2:88.961的混和效应非常强以至于完全解释了它们与易变性之间的关联关系.例如,在控制NMIMP或者SLOC后,LCOM2、OCC、PCC和SNHD与易变性之间的关联完全消失.此外,类规模的“负”的混和效应不仅Page9有可能导致关联强度的改变,而且也有可能会导致关联方向的改变.例如,在控制NMIMP前,LCOM4与易变性正相关;在控制NMIMP后,LCOM4与易变性负相关.内聚性度量的实验结果表明:①当NMIMP作为类规模度量时,LCOM2、LCOM4、Co、Co、TCC、LCC、OCC、PCC、DCD、DCI和SNHD的验证结果被“污染”;②当SLOC作为类规模度量时,LCOM1、LCOM2、LCOM4、Co、TCC、OCC、PCC、DCD、CAMC和SNHD的验证结果被“污染”.(2)耦合性度量.DCAEC的平均的标准化间接效应种群值为0.在其他情况下,所有耦合性度量的平均的标准化间接效应的种群值都不为0.因此,对DCAEC而言,类规模度量不存在混和效应.对其余的耦合性度量而言,总是存在混和效应.耦合性度量的实验结果表明:①当NMIMP作为类规模度量时,DCMEC、OCMEC、DMMEC、OMMEC和CBI的验证结果被“污染”;②当SLOC作为类规模度量时,DCMEC、OCMIC和OCMEC的验证结果被“污染”.(3)继承相关度量.当SLOC作为类规模度量时,SIX的平均的标准化间接效应种群值为0.在其他情况下,所有继承相关度量的平均的标准化间接效应的种群值都不为0.因此,对SIX而言,当用NMIMP作为类规模度量时存在混和效应.对其余的继承相关度量而言,无论用NMIMP还是SLOC作为类规模度量,总是存在混和效应.继承相关度量的实验结果表明:①当NMIMP作为类规模度量时,DIT、AID、CLD、NOC、NOP、NOD、NOA、NMO、NMI、NMA、DPA、DPD和DP的验证结果被“污染”;②当SLOC作为类规模度量时,DIT、AID、NOP、NOA、NMI和NMA的验证结果被“污染”.表3汇总了类规模的潜在混和效应的元分析结果.其中,表3(a)给出了在各度量维上混和效应方向的分布,表3(b)给出了在各度量维上OO度量验证结果“污染”程度的分布.此处,“正”指“+”或者“”,“负”指“-”或“”,强“正”指“”,强“负”为“”.从表3,我们可以观察到:(1)在每个度量维上,类规模对超过90%的OO度量都具有混和效应.当不区分度量维时,类规模对95%以上的OO度量具有混和效应.(2)在每个度量维上,类规模对超过60%的OO度量具有“正”的混和效应.当不区分度量维时,类规模对超过80%的OO度量具有“正”的混和效应.(3)对内聚性度量和继承相关的度量而言,至少有30%的OO度量的验证结果被“污染”.当不区分度量维时,至少有35%的OO度量的验证结果被“污染”.(4)对内聚性度量和继承相关的度量而言,在控制类的规模后,至少有22%的OO度量与易变性的相关性消失.当不区分度量维时,在控制类的规模后,至少有30%的OO度量与易变性的相关性消失.表3类规模潜在混和效应的元分析结果汇总类别内聚性度量6139940耦合性度量950950继承相关度量9468212所有度量8415914类别内聚性度量强“正”强“负”强“正”强“负”耦合性度量2239560继承相关度量250150所有度量7162412上述结果表明:(1)对OO度量而言,类规模的混和效应是普遍存在的,在大多数情况下会导致人们高估它们与易变性之间的关联关系;(2)许多OO度量的验证结果被类规模的混和效应“污染”了,其中最常见的“污染”是类规模的混和效应导致OO度量与易变性之间具有虚假的关联关系.4.2效度威胁效度指实验结论的真实性程度和有效性程度,主要包括建构效度、内部效度和外部效度.建构效度指依赖变量和独立变量在多大程度上准确地度量了它们所要代表的概念.内部效度指自变量和因变量之间关系的确定性程度,涉及到实验结论的真实性程度.外部效度指自变量和因变量之间关系的可推广性程度,涉及到实验结论的代表性程度.4.2.1建构效度的威胁本文的依赖变量是一个类的两个子版本间的SLOC变更量.在文献[2]中,Arisholm等人手动检查了Java软件中同一个主版本下的两个子版本间的变更情况,发现它们是由结构性变更组成的.据此,以两个子版本间的SLOC差异作为依赖变量来分析OO度量的易变性预测能力具有一定的合理性.然而,在软件维护实践中,维护人员可能会由于版本发布计划、可用资源等外部条件的因素而将一些结构修正推迟进行,从而有可能会影响分析结果.实际上,这一问题是软件度量实证研究难以避免的通用问题.例如,在验证OO度量的缺陷预测能力Page10时,许多文献以软件发布后一个固定时间段长度(例如6个月)内报告的bug数目作为依赖变量[16].在实践中,时间段长度的选取必定会影响分析结果.我们计划在后续研究中以跨度更大的子版本为实验对象,分析这一威胁对实验结果的影响.本文的独立变量是2个规模度量和55个OO度量,先前的文献已对它们的建构效度进行了调查[11-12,17-18].特别地,我们利用商业工具UnderstandforJava提供的API收集度量数据,在一定程度上保证了度量数据收集的可靠性.4.2.2内部效度的威胁本文实验结论的内部效度存在3个可能面临的威胁.第1个威胁是依赖变量计算规则的未知影响.在先前的分析中,每一被增加的或者被删除的源代码行被计为1个SLOC变更,每一被修改的源代码行被计为2个SLOC变更(下文称对应的依赖变量为“TS变更”).为检查计数规则对实验结论的影响,我们使用3个附加的计数规则生成3个依赖变量:(1)“AS变更”.只对被增加的源代码行计数,每一被增加的源代码行被记为1个SLOC变更;(2)“DS变更”.只对被删除的源代码行计数,每一被删除的源代码行被记为1个SLOC变更;(3)“MS变更”.只对被修改的源代码行计数,每一被修改的源代码行被记为1个SLOC变更.图2给出了在4个不同依赖变量下102个数据集的Java类上的SLOC变更量的分布情况.在每一个特定的数据集上,每一SLOC变更量区间(0、1~10、11~20、21~30、31~50、51~100、101~200图3不同依赖变量下的元分析实验结果和>200)的分布用一个百分比表示.由于总共有102个数据集,对每一给定的SLOC变更量区间而言,总共有102个百分比,我们因此用一个箱线图描述其总体分布.例如,对于SLOC变更区间“1~10”,102个数据集上“AS变更”分布的中位值为10.96%,第三四分位数为17.65%,第一四分位数为5.73%.由图2的SLOC变更区间0上的分布可以看出,不管对哪一种依赖变量,超过50%以上的数据集中有65%以上的Java类在系统版本演化过程中没有发生变更.图2不同依赖变量下的类的SLOC变更量分布图3给出了在不同依赖变量下的实验分析结果.从图3(a)可以看出,当NMIMP或者SLOC作为类规模度量时,不管在哪个依赖变量下,类规模的混和效应对90%以上的OO度量都存在,其中主要是“正”的混和效应.从图3(b)可以看出,当NMIMP或者SLOC作为类规模度量时,不管在哪个依赖变Page11量下,30%以上的OO度量的验证结果都被“污染”了,其中大部分度量与易变性之间的关联都是虚假的.总体上,上述结果表明依赖变量的计算规则对我们的实验结论没有大的影响.第2个威胁是类规模度量的选择对实验结论的未知影响.在前文中,我们只使用NMIMP和SLOC作为类规模的度量.为调查这个威胁,我们使用如下类规模度量重新分析潜在混和效应:(1)NM.一个类中的方法总数,包括继承的方法和非继承的方法;(2)NAIMP.类中属性的数目(排除继承的属性);(3)NA.类中的属性总数,包括继承的和非继承的;(4)Stmts.类的所有方法中语句总数,包括声明语句和可执行语句.图3给出了不同的类规模度量下的实验结果,容易看出:(1)不管对哪个依赖变量使用哪个规模度量,类规模的混和效应对90%以上的OO度量都存在;(2)对除NA外的其他规模度量而言,20%以上的OO度量的验证结果都被类规模的混和效应“污染”了.由此可知,类规模度量的选择对我们的实验结论也没有实质性的影响.第3个威胁是斯皮尔曼相关系数到皮尔森相关系数的转换对实验结论的未知影响.在先前的分析中,我们首先将斯皮尔曼相关系数转换为皮尔森相关系数,然后在此基础上计算“总效应”、“直接效应”和“间接效应”并进行元分析.由于在我们的数据集上,大多数OO度量值都不服从正态分布,因此这种处理是合适的.尽管如此,有人可能会认为这种变换实际上是不必要的,因为皮尔森相关系数具有一定的鲁棒性,数据是否服从正态分布对其影响不大.为消除这个威胁,我们直接使用皮尔森相关系数重新分析类规模的混和效应,发现实验结果非常类似.因此,这种转换对我们的实验结论的影响也很小.4.2.3外部效度的威胁本文实验结论的外部效度存在3个可能面临的威胁:第1个威胁是所得的实验结论可能只对特定类别的软件系统适用.在实验中,我们在选择这102个系统时,事先没有对它们的规模和类型做任何要求,只要求其实现语言是Java,这与前人的系统选择方法是一致的[7].如前文所述,这些软件系统涵盖了软件开发、因特网、科学/工程、游戏/娱乐、通讯、办公/业务、系统、多媒体和数据库等主要类别,在这些数据集上得出的结论不太可能只对特定类别的软件系统适用;第2个威胁是所得的实验结论有可能不能推广到其他系统上.在前文的分析中,我们使用了元分析中的随机效应模型来进行分析.根据文献[6],随机效应模型不仅考虑了“研究”(即系统)内的样本误差,也考虑了“研究”间的差异,因此所得的结论可以推广到其他“研究”上;第3个威胁是所得的实验结论可能只对Java软件系统适用,而不能推广到其他语言实现的软件系统上.我们只使用了Java软件系统的数据进行分析,其他语言实现的系统在结构特性上有可能有差别,这一威胁有待在将来的工作中进一步调查.5结束语我们最近的研究指出类的规模对OO度量的易变性预测能力具有很强的混和效应,因此需要将其作为混和变量来考虑,这对正确地分析OO度量与易变性之间的关系具有重要的实际意义.但我们先前的研究只分析了一个软件系统,其结论是否能够推广到其他系统上需要进一步调查.为此,本文采用元分析方法和102个Java系统上的数据对类规模的混和效应进行了更细致的分析.我们的实验结果证实和强化了先前的结论:类规模的混和效应是广泛存在的,而且在大多数情况下会导致高估OO度量的易变性预测能力.因此在OO度量易变性预测能力研究中,人们确实需要考虑类规模这个混和变量,以便得出正确的结论.在将来的工作中,我们计划对软件缺陷预测上下文中的规模混和效应进行元分析研究[19].
