Page1一种基于环切割的约束满足问题求解算法李占山李宏博张永刚王孜文(吉林大学符号计算与知识工程教育部重点实验室长春130012)(吉林大学计算机科学与技术学院长春130012)摘要该文首先给出一种无环约束满足问题的无回溯搜索算法Tree_Search,然后将环切割思想嵌入到目前最流行的MAC3rm算法中,给出一种新算法CCS.CCS将原回溯搜索过程分为两部分:第1部分通过回溯搜索求解环切割集中变量,将原问题化简成一个满足弧相容的无环问题;第2部分通过无回溯的Tree_Search算法求解化简后的无环问题,改进了MAC3rm算法.证明了MAC3rm算法在环切割集上求得的局部解一定可以扩展为一个全局解,并且如果原问题无解,则MAC3rm算法在环切割集上找不到局部解.实验结果显示,CCS的效率在大多数情况下高于MAC3rm.在求解随机问题相变阶段的测试用例时,CCS的效率最高可以达到MAC3rm的140倍.Benchmark中几组问题的测试结果显示,CCS在整体上效率高于MAC,最高可以达到MAC3rm的100倍以上.关键词弧相容;无回溯搜索;环切割;MAC3rm1引言约束满足问题(ConstraintSatisfactionProblem,CSP)[1]在人工智能领域有着广泛的应用,许多实际应用问题都可以用CSP进行建模,如调度问题、配置问题、图着色问题等等.约束满足问题求解一直是约束程序研究领域的难点,寻找一个CSP问题的解是一个NP完全问题.深度优先的回溯搜索算法(Backtracking,BT算法)[2]是CSP求解的一个完备的核心算法.为了提高求解效率,通常在求解前和求解过程中使用约束关系删除变量值域中一些不参与解的值,这个过程称为约束传播[3]或者相容性技术.常见的完备求解算法都是在BT算法搜索过程中加入约束传播技术,如向前检查算法(ForwardChec-king,FC)[4]、维持弧相容算法(MaintainingArcConsistency,MAC)[5].其中MAC算法是应用的最广的,并且在求解大规模难解问题时有着明显的优势.MAC算法是在BT算法中嵌入弧相容算法(ArcConsistency,AC)[6],通过弧相容算法进行约束传播,达到高效的剪枝目的.MAC算法的求解效率主要受两方面因素的影响,一是在求解过程中使用的AC算法本身的效率,另外一个因素是AC算法使用的数据结构的复杂程度,因为在求解过程中需要维护一部分数据结构,数据结构较复杂时,维持这些数据结构要消耗更多的时间.AC3[6]是早在1977年被提出的,它是最简单、最基本的AC算法,也是在求解中应用最广泛的.在AC3的基础上,一些改进算法被提出,如AC4[7]、AC6[8]、AC7[9]、AC2001[10]等.这些算法虽然有着较优的最坏时间复杂度,但由于其本身数据结构复杂,因此在求解中的应用效果并不是很理想.2007年Lecoutre等人[11]提出了AC3rm,AC3rm使用和AC3.1类似的数据结构,但是在求解过程中只维护和AC3相同的最简单的数据结构,是目前普遍认为在MAC算法中应用效果最好的AC算法.除AC算法以外,其它的约束传播技术如SingletonArcConsistency[12-13]、k-consistency[3]等,都可以实现比AC算法更高效的剪枝,但它们都比AC算法有着更高的时间复杂度和更复杂的数据结构,因此在求解中很少被应用.除此以外,我国学者孙吉贵等人[14]曾于2008年在MAC算法基础上提出了一种基于预处理技术的约束满足问题求解算法BT+MPAC.该方法虽然没有AC算法剪枝效果好,但是本身的时间复杂度低于AC,并且求解过程中维持的数据结构也很简单,在一些测试用例中,BT+MPAC比MAC算法效率更高,其主要缺点在于需要在求解前执行预处理.Freuder[15]于1982年提出无回溯搜索的充分条件以后,一些关于无回溯搜索的思想相继出现.如文献[16-17],但这些无回溯搜索算法主要是针对特定类型的问题,如树形结构、配置问题等.普通约束满足问题的无回溯搜索需要在求解过程中维持高阶相容[15],但是维持高阶相容本身要消耗大量时间,因此很少被采用.除了无回溯思想以外,基于将问题分解进而提高求解效率的方法也相继被提出[18-19],其中Dechter[20]于1990年提出了环切割集的概念,但是Dechter关于环切割的方法,在为环切割集中变量找到局部解后,不能保证这个局部解一定可以扩展成一个全局解.本文首先给出一种Tree_Search搜索算法,它应用于约束图是树形结构的并且满足弧相容的二元问题上可以实现无回溯搜索,然后将环切割集的思想与目前最流行的求解算法MAC3rm[11]相结合,给出一种新的搜索算法(Cycle_Cut_Search,简称CCS算法).我们还提出了环切割化简定理,证明了通过MAC3rm算法寻找到的环切割集上的局部解,一定可以扩展成一个全局解,并且如果原问题无解,则MAC3rm算法无法找到环切割集上的局部解.基于环切割化简定理,CCS算法将原MAC3rm算法的全局回溯搜索过程分为两部分:第1部分在环切割集上用MAC3rm算法回溯搜索局部解;第2部分通过Tree_Search无回溯搜索算法将局部解扩展为全局解.通过环切割化简的方式改进了MAC3rm算法.我们的实验结果显示,CCS的效率在大多数情况下高于MAC3rm.在求解随机问题相变阶段的测试用例时,CCS的效率最高可以达到MAC3rm的140倍.Benchmark中几组问题的测试结果显示,CCS在整体上效率高于MAC,最高可以达到MAC3rm的100倍以上.2相关知识介绍定义1.约束满足问题[1].一个约束满足问题P由3个部分组成:P=〈X,D,C〉,其中X={x1,x2,…,xn}是一个有限的变量集合;D={D1,D2,…,Dn},其中Di∈D对应xi∈X,是变量xi的有限值域,C={c1,c2,…,ck}是一个有限约束集合,其中任意cj∈C表示变量取值之间的制约关系.如果C中所有约束包含的变量个数都小于等于2,则称P为二元约束满足问题.一个约束满足问题的解Page3是为每个变量在其值域中选择一个值构成集合S,使得S中的所有变量取值满足C中所有约束.本文中用P表示一个约束满足问题,S表示P的一个解,PX表示P的变量集,PC表示P的约束集,(x,a)表示x的取值为a,n表示P中包含的变量个数,d表示P中最大的变量值域的大小.定义2.局部解.给定一个约束满足问题P=〈X,D,C〉,X是X的一个子集,如果对于X中所有变量,都能找到对应的赋值,使这些赋值构成集合S,使得S满足X中所有变量相关的所有约束,则称S为P在X上的局部解.在二元约束满足问题中,如果存在一条约束cxy,则(x,cxy)叫做一条弧,表示的是约束cxy对x取值的制约.在二元CSP中,一条约束可以表示两条弧.定义3.弧相容(ArcConsistency,AC)[6].给定一个二元约束满足问题P,对于P中的某一条弧(x,cxy),如果x值域中能满足x上一元约束的每一个值a,都能在y的值域中找到一个值b满足y上一元约束,并且(a,b)满足cxy,那么称它是弧相容的.一个CSP是弧相容的,当且仅当它的每一条弧都是弧相容的.对于问题P在进行弧相容检查时,如果检查过程中将某一变量的值域删空,则此问题P无解,记为AC(P)=⊥.定义4.Singleton弧相容(SingletonArcConsistency,SAC)[12].给定一个约束满足问题P,其中一个变量xi,a为Di中一个值,如果用单独的{a}替换原问题P中xi的值域Di后得到的P|xi=a是弧相容的,即AC(P|xi=a)≠⊥,则称(xi,a)是singleton弧相容的.如果xj∈X,b∈Dj,都有(xj,b)是singleton弧相容的,则称P是singleton弧相容的.本文主要使用单个值的singleton弧相容.目前较流行的实现全局singleton弧相容的算法是SAC-SDS[13].维持弧相容算法(MaintainingArcConsistency,MAC)[5]是一种高效的求解CSP问题的回溯搜索算法.MAC算法是在BT算法框架下嵌入AC算法,在搜索过程中维持弧相容的状态,每次变量赋值后利用AC算法进行约束传播,如果得到一个弧相容的状态,则赋值成功,否则赋值失败,选择下一个赋值或者发生回溯.目前最流行的MAC算法是Lecoutre于2007年提出的MAC3rm算法,即在MAC算法中通过AC3rm执行弧相容,MAC3rm在求解效率上比其它MAC算法有着明显的优势.由于篇幅有限,这里不介绍MAC3rm的算法描述,关于MAC3rm的一些细节可以参考文献[11].给定一个二元CSP,如果将其中的变量当成节点,其中的约束当做边,则可以得到一个无向图G,我们称G为这个CSP的约束图.我们称约束图中没有回路的二元CSP为无环约束满足问题或树形约束满足问题,约束图中有回路的称为有环约束满足问题.定义5.环切割集(cycle-cutset)[20].一个约束图G的环切割集M是该约束图中变量集的一个子集,M满足如下条件:将M中的变量从约束图G中移除后,G中不存在环.后面程序伪代码中的X(c)返回约束c相关的变量集合.本文所讨论的都是二元约束满足问题,因此X(c)得到的只是一个约束相关的两个变量.3Tree_Search搜索算法Freuder[15]在1982年提出无回溯搜索的充分条件,指出满足弧相容的无环CSP在宽度为1的搜索序列下可以实现无回溯搜索,关于搜索序列宽度的更多细节,可以参考文献[15].我们给出无回溯搜索充分条件在树形问题上的具体描述.定理1.给定一个无环约束满足问题P,如果P满足弧相容,则P一定有解,并且可以用一种无回溯的算法求解.树的深度优先遍历序列和宽度优先遍历序列都可以满足宽度为1,我们给出一种基于深度优先顺序的无回溯搜索算法.算法1.Tree_Search(TS)无回溯求解算法,P为一个满足弧相容的无环约束满足问题.Tree_Search(P)Begin1.Q=PX;2.whileQisnotemptydo3.selectaxifromQ;4.Depth_First_Search(xi);EndDepth_First_Search(xi)//深度优先遍历赋值Begin1.selectanavailablevaluevforxi;2.xi=v;3.removexifromQ;4.whilethereisanotherconstraintcinvolvexiand5.xj=X(c)-xi;6.cdealed=true;7.Depth_First_Search(xj);EndPage4定理2.算法Tree_Search的最坏时间复杂度为O(nd).证明.在深度优先搜索过程中,搜索到任意变量xi时,若xi为根节点,可直接在Di中找到一个未删除的值为xi赋值.若xi不是根节点,则只有它的父亲节点xj已经被赋值(xj,b),因此只需在Di中找到一个值a支持(xj,b)即可,由于P是弧相容的,所以一定能找到一个(xi,a)使得(a,b)满足cxy.为每个变量寻找当前可用的赋值,最多寻找d个值,问题中一共有n个节点,所以算法Tree_Search的最坏时间复杂度为O(nd).4环切割化简由于约束满足问题的众多求解算法都是建立在回溯搜索的基础上,而Tree_Search算法在处理无环约束满足问题时效率通常高于回溯搜索算法,所以如果能够将普通约束满足问题转化成一个满足弧相容的无环约束满足问题后应用Tree_Search算法进行求解,那么就会提高问题求解效率.我们的环切割思想借鉴了单个值singleton弧相容的定义,下面举例说明:一个约束满足问题P=〈X,D,C〉,X={x1,x2,x3},Di={1,2,3,4}(i=1,2,3),C={C12:x1+x2>2,C23:x2<x3,C31:x3≠x1},P的约束图中存在环.如果AC(P|x1=1)≠⊥后得到新问题P1.则P1D1={1},P1D2={2,3},P1D3={3,4},此时P1D2和P1D3中的所有值都支持(x1,1),以后的求解过程中,无论x2赋值为P1D2中的哪个值,约束C12都一定不会被违反,同理x3的赋值也不会违反C31,因此以后的求解中可以不再考虑x1,C12,C31,这样就可以暂时将x1,C12,C31从P1中移除后得到P2,此时P2的约束图中只含有x2,x3,C23,然后可以对P2继续求解.定义6.给定两个CSP,P1和P2,如果P1X和P2X相同,并且P1和P2的解相同,则称P1和P2是等价的.定理3.对于一个约束满足问题P,如果AC(P|xi=a)≠⊥后得到P1,则在P1中暂时将xi及所有和xi相关的约束移除后得到化简后的问题P2和P1是等价的.证明.AC(P|xi=a)≠⊥得到P1后,对于P1中任意一个和xi之间有约束关系的变量xj,当前P1Dj中的所有值都一定支持(xi,a),并且(xi,a)也一定支持P1Dj中的所有值.因此求解P1时可以不再考虑这些Cij,而P1Di中只包含(xi,a)一个值,因此在P1和P2的所有解中,xi的取值一定是a.因此将它们移除后得到的新问题P2和P1是等价的.值得注意的是定理3中提到的等价是指P1和P2等价,并不是和原问题P等价.以下所提到的“化简”都是根据定理3的思想,通过为变量赋值后执行弧相容算法来判断化简是否成功.当AC(P|xi=a)≠⊥时,这一步化简成功,否则化简失败.根据定理3,我们可以在求解过程中逐步将原问题化简,但在化简过程中难免遇到AC(P|xi=a)=⊥的情况,针对这一问题,我们可以将化简过程嵌入到BT算法中,每次化简失败时启动回溯机制.由于我们的化简是以弧相容执行结果判断是否化简成功,这和MAC3rm算法赋值后约束传播过程接近,因此我们可以将环切割化简的方法结合MAC3rm算法.定理4.环切割化简定理.给定一个有环约束满足问题P,在MAC3rm求解过程中优先为环切割集中变量赋值,如果P有解,那么一定能将原问题化简成一个无环的问题P1,并且由环切割集上的局部解一定可以扩展出一个解;如果P无解,那么MAC3rm算法无法为环切割集中变量找到局部解.证明.如果P有一个解S,由于MAC3rm算法是完备的,则MAC3rm算法至少能找到S在环切割集上的局部解,由于MAC3rm算法在执行过程中维持弧相容的状态,在每次赋值后要执行弧相容算法,MAC3rm算法每次为变量赋值相当于一次化简.因此在找到环切割集上的局部解后,问题仍是一个弧相容的状态,并且环切割集中的变量都已经化简成功,将环切割集中变量和相关约束全部删除后,P化简成无环问题P1.并且P1满足定理1中条件,因此P1一定有解.由于在P1中,环切割集中变量都已经找到局部解,因此P1的解就是原问题P的解.如果P无解,假设化简环切割集中所有变量成功后得到新问题P2.由定理3可知,P2的约束图中无环,并且由于化简过程是维持弧相容的,则P2满足弧相容,由定理1可知,P2一定有解,这与前提P无解矛盾,因此如果P无解,则化简一定失败.证毕.计算最小环切割集是一个NP问题[18],通常只能通过启发式算法计算一个近似最小的环切割集.下面给出一种计算环切割集的算法Compute_CutSet.其中get_a_cycle()是基于深度优先遍历搜索P的约束图,如果找到一个环,记录这个环中所有变量并Page5返回true,否则返回false.Compute_CutSet(inP:csp)Begin1.cut_set={};2.whileget_a_cycle(P)do3.selectaxivariablefromthecycle;4.cut_set=cut_set∪{xi};5.removexiandalltheconstraintsinvolvexifromP;6.returncut_set;End定理5.算法Compute_CutSet最坏时间复杂度为O(n2).证明.每次get_a_cycle基于深度优先遍历约束图,最坏要遍历k个节点才能找到环(k为当前约束图中的变量个数),因此寻找一个环需要最坏时间复杂度为k,最坏情况是问题P的约束图是一个完全图的情况,此时任意3个变量都构成环,因此要将n-2个变量加入环切割集,因此需要寻找n-2个环,每次找到一个环后将一个变量从约束图中删除,k递减1,所以最坏情况下要访问∑n2-3个变量,所以最坏时间复杂度为O(n2).证毕.下面给出基于环切割化简的约束满足问题求解算法Cycle_Cut_Search(CCS).Cycle_Cut_Search(inP:csp)Begin1.ifCycle_Cut_MAC3rm(P)then2.Tree_Search(P);else3.returnnosloution;EndCycle_Cut_MAC3rm(inP:csp):BooleanBegin1.cut_set=Compute_CutSet(P);2.ifMAC3rm(P,cut_set)then//MAC3rmonlyassign3.foreachxiincut_setdo4.RemovexiandalltheconstraintsinvolvexifromP;5.returntrue;else6.returnfalse;End定理6.当问题P的约束图是完全图时,算法Cycle_Cut_Search退化为MAC3rm算法.证明.当问题P的约束图是完全图时,任意3个变量都构成一个环,每次化简一个变量xi后只能将xi所在的所有环删除,其他未化简变量仍在环中,因此需要化简(n-2)个变量才可以将问题化简为一个无环约束满足问题.此时有(n-2)个变量要通过MAC3rm算法求解,因此算法Cycle_Cut_Search退化为MAC3rm算法.Dechter[20]的方法中只是通过为变量赋值进行切割,但是并没有用弧相容算法进行约束传播,因而不能保证环切割集上找到的局部解一定能扩展成全局解.除此以外,Sabin等人[21]在1997年曾提出一种和CCS接近的算法MACE,两者主要区别在于,MACE是建立在MAC-7ps基础上的,而CCS是建立在MAC3rm基础上的,并且MACE在求解过程中不断地将不在环中的变量加入到另一个变量集合中,在求解过程中变量所属的集合是动态变化的.而CCS在MAC3rm开始求解前已经将变量所属集合确定,在求解过程中不再改变.MACE通过约束检查次数来衡量算法效率,虽然约束检查次数是一个不随编程环境改变的硬性指标,但是文献[9,22]都指出了减少约束检查次数并不一定提高求解效率.5实验结果MAC3rm算法是目前最流行的二元约束满足问题求解算法,我们将CCS算法和MAC3rm进行比较.我们的一些实验细节如下:二元约束通过二维数组表示,这样的约束检查代价最小.CCS算法计算环切割集时选择当前环中连接约束最多的变量加入环切割集.每次测试以一小时为界限,超时则停止测试,记为—.测试环境为:IntelCore(TM)2DuoCPUT6570,双核2.10GHz,3GBDDR800内存,WindowsXPSP3,JDK1.5.0.5.1随机问题测试我们选择二元随机约束满足问题经典模型ModelB[24]对算法Cycle_Cut_Search进行测试.使用Dom/Ddeg[23]作为变量赋值顺序的启发式策略.ModelB问题模型由4个参数控制,〈n,m,p1,p2〉其中n是问题中变量个数,m是每个变量的值域大小,其中每个变量的值域大小都是相同的,p1表示约束图中约束的密度,即在约束图G中均匀选择p1×n×(n-1)/2条约束,p2表示约束的松紧度,是用来描述约束中存在冲突值对多少的参数,对于每条约束均匀地选p2×m×m个值对作为存在冲突的值对.我们选取n=50,m=30,d=0.1的问题进行测试,p2在0.1~0.9,每组连续测试50次求平均值,Page6其中p2在0.1~0.69和p2在0.78~0.9的随机问题,都是容易解的问题,耗时均在几十毫秒左右,并且两者差异不大,这里并没有给出这两个区间的测试结果,只给出了处于相变阶段[24]的难解问题即p2在0.69~0.78区间内两者耗时比较,统计后结果如下.图1中x轴表示p2在0.69~0.78,每个数据点的p2递增0.002.由图1中数据可知,在求解随机问题n=50,m=30,d=0.1时,CCS的效率明显高于MAC3rm,我们的测试数据显示,CCS的效率最多可以达到MAC3rm的140倍.5.2benchmark测试Benchmark测试用例是用来测试CSP求解算法各方面性能的一个标准,本文采用的benchmark用例全部来自2005年国际约束程序竞赛.我们选择其中的几组问题对CCS进行测试,分别是rlfap、bqwh15_106、frb35-17、frb40-19、Domino、composed-25-10-20.测试结果见表1~5.rlfapbqwh15_106表1中给出了rlfap问题中约束较稀疏的几个子问题的测试结果.bqwh15_106这组问题中共100个子问题,我们测试了全部100个子问题,将其中两者耗时都在1s以上的子问题测试结果显示在表2中.表3中列出了这两组frb问题的全部10个子问题测试结果,frb问题的约束相对比较稠密,因此环切割化简的优势并不明显.Domino问题的特点是约束稀疏且每条约束都非常紧,表4中列出了Domino问题的测试结果.表5中列出了composed25-10-20的测试结果,从表5中数据可知,部分子问题中,MAC3rm超时,但是CCS可以在有效时间内求解.子问题时间/sfrb35-17Dominocomposed-25-10-205.3实验结果分析由于变量赋值顺序对算法的效率有影响,因此我们的测试结果在个别情况下CCS效率低于MAC3rm,这可能是由于Dom/Ddeg启发式策略在全局变量中寻找到一个比优先赋值环切割集更高效的变量赋值顺序.我们的实验结果显示,CCS在绝大多数情况下效率高于MAC3rm,在随机问题相变阶段,最高可以达到MAC3rm效率的140倍,在我Page7们选择的benchmark测试用例中,CCS的效率可以达到MAC3rm的100倍以上.6结论本文首先给出一种无环约束满足问题的无回溯搜索算法Tree_Search,然后将环切割集的思想与目前最流行的求解算法MAC3rm相结合,给出一种新算法Cycle_Cut_Search.CCS将问题中变量集分为两部分:环切割集中的变量和环切割集以外的变量,通过MAC3rm算法为环切割集中变量赋值.给出了环切割化简定理和证明,根据环切割化简定理,CCS算法通过MAC3rm算法在环切割集上找到局部解后,可将原本有环约束满足问题化简成满足弧相容的无环约束满足问题,然后用Tree_Search算法执行无回溯求解,改进了MAC3rm算法的求解效率.我们实验结果显示,CCS的效率在大多数情况下高于MAC3rm.在求解随机问题相变阶段的测试用例时,CCS的效率最高可以达到MAC3rm的140倍.Benchmark中几组问题的测试结果显示,CCS在整体上效率高于MAC,最高可以达到MAC3rm的100倍以上.
