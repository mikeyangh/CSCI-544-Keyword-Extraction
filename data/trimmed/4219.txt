Page1基于模糊聚类的推测多线程划分算法李远成阴培培赵银亮(西安交通大学计算机科学与技术系西安710049)摘要推测多线程(SpeculativeMultithreading,SpMT)技术是一种实现非规则程序自动并行化的有效途径.然而,如何有效评估由诸如控制、数据依赖等因素导致的多种并行开销并实现最优线程划分一直是制约加速比性能提升的关键问题.基于启发式规则的传统划分方法虽然可以取得一定的加速效果,但由于启发式规则只能对多种并行开销进行定性评估,因而导致只能得到经验上较优的线程划分.针对传统划分方法的局限性,文中首次提出并实现了一种基于模糊聚类的线程划分方法.在该方法中,作者首先提出一种评估模型来定量评估各种并行开销,然后通过深入分析各种并行开销来确定最佳的线程解搜索空间,最终利用聚类方法实现有效线程解空间搜索以求取更优的线程划分.基于Olden程序集的测试结果表明,文中提出的线程划分方法可以有效地对非规则程序进行划分,其平均加速比可达到1.85.关键词推测多线程;线程划分;模糊聚类;自动并行化;代价评估1引言挖掘并行性是提高串行程序执行性能的有效方法之一.随着超标量(Superscalar)和指令级并行(ILP)等技术遇到越来越多的瓶颈以及片上多处理器(CMP)的迅速发展,线程级并行(TLP)逐渐成为一个更佳的选择.近年来,推测多线程(SpMT)技术[1-3]作为一个能有效开发非规则程序并行性的线程级并行技术,已经得到了迅速发展.SpMT技术一般采用软硬件协同设计的方法实现串行程序的并行执行.在SpMT系统中,编译器通过在程序中插入边界指令和推测指令将程序划分成多个推测线程,并在存在大量控制和数据等依赖的情况下,以激进的方式挖掘线程级并行性.在推测执行过程中,由执行模型检测控制和数据等依赖的发生,并采取撤销和重新运行等硬件手段来保证程序执行的正确性.SpMT技术在有效提升程序执行性能的同时,诸如控制、数据依赖等导致的多种并行开销成为制约程序加速比进一步提高的重要因素.在SpMT系统中,线程划分是SpMT编译器的核心,线程划分的结果直接决定了推测多线程编译器的最终性能.因此,有效评估诸如控制、数据依赖等因素导致的多种并行开销并实现最优推测多线程划分将是提升加速比性能的主要途径之一.目前,研究者已经提出了多种推测多线程划分方法[4-5].同时,诸多优化技术如值预测[6]和分支预测[7]等技术也被大量提出用以进一步消减线程间的数据和控制等依赖造成的开销.从整体上看,这些划分方法都取得了一定的加速效果,但却存在以下局限性:(1)现有线程划分方法的核心都是基于启发式规则,而这些基于经验性的启发式规则只能对多种并行开销进行定性评估,这将导致现有的划分方法只能得到经验上较优的线程划分解;(2)虽然有些方法通过建立动态评估模型在一定程度上克服了定性评估的不足,但是其低效的评估方法严重限制了此类方法的进一步应用.针对现有线程划分方法存在的局限,为了更加深入探索线程划分影响程序加速比的内在规律,本文首次提出一种可以有效搜索线程划分解空间以寻求更优解的线程划分方法,即基于模糊聚类(FuzzyClusteringMethod,FCM)的线程划分方法.该方法首先通过深入分析各种影响加速比性能的并行开销,并结合启发式规则确定有效的线程划分解的搜索空间.然后,基于对多种并行开销的分析,提出一种定量评估多种并行开销的评估模型来判定聚类结果的有效性.在此基础上,利用FCM算法对线程解空间进行搜索,进而求取更优的线程划分.最后,本文将提出的划分方法在项目组开发的Prophet编译系统平台[8]上进行了实现.基于Olden测试程序集[9]的实验结果表明,本文提出的线程划分方法可以有效地对非规则程序进行推测多线程划分,相对于传统的基于启发式规则的线程划分方法,本文方法可以取得平均9.9%加速比性能提升,其平均加速比值达到了1.85.2推测多线程技术2.1SpMT执行模型在Prophet并行编译器中,串行程序被划分成为多个推测线程进行执行,每个推测线程执行程序的不同部分,程序的串行语义用以保证推测线程的提交顺序.在并行推测执行中,有且只有一个是非推测线程,该线程可以提交其执行结果,代表程序当前确定执行的状态.其它线程为推测线程,由串行程序代码片段及其预计算片段(pre-computationslice,p-slice)构成,线程间以前驱和后继的形式保持串行程序的语义.p-slice是由编译器根据程序切片技术生成的一小段代码,用来对推测线程使用的live-ins变量(指线程体使用但并非由该线程定义的值)进行值预测.如图1所示.激发点(SpawnPoint,SP)和准控制无关点(ControlQuasi-IndependentPoint,CQIP)指令对唯一确定一个激发线程对.串行程序中插入SP-CQIP点就被映射为推测多线程程序,SpMT程序中忽略SP-CQIP就得到串行程序(图1(a)).CQIP点把程序分成一些代码段,当程序执行到SP点的时候,会发起一个新的线程并推测执行CQIP点之后的那个代码段.执行过程中使用执行模型检测线程的运行Page3情况,如果线程推测执行成功,那么推测线程一直执行直到自身的CQIP点,如图1(b)所示.验证失败或读后写(ReadAfterWrite,RAW)内存依赖违规等导致推测执行失败.若验证失败则由父线程串行执行验证失败的代码段,如图1(c)所示,否则,在当前的状态下重新启动该线程,再次谋求推测执行成功,如图1(d)所示.2.2推测并行开销在SpMT并行执行模式下,主要有5种开销影响推测多线程的并行性能.这5种开销分别为:线程分发和提交开销、线程间通信开销、缓冲区溢出开销、线程撤销和重启开销以及线程负载不平衡开销等.在这5种开销中,缓冲区溢出开销、线程撤销和重启开销以及线程负载不平衡开销是影响并行性能最大的3种开销[10].线程分发和提交开销主要是由调度一个新线程到处理单元和将推测缓冲区数据向安全存储器传输并更新等时间组成.此开销主要取决于硬件总线带宽以及线程需要处理的数据量的大小等因素.线程间通信开销主要由处理单元等待前驱线程进行值传递的时间构成.此开销主要依赖于体系结构对同步寄存器或者内存通信的支持,同时也受到线程间通信点位置以及通信频率的影响.推测缓冲区溢出开销则主要是由于推测缓冲区溢出处理单元保持等待状态直至成为非推测或者被撤销所引起的时间组成.此开销主要和缓冲区物理大小、缓冲区的组织结构以及线程体大小有关.对于以上3种开销来说,尽管开销的大小在一定程度上会受到不同划分策略的影响,但其共同特点就是更多地受到硬件体系结构因素的影响,例如总线互联机制、缓冲区大小、高速缓存以及内存的访问机制等等.线程撤销和重启开销主要由于发生控制和数据依赖推测失败所导致.如图2所示,当线程0验证线程1时,发现线程0实际执行时的直接后继不是线程1或者线程1所使用的预测数据是错误的,此时将发生控制或数据依赖违规.因此,线程1将会被撤销并重启执行,同时,线程1的所有子线程将全部被撤销,同时处理单元2和处理单元3被释放,并重新分配给新激发的推测线程(2和3可能是线程2和3,也可能是其它的推测线程).这些回滚线程的执行时间就构成了线程撤销和重启的时间开销.负载不平衡开销则主要是由于线程粒度大小不一造成的.如图2所示,线程1的粒度小于线程0,因此在线程0执行完并验证线程1之前,处理单元1将处于等待状态.这些等待时间就构成了负载不平衡开销.此两种开销的一个共同特点就是严重依赖于线程划分策略,合理的线程划分策略能够有效地减少这两种开销所造成的影响.图2控制、数据依赖和负载不平衡开销示意图在本文中,假设硬件体系结构是基于良好设计的,可以有效地减少前3种开销.本文主要关注于如何有效定量评估这2种并行开销,并提出一种高效的线程划分方法来实现更加合理的线程划分.2.3基于预计算的值预测在推测并行执行中,值预测技术作为一种有效减少数据依赖开销的技术得到了研究者的广泛研究.目前,预计算片段技术作为一种有效的值预测技术已经得到了广泛的应用.预计算片段技术是一种基于程序切片技术[11-12]的值预测方法,它通过对推测线程的live-ins变量构建预计算片段,并在推测线程执行前预先执行此代码片段实现推测值的预测.构建预计算片段主要分为3个步骤:(1)构建基于程序控制流图的数据依赖图;(2)确定推测线程的live-ins变量;(3)构建基于live-ins变量的程序片段.在Prophet中,为了有效减少预计算开销,编译器只是从CQIP到SP沿推测路径前向遍历,构建推测线程的预计算片段,因此预计算片段不正确的可能原因或者是发生需要的live-ins位于非推测路径上,或者产生该live-ins的指令来自于非推测路径.另外,当构建预计算片段过程中遇到函数调用指令时,如果将函数调用指令调用的子程序全部包含进预计算片段,这就可能导致预计算片段非常庞大,而一般情况下,子程序中很多代码可能根本是不需要的.因此,本文采取了比较保守的方案,即在产生的预计算片段中裁剪函数调用指令.3基于FCM的线程划分框架3.1基本思想SpMT技术在允许存在大量控制和数据依赖的Page4情况下,试图以激进的方式挖掘线程级并行性.研究结果表明,如果线程选择合理,并采用合适的值预测技术,推测并行能获得远远高于超标量获得的加速比,极大地提高系统性能.在SpMT系统中,编译器一般是基于程序CFG,按照某一选定的推测路径进行线程划分.线程划分的本质就是将推测路径上的代码以基本块为单位划分成多个线程组合(即线程解).如果将推测路径所包含的基本块看作若干个有序对象xi,构建一个由这些对象组成的样本集,则针对每个过程的线程划分可以看作是将此样本集按照一定的划分策略进行分类的过程,所有的分类结果构成线程划分的解集.直观地,样本集分类的类别数目c的范围为[1,对象个数].基于2.2节对并行开销的分析可知,线程负载不平衡是影响加速比性能最重要的因素之一,在线程划分时如何尽可能使线程负载趋于平衡至关重要.因此,对每个分类数c所对应的划分解子集,可以近似认为线程负载最平衡的划分解将具有最佳的加速比性能.对于一个串行程序,由于将其代码划分为多个线程单元本质上可以看作是一个分类问题,因此这使引入现有的基于搜索的分类技术应用于线程划分成为可能.同时,由于在CMP上将线程划分为执行时间最优的多个推测线程是NP完全问题[13],对线程划分解空间的完全搜索将可能会导致无法承担的巨大开销.因此,需要一种折中的方案来平衡搜索所引发的开销和搜索所求取的线程划分解的加速比性能,即基于搜索的线程划分方法结合一定的启发式规则进行.通过结合启发式规则将可以大大简化需要搜索的线程划分解空间,同时也可以进一步降低搜索过程的复杂性并加速更优线程划分解的求解过程.另外,FCM方法作为一种有效的聚类划分技术,目前,已被大量研究.和通常将数据进行硬性划分的一般划分方法不同,FCM方法实现了一种软划分,其聚类结果描述了样本属于各个类别的不确定性程度.这种聚类结果的模糊性将非常适合应用于推测多线程的划分,即通过FCM确定各个不同基本块隶属于不同线程单元的隶属度,然后利用基于经验得来的启发式规则来确定最终的线程划分.正基于以上分析,本文自然地提出一种基于模糊聚类的线程划分方法.该方法首先对分类数目c构成的划分解空间进行搜索,然后根据聚类结果描述的样本属于类别的隶属度,并结合启发式规则来确定最佳的划分.显然,每个类别包含的对象所代表的基本块就自然地构成了一个推测线程.3.2基于模糊聚类的线程划分3.2.1模糊聚类算法FCM算法是一种基于划分的聚类算法.给定一含有N个向量的样本集S={xj,j=1,…,N},xj∈RP,算法的目标就是将样本集S划分到c个类别集{1,2,…,c},使得被划分到同一类的对象之间相似度最大,而不同类之间的相似度最小.FCM的目标函数的一般形式为其约束条件为式中,犝为模糊隶属度矩阵,犞为聚类中心矩阵,X为样本集合,c为聚类数,xj∈RP为第j个数据,uij为xj属于第i类的隶属度,m∈[1,+]是一个加权指数.对式(1)用拉格朗日乘法构造最小化的目标函数,可得求其最优解的必要条件:FCM算法的输出是c个聚类中心点向量和一个c×N(N为样本个数)的模糊划分矩阵,这个矩阵表示的是每个样本属于每个类的隶属度.根据这个划分矩阵按照模糊集合中的最大隶属原则就能够确定每个样本归为哪个类.本文提出的模糊聚类划分方法正是通过将线程划分问题转化为聚类划分问题,然后通过判定聚类结果的有效性来求得最佳线程划分解.在本文提出的线程划分方法中,FCM过程是作为划分过程的其中一个处理环节,FCM算法处理的是每一个对象程序的结构化和归一化结果,输出结果给出的是不同程序块对不同线程单元的隶属程度描述.对于给定的某一聚类数,其线程划分解是根据启发式规则来最终确定.和经典的人工智能、统计学习理论以及专家系统等领域使用的模糊理论相比,其主要区别在于确定最终线程划分解的知识并非来源于聚类分析,而是来源于程序行为分析的结果;某一程序对象的FCM过程输出的不同程序块对不同线程单元的隶属程度知识并不能被用以和启发式规则结合,并指导其它程序对象的聚类分析过程.Page53.2.2形式化预处理(1)结构化分析本文提出的线程方法是基于程序CFG进行推测多线程划分.因此,为了便于对推测路径上的代码构建样本集,需要对程序CFG进行结构化预处理.首先,利用程序剖析技术提取包括分支概率、循环和过程调用的动态指令数目、循环迭代次数等信息,建立基本块层级的加权控制流图WCFG.然后,在WCFG基础上,进行结构化分析并建立超级控制流图SCFG.在SCFG中,过程调用和循环区域均被归结为类似于基本块的形式,即超级块.对于过程调用,其指令数目大小可采用如下表达式计算:对于循环区域,处理方式如图3例子所示.首先,通过对循环区域控制流图进行剖析,构造一个循环路径集合.每个循环路径由循环体中从循环入口节点到循环出口点的一个串行节点集组成.在循环区域控制流图中,一个循环出口节点可能有3种类型:(1)指向循环头节点;(2)指向循环区域外部节点;(3)节点调用了包含结束指令的过程调用.一个循环路径可以用如下式子表示:循环路径=路径上节点集+路径类型+路径类型={循环外节点|循环头节点|退出节点}.然后,通过计算此循环路径集合计算出循环区域的动态指令数目大小.其具体计算方式可用如下方式表示:循环例程=循环体内路径的集合.(2)归一化处理进一步,为了应用FCM算法,首先利用结构化分析的结果来构造以基本块(或者超级块)为对象的样本集S={xj,j=1,…,N},然后,根据CFG中的控制流关系,构造所有样本的邻接矩阵犕adjacent.此矩阵中的每个元素表示对应的两个样本之间的控制流关系:Mij=1,i→j有控制流接下来,根据犕adjacent和下述规则,求取任意样本之间的距离Dij:①如果Mij值为1,则Dij为两个样本所代表的基本块包含的动态指令数之和的1/2;②如果Mij值为0,则Dij为两个样本之间所包含的路径的距离.Dij值描述了样本之间的距离,经过归一化处理,可以得到样本集的距离矩阵犇distance:显然,根据犇distance可以很容易计算式(4)和式(5).3.2.3确定有效性函数在利用FCM算法进行线程划分时,如何判定某一个聚类结果的有效性是一个关键问题.针对这一问题,本文提出了一个可以有效评估各种并行开销的评估模型,并利用该模型来判定聚类划分的有效性.图4给出了一个基于SCFG的线程划分的实例,图中实体粗线表示推测路径,实体细线表示线程划分的边界.图4中,在最可能路径上划分了3个线程,分别为线程1,线程2和线程3.线程1包含了超级块A和B,线程2包含了超级块C和E,线程3包含了超级块G和I.根据2.1节描述的Prophet执行模型可知,这些线程将会被推测执行;当成功执行时这些线程可以对并行做出贡献,其执行时间将会等价成并行时间.由于线程是依据推测路径进行划分,推测路径上所有基本块(或者超级块)将以一定的概率参与并行,而不在推测路径上的基本块(或者超级块)则由于没有被推测(即使实际中被推测执行,由于在Prophet中p-slice只是沿推测路径进行提取,因此没有进行值预测,通常也会由于数据依赖而撤销,最终被串行执行)而只能串行执行.根据Page6Amdahl定律,一个程序的加速比是由程序串行部分的运行时间和并行部分的运行时间决定的.假设T_Time是串行程序执行时间,T_Seq是程序中串行部分的执行时间,T_Par是程序中并行部分的执行时间,那么加速比可以用如下的公式计算:设推测路径上有n个节点,则可构造由这n个节点组成的集合N={nt,1tn},同时,假设Probt为节点nt沿推测路径的分支概率.图5构建线程激发树的例子对于线程结点Tl,假设Wl是线程Tl的执行时间,并且假设当推测成功时,Wl是此线程相对于其父线程结点的等价并行时间.进一步假设T_equ_Tl是以Tl为根结点的线程激发子树的等价并行执行时间.以图6为例,对于线程结点Tl,如果线程结点Tl是一个根结点,则Wl等于T_equ_Tl.如果Tl不是根结点,假设P_Sl是Tl的预计算片段的执行时间.对于Tl的父线程Tpar,SPpar是线程的发起代价,(1)计算T_Par接下来,本文详细说明如何评估各种并行开销并最终求取某一划分的理论加速比.对某一过程,假设共划分为L个线程,则对每个线程Tl,1lL,根据集合N构建集合Tl_path={nm,1tM},nm为所有位于从线程l开始的节点到线程l的末尾节点路径上的节点.则线程l被推测执行的概率可以由下面式子来计算:下面,我们通过构建并遍历线程激发树来计算程序的并行执行等价时间T_Par.图5给出了1个激发树构造的例子.图5(a)中,最左边的线程是确定线程,其它的都是推测线程.1个线程的推测级越高,则它越具有推测性,也越靠近右边.线程发起的顺序为①→②→③→④→⑤→⑥→⑦,串行执行顺序为①→⑥→⑦→④→③→⑤→②.图5(b)中是程序对应的线程激发树,激发树中推测级别高的线程处于树的右侧.Cp是线程的验证代价,而Cl是线程的提交代价.则对于Tl,我们可以按照下面式子计算它的Wl:Wl=T_equ_Tl,ifTlisroot烄(P_Sl+T_equ_Tl)-(Wpar-SPpar+Cp)烅Cl,if(P_Sl+T_equ_Tl)-(Wpar-SPpar+Cp)烆Page7根据式(10),我们通过广度遍历激发树来计算T_equ_Tl.假设它的孩子结点为Tli,i=0,1,…,k(k=1,2,…).为了模拟撤销和重启代价,假设αl是在Tl的执行过程中发生数据违规的概率.那么我们可以用算法1的函数T_equ(Tl)来计算T_equ_Tl.显然T_Par可以通过如式(11)来确定:算法1.计算每个激发树的等价执行时间.输入:激发树T输出:T_equ(Tl)1.T_equ(threadnodeTl){2.T_equ_Tl=0;3.IF(Tlisleafnode)4.T_equ_Tl=PlWl;5.ELSE{foreachchildnodeTli6.T_equ_Tl=PlWl+7.Pli∑k8.returnT_equ_Tl;}在本文,我们利用程序切片技术对推测线程进行了值预测,因此,当线程l以概率Pl被推测时,我们近似认为线程将会成功执行而不会由于数据依赖发生撤销(此时α=0).另外,由于我们采取了保守的预计算片段策略,对子程序和循环体等超级块没有进行值预测,因此,我们保守地认为由于复杂的数据依赖,对于包含超级块线程的推测始终是失败的(此时α=1).(2)计算T_Seq在推测执行模式下,所有的线程Tl都在概率Pl下被推测并行执行.设T_Time是程序串行的执行时间,则推测执行模式下的程序串行部分的执行时间可以通过如下的式子进行计算:根据式(9)、(11)、(12),对于任意一种线程划分,我们都可以计算出其理论加速比值.即对某一个聚类划分ci,其聚类有效性函数可以由下式来定义:3.2.4基于FCM的线程划分在本节,本文给出详细的基于FCM算法的线程划分方法.首先,为了进一步缩小搜索范围并减少搜索开销,基于3.1节的分析,我们可以摈弃一些显然会导致严重负载不平衡的线程划分,最终确定聚类数范围为[1,c],其中c由下式来确定:式(14)中,xt表示其代表的基本块的动态指令数目.然后,对某一确定的ci,应用FCM算法对样本集S进行划分.根据算法输出的隶属度矩阵,我们依据算法2来确定具体的推测线程,即确定线程边界CQIP点位置.在算法2中,我们设定阈值ε=10-4,即当某一基本块对不同的线程中心隶属度相差在此阈值范围之内时,结合启发式规则,将按照更有利于减少控制依赖发生的原则来判定此基本块的归属类别.算法2.确定候选推测线程.输入:关系矩阵犝,聚类中心矩阵犞,阈值ε输出:二维矩阵犚[n,ci],每个候选推测线程Tci1.Determine_Threads(犝,犞,ε,犚[n,ci])2.FOR(1=<j;j++;j<=n)3.{temp=thefirstcolumnnumberofthemax(犝(j));4.犚[j,temp]=temp;}5.FOR(1=<j;j++;j<=n)6.FOR(1=<k,k++,k<=ci)7.{IF(犚[j,k]!=犚[j+1,k])&8.{ifnodejisthepost-dominatorofthestartnode9.犚[j,k]=k+1;}}接下来,对于已经确定的候选推测线程,分别在适当的位置插入其相应的激发点.同时,由于线程划分的NP特性,即使在使用了前述一些典型启发式规则情况下,此插入过程仍然会导致很大的开销.因此,为了进一步降低复杂性以减少开销,本文进一步引入几个典型的启发规则指导最终的线程划分,以达到更好地搜索开销和搜索精度的折中效果.这些启发式规则主要包括:(1)激发点SP可以在激发线程的任意位置;(2)激发点SP和相应的CQIP点必须位于同一过程体或者循环体内;Page8(3)为了减少发生数据依赖的概率,数据依赖数目[14](用两个线程之间的数据依赖弧个数来量度)必须小于某一个阈值.算法3给出了详细的激发点SP插入算法的描述.算法3中,get_candidate_thread()函数用来获取下一个有可能被激发的候选线程,data_depend-ence_count()则用来计算在当前激发点位置到候选线程之间的数据依赖数.算法3.确定SP的位置.输入:curr_thread,future_thread,spawn_pos输出:spawn_pos1.insert_spawn_point(curr_thread,future_thread,2.future_thread··=get_candidate_thread();3.IF(curr_thread.spawn_count()==0)4.spawn_pos··=thepositionoffirstinstruction5.WHILE(spawn_posisnotthelastinstruction)6.opt_ddc=data_dependence_count(curr_thread,7.IF(opt_ddc<DEP_THRESHOLD)THEN8.curr_thread=future_thread;9.Insert_spawn_point(curr_thread,future_thread,10.ENDIF11.spawn_pos··=thepositionofthenextinstruction12.ENDWHILE13.ELSE14.curr_thread=future_thread;15.spawn_pos··=thepositionoffirstinstruction16.Insert_spawn_point(curr_thread,future_thread,17.ENDIF}下面,利用3.2.3节确定的有效性函数f(ci)对每一个ci所对应线程划分进行有效性计算.基于FCM的线程划分算法描述如下:1.确定聚类分类数的范围[cmin,cmax].2.对于聚类分类数c从cmin到cmax依次应用如下步骤:2.1.初始化聚类中心犞(0);2.2.应用基本的FCM算法更新模糊分类矩阵犝和聚2.3.判断是否收敛,如果没有,转步骤2.2;否则转步骤2.4.通过有效性指标函数计算有效性指标值f(ci).3.比较对应每个c的有效性指标值,最大指标值f(ci)所对应的线程划分解即为所求的最优解.3.3算法复杂度分析本文提出的基于FCM算法的线程划分方法时间复杂度主要包括3个方面:FCM算法、聚类有效性函数计算和插入激发点算法.假设样本集中有n个节点,则插入处理激发点算法的时间复杂度不超过O(n).FCM算法包括2个部分,即计算迭代计算隶属度矩阵和确定候选线程.其时间复杂度为O(n2+Lnp),其中L为FCM的迭代次数,在本文中,由于样本集中的基本块只有一维距离属性,因此,其维数p的值为1.根据3.2.3节的分析,聚类有效性函数计算的时间复杂度主要由式(9)和算法1组成,其复杂度为O(nlogn).因此,算法总的时间复杂度为O(n2+Ln+nlogn).另外,基于启发式规则进行线程划分的算法时间复杂度通常为O(nlogn)[14-15],但是某些基于启发式规则进行动态评估进行线程划分的算法时间复杂度则通常达到O(n3)[13],甚至更高的复杂度[16](由于需要通过模拟器模拟执行,因此将依赖于划分对象程序本身的复杂度).本文算法由于增加了FCM过程处理,因此时间开销将比基于传统启发式规则进行划分的算法大,但却明显小于利用动态评估进行线程划分的时间开销.4实验评估4.1模拟环境本文提出的基于FCM的线程划分方法已经在Prophet编译系统平台上进行了实现.Prophet模拟器采用MIPS指令集,通过扩展指令集实现对SpMT处理器模拟.每个处理单元PE有自己的程序计数器、取指令单元、解释指令单元和执行单元,用来从线程中取出指令并执行.同时,Prophet模拟器包含了ALU、Cache、流水线等部件,实现了超标量流水多核处理器的模拟.具体的配置信息见表1.取指、发射和提交宽度多版本一级Cache4路组相联、64KB,命中延迟:2个时钟周期处理单元数激发开销验证开销本地寄存器访问内存提交开销本文选择Olden测试程序集的子集对论文提出Page9的划分方法进行性能测试.Olden基准程序是由Princeton大学提供的一个测试集,具有复杂的数据结构以及对这些数据结构的操作,例如都是对树和链表进行合并、遍历等操作;另外,Olden程序结构大多为递归,具有复杂的线程间依赖关系.因此,Olden基准程序测试集这些复杂的控制和数据依赖的特性,非常有利于测试本文提出的划分算法的性能.同时,为了获取程序动态执行的信息,我们设计了一个训练集,并根据训练集的不同输入,对每个测试程序模拟执行大约10M条指令.4.2实验及结果分析为了展示本文方法的有效性,我们选择和基于一些典型的启发式规则的线程划分方法进行性能比较[14-16].这些启发式规则除本文使用的启发式规则(如3.2.4节描述)外,还有诸如线程划分点应尽可能位于程序的控制无关点处,人为设置线程粒度大小的范围等.本文方法是一种结合启发式规则和搜索方法的线程划分方法,其具有的解空间搜索功能将可以有效地摒弃单纯基于启发式规则带来的自上而下或自下而上的顺序划分的局限,并进而求取更优的线程划分解.另外,为了与基于这些启发式方法进行线程划分进行对比,我们已经在Prophet平台将基于这些启发式规则的划分算法进行了实现[15].下面我们首先给出相比基于启发式规则[15]方法,本文方法在减少并行执行负载不平衡开销的信息统计,如表2所示.Olden程序基于启发式MstBhPowerVoronoi7.2Perimeter59.034.3072.0Em3dH.mean18.610.1084.2表2中第2列和第3列分别给出的是基于两种方法生成的线程在并行执行过程中,由于负载不平衡导致的处理器处于等待状态占总处理器执行时间的比例.从表2可以看出,负载不平衡所引起的开销占用相当大比例的处理器执行时间,尤其是Mst和Perimeter程序,其处理器等待状态所占比例分别达到了31.4%和59.0%,严重影响了并行执行的加速比性能.同时,从第3列可以看出,基于本文方法生成的线程相比于基于启发式规则生成的线程所引起的负载不平衡开销均有明显的降低,特别是Mst程序,其负载不平衡开销减少比例高达217.2%.总体上,我们可以平均减少84.2%负载不平衡开销,这说明本文方法可以有效地减少负载不平衡的影响.表3给出了应用FCM算法时,Olden程序聚类迭代次数的统计信息.从表3中可以看出,所有程序的迭代次数都比较小,Olden程序的平均迭代次数仅为262.7次.这一方面说明,启发式规则的使用大大简化了搜索的复杂性,本文通过结合启发式规则来确定线程的解搜索空间是可行的;同时,这也说明了由于非规则程序包含的过程体通常较小[17],因此需要划分的样本集规模不大,FCM算法可以被用来有效地进行推测多线程划分.另外,由于FCM过程只是作为划分过程的其中一个处理环节,FCM算法独立地处理的是每一个对象程序.相较于经典的人工智能、统计学习理论以及专家系统等领域使用的模糊理论,本文方法中的FCM过程输出结果仅仅给出了不同程序块对不同线程单元的隶属程度描述,其聚类所得的知识并不能被用以和启发式规则结合以指导其它程序对象的聚类分析过程.因此,表3同时也说明了进一步的工作应该着重于探索如何更好地结合FCM算法和启发式规则,并进而有效利用FCM聚类知识用于指导更好地进行线程划分.图7给出基于本文方法和基于启发式规则方法生成的推测线程的加速比性能对比.从图7可以看到,本文方法在测试程序集上的加速比相比基于启发式规则方法均有不同程度的提高,特别是Peri-meter、Bh、Em3d、Mst等程序提升相当明显.同时,从图7可以看到,不同程序性能提升的幅度有较为明显的差距.首先,这说明基于启发式规则方法对某些程序确实可以产生性能很好的推测线程;其次,这间接说明了本文提出的评估方法尚不够精确,导致某些潜在的开销信息不能被完全提取,致使对多种开销的评估出现一定程度的偏差,进而导致聚类有效性函数存在一定程度的不精确性.但这种评估偏差可以通过提高评估模型的精确度来有效地消除或Page10者降低到可以接受的范围.最后,这也说明根据启发式规则来确定的线程解空间存在一定程度的局限性,有可能不包含全局最优解.另外,根据3.3节对算法复杂度分析可知,较启发式规则方法,在取得更好的加速比性能的同时,本文方法的不足之处在于其开销明显增大;另一方面,结合3.3节的分析可知,本文算法有效解决了线程划分的NP难题,算法开销被保持在一定的范围之内,这也说明了本文提出的通过结合使用启发式规则来寻求算法开销和最终线程划分解性能的折中方法是合理的.同时,从图7还可以看出,Perimeter程序的加速比性能较低,Em3d程序则具有较高的加速比,这主要是是因为Em3d程序比Perimeter程序含有更多的适合推测并行的循环体.表4基于两种方法的推测线程动态执行统计信息激发成功率基于启发式规则方法基于FCM方法Olden程序Mst639Bh120275Power129359Voronoi111907perimeter9677Em3d在表4的最后一列我们给出所有的Olden程序加速比性能的提升率.从表4可以看出,所有的Olden程序都有从1.8%到25.3%范围内不同程度的加速比性能提升.总之,上述结果表明,本文针对传统的基于启发式规则的线程划分方法所提出的基于FCM的线程划分方法可以有效地对非规则程序进行划分.首先,FCM方法可以在一定程度上克服单纯依靠具有经验性的启发式规则进行划分的局限,通过对线程划分解空间进行搜索将可以有效地寻求更优线程划分解.其次,为了有效减少FCM过程的开销,本文方法在算法开销和获取程序加速比之间实现了一种折中方法,通过结合一些典型的启发式规则将复杂度限制在了一定的范围之内.同时,由于本文提出的线程划分方法的划分对象是以过程为单位的非规则程为了进一步分析算法的有效性,在表4,我们给出了基于本文方法和基于启发式规则方法生成的推测线程在编译器并行执行过程中的动态统计信息.从表4可以看出,对于Mst、Bh、Power、Em3d、Perimeter等程序,基于FCM方法所激发的线程数目均有较为明显的增加;同时,虽然线程激发成功率有一定程度的下降,但是成功激发的线程数目都有较为明显的增加,特别是Em3d程序,激发的线程总数增加了近2.2倍,但激发成功率仅仅下降了10%.同时,从表4还可以看出,对于Voronoi程序,和其它测试程序不同,基于FCM方法所激发的线程数目有0.8%的减少,但其激发成功率却有2%的提升,且总的成功激发线程数目仍有一定程度的增加.这说明,基于FCM方法产生的推测线程可以通过激发更多成功的推测线程来挖掘程序的并行性,并因此带来加速比性能提升.进一步,定义加速比性能提升率为性能提升率=基于FCM加速比-基于启发式规则加速比0.74050.93830.74100.93800.57090.6486序,而非规则程序的过程体大都规模较小,因此对以过程体构成的小样本集进行划分也非常适用于应用FCM算法.总体上,相对于基于典型的启发式规则的划分方法,本文方法取得了平均9.9%加速比性能提升.5相关工作SpMT技术作为一个能有效挖掘非规则程序并行性的线程级并行方法,目前已经得到了迅速发展.在SpMT系统中,线程划分技术是最为关键的技术,其线程划分结果将直接决定SpMT编译器的最终性能.Bhowmik等人[14]通过构建基于SUIF-MachSUIF编译框架的推测多线程方案,利用控制流图和数据流图关联关系,提出一个基于相对最可Page11能路径的线程划分算法.Wang等人[18]采用编译时的静态程序剖分技术提取程序的代码特征,评估循环结构的并行代价开销,寻找出最优线程边界和激发点位置,最终将整个程序分解为多个线程.从整体上看,这些单纯基于启发式规则方法的划分算法都取得了一定的加速效果,但是由于启发式规则只能对多种并行开销进行定性评估,因而这些方法只能得到经验上较优的线程划分.为了克服启发式规则只能定性评估多种并行开销的局限,Carlos等人[16]提出一种通过实际动态执行模式来评估并行开销的评估模型,最终选取并行性能最佳的推测线程,实现程序的线程划分.类似地,Luo等人[19]通过引入硬件性能计数器,建立了一个软硬件评估模型来动态评估程序运行时的性能,并从中选取性能较好的线程作为推测线程,进而确定线程划分解.这些基于动态评估的方法虽然取得了较好的效果,但是其低效的评估方法严重限制了算法的进一步应用.为了克服上述划分方法的不足,一些人试图引入机器学习技术指导线程划分.Wang等人[20]采用程序剖分技术提取循环结构特征,构建基于推测线程映射的性能调整模型,从推测线程执行的调度角度探讨如何进一步提高加速比性能.Tournavitis等人[21]则试图通过收集运行时的信息作为训练样本,抽取控制和依赖的特征,建立一种分析模型来计算数据依赖值并进而指导线程划分.和前述方法中仅仅应用机器学习方法间接用于提高加速比性能不同,在本文,我们通过引入模糊聚类方法,首次提出了一种基于对线程解空间进行搜索的线程划分方法.该方法可以有效地克服传统的仅仅基于经验性的划分思想,更加深入探索线程划分影响程序加速比的内在规律.这对于多核处理器研发、加速现有串行应用程序都将有着重要的理论意义和应用价值.6结论及下一步的工作线程划分是SpMT技术的关键因素之一.因此,有效评估诸如控制、数据依赖等因素导致的多种并行开销并实现最优线程划分是加速比性能提升的关键.针对现有线程划分方法存在的不足,本文首次提出一种可以有效搜索线程划分解空间以寻求更优解的线程划分算法,即基于FCM的线程划分算法.该算法首先通过深入分析各种影响加速比性能的并行开销,并结合启发式规则确定了有效的线程划分解的搜索空间.然后,提出一种评估模型对各种并行开销进行定量评估,进而确定了聚类算法的有效性指标函数.在此基础上,利用模糊聚类的方法对线程解空间进行搜索以求取更优的线程划分.该线程划分方法的主要创新在于:(1)深入分析多种并行开销,并结合启发式规则有效地确立了推测线程划分解的搜索空间;(2)首次提出一种能定量评估各种并行开销的评估模型,并根据此模型求取任意线程划分解的理论加速比来判定聚类的有效性;(3)首次提出一种基于FCM算法的推测多线程划分方法,实现对线程划分解空间的有效搜索以求取更优的线程划分解.基于Olden测试程序集的实验结果表明,本文提出的基于FCM方法的线程划分方法的平均加速比达到1.85;相对于传统的基于启发式规则的线程划分方法,本文方法可以取得平均9.9%加速比性能提升.这说明,本文提出的线程划分算法可以有效地对非规则程序进行推测多线程划分.进一步地,由于本文中的线程解空间是结合启发式规则确定的一维解搜索空间,存在一定程度的局限性,有可能不包含全局最优解;同时,本文提出的评估模型尚不够精确,会导致某些潜在的并行开销信息不能被完全提取,致使对多种开销的评估出现一定程度的偏差,进而影响聚类有效性函数的精确性.另外在划分过程中,某一程序对象的FCM过程输出的不同程序块对不同线程单元的隶属程度知识并不能被用以和启发式规则结合并指导其它程序对象的聚类分析过程,而这些聚类结果中蕴含的线程划分的规律性知识将对提升加速比性能有着重要意义.因此,下一步的工作将从以下3个方面进行:(1)更深入分析影响线程划分的多种因素,以确定包含数据和控制依赖等因素在内的多维线程解搜索空间;(2)进一步完善评估模型,提高评估模型的精度,并设计更加精确的聚类有效性函数;(3)进一步探索如何更好地结合FCM算法和启发式规则,并进而有效利用FCM聚类知识用于指导更好地进行线程划分.另外,由于本文提出的划分算法仅在Prophet编译系统平台上进行了相应的实现,因此,当将该算法与其它的并行体系结构建立的平台相结合应用时,尚需要注意以下问题:(1)针对不同的并行应用平台,分析和评估其影响并行性能的具体因素以确立相应的线程划分解的搜索空间;(2)针对不同的并行应用平台,也需要根据相应的影响并行性能的具体因素来建立相应的评估模型,并结合FCM算法来探索线程划分的更优解.Page12
