Page1多核共享缓存bank冲突分析及其延迟最小化1)(北京理工大学计算机科学技术学院北京100081)2)(鲁东大学数学与信息学院山东烟台264025)摘要在硬实时多核系统中,共享资源冲突的问题为硬实时任务的最差情况下执行时间(WCET)分析带来了新挑战.虽然现有的共享缓存冲突分析技术在storage冲突方面已取得研究进展,但对于bank冲突而言,现有研究仍局限于通过界定bank冲突延迟上限来分析和处理bank冲突.该文通过优化核-bank映射关系来使硬实时多核系统中的bank冲突延迟最小化,即在对bank冲突延迟进行分析的基础上,首先通过优化核-bank之间的映射关系来消除bank冲突;若无法消除,则需要寻找能使bank冲突延迟最小化的核-bank映射关系解,并为此设计了一种基于多核总线请求时间序列的bank冲突延迟求解算法.最后,文中设计了能够对总线访问延迟进行消重的多核硬实时任务WCET估算方法.实验结果表明:文中所提的优化方法可消除这类bank冲突或使其延迟最小化,文中所提的WCET估算方法与现有估算方法相比可获得更精确的最差情况下执行时间(WCET).关键词多核系统;硬实时任务;优化;核到bank映射;bank冲突延迟;最差情况下执行时间1引言硬实时系统对硬实时任务的执行时间有着严格要求,每个硬实时任务必须在确定的截止期之前完成.硬实时任务的最差情况下的执行时间(WCET)是判断硬实时任务是否能够安全运行的重要依据[1],迄今为止,针对硬实时单核系统的WCET估算技术已取得重大的研究进展[2],然而,随着嵌入式多核技术(如ARM11MPCore①,QorIQP4080②等)在硬实时系统领域的广泛应用,这类硬实时多核系统中往往存在着任务之间可以共享的资源,如共享的片上高速缓存和片上总线等,同时运行的硬实时任务在使用这些共享资源时可能会发生bank冲突、总线访问冲突等.这些冲突会给硬实时任务的执行带来不可预测的额外执行时间,这为WCET估算带来了新的技术挑战[3].由于基于单核的传统WCET估算技术无法支持对这类冲突的时间分析[4-5],为了获取安全的WCET,我们在对多核系统上的硬实时任务进行WCET估算时,必须重新估算这些冲突对执行时间带来的影响.目前,多bank结构已成为共享缓存设计的主要方向[6-8],例如一个多bank结构的L2缓存由多个bank组成,当多个请求同时到达L2缓存的一个bank时,只能有一个请求使用这个bank,其他请求必须等待,此时就发生了bank访问冲突.在对bank访问冲突的处理上,现有技术(如Paolieri[9]和Yoon[10]等)主要采用界定每个请求遭受的bank冲突延迟上限的方法.这种方法虽然可以简化WCET的估算,但需要借助于特殊的总线结构或总线仲裁策略将bank冲突延迟限制在一定范围内,如两层总线仲裁策略(twohierarchicalbusarbitration)[9]、和谐的轮询总线仲裁策略(harmonicround-robinbusarbitration)[10]等;然而,其他一些常见的总线结构或总线仲裁策略,如简单轮询策略(pureround-robinarbitration),与这类特殊的总线仲裁策略完全不同,采用上述bank冲突延迟上限界定法就无法有效界定每个请求遭受的bank冲突延迟上限.另外,这种界定bank冲突延迟上限的方法对硬实时任务的WCET估算过高.无论请求遭受到bank访问冲突与否,该方法为每个访存请求增加一个额外的bank冲突延迟上限.实际上,并不是所有请求都会遭受到bank访问冲突,并且即使在一组请求中发生了bank访问冲突,每个请求遭受的bank冲突延迟也不尽相同,如第1个访存请求就不会遭受到bank访问冲突.在硬实时多核系统中,运行在同核上的硬实时任务之间不存在bank访问冲突,而在不同核上同时运行的硬实时任务若因为共享某个bank,则它们之间可能存在bank访问冲突.因此,不同的核到bank映射方式对应的bank访问冲突不同,通过改变核到bank映射关系就可改变多核系统中bank访问冲突的情况.本文的主要目的是通过优化核到bank的映射关系来优化硬实时多核系统中的bank冲突延迟,进而对硬实时多核系统进行WCET估算.其中,硬实时多核系统中的L2缓存采用了多bank结构并进行column划分③,共享总线为采用简单轮询总线仲裁策略的时分多路复用(TDMA)实时总线.本文主要贡献如下:(1)对采用简单轮询总线仲裁策略的硬实时多核系统进行了bank冲突延迟分析,给出了bank访问冲突发生的条件和bank冲突延迟的计算方法;(2)根据bank访问冲突发生的条件,首先优化核到bank的映射关系以消除bank访问冲突.若不能消除bank访问冲突,则进一步优化核到bank的映射关系使bank冲突延迟最小化,并为该优化问题提出了一种基于多核总线请求时间序列的bank冲突延迟求解算法;(3)提出了多核硬实时任务的WCET估算方法,该方法综合考虑了任务在流水线上的执行时间、访问存储系统的时间和总线访问延迟之间的相互影响关系.本文第2节介绍相关工作;第3节给出硬实时多核系统模型,包括多核结构和应用模型;第4节分①②③Page3析bank冲突延迟;第5节提出优化问题,并设计求解算法;第6节设计多核硬实时任务的WCET估算方法;第7节给出实验环境及实验验证结果;第8节得出结论.2相关工作在硬实时多核系统中,与L2缓存相关的任务间冲突主要包括storage干扰和bank访问冲突.由于总线访问冲突与storage干扰或bank访问冲突之间存在着相互影响,因此在分析storage干扰或bank访问冲突时,一般需要结合总线访问冲突进行分析.一些现有的研究成果将共享总线设计和共享缓存划分技术结合起来,对请求遭受的总线访问延迟和bank冲突延迟进行分析,但采用了界定每个请求遭受的延迟上限的方法.如Paolieri等人[9]在其工作中,提出了一种二层总线仲裁的多核结构,用以界定每个总线请求遭受的总线访问延迟和bank冲突延迟,共享L2缓存采用缓存划分或bankization划分,以消除storage干扰或bank访问冲突;在采用bankization划分时,要求任务独占分配的bank以消除bank访问冲突,受bank数目的影响,这种方法受限制于硬实时多核系统的工作负荷.然而该方法仅适用于这类特殊的多核结构,且WCET估算方法采用了界定延迟上限的方法.再如在Yoon等人[10]的可调WCET(tunableWCET)、和谐的轮询总线仲裁策略等工作中,共享L2缓存采用二级划分结构,整个缓存被划分成多个bank,每个bank又进一步被划分成多个column.其中,核向bank做映射,硬实时任务向column做映射且独占分配的column以消除storage干扰.在优化时采用了界定bank冲突延迟和总线访问延迟上限的方法.然而该方法仅适用于和谐的轮询总线仲裁策略,同时采用界定延迟上限的方法造成WCET估算过高.另有一些研究成果是将storage干扰分析和总线访问冲突分析结合起来进行WCET估算,但在分析时却没有考虑bank访问冲突问题.如Andrei等人[11]和Rosén等人[12]提出的TDMA总线延迟分析和storageinterference延迟,优化了总线调度策略,其特点是,在这种TDMA总线中使用静态调度分析,总线时槽被静态地分配给不同的核.Chattopadhyay等人[13]提出了融合共享缓存和总线的WCET分析框架,在分析总线访问延迟时让循环的开始与总线调度周期的第一个时槽对齐,同时考虑到L2缓存的storage干扰,因此进行反复迭代与调整,直到结果稳定.虽然这种方法比Andrei等人[11]提出的方法效率高,但是该方法对WCET值估算仍过高.Kelter等人[14]通过界定TDMA偏移量(TDMAoffset)上界的方法来进一步提高分析效率,具体采用了Chattopadhyay等人[13]提出的分析框架来估算WCET,并用全局收敛性分析(globalconvergenceanalysis)来界定TDMA总线偏移量的上限.Kelter等人[15]静态分析(staticanalysis)了TDMA总线给请求带来的总线访问延迟,并给出了形式化证明.同时结合storage干扰分析估算了多核系统的WCET.Chattopadhyay等人[16]提出了一种多核系统的WCET分析框架,改进了文献[13]对循环结构的处理.在分析总线访问延迟时不再让循环的开始与总线调度周期的第一个时槽对齐,而是根据执行上下文(executioncontext),令请求的总线访问延迟为可能遭受的最大总线访问延迟.Li等人[17]分析了并行任务的WCET,首先使用信息序列图(MessageSequenceChart,MSC)将并行任务的生命期分成重叠(overlapping)和非重叠(nonoverlapping)两部分,对于重叠部分的分析,采用Chattopadhyay等人[13]提出的分析框架和Kelter等人[14]提出的界定总线偏移量的方法.还有一些研究成果将分析重点仅放在storage干扰上,均没有考虑bank冲突延迟和总线访问延迟对硬实时任务WCET的影响.如Yan等人[18]根据线程的程序控制流信息,计算线程在共享L2指令缓存上的storage干扰.Chen等人[19]通过指令的取指时间关系,分析了进程在共享缓存上的storage干扰.Ding等人[20]提出了动态锁指令缓存以消除storage干扰,该方法可灵活锁定循环结构对应的缓存空间.Liu等人[21]应用锁缓存技术来消除storage干扰.3硬实时多核系统模型3.1嵌入式多核模型如图1所示的一个嵌入式多核处理器含有Ncore个同构的有序(in-order)核,表示为C={c1,c2,…,}.每个核有自己私有的第一级数据缓存和指令cNcore缓存.由所有核共享使用的第二级缓存(unifiedL2cache)采用多bank结构,由Nbank个大小相等的bank组成,表示为B={b1,b2,…,bNbankPage4需要的时间为LM个时钟周期(cycles).使用Yoon等人[10]提出的缓存两级划分方法将每个bank进一步划分成相等的Ncolumn个columns.连接L2缓存和核的实时总线是全双工TDMA总线,该实时总线采用简单轮询调度策略,每个总线调度周期有Lround个等长的总线时槽,表示为R={s1,s2,…,sLround每个总线时槽的长度等于总线完成一次请求所需要的时间,表示为LB个时钟周期.假设LM/LB是整数,那么一个请求完成一次L2缓存访问至少需要(LB+LM)个时钟周期,设为Llat.核到总线时槽的映射是一一映射,且把核ci(∈C)映射到总线时槽si(∈R)上.请求访问L2缓存,发生缺失时需要访问主存,假设请求访问主存需要的时间为LL2penal个时钟周期.3.2多任务应用模型假设一组硬实时任务已经被分配到Ncore个核上,这些任务在执行过程中不能在核间迁移,同核上的任务将按顺序执行,那么某时间段内最多有Ncore个任务均匀分布在Ncore核上且并发执行.在确定任务到核的分配后,需要确定核需要的L2缓存大小,设HTi是分配到核ci的任务集合,任务τj(∈HTi)需要的L2缓存大小为Sizej个columns,则核ci需要的L2缓存大小为Sizeci=max(Sizej|1jni)个columns,其中ni为集合HTi中的任务数.采用类似于Yoon等人[10]所提方法来作核到bank的映射和硬实时任务到column的映射,按照核需要的最大L2缓存大小向bank作映射,当多个核共享使用某个bank时,在这些核上同时运行的任务之间有可能存在bank访问冲突.在作任务到column的映射时,任务独占分配给它的column.故不存在storage干扰.另外,采用Li等人[17]所提方法来处理任务间的共享代码和任务间的通信.如果多个任务共享使用某个函数或程序段,则为每个任务复制一份以取消任务间的代码共享.若任务间需要通信则采用邮箱机制来取消由同步带来的影响.4Bank冲突延迟分析设有Nk示为Cbk={c1,c2,…,cN{s1,s2,…,sN运行在ci(∈Cbk期中遭受的bank冲突延迟.如图2所示,当i≠1时bcdij可以用式(1)表示:bcdij=图2运行在核ci(∈Cb在第1个总线周期中,核c1(∈Cbkbank冲突延迟为0,即bcd11=0.一般地,bcd1j如图3所示,当cp(∈Cbk期上有访问bk的请求,且该请求是运行在核c1上的硬实时任务在第j个总线周期上访问bk的前一个请求,bcdpq是运行在核cp上的硬实时任务在第q个总线周期上遭受的bank冲突延迟,sp是其对应的总线时槽,则运行在核c1上的硬实时任务在第j个总线周期上遭受的bank冲突延迟可以表示为bcd1j=bcdpq+LM-(j-q-1)·Lround·进一步简化为式(2).bcd1j=bcdpq+LM-((j-q)·Lround+s1-sp)·LB,>00,{定义两核ci(∈C)和cj(∈C)之间的模距离为它们对应总线时槽的最小距离,即dij=min(|sj-si|,Page5图3运行在c1(∈CbLround-|sj-si|).为了判断一个bank上是否存在bank访问冲突,给出定理1如下.定理1.ci,cj∈Cbk上不存在bank访问冲突.证明.由于dijLM/LB,在式(1)中,LM-(si-s(i-1))·LB0,在式(2)中,LM-((j-q)·Lround+s1-sp)·LB0.由此可知,在访问bk的所有请求中,后一个请求所遭受的bank冲突延迟一定小于或等于前一个请求所遭受的bank冲突延迟.由于在访问bk的请求序列中,第一个请求的bank冲突延迟为0,又因为bank冲突延迟具有非负性,因此所有请求的bank冲突延迟都为0,即在bk上不存在bank访问冲突.5优化核到bank的映射5.1优化问题的形式化描述由定理1可知,在一个核到bank的映射中,若映射到任一个bank上的任意两个核之间的模距离大于等于LM/LB,则在整个系统上不存在bank访问冲突.用xik表示bk(∈B)是否有column分配给ci(∈C),若有(即ci∈Cbk用ncolik表示bk分配给ci(∈C)的column数目,如果xik=1,则ncolik>0,否则ncolik=0,由于硬实时任务独占分配给它的column,因此ncolik是整数.以xik和ncolik为决策变量,优化核到bank的映射使系统不存在bank访问冲突的形式化描述如下.目标函数:约束:Sizeci0,ncolik0,ci∈C,bk∈B(7)其中,约束(4)是指在硬实时多核系统中L2缓存满足硬实时任务的需求;约束(5)是指映射分配给每个核的column数需要满足每个核的需求;约束(6)是指在每个bank上分配的column数不超过bank的大小;约束(7)是非负约束.下面利用Ncore、LM/LB和Ncolumn参数来探讨通过优化核到bank的映射来消除bank冲突的判据.定理2.已知Ncore、LM/LB和Ncolumn,且L2缓存的容量大小满足需求,若Ncore/(LM/LB)>Ncolumn,则bank访问冲突可以通过优化核到bank的映射去消除(证明过程见附录).用Size(Ci)表示集合Ci(C)中,核需要的总column数.结合核需要的总column数,可以给出当LM/LB=2时能够通过优化核到bank的映射消除bank冲突的判据,如定理3.定理3.已知C、Ncoremod2=0、LM/LB=2、Ncolumn和Sizeci>0,1iNcore.将C分割成两个互不相交的子集C0和C1且满足:在任一子集中的任意两个核之间的模距离大于等于LM/LB.若在每个子集中能够找到一个核集合Csi(Ci),0i1,且满足Size(Csi)Size(Ci)modNcolumn,则bank访问冲突可以通过优化核到bank的映射去消除(证明过程见附录).定理2和3中的条件是判断bank冲突是否可以消除的充分条件,在许多应用场景中并不是所有硬实时系统的bank访问冲突都能够通过优化核到bank的映射消除,例如,在一个6核的硬实时多核系统中,L2缓存被划分4个大小相等的bank,每个bank又被划分成8个大小相等的column,核到总线时槽的映射及每个核需要的L2缓存的大小如表1所示.在这个例子中,使用上述优化方法对核到bank的映射进行优化,就不能使共享每个bank的任意两核之间的模距离都大于等于LM/LB.在这种情况中就无法通过上述优化方法来消除bank访问c1c2c3c4c5c6Page6冲突,但可通过优化核到bank的映射使多核系统遭受的bank冲突延迟最小化.设Nroci是运行在核ci(∈C)上的硬实时任务需要的总线周期数,Nrobk=max(Nroci|ci∈Cbk是共享bk的硬实时任务需要的最大总线周期数.根据式(1)和(2),发生在bk上的所有bank冲突延迟可以表示为∑(min∑Nrocij=1计算任务遭受的bank冲突延迟需要关注硬实时任务的执行特性,如访问L2缓存的时间、L2缓存的地址等,即需要关注硬实时任务的主存块到L2缓存的映射以及硬实时任务映射到L2缓存的哪些column上等.为了对WCET进行安全估算,当多核共享一个bank时,假设这些核上的硬实时任务发出的访问L2缓存的请求总是访问这个共享bank.在此基础上,通过优化核到bank的映射来最小化每个硬实时任务遭受的bank冲突延迟,根据式(8),该优化问题的形式化描述如下.目标函数:约束:Sizeci0,ncolik0,ci∈C,bk∈B(13)5.2优化问题求解目标函数(9)与目标函数(3)的区别在于在目标函数(3)中不需要计算bank冲突延迟,而目标函数(9)中则需要计算bank冲突延迟.5.2.1计算bank冲突延迟根据前面对bank冲突延迟的分析,计算bank冲突延迟,需要事先确定多核硬实时任务的总线请求时间序列.本文组合使用Chronos[22]和lp_solve①来获取同核上的硬实时任务的总线请求时间序列,用RQci时间序列,bank冲突延迟的计算过程主要由以下3部分组成.(1)计算总线访问延迟,确定请求访问总线的时间.设tj-1,tj(∈RQci相邻总线请求(分别表示为rqj-1,rqj)所对应的总线请求时间,badj-1为请求rqj-1遭受的总线访问延迟.若tj>(tj-1+badj-1),rqj遭受的总线延迟表示为badj=(Lround·LB+(si-1)LB-tjmod(Lround·LB))mod(Lround·LB);否则,badj=Lround·LB.(2)确定当前bank冲突延迟所在的总线周期.设RTkn为Nk请求时间的集合,令tmin=min(tj|tj∈RTkn)是RTkn中的最小值,则当前总线周期的开始时间为tmin-tminmod(Lround·LB).(3)计算bank冲突延迟.如果当前总线周期为第1个总线周期,则RTkn中第1个在该总线周期内访问总线请求遭受的bank冲突延迟为0,否则根据式(2)计算;而RTkn中在该总线周期内其他的访问总线请求所遭受的bank冲突延迟根据式(1)计算.算法1给出了发生在bk上的bank冲突延迟的计算方法.si为对应的总线时槽.在算法1的输出结果中,T_b_delay[i]是运行在核ci(∈Cbk任务所遭受的总bank冲突延迟,以便为估算硬实时任务的WCET做准备.第1、2行初始化,current_q[i]表示当前处理的总线请求时间,used[i]标记是否可以从请求序列里取第1个请求,若used[i]=True,则表示可以从请求序列里取第1个请求.第5行判断是否可以从请求序列中取出第1个请求到rq,第8~14行计算总线访问延迟;第15行更新current_q[i]为当前请求访问总线的时间,为计算bank冲突延迟做准备,并将请求标记为处理.第19、20行确定总线调度周期,round1是该总线调度周期的开始时间.第22行判断请求是否落在当前总线调度周期内.第24、25行计算当前总线周期内第1个请求的bank冲突延迟,第27、28行计算当前总线周期内其他请求的bank冲突延迟.第30行更新T_b_delay[i],此时,T_b_delay[i]是运行在核ci上的硬实时任务截止目前遭受的所有bank冲突延迟.第35行为计算在下一个总线周期中第1个请求所遭受的bank冲突延迟做准备.第37行计算在bankbk上发生的所①Lpsolveversion5.5.http://www.comp.nus.edu.sg/~Page7有bank冲突总延迟.算法1.计算发生在bk上的bank冲突延迟.输入:Cb输出:发生在bk上的各核bank冲突总延迟Total_delay[k],1.Total_delay[k]=0;2.T_b_delay[i]=0,current_q[i]=0,used[i]=True,3.WHILE(存在一个RQc4.FOR(i=1;i<=Nk5.IF(used[i]==True)THEN6.7.8.IF(rq<=current_q[i])THEN9.busdelay=LroundLB;10.ELSE11.busdelay=(si-1)LB-rqmod(LroundLB);12.busdelay=LroundLB+busdelay;13.busdelay=busdelaymod(LroundLB);14.ENDIF15.current_q[i]=rq+busdelay;16.used[i]=False;17.ENDIF18.ENDFOR19.在current_q[Nk20.round1=M_q-M_qmod(LroundLB);21.FOR(i=1;i<=Nk22.IF(current_q[i]<=(round1+(si-1)LB))THEN23.IF(current_q[i]是第1个请求)THEN24.B_delay=Init_delay-(round1+siLB);25.IF(B_delay<0)THENB_delay=0;26.ELSE27.B_delay=B_delay+LM-(si-pre)LB;28.IF(B_delay<0)THENB_delay=0;29.ENDIF30.T_b_delay[i]=T_b_delay[i]+B_delay;31.pre=si;32.used[i]=True;33.ENDIF34.ENDFOR35.Init_delay=round1+B_delay+LM+preLB;36.ENDWHILE37.Total_delay[k]=∑c38.RETURNTotal_delay[k],T_b_delay[i];5.2.2优化问题的求解算法设Zk是共享bk(∈B)的所有硬实时任务之间模距离小于LM/LB的模距离的数.若Zk=0,则共享bk所有硬实时任务之间的模距离都大于等于LM/LB,根据定理1,在该bank上不存在bank访问冲突,否则,在该bank上可能存在bank冲突.算法2给出了该优化问题的求解算法.第4~25行按照c_seq[]依次做核到bank的映射.根据式(1)和(2)可知,bank冲突延迟具有积累性,在做核到bank映射时,映射到一个bank上的核应尽可能的少;另外,算法1在计算bank冲突延迟时不考虑一个bank中的column在地址上的区别,因此核到bank的映射过程可以简化如下:c_seq[]中的核依次向bankb1映射,b1分配完后,再向b2映射,b2分配完后,向b3映射,依次类推,c_b_mapping[Ncore][Nbank]存放当前核到bank的映射关系.第26行计算所有的Zk,第27行判断该映射是否存在bank访问冲突.若存在bank访问冲突,第32行调用算法1计算发生在每个bank上的bank冲突延迟.第36行计算总的bank冲突延迟.第38、39行更新最优结果.第43~48行回溯搜索解空间.第50~54行是主过程,在第50行根据定理2、3进行判定,若bank冲突不能消除,则在第52行调用F_M_Mapping(n)求解.算法2.优化核到bank的映射关系,使bank冲突延迟最小.输入:C,Ncore,LM,LB,B,Nbank,Ncolumn,RQc输出:最小的bank冲突延迟(M_delay)、相应的核到1.设置Zk、M_delay初值、used[]为False;2.FUNCTIONF_M_Mapping(n)3.IF(n>Ncore)THEN4.n_bank=1,n_col=Ncolumn;5.WHILE(i<=Ncore)DO6.7.IF(n_core>=n_col)THEN8.9.10.11.12.13.ENDWHILE14.IF(n_core==0)THENi++;15.ELSE16.17.18.Page819.20.ELSE21.c_b_mapping[j][n_bank]=n_core;22.n_col=n_col-n_core;23.i++;24.ENDIF25.ENDWHILE26.计算Zk,1kNbank;27.IF(所有的Zk都为0)THEN28.M_delay=0;29.ELSE30.FOR(k=1;k<=Nbank;k++)DO31.IF(Zk>0)THEN32.33.ENDIF34.ENDFOR35.ENDIF36.b_delay=∑37.IF(b_delay<M_delay)THEN38.M_delay=b_delay;39.M_mapping[][]=c_b_mapping[][];40.ENDIF41.RETURN42.ENDIF43.FOR(i=1;i<=Ncore;i++)DO44.IF(!used[i])THEN45.c_seq[n]=ci;used[i]=True;46.F_M_Mapping(n+1);used[i]=False;47.ENDIF48.ENDFOR49.ENDFUNCTION50.利用定理2、3判断bank冲突是否可以消除;51.IF(bank冲突不能消除)THEN52.F_M_Mapping(1);53.ENDIF54.RETURNM_delay,M_mapping;6WCET估算6.1WCET估算的预备知识Theiling等人[23]提出的共享缓存的抽象解释(abstractinterpretation)分析法,是将指令根据访问共享缓存是否命中分成:Always-Hit(AH)、Always-Miss(AM)、PerSistence(PS)和Not-Classified(NC)四类.AH是指访问共享缓存总是命中的,AM是指访问共享缓存总是缺失的,PS是指第1次访问共享缓存是缺失而以后的访问都是命中的,而其他情形则属于NC类.一个五级流水线模型[24]由取指(IF)、译码(ID)、执行(EX)、写回(WB)和提交(CM)组成.在取指阶段中,按指令在程序中的顺序将指令从存储系统中依次取出,存放到取指缓存(I-buffer);在译码阶段中,将取指缓存中的指令进行译码操作并按在程序中的顺序发送到ROB(Re-OrderBuffer).在执行阶段,ROB中的指令发送到相应的执行单元进行执行.对于Load指令,执行阶段只计算有效存储地址,在写回阶段取操作数.在写回阶段,一方面Load指令从存储系统中取操作数,另一方面将执行阶段的执行结果写回ROB.在提交阶段,指令按照在程序中的顺序提交.Li等人[25]提出了执行图(ExecutionGraph)的概念,该执行图描述了控制流图(CFG)的一个基本块(basicblock)在五级流水线模型上执行状态.本文设计的多核多任务WCET估算方法是在Chronos的基础上,增加了对多核共享资源冲突延迟语义的分析支持.Chronos是单核硬实时任务的开源WCET估算工具,该工具可对二进制执行文件进行反汇编,以形成控制流图及执行图,并利用该图对指令在流水线阶段间的依赖关系进行分析处理,以及估算基本块的最差情况下执行时间.一般地,利用Chronos可获得如下内容:(1)基本块的最差情况下执行时间;(2)任务的控制流图;(3)基本块中每个请求的总线请求时间;(4)指令的AH、AM、PS和NC分类等.6.2WCET估算方法设ci(∈C)的执行时间是指运行在ci上某硬实是ci遭受的所有总线访问延迟,Dbank时任务的执行时间.设Tp间,Tmci缓存所需要的时间,nqciDbusci所有bank冲突延迟,ci在最差情况下的执行时间可以表示为WCETci=TpDbusci+Dbank以直接用单核WCET估算工具估算,Dbank法1计算得到.令WCETci=TpLlat+Dbus由于多核多任务在流水线、请求访问总线和请Page9求访问存储系统中可以并发执行,那么某个任务在流水线上的执行时间、总线访问延迟和存储系统访问时间之间可能存在着时间重叠问题.另外,由于核与TDMA总线时槽之间已确立对应关系,在计算多核总线访问延迟时,总线访问冲突延迟可转换为请求等待自己对应的总线时槽.为此,我们在Chronos基本块最差执行时间分析模块的基础上,增加了对多核总线访问延迟、时间消重等语义的支持,实现了下面的算法3.算法3给出了估算一个基本块(记为blk)最差情况下执行时间的方法,该算法是在Chronos分析工具中实现的.由于PS指令在第1次执行中是缺失的且在后续执行中总是命中的,若一个基本块在循环结构中,它的第1次执行和后续执行的最差情况下执行时间是不同的.在算法3中,用first标识基本块是否为第1次执行,first=0表示该基本块的第1次执行,first=1表示该基本块的非第1次执行.令offset为基本块开始执行时对应的总线偏移量,若基本块的开始时间为tb,对应的总线偏移量可以表示为offset=tbmod(Lround·LB),且0offset<Lround·LB,对于不同的offset值,基本块有一个最差情况下执行时间与之对应,存放在MET[first][blk][offset]中.Tstage(i)(sta)和Tstage(i)(fin)分别是指令i在stage阶段的开始时间和完成时间,若指令i在stage阶段需要访存,则Tstage(i)(sta)为请求申请总线的时间.Tn(fin)是基本块最后一条指令的完成时间,T1(ready)是基本块的第一条指令的准备时间.第1~10行定义计算总线访问延迟的函数Com_bdelay(),pre是前一个请求访问总线的时间,其值为对应流水阶段的开始时间与总线访问延迟的和.在第2~8行计算总线访问延迟,若当前请求申请总线的时间小于或等于前一个请求访问总线的时间,则消重,总线访问延迟为(Lround·LB)个时钟周期(第3行).否则,在第6、7行计算总线访问延迟.第13行先利用Chronos流水线分析对基本块blk进行分析(包括L1缓存分析),可得到指令在各个流水线阶段上的执行时间及依赖关系,但此时并未涉及总线访问延迟的影响.对于基本块中的每条指令及每个流水线阶段,第19~25行和第27~33行分别处理first取不同值的情况,第20和28行分别调用函数Com_bdelay()计算总线访问延迟.在第22、24、30和32行分别更新相应流水线阶段的完成时间.使用Chronos的原有处理依赖关系的方法,第36行更新指令i在后续流水线阶段上的依赖关系,第38行更新指令i的后续指令的依赖关系.第40行计算该基本块的最差情况下执行时间.算法3.多核环境下某任务基本块最差情况下的执行时间分析.输入:基本块blk的执行图,Lround,对应的总线时槽sj输出:基本块blk最差情况下执行时间MET[first]1.FUNCTIONCom_bdelay(start,offset,pre);2.IF(start<=pre)THEN3.busdelay=LroundLB;4.ELSE5.cur=start+offset;6.busdelay=(sj-1)LB-curmod(LroundLB);7.busdelay=(LroundLB+busdelay)mod(LroundLB);8.ENDIF9.RETURNbusdelay;10.ENDFUNCTION//以下为主过程11.FOR(first=0;first<=1;first++)DO12.FOR(offset=0;offset<(LroundLB);offset++)13.pipeline_analysis();14.pre=0;15.FOR(依次取blk中的每条指令i)DO16.FOR(stage=0;stage<pipe_stages;stage++)17.IF(i在stage阶段访问存储系统)THEN18.19.20.21.22.23.24.25.26.27.28.29.30.31.32.33.34.35.ENDIF36.37.ENDFORPage1038.更新后续指令的依赖关系;39.ENDFOR40.MET[first][blk][offset]=Tn(fin)-T1(ready);41.ENDFOR42.ENDFOR43.RETURNMET[first][blk][];利用算法3可以估算出每个基本块在不同开始时间下的最差情况下执行时间(同时考虑到基本块是否在循环中且是否有PS指令),共有(2·Lround·LB)个值.根据基本块在控制流图中的执行次序和开始时间(设第一个执行的基本块的开始时间为0),从每个基本块的(2·Lround·LB)个值中选择一个用来估算硬实时任务的WCETci.对于一个基本块blk,设Tblk(sta)、offsetblk和Tblk(fin)分别为该基本块的开始时间、总线偏移量和完成时间.开始时间Tblk(sta)是其直接前驱的最迟完成时间,总线偏移量offsetblk可以表示为offsetblk=Tblk(sta)mod(Lround·LB),设pre为基本块blk的直接前驱,offsetpre为基本块pre的总线偏移量.offsetblk可以表示为式(15),完成时间Tblk(fin)可以表示为式(16).offsetblk=(offsetpre+MET[first][pre][offsetpre])·Tblk(fin)=Tblk(sta)+MET[first][blk][offsetblk]若控制流图存在循环结构,则全部展开,对于事先不能确定循环次数的循环结构,按照Chronos处理方法将循环次数的最大上限作为循环次数展开.此时,整个控制流图仅存在分支和顺序结构,且一个基本块的开始时间等于其直接前驱的最大完成时间.反复使用式(15)和(16)可以计算最后一个基本块的完成时间.以MlardalenWCETbenchmark[26]测试程序集中的fibcall测试程序为例,说明利用算法3的结果估算WCET的方法.图4(a)是fibcall的控制流图,其中,圆形代表基本块,圆形内的数字为基本块的编号,旁边的数字为该基本块的执行次数,有向边代表基本块的先后次序.将循环展开后的控制流图如图4(b)所示,若基本块在循环中,标识出该基本块是第几次执行.设fibcall在该例中对应的总线时槽为si,开始执行时间为Tst.则基本块0的开始时间T0(sta)=Tst,对应的总线偏移量offset0=((si-1)·LB+T0(sta))·mod(Lround·LB),利用式(16)可以得到基本块0的完成时间T0(fin)=T0(sta)+MET[0][0][offset0].基本块2的开始时间T2(sta)=T0(fin),根据式(15)和(16),可得基本块2的总线偏移量和完成时间,即offset2=(offset0+MET[0][0][offset0])·mod(Lround·LB),T2(fin)=T2(sta)+MET[0][2][offset2].接下来,可以获得基本块3第1次执行的开始时间(记为T3(1)(sta))、总线偏移量(记为offset3(1))和完成时间(记为T3(1)(fin)).处理完基本块3的第1次执行,进入分支结构的处理,反复利用式(15)和(16)可以得到基本块4第29次执行对应的总线偏移量offset4(29)和完成时间T4(29)(fin),T4(29)(fin)=T4(29)(sta)+MET[1][4][offset4(29)].基本块5的开始时间T5(sta)=max(T3(1)(fin),T4(29)(fin)),总线偏移量offset5=(offset3(1)+T5(sta)-T3(1)(sta))·mod(Lround·LB),最终可以得到基本块1的完成时间T1(fin)=T1(sta)+MET[0][1][offset1],即该例的WCETci=T1(fin).算法4是基于算法3的多核环境下硬实时任务最差情况下执行时间的分析算法.第1~21行定义了处理分支结构的函数Com_branch(),输入参数Pn指向分支结构的开始基本块,Nbr_Pn是分支结构的分支数,offset是分支结构开始时对应的总线偏移量,first标识该基本块是否是第一次执行,blk是基本块编号,br_exe[i]是分支i的总执行时间(相对于分支结构的开始时间),第7行根据式(16)计算当前基本块的完成时间,第8、9行根据式(15)计算总线偏移量,第10~15行处理嵌套分支结构,第10行判断是否有分支结构,若有,则在第11行读取分支的数目Nbr_Pb,在第12行调用Com_branch()处理分支结构.第19行获得分支结构的最大完成时间Page11(相对于分支结构的开始时间).第23行建立链表TSLinkList,若存在分支结构,则在链表中用分支结构的开始基本块对应的链表结点指向分支结构的结束基本块对应的链表结点,分支结构的分支存放在分支结构的开始基本块对应的链表结点中.第28、33行分别计算当前基本块的完成时间(相对于任务开始时间).第38行根据式(14)计算任务的最差情况下执行时间.算法4.多核环境下硬实时任务最差情况下执行时间的分析.输入:循环已展开的控制流图,每个基本块的执行图,输出:硬实时任务的最差情况下执行时间MT_exe1.FUNCTIONCom_branch(Pn,Nbr_Pn,offset)DO2.FOR(i=1;i<=Nbr_Pn;i++)DO3.boffset=offset,br_exe[i]=0;4.Pb指向Pn的第i个分支的第一个基本块;5.WHILE(Pb不为空)DO6.7.br_exe[i]=br_exe[i]+MET[first][blk]8.boffset=boffset+MET[first][blk][boffset];9.boffset=boffsetmod(LroundLB);10.11.12.13.14.15.16.17.ENDWHILE18.ENDFOR19.Mb_exe=max(br_exe[i]|1iNbr_Pn);20.RETURNMb_exe;21.ENDFUNCTION//以下为主过程22.调用算法3估算每个基本块的最差情况下执行时23.读取控制流图,建立链表TSLinkList(有头结点);24.offset=(sj-1)LB,MT_exe=0;25.Pn=TSLinkList->next;26.WHILE(Pn不为空)DO27.获得由Pn指向的基本块标识blk和执行信息first;28.MT_exe=MT_exe+MET[first][blk][offset];29.offset=(offset+MET[first][blk][offset])·30.IF(Pn有分支)THEN31.获得Pn指向基本块的分支数Nbr_Pn;32.tmp_exe=Com_branch(Pn,Nbr_Pn,offset);33.MT_exe=MT_exe+tmp_exe;34.offset=(offset+tmp_exe)mod(LroundLB);35.ENDIF36.Pn=Pn->next;37.ENDWHILE38.MT_exe=MT_exe+Dbank;39.RETURNMT_exe;7实验验证使用MlardalenWCETbenchmark[26]测试程序集分别设计无bank访问冲突、存在bank访问冲突的两个实验场景,来验证前面提出的算法的正确性.7.1无bank访问冲突的应用场景7.1.1实验环境和测试程序由6个同构核{c1,c2,…,c6}组成的多核系统中,每个核有一个有序(in-order)5级流水线,无分支预测功能,取指队列大小为4,取指宽度为2,指令窗大小为8.每个核有私自L1数据和L1指令缓存,大小均为64字节,1个bank,2路关联,每line有8字节,1个时钟周期的访问时间,采用LRU替换策略.L2缓存为所有核共享,大小为4KB,被均匀划分成4个bank,每个bank的大小为1KB,4路关联,每line有32Bytes,4个时钟周期访问时间(即LM=4),采用LRU替换策略.每个bank又被均匀划分成8个column.每个column的大小为128Bytes(即1组4路关联的line).连接L2缓存和核的总线为TDMA实时总线,采用简单轮询总线调度策略,总线完成一次请求所需要的时间为2个时钟周期,即LB=2.请求访问主存需要的时间为LL2penal=30个时钟周期.使用的测试程序是MlardalenWCETbench-mark测试程序集中的一部分,测试程序的特性如表2所示.为了给测试程序分配合适的L2缓存大小,我们使用Chronos测量这些测试程序在分配给测试程序bsort100fibcallexpintinsertsortprimePage12不同L2缓存大小时的WCET,测量结果和采用的L2缓存大小如表3所示.表3不同L2缓存大小时测量的WCET(时钟周期)和缓存大小bsort100cntexpintfibcallinsertsortprime128B688805035752169219701363575000256B688833050633168739701149975000512B10027500390401719197011451750001024B9263600291521719197011451750002048B2965080291521719197011451750004096B296508029152171919701145175000采用值2048/161024/8256/2128/1512/4128/17.1.2实验结果实验中采用的任务到核映射和核到总线时槽映射如表4所示.用Chronos得到各任务访问L2缓存的总线请求时间序列如图5所示.使用算法2做核到bank映射,若可能存在bank访问冲突,则用算法1计算bank冲突延迟,结果如图6所示,解空间为720,总的bank冲突延迟的范围为[0,149560],其中一个不存在bank访问冲突的映射关系如表5所示.在表5所示的核到bank映射关系中,映射到任意一个bank上的任务之间的模距离都大于等于2.由于LM/LB=2,因此,在该映射中不存在bank访问冲突.测试程序insertsortbsort100fibcall表5一个没有bank冲突延迟时核到bank映射关系测试程序insertsortixpintbsort100fibcallprime为了考察优化核到bank映射后对WCET的影响,取表6所示的核到bank映射作为未优化时的映射,在该映射下各任务遭受的bank冲突延迟如表7所示.使用算法4(调用算法3)估算了在两个映射下各任务的WCET,结果如图7所示,所有测量结果都是相对于任务在单核系统中测量的结果(下同).在图7中,Opt表示优化核到bank映射后估算的结果,no_Opt表示未优化核到bank映射时估算的结果.从图7中可以看出,相对于未优化时的估算结果,优化映射后对所有任务的WCET有不同程度的改善,平均提高了约15%.对expint的WCET改善程度最大,提高了大约50%.虽然bsort100遭受的bank冲突延迟为43736个时钟周期(如表7所示),但由于其规模较大,改善效果相对不明显(提高了约1%).另外,在这两个映射中,insertsort和fibcall都没遭受到bank访问延迟,估算的WCET未发生变化.测试程序insertsortexpintbsort100fibcallprime表7在表6所示的映射中各任务遭受的bank冲突延迟insertsortAI+ILP(抽象解释加整数线性规划)方法是现有文献估算WCET的常用方法,如Chattopadhyay等人[13]、Kelter等人[14-15]等.AI+ILP方法的共同Page13图7优化核到bank映射后和未优化时的估算结果对比点是分别估算每个基本块在流水线上的执行时间、访问共享L2缓存的时间、访问主存的时间和总线访问延迟,然后用线性规划求解工具将这些时间组合起来得到任务的WCET,这里,我们将这类方法统称为“AI+ILP”方法.分别使用算法4和AI+ILP方法估算了在表5所示的映射中各任务的WCET值(没有bank冲突),结果如图8所示.其中,Alg4代表使用算法4对总线访问延迟进行了消重的估算结果,AI+ILP代表使用AI+ILP未对总线访问延迟进行消重的估算结果.相对于AI+ILP方法而言,算法4对任务的WCET有不同程度的改善,平均提高了约30%.影响估算结果的主要因素有访问L2缓存的次数、访问密集度和指令在流水线上的依赖关系等.insertsort的多数访存指令都集中在基本块3中(使用Chronos获得),需要进行消重的计算较多,改善程度最大,提高了大约50%.bsort100访问L2缓存的次数为394210次(如图5所示),消重效果也比较明显(约45%).由于fibcall的访问次数很少,因此改善效果不明显.虽然prime的访问次数也较大(9335次),但受到其指令间依赖关系的影响,抵消了对总线延迟消重后的效果.图8算法4和AI+ILP方法估算的结果对比分别使用两种方法对每个任务进行20次估算,20次运行时间的平均值如表8所示.由此可以看出,由于算法4需要调用算法3并参与时间消重计算,因此其运行时间比AI+ILP方法有所提高.测试程序insertsortexpintbsort100fibcallprime7.2存在bank访问冲突的应用场景为了验证bank访问冲突不能消除时的优化效果,我们设计了相应的应用场景.在实验环境中,L2缓存的容量大小为3KB,被均匀划分成3个bank,每个bank的大小为1KB.每个bank又被均匀划分成8个column,每column的大小为128Bytes.其他参数的设置值采用7.1.1节中实验环境的相应参数值.使用了表2中的5个测试程序,如表9所示.7.2.1实验结果在实验中采用的任务到核映射和核到总线时槽映射如表10所示.在该应用场景中,核c6空闲,不占用总线时间,即每个总线调度周期的长度为5·LB=10个时钟周期.各任务访问L2缓存的总线请求时间序列如图5所示.执行算法2做核到bank映射,结果如图9所示,解空间为120,总的bank冲突延迟范围为[33704,110660].具有最小bank冲突延迟的核到bank的映射如表11所示,在该映射中,只在bankb1上存在bank访问冲突,各个任务遭受的bank冲突延迟如表12所示.表10使用的任务到核的映射和核到总线时槽的映射测试程序insertsortbsort100Page14表11一个bank冲突延迟最小的核到bank映射测试程序insertsortbsort100fibcall表12在表11所示的映射中各任务遭受的bank冲突延迟取表13所示的核到bank映射作为未优化时的映射,在该映射下各任务遭受的bank冲突延迟如表14所示.使用算法4估算在两个映射下各任务的WCET,结果如图10所示.从图10中可看出,相对于未优化时的估算结果,优化映射后对所有任务的WCET有不同程度的改善,平均提高了约10%.对insertsort的WCET改善程度最大,提高了大约20%.虽然bsort100遭受的bank冲突延迟为37840个时钟周期(如表14所示),但相对效果不明显(约1%).测试程序insertsortbsort100fibcall表14在表13所示的映射中各任务遭受的bank冲突延迟图10优化核到bank映射后和未优化时的估算结果对比分别使用算法4和AI+ILP方法估算在表11所示的映射中各任务的WCET(各任务遭受的bank冲突延迟如表12所示),结果如图11所示.相对于AI+ILP方法而言,算法4对任务的WCET估算结果有不同程度的改善,平均提高了约25%,例如对bsort100WCET的改善程度约为45%,对fibcallWCET的改善程度约为5%,对primeWCET的改善程度约为8%.另外,在该场景下,分别使用两种方法对每个任务进行20次估算,20次运行时间的平均值如表15所示,由此可以看出,由于算法4需要调用算法3并参与时间消重计算,因此其运行时间比AI+ILP方法有所提高.图11算法4和AI+ILP方法估算的结果对比测试程序insertsortexpintbsort100fibcall8结论本文提出了通过优化核到bank映射来最小化Page15硬实时多核系统的bank冲突延迟方法,旨在通过消除bank访问冲突或最小化bank冲突延迟来改善多核系统中硬实时任务的WCET.通过对硬实时多核系统中bank冲突延迟的分析,我们得出了硬实时任务间不存在bank访问冲突的判断条件,并用优化核到bank映射的方法来消除bank访问冲突.然而,并不是所有的bank访问冲突都可以消除,此时需要优化核到bank映射来最小化bank冲突延迟.为此,我们设计了求解该优化问题的相应算法.另外,还设计了能够对总线访问延迟进行消重的WCET估算方法.实验结果表明,本文提出的优化方法可以消除硬实时多核系统中的bank访问冲突或使bank冲突延迟最小化.与现有WCET估算方法比较,本文提出的WCET估算方法可以获得更精确的WCET值.
