Page1用于转录因子结合位点识别的定位投影求精算法张懿璞霍红卫于强郭鸿志(西安电子科技大学计算机学院西安710071)摘要定位转录因子结合位点,也称模体发现问题,对于理解基因调控关系非常重要.文中提出了一种新的定位投影求精算法(Fixed-PositionProjectionRefinementalgorithm,FPPR)用于DNA序列中的转录因子结合位点识别.通过一个基于数据集对应位置频率矩阵的投影过程,将DNA数据聚类为不同的子集,过滤选出其中具有一定信息量和复杂度的子集,作为初始状态,进而使用期望最大化算法进行求精.FPPR通过对定位投影过程中阈值的设定,实现了对OOPS、ZOOPS、TCM这3种模型中不同模体实例分布的处理.同时,结合高阶马尔可夫背景设计目标函数,使得算法的概率模型更加符合真实生物数据.此外,通过相似函数WIC评估,FPPR可拓展为解决多模体识别问题.真实数据测试表明,FPPR可以在合理的时间内准确找寻模体,与MEME、GAME、MotifSampler和GALP-F等算法相比有更好的性能,并且可以有效地解决多模体识别问题.关键词转录因子结合位点;模体;定位投影;求精1引言转录因子结合位点是DNA序列中基因调控区域的一些核苷酸片段,通常小于30个碱基长度.转录因子结合位点和指定蛋白质组别之间的内在关系决定了转录工作的活性并且支配着基因表达水平.识别核苷酸序列中的转录因子结合位点TFBS(Tran-scriptionFactorBindingSites),对开发潜在的调控关系以及研究生物体进化有着重要意义,已经成为了现今生物信息学中最为广泛研究的问题之一.用于寻找转录因子结合位点的计算方法一般分为两类[1]:denovo方法和基于训练的方法.denovo方法是分析基因上游区域中的过表达模体,一般预测结合位点时不使用任何先验知识[2].这一类方法通常使用的手段有位置偏移(模体集中于转录起始位点附近)[3]、特异性(比较模体在编码区域和非编码区域的位置)[3]、背景模型下最小可能性[4]等.另一类基于训练的方法,使用一组已知的位点集来获取统计信息从而预测结合位点.这类方法通常使用基于位置频率矩阵的一致性方法[5]、结合位点的贝叶斯模型[6-8]、结合位点的隐马尔可夫模型[9]以及生物物理方法[10]这几种手段解决问题.这些方法通常都使用一些特殊的位置频率矩阵描述在一定的排列下,每个碱基在各个位置发生的概率,其中著名的算法有:使用期望最大化算法(ExpectationMaximization)[11]的MEME[12]、基于贪心概率模型的算法Consensus[5]、基于吉布斯采样(Gibbssample)的算法GibbsDNA[13]等.近年来,基于训练的模体识别方法有着较快的发展.其中,遗传算法GA(GeneticAlgorithm)被广泛地与模体发现问题相结合.Wei和Jensen[14]提出了一个基于GA的模体识别算法GAME,使用基于贝叶斯的后验分布作为适应度函数.而另一个利用GA的算法GALF-P[15]是在搜索阶段和自适应模型后的处理时加入了一个局部的过滤操作.Huo等人[16]提出的算法GOBMD(GeneticOptimizationwithBayesianModelforMotifDiscovery)则是通过随机投影为遗传算法提供良好的初始种群从而进行求精.同时,基于期望最大化和吉布斯采样的算法也有了进一步的发展.Thijs等人[17]将问题模型与高阶背景相结合,通过概率分布估计模体数来优化吉布斯采样过程.Li[18]提出的GADEM(GeneticAlgorithmguidedformationofspacedDyadscoupledwithEMforMotifidentification)算法通过构建隔开的二分体模型与EM相结合来同时寻找两个模体.Bi[19]提出MECEMDA(MonteCarloEMMotifDiscoveryAlgorithm)算法将蒙特卡罗采样与期望最大化算法相结合来寻找模体.Reid等人[20]通过一个结合后缀树的期望最大化算法STEME(SuffixTreeEMforMotifElicitation),减少了运算量并且缩小搜索空间,可以很好地解决高通量的生物数据.除此之外,聚类方法也在模体发现问题中得到了广泛的应用.Mahony等人[21]的SOMBRERO(Self-Or-ganizingMapforBiologicalRegulatoryElementRecognitionandOrdering)算法是对位置权重矩阵进行自组织映射(self-organizingmap)来识别模体.CRMD[22]则是构建模体及其实例的分布统计模型,用一个基于熵值的聚类过程筛选模体.但是在结合遗传算法的模体识别方法中,由于表示候选模体的初始群体是随机产生的,加之搜索空间巨大,就需要较大的群体规模和迭代次数,对遗传算法的速度和有效性会产生一定的影响.并且,因初始状态的选择而导致收敛到不同局部最优解的缺点,同样也出现在基于期望最大化和吉布斯采样的算法中.本文提出了一种新的基于训练的模体识别算法FPPR(FixedPositionProjectionRefinementalgorithm),应用于转录因子位点识别.通过设计一种新的投影方法,定位投影,FPPR对数据集进行分解,选取具有一定保守性和复杂度的子集作为初始状态来进行求精.FPPR结合高阶马尔可夫背景模型和在序列中模体分布的具体模型,使用信息熵作为目标函数,可更加准确地描述候选模体的特征.同时,使用期望最大化算法的参数更新方式对子集进行求精,可以保证每个合格子集快速收敛至一个局部最优解,从而提高识别准确率.此外,引入相似度函数WIC对求精结果进一步细化,可以解决更为困难的多模体识别问题.真实数据的实验证实,FPPR可以在合理的时间内准确地识别数据中的潜在模体.并且,与MEME、GAME、MotifSampler和GALP-F这些经典的模体识别算法相比,FPPR对识别模体有着更加精确的定位和更为高效的效率.多模体数据的测试也表明了FPPR在解决多模体识别问题时的有效性.2模型与方法概述2.1问题定义及概率模型对已知的DNA序列集合,我们要寻找模体对应的调控位点,即根据给定的模体长度定位所有转Page3录因子结合位点.问题的输入是一组未经对齐的DNA序列,目标是寻找一个或多个模体,也就是一个或多个核苷酸片段.核苷酸片段通常出现在大部分的序列中,我们假设其长度已知(通常小于30个碱基).下面给出的是DNA序列中模体发现问题的形式定义:已知DNA序列集合S={S1,…,Si,…,St},其中,Li表示序列Si的长度,sij表示字符集Σ={A,C,G,T}中的一个字符,sij出现在序列Si的第j个位置(j=1,…,Li).假设模体长度l已知,我们令l-mer表示一个长度为l的碱基片段,例如,l-mer=si,j+1si,j+2…si,j+l-1表示第i行第j个位置起始的子序列.根据起始位置j选择的不同,每条序列包含有ni=Li-l+1个长度为l的子序列.模体通常可由一致序列(consensus)或概率谱(probabilisticprofiles)[23]表示.而概率谱又常以一个位置频率矩阵犘犉犕(ProbabilisticFrequencyMatrix)来表示模体.犘犉犕是一个大小为4×l的矩阵,每一列对应着模体长度l中的一个位置,其中的图1犘犉犕计算流程2.2模体保守性和背景模型根据概率谱上基于模体和背景分布的概率模型,模体的保守性可以通过计算相对熵[26],也称为信息量(InformationContent)来评估:这里θ0k为碱基k的背景概率.相对熵用于度量碱基对于相应背景分布的保守性,它的值越高,则模体的保守性越高.文献[27]指出,相对熵是模体发现算法中最具有影响的因素之一.大部分识别转录因子结合位点(模体发现)的研究方法都假设转录因子和DNA结合之间相互作用的信息为一维的核苷酸序列.Benos等人[28]认为,一维的核苷酸序列模型虽不尽完美,但是提供了一个较为近似的模型用于匹配真实的蛋白质-DNA的相互作用.但是,在实际中,这样的相互作用发生在一个三维的空间中,并且理想的模型应结合DNA的形态特征.比如,在真核生物中,DNA是以压缩染色体的形式存储,而大部分被蛋白质包裹的DNA元素表示相应碱基(A,C,G,T)出现的频率.Liu等人[24]提出了一个多项分布模型[24]:Θ=(θ1k,…,θwk,…,θlk)(k∈Σ),θwk表示碱基k在模体第w个位置出现的概率.θ0k表示碱基k出现在序列中无模体发生的位置,也称为背景分布.这样由模体和背景2个成分组成的模型,被广泛用于基于期望最大化[12,25]和吉布斯采样[13]等模体发现算法.犘犉犕可以由计算一个计数矩阵犖中每个对齐(alignment)位置上各碱基的相应频率得到.为了避免某个碱基概率为0在计算中带来的不便,我们使用了一种简单并且被广泛应用的方法,给计数矩阵中加入一个伪计数.这样犘犉犕可表示为这里,Nwk为碱基k在第w个位置出现的次数,ε是伪计数,一般根据位点的数量进行变化,通常取值为1.图1描述了模拟数据中如何计算犘犉犕的过程.序列为组织蛋白.这对于未来模型的发展是一个重要的信息,因为部分序列是包裹在组织蛋白周围的,那么它们就无法自由地与DNA结合蛋白(如转录因子)相互作用.在生物序列中进行模体识别时,另一个重要的问题是如何选择背景模型,这将极大地影响结果的准确性.使用高阶马尔可夫模型[29]可以有效提升转录元素的鉴别率.本文算法使用零阶和三阶马尔可夫模型作为背景模型参考.与零阶马尔可夫模型碱基各自独立分布不同,在三阶马尔可夫模型中,序列ATGCG的概率值可通过p0(ATGCG|θ0)=p(ATG)×p(C|ATG)×p(G|TGC)计算得到.一般地,背景模型概率可通过输入序列进行估计,但有时也可以使用外部的序列集合作为参考,比如,某个有机物种的整个启动子集.拓展为一个更为普遍的形式:当碱基在每个位置不独立时,信息量函数可以IC(Θ,θ0)=∑u∈Σlp(uΘ)logp(uΘ)Page4这里,l是模体长度;p(u|Θ)表示在模体分布Θ下产生碱基片段u的概率,p(u|θ0)为背景分布θ0下产生同样片段的概率.注意到,当背景模型为零阶马尔可夫过程时,式(3)可以简化为式(2).2.3MEME算法模型MEME是目前最流行的解决模体发现问题的算法,它使用期望最大化算法(EM)来更新参数,估计结合位点信息.EM算法可以保证目标函数收敛到一个局部最优解,但是对于初始状态的选择非常敏感.为了减轻此影响,MEME通常选择不同的起始位点作为初始状态来多次运行算法.作为一个基于概率模型的算法,MEME也将数据看作背景成分和模体成分的混合.通过定义一个二元随机变量Zij(j=1,…,Li),MEME计算每一个l-mer的似然值来寻找模体,Zij用于表示每个l-mer是背景成分或模体成分.当碱基sij表示为一个结合位点时,Zij=1;否则,Zij=0.这样,整个数据集的似然值可以表示为log(p(X,Z|θ0,Θ))=∑t这里,Xij表示第i行第j个l-mer.期望最大化算法正是通过更新潜在的隐变量Z使得似然值最大化,主要过程分为E步和M步E步:M步:重新估计参数ΘE步和M步重复执行直至收敛.Θ(T+1)=argmaxE[logp(X,ZΘ(T))](6)需要特别指出的是,针对模体发现的概率模型,MEME进行了一些变化.通过描述位点如何分布,MEME将概率模型细分为OOPS、ZOOPS、TCM3类.OOPS表示有且只有一个模体出现于每条序列中,这是模体发现问题最基本的假设.但是对大部分真实数据而言,这个假设并不合理,因为很多序列并没有包含位点信息,这就极大地削弱了识别算法的有效性.鉴于这种情况,MEME又提出了另一个模型ZOOPS,即每条序列中含有一个或没有模体出现.这两种模型看似对大部分实验数据都适用,但是仍没有考虑一条序列中出现多个模体的情况.TCM模型允许一条序列中有零或多个模体发生,比起上述2个模型,TCM更加灵活且有更好的适用性.但是,TCM也是对计算要求最为苛刻的模型.在计算时,必须要注意那些重叠的位点,否则,MEME将会收敛到一个自重叠(self-overlapping)的模体上.这是由于MEME假设每个l-mer是独立的,如果考虑l-mer的起始位置和结束位置,将会有2(l-1)个l-mer与其重叠.在本文中,我们会针对上述的3个模型在算法的参数设置上进行调整,具体参见4.1节.3定位投影求精算法根据上述的概率模型,我们将模体发现问题转化为:如何在数据集中寻找若干相似的碱基片段,并且,使得由这些碱基片段构成的位置频率矩阵的信息量最大化.基于这个思想,我们提出了一个通过定位投影求精的模体发现算法(Fixed-positionprojec-tionrefinementalgorithm),主要包含聚类(定位投影)、过滤、求精3个过程,各部分具体细节如下.3.1定位投影聚类过程聚类是为求精过程提供初始参数的过程.由于随机产生的初始状态包含有太多的噪声信息,所以如何选择一个好的初始状态,使得求精运算可以快速收敛到一个局部最优解就变得尤为重要.很显然,如果对数据集中所有的子序列进行组合来寻找相似的l-mer构成初始状态,开销过于庞大.因为这样的组合有(Li-l+1)t种,并且在实际问题中,序列的碱基数通常数量级为103或更高.以往,MEME随机选择l-mer构成初始状态,但是这样的初始状态不能保证算法收敛到唯一的全局最优解,只能以多次运行算法的方式来提高准确率,开销过大.为了避免上述缺点,本文设计了一种初始化模体参数的聚类方法———定位投影法(theFixedPointProjection),具体过程为(1)使用集合S中的所有l-mer组成新的集合X,X={xn|n=∑(Li-l+1)},xn表示一个l-mer,由字符a1,…,al(a∈Σ)组成.(2)计算集合X中每个位置的相对熵,这里fwk表示字符k在第w个位置出现的概率.(3)选取相对熵最大的位置q进行投影,q=argmaxw=1,…,l{Hw}.将集合X分为4个子集,第1个子集Page5X1包含在位置w上出现碱基“A”的所有l-mers;第2个子集X2包含在位置w上出现碱基“C”的所有l-mers;同样,X3和X4包含在位置w上出现碱基“G”和“T”的所有l-mers.(4)设定阈值max_size和min_size,并对4个子集{X1,X2,X3,X4}的大小分别进行检查.以X1为例,若|X1|<min_size,则子集X1直接抛弃;若|X1|>max_size,则将X1返回第(2)步,再次寻找投影位置并进行分解;若min_size|X1|max_size,则认为X1合格,存储入候选类集合{cm}中.阈值max_size和min_size的设定在4.1节中有详细说明.图2是定位投影过程的详细流程图.这样的聚类方法有如下几个优点:(1)聚类的目标是数据集中所有的子序列,可以保证每一个子序列都有机会出现在一个类中.(2)我们解决模体发现问题的目标是选取合适的犘犉犕使得目标IC最大化.选取相对熵值最大的位置作为投影位置,这个过程本身就是最大化IC工作的一部份.(3)由定位投影得到的图2定位投影聚类过程((a)将已知DNA序列集S转化为长度为7的子序列集合X,计算每个位置的相对熵,选取第5个位置进行投影.(b)由X分解得到的4个子集,在每个集合的第5个位置上,碱基依次为“A”、“C”、(c)分解得到的子集,选取位置再进行投影分解.(d)所有子集大小满足阈值要求,保存为{cm},即聚类结果)每一个类cm的大小在[min_size,max_size]之间,这样的类我们称为为候选类.如果这个类的规模过大,那么它包含子序列的差异性较大,必然包含很多不必要的噪声;如果这个类的规模较小,子序列无法表示一个有意义的模体,也就是转录因子无法结合足够多的序列,这样的类我们直接抛弃.虽然在某些情况下,在被抛弃的类里可能包含有某个模体实例,但是这样被抛弃的类还可以被其它含有模体实例的类所弥补.在最差的情况下,最终我们得到类的最大数量为n/min_size,n为所有子序列(l-mer)的数量.在实际中,我们最终得到类的数量会远小于这个数,比如子序列数量为105的集合中,最终得到类的数量可能只有几百个.最后,在真实的DNA数据中,经常会出现一些无意义的碱基片段,比如重复出现的“AAAAAAAAAA”或是“CGCGCGCGCG”.这些碱基片段同样会生成相同重复的l-mers,而这类l-mers的重复计算通常对MEME这种算法的影响非常大.而通过我们所设计的定位投影法,这些无意Page6义的l-mers会非常容易被找出并抛弃.下面的算法1为定位投影聚类过程的伪代码.算法1.FixedPositionProjection.输入:DatasetX输出:Candidatesets{cm}{cm}←queue←XWHILEqueueisnotemptyDORETURN{cm}3.2使用复杂度及信息量过滤子集在通过定位投影过程得到的候选类{cm}中,有相当一部分类包含的是背景信息.对这些包含背景信息的类进行求精开销很大且毫无意义.所以,如何有效鉴别一个类的好坏就变得尤为重要.这里,我们注意到一个类的位置频率矩阵并不能完全反映其质量,这是因为背景序列中有大量重复出现的l-mers,这些l-mers会导致犘犉犕有较高的位置保守性,但不一定会有较好的复杂度.所以我们也将引入复杂度作为评判一个类好坏的因素.本文中,我们使用的复杂度测度[30]为我们通过复杂度(8)和信息量(9)这2种质量评估标准对候选类{cm}中的各个子集进行过滤.其规则如下:J(m)=1(1)计算{cm}中每个类的复杂度,记为J(m).(2)计算{cm}中每个类的信息量,记为I(m).I(m)=1(3)对于{cm}中每一个候选子集,如果同时满足J(m)J(m)&&I(m)I(m),则认为是一个合格类,保存至Cluster={clusterM}.可以看到,我们设计过滤过程的目的是为了剔除那些具有低信息量或低复杂度的类,减少因背景序列中大量重复子序列所带来的不必要计算.这个过程极大地减少了需要求精类的个数,仅留下了适量的合格类从而使得求精过程得以更快地完成,极大地减少了运算量和算法运行时间,减少的运算量参见4.4节.同时,保留含有高信息量的类同样也与我们解决模体发现问题的目标(最大化IC)一致.3.3模体求精传统的期望最大化算法,因初始状态选择的不确定往往会导致收敛到不同的局部最优解.本文中使用的求精方法正是根据这个因素,确定若干个具有较高保守性的初始状态,使得每一个初始状态都能快速地收敛到对应的一个局部最优解.对于过滤后的合格类Cluster,我们采用与EM算法相似的方式来更新参数,即更新模体成分的概率分布Θ.通过更新Θ,得到收敛结束时对应的分布Θ(T),即可获得相应的模体.在收敛过程中,我们同样选择信息量IC作为目标函数,并规定当满足|IC(T+1)/IC(T)-1|<10-6时迭代中止,具体运算如下.Z(T)其中,ε为伪计数,一般取值1,用来规避某个碱基出现概率为0时所带来的不便.在上述的参数更新方式中,搜索空间为整个数据集中所有的l-mer,这就使得那些没有被聚类所包含的l-mer同样可以对目标函数做出贡献.注意到,每个求精过程中初始的参数Θ(0)和Z(0)是由一个合格类所提供,因为过滤得到的合格类在参数Θ的许多位置上有着较高的保守性,使得每当更新参数Z时(方程(10)),数据中绝大部分背景l-mer或与合格类相似度较低的l-mer所提供的概率值p(X|Zij,Θ(T))非常小,也就是对更新Z的共享很小,这样就使得迭代可以快速地收敛到局部最优解.对于求精后的合格类,比较其目标函数并进行排列,由最大目标函数IC对应的分布Θ即可得到相应模体.整个FPPR算法的伪代码如下.Page7算法2.MPPR算法.输入:DatasetS,motiflengthl输出:motifxmotifX←allthesubstringslengthlfromS{cm}←FixedPositionProjection(X)Cluster←Filter{cm}FOReachClusterMDO图3定位投影求精算法流程图3.4寻找多模体我们提出的定位投影求精算法可以拓展到解决多模体发现问题.在此类问题中,多个模体通常含有多样的一致序列表达,模体实例的数量也大为增加,而且由于模体的多样性,数据的信噪比也远低于单个模体.所以,解决多模体发现问题要远远难于解决单模体发现问题.一些传统的模体发现方法经常采用多次运行单模体发现算法来定位不同的模体,这些方法通常的手段是在发现一个模体后,将这个模体相应的实例和邻近重叠的子序列从原序列中移除[31],这样的目的是避免这些重叠的子序列对发现新模体产生干扰.但却有明显的缺点,即寻找后一个ICmax←max{ICM-max}GetthemotifxmotiffromthecorrespondingΘmaxofICmaxRETURNxmotif图3为定位投影求精算法的流程图,其中(a)为算法的整体流程,通过定位投影聚类、阈值过滤、模体求精3个部分对模体发现问题进行求解.定位投影聚类的具体流程如(b)所示,对于输入集合,我们选取大小合适作为候选集,过滤掉过小的子集,对过大的子集做进一步的分解.(c)为模体求精过程的流程图,通过更新参数迭代求精,得到每个合格子集相应的模体.模体要取决于前一次模体发现的精确度.如果前一次发现的是某个模体的伪实例,而真实的模体实例存在于那些被移除的重叠的子序列中,那么后面模体的查找只能更加不准确.在通过FPPR算法求解单个模体时,我们发现由于模体具有弱保守性,过滤后的一些合格类可能会产生相似的一致序列,并且一些合格类在求精后也可能得到相似的模体,可能预测共同的结合位点.所以在本文中,为了解决多模体发现问题,我们采用与传统方法不同的手段,即不移除任何子序列,也不重复使用单模体查找算法.由于过滤得到的合格类都具有一定的位置保守Page8性和复杂度,那么在寻找多模体时,我们首先对这些合格类都进行求精,输出多个模体.再根据这些模体对应的位置频率矩阵,计算它们之间的相似度.最终由信息量大小排列即可寻找多个模体.本文采用基于信息量的WIC[32]函数来度量模体之间的相似度.WIC由模体A和模体B定义:WIC(Aa,Bb)=IC(Aa)×IC(Bb这里,a表示模体A的第a个位置,b为模体B的第b个位置,c一般取值为2.5;IC(Aa)表示模体A第a个位置的信息量,其定义与式(7)相同;DIC表示信息量差异,定义见式(14).DIC(Aa,Bb)=∑k∈Σ进行多模体查找的具体流程为:假设寻找的模体数量为U,当一个新模体被找到时,我们先检查是否有相似的模体已被发现.如果有,比较其信息量大小,保留信息量高的.如果没有,用新模体代替原来U个模体中信息量最小的.这样的方法不仅确保了U个输出模体互不相同,而且这些模体都具有尽可能高的信息量.在下一节中,我们也使用FPPR对含有多模体的数据进行了测试.4实验分析4.1参数设置在进行数据测试前,我们首先设定算法中需要的参数.由输入序列可得到的数据有序列数t和序列长度Li(i=1,…,t).模体长度l通常我们假设其为已知先验,但是在一些数据中,模体长度并不知道,我们会尝试不同模体长度(6~25bps)并选取结果最好的.根据上述的信息,我们可以生成包含所有l-mer的集合X并开始定位投影.投影次数和候选类的个数都由阈值参数max_size和min_size决定.在设定max_size和min_size大小时,我们期望有模体存在的类中含有尽可能多的模体实例,并且受到背景干扰较小.这就使得我们在面对不同的模型时,有着更加灵活的参数设置.当模型为OOPS时,每条序列中有且只有一个模体实例,此时模体实例总数等于序列个数,我们取候选集上限为序列数max_size=t,下限min_size=3t/4(当t<5时,min_size=t/2);当模型为ZOOPS时,序列中含有一个或没有模体,模体实例总数小于序列个数,此时我们选取max_size=t,min_size=t/2;模型为TCM时,每条序列中可能含有多个也可能不含模体.根据经验,模体实例总数都会接近序列个数,我们取max_size=5t/4,min_size=t.由设定的阈值max_size和min_size,可以进行定位投影过程得到候选集,进而由候选集中的各个子集生成其相应的犘犉犕,并进行过滤和求精过程.在求精过程中,我们并没有限制迭代次数,设目标函数在|IC(T+1)/IC(T)-1|<10-6时即为收敛停止迭代.4.2数据统计信息我们使用6组真实的DNA数据来测试本文算法的性能.CREB、CRP、MEF2、MYOD、SRF和TBP.这些数据包含有不同物种的序列,CRP数据包含有与大肠杆菌中环腺苷受体蛋白质结合的转录因子结合位点[25,33-34].数据集CREM、MEF2、MYOD、SRP和TBP从ABS数据库[35]中选出.这些数据集所含的信息有很大程度的不同,模体长度由6bps变化至18bps,模体实例数由17变化至95,序列条数也有较大的变化,17~95.需要特别指出的是,在CREM和CPR中,某些序列中都含有2个模体,而在MYOD和SRF这2组数据中,一些序列包含有2个以上的模体.使用这些数据对算法进行测试,可以检验我们的算法在不同数据下性能是否稳定.而数据中所含的已经标出的位点信息,使得我们可以更好地进行性能分析及与不同算法进行比较.各组数据的统计信息如表1所示.数据tLlinstanceN_avgCREB172008191.12CRP1810518231.28MEF21720010171.00MYOD172006211.23SRF2020010361.80TBP952007951.00表1中,t为输入序列个数,L为序列长度,l表示模体长度,instance表示数据中模体实例个数,N_avg表示每条序列中平均的模体实例数.4.3算法性能比较我们把本文算法与MEME[12]、GAME[14]、MotifSampler[17]和GALF-P[15]算法进行对比.为了公平比较,测试每组数据时都使用相同的模体长度,并且尽可能较少地使用先验信息(已经标注出的位点信息等).因为MEME和MotifSampler对起始位点的选择比较敏感,我们选择多组不同的起始Page9位点来运行算法.而GAME和GALF-P是基于遗传算法设计的,它们的结果通常受到随机种子的影响较大,这里我们分别运行GAME和GALF-P算法20次取其平均值.在每一次运行中,GAME和GALF-P的模体集搜索数量分别为3×107和3×106,在这样较大的采样空间中进行搜索,GAME和GALF-P的期望结果接近最优.在评估预测的位点是否准确时,研究者们一般使用2种方法[36-37]:基于核苷酸水平和基于位点水平.基于核苷酸水平是计算预测的实例中有多少核苷酸和真实实例中的核苷酸相重叠.而基于位点水平,判断一个实例准确与否是看它是否与真实的实例有至少多于1个核苷酸位置的重叠.本文中,我们采用了一种混合上述2种方式的评估方法[14],即预测的位点和真实的位点如果相对位移在3个核苷酸(碱基)内,我们都认为这样的实例正确.为了评估算法性能,我们引入了Precision,Recall和F-score[38]3种测度,简称P、R、F,其具体定义如下,其中|·|表示集合的势.可以发现,我们希望得到一个较高的Precision,但是可能会被假阳性的模体所干扰(找到的模体并不一定是真实的模体).而Recall是反映预测表26组DNA数据上的结果比较数据CREB0.930.680.780.680.790.730.710.630.670.700.840.760.740.900.81CRP0.890.670.760.790.780.780.940.700.800.940.700.800.830.790.81MEF20.930.820.880.880.880.880.720.760.740.840.940.890.840.940.89MYOD0.600.280.380.480.480.480.460.290.350.470.860.610.780.680.82SRF0.740.890.810.700.920.800.760.860.810.680.880.760.950.970.96TBP0.830.690.760.780.770.770.740.670.700.740.870.800.820.810.82Average0.820.560.730.720.770.740.720.650.680.730.870.770.830.850.85实现的,这样的运行时间比较看似并不公平.但是通4.4运行时间及计算复杂度分析表3为上述5个算法的运行时间,这里我们在过这些运行时间至少可以说明,本文的算法在Win-相同的实验设备下进行:2.67GHz的CPU和2GBdows系统下使用Matlab实现的时间是在合理的可内存.其中,本文算法是由Matlab实现,在Windows接受范围之内.通过表3我们可以看到,MEME和系统下运行;GAME是由java实现,在Windows系MotifSampler运行时间虽短,但是因为初始位点的选取,它们通常要运行多次.而基于遗传算法的统下运行;GALF-P是通过Windows系统下的C实GAME和GALF-P,GAME明显略慢于本文算法,现;而MEME和MotifSampler是在Linux系统下的C实现.虽然这些算法是在不同的系统和平台下GALP-F和我们算法的运行时间各有高低.特别指的实例中真阳性的概率.由于假阳性的干扰,这2个测度可能会向完全不同的方向变化,所以我们引入第3个测度F-score作为权衡.如定义式(16)所示,一个高F-score值意味测试结果在Precision和Recall两方面均有很好的表现.表2为MEME、GAME、MotifSampler、GALF-P和本文算法FPPR的比较.加粗部分为每组数据最好的结果.我们可以看到,在Precision方面,FPPR在MYOD和SRP数据上有较好的表现(0.78,0.95),MEME在CREB,MEF2,TBP3组数据中都有较高的Precision值(0.93,0.93,0.83),CRP数据在算法MotifSampler和GALF-P上结果均为最好(0.94).在Recall方面,本文算法在CREB、CRP、MEF2、SRF4组数据中性能较好(0.90,0.79,0.94,0.97),其中在MEF2上,GALF-P和本文算法的结果相同(0.94),而对于数据MYOD和TBP,GALF-P的结果为最优(0.86,0.87).通过Precision和Recall性能上的比较,可以看到我们的算法受到假阳性的干扰较小,在预测的实例中,真阳性占据了结果的较大比重.所以在F-score方面,本文算法仅在MEF2这组数据和GALF-P有相同的值(0.89),其余5组数据的结果都是这5个算法中效果最好的.而在整体的平均性能上,我们的算法在Precision和F-score两方面性能最高(0.83,0.85),仅在Recall上比GALF-P低0.02.通过表2,我们不难发现,本文算法在各项数据的测试中都有较好的结果并且性能优于大部分目前较为流行的模体发现算法,而且在多种数据类型的测试中性能都较为稳定.Page10数据CREB1.52134.0015.9643.5017.52CRP0.60391.0414.2797.228.91MEF22.01113.2515.0835.06101.91MYOD2.2596.0813.6128.6330.27SRF2.12223.5626.9248.9298.28TBP39.05786.3285.5380.4910.83出的是,在处理TBP这组序列数为95的较大的数据时,相比于其它算法,我们的算法在运算效率上有大幅度的提升.这里我们具体对FPPR在各个过程的运算量进行分析.表4是我们的算法在处理各数据时,各个阶段在上述的6组数据之外,我们还使用了Tompa表4子序列总数及FPPR在聚类、过滤、求精各过程的运算量统计数据l-mer总数阈值候选子集数量合格子集数量平均迭代次数合格子集l-mer总数l-mer减少量/%CREB3294[15,19]664CRP1584[16,24]315MEF23247[9,17]176MYOD3315[17,23]556SRF3820[20,30]73TBP18430[80,95]322除此之外,我们还对FPPR算法的计算复杂度进行了分析.因为定位投影聚类过程和模体求精过程分别受到投影次数、合格子集数量以及迭代次数的影响,这里,我们对各部分的计算复杂度分别进行分析.首先,对于定位投影聚类过程,假设投影次数为h.在每一次投影时,算法需要的计算每个位置的熵值,复杂度O(nl),这里n=∑(Li-l+1)表示l-mer的总个数,l为模体长度.所以整个定位投影聚类过程的计算复杂度为O(hnl),注意到h和l的数量级一般仅为10,n的数量级通常不大于105,那么定位投影聚类过程的计算复杂度为107.而对于模体求精,我们假设共有M个合格子集需要求精,每个求精过程的平均迭代次数为T.在每一次迭代中要进行E步和M步各一次,E步为计算每一个l-mer在序列中的贡献度,计算复杂度为O(nl);M步是重新估计模体各个位置的参数值,计算复杂度同样也为O(nl).则整个模体求精过程的计算总复杂度就为O(MTnl).通过上述的实验我们可以看到,合格子集和平均迭代的数量级一般均为10,那么模体求精过程的计算总复杂度也就不大于108.而定位投影聚类过程和模体求精过程相比,过滤过程的计算复杂度这里可以忽略不计.上述的计算复杂度分析体现了我们算法在计算效率上的提高,也与我们在实验中所得到的运行时间相一致.4.5其它数据测试的数据量,其中包括:l-mer的总数、定位投影过程所取的阈值、定位投影过程后候选子集的数量、过滤过程结束后合格子集的数量、合格子集求精时的平均迭代数、合格子集中l-mer的总数以及相对于整个数据集l-mer减少量.通过表4可以看到,我们设计的定位投影和过滤过程不但使得需要进行求精的子集数量大为减少,而且在较短的迭代次数中达到了收敛(通常在20次迭代内).同时,l-mer数量也得到了大规模的缩减,占总量的90%以上.特别是对于TBP这类规模较大的数据,最终得到的合格子集仅为2个,平均迭代4次就可达收敛,其l-mer减少量高达99%.数据[37]测试算法性能.Tompa数据是一组标准的数据集用以评价新设计出的模体识别方法,包含real、generic、Markov3种类型的数据,我们选择其中的real类型数据进行测试.Real数据包含52组从TRANSFAC数据库提取含有结合位点的真实启动子序列,涉及Drosophilamelanogaster(Dm)、Mouse(Mus)、Human(Hm)和Saccharomycescerevisiae(Yst)4个物种.需要指出的是,Tompa数据中,一些数据只含有一条序列,如dm02r、dm06r;而在另一类数据中,并不是每条序列中都含有模体,如dm01r、hm06r、hm11r、mus07r和yst01r等;但是对于Tompa的绝大部分数据,每条序列中都含有不止一个模体,如hm08r、hm10r、mus11r、yst03r和yst05r等.所以在Tompa数据中,模体的保守性都很差,非常难于寻找.这里,我们选取了其中的部分数据进行测试,具体为:Dm物种中选取dm01r、dm02r、dm03r、dm04r、dm05r和dm06r;Mus物种选取mus01r、mus03r、mus05r、mus06r、mus11r和mus12r;Hm物种选取hm01r、hm07r、hm08r、hm10r、hm17r、hm22r、hm23r和hm24r;Yst物种选取yst01r、yst02r、yst03r、yst04r、yst05r、yst06r、yst08r和yst09r.在Tompa数据集中,由于一些序列模体个数较多,并且序列之间模体的长度也不相同.所以在评估算法性能时,我们使用基于核苷酸水平的测度.这里,nTP(truepositive)表示预测到的真实模体位点;nTN(truenegative)表示没有预测Page11到真实存在背景成份中的碱基;nFP(falsepositive)表示错误预测到的模体碱基;nFN(falsenegative)表示没有预测到的真实模体碱基.方程(18)为基于核苷酸水平的性能指数.为了更好地展示本文算法的性能,在测试Tompa数据时,我们选取MEME算法作为参照.MEME是现今较为成熟和广泛使用的工具,比起其它算法,能快速地输出指定长度范围内的多个模体.为了公平,我们对两种算法选用相同的参数.在测试每组数据时,也选择不同的模体长度作为先验,范围是6~25,选取输出最好的一组作为结果.图4为FPPR和MEME算法对Tompa数据的具体测试结果.从图4中我们可以看到,对于Dm物种,dm02r和dm06r都只含有一条序列,而FPPR和MEME对于这种只含有一条序列的数据都无法测出结果.而dm03r、dm04r和dm05r,这几个数据都是一些序列中不含有任何模体,另一些序列含有图4FPPR和MEME算法在Tompa数据集上的测试比较通过Topma数据实验我们可以看到,现有算法在Tompa数据上性能结果很差[37].但不同的算法之间可以相互补充,比如mus06r、yst05r和hm10r这几组数据,FPPR可有效地进行预测,而MEME算法的准确率就较差.现有的研究中,这样合并不同的算法结果可以有效地提升准确率,相关算法如Ensemble[36].其性能表现不仅体现在不同算法之间多个模体.如dm05r的第3条序列,就含有9个模体.这样的模体分布使得定位模体变得异常困难,所以FPPR和MEME在Dm物种上效果都很差对于Hm物种,一个显著的特点就是数据中所含模体长度变化极大.以hm01r为例,不同序列中模体长度由7~56变化不等.我们使用固定的模体长度作为先验,也只能是预测某些位点和真实模体的一小部片段重合.而像hm17r这样模体长度变化较小的(10~17bps)数据,FPPR和MEME的结果都为这一类物种中最好的,且FPPR的准确率高于MEME.在Hm物种的整体性能上,FPPR的准确率略高于MEME.在Mu物种和Yst物种的测试数据中,大部分数据的序列数都较少(小于10条序列),仅是mus11r、yst03r、yst08r和yst09r这4组数据序列数大于10.并且在这2个物种中,大部分数据序列中都含有较多的模体,并且每条序列中的模体长度均不一致.经过实验我们可以看到,对于这2个物种,FPPR和MEME的准确率各有高低.的结果可以相互补充,而且,由不同的算法得到的一致结果同样也可以增强给定的预测.同时,我们还使用本文算法对几个被广泛使用的生物基因数据进行测试,这些基因数据包含有dihydrofolatereductase(DHFR)[39]、preproinsulin[39]、c-fos[39]、YeastECB[40]和LexA[41].数据DHFR、preproinsulin和c-fos为包含有真核生物上游区域Page12的基因序列,YeastECB是酵母早期细胞周期序列.其中,DHFR和preproinsulin的序列中包含有2个不同的转录因子结合位点,DHPR中的模体长度分别为13和11,preproinsulin中模体长度为15和13.如表5所示,使用FPPR预测的模体为阴影加粗部分.和真实参照模体相比,DHFR数据中长度为13的模体有一个位置的偏差,长度11的模体完全重表5FPPR在真实数据上的运行结果图5FPPR测试5组真实数据的模体的logo图合;Preproinsulin数据长度15和13的模体都完全重合;YeastECB数据有2个位置的偏差;c-fos和LexA的结果均偏差一个碱基位.图5为上述5组数据在使用FPPR测试后得到的模体logo图.通过这些实验我们可以看到,FPPR算法不仅可以准确找寻不同物种不同基因上的模体,对于同一数据中所包含的多个模体,我们的算法还可以进行有效的预测.预测的模体5结论模体发现是一个著名的挑战问题,因为相对于序列长度,模体通常较短,这样的弱保守性使得其较难从背景中区分出来.本文提出了一种定位投影求精算法,通过对数据集中所有的子序列进行投影聚类,将数据集分解成若干子集,对其中的合格子集求精从而识别模体.我们的算法避免了传统算法(如期望最大化算法或吉布斯采样)因初始状态选择的不同而陷于不同局部最优解的缺陷,使用信息量作为目标函数来选择最优的子集得到相对应的模体.同时,为了更接近真实情况,我们将背景模型拓展到了高阶马尔可夫模型而不只是简单的独立分布模型.并且通过对聚类大小阈值的控制,将模体模型拓展到OOPS、ZOOPS和TCM这3类模型上,这就使得我们算法更为符合实际中模体出现的规律.在实验方面,通过真实数据上的测试比较,我们看到FPPR可以在合理的时间内准确的识别出各类物种中的模体.与算法MEME、GAME、MotifSampler和GALP-F相比,FPPR在Precision和Recall上有一个较好的平衡,因此得到了更好的性能值F-score.此外,通过相似函数WIC对合格子集的结果进行细化,FPPR也可以有效地解决多模体识别问题.与大部分模体识别方法相同,本文的算法的设计也是假设DNA所有区域都以相同的方式连接转录因子,转录因子只依赖于序列本身,并没有考虑核染色质结构以及后生成信息,并且对于较为复杂的组织结构,由少量序列寻找的模体并没有足够Page13的保守性,往往受到序列随机相似性的干扰.这类统计方法通常只考虑模体的统计意义和富集部分,而不是对整个基因区间得到可行的结果.同时,转录因子结合位点只限于启动子区域,转录过程由基因的末端元素增强子或沉默子控制.所以,使用ChIP-seq技术,对全基因组进行转录因子位点识别,以及在面对大规模海量数据时,采用更高效的手段,如并行技术等,来设计算法也是我们未来工作的研究重点.
