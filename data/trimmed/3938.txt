Page1COStream:一种面向数据流的编程语言和编译器实现张维维1)魏海涛1)于俊清1),2)李鹤1)黎昊1)杨秋吉1)1)(华中科技大学计算机科学与技术学院武汉430074)2)(华中科技大学网络与计算中心武汉430074)摘要数据流编程模型作为高效的并行编程模型被广泛应用于媒体处理和网络服务等应用中.然而,多/众核结构的底层计算、存储和通信的复杂性对数据流程序的性能提出了新的挑战,数据流程序在不同的多/众核结构上的可移植性和可编程性也为编译器提出了更高的要求.针对数据流程序所面临的问题,提出并设计实现一种数据流编程模型———COStream数据流编程语言及其编译系统,提高了数据流程序的可编程性.COStream在C语言文法的基础上加入表征数据流图的文法结构,文法结构清晰,具有良好的可重用性和可扩展性.COStream编译系统利用同步数据流图作为中间表示,根据目标系统的结构特点对数据流程序进行并行优化并构造流水线调度,进而生成高效的可并行执行的目标代码.在X86多核架构下实现了COStream编译系统,并对该领域的多个实验程序进行了测试,测试结果表明,COStream具有良好的可扩展性和高加速比.关键词多核处理器;数据流;编译;COStream1引言随着半导体技术的发展,多/众核平台作为新的计算平台,为各类应用提供了强大的并行计算能力,但它也将如何充分挖掘程序的并行性以及如何充分利用资源等问题暴露给了编程人员.C、C++和Fortran等传统的编程模型,主要对应的是单指令流和传统集中式内存管理模式,无法很好地适合这种新型的并行平台结构.当前比较流行的编程模型,如OpenMP和MPI,虽然显式地提供了访问底层资源的接口,但要求编程人员必须熟悉平台系统底层结构,设计并行程序时需要根据系统底层结构进行精心的任务划分、数据通信以及同步设计,导致了程序性能受制于编程人员并行算法的设计和对并行系统的理解,极大地增加了编程人员,尤其是各个应用领域编程人员的编程负担.为此,数据流编程模型作为新的高效的并行编程模型被提出来.目前,支持流应用的计算平台主要有片内多处理机Raw[1]、片上众核处理器Godson-T[2]、SIMD流处理器Merrimac[3]和CELL[4]等.主要的支持流编程的流语言有Streamit[5]、Brook[6]、Cg[7]和DFBrook[8].这些流编程语言一般是针对特定平台系统开发的,尽管它们能够充分利用特定平台的底层硬件资源,但是用这些流语言编写的程序在可移植、可扩展性以及跨平台使用上存在一定的局限性,如Brook是在Merrimac上开发的,而StreamIt是针对Raw开发的.为此,针对多/众核平台上并行编程困难、资源利用率低等问题,结合大规模数据计算等计算密集型应用,以实际应用程序为驱动,开展面向多/众核平台的编程语言、编程模型及相关编译支持技术的研究,具有重要的理论研究和实际应用价值.本文基于多核与分布式系统结构的特点以及数据流编程模型,设计并实现了COStream数据流编程语言及其编译系统.COStream数据流编程语言是对C语言做数据流扩展,语言文法是在C语言的基础上结合数据流编程模型而设计的,它能够屏蔽目标底层系统的细节,提高了编程人员编程效率,同时针对不同的多/众核平台系统均具有良好的可移植性.另外,COStream编译系统能够针对并行系统的底层特点做编译优化,提高数据流程序在特定平台上的执行效率.COStream编译系统主要有3个组成部分:前端语言编译模块、针对不同底层架构的编译优化模块和目标代码生成模块.本文的主要贡献有以下3点:(1)设计并实现了数据流编程语言COStream及相应的编译器框架;(2)针对共享存储架构和数据流程序的特点提出基于共享存储的多核架构的编译优化框架;(3)在X86架构上实现了该编译器框架和后端优化框架,通过实验验证了框架的有效性.本文第2节介绍COStream数据流编程语言;第3节讨论COStream编译器的设计架构;第4节介绍针对X86共享存储的多核架构的编译优化框架;第5节介绍在X86架构下的实验方法和结果;第6节介绍相关工作;第7节对全文进行总结.2COStream数据流编程语言2.1数据流编程模型数据流编程语言(DataFlowProgrammingLanguage)[1]是一种面向领域的编程语言(DomainSpecificLanguage,DSL)[9],以数据为中心,通过将应用领域中功能独立和数据驱动等特性与程序语言设计相结合,采用数据驱动的执行方式,将计算和通信分离,暴露程序本身固有的结构特点,简化编程,被广泛用于数字媒体处理和网络服务等应用领域.使用数据流编程模型时,编程人员无需对底层系统有很详细的了解,只需要按照领域应用问题本身的数据流程特点进行编程,简化了领域编程.数据流模型分成动态数据流模型和静态数据流模型.数据流编程模型SWARM[10]和DARTS[11]采用Codelet[10]动态数据流模型,对于大规模并行系统它在运行时实现细粒度并行,在运行时确定数据依赖和任务调度.但在信号处理领域,静态数据流特别是同步数据流模型(SynchronousDataFlow,SDF)[12]则是比较理想的选择.编程语言是底层程序执行模型的体现.COStream采用SDF作为语言的执行模型.在SDF中,程序由一个SDF图表示,SDF图中每个结点代表一个计算任务,称为actor,边代表了生产者actor与消费者actor之间的数据流动,每条边上具有两个权值,分别代表生产者每次执行生产数据的个数(称为产生率)和消费者每次执行消耗数据的个数(称为消耗率).在SDF图中actor有独立地址空间,actor间的数据流动是通过FirstInFirstOut(FIFO)队列来实现.actor采用数据驱动的方式执行,只要actor的输入边有足够的数据,actor将不停地重复执行并产生数据到输出Page3边.在SDF模型中,actor有两种类型即有状态的actor和无状态的actor.一个有状态的actor执行时需要根据上次执行的状态来决定之后的执行状态,而一个无状态的actor当前的执行与上一次执行状态无关.SDF模型将通信与计算分离,为编译器的并行优化提供了机遇.图1的SDF图中有2个actor,actorP和actorC,都是独立的计算单元,actorP每次执行向缓存中产生2个数据,即生产率为2,actorC每次执行从缓存中消耗4个数据,消耗率为4.两个actor都采用数据驱动的方式执行,只要数据足够,自动开始执行.2.2COStream数据流语言的设计COStream编程语言是一种面向并行体系结构的高性能数据流编程语言,语言的名称由3个关键字:Composite、Operator和Stream组合而来.COStream程序采用有向图来描述应用的处理过程,图中节点表示计算,边表示数据依赖,边的方向表示数据流动方向.COStream数据流编程语言是对C语言做数据流扩展,语言文法是在C语言文法基础上加入表征数据流图结构的文法,实现对数据流图最基本的抽象,方便数据流程序的编写.它主要包括如下几个特点:(1)复合数据流类型的定义.COStream支持类似于C语言中struct类型的数据流类型定义,来实现复杂的数据操作.(2)actor之间采用参数传递方式实现连接,增强actor的复用.COStream采用类似于C语言参数传递方式实现actor之间依赖关系的建立.(3)采用窗口机制实现对数据流的访问.窗口的长度定义了actor每次执行生产或消耗数据的码率.另外,在actor内部支持对窗口内数据的随机访问.(4)支持层次性数据流图的构造.层次性流图是对SDF图中子图的抽象,COStream设计层次性流图文法用来支持层次性流图的构造,方便编程.图2给出了一个用COStream编写的一个程序实例,程序的功能为求移动平均值,该程序由3个operator组成即Source、Avg和Sink.图3给出了该程序对应的SDF图.2.2.1Stream数据流(stream)作为通信载体连接数据流图中各个计算单元,是对数据流图中通信边的抽象,是由一系列数据流成员(token)组成的序列,它为SDF中的actor提供可并行处理的对象.数据流成员的声明类似于C语言的结构体,是一种复合数据类型,可以包括任意基本C内置数据类型、字符串类型和基本内置类型的数组等,存储器对数据流成员的组织对编程人员是透明的.数据流分为输入数据流和输出数据流两种类型.在SDF图中输入数据流对应actor的输入边,对actor是只读的;输出数据流对应actor的输出边,对actor是可读写的.一般Page4来说,一个stream是一个actor的输入数据流同时又是另一个actor的输出数据流.2.2.2OperatorSDF图中最基本的组成单元和计算单元是actor,在COStream中由operator文法结构表示.Operator在SDF中被抽象成一个actor,专门用来处理stream中的数据,operator定义了actor输入边、输出边和具体的处理过程.Operator由头部定义和体定义组成,其中operator头部定义了该operator处理的输入、输出流以及operator名称,COStream暂时不支持匿名operator的定义.COStream中一个operator可以有多个输入流和多个输出流.Operator体包括该operator内需要用到的变量声明和定义、init、work和window这4个部分.其中,work是operator的核心结构,是数据流程序周期性迭代的执行单元.Operator对输入流和输出流中的数据访问操作也是在work中进行的.Operator内部变量的声明或者定义主要是为了说明该operator的work在执行时是需要的一些静态变量,类似于C语言中static关键字修饰的变量,对于无状态的operator来说,这部分可以为空.Init定义了operator开始执行时需要进行的初始化工作.COStream采用窗口机制确定对流中数据的访问方式,operator中的window结构规定对输入流和输出流中数据访问的窗口类型和窗口大小.下面详细讨论COStream中的窗口机制.COStream对流中的数据访问采用窗口机制,窗口用前沿和后沿界定,前沿和后沿的距离就是当前operator执行时可操作的输入、输出缓冲区的大小,它由window中的参数确定.COStream中窗口类型有两种:一种是sliding类型,代表滑动窗口类型,该类型的窗口支持peek,pop和push这3种操作方式,一般用于输入流;另一种是tumbling类型,代表翻转窗口类型,该类型窗口只支持push和pop两种操作方式,既可以用于输入流也可以用于输出流.pop操作删除最先到达流中的token,并返回该token;peek(i)操作返回流中距离流窗口前沿的第i个token;push操作是将计算得到的token放到流,对缓冲区的使用是从前沿到后沿的.Operator一次执行完成后同时移动窗口的前沿和后沿.图4(a)图描述COStream中的输入输出流的窗口示意图,图4(b)和(c)分别表示如果(a)对应的窗口分别是sliding(5,3)和tumbling(5)时,一次operator执行完成后窗口的移动情况.为了便于操作输入输出流中的数据COStream,对输入输出窗口操作是通过下标操作符[]来实现的.图3中3个actor:Source、Avg和Sink分别对应图2中的3个operator.以图2的operatorSource为例,Source内声明了一个整型变量x,在work函数第一次执行时先调用init函数初始化x为0.Source在做周期性迭代时work会对x的值加1,将新的x值push到输出流S中以供Avg消耗.Window中的语句Stumbling(1)定义了Source的输出窗口类型为翻转窗口类型,生产率为1,即每次迭代向输出流中push一个数据.综上,Source作为源actor执行周期性迭代产生自然数序列,在迭代过程中并将其结果添加到输出流中供SDF图中其它actor的消耗.2.2.3CompositeOperator定义了数据流图中的计算节点,为了将不同节点连接构造数据流图,COStream定义了composite结构,相对于operatorcomposite属于高层次的复合结构,代表一个由单个或若干个operator组成的可重用的数据流图结构,它是对SDF图中可复用的子图的抽象.一个composite既可以作为一个完整的数据流程序形成一个完整SDF图,也可以作为子程序被其它的composite调用,作为一个完整SDF图的一部分.composite由composite头部和composite体组成.composite头部表明该composite的输入输出边参数、composite参数以及composite的名称,COStream不支持匿名composite.Composite的输入输出边参数是用来确定在生成SDF图时该Page5composite结构所形成的子图与SDF图中其它节点的连接关系.Composite可以同时有多个输入多个输出边.Composite参数主要是指composite结构在实际被调用时需要从调用处传入的参数,可以根据参数的情况决定composite最终子图的结构,该参数可以在composite内部被使用.composite体主要由如下两部分组成:一部分是composite内部需要使用的变量的定义和一些相关的操作语句,这一部分可以看作与普通的C语言语句类似;另一部分是composite内部能够对流中的数据进行处理的表征子数据流图结构的语句块,它是由一个或若干oper-ator根据数据流依赖关系连接而成,是composite的核心.Composite结构在编译阶段被扩展,经过编译数据流程序的数据流图子结构将被扩展成完整的数据流图,程序中的多个composite也将转变为一个用于形成最终的SDF图.在图2示例中程序是由2个composite组成,程序入口为名为Main的composite,Main中调用了MovAvgcomposite,在编译时MovAvg将根据输入输出边的关系被实例化,最终形成一个完整的SDF图,如图3所示.2.2.4Operator的其它连接形上一小节提出了可复用的composite,它允许编程人员自定义operator的连接.COStream为了使编程人员更高效地构建数据流图,在composite内部引入支持流水线和并行结构化的层次性编程结构,图6splitjoin和pipeline应用举例即pipeline和splitjoin结构[5].图5描述了这两种基本的层次性数据流结构.pipeline结构将不同的operator顺序直线连接;splitjion结构对输入流进行分批并行处理,提高了数据流处理的任务并行性.下面详细介绍这两种结构的特点.图5COStream支持的operator的其它连接形式COStream引入add操作将operator和composite调用添加到pipeline和splitjoin中.图6中的例子能够说明splitjoin和pipeline的层次性特点和使用特性.在图中左边部分是COStream的源码片段,右边是对应的数据流图.在本例中可以看到添加了层次性的结构有助于增加数据流程序编程的灵活性和可扩展性.另外,在splitjoin和pipeline中流能够被参数化,在本例compositeVocodeBank中关于内置的pipeline调用次数可以由参数N来确定,通过N控制splitjoin结构的宽度,同样在pipeline中可以通过参数来控制pipeline的深度.Page62.2.5内置Composite和外部程序接口为了便于对文件操作,COStream对文件的I/O提供了内置composite支持,通过调用内置的文件I/OcompositeCOStream可以完成对文件读写操作.FileReader和FileWriter是COStream为I/O提供的内置的composite接口.FileReader用于将文件中的数据读到流中,FileWriter是将流中的数据写到文件中.具体用法如下:stream〈doublex〉A,B;//1A=FileReader(“data.bin”);//2FileWriter(B)(“result.txt”);//3行2表示将data.bin文件中的数据读入到数据流A中,行3表示将处理后输出的流B中的数据保存至文件result.txt.另外,COStream还提供了程序的外部接口,使COStream程序可以嵌入到C++程序中,通过这种方式可以使得在C++程序中满足数据流程序特性的对程序性能有关键影响的模块通过COStream实现,以便使程序在执行时能够充分利用处理器资(1)编译器前端.编译器前端是对COStream源程序进行词法分析、语法分析和语义动作分析建立图7COStream数据流编译系统框架图源,而编程人员又可以不需要关心底层硬件结构的细节.在3.2节中将会对调用COStream外部接口的C++程序的编译过程做详细的介绍.本节针对COStream的执行模型和语言结构进行了详细的讨论.语言设计综合考虑了与高级语言的语法相似性和数据流编程模型的特性,利于编程人员进行编程.3面向多/众核架构的COStream编译框架3.1COStream编译器总体框架图7描述了COStream编译系统的总体框架图.COStream编译器的源语言为COStream数据流语言,目标语言根据目标系统不同生成不同底层语言,如C、C++和openCL[13]等,编译器通过调用底层语言编译器生成对应目标平台的可执行文件.下面详细介绍COStream编译系统的组成部分.抽象语法树.通过编译器前端COStream源程序将被转换成一棵由顶层语法树节点表示的层次性抽象Page7语法树结构.COStream编译系统采用Lex和Yacc[14]生成词语法分析器.(2)语义分析和代码优化.编译器对经过词语法分析形成的抽象语法树进行语义分析并对抽象语法树作机器无关优化,得到最佳抽象语法树.(3)中间代码生成.COStream以SDF图作为中间表示,该阶段根据COStream中的composite调用关系和stream依赖关系,对经过优化后的抽象语法树进行分析,将语法树进行深层次的展开,得到一个只有operator通过stream相连的完整的数据流图的抽象语法树结构,利用此时的抽象语法树生成SDF图,该SDF图是编译器后续操作的基础.另外,该阶段还需要对SDF图中的各个节点的工作量进行估计,确定SDF图中各个actor的负载情况.(4)数据流图的周期性调度.编译器对SDF图表示的数据流图结构采用单出现调度策略(SingleAppearanceSchedule,SAS)[15]得到静态平衡数据流图.编译器根据程序中各个actor的peek、pop和push率决定在初态和稳态下各个actor的执行次数,为后续的优化和代码生成提供依据.(5)底层结构相关优化.编译器根据不同底层系统结构特性,对COStream程序进行与底层结构相关的优化,主要从计算任务分配、存储优化和通信优化等方面对程序进行优化,在开发并行性的同时减小相应的开销,使数据流程序在执行时能够充分利用底层系统的资源,提高程序的执行效率.COStream主要针对X86、Codson-T、GPU和多核集群等目标系统做编译优化.在第4节中具体介绍面向X86共享多核架构下的相关优化.(6)代码生成.根据底层结构相关优化的结果、目标系统的体系结构以及目标代码的特性,设计最终目标代码的生成框架,生成能够在目标系统上高效的可并行执行的代码.(7)运行时系统.运行时系统主要包括数据流程序在特定平台上执行时通信模型的设计和为了支持代码生成所需的相关库函数的设计,关于通信模型和库函数一般采用特定平台上的目标语言来实现.(8)底层编译系统.编译器将生成的针对特定平台的目标代码交由平台上的底层语言对应的编译器进行编译,生成对应的可执行文件,以X86后端为例,经过COStream编译系统的目标代码模块生成的是C++代码,再经过gcc编译最终生成能够在多核下可并行执行的文件.3.2编译器外部接口COStream编译器支持两种程序编译模式:独立模式和嵌入模式.以目标语言C++为例,在独立模式中,COStream程序被翻译成C++,最后编译成独立可执行的文件,无需其它干涉;在嵌入模式中,COStream程序通过COStream的外部接口被C++程序调用,成为C++的一个调用库,和外部C++一起编译连接.在编译时只需设置相应的编译选项,编译器就能够对代码以不同的方式编译,其中-embed表示嵌入式调用,而-normal表示独立执行程序.图8描述了COStream在两种模式下的编译过程.4面向X86多核架构的编译优化框架本节将基于X86共享存储多核架构提出一种COStream数据流编译优化框架.该框架目标是针对数据流程序根据共享存储多核架构的结构特点构造高吞吐量低延迟的软件流水线调度.4.1软件流水线调度4.1.1任务划分任务划分的目的是根据SDF图中actor的负载和actor间的依赖关系构造高吞吐量低延迟的软件流水线调度,以最大化底层系统资源利用率.数据流程序要想充分利用系统资源就必须充分合理地利用其自身的数据并行性、任务并行性和流水线并行性[22].在软件流水线调度中,流水线的启动间隔(InitiationInterval,II)是指相邻两次循环迭代进入流水线的时间间隔,II越小意味着吞吐率越大.任务Page8划分的目的就是要最小化II.在软件流水中II是由流水线中各资源的处理时间决定,在X86中,资源主要是处理器核,那么影响程序最终执行性能的主要因素就是划分的负载均衡情况.任务划分是要确定SDF图中的各个actor被分配到哪个处理核上.COStream任务划分采取以负载均衡为目标同时最小化同步通信开销的分配策略.负载均衡的目的是为了保证流水线在满状态时各个核上的有效计算时间是相等的,核间因相互等待而产生的空闲时间将会小,II就会小,处理核利用率就高,系统的吞吐量就大.同时,因为SDF中actor之间有数据依赖,为了保证数据访问的局部性最小化同步通信延迟,在任务划分时应该尽可能地将有依赖关系的actor分配在一个核上以最大程度地减少核间通信边的数量.文献[16]比较了常见的任务划分和分配策略,常见的分配策略主要包括有循环分发分配策略、亲和性分配策略和贪心分配策略等.综合COStream程序运行时存在的问题及常图9复制分裂算法流程图4.1.2阶段赋值经过任务划分后,数据流程序的各个actor已经被分配到处理核上,阶段赋值的目的是确定各个actor被分配到流水线的哪个执行阶段.由于各个actor之间存在依赖关系,因而除了在空间维度上对actor进行分配,还需要在时间维度上指定各个actor的相对计算顺序以满足actor间数据依赖关系.通见任务分配策略,COStream选择以负载均衡为目标同时最小化通信开销的K路图划分算法(MultilevelK-wayPartitioning,MKP)[17].COStream采用Metis[18]提供的接口实现MKP算法为SDF图作任务分配.由于MKP作为通用的图划分算法,没有充分结合数据流程序自身存在的各种并行性其结果并不能很好地满足程序运行的要求,COStream在MKP划分结果的基础上根据数据流程序的特点进行了进一步优化,提出复制分裂算法,图9描述了复制分裂算法的基本流程.复制分裂算法根据MKP划分结果的负载平衡情况,利用了SDF图中无状态的actor存在的数据并行性,对无状态的actor做分裂,增大任务并行性,将分裂产生的不同副本分配到不同的划分子集中,降低actor粒度,使不同划分的负载达到平衡.经过实验分析看到,COStream在X86环境下平衡因子设为1.5时能够得到较理想的结果,其中平衡因子指的是划分中负载最大的与最小的比值.过任务划分的结果和actor间的数据依赖性为每个actor分配执行阶段调度构造软件流水线调度.对于SDF图G=(V,E),V代表SDF图中的所有结点的集合,E代表SDF图中的所有边的集合.为了保证SDF图中actor间数据流依赖关系,规定:对于SDF图中任意v∈V,u∈V,存在有向边(v,u)∈E,该边的终点u的阶段值不小于始点v的阶段值.Page9算法1.阶段赋值算法.输入:SDF图G(V,E),图G计算单元到核的映射输出:图G计算单元到阶段号的映射mapActor2Stage1.topologyOrderOfActors=topologyTravSDF();2.FORallactoruINtopologyOrderOfActorsDO3.intmaxStageValue=0;intstageValue;4.FORallactorvwhichisaparentofuDO5.IF(mapActor2Partition[v]!=6.stageValue=mapActor2Stage[v]+1;7.ELSE8.stageValue=mapActor2Stage[v];9.ENDIF10.IF(stageValue>maxStageValue)THEN11.maxStageValue=stageValue;12.ENDIF13.ENDFOR14.mapActor2Stage[u]=maxStageValue;15.ENDFOR算法1描述了阶段赋值的过程.首先,对数据流图G(V,E)进行拓扑排序;其次,按照数据依赖关系依次访问所有的actor,对u∈V,令maxStage为0,遍历u的每个输入边(v,u)∈E,如果v和u在不同处理核上,则u的阶段号stageu=stagev+1;否则u的阶段号stageu=stagev.如果stageu>maxStage,图10任务划分、阶段赋值和软件流水调度事例4.2基于软件流水线调度的代码生成框架基于X86架构COStream编译器使用C/C++作为目标代码.数据流程序在执行时根据任务划分则更新maxStage.在遍历完u的每条边后,以maxStage作为u的阶段号.图10给出了任务划分、阶段赋值和软件流水调度执行的一个例子.初始SDF图有A、B和C这3个actor,在任务划分阶段将B复制分裂成两个计算单元B1和B2,同时引入了split和join两个计算节点.经过任务划分后,计算单元A被分配到处理器核core0,split和B1被分配到core1,B2、join和C被分配到core3上.图10(a)给出了经过阶段赋值后各个计算单元的阶段值,完成了软件流水的构造.图10(b)给出了对应的软件流水调度执行过程,程序启动时流水线处于填充阶段,各个核上的actor按照其阶段值从小到大的顺序启动执行,当所有的actor都启动时,流水线进入满阶段;在流水线满阶段,所有的actor都进行周期性的迭代执行,由于任务划分阶段基本实现了不同计算核上的负载均衡,此时核间同步开销小,资源利用率高,系统的吞吐率达到最大;在流水线调度的排空阶段,程序开始相继结束actor的执行,各个核的actor按照阶段值从小到大的顺序结束其周期性的迭代,等到所有的actor结束其稳态调度后,整个程序终止并释放运行时占有的各种资源.情况为每个计算核分配一个线程,一个线程对应SDF图中的若干个actor,线程中的actor在相应软件流水的执行阶段被调度到处理器.COStream的Page10目标代码主要包括如下几个部分:(1)operator对应的类定义文件.数据流图的每个计算单元对应一个actor类的定义,类的成员函数包含一个用于初始化该actor访问的缓冲区的构造函数、一个初态调度函数以及一个稳态调度函数.类中的work函数和init函数分别对应该operator中的work和init,初态调度函数和稳态调度函数是根据actor周期性调度的结果确定的.(2)定义actor间的通信边的代码.该文件主要对SDF图中的通信边进行管理.数据流图中的有向边表示数据流程序数据的流动方向,边上端结点生产数据,下端结点消耗数据.COStream基于数据流图的这种特点采用生产消费者模型对缓冲区进行管理.在X86中,生产者和消费者使用共享缓存作为通信方式.在目标代码中,定义供生产者和消费者共同访问的有界循环缓存区buffer,生产者将数据写入缓冲区尾部,消费者从缓冲区头部访问数据,COStream中缓冲区采用循环队列来实现.voidthread_x_fun(){实例化actor的对象;charpipelineStage[MAXSTAGE]={0};stage[0]=1;//初态调度for(intstageIter=0;stageIter<MAXSTAGE;stageIter++){if(N-1==stageIter){//调用阶段号为N-1的计算单元的初态调度函数}…if(0==stageIter){}}//稳态调度for(intstageIter=0;stageIter<maxIter+MAXSTAGE-1;if(pipelineStage[N-1]){}…if(pipelineStage[0]){}//移动stage,实现流水线填充与排空for(intstageIter=MAXSTAGE-1;stageIter>=1;//判断是否进入流水线排空阶段if(stageIter==maxIter-1)barrierSync();//同步操作}}(3)流水线循环和同步控制的代码文件.该部分主要是指根据软件流水线调度结果生成的整个程序的控制代码和各个计算核上线程的控制代码.COStream根据X86的特点通过任务划分结果决定一个线程内的actor,再通过软件流水线调度确定actor间的执行顺序,COStream在流水线的不同阶段引入同步机制,保证不在同一个线程内且有数据依赖的actor间能够正常的运行.图11给出了一个线程内构造软件流水的过程.5实验结果与分析本文采用的实验平台是X86-64架构的服务器,机器配有2颗2.50GHzIntelXeonE5420CPU和最大支持内存48GB.实验环境是内核版本为2.6.18的Linux操作系统,gcc版本为4.1.2.为了对COStream编译系统面向X86架构的编译优化进行全面的性能评估和分析,选取了11个多媒体领域常见的算法作为测试程序,用COStream数据流编程语言实现,作为COStream编译器的输入.测试程序中有计算密集型应用,也有数据和计算都密集的应用.各个测试程序的功能、规模和结构描述如图12所示,在图12中SDF图节点数目反映了该程序在任务划分和调度方面的复杂性.测试程序名简要描述BeamFormer滤波器程序2171057ChannelVocoder频道话路DCT离散余弦DESDES加密FFT傅里叶Filterbank多速率信号FMRadio调频收音机MPEGdecoder视频解码Sperpent蛇加密程序44111460Tde透明数据Vecoder比特率减图13给出了测试程序经过COStream编译后在目标环境上执行的加速比.从图中可以看出,每个Page11程序执行加速比随着核数目的增多而增大,基本呈现一个线性增长趋势.测试程序在2个核下加速能够达到1.9x,加速效果非常理想.在8个核的情况下,有1个程序加速比超过了7x,有6个程序加速比达到6x,在8核时平均加速比能够达到5.9x,加速效果比较理想.通过对测试程序分析发现,如果测试程序任务划分结果展现了很好的连通性,使得各个处理器核在软件流水调度过程中有很好的数据访问局部性,加速比就相对较好.COStream用MKP对SDF图进行初始化分,根据划分的负载均衡情况对划分结果采用复制分裂算法,增加SDF图的任务并行性并调整划分的负载,但通过这种方式影响划分结果的连通性,故对分裂后的SDF图再用MKP划分算法进行划分,最终得到较好的划分结果,实验结果也证明了该算法的有效性.另外,从图13的结果可以看出对于FMRadio和Vecoder加速效果不太理想,当处理器核数目达到4时,增加处理器核数目不能对程序的性能产生明显的改进,这主要是由测试程序自身的特性决定的.通过分析发现影响加速比主要有下面3个因素:(1)负载均衡.在共享存储的多核系统中负载均衡对于数据流程序的执行效率有非常重要的影响,如果计算核上的任务负载不均衡,那么不考虑同步、通信等其它因素,数据流程序的加速效果也不可能达到理想的要求.(2)局部性(locality).任务调度后子图的连通性越差,划分间通信边数目就越多,程序运行时处理器核间就需要频繁地进行数据通信,影响数据的局部性,增加了数据访问延迟,在软件流水时同步开销将会很大,对加速比的影响也会很大.COStream采用的任务分配策略就是在负载均衡的前提下尽量保证局部性.(3)数据流程序自身的特性,即SDF图中通信边的数目和actor的负载.对于FilterBank测试程序7.4x的加速比的主要原因就是SDF图中各个actor的负载几乎是一样的并且通信边的数目相对比较少,这样SDF图经过COStream划分能够得到具有良好负载均衡和局部性的划分结果,从而得高的加速比;但对于FMRadio而言,尽管SDF图对应31个节点但各个节点的计算量普遍较小,划分完成后各个核上的计算时间小于核间的同步时间,程序的计算同步比太低,只有4.4x的加速比,加速效果没有达到理想要求.通信与同步比衡量了测试程序的有用计算和时间开销之间的比例,在一定程度上反应了程序的性能.在X86环境下采用的是软件流水调度策略,各个并行线程在软件流水调度的每次执行阶段中需要进行一次同步操作,COStream采用sense-reversingbarrier[19]做核间的同步,保证不同核上的actor间的数据依赖关系能够满足.各个处理器核的运行时间有计算时间和同步时间两部分组成.图14给出了各个测试程序在8个核上的运行时计算同步时间分布.从图14可以看出,FMRadio和Vocoder的计算同步比不太理想,同步开销太大,导致加速比较低;但对于FilterBank同步比例只占5%,程序执行时具有良好的局部性和负载均衡,从而能够达到高的加速比.对比图13可以发现测试程序的计算同步比能够达到较高水平的,程序的加速效果也相对较为理想.图14测试程序在8核上运行的计算同步比6相关工作数据流编程模型是针对数据流应用的大规模密集型计算的特点以及多核处理器体系结构特点而设计的一种编程模型[16].Dennis等人[20-21]将数据流作为一种编程方法引入程序设计领域,设计了数据流编程语言.Lee和Messerschmitt[12]扩展了数据流模型,提出了粗粒度同步数据流模型.MIT的Thies等人[5]基于JAVA采用同步数据流模型针对RAWPage12设计了StreamIt数据流编程语言,StreamIt计算节点Filter只支持单输入单输出流,程序构造存在不直观不易编写等问题,影响编程人员的编程效率.另外,StreamIt中流的类型只能是单一的基本类型,对于复合类型支持不够,对于处理复杂的结构化数据在处理上存在一定的局限性.数据流程序的在多核架构上的并行编译优化也被广泛的研究.Gordon等人[22]针对Raw采用分裂融合的方法对StreamIt存在的数据、任务和流水线并行性进行研究;Udupa等人[23]采用线性规划方法利用StreamIt中存在的各个可并行性,实现了StreamIt在GPU上的调度.Liao等人[24]采用了仿射变换(Affinepartitioning)方法将Brook映射到多核处理器上.Brook编程模型是Stanford大学超级流计算机项目Merrimac设计的,编译优化主要集中在数据级的并行上,缺乏对粗粒度并行的支持.Wei等人[2,8]用DFBrook基于层次性存储多核结构,对数据流程序如何在资源受限的环境下构造最佳软件流水线进行研究,但该方法不适合大规模的分布式多核集群环境,且DFBrook对大数据量的大规模计算应用编写支持不理想.针对上述问题,本文基于多/众核架构提出一种跨平台使用的数据流编程模型COStream.COStream的编译系统利用SDF图作为中间表示,根据并行系统的底层特点进行建模,针对不同的底层并行系统进行不同的并行编译优化.另外,本文也提出了一种基于X86共享存储多核架构下开发数据流程序多种并行性特别是任务并行性、数据并行性以及流水线并行性的编译优化方法.7总结本文提出并实现了一种数据流编程模型———COstream数据流编程语言及其相应的编译系统.COStream是在C语言文法的基础上加入了与数据流相关的文法结构:composite、operator和stream,支持数据级并行、任务级并行和流水线并行.COStream编译器编译过程包括编译器前端、底层结构相关的编译优化和目标代码生成.为了验证当前编译系统的有效性,在COStream编译系统总体框架的基础上实现了针对X86多核架构编译优化方法.实验结果表明了方法的有效性.本文提出的优化方法主要是针对共享处理器架构,如何设计在分布式环境下的层次性优化方法和面向片上多/众核处理器架构的编译优化方法以及针对共享处理器架构中的层次性存储做优化是将来需要进一步研究的工作.
