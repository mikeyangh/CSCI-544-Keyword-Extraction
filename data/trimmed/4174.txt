Page1基于多类特征的Android应用恶意行为检测系统杨欢1)张玉清1),2)胡予濮1)刘奇旭2)1)(西安电子科技大学综合业务网理论及关键技术国家重点实验室西安710071)2)(中国科学院大学国家计算机网络入侵防范中心北京100190)摘要目前针对未知的Android恶意应用可以采用数据挖掘算法进行检测,但使用单一数据挖掘算法无法充分发挥Android应用的多类行为特征在恶意代码检测上所起的不同作用.文中首次提出了一种综合考虑Android多类行为特征的三层混合系综算法THEA(TripleHybridEnsembleAlgorithm)用于检测Android未知恶意应用.首先,采用动静态结合的方法提取可以反映Android应用恶意行为的组件、函数调用以及系统调用类特征;然后,针对上述3类特征设计了三层混合系综算法THEA,该算法通过构建适合3类特征的最优分类器来综合评判Android应用的恶意行为;最后,基于THEA实现了Android应用恶意行为检测工具Androdect,并对现实中的1126个恶意应用和2000个非恶意应用进行检测.实验结果表明,Androdect能够利用Android应用的多类行为特征有效检测Android未知恶意应用.并且与其它相关工作对比,Androdect在检测准确率和执行效率上表现更优.关键词系综算法;Android应用;多类特征;恶意代码检测;行为分析;数据挖掘;智能手机;网络行为1引言近年来,智能手机普及率迅速增加,智能手机应用功能激增.全球最具权威的IT研究与顾问咨询公司Gartner的数据显示①,预期到2016年年底,将有23亿部电脑、平板电脑以及智能手机使用Android系统,而微软Windows设备的数量为22.8亿.Android近年来的快速发展使其成为了一个占主导地位的智能手机平台,拥有整个市场约三分之二的份额.由于Android系统的开放性,它也成为了众多恶意代码开发者的活跃地盘.Android用户可以从GooglePlay②和第三方Android市场(例如:Amazon、hiapk、gfan等)下载应用程序.应用程序开发者可以上传自己的应用程序到第三方Android市场.GooglePlay(前名为AndroidMarket),是一个由Google为Android设备开发的在线应用程序商店,可以让用户浏览、下载及购买GooglePlay上的第三方应用程序③.GooglePlay提供了Google’sBouncer检测恶意程序,但是实时性不够,恶意程序在被检测出来之前已经被用户大量下载[1].根据独立安全机构Av-test在2013年1月使用ESET、Lookout:Antivirus&Security、Kaspersky、Qihoo360等22个手机杀毒软件对869个已知Android恶意应用的检测报告显示④,各大手机杀毒软件的平均查杀率为94%.而对于未知恶意应用的检测,各大厂商没有公开杀毒软件的技术细节,本文无法做详细分析.由于恶意代码的数量和种类越来越多,加上代码混淆、加密等技术的兴起,使得恶意代码检测变得越来越困难.目前,典型的恶意代码检测技术包括基于签名、行为的检测方法.传统的基于签名的检测技术被普遍使用,但是它必须拥有一类恶意应用的签名库后才能检测该类恶意应用,因此无法有效检测未知的恶意应用.基于行为的恶意代码检测目前主要采用动态和静态两种方法.动态方法是在系统运行过程中收集应用程序的一些行为信息.优点是绕过了静态方法遇到的代码混淆和加密等方面的问题,缺点是动态测试代码覆盖率低,并且有些恶意程序可以防止自身在模拟器下运行,当在模拟器下运行时会自动崩溃;静态方法主要研究使用反汇编反编译技术或者在smali中间代码上进行控制流和数据流分析技术来进行恶意代码检测.优点是代码覆盖率高,缺点是要解决静态方法无法检测的代码混淆、加密以及在动态执行中才解码恶意代码的问题.由于数据挖掘技术可以从大量数据中挖掘出有意义的信息[2-4],有些研究者利用该技术挖掘出恶意应用的行为特征,以此来检测未知恶意应用.但是,目前的研究方法存在3方面的局限性:(1)不同的数据挖掘算法针对同一类特征的检测效果不同,无法预知哪个算法效果最优;(2)同一种算法对不同类型的特征检测效果不一定都是最优;(3)使用单一的算法不能充分发挥每类特征在Android恶意应用检测时所起的不同作用.本文针对以上方法的局限性,首次提出一种基于三层混合系综算法的多类特征Android应用恶意行为检测系统,自动检测Android平台的恶意应用程序.该系统采用动静态结合的行为特征提取方法,提取Android应用的多类行为特征,再采用三层混合系综算法建立检测模型,并对大量现实中的应用程序进行检测.具体方法介绍如下:首先,本文创建恶意应用库和非恶意应用库.恶意应用库的创建参考文献[5]中所使用的部分恶意应用.非恶意应用库的创建是通过修改Akdeniz⑤的爬虫程序从GooglePlay上批量下载应用程序,并使用多种已有检测软件、杀毒软件和人工进行检测,确保数据库的准确性.其次,在特征提取阶段,本文采用动静态结合的分析技术.静态分析主要对AndroidManifest.xml文件进行自动化分析.一是提取packet名称和activity名称为动态分析提供参数;二是对permission、activity、service、receiver和provider组件进行特征提取;三是对使用native代码的应用程序中的lib库文件进行分析,提取应用程序的函数调用序列.动态分析主要采用沙盒技术,自动完成启动模拟器、安装应用程序、模拟用户行为和提取系统调用序列等工作.而后,在特征描述阶段,对提取的多类特征进行①②③④⑤Page3格式化处理,构建各类特征的集合.一是静态获取的各个组件使用个数的统计数据;二是静态获取的应用程序lib文件所使用的重要函数调用的统计数据;三是动态获取的各个系统调用使用次数的统计数据.最后,使用三层混合系综算法建立检测模型.第一层使用多个基础分类器对3种不同类型特征进行训练,给出适合不同类型特征的最优算法;第二层将系综算法与最优分类算法结合再次进行训练建立模型,进一步提高检测准确率;第三层对待检测的应用程序使用建立的模型进行分类并使用判决算法给出检测结果.本方法通过实验对1126个恶意应用和2000个非恶意应用进行了检测.实验结果表明,本文提出的方法在有效性、准确性和执行效率上表现良好,准确率为94.24%,优于其它Android恶意应用检测系统.本文的主要创新点与贡献如下:(1)采用动静态结合的行为特征提取方法,动态方法弥补了静态方法不能检测运行中释放的恶意代码的缺点,也绕过了静态方法遇到的代码加密和混淆问题;静态方法为动态方法提供了运行参数,可以分析动态方法无法处理的应用程序.(2)本文设计的检测系统提取了应用程序的多类行为特征,充分反映了应用程序行为,并且该系统具有可扩展性,可以加入更多类型特征进行检测.(3)首次提出了一种三层混合系综算法THEA(TripleHybridEnsembleAlgorithm),对各类特征分别选取最优的基础分类算法从而给出综合判决结果.并首次将其应用到Android应用的恶意代码检测,实验证明了该算法的有效性.(4)将提出的原型系统实现了自动化的检测工具Androdect,对大量现实中的恶意应用和非恶意应用进行检测.本文第2节介绍相关工作;第3节总体介绍检测系统;第4节阐述系统的关键技术和算法;第5节给出实验设计与结果分析;第6节讨论本文提出系统的局限性和下一步工作;最后在第7节对本文进行总结.2相关工作随着智能手机的广泛应用,发布手机应用程序的官方市场和第三方市场上都出现了含有恶意代码的应用程序,使得智能手机应用程序的恶意代码检测成为了研究热点.由于Android系统占有大量的市场份额以及其平台的开放性,手机平台恶意代码检测研究更多地集中在Android系统平台.目前,国内外典型的Android平台恶意代码检测技术主要有基于签名和基于行为的检测方法.首先出现的是基于签名的方法.文献[6]重点介绍了基于特征码的恶意代码检测方法.国外著名的Android恶意代码检测工具Androguard①也是基于签名的方法,它的主要缺点是无法检测未知恶意应用.随后,由于基于签名的方法无法检测未知恶意应用,研究者开始研究基于行为的恶意代码检测方法.文献[7]使用动态方法监视手机应用程序的网络行为、短信和隐私等信息.Blsing等人[8]使用动态方法分析Android应用的系统调用、网络访问、文件和内存等方面的信息.Enck等人[9]提出了使用动态污染分析变量层、方法层、消息层和文件层的信息,用于检测隐私泄露方面的漏洞.路程[7]、国外研究者Shabtai等人[10]以及Padriya等人[11]研究了Android源代码的静态分析技术.近年来,也有研究者将数据挖掘技术应用到手机平台恶意代码检测.2009年,Schmidt等人[12]使用静态方法获取函数调用特征,对Symbian系统和Android系统[13]进行基于分类算法的恶意代码检测,由于研究时间比较早,还没有大量真实的恶意样本用来验证结果.2011年,Iker等人[14]使用动态方法提取系统调用特征,应用K-means聚类算法区分基于同一应用程序改写的恶意代码和非恶意代码,该方法只限于检测同一应用程序的不同变种是否包含恶意代码.2012年,Shabtai等人[15]使用动态人工方法提取API特征并使用分类算法对自己编写的Android恶意代码进行检测,但没有使用现实中的大量应用程序进行验证.上述工作从基于签名的检测方法过渡到基于行为的检测方法,从检测已知恶意应用过渡到检测未知恶意应用,在基于数据挖掘算法的研究中大部分是基于处理单一类型特征的数据挖掘算法,然而,实际中需要考虑恶意应用的多类行为特征,目前还没有一种数据挖掘算法可以充分发挥不同类型特征在Android恶意代码检测中所起的不同作用.①Androguard[EB/OL].http://code.google.com/p/an-Page43Androdect检测系统本文提出了一种基于三层混合系综算法的多类特征Android恶意行为检测系统,并实现了工具Androdect,可以自动化地检测未知恶意应用.该系统采用动静态结合的分析技术提取Android应用的多类行为特征,并设计了三层混合系综算法THEA建立检测模型.Androdect检测系统框图如图1所示,该系统由6个部分组成:Apps数据库、预处理模块、特征提取模块、特征集合、格式化处理模块和三层混合系综算法检测模块,具体介绍如下:(1)Apps数据库.本文创建了恶意应用程序库和非恶意应用程序库.恶意应用程序库使用文献[5]中提供的部分恶意应用.而对于非恶意应用库,由于GooglePlay将应用程序下载并直接安装在手机上,这对实验造成不便,因此,本文使用Java语言改写了Akdeniz的爬虫程序,增加了异常处理、去重、迭代等功能,可以实现从GooglePlay上批量不间断下载应用程序到PC端.(2)预处理模块.文献[16]指出GooglePlay上52208个应用程序中只有2个为恶意应用,所以可图1Androdect检测系统框图4关键技术与算法4.1特征提取技术本文结合了动静态行为分析技术,提取Android应用的3种不同类型特征,下面分别作详细介绍.4.1.1静态分析技术系统中的静态分析模块采用的是静态分析技术,使用AndroidSDK(SoftwareDevelopmentKit,软件开发工具包)中自带的AAPT(AndroidAsset以认为GooglePlay上的应用程序基本为非恶意应用.但是,为了使结果更加精确,本文对从GooglePlay上批量下载的应用程序使用其它检测工具、杀毒软件和人工进行检测,确保非恶意应用程序库中的应用程序均为非恶意应用,不包含可疑的恶意应用.(3)特征提取模块.本文结合动静态行为分析技术.其中,静态分析主要对应用程序进行自动化分析,提取各个组件特征和函数调用序列;动态分析采用沙盒技术,自动提取各个应用程序的系统调用序列特征.(4)特征集合.在特征描述阶段,构建3种不同类型特征的集合.①静态获取各个组件使用个数的统计数据;②静态获取应用程序lib文件中所使用的重要函数调用的统计数据;③动态获取各个系统调用使用次数的统计数据.(5)格式化处理模块.本文使用Python语言编写代码对提取的特征集合进行格式化处理,统一处理为CSV(CommaSeparatedValues)格式,即逗号分隔值格式.每一行为一个应用程序测试样本.(6)三层混合系综算法检测模块.使用三层混合系综算法对数据进行处理,创建最优的检测模型,对待检测应用程序进行检测.PackagingTool,Android资产打包工具)对每个Android应用(即APK)进行解压缩,提取Android-Manifest.xml文件和lib库文件(.so文件).每个应用程序都包含一个AndroidManifest.xml文件,位于根目录下,它定义了应用程序的内容和行为.静态分析模块主要完成以下3个工作,如图2所示.(1)对Android应用进行自动化分析,提取其中的packagename和launchableactivity为动态分析提供参数.(2)对AndroidManifest.xml文件进行自动化分析,提取各个组件使用个数情况,包括permission、Page5activity、service、receiver和provider①.Permission描述了该应用程序请求的权限,为了保护设备上的资源和功能.Activity通常表示应用程序的一个用户界面.Service类似于Windows平台的服务,它是可能长时间运行的后台进程.Receiver使得应用程序可以接收系统或者其它应用程序的Intent消息.内容provider定义了一种标准机制来共享数据,允许应用程序使用其它应用程序的数据.例如:随机挑选几个APK进行静态分析,结果如表1所示,cn.cntv.apk应用程序声明了10个permission、20个activity和2个service组件,但是没有使用receiver和provider组件.cn.cntv.apkbubei.tingshu.apk14个59个4个1个0个com.meitu.kankan.apk16个32个1个0个0个(3)使用AndroidNDK(NativeDevelopmentKit,原生软件开发工具包)中的arm-linux-androideabi-readelf.exe提取native代码编译链接后生成的ELF文件的函数调用序列.可执行链接格式ELF(ExecutableandLinkingFormat)目标文件有3种类型:可重定位文件、可执行文件和共享目标文件.共享目标文件即lib文件夹下的.so文件,它是Androidnative代码所涉及的文件,用于和其它共享目标文件或者可重定位文件一起生成ELF目标文件或者和执行文件一起创建进程映像.本文对每个应用程序的多个.so文件进行合并后使用readelf工具提取“.dynsym”section中保存的动态符号表“SymbolTable”.并且所抽取的信息选取“FUNC”类型,不能选取“OBJECT”等其它类型,因为函数调用必须是从外部调用、共享库或者系统调用的函数.对数据库中的应用程序进行统计,如表2所示,可以得出恶意应用中含native代码的应用程序占47%,非恶意应用中含native代码的应用程序占33%.恶意应用程序库1126非恶意应用程序库20004.1.2动态分析技术主要采用沙盒技术,流程图如图3所示.系统中动态分析模块使用动态分析技术,本文①TheAndroidManifest.xmlFile[EB/OL].http://devel-Page6数安装应用程序.参数开启应用程序.户行为.调用序列.步骤1.创建模拟器快照并从快照启动.步骤2.使用静态分析获得的packagename参步骤3.使用静态分析获得的launchableactivity步骤4.使用SDK自带的工具monkey模拟用步骤5.使用SDK自带的工具strace提取系统步骤6.关闭并卸载应用程序.以前研究者也做过此类工作,但都没有给出具体实现方案和在现实环境下的测试结果.本文根据实际工作提出此过程中的一些具体问题和相应的解决方案,具体介绍如下:(1)模拟器快照.为了加快系统运行速度,在创建模拟器后创建模拟器快照,每运行整百个应用程序后重新启动一次模拟器,以免重复安装卸载应用程序造成垃圾文件过多影响运行速度,也避免每处理一个应用程序重启模拟器一次影响运行速度.(2)是否使用activity组件.判断应用程序是否使用activity组件,因为没有activity组件无法使用monkey工具提取系统调用特征.因此,本文构建的系统会自动提取出没有使用activity组件的应用程序,而后使用静态分析技术来弥补该缺点.(3)模拟器下无法运行.开启应用程序后要判断其是否崩溃,部分开发者为了防止应用程序在模拟器中运行,会使应用程序开启后自动崩溃.本文提出的系统在运行过程中会输出这些应用程序,后面在真机上依次进行同样的系统调用特征提取.(4)多进程.有些应用程序含有多个进程,一个进程为正常行为,另一个进程为恶意行为,由于无法预先判断某应用程序中哪个进程为恶意行为,哪个进程为正常行为.因此,本系统不把此类应用程序作为训练样本,通过对每个进程分别提取系统调用特征可以检测此类应用程序,只要含有恶意行为特征就判定为恶意应用.4.2三层混合系综算法恶意代码检测所选取的特征和算法.表3列出了之前研究者使用分类聚类算法进行表3相关工作中选取特征及使用的算法对比检测工具选取特征DroidMat[17]权限、Intent、APIK-means/EM、kNN/NBAndromaly[15]APINB、BN、DTJ48、Histogram、Crowdroid[14]系统调用文献[12]中工具函数调用CentroidMachine、NB、SVM文献[13]中工具函数调用PART、Prism、kNN会不会有一种算法总表现为最优呢?意代码检测上所起的不同作用呢?DroidMat[17]提取权限、Intent、API特征,使用聚类算法进行聚类而后使用分类算法检测恶意应用,对比了两种聚类算法K-means和ExpectationMaximization(EM)以及两种分类算法k-NearestNeighbor(kNN)和NaveBayes(NB)的检测结果.Andromaly[15]提取了API特征,对比了6种数据挖掘算法NB、BayesianNetworks(BN)、DecisionTree(DT)J48、Histogram、K-means和Logistic的检测结果.Crowdroid[14]针对系统调用特征进行提取,使用K-means聚类算法进行检测.文献[12]针对函数调用特征进行提取,对比了CentroidMachine、NB、SupportVectorMachine(SVM)3种分类算法的检测结果.文献[13]针对函数调用特征进行提取,对比了PART、Prism、kNN3种分类算法的检测结果.效果不同,那么,哪一种算法最优呢?由上面的分析结果可以提出以下3个问题:(1)针对同一类型特征选用不同的算法,检测(2)针对不同类型的特征,使用同一算法检测,(3)如何充分发挥不同类型Android特征在恶以上相关研究的检测结果说明使用传统分类聚类算法无法预先知道哪个算法对该特征检测效果最优;也没有一种固定的算法对不同类型的特征表现效果总是最优;并且单一算法不能充分发挥不同类型Android特征在恶意代码检测上所起的不同作用.因此,针对以上提出的问题,本文设计了一种针对多类特征基于多种基础分类器的三层混合系综算法THEA(TripleHybridEnsembleAlgorithm).4.2.1相关概念定义1.分类器系综[18].分类器系综是一种从根本上提升分类精度的方法,是将k个学习得到的模型系列M1,M2,…,Mk组合起来,创建一个改进的复合模型M.传统的系综方法有装袋(Bagging)和提升(Adaboost).装袋是对每个模型给出等权重预测;提升是初始时赋予每个元组同样的权重,每得到分类器Mi之后,更新权重,使得后面的分类器Mi+1更关注Mi误分类的训练元组.定义2.k折交叉确认(k-foldcross-valida-tion)[18].k折交叉确认就是将初始数据随机划分为k个互不相交的子集,也叫“折”D1,D2,…,Dk,每个折的大小大致相等.训练和检验进行k次.在第i次Page7迭代,划分Di用作检验集,其余的划分一起用来训练模型.4.2.2THEA图4为本文设计的三层混合系综算法THEA框图.具体思想为,因为无法预先知道哪个算法对特定类型特征表现效果最优,为了不盲目地随机选择一个算法进行检测,本算法在第1层设计采用多个基础分类器分别进行检测,选出最优分类器.并且针图4三层混合系综算法THEA下面对算法1的流程做详细介绍:第1层对3个不同类型特征库Di(i=1,2,3)使用多个基础分类算法Mm(m=1,2,3,4)依次采用k折交叉确认方法进行训练,此处m选取4,k选取10.在一种特征集合中,每一个基础分类算法Mm(m=1,2,3,4)进行10折交叉确认,生成的分类器可以用矩阵描述为每列取k次检测的平均值作为最后的分类器.对3个不同的特征集合Di(i=1,2,3)依次迭代Mm(m=1,2,3,4)基础分类算法,生成的分类器可以用矩阵描述为在每一列中选取最优的分类器,共选取i个分类器.对不同类型的特征选择效果最优的分类器,不是盲目地使用一种分类器对所有类型特征进行检测.在第2层为了使检测效果更优,本算法使用了系综算法分别对选取的3个最优分类器的分类效果进行提升.最后,在第3层对一个应用程序的3种不同类型特征进行一个综合评判,使用计算加权平均值的判决算法给出检测结果.最后,相当于针对每种类型特征集合输出一个最优分类器Ci(i=1,2,3).本文选取的基础分类算法为NB、kNN、PART、J48[2],由于系统具有可扩展性,还可以加入更多基础分类算法.关键是基础分类算法要选取差异大的,这样有利于分类器的效果.第2层使用RotationForest算法提升第1层输出的3个最优分类器的分类效果.RotationForest算法[19]是利用特征提取来构造基分类器差异性的集成学习方法,该算法的基分类器只能选定一种算法,但是经过变换产生多个基分类器,它们不仅精度高而且差异大,该算法的设计者也证实其特性比传统的Bagging、Adaboost系综算法分类效果更优.因此,本文选用RotationForest算法在第2层输出3个改进的最优分类器.第3层对待检测应用程序提取3种类型的特征,使用第2层输出的3个最优分类器进行分类,最后使用Voting函数求加权平均值给出判决结果.本文选取0代表非恶意应用,1代表恶意应用,每个分Page8类器给出的结果Result为0到1之间某个值(例如0.8,表示将该应用程序判定为恶意应用的概率为80%,判定为非恶意应用程序的概率为20%),该值体现了该类特征判定结果的权重,越接近1则表示根据该类特征将待检测的未知应用程序判定为恶意应用的权重就越大.然后将每种特征的结果求加权平均值得出最后判断结果.Voting函数公式定义如下:加权平均值=x×Result1+y×Result2+z×Result3x,y,z∈(0,1);0Result1,Result2,Result31,其中,x,y,z表示该应用程序是否含有该类特征,1代表有,0代表无;Result表示根据各类特征的判定结果.算法1.THEA.输入:Di:3种类型训练样本的集合,i=1,2,3Dij:每种训练样本集合被等分为k个元组,j=1,2,…,kk:轮数(每轮产生一个分类器)Mm:基础分类算法,m=1,2,3,4C:生成的分类器Cal:计算w=Accuracy的值RF:RotationForest算法输出:CTHEA三层混合系综分类器,Result过程1.生成THEA分类器并给出分类结果//第1层分类算法FOReachDiinDDOFOReachMminMDOSetwi=Max(w1,w2,w3,w4)OutputCiwithwiOutputC1,C2,C3//第2层分类算法FOReachDiinDDODivideDitokpartsFORj=1tokDOOutputRF(Ci)iwithMeanvalueOutputRF(C1)1,RF(C2)2,RF(C3)3//第3层分类算法ReadnewtestDnFOReachRF(Ci)iinRF(C)DOTest(Dn,RF(Ci)i)OutputResultiVoting(Resulti,Result2,Result3)Output(CTHEA,Result)5实验设计与结果分析本文通过实验来评估Androdect系统的有效性,与之前的相关工作进行对比,并重点与国外著名的Android恶意代码检测工具Androguard使用相同的测试集进行对比分析.5.1实验环境本文使用Java和Python语言实现了自动化检测工具Androdect.其中,动静态行为特征提取部分主要由Python语言实现,APK捕获和三层混合系综算法实现主要由Java语言实现.使用Androdect对现实中1126个恶意程序和2000个非恶意程序进行检测.所有实验在内存为4GB,处理器为Intel(R)Core(TM)2Quad2.67GHz的机器上完成.Androguard测试实验在1GB内存的VirtualBox虚拟机上完成.为了对比,Androdect的测试实验同样在1GB内存的虚拟机上完成.5.2实验结果分类器性能的评估参数[18].在介绍本实验结果之前,先介绍几个用来衡量定义3.混淆矩阵(confusionmatrix).混淆矩阵是分析分类器识别不同类元组情况的一种有用工具,如表4所示.本文将非恶意应用定义为正元组,恶意应用定义为负元组.Truepositives(t_pos)指分类器将非恶意应用正确识别为非恶意应用的元组;Truenegatives(t_neg)指分类器将恶意应用正确识别为恶意应用的元组;Falsepositives(f_pos)指分类器将恶意应用错误识别为非恶意应用的元组;Falsenegatives(f_neg)指分类器将非恶意应用错误识别为恶意应用的元组.预测为↓非恶意应用恶意应用由混淆矩阵计算出相应的分类器评估参数的公式为Page9Accuracy=t_pos+t_negTPRate=Recall=t_posFPRate=f_posPrecision=t_posF-measure=2×recall×precision定义4.ROC曲线(ReceiverOperatingChar-acteristic接收者运行特征).ROC曲线显示了给定模型的Truepositives概率与Falsepositives概率之间的比较评定.定义5.AUC(AreaUnderCurve).ROC曲线下面的面积是模型准确率的度量AUC.为了评估模型的准确率,可以测量曲线下方的面积,面积越接近0.5,对应模型的准确率越低,完全准确的模型的面积为1.第1层分类使用选定的基础分类器PART、NB、kNN、J48对3种类型特征采用10折交叉检验测试,结果如表5~表7所示.由测试结果可以看出,针对各个组件特征,kNN算法表现最优;针对函数调用特征,PART算法的TPRate值最高,kNN算法的AUC值最高.由于函数调用特征数量较多,本文采用特征选择算法对原有特征进行筛选,目的是选择对分类器影响较大的255个特征,同时降低维度减少计算时间.具体使用InfoGainAttributeEval评价策略方法(根据与分类有关的每一个属性的信息增益进行评估)和Ranker搜索策略方法(属性判据值排序);针对系统调用特征,J48算法的TPRate值最高,PART算法的AUC值最高.由于Accuracy指标综合考虑了混淆矩阵的4个分量,本文使用Accuracy评估分类器性能,表8给出了各种特征集合各个基础分类器Accuracy值的结果.由此得出,kNN算法为针对各个组件特征的最优分类器,PART算法为针对函数调用特征的最优分类器,J48算法为针对系统调用特征的最优分类器.TPRateFPRatePrecisionRecallF-MeasureAUCPART0.8720.1360.8740.8720.8730.936NB0.7770.1880.8080.7770.7810.870kNN0.9060.0930.9080.9060.9060.938J480.8980.1170.8980.8980.8980.923TPRateFPRatePrecisionRecallF-MeasureAUCPART0.9750.0260.9750.9750.9750.977NB0.910.0920.910.910.910.969kNN0.9720.0280.9720.9720.9720.985J480.970.0330.970.970.9690.979TPRateFPRatePrecisionRecallF-MeasureAUCPART0.8120.250.8090.8120.8080.854NB0.6490.4860.6280.6490.6280.603kNN0.7550.2850.7550.7550.7550.715J480.8180.2160.8170.8180.8170.814PART87.1797.4681.16NB77.6791.0264.88kNN90.5697.2175.46J4889.8396.9581.77最优算法kNN第2层分类使用RotationForest算法对第1层选取的3个最优分类器使用10折交叉确认重新训练,得出表9.由此看出,经过RotationForest算法后,分类器效果得到了明显的改善.TPRateFPRatePrecisionRecallF-MeasureAUC各个组件特征0.9120.090.9140.9120.9130.948函数调用特征09750.0270.9760.9750.9750.988系统调用特征0.8740.1640.8730.8740.8730.945第3层分类使用第2层输出的3个最优分类器模型并结合判决算法对新的未知应用程序进行检测.依旧采用10折交叉确认对3126个应用程序进行测试,得到的混淆矩阵为表10,准确率为94.24%.测试结果充分证明了Androdect系统的有效性.预测为↓非恶意应用/个恶意应用/个非恶意应用恶意应用5.3结果比较为了评估Androdect系统的有效性,本文将提出的方法与近年来的相关工作进行对比,并与国外著名的Androguard工具使用相同的测试样本进行对比分析.5.3.1与近年来相关工作的对比表11列出了本文提出的方法与近年来的相关Page10工作的对比情况.DroidMat[17]提取权限、Intent、API等特征,使用聚类算法进行聚类而后使用分类算法检测恶意应用,对比了两种聚类算法K-means和ExpectationMaximization(EM)以及两种分类算法k-NearestNeighbor(kNN)和NaveBayes(NB)的检测结果.该方法将多类特征放在一个集合中,使用单一种类分类算法进行检测.Andromaly[15],动态提取API特征,对比使用3种特征选择算法ChiSquare、FisherScore、InfoGain和6种数据挖掘算法NB、BN、DTJ48、Histogram、K-means、Logistic的测试结果,缺点一是没有使用真实的恶意应用进行实验验证,仅使用自己编写的4个恶意应用进行检测;二是动态提取整个运行环境的API特征,没有表11相关工作对比检测工具DroidMat[17]权限、API、Intent等特征Andromaly[15]Crowdroid[14]AASandbox[8]文献[12]中工具文献[13]中工具Androdect组件、系统调用、函数调用等特征动静结合综上所述,DroidMat和Androdect系统提取了Android应用的多类行为特征,充分反映了Android应用恶意行为特征;AASandbox和Androdect系统采用了动静态结合的特征提取技术,弥补了动静态分析技术各自的缺点;除了Androdect系统,其它工具都采用单一分类或者聚类算法进行检测;本文设计的实验收集了更多现实中的应用程序进行检测来验证系统的有效性和准确性.5.3.2与Androguard对比由于在网上可以很容易获得Androguard工具,本文使用同样的测试样本对Androguard以及Androdect进行了测试.使用Androguard官方网站提供的Ubuntu系统镜像ARE(AndroidReverseEngineering),ARE默认安装的Androguard版本过低,作者没有更新,本文将其进行更新,并下载相关依赖库重新编译,更新至2013年4月最新版本Androguard-1.9.但是最新版本Androguard-1.9以及Androguard-1.6对于APK的解析存在问题,有很多不能处理的应用程序,对恶意应用的检测效果很差,反而较低版本更加稳定.并且发现更新版本的Androguard签名库并没有发生变化,只是加入了更多的程序分析功能,对本实验没有影响.因此本文还是与ARE默认安装的Androguard版本进行对比.针对运行中的APK进行特征提取;三是测试过程多人工参与.Crowdroid[14]使用动态方法对系统调用进行特征提取,基于K-means聚类算法进行检测,该工具只能区分同一应用程序的各个变种是否为恶意应用.AASandbox[8]提出了动态提取系统调用特征的总体框架和思想,没有应用数据挖掘算法进行检测,也没有给出验证结果.文献[12]提出的工具采用静态方法提取函数调用特征,对比了3种分类算法CentroidMachine、NB、SVM的检测结果,但只针对Symbian系统进行了验证.文献[13]静态提取了函数调用特征,对比了3种分类算法PART、Prism、kNN在Android系统上的检测结果,对240个应用进行验证.K-means、LogisticAndroid4个自己编写APKPART、Prism、kNNAndroid240个APK三层混合系综算法Android3126个APK对比发现,Androguard处理大量应用程序时无法完全自动化,并有部分应用程序不能正确处理,进程可能被意外杀死,报错退出,或者停止执行.而且运行时间慢,平均一个应用程序大约需要运行2.5min,程序意外中止后需人工发现重启程序,排除运行中的间隔时间,运行3126个应用程序需要耗费5.5天时间.具体的对比数据如表12所示,测试结果使用混淆矩阵说明,如表13、表10所示.由此得出,Androdect在准确率上高于Androguard,并且运行时间短,可以处理几乎所有的应用程序.表12Androdect与Androguard测试数据对比Androguard90.74大于5.51663126Androdect94.242.1预测为↓非恶意应用/个恶意应用/个非恶意应用恶意应用5.3.3结论改进了它们的缺点,主要优点有以下几个方面:本文提出的系统结合了上述研究方法的优点,(1)以往的研究方法大多提取单一种类特征,Page11本文提出的系统提取3种不同类型特征,充分反映了应用程序行为,并且该系统具有可扩展性,可以加入更多类型特征进行检测.(2)采用动静态结合的特征提取方法,动态方法弥补了静态方法不能检测运行中释放恶意代码的缺点,绕过了代码加密混淆问题;静态方法为动态方法提供了运行参数,解决了动态方法无法处理的应用程序.(3)首次设计了三层混合系综算法THEA,可以充分考虑不同类型特征在Android恶意代码检测中所起的不同作用,对各类特征分别选取最优基础分类器并给出综合判决结果,实验证明了该算法的有效性.(4)对大量现实中的应用程序进行检测,可以处理几乎所有的应用程序,并且实现了完全自动化.6讨论第5节介绍了Androdect系统与其它相关工作比较的主要优点,但是该系统仍然存在一些局限性.下面给出该系统的局限性和下一步工作方向:(1)本文提出的Android恶意应用检测系统具有一定的扩展性,主要表现在两个方面.一是特征类型方面,可以加入更多类型的特征,不仅局限于本文提出的3类特征.例如,可以加入具体的权限使用情况、上层API使用情况等特征;二是基础分类器的选择,本文强调了基础分类器的选择应选取差异较大的不同类型的分类器,也可以加入SVM等精度更高的分类器作为基础分类器,本文只选取了之前研究者通常使用的四个分类器,下一步工作中将加入分类精度更高的分类器.(2)在Android恶意应用的检测研究中本文提出分别针对不同特征做分类还出于以下几个原因:①不是所有的Android应用程序都包含本文提取的全部3种类型特征,部分Android应用程序不存在本文提取的函数调用特征,部分Android应用程序没有使用组件,所以无法将所有特征混在一起考虑.②一个Android应用程序的组件特征只有5个,而系统调用特征可能使用100多个,函数调用特征可能使用上千个,如果将所有这些特征融合在一起考虑,那么组件类的5个特征可能会被淹没.并且对于不同类型的特征,本文衡量的数据不同,针对组件特征本文考虑的是每个应用程序使用每个组件的个数;针对系统调用特征本文考虑的是每个应用程序使用每个函数调用的次数;针对函数调用特征本文考虑的是每个应用程序使用了哪些函数调用.③本文提出的检测系统的时间消耗主要在各类特征提取和格式化处理部分,而分类器的训练和检测上执行时间很短,通常在几秒或几分钟内完成,并不会牺牲很多时间.(3)本文中的动态行为特征提取模块使用的是Monkey工具①,它是Android中的一个命令行工具,可以在模拟器或实际设备中运行.它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等),模拟人类使用应用程序的动作.后面的工作可以参考文献[20]所做的研究,在动态模拟事件时基于UI(UserInterface)智能地有规律地触发事件.但是,该文献也指出,此研究没有在大量应用程序上做测试,因为基于UI触发恶意行为的应用程序占少数.(4)针对多类特征的三层混合系综算法可以结合云计算平台进行更快速的处理,进一步研究实现在线实时数据检测,预防现有的update攻击.Update攻击就是在应用程序提示更新后,用户确认并下载安装含有恶意代码的更新程序.(5)本文实验中的恶意样本已经是广为流传的恶意应用,各大杀毒软件已经在各自的病毒库中包含了这些病毒,所以检测率会比较高.手机上的杀毒软件对已知病毒的查杀率也比较高.根据独立安全机构Av-test在2013年1月使用ESET、Lookout:Antivirus&Security、Kaspersky、Qihoo360等22个手机杀毒软件对869个已知Android恶意应用的检测报告显示,各大手机杀毒软件的平均查杀率为94%,与本文工具的准确率94.24%相平.而本文主要研究的是对未知恶意应用的检测,在此方面,各大厂商没有公开自己的杀毒软件的技术细节,本文无法做详细分析.7总结本文采用动静态结合的技术提取Android应用的多类行为特征,通过设计三层混合系综算法THEA建立检测模型,并实现检测工具Androdect进行恶意代码检测.一方面弥补了动态分析和静态分析各自的缺点,另一方面充分考虑了不同类型特①UI/ApplicationExerciserMonkey[EB/OL],http://devel-Page12征在Android恶意行为检测中所起的不同作用,对各类特征分别选取最优算法并给出综合判决结果.使用Androdect对现实中1126个恶意应用和2000个非恶意应用进行测试.实验结果表明,Androdect在准确率和执行效率上表现良好,优于其它著名的恶意代码检测工具.下一步工作将研究加入更多类型行为特征以及精度更高的基础分类算法,在动态阶段模拟更精确的用户触发行为,并对三层混合系综算法结合云计算实现更快速的处理,进一步完善系统.致谢感谢我的导师、师兄以及我们的团队给予我的所有帮助,还要感谢给予此论文意见和帮助的各位审稿专家和编辑,最后感谢我的家人给予我的大力支持!
