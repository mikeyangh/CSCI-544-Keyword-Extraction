Page1NodeRank:一种高效软硬件划分算法陈志武继刚宋国治陈金亮(天津工业大学计算机科学与软件学院天津300387)摘要软硬件协同设计是现代嵌入式系统开发的核心技术,如何将系统功能划分到软件和硬件部分上是软硬件协同设计的关键环节.文中将软硬件划分问题看作带有动态通信代价的变异0-1背包问题,提出一种基于迭代排序思想的NodeRank算法.该算法通过迭代排序计算结点通信代价的期望值,进而求解背包问题,构造出软硬件划分问题的优质启发解.实验结果证明,在计算-通信代价均衡,弱实时性约束条件下,NodeRank对边点比大于等于2的任务图的处理结果与目前已知效果最好的禁忌搜索方法的平均性能差距不超过1.2%,而平均时间开销可以节约95%.在通信代价较高的条件下,NodeRank与禁忌搜索相比,可提升性能达3.5%,并节约时间超过75%.关键词软硬件划分;启发式算法;0-1背包问题;迭代排序1引言件部分具有执行速度快、功耗低等优点,但成本较高;软件部分执行速度慢,但成本低,配置相对灵活.软件和硬件实现方案具有互补特性,需要根据系统现代嵌入式系统通常由软硬件两部分组成.硬需求进行协同设计.软硬件划分是软硬件协同设计Page2的关键环节,它决定系统中哪些组件由软件实现,哪些由硬件实现,对系统性能有重要影响.软硬件划分问题是一个NP完全问题[1],目前已有的解决方法主要分为精确算法和启发式算法两类.精确算法包括动态规划算法[2-3]、整数线性规划算法[4-5]和分支限界法[6]等,一般用于较小规模的划分问题.对于规模较大的问题,只能使用启发式算法.处理软硬件划分问题的启发式算法主要分为专用启发式算法和通用启发式算法两大类.专用启发式算法包括硬件约束优先[7]、软件约束优先[8]和软硬件约束结合[9]3个子类.目前,面向可重构硬件环境的专用启发式算法[10-11]逐渐发展为新的研究热点.在通用启发式算法方面包括遗传算法[12-13]、模拟退火算法[14]、粒子群算法[15]等基本智能搜索方法.也有学者提出复合型搜索算法,例如,文献[16]将遗传算法中的交叉和变异思想引入粒子群优化算法,提出一种遗传粒子群优化(GPSO)算法.文献[17]提出将遗传算法与禁忌搜寻相结合(GATS)的启发式算法.文献[18]提出一种将遗传算法与蚂蚁算法进行动态融合的软硬件划分方法.本文利用文献[19]提出的模型将硬件划分问题转化为带有动态通信代价的变异0-1背包问题,借鉴用于网页排名的PageRank算法思想,对结点的通信代价期望值和排名进行迭代计算,根据背包问题贪心解策略构造并调整得到软硬件划分问题的优质启发解.本文第2节对使用的计算模型进行描述,并对前期基础工作进行介绍;第3节讨论NodeRank算法设计,进行复杂性分析;第4节介绍实验方法,展示并分析实验结果;最后总结全文并对下一步工作进行展望.2问题模型与前期工作根据文献[19]提出的计算模型,利用无向图G=(V,E)描述系统任务图,如图1所示,其中V和E分别是结点和边的集合.每个结点i包括软硬件执行代价si和hi,边上的权值表示结点间通信代价,记为cij,图1中实线代表划分方案的实际通信代价.软硬件划分问题P可等价表示为问题Q.问题P的具体定义和变换过程请参考文献[19].Q其中狓=(x1,x2,…,xn)表示一个划分结果,xi=1表示结点i由软件实现,xi=0表示由硬件实现,R为软件代价和通信代价的约束,C(狓)=∑n为总的通信代价.问题Q与式(2)所示的经典0-1背包问题非常相似:hi,si,R分别对应bi,wi,K,区别在于问题Q存在非线性的通信代价C.0-1KP由于0-1背包问题存在简单且有效的启发式算法:根据物品的价值b与重量w的比值由大到小依次放入背包,直到满足约束条件.因此,在前述的问题模型基础上,求解软硬件划分问题的基本思路是首先构造对应变异0-1背包问题的启发解,然后再调整为问题Q的可行解.根据这一思路,我们在文献[19]中提出了一种一维搜索算法.它对非线性的通信代价C在取值范围[0,R]内依据步长参数dx进行一维搜索,针对不同的C值,构建不同约束条件的背包问题,并通过求解一系列背包问题找出针对问题Q的较优可行解.该算法大幅缩减了搜索空间,具有较低的时间复杂度O(nlogn+d·(n+m)),其中d是算法在一维搜索空间内的搜索频次.文献[9]中提出的启发式算法首先忽略通信代价C,将问题Q直接简化为经典0-1背包问题进行求解,然后通过对软硬件划分结果集合中的结点进行双向移动调整,提高启发解的质量.该算法的时间复杂度是O(nlogn+k·(n+m)),其中k是需要进行调整的节点数量.此外,文献[9]还利用禁忌搜索技术对该启发式算法得到的解进行改进,该方法得Page3到的解是目前对这一类软硬件划分问题已知取得的最好结果.3NodeRank算法3.1算法思想与文献[9,19]相似,NodeRank算法的基本思路也是要利用0-1背包问题的贪心策略来近似求解问题Q.但对于问题Q来说,有效的排序策略必须考虑通信代价C的影响.分析发现,一条边的两个结点分属不同子集(硬件集合VH和软件集合VS)的可能性越大,则该边所产生的通信代价计入总代价的可能性就越大,即该边所产生的通信代价的期望值就越大.从结点角度看,结点的通信代价与相邻结点的划分情况(即排序)有关,而相邻结点的划分又与其通信代价有关,进而与本结点划分(即排序)有关.为解决这一矛盾,本文借鉴了网页排名算法PageRank[20]的设计思想,设计了一种NodeRank算法.PageRank算法的基本思想是:要确定一个网页Wi的相对排序,不仅要知道有多少网页链接了它,而且还要知道那些网页各自的排序———因为排序靠前的网页质量更高,建立的链接更有“价值”.PageRank算法将这一问题描述为式(3),通过迭代方式计算出所有网页的排名.i表示第n次迭代后页面Wi的排名,j→i表其中Rn示Wj包含一条到Wi的链接,Nj表示页面Wj的链接总数.本文假设初始时结点都属于VH,对问题Q的求解过程即为找出排序靠前的结点加入VS.为了更准确地对结点进行排序,定义结点i加入VS带来的通信代价期望E(ci),结点i属于VS的概率为PS(i),结点i属于VH的概率PH(i)=1-PS(i).且规定E(c)的初始值为0.NodeRank算法利用图2所示的迭代流程进行近似求解,计算0-1背包问题贪心解时采用的排序依据为Rank(i)=hisi+E(ci).因为估算的通信代价与实际情况存在偏差,得到的解可能不是可行解,必须对它进行判断与调整.调整的基本思路与文献[9]提出的启发解调整思路相同,具体方法在3.2节中详细介绍.3.2算法描述与分析算法1是对图2所示NodeRank算法框架的伪代码实现,迭代iter_num次后自动结束.特别当iter_num=0时,NodeRank将退化为文献[9]所提出的启发式算法.算法1.NodeRank.输入:任务图G、约束条件R和迭代次数iter_num输出:迭代过程中的最佳划分方案狓best=(x1,x2,…,xn)1.狓=(0,0,…,0);狓best=(0,0,…,0);max_sum_hixi=2.REPEAT3.Rank(i)=hisi+E(ci),按照Rank(1)Rank(2)…4.i=1,rec=R5.REPEAT6.IFsirecTHEN7.rec=rec-si,xi=1andi=i+18.ENDIF9.UNTIL((rec0)or(i>n))10.IF(S(狓)+C(狓)>R)THEN11.狓=Adjust_Out(狓)12.ENDIF13.狓=Adjust_In(狓)14.IFmax_sum_hixi<H(狓)THEN15.max_sum_hixi=H(狓)16.狓best=狓17.ENDIF18.对于每个节点i,19.对于每个节点i,20.k=k+121.UNTIL(k>iter_num)第3~9行完成带有通信代价的0-1背包排序求解过程.这是一个贪心过程,并不能保证所得结果为可行解.第10~17行利用算法2和算法3将其调整为较好的可行解,其中S(x)和H(x)分别表示软硬件的总代价.第18行对第k次迭代后的结点i属于VS的概率PS(i)进行更新,其中PS和PH分别表示当前划分结果为软件或硬件对PS(i)的更新分量,这也是PS(i)的初始值,α表示概率PS(i)历史情况所占的权重,这些都是算法的全局参数.第19行根据更新后的PS(i)重新计算每个结点的通信代Page4价期望值.算法2和算法3共同完成可行解调整工作.首先,按照式(4)计算每一个结点i移动后通信代价的变化情况Δci:然后,按照硬件代价与软件代价和通信代价变化之和的比值最小化原则移出结点,按照硬件代价与软件代价和通信代价变化之和的比值最大化原则移入结点,并保证调整结果为可行解.算法2.Adjust_Out.输入:任务图G,约束条件R和当前划分方案狓=输出:移出部分结点后的划分方案狓=(x1,x2,…,xn)1.REPEAT2.对于每个xi=1的结点i3.k=argmini4.更新S(狓),C(狓)和H(狓)5.UNTIL(S(狓)+C(狓)R)算法3.Adjust_In.输入:任务图G,约束条件R和当前划分方案狓=输出:移入部分结点后的划分方案狓=(x1,x2,…,xn)1.rec=R-(S(狓)+C(狓))2.REPEAT3.对于每个xi=0的结点i4.k=argmaxi5.rec=rec-(sk+Δck)6.更新S(狓),C(狓)和H(狓)7.UNTIL(S(狓)+C(狓)R)定理1.NodeRank算法的时间复杂度为O(N·(m+n)logn),其中N为迭代次数,n和m分别表示任务图中的结点数和边数.证明.NodeRank算法(算法1)会通过迭代方式调用算法2和算法3,这三部分共同决定了整个算法的时间复杂度.对每次迭代过程,算法1第3行在O(nlogn)内完成排序,随后的第5~9行可以在O(n)时间内完成.第18行对每个结点计算新一轮被选入软件集合的概率,所需时间为O(n),第19行等价于对图中每条边的2个顶点进行计算,所以时间复杂度为O(m).算法2和算法3的执行过程类似,这里作为一个整体进行分析.在一次迭代过程中,算法2和算法3移动的结点总数必然小于等于n.每次将一个结点k移出或移入软件或硬件集合后,只需要计算任务图中与结点k直接相连的结点的通信代价的变化值Δc.用mi表示和结点i关联的边数,则更新总次数必小于等于∑n新Δc的执行时间为O(m).由于算法2和算法3中要多次选择hisi+Δci行排序处理,所需时间为O(nlogn).通过前面分析可知hisi+Δci看作向有序数据中进行插入操作,开销为O(logn).因此,算法2和算法3中选择移动结点的执行时间可以控制在O(mlogn+nlogn).结合以上分析,NodeRank算法的时间复杂度为O(N·(m+n)logn).4算法性能测试4.1实验环境为验证NodeRank算法的性能,本文实验部分采用了文献[19]的基础设置环境.根据通信代价与软件计算代价之比(CCR)定义了3种不同类型的任务图:计算密集型、计算-通信均衡型和通信密集型,对应CCR取值分别为0.1,1与10.考虑2种不同约束条件R:强实时约束R值较小,记为R=low;弱实时约束R值较大,记为R=high.表1给出文献[19]中使用的全部基准任务,所有任务的边数与结点数的比值(简称边点比)范围为[1,3].任务名称结点数n边数m规模(2n+3m)规模序号m/ncrc32253415211.4patricia215019222.4dijkstra267126532.7clustering150333129942.2rc6329448200251.4random110001000500061.0random210002000800082.0random31000300011000103.0random415001500750071.0random51500300012000112.0random61500450016500133.0random7200020001000091.0random82000400016000122.0random92000600022000143.0在本文中,文献[19]提出的一维搜索算法记作Base,文献[9]提出的启发式算法记作Adjust,基于Page5禁忌搜索的改进算法记作Adjust+Tabu(在表2~4中简称Tabu).实验硬件环境为曙光小型机:AMDOpteron6234CPU(主频2.4GHz)、512GB内存.操作系统平台为Windows2008Server.实验使用了文献[19]和文献[9]的算法源代码进行算法性能比较,并对文献[9]中禁忌搜索过程的参数进行了优化.NodeRank的全局参数值设定为α=0.7,PS=0.9,PH=0.1.每组实验结果均为随机运行50次得到的平均值.利用下式计算算法A对算法B的改进情况.改进程度=1-算法A的硬件代价4.2实验结果与分析图3给出对Size=2002的任务使用不同迭代次数时,NodeRank与Adjust结果相比的改进情况.其中第1次迭代的改进效果最明显,第4次迭代图4各算法与Base相比的改进情况之后的改进幅度变小.综合考虑算法的性能与开销等情况,后续实验中NodeRank的迭代次数设为4.图4(a)~图4(f)是对不同算法求得的解的质图3NodeRank算法迭代次数选取,Size=2002Page6量的比较,横坐标是任务规模序号(对应任务情况参见表1),纵坐标为相对Base的改进情况.图4(a)、(c)和(e)表明在R=low情况下,各种算法改进幅度相差不大.图4(d)表明,在CCR=1,R=high情况下,实验结果明显分为两种情况.对规模序号为5、6、7和9的任务实例,NodeRank所得结果与Adjust差别不大,与Adjust+Tabu的结果有一定差距.这类任务实例的共同特征是边点比值约为11,即任务图中结点间通信情况较少.因此,表2在比较NodeRank和Adjust+Tabu所求得解的质量时将测试任务按照边点比分为两组:[1,2)和[2,3].前一组包括规模序号为1、5、6、7和9的任务,其余任务属于第2组.对第2组的任务来说,NodeRank与Adjust+Tabu的平均差距只有1.2%,最大差距不超过3.4%.从图4(e)、(f)和表2中可以看出,在CCR=10时,NodeRank(表2中简记为Rank)在总体上具有一定性能优势,最好的情况比Adjust+Tabu性能提升3.5%.对表2中第2组任务来说,NodeRank比Adjust+Tabu具有1.5%的平均性能提升.图5分析了对size=8000的任务,各算法相对Base的改进幅度的分布情况.横坐标是改进幅度,范围是[0%,5%,10%,…,80%],每个点间隔是5%,如果一次实验的改进幅度落在区间(a,b]内,则计入b%所在的点.纵坐标是50次随机实验中改图5各算法与Base相比改进情况的分布,size=8000表2NodeRank与Adjust+Tabu比较(数值为硬件代价)m/n任务[1,2)[2,3]注:①Tabu算法相对NodeRank算法的改进;②NodeRank算法相对Tabu算法的改进.进程度落在b%点所代表的区间的次数.图5的总体情况与图4的分析结论基本一致.在CCR=1,R=high情况下,NodeRank的效果与Adjust+Tabu相差很小,都明显优于Adjust.在CCR=10,R=high情况下,NodeRank具有明显优势.表3和表4分别给出了CCR=1,R=high和CCR=10,R=high两种情况下各算法的运算时间,以Adjust+Tabu的运行时间为基准(即100%)进行了换算.在CCR=1,R=high条件下,NodeRankPage7与Adjust+Tabu相比,平均时间开销节约高达95%以上,但性能相差不大,因此具有很高的效率.NodeRank的运行时间约为Adjust的3~4倍,这与本文实验所用迭代次数为4的设置一致,说明NodeRank的时间开销与迭代次数基本呈线性关系,因此可以利用NodeRank的迭代次数调节性能和时间成本的关系.任务规模1520.10.00.00.00.20.0485.91920.10.00.10.00.20.0536.02650.10.00.00.00.30.0582.212990.80.11.40.14.40.31715.520022.00.15.40.220.80.73117.3500012.90.241.00.5202.52.48523.7750027.90.296.50.8473.53.812332.6800014.70.268.00.7199.12.19409.71000049.50.3187.31.1889.45.316865.71100016.30.283.41.1197.92.67503.41200031.10.2162.41.2462.63.513392.11600054.10.3290.31.6839.64.618180.11650033.80.3195.81.7459.03.911682.62200057.70.3393.52.3881.45.117168.2任务规模1520.10.00.10.00.20.0941.71920.10.00.00.00.20.0364.52650.20.00.00.00.20.0403.512990.80.11.40.23.60.6648.420022.00.26.60.616.61.61030.1500013.20.262.30.9159.62.36927.8750028.60.3156.51.7378.04.29110.4800015.11.172.45.3161.911.71378.61000050.10.4276.62.2674.65.312703.11100016.31.081.15.0166.610.21627.11200031.01.5166.58.0361.717.42073.81600053.82.3332.714.3690.429.72323.91650033.61.6220.410.6416.020.12071.22200057.72.1382.413.6719.025.62810.9在CCR=10,R=high条件下,NodeRank与Tabu相比,平均节约时间在75%以上.由于任务规模较大时,Tabu无法找到更好的解,使得算法总体运行时间减少,导致时间节约比例上升.此时,NodeRank的运行时间约为Adjust的2~3倍,进一步提升了算法改进的时间效率.5结语利用解决0-1背包问题的思路,借鉴网页排序问题的经典PageRank算法,本文提出一个基于迭代排序思想的高效软硬件划分算法NodeRank.实验结果证明,在CCR=1,R=high情况下,NodeR-ank对边点比大于等于2的任务图的处理结果与目前已知效果最好的禁忌搜索方法的平均性能差距不超过1.2%,最大差距不超过3.4%,而平均时间开销可以节约95%以上.在CCR=10,R=high情况下,NodeRank与禁忌搜索相比,最多可提升性能3.5%,节约时间超过75%.下一步将对边点比约为11的任务(对应规模序号为5、6、7和9的任务实例)进行分析与优化处理.此外,还将研究如何利用NodeRank得到的启发解和结点Rank值,结合禁忌搜索等智能搜索算法,以期得到更好的解.致谢匿名审稿人对本文提出了宝贵修改意见,在此表示感谢!
