Page1BOD:一种高效的分布式离群点检测算法王习特申德荣白梅聂铁铮寇月于戈(东北大学信息科学与工程学院沈阳110004)摘要离群点检测是数据管理领域中的热点问题之一,在许多方面都有着广泛应用,如信用卡诈骗、网络入侵检测、环境监测等.目前现有的离群点检测算法大多针对集中式的处理环境.但随着数据规模的不断增长,传统的集中式算法处理效率受限,无法满足用户日益增长的需求.针对上述问题,文中提出了一种新型的分布式离群点检测算法.首先,在数据存储阶段(即预处理),提出了BDSP(BalanceDrivenSpatialPartitioning)数据划分算法.该算法可以有效地均衡每个计算节点的工作负载,并实现良好的过滤效果.此外,为划分所得到的每个块设计了一种全新的编码方式,可以快速地确定块与块之间的相邻关系,降低网络开销.基于BDSP算法,提出了BOD(BDSP-basedOutlierDetection)分布式离群点检测算法.该算法包括2个步骤:在每个计算节点本地,利用R树索引进行批量过滤,快速地计算离群点并得到本地候选集;利用BDSP中提供的块编码确定需要相互通信的节点,使用少量的网络开销得到最终结果.最后,通过大量实验验证了文中所提出的BDSP和BOD算法的有效性.实验结果表明,相对于现有算法,文中算法可以显著地提高计算效率并大幅降低网络开销.关键词离群点检测;分布式计算;大数据;数据划分;数据管理;大规模数据1引言离群点检测是数据管理中的热点问题之一[1],在许多领域都有着广泛的应用,如信用卡诈骗、网络入侵检测等.在早期文献[2]中,离群点被描述为:在一个数据集中,若某个数据点与其他数据点的差距非常大以至于被怀疑是通过其他机制生成出来的,那么该数据点就被认为是离群点.至今,研究者们已经提出了多种不同的离群点定义标准.其中,本文主要研究基于距离的离群点,该定义由Knorr等人[3]于1998年提出,是一种被广泛认可的离群点定义标准.具体地,对于给定的两个参数k和r,那么基于距离的离群点可以被定义为:对于数据集中任意数据点p,若与p的距离不大于r的点的数目少于k个,那么p为离群点.目前,学者们已经提出了许多优秀的离群点检测算法.但是绝大多数算法都是针对集中式环境设计的.面对数据量的不断增加,这些集中式算法的处理效率有限,在很多情况下不能满足用户的需求.例如在电子商务中,将用户的交易信息看作整体数据集,那么通过检测离群点(即查找那些与用户日常交易习惯不符的异常交易记录),可以帮助发现用户账户盗窃,进而避免财产损失.但目前许多大型的电子商务网站,每天都会产生极其大量的交易记录,若使用集中式算法对这些数据进行离群点检测,可能需要花费数小时的时间.计算结果的时效性无法得到保证,也就无法及时地避免用户财产损失.在这种情况下,设计一种高效的分布式离群点检测算法变得十分必要.本文主要针对基于距离的离群点,提出一种新型的分布式计算方法.目前在分布式环境中离群点检测的相关研究主要有文献[4-6].其中文献[5-6]采用了top-n离群点的定义①.这种定义的不足之处在于:对于每个数据点p,只关心与其最近邻的k个数据点,而忽视了其他与p临近的数据点提供的信息.此外,这种定义需要大量全局信息才能够计算出最终结果,网络开销较大,不适合分布式环境.文献[4]所研究的问题与本文相同,但所提出的PENL算法没有对数据进行有效地划分,对于数据集中任意一个数据点p,在最坏情况下,必须与其他所有数据点计算距离,才能得到最终结果.因此当数据规模较大时,PENL算法需要大量的网络开销,也无法保证良好的执行效率.1.1难点与挑战可以看出,分布式离群点检测是十分有意义的.但由于问题的固有难度较大,目前并未出现较为完善的计算方法.本文所面临的主要问题总结如下:(1)如何进行有效地数据划分.显然地,给定一①给定参数k、n,数据点p的得分为p和它最近邻的k个点Page3个数据集P(所包含的数据点个数为|P|)和一个具有N个节点的集群,在离群点检测开始之前,对数据进行有效地划分(即预处理),可以显著地提高计算效率.一般地,良好的数据划分应考虑如下2个方面:首先,使每个节点所获得的数据量大致均匀,保证较好的并行性;另外,使绝大部分计算可以在每个节点本地进行,不需要进行大量的通信,降低网络开销.目前常见的数据划分方式主要有包括2类:即基于数据量的划分和基于空间的划分.但这2种划分方式都存在明显的不足,无法满足上述要求.例1给出了详细的描述.例1.给定包含4个节点n1、n2、n3、n4的集群,和一个包含40个2维数据点的数据集P.若将各数据点映射到一个二维空间内,其具体结果如图1所示.已知一个基于距离的离群点查询,其中半径r=0.2,阈值k=4.为快速地计算数据集P的离群点,可将P划分为4个子集并分配给4台计算机分布式处理.第1种常见的划分方式为基于数据量的划分.即随机地为每个节点分配|P|/N个数据点,以保证每个节点上的工作量大致均衡.依据这种划分策略,每个节点获得40/4=10个数据点.具体的分配结果如图1所示(每个节点上的数据点以同一种图案进行标识,如节点n1上的数据点标识为三角形状).容易发现,这种分配方式忽略了数据点之间的空间位置关系,无法进行较好的本地过滤,造成大量网络开销.如在图1中,在节点n1上,当进行本地局部计算时,发现与p1距离不大于r的数据点只有p2,因此p1为n1的局部离群点.但此时却无法很好地判定p1是否为数据集P中的离群点(即最终结果),因为在其他计算机上,很可能存在与p1的距离不大于r的数据点(如p3、p4等).这样,在最坏情况下,节点n1需要与所有其他节点进行通信,从而造成了大量的网络开销,降低了查询效率.第2种常见的划分方式为基于空间的划分方式(如网格划分).即将一段连续空间划分为一个块,同一块内的数据点被划分在一起.例如在图1中,可将每维平均切分为2段,共得到4个块b1、b2、b3、b4,每个块被分配给一个节点.这种切分方式可以实现更好的过滤效果.如块b1中的点p5,该点在本地被判定为离群点,同时也容易地发现,与p5距离不大于r的数据点一定在块b1内,那么p5必然是全局的离群点.而对于p6,发现与其距离不大于r的数据点只可能在块b2、b3内,因此只需要与b3进行网络通信就可以确定p6是否为最终结果.可见此种划分方式节省了大量的网络开销进而提高计算效率.但是,这种划分容易造成数据分布不均匀,使各节点的负载不够均衡.如图1所示,块b3、b4内包括了大量的数据点,而块b1、b2仅包括少量数据点.因此这种划分方式也存在一定弊端,不适合于分布式计算.(2)如何在分布式环境下高效地计算离群点.在数据划分后,就需要分布式地计算离群点.宏观地,计算过程可以分解为2个部分:①在每个节点本地进行局部计算,得到一些可能成为最终结果的数据点(即候选集);②通过网络通信,从候选集中确定最终结果.相应地,分布式离群点计算也包括2个具体问题:首先,在步骤1中,如何快速并准确地获取候选集;此外,在步骤2中,如何有效地降低网络开销,以提高算法的整体性能.1.2主要贡献本文主要针对分布式离群点检测问题,提出了一种新型的数据划分策略以及相应的查询处理算法.具体地,本文贡献点总结如下:(1)提出了一种新型的基于空间的数据划分方法:BDSP(BalanceDrivenSpatialPartitioning)算法.该算法继承了传统空间划分的优势,具备良好的过滤效果.同时,还可以平均化每个节点上的工作负载,提高并行性.此外,为划分所得到的块设计了一种全新的编码方式,可以快速地确定块与块之间的相邻关系,降低网络开销.(2)基于BDSP算法,提出了一种分布式离群点检测算法:BOD(BDSP-basedOutlierDetection)算Page4法,该算法分为2部分:①首先在每个计算节点本地,设计了一种新型的基于R树的局部离群点检测算法,可以快速地计算出本地离群点并得到候选集;②利用块的编码迅速地确定需要相互通信的节点,最终使用少量的网络资源计算得出最终结果.(3)分别使用真实数据集和人工合成数据集进行实验,验证了本文所提出的BDSP和BOD算法的有效性.本文第2节概述离群点检测的相关工作;第3节对分布式离群点检测进行形式化描述;第4节详细描述BDSP数据划分算法,第5节描述BOD算法的具体过程;第6节给出实验结果与分析;第7节对全文进行总结.2相关工作本节主要对离群点检测的相关研究进行概述.在2.1节中,主要总结了对离群点的各类定义标准,并概述了传统集中式环境中相关的查询处理算法.在2.2节中,主要总结了分布式离群点检测的相关算法.2.1集中式离群点检测离群点最早是在文献[2]中提出的.在之后数十年的研究中,不同的学者给出不同的具体定义.早期出现的是基于统计的集群点定义标准[7].此类定义对数据集假设一种分布(或概率模型),那些明显不符合假设分布(或概率模型)的数据被认为是离群点.此类定义标准不适用于高维数据,因为对于高维数据,建立一个优秀的分布模型是非常困难的.为了克服上述问题,出现基于距离的离群点定义标准,如文献[3,8]等,以及基于密度的定义标准,如文献[9]等.这些定义并不对数据分布进行预先假设,因此具有良好的实用性.基于距离的离群点是目前被广泛认可的定义标准,也出现了许多相关的离群点检测算法.其中Knorr等人[3]提出的NL算法是一种基于距离的离群点检测的基准算法.该算法不使用索引机制,需要计算数据集中任意两个数据点之间的距离.Bay等人[10]提出了ORCA算法,该算法在离群点检测算法开始之前随机化数据集,可以快速地过滤掉非离群点.Angiulli等人[11]提出的DOLPHIN算法通过将一部分数据保存在内存中,只需要2次扫描数据集就可以得到所有的离群点.此外,还有一些算法致力于通过索引机制来改善查询效率,如R树[12]、M树[13]等.如文献[8]提出了IBACO算法,该算法使用R树进行范围查找,可以快速地计算离群点.目前还出现了许多针对特定应用背景的离群点检测算法,如数据流上的离群点检测[14],不确定数据的离群点检测[15]等.2.2分布式离群点检测当数据量较大时,集中式算法运行时间变长,降低了计算结果的时效性.因此,一些学者开始使用分布式算法并行地计算离群点,以提高计算效率.相关的研究总结如下.Otey等人[16]提出了一种针对混合属性数据集的离群点定义方法,并针对这种离群点定义,提出了分布式计算方法.该算法包括2个计算过程,在第1次计算结束后,集群各节点需要进行同步并构建全局模式用于后续计算.此外,还出现了一些基于MapReduce的并行离群点检测算法,如文献[17-18]等.但以上的算法不适用于基于距离的离群点定义.文献[5-6]采用top-n离群点定义.这种定义存在一定的不足,且不适合分布式环境(具体原因已在第1节中陈述).与本文所研究问题最为接近的工作有文献[4],该文主要基于Knorr等人所提出的NL算法提出了并行化的PENL算法.但算法没有使用索引机制,必须对数据集进行多次遍历,具有较高的磁盘I/O代价.此外,PENL算法采用了基于数据量的数据划分方法,在分布式计算时需要进行大量的网络传输.总之,目前现有的分布式离群点检测方法存在诸多不足,无法保证良好的计算效率.3问题描述本文主要研究在分布式环境下,如何并行地计算出数据集内所有的基于距离的离群点.下面,首先形式化的给出基于距离的离群点定义;其次,简要描述算法在分布式环境下的处理框架.表1列出了本文使用的主要符号.符号kpnb3.1基于距离的离群点定义一般地,给定一个具有d维属性的数据集P,记Page5数据集内的数据点个数为|P|.对于P内任一数据点p,p包括d个可度量的属性值,记作p=〈p[0],p[1],…,p[d-1]〉(为方便描述,后文中认为数据点的各维属性值均不小于0).那么点p1、p2之间的距离为dist(p1,p2)=∑i∈[0,d-1]定义1.邻居.给定一个用户定义的参数r,对于两个数据点pi、pj,若pi与pj之间的距离不大于r,那么称pi(pj)为的pj(pi)邻居.本文记数据点pi的邻居数目为nn(pi,r).定义2.基于距离的离群点.给定距离阈值r和一个正整数k,对于数据集P中数据点pi,如果满足nn(pi,r)<k,那么pi为离群点.3.2处理框架本文主要针对常见的分布式环境,即集群包含固定个数的计算节点N={n1,n2,…,n|N|}(|N|为节点个数),每个节点都存储数据集P的一个子集,并包含一个查询处理引擎,用于接收查询和查看结果.节点之间可以相互通信.分布式环境下的离群点检测问题可以被描述为:对于一个给定参数r、k的查询,通过充分利用集群中各节点的计算能力,快速地返回数据集P中所有的离群点.图2描述了查询处理的总体框架.如图2所示,每个计算节点具有一个查询处理引擎,并存储着数据集|P|的一个子集.数据集的划分使用BDSP算法,将在第4节中具体介绍.当某一计算节点n1接收到一个查询q时,n1将查询发放给集群中的全部节点;接下来,每个节点在本地进行局部计算,得到本地候选集;然后,通过少量的全局通信,确定最终结果,并将其汇总到n1上供用户查看.4数据划分在离群点检测之前,进行有效地划分,可以显著地提高计算效率.本文提出的BDSP是一种新型的空间划分方法,该算法继承了传统空间划分良好的过滤能力,并具有较高的分布均衡性.算法大体包括2个步骤:首先将数据集切分成多个不等大的块,同时为每个块分配唯一的二进制编码,用于快速地判定块之间的相邻关系(4.1节);接下来按照一定的规则将得到的块分配给集群中的各节点,使每个节点所得到的数据点个数大致相同(4.2节).4.1块的切分本小节主要包括两部分内容:首先介绍切分算法的具体细节;接下来阐述块编码的详细方法.4.1.1切分算法在介绍切分算法之前,首先介绍该算法的2个主要输入参数:(1)块(block).即所需要切分的空间区域.对于d维空间内的一个块b,可以使用块的下界点b.min、上界点b.max表示,记b=[b.min,b.max].其中对于任意属于块b的数据点p,满足i∈[0,d-1],b.min[i]<p[i]b.max[i].例如在图3中,块b6的下界点b6.min=〈0.5,0.25〉,上界点b6.max=〈0.75,0.5〉,则b6可以表示为[〈0.5,0.25〉,〈0.75,0.5〉].在切分算法中,最初被切分的块为数据集P对应的全域(如在图3中,全域为[〈0,0〉,〈1,1〉]).Page6(2)切分维度.取值范围为[0,d-1]整型变量,用于标识将被切分的维度.在切分算法中,最初的切分维度为0.总体上,切分算法是一个递归调用的过程.首先,对于当前块b(对应的维度为i),切分算法首先选择b在第i维上的中值mid=(b.min[i]+b.max[i])/2.沿着第i维的方向,以中值mid为分割线,将b分成2个等大的子块bleft、bright(为方便描述,后文称第i维值小于mid的子块称为左侧子块,称大于mid的为右侧子块).其中bleft的下界点bleft.min与b的下界点b.min相同,bleft的上界点的第i维值bleft.max[i]=mid,j∈[0,d-1]且j≠i,bleft.max[j]=b.max[j].相应地,bright.max=b.max,bright.min[i]=mid,j∈[0,d-1]且j≠i,bright.min[j]=b.min[j].接下来,对于得到的两个子块bleft,bright中的任一块,若该块中的数据点个数少于|P|/N,那么切分终止,否则,需要对该块进一步切分,所对应的切分维度变为(i+1)modd,切分方法同上.算法1描述了切分的具体过程.算法1.split(blockb,dimensioni).1.取b在第i维上的中值mid=(b.min[i]+b.max[i])/2;2.沿着第i维的方向,以值mid为分割线,将块b切分3.IF块bleft内的数据点个数多于|P|/NTHEN4.递归调用split(bleft,(i+1)modd);5.ELSE6.输出bleft作为最终结果;7.ENDIF8.IF块bright内的数据点个数多于|P|/NTHEN9.递归调用split(bright,(i+1)modd);10.ELSE11.输出bright作为最终结果;12.ENDIF例2.如图3所示,分布在二维空间[〈0,0〉,〈1,1〉]内的数据集P的规模|P|=60,集群共包括6个节点,|P|/N=10.首先对于全域,沿着第0维方向,以中点0.5为分割线,将其切分成2个子块,左侧为[〈0,0〉,〈0.5,1〉],右侧为[〈0.5,0〉,〈1,1〉].进一步考虑左侧子块[〈0,0〉,〈0.5,1〉],发现其内部包含超过10个数据点,因此需要进一步将该块沿着第1维方向进行切分,得到块b1,b2.此时b1,b2内的数据点个数均小于10个,左侧的切分终止.接下来以相同方法对右侧子块进行切分,最终得到b1,b2,…,b9共9个子块,每个子块内都包含不超过10个数据点.切分算法中,当某个块中的数据点个数少于|P|/N(即平均每个节点应该存储的数据点个数)时,就不再继续切分该块,因此大多数情况下,最终得到的块的数目只略大于N.同时也可以看出,当数据集规模给定时,算法的终止条件只与计算节点数目N有关,而与数据维度d无关,因此切分算法对数据维度的变化并不敏感.4.1.2块的编码在计算离群点的过程中,相邻的块之间需要进行网络通信才能确定最终结果.如在图1中,块b3中可能存在数据点p6的邻居.为确定p6是否为离群点,b2就需要与相邻块b3进行通信.但实际上,经过切分之后,难以保留块与块之间的空间关系,尤其是当数据维度较高或切分次数较多时,确定块与块的相邻关系变得十分复杂.为解决上述问题,提出了一种新型的块编码方式,规则如下.在初始化时,指定全域的编码为“”.接下来,在每一次切分过程中,记被切分的块b的编码为b.code,并记b被切分成的左侧子块为bleft,右侧子块为bright.那么bleft对应的编码为bleft.code=b.code+“0”,记为b.code的左孩子.相应地,bright的编码bright.code=b.code+“1”,为b.code的右孩子.当切分算法结束后,编码过程构成了一颗二叉编码树.树的每个非叶子节点都与某一维度的切分相对应,叶子节点为切分算法最终得到的块.图4展示了与图3切分过程对应的编码树.其中根节值为空,与0维的切分相对应.对0维的切分中产生的左侧子块[〈0,0〉,〈0.5,1〉]编码为“0”.对该子块的1维进一步切分,得到的左侧子块b1的编码为“0”+“0”=“00”,右侧子块b2的编码为“01”.利用上述编码方式,可以快速地确定块与块之间的相邻关系,极大地提高分布式计算的效率.在介绍具体细节之前,还需要引入虚划分的概念.Page7对于某个块b,假设全域以b为粒度进行划分,并按照相同的方式进行编码,最终可以得到若干与b等大且整齐排列的块.由于这次划分并未实际执行,故称其为虚划分,得到的块称为虚块(相应地,可以称真实切分得到的块为实块).例如在图3中,若以块b6为粒度进行划分,可以得到整齐排列的16个虚块,图5展示了虚划分的结果以及部分虚块对应的编码.那么,对于给定的块b,确定块相邻关系的方法可以被概括为2个步骤:首先,通过合理的编码转化,找到与b相邻的虚块;其次,利用相邻虚块提供的信息,找到与b相邻的实块.具体过程如下:步骤1.对于块b的编码b.code,容易发现b.code的每一位字符都与某一维度的切分对应.那么从b.code的左侧起,依次抽取与第i维对应的字符,将得到的字符合并为一个新的字符串,称为b的i维编码,记为sub(b.code,i).注意:给定编码b.code,可以求得b的各维编码;相应地,给定b的各维编码,亦可容易地还原b.code.例如在图4中,块b6的编码为1001,与第0维对应的字符依次为“1”、“0”,那么b的0维编码为“10”,即十进制2.类似地,其1维编码的十进制表示形式为1.容易发现,若以b为粒度进行虚划分,则b的每一维编码即代表了虚划分中b在该维度上的次序(从0开始计数),利用这一特性可以容易地找到相邻虚块.例如在图5中,以块b6为粒度进行虚划分,此时,块b6的0维编码为2,则其在0维方向位于第3块.类似地,b6在1维方向上位于第2块.因此,其相邻虚块的0维编码必然为1、2、3,1维编码必然为0、1、2.步骤2.容易发现,在步骤1中得到的相邻虚块与算法1中输出的真实块只存在3种位置关系,即包含、被包含、相等(不存在相互交叠的情况).通过对不同位置关系的仔细分析,可以最终得到b的所有相邻块,具体方法如下:(1)相等.对b的一个相邻虚块bvir,取其编码bvir.code,并以bvir.code为关键字查找编码树,如果发现某个叶子节点对应的编码与bvir.code相同,记该叶子节点对应的块为beq,那么bvir与beq相等,beq必与b相邻.例如:对于图5中编码为1000并与b6相邻的虚块,经过查找图4中的编码树,得到叶子节点b5.那么可以判定该虚块与b5相等,b6与b5相邻.(2)被包含.以bvir.code为关键字查找编码树,如果直至检索到某个叶子节点(记对应的块为bcon),仍然未得到与bvir.code相同的编码,那么bvir被bcon包含,bcon必与b相邻.例如:对于图5中编码为0011并与b6相邻的虚块,查找图4中的编码树,当检索到叶子节点b1时仍未得到相同编码.那么该虚块被b1包含,b1必与b5相邻.(3)包含.如果检索到某个非叶子节点,其对应的编码与bvir.code完全相同,那么bvir包含该节点的所有子节点对应的块,而其中只有一部分块与b相邻.此时,按照如下方法搜索以该节点为根的子树:对于检索到的任一节点γ,取γ对应的维度i,如果sub(bvir.code,i)>sub(b.code,i),那么继续检索γ的左孩子;如果sub(bvir.code,i)<sub(b.code,i),那么继续检索γ的右孩子;如果sub(bvir.code,i)=sub(b.code,i),那么γ的两个孩子都需要进行检索.例如图5中编码为1110并与b6相邻的虚块,发现其与图4中编码树的非叶子节点对应,则需要检索以该节点为根的子树.发现该节点与0维对应,其0维编码为“11”,大于块b6的0维编码,那么继续检索该节点的左孩子b8.发现b8已经为叶子节点,则检索终止,b8与b相邻.利用上述方法可以快速地找到块b的所有相邻块,b仅需要与其相邻的块进行网络通信即可计算最终结果.假设P内数据点成随机分布,设每个维度被切分成了ε段,那么最终全域被切分成εd个块.若使用块编码找到相邻块,那么b只需要与3d-1个块进行通信.而如果不使用该方法,在最坏情况下,b需要与εd-1个块进行通信(ε远大于3).可见,块编码可以大大的降低网络开销.编码树虽然是一颗非平衡二叉树,但在实际应用中并不会对查找效率产生太大影响.这主要是因Page8为在切分算法中,每进行d次切分,就会将原块切分为2d个子块,子块的每一维长度为原块的1/2.当在进行了h·d次切分之后,得到的最小块的每一维长度为1/2h,那么该块内任意两点的距离的最大值仅为槡d/2h.容易发现,若槡d/2hr,则该块内任意点都是其他点的邻居,此时继续切分已经没有意义.也就是说,最差情况下,当h分结束,此时编码树高为1预见,在通常情况下该值并不大.例如:对于一个3维数据集,查询半径r设为0.01.在最差情况下,编码树仅为24层高的2叉树,那么叶子节点的编码长度不超过3字节,查询效率可以得到保证.4.2块的分配当切分算法结束之后,记最终得到的块的集合为B={b1,b2,…,b|B|},显然块的数目|B||N|.接下来,需要将|B|个块分配给集群中的|N|个节点.分配算法主要考虑了2个方面:首先使每个节点所存储的数据点数目大致相同,均衡各节点的负载;其次,尽量将相邻块分配到同一个节点上,以进一步降低网络开销.具体的分配算法如算法2所示.算法2.allocate_blocks_to_nodes().输入:块集合B={b1,b2,…,b|B|},输出:将每一个块分配给集群中的节点1.将B中各块按照块内包含数据点个数降序排序;2.从B中取出前|N|个块,将它们分别分配给N中的3.WHILEB中仍然存在未被分配的块DO4.取出B中的第一个块b;5.初始化集合Ntemp为空;6.λ←集群中各计算节点包含的数据点个数的均值;7.FOR集群中的每一个计算节点niDO8.IFni包含的数据点个数不大于λTHEN9.10.ENDIF11.ENDFOR12.将Ntemp中的计算节点按包含数据点个数升序排序;13.顺序遍历Ntemp,选择包含与b相邻块最多的节点n;14.将b分配给节点n;15.ENDWHILE例如:在图3中,需要将数据集P存储在具有6个节点的集群中(记作N={n1,n2,n3,n4,n5,n6}).经过切分算法,P被分割成9个块,将他们按照数据点个数降序排序,得到序列b2,b3,b7,b1,b6,b5,b9,b8,b4.首先将前6个块依次分配给集群中的各个节点.接下来,当分配b9时,集群中各节点包含的数据点个数的均值λ=(9+8+8+7+7+6)/6=7.5,节点n4、n5、n6满足要求.将这些节点按照数据点个数排序得到n6、n4、n5.发现b9不与这3个节点所包含的任何块相邻,那么将b9分配给第一个节点n6.类似地,将b8分配给n5,b4分配给n4.表2描述了分配的最终结果.节点通过BDSP算法的切分和分配两个过程,可以将数据集P进行有效地分配.该算法首先继承了传统空间划分方法过滤能力强的优点,可以极大地减少网络开销;此外也可以保证集群中各节点获得的数据点数目大致相同,均衡了各节点的工作负载.定理1展示了BDSP算法的具体优势.定理1.使用BDSP算法,对于集群中任一节点n,其获得的数据点数目小于2|P|/|N|.证明.假设对于第i次分配结束时,集群满足定理1.那么对于第i+1次分配,若记此次需要分配的块为b,显然,b所包含的数据点个数|b||P|/|N|.记第i+1次分配最终选择的计算节点为n(算法2第13行),由于此时集群中各计算节点包含的数据点个数的均值λ必小于|P|/|N|,所以n中包含的数据点个数亦小于|P|/|N|.那么,将b分配给n后,集群中的节点仍然满足定理1.此外,易证在第一次分配时集群满足定理1.5BOD算法描述本节主要描述了BOD算法的具体细节.该算法包括2部分:(1)局部部分.即在每个节点本地利用R树索引进行批量过滤,使用少量的磁盘IO快速地确定最终结果的候选集;(2)全局部分.即利用4.1.2节中的块编码快速地确定需要相互通信的块,利用少量的网络通信从候选集中确定最终结果.5.1BOD算法-局部本小节主要阐述BOD算法中的局部离群点计算方法.在现有的基于索引的集中式离群点检测算法中,对于每一个数据点,都需要对索引进行范围查找,这种查询处理方式需要消耗大量的磁盘IO,并Page9不适用于大规模数据.为此,本文提出了一种新型的基于R树的局部离群点检测算法.该算法首先利用R树结构对数据点进行批量过滤,极大地减少了需要进行范围查找的数据点数目;之后,以批量查询的方式代替了传统的逐个查询,显著地减少了IO次数,从而提高了计算效率.在详细描述本文算法之前,首先对R树索引进行简单概述.5.1.1R树索引概述R树是一种树形的多维空间索引结构.它的每个节点对应空间内的一个最小外界矩形(MinimumBoundingRectangle,MBR).每个MBRm可以使用其下界点m.min和上界点m.max来表示,记作m=[m.min,m.max],记R树节点e对应的MBR为e.MBR.对于一个给定的阈值t,限定每个节点包含的对象数目在[t,2t]范围内.树的叶子节点对应的MBR是所包含数据点的最小矩形,非叶子节点对应的MBR是它所有孩子节点MBR的外包矩形.图6描述了2维空间内一个块bm=[〈0.25,0.25〉,〈0.5,0.5〉]对应的R树索引,阈值t=2,每个节点可包含2~4个对象.e6是一个叶子节点,包含p11、p12、p13和p14这4个点,它对应的MBR可以表示为e6.mbr=[〈0.3125,0.475〉,〈0.3375,0.4875〉].e2是一个非叶子节点,包含e4和e5两个孩子节点,它对应的MBR为e2.mbr=[〈0.3875,0.29〉,〈0.475,0.44〉].5.1.2局部查询算法描述算法首先利用R树结构对数据点进行批量过滤,具体的过滤方法如下.定理2.对于R树中的任一节点e,如果e.MBR满足:最大对角线长度不大于查询半径r,且MBR内的数据点个数不小于k,那么该MBR内的所有数据点均不是离群点.证明.若最大对角线长度不大于查询半径r,则MBR内所有数据点的相互距离都不大于r,又有数据点个数不小于k,则根据离群点定义,MBR内所有点都不是离群点.对R树进行遍历,所有满足定理2的MBR中的数据点一定不是离群点,可以被安全地过滤掉.例如在图6中,给定离群点查询r=0.05,k=4,MBRe5、e6、e8均符合定理2,可被直接排除.而e4、e7内可能存在离群点,需要保留.接下来,对于剩下的MBR,主要以批量查询的方式确定局部离群点.为提高查询效率,主要利用下面2个剪枝策略缩小搜索空间.定义3.MBR的最小距离[8].给定两个MBR,m1、m2,两个MBR的最小距离为min_dist(m1,m2)=∑i∈[0,d-1]槡x[i]=m2.min[i]-m1.max[i],m2.min[i]>m1.max[i]烄m1.min[i]-m2.max[i],m1.min[i]>m2.max[i]烅0,烆显然地,给定MBRm1中的任意一个数据点p1和m2中的任意一个数据点p2,p1与p2的距离必然不小于m1与m2的最小距离,即dist(p1,p2)min_dist(m1,m2).因此,得到第1个过滤条件.定理3.对于两个MBRm1、m2,如果min_dist(m1,m2)>R,那么对于m1中的任意数据点p1,m2中必然不存在p1的邻居(反之亦然).证明.根据定义1和3,本定理可得证.证毕.定义4.MBR的最大距离[8].给定两个MBR,m1、m2,两个MBR的最大距离为max_dist(m1,m2)=∑i∈[0,d-1]m1.min|,|m1.max-m2.min|}.槡类似地,给定MBRm1中的任意一个数据点p1和m2中的任意一个数据点p2,dist(p1,p2)max_dist(m1,m2).因此,得到第2个过滤条件.定理4.对于两个MBRm1、m2,如果max_dist(m1,m2)R,那么对于m1中的任意数据点p1,m2中所有数据点必然是p1的邻居(反之亦然).证明.根据定义1和3,本定理可得证.证毕.根据上述2个过滤策略,进行以R树叶子节点MBR为粒度,R为半径的范围搜索,可以得到所有Page10的局部离群点.具体过程如算法3所示.算法3.local_outlier_detection().输入:本地存储的所有数据点;对应的R树索引输出:所有的局部离群点1.初始化集合E为空,堆H为空;2.遍历R树,所有不满足定理2的叶子节点加入E中;3.FORE中的每一个叶子节点eDO4.集合Pe←读取e.MBR内的所有数据点;5.FORPe中的每一个数据点pDO6.nn(p,r)←计算Pe中以r为半径p的邻居数目;7.IFnn(p,R)kTHEN8.从Pe移除p;9.ENDIF10.ENDFOR11.IFPe不为空THEN12.R树根节点的孩子节点加入到H中;13.WHILEH不为空DO14.取H首元素h;15.IFmin_dist(e.MBR,h.MBR)>rTHEN//定理316.continue;17.ELSEIFmax_dist(e.MBR,h.MBR)rTHEN18.num←h.MNR内的数据点个数;19.FORPe中的每一个数据点pDO20.nn(p,r)+=num;21.IFnn(p,R)kTHEN22.23.24.ENDFOR25.ELSEIFh为叶子节点THEN26.FORPe中的每一个数据点pDO27.28.IFnn(p,R)kTHEN29.30.31.ENDFOR32.ELSE33.h的孩子节点加入H中;34.ENDIF35.ENDWHILE36.ENDIF37.Pe中剩余的数据点为局部离群点,输出;38.ENDFOR例3.在图6中,首先通过定理2进行过滤,判定可能存在离群点的MBR有e4、e7.对于e7,通过检索R树,发现e8与e7的最小距离大于r,因此e8内不存在e7内数据点的邻居.同时发现e6与e7的最大距离小于r,因此e6内的数据点均为e7内数据点的邻居.因此可以将e7内每个数据点的邻居数目加4.至此,可以断定e7内不存在离群点.对于e4亦采用类似地查找方法,最终得到离群点为p16、p17.记在块b中的局部离群点集合为Ob,正如在第1节中提到的,局部离群点不一定是全局离群点,需要与其他块进行通信才能确定最终结果.但由于本文采用了BDSP划分方式,可以在本地提前确定一部分结果,减少数据传输量.具体地:定理5.对于块b中的任意局部离群点p,如果i∈[0,d-1],p[i]-b.min[i]>r且b.max[i]-p[i]r,那么p必为全局离群点.证明.由于i∈[0,d-1],p[i]-b.min[i]>r且b.max[i]-p[i]r,那么p的所有邻居必然都存储在块b内.因此对于全集P,p的邻居数目仍然不大于k,因此p是全局离群点.在块b中,对于局部离群点集合Ob中任一数据点p,如果p满足定理5,那么该点必为全局离群点,可直接作为最终结果输出.如果p不满足定理5,那么称之为非确定离群点,并记块b中的所有非确定离群点集合为Ob.显然地,Ob中的任一数据点p,在与b相邻的其他块中,可能存在p的邻居,需要进一步与其他块进行网络通信,才能最终确定p是否为全局离群点.因此集合Ob作为最终结果的候选集,需要暂时保存.例如在图6中,根据定理5进行计算,p17为全局离群点,直接输出.而p16为非确定集群点,需要进一步的网络通信才能够判定,具体计算方法在5.2节中给出.5.2BOD算法-全局如5.1节所述,如果块b中存在非确定离群点,则b需要与其相邻的块进行网络通信.对于任意块b,根据4.1.2节中提供的方法,计算得到其相邻块的集合neig(b).一般情况下,对于b中的某个非确定离群点p,也仅需要与neig(b)中一部分块进行通信,就可以确定p是否为最终结果.为了准确地选择通信块,首先给出如下定义.定义5.点与块的最小距离[8].给定数据点p和块b,那么p与b的最小距离min_dist(p,b)=(z[i])槡∑i∈[0,d)z[i]=Page11显然地,对于neig(b)中的某个块b,依次判断b中的每一非确定离群点p,若满足min_dist(p,b)r,说明b中可能存在p的邻居,则将p加入到集合sendb→b中.最终将sendb→b中的所有点发送到块b所在的节点.在块b中,对于收到的sendb→b中的每一个数据点p,对R树索引进行以p为查询点,r为半径的范围查找,得到在块b中p的邻居数目并将该值返回给块b.最终,得到块b中每个非确定离群点的全局邻居数目,进而输出最终结果.算法4展示了具体计算过程.算法4.outlier_judgement().输入:块b中的非确定离群点集合集合Ob输出:Ob中的全局离群点1.FOR集合neig(b)中的每一个块bDO2.初始化集合sendb→b;3.FOROb中的每一个数据点pDO4.IFmin_dist(p,b)rTHEN5.sendb→b←p;6.ENDIF7.ENDFOR8.将sendb→b发送到b所在节点;9.ENDFOR10.FOROb中每个数据点pDO11.根据各块返回的结果,计算p的全局邻居数目12.IFnn(p,r)<kTHEN13.将p作为全局离群点输出;14.ENDIF15.ENDFORBOD算法复杂度分析:在算法3中(BOD算法-局部),对于一个包含s个数据点的块,首先遍历R树索引的叶子节点,对数据点进行批量过滤,复杂度为O(l)(l为R树叶子节点个数).记过滤后剩余数据点个数为s.对于每一个剩余的数据点,都需要利用R树索引找到它的本地邻居,以确定其是否为非确定离群点.该过程复杂度下界为Ω(k·d·s·log(s)),最差情况的复杂度为O(k·d·s·s).在算法4中(BOD算法-全局),记块内的非确定离群点数目为s.每个非确定离群点都需要在其他块内进行最多k次查找(找到k个邻居).因此,算法4的复杂度下界为Ω(k·d·s·log(s)),最差情况的复杂度为O(k·d·s·s).例4.图6描述了块bm内的数据点分布情况,经过计算得到非确定离群点p16.块bm在全域内的空间位置如图7所示,其相邻块为b1、b2、b3、b4、b5、b6.通过使用定义5,发现只有块b5内可能存在p16的邻居,因此将p16发送给块b5所在节点.接下来,对块b5的R树索引进行以p16为查询点,r为半径的范围查找,得到2个邻居pi、pj,则向bm返回数字2.在bm本地p16的邻居数目为0,因此p16在全局的邻居数目为2,小于k,则可以确定p16为离群点.6实验分析6.1真实数据的测试结果本小节主要使用真实数据集来测试本文提出的BOD算法性能.实验中使用的集群包括4个节点,每个节点的配置为IntelCorei321003.1GHzCPU,8GB内存,500GB硬盘,操作系统为RedHatLinux6.1.算法采用JAVA语言编写,JDK版本为1.7.0.数据集为UCI提供的森林覆盖数据(链接地址:http://archive.ics.uci.edu/ml/),共包括581012条数据,每条数据包括10维可度量属性,每维属性值被映射在0~100的范围内.实验中的对比算法为PENL算法[4],主要的衡量标准为查询处理时间和通信量(以网络间传输的数据点个数来度量).实验中并未测量2个算法的预处理时间(数据划分,索引的建立),主要是因为对于一个的数据集,预处理只需要进行一次,之后对于不同的查询都可以重复使用,因此这部分的时间消耗不需要计算.表3描述了相关的实验结果.行号1k=5,r=1322624132k=5,r=1421723053k=5,r=1520422594k=7,r=1521923125k=9,r=152302395Page12如表3所示,由于本文提出的BOD算法采用了BDSP数据划分算法和良好的索引策略,可以在较短时间内完成离群点检测任务.在网络通信方面,BOD算法仅仅需要传输局部的非确定离群点,大大地节省了网络开销.相比之下,PENL算法采用了基于数据量的划分方法和较为简单的Nested-Loop算法,对于任一计算节点上存储的数据集,都需要与所有其他节点上的数据集进行比较才能确定最终结果,需要将整个数据集在网络中传输多次,网络开销巨大,处理速度也较为缓慢.另一方面,通过对比表3中1~3行的实验结果,容易发现,随着查询半径r的增大,数据集中的离群点个数逐渐减少,BOD算法的处理时间和通信量都随之轻微减少.PENL算法在处理时间方面与BOD算法趋势相同,但通信量维持不变.这主要是因为PENL算法需要将所有计算节点上的数据集进行两两比较,网络传输量与计算节点数目和数据集规模有关,与查询无关.通过对比3~5行发现,随着查询阈值k的增大,离群点个数增多,导致BOD算法的处理时间和通信量都随之轻微增加.但无论参数如何变化,BOD算法相对于PENL算法一直保持明显优势.6.2人工合成数据的测试结果由于真实数据集规模有限,且无法变化数据维度等参数,因此本小节使用人工合成数据进一步地对算法性能进行测试.在6.2.1节中,首先验证了本文提出的BOD算法-局部部分(即算法3)在集中式环境下计算离群点的性能,并与传统集中式的离群点检测算法[3]进行对比.接下来在6.2.2节中,在分布式环境下对比了BOD算法与PENL算法的性能.所使用的合成数据集为聚簇分布数据,各维的取值范围为0~10000.具体生成方法如下:对于包含图8集中式算法中k的影响在图9中分别使用维度为3、5的数据集,测试了r值对于两种算法的查询处理时间以及访问R树节点的次数的影响,数据集规模为5×106.在图9α个数据点的数据集,随机生成α/1000个聚簇点,每个聚簇内平均包含1000个数据点.在每个聚簇内,数据点以聚簇点为中心呈高斯分布.实验相关变量的默认值和变化范围如表4所示.参数集群规模数据量数据维度6.2.1集中式算法性能对比在传统的基于R树索引的集中式离群点检测算法[3]中(实验中简称TRAD),对于每一个数据点p都需要对索引进行以r为半径的范围查询,造成对R树节点的频繁访问,导致大量的磁盘IO.而在本文的算法3中(实验中简称LOD),首先通过批量过滤,大幅减少了需要进行范围查找的数据点数目.然后以批量查询的方式代替了传统的逐个查询,显著地降低了磁盘IO次数并提高了算法性能.本小节针对集中式环境,详细对比了本文算法LOD与传统算法TRAD的性能.在图8中,分别使用规模为2.5×106、5×106的数据集,测试了k值对于两种算法的查询处理时间以及访问R树节点的次数的影响.在图8(a)中,随着k的增大,离群点数目增多,两种算法的处理时间都随之增加,但LOD的处理速度明显优于TRAD算法.此外,当数据集规模增大时,两种算法的处理时间也都随之增加.在图8(b)中,随着k的增加,两种算法访问R树节点的数目都随之增加.但是LOD采用批量处理的方式,相对于TRAD大幅减少了R树节点的访问次数,这也是本文算法处理速度更快的主要原因.(a)中,随着r的增大,对R树进行检索时的搜索范围变大,因此TRAD的处理时间轻微增加.而对于LOD算法,由于r值增加,同时导致了使用定理2Page13过滤掉的MBR数目更多,因此需要进行范围查找的数据点个数减少,因此整体的处理时间无明显变化.此外,当维度增大时,两种算法的处理时间也都随之增加.在图9(b)中,随着r的增加,LOD图9集中式算法中r的影响6.2.2分布式算法性能对比本小节主要在分布式环境下对比了BOD算法与PENL算法的性能.图10描述了集群规模对算法性能的影响.可以看出随着集群规模的扩大,集群的计算能力提高,BOD和PENL算法的处理时间都随之减少,说明两种算法都具有良好的性能加速比.另外在图10(b),节点个数的增加也导致了局部不确定离群点增多,因此BOD算法的通信量轻微增加.而对于PENL算法,更多的计算节点意味着每图10集群规模的影响图11数据量的影响在图12(a)中,测试了数据维度对处理时间的影响.随着维度的增加,计算两点距离、索引查找等操作都更加耗时,因此BOD和PENL算法的处理时间都明显增加.通过观察图12(b)发现,BOD算访问的R树节点数目无明显变化,TRAD的访问节点数目增加,所反映的趋势与图9(a)相同.当变化数据维度时,两种算法访问节点的数目无明显变化.个计算节点本地存储的数据更少,因此网络传输量也随之轻微增加.图11描述了数据量对算法性能的影响.随着数据量的增加,BOD和PENL算法都需要消耗更多的系统时间,也会产生更多的网络开销.但通过对比容易发现,BOD算法的处理时间明显低于PENL算法,且增长得较为缓慢.而PENL算法的处理时间的增长趋势明显较快.这也进一步说明了在处理大规模数据时BOD算法的优势.法的通信量对数据维度的变化并不敏感,变化十分轻微.PENL算法的通信量仅与计算节点数目和数据集规模有关,因此当变化维度时,传输量不变.当变化k,r值时亦然(图13(b)和图14(b)),具体原因Page14已在6.1节中阐述.容易发现,与许多相关研究[3,8]类似,本文的BOD算法性能受维度影响较为明显,存在一定的局限性.因此算法较为适合处理多维数据(维度一般不超过10),但无法很好地面对高维数据(几十维甚至上百维).这主要是因为算法使用了R树索引结构,当维度较高时,MBR之间重叠部分增多,导致查询效率明显降低.实际上,在处理高维数据时,绝大部图12维度的影响图13分布式算法中k的影响图14分布式算法中r的影响图15分布式算法中r、k的综合影响分空间索引的存储空间都很庞大,查询效率也不是很理想,可以考虑在预处理阶段使用文献[19]中提供的方法将数据降维,以提高计算效率.接下来,图13~图15测试了不同查询参数对算法性能的影响.在处理时间方面:随着阈值k的增加,更多的数据点成为离群点,因此两种算法的处理时间也随之增加.随着半径r的增加,更少的数据点成为离群点,处理时间轻微减少.在传输量方面:Page15PENL算法的传输量并不受k,r值的影响.对于BOD算法,k的增加会导致更多的非确定离群点,因此传输量增加,而半径r的增加会降低非确定离群点的数目,因此传输量轻微减少.通过上述多种不同的实验测试,验证了本文的提出的BOD算法的优秀性能.BOD算法与现有的PENL算法相比,具有明显优势.7结论本文研究了分布式环境下的离群点检测问题.首先,提出了一种新型的基于空间的数据划分算法:BDSP.该算法可以平均化每个节点上的工作负载并具备良好的过滤效果.然后,为BSDP划分得到的块设计了一种全新的块编码规则,利用该规则可以快速地确定块与块之间的相邻关系,节省网络开销.接着,基于BDSP划分算法,提出了BOD算法,该算法包括2个步骤:在每个计算节点本地,该算法使用R树索引进行批量过滤,快速地计算出本地离群点并得到候选集;进一步地,使用BDSP中提供的块编码规则,确定需要通信的相邻块,并计算出最终结果.最后通过大量实验说明了本文所提出的BDSP和BOD算法的正确性和有效性.
