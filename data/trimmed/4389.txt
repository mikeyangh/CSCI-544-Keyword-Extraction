Page1PN4TS:一种基于CPN模型的IOCO测试选择方法刘靖1)李茹1)叶新铭1)李军2)1)(内蒙古大学计算机学院呼和浩特010021)2)(中国科学院计算技术研究所北京100190)摘要文中将IOCO(Input-OutputConformance)一致性测试理论与着色Petri网(ColoredPetriNets,CPN)进行优势融合,提出一种使用CPN描述测试目的模型并驱动IOCO一致性测试选择的新方法,称为PN4TS方法.PN4TS方法首先定义了面向一致性测试的CPN模型(ConformanceTestingorientedCPN,CT-CPN),描述软件系统的功能行为;定义了基于CT-CPN描述的PN-IOCO一致性关系;之后,构建CT-CPN描述的测试目的模型,并将该模型与描述软件功能行为的CT-CPN模型执行同步模拟,提出了一种测试目的模型驱动的IOCO一致性测试选择方法,并证明了所生成测试例的可靠性及其对测试目的的覆盖完备性.PN4TS方法以实际测试数据驱动测试例的生成过程,有效保证了经测试目的选择所生成的测试例是切实可执行的.文中使用简单文件传输协议例示了PN4TS方法的应用过程,之后结合数字内容点对点网络分发软件系统的实际测试生成和测试执行实践,证实了PN4TS方法应用于较大规模软件系统的一致性测试应用时具有更好的可用性和可靠性.关键词测试选择;测试目的;IOCO一致性;着色Petri网;同步模拟执行1引言软件一致性测试(ConformanceTesting)[1]用以确认被测软件实现(Implementation)是否符合软件功能说明(Specification)的要求,发现被测软件实现中存在的与软件功能说明不一致的错误或缺陷,提高软件系统的研发质量.其中,测试生成与选择、测试执行与一致性结果判定是一致性测试的两个基本过程.已有相关研究与实践更多偏重于提高一致性测试执行的自动化程度和可靠性,如TTCN-3等测试方法及软件的广泛应用,但测试例在很大程度上仍依靠手工生成,很难保证一致性测试过程的完备、规范和可靠[2-3].近年来,软件测试的相关研究中,基于模型的一致性测试方法(ModelBasedConformanceTesting,MBCT)以有效融合形式化方法与传统测试技术而引起学术界和业界的重点关注与推进[4-6],其优势在于以准确描述软件行为的形式化或半形式化模型为基础,自动生成大量可靠的测试例,改善测试例手工生成方式的缺陷与低效,能够与自动化程度较高的测试执行过程形成良好衔接,进一步增强软件系统错误的检测能力.基于IOCO(Input-OutputConformance)一致性关系的测试方法[3]是目前MBCT的主流方法之一,具备坚实的理论基础[7]和成功实践应用[8-9].这类方法通常基于LTS(LabeledTransitionSystem)模型,在IOCO关系[7]的指导下生成大量可靠的一致性测试例,用以判定被测软件实现是否一致于软件功能说明.此外,与有限状态机、LTS、进程代数等常用的软件形式建模方法相比较,着色Petri网(ColoredPetriNets,CPN)[10]能够更加直观、准确地刻画复杂软件系统的交互式及并发行为,且CPN在系统层次建模、复杂数据处理、模型分析与动态模拟执行等方面也更具优势,更易于对作为MBCT基础的软件形式模型的正确性进行有效确认[11].更重要的是,CPN模型的动态模拟是一种以实际数据驱动模型控制流与数据流的协同执行过程,基于这种模拟执行能够生成大量实际可执行的一致性测试例.本文面向网络环境中具有多交互、高并发特性的软件系统的一致性测试应用,研究IOCO测试理论与CPN建模进行优势融合的方式,旨在构建使用CPN描述测试目的模型并驱动IOCO一致性测试选择生成的新方法,称为PN4TS方法,保证测试例的实际可执行性,提高基于CPN模型实施一致性测试的自动化程度与应用能力.图1给出PN4TS方法的4个关联组成部分:(1)提出面向一致性测试的CPN(ConformanceTestingorientedCPN,CT-CPN)模型,用于为软件系统功能进行形式建模;(2)以CT-CPN模型为基础,定义PN-IOCO一致性关系,用于形式描述“软件实现与软件功能说明相一致”的确切涵义;(3)构建描述具体测试目的的CT-CPN模型,并在PN-IOCO一致性关系的指导下,对软件功能描述模型和测试目的模型执行同步模拟,生成满足该测试目的、并使用CT-CPN描述的一致性测试例;(4)证明测试生成的可靠性(Soundness)以及对测试目的覆盖完备性(TestPurposeCoverageCompleteness).本文以简单文件传输协议和实际的数字内容点对点网络分发软件为例,阐述PN4TS方法的应用过程、可用性与有效性.PN4TS方法的优势主要体现在:(1)基于CPN模型的动态模拟过程,充分考虑系统控制流和数据流的协同执行,以实际测试数据驱动测试例的选择性生成,有效地保证了测试例的可执行性与可靠性;(2)在PN-IOCO一致性关系定义中,只有实际测试输出与测试例中描述的预期测试输出(TestOracle)相同时,才会判定被测系统实现一致于软件功能说明,故行为正确但功能不完整的被测实现将被判定为与软件功能说明不一致,加强了对这种缺陷软件的错误检测能力;(3)与已有基于遍历模型状态空间或基于LTS模型同步积来生成测试用例[3]的方法相比,本文利用CT-CPN模型间的同步模拟执行来生成测试例,并不受控于软件系统模型的规模大小,具备更好的可用性,能够有效处理较大规模软件的功能一致性测试应用.2相关工作基于CPN模型进行软件功能一致性测试的典Page3型研究中,Watanabe与Kudoh[12]首先提出了一种最朴素的方法,即直接生成系统模型的状态可达树,基于树的遍历实现测试序列的提取;继而合并等价状态节点构建状态可达图,并按照基于FSM模型的测试生成方法构造测试例.近来,Wu等人[13]和Xu和Chu等人[14]也利用模型可达图中的可达路径简单抽取出测试序列构成测试例模型.此外,Farooq等人[15]首先给出顺序覆盖标准(分支覆盖、边覆盖等)和并发覆盖标准(结点或边的交叠覆盖等),并利用随机漫步(RandomWalk)算法对系统CPN模型的状态空间进行多次搜索,直至已生成的测试例集合符合预期覆盖标准.Zhang等人[16]利用CPN建模工具支持的模型检测技术完成基于状态空间生成反例来构建测试例.Yu等人[17]提出了一种CPN模型支持的虚拟测试模拟执行环境,能够在没有实际测试环境部署的条件下完成软件系统测试,并未描述测试生成过程.Zhu和He[18]对面向高级Petri网的测试可观察模式与相应覆盖标准进行了更充分的论述,但同样并未给出具体测试生成方法.为使一致性测试能够在有限时间和条件约束下顺利实施,通常将特定的测试选择标准集成到测试例生成过程中,以生成可用于实际测试的有限个测试例.常见的测试选择方法包括基于测试目的的选择[9,19-22]、随机选择[8,23-24]、基于属性覆盖的选择[25-26]、符号化的数据选择[27]等.其中,基于测试目的(TestPurpose)的选择方法通常将部分系统行为描述为一种测试目的,并使所生成的测试例重点对这部分功能进行一致性测试,满足本文对具有黑盒性质的网络软件系统的功能一致性测试需求.总体而言,基于CPN模型生成测试例的相关方法较少,且普遍面向系统内部行为可知的应用,采用完全遍历或随机遍历模型状态空间来生成测试例.而本文所提PN4TS方法以IOCO测试理论为指导,对分别描述软件功能行为与特定测试目的的两个CT-CPN模型执行同步模拟,实现有效的测试例选择性生成.本方法充分考虑测试过程中系统外部行为的可观察特性以增强测试例对实际测试过程描述的准确性;利用CPN模型的动态模拟功能简化测试例的选择性生成,强化测试例的可执行性;通过证明测试例的可靠性及对测试目的的覆盖完备性,说明通过执行测试例来判定软件被测实现与软件功能说明之间的一致性是可靠的.3软件系统的CT-CPN建模(CPN,PS,TS):定义1.CT-CPNS模型定义为CT-CPNS=(1)CPN是一个基本CPN,P为位置集,T为(2)PS=P且PS=PO变迁集;集合,PE集为空;(3)TS=T且TS=TI迁集合,TO且各变迁集合彼此间交集为空;(4)CT-CPNS输出有限,即狋狉犪犮犲(M0)n(n∈N);(5)CT-CPNS中不存在内部行为构成的环结构,即M:MσM,σ∈BE(TE(说明:本文涉及CPN模型中的标识可达、点火路径、可达状态等概念的形式定义参考文献[10]).定义1将描述软件功能说明的CT-CPN模型定义为CT-CPNS.其中,依照一致性测试的需求,首先将软件运行状态(对应于CPN模型中的位置元素)区分为可观察状态和内部状态:可观察状态描述被测系统进行测试输入、或被测系统呈现可观察的测试输出的状态;而内部状态则描述被测系统内部运行、外部无法观察到的系统运行态.同时,将软件行为(对应于CPN模型中的变迁元素)区分为输入行为、输出行为和内部行为:输入行为描述测试者向被测系统提供输入;输出行为描述被测系统产生测试者可观察的输出;而内部行为描述被测系统内部执行、测试者不可观察的行为.在构建一个具体软件系统的CT-CPNS模型时,需要多次对该模型执行动态模拟(Simulation),修正不精确的模型元素,并避免出现如下两种情况:对给定输入不能产生无限可能的输出,否则实际测试中将无法在有限时间内给出确定的测试结论;模型中不能包含内部行为构成的环结构,否则被测系统无输出响应时,很难断定系统是处于死锁状态或其他不可知状态.下文以简单文件传输协议(简记为SFTP)为例,给出其CT-CPNS模型,如图2所示.SFTP中具有相同功能的不同对等结点(Peers)之间能够通过网络共享同一个资源文件(该文件由若干文件片段[SN,DATA]组成).结点接收到一个片段请Page4求(req)时,按所请求的片段序号(SN)检索自身已有片段集合(DATASET),并将匹配的片段(DATAENTRY)发送给请求结点;结点接收到所请求的片段(rep)时,先将其存储至已有片段集合并发起针对未有片段的新请求.该模型中,rv/sd/set为可观察位置;recv为输入变迁,描述报文的接收,图2简单文件传输协议中对等结点的CT-CPNS模型在进行CT-CPNS建模时,需要结合系统的功能行为,及实际测试执行所设置的外部控制观察点[1](PointsofControlandObservation)来共同选择可观察位置进行标识,通常将其作为输入变迁的前集或输出变迁的后集,便于通过可观察位置上的token数据变化来判定其关联变迁是否正确点火执行.特别地,图2中的位置set上的token数据能够反映对等实体中已存文件片段是否更新,故可作为一种测试判定标准将其建模为可观察位置.4PN-IOCO一致性关系根据基本IOCO一致性关系的定义[7],本文将基于CT-CPN模型的IOCO一致性关系定义如下.定义2.PN-IOCO定义为ss∈CT-CPNS与ii∈CT-CPNI之间的一种实现关系(ImplementationRelation):ii犘犖-犐犗犆犗ss=defσ∈犛犘狋狉犪犮犲(MS):狋狅犽犲狀狊(MI犳犻狉犲狊σ)=狋狅犽犲狀狊(MS犳犻狉犲狊σ),其中M犳犻狉犲狊σ=def{Mn|MσMn,σ∈BE(T)}(1)MS是模型ss对应的初始标识;MI是模型ii对应的初始标识;犛犘狋狉犪犮犲(MS)给出了模型ss中所有可行的行为执行路径,并以此约束测试例的生成范围;(2)狋狅犽犲狀狊(M)=def{M(P)|P∈PO了标识M下可被观察到的输出数据:在模型ss中,对应于可观察位置上的token数据,而在模型ii中,并触发协议后续行为的执行;send/store/newreq为输出变迁,描述已存片段的发送、接收片段的存储和新片段的请求,标志之前的内部行为执行已完成;其余为内部位置和内部变迁.特别地,位置sp中预存了片段序号的全集,用于辅助判定需要请求哪个新的文件片段.对应于实际观察到的输出结果.需要特别说明:首先,软件实现通常是物理存在的软件或软硬件协同系统,其内部行为并不完全可知,为此,IOCO一致性测试理论假设每一个被测系统实现都存在一个与之对应的形式模型,可以通过外部行为特征对其进行描述,但无法显式构建[6],故使用CT-CPNI来描述被测实现的形式模型.其次,PSPI且TSTI成立,即ii模型也是通过变迁点火执行来反映系统真实的执行过程,且模型ss中定义的可观察位置集及输入输出变迁集都可以对应到模型ii中.此外,在PN-IOCO定义中,要求狋狅犽犲狀狊数据必须相同,即只有观察到的实际测试输出与预期定义好的测试输出标准完全相同时,才会判定软件实现一致于软件功能模型.与基本IOCO一致性关系相比,行为正确但功能不完整的那些软件实现将被判定为与软件规范说明不一致.因此,PN-IO-CO一致性关系指导下的一致性测试过程可以有效增强对存在功能缺陷的被测系统的检测能力.PN-IOCO一致性关系明确定义了如何判定被测软件实现与软件功能说明之间的一致性关系:给定模型ss的初始标识赋值,可生成若干可执行路径σ,以此为基础构成测试例集合TS.假设存在t∈TS,测试执行时,将t中描述的输入行为逐一实施于被测系统,并观察其实际输出,如果所有实际输出与ss模型中对应可观察位置上预期输出的token数据都相同,则认为测试例t执行通过,即ii狆犪狊狊t;否则,一旦出现实际输出与预期输出不相同,则认为测Page5试例t执行失败,即ii犳犪犻犾t.由定义2可知,如果被测软件实现能够通过基于模型ss所生成的测试例全集TS,则可判定该被测实现与模型ss所描述的软件系统规范说明是一致的.5测试目的模型驱动的测试选择本文基于测试目的进行有选择的测试生成:将描述系统特定的、部分功能的测试目的建模为一种CT-CPN模型,并通过该模型与描述软件功能说明的CT-CPNS模型的同步模拟执行,约束SPtrace集合中可执行路径的构造过程,使所生成的测试例能够针对测试目的所描述的特定系统功能完成一致性测试,并且具有良好的可执行性和可靠性.5.1基于CT-CPN模型的测试目的建模测试目的通常针对软件系统中特定的部分功能行为进行描述,例如在网络软件中,请求报文的发送、数据报文的接收、关键数据结构的更新操作等都可以作为一种测试目的,以约束测试例的生成范围,使通过约束所生成的这些测试例能够重点针对测试目的覆盖的那些软件功能行为进行一致性测试,对规模较大的软件系统便于更有针对性和可操作性的测试执行.CT-CPNTP模型的构建显然需要以CT-CPNS为基础,因为测试目的仅仅用于刻画完整系统行为中一部分具体的、希望重点测试的执行过程,所以本文将以CT-CPNS为基础构建描述测试目的CT-CPNTP模型.定位置;(CT-CPNS,PTP,ΣTP):定义3.测试目的模型定义为CT-CPNTP=(1)CT-CPNS是一个CT-CPNS模型;(2)PTP=PS∪{ph}:位置元素ph称为覆盖判(3)ΣTP=ΣS∪{犮狅狏犲狉犲犱}.在CT-CPNTP模型中,ph通常作为一个输出变迁的后集,是模型的终止位置,且其上只能允许出现值为犮狅狏犲狉犲犱的token数据.具体而言,若ph位置上生成了值为犮狅狏犲狉犲犱的token数据,说明从初始标识开始,模型执行所产生的点火路径恰对应于测试目的描述的功能行为执行,而约束这种行为的发生条件是通过为该路径中所有点火变迁添加必要的防卫表达式来实现的.图3给出了一个针对简单文件传输协议的CT-CPNTP模型示例.该测试目的关注于对等实体接收到文件片段请求后(通过防卫表达式[(#1p)=req]来约束),能否通过片段号的匹配(通过防卫表达式[n=(#1en)来约束]),将所请求的片段从已有片段集合中检索出来.如果ph位置上产生值为犮狅狏犲狉犲犱的token数据,则说明点火路径正确描述了上述测试目的的行为执行.图3简单文件传输协议的第1个CT-CPNTP模型5.2基于模型同步模拟执行的测试例生成构建测试目的驱动的一致性测试生成方法,必然要同时考虑软件功能CT-CPNS模型和测试目的CT-CPNTP模型的模拟执行,这是因为CT-CPNS模型的执行反映了系统行为的具体发生过程,包括每一步实际输入及输出,这是测试例生成的基础依据;而CT-CPNTP模型的执行能够指导系统行为发生路径的选择,确保将所生成的测试例约束在测试目的所关注的一些特定的行为执行过程,而对其他执行过程不再深入考虑.因此,需要对上述两种模型执行同步模拟,生成覆盖测试目的的测试例,并使用CT-CPNTC加以描述.以PN-IOCO一致性关系为指导,基于测试目的进行有选择的测试生成时完成两方面工作:约束SPtrace集合中可执行路径的构造过程,使所生成的测试例覆盖测试目的所描述的路径;对所有可观察输出不但要进行正确性判定,还要明确标识其是否覆盖了测试目的.具体而言,给定CT-CPNS模型的初始标识MS及一个测试目的CT-CPNTP模型的初始标识MTP之后,基于这两个模型中可激活绑定元素的不断同步点火,驱动测试例的选择性生成,而同步点火按如下规则执行:规则1.输入行为的同步点火规则.若t∈TIBETP均可激活,则生成t∈TIp∈pre(t)}:p∈PI构造新的内部位置p∈PE(t,bS)与(t,bTP)执行,且M(p)={M|M(p)(t,bS→)},完成一次输入行为的同步执行.规则2.内部行为的同步点火规则.若t∈TEBETP均可激活,且若点火执行后可生成相同的token,Page6则将(t,bS)与(t,bTP)点火,完成一次内部行为的同步执行;否则,单独多次点火(t,bS),直到t∈TE完成内部行为同步执行前,被测实现需要先执行若干内部行为,直到测试目的所约束那些同步行为可激活并执行(鉴于内部变迁的点火反映了系统内部行为的发生,所以并不需要描述在测试例模型中).规则3.输出行为的同步点火规则.若t∈TO(3)将t∈TO(2)生成a∈(tv,pv),r=pre(tv)(r∈POBETP均可激活,则生成t∈TOpost(t)}:p∈PO需要构造新的内部位置p∈PE(t,bS)与(t,bTP)执行,完成一次输出行为的同步执行,并为每一个p∈PO(1)生成q∈PTOp∪q}∧{post(tv)=pv},且M(q)=M(p);其中,M(q)上的token记录可观察位置p的预期输出;可一般性的描述为ifM(r)=M(q)then1pass++1coveredelse1fail,即如果实际输出M(r)与预期输出M(q)相同(此时测试目的已确定被覆盖),则测试结果指示位置pv中将同时生成值为pass与covered的token数据;置或可观察位置关联,即r∈PE保持测试例模型的连通;同时删除冗余的内部位置.在实际输入数据的驱动下执行上述规则可逐步产生CT-CPNTC测试例模型.由于CT-CPNTP是以对应系统的CT-CPNS为基础而构建的,描述其部分行为执行,因此不会发生CT-CPNTP中的绑定元素可点火执行而CT-CPNS中的对应绑定元素不可被激活的情况,保证上述规则的可行性.下面给出CT-CPNTC的形式定义.定义4.CT-CPNTC模型定义为CT-CPNTC=(1)CPN是一个基本CPN,P为位置集,T为(2)PTC=P,PTC=PITC为输入位置集合,标识测试输入数据;POTC:PIPE为可观察位置集合,标识可观察的实际输出数据;TC为预期结果指示(TestOracle)位置集合,标识PTO对应可观察位置上预期应产生的正确输出结果;TC为测试结果指示位置集合,标识测试判定结果,PV只允许pass/fail/covered三种token数据:fail表示执行失败,只存在pass表示执行通过,pass与(CPN,PTC,TTC):变迁集;(3)TTC=T,TTC=TI入变迁集合,描述测试输入的提供;TO集合,描述测试输出结果的呈现;TV迁集合,判断实际输出是否与预期输出相同,并产生测试判定结果;各变迁集合彼此间交集为空;covered同时存在表示覆盖了测试目的的测试执行成功通过;PE态;各位置集合彼此间交集为空;(4)CT-CPNTC是行为有限的,即n∈N,σ∈trace(CT-CPNTC):|σ|<n.以简单文件传输协议为例,将图2给出的系统CT-CPNS和图3给出的测试目的CT-CPNTP同步模拟执行,可生成图4所示的CT-CPNTC测试例模型,用于测试CT-CPNTP模型描述的那些软件行为是否被正确实现.测试例模型的具体生成过程如下:图4简单文件传输协议的第1个CT-CPNTC模型(1)设置MS与MTP:MS(rv)={1(req,2,“”)},MS(set)={[(1,“one”),(2,“two”)]},MS(ssn)={[1,2]},MS(sp)={[1,2,3,4]};MTP(rv)={1(req,2,“”)},MTP(set)={[(2,“two”)]};(2)应用规则1处理输入变迁recv:将关联的绑定元素(recv,{p=(req,2,“”)})执行同步模拟,生成测试例模型中的输入位置rv与输入变迁recv,并添加内部位置sn作为recv的后集,且MTC(rv)={1(req,2,“”)};(3)应用规则2处理内部变迁search:在CT-CPNS模型中,该变迁先后关联了绑定元素(search,{n=2,ds=[(1,“one”),(2,“two”)]})和(search,{n=2,ds=[(2,“two”),(1,“one”)]}),而在CT-CPNTP模型中,该变迁只与绑定元素(search,{n=2,en=(2,“two”)})相关联,因此,CT-CPNS模型中的search变迁被点火执行两次,第1次是独立执行,第2次与CT-PNTP模型同步模拟执行,且MS(nd)=MTP(nd)={(2,“two”)};(4)应用规则3处理输出变迁send:将绑定元素(send,{n=2,d=“two”})和(send,{en=(2,“two”)})执行同步模拟,得到MS(sd)={(rep,2,“two”)},MTP(ph)={covered},标志着测试目的覆Page7盖的行为路径正常执行.在测试例模型中生成输出变迁send及可观察位置ar,并为ar构建由预期结果指示位置rr、测试判定变迁vt及测试结果指示位置vd构成的测试判定单元,且MTC(rr)=MS(sd)={(rep,2,“two”)},测试判定变迁vt的输出弧表达式清楚地描述了测试判定标准,即如果在实际测试过程中观察到了报文(rep,2,“two”)的产生,则说明被测系统在执行测试目的所约束的行为路径时,符合系统功能模型的预期定义;最后,将测试例模型中的输出变迁send与内部位置sn关联,即pre(send)=sn,保证了模型的连通.由此可知,PN4TS方法以实际测试数据驱动测试例的选择性生成,充分保证测试例的可执行性;CT-CPNTC模型准确、清晰地描述了测试流程及测试判定标准,能够直观、有效地指导实际测试执行.5.3测试生成的可靠性和覆盖完备性证明定理1.给定ss∈CT-CPNS,tp∈CT-CPNTP,将通过PN4TS方法生成的测试例全集记为TS,即存在测试选择函数TestSel:CT-CPNS×CT-CPNTP→CT-CPNTC,满足TestSel(ss,tp)TS,则TestSel对PN-IOCO是可靠的.证明.采用反证法进行定理1的证明.设ss对应的任一个被测实现为ii∈CT-CPNI,假设存在测试例tt∈TestGen(s),使得not(ii狆犪狊狊tt)且ii犘犖-犐犗犆犗ss,即被测实现ii一致于软件功能模型ss,但却未能通过由TestSel方法生成的一个测试例tt.那么:not(ii狆犪狊狊tt)p∈PVr∈POσ∈SPtrace(MS):tokens(MIfiresσ)≠tokens(MSfiresσ),M(r)(MIfiresσ),M(q)(MSfiresσ)[存在一条路径σ,在其点火执行过程中,位置r上的实际输出不同于预期结果指示位置q上的数据]该结论与ii犘犖-犐犗犆犗ss假设出现矛盾,故如果存在未通过的测试例,则被测软件系统一定存在和软件功能模型不一致的错误或缺陷,即通过执行TestSel所生成的测试例来判定一致性是可靠的.定理2.给定ss∈CT-CPNS,tp∈CT-CPNTP,将通过PN4TS方法生成的测试例全集记为TS,即存在测试选择函数TestSel:CT-CPNS×CT-CPNTP→CT-CPNTC,满足TestSel(ss,tp)TS,则TestSel对tp的覆盖是完备的.CT-CPNI:ii犮狅狏犲狉-狆犪狊狊tt=def证明.设ss对应的任意被测系统实现为ii∈ii狆犪狊狊tt∧p∈PVp∈PVσ∈SPtrace(MS‖MTP):tokens(MTPfiresσ)tokens(MSfiresσ)∧tokens(MSfiresσ)=tokens(MIfiresσ)[对CT-CPNTP与CT-CPNS同步模拟执行所生成的任意执行路径σ,实际输出与预期输出结果相同]σ∈SPtrace(MTP):tokens(MTPfiresσ)tokens(MIfiresσ)[被测系统覆盖了测试目的描述的系统行为]证毕.综上证明,通过PN4TS方法生成的测试例是可靠的,并且对具体测试目的的覆盖是完备的.具体而言,在实际测试执行时,如果一个测试例的执行失败,不管其是否覆盖了测试目的,都说明被测软件存在与软件功能说明不一致的错误或缺陷;相反地,如果测试例成功执行,虽然不能给出被测软件实现一致于软件功能说明的结论,却可以保证这样的测试执行是针对测试目的所描述的系统行为的,增强了测试者对“测试目的所覆盖的软件功能在被测软件中被正确实现”的判断.6实例分析上文使用简单文件传输协议例示了PN4TS方法的应用过程,重点步骤包括协议的CT-CPNS建模(如图2)、测试目的的CT-CPNTP建模(如图3)、基于这两个模型的同步模拟执行生成可执行测试例CT-CPNTC模型(如图4).本节首先给出简单文件传输协议的实际测试执行过程,以此证实PN4TS方法的有效性,即所生成的测试例具有预期良好的错误检测能力.之后,结合数字内容点对点网络分发软件(简记为DCP2ND)的实际测试选择和测试执行实践,说明PN4TS方法在处理较大规模软件系统的一致性测试应用时,同样具有较好的可用性及有效性.最后小结PN4TS方法的实际应用方式.6.1简单文件传输协议的测试执行SFTP系统的主要功能包括:(1)对等实体接收到片段请求后,按所请求片段的序号在已有片段集合中检索,并将匹配的文件片段传输给请求方;(2)对等实体接收到所请求的片段时,先将其存储Page8至已有片段集合中,并查询未有片段序号后对其发起新的片段请求.图3所示的CT-CPNTP模型和图4所示的CT-CPNTC模型关注于上述第1个功能的一致性测试.下面将针对上述第2个功能进行测试生成.首先,构建如图5所示的CT-CPNTP模型,描述了第2个功能对应的软件行为,其中,对等实体接收到所请求片段的行为由防卫表达式[(#1p)=rep]来约束,而对未有片段发起新请求的行为由防卫表达式[not(List.null(listsubss2ss1))]来约束(该表达式描述了还存在需要请求的片段集).图5简单文件传输协议的第2个CT-CPNTP模型将图2给出的CT-CPNS和图5给出的CT-CPNTP执行同步模拟,生成图6所示的CT-CPNTC测试例模型,用于针对第2个功能的一致性测试.具体生成测试例时,首先设置MS与MTP:MS(rv)={1(rep,2,“two”)},MS(set)={[(1,“one”)]},MS(ssn)={[1]},MS(sp)={[1,2,3,4]};MTP(rv)={1(rep,2,“two”)},MTP(set)={[(1,“one”)]}.之后,分别应用规则1处理输入变迁recv,应用规则3处理输出变迁store和newreq即可,具体过程不再赘述.可以看到,预期结果指示位置MTC(rset)={[(1,“one”),(2,“two”)]},且MTC(rsd)={1(req,3,“”)},标志着对等实体应该接收到所请求片段(2,“two”),并生成对3号片段的新请求报文(req,3,“”),作为TestOracle指导测试执行.图6简单文件传输协议的第2个CT-CPNTC模型SFTP系统的测试执行过程为:首先,利用错误注入(ErrorInjection)的方法,实现了5个含有已知代码错误、2个功能不完整、1个功能完整且正确的SFTP软件,都作为被测系统实现(SystemUnderTesting),具体描述见表1.之后,对各版本的被测实现,按照图4和图6给出的测试例模型(对应表1中的tc1和tc2)完成一致性测试执行,若其能够检测出被测系统实现中注入的错误或缺陷,则说明利用PN4TS方法执行一致性测试是可靠的.表1SFTP系统的被测实现及测试结果描述被测协议实现:i1完全正确正确实现了所有的协议功能i2错误不能正确发送被请求的片段i3错误依序号检索片段时,不能正确匹配i4错误不能正确存储接收到的片段i5错误不能正确计算需要请求哪个新片段i6错误不能正确解析接收到的各类报文i7部分正确片段检索功能未实现i8部分正确片段存储功能未实现测试结果:tc1狆犪狊狊failfail狆犪狊狊狆犪狊狊failfail狆犪狊狊tc2狆犪狊狊狆犪狊狊狆犪狊狊failfailfail狆犪狊狊fail分析表1给出的测试结果:i1通过所有测试;i2和i3未能通过tc1的测试但通过了tc2的测试,原因在于i2和i3中的实现错误被tc1所描述的测试执行路径所覆盖(导致测试结果指示位置vd上生成了值为fail的token数据),而未被tc2所描述的测试执行路径所覆盖.同理,i4和i5未能通过tc2的测试但通过了tc1的测试.i6未通过所有的测试,是因为其存在的实现错误同时被tc1和tc2所描述的测试执行路径所覆盖.i7不支持在已有片段集合中按序号进行片段检索的功能,所以在实际测试中并未观察到预期报文的产生,而导致tc1测试失败,但tc2并未测试这个功能,故tc2测试通过.同理,i8导致tc2测试失败,但tc1测试通过.这样,综合tc1和tc2的测试结果,我们判定除被测系统i1外,其他协议实现均与协议功能模型不一致.综上分析,利用PN4TS方法生成的测试例不但能够检测出被测系统中的实现错误,还能检测出那些行为正确但功能不完整的缺陷系统,证实了PN4TS方法的有效性和优势所在,且利用该方法执行软件系统的功能一致性测试会更加可靠.6.2DCP2ND系统的测试生成及测试执行本节以作者所在课题组研发的DCP2ND软件系统为实践对象,利用PN4TS方法完成该系统的一致性测试实践,用以检测该软件系统设计和实现中存在的错误和缺陷,但更重要是为了验证PN4TS方法在处理较大规模软件系统的一致性测试应用时Page9的可用性,说明利用PN4TS方法执行较大规模软件系统的一致性测试同样是可靠的.DCP2ND软件系统遵照BitTorrent协议[28]实现数字内容在互联网中的快速分发和共享.BitTorrent协议以其易部署、强容错、高分发效率等优势成为大量P2P(Peer-to-Peer)应用所采用的主流协议.Bit-Torrent协议包括三类结点:下载者(Leecher)、种子结点(Seed)和索引服务器(Tracker),协议将共享的资源文件切分为等长的片段(Piece)进行分发,每个结点从其他结点下载片段的同时也为别人提供片段的上传.协议基本工作流程为:首先,下载者与索引服务器交互,获取可提供所需片段的种子或其他下载者列表及各结点的索引信息,如结点标识、IP和端口等;之后,该下载者按一定的片段选择算法选择其中部分结点进行握手连接,并通过交换位图(bitmap)获知其拥有的片段信息;最后,向成功建立连接的各结点逐片请求并传输片段数据,可运行阻塞(choking)算法提高传输性能和公平性.在成功下载一个片段后要告知所连接的邻居结点,而当整个文件下载完成时,该下载者变为种子结点,并继续为其他下载者提供片段的上传.这种对等结点间的共享行为充分利用网络带宽和结点能力加速了文件下载和资源共享.在DCP2ND软件系统实现中,同样包含下载者、种子结点和索引服务器三种实体结点,并按上述BitTorrent协议的基本工作流程实现文件共享.本节设置DCP2ND软件系统的运行场景如下:新加入的Leecher结点L1~L2与已存在的Leecher结点L3~L8,以及Seed结点之间共享单一文件的10个piece片段(p1~p10).其中,Seed拥有全部片段,L3~L8各自已有部分片段,但片段p10仍仅种子结点才有.这样,L1从种子结点下载片段p10(最少优先的片段选择)后,L1和L2将从Seed或其他下载者结点下载全部片段;而L3~L8也从Seed或其他下载者结点下载所缺的片段,直至所有下载者结点都变为种子.上述场景设置已涵盖了DCP2ND软件系统的所有主要功能,可以作为对其进行功能一致性测试的应用场景.际的测试生成及测试执行,具体步骤概述如下.步骤1.生成描述该软件功能行为的CT-CPNS层次模型,包括15个CPN模块,分别描述了整体运行结构(Top),3种实体结点的行为执行总体流程(Tracker/Seed/Leecher)、实体间通信报文处理行利用PN4TS方法对DCP2ND软件系统执行实为(S_send/S_reveive/L_send/L_receive)和实体内部的具体功能事务处理(详见表2中的模块描述).作为例示,图7给出了描述下载者结点行为执行整体流程的CT-CPNS模块Leecher,即描述了请求可用节点列表及解析、与种子节点或其他下载者间请求和收发文件片段等功能间的关联关系.表2DCP2ND软件CT-CPNS层次模型中的模块描述TopTracker索引服务器行为执行总体流程Generatelist生成下载者请求的可用结点列表SeedS_send根据握手协议处理下载者的连接请求S_receive接收并处理下载者的片段请求s_sendpk发送下载者请求的片段s_choking种子结点执行choking算法Leecher下载者结点行为执行总体流程L_send与其他下载者握手连接并发送位图L_receive接收到不同类型报文时分派处理l_reqhandle解析位图并触发未有片段请求l_sendpk接收其他结点片段请求并发送该片段l_havepk接收所请求的片段并触发新片段请求l_choking下载者结点执行choking算法结点的连接参数片段信息消息(如:向L4随机请求一个文件片段)p10)有片段信息的数据结构序号tp1L1对索引服务器发来的可用结点列表进行解析,获得可用tp2L1接收位图报文(L3发送的),解析该报文获得L3的已有tp3L1向L3发送interested消息,并接收L3返回的unchokingtp4L1与已连接的下载者执行随机第一片的片段选择算法tp5L1执行最少优先的片段选择算法(向Seed请求文件片段tp6L1接收含片段p10的数据报文(Seed发送的),更新存储已tp7L1生成片段p5的请求报文并向L5发送tp8L1接收含片段p5的数据报文(L5发送的),更新存储已有片段信息的数据结构,继续生成对片段p6的请求报文tp9L1接收片段p10的请求报文(L2发送的),检索已有片段信息,并为p10片段生成数据响应报文步骤2.以软件CT-CPNS层次模型为基础,可生成若干典型CT-CPNTP模型,如表3所述,描述希望被实际测试的软件主要功能行为.作为例示,图8给出了tp9的CT-CPNTP模型,其中storemsg变迁的防卫表达式[mem(#3tmsg)10]约束了该报文请求操作是针对p10片段进行的;genpk变迁的防卫表达式[peerid2=pid(2)]约束了该报文请求来自于L2;check变迁的防卫表达式约束了L1对自身已有片段的检索操作也是针对p10进行的.若模型中ph位置上生成一个值为犮狅狏犲狉犲犱的token数据,则可标识测试目的所描述的系统功能得以正确地执行,即L1为L2生成了对p10片段的数据响应报文.Page10图7DCP2ND软件层次CT-CPNS模型中的下载者结点行为描述模块步骤3.对每个CT-CPNTP,将其与该软件的CT-CPNS层次模型中的相关模块执行同步模拟,可生成具体的CT-CPNTC模型,用于对相应测试目的所覆盖的软件功能进行一致性测试.生成过程中使用规则1和规则3来处理输入输出行为,重点是为模型中的可观察位置添加预期结果指示位置;使用规则2消去大量描述软件内部行为的模型元素,并添加必要的内部位置以保证测试例模型的连通性(如图9中的sn位置).作为典型示例,图9分别给出了将tp8对应的CT-CPNTP和表2中的L_receive及l_havepk模块执行同步模拟,以及将tp9对应的CT-CPNTP和表2中的L_receive及l_havepk模块执行同步模拟所生成的两个CT-CPNTC测试例模型.可以看到,基于CT-CPN模型的测试例以外部可观察的输入输出为驱动清晰描述了具体测试步骤,以实际测试数据为依据准确描述了预期测试结果,这样不但充分保证了测试例的可执行性,并且使测试例模型能够直观、有效地指导实际测试的执行过程.步骤4.实际执行生成的各测试例,判定DCP2ND软件系统与其CT-CPNS层次模型的功能描述是否一致,发现了软件实现中的不同错误,如位图信息解析错误导致的无法正确请求片段数据、没有执行最少优先片段算法、无法向同一下载者结点请求关联片段等.在实际测试过程中,对执行失败的测试例,首先要定位产生fail结果的变迁元素,以此确定被测实现是在执行什么操作或行为时产生错误,同时,结合该变迁点火时绑定元素中的具体数据,进一步分析是怎样的数据错误引发相关功能失效.将被测实现中存在的错误改正后,需要重新执行对应的测试例,直至测试执行的结果为通过,且覆盖了测试目的.此时,可判定在测试例所覆盖的软件功能范围内,被测软件实现与软件功能说明(即该软件系统的CT-CPNs模型)是一致的.分析对DCP2ND软件系统的实际测试生成与执行实践可知,对DCP2ND这样规模较大的软件执行模型驱动的一致性测试时,传统基于模型状态空间遍历或基于模型同步积的测试生成方法都会因为模型过大而无法实际操作.但PN4TS方法是通过CT-CPN模型间的同步模拟执行来生成测试例,并不受控于系统模型的规模大小,因此,可以有效实施于较大规模的软件一致性测试应用.6.3PN4TS方法的实际应用方式PN4TS方法主要用于网络环境中具有多交互、高并发特性的软件系统的IOCO一致性测试实践,在切实保证测试例可执行的基础上,能够很好地支持较大规模网络软件的一致性测试应用.总结上述两个实例测试过程可知,PN4TS方法的实际应用过程可概述为4个步骤:首先,为被测软件系统构建描述其功能行为且考虑了一致性测试实际需求的CT-CPNS层次模型,充分利用CPN模型分析与动态模拟执行等技术确认该层次模型的描述正确性.Page11接着,以构建好的CT-CPNS层次模型为基础,为不同的测试目的构建各自对应的CT-CPNTP模型,来描述希望被实际测试的部分软件功能行为.之后,应用本文PN4TS方法给出的3个测试选择生成的核心规则,即分别针对模型中输入变迁、输出变迁和内部变迁的测试生成规则,将CT-CPNS层次模型与每图9DCP2ND软件一致性测试使用的CT-CPNTC模型实例7结论文中将IOCO测试理论与CPN建模进行优势融合,提出了PN4TS方法,基于描述软件功能和描述测试目的的CT-CPN模型的同步模拟执行,生成可执行的测试用例,实现了测试目的驱动的IOCO测试选择,并证明了测试生成的可靠性及其对测试目的的覆盖完备性.通过对简单的SFTP系统和较大规模的DCP2ND软件的实际测试生成与测试执行实践,验证了PN4TS方法的可用性及有效性.PN4TS方法为基于Petri网模型的一致性测试研究提供了一种新的思路与解决方案,其优势主要体现在:首先,利用CT-CPN模型的动态模拟技术生成测试例,充分考虑了功能行为控制流和数据流的协同执行,以实际数据驱动测试选择,保证了所生成测试例是实际可执行性的,且测试例模型中添加的测试结果指示和判定单元由具体数据描述,可作为一种TestOracle标准,为测试执行人员提供准确、直观的测试结果判定依据.其次,PN-IOCO一致性关系要求只有实际观察的测试输出与预定义的测试输出相同时,才会判定被测软件一致于软件功能模型,与基本IOCO定义相比,加强了对那些行为正确但功能不完整的缺陷软件的检测能力.最后,当软件功能模型较大时,基于遍历模型状态空间来生成一个CT-CPNTP模型执行同步模拟,生成覆盖各个测试目的的多个CT-CPNTC测试例模型.最后,以生成的测试例模型为指导完成测试执行,利用模型中的TestOracle测试判定单元描述,判定被测软件实现是否与其对应的CT-CPNS层次模型的功能描述一致,来发现软件实现中的不同错误和缺陷.测试例的方法由于状态爆炸往往难以实施,同时,IOCO测试理论中提出的基于LTS模型同步积的测试例选择方法,也会因为模型过大而无法执行同步积操作,但是,本文基于CT-CPN模型间同步模拟执行的选择性测试生成方法,并不受控于系统模型的规模大小,具备更强的可用性,能够有效处理较大规模软件的一致性测试应用.
