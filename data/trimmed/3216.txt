Page1基于阈值的概率图可达查询袁野王国仁(医学影像计算教育部重点实验室(东北大学)沈阳110004)(东北大学信息科学与工程学院沈阳110004)摘要图的可达性查询被广泛应用于生物网络、社会网络、本体网络、RDF网络等.由于对数据操作时引入的噪声和错误使这些图数据具有不确定性,而确定图的可达查询不能有效地处理不确定性,因此该文研究用概率语义描述的图可达性查询.具体的,该文使用可能世界概率模型定义不确定图(称为概率图),基于该模型,研究了基于阈值的概率可达查询(T-PR).首先为避免枚举所有可能世界,给出一个基本算法可精确求解T-PR查询.其次为进一步加速基本算法,给出3种改进方法,它们是不确定事件界、同构图的缩减、基于不相交路径和割集的界.通过合理的组合给出3种方法的合并算法.最后基于真实概率图数据的大量实验验证了该文的设计.关键词概率图;可能世界;不确定事件;同构图缩减;路径集;割集1引言本文研究一个概率图上任意两点的可达性问题.具体地,给出一概率图,其任意两点s和d,一用户查询阈值ε(0ε<1),返回s和d的连通概率是否不小于ε.由于图的不确定性存在于许多应用中[1-7],研究概率图中的可达查询十分必要,下面给出两个具体应用的实例.应用实例1.已有很多关于概率XML数据库的研究[1-2].在这些文献中,一个XML文档被建模成一颗概率XML树.树的结点被分成“ordinary结点”和“distribution结点”,这些结点定义了父结点和孩子结点之间概率的依赖关系.在XML数据库中,可达性查询是最基本的路径查询.其形式为//P1//P2,表示P1是P2的祖先.在概率XML树中,该查询不仅返回从P1~P2的一条路径,而且还包括P1~P2的可达概率.这样的查询也可被看作有向概率图的可达查询.应用实例2.对本体的查询日趋重要,因为很多领域都在建立自己的本体知识库,其中“基因本体(GO)”是最著名的本体知识库(http://www.gene-ontology.org).GO被构建成有向无环图,其中图结点表示概念,边表示概念之间的从属关系,而概念是对有机物中不同种类RNA的抽象.对于GO网络,生物专家会关心某两个概念之间的关系在特定的生物过程中起到的作用.对该问题,可用两概念间的可达查询来回答.而由于不准确的RNA检测方法,使概念之间的联系不再确定[4-6],因此使用概率图表示GO网络是合适的[3],其中边的权值表示概念之间存在相互作用的可能性.对应用实例2,文献[7]给出一个真实概率网络,其中每条边被赋予一个概率.此概率被定义为两种RNA之间的可靠性,该值越大,两种RNA之间越可靠.图1给出该网络的一部分,在图中,边e3上的概率表示概念B对概念A影响的概率是0.75.对图1,会提出查询“概念s影响概念d的概率是多少?”.传统的s和d之间的可达性查询仅返回s可以影响d.但是,上述查询不仅返回“可以影响”,而且还返回影响的程度.为解决概率有向图的T-PR查询问题,本文采用可能世界模型[8-9](一种被用来描述概率数据库的模型)定义概率图.具体地,给出一个概率有向图,赋予每边一个存在概率,每个顶点是确定的,即其概率为1.一个概率图的可能世界是一个确定图,称为可能世界图(简称可能图),它是概率图中所有边(取决于它们的存在性)组合的一个实例.一个可能图的概率是其所有存在边概率和其不存在边的不存在概率的乘积.给定概率图两顶点s和d,从s到达d的可达概率是部分可能图概率的和,在这些可能图中,s和d必须是连通的.一种直接求解T-PR查询的方法是枚举概率图所有的可能图,并且对每个可能图做传统的可达查询处理.找出所有给定两点连通的可能图,对其概率求和,所得结果即是可达概率,再与查询阈值比较返回结果.称该方法为Naive算法.但是,此方法的效率非常低,因为需枚举指数级的可能图.因此,为避免Naive算法,本文首先设计一基本算法可精确计算出可达概率.但处理T-PR查询是#P完全问题,因此在最坏情况下,基本算法的计算代价会很高.为此本文对基本算法开发出3种改进方法,它们分别是“不确定事件界”、“同构图的缩减”、“基于不相交路径/割集界”.3种方法都是充分利用图的结构特点和阈值界加速查询,尽可能早地使基本算法收敛.最后给出3种方法的合并算法.正如用真实概率图数据的实验结果所示,合并算法具有非常快的运行速度.2问题定义定义1.一个概率图是一集合G=((V,E),Pr),其中(V,E)是有向无环图,Pr:E→(0,1]是定义边集中每条边存在的概率函数.从定义1易知确定图是一个特殊的边概率为1的概率图,可表示为G=((V,E),1).正如第1节提到的,本文使用可能世界模型来定义概率图.在可能世界模型下,一概率图可派生出一组确定图G=(V,E),此确定图称为可能世界图,简称可能图,它满足V=V,EE.根据文献[1-7]应用的规定,本文假设概率图不Page3同边的概率分布是相互独立的,因此可能图的概率为Pr(G)=∏e∈E定义2.给一概率图G,其两个顶点s和d,一查询阈值ε(0ε<1),基于阈值的概率可达查询(T-PR)返回如下信息:(1)“两顶点能够以概率ε连通”,如果可达概率qprε;(2)“两顶点不能以概率ε连通”如果可达概率qpr<ε.其中可达概率计算如下其中RA(G)是s可达d的可能图的集合.例如对图1中的概率图,枚举其25=32个可能图,然后判断s和d连通的可能图,对它们的概率求和即是可达概率,其值是0.9176.如果用户的查询阈值是0.5,则系统返回“两顶点能够以0.5的概率连通”.注意到s和d在G中可能不连通,本文采用“Path-TreeCover”[10]方法首先测试s是否可到达d.如果它们连通,然后计算可达性概率qpr.否则,直接返回不可达信息.接下来,本文都假设在G中s和d是连通的.对计算可达概率的复杂度,引用文献[11]中的结论.引理1.计算概率图中的可达概率是一个#P完全问题.3基本算法定义3.给定一个概率图G,其两个顶点s和d,一个s—d路径是连通从s到d的连续边的集合.如果一个s—d路径中不包含任何的s—d子路径,则它被称为最小s—d路径(表示为Imin(s—d)).根据定义1知,图G是无环图,因此易知一s—d路径即是Imin(s—d).定义4.对任意一边e∈G,定义一布尔变量xe,其中事件xe=1(称为成功事件)的概率是e的存在概率,事件xe=0(称为失败事件)的概率是e不存在的概率.接下来用Event(e)表示事件xe=1,用Event(珋e)表示事件xe=0.这样,有了基本事件便可定义复合事件.例如事件I=Event(珋ij珔k)表示边j是成功的,边i和k是失败的.其它不在I中的边是不确定的(即不是成功的也不是失败的),每个I把图G的边集E分成3个不相交的子集Es(I)、Ef(I)和Eu(I),分别用来记录成功的边集、失败的边集和不确定的边集.例如对于Event(珋ij珔k),有Ef(I)={i,k},Es(I)={j},Eu(I)=E\{i,j,k}.易知Es(I)∪Ef(I)∪Eu(I)=E.由于边的分布是独立的,事件I的概率为Pr(I)=∏e∈Es定义3个重要事件.定义5.给定一个概率图G,其两顶点s和d.如果Es(I)中的边能使s和d连通,复合事件I是成功的(记为s-event).如果Ef(I)中的边不能使s和d连通,I是失败的(记为f-event),如果I既不是成功的也不是失败的,则I是一个不确定的事件(记为u-event).例如在图1中,Event(e1e4)是s-event,由于其成功边集{e1,e4}的存在使s和d连通.Event(e1e2e3)是f-event,因为当其失败边集e1,e2不存在时,必使s和d不连通.Event(e2e3)是u-event,因为不能通过判断其成功边集e3的存在和其失败边集e2的不存在,来确定s和d是连通还是断开.定理1.对概率图G中任意一u-eventI,I中至少有一条Imin(s—d)路径.证明.设I的Eu(I)为e1e2…eα,那么有(e1e2…eα)∪Es(I)=E\Ef(I).因为I是不确定事件,故可分两种情况考虑:(1)当I不失败时,由于I的边集E(I)=Es(I)∪Ef(I),所以I∧Event(e1e2…eα)必是s-event;(2)当I不成功时,边集(e1e2…eα)是非空的.根据(1)、(2),易得(e1e2…eα)是Imin(s—d)路径.例如在图1中,在u-eventEvent(e2e3)下,可找到Imin(s—d)={e1e4},并且Event(e1e3)∧Event(e1e4)是一个s-event.这个定理是基本算法的基础.概率图G的整个事件空间Ω是u-event,定理1保证在Ω下能够找到一个Imin(s—d)=(e1e2…en),也就等于找到了成功事件Event(e1e2…en).而对于任何一u-eventI,根据定理1都可以找到成功事件Event(Imin(s—d)).下面的公式生成不相交的事件.对于一个u-eventI,由概率分解定理得到I=I∧Ω=I∧(Event(e1e2…en)∨Event(e1e2…en))=(I∧Event(e1))∨(I∧Event(e1e2))∨…∨(I∧Event(e1e2…en))∨(I∧Event(e1e2…en))起初在G的整个事件空间Ω下找到Imin(s—d)=(e1…en),后用式(3)产生的事件I∧Event(e1e2…en)是一个s-event,而事件Ii=I∧Event(e1,e2,…,Page4ei)(1in)可能是成功、失败或者不确定的.此时可以继续用式(3)对不确定事件分解产生成功事件.重复此过程直到没有不确定事件为止.最后把所有成功事件的概率加到一起①,即可得到可达概率qpr.算法1给出基本算法的具体步骤.算法1.基本算法.输入:概率图G,s和d,阈值ε输出:有效或无效的查询结果算法描述:1.S={Ω,,0,0};//为整个G的事件空间Ω初始化2.qpr=0;//初始化可达概率3.while(S≠){4.根据集合S中的索引i,获得一事件Ii;5.if(i<ni)6.i=i+1;7.else集合S被舍弃;8.在事件Ii下找到一s—d路径Iimin(s—d);9.if(Event(Iimin(s—d))==)10.删除Ii;//此时事件Ii是失败的.11.elseif(Ii是成功的)12.qpr=qpr+Pr(Ii);13.elseqpr=qpr+Pr(Ii∧Event(Iimin(s—d)));14.if(qprε)15.return“两顶点能够以概率ε连通”;16.将一个新的集合{Ii,Iimin(s—d),ni,i=1}放入S;17.}//while结束18.return“两顶点不能以概率ε连通”.图2图1中概率图的解决树此算法的过程可用一棵解决树表示,其定义如下.定义6.一棵解决树是一树形结构,其根节点表示G的整个事件空间Ω,其它节点表示由式(3)产生的事件I∧Event(e1e2…ei)(1in)或I∧Event(e1e2…en).特别地,每个叶子节点表示一个s-event或者f-event,但中间节点仅能表示u-event.根据解决树,算法1的工作原理如下:开始解决树仅包含根节点表示G的整个事件Ω(Ω是一u-event),接下来用式(3)找到一s—d路径e1e2…en,并将Ω分成不相交的事件.这些事件构成了解决树的第一层结点②,其中Event(e1e2…en)是成功的,事件Event(e1e2…ei)(1in)可能是失败、成功或者不确定的.同样地,对每个u-event进一步递归划分为不相交的事件,直到没有u-event为止.解决树不断由u-event结点进行扩展直到只剩下s-event和f-event结点为止,并且这些结点构成解决树的叶子节点.qpr的值为所有s-event概率的和.最后将qpr和阈值ε比较,并返回查询结果.例如,欲计算图1中s到d的qpr,图2给出其基本算法的解决树.如图所示,树根是Ω,在Ω下找到s—d路径e1e4,产生事件Event(ei)(u-enent)、Event(e1e4)(u-enent)和Event(e1e4)(s-event).每个u-event继续被分解,直到解决树中只包含s/f-event,如图2中叶子节点所示.所有的s/f/u-event都在图中列出,并且给出每个s-event的概率,它们的和0.68+0.1224+0.072+0.0162+0.027=0.9176即为qpr.①②Page54改进算法由引理1知,计算qpr的精确值是很困难的.因此对于一个很大的图,基本算法仍需要枚举大量的s—d路径.本节将给出3种优化算法使基本算法尽可能快地收敛.4.1不确定事件界T-PR查询包括阈值ε,因此可以利用这个阈值来加速查询.一种方法是计算qpr的界,然后将此界与ε比较给出查询结果.对固定的α(0α<1),如果一个u-eventI的概率不小于α(Pr(I)α),则称I为有α资格的u-event,否则,I为非α资格的u-event,如果Pr(I)<α.对给定α,设Xα,Yα,Zα分别为解决树中的s-event集合、f-event集合和非α资格的u-event集合,则定理2给出qpr的上下界.定理2.对0αβ<1,有∑I∈XβPr(I)qpr1-∑I∈Yα∑I∈Xα证明.设Treeα和Treeβ为对应于α和β的子解决树.如果αβ,那么每个有β资格的u-event也是有α资格的u-event.因此每个有β资格的u-event可在Treeα和Treeβ被分成若干子事件.然而,一个有α资格非β资格的u-event只能在Treeα被划分而不能在Treeβ被划分.因而有XβXα,YβYα,从而推出结果.该定理表明,一个较小的α会使qpr的上界和下界非常接近,也就会有非常好的过滤能力.如果选择一系列的α满足1>α1>α2>α3>…>0,便可获得一系列递增的下界和递减的上界以保证精确的qpr.得界以后再与ε比较给出查询结果.这种方法避免了在解决树上对u-event事件的深度分解,并能快速地逼近准确值.但欲应用定理2,必须预先确定α的值,此种方法不是最佳的选择.但我们可以用解决树中s-event和f-event的叠加概率作为界限,它的本质即是定理2.设Pr(Is)和Pr(If)是当前从解决树第一层开始累加的s-event和f-event的概率.根据定理2有Pr(Is)qpr1-Pr(If).根据查询结果的条件qprε做如下测试:(1)如果Pr(Is)ε,则停止基本算法返回有效结果;(2)如果1-Pr(If)ε,则也停止基本算法,并返回无效结果.随着累加值的不断递增,就像选择一系列的α一样,可得越来越紧的界限,尽可能早地停止计算.4.2同构图缩减如式(3)所示,任何事件I∧Event(e1,e2,…,ei)(1in)可能是一个u-event.因此在基本算法中,如果在解决树的低层产生较多的u-event,那么会产生对u-event的深度分解.这样会导致整个解决树的结点数量以指数增长,从而产生巨大的计算开销.幸运的是,我们发现在一系列相邻的u-event中存在一种结构关系,通过这种关系,能够大幅度地缩减结点的数量,以减少计算代价.本小节给出该方法的具体实现.对一u-eventI,设E(I)=Es(I)∪Ef(I),G\E(I)为G删除边集E(I)后得到的子图,Pr(G\E(I))|con为G\E(I)中s到d可达概率.从基本算法可得,事件Event(E(I))对qpr的贡献概率为Pr(E(I))·Pr(G\E(I))|con,其中Pr(E(I))=Pr(Es(I))·Pr(Ef(I)).例如在图2,不确定事件Event(e1)的贡献概率是Pr(e1)·Pr(G\e1)|con,并且以(e1)为根的子树给出了Pr(G\e1)|con的计算过程.设S=G\E(I),S\e表示从S中删除边e.又设Se表示从S缩e,即从S中移除e,并将关联e两顶点的边关联到一个顶点上.定理3给出关于图S=G\E(I)的一重要性质.Pr(S)|con=Pr(e)Pr(Se)|con+Pr(珋e)Pr(S\e)|con定理3.证明.设Scon表示S中s到d连通的事件,由全概率公式可得Pr(S)|con=Pr(e)Pr(Scon|e)|con+Pr(珋e)Pr(Scon|e),其中Pr(·|·)表示条件概率.易知Pr(Scon|珋e)等于Pr(S\e)|con,而Pr(Scon|e)表示边e已存在时对Scon的影响,因此可以缩减e,并且有Pr(Scon|珋e)等于Pr(Se)|con.证毕.令I∧Event(e1e2…ei)=Ii和I∧Event(e1e2…ei+1)=Ii+1是解决树中两个相邻的u-event,并令Fi和Fi+1分别表示G\E(Ii)和G\E(Ii+1)得到的子图.则可得qpr=Pr(Ii)Pr(Fi)|con+Pr(Ii+1)Pr(Fi+1)|con=Pr(Ii)[Pr(ei+1)Pr(Fiei+1)|con+对于两个相邻的u-event,Fi和Fi+1有相同的顶点,并且Fi仅比Fi+1多边ei+1,因此,Fi+1\ei+1和Page6Fi+1是相同(同构)的图①,式(4)可重写为qpr=Pr(Ii)Pr(Fi)|con+Pr(Ii+1)Pr(Fi+1)|con=Pr(Ii)Pr(ei+1)Pr(Fiei+1)|con+Pr(Fi+1)|con[Pr(Ii)Pr(ei+1)+Pr(Ii+1)](5)式(5)给出的结果是合并同构的图,并产生两个新事件,而其中一个事件对应于更小的图.对于解决树中一系列的u-event,用式(5)分解它们,这样会产生大量同构的且规模小的图.合并同构图,直到没有相邻u-event为止.最后得到的新事件个数与被分解的u-event的个数相同,而基本算法会产生指数级的新事件.这说明通过缩减同构图后,树节点的数图3对图2中不确定事件Event(珋e1)和Event(e1珋e4)的缩减4.3不相交路径/割集界4.1节给出的u-event界是在解决树中不断对s-event和f-event概率的累加.但只是“加”的操作,而“乘”的操作会快得多,会使界限收敛得更快.本小结便给出通过“乘”操作获得的上下界.设图G中s到d共有m条s—d路径,又设I1,I2,…,Im为这m条路径连通的事件.那么易知qpr=Pr(I1∨I2∨…∨Im)=1-Pr(I1∧I2∧…∧Im)由于m条路径中有很多路径相互交叠,因此事件I1,I2,…,Im互相不独立,那么Pr(I1∧I2∧…∧Im)≠∏m[1-Pr(Ii)].其实该不等式也就是计算qpr是困i=1难的本质.但如果能找到不相交路径的集合,那么这些路径对应的事件便是独立的.设有l条不相交的路径,那么式(6)便可写成量会大幅度地减少,从而大大地降低了计算代价.图3给出图2解决树中两个u-eventEvent(e1)和Event(e1e4)分解和合并的过程.其中把两个同构图(标注在矩形中)缩减成一个图.从图中可见,两个u-event产生对应于小图的两个新事件,且这些事件都是成功的,因此可直接计算出结果.给出的结果0.2376和图2中基本算法求得的结果0.027+0.0162+0.072+0.1224=0.2376是一样的.然而基本算法又产生两个u-event,还得继续分解下去.这个例子充分地说明了缩减同构图对降低计算代价的重要性.上式给出一qpr的下界LowerB.如果此下界不小于阈值ε,则即可返回有效结果.类似地,可得qpr的上界UpperB:qpr1-∏k其中Ci(1ik)为G的k个不相交的割.如果此上界小于ε,那么即可返回无效结果.从式(7)和式(8)可见,如果l和k越大,界限越紧.因此我们欲求最大的l和k值,即求出图G中s到d的最大不相交路径数和割数.这里应用网络流理论中的两个定理[12].s—d割的基数.路径的长度.引理2.最大不相交s—d路径数等于最小引理3.最大不相交s—d割数等于最短s—d这里使用文献[12]中的算法求解最大的l和k(设为lmax和kmax),该算法可在多项时间内完成,因此可快速地求出紧的解.例如在图1中,最大的不相交路径集和割集分别为{{e1,e4},{e2,e5}}和{{e1,e2},①这里不需要做同构测试,通过分析显然会产生同构的图.Page7{e4,e5}}.因此下界是LowerB=1-(1-P1P4)(1-P2P5)=1-(1-0.85×0.8)(1-0.8×0.9)=0.9104,上界是UpperB=1-(1-P2P5)(1-P1P4)=0.9506.即(LowerB=0.9104)(qpr=0.9176)(UpperB=0.9506).用lmax和kmax得到相当客观的界限,但每个路径和割都有一个权值,即其存在概率,因此权值也会影响界限的大小.欲产生更好的界限,在保持求得lmax和kmax的同时,尽可能地选择权值大的集合.首先给出选取权值最大的lmax路径集:给每边e∈G一代价-log2pe,其中pe为e的存在概率,因此一条代价为v的路径的存在概率为2-v.易得,如果代价越小,此路径的存在概率越大.从而选择最大权值的路径集问题可转化成求解具有最大代价的lmax路径集.本文通过简单地修改网络流算法[12]来求解此问题,即原来的算法每步都是寻找一“增广路径”,这里变成寻找“代价最小的增广路径”,而代价最小的路径可通过最短路径算法求得[12].类似地也可求得存在概率最大的kmax割集.欲在基本算法中应用“不相交路径/割集界”,这里对基本算法做如下改动:因为解决树中每个u-event的结点都对应于G的一个子图,便可对该子图应用“不相交路径/割集界”,然后和ε比较,如果满足判断条件,便可停止基本算法返回查询结果.5合并算法上节给出的3种改进算法是互相独立的,即分别是对基本算法的优化.如果将3种方法同时作用于基本算法,那么将对计算的加速有“质”的提高.本节给出基本算法和3种改进方法的合并算法.算法2给出合并算法的详细步骤.此算法主要分为3个步骤.第1步(6~10行):在基本算法每产生一个u-event后,便对此u-event应用“不相交路径/割集界”,如果满足条件,就返回结果.第2步(11~12行):如果第1步不能停止计算,就开始分解连续的u-event,并合并同构图.第3步(13~31行):对第2步输出的u-event继续用式(3)分解,但此时开始不断地积累“不确定事件界”尽早地结束迭代.算法2.合并算法.输入:概率图G,s和d,阈值ε输出:有效或无效的查询结果算法描述:1.S={Ω,Φ,0,0};//为整个G的事件空间Ω初始化2.LBU=0,UBU=1;//初始化u-event的下界和上界3.qpr=0;//初始化可达概率4.while(S≠){5.根据集合S中的索引i,获得一事件Ii;6.获取不相交路径集下界LBPath和割集上界UBCut;7.if(LBPath+qprε)8.return“两顶点能够以概率ε连通”;9.if(UBCut+qpr<ε)10.return“两顶点不能以概率ε连通”;11.if(从Ii开始有连续的u-event)12.用式(5)分解这些事件并合并同构图,直到没有13.if(i<ni)14.i=i+1;15.else集合S被舍弃;16.在事件Ii下找到一s—d路径Iimin(s—d);17.if(Event(Iimin(s—d))==){18.UBU=UBU-Pr(Ii);19.删除Ii;//此时事件Ii是失败的.}20.elseif(Ii是成功的){21.qpr=qpr+Pr(Ii);22.LBU=LBU+Pr(Ii);}23.else{24.qpr=qpr+Pr(Ii∧Event(Iimin(s—d)));25.LBU=LBU+Pr(Ii∧Event(Iimin(s—d)));}26.将一个新的集合{Ii,Iimin(s—d),ni,i=1}放入S;27.if(LBUε)28.return“两顶点能够以概率ε连通”;29.if(UBU<ε)30.return“两顶点不能以概率ε连通”;31.}//while结束.通过第4节的分析,“不相交路径/割集界”具有最强的过滤能力(实验也给出验证),因此把此过滤步骤放在第1步尽可能地缩减计算空间.“不确定事件界”是依赖于解决树结点数目的,因此如果对第1步后剩余的计算空间(其实该剩余空间已很小)直接用“不确定事件界”,很有可能由于有很多的树节点使过滤效果不好.但算法2中先用“同构图缩减”,这会使树的宽度不再增加,导致计算空间已是节点数目线性的阶.之后在对宽度很小的树应用“不确定事件界”,这样会最大限度地发挥“不确定事件界”的过滤能力.实验说明这样组合的“合并算法”有相当强的过滤能力.6性能分析本节用真实和合成的概率图数据验证本文的算法,算法代码用VisualC++6.0编写,运行环境是Page8奔腾43.0GHzCPU,2GHz内存和160GB硬盘.对本文给出的算法,BC表示“基本算法”,IGR表示“同构图缩减”算法,UB表示“不确定事件界”算法,PCB表示“不相交路径/割集界”算法,ALL表示“合并算法”.真实概率图数据采用Entrezgene6091-OMIM127700数据库①.它是描述人类基因网络的数据库,其中网络节点代表“显性基因”,边被赋予小数权值以表示基因相互作用的大小.使用该数据库的5个基因网络作为概率图数据,表1给出它们的参数.图数据编号节点数量边集大小边的平均概率Dys1Dys2177541630.396Dys3325987900.212Dys46786140560.237Dys511368327540.311图4真实数据下算法的运行时间其次给出对合成概率数据的实验结果.因为此图边的存在概率是合成的,故可以测试不同概率分布下的运行效率.这里通过改变N(μ,σ)分布中的μ和σ来实现.具体地,μ取0.5~0.9,默认值是0.7;σ取0.1~0.5,默认值是0.4.图5给出测试结果.如图5(a)所示,随着μ的增加,所有算法的运行时间图5合成数据下算法的运行时间最后用真实数据测试算法的可扩展性.图6给出测试结果,其中横坐标是Dys1~Dys5,纵坐标是运行时间.如图所示,所有曲线都随图规模的增加而同时从Citeseer②中抽取图数据(|V|=12140,|E|=36874),并按正态分布N(μ,δ)为每边产生概率.每次实验时,随机地产生100个查询,记录下查询的平均代价.首先给出对真实概率图数据的实验结果.这里选取小图(Dys1)和大图(Dys2)两个具有代表性的数据,给出在不同阈值下的结果.图4给出阈值是0.3~0.7的运行时间.从图中可见,所有的曲线都呈上升趋势,这是因为越高的阈值需要需要枚举越多的s—d路径.很明显,3种改进算法都比BC快得多,并且PCB是最高效的改进算法.这一点验证了对3种算法的设计与分析.而ALL算法的运行效率比其它任何方法都要高出一块.例如,对Dys1的平均运行时间ALL只需1s多,即使对边数超过3万的Dys5平均也不超过15s.都在增加.尽管μ的增加导致可达概率指数级的增长,但除了BC,其它算法都有较好的可扩展性.类似的结果也在图5(b)中给出,其中3种改进方法和合并算法的曲线都缓慢地下降.这说明改进算法的有效性.ALL在图5中的两个实验都表现出极高的运行效率.增长.其中BC增长的最快,到Dys4时就已经超过①②Page9300s,其曲线增长的趋势呈近似指数级的增长.而其它算法都可避免此种爆炸性的增长,具有较好的可扩展性.尤其ALL有非常快的速度,即使对边数量超过3万的图Dys5求解NP难查询也可在20s内完成.7结语已有很多面向确定图的可达查询工作.文献[15]用图的传递闭包来压缩原始图,并在求解过程中把问题转化为网络流问题.文献[16]把图分成若干有向链,并每个顶点都记录了与其相邻的链,从而可常数时间求解查询.文献[17]首先提出树覆盖的方法,并以树为单元对图进行压缩,并证明此种压缩是保证可以求解查询的最优压缩.文献[18]和文献[19]都是在索引构建时间上改进了树覆盖方法.文献[10]拓展了有向链的方法,把问题转换成平面图的问题,并只需2跳即可完成查询.面向概率数据库的研究是现在的热点.早期工作的重点是在概率关系数据库上如文献[8-9,20],即处理概率SQL查询.之后研究者提出了一些查询类型及其处理方法,主要包括Top-k查询[21]和Skyline查询等[22].近年来开始关注结构化数据如概率XML数据[1-2,13-14].就图数据库而言,邹等人[23]研究了不确定图的频繁子图挖掘,而张等人[24]研究了带索引的不确定图Top-k查询.本文是第一个面向概率图研究可达查询的工作.采用细粒度的可能世界模型定义概率图,从而使可达查询具有丰富的概率语义.在给出问题是#P难后,本文首先设计了一个基本算法可精确地给出查询结果.在用解决树重新描述基本算法后,用不确定事件界对解决树进行了剪枝.用同构图的缩减可以使基本算法只对图中相同的元素进行一次计算,从而降低计算空间.用不相交路径/割集界可使计算快速地收敛.最后所有算法的合并在实验中显示出相当高的运行效率,说明本文开发的算法具有实际应用的价值.
