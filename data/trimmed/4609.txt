Page1一种基于预测控制的SaaS系统自适应方法1)(武汉大学软件工程国家重点实验室&计算机学院武汉430072)2)(武汉大学国际软件学院武汉430072)3)(湖北文理学院湖北襄阳441000)摘要对于部署在虚拟服务器集群上的多层云端应用系统而言,可以通过调整运行时架构以适应需求和上下文环境的变化,并保证其在动态负载下的性能.然而,由于缺乏通用的方法,如何从问题空间上的需求自适应地映射到解空间上的架构就成为了一个关键的问题.为解决这个问题,目前存在3种驱动方法:需求驱动模型、架构驱动模型和综合需求和架构模型的驱动方法.然而,这些方法的性能是有限的,并且忽视了时间变化规律,对横切系统多个层次的需求演化支持也不足.文中提出了一个基于预测控制的自适应方法(SAPC),它采用综合需求和架构的模型来驱动系统的自适应.该方法根据监控获取的运行时状态信息日志得到服务组件QoS值,学习基于小波变换的模型以准确预测服务组件的QoS,并通过预测控制诱导需求进化或实现运行时架构的模型转换来达到系统的自适应.更进一步,其根据当前的服务组件的QoS以及目标QoS做出优化决策.在控制操作部分中,判别当前情况下是做框架调整还是需求调整.如果存在可行的运行时模型,则通过预测控制产生操作向量,继而自动生成面向方面的脚本;该脚本被执行后会重构运行时模型并生成相应实例,该实例被传递给并行计算架构(比如MapReduce、Yarn或Spark等)来执行.否则,运用训练好的模型标识出进化点,然后将进化点与初始的需求混合起来以诱导需求进化.为验证上述方法,文中以一个名为CloudCRM在线SaaS平台为基准进行了大规模的实验,该平台基于RGPS元模型框架,通过对开源软件SuperCRM进行服务化改造来获得,其支持多租户.为观察平台在不同模型驱动方法的性能表现,文中对于该平台进行了剪裁,构造了4种由不同模型驱动的系统(包括Static、Req、Arch与SAPC),实验结果验证了文中方法的有效性.其中,在用户数为20时文中方法相对于其他3种方法在响应时间上分别降低54%,26%与21%,在吞吐率上提高313%,288%与12%,在可靠性上提高0.40%,0.26%与0.42%;在用户数为200时文中方法相对于其他3种方法在响应时间上分别降低99.5%,99.2%与20.7%,在吞吐率上提高320%,298%与10%,在可靠性上提高500%,495%与1.5%.进而文中方法使用小波变换分析相较于傅里叶变换在响应时间上降低7.2%,在吞吐率上提高2.4%,在可靠性上提高0.08%.在参数对于系统的影响方面,随着目标集合的大小与插件扩展点的数目的增长,SAPC方法都符合响应时间和吞吐量增加而可靠性下降的现象.关键词自适应系统;需求;预测控制;服务质量;软件即服务;云计算1引言在软件工程中,需求工程关注的是准确描述问题以及如何加快系统从需求建模到实现的过程[1].在应用程序部署之后,由于软件需求的演化而产生的需求变更会导致耗时费力的开发活动[2],并同时影响客户的体验.因此,软件系统需要具有自适应调整的能力,以快速响应需求变更和感知上下文变化.目前,随着工业界自适应技术变得越来越流行,一些采用自适应技术的产品或原型已经开发出来.比如IBM已经获得了一些有意义的结果:AutoTune[3]是一个典型的自适应应用实例.当前有很多研究使Page3用模型驱动的方法来实现运行时的自适应[4],而不是依靠低级且易出错的手工脚本来实现.模型在运行时,系统可以收集系统状态信息,然后分析和预测系统的性能,进而依据它们实现动态适应性调整[5-6].在模型驱动中,需求模型[7-11]和架构模型[12-15]都已经被使用过.需求模型驱动的方法为简化需求元素(目标或功能)和架构元素(服务组件)之间的映射,通常会忽视架构设计部分的复杂性.而在架构模型驱动的方法中通常会假设在设计时确定需求,并且在运行时需求不再改变,因此其无法动态地适应变化的需求.既然这两种自适应方法都有不足,那么可以考虑把它们结合起来.文献[16-17]尝试利用Kramer和Magee的架构[18]将它们组合在一起,其中架构元素被视为一组功能的接口.然而,软件架构不应该仅包含功能的集合,还应该包含一组设计决策,这是由于功能服务组件会被自适应系统组合起来并相互作用[14].这些设计决策能够根据变化调整需求,并可能横切系统的多个层次(目标或流程).1.1研究动机本文使用一个名为CloudCRM的在线SaaS平台作为基准进行案例研究.该平台的业务部门负责营销策略,其通过多租户(multi-tendency)的方法来满足客户个性化定制的需求,该平台的技术部门则负责开发和维护系统.根据历史监测(如图1),其业务负载通常表现趋势性、周期性和随机性.当系统在一年的某个特定的时间负载达到峰值,该系统由于遇到大量并发请求,性能会降低.这时若是没有适当地增加系统的负载能力,系统的响应时间会变长,业务的失败率也会增加,从而导致客户的不满.现在考虑以下两个场景.(1)场景A.技术部门发现系统的瓶颈在于订单验证过程.该过程由几个服务组件组成(包括订单信息检查、信用检查和欺诈检查).考虑到设计决策,他们决定将检查服务组件从顺序模式切换到并行模式以获取更好的性能.其通过采用支持水平扩展的并行计算架构(比如MapReduce①、Yarn②或Spark③等)来实现运行时的自适应模型转换,以之解决性能瓶颈(其中切换过程对于业务部门是透明的).(2)场景B.若是技术部门不能找到可行的运行时模型来解决问题,则把问题提交给业务部门.而业务部门根据情况决定改变订单验证流程,使得该流程只涉及订单信息检查和信用检查,而跳过欺诈检查.虽然这样做可能会增加由于恶意订单所导致的风险,但是可以有效地缓解拥塞问题,这需要业务部门来权衡.上述操作将会产生新的需求(通过需求的自适应来实现),进而系统可以将其映射到相应架构模型来实现运行时的自适应.此外,系统通过为租户配置角色来实现客户的个性化定制的需求.而角色中则包括非功能属性QoS(服务质量)[19],其主要包括可用性、响应时间、可靠性、吞吐量等.该场景同时也表明为满足用户的个性化需求,系统常常需要调整分散在不同的层次的多个元素.1.2贡献由于缺乏考虑时间变化规律且综合需求和架构的模型,目前把问题空间上的需求自适应地映射到解空间的架构上的方法还有不足之处.本文的主要贡献包括:(1)提出一个通过预测控制的自适应方法SAPC(Self-adaptationApproachbasedonPredictiveControl).该方法可以通过学习基于小波变换的模型以预测系统服务组件的性能,并诱导需求进化或实现架构的模型转换以达到运行时系统的自适应.(2)使用一个名为CloudCRM在线SaaS平台作为基准进行案例研究,其结果验证了本文方法的有效性.本文第2节回顾与本文相关的研究工作;第3节给出问题的定义;第4节给出解决方案的整体构架;第5节给出解决方案的弹性机制;第6节给出支持需求模型自适应驱动的元模型及相关技术;第7节给出支持架构模型自适应驱动的元模型①②③Page4及相关技术;第8节通过实验对本文提出的方法进行了评估;第9节总结全文并给出下一步的研究方向.2相关研究本文的相关研究主要从3个方面展开:(1)需求模型驱动的方法;(2)架构模型驱动的方法;(3)综合需求和架构模型的驱动方法.2.1需求模型驱动的方法Elkhodary等人[7]提出了一个面向特征自适应框架FUSION,该框架能够学习自适应决策.Baresi等人[8]提出了一个促进需求驱动的适应性框架FLAGS.Peng等人[9]提出了一个考虑质量动态变化,通过基于价值的反馈回路驱动需求的方法.Fu等人[10]提出了一个通过有状态的需求监测来自我修正的社会技术系统.Souza等人[11]提出了一个可以反映需求变化的需求进化方法.这些方法都假定需求可以直接映射到架构元素上,但是这个假定是有问题的,因为它们忽略了架构模型的复杂性.2.2架构模型驱动的方法Oreizy等人[12]提出了一个架构驱动的运行时进化机制.Garlan等人[13]提出一个架构驱动的自适应框架Rainbow,该框架能对特定的需求进行定制.Floch等人[14]提出一个支持移动自适应的框架MADAM.这些方法都假定当系统正在运行时,需求保持不变,且其中的大多数方法支持简单操作(如添加、删除或替换组件),但是它们不支持横切系统多个层次的需求演化.2.3综合需求和架构模型的驱动方法Kramer等人[18]结合需求和架构提出一个三层参考模型,其中包括目标管理,变更管理及计划执行.Sykes等人[16]使用基于模型检验的技术生成脚本,并根据脚本重构架构的模型MBP.Tajalli等人[17]提出一个基于计划模型驱动的自适应方法PLASMA.通过设计决策,动态配置架构模型来适应变化.在综合需求和架构的模型方面,相关研究工作相对较少.它们的性能有限,且忽视了时间变化规律,对横切系统多个层次的需求演化支持也不足.3问题定义自适应是个很棘手的问题,它需要解决如何在运行时将需求映射到架构元素上并能适应需求演化.问题的形式化描述如下:给定C为一个三元组集合,其每个元素表示为(i,t,Ci,t).其中i是应用执行单元,t是时刻,Ci,t是主控制节点在时间t对于服务组件i的控制操作.控制操作包括为满足是期望的性能,而触发的运行时的模型转换或标识需求改进点操作.给定Y为一个四元组集合,其每个元素表示为(u,i,t,Yu,i,t).其中u是租户,i是服务的第i个QoS,t是时刻,Yu,i,t是租户u在时间t观察到的运行时定制服务第i个QoS值.未来的Yu,i,(t+1)可以根据日志中作为上下文的当前时间点和前面k-1个时间点Yu,i=(Yu,i,t-k,Yu,i,t-k+1,…,Yu,i,t-k+l,…,Yu,i,t)来预测.为支持SaaS系统的“多租户”特征,满足多租户的个性化定制的需求.给定需求约束Yref为一个三元组集合,其中每个元素表示为(u,i,Yu,i,ref).Yu,i,ref是单个租户个性化定制的需求(租户u定制服务的第i个QoS的约束值).然后根据预测的{Yu,i,(t+1)}、给定的Yref与三元组集合C生成时间t+1时的控制操作{Ci,(t+1)}.其目的是实现系统运行时的自适应,达到需求约束下的最优稳定性能.4整体构架如图2所示,本文提出的框架是基于MAPE-K[20]控制回路模型的,它由监控器、分析引擎、设计决策管理器、需求演化管理器和执行引擎构成.首先,实时监控器获取服务组件的QoS值并用日志记录下来,然后将其传到分析引擎.分析引擎根据日志记录使用基于小波变换的模型预测QoS值.设计决策管理器则根据预测QoS值和目标QoS值寻求满足需求约束的最佳设计决策:如果能找到可行的运行时模型,则自动生成面向方面的脚本,进而执行引擎通过执行脚本来完成运行时的模型转换;否则,设计决策管理器则标识出需求演进的具体改进点,以诱导需求进化.Page5图2整体框架5弹性机制5.1运行时服务单元的QoS值的预测傅里叶变换在声学、电信、电力系统、信号处理等诸多领域都有广泛应用,它可以将时间序列数据转换为频率序列数据以抽取时间序列的特征.虽然其能够将信号的时域特征和频域特征联系起来,但却不能把二者有机地结合起来.这是因为信号的时域波形中不包含任何频域信息,其Fourier谱(如式(1)所示)表现的是信号的统计特性:它是整个时间域内的积分,没有局部化分析信号的功能,存在着时域和频域的局部化矛盾.其中,T为函数的周期.Milidiu等人[21]将小波变换和混合专家模型(MEM)相结合,用来进行时间序列的预测.其可以更深刻的把握非线性问题的本质.因此,本文选择使用小波变换分析和描述应用在各个单位时间内运行时服务单元的QoS值随时间的变化规律.该变换能提高系统的性能,我们将在8.4.1节给出具体的实验验证.回顾在问题定义中的内容,未知的时间序列元素Yu,i,(t+1)可以根据日志信息来预测,日志信息是Yu,i=(Yu,i,t-k,Yu,i,t-k+1,…,Yu,i,t-k+l,…,Yu,i,t).具体地,可将Yu,i,(t+1)展开为其中,ωji是隐含层到输出层权值,h(j)是第j个隐含层节点的输出,l是隐含层节点数,m是输出层层节点数.更进一步,h(j)定义为h(j)=hj其中,ωlj是输入层和隐含层的连接权值,bj是小波基函数hj的平移因子,aj是小波基函数hj的伸缩因子,hj是小波基函数,本文采用了Morlet母小波基函数,其定义为小波网络权值参数修正公式如下:(1)计算预测误差其中,Yref是期望输出,Y是预测输出.(2)根据误差修正相关权值和系数其中,梯度公式如下:Page6其中,η是学习速率.算法的时间复杂度为O(nkm),其中n是迭代次数,k是输入层节点的数目,m是隐含层节点的数目.5.2基于QoS的设计决策回顾问题定义中的内容,我们将根据预测的Y(t+1)、给定的Yref与三元组集合C生成时间t+1时的控制操作向量犆(t+1).控制操作包括为满足是期望性能Yref而触发的运行时的模型转换或标识需求改进点操作,具体实现见算法1.其中,Yt={Yu,i,t}是所有租户在时间t观察到的运行时运行时定制服务QoS值的集合,Y(t+1)是对所有租户预测到的在时间t+1的定制服务QoS值的集合,Yref={Yu,i,ref}是期望性能(租户定制服务的QoS集合),犆(t+1)={Ci,(t+1)}是时间t+1时对服务组件i的控制.算法1.设计决策算法.输入:Yt,Y(t+1),Yref输出:犆(t+1)初始化:trainclassificationpredictionmodeltrainlabelingimprovementpointsofrequirementsmodelIFclassification-prediction(Yt,Y(t+1),Yref)=犆(t+1)=label-improvement-points(Yt,Y(t+1),Yref)ELSE犆(t+1)=architecture-transformations(Yt,Y(t+1),Yref)ENDRETURN犆(t+1)操作集合.算法主要包括两大部分:初始化部分和控制操作部分.在初始化部分中,我们利用历史记录来学习SVM(支持向量机)模型[22],来判别当前情况下是否存在可行的运行时模型.更进一步,如果不存在可行的运行时模型,我们同样利用历史记录来学习SVM模型,只不过模型的输出变成了对改进点的标注,用以诱导需求进化,而该标注是基于概念和本体的.在控制操作部分中,在当前需求的约束下,如果不存在可行的运行时模型,则运用训练好的模型诱导需求进化.否则,通过预测控制产生操作向量犆(t+1).而为寻求控制操作向量犆(t+1),需要控制器用最小幅度的调控让系统满足多租户个性化定制需求.为此,我们定义目标函数并使得其值为最小.其中,q是稳定因子,犆t是当前控制操作向量,Yref是期望输出,W={wi}是服务组件的权重,犆(t+1)={Ci,(t+1)}.我们采用梯度下降法来预测优化的控制操作向量犆(t+1),梯度公式为犆(t+1)算法的时间复杂度为O(nl),其中n是迭代次数,l是服务组件单元的数目.更进一步,由式(13)得到的控制操作向量{Ci,(t+1)}只是反映了操作的强弱,并没有物理实际意义.因此,需要将控制操作向量犆(t+1)映射到系统的实际运作的弹性机制上,我们定义映射函数f(x)如下:其中,数字{1,2}分别表示不同的计算模型(串行,并行),w1是通过一系列实验得到的经验值.最后,我们得到然后返回.6需求的自适应根据5.2节的设计决策产生的输出(对改进点的标注),我们可以定位变更需求对初始需求的演化生长点,更进一步捕获需求变更的影响,继而采用面向方面描述变更需求,完成需求的自适应.6.1支持演化的需求元模型为支持需求的演化,本文扩展了RGPS需求元模型框架[15]以构建需求模型库(如图3).通过添加标签、概念、本体、方面和词汇等元素,以提高标签的语义互操作性.通过标签的方式来识别需求的改进点,以诱导需求进化.Page7图3基于RGPS支持演化的需求元模型6.2面向方面的需求演化需求演化建模要解决的根本问题是:如何根据变更的需求将原始需求模型演变为满足新的需求的需求模型.6.2.1基本过程具体而言,分为5个阶段完成:(1)根据5.2节的工作,分析与获取变更需求(主要是通过标注来完成的).(2)本体匹配.根据第一阶段得到的标注,在基于RGPS的演化需求模型库中搜索目标或过程元素,作为初始需求模型.(3)利用面向方面的需求演化建模分析方法,针对初始需求模型,找到合适的演化改进点.(4)基于演化改进点,捕获需求变更的影响(在6.2.2节中详述).(5)业务部门以OWL-SA作为描述语言(在6.2.3节详述),根据上述分析,建立满足演化需要的新的需求规格脚本,为系统的即时演化提供支持.6.2.2需求演化的传播根据基于RGPS支持演化的需求元模型(如图3),需求项之间以及需求项与其他系统元素间存在着关联关系.由前面分析获取的改进点,其可以作为演化生长点将需求变更传播出去.为了捕获被影响到的系统元素,假设我们从RGPS需求元模型中获取了需求项间的关联矩阵犕1,需求项与目标项间的关联矩阵犕2,目标项与过程项间的关联矩阵犕3.由于需求项间的传递依赖,我们需计算矩阵犕1的闭包M当变更需求向量为狉时,我们可以通过计算受影响的目标元素向量狅,通过计算受影响的过程元素向量狆,最终我们获取了变更需求的集合.6.2.3OWL-SA描述语言描述语言OWL-SA基于OWL-S[23]的,其采用切入点-通知模型(pointcut-advicemodel).其中,A表示方面(Aspect),其代表的是演化的需求规格,它包括一个或多个切入点-通知对(pointcut-advicepairs).OWL-SA的元模型如图4所示.Page8切入点-通知对中的切入点用于描述演化的位置.其中定义两种类型的切入点:(1)控制制导切入点,即原过程模型中的某节点或其附近的位置.其描述形式如下:services/owl-s/1.1/Process.owl#TheParentPerform”〉〈fromProcessrdf:resource=“rdf:resource=#http://www.daml.org/services/图5需求演化脚本7架构模型的自适应根据5.2节的设计决策的输出(待触发的运行//process:CompositeProcess[@rdf:ID=“CP1”]//process:perform[@rdf:ID=“Step1”].(2)数据制导切入点,即切入的过程将改变原过程模型的数据,比如输入、输出参数,其描述形式如下://process:CompositeProcess[@rdf:ID=“CP1”]//process:hasInput[@rdf:ID=“I1”].切入点-通知对中的通知用于描述演化的内容.其包括:切入点附近插入、删除和修改过程,或是在过程中增加的输入输出参数,通常情况下是由控制结构Perform触发.通知与切入点之间的关系用advice的一个属性evolutionOrder来表示,其值有4种:Before(前面)、after(后面)、parallelTo(并行)和Around(替换).回到1.1节的场景B中,假设负载达到顶峰后开始下降.受需求演化的诱导,被跳过的欺诈检查将被业务部门恢复.该需求演化脚本如图5所示.时的模型转换),系统可以自动产生计划脚本.脚本紧接着被传到执行引擎,而引擎则使用反射的方法,将变更对应的插件织入到系统中,从而完成架构模型的自适应.Page97.1基于插件架构的元模型系统的弹性机制是通过切换在插件扩展点上的支持不同计算模型的插件来完成的.其计算模型包图6基于插件架构的元模型其中,扩展点接口(Pluggable)用于定义扩展点.扩展点(Extensionpoint)是系统中可以被再次扩展的接口,它可以使得执行过程变得可插入,可以任意变化.扩展点实现扩展点接口.扩展(Extension)是针对扩展点的实现,每个扩展都可以拥有自己的额外属性,用以区分同一个扩展点不同的实现.插件(Plugin)包含了插件依赖关系,运行时库和插件描述符.插件描述符(PluginDescriptor)包含了插件的名称id版本等信息.插件工厂(PluginRepository)用来产生插件实例.下面给出一个基于插件架构的实例(如图7).〈pluginid=“order-verification-basic”version=“1.0.0”provider-name=“CloudCRM.org”〉〈runtime〉〈libraryname=“order-verification.jar”〉〈exportname=“”/〉〈/library〉〈/runtime〉〈requires〉〈importplugin=“order-extensionpoints”/〉〈/requires〉〈extensionid=“org.CloudCRM.order.verification.basic”〈implementationid=“BasicOrderVerification”class=“org.CloudCRM.order.verification.basic.parallel”/〉〈/extension〉〈/plugin〉7.2计划脚本的生成描述语言OWL-SA不仅能用于支持需求演化,括串行和并行.本文利用插件架构形成支持不同计算模型统一框架.下面给出了基于插件架构的元模型,如图6所示.还能够用到运行时的模型转换中.我们将其扩充以支持变更操作:增加或删除插件扩展点、增加或删除插件、关联插件扩展点与插件,替换插件等.根据4.2节的设计决策的输出(待触发的运行时的模型转换),系统使用替换插件操作:使用Xpath来定位文档树中的插件扩展点,修改其下的插件节点,从而产生新的计划脚本.回到1.1节的场景A中,系统能够自动生成计划脚本(如图8).〈Aspectname=“FraudChecking”〉〈pointcutname=“CreditChecking”〉process:CompositeProcess[@rdf:ID=“OrderVerificationProcess”]process:perform[@rdf:ID=“CreditChecking”]process:ExtensionPoint[@rdf:ID=“CreditCheckingArchitecture”]〈/pointcut〉〈adviceevolutionOrder=“after”〉〈Performrdf:ID=“FraudCheckingPerformed”〉〈processrdf:resource=“&aux;#FraudChecking”/〉〈Extensionpointrdf:ID=“FraudCheckingPerformed”〉〈/Extensionpoint〉〈/Perform〉〈/Aspect〉该脚本由执行引擎执行,切换在插件扩展点上的支持不同计算模型的插件.7.3计划脚本的执行执行引擎通过执行计划脚本重新配置运行系统来实现运行时的模型转换.详细过程如下:系统利用载入内存并已经初始化过的插件工厂Page10生成相关插件实例:通过插件的id定位并读取计划脚本中相应的插件描述符配置项,进而使用反射机制生成插件实例.紧接着我们通过插件实例调用实现支持不同计算模型的方法,进而生成一组任务,并将其传到并行计算系统上去执行.计划脚本的执行的代码如图9所示.publicclassparallelextendsverification.basic{Configurationconf=null;PluginRepositoryrepo=null;PluginDescriptord=null;ClassLoadercl=null;StaticClassclazz=null;StaticMethodm=null;publicparallel(){conf=Configration.create();repo=newPluginRepository(conf);d=repo.getPluginDescriptor(“BasicOrderVerification”);cl=d.getClassLoader;try{clazz=Class.forName(“org.CloudCRM.order.verification.basic.parallel”,true,cl);}catch(Exceptione){System.err.println(“cannotloadtheclass‘parallel’”+e.get-Message());return;}}try{m=clazz.getMethod(“verify”,newClass[]{Class.forName(“org.CloudCRM.order.verification.basic.parallel”)});}catch(Exceptione){System.err.println(“cannotloadtheclass‘parallel’”+e.get-Message());return;}}try{result=m.invoke(clazz.newInstance());}catch(Exceptione){System.err.println(“cannotloadtheclass‘parallel’”+e.get-Message());return;}}}8实验评估8.1实验设计本文使用了综合需求模型和架构模型的驱动方法,扩展了课题组现有的SaaS平台(CloudCRM客户关系管理云服务平台).该平台基于RGPS元模表1不同模型驱动方法的性能比较方法StaticReqArchSAPC型框架,通过对开源软件SuperCRM进行服务化改造来构建,其支持多租户.该平台的配置环境如下:(1)该集群包括18个节点,每个节点有64位8核CPU和16GBRAM.(2)所有节点都用CentOS6.2,Java1.6.022.(3)数据库采用mongodb2.0.8.为观察平台在不同模型驱动方法的性能表现,本文对于该平台进行了剪裁,构造了4种由不同模型驱动的系统,具体见8.2节.为观察平台在不同状况下的性能表现,本文可以设置或调整如下参数:模拟并发用户的数目、需求目标集合的大小(goalsize)、插件扩展点的数目(extensionpointssize).当前实验参数设置如下:模拟并发用户的数目设置为20或200,目标集合的大小设置为21,插件扩展点的数目设置为8.8.2比较方法本文对比了以下4种不同模型驱动方法:(1)不支持自适应的方法Static.(2)基于需求模型的自适应方法Req.(3)基于架构模型的自适应方法Arch.(4)综合需求和架构模型的自适应方法SAPC.8.3实验结果分析为了避免实验结果的随机性,我们重复该实验50次,对获得的性能指标求均值.实验结果如表1,其中性能指标包括全局响应时间(Response-time)、吞吐量(Throughput)和可靠性(Reliability).详细分析如下:(1)从表中可知,我们的方法与其他方法相比获得了更好的性能.(2)当模拟并发用户的数目从20增加到200时,变得响应时间变长,吞吐量更高,可靠性则降低了.(3)当模拟并发用户的数目从20增加到200时,不同的方法会有不同的表现.例如,Static方法的响应时间从1473.92ms变化到157644.33ms,而SAPC方法的响应时间则从676.35ms变化到731.43ms.这表明,综合了需求和架构自适应的方法起了作用,达到更好的性能.Page118.4进一步讨论8.4.1时间序列预测采用不同变换对系统性能的在这个实验中,参数设置为:模拟并发用户的数目设置为200,其他同8.1节.从表2可知,由于小波(Wavelet)变换分析相较于傅里叶(Fourier)变换有较好的预测精度,在系统中采用小波变换分析获得了较好的性能.方法FourierWavelet8.4.2综合需求和架构模型不同驱动方法的性能目前在综合需求和架构模型方面具有代表性的模型包括Kramer等人[18]的模型、Sykes的模型MBP[16]、Tajalli等人[17]的模型PLASMA.下面我们通过实验来验证同上述几种方法相比,我们的方法SAPC的有效性.在这个实验中,参数设置为:模拟并发用户的数目设置为200,其他同8.1节.从表3可知,由于图10目标集合的大小对性能的影响8.4.4插件扩展点的数目对性能的影响在这个实验中,我们逐步改变插件扩展点的数目从3到12,每步为3.其他参数设置为:模拟并发用户考虑了时间序列规律,我们的方法与其他综合需求和架构模型的驱动方法相比获得了最好的性能.表3综合需求和架构模型不同驱动方法性能比较方法Kramer’smodelMBPPLASMASAPC8.4.3目标集合的大小对性能的影响在这个实验中,我们逐步改变目标集合的大小从3到24,每步为3.其他参数设置为:模拟并发用户的数目设置为20或200,插件扩展点的数目设置为8.图10(a)~(c)表明的是当并发用户的数量是20时的影响,而图10(d)~(f)表明的是当并发用户的数量是200时的影响.图10表明:在不同大小的目标集合下,SAPC方法都符合响应时间和吞吐量增加而可靠性下降现象.当模拟并发用户的数目扩大时,对于不同性能指标影响幅度不同(吞吐量幅度最大而可靠性幅度最小).的数目设置为20或200,目标集合的大小设置为21.图11表明:在不同插件扩展点的数目下,SAPC方法对于性能的影响同8.4.3节.Page12图11插件扩展点的数目对性能的影响9结论本文提出了一个通过预测控制的自适应方法(SAPC),其采用了综合需求和架构的模型来驱动系统的自适应.通过分析日志信息,学习基于小波变换的模型以预测未来时刻服务单元的QoS;通过基于预测控制产生设计决策,诱导需求进化或进行运行时的模型转换.大量实验的结果显示我们的方法的有效性.在未来,我们计划更进一步研究基于预测控制模型,在支持需求演化的元模型中加入验证机制,提取更多的状态信息以改进方法,以及从用户满意度等更多的方面评估该方法.
