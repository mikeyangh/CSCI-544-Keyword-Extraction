Page1面向可信移动平台具有用户可控关联性的匿名证明方案岳笑含1)周福才2)林慕清1)李福祥1)1)(东北大学信息科学与工程学院沈阳110004)2)(东北大学软件学院沈阳110004)摘要针对可信移动平台(TrustedMobilePlatform,TMP)远程认证方式中直接匿名证明方案存在的性能瓶颈、R攻击以及跨信任域问题,提出了一种新型的具有用户可控关联性的匿名证明(AnonymousAttestationwithUser-controlled-linkability,TMP-UAA)方案.通过引入可信第三方CA构建了方案的模型,该模型可以有效解决传统直接匿名证明设计中存在的R攻击和跨信任域问题,且易于部署实现.根据提出的方案模型,首先利用Paillier加密系统及可验证加密技术设计了一个安全两方计算协议,该协议用于实现TPM-UAA方案中的Join协议;其次运用该协议并结合提出的l-MSDH假设和XDH假设给出了方案的具体设计;然后在随机预言模型下对方案的安全性进行了证明,证明表明该方案满足用户可控匿名性以及用户可控可追踪性;此外在性能方面与现有直接匿名证明方案相比,该方案具有更短的签名长度以及更高的计算效率;最后阐述了TPM-UAA方案在可信移动环境下的跨域证明,该证明避免了传统直接匿名证明存在的跨信任域及R攻击问题.关键词匿名证明;可信移动平台;移动可信模块;跨信任域;R攻击;用户可控关联性;移动互联网1引言随着计算能力及普适网络结点的不断增长,移动设备(例如智能手机、平板电脑、PDA、笔记本电脑等)的计算环境变得更加开放和通用,这促使越来越多的服务及应用被开发并部署到这些移动设备中,同时也导致了移动设备的安全性受到来自各个方面的威胁.面对移动设备的异构性、应用环境的复杂性以及利益相关者(stakeholder)的多样性,在PC机上传统的安全保障措施变得难以适用,也无法从根源上解决安全问题.为此可信计算组织[1-2](TrustedComputingGroup,TCG)针对移动平台的特性,成立了移动电话工作小组(MobilePhoneWorkGroup,MPWG)并于2007年发布了移动可信模块(MobileTrustedModel,MTM)标准①,旨在移动设备上建立可信执行环境来确保移动平台的安全性.同时MPWG针对移动设备发布了更加通用的安全体系结构标准,称为TCG移动参考体系结构②(TCGMobileReferenceArchitecture,MRA),标准定义了可信移动平台(TrustedMobilePlatform,TMP)体系结构,该体系结构由一系列抽象的抗干扰可信引擎(TrustedEngine,TE)及MTM模块组成,并用不同的TE代表不同的利益相关者,这种灵活性与模块化并重的设计思想为移动设备安全体系架构的实现提供了重要的借鉴意义.由于MTM的标准是对TPM标准[3]的继承和扩展,因此提供了可信计算技术的多种核心功能,其中就包括了最重要的远程认证功能,这种远程认证实则上是为确保平台隐私性而对MTM模块的远程匿名认证,即向验证者证明该可信移动平台上存在MTM的真实性.出于隐私保护,MTM标准提供了两种可选的匿名证明方案:基于隐私CA匿名证明及直接匿名证明(DAA).起初基于隐私CA的匿名证明方案存在没有可参考的商业模型以及效率瓶颈等问题.2004年,Brickell、Camenisch和Chen[4]提出了一种新型的匿名证明方案,即直接匿名证明(DirectAnonymousAttestation,DAA)方案,该方案被TCG纳入到MTM标准中.从密码学角度来讲,DAA是一种特殊的群签名原型,能够在保障用户隐私的前提下提供远程证明功能.DAA方案[4]的参与者有3类:发布者、签名者及验证者.签名者由TPM/MTM及平台主机/可信引擎构成,其中真正的签名者是TPM/MTM.由于自身资源较小,需要主机/可信引擎辅助执行DAA方案.DAA方案主要由加入协议和签名协议组成,加入协议用于向发布者申请DAA证书,签名协议用于产生DAA签名.在安全性方面与群签名的完全匿名性(FullAnonymity)、完全追踪性(FullTracea-bility)等安全性需求不同,DAA提供了用户可控的匿名性(User-controlledAnonymity)及用户可控追踪性(User-controlledTraceability).造成这种不同的主要原因是:DAA是一种可协商匿名性方案,即用户与验证者通过对基名(basename)的协商来控制该用户生成的DAA签名是否可以相关联(Link-ability),方案取消了群签名中的Open算法,取而代之的是Link算法.然而针对资源有限的可信移动平台,原有DAA方案[4]高昂的计算代价会带来方案性能上的瓶颈并降低移动设备的实用性.另外在实际部署中还存在R攻击[5]以及跨信任域问题[6],这些问题会导致可信计算技术无法应用于移动终端.因此有必要设计面向可信移动平台的新型匿名证明方案来解决DAA方案中存在的问题.2相关工作围绕提高DAA性能的问题,众多学者和机构分别提出了不同的解决方案.目前,提出的DAA方案可以分为两类:一种是基于RSA假设的DAA方案[4,7-8];另一种为基于椭圆曲线密码学的DAA方①②Page3案.同等安全级别下,基于椭圆曲线的DAA方案在计算效率及通信性能上要比基于RSA假设的DAA方案高.在文献中可以找到的基于椭圆曲线的DAA方案共有8个.按所基于的安全性假设,以上8个方案可分为两类:基于LRSW和DDH或DBDH假设的方案[9-14]以及基于l-SDH和DDH假设的方案[15-16],其中性能最好的DAA方案是由Chen等人[12]提出的.但由于移动设备资源有限,有必要探索新的方法来构建一种性能更好、适用于可信移动平台的匿名证明方案.上述的直接匿名证明方案仅是对性能问题的研究,然而在部署实现过程中会遇到各种问题.由于DAA方案的匿名证明具有“直接性”,即无需可信第三方参与的直接证明,这种直接性会造成以下两个问题:一是由Rudolph提出的隐私性攻击,简称R攻击[5-6],该攻击的思想是在成员加入阶段恶意发布者可以生成不同的发布者公钥,与不同的MTM身份标识(EK证书)一一绑定,在DAA签名验证阶段,验证者与发布者合谋就可以通过与MTM绑定的公钥来唯一锁定可信平台身份,导致平台用户的隐私遭到破坏,造成这种攻击的主要原因是发布者公钥的合法性得不到验证;二是跨信任域问题,由于DAA属于特殊的群签名方案,所以不同的发布者、签名者及验证者形成的群域之间就存在信任的问题[17],导致域中的验证者无法验证其它域中签名者生成的DAA签名,这是因为其它域中发布者的公钥合法性得不到验证.在移动环境中这个问题尤为突出,由于移动设备很容易从一个区域到另一个区域甚至从一个国家到另一个国家,这样会导致移动设备的可用性受到限制.文献[6,17]分别给出了这两个问题的解决方法,但这两种解决方法一方面非常复杂并且需要加入多个可信实体,难以部署实现,另一方面对于移动终端这种资源有限的设备,性能也大为降低.因此如何设计一种具有可部署性且可避免以上两个问题的匿名证明方案是一个挑战性问题.针对上述挑战,本文面向可信移动平台综合考虑了实用性及安全性,提出了面向可信移动平台具有用户可控关联性的匿名证明方案(AnonymousAttestationwithUser-controlled-linkability,简称TMP-UAA).本文的主要贡献如下:(1)针对R攻击和跨信任域的问题,借鉴公钥基础设施PKI的构架思想设计了一种合理且具可部署性的TMP-UAA模型,该模型可以有效解决R攻击和跨信任域问题;设,并对其进行了归约性证明;(2)提出了一个新的密码学假设,l-MSDH假(3)由于加入协议运行次数远小于签名协议运行次数,因此构建了一个在加入阶段使用的安全两方计算协议,利用该协议生成的UAA证书可以最小化签名协议的计算代价及签名长度;(4)基于TMP-UAA模型,给出了方案具体步骤,并在随机预言模型下对该方案的安全性进行了证明.在128bit安全级别下,对提出的TMP-UAA方案性能进行了详细的分析比较.本文第3节介绍TMP-UAA方案设计所需要的密码学假设及工具;第4节设计TMP-UAA模型及其安全模型;第5节构建TMP-UAA方案中加入(Join)阶段所需的两方计算协议;第6节对提出的TMP-UAA方案进行具体的构建;第7节对TMP-UAA方案的安全性及性能进行详细证明及分析;第8节基于提出的TMP-UAA模型详细阐述移动环境下跨信任域问题的解决方法;第9节总结全文.3密码学假设及工具3.1双线性配对令G1、G2是两个p阶循环群,其中p为素数,g1,g2分别是G1、G2的生成元.定义两个群上的双线性映射为e:G1×G2→GT,且满足下面的性质:a,b∈位元;双线性.e(ga非退化性.e(g1,g2)≠1GT,其中1GT是GT的单可计算性.存在有效算法来计算t=e(g1,g2).文献[18]将目前在密码学中使用的配对分为3种类型.本文方案使用第3种配对,即G1≠G2且G1和G2之间不存在有效可计算的同态.3.2密码学假设定义1.DDH(DecisionalDiffie-Hellman)假设.该DDH难题在群G1=〈g1〉中的定义如下:以四元组(g1,ga率多项式时间算法能够以不可忽略的概率ε判断c是否等于a·b.定义2.XDH(eXternalDiffie-Hellman)假设.对于一个非对称双线性配对e:G1×G2→GT,若DDH难题在群G1中是困难的,那么该XDH假设成立.Page4定义3.l-SDH(l-StrongDiffie-Hellman)假设.该l-SDH假设在群(G1=〈g1〉,G2=〈g2〉)中定义如下:以(l+2)个元组(g1,g2,gx2作为输入,不存在一个概率多项式时间算G1×Gl+1法能够以不可忽略的概率ε输出一个二元组(A,c),使得e(A,g(x+c)下面将给出一个改进的SDH假设.定义4.l-MSDH(l-ModifiedStrongDiffie-Hellman)假设.该l-MSDH假设在群(G1=〈g1〉,G2=〈g2〉)中定义如下:以(l+2)个元组(g1,g2,gx2,…,gxlgx2多项式时间算法能够以不可忽略的概率ε输出一个三元组(Ac,A,c),使等式e(A,gx成立,其中c∈很显然对于任意l1在同样的双线性群中,l-SDH难题的困难性蕴涵了l-MSDH难题的困难性,该难题的归约性证明如下.证明.假设有敌手可以在概率多项式时间内输出一个l-MSDH的实例,那么就存在概率多项式时间的模拟器能够解决l-SDH难题.给定如下参数,G1=〈g1〉,G2=〈g2〉,其中g1=λ(g2),λ是群G2到群G1的同态以及(l+2)个元组(g1,g2,gx2,…,gxlgx2互过程如下:··=λ(珟g2)=λ(gZ(1)选择随机数α∈p以及ci∈Rp,i=1,…,l-1,然后利用l-SDH难题的(l+2)个元组,可以获得珟g1值得注意的是Z≠0,若Z=0即存在x=-ci,无需的帮助就可以解决SDH难题.将公钥(珟g1,g2,Ω··=gx(2)对于的第i次质询,假设质询次数为qA<l,返回一个MSDH实例,计算MSDH实例如下:计算(Aciα·∏q-1j≠i,j=1.显然可以验证等式成立:e(Bi,Ω)=e(珟g1/Bi,g2)=e(gZ-ci·Yi1,g2)(3)经过qA次质询后,输出一个MSDH实例(B·,B··,c),其中c≠ci,i∈{1,…,qA}且验证等式(4)若验证通过,即有B·=gc·Z/(x+c)1,令Z=α·(X(x)(x+c)+C),其中X(x)为gZ/(x+c)l-1阶关于x的多项式,C为一个可计算的常数,对于B··即有A=((B··)1/α·g-X(x)(A,c)作为对SDH难题的解.3.3Paillier密码系统Paillier密码系统[19]具有加同态(AdditiveHomomorphic)及自盲化(SelfBlinding)等性质,常用于构建各种密码协议.该密码系统由以下3个算法组成:P-KeyGen(1k):输入安全参数1k,选择两个随机k-bit素数P和Q,并置N=PQ.随机选择一个数g,g要满足gcd(L(gλ(N)modN2),N)=1,其中函数L(u)=(u-1)/N,λ(N)=lcm(P-1,Q-1),选择一个随机数a∈R在模N2下的阶为λ(N).加密系统公钥为(N,g,h),私钥为(P,Q).P-Enc(m):输入消息m∈N,选择随机数r∈N,计算密文c=gm·hrmodN2.P-Dec(c):输入密文c∈另外,Paillier加密系统加同态可以形式化表示(L(cλ(N)modN2)/L(gλ(N)modN2))modN.为P-Dec(P-Enc(m1)·P-Enc(m2))=m1+m2.3.4可验证加密可验证的加密[20](VerifiableEncryption)是构建多方计算协议的常用密码学工具之一,允许任何实体验证加密的消息和先前承诺的秘密值一样,但不会泄露明文的任何信息.安全的可验证加密满足三种性质:完备性(Completeness)、有效性(Soundness)和零知识性(Zero-Knowledge).4面向可信移动平台的匿名证明模型4.1TMP-UAA模型描述括:发布者、签名者者.下面对各参与者进行说明:TMP-UAA模型如图1所示,其中参与实体包发布者(Issuer,):可为移动设备生产厂商,生成发布者公私钥并为移动可信模块颁发UAA证书;成立;签名者(Signer,部分组成:可信引擎及移动可信模块),能够使Page5发布者确信其拥有一个合法的MTM并获取UAA证书,以此证书来向验证者证明该平台为可信移动平台;证书颁发中心(CertificateAuthority,):作为可信第三方(TrustedThirdParty,)提供发布者公钥证书的颁发、验证以及下载等功能,另外的一个职能是为加入协议提供RSA公钥参数;验证者(Verifier,):通常为服务提供者,通过下载发布者公钥证书来校验由签名者生成的UAA签名.值得说明的是,在为发布者颁发公钥证书之后不再参与TMP-UAA方案,而其它实体均直接参与TMP-UAA方案,该方案包括了以下算法及协议:(1)Setup(1k):输入安全参数1k,使用随机化(randomized)算法生成公私钥对(IPK,ISK),将生成的部分IPK公钥及相关资格凭证等交由验证,验证发布者合法性并为其颁发发布者公钥证书;(2)Join(ISK,IPK,f,params2PC):不同于现有DAA方案加入协议的构建方法,该加入协议基于安全两方计算协议,及各自输入秘密值ISK及f并运行基于公共参数(IPK,params2PC)的两方计算协议,最后获得由颁发的UAA证书Cre;(3)Sign(IPK,m,bsnV,f,Cre):以私钥f、证书Cre、验证者基名bsnV、消息m以及发布者公钥IPK作为输入,及使用随机化算法生成关于消息m的UAA签名σ并发送给,值得说明的是bsnV用于控制UAA签名的关联性;(4)Verify(m,bsnV,σ,IPK,RL):以消息m、UAA签名σ、验证者基名bsnV、发布者公钥IPK以及对应信任域的撤销私钥列表RL为输入,运行确定性(deterministic)算法判定签名是否有效,并输出1(有效),0(无效).需要说明的是,如何建立RL列表不在本文讨论范围之内;(5)Link(σ0,σ1,bsnV,IPK):当bsnV为非空时,使用确定性算法来判定两个签名并输出:1(相关联)表示两个UAA签名由同一签名者产生;0(不关联)表示由不同签名者产生;⊥(无效)表示签名σ0或σ1是无效的.在本文第2节中阐述了造成R攻击以及跨信任域问题的原因,即发布者公钥合法性得不到验证.而在上述TMP-UAA模型中公钥的合法性由来保障,一方面避免了恶意发布者滥用公钥而导致R攻击产生的问题;另一方面,无论验证者在任何信任域中均可通过验证不同发布者公钥证书的合法性,实现了验证者域无关性,同时也有效解决了跨信任域问题,关于该问题的进一步阐述见第8节.4.2TMP-UAA安全模型(1)正确性如果签名者与验证者都是诚实的,意味着签名者私钥fRL,那么由该签名者所生成的签名以及签名之间的关联都可被验证者以压倒性的概率验证通过.这表明本文所提出的算法及协议必须满足一致性需求.其形式化表示如下:若Setup(1k)→(ISK,IPK),Join(ISK,IPK,f,params2PC)→(f,Cre),以及Sign(IPK,m,bsnV,f,Cre)→(m,σ),则必有Verify(m,bsnV,σ,IPK,RL)→1以及Link(σ0,σ1,bsnV,IPK)|bsnV≠⊥→1成立.(2)用户可控匿名性TMP-UAA方案提供了用户可控匿名性(user-controlledanonymous),这个概念需要满足以下两个性质,非形式化描述如下:匿名性(anonymity):敌手在不知道签名者私钥的前提下,即使可以获取发布者的私钥及签名者的UAA证书,也难以通过签名值来揭示签名者的身份.用户可控不可关联性(user-controlledunlink-ability):给定σ0和σ1是分别关于不同非空基名bsn0和bsn1的签名,敌手在不知道签名者私钥的前提下,难以通过签名值来揭示这两个签名是由同一个签名者产生的.可以通过敌手与挑战者之间的游戏来形Page6式化定义用户可控匿名性的概念.私钥对(IPK,ISK)发送给.Initial.运行Setup(1k)算法,并将生成的公JoinInitial.由于Join协议基于两方计算协议,其安全性模型与Sign协议相独立,因此为确保该游戏的进行,将在该阶段初始化一个足够大的UAA证书列表LCre.ID对应的签名者私钥作为对的响应.Phase1.对进行如下质询:①Join-Corrupt.为确保能获取关于每个签名者身份标识ID的UAA证书,可以进行JoinCorrupt质询,将从LCre中选择一个UAA证书作为关于该ID的返回值.②Sign.提交它所选择签名者的ID以及基名bsnV(等于⊥或者字符串)和消息m,运行Sign协议并将UAA签名值σ发送给.③Corrupt.提交它所选择签名者的ID,将Challenge.在第一阶段结束后,选择两个签名者的身份标识ID0及ID1,消息m和它所选择的基名bsnV(等于⊥或者字符串)提交给.这里必须要保证没有对ID0及ID1进行过Corrupt质询,并且在bsnV≠⊥的情况下没有用同一个bsnV对ID0及ID1进行过Sign质询.选择ψ∈R{0,1}并对消息m运行Sign协议,并将得到的签名值σψ作为挑战值发送给.Phase2.用与Phase1同样类型的质询继续询问,这个阶段必须要保证其不允许对ID0及ID1进行Corrupt质询,以及要保证在bsn≠⊥的情况下没有用同一个bsnV对ID0及ID1进行任何Sign质询.Response.返回一个比特值,当=ψ时称定义5.敌手破坏用户可控匿名性游戏的赢得了该游戏.优势记为Adv[任何概率多项式时间敌手,Adv[的,那么称TMP-UAA方案具有用户可控匿名性.(3)用户可控追踪性TMP-UAA方案提供了用户可控追踪性,该安全性定义继承了群签名完全追踪性(fulltraceability)中的不可伪造性及抗合谋性,但在追踪算法上用Link算法代替了群签名的Open算法.其定义非形式化描述如下:不可伪造性(unforgeability):敌手在不知道发布者私钥的情况下,即使它获取了关于签名者UAA证书及私钥的一个集合,它也很难伪造一个有效的UAA签名,且生成该签名所使用的证书及私钥不在上述集合中.用户可控关联性(user-controlledlinkability):给定敌手一个非空基名bsnV,敌手难以伪造关于相同签名者的两个不同签名,使得Link算法的输出为0.为形式化这个概念,通过敌手与挑战者之间的游戏来定义用户可控追踪性的概念.Initial.运行Setup(1k)算法,并将生成的公钥IPK发送给,并不泄露私钥ISK.JoinInitial.同定义5中的JoinInitial.Probing.对进行如下质询:①Join-Corrupt.同定义5中的Join-Corrupt.②Sign.提交它所选择签名者的ID以及基名bsnV(等于⊥或者字符串)和消息m,运行Sign协议并将UAA签名值σ发送给.③Corrupt.提交它所选择签名者的ID,将ID对应的签名者私钥作为对的响应,并将关于该ID的私钥放入RL中.Output.输出一个签名者ID,UAA签名σ,消息m以及基名bsnV.仅当以下两种情况发生时,称赢得了该游戏.①Verify(m,bsnV,σ,IPK,RL)→1,且该签名σ不属于已经Sign质询的响应集合;②敌手能够生成关于相同基名bsnV及ID的两个有效UAA签名σ0、σ1,使得关联算法Link(σ0,σ1,IPK)|bsnV≠⊥→0.定义6.敌手破坏用户可控匿名性游戏的优势记为Adv[概率多项式时间敌手,Adv[那么称TMP-UAA方案具有用户可控追踪性.5安全两方计算协议的构建TMP-UAA方案的Join协议基于两方计算协议,因此有必要在本节对该协议的构建进行具体阐述.文献[21]提出了一个安全两方计算协议,该协议使得用户最终得到一个由发布者签发的证书Cre··=g1/(isk+f)isk∈p是发布者输入秘密值,f∈p是用户输入秘密值.虽然文献[21]构建了该协议的安全模型并进Page7行了安全性证明,但是文中该协议只是形式化的描述并未对该协议进行实例化.因此本节利用Paillier同态加密系统[19]及可校验加密方法[20,22]实例化该协议.协议由3个实体构成:发布者、用户及可信第三方(在Join协议中为图1中的).值得说明的是,不直接参与该协议而仅提供可信的公共参数paramsT··={n,g,h},其中n=pq为RSA模数并且n2l·p2(l为安全参数),p和q是其他参与者所不知道的,g,h∈如下:(1)发布者生成Paillier加密系统所需的相关参数,{PK,SK}={(N,g,h),(P,Q)},其中N2k·p2.选取随机数r1∈RN计算密文e1··=P-Enc(isk)以及承诺值c1··=giskhrmodn,其中r∈Rn,将e1,c1发送给用户并进行如下知识证明:PK{(sk,r1,r):e1=giskhr1modN2∧c1··=giskhrmodn};(2)用户利用Paillier加同态的性质进行如下计算:首先选择两个随机数r2∈Rp,r3∈RN分别计算密文e2··=(e1)r2gf·r2hr3=g(isk+f)·r2hr1r2+r3modN2及承诺值c2··=gf·hrmodn,其中r∈Rn/p,并计算珚f··=f·r2及r-··=r2·r.用户将e2,c2发送给发布者,并进行如下知识证明:PK{(f,珔f,r2,r3,r-,r):e2··=(e1)r2gf-hr3modN2∧BilinearSetup(1k)→params(G1,G2,GT,p,e,g1,g2,h1),c2··=gf·hrmodn∧1=cr12/(gf-hr-)};(3)接收到e2,用私钥对e2解密得到明文m··=P-Dec(e2)=(isk+f)·r2,计算Cre··=1modp,并将Cre发送给用户;g1/m(4)用户计算Cre··=(Cre)r2=g1/(isk+f)该2PC协议的安全性由文献[21]提出的2PC安全性定理及Paillier加密系统、PK知识证明系统的安全性保证,其中Paillier加密系统和知识证明协议的安全性证明分别参见文献[19,22].上述协议的安全性确保了发布者获取不到关于用户私钥f的任何信息,可以有效保障用户隐私.6TMP-UAA方案6.1初始化(Setup)输入安全参数1k,该初始化算法执行如下:(1)发布者产生公共参数:其中p代表群G1,G2和GT的素数阶,e代表一个配对函数e:G1×G2→GT,g1是群G1中的生成元,g2是G2群中的生成元;(2)发布者选择以下4个Hash函数,分别是H0:{0,1}→p,H1:{0,1}→G1,H2:{0,1}→p,H3:{0,1}→p,并选择私钥ISK··=γ∈R计算Ω··=gγ;(IPK,ISK)··=((G1,G2,GT,p,e,g1,g2,H0,H1,H2,H3,Ω),γ);(4)发布者将公钥IPK经由安全通道发送给,根据该名发布者的相关信息颁发公钥证书CertIPK.(3)发布者输出公钥及私钥为值得说明的是,在实际的实现设计中对于步(2)中Hash函数H0,H2,H3可使用同一个Hash函数,这里将其标识为不同的Hash函数是为方便第7节的安全性证明.6.2加入(Join)协议本小节所提出的加入协议基于第5节提出的安全两方计算协议,协议参与者为发布者以及移动可信模块并各自以一个秘密值作为输入,最后获得发布者为其颁发的UAA证书.首先为确保与发布者通信的MTM是真实的,需要在两者之间建立一条单向真实通道(one-wayauthenticchannel),TCG推荐[1]的一种方法是利用MTM的EK(背书密钥)公钥加密发布者向所发送的每条信息,发布者与按如下步骤进行:(1)获得发布者的公钥证书CertIPK后,验证该公钥证书的合法性,然后利用MTM的内部密钥种子DAAseed值以及发布者的公钥IPK来生成秘密值f··=H0(DAAseed‖IPK);(2)与分别以f和ISK=γ作为秘密输入值,并分别扮演2PC协议中的用户及发布者运行本文第5节中所提出的两方计算协议;(3)通过两方计算协议得到发布者所颁发的UAA证书Cre··=g1/(γ+f)((Cre)f,Cre)=(gf/(γ+f)校验e(A,Ω)=e(g1/A,g2)是否成立.最后存储(A,A),将f加密保存在MTM的非易失性存储区内.6.3签名(Sign)协议验证者,协议按如下步骤进行:该协议的参与方为MTM,可信引擎以及Page8(1)为确保消息的新鲜性,首先发送一个随机值nV←{0,1}ln给;(2)选择随机数r∈Rp,计算T1··=Ar,T2··=Ar,T3··=gr(3)若的基名(basename)有bsnv≠⊥,则需要计算B··=H1(bsnV)∈G1并令V··=T2·B,否则令B··=⊥,V··=T2,然后将(T2,B,c,m,bsnV)发送给;(4)若bsnv≠⊥计算K··=Bf,否则令K··=⊥,然后选择一个随机数rf∈p计算U··=Vrf以及c··=H3(c‖K‖U‖bsnV‖m‖nM),nM→(0,1)ln;(5)计算sf送给;(6)将签名值σ··=(T1,T2,T3,K,c,sf,nM)发(1)校验发布者公钥证书的合法性并检查T1,送给验证者.6.4验证(Verify)验证者接收到TMP的签名值σ及消息m后,利用发布者的公钥IPK及撤销列表RL(已撤销私钥f的列表)进行如下校验:T2,T3,K是否属于G1,及sf是否属于p;(2)对于每个f∈RL校验是否有T1=Tf(3)验证等式e(T2,Ω)=e(T3/T1,g2)是否成立;(4)若bsnV≠⊥令B··=H1(bsnV)计算V··=T2·B以及W··=T1·K,否则令V··=T2及W··=T1·计算U··=Vsf·W-c,校验c是否等于H3(H2(T1‖T2‖T3‖nV)‖K‖U‖bsnV‖m‖nM);绝),否则输出1(接受).6.5关联(Link)非空基名bsnV以及公钥IPK,关联方法如下:输入两个消息-签名对(m0,σ0)和(m1,σ1),一个(1)对于上述每个签名运行验证算法,若算法(5)若以上任意步骤校验失败,输出0(拒(2)若(B,K)∈σ0与(B,K)∈σ1相同,则返回1返回值为0,则该关联算法返回⊥(无效);(关联);否则返回0(不关联).7安全性及性能分析7.1安全性分析基于第4节提出的安全性模型,本节对本文提出方案的安全性进行分析.一个TMP-UAA方案必方案满足正确性.须满足以下安全性质:正确性、用户可控匿名性及用户可控追踪性.(1)正确性定理1(正确性).本文所提出的TMP-UAA证明.验证算法Verify以及关联算法Link的正确性可直观得出.(2)用户可控匿名性定理2(用户可控匿名性).TMP-UAA方案提供了用户可控匿名性,如果存在一个敌手以不可忽略的概率区分出不同签名者所产生的签名值,那么就存在一个概率多项式时间的模拟器能够以不可忽略的概率解决XDH难题.在TMP-UAA方案中,对于bsnV值为空或非空的情况有两种形式的签名,对于这两种情况的签名值在XDH难题假设下将分别以引理的形式证明它满足用户可控匿名性.TMP-UAA签名满足匿名性.引理1.当bsnV=⊥时,在XDH假设下证明.给定模拟器一个XDH的实例,即(u,v=ua,w=ub,z),其中u∈G1,a,b∈p以及z=uab或者z∈RG1,为判断所给定的z属于哪种情况与进行如下交互:Initial.运行Setup(1k)算法,生成发布者公私钥对IPK,()ISK=((G1,G2,GT,p,e,g1,g2,H0,H1,H2,H3,Ω),γ),并将该公私钥对发送给.对于的质询,为确保响应的一致性建立如下3个列表:LH3存储对随机预言H3的质询值及响应值;LC存储对Corrupt的质询及响应值,表项关键字为(ID,f,CreDAA,d),其中d若等于1表示对应的签名者被Corrupt质询,d等于0则表示对应签名者未被Corrupt质询;LS存储对Sign的质询及响应值,表项关键字为(ID,m,σ).在模拟的开始阶段各个列表均为空.在的质询过程中,用qH、qJC、qS、qC分别表示对Hash函数、Join-Corrupt、Sign及Corrupt的质询次数.Join-Initial.生成了一个足够大的UAA证书列表LCre··={(Crej,fj)}={(g1/(γ+fj),fj)}|j∈{1,…,n},其中qJC<n<l.Hash质询.令H3为随机预言,如果输入的字符串str之前没有被质询过,那么从p中均匀选取一个随机数将其作为对的返回值并将该值及str存放到LH3中,否则返回之前对字符串str在Page9LH3中对应的结果以确保结果的一致性.Join-Corrupt质询.提交一个签名者的ID,随机选择i←{1,…,qJC}并分两种情况对进行响应.Case1.当该质询为第i次质询且i≠i,从LCre列表中选取一个表项并将表项中的UAA证书Cre作为对的返回值,并将该表项从LCre删除,将(IDi,fi,Crei,d=0)写入列表LC中.Cre··=u并将其作为对的响应.Case2.当i=i时标记该ID为ID,令Sign质询.提交一个签名者的ID、消息m及随机值nV,并且关于该ID的签名者已经加入,同上要分以下两种情况对进行响应.Case1.如果ID≠ID,从列表LC中获取关于该ID对应的表项并运行Sign协议,将得到的UAA签名σ作为对的响应并存储(ID,m,σ)到LS中.Case2.如果ID=ID,则按以下步骤伪造一个UAA签名:①选择一个随机数r∈Rp,计算T1··=vr=ua·r,T2··=ur,T3··=vr·uγ·r=ur(a+γ)并令V··=T2,W··=T1;②选择nM→(0,1)ln以及c,sf∈Rp,计算U··=Vsf·W-c;③令str··=H2(T1‖T2‖T3‖nV)‖U‖bsnV‖m‖nM并通过设置H3(str)=c来修订(patch)随机预言H3,如果之前对str质询过,那么退出并输出ψ∈R{0,1};存储(ID,m,σ)到LS中.④输出签名σ··=(T1,T2,T3,c,sf,nV,nM)并Corrupt质询.如果提交的签名者ID≠ID,那么将LC表中对应该ID的私钥f作为返回值并置表项b=1,否则退出并输出ψ∈R{0,1}.Challenge.在挑战阶段,选择两个签名者的身份标识(ID0,ID1)以及消息m、随机值nV发送给.如果ID{ID0,ID1}且对ID0,ID1做过Corrupt质询,那么退出并输出ψ∈R{0,1},否则选择∈{0,1}使ID=ID并执行以下步骤生成关于ID的签名σ:①选择一个随机数r∈Rp,计算T1··=zr,T2··=wr,T3··=zr·wγ·r并令V··=T2,W··=T1;②其余的伪造步骤同上述Sign质询中Case2;③将挑战的签名σ发送给.综上,可以获得S对于XDH难题的判定优势Output.经过定义5中的两个阶段质询后,最后将输出关于该签名者ID的猜测值,如果=,那么输出它的判定ψ=1即判断出z=uab,否则输出ψ=0表示z∈RG1.下面对的判定优势进行评估,用ψ∈R{0,1}表示ψ=1时z=uab,ψ=0时z∈RG1.并用abort代表S退出的事件,即有Pr[ψ=ψ|abort]=1/2.假设S并没有退出,那么若ψ=0,表示z∈RG1,则该挑战签名σPr[ψ=0|abort∧ψ=0]=1/2;若ψ=1,表示z=uab,则S与A对上述真实游戏进行了完美的模拟并且A最终以概率ε正确地猜出了=,因此就有Pr[ψ=1|abort∧ψ=1]=1/2+ε.概率,如下:|Pr[S((u,v=ua,w=ub,z)∧(z=ua·b))=0]-Pr[S((u,v=ua,w=ub,z)∧(z∈RG1))=0]|=|Pr[ψ=0|ψ=1]-Pr[ψ=0|ψ=0]|=|1-Pr[ψ=1|ψ=1]-Pr[ψ=0|ψ=0]|=|1-Pr[abort]Pr[ψ=1|abort∧ψ=1]-Pr[abort]Pr[ψ=1|abort∧ψ=1]-Pr[abort]Pr[ψ=0|abort∧ψ=0]-Pr[abort]Pr[ψ=0|abort∧ψ=0]|=|1-Pr[abort](1/2+1/2)-Pr[abort]((1/2+ε)+1/2)|=Pr[abort]ε.Pr[abort]代表没有退出的概率,首先在Sign质询中在伪造签名时退出的概率至多为qH/p5,这是一个可以忽略的值;其次在Corrupt质询中,没有退出的概率为1/qJC;最后在挑战阶段,仅当A选择了ID∈{ID0,ID1}时才不会退出,这个概率为1/qJC.计算如下概率Pr[abort](1-qH/p5)·(1-1/qJC)·1/qJC,因此判定XDH难题的概率至少为ε·(1-qH/p5)·(1-1/qJC)·1/qJC.Initial.将LS表项关键字设置为(bsnV,ID,m,σ)TMP-UAA签名满足用户可控不可关联性.引理2.当bsnV≠⊥时,在XDH假设下证明.证明的思路同引理1,给定模拟器一个XDH实例,即(u,v=ua,w=ub,z),其中u∈G1,a,b∈p以及z=uab或者z∈RG1,为判断所给定的z属于哪种情况与进行如下交互:Page10Join-Initial.初始化过程与引理1相同.Hash质询.令H1、H3为随机预言,H3质询的定义同引理1.对于H1的质询随机选取一次质询索引i←{1,…,qH}以及取s∈Rp,设置H1(str)=ws.其它情况下选取s∈Rp,令H1(str)=us作为对的应答,并将r、字符串str及结果us存放到LH1中,如果质询的字符串str之前已经询问,直接返回LH1中对应的结果.Join-Corrupt质询.在该质询中提交一个签名者的ID,如果该质询为第i次质询,标记该ID为ID,由于不知道f=a=logvu,随机选择Cre∈RG1作为对质询的响应.其它情况,同引理1中的Case1.Sign质询.提交一个签名者的ID、基名bsnV、消息m及随机值nV,并且关于该ID的签名者已经加入,分以下两种情况对进行响应.Case1.如果ID≠ID,从列表LC中获取关于该ID对应的表项并运行Sign协议,将得到的UAA签名σ作为对的响应并存储(ID,m,σ,bsnV)到LS中.Case2.如果ID=ID,则按以下步骤伪造一①如果bsnV=str,退出并输出ψ∈R{0,1},否则从LH1中查找bsnV所对应的结果us及s值并计算K··=vs,令B··=us;②选择一个随机数r,t∈Rp计算T1··=(Cre)t·r,T2··=(Cre)r,T3··=(Cre)r(t+γ)并分别令V··=T2·B,W··=T1·K;个UAA签名:并添加一个Hash列表LH1存放H1的质询-响应值,其它初始化过程与引理1一致.③选择nM←{0,1}ln以及c,sf∈Rp,计算U··=Vsf·W-c;④令str··=H2(T1‖T2‖T3‖nV)‖K‖U‖bsnV‖m‖nM,通过设置H3(str)=c来修订(patch)随机预言H3,若之前对str质询过,那么退出并输出ψ∈R{0,1};⑤输出签名σ··=(T1,T2,T3,K,c,sf,nV,nM)并存储(ID,m,σ,bsnV)到LS中.Corrupt质询.如果提交的签名者ID≠ID,那么将LC表中对应该ID的私钥f作为返回值并置表项b=1,否则退出并输出ψ∈R{0,1}.Challenge.在挑战阶段,选择两个签名者的身份标识(ID0,ID1)以及消息m、基名bsnV、随机值nV发送给.如果ID{ID0,ID1}并且bsnV≠str,那么退出并输出ψ∈R{0,1},否则选择∈{0,1}使得ID=ID并执行以下步骤生成关于ID的签名σ:①从LH1中查找关于str的表项,并计算K··=zs,令B··=ws;②其余的伪造步骤同上述Sign质询中Case2;③将挑战的签名σ发送给.Output.A最后将输出关于该签名者ID的猜测值,如果=,那么输出它的判定ψ=1即判断出z=uab,否则输出ψ=0表示z∈RG1.同引理1,的判定优势为Pr[abort]ε,如果游戏可以顺利进行,那么在各个阶段和质询中不会退出,在Sign质询中退出的概率至多为(qH/p6)·1/qH=1/p6,在Corrupt质询中,没有退出的概率为1/qJC,在挑战阶段没有退出的概率为1/(qJC·qH),因此解决XDH难题的概率至少为ε·(1-1/p6)·(1-1/qJC)·1/(qJC·qH).综上两个引理,在XDH假设下提出的TMP-UAA方案具有用户可控匿名性.(3)用户可控追踪性定理3(用户可控追踪性).TMP-UAA方案提供了用户可控追踪性,如果存在一个敌手以不可忽略的概率破坏了用户可控追踪性,那么就存在一个概率多项式时间的模拟器能够以不可忽略的概率解决l-MSDH难题.证明.给定l-1个MSDH实例(Afii,Ai,fi),i←(1,…,l-1)以及发布者的公钥(g1,g2,Ω=gγ2),通过如下与的交互生成一个新的MSDH实例.Initial.通过以上给定的参数,输出TMP-UAA发布者的公钥(G1,G2,GT,p,e,g1,g2,H0,H1,H2,H3,Ω)给敌手.表项及询问次数定义同定理2中的引理1.Hash质询.令H3为随机预言,如果输入的字符串str之前没有被质询过,那么从p中均匀选取一个随机数将其作为对的返回值并将该值及str存放到LH3中,否则返回之前对字符串str在LH3中对应的结果以确保结果的一致性.Join-Initial.利用给定的MSDH实例来模拟Join协议输出的结果.Join-Corrupt质询.对于敌手提交的签名者ID,选取i←{1,…,qJC}并分两种情况给予Page11为应答.的Ai作为应答.Case1.当i=i时,随机选取Cre∈RG1作Case2.当i≠i时,选取一个MSDH实例中将以上的结果保存到LC中.Sign质询.提交一个签名者的ID、基名bsnV、消息m及随机值nV,并且关于该ID的签名者已经加入,分以下两种情况对进行响应.Case1.当ID=ID时,随机选取r,s,sf,应答:c∈Rp,并作如下计算:G1以及K··=Bs;①若bsnV≠⊥则分别计算B··=H1(bsnV)∈②计算T1··=Crer,T2··=grλ(Ωr)=Crer·gγ·r③计算U··=Vsf·W-c,并选择nM←{0,1}ln,令str··=H2(T1‖T2‖T3‖nV)‖K‖U‖bsnV‖m‖nM并通过设置H3(str)=c来修订(patch)随机预言H3,如果之前对str质询过,那么退出;④输出签名σ··=(T1,T2,T3,K,c,sf,nV,nM)并存储(ID,m,σ,bsnV)到LS中.Case2.当ID≠ID时,运行Sign协议,将签名σ作为对的应答,存储(ID,m,σ,bsnV)到LS中.Corrupt质询.如果提交的签名者ID≠ID,那么将LC表中对应该ID的私钥f作为返回值,置表项b=1并将f放入RL中,否则退出.Output.最后输出一个伪造的签名,包括消息m,签名者ID以及签名σ.对于有两种情况需要考虑:Case1.如果σ可以验证成功,即Verify(m,bsnV,σ,IPK,RL)→1.根据分叉引理[23],可以利用回绕(rewind)技术来提取关于该ID的私钥f,即以相同的(T1,T2,T3,K)并控制Hash函数H3的输出结果,来得到不同的c,c两个值,对应的会响应sf,sf两个值,就有f··=(sf-sf)/(c-c),对于f有以下两种情况要考虑:e(g1,g2)成立,那么可以获得一个MSDH实例,即是((Cre)f,Cre,f);e(g1,g2),那么将(T1,T2,f)作为一个盲化的MSDH实例.②当f{fi}i←(1,…,l-1),且e(Cre,gf①当f{fi}i←(1,…,l-1),且e(Cre,gfCase2.若bsnV≠⊥,以同样的基名bsnV输出了两个关于同一签名者ID的签名σ0,σ1使得Link(σ0,σ1,IPK)|bsnV≠⊥=0.在两个签名中基名相同必有B0=B1,因为不可关联即K0≠K1,这意味着为同一签名者产生了两个不同的私钥值,那么可以利用Case1中的方法来提取私钥值产生一个新的MSDH实例.以上两种情况,如果以不可忽略的概率可以赢得用户可控追踪性游戏,那么均能够以不可忽略的概率来解决MSDH难题.7.2性能分析本节将提出的TMP-UAA方案与现有的DAA方案[4,9,13-16]进行比较.在本文中评估的指标有两种:签名长度及计算代价.在进行方案性能对比之前,各方案的安全级别统一定义为128bit级别.另外需要定义安全参数长度及相关算法的计算代价.安全参数定义:(1)双线性配对算法安全参数,本文采用了高效的BN椭圆曲线算法[24],那么在128bit级别下lp=255bit,群G1中的元素大小为25bit,群GT中的元素大小为3072bit,Hash函数lH=255bit;(2)RSA算法的安全参数,在128bit级别下ln=2048bit,lρ=208bit,在文献[4]中对应的le=368bit,le=120bit,lv=2536bit,lH=160bit.1,2,T)分别表示在群G1,G2,GT中的单(m=1)或多(m>1)指数运算,使用BN椭圆曲线GT计算代价是G1约14倍,G2是G1的约4倍[11],另外用Pm来表示单次配对或多次配对幂运算,很明显配对运算要比在群中的运算代价要大很多[24];(2)RSA指数算法,采用Gm指数运算及多指数运算,值得说明的是GN与GT的指数计算代价几乎相同[11],另外用n来表示撤销列表RL中表项的个数.值得说明的是,本文并未比较Join协议的计算代价,这是因为Join协议的执行次数要远小于Sign协议执行次数,且Join协议可以在移动设备出厂前完成.通过表1可以直观得出本方案在签名、验证计算效率上要高于现有已知DAA方案.对于MTM,当关联性不需要时(即bsnV=⊥)只需执行一次指数操作,当需要关联性时(即bsnV≠⊥)仅需两次指数操作,对于其它DAA方案(除了文献[14]的方案)至少要执行三次指数操作.对于可信引擎TE,Sign协议只需执行三次指数操作,这比其它DAA方案计算代价定义:(1)ECC指数算法,采用GmPage12效率都要高,且在Verify算法计算代价比较中,本方案要优于其它DAA方案.因此在计算代价方表1本文方案与现有DAA方案在128bit安全级别下的计算代价及签名长度比较N+1G4NBCC方案[4]3Gρ+1G3BCL方案[9]CPS方案[13]Chen方案[16]2G1+1GTBL方案[15]Chen方案[14]1G1/2G1本方案对于签名长度,从表1可以看出,本方案的签名长度是最小的,当签名不需要关联性时仅为1278bit,当需要关联时为1534bit.因此在签名长度方面,较其它DAA方案本文提出的TMP-UAA方案会使移动设备的通信代价更小,仅为原DAA方案[4]的6.2%/7.5%(不需要关联/需要关联).8移动环境下跨信任域的匿名证明传统的DAA方案只适用于单信任域的情况,这是由于DAA证书发布者通常是移动可信模块MTM或移动设备的生产厂家,这样就形成了以各个发布者为单位相互独立的信任域,在单独的信任域中,签名者可以向域内验证者进行无需可信第三方参与的直接证明(directproof).然而由于不同信任域内的DAA方案参与者只信任各自域内的发布者,因此会产生跨域可信问题,例如在信任域A内的验证者无法确信信任域B内的可信移动平台所产生的直接证明是有效的.从另外的角度看,由于DAA属于特殊的群签名方案,以更高的层面可以将域A和域B看作是两个实体A和B,以上的问题可以转化为:对于验证者A,签名者B产生的签名是不可信的,造成这个问题的直接原因就可以归结为A怀疑B提供公钥的合法性.那么利用本文提出的TMP-UAA模型可以很好解决这个问题.由于发布者的公钥受可信第三方CA认证,保证了发布者公钥的合法性,因此任意域内的验证者都可以通过CA校验与签名相关的公钥的合法性,即可对实体A或实体B生成的UAA签名进行验证,如图2所示.另外一个值得考虑的问题是多信任域中RL列表的获取,即验证者如何获取相应域中的RL列表.由于TPM-UAA模型借鉴了PKI的架构思想,因面,本文提出的TMP-UAA方案更加适用于移动设备.此该问题可以采用类似CRL列表的管理方式来解决:一种方式是集中式管理,各个域的发布者将各自的RL列表提交给CA统一管理并定期对提交的RL列表进行更新,验证者可以通过CA下载对应发布者公钥的RL列表;另一种方式是分布式管理,每个域的发布者维护各自域的RL列表,当验证者验证UAA签名时,可通过发布者公钥证书中的RL列表所在的发布点下载列表,例如X509.V3证书提供了这样的功能.9结论高性能及可部署性是匿名证明方案在移动环境下的两个重要需求.本文针对可信移动平台的特点并以实用性为动机提出了一种新型的匿名证明方案,该方案在保证原有DAA安全性及功能性的基础上提供了更高的执行性能,而且TMP-UAA方案的构建方法为移动可信模块MTM及可信移动平台TMP匿名证明方案的构建提供了新思路;另一方面本文设计的TMP-UAA模型能够有效解决目前DAA模型设计中存在的R攻击及跨信任域问题,更适于在移动平台上部署实现.Page13
