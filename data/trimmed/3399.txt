Page1基于模型的网构软件可达性检测方法研究赵会群孙晶魏莹王文文郭峰(北方工业大学计算机科学与技术系北京100144)摘要针对网构软件(Internetware)可达性检测中存在状态空间“爆炸”等问题,提出了一种基于网构软件代数模型的可达性检测方法.根据网构软件特性建立其代数模型,通过引入网构相关和网构空间概念,进一步扩展网构软件代数模型.通过明确网构软件可达性与网构组合运算表达式的关系,把可达性判定转化成递归表达式(网构线性相关)判定上来;通过建立网构空间到线性空间映射,把网构线性相关判定问题转化成齐次线性方程组非零解的判定上来.转换过程把线性相关的网构进行压缩,从而有效地抑制了状态空间的增长.给出了可达性检测算法,并讨论了该方法的实际应用.关键词网构软件;软件可达性;进程代数;线性代数1引言随着Internet技术的不断发展,基于InternetPage2制[4];云计算给用户提供了无需配置的计算和信息服务模式[5].网络终端用户已经逐渐地把Internet看成是一个大的计算机系统,即“TheNetworkistheComputer”和“GlobalUbiquitousComputer”[6].这些新的计算模式的出现,促使计算机工作者对软件技术有了新的思考,如何在这种新的“计算机平台”上开发、运行和维护计算机软件,已经成为计算机科学与技术面临的具有挑战性的问题[10].为了迎接这一挑战,软件技术也经历了许多变迁.从面向对象[7]到基于构件[8]的软件开发,再到面向服务[9]的软件集成都体现出这种变化,而这种变化也孕育了一种新的软件技术体系“网构”软件[10].所谓网构是以开放、自主的方式存在于Internet的各个节点之上,可在开放的环境下通过某种方式加以发布,并以各种协同方式与其它软件实体进行跨网络的互连、互通、协作和联盟的软件实体[10].网构软件是应能感知外部环境的动态变化,并随着这种变化按照功能指标、性能指标和可靠性指标等进行静态(离线)的调整和动态(在线)的演化,以使系统具有尽可能高的用户满意度的一种新的软件形态.网构软件具有自主性、协同性、反应性、演化性和多目标性等特征[10].由于网构是以开放、自主的方式存在于Internet的各个节点之上,所以网构软件的可靠性成为用户关注的焦点,而焦点之一就是网构组合的可达性.可达性(reachability)的原始定义可以在图论中找到,如下:“有向图D=(V,A),V、A分别是点集和边集;一个可达性关系是A上的传递闭包(transitiveclosure),满足对所有的有序点对(s,t),存在一个点序列v0=s,v1,…,vd=t,使得(vi-1,vi)∈A(其中,1id)”[11].计算可达性通常指的是计算能力是否能够被激活,并正常工作.计算可达性是计算机科学中的经典问题,如无穷状态系统、重写系统、动态系统和混合系统中计算的可达性问题,计算机界也有关于可达性的国际学术会议,如RP2010.为了分析计算机系统可达性,可达性检测与分析方法自然成为研究的热点,如基于代数结构的可达性分析[12]、基于Petri-Nets的可达性分析[13].本文提出一种基于代数模型的网构软件可达性检测方法.该方法通过对被测系统建立代数模型,从代数结构方面分析网构软件的可达性问题.分析中为了抑制模型状态空间的“爆炸”,把模型的状态空间变换到线性空间,利用线性代数中线性相关理论和方法检测网构软件的可达性.文中的第2节首先建立网构软件的代数模型,在该模型基础上第3节讨论网构软件的可达性检测方法,给出具体的检测算法;第4节介绍一个模拟检测案例,分别用提出算法和模型检测工具实现两个可达性检测系统,并对两个检测系统进行比较,分析二者的性能;第5节通过与相关研究工作比较给出本文结论.2网构软件代数模型下面提出一种称为网构代数的代数系统,试图用代数学方法描述网构软件的主要特征,为进一步分析网构软件的性质奠定基础.模型建立过程中借鉴了进程代数和传统的代数学理论来定义网构、网构组合以及网构软件体系结构等概念,最后给出网构软件代数模型.2.1网构网构是可在开放的环境下通过某种方式加以发布,并以各种协同方式与其它软件实体进行跨网络的互连、互通、协作和联盟的软件实体.下面分别给出网构、网构组合和网构软件体系结构的形式化描述以及网构同态和同构概念.定义1.网构是一个软件实体,它由网构接口、网构实现构成.网构接口是网构与外部接触点的集合,即〈Port1,Port2,…,Portn〉,而每一个接触点Porti是一个十元组〈Dom,ID,Publi,Refli,Extei,Privi,Behai,Msgsi,Consi,Non-Funci〉.其中:Dom是网构所在域,如公司或机构名称等.ID是网构的标识,是一个基于标准编码的数据结构,可以用于安全认证、地址解析和信号位等;Publi是网构第i个接触点能提供给环境或其Refli是网构第i个接触点能提供给环境或其它网构元数据的集合,该集合有一个布尔型的标志元素,当元数据变化时置该元素为T,当与其交互的环境获得元数据信息后,置F;Extei是网构第i个接触点运行所需环境或其它网构的功能集合,它具有环境感知能力;它网构的功能集合;集合;组谓词表达式;Privi是网构第i个接触点私有属性和功能的Behai是网构第i个接触点行为语义描述,是一Msgsi是网构第i个接触点功能中活动所产生Consi是对网构第i个接触点行为约束,它通常消息的集合;Page3包括网构运行的初始条件、前置条件和后置条件,有时为了明确表示这3个条件,可把它写成Cons(init,pre-cond,post-cond),其中init、pre-cond和post-cond分别表示初始条件、前置条件和后置条件的集合;Non-Funci是网构第i个接触点非功能说明,包括网构的业务策略、合同、安全性、可靠性说明等.网构实现是网构在计算机上的表现形式,可以是一段代码、也可以是一个软件运行环境,甚至可以是一个文件.一个网构接口的属性可以表示成Atti(A),或者进一步写成Atti(x),其中Atti表示某一个属性,如Publi(x),x表示A中的一个活动.上述的网构属性构成可以随着网构所担当的角色有所不同.如一个用Java实现的跨平台网构通常需要〈Dom,ID,Publi,Refli,Extei,Privi,Behai,Msgsi,Consi,Non-Funci〉中的所有描述信息;而对网构的支撑软件(网构中间件),其网构的Refli和Extei两个属性可能为空;而对一个数据库文件,不需要网构的行为属性,所以有〈Dom,ID,,,,,Msgsi,Consi,,〉.多个接触点是对网构多目标性的刻画;而属性Dom、Publi、Extei、Privi、Behai、Msgsi、Consi、Non-Funci和Refli分别是对网构自主性和反应性的抽象.下面给出网构相等和网构演化概念.定义2.设A、B是论域Dom(U)中的两个网构,U为网构集合,下同.如果对所有的接触点,A、B满足下列条件:(1)Publ(A)=Publ(B);(2)Refl(A)=Refl(B);(3)Extn(A)=Extn(B);(4)Priv(A)=Priv(B);(5)Beha(A)Beha(B);(6)Msgs(A)=Msgs(B);(7)Cons(A)Cons(B);(8)Non-Func(A)Non-Func(B),则称A、B相等,记作A=B.‘’为逻辑等价,‘’为永真蕴涵,下同.定义3.设A和B是论域Dom(U)中的两个网构,如果对所有的接触点,A和B满足下列条件:(1)Dom(A)=Dom(B);(2)Publ(B)Publ(A);(3)Refl(A)=T;(4)Extn(B)Extn(A);网构演化是对网构的演化性的抽象.下面进一(5)Priv(B)Priv(A);(6)Beha(B)Beha(A);(7)Msgs(B)=Msgs(A);(8)(Cons(B)=Cons(A))or(9)(Non-Func(B)=Non-Func(A))or则称B是A的一个演化,记为Evolve(B,A).步讨论网构组合的抽象方法.2.2网构组合下面结合网构软件特点,对进程代数中的算子进行扩展,把网构组合解释成网构连接运算的实现.定义4.设A、B是论域Dom(U)中的两个网构,若x∈Extn(A)∧y∈Publ(B)使得[pre-cons(x)∧pre-cons(y)]∧[Msgs(x)Msgs(y)]∧[Msgs(A)=Msgs(y)∪Msgs(A)],即网构A通过发送一个消息“激发”网构B中的Publ(B)来实现功能需求,并回应执行结果,就称网构A、B进行了一次“激发”运算,记作C=AB.特别地把C=AB记为c=xy.AB仍然是一个网构,它满足下列性质:(1)Dom(C)=Dom(A)∪Dom(B);(2)Publ(C)=Publ(A)∪Publ(B);(3)Refl(C)=Refl(A)∪Refl(B);(4)Extn(C)=Extn(A)∪Extn(B);(5)Priv(C)=Priv(A)∪Priv(B);(6)Beha(C)Beha(A)∧Beha(B);(7)Msgs(C)=(Msgs(A)∪Msgs(B));(8)Cons(C)Cons(A)∧Cons(B);(9)Non-Func(C)Non-Func(A)∧定义5.设A、B是论域Dom(U)中的两个网构,若x∈Extn(A)∧y∈Publ(B)使得[pre-cond(x)∧pre-cond(y)]∧[Msgs(x)Msgs(y)]∧[Priv(A)={y}∪Priv(A)]∧[Extn(A)=Extn(A)-{y}],即网构A通过拷贝网构B中的y到Priv(A)来实现功能需求,就称网构A、B进行了一次“使用”运算,记作C=AB.特别地把C=AB记为c=xy.AB仍然是一个网构,它满足下列性质:(1)Dom(C)=Dom(A)∪Dom(B);(2)Publ(C)Publ(A)∪Publ(B);(3)Refl(C)=Refl(A)∪Refl(B);Page4(4)Extn(C)Extn(A)∪Extn(B);(5)Priv(C)Priv(A)∪Priv(B);(6)Beha(C)Beha(A)∧Beha(B);(7)Msgs(C)=(Msgs(A)∪Msgs(B));(8)Cons(C)Cons(A)∧Cons(B);(9)Non-Func(C)Non-Func(A)∧“使用”和“激发”运算是最基本的网构组合运算.在不需要区分二者的情况下,可以把二者统称为“调用”运算,记为AB.可以证明“调用”运算满足结合率[14].定义6.设A、B是论域Dom(U)中的两个网构,若x∈Publ(A),y∈Extn(B)使得[(pre-cond(y))((pre-cond(x))]∧[Msgs(y)Msgs(x)],反之x∈Extn(A),y∈Publ(B)使得[(pre-cond(x))((pre-cond(y))]∧[Msgs(x)Msgs(y)],则称B与A协同运算,记作AΘB.H=pre-cond(A)∩pre-cond(B)称为协同条件集.特别地把C=AΘB记为c=xΘy.显然,“协同”运算满足交换率.定义7.设A、B是论域Dom(U)中的两个网构,若x∈Publ(A),y∈Extn(B)可以有[(pre-cond(y))((pre-cond(x))]成立,反之x∈Extn(A),y∈Publ(B)可以有[(pre-cond(x))(pre-cond(y))]成立,但H=pre-cond(A)∩pre-cond(B)=,则称A与B并行,记作C=A‖B.特别地把C=A‖B记为c=x‖y.显然,并行运算是协同运算的特例,并都满足交换率.定义8.设A、B是论域Dom(U)中的两个网构,x1∈Publ(A)、y1∈Extn(A),x2∈Publ(B)、y2∈Extn(B),若[(post-cond(y1)pre-cond(x2))][post-cond(y2)pre-cond(x1)],则称A与B重复,记为C=A·B.特别地,当A=B时,称A重复执行,记为C=x1·A,简记C=·A.定义9.设A、B是论域Dom(U)中的两个网构,若x∈Publ(A),y∈Publ(B)使得[pre-cond(x)]∨[pre-cond(y)],则称网构A与网构B选择执行,记为C=A+B.特别地把C=A+B记为c=x+y.定义6~9中的运算也有与式(3)类似的性质.这里略.可以证明“选择”运算满足交换率.“重复”、“激发”与“使用”、“协同”与“并行”运算对“选择”运算满足分配率.下面仅就“重复”对“选择”的分配律加以证明,其它证明略.定理1.“重复”运算对“选择”运算满足分配律,即证明.要证明式(1)成立,只要证明等式的左边和等式右边满足定义2中的8个条件即可.为此,我们有代表性地证明第1个和第5个条件成立,其它证明同理.首先,对“·”和“+”运算,都有Publ(AOPiB)=Publ(A)∪Publ(B)性质,所以对x∈Publ((A+B)·C),有x∈Publ(A)∨x∈Publ(B)∨x∈Publ(C),可得x∈Publ(A·C+B·C).同理,对y∈Publ(A·C+B·C)有y∈Publ((A+B)·C).因此,有Publ((A+B)·C)=Publ(A·C+B·C),定义2的性质(1)成立.首先,对“·”运算,有Beha(A·B)Beha(A)∧Beha(B)性质;而对“+”运算,有Beha(A+B)Beha(A)∨Beha(B)性质.由Beha((A+B)·C)(Beha(A+B))∧Beha(C)(Beha(A)∨Beha(B))∧Beha(C)(Beha(A)∧(Beha(C))∨(Beha(B)∧(Beha(C))Beha(A·C+B·C),则Beha((A+B)·C)Beha(A·C+B·C)).定义2的性质(5)成立.以上借鉴进程代数中的算子概念,对组合进行分类,下面进一步讨论网构组合概念.定义10.网构组合是网构运算的实现.它是一个六元组〈ID,Role,Beha,Msgs,Cons,Non-Func〉.其中:ID是组合的标识;Role为网构组合与网构的交互点的集合,每个Role=〈Id,Action,Event,LConstrains〉.其中:Id是Role的标识;Action是Role活动的集合,每个活动由事件的连接(谓词)组成;Event是Role产生的事件集合;LConstrains是Role的约束集合.我们把Role从组合的其它属性分开来描述的目的是突出组合的多态性,即一个组合可同时实现多个网构的组合.Msgs是组合中各Role中活动产生事件的集合.Beha是组合行为的语义描述.Cons是组合约束的集合,它包括组合的初始条件、前置条件和后置条件,有时为了明确表示这3个条件可把它写成Cons(init,pre-cond,post-cond),init、pre-cond和post-cond的含义与网构中的定义Page5Non-Func是组合的非功能说明,包括按何种相同.策略、合同、安全性和可靠性组合等.2.3网构软件体系结构代数模型多个域的集合,下面给出网构软件体系结构的定义.定义11.设U={Dom1,Dom2,…,Domn}是(1)网构是一个网构软件体系结构;(2)网构组合是一个网构软件体系结构;(3)由网构经有限次网构组合(网构运算)后是网构软件体系结构.网构软件体系结构(ISA),记为ISA=〈C,O〉.其中,C表示组成网构集合,O表示网构组合(运算)的集合.与ISA组合后仍是一个ISA.由定义11可得ISA的性质如下:(1)封闭性.即网构与网构,网构与ISA,ISA(2)层次性.即网构可由网构组合而成,而网构(3)可扩充性.即一个满足条件的新网构可以从网构组合是网构运算实现角度,可以进一步又可以再经过组合组成更高层的网构.通过组合加入到ISA中.证明ISA对任意一个运算构成代数系统.的正确性.一个组合运算都构成代数系统.定理2.设ISA=〈C,O〉,则ISA对O中的每证明.由网构组合运算的封闭性可得定理2为此,把ISA=〈C,O〉称为网构代数模型,也称网构软件的代数表达式.在ISA代数模型定义基础上,可以进一步利用代数学方法挖掘网构软件的代数性质,为网构软件研究奠定基础.定义12.设ISA1=〈C1,O1〉、ISA2=〈C2,O2〉,若x∈C1总有y∈C2,使得y与x对应,则称ISA1与ISA2之间存在着一个映射,记为f:ISA1→ISA2,或y=f(x).若映射是满射,则称网构间映射为满射;若映射是一对一的,则称网构间为一一映射.定义13.设ISA1=〈C1,O1〉、ISA2=〈C2,O2〉是两个网构,f是ISA1到ISA2的一个映射,若对x∈C1和y∈C1有f(xOPiy)=f(x)OPjf(y),其中OPi∈O1,OPj∈O2,则称f为从S1到S2的同态,也称ISA1与ISA2同态;若f是单射,则称f是从ISA1到ISA2的单一同态;若f是一一映射,则称f是从ISA1到ISA2的同构,也称ISA1与ISA2同构.用同态与同构概念可以进一步描述基于网构软件的进化性、网构之间的关系等概念,这里仅给出后者.定义14.给定ISA1=〈C1,O1〉、ISA2=〈C2,O2〉,构造一个新的网构ISA1×ISA2=〈C1×C2,OPk〉.其中C1×C2是网构集合的笛卡尔乘积,而OPk定义成对x1,x2∈C1和y1,y2∈C2有〈x1,y1〉OPk〈x2,y2〉=〈x1OPix2,y1OPjy2〉,OPi∈O1、OPj∈O2.称ISA1×ISA2是ISA1到ISA2的积结构,而ISA1和ISA2是ISA1×ISA2的因子,这里的OPi、OPj和OPk运算是任意网构组合运算.在定义14的基础上可以定义网构间的关系.定义15.对x1、x2∈C1和y1、y2∈C2,在定义14中,所有满足〈x1OPix2〉的(x1,x2)的任意一个子集合称为运算OPi的一个关系;所有满足〈y1OPjy2〉的(y1,y2)的任意一个子集合称为运算OPj的一个关系.2.4网构软件可达性概念式都可以写成下面的标准型.定理3.任意一个ISA=〈C,O〉的代数表达ISA=a1OpC1+a2OpC2+…+amOpCm(2)或简写成其中,ai∈Cj;Cj∈C,m为所有网构的个数,i,j可能不等,Op是“使用”或“激发”运算.证明.采用归纳法.当k=1时,用户通过发送命令启动系统,所以ISA=a1OpC1,定理成立.现假设k=n-1成立,即ISA=a1OpC1+a2OpC2+…+an-1OpCn-1,去证明k=n有ISA=a1OpC1+a2OpC2+…+anOpCn.下面就ISA中的各种运算证明式(2)的正确性.(1)对选择运算“+”.ISA+anOpCn=a1OpC1+a2OpC2+…+an-1OpCn-1+anOpCn,根据定义11,ISAn-1+anOpCn仍然是一个网构软件体系结构.因此,ISA=a1OpC1+a2OpC2+…+anOpCn,定理成立.(2)对重复运算“·”.设an∈Cj,Cn∈C,构造anOpCn·ISAn-1=anOpCn·(a1OpC1+…+an-1OpCn-1),由于“·”对“+”满足分配律,则anOpCn·(a1OpC1+…+an-1OpCn-1)=anOpCn·a1OpC1+…+anOpCn·an-1OpCn-1,选择xi∈Publ(Cn)展开上式有anOpCn·Page6a1OpC1+…+anOpCn·an-1OpCn-1=anOpx1·a1OpC1+…+anOpxn-1·an-1OpCn-1+C0,其中C0是一个空网构.构造bi=anOpxi·ai,i∈[1;n-1]并且bnOpCn=C0,则anOpCn·ISAn-1=b1OpC1+…+bnOpCn=Sn-1+bnOpCn,又因为anOpCn·ISAn-1仍然是一个网构软件体系结构,因此,有ISA=b1OpC1+b2OpC2+…+bnOpCn.(3)对协同运算“Θ”.设an∈Cj,Cn∈C,构造anOpCnΘISAn-1=anOpCnΘ(a1OpC1+…+an-1OpCn-1),由于“Θ”对“+”满足分配律,则anOpCnΘ(a1OpC1+…+an-1OpCn-1)=anOpCnΘa1OpC1+…+anOpCnΘan-1OpCn-1,选择xi∈Publ(Cn)展开上式有anOpCnΘa1OpC1+…+anOpCnΘan-1OpCn-=anOpx1Θa1OpC1+…+anOpxn-1Θan-1OpCn-1+C0,其中C0是一个空网构.构造bi=anOpxiΘai,i∈[1;n-1],并且bnOpCn=C0,则anOpCnΘISAn-1=b1OpC1+…+bnOpCn=Sn-1+bnOpCn,又因为anOpCnΘISAn-1仍然是一个网构软件体系结构.因此,有ISA=b1OpC1+b2OpC2+…+bnOpCn.(4)同样的方法可以证明对使用和激发运算“Op”定理成立.上述过程证明了对所有的网构运算ISA都有ISA=a1OpC1+a2OpC2+…+amOpCm.在(1)、(2)的证明中,通过构造新的活动实现了ISA的重新配置,这种构造方法是从左侧进行,其物理意义表现为更新应该主动适应ISA的风格.标准型式(3)中的ai通常是一个行为明确的活动,如安全性确认等可信活动等,所以可以把ai看成是常量;为了分析网构软件系统的可达性,下面给出两个递归表达式.个相关概念———死锁与活锁.几个网构功能,则称系统出现“活琐”.定义16.如果一个网构软件无限循环执行某“活锁”表现为网构代数表达式中包括递归.定理4.“活锁”表现为网构代数表达式是一证明.定理显然成立.定义17.对一个网构软件系统,如果网构总能到达,那么称该网构软件系统有活动性;如果一个网构调用在执行某个网构组合后异常终止,则称该网构软件系统出现“死锁”,记为“⊥”.“终止”活动“⊥”是一种正常的网构活动,但“⊥”出现在需要继续执行的调用过程中时,就会引起“死锁”.根据定义17,显然有定理5成立.定理5.在有“终止”活动“⊥”的网构软件系统中,其网构表达式中某项的常量只有“⊥”.证明.反证法.假设网构表达式ISA=a1C1+a2C2+…+akCk,其中ai为“⊥”,记有ISA=a1C1+a2C2+….⊥Ci+…+akCk.根据“⊥”的定义,一定不存在x∈Ci与“⊥”发生调用运算,所以⊥Ci=⊥,定理成立.例1.F=aG+bF;G=cG+dG.G无限自循环,系统出现活琐.X=aY+bX;Y=cY+dX+⊥.如果网构Y执行常量“⊥”,那么系统进入终止状态.定义18.如果一个网构代数表达式中没有出现“活锁”和“死锁”,则称该网构软件系统具有可达性.3网构软件可达性检测算法研究本节讨论网构软件可达性检测算法,方法是通过定义网构的线性相关性,把网构软件可达性判断等价变换到网构的线性相关性判定上来,利用线性代数理论和方法求解网构软件的可达性.定义19.设F1,F2,…,Fn是N个可访问的网构,a1,a2,…,an分别是F1,F2,…,Fn网构中的活动.如果对任意的i∈[1,N]都有Fi=a1F1+a2F2+…+ai-1Fi-1+aiFi+ai+1Fi+1+…+anFn,则称F1,F2,…,Fn线性相关.网构线性相关与线性空间中向量的线性相关性具有相似的含义.定理6.设S1=a1F1+a2F2+…+anFn、S2=b1G1+b2G2+…+bkGk是两个网构,ai和bi分别是网构S1和S2中的活动,下同;S1ΘS2=c1H1+c2H2+…+cnHn是网构协同组合表达式,则S1ΘS2是递归表达式的充要条件是H1,H2,…,Hn线性相关.证明.充分性,用归纳法证明.当n=1时,即H1=d1H1,则S1ΘS2=c1H1=c1d1H1,显然是递归表达式;当n=2时,即H1=d11H1+d12H2,H2=d21H1+d22H2,分别代入S1ΘS2=c1H1+c2H2+…+cnHn中,则S1ΘS2=c1d11H1+c1d12H2+c2d21H1+c2d22H2,根据“Op”运算对“+”运算的分配律整理后有S1ΘS2=m1H1+m2H2,其中m1=c1d11+c2d21,m2=c1d12+c2d22,显然也是递归表达式.同理,可以证明在假设n=k时S1ΘS2是递归表达式,Page7n=k+1时S1ΘS2也是递归表达式.必要性.由于S1ΘS2=c1H1+c2H2+…+cnHn是递归表达式,则一定i∈[1,N]使得Hi=hiHi;或者i1,i2,…,ik∈[1,N],使得Hi1=hi2Hi2,Hi2=hi3Hi3,…,Hik=hi1Hi1;或者i1,i2,…,ik∈[1,N],使得:Hi1=hi1Hi1+hi2Hi2+hi3Hi3+…+hikHik,H21=hi1Hi1+hi2Hi2+hi3Hi3+…+hikHik,Hik=hi1Hi1+hi2Hi2+hi3Hi3+…+hikHik.这3种情形分别代表直接递归和间接递归,所以可以得出H1,H2,…,Hn线性相关.定义20.设ISA=〈C,O〉,“+”和“Op”分别是网构的选择运算和调用运算,如果对“+”满足:F1+F2=F2+F1(交换率);(F1+F2)+F3=F2+(F1+F3)(结合律)以及存在零网构和异常网构,即F1+#=F1(零网构#);F1+(~F1)=#(异常网构-F);“Op”对“+”满足:H(h1+h2)=Hh1+Hh2(左分配律),(h1+h2)H=h1H+h2H(右分配律),并且有内部协同网构活动,即εF=F(内部协同网构活动对ε),则称ISA=〈C,O〉对“+”和“Op”构成网构空间.定理7.ISA=〈C,O〉对“+”和“Op”构成网证明.设F1,F2,F3分别是ISA中的网构.根F1+F2=F2+F1(交换率);(F1+F2)+F3=F2+(F1+F3)(结合律).又由于ISA软件中存在空网构和异常网构,分F1+#=F1(零网构#);F1+(~F1)=#(异常网构~F).又由调用运算“Op”性质,则有εF=F(内部协同活动对ε,如一对应答网构);H(h1+h2)=Hh1+Hh2(左分配律);(h1+h2)H=h1H+h2H(右分配律).因此,ISA=〈C,O〉对“+”和“Op”构成网构定理8.设ISA=〈C,O〉,一定存在一个线性空间V与ISA同构.证明.设P为一个数域,H为网构中活动集合.按照以下规则构造映射Φ:对hi∈H,令Φ(hi)=pi,pi∈P是活动hi执行所需要的代价,特别地,令pi为活动使能的真假值;对Ci∈C,令Φ(Ci)={Φ(h1),Φ(h2)…Φ(Ci)}=犡i.其中犡i为n维向量,犡i=(id,x1,x2,…,xn-1),xi=Φ(hi)为整数,id是构空间.据选择“+”运算性质有别记为#和~F,则有空间.Φ(an)+整数Φ(bn)}Ci的标示;“+”与“+整数”对应,“Op”与“×整数”对应,则向量犡1,犡2,…,犡n以及“+整数”和“×整数”构成线性空间.对上述定义的映射Φ,由于id的引用,显然Φ是一一映射.又对A,B∈C,A={a1,a2,…,an},B={b1,b2,…,bn},ai是A中的活动,bi是B中的活动,有A+B={a1+b1,a2+b2,…,an+bn},则Φ(A+B)={Φ(a1+b1),Φ(a2+b2),…,Φ(an+bn)}={Φ(a1)+整数Φ(b1),Φ(a2)+整数Φ(b2),…,={id1,x1,x2,…,xn-1}+整数{id2,y1,y2,…,yn-1}=Φ(A)+整数Φ(B)=犡1+整数犡2.又对Φ(hiOpCi)=Φ(h1Opc1,h1Opc2,h1Opc3,…,h1Opcn)={Φ(h1Opc1),Φ(h1Opc2),Φ(h1Opc3),…,Φ(h1Opcn)}={Φ(h1)×整数Φ(c1),Φ(h1)×整数Φ(c2),Φ(h1)×整数Φ(c3),…,Φ(h1)×整数Φ(cn)}=Φ(hi)×整数{Φ(c1),Φ(c2),Φ(c3),…,Φ(cn)}=pi×整数Φ(Ci)=pi×整数犡i,这里ci∈Ci,又由于ISA=a1OpC1+a2OpC2+…+amOpCm,所以有Φ(a1OpC1+a2OpC2+…+amOpCm)=Φ(a1)×整数Φ(C1)+整数Φ(a2)×整数Φ(C2)+…+Φ(am)×整数Φ(Cm)=p1×整数犡1+整数p2×整数犡2+…+pm×整数犡m,即任何一个网构表达式都可以找到唯一的线性表达式与其对应,反之亦然.因此,定理成立.在上面的推导过程中Φ(h1Opci)=Φ(h1)×整数Φ(ci)是根据马尔可夫链特性得出的结论,可以证明“使用运算”可以转化成“激发”运算,而“激发”运算下活动的激发序列满足半马尔可夫特性[22].因此,活动序列的非功能属性为各个活动属性值的乘积,如活动的可靠性等[14].推理1.设F1,F2,…,Fn是N个可访问的网构,F1,F2,…,Fn线性相关的充分必要条件是在同构变换下与F1,F2,…,Fn对应的犡1,犡2,…,犡n系数行列式的值为0.推理1说明可以通过网构的线性相关性判断网构的可达性.根据以上推断,下面给出网构软件可达性检测步骤和算法.求解的步骤如下:1.根据网构注册表,确定网构代数表达式的系数矩阵;2.通过计算系数矩阵的行列式,判断网构相关性,从而检测网构软件可达性.Page8具体求解算法如下.算法1.基于ISA代数模型的软件可达性检1.根据网构注册表,确定网构代数表达式的系数矩阵;输入:注册表的信息表输出:相关服务元素集for一个注册表中的每个服务流(f1,f2,f3,…,fn)2.扫描系数矩阵,判断网构的相关性.输入:相关服务元素的系数矩阵输出:活动路径中服务元素列表foreachi{result=coefficient_matrix(i,j)and图1该网构组合描述了顾客、多个销售代理和生产厂家为顾客提供订货计划的服务流.正常的服务流如图1(b)所示,Provider1根据Provider2提供的最佳折扣货物信息,把订货业务转包给Provider2;以此类推,最终Provider4通过Producer给Request提供订货服务.最佳折扣服务信息流如图1(a)所示,Provider1与Provider4相互通报了最佳折扣服务信息,Provider4在向Provider1通报的同时,也向Provider3通报,而Provider3又通报给Provider2,Provider2又通报给Provider1,上述服务信息流用箭头表示.正因为Provider1与Provider4相互通报了同一批货物信息,所以就会出现图1(c)所示的非可达的服务流.这种情况发生在Provider1没有及时发布与Producer失去最佳折扣关系服务信息,使得Request订单到来时,出现循环不可达的服务流.应用提出的ISA代数模型和算法1的检测过程如下:根据图1表述的服务组合,其ISA代数模型为在算法1中步1的执行时间为O(HL),其中,H是网构注册表的长度,L是最长网构流的长度;步2的执行时间是O(N2),N为关系集合的元素个数.4案例分析下面结合一个零售企业订货业务,介绍两种网构可达性检测方法.4.1基于ISA代数模型的可达性检测图1是一个网构组合案例.其中,Request、Pro-ducer、Provider1~Provider4分别为通过UDDI[15]发布的网构,每一个网构又都有其内部功能,从而形成嵌套的业务逻辑.P=(a11Provider1+a22Provider2+即Request可以连接到Provider1~4中的一个获得订货,aii是订货活动.又由于Provider1与Provider4之间可以相互提供订货,即有Provider1=a14Provider4,Provider4=a41Provider1把Provider1和Provider4分别代入P的代数表达式有P=(a11a14Provider4+a22Provider2+显然,式(6)是递归表达式.根据推论1及算法1得,齐次线性方程组(7)有非零解.对其任何两个2阶系数行列式就解时,只有式(8)的式子为0.这里aij分别表示与网构Provider1和Provider2相对应的线性空间中向量犢1和犢2的分量.根据推论1证明中映射建立的方法,当Provider1通过a1(a1是Provider1的一个活动)向外界提供服务时,Page9a11为真1,当Provider1向Provider2提供a1服务时,a12为真1;同样地,当Provider2通过a2(a2是Provider2的一个活动)向外界提供服务时,a22为真1,当Provider2向Provider1提供a2服务时,a21为真1.4.2基于模型检测工具的可达性检测为了分析和比较基于ISA代数模型的检测算法有效性,采用模型检测工具集CADP[16]中的EVELUATOR对上述业务进行可达性检测.检测过程描述如下:(1)建立业务过程的Lotos描述,见图2.由于Provider1[request,reply,refusal,sendpriceP,sendpriceR,givingup,request1_2,reply1_2,request1_4,reply1_4]图2订货交易过程的Lotos描述摘要图3CADP检测结果5相关研究比较及结论用模型检测方法检测计算可达性是一种常用的篇幅有限,这里仅给出行为描述总揽部分;其中[request,reply,order,refusal,sendpriceP,send-priceR,givingup]是订货采用的抽象服务原语,这里作为Requester与Provider1~4交互的‘门’;而[request1_2,reply1_2,request1_4,reply1_4]是Provider1与其它进程交互的‘门’,以此类推.(2)在WindowsXP-SP3环境(IntelCore2、2.09GHz、2GB)执行Lotos程序,结果见图3.其中图3(a)为执行Lotos后产生的状态空间图,共产生了722个状态,1580条转换边.图3(b)是执行检测条件:“〈true.ORDER〉true”,即可能订货成功的状态转换图;而图3(c)是执行检测条件:“[true.REQUEST1_2!]muX.(〈true〉trueand[notORDER]X)”,即一定订货成功的状态转换图.可以发现图3(c)中有一个‘环’,这表明业务在此循环不可达.方法,与案例分析中类似的工作还有一些,比较相近的是Nakajima[17]的工作.作者结合预定飞机票的服务业务作为被检测对象,用SPIN中的Promela对业务建模,在考虑了服务内部活动情况下,共形成了Page10700行代码,生成了280000个状态,470000个状态迁移.与我们遇到的问题相似,状态空间随着模型的复杂程度急剧增加,如果不进行有效的压缩无法在实际检测中应用.本文提出的基于ISA代数模型检测方法对模型状态空间通过“网构相关性”进行有效的控制,部分地解决了状态空间快速增长问题.当然,本文仅仅从网构软件体系结构角度检测计算可达性,并没有从网构行为上考虑计算的可达性.并行程序的可达性测试是一类经典问题,Hwang等人[18]针对并行程序因时序不确定而导致的测试困难,结合确定性(deterministic)和非确定性(nondeterministic)测试策略,提出了一个并行程序可达性测试方法.该方法首先选择指定的测试用例,在指定的同步序列(SYN-Sequence)上执行;执行结束后,立即随机选择测试用例在不确定的同步序列上执行,从而测试并行软件的可达性.在Hwang等人之后,文献[19]进一步提出了一个并行程序的执行模型,该模型的主要贡献是:提出了多种同步和异步结构用于消息传递和控制,提出了基于时间戳的竞争事件标志方法,提出了同步序列中竞争变量的计算方法,有效地解决了并行程序的可达性测试问题.与本文研究的问题不同,并行程序是在单域设计并工作的程序,而本文面对的是可以在域间工作的、无法进行集中控制的网构,所以不能进行方法的替代.相关工作还有一些.Schlingloff[20]等人提出一种基于Petri网的Web服务可达性检测方法,该方法用BPEL4WS描述的Web服务,并把BPEL转换成Petri网模型,然后用基于Petri网模型检测工具检测可达性.周立等人[21]针对网构软件行为中的不确定性和不完整性,提出了一种支持协商的网构软件体系结构行为建模与验证方法;通过扩展UML建模元素支持行为的不确定与不完整建模;提出基于模型检验Spin反例引导的正确性验证方法.本文在ISA代数模型基础上,把ISA软件可达性检测转化成递归代数表达式和齐次线性方程组非零解判定上来,从而降低了问题求解的代价.用代数学方法建模软件并分析软件属性并非新的做法,作者在文献[14]中介绍了一个SOA软件代数模型,本文提出的ISA代数模型有部分内容来自于文献[14]中的工作,但不同的是本文从网构软件角度重新审视代数模型方法,为网构计算可达性奠定了基础.本文仅从网构体系结构角度讨论了可达性检测问题,并没有深入到网构行为细节上分析网构软件的特性,我们将深入讨论ISA代数模型的行为模型,开展更细致的研究工作.致谢本文所述工作得到了北京大学软件研究所梅宏老师的指导,在此表示衷心地感谢!
