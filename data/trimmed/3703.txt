Page1直接匿名证言协议的性能估算新方法1)(四川师范大学计算机学院,四川省可视化计算与虚拟现实重点实验室成都610066)谭良1),2)孟伟明1)周明天3)2)(中国科学院计算技术研究所北京100190)3)(电子科技大学计算机学院成都610054)摘要性能问题是阻碍DAA推广和应用的首要问题.为了进一步优化该协议的性能,找出性能瓶颈,定量地分析和测量DAA中各个实体的性能负荷分布是一个十分重要且必须的工作.文中详细分析了DAA的协议流程,提出了以机器周期为基本性能单位的性能负荷分布测量方法———归一化统计法(NormalizedStatistics,NS).该方法需要首先分析DAA协议中的各种复杂运算,针对不同的运算选用当前性能较好的算法,然后统计各个算法中大整数单精度乘法、单精度加法、读内存、写内存等基本运算的数目,最后通过汇总并转换得出DAA协议中各实体以机器周期为单位的性能负荷分布和总性能负荷.比较分析表明,该方法不仅能相对准确、精细、有效地定量计算出DAA协议中各实体的性能负荷和总的性能负荷,而且测出的性能负荷具有平台无关性.最后为了说明该方法的有效性,将NS方法应用于有关可信计算匿名证明的一个典型方案的性能负荷估算.关键词可信计算;直接匿名证言;Camenisch-Lysyanskaya签名;知识证明;性能负荷1引言可信计算组织TCG在TPM规范1.2版中采用了直接匿名证言(DirectAnonymousAttestation,DAA)协议[1],该协议主要基础包括Camenisch-Lysyanskaya签名方案[2]、基于离散对数的知识证明和Fiat-Shamir启发式方法[3],既解决了隐私CA的瓶颈问题,又实现对TPM芯片的认证和匿名,是当前可信计算平台身份证明最好的理论解决方案之一.但是该协议非常复杂,实现过程中不仅涉及到多个实体,而且涉及大量的耗时运算.性能问题突出制约了该协议的广泛应用.为了进一步优化该协议的性能,找出性能瓶颈,定量地分析和测量DAA中各个实体的性能负荷是一个十分重要且必须的工作.对于这一问题,最好的方法是开发出实际的DAA系统,在真实的环境中实际测量.但实际上,目前产业界生产的可信计算产品如TPM芯片、可信计算机(台式机和笔记本)等采用DAA协议进行平台身份认证的产品还比较少见,再加上完整的DAA协议流程包括TPM、平台Host、发布方Issuer、验证方Verifier和可信第三方TTP等共5个实体,在真实的运行环境测试性能负荷分布不仅需要TPM支持,而且还需要开发和建设其它4个实体.显然,这是一个复杂的系统工程,需要较大的成本和时间开销.因此,通常采用以下两种方法对DAA的性能进行定量分析和测试.(1)仿真环境实测法.文献[1]是在IBMThink-PadT41(1.7GHzIntelPentiumMCPU,1GBRAM,Linux)上运行IBM开发的DAA原型系统,测量的结果是,TPM向发布者申请DAA证书需要2.4s,其中TPM约占用25%,主机约占用25%,发布者约占用50%的时间;TPM每次向验证者认证自己需要4.4s,其中TPM约占用8%,主机约占用47%,验证者约占用45%的时间.文献[4]是在Inteldual-core3.2GHz、1GBRAM、Windows平台上开发DAA原型系统,设计了tpm-module,host-mod-ule,server-module3个模块.测量的结果是,在Join阶段,TPM需要15.2s,Host需要12s;在Sign阶段,TPM需要13.8s,Host需要20.6s;在Verify阶段,TPM需要0s,Host需要30.4s.值得注意的是,此类方法通常在单台机器上对DAA的各协议实体进行性能测试,不计通信开销.这和在实际的运行环境进行测试是有差别的,毕竟原型系统不是实际运行环境.而且协议中涉及到的多个实体如果均在同一个平台上运行,会相互影响彼此的运行效率,因此该方法测试的性能负荷分布并不准确.(2)运算符号化统计法.该方法是将DAA协议中的各主要运算符号化,然后统计符号次数并求和.例如只需将DAA中涉及的主要运算的表示符号约定:Gn:一指数模n运算,例如gamodn(Gn是G1n的简写);G2n:两指数连乘模n运算,例如gahbmodn;G3n:三指数连乘模n运算,例如gahbycmodn;Gin:依上述Gn,G2n,G3n的定义类推;GΓ:一指数模Γ运算,例如gamodΓ;G2Γ:三指数连乘模Γ运算,例如gahbycmodΓ;GiG3依上述GΓ,G2的运算;Pv:验证一个数为素数的运算;H:Hash运算;则DAA协议的性能分布如表1.表1基于运算符号化统计法的DAA性能负荷分布阶段参与方申请加入(Join)进行签名(Sign)签名验证(Verify)Verifier4·G2实际上,有关DAA扩展和改进的大量文献(如文献[5-11])均采用该方法进行性能负荷分析.因为该方法简单,且在同类运算性能的比较上非常有效,如Gn<G2n<G3n,GΓ<G2类运算之间无法进行比较.因此,当各协议实体的不同类型运算较多时,该方法不能定量估算性能负荷及其比例关系,不便于各阶段、各实体性能负荷的比较分析.鉴于以上原因,提出了以机器周期为基本性能单位的性能负荷分布测量方法———归一化统计法(NormalizedStatistics,NS).该方法需要首先分析DAA协议中的各种复杂运算,针对不同的运算选用当前性能较好的算法,然后统计各个算法中大整数单精度乘法、单精度加法、读内存、写内存等基本运算的数目,最后通过汇总并转换得出DAA协议中各实体以机器周期为单位的性能负荷分布和总性能负荷.理论分析表明,该方法不仅能相对准确、精细、有效地定量计算出DAA协议中各实体的性能负荷和总的性能负荷,而且测出的性能负荷具有平台无关性.最后为了说明该方法的有效性,将NS方法应Page3用于有关可信计算匿名证明的一个典型方案的性能负荷估算.2DAA协议流程分析本节将依据文献[1]对DAA协议进行流程分析.文献[1]重点描述DAA实现认证和匿名的复杂运算和步骤,但协议流程描述并不详细和完整.如发布DAA证书时发布方对谁提供零知识证明协议证明DAA证书构造正确?谁对DAA证书进行了签名?等等.本节将对此进行补充,使得DAA更明确和完整.2.1DAA协议的常数和假设DAA协议涉及到的安全参数和长度要求包括,ln为RSA模数长度,长度为2048位;lf为TPM秘密ID的长度,长度为104位;le为指数e的长度,长度为368位;le为选择e的区间长度,长度为128位;lv为随机数v的长度,为2536位;l为零知识协议安全常数,长度为80位;lH为Hash函数输出长度,即SHA-1,长为160位;lΓ模数Γ的长度,长度为1632位;lρ为ρ的长度,与Γ一起应用于假名,长度为208位.假设1.(StrongRSAAssumption)不存在可行的算法,对任意随机的RSA模数n和一个随机元素u∈Zn,计算出e>1和v,使得ve≡umodn.假设2.(DecisionalDiffie-HellmanAssump-tion)假设Γ为lΓ比特的素数,ρ为lρ比特的素数且ρ|Γ-1.设γ∈ZΓ为阶等于ρ的元素,对足够大的lΓ和lρ,不存在可行的算法可以区分四元组{(δ,δa,δb,δab)}和{(δ,δa,δb,δc)},其中δ为〈γ〉中的一个随机元素,a、b和c为区间[0,ρ-1]内的随机元素.2.2DAA协议初始化DAA协议初始化是在发布方和可信第三方之间进行的.发布方在生成DAA公钥的同时向可信第三方提供一个非交互式的零知识证明,证明其公钥的合法性.这对于其后参与者在发布方作弊时也能保持匿名起到了关键的作用.1.发布方选择一个安全素数乘积构成的RSA模数n=pq,其中p=2p+1,q=2q+1,p,q,p,q,都是素数,n长度为ln;2.选择QRn的一个随机生成元g;3.选择随机整数x0、x1、xZ、xS、xh、xg∈[1,pq],并计算g=gxgmodn,h=gxhmodn,S=hxsmodnZ=hxZmodn,R0=Sx0modn,R1=Sx1modn;4.提供一个非交互式的零知识证明发布方公钥构造正确.即发布方对g和h相对于g的离散对数作零知识证明,对S和Z相对于h的离散对数作零知识证明,对R0和R1对S的离散对数作零知识证明;(1)发布方选择随机数rxg,rxh,rxS,rxZ,rx0,rx1∈[1,pq],计算txg=grxgmodn,txh=grxhmodn,txS=hrxsmodn,txZ=hrxZmodn,tx0=Srx0modn,tx1=Srx1modn;(2)可信第三方选择一个随机比特串nTI∈{0,1}lH作为防重放攻击的nonce,发送给发布方;(3)发布方也选择一个随机比特串nIT∈{0,1}lH作为防重放攻击的nonce,并计算cxg=H(txg‖nTI‖nIT),cxh=H(txh‖nTI‖nIT),cxS=H(txs‖nTI‖nIT),cxZ=H(txZ‖nTI‖nIT),cx0=H(tx0‖nTI‖nIT),cx1=H(tx1‖nTI‖nIT);(4)发布方计算sxg=rxg+cxgxg,sxh=rxh+cxhxh,sxS=rxS+cxSxS,sxZ=rxZ+cxZxZ,sx0=rx0+cx0x0,sx1=rx1+cx1x1,将(cxg,sxg,cxh,sxh,cxS,sxS,cxZ,sxZ,cx0,sx0,cx1,sx1,nIT)传给可信第三方;(5)可信第三方验证sxg<(pq×2h+1),sxh<(pq×2h+1),sxS<(pq×2h+1),sxZ<(pq×2h+1),sx0<(pq×2h+1),sx1<(pq×2h+1),并计算H(gsxgt-cxgxgmodn)=cxg,H(gsxht-cxhxhmodn)=cxh,H(hsxst-cxsxsmodn)=cxS,H(hsxzt-cxzxzmodn)=cxz,H(Ssx0t-cx0x0modn)=cx0,H(Ssx1t-cx1x1modn)=cx1;5.选择素数Γ为lΓ比特,ρ为lρ比特且Γ=rρ+1.选择一个随机数γ∈RZγ(Γ-1)/ρmodΓ;6.DAA发布者将(n,g,g,h,S,Z,R0,R,γ,Γ,ρ)发送给可信第三方,可信第三方用其私钥对此签名,随后发布方公布发布者公钥.2.3DAA-Join协议设发布者公钥PK1=(n,g,g,h,S,Z,R0,R1,γ,Γ,ρ),发布方对PK1的签名使用的公钥是PK1,假设发布方基名是bsn1.DAAseed为TPM产生(f0,f1)的恒定常量.给TPM;1.平台计算ζ1=(H(1‖bsn1))(Γ-1)/ρmodΓ,将结果返2.TPM检查ζρf=H(H(DAAseed‖H(PK1))‖cnt‖1)modρ,记f0=LSBlf(f),f1=CARlf(f),选择一个随机数v∈R{0,1}l+ln,计算U=Rf00Rf11Svmodn,N1=ζf0+f2U和N1发送给平台,平台转发给发布方;3.发布方检查撤销列表中的所有f0和f1,验证N1≠Page4lfζf0+f211modΓ.发布方同时还检查该平台以前使用的N1,如果平台位于撤销列表中,发布方终止Join协议;4.TPM通过零知识协议向发布方证明其拥有f0、f1和v以及U和N1的正确构成;(1)TPM选择随机数rf0,rf1∈R{0,1}lf+l+lH和rv∈R{0,1}lf+2l+lH,计算U~=Rrf00Rrf11Srvmodn,N~将结果发送给平台;(2)发布方选择一个随机比特串ni∈{0,1}lH作为防重放攻击的nonce,发送给平台;(3)平台计算ch=H(n‖R0‖R1‖S‖U‖N1‖U~‖N~ni),返回结果给TPM;(4)TPM选择TPM端的nonce,nt∈{0,1}l,计算c=H(ch‖nt);rv+cv;(5)TPM计算sf0=rf0+cf0,sf1=rf1+cf1,sv=(6)TPM发送c,nt,sf0,sf1,sv给平台,平台转发给发布方;(7)发布方计算U~=U-cRsf00Rsf11Ssvmodn,N~然后验证c=H(H(n‖R0‖R1‖S‖U‖N1‖U~‖N~sf0,sf1∈{0,1}lf+l+lH+1,sv∈{0,1}ln+2l+lH+1;5.发布方选择随机数v^∈R{0,1}lv-1和素数e∈R[2le-1,2le-1+2le-1],计算v=v^+2lv-1,A=Z6.发布方向平台证明其A计算正确(防止发布方得到A后,选择一个b〈h〉,且be=1modn,返回Ab给平台,可用于后继跟踪平台);(1)平台选择一个随机的nonce,nh∈{0,1}lH,将结果发送给发布方;(2)发布方随机生成re∈R[0,pq],计算A~=(Z/USv)remodn;(3)c=H(n‖Z‖S‖U‖v‖A‖A~‖nh)和se=re-c/emodpq,并将结果c,se,A,e,v发送给平台;(4)平台验证e是素数且位于区间[2le-1,2le-1+2le-1],计算A^=Ac(Z/USv)semodn,验证c=H(n‖Z‖S‖U‖v‖A‖A^‖nh);7.平台发送v给TPM;8.TPM计算v=v+v,保留v、f0和f1.2.4DAA-Sign协议(HΓ(1‖bsnv)){Γ-1}/ρmodΓ;1.根据验证方是否提供bsnv,平台计算ζ∈R〈γ〉或ζ=2.平台随机选择整数w,r∈{0,1}ln+l,计算T1=Ahwmodn和T2=gwhe(g)rmodn.TPM计算Nv=ζf0+f2lfmodΓ并将结果发送给平台;3.TPM和平台合作生成一个零知识证明,证明T1、T2来自于DDA证书,且Nv计算中应用的f为该DAA证书的秘密;(1)TPM随机选择rv∈R{0,1}lv+l+lH,计算1t=Rrf00Rrf11Srvmodn,r~f=rf0+r2lfT~TPM将T~(2)平台随机生成re∈R{0,1}le+l+lH,ree∈R{0,1}2le+l+lH+1,rw,rr∈R{0,1}ln+2l+lH,rew,rer∈R{0,1}le+ln+2l+lH+1,计算T~T~2=T-re2grewhreegrermodn;(3)平台计算ch=H(n‖g‖g‖h‖R0‖R1‖S‖Z‖γ‖Γ‖ρ‖ζ‖T1‖T2‖Nv‖T~并将结果发送给TPM,TPM选择一个随机的nonce,nt∈{0,1}l,计算c=H(H(ch‖nt)‖b‖m),并将nt,c返回给平台;(4)TPM计算sv=rv+cv,sf0=rf0+cf0,sf1=rf1+cf1,并将3个结果发送给平台;(5)平台计算se=re+c(e-2le-1),see=ree+ce2,sw=rw+cw,sew=rcw+cwe,sr=rr+cr,ser=rer+cer;(6)平台最终输出对m的签名:σ=(ζ,(T1,T2),Nv,c,n,(sv,sf0,sf1,se,see,sw,sew,sr,ser)).2.5DAA-Verification协议1.计算2.验证c=H(H(H((n‖g‖g‖h‖R0‖R1‖S‖Z‖γ‖Γ‖ρ‖ζ‖T1‖T2‖Nv‖T~以及Nv,ζ∈〈γ〉,sf0,sf1∈{0,1}lf+l+lH+1和se∈{0,1}le+l+lH+1;3.如果验证方提供了基名,验证4.检查撤销列表上所有的f0、f1,验证Page53DAA协议的性能估算新方法———NS方法NS方法的步骤如下:(1)首先进行复杂运算的统计;(2)确定主要运算及其算法选择;(3)基本运算统计;(4)以机器周期数为基本单位估算性能负荷分布.3.1DAA协议的复杂运算统计NS方法的第1步是进行复杂运算的统计.DAA包括初始化阶段、Join协议阶段、Sign阶段和验证阶段,我们在进行复杂运算统计时,实体仅考虑发布方Issuer、Host平台、TPM以及验证方Verifier.DAA协议是以大数运算为主,主要的复杂运算包括大素数选择、大随机数产生、模指数运算、SHA-1运算、大整数乘法和大整数加法等.下面将各种复杂运算按照实体进行统计,可以很容易地看出各个协议实体在整个协议过程中的复杂运算消耗.由于篇幅关系,统计过程略.统计结果见表2.其中lc是TPM撤销列表的长度.运算实体Host0次9次20次4次9次6次TPM0次7次14次4次6次8次Issuer5次18次24次6次7次8次Verifier0次0次17+lc次4次0次0次3.2DAA复杂运算的算法选择NS方法的第2步是确定主要运算及其算法选择.从表2可以看出运算次数较多是大整数模指数运算、大随机数运算和大整数乘法运算.其它运算如大素数选择、SHA-1运算、大整数加法等运算次数较少,因此,在性能估算时,主要考虑大整数模指数运算、大随机数产生运算和大整数乘法运算.另外,对主要运算的算法选择时,应遵循一个基本的原则,即选择的算法应该是该运算使用得最多、最广泛的算法,并已经应用于GMP、NTL、Crypto++、LibTomCrypt(LibTomMath)、OpenSSL以及miracl等库中.根据以上原则,大随机数产生运算选择Lehmer算法1.提出的线性同余法算法.如算法1所示.其中a是乘子,c是增量,x0为种子,m为模数,当a≈xi,该算法主要运算是一次模乘运算.著名的粒子输运MonteCarlo程序MCNP、MORSE和KENO的随机数发生器均基于该方法.模指数运算选择Montgomery模指数算法[12],该算法是目前最好的模指数算法之一,由滑动窗口指数算法结合Montgomery模乘法,如算法2所示.算法2.Montgomery模指数算法.输入:整数m=(ml-1…m1m0)b,gcd(m,b)=1,R=bl,输出:xemodm1.x~←Mont(x,R2modm),A←Rmodm;2.对于i从t递减到0,执行:3.A←Mont(A,1);4.返回A.该算法主要运算如表3.其中t+1表示指数e的二进制长度,l表示以b为基的数的长度.表3Montgomery模指数算法的主要运算次数步骤Montgomery模乘法次数单精度乘法次数123算法1和2的关键运算均是模乘运算,因此模乘运算算法的选择非常关键.在众多的模乘算法中,选择CIOS算法[13],该算法将多精度乘法和模约减算法完美地融合为一体,在读写内存等方面节省了许多资源,如算法3所示.算法3.CIOS模乘算法.输入:整数m=(mn-1…m1m0)b,x=(xn-1…x1x0)b,输出:xyR-1modm1.A←0;2.对于i从0到n-1,执行:2.1.A←A+xiy;2.2.ui←a0mmodb;2.3.A←(A+uim)/b;3.如果Am,则A←A-m;4.返回A.算法3包含单精度乘法、单精度加法、读内存以及写内存的次数如表4.其中k表示以b为基的大整数的位数.Page6表4COIS模乘算法的基本运算及次数统计表法[14].如算法4所示.基本运算单精度乘法单精度加法读内存写内存CIOS算法2k2+k4k2-k-14k2+7k2k2+4k多精度乘法运算选择效率较高的Comba算算法4.Comba多精度乘算法.输入:两个整数x和y,长度分别为n和t,基为b输出:乘积的b进制表示x×y=(wn+t-1…w1w0)b1.(v2v1v0)b=0;2.对于i从0到n+t-2,执行:2.1.(v2v1v0)b←(v2v1v0)b+∑i2.2.wi←v0,v0←v1,v1←v2,v0←0;3.wn+t-1←v0;4.返回(wn+t-1…w1w0)b.算法4包含单精度乘法、单精度加法、读内存以及写内存的次数如表5.其中k表示以b为基的大整数的位数.表5Comba多精度乘算法的基本运算及次数统计表操作单精度乘法单精度加法读内存写内存Comba算法k22k2-22k22k由于算法1的实现主要包括算法3,根据表4,得算法1包含的基本运算统计表6.操作单精度乘法单精度加法读内存写内存Moktgomery模乘算法2k2+k4k2-k-14k2+7k2k2+4k由于算法2的实现主要包括算法3和4,根据表4、表5得算法2包含的基本运算统计表7.表7Moktgomery模乘算法的基本运算及次数统计表操作单精度乘法单精度加法读内存写内存Moktgomery模乘算法单精度乘法次数3l(l+1)(t+1)03.3DAA协议各阶段的基本运算统计NS方法的第3步是基本运算统计.NS方法的基本运算是单精度乘法、单精度加法、读内存和写内存.之所以选择这些运算作为NS方法的基本运算,是因为这些基本运算的机器周期很容易确定.由于当前的多数计算机为32位机型,因此,选择b=32.如果机型为64位,则b=64,则统计的相关结果减半.3.3.1DAAJoin阶段的基本运算统计和Issuer.Join阶段的基本运算统计表8.在Join阶段,协议实体包含Host平台、TPM表8DAA协议Join阶段的基本运算次数统计表Host114385681226020918233330857117121378TPM383098821376894638389356930195455631Issuer5609846415521356895699016652860589803.3.2DAASign阶段的基本运行统计Sign阶段的基本运算统计表9.在Sign阶段,协议实体包含Host和TPM.表9DAA协议Sign阶段的基本运算次数统计表Host735976684727407463750465815376673079TPM2036416602011462422078784361043593543.3.3DAAVerification阶段的基本运算统计在Verification阶段,协议实体包含Verifier,取lc=0.Verification阶段的基本运算统计表10.表10DAA协议Verification阶段的基本运算次数统计表Verifier8130905968033492738294217144163370843.4DAA协议的性能负荷分布及总性能负荷的估算与分析NS方法的最后一步是以机器周期数为基本单位估算性能负荷分布.定义1.令执行一次单精度乘法运算的机器周期数为θ0,执行一次单精度加法的机器周期数为θ1,读内存的机器周期数为θ2,写内存的机器周期数为θ3.在DAA协议的某一阶段某实体运行单精度乘法n0次,运行单精度加法n1次,读内存n2次,写内存n3次,则该实体在此阶段运行时所需机器周期总数为假定DAA整个协议均运行在X86指令系统上,通常X86指令系统执行一次单精度乘法运算的机器周期数了θ0=2,加法的机器周期数θ1=2,读内存的机器周期数θ2=1,写内存的机器周期数θ3=1.由式(1)根据表8在Join阶段各实体的机器周期总数如表11.图1为Join阶段的性能分布图.从图1可以看出,在该阶段Verifier的性能开销占0%,TPM占33.48%,Host占16.58%,Issuer占49.94%.Page7表11Join阶段的各协议实体的机器周期总数由式(1)根据表9在Sign阶段各实体的机器周期总数如表12.图2为Sign阶段的性能分布图.从图2可以看出,在该阶段Issuer、Verifier的性能开销占0%,TPM占21.68%,Host占78.32%.表12Sign阶段的各协议实体的机器周期总数由式(1)根据表10在Verify阶段各实体的机器周期总数如表13.图3为Verify阶段的性能分布图.从图3可以看出,在该阶段TPM、Issuer的性能开销占0%,Verifier占100%.表13Verify阶段的各协议实体的机器周期总数由式(1)根据各实体的机器周期总数如表14.图4为总性能分布图.从图4可以看出DAA整个协议完成各实体的总性能开销分布.TPM占16.08%,Host占17.46%,Host占27.51%,Issuer占31.81%,Verifier占24.22%.显然,采用此方法得出的性能分布与单机系统仿真环境实测法得出的结果完全不一致[2-3].另外,还可以对各实体在协议的各阶段之间的性能开销做一个比较:(1)对于TPM,显然有TPMJoin>TPMSign>TPMVerify,其中,Join阶段占65.23%,Sign阶段占34.77%,其它两阶段占0%.(2)对于Host,显然有Hostsign>HostJoin>HostVerify,其中,Sign阶段占79.72%,Join阶段占20.28%,其它两阶段占0%.(3)而对于Verifier,仍有VerifierVerify>Verifiersign=VerifierJoin其中,Verify阶段占了100%,其它三阶段占0%.4NS方法的应用为了验证NS方法的有效性,本节将NS方法应用于可信计算匿名证明的文献[11]典型方案的性Page8能负荷估算,并将该方案与原方案进行比较.首先统计文献[11]中的复杂运算.文献[11]主要运算包括E(Fq)的点加、标量乘[15]和非双线形映射,而E(Fq)的点加、标量乘和非双线形映射的主要开销是求逆(I表示)、模乘法(M表示)和模平方(S表示).仿射坐标表示时:两不同点相加(点的加法),需要两次模乘法,1次模平方,1次求逆,即2M+1S+1I;相同点相加(点的倍点),需要2次乘法,2次模平方,1次求逆,即2M+2S+1I.对采用Tate对计算非双线形映射[16],需要6次Mk,8次Mb,2次Sk,(19+2k)次M,8次S,4次I,即6Mk+8Mb+2Sk+(19+2k)M+8S+4I,其中Mk≈k1.6M,Mb=kM,Sk=2kS,k是Fpk嵌入系数.表15是文献[11]中协议各阶段的主要运算统计表.JoinSignTPM010VerifyVerifier155然后确定主要运算及其算法.模乘法运算选用第3节中的CIOS算法;模平方算法选用Montgomery模平方算法的改进算法OMMS1,适合通用32位处理器计算大整数;对于模逆算法,根据费马定理,当q是素数,a是正整数且不能被q整除时有a-1=aq-2modq.因此,对E(Fq)内元素求逆都可和模指数运算统一,因此模逆算法选用Moktgomery模乘算法.第3步是的基本运算统计.取嵌入系统k=1,E(Fq)中元素长度为160位,表16是协议各阶段运算统计表.运算阶段JoinSignTPM40770553747912738428VerifyVerifier7862607723751107453562379最后以机器周期数为基本单位估算性能负荷分布.按照第3节的方法,表17是协议各阶段各协议实体的机器周期总数.表18是各实体的总性能负荷分布.JoinSignTPMVerifyVerifier表18文献[11]方案各实体的总性能负荷分布作定量的比较:另外,可以将最初的原始方案和文献[11]方案(1)对于两方案总开销,文献[11]方案机器周期总数的理论结果为94469301,最初的原始方案机器周期总数的理论结果为18669017541.显然,文献[11]方案的性能远远高于最初的原始方案的整体性能,高3个数量级.(2)对于TPM,文献[11]方案总开销为819543,最初的原始方案的总开销为3226613073.显然,文献[11]方案对TPM的性能要求远远低于最初的原始方案,低4个数量级.(3)对于Host,文献[11]方案总开销为6476791,最初的原始方案的总开销为5085172621.显然,文献[11]方案对Host的性能要求远远低于最初的原始方案,低3个数量级.(4)对于Issuer,文献[11]方案总开销为82385865,最初的原始方案的总开销为5878593311.显然,文献[11]方案对Host的性能要求远远低于最初的原始方案,低两个数量级.(5)对于Verifier,文献[11]方案总开销为4787102,最初的原始方案的总开销为4478638536.显然,文献[11]方案对Verifier的性能要求远远低于最初的原始方案,低3个数量级.5NS方法与其它方法的比较“符号化运算统计法”进行比较分析.有如下特点:本节将NS方法与“仿真环境模拟测试法”和(1)NS方法与“仿真环境模拟测试法”相比,具一方面,NS方法不受实际测试环境、开发技Page9术、运行平台、网络环境等方面的影响.因此,应用本方法进行同一方案中不同协议实体之间、不同阶段以及不同方案之间性能的比较和分析要比“仿真环境模拟测试法”更方便和准确.另一方面,“仿真环境模拟测试法”只需要在理解协议的基础上借助于一些大数运算库和加密库就可以开发实体原型进行仿真测试,理论分析难度要比NS方法小.但需要用户熟悉大数运算库和加密库的编程.(2)NS方法与“符号化运算统计法”相比,具有如下特点:NS方法更有效.NS方法将所有复杂运算转化和汇总为以机器周期为单位的性能负荷分布和总性能负荷,便于不同阶段、不同实体之间的比较分析.克服了符号化统计法在不同运算间不能直接进行比较的缺点.NS方法精细和准确.NS方法由于深入分析了各主要运算具体算法的内部特点,将各种负责运算归结为单精度乘、单精度加、读内存和写内存等基本操作.这样得出的结果要比符号运算统计法更精细和准确.NS方法更适用.NS方法不仅适合同一方案不同实体之间的性能对比,更合适于不同DAA方案之间的性能对比.如第4节.NS方法理论分析难度高.与“符号化运算统计法”相比,NS方法不仅需要分析算法中的主要运算,而且还要分析算法的实现过程以及基本运算的次数,所以,NS方法理论分析难度高于“符号化运算统计法”的理论分析难度.从以上的分析可以看出,尽管本文是针对原方案提出的性能估算新方法,但该方法也适用于以后相关的其它新方案.特别适合与计算类型较多、方案之间需要精细和准确比较的场合.6总结性能问题是阻碍DAA协议的广泛应用的瓶颈.本文提出的以机器周期为基本性能单位的性能负荷分布测量方法具有重要的意义.该方法需要首先分析DAA协议中的各种复杂运算,针对不同的运算选用当前性能较好的算法,然后计算各个算法中大整数单精度乘法、加法、读内存、写内存等基本运算的数目,最后通过汇总并转换得出DAA协议中各实体以机器周期为单位的性能负荷分布和总的性能负荷.我们下一步的工作将在两个方面开展:(1)将该方法应用于其它方案的性能分析以及各方案之间的性能分析与比较;(2)进一步优化DAA协议.
