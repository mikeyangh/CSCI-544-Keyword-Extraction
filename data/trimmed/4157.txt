Page1基于谓词执行序列的软件缺陷定位算法李伟郑征郝鹏高乙超饶培峰宫成(北京航空航天大学自动化科学与电气工程学院北京100191)摘要谓词执行信息收集和利用的程度会直接影响基于谓词的统计学缺陷定位方法(PBSD)的定位效果.文中主要围绕两个问题进行研究:(1)是否可以通过增加谓词的执行信息量来提高算法的定位精度?(2)执行信息量与算法定位精度有什么关系?在此基础上,设计了一种基于谓词执行序列的软件缺陷定位算法,通过引入谓词执行序列增大算法使用的谓词执行信息量.实验表明,增大谓词执行信息量确实可以提高缺陷定位精度,且当程序中谓词执行信息量充足时,定位精度会随信息量的增加不断提高.关键词软件缺陷定位;软件调试;统计学调试;谓词;执行序列1引言软件缺陷定位是指当软件发生失效时,程序员通过分析程序源代码,找到引发该失效的缺陷代码的行为[1].传统的软件缺陷定位多是利用交互式的调试工具人工完成,调试效率低,很难满足和适应大型复杂软件的调试需求,因此,相关研究人员一直致力于研究自动化的软件缺陷定位方法.近年来,一类基于谓词的统计学缺陷定位方法[2-7](PredicatesPage2精度之间有什么关系?来提高算法的定位精度?BasedStatisticalDebugging,PBSD)相继被提出,该类方法通过收集和分析程序运行过程中谓词的执行信息来确定程序中谓词与缺陷的相关程度.具体过程为:(1)通过对谓词进行插桩,得到程序运行过程中谓词的执行信息.虽然程序任何一次单独运行所输出的谓词执行信息不一定能反映完整的程序执行特征,但是通过多次运行可以收集到谓词的多组执行信息,将这些信息进行统计学分析可以得到谓词的一个较完整执行特征.(2)将谓词在程序运行成功与运行失败时所得到的执行特征进行一致性比较,获得谓词与缺陷的关联度.上述过程表明,作为从程序中抽取的特征,谓词执行信息的类型和信息量大小是这类方法的核心和基础.因此,本文针对现有PBSD方法所利用的执行信息进行分析,发现关于谓词执行信息收集存在的不足:现有方法忽略了对于谓词判断顺序这一重要信息的收集,导致其对某些缺陷的定位精度不够准确.据此,本文围绕以下两个问题展开研究:问题1:是否可以通过增加谓词的执行信息量问题2:谓词执行信息量的增加与算法的定位我们首先考虑增加算法中谓词的执行信息量,将谓词判断顺序这一有用信息加入到算法的设计中,提出了一种基于谓词执行序列的软件缺陷定位算法(PredicateExecution-SequenceBasedFaultLocalizationAlgorithm,简称Pesla算法),并通过进一步增大谓词执行信息量对算法进行扩展,得到Nbit-Pesla算法.实验表明,通过增加谓词的执行信息量的确可以有效提高算法的定位精度,但同时也发现,单纯增加算法中使用的谓词执行信息量并不一定会提高算法的定位精度,因为算法的定位精度还与待测程序有关.当待测程序中所蕴含的信息可以满足算法的需求时,算法的定位精度会随着执行信息量的增加不断提高,相反则会下降.基于该思想,本文最后讨论了如何针对不同程序的执行信息为Nbit-Pesla算法选取合适N值的问题.本文第2节简单介绍缺陷定位领域的研究现状;第3节给出Pesla算法的研究动机;第4节给出Pesla算法的基本思想和详细步骤,并将其扩展为Nbit-Pesla算法;第5节中将Pesla算法与Nbit-Pesla算法分别在Siemens、Space软件包中进行实验,将实验结果与CBI算法[2-3]、SOBER算法[4]、Mann-Whitney算法、Wilcoxon算法以及F-test、t-test算法[5]进行比较分析,得出结论;第6节对本文进行总结和展望.2相关研究软件缺陷定位的研究自20世纪70年代起,至今已形成几类比较有代表性的方法.本文主要介绍其中的两类.基于程序切片的方法[8]是最早提出的一类方法,该类方法将可能影响同一变量值的相关语句所组成的集合定义为一个切片,通过对比程序运行成功与失败时,同一变量所对应切片包含语句的异同,推测缺陷可能的位置.根据所使用的不同程序切片,基于切片的方法还可分为基于静态切片的方法[9]、基于动态切片的方法[8,10-12]以及基于执行切片[13]的方法.另外一类重要的缺陷定位方法是基于程序谱的方法,该类方法最早由Collofello和Cousins提出[14],通过插桩,收集程序运行过程中输出的执行信息来定位程序中的缺陷,但是早期的方法仅考虑了程序运行失败时的情况,直到Tarantula算法[15]的提出,才加入了程序运行成功时的执行信息.而根据所使用的程序谱的不同,该类方法可以分为基于可执行语句的方法和基于谓词的方法.作为一种典型的基于可执行语句的方法,Tarantula算法利用程序中可执行语句在失败运行时出现的频率来估计其含有缺陷的可能性,在此基础上,学者们又相继提出了另外33种基于可执行语句的方法,Naish等人[16]已对这33种方法进行了总结和系统的介绍.本文所提算法属于基于谓词的方法.CBI和SOBER作为两种代表性算法,在第3节论述本文研究动机时会有介绍.Hu和Zhang等人[6]指出SOBER所使用的假设检验方法有一个基本前提,即谓词的“EvaluationBias”[4]符合正态分布,但是实验表明,相当一部分谓词的“EvaluationBias”并不符合正态分布,因此,文献[6]将非参数假设检验的方法Mann-Whitney检验、Wilcoxon检验分别应用于缺陷定位[5],实验表明,非参数假设检验方法具有更好的定位效果.此外,在CBI和SOBER的基础上,Zhang等人[7]还提出了一种基于谓词“evaluationsequences”的改良方法,同样提高了对部分缺陷的定位精度.近年来,将软件缺陷定位技术与机器学习、数据挖掘等领域相关理论融合逐渐成为该方向研究的新热点,一系列算法被相继提出:Wong等人[17]提出了Page3基于BP神经网络的缺陷定位算法;而Briand等人[18]则提出使用C4.5决策树算法生成规则对测试用例进行分类进而达到缺陷定位的目的;另外还有一些基于机器学习的算法在文献[19]中有较详细介绍.3研究动机本节对CBI算法[2-3]和SOBER算法[4]中谓词执行信息的收集和使用进行分析比较,以一个实例说明本文的研究动机.Liblit等人[2-3]首次在缺陷定位方法中引入针对谓词的插桩,使用谓词执行信息构建CBI算法.该算法通过比较程序在运行成功与运行失败时谓词是否被判断为“真”来计算各谓词与缺陷的关联程度,实验结果表明程序中的缺陷确实与谓词的执行有关,这也证明了基于谓词进行缺陷定位这种思想的正确性和可行性.鉴于CBI算法的良好定位效果,Liu等人[4]提出了SOBER算法,该算法继承了CBI算法的基本思想,同时指出CBI算法中谓词执行信息的收集具有局限性:程序运行一次,一个谓词只执行一次,这种情况与绝大多数程序中谓词的执行情况是不相符的,实际上,大多数谓词在程序一次运行的过程中被多次执行.据此,SOBER算法在CBI算法的基础上细化了对谓词执行信息的收集,用程序一次运行中谓词被判断为“真”和为“假”的次数代替是否被执行为“真”的判断,并提出“EvaluationBias”的定义(如式(1)所示,该定义用来衡量谓词P在程序一次运行中被判断为“真”的概率,其中,Φ(P)表示“Evalua-tionBias”;nt(P)表示程序运行一次,谓词P被判断为“真”的次数;nf(P)表示程序运行一次,谓词P被判断为“假”的次数).根据该定义,Liu利用假设检验的方法构建出计算谓词与缺陷相关度的公式(如式(2)所示,其中,S(P)表示谓词与缺陷的相关程度;fs(P)表示在所有成功测试用例中,P被判断为“真”的概率;ff(P)表示在所有失败测试用例中,P被判断为“真”的概率;Sim表示fs(P)与ff(P)的相似程度,fs(P)、ff(P)和Sim的具体计算过程详见文献[4]).SOBER算法首先使用式(1)分别计算出程序在执行一个测试用例,运行成功或失败时,谓词P被判断为“真”的概率Φs(P)或Φf(P),运行全部测试用例后统计得到fs(P)和ff(P);最后利用式(2)计算出P与缺陷的相关程度S(P).实验表明,由于SOBER算法加入了谓词执行次数的比较,其定位效果在一些程序上的表现比CBI更好.然而,通过分析可以发现SOBER算法依然存在不足.图1是Replace程序中第26个版本的部分代码.图中第8行为缺陷代码,第9行为其正确版本.可以看出,该缺陷属于逻辑错误,即使经验丰富的程序员也需要一步步调试才可能定位.我们首先尝试用SOBER算法对其定位:加载该程序两个测试用例,一个运行成功,一个运行失败,缺陷所在谓词P的执行情况如表1所示,P判断为“真”记为“1”,判断为“假”记为“0”.将这两次运行所输出的谓词执行信息代入式(1),得到如下结果:在这两次运行中,P被判断为“真”的概率是相同的,而这并不能发现P上的缺陷.为确认这一结果,我们加载该程序所有测试用例,将执行信息分别代入式(1)后进行统计处理得到:两者仅仅表现出微小差别,进一步将其代入式(2)得到该谓词可疑度仅为-0.0013,排在所有谓词第47位,考虑到该程序共有65个谓词,这意味着需要检测超过72%的谓词才有可能发现该缺陷.通过分析发现,SOBER算法对该缺陷定位精度低下的原因在于:该算法仅考虑了谓词的执行次数,而忽略了谓词的判断顺序.在上述两次运行中,谓词判断为“真”和判断为“假”的次数是相同的,但其判断顺序不同,分别为“真假假真真真假假”和“真假假Page4假真真假真”.SOBER算法虽然比较了这两次执行中P被判断为“真”和“假”的次数,但是忽略了其判断顺序,从而无法找到其中的差别.对于该程序的其它测试用例,这种情况同样存在,SOBER算法无法捕捉谓词判断顺序上的差异,从而影响其定位精度.为解决这一问题,一个很自然的想法是加入谓词的判断顺序.由此引出本文研究的两个核心问题:(1)是否可以通过增加谓词的执行信息量来提高算法的定位精度?(2)谓词执行信息量的增加与算法的定位精度为回答这两个问题,在下一节中,本文将引入谓词执行序列的概念,通过定义谓词执行序列向量来表征谓词的判断顺序,从而在计算谓词缺陷关联度时引入谓词的判断顺序.之间有什么关系?根据本文4.1节描述的定义2,将表3所示信息代入,可得到成功时的2位执行序列向量为{2,1,2,2},失败时的2位执行序列向量为{2,2,2,1},可以看出这两个2位执行序列向量有明显区别,进一步将所有测试用例代入,使用本文4.2节的算法1,可得该谓词的缺陷关联度在所有谓词当中排在了第2位,相比SOBER算法提高了45位.4基于谓词执行序列的软件缺陷定位算法4.1基本定义定义1(谓词执行序列).设Pi是程序中第i个桩点处的谓词,程序在第k次运行中,Pi执行m次,则其执行序列定义为其中,esjPi的判断结果,若判断为“真”则esj谓词执行序列是通过在程序中插桩所获得的谓词实际执行信息,表示了程序运行过程中谓词的实际执行情况,包括谓词执行的次数、每次的判断结果以及判断为“真”和“假”的先后顺序.定义2(N位执行序列向量).设Pi是程序中第i个桩点处的谓词,程序第k次运行,Pi的N位执行序列向量定义为犈NkPi=(n00…︸00其中,na1a2…aN为执行序列ESk的个数,al=0或1,l=1,2,…,N.由此可得程序第k次运行,Pi的2位执行序列向量为犲k列ESkPi包含子序列a1a2的个数,al=0或1,l=1,2.N位执行序列向量是从谓词执行序列中提取出的谓词执行信息,是算法直接操作和使用的谓词执行信息.定义3(缺陷关联度).谓词Pi的缺陷关联度定义为程序运行成功时Pi的N位执行序列向量Pi+与程序运行失败时Pi的N位执行序列向量犈NPi-的距离,用2-范数表示:犈N当N=2时该表达式也可表示为其中,犲Pi+是程序运行成功时,Pi的两位执行序列向量;犲Pi-是程序运行失败时,Pi的两位执行序列向量.4.2算法描述本节将详细介绍基于谓词执行序列的缺陷定位算法Pesla的基本思想和实现步骤.Pesla算法的基本思想是:对于桩点处的谓词P,比较P在程序运行成功与失败时的执行序列,根据定义3算出所有桩点处谓词的缺陷关联度,将谓词按照缺陷关联度进行排序.P的缺陷关联度越大,则认为P以及与P有数据或控制关联的程序代码含有缺陷的概率越大.部分:Pesla算法的实现分为数据收集和数据统计两(1)数据收集部分.传统的数据收集方式是通过在待测程序中插入桩点,然后输入程序的测试用例来实现的.为公平比较算法的定位效果,本文选择与SOBER相同的插桩方式,对if/while/for这3类分支语句以及函数返回值(return语句)[2]中的谓词进行插桩;(2)数据统计部分.对收集到的谓词执行信息进行统计处理是Pesla算法的核心.收集到的谓词执行信息分为两类,一类是程序运行成功时的谓词执行序列集INFOs;另一类是程序运行失败时的谓词执行序列集INFOf(s和f分别表示成功测试用例和失败测试用例的个数).分别从INFOs和INFOf中统计出谓词Pi的2位执行序列向量犲Pi+和犲Pi-,代入式(4)即可得到Pi的缺陷关联度.计算出所有桩点处谓词的缺陷关联度后,将谓词按照缺陷关联度大小排序即可得到输出Report.详细描述Page5见Pesla算法.算法1.Pesla算法.输入:INFOs,INFOf输出:Report:最终的谓词排序结果符号:Infok:程序第k次运行,待测程序中所有桩点处1.ForallPi∈Pdo2.ForallInfok∈INFOsdo3.IfESk4.犲k5.Endif6.Endfor7.ForallInfok∈INFOfdo8.IfESk9.犲k10.Endif11.Endfor12.犲Pi+←∑s13.犲Pi-←∑f14.RPi←犲Pi+-犲Pi-15.Endfor16.Compositor()值得注意的是对于stat(ESk形需要讨论:情形1.ESk程中没有被执行,则犲k情形2.ESk行过程中仅执行了一次,若es10.5,0.5);否则犲k情形3.ESk即Pi在程序第k次运行过程中执行m次,则分别统计n00、n01、n10、n11的次数分别为犲k后犲kPi←犲k对于情形2,本文采用等概率处理的方法:若谓词在程序一次运行中只执行了一次,则假设第2次执行判断为“真”和为“假”的概率各为1/2,然后再对犲k4.3算法扩展Pi中的元素赋值.Pesla算法是基于谓词的2位执行序列向量,这种算法同样可以扩展到3位、4位以及更高位的执行序列向量,以增加更多执行信息的比较,但是这种执行信息的增加可能带来两种新的情况:一种是由于信息更加丰富,使算法定位精度提高;另一种是由于信息存在冗余,使算法定位精度下降.这就引出了前面提到的第2个问题,即谓词执行信息量的增加与算法的定位精度之间存在什么关系?为回答该问题,本节首先将对Pesla算法进行扩展,使其基于更大的谓词信息量进行计算,并且对扩展后的算法进行时间复杂度分析.后面的实验部分对该问题进行了回答.扩展后的算法命名为Nbit-Pesla算法(Nbit表示算法使用N位执行序列向量),其基本思想与Pesla算法基本一致.两者的不同说明如下.(1)对于函数stat(ESk2位执行序列向量,所以只需分为3种情形进行讨论;在扩展后,由于所需向量位数增加,谓词执行次数小于向量位数的情形也相应增加,对这种情况,我们一律采用4.2节用到的等概率补齐的方法对N位执行序列向量的元素赋值,详细描述见Nbit-Pesla子算法.算法2.Nbit-Pesla子算法.stat(ESk位执行序列向量的函数输入:ESk输出:犈NkPi:N位执行序列向量符号:a1a2…aN:同定义2中的a1a2…aN1.Ifm=0then/Pi没有被执行/2.犈NkPi=(0,0,…,0)3.Elseif1m<N/Pi执行次数小于N次/4.nes15.犈NkPi中其它元素赋值为06.ElseifmN/Pi执行次数大于等于N次/7.Forallj∈[1,m-N+1]do8.Ifesj9.na1a2…aN←na1a2…aN+110.Endif11.Endfor12.犈NkPi←犈NkPi/(m-N-1)13.Endif(2)计算缺陷关联度的函数由式(4)改为了式(3).Nbit-Pesla算法的基本思想表明,若N增大,算法所需处理的谓词执行信息量就会增加,并导致算法的计算复杂度提升.设待测程序包含t个桩点,s个运Page6行成功的测试用例,f个运行失败的测试用例,那么对于Nbit-Pesla算法,记录所有执行序列向量需要t×(s+f)×2N个存储单元,其空间复杂度为O(t×(s+f)×2N).计算谓词缺陷关联度的过程需要做(2N×(s-1)+2N×(f-1)+1)×t次加法,2×2N次除法和乘法运算,则Nbit-Pesla算法的时间复杂度为O(t×(s+f)×2N),对于同一待测程序,若t、s、f都不变,则算法的空间和时间复杂度会随N的增长呈级数增长.若待测程序规模很大且测试用例较多,这种增长速度是不可接受的.我们在选择算法时,不仅要考虑算法的定位精度,还需要权衡所付出的代价.因此,有必要研究算法定位精度与谓词执行信息量之间的规律,只有探明这其中的规律,才能合理选择算法以达到定位精度与计算代价之间的平衡.5实验及结果分析本文实验由3部分组成:(1)Pesla算法与现有表2目标程序的主要信息print-tokens(2programs)schedule(2programs)replacetot-infotcasSpaceSpace软件是欧洲航天局开发的一个矩阵描述语言(ADL)解释器,它可以从文件中读取ADL描述语句并检查文件内容是否合乎语法规则,如果ADL文件正确,Space将输出一个矩阵数据文件,包含矩阵元素信息、位置、激励,否则将输出错误提示,Space软件包含6218行可执行语句,914个桩点谓词,13496个测试用例,38个缺陷版本,每个版本中包含一个真正的缺陷,Space软件是软件缺陷定位研究领域公认的典型测试对象.5.2犘-score评价方法本文选用P-score[20]作为比较各算法定位精度的主要评价方法.P-score由Zhang等人[20]提出,相较T-score[21],不需要假设“有一个完美的程序调试员”,且使用更为方便、直接.下面介绍P-score的使用方法.首先给出P-score的计算公式:算法的比较,包括与CBI、SOBER、Mann-Whitney、Wilcoxon、F-test、t-test各种基于谓词算法的比较(其中SOBER、Mann-Whitney、Wilcoxon、F-test、t-test算法都是基于“EvaluationBias”所提出的方法);(2)当N取不同值时,各Nbit-Pesla算法之间定位效果的比较;(3)根据程序执行信息选择N的经验公式及其效果验证.为了更好地描述实验,在5.1~5.3节中我们首先对目标程序、评价方法和实验设置进行介绍.5.1目标程序参照之前的研究,本文选取Siemens软件包中的全部7段程序,和一个应用软件Space作为目标程序进行实验.Siemens软件包中的每个程序分别包含7~41个缺陷版本,每个缺陷版本中有一个人工植入的缺陷.表2中列出了目标程序的主要信息.例如,对于tcas程序来说,共有41个缺陷版本,每个版本中包含133~137行可执行语句,其中有11个桩点谓词,1608个测试用例,平均有23个失败的测试用例和1585个成功的测试用例.834065471191413496其中,L为目标程序中的谓词数量,P表示程序中与缺陷最相关的谓词,indexofP是谓词P在输出Report中的排序序号.为方便理解,举例如下,假设一个缺陷程序中含有10个谓词{P1,P2,P3,…,P10},与缺陷最相关的谓词为P8,利用算法得到的Report中谓词的排序为{P3,P7,P10,P8,…,P2},P8排在第4位,则P-score=4/10×100%=40%.P-score可以解释为所需检查的谓词数量越少,则算法对缺陷的定位精度越高.5.3实验设置为公平比较各算法的优劣,本文需要对4个影响实验结果的主要因素进行设置:缺陷版本的选择、缺陷最相关谓词的确定、桩点位置的确定和测试用例的选择.首先,根据5.1节中的介绍,Siemens软件包一共包含132个缺陷版本,Space软件中包含38个缺陷版本,但本文的实验并没有使用全部的缺陷版本,而是根据以下两条原则对缺陷版本进行筛选:Page7(1)对于一个程序的缺陷版本,其测试用例集中既要包含成功的测试用例,又要包含失败的测试用例;(2)缺陷程序中与缺陷最相关的谓词要能够明确地确定,这是因为程序中与缺陷最相关谓词的确定会对最终的实验结果产生较大影响,若无法清晰地确定该谓词的位置,则将此缺陷版本从实验中剔除.根据这两条原则,在Siemens软件包中共排除掉21个缺陷版本,在Space软件中排除掉10个缺陷版本①.本文选择文献[5]中使用的最相关谓词选择策略:第1步,确定缺陷位置.若缺陷在可执行语句上,标记该可执行语句,若缺陷为可执行语句的缺失,则标记距离缺失语句最近的下一条可执行语句;第2步,根据第1步标记的可执行语句,选择距离该可执行语句最近的谓词作为程序中与缺陷最相关的谓词,如有两个或更多谓词与该可执行语句距离一样近,无法确定唯一的谓词,将此缺陷版本剔除(在实验所选用的139个缺陷版本中,缺陷最相关谓词所在语句与标记的可执行语句之间都没有超过3行代码).与以往的研究[2-7]相同,由于本文研究不涉及缺陷定位的效果对测试用例的依赖,因此,在实验中同样是加载程序的全部测试用例,再将所得结果进行比较.在选择桩点位置时,本文选择与SOBER相同的设置,仅对程序代码中的分支语句(if、for、while)以及返回值(return)中的谓词[2]进行插桩.本实验所用计算机的CPU是两颗Xeon-E5630,主频2.53GHz,内存12GB.本文所选用的Siemens软件包与Space软件全部在Software-artifactInfrastructureRepository(SIR)网站下载获得,而Mann-Whitney、Wilcoxon、F-test、t-test假设检验算法也是在ALGLIB网站下载获得,CBI、SOBER算法则根据文献[2,4]中的描述实现.5.4Pesla算法与各算法的比较本节,我们将针对各算法的整体定位效果、不同程序的定位效果以及单个缺陷版本的定位效果3个方面分别进行比较,最后用假设检验来证明Pesla算法在定位精度上的优越性.首先,本文给出将各种算法应用在Siemens软件包的各缺陷版本后,所得到的定位效果对比,如图2所示(其中Wilcoxon、Mann-Whitney、SOBER、CBI、F-test,t-test的数据来源于文献[5]).图中横坐标表示所需检查的谓词占全部谓词的百分比,纵坐标为所发现的缺陷占全部缺陷的百分比.从图2中可以看出,在10个统计节点处,相对于其它算法,Pesla算法都表现出了更好的定位效果,尤其是当检查的谓词数量相对较少时,这种优势更为明显,例如,当检查10%的谓词时,Pesla可以定位33.33%的缺陷,其它算法中表现最好的Wilcoxon也仅能定位17.11%,Pesla定位到的缺陷数量接近Wilcoxon的2倍;Mann-Whitney的5倍,是其它算法的7~30倍,而当检查30%的谓词时,这种优势虽然有所下降,但Pesla仍旧表现出更好的定位效果.图2各算法在Siemens软件包上的定位效果对比图3给出了各种算法在各个程序上的定位效果对比,可以看出,在大多数程序上,相比于其它算法,Pesla都表现出了更高的定位精度,只有在tcas程序上,Wilcoxon比Pesla表现得更好.为了进一步验证Pesla算法在定位单个缺陷时同样具有更高的定位精度,本文又对各种算法在定位同一个缺陷时的表现做了比较,如表3、表4所示.在表3中,“Min”表示使用该算法定位一个缺陷所得到的最小P-score;“Max”表示最大的P-score;“Median”表示P-score的中位数;“Mean”表示P-score的均值;“Stdev”表示P-score的标准差.这5个指标中,“Median”和“Stdev”体现了算法在定位不同缺陷时所表现出的稳定性,其值越小,表明该算法的稳定性越好.从表3中可以看出,在这两个指标中,Pesla算法都是表现最好的那一个,即在使用Pesla算法定位不同缺陷时具有更高的概率,能够获得更高的定位精度.①本文中的设置与文献[5]中完全相同,因此所排除的缺陷Page8图3各种算法在单个程序上的定位效果对比表3各种算法在Siemens软件包上定位效果的详细对比表4Pesla算法对单个缺陷的定位效果对比P-scorePesla-P-scoreSOBERMann-WhitneyWilcoxonSOBERF-testt-test比较范围/%-1~1-5~5<-10-10~10<-20-20~20表4是Pesla分别与其它算法进行比较的结果,为方便理解该表,用一个例子来说明:对于第1列“P-scorePesla-P-scoreWilcoxon”的“<-1%”,它表示,在111个缺陷中,有61个缺陷,其P-scorePesla-P-scoreWilcoxon<-1%,也可以理解为,Pesla算法在定位61个缺陷时,定位精度比Wilcoxon算法高1%以上.“>1%”则表示,在111个缺陷中,有46个Median/%24.5639.8250.0063.0663.6475.8680.30缺陷个数7433474829711228632820缺陷,其P-scorePesla-P-scoreWilcoxon>1%,可理解为Wilcoxon算法在定位46个缺陷时,定位精度比Pesla算法高1%以上.从表4中可以看出,相比于其它算法,Pesla算法在定位绝大多数缺陷时的定位精度更高.下面我们给出各种算法应用在Space软件上的定位效果对比,如表5、表6所示.Page9谓词检查量/%1100表5各算法在Space上的定位效果对比表6各算法在Space上的定位效果详细对比WilcoxonMann-WhitneySOBERF-testt-test由于Space软件较大,其中包含的谓词数量较多,本文侧重比较当检查少量谓词时,各算法所能定位到的缺陷数量.由表5可以看出,只有检验少于1%的谓词时,Pesla定位到的缺陷数量稍少于Wilcoxon和Mann-Whitney,而在其它的统计节点处,Pesla都是定位到最多缺陷的算法.我们进一步对各算法在定位Space软件单个缺陷时的情况进行比较,从表6可以看出,相比于SOBER、CBI、F-test、t-test这4种算法,Pesla算法无论是在定位精度还是定位缺陷的稳定性上都有很大的优势;而相比于Wilcoxon和Mann-Whitney,Pesla则在定位缺陷的稳定性上表现更好.综合以上分析,我们可以得到以下结论:Pesla算法相对于其它算法具有更高的定位精度以及更好的定位稳定性.t检验来证实该结论,设:H0:利用P-score进行比较时,Pesla算法与X算法的定位精度没有显著差异.H1:利用P-score进行比较时,Pesla算法与X算法的定位精度有显著差异.表7为当X为不同算法时,得到的t检验的检验统计量P-value,如Pesla与Wilcoxon比较,使用t检验可以得到P-value<0.00005.可以看到,所有的P-value均小于0.05.若给定显著性水平α=0.05,则由表8中的结果可以得到:在显著性水平α=0.05下,拒绝原假设H0,认为Pesla算法与X算法具有显著差异,即使选择显著性水平α=0.01,以上结论仍然成立.为检验以上结论在统计上的显著性,我们使用缺陷个数10111818212528Median/%0.771.551.373.1146.0021.1720.68Pesla<5.0×表8不同犖bit-Pesla算法的缺陷定位效果比较比较范围/%=022<-140-1~122>149<-531-5~545>535<-108-10~1061>1024<-201-20~2096>2010因此,我们对于问题1的回答是:通过在算法中增加谓词的执行信息量确实可以有效提高算法的定位精度.5.5不同犖bit-Pesla算法的比较上节的实验结果表明Pesla算法相比其它算法具有更高的定位精度,这就引出了问题2:谓词执行信息量的增加与算法的定位精度之间有什么关系?为此,本文按照递增的方式选取N值,设N=3、4、5,将Nbit-Pesla算法应用于Siemens软件包与Space软件(注:当N大于等于6时,由于算法时间复杂度太高,对于Space而言,需要付出的代价太大,因此Page10不予考虑).与上节相同,本节同样针对不同Nbit-Pesla算法的整体定位效果、不同程序的定位效果以及单个缺陷版本的定位效果进行比较和讨论,最后对问题2进行回答.图4和图5是N取不同值时,Nbit-Pesla算法在Siemens软件包上的定位效果对比.可以看出,当检验的谓词数量不变,而N增大时,Nbit-Pesla算法并没有定位出更多的缺陷,相反,定位出的缺陷数量呈现出递减的趋势,尤其是当检验的谓词数量少于20%时,这种趋势表现的更明显.图5不同Nbit-Pesla算法对单个程序的定位效果对比但是,这并不能证明,随着N的增大,Nbit-Pesla对每个缺陷的定位精度都会下降.因此,我们统计了不同Nbit-Pesla对单个缺陷的定位结果,如表8、表9所示.算法Min/%Max/%Median/%Mean/%Stdev/%Pesla1.59100.0024.5630.4526.853bit-Pesla1.59100.0025.4032.5726.164bit-Pesla1.59100.0030.0034.1724.165bit-Pesla1.59100.0031.7535.5323.36从表9中可以看出,总体上来说,“Mean”随着N的增大而增大,“Stdev”却越来越小,这表明Nbit-Pesla算法的平均定位精度有降低的趋势,但针对不同缺陷,定位精度的波动性越来越小.由表8,我们可以看出,随着N的增大,Nbit-Pesla图4不同Nbit-Pesla算法在Siemens软件包的定位效果对比算法并不是对所有缺陷的定位精度都会降低,还有相当一部分缺陷的定位精度会持续提高,例如,3bit-Pesla算法对22个缺陷的定位精度与Pesla算法相同,对40个缺陷的定位精度要高于Pesla算法,仅对49个缺陷的定位精度低于Pesla算法;即使N增大至5,仍然有19个缺陷的定位精度在提高.经统计发现,这19个缺陷是包含在之前40个定位精度提高的缺陷中的,即这19个缺陷随着N的增大,其定位精度在不断提高.表10、表11列出了Nbit-Pesla算法在Space软件上对缺陷的定位效果.与Siemens软件包中得出的结论相似,当检验的谓词数量较少,如在1%、2%时,随着N的增大,Nbit-Pesla算法定位到的缺陷数量呈现出了比较明显的下降趋势,且其平均定位精度不断降低.Page11表10不同犖bit-Pesla算法在Space上定位效果对比谓词检查量/%11514111010262425242026262525502828282810028282828表11不同犖bit-Pesla算法在Space上的详细对比算法Min/%Max/%Median/%Mean/%stdev/%Pesla0.1144.970.774.7011.553bit-Pesla0.1144.751.105.5011.344bit-Pesla0.1144.971.706.3011.235bit-Pesla0.1144.752.306.6011.11但是,与先前观察到的结果一样,并不是对Space软件中的所有缺陷,Nbit-Pesla的定位精度都会下降.我们统计得到,对于Space软件v1、v3、v27版本中的缺陷,随着N增大,其定位精度在不断提高;而对于v7、v10、v12、v16、v18、v20、v21版本中的缺陷,其定位精度几乎没有变化.究其原因,我们发现:一个程序,其缺陷谓词在一个测试用例中的执行次数m是固定的,当m>N时,采用本文算法对该缺陷进行定位,总能获得较好的定位精度,若N增大的同时始终满足m>N,则Nbit-Pesla算法对该缺陷的定位精度也会持续提高或保持不变,但一旦出现m<N的情形,就需使用4.3节Nbit-Pesla子算法中所介绍的等概率补齐的方法来对该谓词的N位执行序列向量赋值.若N持续增大,所需补齐的位数就会增多,这会导致该缺陷谓词在程序运行成功时得到的N位执行序列向量与运行失败时得到的N位执行序列向量之间的区分度越来越小,最终造成对该缺陷的定位精度下降.由4.3节分析可知,Nbit-Pesla算法的计算复杂度随N的增大呈级数增长,图6、图7分别给出了N取不同值时,Nbit-Pesla算法定位Siemens和图6Nbit-Pesla算法在Siemens上的时间开销图7Nbit-Pesla算法在Space上的时间开销Space软件包中缺陷时的时间开销变化.图中纵坐标表示定位一个缺陷,算法的平均运行时间,单位是秒.可以看出,随着N的增大,算法的运行时间越来越大,与之前的分析一致.同样,图8、图9分别给出了N取不同值时,Nbit-Pesla算法定位Siemens和Space软件包缺陷时的空间开销变化.图中纵坐标表示定位一个缺陷,算法平均所需占用的内存大小,单位是兆字节.可以看出,随着N的增大,算法所占用的内存空间几乎是严格按照级数增长.图8Nbit-Pesla算法在Siemens上的空间开销图9Nbit-Pesla算法在Space上的空间开销综合本节实验,可以得到:若待测程序在运行过程中谓词的执行次数较多,所输出的谓词执行信息量可以满足算法需求,增大N的取值确实可以有效提高算法的定位精度.然而,如果无限制地增大N,不仅计算复杂度呈级数增长,而且对于某些程序,还会因为待测程序信息提供能力有限(由于大部分谓Page12词的执行次数较少),造成算法定位精度下降.因此,如何根据待测程序中谓词执行信息的情况来选择适合该程序的N是一个重要的问题.5.6犖bit-Pesla算法中犖的选择在本节中,通过大量的实验分析和验证,我们给出了根据程序执行信息选择N的一种方法,进而对该问题进行初步的探讨.假设待测程序共有L个谓词,Pi为第i个谓词(1iL).在一次缺陷定位过程中,待测程序共运行了W次(即有W个测试用例).ESk次运行中Pi的执行序列,|ESk度.令meanPi=∑W词Pi在所有测试用例中的平均执行次数,并设集合M={meanPi|i∈[1,L]}.我们用MeanM表示集合M中所有元素的均值,即对待测程序中所有谓词的平均执行次数求均值.进而,我们可以用式(6)对N进行设定:其中·表示向下取整.该公式等价于例如,在schedule2的第1个版本中,通过运行程序并统计执行信息可以得到MeanM=18,进而根据式(6)我们可以得到Ne=3.这与我们在5.5节实验中得到的能取得最优定位效果的N值是相同的.该公式的设计来源于以下两个方面的基本思想:(1)待测程序中谓词执行次数越多则选择的N值越大,这与我们在5.5节中得到的结论是相呼应的;(2)待测程序的执行信息能够较好地满足Nbit-Pesla算法获取信息的要求,即保证执行序列Pi(参见定义2)中的每一个元素所代表的序向量犈k列模式都能够有一定数量的子序列与之匹配.例如,当MeanM∈[2n+1,2n+2),根据式(6)得到Ne=n,则执行序列向量将包含2n个元素.从而,每个元素所代表的序列模式平均至少有1个以上的子序列与之匹配,最多可能存在2n+2-n个匹配的子序列;表12显示了在Siemens和Space软件包中139个程序上式(6)对于Ne的选择效果.其中,Nopt1表示能取得最优定位效果的N值;Nopt2表示能取得次优定位效果的N值;Nopt3表示能取得第3位定位效果的N值.选择效果Ne=Nopt1Ne=Nopt2Ne=Nopt3其它情况从表12中可以看出,在139个程序版本中,Ne对其中的78个准确选择到Nopt1;选择Nopt2的占所有版本数的17.3%;选择Nopt3的占了7.2%.超过80%的程序版本使用式(6)都可以选择到最好或者较好的N值(Ne的取值位于前3位).进一步,基于式(6)我们可以通过以下步骤对Nbit-Pesla算法进行简单改进,得到的算法简称Nebit-Pesla算法:第1步,搜集待测程序中桩点谓词在每个测试用例中的执行信息;第2步,根据执行信息统计得到MeanM,并使用式(6)计算Ne;第3步,令N=Ne,然后使用Nbit-Pesla算法对该程序进行缺陷定位.将Nebit-Pesla算法应用于Siemens和Space软件包,并与每个缺陷版本上取得最优定位效果的Nbit-Pesla算法(即N=Nopt1时所选择的Nbit-Pesla算法,以下简称为最优Nbit-Pesla)进行比较.图10中横坐标表示分别使用Nebit-Pesla和最优Nbit-Pesla定位时,P-score的差值,纵坐标表示版本个数.例如,图6中左边第1个柱状图表示:在119个缺陷版本上,Nebit-Pesla与最优Nbit-Pesla的定位精度(P-score计算结果)相差小于10%.Nebit-Pesla在90%以上的程序都可以取得与最优定位精度接近的效果(差别小于20%).图10Nebit-Pesla相比最优Nbit-Pesla的定位效果通过这两方面的实验,我们可以得到如下结论:使用式(6)计算得到的Ne确实可以对Nbit-Pesla算Page13法中的N进行最好或较好的选择.5.7结论的有效性讨论影响本文结论有效性的因素主要有以下3个:(1)各算法的复现是否正确;(2)P-score评价方法是否有效;(3)目标软件的选取是否合适.首先,对于SOBER算法和CBI算法,本文按照文献[2,4]所述步骤进行复现,并用文献[4]中所列举的例子验证了其正确性;对于Wilcoxon、Mann-Whitney、F-test,t-test算法,我们直接利用ALGLIB数理统计软件进行实现,而该统计软件已被多位学者和研究人员应用于研究和工程实践中,其计算精度和正确性可以保证.因此可以认为本文对于各算法的复现应该是正确的,所得到的实验结果和数据也是有效的.当前软件缺陷定位领域使用较多的3种评价方法为T-score、Expense以及P-score.每种评价方法都有不足,但都有一定的适用范围,其中T-score由Renieris和Reiss提出[22],该方法不但适用于基于语句的缺陷定位方法,还适用于基于谓词的缺陷定位方法;Expense则由Jones等人[21]提出,主要适用于基于语句的方法,而P-score则由Zhang等人[20]于近几年提出,主要适用于基于谓词的方法,因此,选用与本文研究最相关的P-score作为评价各算法定位精度的标准也是合理的.Siemens软件包一直以来就是研究软件缺陷定位的必选实验对象之一,但是由于其中所包含的缺陷都为人工植入,很难代表真实的软件缺陷,为此,本文增加了Space软件作为实验对象,得到了相同的结论,但这依旧不能排除对于其它实验对象,本文的研究会得到不同实验结果的情况.因此,在今后的研究中,增加更大规模的软件作为实验对象仍旧是一个重要的方面.6结束语软件缺陷定位在软件调试过程中是一项异常费时费力的工作,在现有方法中,基于谓词的统计学缺陷定位方法在定位精度上已有良好表现.本文在总结前人研究的基础上围绕两个问题展开研究,进一步丰富了算法所需的谓词执行信息,设计出基于谓词执行序列的缺陷定位算法,并对该算法进行了扩展.最后用实验证明增大谓词执行信息量的确可以有效提高算法的定位精度,并且当待测程序中所蕴含的谓词执行信息可以满足算法的需求时,算法的定位精度会随着执行信息量的增加不断提高.同时通过本文的工作也发现,若不考虑待测程序运行时对执行信息的提供能力,一味增加算法中处理的谓词执行信息量,反会使算法的定位精度降低.因此,本文最后讨论了如何针对不同程序的执行信息为Nbit-Pesla算法选取合适N值的问题.对N值设定方法的进一步分析和改进将是我们下一步的工作重点.
