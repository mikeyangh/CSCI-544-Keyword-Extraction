Page1基于FSM的测试理论、方法及评估刘攀1),2)缪淮扣1),2)曾红卫1)刘阳1)1)(上海大学计算机工程与科学学院上海200072)2)(上海市计算机软件评测重点实验室上海200072)摘要为搭建基于FSM的测试方法由理论研究通往工业应用的桥梁,文中讨论了若干基于FSM模型的测试方法及其相关理论,提出构造区分序列的理论及测试序列集合冗余约简的理论,补充并实现了若干基于FSM的测试生成算法.随后文中提出了基于FSM的测试方法评估的5项量化指标,实验评估了若干基于FSM模型的测试方法,给出了一些基于FSM测试的经验建议.文中的评估有助于基于FSM的测试方法在工业中的推广.关键词基于FSM的测试;测试评估;测试生成算法;基于FSM的测试理论;冗余约简1引言软件测试是提高软件可靠性和保证软件质量的一种重要手段.传统的软件测试依赖于人工测试,是Page2方向.该方法能由描述软件需求的形式规格说明生成测试序列,再检测待测系统(SystemUnderTest,SUT)[2]的运行是否严格遵守它的形式规格说明.由于测试序列的生成、测试执行及测试结果的分析能在一定程度上自动实现,因此降低了软件的测试成本,提高了测试效率.有限状态机(FiniteStateMachine,FSM)作为一种形式建模语言已被广泛用于描述软件的需求,基于FSM的测试方法亦被广泛研究.然而,基于FSM的测试仍然处于理论研究状态,并未在工业界得到广泛应用[1,3].为该方法搭建一条由理论界通往工业应用界的桥梁就显得非常必要,而充分的实验评估是实现这一目标的有效方式之一.现有研究对基于FSM的测试评估并不完善.Sidhu等人[4]通过一个案例研究了一些基于FSM的测试方法,并比较了由这些方法生成的测试序列总长度及错误覆盖能力,但该文仅讨论了若干基于FSM的测试方法的构造思想,而没有提供可实践的算法,且文中讨论的错误类型非常有限,与实际软件中的错误类型不符;Dalal等人[5]利用一个基于模型的测试工具测试了4个实际应用,并讨论了基于模型的测试生成时的注意事项,但支持工具接受的建模语言是定制的AETGSpec,而非通用的FSM模型;Broy等人[6]对若干基于FSM的测试方法的理论进行综述,而并未对这种测试方法进行实验评估;Neto等人[3,7]通过对五大电子图书馆的索引,分析和讨论了现有基于模型的测试研究工作.然而他们没有比较不同方法的优劣;Ammann和Offutt[8]则从测试覆盖准则的角度评估了基于FSM的测试方法,但并未给出测试覆盖准则的实现算法,导致实际应用的困难.本文重点讨论基于FSM的测试方法的理论、实现算法及冗余约简原理.以6个FSM模型及其应用为实验对象,评估若干基于FSM的测试方法,并提出了5个量化评价指标.依据实验的结果,本文对基于FSM的测试提出了一些经验性的指导意见.本文的创新点在于:(1)补充了基于FSM的测试理论,完善了区分序列的构造理论,提出了新的冗余约简方法;(2)提出了评估基于FSM的测试方法的5项量化指标,并评估了若干基于FSM的测试方法;(3)给出了基于FSM的测试的一些经验性建议.本文第2节介绍基于FSM测试的一些基础知识;第3节综述若干基于FSM的测试方法;第4节讨论测试序列集的冗余问题,并提出了冗余约简算法;第5节提出5项量化指标,评估基于FSM的测试方法;第6节对实验结果进行讨论,并为基于FSM的测试方法给出一些经验性的意见;第7节分析国内外同类研究;第8节总结全文,并指出今后的研究方向.2预备知识有限自动机包括Moore机和Mealy机,其中Mealy机是由状态集合、输入符号集合、状态迁移函数、输出符号集合和输出函数构成,与通信协议的描述相一致.因此,Mealy机最早被用于对通信协议的建模和测试[9].Mealy机的定义[2,4,6,9]如下.定义1(Mealy机).一个Mealy机是一个五元组M=〈I,O,S,δ,λ〉,其中I是一个有限非空输入符号集合,O是一个有限非空输出符号集合,S是一个有限非空的状态集合,δ:S×I→S为状态迁移函数,λ:S×I→O为输出函数.在Mealy机中输入一条序列x=a1a2…ak,由状态迁移函数δ(si,ai)=si+1(i=1,2,…,k)可获得一组连续的状态s1s2…sk,本文采用函数δ(s1,x)表示该组连续序列.同理,可以由输出函数λ(s1,x)产生一条输出序列b1…bk,其中λ(si,ai)=bk(i=1,2,…,k).在本文中,x·y表示两个序列或输入符号的连接,λ(s1,x)=-表示输出为空.本文随后规定MS表示软件需求的Mealy机,MI表示软件实际应用的Mealy机.基于FSM的测试过程:依据测试方法(准则)由MS中产生测试序列,再应用到MI中,观察MI是否严格符合它的规格说明MS,即通过比较实际的测试序列和输出结果是否与预期一致,探测MS和MI之间所有的不一致性错误.因此通常称这种测试为一致性测试[1,2,6].现有基于FSM的测试研究是建立在一些前提和假设[6,10]的基础上.假设1.MS是被约简的或最小化的.对于任意两个状态s和t,存在一个输入序列x,使得x能依据输出函数λ(s,x)和λ(t,x)的不同,区分s和t.形式描述为s,t:S,x:I·(λ(s,x)≠λ(t,x)).假设2.MS是具体的.S中的每一个状态和I中的每一个输入符号都能应用状态迁移函数δ和输出函数λ.形式描述为si:S,x:I·(sj∈S,y∈O·(δ(si,x)=sj)∧(λ(si,x)=y))).假设3.MS是强连通的.MS中的每一个状态都可经过一条或多条连续的迁移由其它状态到达.Page3形式描述为si,sj:S·(p:I·(δ(si,p)=sj)).某些基于FSM的测试方法并不严格遵守假设3,而仅要求MS中的每一个状态都能由初态到达(本文称为假设3).假设4.在测试过程中,MI并不会改变,且MI与MS拥有相同的输入和输出符号集合.形式描述为IMS=IMI∧OMS=OMI.假设5.初始状态.MS和MI都有一个初始状态s1,且测试之前MI已经处在它的初始状态.假设5并非严格要求,如n端口自动机则拥有多个初始状态.假设6.状态数目相同:MS和MI有相同数目的状态,MS和MI之间的不一致性错误并不会造成MI中状态的增加.依据假设6,MI中包含两类错误:(1)输出错误,即MI的输出与预期输出λ(s,x)不符;(2)迁移错误,即MI的状态迁移与预期状态迁移δ(s,x)不符.然而,实际软件应用MI中状态数目可能增加或减少,造成迁移的增加或减少,本文将状态的变更带来的错误称为额外迁移错误.迁移错误与额外迁移错误不同,迁移错误是指,在MS的状态s上存在输入a,但实际MI的输出状态与预期状态不符;额外迁移错误是指,在MS的状态s上不存在输入a,但实际MI的状态s上存在输入a使得δ(s,a)不空.假设7.重置消息.MS和MI都有一个重置消息reset(简称r),使得状态机在任何状态时都能回到初始状态s1且不会产生任何输出.假设8.状态位消息.MS和MI都有一个特定的状态位(status),使得在任意时刻,它们所处的状态都能被状态位标识,例如状态si表明了状态所处的状态位是i.假设9.设置消息.输入符号集合I包含一个特殊的集合set(s),当系统处于初始状态时,自动机能够获得一个set(s)消息后,能够移动到状态s,同时不产生任何输出.在基于FSM的测试中,上述的假设不一定都需要满足,大多数的基于FSM的测试生成方法仅需满足其中的几条假设.3基于FSM的测试方法3.1图形的遍历方法由FSM产生测试用例的思想来源于有向图的遍历[11].基于图形覆盖的程度,研究人员提出两类基本覆盖:状态覆盖和迁移覆盖[8],并给出了由状态覆盖和迁移覆盖生成测试用例的方法.在FSM中,一条迁移[12-13]被定义为t=(si,a/b,sj),其中f(si,a)=sj,a∈I,b∈O,si为迁移t的前状态,sj为迁移t的后状态.定义2(状态覆盖).测试用例集合T至少覆盖了MS中的所有状态一次.定义3(迁移覆盖).测试用例集合T至少覆盖了MS中的所有迁移一次.依据有向图的遍历方法,由初态开始遍历FSM,生成一棵广度优先生成树,再获得由树根结点到叶子结点的迁移序列作为测试用例.文献[14]中给出了广度优先遍历FSM的算法,但该算法并未考虑到迁移之间可能存在的约束关系[13,15].例如BBS论坛中存在两类访客,一类是未注册的游客,另一类为注册用户.注册用户可以发表帖子和浏览其他用户的帖子,而游客只能浏览已发表的帖子,因此注册用户与发表帖子之间存在约束关系.定义4(迁移约束集).在FSM中,设RS={(ti,tj)|ti→tj}为迁移约束集,其中ti和tj为FSM中的两条迁移且tj的存在取决于ti的存在.假设图1(a)中MS的迁移约束集为RS={(t3,t4)}.若直接采用广度优先遍历算法,可获得一棵测试生成树,如图1(b)所示.由测试生成树产生测试用例集合T={t1,t2t3,t2t4t5,t2t4t6}.但T并不满足迁移约束集RS,为此本文提出了基于迁移约束的广度优先遍历算法TBFS.算法TBFS的思想:采用广度优先遍历FSM,若存在迁移t∈ranRS,则回溯访问树中所有父亲结点,查看是否满足t:domRS∧t→t;若满足,则采用迁移t构造生成树,否则跳过迁移t继续构造生成树.例如在图1(b)中,当遍历到迁移t4时,由于t4∈ranRS,则回溯遍历父亲结点,找到迁移t2,但由于t2domRS,则放弃t4作为t3的前状态s2的后继.依据广度优先遍历,获取t3的后状态s2,选取t4作为后续迁移,回溯遍历父亲结点,找到迁移t3.由于t3∈domRS∧t3→t4,则将t4作为状态s2的后继.依据这种构造思想,最终获得的生成树如图1(c)所示.若FSM中不存在迁移约束集时,算法TBFS转变为普通的广度优先遍历算法.在最坏情况下,算法TBFS的时间复杂度为O(n3),其中n为|S|.由图1(c)中的树可得,序列t2t3t4满足状态覆盖,序列t1,t2t3t4t5和t2t3t4t6满足迁移覆盖.图1(a)中MI是MS的一个错误应用,其中t=(s3,a/0,s2)是一个错误迁移.由序列t2t3t4得到的输入序列bab和状态序列s1s2s3.在MI中输入bab,获得实际运行的状态序列为s1s2s3,因此满足状Page4图1态覆盖的序列t2t3t4并不能发现迁移错误t.而序列t2t3t4t5包含的输入序列baba和状态序列为s1s2s3s3,在MI中输入baba,获得的实际状态序列为s1s2s3s2与预期序列s1s2s3s3不一致,因此满足迁移覆盖的序列能够发现MI中的迁移错误t.算法TBFS.带迁移约束的广度优先遍历生成树.输入:存储FSM的邻接矩阵犪狉狉犪狔[n][n]及它的迁移输出:广度优先遍历生成树Tree1.初始化列表list1=s1,list2=null及其游标位置pre=0,post=1;2.标记s1为树Tree的根结点;3.While(pre!=post)4.s=list1.get(pre);//取list1中pre位置的值;5.While(存在前状态为s的迁移t)6.从数组犪狉狉犪狔[n][n]中取下一个迁移t=7.If(t在list2中)8.If(t∈ranRS)//存在迁移约束9.访问从结点si到根结点的所有分枝;如果10.Endif11.Else12.标记t为一个分枝,si作为s的后继结点;将13.Endif14.Endwhile15.pre++;16.Endwhile17.ReturnTree3.2W方法图形遍历的方法是通过观察系统中的状态是否到达来判断系统是否存在不一致性错误.若应用系统的状态不可观察,则需要利用输出序列来判断系统中的错误.这类测试生成方法包括W方法、Wp方法、U方法和DS方法等.它们需要解决两个问题:(1)如何生成覆盖FSM的输入序列;(2)如何辨别最终到达的状态为目标状态.W方法最早是由Chow[9]提出的,并被应用于电信系统的测试.该方法需要遵循3条性质:(1)仅仅检测系统设计中的控制结构;(2)规格说明不必是可执行的;(3)测试序列一定能揭示控制结构中的错误,并能解释错误的来源.W方法并不需要使用状态位信息,而是采用分离序列(separatingsequence)[6,16]来区分自动机中的每个状态.定义5(分离序列).对于S中的任意两个状态s和t,它们的分离序列是x∈I,以便使得λ(s,x)≠λ(t,x).形式描述为s,t:S,x:I·(λ(s,x)≠λ(t,x)).由假设1可知,规格说明MS是最小的,则MS中不存在两个等效的状态,即任意两个状态都存在分离序列.W方法构造了一个输入序列覆盖集P来实现对FSM的所有迁移覆盖,同时构造了一个由分离序列组成的特征集W,以区分最终到达的状态.定义6(输入序列覆盖集).MS的输入序列覆盖集P是由输入序列构成,以便对于S中的任意状态s和I中的每一个输入a,都存在一个输入序列x∈P,x从MS的初始状态s1开始,到λ(s,a)产生的输出结束.形式描述为s:S,a:I·(x,y:P·(x=y·a∧δ(s1,y)=s).由定义6可知,输入序列覆盖集P是由空输入ε和所有从初始状态开始到任意状态结束的输入序列构成,输入序列覆盖集P可由生成树获得.定义7(特征集).MS的特征集W是由分离序列构成的集合,以便对S中的任意状态s和t,W中都存在一个输入序列x使得λ(s,x)≠λ(t,x).形式描述为s,t:S·(x:W·(λ(s,x)≠λ(t,x)).由于特征集能够区分S中任意两个状态,因此利用特征集构造测试序列可以不需要知道MS的状态信息.W方法通过广度优先遍历FSM的方式,构Page5造一棵测试生成树,获取由树的根结点到任意结点的输入序列构成了P集;同时,对状态集合S中的每一对状态s和t,寻找这两个状态的分离序列,并用这些分离序列构成W集.W方法的输入序列为r·P·W,预期的输出序列为λ(s1,r·P·W).现有构造P集和W集的方法[6,9]中存在两个问题:(1)对P集的构造并没有考虑FSM中的迁移约束;(2)对W集而言,仅给出构造思想,并未提供分离序列的构造算法.为克服第1个缺点,本文建议采用算法TBFS来生成测试树,再构造P集.为克服第2个问题,本文提出了分离序列构造的新方法.以图1(a)中的MS为例,本节演示了分离序列的构造方法.首先为MS建造一个输入/输出与状态之间的关系表,如表1所示.在表1中,符号×表示某个状态应用了某个输入/输出.由表1可知,状态s1应用a/0和b/1,状态s2应用a/1和b/1,状态s3应用a/0和b/0.I/Oa/0a/1b/0b/1s1s2s3定义8(可识别函数).MS的关系表被定义为一个可识别函数φ:S→I/O,其中S是MS的状态集,I/O表示输入/输出集合,且满足s:S,x/y:I/O·(p:S·δ(s,x)=p∧λ(s,x)=y).依据定义8,图1(a)中MS的可识别函数为φ(s1)={a/0,b/1},φ(s2)={a/1,b/1},φ(s3)={a/0,b/0}.借助一组特定的运算,本文构造了一个三角矩阵.定义9(三角矩阵).在MS中,可识别函数的三角矩阵是由Dij(i<j)构成,其中Dij=依据定义9,D12=φ(s1)-φ(s2)={a/0},D13=φ(s1)-φ(s3)={b/1},D23=φ(s2)-φ(s3)={a/1,b/1}.则图1(a)中MS的三角矩阵如图2所示.取D12中的元素a/0,则输入a是状态s1和s2的分离序列,取D13中的元素b/1,则输入b是状态s1和s3的分离序列,取D23中的元素a/1或b/1,则输入a或b是状态s2和s3的分离序列.因此最终获得的特征集W={a,b}.为保证该方法的正确性,本文随后给出了4条定理及证明,其中证明部分的推理规则可参见文献[17].φ(s1)·λ(s1,x)=λ(s2,x)).引理1.├s1,s2:S·(φ(s1)=φ(s2)x/y:可由定义8证明引理1,证明过程略.引理2.├s1,s2:S·(φ(s1)=φ(s2)x/yφ(s1)·λ(s1,x)=λ(s2,x)).证明.如果x/yφ(s1),则由定义8可知,λ(s1,x)=-或者存在a∈O使得λ(s1,x)=a.因为φ(s1)=φ(s2),则λ(s2,x)=-或者存在a∈O使得λ(s2,x)=a.若λ(s1,x)≠λ(s2,x),则有x/a∈φ(s2)∧x/aφ(s1)或者x/a∈φ(s1)∧x/aφ(s2).则由集合的定义可知φ(s1)≠φ(s2),与已知φ(s1)=φ(s2)矛盾,因此,必有λ(s1,x)=λ(s2,x).证毕.引理3.├t1,t2:S,x:I·(λ(t1,x)=λ(t2,x))t1,t2:S·(x:I·λ(t1,x)=λ(t2,x)).可由克林闭包的定义证明引理3,证明过程略.定理1.对最小Mealy机MS而言,状态集合S中至少存在两个不同的状态s和t,使得MS的可识别函数φ(s1)不等于φ(s2).形式表示为s1,s2:S·(x:I·(λ(s1,x)≠λ(s2,x)))├t1,t2:S·(φ(t1)≠φ(t2)).证明(反证法).1.t1,t2:S·(φ(t1)≠φ(t2))假设2.t1,t2:S·(φ(t1)=φ(t2))1,-int3.φ(t1)=φ(t2)4.x/y:φ(t1)·λ(t1,x)=λ(t2,x)3,引理15.λ(t1,x)=λ(t2,x)6.x/yφ(t1)·λ(t1,x)=λ(t2,x)3,引理27.λ(t1,x)=λ(t2,x)8.x/y:I/O·(x/y∈φ(t1)∨x/yφ(t1))9.x/y:I/O·λ(t1,x)=λ(t2,x)4~8,-int10.x:I·λ(t1,x)=λ(t2,x)9与y无关11.t1,t2:S,x:I·λ(t1,x)=λ(t2,x)12.t1,t2:S·(x:I·λ(t1,x)=λ(t2,x))13.s1,s2:S·(x:I·λ(s1,x)≠λ(s2,x))Page614.t1,t2:S·(φ(t1)≠φ(t2))12和13矛盾定理1保证了三角矩阵不全为空.定理2.对于S中的任意两个状态s1和s2,如果φ(s1)不等于φ(s2),那么差集D12=φ(s1)-φ(s2)或D12=φ(s2)-φ(s1)能够识别状态s1和s2.形式表示为证明.1.φ(s1)≠φ(s2)假设2.D12≠3.D12=φ(s1)-φ(s2)∨D12=φ(s2)-φ(s1)4.D12=φ(s1)-φ(s2)3,假设5.x/y:D12·(x/y∈φ(s1)∧x/yφ(s2))6.x/y∈φ(s1)∧x/yφ(s2)-elim7.x/y∈φ(s1)·(λ(s1,x)=y)定义88.λ(s1,x)=y9.x/yφ(s2)·(λ(s2,x)≠y)定义810.λ(s2,x)≠y11.λ(s1,x)≠λ(s2,x)8,10,替换12.x/y:D12·λ(s1,x)≠λ(s2,x)13.D12=φ(s2)-φ(s1)3,假设14.x/y:D12·(λ(s1,x)≠λ(s2,x))15.φ(s1)≠φ(s2)x/y:D12·λ(s1,x)≠λ(s2,x)16.s1,s2:S·(φ(s1)≠φ(s2)由定理2可知,在三角矩阵内,若Dij≠,则对于任意x/y∈Dij,输入x一定能识别状态si和sj.引理4.├s1,s2:S,x,x1:I·(δ(s1,x)=s2λ(s1,x·x1)=λ(s1,x)·λ(s2,x1)).可由定义1和序列的连接操作证明引理4,证明过程略.引理5.├a,b,c,d:O·(a=b∧c≠da·c≠b·d),或者├a,b,c,d:O·(a≠b∧c=da·c≠b·d),或者├a,b,c,d:O·(a≠b∧#c=#da·c≠b·d).可由序列的连接操作证明引理5,证明过程略.定理3.对识别函数φ而言,如果φ(s1)等于φ(s2),且I中存在x和y,使得δ(s1,x)=si,δ(s2,y)=sj及Dij≠,那么对于Dij中任意x1/y1,输入序列x·x1都能识别状态s1和s2.形式表示为s1,s2:S·(φ(s1)=φ(s2))├x,y:I,si,sj:S·(δ(s1,x)=si∧δ(s2,y)=sj∧Dij≠)x1/y1:Dij·(λ(s1,x·x1)≠λ(s2,x·x1)).证明.1.s1,s2:S·(φ(s1)=φ(s2))前提2.φ(s1)=φ(s2)3.x/y∈φ(s1)·(λ(s1,x)=λ(s2,x))2,引理14.λ(s1,x)=λ(s2,x)5.x,y:I,si,sj:S·(δ(s1,x)=si∧δ(s2,y)=sj∧Dij≠)6.δ(s1,x)=si∧δ(s2,y)=sj∧Dij≠7.Dij≠8.Dij=φ(si)-φ(sj)∨Dij=φ(sj)-φ(si)9.φ(si)≠φ(sj)10.x1/y1:Dij·λ(si,x1)≠λ(sj,x1)9,定理211.λ(si,x1)≠λ(sj,x1)12.δ(s1,x)=si13.δ(s2,y)=sj14.λ(s1,x·x1)=λ(s1,x)·λ(si,x1)12,引理415.λ(s2,x·x1)=λ(s2,x)·λ(sj,x1)13,引理416.λ(s1,x)·λ(si,x1)≠λ(s2,x)·λ(sj,x1)17.λ(s1,x·x1)≠λ(s2,x)·λ(sj,x1)14,16,替换18.λ(s1,x·x1)≠λ(s2,x·x1)15,17,替换19.x1/y1:Dij·(λ(s1,x·x1)≠λ(s2,x·x1))20.x,y:I,si,sj:S·(δ(s1,x)=si∧δ(s2,y)=由定理3可知,若D12=,则能利用s1和s2的相邻状态si和sj的Dij(Dij≠)来获得s1和s2的分离序列.若Dij=,由定理1可知,可识别函数的三角矩阵中一定存在一个Dpq≠,又由于最小Mealy机一定存在特征集[6],因此可由Dpq来获得s1和s2的分离序列.引理6.├s:S,y,a:I,b:O·(λ(s,y·a)=λ(s,y)·b∧#b=#(y·a)-#y).可由定义1和序列的连接操作证明引理6,证明过程略.定理4.对Ms的特征集W而言,若存在分离序列x和y满足x=y·a,其中a是一个输入序列,Page7那么集合W=W-{y}同样是MS的一个特征集.形式表示为├s1,s2:S,x,y:W,a:I·(λ(s1,y)≠λ(s2,y)∧x=y·a)λ(s1,x)≠λ(s2,x).证明.1.s1,s2:S,x,y:W,a:I·(λ(s1,y)≠λ(s2,y)∧x=y·a)2.x,y:W,a:I·(λ(s1,y)≠λ(s2,y)∧x=y·a)3.λ(s1,y)≠λ(s2,y)∧x=y·a2,-elim4.λ(s1,y)≠λ(s2,y)5.x=y·a6.λ(s1,x)=λ(s1,x)7.λ(s1,x)=λ(s1,y·a)5,6,替换8.λ(s2,x)=λ(s2,x)9.λ(s2,x)=λ(s2,y·a)5,8,替换10.s1:S,y,a∈I,b1:O·(λ(s1,y·a)=11.λ(s1,y·a)=λ(s1,y)·b1∧#b1=#(y·a)-12.λ(s1,y·a)=λ(s1,y)·b111,∧-elim13.#b1=#(y·a)-#y11,∧-elim14.s2:S,y,a∈I,b2:O·(λ(s2,y·a)=15.λ(s2,y·a)=λ(s2,y)·b2∧#b2=#y·a-16.λ(s2,y·a)=λ(s2,y)·b215,∧-elim17.#b2=#(y·a)-#y15,∧-elim18.#b1=#b219.λ(s1,y)·b1≠λ(s2,y)·b24,18,引理520.λ(s1,y·a)≠λ(s2,y)·b212,19,替换21.λ(s1,y·a)≠λ(s2,y·a)16,20,替换22.λ(s1,x)≠λ(s2,x)23.s1,s2:S,x,y:W,a:I·(λ(s1,y)≠依据定理4,可以对特征集W进行冗余约简.基于定理1~4,本文设计了特征集W的构造算法WSA.算法WSA的时间复杂度为O(n2).表2W方法的测试序列Pεr·P·Wrarbraarabrbarbbrbaarbabrbbarbbbrbbaarbbabrbbbarbbbb输出01001111111111111101101100110011001101算法WSA.特征集W的构造.输入:Mealy机Ms输出:Ms的特征集W1.初始化W=;2.构造Ms的一个可识别函数φ;3.For(i=1;i<n;i++)//构造Dij.4.For(j=i+1;j<=n;j++)5.Ifφ(si)φ(sj)≠thenDij=φ(si)-φ(sj);6.ElseDij=φ(sj)-φ(si);7.Endfor8.Endfor9.对于每个Dij,如果Dij=,则依据定理3,从x/y10.对于W中任意两条序列x和y,如果存在x=y·11.ReturnW.以图1(a)中的MS为例,依据算法TBFS产生一棵测试生成树.为简化测试生成,本节并不考虑MS中的迁移约束.图3(a)是MS的一个错误应用,存在一个输出错误b/1.由算法TBFS获得的测试生成树如图3(b)所示,由这棵树得到输入序列覆盖集P={ε,a,b,ba,bb,bba,bbb},其中ε表示空输入.依据算法WSA得到特征集W={a,b}.依据W方法,使用输入序列r·P·W和输出序列λ(s1,r·P·W)建造表2,其中的r表示重置消息(假设7).对于图1(a)中MI的迁移错误t=(s3,a/0,s2),测试序列rbbaa的实际输出为1101,而预期输出为1100,因此迁移错误t能被发现.对于图2(a)中MI的输出错误b/1,测试序列rbbb,rbbba,rbbbb的实际输出为111,1110,1111,而预期输出为110,1100,1101,因此这3条测试序列都能够发现输出错误b/1.在实验[4]中,W方法既表现出很强的错误探测能力,又包含不可容忍的测试序列总长度,导致测试成本的急剧增加.如表2所示,W方法的测试序列总长度为52.测试序列baPage83.3Wp方法Wp方法[2]也称部分W方法,其主要优点是约简了W方法产生测试用例的总长度.该方法将测试分为两个阶段:第1个阶段测试MS中的每一个状态是否在MI中;第2个阶段检测所有未在第1个阶段中被检测的迁移.为实现第1个阶段,Wp方法使用一个状态覆盖集来替代输入序列覆盖集P.相比输入序列覆盖集P,状态覆盖集更小.定义10(状态覆盖集).状态覆盖集Q是由输入序列组成,且对于任意的s∈S,都存在一个输入序列x∈Q,使得自动机迁移到s,即δ(s1,x)=s.形式描述为s:S·(x:Q·δ(s1,x)=s).Wp方法的第1阶段的输入序列为r·Q·W,输出序列为λ(s1,r·P·W).在第2个阶段,Wp方法使用一个识别集Wi(identificationset)[6]来区分si与其它状态,而不是W方法中的特征集W.定义11(识别集).状态si的一个识别集Wi是由输入序列构成,对于sj:S,i≠j,集合Wi中都存在一个输入序列x,使得λ(si,x)≠λ(sj,x),且Wi的任意一个真子集均不满足这个特性.由定义11可知,每个状态的识别集都是特征集W的子集,且识别集的任意子集都不是该状态的识别集.求解特征集中的最小识别集是一个NP难问题.本文采用启发式方法,每次都从特征集W中选取一条输入序列x,使得x能够识别最多状态,且这些状态未被已选出序列识别.依据这种思想,本文设计了识别集的生成算法WPSA.假定|W|=p,|S|=n,则算法WPSA的时间复杂度为O(pn2).在第2阶段,为获取第1个阶段中未被检测的迁移,需要构造集合R=P-Q,其中P是迁移覆盖集,Q是状态覆盖集.则第2个阶段的输入序列为r·R·Wi,输出序列为λ(s1,r·R·Wi).第2阶段的目的是为了测试第1阶段未被测试的迁移,以保证Wp方法的错误探测能力.对于Wp方法与W方法的测试等效性,可以参阅文献[2]中的证明.算法WPSA.识别集的构造算法.输入:特征集W和FSM的状态集合S,|S|=n输出:识别集W1,W2,…,Wn1.初始化W1=W2=…=Wn=;2.foreachsi∈S3.tmp_S=S-{si};4.tmp_W=W;5.While(tmp_S≠)6.从tmp_W中选出一个x,使得x能将si与7.Endwhile8.Endfor9.ReturnW1,W2,…,Wn.随后本文以图1(a)中的MS为例,演示Wp方法,并分析Wp方法的错误探测能力和测试序列的总长度.依据算法TBFS,构造一棵测试生成树,如图3(b),则这颗树的状态覆盖集Q={ε,b,bb}.由于图1(a)中FSM的特征集W={a,b},则第1个阶段产生的测试序列显示在表3中.Qεr·Q·Wrarbrbarbbrbbarbbb输出011111110110依据算法WPSA,由于a能区分状态s2与其它状态,b能区分状态s3与其它状态,则W2={a}及W3={b}.而s1不能被a或b单独识别,则W1=W2∪W3={a,b},即s1能被a和b区分其它状态.R=P-Q={ε,a,b,ba,bb,bba,bbb}-{ε,b,bb}={a,ba,bba,bbb}.第2阶段产生的测试序列显示在表4中.Rababbabbbr·R·Wiraarabrbaarbbabrbbbarbbbb输出0001111110011001101由表3和表4可知,测试序列的总长度是43.图1(a)中MI的迁移错误t=(s3,a/0,s2)能被测试序列rbbab发现,而图3(a)中MI的输出错误b/1能被测试序列rbbb,rbbba,rbbbb发现.3.4UIO方法在Wp方法中,如果识别集Wi仅为一条测试序列,那么它被称为状态签名(statesignature)[18]或UIO(UniqueInput/Output)序列[19],且能唯一识别状态si.UIO方法首先采用P集测试每一条从状态si到状态sj的迁移,再采用sj的UIO序列检测终态是否是sj.因此该方法同样不需要状态位信息.定义12(UIO序列).在Mealy机中,状态s的UIO序列是一条输入序列x,满足任意其它状态t∈S,都有λ(s,x)≠λ(t,x).UIO方法采用状态s的UIO序列替代W方法中的特征集W,即测试输入为r·P·UIOi,测试输出为λ(s1,r·P·UIOi).由于UIOi仅包含一条序列,因此该UIO方法的测试序列总长度总是比WPage9方法的要短.但UIO方法并不能保证揭示应用中的任何错误[20].例如,若一个错误应用的状态s与状态s有相同的UIO序列,因为没有状态位的信息,因此测试的输出将无法辨别状态s与状态s.为此Vuong等人[20]提出了UIOv方法,该方法建造测试组包括3个阶段:(1)Uv过程.获得每个状态s的UIO序列,即对MS中的每个状态s都有一个条区分序列x,使得x能将状态s与其它状态区分出来.设状态覆盖集为Q,则Uv过程的输入序列为r·Q·UIOi,输出序列为λ(s1,r·Q·UIOi).(2)Uv过程.获得每个状态s的UIO序列,即从UIO集合中除去能够区分s与其它状态的序列.如UIO={ab,a,b},其中ab和a能将状态s与其它状态区分出来,则UIO-{ab,a}={b},那么s的UIO序列为b.Uv过程的输入序列为r·Q·UIOi,输出序列为λ(s1,r·Q·UIOi).(3)迁移测试阶段:获得Uv过程和Uv过程中没有访问到的迁移,即执行R=P-Q.再对集合R中序列到达的最后一个状态应用相应的UIOi,最终的输入序列为r·R·UIOi,输出序列为λ(s1,r·R·UIOi).UIO方法可以被认为是一类特殊的Wp方法,其中特征集W是所有UIO序列的并,Wp方法的第1阶段为UIOv方法的Uv过程和Uv过程,Wp方法的第2阶段为UIOv方法的迁移测试阶段.UIOv方法需要构造Q集、P集、UIO集和R集,其中Q集、P集和R集的构造算法已在前几节中被描述,因此本节主要描述UIO集的构造算法.直接构造所有状态的UIO集合是一个NP难问题[11,21].文献[22]给出了一个构造所有UIO序列的算法,但该算法运用的推理规则会造成UIO序列长度的增加[11],最终导致测试成本的增加.本文提出了一种启发式方法求解某个状态的一条UIO序列.该方法的求解步骤:(1)若状态s的识别集Wi={a,b},则获取状态s1=δ(s,a)和s2=δ(s,b);(2)分别以状态s1和s2为根结点,遍历规格说明MS生成两棵广度优先生成树,且树中最后一个叶子结点的状态为s;(3)分别从根为s1和s2的两棵树中获取由根结点到最后一个叶子结点的序列x和y,若序列x的长度小于序列y,则状态s的UIO=a·x·b,否则状态s的UIO=b·y·a.依据这种方法本文给出了算法UIOS.由于|Wi|n-1,因此算法UIOS的最坏时间复杂度为O(n4).UIO方法必须满足MS是强连通的(假设3),否则步5中状态迁移函数δ(si,x)可能为空,则存在状态没有相应的UIO序列.过去对UIO方法的研究[6,11,20-22]均是以通信协议为研究对象,而通信协议中的任意两个端口之间均能相互通信,因此协议模型MS中的每个状态都存在相应的UIO序列.算法UIOS.构造UIO集.输入:规格说明Ms和识别集W1,W2,…,Wn;输出:集合UIO1,UIO2,…,UIOn;1.初始化UIO1=UIO2=…=UIOn=,Tmp=2.foreachWi//Wi是状态si的识别集;3.if(|Wi|=1),thenUIOi=Wi;4.else5.Foreachx∈Wi,6.s=δ(si,x)和Tmp=Tmp∪{s};7.Endfor8.Foreachs∈Tmp9.遍历Ms,构建一棵根为s及终止结点为si10.Endfor11.按递减次序对Sp中的所有序列排序,再删12.Foreachx∈Sp13.获得包含序列x初始结点s,从Wi中取序14.Endfor15.从Sp中获得最长的一条序列p,如果seq=16.Endif17.Endfor18.ReturnUIO1,UIO2,…,UIOn.随后本文以图1(a)中的MS为例,演示UIO方法及其改进的UIOv方法,并分析这两种方法的错误探测能力和测试用例的总长度.UIO方法:(1)用P集测试所有迁移;(2)用UIO序列验证P集测试迁移的终态是否正确.依据算法UIOS,得到UIO1=ab/01,UIO2=a/1,UIO3=b/0.具体的构造UIO方法的过程如表5.Pεabbabbbbabbbr·P·UIOirabraabrbarbaarbbbrbbabrbbbb输出010011111111011001101对于图1(a)中MI的迁移错误t=(s3,a/0,s2),UIO方法可以通过测序列rbbab检测而发现;对于Page10图3(a)中MI的输出错误b/1,可以通过序列rbbb和rbbbb发现.由表5可知,UIO方法的测试序列总长度为28.在UIOv方法中,由于集合UIO=UIO1∪UIO2∪UIO3={ab/01,a/1,b/0},则UIO1=UIO-UIO1={a/1,b/0},UIO2=UIO-UIO2={b/0,ab/01},UIO3=UIO-UIO3={a/1,ab/01}.R=P-Q={a,ba,bba,bbb},集合R与状态之间的关系可以查看表3.UIOv方法的构造过程如表6~8.r·Q·UIOirabrbarbbbr·Q·UIOirarbrbbrbabrbbarbbab输出011111001101100UIOiUIO1UIO2UIO1UIO3r·R·UIOiraabrbaarbbbabrbbab输出001111110011100同样UIOv方法中的测试序列rbbab能够发现图1(a)中MI的迁移错误,而输入序列rbbb能发现图3(a)中MI的输出错误.由表6~8可知,测试序列的总长度为49.但UIO方法和UIOv方法都必须满足模型MS是强连通的.3.5DS方法在某些情况下,一条UIO序列能够区分所有的状态,那么这条序列被称为区分序列(Distinguis-hingSequence,DS)[4,6].若特征集W仅仅包含一条输入序列时,则DS方法可以看成是W方法的一个特例,但并非是所有的Mealy机都存在区分序列[6,20].因此,若Mealy机存在区分序列x,则DS方法的输入序列为r·P·x,输出序列为λ(s1,r·P·x).为构造区分序列x,文献[21]提出构造分裂树(splittingtree)获取区分序列的方法,该方法的演示如图4所示.图4显示了图1(a)中MS的分裂树,这棵树的构造过程采用了集合的划分方式.当对集合{s1,s2,s3}输入a时,依据输出函数λ(s,x)的不同,将集合{s1,s2,s3}划分为{s1,s3}0和{s2}1,其中0和1表示集合内元素的输出.对{s1,s3}0和{s2}1输入a时,依据输出函数λ(s,x)的不同,得到{s1,s3}00和{s2}11,由于集合{s1,s3}未被划分,因此这条分枝不必继续输入a来划分{s1,s3}0和{s2}1;再对{s1,s3}0和{s2}1输入b,依据输出函数λ(s,x)的不同,集合{s1,s3}0被划分为{s1}01和{s3}00,{s2}1得到{s2}11.由于每个集合仅有一个元素,因此序列ab是一条区分序列.同理,采用这种方式构造继承树中的其它分枝.由于图4可知,输入序列ab,ba和bb均是图1(a)中MS的区分序列.构造Mealy机的分裂树是一个NP难问题[6,21],且Mealy机并不一定存在一条区分序列,为此需要判断Mealy是否存在区分序列.文献[21]给出了一个检测区分序列是否存在的算法,在本文中命名为算法CDS.与原算法中的自然语言描述不同,算法CDS采用了形式语言描述.算法CDS.检测Mealy是否存在区分序列.输入:规格说明MS和状态集S输出:布尔值,true表示存在区分序列,false表示不存1.初始化π={{S}};2.while(B∈π∧a∈I,s,t∈B·((λ(s,x)≠λ(t,x)∨3.π=π;4.π=π-B;//从π中删除B.5.π=π∪Partition(B,π);6.Endwhile7.如果B∈π·#B>1,则返回false;否则返回true.算法CDS中的Partition(B,π)表示对B中状态的划分,对不同的状态输入相同序列a∈I,将具有相同输出的状态移动到π中不同的集合内.对于算法CDS的正确性,文献[21]中给出了详细的证明.算法CDS不能在多项式时间内实现.文献[6,21]给出了构造一棵完全分裂树(splittingtree)算法SPT.对于该算法的详细描述可以查阅文献[6,21],限于篇幅原因,本文不再赘述.当且仅当Mealy机存在一个区分序列时,算法SPT才成立.同样算法SPT也不能在多项式时间内完成.依据算法SPT,将图1(a)中MS转换成一棵分裂树,如图4所示.取区分序列ba,则MS的输出函数λ(s1,ba)=11,λ(s2,ba)=10,λ(s3,ba)=01.DS方法的构造过程如表9所示.Page11Pεabbabbbbabbbr·P·xrbarabarbbarbabarbbbarbbabarbbbba输出11011110111011001100011011由表9可知,DS方法的测试序列总长度为33.图1(a)中的迁移错误t=(s3,a/0,s2)可以通过测试序列rbbaba发现,而图2(a)的输出错误b/1能通过测试序列rbbba发现.DS方法的缺点是并非所有的Mealy机都存在区分序列,另外测试序列的总长度与选取的区分序列有关.3.6T方法软件测试中可能存在一类额外迁移错误,即描述需求的规格说明中并没有这些迁移,而实际应用中却存在这些额外的迁移.在某些情况下,这些额外的迁移会导致系统的崩溃.例如1999年12月3日,美国航天局火星极地登陆者号探测器飞船在试图登陆火星表面时失踪.错误修正委员会观测到故障,认定出现失误动作的原因极有可能是某一个数据被意外更改.这表明该系统中至少存在一条额外迁移,在正常情况下,这条额外迁移并不会被执行,但在特定情况下,这条额外迁移的执行会导致系统运行出错.然而本文前几节中讨论的基于FSM的测试方法均不能探测到这类错误,因为上述方法都是由规格说明MS导出测试用例,而额外迁移仅仅出现在实际应用MI中,因此由规格说明产生的测试序列并不能激活实际应用中的额外迁移.虽然额外迁移的错误已经超出了基于FSM的测试能力,但仍然存在少表10改进T方法的计算机模拟过程长度覆盖所有迁移t7=(s3,c/0,s2)t8=(s3,d/0,s4)实验随机次数MI的测试输入17rbabcbd7227rbabcbcbbbbcbabbbad11101010110100110019374rbbcabcbcabbbaabaab2844rbbd4515rabbaacabd1067rbbbbbd7754rbbbbabcabcbaabbbca84rbabd914rbbaaaabbbaad1100000110001028rabbbbbacbbabbd01101100100110(1)在实验中,改进T方法产生测试输入的内容和长度是随机的,这说明改进T方法是不稳定的.(2)仅在实验7中,改进T方法产生的测试输入覆盖了MS中的所有迁移,因此改进T方法并不量基于FSM的测试方法能够探测这类错误.图5为图1(a)中MS的一个错误应用.该错误应用包含了两个额外的迁移t7=(s3,c/0,s2)和t8=(s3,d/0,s4).为发现这两条错误迁移,必须寻找一种能够激活额外迁移的方法.T方法[4]又称为随机测试生成方法,该方法随机产生测试输入,直到MS中的所有迁移都被至少覆盖一次.传统T方法直接由规格说明随机产出覆盖MS的测试序列,因此同样也不能发现额外迁移错误.本文改进了T方法,将随机产生的测试输入直接应用到Mealy机MI中,直到由MI产生的迁移覆盖MS中的所有迁移一次.由于是随机产生测试输入,因此可能在一定的概率下探测到MI中的额外迁移.为验证这个观点,我们以图1(a)中的MS为例,利用计算机模拟了随机测试序列的生成.为避免死循环,在计算机模拟时,若某个状态输入任何符号时都不会发生后续迁移,即MI并非强连通的,则无论MS中所有迁移是否被覆盖,程序都结束.实验中,假定的测试输入集I={a,b,c,d},实验随机产生了十条测试输入和相应的测试输出,如表10所示.一些重要的结论可以从表10中得出.51315一定能保证探测到MI中的迁移错误和输出错误.(3)在实验1,2,3和10中,改进T方法能够同时探测到额外迁移t7和t8;在实验1,2,3,5,6,7和10中,改进T方法能够探测到额外迁移t7;在实验Page121,2,3,4,5,8,9和10中,改进T方法能够探测到额外迁移t8.实验表明改进T方法对额外迁移具有一定的探测能力.(4)对图5中的MI而言,在10次实验中,改进T方法随机产生测试输入的平均长度为23.4,实际有效的测试输入平均长度为14.2.实验中改进T方法产生的测试序列长度并不太长.3.7扩展Wp方法分集的概念.文献[2]提出了Wp方法的扩展应用,引入了区定义13(区分集).Mealy机的区分集被定义表11扩展Wp方法的第1阶段产生的测试序列r.Q.I.Wra,rb,raa,rba,rca,rda,表12扩展Wp方法的第2阶段的测试序列R测试状态r.R.I.Wiraaa,raba,raca,rada,输出000,011,0-,0-,在表11、表12中,符号“-”表示输出为空.由表11、表12可知,测试序列的总长度数为214.图1(a)中MI的迁移错误t=(s3,a/0,s2)能够由测试序列rbbab发现,而图2(a)中MI的输出错误b/1能由测试序列rbbba发现,图5中MI的错误额外迁移错误t7和t8分别由rbbca和rbbda发现.当m-n越大时,扩展Wp方法产生的测试序列越长.为减少扩展Wp方法产生的测试序列长度,文献[23]提出了R-Wp方法,该方法通过排除Wp方法中错误的状态迁移而减少测试输入序列的数目.R-Wp方法包含3个步骤:1.估计实现中的有限状态机中状态数目的上界m,其中m要大于或等于规约说明中的有限状态机中的状态数目n.2.检验在规约说明中的状态在实现中可被识别并验证其正确性,同时从初始状态到这些状态所经历的状态迁移也被验证,该部分的测试输入序列可如下构造:T1=Q·X[m-n]·W,其中I表示测试输入集合,X[m-n]表示{ε}∪I∪I2∪…∪Im-n.3.验证在上面没有被验证的状态迁移,测试输入序列可构造如下:其中Q是S的状态覆盖集,P是S的迁移覆盖集,W是有限状态机的特征集.为Z=({ε}∪I∪I2∪…Im-n).W=X[m-n]·W,其中I为Mealy机的输入符号集,n为MS中的状态数目,m表示实际应用MI的状态数目且m>n,X[m-n]表示{ε}∪I∪I2∪…∪Im-n,W为特征集.实际应用中,MI的状态数目可能比MS中的状态数目多,因此文献[2]提出利用区分集Z代替特征集W.为发现图5中MI的额外状态,本文假定m-n=1,即Z=I.W,其中I={a,b,c,d},特征集W={a,b},识别集W1={a,b},W2={a},W3={b}.同样扩展Wp方法也包含了两个阶段.扩展Wp方法得到的测试输入及测试输出如表11、表12所示.测试序列b111,110,1-,1-,111,111,1-,1-测试序列bbas3rbbab,rbbbb,rbbcb,rbbdb1100,1101,11-,11-由R-Wp方法的实现步骤可知,该方法的实现需要利用状态覆盖集Q、迁移覆盖集P和特征集W.因此可参照上述相关算法获得R-Wp方法的测试序列.由R-Wp方法的实现可知,第1阶段的测试序列为表11中的测试序列,而第2阶段的测试序列为表4中的测试序列.综合表11和表4,R-Wp方法的测试序列总长度为121.文献[23]证明了R-Wp方法与扩展Wp方法具有相同的错误探测能力.4冗余约简软件测试的目的是以较小的测试成本为代价,尽可能发现软件中的错误.上述基于FSM的测试方法产生的测试序列集中可能包含冗余,如对于W方法,表2中测试序列ra和raa之间存在冗余,因为能被序列ra发现的错误,一定能够被序列raa发现,则序列ra就是冗余序列.冗余序列的存在会导致测试成本的激增,为此本文提出在维持错误探测能力的前提下,减少测试序列中的冗余.文献[14]从测试覆盖准则的角度,分析满足不同测试覆盖准则的测试用例集合内存在的冗余问题,该研究能够保证约简后的测试用例集合同样也Page13满足某个测试覆盖准则.但是文献[14]中的研究并不能保证约简前后的测试用例集合具备相同的错误探测能力.为此,本文提出采用前置和后置条件分析法,约简测试序列中的冗余,即在相同前置条件和后置条件下,测试序列的冗余约简并不会降低测试序列集合的错误探测能力.定义14(前置和后置条件).测试序列A中的某个元素b的前置条件是A中与b相邻的前一个元素a的输出,元素b的后置条件是元素b的输出.由定义14可知,在图1(a)的MS中,测试序列ra,其中a的前置条件为r的输出“-”,a的后置条件为0.对测试序列为raabb,该序列的前置条件为-001,该序列的后置条件为0011.定义15(冗余).若测试序列A包含了测试序列B,且包含部分与B拥有相同的前置条件和后置条件,则在序列A和B中,B是冗余的.对于图1(a)中的MS而言,测试序列raa包含测试序列ra,且包含部分与ra拥有相同的前置条件与后置条件,则ra是冗余的.定理5.对测试序列A,B而言,若B是冗余的,则测试序列A的错误探测能力与序列A和B的错误探测能力相同.证明.假定测试序列B能够探测到错误集合为E,则B→E.由定义15可知,A包含B,则对于序列B中的任意一个元素b,在A包含B的部分中一定存在一个元素a,使得b=a且它们拥有相同的前置条件和后置条件,则a→b,因此A→B.由关系的传递性可知,若A→B和B→E,则有A→E,即序列A也能探测到错误集合E.因此序列A与序列A和B的错误探测能力相同.对序列A和B,若A仅仅包含B,则并不能得出A→B.因为序列B有它的前置条件和后置条件,前置条件是序列B出现的前提,后置条件保证了序列B的错误探测能力,因此若不能保证A中包含B的部分也与B一样具有相同的前置条件和后置条件,则序列A并不能保证发现序列B能够探测到的错误.依据本文的冗余定义,可以对上述所有基于FSM的测试生成方法进行冗余约简.本文给出序列集合的冗余约简算法TSRD.算法TSRD.测试序列的冗余约简算法.输入:测试序列组ts[1],ts[2],…,ts[n]和Mealy机MS输出:被约简后的测试组1.StringBuffersb=newStringBuffer();//初始化2.按序列长度递减排序测试序列组ts[1],ts[2],…,ts[n];3.sb.append(ts[1]).append(“@”);4.for(inti=0;i<ts.length;i++)5.for(intj=i+1;j<ts.length;j++)6.Stringst=λ(s1,ts[i]);7.Stringst1=λ(s1,ts[j]);8.If(ts[i].indexOf(ts[j])!=-19.sb.append(ts[j]).append(“@”);10.Endif11.Endfor12.删除字符串sb中的最后一个符号“@”;13.ts=newString[sb.toString().split(“@”).length];14.ts=sb.toString().split(“@”);15.sb=newStringBuffer();16.for(intk=0;k<=i;k++)17.endfor18.returnts.split(“@”);//返回被约简后的测试序列算法TSRD的时间主要集中在步2和4,其中步2的时间最多为n2,步4的时间不超过n2,因此算法TSRD的最坏时间复杂度为O(n2).5实验评估实验的内容包括测试成本、错误探测能力、冗余约简效率及改进T方法(本节简称T方法).实验的对象包含3个协议模型CM1、CM2和CM3(来自文献[6,10,24]),一个学生管理系统模型SIMS,一个在线邮箱模型EMAIL和一段程序模型PM.针对程序模型PM,我们在实际程序中添加了5个错误.有关程序建模的方法可以参考文献[8].实验中包含3类错误:错误类型I表示迁移错误,错误类型II表示输出错误,错误类型III表示额外迁移错误.模型MS及其应用模型MI的详细信息如表13所示.模型MS信息CM1363I,II,III1,1,1CM2364I,III2,2CM3573I,II1,2PM11125I,II4,1SIMS10214II,III2,2EMAIL7134I,II,III2,1,15.1测试成本影响测试成本的主要因素是测试用例的总数[25],因为对每条测试用例都需要分配资源,如测试计划、测试设计和测试执行.其中测试执行又与测Page14试用例的长度有关.为此,本文提及的测试成本包括测试序列的总长度和测试序列的总数.假定测试序列总数产生的测试成本为C1=h(Sq),是一个关于序列总数Sq的函数,测试序列总长度产生的测试成本为C2=g(Ls),是一个关于序列总长度Ls的函数,则总的测试成本为C=C1+C2.为获得函数h(Sq)和g(Ls),不妨假设一条总长度为1的测试序列产生的测试成本为1,则1=h(1)+g(1).因此,g(1)=1-h(1),h(1)<1及g(1)<1.假设α=h(1),则1-α=g(1).因此,函数h(Sq)=α×Sq,g(Ls)=(1-α)×Ls.基于上述分析,本文给出了测试成本的量化评估指标.定义16(测试成本).基于FSM的测试成本C被定义为其中Sq表示测试序列的总数,Li表示第i条测试序列的长度,α是小于1的测试参数,表示测试序列的数目对测试成本的影响,1-α表示测试序列的总长度对测试成本的影响.图6若干基于FSM的测试方法的测试成本一般而言参数α小于1/2,即测试序列总长度对测试成本的影响要大于测试序列数目对测试成本的影响.依据式(1),可以量化评估基于FSM的测试方法的测试成本,同时也能估算测试时间.若知道人均每日测试成本Cd,则测试时间D=C/Cd.因此,式(1)可以作为实际软件测试成本花费的一项重要评价指标.为量化评估上述基于FSM的测试生成方法的成本开销,本文假定参数α=0.2,分别计算由不同模型产生的测试序列的成本.在实验中R-Wp方法设定的区分集Z=X[1]·W.由于T方法的测试序列长度是随机的,导致测试成本的随机变化,因此本节没有将T方法与其它方法进行测试成本比较,而在5.4节对T方进行实验评估.图6显示了上述不同测试生成方法应用于不同模型时的测试成本消耗.在图6(c)和(f)中的DS方法结果为0,其原因是不能由模型CM3和EMAIL获得区分序列,(d)中的UIO和UIOv方法的结果为0,其原因是PM模型不存在UIO序列,即PM模型不是强连通的.Page15由图6可以得出一些实验结论:(1)一般而言,基于FSM的测试方法的成本递减顺序:R-Wp方法>W方法>UIOv方法>Wp方法>DS方法>UIO方法>迁移覆盖>状态覆盖.(2)若仅从成本角度考虑,R-Wp方法是最不经济的.实验中R-Wp方法仅考虑m-n=1的情况,若考虑m-n>1的情况,则R-Wp方法的测试成本还将成倍增长.另外,在程序模型PM及两个软件系统模型SIMS和EMAIL中,R-Wp方法的测试成本是数倍甚至是数十倍于其它基于FSM的测试方法.(3)DS方法、UIO方法和UIOv方法并不适用于所有的FSM模型.5.2错误探测能力本文讨论的错误探测能力包含错误的类型和错误的数目,其评价指标是指在实际程序中植入错误,考核被探测错误在所植入的同类型错误中所占的比图7若干基于FSM的测试方法的错误探测率在图7(c)和(f)中,DS方法的错误探测率为0,其原因是模型CM3和EMAIL不存在区分序列,重,即被查杀的变异得分(mutationscore)[26].为探测实际软件中的错误,本文分别为模型CM1、CM2和CM3设计了相应的MI,为程序模型设计了一段包含错误的程序,而模型SIMS和EMAIL则直接采用它们的应用.为了量化评估测试效率,本文给出了错误探测率的定义.定义17(错误探测率).软件的错误探测率ρ被定义为其中St表示错误类型的总数,Nf(i)表示探测到i型错误的数目,Sf(i)表示软件中存在的i型错误的总数.式(2)将不同类型的错误视为同等重要,错误探测率ρ涉及错误类型的种类和同一种错误类型的错误数目.依据式(2),可以量化计算各种测试方法的错误探测能力.图7显示了这些测试方法的错误探测率.(d)中UIO方法和UIOv方法的错误探测能力为0,其原因是模型PM不是强连通的.若不考虑图7中Page16DS方法、UIO方法和UIOv方法的无效情况,则由图7可以得出一些重要的结论:(1)上述任何一种测试方法都不能保证100%探测到所有系统中的错误,其中R-Wp方法的错误探测率最高,状态覆盖的错误探测率最低,W方法、Wp方法和UIOv方法的错误探测率相同.(2)在(a)和(b)中,迁移覆盖的错误探测率比W方法和Wp方法的错误探测率要低.这是由于协议测试时状态位信息不可获得,造成迁移覆盖产生的测试序列不能辨别最终获得的状态,导致其错误探测能力的下降.(3)在(d)、(e)和(f)中,迁移覆盖的错误探测率与W方法和Wp方法的错误探测率相同,其原因是在对程序和两个系统的测试时,状态位可获得.因此,若测试时状态位可获得,迁移覆盖的错误探测率等同于W方法和Wp方法.(4)在(b)中,UIO方法的错误探测率比UIOv方法低下,因此UIO方法的错误探测率不如W方法、Wp方法和UIOv方法.(5)在(c)、(d)和(f)中,DS方法、UIO方法和UIOv方法的错误探测率为0,因此DS方法、UIO方法和UIOv方法的使用范围比W方法和Wp方法要窄.为进一步评估这些方法,本文给出了针对某一种错误类型的探测效率的评价指标.探测率ρ(i)被定义为定义18(i型错误探测率).软件的i型错误其中Nf(i)(k)表示在第k个模型中探测到i型错误的数目,Sf(i)(k)表示第k个模型中i型错误的总数.定义18给出的是某一种错误类型的平均错误探测率.依据式(3),我们能够统计上述测试生成方法的I、II和III型错误探测率,如图8所示.一些重要的结论可以由图8得出:(1)在实验中,上述方法对错误类型II的探测是最有效的,其中迁移覆盖、W方法、Wp方法和R-Wp方法能够100%地探测到系统中错误类型II的所有错误.(2)错误类型I的探测效率要低于错误类型II的探测效率,且没有一种方法能够保证发现所有应用中错误类型I的错误.这个问题的原因在于模型PM.例如,若程序中的迁移条件为a>0,但被误写成a0,则输入a=1不会发现这个迁移错误.(3)错误类型III的探测效率最低,在实验中,仅有R-Wp方法能够发现这类错误,且不能保证发现错误类型III中的所有错误.5.3冗余约简效率本文所指的冗余约简包括测试序列总长度的约简和测试集合大小的约简.由于本文提出的冗余约简方法对状态覆盖和迁移覆盖没有任何效率,因此本文仅针对W方法、Wp方法、UIO方法、UIOv方法和R-Wp方法进行冗余约简效率的评估.本文给出了两项冗余约简的评价指标.定义19(测试序列总长度的约简率).测试序列总长度的约简率RL被定义为其中Sq表示测试序列的总数,Li表示第i条测试序列的长度,Li(r)表示第i条序列中冗余的长度,若第i条序列满足冗余定义(定义15),则Li(r)=Li,否则Li(r)=0.定义20(测试集合的约简率).测试集合的约简率RS被定义为其中Sq表示测试集合中序列的总数,Sq(r)表示测试集合中被约简的测试序列总数.依据式(4)和(5),本文对不同方法的冗余约简效率进行了评估,结果如图9、图10所示.由于模型PM不存在UIO序列,因此UIO方法和UIOv方法不能应用在模型PM中,同理DS方法不能应用在模型CM3和EMAIL中.由图9、图10可以获得一些重要信息:(1)本文提出的冗余约简方法对大多数基于FSM的测试方法都是有效的.其中对W方法、WpPage17表14T方法的实验结果实验CM1的结果111I,II30I,III60I,II80I1100I,II,III151I,II,III215I,II30I,III60I,II33I1100I,II,III69I323I,II,III30I,III60I,II38I,II1100I,II,III177II,III412I,II30I,III60I,II25I,II1100I,II,III143I,II511III30I,III60I,II19I1100I,II,III132I,II,III基于FSM的测试应用难点:(1)建立有效的由表14可知,T方法即表现出一定的错误探测FSM模型.当软件的应用复杂时,模型的建立将会能力,又表现出令人难已接受的测试序列长度.在变得非常困难,因为我们需要预知所有可能的状态、5组实验中,随机产生的测试序列都不同程度地发输入/输出信息、存在的迁移约束以及模型中的性现系统中的错误,而对模型CM2、CM3和SIMS的质,同时还需要考虑建模粒度、建模工具以及模型的实验中,序列长度均为n(n-1)×|I|,这表明这有效性;(2)缺乏通用的支持工具.虽然目前国内外一3个模型的实际应用中可能缺少MS中的迁移,通过观察实际的应用,我们发现CM1和CM3的应用缺些研究人员开发了若干基于FSM的测试支持原型工具[5,13,27],但这些原型工具并不能完全自动的由FSM少相应的迁移;而对模型SIMS的实际应用,由于概模型产生有效的测试用例,同时不同的工具原型所率问题,使得其中一条迁移无法在n(n-1)×|I|次针对的应用领域也不同,因此工具不具有通用性.被覆盖.另外由实验可知,测试序列的长度是变化的,最大长度是最短长度的2~3倍,这表明T方法现有基于FSM的测试研究需要一些前提和假设,导致了基于FSM的测试方法应用的限制.表15测试成本的稳定性差.显示了不同测试方法的应用条件及错误探测能力的6讨论分析.虽然文献[4]认为W方法、Wp方法、DS方法和T方法需要MS是强连通的(假设3),但在本文的实验中,当MS满足可达性(假设3)时,这些方法即可应用.UIO方法和UIOv方法需要MS是强连通的,否则MS不存在UIO序列.表15中“-”表示不能确定,l.st表示成本最低,l表示低成本,m表示中等成本,h表示高成本,h.st表示最高成本.依据上述的理论讨论及实验评估,本节对若干基于FSM的测试方法进行讨论,重点讨论了基于FSM的测试应用的难点、应用范围、测试成本和错误探测能力,并给出了一些基于FSM的测试的经验建议.方法、UIOv方法和R-Wp方法的冗余约简效率较高,而对DS方法的冗余约简效率相对要低.(2)在协议模型CM1、CM2和CM3的应用中,冗余约简的效率要明显高于对程序模型PM和实际的系统模型SIMS和EMAIL.5.4T方法的实验本节实验的目的是为了评估T方法的测试成本和错误探测能力.在实验中,若MI中的状态比MS中的迁移少,则T方法产生的测试序列将无法通过测试MI而获得与MS中一样的迁移.为此,在实验中本文为T方法增加了一条终止条件,即当随机产生n(n-1)×|I|次测试输入时,T方法强制结束.与3.6节中的计算机模拟实验不同,本节的实验假定错误应用MI不可知.本节采用T方法,分别由模型CM1、CM2、CM3、PM、SIMS产生5组测试序列,比较各组测试用例的长度及探测到的错误类型.实验结果如表14所示.PM的结果长度错误类型Page18些经验建议:比较项目假设成本错误探测能力算法时间复杂度状态覆盖2,3,7,8l.stI,IIO(n3)迁移覆盖2,3,7,8lI,IIO(n3)W1,2,3,4,7hI,IIO(n3)Wp1,2,3,4,7hI,IIO(n3)UIO1~4,7mI,IIO(n4)UIOv1~4,7hI,IIO(n4)DS1,2,3,4,7mI,IIR-Wp1,2,3,7h.stI,II,IIIO(n3)T1,2,3-I,II,III依据表15,本文给出了基于FSM的测试的一(1)若不计较测试成本,建议选择R-Wp方法进行软件测试.虽然R-Wp方法并不能保证探测出所有的错误,但对比其它方法,该方法的错误探测率最高.(2)若测试成本受限时,当状态信息可获得时,建议选择迁移覆盖方法;当状态不能获得时,建议选择UIO方法或DS方法.(3)综合考虑测试成本和错误探测能力,我们建议采用组合测试.当状态信息可获得时,建议选择迁移覆盖方法与T方法进行组合测试;当状态信息不能获得时,建议选择Wp方法或UIOv方法与T方法进行组合测试.7相关工作基于FSM模型的测试已被广泛研究,形成了一系列的测试生成方法及相关理论,但工业界却很少在实际中应用这些理论成果[1,28].为搭建由理论研究领域通往工业界应用领域的桥梁,研究人员对基于(FSM)模型的测试进行综述和评估.Sidhu等人[4]以运输协议为例,学习了若干基于FSM的测试方法.实验表明,UIO方法、DS方法和W方法在强一致性测试(strongconformancetest)中能够探测所有的错误,而T方法并不能发现所有的错误,且测试序列集中存在大量的冗余.然而,在我们的实验中UIO方法的错误探测能力比W方法弱,且UIO方法和DS方法都存在失效的情况.我们认为其原因是Sidhu等人的实验案例是一个个案,因此实验结果不具有代表性,同样强一致性测试中的错误类型也较实际软件中的错误类型少.Dalal等人[5]利用一个基于模型的测试支持工具测试了4个实际项目,并讨论了实现基于模型的测试时的注意事项.然而测试支持工具仅支持特定建模语言AETGSpec,而非理论研究非常成熟的有限自动机.Broy等人[6]综述了若干基于FSM的测试生成方法,讨论了方法的理论基础,但缺乏相关的实验比较和评估.另外,文中的算法并不完善,部分算法难以应用.Neto等人[3,7,28]利用网上5大数字图书馆资源,对基于模型的测试的论文进行统计,讨论了现有研究工作状况、分类、工具支持及不同方法的特性等,这些都为工业应用提供了参考价值.然而他们的研究并没有比较各种测试方法的好坏,判断一种基于模型的测试方法好坏的依据是能否有相应的工具支持.Mohagheghi等人[29]对基于模型的测试中模型的质量提出了6个评价指标:正确性、完整性、一致性、可理解性、工具支持性和局限性.Pretschner等人[30]提出了基于模型的测试有3个关键因素:描述软件行为的模型、支持测试生成的工具和测试生成算法(准则),并对前两项关键因素进行了讨论.Dorofeeva等人[31]采用实例学习了多种测试生成方法,评估了测试序列的总长度,但并未对错误探测能力进行讨论及测试成本进行定量的分析.Ammann等人[8]对若干基于FSM的测试覆盖准则进行了评估,但缺少对不同准则的实现算法.与现有基于FSM模型的测试评估不同,本文讨论并完善了基于FSM的测试方法的理论和若干实现算法,从多个角度对若干基于FSM的测试方法进行实验比较.为了实现比较的客观性和可操作性,本文提出了实验评估的5项量化指标.另一项与本文研究工作相关的是测试序列集合的冗余约简.早期关于测试用例集合的约简技术主要是采用一些启发式算法[32-33]选取测试有效的用例,随后聂长海等人[34]提出利用需求间的相互关系对测试集合进行约简,这些研究非常适合回归测试中的冗余约简,而并不适合基于FSM的测试序列集合的约简.一些研究者提出利用序列的重叠(overlap)[12,35]部分对测试序列集合进行合并,但这种约简技术并未考虑到约简前后测试序列集合的错误探测能力.我们之前研究了由测试覆盖准则产生测试序列集合的冗余约简[13],提出了利用字符串匹配方式的冗余约简方法,该方法能够保证约简前后都满足某项测试覆盖准则.与之前的研究不同,本文的研究保证了约简前后测试序列集合拥有相同的错误探测能力.8结论基于FSM的测试能够由描述软件行为的模型自动产生测试序列集合,极大地降低了测试用例设计的成本.然而由于现有理论的不完善及通用性支持工具的缺乏,目前基于FSM的测试还未在工业界得到广泛的应用.为提高软件自动化测试的水平,Page19推广基于FSM的测试在工业界的应用,本文对基于FSM的测试理论和方法进行了补充及实验评估.本文的主要贡献如下:(1)补充了基于FSM模型的测试理论,如提出了区分序列的构造理论及测试序列集合冗余约简的理论;(2)改进并实现了相关的基于FSM的测试生成算法;(3)提出了对基于FSM的测试评估的5项量化指标,实验评估了若干基于FSM的测试方法,并给出了应用这种测试方法的相关经验性建议.测试支持工具是基于FSM的测试方法应用的一项重要指标.我们已经开发了一个基于FSM的、面向Web应用的测试原型工具,将来的主要工作是开发一个通用的、基于FSM的测试支持工具,包括FSM的建模、测试生成、测试执行和测试评估等,以便更好地推广基于FSM的测试方法.
