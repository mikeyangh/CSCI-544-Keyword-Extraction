Page1反编译中用户函数与库函数同名的区分技术研究吴伟峰赵荣彩(信息工程大学信息工程学院郑州450002)摘要ITC反编译系统应用了基于动态链接信息的库函数快速识别技术,对于绝大部分待翻译IA-64二进制可执行程序中的库函数它都能正确识别,但是当二进制可执行程序包含有与库函数同名的用户函数时,就可能会出现问题.作者在深入分析基于动态链接信息的库函数快速识别技术所导致的问题原因的基础上,充分研究了ELF64格式二进制文件的具体组织及编译链接策略,针对反编译及二进制翻译在此方面的问题,给出了准确区分用户函数和库函数的区分算法.关键词反编译;IA-64;ELF64;动态链接;用户函数,库函数,同名1引言库函数恢复在逆向工程中具有极为重要的作用,因为它给反编译工作带来了如下好处:屏蔽了依赖于某一体系结构机器低级特性的影响、降低了后续处理过程的复杂性、增强了中间表示及后端代码的可读性和正确性,同时也提高了反编译生成代码移植时的运行效能.库函数的识别是相关研究中最热门的问题之一,也是极具应用价值的一项研究内容.库函数的识别与编译器及其版本都有关系,因此研究通用的识别器极其困难.从几篇已发表且具有代表性的文章看出,目前进行的识别和恢复研究都是针对特定编译器版本的系统库函数的.早期,库Page2函数识别方法[1-2]多为针对某种编译器的特定版本和特定模式手工构造库函数识别模板库,这种方法耗时太长且效率低下.后来,又有学者提出了自动生成模板库的方法和技术,但构造模板库的工作量仍然很大[3-5].鉴于上述库函数识别技术存在的缺陷,参考文献[6]立足于链接程序链接过程的逆阐述了识别库函数的恢复思想,针对IA-64上的ELF64格式二进制文件提出了基于动态链接信息的库函数快速识别技术,显著降低了库函数识别所需的工作量和时耗.针对绝大部分待翻译的IA-64二进制可执行程序应用上述的库函数快速识别技术都能得到令人满意的正确结果,但是当二进制可执行程序包含有与库函数同名的用户函数时,就可能会出现问题.如果用户编写的同名函数与相应的库函数等价,把其识别成库函数没有问题;但如果两者实现的功能不等价,如仍把其识别成库函数就会导致无法预测的后果,因此,有些软件将此作为一种反反编译的混淆策略.迄今为止在反编译和二进制翻译领域都没有对用户函数与库函数同名的区分问题进行过相关的研究.针对与库函数同名的用户函数给库函数识别带来的问题,本文以反编译系统ITC为平台基于ELF64格式二进制文件给出了准确判定库函数和用户函数的区分算法.2系统平台ITCITC的设计目标是实现一个静态二进制翻译系统ITA,完成从IntelIA-64/Linux平台上可执行的二进制代码到Alpha/Linux平台上可执行二进制代码的自动翻译工作.ITA是静态二进制翻译器,主要由两部分组成:反编译器和目标机C编译器,如图1所示.其中,反编译器由四部分组成:指令解码器、语义映射器、通用分析器、C代码生成器.指令解码器的功能是依据用户的命令,装载需要翻译的可执行程序的二进制映象,提取程序的各段信息,找到程序的主入口点,完成二进制指令流到IA-64汇编表示的转换;语义映射器是利用语义描述语言对IA-64指令语义进行描述,建立指令与其对应描述之间的映射关系,把汇编指令转换成与机器特性相关的低级中间表示RTL(RegisterTransferList);通用分析器的核心技术是过程恢复,主要功能是通过对过程的抽象以及数据流分析和控制流分析,对控制流以及与过程相关的内容进行恢复,生成与机器无关的高级中间表示HRTL(Higher-levelRegisterTransferLan-guage);C代码生成器完成将HRTL转换成低级C代码,同时使用数据数组向量和数据段链接映射相结合的方式实现数据段的映射寻址.最后应用基于gcc2.95.3的目标机交叉编译器将生成的C代码编译成可在Alpha上执行的二进制代码,从而达到二进制代码翻译的目的.反编译器是ITA系统的核心组成部分,为了方便起见,在随后的阐述中将把ITA系统的反编译器称为ITC反编译系统.参考文献[6]介绍的库函数快速识别技术在ITC反编译系统中得到了应用.3函数同名问题3.1函数同名问题描述如果用户函数与系统库函数同名,则会出现两种情况:两者功能等价或者两者的输出结果不同.对于反编译而言,第1种情况因为功能等价,所以把同名的用户函数当成相应的库函数处理完全可以;但对于第2种情况,如果仍把其当成相应的库函数进行处理就改变了程序的原本语义,这样可能导致对整个程序的移植失败,因对此函数调用的返回结果跟预期结果不一致.下面使用两个具体的例子加以说明.例1.用户函数floor与数学库函数floor功能等价.#include"math.h"doublefloor(doublet){Page3}intmain(){}此程序的输入输出结果对如下,格式为〈输入数据、输出数据〉:对此程序的可执行程序进行反编译后仅得到一个main.c源程序文件,因把用户函数floor处理成了数学库函数floor,但得到的结果仍然为例2.用户函数floor与数学库函数floor的功能不等价.#include"math.h"doublefloor(doublet){}intmain(){}此程序的输入输出结果对格式为〈输入数据、输出数据〉:对此程序的可执行程序进行反编译后也仅得到一个main.c源程序文件,同样把用户函数floor处理成了数学库函数floor,但得到的结果却和源程序的输出结果大不一样:3.2函数同名问题分析按上节描述,参考文献[6]介绍的库函数快速识别技术无法把与库函数同名的用户函数同相应的库函数区分开来,且无法保证待反编译的二进制可执行程序包含的同名用户函数同库函数功能等价,如例2所示,所以才会导致这样的问题.表面上看来,原因在于反编译系统ITC无法将与库函数同名的用户函数识别出来;但从更深的层面看,真正的原因是现用的库函数识别技术存在严重的缺陷.所以,为了解决用户函数与库函数同名的问题,有必要更深入地研究参考文献[6]所描述的库函数快速识别技术及ELF64格式二进制文件的具体组织策略.4库函数识别流程解析参考文献[6]讨论的是IA-64体系结构下ELF64格式二进制可执行文件通过动态链接机制进行函数调用的库函数识别方法.由于IA-64二进制代码的动态链接符号表(dynamicsymboltable)中与库函数名对应的地址项为0,因此无法通过二进制代码中函数调用处的调用地址来判定所调用的库函数.为了解决上述问题,研究了IA-64体系结构关于动态链接实现的约定,结合实例分析了惰性绑定机制的实现过程,进而研究了ELF64中.plt段的布局规律,同时分析了.plt、.got、.IA_64.pltoff、.rela.IA_64.pltoff和.dynstr等段之间的相互联系,提出了由.plt段中的importstub地址反向推出对应的函数名的步骤和方法,并给出了ITC反编译系统中所使用的库函数名的识别算法,该算法可在二进制文件解码阶段建立库函数的importstub地址与函数名之间的一一映射关系,构建名字-值对并将其加入到反编译系统符号表中,以达到通过调用指令中的importstub地址就能够找到函数名的目的.下面通过一个例子加以说明.例3.包含库函数sin和用户函数cos的示例程序cos_sin-e.c.#include〈math.h〉floatcos(floati);intmain()Page4{floatb;b=sin(0.5);b=cos(0.6);printf("cos0.6is%f\n",b);return0;}floatcos(floati){i=ii;returni;}本节对程序cos_sin-e.c的各种操作,都是对其0000000000000000DFUND0000000000000280GLIBC_2.2__libc_start_main另外,该程序对应的.plt段内容组织如下:基于以上3组数据进行分析可得,库函数sin和printf的调用地址分别为0x4000000000000560和0x4000000000000540,两者都处于.plt段的地址范围之内,在动态链接符号表中两者对应的地址都为零,正好符合引入的库函数识别技术的识别范围,于是构建名字-值对〈sin,0x4000000000000560〉、〈printf,0x4000000000000540〉并把其加入到反编译系统符号表中;但对于用户函数cos,由于其在动态链接符号表中对应的地址是0x40000000000008f0,此地址不为零且函数cos的调用地址同样为0x40000000000008f0,所以反编译系统就直接将构建的名字-值对〈cos,0x40000000000008f0〉加入到系统符号表中.在随后解码过程中,解码main函数时会先后遇到和函数sin、cos、printf相应的函数调用,于是先把这些函数调用地址依次存入函数调用链中,在main函数解码完成后根据函数调用链再对相应的被调函数的函数体进行解码.解码之前要先判断该函数是否已被解码过,如果已解码过就不再对其进行解码;在IA-64机上使用gcc编译器生成的二进制可执行码而进行的.在此程序的objdump代码中,函数sin、cos和printf与相应的函数调用语句对比关系如下:…br.call.sptk.manyb0=4000000000000560〈sin〉;;…br.call.sptk.manyb0=40000000000008f0〈cos〉;;…br.call.sptk.manyb0=4000000000000540〈printf〉;;…此程序对应的动态链接符号表如下:另外,还要判断该函数是不是库函数,即需不需要对此函数的函数体进行解码,如果是库函数就不再对其进行解码.此时的反编译系统ITC对库函数的判定依据是:根据函数调用地址到系统符号表中查找匹配的名字-值对,从而得到被调用函数的函数名,然后再根据函数名判断此函数是不是库函数.对于例3而言,函数调用地址0x4000000000000560、0x40000000000008f0和0x4000000000000540对应的函数名字-值对分别为〈sin,0x4000000000000560〉、〈cos,0x40000000000008f0〉和〈printf,0x4000000000000540〉,因此可知main函数调用的3个函数是sin、cos和printf,从而根据函数名判定这3个函数都是库函数,进而不再对其函数体进行解码.这样库函数sin和printf得到了正确的识别,而用户函数cos却被错误地识别成了系统库函数.把与库函数同名的用户函数识别成库函数的主要原因是:对库函数的判定仅是依据函数名进行的,而编译器在处理与库函数同名的用户函数时又把其放入了动态链接符号表中.5ELF64格式二进制文件IA-64在Linux操作系统下的可执行文件为ELF64格式,ELF是UNIX系统实验室(USL)作为应用程序二进制接口(applicationbinaryinterface)开Page5发和发布的可执行连接格式[7-8].ELF文件可以从两个视角来看待文件的内容,一种是从文件链接的角度,文件由text、data、rodata、bss等一个个的section组成,另一种是从程序执行的角度,由segment组成,如图2所示.ELFheader在文件开始处,描述了整个文件的组织.另外,ELF文件还有两个可选的头表:程序头表(Programheadertable)或段头表(SectionheaderElf64_Offe_phoff;/Programheaderoffset/Elf64_Worde_flags;/Processor-specificflags/Elf64_Halfe_phentsize;/Sizeofprogramheaderentry/Elf64_Halfe_phnum;/Numberofprogramheaderentries/Elf64_Halfe_shentsize;/Sizeofsectionheaderentry/Elf64_Halfe_shnum;/Numberofsectionheaderentries/Elf64_Halfe_shstrndx;/Sectionnamestringtableindex/5.2ELF64文件中的表段表是反编译器经常使用的表之一.当段被装入到内存执行时,反编译器由ELF程序头找到段头图3ELF64程序头Elf64_Addrsh_addr;/Virtualaddressinmemory/Elf64_Wordsh_info;/Miscellaneousinformation/Elf64_Xwordsh_addralign;/Addressalignmentboundary/Elf64_Xwordsh_entsize;/Sizeofentries,ifsectionhastable/图4ELF64段头表结构table).通常,链接文件具有段表,可执行文件有程序头表,共享目标文件两者都有.Section提供了目标文件的各项信息(如指令、数据、符号表、重定位信息等),Programheadertable指出怎样创建进程映像,Sectionheadertable包含每一个section的入口,并给出对应的名字、大小等信息.5.1ELF64文件的header文件头在文件的开始部分,用于定位文件的其它部分.如图3所示,前两个字节为ELF文件的标识符,反编译器应用该标识符来确定该文件是否是ELF64文件,获得数据结构大小尾端的信息以及操作系统的相关信息等.文件头还含有其它表的偏移,例如程序头表、段头表等.文件头还包含这些表中项的个数.应用这些偏移,反编译器可以很容易获得访问信息所在表的位置.表项的个数可以帮助反编译器确定访问表内信息时是否越界.文件头还可以得到程序执行的第一条指令的位置,即入口点的信息可以确定.表,再从段头表中找出只读数据段、初始化数据段、未初始化数据段的起始虚地址和大小.段头表结构如图4所示.Page6字符串表中包含有段名和符号名字符串,它是一个字节数组,存储包含以null为终止的字符串.段头表项和符号表项通过相对于串表开始的索引来引用字符串表中的字符串.字符串表中的第一个字节定义为null,所以索引0总是指向null或不存在的名字.符号表存放有动态链接例程的名字及其它一些相关的信息.它通常是以数组的形式组织和存储的,其中第一项即下标为0的数组项是未定义使用的,存储内容如图5所示.符号表表项的存储结构如图6所示,结构体Elf64_Sym的数据成员指代的具体意义如下所示:st_name:此数据成员存储的是字符串表数组下标,通过这一下标获得相应的符号名.如果它的值不为零,可以通过这一下标值在字符串表中获得此表项对应的例程名字;否则,此例程名字为空.st_info:此数据成员描述的是符号类型和其具有的绑定属性.它占用8bits存储空间,低4位用于表示相应的符号类型,高4位用于表示绑定属性,具体含义见图7.NameValueSTB_LOCAL0NotvisibleoutsidetheobjectfileSTB_GLOBAL1Globalsymbol,visibletoallobjectfilesSTB_WEAK2Globalscope,butwithlowerprecedenceSTB_LOOS10Environment-specificuseSTB_HIOS12STB_LOPROC13Processor-specificuseSTB_HIPROC15st_other:保留数据成员,以备将来使用.数值必须为0.st_shndx:此数据成员存储的是段(section)索引,表明符号是在哪个段中定义的.对于那些未定义的符号,此数据成员的值为SHN_UNDEF;对于绝对符号它的值为SHN_ABS;而对于公共符号它的值则是SHN_COMMON.st_value:此数据成员存储的是和例程相关的值.数据值可能是一个绝对的值,或者是一个地址,这要视具体内容而定.st_size:许多的符号都有与其相关的存储空间大小.例如,一个数据目标的空间大小是它所包含的字节数.假如符号的大小为0或者其大小未知的时候,此数据成员的值为0.5.3ELF64文件中的代码组织本小节考虑的主要是与源程序运行密切相关的如上所述,在编译生成ELF64文件的过程中链接器要处理两种不同类型的输入文件:用户文件和库文件.对于两种文件我们在此仅考虑对.text段中可执行代码的处理.谈及对库文件的处理,就涉及到链接时对库函数调用的两种处理策略:静态链接和动态链接.静态链接,是把涉及到的库中的程序和数据在链接时就绑定到可执行程序中;而动态链接使得大部分的链接过程延迟,直到程序开始运行时或已经开始运行时才进行链接.虽然动态链接有许多静态链接不具有的优势,但它比静态链接要慢很多,因为大部分的链接过程在每次程序运行时都必须重做,程序中所有的动态链接符号都得通过5.2节给出的符号表(symboltalbles)来查找和解析;同时动态链接的程序通常使用额外的“胶合(glue)”代码来调用共享库代码在ELF64文件中的组织情况[7-9].ELF64文件通常包含有文本、数据和bss段,即为.text、.data和.bss段.除此之外还有.init和.fini段.链接器接收的每个输入文件都拥有一系列不同类型的段,它从输入文件中将每种段(包括库目标文件中的各种段)都收集到一起,如可执行代码几乎都链接到输出文件的同一个.text段中;同时链接器会记下哪些符号需要在运行时从库文件中解析,并生成.interp、.got、.plt段和符号表段以支持动态链接.接下来链接器会按照约定的顺序安排存储空间,在Linux系统中是先文本段.text,然后是数据段.data,随后是.bss段.Page7中的例程,因胶合代码常包含若干个跳转,这会明显地减慢调用速度.所以,现在编译器大都同时采用两种链接策略,以获得最佳的运行效果.对用户文件的处理,一般情况下直接将用户代码放置在.text段中合适的位置上.但有一个例外情况是用户在程序内部定义了与库文件中的函数同名的用户函数,并且用它们代替系统库文件中的函数,特别是malloc和free等关于堆区管理的函数.在这种情况下将设置一个链接器标识,表示“不要在库文件中查找这些符号”,这样虽然与库函数同名的用户函数被作为用户函数进行了链接处理,但此用户函数却像库函数一样在动态链接符号表中留下了自身的链接信息,如第4节例3程序中的cos函数.6函数同名问题的解决方案根据第4节对库函数识别技术和第5节对ELF64格式二进制文件组织策略的具体分析,可知要解决用户函数与库函数同名的区分问题,应把突破点放在以下两方面:(1)与库函数同名的用户函数和库函数在.text段中所处位置的差别;(2)二进制文件中的动态链接符号表.依据与库函数同名的用户函数和库函数在.text段中所处位置的差别,完全可以解决同名问题.因为编译器gcc在处理函数时有明确的标准:库函数都使用动态链接进行链接处理,对库函数的调用地址都处于.plt段的地址范围之内;用户函数都使用静态链接进行链接处理,对函数的调用地址都大于.plt段的段尾地址.因此,对于由gcc编译生成的二进制可执行程序可以按照调用地址与.plt段地址之间的关系进行用户函数和库函数的区分.对由icc编译器[10]编译生成的二进制可执行程序处理起来就很麻烦,因为icc是Intel公司针对Intel系列机器发布的编译器,由于商业竞争的原因它不像编译器gcc那样标准,而是采取了很多深度的编译优化策略.例如:icc在处理库函数时对小部分库函数像gcc那样采用动态链接的处理策略,而对大部分的库函数则采用静态链接的处理策略,更甚对一部分的库函数则直接在静态链接的基础上又采用内嵌优化策略来提高程序的运行速度.虽然编译器icc在处理库函数时极不规范,但并不是无章可循,由icc编译生成的二进制可执行程序中用户函数代码和库函数代码都是集中存储的,且在两种代码交界处有一个标志性符号“DwArFiI_HiGh_Pc”,据此,可对由icc编译生成的二进制可执行程序按照函数调用地址、.plt段地址以及标志性符号“DwArFiI_HiGh_Pc”对应地址之间的关系进行用户函数和库函数的区分:当函数调用地址处于.plt段尾地址和标志性符号“DwArFiI_HiGh_Pc”对应地址之间时,此函数为用户函数;否则,为库函数.上述方案深度依赖于ELF64文件中的符号表,特别是标志性符号“DwArFiI_HiGh_Pc”.当ELF64文件经过strip等瘦身工具处理后,其中绝大多数符号信息都不复存在,包括符号“DwArFiI_HiGh_Pc”,仅留下了动态链接符号表中的少量信息,因为这些符号信息在动态链接的时候需要使用.庆幸的是动态链接符号表中保存有库函数及与库函数同名的用户函数的一些信息,下面基于二进制文件中的动态链接符号表给出一种通用的用户函数与库函数同名的区分算法.6.1基于动态链接符号表的函数同名问题分析本节对用户函数与库函数同名问题的分析仍是基于第4节例3给出的程序cos_sin-e.c进行的.使用反汇编工具objdump显示的动态链接符号表信息与5.2节描述的符号表存储结构是一一对应的.例3示例程序经icc编译器编译生成的二进制可执行程序对应的信息组如图8所示,经gcc编译器编译生成的二进制可执行程序对应的信息组如图9所示.结合5.2节描述的符号表存储结构及图8和图9给出的动态链接符号表信息,可以很显然地看出:st_name列对应的是函数及例程的名字;st_value列对应的是与函数或例程相关的地址;st_info列对应的是与函数或例程相关的符号类型信息和绑定属性;st_shndx列表明st_name列给出的符号是在哪个段中定义的,ABS代表此符号是绝对符号且它的值为0xFFF1,UND代表此符号是未定义的符号且它的值为0,对于其它项(如:.text)所具有的值要视具体情况而定,但肯定不为0;st_size列表明与函数或例程符号相关的空间大小值;“区分标志”列给出的信息表明相关函数或例程所处的位置信息,GLIBC_2.2表示对应的函数或例程来自动态链接库文件,Base表示对应的函数或例程来自于本ELF64文件的.text段.Page8st_valuest_infost_shndxst_size区分标志st_name6000000000002b10gDOABS0000000000000000Base_DYNAMIC0000000000000000DFUND00000000000001e0GLIBC_2.2__cxa_finalize0000000000000000DFUND0000000000000280GLIBC_2.2__libc_start_main图8例3示例程序经icc编译对应的信息组st_valuest_infost_shndxst_size区分标志st_name0000000000000000DFUND0000000000000280GLIBC_2.2__libc_start_main图9例3示例程序经gcc编译对应的信息组遗憾的是我们从动态链接符号表中得不到“区分标志”列显示的信息,推测此列信息可能是由其它列中的信息综合得到的.虽然如此,仍可以根据st_name、st_shndx和st_size三列信息最终判定出哪些函数为库函数,哪些函数是用户函数.比如对用户函数cos接着第4节描述的识别工作继续往下做,当main函数解码完成并依据函数调用链对被调用地址0x40000000000008f0或0x4000000000001240所对应的cos函数体进行是否解码判定时,根据系统符号表中的名字-值对Page9得到与其相对应的st_shndx和st_size值,如果函数调用地址不在.plt段的地址范围中且st_shndx和st_size的值都大于0,则此函数为用户函数同时对其函数体进行解码,否则此函数为库函数.6.2基于动态链接符号表的同名问题区分算法基于上节的分析,本节将给出一种基于动态链接符号表的用户函数与库函数同名的区分算法.在给出区分算法之前先定义并建立一个与动态链接符号表相对应的不完全符号表Table_Dynamic,该表包含的数据成员有st_name、st_shndx和st_size,具体组织形式如图10所示.st_namest_shndx图10不完全符号表Table_Dynamic的组织结构用户函数与库函数同名的区分算法描述如下:功能:判定待解码的函数是否为库函数输入:函数调用地址Addr、系统符号表Table_Sys和符输出:与地址Addr相应的函数是否为库函数,是库函begin根据调用地址Addr在系统符号表Table_Sys中查end在ITC系统中应用上述同名区分算法后,系统对库函数的识别能力得到了极大的提高,有效消除了与库函数同名的用户函数对翻译正确性的影响.正确识别了所有与库函数同名的用户函数,像sin、cos、sqrt、log、exp、pow及random等;另外,对测试集IEEE754浮点测试软件中的测试用例paranoia包含的用户函数random进行了成功的识别.7结束语本文首先指出参考文献[6]介绍的库函数快速识别技术在区分库函数和与库函数同名的用户函数方面存在的缺陷,并在深入分析库函数快速识别技术、ELF64格式二进制文件的具体组织策略、gcc和icc编译器在处理库函数及与库函数同名的用户函数时所采用的编译策略的基础上,提出了判定库函数和同名用户函数的区分算法.在设计此算法的过程中考虑到各种可能出现的情况,另外还特别考虑了strip等瘦身工具的使用对区分算法的影响.大量测试用例的检验表明,本文给出的用户函数与库函数同名的区分算法是有效的,达到了正确区分用户函数和库函数的目的.
