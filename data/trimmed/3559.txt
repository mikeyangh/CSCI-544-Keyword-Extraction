Page1基于冲突域的高效属性约简算法葛浩1)李龙澍2)杨传健3)1)(滁州学院机械与电子工程学院安徽滁州239012)2)(安徽大学计算机科学与技术学院合肥230039)3)(滁州学院计算机与信息工程学院安徽滁州239012)摘要引入冲突域的概念,研究冲突域的性质.以冲突域中冲突对象数目的变化为度量标准,给出核属性和属性重要性的计算方法,并设计了快速求解核属性和属性重要性的算法.在此基础上,给出高效属性约简算法,该算法以核属性为初始约简集,以属性重要性为启发式信息.在最坏情况下,算法的时间复杂度为O(|C|2|U|),空间复杂度为O(|U|);实验结果表明,该算法是正确的、高效的.关键词决策表;粗糙集;属性约简;正区域;冲突域;核属性1引言粗糙集理论[1-2]是波兰数学家Pawlak教授于1982年提出的一种处理含糊和不精确性知识的数Page2决策表所有约简和最优约简是一个NP-Hard问题[3].属性约简方法一般采用启发式算法,常用的启发式算法有三类:基于信息熵、基于可分辨矩阵和基于正区域.苗夺谦等人[4]提出了基于互信息的MIBARK算法,其时间复杂度为O(|C||U|2)+O(|U|3),但不能保证算法的完备性;王国胤等人[5]给出基于信息熵的CEBARKNC算法,算法的时间复杂度为O(|C|2|U|2).Hu等人[6]根据Skowron可分辨矩阵[7]提出一种属性约简算法,其时间复杂度和空间复杂度分别为O(|C|2|U|2)和O(|C||U|2),但因为没有考虑到决策表中存在不相容问题,Hu的算法在处理不相容决策表时,不能保证获得正确的约简;刘文军等人[8]给出基于改进的可分辨矩阵的约简算法,可以很好地处理不相容问题,但该算法的时间和空间复杂度与Hu的算法是相同的;蔡卫东等人[9]和徐章艳等人[10]进一步改进了可分辨矩阵,给出了时间复杂度和空间复杂度为max{O(|C|2(|Upos||U/C|)),O(|C||U|)}和max{O(|C|(|Upos||U/C|)),O(|C||U|)}的算法.以上这两类启发式约简算法的时间复杂度均比较大,并且空间复杂度也不理想.正区域的属性约简方法因不需要建立可分辨矩阵,其空间和时间开销相对较小,许多学者对这种方法做了大量研究.叶东毅[11]给出对Jelonek约简算法的改进算法,其时间复杂度最坏情况下为O(|C|2|U|2).由于基于正区域求解约简过程中,等价类划分是约简算法的关键步骤,因此刘少辉等人[12]采用了快速排序法对属性集排序后划分等价类,其时间复杂度为O(|C||U|log|U|),由此设计的属性约简算法时间复杂度为O(|C|2|U|log|U|);徐章艳等人[13]对刘少辉等价类划分算法进行改进,采用链式基数排序算法划分等价类,其时间复杂度为O(|C||U),使整个约简算法时间复杂度降低为max{O(|C||U|),O(|C|2|U/C|)},但在某些情况下该算法是不完备的.针对目前约简算法中存在的不足:约简算法不完备、处理大数据集时的效率不够理想,本文提出一个基于冲突域的高效的完备属性约简方法.由于等价类划分是本文约简算法中的重要操作,因而首先采用分布计数的基数排序思想,求解等价类,使求解U/C的时间复杂度降为O(|C||U);然后给出冲突域的概念和相关性质,并提出基于冲突域的求核属性和属性重要性的方法;接着以核属性为初始约简集,以属性重要性为启发式信息,给出一个高效的属性约简算法,算法最坏情况下时间复杂度为O(|C|2|U|),空间复杂度为O(|U|).本文第2节介绍相关粗糙集理论;第3节提出一种分布计数的基数排序方法,并设计快速求解等价类算法,该算法提供给后面的操作使用;第4节给出了冲突域的性质和冲突域一般求解算法以及改进算法;在第5节中首先给出基于冲突域的快速求核方法,解决了因不相容性造成的求核错误,然后给出属性重要性的定义和性质,最后给出高效的属性约简算法;第6节通过一个实例说明本文的方法,并采用UCI数据库中数据集进行实验测试,且对实验结果进行分析;最后一节为全文总结.2基本概念定义1.一个决策表可以定义为其中,U为论域,是对象的集合,U={x1,x2,…,xn};A为属性集,A={a1,a2,…,am},A由两个部分组成A=C∪D且C∩D=,C为条件属性集,D为决策属性集,一般情况下D中只含有一个属性D={d};V为属性的值域,V={Va1,Va2,…,Vam};f为信息函数f:U×A→V,a∈A,x∈U,有f(x,a)∈Va.定义2.对于决策表S=(U,A,V,f),令PA,ind(P)={(xi,xj)|f(xi,b)=f(xj,b),b∈P}称为S的不可区分关系.显然不可区分关系为一个等价类,含x的等价类记为[x]P.P在U上导出的划分记为U/P.定义3.对于决策表S=(U,A,V,f),令PA,P_X={x∈U|[x]PX}称为X的P下近似集;P-X={x∈U|[x]P∩X≠}称为X的P上近似集;POSP(X)=P_X称为X的P的正区域.定义4.决策表S=(U,C∪D,V,f)中,PC,称POSP(D)=∪X∈U/DP_X为P关于D的正区域.定义5.决策表S=(U,C∪D,V,f),若存在xi,xj∈U,当i≠j时,若有f(xi,C)=f(xj,C)且f(xi,D)≠f(xj,D),则称该系统为不相容决策表,xi与xj称为不相容对象.否则称为相容决策表.定理1[14].给定决策表S=(U,C∪D,V,f),a∈C为核的充分必要条件是POSC-{a}(D)≠POSC(D).3等价类性质在求解正区域和核属性的过程中,等价类划分是一个关键步骤.求等价类的一般方法是对样本集U中未分类的对象进行两两比较,比较它们对条件Page3属性集C每个属性取值是否相同,如果相同,则属于同一个等价类.上述方法等价类的划分的时间复杂度为O(|C||U|2).性质1.一个决策表S=(U,A=C∪D,V,f),两个样本xi,xj∈U相对于属性集C同属于一个等价类当且仅当a∈A,有f(xi,a)=f(xj,a).由定义2,可以得证.根据性质1,可先对决策系统S按属性集C排序,然后分析排序后的决策系统S,划分等价类.刘少辉等人[12]和赵军等人[15]使用了快速排序,使等价类划分算法的时间复杂度降低为O(|C||U|log|U|),徐章艳等人[10,13]利用链式基数排序算法,将时间复杂度降低到O(|C||U|).本文提出一种分布计数的基数排序方法,按属性集C对决策表S排序,该算法的时间复杂度也为O(|C||U|),空间复杂度为O(|U|).该算法相对于徐章艳的方法更加易于处理决策信息系统.对决策表采用分布计数的基数排序思想:设S=(U,C∪D),其中C={ai|i=1…m},D={d},决策表一行为一个数据对象,则S是数据对象的集合:S={Si|i=1…n},其中Si为一个m+2的元组:Si=(xi,a1,a2,…,am,d),其中,Si.xi为对象的编号,Si.aj表示对象i的aj属性值,Si.d表示对象i的决策属性值.按照属性集C对S排序,即依次以每个属性ai对S排序.首先,把需要离散化的属性ai离散化,将其分布在整型区间[1…e](其中,0<e|U|);然后,构造一个计数表countPos[0…e],countPos中元素个数为U/{ai}中等价类的个数,每个元素用于存放U/{ai}中每个等价类当前最后一个元素在有序决策表中的位置,根据countPos表,可以直接将每个对象Si放到有序决策表最终的位置.在这个过程中,需要使用两个辅助空间:一个是countPos;一个是存放有序决策表的sortedS.算法1.等价类划分算法.输入:决策系统S=(U,C∪D,V,f),U={xi|i=1…n},输出:U/C1.fori=1to|C|do//分布计数的基数排序1.1.{初始化countPos表:countPos[0…e]=0;1.2.对属性ai,统计U/{ai}中每个等价类中对象的1.3.计算U/{ai}中每个等价类最后一个对象在有1.4.forj=|U|to1do1.4.1.{根据Sj.ai的值,在countPos表中找到Sj在有1.4.2.将Sj存入有序决策表sortedS的第pos位置;1.4.3.修改等价类[Sj.ai]{ai}当前最后一个元素在2.s=1,E1={x1};3.fori=2to|U|do4.输出等价类集合E(即U/C)和等价类数目s.算法中,步1循环体的时间复杂度为O(|U|),循环次数为O(|C|),因而步1总的时间复杂度为O(|C||U|);步3的时间复杂度为O(|C||U|),故算法1的时间复杂度为O(|C||U|)+O(|C||U|)=O(|C||U|).空间开销方面,在步1中辅助空间countPos其容量最大为|U|+1,步3中辅助空间sortedS的容量可以控制为2|U|.因而,算法1的空间复杂度为O(|U|).该算法思想将用于后面的算法中.4冲突域的性质及其算法4.1冲突域性质定理2.在决策表S=(U,C∪D,V,f)中,设PC,则POSP(D)=∪{Y|Y∈U/P∧YU/D}.证明.设U/P={Y1,Y2,…,Ym},U/D={X1,X2,…,Xn},若有Yi∈POSP(D)(1im),设x∈Yi,有[x]P=Yi∈POSP(D),则[x]D=Xj(1jn)∈U/D.根据正区域定义,x∈Yi有x∈P_Xj,即[x]PYj.因此,有POSP(D)=∪{Y|Y∈U/P∧YU/D}.定义6.决策表S=(U,C∪D,V,f)中,PC,P关于D的冲突域记为ConSet(P),定义为由定义6可知ConSet(P)是对S按照条件属性集P划分后,冲突对象类的集合.性质2.在决策表S=(U,C∪D,V,f)中,设PC,ConSet(P)为P关于D的冲突域,则对于xi∈ConSet(P),xj∈ConSet(P),满足f(xi,C)=f(xj,C)∧f(xi,D)≠f(xj,D).由定义6和定理2可以得证.4.2冲突域一般求解算法根据定义6和性质2,可以得到ConSet(P)的基本算法.Page4算法2.冲突域ConSet(R)的基本算法.输入:S=(U,C∪D,V,f)中,设≠PC输出:ConSet(P)1.ConSet(P)=;2.依据算法1,按属性P排序决策表S,得E和s;3.fori=1tosdo4.输出ConSet(P).算法中,步2的时间复杂度为O(|P||U|),步3的时间复杂度O(|U|),则算法2总的时间复杂度为O(|P||U|),空间复杂度为O(|U|).4.3改进的冲突域求解算法定理3.在决策表S=(U,C∪D,V,f)中,设PRC,则POSR(D)=POSP(D)∪∪{Z|Z∈Y/(R-P)∧Y∈U/P∧ZU/D},ConSet(R)=ConSet(P)-∪{Z|Z∈ConSet(P)/(R-P)∧ZU/D},其中U=U-POSP(D).证明.设U/P={Y1,Y2,…,Yt,Yt+1,…,Ym},POSP(D)={Y1,Y2,…,Yt},ConSet(P)={Yt+1,…,Ym},令Yi∈POSP(D),其中i=1,2,…,t;Yj∈U/P-POSP(D),其中j=t+1,t+2,…,m;由于,U/R是对U/P的加细,则U/R=U/(P∪(R-P))又有POSR(D)=∪{Z|Z∈U/R∧ZU/D}=∪{Z|Z∈Y/(R-P)∧Y∈U/P∧ZU/D}=∪{Z|Z∈Yi/(R-P)∧Yi∈U/P∧ZU/D}∪∪{Z|Z∈Yj/(R-P)∧Yj∈U/P∧ZU/D}=POSP(D)∪∪{Z|Z∈Yj/(R-P)∧Yj∈U/P∧ZU/D}=POSP(D)∪∪{Z|Z∈Y/(R-P)∧Y∈U/P∧ZU/D}.由于ConSet(R)=U/R-POSR(D),则ConSet(R)=U/R-(POSP(D)∪=(U/R-POSP(D))-=ConSet(P)-∪{Z|Z∈Y/(R-P)∧=ConSet(P)-∪{Z|Z∈ConSet(P)/∪{Z|Z∈Y/(R-P)∧Y∈U/P∧ZU/D})∪{Z|Z∈Y/(R-P)∧Y∈U/P∧ZU/D}Y∈U/P∧ZU/D}(R-P)∧ZU/D}.根据定理3,若≠PRC则ConSet(R)可以在ConSet(P)的基础上运算求得,这样可以避免求解过程中的一些重复运算,从而提高算法效率.进一步研究发现,在已知ConSet(C)的前提下,ConSet(R)的计算可以在定理3的基础上进一步简化.为了便于说明,下面先给出相关的定义.定义7.在决策表S=(U,C∪D,V,f)中,设≠PRC,U=U-POSP(D),记U=U-∪{Y|Y∈ConSet(P)∧x∈Y有x∈ConSet(C)},ConSet(P)=ConSet(P)-∪{Y|Y∈ConSet(P)∧x∈Y有x∈ConSet(C)}.定理4.在决策表S=(U,C∪D,V,f)中,设≠PRC,已知ConSet(C),则ConSet(R)=ConSet(P)-∪{Z|Z∈ConSet(P)/(R-P)∧ZU/D}.证明.由定理3,ConSet(R)=ConSet(P)-∪{Z|Z∈ConSet(P)/(R-P)∧ZU/D}=ConSet(P)-∪{Z|Z∈(ConSet(P)+∪{Y|Y∈ConSet(P)∧x∈Y有x∈ConSet(C)})/(R-P)∧Z(U+∪{Y|Y∈ConSet(P)∧x∈Y有x∈ConSet(C)})/D=ConSet(P)-∪{Z|Z∈(ConSet(P)/(R-P)+∪{Y|Y∈ConSet(P)∧x∈Y有x∈ConSet(C)}/(R-P))∧Z(U/D+∪{Y|Y∈ConSet(P)∧x∈Y有x∈ConSet(C)})/D=ConSet(P)-∪{Z|Z∈ConSet(P)/(R-P)∧ZU/D}.定理4表明了,如果ConSet(P)中某个等价类Z是ConSet(C)中某个等价类或某几个等价类的并集,则Z中的元素也必然属于ConSet(R),在进行求解ConSet(R)过程中则不需要对这样的等价类Z判断,直接放入ConSet(R)中即可.根据定理4,下面给出改进的冲突域求解算法.算法3.冲突域ConSet(R)的改进算法.输入:S=(U,C∪D,V,f)中,设≠PRC,输出:ConSet(R)1.根据ConSet(C)对ConSet(P)遍历,得ConSet(P);2.ConSet(R)=ConSet(P)-ConSet(P);3.对ConSet(P)的每个等价类Ei按属性R-P排序,4.forj=1tosdo5.输出ConSet(R).算法3中,步1和步2的时间复杂度为O(|U-POSP(D)|,步3时间复杂度为O(|R-P||U-Page5POSP(D)|),步4的时间复杂度为O(|U-POSP(D)|,因此算法3总的时间复杂度为O(|R-P||U-POSP(D)|),空间复杂度为O(|U|).5约简算法设计和分析针对决策表中存在的不相容性,下面给出一种,{定义8.决策表S=(U,C∪D,V,f)中,a∈Hu等人[6]和赵军等人[15]的求核方法对于相容的决策表处理是正确的,但对不相容决策表却不能保证获得正确的核.而采用启发式方法进行属性约简,通常是以核属性为初始约简集,下面先研究核属性的求解.5.1快速求核算法求核方法,该方法建立在冲突域的基础上.C,核属性集GCore(C)表示为GCore(C)={a|a∈C},|ConSet(C-{a})|>|ConSet(C)|.|ConSet(C)|表示ConSet(C)中冲突对象的数目.定义8说明了,若删除某个属性a后,如果冲突对象的个数增加了,说明a为核属性;否则a不是核属性.该方法避免了采用正区域方法中的一些繁琐操作,减少了计算量;也避免了采用可分辨矩阵方法中建立可分辨矩阵所需的大量时间和空间开销.定理5.对于决策表S=(U,C∪D,V,f),有Core(C)=GCore(C).证明.设U/C={Y1,Y2,…,Ym},U/D={X1,X2,…,Xn}.(1)首先,证明GCore(C)Core(C).对a∈GCore(C),由定义8可知,删除属性a后,ConSet中冲突对象个数增加了.设xConSet(C),x∈ConSet(C-{a}),则存在y[x]C且y∈[x]C-{a},有f(x,D)≠f(y,D).设x∈Xq,y∈Xp,yXq,由于y∈[x]C-{a}并且yYq,由下近似定义知x(C-{a})_Xq,故xPOSC-{a}(D).又因x在原来系统S中无冲突对象且x∈Yq,由于x∈C_Yq,故x∈POSC(D),于是POSC(D)≠POSC-{a}(D).所以a∈Core(C).因此,GCore(C)Core(C).(2)然后,证明Core(C)GCore(C).对a∈Core(C),有POSC(D)≠POSC-{a}(D),则x使得[x]CXk且[x]C-{a}Xk.于是y,y∈[x]C-{a}且y[x]C.有f(x,C-{a})=f(y,C-{a})且f(x,D)≠f(y,D).因此,删除属性a后,会产生冲突.下面要证明x在原来系统S中为非冲突对象.采用反证法证明.假设z,z,x∈[x]CXk且f(x,D)≠f(z,D).因此,x,z属于U/D的不同等价类,此与z,x∈[x]CXk相矛盾.所以,x在原来系统S中没有与之相冲突的对象.因此删除a后,新增加了冲突对象,也就是|ConSet(C-{a})|>|ConSet(C)|,即a∈GCore(C).故Core(C)GCore(C).由(1)(2)得Core(C)=GCore(C).证毕.由定理5,给出一个快速求核算法.算法4.快速求核算法.输入:决策表S=(U,A,V,f),其中A=C∪D且C∩输出:决策表的核Core(C)1.Core(C)=,ConSet(C)=;2.根据算法2,求得ConSet(C);3.fori=1to|C|do3.1.{根据算法2,求得ConSet(C-{ai});3.2.if(|ConSet(C-{ai})|>|ConSet(C)|)4.输出Core(C).算法4中,步2的时间复杂度为O(|C||U|).步3.1的时间复杂度为O(|C||U|),步3循环次数为|C|次,则步3的时间复杂度为O(|C|2|U|).因此,算法4的时间复杂度为O(|C||U|)+O(|C|2|U|)=O(|C|2|U|),空间复杂度为O(|U|).5.2属性重要性定义9.在决策表S=(U,C∪D,V,f)中,C为条件属性,D为决策属性,RC,a∈C-R,U=U-POSR(D),则POSa(D)定义为POSa(D)=∪{Z|Z∈U/{a}∧ZU/D}.定义10[12].在决策表S=(U,C∪D,V,f)中,C为条件属性,D为决策属性,RC,a∈C-R,则属性a的重要性SGF(a,R,D)定义为SGF(a,R,D)=γR∪{a}-γR.其中,γR=|POSR(D)|/|U|.定义11.在决策表S=(U,C∪D,V,f)中,C为条件属性,D为决策属性,RC,a∈C-R,则属性a的重要性Sig(a,R,D)定义为Sig(a,R,D)=|ConSet(R)|-|ConSet(R∪{a})|.定理6.在决策表S=(U,C∪D,V,f)中,≠RC,a∈C-R,SGF(a,R,D)与Sig(a,R,D)是等价的.证明.设U=U-POSR(D),则Page6=|POSR∪{a}(D)|/|U|-|POSR(D)|/|U|=(|POSR∪{a}(D)|-|POSR(D)|)/|U|=(|POSR(D)∪∪{Z|Z∈Y/{a}∧Y∈U/R∧ZU/D}|-|POSR(D)|)/|U|=|∪{Z|Z∈Y/{a}∧Y∈U/R∧ZU/D}|/|U|,Sig(a,R,D)=|ConSet(R)|-|ConSet(R∪{a})|=|U-POSR(D)|-|U-POSR∪{a}(D)|=|U-POSR(D)-(U-POSR∪{a}(D))|=|POSR∪{a}(D)-POSR(D)|=|POSR(D)∪∪{Z|Z∈Y/{a}∧Y∈U/R∧ZU/D}-POSR(D)|=|∪{Z|Z∈Y/{a}∧Y∈U/R∧ZU/D}|,可见,SGF(a,R,D)与Sig(a,R,D)是等价的.证毕.根据定理6,给出属性重要性的算法.算法5.属性重要性Sig(a,R,D)算法.输入:S=(U,C∪D,V,f)中,设PRC,ConSet(P)输出:Sig(a,R,D)算法5可以由算法3得到,在算法3中只需要令R-因为R-P={a},则算法5的时间复杂度为P={a},即可获得.算法略.SGF(a,R,D)=γR∪{a}-γRO(|U-POSP(D)|).5.3属性约简算法定理7.决策S=(U,C∪D,V,f)中,设RC,如果R是决策表S的约简当且仅当|ConSet(R)|=|ConSet(C)|.证明.只要证明|ConSet(R)|=|ConSet(C)|POSR(D)=POSC(D),即可.(1)必要性,即POSR(D)=POSC(D)|ConSet(R)|=|ConSet(C)|.POSC(D)=POSR(D),必有|POSR(D)|=|POSC(D)|,则|U-POSR(D)|=|U-POSC(D)|,即|ConSet(R)|=|ConSet(C)|.(2)充分性,即|ConSet(R)|=|ConSet(C)|POSR(D)=POSC(D).①由于RC,则有POSR(D)POSC(D).②假设,POSR(D)POSC(D)不成立,则POSR(D)POSC(D).则至少x0∈U,有x0∈POSC(D),但x0POSR(D).因此有x0∈U-POSR(D),但x0U-POSC(D),则|U-POSR(D)|≠|U-POSC(D)|.又因POSR(D)POSC(D),从而|POSR(D)|<|POSC(D)|,则|U-POSR(D)|>|U-POSC(D)|,即|ConSet(R)|>|ConSet(C)|,此与|ConSet(R)|=|ConSet(C)|相矛盾.故POSR(D)POSC(D).由①②得POSR(D)=POSC(D).由(1)(2)定理7得证.根据定理7,同时综合前面的算法,下面给出高效的属性约简算法.算法6.决策表属性约简算法.输入:决策S=(U,C∪D,V,f),U={xi|i=1…n},C=输出:约简属性集R1.根据算法4,求得ConSet(C)和核Core(C),令R=2.if(R=)thenConSet(R)=U;3.while(|ConSet(R)|≠|ConSet(C)|)3.1.{fori=1to|C-R|do3.2.选择最大Sig(ai,R,D)的ai;如果这样的ai有多3.3.R=R+{ai};3.4.更新ConSet(R);4.fori=1to|R-Core|do5.输出R.算法6中,步1的时间复杂度为O(|C|2|U|);步2最坏情况下的时间复杂度为O(|C||U|);步3.1的时间复杂度为O(|C-R||U-POSR(D)|),步3.2的时间复杂度为O(|U-POSR(D)|),步3.4的时间复杂度为O(1),步3内部循环体循环的次数最大为|C-R|次,则步3的时间复杂度为O(|C-R|2|U-POSP(D)|);步4最坏情况下时间复杂度为O(|C|2|U|).因此,算法6总的时间复杂度最坏情况下为O(|C|2|U|),空间复杂度为O(|U|).6实例和实验分析6.1实例分析表1为一个决策表,表中共有11个样本对象,其中{c1,c2,c3,c4,c5}为条件属性集C,D为决策属性.Page7Uc1c2c3c4c5Dx1001111x2001110x3011110x4011111x5110111x6110110x7010000x8011000x9100111x10110011x11101010分析决策表表1,可知x1和x2、x3和x4、x5和x6分别是冲突对象,因此该决策表为不相容决策表.由于ConSet(C)={{x1,x2},{x3,x4},{x5,x6}},|ConSet(C)|=6.分别计算ConSet(C-{c1})={{x1,x2},{x3,x4},{x5,x6}},|ConSet(C-{c1})|=6;ConSet(C-{c2})={{x1,x2,x3,x4},{x5,x6,x9}},|ConSet(C-{c2})|=7;ConSet(C-{c3})={{x1,x2},{x3,x4},{x5,x6}},|ConSet(C-{c3})|=6;ConSet(C-{c4})={{x1,x2},{x3,x4},{x5,x6,x10}},|ConSet(C-{c4})|=7;ConSet(C-{c5})={{x1,x2},{x3,x4},{x5,x6}},|ConSet(C-{c5})|=6.只有|ConSet(C-{c2})|>|ConSet(C)|和|ConSet(C-{c4})|>|ConSet(C)|,因此Core(C)={c2,c4},令R={c2,c4}.则ConSet(R)={{x1,x2,x9},{x3,x4,x5,x6},{x7,x8,x10}},|ConSet(R)|=10.接着,以核属性集为初始约简集R,以Sig(ai,R,D)为启发式信息选择属性进行约简(i=1,3,5),分别对c1,c3,c5采用算法3,在ConSet(R)基础上进一步表23个约简算法的比较执行时间/ms决策表|U||C||Core|最小约简DT1115233No1.755Yes0.093No0.08Patient908888No10.418No1.588No0.73Monks-14326333No16.564Yes2.973No1.32Vote43516799No70.9110Yes24.059No18.12Tic-Tac-Toe9589088No101.918No17.908No23.57Led17200022141818No912.3422Yes452.1318No226.86Poker2501010577No3143.327No902.277No760.57分析表2可以发现,算法C和算法B的执行时间要远低于算法A,并且随着数据集的增大,这种优计算,得ConSet(R∪{c1})={{x1,x2},{x3,x4},{x5,x6}},|ConSet(R∪{c1})|=6;ConSet(R∪{c3})={{x1,x2},{x3,x4},{x5,x6},|ConSet(R∪{c3})|=8;ConSet(R∪{c5})={{x1,x2,x9},{x3,x4,x5,x6}},|ConSet(R∪{c5})|=7;则Sig(c1,R,D)=|ConSet(R)|-|ConSet(R∪{c1})|=4,Sig(c3,R,D)=|ConSet(R)|-|ConSet(R∪{c3})|=2,Sig(c5,R,D)=|ConSet(R)|-|ConSet(R∪{c5})|=1.可见Sig(c1,R,D)的值最大,故选择属性c1加入R中,有R={c1,c2,c4},ConSet(R)={{x1,x2},{x3,x4},{x5,x6}};此时|ConSet(R)|=|ConSet(C)|.最后,对R中非核属性{c1}反向消除检查有|ConSet(C)|≠|ConSet(R-{c1})|,因此属性约简为R={c1,c2,c4}.如果采用文献[13]的方法得到约简属性集为{c1,c2,c3,c4,c5},可见该约简集中c2,c5为冗余属性.文献[13]的方法错误的原因是忽略了最重要的核属性,没有从核属性出发求解约简;并且,约简结束后没有对约简集中的非核属性进行反向消除冗余检查.6.2实验比较采用本文决策表1和UCI数据库中6个决策表为实验数据,对3个约简算法进行测试(实验环境为Petium42.8GHz,RAM512MB微机,VS.NET2005平台的VC++),结果如表2(刘少辉的属性约简算法记为算法A,文献[12]的属性约简算法记为算法B,本文的属性约简算法记为算法C;DT1表示本文决策表1;|Core|表示核属性的数目).约简中属性数越性更明显.对算法C和算法B的比较发现,算法C花费时Page8间要普遍低于算法B,并且随着数据集规模的增大,优越性也越明显.深入分析表2可以发现一个规律:当约简集与核属性集属性数目比值较大时,算法B的性能要优于算法C;当约简集与核属性集属性数目比值较小(<2)时,算法C的性能要明显好.出现这种结果的原因是:在算法C的最后阶段(即本文算法6中的步4)对非核属性进行了反向消除检查,增加了一些计算量所造成的.例如,数据集Patient和Monks-1的约简集和核属性集是相同的,按照本文的约简算法,当求出核属性集以后就等于约简算法完成了(也就是,算法6中步2完成后,整个约简算法就等于结束了),因此算法C的性能明显优于算法B.而在处理数据集Tic-Tac-Toe时,算法C花费的时间却大于算法B,这是因为:Tic-Tac-Toe数据集中核属性数目为0,约简集中8个属性均为非核属性,因此在算法C的最后阶段(即,算法6的步4)需要对约简集中所有属性进行反向消除检查,这必然要花费一些时间.如果算法B最后也加上消除冗余操作的话,在处理数据集Tic-Tac-Toe总的时间开销将增加到31.86ms,这个时间将大于算法C的23.57ms.另外,分析表中属性约简结果可以看出,算法C和算法A是完备的,并且获得的属性约简是最小约简.但算法B却不一定能保证约简的完备性,由表2可以看出,算法B在处理决策表DT1、Monks-1、Vote和Led17时,所求的约简中均存在冗余的属性.这是因为算法B没有从核属性着手进行约简求解,并且在获得约简后没有对非核属性进行冗余性检查.7结论属性约简是粗糙集理论一个重要研究内容.在属性约简中,等价类划分是一个关键步骤.本文首先研究了等价类的性质,利用分布计数的基数排序方法,对决策表排序,设计了对属性集C进行快速等价类划分算法,其时间复杂度为O(|C||U|).然后,给出冲突域的定义,讨论冲突域的性质,以冲突域中对象的个数的变化作为核属性和属性重要性判断的依据,并设计求核和属性重要性的算法.在上述基础上,设计属性约简算法,算法以核属性为初始约简集,不断将重要性大的属性加入约简集中,并对非核属性进行反向消除检查,以保证约简的完备性.该算法的时间复杂度为O(|C|2|U|),空间复杂度为O(|U|).实验结果表明该算法是正确的、高效的.
