Page1确定性并行技术周旭卢凯陈沉(国防科技大学计算机学院长沙410073)(国防科技大学并行与分布处理国家重点实验室长沙410073)摘要由于执行个体之间的同步、竞争和干扰,并行程序的执行存在着不确定性问题,即程序在相同输入下多次执行可能得到不同的结果.不确定性给并行程序在开发、调试、测试、容错和安全等方面都带来了挑战,严重降低了并行程序的可靠性,阻碍了并行程序的发展.确定性并行技术通过控制并行程序执行个体间的同步、竞争和干扰,使程序的执行结果仅依赖于输入.确定性并行技术能够从根本上解决了目前并行程序存在的诸多问题,提升了并行程序的可靠性,给并行程序的发展带来了新的机遇.文中调查、分析和比较了目前主流的确定性并行技术和方法,分析了弱内存一致性对确定性并行系统的影响,并对未来确定性并行技术的发展趋势做出了展望.关键词确定性;并行计算;可靠性;数据竞争1引言和传统的串行程序相比,并行程序在给计算性能带来提升的同时,也给程序的开发和维护带来了挑战.并行程序通常由多个并行执行个体(如线程)协同完成一个任务,因此执行个体之间就广泛存在着同步、竞争和干扰的问题,这就导致了并行程序的不确定性,即程序在相同的输入下多次执行,可能产生不同的执行路径和结果.这种不确定性给并行程序在许多方面(如开发、测试、维护、容错和安全等)都带来了新的挑战.目前,确定性并行技术被认为是应对这个挑战的关键核心技术[1-7].确定性并行技术要求程序在相同的输入下运行时总是能得到相同的执行流程和结果.确定性并行技术的基本思想是控制并行执行个体之间的同步、竞争和干扰,使执行个体之间按照一定的规则和顺序进行交互,从而确保每次执行都能复现这种规则和顺序,使程序即使在不同的环境中执行也能得到相同的结果.在确定性并行技术下,程序的执行结果仅依赖于输入和程序逻辑本身,因此排除了外界环境对于执行结果的影响.然而目前确定性并行技术的研究还不成熟,存在着诸多问题:例如纯软件实现的确定性并行系统效率普遍低下,可以达到2~10倍的性能开销,这使它们很难在实际应用中被接受[1-2];而硬件支持的确定性并行系统如今只有模拟结果,在实验室和工业界都不存在真实的硬件确定性系统[1,7].除此之外,确定性并行系统还存在着诸如移植性、稳定性、可扩展性等方面的问题.这些问题制约了确定性并行技术的实用化,亟需解决.本文分析了引起并行程序不确定性的原因,介绍了确定性并行技术的优势;对目前的确定性并行技术方法做了总结和归类,详细对比了几种主要的确定性并行技术方法,其中也包括我们自己实现的三个确定性算法;并针对弱内存一致性对确定性并行系统的影响做了深入分析.在此基础上,展望了未来确定性并行技术的发展趋势.2并行程序的不确定性并行主要有两种形式,一种是多线程并行,即各个并行执行个体之间共享内存空间;另一种是多进程并行,即各个执行个体之间不共享内存空间,而是通过其他方式(例如管道或者网络)进行通信.然而不管是何种并行形式,都存在着不确定性执行的问题.在本节中,我们将分析引起并行程序不确定性的主要因素及不确定性给程序带来的挑战.2.1不确定性因素在多线程并行中,导致程序不确定性的原因是线程对于共享内存的竞争访问.我们可以将其分为数据竞争和同步竞争两种形式.数据竞争是指并行执行的两个访存操作对同一个内存单元进行访问,它们的执行顺序没有被任何同步语句所限制,并且其中至少一个访存操作为写指令.同步竞争是指两个互斥同步语句同时访问一个同步变量,例如两个加锁操作(lock)同时在加一把锁(L).实际上同步竞争是一种特殊的数据竞争,是线程通过原子指令对同步变量的一种竞争访问.但是因为同步语句的特殊性,有必要将其单列出来.图1展示了数据竞争和同步竞争引起程序执行不确定性的两段代码.线程T1和线程T2同时进行存款和取款的操作,当两次执行的线程访存交织顺序不同时,代码的最终执行结果就会不同.图1(a)中的代码没有用锁保护,因此并行执行时会产生对共享变量x的数据竞争(T1:1和T2:2,T1:2和T2:1,T1:2和T2:2都会分别形成数据竞争).竞争的结果会导致变量x最终的值可能为9,10或者11.图1(b)中的代码虽然用锁保护了存款和取款操作的原子性,不会产生对变量x的竞争访问,然而两个线程对锁的竞争依然存在,因此不确定性仍然没有消除.如果线程T1先得到锁,就会使客户的存款量达到10以上,因此账户会自动升级为VIP账户.反之,如果线程T2先得到锁,线程T1再执行存款操作时存款量就只有10,因此最终此账户就不会升级为VIP账户.在多进程程序中,同样存在着进程间的交互,因此也可能引发不确定性.例如,MPI消息传递是一Page3种常见的多进程并行模型.进程通过调用消息发送和接收函数来进行交互.在MPI中存在着异步消息传递函数和混杂消息接收函数.异步消息传递函数并不能保证消息传递能够在确定的程序执行点完成,而混杂消息接收函数可以选择接收任意到达的消息,它们都能引起程序执行状态的不确定[8-9].非并行引起的不确定性.程序中还可能存在其他一些能够引起不确定性的操作,例如对随机数发生器rand函数的调用.这种不确定性是一种人为的不确定性,是程序逻辑本身所需要的,同时也是一种可控的不确定性.这种不确定性不是由并行所引起的,因此并不是并行程序所固有的,在串行程序中同样存在.由于这种不确定性并不增加程序的开发和维护难度,因此不属于确定性并行技术的研究范畴.2.2不确定性的挑战和安全等许多方面都带来了严峻的挑战.不确定性给并行程序的开发、维护、测试、容错不确定性对程序开发的挑战.并行程序的开发要比串行程序困难得多.因为线程之间的交织顺序是没有任何限定的,这导致程序员在编写并行程序时不但要考虑程序逻辑,更要注意线程之间所有可能的交织顺序,小心的使用同步语句保证程序并行执行的正确性.这就给普通程序员形成了很高的门槛,即便是熟练的程序员也难免出现各种错误.Lee[4]在其研究中指出,即使对于很小的一段并行算法,经验丰富的程序员也很难一次性写出正确的代码.不确定性对程序维护的挑战.调试是程序维护的重要方面.不确定性导致并行程序的bug不可复现,从而阻碍了调试的进行.传统的最直接的调试方法是:通过多次迭代式的运行程序,追踪bug信息,从而一步步逼近bug的根源.然而在并行程序中很多bug是依赖于特定的线程交织顺序的,这些bug因为只有在特定的线程交织顺序下才会出现,因此就具有很强的潜伏性.即便偶尔出现一次,也很难通过重新运行程序来重现bug,从而导致调试方法失效[1-3,5-6].不确定性对程序测试的挑战.由于不确定性的影响,并行程序在相同的输入下往往不能得到相同的输出.在并行程序测试时,即使观察到程序在某个输入下得到了正确的输出结果,也不能保证程序在生产环境中在同样的输入下一定能得到同样的结果.因此传统的通过输入对程序进行压力测试的方法在一定程度上会失效.不确定性使得程序的执行不仅依赖于输入的变化,而且还受线程调度等时间相关因素的影响.因此要得到可信的测试结果,就必须对并行程序的交织顺序也进行覆盖.然而线程的交织顺序是不受限制的,这就极大的增加了程序的测试空间,给程序测试带来了挑战[1,5,10].不确定性对程序容错的挑战.副本容错是一种常用的容错技术,主要使用在一些对可靠性要求很高的领域,经常用来容硬件产生的偶发错.副本容错一般要求同时运行一个程序的多个实例(称为副本),所有运行副本给定同样的输入.在这种情况下即便个别硬件产生了偶发错,只要正常的硬件达到一定的数量,运行在这些硬件上的副本就能得到正确并且一致的输出结果,因此最终我们依然可以得到正确的执行结果.然而不确定性却破坏了副本容错技术在并行程序中的应用.由于不确定性的影响,即使硬件没有产生偶发错,软件仍然有可能产生不一致的输出结果,导致我们不能判断出正确的运行结果[1-3].不确定性对程序安全的挑战.数据竞争和不确定性导致并行程序面临着一种新的安全漏洞,即并发漏洞[11-13].不同于以往由于输入引起的漏洞,并发漏洞是由特定的线程交织顺序所触发的,不确定性使得这种漏洞具有极强的隐蔽性和不可复现性,从而对漏洞检测和入侵检测等安全领域造成了严峻的挑战.首先,不确定性导致这些安全漏洞很难被现有的漏洞检测工具所发现.其次,漏洞一旦被利用使系统遭到攻击,系统管理员也很难追踪和分析入侵代码行为,不利于漏洞的及时修复.3确定性并行技术确定性并行技术的目标是消除由于并行引起的不确定性,降低并行程序的开发和维护成本,提高并行程序的可靠性,为并行程序的持续发展提供技术支撑.3.1相关技术与确定性并行技术比较相关的两种技术领域是记录-回放技术和数据竞争检测技术.这三种技术的核心都是发现并控制程序中的数据竞争,但是目标和侧重各有不同.数据竞争检测技术侧重于发现程序中的数据竞争;而其他两种技术则侧重于动态地消除数据竞争所引起的不确定性.数据竞争检测技术通过静态分析或者动态执行Page4的方式发现可能产生数据竞争的代码位置并报告给程序员,由程序员手动修复数据竞争[14-19].最新的研究还包括了利用数据竞争检测结果自动修复并行错误的技术[20-21].记录-回放技术通过复现数据竞争等不确定性事件来实现确定性执行.记录-回放技术分为两步:首先针对程序在某一输入下的执行进行记录,记录的内容包括所有程序执行中的不确定性事件,主要是数据竞争的顺序;然后在回放阶段根据所记录的日志重放程序的执行,从而确保程序在回放阶段的行为和记录阶段完全一致[9,22-26].与其他两种技术相比,确定性并行技术的功能更为强大,应用更为广泛.确定性并行技术的优势主要体现在以下几个方面.首先,确定性并行技术支持任意输入下程序的自动确定性执行,应用领域更为广泛.数据竞争检测技术能够检测和自动消除部分数据竞争,却不能实现确定性.这是因为同步竞争也能引起不确定性,图1的例子可以证实这一点.对并行错误的研究同样表明,数据竞争只是引起并行错误的一种主要形式,而不是唯一的形式[27-28].在这种情况下,实现程序的确定性就具有更重要的意义,它可以应用于程序开发、测试和调试等多种领域.记录-回放技术虽然也能实现确定性,但是只能保证程序在特定输入下的确定性,前提是已经记录了程序在该输入下的执行过程.因此,虽然记录-回放技术对程序调试的意义明显,但是却很难应用于开发和测试等领域.其次,确定性并行技术无需外部日志的支持,使用方便.确定性并行技术实现的是程序内在的确定性,无需外部日志的支持,可以简化系统的部署和使用.与此不同的是,记录-回放技术依赖于外部日志,因此日志和程序必须同时存在才能保证确定性.而维护日志还会产生额外的时间和空间开销,对于某些系统来说,这种日志开销十分显著[25-26,29].最后,确定性并行技术能够实现首次确定性,即程序在第一次运行时就能保持确定性.而记录-回放技术的首次运行即记录阶段的执行是不确定执行.首次确定性使得确定性并行技术可以解决并行程序在测试和容错等应用领域的困难[10].然而,确定性并行技术的优势并非说它可以完全代替其他两种技术.事实上,确定性并行技术和其他两种技术的结合会产生更好的效果.例如,利用数据竞争检测技术首先发现程序中的数据竞争,从而减少记录-回放技术或者确定性并行技术的运行时开销[30].3.2技术分类根据实现层次和手段的不同,本文将确定性并行技术分为确定性编程语言、确定性运行时系统、确定性操作系统、确定性编程模型和确定性算法.例如Jade、StreamIt和SHIM属于支持确定性的并行编程语言;Dthreads是一种完全兼容POSIXpthreads的确定性多线程运行时库[6];Determinitor和dOS则属于支持确定性的操作系统[5,31];Grace是一种面向确定性的并行编程模型[32],Blelloch等人[33]则提出了利用基本的可交换操作构建确定性并行算法的理论.确定性并行按照其他标准也有不同的分类方法,例如按照所支持并行级别的不同可以分为线程级确定性系统和进程级确定性系统,按照是否有硬件支持的标准可以分为纯软件确定性系统和硬件支持的确定性系统.而按照实现层次分类的方法最能体现确定性并行系统在技术上的差别,因此本文采用了这种分类法.在所有的这些确定性技术中,确定性运行时系统在灵活性、移植性、兼容性、通用性等方面都具有优势,是确定性并行领域最重要的一个研究分支.确定性运行时系统是指以编译器加运行时库的方式实现的确定性并行系统.确定性运行时系统简单易用,只需要将原来的并行程序重新编译和链接(个别系统只需要重新链接)即可,可以较好地兼容现有并行程序.确定性运行时系统部署在操作系统和应用程序之间,因此又具有较好的移植性.目前确定性运行时系统是确定性并行系统的主流实现方式.3.3技术对比本节从性能、确定性、可扩展性、兼容性、稳定性和可移植性等方面对现有的主流确定性技术进行对比.注意,这里的稳定性是指系统抵御代码或者输入的微小变化对确定性扰动的能力[34-35].为了能够直观的比较各种确定性技术,我们采取了量化评分的方式.首先我们假设存在理想的确定性系统,它必须在性能和可扩展性方面接近非确定性并行实现(例如接近pthreads库的性能);在确定性方面必须能够实现执行流程和结果的完全一致;在兼容性方面,必须能够保证在不修改程序代码的情况下完全兼容现有并行程序;在稳定性方面,其确定性不受代码或者输入微小扰动的影响;在可移植性方面,必须能够保证确定性在各种硬件平台和操作系统之间能够方便地移植.我们以理想的确定性系统为基准,对上述每个指标进行量化评分(评分数值为离散的1,2,3).如Page5果确定性系统在某个指标上达到或接近理想确定性系统的标准,则其在这个指标上的量化评分为3分.如果确定性系统在某个指标上完全没有达到要求,则其量化评分为1分.而如果确定性系统在某个指标上部分达到了要求,其量化评分就为2分.在这个表1主流确定性并行系统的分类和量化比较确定性系统DMPKendoCoreDetRCDCDthreads运行时系统dOSClavinDeterminitor操作系统TernPeregrine运行时系统DDOSFPDetDMPIRFDetpthreads运行时系统注意,表1的主要作用是对比各种确定性系统,方便发现系统的问题,其中的量化评分并不具有绝对意义.随着技术的改进,一个原本接近理想标准的系统也可能变为完全没有达到理想标准.因此,这些评分只有在当前技术条件下比较同类型的确定性系统时才有意义.另外,如无特殊说明,表中的性能评分都是针对算法的软件实现,例如DMP算法就存在软件和硬件两种实现方式.而Calvin系统只有硬件实现方式,因此表1中只有它的性能评分是针对硬件实现.表1中带星号的数据表示确定性系统在某个指标上达到该评分时受某些非关键因素影响.例如Kendo的可移植性受硬件性能计数器的影响;而CoreDet和RCDC的兼容性可能会受到弱内存一致性的影响;Cavlin由于采用硬件实现,一般只能保证整个系统的确定性,而人们一般更加关注单个程序的确定性;Tern和Peregrine的可移植性受所记录的线程调度的影响,如果新平台缺乏原先记录的线程调用,将不能够按照原来的确定性运行程序.从以上对比可以看出,目前确定性系统或多或少都存在一些问题,尤其是在性能方面.对于通用确定性系统来说,目前还不存在真实的硬件实现,纯软件实现的方法性能开销又非常大.此外,确定性并行技术的研究对于进程级并行的支持还不够.针对这些问题,我们基于现有工作对确定性技术做了一些标准上,我们根据文献中报告的数据对现有的主流确定性系统进行了评分,结果如表1所示.其中pthreads为标准的POSIX线程库,它除了不具有确定性之外,其他方面都是线程级确定性并行系统的理想标准.确定性性能可扩展性兼容性稳定性可移植性311313232323312313312313322233333311332131222333322333311313232323332223133333研究和优化,表1中加粗的三项是我们的研究成果.从整体上讲,目前确定性并行技术离实用化还存在差距,需要做更加深入的研究.4确定性技术分析本节我们通过介绍几种主流的确定性并行方法,深入讨论确定性并行技术的实现细节,分析这些技术的特点和不足,在此基础上分析弱内存一致性对确定性技术的影响.4.1轮转法Devietti等人最早提出了一种轮转法来实现通用多线程程序的确定性,称之为DMP[1]算法(DeterministicMultiprocessing).DMP算法按照执行指令数将程序执行分成“轮”,每一轮每个线程只允许执行一定数量的指令,指令执行完则该轮结束.一轮执行又可以分为并行阶段和串行阶段,在每一轮开始时,程序首先进入并行阶段.这时只要线程之间的访存不发生冲突,就可以一直执行到该轮结束;一旦检测到线程的访存与其他线程发生冲突,则强制线程暂停执行,等待进入串行阶段解决访存冲突.当所有线程都因为发生访存冲突或者执行完该轮的指令数而暂停时,程序就会进入串行执行阶段.在串行阶段线程根据ID号的顺序依次轮流执行.由于并行阶段不存在访存冲突,而串行阶段线程按照确定Page6的顺序执行,于是就以确定的方式解决了原本的访存冲突,消除了不确定性.为了检测访存冲突,DMP将程序内存以“块”为粒度进行划分,每一块设置一个拥有权标志位,标记当前拥有该内存块的线程.在每一轮的并行执行中,线程只能根据内存块的拥有权标记来访问内存:当线程拥有内存块时,该线程就可以对该内存块进行读写访问,其他线程不能对该内存块进行读写操作;当内存块不被任何线程拥有时(内存块的状态为共享态),任何线程可以对该内存块进行读操作,而不能写.内存块的状态在并行阶段中不会发生改变,直到程序进入串行阶段.进入串行阶段后,由于每次只有一个线程对内存进行独占访问,当前执行的线程就可以访问任何内存块,同时根据访存指令修改内存块的状态:当线程写内存块时,内存块变为独占状态,并归该线程拥有,以方便后续该线程对于内存块的读写;当线程读内存块时,内存块的状态变为共享态,以方便其他线程后续对该内存块的读.DMP算法虽然能够保证确定性,但是其串行执行的方法却损失了并行度.一种极端的情况是线程因为一条访存冲突指令进入串行阶段,但是串行阶段执行的其他指令都不发生访存冲突.因此,纯软件的DMP实现有2~10倍的开销.针对这一点我们对DMP算法进行了改进,实现了全并行的确定性多线程算法FPDet[35].FPDet仍采用轮转法执行多线程程序,但是和DMP算法不同,当发生访存冲突时FPDet算法并不强制程序进入串行阶段,而是通过在线程之间交换内存块的拥有权来解决访存冲突,从而使没有发生访存冲突的指令可以尽可能的并行执行.这种方法在一定程度上提升了DMP算法的性能,但性能开销仍然有2~8倍[1,6].DMP算法和FPDet算法都实现了强确定性和顺序一致性.顺序一致性使它们能够很好地兼容已有程序,运行时系统的实现方式使其具有可移植性.然而,由于需要监控每条访存指令,这两种算法的性能和可扩展性都比较差.DMP和FPDet算法都需要静态配置两个基本的参数:即轮长度R和内存块大小B.轮长度以指令数为计量单位,程序执行R条指令为一轮.由于这两个静态配置参数的影响,这两种算法都不具有稳定性.当程序的指令数发生微小变化时,例如程序员插入一条printf函数调用,就会导致printf调用之后每一轮的指令位置发生变化,造成程序执行结果的巨大变化.同理,由于内存块大小的配置参数,在输入发生微小变化时同样会导致执行结果的巨大变化.因此,静态配置的轮长度和数据块大小等参数使它们实现的确定性很难抵御代码或者输入的微小改变所带来的扰动,因此不具有稳定性.另外,这两个算法的实现复杂度较低,而软件实现方法对访存指令的插桩相对于算法本身开销较大,因此从性能和算法复杂度上考虑这两种算法更适合于硬件实现.4.2弱确定性算法经典轮转法的性能问题很大程度上是由处理数据竞争引起的.Olszewski等人[3]从另一个角度出发,假设程序中不存在数据竞争,于是提出了弱确定性的概念.所谓弱确定性是指系统只保证程序同步语句的执行顺序是具有确定性的.为了实现弱确定性,Olszewski等人设计了Kendo算法.算法的思想是利用逻辑时钟来对线程的加锁机会排序,由于逻辑时钟的快慢仅依赖于程序代码执行的数量,因此能够保证程序加锁顺序是确定的,而这等价于程序同步语句的执行顺序是确定的.Kendo算法的关键问题是弱确定性的基本假设在实际情况中很难成立.由于各种原因(程序员的疏忽等),绝大多数多线程程序都存在数据竞争,对于这些程序,Kendo算法不能直接保证其确定性,而是必须要求程序员首先对所有的数据竞争代码进行加锁,将数据竞争转换为同步竞争,这样才能保证确定性.然而精确的定位和消除程序中的数据竞争本身就是一件非常困难的事情,现有的数据竞争检测工具无法完全解决误报和漏报的问题[36-37].Kendo通过牺牲一部分确定性来换取性能的提升.实验显示,它的性能开销只有不到16%[3].Kendo算法之所以能够提升性能,主要是因为在弱确定性的需求下系统无需控制每条访存指令,而只需处理同步语句即可.由于同步语句的数量相对于普通访存指令的数量要少很多,因此会极大地降低开销.除此之外,Kendo算法不改变原有程序的内存一致性模型,因此能够很好地兼容已有程序.Kendo算法的可扩展性受限于线程对逻辑时钟的等待,即每次同步操作都要等待线程的逻辑时钟变为最小,任何线程的延迟都会导致等待时间的加长,在线程数增加时这种等待开销会急剧增加.利用硬件性能计数器来实现逻辑时钟使得Kendo算法的稳定性和移植性都受到一定的影响[38].类似实现弱确定性的系统还包括Tern.由于Tern系统的特点是实现了稳定性,因此我们将在4.6节重点介绍.4.3弱化内存一致性为了解决确定性技术的性能问题,学术界提出了Page7通过弱化内存一致性来提升并行度的方法.Bergan等人在DMP算法的基础上做了进一步改进,实现了CoreDet[2]和RCDC[39]确定性系统.CoreDet系统首次使用了TotalStoreOrder(TSO)弱内存一致性模型来优化确定性系统的性能.CoreDet使用和DMP同样的方法将程序执行分轮,每一轮执行一定数量的指令.不同的是,在每一轮中每个线程都工作在共享内存的本地副本中.确切地说,当一个线程需要写一块共享内存时,系统首先为该线程创建这个内存块的本地副本,然后将内容写到本地副本中.随后该线程对于这块内存的读写都在本地副本中进行.如果线程只对内存进行读操作就不需要创建本地副本,直接在共享内存中进行.CoreDet在每一轮结束时会将本地副本中的内存修改合并到共享内存中,然后清除本地副本.由于本地副本的机制,线程之间就不会存在R/W和W/R冲突.而所有的W/W型访存冲突都被集中在每一轮结束时的内存修改合并阶段.在这个阶段,各个线程依次按照ID号顺序合并内存修改,因此也可以保证确定性.在CoreDet系统中,由于使用了TSO弱内存一致性模型,原本需要在串行阶段执行的冲突代码可以在并行阶段执行.因此就提升了系统的并行度,对系统可扩展性的提升有着重要的作用.需要注意的是,在CoreDet系统中,每轮的结束阶段仍然有一小段串行执行,这是为了执行原子指令.原子指令由于其特殊性,必须直接在共享内存上执行.因此,在遇到原子指令时,线程需要提前结束本轮执行,等所有线程提交了本轮的内存修改之后,按线程号顺序依次执行剩余部分的指令.RCDC在CoreDet的基础之上进一步弱化了内存一致性.RCDC使用的内存一致性模型为DRF(DataRaceFree)放松一致性模型[39].在CoreDet系统中,所有的原子指令是不能并行执行的.而RCDC观察到,有些原子指令是可以并行执行的.例如两个线程分别执行lockL1和lockL2,由于所加的锁不同,因此可以并行执行而不会引起不确定性.RCDC通过追踪由于线程同步所形成的happens-before关系,对于不存在happens-before关系的加锁操作可以在不影响确定性的情况下令其并行执行.CoreDet和RCDC算法通过弱化内存一致性来提升并行度,其优点是具有强确定性、较好的可扩展性和较好的可移植性.但是弱化内存一致性可能导致兼容性问题.如果原本程序的正确性是建立在顺序一致性的基础上,那么弱化内存一致性将可能导致程序不能正确运行.在性能方面,由于没有改变轮转法使用编译插桩的实现方式,这两种方法的性能几乎没有提升,仍然有2~8倍的性能开销[2].同时这两个系统采用了和DMP算法同样的指令分轮和内存分块方法,因此稳定性也没有改善[34].Calvin[7]同样采用了TSO弱内存一致性,从算法上来讲和CoreDet算法一致,但是完全基于硬件实现.因此其确定性、性能、可扩展性都比较好.由于需要特殊的硬件支持,因此它存在比较严重的兼容性问题,即不能兼容已有的二进制程序;另一方面,如果有编译器的支持,Calvin系统可以兼容具有源码的程序.Calvin系统的不足是稳定性(仍然由轮长度等参数引起)和可移植性较差,在没有商用硬件的情况下这种可移植性问题尤为严重.4.4隔离通信法Liu等人[6]通过完全隔离线程通信的方法开发了Dthreads确定性系统.Dthreads突破了纯软件确定性系统实现手段的瓶颈,通过完全隔离线程的内存空间,有效化解了CoreDet系统的编译插桩开销,并成为一段时间内最高效的纯软件确定性系统[6].与CoreDet等系统采用编译插桩控制访存冲突不同的是,Dthreads采用了页面保护机制来隔离线程内存空间,从而消除访存冲突.首先,Dthreads将多线程程序的线程全部转换为轻量级进程,这样每个线程就可以拥有独立的页表,从而实现对共享内存不同的访问权限.其次,Dthreads在线程首次修改共享内存时做Copy-on-Write,为每个线程生成共享内存的本地副本,从而避免直接的访存冲突.这些副本以页面为单位组织,称为双胞胎页面(Twin-Page).在每次需要将本地内存修改提交到共享内存时,通过逐字节比较原始页面和双胞胎页面就可以获得线程的内存修改.Dthreads所采用的这种控制访存冲突的方法取得了明显的性能提升,主要原因是它消除了对读写指令的编译插桩开销.需要注意的是,与CoreDet等轮转法系统不同的是,Dthreads每轮的长度不是由执行指令数决定的.Dthreads规定,线程在遇到任何一条同步指令时结束当前轮的执行.这样做主要是因为Dthreads要和POSIXpthreads的使用接口完全兼容,因此抛弃了编译插桩的方法.这样Dthreads就只需要重新实现pthreads库函数,而应用程序仅需要重新链接Dthreads库来获取确定性.显然,这种实现方式的劣势是可能造成线程之间在每轮执行中的负载不均Page8衡.例如,如果两个线程在进入下一个同步语句前执行的指令数差别很大,就会造成其中一个线程等待时间过长.对于那些具有典型不规则同步的程序来说,Dthreads可能造成较大的性能开销.Dthreads系统极大地提升了纯软件确定性系统的性能,使得平均性能开销不超过2倍,但是某些程序开销仍然可达8倍[40].Dthreads系统能够提升性能的主要原因有两方面:首先,它采用页面保护机制来隔离线程之间的访存冲突,避免了CoreDet等软件算法的插桩开销;其次,它的指令分块粒度较大,极大地减少了线程间的全局同步次数,降低了同步开销.Dthreads同时具有强确定性、稳定性和较好的可移植性.Dthreads系统的可扩展性受限于全局同步所引起的负载均衡问题.同时,由于使用了TSO弱内存一致性模型,并且内存一致性较Core-Det更弱,因此导致了更为严重的兼容性问题,例如它明确不支持Adhoc同步方式[6].4.5全局同步问题以上介绍的强确定性系统存在一个共同的问题:那就是依赖于全局同步来实现确定性.全局同步是指由确定性系统插入到程序执行中的一种额外的同步点,它要求所有线程在这个同步点中暂停执行,以方便系统处理不确定性.全局同步使确定性的实现变得简单,但同时也带来了性能和正确性方面的问题.全局同步问题根源在于它并非程序固有的同步策略,而是由确定性系统引入的额外的同步策略.因此全局同步是没有任何程序语义的,它的存在仅仅是为了实现确定性,和线程之间的通信需求毫无关系.当线程本身的同步策略和确定性系统所引入的全局同步产生冲突时,就有可能产生正确性和性能方面的问题.为了消除全局同步,我们提出了一种DLRC弱内存一致性模型,并在此基础上实现了一种免全局同步的确定性并行算法RFDet[40].确定性算法的关键是限制数据竞争,在没有全局同步的情况下,我们必须保证能够通过程序本身的同步来限制数据竞争.而根据C++内存一致性模型,如果两个访存操作之间具有happens-before时序关系,后一个操作就必须能够看到前一个操作对内存的更新[41],这是保证C++程序正确性最基本的内存一致性.因此,为了限制数据竞争,我们就将内存一致性弱化到这个程度,并且保证任何指令仅能够看到和它具有happens-before时序关系并且发生在它之前的指令对内存的修改,这就是我们提出的DLRC内存一致性模型.根据这个模型,我们就可以阻止所有通过共享内存访问形成的线程间通信,将这些通信全部延迟到线程同步的时候.这样一来,我们就将原本程序中的数据竞争都限制在线程同步点上,从而可以在不引入任何额外同步的前提下处理数据竞争.DLRC内存一致性模型的效果是数据竞争的结果仅依赖于同步竞争的结果,因此程序的确定性仅和同步语句的执行顺序相关.在DLRC内存一致性模型的基础上,我们通过Kendo算法保证同步语句执行顺序的确定性,于是实现了一个高效、免全局同步的确定性系统RFDet.实验显示RFDet的性能比同样是纯软件实现但使用了全局同步的Dthreads性能提升了近1倍.和Dthreads系统相比,RFDet系统最大的特点是消除了全局同步.对于具有不规则同步的程序来说,Dthreads方法的全局同步会引起线程之间的负载不均衡,严重的还会导致死锁,而RFDet算法由于完全基于线程原有同步实现确定性,因此更能发挥程序细粒度的并行,从而取得更好的性能.RFDet系统实现了强确定性,平均性能开销不到50%[40].此外纯软件运行时系统的实现方式使其具有可移植性.不足之处是RFDet系统增加了很多写操作,一定程度上影响了可扩展性.其抗代码扰动的能力,即稳定性,受限于Kendo算法中逻辑时钟受代码微小变化的影响.同样,因为采用了弱内存一致性模型,RFDet不支持Adhoc同步方式,降低了兼容性.4.6稳定确定性DMP等基于轮转法的确定性系统存在一个问题,即不具有稳定性.对于传统的并行执行模型(如pthreads)来说,当输入发生微小变化时,只要不是关键数据的改变,程序一般都会走类似的执行路径,偏差不会太大.但是由于确定性系统的干扰,程序的稳定性可能会被破坏,即当程序的输入发生微小变化时,程序执行路径的变化可能会被放大,造成执行结果的显著变化[42-43].也就是说确定性系统在保证确定性的同时,可能将程序的计算过程变成一个混沌系统.Yang等人提出了稳定确定性的概念,并通过Tern算法解决了稳定性的问题[34].Tern算法会首先对程序执行进行记忆,并以〈输入,调度〉二元组的形式存储在数据库中.在以后的执行中,系统会首先在数据库中依据输入条件匹配调度二元组.注意二元组中的输入是一个输入条件,只要符合这个输入条件就会匹配上,因此实际上代表了一组输入.一旦匹配上,系统就会使用相应的调度去执行程序.否Page9则,系统以正常的方式执行程序,记录其执行路径和输入条件,并将其存放到数据库中.由于Tern不支持数据竞争(类似于Kendo),Peregrine算法[44]在Tern算法的基础上做了进一步改进,使其可以支持数据竞争.Bergan等人[43]进一步将调度精确化简,保证能够覆盖到所有的输入集合.稳定性是多线程程序应该具备的一个重要特性[42],然而由于确定性系统强加的调度限制,程序的稳定性被破坏了.Yang等人所提出的稳定确定性方法从一定程度上解决了这个问题,但是他们设计的系统复杂度太高,部署和使用不方便,其致命的问题是输入不能匹配调度数据库的情况,这对于商用软件来说是不可接受的.因此未来有必要对确定性系统的稳定性做进一步研究.Tern和Peregrine两个系统最大的优点是具有好的稳定性.这两种方法不改变原有多线程程序的调度方式,而是从原有多线程程序的调度集合中选择其中的一部分作为自己的调度集合.由于在一定程序上缩小了调度集合,因此这种方法具有较好的稳定性.其次这两个系统采用纯软件的方法实现,不改变程序原有的内存一致性模型,因此也具有较好的兼容性和可移植性.在性能方面,两个系统在输入不匹配时性能开销不可容忍,可以达到上百倍[34,43-44].由于需要强制线程按照特定的调度执行,可扩展性并不能达到理想标准.另外,Tern系统不解决数据竞争问题,因此仅实现了弱确定性.4.7确定性多进程目前大多数确定性并行方法都是针对单个多线程程序,然而多进程程序的确定性也不容忽视.很多程序都会采用多进程的并行方式来提升安全性,例如Apache服务器和Chrome浏览器.Bergan等人[31]设计了dOS宣布支持多进程程序的确定性.dOS是对Linux操作系统的一种扩展,它可以保证Linux系统上一组进程的确定性.每一个确定性的进程组被称为一个DPG(DeterministicProcessGroup).由于有来自于操作系统内核的支持,dOS可以控制进程间通信,同时屏蔽了来自于操作系统内部状态变化对应用程序的影响.进程内部由于线程竞争引起的不确定性使用DMP算法解决.进程组与外部其他进程或者进程组的通信接口通过SHIM层实现,这个SHIM层负责记录外部进程与进程组交互时产生的不确定性事件.这样就可以通过记录-回放技术重现进程组执行.最近,Bergan等人又将dOS扩展,实现了可以支持分布式环境的确定性系统DDOS[45].这些确定性操作系统功能强大,但因为实现在操作系统级别,因此移植性较差,部署和使用极不方便.同时,dOS和DDOS的开销问题非常严重[31,45],这是因为一方面它们采用了开销较大的DMP算法,另一方面,它们并没有采用一层抽象级别来屏蔽底层细节,因此需要处理进程之间的各种交互操作,带来较大的开销.Determinitor也是一个支持确定性的操作系统,它采用了新的编程模型.在这种编程模型下,线程之间只能通过特定的系统调用进行交互,使线程在正常执行时不会发生访存冲突,因此其性能较好.该系统另一个优点是程序本身已经定义了所有访存操作的顺序,不需要外部运行时系统的干预,因此程序的稳定性好.然而新型的编程模型导致在该系统下编程方式的改变,从而造成系统完全不兼容现有的多线程程序[5].与这些直接支持确定性多进程的方法不同,我们通过在MPI编程模型上实现确定性消息传递技术(DMPI)来支持多进程的确定性[8].DMPI利用逻辑时钟控制消息的发送和接受,强制异步消息传递操作在确定数量个逻辑时钟之后完成消息传输,同时强制混杂消息接收函数只接收具有最小逻辑时钟的消息,最终消除了这两个不确定性操作对应用程序状态的影响.DMPI系统的性能开销主要来自于两个方面,一是实现逻辑时钟所产生的插桩开销,二是消息传递操作额外的等待开销.由于插桩粒度较大,并且消息传递操作相对于普通指令执行数量很少,因此DMPI系统的总体性能开销并不大,平均性能开销仅有14%.同时MPI是介于操作系统和应用程序之间的运行时系统,对于现有的MPI程序具有很好的兼容性和可移植性.DMPI的可扩展性和稳定性都受限于系统对逻辑时钟的依赖,这是因为逻辑时钟比较会牵扯到所有系统中的进程,具有全局同步的特性.而逻辑时钟计数结果会受到指令数微小改变的影响.最后,DMPI没有实现强确定性,它不支持MPI中一些不常用的非确定性操作,如单边通信.MPI是一种通用的编程模型,其应用十分广泛,因此对MPI的确定性支持具有重要的应用价值.4.8内存一致性和确定性在共享内存的多核体系结构中,内存一致性定义了内存修改可见性的延迟程度.Lamport最早给出了顺序一致性的定义:并行程序的执行结果等价于某种串行执行方式的结果,并且对于每个执行单Page10位(线程)来说,其执行指令的顺序和串行等价执行中这些指令的顺序完全一致[46].如果用内存修改的可见性来解释,顺序一致性等价于线程对内存的修改会对所有其他线程立即可见.顺序一致性是最直接的一种内存一致性模型,也是程序员最容易接受的内存一致性模型.然而顺序一致性要求每个访存指令都必须等待前一个访存指令到达主存后才能开始,因此其性能较低.为了优化访存性能,现代体系结构一般通过弱化顺序一致性来提升性能.常用的内存一致性模型包括TSO(TotalStoreOrder)、PSO(PartialStoreOrder)、RC(ReleaseConsistency)和LRC(LazyReleaseConsistency)等.弱内存一致性通过延迟线程写操作对其他线程的可见性来提升性能.在TSO模型中,本地CPU核所写入的值存放在一个写缓冲区中,写缓冲区中的值对远端CPU核是不可见的,只有当写缓冲区满或者程序执行了fence指令后写缓冲区中的值才会被写入到主存中,这时其他CPU核才可以看到这些值.内存一致性对确定性技术有着重要影响.首先,弱内存一致性能够有效地减少线程间的访存冲突,而确定性系统的开销主要来自于处理线程间的访存冲突,因此弱一致性可以降低确定性系统的开销.例如在顺序一致性模型下,一个线程的写操作W是立即可见的,因此就会和其他线程对于同一个内存位置的读R或者写W发生冲突,引起不确定性.正是因为这样,DMP等算法必须控制每一个访存操作,安排这些访存操作的执行顺序,避免不确定性的发生.然而同样的代码在TSO模型下就会有所不同,由于线程的写W并不是立即可见的,因此即便其他线程有对同一个内存的读R或者写W,它们之间也不会产生冲突.在CoreDet系统中,写操作被延迟到每轮执行的末尾才提交到主存,这样就只需在提交内存修改时安排所有写操作的顺序,因此会极大的提升并行度.理论上讲,内存一致性越弱,确定性并行系统需要安排的访存顺序就越少,就越容易获得较高的性能.然而这并不是绝对的,系统的性能还和具体的实现技术相关.除了性能,弱内存一致性还能改善确定性系统的稳定性.例如在Dthreads系统中,各个线程对内存的修改只有在线程同步时才会合并到共享内存,因此其确定性并不受输入和代码微小扰动的影响.弱内存一致性为确定性并行性能优化带来契机的同时也给可编程性和兼容性带来了困难.在多线程编程中,程序员最容易接受的是顺序一致性,程序员在编写程序时会自然认为对一个变量的修改会立即可见.如果确定性系统不能保证程序员的这种期望,就可能造成程序执行的错误.因此弱内存一致性一般都要求程序员增加额外的fence指令来强制内存修改必须在某一个点之后可见,这无疑会增加程序员的负担.另一方面,按照顺序一致性模型编写的程序一般不能在弱内存一致性的体系结构中正确执行,更进一步,支持较强内存一致性的程序一般不能在具有较弱内存一致性的体系结构中正确运行.这是因为程序中可能不存在合理的fence,因此产生了向后兼容的问题.和体系结构面临的问题一样,使用弱内存一致性的确定性并行系统也存在着这种兼容性和可编程性的问题.例如Dthreads的弱内存一致性模型就不支持Adhoc同步语句.即便是这样,弱内存一致性仍然是目前确定性并行技术的主流[47-49].这是因为性能和稳定性是影响确定性并行系统实用性的关键,而可编程性和兼容性可以通过其他方法来弥补.例如,可以设计新的编程模型,使程序员在编写多线程程序时并不直接考虑线程同步,这样就能屏蔽弱内存一致性的问题.另一方面,也可以利用一些自动化的工具来实现对传统代码的兼容.例如Liu等人[50]提出了一种自动根据弱内存一致性模型为程序加fence的方法,类似的方法也可以用在确定性系统中.弱内存一致性在确定性多线程的实现中占有重要地位.如图2所示,目前确定性并行技术已经探讨了SC、TSO等内存一致性模型.我们也在RFDet算法的实现中尝试了LRC内存一致性.初步结果显示,在LRC内存一致性模型下,确定性并行能取得更好的性能,但同时也会将系统的兼容性降低.其他的一些内存一致性模型如PSO还没有被任何确定性技术所使用.目前哪种弱内存一致性模型最适合确定性并行还不得而知,很有可能需要为确定性并行设计一种全新的内存一致性模型来同时解决性能和兼容性方面的问题,未来需要在这方面做深入探讨.Page115确定性并行发展趋势展望确定性并行技术作为一种并行程序的解决方案,上接应用程序,下接体系结构,因此它的发展同时受两方面因素的主导:一是体系结构的发展;二是应用程序的需求.目前异构和大规模并行是体系结构的两个重要发展趋势;而上层应用程序则要求尽可能的发挥体系结构的性能,同时方便用户编程.受这些因素的影响,目前确定性并行技术存在着向大规模并行、异构和新型编程模型等方向发展的趋势.5.1大规模并行支持受科学计算和云计算等应用的影响,并行计算正在向大规模并行和分布式并行等方面发展.针对这一趋势,确定性并行技术不能仅仅停留在支持多线程并行.在大规模并行计算领域中,由于程序并行度极高,更加容易出现问题,因此更加迫切需要确定性并行技术的支持.目前国际上已经开始研究面向分布式环境的确定性系统.然而由于并行度很大,这种系统的开销也会急速上升.例如,Bergan等人[45]实现的面向分布式系统的确定性并行系统DDOS的性能开销可高达20倍,远远不能满足实用需求.支持大规模并行程序的确定性技术能够应用于云计算和科学计算等领域,例如应用在天河超级计算机中[51],为大规模并行计算和云计算的可靠性提升提供技术支撑,是未来的一个发展趋势.5.2异构体系结构支持目前异构体系结构也是一个重要的发展趋势,因此确定性并行技术必须能够支持异构体系结构,否则将很难适应未来硬件的发展.目前Jooybar等人已经研究了GPU的确定性并行技术[52].然而,异构并非只有GPU一种形式,其实现层次也可以多元化.例如在通用的OpenCL语言级别上实现确定性,这样便于屏蔽底层硬件的差别,同时具有较好的移植性.另外,由于异构体系结构中各个执行单元之间的速率和指令集可能存在差别,因此也会给确定性并行技术带来新的挑战.5.3确定性编程模型目前大多数确定性系统都是对现有多线程模型的修补.由于多线程模型本身的限制,可能导致确定性系统在性能等方面的问题.因此有些研究者倾向于设计新的编程模型来从根本上改善确定性并行技术.我们在一些确定性系统中能看到新编程模型的影子,例如Determinitor系统[5],Grace[11]系统等.最近,Merrifield等人[53]又提出了利用版本控制模型来实现确定性的方法,取得了较好的实验效果.设计全新的编程模型能够有效地避开数据竞争的问题,同时能够让程序员专注于算法逻辑,具有很强的吸引力.因此,设计高效通用的确定性并行编程模型也是未来确定性并行技术的一个发展趋势.6结束语并行程序的执行具有不确定性,这给并行程序带来了严峻的挑战,已经成为影响并行程序可靠性的关键问题.确定性并行技术给我们带来了很多期待:通过保证并行程序在相同的输入下总是产生相同的输出,确定性并行技术能够同时解决并行程序在开发、测试、调试、容错和安全等方面的问题.然而目前确定性并行技术在很多方面,尤其是性能方面还难以满足实用性的需求.本文介绍了目前主流的一些确定性并行技术方法,包括我们自己实现的三个确定性算法,分析和对比了这些方法的优缺点,讨论了弱内存一致性对确定性并行技术的影响,并对未来确定性并行技术的发展趋势作出了展望.
