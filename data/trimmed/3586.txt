Page1基于组合阶双线性群的组签名方案周福才1)徐剑1),2)王兰兰2)陈晨2)李福祥2)1)(东北大学软件学院沈阳110819)2)(东北大学信息科学与工程学院沈阳110819)摘要利用Lewko等人于2010年提出的三素数组合阶双线性群理论,构建了一个基于BMW模型的高效组签名方案,并通过引进Groth-Sahai等人提出的非交互式零知识证明理论,解决了传统组签名方案通信效率低、不能抵抗选择密文攻击等问题.方案中签名的大小是一个常量而非依赖于其它系统参数.作者同时给出了严格的安全性证明,并将文中方案分别与已有的典型方案在效率和安全性方面进行了比较,结果表明该方案在这两方面均具有一定优势.关键词组签名;组合阶双线性群;非交互式零知识证明;BMW模型1引言1.1相关工作Chaum和VanHeyst[1]于1991年首次提出组签名方案,该方案允许组内成员代表整个组进行签名而不暴露签名者身份.由于组签名的特殊性质,很快引起各国学者的广泛关注.按照组签名安全性的证明方法,可以分为基于随机预言模型(ROM)和基于标准模型的组签名.基于ROM的安全性证明已经取得了很多成果,组签名方案[2-5]的安全性证明依赖于ROM,研究者通过利用ROM证明签名的不可Page2否认性、抗联合攻击等重要性质,从而证明组签名方案的安全性.Canetti等人[6]指出在ROM中理论上存在安全的签名和加密方案,但在实际使用ROM时需假设签名的明文是均匀随机的,实际上并不存在这样的明文,因此在实际应用中并不安全.也有其它研究者指出了ROM存在的缺陷[7-9].在后续的研究中,研究人员开始避免使用ROM,而逐渐向标准模型过渡.Bellare等人提出了第一个在标准模型下证明安全的组签名模型,称之为BMW模型[10],该模型给出了组签名的通用结构及其应该满足的安全性要求,并在组签名过程中引入非交互式零知识证明(NIZK)理论.该结构满足完全匿名性和完全可追踪性,组签名的其它性质可以从这两个基本性质中得到证明,而且签名密钥的长度是组内成员数量的对数,签名的大小是常量.文献[11-15]方案都是基于BMW模型构建的组签名方案,其中文献[11]方案由Boyen和Waters于2005年提出,其安全性证明依赖于标准模型,他们将分层签名机制和NIZK[16]相结合,其中安全的分层签名来源于组合阶双线性群中高效的基于身份的加密方案[17].但该组签名方案仅在选择明文攻击下是安全的,并不能抵抗选择密文攻击,而且所使用的群中元素个数依赖于签名者的数量.2007年Boyen等人改进了文献[11]方案的缺陷,并提出了新的组签名方案[12].该方案中,引进了Groth的NIZK理论[18],其效率和文献[11]方案相比有所提高.Libert等人于2009年使用Groth-Sahai证明系统的第3个实例———DLIN[19]构建了组签名方案[14],并给出不可连接性的证明,同时解决了组内成员的证书撤销机制,但由于非交互式证明系统的计算代价较大,所以不适合实际应用,也没有提供合理的追踪机制,导致其不能解决不可伪造性和不可否认性等问题.BMW模型的缺点之一是组成员不能动态加入,成员最大数量在初始化阶段就已经确定,而且真实的成员数量也是难以确定的,这一点影响了组签名在很多方面的应用(比如可信计算平台的匿名认证环境中).为了解决上述问题,Bellare等人于2005年将BMW模型扩展为BSZ模型[20],BSZ模型中增加了成员的“加入”阶段,并增强了安全性.但每增加一个阶段,就意味着增加交互次数,增加通信代价.方案[21-22]是基于BSZ模型构建的组签名方案,其中Ateniese和Camenisch等人提出的方案[21]是早期比较高效的方案之一,其中应用了BB+签名和CL+签名的重要性质.但他们所使用的安全性证明依赖于交互式假设,所以不能抵抗选择密文攻击.1.2本文工作2010年,Lewko等人在文献[23]中提出了三素数组合阶双线性群理论,并构建了一个HIBE加密方案,此方案被证明是完全安全的,而且能够解决在HIBE系统中不使用标签和密文压缩等问题.本文利用上述三素数组合阶双线性群及HIBE加密方案构建了一个基于BMW模型的高效组签名方案,满足BMW模型中定义的完全匿名性和完全可追踪性等安全性要求,除此之外,本文运用假设2、3证明了该组签名方案的不可伪造性.NIZK的重要特点之一是能够抵抗选择密文攻击,此外,非交互式证明中交互的单向性也是密码学协议的一个重要应用.Groth和Sahai在文献[24]中提出了强有力的非交互式证明系统,用于证明被承诺的变量所满足的特定关系.本文将NIZK的理论应用于组签名方案中,一方面解决选择密文攻击的问题,另一方面利用非交互式证明的交互单向性保证签名的安全性和通信的高效性.在文章的第5节,将通信代价和计算代价分别与同类文章进行对比分析.2预备知识2.1组合阶双线性群2010年Lewko和Waters使用群生成器和一个参数生成算法重新定义了组合阶双线性群,其中参数生成算法以安全参数λ作为输入,以双线性群G的描述作为输出.群生成器输出参数(N=p1p2p3,G,GT,e),其中p1,p2,p3是互不相同的素数,G和GT是阶为N=p1p2p3的循环群,映射e:G2→GT的性质描述如下:(1)双线性.g,h∈G,a,b∈N,e(ga,hb)=e(g,h)ab.(2)非退化性.g∈G,g是群G的生成元,则e(g,g)是GT的生成元.假设1.三素数组合阶双线性群中的子群判定假设,给定一个群的生成器,定义下列关系:=(N=p1p2p3,G,GT,e)←RD=(,g,X3),T1←RGp1p2,T2←RGp1.Page3定义敌手攻破假设1的优势为Adv1,(λ)··=Pr[(D,T1)=1]-Pr[(D,T2)=1].对于任一个多项式时间算法,Adv1,(λ)是一个关于λ可忽略函数.假设2.给定一个群生成器,定义下列关系:=(N=p1p2p3,G,GT,e)←RX2,Y2←RGp2,X3,Y3←RGp3,D=(,g,X1X2,X3,Y2Y3),T1←RG,T2←RGp1p3.定义敌手攻破假设2的优势为Adv2,(λ)··=Pr[(D,T1)=1]-Pr[(D,T2)=1].对于任一个多项式时间算法,Adv1,(λ)是一个关于λ可忽略函数.假设3.给定一个群生成器,定义下列关系:=(N=p1p2p3,G,GT,e)←Rg←RGp1,X2,Y2,Z2←RGp2,X3←RGp3,D=(,g,gαX2,X3,gsY2,Z2),T1=e(g,g)αs,T2←RGT.定义敌手攻破假设2的优势为Adv3,(λ)··=Pr[(D,T1)=1]-Pr[(D,T2)=1].对于任一个多项式时间算法,Adv1,(λ)是一个关于λ可忽略函数.2.2Groth-Sahai证明系统Groth和Sahai给出了如何使用非交互式零知识理论构建证明系统的方法.其中常用的基本概念如下:承诺是指将{xm}m=1…M∈G1进行隐藏,计算得出其唯一绑定的承诺值{Cm}m=1…M.随机选择{aq}q=1…Q∈G1,{bq}q=1…Q∈G2,{αq,m}q=1…Q,m=1…M∈Zp,{βq,n}q=1…Q,n=1…N∈Zp,则{xm}m=1…M∈G1在群G1上的承诺为Cm=aq∏M在群G2上的承诺为Dn=bq∏N值的双线性配对等式∏Q称为陈述s.证明π是要证明陈述s是正确的,即配对等式有解存在,系统能够从承诺中提取相应的xm和yn,使得陈述s中的等式成立.形式化的表示如下:π={NIZK((c1:x1),…,(cM:xM),(d1:y1),…,(dN:yN)):(∏Qeaq∏Mq=1上述证明系统满足如下安全性要求:(1)正确性.即诚实的示证者持有证据w,则其陈述s一定会被诚实的验证者接受.(2)合理性.若xL,一个多项式时间内的敌手PPT不能伪造一个可以被诚实验证者接受的证明.(3)可追踪性.若诚实验证者接受了证明,则可以从承诺中提取出满足配对等式的值.(4)证据不可区分性.若关于陈述x∈L存在着两个证据w1,w2,多项式时间内敌手PPT不能分辨出证明过程使用的是哪一个证据.3GSCOBG方案本节在BMW模型的基础上给出了GSCOBG方案的算法构成与安全性定义,以及该方案的详细设计过程.3.1GSCOBG方案结构及其安全性定义本文所给出的组签名方案包含6个多项式时间内算法:组签名初始化算法Setup,组签名密钥产生算法KeyGen,组内成员签名算法Sign,承诺算法Commit,签名验证算法Verify,签名追踪算法Trace.Setup算法.输入安全参数,系统产生所用到KeyGen算法.系统将公共参数作为输入,产生三元组(TK,MK,KID),其中TK为追踪密钥,MK为组管理者私钥,KID是身份信息为ID的组内成员的签名密钥.的所有公共参数和随机数.Sign算法.该算法将组内成员ID的签名密钥和要签署的消息M作为输入,算法输出一个在消息M上的签名,签名要满足特定的验证等式.Commit算法.该算法将上述的签名值及其满足的特定关系作为输入,产生和签名值所对应的承诺值,并将特定关系转化为配对乘积等式.Verify算法.该算法将公共参数、消息M,签名值σ作为输入,如验证通过则输出1,否则输出0.Trace算法.该算法将组管理追踪密钥TK、消息M和在M上的签名值σ作为输入,算法输出签名者标识ID.对于一个安全的组签名方案须满足下列安全性:正确性.对于诚实的组成员生成的签名,验证者必须接受,且通过追踪算法能够从正确的签名中提取出正确的成员身份.形式化表述为Page4Pr[params←Setup(1λ);(MK,TK,KID)←Keygen(params);σ←Sign(params,KID,M):Verify(params,m,σ)=1∧Trace(TK,M,σ)=ID]=1.完全匿名性.匿名性要求敌手不能计算出组管理者的私钥,也不能恢复出组成员的身份信息.敌手执行两个阶段:选择阶段和猜测阶段.在选择阶段输入组成员的私钥KID和公共参数params,在该阶段结束时,输出两个合法的成员标识ID1,ID2和消息M.在第二阶段敌手得到随机签名者在M上的一个签名值.敌手的最终目标是猜出签名值是使用哪个密钥所签署的,但猜中的概率是1/2.形式化表述为Pr[params←Setup(1λ);(ID1,ID2,M,State)←1(params,KID);b←{0,1};σ←Sign(params,KIDb,M);b←2(params,KID):Verify(params,m,σ)=1∧b=b]=1完全可追踪性.完全可追踪性要求组内若干个成员不能密谋伪造签名,伪造的签名不能提取出合法的成员身份.敌手执行两个阶段操作:选择阶段和猜测阶段.集合G中包含合法的用户ID与数量,选择阶段敌手通过不可靠的集合展开攻击,集合G包含不可靠成员的身份标识和成员数量.猜测阶段敌手尝试伪造一个在消息M上的签名σ,如果是合法签名,追踪算法若能够输出身份标识ID∈G,则敌手攻击成功,否则失败.形式化表述为Pr[params←Setup(1λ);G←1(params);σ←Sign(params,KID,M);ID←Trace(params,TK,σ):Verify(params,m,σ)=1∧ID∈G]=0.不可伪造性.数字签名的基本要求是签名不能被伪造,即伪造的签名不能被验证算法所接受.实际上不可伪造性包含在完全可追踪性中.敌手可以通过签名预言机获得选择阶段的数字签名.若敌手产生一个合法的签名(m,σ),并使用追踪算法追踪成员身份,算法输出均属于集合G,而实际上集合G是一个空集合.3.2GSCOBG方案设计本节利用组合阶双线性群构建了一个高效组签名方案,方案中引入了Groth和Sahai提出的非交互式证明理论,并结合承诺方案加以构建.图1描述了整个组签名方案的执行过程.初始化过程中,λ是安全参数,身份信息ID和消息M可以分别表示成k位和n位的二进制串,要求k<=nλ,组内可以支持2k个成员加入.G是一个可交换的乘法群,阶为N=p1p2p3,其中p1,p2,p3为素数,e:G×G→GT为双线性映射.Setup(1λ).令Gpi是群G的一个子群,阶为pi,在群Gpi中随机选择生成元g,v←G2(u1,…,uk)←Gkxk)←{0,1}k;向量(v1,…,vn)←Gn消息M,M=(m1,…,mn)←{0,1}n,选择数α←N.因此公共参数为PP={N,g,u,u1,…,uk,v,v1,…,vn,A=e(g,g)α},MK=gα←G,TK=p2公共参数不仅包括pp而且包括了k,n以及(N,G,GT,e)的相关描述.KeyGen(PP,MK,ID).系统为用户分配一个唯一标识ID=(x1,…,xk)←{0,1}k,并为其产生签名密钥,选择随机数r1←N,在群Gp3中选择两个元素,R3,R3←G2计算产生.由所选的元素计算用户ID的签名密钥如下:KID=K1=gαur1∏k并生成非交互式零知识证明π1=ur1∏k用于向验证者证实自己的身份.Sign(PP,KID,M).用户使用秘密的签名密钥KID=(K1,K2)←G2对消息M进行签名.选择随机数s←N,得到如下签名:S=(S1,S2,S3)=K1vr2∏n而S1,S2,S3首先满足配对乘积等式:e(S1,g)eS2,ur1∏k因为以上签名中包含秘密签名密钥,所以根据Groth-Sahai的非交互式零知识证明理论,应对私密信息进行承诺,进而使得验证者确信承诺中包含私密信息.按照NIZK中的承诺方法,如果对群中元素x←G承诺,则将x的一一映射为x,选择随机数r1,…,rI←Page5方便最后的追踪,本方案中将x作为x的一一映射即x→x,从而简化承诺的复杂程度.Commit(pp,S).本方案中需要对上述签名过程中产生的3个签名元素S1,S2,S3以及ur1∏kvr2∏nvmjj进行承诺.选择t,t1,t2,t3∈N对元组S1,j=1S2,S3,uIDh1,vmh2承诺如下:comm1=S1ht1,comm2=S2ht2,comm3=S3ht3,comm4=ur1∏k并计算π2=gt1-r1t-st·ur1∏k最终签名由以下元组组成:σ=(comm1,comm2,comm3,comm4,comm5,π2).Verify(PP,σ).验证者收到签名后,利用公开参数对身份的证明和签名进行验证,如果身份和签名都满足验证等式,则验证通过,否则返回错误消息.对身份进行验证时,令C=ur1∏k式e(C,C∏k继续对签名进行验证,否则返回错误消息.对消息进行验证时只需验证下面等式是否成立:e(comm1,g)e(comm2,comm4)e(comm3,comm5)=A·e(h,π2),如果等式成立则签名将被验证者所接受,否则返回错误消息.Trace(pp,Ci,TK).当签名者对ID=x1,…,xk←{0,1}k的每一位进行承诺时,选择随机数r11,…,r1k←(N)k,而r=r11+r12+…+r1k,计算Ci=ur1i·uxii使得C=C1·C2·…·Cn=ur1∏k产生纠纷时,需要组管理者追踪签名者身份,组管理者使用追踪密钥TK=p2,通过计算(Ci)p2的值恢复出ID.若(Ci)p2=1(其中1为群G中的单位元),则xi=0;若(Ci)p2≠1,则xi=1.进而依次恢复出用户身份信息ID所对应的二进制串.4安全性证明定义1.如果(Setup,KeyGen,Sign,Verify)是一个具有正确性、完全匿名性、不可伪造性、完全可追踪性的组签名方案,且对于组成员身份的证明过程(Setup,KeyGen,Verify,Trace)是一个具有正确性、合理性、证据不可区分性、可追踪性的非交互式证明系统,则该组签名方案是安全的.定理1.Setup(1k),KeyGen(PP,MK,ID),Verify(PP,σ)是一个具有正确性、不可伪造性、完全匿名性、完全可追踪性的组签名方案.下面给出定理1的证明.(1)正确性.正确性的证明包含3个部分:身份验证等式的正确性、最初签名验证等式的正确性、承诺以后最终签名验证等式的正确性,下面分别对以上3个等式进行验证.若要证明对于身份的验证等式eC,C∏ke(u,π1)成立,通过等式的左边可得u-1()i=eur1∏keC,C∏k=e(ur1,ur1)e∏keur1,∏k=eu,ur1∏k=e(u,π1).签名算法中,组成员产生最初的签名包含3个签名值(S1,S2,S3),该三元组满足等式e(S1,g)eS2,ur1∏k若要证明该签名的验证等式成立,通过计算等式的左边可得e(S1,g)eS2,ur1∏k=egαur1∏ke(gr1R3)-1,ur1∏k=e(gα,g)e(R3,g)e(R3)-1,ur1∏k=e(gα,g)=A.若元素g是群G的一个生成元,根据组合阶双线性群的正交性,元素gp1p2是群Gp3的生成元,元素gp1p3是群Gp2的生成元,元素gp2p3是群Gp1的生成元.假设h1∈Gp1,h2∈Gp2,因此,对于α1,α2,h1=(gp2p3)α1和h2=(gp1p3)α2,可以推导出e(h1,h2)=e(gp2p3α1,gp1p3α2)=e(gα1,gp3α2)p1p2p3=1.因此Page6承诺后的签名值σ=(comm1,comm2,comm3,comm4,comm5,π2)满足验证等式e(comm1,g)·e(comm2,comm4)e(comm3,comm5)=A·e(h,π2),为证明上述等式成立,计算等式的左边可以得出e(comm1,g)e(comm2,comm4)e(comm3,comm5)=e(S1ht1,g)eS2ht2,ur1∏k=e(gα,g)eh,gt1-r1t-stht(t2+t3)ur1∏k=A·e(h,π2).的,从而整个签名方案满足正确性要求.因此可以得出三部分验证等式都是满足正确性很容易得出如下结论:在配对函数中的两个元素若来自群G的任意两个不同子群Gpi,则其配对函数值为单位元1,从而配对函数e(R3,g)和(e(R3)-1,ur1∏k式e(S1,g)eS2,ur1∏k足正确性要求.(2)完全匿名性.引理1.如果敌手在多项式时间t内,可以以ε的概率攻破假设1或假设2,则在多项式时间t内,敌手就可以以ε中t≈t.引理1的证明.Waters等人[25]提出了半适用性的概念,半适用性签名密钥K1=K1·gγzk2,K2=K2·gγ2,Ek+1=Ek+1gγzk+1,…,El=Elgγzl,半适用性签名:comm4=comm4·gxzs2,comm=g=g·gx用半适用性的签名和密钥可以得出e(g,g)α·e(g2,g2)xγ(zk-zs),如果zk=zs则验证等式是成立的.本节将使用Game序列进行证明,其中GameReal是真实且安全的Game序列,而GameRestricted序列相对于GameReal而言,对敌手询问做了一些限制,要求所有身份信息ID模N后的值是不相同的.q表示敌手询问密钥的次数.k从0~q中取值,定义Gamek如下:给定g,X3,可以使用算法模拟GameReal,算法产生身份标识ID,ID,其满足ID≠IDmodN,并且p2整除ID-ID.算法使用上述ID计算有效解a=gcd(ID-ID,N).令b=N且N=ab=p1p2p3.存在两种情况:p1整除b,或p1整除a,从而有a=p1p2,b=p3.其中之一会以ε的概率出现.在情况1中算法会攻破假设1.给定的g,X3,能够通过验证gb是否是身份标识来判定p1整除b,然后验证Tb是否是身份标识,如果是身份标识,则T∈Gp1,反之,T∈Gp1p2.情况2中,算法攻破假设2,给定g,X1X2,X3,Y2Y,算法能够通过验证(X1X2)a是身份标识来判定a=p1p2,然后验证双线性函数e((Y2Y3)b,T)是否是身份标识,如果是,则T∈Gp1p3,否则T∈G.然而敌手攻破假设1的概率是可忽略的,说明GameReal序列与GameRestricted序列是不可区分的,即GameRealAdv-GameRestrictedAdv=0,根据逆否命题的性质可以得出敌手攻破完全匿名性的概率为AdvA<ε(3)不可伪造性.不可伪造性的证明依赖于假设1~3,以下引理说明GameRestricted序列与Game0序列是不可区分的,Game0序列与Gamek-1序列是不可区分的,以此类推,最终得出每个序列都是不可区分的.引理2.假设如果存在算法使得那么可以构造一个算法以ε引理2的证明.首先得到值g,X3,T之后可以使用算法模拟GameRestricted或Game0.算法选择随机数α,a1,…,al,b∈ZN,计算g=g,ui=gai,h=gb,i∈{1,…,l},并将公共参数{N,u1,…,ul,g,h,e(g,g)α}发给.当攻击者询问算法用户ID=(x1,…,xk)的密钥时,选择随机数r,t,w,vj,…,vl∈ZN,计算K1=gαur∏kk+1Xvk+1,…,El=ururM0,M1和一个挑战身份信息ID=(x1,…,xk),算法随机选择β∈{0,1},产生签名comm1=comm1β,comm4=Ta1x签名是一个zc=a1x1+…+akxk+b的半适用性签名.如果T∈Gp1这将是一个正常的签名,因此算法可以使用算法的输出区分T.引理3.如果存在一个算法满足那么可以构造一个算法以ε的概率攻破假设2.引理3的证明.算法得到g,X1X2,X3,Y2Y3,Page72=YtT,选择随机数a1,…,al,b∈ZN,并设置公共参数为g=g,ui=gai,h=gb,e(g,g)α,并发给算法,当攻击者询问身份为ID的第i位信息,i<j,算法创建一个半适用性密钥,同时选择随机数r,t,zk+1,…,zl∈ZN,计算:K1=gαur∏kgr(Y2Y3)t,Ek+1=ur通过gγ生正常的密钥.为了建立身份信息ID=(x1,…,xk)第j次密钥询问,使用随机数wk,wj+1,…,wl∈N产生密钥K1=gαTzkXwk3,K2=T,Ek+1=Taj+1Xwj+1,…,El=TalXwl3.如果T∈Gp1p3则上述密钥为正常密钥,如果T∈G则为半适用性密钥.在某一时刻,算法发送给两个消息M0,M1和一个挑战身份ID=(x1,…,xk).算法随机选择β∈{0,1},构成的签名表示为如下形式:comm1=comm1β,comm4=(X1X2)a1x1+…+akxk+b,g=X1X2.如果T∈Gp1p3,算法能够模拟出Gamek-1,如果T∈G,能够模拟出Gamek,因此能够使用算法的输出区分出T.引理4.如果存在一个算法满足那么可以构造一个算法以ε的概率攻破假设3.引理4的证明.算法得到g,gαX2,X3,gsY2,Z2,T,算法选择随机数a1,…,al,b∈ZN,设置公共参数g=g,ui=gai,h=gb,e(g,g)α=e(gαX2,g),并发给,当询问用户ID=(x1,…,xk)的密钥时,算法产生一个半适用性密钥,选择随机数c,r,t,w,z,zk+1,…,zl,wj+1,…,wl∈N,计算:K1=gαuri∏kEk+1=ur算法发送给两个消息,M0,M1和一个挑战身份信息ID=(x签名comm1=comm1β,comm4=(gsY2)a1xg=gsY2.如果T=e(g,g)α,那么该签名就是对于消息Mβ的半适用性签名.如果T是GT中的一个元素,那么该签名是对随机消息产生的签名.因此算法使用算法的输出可以区分T.如果假设1,2和假设3成立,那么通过上述引理可以得出真实的安全Game序列与GameFinal序列是不可区分的,这表明β值对于攻击者而言是隐藏的,因此,攻击者攻伪造一个组签名方案的概率是一个可忽略的函数.(4)完全可追踪性.完全可追踪性的证明,基于上述签名的不可伪造性,构造一个模拟器与敌手进行组签名Game序列的交互.引理5.如果存在一个敌手在多项式时间t内可以以概率ε攻破组签名的完全可追踪性,则存在一个敌手在t时间内可以以概率ε攻破签名的不可伪造性,其中t≈t.引理5的证明.在初始化算法中,产生公共参数,将追踪密钥TK发送给敌手,敌手得到提取的权限.在模拟器与敌手的交互过程中,如果敌手询问某一用户ID的签名密钥,则模拟器通过询问签名预言机获得用户ID=(x1,…,xk)的签名密钥(K1,K2),然后将其发送给敌手.敌手询问在身份信息为ID=(x1,…,xk)的用户在消息M=(m1,…,mn)上的签名,得到签名S=(S随机数t,t1,t2,t3∈N生成最终的签名σ(=SS2ht2,S3ht3,ur1∏k性可以通过追踪密钥TK最终能否提取出组内一个合法的身份来验证.某时刻,敌手可以通过自己掌握的知识伪造用户ID=(x1,…,xk)在消息M=(m签名σ=(comm1,comm2,comm3,comm4,comm5,π),模拟器产生λ,其中λ满足λ≡1(modp1)且λ≡0(modp2p3).而commλ1,commλ2,commλ3,commλ4,commλ5,πλ满足如下验证等式:e(commλ1,g)e(commλ2,commλ4)e(commλ3,commλ5)=A·e(h3,πλ2).因此证明敌手可以伪造出用户签名,而在引理2~4中已经证明出签名的不可伪造性,所以该结论与假设相矛盾,从而得出引理5的正确性.至此,定理1得证.定理2.Setup(1k),KeyGen(PP,MK,ID),Verify(PP,σ),Trace(pp,σ)是一个具有正确性、合理性、证据不可区分性、可追踪性的非交互式零知识证明系统.主要证明该非交互式证明系统的其它特性.证明.正确性已经在定理1中得到证明,下面(1)合理性.已知验证等式eC,C∏kPage8通过计算可得u-1(eC,C∏k=eu,ur1∏ku的阶为p2,所对应的配对eu,ur1∏k的阶为1或p2,从验证等式eC,C∏ke(u,π1)中可以得出eC,C∏k因此∏ki=1∏kGp1的生成元,其阶为p1,所以xi=0或xi=1.(2)证据不可区分性.当签名者对ID=x1,…,xk←{0,1}k的每一位进行承诺时,选择随机数r11,…,r1k←(N)k,而r=r11+r12+…+r1k,计算Ci=ur1i·uxii,使得C=C1·C2·…·Cn=ur1∏kCi=ur1i·u0等式e(Ci,Ciu-1i)=e(ui,(u2xi-1此对于承诺值相同的不同承诺对象而言,生成的证明π=(ur1i·u1具有证据不可区分性.(3)可追踪性.可追踪性证明包含隐藏性和绑定性两部分.隐藏性.若验证者已知承诺值为Ci=ur1i·uxii,并不能从中得到签名者的签名密钥以及身份信息方案非交互式匿名性抗CCA不可否认性可追踪性不可连接性不可区分性成员撤销表1安全性对比ACHdM[21]×BW06[11]BW07[12]LV09[14]WL10[15]本文方案表2是对提出的GSCOBG方案的效率分别从通信次数、通信代价、计算代价三个方面进行分析.通过计算,本文提出的组签名方案的6个算法中共使用群中元素2k+14个(其中k为消息串的长度),随机数12个,幂运算k+26个,配对运算9个.由于配对的计算较复杂,所以在效率分析上应该作为主要的考虑因素.x.在组签名方案中生成参数时,根据假设1可知u与uGp2在计算上是不可区分的.通过计算Ci=ur1i·uxii所得的承诺值,根据假设1,不存在多项式时间内的敌手分辨出究竟使用的是ur1i还是ur1i.若使用ur1i时使用追踪密钥TK=p2,C可变形为Ci=ur1i·uxii=uxii·ur1i-(xi-xi)/α2,其中gp1p3α2∈Gp2,g∈G,u=uα2i通过追踪方式打开Ci得到的可为任意值,计算过程如下:Cp2i=(ur1i·uxii)p2=(uxii·ur1i-(xi-xi)/α2)α2绑定性.承诺值Ci与承诺对象身份xi是一一对应的,即不存在两个xi承诺后生成相同的承诺值.使用Ci=ur1i·uxii构建承诺值,根据假设1,Ci与xi值一一对应.若给出u∈Gp2时使用追踪密钥TK=p2可以从Ci中提取出承诺对象xi,即(Ci)p2=(ur1i·uxii)p2=(up2i)xi,如果(Ci)p2=1,则xi=0;如果(Ci)p2≠1,则xi=1,从而依次恢复出唯一的用户身份信息ID对应的二进制串.5分析与比较本节将GSCOBG方案与同类其它方案在安全性和效率两方面分别作了比较,表1是本文方案与上文提到的基于BMW模型和BSZ模型的系列组签名方案的安全性对比.方案通信ACHdM[21]5206+l40519BW06[11]34k+124k+6k+102k+6k+4BW07[12]3k+22112k+32k+1214VLRGS[14]32k+38k+12k+21k+2322WL[15]53k+4727712本文方案32k+1412k+264k+129Page9本文将提出的GSCOBG方案与同类的其它组签名方案进行了对比,通过表1和表2可以得出以下结论:GSCOBG方案在交互次数方面优于交互式的方案ACHdM[21]和文献[15]中的方案,在通信代价方面整体优于文献[11,14]中的方案,在计算代价方面优于非交互式组签名方案BW07[12],在配对的计算量方面优于文献[11-12,14-15,21]中的方案.6总结本文使用组合阶双线性群构建了一个基于BMW模型的高效组签名方案,在方案中引进了Groth-Sahai证明系统的思想,并提供了严格的安全性证明,最后分别从安全性和效率两方面将该方案与同类其它组签名方案做出对比,从而得出该方案在效率和安全性上的优势.GSCOBG方案,解决了传统组签名的通信效率低、不能抵抗选择密文攻击等问题.此外,签名的大小是一个常量,不依赖于其它系统参数.同时GSCOBG方案也存在不足之处,比如没有提供完整的成员撤销机制等问题,这需要在今后的工作中得以继续完善.
