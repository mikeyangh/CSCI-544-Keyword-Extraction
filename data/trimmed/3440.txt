Page1基于MDA的并行仿真可视化组件建模范式姚益平刘刚(国防科学技术大学计算机学院长沙410073)摘要并行仿真是提高分析仿真运行效率的有效途径.当前国内外并行仿真由于缺乏高效统一的可视化组件建模范式的指导,往往需要采用从上到下的集中式开发模式,开发门槛高、效率低、二次建模困难,且模型间的耦合度大、协调难,模型与仿真平台紧密绑定,难以实现模型的分步开发、封装、快速组装及平台间模型的重用.作者结合组件建模及MDA技术的优势,针对当前广受关注的PDEVS规范所存在的不支持原子模型可视化建模及事件处理逻辑过于集中、无法挖掘处理逻辑内部并行性的缺点,提出了基于MDA的并行仿真可视化组件建模范式———EDEVS,并证明了该范式的描述能力不弱于PDEVS;在此基础上,设计实现了基于EDEVS的可视化建模框架及EDEVS模型到YHSUPE并行仿真平台模型的代码转换插件,将组件化引入YHSUPE,使其能够适应大规模并行仿真模型分步开发及快速组装的应用需求,验证了EDEVS范式的可行性.关键词并行离散事件仿真;组件建模;MDA;DEVS;范式1引言大规模生态环境仿真、计算系统生物学仿真、复Page2由于这类仿真往往包含大量的实体,实体内又包含多个模型,而且随着仿真应用的不断深入,其实体规模越来越大,实体间以及模型间存在错综复杂的交互[1],且这些实体模型往往涉及多个领域的专业知识,需要不同领域的专家分别开发,特别是由于知识产权保护等原因,这些模型往往需要以封装好的执行码形式提交给使用方,这就使得模型的组件化开发及封装标准和组装技术变得尤为重要,目前的仿真组件化建模理论和方法要么没有考虑并行仿真事件驱动等特征,只适合于HLA等分布式交互仿真系统;要么过于复杂,难以使用,从而使得并行仿真往往需要采用从上到下的集中式开发模式,存在开发门槛高、开发效率低、二次建模困难,且模型间的耦合度大、协调难,模型与仿真平台紧密绑定、难以实现模型的分布高效开发、封装和快速组装及平台间模型的重用等问题[2-3],从而使得其难以适应大规模并行仿真应用发展的需要.因此,为满足大规模并行仿真模型分布开发、组件化组装的需求,提高应用的建模开发效率,亟待研究基于组件的并行仿真可视化建模理论与技术.归纳起来,大规模并行仿真对建模理论和技术提出了以下要求:(1)能把大而复杂的模型递归地分解为小的简单的模型,分步建模.大规模并行仿真中往往包含极其复杂的模型(例如环境模型、C4I武器系统模型等),且模型还往往涉及多个领域的专业知识,直接对其进行建模往往非常困难,应当能够将之递归地分解为涉及领域知识较单一的小模型,由地理上分布的各领域专家分别建模[4].(2)能够方便地利用已有模型,从小模型构造大模型,从下到上构建仿真应用.对于大规模仿真中的复杂模型,每次都从头开始建模开发往往工作量巨大,且模型的正确性难以保证.而利用已有的模型构造符合要求的大模型,并层次化地组装成仿真应用,则是快速、高效、灵活地构造仿真应用的最佳途径[5-7].(3)保证模型的自包含特性,即能独立封装、发布,而不依赖于其它模型.大规模并行仿真中的不同模型往往需要不同领域的专家分别开发,为保证模型开发、调试的独立性及相对的保密性(很多模型涉及版权问题),就必须要求模型具有自包含特性,使得各单位的模型能独立封装,并易于组合[8-9].(4)采用与仿真平台无关的可视化建模方式,并提供高效的代码转换机制.目前国内外并行仿真平台正处于不断完善和发展之中,尚未形成统一的标准.因而,有必要在一定程度上保持模型的平台无关特性,而由高效的代码转换机制将平台无关模型转换并封装成平台相关模型,使大规模并行仿真应用能够快捷地使用并行仿真领域的最新成果,推进自身发展[10].基于组件的建模技术可有效降低组件模型间的耦合度,改善模型的重用性,有利于实现仿真模型开发与使用的分离,由领域专家设计组件化的仿真模型,应用开发人员使用已有的组件模型快速组装仿真应用,从而能够大大提高仿真应用的开发效率;而MDA(ModelDrivenArchitecture)[11]技术能使模型与模型的运行平台相分离,从而有效地支持模型在运行平台间的重用.本文立足大规模并行仿真对建模范式的要求,结合组件建模及MDA技术的优势,提出了一种基于MDA的并行仿真可视化组件建模范式EDEVS(Event-schedulingDiscreteEVentsimulationSpec-ification)[12],并设计实现了基于EDEVS范式的可视化建模框架,为建模人员提供可视化的建模图元,使建模过程直观简便,充分支持快速、分步建模及模型的可视化组装.在此基础上,本文实现了EDEVS模型到YHSUPE(YinHeSimulationUtilitiesforParallelEnvironment)[1]仿真平台模型代码的映射,将组件化引入YHSUPE,提高了其建模开发效率,验证了EDEVS的可行性.本文第2节介绍国内外相关工作;第3节介绍EDEVS原子组件模型范式、耦合组件模型范式及建模实例,并证明该范式描述能力;第4节简要介绍EDEVS可视化建模环境VisiCom;第5节对本文所做的工作进行总结.2相关工作国内外对基于并行仿真的组件化建模技术的研究主要有Flames、CCSE和JMASS的组件化建模技术及BOM(BaseObjectModel)和DEVS(Dis-creteEventSystemSpecifications)组件化建模规范.美国Ternion公司的产品Flames是当前著名的仿真集成环境之一,应用于大型仿真.它对装备进行分类,定义相应的组件化接口,并在此基础上对每类装备实现一个基本模型类,让模型设计者能继承这些模型类而派生出自己的模型.Flames支持模型参数的可视化配置,但不支持原子模型的可视化建模,Page3其建模方式与其仿真平台相绑定,且不支持集群式并行仿真,限制了其仿真应用的规模[13];美国联合仿真三大项目之一的JSIMS系统提供了一系列并行仿真支持工具,其中,公共组件仿真引擎CCSE为JSIMS的综合环境提供核心支撑服务,CCSE借鉴了组件式建模思想,提供了实体和组件两种基类,供用户开发自己的组件模型,在实体里对组件进行组装,然后应用到CCSE的仿真框架中去.但CCSE建模框架不支持可视化建模,且其公布订购式的模型解耦方式存在效率问题,其建模方式也与其仿真平台绑定,不支持平台间的模型重用[8];JMASS也是美国联合仿真三大项目之一,目标是促进组件级和平台级系统的模型重用和互操作,与Flames一样,JMASS中的重用仅限于既定的几类模型,没有统一的建模规范,不支持可视化建模,不支持模型的递归分解,重用粒度过粗,也不支持平台间模型重用[14-15];BOM是由SISO提出的面向分布式仿真的组件化建模框架,但BOM定义的是概念模型及该模型到HLA规范的映射方式,不是一个完整的并行离散事件仿真建模规范[17-18];DEVS是亚利桑那州立大学Zeigler教授课题组在20世纪70年代末提出的并行离散事件系统规范,并于2000年初发展出其并行化版本PDEVS(ParallelDEVS),且基于此规范实现了DEVSJAVA、COSMOS等仿真平台.PDEVS包括原子模型和耦合模型两个范式.原子模型范式规定如何从无到有构造模型,而耦合模型范式规定如何利用小模型构造大模型.PDEVS原子模型可以用一个八元组表示:素,也可以为空;素,也可以为空;其中:Xm={(p,v)|p∈IPorts,v∈Xp}是输入端口与其参数值的二元组集合;Ym={(p,v)|p∈OPorts,v∈Yp}是输出端口与其参数值的二元组集合;S是状态变量的集合;Xbm是输入包,可以包含Xm中的一个或多个元Ybm是输出包,可以包含Ym中的一个或多个元δext:Q×Xbm→S是外部状态转换函数,用于响δint:S→S是内部状态转换函数;δcon:Q×Xbm→S是冲突消解函数,当外部状态λ:S→Ybm是输出函数;转换与内部状态转换同时发生时被调用;应外部事件;ta:S→R+0,是时间推进函数;Q={(s,e)|s∈S,0eta(s)}是全状态变量,包括状态变量集S与e,e记录从上次发生状态转换到现在的时间间隔.任意时刻模型处于某个确定的状态s∈S,如果没有外部输入出现,这个状态将持续ta(s)时间,其中ta(s)是一个非负实数.当ta(s)为0时,称s为一个暂态,此时模型不受外部输入的干扰,相反ta(s)为时,称s为一被动态,只要没有外部输入出现,这个状态将一直持续下去,而ta(s)为其它值时,在没有外部输入发生的情况下,经过ta(s)时间之后,模型将进入由内部状态转换函数δint所决定的下一个状态s=δint(s),并产生输出,需要注意的是模型只在此种情况下产生输出;若在ta(s)时间之内,有外部输入x∈Xbm产生,则模型将进入由外部状态转换函数δext所决定的下一个状态s=δext(s,e,x).如果外部输入恰好出现在ta(s)时刻,那么模型的下一个状态由冲突消解函数δcon决定.将已有的原子模型或耦合模型的输入输出端口连接起来就可以构成更大的耦合模型.形式上,耦合模型可以表示成:N=〈X,Y,D,{Md|d∈D},EIC,EOC,IC〉,其中:X是输入端口及其参数值的二元组集合;Y是输出端口及其参数值的二元组集合;D是构建耦合模型的子模型名称集合;Md表示名称为d的子模型;EIC是该耦合模型输入端口与其子模型的输EOC是子模型的输出端口与该耦合模型的输IC是子模型之间的输入、输出端口连接关系集合.模型的耦合是通过指定端口之间的连接关系来实现的,这样就可以由已有的模型层次化地构成更大的模型[19].PDEVS规范还规定了与建模范式相对应的仿真引擎实现规范.但由于PDEVS不支持原子模型的可视化建模,模型开发难度大,且原子模型的事件处理逻辑过于集中,时间同步开销大,运行效率不理想,因此到目前为止未被业界广泛接受.总之,目前国内外并行仿真组件建模理论与技术正处于研究发展之中,现有的理论与技术要么不支持可视化建模、时间同步开销大或者建模方式与仿真平台绑定,要么不支持复杂模型的递归分解、使用难度大,要么不支持并行仿真,难以满足大规模并行仿真应用在模型递归分解、分布式可视化开发、封出端口的连接关系集合;入端口的连接关系集合;Page4装和快速组装及平台间模型的重用等方面的需求,亟待研究高效的并行仿真组件建模规范及模型可视化建模技术,以促进复杂系统并行仿真应用的发展.3EDEVS范式EDEVS范式在保证PDEVS范式的递归性、自包含特性及建模表达能力的基础上,针对PDEVS不支持原子模型可视化建模及事件处理逻辑过于集中、时间同步开销大的缺点,通过引入内部端口,将PDEVS原子模型的外部状态转换函数和内部状态转换函数划分为与端口相对应的端口处理函数,充分开发状态转换函数潜在的并行性,在不违反因果关系的前提下实现更细粒度的并行.EDEVS包括原子模型与耦合模型两个范式,以下将分别对两个范式进行介绍.3.1EDEVS原子模型及其参数值的二元关系集合;EDEVS原子模型可以用一个十元组来表示:M=〈Xm,Ym,Km,S,Initie,δ,δcon,λ,feid,ea〉,其中:Xm={(p,v)|p∈IPorts,v∈Xp}是输入端口及其参数值的二元关系集合;Ym={(p,v)|p∈OPorts,v∈Yp}是输出端口InnerPorts={"cancelOP"}∪OtherPorts为内Km={(p,v)|p="cancelOP",v∈intorp∈OtherPorts,v∈Kp}是内部端口及其参数值的二元关系集合,Xm、Ym和Km也称为事件集;feid=(OPorts∪OtherPorts)→(int)是一个ID生成函数,该函数为每个被调度的事件(目的端口“cancelOP”除外)生成一个全局唯一的标识,在所调度的事件未被执行之前,以此标识作为参数调度一个目的端口为“cancelOP”的事件,可将其撤销;Initie={(p,t)|p∈Km,0t<}是目的端口为内部端口的初始事件集,其中“(p,t)”代表p事件在t时刻执行(“执行”即执行其相应的端口处理函数);部端口;δ:(Xm∪Km)×S→S是端口处理函数;δcon:(Xm∪Km)b×S→S是优先级排列函数,当同一组件中的多个事件被调度在同一时刻执行时,将按优先级先后顺序触发相应的端口处理函数;λ:(Xm∪Km)×S→(Km∪Ym)b为输出函数;ea:(Km∪Ym)×S→R+0,为时间推进函数,决IPorts∩InnerPorts=,IPorts∩OPorts=定所调度的事件的执行时间;,OPorts∩InnerPorts=.与PDEVS原子模型不同的是,EDEVS原子模型有三类端口:输入端口、内部端口及输出端口,其中内部端口只对模型自身可见.输入端口接收由其它模型触发的事件,而内部端口和输出端口则接收模型内部逻辑触发的事件,每个端口都有相应的处理函数来处理事件(事件处理函数为δ的子集).事件处理基本流程为:接收事件传入到本端口的数据,修改模型的状态变量,调度其它事件(其中,输出端口仅将接收到的事件转发到与该端口相连的其它模型的输入端口).就模型本身而言,称输入端口接收到的事件为外部事件,内部端口接收到的事件为内部事件;相应地,若模型内部逻辑触发了一个目的端口为内部端口的事件,则称调度了一个内部事件,若模型内部逻辑触发了一个目的端口为输出端口的事件则称调度了一个外部事件.在任意时刻模型处于状态s,如果有外部事件或内部事件发生,那么模型进入下一个由端口处理函数δ决定的下一个状态s=δ(s,x),而后调度一系列由输出函数λ(x,s)所决定的内部事件或外部事件,如果这些事件没有被取消,那么经过由时间推进函数ea所确定的延时之后,将触发相应的端口处理函数[12].3.2EDEVS耦合模型EDEVS耦合模型的定义与PDEVS的耦合模型定义类似,皆通过指定端口连接关系来从原子模型层次化地构造更大的模型[12].3.3EDEVS原子模型建模实例本节将介绍两个EDEVS原子模型建模实例.其中,第1个模型实现了一个积分器,该积分器在给定的积分区间和步长内对X2积分;第2个模型实现了一个加法器,对输入该加法器的两个数求和,在下节的耦合模型实例中本文将会把两个积分器的输出端口分别与加法器的两个输入端口相连,构建一个耦合模型.3.3.1积分器模型图1为积分器模型示例.该模型对X2进行定步长积分.其中Step,Integral,Begin,End4个状态变量分别描述“积分步长”、“积分值”、“积分的起始点”及“积分的结束点”.Integral的初始值为0.0,Step,Begin及End可以由模型的使用者自行设定,Step越小,积分值越精确.模型有一个内部端口和一个输出端口,没有输入端口.内部端口的参数集为空,其端口处理函数对(Begin+t)×(Begin+t)×Step即X×dt的值进行累加;输出端口的参数集中只有一个参数,即积分结果,用于向外输出积分值.Page5该模型的处理流程为:在逻辑时间0时刻,模型调度一个目的端口为“IntegralOperation”的初始事件,触发积分累加操作Integral=Integral+(Begin+t)×(Begin+t)×Step.此后,若积分未完成(即Begin+t<End),则“IntegralOperation”的端口处理函数在完成状态转换后,皆会调度一个目的端口为“IntegralOperation”,执行时间为当前时间加上“Step”个逻辑时间的内部事件,继续积分累加操作,否则调度一个延时为0、目的端口为“Ans”的外部事件,将积分值”Integral”输出.IPorts={}InnerPorts={"IntegralOperation"}OPort={"Ans"}Km={(p,v)|p∈InnerPorts,v=}Ym={(p,v)|p∈OPorts,v∈}S={Step,Integral,Begin,End|Step,Integral,Begin,End∈},S0={Integral=0,Step=configurable,Begin=configurable,End=configurable}Initie={("IntegralOperation",0)},δcon=firstcomefirstserviceδ(〈Begin,End,Step,Integral〉,("Integral",))=〈Begin,End,Step,Integral+(Begin+t)×烅烄(Begin+t)×Step〉,if(Begin+t<End)烆〈Begin,End,Step,Integral〉,λ(〈Step,Integral,Begin,End〉,("Integral",))={〈"Integral",〉,ifBegin+t<Endea("IntegralOperation",〈Step,Integral,Begin,End〉)=Stepea("Ans",〈Step,Integral,Begin,End〉)=0〈"Ans",Integral〉,3.3.2加法器模型图2为加法器模型示例.该模型的两个输入端口“InA”及“InB”接收两个加数,而后送入两个内部端口“ans1”及“ans2”进行累加操作:ans=ans+v,并记录已累加的操作数的个数:count=count+1.IPorts={"InA","InB"}InnerPorts={"ans1","ans2"}OPort={"Output"}Xm={(p,v)|p∈IPorts,v∈}Km={(p,v)|p∈InnerPorts,v∈}Ym={(p,v)|p∈OPorts,v∈}S={ans,count|ans,count∈},S0={ans=0,count=0}Initie={},δcon=firstcomefirstserviceδ(〈ans,count〉,("InA",v))=〈ans,count〉δ(〈ans,count〉,("InB",v))=〈ans,count〉δ(〈ans,count〉,("ans1",v))=〈ans+v,count+1〉δ(〈ans,count〉,("ans2",v))=〈ans+v,count+1〉λ(〈ans,count〉,("InA",v))=〈"ans1",v〉λ(〈ans,count〉,("InB",v))=〈"ans2",v〉λ(〈ans,count〉,("ans1",v))=〈"Output",ans〉if(count==2)λ(〈ans,count〉,("ans2",v))=〈"Output",ans〉if(count==2)ea("ans1",〈ans,count〉)=0ea("ans2",〈ans,count〉)=0ea("Output",〈ans,count〉)=0当count==2时累加操作完成,端口“Output”将向外输出最终结果ans.3.4EDEVS耦合模型建模实例图3为两个积分器与一个加法器耦合而成的模型,该模型计算两个积分器的积分之和.该耦合模型没有输入端口和内部端口,只有一个用于输出积分之和的输出端口“CoupledModelOut”.D中定义了耦合组件中的子组件的名称为IntergralUnit1,IntergralUnit2以及AdderUnit1,其中前两个为积分器模型,第三个为加法器模型,EOC中将加法器的“Output”输出端口连接至耦合组件的“Coupled-ModelOut”输出端口,IC中将两个积分器的“Ans”输出端口分别连接至加法器的“InA”及“InB”输入端口,由此构成计算积分和的耦合模型.OPort={"CoupledModelOut"}Xm=Km=Ym={(p,v)|p∈OPorts,v∈}D={IntergralUnit1,IntergralUnit2,AdderUnit1}MIntergralUnit1=Intergrator,MIntergralUnit2=Intergrator,MAdderUnit1=AdderEIC=EOC={((AdderUnit1,"Output"),(N,"CoupledModelOut"))}IC={((IntergralUnit1,"Ans"),(AdderUnit1,"InA")),((IntergralUnit2,"Ans"),(AdderUnit1,"InB"))}3.5EDEVS描述能力证明EDEVS的描述能力决定了基于它搭建的仿真建模框架的建模能力,也就决定了整个仿真平台的仿真能力.而PDEVS是从控制理论发展而来的,理论较成熟,其建模离散事件系统的能力业已得到形式化的证明.因此可以通过证明EDEVS能描述PDEVS中的所有模型来保证EDEVS的建模能力.为此,以下将证明EDEVS能描述PDEVS所能描述的任何模型.定义1.给定任意PDEVS模型Mpdevs=〈XM,YM,S,δext,δint,δcon,λ,ta〉,定义相应的EDEVS模型Mpdevs=〈XM,YM,Km,Sed,Initie,δ,δcon,λed,feid,ea〉.其中(以下提及的时间均为仿真时间):InnerPorts={k1,k2,k3};K1={k1,},K2={k2,},K3={k3,};Km={K1,K2,K3}(K1的端口处理函数取代δint,K2用于取消NIeid0所标识的被调度但尚未执行的事件,K3用于模拟δext的行为,本文将用Porttime来标识目的端口为“Port”,执行时刻为“time”的事件);Page6Sed=〈NIeid0,NIeidn,tl,tn,IPset,xflag,能被调度一次;NIeid0用于保存上一个被调度的K1事件的标识;NIeidn用于保存将被调度的K1事件的标识;tl是K1或K3事件最近一次被执行的时刻;tn是最后被调度的K1事件将要被执行的时刻;IPset用来构造Xbm;xflag,yflag用来保证K3在每个仿真时刻只So,Sn分别是S(Mpdevs模型中的状态变量)的上一个状态和当前状态,由于EDEVS模型先执行端口处理函数,后执行输出函数,而PDEVS模型正好相反,为了取得与PDEVS模型一致的输出,必须用So保存上一个状态.Medevs用于响应外部事件的端口处理函数定义如下:p∈IPorts(以下if语句中的“=”为赋值运算符,隐含其值在给定的定义域内,“==”为相等测试运算符):δ(Xp,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=〈NIeido,NIeidn,tl,tn,IPsetXp,true,false,烄So,Sn〉,if(xflag==false)烅〈NIeido,NIeidn,tl,tn,IPsetXp,true,true,So,Sn〉,烆λed(Xp,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=ea(K3,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=0;其中“IPsetXp”表示将Xp存入IPset.Medevs状态转换函数用于响应内部事件的部分定义如下:δ(K1,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=〈NIeidn,Kt+ta(Sk1)烄yflag,Sn,Sk1〉,if(Mpdevs:δint(Sn)=Sk1)烅〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉,烆λed(K1,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=(K3),if(xflag==ture&&yflag==false),{else;(K1,λ(So)),if(δint(Sn)isdefined),{ea(K1,Sed)=ta(Sn),ea(λ(So),Sed)=0;δ(K2,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉;λ(K2,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=〈"cancelOP",NIeido〉;ea(〈"cancelOP",NIeido〉,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=0;δ(K3,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=〈,Kt+ta(Sk3)烄if(Mpdevs:δext((Sn,t-tl),IPset)=Sk3andtn==t)〈NIeidn,Kt+ta(Sk3),false,false,Sn,Sk3〉,烅elseif(Mpdevs:δext((Sn,t-tl),IPset)=Sk3andtn!=t)〈NIeido,NIeidn,tl,tn,,false,false,So,Sn〉烆λed(K3,〈NIeido,NIeidn,tl,tn,IPset,xflag,yflag,So,Sn〉)=ea(K1,〈NIeido,NIeidn,tl,tn,IPset,xflag,λflag,So,Sn〉)=ta(Sn);ea(K2,〈NIeido,NIeidn,tl,tn,IPset,xflag,λflag,So,Sn〉)=0.若Mpdevs中的冲突消解函数定义为δcon(s,ta(s),x)=δext(δint(s),0,x)),则Medevs的δcon定义为δcon((xm∪km)b,s)=即K2的优先级最高,其次是K1,然后是外部事件,最后是K3;否则Medevs的δcon定义为δcon((xm∪km)b,s)=即K2的优先级最高,其次是外部事件,然后是K3,最后是K1.引理1.内部事件K2或K3只能伴随外部事证明.从状态转换函数的定义中可以知道,K2只由与K3相对应的状态转换函数调度且延时为0,而K3只由外部事件调度且延时为0,因而K2及K3只能发生在有外部事件发生的时刻,即伴随外部事件发生.件发生定理1.Medevs能准确描述Mpdevs.Page7证明.只要证明,给定输入串{(Xt1(0t1…tn)}及Mpdevs的初始状态S0,置Medevs的初始状态Sed0=〈,Kta(S0)false,false,S0,S0〉,Initie={〈K1,ta(S0)〉}(即调度K1事件在ta(S0)时刻执行),那么在任意时间段内,Medevs的状态转换序列在Sn分量上的投影序列与Mpdevs的状态转换序列相同,输出序列也相同(参看文献[19]第1章第5节关于模型同构的论述).假设Mpdevs中δcon(s,ta(s),x)=δext(δint(s),0,x)),则(1)t=0时,分两种情形.(a)若t1<ta(S0):对于Mpdevs,此时外部输入Xt1换发生,因而先执行δext:Q×Xbm→S,记δext(S0,t1-0,Xt11)=S1,则Mpdevs的状态变化序列STpdevs={S00,St11},而由于输出只能在内部状态转换函数即将执行时产生,因此此时输出为,输出序列YTpdevs=,时间推进到t1,若没有外部输入干扰,内部状态转换函数将在t1+ta(S1)时刻执行.对于Medevs:由于K1被调度在ta(S0)时刻执行,而由引理知0t<ta(S0)时没有K2或K3之间发生,事件队列为{Xt1外部事件Xt1分量Xt1δ(Xt11(1),〈,Kta(S0)λed(Xt11(1),〈,Kta(S0)ea(K3,〈,Kta(S0)S0〉)=0;即调度K3在t1时刻执行.事件队列为{Xt1t1时刻发生的众多事件当中,K3应在最后执行,因而接下来处理Xt11-Xt1对Xt11(2),〈,Kta(S0)δ(Xt1λed(Xt11(2),〈,Kta(S0)类似可以推出,对Xt1δ(Xt11(n),〈,Kta(S0)Xt1〈,Kta(S0)Xt1〈,Kta(S0)1(n),〈,Kta(S0)S0〉)=;λed(Xt1此时事件队列为{Kt1δ(K3,〈,Kta(S0)S0〉)=〈Kta(S0)false,false,S0,S1〉;λed(K3,〈Kta(S0)ea(K1,〈Kta(S0)false,S0,S1〉)={K1,K2};false,S0,S1〉)=ta(S1);false,S0,S1〉)=0;ea(K2,〈Kta(S0)即调度事件K2在t1时刻执行,调度K1事件在t1+ta(S1)时刻执行.此时事件队列为{Kt11},下面处理事件K2:Kt1+ta(S1)δ(K2,〈Kta(S0)false,S0,S1〉)=〈Kta(S0)ta(S1),,false,false,S0,S1〉;λed(K2,〈Kta(S0)false,S0,S1〉)=〈"cancelOP",NIeido〉;ea(〈"cancelOP",Kta(S0)t1+ta(S1),,false,false,S0,S1〉)=0;此时事件Kta(S0)下一事件到来前,Medevs的状态稳定在〈,1,t1,t1+ta(S1),,false,false,S0,S1〉,K1Kt1+ta(S1)事件被调度于t1+ta(S1)时刻发生.φsn(St1ed=,即状态转换序列在Sn分量上的投影Yt1φsn(STedevs)={S00,St11},输出序列YTedevs=,可见,STpdevs=φsn(STedevs),YTpdevs=YTedevs,且Medevs中K1即将发生的时刻与Mpdevs中下个内部状态转换时刻相同,都为t1+ta(S1).(b)若t1ta(S0):对于Mpdevs,由于δcon(S,ta(S),x)=δext(δint(S),0,x)),因而先执行δint:S→S,假设δint(S0)=S1,λpdevs=Yta(S0){Yta(S0)1},若没有外部输入干扰,内部状态转换函数Page8将在ta(S0)+ta(S1)时刻执行.对于Medevs,初始事件集为{Kta(S0)到ta(S0),执行事件K1:δ(K1,〈,Kta(S0)S0〉)=〈Kta(S0)ta(S1),,false,false,S0,S1〉;λed(K1,〈Kta(S0)ta(S1),,false,false,S0,S1〉)={K1,Y1};ea(K1,〈Kta(S0)ta(S1),,false,false,S0,S1〉)=ta(S1);ea(Y1,〈Kta(S0)ta(S1),,false,false,S0,S1〉)=0.在下一事件到来前,Medevs的状态稳定在1,Kta(S0)+ta(S1)〈Kta(S0)false,false,S0,S1〉,K1事件被调度于ta(S0)+ta(S1)时刻发生.φsn(Sta(S0)φsn(STedevs)={S00,Sta(S0){Yta(S0)1},可见STpdevs=φsn(STedevs),YTpdevs=YTedevs,且Medevs中K1即将发生的时刻与Mpdevs中下个内部状态转换时刻相同,都为ta(S0)+ta(S1).(2)假设ti时刻之前STpdevs=φsn(STedevs),YTpdevs=YTedevs均成立,记Mpdevs所处状态为i(0)(ti-1tk<ti),若没有外部输入干扰,内部状态Stk转换函数将在tk+ta(Stk状态为:〈Ktk-lfalse,false,Stk-mta(Stki(0))时刻发生,模型的输入为{(Xti+1n)|(titi+1…ti+n)}.Xti+n(a)若tk+ta(Stk证明方法与第(1)步的(a)情况类似;(b)若titk+ta(Stk证明方法与第(1)步的(b)情况类似;而Mpdevs中δcon(s,ta(s),x)=δint(δext(s,0,x))时,证法类似,不再累述.综上可知Medevs的状态转换序列在Sn分量上的投影序列与Mpdevs的状态转换序列相同,输出序列也相同,因此命题正确.由Mpdevs的任意性可知EDEVS能描述PDEVS所能描述的任意模型.4EDEVS可视化建模框架的实现EDEVS吸收了组件建模及MDA技术的优点,支持可视化组件建模.本文基于EDEVS范式开发了一个可视化建模框架VisiCom[20].该框架将EDEVS范式中的元素图元化,使得用户能够通过拖拽图元的方式直观、快捷地建立EDEVS模型.VisiCom包括可视化模型编辑器及代码转换器两大组成部分.可视化编辑器提供建模图元,接收用户以图元形式表示的EDEVS模型,将之转换并保存为XML模型描述文件;代码转换器负责将XML模型文件中的平台无关模型转换成特定平台下的模型代码.4.1可视化模型编辑器与EDEVS范式相对应,可视化编辑器包括原子模型编辑器及耦合模型编辑器.原子模型编辑器用来构造EDEVS原子模型,耦合模型编辑器利用已建好的原子模型或耦合模型,构造更复杂的模型,实现层次化建模.4.1.1原子模型编辑器原子模型编辑器以图元或图元属性的形式对EDEVS原子模型范式中的元素进行可视化.其中,“输入端口”、“输出端口”、“内部端口”、“状态”、“事件调度”、“取消调度”及“初始化事件集”都有图元与之相对应;“端口处理函数”及“优先级函数”分别作为端口的“伪码”属性和“优先级”属性实现;“事件标识生成函数”及“时间推进函数”分别作为“事件调度”的“名字”属性和“延时”属性实现.原子模型编辑器的界面如图4所示:“内部端口”、“事件调度”、“取消调度”、“状态”图元分布在编辑器左边的tab页内,将图元拖入编辑器即生成该图元实例;“输入端口”、“输出端口”图元处于工具条上,单击图元即在模型编辑区的边界出现该图元实例;“初始化事件集”图元实例在每个原子模型内有且仅有一个,内置于编辑区中.每个图元实例都有相应的属性框,其中,“端口”图元实例的属性框包括“名称”、“参数列表”、“优先级”及“伪码”4个属性条目,“参数列表”定义此端口的传入参数类型,可以是int、double、bool或string等类型,“优先级”是一个整型数值,定义以此端口为目的端口的事件在同时刻发生的事件中的处理次序,“伪码”描述“端口处理函数”的处理逻辑,该处理逻辑应遵循以下流程:首先,解析事件传入参数,其次根据参数及状态变量值计算状态变量新值,最后计算事件调度延时和传出参数值,并调度目的端口为“内部端口”或“输出端口”的事件;事件调度图元实例的属性框包括“名称”、“条件”及“延时”3个条目,“名称”在此模型中唯一,用于与feid相关联.“条件”为真时调度相应的Page9事件,“延时”表示该事件经过多长时间后到达目的端口,从而触发目的端口处理函数的执行;“取消调度”图元实例用来取消被调度但尚未执行的事件,其属性框包括“名称”、“条件”及“目标”3个属性条目,“目标”属性保存要取消的“事件调度”的名字,当条件为真时取消之;“状态”图元实例用来描述模型的状态变量,其属性框包括“名称”、“类型”、“可配置”、“取值范围”、“默认值”及“属性描述”6个属性条目,其中“类型”可以是int,double,string等,“可配置”属性表示是否允许模型使用者通过配置接口对此属性进行配置.图4即为3.3.1节介绍的定步长积分器的可视化模型,包括10个图元实例,其中有4个状态变量图元实例,状态变量图元实例分别代表Step、Inte-gral、Begin及End4个状态变量;1个初始化事件集图元实例;1个名为犐狀狋犲犵狉犪犾犗狆犲狉犪狋犻狅狀的内部端口实例,用来计算积分值,其伪码为integral=integral+(t+begin)×(t+begin);sendresultans=integral(对名为“sendresult”的事件调度的参数集赋值);1个名为Ans的输出端口实例,用来向外界输出积分值;3个事件调度图元实例,其中,第1个名为BeginIntegral,它连接初始化事件集图元与IntegralOperation端口,调度延时为0,表示逻辑时间的0时刻调度一个指向IntegralOperation端口的事件,第2个名为SelfStep,它连接IntegralOp-eration图元自身,延时为Step,条件为Begin+t<End,即在计算积分值的过程中此端口的端口处理函数会调度一个目的端口为自身的事件,此事件在Step时间间隔之后执行,驱动积分的累加过程,最后一个名为SendResult,它从IntegralOperation指向名为Ans端口,延时为0,条件为!(Begin+t<End),表示积分完成之后立即向Ans端口输出积分值.4.1.2耦合模型编辑器如图5所示,耦合组件编辑器的基本图元是“输入端口”、“输出端口”、“端口连接线”及“组件库中的组件”(表现为带输入、输出端口的方框).图5是一个名为Couple的耦合组件可视化模型实例.该耦合模型实例化两个4.1.1节所建立的定长积分器模型,并把它们输出的积分值输入到3.3.2节介绍的加法器模型内做加法运算,而后将结果输出.该耦合组件只有一个输出端口“Answer”,用来输出积分和.两个Integral子组件实例的输出端口分别与加法器子组件实例的两个输入端口相连;而加法器子组件实例的输出端口与Answer端口相连.点击子组件实例,可在编辑器右方的属性编辑框中对子组件的可配置属性进行设置.4.1.3EDEVS模型文件可视化建模工具接收用户输入的图形模型后,将此模型转换并存储为XML模型描述文件.此文件将是代码生成工具生成平台相关模型的输入.原子模型XML描述文件包括InfoRegion、InitRegion、PortRegion、DeltaRegion及StateRegion五个部分.其中,InfoRegion描述组件的基本信息,包括组件名、组件UUID以及组件的开发者及版权等信息;InitRegion描述初始事件集,即在逻辑时间的0时刻需要仿真引擎预先调度的事件;PortRegion描述端口信息,包括输入、内部及输出端口的名称,优先级及参数集,以及端口可能发出的事件调度;DeltaRegion描述模型的端口处理函数的执行逻辑;StateRegion描述状态变量信息,包括状态变量的名称、类型、取值范围及可配置与否等信息.耦合模型XML描述文件包括InfoRegion、InitRegion、Sub-ComConfRegion、PortRegion及PortConnection五个部分.与原子模型XML描述文件一样,耦合模型Page10XML描述文件也包含InfoRegion、InitRegion及PortRegion;不同的是,耦合模型没有DeltaRegion和StateRegion,因为其事件处理逻辑及状态变量都分布在所包含的原子模型中,此外其增加了Sub-ComConfRegion及PortConnection两个区段,其中,SubComConfRegion描述子模型的UUID及其参数配置情况;PortConnection描述耦合组件与子组件之间以及子组件与子组件之间的端口连接关系.4.2代码转换器Visicom可视化模型编辑器生成的EDEVS组件化模型文件与平台无关,支持平台间的模型重用,只要实现相应的代码转换器即可.YHSUPE是作者所在课题组开发的一个并行仿真平台,其在基于银河高性能计算机的仿真应用中取得了较高的执行性能,但其采用集中式开发模式,开发协同程度大、模型间耦合度高,较难重用,且其编程过程较复杂,学习曲线较高、二次建模较困难.为此,本文实现了EDEVS模型到YHSUPE模型的代码转换器,将可视化组件建模引入YH-SUPE,以解决以上问题.为了降低代码转换器的复杂度,本文利用YH-SUPE所提供的API实现了一个SpBaseCompo-nent类,此类对EDEVS规范中的元素(端口、事件调度、取消调度等)进行了相应的实现,包含三类接口:(1)组件配置接口voidConfigHandler(SpParameterSet&para).para是〈ParaName,ParaValue〉形式的名值对,用来对组件中名为ParaName的可配置属性配置初始值.(2)连接关系配置接口voidAddSubscriber(char×myPort,char×hisUUID,char×hisPort)用来将UUID为hisU-UID的组件的hisPort端口加入到此组件的my-Port端口的输出列表中.(3)组件业务逻辑接口①端口注册接口(a)voidRegisterInputPort(stringPort-Name,intpri=0);注册名为PortName优先级为pri的输入端口.(b)voidRegisterInnerPort(stringPort-Name,intpri=0);注册名为PortName优先级为pri的内部端口.(c)voidRegisterOutputPort(stringPort-Name,intpri=0);注册名为PortName优先级为件创建时刻调用,用来构造初始事件调度集.②初始事件调度接口voidPrimaryEvent();此接口由仿真引擎在组③事件调度接口(a)voidSendMsgToPort(char×myPort,SpParameterSetpset,SpCancelHandlehandle,doubledelay=1);用来向本组件的内部端口或输出端口发出事件调度.(b)voidSendMsgToSubscribers(char×myPort,SpParameterSetpset,doubledelay=0);用来向输出端口的订购者发出事件调度.pri的输出端口.(d)voidRegisterPortHanler(stringPort,FuncPtrFunc);将端口处理函数Func关联到Port端口.④取消调度接口voidCancelMessage(SpCancelHandlehandle);用来取消事件调度.YHSUPE下的EDEVS组件继承SpBaseCom-ponent类,使用此类提供的组件接口实现自身的逻辑并与其它组件进行交互.图6和图7是利用本文实现的YHSUPE代码生成器转换4.1.1节以及4.1.2节所建立的图形化模型所生成的YHSUPE模型的代码片段.其中图6是头文件片段,图7是实现文件片段.尽管各并行仿真平台的API函数名称不同,但实现的功能集合都大同小异.只要提供相应的代码生成器,就能将Visicom图形化建模生成的EDEVS模型转化为相应并行仿真平台下的实现代码,从而实现仿真平台间的模型重用.Page115总结由于缺乏高效统一的可视化组件建模范式,国内外并行仿真平台往往存在二次建模困难、编程调试复杂和模型难以在平台间重用的问题.本文针对当前广受关注的PDEVS规范所存在的不支持原子模型可视化建模、事件处理逻辑过于集中、无法挖掘处理逻辑内部并行性的缺点,提出了基于MDA的并行仿真可视化组件建模范式———EDEVS,证明了该范式的描述能力不弱于PDEVS,并实现了基于该范式的可视化建模框架及EDEVS建模框架到YH-SUPE仿真平台建模框架的映射,改善了YHSUPE的建模框架,使其能够满足大规模并行仿真分布、快速建模的需要.EDEVS继承了PDEVS的优点,通过基于端口调度的组件化技术实现模型之间的解耦合,提高模型的可重用性;通过模型驱动的建模技术将建模过程与模型的代码实现分开,使建模人员只需关注建模,而无需关注模型在具体平台上的实现,降低了建模复杂度,同时支持模型在仿真平台间的重用,通过在原子模型的定义上引入内部端口,EDEVS将PDEVS的外部处理函数和内部处理函数划分为与外部端口和内部端口相对应的端口处理函数,从而可充分开发各端口处理逻辑的并行性,在不违反因果关系的前提下实现更细粒度的并行,同时提供端口定义及端口之间调度关系的可视化方法,改善了建模效率.
