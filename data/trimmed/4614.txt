Page1云平台下基于隐私保护的桶划分方案1)(国家数字化学习工程技术研究中心(华中师范大学)武汉430072)2)(武汉大学计算机学院武汉430072)摘要DAAS(DatabaseasaService)模式以其管理便捷的特性受到大量组织机构的青睐,同时托管数据的安全也成了迫切需要解决的难题.数据加密对于外包数据的安全起着重要作用,这会降低数据查询效率,因此高效安全的密文查询成为解决数据机密性的突破口,然而,云计算环境下国内外针对DAAS模式密文查询的研究缺少攻击模式下对隐私的深度分析.针对该问题,该文提出了一种DAAS模式下基于隐私保护的桶划分算法.首先根据查询效率指标提出了一种基于遗传算法的桶划分方案;在此基础之上,针对查询的过程中隐私泄漏情况提出了信息泄露的隐私指标体系,并将该指标体系与查询效率进行结合,最后基于遗传算法的桶划分算法对隐私与效率的模型进行最优化,从而获得最优的桶划分方案来确保查询过程中的隐私与查询效率最优的平衡.该算法可以在提高范围查询精确度和系统效率的基础上,降低密文查询中隐私泄露的信息,从而提高云平台中隐私数据的可用性和隐私性.最后,为了验证文中所提方案的可行性,将文中的算法与目前采用的几种桶划分方案进行对比,发现文中的方案在查询精准度上以及在隐私的保护上均优于其他方案.关键词密文查询;桶划分;遗传算法;隐私指标;云计算1引言在云计算环境下,虽然DAAS(DatabaseasaService)数据库外包模式为企业带来了开销的节省等许多优势,但也对机密数据的安全与用户的隐私带来了挑战[1],例如组织机构将用户的个人医疗数据等隐私数据等进行外包,一旦这些隐私数据被非法窃取将会对用户或企业造成巨大的损失.加密机制为DSP(DatabaseServiceProvider)端数据安全提供了重要思路,却也使得数据丧失了许多特性,如有序性、相似性等,这给DAAS系统的数据查询带来很大的困难和挑战.因此,针对数值型数据,如何构建一种既能提高密文的查询效率且能确保隐私的密文索引显得至关重要.国内外针对数值型数据的密文查询进行了大量的研究.目前的研究主要分为两种:一种是直接对密文进行构建可搜索的加密算法,查询结果直接为需要的密文;另外一种是利用hash桶对数据进行分段,返回结果中不仅包含正确的结果也包含其他混淆结果.Qi和Atallah[2]研究了基于同态加密算法的密文kNN查询方法,其将时间开销从二次方变成了线性,然而在提高效率的同时泄露了一些信息(比如盲值的大小等).Agrawal等人[3]提出了一种保持有序的加密方法,但加密数据保持有序性,容易遭到选择密文攻击.Ozsoyoglu等人[4]提出了另一种保序加密方法,极大地减少了加/解密开销,提高了加密数据操作性能,但该方法容易遭受服务器端的统计攻击.IBM研究员Gentry态加密算法,在理论上取得了一定突破,但还存在很大的性能缺陷,实用尚有差距.Hacgümü等人[6]在DAAS模型基础上,构建密文数据分桶机制,从而缩小用户端解密范围,因返回客户端的记录集包含一些不满足查询条件的记录,需由客户端进行解密过滤处理;Wang等人[7]提出了一种桶划分的自适应调整方法STBucket,以减小查询的误检率.宋伟等人[8]通过分析不同查询分布对客户端查询精度的影响,提出了一种面向服务的加密数据高效查询方法AEI,可以很好地适应数据的频繁更新操作,然而对于查询的隐私并没有过多考虑.Hore等人[9]提出了启发式桶划分算法,通过优化算法获取最优的桶数目,并且提出信息熵等指标对算法进行隐私加强,提高对敏感属性的保护效率,然而该算法中并没有给出一个有效的均衡隐私与查询效率的方案.Ciriani等人在文献[10]中针对关系型数据,采用数据分段、加密技术,提出一种系统查询消耗计算模型,并提出一种启发式搜索算法找出系统查询消耗最小的数据分段,但是该方法的时间复杂度较高,并没有很好的平衡安全性和效率的关系.从上述的分析情况来看,国内外针对DAAS模型下密文范围查询的技术虽然已经做了大量的研究,然而它们缺少攻击模式下对隐私的深度分析.关于隐私问题目前还没有一个统一的定义,这是一个挑战性的问题.因此,如何设计一种平衡用户隐私和DAAS查询精度的密文查询算法对于数据的安全具有重要的意义.本文提出了一种DAAS模式下基于隐私保护的桶划分算法.首先根据查询的过程提出了一套密文查询中信息泄露的隐私指标体系,并将该指标体系与查询效率进行结合,最后基于遗传算法的桶划分算法对隐私与效率的模型进行最优化,从而获得最后的桶划分方案来确保查询过程中的隐私与查询效率最后的平衡.该算法可以在最大化范围查询的精确度和提高系统效率基础上,降低密文查询中隐私泄露的信息,从而提高云平台中隐私数据的可用性和隐私性.2密文查询方案的基础模型2.1数据外包模型图1中描述的是在云计算架构下数据外包程序Page3的简单架构.本文假设客户端环境是可信的,服务端的环境是不可信的,服务端的数据是以密文的形式存放.为了查询数据,客户端可以将整个数据表下载下来,然后解密筛选出正确的结果,服务端的功能缩图1DAAS密文查询架构在图1的DAAS架构中,服务端通过webservice的方式将数据的管理功能(创建数据库、表等)、数据查询功能等发布出来,客户端通过webservice调用相应的数据库管理功能,客户端包含3个主要组件:数据加/解密引擎、查询转换器和查询处理器.为了让服务端处理查询,每个加密记录属性值增加1个索引属性(桶id).用户的明文需要桶查询转换器转换成针对桶id的查询.这个转换是查询转化器通过“映射函数”来完成的.服务端执行转换后的查询,返回1个密文结果集.结果集中包含有所有的正确结果,同时也包含“假阳性”的错误结果.随后系统通过查询处理器解密返回的结果集同时剔除“假阳性”结果.另外,客户端需要负责密钥的管理和数据的加解密,由于对列或整个表加密将会导致数据的客户端的负担非常重,同时对每个值进行加密也会使得客户端的加密开销很大,因此,本文采用行加密方式对数据进行加密.密钥的管理问题不属于本文讨论范围.2.2安全假设在本文中,我们主要关注的攻击者具有比较强的攻击能力,其能够攻入数据库服务器,并能够有权访问DSP端的密文数据库.本文的攻击与信任模型如下:(1)假设服务器是半可信的,即其能够执行用户的请求及安全策略,但是会对用户的数据及用户的隐私比较好奇,但却不会破坏用户数据的完整性.(2)我们假设用户与DSP之间的通信信道是安全的,比如现有的安全通信机制(SSL或IPsec),同时我们信任用户的前端,即信任前端是安全的.(3)同时为了防止攻击者通过日志等其他方式减成了一个安全存储容器,然而这样违背了数据库外包的初衷.为了提高查询的效率,需要服务端能够对加密数据进行查询处理.间接获取用户的相关信息,我们对所有的日志信息、用户数据、数据库模式文件等相关文件进行加密存放.(4)假设采用加密算法是不可能被强行暴力破解的.2.3区间查询的理论分析接下来,本文着重研究范围查询的加密索引的建立.在文献[6]中介绍了通过对敏感数据域进行划分,并为每一个条目分配一个桶id,这就是该条目对应的加密索引值.如原始表记为R,服务器端的表将只包含数据库加密的元组(etuple)和相应的桶id.下面给出例子说明:表1和表2分别展示了加密前的明文格式和加密后的密文存储格式.表2中服务端只能看到数据段的加密数据和加密索引(如AS,BS).针对age属性将[25,30]之间划分为a1号桶,而将(30,60]划分为a2号桶;针对salary属性将[4500,4900]划分b1号桶,将[5000,6500]划分为b2号桶.因此,查询时一般的查询将被转换成针对加密索引的查询.如下面的SQL查询语句eid654700750775etuple01101010011011100111000111110010Page4Selectname,agefromRwhereR.B>=5000经过查询转换转化成下面的查询语句SelectetuplefromRSwhereRS.BS=b2其中b1,b2是敏感数据属性salary的桶编号.这种方法所返回的结果一般是正确结果的超集,意味着返回的结果中含有不满足查询条件的记录.为了过滤出这些记录,在客户端需要将返回的结果解密成明文,然后根据原始的查询标准对明文再次查询得到正确结果.这种方式也会出现查询效率与隐私保护的平衡问题.例如当桶的总数量很少而每个桶内数值非常大的时候,只会泄露很少的信息,然而数据需要返回许多的假阳性的结果(极端情况下相当于将整个数据库返回给用户),客户端的通信开销和计算开销都较大.当桶的数量较多每个桶的数据量较少,虽然提高了查询精度,然而却增加了隐私泄露的风险,极端情况下相当于每个值分为一个桶.因此,客户端的桶划分算法的目标就在于如何平衡隐私泄露风险与数据的查询精准性,从而提高查询效率和降低隐私泄露风险,增强对推理攻击的抵抗能力.在本文中我们只介绍单一属性上的桶划分算法,多属性的桶划分算法,只是分别对不同的属性分别进行桶划分算法.接下来,我们首先提出桶划分方案查询效率的模型,并对此模型提出查询优化算法,具体介绍单一属性上的桶划分算法,而后对查询过程中的可能出现隐私泄露分析,并提出相应的隐私指标.最后在此隐私指标的基础之上对查询精准度算法进行改进,从而达到在密文情况下数据查询的精准性与隐私安全的平衡.3面向精准度的智能化桶划分算法3.1基础模型构建为了简化分析,本文的桶划分算法的研究对象主要是数值型的离散域,如整数Z.假设关系为R=(V,F),其中V是不同的数值,在敏感属性域中每个数值至少出现了一次.F是每个数值对应的频数.P是范围查询Q的分布.使用最优桶划分算法将R划分到M个桶中,确保所有的范围查询的“假阳性”错误总数最小.具体的概念详见表3.符号Vmin给定属性的最小取值Vmax给定属性的最大取值N不同值的个数R明文关系|R|关系R的元组个数V[Vmin,Vmax]区间内所有的出现的数值的集合F[Vmin,Vmax]区间内所有出现的数值对应的频数nn=|V|=|F|RS加密的关系表M桶的数目QR上的所有范围查询的集合qq是Q中随机的一个查询q=[low,high],其中low,high∈[Vmin,Vmax]Q桶级别的查询的集合qq是桶级别查询集合Q中的随机查询T(q)T(q)是转换函数,它将原始查询q∈Q转换成桶查询q∈Q为了简化模型,本文主要考虑查询分布为均匀分布的情况.因此,密文数据划分为M桶的情况下,所有的可能的查询概率相同且为2的C2n=假设每个桶的密文元组规模为N1,N2,…,NM,针对任意K个查询,每次查询返回的正确结果为C1,C2,…,CK,K次查询返回的元组总数为T1,T2,…,TK,因此,查询的平均查询准确度(QueryAccuracy)如式(1)所示QA=其中假阳性值(TotalnumberofFalsePositive)错误总数如式(2)所示因此,根据式(1)和(2)可知,为了提高查询精度,提高密文的查询效率需要最小化“假阳性”错误总数.首先考虑关系的单个属性的情况,这个属性的值域是有序的离散域,在本文中,属性值域假设为非负整数域.针对桶i,假设其中有Ni个不同的值,Vi代表分布在桶i的数据集合,Fi={fPage5为Vi中对应的Ni值的频数.在查询的一端落在桶i的情况下,接下来建立桶i的“假阳性”错误总数(TFP)模型.定义1.假设查询的最小端位于桶i的qi的集合记Qi,其中qi=[l,h],l∈Vi,即viQi中查询的右端h位于第i个到第M个桶之间的任何一个桶中.在该情况下,任意两个桶之间没有范围交集,即任意桶中不存在值vivikvi同时满足桶[1,3],[2,4]的范围),整个划分的TFP是相对最小的.max;(2)vj针对上述命题,用反证法证明,假设在桶i,j之间存在空间交集的情况下,即存在lvi足上述条件a和b,且TFP的值最小.针对l落在桶i的任意查询q,其h端位于桶x中时,因此需要对桶i和x之间的桶进行查询,同时还要取出vi桶j(桶j不位于桶i和x之间),所以针对查询的整个划分方案的TFP为Ui+Ux+TFP(j),其中Ui为桶i中l离桶i中最小值之间的值的频数之和,UM为h离桶M最大值之间的值的个数(频数之和),TFP(j)为桶j的TFP.然而当将vi中时,TFP仅为Ui+Ux,因此,假设不成立,定义1成立.当任意两个桶之间不存在范围交集的情况下,且桶按照由小到大的顺序排列.为了计算整个方案的TFP,我们以查询为着手点,分析在这些查询的情况下每个桶内部的TFP情况.假设Qt为长度为k的查询集,其中qk=[left,right]为查询区间为k的任意随机查询,因此,所有长度为k且与桶i有交集的个数为Ni+k-1.然而针对其中任意元素e而言,仅有k个查询与元素e有交集,对于另外的Ni-1个查询而言,其作为假阳性值返回.然而,对于同时跨越两个不同的桶的qk,其对假阳性值的贡献也分为两部分.因此,当遍历所有的查询请求qk时,其对应假阳性值如表4所示.从表4中可以看出每个查询的条件概率均为1Ni+k-1的个数为Ni+k-1,且这些查询又是等概率.因此,在查询长度固定的情况下,对于所有交集的qk的假阳性值之和为情况下桶i的假阳性值如式(3)所示.High位置为i桶的第1个值为i桶的第2个值为i桶的第3个值为i桶的第k+1个值为i桶的第Ni个值TFP(i)=pQ·pi·其中pQ为长度为k的查询占所有的查询的比例,pi为与桶i有交集的且查询区间为k的查询占所有长度为k的查询的比例.式(3)中的假阳性主要包含两部分,其中一部分是整个查询请求位于桶i内部;另外一部分是查询请求跨越桶i和其他的桶j,在式(3)中仅计算了对桶i的影响,另外一部分对桶j的影响将在桶j的TFP中体现出来.因此,整个方案的假阳性值等价为所有长度的查询请求带来的假阳性值,其为所有桶的假阳性值相加,具体如式(4)所示通过式(4)可知,由于N为总的值的数目,针对具体的数据集而言是一个固定值,因此为了降低查询的“假阳性”错误以提高密文查询的准确率,需要对所有桶的NiFi之和进行最小最优化.3.2面向精准度的智能桶划分算法为了降低查询中的“假阳性”错误,需要对MNiFi进行最小化处理.该问题可以归结为是集合∑i=1划分的问题,将元素划分在不同的数据集合中确保“假阳性”目标函数最小.集合划分问题在数学上是十分困难的问题,也是经典的NP-hard问题[11-14],Page6因此不可能在多项式的时间内计算出最优值,因此本文采用遗传算法启发式思想设计了面向精准度的智能桶划分算法(Precision-OrientedIntelligentPartitioningAlgorithm,POIPA)来优化该假阳性指标,进而优化查询精准度,给出查询方案.(1)适应度函数由于遗传算法适合求目标函数的最大值,同时本文研究的范围为正整数范围,Ni·Fi一定为正数因此,本文的假阳性模型进行取倒,适应值的范围在[0,1]之间,具体形式如式(5)所示其中X={x1,x2,…,xN}表示桶的划分方案,xi表示第i个Vi值所对应的桶的标号,且集合V中数值均是按照由小到大的顺序进行排列.(2)基因表示POIPA算法的最优化问题MaxFit(X),其变量可以采用二进制编码来表示染色体.数字串的位数取决于变量的取值范围以及期望达到的精度.针对整数区域的最大值求解问题,除了二进制编码之外,还有一种十进制编码,这两种编码方式各有优缺点.然而,在本模型中,在桶的数目不为2n的情况下,迭代的过程中会消耗大量的计算资源和空间进行判断交叉变异后种群的合法性,因此,本文采用十进制编码.在基因中采用一个十进制位表示一个变量,从而确保每个Vi只会出现在一个桶中,具体的表现方式如图2所示.(3)算法过程遗传算法的初始种群是均匀分布,若单纯利用POIPA方法调整桶的划分需要较长时间,不利于服务质量的稳定.因此,为加快密文分段的划分,种群初始化时将equi-width方法划分得到的划分机制作为初始种群的一个染色体,再利用POIPA方法进行动态调整和优化,在优化的过程中利用精英保留策略,将父代最优的值传递子代中直到目标函数达到最优.具体的算法如算法1所示.算法1.面向精准度的智能桶划分算法.函数原型BestBucketPartition(intbucketNum,int[]value,int[]freq)输入:划分后桶的数目bucketNum、敏感属性的不同取输出:最佳分桶方案1.initialPopulation(PopSize);2.for(i=0;i<MaxPopulation;i++){3.select(ipop,lastBest,curBest);4.Crossover(ipop,crossPara);5.Mutation(ipop,MutationPara);6.Elite();//利用父代的最佳值替换子代中最差值7.ReturnBest;}8.voidselect(String[]ipop,BestlastBest,9.for(inti=0;i<popNum;i++)10.evals[i]=calculatefitnessvalue(ipop[i]);11.generateNextPop(evals,nextpop);//轮盘选择法12.ipop=nextpop;13.if(generation>=1){//运行的代数大于114.Worst=FindWorst(ipop);//找出本代最差值15.Worst=Best;}16.voidElite(){//17.curBest=findcurBest(ipop);18.if(Best.fitness<curBest.fitness)19.Best=CurBest;}注.Best为全局最优划分,curBest为本代最优划分.POIPA算法中的种群初始化为了加快收敛速度,构建PopSize个个体.初始化函数是利用随机数生成器,为每个个体生成popNum个[0,bucketNum)之间的正整数,形成染色体方案.在初始化的过程中,将equi-width方案作为种群的一个染色体,即将value集合的值按照顺序进行均匀划分到bucketNum个桶中.初始化种群之后,计算本代中所有染色的适应值(参照式(5)),然后根据计算出每个个体的适应值与整个种群的适应值的比值,并随机产生(0,1)之间的浮点数确定选用哪个染色体.同时为了确保收敛Page7速度,采用了精英保留策略,通过将选择出来的新种群中的最差的染色体方案替换为全局最优的染色体方案,这样将全局最优的染色体方案能够进行杂交和变异,进而在此个体之上产生更加优秀的子代个体.在选择出适应值好的父代之后,根据交叉因子确定杂交对数,然后随机选择一对个体,进行单点交叉,形成中间种群,而后在中间种群中,随机抽取(变异因子PopSize)个个体,然后在选择的个体中随机选择一个基因位在[0,bucketNum)之间进行随机变异.由于初始化的过程将equi-width方案加入了种群,因此需要加大变异因子,以免陷入局部的最优方案中.在完成交叉变异之后,查找出子代中最好的个体并与全局最优方案比较,选出两者中最好的个体作为新全局最优方案.POIPA算法的时间复杂度是O(npopNum),外层循环是遗传算法的经历的代数,内层循环次数是总群的个数(总群个数是常值).每一代中的选择、交叉、变异等操作都会花费O(popNum)时间.算法的空间复杂度是O(n),主要是来自于存放染色体的空间.4面向隐私保护的智能化桶划分算法4.1攻击模型上一节中提出的介绍的提高精准性的查询的优化算法,虽然能够有效地提高查询的精准度,然而,在一定程度上威胁到了数据的隐私安全.其构建的索引是建立明文与密文之间的桥梁,这种对应于映射关系很可能为推理攻击以及数据分析等攻击技术提供了数据库内容重构及破解索引含义的可能性.因此,评估和量化公开的信息或索引的信息泄露的系数是非常重要的,这将为桶划分的方案的查询效率与隐私安全的均衡提供很重要的依据.针对DAAS的推理攻击主要分为两大类[15],其主要是根据攻击者的先验知识程度不同的进行分类,然而在这两种的情况下攻击者对密文数据均具有绝对的控制权.第1种推理攻击在攻击者仅知道数据库中的数据频数以及数据库的密文来进行攻击,这种称为Freq-attack.这种场景下,攻击者对数据库中明文数据的分布规律非常了解,这种分布可以是具体的,比如存放用户薪资的数据库的薪资频数,当然也可以是近似的.在本文中,我们考虑攻击者知道数据库的具体频数这种比较强的攻击方式.在这种情况下,攻击者攻击的对象主要是两种:第1种是对明文数据的攻击,即通过掌握的数据库的分布,去猜测具体某个密文的值;第2种是对索引的攻击,即根据映射关系,推导出明文与索引之间的对应关系,从而分析出数据库的密文以及用户的隐私.第2种推理攻击在攻击者知道数据库的明文与密文来进行攻击,即攻击者知道原始数据库的明文以及密文数据库,却不知道明文与密文之间的对应关系(索引).因此,这种情况下,攻击者需要攻击的是对索引与明文的对应关系进行攻击,从而来明确掌握用户新插入数据的含义及意义.然而这种攻击方式的条件太强,不属于本文的考虑范围.Freq-attack推理攻击也分为简单的推理攻击和利用统计的推理攻击.简单的推理攻击的依据主要是通过索引的相同个数以及密文的相同个数来确定.例如:针对那些直接对密文进行一一对应建立索引的情况,如果某敏感属性的索引值完全相同,推断出这两个数字的明文相同,再结合数据的分布情况就可以推断出其中出现次数较多的数据.密文数据库的简单推理攻击等价于根据索引出现次数将其归为同一个等价类中.下面以2.3节中的案例进行推理分析.age.2=a1,a{salary.2=b1,b{}2=5000,4500,4700,在这种情况下,由于明文与索引之间是多对一的关系(等价于将4个数据划分到2个集合中),同样索引与密文之间也是多对一,因此直接根据明文出现的次数进行分析对这种桶划分机制的攻击较弱.每个值的信息泄露概率就是属性值的基数的倒数,如表5所示.整个表格的索引推理攻击信息泄露为每个值信息泄露概率的乘积,具体如式(6)所示Page8其中t遍历所有的元组即行数,c遍历所有敏感属性即列数,其中pt,c由式(6)可知,上述案例中的整个表格的索引推理攻击信息泄露就是()1数据库而言,期望于利用简单推理攻破这种索引是不切实际的.因此,针对本文的桶划分方案,本文主要考虑的攻击场景为Freq-attack的统计攻击对数据库内容进行攻击.客户端使用非确定性加密算法加密用户的敏感属性的值,假设该加密算法是不会被破解的,因此攻击者不能通过解密数据来获取敏感属性的明文.对于给定的元组,攻击者能做的就是用比较高的概率去估计这个密文的真实明文值.在这种情况下,攻击者需要获得整个桶的划分机制(这个可以通过大量的统计分析获得,简单推理无法获得),并根据这个划分模式,加上利用统计估计技术和大量统计实验,不断的缩小数据的范围,最终以比较高的概率猜测出该值的最小范围,这种方式的代价非常大.为了简化分析,本文假设处在最坏的情况下即:攻击者已获得整个桶划分机制,同时通过统计的方式知道每个值的频数.但是攻击者不能将每个加密元组与值进行对应,因为同一个桶中的加密属性的值是一样的.为了对统计攻击下的信息泄露进行度量,本文提出两个隐私指标:方差以及方差之方差.4.2隐私指标由于攻击者采用统计攻击的方式,因此,桶划分方案中数据的分布规律指标如方差、方差之方差需要进行增强以抵抗攻击者的统计攻击.本文定义估计误差方差SEE(SquaredErrorofEstimation)以及方差之方差.定义2.估计误差方差:假设桶K内部元素的分布律为随机分布XK,PK是对应值的概率分布值,那么其对应的离散值概率为pk.攻击者为了猜测加密元组的真实值,通过大量的统计拟合出桶K的元素的评估分布律YK,对应的概率函数为pk.然而猜测值与真实值之间存在误差,为了衡量该误差,提出估计误差方差SEE,即真实值xi与猜测值yi之间的欧式距离的平方.具体表现形式如式(7)所示SEE=E(‖XK-YK‖2)=∑=∑=∑=∑∑2∑=E(X2)+E(Y2)-2E(X)E(Y)=Var(XK)+Var(YK)+(E(X)-E(Y))2(7)从式(7)可以得知,攻击者A为了尽量减小估计均差误差SEE,其可以通过以下两种方式:(1)减少A估计的数据分布的方差值Var(YK);(2)减小桶内数据的真实分布均值与猜测分布均值之间的差值(E(XK)-E(YK)),其中桶K内数据的分布均值为E(XK)=∑在统计上获得与真实值最接近的猜测值的统计分布形式为两个分布的均值要相等,E(XK)=E(YK),且Var(YK)=0.因此,客户端可以通过提高Var(XK)增加攻击者的攻击难度,即尽量保持桶内数据分布保持无序状态,从概率角度提高密文数据的安全性.因此为了确保整个方案的泄露信息量尽量少,需要确保所有桶的分布方差的期望尽量大,∑Var(XK).定义3.桶的估计方差:数据划分为M个桶,整个划分的机制的随机分布为X,桶i对应的分布为Xi,其对应的概率为pi.通过式(7)可知为了保证每个桶内部密文数据的安全需要提高VarX()i,然而当一个桶的VarX()i增加很有可能导致其他桶的Var值降低,这样容易导致一部分桶的Var值很高,而另一部分桶的Var值很低时,那么Var值低的桶内部的密文值就很容易被攻击.因此为了确保所有的桶的Var都相差不大,本文提出了方差之方Page9差VarofVar的概念,具体形式如式(8)所示VarofVar=∑为了衡量方案的信息保护能力系数,我们将Var指标与VarofVar进行归一化处理procoe=β其中β,γ是由用户定义的系数.4.3隐私与性能的权衡假设原始的数据集合为{x1,x2,…,xN},并将数据集合划分为M个桶中并保证数据只出现在唯一的一个桶,xi∈Bk,i∈[1,N],k∈[1,M],Bi∩Bj=,i,j∈[1,M].为了保证划分后密文数据的查询的准确率,同时保证桶的划分机制泄露的隐私最少,需要对这两组相互矛盾的指标进行最优化处理,即对第3节中TFP指标进行最小化,对桶内数据分布方差指标∑要对VarofVar指标进行最小化处理,这是一个多目标最优化的问题.为了简化将多目标最优化问题进行统一指标转换成用于寻求隐私和准确率的单目标priv_eff的最优化问题,即将对应的指标进行反正切转换(arctan(X)+π/2)将值域映射到[0,π]中,并根据用户的定义权重来确定两组指标的重要性,具体形式见式(9).priv_eff=由式(9)可知,为了确保准确率和划分机制可能泄露的隐私信息最小,需要对隐私和准确率均衡指标priv_eff进行最大化优化.该问题依然归结为是集合划分的问题,经典的NP-hard问题,因此针对该问题本文采用精英保留遗传算法的思想来优化该指标,并利用该思想设计面向隐私保护的智能桶划分算法(PRIPA),进而确保查询精准度和可能泄露的隐私均达到最优.PRIPA算法的核心就是将指标priv_eff进行最大化最优处理.PRIPA算法为加快密文分段的划分,与PROPA算法类似将初始种群,将equi-width方法划分得到的划分机制作为初始种群的一个染色体,然后在初始种群进行迭代,在迭代中不断寻求本代中最优值进而找出全局最优解,同时为了加快收敛,算法利用精英保留策略对,将父代最优的值传递子代直至全局最优解收敛到固定值.具体的算法如算法2所示.算法2.面向隐私保护的智能桶划分算法.函数原型BestBucketPartition(intbucketNum,int[]value,int[]freq,float[]para)输入:划分后桶的数目bucketNum、敏感属性的不同取输出:最佳分桶方案1.initialPopulation(PopSize);2.for(i=0;i<MaxPopulation;i++){3.select(ipop,lastBest,curBest);//保留子代最好值4.Crossover(ipop,crossPara);5.Mutation(ipop,MutationPara);//变异操作6.Elite();//利用父代的最佳值替换子代中最差值7.ReturnBest;}8.Voidcaculate(){9.TFP=caculateTFP();10.VarSum=caculateVar();11.VarofVar=caculateVarofVar();12.pri-per=caculatePriv_Eff(TFP,VarSum,PRIPA算法主要的核心算法与PROPA主要思想基本一致,均是利用迭代遗传算法对初始均匀的种群进行迭代,在指标priv_eff最优的约束下使得种群不断朝着priv_eff最优的方向进化.为了加快迭代收敛速度,采用了精英保留策略,通过将选择出来的新种群中的priv_eff最差的染色体方案替Page10换为全局priv_eff最优的染色体方案,这样将最优的染色体方案能够进行杂交和变异将最优的基因遗传到后代中.对选择出来的种群进行单点交叉和单点变异,形成新种群.在完成交叉变异之后,比较子代中最优方案与全局最优方案,选出两者中最好的个体作为新全局最优方案,直到局部最优方案与全局最优方案的priv_eff基本一致,即两者的之差的绝对值小于10-n.5实验设计与分析为了验证基于遗传算法的隐私增强算法,进行相关的性能测试和功能验证.下面简单介绍实验环境.5.1数据集介绍为了更加贴合实际,整个实验在开源云管理平台opennebula搭建的云平台中进行,实验环境中包含6台物理机和12虚拟机.云平台中所有服务器为同等配置,均为2×AMD皓龙2370×4核,16GB内存,千兆以太网网卡.在云平台中,每个物理机的系统为Linux,底层利用Xen3.3来实现对物理平台的虚拟化,平台中虚拟机的版本为Windows系统.其中一台虚拟机作为DSP用来存放外包的数据.其余11台虚拟机作为用户端.5.2数据集介绍为了测试算法的可用性、效率、安全性性能以及相互之间的制约关系,本文分别采用随机函数模拟数据集均值为5000方差为100的正态分布数据集、均匀分布的合成数据集(数据区间为[1,10000],数据规模为40万条)和真实的数据集TPC-H中的表格partsupp中的ps_availqty属性(区间为[1,10000],数据规模为80万条)等数据集对算法进行测试,数据规模为80万条记录.本文根据不同的数据集分别利用随机数生成器均匀产生不同的查询集,每个查询集规模为10000.每个查询根据对应的数据集合范围随机产生两个不同的数值组合成一个查询,这样确保了查询的随机性与公平性.针对上述的数据集,本文分别针对QoB算法、CB算法、equi-depth算法、PRIPA算法、PROPA这5种算法,测试相应的准确率指标和隐私保护指标.下面具体介绍相应的指标及相应的测试结果.5.3性能及结果分析(1)准确率QA为了评估本文算法对密文数据的查询准确率在实验中分别利用合成数据集和真实数据集测试了上述5种算法的QA值,其中CB算法的退化率为2、PROPA算法的用户隐私参数分别为α=0.25,β=0.5,γ=0.25,并以PRIPA的QA值为基准值,计算出其他3种算法的值与该值的比值关系,具体见图3所示.在图3(a)中可以看出在数据服从均匀分布且用户查询均匀时,其他几种算法的查询精准率QA与本文算法QA的比值均明显小于1,这说明PRIPA算法相对于其他几种算法而言其效果要优异许多,尤其随着划分桶的数目增加,其效果体现的更加明显.从图3(b)中可以看出,当数据服从正态分布时,所有的算法与PRIPA算法的查询精度比值随着桶的数量增加而降低,在桶为450的时候所有算法与PRIPA精准度比值达到最低.在图3(c)中,刚开始的效果比较稳定,当桶的数量为350的时候查询精度比值骤降,这可能与ps_availqty的数据分布有关,在桶为500时其他算法的查询精度仅为PRIPA算法的30%左右.从以上的3个子图中可以看出,PRIPA算法的桶划分方案查询精度优于其他几种方案.(2)查询性能与隐私的均衡图4描述了查询精度与保护能力系数的均衡效果.我们取每种算法(QoB算法、CB算法、equi-depth算法、PRIPA算法、PROPA算法)的10组数据,这10组数据分别表示桶的划分数量在100,150,200,…,550的情况下,查询精度与procoe(该值越大说明隐私保护能力越强)坐标值.从图中可以看出,整体趋势上测试过程中的5种算法的查询精度与procoe值是相互制约的,查询精度高则procoe低,反之则procoe高查询精度低.在图4的右侧是PRIPA、QoB、equi-depth这3种算法的查询精度和procoe值的坐标值,其查询精度较高,然而这3种算法的procoe值较小,意味着他们对统计攻击能力较弱很容易泄露桶内数据的安全.CB算法在QoB算法的基础上对数据进行随机化提高了数据安全性同时也兼顾了对查询精度但是没有达到最优的均衡效果,本文的PROPA算法的方案相对其他几种算法而言,其安全性与查询精度均是比较优异的,达到了对安全性与查询精度的有效均衡.Page11图3查询值正态分布正确率6结束语为了均衡云环境下外包数据的隐私性与查询效率,本文首先提出了桶划分模式下查询效率指标,并提出了一种基于遗传算法的PRIPA算法对该指标进行优化.为了提升PRIPA算法的隐私保护能力,本文分析了查询过程中可能存在的信息泄露情况,提出了一套隐私保护指标,并将该指标与查询效率进行结合,提出了用于均衡查询效率与隐私性的PROPA算法.为了验证本文方案的正确性,本问题与目前的几种常用的算法进行对比,最后结果发现,本文的方案相对于其他的几种方案而言,在查询效率与隐私均衡上均有较好的效果.虽然本文的方案提出了一种均衡查询效率和隐私保护能力的桶划分方案,然而其只能适用于单一敏感属性,并没有涉及组合属性的情况.同时,本文的研究过程中没有深入的研究查询的分布与数据分布的之间的关系.这些问题是本文下一步研究工作的重点.
