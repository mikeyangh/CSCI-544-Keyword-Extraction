Page1基于偏序约简程序可达图的并发程序切片方法戚晓芳1),2)徐晓晶3)江振亮1),2)汪鹏1)1)(东南大学计算机科学与工程学院南京211189)2)(东南大学计算机网络和信息集成教育部重点实验室南京211189)3)(IBM中国系统与科技实验室上海201203)摘要并发程序切片是一种重要的并发程序分析手段.基于程序可达图可构造以程序状态和语句二元组为节点的、依赖关系具有可传递性的并发程序依赖图,解决依赖关系的不可传递性问题,提高切片精度.程序可达图通过交织执行模拟并发活动,分析代价较高.偏序约简是一种十分有效的并发系统状态空间约简技术,约简的并发系统状态空间包含所有的并发程序执行代表.为提高效率,该文将偏序约简技术扩展到程序可达图的约简中,在偏序约简理论的基础上,证明了基于未约简和约简的并发程序可达图构造的并发程序依赖图在进行切片计算时是等价的.实验结果表明,采用偏序约简技术使基于程序可达图的并发程序切片方法在保证切片精度不受损失的前提下显著提高切片效率.与其它高精度切片方法相比,基于约简程序可达图的切片方法的精度更高,在大多数情况下,切片效率也有一定提高.关键词并发程序;程序切片;依赖性分析;可达性分析;偏序约简;程序分析;软件测试1引言多核技术的普及、高级编程语言对并发设施的支持以及实际应用需求的不断增加,使得并发软件的开发和使用日益广泛[1].由于并发与竞争的存在,并发程序具有不确定性,这种不确定性给并发程序的分析理解和维护带来了新的困难和挑战[1-3].程序切片是一种重要的程序分析理解方法,用于从原有程序中抽取对特定语句有影响的程序成份以构成新程序,通过分析这种简短的新程序(称为程序切片)达到简化原有程序分析的目的[2-3].目前并发程序切片研究尚未成熟,还存在着如何有效表示并发程序、提高并发程序切片的精度和效率等问题有待解决[4-19].对并发程序切片进行深入的研究不仅可丰富并发程序分析理解和维护的理论基础,还可将其研究成果广泛应用于并发软件的分析理解、调试、测试、度量等并发软件的工程活动之中.现有的并发程序切片大多先基于并发程序流图进行依赖性分析,然后构造并发程序依赖图,再遍历依赖图以计算切片[4-15].由于不同并发单元中可并发执行语句间的数据依赖(干扰依赖)的引入,并发程序语句间依赖关系具有不可传递性,简单遍历并发程序依赖图将不可避免地引入冗余语句,导致切片精度较低[4-6].为解决依赖关系不可传递性问题,人们根据依赖序列应满足执行的先后时序要求,提出在遍历并发程序依赖图时进行附加判断,去除了部分冗余语句[7-15].尽管这些方法从某种程度上提高了切片精度,但未有效解决依赖关系不可传递性问题.某些依赖序列满足执行先后时序要求,但当存在其它并发单元对共享变量的重新定义时,依赖关系仍有可能是不可传递的,并发程序切片的精度仍需进一步提高[11-12].为解决上述问题,我们提出一种基于程序可达图的并发程序依赖性分析方法,该方法可解决依赖关系不可传递性问题,获得高精度的并发程序切片,精度较其它高精度并发程序切片方法有明显提高[16-19].但程序可达图通过交织执行模拟并发活动,可达图存在状态爆炸问题[20].与其它高精度并发程序切片方法类似,基于程序可达图的并发程序切片方法具有指数级的复杂度,切片效率较低,并发程序切片技术的应用因此受到较大的限制[16].偏序约简技术是一种十分有效的并发系统状态空间约简技术,约简的并发系统状态空间包含所有的并发程序执行代表.当并发单元之间的交互作用较少时,在某些情况下,通过约简并发系统的状态空间可从指数级增长下降为多项式级增长[21-23].本文在前期工作的基础上,将偏序约简技术应用到程序可达图的约简中,在不损失切片精度的前提下,提高分析效率.为方便理解,文中首先通过两个实例说明并发程序中两类依赖关系不可传递性问题,然后给出我们在前期工作中提出的基于程序可达图的依赖性分析方法[16-19],并在偏序约简相关技术和理论的基础上证明基于未约简和约简的并发程序可达图所构造的并发程序依赖图在进行并发程序切片计算时是等价的,同时实现了相应的切片算法和目前其它主要并发程序切片算法,进行实验研究,最后给出相关工作比较和结论.2依赖关系不可传递性问题Krinke和Nanda[9-12]所研究的基于共享变量的通信是一种经典的基于共享变量的并发机制,对它的研究具有普适性,易扩展到Java、C++等语言的并发程序研究中.为此,本文以Krinke和Nanda所研究的并发程序为例进行分析.本文所研究的并发程序是所谓的轻度并发程序,由一组线程组成,各个线程共享同一地址空间.线程间通过共享变量进行通信,共享变量的读写是原子操作,用cobegin和coend分别表示线程的创建和终止.设Si与Sj为并发程序的两个语句,若Si与Sj并发执行,Si执行时使用到Sj定义的变量,则称Si干扰数据依赖于Sj.在并发程序中,干扰依赖可产生两种类型的依赖关系不可传递性问题,即依赖时序问题和共享变量重定义问题[11-12].依赖序列因不满足语句执行的时序要求而产生的不可传递性问题,Page3称作并发程序依赖时序问题(TimeTravel)[9-15].图1(a)给出一个实例,实例1由4个线程组成,主线程θ1创建3个并发执行的子线程θ2、θ3和θ4,各线程通过共享变量x和y进行通信.S6使用共享变量x干扰依赖于S4,类似地,S4干扰依赖于S7,由于在θ3的控制流图中不存在S7到达S6的路径,〈S7,S4,S6〉不满足时序要求,S6不可能依赖于S7,〈S6,S4,S7〉中的依赖关系是不可传递的.在并发程序中,某些依赖序列尽管满足语句执行的时序要求,但由于共享变量的重新定义,仍可能产生依赖关系不可传递性问题,本文将这类问题称作共享变量重定义问题.图1(b)给出文献[11]中的一个实例,实例2中S3干扰依赖于S4,S4数据依赖于S1.〈S1,S4,S3〉满足时序要求,但由于S2中对共享变量x的重新定义,S3依赖于S4与S4依赖于S1不能同时发生,使得〈S3,S4,S1〉中的依赖关系不可传递.目前,大多数并发程序切片方法采用并发程序流图表示并发程序的执行,而并发程序流图中并行流被简单地视为分支流处理,尽管增加了干扰数据的依赖分析,但没有从全局分析并行流间的数据依赖关系,造成上述两类依赖关系不可传递性问题.3线程交互可达图及其偏序约简技术欲解决上述问题,需寻求一种全局的并发程序表示方式[16].可达性分析对并行流进行顺序化处理,基于程序可达图可从全局进行并发程序依赖性分析,解决依赖关系不可传递性问题[16].为避免语句级的可达性分析造成分析代价过高等问题,在不影响分析精度的前提下,本文采用线程交互图对线程进行粗粒度的表示,再进行可达性分析,从而生成线程交互可达图,在可达性分析过程中采用偏序约简技术进一步降低可达图的复杂度,提高分析效率.3.1线程交互可达图并发程序由一组线程组成,每个线程是一个顺序执行流.为方便描述,文中对共享变量读写、线程创建或等待线程终止等涉及到线程之间交互的语句,称为交互语句,这些语句在所在线程外是可见的.除交互语句以外的语句称作非交互语句,非交互语句在所在线程外是不可见的.在并发程序中,交互语句的执行顺序一旦确定,非交互语句的不同顺序的交织执行对并发程序的执行结果和依赖分析不产生影响.为此,根据交互语句,我们可对线程分块或程序段(称线程域)进行分析.给定某线程的控制流图(CFG),采用下列方法构造线程域:从入口语句或交互语句的后继语句起始,沿CFG路径到达最近的交互语句或出口语句终止,被遍历的一个单入口、多出口的CFG子图所对应的程序段为一个线程域.每个线程域表示一个程序控制点,即将执行该线程域所包含的程序段.将每个线程域用一个节点表示,节点间的边称作变迁,表示相应的交互语句及其之前所有非交互语句程序段的执行,由此可生成线程交互图.定义1.给定线程θ,其线程交互图(TIG)是一个五元组〈N,T,ns,Σ,υ〉,其中:节点集N是线程域集,边集T是变迁集,TN×Σ×N,ns是初始状态,Σ是变迁标签集,υ是标签函数,对T中的每个变迁映射为Σ中的一个标签.在定义1中,变迁分为共享变量读写、线程创建和等待线程终止,每类变迁的标签仅与交互语句有关.共享变量读写变迁的标签为该共享变量读写语句的标号,线程θ创建和等待各子线程θ1,θ2,…,θk终止变迁的标签分别为θ→(θ1,θ2,…,θk)和θ←(θ1,θ2,…,θk).若t∈T,t=(n,e,n),n,n∈N,n和n则分别记为pre(t)和post(t),t所在线程记为Active(t),t中使用的共享对象的集合记为Used(t).实例1的4个TIG图如图2所示.Page4给定并发程序CP,各线程的线程交互图TIGs=i=1〈Ni,Ti,nis,Σi,υi〉,共享变量集合为O=∪r∪p并发程序的全局执行空间可通过可达性分析,生成线程交互可达图来表示.可达性分析从初始状态出发,执行在该状态下可能发生的变迁,生成后继状态,再从这些后继状态出发执行可行变迁,如此反复,直到没有新的状态生成.定义2.线程交互可达图(TIRG)是一个四元组A=(M,m0,TG,ΔG),其中:节点集M是全局状态集,m0∈M,表示初始状态,边集TG是变迁集,TGM×ΔG×M,ΔG是变迁标签集.在定义2中,全局状态通过各线程的程序控制点以及共享变量的取值表示,全局状态集MN1×N2×…×Np×V1×V2×…×Vr,V1,V2,…,Vm分别为共享对象O1,O2,…,Or的取值空间.在可达性分析过程中,后继状态中的线程域分量与前驱状态除发生变迁的线程的分量发生变化外,其余分量不图3实例1的TIRG图若m∈M:(m,t,m)∈TG,则称在m下可发生变迁t,记在m下可发生变迁组成的集合为Enabled(m).若(m,t,m)∈TG,则称在m下发生t变迁后到达m,记为(m,t)→m.设ω为一个变迁序列,ω=t1t2…tn,当且仅当满足(m=m1,t1)→m2∧(m2,t2)→m3∧…∧(mn,tn)→mn+1=m时,称在m下发生ω变迁序列后到达m,记为(m,ω)→m.定义3.给定某并发程序CP,设CP的局部变迁集合为T,全局状态集为M,则IT×T,I是变迁独立关系当且仅当(t1,t2)∈I满足:m∈M:(t1≠t2∧(m,t1)→m1∧(m,t2)→m2)独立关系的补集称作依赖关系,若独立关系为变.为方便描述,称定义1中变迁集T中的变迁为局部变迁,定义2中变迁集TG中的变迁为全局变迁,TG中每个全局变迁与T中的某个局部变迁相对应.全局变迁分为共享变量读写以及线程创建和终止等3类,其标签与定义1中局部变迁类似.实例1的TIRG图如图3所示,从初始状态m0=(1,-,-,-,x=?,y=?)开始,其中-表示线程处于未激活或执行已终止,?表示未初始化,发生θ1创建θ2,θ3和θ4变迁后,生成m1=(2,4,6,9,x=5,y=10).在m1下,可发生标签为S4,S6和S9的变迁.执行S4变迁后,改变m1中θ1的分量和x的值,生成m2=(2,5,6,9,x=15,y=10).类似地,执行S6和S7变迁,则分别生成m3和m4.从这些状态出发执行可行变迁,生成新状态,反复上述过程,直至生成终态m15和m16.图3中完全扩展线程可达图的状态数为17,变迁数为23,变迁序列数为12.I,则依赖关系D=T×T\I.按照变迁独立关系的语义,判断变迁独立和依赖关系需考虑并发系统所有的全局状态,操作十分困难也不可行.一般地,我们通过一个语法检查的充分条件来判断两个变迁之间是否依赖.当满足下列条件之一时,t1与t2依赖:;一个变迁对O中的共享对象进行写操作.(1)(pre(t1)∪post(t1))∩(pre(t2)∪post(t2))≠(2)Used(t1)∩Used(t2)≠且t1和t2中至少有在条件(1)中,当pre(t1)∩pre(t2)≠时,t1与t2的依赖也称作冲突依赖.在条件(2)中,若t1和t2对某一共享变量均进行读操作,则t1与t2之间不产生依赖.在偏序约简过程中,一般只需考虑冲突依赖和并行Page5执行变迁之间由于共享变量读写产生的依赖[21-22].传统偏序约简技术在描述并发系统全局状态时考虑了各并发单元的控制点和各共享对象的值,主要由于待检验性能不仅与控制流还与数据流密切相关[21-23].而程序依赖分析仅需提取并发程序的控制流信息,因此,可将具有相同控制点分量、不同共享对象分量的状态节点合并为一个节点,生成一个简化的线程交互可达图表示并发程序执行.在图3中,若分别将m11与m12,m13与m14,m15与m16合并为一个节点后,则状态数减少为14,变迁数为21,但变迁序列数仍为12,与未简化的线程交互可达图中的变迁序列数上完全相同.3.2偏序约简技术为方便描述,下面对完全扩展的线程交互可达图用AG表示,约简后的线程交互可达图用AR表示.目前常用的偏序约简技术为稳固集技术和睡眠集技术,这两种技术都是通过去除AG中的冗余变迁序列实现约简的[21].定义4.设ω、ω为两个变迁序列,若ω(ω)可由ω(ω)通过连续交换相邻独立变迁的位置而获得,则称ω与ω等价,所有与ω等价的变迁序列集合称作并发系统的一个迹(Mazurkiewicz’sTrace),记为[ω][21].由定义3和定义4,可得:性质1.设m为某状态,ω1,ω2为两个变迁序列,若[ω1]=[ω2],(m,ω1)→m1,(m,ω2)→m2,则m1=m2定义5.给定某状态m,变迁集TEnabled(m),T是m下的稳固集当且仅当:对在AG中从m出发的任意变迁序列ω=t1t2…tn(1in:tiT),(m=m1,t1)→m2∧(m2,t2)→m3∧…∧(mn,tn)→mn+1,满足tn在mn下与T中所有变迁独立.稳固集满足当选择稳固集之外的变迁扩展时对稳固集中的变迁不产生任何影响[21-22].稳固集计算主要采用一些启发式算法,各种算法各有优缺点[21].本文选取Overman提出的算法,该算法的约简效果和复杂度达到了较好的折中.采用以下方法计算状态m的稳固集P_S(m):初始时在工作表W中加入Active(t0),t0为在当前状态m下可发生的一个任意变迁,从W中取出下一个线程θx,在W中加入Active(t)和Active(t),其中t为在m下线程θx中可发生的变迁,t是与t并行执行且依赖的变迁,同时将加入W中的线程标记为已访问线程,再从W中取出下一个线程,如此反复,直至W为空,最后从Enabled(m)中找出已访问线程中在m下可发生的变迁,即为稳固集.该算法时间复杂度为O(p2),其中p为线程数.在一般情况下,稳固集中不可避免地存在相互独立的变迁,采用睡眠集技术可去除这些独立变迁产生的冗余交织,进一步减少可达图中的状态和变迁数.稳固集中不被扩展的变迁集称作睡眠集[21].采用下述方法计算睡眠集:令初始状态m0的睡眠集Sleep(m0)为,对任意状态m,将已在m下扩展的变迁集与m的睡眠集进行合并,去除在m处与待扩展变迁t依赖的变迁后所得变迁集即为m的睡眠集Sleep(m),其中m为在m处发生变迁t后生成的后继状态,Sleep(m)中的变迁在m处不需扩展或在m处已扩展且与t独立.设P_S(m)和Sleep(m)分别为m状态下的稳固集和睡眠集,则在m状态下实际扩展的变迁集为P_S(m)\Sleep(m).为保证约简状态空间图表示并发系统所有可能的执行,Godefroid对稳固集的计算进行改进,要求稳固集满足下列定义6中的附加条件(也称为Godefroid附加条件)[21].定义6.在并发系统状态空间搜索过程中,所计算的各状态m的稳固集满足下列两个条件之一:(1)存在一个不在睡眠集中的变迁,且该变迁扩展后所生成的后继状态不在当前栈中,即扩展该变迁后在当前扩展路径上不产生回路;(2)稳固集为Enabled(m).实例1的约简状态空间如图4所示,其中未划线的状态节点和实线边组成了约简状态空间图,划线的状态节点和虚线边为约简去除的状态和变迁,状态节点后面的集合表示睡眠集.在实例1中,变迁依赖集为{(S4,S6),(S4,S7),(S7,S9)}.在初始状态m0=(1,-,-,-)处,创建线程,进入状态m1,在m1处,初始选择S4变迁,将θ2加入W中,在m1下θ2可发生的变迁为S4,由于S4与S6和S7并行且依赖,将θ3加入W中,在m1下θ3可发生的变迁为S6,S6与S4并行且依赖,但θ2已加入过W,迭代终止,在计算过程中已访问的线程为θ2和θ3,m1的稳固集为{S4,S6},m1的睡眠集为.在m8处,采用类似的方法可计算出其稳固集为{S4,S7},sleep(m8)=sleep(m3)∪{S4,S7}\{S7}={S4},其中sleep(m3)为空集,S7因与S9依赖在睡眠集中被去除.在图4中,完全扩展线程可达图中的状态数为14,变迁数为22,变迁序列数为12,约简后状态数减少为12,变迁数减少为15,变迁序列数减少为6.Page6图4实例1的TIRG约简示意图4基于约简程序可达图的并发程序切片可达图通过模拟并行流的交织执行将其顺序化处理,可达图中每个从初始状态出发到终态的变迁序列表示并发程序一个可能的执行,可达图描述了并发程序所有可能执行的先后顺序关系.基于可达图我们可采用在控制流图中常用的数据流分析技术进行并发程序依赖性分析,然后进行切片计算.与一般顺序程序控制流图不同的是,并发程序中不同线程可对同一个共享变量进行赋值定义,同一语句在不同的并行流交织执行情况下处于不同的程序状态.对这些在不同程序状态下执行的语句不进行区分,可能会引起语句间依赖性不可传递的问题[16].为此,我们将程序状态和语句进行组合,将这种组合称作M-S对,并基于线程交互可达图分析M-S对之间的依赖关系,构建以M-S对为节点的并发程序依赖图,简称MSDG图.定义7.设并发程序CP的TIRG图为AG=(M,m0,TG,ΔG),则CP基于AG的依赖图(MSDG)为四元组〈M,S,MS,ED〉,其中:M为CP的程序状态集,S为CP的语句集,节点集MSM×S,边集ED={(Λi,Λj)|dep(Λi,Λj),Λi,Λj∈MS,dep∈{CD,DD,SD}}.在上述定义中,CD,DD,SD分别表示控制依赖、数据依赖和同步依赖.由于可达图将并发程序的并行流顺序化处理,在分析数据依赖时,我们不需再区分一般数据依赖和干扰数据依赖.考虑到由cobegin/coend引起的同步活动是一种线程执行等待引起的控制,故将这种由同步活动引发的控制依赖称为同步依赖,以区别于由谓词取值等引起的一般控制依赖.MSDG图中的依赖关系具有可传递性,具体证明参见文献[16].性质1.给定并发程序CP,其MSDG图中的依赖关系具有可传递性[16].基于MSDG图计算并发程序切片是一个简单的图的遍历问题.给定切片标准s,先找出所有以语句分量为s的M-S对集合,然后分别以这些M-S对为始点遍历MSDG图,所访问的节点合并后去除状态分量后得到的语句集合即为s的切片.约简后的线程交互可达图包含所有的并发程序执行代表,基于未约简和约简并发程序可达图构造的并发程序依赖图在进行切片计算时是等价的,下面先给出迹自动机的定义和相关性质,再进行证明.定义8.设AG为并发系统的状态空间图,AR为约简状态空间图,当满足下列性质时,称AR为该并发系统的一个迹自动机:对AG中从初始状态m0出发的任意变迁序列ω,在AR中存在一个从m0出发的变迁序列ω,满足ω∈Pref[ω,m0],其中[ω,m0]表示从m0出发、与ω等价的变迁序列集合,Pref[ω,m0]表示由[ω,m0]中变迁序列的前缀生成的变迁序列集合[21].采用Godefroid附加条件的算法生成的约简状态空间图是并发系统的一个迹自动机[21].图4中的AR是实例1的一个迹自动机,设ω=t1S9S6S4S7t2,其中t1为θ1→(θ2,θ3,θ4),t2为θ1←(θ2,θ3,θ4),显然ω是一个被约简掉的变迁序列,但在AR中可找到一个变迁序列ω=t1S6S4S9S7t2,S4和S6分别与S9独立,在ω中先交换S4与S9的位置,再交换S6与S9的位置,即可生成ω,ω∈[ω,m0],ω是自身的前缀,ω∈Pref[ω,m0].设ω为某变迁序列,称ω中语句间的控制依Page7赖、数据依赖以及同步依赖关系集合为ω的程序依赖,记为ProgDep(ω).性质2.设ω、ω为两个变迁序列,若[ω]=[ω],则ProgDep(ω)=ProgDep(ω).证明.由于[ω]=[ω],因此ω与ω是等价的,ω可由ω通过连续交换相邻独立变迁位置而获得.设在由ω生成ω过程中的各变迁序列为(ω=ω1,ω2,…,ωn=ω),满足1in-1:存在变迁序列u,v和独立变迁a,b,其中ωi=uabv且ωi+1=ubav.同一个并发单元内部中的相邻变迁或冲突变迁存在依赖,变迁a,b独立,表明a,b为不同线程中的变迁,而控制依赖发生在同一个线程内部,因此,a和b交换位置不影响ωi和ωi+1中的控制依赖分析.变迁a,b在u之后,a,b位置的交换不影响u中语句的数据依赖关系;其次,由变迁独立关系的定义得,变迁a,b对应语句之间也不可能存在由于对同一个变量的定义引用而产生的数据依赖关系,a,b位置的交换不影响a,b本身的数据依赖关系;最后,由变迁独立关系的定义,变迁a,b对应语句之间也不存在对同一个变量的定义,否则a,b不独立,因此,a,b位置的交换不影响v对应语句的数据依赖关系.以上分析表明,a,b位置的交换不影响ωi和ωi+1中的数据依赖关系.参加同步活动的变迁之间存在依赖,变迁a,b独立,表明a,b未参加任何同步活动,因此,交换a和b的位置不会影响ωi和ωi+1中的同步依赖关系分析.综上所述,a,b位置的交换不影响ωi和ωi+1中数据依赖、控制依赖以及同步依赖,即ProgDep(ωi)=ProgDep(ωi+1),将i从1~n-1代入ProgDep(ωi)=ProgDep(ωi+1),可得:ProgDep(ω)=ProgDep(ω1)=ProgDep(ω2)=…=ProgDep(ωn)=ProgDep(ω).证毕.设并发程序CP完全扩展的线程交互可达图为AG,采用综合稳固集和睡眠集技术约简生成的可达图为AR,记基于AG和AR构造的依赖图分别为MSDG和MSDGR.由于AR是AG的子图,可得:性质3.MSDGR图是MSDG图的子图.给定切片标准s,记基于MSDG图计算s的切片为Slice(s),基于MSDGR图计算s的切片为Slice_R(s).性质4.Slice(s)=Slice_R(s).证明.设l为MSDG图中任意一个从以语句分量为s的某M-S对节点开始的依赖序列,l由TIRG图中的变迁序列ω分析所得.由性质1,在AR图中存在一个变迁序列ω,满足ω为某变迁序列ω的前缀,且[ω]=[ω].由性质2可得,ProgDep(ω)=ProgDep(ω).由于ω为ω的前缀,因此,ProgDep(ω)ProgDep(ω),即ProgDep(ω)ProgDep(ω),基于MSRGR图可遍历到依赖序列l中各语句.由Slice(s)和Slice_R(s)的定义,可得Slice(s)Slice_R(s).由性质3,MSDGR图是MSDG图的子图,可得Slice_R(s)Slice(s).由Slice(s)Slice_R(s)和Slice_R(s)Slice(s)可得Slice(s)=Slice_R(s).下面给出实例1说明基于未约简和约简线程交互可达图进行并发程序切片计算的情况.实例1的MSDG图比较复杂,其中最重要的是数据依赖边,为降低图的复杂程度,图中只给出了数据依赖,其它控制依赖和同步依赖用文字表述.整个图5中的所有依赖关系组成基于未约简线程交互可达图生成的MSDG图.而图5(a)中的实线边以及与这些边相连的节点表示基于约简程序可达图分析所得的数据依赖,图5(b)、(c)中黑色文字表示了基于约简线程交互可达图分析所得的控制和同步依赖,三者共同组成MSDGR图.由图4可见,MSDGR是MSDG的子图.MSDG图中的节点数为41,数据依赖边数为48,控制依赖边数为39,同步依赖边数为3;MSDGR图中节点数为29,数据依赖边数为27,控制依赖边数为22,同步依赖边数为3,约简效果较为明显.对MSDG图中的任意M-S对依赖序列,在MSDGR图中都存在一个长度相同且相同位置的M-S对中语句分量分别相同的M-S对依赖序列.如图5(a),依赖序列l=(〈m0,S1〉,〈m4,S4〉,〈m7,S6〉,〈m10,S7〉)中的依赖边均为虚线,表明该依赖序列仅在未约简的MSDG图中出现,在约简的MSDGR图中,我们可找到一个依赖边均为实线的依赖序列l=(〈m0,S1〉,〈m1,S4〉,〈m2,S6〉,〈m10,S7〉),l与l长度相同,且依赖序列中相同位置的M-S对的语句分量也分别相同.基于MSDG图与MSDGR图进行切片计算是等价的.如对S6进行切片,遍历MSDGR图的M-S对集合为{〈m2,S6〉,〈m1,S4〉,〈m0,S1〉,〈m1,S3〉,〈m1,S6〉,〈m0,startt0〉,〈m1,startt1〉,〈m1,startt2〉,〈m0,cobegin〉},图5(a)中深色的实线节点为通过数据依赖边获得的节点;遍历未约简MSDG图的M-S对集合为Page8图5实例1的MSDG图{〈m2,S6〉,〈m1,S4〉,〈m0,S1〉,〈m1,S3〉,〈m1,S6〉,〈m7,S6〉,〈m4,S4〉,〈m4,S3〉,〈m0,startt0〉,〈m1,startt1〉,〈m1,startt2〉,〈m0,cobegin〉},在图5(a)中深色的实线和虚线节点为通过数据依赖边获得的节点.去除状态分量后所得S6的切片相同,Slice(S6)={S6,S4,S1,S3,startt0,startt1,startt2,cobegin}.实例2的TIRG和MSDG图以及相关分析已在文献[16]给出,限于篇幅,本文不再赘述.5实验分析在上述理论工作的基础上,我们针对多线程共享变量通信机制,通过C/C++程序分析工具CodeSurfer获取程序的控制流图、子程序调用图以及数据的定义/引用等基本信息,实现了基于程序可Page9达图的并发程序切片原型系统[19].该系统主要包括构造TIRG图、构造MSDG图以及切片计算等子系统,其中构造TIRG图子系统实现了完全扩展线程交互可达图以及采用本文3.2节中稳固集和睡眠集偏序约简技术生成的程序交互可达图的算法.同时,为方便与相关工作进行比较,我们还实现了目前最有代表性的Nanda提出的基于线程系统依赖图(TSDG)的并发程序切片算法:三色两趟式并发子程序间切片方法、基于拓扑号的上下文敏感的并发子程序间切片算法[11-12]以及Giffhorn对该方法进行约束优化的改进算法[14],其中TSDG图是将各线程的系统依赖图通过干扰依赖边连接而成的语句间的依赖图.实验环境为IntelCore2Q8400处理器,2.66GHz,3GB内存,WindowsXP系统,CodeSurfer版本为2.1p1.20070526-i686-pc-win32.实验程序为文献[14]中使用的两个Java并发程序,为方便CodeSurfer分析,我们将这两个Java并发程序转换为类似C语言的程序,其中main函数视为主线程,子程序cobegin()/coend()的调用视为线程的创建/终止,两个或多个线程使用的全局变量视为共享变量.为观察不同切片方法在状态组合爆炸问题上的处理情况及其对切片时间性能的影响,我们对上述两个实验程序在具有不同线程数的情况下进行依赖性分析和切片实验.表1给出两个实验程序在不同线程数下构造的线程系统依赖图(TSDG)以及线程交互可达图(TIRG)和M-S对依赖图(MSDG)的大小,其中TIRG和TIRGR分别表示未约简和约简的线程交互可达图,MSDG和MSDGR分别表示基于TIRG和TIRGR图构造的M-S对依赖图,TSDG图是线程系统依赖图.表1中N表示相应图中的节点数,E表示边数,—表示分析超过1h而无法正确获取相应数据.程序线程Time-TravelShared-Queue由表1可见,采用偏序约简技术对SharedQueue程序产生了明显的约简效果,较大幅度地降低了TIRG图和MSDG图的复杂度,且随着线程数的增加,两者的约简效果愈加明显.当线程数为2、3、4时,TIRGR图(约简后的TIRG)的节点数分别减少为未约简TIRG图节点数的75%、63%和60%,边数分别减少为未约简TIRG图边数的52%、32%和24%.当线程数为5时,不采用约简技术难以构造TIRG图.相应地,MSDGR图的复杂度远远低于MSDG图的复杂度.当线程数为2、3时,MSDGR图的节点数分别为MSDG图节点数的59%和42%,边数分别为MSDG图边数的33%和13%.当线程数为4、5时,基于未约简的TIRG图难以构造MSDG图.由表1还可看出,采用偏序约简技术对TimeTravel程序并未产生十分明显的约简效果,约简后TIRG图和MSDG图的复杂度略有减小,没有明显的变化.实验采用不同切片算法分别对两个实验程序进行切片实验,表2和表3分别给出了切片的精度和时间性能的实验结果.在表2和表3中,Name表示程序名,Inst表示线程的实例数,R和RO是我们提出的基于程序可达图的切片算法,其中R表示基于未约简程序可达图的切片算法,RO表示基于约简程序可达图的切片算法,N和NO是Nanda在文献[11-12]所提出的可解决依赖时序问题和上下文不敏感问题的高精度切片算法,N表示未进行优化的切片算法,NO表示通过元组可达性的判断对N方法进行优化的切片算法,I表示Nanda提出的三色两阶段遍历TSDG图的切片算法,该算法不能解决依赖性不可传递问题和上下文不敏感问题.本次实验选取的切片标准为含共享变量的语句,切片大小为各切片中语句数的平均值,表示切片的精度,工作节点数是每个切片计算过程中的加入工作表中的节点数的平均值(与切片时间密切相关).表2中的S表示切片语句数,W表示工作节点数.在TimeTravel程序中,采用R和RO方法所获得的切片的精度较I方法提高3.3%~10%,较N和NO方法提高1.6%~3.3%,表明对该程序进行切片,存在两类依赖关系不可传递性问题.在SharedQueue程序中,5种方法切片精度相同,表明对所选切片标准进行切片,不存在依赖关系不可传递性问题和上下文不敏感问题.表3给出了不同切片算法的时间性能,TB表示构造依赖图的时间,TS表示切片时间,其中切片时Page10间为各切片时间的平均值.N、NO和I方法的切片计算都基于TSDG图,依赖图构造时间相同,主要包括程序编译和语句依赖关系分析的时间,R和RO方法的切片计算基于MSDG图,依赖图构造时间包括程序编译、构造TIRG图和M-S对依赖关系分析的时间.程序线程Time-TravelShared-Queue程序线程Time-TravelShared-Queue在SharedQueue和TimeTravel程序中,当线程数较小时,TSDG图与MSDG图的构造时间相差不大,但随着线程数的增加,TSDG图的构造时间大致呈线性增长,在SharedQueue程序中,偏序约简效果较为明显,未约简MSDG图的构造时间呈指数级增长,约简的MSDGR图则明显减缓增长的幅度,而在TimeTravel程序中,略有约简,两者差距不大.结合表1可看出,依赖图的构造时间大致与表1中依赖图的大小相吻合.由表3可见,采用I方法进行切片所花费的平均切片时间较少,切片效率最高,且随着线程数的增加,切片时间大致呈线性增长.N方法和R方法切片效率较低,且随着线程数的增加,切片时间呈指数级增长,NO和RO方法减缓了这种增长趋势,这些趋势与表2中工作节点数随线程数的增长趋势相吻合.表2中RO方法的工作节点数明显多于NO方法的工作节点数,但由于NO方法为解决时序依赖问题在切片过程中对每个工作节点需进行依赖序列是否满足时序要求的检查,因此,在两个实验程序中,RO方法的切片时间在大多数情况下表现为少于NO方法.6相关工作Cheng[4]最早研究了Ada并发程序切片,通过添加选择依赖、同步依赖和通信依赖边将一般顺序程序依赖图扩展为进程依赖网(PDN),然后遍历PDN计算并发程序切片.Zhao[5]在PDN上增加形参、实参节点以及相关依赖边表示由于子程序调用引起的数据和控制依赖,生成多线程依赖图(MDG),同时采用一般顺序子程序两趟式遍历算法遍历MDG图计算并发子程序间切片和面向对象的并发程序切片.Nanda等人[12]在系统依赖图(SDG)上添加干扰依赖边生成线程系统依赖图(TSDG)表示并发程序的依赖关系,并在此基础上提出三色两趟式并发子程序间切片方法,对一般顺序子程序两趟式遍历算法进行改进,在遍历TSDG图的过程中,通过保证干扰数据依赖边所遍历语句可进行调用上下文的两趟遍历,来确保切片结果的正确性.Hatcliff[6]通过简单遍历TSDG图计算Java并发程序切片,其切片方法类似于Zhao的算法.上述4种方法因未考虑并发程序中依赖关系的不可传递性和上下文不敏感问题,直接遍历依赖图,所得切片包含大量冗余语句,精度较低.为解决依赖关系不可传递性问题,人们根据依赖序列应满足执行的先后时序要求,提出在遍历并发程序依赖图时进行附加的判断,以提高切片精度[7-15].如张晶等人[7]在遍历依赖图的过程中,根据切片标准的控制流和并行流的可达语句集去除部分冗余语句(该方法不能保证每个依赖序列是一个可能的执行语句序列),解决了部分时序依赖不可传递问题.陈振强等人[8]根据依赖序列的不可能依赖语句集的判断去除冗余语句,由于不可能依赖语句集的保守计算,该方法同样不能保证每个依赖序列是一个可能的执行语句序列,仅解决了部分时序依赖不可传递性问题,但与张晶的方法相比,该方法由于在进行冗余语句判断时不仅考虑了切片标准的可达信息,还考虑了依赖序列中的各节点的可达信息,因此该方法较张晶的方法可去除更多的冗余语句.Krinke[9]提出一种附加判断方法,在遍历时记录各线程的最后依赖语句,当通过干扰依赖到达某线程时,判断当前依赖语句是否存在一条控制流路径到达该线程中所记录的最后依赖语句,由此保证每个依赖序列是一个可能的执行序列,较好地解决了时序依赖性不可传递问题,获得高精度的并发程序切Page11片,但该方法的效率较低,具有程序语句数指数级的复杂度.在后续的工作中,Krinke[10]还将该方法扩展到并发子程序间切片的研究中,基于调用串实现子程序虚拟内联,解决了上下文不敏感问题,获得了较高精度的并发子程序间切片.Nanda等人[11-12]对Krinke的方法进行了完善和优化,提出基于拓扑号的并发子程序间切片方法,采用虚拟内联的方法,对同一语句在不同调用下的执行实例进行区分,在遍历到每个语句时都记录各并发单元在依赖序列中的最近依赖语句的实例,并将该方法应用于Java并发程序切片.Giffhorn等人[13]通过实验研究,比较了Krink和Nanda提出的几种并发程序切片方法及优化措施对并发程序切片精度和效率的影响[13-15].尽管上述方法从某种程度上提高了切片精度,但由于并发程序依赖图是由各并发单元依赖图通过并发单元间依赖边简单连接构成的,它不能从全局有效地表示并发单元间的依赖关系,这类方法均不能解决共享变量重定义不可传递性问题,并发程序切片的精度仍需进一步提高.为解决依赖性不可传递问题,在前期工作中,我们提出了基于程序可达图的并发程序切片方法,该方法可解决时序依赖不可传递性问题和共享变量重定义不可传递性问题,切片精度较上述方法高[16-19].在切片效率方面,虽然该方法具有程序语句块数指数级的复杂度,在最坏情况下较Krinke和Nanda切片方法有所提高,但切片效率仍然较低.本文采用偏序约简技术约简程序可达图,在保证切片精度不受损失的前提下提高切片效率,实验研究表明,与其它高精度切片方法相比,基于约简程序可达图的切片方法的精度更高,在大多数情况下,切片效率也有一定提高.7结论干扰依赖的存在使得并发程序中语句间的依赖关系具有不可传递性,大多数并发程序切片方法只能解决时序依赖不可传递性问题.基于程序可达图可构造以程序状态和语句二元组的、具有可传递性质的并发程序依赖图,但可达图存在状态爆炸问题,切片效率较低,并发程序切片技术的应用因此受到限制.偏序约简方法是一种十分有效的降低可达性分析代价的方法,本文将偏序约简技术扩展到程序可达图的约简中,在偏序约简理论的基础上,证明了基于未约简和约简的并发程序可达图构造的并发程序依赖图在进行切片计算时是等价的.实验研究表明,基于偏序约简程序可达图的并发程序切片方法,在保证切片精度不受损失的前提下可明显提高程序切片的效率.与目前经典的Nanda所提出带优化的可解决依赖时序问题和上下文不敏感问题的高精度切片算法NO相比,基于约简程序可达图的切片方法精度更高,切片效率在大多数情况下好于NO方法.
