Page1基于统计分析的弱变异测试可执行路径生成巩敦卫1),4)1)(中国矿业大学信息与电气工程学院江苏徐州221116)2)(徐州工程学院信电工程学院江苏徐州221000)3)(中国矿业大学理学院江苏徐州221116)4)(兰州理工大学电气工程与信息工程学院兰州730050)摘要变异测试是一种面向缺陷的软件测试技术,然而高昂的测试代价,影响了其在实际程序测试的应用.Papadakis等人将某一程序的弱变异测试问题,转化为另一程序的变异语句真分支覆盖问题,以期采用已有的分支覆盖方法,生成变异测试数据.但是,上述方法使得转化后程序包含大量的变异分支,增加了分支覆盖测试数据生成的难度.如果采用合适的方法,约简转化后程序中包含的变异分支,并依所属的路径,对约简之后的变异分支分组,那么,将能够利用已有的路径覆盖测试方法,生成高质量的变异测试数据,从而提高弱变异测试的效率.但是,如何基于某一程序和变异体,生成可执行路径,至今缺乏有效的方法.鉴于此,文中通过考察变异语句真分支之间的相关性,提出了一种用于弱变异测试的可执行路径生成方法,使得覆盖这些路径的测试数据,能够杀死所有的变异体.该方法首先考察变异语句真分支之间的占优关系,约简被占优的变异分支,从而减少变异分支的数量;然后,将非被占优的变异分支插入到该程序,转化为另一被测程序,并基于转化之后的程序,考察同一语句形成的多个变异分支的相关性;通过组合相关变异分支,形成新的变异语句真分支;接着,利用被测语句与新变异语句真分支的相关性,生成包含新变异语句真分支和被测语句的可执行子路径;最后,采用统计分析,基于子路径之间的执行关系,构建并约简相关矩阵,将相关的子路径组合,生成一条或多条可执行路径.将所提方法应用于9个基准和工业程序测试中,并与传统方法进行了比较.实验结果表明,所提方法生成了为数较少的可执行路径,且运行时间短;更重要的是,这些可执行路径能够覆盖所有的变异分支.此外,所提方法涉及的样本容量,对生成的可执行路径数有一定的影响,但对程序的运行时间影响较小.关键词变异测试;弱变异测试;变异分支;路径覆盖;可执行路径1引言软件测试是保证软件质量的重要手段,通过测试,不但能够检测软件可能存在的缺陷,而且能够提高软件的可靠度.在诸多测试技术中,变异测试直接面向程序缺陷,生成测试数据,是提高测试数据充分性的一种有效方法[1].为了进行变异测试(mutationtesting),首先,通过使用变异算子(mutationoperator),对程序的某一语句做合乎语法的微小变动,以产生一个新的程序,称该程序为一个变异体(mutant)[2];然后,以某一测试数据,分别执行变异体和原程序,如果两者的输出不同,那么,称测试数据杀死了该变异体,这种变异测试准则称为强变异测试(strongmutationtesting)[3];如果两者在变异点执行后,变量状态出现不一致,即可认为该变异体被杀死,那么,这种变异测试准则称为弱变异测试(weakmutationtesting)[4].基于弱变异测试准则,判定某变异体是否被杀死时,不需要完整的执行原程序和变异体,因此,提高了变异测试的效率.Horgan和Mathur[5]的理论分析表明,在特定条件下,基于弱变异测试得到的变异得分(mutationscore),与基于强变异测试得到的变异得分基本保持一致.此外,Offutt和Lee[6]的实验结果表明,在多数情况下,弱变异测试可以替代强变异测试.一个程序往往存在很多变异体,为了杀死这些变异体,也需要大量的测试数据;而且,这些测试数据需要同时执行原程序和变异体,因此,变异测试的效率通常很低.为了克服上述不足,Papadakis等人[7]通过将变异语句转化为变异分支(mutantbranch),并将所有转化后的变异分支,插入到原程序后,形成新的被测程序,这样一来,将原程序的弱变异测试问题,转化为新程序的分支覆盖(branchcoverage)问题,以采用已有的分支覆盖方法,解决变异测试问题,从而提高了弱变异测试的效率.但是,采用上述方法进行弱变异测试转化,将导致新程序包含大量的变异分支,使得分支覆盖测试数据生成问题非常复杂.如果采用合适的方法,约简(reduction)新程序中的变异分支,并对约简之后的变异分支,依所属的路径进行分组,那么,能够将分Page3支覆盖问题,转化为路径覆盖(pathcoverage)问题,这样一来,能够减少生成的测试数据,进一步提高弱变异测试的效率.鉴于此,本文提出一种基于统计分析的弱变异测试可执行路径生成方法.首先,对同一被测语句进行变异,形成相应的变异分支,并根据这些分支的执行关系,形成新的变异分支;然后,基于新的变异分支与被测语句的相关性,形成可执行子路径;最后,基于统计分析的方法,生成一条或多条包含这些子路径的可执行路径.本文的贡献主要体现在:(1)给出了基于同一被测语句变异,形成新变异分支的方法,减少了变异分支的条数;(2)给出了可执行子路径形成的策略,使得形成的子路径,包含所有的新变异分支;(3)给出了可执行路径的生成方法,使得生成的可执行路径,包含所有的子路径.通过上述工作,将弱变异测试问题转化为路径覆盖问题,生成了包含所有变异分支的可执行路径,那么,覆盖这些路径的测试数据,能够杀死相应的变异体,从而提高了变异测试的效率.本文第2节综述相关的工作;第3节阐述本文提出的方法,包括基于同一语句变异形成新变异分支、可执行子路径的生成、可执行路径的生成以及实例分析等;第4节通过对比实验,评价所提方法的性能;最后,第5节总结全文所做的工作,并提出后续的研究问题.2相关工作本节从如下5个主要方面,总结已有的研究工作,主要包括变异测试、变异体约简、变异测试数据生成、路径覆盖测试以及弱变异测试转化.在此基础上,引出本文研究的动机.2.1变异测试变异测试是由DeMillo等人[2]提出的一种面向缺陷的测试技术.进行变异测试时,不仅可以选择注入缺陷的位置和类型,而且可以根据不同层次的测试,选择变异算子,因此,变异测试具有很好的灵活性和针对性[8-10].进行变异测试时,对原程序的语句,按照句法规则进行一些小的改动,称为变异[2,8];改动语法的规则,称为变异算子;改动之后的语句,称为变异语句;在变异体中,如果变异语句只有一个,那么,称为一阶变异体[11];相应的变异测试,称为一阶变异测试.本文仅研究一阶变异测试,简称变异测试.在强变异测试准则下,判断一个变异体能否被杀死,需要满足如下3个条件[2,12]:(1)可达性.测试数据能够执行到变异体中的变异语句;(2)必要性.测试数据执行变异语句之后,产生与原程序不同的状态;(3)充分性.上述不同的状态,能够导致原程序和变异体的输出不同.如果对于任何测试数据,执行原程序和变异体后,输出均相同,那么,称该变异体为等价变异体(equivalentmutant)[8].除了强变异测试准则之外,还有弱变异测试准则,该准则只需要满足可达性和必要性条件,即可认为变异体被杀死.已有研究表明,满足可达性和必要性条件的测试数据,也能够在很大程度上满足充分性条件[5-6],因此,弱变异测试是强变异测试的有效替代[13-15].2.2变异体约简为了提高变异测试效率,一种有效的方法是尽可能减少需要杀死的变异体,此即变异体约简[16-17].通过变异体约简,减少了需要运行程序(变异体)的次数,提高了变异测试的效率.Just等人[16]通过约简同类变异算子生成的变异体,减少需要杀死的变异体,从而提高变异测试的效率.Offutt和Lee[17]通过采用部分变异算子代替所有的变异算子,生成变异体,以减少需要杀死的变异体.徐拾义[18]通过与变异体对应条件语句之间的占优关系,约简变异体.此外,还有学者采用遗传算法[19],约简变异体.2.3变异测试数据生成基于变异测试准则,生成测试数据,以杀死相应的变异体.Offutt[20]提出了基于约束的测试数据生成方法,生成的测试数据能够检测98%的变异体.但是,该方法受到符号执行技术本身的限制;为了克服上述不足,Offutt等人[21]、刘新忠等人[13]以及单锦辉等人[22]从不同方面提出了动态域约简方法,提高了测试数据生成的效率.但是,上述研究工作仅局限于采用传统的约束求解方法,生成变异测试数据.基于搜索的方法[23],如遗传算法[24],也可以用于生成测试数据.张功杰等人[25]以测试数据集作为决策变量,构造目标函数,并采用集合进化,生成变异测试数据,但是,该方法没有对变异体约简,使得生成变异测试数据的代价比较高.2.4路径覆盖的测试与变异测试相比,结构覆盖测试近年来取得了丰硕的研究成果,该测试方法以覆盖程序的某种结构,如语句、分支,或者路径,为测试目标,生成测试Page4数据,相应的覆盖准则分别称为语句覆盖、分支覆盖以及路径覆盖.在这些结构覆盖准则中,路径覆盖最为常用.其中,采用基于搜索的方法,生成测试数据[26-27],成为近年来软件测试研究的热点.该方法首先将路径覆盖问题,转化为一个数值函数优化问题;然后,采用某一搜索方法,如进化优化方法,生成期望的测试数据.Bueno等人[28]、Lin等人[29]以及Watkins等人[30]分别利用遗传算法,生成覆盖路径的测试数据.但是,上述方法存在的共同不足是,一次运行遗传算法,仅能生成覆盖一条路径的测试数据.为了克服上述不足,Ahmed等人[31]将多路径覆盖测试数据生成问题,转化为多目标优化问题,使得一次运行遗传算法,能够生成覆盖多条路径的测试数据.但是,当需要覆盖的路径很多时,基于该方法建立的模型,将包含很多目标函数,提高了模型求解的复杂度.后来,文献[32-33]针对很多路径覆盖问题,通过路径分组,简化了优化模型,从而降低了问题求解的难度.但是,路径覆盖测试面临的问题是,如何生成需要覆盖的目标路径;此外,还需要判断这些路径是否可执行的,这是因为,如果这些路径是不可执行的,将花费很多时间,用于生成覆盖这些路径的测试数据,从而降低了软件测试的效率.Zhang等人[34]基于程序的控制流图,采用深度优先搜索方法,自动生成基本路径集.虽然这些路径能够覆盖控制流图的所有节点和边,但是,有些路径是不可执行的.为了避免生成不可执行的路径,Yan等人[35]根据控制流图,采用广度优先搜索方法,生成可执行的基本路径集.但是,对于大型程序,构造其控制流图的代价是相当大的;此外,在软件测试时,往往只需测试程序的部分代码及其形成的路径,此时,构造完整的控制流图通常是没有必要的.鉴于此,本文基于选择的被测语句,通过弱变异测试转化,并采用合适的策略,生成包含这些被测语句及其转化后语句的可执行路径集,以期提高软件测试的效率.2.5弱变异测试转化鉴于结构覆盖测试已经取得的成果,Papadakis等人[7]将基于弱变异测试准则杀死变异体的问题,转化为变异条件语句真分支的覆盖问题.为此,首先,对于变异前后的语句s和s,基于弱变异测试的必要条件,构建变异条件语句“ifs!=s”,其真分支为一个标志语句;然后,把这些变异条件语句,插入到原程序的相应位置,形成新的被测程序.那么,能够覆盖新程序变异条件语句真分支的测试数据,一定能够杀死该变异条件语句对应的变异体.这样做的好处是,能够利用已有的分支覆盖测试数据生成方法,生成变异测试数据.进一步,Papadakis等人[36]提出一种路径的选择策略,以覆盖所有的变异分支.为此,从候选路径集中,选择合适的路径,使得覆盖这些路径的测试数据,也能够覆盖变异分支,从而通过已有的路径覆盖测试数据生成方法,生成杀死变异体的测试数据.但是,由于该方法没有约简变异体,使得新程序包含大量的变异分支,从而增加了程序的复杂度,降低了变异测试数据生成的效率.3提出的方法对于一个实际的被测程序,尽管该程序的代码可能很多,但是,程序的缺陷往往仅集中于某些代码范围内,如果针对所有的语句均实施测试,那么,将会花费很大的测试代价.鉴于此,可以选择出现缺陷概率比较大的语句[10]进行测试,对于提高测试效率,是非常有帮助的.现在我们考虑上述语句的变异测试问题.采用Papadakis等人[7]思想,将弱变异测试转化为分支覆盖问题,我们研究发现,在新的被测程序中,被插入的这些变异分支之间存在一定的关联,体现为多个变异分支分布在同一条路径上.因此,我们考虑基于变异分支所在的路径,对上述变异分支分组,那么,将弱变异测试问题,转化为路径覆盖问题,以期提高变异测试的效率.3.1思想首先,基于对同一被测语句变异,形成的多个变异分支,采用静态分析,根据这些分支的执行关系,形成新的变异分支;然后,基于新的变异分支与被测语句的相关性,形成一条或多条可执行的子路径;最后,基于统计分析方法,根据这些子路径的执行关系,自动生成一条或多条可执行路径.3.2基于同一语句变异形成新变异分支本节考虑针对同一被测语句变异,形成新的变异分支.首先,对同一语句进行变异,基于变异分支之间的执行关系[37],进行分组;然后,基于每组变异分支所属条件语句的语义关系,形成新的变异分支.在si之前插装变异分支后形成新程序,插装的变异分支分别记为e1,e2,…,ep,…,这些变异分支的真分支分别记为e1(1),e2(1),…,ep(1),….记被测语句Page5为si,如果该语句是条件语句,记其真分支为si(1),假分支为si(0).图1示例程序对被测语句“x<=y”实施关系运算符替换(RelationOperatorReplacement,ROR)、算术运算符替换(ArithmeticOperatorReplacement,AOR)和单目运算符替换(UnaryOperatorReplacement,UOI)等3种变异算子[17],其中,ROR包含的变异算子为{(u,v)|u,v∈{>,>=,<,<=,==,!=}∧u≠v},AOR包含的变异算子为{(u,v)|u,v∈{+,-,,/,\%}∧u≠v},UOI包含的变异算子为{(v,--v),(v,++v),(v,v--),(v,v++)}.实施这3种变异算子之后,被测语句“x<=y”共生成11个变异语句.首先,对9个非等价变异体对应的变异语句转化为相应的变异分支,并插装到原程序的被测语句“x<=y”之前;然后,分析新程序中9个变异分支之间的占优关系,由文献[37]可知,当一个变异分支执行时,其他一或多个变异分支一定执行,记该变异分支占优其他变异分支,当程序的某一输入,使得变异分支e1、e3或e5执行时,变异分支e6一定执行,那么,e6是被占优分支.类似的,变异分支e7、e8和e9也是被占优分支.约简这些被占优分支之后,5个非被占优变异分支为e1,e2,…,e5.如图1(c)的灰色部分所示.下面通过一个例子,说明变异分支分组策略和新的变异分支形成过程.如图1(a)为被测程序.然后,根据这些非被占优变异分支之间的执行关系,对5个变异分支分组.如图1(b)所示,根据执行关系,考虑变异分支e1和e3的条件谓词表达式,这2个条件谓词表达式并不矛盾,因此,可以将这2个变异分支分为一组;类似的,将变异分支e2和e4分为一组;变异分支e5单独为一组.最后,考虑上述3组变异分支,在各自组内形成新的变异分支.对于e1和e3所在的组,通过“逻辑与”的方式,把其条件谓词表达式连接起来,新形成的变异分支为e13:if((x<=y)!=(x<=++a1))&&类似的,基于变异分支e2和e4,新形成的变异分支为e24;新形成的变异分支如图1(c)所示.以这种方式分组变异分支和形成新变异分支,有利于生成数量较少的可执行路径.但是,通过“逻辑与”的连接方式,可能增加了包含这些新变异分支路径覆盖的难度.解决该问题的途径之一是,利用比较成熟的路径覆盖技术,生成测试数据,以降低测试数据生成的代价,关于该内容的研究,已经超出了本文的范围.Page63.3可执行子路径的生成不引起混淆的情况下,被测语句si之前插装的新变异分支仍记为e1,e2,…,ep,…,它们的真分支分别记为e1(1),e2(1),…,ep(1),….现在由这些新变异分支与被测语句,生成可执行子路径.如果条件语句的谓词表达式,那么,考察上述变异分支ep的条件语句与该条件语句si之间的相关性.如果它们是真真相关的[38],那么,基于变异真分支和被测语句的真分支,形成一条子路径,记为(ep(1),si(1));如果它们是真假相关的[38],那么,基于变异真分支和被测语句的假分支,形成一条子路径,记为(ep(1),si(0)).如果被测语句不是条件语句的谓词表达式,那么,直接基于变异真分支与该被测语句,形成一条子路径,记为(ep(1),si).通过上述方法,对于每一新变异分支,与被测语句,能够形成一条子路径.进一步,根据变异分支的可执行性,判定子路径是否是可执行的,从而得到可执行的子路径.类似方法,对于所有变异分支e1,e2,…,ep,…,与被测语句si,形成的可执行子路径集合为{ai1,ai2,…,aip,…}={(e1(1),si(b)),(e2(1),si(b)),…,取、1或0,其中“”表示为被测语句既没有真分支也没有假分支.因此,si(b)分别表示为被测语句,被测语句的真分支、或被测语句的假分支.对于图1的示例程序,由于新变异分支e13的条件谓词表达式“((x<=y)!=(x<=++a1))&&((x<=y)!=(x<=abs(y)))”与被测语句s1的条件谓词表达式“(x<=y)”在语义上是矛盾的,因此,e13和s1真假相关,形成的子路径为a11=(e13(1),s1(0));类似的,e24和s1真真相关,形成的子路径为a12=(e24(1),s1(1));e5和s1真真相关,形成的子路径为a13=(e5(1),s1(1)).由于e13、e24和e5均为可执行变异分支,因此,它们所属的子路径a11=(e13(1),s1(0))、a12=(e24(1),s1(1))和a13=(e5(1),s1(1))也是可执行的,从而生成的可执行的子路径集合为{a11,a12,a13}={(e13(1),s1(0)),(e24(1),s1(1)),(e5(1),s1(1))}.3.4可执行路径的生成假设原程序有n条被测语句,其第i条被测语句为si(i=1,2,…,n),采用第3.2和3.3节的方法,得到的可执行子路径集合为Ai={ai1,ai2,…,ai|Ai|}.对于所有的被测语句,可执行子路径的集合为A={A1,A2,…,An},容易知道,A包含的子路径条数为|A|=∑时执行,因此,需要将Ai与Aj(j=1,2,…,n,j≠i)的子路径进行组合,生成可执行路径.下面考虑插入新变异分支之后的新程序.为了使生成的可执行路径比较少,必须充分考虑子路径之间的执行关系.首先,基于子路径之间的执行关系,构建一个相关矩阵;然后,根据矩阵中元素的取值,约简该矩阵,同时,使得可执行子路径集合包含的元素最少;最后,根据与某子路径相关的子路径条数,依一定的顺序,将相关的子路径组合起来,生成一或多条可执行路径.(1)相关矩阵的构建为了构建相关矩阵,考虑A的2个子路径aip,ajk,i≠j.对于程序的某一输入x,aip可能被穿越,也可能不被穿越,ajk也是如此.为了反映这2个子路径被穿越的可能性,定义如下2个随机变量:μip(x)=μjk(x)=显然,变量μip和μjk服从(0,1)分布.对于变量μip和μjk,若给定μip,且P(μip=i)>0时,μjk的条件分布律为P(μjk=j|μip=i)=式(1)反映了变量μip=i发生的条件下μjk=j发生的概率.如果随机变量μip和μjk的值存在一定的联系;那么,子路径aip和ajk的执行也具有一定的相关,反之亦然.因此,可以利用式(1)的μip和μjk的条件分布率,考察aip,ajk执行的相关程度.在程序的输入域中采样R次,采样值分别为x1,x2,…,xR,对于每一采样值,根据子路径aip和ajk是否被穿越,计算上述随机变量的μip和μjk值.子路径aip和ajk之间的相关度,记为αip,jk,可以定义如下:由式(2)可以看出,两个子路径的相关度的取值范围是0αip,jk1;当αip,jk=1时,表示同一或两个不同的子路径最相关;当αip,jk=0时,表示这两个Page7不同的子路径最不相关.由式(2),类似的,可以得到所有子路径之间的相关度,对于可执行子路径集合Ai={ai1,ai2,…,ai|Ai|},由这些相关度的值,够构建如下的相关矩阵:a11a12Λ=aipan|An|由矩阵Λ可以看出,(1)矩阵Λ的对角线元素均为1,即子路径与自身的相关度为1,表明子路径与自身最相关;(2)αip,jk的值越大,那么,子路径aip、ajk的相关度越高;特别的,αip,jk=1时,表示两个不同的子路径是最相关的,即子路径aip的执行,必然导致ajk也执行;(3)αip,jk的值越小,那么,子路径aip、ajk的相关度越低;特别的,αip,jk=0时,表示两个不同的子路径是最不相关的,即子路径aip的执行,必然导致ajk不执行.(2)相关矩阵的约简当不同子路径之间相关度αip,jk=1时,可以约简相关矩阵Λ.首先,考察Λ的第1行包含的元素,该行元素反映了子路径a11与ajk(j=1,2,…,n;k=1,2,…,|An|)的相关度.如果α11,jk,j≠1;瓡:α11,jk=1,此时,子路径a11执行,必然导致ajk也执行,那么,从Λ中删除子路径ajk对应的列和行,同时从集合A中删除ajk;然后,考察约简后相关矩阵的第2,3,…行元素,采用类似的方法,继续约简相关矩阵和子路径集合,直到所有行的元素均被考察为止.在不引起混淆的情况下,仍记约简后的相关矩阵为Λ,子路径集合为A.(3)可执行路径的生成为了生成一或多条可执行路径,首先,在约简后的矩阵Λ中,考察与子路径具有相关的其他子路径的条数,按照一定的顺序,选择基准子路径;然后,针对每一基准子路径,将与该基准子路径相关的子路表1分组的变异分支与形成的新变异分支被测语句x+y<=z(x==y)&&(y==z)ROR径结合,生成一条可执行路径;最后,将该可执行路径包含的子路径从集合A中删除,直到A不包含任何子路径为止.下面,分别给出基准子路径的选择和可执行路径生成的方法.为了选择基准子路径,首先,考虑Λ中子路径aip对应的行,记录该行中所有0<αip,jk<1对应的子路径ajk,并统计这些子路径的个数,记为nip;然后,考虑Λ的所有行,能够得到集合{nip,…,nip,…,nn|An|},该集合反映了与每一子路径相关的子路径条数,若nip越小,与子路径aip相关的子路径越少,那么,生成可执行路径时,aip可供利用的子路径越少.因此,为了生成比较少的可执行路径,有必要优先选择集合{nip,…,nip,…,nn|An|}中最小的元素,设nip为该集合最小元素,那它所对应的子路径aip为基准子路径.为了生成一条可执行路径,考察与基准子路径aip相关的所有子路径.如果与基准子路径aip相关的子路径有0条,那么,生成一条基准子路径自身的可执行路径(aip).如果与该基准子路径相关的子路径只有1条,记与基准子路径相关的子路径为ajk;将子路径aip和ajk连接起来,生成一条可行性路径(aip,ajk).如果与该基准子路径相关的子路径多于1条,记与基准子路径aip相关的子路径为ajk和alm,如果0<αjk,lm<1且0<αip,lm<1,那么,将(aip,ajk)与alm连接起来,生成一条可执行路径(aip,ajk,alm).类似的,能够生成包含更多子路径的可执行路径.那么,由所有子路径生成的可执行路径集合为{(aip,ajk,alm,…),(aip3.5实例分析下面通过程序Triangle说明采用第3节的方法,生成可执行路径的过程.图2(a)为Triangle的源代码.在程序的前、中和后部,分别选取3条被测语句,并从传统变异算子[17]中选择2种,实施变异操作,得到21个变异体,其中16个非等价变异体,采用文献[7]方法,生成相应的变异分支,如表1所列.Page8if(x>z)!=(x!=z)if(x>y){t=x;x=y;y=t;}1if(x>z1(1){t=x;x=z;z=t;}if(y>z){t=y;x=z;z=t;}2if(x+y<=z2(1){type=0;}2(0)elseif(xx+yy==zz)3elseif(x==y)&&(y==z→)3(1){type=2;}3(0)elseif(x==y)‖{type=3;}{type=4;}图2Triangle被测程序采用第3.2节的方法,对这些变异分支分组,并形成7个新的变异分支,如图2(b)所示.将这些新变异分支插入到原程序中,形成新的被测程序,如图2(c)所示.采用第3.3节的方法,形成的可执行子路径集合为H={A1,A2,A3}={{a11,a12,a13},{a21,a22},{a31,a32}}={{(e1(1)),(e2(1)),(e3(1),1(1))},{(e4(1),2(1)),(e5(1),2(0))},{(e6(1),3(1)),(e7(1),3(0))}.取R=3000时,采用第3.4节(1)的方法,得到如下相关矩阵Λ:a11熿a12a13Λ=a21a22a31a32燀占优由Λ可知,子路径a31与a11的相关度α31,11=1,采用第3.4节(2)的方法,从Λ中删除a11对应的行和列,并从集合A中删除子路径a11.类似的,从Λ中删除a22对应的行和列,并从A中删除子路径a22.得到约简后的相关矩阵如下:Λ=约简后的子路径集合为A={{a12,a13},{a21},{a31,a32}}.对于约简后的相关矩阵Λ和子路径集合A,采用第3.4节(3)的方法,分别记录与子路径a12,a13,a21,a31,a32相关的其他子路径,并统计这些相关子路径的条数,如表2所列.Page9子路径a12a13a21a31a32首先,选取a31作为基准子路径,生成的可执行路径为(a31),并将a31从集合A中删除;然后,选取a13作为基准子路径,生成的可执行路径为(a13,a21),并将a13,a21从集合A中删除;最后,选取a12作为基准子路径,生成的可执行路径为(a12,a32),并从集合A中删除a12,a32.此时,A=,生成可执行路径结束.经过以上步骤,生成的可执行路径集合为{(a31),(a12,a32),(a13,a21)}.4实验本节通过实验,验证所提方法的有效性.首先,提出实验需要验证的问题;然后,给出实验所用的程序;接着,描述实验过程;最后,给出实验结果和分析.4.1需要验证的问题为了说明本文方法的有效性,需要验证如下问题:(1)本文方法生成的路径是否是可执行的?通过采用随机法生成测试数据,考察生成的测试数据能否覆盖这些路径,说明生成路径的可行性.表3被测程序的基本信息和参数IDT1T2T3T4T5T6T7SpaceFixgramp91T8Totinfo_2.0406T9总计4.3实验过程实验的硬件条件为:英特尔酷睿双核3.10GHz(2)本文方法生成的可执行路径,能否覆盖所有的变异分支?通过覆盖可执行路径的测试数据,对变异分支的覆盖率反映.(3)本文方法生成的可执行路径是否很少?通过子路径之间的随机结合和排列组合,形成的可执行路径的条数,与本文方法生成可执行路径比较,说明可执行路径的多少.(4)计算相关矩阵所需的样本容量,是否会影响本文方法的性能?通过不同样本容量,本文方法生成的可执行路径条数和运行时间,反映样本容量的影响.4.2被测程序选取9个基准和工业程序作为被测程序,验证本文方法的有效性,这些程序的基本信息如表3所列,其中,程序T1~T5常用于变异测试,选自文献[39-40];T6是一个简单的UNIX通用程序,选自文献[41];此外,为了评价本文方法在工业程序测试中的适用性,选择西门子系统的程序T7、T8和T9为被测程序,其源代码可以从网站http://sir.unl.edu/portal/index.php免费下载;T7选择的是Space[42-43]的Fixgramp函数;T8、T9规模比较大些,包含的分支和函数比较多,且这些函数的类型复杂,既有嵌套调用,又有递归调用,是多个文献[44-46]的被测程序.需要说明是,在表3第4列的输入空间,程序T9输入变量采用ACSII编码方式,在程序中可以将ACSII值和对应的字符进行转化.程序功能三角形分类求三个数中值销售人员的提成计算某天的次序插入排序计算一年的日历10矩阵语言翻译器统计表中信息,表中数据是整数.模式匹配CPU、2GB内存;软件采用MicrosoftWindowsXPSP3操作系统和VC++开发环境.Page10实验中,根据被测程序的代码行数,分别选择3~20个不同的被测语句进行变异.根据程序的结构和被测语句的类型,选择被测语句的变异算子,实施变异操作,以生成变异体.对非等价变异体采用文献[7]的方法,生成相应的变异分支.对于每个被测程序,首先,将生成的变异分支,插入到原程序中,形成新的被测程序P;然后,基于第3.2节的方法,对P中的变异分支形成新分支,插入到原程序中,形成另一被测程序P.对于程序P,首先,给定某一样本容量,采用第3.3、3.4节的方法,生成一条或多条路径;然后,以所提方法生成的一条或多条路径为目标路径,采用随机测试数据生成方法[45],在被测程序的输入空间内随机采样,直到生成覆盖这些路径的测试数据,或迭代到一定代数,终止程序,并考察这些测试数据覆表4随机法生成覆盖可执行路径的测试数据IDT1T2T3T4T5T6T7T8T9总计盖的变异分支;最后,通过子路径之间随机结合和排列组合结合,形成的可执行路径,与本文方法生成的可执行路径比较,说明后者路径条数是否较少.此外,设置不同的样本容量,考察其对生成的可执行路径数目和运行时间的影响.4.4实验结果与分析为了回答第4.1节提出的问题,设计了4组实验.现在给出实验结果,并进行分析.(1)生成路径的可执行性为了验证本文方法生成的路径是可执行的,考虑上述9个被测程序.由表3可知,这些被测程序共产生了458个变异体,其中265个非等价变异体;将这些非等价变异体转化为相应的变异分支,形成101条新的变异分支.采用第3.4节的方法,生成了39条路径,如表43,3,114,-85,59,118,95,-95,-60,29,-1025,2,-11,9,3,-62,69,-39,-124,87,106,55"□","EED","nd|-a""%Q","1ry","3#gd""□?","m@mpq","6er□-""4Te","7@a8","1,/1A""□-","□&]","6er□sd""□-","@tds","rer□3""□9,"□[%0&","1%#1b""□?","OPE","er&"Page11的第3列所示.采用随机法,生成的覆盖路径的测试数据,如表4的第5列所示,其中T9的测试数据为ACSII值对应的字符,“□”代表空格.此外,表4的第4列还给出了生成这些测试数据的迭代次数;第6列统计了生成路径的覆盖率.由表4可以看出,生成路径的覆盖率均为100%.这说明,采用本文方法生成的路径,确实是可执行的.(2)可执行路径对变异分支的覆盖为了验证采用本文的方法,生成的可执行路径路径编号变异分支条数123由表3、表5和表6可知,这些程序的可执行路径,能够覆盖它们所有变异分支.上述实验结果表明,采用本文方法生成的可执行路径,能够覆盖程序的所有变异分支.(3)生成的可执行路径条数为了验证采用本文的方法,生成的可执行路径条数比较少,与另外2种路径生成方法比较,一种方法是随机结合法,该方法通过随机结合约简后的相关矩阵中的子路径,生成可执行路径;另一种方法是排列组合法,该方法基于子路径集合,通过排列组合方法,生成可执行路径.所提方法在形成新变异分支和生成子路径时,基于同一语句形成的变异分支比较少,程序局部结构比较简单,因此,采用静态分析比较准确;此外,将新变异分支插装到原程序中,将增加测试的代价.鉴能否覆盖新程序的所有变异分支.首先,考察程序T1.由表4可知,该程序共生成3条可执行路径.为了验证这3条路径能否覆盖该程序的16条变异分支,针对每一路径,考察该路径覆盖的变异分支,结果如表5所列,这3条可执行路径覆盖了程序T1的所有变异分支.其中,重复覆盖的变异分支有3条.然后,对于其他被测程序,采用上述方法,能够得到可执行路径覆盖的变异分支,对于重复覆盖的变异分支,只记录1次,结果如表6所列.ID路径编号变异分支条数T2总计T3总计T4总计T5总计T6总计于此,从子路径生成可执行路径这一步,选择随机法和组合法,与所提方法进行比较.以程序T1为例,说明采用随机结合法,生成可执行路径的过程.由第3.5节的约简后矩阵可知,共有5条子路径.通过随机方式结合这5条子路径,形成一系列路径,这些路径中包含很多不可执行路径,最终得到了5个可执行路径集合,每一个集合包含了若干条可执行路径.对于其他8个被测程序,采用上述方法,也能够得到相应的可执行路径集合,如表7所列.由表4和表7可知,①子路径之间的随机结合得到的路径集合,包含的可执行路径不同,这些路径的条数也不尽相同,其中,针对每一被测程序,第1个集合包含的可执行路径最多,最后1个集合包含的可执行路径最少;②采用本文方法得到的可执行路径,与最后1个集合包含的可执行路径相同.Page12表7采用随机法生成的路径集路径集T71ID路径集编号T1T2123451234562~2526~51T31{(a11),(a12),(a21),(a31),(a32)}T41{(a11),(a21)}T51{(a11),(a12),(a13),(a21)}T6123上述实验结果表明,与随机结合法相比,本文方法得到了较少的可执行路径.仍以程序T1为例,说明采用排列组合法,生成可执行路径的过程.T1的子路径集合A={{a11,a12,a13},{a21,a22},{a31,a32}},通过静态分析,得知该集合包含子路径最多的集合为A1={a11,a12,a13},共包含3条子路径.因为,这3条子路径之间不能相互结合生成可执行路径,所以,可能生成的可执行路径条数3.下面基于A包含的子路径,采用排列组合法,生成可执行路径.首先,从集合A1={a11,a12,a13}中路径集编号表8被测程序T1采用组合方法形成的3条路径101112131415161718编号123451…m{(a11),(a12),(a13),(a21),(a22),(a31),(a41),(a61),(a113)}{(a11,a31),(a12),(a13),(a21),(a22),(a41),(a61),(a113)}{(a31,a61),(a11),(a12),(a13),(a21),(a22),(a41),(a113)}{(a11,a61),(a12),(a13),(a21),(a22),(a31),(a41),(a113)}{(a11,a31,a61),(a12),(a13),(a21),(a22),(a41),(a113)}{(a11),(a22),(a52),(a63),(a101),(a142),(a12),(a23),(a42),(a91),(a31),(a93),(a113),(a33),(a82),(a41),(a71),(a122),(a51),(a111),(a121),(a133)}{(a11,a22),(a52),(a63),(a101),(a142),(a12),(a23),(a42),(a91),(a31),(a93),(a113),(a33),(a82),(a41),(a71),(a122),(a51),(a111),(a121),(a133)}{(a11,a22,a52),(a63),(a101),(a142),(a12),(a23),(a42),(a91),(a31),(a93),(a113),(a33),(a82),(a41),(a71),(a122),(a51),(a111),(a121),(a133)}{(a11,a22,a52,a63,a101,a142),(a12,a23,a42,a91),(a31,a93,a113),(a33,a82),(a41,a71,a122)(a51),(a111,a121)),(a133)}2C13C1取出3个元素,且每次取出一个不重复的元素,有C1取出0或1个元素,且每次取出不重复的元素,有C13C12C1或1个元素,且每次取出不重复的元素,有C13!种取法;最后,删除重复的路径组合,得到不重复的路径集合,共有C13!3!3!/3!=36个,如表8所列.在这些路径集合中包含了一些不可执行路径,最终,仅有第35和36个路径集合包含可执行路径.路径集编号192021222324252627282930313233343536Page13对于被测程序T2~T9,采用上述方法,也得到相应的可执行路径的集合,如表9所列.表中第2列表9其他被测程序采用组合方法生成的路径集IDT2{{a11,a12,a13},{a21,a22,a23},{a31,a32}}T3{{a11,a12},{a21},{a31,a32}}T4{{a11},{a21,a22}}T5{{a11,a12,a13},{a21,a22},{a31}}T6{{a11},{a21,a22},{a31},{a41},{a51},{a61},{a71}}T7{{a11},{a21},{a31},{a41},{a51},{a61,a62}}{{a11,a12,a13},{a21,a22},{a31},{a41},{a51},{a61},{a71},{a81},T8T9{{a11,a12},{a21,a22,a23},{a31,a32,a33},{a41,a42},{a51,a52,a53},由表4和表8、表9可知,①采用组合法生成的路径数,与本文方法生成的可执行路数相同;②采用组合法生成的路径,通过占优关系约简之后,与本文方法生成的可执行路径相同.上述实验结果表明,本文方法与采用排列组合方法生成的可执行路径数相同.本组实验结果表明,采用本文方法生成的可执行路径比随机结合法少;与排列组合法生成的可执行路径相同.下面从实验消耗成本方面进行分析.采用随机法生成路径时,一次运行程序,生成一个路径集,如表7所列,生成的可执行路径个数不确定.采用组合法生成的路径集,如表8所列,T1程序仅生成了3条路径,有效路径与路径数量的比为5.5%(2种可执行路径集合×3/(36种×3)).如果生成的路径多于3条,那么,有效路径与路径数量的比更小.对于其他8个被测程序,也能得到类似的实验结果.随着程序规模的增大和变异分支的增多,随机法和组合法形成的路径组合条数将呈爆炸式增长.而所提方法的有效路径与路径数量的比为100%.更重要的是,随机法和排列组合法生成的路径集包含的不可执行路径,检测起来相当困难.到目前为止,还没有一种有效的方法,自动检测某程序的所有不可执行路径[38],导致的后果是,需要花费很多的时间,人工检测不可执行路径.而采用本文方法自动生成的全是可执行路径,且运行时间少.表10给出了R=5000时,采用本文方法,由子路径自动生成可执行路径的运行时间.由该表可以看为各被测程序的子路径集合;第3列为生成的可执行路径集合;第4列为该集合包含的可执行路径条数.{(a11,a31),(a12,a21),(a22),(a13),(a23,a32)}{(a11),(a12),(a21),(a31),(a32)}{(a11,a21),(a22)}{(a11),(a12),(a13,a22),(a21,a31)}{(a11,a22,a31,a51,a61,a71),(a21,a41)}{(a11,a61),(a51),(a21,a31,a41,a62)}{(a11,a31,a51,a61,a71,a81,a91,a101,a111,a121,a131,a141,a151,a161,a172),(a12,a112,a171),(a41),(a13),(a21),(a22),(a113)}{{a12,a23,a32,a42,a62,a81,a91,a112,a123,a132},{a133},{a51},{a31,a93,a113},{a21,a53,a61,a92,a111,a121,a131,a141},{a33,a82},{a41,a71,a122},{a11,a22,a52,a63,a101,a142}}出,除了T6和T9运行时间稍多之外,其他程序的运行时间均较少.因此,与其他2种方法比较,本文方法是高效的.T1,T3,T4,T5(4)样本容量对本文方法性能的影响下面,分析样本容量对本文方法生成可执行路径的条数和运行时间等性能指标的影响.首先,考虑样本容量对本文方法生成可执行路径条数的影响.如表11第2和第8列为被测程序包含的子路径条数;第3和第9列为实验中选取的不同样本容量;第4和第10列为不同样本容量下,两个不同子路径之间相关度α≠0的个数;第5和第11列为本文方法生成的相应的可执行路径条数.由表11可以看出,①随着样本容量的增加,两个不同子路径之间相关度α≠0的个数增多;②α≠0的个数越多,由子路径生成的可执行路径条数越少;③当样本容量很大时,α≠0的个数将保持不变,此时,生成可执行路径的条数将很少.然后,考察样本容量对程序运行时间的影响.不同样本容量下,本文方法生成可执行路径运行的时间如表11的第6和第12列所示.由该表可以看出,除了程序T6,T9之外,对于其他被测程序,样本容量对运行时间的影响几乎可以忽略不计.每个程序样本容量的充分值,需要通过多次运行该程序才能得到.一般情况下,α≠0个数不再变化时Page14ID子路径条数表11样本容量的影响T1T2T3T4T9的样本容量值,即为该程序的样本容量充分值.如表11第3和第9列所示,R标注为“”的值,为该程序的样本容量充分值.5总结本文研究弱变异测试问题,并将弱变异测试转化为路径覆盖问题,期望利用已有的路径覆盖方法,生成高质量的变异测试数据,以提高变异测试数据生成的效率.为此,首先,对同一语句变异形成的多个变异分支,基于执行关系,形成新的变异分支;然后,利用该语句与新变异分支的相关性,生成包含新变异分支的可执行子路径;最后,采用统计分析方法,生成一条或多条覆盖所有子路径的可执行路径.这样做的好处是,覆盖上述可执行路径的测试数据,一定能够杀死相应的变异体,从而为生成高质量的变异测试数据,提供了一条可行的途径.为了评价所提方法的性能,将所提方法应用于9个基准和工业程序测试,并与随机法和排列组合法比较.实验结果表明:(1)采用本文方法生成的路径均为可执行的;(2)这些可执行路径能够覆盖所有的变异分支;(3)采用本文方法生成的可执行路径条数少,运行时间短;此外,本文方法涉及的样本容量,对生成ID可执行子路径条数T5T6T7T8T9的可执行路径数目有一定的影响,而对程序的运行时间基本没有影响.值得说明的是,本文在生成可执行路径时,仅考虑了生成可执行路径的条数,而没有考虑这些可执行路径覆盖的难易程度.一种可能的情况是,虽然可执行路径少,但是,如果这些路径难以覆盖,那么,也难于生成覆盖这些路径的测试数据,从而降低了变异测试数据生成效率,鉴于此,在后续的研究中,有必要进一步结合路径覆盖的难易程度,生成条数少且容易覆盖的可执行路径,以提高变异测试数据生成的效率.此外,对于并行程序的弱变异测试,如何生成相应的可执行路径,也是需要进一步研究的问题.致谢各位审稿专家对本文提出了宝贵的评审意见,这些评审意见对提高论文水平具有很大的帮助.编辑付出了辛勤工作.在此一并致谢!
