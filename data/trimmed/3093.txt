Page1扩展不干扰模型(ENISM)及基于CSP的描述和验证方法崔隽黄皓高晓春1)(南京大学软件新技术国家重点实验室南京210093)2)(南京大学计算机科学与技术系南京210093)摘要在不干扰理论的基础上,提出扩展不干扰模型ENISM及其验证方法,用以描述和分析操作系统中的信息流策略.工作包括:(1)依据系统功能模块定义多个执行域,以即将执行的可能动作序列集合与可读取的数据存储值集合一同作为ENISM定义执行域安全状态的基础;(2)给出判定系统中不存在违反策略的执行轨迹和数据流动的条件ENISM-CC;(3)基于通信顺序进程给出ENISM-CC的语义及操作系统模块设计的形式化描述和验证方法.关键词不干扰模型;通信顺序进程;形式化描述;形式化验证;完整性1引言特性,是目前操作系统安全验证的主要方法之一.信息流分析的方法使我们能够清楚地理解系统内部信息的流动方向,从独立于系统操作的另一个角度观察系统的实际行为.操作系统的很多安全属性都可用信息流模型来形式化地分析操作系统的安全Page2以表述成一系列相关的信息流策略,比如机密性、完整性、隔离性、不可旁路性等.通过信息流分析,我们可以证实一个操作系统的设计是否能够满足给定的信息流策略所表达的安全属性.信息流分析方面的研究工作很多,Goguen和Meseguer提出的不干扰模型[1]是最主要的研究成果之一.不干扰模型通过观察信息域中信息值的改变来感知信息的流动,而不是简单依靠对读写操作的考察来推测信息流向,具有比其它信息流模型更好地发现确定性系统中各种存储隐蔽信道问题的能力.Haigh、Young[2]和Rushby[3]等人在不干扰模型基础上在信道控制方面对其进一步探讨,提出了干扰的非传递性.谢钧[4]等则将不干扰模型从确定性系统推广到非确定系统.虽然不干扰模型在信息流策略的形式化描述和验证方面有很好的表现,但不干扰模型主要关注的仍是存储信息的改变,忽略了执行轨迹的变化.尽管广义上讲,信息域执行轨迹的改变也是一种信息的表征,但是在具体的系统策略验证过程中很难直观地判断目标域未来执行的路径是否发生了改变.仅依靠考察存储值的改变并不能完全反映出执行轨迹的变化,而执行轨迹的变化,特别是安全控制模块轨迹的改变或被旁路往往会产生极其严重的后果.因此,为了更好地表达和分析系统的信息流策略,信息域的行为执行是否受到其它域的干扰也是信息流分析工作必须考察的对象.Ryan[5]、Roscoe[6]和Graham[7]都分别使用进程代数的方法从不同的视角描述了不干扰模型的语义,并阐述了高密级信息域的执行轨迹对低密级信息域的输出及可执行动作集合的影响,Roscoe和Goldsmith[8]在此基础上还针对非传递特性作了进一步探讨,并给出了判定干扰性存在的方法.马建平[9]等则将不干扰关系定义为如果一个信息域A不干扰另一个信息域B,则A的行为既不会改变B内存储变量的值,也不会影响B当前状态下可执行的动作.上述文章表明,对执行序列的描述有助于分析信息域之间的不干扰属性,然而,本文认为还可以在3个方面做进一步探讨.首先,用进程代数描述不干扰属性,主要描述的是行为本身,而忽视了输入数据对行为执行的影响,往往将具有不同输入值的同一输入事件视为同一事件来考虑,这就屏蔽或减弱了不同输入值对信息域的干扰作用.其次,本文认为当前状态下可执行的序列集合比当前状态下可执行的事件集合更能准确地反映信息域内执行的改变,可执行的序列集合可反映出目标域未来的执行趋势,其不仅可以反映出未来每一个状态的可执行事件,更将各个状态联系起来更精确地考察目标域的执行改变.最后,目标域的执行受到了干扰还是信息值受到了干扰并不总是一致的,应分别讨论.在实际的信息系统中,两个合作的模块一定存在着合理的信息流动(如访问控制器的输入模块和决策模块),但这并不表明合作模块之间一定允许通过交互数据改变对方的执行轨迹(如输入模块只许给决策模块传递决策信息,而不允许改变决策模块的决策过程).因此,我们认为应针对目标操作系统的执行不干扰和存储不干扰分别制定安全策略.基于以上考虑,本文提出更适于描述操作系统的信息流策略的扩展不干扰安全模型(ENISM)及验证系统设计是否满足该策略的验证方法.我们将各个功能相对独立的系统模块均视作执行域.ENISM在传统不干扰模型的基础上增加了未来可能执行的动作序列集合的改变作为分析目标域安全状态是否发生改变的依据之一,动作序列集合和信息存储值集合一同考察更能准确地反映出目标域的当前状态;ENISM将输入数据值反映在输入动作中,将能够接收不同输入数据的同一输入动作看作同一动作的不同执行,以反映不同输入对目标域的影响;ENISM分别考察目标域的执行不干扰条件和数据存储的不干扰条件,有助于从执行域之间的执行干扰和存储干扰两方面分析、描述和验证系统的信息流策略.为了能够形式化描述一个实际的操作系统设计,并正确有效地描述、分析和验证系统的信息流策略,本文还通过通信顺序进程(CSP)[10-11]来实现系统设计的形式化描述和策略的语义表述.CSP用一组通信进程来描述系统行为,能够准确地描述系统的执行轨迹,这正是描述行为不干扰属性所需要的.本文给出基于CSP的形式化描述系统设计的方法,用CSP诠释ENISM中判定系统安全性条件的语义,并使用CSP验证工具FDR2①针对操作系统中的引用监视器设计的实例演示策略制定、设计描述、信息流分析、自动化验证的全过程.本文第2节给出扩展不干扰模型ENISM的定义,提出执行不干扰和存储不干扰的概念,并在此基础上给出基于单步状态的安全展开条件(unwindingconditions),即设计中存在违背信息流策略的执行①FDR2用户手册.http://www.fsel.com/documentation/Page3轨迹或数据流动的充分条件(ENISM-CC);第3节基于通信顺序进程CSP给出系统设计的形式化描述方法和ENISM-CC的语义,并给出形式化分析和验证信息流策略的方法;第4节以引用监视器为例,说明ENISM的有效性和形式化验证方法的可行性.2扩展不干扰模型2.1扩展不干扰模型的定义本文在研究信息域不干扰理论的基础上,提出了扩展不干扰模型ENISM.该模型将执行域中即将执行的动作序列和执行域主体可观测的存储信息一同作为考察执行域完整性的对象.因此,除保留传统不干扰模型所包含的执行域、状态、值域、状态转换函数、取值函数等元素外,还细化了执行域的定义,增加了对执行域上行为集合和数据存储集合的描述,并将输入数据作为输入动作的一个属性引入到定义中,以方便描述输入数据的不同对执行域可观测的存储值和执行序列的影响.该模型还定义了执行域上某个执行状态之前和之后的执行序列,通过描述已执行和即将执行的动作序列来推测可能存在的干扰.下面首先用状态转换机来描述一个确定系统,然后针对给定的不干扰策略给出系统信息流安全的定义以及单步展开条件.定义1.系统M包括以下元素:系统中所有的数据对象的集合O;系统中的数据对象可能取值的集合V;系统行为集合A.系统行为ax∈A,x描述了动作a的输入值,以区分同一动作接受的不同输入.如果a没有输入,则x取值ε;系统状态集合S,系统的初始状态记为s0;系统执行域集合D,一个域u∈D包含了可在这个域上执行的行为集合uI和这个域上可观测的数据存储的集合uD.且D上存在关系∪,有u,v∈D,u∪v∈D;行为可执行判断函数enabled:S×A→Boolean,enabled(s,ax)表示在状态s下动作ax是否可执行;单步状态转换函数step:S×A→S.如果enabled(s,ax)=true,则在状态s下执行动作ax后系统由状态s转化为状态step(s,ax);行为执行域函数dom:A→D,dom(ax)表示了行为ax所在的执行域;信息域取值函数values:S×2O→2V.ObjsO,values(s,Objs)表示在状态s下,数据存储集合Objs中元素对应取值的集合;系统的行为执行轨迹集合Ts.Ts记录了系统由状态s开始到任意时刻为止的所有可能行为序列的集合;Ts,u则表示了Ts在域u上的行为序列的集合.且有ε∈Ts,u;axα∈Ts,u,ε表示空串,表示行为或行为序列的复合运算符,axα表示先执行行为ax,然后执行行为序列α;系统已执行的行为轨迹RTs.RTs记录了系统由初始状态s0转化到状态s过程中的行为序列;RTs,u则表示了RTs在域u上的行为序列;系统执行函数run:S×A→S,α∈Ts时,run(s,α)有定义,并且满足run(s,ε)=s,run(s,axα)=run(step(s,ax),α).为了能够描述同一行为的不同输入,我们定义集合A上的关系R.对于A中的任意两个行为,如果它们是执行的同一段代码,则认为它们满足关系R,显然关系R满足自反、对称和传递性.基于关系R可以建立等价类集合A/R,记为RA,有定义{[ax]}=RA={c|c∈A∧cRax}.为描述方便将[ax]简记为a,下文中会用a来描述可接受不同输入的一类R等价行为.系统的信息流策略可以定义为集合Du={uI,uD|u∈D}上的关系及其补关系=Du×Du\.并分别称和为干扰关系和不干扰关系.对于任意的u,v∈D,uDvI,uIvI反映了域v的行为执行可能受到域u的执行或可观测数据值的影响,而uDvD,uIvD反映了域v可观测的数据值可能受到域u的执行或可观测数据值的影响.下面依据给定的信息流策略定义系统的信息流安全.在定义系统的信息流安全之前,首先定义系统的执行安全性和存储安全性,以分别描述满足信息流策略的行为和信息流动.定义2.执行安全性.给定系统M以及安全策略,如果v∈D,α∈Ts0满足PurgeI(α,v)∈Ts0∧Trun(s0,α),v=Trun(s0,PurgeI(α,v)),v,则称系统M满足执行安全性.其中,提取函数PurgeI从执行序列α∈A中去除所有不允许干扰vI的行为,从而得到一个新的序列.提取函数的定义如下:PurgeI(ε,v)=ε;PurgeI(axα,v)=axPurgeI(α),dom(ax)IvIPage4定义2说明,如果从任意可执行序列中去掉所有不允许干扰域v执行的行为后,余下的行为仍能构成一个可执行序列,且该序列的执行不影响域v的执行轨迹.定义3.存储安全性.给定系统M以及安全策略,v∈D,α∈Ts0,满足PurgeD(α,v)∈Ts0∧values(run(s0,α),v)=values(run(s0,PurgeD(α,v)),v),则称系统M满足存储安全性.SoursesD(ε,v)={vD},SoursesD(axα,v)={dom(ax)I}∪SoursesD(α),烄{dom(ax)I}∪{dom(ax)D}∪SoursesD(α),u∈SoursesD(α,v).dom(ax)Iv∧dom(ax)Dv烅SoursesD(α),烆定义3说明,如果从任意可执行序列中去掉所有不允许干扰域v的可观测信息值存储的行为后,余下的行为仍能构成一个可执行序列,且该序列的执行不影响域v的可观测数据值.从SoursesD函数的定义可以看出,要保证提取之后的序列仍是可执行序列,不仅要保留允许改变域v的数据值的域行为,也要保留允许影响这些行为执行的其它域的行为.由于对目标域执行轨迹集合的考察侧重于分析存储隐蔽通道,而对目标域数据值的考察则侧重于解决信道控制问题,所以从提取函数PurgeI、PurgeD的定义可以看出,对目标域的行为集合的干扰策略支持传递性,而对目标域的数据集合的干扰策略则不支持传递性.即对于任意的u,w∈Du,v∈D,如果策略允许uvI且vIw,则策略也同样允许uw,但是即使策略允许uvD且vDw,策略也不一定允许uw.定义4.对于给定的系统M以及安全策略,如果对于M中的任意安全域u∈D,同时满足执行安全性和存储安全性,则称系统M满足安全策略.定义4描述了如果系统M中不存在违背安全策略的信息流动和不被安全策略允许的执行轨迹,则可以说系统M是安全的.因此,定义2和定义3给出的执行安全性和存储安全性条件就是系统M满足安全策略的条件.为了便于系统验证,下文将给出并证明只涉及单步状态改变的展开条件.定理1.ENISM单步展开定理(ENISM-CC).对于给定的系统M和安全策略,对于s,t∈S,v∈D,ax∈A,如果存在状态等价关系~vI,~vD满足下列条件,则系统M满足安全策略.其中,提取函数PurgeI从执行序列α∈A中去除所有不允许干扰vI的行为,从而得到一个新的序列.提取函数的定义如下:PurgeI(ε,v)=ε;PurgeI(axα,v)=axPurgeI(α),dom(ax)IvI其中,SoursesD函数计算由所有允许干扰vD的执行域构成的集合(i)s~vItTs,v=Tt,v;(ii)s~vIt∧enabled(s,ax)∧dom(ax)IvI∧RTs,TB=RTt,TBenabled(t,ax)∧step(s,ax)~vIstep(t,ax);(TB={∪u|u∈D,uIvI});(iii)(dom(ax)IvI∧enabled(s,ax)s~vIstep(s,ax);(iv)s~vDtvalues(s,v)=values(t,v);(v)s~vDt∧enabled(s,ax)∧enabled(t,ax)∧(dom(ax)DvD→s~dom(ax)Dt)step(s,ax)~vDstep(t,ax);(vi)(dom(ax)IuD∧enabled(s,ax)s~vDstep(s,ax);s~vIt的实际意义表示:对于域v而言,在状态s和t下可执行轨迹是完全相同的,简记为执行等价.同样s~vDt的实际意义表示:对于域v而言,在状态s和t下可观察到的信息值是完全相同的,简记为存储等价.条件(i)和(iv)表示:若两状态下v满足执行等价或存储等价,则在这两状态下可执行的轨迹集合或可观测的信息值集合相同;条件(ii)表示若两状态下v满足执行等价,且在这两个状态下,所有允许干扰vI的执行域上已执行了相同的轨迹,则两状态下在上述域上可执行相同的行为ax,且执行ax后v上仍满足执行等价;条件(v)表示若两状态下v满足存储等价,且可执行相同的行为ax,如果域dom(ax)在这两状态下也是存储等价的,则执行ax后v上仍满足存储等价;条件(iii)(vi)表示,执行不Page5允许干扰vD或vI的行为后达到的状态,与执行前的状态在vD或vI上是等价的.和存储安全性条件.即证明.证明单步条件能够推导出执行安全性(i)(ii)(iii)(iv)(v)(vi)(v∈D,α∈Ts0→((PurgeI(α,v)∈Ts0∧Trun(s0,α),v=Trun(s0,PurgeI(α,v)),v))∧(PurgeD(α,v)∈Ts0∧values(run(s0,α),v)=values(run(s0,PurgeD(α,v)),v))).(1)证明单步条件能推出执行安全性.由s0~vIs0,RTs0,TB=RTs0,TB知,如果能够证明v∈D,s,t∈S.RTs,TB=RTt,TB∧s~vIt∧α∈TsPurgeI(α,v)∈Tt∧Trun(s,α),v=Trun(t,PurgeI(α,v)),v则命题得证.对α的长度进行归纳证明.①当α=ε时,命题显然成立.②假设α使命题成立,现证明aα也同样使命题成立.假设对a分情况讨论:a)若dom(a)IvI,则又由条件(iii)得所以又由dom(a)IvI知则于是由归纳假设和式(4)、(5)知PurgeI(α,v)∈Tt∧Trun(step(s,a),α),v=Trun(t,PurgeI(α,v)),v于是由式(2)和run、step的定义知PurgeI(aα,v)∈Tt∧Trun(s,aα),v=Trun(t,PurgeI(aα,v)),v.b)若dom(a)IvI,则由式(1)和条件(ii)得又由式(1)和RT的定义得则由归纳假设和式(8)、(9)得RTstep(s,a),TB=RTstep(t,a),TB∧α∈Tstep(s,a)(9)PurgeI(α,v)∈Tstep(t,a)∧Trun(step(s,a),α),v=Trun(step(t,a),PurgeI(α,v)),v由run、step的定义知aPurgeI(α,v)∈Tt∧Trun(s,aα),v=Trun(t,aPurgeI(α,v)),v由式(7)得PurgeI(aα,v)∈Tt∧Trun(s,aα),v=Trun(t,PurgeI(aα,v)),v综上所述,由①、②的结论可推出执行安全性(2)证明单步条件能推出存储安全性为证明方便,记s~SourcesD(α,v)t=def(w∈SourcesD(α,v).s~wt),条件.则由其中SD={∪u|u,w∈D,wI∈SourcesD(α,v),uIvI}知,如果能够证明v∈D,s,t∈S.RTs,SD=RTt,SD∧s~SourcesD(α,v)t∧α∈TsPurgeD(α,v)∈Tt∧values(run(s,α),v)=values(run(t,PurgeD(α,v)),v),则命题得证.对α的长度进行归纳证明.①当α=ε时,命题显然成立.②假设α使命题成立,现证明aα同样使命题成立.假设对a分情况讨论:a)若dom(a)ISourcesD(aα,v),则又由条件(iii)(vi)及SourcesD函数的定义得所以又由假设条件(11)知于是由归纳假设和式(14)、(15)知PurgeD(α,v)∈Tt∧values(run(step(s,a),α),v)=values(run(t,PurgeD(α,v)),v),于是由式(12)和run、step的定义知PurgeD(aα,v)∈Tt∧values(run(s,aα),v)=Page6PurgeD(α,v)∈Tstep(t,a)∧values(run(step(s,a),α),v)=enabled(t,a),step(s,a)~SourcesD(α,v)step(t,a)(17)又由假设条件(11)知由归纳假设和式(17)、(18)知values(run(step(t,a),PurgeD(α,v)),v)由run、step的定义知values(run(t,aPurgeD(α,v)),v).由式(16)得aPurgeD(α,v)∈Tt∧values(run(s,aα),v)=values(run(t,PurgeD(aα,v)),v).b)若dom(a)I∈SourcesD(aα,v),则由条件(ii)、(v)及假设RTs,SD=RTt,SD得PurgeD(aα,v)∈Tt∧values(run(s,aα),v)=values(run(t,PurgeD(aα,v)),v).综上所述,由①、②的结论可推出存储安全性.则由定义4知命题得证.ENISM不仅可用于描述和分析操作系统的信息流策略,更可以用于类似的具有模块化结构的复杂系统的信息流分析和描述.但是,根据不同系统的特点,描述和验证的方法会有所差别,下文将主要针对操作系统的描述和信息流策略的验证给出具体的形式化方法.3基于CSP的系统描述和信息流策略验证方法Rushby在文献[3]中通过考察信息域上的主体对信息值的观察(observe)或修改(alter)能力来描述信息的流动,并通过检查是否存在恶意主体拥有不被允许的能力来查找违反安全策略的信息流动.但是,信息流动不仅仅反映在数据值的传递上,还反映在一个域的行为执行和信息改变对另一个域上的行为执行的影响上,如影响到上节单步展开条件中描述的Ts,u.而行为序列集合Ts,u可能包含多个甚至无限多个连续行为,验证行为序列集合的改变无法使用Rushby的方法来实现.本文通过通信顺序进程(CSP)[10]来形式化描述操作系统的设计和安全状态.CSP用一组通信进程来描述系统行为,能够描述系统的执行轨迹,这正是描述行为不干扰属性所需要的.目前,已有许多支持CSP的自动化验证工具,可辅助我们进行自动化的系统验证.本节即将给出基于CSP的形式化描述系统设计的方法,并用CSP诠释系统M满足安全策略的条件,为进一步利用CSP验证工具FDR2进行形式化验证做准备.为便于理解,先将下文中用到的通信顺序进程(CSP)的部分算子列出如下:P一个进程αPP的子母表a→P前缀算子,ifathenP(a→P|b→Q)选择算子,ifathenPelseifbthenQP/s后继算子,PaftersP‖Q并发算子,PinparallelwithQP\C屏蔽算子,PwithChidingPΓC约束算子,srestrictedtoAP□Q不确定算子,PorQtraces(P)P可能执行的迹的集合failures(P)P当前不接受的动作集合虽然,随着硬件技术和操作系统实现技术的发展,操作系统具有了更复杂的功能,支持对更多资源设备的管理.但是,如果我们不考虑信息的载体和获取信息的方式,总可以把信息抽象为对象,把信息的接收、读取、传送抽象为读、写操作.于是,在描述一个操作系统设计时,除使用标准的CSP算子和定义外,增加定义以下描述规则.定义5.相关定义和描述规则如下.(1)对应于ENISM中的执行域u,进程U描述域u上的执行轨迹集合,并将进程的集合定义为DP;将数据存储或外部输入输出设备描述为d∈uD,读入或写出的系统内变量描述为v.U;将非读写操作c∈uI,描述为c.U;将读写操作描述为d.read.v.U或d.write.v.U;规定每一个读写操作只能描述对一个数据存储或外部输入输出设备的读或写.系统临时变量之间的值传递也必须描述为通过某个外部存储传递.(2)对于给定系统M上的任意进程U和任意迹tr∈Traces(M),定义interferedSet(tr,U)aM为执行迹tr在执行U上操作时读取的数据所能影响的系统变量集合.定义Acts(tr)A为tr中操作的集合,则计算interferedSet(tr,U):①d.read.v.U∈Acts(tr),v.U∈interferedSe(tr,U);②d∈αM,若V,W∈DP,d.write.v.V∈αV,d.write.w.W∈αW,v.V∈interferedSet(tr,U),则w.W∈inter-feredSet(tr,U).由此可计算U的所有输入数据所能影响到的系统M的变量集合为{a|a∈interferedSet(tr,U),tr∈Traces(M)},记为βU.Page7(3)将选择语句中的分支选择条件描述为一组操作,分别作为各分支的起始标记.如tr0→ifcond1(v)thentr1elseifcond2(v)thentr2elseifcondn(v)…elsetrn,可描述为tr0→((v.U.ct1.m1→tr1)|(v.U.ct1.m2→tr2)|…|(v.U.ct1.mn→trn)),其中cti(i=1,…,p),mi(i=1,2,…,n)为不同的自然数,cti用于区分系统中不同的选择语句,mi用于区分选择语句中的不同分支,p描述系统中选择语句的数量,n描述每一个选择语句的分支数.上例中v.U.ct1.m2表示这是描述过程中遇到的第1个选择语句的第2个分支.定义由任一选择语句中的分支起始标记构成的集合为Ecti(i=1,2,…,p),由Ecti(i=1,2,…,p)构成的集合为E={Ecti|i=1,2,…,p},上例中Ecti={v.U.cti.m1,v.U.cti.m2,…,v.U.cti.mn}.(4)函数GetChoiceActs:T×DP→2E,Get-ChoiceActs(tr,U)={Ecti|x.cti.mj∈Ecti,x∈interferedSet(tr,U)},则函数GetChoiceActs描述了tr执行U的操作时读取的数据所能影响到的选择语句集合.(5)对于E的任意子集eE,设e={e1,e2,…,en},则定义函数Cartesian(e)=e1×e2×…×en,描述e中所有元素的笛卡儿积.由于ei描述的是某个选择语句的所有分支起始标记的集合,Cartesian(e)则反映了e中涉及的多个选择语句的所有选择结果的组合.对于其中的任意一种选择结果α∈Cartesian(e),设α={α1,α2,…,αn},定义进程Choice(α)=(α1|α2|…|αn)→Choice(α),Choice(α)可将分支选择结果反映在与其同步的进程中.(6)对于任意执行迹tr∈Traces(M),如果存在某个状态s,是由初始状态s0执行tr后达到的.则一定可以由tr的输入数据和执行轨迹确定GetChoiceActs(tr,M)中的一部分选择语句的分支选择结果,即存在GetChoiceActs(tr,M)的一个子集es和es上的一种选择组合αs,tr,M,有αs,tr,M∈Cartesian(es),下文称αs,tr,M为系统M由初始状态s0执行轨迹tr到状态s时的分支选择向量.(7)d.read.v∈αM,记状态s下d的取值为getData(d,s),v的取值为getParam(v,s).(8)系统描述中遇到不确定选择P□Q,均表达为确定性选择关系(a→P|b→Q),在不影响语义的前提下确保系统描述中不存在非确定性.下面基于CSP和上述描述规则给出一种等价关系定义.定义6.对于给定的系统M和安全策略,任意状态s,t,M中的任意执行域w∈D上进程的描述W.如果由初始状态s0执行到状态s的执行轨迹为trs∈Traces(M),产生的分支选择向量为αs,trs,M,执行到状态t的执行轨迹为trt∈Traces(M),产生的分支选择向量为αt,trt,M,则有s~wDtiff(d.read.v∈αM,getData(d,s)=s~wItiff(((M/trs)‖Choice(αs,trs,M))ΓαW=getData(d,t),getParam(v,s)=getParam(v,t))定义6基于CSP给出了一种状态等价的定义.基于进程W的存储等价要求W可读取的数据存储和W中的变量值在两个状态下都必须是相等的;执行等价则由于引入了数据对执行的影响,不再简单地理解为(M/trs)ΓαW=(M/trt)ΓαW,还要考虑输入对分支选择的影响,即引入了Choice()来体现分支选择的结果.只有trs、trt中的行为及输入值所影响的分支选择结果都不能改变域W上行为的执行时,才能认为状态s,t是执行等价的.基于上述等价关系和CSP描述规则,我们给出目标系统满足不干扰策略的判定条件.定理2.对于确定性系统M和安全策略,如果对于M中的任意执行域w∈D,存在定义6定义的等价关系~wD,~wI,并满足以下条件,则称系统M满足安全策略.(1)执行安全性条件w∈D,u={∪z|zIwI},v={∪z|zIwI}.设W,U,V分别描述域w,u,v上的进程,M=U‖V‖W,则满足Assert(M\αU\βU):[deterministic[FD]]=true(表明M\αU\βU中不存在非确定性).(2)存储安全性条件u∈D,uIwD,设U,W分别描述域u,w上的进程,且满足执行安全性条件要求M\αU\βU是确定的,即通过αU,βU反映U的执行和输入对其它进程的干扰,而存储安全性条件则主要关心两个域之间是否存在直接的信息传递.证明.(1)证明执行安全性条件,即证明满足定理1的(i)(ii)(iii).Page8①由定义5和定义6知即为Ts,w,因此定理1(i)成立.②证明定理1的(ii)成立由定义1知RTs,u是一组行为的执行序列,且有RTs,{v,w}=RTs,{v,w}trs\αU=trt\αU(19)由定理1(ii)的条件enabled(s,ax)∧dom(ax)IwI知,存在a∈αM-αU,(trs〈a〉)∈traces(M).由M\αU\βU的确定性知(trs〈a〉)\αU\βU∈traces(M\αU\βU)(20)假设即由式(19)得如果aβU,则同式(20)有(trt\αU\βU,{a})∈failures(M\αU\βU)(trs\αU\βU,{a})∈failures(M\αU\βU)(22)根据式(20)和(22)知这与M\αU\βU的确定性矛盾.如果a∈βU,则a所在的选择语句必至少还存在另一个分支选择行为b∈βU,满足(trt〈b〉)∈traces(M‖Choice(Choice(αt,trt,M))),因为a不是U进程上的分支选择,所以a,b所在分支在U进程以外存在分歧.不妨设存在行为c∈αM-αU-βU,行为序列trx满足trx∈traces(M\(trs〈a〉));trx∈traces(M\(trt〈b〉));(trx〈c〉)∈traces(M\(trs〈a〉));(trx,{c})∈failures(M\(trt〈b〉));即(trs〈a〉trx〈c〉)∈traces(M);(trs〈b〉trx,{c})∈failures(M);于是有(trs〈a〉trx〈c〉\αU\βU)∈traces(M\αU\βU)(trs〈b〉trx\αU\βU,{c})∈failures(M\αU\βU);由式(19)和a,b∈βU知(trstrx〈c〉\αU\βU)∈traces(M\αU\βU),(trstrx\αU\βU,{c})∈failures(M\αU\βU);这与M\αU\βU的确定性矛盾.即式(21)假设不成立,有最后用反证法证明step(s,ax)~wIstep(t,ax)即假设((M/(trs〈a〉))‖Choice(αstep(s,a),trs〈a〉,M))ΓαW≠((M/(trt〈a〉))‖Choice(αstep(t,a),trt〈a〉,M))ΓαW则一定有((M/(trs〈a〉))‖Choice(αstep(s,a),trs〈a〉,M))\αU\βU≠((M/(trt〈a〉))‖Choice(αstep(t,a),trt〈a〉,M))\αU\βU,即存在不相等的执行序列,不妨设存在trx∈traces(((M/(trs〈a〉))‖Choice(αstep(s,a),trs〈a〉,M))\αU\βU),c∈αM-αU-βU,(trx〈c〉)∈traces(((M/(trs〈a〉))‖Choice(αstep(s,a),trs〈a〉,M))\αU\βU)(trx,{c})∈failures(((M/(trs〈a〉))‖Choice(αstep(s,a),trs〈a〉,M))\αU\βU),同式(23)的证明过程可知,这与M\αU\βU的确定性矛盾.即式(24)的假设不成立,即满足(ii).综合式(23)、(25)可得,系统M满足定理1的③证明此条件满足定理1的(iii).下面同样用反证法证明s~wIstep(s,ax),假设((M/trs)‖Choice(αs,trs,M))ΓαW≠((M/(trs〈a〉))‖Choice(αstep(s,a),trs〈a〉,M))ΓαW则同②的证明过程可得到该假设同样与M\αU\βU的确定性矛盾,即假设错误,s~wIstep(s,ax)得证.即满足定理1的(iii).综上所述,系统M满足定理1的条件(i)(ii)(iii),即系统M满足安全策略.(2)证明存储安全性条件,即证明满足定理1的(iv)(v)(vi)①由定义5和定义6知d.read.v∈αW,getData(d,s),getParam(v,s)即为values(s,v),因此定理1(iv)成立.②由定理1(v)知,对于任意两个状态s,t,若s~wDt∧enabled(s,ax)∧enabled(t,ax)∧(dom(ax)DwD→s~dom(ax)Dt),如果ax不是写操作,显然满足(v);否则不妨设ax=d.write.v..a)如果ax在不干扰w的域中执行,即d.write.v.∈αU,根据数据完整性条件d.write∈αUd.readαW知,d.readαW,即d的改变不会被域w所观察到,仍有values(step(s,ax),w)=values(step(t,ax),w),Page9即满足(v).b)如果ax在干扰w的域中执行,即d.write.v.αU,则有dom(ax)DwD.根据定理1(v)的条件知s~dom(ax)Dt,即getParam(v,s)=getParam(v,t),于是如果有d.read.v.∈αW,则在执行动作d.write.v.后,域w上有getData(d,step(s,ax))=getData(d,step(t,ax)),而对于域w上可观察的其它存储或变量不会因动作d.write.v.的执行而改变,因此满足(v).③如果dom(ax)IwD,即d.write.v.∈αU,根据数据完整性条件d.write∈αUd.readαW知,d.readαW,即d的改变不会被域w所观察到,仍有d.read.v.∈αW,getData(d,s)=getData(d,step(s,ax)),getParam(v,s)=getParam(v,step(s,ax)),即values(s,w)=values(step(s,ax),w),满足定理1的(vi).综上所述,系统M满足定理1的条件(iv)(v)(vi).因此,根据(1)、(2)的证明结论知,系统M满足安全策略.下节主要通过操作系统中的一个实例来说明如何通过上述方案来描述系统设计以及分析和验证系统是否满足给定的信息流策略.4实例研究:引用监控器设计的安全分析与策略验证本文所研究的扩展不干扰模型(ENISM)和基于通信顺序进程(CSP)的描述和验证方法是作者参与的“八六三”课题“分布式可信计算系统研究”中的研究成果之一,被用在对操作系统的安全服务器、引用监视器以及操作系统微内核等关键模块的正确性、完整性、不可旁路性的验证上.本节以引用监控器的设计为例,验证与引用监控器的完整性和不可旁路性相关的信息流策略,即借助形式化验证工具FDR2来验证引用监控器是否满足定理2的两个条件.通过该实例说明ENISM的正确性、有效性和可用性.验证的过程主要分为以下几个步骤:(1)系统功能分析和安全域划分.该实例是一个有关安全操作系统中的引用监控器的实例.任何用户要访问文件系统都必须经过引用监控器来进行访问控制.如图1所示,安全服务器用于存放主客体的安全标识、修改安全策略以及协助引用监控器进行访问控制决策.引用监控器是访问控制的执行单元,安全服务器才是真正的决策单元,模块交互图如下.安全服务器被分为配置管理模块和决策模块.配置管理模块负责对策略文件的维护和修改,需要访问文件系统读取策略文件.决策模块负责对应用程序的访问请求进行权限判断,也需要通过文件系统读取策略文件.应用程序同样需要通过文件系统访问资源.文件系统的入口是引用监控器,所有请求都必须首先经过引用监控器,引用监控器通过向安全服务器决策模块请求决策来决定是否执行文件操作.下为FDR2中源码的部分截图):(2)用CSP描述各模块的执行过程和数据资源下面我们用CSP来描述各模块的执行过程(以(a)引用监控器的描述引用监视器(RM)接收请求访问文件系统的进程信息Pinfo、要访问的文件信息,如果是安全服务器(SS)的请求(包括配置模块(SSA)和决策模块(SSD)),则通知文件系统FS执行,否则向SSD发送permQuery,询问请求进程是否有访问该文件的权限.如果SSD返回Yes,则通知FS执行,否则向请求者返回拒绝信息reject.Page10(b)安全服务器的描述块(SSD),写策略模块(SSDc).安全服务器(SS)分为配置模块(SSA),决策模SSA接受管理员的命令向文件系统FS请求更新策略文件,请求被RM截获.更新完毕,会发送消(c)客户程序的描述客户程序Client接收用户输入,并向FS请求(d)文件系统的描述文件系统FS接收RM的指令accessFS,执行(e)消息传递进程的描述实际系统中是由内核实现消息传递的,这里引入msgPass进程实现该功能.用于接收和转发其它上述各模块并发执行,并通过msgPass同步,构成完整的系统M,其描述如下:M=(SSA|||SSD|||SSDc|||Client|||RM|||RM|||RM|||FS|||FS|||FS)[|aM|]msgPass.上述CSP描述构成了系统的完整描述,以.csp文件的形式提交给形式化验证工具FDR2进一步分析.(3)提出安全目标,制定安全策略,安全策略反映为不干扰关系.由于篇幅的限制,我们仅对引用监控器最敏感的不可旁路的安全目标进行验证.由于安全服务器配置模块SSA和用户模块Client都提供了对用户的接口,根据用户请求访问文件系统FS,它们是RM主要监控的对象.因此,本例验证的目标是:SSA和Client不可以绕过RM直接干扰文件系统FS.验证目标描述成不干扰关系是:息exchangeAD通知SSDc修改内存中的策略信息.SSD接受来自RM的权限决策请求permQuery,并依据permQuery中的用户信息和请求操作查询策略库,得到决策结果,并将决策结果返回RM.文件访问,文件请求被RM截获并处理.客户程序等待处理结果accqueryResult.文件操作,并向RM返回结果.进程之间的同步消息,以实现进程间同步.msgPass描述的片断如下:SSAIRMI;ClientIRMI;SSAIRMD;ClientIRMD;SSAIFSI;ClientIFSI;SSAIFSD;ClientIFSD;RMIFSI;RMIFSD;SSDIRMI;SSDIRMD;SSAISSDI;ClientISSDI;SSAISSDD;ClientISSDD;SSDcIRMI;SSDcIRMD;SSDcIFSI;SSDcIFSD;SSAISSDcI;SSAISSDcD.上述不干扰关系表明SSA、Client、SSDc只能向RM传递数据而不能改变其执行路径;SSA、Client、SSDc既不能直接向SSD、FS传递数据也不能改变其执行路径;RM可以与FS有直接的交互,甚至调用FS执行.(4)根据定理2(2)验证以下对数据存储的不干SSAIFSD;ClientIFSD;SSAISSDD;ClientISSDD;SSDcIFSD.扰关系:Page11验证过程如下:SSA写数据集合为{accquerycont.write.ac-cFile.SSAn,accqueryPinfo.write.Pinfo.SSAn,exchangeAD.write.result.SSAn};影响到的读数据集合为{accquerycont.read.accFile.RMn,ac-cqueryPinfo.read.Pinfo.RMn,exchangeAD.read.result.SSDn};Client写数据集合为{accquerycont.write.ac-cFile.Clientn,accqueryPinfo.write.Pinfo.Cli-entn};影响到的读数据集合为{accquerycont.read.accFile.RMn,accqueryPinfo.read.Pinfo.RMn};修改后的SSDc写数据集合为{accquerycont.write.accFile.SSDn,accqueryPinfo.write.Pinfo.SSDn,exchangeDA.write.policyinfo.SSDn,poli-cyFlash.write.policyInfo.SSDn};影响到的读数据集合为{accquerycont.read.accFile.RMn,ac-cqueryPinfo.read.Pinfo.RMn,exchangeDA.read.policyinfo.SSAn},即满足SSDcIFSD.(5)根据定理2(1)借助FDR2来验证以下执行不干扰关系:将上节得到的.CSP源文件输入FDR2中,根据定理2(1)可知要证明系统满足SSAIRMI;ClientIRMI;SSAIFSI;ClientIFSI;SSAISSDI;ClientISSDI;SSDcIRMI;SSDcIFSI图3不确定轨迹分析图2表明,表达式checkM不满足确定性,图3显示了错误的原因.图3的两幅截图显示了两条执行路径,第2幅中RM由于接收到pinfo传递来的参数值为Admin,则可以执行access.write.accFile.RMn,而第一幅图则由于接收的pinfo的参数值为SSDc写数据集合为{accessFS.write.accFile.SSDn,exchangeDA.write.policyinfo.SSDn,poli-cyFlash.write.policyInfo.SSDn};影响到的读数据集合为{accessFS.read.accFile.FSn,exchangeDA.read.policyinfo.SSAn}显然满足SSAIFSD;ClientIFSD;SSAISSDD;ClientISSDD,但是不满足SSDcIFSD,因为在SSDc的读数据集合中存在accessFS.read.accFile.FSn,即SSDc绕过RM直接将数据写到FS中.修改SSDc如下.即要判定以下表达式的确定性(βU在FDR2中写作bU):结果如图2所示.Client,不允许执行access.write.accFile.RMn,从而产生不确定.因此,产生不确定的原因是由于SSA,Clien,SSDc之一传递给RM的数据值pinfo可能干扰了RM的执行,即不满足SSAIRMI;ClientIRMI;SSDcIRMI之一.实际的意义是:Page12当SSA,Clien,SSDc之一被攻破而以管理员的角色访问RM时,RM不会对该进程的访问请求做实质性的检查,即不会将请求送到SSD中验证,因此,该进程可以绕过RM执行任意文件访问操作.图4修改后的执行结果显然,修改后的系统设计可证明解决了引用监视器RM被旁路的问题.5总结与展望本文提出的扩展不干扰模型ENISM可用于分析操作系统中可能存在的违背信息流策略的执行轨迹和数据流动,从而分析系统中的存储隐蔽通道,解决信道控制问题,验证信息流策略.该模型视操作系统的不同功能模块为执行域,强调将未来可能执行的行为序列集合与数据存储值集合一同作为分析执行域安全状态改变的依据.并通过分析单步动作的执行对系统执行和信息流动的影响总结出安全的状态转换条件.本文还基于通信顺序进程CSP给出了形式化的系统设计描述方法和ENISM策略表达及验证方法,并通过一个实例展示了ENISM及相应策略验证方法的正确性和有效性.虽然目前已存在多种形式化验证工具,但是对可验证的系统规模还存在一定的限制,而且系统描述也需要人工的参与.因此,在实际的策略验证过程中,如何对复杂的系统实现合理的分解,以提高验证的效率;如何改进ENISM模型,使验证条件更简单更便于验证,都是需进一步研究的重点.
