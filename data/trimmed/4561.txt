Page1基于动态切片和关联分析的错误定位方法1)(中国矿业大学计算机科学与技术学院江苏徐州221116)2)(河南工业大学信息科学与工程学院郑州450001)3)(南通大学计算机科学与技术学院江苏南通226019)摘要错误定位是软件调试中非常耗时费力的活动之一,自动错误定位技术可以提高调试效率,降低调试成本.该文提出一种把动态切片、关联分析及排序策略相结合的错误定位方法.首先,收集程序执行的动态切片及相应的执行结果构建混合谱矩阵;然后,基于混合谱矩阵进行关联分析,随后依据提出的排序策略对语句进行排序,得出较合理的语句优先级次序,从而进行错误定位.为验证该方法有效性,作者设计并实现了一个错误定位原型工具DSFL,针对一组Java基准程序开展错误定位实验,并与12种错误定位技术进行对比.实验结果表明该方法可以在一定程度上提高错误定位精度和效率.关键词动态切片;关联分析;错误定位;排序策略1引言现代技术的发展使得软件广泛应用于社会的各Page2试代价高、耗时长,占软件开发维护过程代价的50%~80%[1].错误定位,即在程序执行失败的情况下找出可能错误位置的过程[2],是软件调试中不可缺少的关键性工作之一.错误定位有利于软件错误的快速检测与修复,可以降低软件调试成本[2].因此,研究错误定位具有重要意义.软件错误定位方法主要通过缩小错误搜索范围来提高效率[3-5].早期程序员通过调试工具设置断点来缩小错误查找范围,但这种手工调试方式效率比较低.Delta调试技术[4]采用迭代运行程序的方式,不断交换失败与成功运行的内存状态,从而缩小错误定位范围,但迭代搜索代价较大.动态切片技术[5]则通过去除与程序错误不相关的语句来缩小错误搜索范围.然而,计算动态切片时,很少考虑变量定义时实际引用的变量,使得切片结果包含部分不相关变量的切片,结果冗余.为此,本文提出了一种改进的动态切片方法,该方法在计算动态切片时,找出当前变量在定义时的实际引用变量,排除未引用变量,使得动态切片结果更加精确.基于覆盖信息的错误定位以程序中语句或基本块为研究对象,统计不同执行轨迹的覆盖信息进行怀疑度计算.如Jones等人[6-7]提出了Tarantula方法;Abreu等人[8]使用分子生物学领域的相似系数提出了Ochiai方法;Naish等人[9]提出了Naish1、Naish2方法.这类方法通过计算语句怀疑度得出检查语句的先后次序以定位错误.然而,这类方法对执行轨迹进行了高度简化并忽略了程序内部固有的依赖关系,定位精度受限.通过分析程序执行过程,可以发现可疑代码与程序执行失败有着某种关联,找到这种关联能更有效地定位错误.关联分析技术能够从大量程序执行信息中获取语句错误的相关性信息,反映出执行轨迹中语句与执行结果的关系.为此,本文提出了一种关联分析与排序策略相结合确定语句检查优先级次序的方法.基于上述思路,本文提出了动态切片、关联分析及排序策略相结合的错误定位方法DS-FLAR(DynamicSlicing-FaultLocalizationbasedonAssocia-tionanalysisandRankstrategy).该方法有如下优点:(1)动态切片技术可以缩小错误定位范围,将可疑语句缩小为与失败输出变量相关的语句;(2)关联分析及排序策略相结合的方法(FLAR)可以提高错误定位的精度,即提高错误语句在Rank列表中的次序.本文主要贡献包括:(1)提出了一种排序策略,对关联分析后的语句进行排序,生成更加合理的语句检查序列.(2)提出了基于动态切片、关联分析及排序策略的错误定位方法,从而得到更加精确的错误定位结果.本文第2节介绍研究动机;第3节详细描述本文方法;第4节介绍实验结果及相关分析;第5节介绍相关工作;第6节总结全文,并明确今后进一步的研究工作.2研究动机软件错误定位存在搜索域过大与精度不高的问题.错误定位方法常使用动态切片技术缩小错误定位范围,而现有前向计算动态切片方法[10-11]计算语句定义变量的切片时,考虑语句中所有引用变量的切片,而不是变量定义时实际引用变量的切片,造成切片结果冗余.为此,本文对定义变量进行影响集分析,考虑变量定义时实际引用变量的切片结果,从而对原动态切片方法[11]进行改进.动态切片技术在一定程度上缩小了错误定位范围,但切片后的程序为语句集合,集合内元素无先后次序,测试人员需检查切片中所有语句以定位错误.关联分析技术能找到执行轨迹中语句与程序执行失败的关联,这种关联能有效地定位错误.为此,本文提出了关联分析及排序策略相结合的方法(FLAR)来确定语句检查优先级次序,用于提高定位错误精度.下面以图1所示程序(错误在s10)为例来说明本文的研究动机.s1sub(i,j,k){s2if(k>0)s3returni;elses4returnj;}s5main(){intx,y,z,r;s6x=read();s7y=read();s8z=read();Tarantula=passed(s)/totalpassed+failed(s)/totalfailed针对图1中示例程序,我们构造8个测试用例如下t1(5,2,5),t2(4,1,4),t3(-4,2,-2),t4(1,4,1),t5(1,0,-1),t6(-2,-4,1),t7(0,4,1)和t8(0,0,-1),并分别收集其执行的覆盖信息、(原/改进)动态切片Page3信息(〈I,s17,r〉为切片准则).比较Tarantula[6-7]和本文FLAR方法(详见3.3节)在覆盖信息、原动态切片[11]和改进动态切片上的错误定位效果,如表1所示(“●”表示语句被覆盖,“”表示语句未被覆盖).第1列为语句编号,第2列为覆盖信息及Tarantula(简写为Tar.)和FLAR在其上计算得到的语句排序结果.定位错误按序号从小到大检查语句.Tarantula式(1)中failed(s),passed(s)表示语句s被失败和成功执行轨迹覆盖的次数,totalfailed表1示例程序的覆盖信息、(原/改进)动态切片及排序结果(原)动态切片t1t2t3t4t5t6t7t8Tar.FLAR●●●11●●●●12●●●●12语句s1s2s3s4s6s7s8s9狊10(犳)●●●●●●●●s11s12s13s14s15s16s17T/FFFFTTTTTfaultR.由表1第2,3列可知,原有动态切片比覆盖信息规模小,例如t1执行时,动态切片去除了无关语句s11,s12,s17.Tarantula方法在原有动态切片和覆盖信息上定位到错误需要检查的语句数分别为“3-10”和“4-14”,可以看出动态切片提升了错误定位的精度.由第3,4列可知,改进的动态切片比原有动态切片规模小,例如t1执行时,改进的动态切片去除了无关语句s7,其原因是考虑了定义变量的实际引用变量,去除了无关变量y的切片从而缩小了切片规模.Tarantula方法在改进动态切片上定位到错误需要检查“3-9”语句,由此可见改进动态切片比原有动态切片进一步提高了错误定位精度.在覆盖信息上应用本文提出的FLAR方法需检查“2-12”语句定位错误,优于Tarantula方法;在原有动态切片上需检查“1-8”条语句,在改进动态切片上需检查“1-7”条语句定位错误,同样优于Tarantula方法.由此可见,使用关联分析及排序策略给出的语句检查次序更有效,并且能提高错误定位精度.和totalpassed分别表示失败和成功执行轨迹总数.第3列为原有动态切片及Tarantula和FLAR在其上计算得到的语句排序结果,第4列为改进的动态切片及Tarantula和FLAR在其上计算得到的语句排序结果.倒数第2行“T/F”表示程序执行结果成功(T)或失败(F).最后一行“faultR.”表示各方法定位到错误需检查的语句数,例如“4-14”表示定位到错误“最好”情况需检查4条语句,“最坏”情况需检查14条语句.3-101-83本文方法本文方法主要步骤如下:(1)计算程序执行的动态切片信息;(2)将每次测试用例执行的动态切片信息和相应的测试结果构造成混合谱矩阵;(3)在混合谱矩阵上进行关联分析,随后依据提出的排序策略对关联分析后的语句进行排序,生成错误定位报告.3.1动态切片动态切片技术是一种有效的程序调试技术,已广泛应用于软件调试中的错误定位研究.当程序执行产生错误输出或异常时,调试人员通常希望快速确定错误语句可能存在的范围,动态切片技术可以通过计算错误输出语句的后向动态切片以缩小错误定位范围.动态切片计算方法根据计算过程不同分为后向计算方法[12-13]和前向计算方法[10-11].后向计算方法采用回溯程序执行时产生的动态依赖关系的方式来寻找程序中兴趣点的依赖节点,从而获得兴Page4趣点的动态切片,该方法需遍历程序一次执行中的全部动态依赖关系[12-13].前向计算方法通过程序中兴趣点的直接动态依赖关系从而获得程序中兴趣点的动态切片,该方法需要维护程序中每个执行实例的切片结果[10-11].相比后向计算方法,前向计算方法在错误发生后可以根据错误输出语句的直接动态依赖关系生成该语句的动态切片,不需要后向遍历动态依赖关系,因而能在程序出错时更加快速的计算出动态切片结果.鉴于此,本文采用前向计算方法计算程序后向动态切片,并且对定义变量进行影响集分析以提高切片精度,将得到的动态切片结果用于错误定位.首先介绍相关定义.定义1.执行轨迹.测试用例t执行源代码的执行轨迹T是程序执行过程中跟踪到的所有语句的序列,记为T=〈s1,s2,…,sn〉.用时间戳stamp表示语句在执行轨迹T中执行的先后次序,标记为sstamp.按程序执行成功与否,将执行轨迹分为成功执行轨迹与失败执行轨迹两类,分别表示为Tp={Tp1,Tp2,…,Tpm}和Tf={Tf1,Tf2,…,Tfn}.定义2.动态切片.对于给定的切片准则C=〈I,s,V〉,其中I为程序的输入,s为程序中的兴趣点,V为变量集.基于切片准则C和输入I,动态切片是由程序P中的所有影响兴趣点s(一条语句或语句块)中变量集V的语句和谓语构成的集合[5].定义3.影响集Influence[v].对于给定语句s,变量v∈Def[s],影响集Influence[v]={v|v是v定义时实际引用的变量,v∈Use[s]}.其中,定义集Def[s]是语句s中被定义的变量集合,引用集Use[s]是语句s中引用的变量集合.本文对定义变量进行影响集分析,去除无关变量,以降低切片结果的冗余程度.定义4.混合谱矩阵(HybridSpectrumMatrix,HSM).对于由n条语句s组成的程序P和给定的m个测试用例,测试用例每次执行得到一个动态切片slice和相应执行结果.混合谱矩阵是由多个动态切片和执行结果构成的二维矩阵犎犛犕=[Mm×nNm×1],aij∈Mm×n,bij∈Nm×1,其中aij=bij=本文中混合谱矩阵采用语句的击谱[3]形式,若某条语句被覆盖到为1,否则为0.文中提到的某条语句被程序执行轨迹覆盖多次是指由不同的程序执行轨迹多次覆盖,而不是被一条程序执行轨迹多次覆盖.算法1描述了改进的前向计算动态切片算法.第1~3行计算语句s的引用集Use[s]中变量use的动态切片slice[use].根据当前执行实例si的动态数据依赖dynDD[si]获得引用变量的动态切片slice[use].第4~10行根据定义3计算定义变量def的影响集Influence[def].第11~18行为计算定义集Def[s]中变量def的动态切片slice[def].第11行由dynCD[si]得到控制依赖谓词pred的切片slicePred.第12~18行计算定义变量的动态切片slice[def],其切片由当前执行语句s、调用语句call、控制依赖谓词切片slicePred以及定义变量影响集Influence[def]中变量influence的切片slice[influence]共4部分组成.算法1.改进的前向计算动态切片算法.输入:si//当前执行实例输出:slice[use]//语句s引用变量use的动态切片begin1.foreachuse∈Use[s]do2.findslice[use]bydynDD[si];3.endfor4.foreachdef∈Def[s]do5.Influence[def]={};6.foreachuse∈Use[s]do7.ifuseaffectthevalueofdefthen8.addusetoInfluence[def];9.endfor10.endfor11.findslicePredbydynCD[si];12.foreachdef∈Def[s]do13.slice_T={s,call}∪slicePred;14.foreachinfluence∈Influence[def]do15.slice_T=slice_T∪slice[influence];16.endfor17.slice[def]=slice_T;18.endforend以图1程序为例,改进的前向计算动态切片算法计算过程如表2所示.对于给定输入I为t1(5,2,5)和切片准则〈I,s17,r〉,则程序执行轨迹Tf={s17,s4s3read()和sub()的返回值抽象为变量ret_read和8,s5Page5ret_sub,pred_2表示语句s2是谓词.以表2第9行为例说明动态切片的计算过程,语句s9引用集Use[s]中变量x,y,z和ret_sub的切片结果通过动态数据依赖即可获得;定义集Def[s]变量m受函数sub()返回值变量ret_sub和变量z的影响,与变量x,y无直接依赖关系,而在此次执行中ret_sub实际引用变sstampDef[s]Use[s]slice[use]dynCD[si]callpreddefInfluence[def]influencedynDD[influence]slice[def]表2改进的前向计算动态切片计算过程s15s26s37s48s51{i,j,k}s62{pred_2}{k}s73{ret_sub}s89s910s1011s1112{pred_12}{x}s1214{pred_14}{m}s1315s1417pred_2pred_12pred_143.2关联分析和排序策略动态切片技术能在一定程度上缩小错误定位的范围.为了得到更加精确的错误定位结果,本文在动态切片信息及相应的执行结果上构建混合谱矩阵犎犛犕,然后采用关联分析及排序策略生成语句检查的优先级次序,从而定位错误.3.2.1关联分析定义5.布尔判别函数B(s).若某条语句s只出现在失败执行轨迹中,则B(s)值为1;若某条语句s既出现在失败执行轨迹中又出现在成功执行轨迹中,或者语句s只出现在成功执行轨迹中,则B(s)值为0,定义如下:定义6.关联规则(associationrules).为AB形式的逻辑蕴涵式,其中AD,BD且A∩B=,量x,与变量y无关,其动态切片slice[m]={s9}∪slice[z]∪slice[ret_sub],不包含变量y的切片.现有前向计算动态切片方法[10,11]计算语句s9中定义变量m的动态切片时,包含引用变量y的动态切片,结果存在冗余.而本文方法得到的动态切片更加精确,从而使错误定位更加准确.{ret_read}ret_read{ret_read}ret_read{ret_read}ret_read{ret_sub,pred_14}xyzijkmxy则A,B分别称为关联规则AB的前件和后件[14].在错误定位中,程序的一条执行轨迹及相应执行结果作为一个事务,所有执行轨迹及相应执行结果为事务集D;A表示执行轨迹中语句,B表示程序执行结果(成功T或失败F).A表示关联规则的前件,B表示关联规则的后件[14].本文中的混合谱矩阵存储了软件错误定位中的所有事务.定义7.支持度(support).规则AB的支持度是指A和B两者在事务集D中同时出现的概率,记为support(AB),它是概率P(A∪B)[14],即support(AB)=support(A∪B)=P(A∪B)(5)在错误定位的上下文环境中,support(AB)表示某条语句A出现在事务集D中且同时程序执行结果为B的概率.最小支持度阈值min_support=其中N=|Tp|+|Tf|,因定位到错误至少需要一个Page6失败执行轨迹,所以最小支持度阈值为1定义8.置信度(confidence).规则AB的置信度表示在出现A的事务集D中B也同时出现的条件概率[14],即包含A和B的事务数与包含A的事务数的比值,记为confidence(AB)=P(B|A)=在错误定位的上下文环境中,confidence(AB)表示语句A出现的事务集D中执行结果B也同时出现的条件概率,support(A)表示包含语句A的事务数与所有事务数的比率.最小置信度阈值min_confidence=失败执行轨迹,且最极端情况下错误语句又出现在所有执行轨迹中,所以最小置信度阈值为1定义9.语句错误相关性.对于执行轨迹中的每条语句A和程序执行结果B(成功T或失败F),AB有3种规则:AF(A∈Tf∧ATp),AT(A∈Tp∧ATf),AF或T(A∈Tp∧A∈Tf).3.2.2排序策略在软件错误定位中,已有研究表明语句的怀疑度与它被失败执行轨迹覆盖的次数正相关,与它被失败执行轨迹没有覆盖的次数负相关,与它被成功执行轨迹覆盖次数负相关;并且一个程序至少被一个失败测试执行,且所有失败测试的贡献率大于所有成功测试的贡献率[6-7,15-16].根据以上分析,本文设计如下3层排序策略:(1)B(s)值为1的语句优先被检查.程序执行失败必定触发了错误语句,只出现在失败执行轨迹中的语句出错概率更高,应该优先被检查;(2)support值越大的语句越优先被检查.support值越大表明语句被失败执行轨迹覆盖的次数越多,则此语句应该优先被检查;(3)confidence值越大的语句越优先被检查.在语句出现在失败执行轨迹中次数相同情况下(即support值相同),出现在成功执行轨迹中次数越少,则confidence值越大,越优先被检查.3.2.3关联分析及排序策略算法算法2描述关联分析及排序策略算法.该算法将混合谱矩阵犎犛犕作为输入,其中犎犛犕存储语句击谱信息,即1表示语句被执行轨迹覆盖,0表示语句未被执行轨迹覆盖;将排序后语句序列sList作为输出.第1行初始化链表S,用于存储语句si及B(si),support(siF),confidence(siF)值,i=1,2,…,n.第2~6行在混合谱矩阵上计算语句s的B(s),support(sF)和confidence(sF)值,其中B(s)值按定义5计算,support(sF)按定义7计算,即语句s被失败执行轨迹覆盖次数与所有执行轨迹数量的比值,confidence(sF)按定义8计算,即语句s的support(sF)与support(s)的比值.第7~23行进行关联分析与排序,选取support(siF)min_supportconfidence{s1,s2,…,sn},B=F(程序执行失败),其中,第7行中S.size为链表中元素个数;第9、10行为取出S[j],S[j+1]中存储的语句sj,sj+1;第13、16和19行swap()函数为两条语句的交换函数;然后按照本文设计的排序策略进行排序.第24~27行取出排序后语句序列sList中的语句;第28行返回语句序列sList.算法2.关联分析及排序策略算法.输入:犎犛犕//混合谱矩阵输出:sListbegin1.listS=InitInput();2.foreachs∈犎犛犕do3.computeB(s);4.support(sF)=P(s∪F);5.confidence(sF)=P(s∪F)/P(s);6.endfor7.fori=0:S.sizedo8.forj=0:(S.size-i-1)do9.sj=S[j].getStatement();10.sj+1=S[j+1].getStatement();11.if(support(sjF)min_support&&12.13.14.15.16.17.18.19.20.else21.deletesi;22.endforPage723.endfor24.foreachs∈Sdo25.ifs.getStatement()!=nullthen26.sList.add(s.getStatement());27.endfor28.returnsList;end3.3错误定位实现本文方法实现过程:首先,基于改进的动态切片算法,计算得到一个更加精确的动态切片;其次,将动态切片及相应执行结果构建混合谱矩阵;最后,进行关联分析,并根据排序策略给出语句检查优先级次序,生成错误定位报告.下面以图1程序为例来分析如何定位错误.我们以〈I,s17,r〉为切片准则,以8个测试用例为输入运行程序,根据算法1计算动态切片如表1第4列所示.将动态切片和相应执行结果构建混合谱矩阵犎犛犕如图2所示.根据算法2对混合谱矩阵中数据进行关联分析及排序(FLAR),其中按本文设计排序策略对语句排序如表3所示.以语句s1为例说明算法2计算过程.首先,计算语句s1的布尔判别函数B(s1)、支持度support(s1F)和置信度confidence(s1F)值:对于B(s1)值,因语句s1既出现在失败执行轨迹也出现在成功执行轨迹中,根据定义5,B(s1)=0;对于support(s1F),因语句s1出现在失败轨迹中3次,出现在成功轨迹中5次,根据定义7,support(s1F)=3/(3+5)=3/8;对于confidence(s1F)值,因语句s1出现在失败执行轨迹中概率为3/8,support(s1)=1,根据定义8,confidence(s1F)=(3/8)/1=3/8.其他语句指标计算同s1.其次,选取support(siF)1/8和confidence(siF)1/8进行关联分析,并对关联分析后的语句进行排序.表3展示了本文设计的3层排序策略排序过程:(1)因为没有只出现在失败执行轨迹中的语句,所以B(s)值都为0,见第2行;(2)在语句B(s)值相同的情况下,support值越大的语句越优先被检查,因此语句s1比语句s3优先被检查,见第3行;(3)在语句support值相同情况下,confidence值越大的语句越优先被检查.对于有相同support值的语句s3和s15,根据confidence值大小则先检查s15再检查s3,见第4行.对于有相同support、confidence值的语句s4和s7,则具有相同检查等级;最后生成语句Rank如表3最后一行所示.按此序列定位错误,“最好”情况需要检查1条语句,“最坏”情况需要检查7条语句即可定位到错误.在覆盖信息和原有动态切片上进行关联分析和排序(FLAR)过程同上.指标B(si)support(siF)3/83/82/81/83/81/83/83/83/81/83/82/81/8confidence(siF)3/83/82/51/33/81/33/83/83/81/43/81/21/4Rank4实验结果及分析为了评估本文方法的有效性,我们进行了对比实验.实验运行环境为Intel(R)core(TM)3.10GHz处理器和4GB内存的计算机,Eclipse开发平台.4.1实验对象本文选取13个Java程序作为测试基准程序,如表4所示,其中第1~3列为程序名称、描述及代码行数(不含空白行和注释行),第4,5列为实验使用的错误版本数和测试用例数.每个程序累积代码行数为所有错误版本代码行数的累加.其中SiemensSuite中后5个程序是由Santelices等人[17]把C版本程序转换为Java版本程序①,jtcas,Nanoxml和XML-security来源于SIR(SubjectInfrastructureRepository)②.本文方法适用于单错误版本程序的错误定位.我们从jtcas的41个错误版本中去除无测试用例执行失败的2个版本和多错误的8个版本,选取其余31个版本进行测试;随机选取tot_info程序23个错误版本中的10个版本进行测试;选取schedule的9个错误版本;选取schedule2的10个错误版本中8个版本进行测试,去除了v4版本(错误为去除350行处注释语句)和多错误的v6版本;选取print_tokens的7个错误版本和print_tokens2的5个错误版本进行测试;另外选取NanoXML共28个错误版本和XML-security共18个错误版本进行测试.因此,我们共测试116个单错误版本程序.①②Page8SiemensSuiteNanoXMLv1NanoXMLv2NanoXMLv3NanoXMLv5XML-securityv1XML-securityv2XML-securityv34.2实验工具本文在Eclipse实验平台上使用Java语言开发了基于动态切片、关联分析及排序策略的错误定位原型工具DSFL(DynamicSlicingFaultLocator).DSFL使用Java优化框架Soot分析计算目标程序的数据流和控制流信息,使用Java调试接口(JavaDebuggerInterface,JDI)获取目标程序执行时的轨迹信息和覆盖信息,结合上述信息利用本文提出的切片算法进行动态程序切片计算,并进行错误定位.4.3实验设计本文方法主要从动态切片缩小错误定位范围和关联分析及排序策略相结合提高错误定位精度两个方面来提高错误定位效率.本文设计了3个层次对比实验:(1)验证关联分析及排序策略相结合FLAR方法(假设不使用动态切片技术)的有效性,见4.4.1节;(2)验证提出的动态切片技术提升错误定位精度的程度,见4.4.2节;(3)验证本文DS-FLAR方法有效性,见4.4.3节.并选取4组方法进行错误定位对比实验.第1组为基于覆盖信息的经典错误定位方法Tarantula[6-7]和Ochiai[8];第2组为Xie等人[18]表5FLAR与基于覆盖信息的各种方法累积检查语句数对比FLARTarantulaOchiaiNaish1Naish2Wong1Russel&RaoBinaryGP02jtcastot_infoscheduleschedule2print_tokensprint_tokens2NanoXMLv1NanoXMLv2NanoXMLv3NanoXMLv593367425293850151619501120161525843498XML-securityv12500XML-securityv2XML-securityv34833累积检查总语句数154752229420936191122195421914注:数字表示定位到错误的累积检查语句数,越小越好.1248701160802475930175095018702619321326864550理论证明的两组最优怀疑度计算公式:其一为Naish1[9]和Naish2[9],其二为Wong1[19]、Russel&Rao[9]和Binary一组更优;第3组为Xie等人[20]理论证明的基于遗传算法机器推导的3个最优怀疑度计算公式GP02、GP03和GP19;第4组为基于动态切片的错误定位方法FS[21]和PSS-SFL[22].4.4实验结果分析本文从累积检查语句数[15]、错误定位代价[23]和EXAM指标[15,32]3个指标对错误定位效率进行评估.检查结果中可能有多条语句检查等级相同,“最好”情况是检查第1条语句就定位到错误,“最坏”情况为直到检查到最后1条语句才定位到错误,本文选取“最好”和“最坏”情况平均值进行评估.4.4.1基于覆盖信息对比实验为验证提出的关联分析及排序策略相结合的FLAR方法有效性,在覆盖信息上进行对比实验.对每个基准程序统计累积检查语句数———定位出多个错误版本中所有错误需检查的总语句数[15].实验结果可能受不同程序结构影响,因此,我们测试了不同程序,其结果如表5所示,第1列为基准程序,其余各列为不同方法定位错误需检查总语句数.对于每个程序,FLAR检查语句数少于对比方法(Ochiai除外);FLAR检查语句数在tot_info程序上与Ochiai相当,在print_tokens程序上定位效果稍差于Ochiai.对于所有程序(由表5最后一行可知),FLAR累积检查语句数是Tarantula、Ochiai、Naish1、Naish2、Wong1、Russel&Rao、Binary、GP02、GP03和GP19累积检查语句数的69.41%,73.92%,80.97%,70.49%,70.62%,70.49%,70.45%,71.27%,67.59%和67.16%.由此可知,FLAR方法累积检查语句数少于对比方法.Page9同时,使用定位错误代价从相对指标的角度对所有方法进行评估.错误定位代价是找到一个程序所有测试版本中错误的累积检查语句数与所有版本可执行代码总行数的比值[23].某方法的错误定位代价越小,则该方法定位效果越好.由表6最后一行可知,FLAR比Tarantula、Ochiai、Naish1、Naish2、Wong1、Russel&Rao、Binary、GP02、GP03和GP19表6FLAR与基于覆盖信息的各种方法错误定位代价对比程序jtcastot_infoscheduleschedule2print_tokensprint_tokens2NanoXMLv1NanoXMLv2NanoXMLv3NanoXMLv5XML-securityv11.52XML-securityv21.48XML-securityv32.76平均定位代价注:数字表示错误定位代价,越小定位效果越好.为更直观比较不同方法优劣,本文还使用EXAM指标进行评估.EXAM指标为错误检出率与代码检查率的比值[15,32].实验结果如图3所示,横坐标为代码检查率,纵坐标为相应的错误检出率.在相同代图3FLAR与基于覆盖信息的各种方法效率对比错误定位代价分别降低了3.58%,2.50%,2.33%,5.49%,4.21%,4.08%,4.17%,4.38%,4.82%和5.40%.由此可知,FLAR的错误定位平均代价较小.FLAR定位效果优于对比方法是因为本文方法考虑了程序执行轨迹中语句与执行结果的关联关系,并结合排序策略,使得生成的语句检查序列更有效.9.667.974.664.387.722.312.244.05码检查率情况下,某方法的错误检出率越高,则该方法越有效[32].从图3(a)、(b)和(d)可知,FLAR定位效果明显优于Tarantula、Ochiai、Naish1、Naish2、GP02、GP03和GP19.由图3(c)可知,在代码检查率Page10小于5%时,Wong1、Russel&Rao和Binary定位效果优于FLAR,这是因为这3种方法检查出多条有相同最大怀疑度值的语句(错误语句包含其中),若能接近最好情况定位到错误,则使得在较低代码检查率时就能定位到错误.但在代码检查率大于5%时,FLAR定位效果优于对比方法;由表5和表6可知,总体上FLAR定位效果优于Wong1、Russel&Rao和Binary.4.4.2基于动态切片信息的对比实验为了评估本文提出的动态切片技术相对于覆盖信息提升错误定位精度程度进行了如下实验:基于覆盖信息应用FLAR、Tarantula、Naish1和Wong1生成语句检查序列,同样在动态切片信息上应用上述方法,并分别命名为DS-FLAR、DS-Tarantula、DS-Naish1和DS-GP02,比较在这两种情况下的错误定位精度差异.通过比较表5和表7可知,累积检查总语句数DS-FLAR比FLAR减少了34.71%,DS-Tarantula比Tarantula减少了34.32%,DS-Naish1比Naish1减少了27.72%,DS-GP02比GP02减少了35.51%.由此可见,动态切片技术的应用使得错误定位方法的累积检查总语句数有所减少.比较表6和表8最后一行数据计算可知,动态切片技术在一定程度上可以减少错误定位代价,例图4动态切片相对覆盖信息提升错误定位精度对比如,FLAR定位错误总体平均代价降低了4.09%(从8.27%下降为4.18%),Tarantula降低了6.28%(从11.85%下降为5.57%),Naish1降低了5.33%(从10.60%下降为5.27%),GP02降低了7.30%(从12.65%下降为5.35%).动态切片技术对不同方法定位代价影响不同,如在jtcas程序上,FLAR定位错误代价降低了7.12%,Tarantula降低了9.09%,Naish1降低了10.77%,GP02降低了9.70%,这是受方法不同程序的影响.图4虚线表示基于覆盖信息上述4种方法的错误检出率随代码检查率的变化趋势,实线表示动表7动态切片使用后各方法的累积检查语句数对比程序jtcastot_infoscheduleschedule2print_tokensprint_tokens2NanoXMLv1NanoXMLv2NanoXMLv3NanoXMLv5XML-securityv11603XML-securityv21240XML-securityv32309累积检查总语句数10104注:数字表示定位到错误的累积检查语句数,越小越好.Page11表8动态切片使用后各方法的错误定位代价对比程序jtcastot_infoscheduleschedule2print_tokensprint_tokens2NanoXMLv1NanoXMLv2NanoXMLv3NanoXMLv5XML-securityv11.06XML-securityv21.11XML-securityv31.93平均定位代价注:数字表示错误定位代价,越小定位效果越好.态切片技术使用后上述4种方法的错误检出率随代码检查率的变化趋势.由图4可知,DS-FLAR、DS-Tarantula、DS-Naish1和DS-GP02在定位效果上优于原始方法.文献[24,25]认为在较低代码检查率(如10%[25]或20%[24])时定位出的错误数越多,则该方法越有效.本文比较不同方法在20%代码检查率时定位出的错误数百分比.DS-FLAR定位出总错误数的92.08%,而FLAR定位出69.61%;DS-Tarantula定位出85.26%,而Tarantula为60.99%;DS-Naish1定位出89.24%,而Naish1为64.71%;DS-GP02定位出87.10%,而GP02为49.12%.这种错误定位准确度提高主要是由于动态切片技术的使用缩小了错误定位范围.从总体上可以看出,本文提出的动态切片技术从不同程度上提升了错误定位精度.4.4.3本文DS-FLAR方法与各种方法对比为了评估本文提出的DS-FLAR方法的错误定位效果,将其与基于动态切片错误定位方法FS[21]和PSS-SFL[22]对比,并与基于覆盖信息的10种怀疑度计算错误定位方法对比.首先,评估本文改进动态切片对整体定位精度改善的贡献大小.在原动态切片上应用FLAR(记为D-FLAR)与DS-FLAR相比较,两者差异即为改进动态切片对整体错误定位精度的贡献.由表9第2,3列比较可知,对于每个程序,改进动态切片减少了检查语句数,如对jtcas程序定位错误检查语句数减少了78,对tot_info程序减少了92,总体上累积检查语句数减少了1732.由表10第2,3列比较可知,对于每个程序,改进动态切片比原动态切片减少了平均定位代价,如对jtcas程序减少1.53%,对tot_info程序减少3.25%,总体上平均定位代价减少1.01%.由此可见,改进动态切片对整体定位精度有一定程度的提升.其次,DS-FLAR与FS和PSS-SFL进行对比分析.由表9可知,对于每个程序,DS-FLAR检查语句数比FS少,也比PSS-SFL少(NanoXMLv2,XML-securityv2除外).对于所有程序(由表9最后一行可知),定位到错误DS-FLAR累积检查语句数比FS、PSS-SFL少,且是FS、PSS-SFL累积检查语句数的54.41%(10104/18570)和77.01%(10104/13120).由表10最后一行可知,DS-FLAR平均定位代价比FS、PSS-SFL分别降低了4.79%、2.48%.直观上,由图5(d)可知,DS-FLAR定位效果优于FS、PSS-SFL.总体上,DS-FLAR定位效果优于基于动态切片的错误定位方法FS和PSS-SFL.这是因为本文动态切片对定义变量进行影响集分析提高了切片的精度,并且关联分析及排序策略生成的语句检查序列更有效.表9基于动态切片的各种方法累积检查语句数对比程序jtcastot_infoscheduleschedule2print_tokensprint_tokens2NanoXMLv1NanoXMLv2NanoXMLv3NanoXMLv5XML-securityv1XML-securityv2XML-securityv3累积检查总语句数10104注:数字表示定位到错误的累积检查语句数,越小越好.表10基于动态切片的各种方法错误定位代价对比程序jtcastot_infoscheduleschedule2print_tokensprint_tokens2NanoXMLv1NanoXMLv2NanoXMLv3NanoXMLv5XML-securityv1XML-securityv2XML-securityv3平均定位代价注:数字表示错误定位代价,越小定位效果越好.最后,DS-FLAR与基于覆盖信息的错误定位方法进行对比分析.由表5和表9可知,对于每个程序,DS-FLAR检查语句数均少于相比较的基于覆盖Page12图5DS-FLAR与各种方法效率对比信息的10种错误定位方法.对于所有程序(由表5和表9最后一行可知),DS-FLAR能够减少错误定位时需要检查的总语句数,且DS-FLAR累积检查总语句数是Tarantula、Ochiai、Naish1、Naish2、Wong1、Russel&Rao、Binary、GP02、GP03和GP19累积检查总语句数的45.32%,48.26%,52.87%,46.02%,46.11%,46.02%,46.00%,46.53%,44.13%和43.85%.由此可知,本文方法错误定位准确度有一定程度的提升.由表6、表10可知,DS-FLAR相比Tarantula、Ochiai、Naish1、Naish2、Wong1、Russel&Rao、Binary、GP02、GP03和GP19平均错误定位代价分别降低了7.67%,6.59%,6.42%,9.58%,8.30%,8.17%,8.26%,8.47%,8.91%和9.49%.由图5(a)、图5(c)可知,DS-FLAR错误定位效果明显优于Tarantula、Ochiai、GP02、GP03和GP19.由图5(b)可知,DS-FLAR定位效果明显优于Naish1和Naish2;当代码检查代码率小于5%时,DS-FLAR与Wong1、Russel&Rao、Binary错误定位效果相当,当代码检查代码率大于5%时,DS-FLAR定位效果明显优于Wong1、Russel&Rao和Binary.由表6、表10可知,总体上DS-FLAR定位效果优于Wong1、Russel&Rao和Binary.通过前面3个层次的对比实验,可得出以下结论:(1)本文提出的关联分析及排序策略相结合的FLAR方法(假设不使用动态切片技术),定位精度高于Tarantula、Ochiai、Naish1、Naish2、Wong1、Russel&Rao、Binary、GP02、GP03和GP19.(2)本文提出的改进动态切片应用于FLAR、Tarantula、Naish1和GP02,其错误定位精度都有明显提升,说明本文提出的动态切片技术缩小错误定位范围效果较好.(3)DS-FLAR定位效果优于相比较的基于动态切片的错误定位方法和基于覆盖信息的10种怀疑度计算错误定位方法.5相关工作目前,主要有以下两类基于动态测试的错误定位方法:(1)基于程序切片的错误定位方法;(2)基于覆盖信息的错误定位方法.研究人员提出了多种基于程序切片的错误定位方法.第1类方法是程序切片结果直接用于错误定位.如Zhang等人[21]提出了一种基于动态切片的错误定位方法,该方法采用前向计算方法分别计算和比较了数据切片、全切片和相关切片的错误定位效果,并实验证明了全切片和相关切片错误定位效果较好.我们之前的研究[26]是针对空指针异常问题,Page13应用程序切片技术,结合实时堆栈信息,在切片后程序上进行空指针与别名分析,从而定位空指针异常.第2类方法是程序切片和程序谱方法相结合的错误定位.例如,Wen等人[22]使用动态切片提取程序元素间依赖关系,缩减程序执行轨迹,然后在语句频谱信息上构造了类似于Tarantula的公式统计语句怀疑度.Alves等人[27]通过动态切片和修改影响分析来提高Tarantula的错误定位效率.与文献[22,27]不同,本文采用改进的动态切片技术来提高动态切片精度;然后采用关联分析及排序策略生成可疑语句的优先级次序,而他们采用Tarantula公式生成可疑语句检查次序.Yu等人[28]基于覆盖信息和静态控制流图构建执行流图,从而得到半动态切片(semi-dynamicslicing),然后使用Tarantula公式计算怀疑度.Lei等人[29]使用静态后向切片和执行切片的交集构成近似动态切片(approximatedynamicslice),然后统计语句的怀疑度.与文献[28-29]构造半动态切片和近似动态切片的方法不同,本文方法得到的是动态切片,切片结果更加准确,且在动态切片信息上进行关联分析及排序生成语句检查序列.基于覆盖信息的错误定位方法可分为两类.第1类是比较覆盖信息的差异.如Renieris等人[30]提出了最近邻查询错误定位方法(NearestNeighborQueries,NNQ).该方法假定存在一个失败运行与多个成功运行,使用距离度量方法从成功运行中统计出与失败运行最相似的程序谱,比较其差异,去除被失败和成功运行都执行的语句,生成错误定位报告.第2类是统计覆盖信息的特征.如Jones等人[6-7]提出了Tarantula怀疑度计算错误定位方法,计算出每条语句怀疑度,然后按照怀疑度大小检查可疑语句.Abreu等人[8]提出了Ochiai错误定位方法,引入分子生物学领域相似系数Ochiai来计算语句怀疑度,实验表明Ochiai定位效果优于Tarantula.Xie等人[18]理论证明了Naish1和Naish2,Wong1、Russel&Rao和Binary为两组最优的怀疑度计算方法,Xie等人[20]还理论证明了基于遗传算法通过机器推导出来的3个最优公式GP02,GP03和GP19.上述方法实质上是按照语句怀疑度大小检查可疑语句,从而定位错误.Nessa等人[31]通过构造N长度的执行序列,利用统计信息关联挖掘N长度执行子序列与执行结果的关联,进而提出了N长度序列和关联规则相结合的错误定位方法.赵磊等人[32]提出了在覆盖向量(每次执行的代码基本块覆盖信息)中,求解与某个基本块b0一致的分量所对应的基本块,这些分量即为基本块b0的频繁集;求出频繁集后,语句的怀疑度按Tarantula,Ochiai等公式进行计算.与文献[31]相比,本文方法不但使用支持度和置信度指标进行关联分析,而且使用布尔判别函数和排序策略加以筛选排序.与文献[32]相比,本文采用关联分析与排序策略直接筛选排序可疑语句,从而定位错误,无需进一步计算语句怀疑度,从而减少时间代价.实验结果表明,本文方法定位错误的准确度更高.6结束语本文提出了一种基于动态切片、关联分析及排序策略相结合的错误定位方法.该方法首先采集程序的动态切片信息和相应执行结果,构建混合谱矩阵;然后在此基础上进行关联分析,随后依据本文设计的排序策略对语句进行排序,进而生成语句检查的优先级次序,开发人员利用此序列定位错误.本文从3个层次在13个Java基准程序上进行了对比实验,与基于动态切片的FS、PSS-SFL以及基于覆盖信息的10种怀疑度计算错误定位方法进行对比.实验结果表明,本文提出的改进动态切片方法能有效的缩小错误定位范围,提出的关联分析与排序策略相结合生成的语句优先级次序定位错误效果很好.因此,本文方法定位错误的效率较高.虽然我们在不同规模基准程序上验证了本文方法的有效性,但本文方法同其他错误定位方法一样,处理多错误的故障定位时,效率会有所降低.下一步的工作中,我们将重点研究本文方法如何提高多错误程序中定位的效率.致谢在此,我们对审稿人和编辑表示感谢,对本文提出建议的同行表示感谢!
