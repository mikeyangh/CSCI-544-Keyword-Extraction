Page1基于流映射的负载均衡调度算法研究戴艺苏金树孙志刚(国防科学技术大学计算机学院长沙410073)摘要网络管理者需要能够提供可扩展性、吞吐率保证及报文顺序的高性能路由器体系结构.目前基于Crossbar的集中式路由器体系结构难以实现性能和规模的可扩展,基于两级Mesh网络的负载均衡交换结构成为扩展Internet路由器容量的有效的途径.负载均衡路由器存在严重的报文乱序现象,输出端报文重定序复杂度为O(N2).文中提出一种区域均等的负载均衡交换结构,每k个连续的中间级输入端口划分为一个区域,输入端采用基于流映射的负载分配算法UFFS-k(UniformFine-grainFrameSpreading,k为聚合粒度,简称UFFS-k),在k个连续的外部时间槽,以细粒度的方式将同一条流的k个信元分派到固定的映射区域,通过理论证明,该调度策略可获得100%吞吐率并能够保证报文的顺序.为避免流量区域集中现象,采用双循环(dual-rotation)方式构建不同输入端口的流到区域的映射关系;为实现负载在中间级输入端口的均衡分布,每个输入端口维护全局统一视图的流量分布矩阵,UFFS-k调度算法根据流量分布矩阵调度单位帧,可以证明,对任意输出端口j,同一区域OQj队列长度相同且不同区域OQj队列长度至多差1,从而实现了100%负载均衡度.UFFS-k调度算法分布于每个输入端口独立执行,根据流到区域的映射关系及负载分布状态分派信元,模拟结果显示,当聚合粒度k=2时,UFFS-k算法在同类维序算法中表现出最优延迟性能.关键词路由器体系结构;负载均衡路由器;报文乱序;双循环映射;可扩展1引言新一代互联网在规模、功能、性能和服务等多个维度上的可扩展特性需要核心路由器实现交换容量和端口密度的可扩展、提供延迟和吞吐率保证并维持报文的顺序.针对基于Crossbar的路由器体系结构受限于LVDS传输及封装技术,难以支持高速链路及高密度端口的问题[1],近年来,基于两级Mesh网络的负载均衡交换结构成为扩展路由器容量与规模的有效途径.负载均衡交换结构(load-balancedswitch)最初由Chang等人[2]在他们设计的Birk-hoff-vonNeuman输入排队交换机中提出,它由第一级不带任何输入/输出缓冲区的Crossbar和第二级输入端带有VOQ队列的Crossbar构成.每一级Crossbar按照单循环置换矩阵周期性地建立连接模式,第二级Crossbar也就是Birkhoff-vonNeu-man输入排队交换机能够获得100%的吞吐率(对于这一结论,Chang等人[2]进行了严格的证明);模拟结果显示,在重负载的情况下,信元平均延迟接近OQ交换结构[2].针对Crossbar结构需要动态变化连接关系,难以扩展到更高速度的问题,近几年提出了一种采用两级全相连Mesh网络替代两级Cross-bar的负载均衡交换结构[3-5].这种采用固定连接方式的负载均衡交换结构被认为是一种能够将路由器扩展到高容量和高速度的切实可行的方法.该交换结构的可扩展性得益于以下两个关键特性:(1)不需要集中式的调度器,在O(1)时间内,所有的缓冲和转发操作在每个线卡本地完成.(2)采用两级固定配置的Mesh网络,其确定的连接模式独立于报文到达过程.因此不需要为每个报文动态配置交换网络,这种固定的连接方式也易于用光互连技术实现.斯坦福大学基于负载均衡交换结构,实现了一个100Tb/s的光路由器[4],包含640个线卡,每个运行在160Gb/s的速率.采用了一种层次化的Mesh体系结构,640个线卡被组织成40个机柜,每个机柜包含16个线卡.机柜间通过静态配置的40×40光交换器件MEMS(等同于光Crossbar)进行互连.MEMS交换速率可配置,当加入或移除线卡时,需要调节MEMS速率以保证流量畅通[4].2相关研究网络流量特性决定路由器处理的数据模型.对于并行路由器而言,最重要的是报文乱序属性,研究者采用主动测量和被动测量方式对报文乱序行为做了大量研究.Bennett在MAE-EastISP的交换中心测量了报文乱序情况,发现在重负载、网络设备并行度高的测量环境下,报文乱序情况非常严重,90%以上的连接发生乱序[6].Bennett分析这种高乱序率主要来自网络内部的局部并行处理机制,包括并行交换设备和并行传输链路,并指出报文乱序不是网络的病态行为.负载均衡交换结构存在报文乱序现象,从最初基于两级Crossbar的负载均衡交换结构[2]到目前广泛研究的基于两级Mesh网络的负载均衡交换结构[3-4,7-8]均受到报文乱序问题的困扰.乱序报文会损害Internet网况,因为Internet广泛使用的TCP传输协议会错误地将乱序报文看作是报文丢失拥塞发生的标志,从而引发不必要的重传及TCP超时.这些重传和超时将降低TCP吞吐率,提高报文延迟,因此在路由器中保证报文的顺序是极其必要的.防止报文乱序的方法可以分为两类:(1)限定乱序报文的数量,在输出端设置容量有限的重定序缓冲区,用于重定序乱序报文;(2)保证报文按照到Page3达顺序离开输出端口,从而避免了报文乱序.在负载均衡交换结构中,文献[4,7]采用的是基于限定报文重定序数量的第1种方法.由于缓冲区的容量有限,这些方法只能处理一定范围内的乱序报文,如果将重定序缓冲区尺寸增加至O(N2),虽然能够完全解决报文乱序的问题但会相应地以二次方的时间尺度增加报文延迟,其中N为端口数目.因此,这些方法并不能有效解决报文乱序问题,并且难以适应路由器高端口密度的需求.文献[3]所提出的满帧优先(FullOrderedFrameFirst,FOFF)算法是第1种方法的代表算法,它允许路由器中存在一定数量的乱序报文,在输出端设置了容量为N2个信元的N个的缓冲队列用于重定序乱序报文.文献[3]证明了,为了保证信元按序离开,重定序缓冲区容量至多为N2个信元.为了限定乱序信元的数量,FOFF算法每N个外部时间槽只能服务一个队列,当被服务队列的信元不能占用全部的内部链路时(所含信元小于N的情况),由于其它队列不能使用剩余的空闲链路,将造成Mesh网络带宽浪费,增加信元平均延迟.近年来,更多的研究者趋向于采用第2种方法来保证报文的顺序,消除了输出端的重定序操作及缓冲区开销,有利于提高延迟性能[9-11].文献[5]提出一种邮箱交换(mailboxswitch)的思想.采用对称型连接模式为通告报文离开时间创造反馈通路,调度器根据报文的离开时间调度报文.该策略能够保证每条流的报文按照其到达顺序离开交换系统但不能提供100%的吞吐率.文献[11]提出一种能够保证报文顺序的交替匹配交换结构(interleavedmatc-hingswitch),采用集中式的调度模式,假设流量特征是预知的且固定不变,采用矩阵分解的方法[12]离线解决集中式调度问题,分布式实现在线调度并提供服务保证.然而,当流量变得不可预知并动态改变时,难以在大的交换尺寸下满足集中式的调度需求.文献[9]提出一种并发匹配交换结构CMS(Concur-rentMatchingSwitch),其基本思想为:通过在中间级线卡设置协同槽(coordinationslots)即长度为1的缓冲区,保证了所有匹配报文从输入线卡到达目的输出线卡经历了相同的延迟,从而避免了信元乱序.CMS结构首先为每个到达报文发送请求令牌到中间级输入线卡而不是报文本身,每一个请求令牌相当于一个占位符.中间级输入线卡为每一条流的请求令牌计数,因此需要维护N2个虚拟令牌计数器,构成N×N的虚拟令牌计数矩阵.每一个中间级输入线卡根据本地虚拟令牌计数矩阵计算匹配,不需要任何全局的状态信息或从其它中间级输入线卡获取虚拟令牌计数信息,并根据匹配结果发送许可令牌到每一个输入线卡.任何双向匹配算法都可以用于计算CMS结构中的匹配问题,文献[11]证明,只要中间级输入线卡使用稳定的匹配算法,带流分离操作的CMS结构是稳定的,从而能够提供100%的吞吐率.然而CMS结构采用双向匹配算法,算法复杂度至少为O(N2);另一方面,CMS结构假设输入线卡和中间级输入线卡之间的令牌通信开销可以忽略不计,而在路由器硬件实现中令牌在线卡间的频繁传递将成倍增加调度周期[13].在负载均衡交换结构中,信元乱序问题源自不同的中间级输入线卡中目的端口相同的缓冲队列具有不同的长度.鉴于此,文献[3]提出一种UFS(UniformFrameSpreading)算法,通过将同一条流的N个信元依次分派到N个中间级输入线卡,使得中间级输入线卡相同目的端口的缓冲队列具有相同的长度,从而保证了信元的顺序.当流所含信元数目小于N时则需等待,因此在高端口密度下,UFS算法所引发的信元延迟是不可容忍的.为了降低UFS算法信元聚合延迟,我们在早期论文[14]中提出了固定映射的思想,由此设想了一种基于流映射的细粒度负载分配算法UFFS-k(UniformFine-grainFrameSpreading,k为聚合粒度,简称UFFS-k),通过构建流到区域的固定映射,实现报文的顺序并通过降低聚合粒度以提高延迟性能.论文[14]提出的循环映射算法本身并不能保证负载均衡,本文首先通过理论证明,UFFS-k算法能够保证报文的顺序;原创性地提出最小长度分派以及流量分布矩阵互斥写策略,证明了最小长度分派结合流量分布矩阵互斥写策略能够获得100%负载均衡度;最后在贝努利一致流量模型和突发流量模型下分析评测UFFS-k算法在不同聚合粒度k下的延迟性能,并与目前主流的负载均衡调度算法进行比较,模拟结果显示,当聚合粒度k=2时,UFFS-k算法在同类维序算法中表现出最优延迟性能.3UFFS-犽算法基本思想3.1体系结构UFFS-k算法采用的负载均衡交换结构如图1所示,输入端口将到达信元按照目的端口缓冲在VOQ队列,VOQ队列来自同一条流的k个信元,称之为一个单位帧;N个中间级输入端口被依次划分Page4为N/k组,每组含k个连续的中间级输入端口构成一个区域;每个输入端口独立执行UFFS-k信元分派算法,在k个连续的外部时间槽,UFFS-k将同一条流的单位帧通过第一级Mesh网络发送该流固定图1负载均衡交换结构参照文献[14]给出的符号与定义,我们用VOQi,j表示输入端口i的虚拟输出队列j;OQl中间级输入端口l的输出队列j;f(i,j)表示从输入端口i到输出端口j的流;k为聚合粒度,表示UFFS-k算法连续调度同一条流信元的数目(k为端口数N的因数);VOQi,j队列的每k个信元构成一个单位帧(unitframe),输入端i,N/k个不同VOQ队列的单位帧(共计N个信元)构成一个聚合帧(aggregateframe),VOQi,j队列的N个信元,构成一个满帧(fullframe);中间级输入端口1,2,…,N被依次分成N/k组,每一组含k个连续的中间级输入端口,第g组的k个中间级输入端口构成一个区域,记作Rg,Sr,z表示区域r的第z个中间级输入端口;每个输入端口的N条流被划分为N/k组与N/k个区域相对应,每组含k条流,输入端口i第f组的k条流构成一个流分支,记作Qi为降低报文缓冲存储器带宽需求,Mesh网络通常运行在速率R/N(内部链路加速比为1),由此得到以下定义.定义1.在速率为R的链路发送或接收一个信元所耗费的时间为外部时间槽(externaltimeslot).定义2.在速率为R/N的链路发送或接收一个单位帧所耗费的时间为时间槽(timeslot),时间槽为外部时间槽的N倍.定义3.受输入链路约束影响[15],输入端口每N个外部时间槽恰能发送一个信元到同一中间级的映射区域;各区域按照目的端口将信元缓冲在OQ队列,由于流到区域的映射关系固定,来自同一单位帧的k个信元将依次到达OQ队列头位置,等待第二级Mesh网络空闲时依次离开输出端口.输入端口,可用输入链路集合(AvailableInputLinkSet)是指在外部时间槽e,能够从输入端口i接收信元的中间级输入端口的集合,记作AIL(i,e).定义4.受输出链路约束影响[15],中间级输入端口每N个外部时间槽恰能发送一个信元到同一输出端口,可用输出链路集合(AvailableOutputLinkSet)是指在外部时间槽e,能够将信元发送到输出端口j的中间级输入端口的集合,记作AOL(j,e).在负载均衡交换结构中,当同一条流的信元所在中间级输入线卡OQ队列长度不同时就会引发信元乱序,并且乱序信元数目随着OQ队列长度差异的增大而增大.UFS算法通过将同一条流的N个信元分派到中间级输入线卡所有的OQ队列,保证了OQ队列长度的一致性从而实现了信元保序.UFS的缺点是需要在输入端VOQ队列聚合N个信元,聚合粒度太大,增加了信元延迟,并存在“饿死”现象.针对以上问题,UFFS-k算法以细粒度的方式将同一条流的k个信元分派到预先设定的映射区域(k个连续的中间级输入端口),由于流到区域的映射关系固定,对任意流,其信元所在映射区域的OQ队列长度相同,从而实现了信元的按序发送,我们在3.3节证明了该结论.3.2建立流到区域的映射流到区域的映射算法用于构建流到区域固定的映射关系,它关系到中间级输入端存储资源及两级Page5Mesh网络的利用率,为避免吞吐量损失(lossofthroughput)流到区域的映射算法应实现输入负载在各区域的均衡分布.本节提出一种兼顾负载均衡和报文保序的双循环(dual-rotation)映射算法,其主要思想与我们之前提出的循环映射算法[14]类似:既然对于任意给定的区域,只能接收同一输入端口固定的k条流,那么为实现负载在各区域的均衡分布,以循环方式调整流分支到区域的映射,从而得到N/k种映射方式.如图2所示,第1层循环保证了每个区域恰能涵盖所有的流;进一步以循环方式调整不同输入端口与N/k种映射方式的关联,第2层循环保证了每个区域按照输入端口的均衡分布涵盖所有的流.从3.3节可以看到,UFFS-k算法根据中间级输入端口流量分布矩阵调度单位帧,进一步保证了每条流在区域之间的均衡性.双循环映射算法通过简单的取模运算建立流到区域的映射关系,可描述如下://Definethefollowingconstants://N,Numberofports//k,Aggregatefactor//Definethefollowingvariables://i,Integer,inputportnumber//f,Integer,flowbranchnumber//g,Integer,regionnumberfor(i=0,i<N,i++)for(g=0,g<N/k,g++)FlowMapping(QiFunctionFlowMapping(Qiif(k==1)f=(g+i)%(N/k);else{if(g<(i%(N/k)))f=(g+(N/k))-(i%(N/k));elsef=g-(i%(N/k));}EndFunctionFlowMapping图2显示了当端口数目N=32,聚合粒度k=8时,循环映射算法得到的流到区域的映射结果(VOQij代表从输入端口i到输出端口j的流,→表示映射关系).3.3UFFS-犽调度算法UFFS-k算法分布于每个输入端口独立执行,根据流到区域的映射关系分派信元.UFFS-k算法以轮询(round-robin)方式服务于N/k个流分支,以单位帧为最小调度单元,在连续的k个外部时间槽,发送流分支中固定VOQ队列的单位帧,输入端口iUFFS-k调度算法每个外部时间槽的操作可描述如下:步1.对区域Rg(g初始化为0),若流分支Qi等式(f+i%(N/k))%(N/k)=g)最小均衡系数VOQ队列VOQi,j(kfj<kf+k)存在单位帧且输入端口i到中间级输入端口Sg,1的内部链路空闲,则将VOQi,j队列头信元发送到区域Rg中间级输入端口Sg,1;若Qi列不存在单位帧或者输入端口i到中间级输入端口Sf,1的内部链路忙,则g=(g+1)modN/k,返回步1;步2.发送VOQi,j队列头信元到区域Rg中间级输入端口Sg,2;…口Sg,k,g=(g+1)modN/k,返回步1.步k.发送VOQi,j队列头信元到区域Rg中间级输入端通常情况下,在每个时间槽即每N个外部时间槽,UFFS-k调度算法可从输入端N/k个流分支中聚合N/k个单位帧构成一个聚合帧分派到中间级输入端口.VOQ队列均衡系数反映了流量在中间级输入端口OQ队列分布的均衡性,UFFS-k调度算法根据各区域OQ队列长度调度单位帧,实现了区域间的负载均衡.下面将通过证明详细阐述均衡系数工作原理.引理1.对任意输入端口i,e0,输入链路集合个数满足|AIL(i,e)|N-N/S+1,其中S为内部链路加速比.证明.对引理1的证明见参考文献[16].引理2.UFFS-k调度算法在没有考虑内部链路加速比的情况下(s=1),对任何区域r,若Sr,1∈AIL(i,E)则有Sr,z∈AIL(i,E+z-1),z=2,…,k,且UFFS-k调度算法在任意时间槽即N个连续的外部时间槽,可用输入链路集合满足∪E+N-1∪0r<N/k∪kz=1Sr,{}z.证明.Sr,1∈AIL(i,E)表明中间级输入端口Page6Sr,1在最近的N-1个外部时间槽内没有从输入端口i接收信元(若Sr,1在外部时间槽E-(N-1)接收过信元,那么N-1个外部时间槽以后,Sr,1仍不可用,即Sr,1AIL(i,E)).不失一般性,假设Sr,1在外部时间槽E-N从输入端口i接收过信元,那么根据输入链路约束,N个外部时间槽以后,Sr,1重新被释放即Sr,1∈AIL(i,E).由于UFFS-k调度算法总是在连续的k个外部时间槽依次发送信元至Sr,1,…,Sr,k,那么Sr,2,…,Sr,k分别在外部时间槽E-N+1,…,E-N+k-1接收信元,根据输入链路约束,Sr,z∈AIL(i,E+z-1),z=2,…,k成立.接下来证明引理2的第二部分.根据输入链路约束不难推断,在任意N个连续的外部时间槽内不存在同一个中间级输入端口两次加入到可用输入链路集合中,该特性可表示为若Sr,z∈AIL(i,e),Sr,z∈AIL(i,e)则Sr,z≠Sr,z其中1|e-e|N-1.又由引理1知,|AIL(i,e)|N-N/S+1=1,即在任意外部时间槽,至少有1个中间级输入端口可用,不失一般性,假设在每个外部时间槽e,存在Sr,z∈AIL(i,e)从输入端口i接收信元,那么根据引理1从E到E+N-1连续的N个外部时间槽,一定有N-|AIL(i,E)|个不同的中间级输入端口加入可用输入链路集合中,从而有∪E+N-1∪0r<N/k1zkSr,z成立,之前已经证明对任何区域r,∪k总是在k个连续的外部时间槽,以round-robin的方式依次加入可用输入链路集合,将Sr,1∈AIL(i,E),Sr,z∈AIL(i,E+z-1),z=2,…,k等价表示为∪E+k-1v=EAIL(i,v)=∪1zkSr,z后,在任意N个连续的外部时间槽,∪E+N-1引理3.UFFS-k调度算法保证对任意区域Rg,0j<N,k个中间级输入端口对应的k个OQl队列长度相同(忽略单位帧的传输延迟),其中l∈Rg.证明.采用对时间槽的归纳法证明.对第1个时间槽,引理3显然成立.假设在时间槽T结束后,引理3成立,那么只需证明在时间槽T+1结束后,引理3依然成立.由引理2知,在任意时间槽,可用输入链路集合满足∪e+N-1v=eAIL(i,v)=∪0r<N/k∪k端口i,在同一时间槽至多发送一个单位帧到特定区域Rg.假设在时间槽T+1,区域Rg从P个输入端口接收到了P个单位帧,其中0PN.不失一般性,假设该P个单位帧目的端口集合为{j1,j2,…,jP},其中1PP,那么区域Rg目的端口j(j=j1,j2,…,jP)对应的k个队列OQSg,1j分别接收到d(d=d1,d2,…,dP)个信元,d1OQSg,k表示区域Rg接收到的目的端口为j1的单位帧的数目,以此类推.在时间槽T结束后,由引理3知对输出端口j,OQl间槽T+1结束后OQSg,1j,OQSg,2j,…,OQSg,kj(j=j1,j2…jp)在队列长度增加d(d=d1,d2,…,dP)后仍然相等,其它OQl槽T+1结束后依然成立.定义5.既然对任意区域Rg,OQl同(l∈Rg),那么队列VOQi,j均衡系数等于其映射区域Rg输出队列j的长度,记作Lg,j.定理1.UFFS-k调度算法能够保证每条流按序离开输出端口.证明.该命题等价于证明:假设流f(i,j)任意两个信元C1,C2,若C1先于C2到达输入端口i,那么C1先于C2离开输出端口j.考虑C1,C2属于同一单位帧和不同单位帧两种情况:若C1,C2属于同一单位帧,那么根据UFFS-k调度算法,在连续的k个外部时间槽,依次将单位帧的k个信元以循环(roundrobin)方式分派至其映射区域Rg;假设C1缓冲在队列OQl1j,C2缓冲在队列OQl2j,则l1,l2∈Rg,按照C1,C2到达顺序l1<l2.假设OQl1j,OQl2j队列长度分别为L1,L2,由引理3知,L1=L2,根据输出链路约束,在每个时间槽,输出线卡j恰能从OQl元,那么L1个时间槽后,C1,C2将按序离开输出端口j.若C1,C2属于不同单位帧,按照到达顺序,UFFS-k算法首先调度C1所在单位帧,其次调度C2所在单位帧,C1先于C2到达流f(i,j)的映射区域Rg,若C2到达区域Rg时,C1已经离开输出端口j,则得证.否则,假设以C1为界,Lg,j=L1,以C2为界,Lg,j=L2,则L2>L1.C1首先离开输出端口j,L2-L1个时间槽后,C2离开输出端口j.证毕.定义6.若队列VOQi,j存在单位帧且均衡系数满足Lg,j=min0g<N/k(Lg,j),则在连续的k个外部时间槽将VOQi,j队列单位帧发送到区域Rg,这就是最Page7小长度分派.引理4.采用最小长度分派的UFFS-k调度算法保证在时间槽T结束后,对任意两个区域Rg1,Rg2,其OQ队列长度Lg1,j与Lg2,j最多差1.证明.采用对时间槽的归纳法证明.对第1个时间槽,引理4显然成立.假设在时间槽T结束后,引理4成立,那么只需证明在时间槽T+1结束后,引理4依然成立.在时间槽T结束后,由引理4知,假设min0g<N/k(Lg,j)=L,则max0g<N/k(Lg,j)=L+1,其中L0.在时间槽T+1内,对任意输出端口j,可能存在一个或多个输入端口将单位帧发送到满足Lg,j=min0g<N/k(Lg,j)的区域Rg,不失一般性,假设被调度的区域集合为{Rg1,Rg2,…,Rgp},其中pnum(Lg,j=min0g<N/k(Lg,j)),那么其对应的OQ队列长度{Lg1,j,Lg2,j,…,Lgp,j}由L变为L+1.若p=num(Lg,j=min0g<N/k(Lg,j)),则有min0g<N/k(Lg,j)=max0g<N/k(Lg,j)=L+1;若p<num(Lg,j=min0g<N/k(Lg,j)),则有min0g<N/k(Lg,j)=L,max0g<N/k(Lg,j)=L+1;与此同时,受输出链路约束影响,输出线卡j将依次从OQl出N个信元,当时间槽T结束后,所有OQjs队列长度全部减1,即Lg,j(0g<N/k)全部减1,综上所述,引理4在时间槽T+1结束后依然成立.证毕.UFFS-k调度算法需要维护全局统一视图的流量分布矩阵犔=[Lg,j],为了保证流量分布矩阵在每个输入端口视图的一致性,必须实现对流量分布矩阵写操作的互斥性.我们采用锁机制实现对互斥量Lg,j的互斥写:若g,j满足Lg,j=min0g<N/k(Lg,j)且Lg,j处于解锁(unlock)状态,那么输入端口i对Lg,j加锁后将VOQi,j队列单位帧发送至其映射区域Rg,Lg,j加1后被解锁.流分支中均衡系数Lg,j处于加锁状态的VOQi,j队列直接被跳过.不难推断,只有那些流到区域的映射关系相同的输入端口同时调度目的端口相同VOQi,j队列时才可能引发对同一Lg,j的写冲突,对均衡系数Lg,j的互斥写可以避免这些输入端口同时将多个单位帧发送到同一区域的输出队列j,造成流量分布不均衡.注:本文对引理4的证明也是以实现流量分布矩阵犔互斥写为前提的.由于流分支到区域的映射关系固定,存在某些区域因负载过重而发生缓冲区溢出而其它区域相对空闲的情况.例如,输入端某个流分支的VOQ队列含N个信元,并且队列长度仍在不断增长,而其它流分支没有单位帧可以调度.这样重负载流分支到其映射区域的内部链路将成为性能瓶颈,另一方面重负载流分支因无法使用输入线卡其它空闲链路而造成内部带宽浪费.为了解决以上问题,UFFS-k算法允许重负载流分支抢占链路资源,通过赋予满帧最高优先级将突发报文流均匀分布于每个区域.UFFS-k算法调度满帧时可能引发信元乱序,图3显示了将满帧分派到中间级输入端口时,出现了信元乱序现象.图3中4个区域{R1,R2,R3,R4}输出队列j的长度{L1,j,L2,j,L3,j,L4,j}分别为3,2,2,3(灰色部分所示),当输入端将流f(i,j)的N个信元分派到这4个区域时(黑色部分所示),区域2、3的信元先于区域1的信元到达目的端口j,而正确的离开顺序应该是区域1的信元最先离开,然后是区域2,区域3和区域4.为了解决调度满帧引发的信元乱序问题,我们将从VOQi,j队列读出的N/k个单位帧(即一个满帧)依次分派到目前Lg,j最小的区域Rg.采用该策略得到的分派顺序是:从VOQi,j队列读出的第1个及第2个单位帧依次分派在区域2和区域3,第3个单位帧及第4个单位帧依次分派在区域1或区域4,这4个单位帧将按读出顺序依次到达输出端口j.由引理4知,不同区域输出队列j的长度至多差1,因此将满帧中N/k个单位帧依次发送到目前Lg,j最小的区域不会引发信元乱序.本质上,调度单位帧与调度满帧都采用了最小长度分派策略,两者的区别在于单位帧只能固定分派到其映射区域,而满帧将被拆分为N/k个单位帧均衡分布于N/k个区域.我们采用负载均衡度来衡量负载在中间级输入3.4UFFS-犽算法负载均衡度分析线卡分布的均衡程度,负载均衡度可定义如下.定义7.负载均衡度.假设在时间段[tr,tv]内的第l个交换模块转发了Sl[tr,tv]个信元.负载均Page8衡度为在该时间段内,不同交换模块转发的最小信元个数与最大信元个数的比值,即其中,K为中间级交换模块的数目.显然负载均衡度E[tr,tv]1,E[tr,tv]趋近于1,表示各交换模块处理的信元数基本相同,负载在交换模块的分布比较均衡.E[tr,tv]越小,交换模块负载均衡性越差.定理2.UFFS-k调度算法可获得100%负载均衡度.证明.由引理4知,对任意两个区域Rg1,Rg2,目的端口相同的OQ队列长度Lg1,j与Lg2,j最多差1.那么含N个OQ队列的交换模块,对任意时间段[tr,tv]满足maxl=0,…,K-1Sl[tr,tv]-minl=0,…,K-1Sl[tr,tv]N.负载均衡度可计算为E[tr,tv]=当maxl=0,…,K-1Sl[tr,tv]N时,负载均衡度E[tr,tv]趋近于1,UFFS-k调度算法可获得100%负载均衡度.3.5UFFS-犽算法吞吐率分析3.5节证明了UFFS-k算法能够获得100%的吞吐率.引理3摘自文献[3],描述了工作保持(work-conserving)的服务特性.引理5.考虑一种工作保持(work-conserving)的服务,令A(t)和B(t)分别表示在时间t以前到达和服务的信元数目.假设服务容量是每个外部时间槽服务一个信元,那么对于所有的时间t0,B(t)=min0st[A(s)+t-s].接下来,我们证明UFFS-k算法能够保证100%的吞吐率.考虑给定的输出端口j,令Aj(t),Bj(t),Cj(t)分别表示目的端口为j的到达输入端口、中间级输入端口及输出端口j的信元数目.定理3.UFFS-k算法和理想的输出排队交换结构具有相同的吞吐率,与输入流量到达过程无关.证明.首先,每个输入端口任意流分支至多包含k(k-1)个信元,此时,流分支中没有一个单位帧可以调度,当存在单位帧可以调度时,输入端是工作保持的(在k-1个外部时间槽的延迟范围内).由于每个输入端在每个外部时间槽最多到达一个信元,因此当输入端工作保持时,流分支最多包含k(k-1)+k-1=k2-1个信元(输入端开始服务流分支后),自此流分支中的信元数目不会进一步增加.当不存在单位帧、输入端不再工作保持时,流分支信元数目不会超过k(k-1).因此对任何流分支在任何时刻最多包含k2-1个信元(不包括正在服务的信元).那么N个输入端口最多包含Nk2个信元,特别地,当所有到达信元目的端口相同时,最多有Nk2个信元去往输出端口j.因此,在任意时刻t0,Bj(t)Aj(t)-Nk2(在这里,假设信元传输是瞬时的.如果报文传输延迟τ>0,那么Bj(t)Aj(t-τ)-Nk2,接下来的等式都照此简化).令Bj所含信元个数.对任意流,当单位帧还没有全部到达中间级输入端时,最多有k-1个信元在中间级OQ队列.由于UFFS-k算法对流量分布矩阵写操作的互斥性,对于给定输出端口j,至多有N/k个输入端口正在发送且未发送完毕目的端口为j的单位帧,则有只要存在单位帧完全到达中间级输入端口,则交换阶段是工作保持的.因此,交换阶段至少与信元到达过程服从Bjservingserver)一样多的信元,因此由引理5得到Cj(t)min0st[Bjmin0st[Aj(s)+t-s-Nk2-N/k(k-1)](1)我们现在比较在相同的到达模式下负载均衡交换结构与OQ交换结构的性能.OQ交换结构中目的端口为j的信元行为可以建模为到达过程为Aj(t),服务时间间隔为常量1的工作保持服务.假设OQ(t)为这种服务的服务次数,那么根据引理5,我Cj们得到比较式(1)与式(2)得到Cj(t)min0st[Aj(s)+t-s]-Nk2-N/k(k-1)因此,UFFS-k算法服务信元的数目和OQ交换结构服务信元的数目仅相差常量Nk2+N/k(k-1).这意味着UFFS-k算法总是和OQ交换结构具有相同的吞吐率,并与输入流量的到达过程无关.证毕.Page94UFFS-犽算法性能评测目前一般采用软件模拟的方法对交换结构及其调度算法进行性能评估.我们对Stanford大学开发的SIM模拟器①,进行了修改和扩充,构建了一个输入端采用VOQ队列模型,中间级采用OQ队列模型的负载均衡交换结构(load-balancedswitch).我们在贝努利一致流量模型和突发流量模型下,比较了FOFF[3]、UFS[3]、UFFS-k和基本的负载均衡算法BLA[2](BasicLoad-balancedAlgorithm)的延迟性能,观察了聚合粒度k=8,4,2,1时UFFS-k算法延迟性能的变化.4.1模拟环境SIM模拟器提供多种流量模型,我们采用了两种具有代表性的流量模型:(1)贝努利一致流.服从贝努利到达过程,独立同分布,目的端口均匀分布于所有的输出端口;(2)突发流.突发长度为10,在忙-闲周期(busy-idleperiods)突发信元,目的端口以连续突发或者一个信元接一个信元的方式分布于所有的输出端口.由于Internet流量具有突发特性,突发流量模型更接近真实的网络流量.在所有的模拟实验中,模拟时间为200000个外部时间槽;实验参数为:端口数目N=16,内部链路加速比S=1.所有队列长度为无穷大,即不限制队列长度,不丢弃信元.4.3节在贝努利一致流量模型和突发流量模型下,模拟比较了FOFF、UFS、UFFS-k和BLA4种算法的延迟性能,分析了UFFS-k算法在不同的聚合粒度下的延迟特性.4.2算法建模我们在负载均衡交换结构中实现了FOFF、UFS、UFFS-k和BLA4种调度算法.对于FOFF算法,输入线卡采用VOQ队列缓冲到达信元;中间级输入线卡采用OQ队列模型;每个输出线卡维护N个深度为N个信元的缓冲队列,用于重定序乱序报文.在输入端,满帧被赋予最高优先级,只要存在满帧则调度满帧,若不存在满帧则以round-robin的方式调度其它非空VOQ队列.为了限定负载均衡路由器内乱序信元的数量,FOFF算法严格按照round-robin的顺序发送VOQ队列的信元到中间级输入线卡.因此,每N个外部时间槽FOFF只能服务一个VOQ队列,当被服务VOQ队列的信元不能占用全部的内部链路时(所含信元小于N的情况),将造成内部链路带宽的浪费.FOFF算法在输入端保证了每条流的信元以round-robin的方式分布于中间级输入线卡.在输出端,FOFF维护N个round-robin指针指示每条流的下一个信元所在的中间级输入线卡,来自该中间级输入线卡的信元就是下一个信元.因此,FOFF算法能够在没有任通信开销的情况下实现信元的按序发送,但输出端O(N2)的重定序缓冲区开销加大了信元延迟.建模UFS算法为聚合粒度等于端口数目N的UFFS-k算法,在这种极端情况下已经不存在流到区域的映射关系.建模UFFS-k算法为:输入端采用VOQ队列模型,按照3.3节所描述的算法建模UFFS-k算法,UFFS-k算法分布在每个输入端独立执行;中间级输入线卡采用OQ队列模型.在没有特殊声明的情况下,所有队列长度均为无穷大.对于基本的负载均衡调度算法BLA,我们按照文献[2]所执行的调度算法建模BLA算法.输入端以固定轮转的方式将到达信元通过第一级Mesh网络发送到中间级输入线卡.由于连接模式的周期性,信元按照其到达时间均匀分布在中间级输入线卡,因此到达中间级输入线卡的流量是负载均衡的.中间级输入线卡采用VOQ队列模型,按照信元的目的端口缓冲信元,同样以固定轮转的方式将VOQ队列中的信元通过第二级Mesh网络发送到输出端口.文献[2]证明了,BLA算法能够获得100%的吞吐率,在重负载的情况下,信元平均延迟接近OQ交换结构.BLA算法不能保证报文的顺序,存在严重的报文乱序现象.4.3延迟实验我们分别在贝努利一致流量模型和突发流量模型下分析比较了FOFF、UFS、UFFS-k和BLA4种算法的信元平均延迟.图4显示了在贝努利一致流量模型下UFS算法的系统平均延迟远远大于其它算法,这是因为UFS需要在输入端聚合N个信元才能实施一次调度.通过不断降低聚合粒度k,UFFS-k算法的延迟性能得到了显著提升.在极端情况下,当聚合粒度为1时,UFFS-1算法在低负载情况下具有与BLA算法相当的延迟性能,但在高负载情况下变得不稳定,当负载大于0.7时,UFFS-1算法系统平均延迟高于UFFS-2.这可能是因为聚合粒度为1时,UFFS-1算法总是将流发送到固定的中间级输入线卡,这种每条流专享一条链路的调度方式可能会造成内部链路带宽的严重浪费更不利于负载均衡.对于FOFF算法,正如第2节所指出①http://klamath.stanford.edu/tools/SIM/Page10的,内部链路带宽浪费在某种程度上降低了系统吞吐率,此外大部分的信元延迟发生在输出端的重定序操作上(重定序缓冲区开销为O(N2)).当输入负载大于0.2时,UFFS-4具有比FOFF更低的信元平均延迟;而UFFS-2的延迟性能明显优于FOFF.BLA算法延迟性能略优于UFFS-2算法,但BLA算法存在严重的信元乱序问题,从而损害TCP协议的性能.图4FOFF、UFS、UFFS-k及BLA算法平均延迟图5显示了在突发流量模型下的模拟结果.随着聚合粒度的不断降低,UFFS-k算法延迟性能获得的提升越少.在极端情况下,当聚合粒度k=1时,UFFS-1系统平均延迟大于UFFS-2;UFFS-1算法在突发流量模型下变得更不稳定;当输入负载达到0.99时,UFFS-1算法的平均延迟最大,甚至超过了UFS算法.UFFS-1算法发送每条流到固定的中间级输入线卡,在突发情况下,UFFS-1算法为实图5FOFF、UFS、UFFS-k及BLA算法平均延迟(突发流量模型)现负载均衡必将导致信元被延迟调度.当输入负载大于0.3时,UFFS-4算法延迟性能优于FOFF算法.UFFS-2算法在所有能够保证报文顺序的算法中具有最优延迟性能,并与不具备报文保序特性的BLA算法性能相当.5结论采用固定连接模式的负载均衡交换结构成为提高路由器性能、规模、可扩展性的有效途径.负载均衡交换结构存在严重的报文乱序现象,乱序报文会降低TCP连接吞吐率增加报文延迟,在路由器中保证报文的顺序是极其必要的.另一方面,为了保证报文的顺序,路由器需要完成大量额外的工作,这会影响路由器的性能.本文提出一种基于流映射的负载调度算法UFFS-k,采用双循环方式构建流到区域的映射,以细粒度的方式将同一条流的k个信元分派到固定的映射区域,通过理论证明,该调度策略可获得100%吞吐率并能够保证报文的顺序.本文通过模拟验证UFFS-k算法在不同聚合粒度k下的延迟性能,并与目前主流的负载均衡调度算法进行比较.模拟结果显示,当聚合粒度k=2时,UFFS-2算法在所有能够保证报文顺序的调度算法中具有最优延迟性能;并在突发流量模型下,表现出与不具备报文保序特性的BLA算法相当的性能;因此UFFS-2算法能够在保证报文顺序的同时提供延迟和吞吐率保证.
