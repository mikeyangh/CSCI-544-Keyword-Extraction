Page1基于组合测试的软件故障定位的自适应算法周吴杰1),2)张德平4)徐宝文2),3)1)(东南大学计算机科学与工程学院南京210096)2)(南京大学软件新技术国家重点实验室南京210093)3)(南京大学计算机科学与技术系南京210093)4)(南京航空航天大学信息科学与技术学院南京210016)摘要在研究了Martínez等人提出的组合测试错误定位模型的基础上,改进了他们用高维覆盖表来构造错误定位表的方法,并且针对安全值已知的待测系统提出了至多t维的错误交互定位的自适应算法,从而解决了Martínez等人提出的开问题之一,并进一步分析了自适应算法的性能,证明了定位错误交互需调用的测试过程数目是关于错误交互数与因素数多项式阶增长的,拓展了Martínez等人提出的针对t=2的错误交互定位的自适应算法.关键词组合测试;覆盖表;错误定位表;自适应算法1引言随着计算机技术的飞速发展,软件与硬件系统Page2统,其因素数很少时,可采取穷尽测试来测试各个因素交互,但对于大的软件系统,则穷尽测试是不可能的.例如,一个软件系统有10个因素,每个因素有4个不同的取值,则穷尽测试需要410=1048576个测试用例.如果我们选择测试用例来测试所有因素的两两交互,或者t维交互,则测试用例会大大减少.上例中,两两交互测试至多只需25个测试用例.Kuhn等人[1]的研究表明测试两两交互覆盖能发现大约70%的错误,三维组合覆盖能发现90%的错误.人们应用组合测试策略进行软件测试已有很长时间,最早的组合测试是应用正交拉丁方和正交试验设计来对软件进行测试[2-3],后来贝尔实验室提出了基于贪心策略的组合测试用例生成算法,并开发了相应的测试工具[4].此后,美国喷气推进实验室的Tung等人以及Colbourn等人[5-8]在此基础上分别提出了改进的TCG方法和确定密度算法.2001年,Lei等人[9-11]提出了基于参数顺序扩展策略的组合测试用例生成算法.Kobayashi和Tsuchiya等人[12]则在2002年提出用于生成两两组合测试用例集的基于递归的代数方法.2003年,Cohen等人[13-15]将模拟退火算法应用于变力度组合测试用例的生成.Shiba和Tsuchiya等人[16]在2004年研究了遗传算法和蚁群算法在组合测试数据自动生成中的应用.在组合测试中,由于测试失败预示着系统组件中存在错误,这就需要测试人员找出触发系统故障的错误交互.目前,对组合测试的结果进行调试和错误定位分析的研究还很少.2002年Zeller和Hildebrandt[17]提出Δ-调试方法对待测系统中出现的故障进行调试以简化与孤立导致故障的环境或输入.2006年,Yilmaz等人[18]用分类树法来定位错误交互,系统的错误交互一般很难被精确地确定.2006年徐宝文等人[19]提出了一种基于组合测试的软件故障调试方法,可把引发软件故障的错误交互锁定在很小的范围内,但他们的方法仅对因素个数较少的情况可用.2008年Colbourn和McClary[20]提出了(d,t)错误定位表及错误侦测表的概念,用这些表来对组合交互错误进行定位.随后Martínez等人[21-22]提出了一般的错误定位表,在此模型下提出了自适应算法来定位错误交互,但他们只处理了二维组合覆盖,即在软件故障是由二维错误交互引发的假设下,给出错误交互定位的自适应算法,对于一般的情形并没有给出相应的解决办法,而是作为开问题提出来.因此,当利用组合测试策略来对系统进行测试时,某些因素的组合会导致系统发生故障,如何定位和侦测哪些因素组合会导致系统故障,是组合测试研究中一个亟待解决的问题.本文在研究Martínez等人[21-22]提出的组合测试错误定位表模型的基础上,改进了他们提出的用高维覆盖表来构造错误定位表的方法,然后针对安全值已知时定位二维错误交互的自适应算法没法处理高维错误交互的不足,提出了具有安全值已知时至多t维的错误交互定位的自适应算法,从而解决了Martínez等人提出的开问题之一,并进一步分析了自适应算法的性能,得到结论:定位错误交互需调用的测试过程数目是关于待测系统中错误交互数与因素数的多项式阶增长的,推广了Martínez等人提出的针对t=2的错误交互定位自适应算法.本文第2节介绍基本的组合测试模型、故障定位模型以及相关结论,并对Martínez等人的用高维覆盖表来构造错误定位表的方法进行推广,使得这个方法在实践中能够得到实用;第3节我们分析Martínez等人提出的在安全值已知的待测系统中的定位二维错误交互的自适应算法,提出在此待测系统中的至多t维的错误交互定位的自适应算法;第4节我们分析自适应算法的性能,得到结论:定位错误交互需调用测试过程数目是关于待测系统中错误交互数与因素数的多项式阶增长的,并对Martínez等人提出的针对t=2的错误交互定位自适应算法进行推广;最后总结全文并讨论未来可进行研究的方向.2组合测试故障定位模型为了研究基于组合测试的软件故障与侦测技术,这里先给出一些记号和形式化定义.假设影响待测系统(SoftwareUnderTest,SUT)的因素共有k个,因素i有vi(1ik)个可能的取值,用0,1,…,vi-1表示.我们用记号[0,vi-1]表示集合{0,1,…,vi-1}.假设这些参数的取值是相互独立的,即某个参数的具体取值不会影响其它参数的取值或存在性.定义1.设k维向量犜=(T1,T2,…,Tk),其中Ti∈[0,vi-1],i=1,2,…,k,则称这个k维向量犜为第i个因素取值为Ti的测试用例.定义交互的概念如下.定义2.设集合I={(i1,ai1),(i2,ai2),…,Page3(it,ait)},其中因素ij互不相同,aij∈{0,1,…,vij-1}(j=1,2,…,t),则称这个集合I为一个t维交互.称集合fI={i1,i2,…,it}为交互I对应的因素集,一维交互{(i1,ai1)}也称为顶点,简记为(i1,ai1).定义3.设一条测试用例犜的第ij个因素取值是aij(j=1,2,…,t),即犜(ij)=aij,则称这条测试用例覆盖了t维交互I={(i1,ai1),(i2,ai2),…,(it,ait)}.这样,一条测试用例覆盖了()k了产生满足一定维数的交互覆盖要求的测试用例集,定义覆盖表如下.定义4.如果A是一个n×k表,表中第i列元素都取自[0,vi-1],且满足:每个可能的t维交互都被表中某一行所对应的测试用例所覆盖,即对任意的t维交互{(i1,ai1),(i2,ai2),…,(it,ait)},至少存在一行r,使得A[r,ij]=aij,j=1,2,…,t,则称A是一个t维混合覆盖表,记为MCA(n;t,(v1,v2,…,vk)).t称为覆盖表的强度.给定t和v1,v2,…,vk,称使得MCA(n;t,(v1,v2,…,vk))存在的最小的整数n为混合覆盖表数,记为MCAN(t,(v1,v2,…,vk)),当定义中的v1=v2=…=vk=v时,我们简记为CA(n;t,k,v)和CAN(t,k,v).在不引起混淆的情况下覆盖表或混合覆盖表统称为覆盖表.一般人们用覆盖表或混合覆盖表来产生测试用例,表中每列对应一个因素,k表示待测系统的因素数,vi表示每个因素可能取的取值个数,每一行表示一个测试用例,t维覆盖表产生的测试用例集能覆盖到k个因素中任意t个因素所有可能的取值组合,二维覆盖表产生的测试用例集称为两两组合测试用例集,人们希望在不降低测试标准情况下来产生尽可能少的测试用例.例如,一个打印系统有两种类型打印机P1,P2,分别用0,1表示;打印的文件格式有3种JPEG,PDF,PS,分别用0,1,2表示;颜色有黑白与彩色两种,用0,1表示;文件大小划分为小于等于50MB,大于50MB且小于500MB和大于等于500MB,也分别用0,1,2表示[22].如果对因素的所有可能取值组合进行测试,则需要2×3×2×3=36个测试用例,若只考虑任意两个因素之间的交互作用,则只需要9条测试用例即可,如表1所示.测试用例打印机文件格式颜色文件大小输出结果10000pass20011fail31012fail41110pass51101pass60102fail70200fail80211pass91212pass假设每条测试用例运行时只有两个结果:通过或失败,假设一个运行失败的测试用例至少包含一个交互错误,否则就运行通过,并且假设若一个交互是错误的,则所有包含此交互的测试用例运行都是失败的.运行表1中的测试用例,得到输出结果列在表末,对于那些失败的测试用例,到底是哪个取值组合出了问题?为此,必须对覆盖表做新的研究,最好在测试完之后就能知道哪些是错误交互,这在没有额外的假设下很难做到,为此Colbourn和McClary[20]提出了错误定位表及错误侦测表的概念,后来Martínez等人[21-22]在此基础上提出了错误定位表的概念(ELAs).他们提出的错误定位模型是把待测系统(SUT)中的错误交互看成超图的边,从而构成一个错误交互超图来进行定位.为了简化起见,这里采用交互集合的语言来介绍错误定位表模型.假设某个s维交互导致错误,则所有包含这个s维交互的其它交互也会导致错误,为此只记录极小的错误交互,即其任何的真子集都不再是错误交互.设某个待测系统(SUT)有d个极小错误交互,用Π表示所有的极小错误交互构成的集合,则Π中错误交互都不可能互相包含.如果Π中每个错误交互都有t个元素,则记为Πt,如果每个错误交互至多有t个元素,记为Πt-.以后若不特别说明,错误交互集都是指极小的错误交互集.如果一条测试用例没有覆盖Π中任何错误交互,则称这条测试用例避开了Π.定义5.给定t维交互I与错误交互集Πt,如果存在覆盖这个交互I的一条测试用例T避开了Πt\{I},则称这个t维交互I关于Πt是可定位的,并称此测试用例T定位了交互I.如果每个t维交互关于Πt都是可定位的,则称Πt是可定位的.类似地,可以给出如下定义.定义6.给定s(st)维交互I与错误交互集Πt-,设I包含的Πt-中的极小错误交互集合为ΓI,如果存在覆盖这个交互I的一条测试用例T避开了Πt-\ΓI,则称这个s维交互I关于Πt-是可定位的,并Page4称此测试用例T定位了交互I.如果每个s(st)维交互关于Πt-都是可定位的,则称Πt-是可定位的.由定义5与定义6知,组合测试方法只能定位可定位的错误交互集Π,如一个待测系统(SUT)中有3个因素,每个因素取值都是二元的,如图1所示,类型1中交互集{{(2,0),(3,1)}{(2,1},(3,1)}}就是不可定位的,因为交互{(1,0),(3,1)}不可定位;类型2中交互集{{(2,0),(3,1)}{(2,1},(3,1)}}也是不可定位的,因为交互{(1,0),(3,1)}不可定位.对于错误交互集Π是否可定位,判断起来比较复杂,如果对于任意一个因素i,都至少存在一个顶点(i,si),错误交互集Π没有覆盖这个顶点,则错误交互集Π是可定位的.定义7[22].如果一个待测系统(SUT)中的错误交互集为Π,且对i∈[1,k],都存在顶点(i,si),使得(i,si)没有被包含在任何交互I∈Π中,则这个待测系统(SUT)具有安全值,并称(s1,s2,…,sk)为这个待测系统的安全值向量.所以如果一个待测系统(SUT)具有安全值向量,则其错误交互集Πt-是t-维可定位的[22].对于可定位的错误交互集Π,定义错误定位表如下.定义8[22].设待测系统(SUT)中,其错误交互集Πt是可定位的,一个n×k表A,其第i列元素取自[0,vi-1](i=1,2,…,k),且满足:每个t维交互I都能被A的某一行对应的测试用例所定位,则称A是强度为t的错误定位表,记为ELA(n;t,(v1,v2,…,vk)).当定义中的v1=v2=…=vk=v时,我们简记为ELA(n;t,k,v).定义9[22].设待测系统(SUT)中,其错误交互集Πt-是可定位的,一个n×k表A,其第i列元素取自[0,vi-1](i=1,2,…,k),且满足:每个s(st)维交互I都能被A的某一行所对应的测试用例所定位,则称A是强度至多为t的错误定位表,记为ELA(n;t-,(v1,v2,…,vk)).当定义中的v1=v2=…=vk=v时,我们简记为ELA(n;t-,k,v).显然,每个错误定位表ELA(n;t,(v1,v2,…,vk))(ELA(n;t-,(v1,v2,…,vk)))都是MCA(n;t,k,(v1,v2,…,vk)).在文献[22]中,Martínez等人表明,当Π中错误交互数是k的高阶无穷小时,绝大多数待测系统(SUT)都有安全值.利用错误定位表ELA(n;t-,(v1,v2,…,vk)),我们很容易确定错误交互集Πt-.运行错误定位表所形成的测试用例集,对所有通过的测试用例其包含的所有的交互都是正确的,只需从所有的s(st)维交互形成的集合中划去包含在某个通过的测试用例中的那些交互,剩下的就是所寻找的错误交互集,再对这个集合中划去所有的非极小错误交互,剩下就是所求的Πt-.盖表.定义10[23].设待测系统(SUT)中,交互集Π是可定位的,一个n×k表A,其第i列元素取自[0,vi-1](i=1,2,…k),且满足:与错误定位表概念类似的一个概念是禁忌覆(1)A的每一行所对应的测试用例避开了Π;(2)每个不包含Π中交互的t维交互都能被A的某一行所覆盖,则称A是强度为t的禁忌覆盖表,记为CAFE(n;t,(v1,v2,…,vk),Π),Π中的边称为禁忌边.当定义中的v1=v2=…=vk=v时,我们简记为CAFE(n;t,k,v).前面打印机系统的例子中,假设系统中错误交互如图2所示.我们可以根据这个错误交互集Π构造ELA(12;2,(2,3,2,3)),如表2所示.测试用例打印机文件格式颜色文件大小输出结果10110fail21010fail31200fail40000pass50001pass61002pass71100pass81111pass91102pass101210pass110211pass120212passPage5在ELA(12;2,(2,3,2,3))表中可以看到每个错误交互都出现在不同行,每个非错误交互都出现在一个运行通过的测试用例中.在表2中覆盖表不是一个错误定位表,因为交互{(1,1),(2,0)}不能被表中任何行所定位.对于可定位的错误交互集,错误定位表规模有多大?Martínez等人用更高强度的覆盖表来构造错误定位表.假设待测系统(SUT)具有安全值向量,其错误交互集Πt-中错误交互数最多为d,则当t+dk时,每个MCA(n;t+d,(v1,v2,…,vk))都是ELA(n;t-,(v1,v2,…,vk));对于不具有安全值向量的待测系统,其错误交互集Πt-中错误交互数最多为d且是可定位的,则当t(d+1)k时,每个MCA(n;t(d+1),(v1,v2,…,vk))都是ELA(n;t-,(v1,v2,…,vk))[22].这样可以利用高维的覆盖表来构造错误定位表,根据覆盖表的规模就可知错误定位表的规模的上界.因为在固定强度t时,覆盖表的行数是关于因素数的对数增长的,所以错误定位表的行数也是关于因素数的对数增长的,即当待测系统具有安全值向量时,其错误交互集Πt-中错误交互数最多为d,则存在ELA(n;t-,(v1,v2,…,vk))满足n=O(d(v)dlogk);对于不具有安全值向量的待测系统,其错误交互集Πt-中错误交互数最多为d且可定位,则存在ELA(n;t-,(v1,v2,…,vk))满足n=O(d(vt)dlogk)[22].用高维覆盖表来构造错误定位表,其行数虽然关于因素数是对数增长的,但是关于错误数d却是指数增长的,这样当d比较大时,用这种方法构造的错误定位表来定位交互错误,测试用例存在了很大的冗余,尤其对于不具有安全值向量的待测系统,用MCA(n;t(d+1),(v1,v2,…,vk))来构造ELA(n;t-,(v1,v2,…,vk)),即使d很小时,行数的规模也太大.所以我们把这个结论改进为如下的定理.定理1.设待测系统(SUT)中,其错误交互集Πt-中错误交互数最多为d且是可定位的,设v=min{v1,v2,…,vk},d~=maxt时,每个MCA(n;t+d~,(v1,v2,…,vk))都是ELA(n;t-,(v1,v2,…,vk)).详细证明见附录.有了这个改进的定理,我们显然有以下推论.推论1.设待测系统(SUT)中,其错误交互集Πt-中错误交互数最多为d且是可定位的,且tv,则当t+dk时,每个MCA(n;t+d,k,v)都是ELA(n;t-,k,v).推论2.设待测系统(SUT)中,其错误交互集Π2-中错误交互数最多为d且是可定位的,且vi2(i=1,2,…k),则当2+dk时,每个MCA(n;2+d,(v1,v2,…,vk))都是ELA(n;2,(v1,v2,…,vk)).用定理1我们得到改进的定理2.定理2.设待测系统(SUT)中,其错误交互集Πt-中错误交互数最多为d且可定位,设v=min{v1,v2,…,vk},d~=max{td/v,d},则存在ELA(n;t-,(v1,v2,…,vk))满足n=O(d(v)d~logk).从推论2,定理2中我们知道,对于一般的待测系统,若已知错误交互最多是二维的,且错误交互数d很小时,用MCA(n;2+d,(v1,v2,…,vk))可定位出交互错误,且其行数规模不是太大.用错误定位表来定位交互错误,其优点是并行性,即所有的测试用例可同时执行,而其缺点是冗余的测试用例比较多,当每条测试用例执行时间很短且花费不高时可用此策略,否则我们可考虑自适应的策略.3具有已知安全值的待测系统的错误交互定位自适应算法在这一节,我们考虑当一个SUT具有安全值时定位交互错误的自适应算法.所谓自适应算法,就是根据前面选出的测试用例的执行结果来选取后面的测试用例.根据Martínez等人的结论,可用更高维的覆盖表来构造具有安全值的错误定位表,但是需要预先知道错误交互的个数d,并且表的行数n=O(d(v)dlogk),所以如果错误交互数太大时,覆盖表很难构造出来,因为覆盖表的行数是关于d指数增长的.Martínez等人对具有安全值SUT且错误交互集为Π2-的覆盖表提出了自适应算法,它不需要预先知道错误数,但要预先知道每个因素的安全值,并且所需的测试用例数是关于d多项式增长的,最坏情况下需要O(d(logk)2+d2logk)条测试用例[22].Martínez等人提出的自适应算法简述如下:假设一个带测系统(SUT)其安全值向量为狊=(s1,s2,…,sk),错误交互集为Π2-.他们先用贪心密度算法建立一个MCA(n;2,(v1,v2,…,vk))A[7],然后对表中的每一行所对应的测试用例T执行测试,用过程TEST(T)表示,其运行结果为通过或失败,Page6若通过,则这个测试用例所包含的所有1维2维交互都是正确的,对于失败的测试用例,调用一个过程LocateErrorInTest((s1,s2,…,sk),T,A=[1,k])来确定被测试用例T所覆盖的错误交互.过程LocateErrorInTest(s,T,A)是递归调用的,每次调用时都假设T是失败的测试用例,过程输出的是测试用例集T所覆盖的因素在集合A中的错误交互集合,初始化A=[1,k],然后把A划分成近似相等的两个集合A,A,设Ti=Ti,i∈ATi=Ti,i∈Asi,i烅烄烆A,则递归调用过程LocateError-InTest(s,T,A)和LocateErrorInTest(s,T,A)分别得到E和E,再调用过程AcrossLocate(s,T,A,A,E,E),这个过程输出一个因素在A中,另一个因素在A中的错误交互构成的集合,得到E,则LocateErrorInTest(s,T,A)过程返回Π2-=E∪E∪E.具体算法参见文献[22]中的算法2.对于一般的错误交互集Πt-,如果t>2时,则上述的算法很难推广,因为当把集合A划分成几个近似相等的集合时,因素在各个集合之间的错误交互很难处理,所以对于一般的安全值已知的待测系统,Martínez等人没有解决,而是作为开问题提出来,这一节我们主要解决这个问题.设一个待测系统(SUT)具有安全值向量,其安全值向量仍设为狊=(s1,s2,…,sk),其错误交互集Πt-是可定位的,我们先用贪心密度算法建立一个MCA(n;t,(v1,v2,…,vk))A[8],然后对表中的每一行所对应的测试用例T执行测试,用过程TEST(T)表示,其运行结果通过或失败,对失败的测试用例,我们调用过程LocateErrorInTest(s,T,t)来得到测试用例T中所覆盖的错误交互集.我们的算法工作如下:先初始化集合A=[1,k]\{i|Ti=si},然后把集合A划分成近似相等的t+1个集合A1,A2,…,At+1,使得A=∪t+1t+1),则在A\Ai,i=1,2,…,t+1这t+1个集合中,至少有一个集合,包含有错误交互的因素集,把它赋值给A,进入下一个循环,直到|A|t,我们就调用辅助过程LocateAux(s,T,A),这个辅助过程确定因素在A中的强度小于等于t的所有错误交互.然后我们把A对应因素的取值重新取成安全值来更新测试用例T,再重复以上过程,这样得到一个错误交互集Π,且T中再不会覆盖与Π中所有错误交互都不相交的错误交互,然后再执行一个LocateAcrossError(s,T,Π)过程,这个过程主要确定被测试用例T覆盖且与前面得到的错误交互相交的其它错误交互.设集合B是Π中所有错误交互所对应的因素集的并,即设Π={I1,I2,…,Il},第i个交互Ii={(i1,Ti1),(i2,Ti2),…,(is,Tis)}对应的因素集合为fIi={i1,i2,…,is},则集合B=∪li=1fIi,设B={l1,l2,…,ly}.为了找出所有的不属于Π且与Π中错误交互有交集的错误交互,我们构造一个行数尽可能少的带有禁忌边的部分禁忌覆盖表PCAFE(m;t,y,2,Γ)P,这是一个二元的部分禁忌覆盖表,其中Γ={{(y1,1),(y2,1),…,(ys,1)}|{(ly1,Tly1),(ly2,Tly2),…,(lys,Tlys)}∈Π,st}表示禁忌边集合,则此覆盖表的每一行都避开了Γ,且不属于Γ的任何交互{(y1,1),(y2,1),…,(yt,1)}都被P的某一行所覆盖.这个表是存在的,因为对任何一个不属于Γ的t维交互{(y1,1),(y2,1),…,(yt,1)},其对应的被T覆盖的t维交互{(ly1,Tly1),(ly2,Tly2),…,(lyt,Tlyt)}不包含Π中的任何交互,一定存在一个每个yi位取值为1,其余取值为0的y维二元向量覆盖它.然后根据这个覆盖表的每一行来构造一个测试用例T,如果此行第yi列取值为1,此列所对应的B中的因素是lyi,则测试用例T中的第lyi个因素取值为Tlyi,否则T中的第lyi个因素取值都为slyi.由于每一行都避开了Γ,即对任意的{(ly1,Tly1),(ly2,Tly2),…,(lys,Tlys)}∈Π,测试用例T没有覆盖这个前面已寻找出来的错误交互,另外对任意不属于Γ的{(y1,1),(y2,1),…,(yt,1)},都存在某一行覆盖它,即对任意不包含Π中的任何交互的交互{(ly1,Tly1),(ly2,Tly2),…,(lyt,Tlyt)},都存在某个如上构造的测试用例T覆盖它,也就是说,任意的与Π中某个错误交互有交集的都能被某一行所覆盖.然后再递归调用过程,则可得到与Π中某个错误交互有交集的错误交互.具体算法如下.算法1.定位交互错误的自适应算法.输入:因素数目k及因素取值向量(v1,v2,…,vk),交互输出:至多t维的错误交互集Πt-begin用贪心密度算法生成混合覆盖表MCA(n;t,初始化Πt-=,Page7returnΠt-endprocedureLocateErrorInTest(s,T,t)beginΠ=BasicLocateErrorInTest(s,T,t)endprocedureBasicLocateErrorInTest(s,T,t)begin初始化错误交互集Π=endprocedureLocateAux(s,T,A)//测试因素是A的子集的所有交互是否是错误交互beginendprocedureLocateAcrossError(s,T,Π)begin设Π={I1,I2,…,Il}Γ={{(y1,1),(y2,1),…,(ys,1)}|Page8returnΠend对算法1作如下几点说明:(1)在算法1中,对于构造部分带禁忌边的覆盖表,可以用带约束的集成SAT的AETG工具来构造[24],一般在每一行中错误交互数较少,所以也可用贪心算法等其它方法构造.(2)对于每次侦测到一个故障就调试使得错误消失的测试模型,则只需扫描覆盖表A的每一行,对出现fail的行调用基本的过程BasicLocateError-InTest(s,T,t)找出一个触发故障的错误交互就可以了.并且这种调试模型可用Δ-调试方法来调试[17].(3)若运行失败的测试用例T中有维数大于t的错误交互,算法1可能不能找出所有的维数小于等于t的错误交互,但对于维数大于t的错误交互,可在某次调用过程BasicLocateErrorInTest(s,T,t)时侦测出来,在运行到while循环时,若在某次循环时,TEST(T)=fail,然后把集合A=[1,k]\{i|Ti=si}划分成t+1个近似相等的集合A1,A2,…,At+1,若在A\Ai,i=1,2,…,t+1这t+1个集合中,没有任何一个集合包含有错误交互的因素集,则T中含有维数大于t的错误交互.若要准确地定位出这个交互,则需要提高覆盖的维数t,再来运行算法1.我们分析算法1所需调用测试TEST()的次数来度量算法1的性能,得到以下定理.定理3.设待测系统中错误交互集Πt-的错误交互数|Πt-|=d,则算法1调用TEST()的次数为O(dt+1logk+d(logk)2).详细证明见附录.注.由定理3,我们知道算法1调用TEST()的次数是关于错误交互数d多项式增长的,关于t是指数增长的,如果t比较大,需要调用附加的测试用例数有可能比较多,但Kuhn等人[3]的研究表明一般的待测系统的错误交互的维数小于等于6,所以当d不大时,或运行失败的测试用例中包含的错误交互数不大时,算法1调用TEST()的次数并不多.4结论和未来的工作在这篇文章中我们推广了Martínez等人[22]用高维覆盖表来构造错误定位表的方法,改进了Martínez等人[22]提出的在组合测试中怎样定位至多t维的交互错误的自适应算法,解决了Martínez等人[22]留下的开问题之一,即安全值已知的待测系统中,构造了自适应算法来定位错误交互集Πt-的错误交互,对于另一个开问题,即一般待测系统的错误定位仍然没有解决.所以我们未来的工作一方面研究对一般待测系统的错误定位构造自适应算法,对具有安全值但安全值未知时构造算法来计算安全值向量;另一方面,对安全值已知的待测系统,我们研究生成测试用例的非自适应算法,即构造错误定位表来定位错误.虽然自适应算法调用TEST()次数一般比非自适应算法调用的次数少很多,但是错误定位的自适应算法执行时并行程度不够.研究针对安全值已知的待测系统构造的错误定位表与组群测试(grouptesting)里的池设计(poolingdesign)之间的关系[25-26].研究直接构造错误定位表ELA的非自适应算法或者对具有安全值但安全值未知的待测系统构造多阶段的非自适应算法.
