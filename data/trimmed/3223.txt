Page1基于Nearest-Biclusters协作过滤技术的效用图结构学习算法王黎明1)李琨1),2)1)(郑州大学信息工程学院郑州450001)2)(河南职工医学院郑州451191)摘要在多议题协商研究中,议题之间的依赖关系增加了协商Agent效用函数的复杂性,从而使得多议题协商变得更加困难.基于效用图的多议题依赖协商模型是体现议题间依赖关系的多议题协商模型.在该协商模型中,协商双方仅需要较少的协商步数就能够找到满足Pareto效率的协商结局.如何有效地学习买方Agent的效用图结构是该协商模型的关键.文中基于Nearest-Biclusters协作过滤技术的思想提出了一种新的效用图结构学习算法(NBCFL算法).该算法首先利用Nearest-Biclusters协作过滤技术发现买方偏好的局部匹配特性,提取与当前买方Agent类型相同的买方Agent所产生的协商历史记录,然后通过计算各议题间的依赖度学习买方Agent的效用图结构.实验表明在参与协商的买方Agent类型不同的条件下,NBCFL算法比IBCFL算法能更好地学习买方Agent的效用图结构.关键词效用图;多议题协商;协作过滤;双向聚类1引言多议题协商是多Agent系统研究的热点之一.目前关于多议题协商问题有大量的研究[1-5],其中大部分研究工作都假定协商议题之间相互独立[1-3].文献[3-5]是我们的前期工作,在此基础上,本文进一步考虑议题之间的依赖性,这种依赖性增加了多议题协商问题的复杂性.Klein等人[6]首次将多议题依赖引入到多议题协商模型中,协商Agent使用模拟退火和爬山搜索方法搜索Pareto最优解;Takayuki等人[7-8]利用带有约束的效用函数表示协商Agent的非线性偏好(即议题间存在依赖关系),提出了基于拍卖的多议题依赖协商模型;Lai等人[9]在协商Agent具有非线性偏好的条件下,利用基于协商基线的协商协议对多议题协商模型进行了研究;Somefun等人[10]利用超立方体结构类型的效用函数表示买方Agent的非线性偏好,并以绑定(bund-ling)销售模型为基础对多议题依赖协商问题进行了研究;Robu等人[11-12]提出了一种基于效用图的多议题依赖协商模型,该模型采用效用图表示买方Agent非线性偏好,并利用图形结构特点大大降低了多议题依赖协商问题的复杂性.文献[12]中的实验表明,随着效用图结构学习准确率的增加,完成协商所需要的协商步随之减少,而协商结局满足Pareto最优的比率随之增加.因此,能否正确学习效用图的结构是该协商模型中需要解决的一个关键问题.协作过滤技术[12]的主要思想是利用协商历史数据发现买方的偏好并为买方提供购买建议.然而这种建议机制是静态的,买方对该建议仅能够接受、拒绝或者坚持己见.在协商框架内,该建议机制可以被协商过程所取代,增强了灵活性.Robu等人[12]基于项目协作过滤技术的思想,提出了效用图结构学习算法(IBCFL算法).当买方Agent类型相同时,该算法能够得到较好的学习效果.因为IBCFL算法是利用整个协商历史数据求解议题之间依赖度的,所以当买方Agent类型不同时,该算法不能有效地学习效用图结构.在买方Agent类型不同的条件下,本文对基于效用图的多议题依赖协商模型进行了研究,并借鉴Nearest-Biclusters协作过滤技术[13]的思想提出了效用图结构学习算法(NBCFL算法),且通过实验验证了算法的可行性与有效性.2相关定义定义1(协商Agent集合).Σ=ΣB+ΣS是协商Agent的集合,其中ΣB={B1,…,Bp}为买方Agent集合,p为买方Agent的个数;ΣS={S1,…,Sq}为卖方Agent集合,q为卖方Agent的个数.定义2(议题集合及其值向量).I={I1,I2,…,In}表示协商议题集合,其中n表示协商议题的个数.狓=(x1,…,xn)表示关于议题集合I的一个值向量,其中Ii∈I(1in),xi∈Xi表示议题Ii的一个取值,Xi表示议题Ii取值的值域.定义3(一般联加独立效用函数)[14].设Dom(I)=∏n合C={C1,…,Cr}是集合I的r个子集组成的集合且∪ri=1Ci=I,i,1ir,设Dom(Ci)=∏j∈Ciu(·)是关于Dom(Ci)的一般联加独立效用函数,当且仅当存在子效用ui:Dom(Ci)→使得狓∈Dom(I),u(狓)=∑r示议题簇Ci关于值向量狓构成的子值向量.定义3中的每一个议题簇Ci中包含的议题表示这些议题间存在依赖关系,而子效用ui则反映了这些议题间的依赖度.当Ci=1(1ir)时,子效用值ui表明购买一个商品时对该商品的评估值;当Ci>1时,子效用值ui表明购买两个或两个以上商品的联合效用值,如果联合效用值为正,则表示这些商品之间存在互补性,否则存在可替代性.定义4(效用图).设Dom(I)=∏n集合C={C1,…,Cr}是集合I的r个子集组成的集合且∪ri=1Ci=I.设狓∈Dom(I),则表示效用u(狓)=∑rui(狓Ci)的效用图是一个无向图G=(I,F),当且i=1仅当满足(1)I={I1,…,In}是无向图G的点集;(2)(Ii,Ij)∈F,CsC(1sr),使得Ii,Ij∈Cs.(3)CsC(1sr),效用u(·)中的各子效用us与之关联.例1.设I={I1,I2,I3,I4},议题簇集合C={{I1},{I1,I2},{I2,I3},{I2,I4},{I3,I4}}.设C2,Page3C4对应的子效用u2,u4取值(即议题间依赖度)为正,C3,C5对应的子效用u3,u5取值为负,则效用图如图1所示.图1效用图(+表示互补性,-表示可替代性)定义5(买方Agent类型集合).CA={C1,…,Ct}表示买方Agent类型的集合,其中t为买方Agent类型的个数;Ci={Ci1,…,Cir}(1it)为第i类买方Agent的议题簇集合,即第i类买方Agent认为各个议题间存在的依赖关系,r为议题簇的个数.定义6(买方Agent类型相同).买方Agent类型集合CA={C1,…,Ct}包含的t类买方Agent类型是相同的,当且仅当满足C1=C2=…=Ct.定义7(买方Agent类型不同).买方Agent类型集合CA={C1,…,Ct}包含的t类买方Agent类型是不同的,当且仅当满足Ci∩Cj=,其中,1it,1jt且i≠j.定义8(协商历史矩阵).协作过滤算法中的m行n列User-Item矩阵犈定义为协商历史数据矩阵.设U={U1,…,Um}是矩阵犈的行集合(也叫用户集合),其中Ui是买方i产生的协商历史记录;I={I1,…,In}是矩阵犈的列集合(也叫议题集合),其中Ij是第j个议题.矩阵犈是一个二值矩阵,矩阵中的元素eij=1表明买方Bi购买了议题Ij,否则表示未购买议题Ij.定义9(双向簇).一个双向簇(bicluster).A=(Ub,Ib)∈2{1,…,m}×2{1,…,n},其中用户子集Ub={U1,…,Up}是矩阵犈行集合的子集(UbU且pm),议题子集Ib={I1,…,Iq}是矩阵犈列集合的子集(IbI且qn).一个双向簇A是矩阵犈的p行q列子矩阵.定义10(包含最大)[15].双向簇A=(Ub,Ib)是包含最大(inclusion-maximal)的双向簇,当且仅当①Ui∈Ub,Ij∈Ib:eij=1且②(Ub,Ib)∈2{1,…,m}×2{1,…,n},其中(a)Ur∈Ub,Is∈Ib:er,s=1且(b)UbUb∧IbIb∧(Ub,Ib)≠(Ub,Ib).定义11(Like集合).Like={L1,…,Lr}是关于协商历史矩阵犈的所有包含最大的双向簇集合,其中Li=(Ui,Ii)∈Like(1ir)都是包含最大的双向簇.定义12(Dislike集合).设矩阵珚犈为协商历史矩阵犈的反值矩阵.Dislike={D1,…,Ds}是关于反值矩阵珚犈的所有包含最大的双向簇集合,其中Dj=(Uj,Ij)∈Dislike(1js)都是包含最大的双向簇.3基于效用图的多议题依赖协商模型3.1协商模型的形式定义基于效用图的多议题依赖协商模型可以定义为一个7元组UGDNM=〈Σ,I,X,CA,P,U,Pro〉,其中(1)Σ=ΣB+ΣS是协商Agent的集合.在一次完整的协商线程中,本文仅考虑一对一的协商,并简记某一买方Agent为买方B,某一卖方Agent为卖方S.(2)I={I1,…,In}为协商议题(商品)集合,其中包含有n个议题.(3)X={X1,…,Xn}是各议题值域集合.Xi∈X(1in),Xi={0,1}.即当xi取值为1时,表示购买议题Ii;反之,表示未购买Ii.(4)CA={C1,…,Ct}表示买方Agent类型集合,其中t为买方Agent类型的个数,Ck={Ck1,…,Ckr}(1kt,r=Ck)为第k类买方Agent的议题簇集合.本文在买方Agent类型不同的条件下进行研究,即Ci∩Cj=,其中,1it,1jt且i≠j.(5)P是所有值向量对应的标价构成的集合.(6)U={UB,US}是协商Agent效用函数组成的集合.设协商Agent采用拟线性效用函数[11],即UB(狓,pB)=VB(狓)-pB(狓),US(狓,pS)=pS(狓)-VS(狓).设当前参与协商的买方B属于第k类,且评价函数VB是一般联加独立效用函数,即VB(狓)=∑Ckui(狓Ck是联加函数,即VS(狓)=∑n是每个议题Ii的成本,n为议题的个数.pB,pS∈P分别是买方B和卖方S对值向量狓提出的标价.(7)Pro表示协商协议,UGDNM采用轮流提议(alternating-offer)协商协议.3.2交互过程在UGDNM的每一步协商中,协商双方都会产i=1Page4生一个提议(记为O=(狓,p)),其中p是值向量狓对应的标价.交互过程可以分为以下两个阶段:(a)从集合CA中随机选择某一议题簇集合Ck并产生相应的买方B(即买方B属于第k类买方Agent).买方B根据自身的效用图结构及子效用值计算第一个提议(记为Of=(狓f,pf)),并发送给卖方S.卖方S根据狓f的内容提取第k类买方Agent所产生的协商历史数据,利用协商历史数据计算各个议题之间的依赖度,根据各议题间的依赖度学习效用图结构,并为该效用图分配初始的子效用值.(b)卖方S利用买方B每一次所发送的提议更图2交互过程4基于Nearest-Biclusters协作过滤技术的效用图结构学习算法(NBCFL)本文仅考虑所有议题簇中包含议题个数为2的情况,而关于议题簇中包含更多议题的情况,将在以后的工作中进行研究.因为类型相同的买方Agent对某些议题簇具有相似的偏好(偏好的局部匹配),而对于类型不同的买方Agent来说,他们的效用图结构不同,局部偏好也就不相似.所以,当买方Agent属于不同类新子效用的取值,并向买方B提出使得利润(GainsfromTrade,GT)最大的反向提议.买方B对卖方S提出的反向提议进行评估并做出相应的让步,再次发送一个提议给卖方S,循环反复直至协商结束.在协商过程中,卖方S不知道买方B的评价函数VB的各子效用取值,而只是利用一个Sigmoid学习函数[11]评估各子效用值.在协商的每一步都使用2%的中止协商风险率模拟时间约束.交互过程如图2所示,其中阶段(b)的过程与文献[11]中描述的内容相同,本文主要针对阶段(a)的工作进行研究,即利用协商历史数据学习效用图结构.型时,利用整个用户集合不能够准确地发现议题间的依赖关系.本文利用Nearest-Biclusters协作过滤技术能够发现买方偏好局部匹配的特性,提出了卖方Agent学习买方Agent效用图结构的NBCFL算法.NBCFL算法针对当前参与协商的买方Agent,提取与其类型相同的所有买方Agent产生的协商历史数据,然后通过计算议题之间的依赖度学习该类买方Agent的效用图结构.NBCFL算法分为3个阶段:(1)协商历史数据预处理;(2)求解Nearest-Biclusters;(3)学习效用图结构.Page54.1协商历史数据预处理此阶段采用一种双向聚类算法———Bimax算法[15],对协商历史数据进行预处理.Bimax算法是一种基于分治法的双向聚类算法,该算法能够在二值数据矩阵中较快地(最差情况下的时间复杂度为O(mnβmin{m,n}),其中β是矩阵犈中所有包含最大的双向簇的数量,m、n分别表示矩阵犈的行数和列数)找到所有包含最大的双向簇.为了使讨论更加简单,通过一个例子来说明Bimax算法.例2.Bimax算法在运行时需要设定一些参数,即设定每个双向簇的最小议题数和最小用户数.该例将两个参数都设为2(即Ib2和Ub2),则对协商历史矩阵犈(如图3(a)所示)应用Bimax算法可以发现3个双向簇(如图3(b)所示):b1:Ub1={U1,U2},Ib1={I1,I6};b2:Ub2={U1,U5},Ib2={I3,I5,I6};b3:Ub3={U4,U5,U6},Ib3={I2,I5}.两个双向簇可能会重叠,即矩阵犈中的某些用户或议题可能存在于多个双向簇中.例如,b1、b2中关于议题I6重叠,b2、b3关于议题I5重叠.为了不遗漏重要的双向簇,则本文允许重叠的发生,在实验中设定每个双向簇的最小议题数和最小用户数都为1.由于Nearest-Biclusters协作过滤技术[13]中讨论的是买方Agent最可能购买的议题,而UGDNM中议题之间存在着互补性和可替代性的关系,因此本文不仅要考虑买方Agent期望购买的议题,还要考虑他们不愿购买的议题.对于一个二值数据矩阵来说,一个双向簇是矩阵中所有等于1的元素构成的子矩阵,所以对协商历史矩阵犈的预处理需要做以下两步工作:(1)利用Bimax算法对协商历史矩阵犈中的记录进行分类,将得到的每一个双向簇Li=(Ui,Ii)合并到Like集合中.(2)求协商历史矩阵犈的反值矩阵珚犈.再次利用Bimax算法对数据进行分类,将得到的每一个双向簇Dj=(Uj,Ij)合并到Dislike集合中.4.2求解Nearest-Biclusters为了学习买方B的效用图结构,要将第k类买方Agent所产生的协商历史数据分离出来.因为买方B提出的值向量狓f(或反值向量狓-度地反映它的偏好,所以通过计算Like集合(或Dislike集合)中的双向簇与值向量狓f(或反值向量f)之间的相似度,找到第k类买方Agent所产生狓-的协商历史数据.为减少Bimax算法中参数设置对相似度计算的影响,本文提出了一种新的相似度计算方法,即值向量狓与双向簇bc的相似度等于值向量狓与双向簇bc中共有议题的数量除以二者所含议题数的最大值.其中,I狓是买方B提出的值向量狓中期望购买的议题集合,Ibc是双向簇中包含的议题组成的集合,式(1)的值域是[0,1].式(1)表明相似度越高,双向簇中用户子集包含的协商历史数据是由第k类买方Agent所产生的可能性就越大;反之,则可能性就越小.算法1.寻找最近双向簇.NearestBiclusters(Q,N,狓)输入:双向簇集合Q(Like集合或Dislike集合),阈值输出:行号集合M说明:n是协商议题的个数,nM是集合Q中的双向簇1.ForeachLsQDo//0snM,其中Ls=(Us,Is)2.ForeachIi∈IDo3.IfIi∈Isandxi=1ThencI←cI+1;Endif4.IfIi∈IsThennB←nB+1;Endif5.Ifxi=1Thennb←nb+1;Endif6.Endfor7.SIM[s]←cI/max(nB,nb);8.Endfor9.S←Sort(S,SIM);//根据相似度值将集合S中Page610.ForeachLsSandcount<NDo11.M←Us;12.Ifsim(狓,Ls)≠sim(狓,Ls+1)Thencount++;13.Endfor14.Return(M).因为值向量狓f受买方B所属类型及子效用值的影响,且相似度受到值向量狓f的影响,所以选择相似度大于某一阈值的双向簇作为近邻并不合适.因此,算法1对于某一双向簇集合Q,选择前N个相似度所对应的双向簇作为买方B的近邻,并收集这些近邻中包含的用户子集作为提取协商历史记录的依据.算法2.提取协商历史记录.ExactHistory(犈,Like,Dislike,Nl,Nd,狓f,狓-输入:协商历史矩阵犈,Like集合,Dislike集合,阈值输出:协商历史矩阵犈说明:Ml,Md,M是行号集合;SelectRecord函数的功1.Ml←NearestBicluster(Like,Nl,狓f);2.Md←NearestBicluster(Dislike,Nd,狓-3.M←Ml∪Md;//将Ml,Md合并为M;4.ForeachUi∈MDo5.犈←SelectRecord(犈,Ui);6.Endfor7.Return(犈).算法2的目的是利用得到的近邻中包含的用户子集,从矩阵犈中提取相应的协商历史记录,合并为一个新的协商历史矩阵犈,并将其作为下一阶段工作的数据集.4.3学习效用图结构经过第2个阶段的工作,得到了一个新的协商历史矩阵犈.矩阵犈包含了大量的第k类买方Agent所产生的协商历史记录.因为基于关联相似度学习效用图结构的准确率比基于Cosine相似度学习的准确率高[12],所以本文利用基于关联的相似度计算各个议题之间的依赖度.因为基于关联相似度是由基于Pearson关联系数(Pearson-Correlationcoefficient)演变而来的,而对于二值数据可以将Pearson关联系数转化为-coefficient[16].犆狅狉(i,j)=Ni,j(1,1)×Ni,j(0,0)-Ni,j(0,1)×Ni,j(1,0)其中Ni,j(1,1),Ni,j(1,0),Ni,j(0,1),Ni,j(0,0)是议题i,j取值为0或1时协商记录的个数;Ni(1),Ni(0),Nj(1),Nj(0)分别是议题i或j取值为1或0时协商记录的个数;式(2)的值域是[-1,1].式(2)反映了议题之间的正负关联关系,即依赖度.值越接近于1表明两个议题越可能具有较强的互补性,而值越接近于-1表明两个议题越可能具有较强可替代性.在理想的情况下,所有存在依赖关系的议题在关联矩阵中的值应该是最大的或最小的.但是受噪声数据的影响,可能会得到一些额外的依赖关系.当然,即使不能够得到100%的效用图结构,在交互过程的阶段(b)(如图2所示),卖方Agent仍然可以通过买方Agent发送的提议来更新子效用值的评估值,从而使协商双方在有限的协商步内找到满足Pareto效率的协商结局.对于卖方Agent来说需要解决的问题是:在卖方Agent不知道买方Agent效用图中实际存在几条依赖边的情况下,应该取多少条依赖边?一种可能的解决方法是假定效用图中依赖边的个数是图中议题个数的线性函数[12],即假定效用图中依赖边的个数不会超过kmax×n(kmax是一个较小的正数,n是协商议题的个数).在本文的实验中,假定效用图中依赖边的个数不超过1.5×n(kmax=1.5).算法3.NBCFL算法.NBCFL(犈,珚犈,狓f,狓-输入:协商历史矩阵犈,反值矩阵珚犈,值向量狓f,反值向Dislike集合.输出:效用图G1.对矩阵犈和珚犈调用Bimax算法,得到Like集合和2.调用ExactHistory(Like,Nl,狓f,Dislike,Nd,狓-得到新的协商历史矩阵犈.3.对于每一个议题对偶,根据式(2)在矩阵犈上计算各个议题间的依赖度,并得到一个n×n的关联矩阵犆狅狉.4.从关联矩阵犆狅狉中,分别选择p和q条(其中p+qkmax×n)依赖度取值最大和最小的依赖边,根据选择的依赖边生成效用图G.算法3的第4步中的p和q条依赖度取值最大和最小的依赖边分别表示议题间存在互补性和可替代性的个数.本文实验中效用图中包含的互补性和可替代性依赖关系的数量比为2,即p/q=2.5实验及分析实验中协商议题个数为10,随机产生3种类型的买方Agent.每一类买方Agent的效用图结构随Page7机选取15条依赖边,其中10条具有互补性,5条具有可替代性.买方Agent对单个议题的评估值及联合效用值随机产生,并且满足正态分布N(1,0.5).本文采用文献[11-12]的方法收集买方Agent发送的值向量狓f或协商结局作为协商历史数据.实验结果取30次不同测试结果的平均值.为了保证这30次测试结果尽可能独立,对于每一次测试都重新生成新的协商历史矩阵,其中对每次测试都等概率地从3类买方Agent中选择某一买方Agent类型,并随机生成该类型的150个买方Agent.对每一个买方Agent提出的值向量狓f进行检验,取这150个检验结果的平均值作为一次测试结果.5.1阈值选择对划分正确率的影响第1组实验(协商历史矩阵犈包含1500条记录)测试阈值选择对划分正确率的影响.划分正确率,即对于买方B来说,提取的协商历史矩阵犈中由第k类买方Agent所产生的协商历史的数量与矩阵犈中所有历史记录数量的比值.如图4所示,图中横坐标表示阈值Nl(或Nd)的取值,纵坐标表示划分正确率.圆形标示的曲线表示阈值Nl对划分正确率的影响,三角形标示的曲线表示阈值Nd对划分正确率的影响.由图4可知,随着阈值Nl(或Nd)的增加,所选择的近邻数越来越多,划分正确率越来越低.当阈值大于16时,提取的协商历史矩阵犈与原协商历史矩阵犈基本相同(即犈=犈),因此划分正确率为33.3%.当阈值为1时,划分正确率最大.5.2阈值选择对效用图结构学习的影响第2组实验(协商历史数据包含1500条记录)测试阈值选择对效用图结构学习的影响.为了说明算法的有效性,本文采用正确学习到的依赖边个数与买方Agent效用图实际依赖边个数的比率作为评估标准,即效用图结构学习的准确率.如图5所示,横坐标表示阈值Nl或Nd的取值,纵坐标表示效用图结构学习的准确率.由于NBCFL算法需要同时设定Like集合和Dislike集合所选近邻的阈值Nl和Nd,为尽可能地减少两个阈值设定对测试结果的影响,在测试阈值Nl对学习效果的影响时,设阈值Nd=1;同理,在测试阈值Nd对学习效果的影响时,设阈值Nl=1.由图5可知,阈值Nl的设定对效用图结构学习准确率的影响最大且当阈值Nl=2和Nd=2时能够获得较高的准确率.图5近邻选择对效用图结构学习准确率的影响5.3协商历史矩阵规模对NBCFL算法和IBCFL算法的影响最后,第3组实验(阈值Nl=2和Nd=2)比较分析了当买方Agent属于不同类型时协商历史矩阵的规模对NBCFL算法与IBCFL算法性能的影响.实验分别对不同规模(m=300,600,900,1200,1500,2700)的协商历史矩阵进行测试.由图6可知,在买方属于不同类型的条件下,使用NBCFL算法比IBCFL算法能够更加有效地学习效用图的结构.随着协商历史数据数量的增加,NBCFL算法学习效用图结构的准确率也随之提高.由于效用图的结构及子效用值都是随机生成的,所以不同类型的买方Agent可能会提出相同值向量狓f,以至于对划分正确率和效用图结构学习的准确率造成负面影响.Page8通过实验可知,效用图结构学习的准确率受到划分正确率、近邻的选择及协商历史数量等因素的影响.由图4、图5可知,虽然当阈值为1时,式(1)能够得到较高的划分正确率,但是此时所得到的协商历史矩阵犈中所包含的协商历史记录的数量比较少,而当阈值为2时,两方面的影响因素能够取得一个较好的平衡,因而可以得到较好的学习效果.6结论与下一步工作本文基于效用图的多议题依赖协商模型,在参与协商的买方Agent类型不同的条件下,对效用图结构学习的问题进行了深入的研究,并基于Nearest-Biclusters协作过滤技术的思想提出了卖方Agent学习买方Agent效用图结构的NBCFL算法.NBCFL算法针对当前参与协商的买方Agent,提取与其类型相同的所有买方Agent产生的协商历史数据,然后通过计算各议题间的依赖度学习该类买方Agent的效用图结构.实验表明在参与协商的买方Agent类型不同的条件下,NBCFL算法比IBCFL算法能更好地学习买方Agent的效用图结构.今后的工作将主要集中在进一步提高效用图结构学习的准确率以及在子簇内包含有更多议题情况下的依赖性研究.
