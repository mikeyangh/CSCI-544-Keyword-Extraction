Page1NoC中相邻虚通道循环共享的VOQ容错路由器设计梁华国2)1)(合肥工业大学计算机与信息学院合肥230009)2)(合肥工业大学电子科学与应用物理学院合肥230009)摘要集成电路的不断发展使得片上系统遇到了不可逾越的瓶颈问题,片上网络因其具有良好的可扩展性、较高的通信效率和可靠性等优势成为了一种新型的互连架构,被研究者们广泛研究.路由器是片上网络中的关键部件,主要负责数据包的存储转发,影响着网络的整体性能,故对路由器的容错设计显得尤为重要.而路由器中缓冲区所占的面积较大,且常见的缓冲区容错方案都可能会产生头阻塞问题,因此需要设计一种容错路由器架构,既可以解决头阻塞问题,又能实现缓冲区容错.该文提出一种相邻虚通道循环共享的VOQ容错路由器设计,可以有效地容忍虚通道故障,在网络拥塞时能最大程度的保证缓冲区的利用率,且在路由器内部虚通道均故障时依旧可以保证整个网络的连通性.在基准VOQ路由器的基础上,该文通过增加多个多路选择器和数据分配器来实现相邻虚通道的共享,增加旁路总线来保证即使输入端口内部虚通道均故障,路由器依旧可用.当数据包所要发往的虚通道故障或者拥塞时,通过借用相邻虚通道或旁路来实现数据包的存储转发,达到了容错的目的,提升网络性能.同时,该文设计了一种基于双向队列的FIFO控制器,通过两套读写指针实现对借用虚通道数据包和非借用虚通道数据包的读写操作.双向队列的设计,保证了数据包在输出时依旧持有VOQ特性,这是绝大多数的缓冲区容错方案所没有的.实验结果表明,在无故障发生时,该文方案较VOQ路由器和multipleVOQ路由器而言平均延时有所降低,吞吐率有所提高;在故障发生时,该文方案的相邻VC因为可以借用,故较VOQ路由器和multipleVOQ路由器,平均延时分别降低了32.3%和23.3%,吞吐率也有所提高.该文方案没有增加额外的FIFO开销,硬件开销上因为双向队列和BIST检测模块的设计较参考文献方案有所增加,但是相对于其达到的性能而言,这种硬件开销的略微增加是可以接受的.在网络出现虚通道故障或拥塞时,该文方案的设计维持了VOQ特性不变,保证了整个网络的连通性,达到了较高的可靠性,系统整体性能较优.关键词片上网络;容错路由器;VOQ;虚通道共享;双向队列1引言随着集成电路工艺的不断发展、晶体管特征尺寸的不断缩小,单个芯片上可集成的核数目越来越多,传统的基于总线架构的片上系统(SystemonChip,SoC)出现了可扩展性低、通讯效率差等问题[1-5].为了更有效地实现核间的通信,研究者们提出了片上网络(NetworkonChip,NoC)的概念[6-8].一个典型的NoC系统由处理单元、网络资源接口、路由器和通道组成.NoC中的所有链路都可以同时进行数据传输,较传统的通信架构而言,达到了较高的并行性[9].在NoC的组成中,路由器扮演着通信资源的角色,负责数据包的存储和转发[10].对于一个拓扑和带宽都确定的网络来说,NoC路由器的设计很大程度上影响着网络的延时和整体性能[11].由于制造缺陷、电路老化、工艺不稳定性和电子迁移等原因,路由器中元件会出现永久性故障[12].文献[13]指出,路由器中故障分布与元件面积成正比关系,含晶体管越多的元件,越容易出现故障.其实验表明,在45nm工艺下,如果FIFO大小为32-flit,那么FIFO面积占Page3路由器总面积的94%.如果FIFO大小为8-flit,则占80%.以上数据充分说明,在路由器面积中FIFO面积占很大比重,因此FIFO模块比较容易出现故障,故对路由器FIFO的容错显得尤为重要.面对上述问题,国内外研究者们展开了深入研究.对于NoC中路由器的FIFO故障,主要有两类解决办法:(1)对数据包进行重路由,使其绕过故障路由器来实现容错.如文献[14]设计了一种容错路由算法,它通过对路由器的重构来达到容忍任意数量、任意分布的路由器故障以及链路故障,并且不需要增加额外的路由表和虚通道(VirtualChannel,VC),但是故障节点中元件即使没有故障也不能被使用,造成了资源浪费.文献[15]提出了一种基于强化学习的片上网络容错偏转路由器,它在发送数据包的同时,采用强化学习的方法对路由表进行重配置以实现路由的容错,但是在每个路由器内部都需要维持一个路由表;(2)通过改进路由器架构来实现FIFO容错.如文献[16]提出了部分输入端口VC借用的容错路由器架构,实现了FIFO容错且一定程度上平衡了网络负载,但其实现方式和控制逻辑较为复杂,在不同的网络流量下需要借用的VC输入端口不一样.文献[17]提出ViChaR(dynamicVirtualChannelRegulator)架构,将输入端口内部的缓冲区进行共享.这种共享方式使得端口内部VC的数目和深度都有了较大的可变性,其FIFO的资源利用率较传统NoC路由器要高,但是其需要庞大的VC记录表和复杂的硬件来实现.文献[18]提出将输入端口内部的缓冲区进行共享,不同的是该方案的VC数目有一定的限制.因此其实现较ViChaR而言较为简单,但是每个输入端口处依旧需要维持一张关于VC状态的记录表.文献[19]将缓冲区划分成共享缓冲区和私有缓冲区,将VC数目限制为4个.该方案通过对缓冲区的预存取操作降低了数据包的读写延时,但是数据包如果不经过旁路会被存储两次,缓冲区的利用率较低.文献[20]所提方案中的缓冲区也是使用分布式方式放置在路由器中,每个输入端口处依旧是独立的VC缓冲区,但是增加了一组中间存储器,其交叉开关部分设计较为复杂,需要两个交叉开关.文献[21]没有采用缓冲区共享的方式来处理FIFO故障问题,而是将链路、缓冲区等模块均细化为4个小模块,使故障定位在具体的小模块中,通过对故障模块的重定向来实现容错,这是一种时间冗余的容错方案.以上所述的容错路由算法的设计和路由器架构的设计都较好的解决了FIFO的故障问题.但是,很多的设计方案在输入端口处均没有为发往不同输出端口的数据包设置特定的存储单元,这可能会导致头阻塞问题[22].头阻塞是指位于同一个VC的多个数据包中的第一个数据包,因得不到交叉开关授权而被阻塞,使其后面的所有数据包,因要等待第一个数据包传输而不得不被阻塞的现象.只要VC数目有一定的限制,不等于buffer槽的总数,大多数的可共享输入缓存的路由器架构都可能会产生头阻塞问题.文献[16]所提的ViChaR架构可以较好的处理头阻塞问题,但是其开销太大,需要庞大的VC控制表和较多的硬件逻辑设计.为解决头阻塞问题,研究者们提出了VOQ(VirtualOutputQueue)机制[23],使得从每个输入端口到不同的输出端口都有一个VC单元.同时,考虑到FIFO的故障问题,设计一种基于VOQ的可解决FIFO故障的容错方案显得尤为重要.文献[24]基于VOQ机制提出了multipleVOQ路由器,将原有的4个VC变成8个VC,使得每个输出端口有2个VC与之对应.这种架构在发生故障或网络流量不均衡时,端口对应的FIFO容量较小,不能利用其他空闲FIFO存储数据.文献[25]探究了FVADA(FixedVCAssign-mentwithDynamicAllocation)VC分配机制,通过动态的VC分配达到FIFO的高利用率,在实现FIFO容错的同时也解决了FIFO拥塞问题,但当网络流量较大时仍然会有头阻塞问题产生.本文针对路由器中的FIFO故障问题,提出了一种对VOQ路由器的改进架构———相邻虚通道循环共享(VirtualchannelLoopSharing,VLS)路由器.这种路由器在保持VOQ特性不变的基础上,通过结合循环共享相邻VC和旁路机制来进行容错,同时有效地缓解了网络的拥塞现象.当发往特定输出端口的数据包所对应的FIFO故障时,数据包可借用相邻VC的buffer槽存储或绕过故障FIFO以实现容错.此外,当所申请的FIFO拥塞时,数据包也可使用相邻VC存储,充分地利用了相邻VC的空闲buffer槽,较好地提升了网络的整体性能.为保证VOQ特性,我们设计出了一种基于双向队列的FIFO控制器,通过控制两套读写指针实现对借用VC数据包和非借用VC数据包的读写操作.2头阻塞和基准的VOQ路由器如图1所示,传统的NoC路由器[26]由以下部Page4分组成:5个输入端口(E、S、W、N、L)、路由计算模块、虚通道分配器、交叉开关分配器、5个输出端口(E、S、W、N、L)和一个5×5的交叉开关(crossbar)图2传统的NoC路由器和基准的VOQ路由器VOQ路由器的特定VC映射特定输出端口的特性,虽然较传统NoC路由器简化了虚通道分配和交叉开关分配操作,但是当某个VC故障时却无法完成从输入端口到某个输出端口的数据传输.以图2为例,若图2(a)中任意一个VC发生故障,数据包均可以发往其他3个VC来实现存储转发.而图2(b)中的VC发生故障时,数据包无法发送至该故障VC对应的输出端口.因此,对VOQ路由器的容错模块.每个输入端口有多个VC,数据包从输入端口进入路由器后,会经过路由计算、虚通道分配、交叉开关分配、交叉开关传输、链路传输5个阶段的流水,完成数据包的存储转发.VOQ路由器是在传统的NoC路由器基础上改进的,简化了虚通道分配和交叉开关分配的操作.传统NoC路由器在网络负载大的情况下很容易发生头阻塞问题.头阻塞将会增加网络通信延时从而进一步增大网络拥塞状态,如图2(a)所示,以E输入端口为例,它有4个VC(VC-0、VC-1、VC-2、VC-3).我们假定数据包A、B、C分别发往输出端口S、W、N,数据包D和数据包E均发往输出端口L.在传统的NoC中,数据包E进入输入端口后会随机选择一个VC,图中随机选择的是VC_0.此时,若发往输出端口S的路径遇到阻塞,这将导致数据包A停留在VC-0中迟迟不能转发,使得VC-0中的后续数据包E也无法发送,形成头阻塞问题.文献[23]提出了能有效解决头阻塞问题的VOQ机制.VOQ机制主要思想就是把输入端口中VC分别映射到不同的输出端口,这样一个VC中只存有发往同一个输出端口中的数据,如图2(b)所示,其中VC-S、VC-W、VC-N、VC-L只能存储发往S、W、N和L输出端口的数据,从根本上避免了头阻塞的发生.很有必要的.此外,VOQ机制不适用于mesh拓扑中的不均衡通信.以E输入端口为例,若在某一段时间内由E输入端口发往S输出端口的数据包数目明显多于发往W、N和L输出端口的数据包,VOQ路由器就会出现VC-S满,但VC-W、VC-N和VC-L有空闲的状态.鉴于此,针对VOQ路由器可能发生的拥塞现象,合理地利用空闲VC来缓解拥塞是研究的另一个重点.Page53VLS路由器架构及其容错原理3.1故障及拥塞分析以E输入端口为例,VC-S、VC-W、VC-N、VC-L分别表示存放发往输出端口S、W、N、L的数据包的VC.图3(a)所示的是每个VC均能正常工作的情况,此时没有故障和拥塞的发生,无需借用相邻VC.如果VC-S出现拥塞,如图3(b)所示,由E输入端口发往S输出端口的数据包只能被缓存在上级路由器中,会造成上级路由器的拥塞,增大网络延时,降低吞吐率.因此,充分利用可用资源来缓解网络拥塞现象是非常有必要的.若输入端口中某个VC出现故障,如图3(c)所示,VC-S发生故障,则在特定输入端口对应特定输出的VOQ路由器中,由E输入端口发往S输出端口的数据包无法正常传输.如果没有相应的容错措施,会使网络的性能越来越差,因此在设计VOQ路由器时必须考虑VC故障问题.3.2VLS路由器架构由于VOQ路由器架构在实际应用过程中可能出现网络流量不均衡问题以及发生因为某个FIFO故障而导致的发往特定输出端口的数据包无法正常传输的情况,故本文提出了在输入端口内部共享相邻VC存储数据包的方法,以实现端口内部相邻虚通道循环共享的VLS路由器设计.VLS路由器如图4所示,主要由5个输入输出端口、路由计算模块、虚通道分配模块、交叉开关分配模块和旁路控制器组成.其中,路由计算模块采用的是前向路由技术,数据包从输入端口进入后会同步进行路由计算和虚通道分配操作,此时路由计算的结果是数据包在进入下级路由器后需要发往的输出端口.这种前向路由技术使得数据包在路由器中的传输变成4阶段的流水,一定程度上减少了数据包在网络中传输的延时.由于本文架构是在VOQ路由器架构上进行改进的,故仍然保持VOQ架构关于特定VC映射特定输出端口的性质,较传统NoC路由器而言,简化了虚通道分配和交叉开关分配操作,防止了头阻塞的发生.数据包在进入输入端口后,会经过VC选择器、双向FIFO控制器和输出选择器阶段,接受交叉开关的仲裁,图5所示的即为E输入端口的控制逻辑.由于本文所提到的FIFO故障指的是永久故障,故可以通过BIST检测进行测试.在工作模式之前,系统首先工作在测试模式,启动BIST检测机制,对路由器中的FIFO进行故障检测.测试结束后,将FIFO的故障信息传送给VC选择器模块,根据相应的故障信息判断是否借用相邻的VC.VC选择器.数据包会有一个VCID域和一个BVC域,VCID域里的信息表示数据包会发往哪个VC,BVC域表示数据包是否有借用VC,若借用,则BVC域的值为1,若没有借用,则值为0.此模块析取数据包的VCID域信息,接收来自BIST测试模块发送的FIFO的故障信息,以及双向FIFO控制器的满信息,判断是否共享相邻VC,以分配合适的VC给到来的数据包.双向FIFO控制器.由于同一VC的FIFO中可能会存有发往两个输出端口的数据包,故需要双向FIFO控制器来实现两种数据包的读写过程.为了保证改进后的路由器依旧保持VOQ的特性,我们对FIFO的控制逻辑做出改变,设定两套读写指针.两种数据包分别从FIFO的两端开始进行读写操作,对借用VC的数据包的操作采用指针控制器1来控制,非借用VC的数据包的操作采用指针控制器2来控制.输出选择器.为了保证交叉开关操作的简洁性,输出选择器模块接收来自双向FIFO控制器的空信息,通过判断FIFO中的数据来实现对发往同一输出端口的数据包的仲裁选择.输出选择器模块内部Page6图4VLS路由器架构图5E输入端口有一个计数器,用于计算数据包输出仲裁时连续选择同一个VC的次数.为避免饥饿的发生,当计数器大于某一特定值时选择另一条VC输出数据包,同时将计数器复位至0,重新开始计数.以E输入端口发往S输出端口的仲裁为例,该仲裁通过判断VC-S中非借用的FIFO和VC-W中借用的FIFO即VC-W(S)是否有数据来做出决策,0表示无数据包,1表示有数据包,其仲裁决策如表1所示.X表示维持上周期决策结果.Page7表1E输入端口中S输出的数据包仲裁选择VC-S由表1可以看出,本文优先传输借用VC中的FIFO的数据包,这样的优点是尽可能的减少因借用导致的正常数据包传输的关键路径延迟的增大.旁路控制器.若BIST发送的故障信息显示数据包要存储的VC及其相邻VC均故障时,可通过VC选择器模块选择旁路总线来绕过故障VC,从相对应的输出端口进行输出.当旁路控制器有多个旁路请求时,选择最先到来的数据包输出.3.3双向FIFO控制器本文的FIFO模块要存储借用VC的数据包和非借用VC的数据包,因此其与控制逻辑较传统路由器的FIFO有所不同.当网络中出现VC故障或拥塞时,双向FIFO控制器的设计在本文的容错方案中必不可少,故对其做出详细的说明.图6显示了双向FIFO控制器的主要构成部件,双向FIFO控制器主要由2个指针控制器和1个比较器组成.每个指针控制器控制一组读写指针,其中指针控制器1控制的是借用VC的数据包的读写操作,指针控制器2控制的非借用VC的数据包的读写操作.两组读写指针的时钟信号不同时有效,同一时刻只能允许一组数据的读写.比较器根据两组读写指针的位置来判断FIFO的状态,判定满和空信号是否有效.我们用a2指代写指针2的值,用a1指代写指针1的值,用b2指代读指针2的值,用b1指代读指针1的值,假设FIFO共有n个buffer槽,则判定条件如下:(1)b2-a2=1,则非借用FIFO满.(2)b1-a1=1,则借用FIFO满.(3)a2=b2,则非借用FIFO空.(4)a1=b1,则借用FIFO空.3.4VLS路由器容错方案由于路由器中FIFO面积所占比重较大,且在FIFO故障和拥塞情况下会严重影响网络性能.因此,对VOQ路由器的容错和平衡负载的研究显得尤为重要.本文提出的VLS路由器通过借用相邻VC来存储数据包,在保证VOQ特性不变的同时有效地容忍了VC故障.当端口内部中出现不同情况的故障时,本文的容错方案如下:(1)单VC故障.即VOQ路由器中输入端口内部某个VC出现故障,我们以E输入端口的VC-S为例.当E输入端口有发往输出端口S的数据包A请求到来时,VC选择器会接收到BIST发送的VC-S的故障信息和双向FIFO控制器发送的满信息,判断是否共享VC-W给数据包A.若VC-W的满信号无效,此时VC-W没有拥塞,更改数据包A的VCID域值为VC-W,同时置数据包的BVC域为1.指针控制器1将数据包存储在VC-W中.若VC-W拥塞,则更改数据包A的VCID域值为VC-W,置BVC域值为1,等VC-W有空闲buffer槽后,将数据包A存储至VC-W中.(2)多VC故障.即VOQ路由器中输入端口内有多个VC出现故障的情况,我们将其细化为多个单VC故障来解决问题.针对每个单VC故障,首先查看其相邻VC是否故障,若故障则通过旁路总线绕过故障VC,若无故障则可以借用相邻VC实现容错.综上所述,本文方案所设计的路由器有着一定的容错能力.当VLS路由器内部发生不同数目的VC故障时,该路由器性能有可能不受故障影响,与无故障时等同.如图7所示,在不同的VC故障数时,路由器性能不变的概率.其中,每个输入端口内部有4个VC,每个路由器有5个输入端口,路由器内部共有20个VC.从图中可以看出,当路由器中出现8个VC故障,即故障率为40%时,路由器性能不变的概率为23.4%.由此可以看出,本文方案的Page8容错能力较好,对网络的延迟没有带来较大的影响.同时,旁路总线的使用,保证了路由器中出现不同VC故障率时,路由器依旧可以正常运行,网络连通性较好,无节点损失.4实验结果和分析本文采用在Booksim[27]基础上进行扩展的仿真器作为本文的实验平台,搭建的拓扑结构为4×4的Mesh结构.针对不同的VOQ路由器设计方案,在性能和面积上进行比较.方案1为基准的VOQ路由器设计,方案2是文献[24]提出的multipleVOQ路由器,方案3为本文提出的VLS路由器.FIFO的大小为32个flits,每个路由器均有5个输入输出端口.方案1和方案3中每个FIFO有4个VC,每个VC大小为8个flits.方案2中每个FIFO有8个VC,每个VC大小为4个flits.4.1性能比较本文实验采用维序路由机制,通过在网络中设定不同的VC故障数,故障发生位置相同,来分别比较延时和吞吐率.延时是数据包从进入网络,到尾部离开网络的时间的差的平均值.吞吐率反映了单位时间内网络接收或发送的消息量.实验的通信模式为均匀模式和热点模式,采样周期为1000.图8和图9所示的是在均匀模式和热点模式下,当故障数为0时,3种方案在不同注入率下的延时和吞吐率的比较.从图中我们可以看出,在注入率很小的时候,3条曲线几乎重合.随着注入率的不断增大,3种方案的延时越来越大,但本文方案的增长趋势较为缓慢.方案1和方案2在无故障数的情况下,其延时和吞吐率几乎一样,这是因为针对某一特定输出端口都只有8flits的buffer槽用于存储数据包.本文方案在注入率较小时,曲线与方案1的接近,因为此时网络没有达到饱和,不需要考虑单个Page9VC不够用的问题.但当注入率继续增大时,本文方案就有一定的优势,通过借用,可以增加网络的吞吐量,减小延时.在均匀模式下,当注入率为0.6flits/(cycle×node)时,与方案2相比较,本文方案的延时减少了21.1%,吞吐率增多了19.7%.在热点模式下,当注入率为0.6flits/(cycle×node)时,本文方案比方案2的延时减少了30.3%,吞吐率增多了29.4%.随着注入率的不断增大,热点模式较均匀模式更容易产生拥塞现象,而本文方案可以缓解网络拥塞问题,故本文方案在热点模式下的性能要优于均匀模式.图10和图11显示了在均匀模式和热点模式下,当故障数为4时,3种方案延时和吞吐率的比较.随着注入率的不断增大,本文方案在延时上的增长速度明显小于其他两种方案.随着注入率的不断增大,延时急剧增大,网络达到饱和状态.方案1的延时最大,因为它没有考虑到容错问题.而在方案2中每个特定输出端口对应2个VC,在某个VC故障时利用另一个VC来存储数据包,具有一定的容错能力,故性能优于方案1.本文方案中可以共享相邻VC,通过相邻VC的借用实现容错,其VC的容量大于方案2中VC的容量,故注入率越大,吞吐率越高,性能较前两种方案越好.在均匀模式下,当注入率为0.4flits/(cycle×node)时,本文方案比方案2延时降低了30.4%,吞吐率升高了23.3%.在热点模式下,同样的注入率时,与方案2相比,本文方案延时降低了36.3%,吞吐率升高了31.9%.随着注入率不断增大,本文方案在热点模式下的性能要优于均匀模式,因为热点模式下所有数据包都发往热点,较均匀模式更容易产生拥塞.图12是在均匀模式和热点模式下,当注入率为0.4flits/(cycle×node)时,3种方案在不同的故障数下的延时比较.在相同的注入率下,随着故障数的增多,数据包的延时增大.从图中可以看出,方案2的延时要优于方案1,本文方案的延时是3种方案中最低的.如当故障数为6时,均匀模式下本文的延时较方案1和方案2分别降低了39.5%和31.6%,热点模式下本文方案的延时比方案1和方案2分别降低了50.8%和38.9%.这是因为本文提出的路由器能够有效地解决VC故障问题,并且较好地缓解网络拥塞.Page104.2硬件开销本文使用XilinxISE14.6实验工具,在XilinxVirtex-5XC5VFX70T环境下进行3种方案路由器的硬件仿真实验,通过Verilog-HDL语言描述相关硬件逻辑,并结合使用ModelSim10.2c进行功能和结构仿真.方案1为基准的VOQ路由器设计,方案2是文献[24]提出的multipleVOQ路由器,方案3为本文提出的VLS路由器.这3种方案的缓冲区大小是一致的,实验仿真结果如表2所示.从中我们可以看出,本文所提出的VLS路由器的硬件开销大于方案1和方案2.方案2的硬件开销大于方案1的原因在于,输入端口内部有两个VC可以映射到特定的输出端口,其控制逻辑较为复杂,同时需要建立VC存取控制表.本文方案是在方案1的基础上进行改进,增加了VC选择器、双向FIFO控制器等控制模块,同时还有BIST检测模块,因此硬件开销比方案1大.本文方案比方案2要略大,因为方案2的交叉开关控制逻辑变得复杂,而交叉开关在路由器中面积所占比重较大.本文方案的Slices、LUTs和Flips-Flops较MultipleVOQ路由器分别增加了15.1%、14.7%和9.1%.VOQ路由器5MultipleVOQ路由器VLS路由器55总结随着集成电路产业的不断发展,可靠性成为我们研究的重点.本文所提出的路由器通过端口内相邻VC的借用,实现相邻VC的循环共享,有以下几点贡献:(1)若端口内部的VC出现故障或拥塞,将数据包传入其相邻VC,共享相邻VC的buffer槽存储数据,实现了对故障VC的容错,一定程度上缓解了网络拥塞问题;(2)通过利用端口的相邻VC来存储数据包,没有增加额外的FIFO,且循环共享的方式保证了每个VC都可以借用和被借用;(3)设计了一种有两套读写指针的FIFO控制器,在共享相邻VC的同时,保证了VOQ的特性没有改变.实验表明,本文所提出的基于VOQ机制的VLS路由器具有容错能力,适应于不同网络流量,大幅度提高了网络的性能.
