Page1一种共享资源敏感的实时任务分配算法杨茂林雷航廖勇(电子科技大学信息与软件工程学院成都611731)摘要为提高多核实时系统分组固定优先级调度策略下的任务分配效率,该文对FIFO(FirstInFirstOut)自旋机制下任务阻塞时间,以及自旋等待造成的可调度性损失进行了定量分析,提出了一种新的任务相关度评价方法以衡量核间任务的相关性,并基于该方法提出了共享资源敏感的任务分配算法.该算法包含任务分组策略和任务组拆分策略.任务分组策略将存在共享资源冲突的任务划分为相关任务子集,尽可能将相关任务子集分配到同一核上,以避免核间任务相互阻塞造成可调度性损失;任务组拆分策略则根据任务相关度评价结果,对无法分配到同一核上的相关任务子集进行拆分,并将拆分出的任务分配到当前负载最轻的核上,以减小自旋造成的可调度性损失.实验结果表明,该算法任务集合接受率高于同类算法,而系统自旋损失低于同类算法.关键词多核处理器;实时系统;实时调度;任务分配算法;自旋机制1引言为了充分发挥多核处理器的计算能力,不同核上的任务需要高度的并行执行.为此,应尽量减小分配到不同核上的任务之间的依赖性,减少核间任务相互阻塞造成的系统资源浪费.多核实时调度一般分为:(1)全局调度(GlobalScheduling,GS),即操作系统仅维护一个全局就绪任务队列,动态地分配就绪任务执行,允许任务在不同的核间迁移;(2)分组调度(PartitionedScheduling,PS),即操作系统为每个核维护一个就绪任务队列,任务被分配到固定的核上后,仅在该核上调度执行而不允许在核间迁移.GS调度理论上可使系统利用率达到100%,然而实验研究显示[1-3]支持全局调度的调度器计算开销大,且任务频繁迁移可能导致Cache效率严重降低.相反,分组调度的系统开销小,但是其固有的任务分配难题使得系统的理论利用率相对较低[4].为了缓解调度开销与系统利用率的矛盾,出现了将GS与PS相结合的半分组调度[5]和集群调度(ClusteringScheduling,CS)[6].其中半分组调度允许一部分任务拆分成多个子任务,并允许子任务在不同核间迁移;而CS将处理器核进行分组,允许任务在属于同一分组的不同核间迁移.Brandenburg[2]在实时操作系统上对分组调度,全局调度,以及集群调度进行比较研究并指出,分组调度是最适合于强实时系统的调度策略.在PS调度下,任务分配是NP-hard问题.早期的任务分配算法假设任务相互独立,采用类似求解“装箱问题”的启发式算法进行任务分配,如First-Fit-Decreasing(FFD)、Best-Fit-Decreasing(BFD)、Worst-Fit-Decreasing(WFD)以及Next-Fit(NF)等.这类算法实现开销小,但忽略了任务间同步互斥的约束.在任务间具有前驱后继约束的任务模型中,任务集合通常抽象为有向图或树[7-8].Liu等人[7]根据图论算法中分枝与绑定的方法约束解空间,提出了一种基于布尔可满足性的最优化任务分配算法;Stavrinides等人[8]结合非精确计算模型和装箱算法,提出了基于任务复制的实时调度机制.然而这些算法均没有考虑任务互斥访问共享资源的情况,因此忽略了任务间相互阻塞造成的调度开销.由于任务通常需要互斥访问共享内存,关键数据等软硬件资源,当某任务请求访问当前被其他核上的任务锁定的共享资源时,将被阻塞而挂起或循环等待(自旋).Ras等人[9]指出,与挂起机制相比,自旋机制实现简单,任务切换次数少,但可能造成较大的处理器时间浪费.由于实时系统必须确保任务最坏情况响应时间小于任务截止时限,因此更关注任务被阻塞的最长时间.文献[10]分析了基于优先级等待的挂起机制下,任务最坏阻塞时间与响应时间.分析表明,挂起机制下任务抢占关系变得更加复杂,任务最长阻塞时间的估算也更加保守,从而使得挂起机制节约处理器时间的优势减弱.当任务频繁被其他核上的任务阻塞时,系统利用率可能急剧降低,甚至形成系统瓶颈[11-13].为此,Lakshmanan等人[11]提出将访问相同共享资源的任务分配到同一核上,并结合BFD提出了任务同步敏感的任务组合分配策略.Nemati等人[12]基于任务阻塞时间和Cache亲和性等因素,提出将任务相关性大的任务进行分组并分配到同一核上的分配策略.最近,Han等人[13]基于PS和MSRP[14]协议提出了同步敏感的能耗与松弛度管理机制,尽量将访问相似共享资源的任务分配到同一核上.然而以上算法并没有对任务阻塞造成的调度开销以及任务分组尺度进行定量分析,也没有解决如何对任务分组进行适当拆分和再分配的问题.Bin等人[15]提出一种分组适度算法,优先对可以访问共享资源的任务进行分组,当任务不访问资源时选择最早可用时间最小的处理器进行任务分配.然而该算法仅适用于非周期任务的非抢占式调度,且需要在线估计处理器及共享资源的最早可用时间,因此需要较大的计算开销.为了减少分组固定优先级调度策略下核间任务相互阻塞造成的调度开销,提高系统可调度性(Schedulability),本文针对具有互斥访问共享资源约束的实时周期任务模型,对MSRP协议机制下核间任务阻塞时间,以及自旋造成的系统资源浪费进行了定量分析;提出了任务相关度评价方法,以及共享资源敏感的多核实时任务分配算法.该算法将访问相同共享资源的任务划分为任务子集(以下称为相关任务子集),将同一相关任务子集中的任务分配到相同核上,以避免核间任务阻塞;当同一相关任务子集中的任务无法分配到相同核上时,根据任务相关度评价方法对相关任务子集进行拆分,以减少核间任务阻塞对系统利用率的影响.最后,通过实验评估验证了该算法的优越性.本文第2节介绍系统模型;第3节对MSRP协议机制下任务阻塞时间进行分析;第4节详细介绍Page3任务相关度评价方法以及共享资源敏感的任务分配算法;第5节对所提算法与类似算法进行性能比较分析;第6节对全文作简要总结.2系统模型周期任务(Task)i表示为三元组τi=(Ti,Ci,πi),Ti为任务周期,Ci为任务最坏执行时间,πi为任务优先级(πi数值越大表示优先级越高).任务优先级固定且互不相同,任务间无前驱后继关系.τi在每个周期开始时就绪,无释放抖动(ReleaseJitter),τi的一次执行称为一个任务实例(Instance或Job),表示为Ji.任务相对截止时限等于任务周期(ImplicitDeadline).定义1.τi的CPU利用率(ui)为τi的最坏执行时间与任务周期的比值,即ui=Ci/Ti.周期任务集合Γ={τ1,τ2,…,τn}在由m个核组成的同构(Homogeneous)多核处理器P={p1,p2,…,pm}上执行.p(τi)表示τi所在的核,τ(pk)表示分配到核pk上的任务集合.系统中有q个共享资源Φ={ρ1,ρ2,…,ρq},Θi∈Φ表示τi所需访问的共享资源集合,τi必须互斥访问ρs∈Θi.若ρs仅被分配到同一核上的任务访问,则称为局部资源,否则称为全局资源.Ф中局部资源集合表示为ФL,全局资源集合表示为ΦG.任务请求共享资源的规则符合MSRP[14]协议,其中全局资源请求不可互相嵌套.当τi∈Γ与其他所有任务都不访问相同共享资源时,称τi为独立任务,Γ中所有独立任务组成的任务子集表示为Γ.3核间任务阻塞分析分组固定优先级调度策略下,分配到不同核上的任务按照单处理器调度算法调度执行.当某任务请求访问已被其他核上的任务锁定的全局资源时,该任务将被阻塞.根据MSRP[14]协议,任务自旋等待全局资源.当多个任务等待同一全局资源时,为了避免任务饿死,MSRP中采用了FIFO排队的机制.下文将这种机制简称为FIFO自旋.自旋机制下,被阻塞任务所在核逻辑上处于空闲状态,因此造成了系统资源浪费,影响了系统可调度性.引理1.若τj访问一次全局资源ρs的最长时间为ξj,s,则任意τi∈pk请求访问ρs而等待的最长时间为证明.FIFO自旋机制下,τi等待全局资源ρs期间不可能被其他任务抢占,其等待时间仅取决于ρs的FIFO等待队列中排在τi前面的任务访问ρs的时间.当τi请求ρs时,若其他所有核上访问ρs时间最长的任务也恰好请求访问ρs,且τi插入到FIFO队列的队尾时,τi将等待这些任务依次释放ρs后才能访问ρs,其等待时间达到最大值,如等式(1)所示.定义2.核pk的自旋损失(Sk)为该核上所有任务在tLCM时间内自旋等待的最长时间之和与tLCM之比.其中,tLCM为该核上所有任务的周期最小公倍数.由于不同核上的任务并行执行,τi每次请求访问全局资源ρs时都可能插入到相应FIFO队列的队尾,使得其等待时间达到最大值Wk,s(引理1).当τi的任务实例多次访问共享资源时,其自旋等待全局资源的最长时间之和为εi=∑ρs∈Θi∩ΦGτi的一个任务实例访问全局资源ρs的次数).由此可知,核pk在Ti时间内会因τi自旋等待而浪费εi个时间单位.此外,核pk上所有任务在tLCM时间内都恰好经历一定个数的完整周期,所以Sk反映了核pk上所有任务自旋等待而对系统利用率造成的最大累计浪费.为了满足实时系统的可调度性,通常需要预留一定的处理器资源以确保系统在最坏情况下仍能满足实时任务的截止时限要求,引起系统可调度性损失.其中,自旋损失正好刻画了最坏情况下任务自旋等待所造成的可调度性损失,因此降低自旋损失可减小系统资源浪费,提高系统利用率.失等于τi对核pk造成的自旋损失Sk(i),其中定理1.调度τi∈pk引起的系统可调度性损证明.因为tLCM为τi∈τ(pk)的周期最小公倍数,所以τi在tLCM时间内恰好执行tLCM/Ti次.根据定义2可知任意τi∈pk对其所在核造成的自旋损失为(tLCM/Ti)·∑ρs∈Θi∩ΦG由于任务自旋等待期间独占处理器资源,因此若将任Page4务自旋等待时间视为任务执行时间,则自旋等待所占用的CPU利用率为Sk(i)(根据定义1).可见调度τi∈pk引起的系统利用率损失恰好等于Sk(i).证毕.4共享资源敏感的任务分配算法为了避免或减少FIFO自旋机制下核间任务阻塞造成的系统资源浪费,本文提出了共享资源敏感的任务分配算法.该算法包含两种策略:(1)任务分组策略,即将存在共享资源冲突的任务划分为相关任务子集,将同一相关任务子集中的任务分配到相同核上;(2)任务组拆分策略,即当某些相关任务子集无法分配到相同核上时,对相关任务子集进行拆分,以调整任务分配.为了进行相关任务子集拆分,本文提出了任务相关度评价方法,将任务相关度小的任务从相关任务子集中拆分出,以减小分配到不同核上的任务间的依赖性,从而减小核间任务阻塞造成的可调度性损失.本节首先介绍任务分组策略,然后介绍任务相关度评价方法,随后给出任务组拆分策略,最后给出算法整体描述与算法复杂度分析.4.1任务分组策略若存在一种任务分配结果,使得不同核上的任务不访问相同共享资源,则各核上的任务子集相互独立.从而,可避免核间任务自旋等待共享资源所造成的系统资源浪费.为此,提出了任务分组策略:将Γ中所有存在共享资源冲突的任务划分为一个相关任务子集,并将同一相关任务子集中的任务分配到相同核上.其中,若任意两个任务τ1与τ2访问资源ρ1,而τ2与τ3访问资源ρ2,则这3个任务将划分到同一相关任务子集中,如图1中相关任务子集1所示.任务分组策略将Γ从逻辑上被划分为一系列相关任务子集和一个独立任务子集.将同一相关任务子集中的任务分配到同一核上,则可避免核间任务阻塞.由于τi∈Γ为独立任务,因此将Γ中的任务分配到任意核上都不会引起核间任务阻塞.通过如下的递归算法可实现任务分组.算法1.任务分组算法.输入:Γ={τ1,τ2,…,τn}输出:一系列相关任务子集1.τi.link←NONE//标识τi属于某相关任务子集2.τi.indep←TRUE//标识τi是否为独立任务3.DefineIterative(τi)//定义递归函数用于子集划分4.FORj=1:n5.IF(τj.linkisNONE)6.τi.indep←FALSE∧τj.indep←FALSE7.τj.link←τi.link8.Iterative(τj)9.EndDefine10.FORi=1:n11.IFτi.linkisNONE12.τi.link←i13.Iterative(τi)14.FORi=1:n15.IFτi.indepisTRUE//该任务为独立任务16.Γ←τi//独立任务τi的.link值为i17.ELSEIFτianySub-task-set18.Γ—←Create_Sub_Set19.FORj=1:n20.IFτj.linkisthesameasτi.link21.Γ—←τj//τj与τi属于同一子集该算法的基本思想如下:(1)假设所有任务的初始状态为独立(.indep←TRUE)和无分组(.link←NONE).(2)若所有任务的.link均不为NONE,则算法结束;否则,选择某个未经过分组的任务τi(τi.linkisNONE),修改其分组状态τi.link←i,并依此判断τi是否与其他任务访问相同共享资源.(3)若τi与其他某个任务τj访问相同共享资源,则同时将这两个任务的状态.indep置为FALSE,将τj的分组状态置为τi.link,并将τi,τj划分到同一相关任务子集中;然后以递归方式从τj开始重复该步骤.(4)判断τi与后续任务是否访问相同共享资源,若访问相同共享资源则跳到步(3);否则跳至步(2).以上步骤结束后,所有.indep为TRUE的任务为独立任务,这些任务组成独立任务子集Γ而所有.link值相同的任务划分到同一相关任务子集中.从而得到一系列相关任务子集.4.2任务相关度评价方法尽管任务分组策略可以从理论上避免核间任务Page5阻塞,然而当算法1所得的某些相关任务子集无法整体分配到同一核上时,需要将这些相关任务子集中的任务分配到两个或多个核上.当相关任务子集中访问相同共享资源的任务分配到不同核上时,将会引起核间任务阻塞,从而造成自旋损失.本小节提出任务相关度评价方法,以衡量相关任务子集中不同任务间的相关度大小.失等于τi与τj分别对pk造成的自旋损失之和引理2.任意τi,τj∈τ(pk)对pk造成的自旋损证明.不失一般性,设任意τi∈τ(pk)的每个实例等待访问所有全局资源的最大时间为bi.根据定理1,τi对核pk造成的最大自旋损失为bi/Ti.又根据定义2可知,Sk(i+j)=bi/Ti+bj/Tj,即Sk(i+j)=Sk(i)+Sk(j).证毕.将x(1xn)个任务访问所有共享资源的最长时间用x×q(q为共享资源数)阶矩阵犝x×q表示.其中,任意元素ui,s表示x个任务中的第i个任务(设为τc)访问共享资源ρs的最长时间,即ui,s=ξc,s(引理1).若ui,s=0,则表示τc没有访问共享资源ρs.定理2.设Γ—={τa,τb,…,τz}(x=|Γ—|n)为算法1得到的相关任务子集,用x×q(q为共享资源数)阶矩阵犝x×q表示Γ—访问共享资源的时间.若将任意τi(设为矩阵犝x×q第c行对应任务)从Γ—中拆分出并分配到核pr上,而Γ—中其余任务分配到核pk上(r≠k),则Γ—中其余任务对核pk造成的自旋损失为其中,Γ—i=Γ——{τi};f(d)为矩阵犝x×q第d行对应的任务序号.证明.根据算法1,τi只可能与某些τj∈Γ—i访问相同共享资源.因此,τj∈Γ—i只可能由于自旋等待τi.当uc,s×ud,s≠0,则uc,s≠0且ud,s≠0.此时τi与矩阵犝x×q第d行所对应任务τf(d)都会访问共享资源ρs.由于任务τi与τf(d)在不同核上并行执行,因此τf(d)每次(一个实例需访问nf(d),s次)请求访问ρs都可能自旋等待τi访问ρs的最长时间ξi,s(等于uc,s).由此可知,τf(d)的一个实例需等待全局资源ρs的最长时间为αc,d,s=uc,s×nf(d),s.对αc,d,s进行累加可得τf(d)的每个实例自旋等待的时间总和∑q可知,τf(d)造成的自旋损失为Sk(f(d))=∑q又根据引理2可知,Sk(Γ—i)=∑d∈[1,x]∧d≠c定理2描述的自旋损失是由Γ—中与τi访问相同共享资源的任务引起的.因此,Sk(Γ—i)从自旋损失的角度定量描述了τi与Γ—中其余任务的一种相关关系.本文将Sk(Γ—i)作为衡量Γ—中τi与其余任务的相关度评价指标.4.3任务组拆分策略根据定理2,将Sk(Γ—i)最小的任务从Γ—中拆分出可最小化自旋损失.然而,若一次拆分后相关任务子集仍不可调度,则需要进一步拆分.当Γ—被拆分后,Γ—中包含的任务以及核间任务关系均发生变化,因此需要对矩阵犝的部分元素进行变换,使得从Γ—中拆分出多个任务时Γ—所在核的自旋损失仍保持最小.为此,需要解决两方面问题:(1)拆分出的多个任务分配到哪里;(2)选择哪些任务进行拆分.设初始任务子集分配到核pk上,且第一次拆分将τi∈Γ—分配到pr(r≠k)上.随后被拆分出的任务τu可以分配到pr或其他某个核py上(y≠k,y≠r).根据引理1可知,当τu与τi访问任意相同共享资源ρs时,若将τu分配到pr上,则核pk上的任务访问ρs需等待的最长时间为max(ξi,s,ξu,s);而若将τu分配到py上,则核pk上的任务访问ρs需等待的最长时间为ξi,s+ξu,s.结合引理1和定理1可知,将Γ—中拆分出的任务分配到相同核上可减小核间任务阻塞时间,从而减小不必要的自旋损失.因此,当Γ—作进一步拆分时,将新拆分出的任务分配到前一个被拆分出的任务所在的核上.当拆分出的任务分配到相同核上时,可将这些任务视为一个虚拟任务.将当前欲拆分出的任务逻辑上合并到原有虚拟任务中,从而使得每次拆分都等同于从初始相关任务子集中拆分出一个虚拟任务.如图2所示,当将τ3从相关任务子集中拆分出时Page6(此时τ1已被拆分出),可视为将τ1,τ3逻辑上合并为一个虚拟任务τ,再将虚拟任务τ从原始相关任务子集中拆分出.由于矩阵犝中每个行向量描述一个任务,因此可通过行向量变换实现任务的逻辑合并.设Γ—={τa,τb,…,τz}(x=|Γ—|n)为算法1得到的相关任务子集,矩阵犝x×q表示Γ—访问共享资源的时间(见式(4)).虚拟任务τ的构造方法如下:(1)当τi为第一个被拆分出的任务时,虚拟任务τ指向矩阵犝x×q中任务τi所在行;(2)当τi为第c(c>1)个被拆分出的任务时,对原有虚拟任务所指向的行进行相应行变换,并将矩阵犝x×q中任务τi所在行清零.设原有虚拟任务指向矩阵犝x×q第v行.当τi为第c(c>1)个被拆分出的任务时,依次将矩阵犝x×q第v行第s列元素(uv,s)变换如下:例如,设图2中τ1,…,τ4依次对应如下矩阵犝4×3的第1~4行.τ1被拆分出后,虚拟任务τ指向犝4×3的第1行.当τ3为即将被拆分出的第2个任务时,虚拟任务所指向行的各元素按行变换规则依次变为2、0、2,同时矩阵第3行清零,如犝4×3所示.犝4×3=定理3.若初始Γ—分配到核pk上,所有从Γ—中拆分出的任务都分配到核pr上(r≠k),则Γ—中剩余任务因等待虚拟任务τ而对核pk造成的最大自旋损失为Sk(Γ—).证明.当τi为第一个被拆分出的任务时,Sk(Γ—)=Sk(Γ—i),根据定理2,命题成立.当τi为第c个(1<cx)被拆分出的任务时,根据虚拟任务构造方法,虚拟任务τ所指向的行中第s列元素(设为uv,s),代表所有拆分出的任务需访问共享资源ρs的最长时间.根据引理1可知,τj∈Γ—∩τ(pk)(设为矩阵犝x×q第d行对应任务)访问共享资源ρs时需要等待的最长时间为Wk,s=∑pr≠pkuv,s.当τi被拆分出后,犝x×q中任务τi所在行被清零,因此不会重复计算τi对核pk造成的自旋损失.所以,τj∈Γ—∩τ(pk)的一个实例自旋等待ρs的最长时间可按照式(6)进行计算,即τj的一个实例需自旋等待的最长时间为∑q中剩余任务造成的自旋损失为Sk(Γ—v).其中,犝x×q第v行所对应的任务为虚拟任务τ,即Sk(Γ—)=Sk(Γ—v).根据定理3,可将Sk(Γ—)作为虚拟任务τ与Γ—中剩余任务间的相关度评价指标.由于虚拟任务为多个任务逐个合并而成,因此若每次都将使得Sk(Γ—)取最小值的任务拆分出,则可保证每次拆分后Γ—中剩余任务对其所在核造成的自旋损失最小.由此得到任务组拆分策略:首先将Sk(Γ—i)取最小值的任务τi从Γ—中拆分出并分配到其他核上,判断系统的可调度性.若系统可调度,则拆分过程结束,否则,采用虚拟任务构造方法继续拆分Γ—,逐个将使得Sk(Γ—)取最小值的任务分配到第一个被拆分出的任务所在的核上,直至系统可调度.若Γ—中所有任务拆分后仍不可调度,则表明任务组拆分策略失败.算法2.任务组拆分算法.输入:犝x×q//|Γ—|=x,Γ—为算法1所得相关任务子集,输出:任务分配结果1.τv←犳(min{Sk(Γ—i)|i∈[1,x]})//取Sk(Γ—i)最小的2.pr←Worst-Fit(τv)//将τv分配到负载最小的核pr上3.虚拟任务τ指向矩阵犝x×q第v行4.WHILESched(τ,pr)=FLASE//该分配后是否可5.犫←狌v//将犝x×q第v行暂存至q维向量犫中6.FORi∈[1,x]∧i≠v7.犮←狌i//将犝x×q第i行暂存至向量犮中8.s∈[1,q],uv,s=max(uv,s,ui,s)//行变换9.j∈[1,q],ui,j=0//矩阵犝x×q第i行清零10.IFSk(Γ—)<Mins//设Mins的初值大于111.Mins←Sk(Γ—)Page712.tem←i13.ENDIF14.狌i←犮//恢复矩阵犝x×q第i行15.狌v←犫//恢复矩阵犝x×q第v行16.ENDFOR//此时tem指向被拆出任务所在行17.s∈[1,q],uv,s=max(uv,s,utem,s)//更新虚拟任18.j∈[1,q],utem,j=0//矩阵犝x×q第tem行清零19.Alloc(τtem,pk)//将τtem分配到核pk上20.IFΓ—isempty//所有任务拆分后仍不可调度21.RETURNFAILURE算法2为任务组拆分策略的算法实现,其中第一个被拆分出的任务被分配到当前负载最小的核上(Worst-Fit(τv)).因为该核的可用空间最大,是最有可能接受全部被拆分出的任务的核,因此可在最大限度上满足被拆分出的任务分配到相同核上的要求.对于x×q(|Γ—|=x,q为共享资源数)阶矩阵犝x×q,计算Sk(Γ—i)的时间复杂度为O(qx);选择Sk(Γ—i)最小的任务最多需计算x次Sk(Γ—i),因此从Γ—中拆分出一个任务的时间复杂度为O(qx2);WHILE语句最多执行x次,因此算法2总体时间复杂度为O(qx3).除矩阵犝x×q外,算法2在行变换时需要两个q维行向量暂存矩阵犝x×q的相应行,因此算法2的空间复杂度为O(qx).4.4任务分配算法整体描述结合以上分析,本文提出了共享资源敏感的多核实时任务分配算法,该算法主要包含以下3个步骤.(1)采用任务分组策略,将待分配任务集合划分为一系列相关任务子集和一个独立任务子集,将相关任务子集按CPU利用率(∑ui)排序,采用WFD算法分配相关任务子集(属于同一相关任务子集的任务被分配到相同核上,否则认为该相关任务子集不可分配).(2)结合任务组拆分策略和WFD算法进行分配.首先,采用WFD算法将待拆分的相关任务子集分配到当前负载最小的核上,以减少需要被拆分出的任务个数.然后,根据任务相关度评价结果,逐个将该相关任务子集中的任务拆分出来,直到系统满足可调度性要求.若Γ—中所有任务拆分后仍不可调度,则撤销本轮分配(使各核上所分配的任务恢复到本轮任务组拆分策略实施前的情况).(3)采用WFD算法分配独立任务和第2阶段未分配的任务.任务分配算法伪代码如下.算法3.SharedResouce-Aware任务分配算法.输入:Γ={τ1,τ2,…,τn}输出:任务分配结果1.由算法1得到g个相关任务子集:Γ—1…Γ—g2.FORi=1:g3.Γ—h←Highest_U()//未分配的最大相关任务子集4.pk←Iowest_Load(P)//当前负载最小的核pk5.IFSched(Γ—h,pk)isTRUE//Γ—h在pk上可调度6.Alloc(Γ—h,pk)//将Γ—h分配到pk上7.WHILEΓ—i∈{Γ—1…Γ—g}未分配8.Γ—h←Highest_U()//未分配的最大相关任务9.pk←Iowest_Load(P)//当前负载最小的核pk10.IF任务组拆分算法返回FAILURE11.Roll_Back()//撤销本轮分配12.Taskset_Broken()//拆散Γ—i留待分配13.WHILEτi未分配14.τh←Highest_U()//未分配的最大的独立任务15.pk←Iowest_Load(P)//当前负载最小的核pk16.IFSched(τh,pk)isTRUE//分配后可调度17.Alloc(τh,pk)//将τh分配到pk上其中,算法1可根据形式与式(4)相同的n×q阶矩阵犝n×q进行任务分组.即算法1可通过判断矩阵犝n×q第i行与第j行的同一列是否有同时不为零的元素,以判断τi与τj是否访问相同资源.若某些列上有同时不为零的元素,则τi与τj访问了相同的资源.本文系统模型中有n个任务,m个核和q个共享资源.采用矩阵犝进行任务分组的时间复杂度为O(qn2);采用WFD算法分配相关任务子集(算法3第2~6行)的时间复杂度为O(g2+mg),其中g为相关任务子集数;若第1阶段结束后,有l个相关任务子集无法分配,各相关任务子集中最多有x个任务,则采用任务组拆分策略(算法3第9~12行)的时间复杂度为O(l2+lm+lqx3);若独立任务子集包含h个任务,则WFD算法(算法3第13~17行)的时间复杂度为O(h2+hm).由于以上分析中2g<n,lx<n,h<n,因此对最优解进行求解的时间复杂度为O(mn+qn3).本算法需要存储n×q阶矩阵犝n×q以及2个额外的q维行向量(算法2中临时向量犫和犮),因此空间复杂度为O(qn).此外,当任务参数可事先确定时,分组调度策略下的任务分配可通过离线计算确定,因此以上的算法过程不存在系统运行时开销.Page85实验评估根据实时系统中常用的周期任务模型,任务周期性到达并按照优先级进行抢占式调度.其中,传统的“装箱”启发式算法对任务间的相互关系是不敏感的.文献[11-12]提出了任务同步敏感(Synchronization-aware,简记为Syn-aware)的组合分配策略,尽量将访问相同共享资源的任务分配到同一核上.然而这些算法均未考虑组合分配失败后如何进行拆分的情况,因此对组合拆分造成的系统损失不敏感.本文将所提出的共享资源敏感算法(SharedResource-aware,简记为SR-aware)与传统启发式算法(WFD)以及基于组合分配策略的算法(Syn-aware)[11-12]进行比较.由于Syn-aware算法没有给出完整的算法实现,因此当访问相同共享资源的任务无法分配到同一核上时,本实验采用随机选取的方式对任务组合进行拆分.设计实验如下.5.1性能指标本文以8核处理器平台上任务集合接受率作为任务分配算法的性能指标.设每次实验随机产生N=10000个任务集合,统计任务分配算法A可调度的任务集合数为M,则算法A的任务集合接受率为M/N.任务集合接受率越大表明算法效率越高.此外,对各算法的系统平均自旋损失进行了比较,其中,系统自旋损失定义如下:自旋损失是确保系统可调度而造成的隐性资源任务数n由各任务的CPU利用率ui分布与系浪费,因此与系统利用率和算法效率密切相关.5.2任务模拟统利用率SU=∑τi∈Γ(1)ui根据UUnifast-Discard算法[16]在[0.1,0.3]内随机取得.(2)任务周期Ti的自然对数服从均匀分布,在[100,1000]内随机产生,从而模拟大多数实时任务.(3)任务执行时间Ci由任务周期与任务CPU利用率决定,且满足Ci=Ti×ui.(4)任务优先级与RateMonotonic(RM)[17]算法一致,即任务周期越长,其相对优先级越小.(5)每16个共享资源分为一组,一组共享资源可被8个任务随机访问.(6)各任务包含1~6个临界区,各临界区对应的共享资源在任务所访问的共享资源分组中随机选择.(7)任务访问各共享资源的时间,即临界区长度在[1,20]内取值.5.3实验结果(1)任务集合接受率.当临界区长度为4,每个任务包含2个临界区时,任务集合接受率与系统利用率SU的关系如图3所示.各算法任务集合接受率随SU增加而单调下降.WFD与Syn-aware算法在SU>0.6时出现任务集合不可调度,而SR-aware算法在SU>0.7以后才出现任务集合不可调度.其中Syn-aware算法的任务集合接受率大于WFD算法,这是因为Syn-aware算法将存在访问共享资源冲突的任务尽量分配到同一核上,在一定程度上减少了自旋损失.而WFD对任务间相互阻塞所引起的系统资源浪费不敏感,仅根据任务CPU利用率和各核负载进行分配,因此当核间任务阻塞造成的开销不可忽略时,WFD算法的性能会急剧降低.SR-aware算法在Syn-aware算法基础上增加了任务组拆分策略,在相关任务子集拆分时可以尽量减小自旋损失,因此其任务集合接受率高于Syn-aware算法.图3任务集合接受率随系统利用率增加的变化图4给出临界区长度对各算法性能的影响,其中每个任务包含2个临界区,SU=0.65(图3显示SU=0.65时各算法任务集合接受率接近).由于任务自旋等待的时间随临界区长度增加而增加(见引理1),因此各算法任务集合接受率均有所降低.当相关任务子集无法分配到同一核上时,SR-aware算法根据任务相关度评价方法将拆分出的任务尽量分配到同一核上,因此任务通常只需自旋等待某一个核上的任务,自旋损失明显减小(详见引理1、定理1).而Syn-aware算法对任务组合进行随机拆分,对拆分出的任务进行随机分配,因此在临界区长度较长时所引起的系统利用率损失也较大.由于在相关任Page9务子集拆分中的随机性,Syn-aware算法的性能趋近于WFD算法.图4任务集合接受率随临界区长度增加的变化图5为SU=0.65,临界区长度为4时,任务临界区数对任务集合接受率的影响.随着任务临界区数增加,任务自旋等待共享资源所造成的系统资源损失也相应增加,因此各算法的任务集合接受率均有所下降.同时,任务间通过访问共享资源而产生的关系也更加紧密,容易形成较大的相关任务子集.当任务临界区数较多时,SR-aware与Syn-aware算法需要进行频繁的相关任务子集拆分,SR-aware算法在任务组拆分策略方面的优势使得其任务集合接受率高于Syn-aware算法.图5任务集合接受率随任务临界区数增加的变化(2)系统自旋损失.图6、图7、图8的实验参数分别对应于图3、图4、图5.系统自旋损失由等式(8)计算所得,其中包含了各算法不可调度的任务集合中各任务的自旋损失,因此实验结果中出现了系统自图6系统平均自旋损失随系统利用率增加的变化图7系统自旋损失随临界区长度增加的变化图8系统自旋损失随任务临界区数增加的变化旋损失大于1的情况.由于各算法分配相同的任务集合,因此将各算法的分配结果所造成的自旋损失(包括不可调度的情况)进行统计比较,更能够体现不同算法的性能差异.实验结果显示,系统自旋损失随各任务参数的变化趋势与任务集合接受率的变化趋势基本相反.其中,SR-aware算法系统自旋损失最小,WFD算法最大,Syn-aware算法的系统自旋损失趋近与WFD算法.由此说明,将自旋损失作为衡量任务间相关性的指标具有一定的现实意义,而将最小化任务自旋损失作为任务分配算法的优化目标可以减小系统资源浪费,提高系统利用率.6结论本文研究多核实时系统分组固定优先级调度策略下,具有互斥访问共享资源约束的周期任务分配问题.首先,对FIFO自旋机制下任务阻塞时间以及自旋造成的可调度性损失进行定量分析,提出了自旋损失的概念以衡量自旋对系统利用率的影响.接着,从任务自旋损失的角度,提出了一种衡量任务间相关度的评价方法,并基于该评价方法提出了一种共享资源敏感的实时任务分配算法.该算法包括任务分组策略以及任务组拆分策略,可避免或减少核间任务阻塞,从而减小任务自旋所造成的系统资源浪费,提高系统利用率.最后,将所提算法与同类算Page10法进行性能比较,实验结果表明,新算法任务集合接受率高于WFD和Syn-aware系列算法,而系统自旋损失低于上述算法.
