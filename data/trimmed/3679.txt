Page1数据时效性判定问题的求解算法李默涵李建中高宏(哈尔滨工业大学计算机科学与技术学院哈尔滨150001)摘要数据的时效性问题是影响数据质量的重要因素之一.时效性差的数据会对企业决策和人们的日常生活带来许多不利影响,这使得判定数据的时效性成为必要.许多应用数据库中都没有完整、清洁、可用的时间戳,从而导致数据时效性的判定非常困难.冗余记录和时效约束能够在时间戳缺失的情况下有效地辅助恢复数据的时序关系,因而能够帮助数据时效性的判定.文中研究包含冗余记录的集合在给定时效约束下的时效性判定问题,并首次提出了时效性判定问题的求解算法.首先,文中定义了查询相关时效性和用户相关时效性.在判定查询相关时效性时,文中将查询归结为最新值查询和时效序列查询两类,并分别根据两类查询的特点,对每类查询定义了查询结果时效性和平均时效性.然后,文中提出了时效图的概念.利用时效图,文中给出了查询相关时效性和用户相关时效性判定问题的求解算法.最后给出了真实数据和虚拟数据上的实验结果,验证了文中算法较高的执行效率,并分析了各个参数对算法的影响.关键词数据质量;数据时效性;相关时效性1引言数据的时效性问题普遍存在于各类实际应用中,是影响数据质量的重要因素之一.随着时间的推移,数据质量会快速的下降,有统计称,在商业数据库中,约有2%的客户信息会在一个月内变的陈旧[1],即是说,在2年内,会有近50%的记录因为过时而使其可用性受到影响.在企业决策时,企业往往会因为使用了陈旧的数据而做出错误的决策,而在日常生活中,银行可能会将信用卡账单寄送到持有人搬家前的旧地址.劣质数据每年给美国造成的经济损失高达6000亿美元[1],而时效性差正是造成数据劣质的罪魁祸首之一.为此,确保数据时效性是一个十分重要的问题.数据时效性判定问题是确保数据时效性的一个关键问题.无论是数据时效性问题的发现还是数据时效性问题的修复,都首先需要对数据时效性加以判定.在用户使用数据时,往往也首先要求判定数据的时效性.本文集中研究数据时效性判定问题.通常,很多应用数据库中都没有时间戳.即使存在时间戳,由于数据缺乏及时有效的维护或数据集成等原因,这些时间戳经常不可用或不精确[2].而且,同一记录的不同属性随时间变化的频率不同,使得同一记录的不同属性的新旧程度也会不同,为每条记录的每个属性都保存相应的时间戳并非易事.所以,数据时效性判定问题面临的主要挑战是数据集合中没有完整、精确、可用的时间戳.虽然在时间戳缺失或不精确的情况下,数据时效性的判定问题变得困难,但是我们仍能够利用一些冗余记录和时效约束(currencyconstraint)来实现数据时效性的判定.冗余记录是指数据集合中存在着多条记录描述同一实体的情况.例如,在网络环境下,用户搜索某人的信息,往往得到多条不同的结果;数据集成环境下,会有多条来自不同数据源的记录描述同一实体;企业周期性地备份数据库,在被备份的历史数据中,同一实体也可能存在多条历史记录.时效约束是数据的语义信息,可以辅助恢复同一实体不同属性值的部分时序关系[3],进而判定数据集合的时效性.我们用例1来说明如何结合冗余记录和时效约束来恢复时序关系.例1.考虑图1所示的数据集合D.D中有4条记录描述实体Alice在过去某段时间的工作情况,其中,tID、EID、FN、LN、City、Salary和Status分别表示记录ID、实体ID、姓、名、工作城市、工资和婚姻状况.tIDEIDFNLNCitySalaryStatust11AliceSmithBeijing50kSinglet21AliceSmithShanghai70kSinglet31AliceGreenGuangzhou80kMarriedt41AliceGreenHarbin80kMarried时间及插入时间,但有时效约束如下:最新值.Married,再变成Divorced.假设D中无可用时间戳可以表示数据的生成cc1:同一个人的工资不会随时间下降.cc2:存有工资最新值的记录也存有工作城市的cc3:同一个人的婚姻状况只能由Single变成我们用tiAtj表示属性值ti[A]比tj[A]旧,将ti和tj的A属性值新旧程度相同记为ti=Atj由约束cc1可知,因为Alice的Salary取值从小到大为50k<70k<80k=80k,所以t1Salaryt2Salaryt3=Salaryt4.同理,由cc3可得t1=Statust2Statust3=Statust4.结合cc1和cc2,在City属性上有t1Cityt2Cityt3和t1Cityt2Cityt4.注意,在Salary属性上,由t3[Salary]=t4[Salary]可得t3=Salaryt4,但同样的判断在City属性上并不成立,因为t3[City]≠t4[City].在这种情况下,我们只能恢复出City属性上的部分时序关系.如例1所示,当数据集合中不存在可用时间戳,但存在冗余记录和时效约束时,我们能够有效地恢复该数据集合上的部分时序关系,并判定数据集合在给定的时效约束下的时效性.文献[3]是当前数据质量领域中唯一一篇研究数据时效性的工作,该文献利用由冗余记录和时效约束恢复得到的时序关系对数据的时效性进行了建模,但遗憾的是,文献[3]并没有给出任何能判定数据时效性的算法.本文在文献[3]的基础上,研究包含冗余记录的数据集合在给定的时效约束下的时效性判定问题,主要解决了数据相对于查询的时效性判定问题、数据相对于用户的时效性判定问题.我们把数据相对于查询的时效性称为查询相关时效性.当用户向时效性不佳的数据发出查询时,查询结果的时效性也不能保证,所以需要将查询结果及其时效性判定结果一同返回给用户.为了求解此问题,我们将查询归结为2类:最新值查询和时效序Page3列查询.对每类查询,分两步求解数据相对于该类查询的时效性判定问题:第1步,对于给定的数据集合D和查询Q,判定Q在D上的查询结果的时效性;第2步,基于第1步的判定方法,将每类查询作为一个整体,判定数据集合D相对于该类所有查询的平均时效性.我们将数据相对于用户的时效性称为用户相关时效性.面对同一个数据集合,不同的用户会有不同的需求,这些需求可以通过查询来体现.例如,企业中薪酬分析人员的查询集中于“职位”和“工资”属性,而销售经理则更倾向于查询员工在不同城市的销售业绩.对于特定用户,其查询往往集中于某一类,甚至某几个查询,那么只要保证数据相对于这些常用查询的时效性良好,数据对于用户来说,时效性就高.因此,数据相对于用户的时效性判定问题可以归结为常用查询的查询结果的时效性判定问题.我们给出了此类判定问题的求解方法.本文贡献如下:(1)研究了包含冗余记录的数据集合在给定时效约束下的时效性判定问题,并给出了查询相关时效性和用户相关时效性的定义.(2)将查询归结为2类,提出了时效图的概念,给出了数据相对于查询的时效性判定问题的求解算法.方法.(3)给出了数据相对于用户时效性的判定(4)通过大量实验,研究了各个参数对时效性判定结果及算法效率的影响.本文第2节介绍相关工作;第3节给出查询相关时效性和用户相关时效性的定义;第4节提出查询相关时效性和用户相关时效性的判定方法;第5节讨论实验结果;第6节给出本文结论及未来研究方向.2相关工作文献[3]首次研究了数据库的时效性建模问题,该文献分3部分对数据的时效性建模:时序关系、时效约束、不同数据源间的拷贝函数.时序关系tiAtj的定义与例1中相同.时效约束定义为一阶逻辑语句,能够描述数据的语义信息.当数据来自于多个数据源时,拷贝函数可以描述不同数据源间的依赖关系(如数据源D1的某些数据可能拷贝自数据源D2).本文继承了文献[3]中时序关系和时效约束的定义,但研究的内容有所不同.首先,本文研究数据的查询相关时效性和用户相关时效性判定问题,文献[3]没有研究这两个问题.其次,本文给出了查询相关时效性和用户相关时效性的判定算法,而文献[3]没有给出任何数据时效性判定的算法.第三,文献[3]研究的判定问题多为NP完全或更难,这给该模型应用于实际带来了不小的困难,而本文对时效约束进行了更具体的分析,使得在本文定义的场景下,能够在多项式时间内判定数据的时效性.真值发现[4-6]研究如何发现多个数据源之间的依赖,即前文所述的拷贝函数.这些工作能够在多数据源环境下,根据数据源的依赖关系发现过时数据,但因为其目标在于对不一致数据发现真值,并不研究数据时效性,所以与本文工作不同.时间数据库[7-8]研究数据库对时间维度的支持.这些工作与本文工作有三点不同:(1)时间数据库假设数据有完整、清洁、可用的时间戳,而本文不假设数据有时间戳;(2)时间数据库侧重于研究如何让数据库对时间有更好的支持,并不考虑数据时效性能否满足用户需求;(3)时间数据库假定同一记录的所有属性时效性相同,而本文没有这一假定.时间约束(temporalconstraints)研究[9]看似与时效性研究相关,实际不同.时间约束研究主要集中在约束与满足约束的变量之间的关系,与本文研究的时效性判定问题不同.时间约束的定义也与本文研究的时效约束不同.3数据时效性定义3.1预备知识本文假设数据集合中可以有多条记录描述同一实体,且实体识别工作[10]已经完成.令数据模式R=(tID,EID,A1,…,An),其中,tID表示记录ID;EID表示实体ID,如果ti[EID]=tj[EID],则ti和tj描述同一实体;A1,…,An是n个属性,ti[A]表示记录ti的A属性值.当描述同一实体的记录在同一属性上有多种取值时,时序关系可以描述各值的新旧情况,形式化定义如下.定义1.时序关系(CurrencyOrder).设D是数据模式R的数据集合实例.D中记录ti和tj满足属性A上时序关系tiAtj当且仅当下述条件同时成立:①ti[EID]=tj[EID];Page4②ti[A]先于tj[A]出现在D中.例如,在图1所示的数据集合中,如果Alice2009年的City值为Beijing,2010年的City值为Shanghai,则t1Cityt2.时序关系是一个传递关系.记录间的时序关系需要通过时效约束来判定.时效约束的形式化定义如下.定义2.时效约束(CurrencyConstraints).设Ai是模式R的属性.R在Ai上的时效约束定义为如下一阶逻辑语句:t1,…,tk:R(∧j∈[1,k](t1[EID]=tj[EID])∧ψ→tuAitv),其中,R是数据模式;t1,…,tk是模式R的任意实例的k条记录;ψ是谓词;∧j∈[1,k](t1[EID]=tj[EID])∧ψ称为时效约束前件;tuAitv称为时效约束后件.例1中的cc1、cc2可以表示为式(1)、(2)所示的约束,cc3可写成(3)、(4)两条约束.s,t:Emp(t[EID]=s[EID]∧t[Salary]<s,t:Emp(t[EID]=s[EID]∧tSalarys→tCitys)s,t:Emp(t[EID]=s[EID]∧(t[Status]=s[Salary]→tSalarys)Single∧s[Status]=Married)→tStatuss)s,t:Emp(t[EID]=s[EID]∧(t[Status]=Married∧s[Status]=Divorced)→tStatuss)3.2查询相关时效性根据R在Ai上的时效约束能够得到描述某实体的记录在Ai上的时序关系,因此使用时效约束时只需知道待判断的实体和属性分别是什么即可.设查询为Q,那么基于时效约束判定查询相关时效性时就需要把Q抽象成三元组Q=(eQ,Attr(Q),QType),其中,eQ表示被查询的实体;Attr(Q)表示被查询的属性集合;QType表示Q所属的查询类别.查询类别有最新值查询和时效序列查询2种,用curQ表示Q的查询结果的时效性,curQ的值域为[0,1],其值越接近1则查询结果的时效性越好,越接近0则查询结果的时效性越差,两种查询相对应的查询相关时效性分别定义如下.3.2.1最新值查询最新值查询(CurrentValueQuery,CVQ)只关心某实体的最新状态,即eQ的Attr(Q)中属性的“最新值”.典型的CVQ形如查询Q1:“Alice当前的工作城市和工资”,即Q1=(Alice,{City,Salary},CVQ).为了判定CVQ查询相关时效性,首先要对给定的数据集合D和查询Q,判定Q在D上的查询结果的时效性.设Q=(eQ,Attr(Q),CVQ),则为了回答Q,需要给eQ的Attr(Q)中每个属性找到其唯一确定的最新值.如果这样的最新值不能被找到,那么Q就无法被准确地回答,其查询结果的时效性自然也受到影响.因此在判定CVQ查询结果的时效性时,首先需要为Attr(Q)的属性Ai找到一个记录集合TAi,使得对任意记录t∈TAi,t[Ai]是eQ的一个可能的Ai最新值.TAi称为Ai相对于Q的最新记录集合,形式化定义如下.定义3.Ai相对于Q的最新记录集合.设D是数据模式R的数据集合实例,eQ是D中某个实体,查询Q=(eQ,Attr(Q),CVQ),记录集合TAi称为Ai相对于Q的最新记录集合,当且仅当对t∈TAi,t满足下述两个条件:①t[EID]等于eQ的ID;②不存在记录s,使得根据R在Ai上的时效约束能够推出tAis.理想情况下,eQ的Ai最新值唯一确定,即下述两种情况其中之一成立:TAi只包含一条记录;或TAi包含多条记录,但对s,t∈TAi有s[Ai]=t[Ai].这时可认为eQ的Ai最新值的确定度为1.但因时效约束作用有限,所以可能存在s,t∈TAi,有s[Ai]≠t[Ai],这时Ai有多个可能的最新值.设TAi中的记录共有cnt(TAi)种不同的Ai值,那么eQ的Ai最新值的确定度就是1/cnt(TAi).1/cnt(TAi)称为Ai对Q的时效性贡献,对Attr(Q)中所有属性的时效性贡献求平均,就得到Q查询结果的时效性.下面给出CVQ查询结果时效性的形式化定义.定义4.CVQ查询结果的时效性.设D是模式R的数据集合实例,查询Q=(eQ,Attr(Q),CVQ),Q的查询结果的时效性curQ定义如下:其中,|Attr(Q)|是Attr(Q)中属性的数目;TAi是Ai相对于Q的最新记录集合.当Attr(Q)中各属性重要性不同时,在判定时效性时,可对属性按重要性加权.设属性Ai权值为wAi,则∑Ai∈Attr(Q)wAi=1.式(5)等价于各属性权值均Page5为1/|Attr(Q)|的情况,当Attr(Q)中各属性权值不相等时,可以将式(5)修改为式(6),用式(6)来计算查询结果的时效性.解决CVQ的查询相关时效性判定问题的第2步是将所有的CVQ查询作为一个整体,判定数据相对于所有CVQ查询的平均时效性(称为CVQ平均时效性).CVQ平均时效性与CVQ查询结果的时效性的定义非常相似,区别仅在于CVQ平均时效性需要对数据集合D中的每个实体的每个属性计算时效性贡献,对所有的时效性贡献求加权和,以之作为D的CVQ平均时效性.3.2.2时效序列查询时效序列查询(CurrencySequenceQuery,CSQ)关心实体的历史信息,即描述eQ的记录在Attr(Q)中的属性上的时序关系.典型的CSQ形如查询Q2:“Alice先后在哪些城市工作过”.即Q2=(Alice,{City},CSQ).在图1所示的数据集合实例中,Alice的City属性有4个不同值:“Beijing”、“Shanghai”、“Guangzhou”、“Harbin”.回答Q2时,需要找到相应的4条记录在City属性上,根据时序关系“City”排成的序列,如t1Cityt2Cityt3Cityt4,我们将这样的序列称为时效序列.为了判定CSQ查询相关时效性,首先要对给定的数据集合D和查询Q,判定Q在D上的查询结果的时效性.CSQ不关心最新值,而关心记录的时序关系,如果所需的时序关系不能被唯一确定,那么CSQ就无法被准确回答,其查询结果的时效性也受到影响.设Q=(eQ,Attr(Q),CSQ),为了回答Q,需要为eQ在Attr(Q)中每个属性上找到最长的时效序列.设eQ在Ai上的最长时效序列为SqAi,当前数据集合实例中共有l条不同的记录描述实体eQ,则理想情况下SqAi的长度(记为|SqAi|)应当为l.这时eQ在属性Ai上的时效序列的确定度为1.但因为时效约束作用有限,所以通常情况下|SqAi|<l,此时eQ在Ai上的时效序列的确定度为SqAi/l.SqAi/l称为Ai对Q的时效性贡献,对Attr(Q)中所有属性的时效性贡献求平均,就得到Q查询结果的时效性.CSQ查询结果时效性的形式化定义如下.定义5.CSQ查询结果的时效性.设D是模式R的数据集合实例,查询Q=(eQ,Attr(Q),CSQ),Q的查询结果的时效性curQ定义如下:其中,|Attr(Q)|、SqAi和l的定义与前文相同.与CVQ类似,当属性重要性不同时可以对Attr(Q)中属性按重要性加权,并以Attr(Q)中属性时效性贡献的加权和作为Q的查询结果的时效性.判定CSQ查询相关时效性的第二步是将所有的CSQ查询作为一个整体,判定其查询结果的平均时效性(称为CSQ平均时效性).与CVQ类似,可对数据集合D中的每个实体的每个属性计算时效性贡献,对所有的时效性贡献求加权和,以之作为数据集合D的CSQ平均时效性.3.3用户相关时效性如引言中所述,用户需求往往通过查询来体现,具体表现在用户使用数据时往往偏好某一类、甚至某几个查询.可以按照对查询的偏好将用户分为3类:第1类用户对查询没有偏好;第2类用户对CVQ和CSQ的平均时效性要求不同,若用户更关心实体当前的状态,则对CVQ平均时效性要求更高,若用户更关心记录的时序关系,则对CSQ平均时效性要求更高;第3类用户对某些常用查询的结果时效性要求较高,例如,薪酬分析人员经常查询员工的工资信息,其常用查询集合里就包含那些和“Salary”属性相关的CVQ或CSQ查询.第1类用户对查询没有偏好,故在判定该类用户相关时效性时,所有查询的重要性权值相等.所以,第1类用户相关时效性定义为CVQ和CSQ的平均时效性的平均数.对于第2类用户来说,CVQ和CSQ的重要程度不同,因此,第2类用户相关时效性定义为CVQ和CSQ平均时效性的加权和,权值取决于该类查询对用户的重要程度,CVQ和CSQ的权值之和等于1.第1类和第2类用户相关时效性(记为curuser)可统一表示为式(8).在判定对第1类用户相关时效性时只需令式(8)中的wCVQ=wCSQ=0.5即可.第3类用户对某些常用查询的结果时效性要求较高,设这些查询组成的集合为,则需要为中的查询一一判定其结果的时效性.再根据查询的重要程度给中的查询赋予相应的权值,并计算其查询结果时效性的加权和,就得到第3类用户相关时效性.第3类用户相关时效性定义如式(9)所示:Page6其中,curuser表示用户相关时效性,Qi是中的查询,wQi是Qi的权值且∑Qi∈时效性.3.4讨论对于同一个数据集合,用不同的时效性判定方法得到的结果可能完全不同.查询结果时效性描述的是数据相对于查询的时效性,其仅能反映查询涉及到的那一小部分数据的时效性如何,如果该部分数据时效性好,则相应的查询结果时效性就高.而查询平均时效性和用户相关时效性侧重于描述数据整体的时效性,其中两类查询平均时效性分别从最新值和时序关系两个角度描述了数据整体的时效性状况,而用户相关时效性则是针对不同用户需求,描述当前数据集合的时效性状况.在得到查询相关时效性和用户相关时效性后,可以进一步给出能够提高时效性的数据修复建议.对于某些结果时效性较差的查询,可以按照查询所属类别,着重修复查询涉及到的记录和属性,即确定其最新值,或恢复时序关系.对于第1类和第2类用户,如果用户关心的某一类查询的平均时效性特别差,则可以着重针对这类查询来修复数据.例如,在判定第1类用户相关时效性时,当前数据集合实例的CVQ平均时效性为0.9,而CSQ的平均时效性仅0.5,则应当着重恢复数据的时序关系.对于第3类用户,可以根据中查询的查询相关时效性来修复结果时效性较差的查询涉及到的那部分数据,从而提高用户相关时效性.4数据时效性判定问题求解4.1时效图不失一般性地,可设数据集合实例D中描述实体e的记录构成的集合为Se={t1,…,tk},对Se中记录ti和tj,可能存在ti[A]≠tj[A]的情况,假设数据中没有错误,则时序关系tiAtj和tjAti必有一个成立.时效图Ge,A用于描述Se中记录在A上的时序关系,形式化定义如下.定义6.时效图(currencygraph).设e为数据模式R的数据集合实例D中的实体,A是R中属性,Se={t1,…,tk}是D中描述e的记录构成的集合,有向图Ge,A=(V,E)称为e在A上的时效图,当且仅当下述条件同时满足:①|V|=|Se|,且V中的任意结点vi对应Se中的记录ti;②tiAtj当且仅当E中存在有向边(vi,vj).时效图Ge,A的构造算法如算法1所示.算法的输入为实体e,属性A,描述e的记录构成的集合为Se及数据模式R上的时效约束的全体构成的集合CCR,输出为e在A上的时效图Ge,A.算法第1行初始化图G,令其结点和边集和均为空;第2到5行向结点集合V中添加结点,使得V中结点和Se中记录一一对应;第6到12行检查CCR中每一条约束,如果当前约束cc是A上的时效约束(A上的时效约束可能不止一条),且存在ti,tj∈Se,使得根据cc能判定tiAtj成立,则向边集合E中添加有向边(vi,vj);循环结束后,图G即为时效图Ge,A.算法1.时效图Ge,A的构造算法.输入:e,A,Se,CCR输出:Ge,A1.G←(V,E);V←;E←;2.foreachti∈Sedo3.addviintoV;4.tag(vi)←ti;5.endfor6.foreachcc∈CCRdo7.ifccisacurrencyconstraintofAthen8.foreachtitjthatcanbeinferredfromccdo9.add(vi,vj)intoE;10.endfor11.endif12.endfor13.Ge,A←G;14.returnGe,A.下面我们用一个例子来说明算法1的执行过程,并在4.3节讨论算法1的时间复杂度.例2.考虑图1所示数据及式(1)和式(2)所示的时效约束.式(1)和式(2)分别是属性Salary和City上的时效约束,则可以对实体Alice的属性Salary和属性City构造时效图,如图2(a)和(b)所示.当数据集合中不存在可以表示属性各个取值的插入和生成时间的时间戳时,时效图可以用来判断哪些值是(或更有可能是)最新的.在图2(a)中,我们将代表t3和t4的结点合并成为一个结点,这是因为t3和t4的Salary属性值相同,则根据式(1),t3和t4的时效性应当相同(它们都具有最新的Salary值),在下文的算法中,我们会在需要时将这样的结点合并.对于任意实体e及其属性A,其时效图在时效Page7图2实体Alice的Salary属性和City属性对应的时效图约束给定后就确定了,因此可以将计算时效图的工作作为数据预处理,对每个实体的每个属性预先生成时效图并存储,从而在判定时效性时减少因反复生成时效图而产生的时间开销.4.2查询相关时效性判定问题求解4.2.1CVQ查询结果时效性及平均时效性判定算法.我们首先给出CVQ查询结果的时效性判定设查询Q=(eQ,Attr(Q),CVQ),如3.2.1节所述,Q要求eQ的Attr(Q)中每个属性有唯一确定的最新值.而在时效图中,某结点出度为0表示该点不比图中任何其它结点旧.所以在判定查询结果的时效性时,首先应当找到Attr(Q)中每个属性Ai的时效图GeQ,Ai中所有出度为0的点,这些点对应的记录构成定义4中的TAi集合.当时效约束相互间没有冲突时,时效图是有向无环图(因为时序关系是传递关系,所以如果时效图中有环,则说明存在tiAtj且tjAti的情况,即约束出现了冲突),此时时效图中至少有1个点出度为0.在找到所有出度为0的点后,利用式(6)就可判定Q的查询结果的时效性.CVQ查询结果的时效性判定算法如算法2所示.算法输入为Q=(eQ,Attr(Q),CVQ)和权值向量犠,其中犠用于设定Attr(Q)中属性的权值,输出为二元组(ansQ,curQ),ansQ用于记录Attr(Q)中各个属性的最新值,curQ为Q查询结果的时效性.算法首先用FindCurrentValue(GeQ,Ai)为Attr(Q)中每个属性Ai找到所有可能的最新值,并计算Ai对Q的时效性贡献,分别记录于(ansAi,curAi),然后对所有的curAi求加权和,得到Q的查询结果的时效性curQ.算法2.CVQ查询结果的时效性判定.输入:Q=(eQ,Attr(Q),CVQ),犠输出:(ansQ,curQ)1.curQ←0;2.foreachAi∈Attr(Q)do3.loadGeQ,Ai;4.(ansAi,curAi)←FindCurrentValue(GeQ,Ai);5.curQ←curQ+wAi×curAi;6.endfor7.ansQ←(ans1,…,ans|Attr(Q)|);8.return(ansQ,curQ).FindCurrentValue(GeQ,Ai)如算法3所示.算法3将时效图GeQ,Ai中的每个出度为0的点vi对应的记录ti加入集合TAi,并将ti[A]加入集合ansAi.在检查完所有出度为0的点之后,令cnt(TAi)等于ansAi中不同的Ai值的个数,并以1/cnt(TAi)作为属性Ai的时效性贡献,即curAi.算法3.FindCurrentValue(GeQ,Ai).输入:GeQ,Ai=(V,E)输出:(ansAi,curAi)1.ansAi←,TAi←;2.foreachvi∈Vdo3.ifoutdegree(vi)==0then4.addtiintoTAi5.addti[A]intoansAi6.endif7.endfor8.cnt(TAi)←thenumberofuniquevaluesinansAi9.curAi←1/cnt(TAi);10.return(ansAi,curAi).下面用一个例子来给出算法2的直观解释.例3.考虑图2中的两个时效图,设查询为“Alice当前的工作城市和工资”,即Q=(Alice,{City,Salary},CVQ),权值向量犠=(0.5,0.5).根据图2,TCity={t3,t4},ansCity={Guangzhou,Harbin},TSalary={t3,t4},ansSalary={80k}.进而可计算得到curCity=0.5,curSalary=1,curQ=0.5×0.5+0.5×1=0.75,ansQ={{Guangzhou,Harbin},{80k}}.接下来我们讨论CVQ平均时效性的判定方法.如3.2.1节所述,判定CVQ平均时效性需要对数据集合D中的每个实体的每个属性计算时效性贡献,并对所有的时效性贡献求加权和.上述工作可Page8(1)构造一个特殊的查询Q,令Attr(Q)等于(2)对于数据集合D的每个实体e,令eQ=e,(3)将所有的第2步中得到的结果根据实体的以分3步完成:模式R的所有属性,并为每个属性赋予权值.并执行一遍算法2.重要性做加权和,作为CVQ平均时效性.4.2.2CSQ查询结果时效性及平均时效性判定我们首先讨论CSQ查询结果的时效性判定方法.设查询Q=(eQ,Attr(Q),CSQ),如3.2.2节所述,为了判定Q的查询结果的时效性,需要对eQ的Attr(Q)中每个属性求最长时效序列.因为时效图中的边表示时序关系“A”,所以求最长时效序列等价于在时效图中寻找最长路径.如果能够完美地回答Q,则Attr(Q)中每个属性的时效图的最长路径都是哈密顿路.那么,最长路径长度与哈密顿路长度之比就等于定义5中的SqAi/l,对Attr(Q)中每个属性计算SqAi/l,再使用式(7)即可判定Q的查询结果的时效性.最长路径问题是一个NP难问题,但是由于时效图均为有向无环图,所以可以利用拓扑排序在多项式时间内解决该问题.CSQ查询结果的时效性判定问题的求解算法如算法4所示.算法输入为Q=(eQ,Attr(Q),CSQ)和权值向量犠,其中犠用于Attr(Q)中属性权值的设定.输出为二元组(ansQ,curQ),ansQ记录Attr(Q)中各个属性的对应的最长时效序列,curQ为Q查询结果的时效性.算法先用FindLongestSequence(GeQ,Ai)对Attr(Q)中每个属性Ai,求时效图GeQ,Ai中的最长路径并计算Ai的时效性贡献,记录于(ansAi,curAi),然后对所有的curAi求加权和,得到Q查询结果的时效性curQ.算法4.CSQ查询结果的时效性判定.输入:Q=(eQ,Attr(Q),CSQ),犠输出:(ansQ,curQ)1.curQ←0;2.foreachAi∈Attr(Q)do3.loadGeQ(Ai);4.(ansAi,curAi)←FindLongestSequence(GeQ,Ai);5.curQ←curQ+wAi×curAi;6.endfor7.ansQ←(ans1,…,ans|Attr(Q)|);8.return(ansQ,curQ).FindLongestSequence(GeQ,Ai)如算法5所示,其基本思想是按照拓扑排序给图中的结点赋予相应的层次编号,在对所有的结点都赋予层次编号之后,最大层次编号就是最长路径的长度.注意,同一层的结点对应的属性值可能相同(如图2(a)中t3和t4对应的Salary属性值均为80k),从而其新旧程度相同,需要将这样的结点合并.算法5.FindLongestSequence(GeQ,Ai).输入:GeQ,Ai=(V,E)输出:(ansAi,curAi)1.ansAi←,level←0,cnt←0;2.whileV≠do3.vset←Find0IndegreeNodes(GeQ,Ai);4.mergethenodeswithsameAivalueinvset5.cnt←cnt+|vset|6.foreachvi∈vsetdo7.vi.lv=level;8.endfor9.level←level+1;10.addvistintoansAi;11.removethenodesinvset;12.endwhile13.curAi=level/cnt14.return(ansAi,curAi).下面用例4来直观地说明算法4.例4.考虑查询“Alice先后在哪些城市工作过”,则查询Q=(Alice,{City},CSQ).图2(b)所示为Alice的属性City的时效图,可将其等价的转化为图3(b)所示的时效序列的形式,其中横轴上的点表示层次编号(如t1属于层次1),层次编号越大,属性值越新,如果两条存有不同值的记录属于同一层,则说明在当前约束下二者的时序关系无法判定.理想的时效序列长度为4,如图3(a)所示,为t1Cityt2Cityt3Cityt4,但实际情况如图3(b)所示,最长时效序列长度为3.因此属性City对于Q的时效性贡献为3/4=0.75.又因为Attr(Q)中仅包Page9含一个属性,所以Q的查询结果的时效性为0.75.CSQ平均时效性的判定方法与CVQ平均时效性的判定方法基本相同,即可以类似地定义查询Q,并在数据集合的所有实体上反复执行算法4,最后对所有得到的时效性贡献求加权和得到CSQ平均时效性.在此我们不再赘述方法细节.4.2.3时间复杂度分析设数据库模式R有n个属性,数据集合D中共有m条记录,共有c条时效约束.对于算法1,设检查一条时效约束的可满足性所需的最长时间为r,则最坏情况下算法1需要对每对记录检查所有的时效约束是否满足,时间复杂度为O(m2×c×r).r取决于时效约束的具体形式,复杂的规则虽然有较强的表达能力,但往往需要很长时间来检查其前件是否成立,反而会给时效性判定带来负面影响.因此,本文要求时效约束定义(定义2)中的条件ψ的形如规则1,当约束均满足规则1时,可以在多项式时间内完成时效图的构建.规则1.时效约束定义中的条件ψ必须满足下述条件:①ψ是若干谓词的合取,即形如p1∧…∧ph(可将(pi∨pj)∧pk改写为(pi∧pk)∨(pj∧pk)并进一步拆为两条规则),其中,h非常小,可以认为是常数;pi表示第i个条件,如t[Salary]<s[Salary];②对于ψ中的任意pi,可以在常数时间或多项式时间内判定其是否为真.规则1有两个作用.首先,规则1能帮助用户或领域专家写出更规范的约束,从而更方便计算机判定约束的可满足性.其次,规则1虽然使得时效约束的表达能力受到了一定限制,但是该规则能够保证约束的可满足性可以在多项式时间内被判定(至多只需检查h个谓词,每个谓词至多需多项式时间的).算法2调用了算法3,因此首先分析算法3的时间复杂度.算法3中2至7行的循环至多进行|V|次,第8行在计算ansAi中不同的Ai值的个数时,朴素的两两对比的方法至多比较|V|2次,而|V|在最坏情况下等于m,因此算法3的时间复杂度为O(m2).算法2中2至6行的循环共执行|Attr(Q)|次,每次循环调用一遍算法3,在最坏情况下,|Attr(Q)|=n,故算法2的时间复杂度为O(n×m2).注意,我们将生成时效图作为数据预处理,因此在算法2的第3行只读取时效图,而没有考虑时效图生成的时间.除此之外,算法3中,可以利用Hash函数将不同的属性值映射到不同的桶,则第8行的时间开销可以降到O(1),从而将算法3和算法2的时间复杂度分别降至O(m)和O(n×m).算法4调用了算法5,因此首先分析算法5的时间复杂度.算法5的第4行至多需执行|V|2次结点的两两比对,故2~12行的循环最坏情况需执行|V|3次.|V|在最坏情况下等于m,因此算法5的时间复杂度为O(m3).算法4中2~6行的循环共执行|Attr(Q)|次,在最坏情况下|Attr(Q)|=n,故算法4的时间复杂度为O(n×m3).与算法2和算法3同理,可以使用Hash函数将算法5的第4行开销降至O(1),从而将算法4和算法5的时间复杂度降至O(n×m2)和O(m2).4.3用户相关时效性判定问题求解用户相关时效性定义如3.3节所述.对于3.3节所述的第1类和第2类用户,可以利用4.2节的方法求得CVQ平均时效性和CSQ平均时效性,再利用式(8)就可求得相应的用户相关时效性.对于3.3节所述的第3类用户,需要对中每个查询,根据其所属的查询类别使用算法2或算法4求得查询结果时效性,再使用式(9)求得相应的用户相关时效性.5实验结果及分析5.1实验配置实验采用的硬件为IntelCorei5CPU,4GB内存,操作系统为Windows7,代码使用C++编写,软件开发环境为MicrosoftVisualStudio2010.因为之前没有其它工作能够给出数据时效性的判定算法,所以本节实验主要研究本文的时效性判定方法中各个参数对算法的影响.我们在真实数据集合和虚拟数据集合上分别对算法1、算法2、算法4及4.3节的用户相关时效性判定方法进行了实验.其中真实数据用于研究数据时效性判定结果对规则数目的敏感程度,虚拟数据用于验证本文算法的执行效率.真实数据集由100条个人信息组成,数据模式Stu=(tID,EID,Name,Gender,Edu,Occu,Ent/Sch,Addr,Salary,Age),各属性分别表示记录ID、实体ID、姓名、性别、学历、职业、工作单位/学校地址、住址、工资和年龄.真实数据集合中包含10个实Page10体,每个实体有10条不同的记录描述其信息.数据模式Stu上共定义了15条时效约束,例如s,t:Stu(s[EID]=t[EID]∧t[Age]<s[Age]→tAges)和s,t:Stu(s[EID]=t[EID]∧t[Edu]=Bachelor∧s[Edu]=Master→tEdus).我们通过改变约束的数目来研究其对数据库时效性判定结果的影响.虚拟数据集合采用自己编写的数据生成工具生成,其5个主要参数如下:entityNum用于控制实体的个数;为了方便衡量记录数对实验效率,我们将所有实体对应的记录数设为相等,用参数tupleNum控制;attrNum用于控制数据库的模式的属性数目;constraintNum用于控制约束的数目,生成工具生成的约束仅对一对记录生效,且均可以在常数时间内被判定可满足性;queryNum用于控制查询的数目.我们每次变动一个参数,固定其余4个参数,并研究该参数的变化对于算法效率的影响.5.2规则数目对时效性判定结果的影响在真实数据集上有15条时效约束,根据被这15条时效约束的覆盖的程度(覆盖程度越高,则时效约束影响的记录越多,因而越有助于恢复数据的时序关系),可以将真实数据集合D划分成两个子集合D1和D2,D1和D2各包含50条记录,D1被时效约束覆盖得较好,D2被时效约束覆盖得较差.查询集合被用来判定D的第3类用户相关时效性.可被划分为子集合1和2,其中1中的查询仅针对D1中的实体,而2中的查询仅针对D2中的实体.我们在D1、D2和D上分别进行实验,并比较这3种情况下查询相关时效性以及用户相关时效性判定结果的变化.图4中(a)~(c)3幅图分别为时效约束增加时,D1、D2和D的时效性判定结果变化情况.CVQ和CSQ两条折线表示当约束增加时,数据集合的CVQ和CSQ平均时效性上升情况.图4(a)中折线curD1(usingmethod1)表示D1的第1类用户相关时效性判定结果,折线curD1(usingmethod3)表示D1的第3类用户相关时效性判定结果,图4(b)同理.图4(c)中的curD(usingmethod3and1)和curD(usingmethod3and2)两条折线分别是使用1和2对D做第3类用户相关时效性判定的结果.因第1类用户相关时效性相当于第2类用户相关时效性权值相等的情况,所以不必专门对第2类用户相关时效性进行实验.由本组实验可以得到3个结论.(1)当时效性约束增多时,各类时效性判定结果在数值上均呈上升的趋势,但约束的效力各不相同.从图4中可以看出,第6和第10条时效约束加入时,D1、D2和D的各类时效性上升最快,这是因为这两条时效性约束能够影响的记录最多;而第7和第11条约束加入时,数据时效性并没有明显的上升,这是因为这两条约束只影响了非常少量的记录,因此对数据时效性几乎无影响.图4时效约束数对D1、D2和D的时效性判定结果的影响Page11(2)随着时效约束的增多,第3类用户相关时效性提升最快.这种现象的出现是因为第3类用户相关时效性仅关心查询涉及到的实体和属性,因此受时效约束影响最大.(3)被时效约束覆盖越好的数据集合的时效性越高.D1被时效约束覆盖的最好,当时效约束数目增加时,其各类时效性判定结果始终最高,约束数目等于15时,各类时效性均能达到0.8以上,第3类用户相关时效性更是达到了0.92.与之相比,D2被约束覆盖的较差,则各类时效性均较低,约束数目等于15时,各类时效性都只有0.75左右.D=D1∪D2,其被约束覆盖的程度介于D1和D2之间,因此各类时效性判定结果也介于二者之间.图5所示为使用1、2、分别对D判定第3类用户相关时效性得到的结果.可以观察到,使用不同的查询集合判定得到的第3类用户相关时效性差异很大.如前文所述,查询集合反映用户需求,该结果说明需求不同时,数据相对于用户来说,时效性也不同.除此之外还可以观察到,当使用1来判定D的用户相关时效性时,某些时效约束(如约束9)能较大幅度地提升时效性,但使用2时该约束不起任何作用.这说明需求不同时约束的作用也不同,并非所有约束都能真正提升数据时效性.图5使用不同的查询集合判定D的第3类用户相关时效性5.3各参数对算法执行效率的影响本小节用虚拟数据集合分析不同参数的改变对算法执行效率的影响,各参数意义如5.1节所述.在每组实验中,我们让被研究的参数从1k变到10k,并将实验分为两步.第1步,研究entityNum、tupleNum、attrNum、constraintNum对算法执行时间的影响,每次改变1个参数取值,并固定其余4个参数,按照当前参数取值,用数据生成工具随机生成数据集合和约束,并做如下3步工作:(1)为数据集合中所有实体在所有属性上构造时效图(buildcurrencygraph);(2)判定数据集合的CVQ平均时效性(evaluateCVQs);(3)判定数据集合的CSQ平均时效性(evaluateCSQs).第1和第2类用户相关时效性判定正好由上述3个过程构成.3个过程的执行时间如图6~图9所示,其中各图的横轴表示参数取值的变化,纵轴表示算法执行时间,图6、图8、图9的纵轴单位为ms,图7的纵轴单位为104ms.第2步,利用随机生成的包含queryNum个查询的集合判定第3类用户相关时效性,并研究queryNum的变化对其执行时间的影响,结果如图10所示,其中各图的横轴表示queryNum的取值,纵轴表示执行时间,单位为ms.图6所示为entityNum对算法执行效率的影响.本组实验中,为了把其它参数的影响尽量降到最低,我们令tupleNum、attrNum和constraintNum都等于10,则可认为算法1、2、4对于单个实体执行都只需常数时间.从图6可以看出,3种工作的执行时间随entityNum的变化基本呈线性增长,并且均能在0.12s内完成.图6参数entityNum对算法执行效率的影响图7所示为tupleNum对算法执行效率的影响.本组实验中entityNum、attrNum和constraintNum都等于10.4.2.3节中的理论分析表明,CVQ和CSQ相关时效性判定算法(不使用Hash函数优化)的时间复杂度是记录数目的平方或三次方量级,这与图6所示的实验结果相符.在tupleNum=10k时,判定CVQ平均时效性大约需29s.本图没有给出buildcurrencygraphs的执行时间,这是因为本实验中随机生成的约束仅对一对记录生效,且可满足性判定只需常数时间,故tupleNum不影响buildcurrencygraphs的执行时间.事实上,tupleNum=Page1210k时buildcurrencygraphs也只需约10ms,和其它两个过程相比几乎可以忽略不计.图7参数tupleNum对算法执行效率的影响(attrNum=entityNum=constraintNum=10)图8所示为attrNum对算法执行效率的影响.本组实验中entityNum、tupleNum和constraintNum都等于10.算法2和算法3的执行时间随attrNum增长基本呈线性增长,而buildcurrencygraphs因为要对每个实体在每个属性上构建时效图,故其运行时间也随attrNum的增长呈线性增长.在图中可以看出,attrNum=10k时,最多只需0.12s就可以完成3个过程中的任何一个,算法执行效率较高.图8参数attrNum对算法执行效率的影响(tupleNum=tupleNum=constraintNum=10)图9所示为constraintNum对算法执行效率的影响.本组实验中entityNum、tupleNum和attrNum都等于10.约束数目影响时效图的构建,而buildcurrencygraphs是数据预处理过程,如图9所示,其执行时间随constraintNum的增长呈线性增长.算法2和算法4中不构建时效图,所以evaluateCVQs和evaluateCSQs的执行时间只随随机生成的数据集合不同而略有波动,与constraintNum无关.图9参数constraintNum对算法执行效率的影响图10所示为queryNum对第3类用户相关时效性判定的执行时间的影响.该组实验中entityNum、tupleNum和constraintNum都等于10,attrNum等于1000(查询较多时,涉及到的属性也相应的会变多,因而attrNum设置的较大).由于除queryNum外其它参数都是常数,所以算法执行时间随queryNum的增长呈线性增长.queryNum=10k时判定第3类用户相关时效性只需约0.46s,算法执行效率较高.图10参数queryNum对算法执行效率的影响(attrNum=1000,tupleNum=entityNum=rNum=10)6结论及未来研究方向本文研究包含冗余记录的集合在给定时效约束下的时效性判定问题,并给出了查询相关时效性判定问题和用户相关时效性判定问题的定义及算法.在判定查询相关时效性时,将查询分为CVQ和CSQ两类,分别给出了这两类查询的结果时效性和平均时效性判定问题的算法.在判定用户相关时效性时,将用户分为3类,针对每类用户的需求,提出了不同的用户相关时效性判定方法,并进一步讨论了如何根据用户相关时效性判定结果来指明数据修复的方向.在研究上述时效性判定问题的过程中,本文提出Page13了时效图的概念,将时序关系以图的形式建模,使之能够帮助时效性的判定.最后用实验分析了各个参数对算法的影响,并验证了本文算法的高效性.在本文工作的基础之上,未来我们将着力于研究下述问题:(1)如何在数据集合动态变化时准确地判定数据时效性;(2)如何在数据不完整或有错误时判定数据时效性;(3)在数据时效性不佳时,如何自动修复数据.
