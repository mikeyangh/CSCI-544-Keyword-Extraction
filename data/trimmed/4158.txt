Page1考虑类特性的面向对象错误定位涂径玄陈林许蕾卢红敏徐宝文(南京大学软件新技术国家重点实验室南京210048)(南京大学计算机科学与技术系南京210048)摘要基于频谱的错误定位方法很少考虑语言特性对其错误定位效率的影响.文中针对基于频谱的面向对象程序错误定位,分析讨论了类特性对基于频谱的错误定位方法的有效影响,提出了结合类可疑度信息的错误定位算法,并通过3个Java开源软件作为实验对象对其进行了验证.实验结果表明,文中提出的方法能够有效提高基于频谱的面向对象错误定位方法的效率.关键词错误定位;面向对象;类可疑度;频谱;程序分析1引言错误定位是软件调试中一个十分费力耗时的过程,现今软件的复杂性增加了错误定位的困难性[1].为了提高程序员调试错误的效率,研究者提出了一系列自动化的错误定位方法,其中包括基于频谱的错误定位、基于模型的诊断、基于统计的错误定位等方法.基于频谱的错误定位是一种有效的轻量级错误定位方法:通过运行测试用例得到程序频谱,分析程序频谱得到语句与错误的相关性,并将语句按照错误相关性大小进行排序,减轻程序员手工排查语句的工作量,提升调试效率.面向对象程序具有类、对象、继承、封装等特性,在基于频谱的面向对象程序错误定位方法中[2-6],研究者很少特定考虑语言特性对错误定位的影响.我们结合近年来在程序分析、度量和测试方面的工作[7-12],对基于频谱的面向对象程序错误定位以及Page2面向对象程序的特性对其错误定位效率的有效影响做了初步研究,并在此基础上,提出了利用类可疑度信息,促进基于频谱的面向对象程序的错误定位效率的提高.实验结果表明,本文提出的方法能够有效地提高基于频谱的面向对象错误定位方法的效率.2相关工作程序频谱是软件的一种动态行为,Harrold等人[13]通过分析成功测试用例和失败测试用例频谱之间的差异性对错误语句进行定位.基于频谱,研究者提出了许多度量方法来定位错误.Jones等人[14]开发的Tarantula工具是第1个基于频谱的调试工具,该工具运用Tarantula算法对C程序语句着色,根据颜色来区分语句含错的可能性.Abreu等人[15]比较了Ochiai、Tarantula和Jaccard3种度量算法,并在西门子测试套件上做了实验,实验结果表明基于语句频谱Ochiai算法效果是最好的.Liu等人[16]提出了统计模型SOBER,对成功和失败测试用例中谓词的取值模式进行建模,来计算谓词的取值模式与错误的统计相关性.Wong等人[3]考虑了测试用例的数量对错误定位的影响,提出随着测试用例运行,成功测试用例应具有不同权重,并设计了3种Wong度量算法,实现了χDebug调试工具,并通过实验评估了这3种算法的有效性.近年来,研究者在频谱类型对错误定位效率影响方面也做了许多研究工作.Santelices等人[17]评估分析了语句频谱、分支频谱和定义-引用频谱3种轻量级频谱对错误定位的影响,并提出了3种不同频谱类型的结合方法:max-SBD、avg-SBD和avg-BD,其中avg-SBD效果最好,实验结果表明结合了多种频谱类型的错误定位方法更有效.Yu等人[5]把错误类型分为了两种,即控制依赖错误和数据依赖错误,针对两种错误类型分别建立了两种特定的频谱模型,并提出了结合这两种频谱模型的LOUPE算法进行错误定位.在面向对象程序错误定位方面,研究者也做了一些研究.Dallmeier等人[4]针对面向对象程序提出了Ample算法并设计实现了AMPLE系统,该系统在类的层次上进行错误定位,能够计算出每个类的错误相关性并有效地定位错误的类.Masri[18]提出了基于信息流频谱的错误定位方法,并把该方法运用到了Java程序的错误定位中.上述基于频谱的错误定位方法很少考虑语言特性对其效率的影响,我们在表1中列出了主要的基于频谱的错误定位方法.针对面向对象程序,本文分析讨论了类的特性对基于频谱的错误定位方法的有效影响,提出了结合类可疑度信息的错误定位方法.方法名称错误定位Tarantula语句级别SpaceSOBERAmpleOchiaiWong3FaultLocalization语句级别NanoXML,DIFABasedavg-SBD语句级别LOUPE语句级别SiemensSuitsC没有考虑3类封装特性对错误定位的有效影响近十年来,研究者对基于频谱的错误定位方法的研究主要集中于以下3方面:频谱度量算法的研究、频谱类型的研究和测试用例的研究.很少有研究者考虑不同语言特性,面向过程语言和面向对象语言所编写的程序差异性较大,本节分析讨论类特性对面向对象错误定位的有效影响.面向对象程序具有类、对象、封装、继承等特性.类刻划了一组对象所共有的属性和行为,封装了一组属性和方法,继承描述了类的层次结构,对象是面向对象程序运行时的基本活动单位.类是面向对象程序的基本组成单元,我们初步研究了类的封装特性对基于频谱的面向对象错误定位的影响.类具有封装特性,封装的方法和数据描述了一组对象的共同属性和行为.在面向对象程序中,语句包含在不同的类中,我们可以把类视为封装了一组语句的容器.通过运行测试用例得到语句覆盖信息,不同类容器的语句可能具有相同的覆盖信息,运用基于频谱的错误定位方法计算出的这些语句具有相同的含错可疑度,增加了错误定位的工作量.我们使用对象方法调用序列来描述类的行为,比较成功测试用例执行和失败测试用例执行中类行为的差异性,即基于Dallmeier等人[4]提出的基于方法执行序列频谱计算类可疑度值的思想,获得每个类的可Page3疑度信息.每个类容器中的语句结合所属类的可疑度信息,不仅可以区分不同类中具有相同覆盖信息语句的含错可疑度,而且使得错误语句的含错可疑度更大,从而减少错误定位的工作量,提高错误定位的效率.测试用例t45,5,5类可疑度0.8330.8590.833System.out.print(mid);}}S24······0.5150.58315-1.318-0.76718图1计算中值的Java程序我们使用Tarantula算法[14]和Wong3算法[3]对该面向对象程序错误定位.运行6个测试用例,搜集语句覆盖信息,图1中的“·”表示测试用例执行了这条语句,如图所示,类User、类Displayer以及类Cal的错误语句具有相同的语句频谱信息,Tarantula算法和Wong3算法计算出的这些语句具有相同的含错可疑度,可疑度值分别是0.5和-1.3,需要分别检查62.5%和75%的可执行代码如图1所示,该实例是包含有一条错误语句的3个类,S8是错误语句,有6个测试用例,其中t5是失败测试用例.User是一个输入数据的类,类Cal是用来计算3个整数的中值,Displayer是一个显示计算结果的类.t55,3,4t62,1,3··0.83340.8404050.2155··0.83340.8404050.2155··0.83340.8404050.2155·024024-17-0.757··0.83340.8404050.2155量才能定位到错误语句S8,定位效果并不十分理想.我们可以利用类信息来提高Tarantula和Wong3的错误定位效率.运行6个测试用例,除了搜集语句频谱信息,我们还搜集了每个对象方法的执行轨迹信息,使用对象方法执行序列的差异性来描述类的行为,通过描述类的行为,我们可以得到类的可疑度信息,获取类可疑度信息的方法我们将在第4节中详细阐述,结果如图1中左边第1列所示,Page4类User、Cal和Displayer的含错可疑度值分别是0.833、0.859和0.833.通过对图1中示例程序的每一条语句使用类可疑度信息结合算法,Tarantula和Wong3的错误定位效率有了明显提高,分别检查33.3%和45.8%的执行代码量就能定位到错误语句S8,定位效率均提高了约30%,类可疑度信息结合算法将在第5节中详细阐述.在后续章节中,我们将详细阐述如何提取类的可疑度信息,以及类可疑度信息的结合算法,并通过实验评估其有效性.4提取类可疑度信息对象之间通过消息传递进行通信,利用方法之间的调用实现相应功能,我们使用方法执行序列轨迹来描述类的行为,通过比较类的行为在成功测试用例执行和失败测试用例执行的差异性来获得类的可疑度信息.Dallmeier等人[4]提出了基于方法执行序列频谱计算类可疑度值的方法,主要思想如下:运行一条失败测试用例和多条成功测试用例,搜集每条测试用例对应的方法执行信息,得到每个对象的方法执行轨迹,并将轨迹按照一定长度划分为若干方法调用序列,将属于同一对象的方法调用序列聚集到对象的方法调用序列集合中,再把属于同一个类的对象的方法调用序列集合合并为这个类的方法调用序列集合,最后,根据方法调用序列频谱计算每个方法调用序列的可疑度值,每个类的方法调用序列集合的可疑度平均值作为这个类的可疑度值.他们通过实验验证了:方法调用序列长度为3~8的对象方法调用序列时,能够取得最好的类错误定位效果.Dallmeier等人并没有通过执行多条失败测试用例搜集方法执行信息,实际上,执行一条失败测试用例和多条成功测试用例获得的方法执行信息不能充分描述类行为.基于以上想法,本文提出了一种新的提取类可疑度信息的算法.我们使用了一组符号〈anp,anf,aep,aef〉来表示方法序列的频谱信息[19],每一个方法调用序列都对应着一个四元组.下标e和n分别表示测试用例执行和未执行方法调用序列,下标f和p分别表示测试用例失败和成功执行方法调用序列,例如,anp表示成功测试用例没有执行该方法调用序列的数量.一般情况下,包含错误的序列具有较高的aef值和较低的aep值.一个序列被较多的失败测试用例执行,却被较少的成功测试用例执行,则其可疑度越大,反基于函数调用序列频谱,函数调用序列p的可之,则其可疑度越小;一个序列没有被失败测试用例执行,被成功测试用例执行的数量越多,则其可疑度越大,反之,被成功测试用例执行的数量越少,则其可疑度越小.疑度w(p)计算公式为w(p)=3×%fail(p)1烄烅aef>0%pass(p),aef烆其中疑度值作为该类的可疑度值w(C):我们把类的函数调用序列集合S(C)的平均可w(C)=1/t∑p∈S(C)w(p)wheret=|S(C)|(2)根据本文提出的类可疑度信息获取算法,我们可以获得图1中3个类的方法调用序列集合S(Cal)={(Cal.m1),(Cal.〈init〉),(Cal.m2)},S(User)={(User.〈init〉),(Cal.Mid,Displayer.show)},S(Displayer)={(Displayer.〈init〉)}.根据表2中的方法序列频谱,使用式(1)计算出每个方法调用序列的可疑度值,使用式(2)计算每个类的可疑度值,最后得到3个类的可疑度信息.(Cal.m1)(Cal.〈init〉)(Cal.m2)(User.〈init〉)(Cal.Mid,Displayer.show)5100(Displayer.〈init〉)5类可疑度信息结合算法本节阐述如何利用类的可疑度信息来提高基于频谱的面向对象错误定位方法的定位效率,为了便于阐述,我们假设选取了一个基于频谱的错误定位工具ζ来定位错误语句,通过ζ可以计算每条语句s的可疑度值M(s),我们把结合类可疑度信息的ζ记为WithCI-ζ.在面向对象软件系统中,语句的数量通常比类Page5的数量大得多,Zhang等人[20]通过实验验证了面向对象软件系统规模与类数目的关系,得出了“Size=N×113.88”这个结论,其中Size是面向对象软件系统的规模,N是类的个数.Zhang等人的结论从一定程度上反映了面向对象软件中语句和类的数目在数量级上的差距.相应的,在基于频谱的面向对象错误定位中,需要检查的可疑语句的数量比可疑类的数量大很多,并且这些可疑语句通常分布在不同的类中,假设排在包含错误的语句之前的可疑语句分布在m个类中,定位到包含错误的类需要检查的可疑类的数目为n,显然,当n=1,结合类可疑度信息后,错误定位效率必然会提高,当1<n<m,随着n增大,结合类可疑度信息后,错误定位效率提高的程度会逐渐减小,当n>m时,则错误定位效率难以再提高.本文通过实验验证,在绝大部分情况下,类可疑度信息提取算法能够保证n<m,结合类可疑度信息,能够有效提高错误定位效率.一条语句s被ζ赋予的可疑度值M(s)越大,且语句s所属类的可疑度值越大,则该语句含错的可疑度就越大;反之,该语句含错的可疑度就越小.因此,我们以和的形式结合类的可疑度信息和语句可疑度信息来定位错误.由于两种可疑度信息在数量上的较大差异,相加时应被赋予不同的权重,语句可疑度信息相对较多,被赋予了较大的权重,相应的,类可疑度信息被赋予较小的权重.为了保证结合类信息的错误定位效率,我们首先把错误定位工具ζ得到的可疑语句按照Debroy等人[21]提出的基于失败测试用例执行数目的分组策略分成若干组,被失败测试用例执行越多的组,则该组可疑度越大.不同组的可疑语句结合不同权重的类可疑度信息,可疑度越大的组表明该组包含错误语句的可能性越大,则结合的类可疑度信息权重较大,同理,可疑度越小的组结合的类可疑度信息权重较小.通过分组策略,我们可以从一定程度上防止排名靠后的可疑语句通过结合类信息后,排名高于包含错误的语句.例如,给定两条可疑语句S1、S2,其中S1是包含错误的语句,S1可疑度排名在S2之前,S2所属类的可疑度大于S1所属类的可疑度,但是S1被分在了可疑度较高的组,结合类的可疑度信息的权重大于S2所结合的权重,在一定程度上能防止S2结合类可疑度信息后排名高于S1.我们首先将可疑语句分为1~n组,标记为G0,G1,G2,…,Gn-1,Gi中的下标i表示有i个失败测试用例执行了Gi组内的可疑语句.每条可疑语句只包含在一个组内,可疑语句和组具有多对一的映射关系.给定语句s,WithCI-ζ算法的可疑度计算公式为susp(s)=i×ti/totalf(∑ni=1其中上述公式中,totalfailed代表失败测试用例的总数,C(s)表示包含语句s的类,w(·)表示由式(2)计算得到的类可疑度值,M(s)表示由错误定位工具ζ计算得到的语句s可疑度值.我们以图1中的Tarantula方法为例来说明类可疑度信息的结合算法.由于实例中只有一条失败测试用例,我们把24条可疑语句分成两组,被失败测试用例执行的可疑语句分为G1组,其它可疑语句分为G0组.例如语句S8被失败测试用例t5执行,被分到G1组,S8属于类Cal,该语句的类可疑度信息w(C(S8))的权重为1,且M(S8)=0.5,w(C(S8))=0.859,基于式(3),我们得到语句S8结合类可疑度信息的可疑度值为susp(S8)=1.0×0.859/4+3.0×0.5/4=0.59.我们可以用同样的方法计算实例程序中余下语句结合类可疑度信息的可疑度值.6实验为了评估上述方法的有效性,本文选取3个Java开源软件作为实验对象,对其效果进行验证.6.1实验设计我们使用BCEL①字节码插装工具插装Java程序字节码获得函数执行轨迹,使用CodeCover②工具获得语句覆盖信息.3个实验对象的信息如表3所示.实验对象名称实验对象描述类的NanoXMLv1XML解析器1643345214NanoXMLv2NanoXMLv3NanoXMLv5JTopasv1文本数据1933414126JTopasv2解析器2141726145JTopasv3JAlignerv1序列对比软件1831981140①②Page6NanoXML和JTopas各个错误版本及相应的测试套件可以从http://sir.unl.edu下载得到,JAligner是基于Smith-Waterman算法的序列比对软件,包括140个测试用例,这些测试用例是由开发者生成的.3个实验对象里的错误都是植入的错误,NanoXML和JAligner都是植入的单错,JTopas既植入了单错也植入了多错,我们选取单错误版本作为实验对象.根据SIR的文档[22]以及研究者以前研究工作的实验[4,17-18],我们排除不产生失败测试用例的错误版本,总共有44个单错误版本作为实验对象.我们选取两种具有代表性的基于频谱的错误定位方法Tarantula和Wong3,并把本文提出的结合类可疑度信息的算法分别运用于这两种算法,为了便于描述,我们把结合类可疑度信息的Tarantula和Wong3算法分别记为WithCI-Tarantula和WithCI-Wong3.通过分别比较Tarantula和WithCI-Tarantula以及Wong3和WithCI-Wong3在上述3个实验对象上的错误定位效果,来验证本文算法的有效性.在实验中,只考虑可执行语句,排除空白行、注释以及不可执行语句.对每个错误版本,我们运行相应的测试套件对其进行错误定位,得到可疑语句排列,基于可疑语句排列来查找错误语句,把不需要检查可疑语句的百分比作为评估错误定位算法有效性的标准[23].6.2实验结果6.2.1总体效果及分析我们用图2和图3分别比较Tarantula和WithCI-Tarantula以及Wong3和WithCI-Wong3在44个单错误版本上错误定位的总体效果.x轴表示定位到错误不需要检查代码的百分比,y轴表示定位到错误的百分比.根据图2和图3所示的结果,我们观察得出结合类可疑度信息的错误定位算法的图2WithCI-Tarantula和Tarantula错误定位效果曲线总是在原算法的上方,表明结合类可疑度信息的错误定位算法的错误定位效率总是提高的.图3WithCI-Wong3和Wong3错误定位效果表4详细表示了图2和图3的结果.表中第1列表示检查代码的百分比,第2列到第4列分别表示原错误定位算法和相应结合类可疑度信息的错误定位算法在检查一定代码百分比下能够定位出版本错误的百分比.根据表4,检查1%的代码,WithCI-Tarantula和Tarantula分别能检查出45%和23%的版本错误,WithCI-Wong3和Wong3分别能检查出48%和30%的版本错误;要检查出所有的版本错误,WithCI-Tarantula和Tarantula需要分别检查30%和45%的代码,WithCI-Wong3和Wong3需要分别检查35%和60%的代码.检查代码百分比145.4522.7347.7329.55565.9054.5570.4563.641081.8268.1886.3665.911586.3681.8190.9177.272097.7386.3695.4579.552597.7388.6495.4581.8230100.0095.4597.7386.3635100.0095.45100.0090.9140100.0095.45100.0093.1845100.00100.00100.0093.1850100.00100.00100.0095.4555100.00100.00100.0097.7360100.00100.00100.00100.0065100.00100.00100.00100.0070100.00100.00100.00100.0075100.00100.00100.00100.0080100.00100.00100.00100.0085100.00100.00100.00100.0090100.00100.00100.00100.0095100.00100.00100.00100.00100100.00100.00100.00100.00图4和图5显示了Tarantula和WithCI-Tarantula以及Wong3和WithCI-Wong3错误定位效果的总体分散情况.每个箱形图上端的横线和底端的横线分别表示不需要检查代码百分比的最大值和最小Page7值,箱子的顶部和底部分别表示上4分位数和下4分位数,箱子内的横线表示中位数.我们可以从图中观察得到,结合类可疑度信息的错误定位算法总是比相应的原错误定位算法效果更好.图4WithCI-Tarantula和Tarantula箱线图图6WithCI-Tarantula和Tarantula在各个版本的错误定位效果图7WithCI-Wong3和Wong3在各个版本的错误定位效果从图6可以得出,75%(33/44)的错误版本的错误定位效果有所提高,5个错误版本的效果略微下降,其它的错误版本效果未变;WithCI-Tarantula和Tarantula各个错误版本定位错误不需要检查代码量百分比的平均值分别是95.06%和91.02%.为了6.2.2个体效果及分析图6和图7用柱状图分别表示了Tarantula和WithCI-Tarantula以及Wong3和WithCI-Wong3在各个错误版本上的错误定位效果.检测两组百分比之间是否存在统计上的显著差异,我们使用了Wilcoxon秩和检验,计算得到p值是5.56e-06,p值小于0.05,表明Tarantula结合类可疑度信息后,错误定位不需要检查代码百分比的增加具有显著性.Page8根据图7所示的结果,75%(33/44)的错误版本的错误定位效果是增加的,有3个错误版本的效果略微下降,其它版本效果没有变化;WithCI-Wong3和Wong3不需要检查代码百分比的平均值分别是95.55%和89.36%.同样,我们对这两组百分比运用Wilcoxon秩和检验,计算得到p值为8.428e-06,p值小于0.05,表明结合类可疑度信息的Wong3算法错误定位不需要检查代码百分比的具有显著性增加.6.3实验讨论本文算法是通过结合类的可疑度信息来提高基于频谱的面向对象错误定位方法的效率,类的可疑度信息对错误定位效率的提高起着关键作用.实验结果表明,本文提出的获取类可疑度信息的算法是有效的.通过上述实验,我们得到查找错误类平均需要检查类的数量是2.32,利用Dallmeier提出的基于一条失败测试用例执行信息的Ample算法得到查找错误类平均需要检查类的数量是2.42,实验表明本文提出的提取类可疑度信息的方法更有效;利用Tarantula和Wong3算法计算得到排在错误语句前的可疑语句平均分布在4.52个类中.在获取类的可疑度信息时,如果失败测试用例的数量太少或者只有一条,会在一定程度上影响类可疑度信息的提取.在上述实验结果中,总共有8个错误版本的效果略微下降,平均下降了1.26%.其中,有5个错误版本只有一条失败测试用例,提取的类的可疑度信息不够有效而导致的效果略微下降;剩下3个错误版本的Tarantula和Wong3算法的错误定位效果非常好,平均检查可疑度语句百分比是1.46,平均分布在2.12个类中,而相应的类可疑度信息还不够有效,平均检查类的个数是3.75,从而导致这3个版本的效果略微下降.在以上实验中,未结合类可疑度信息的Tarantula和Wong3算法在许多错误版本中定位效果不够好,通过结合类可疑度信息后,其定位效率得到了很大提升;对于Tarantula和Wong3错误定位效果好的版本中,在绝大部分情况下,结合类可疑度信息后,其定位效率依然能够得到提升.实验结果表明,结合类可疑度信息对基于频谱的面向对象错误定位是十分有效的.7结论本文对基于频谱的面向对象程序错误定位进行了研究,分析讨论了类的特性对基于频谱错误定位方法的影响,提出了结合类可疑度信息的错误定位方法,选取了3个Java开源软件作为实验对象,并分别比较了Tarantula和结合类可疑度信息的Tarantula算法,以及Wong3和结合类可疑度信息的Wong3算法的错误定位效果.实验结果表明,本文方法能够有效提高基于频谱的面向对象程序错误定位效率.在未来的工作中,我们将致力于以下两个方面:(1)把本文提出的算法应用到基于分支覆盖或者基于定义-引用覆盖的面向对象错误定位方法中,并通过实验评估其有效性.(2)我们希望能够结合基于频谱的错误定位方法提取函数调用的上下文信息,力求在查错过程中给出搜索错误语句的相关路径信息,有助于在搜索错误语句过程中理解错误,更快地找到错误.
