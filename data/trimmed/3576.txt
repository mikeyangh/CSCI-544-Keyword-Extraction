Page1在线-离线数据流上复杂事件检测彭商濂1)李战怀1)陈群1)李强2)1)(西北工业大学计算机学院西安710129)2)(西北工业大学软件与微电子学院西安710072)摘要随着数据采集和处理技术的发展,在物联网对象跟踪、网络监控、金融预测、电信消费模式等领域中进行事件检测显得越发重要.事件检测在一次扫描数据流的假设下完成,数据流在被处理完后丢弃.事实上,很多应用场景中,历史数据流因含有丰富的信息而不能简单丢弃,且一些事件检测查询需要同时在实时和历史数据流上进行.鉴于已有复杂事件检测很少考虑同时在实时-历史数据流上进行模式匹配,作者研究了在线-离线数据流上复杂事件检测的关键问题.主要工作如下:(1)针对滑动窗口内产生的大量模式匹配中间结果,提出利用时态关系和时空关系管理中间结果的方法TPM和STPM.STPM以中间结果的时态和状态信息为权值对中间结果进行管理,将最近的、最有可能更新状态的中间结果置于内存,极大地减少了中间结果的读取操作代价.(2)给出了基于选择度的在线-离线复杂事件检测优化算法;(3)给出了算法的复杂性分析和代价模型;(4)在基于时空关系的中间结果管理模型下,在一个在线-离线复杂事件检测原型系统中进行实验,对多个参数(子窗口大小,选择度,匹配率,命中率)进行了算法对比分析.实验结果充分验证了所提出的算法的可行性和高效性.关键词物联网;复杂事件检测;数据流;非确定有限状态自动机;RFID;无线传感器网络1引言随着逐渐增多的应用领域(如金融业、网络监控、基于RFID的供应链管理、医疗监控、物联网应用等)需要处理大量分布、高速的数据流,复杂事件检测(ComplexEventProcessing,CEP)变得越发重要[1-2].用户通过复杂事件定义语言描述需要检测的模式(复杂事件),复杂事件检测引擎将用户定义的模式解析为自动机或树模型,然后在事件流上进行事件检测.在当前的复杂事件处理系统中,一般假设事件流以一次扫描的方式被扫描,且处理完后就被抛弃,无需进行归档.事实上,一次扫描数据流并没有充分发掘数据流的价值,用户将查询定义在数据流上也只能描述一部分现实世界的查询需求.正如下面列举的实例显示,数据流上的复杂事件查询不但需要处理实时数据流,同时也需要访问历史数据流.示例1:汽车行驶时间实时计算(如超速监控).高速公路上,汽车上安装有主动RFID电子标签用于身份识别和跟踪;高速公路收费点或沿路的监控点都安装了RFID阅读器.当汽车经过高速公路收费点时(或途中的监控点时),这些阅读器可以跟踪单辆汽车,并记录其速度信息.为了计算当前点和上一个点的行驶时间,需要从实时数据流上取出事件记录,然后查询历史数据流寻找上一个点的时间信息,判断是否超速行驶.该查询如图1所示,是用文献[3]中的基于SQL的查询语言描述的.示例2:股票趋势预测.股票的趋势预测信息可以辅助投资者进行股票的买进或抛出.投资者可以在股票流上定义如下的复杂事件查询:当在一支股票的实时数据流上检测到一个下降模式(“\”)时,在历史股票流上检测一个勾模式(“√”),该查询如图2所示,也用文献[3]中查询语言描述.这些示例表明,复杂事件检测需要同时集成在图1基于RFID的高速公路行驶时间监控事件查询线数据流与离线数据流的处理.在线-离线复杂事件处理在实际应用中需面对下列挑战:(1)海量高速的流数据.应用场景很容易产生GB级到TB级的流数据(如在基于RFID的电子超市),如何有效地存储这些数据是在线-离线复杂事件处理的重要问题;(2)复杂事件中间结果管理.在很多复杂事件检测应用中,用户定义一个很大的时间窗口W.随着复杂事件检测的推进,在W中的复杂事件的中间结果数量将变得非常巨大.同时在历史数据流上复杂事件检测的中间结果也将随之增大.在复杂事件处理节点内存资源有限的情况下,如何对这些生命周期在W内的中间结果进行有效的管理对复杂事件检测的响应时间具有重要影响.(3)数据流中事件分布的不同使得事件检测在实时数据流和历史数据流上的实例数目也不同,导致历史流的访问请求次数的不同和历史流上模式的重复计算,利用数据流中事件类型的选择度和不同实例的历史流访问区间交叉等特性对在线-离线事件检测顺序的进行调度可以有效减少复杂事件的响应时间.当前的复杂事件检测主要针对实时数据流,很少考虑再次访问历史流.与本文工作最为接近的是Moirae[4]和Dejavu[5-6].Moirae是一个集成了流数据处理和数据库技术的数据流处理引擎(StreamProcessingEngine,SPE).Moirae支持4类查询:事Page3件查询、标准混合查询、上下文查询、上下文混合查询.Moirae设计的假设是:查询整个历史日志(数据)太慢以至于不能满足应用的响应要求,所以返回最相关的近似查询结果是合理的.基于该假设,Moirae提出了历史流分区存储、最近访问的事件物化、查询执行分解和历史查询调度等设计方法.可以看出,这些方法都不是全新的,且已经应用到数据库的相关领域.由于复杂事件检测要求的是准确的查询,所以Moirae的设计不能直接用于CEP.Dejavu是一个集成了在实时-历史上进行复杂事件检测的SPE.Dejavu通过扩展SQL语言以便支持复杂事件的定义(如增加模式匹配字句MATCH_RECOG-NIZE[3]),使该事件处理引擎可以定义复杂事件查询,同时通过扩展MySQL的读写数据API,使得该引擎支持快速的数据流归档.在Dejavu中,为避免历史数据流的重复计算,使用了结果缓存的数据结构将历史流上的模式缓存,以便为实时流上后续的复杂事件检测共享使用.此外,通过利用实时数据流和历史数据流的选择度不同来调整这两个流的连接顺序以优化事件检测查询的执行.在Dejavu中,作者主要考虑股票流上连续模式的在线离线复杂事件检测.由于离散模式的子事件可能分布在数据流的任意位置,中间结果缓存及相应的优化算法都需要重新考虑.作者研究了基于离散模式的在线-离线复杂事件检测,文献[7]是作者的初步工作,提出了基于离散模式的在线-离线复杂事件检测的系统结构和基本处理方法.本文在文献[7]工作的基础上,增加了下列研究内容:(1)针对大滑动窗口内产生的大量模式匹配中间结果,在系统结构中增加了中间结果管理的模块,提出利用时态关系和时空关系管理中间结果的方法TPM和STPM.STPM以中间结果的时态和状态信息为权值对中间结果进行管理,将最近的最有可能更新状态的中间结果置于内存,极大地减少了中间结果的读取操作代价.(2)增加了基于选择度的在线-离线复杂事件检测优化算法;(3)给出了算法的复杂性分析和代价模型;(4)在基于时空关系的中间结果管理模型下,重新进行了实验设计,进行了相关算法的对比分析.本文第2节介绍相关工作;第3节介绍事件模型、问题定义和在线-离线事件检测架构;第4节介绍在线-离线CEP检测算法及其优化;第5节描述中间结果管理策略;第6节为实验结果分析;第7节总结全文和下一步工作展望.2相关工作复杂事件检测是一种从简单事件集合中关联出更具有语义的复杂事件的数据分析技术,最早在基于trigger和ECA规则的主动数据库[8-9]中应用,随后在基于关键字或简单谓词的Publish/Subscribe系统中应用[10].随着流数据处理系统的推广,结合窗口概念的复杂事件检测也被集成到数据流管理系统(DataStreamManagementSystems,DSMS)中.典型的系统有Aurora[11]、TelegraphCQ[12]和HiFi[13]等.这些系统主要针对与数据流的连接(join)、聚集(aggregation)和一些统计(statistics)操作,不适用于定义复杂事件检测的查询.SASE[1,14-15]、ZStream[16]和Cayuga[2]是流数据上复杂事件检测的3个比较著名的原型系统.它们各自有事件定义语言(基于类SQL或声明型定义语言)和查询模型(如自动机模型、树模型)及相应的优化策略,但缺少集成历史流访问的复杂事件定义和检测的支持.Page4文献[8,17]研究了在传统数据库上进行模式匹配的相关问题[3],包括模式定义语言、算子语义和查询模型.这些工作缺乏对流数据上事件检测的考虑,也不适用于流数据上更为复杂的事件查询.Moirae[4]和Dejavu[5-6]是两个与本文工作最为接近的实时-历史数据流查询系统.Moirae主要研究在不可能遍历整个历史流情况下如何为查询返回最相似的结果的问题,精确的查询结果可以通过逐步求精的方式获得.Moirae通过将已有数据流、数据库和存储等方面的技术集成到一个框架中,支持多种类型的查询.本文工作与Moirae的不同之处在于,本文考虑的复杂事件查询要求精确结果且复杂事件有可能分布在较长的时间区间内,考虑如何快速、完整检测数据流上的复杂事件,同时考虑在复杂事件中间结果较多而引起系统负载较大时如何降载的问题.Dejavu是一个集成实时-历史数据流处理的复杂事件系统.Dejavu通过声明性的模式匹配语言定义复杂事件.在Dejavu中,数据的存储架构基于开源的数据库系统MySQL.通过在系统中集成MySQL的可插入式API,Dejavu引入DStream和DArchive这两类存储结构,并在DStream和DAr-chive之间设计了一个最近处理过的事件缓冲区(RecentBuffer)来平衡实时流和历史流归档操作,同时为历史流上的复杂事件检测提供数据源.在Dejavu中使用了结果缓存(ResultsCache)数据结构存储在历史流上寻找到的模式,以便为后续的模式匹配使用.Dejavu所处理的在线-离线复杂事件检测主要针对连续模式(如在股票数据流上寻找“勾”),而Dejavu中的离散模式主要是实时处理.此外,Dejavu中的中间结果缓存基于如下的观察:历史流上检测到的一个实例可能被实时流上的多个实例访问,所以把已经加载的历史流上的所有模式检测出来并缓存有利于减少重复计算和数据加载.但我们观察到,连续模式其实是更为一般的模式———离散模式的特例,离散模式并不严格要求子事件的顺序,即离散模式的中间结果(子事件)可能分散在实时流和历史流的任何可能位置,所以将历史流上的所有中间结果计算出来缓存在内存对离散模式的在线-离线复杂事件检测是不适用的.Chandrasekaran[18]等研究了在DSMS中集成历史数据流查询的问题,主要工作包括存储管理器降载及查询结果精度之间的折中、索引插入和归档查询降载及各种查询在实时流和历史数据流上的无缝执行[19].研究通过位图索引对历史数据流进行存储和更新.他们的工作主要针对实时-历史数据流上的聚集、统计操作,不适用于复杂事件检测.复杂事件处理的相关工作包括中间件[20-25]、RFID数据流上的复杂事件检测[1,7,14,26-27]、乱序数据流上的复杂事件检测[28-31]、嵌入序列复杂事件检测[32]、基于不确定模型的事件检测等[33].其中文献[1,14,26]研究在实时数据流进行复杂事件检测,没有考虑实时-历史数据流集成的复杂事件检测.文献[7]是作者对在线-离线复杂事件检测的前期基础研究工作,但没有更为高效的中间结果管理方案和复杂事件检测优化算法.3事件模型与问题定义3.1事件模型定义1.原始事件.原始事件是指不能再分解成子事件的事件.原始事件是由一些属性组成的元组(tuple),记为e(TID,state,Timestamp,〈attri-List〉),其中state为事件类型标识,TID为对象标识,Timestamp为事件发生的时间戳,〈attriList〉为事件的其它属性列表.本文中,事件类型用大写字母E表示,E对应的实例用小写e表示.原始事件语义简单,实际应用中需要将原始事件转换为语义更为丰富的复杂事件.定义2.复杂事件.将原始事件/复杂事件通过事件算子,如SEQ(序列)、AND(与)、OR(或)、NOT(非)等,组合成的事件称为复杂事件.定义3.连续模式.对于一个模式P,如果构成该模式的子事件要求连续地出现在数据流中,称模式P为连续模式.定义4.离散模式.对于一个模式P,如果构成该模式的子事件可以出现在数据流中任何位置,则称模式P为离散模式.可见,离散模式是一种更为通用的模式,包含了连续模式.定义5.在线-离线数据流上事件检测.如果复杂事件检测由在实时流上的模式和离线流(历史流)上的模式组成,则称为在线-离线数据流上事件检测.3.2复杂事件定义语言复杂事件通过事件定义语言描述,目前常用的事件定义语言包括类SQL型语言[3]和声明型语言[1].本文对文献[3]的基于SQL的复杂事件定义语言进行了适当的扩充以便定义在线-离线复杂事件查询,事件定义语言的结构如下:Page5SELECT〈selectedfieldslist〉FROM〈streamsortables〉MATCHRECOGNIZE([PARTITIONBY][ORDERBY〈fieldname〉][MEASURES〈measurelist〉][ONE/AllROWPERMATCH][AFTERMATCHSKIPTONEXTROW/PASTLASTROW/…]PATTERN(patterndescription)DEFINE〈eventsconstraintslist〉[WINDOW〈windowspecification〉])其中MATCH_RECOGNIZE子句表示模式匹配的入口;PARTITIONBY将事件流按某属性进行分区;ORDERBY将事件流按一定属性排序;MEA-SURES子句将事件的一些属性重新命名;ONE/ALLROWPERMATCH和AFTERMATCHSKIPTONEXT是模式匹配的事件选取策略;PATTERN字句中定义要检测的模式;DEFINE描述复杂事件的约束条件;WINDOW子句定义了复杂事件的有效时间区间.如图3所示,(a)表示的是Query2定义的检测在线-离线股票流上的连续模式,(b)中描述的是基于RFID的供应链监控中数据流上的离散模式.3.3在线-离线复杂事件检测架构在线-离线数据流上复杂事件检测系统结构如图4所示.事件流通过网络接口进入事件流路由器,事件流路由器可以过滤一些不相关的数据流.数据流以追加的方式存储于时实流缓冲区中,该缓冲区的数据一方面可以为实时流上的复杂事件检测提供源数据,一方面也可以为历史流上的复杂事件检测提供源数据,且数据流的归档可以通过该缓冲区批量完成.数据流原始数据存储在关系数据库或文件系统中,并可以按事件的ID或时间区间进行反复读取.历史数据流的并发读写通过信号量来控制.在事件检测过程中,没有达到完全匹配且没有超出滑动窗口的部分模式匹配在系统负载较大的时候被归档到部分匹配数据库中.数据流处理引擎接收用户定义的复杂事件查询,并将事件查询解析为数据流处理器里对应的查询执行模型(如自动机、树或Petri网),数据流处理器分别从实时流、历史流(通过归档事件抽取器)和部分模式匹配数据库(通过部分匹配抽取器)读取相应的数据进行在线-离线复杂事件模式匹配.归档事件抽取器中分别以事件的ID(Hash索引)和事件归档的时间(B+树索引)建立二维的索引结构,支持单个历史事件和某个时间区间上的历史事件的访问.部分匹配抽取器中以中间结构的ID构建Hash索引,以支持快速的中间结果的读取、更新及删除操作.4在线-离线复杂事件检测在线-离线流上复杂事件检测需要在实时数据流和历史数据流上进行,由于实时流和历史流处理模式的不同而导致复杂事件检测响应时间的不同.本节介绍两种在线-离线复杂事件检测算法并分析它们的代价模型,代价模型的相关标识如表1所示.Page6标记WLInstRAPLPAPMCostLCostANInstLNInstACostWDBCostWPMCostRDBCostPLPANP4.1主动在线-离线事件检测算法在线-离线数据流上复杂事件检测的一种算法为主动算法(ActiveLive-ArchivedEventDetectionAlgorithm,ALAA).ALAA的算法描述如算法1所示.算法1.主动在线-离线事件检测算法.输入:PL,PA,WL,RA输出:检测到的复杂事件CECoBegin1.初始化实例链表PML、PML、InstL和InstA为Null;2.对于实时流上滑动窗口WL内的事件3.进行复杂事件PL的检测;4.将达到最大状态的PL实例放入InstL中;5.将未达到最大状态的PL实例放入中间结果集合6.计算最大的历史流访问区间Rmax;7.对于Rmax内的事件8.进行复杂事件PA的检测;9.将达到最大状态的PA实例放入InstA中;10.将未达到最大状态的PA实例放入中间结果集11.将InstL中的实例与InstA中的实例在EventID属12.CE=InstLEventID∧RAi∧PInstA;13.归档历史流数据,处理下一个滑动窗口WL;CoEndALAA算法对于实时数据流上PL和历史数据流上PA的检测是并行进行的,并通过消息进行通信.当实时流上检测完一个滑动窗口WL长度的PL后,SPE通知复杂事件连接器将InstL中的实例和已检测出的InstA实例进行事件标识(EventID)或其它属性(如RAi,P)的连接操作,生成最后可以输出的复杂事件.ALAA算法示意如图5所示.ALAA算法的代价模型.ALAA算法的代价模型主要由下面几部分组成:(1)在实时流上进行PL事件检测的代价;(2)在历史流上进行PA事件检测的代价,这部分代价包括将实时数据流归档的代价和将数据流从外存读取到内存的代价;(3)将InstA实例和InstA实例进行连接操作的代价:CostALAA=|WL|×CostL+|Rmax|×CostRDB+|Rmax|×CostA+CostPLPA×NInstL×NInstA(1)从代价模型可以看出,实时流滑动窗口WL的长度和数据流的流速决定了复杂事件的数目,数据流流速越大,窗口长度越长,则实时流上复杂事件检测所需要的计算资源就更多,计算代价也增大.此外,由于实时数据流是缓冲在一个缓冲区结构中,该缓冲区在为复杂事件检测提供数据源,同时已经处理的数据流也将以批量方式插入数据库,所以缓冲区的大小决定了批量插入的规模,这里需注意的是:缓冲区越大,给SPE所能分配的存储资源就越小,同时,批量插入数据库的代价CostWDB也将增加.最后,实时和历史流上的复杂事件实例连接操作代价CostPLPA为在所有已检测出来的InstA和InstL上进行连接操作的代价.ALAA算法的不足在于它需要检测历史流中所有存在的PA模式实例,无论该实例是否参加后续的模式匹配.可以看出,ALAA算法是一种直接但比较盲目的算法,它没有利用到数据流中各个事件类型的选择度特性来减少复杂事件检测的计算代价.因此,我们介绍另外一种在线-离线复杂事件检测算法.4.2被动在线-离线事件检测算法在线-离线数据流上复杂事件检测的另外一种算法为被动算法(LazyLive-ArchivedEventDetec-tionAlgorithm,LLAA).与主动算法不同,被动算法只有在其中一个数据流上检测出达到最大状态的实例后才触发另外一个数据流上的复杂事件检测.LLAA算法的执行是一个顺序交替的过程,如算法2所示.算法2.被动在线-离线事件检测算法.输入:PL,PA,WL,RA输出:检测到的复杂事件CE1.对于实时流WL内的每个事件eiPage72.检测是否存在对应的PL实例InstLi3.如存在,但将ei的状态更新至InstLi后没达到4.如存在,且将ei的状态更新至InstLi后达到最5.计算InstLi的历史流访问区间RAi;6.将RAi对应的数据流读取到内存,检测历史流7.在事件ID属性上对实例InstLi和InstAj进8.输出CEi;9.处理WL中的下一事件e.LLAA算法的执行示意图如图6所示.算法的执行可以从实时流或历史流上的事件检测的任意一边开始.算法2中是从实时流开始.当实时流上检测到一个PL实例后,就触发一次归档流上的PA的复杂事件检测.为了减少数据流的重复扫描和计算,LLAA算法一次把RAi对应的历史流加载进内存并将RAi上的所有的PA实例都检测出来,此操作是基于对实际应用场景中的观察:相似的模式总有聚集出现的现象,如在一个传送带上,监控物品经过某几个点的路径总是聚集在数据流的一个事件区间上出现.当RAi上的所有的PA实例都检测出来后,将实时流上的InstLi实例与它们进行一些约束关系(如EventIDi,RA等)的连接操作,生成可输出的复杂事件,然后进行下一个实时流事件的处理.LLAA算法的代价模型.LLAA算法的代价模型包括如下几部分:(1)处理实时流WL中的每个事件的代价;(2)读取InstLi对应的历史流到内存的代价;(3)在InstLi对应的历史流上进行PA检测的代价;(4)InstL与InstA进行连接操作的代价:CostLLAA=WL×CostL+NInstL×CostRDB+∑NInstL在该代价模型中,NInstL×CostRDB为所有达到最大状态的实时流上的实例触发的历史流访问的代价,∑NInstLRAi上的复杂事件的代价,CostPLPA×NP为实时流i=1和归档流上达到最大状态的实例连接操作的代价.LLAA算法的复杂度为O(|WL|×|RA|).LLAA算法是一种基于实时流上单实例驱动的算法,即只有实时(历史)数据流上存在一个最大状态的实例时,才触发另外一个数据流上的复杂事件检测.实际上,基于单个实例的LLAA事件检测的方法没有利用到实时流上临近的实例访问历史流区间重叠,导致多次外存数据的请求和重复的计算,因此在下节我们介绍如何利用数据流的选择度和模式的聚集特点优化LLAA算法.需要注意的是,本文提出的LLAA算法和文献[6]中的LazyPatternProcessing都是基于触发式的查询处理方法,即先在实时流上循环处理,待检测到一个实时流的实例后,再作历史流的处理.在文献[6]中,由于针对的是连续模式的查询,第一次历史流访问后的所有实例按时间顺序存储,并在新的实时流实例被检测到时删除不可能存在匹配的历史流上的实例.由于本文处理的是离散模式,触发历史流访问的实例可能存在于实时流的任何位置,因此需要缓存很多实时流的实例,且每个实时流实例访问历史流的时机不一样,因此历史流上计算出来的实例也不能简单的删除.所以,本文的LLAA虽在结构上和文献[6]相似,但因为处理的问题的差异,所需要的存储和计算代价是不一样的.另外,本文使用B+树结构存储原始事件和中间结果,可以更为快捷地进行状态更新、批量数据库插入、批量过期事件的删除等操作.4.3优化LLAA算法P选择度SelP定义为定义6.选择度.给定一个模式P,事件流S,即数据流上匹配模式P的实例的数目占事件流大小的比例.可见SelP越大,则表明事件流S中匹配P的实例数目越多;SelP越小,S中匹配P的实例数目越小.SelP常来确定最佳的查询执行计划(如连接操作中,用较小SelP的对象集合连接较大SelP集合可大大减少连接操作的代价).(1)基于SelP的LLAA算法优化在LLAA算法中,SelP可以用来选择实时流和历史流的连接顺序,如SelPL<SelPA,则InstLInstA可以减少历史流的加载和重复计算;如果SelPA<SelPL,InstAInstL可以减少实时流上不会产生最终输出的模式匹配的计算.由于历史流存储在静态的文件或数据库上,其选择度可以通过数据库管理Page8系统的工具得到;对于实时流,选择度可以通过应用场景的先验知识或进行统计抽样等技术计算.基于选择度的实时流-历史流连接顺序选择如图7所示.图7中,实时流的滑动窗口WL中有3个PL实例,而WL对应的历史流访问区间RA中有6个PA实例,SelPL<SelPA,所以在当前滑动窗口中选择实时流连接历史流以减少历史流的加载与计算.图7LLAA算法数据流连接顺序选择示意图(2)基于子窗口的LLAA算法优化虽然通过选择度可以减少部分历史流的加载与计算,但当WL存在多个PL实例,且每个实例都对应自己的归档流访问请求,如果采用检测到一个PL实例触发一次历史流的访问与计算,将会导致多次数据流的请求,且没有利用到临近PL实例访问的历史流具有交叉的性质.如图8所示,实时流上存在7个PL实例PL1~PL7,如果按照算法2的复杂事件检测方法,需要进行7次历史流访问,虽然可以通过结果缓存共享一次加载的历史流计算结果,但是两个历史流未交叉的部分还需要加载和计算.如图8中的历史流访问区间RA2-RA3,RA4-RA5-RA6,它们之间都存在交叉,此时如果将RA2-RA3,RA4-RA5-RA6分别作为一个处理单元进行加载和计算,可以减少数据库的访问请求操作和重复计算.图8基于子窗口的LLAA算法执行示意图因此,我们利用实例间的聚集特性将滑动窗口划分为多个子窗口,以子窗口为单位进行在线-离线复杂事件检测.如何选择合适大小的子窗口与复杂事件输出的延迟直接相关:如果子窗口选择较小,则可能导致多次的历史流访问请求和计算,增加响应时间;如果子窗口选择较大,则可能导致较长的复杂事件输出的延迟.引理1.给定一个在线-离线复杂事件查询,一个用户定义的容忍延迟时间TL,对于滑动窗口|min{Ikestarttime}-Ii+jeendtime|TLW内达到最大状态的复杂事件实例序列I1,I2,…,In,实例Ii,Ii+1,…,Ii+j被划分到第i个子窗口WSubi当且仅当且|min{Ikestarttime}-Ii+j+1eendtime|TL.其中,ik(i+j),Iiestarttime表示第i个达到最大状态的实例的最后一个子事件的时间戳,Iieendtime表示第i个达到最大状态的实例的最后一个子事件的时间戳.引理1表明WSubi的长度为该窗口中具有最大eendtime的实例与具有最小estarttime的实例的时间差.基于子窗口的LLAA如算法3所示.算法3.基于子窗口的LLAA算法(SLLAA)输入:PL,PA,WL,RA,TL输出:检测到的复杂事件CE1.对WL中的事件进行复杂事件PL的检测;2.根据引理1计算子窗口WSub的大小;3.计算WSub中实例访问历史流的最大区间RAi=4.对于RAi内的事件5.进行复杂事件PA的检测;6.将达到最大状态的PA实例放入InstAj中,7.如果RAi中的事件已处理完8.将InstLi中的实例与InstAj中的实例在9.输出满足约束的复杂事件CE;10.处理滑动窗口WL内的其它事件;11.如当前WL一处理完,删除失效的事件和中间在算法3中,滑动窗口WL按实例聚集被划分为若干小的子窗口WSub,离线复杂事件检测以子窗口为单位进行,子窗口的大小决定历史流的访问和计算频率:如果|WSub|=1,复杂事件检测就等价于LLAA算法;如果子窗口过大,如|WSub|=|WL|,即将整个窗口的实时流处理完后再进行历史流的处理,则复杂事件检测的平均响应时间将增加.SLLAA算法的代价模型如下:CostLLAA=|WL|×CostL+n×CostRDB+Page9i=1其中n×CostRDB为以n个WSub单位读取数据库的代价,∑n匹配的代价.SLLAA的算法复杂度为O(|WL|)maxi∈[1,n]{|RAi|}),可以看到,只要选择了合适的n,SLLAA算法的代价比LLAA的要小很多.以实时流上达到最大状态的实例集合为单位进行历史流访问时,为了确保事件检测的完整性(防止复杂事件的漏检)和一致性,需要将实时流和历史流上未达到最大状态,但生命周期还在滑动窗口WL内的部分匹配结果缓存起来,以便后续的事件检测进行相应的状态更新.5中间结果管理随着数据流的流速的变化和复杂事件检测的推进,复杂事件检测将产生大量未到达最大状态的部分模式匹配结果(partialpatternmatchresults简称中间结果,PM).例如在一个基于RFID的实时物品监控场景中,用户定义一个检测10h内经过RFID阅读器A,B,C和D的物品,该复杂事件可以描述为一个序列(SEQ)模式P=SEQ(A;B;C;D)[10h],假设滑动窗口为tumbling类型(处理完一整个窗口后向前滑动),模式匹配缓冲区大小是固定的.则在缓冲区中存在着的中间结果集PM={A,SEQ(A;B),SEQ(A;B;C)}的实例,这些实例随着复杂事件的推进可能溢出缓冲区,为了保证复杂事件检测的完整性和一致性,需要对这些没有超出滑动窗口区间的中间结果进行归档,并在复杂事件检测过程中不断更新它们的状态.在线-离线复杂事件检测同样存在中间结果管理的问题,我们主要针对实时流介绍相关管理算法,历史流的中间结果管理类似.5.1基于时态的中间结果管理基于时态的中间结果管理(TemporalPartialMatchManagement,TPM)方法如图9所示.中间结果按产生的时间顺序被放入中间结果缓冲区,缓冲区中存储的是中间结果的全部信息(例如事件标识符TID、事件的状态State、中间结果产生的时间TS和最后更新的时间TE),通过一个B+树数据结构来辅助中间结果的状态更新操作和插入,其中B+树的键值为(TID,State),树的叶节点指向对应的中间结果实体,其记录一直存储在内存中,直至对应的中间结果输出复杂事件或该中间结果无效才被删除.中间结果缓冲区有一个归档的界限,当达到这个界限时就通过PMR将对应区间上的中间结果写入到外存文件系统.当数据流中的事件触发中间结果状态更新时,如该中间结果不在缓冲区,则通过PMR将其读入,并进行状态更新操作.TPM是一种利用中间的时态关系管理中间结果的方法,可以看到,当数据流的流速增加时,TPM会频繁地将产生的中间结果归档到外存,而当实时流中的事件触发中间结果状态更新时,由于其对应的中间结果有可能不在内存中,TPM需要到中间结果存储区(PMS)中去读取,这就导致了中间结果频繁的被读写操作.TPM这种中间结果管理方法适用于中间结果更新少的应用,批量的中间结果归档很高效.如图3(a)中的股票流上连续模式的在线-离线复杂事件检测,历史流上的“√”模式被检测出来后就不需要进行更新,而实时流上的“\”模式只与后续的股票事件关联,不需要去访问历史的中间结果.但对于图3(b)中的离散模式,TPM就不适用了.因为离散模式的子事件分布在数据流的任意时间点,在未达到复杂事件的输出状态且滑动窗口未滑动没有滑动前,中间结果还处于在其生命周期中,数据流上新的事件随时都可能触发中间结果的状态更新操作,所以TPM只利用时态关系管理中间结果是不够的,还需要考虑中间结果的空间信息.5.2基于时空关系的中间结果管理针对TPM管理中间结果的不足,提出基于时空关系的中间结果管理(SpatialTemporalPartialMatchManagement,STPM)方法,如图10所示.STPM方法中,中间结果的时态关系以优先级的方式体现,优先级定义如下.定义7.中间结果优先级.假设给定一个模式P=SEQ(E1,…,Ei,E(i+1),…,En),事件类型Ei和E(i+1)的事件发生的时间间隔最大值为Δti,p(E(i+1)|Ei)为Ei类型事件发生后E(i+1)类型事件发生的条Page10件概率.对于数据流上的一个Ei类型(i<n)的事件e,它产生的中间结果PMe的优先级WPMe定义为即中间结果优先级定义为简单事件当前的时间与下个类型事件可能发生的时间间隔之和.WPMe体现了中间结果的时空信息.基于WPMe的中间结果管理如过程1所示.过程1.STPM.1.对于一个事件e2.如在PMB存在它的PMe实体3.tmpState=PMeState;4.PMeState=PMeState∪eState;5.如果tmpState≠PMeState;6.//在TreeWPM插入一条记录7.WPMe=et+Δti×p(E(i+1)|Ei);8.TreeWPMInsert(WPMe,eTID,eState)9.如果PMB达到归档上限ΔR10.PMRWrite(ΔR,TreeWPM,PMB);11.如在PMB不存在它的PMe实体,但存在其Hash12.PMRWrite(eTID,PMS)PMRWrite(eTID,13.处理下一个事件.当事件e进入复杂事件处理引擎后,首先查询PMB中是否存在它的PMe实体.如存在,则需要将e的状态更新到PMe上,如PMe的状态未更新(说明该事件已出现过,如RFID数据流中的重复读事件),则不需更新优先级树TreeWPM,否则根据式(5)计算PMe的WPMe,并在TreeWPM插入一个新的记录.需要注意的是,同一TID的事件在TreeWPM上可能对应多条记录,权值越小的记录越靠近树的左边,在归档过程中可以通过与中间结果的状态比较将不是最新状态的TreeWPM记录删除,减少TreeWPM的操作.中间结果的归档是通过一个计数器ΔR,当中间结果中的记录达到ΔR时就进行一次归档操作:在TreeWPM上按优先级从小到大取ΔR长的中间结果进行归档.归档时要比较TreeWPM上记录的状态和中间结果的最新状态,将不是最新状态的TreeWPM上的记录删除,将是最新状态的记录归档到PMS.对于实体不在内存的中间结果,需要通过PMRWrite(eTID,PMS)将其读入,更新其状态和TreeWPM.可以看到,STPM是一种启发式方法,它始终将时态信息和状态信息最新的中间结果保留在中间结果缓冲区,以便为复杂事件检测提供更高的命中率,减少复杂事件的输出的响应时间.STPM的不足在于进行中间结果归档时,基于Hash的方法无法按中间结果时间属性直接进行批量插入操作,但可以通过对将归档的中间结果排序来完成,所以STPM稍作调整后也适用于连续模式的中间结果管理.此外,STPM的TreeWPM虽然可能存储了多个TID相同的记录,但随着复杂事件检测的推进,这些记录会被不断地删除掉,所以STPM耗费的空间代价与TPM只有微弱的差异.6实验结果与分析为了测试文中提出的方法,我们设计了一个在线-离线复杂事件检测原型系统.该复杂事件检测原型系统用C++实现,编译环境为VisualStudio2008,使用的数据库是开源数据库MySQLServer5.2,系统配置:CPU为Pentium(R)E5200DualCore2.52GHz,内存为2GBRAM,操作系统为WindowsXP.由于本文主要考虑离散模式的在线-离线复杂事件检测,为了测试本文算法,我们设计了一个数据模拟器,模拟类似图3(b)所示离散模式的在线-离线复杂事件检测.实验分析使用的主要参数如表2所示,其中一些参数为数据生成器的参数.历史数据流被加载到SPE的一个缓冲区,当缓冲区内不能存储所请求的历史流时,通过按时间顺序批量加载.p(B|A,Δt)A类型事件在Δt出现在B的概率RBuffer|WSub|Page11复杂事件定义被解析为自动机模型进行检测.实验的性能指标为在线-离线复杂事件检测的CPU耗费(处理完实时流的时间)和未命中次数(missedhittimes).实验1.ALAA与LLAA的CPU性能比较.图11是两种不同的在线-离线执行算法的性能比较.由于ALAA算法在实时流和历史流整个数据集上运行,而LLAA算法只在其需要的历史流上运行,所以为了性能比较的公平,我们限定了实时流和历史流的大小,并用均匀分布生成数据流,匹配率设为0.5,ΔR为固定值.从图11可以看到,ALAA的CPU耗费始终比LLAA高,其主要原因是ALAA是一种盲目的在线-离线检测算法,它要加载整个历史流并检测其上的PA,而LLAA是一种触发式的在线-离线复杂事件检测方法,只有在存在达到最大状态的PL时才触发一次归档流的访问和计算.由于ALAA比LLAA算法性能相差较大,所以后续实验的性能测试我们主要关注LLAA.LLAA算法的CPU比较.实验2.基本的LLAA算法与基于选择性的基于选择性的LLAA算法(OptimizedLLAA,OLLAA)性能主要测试不同选择性的时候,在线-离线事件检测选择的数据流顺序的变化对CPU耗费的影响.该组实验在大小为1~5万的数据集上进行,该组实验我们固定了实时流的选择度,调整历史流的选择度,基本的LLAA算法用实时流去连接历史流,而OLLAA算法则是历史流连接实时流.从图12可以看出,OLLAA在CPU耗费上更少,其原因是使用基于选择度的复杂事件检测减少了不必要的PL实例和PA实例的计算和连接操作.但随着历史流的选择度逐渐增大,LLAA与OLLAA的算法性能差异变小,主要原因是因为两个数据集的可选择度接近时,连接操作的次数与连接操作的顺序关系不是很大.在实际处理中,历史流的选择度可以通过数据库的统计工具获得,而实时数据流的选择度则可以通过一些抽样技术获得.图12调整历史流的选择度LLAA与OLLAA的CPU性能比较.实验3.基本的LLAA算法与SLLAA算法该组实验测试基本的LLAA算法和SLLAA算法的CPU性能比较.SLLAA的子窗口的选取值分别为500,1000,1500,2000,2500和3000.为了说明子窗口效果,我们将数据流的复杂事件的MRatio设置为1.从图13可以看出,SLLAA算法比LLAA算法的CPU耗费都要少,主要原因是SLLAA算法通过批量的历史流加载和计算,减少了对历史流的请求次数(读写操作)和具有交叉历史流访问区间的重复计算,从而使得在线-离线复杂事件检测的平均响应时间减少.图13还表明,子窗口的选取并不是Page12越大或越小,SLLAA的性能就越好.相反的是,子窗口的取值在一个取值区间的中间部分(如本实验的[500,3000])时,SLLAA可达到CPU性能最优.该组实验可以为用户设定合适的容忍时间上限提供很好的推荐:用户可以根据系统的历史处理信息,如窗口大小、数据流的分布、模式特点、子窗口的取值区域等,结合系统当前的特点,设定比较合适的响应时间,达到系统资源的合理利用.实验4.调整LLAA的RBuffer性能比较在前面的章节介绍过,RBuffer是一个数据缓冲区,可以缓冲实时的数据量,为实时复杂事件检测提供数据源,同时也为历史流上的复杂事件检测提供数据源.RBuffer不能太小,因为当数据流高速进入事件处理引擎时,RBuffer由于可能存储不了数据流而频繁地将Buffer中的数据归档到外存,同时历史流上的归档操作也会因为RBuffer没有其需要的数据而频繁地访问外存,这就导致系统的高负载.由于内存是一个公共资源,当RBuffer的空间增大时,系统分配给模式匹配的空间自然减少,而模式匹配要存储原始事件的所有信息,因此,如果RBuffer过于大,则系统的性能会下降.图14表明,较小的RBuffer导致较多的数据库读写操作,而较大的RBuffer则可以减少数据库的读写操作,但RBuffer不能无限大.图14LLAA运行于不同的RBuffer和数据集时的实验5.TPM与STPM的CPU性能比较.LLAA在STPM与TPM两种中间结果管理方法上的性能测试如图15所示,为了能明显看到中间结果管理的效果,实验中设置|WSub|=5000,RBuffer=50000.从图15可看出,STPM的CPU性能明显优于TPM,其主要原因在上节也介绍过,是由于TPM没有利用到中间结果的空间信息,盲目地将中间结果归档,导致事件检测过程的中间结果命中率急剧下降,命中率下降意味着需要多次的数据库读取操作,数据库的频繁操作是非常耗时的.而TPM利用中间结果的时空关系(虽然空间关系时态化了),将最有可能更新状态的中间结果放于内存,提高了复杂事件的命中率,减少了复杂事件输出的时间.STPM的CPU性能和Miss次数比较实验6.调整LLAA的MRatio时TPM与我们调整数据集的大小和匹配率MRatio,测试了STPM和TPM的CPU性能和处理完相同数据集后的Miss次数统计.STPM和TPM的CPU性能比较如图16所示,可以看出,在数据集和MRatio变化时,STPM的CPU耗费稳定且都远小于TPM,进一步说明了中间结果管理需要更多的查询的特性才能使复杂事件检测响应时间更短.STPM和TPM的CPU性能差异其实来自于模式匹配时中间结果的Miss次数的差异,如图17所示.可以看到,随着MRatio的变大,TPM搜寻中间结果缓冲区的失效次数逐步减小,而STPM的中间结果缓冲区搜索失效次数保持在一个很低且稳定的区域(10~20次左右),即STPM能在缓冲区内保存更Page13图17STPM与TPM的中间结果Miss次数比较为活跃的中间结果,大大减少了归档中间结果的访问代价.7结论本文研究了在线-离线(历史)数据流上的复杂事件检测问题.通过使用最近处理过的事件缓冲区缓存最近处理过的实时数据流,可以减少历史流的请求代价.提出了在线-离线复杂事件检测算法ALAA和LLAA,并通过数据流的事件分布特性提出了LLAA的优化算法.针对复杂事件处理大窗口和高流速时产生的大量中间结果,提出了基于时态和时空关系的中间结果管理方法STPM和TPM.通过利用中间结果的时态和空间状态信息,STPM减少了状态需要更新的中间结果被交换到外存的可能性,提高了复杂事件检测的中间结果命中率,减少了复杂事件检测的响应时间.本文目前研究的是离散模式的在线-离线复杂事件检测,系统中只有一个事件查询.实际应用中,可能存在多个用户同时在实时流和历史流上查询,每个查询由于其语义(模式,窗口等)的不同而对应不同的查询执行模型(不同的自动机或Tree),如何在一次扫描数据流的时候或一次扫描多个查询对应的自动机的情况下进行查询调度,是多个查询优化的重要问题.此外,当系统中存在多个在线-离线复杂事件查询时,由于每个查询对应不同的时间窗口约束和历史流访问请求区间,如何利用这些查询的共同特点和数据的特点进行查询优化,如何在系统资源有限的情况下,对各种状态的中间结果进行高效管理,给系统降载,都是需要重点考虑的问题.此外,由于复杂事件检测的应用场景一般为分布式环境,数据在汇集到中心节点时,由于网络延迟或其它不确定因素,在数据流中可能存在数据乱序的情况,如何在保证在线-离线复杂事件检测完整性和一致性的前提下去除乱序数据的影响,也是需要考虑的问题.
