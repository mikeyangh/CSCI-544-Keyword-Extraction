Page1一种基于动态依赖关系的类集成测试方法张艳梅姜淑娟张红昌(中国矿业大学计算机科学与技术学院江苏徐州221116)摘要类间集成测试是面向对象软件测试的重要组成部分,合适的测试顺序能够极大地节省测试成本.类间依赖关系构成环路的情况下,需要删除某些依赖关系以消除环路,同时需要引进测试桩.忽略类间动态依赖关系导致测试桩的数目不足,难以完成测试.文中提出一种基于动态依赖关系的类集成测试方法.首先分析了类之间的静态依赖和动态依赖关系;然后在保证测试桩的数目尽可能少的前提下,给出了边的删除规则以及消除由静态依赖关系和动态依赖关系形成的环路的算法,在此基础上,进一步提出测试顺序分配策略和算法;最后针对提出的方法开发了基于测试级的类测试序列自动生成工具———TLOG.实验结果表明:该方法较其它方法需要较少的测试桩,测试效率有明显提高.关键词集成测试;测试顺序;测试桩;动态依赖;测试级1引言集成测试中最重要的问题[1].不同的类测试序列,需要不同的测试代价,所以,尽可能减少测试代价是确定类间测试顺序的重要目标.如果类的静态依赖关面向对象程序中,类间测试顺序的确定是类间系中不存在环路,类间测试顺序问题可以通过简单Page2的逆向拓扑排序来解决,而对于存在环路的情况,测试人员必须从对象关系图中删除某些依赖关系,以打破其中的环路.在删除依赖关系时,需要引进测试桩.测试桩指的是当C1依赖C2,增量集成过程中,C1集成时,但C2尚未被集成,用来模拟C2的服务组件.节省测试成本是选择测试顺序的一个重要目标,而在面向对象程序的测试中,开发测试桩是一项成本很高的工作,这是因为根据测试桩的定义可知,测试桩需要模拟的是待测试对象所依赖的类的服务组件,而由于一个类的对象行为依赖于对象当前状态,并且一个行为需要涉及到多个对象,因此要准确地模拟一个类的对象行为需要理解所有与之相关的类的对象行为,所以节省开发测试桩的开销是确定类间测试顺序的一个重要任务.减少开发测试桩成本的方法主要有两类:一类是最小化所需测试桩的数目,另一类是最小化测试桩的复杂度.测试桩复杂度是用来衡量构造一个测试桩的难易程度.测试桩的复杂度不易控制,因为:(1)测试桩的复杂度标准难以制定,Kraft等人[2]提出了一套测试桩的复杂性标准,但根据案例研究表明,他们的标准在某些情况下并不可行;(2)测试桩的复杂度在某种程度上取决于开发人员的编程能力,由于面向对象编程具有极大的灵活性,不同开发背景的程序员开发同一个类的测试桩,完全有可能生成复杂度相差很大的测试桩;(3)Tai等人[3]将测试顺序应用到集成测试中,他们证明先构造类的测试顺序,然后按照类的测试顺序来进行集成测试的方法,可以在一定程度上减少测试桩的数量.因此,我们采用的是最小化测试桩数目的方法.现有类间测试顺序研究方法大多只限于静态分析[1,4-6],而类间的动态依赖关系比较普遍,动态依赖关系同样会导致类关系图中环的形成,对类间测试序列产生影响,在删除动态依赖关系时,需要引进动态依赖关系测试桩.忽略类间动态依赖关系将导致测试桩的数目不足,使得测试不充分.本文主要研究基于动态依赖关系的类测试顺序的确定方法,解决忽略类间动态依赖关系所导致的测试桩的数目不足而难以完成测试的问题,通过花费尽可能少的测试桩找到一个最佳的测试顺序.需要解决两个问题:静态依赖关系和动态依赖关系构成的环路中边的删除规则以及类测试顺序分配策略.针对要解决的问题,为测试提供足够的测试桩,同时遵循满足构造的测试桩最少的原则,本文首先提出一组由静态依赖关系和动态依赖关系构成的环路中边的删除规则,通过删除弱联系边,解决已有方法中断开继承、组合和聚集等强联系关系增加测试成本的问题;然后在消除环路的基础上给出基于测试级的测试顺序分配策略.2类间的依赖关系面向对象程序类间的依赖关系主要包括两类:一类是静态依赖关系,一类是动态依赖关系.静态依赖关系指的是整个程序代码的静态结构中反映出来的类与类之间的关系.动态依赖关系是指类在程序运行期间形成的一种依赖关系.2.1类间的静态依赖关系静态依赖关系指的是整个程序代码的静态结构中反映出来的类与类之间的关系.面向对象程序中,类间的静态关系主要有继承关系、聚集关系和关联关系.(1)继承指的是子类可以共享父类(或祖先类)属性和操作.父类中定义了其所有子类的公共属性和操作,在子类中除了定义自己特有的属性和操作外,还可以对父类(或祖先类)中的操作重新定义其实现方法.如果类A继承类B,则类A称为类B的子类,并且类A能继承类B的成员(数据成员和成员方法).(2)如果类A聚集类B,则说明类A的数据成员具有一个或多个类B的实例.(3)关联表示类的实例之间存在的某种关系,A的实例映射到B的实例,这种关系叫关联.如果类A关联类B,则说明类A的成员方法使用了类B的实例(如,类A的成员方法包含B类型的参数或成员方法内部包含B类型的局部变量).对于基于图论的方法,类簇以及它们之间的关系可以抽象为对象关系图(ORD)[1],ORD用一个有向图G(V,E)表示,其中,V是由一组代表类的节点构成的集合,E是由一组代表类间关系的有向边构成的集合.图1显示了一个典型的ORD.图1是对象关系图(ORD)示例.图中节点表示程序中的类,实心有向边表示类之间的继承、聚集和关联关系.对于任何类C1到C2之间的有向边:(1)标有I的边表示C1是C2的子类;(2)标有Ag的边表示C1是C2的一个聚集类(C1包含一个或多个C2对象);Page3(3)标有As的边表示C1与C2关联.类之间的继承、聚集和关联关系使得在整个ORD中存在着依赖关系.准确地说,ORD描述的是类之间的静态依赖关系.我们可以依据文献[7]中对类之间静态依赖关系的定义来进行判断.定义1.对于一个ORD中的类X和Y,X静态依赖Y,当且仅当在ORD中存在一条从X到Y的有向路径.令Rs表示ORD中一条有向边的二元关系:Rs={(C1,C2)|在ORD中存在一条从C1到C2边},则类X静态依赖的类的集合S(X)={Y|〈X,Y〉∈Rs+},其中,Rs+表示Rs的传递闭包.例如,图1所示为一个面向对象程序P中的5个类{教师,学生,课程,本科生,成绩}构成的ORD.其中,本科生是学生的一个子类,学生和课程是成绩的聚集类以及学生关联课程、课程关联教师等.对于面向对象集成测试中的每一个类,可用一个类的集合S(X)对类的静态依赖关系进行描述.S(X)表示X在编译阶段静态依赖的类的集合.2.2类之间的动态依赖关系动态依赖关系是指类在程序运行时期形成的一种依赖关系.若类A继承于类B,且重写了类B的虚方法;类B是类C的服务类,即C要么和B相关联要么是B的聚集类,且调用了类B中被类A重写的虚方法,则在程序运行时期,C和B的子类A动态绑定,类C动态依赖于类A.如果类A继承于类B,类B是类C的服务类,即C要么和B相关联要么是B的聚集类,则在程序运行时期,C可能会和B的子类A动态绑定,类C可能会动态依赖于类A.本文是在ORD的基础上进行类间分析的,因此我们将可能存在的动态依赖关系都标记在ORD中.下面给出动态依赖关系的定义.定义2[7].类间的动态依赖关系用Rd表示,令Rd={〈C1,C3〉|存在一个类C2,它是C3的父类,且C2被C1调用},则类X动态依赖的类的集合D(X)={Z|〈X,Z〉∈Rd+},其中,Rd+表示Rd的传递闭包.我们可以从类之间的静态依赖关系得出动态依赖关系,例如:图2中,教师关联学生,学生是本科生的父类,在执行阶段,教师可能动态依赖于本科生.动态依赖边Dy用虚线有向边表示.推论1.由定义1和定义2我们可以推导出类X在编译阶段静态依赖和在执行阶段动态依赖的类的集合SD(X)={Ck|〈X,Ck〉∈(Rs+∪Rd+)}.证明.由SD(X)的定义可知,SD(X)=S(X)∪D(X).由S(X)和D(X)的定义可知,S(X)={Y|〈X,Y〉∈Rs+},D(X)={Z|〈X,Z〉∈Rd+},则SD(X)={Y∪Z|〈X,Y〉∈Rs+,〈X,Z〉∈Rd+}成立,令Ck=Y∪Z.由于二元关系可以用笛卡尔积来表示,因此,X与Y的二元关系X→Y可以记为X×Y∈Rs+,X与Z的二元关系X→Z可以记为X×Z∈Rd+.因此,X与Ck的二元关系X→Ck(即X→(Y∪Z))可以记为X×Ck=X×(Y∪Z)=(X×Y)∪(X×Z)=Rs+∪Rd+.因此,SD(X)={Ck|〈X,Ck〉∈(Rs+∪Rd+)}.定义3.扩展的对象关系图(EORD).在对象关系图ORD中增加表示动态依赖关系的边,用标有Dy的虚线边表示,可得到扩展的对象关系图,记为EORD={V,E},其中,V为表示程序中的各个类节点,E={EI∪EAg∪EAs∪EDy},EI、EAg、EAs分别表示类间继承边、聚集边和关联边.图1的ORD中没有包含动态依赖信息,图2是扩展后的对象关系图(EORD),其中动态依赖用虚线箭头表示,如类教师与类本科生之间存在动态依赖.图1中存在一个环路:教师→学生→课程→教师.但是,由于动态绑定特性,当测试类教师时,类本科生中的方法可能被执行.也就是说,在程序执行阶段,类教师可能依赖类本科生,类成绩可能依赖类本科生.所以,正确的依赖如图2所示.图2中存在两个环路,使原来的ORD的环路增加.为了确定类测试序,需要消除在图1和图2两种情况下的环路.由于动态依赖边的引入对环路产生影响,因此消除Page4环路时所删除的边也需要随之变化.3消除环路算法对于存在环路的EORD,需要消除环路进而给出类间测试序列.因此,确定类间测试顺序的核心问题就是打破环路.Kung等人[1]、Kraft等人[2]、Bri-and等人[8]都认为给不同类型的边创建测试桩的难易程度的高低和代价Cost(C)均存在如下关系:C(关联边)=C(动态依赖边)<C(聚集边)C(继承边).因此,他们称继承关系和聚集关系为强联系关系,动态依赖关系与关联关系均为弱联系关系.为了减少测试代价,本文消除环路时避免删除强联系边;同时,由于本文的解决方案旨在降低测试桩的数目,因此,我们在打破环路的过程中遵循删除涉及环路最多的关联边或者动态依赖边的规则.其中关键问题是首先需要识别出EORD中由类以及它们之间的依赖关系形成的强连通分量(SCCs),然后查找每一个子强连通分量(SCCi)中所有的环路,统计SCCi中每条动态依赖边和关联边所涉及的环路数目,进而将一个有环图消除环路成为一个无环图.3.1EORD中的环路对于EORD中由类以及它们之间的依赖关系形成的SCCs,我们可以通过Tarjan等人[9]的算法进行识别.本节以一个EORD为例介绍子强连通分量(SCCi)中每条动态依赖边和关联边所涉及的环路数目的计算方法.每一个SCCi中的环路查找方法将在4.3节的环路生成模块中再作具体介绍.假设CP(P,Q)表示边P→Q涉及的环路数目.如图3中,CP(G,C)=2,环路分别为G→C→D,G→C→F.在图3中,不考虑动态依赖关系的情况下,类C、D、F、G构成一个SCC{C,D,F,G},其中各关联边的环路数目:CP(C,F)=2,CP(D,G)=2,CP(F,G)=2,CP(G,F)=2.考虑动态依赖关系后,B→E使ORD构成了SCC{B,E},增加了环路B→E→B.因此,对于SCC{B,E},CP(B,E)=1,CP(E,B)=1.3.2消除EORD中环路的方法3.2.1边的删除规则对于存在环路的EORD,首先需要消除环路.删除哪些边消除环路将直接影响到构造测试桩的数量.为了解决已有的方法忽略动态依赖关系的问题,为测试提供足够的测试桩,需要考虑动态依赖边对打破环路的影响.同时为了满足构造的测试桩最少,我们应该遵循删除最少的边打破尽量多的环路的原则.下面给出相关的删除规则.定理1.B是C的父类,又是A的服务类,即A要么和B相关联要么是B的聚集类.如果A在B和C之前进行测试.如果B是非抽象类,不需要为C构造测试桩,只需为B构造测试桩.证明.已知B是C的父类,又是A的服务类,根据动态依赖关系的定义可知,在程序运行时期,A可能会和B的子类C动态绑定,即A可能会动态依赖于C,因此,当测试A时,需要依赖B和C.如果B是非抽象类,B能实例化,它作为服务类的作用不需要通过其子类C实例化来提供,在这种情况下,不需要为C构造测试桩,因此,B是非抽象类时,只需为B构造测试桩.推论2.假设λ是无环的ORD,节点A,B,C∈λ,B是C的父类,又是A的服务类,且A→B是关联边,动态依赖边A→C使得EORD产生了环路A→C→A,边A→C和边C→A没有与其它节点构成新的环路,为了构造尽可能少的测试桩,如果B是非抽象类,且C→A是非关联边,则直接删除动态依赖边A→C;当C→A是关联边,则可以删除边A→C或边C→A.证明.由定理1我们可以推断,如果B是非抽象类,删除关联边A→B时,动态依赖边A→C随之消失,由于动态依赖边A→C使得EORD产生了环路A→C→A,则此时已经消除了该环路.如果A在B和C之前进行测试,需要为B和C构造测试桩.事实上,直接删除边A→C可以消除环路,只需要为C构造测试桩,此时,我们选择直接删除边A→C.如果C→A是关联边,也可以通过删除边C→A(由于关联边为弱联系边)来消除环路,否则,只能删除边A→C.推论3.假设λ是无环的ORD,节点A,B,C∈λ.B是C的父类,又是A的服务类,且A→B是聚集边,同时动态依赖边A→C使得EORD产生了环路A→C→A,边A→C和边C→A没有与其它节点Page5构成新的环路.为了构造尽可能少的测试桩,如果C→A是关联边,则可以删除边C→A或者A→C,相应地为A或C构造测试桩;否则,只能删除边A→C,为C构造测试桩.证明.已知B是C的父类,又是A的服务类,根据动态依赖关系的定义可知,则在程序运行时期,A可能会动态依赖于C.由于动态依赖边A→C使得EORD产生了环路A→C→A,可以删除边C→A或者A→C或者A→B,已知A→B是聚集边,将其排除(Kraft等人[2]已经证明聚集是强联系边,本文避免删除该类型的边);因此,当C→A是关联边,则可以删除边C→A,为A构造测试桩,测试顺序为BCA,或者删除A→C,测试顺序为BAC,为C构造测试桩;否则,只能删除边A→C,为C构造测试桩.例如,由于考虑了动态关系,图2中生成了一个新的环路:教师→本科生→学生→课程→教师.根据推论1,删除关联边教师→学生,可以打破该环路.此外,删除关联边教师→学生还可以打破图中的另一个环路:教师→学生→课程→教师.满足了删除最少的边打破尽量多的环路原则.因此,我们选择删除动态依赖边教师→学生.3.2.2EORD中的环路消除算法如前面所提到的,消除环路是确定类间测试序的关键步骤.根据3.2.1节提出的边的删除规则,我们给出相应的环路消除算法:首先统计动态依赖边和关联边所涉及的环路数目(行1~5),然后判断涉及环路数目最多的边的类型:如果涉及环路数目最多的边为动态依赖边,或者动态依赖边和关联边涉及相同的环路个数(包括由一条动态依赖边和一条关联边构成一个最简单的环路的情况),判断导致动态依赖边形成的边的类型(行6~8):如果是关联边,删除动态依赖边;如果是聚集边,也删除动态依赖边(行9~14).如果两个类之间同时存在一条关联边和一条动态依赖边(同向),且它们涉及的环路数目相同且最多,则同时删除这两条边(行15~17);如果两个类之间同时存在一条聚集边(或继承边)和一条动态依赖边(同向),且它们涉及的环路数目相同且最多,则删除环路中的关联边(行18~20)(由于Kung等人[1]已经证明ORD中的任意一个SCC中至少包含一条关联边).如果涉及环路数目最多的边为一条关联边,则删除该关联边(行21~23).如果多条关联边(或动态依赖边)的环路数目相同且最多,则删除其中任意一条关联边(或动态依赖边)(行24~26).环路消除算法如算法1所示.算法1.EORD(V,E)的环路消除算法.输入:EORD(V,E)输出:无环的EORDBegin1.findallSCCsinEORD;2.for(eachSCCi(Vscci;Escci)∈SCCs)do3.searchcycles(…);4.for(eachassociationedgeAsanddynamicdepend-5.calculatethenumberofcyclesthatinvolveAsandDy;6.while(totalCycle!=0)do7.ifDyhasthemostcyclesorDyandAshavethe8.judgeifDyisleadbyanotherassociationedgeAs;9.ifleadbyAsthen10.removethedynamicdependencyedgeDy;11.elseleadbyaggregationedgeAg12.removethedynamicdependencyedgeDyor13.endif14.endif15.iftwoclasseshaveanAsandaDyinthesame16.removetheAsandDysimultaneously;17.endif18.iftwoclasseshaveanAg(orI)andaDyinthe19.removetheotherassociationedgeofthecycle;20.endif21.ifanassociationedgeAshasthemostcyclesthen22.removetheassociationedgeAs;23.endif24.ifmorethanoneassociation(dynamicdependen-25.removeanyassociation(dynamicdependency)edge;26.endif27.totalCycle=totalCycle-numberofcyclesbroken;28.recalculatethenumberofcyclesforremaining29.endwhile30.endfor31.endforEnd下面把图3中示例应用到该算法中,对算法的执行第2~3行能够在SCC{C,D,F,G}中找出具体步骤作如下说明:5个循环,如表1所示.Page6No.12345表2犛犆犆{犆,犇,犉,犌}中各关联边涉及的环路No.EdgesCyclesinvolvedNC1234根据算法1中的第4~5行计算SCC{C,D,F,G}中各条关联边和动态依赖边涉及的环路数目,结果如表2所示.其中,NC表示环路的数目.由算法6~17行可以得出边1:C→F,边2:D→G,边3:F→G和边4:G→F涉及环路数目相同,均为2,我们任意删除其中的一条关联边,此处,假如删除关联边2,D→G,可以打破两个环路{3,5},剩余环路1,2,4.接下来,应用算法的第28行对剩余的边重新计算涉及环路数目,可以得出两条拥有最多环路数目的关联边分别为C→F和F→G,且删除这两条边中任意一条打破的环路数目相同,所以可以任意选择一条边,这里,我们选择删除边C→F,打破环路1,2,此时,只剩下环路4,该环路由边F→G和G→F构成,这两条边为具有相同环路的关联边,可以任意删除其中的一条边,我们选择删除F→G,则消除了SCC{C,D,F,G}中环路.对于SCC{B,E},根据算法1,需要删除边E→B打破环路.此时,EORD成为了无环图,如图4所示.图4消除环路后扩展的对象关系图(EORD)打破EORD中所有环路需要删除D→G,C→F,F→G,E→B这4条边,分别为这4条边的源类G、F和B各自创建1个测试桩,共需要3个测试桩.4测试顺序分配策略在程序的执行过程中,消除EORD中的环路以后,程序中仍存在动态依赖关系,但这些动态依赖关系并没有使得EORD构成环路,即无环的EORD中既包含静态依赖关系又包含动态依赖关系.由于动态依赖关系在程序运行时期才会存在,同时,传统的逆向拓扑排序只能在程序静态状态下确定类测试顺序,因此不能通过简单的逆向拓扑排序为存在两种依赖关系类簇确定测试顺序.因此,为了解决无环的EORD中的动态依赖关系带来的新的测试问题,我们给出基于测试级的测试顺序分配策略.4.1测试级的定义测试级是指根据静态依赖和动态依赖关系为被测类分配的两个测试级别:静态测试级和动态测试级.其中,静态测试级是指不运行被测程序本身,对程序进行静态分析,仅通过分析或检查源程序中的待测目标类来检查其正确性.静态测试的结果可用于进一步查错,并为测试用例选取提供指导.动态测试级是指需要通过运行被测程序,来检查程序的正确性,该方法由三部分组成:构造测试实例、执行程序、分析程序的输出结果.一个测试级T可以表示为一个三元组T=(Tneed,Tall,Ttype)[7].其中,Tneed为被测试类的集合;Tall为被测类与被测类所依赖的类构成的并集;Ttype为测试的类型.其中,测试类型包括两种,一种是静态测试,用S表示;另一种是动态测试,用Dy表示.下面具体介绍如何为消除环路后的EORD的每一个类确定测试级,即如何划分被测类的测试级别.(1)为了程序的精确测试,对于EORD中的每一个类X,为每个类定义一个静态测试级T=({X},{X}∪S(X),S);(2)对满足D(X)≠的类X,定义一个动态测试级T=(Tneed,Tall,Dy)=({X},{X}∪D(X),Dy).表3所示为图4中无环EORD的S(X)和D(X),首先为每一个类各自定义一个静态测试级,其中类B满足D(X)≠,那么为B定义动态测试类XS(X)ABCDEFGHPage7级,因此类B有两个测试级.按上述方式,可定义图4中EORD的所有测试级如表4所示.Tneed{A}{B}{C}{D}{E}{F}{G}{H}{B}4.2测试级顺序分配策略每一个类的测试级确定之后,需要为它们分配一定的测试顺序.类测试顺序由类的测试依赖性决定[10].测试依赖性表示一个类依赖于其它类的程度.为了确定类测试顺序,本文从类测试依赖性入手,提出两个测试依赖性定理作为确定类测试顺序的依据.定理2.当类A是类B的一个子类,或者类A是类B的一个聚合类,或者类A是类B的一个关联类,则在集成测试时,类A依赖于类B,类A在类B之后进行测试.证明.类A继承于类B时,类A会继承类B的部分属性,从而类A依赖于类B.若类B中被类A继承的成员发生变化,或被类A继承的成员有直接或间接影响的成员发生变化时,将会影响类A的行为.当类A是类B的一个聚合类,由于聚合是整体和个体的关系,即若干个类B聚合成一个类A,则类B的改变必然会影响类A,因此类A依赖于类B.当类A是类B的一个关联类,则类A能够访问类B的数据成员,或者类A传递一个消息到类B.因此,如果类B的数据成员发生变化,或者当类B接收类A发送的消息,并且类B的成员函数发生变化,则类B对消息的响应会有变化,返回给类A的结果也会发生变化.因此,类A依赖于类B.因此,类A在类B之后进行测试.得出定理2的结论.定理3[11].假设3个类A、B、C,当A是B的一个子类,B是C的一个服务类,即C关联于B(或者依赖于B)或者C是B的一个聚合类,则在考虑多态性的情况下,集成测试时,C依赖于B,也依赖于B的子类A.测试顺序为B,A,C.证明.A是B的一个子类,B是C的一个服务类,由测试依赖性定理2得出,A在B之后测试,C在B之后测试.对于A、C的测试依赖性关系有如下情况:(1)若C关联于B(或者依赖于B).如果C需要访问B中的某个数据成员,而A继承B的该数据成员.由于继承和多态性,在程序运行时C可能访问到的实际上是A中的该数据成员.因此C依赖于A.但由于从A到C之间没有任何依赖关系,因此,A不依赖于C.(2)若C是B的一个聚合类,由于A是B的子类,而C是B的聚合类,因此C也可以作为A的聚合类.该情况下C依赖于A.(3)如果C传递一个消息到B,而B负责具体处理消息.由于继承和多态性,继承了B类处理方法的A也能够处理该消息,C也能够将消息传递到A,由A负责具体处理.该情况下C依赖于A.由上述分析得出,测试顺序为B,A,C.得出定理3的结论.因此,对于消除环路以后的ORD或者EORD,根据定理2和定理3,测试级顺序需要满足:首先考虑静态依赖,因为动态依赖只是潜在的运行期间的动态绑定依赖关系,弱于静态依赖关系,即在测试一个类之前,该类所依赖的所有类都已被测试,且在对一个类进行动态测试之前,已完成了对所有类的静态测试.这样,满足测试类所需要的类都已经被测试,可以保证测试桩的数量尽可能少.根据这一要求,应该遵循以下测试级顺序分配规则.(1)若类C1和类C2有两个不同的静态测试级TC1和TC2,且TC1静态依赖TC2,则C2的静态测试级TC2先于C1的静态测试级TC1.(2)若类C1和类C2有两个不同的动态测试级TC1和TC2,且TC1动态依赖TC2,则TC2先于TC1.(3)若类C有2个测试级,静态测试级Ts=({X},X∪S(X))和动态测试级Td=(X,X∪SD(X)),其中,X∈Tall,则Ts先于Td.(4)若类C1的一个动态测试级是TC1=(TC1need,TC1all),并且C2∈TC1all,C1≠C2,则对C2的静态测试级TC2=({C2},C2∪S(C2))先于TC1.无环的EORD中类测试顺序分配算法如算法2算法2.无环的EORD中类测试顺序分配算法.输入:无环的EORD输出:无环的EORD中类测试顺序分配算法所示.Page8Begin1.foreachclassXofacyclicEORDdo2.findXstaticdependencysetXs,addXstoS(X);3.SetStaTstLvl(X,S(X));//为X建立静态测试级4.findXdynamicdependencysetXd,addXdtoD(X);5.SD(X)=(S(X)∪D(X))+6.ifS(X)SD(X)then7.SetDynTstLvl(X,D(X));8.endif//为X建立动态测试级图5TLOG功能结构图该工具的输入信息是一个描述面向对象系统中类间关系的三元组列表,其中的三元组列表可以由面向对象系统的统一建模语言(UML)设计文档中的类图获得.下面介绍TLOG的几个主要功能模块.(1)环路生成模块.如图5中虚线框所示,其输入信息是UML设计文档中的类图或ORD所包含的SCCs中的各条边,查找SCCs中所有的环路时,首先将每一个SCCi中的边以树的形式组织在一起,总共构造i棵树,每棵树的特点是叶节点与根节点相同,然后对所构造的树进行前序遍历,进而找出所有环路,最后自动输出SCCi中的环路数目及所有环路路径、SCCi中各关联边和动态依赖边涉及的环路的数目.(2)环路消除模块.首先对输入的三元组描述信息所表示的类图或ORD,增加动态依赖关系,然后采用Tarjan等人[9]的算法,依次识别SCCi,最后按照3.2.2节中的算法1,通过断开一条或多条关联边或者动态依赖边,将每一个子SCCi的环路断开,直到消除所有环路.(3)测试级排序模块:由4.1节的方法定义测9.endfor10.determinetotalnumberoftestlevelN;11.orderthetestlevelNaccordingtointegrationEnd4.3测试序列生成器TLOG我们根据上述基于测试级的类集成测试方法设计并实现了一个工具———TLOG(TestLevelOrderGenerator),其功能结构如图5所示.试级以后,根据测试级的顺序分配的四条规则以及4.2节中的算法2,得到基于测试级的类集成测试顺序.TLOG能够自动生成基于动态依赖关系的类集成测试序列,可减少测试的工作量.5实验在这一节中,我们将前面介绍的方法应用到一组基准程序中,通过实验验证本文方法的有效性.5.1实验描述和过程在实验中,我们采用了在许多软件测试研究中被作为基准程序来使用的3个系统:(1)ANT系统;(2)DNS系统;(3)BCEL系统.其中,ANT[5]系统(http://jakarta.apache.org)包含25个类,83条依赖边和654个依赖环路.DNS[5]系统(http://www.xbill.org/dnsjava/)可以提供网络域名服务,包含61个类,276条依赖边,其中,10个类构成16个环路.BCEL[5]系统(http://jakarta.apache.org/bcel/index.html)包含45个类,294条依赖边,其中,41个类构成416091个环路.实例的详细信息如Page9表5所示.其中2~8列为仅考虑类间静态依赖关系时系统的统计信息,当考虑动态依赖关系时,类间关系更加错综,类间测试过程也变得复杂很多,表中最后一列是我们考虑动态依赖关系时统计的环路数目.这3个系统的类图可以参照Briand等人的文表5系统的详细信息系统名类的数目use边数As和Ag边数composition边数inheritance边数静态边构成环路数代码行数所有边构成环路数ANT2554DNS61211BCEL45182265.2实验过程5.2.1ANT系统为了说明TLOG工具的工作原理,我们给出实验的具体过程.首先以ANT系统为例进行分析.该系统的类图可以参见文献[5],其中所包含的类如表6所示.根据本文算法1,当多条关联边的环路数目相同,删除其中任意一条关联边,导致测试顺序的不确定性,同时为了与已有方法[6,12]进行比较,我们在实验时运行100次.表7首先给出我们的方法打破静态依赖关系构成的环路过程(此时假设不考虑动态依赖).表7说明采用本文方法,如果只考虑类间静态依赖关系,打破环路共删除10条边.因为需要为构表7打破ANT系统静态依赖关系构成的环路过程次序12345678910表8增加动态依赖关系后打破环路过程次序环路数目1SCC{1,16,2,4,5,10,18,19,20,21,22,23,24,25,17}88942SCC{1,16,2,4,5,10,18,20,21,22,23,24,25,17,19}40173SCC{1,16,2,4,5,10,24,20,21,22,23,25,17,19}184189716→4(16→1)(16→5)(16→10)(16→25)453856204710056891210117125313214115160注:表8中最后一列括号中的边表示随关联边的删除而消失的动态依赖边.献[5-6].对象关系图(ORD)的表示方法类似于类图.类图比ORD多了use和composition关系,但由于use关系和association关系同为弱联系关系,因此在计算类间动态依赖关系时,可将use视为association关系,同理,composition关系视为aggregation关系.113046成这10条边的源类创建测试桩,因此,打破ORD中所有环路需要为类18,24,16,20,22构造测试桩,总共需要构造5个测试桩.类编号类编号1AntClassLoader14NoBannerLogger2BuildEvent15PathTokenizer3BuildException164BuildListener17ProjectComponent5BuildLogger18ProjectHelper6DefaultLogger19RuntimeConfigurable7DemuxOutputStream208DirectoryScanner219FileScanner22TaskAdapter10IntrospectionHelper23TaskContainer11Launcher24UnknownElement1213环路数目65430613550332212103&&21&&18Page10本文考虑动态依赖关系,增加20个动态依赖关系,环路数目由654增至8894.表8给出了SCCs中环路的打破过程.从表8可以看出,增加类间动态依赖关系时,打破EORD中环路共删除23条边,其中,随关联边的删除而消失的动态依赖边有7条.由于需要为删除的这23条边的源类创建测试桩,因此,打破EORD中所有环路需要为类18,2,4,1,5,10,25,21,24,22,16,20构造测试桩,总共需要构造12个测试桩.最后,利用本文的TLOG工具自动生成ANT系统的类测试顺序,共13个测试级,其中10个静态测试级(S),3个动态测试级(Dy).如表9所示.其中:第1列为主测试顺序号,第2列为被测试的类,第3列为被测类所依赖的类,即在被测类之前进行测试的类.第4列为被测类所属测试类型.对于主测试顺序号相同的类,它们之间没有依赖关系,其测试顺序可以是任意的.因此,表9中的测试顺序并不是唯一的测试顺序.5.2.2DNS系统对于DNS系统,我们采用同样的方法进行实验.表10首先给出我们的方法打破静态依赖关系构表10打破DNS系统静态依赖关系构成的环路过程次序环路数目1SCC{33,38,52}&&SCC{8,11,21,25,32,48,58}3&&132SCC{33,38}&&SCC{32,48,58}&&SCC{8,21}1&&2&&133→38&&32→48&&21→834表10说明采用本文方法,如果只考虑类间静态依赖关系时,打破环路共删除6条边.打破ORD中所有环路需要为类52,11,38,48,8,58构造测试桩,总共需要构造6个测试桩.本文考虑动态依赖关系,增加175个动态依赖关系,但环路数目不变.表11给出了SCCs中环路的打破过程.表11增加动态依赖关系后打破环路过程次序环路数目1SCC{38,33,52}&&SCC{8,11,21,25,32,48,58}3&&132SCC{52,33}&&SCC{32,48,58}&&SCC{8,21}1&&2&&152→33&&32→48&&21→834表12DNS系统基于测试级的测试顺序类型主测试级主测试级19,10,13,15,17,27,28,31,36,44,46,49S11S122S1334S145S15成的环路过程(此时假设不考虑动态依赖).主测试级被测类X依赖的类SD(X)14,9,12,23384215206163,12,15,17,20,19,21,23S7891410131121261310从表11可以看出,增加类间动态依赖关系时,打破EORD中环路共删除6条边.打破EORD中所有环路需要为类33,11,48,8,58构造测试桩,总共需要构造5个测试桩.针对DNS系统,利用本文的TLOG工具,我们最后得到19个测试级,其中12个静态测试级(S)、7个动态测试级(Dy).最终的具体测试顺序如表12所示.10Page11主测试级类型主测试级677,11,20,24,30,35,41,54,55,57S178S189S19105.2.3BCEL系统BCEL系统包含416091个环路(不考虑动态依赖),由于篇幅有限,只简单给出采用本文方法打破静态依赖关系构成的环路过程,如表13所示.打破环路共删除73条边,总共需要构造56个测试桩.考虑动态依赖关系后,增加138个动态依赖关系,环路数目增加至626826个.表14简单给出了表13打破BCEL系统静态依赖关系构成的环路过程次序1SCC{2,4,35,30,45,5,6,7,18,8,10,13,21,26,15,9,11,12,14,16,17,19,2SCC{2,4,35,45,5,6,7,18,8,10,13,21,26,15,9,11,12,14,16,17,19,22,25,3SCC{2,4,45,5,6,7,18,8,10,13,21,26,15,9,11,12,14,16,17,19,22,25,27,…7374表14增加动态依赖关系后打破环路过程次序1SCC{2,3,4,35,30,45,5,6,7,9,18,8,10,13,21,26,15,9,11,12,14,16,17,2SCC{2,3,4,35,30,45,5,6,7,9,18,8,10,13,21,15,9,11,12,14,16,17,19,3SCC{2,3,4,35,30,45,5,6,7,9,18,8,10,13,21,15,9,11,12,14,16,17,19,…8788表15BCEL系统基于测试级的测试顺序主测试级类型主测试级1S10238,9,11,12,14,16,20,22,25,32,34,39,40,43,44S12S134S145S1567S168S1795.3实验结果及分析这一节中,我们就打破环路所需构造测试桩的数目,分别与文献[6]中Briand、Traon和Tai等人的3种只考虑静态依赖关系的测试方法、文献[13]SCCs中环路的打破过程.打破EORD中环路共删除87条边,总共需要构造70个测试桩.针对BCEL系统,利用本文的TLOG工具,我们最后得到17个测试级,其中10个静态测试级(S)、7个动态测试级(Dy).最终的具体测试顺序如表15所示.中Li的增加动态依赖关系的类集成测试方法进行比较,比较结果如表16~18所示.其中横坐标表示在算法执行中所花费测试桩的个数,纵坐标表示在100次算法执行中与测试桩的个数相对应的次数.Page12表16ANT系统结果表17DNS系统结果表18BCEL系统结果算法执行次数算法执行次数算法执行次数算法执行次数算法执行次数算法执行次数Page13通过表16~18中的结果可以发现:对于ANT系统,如果仅考虑类间的静态依赖关系,采用本文方法执行算法100次,均需要构造5个测试桩,而采用Briand等人[6]、Le等人[4]和Tai等人[3]的3种方法均构造多于10个测试桩;如果增加类间的动态依赖关系,采用本文方法需要构造12个测试桩,Li的方法[13]同样需构造12个测试桩.对于DNS系统,如果仅考虑类间的静态依赖关系,采用本文方法需要构造6个测试桩,与采用Briand等人[6]的方法构造相同个数的测试桩,而采用Le等人[4]和Tai等人[3]的3种方法均构造多于6个测试桩;如果增加类间的动态依赖关系,采用本文方法需要构造5个测试桩,Li的方法[13]同样需构造5个测试桩.对于BCEL系统,如果仅考虑类间的静态依赖关系,采用本文方法需要构造56个测试桩,而采用Briand等人[6]、Le等人[4]和Tai等人[3]的3种方法均构造多于67个测试桩;如果增加类间的动态依赖关系,采用本文方法需要构造70个测试桩,Li的方法[13]同样需构造70个测试桩.实验结果证明:从这两个方面与已有的集成测试方法相比,如果仅考虑类间的静态依赖关系,本文方法与Briand、Le和Tai等人的3种方法相比,构造的测试桩的个数最少;如果增加类间的动态依赖关系,采用本文方法需要构造的测试桩个数与采用Li的方法[13]相等,但是,他的方法存在缺陷:允许断开继承边和聚集边等强联系边来打破环路,导致测试桩复杂度的提高,因此,如果在不允许断开强联系边的情况下,Li的方法将会大大增加测试桩的个数.因此,体现了本文方法的有效性.6相关工作讨论现有的类间测试顺序研究方法大多仅限于静态分析:Kung等人[1]最早提出解决类间测试顺序问题的方法,并证明如果对象关系图中没有环,则可以通过逆向拓扑排序得到类间测试顺序.如果类图中有环,则首先识别其中的强联通分量,然后删除部分关联边使之成为无环图.Tai等人[3]提出的测试顺序分配策略将ORD中的3种关系分为两个层次:继承关系和聚集关系位于一个层次,关联关系处于一个层次.当穿越主层的关联关系没有形成环路时,该策略导致构造不必要的测试桩.Le等人[4]采用了一种基于测试依赖图模型的方法进行集成测试,测试依赖图是由类和方法之间的测试依赖关系构成的,他们的策略减少了桩的数量,但可能断开继承和聚集关系.之后,Briand等人[6]在不打破继承、聚集等强联系关系的前提下,给出基于图论的测试顺序策略,通过最小化测试桩的数目找到一个最佳测试顺序,与Le和Tai的方法相比,所需测试桩数目最少.Jaroenpiboonkit等人[12]提出了一种使用测试依赖图和面向对象切片技术找到一个满足最小化测试桩的数目的最佳测试顺序的方法.以上方法均未考虑类间的动态依赖关系.考虑类间的动态依赖关系的文献相对较少:La-biche等人[7]给出了基于测试级的类间测试序列生成方法,Kraft等人[2]和Paradkar[14]在类集成测试中考虑了动态依赖关系,但是以上4种方法均没有考虑动态依赖关系对构成的环路的影响,因此也没有给出相关的边的删除规则;就我们所知,目前只有Li等人[13]提出了考虑动态依赖关系时的环路中边的删除规则,解决了忽略类间动态依赖关系所导致的测试桩的数目不足以完成测试的问题,但是他的方法允许断开聚集依赖关系,引起构造复杂测试桩的问题,并且在某些情况下可能产生多余测试桩.将本文方法与已有的算法所得的类测试顺序进行比较,可以得出如下结论:(1)动态测试级的引入是本文的一大特点.我们的方法解决了测试桩的数量不能满足被测类充分测试的问题.(2)本文对存在环路的类簇进行集成测试,打破环路时仅允许删除关联边和动态依赖边,遵循以最少的边打破更多环路的原则,花费较低的测试代价.(3)本文的测试级表示方法可以获得更多的信息量,能够更加清晰、充分地表示类簇的测试序列.其中,相同测试级中的类的测试顺序可以交换.该方法不仅能够灵活体现出各测试级的序列,也能够反映出当测试某一个类时,该类所依赖的类以及一个测试级相对于上一级所增加的类.因此,根据测试级可以得到一种增量测试,能够达到测试用例的高度重用,而测试用例的重用使派生类测试中所需重新设计的测试用例减少,加快测试的进度.7结束语类间测试顺序的确定是类间集成测试中最重要的问题.测试桩的复杂性标准目前国内外大多只针对类间静态依赖关系进行分析,而忽略了类间动态依赖关系,虽然一些相关研究中已经考虑类间动态Page14依赖关系,但是并没有进行定量分析,因此基于类间动态依赖关系建立测试桩的方法是一个新的研究领域.为了解决已有的方法忽略动态依赖关系的问题,为测试提供足够的测试桩,本文不仅分析了类之间的静态依赖关系,更重点分析了类间的动态依赖关系,并考虑了动态依赖边对消除环路的影响,给出了环路消除算法.由于本文增加了动态依赖关系的分析,对于动态依赖关系的测试桩的复杂性标准难以确定,因此,我们从构造测试桩数目的角度与已有方法进行比较,结果证明本文方法能够以相对较少的测试桩满足类的静态测试和动态测试.对于大型面向对象程序来说,被测程序中类的数量很多,工作量相当庞大.在此基础上我们开发了测试级生成器TLOG,能够自动生成基于测试级的类集成测试序列,减少测试的工作量,提高测试效率.本文通过最小化测试桩的数量来确定类间测试顺序,一方面是由于目前针对动态依赖边的复杂度还没有一个度量标准;另一方面是由于现有已考虑动态依赖边的文献中,均采用构造测试桩的数量作为衡量标准,而没有从测试桩复杂度的角度进行研究,为了与已有的方法进行比较,我们也将构造测试桩的数量作为衡量标准.在满足最小化测试桩复杂度的前提下,确定包含动态依赖关系的类间测试顺序,作为我们下一步要研究的内容之一.此外,可以发现,本文中我们没有考虑抽象类的特点,实际上,抽象类的特性,将会影响类间的依赖性,进而将影响类间测试序.这是我们目前正在解决的主要问题之一.致谢在此,我们向对本文给予建议的同行表示感谢.同时,对审稿人提出的有益建议表示感谢.
