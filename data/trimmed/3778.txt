Page1特征模型定制的一种自动传播策略与选择性回退机制李龙赵海燕张伟(高可信软件技术教育部重点实验室北京100871)(北京大学信息科学技术学院软件研究所北京100871)摘要面向特征的分析方法已被主流的软件复用方法接受.其基本思想是将软件的特征作为软件解决需求问题的基本要素,使用特征以及特征之间的关系(这两者的组合也被称为特征模型)来组织软件的需求.特征模型良好的可剪裁性和可扩展性,为领域需求的复用提供了有力的支持.在当前的面向特征的方法中,特征模型上的一个定制决策会影响其他相关特征的绑定状态.如何使用特征模型之间内在的关联关系来实现特征模型的定制的自动传播算法与选择性回退算法是一个值得进行深入研究的课题.作者给出了特征模型定制的一种自动传播策略与选择性回退机制,针对特征模型中存在的二元约束与组合约束进行分析,介绍该算法的实现细节.关键词软件复用;特征模型;模型定制;自动传播;选择性回退1引言随着用户对软件产品的质量和性能的要求越来越高,软件自身的规模和复杂性也随之迅速增长,软件开发面临的压力也日益加剧.因此,人们希望借鉴成熟高效的工业产品生产方式来开发软件产品.从20世纪90年代以来,软件复用研究重新成为了热Page2点,软件复用被认为是解决“软件危机”,提高软件开发效率和质量,实现软件产业工业化生产方式的有效途径[1].作为软件复用的一种重要途径,特征建模技术被用来捕获和组织领域需求,文献[2]的思想是将软件需求组织成为客户/用户价值的一组特征,通过特征间的的精化关系与约束关系来表示需求间的依赖关系,提高软件需求的易定制性.其目的是通过定制操作提取领域内的需求实现软件复用,将领域特征模型转化为应用系统特征模型,实现领域工程与应用工程之间的联系,将已有的应用系统转化为新的应用系统,实现大粒度的软件复用.基于特征模型的复用一般通过特征模型的定制来实现.特征模型的定制技术是指在领域特征模型中选择特征添加到应用系统特征模型中,并且满足领域特征模型所建立的特征间的约束关系.由于特征模型中存在着大量的约束关系与精化关系,使得特征模型中的特征间存在着一定联系,因此在确定特征的绑定状态时,就必须考虑特征的绑定状态是否能够满足特征模型中内含的精化关系与约束关系,而人工检测则极为繁重和耗时.因此,需要有特征模型定制的自动传播机制来辅助定制者进行定制操作,以确保定制操作可以满足特征模型的精化关系与约束关系.目前关于特征模型定制的自动传播机制的研究主要集中在关于二元约束与精化关系的定制的自动传播,对相关复杂约束的定制的自动传播机制研究较少.当定制的自动传播不完全时,就有可能会导致冲突现象的发生.此外,对于定制者采用的一些不当定制决策,应提供机制予以取消.在取消定制决策时,特征的绑定状态仍应满足特征模型中的精化关系与约束关系.定制不是一个单向性的过程,更不能对先前的“失误”操作无法处理.因此,提供回退机制是必要的.特征模型的概念最早是由Kang等人[2]在领域分析方法中提出.从20世纪90年代以来,软件复用研究重新成为了热点,软件复用被认为是解决“软件危机”,提高软件开发效率和质量,实现软件产业工业化生产方式的有效途径.其中,在特征模型的定制问题上,Mannion等人的方法[3]是一种基于树状结构的特征模型定制方法.它考查了特征模型中变化性的三种表示方式(可选性特征、多选一变化点以及多选多变化点),并提出了从树状结构的根出发,逐步向下对特征模型进行定制的策略.这种定制方法可以保证满足同一个变化点的子特征之间的约束,然而未必可以保证满足全局的约束.Hotz等人[4]提出了一种基于知识的定制方法.该方法使用专门的配置语言将特征、用户需求和其它制品在一个单独的配置模型中进行建模,并且提供工具对产品的定制生成实现部分自动化.然而,该方法没有说明配置模型与特征模型以及其它模型之间的联系以及相互的影响.FORM方法的提出者[5]就意识到了在选择特征的时候,需要检查特征模型的完整性和一致性,并且提议采用约束检查算法来辅助验证.Mannion等人[3]基于文献[6]中的思路提出使用命题逻辑对特征的树状结构以及特征间的约束关系进行形式化.于是,就将特征模型的验证问题转化为逻辑表达式的可满足性问题.Batory[7]也采用了基于命题逻辑的约束形式化方法,提到了将定制决策进行传播的思想.然而上述方法都没有提出特征模型定制的选择性回退机制,无法对特征模型的绑定状态进行自由切换.针对上面的问题,本文提出了特征模型定制的一种自动传播策略,在处理精化关系与二元约束的自动传播算法的基础上,增加了处理关于复杂约束的自动传播的过程.在此之后,本文提出一种特征模型定制的选择性回退机制,实现特征模型中特征的绑定状态的自由改变.本文第2节主要介绍特征模型定制问题相关的背景知识;第3节详细阐述特征模型定制的自动传播机制;第4节给出特征模型定制的选择性回退机制;第5节介绍实验室针对该算法开发的工具;第6节对全文进行总结.2背景知识本节主要介绍与特征模型定制问题相关的背景知识,主要包括两个方面:特征模型的基础知识与特征模型定制的相关概念.2.1特征模型领域特征模型是对一个特定领域的软件需求的有组织的描述,反映了该领域内应用系统所共有的属性和系统间可能存在的差异性、系统本身所具有的变化性及领域外部环境可能具有的变化性.特征模型是由特征及特征之间的关系构成.特征是一组具有紧密联系的需求,是具有客户/用户价值的软件特点[8].特征模型可以被定义为一个六元组[9]:(F,Root,Page3Refine,BS,RDC,EAC).其各自代表的含义如下:F是一个集合,其中包括n个特征{f1,f2,…,fn}.Root是F中的一个特征,Root∈F,代表特征模型的根特征.Refine表示特征模型中的精化关系,形式化地表示为F→F的映射.精化用来表示特征模型中的父子关系,在特征模型中,精化关系把不同层次和粒度的特征连接起来,从而形成一种层级结构[9].它在元模型中还具有3个子类:分解关系(Decomposi-tion)、属性化(Detailization)和特殊化关系(Special-ization).一个特征要么是一棵特征树的根结点,要么由唯一的一个父特征精化而来.BS表示一个特征的绑定状态,是F中的任何一个特征的属性.该属性的值只可能为以下3个之一:bound,removed,undecided,分别表示该特征处于被绑定、被移除与未决定的状态.RDC表示由精化关系获得的约束关系.对于一个精化关系,若f1为f2的父特征,由其中可获得约束关系f2依赖于f1.如果f2为必选特征,则可获得约束关系f2相互依赖于f1.EAC是一组约束关系的集合,表示在特征模型之中的显示约束.它分为二元约束与组合约束这两种不同的形式.特征模型中包括二元约束与组合约束两种约束关系.二元约束是指两个特征之间的相互关系,包括3种形式:f1requiresf2,f1excludesf2,f1mutual-requiresf2,分别以f1→f2、f1∨f2与f1f2表示.其中当特征的绑定状态为bound时其取值为真,当其绑定状态为removed时取值为假.组合约束又名复杂约束,表示两组谓词之间的相互关系,包括3种形式:P1requiresP2,P1excludesP2,P1mutual-requiresP2,其真值与二元约束相同.其中P1与P2有3种形式,分别为single-bound(f1,f2,…,fn),all-bound(f1,f2,…,fn),multi-bound(f1,f2,…,fn),分别表示在f1,f2,…,fn的绑定状态中仅有一个为绑定、全部为绑定、至少有一个为绑定.图1是一个特征模型的例子.在该例子中,存在一个二元约束关系:视频通信requires语音通信.此外,该例子中还有一个组合约束未在图上标明,为运行平台requiressingle-bound(桌面平台、手机平台).图中所示带圆圈标记的为可选特征,否则为必选特征.{2.2特征模型的定制从领域特征模型(DomainFeatureModel,DFM)到应用系统特征模型(ApplicationFeatureModel,AFM)是一个定制的过程.通过对领域特征模型的定制,可使领域分析结果得以大粒度复用.特征模型中的特征可以根据其绑定状态被分为3个集合:BoundSet、RemovedSet、UndecidedSet.在特征模型的建模过程结束后,所有未决定绑定状态的特征都位于集合UndecidedSet.定制所要做的事情就是将UndecidedSet中的每一个特征转移到BoundSet与RemovedSet中,使得(其中card表示集合的势):card(UndecidedSet)=0card(BoundSet)+card(RemovedSet)=card(F其中,对于f∈BoundSet或者f∈RemovedSet,不能够使RDC与EAC中出现假值.即对于所有的定制决策,必须满足特征模型的约束关系.如果一个特征从UndecidedSet转移至BoundSet,则称这个特征被绑定,反之若一个特征从UndecidedSet转移至RemovedSet,则这个特征称作被移除.因此,对于特征模型的一个定制决策,需要设计定制的自动传播机制以保证其满足约束关系.即当定制者将一个特征f从UndecidedSet转移至BoundSet或RemovedSet中时,需使相关的特征f1,f2,…,fn自动从UndecidedSet转移至BoundSet或RemovedSet中.这个过程被称之为特征模型的自动传播.同时,定制并不是一个单向的过程.定制工具应该提供机制使得定制者可以撤销自己的定制决策.即,一个特征f除可从UndecidedSet转移到BoundSet或者RemovedSet外,也应有机制使它可从BoundSet或RemovedSet转移至UndecidedSet,同时满足特征模型的约束关系.这个过程称之为选Page4择性回退.例如,对于图1中的特征模型而言,当定制者绑定特征语音邮件时,其父特征语音通信则必须被绑定,否则就会使RDC为假.类似的,如果定制者绑定特征视频通信时,特征语音通信也需要被绑定,否则就会使得EAC为假.若定制者绑定特征运行平台与桌面系统,那么特征手机系统就应当被移除,否则就会使得EAC中的组合约束值为假.这个过程就是定制的自动传播过程.再如,对于图1中的特征模型而言,当定制者绑定特征语音邮件与视频通信时,特征语音通信会被绑定(见上面的分析).当定制者选择性回退特征语音通信(即把特征语音通信从BoundSet转移到UndecidedSet),特征语音邮件与视频通信都应当被转移至UndecidedSet,以满足特征模型的约束关系.3特征模型定制的自动传播策略特征模型定制的自动传播其本质就是在一个特征的绑定状态被修改后,修改其它特征的绑定状态使之可以满足特征模型中的约束关系与精化关系.因此,可以将这个问题分解成为两个部分,即首先处理与某个特征相关的二元约束与精化关系,再处理与之相关的复杂约束.当然,二元约束可以看作一种特殊的复杂约束,自然也可以利用复杂约束的自动传播算法进行传播.然而,将有关二元约束的定制的自动传播算法独立出来有其必要.因为在一个特征模型中,往往存在着大量的二元约束,复杂约束的数量相对较少,因此,如果可以用较小的时间开销来完成关于二元约束的定制的自动传播,就可以降低传播的时间复杂度.3.1关于二元约束的定制的自动传播关于二元约束的定制的自动传播机制可以通过原子集、依赖集与互斥集[10]的手段快速进行传播.对于一个特征及其必选的子特征,可以将其合并为一个集合,称之为原子集.对于原子集中的所有特征,其绑定状态都是相同的.可以用F.AS来表示F所在的原子集.对于一个原子集中的所有特征,可以在定制的时候将其当作一个整体对其进行统一处理.对于一个原子集,可以定义其依赖集.一个原子集AS的依赖集可以被表示成AS.RS.依赖集的元素都是原子集.如果AS1∈AS.RS,表示对于AS中的任何一个特征F,AS1中的任何一个特征F1,都存在约束关系FrequiresF1.类似地,可以定义一个原子集的互斥集.原子集AS的互斥集可以被表示成为AS.ES,互斥集中的元素都是原子集.如果AS1∈AS.ES,表示对于AS中的任何一个特征F,AS1中的任何一个特征F1,都存在约束关系FexcludesF1.如果定制者绑定一个特征F,则需要定制工具将F的依赖集里的原子集中所有特征的绑定状态设为bound,将F的互斥集里的原子集中所有特征的绑定状态设为removed,同时将F的父特征绑定状态设为bound.如果定制者把特征F的绑定状态设为removed,则需要定制工具将依赖集中包含F的原子集里所有的特征绑定状态设为removed,同时将F的子特征的绑定状态设为removed.算法1.构造原子集的依赖集与互斥集算法.输入:源原子集AS输出:AS的依赖集AS.RS与互斥集AS.ES1.countrs(AtomSetAS){//构造依赖集2.AS.RS.add(AS);3.intlength;4.do{5.length=RS.size();6.for(FeatureFinAS){7.if(existFrequiresF1‖Fmutual_requiresF18.AS.RS.add(F1.AS);9.}10.}11.while(RS.size()>length);12.}13.countes(AtomSetAS){//构造互斥集14.AS.ES.empty();15.intlength;16.do{17.length=ES.size();18.for(FeatureFinAS){19.if(existFexcludedsF1‖F1excludesF)20.AS.ES.add(F1.AS);21.}22.}23.while(ES.size()>length);24.}算法的第1~12行表示构造依赖集的算法,第13~24行表示构造互斥集的算法.依赖集的构造思路是寻找对于其中元素F,是否存在特征F1满足FrequiresF1,若存在,则将F1的原子集添加到该依赖集中.反复进行如此的操作直到该依赖集的大Page5小不再增长为止.对于互斥集,构造算法与之类似.区别在于两点:(1)依赖集在构造时需要将该原子集本身加入依赖集中,而互斥集不必;(2)互斥集的构造过程检查是否存在FexcludesF1关系,而非FrequiresF1.基于上述二元约束定制的自动传播策略,一旦定制者的预处理操作结束后,相关特征的二元约束将自动传播.由于创建原子集、依赖集与互斥集的过程是一个预处理的过程,在实施定制操作时,不必检索与原特征相关的所有二元约束,只需要读取该特征的原子集、该特征原子集的依赖集与互斥集即可,因此可以节约大量的时间.3.2关于组合约束的定制的自动传播通过原子集、依赖集与互斥集的算法可以有效地解决关于二元约束的定制的自动传播算法.然而,在特征模型中,组合约束也可以导致特征模型的自动传播.如图2所示的组合约束中,有f1、f2与f3这3个约束绑定数待定数表1Multi-Bound谓词自动传播规则01只有绑定这一个待定特征才能使谓词取值为真,所以可能的定制方式唯一.可以自动传播0>1绑定任意一个特征都可以使谓词成真,所以可能的定制方式不唯一.不能自动传播0任意只有删除所有待定特征才能使谓词取值为假.所以可能的定制方式唯一.可以自动传播约束绑定数待定数0任意只有绑定所有待定特征才能使谓词取值为真,所以可能的定制方式唯一.可以自动传播表2All-Bound谓词自动传播规则01只有删除这一待定特征才能使谓词取值为假.所以可能的定制方式唯一.可以自动传播0>1任意删除一个待定特征都能使谓词取值为假,所以可能的定制方式不唯一.不能自动传播TRUEFALSETRUEFALSE表1、表2、表3中的约束表示谓词的真假状态,绑定数表示谓词中的特征绑定状态为bound的数量,删除数表示谓词中的特征绑定状态为removed的数量,待定数表示谓词中的特征绑定状态为undecided的数量,三者相加即为谓词中所有特征的总数.通过以上规则,可以提出关于组合约束的自动传播算法.通过以上的关于组合约束谓词的自动传播规则,可以寻找关于组合约束自动传播的算法.事实上,只有在表4的几种情况下,组合约束谓词的状特征,并且没有任何的精化关系与二元约束关系.如果此时绑定特征f1,同时绑定特征f2.那么,只有删除特征f3,该组合约束才能被满足.如何处理涉及组合约束的定制决策传播成为定制此类特征模型时所需解决的问题,为此,本文提供了关于组合约束的定制的自动传播机制.关于组合约束按照谓词的不同分别有如下的传播规则.对于Multi-Bound,All-Bound,Single-Bound谓词分别予以讨论.对于组合约束的谓词Multi-Bound,传播规则如表1所示.对于谓词All-Bound,传播规则如表2所示.对谓词Single-Bound,传播规则如表3所示.态才会自动传播(表4中的P与P1皆表示谓词).因此,组合约束是否可以自动传播,取决于如下的两点:(1)谓词的状态是否改变.(2)谓词状态的改变是否会影响到谓词中的特征的绑定状态.根据上面的组合约束的传播规则,可以给出如下的算法来处理关于组合约束的定制的自动传播.Page6约束绑定数待定数表3Single-Bound谓词自动传播规则TRUEFALSE11只有绑定这一个待定特征才能使谓词取值为假,所以可能的定制方式唯一.可以自动传播1>1再绑定任意一个特征都可以使谓词取假,所以可能的定制方式不唯一.不能自动传播组合约束关系P的状态P1应被设为的状态PrequireP1PexcludeP1P1requirePFalseP1excludePTruePmutual-requiresP1TrueP1mutual-requiresPTruePmutual-requiresP1FalseP1mutual-requiresPFalse算法2.关于组合约束的定制自动传播算法.输入:需要自动传播的特征f输出:在自动传播过程结束后的特征绑定状态(BS)1.Propagation(Featuref){2.if(f.pro)return;//特征的pro属性被初始化为假3.set_binding_state(f);4.f.pro=true;5.ProSet(f);//根据原子集、依赖集、互斥集调用二6.ProCS(f);//调用组合约束的自动传播算法7.}8.ProCS(Featuref){//组合约束传播算法9.for(declarevarpasPredicate,eachpcontainsf){10.if(p.state==unknown){//若该谓词状态不确定11.booleanb=proFintoP(p);12.if(!b)continue;13.for(declarevarccasCompositeConstraint,14.if(thestateofpandccareinForm.4){15.p1=cc.get_opposite_predicate();16.set_state(p1);//设置p1的绑定状态17.proPintoF(p1);18.}19.}20.else{21.proPintoF(p);22.}23.}24.}25.proPintoF(Predicatep){26.intnum_bound,num_removed,num_undecided;27.count(num_bound,num_removed,num_undecided);28.switch(p.group){29.casesingle:30.if(numsareinForm.1)31.propagation(finForm.1);32.break;33.casemulti:34.if(numsareinForm.2)35.propagation(finForm.2);36.break;37.caseall:38.if(numsareinForm.3)39.propagation(finForm.3);40.}41.}42.boolproFintoP(Predicatep){//检查特征绑定状态的变化是否会引发谓词状态的变化43.if(p.state!=unknown)44.returnfalse;45.switch(p.group){46.casesingle:47.boolchange=searchForm(Form1,p);48.set_state(p);49.returnchange;50.casemulti:51.boolchange=searchForm(Form2,p);Page752.set_state(p);53.returnchange;54.caseall:55.boolchange=searchForm(Form2,p);56.set_state(p);57.returnchange;58.}59.}上述算法中第1~7行表示特征模型定制操作的主函数,通过设立一个pro的布尔属性表示特征是否被传播过.第8~24行表示关于组合约束的特征模型定制的自动传播算法过程,检查谓词的状态是否不确定,如果确定,则查表1~表3,检查是否可以传播到谓词内的特征;若不确定,则检查是否会改变谓词的状态,如果可以,则查表4,看是否可以传播到另一个谓词.第25~41行表示在谓词内部进行传播的算法,通过查表1~表3,看是否可以让谓词内部的特征绑定状态发生改变.第42~59行表示特征向谓词传播的算法,看特征的绑定状态改变是否会引发谓词的绑定状态改变.3.3特征模型定制的自动传播算法时间复杂度与正确性分析本节将就实现特征模型定制的自动传播机制的算法进行分析.在定制的自动传播过程中,该算法所用的时间相当于关于二元约束与组合约束传播的时间进行相加.对于二元约束而言,根据上面的分析,传播的时间复杂度为O(n),n表示应改变绑定状态特征数目.对于关于组合约束的定制的自动传播,可以设与一个特征相关联的组合约束个数为p,组合约束中包含的特征数目为q,那么一次proCS操作所用到的时间为O(pq),在一次propagation算法中,关于组合约束的定制传播所用到的总时间不会超过∑pq,其中p为所有应改变绑定状态的特征相关的所有组合约束,q为与之对应的组合约束内的特征数目.同时,如果在propagation过程中,绑定或删除了某一个特征,那么该特征会被标记pro属性以避免其被第2次递归调用.因此,设一个特征模型中的总特征数目为m,那么propagation算法所用的时间不会超过O(m).因此,在一次特征模型的定制的自动传播操作中,所用的时间不会大于O(max{n+∑pq,m}).在特征模型中,m的规模不会特别大(目前被使用的最大的特征模型其规模为103级别),所以所用时间完全在可以接受的范围之内.在特征模型被验证一致的情况下,该算法可以在不违反约束关系的前提下,对特征模型的绑定状态进行正确的传播.该算法的正确性基于特征模型的一致性.如果特征模型被验证不是一致的,那么该算法就无法对特征模型进行正确的传播.例如,对于一个特征模型ArequiresB,AexcludedB,那么,此时特征A的绑定状态必然是removed.但由于该特征模型不是一致的,特征模型的定制自动传播算法无法检查到特性A是一个死特征(deadfeature),因而在绑定特征A时,会导致错误的结果.解决的方法是在特征模型的定制操作之前,对特征模型进行一致性验证.对于满足一致性的特征模型,可以用逻辑验证的方法证明,上述算法对特征模型定制的自动传播操作不会违反特征模型的约束关系.4特征模型定制的选择性回退机制对于特征模型而言,如果提供了定制的自动传播算法,就需要提供定制的选择性回退算法,相当于自动传播算法的逆算法.选择性回退算法需要满足以下的条件:(1)在对特征f执行选择性回退算法后,f的绑(2)在执行定制的选择性回退后,不允许出现(3)定制的选择性回退算法应该尽可能多地保留定制者的定制决策.例如,对于下面的例子:f1表示使用平台;f2表示桌面平台;f3表示平板电脑平台;f4表示手机平台;f5表示呼叫转接.它们之间具有如下的约束关系:这时,当定制者进行以下4步时,f4将被绑定:f1→single-boundf2,f3,f()4,f5→f4①删除f3.②删除f2.③绑定f1.④绑定f5.那么,此时如果定制者选择性回退特征f4,选择性回退算法需要做的,就是取消其后两步,将f1与f5的绑定状态变回undecided.这样f4的绑定状态就会变为undecided.如果仅仅取消第3步或第4步其中的一步,那么显而易见,f4的绑定状态仍应定状态需变为undecided.某些特征的绑定状态与约束关系相冲突.Page8为bound而非undecided.但选择性回退算法不应当再取消第1步或第2步,因为取消后两步已经足以让f4回退到undecided,本着保留尽可能多的定制决策的目的,不应该再回退更多的定制决策.对于上述选择性回退算法,下面分两个部分来讲述选择性回退算法的实现步聚.4.1单步回退算法单步回退算法是指回退定制者定制决策的最后一步,即Undo操作.单步回退算法可以算做是选择性回退算法的一部分,是实现选择性回退算法的基础.为了实现单步回退算法,首先需要开辟一个栈空间ActionStack,用来存放定制者已经完成的定制决策.ActionStack栈的每一项被称为一个Action-Item,包含3部分内容:(1)定制决策的定制源(即用户手动修改绑定状态的特征),设为Source.(2)本次定制决策影响到的一组特征,这些特征被修改绑定状态,设为Features.(3)本次定制决策影响到的一组谓词,这些谓词被修改真值,设为Predicates.其结构如图3所示.为了实现单步回退算法,需要对propagation算法加以修改.每调用一次propagation算法之后,都需要记录在其中影响到的特征与谓词.当propagation算法被调用一次,就需要在ActionStack栈中追加一项ActionItem压入栈中.其中该ActionItem的Source属性为propagation算法的参数,其Features与Predicates属性分别为这个propagation算法影响到的特征与谓词.在执行单步回退操作时,算法需要将Action-Stack栈的最后一项弹出,取出其定制源,将Source与Features的特征的绑定状态还原为undecided,并将Predicates的真值还原为unknown,即可实现单步回退操作.4.2选择性回退算法选择性回退算法的思路是依据定制决策的时序性,利用ActionStack与单步回退算法实现定制的选择性回退.ActionStack是一个栈的结构,每次的存取都访问顶端的元素,对于选择性回退算法而言,需要取消ActionStack中间的定制决策.当然,并不能简简单单地将对应项的ActionItem中的相关特征与相关谓词回退,因为这样可能会对之后的定制的自动传播产生影响.一个很容易想到的思路是做多次的弹栈与压栈操作.比如,当现在的ActionStack一共含有n个ActionItem,如果想要取消第m项的定制决策,则先执行Undo操作m-n+1次,再执行m-n次propagation算法将最后的m-n个定制决策重新执行.但是,这样就会造成一些问题.例如现在需要选择性回退一个特征f,先执行Undo操作m-n+1次后,这时f的定制状态会被回复到undecided.如果再执行m-n次的propagation操作,这m-n次的propagation操作可能会再次修改f的绑定状态.一个直观的例子如图4所示.当定制者按顺序绑定特征A、B、C、D时,特征E这时会被绑定。此时的ActionStack如图5所示(由于在定制的自动传播算法中,在A被绑定之后,E的pro属性已经被修改,故而绑定B、C、D都不会影响到E的绑定状态):此时,可以找到E的绑定状态发生变化是由第一步定制决策导致的,但是由于绑定B、C、D这3个定制决策,都会导致特征E被绑定,所以通过先进行数次Undo操作,再重新propagation的做法是无法实现定制的选择性回退的.一个比较好的解决方法是,如果要将一个特征f选择性回退,先找出是哪一步定制决策(设为第m步)影响了f的绑定状态.根据定制的自动传播的机理,前m-1步的所有定制决策,都是可以被保留的.同时,第m步的定制决策,将必然不可以被保留.然后再对第m步之后的定制决策,进行讨论.Page9可以通过一个试探性的propagation算法,决定该定制决策是否被保留.比如,当讨论到第p个定制决策时(p>m),先对其进行一次propagation,如果发现它修改了f的定制状态,再进行Undo操作,证明该定制决策不可用,然后讨论第p+1个定制决策,直到ActionStack结束.例如,对于上面的例子而言,它的执行过程如图6所示,叉号表示定制决策不可用,未被选中.ActionStack){此算法实现如算法3.算法3.选择性回退算法.输入:需要选择性回退的特征f.输出:在选择性回退过程结束后的特征绑定状态(BS).1.selective_undo(Featuref){2.if(f.binding_state==undecided)3.return;4.intm;//记录哪一项定制决策修改了f的绑定状态5.for(declarevaraiasActionItem,eachaiin6.if(ai.Source==F‖ai.Features.contains(F)){7.m=ai.index;8.break;9.}10.}11.Featureft[];12.binding_statebs[];13.for(intj=m+1;j<ActionStack.size();j++){14.ActionItemai=ActionStack[j];15.ft.add(ai.Source);16.bs.add(ai.Source.binding_state);17.}18.for(inti=1;i<=ActionStack.size()-m;i++){19.Undo();20.}21.for(inti=0;i<ft.size();i++){22.set(ft[i],[bs[i]];23.propagation(ft[i]);24.if(ft[i].binding_state==undecided)continue;25.Undo();26.}27.}算法的第4~10行的作用是寻找是哪一个定制决策影响了f的绑定状态,设为m.第11~17行是临时存储第m项之后的定制决策.之后连续进行多个Undo操作,第21~26行检查第m项之后的定制决策是否可以使用,如果可以,则使用;否则,则跳过.对于特征模型的定制,通过定制决策的自动传播算法与选择性回退算法就可以实现特征模型中特征绑定状态的自由切换.如果定制者将一个特征从BoundSet中转移到RemovedSet中,或者将其从RemovedSet中转移到BoundSet中,那么就可以通过先调用selective-undo算法将其转移到UndecidedSet中,然后再将之转移到BoundSet/RemovedSet中.特征在这3种绑定状态之间的相互转化如图7所示.上述算法可以确保在选择性回退的过程之中,保留了尽可能多的定制决策.假设选择性回退特征f的过程保留的定制决策集合为S_Set,在该过程中去除的定制决策集合为R_Set,假设如果有另一个集合S_Set满足让f的绑定状态变为undecided,同时S_SetS_Set,那么,必然可以寻找到一个决策U,使得U∈S_Set同时U∈R_Set.然而,在选择性回退的过程中,采用决策U会导致f的绑定状态变为bound/removed(由S_Set与R_Set的计算过程可知),这与S_Set满足让f的绑定状态变为undecided矛盾.因而上述算法确保在选择性回退过程中保留尽可能多的定制决策.4.3关于回退方法的总结回退操作是许多系统中都会遇到和解决的问题.例如,在文本编辑操作、图形编缉、面向对象建模等过程中,都会用到回退操作.特征模型的定制过程中的选择性回退操作与这些回退操作既有一定的共同点,也有其不同之处.回退操作机制大致上可以分为3种:单次回退机制、多次回退机制与选择性回退机制.单次回退机制是指允许使用者回退刚刚进行的操作,但无法连续回退多步.多次回退机制则是将使用者的操作记录于一个栈中(类似于在本算法中使用的Action-Stack结构),回退的过程是一个弹栈的过程,其过Page10程类似于本文中之前提到的特征模型定制过程中的单步回退操作.特征模型定制操作的回退过程,与其它回退过程的不同之处在于它具有选择性回退操作.选择性回退的机制允许取消定制者做过的错误定制决策.由于错误的定制决策很有可能并非是最近的定制决策,需要考虑该定制决策与最近的定制决策之间的操作是否会对结果产生影响,所以需要制定相关的算法,以确保最终得到定制者希望得到的结果.本文中提到的定制的选择性回退算法可以得到一条可行的定制回退方案.同时,在这条定制方案中,已经不能再加入任何一条先前的定制决策使得目标特征的绑定状态为undecided同时满足特征模型的约束关系.然而,本文中的准则,即求出一条最大的可行定制回退方案,有的时候,并非是定制者想要的结果.例如,对于本节开始的例子,如果取消第1步与第4步,一样可以让特征f4的绑定状态回退为undecided.如何取得特征模型定制的选择性回退的多种回退方案,将是未来的工作需要实现的目标.5支持工具本文所提出的针对特征模型定制的自动传播机制与选择性回退机制,均已在开发的基于矩阵的特征模型建模与定制工具中得以实现.图8是该工具的一张截图.该工具采用SWT/JFace设计,作为一个Eclipse插件使用.界面的顶部是一个工具栏,用来管理I/O与特征模型的建模功能,同时可以切换特征模型的建模状态与定制状态.界面的中部是采用表格的形式显示整个特征模型,最左列为特征模型的特征树,第2列为特征的绑定状态,之后每一列都表示特征模型的一个约束关系.与约束关系相关的特征将在表格内用圆角矩形予以表示.特征树中的特征用黑色和蓝色区分必选特征与可选特征.界面的底部是一些辅助窗口,分别表示特征模型的特征属性、预传播、定制决策列表与约束列表.在建模状态下,该工具可以修改特征的属性.在定制状态下,可以修改特征的绑定状态以进行特征模型的定制操作.6总结本文提出了一种特征模型定制的自动传播机制与选择性回退机制,并给出相应的实现算法.定制的自动传播算法的主要特点是可以处理关于二元约束与组合约束的自动传播,而选择性回退算法则可对先前错误的定制决策予以撤销,使得定制操作可以自由地改变特征模型中特征的绑定状态,同时满足特征模型中的约束关系.通过支持工具的实验验证,该算法对特征模型的定制操作可以提供很好的支持.本文所提的特征模型定制方法仍然具有进一步优化的可能,比如说在选择性回退时,可以提供更多的回退路线.在将来的工作中,将继续深入研究特征模型定制问题的特点,并希望能够利用这些特点进一步完善特征模型定制的相关算法.
