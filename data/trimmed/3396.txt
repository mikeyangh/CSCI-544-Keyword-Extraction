Page1一种目标制导的混合执行测试方法崔展齐王林章李宣东(南京大学软件新技术国家重点实验室南京210093)(南京大学计算机科学与技术系南京210093)摘要混合执行测试(concolictesting)是一种将具体执行与符号执行相结合的自动化测试方法.由于混合执行测试从程序本身出发,未将目标缺陷的先验知识作为指导,会导致生成和执行大量不能发现缺陷的测试输入,从发现缺陷的角度看浪费了时间和计算资源开销.这个问题在具有时间、成本及资源约束的实际测试任务中更加突出.为解决这一问题,文中提出了一种结合静态分析和混合执行测试技术的目标制导的混合执行测试方法:使用静态分析工具分析待测程序中可能含有缺陷的可疑语句及其缺陷类型,并将静态分析所报告的可疑语句作为目标指导测试.目标制导的混合执行测试技术分为3个步骤:首先,计算从程序各分支到待检测缺陷语句的可达性;其次,对待测试程序进行插装以支持混合执行测试;第三,使用静态分析的结果和可达性信息作为指导,只生成和执行可能会覆盖待检测缺陷语句的测试输入,以避免生成和执行不能发现缺陷的测试输入.基于此方法,作者实现了一个测试缓冲区溢出缺陷的原型工具:TARGET,并在一组C语言基准程序上进行了对比实验.实验结果表明与原有的混合执行测试技术相比较,TARGET能在更短的时间内发现程序中更多的缺陷.关键词目标制导测试;缺陷触发;静态分析;混合执行测试1引言为提高软件质量,软件测试和静态分析是两类使用最为广泛的缺陷检测技术[1-2].其中,软件测试是目前工业界使用最多的软件质量保障手段,而静态分析近年来开始逐渐得到工业界的重视和应用.静态分析技术能在软件生命周期的较早阶段发现程序缺陷[3-4].此外,静态分析能在很大程度上实现自动化,具有人力成本开销较小的优势.软件测试技术通过测试用例来触发和确认程序缺陷,能发现程序中的真实缺陷[5].同时,具体的测试用例还能够为软件工程师调试和排错提供有效帮助.但是,软件测试工具通常需要一个较为充分的测试用例集,这在大多数情况下是难以获取的.混合执行测试[6-7]是一种有效的提高测试自动化程度的技术,其目标是通过自动生成测试输入来执行程序中的所有可行路径,从而发现程序缺陷.混合执行测试技术在待测试程序上执行具体输入的同时进行符号执行.首先通过插装的方式在程序执行过程中收集路径条件的符号表达式,然后通过约束求解器求解所收集到的路径条件,以生成执行新路径的测试输入.当不能求解所收集到的路径条件时,混合执行测试使用具体的值来简化符号表达式.混合执行测试在一定程度上解决了缺乏测试用例集的问题,但由于该方法从程序本身出发,未将目标缺陷的先验知识作为指导,导致生成和执行了大量不能覆盖缺陷语句的测试输入,从发现缺陷的角度看,浪费了时间和计算资源开销.由于只有能覆盖缺陷所在语句的测试输入才有可能触发缺陷,不能覆盖缺陷语句的测试输入对发现缺陷是毫无贡献的.如能获取程序中潜在缺陷的类型和位置,就能在不损害缺陷发现能力的前提下,通过避免生成和执行不能覆盖缺陷语句的测试输入来降低测试开销.而一些静态分析工具,则能报告程序中潜在缺陷语句的位置和缺陷类型信息,但由于静态分析在分析过程中使用了一些保守的假设,因而具有较高的误报率.从含有大量误报的缺陷警报中识别出真正的缺陷仍需要大量的人力和时间开销.软件测试和静态分析在很大程度上具有互补性,如果能有效地利用静态分析的结果来指导软件测试,将带来两方面的好处:一方面,静态分析工具所提供的信息能为软件测试提供测试的目标,从而降低软件测试的开销;另一方面,软件测试提供的运行时信息能用于确认和精化静态分析工具所报告的缺陷警报.基于上述思路,本文提出了一种静动态结合的目标制导的混合执行测试方法:使用静态分析工具分析待测程序,检测程序中可能会含有缺陷的可疑语句及其缺陷类型,并将静态分析所报告的可疑语句作为待检测缺陷语句,指导测试输入的生成和执行.目标制导的混合执行测试方法分为3个步骤:首先,使用程序控制流程图分别计算从程序各分支语句到待检测缺陷语句的可达性;其次,对待测试程序进行插装以支持混合执行测试;第三,使用静态分析的结果和可达性信息作为指导,只生成和执行可能会覆盖待检测缺陷语句的测试输入,以避免生成不能发现缺陷的测试输入.我们在一组C语言基准程序上就缓冲区溢出缺陷进行了对比实验.实验结果表明,与原有的混合执行测试技术相比较,本方法能在更短的时间内发现更多的程序缺陷.本文的主要贡献在于:(1)提出了一种结合静态分析和混合执行测试的缺陷检测方法,使用静态分析报告的潜在缺陷的位置和类型信息指导混合执行测试,从而降低测试开销;(2)基于该方法实现了一个用于检测C语言中缓冲区溢出的原型测试工具,并在一组C语言基准程序上进行了实例研究以评估本方法的有效性.本文第2节给出混合执行测试和静态分析的相关背景知识;第3节通过一个例子来引出使用静态分析结果作为目标指导测试的动因;第4节详细描述目标制导的混合执行测试技术;第5节介绍原型工具的实现并进行实验和评估;第6节介绍相关的工作;第7节总结本文的工作并进行展望.2背景介绍2.1混合执行测试混合执行测试[6-7]是一种将具体执行与符号执Page3行相结合的自动化测试方法,其目标是通过生成测试输入来执行程序中的所有可行路径,以发现程序缺陷.其中,concolic是将具体(CONCrete)和符号(symbOLIC)两个词结合在一起所构成的一个新词.具体执行是以具体的输入值执行程序;符号执行使用变量符号代替具体的输入值,模拟执行程序,得到程序各路径条件的符号化表达式,然后对符号表达式进行约束求解,以得到能够执行指定程序路径的具体输入值.而混合执行测试则是将具体执行与符号执行相结合的测试技术,其思想是在具体执行过程中收集路径条件的符号表达式,并按照深度优先的策略将路径条件逐一取反,然后通过约束求解的方式求解取反后的路径条件,以获得执行新路径的测试输入.当不能求解路径条件时,使用具体的值来代替符号表达式,以简化路径条件.在混合执行测试技术的基础上,有一些相关的扩展工作.Sen等提出的CUTE[7]将混合执行测试技术扩展到支持含有指针和数组等复杂数据结构的程序,JCUTE[8]将混合执行测试技术用于自动化测试多线程程序的竞争问题.为解决混合执行测试中分支覆盖率较低和可扩展性不强的问题,CREST[9]提出了几种基于程序静态控制流图的路径搜索策略,尽量生成执行尚未覆盖分支的测试输入.SPLAT[10]则将缓冲区的一段前缀和缓冲区的长度进行符号化建模,用于检测程序中的缓冲区溢出缺陷.2.2静态分析静态分析是指在不运行软件的前提下对软件的各种性质进行分析的过程,其对象可以是设计模型、源程序、字节码等软件生命周期中的各种产物[2].静态代码分析技术最常见的用途是检查源程序中的缺陷,可以按是否流敏感、是否路径敏感、是否支持过程间分析等维度进行分类[4].静态分析技术的优势在于自动化程度高、可扩展性好,能处理规模较大的程序,其缺点在于精度不高,可能会出现误报(falsepositive)和漏报(falsenegative)的情况.误报是指分析工具所报告的缺陷实际上并不存在,而漏报则是指分析工具未能检测出程序中存在的某些缺陷.另外,如何从静态分析的结果中识别出真实的缺陷,并设计测试用例以确认该缺陷仍然具有很大的挑战性.Splint[11]、ARCHER[12]、BOON[13]等静态分析工具能够报告程序中缺陷语句或变量的位置.Prefix[14]、PREfast①、Marple[15]等静态分析工具对识别出的缺陷还提供了相应的路径信息.3示例图1是将WuFTP-1[16]中的一个缺陷进行简化后的示例程序,其中path是一个输入字符串,Example函数的功能是将path中字符串拷贝到数组mapped_path中,若path的第1位不为‘/’,则需要在前面加上‘/’后再进行拷贝.如该程序的控制流程图所示,该程序共包含4条路径,第8、9行修改了mapped_path中的内容,是可能引发缓冲区溢出错误的语句,其中当path的第一位不为‘/’且长度为9时,将会在第9行触发缓冲区溢出错误.使用支持缓冲区建模的混合执行测试工具,如SPLAT[10],将会尝试覆盖程序中的所有路径,并在每次修改缓冲区时检查是否可能溢出.第一,将空字符串作为path的默认输入并运行程序,覆盖语句2,3(T),4(T,F分别表示条件判断语句的true和false分支);第二,转置3(T)所对应的路径条件以生成非空字符串作为下一次程序运行的输入,假设为“a”,该测试输入将覆盖语句2,3(F),5(F),7(T),8,9,并分别在第8、9行检查缓冲区是否可能会溢出,结果为第8行在当前路径条件下不能溢出,第9行可能会溢出,生成长度为9且第1位不为‘/’的字符串作为测试输入并执行,以确认该缺陷;第三,转置7(T)所对应的路径条件,生成第1位内容为‘/’的测试输入,假设为‘/’,覆盖语句2,3(F),①https://www.microsoft.com/china/whdc/devtools/tools/Page45(F),7(F),9;第四,转置5(F)所对应的路径条件,生成长度为10的字符串,覆盖语句2,3(F),5(T),6,测试结束.在测试过程中共生成了5个测试用例以覆盖所有程序路径和确认缺陷,并对可疑语句检查了2次.若使用Marple进行静态分析,将报告第8行是安全的缓冲区修改操作,而第9行则是存在缺陷的.但第9行的缺陷是否为真实的缺陷以及将会如何被触发仍是未知的.观察上述结果发现,程序中可能存在缺陷语句的可疑程度是不同的,使用静态分析对待测试程序进行分析可排除部分不需要动态检测的安全语句.而程序中也只有部分分支能够到达需要动态检查的可疑语句,如分支3(T)、5(T)均不能到达第9行.运行不能覆盖待检测语句的测试输入,如路径2,3(T),4,不能对检测程序缺陷做出贡献.因此,若能有效地使用静态分析的结果指导测试,并不需要覆盖程序的所有路径来检测程序中所包含的缺陷.在测试过程中,若能避免生成和执行不能覆盖待检测缺陷语句的测试输入,将会降低测试开销.4目标制导的混合执行测试如图2所示,本文提出的目标制导的混合执行测试方法首先使用静态分析工具对待测试程序进行分析,获取程序中可能存在缺陷的可疑语句的类型及其所在位置,并将可疑语句作为待检测缺陷语句指导混合执行测试.目标制导的混合执行测试分为3个步骤:可达性分析、程序插装、动态测试.首先,计算程序中各分支语句与静态分析所报告的待检测语句间的可达性;其次,插装待测试程序,以支持在具体执行程序时收集路径条件和各变量的符号化表达式;第三,根据静态分析和可达性分析的信息判断需要覆盖的路径,求解路径条件生成测试输入,驱动程序执行测试输入,同时进行符号执行并对待检测语句进行符号化检测.4.1程序模型在详细介绍各步骤之前,我们先给出待测试程序的模型.基于CREST[9]所使用的程序模型,我们定义了如下与C语言类似的程序模型,用于描述目标制导的混合执行测试技术.待测试程序是由n个函数所构成的一个集合:{f1,f2,…,fn},其中包含一个程序执行的入口函数main.一个函数fi由mi条带标签的语句序列li,1:si,1,li,2:si,2,…,li,mi:si,mi所组成.组成函数的语句可分为5类:(1)输入语句,其形式为Input(var,t),为变量var输入t字节的值;(2)函数调用语句,其形式为fi(var1,var2,…),以var1,var2,…为参数调用函数fi;(3)赋值语句,其形式为Assign(vard,vars,t),将vars中t字节的值拷贝到vard中;(4)条件判断语句,其形式为ifcgotol;(5)终止语句,包含正常终止halt和异常终止abort两种形式.对于一条条件判断语句li,j:ifcgotoli,k,li,k和li,j+1分别为条件c为true和false时执行的下一条语句.我们称这样的两条语句为分支语句,且互为对应分支,将其表示为Pair(li,k)=li,j+1和li,k=Pair(li,j+1).程序的一条路径可表示为一个语句序列,其形式为(entry,B,exit),其中entry是程序入口语句,exit是该次执行的终止语句,B是该次执行过程中顺序经过的分支语句所组成的一个序列:b1,b2,…,bw.4.2静态分析为使用静态分析的结果来指导动态测试,降低测试开销,我们首先使用静态分析工具对待测试程序进行分析,并获取程序中可疑语句的缺陷类型及其所在位置.将可疑语句作为待检测缺陷语句指导测试,其中缺陷的类型将用于构造缺陷模型,用于动态运行时进行相应检查,位置信息则用于计算程序各分支语句到待检测缺陷语句的可达性.静态分析的结果需要具有尽可能高的精确度,因为误报会给动态测试带来额外的检测开销,而漏报则会导致动态测试时不对漏报的语句进行检测,从而将漏报传递给动态测试.一些静态分析工具支持将所报告的缺陷根据重要性进行排序,我们可按照测试预算从重要性较高的缺陷开始,依次选取需要动态检测的缺陷,并作为目标指导混合执行测试.4.3可达性分析并非所有的程序路径都能够覆盖待检测缺陷语句,触发静态分析所识别出的待检测缺陷更需要满足特定的条件.使用程序的结构信息能够部分避免Page5生成和执行不可达待检测缺陷语句的测试输入,从而将测试的重点尽量集中在能覆盖待检测缺陷语句的测试输入上,降低测试开销.本文中我们所使用的程序结构信息是基于过程间控制流图(Inter-proceduralControlFlowGraph,ICFG)所计算出的程序中各分支语句到可疑语句的可达性关系.ICFG是一个由节点和边所组成的有向图,一个节点对应于程序中的一条语句,而一条边则从一个节点指向该节点对应程序语句的直接后续语句所对应的节点.一个由n个函数{f1,f2,…,fn}所构成的程序,语句li,j:si,j的直接后继语句为如下的一个集合:·空集,若li,j:si,j为一条终止语句;·{li,j+1:si,j+1,li,k:si,k},若li,j:si,j为一条条件判断语句:ifcgotoli,k;若li,j:si,j为函数fi的返回语句;fr(…);·{lr,t+1:sr,t+1|函数fr中的语句lr,t为fi(…)},·{lr,1:sr,1},若li,j:si,j为一条函数调用语句:·{li,j+1:si,j+1},其它情况.基于ICFG,在转置分支b所对应的路径条件前,先判断b对应分支Pair(b)的可达性关系,若Pair(b)能达到某待检测缺陷语句,则进行约束求解并生成相应测试输入,否则,跳过该分支,继续转置其它路径条件.算法1描述了计算程序分支语句与可疑语句间可达性关系的算法.该算法将程序的ICFG和静态分析所提供的待检测缺陷语句集合V作为输入.输出mapreachability存放从各分支语句到该分支可达待检测缺陷语句集合的映射.第1~5行调用Reach过程计算分支语句到各待检测缺陷语句的可达性.Reach过程(8~15行)中第9行获取当前语句l的直接后继语句集合successors,第10行逐一检查successors中的语句li是否为待检测缺陷语句,若是,将li加入当前遍历分支的可达待检测缺陷语句集合reachable中.第13行迭代调用Reach过程遍历li的可达语句.算法1.分支可达性计算算法.输入:ICFG:icfg//程序ICFG图输出:mapreachability//从分支到可达待检测缺陷语1.foreachbranchstatementbinicfg{2.setreachable3.Reach(b,reachable)4.reachability[b]··=reachable5.}6.returnreachability7.8.Procedure:Reach(statementl,setreachable){9.setsuccessors··=Successors(l)10.foreachstatementliinsuccessors{11.ifli∈V12.reachable.push(li)13.Reach(li,reachable)14.}15.}4.4程序插装为了在执行具体测试输入的同时进行符号执行,需要对源程序进行插装以收集执行过程中对各个基本类型变量、指针变量和缓冲区的赋值、修改等操作及路径条件的符号表达式.我们将符号执行的功能封装为一个函数库,该函数库包含了4种类型的函数:输入声明、赋值修改跟踪、路径条件跟踪和缺陷检测.算法2描述了程序插装的算法.该算法将源程序和静态分析所提供的待检测语句集合V作为输入,输出插装后的程序.第1行逐一遍历程序中的函数,第2行遍历函数中各条语句li:若li为输入语句,则在li前插装输入声明库函数,用于声明输入变量的符号表达式(3~4行);若li为赋值修改语句,则在li前插装赋值修改跟踪库函数,用于符号化表示该操作,以对程序中的所有变量建立一个由输入变量和常量所构成的符号表示式(5~6行);若li为条件判断语句,则在条件判断语句及其所对应的分支语句处插装路径条件跟踪库函数,用于收集路径条件的符号表达式(7~13行);若li为静态分析所报告的待检测缺陷语句,则在li前插装缺陷检测库函数,用于符号化检查在当前执行路径条件下,该缺陷被触发的可能性(14~15行).算法2.程序插装算法.输入:set:F//源程序输出:setF//插装后程序1.foreachfunctionfiinF{2.foreachstatementliinfi{3.ifliisainputstatementPage64.instrumentlibfunctionAddInput()before5.elseifliisaassignorupdatestatement6.instrumentlibfunctionOperation()before7.elseifliisaconditionalstatement{8.instrumentlibfunctionConditional()before9.bt··=truebranchofli10.instrumentlibfunctionTrueBranch()after11.bf··=falsebranchofli12.instrumentlibfunctionFalseBranch()after13.}14.elseifli∈V15.instrumentlibfunctionChecking()before16.}17.}4.5动态测试动态测试包括测试生成和测试执行两个部分.测试输入的生成过程中,在按照深度优先规则转置各分支的路径条件前,首先检查对应分支是否可达至少一条待检测缺陷语句,若可达则对转置后的路径条件进行约束求解,生成覆盖新路径的测试输入,否则跳过该分支,继续遍历.测试执行过程则运行所生成的测试输入,并在运行时收集路径条件的符号化表达式.在测试执行过程中,检查当前分支对各待检测缺陷语句的可达性,若均不可达,则终止测试执行.此外,在测试执行过程中还需要检查各待检测缺陷是否会被触发.算法3描述了目标制导的混合执行测试技术的测试输入生成算法.第2行为待测试程序准备初始输入值,基本类型输入变量的初始值默认为0,字符串输入变量的初始值默认为空字符串.若输入变量的范围可知,基本类型输入变量可初始化为最大值和最小值,字符串输入变量可初始化为所允许的最大长度和最小长度.算法3.目标制导的混合执行测试输入生成算法.输入:set:V//待检测缺陷语句集合1.list:B/存放分支语句/,2.listI=InitInput()//初始化输入3.Run_Program(I,B,C)//以I为输入运行程序4.Target_Guided_Search(1,B,C)5.6.Procedure:Target_Guided_Search(intdepth,7.boolpairedReachable··=false8.for(inti··=sizeOf(B);i>=depth;i--){9.branchpairedBranch··=Pair(B[i])10.ifreachability[pairedBranch]∩V≠null{11.pairedReachable··=true12.}13.if(pairedReachable=true){14.listI··=solve(C[1]∩…∩C[i-1]∩15.list:B/存放分支语句/,16.Run_Program(I,B,C)17.Target_Guided_Search(++depth,B,C)18.}19.}20.}第3行使用初始输入值驱动程序运行,并在链表B,C中分别顺序记录所覆盖的分支语句及所对应路径条件的符号表达式.在程序的执行过程中,若执行到静态分析所报告的待检测缺陷语句,则检测该语句的缺陷是否会发生.若会发生,确认该缺陷并从V中删除;若不会发生,结合路径条件对该语句的缺陷触发条件进行约束求解,若可解,生成并执行满足上述条件的测试输入以确认该缺陷.当检测到缺陷将会发生时,修改程序状态,避免错误实际发生(如:检测到缓冲区溢出缺陷会发生时,为该缓冲区分配新的地址空间,以避免实际发生缓冲区溢出),并继续运行程序以发现隐藏在程序路径中更深位置的缺陷.程序的可达性信息还被用于降低执行测试输入的开销,当执行到的分支语句对所有待检测缺陷语句均不可达时,提前终止程序运行.Target_Guided_Search过程(6~20行)描述了目标制导的搜索算法.第8行对所收集到的分支链表B进行深度优先遍历,对分支B[i],第10行根据程序的可达性信息判断该分支的对应分支Pair(B[i])是否可达至少一条待检测缺陷语句.若可达,第14行求解路径条件C[1]∩…∩C[i-1]∩(C[i]),Page7生成的测试输入将沿路径(entry,B[1],B[2],…,Pair(B[i]),…,exit)运行.第16行使用生成的输入值驱动程序运行,并在链表B,C中分别顺序记录所覆盖的分支语句及所对应路径条件的符号表达式.当所有待检测缺陷都已得到确认,或所有可达待检测缺陷语句的路径都已被覆盖后,终止测试.5实现和评估5.1原型工具实现为了使本文所提出的方法不失一般性,也具有针对性,基于上述目标制导的混合执行测试技术,我们面向一类典型的程序缺陷:缓冲区溢出,实现了一项原型测试工具:TARGET(TARget-GuidEdTesting)①,以检测C语言程序中的缓冲区溢出缺陷.TARGET的主页上提供了详细的使用说明及下载.为了检测缓冲区溢出缺陷,除了对缓冲区的内容进行符号化建模外,我们还对缓冲区的大小(size)和已使用长度(length)提供了符号化表示.在混合执行测试技术的基础上,我们为指针变量和缓冲区也建立了映射关系.在TARGET的符号映射关系δ中,将一个指针变量从其具体地址addr映射到一个三元组(size,len,C)表示的缓冲区,其中size是一个符号表达式,表示该缓冲区变量分配空间的大小,len是一个符号表达式,表示该缓冲区变量已使用的长度,即该缓冲区变量中终结符‘\0’所在位置,C=c1,c2,…,cv为一个序列,是该缓冲区所存放内容的符号表达式.我们借鉴了SPLAT[10]的思想,仅为缓冲区变量前v个位置进行符号化建模以提高系统的可扩展性.我们将一个指针变量p表示为一个二元组(addr,off),其中addr是一个无符号长整形数,是该指针变量的地址,off则是p所指向缓冲区中的位置距离该缓冲区起始位置偏移量的符号表达式,δ(addr)返回p所指向的缓冲区b(size,len,C).图3描述了TARGET中缓冲区的符号化表示方式.为了在测试过程中通过符号化的方式来检测缓冲区溢出缺陷,需要对该类缺陷定义相应的缺陷模型.表1描述了缓冲区溢出缺陷的缺陷模型.strcpy(pd,ps)lens-offs>=sized-offdstrcat(pd,ps)lens-offs+lend>=sizedpd··=var注:表格中pd=(addrd,offd),bd=(sized,lend,Cd)=δ(addrd)≠null,ps=(addrs,offs),bs=(sizes,lens,Cs)=δ(addrs)≠null.TARGET的动态测试部分是基于混合执行测试工具CREST②实现的,采用的约束求解器为Yices③.TARGET的开发环境是Window7Ulti-mate、VisualStudio2008及MicrosoftPhoenixSDK2008④.其中TARGET的插装器是作为Phoenix的一个插件来实现的.待测程序仅需在Phoenix平台下使用该插件进行编译即可生成包含符号执行所需库函数的可执行程序,该程序可在执行具体输入的同时进行符号执行.表2描述了部分函数的符号化执行语义.pd··=input(size)创建size大小的缓冲区b,其中len··=size,pd··=malloc(size)创建size大小的缓冲区b,其中offd··=0,pd··=ps±vδ(addd)··=δ(adds),offd··=offs±vpd··=‘\0’b··=δ(addrd),len··=offd注:表格中pd=(addrd,offd),ps=(addrs,offs),b=(size,len,C).5.2实验设计为评估目标制导的混合执行测试技术的有效性,我们在同样的开发平台上实现了SPLAT技术[10],并使用上述两个工具分别对一组基准程序进行了测试,从缺陷检测能力、测试输入生成开销和动态检测开销3个方面进行了度量.测试的基准程序包括WuFTP-1、Sendmail-2和gzip-1.2.4,其中WuFTP-1和Sendmail-2取自文献[16]中的一组含有代表性缓冲区溢出缺陷的基准程序,gzip-1.2.4⑤是一个开源的文件压缩程序.由于原有的SPLAT技术发现一个缺陷后就会报告错误并停止测试,为便于比较,我们采取的方式是立即修正所发现的缺陷并继续进行测试,直到不再发现新的缺陷为止.实验运行的硬件环境为IntelDuoCore2.26GHz处理器和2GB内存的计算机.①②③④⑤Page8在本实验中,TARGET工具所需的待检测缺陷信息由静态分析工具Marple[15]提供.Marple将可能存在缺陷的语句分为安全的(safe)、有缺陷的(vulnerable)、不确定的(don’tknow)几类.安全的语句在任何输入条件下均不会被触发缺陷;有缺陷的语句在一定条件下可能会被触发缺陷;不确定类型的语句则是Marple不能判断缺陷是否能被触发的语句.库函数调用、非线性操作及复杂的指针运算都可能导致缺陷是否会被触发不能确定.在本实验中,我们将Marple报告为有缺陷的语句作为待检测缺陷语句指导动态测试.Marple对3个基准程序的静态分析结果如表3所示.基准程序报告缺陷数[15]漏报缺陷数误报缺陷数WuFTP-14Sendmail-24gzip-1.2.49注:Marple分析过程中所考虑的是可能的最坏情况,但由于操作系统等环境因素的限制,如系统所支持的最长文件长度有限,部分缺陷在实际的系统中不能被触发,本文将这类缺陷也暂归为误报.原文中gzip-1.2.4程序所报告的缺陷数为10.在论文发表后,原文作者对Marple进行了改进,减少了一处误报.5.3实验结果分析5.3.1缺陷检测能力表4中比较了两个工具检测缺陷的能力,其中表4测试时间和缺陷检测能力比较基准程序规模/kWuFTP-10.2Sendmail-20.3gzip-1.2.44.55.3.2测试输入生成开销表5中比较了两种工具在生成测试输入上的开销.尝试生成次数列给出了两个工具尝试生成测试输入的次数,即调用约束求解器求解路径条件的次表5测试输入生成的开销基准程序WuFTP-1Sendmail-2gzip-1.2.4从表5中可以看出,TARGET降低了生成测试用例的次数和所耗费的时间,TARGET尝试生成测试输入的总次数约为SPLAT技术的1/3,成功生25651528778711第1、2列给出了基准程序的名称及该程序的代码行数(不含注释和空行),第3、4列分别给出了两个工具检测到的缺陷数、漏报的缺陷数及消耗的时间.其中TARGET所消耗的时间由使用Marple进行静态分析的时间和测试的时间两部分所组成.从表4中可以看出,TARGET在WuFTP-1和Sendmail-2中均检测到了更多的缺陷.其中,TAR-GET在基准程序WuFTP-1中所漏报的缺陷是由于静态分析工具未将该缺陷作为有缺陷的语句报告,因而未在测试时进行检测.总体上看,TARGET所检测到的缺陷数比SPLAT技术多5个,其原因主要有如下两个方面:一方面,当发现会发生缓冲区溢出时,TARGET为缓冲区分配新的空间,继续安全地运行程序,从而能覆盖更深的程序路径,识别出更多的缺陷,而SPLAT技术则立即报告错误并停止测试,为继续测试而修正所发现的缺陷可能会隐藏其它的潜在缺陷;另一方面,除了将默认输入作为测试的初始输入外,TARGET还支持将变量的边界值作为测试的初始输入,从而能更覆盖更多的程序路径.从表中还可以看出,TARGET所花费的总时间大为降低,所消耗的总时间约为SPLAT技术消耗总时间的1/6.其原因是通过使用静态分析的结果和可达性信息,程序中的部分路径不再需要进行测试,从而节省了测试时间.600485数;成功生成次数列给出了两个工具成功生成测试输入的次数,即约束求解器成功解出路径条件的次数,也即是运行待测试程序的次数;时间列给出了测试过程中在生成测试输入上所消耗的时间.成测试输入的次数不到SPLAT技术的1/6,所消耗的时间约为SPLAT技术的1/40.其原因是通过使用静态分析的结果和程序的结构信息,程序中的部Page9分路径不再需要动态检查,也就不需要生成相应的测试输入,从而极大地节省了生成测试输入的时间.值得注意的是在Sendmail-2基准程序中,TARGET尝试生成测试输入的次数更多.这是由于错误的关联性所引起的,对一个错误的修正可能会导致程序路径的减少、其它错误被隐藏等情况发生.该实例中正是出现了这样的情况,对其中一个错误的修改导致路径大量缩减,而TARGET是在原来未经修改的程序上进行测试的,所需要覆盖的路径数更多,所以尝试生成覆盖这些路径的测试输入表6动态缺陷检测开销89932951913653基准程序WuFTP-1Sendmail-2gzip-1.2.4从表6中可以看出,TARGET测试过程中需要进行检测的可疑语句数约为SPLAT技术的1/3,动态检查的次数不到SPLAT技术的1/20,所消耗的时间不到SPLAT技术的1/40.其原因是由于SPLAT技术未使用静态分析的信息,因此需要检查程序中所有涉及缓冲区修改的语句,而TARGET仅需检查静态分析工具所报告的待检测缺陷所在语句,因而SPLAT技术动态检测缺陷的次数和时间开销均远高于TARGET.5.4讨论从上面3个表格中可以看出,与原有的混合执行测试技术相比较,TARGET有效降低了测试生成、缺陷检测及总测试时间的开销,并能发现程序中的更多缺陷.目前TARGET仅支持检测C语言中的缓冲区溢出缺陷,但本方法能通过增加缺陷模型和扩充插装函数库的方式,方便地扩展到支持检测多种程序缺陷,如整形数溢出、内存溢出等.另外,静态分析结果的精确度将会对本方法产生影响:误报会增加动态测试的开销,而漏报则会导致动态测试时不对漏报的可疑语句进行检测,从而不能检测到缺陷.因此,高精度的静态分析结果能进一步提高本方法的效果.6相关工作讨论软件缺陷的检测技术一般可分为静态和动态两类,部分动态缺陷检测技术,如ProPolice①和的次数更多.从表5中我们还可以看出,测试输入生成开销的主要因素是成功生成测试输入的次数,而不是尝试生成测试输入的次数.5.3.3缺陷检测开销表6中比较了动态检测待确认缺陷的开销.可疑语句数列给出了动态测试过程中需要进行检测的语句数;动态检查次数列给出了在测试过程中检查可疑语句中缺陷是否可能会被触发的次数;时间列则给出了测试过程中在检查可疑语句中缺陷是否会被触发所消耗的时间.CRED[17]采用的方法不是生成触发软件缺陷的测试用例,而是致力于如何有效地插装源程序以通过运行时监控的方式检测错误的发生.在本节中,我们主要讨论缓冲区溢出的测试生成技术和静动态结合的软件缺陷检测技术.首先讨论缓冲区溢出的测试生成技术.Grosso等[18]使用遗传算法为函数调用生成输入来发现缓冲区溢出.Shahriar等[19]针对缓冲区溢出这类缺陷提出了一组变异操作符,其主要用途是评估测试集的充分度.基于DART[6],Xu等[10]提出了一种缓冲区溢出测试技术:SPLAT,其主要贡献是提出仅为缓冲区的一段前缀而不是整个缓冲区进行符号化建模,从而提高该方法的可扩展性.该方法与其它的混合执行测试技术一样,无差别地对待程序中的所有路径,并尽可能多地遍历程序路径.与之相比,我们的方法利用静态分析的结果来减少测试过程中需要遍历的路径,并减少需要在运行时检查的可疑语句,从而降低了测试的开销,提高了可扩展性.同时,我们的方法也借鉴了SPLAT仅为缓冲区的一段前缀进行符号化建模的思想,进一步提高了可扩展性.另一个相关的领域是静动态结合的测试技术.Aggarwal等[20]使用BOON[13]的静态分析结果,减少了需要测试的缓冲区溢出的数量,从而减少了生成的测试用例.与我们的方法最为相似的是Christoph等提出的Check‘n’Crash[21]和DSD-Crasher[22].①Gccextensionforprotectingapplicationsfromstacksmash-ingattacks,http://www.trl.ibm.com/projects/security/Page10Check‘n’Crash使用ESC/JAVA[23]分析JAVA程序中函数的前置条件,并在所计算出的前置条件的基础上生成测试用例.由于该技术中所使用的静态分析是过程内的,因此所检测到的程序缺陷很有可能为误报.为解决这一问题,DSD-Crasher提出首先执行测试用例并通过Daikon[24]收集程序中的不变式,获取过程间的约束条件,从而在一定程度上降低误报率.然而,Daikon所收集到的不变式所描述的是系统在正常使用的情况下可能满足的不变式,而安全缺陷往往是系统在异常的使用方式下才会被触发的,另外,Daikon所生成的不变式是不精确的,所以该方法仍然会有一定的误报率.同时,该方法还需要一组较为充分的测试用例集,这在大多数情况下是难以获取的.与之相比,我们的方法使用静态分析结果和程序结构信息指导自动地生成测试输入,触发并确认真正的缺陷,从而避免产生误报.7结论针对现有的混合执行测试技术在遍历程序路径和输入空间时缺乏指导,导致生成和执行不能覆盖潜在缺陷语句的测试输入耗费了大量测试开销的问题,本文提出了一种基于静态分析结果的目标制导的混合执行测试方法:使用静态分析工具分析待测程序中可能含有缺陷的可疑语句及其缺陷类型,并作为目标指导测试.混合执行测试方法由3个步骤组成:可达性分析、程序插装和动态测试.基于该方法我们实现了一项针对C语言缓冲区溢出缺陷的原型测试工具:TARGET,并在一组C语言基准程序上进行了实例研究.实验结果表明与原有的混合执行测试方法相比较,使用静态分析信息能有效地降低测试开销.在本文研究的基础上,我们计划将该方法用于测试更多类型的程序缺陷,同时,我们还计划使用更多的静态分析信息来进一步降低测试开销.致谢本文的部分工作是第一作者在ComputerScienceDepartment,UniversityofVirginia,USA进行学术访问期间完成的.MaryLouSoffa教授和WeiLe博士为本项工作的完成提供了宝贵的意见,特别是对静态分析工具Marple的使用提供了大量的帮助,在此表示衷心的感谢!
