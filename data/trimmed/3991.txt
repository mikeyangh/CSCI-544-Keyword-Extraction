Page1消息传递并行程序路径覆盖测试数据生成问题的模型及其进化求解方法田甜巩敦卫(中国矿业大学信息与电气工程学院江苏徐州221116)摘要测试数据生成是软件测试的关键,近年来得到国内外学者的广泛关注.但是,已有的研究成果主要面向串行程序.任务划分、进程调度和网络延迟,使得并行程序的执行具有不确定性,给并行程序的测试数据生成带来很大挑战.文中研究消息传递并行程序面向路径覆盖的测试数据生成问题,提出并行程序的路径表示,定义等价路径并给出寻找方法.基于此,建立并行程序路径覆盖测试数据生成问题的数学模型,并采用遗传算法求解该模型.作者将所提方法应用于6个基准测试程序,并与随机法比较.实验结果表明,文中所提方法可以高效生成覆盖目标路径的测试数据.关键词软件测试;并行程序;路径覆盖;测试数据;遗传算法1引言在软件开发过程中,测试投入的周期较长,开销较大.已有统计结果表明,软件测试占据整个开发成本的50%以上,包含多个耗时、枯燥,并且容易出错的环节,例如,说明测试需求、筹备测试数据、运行被测软件以及评测结果等.如果这些环节能够自动化实现,必定会缩短软件的开发周期,提高其市场竞争力.自动化软件测试的核心,是生成有效的测试数据.目前,已有很多研究成果用于解决测试数据生成问题,以满足分支覆盖、条件覆盖以及路径覆盖等测试充分性准则.单锦辉等认为,许多软件测试问题都可以归结为以路径覆盖为准则的测试数据生成问题[1].因此,路径覆盖是最常用的测试数据生成准则.但是,已有的研究成果仅适用于串行程序.随着并行计算技术的发展,越来越多的科学问题,如生物信息、互联网络服务以及天气预报等,可以通过并行程序得到有效解决.设计并行程序主要通过并行编程语言和使用消息传递库扩展传统的编程语言等两种途径实现.网络技术的高速发展和单处理机处理速度的不断提高,使得消息传递环境扩展传统的编程语言成为最常用的并行程序开发方式.近年来,出现很多消息传递环境,如MPI消息传递接口(MessagePassingInterface)、PVM并行虚拟机(ParallelVirtualMachine)、CM信息传递库以及Express等.其中,MPI[2]和PVM[3]是公用软件,且几乎能在所有的并行平台上运行.因此,二者是最重要和最流行的消息传递库.与串行程序相比,并行程序更加复杂,可靠性要求更高,这意味着并行程序的测试尤为关键.但是,目前针对并行软件测试的研究工作还比较少,特别是基于消息传递的并行软件.本文研究消息传递并行程序的路径覆盖测试数据生成问题.首先,给出并行程序路径的表示,基于并行程序的特征,定义等价路径,并给出等价路径的寻找方法;然后,建立并行程序路径覆盖测试数据生成问题的数学模型,并采用遗传算法求解该模型,从而得到期望的测试数据.本文的贡献主要体现在如下3个方面:(1)定义并行程序的等价路径,并给出寻找方法;(2)建立路径覆盖测试数据生成问题的数学模型,并采用遗传算法求解该模型;(3)将所提理论与方法应用到基准程序测试中,与随机法的比较结果表明,所提方法可以高效生成并行程序的测试数据.本文第2节综述相关工作;第3节是本文的重点,阐述提出的方法,包括并行程序路径的表示、等价路径及其寻找方法、并行程序路径覆盖测试数据生成问题的数学模型及其进化求解方法等;第4节是所提方法在基准程序测试中的应用以及与其它方法的对比实验结果和分析;最后,第5节总结全文,并提供可能的进一步研究问题.2相关工作2.1并行程序测试Lei等人[4]提出一种可达性测试方法,在不保存已执行序列的前提下,使每个偏序同步序列只执行一次.Carver等人[5]提出分布式可达性测试方法,使多个测试序列同时执行,大大减少了执行时间.Godefroid[6]提出基于模型检测的测试方法,控制线程调度并搜索所有可能的程序行为.但是,随着程序规模的增大,并行软件的交互数目指数增长,引发空间爆炸问题.偏序缩减可以解决空间爆炸问题,思想是并发线程无交互的不同执行序列产生同样的状态.因此,如果一个执行顺序发现一个缺陷,如死锁、数据争用等,其它等价的执行序列也将检测到该缺陷.然而,静态方法无法处理程序的指针,因此静态偏序缩减在实际应用中受到限制.Flanagan等人[7]提出动态偏序缩减方法,尽管偏序缩减使得模型检测减少了搜索空间,但是仍然不能实现搜索空间的完全搜索[8].Krammer等人[9]在运行过程中检查MPI的应用程序接口(ApplicationProgramInterface,API)是否得到正确使用.Vetter等人[10]开发MPI程序的动态监视工具Umpire,用于在运行过程中发现死锁、不匹配的集合操作以及资源耗尽等程序缺陷.Vakkalanka等人[11]开发MPI程序检验工具ISP,其所有进程在一个交互调度器的控制下执行,能够发现程序的局部断言违例,并通过POE(PartialOrderreductionavoidingElusiveinterleaving)算法,为发现程序的所有死锁提供保证.Sun等人[12]针对共享存储的并行程序,通过扩展串行程序的测试标准,提出覆盖测试准则.面向基于消息传递的并行程序,Souza等人[13]基于控制和通信流,提出发送节点、接收节点、全部节点、发送边Page3以及全部边等覆盖准则,基于数据和消息传递流,提出定义、定义-发送、计算、谓词、发送、发送-计算以及发送-谓词等覆盖准则.为了降低测试代价,Souza等人[14]提出基于覆盖准则和可达性的测试方法,根据特定的覆盖准则选择测试数据,引导新同步事件的执行,利用可达性测试,选择合适的同步事件.此外,针对用任务树表示的并行程序,Popovic等人基于运行剖面,将统计使用测试(StatisticUsageTesting,SUT)方法[15]应用到大规模任务树中[16];Popovic等人[17]还利用面向串行程序的统计测试方法,提出了用于利用任务树表示的并行程序的测试方法,并将其与穷举测试和统计使用测试比较,结果表明,该方法的深路径覆盖优于另外两种方法,但是所需要的测试花费较大.2.2测试数据自动生成从总体上讲,已有的测试数据自动生成主要包括3类,分别为随机生成、静态生成和动态生成.随机法通过对被测程序的输入空间进行随机采样,生成满足路径覆盖的测试数据[18],该方法生成单个测试数据的开销小,容易实现,但是该方法在测试数据生成过程中,有很大程度的盲目性;静态法对程序实施静态分析和转换,而不实际运行程序,如王志言等人[19]的区间算术方法和聂长海等人[20]的基于对接口参数组合覆盖的测试数据生成算法等,该方法需要执行大量的代数和(或)区间运算,占用存储空间大,并且不能处理输入空间是无穷区间的情况;通过实际执行被测程序,动态法生成测试数据的过程是确定的,如Miller等人[21]的直线式程序方法、Korel[22]的改变变量方法、王雪莲等人[23]在前向分析基础上的程序切片算法、Gupta等人[24]的迭代松弛方法以及利用启发式算法(如遗传算法、进化策略、模拟退火算法和禁忌算法等)指导测试数据的生成等.遗传算法作为一种基于生物进化与遗传变异原理的全局搜索算法,已经有效解决了很多复杂的优化问题.近年来,应用遗传算法生成满足一定覆盖准则的测试数据,成为软件工程领域的研究热点之一.Xanthakis等人[25]首次应用遗传算法生成满足路径覆盖的测试数据,开创了进化算法成功用于测试数据生成的先河;Ahmed等人[26]、Bueno等人[27]及Watkins[28]使用遗传算法获得满足路径覆盖的测试数据;针对多目标路径和大规模目标路径,我们分别提出使用遗传算法生成测试数据的有效方法[29-30];Lin等人[31]提出扩展海明距离,解决含有相同节点而顺序不同的路径比较问题;谢晓园等人[32]提出3种基于相似程度的适应值函数构造方法,用于生成覆盖指定路径的测试数据;Harman等人[33]利用切片技术,在生成测试数据的过程中,忽略与覆盖目标无关的变量,缩减问题的搜索空间;Arcuri等人[34]将搜索算法应用到面向对象的软件测试数据生成中,利用覆盖元素和测试序列长度定义了适应值函数,研究了分支覆盖中测试序列长度的作用,表明使用较长的测试序列使测试更容易[35].一方面,从2.1节可以看出,大部分针对并行程序测试的研究工作[4-8,10],对被测程序中的通信序列进行测试.文献[9-11]主要发现由并发执行带来的死锁、资源竞争和API的使用等问题.文献[16-17]从任务调度的角度,研究基于任务树的并行程序的统计测试,但所提方法不能直接应用于消息传递并行程序.Sun和Souza等人[12-14]在考虑通信序列的基础上提出多种结构覆盖准则,但是没有给出测试数据生成方法.然而,在通信正确的前提下,即不存在死锁和资源竞争等问题的情况下,如何生成测试数据以提高并行程序的可靠性,我们还没有看到相关的研究工作.另一方面,在2.2节中关于测试数据的研究工作已经取得了可喜的成果.但是,已有的测试数据生成方法主要适用于串行程序.在并行程序中,多个进程并发执行,进程之间通过通信协同完成计算任务.每个进程求解任务的大小不同、进程所在处理器的性能差异、通信延迟以及程序本身功能的需要,使得并行程序的执行过程出现不确定性.这样一来,传统的串行程序测试方法难以应用于并行程序.鉴于此,本文研究基于消息传递的并行程序路径覆盖测试数据生成问题.由于并行程序包含多个进程,每个进程并发执行,在程序运行的每个状态都有可能出现进程之间的交互,因此传统的串行路径表示方法不再适用.本文首先给出并行程序路径的表示,基于路径执行的不确定性,定义等价路径,并给出等价路径的寻找方法;然后,建立并行程序路径覆盖测试数据生成问题的数学模型,并采用遗传算法求解该模型,以生成期望的测试数据;最后,通过基准程序的测试,验证所提方法的效率.Page43提出的方法3.1并行程序的路径记并行程序为S,由m(m>1)个进程组成,第i(i=0,1,2,…,m-1)个进程为Si,这m个进程并发执行,协同完成计算任务,S可以表示为S={S0,S1,…,Sm-1}.记S的输入向量为狓={x1,x2,…,xns},其中,xi(i=1,2,…,ns)为第i个输入分量,取值范围为Dxi,那么,狓的取值范围为D=Dx1×Dx2×…×Dxns.(1)节点.考虑S的第i个进程Si,其基本执行单元称为节点.一个节点包含的语句要么都执行,要么都不执行.节点可以是一个分支语句的判断条件,也可以是一个循环语句的循环条件,还可以是一条或多条连续语句,或者一条消息发送或接收语句.记Si的第j个节点为ni语句,则称ni(2)控制流图.S的控制流图是一有向图G={V,E},其中,V为G的顶点集,Si的每个节点均对应G的一个顶点;对任意nij执行后nini所有控制边组成的集合称为控制边集,记为Ec;对j,nl任意nik为与ninl所有通信边组成的集合称为通信边集,记为Et.边集E为控制边集与通信边集的并集,即E=Ec∪Et.从控制流图的定义可以看出,并行程序的每个进程分别对应一个子图,每个子图有自己的入口和出口顶点.因此,一个并行程序包含多少个进程,其控制流图就有多少个入口和出口顶点;子图内的顶点之间有控制边相连,体现进程内节点之间的串行执行关系;若两个进程之间有通信,其子图之间还有通信边相连.与串行程序控制流图相比,并行程序控制流图主要有2点不同:首先,串行程序控制流图有唯一的入口和出口顶点,而并行程序控制流图包含多个入口和出口顶点;其次,串行程序控制流图只有控制边,而并行程序控制流图不仅有控制边,还有通信边.(3)路径.以输入狓∈D执行S,穿越Si的顶点序列为pi=ni中,|Si|为Si的顶点数,ni出口顶点,那么,p=p0p1…pm-1为狓穿越的路径.可以看出,一条并行程序的路径由多个进程的路径组合而成.由于多个进程并发执行.因此,路径p中的p0p1…pm-1并不代表进程的执行顺序,而是为了后续阐述方便,按照进程号从小到大的顺序表示各进程的执行路径.当然,也可以采用其它方法表示一个并行程序的路径.下面举例说明路径的表示方法.图1为求3个正整数的最大公约数源程序,图2为该程序的流程图.为了便于说明,进程的节点用1,2,…表示,相应的控制流图的顶点也用1,2,…表示.根据控制流图和路径的表示方法,当输入狓=(2,6,3)时,S0、S1、S2和S3可能的执行路径分别为p0=n0p1=n1p2=n2p3=n31n32n33n34n35n36n37n39n35n36n38n39n35n310n311,其中,节点n0发送节点,n0点.因此,并行程序的路径可以表示为p=n03.2等价路径对于串行程序而言,某输入穿越的路径是唯一的.但是,对于并行程序,进程之间的交互导致执行路径的不确定性.具体来讲,任务划分、进程调度以及网络延迟,使得并行程序在相同输入下,经历不同的消息传递顺序,可能导致不同的执行路径.对于S的两条路径p=p0p1…pm-1和p=p0p1…pm-1,若pi与pi(i=0,1,…,m-1)不同的节点序列仅由消息传递顺序导致,称p为p的等价路径.容易知道,p可能有多条等价路径,称由p的等价路径组成的集合为p的等价路径集,用p~表示.前面已经说明,由于执行路径的不确定性,相同的输入会导致程序不同的执行路径.在生成覆盖目标路径的测试数据过程中,如果不考虑等价路径,将会造成不必要的时间和资源浪费.例如,在最坏情况下,假设已经找到了符合要求的测试数据,但是由于消息传递顺序的不同,使得此测试数据没有穿越目标路径,而是穿越了一条等价路径,那么就会由于没有考虑等价路径的存在,丢失这个测试数据.因此,在生成覆盖目标路径的测试数据时,不仅要考虑目标路径本身,还要考虑其等价路径.Page5为了得到某路径的等价路径,首先找出该路径的不确定通信语句;然后根据这些语句在并行程序的影响范围,得到该路径在每个进程的等价子路径;6.MPI_Recv(&x,1,MPI_INT,MPI_ANY_SOURCE,MPI_ANY_TAG,MPI_COMM_WORLD,&status);7.MPI_Recv(&y,1,MPI_INT,MPI_ANY_SOURCE,MPI_ANY_TAG,MPI_COMM_WORLD,&status);//判断进程1和2返回的结果,若都大于1,那么向进程3发送计算数据,并等待接收,否则,发送0以通知(a)进程S0#include〈mpi.h〉#include〈string.h〉intmain(intargc,charargv){1.intx,y;intmyid,numprocs;MPI_Statusstatus;//并行环境初始化MPI_Init(argc,argv);MPI_Comm_rank(MPI_COMM_WORLD,&myid);MPI_Comm_size(MPI_COMM_WORLD,&numprocs);//接收进程0发送的数据2.MPI_Recv(&x,1,MPI_INT,0,1,MPI_COMM_WORLD,3.MPI_Recv(&y,1,MPI_INT,0,2,MPI_COMM_WORLD,//计算两个数的最大公约数4.while(x!=y)5.{if(x<y)6.y=y-x;7.x=x-y;8.}9.MPI_Send(&x,1,MPI_INT,0,1,MPI_COMM_WORLD);10.MPI_Finalize();}//向进程0发送结果,注销并行环境图1求3个数的最大公约数源程序最后基于等价子路径,得到该路径的等价路径.此基础上,给出方法的伪代码.如图3所示.下面给出寻找p的等价路径的具体步骤.并在intmyid,numprocs;MPI_Statusstatus;//并行环境初始化MPI_Init(&argc,argv);MPI_Comm_rank(MPI_COMM_WORLD,&myid);MPI_Comm_size(MPI_COMM_WORLD,&numprocs);//接收进程0发送的数据2.MPI_Recv(&x,1,MPI_INT,0,1,MPI_COMM_WORLD,3.MPI_Recv(&y,1,MPI_INT,0,2,MPI_COMM_WORLD,//若接收的数据为0,则不计算,否则,计算两个数的最大公约数#include〈mpi.h〉#include〈string.h〉intmain(intargc,charargv){1.intx,y,z;else4.if(x>1y>1){5.while(x!=y)6.{if(x<y)7.y=y-x;8.x=x-y;9.}10.MPI_Send(&x,1,MPI_INT,0,0,MPI_COMM_WORLD);}11.MPI_Finalize();}//向进程0发送结果,注销并行环境Page6输入:并行程序S和路径p输出:p的等价路径集p~Begin找出S中的不确定节点珔nd及其不确定节点的接收变量集合Vd;初始化的等价路径集p~=和影响范围集合T={Sd};for每一个发送节点nlIf珔nd→nlendforforVd中每一种变量值的互换方式p=p;ifp不同于p~中已有的路径endforEnd(1)找出不确定通信语句.在消息传递并行程序中,消息的发送和接收是非对称的,消息发送语句必须指定目的进程和消息编号,而消息接收语句的源进程和消息编号没有该限制.在程序执行过程中,当m(mm-1)个进程向同一个目的进程Sd发送消息,且Sd的接收语句中源进程和消息编号不确定时,Sd中与发送语句匹配的m条接收语句对应的节点组成不确定节点,记为珔nd接收数据的变量,称为不确定节点的接收变量,所有这些变量组成的集合记为Vd程序执行不确定的另一重要原因.采用非阻塞通信时,无论消息接收语句的源进程和消息编号是否明确指定,都有可能使程序执行不确定.本文采用阻塞通信,并考虑程序只有1个不确定节点的情况.因此,珔ndj,其中,j为Sd的不确定节点编号.在珔ndj可以简记为珔nd,Vd例如,在路径p中,2个进程S1和S2的节点n19是消息发送节点,都向进程S0发送消息,与n19匹配的接收节点是n0和n2和n2x和y,且都未明确指定消息的源进程和消息编号,那么,消息传递顺序是不确定的,可能是(n29,n0(n17),也可能是(n17组成不确定节点珔n0,珔n0的接收变量集合V=和n0{x,y}.(2)得到不确定通信语句的影响范围.不确定节点珔nd对S的影响范围是1个进程集合,用T表示,包含所有被珔nd影响的进程.确定T之前,首先给出珔nd与消息发送节点之间的关系.记Sd的消息发送节点为nd配的接收节点为niVd出现在赋值语句中,且被赋值的变量作为nd送变量,称珔nd影响nd量为被珔nd影响的接收变量.不确定节点与消息发送节点之间的关系具有传递性,即若珔nd→ndk,其中,ndni发送节点,那么,珔nd→ni首先,将珔nd的所在进程Sd加入T中;然后,判断Sd内是否有被珔nd影响的消息发送节点,若有,则将该节点的目的进程加入T中.即T={St|(t=d)∨(珔nd→nlk∧与nlk匹配的图1中,珔n0所在的进程是S0,在S0内,珔n0→n0Page710,珔n0→n0珔n0→n0目的进程是S0,因此,珔n0的影响范围T={S0,S3}.(3)得到每个进程的等价子路径.为了得到每个进程的等价子路径,考虑不确定节点的接收变量与影响区域的相关性.的等价路径在Si∈T中,如果珔nd的接收变量v∈Vd,或者被珔nd影响的接收变量出现在分支语句的判断条件或循环语句的循环条件中,或者出现在赋值语句中且被赋值的变量出现在分支语句的判断条件或循环语句的循环条件中,那么,珔nd的接收变量与Si∈T具有相关性.进一步,若i=d,则称Si∈T与珔nd的接收变量具有直接相关性,记为v←→rSd;否则,具有间接相关性,记为v←→irSi.图1中,珔nd的影响范围T={S0,S3},S0与x,y∈V具有直接相关性,x←→rS0,y←→rS0,与x,y相关的分支语句的判断条件n0p的p0中其值为真,将x,y的值互换后,其值仍为真,不改变p0的分支走向,此时p0与p0相同,因此,p0的等价子路径p0=p0=n0S3与珔n0的接收变量x,y∈V具有间接相关性,x←→irS3,y←→irS3,与x,y相关的循环和判断条件4、n3是n3仍为真.n3换后,其值不变.n3的值互换后第1次为假,后续执行假分支n3次为真,后续执行真分支n3p3=n31n3(4)得到等价路径.路径p中,将进程Si∈T的相关路径pi用pi替换,得到的路径即为p的等价路径.对于Vd中变量的其它m!-2种互换方式,重复(3)和(4),可以得到p的所有不同等价路径,组成等价路径集合p~.若m个进程向Sd发送消息,那么,在不确定节点珔nd中一共有m!种消息接收顺序,除了当前路径本身对应的一种顺序外,还有m!-1种消息接收顺序.相应的,在Vd中,每一种变量值的互换方式,都对应一种不同于当前路径的消息接收顺序.因此,通过判断Vd中每一种变量值的互换方式对相关分支语句和循环语句的影响,可以得到完整的等价路径集合.图1中,将p0和p3替换p中的p0和p3,得到pp=p0p1p2p3p只有1条等价路径p,因此p的等价路径集珟p={p}.值得说明的是,等价路径的求解思路,同样适用于不确定节点个数多于1的情况.此时,并行程序的运行过程将有更多的不确定性.相应的,等价路径的判定过程也将更加复杂.作为对并行程序测试数据进化生成问题的初步研究,同时,也为了描述清楚,并使该方法具有代表性,这里考虑只有1个不确定节点的典型情况.3.3路径覆盖测试数据生成问题的数学模型路径执行的不确定性,使得并行程序测试数据生成问题与串行程序有明显的区别.记S的目标路径p0=p00p01…p0m-1,并行程序路径覆盖测试数据生成问题可以描述为:寻找狓∈D,使得以狓为输入运行S时,穿越的路径为p0或等价路径p0∈p~0.为了建立该问题的数学模型,针对p0和等价路径集p~0,构造|p~0|+1个函数f0(狓),f1(狓),…,f|p~0|(狓),其中,|p~0|为p~0包含的路径数,f0(狓)对应p0,f1(狓),…,f|p~0|(狓)分别对应p~0中的1条路径.取路径pk=pk0pk1…pkm-1(pk∈p~0∪p0),记狓穿越的路径为p=p0p1…pm-1,那么,在pk和p中,子路径pi与pki的相似度为其中,|pi∩pki|表示pi与pki从前到后连续相同的节点数.那么,路径p与pk的相似度fk(狓)(k=0,1,2,…,|p~0|)可以表示为fk(狓)值越大,说明狓的穿越路径越接近于路径pk,fk(狓)取得最大值1的充要条件是:以狓作为输入运行S时,穿越的路径为pk.这样一来,路径覆盖测试数据生成问题的数学模型可以表示为Page83.4测试数据进化生成方法3.4.1适应度函数虽然上述模型,即式(3)中,包含多个目标函数,但却不是一个传统的多目标问题.传统的多目标问题是要寻找同时满足多个目标的最优解,问题的解需要综合考虑多个目标.而并行程序路径覆盖测试数据生成问题中,只要找到满足其中一个目标函数的解,就找到了穿越目标路径的测试数据,完成该问题的求解.度函数为基于此,在求解式(3)的遗传算法中,设定适应F(x)=max{f0(狓),f1(狓),…,fp~0(狓)}(4)fk(狓)(k=0,1,2,…,|p~0|)的定义如式(2)所示.3.4.2算法步骤给定目标路径p0,采用遗传算法求解式(3),可以得到期望的测试数据.步骤如下:1.获得等价路径集.采用3.2节方法,得到目标路径p0的等价路径集p~0,并插装被测程序.2.设置算法参数,生成初始种群.设置种群规模g、算法终止代数以及遗传操作中的交叉和变异概率等算法参数,生成初始种群M={x1,x2,…,xg}.3.判断是否需要终止种群进化.以种群中的每个个体xi(i=1,2,…,g)作为输入执行被测程序,得到穿越路径.判断是否存在xi,其穿越路径与目标路径或任意1条等价路径完全匹配,若是,输出测试数据和被穿越的路径,终止种群进化;否则,判断是否到达最大终止代数,若是,终止种群进化.4.计算适应度函数.对每个个体xi(i=1,2,…,g),根据适应度函数,即式(4)及目标路径、等价路径和狓i的穿越路径,计算f0(xi),f1(xi),…,f|p~0|(xi),选择其中的最大值作为个体适应度,程序Gcd1求最大公约数Gcd2求最大公约数表1被测程序的基本信息Max-triangle寻找最大值,并判断前3个数是否构成等边三角形Index字符信息检索Matrix两矩阵相乘,并判定其中一个矩阵元素奇数和偶数及其Equations求解线性方程组,并判断最大最小系数基于前期对遗传算法的研究和多次实验,设定遗传算法的交叉和变异概率分别为0.9和0.3.后续部分的最大迭代次数和种群规模,也是多次实验得到的经验值.即便如此,仍不能保证本文对遗传算指导进化过程.5.生成子代种群.个体采用二进制编码,遗传操作分别为轮盘赌选择、单点交叉和单点变异.根据个体适应度,指导遗传操作的进行,生成子代种群,转步3.4实验为了验证本文方法的有效性,将提出的方法应用于基准并行程序的测试.到目前为止,还没有看到其它的并行程序路径覆盖测试数据生成方法.但是,由于随机法的普适性,本部分还实现了测试数据的随机生成,并与本文方法比较.为了公正比较这2种方法,在生成测试数据之前,首先采用3.2节的方法得到目标路径的等价路径;然后分别应用本文方法和随机法生成测试数据.集群环境的配置如下:计算资源的硬件配置均为2×IntelXeonE5606CPU,6×2GB内存,2×146GBRAID1硬盘以及千兆以太网络;软件采用Linux操作系统、Chess集群管理软件以及MPI+C并行编程语言.为了充分验证本文方法的有效性,从6个程序中分别选取1条目标路径,生成覆盖它的测试数据.被测程序的基本信息如表1所列.求解最大公约数、矩阵相乘以及求解线性方程组,是典型的并行应用程序,Gcd1为求解最大公约数程序,增大Gcd1的难度得到Gcd2.增加矩阵相乘和求解线性方程组程序的难度,得到Matrix和Equations.此外,Max-triangle是作者在基准三角形分类程序的基础上改造的并行程序;字符信息检索是工业测试程序Make的一个功能,Index程序是其并行实现.输入变量个数进程数发送语句数接收语句数取值域3411471818[1,64]444910369461232424[0,63]12法的参数设置是最优的.但是,遗传算法参数优化问题,已经超出了本文的研究范围.评价不同方法的性能指标为迭代次数和运行时间,这2个指标越小,说明某方法的性能越好.Page9Gcd1的源程序及其控制流图分别如图1和图24.1Gcd1实验所示.选取的目标路径为1n0p0=n03n12n1n11n1n21n22n23n2n33n32n31n3等价路径集为p~0={n03n12n1n11n12n2n21n23n2n31n32n33n3等价路径的判定方式与3.2节所描述的例子相似,因此这里不再给出详细的判定步骤.设定最大进化代数为5000,种群规模为10.采用随机法和本文方法生成覆盖目标路径(或等价路径)的测试数据,10次实验结果如表2所列.表中,“—”表示到最大迭代次数时,某方法仍然没有找到期望的测试数据.由表2可以看出:(1)10次实验中,随机法有6次一直迭代到最大次数仍没有找到覆盖目标路径(或等价路径)的测试数据,而本文方法每次都能找到期望的测试数据;(2)第2、8、9、10次实验中,随机法找到了期望的测试数据,但是本文方法需要的迭代次数和运行时间都远少于随机法,迭代次数分别减少了64.3%、53.9%、83.8%和81.3%,运行时间分别减少了51.0%、36.6%、77.8%和74.3%.Gcd2、Matrix和Equations程序的种群规模为30,Max-triangle种群规模为10,Index种群规模为20,最大迭代次数均为10000.实验结果及统计测试值如表3所列.表3其它程序的实验结果和统计测试值程序等价Gcd224456.335474580.09162.5083158555.9214.587.914.09Max-triangle13798.4612115893.08726.4369866800.860.621.510.21Index14568.438630143.08721.6356113132.131.881.960.28Matrix32981.966394905.07531.26135751631.661.562.861.39Equations14340.2610495009.56704.86129156053.667.424.404.03表4不同方法所得性能指标值的非参数检验结果Max-triangleIndexMatrixEquations由表3和表4可以看出:(1)本文方法的迭代次数远少于随机法.在5个实验中,相比随机法,本文方实验次数迭代次数12792—804.30—210402918319.29652.2833593—1105.29—42420—744.29—51367—420.72—61076—330.87—74062—1248.87—85431180167.23263.8997614719233.481055.20109234947284.191109.484.2其它实验为了减少随机因素对不同方法性能的影响,每种方法独立运行30次,每次运行时,记录每种方法上述性能指标的实验结果,然后求平均值.为了确定2种方法在各性能指标上的差异是否显著,采用Mann-WhitneyU非参数检验方法,显著性水平取0.05.表3列出2种方法的迭代次数和运行时间的均值与方差.表4是本文方法和随机法所得各性能指标值的非参数检验结果,其中,“0”表示2种方法之间没有显著差异;“1”表示本文方法明显优于随机法.随机法法分别减少了迭代次数51.36%、56.47%、47.6%、60.4%和35.2%.通过检验结果也可以看出,2种方法的迭代次数有显著差异;(2)除了Index程序外,本文方法分别减少了执行时间25.1%、42.86%、41.9%和16.81%.在Index程序中,随机法的时间略少于本文方法.由检验结果可以看出,在Index和Equations程序中,2种方法的执行时间没有明显差别,而其它3个程序中,本文方法的运行时间显著少于随机法.Page10另外,通过以上实验结果还可以看出,本文方法在迭代次数方面的优势比运行时间更明显,这是因为随机法不需要通过遗传操作生成新的测试数据.综上所述,在并行程序路径覆盖测试数据生成问题中,通过寻找等价路径,避免了程序执行的不确定性给测试数据生成带来的影响;并通过实验数据及其分析可以看出,使用遗传算法可以高效地生成覆盖目标路径的测试数据.5结束语随着高性能计算机的发展,并行程序在社会各领域的应用日益广泛,并行程序的测试得到国内外研究者的高度重视.本文研究消息传递并行程序的路径覆盖测试数据生成问题,提出并行程序的路径表示,定义等价路径并给出寻找方法,建立并行程序路径覆盖测试数据生成问题的数学模型,并采用遗传算法求解该模型.实验结果表明,与随机法相比,本文方法能高效生成覆盖目标路径的测试数据.需要说明的是,本文仅考虑阻塞通信,且程序只有1个不确定节点的情况.尽管有些并行程序不止1个不确定节点.但是,在实际的并行程序中,含有1个不确定节点的情况,还是非常普遍的.从这个意义上讲,本文研究的问题具有一定的代表性.并且,本文方法可以推广到不确定节点多于1的情况.含有多个不确定节点的并行程序,具有更多的不确定性,其运行过程将更加复杂.对于这类并行程序,如何高效地判定等价路径,是需要进一步研究的问题.此外,基于等价路径,研究并行程序的错误检测和多路径覆盖,也是非常有意义的课题.
