Page1免预设间隔约束的对比序列模式高效挖掘1)(四川大学计算机学院成都610065)2)(四川大学华西公共卫生学院成都610041)3)(武汉大学软件工程国家重点实验室武汉430072)摘要对比序列模式在识别不同类别序列样本集合的特征上有着重要的作用.已有对比序列模式挖掘算法需要用户预设间隔约束.在不具备充分先验知识情况下,用户不易准确地预设恰当的间隔约束,进而导致不能发现有用的模式.对此,文中设计了带紧凑间隔约束的最小对比序列模式挖掘算法,实现免预设间隔约束,并对候选模式自动计算最适合的间隔约束.此外,设计了3种剪枝策略来提高算法的执行效率.通过蛋白质序列、DNA序列、行为序列数据集验证了提出的算法的有效性和高效率.关键词对比序列模式;间隔约束;序列数据挖掘1引言序列模式挖掘作为数据挖掘的一项重要任务,有着广泛的应用.例如:广电服务商分析用户的收视纪录,发现用户的收视喜好,可为节目编排提供决策支持.再如:分析传染病传播的时空监测数据,可望发现传染病时空聚集性暴发规律,进而为防控工作提供参考.与此同时,序列模式挖掘也受到了众多研究者的关注,不同类型的序列模式被陆续提出,如频繁序列模式[1-2]、闭合序列模式[3]、对比序列模式[4]、周期模式[5]和偏序模式[6]等.给定正类序列样本集合和负类序列样本集合,对比序列模式描述在正类序列样本集合中频繁(模式的支持度大于指定阈值α)、且在负类序列样本集合中不频繁(模式的支持度小于指定阈值β)的项集.对比序列模式能识别不同类别序列样本集合间的差异,并描述各类别样本集合的特征,因此适用于多个领域的序列数据分析.例如:在医学领域,分析阳性肿瘤和阴性肿瘤的DNA序列,识别对比序列模式,能够提高临床诊断的精度;在商业领域,对比不同年龄段顾客的购物行为,发现各年龄段顾客的购物模式,可以提高商品促销活动的针对性.模式的支持度反映了序列集合中有多大比例的样本能够与之匹配.简而言之,匹配即模式在序列中出现.例如:模式P=aed与序列S=aedcbfdc匹配.为了提高模式的适用性,允许模式元素间出现通配符①,即允许模式元素不相邻地出现在序列中.例如:P=a$$c$f与序列S=aedcbfdc匹配.元素之间的连续的通配符个数称为间隔;为提高序列模式匹配的适用性并且方便表达,采用区间来表达序列模式元素两两间通配符个数的最小值和最大值,我们称这个区间为间隔约束.例如:给定模式P=ac,设间隔约束为[1,2],若P与序列S匹配,意味着在S中元素a和元素c间最少出现1个元素,最多出现2个元素.在已有对比序列模式挖掘的研究[4,7-8]中,间隔约束作为挖掘参数与支持度阈值一同需要用户设定.实践表明,在没有足够先验知识时,用户很难设定恰当的间隔约束,失当的间隔约束,会使发现的模式偏离预期的结果,如例1所示.例1.给定表1描述的正类序列样本集合pos和负类序列样本集合neg,挖掘与所有正类序列样本匹配、但不与任何负类序列样本匹配的模式.结果表明:当间隔约束为[1,1]时,模式ad和cf满足条件;当间隔约束为[2,2]时,模式df满足条件;当间隔约束为[2,3]时,模式acc满足条件;当间隔约束为[0,3]时,模式ab满足条件.例1表明,设置不恰当的间隔约束可能导致无法发现有用的对比序列模式.逐个预设所有可能的间隔约束显然效率低下,而且不可行.能否自动计算最合适的间隔约束,使用户能更简便、高效地获得对比序列模式挖掘结果呢?据我们所知,目前还没有对比序列模式挖掘研究工作考虑了在挖掘过程中自动计算合适的间隔约束.本文为响应这一需求,作了下列主要工作:(1)分析了间隔约束设置对对比序列模式挖掘的影响;(2)提出了免预设间隔约束的对比序列模式挖掘问题,避免了用户预设参数,有助于推动数据挖掘的实践;(3)设计了带紧凑间隔约束的最小对比序列模式挖掘算法,并通过翔实的实验验证了算法的有效性和执行效率.本文第2节介绍相关工作;第3节定义本文的研究问题;第4节讲述本文设计的带紧凑间隔约束的最小对比序列模式挖掘算法,该算法不需要预设间隔约束;第5节在真实世界的DNA序列数据集、蛋白质序列数据集和用户行为序列数据集上验证本文提出算法的有效性和执行效率;第6节总结本文工作,并对下一步工作进行展望.2相关工作分析序列数据并提取有用的模式,例如:频繁序列模式[1-2]、闭合序列模式[3]、对比序列模式[4]、周期模式[5]及偏序模式[6]等,能够提高人们对数据蕴含知识的发现能力,因而受到研究者的持续关注.由于篇幅有限,更多序列数据挖掘的研究及其应用请参阅文献[9-11].在序列模式中考虑间隔约束,能够允许序列模①通配符可与任意符号匹配,本文用‘$’指代.Page3式与序列样本进行匹配时,序列模式元素间间隔一定数量的任意元素.这样,可以提高序列模式的适用性,因而间隔约束被普遍地应用于序列模式挖掘中.文献[12]在PrefixSpan算法[13]基础上设计了带间隔约束的序列模式挖掘算法.文献[14]研究了从给定DNA序列中挖掘满足支持度阈值和间隔约束的频繁序列模式的算法.文献[15]设计了Gap-BIDE算法挖掘带间隔约束的闭合序列模式.文献[5]针对单条序列样本,研究了满足给定间隔约束的频繁周期模式.文献[16]设计了利用带间隔约束的序列模式发现软件缺陷特征的方法.请注意,在这些研究工作中,间隔约束均作为算法运行参数之一,由用户预先指定.对比序列模式挖掘[4,7-8]旨在从两类序列样本中,发现在一类样本中频繁出现,但在另一类中不频繁出现的序列模式.文献[4]定义了对比序列模式问题并设计了挖掘算法ConSGapMiner.文献[7]应用对比序列模式于蛋白质序列实现多肽折叠分类的预测.文献[8]在考虑支持度计算过程中引入了模式出现密度的概念.值得一提的是,文献[4,7-8]中对比序列模式间隔约束的范围需要用户预先指定,而本文设计了根据对比序列模式自动计算间隔约束的方法.在生物序列分析中常用motif[17]来描述在序列样本特定位置频繁出现的模式.但是,motif挖掘与本文工作有以下本质区别.首先,motif挖掘只考虑单一类别的序列样本集合,而对比序列模式挖掘分析对象为两类序列样本集合;其次,对比序列模式不要求模式中各元素必须在序列中某特定位置出现;最后,对比序列模式中各元素间的间隔是相对位置,并非motif中元素在序列中的特定位置.因此,motif挖掘算法并不能直接适用于本文研究内容.尽管间隔约束能够提高序列模式的适用性,但需要注意的是在不具备先验知识的前提下,用户很难恰当地设定间隔约束.而不恰当的间隔约束必然导致不能发现或者遗漏序列模式.对此,本文研究了免预设间隔约束的对比序列模式挖掘问题.文献[18]研究了生物序列数据中序列模式发现的问题,并且根据模式出现的位置自动计算间隔约束.虽然文献[18]自动计算间隔约束,但与本文工作相比仍然有以下本质区别:首先,文献[18]是针对一条长序列进行挖掘,其设计的基于Apriori产生候选模式的算法框架不适用于对比序列模式挖掘.其次,文献[18]的挖掘对象没有类别,而本文的挖掘对象则是两个属于不同类的序列样本集合.第三,文献[18]基于模式出现位置没有重叠的前提计算间隔约束.相比较而言,本文提出的计算方法(本文第4节)没有此限定,因而更加灵活、通用.据我们所知,目前还没有对比序列模式挖掘研究工作考虑了在挖掘过程中自动计算间隔约束.3问题定义记Σ为序列元素的集合.例如:对于DNA序列,Σ={G,C,A,T};对于蛋白质序列,Σ包含20种基本氨基酸的编码.给定Σ,任一序列S可形式化地描述为S=e1e2…en,其中ek∈Σ称为S的一个元素,k是区间[1,n]中的正整数,称为S元素的下标.为便于表述,用S[k]指代序列S中的第k个元素,用|S|指代序列S的长度,即S包含的元素的个数.例如:S=aedcbfdc,则S[4]=c,|S|=8.对于序列S,若存在正整数序列〈k1,…,km〉,满足1k1<…<km|S|,且S=S[k1称序列S是S的子序列(S包含S),记为SS.为便于描述,在给定S的前提下,我们用S各个元素在S中的下标(〈k1,…,km〉)指代S,并称〈k1,…,km〉是S在S中出现的一个实例.例如:对于S=aedcbfdc,用〈2,4,7〉指代子序列S=ecd.对序列S中任意的两个元素S[i]和S[j](1i<j|S|),出现在S[i]和S[j]之间的元素个数称为S[i]和S[j]的间隔,记为Gap(S,i,j).容易看出,Gap(S,i,j)=j-i-1.例如:在S=aedcbfdc中元素e(S[2])和元素b(S[5])之间的间隔Gap(S,2,5)=2.定义1(间隔约束).间隔约束γ为一个整数域区间,记作γ=[γ.min,γ.max],其中γ.min,γ.max∈Ζ+γ.max为γ的上界,γ.max-γ.min为γ的宽度.设〈k1,…,km〉为序列S的一个子序列,若γ.minkl+1-kl-1γ.max(1l<m),则称子序列〈k1,…,km〉满足间隔约束γ.定义2(γ-匹配).给定间隔约束γ,序列P和序列S.若S有子序列〈k1,…,k|P|〉满足γ,且P=S[k1]…S[k例2.令序列P=ef,序列S=aedcbfdc.若γ=[2,3],那么由于P=S[2]S[6],且γ.minGap(S,2,6)γ.max,P,S满足γ-匹配;若γ=[1,2],那么Gap(S,2,6)[1,2],P不匹配S.Page4对于任一序列S以及S的子序列P和P,且PP,若P,S满足γ-匹配,则P,S不一定满足γ-匹配,如例3所示.例3.给定序列S=aedcbfdc,令序列P=adc,序列P=ac.容易看出PP.令间隔约束γ=[0,1],由于P=S[1]S[3]S[4],且γ.minGap(S,1,3)γ.max,γ.minGap(S,3,4)γ.max,P,S满足γ-匹配;而P=S[1]S[4],Gap(S,1,4)[0,1],因此P不匹配S.给定间隔约束γ,序列集合D,序列P在D中的支持度(记为supD(〈P,γ〉))为D中与P满足γ-匹配的序列的比例,即supD(〈P,γ〉)=序列模式表达了元素在序列中出现的先后顺序.在序列模式匹配中考虑间隔约束,能避免因为序列中噪声元素影响而不能匹配的情况,从而提高模式的适用性.但是,间隔约束的宽度过大会降低序列模式本身表达含义的精度.因此,本文在满足支持度阈值的相同前提下,选择宽度小的间隔约束作为挖掘结果.对宽度相同的间隔约束,则优先选择下界小的作为结果.为提高序列模式的实用性以及计算效率,序列模式挖掘通常以发现满足特定条件的“最小”序列模式为目标[4,8,19],即包含“最小”序列模式的序列不作为挖掘结果输出.例如,给定序列P和P,且PP,若P和P均满足支持度阈值要求,则只将P作为挖掘结果输出.不失一般性,我们沿用此约束,挖掘最小对比序列模式.定义3给出了本文提出的带紧凑间隔约束的最小对比序列模式的定义.定义3(带紧凑间隔约束的最小对比序列模式).给定两个序列集合pos(正类样本集合)和neg(负类样本集合),设α和β为支持度阈值,如果存在间隔约束γ,使得序列P满足如下条件(i)~(iv),那么称〈P,γ〉为带紧凑间隔约束的最小对比序列模式.(i)在序列集合pos中频繁:suppos(〈P,γ〉)α;(ii)在序列集合neg中不频繁:supneg(〈P,γ〉)β;(iii)模式最小化:不存在序列P和间隔约束γ,满足PP,P≠P,使得对P和γ,条件(i)、(ii)成立;(iv)间隔约束最紧凑:对于P,不存在符合如下任一条件的间隔约束γ,使得条件(i)、(ii)成立;(a)间隔约束宽度最小:(γ.max-γ.min)<(γ.max-γ.min);(b)宽度相等时下界最小:(γ.max-γ.min)=(γ.max-γ.min)且γ.min<γ.min.请注意,定义3中模式最小化条件只是限定模式之间的包含关系,并不限定模式的长度.本文第5节的实验结果表明,带紧凑间隔约束的最小对比序列模式的长度可以为任意值.对比文献[4]中最小对比序列模式的定义,本文提出的带紧凑间隔约束的最小对比序列模式是由序列P和间隔约束γ组成的二元组〈P,γ〉.这样,既保留了对比序列模式能有效识别不同类别序列样本集合间差异的性质(条件(i)和(ii))和最小化(条件(iii)),并且γ作为计算结果不需要在挖掘前预设.因此,本文提出的模式表达更加灵活,同时在实践中算法运行参数设置更简单,更容易为用户使用,具有更强的实用性.简而言之,本文研究的免预设间隔约束的对比序列模式挖掘问题为:在仅指定支持度阈值α和β的情况下,从序列集合pos和neg中挖掘出所有带紧凑间隔约束的最小对比序列模式,即{〈P,γ〉|P,γ满足定义3中的条件(i)~(iv)}.例4.根据表1所示正类序列样本集合pos和负类序列样本集合neg,令α=1.0,β=0.0,则带紧凑间隔约束的最小对比序列模式如表2所示.表2带紧凑间隔约束的最小对比序列模式实例观察表2可看出,不同的带紧凑间隔约束的最小对比序列模式其序列长度、间隔约束并不相同.4算法设计为解决因为用户设置不恰当间隔约束导致不能或部分发现对比序列模式的问题.我们提出了免用户预设间隔约束的算法.算法要点:(1)紧凑间隔约束;(2)最小对比序列模式,称为AlgorithmforMinimalDistinguishingSequentialPatternswithCompactGapConstraints,简称MDSP-CGC.MDSP-CGC的主要步骤包括:(1)产生候选序列模式;(2)对每一个候选序列模式挖掘能满足支Page5持度阈值条件的紧凑间隔约束.4.1算法框架MDSP-CGC算法通过枚举所有可能的候选序列模式来保证挖掘的无遗漏,即挖出所有支持度阈值条件的带紧凑间隔约束的最小对比序列模式.MDSP-CGC采用在序列数据挖掘中广泛应用的集合枚举树方法[20]产生候选序列模式.对给定集合,如序列元素集合Σ,集合枚举树依照集合元素的全序,枚举集合元素的所有可能组合.图1示例了对Σ={a,b,c},用集合枚举树枚举所有候选序列模式.MDSP-CGC算法按深度优先的方式遍历集合枚举树.令P为当前访问的结点表达的序列模式,若存在间隔约束γ,使得〈P,γ〉满足定义3中的条件,那么〈P,γ〉是一个带紧凑间隔约束的最小对比序列模式.同时,根据模式最小化性质,所有包含P的序列模式,都不可能成为最终解.因此,我们得到候选序列模式枚举剪枝条件1.剪枝条件1(最小模式剪枝).给定序列模式P和间隔约束γ,若〈P,γ〉是一个带紧凑间隔约束的最小对比序列模式,那么剪去P在集合枚举树中的所有子孙结点.例5.在例1中,当得到〈ab,[0,3]〉满足条件,那么,在集合枚举树上ab的所有子孙结点都被剪去.即,以ab开头的所有序列都不再作为候选模式.性质1.给定序列集合D,设P是序列模式P的子序列,Γ为候选间隔约束集合,那么MAX{supD(〈P,γ〉)|γ∈Γ}MAX{supD(〈P,γ〉)|γ∈Γ}成立.证明.我们用反证法证明.假设存在一个γ∈Γ,使得MAX{supD(〈P,γ〉)|γ∈Γ}<supD(〈P,γ〉)成立.那么,supD(〈P,γ〉)MAX{supD(〈P,γ〉)|γ∈Γ}<supD(〈P,γ〉)根据式(1)可得supD(〈P,γ〉)=supD(〈P,γ〉)=PP足γ-匹配,反之不一定成立.矛盾.(〈P,γ〉)|γ∈Γ}成立.性质1蕴含了下列候选序列模式剪枝条件.剪枝条件2(α剪枝).给定正类序列样本集合pos,序列模式P和候选间隔约束集合Γ,若MAX{suppos(〈P,γ〉)|γ∈Γ}<α,那么剪去P在集合枚举树中的所有子孙结点.算法1描述了MDSP-CGC算法框架.算法1.MDSP-CGC框架.输入:正类序列样本集合pos,负类序列样本集合neg,输出:带紧凑间隔约束的最小对比序列模式集合MC1.FOR深度优先遍历集合枚举树,产生候选模式P2.计算P的候选间隔约束集合Γ;3.IFγ∈Γ使得〈P,γ〉满足定义3条件(i),(ii),4.移除MC中包含P的模式;//定义3条件(iii)5.MC←MC∪{〈P,γ〉};6.剪去P的所有子孙结点;//剪枝条件17.ENDIF8.IF剪枝条件2成立THEN9.剪去P的所有子孙结点;//剪枝条件210.ENDIF11.ENDFOR12.RETURNMC;算法1步3、步4保证挖掘结果符合定义3中的各项条件.接下来,我们将介绍步2、步3的详细实现过程.4.2间隔约束挖掘朴素算法给定序列模式P,MDSP-CGC首先产生P的所有候选间隔约束(算法1步2).易知,若序列样本的最大长度为l,则候选间隔约束下界的最小值为0,上界的最大值为l-2.例6.在例1中,序列样本的最大长度为8.那么任意候选间隔约束γ满足:0γ.minγ.max6.这样,根据序列样本最大长度l,可以得到Γ={γ|0γ.minγ.max(l-2)},作为候选间隔约束集合.算法2给出了实现该过程的伪代码.Page6算法2的复杂度为O(l2).对算法2中产生的所有候选间隔约束,根据宽度和下界按升序排列,然后依次取出Γ中的间隔约束γ∈Γ,测试〈P,γ〉是否满足支持度阈值(算法1步2).可以看出,算法2对所有候选序列模式产生相同的候选间隔约束集合,这导致算法2的执行结果包含冗余,即不可能成为最终解的间隔约束.为避免这个情况,本文设计基于序列模式实例的间隔约束产生算法.算法2.间隔约束挖掘朴素算法.输入:序列样本最大长度l输出:候选间隔约束集合Γ1.Γ←;2.FORi←0TO(l-2)DO3.FORj←iTO(l-2)DO4.Γ←Γ∪{[i,j]};5.ENDFOR6.ENDFOR7.RETURNΓ;4.3基于序列模式实例的间隔约束挖掘首先,我们定义间隔约束的合并运算如下.定义4(间隔约束的合并).给定间隔约束γ1和γ2,构造间隔约束γ使得γ的下界为γ1和γ2下界的最小值,γ的上界为γ1和γ2上界的最大值,称γ为γ1和γ2的合并,记为γ=γ1∪γ2.即γ=γ1∪γ2=[MIN{γ1.min,γ2.min},MAX{γ1.max,γ2.max}].例如,[2,3]∪[4,6]=[MIN{2,4},MAX{3,6}]=[2,6].给定间隔约束γ1和γ2,若满足γ1.minγ2.min,γ1.maxγ2.max,则称间隔约束γ1覆盖γ2.例7.给定间隔约束γ1=[0,4],γ2=[1,2],0<1,4>2可知γ1覆盖γ2.回忆一下第3节定义的序列包含关系.给定序列P,若序列S中存在一组正整数序列〈k1,…,k|P|〉,满足S[k1P[|P|].〈k1,…,k|P|〉称为P在S中的一个实例.给定实例〈k1,…,k|P|〉,我们按规则1产生区间γ,称γ为P在S上的一个间隔约束实例.规则1.γ.min=MIN{Gap(S,ki,ki+1)|1i<|P|}γ.max=MAX{Gap(S,ki,ki+1)|1i<|P|}例8.设S=aedcbfdc,P=acc.那么,〈1,4,8〉是P在S中的一个实例,且[2,3]为一个间隔约束实例.序列P在序列S中有多个实例,将得到多个间隔约束实例.例如,S=aedcbfdc,P=ac.那么,可以得到间隔约束实例[2,2]和[6,6].给定序列模式P,序列样本集合D,记在D中所有序列上产生的间隔约束实例,即{γ|S∈D,γ为P在S上的一个间隔约束实例}.例9.考虑表1中的正类序列样本集合(pos),序列模式P=acc.那么,可得到P在S1的实例为〈1,4,8〉,在S2的实例为〈1,4,5〉,〈1,4,8〉和〈1,5,8〉,在S3的实例为〈2,5,8〉.根据规则1,[2,2],[2,3]}.观察1.给定序列模式P和间隔约束γ,假设〈P,γ〉是一个带紧凑间隔约束的最小对比序列模式,那么(1)γ至少覆盖一个间隔约束实例(〈P,γ〉才可能满足支持度阈值).(2)γ或者等于一个间隔约束实例,或者等于多个间隔约束实例的合并(γ满足紧凑条件).根据观察1,得到P的候选间隔约束集合Γ.性质2.给定序列集合D,序列模式P,间隔约束γ和γ,若γγ,则supD(〈P,γ〉)supD(〈P,γ〉).证明.根据定义2,{S∈D|P,S满足γ-匹配}{S∈D|P,S满足γ-匹配},由式(1)可得supD(〈P,γ〉)supD(〈P,γ〉).由性质2,可得到候选间隔约束剪枝条件3.剪枝条件3(β剪枝).给定负类序列样本集合neg,序列模式P,和候选间隔约束集合Γ.令γ∈Γ,若supneg(〈P,γ〉)>β,那么将Γ中所有覆盖γ的间隔约束移除.给定间隔约束γ∈Γ,若〈P,γ〉满足支持度阈值且γ最紧凑,那么算法1步3为真.若γ满足剪枝条件3,则移除Γ中冗余的元素.接下来介绍,如何从Γ中选择当前最紧凑的候选间隔约束.我们借鉴了归并排序[21]的思想.首先,求出界值,记为(P)}.然后,对v∈的间隔约束实例,通过合并运算产生所有以v为下界的候选间隔约束的上界,记为U(v).Page7s.t.v=γ.min,vγ.min,γ.maxγ.max}(4)显然,按升序排序U(v)中的元素.那么,当前最紧凑间隔约束一定在{[v,w]|v∈的第一个元素}.设[v,w]为当前选择的候选间隔约束,若〈P,[v,w]〉满足要求,返回[v,w].否则,从U(v)中移除第一个元素(w).重复在{[v,w]|v∈是U(v)的第一个元素}中选择最紧凑的候选间隔约束,直至找到满足条件的间隔约束,或测试完全部候选间隔约束.例10.以(P).min={0,1,2},根据式(4),可知U(0)=例.{2,3};U(1)={2,3};U(2)={3}.因此得到如下所示的候选间隔约束下界及相应的候选上界集合.首先,从{[0,2],[1,2],[2,3]}中选择最紧凑的[1,2]作为候选间隔约束.若[1,2]不满足,则继续从{[0,2],[1,3],[2,3]}中选择最紧凑的间隔约束作为候选,以此类推,直至找到满足条件的间隔约束,或考察完全部候选间隔约束.算法3描述了本小节讨论的基于序列模式实例的间隔约束挖掘算法.分析算法3最坏情况下的时间复杂度,通过扫描序列模式P中各个元素在pos每条序列中出现的位置,可以得到此,算法3步1和步2需要O(|pos|×lpos×lpos)时间,其中,|pos|表示正类序列样本的个数,lpos表示正类序列样本的最大长度.步3~步5计算所有的U(v)需要O(|对〈P,γ〉进行支持度检测,需要O(|(|pos|×lpos+|neg|×lneg))时间,其中lneg表示负类序列样本的最大长度.因此,算法3的时间复杂度为O(|pos|×lpos×lpos+||O(|(P).min|×lpos×(|pos|×lpos+|neg|×lneg))=(P).min|×lpos×(|pos|×lpos+|neg|×lneg)).相比于间隔约束挖掘朴素算法(算法2),算法3显著地减小了候选间隔约束集合的规模.同时,通过对候选间隔约束排序,避免了产生冗余结果(非最紧凑间隔约束),提高了效率.下一节,我们将通过实验验证算法3的执行效率.算法3.基于序列模式实例的间隔约束挖掘.输入:正类序列样本集合pos,负类序列样本集合neg,输出:间隔约束γ1.根据pos产生2.3.FOREACHv∈4.计算U(v)并按升序排列;5.ENDFOR6.REPEAT7.γ←{[v,w]|v∈8.U(v)←U(v)\{w};9.IFsuppos(〈P,γ〉)α∧supneg(〈P,γ〉)βTHEN10.RETURNγ;//〈P,γ〉满足定义3条件(i),11.ENDIF12.IFsupneg(〈P,γ〉)>βTHEN//剪枝条件313.移除包含γ的候选间隔约束;14.ENDIF15.UNTILγ=;16.RETURN;若由算法3得到间隔约束γ为非空,则〈P,γ〉为带紧凑间隔约束的候选最小对比序列模式.在两种情况下,候选序列模式P找不到最合适的间隔约束(算法3输出结果为):第一,在正类序列样本集合中不存在间隔约束使得P的支持度大于等于阈值α;第二,在负类序列样本集合中不存在间隔约束使得P的支持度小于等于阈值β.在这两种情况下,P将不作为结果输出.根据剪枝策略和算法3的设计,容易看出MDSP-CGC算法的挖掘结果一定满足定义3的条件.同时,定理1保证了MDSP-CGC算法的完备性.定理1.给定候选序列模式P,间隔约束γ,若〈P,γ〉为带紧凑间隔约束的最小对比序列模式,则〈P,γ〉一定在MDSP-CGC算法的结果中.证明.我们用反证法证明.假设存在一个γ∈Γ,使得〈P,γ〉为满足带紧凑间隔约束的最小对比序列模式成立,但不在MDSP-CGC算法的挖掘结果中,那么有以下情况:(1)〈P,γ〉被剪枝条件1移除;Page8(2)〈P,γ〉被剪枝条件2移除;(3)〈P,γ〉被剪枝条件3移除;综上,〈P,γ〉为满足带紧凑间隔约束的最小对比序列模式不成立,与原假设矛盾.5实验5.1实验环境实验采用UCI机器学习数据集①提供的E.coli基因序列数据集和用户行为序列数据集ActivitiesofDailyLiving(ADLs),以及pfam数据库(http://pfam.sanger.ac.uk/)提供的蛋白质序列数据集CbiA/X和TatD/C来验证本文提出的MDSP-CGC算法的有效性和执行效率.E.coli中的基因序列包含G、C、A、T4种编码,CbiA/X和TatD/C中的序列包含41种编码,ADLs记录了A、B两个用户的日常行为序列(10种类型).表3列出了实验数据集的特征.正类序列集合E.coli+CbiATatDADLs-A所有算法采用Java语言实现.为区别4.2节和4.3节给出的两种不同的候选间隔约束产生方式,将基于序列模式实例产生候选间隔约束(算法3)的版本记为MDSP-CGC,将采用间隔约束挖掘朴素算法(4.2节算法2)产生候选间隔约束的版本记为Baseline.同时,为验证MDSP-CGC算法的实用性,我们实现了与本文工作最相关的文献[4]中提出的ConSGapMiner算法(为方便表达,用CSM指代ConSGapMiner).请注意,CSM算法必须预先给定间隔约束,并且间隔约束下界的取值固定为0.为进行对比,我们用Java语言重新编写CSM算法以支持间隔约束γ下界为任一非负整数值.在本文所有实验中,默认正类样本集的相对支持度阈值(α)设置为0.6,负类样本数据集的相对支持度阈值(β)设置为0.4.所有实验都在配置为IntelCorei7-37703.90GHzCPU,8GB内存,Windows7操作系统的PC上完成.5.2MDSP-CGC算法有效性验证为验证MDSP-CGC算法的有效性,我们在E.coli、CbiA/X、TatD/C、ADLs上分别运行MDSP-CGC算法,挖掘带紧凑间隔约束的最小对比序列模式.图2给出了在4个数据集上挖掘的序列模式最紧凑间隔约束宽度的分布情况.可以看出,序列模式集合在各个间隔约束宽度上均分布有一定数量的序列模式.请注意MDSP-CGC在E.coli、CbiA/X、TatD/C、ADLs数据集上挖掘得到的大部分(>66.7%)结果的间隔约束的宽度不超过4.我们分析这是因为MDSP-CGC优先选择满足支持度阈值的紧凑(宽度小)间隔约束.表4~表7列出了在4个数据集上,带紧凑间隔约束的最小对比序列模式的平均长度和序列模式α×|E.coli+|α×|CbiA|α×|TatD|α×|ADLs-A|①http://archive.ics.uci.edu/mlPage9图2带紧凑间隔约束的对比序列模式数量的分布(β=0.4)的个数.由表4可知,当负类样本支持度阈值固定,随着正类样本支持度阈值增大,E.coli数据集(DNA序列)上发现的对比序列模式的平均长度呈递增趋势.由于基因序列中只有G,C,A,T这4种编码,较短的序列模式难以满足支持度阈值条件.随着正类样本支持度阈值的增大,集合枚举树向下搜索的深度相应增加.因此,结果集序列模式的平均长度会增加.表5、表6、表7分别列出了MDSP-CGC算法在蛋白质序列数据集CbiA/X、TatD/C和用户行为序列数据集ADLs上所发现的对比序列模式的平均长度和个数.与表4不同,在蛋白质序列数据集中MDSP-CGC算法发现的序列模式的平均长度和模式的个数没有随着正类样本支持度阈值的增大而变化.我们分析其原因为:在蛋白质序列数据集中存在满足条件且长度较短的对比序列模式,根据剪枝条件1,所以由集合枚举树生成的候选模式集合规模相对固定.值得一提的是,表5中序列模式的平均长度为1.997,是因为在CbiA/X数据集中单元素模式“X”在CbiA类中出现了773次,而在CbiX类中出现次数为0.因此,模式“X”满足支持度阈值条件,出现在结果中(请注意定义3关于对比序列模式的条件并不限定模式长度必须大于1).图2和表4~表7说明,如果只考虑某一宽度的间隔约束,将不能发现满足其他间隔约束的最小对比序列模式.为进一步说明此问题,我们利用与本文工作最相关的文献[4]中提出的CSM算法来挖掘指定间隔约束下的最小对比序列模式.表8列出了在支持度阈值α=0.6和β=0.4时,CSM算法(需要预先指定间隔约束)发现的最小对比序列模式个数,以及MDSP-CGC算法挖掘的最小对比序列模式个数(MDSP-CGC算法不需要预先设定间隔约束).从表8可以看出一般情况下,MDSP-CGC算法能够发现更多的最小对比序列模式.但值得注意,在E.coli数据集中CSM算法得到的序列模式个数更多.这是因为MDSP-CGC算法挖掘满足支持度阈值的最小对比序列模式,根据最小模式剪枝,CSM得到的部分结果在MDSP-CGC算法结果中不是最小,因此不会出现在MDSP-CGC的挖掘结果中.因此,在不具备设定间隔约束先验知识的前提下,本文提出表8MDSP-CGC与CSM挖掘模式个数(α=0.6,β=0.4)数据集E.coliCbiA/XTatD/CADLsPage10的MDSP-CGC算法能更灵活、有效地发现对比序列模式.由于篇幅有限,我们仅在表9中列出当设定α=0.6,β=0.4时,MDSP-CGC算法在E.coli数据集上的挖掘结果.观察表9可知,各个模式的间隔约束范围并不统一.例如,设定间隔约束为[1,3],只能发现部分结果.表10中列出当设定α=0.6,β=0.4时,MDSP-CGC算法在ADLs数据集上间隔约束宽度为2的的挖掘结果.由表10可知,得到的序列模式的间隔约束在各个区间上均有分布.若先验地给出间隔约束,则可能丢失序列模式.例如:若指定间图3MDSP-CGC算法与Baseline算法运行时间比较(β=0.4)由此可见,相较于CSM需要预先指定间隔约束,MDSP-CGC算法能自动挖掘对比序列模式并计算最合适的间隔约束则更加实用.5.3MDSP-CGC算法执行效率验证为验证MDSP-CGC算法的执行效率,我们记录了MDSP-CGC算法在不同正类样本绝对支持度阈值(α×|pos|)下的运行时间.据我们所知,目前还没有与MDSP-CGC挖掘任务完全一致的相关工作,我们将MDSP-CGC与Baseline算法的运行时间进行对比;容易看出,MDSP-CGC算法明显快于Baseline算法.特别地,随着数据集规模增大,序列平均长度增长,MDSP-CGC算法相比于Baseline算法效率提升更显著.需要注意的是,随着正类样本支持度阈值的增大,MDSP-CGC算法耗费的时间逐渐增加.这是因隔约束为[1,3],则会丢失间隔约束[3,5]、[4,6]、[9,11]和[12,14]所相关的4个对比序列模式.表9MDSP-CGC在犈.犮狅犾犻的挖掘结果(α=0.6,β=0.4)表10MDSP-CGC在ADLs的挖掘结果(α=0.6,〈SnackGrooming,[1,3]〉〈BreakfastLeaving,[4,6]〉〈ToiletingLeaving,[9,11]〉〈SleepingToileting,[12,14]〉为,随着正类样本绝对支持度阈值增大,大量候选序列模式都不适用于剪枝条件1,导致集合枚举树上搜索的深度增加,产生更多的候选序列模式,增加算法运行时间.但MDSP-CGC算法的执行时间明显少于Baseline算法.表11记录了在设置α=0.6,β=0.4时,MDSP-CGC算法在不同数据集上经过β剪枝后的候选间隔约束(即算法3步9中考察的候选间隔约束)的宽度分布情况.表11MDSP-CGC候选间隔约束的宽度分布(α=0.6,β=0.4)数据集E.coliCbiA/XTatD/CADLsPage11根据表11所涉及的候选间隔约束,图4示例了在α=0.6,β=0.4时,CSM算法在选取不同间隔约束宽度的情况下,考察同等规模的候选间隔约束所需的执行时间.为便于对比,图4也示例了MDSP-CGC在同样支持度阈值下,挖掘带紧凑间隔约束的运行时间.由于执行CSM算法需要预先指定间隔约束,因此,我们计算CSM执行所有给定间隔约束的运行时间之和.例如,图4中,CSM-3表示根据表11所涉及的候选间隔约束,选择所有宽度不超过3的候选间隔约束来执行CSM算法.可以看出,随着候选间隔约束宽度的增长,利用CSM算法发现图4MDSP-CGC算法与CSM算法运行时间比较(α=0.6,β=0.4)图5MDSP-CGC算法伸缩性分析(α=0.6,β=0.4)带紧凑间隔约束的最小对比序列模式需要更多的运行时间.值得注意的是,在图4(b)和图4(c)中,虽然CSM算法在间隔约束宽度规模小于等于4时执行时间比MDSP-CGC算法少,但是CSM算法在间隔约束宽度规模小于等于4时不能找到所有带紧凑间隔约束的最小对比序列模式.最后,我们验证了MDSP-CGC算法的伸缩性,考虑了MDSP-CGC算法执行时间与数据集的选择相关.我们通过复制的方法,将实验数据集规模依次增大k倍.这样,在保持支持度阈值相同情况下,算法挖掘结果保持不变.图5示例了MDSP-CGC算法Page12在实验数据集E.coli、CbiA/X、TatD/C、ADLs规模增大k倍,正类样本数据集的相对支持度为0.6,负类样本数据集的相对支持度为0.4的条件下,执行时间的变化情况.观察图5可以看出,MDSP-CGC执行时间随着数据集规模增大而线性增长.可见MDSP-CGC算法具有较好的伸缩性.6结论对比序列模式在识别不同类别序列样本集合的特征上有着重要的作用.已有对比序列模式挖掘算法需要用户预设间隔约束.在不具备充分先验知识的情况下,用户不易准确地预设恰当的间隔约束,进而导致不能发现有用的模式.针对这个问题,本文设计了带紧凑间隔约束的最小对比序列模式挖掘MDSP-CGC算法,实现免用户设置间隔约束,并对候选模式自动计算最适合的间隔约束,避免了用户在不具备先验知识的情况下因为设置参数不恰当而丢失结果的情况,因此对推动对比序列模式挖掘的实际应用有积极作用.我们设计了3种剪枝策略和相应的数据结构,来保证算法MDSP-CGC具有较高的执行效率.在蛋白质序列、DNA序列以及行为序列数据集上的实验验证了MDSP-CGC算法的有效性和执行效率.下一步,我们将把免间隔约束对比序列模式挖掘的思想应用于其他类型的序列模式挖掘.此外,我们将设计MDSP-CGC算法的分布式实现版本,以及基于免间隔约束对比序列模式的分类器训练,并尝试将其应用于金融、医学等领域的数据分析.
