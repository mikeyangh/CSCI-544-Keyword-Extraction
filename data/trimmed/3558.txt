Page1针对AES的Cache计时模板攻击研究王韬1)赵新杰1)郭世泽2)张帆3)刘会英1)郑天明1)1)(军械工程学院计算机工程系石家庄050003)2)(北方电子设备研究所北京100083)3)(康涅狄格大学计算机科学与工程系斯托斯康涅狄格州06269美国)摘要受微处理器硬件架构和操作系统的影响,分组密码查找S盒不同索引执行时间存在差异,构成了S盒索引的天然泄漏源.该文采用“面向字节、分而治之”的旁路攻击思想,对AES抗Cache计时模板攻击能力进行了研究.首先分析了分组密码访问Cache时间差异泄漏机理,直观地给出了基于碰撞和模板的两种Cache计时攻击方法;其次给出了Cache计时外部模板攻击模型,提出了基于Pearson相关性的模板匹配算法,对128位AES加密第一轮和最后一轮分别进行了攻击应用;为克服外部模板攻击需要一个模板密码服务器的限制,提出了Cache计时内部模板攻击模型,并对AES进行了攻击应用;最后,在不同环境、操作系统、加密Cache初始状态、密码库中,分别进行攻击实验,同前人工作进行了比较分析,并给出了攻击的有效防御措施.关键词高级加密标准;分组密码;Cache计时攻击;模板攻击;查找S盒;防御措施1引言1.1相关工作Cache访问过程中,可通过执行时间、能量消耗(电磁辐射)等旁路产生一定的信息泄露.Kocher[1]和Kelsey[2]在20世纪90年代中期提出将这些旁路信息用于密码破解的思想,随后密码学家在此基础上实现了针对分组密码的各种Cache攻击[3-33].根据所采集物理效应的分类不同,可将Cache攻击分为Cache计时攻击和Cache功耗分析(电磁)攻击两种;根据信息采集模型不同,可将Cache攻击分为时序驱动(timedriven)、访问驱动(accessdriven)、踪迹驱动(tracedriven)3种.时序驱动攻击[4-11]主要通过计时手段采集整个密码加/解密时间,利用统计方法分析密钥.文献[4-7]利用Cache命中和失效次数同密码整体的执行时间关系对DES、AES进行了攻击,这种攻击可简称为“Cache碰撞计时攻击”.文献[8]利用查找S盒不同索引的执行时间同密码整体执行时间的关系,通过模板分析的方法对AES进行了远程计时攻击,该攻击可简称为“Cache计时模板攻击”.后续研究者对文献[8]中的攻击进行了再现[9]、分析[10]以及扩展[11].时序驱动攻击所需样本量大,分析方法相对复杂,但采集方法简单,跨平台适用能力强.访问驱动攻击[12-25]主要利用多进程共享Cache资源特性,使用一个恶意进程S通过读取私有数据在密码进程V执行(某次查找表或整个加密)前清空Cache,然后在V执行后再次启动S观察私有数据被替换情况,根据二次访问执行时间推断S和V的外部Cache访问碰撞,获取V访问Cache行地址,并结合算法进行密钥分析.文献[12]首次指出多线程共享Cache访问方式可为恶意线程监视采集密码线程Cache访问地址提供入口,使得恶意线程能够窃取加密密钥,并实现了针对RSA的访问驱动Cache计时攻击.之后,基于该思想,研究者对AES[13-19]、Camellia[20]、ARIA[21]、SMS4[22]等分组密码,HC-256[23]、SNOW3G[24]、RC4[25]等流密码进行了攻击应用.同时序驱动攻击相比,访问驱动攻击采集方法比时序驱动稍显复杂,但分析方法简单,一般通过计时手段实现,主要适用于支持多进程或线程的微处理器平台.踪迹驱动攻击[26-33]需精确采集一次密码加密多次查表导致的内部Cache访问碰撞信息,得到每次加密所有查表的Cache命中和失效序列,在此基础上结合算法进行密钥分析.文献[26]首先提出踪迹驱动攻击思想,文献[27]首次通过功耗仿真对AES进行了攻击尝试,后续研究者通过仿真手段对OPENSSL中的快速AES实现的第一轮[28]、第二轮[29]、最后一轮[30]进行了分析,通过功耗[32]、电磁[33]手段对适用紧凑型S盒的AES实现进行了物理攻击实验.一般来说,Cache访问内部碰撞采集通过计时手段很难实现,常通过功耗或电磁采集手段进行,攻击主要适用于嵌入式处理器平台,需物理接触密码设备,远程攻击可行性不强.上述3种攻击中,通过分区Cache、将S盒预先加载到Cache中等实现[8,14,34-36],可消除Cache碰撞信息对整体执行时间的影响、阻止攻击者采集Cache碰撞信息,进而可有效地防御时序驱动攻击中的Cache碰撞计时攻击、访问驱动攻击和踪迹驱动攻击.但由于查找S盒不同索引的时间差异受CPU硬件架构、操作系统等多种因素影响,很难从根本上消除掉,现有措施不能有效防御Cache计时模板攻击.有研究者指出[11],即使在加密前将S盒提前加载到Cache中,使得加密每次查表均发生Cache命中,仍不能完全消除掉查表执行时间差异,存在遭受Cache计时模板攻击的风险.因此,本文主要对Cache计时模板攻击进行研究.在Cache计时模板攻击方面,Bernstein[8]在强制消除网络传输时延条件下,实现了一种针对OpenSSL-0.9.7a中AES加密第一轮的远程Cache计时攻击,使用227.5个样本恢复出128位AES密钥.攻击中,密码服务端负责采集AES加密时间并发送给攻击端,本质仍属本地攻击.Bernstein首先搭建了一台同目标密码服务器相同配置的模板密码服务器,在已知密钥情况下采集到对大量样本的加密时间,并计算第一轮每个查表索引对应256个聚类的平均时间标准差(每个聚类平均时间同所有聚类的平均时间之差),得到一条模板曲线;然后对目标密码服务器在未知密钥情况下采集大量样本的加密时间,通过预测每个密钥字节候选值,计算第一轮每个查表索引对应的256个聚类的平均时间标准差,得到一条预测曲线;再通过计算这两条曲线256个点的平均时间标准差乘积并求和,得出两条曲线匹配度.正确的密钥字节候选值对应的匹配度较高,否则较低.Bernstein攻击存在以下潜在问题:一是计算的曲线匹配度未进行归一化处理,匹配算法准确度有待提高;二是攻击条件过于严格,需获取同目标密码服务器一样配置的模板密码服务器,并能控制其在密钥已知时进行密码运算,搭建时间模板.本Page3文工作主要是围绕上述两个问题开展的.1.2本文的贡献本文对Cache计时模板攻击进行了一定的研究,并以AES为例进行了攻击应用,主要研究贡献如下:(1)分析了分组密码查找S盒Cache访问时间泄漏的机理,直观给出了如何利用时间差异进行密钥分析的方法.分组密码时序驱动Cache攻击主要是利用S盒操作时间差异对整体加密时间的影响进行密钥分析.我们认为S盒查表操作时间差异可划分为两类:一是加密两次,查找同一个S盒Cache访问时命中和失效的时间差异,二是利用加密一次查找同一个S盒不同索引的执行时间差异.现有时序驱动Cache攻击[4-11]本质上都属于这两类中的某一类,大都仅给出原理说明,细节阐述很少.本文首次直观地给出了这两类时间差异的特征以及如何利用其进行密钥分析的方法,同时对时间差异泄漏机理和攻击防御难度也进行了比较分析.(2)提出了一种新的基于计算Pearson相关性的Cache计时模板匹配算法.Bernstein[8]给出了一种Cache计时外部模板攻击,主要针对AES加密第一轮进行,其模板匹配方法是将已知密钥时查表索引对应计时标准差模板曲线、未知密钥字节预测查表索引对应计时标准差曲线上256个点简单乘积加和,最大匹配度对应的预测值即为正确密钥字节值,匹配度未进行归一化处理.本文首先给出Cache计时外部模板攻击模型,并提出一种新的基于计算Pearson相关性的Cache计时模板匹配算法,然后对AES加密第一轮和最后一轮均进行攻击和分析.新模板匹配算法通过计算模板曲线、预测曲线间的Pearson相关性系数,对模板匹配度进行归一化处理,提高了正确密钥字节可识别度,降低了攻击所需的样本量.模型.(3)提出了一种新的Cache计时内部模板攻击Bernstein攻击[8]属于外部模板攻击,攻击假定可预先获取一个同目标密码服务器一样配置的模板密码服务器,并能够使用已知密钥执行大量的加密操作,采集加密时间构建模板.实际情况下,这种条件过于严格,而且在外部模板攻击中,用于搭建模板的密码服务器上的运行环境很难保证同目标密码服务器完全一致,而这种环境的差异信息对攻击成功率存在很大的影响.为解决上述问题,本文提出了一种新的Cache计时内部模板攻击模型,并对AES第一轮和最后一轮进行了攻击分析.攻击者可直接采集目标服务器加密时间,然后利用不同次查找同一个S盒的时间搭建内部计时模板,通过计算Pearson相关性系数的模板匹配方法恢复相关密钥.由于内部模板搭建可在目标密码服务器上直接进行,模板搭建和匹配准确度相对较高,攻击样本量比外部模板攻击相对要小.(4)分析和评估了不同环境下AES实现抗Cache计时模板攻击的能力,并给出攻击的一种有效防御措施.现有的时序驱动Cache计时攻击[4-11]大都在单一环境下针对单一AES实现进行,我们则利用Cache计时模板攻击对本地远程环境、不同操作系统、不同加密前Cache初始状态、不同密码库下的AES实现安全性进行了分析和评估,试图研究AES实现在不同环境下的抗Cache计时模板攻击的能力,并给出有效防御措施.结果表明:由于网络传输时延甚至其抖动远大于不同输入的加密时间差异,远程环境下的分组密码Cache计时模板攻击可行性不高;加密前将S盒预先加载到Cache中可有效防御Cache碰撞计时攻击、访问驱动和踪迹驱动Cache计时攻击,但由于其不能消除查找不同S盒索引的访问时间差异,因而不能有效防御Cache计时模板攻击;最新的各类密码库,如OpenSSL-0.9.8j、Mir-acl5.0、LibTomCrypt1.17、Crypto++5.6.1中AES实现仍然是不安全的;防御可通过在AES加密首轮、末轮将查找表预先加载到Cache中,并增加一定的随机时延来实现.1.3结构组织本文第2节给出Cache访问机制、查找S盒访问Cache时间泄漏机理和密钥分析方法;第3节给出Cache计时外部模板攻击模型和对AES攻击应用,并和前人工作进行了比较;第4节给出Cache计时内部模板攻击模型和对AES攻击应用,并对两种模板攻击进行比较分析;第5节对不同环境、不同操作系统、不同加密Cache初始状态、不同密码库下的AES实现安全性进行分析和评估;第6节给出一种攻击防御措施;第7节总结全文.2Cache结构与信息泄露分析2.1Cache访问机制现代微处理器大都使用高速缓存Cache来解决Page4CPU与主存之间速度不匹配的问题.假设整个Cache包括S个Cache组,每组有W个Cache行,每行有δ个元素(B字节),则整个Cache大小为S×W×δ×B字节.CPU读取主存中的一个字a时,首先将a地址放入地址寄存器,Cache控制逻辑依据地址判断a当前是否在Cache中,如果是则地址变换成功,发生“Cache命中”,从Cache中直接读取a;否则发生“Cache失效”,根据程序局部性原理,把包括a在内的一整块数据(δ个Cache元素)从主存中读出来,装载到Cache中去,然后从Cache中读取a.对于典型处理器来说,Cache命中所需时间较少,一般为2~3个时钟周期,而失效则一般需要10~14个.需要指出的是,如无特殊说明,文中的加密时间都是以时钟周期为基本单位.现代分组密码大都使用S盒查表操作,访问Cache,提高算法的执行效率,但由于其整体加密时间受Cache结构和访问机制影响,可在某种程度上泄露出S盒查表索引信息,给密钥安全带来严重威胁.影响密码整体加密时间的因素有很多,本文主要从S盒查表操作时间对整个加密时间的影响进行分析.总的来说,S盒查表操作时间对整体加密时间的影响分为两类:一是加密两次查找S盒Cache访问命中和失效的时间差异,常用于“Cache碰撞计时攻击”;二是利用加密查找S盒不同索引的执行时间差异,常用于“Cache计时模板攻击”.下面分别给出如何利用这两类信息进行密钥分析的方法.2.2查找S盒Cache访问命中和失效时间信息泄露分析如图1所示,pi和pj是一次加密过程中两个明文字节,ki和kj是对应的密钥字节.以AES[37]加密第一轮查找表①T0为例,对于两次查T0表操作,首先按照明文字节差分pipj将大量样本的整个加密时间划分为256个聚类,并计算每个聚类的平均加密时间.如果两次查表索引相同,则第二次查表会发生Cache命中,满足此时pipj值对应的聚类样本加密时间较短,否则较长.也就是说,加密时间较短聚类对应的即为pipj的值,事实上就是kikj值.当考虑到Cache调度策略和程度的局部性原理,发生Cache命中时,AES加密两次查找T0表的索引值y的高8-log2(δ)位(表示为〈y〉)相同,即〈piki〉=〈pjkj〉〈kikj〉=〈pipj〉(2)此时会有连续的δ个pipj值对应聚类的平均加密时间较短.图2为Athlon643000+1.81GHz处理器下(δ=16)221样本时,OpenSSL-0.9.8a[38]中AES第一轮前两次查找T0表根据p0p4值划分的256个聚类的平均访问时间,可以看出,当p0p4的高4位值为7时,其对应平均加密时间较短,而真实的p0p4值为0x78.图2p0p4的256候选值对应的AES平均加密时间2.3查找S盒不同索引时间信息泄露分析2.2节考虑的是同一次加密两次查找S盒时,第二次查找S盒发生的Cache命中和失效对整体加密时间的影响,本节则主要考虑单次查找S盒不同索引访问时间对整体加密时间影响.受处理器硬件架构、操作系统、Cache调度策略等因素影响,分组密码查找S盒不同索引的访问时间也不尽相同.Bernstein[8]指出:大量样本的查找分组密码S盒不同索引的平均访问时间可以用来进行精确建模,作为计时模板信息.图3为WindowsXPSP2环境、Athlon643000+1.81GHz处理器下(δ=16),使用两个已知的不同随机密钥对221样本加密时,OpenSSL-0.9.8a中AES第一轮查找T0表(图3(a))、T3表(图3(b))的256个索引值对应的平均加密时间标准差.平均加密时间标准差是指某个索引值聚类对应的平均加密时间减去所有加密样本平均加密时间差值.可以看出,同一查找表的256个索引值对应平均加密时间标准差确实不尽相同,而且不同查找表的相同查表索引对应的平均加密时间①这里的查找表实际上就是S盒.Page5标准差也不相同.图3不同密钥对应的AES第一轮查表256个如果攻击者能够掌控一台同目标密码服务器相同的模板密码服务器,并能使用已知密钥进行加密,采集到AES第一轮16次查找S盒的所有索引值的平均加密时间,搭建类似图3的16条Cache计时模板曲线,然后对未知密钥的目标密码服务器采集大图4Cache外部计时模板攻击模型量的加密时间信息,分别预测每个密钥字节的值,将根据每个密钥字节候选值将样本划分为256个索引值聚类,得到对应的一条平均加密时间标准差,计算其同前面模板曲线的匹配度,正确密钥字节候选值对应的匹配度往往较高.在加密前进行Cache预热,将S盒提前加载到Cache中,使得加密每次查表均发生Cache命中,可消除2.2节提到的时间差异,进而有效防御Cache碰撞计时攻击[4-7]、访问驱动攻击[12-19]和踪迹驱动攻击[26-33].然而本节攻击利用的单次查找S盒不同索引的时间不受Cache访问命中和失效时间的影响,时间差异根源来自于CPU硬件架构、操作系统等因素,很难消除.即使在加密前将整个S盒提前加载到Cache中,单次查找S盒不同索引值的时间仍然可以用于构建模板,用于进一步的密钥分析.考虑到利用这类时间差异信息进行攻击的较强适用性,本文主要研究利用单次查找S盒不同索引值的访问时间差异进行的密钥分析,即Cache计时模板攻击技术.3AESCache计时外部模板攻击3.1Cache计时外部模板攻击模型需要说明的是,本文中的Cache计时模板攻击主要针对S盒查表操作,特别适用于使用了S盒的分组密码甚至流密码.攻击一般由模板搭建、目标设备Cache计时信息采集、模板匹配3个步骤组成(图4).不失一般性,下面以对分组密码加密第一轮使用明文P和密钥K异或值查表分析为例进行Page6(1)模板搭建攻击者能够掌控一台同目标密码服务器一样的模板密码服务器,并能对其使用已知密钥进行加密操作.①对掌控模板密码服务器,使用已知密钥KT为N个随机明文样本执行加密操作,将采集加密时间存储在数组TM[i](1iN).②对于第一轮加密过程中的m次(假如m=16)查表操作对应的明文、密钥块(假如块大小为一个字节),根据16个索引值piki(1iN)的候选值,分别将TM[i]划分为256个聚类,并计算每个聚类的平均加密时间标准差TMC[i][j](0i15,0j255)中.介绍.(2)目标设备Cache计时信息采集①对未知密钥目标密码服务器,使用未知密钥K采集对N个随机明文加密时间T[i](1iN).②对于第一轮加密中m次查表操作对应的明文、密钥块,以第i次查表操作为例,首先预测ki的256个候选值,对于每个ki的第j个候选值,计算N个明文样本对应piki值q,将T[i]划分为256个聚类,并计算平均加密时间标准差TC[i][j][q](0i15,0j255,0q255).(3)模板匹配①以分析密钥ki为例.假设i=0,ki=0,利用式(3)计算匹配向量犡=TC[0][0][q]同计时模板向量犢=TMC[0][q]的Pearson相关性系数,得到ki的256个候选值对应的相关性系数向量犚[0][j](0j255).表110次OpenSSL-0.9.8a中AES第一轮Cache计时外部模板攻击结果序号k0k1k2k3k4k5k6k7k8k9k10k11k12k13k14k15115215511101881165112170212114821135230111940131873113120191111426111513311116614131421113150128813911891315122965116138122241611116441611351001112911129811113316171188331122711721112051751811761951132127112507811127419139681117136119923115750210111501111113114521143131从表1可以看出,T0表和T3表对应的8个密钥字节恢复效果较好,而T1表和T2表对应字节恢复效果较差.图5(a)、(b)分别为猜测k0=0xe0和k0=0x98时预测查T0表索引聚类和模板中索引聚类对r〈犡,犢〉=∑255②将向量犚[0][j](0j255)按大小进行排序,最大值对应的j即为正确ki.③参考上面步骤通过模板匹配获取所有ki值,通过进一步分析获取初始密钥K.需要说明的是,上面模板攻击过程同样适用于利用密文和加密时间对最后一轮扩展密钥的分析.3.2第一轮攻击为提高AES软件加密速度,OpenSSL-0.9.8a中AES在每一轮中,将除与轮密钥异或以外的操作合并为16次查表操作.整个加密过程由160次查表和176次异或操作组成,执行效率非常高,前9轮分别对T0~T3表执行4次查表操作,最后一轮仅对T3表执行了16次查表操作.AES第一轮加密16次查表操作索引为应用3.1节攻击模型,通过采集已知密钥的AES密码服务器加密时间构建模板,并采集未知密钥的密码服务器加密时间,然后预测每个密钥字节ki,并根据其利用式(3)~(4)计算每个索引字节对应的平均加密时间标准差,同模板进行匹配,匹配度最大的即为正确密钥字节值.在Windows环境下对OpenSSL-0.9.8a中的AES进行了10次Cache计时外部模板攻击实验,样本量为221,16个正确密钥字节在256个候选值模板匹配度集合中排序如表1所示,其中匹配度越高,序号越小.应平均加密时间标准差曲线.正确的密钥值是0xe0.当k0=0xe0时,两条曲线十分接近(图5(a)),而k0=0x98时,两条曲线差异较大(图5(b)).图6(a)为k0的256个候选值的匹配曲线,可以Page7看出,k0=0xe0对应匹配度比较大,匹配曲线出现明显的峰值.需要说明的是,当考虑到程序的局部性原理时,每次查找表访问1个索引值就会将同一个块的16个Cache元素都加载到Cache中,这样相邻图5OpenSSL-0.9.8a中AES第一轮查T0表索引值256聚类对应平均加密时间标准差图6OpenSSL-0.9.8a中AES加密第一轮密钥字节候选值模板匹配度实验中我们发现,经模板分析有些密钥字节的恢复效果比较好,如第k0,k3,k4,k7,k8,k11,k12,k15字节,正确的密钥字节值对应的匹配度最高,峰值比较明显(图6(a)),有些密钥字节(如k1)的恢复效果则较差(图6(b)),正确的密钥字节对应匹配度不一定是最高的.有趣的是,正确k5,k14字节的低的16个索引查表时间十分接近,这样索引值的低4位值有时候很难精确预测.在图6(a)中,当k0的高4位为e时,其匹配度都相对比较高.2~4位也可以恢复出来,如图6(c)、(d)所示,会出现32个峰值,其对应密钥字节的低2~4位相同.这样,在Windows环境下,221样本下,应用本节攻击,可恢复OpenSSL-0.9.8a中AES的70位密钥.进一步降低密钥搜索空间可通过下面两个途径获得:一是加大攻击样本量,二是对AES加密第二轮进行Page8进一步模板分析.3.3最后一轮攻击Bernstein攻击[8]主要针对AES加密第一轮,使用了227.5个样本,经几天时间才恢复128位AES密钥.我们在第一轮攻击的基础上,尝试将攻击转向最后一轮,检验AES最后一轮抗Cache计时模板攻击能力.OpenSSL-0.9.8a中AES最后一轮仅对T4表进行了16次查表操作,16次查表索引yi为T4[yi]k9应用3.1节攻击模型,通过采集已知密钥的密码服务器上加密时间构建模板,并采集未知密钥的表210次OpenSSL-0.9.8a中AES最后一轮Cache计时外部模板攻击结果序号k91112211111111112119211211111111111113130121111111112114214911111111111212514294111111112111616521111111111111713121111111111118121111111111112191124461111111115221110260161121111111111图7(a)为AES最后一轮k9配曲线,同图6比较可以看出,正确密钥候选值k90xc9对应匹配度比较大,匹配曲线会出现唯一的峰值,效果要好于第一轮攻击.原因有两个方面:(1)只有最后一轮对T4表执行了16次查表操作,整体加密时间受每次查T4表操作时间影响比较明显,而第一轮攻击关注的是对加密整体时间受第一轮查T0~T34个表的影响,由于加密其它轮也要查找这4个表,进而对整体加密时间也有较大影响,因而第一轮查表时间差异对整体时间影响较小,噪声较大.图7OpenSSL-0.9.8a中AES加密最后一轮密钥字节候选值模板匹配度密码服务器加密时间,然后预测每个密钥字节k9并根据其利用式(3)和式(5)计算最后一轮每次查表索引字节对应的平均加密时间标准差,同模板进行匹配,匹配度最大的即为正确密钥字节值.在Windows环境下对OpenSSL-0.9.8a中的AES进行了本节所述外部模板攻击实验,样本量大小为220,攻击均能在有限复杂度内恢复完整密钥,10次攻击最后一轮密钥字节的模板匹配度排序如表2所示.从中可以看出,最后一轮攻击(表2)大部分正确密钥字节对应的排序要高于第一轮攻击(表1),攻击效果要好.7k98k9(2)文中每个Cache行包含δ=16个AES查表元素.考虑到程序的局部性原理,根据第一轮攻击中利用的式(4)可知,与正确密钥高4位相同的16个密钥字节的查表时间对整体时间影响大致相同,故第一轮理论上一般可获取每个密钥字节的高4位,而根据最后一轮攻击利用的式(5)可知,由于T4表的雪崩扩散作用,同正确密钥高4位相同的16个密钥字节的查表时间对整体时间的影响也有很大区别,每个预测密钥字节对整体加密时间的影响差异都大,故正确密钥字节对应的匹配曲线峰值最为明显.Page9但是最后一轮k9理想(图7(b)),匹配曲线比较平缓,没有出现明显的峰值,匹配度普遍比较低,我们可以分析得出结论1猜测错误,最后通过暴力破解获取k9k93.4同前人工作比较Bernstein[8]攻击是典型的Cache计时外部模板攻击,主要针对AES加密第一轮进行,使用227.5个样本恢复出128位AES密钥,攻击得到的模板匹配度未进行归一化处理.我们在对Bernstein攻击基础上,提出了一种新的基于Pearson相关性系数的模图8本文模板匹配方法同Bernstein攻击比较4AESCache计时内部模板攻击4.1Cache计时内部模板攻击模型第3节模板攻击属于“两步攻击”,攻击者需掌控一个与目标密码服务器一样配置的密码设备,并能够对已知密钥执行加密操作.本节则尝试去除该条件,构造一种“一步攻击”.攻击者直接采集目标服务器的加密时间,然后利用不同次查找同一个S盒时间搭建内部计时模板,通过模板匹配恢复相关密钥.下面将详细描述Cache内部模板攻击模型.Cache内部模板攻击一般由目标设备加密时间信息采集、内部模板构建、模板匹配3个步骤组成.不失一般性,下面仍以对分组密码加密第一轮使用明文P和密钥K的异或值查表的分析为例进行介绍.目标设备加密时间采集过程不再赘述.分组密码两次查找同一个S盒时,根据其索引yi,yj(如i=0,j=4)划分的256个聚类平均时间标准差分布特征应该基本相似,如图9(a)、(b)所示.攻击者采集到目标密码服务器使用未知密钥的加密时间后,由于密钥未知,故无法根据查找表索引y将所有样本板匹配算法,对AES第一轮和最后一轮均进行了攻击分析.新匹配算法对匹配度进行了归一化处理,提高了Bernstein攻击的效率,可降低攻击样本量和提高攻击准确度.图8(a)、(b)分别为外部模板攻击中,220样本下,应用Bernstein攻击方法和本文模板匹配方法对OpenSSL-0.9.8aAES加密最后一轮进行攻击(被攻击密钥字节相同,0x6b)的结果.可以看出,本文方法对模板匹配度进行了归一化处理,正确密钥字节峰值更为明显.加密时间划分为256个聚类,而只可以根据每次查表对应的明文字节进行聚类划分.具体内部模板构建、模板匹配方法如下:(1)首先按照pi值进行聚类划分,得到256个聚类平均时间标准差,绘制一条模板曲线,如图9(c)所示.(2)然后攻击者可通过预测kikj值,针对每一个kikj值,得到kikjpj值对应的256个聚类(根据pj划分)的平均时间标准差.(3)因为kikj=pipj,如果kikj预测正确,kikjpj所划分的256个聚类平均时间标准差曲线和pi值划分的模板曲线应该最匹配(如图9(d)),计算两条曲线间的Pearson相关性系数值最大;反之,如果kikj预测错误,得到的预测曲线同模板曲线差别较大(如图9(e)),得到的Pearson相关性系数值较小.需要说明的是,基于内部模板攻击可得到某轮查同一类型S盒对应的不同密钥字节异或值,并不能直接得到密钥字节值.同样,上面攻击模型适用于利用密文和加密时间对最后一轮扩展密钥异或值进行的分析.Page10图9Cache计时内部模板攻击模型4.2第一轮攻击OpenSSL-0.9.8a中AES第一轮对T0~T3,4个表分别查找4次,共查找16次表,第j次查找的是Tj%4表.根据4.1节,第一轮攻击可获取24(4×(4×3)/2)个kikj(0i,j15,i%4=j%4)密钥字节,如图10所示.这样,第一轮攻击理想情况下可获取到96(4×表3OpenSSL-0.9.8a中AES第一轮10次Cache计时内部模板攻击结果序号k4k0k5k1k6k2k7k3k8k0k8k4k9k1k9k5k10k2k10k6k11k3k11k7119725146122207912469254121703815711988135282501311396791122774135152551417965841119410616582521511213067112052519749250161787913911101271292481712081595111706710993253181224012611229491124819114460104112006711392501101674592115810117102461序号k12k0k12k4k12k8k13k1k13k5k13k9k14k2k14k6k14k10k15k3k15k7k15k111232191972186172314230256212115195571081525052562553111422061403620543246254413259699914711127325525452213056169284846323025561111061051016960264255254713197134131221336423725682131409573877551125625591213716423435911662512561012132851047967462255255图10AES第一轮Cache计时内部模板攻击恢复密钥3×8)位AES密钥,但当考虑到Cache访问的局部性原理时,对于64字节Cache行大小,每个Cache行16个S盒元素来说,理论上可获取48(4×3×4)位密钥.对OpenSSL-0.9.8a中的AES进行了第一轮内部模板攻击实验,样本量大小为220,10次攻击各个相关密钥字节的模板匹配度排序如表3所示.实验中发现:正确的k4k0,k8k0,k8k4,k11k7,k12k0,k12k4,k12k8,k15k3字节对应匹配度一般是最高的.如图11(a)所示,3组攻击中的256个k4k0候选值匹配度(正确值为0xa2)最高.这同3.2节OpenSSL-0.9.8a中的AES第一轮外部模板攻击可精确恢复k0,k3,k4,k7,k8,k11,k12,k15字节的结果也基本对应.实验中,我们还发现正确的k11k3,k15k11字节对应匹配度常常是最小的,3组攻击中的256个k15k11候选值匹配度Page11(正确值为0xb6)如图11(b)所示,利用该特性,也可以恢复k11k3,k15k11字节.图11OpenSSL-0.9.8a中AES加密第一轮这样,在Windows环境下,使用221样本,应用本节攻击,通过对恢复的k4k0,k8k0,k8k4,k11k7,k12k0,k12k4,k12k8,k15k3,k11k3,k15k11字节进行分析,可恢复OpenSSL-0.9.8a中AES的48位密钥.进一步降低密钥搜索空间可通过下面加大攻击样本量或开展第二轮分析进行.4.3最后一轮攻击OpenSSL-9.8.a中AES最后一轮仅对T4表进行了16次查表.根据4.1节原理,最后一轮攻击最多可获取120个k9后一轮扩展密钥K9,经密钥逆推恢复初始主密钥K.应用4.1节分析模型,对OpenSSL-0.9.8a中AES最后一轮进行攻击,219样本下,120个正确j的密钥字节匹配度排名如图13所示.可以看ik9k9出,OpenSSL-9.8.a中AES最后一轮攻击后,大约110个左右的k9复AES第10轮的120位扩展密钥,经逆推和暴力破解恢复初始密钥.4.4两种模板攻击比较分析在Athlon643000+1.81GHz处理器、Windows图12AES最后一轮Cache计时内部模板攻击恢复密钥图13OpenSSL-0.9.8a库中AES的正确k9XPSP2、MicrosoftVisualC++6.0环境下,我们对OpenSSL-0.9.8a密码库中AES实现进行了Cache计时外部和内部模板攻击实验.结果表明,OpenSSL-0.9.8a库中AES最后一轮外部模板攻击和内部模板攻击中可分别使用220和219样本恢复128位AES密钥.同外部模板攻击相比,内部模板攻击具有以下特点:(1)降低了攻击代价外部模板攻击假定攻击者可预先获取一个与目标密码服务器一样配置的模板密码服务器,并能够使用已知密钥执行大量的加密操作,采集加密时间搭建模板.实际情况下,这种条件过于严格,内部模板攻击则不需要该条件.(2)提高了攻击准确度外部模板攻击中,用于搭建模板密码服务器上的运行环境很难保证同目标密码服务器完全一致,这种环境的差异信息对攻击成功率存在很大的影响.内部模板攻击可在目标服务器上直接搭建时间模板,准确度较高,攻击样本相对要小.(3)可获取密钥字节异或结果外部模板攻击可直接获取AES轮密钥每个字Page12节.内部模板攻击中,由于攻击主要利用加密不同次查找同一类型S盒访问时间差异,只能直接获取对应密钥字节异或值.在OpenSSL-0.9.8a中AES攻击时,由于第一轮分别查找4种查找表4次,第一轮内部模板攻击理论上可恢复96位密钥,比外部模板攻击128位的理论值小;由于最后一轮仅对T4表查找16次,内部模板攻击可获取120位AES密钥,结果比128位的理论值小.5攻击实验扩展与比较分析在实验过程中,课题组还在本地远程环境、不同操作系统、不同加密前Cache初始状态、不同密码库下的AES实现进行了多例攻击实验,以评估其抗Cache计时模板攻击安全性.5.1本地、远程环境攻击前面第3、4节攻击主要在本地环境下进行.在此基础上,我们在两种远程环境下(Windows环境)对OpenSSL-0.9.8a库中AES最后一轮进行了外部模板攻击实验,攻击端、模板密码服务器和目标密码服务器分别被部署在不同的电脑上.(1)第1种攻击环境同Bernstein[8]攻击类似,加密服务器在收到攻击端发送的明文后,将准确的加密时间同密文一起反馈给攻击端,攻击端再利用3.1节方法分析密钥.与Bernstein攻击不同的是,攻击端向加密服务端仅发送16个字节的明文,而Bernstein攻击每次需发送400(800)字节的明文.由于计时采集不是在攻击端进行,攻击可称之为伪远程攻击.在这种环境下,由于服务端接收明文和发送密文、加密时间需要大量地访问Cache,能够起到间接的清空Cache作用,其攻击的最高模板匹配度同次高模板匹配度的差距甚至要远大于本地攻击时(加密前清空Cache)最高模板匹配度同次高模板匹配度的差距,攻击效果十分明显,如图3所示.实验结果表明,此类伪远程计时攻击,无需像Bernstein攻击每次需发送400(800)字节的明文,正常的16个字节明文发送加上上次信息采集中密文和加密时间反馈就可以基本达到清空Cache,将AES查找表从Cache中驱逐出去的作用.(2)第2种攻击环境中,攻击端负责采集从发送明文到接收到密文之间的时间,这是实际攻击中常见的场景.对AES最后一轮进行外部模板攻击时,采集的模板服务器最后一轮第一次查T4表的256个索引值的加密平均时间(90000个时钟周期)及标准差同目标服务器(1400个时钟周期)具有很大不同,时间抖动范围很大(-60到80个时钟周期),差异很大,故即使是正确的密钥字节值,其模板匹配度也很低,整个模板匹配度十分不准确(如图15(b)).而在伪远程攻击时,模板服务器和目标服务器的查T4表的256个索引值加密平均时间标准差基本接近,时间抖动范围非常小(-4到6个时钟周期),十分接近,对于正确的密钥字节值,模板匹Page13配度很高(如图15(a)).可以说明,Cache计时模板攻击在真实远程环境下的可行性不强,网络传输时延甚至其抖动即可掩盖了加密查同一S盒不同索引操作的微弱时间差异.5.2不同操作系统下攻击同一处理器硬件架构在不同操作系统环境下,每个查找表建立的时间模板信息不同,噪声大小也不尽相同.我们在Windows环境实验的基础上,还在Fedora8Linux系统、Gcc4.1.8编译器环境下进行了攻击实验.Linux环境下,其它进程给攻击带来的噪声较小,S盒在Cache中往往是对齐的(对于64B的Cache行大小,1KB大小S盒恰好对应16个Cache行),高4位相同的密钥值对应模板匹配度基本相同.这样,第一轮攻击一般可获取每个密钥字节的高4位(图16);而在Windows环境下,由于操作系统进程和其它进程的影响,即使是高4位相同的密钥字节,对应的匹配度也有很大差异,大部分情况下可直接获取正确密钥字节候选值.图16Linux和Windows环境下AES第一轮密钥k0的5.3不同加密初始状态攻击在前面本地攻击实验中,在加密前大都需进行Cache清空操作,使得加密前查找表都没有预先加载到Cache中,保证Cache的初始状态一致,实验效果非常理想.当前的部分AES软件实现将查找表提前加载到Cache中,这样每次Cache访问都会发生Cache命中,可在一定程度上防御时序驱动Cache攻击.我们尝试在加密前不清空Cache条件下,在Linux环境下对OpenSSL-0.9.8a进行了模板攻击,进行了两类实验.一类是通过修改算法,将AES查找表预先加载到Cache中;此外,我们还在加密前不执行任何操作情况下进行了攻击实验,实验结果同加密前将AES所有查找表预先加载到Cache中攻击效果基本接近.第一轮攻击中,215个样本采集分析后可获取每个密钥字节的低2~4位,最终获取48位密钥(图17).最后一轮攻击中,217个样本下可直接获取k96,k93,k9k9图18加密前预先加载S盒条件下AES最后一轮5.4不同密码库下攻击为检验不同密码库中AES实现抗Cache计时模板攻击能力,我们以Cache计时外部模板攻击为例,针对OpenSSL-0.9.8a、Miracl5.0[39]、LibTom-Crypt1.17[40]、Crypto++5.6.1[41]4类典型密码库中的AES实现,在Windows和Linux环境下,在加密前Cache清空和Cache预热(提前加载S盒到Cache中)两种情况下,开展了大量的攻击实验,实验结果如表4所示.Page14表4不同密码库中AES实现Cache计时模板攻击结果比较OpenSSL-0.9.8aMiracl5.0LibTomCrypt1.17WindowsCrypto++5.6.1由表4可知,这4种典型密码库中的最新AES实现仍易遭受Cache计时模板攻击的威胁,安全隐患较大.此外,加密前进行Cache预热并不能很好地防御Cache计时模板攻击.6攻击防御措施在加密前将查找表预先加载到Cache中,可有效防御Cache碰撞计时攻击、访问驱动Cache攻击、踪迹驱动Cache攻击,本文大量的实验证明了该防御措施并不能有效防御Cache计时模板攻击.为了更好地防御此类攻击,可通过在算法实现中加入一定的随机时延[8,14,34-35](如插入空指令、垃圾指令)来实现.下面我们以Linux系统上Miracl5.0密码库中AES实现为例,通过插入随机个(范围为1~10)空指令,研究随机时延抗Cache计时模板攻击有效性.表5、图19、图20为未加防御、预先加载S盒、预先加载S盒并加入随机时延3种情况下,对AES进行第一轮攻击和最后一轮攻击的结果.表5Miracl5.0密码库中几种AES实现攻击结果(220样本)AES实现未加防御预先加载S盒预先加载S盒并加入随机时延144从图中可以看出:(1)未加防御措施的Miracl5.0密码库中AES实现是不安全的(图19(a)、图20(a));(2)预先加载S盒到Cache后,Miracl5.0中AES执行效率接近于未加防御实现,但第一轮攻击可获取到密钥字节低2~4位(图19(b));最后一轮加密初始状态Cache清空Cache预热Cache清空Cache预热Cache清空Cache预热Cache清空Cache预热Cache清空Cache预热Cache清空Cache预热Cache清空Cache预热Cache清空Cache预热图19Miracl5.0密码库中AES第一轮攻击Page15图20Miracl5.0密码库中AES最后一轮攻击攻击正确密钥字节模板匹配度有所降低,但仍可攻击成功(图20(b));(3)加密前预先加载S盒到Cache中并加入随机时延的Miracl5.0密码库中AES实现,其执行效率要高出未加防御的AES实现约20个时钟周期,但均可有效防御AES第一轮(图19(c))和最后一轮攻击(图20(c)).需要注意的是如果算法防御仅加入时延而不进行加密前Cache预热处理,并不能有效防御访问驱动Cache攻击和踪迹驱动Cache攻击.因此在AES实现过程中,将Cache预热和随机时延结合起来,可有效防御目前所有的Cache计时攻击.7总结本文对AESCache计时模板攻击进行了研究,在对Bernstein的AES第一轮Cache计时模板攻击基础上,提出了一种新的基于Pearson相关性系数的Cache计时外部模板匹配算法,对AES第一轮和最后一轮进行了分析应用,然后利用一次加密不同次查找同一S盒时间搭建内部模板,提出了一种新的Cache计时内部模板分析模型,并对AES第一轮和最后一轮进行了分析应用;在两种模板分析的模型基础上,对不同操作系统、不同密码库、不同加密Cache初始状态,对AES实现抗Cache计时模板攻击能力进行了研究.结果表明,加密前将S盒预先加载到Cache中并不能消除查找不同S盒索引的访问时间差异,进而不能有效防御Cache计时模板攻击;最新的各类密码库中AES实现仍然存在安全隐患,仍易遭受Cache计时模板攻击威胁;防御此类攻击可通过在AES加密首轮和末轮提前将查找表加载到Cache中,并增加一定的随机时延来实现.
