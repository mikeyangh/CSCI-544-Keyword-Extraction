Page1基于扰动的亚复杂动力系统因果关系挖掘郑皎凌1),2)唐常杰1)乔少杰3)杨宁1)李川1)陈瑜1)王悦1)1)(四川大学计算机学院数据库与知识工程研究所成都610065)2)(成都信息工程学院软件工程系气象信息共享与数据挖掘实验室成都610225)3)(西南交通大学信息科学与技术学院成都610031)摘要传统因果分析方法主要是基于具有分布预设的概率模型,但动力系统通常是存在反馈的非线性系统,不适合采用概率方法进行分析.针对这一问题,该文提出了基于扰动的亚复杂动力系统因果分析方法,主要工作包括:(1)采用基因表达式编程的函数拟合方法对动力系统时间序列进行差分方程拟合,减免了关于数据分布模型的预设;(2)基于得到的拟合函数,通过对自变量的扰动来计算因变量的相应波动,提出了根据扰动和波动的数值关系来判断自变量和因变量之间因果关系的判断准则,并基于该准则提出了因果关系挖掘算法和挖掘结果可信度验证方法;(3)在合成数据和真实数据上进行了翔实实验,结果表明该文所提出的算法能挖掘出合理因果关系,在不同数据规模情况下能得到一致挖掘结果.与两种基于概率统计的因果分析方法进行了对比实验,结果表明当系统要素多于两个时,该文的算法仍然能够得到多个要素间正确的因果关系,而两种基于概率统计的方法则无法挖掘出正确的因果关系.关键词亚复杂动力系统;因果关系分析;扰动;波动;函数拟合;数据挖掘1引言1.1研究动机复杂系统是目前很多领域的研究课题,如复杂网络、非线性系统和混沌系统等.亚复杂系统是对复杂系统进行特征提取,忽略次要因素得到的一个较简单且有可能作出工程性解决方案的系统,简称亚复杂系统(Sub-ComplexSystem,SCS).亚复杂动力系统因果关系挖掘旨在从动力学关系上找出系统各要素间的因果关系.此项研究有下列背景:(1)为亚复杂系统干预规则挖掘提供可靠的因果关系支持,保证干预规则的合理性和正确性.亚复杂系统干预规则挖掘旨在描述人工干预下亚复杂系统的动力学行为,解释干预的普适规律[1].而要制定干预规则必须首先弄清系统中各个要素间的因果关系,之后才能施加干预,也只有这样得出的决策才是可信的;(2)在动力系统理论中,判断一个要素对另一个要素的影响是通过建立要素间的微分或差分方程,然后分析方程的特征属性来进行的.但现实中很多要素间并没有直接的方程可循,例如人们认为地球的潮汐和温度可能与太阳黑子有关,但目前尚无相关的动力学方程.找出这类动力系统的因果关系将为建立更准确的模型奠定基础;(3)现有的因果关系研究对数据做了大量假设,如数据呈正态分布或没有环路因果链等,这些假设在实践环境中不一定成立,故需要新的方法来分析动力系统的因果关系.针对上述问题,本文探索如何挖掘亚复杂动力系统因果关系.由于亚复杂动力系统的运行机制总是与时滞和反馈相关的,所以进行分析的对象是系统中各个要素所产生的时间序列数据.下面的实例可充分说明本文研究的对象和目标.例1.有某段公路上随时间变化(每小时)的4个要素:汽车流量(car(t)),平均风速(wind(t)),二氧化氮浓度(NO2(t)),温度(temp(t)).(1)挖掘对象,如图1所示,挖掘对象是由这4个要素产生的时间序列数据;(2)挖掘目标,显然这4个要素可以构成2×4=12对因果关系,挖掘目标是从这12对关系中C2排除掉虚假的因果关系,从而得到真实的因果关系.如图1中Car→NO2√表示car会影响NO2是真实因果关系,而NO2→Car×则表示NO2会影响car是虚假的因果关系.下面对本文挖掘对象和目标进行形式化描述.(1)亚复杂动力系统因果挖掘对象SCS.SCS是系统中各个要素产生的所有时间序列数据,形式化表达成四元组〈m,k,T,Em×k〉,m是系统中要素个数,k是每个要素存在时滞个数,T表示时间序列的长度,Em×k表示系统中所有要素在所有时滞上的集合.如例1亚复杂动力系统的挖掘对象SCS=〈m,k,T,Em×k〉,则m={car,wind,NO2,temp},若k=1,则Em×k={car(t),car(t-1),wind(t),wind(t-1),NO2(t),NO2(t-1),temp(t),temp(t-1)},若T=Page3200d,则表示SCS中含有200d的时间序列数据.(2)亚复杂动力系统因果挖掘目标.设有SCS=〈m,k,T,Em×k〉,m={x1,x2,…,xm},则该系统的候选因果关系共有2×C2m个,记为Candidate_Set={xi→xj|1i,jm,i≠j}.本文旨在挖掘出Candidate_Set子集Causality_Set∈Candidate_Set,使得任意〈xj→xi〉∈Causality_Set都是系统中真实因果关系.为描述简洁,令xj→xi表示xj是xi的原因.1.2问题的难点(1)基于概率对SCS进行挖掘的难点传统的对时间序列进行因果挖掘的方法主要是基于概率的,如两个时间序列之间的相关系数,互信息,转移熵等.而SCS各要素间和要素自身通常存在时滞和反馈,即整个系统模型主要是基于差分或微分方程,而不是基于概率状态的转移.所以,我们认为采用概率方法进行SCS因果挖掘是不合适的.(2)基于回归对SCS进行挖掘的难点传统的因果关系挖掘,如因果贝叶斯网和格兰杰因果检验等,都可以基于回归拟合来进行[2-4],文献[5-6]采用了遗传算法来对因果贝叶斯网的概率参数进行拟合.进化算法,特别是基因表达式编程(GeneExpressionProgramming,GEP),具有强大的函数发现能力,给定预先假设好的因果关系,GEP通常都能够拟合出适应度较高的函数,同时GEP还能够拟合出多种适应度较高的函数,显然这就使得这种基于拟合函数的因果分析方法可信度较低.例2表明基于回归的因果关系发现方法可信度较低.例2.例1的动力系统中有4个要素,从实际生活经验出发可知car→NO2是可信因果关系,而NO2→car则肯定是虚假的因果关系,因为汽车流量一般是不受道路上二氧化氮浓度影响的.但在具体实验中,采用GEP进行函数回归,发现无论是以car(t)作为因变量,还是以NO2(t)作为因变量,都能拟合出适应度很高的函数,故采用函数回归得到的因果关系实际上是不可信的.(3)存在噪声的可信因果关系挖掘即使采用回归分析能得到较准确的因果关系,当数据中含有噪声数据时,挖掘结果也会受到影响,下面举例说明噪声数据的含义及其带来的影响.例3.考虑例1的动力系统.假设car→NO2是真实的因果关系,而气温Temp和风速Wind对NO2没有影响.如果把Car,Temp和Wind作为自变量,把NO2作为因变量进行函数拟合,来分析哪些要素是NO2的原因,有可能得出错误结论,因为此时Temp和Wind是噪声数据,会对分析形成干扰(噪声数据对因果挖掘的干扰形式可参见4.1节例6).2相关工作如1.2节所述,传统的在时间序列上的因果关系挖掘主要是基于概率的,实践表明,SCS的时间序列数据主要是通过差分或微分方程产生的,而不是基于状态间的概率转移的,基于此,本文方法与传统方法有较大不同.本节旨在介绍传统的因果挖掘方法.典型的因果分析方法有格兰杰因果检验[2-3],因果贝叶斯网络[4-5],基于信息理论的因果分析等.按照研究对象分类,包括时间序列因果分析,非线性时间序列的因果分析和生物信号网络的因果分析.格兰杰因果检验既考察变量间的相互关系又考虑其自身变化,格兰杰检验判断变量X是否能预测变量Y,若不能,则认为X不能导致Y,反之亦然.但格兰杰检验需要假设所检验的序列是平稳的,而实际情况是很多宏观和金融序列都是非平稳的,文献[6]讨论了这个问题.同样,对于因果系统的检验也是基于函数回归的,这种理论认为只要回归函数中自变量的时间早于因变量的时间,就称该系统是因果的,我们认为这是不太合理的,因为进化计算特别是GEP有着强大的函数发现能力,给定预先假设好的因果关系,GEP通常都能够拟合出适应度较高的函数,显然这就使得这种对拟合函数的参数进行分析的方法可信度较低.并且上述方法主要针对的都是线性系统,很难推广到非线性系统.因果贝叶斯网络[7]能够学习变量间的概率依存关系及其随时间变化的规律,通过隐变量集合表达时间序列蕴含的潜在信息,通过构造一个有向无环图来反映一系列变量间的概率依存关系.网络结构[8-9]是动态贝叶斯网络中一个关键部分,它表明了系统各元素间的因果关系.目前主要基于进化算法来学习网络结构,这又会存在上述问题,即通过进化算法可得到多种不同且适应度都较高的网络结构,选取其中一种而放弃另一种都无法给出很好的解释.同时,动态贝叶斯网络主要是进行状态间的因果分析,很难运用到数值型非线性系统因果挖掘中.基于信息转移的因果分析利用信息论工具,如信息熵,动态熵,互信息和转移熵等指标来表示两个Page4信号序列间信息的传递方向,文献[10-11]考虑了因果方向.由于互信息[12-13]是一种静态且对称的指标,不适合衡量信息流动的动态过程,文献[14]提出了转移熵来计算信息流间驱动和响应的关系.但是,由于当时间序列的n维分布函数的维数较多或对连续取值区间的划分较细时,都会引起概率论中的“维数灾”.如果预先对时间序列的性质作出某些假设,如服从马尔科夫性或泊松分布,都会降低分析准确性.非线性时间序列的因果分析起源于线性时间序列,文献[15]采用搜索算法对多种时间要素构成的有向无环图进行搜索,来发现线性系统中的偏序关系和依赖关系.文献[16]克服了上述算法只针对线性系统的弱点,提出了快速因果推理算法(FastCausalityInference),能够挖掘存在隐变量(latentvariables)和反馈(feedback)的因果系统.另一些研究基于一组已有的模型族,通过贝叶斯后验方法对这些模型进行打分,最后通过这些模型挖掘出系统的因果关系[17].这些方法依赖于一些先验的假设,比如系统中的各要素之间是条件独立的,或者服从正态分布等,从很大程度上限制了其应用范围.在生物信号时间序列的分析中,主要采用各种滤波,自回归模型及相关性分析方法.如采用相关性来分析神经信号与癫痫病发作的关系[18],采用滤波来分析脑电波与各种行为的关系[19]以及采用自回归模型来分析心血管和心肺间各种生物信号的交互关系[20-21].目前研究的较多的蛋白质信号网络的因果分析则主要采用贝叶斯因果网络来进行分析.如文献[22-23]提出了基于因果贝叶斯网的方法来分析人类T细胞中蛋白质信号网络的因果关系,其主要思路是通过操纵蛋白质中某种化学物质的含量(如磷和磷脂)来控制该蛋白质的活跃(active)或不活跃的状态(non-active),继而来判断其对整个蛋白质信号网络的因果影响.从最新的研究成果来看,Shi等人[24]提出了基于时间序列相似性来判断复杂系统中各要素因果关系的方法,并成功地用于股票因果分析中;Snowsill等人[25]基于重用度来分析Web上各个网页之间的引用因果关系,即把原创页面作为原因,把转载页面作为结果;Liu等人[26]基于频繁项集来挖掘交通数据流中的时空因果干预关系.这些算法都能够出色地分析出特定领域中各要素之间的因果关系,但对于复杂系统中存在环路、时滞的情况就不是很合适.本文第3节介绍亚复杂动力系统因果挖掘过程,包括3.2节介绍GEP对时间序列数据的拟合,3.3节介绍对拟合函数的扰动,3.4节介绍基于扰动结果进行因果分析,并提出了整篇文章所依据的假设和定理;第4节提出基于该假设的两种因果挖掘算法和挖掘结果可信度判断方法;第5节给出在合成数据和真实数据上的实验结果.3基于扰动的SCS因果关系挖掘机制3.1总体挖掘流程如前所述,本文的因果挖掘摆脱了传统的基于概率状态转移的思路,而主要是基于动力学中的扰动理论,本节旨在概括描述基于扰动的SCS因果关系挖掘的过程.因果关系挖掘过程如图2所示.设有亚复杂动力系统SCS=〈m,k,T,Em×k〉,m={x1,x2,…,xm},不失一般性,假设要分析xj是否是xi原因,即xj→xi,则挖掘流程如下:(1)采用GEP以xi(t)为因变量,以Em×k-xi(t)为自变量进行函数拟合,得到函数xi(t)=f({Em×k-xi(t)});(2)基于扰动(后面将详细介绍)对f中的自变量xj施加扰动δ,并计算出因变量xi的相应波动值δf;(3)根据因果判断原则判断xj→xi的真实性.3.2基于GEP的函数拟合本节旨在完成图2中的第1步,即构造拟合函数.设有亚复杂动力系统SCS=〈m,k,T,Em×k〉.则挖掘因果关系的第1步是构造以每个要素xi∈m作为因变量,以Em×k-xi(t)作为自变量的函数.下面给出拟合函数的形式化定义.定义1.ε-拟合函数fxi(t).给定SCS=〈m,k,T,Em×k〉,ε-拟合函数fxi(t)使得xi(t)=fxi(t)({Em×k-xi(t)}),并且|(xi(t)-xi(t))/xi(t)|<ε,其中xi(t)是原时间序列的值,xi(t)是通过fxi(t)得到的拟合值,{Em×k-xi(t)}是fxi(t)的自变量集合.值得指出的是,进行函数拟合时,若因变量是xi(t),则自变量是Em×k-xi(t).易知xi(t-1)~Page5xi(t-k)也属于自变量,这是因为我们需要用xi(t-1)~xi(t-k)来构造关于要素xi动力系统差分方程.下文中都按照上述方式进行函数拟合.由于GEP是遗传算法和遗传编程的结合算法,有强大函数发现能力,故这里采用GEP来进行函数挖掘,关于GEP的详细介绍参见文献[27].3.3对拟合函数进行扰动本节目的是解决第2节问题难点中的第一个难点,也即完成图2中的第2步.由于对真实和虚假的因果关系,GEP都能拟合出适应度较高的函数,无法直接基于拟合结果进行因果分析,我们在拟合结果的基础上,基于扰动和波动的数值关系进行因果判断,下面先举例说明.例4.考虑例1中的动力系统.判断car与NO2的因果关系,即判断是车流量引起二氧化碳浓度的变化,还是相反.(1)首先分别以二者作为因变图3真实因果关系和虚假因果关系的扰动效果(横坐标都表示以小时为单位的时间顺序,纵坐标表示在每个时间点上的汽车流量Car(t)或者是二氧化氮浓度NO2(t))下面形式化描述对拟合函数自变量的扰动及因变量的相应波动.定义2.给定SCS=〈m,k,T,Em×k〉及拟合函数fxi(t).函数的扰动δfxi(t)(xj,δ,t0):δfxi(t)(xj,δ,t0)是挡在t=t0时刻,当自变量xj(t0)~xj(t0-k)取得增量δ,而其他自变量固定时,fxi(t)取得的增量,即δfxi(t)(xj,δ,t0)=fxi(t)(…xj(t0)+δ,…,xj(t0-k)+量进行函数拟合设为car(t)=f(…NO2(t)…),NO2(t)=f(…car(t)…).从图3(a)、图3(b)可以看到,二者都有较好的拟合效果;(2)分别对拟合出的函数在自变量上施加一定的扰动,即car(t)=f(…NO2(t)+δ…),NO2(t)=f(…car(t)+δ…),然后观察因变量的波动情况.图3(c)、图3(d)显示了扰动后因变量的波动情况.可以看到图3(d)中NO2(t)的波动很小,而图3(c)中car(t)式的波动很大.我们认为现实中的动力系统总是具有一定惯性的,当自变量发生微小扰动时,因变量会由于惯性不会产生很大的波动.所以,如果拟合函数反映的是动力系统中真实的因果关系,那么当对自变量进行微扰时,因变量的波动不大.反之,若拟合函数所反映的因果关系在现实系统中并不存在,那么对自变量的微扰可能会引起因变量的强烈变化,第3.4节给出具体解释.δ…)-fxi(t0)(…xj(t0),…,xj(t0-k)…).波动∑fxi(t)(xj,δ,t):波动是扰动在整个时间序列上的平方和,即∑fxi(t)(xj,δ,t)=δfxi(t)(xj,δ,t1)2+…+δfxi(t)(xj,δ,tT)2,其中T就是SCS中时间序列的长度.例5.设有SCS=〈m,k,T,Em×k〉,m={x,y},k=1,T=5,Em×k={x(t),x(t-1),y(t),y(t-1)},Page6x(t)和y(t)的时间序列如表1所示.x(t)1371015y(t)25376y(t)+δ47598设得到以x(t-1),y(t-1)为自变量,以x(t)为因变量的拟合函数fx(t):x(t)=x(t-1)+y(t-1)(x(t)是原时间序列的值,xi(t)是通过fxi(t)得到的拟合值),则当自变量y取得增量δ=2后,fx(t)在时间序列2~5上的波动∑fx(t)(y,δ,t)=δfx(t)(y,δ,1)2+δfx(t)(y,δ,2)2+δfx(t)(y,δ,4)2+δfx(t)(y,δ,4)2,δfx(t)(y,δ,2)=|x(2)-x(2)|2=|(x(1)+(y(1)+δ))-x(2)|2=|1+4-3|2;δfx(t)(y,δ,3)=|x(3)-x(3)|2=|(x(2)+(y(2)+δ))-x(3)|2=|1+4+7-7|2;δfx(t)(y,δ,4)=|x(4)-x(4)|2=|(x(3)+(y(3)+δ))-x(3)|2=|1+4+7+5-10|2;δfx(t)(y,δ,5)=|x(5)-x(5)|2=|(x(4)+(y(4)+δ))-x(3)|2=|1+4+7+5+9-15|2.3.4因果判断准则本节将基于函数扰动和波动概念,提出本研究依据的因果判断准则(图2中第3步).为清晰表达,先给出本节用到的符号(表2)和必要而合理的假设.Max(f(x))f(x)在整个时间序列上的最大值Min(f(x))f(x)在整个时间序列上的最小值δfy(x,δx,t0)函数的扰动,见定义2∑fy(x,δx,t)函数的波动,见定义2假设1.设动力系统含有两个要素x,y,其中x影响y,且有y=f(x);x是随机时间序列,通过函图4在不同时间序列上进行扰动的结果(横坐标都表示以小时为单位的时间顺序,纵坐标表示在每个时间点上的二氧化碳浓度CO2(t)或者是天然气浓度Gas(t))数拟合,得到x=g(y),由于在实际系统中g(y)具有时滞和其他自变量,故g(y)≠f-1(y).并设x0,y0分别是x和y的任意一个取值,f(x),g(y)分别是f(x)和g(y)的一阶导函数,则有下列假设:(1)f(x),g(y)在其自变量的范围内具有各阶导数;(2)|f(x0)δx|<C×|Max(f(x))-Min(f(x))|;(3)|g(y0)δy|C×|Max(g(y))-Min(g(y))|.解释:对于(1),动力系统函数对自变量各阶可导的要求在实践中容易满足.对于(2)、(3),我们以实验5.2.1节中的box-jenkins时间序列数据的一部分(如图4(a)、图4(b)来进行说明.由于CO2(t)具有一定的惯性,图4(a)中点x0处作切线,有Δ1=f(x0)δ1和Δ2=f(x0)δ2,并且由于f(x)波动较小,当δ较大时仍有|f(x0)δx|<C×|Max(f(x))-Min(f(x))|.而Gas(t)是人为随机控制,波动较大,在图4(b)中点y0处作切线,有Δ1=f(x0)δ1和Δ2=f(x0)δ2,但当δ较大时,有|g(y0)δy|C×|Max(g(y))-Min(g(y))|.值得指出的是,假设中存在两个参数,即对x施加扰动的大小δx和常数C.我们认为δx取x(t)在整个时间序列上的平均值是比较合适的,C一般取10.定理1.设动力系统含有两个要素x,y,其中x影响y,且有y=f(x);x是随机时间序列,且时间序列的长度为T,通过函数拟合,得到x=g(y),则当δx和δy取较大值时有:(1)|δfy(x,δx,t0)|<C×|Max(f(x))-Min(f(x))|;(2)|δgx(y,δy,t0)|C×|Max(g(y))-Min(g(y))|;(3)∑fy(x,δx,t)<C×T×|Max(f(x))-(4)∑gx(y,δy,t)C×T×|Max(g(y))-Min(f(x))|2;Page7Min(g(y))|2.证明.见附录1.基于假设1和定理1有以下因果判断定理2.定理2.设有SCS=〈m,k,T,Em×k〉,有任意两个要素x,y∈m,通过函数拟合得到拟合函数y=f(x),如果∑fy(x,δx,t)C×T×|Max(f(x))-Min(f(x))|2,那么x不是y的原因.证明.反证,设x是y的原因,由定理1有∑fy(x,δx,t)<C×T×|Max(f(x))-Min(f(x))|2矛盾,命题得证.即当∑fy(x,δx,t)C×T×|Max(f(x))-Min(f(x))|2时,可得x不是y的原因,但无法证明当∑fy(x,δx,t)<C×T×|Max(f(x))-Min(f(x))|2,x就是y的原因.故第4节的算法都是基于排除法来判断因果关系的.4亚复杂动力系统因果关系挖掘算法及分析本节将描述具体的挖掘算法,并解决第2节的第二个难点,即含噪声数据的因果挖掘.其中朴素算法只通过一次扰动来判断因果关系,而抗噪算法可通过多次回归和扰动来逐步排除虚假因果关系.4.1基于扰动的朴素因果挖掘算法算法如算法1,例6给出了说明.算法1.Nave_Causality_Mining()输入:SCS=〈m,k,T,Em×k〉动力系统时间序列输出:挖掘出的可信因果关系集合Causality_Set1.Causality_Set=null;//初始为空2.Foreachxiinm3.target=xi(t);4.variables=Em×k-xi(t);5.fxi(t)=Generate_Function(target,variables);6.Foreachxj(t)~xj(t-k)invariables7.Calculateδfxi(t)(xj,δ);8.Ifδfxi(t)(xj,δ)don’tsatisfyLemma29.Causality_Set=Causality_Set-〈xj→xi〉;10.EndIf11.EndFor12.EndFor13.ReturnCausality_Set();(1)第5行,Generate_Function(target,variables)表示以target为因变量,以variables为自变量进行基于GEP的函数拟合,得到函数fxi(t);(2)第6行,表示依次对fxi(t)自变量集合variables中的每个要素进行扰动.由于系统的时滞为k,故对每个要素xj所有时间序列上的值xj(t)~xj(t-k)都进行扰动;(3)第7~10行,基于扰动计算出波动δfxi(t)(xj,δ)(第7行),然后根据波动大小进行因果判断(8~10行).例6.考虑例1中的动力系统,分析影响Wind的要素.考虑图5及表3,通过朴素因果挖掘算法来分析影响Wind的要素只需一次函数拟合,而自变量是所有其他要素.表3中自变量,因变量及扰动,波动的含义见定义2,如表3第2行扰动为Temp+(-3),表示对自变量Temp时间序列实施的扰动为Temp=Temp+(-3).参考值表示由自变量拟合出的关于因变量的函数在整个时间序列上的最大值与最小值差值的平方.然后根据定理2来排除虚假因果关系.可以看到,假设C=10,那么表3第1行的因果关系就可以直接被定理2排除,因为波动C×T×参考值.而2,3行的因果关系不能被定理2排除,所以算法1的挖掘结果为{Temp→Wind,NO2→Wind}.1Car,Temp,NO2WindCar+(-6)Infinity379742Car,Temp,NO2WindTemp+(-3)79099379743Car,Temp,NO2WindNO2+(-3)15909379744Temp,NO2WindTemp+(-3)6574379745Temp,NO2WindNO2+(-3)939678379746TempWindTemp+(-3)3332379744.2基于扰动的抗噪因果挖掘算法如例6所示,在朴素算法的挖掘过程中,表3的Page8第1行已经判断出Car不是Wind的原因,但在表3的2、3行中仍然采用含有自变量Car的拟合函数来分析Temp和NO2对Wind的影响,这显然是不合理的,因为没有去掉噪声Car,下面的抗噪因果挖掘算法旨在解决上述问题.算法2.Noise_Robust_Causality_Mining().输入:SCS=〈m,k,T,Em×k〉动力时间序列数据输出:挖掘出的可信因果关系集合Causality_Set1.Causality_Set=null;//初始为空2.Completeness=false;//因果关系集合的完备性验3.Foreachxiinm4.target=xi(t);5.variables=Em×k-xi(t);6.variables=Clear_Noise(target,variables);7.If(variables≠null)8.Foreachxj(t)~xj(t-k)invariables9.Causality_Set=Causality_Set+〈xj→xi〉;10.EndFor11.EndIf12.EndFor13.If(variables≠null)14.Completeness=Judge_Trustiness(target,variables);15.EndIf16.ReturnCausality_Set();过程1.Clear_Noise(target,variables).输入:因变量target,自变量集合variables输出:降噪后的自变量集合1.fxi(t)=Generate_Function(target,variables);2.While(variables≠null)Do3.Foreachxj(t)~xj(t-k)invariables4.Calculateδfxi(t)(xj,δ);5.If!(δfxi(t)(xj,δ)satisfycausalityscenario)6.variables=variables-{xj(t)~xj(t-k)};7.EndIf8.EndFor9.If(variablesischanged)and(variables≠null)10.fxi(t)=Generate_Function(target,variables);11.EndIf12.Elsebreak;13.EndWhile14.Returnvariables;过程2.Judge_Trustiness(target,variables).输入:经过Clear_Noise进行降噪后的自变量集合输出:因果关系集合的完备性验证结果1.fxi(t)=Generate_Function(target,variables);2.Calculateδfxi(t)(variables,δ);//对自变量集合variables中的所有变量同时进行//扰动,并计算相应拟合函数的波动3.If(δfxi(t)(variables,δ)satisfycausalityscenario)//如果对所有变量同时进行扰动时,拟合函数相应//波动幅度仍然在因果判断准则所规定的范围内,//则说明算法所挖掘出的结果是可信的4.Returntrue;5.Else6.Returnfalse;7.EndIf(1)算法Noise_Robust_Causality_Mining()的核心是第6行降噪函数Clear_Noise以及第14行的结果完备性判断函数Judge_Trustiness,函数Clear_Noise主要是循环去掉variables集合中所有不是因变量的原因的要素,函数Judge_Trustiness主要是进一步判断算法挖掘出的因果关系集合的可信性,如果函数的返回值为真,那么在很大程度上算法挖掘出的因果关系集合是可信的.(2)函数Clear_Noise(target,variables).第1行Generate_Function(target,variables)表示以target(即xi)为因变量,以variables为自变量进行基于GEP的函数拟合,得到函数fxi(t).第5行基于因果判断准则将variables集合中不是xi原因的要素xj去掉,整个过程循环进行,直到variables集合为空或不发生变化.(3)函数Judge_Trustines(target,variables)的核心是2,3行,其含义是对自变量集合variables中的所有变量同时进行扰动并计算相应拟合函数的波动,如果在对自变量集合variables中的所有变量同时进行扰动的情况下,拟合函数的相应波动幅度仍然在因果判断准则所规定的范围内,则说明算法所挖掘出的结果是可信的,否则是不可信的.因为现实中的系统在其要素都发生适当扰动时通常是能够保持一定的稳定性的,如果拟合函数在其自变量同时发生扰动后也具有较强的稳定性,则可以进一步说明拟合函数能够较好地符合现实中动力系统的性质,进一步证实结果的可信性.下面通过例7和例8来举例说明算法2的运行过程,其中函数Clear_Noise的运行过程通过例7说明,函数Judge_Trustiness的运行过程通过例8说明.例7.考虑图5及表3,背景和术语与例6相同.(1)根据算法2的3~5行,执行图5中的1~3步(对应表3的1~3行),此时variables={Car,Temp,NO2};(2)当发现Car不是Wind的原因时(表3第1行),将Car从variables中删掉,即此时variables={Temp,NO2},然后重新进行函数拟合,Page9并重新扰动Temp,NO2,如图5第4,5步(表3第4,5行);(3)此时发现NO2也不是Wind的原因(表3第5行),故继续将NO2从variables中删掉,即此时variables={Temp},又重新进行函数拟合并重新扰动Temp,如图5第6步(表3第6行)所示.因为3332<10×37974,故NO2是Wind的原因.例8.考虑表4,背景和术语与例6相同.表4的目标是判断算法2的挖掘结果是否可信.通过表4可以看到,当以要素Car,Temp为自变量,以要素NO2为因变量进行函数拟合后,分别单独对自变量Car(扰动结果如表4第1行)和自变量Temp(扰动结果如表4第2行)进行扰动时,其波动的幅度符合因果判断准则的范围(即6459<10×1439,64<10×1439),故算法2认为Car,Temp都是NO2的原因.而通过Judge_Trustines同时对Car,Temp进行扰动,得到拟合函数波动的幅度仍然近似符合因果判断准则的范围,因为118与10×11=110的数值相差很小,则函数Judge_Trustines认为{Car→NO2,Temp→NO2}是可信的因果关系.自变量因变量1Car,TempNO2Car+(-6)645914392Car,TempNO2Temp+(-3)6414393Car,TempNO2Car+(-3),Temp+(-3)118114.3算法分析4.3.1GEP生成拟合函数的一致性算法1,2都要先采用GEP生成时间序列的拟合函数,而同一组数据可拟合出多个函数.由于算法1,2都只基于其中一个拟合函数进行扰动,本节将用定理3证明只要拟合函数达到足够高的精度,那么无论选取哪一个函数进行扰动,算法的挖掘结果是相同的.为了证明定理3,需要有下面合理的假设2.假设2.当拟合精度足够高时,拟合函数的值和原函数的值相差很小有|f0(x)-f1(x)|<ε.定理3.设有亚复杂动力系统SCS=〈m,k,T,Em×k〉,有任意两个要素x,y∈m,x是随机时间序列,y是受x影响的因变量,设y=f0(x)是x,y真正符合的函数,y=f1(x)是采用GEP生成的任意拟合函数,则当拟合精度足够高时,有(1)|f0(x)|≈|f1(x)|,f0(x),f1(x)分别是(2)如果∑f0(x,δx,t)<C×T×|Max(f0(x))-Min(f0(x))|2,那么∑f1(x,δx,t)<C×T×f0(x),f1(x)的导数.|Max(f1(x))-Min(f1(x))|2,δx是x时间序列的平均值.证明.见附录1.4.3.2算法的完备性讨论算法1,2都是采用排除法,去掉非因果关系,则剩下的关系就是挖掘结果,下面对排除法的完备性作简单讨论.排除法指出如果X,Y的时间序列数据关系符合定理2,则X,Y不具有因果关系,但排除法只能排除具备定理2中数据性质的非因果关系,不能排除具备其他类型数据性质的非因果关系.故排除法是不完备的,即算法去掉的都是非因果关系,但并不是所有的非因果关系算法都能排除.但本文所提出算法2的Judge_Trustiness函数对挖掘出的因果关系集合的可信度进行了进一步的判断,因为该函数提出一个很强的扰动和波动规则,即当所有自变量同时发生扰动时,如果拟合函数的波动范围仍然在规定范围内,算法才认定所挖掘出的因果关系集合可信,所以函数Judge_Trustiness的使用提高了算法的完备性.在社会,经济以及自然科学中对因果关系的大量研究说明,如果动力系统中两个要素X,Y不具备因果关系,那么在很大程度上X,Y所体现出的数据关系都是符合定理2的.比如,文献[24]就指出两个时间序列如果呈现出相似性,那么这两个时间序列就可能含有因果关系.显然,本文所提出的相似性要求更强,因为本文认为除了两个时间序列本身呈现出相似性或可回归性外,并且在微扰作用下两个时间序列的变化规律也呈现出相似性.这就说明了定理2中的排除法能够排除大部分非因果关系,故定理2是具备一定的普适性和完备性的.4.3.3算法复杂度分析从算法1,2可知,算法的时间主要消耗在用GEP进行函数拟合的过程中,如果以GEP函数拟合一次作为单位时间,则有下面的算法时间复杂度.设有动力系统的时间序列数据SCS=〈m,k,T,Em×k〉,则(1)朴素因果挖掘算法的时间复杂度为O(|m|),因为对m中的每个要素,算法只进行一次GEP拟合.(2)抗噪因果挖掘算法的时间复杂度为O(|m|2),首先来分析最坏情况下所需的降噪次数,因为对m中的每个要素xi,算法在最坏情况下需要对m中除xi外的其他的|m|-1个要素依次降噪,故需进行|m|-1次GEP拟合,则对m中的所有要素共需进Page10行|m|×|m-1|次GEP拟合.但在最好情况下的降噪次数为0,即进行GEP拟合的次数与朴素算法相同为|m|次.我们认为需要|m|次与需要|m|×|m-1|次情况出现的概率相同,则抗噪算法平均需要的GEP拟合次数为(|m|×1+|m|×2+…+|m|×|m-1|)/(|m|-1)=|m|2/2,故抗噪算法的平均时间复杂度仍为O(|m|2).5实验和性能分析实验数据包括1组合成数据和3组真实数据.数据量分别为100,200,100和5000,都是亚复杂动力系统若干要素组成的时间序列,分别采用朴素和抗噪因果挖掘算法挖掘,及可信度判断函数来验证最终结果的可信性.所有实验的实验过程如图6所示.本节中表6、10、14的背景和术语与例6相同,C=10.并且ε-拟合函数中ε的平均值小于0.1.同时,我们选择了两种现有的因果分析技术,包括格兰杰因果分析和基于转移熵的因果分析,来与本文的因果分析结果进行对比.这两种方法都能够进行两个时间序列的因果方向分析,当实验数据集中的要素个数大于两个时,实验结果列出了要素集合两两组合的因果分析结果.5.1在合成数据上进行的实验构造了如式()的一个动力系统,存在3个要素x,y,u,该系统时间序列数据的形式化描述为SCS=〈m,k,T,Em×k〉,m={x,y,u},k=1,T=100,Em×k={x(t),x(t-1),y(t),y(t-1),u(t),u(t-1)}.数据按如下方式生成:(1)令x(0)=0.5,y(0)=0.5,u(t)是0和0.5之间的随机时间序列;(2)将x(t-1),y(t-1),u(t)的值代入式()迭代运行100次,得到含有100个数据的时间序列.u(t)=Random(0,1)×0.5烄x(t)=f=u(t)×(x(t-1)+1/(x(t-1)+烅y(t-1)+u(t)))y(t)=g=x(t-1)/(x(t-1)+y(t-1)+u(t烆该系统共6个候选因果关系{u→x,u→y,x→y,x→u,y→x,y→u}.表5给出了如何通过算法1,2以及可信度验证函数来判断和验证该系统的因果关系.表5中算法1和2得出判断结论的实验数据见表6的1~6行.表5中可信度验证函数得出判断结论的实验数据见表6的7,8行.其中,表5的第6列“依据”表示通过了表6中的哪几行得到.如第1行“1,x→u,假,—,—,2”表示因果关系x→u通过算法1判断为假,该结论通过表6第2行得到.候选因果关系算法1算法2可信度验证依据1x→u假—2y→u假—3x→y真真真3,4,74u→y真真真3,4,75y→x真真真5,6,86u→x真真真5,6,8自变量因变量扰动波动参考值1x,yuy+0.5Infinity162xux+0.5Infinity163x,uyu+0.553154x,uyx+0.562155y,uxu+0.525156y,uxy+0.559157x,uyx+0.5,u+0.557668y,uxy+0.5,u+0.5191.7在表5的1,2行中,因算法1已经判断出x→u,y→u是虚假因果关系,故不需要继续使用算法2和可信度验证函数来进一步判断.而表5的3~6行中,算法1,2判断的结果均为真,故需使用可信度验证函数来进一步判断.最终发现的因果关系为{x→y,y→x,u→y,u→x},可见所有正确的因果关系都能被挖掘出来.表7给出采用格兰杰方法对x,y,u三个要素两两进行因果分析的结果,原假设表示要素1不是要素2的原因,当p值小于0.05时拒绝原假设.格兰杰因果分析时两个时间序列时滞为1个时间单位.格兰杰方法发现的因果关系包括{x→y,y→x,u→y},格兰杰方法未发现的因果关系包括{u→x}.Page11表8给出了采用转移熵指标(TransferEntropy,TE)对x,y,u三个要素两两进行因果分析的结果,如TE(x,y)=1.1185,两个时间序列的时滞为1个时间单位.对任意两个要素a,b,我们认为当TE(a,b)>0.5或TE(a,b)/TE(b,a)>5时,表示a→b,即a是b的原因,其他基于转移熵的实验仍然以此为因果判定标准.转移熵指标发现的因果关系包括{x→y,y→x,u→y},转移熵指标未发现的因果关系包括{u→x}.两种已有方法均未能发现因果关系u→x.转移熵(TE)变量x变量y变量u变量x变量y0.5395变量u0.00831.15725.2在真实数据上进行的实验5.2.1box-jenkins数据这组数据来自文献[28],是由box-jenkins在进行时间序列的分析时提出的,包含两个要素,即一个火炉中输入天然气流量Gas的时间序列和天然气燃烧后得到的CO2浓度的时间序列,共200组数据.显然这是一个动力系统,并且有因果关系Gas→CO2,数据的形式化定义为SCS=〈m,k,T,Em×k〉,m={Gas,CO2},k=5,T=200,Em×k={Gas(t),Gas(t-1),Gas(t-2),Gas(t-3),Gas(t-4),Gas(t-5),CO2(t),CO2(t-1),CO2(t-2),CO2(t-3),CO2(t-4),CO2(t-5)}.可知,该系统只有2个候选因果关系{Gas→CO2,CO2→Gas},表9给出了如何通过算法1,2以及可信度验证函数来判断和验证该系统的因果关系.表9的第6列“依据”表示通过了表10中的哪几行得到.如第1行“1,Gas→CO2,真,—,—,1,2”表示因果关系Gas→CO2通过算法1直接判断为真,该结论通过表10中1,2行得到.在表9第1行中,因系统只包含一个原因要素和一个结果要素,不存在噪声数据,故不需要使用算法2去噪,也不需使用可信度判断函数来判断结果可信性.而在表9第2行中,由于算法1已经判断出CO2→Gas是虚假的因果关系,故不需要继续使用算法2和可信度验证函数来进一步判断.很明显,算法1的结论是正确的,因为Gas燃烧是产生CO2的原因.1Gas→CO2真——1,22CO2→Gas假——3,4自变量因变量扰动波动参考值1GasCO2Gas+0.219425565452GasCO2Gas+(-0.2)3735565453CO2GasCO2+5079621994CO2GasCO2+(-50)Infinity2199表11给出了格兰杰方法的分析结果,两个时间序列的时滞为5个时间单位,当p值小于0.05时拒绝原假设.可以看到,格兰杰方法能够发现因果关系Gas→CO2.表12给出了转移熵指标的分析结果,两个时间序列的时滞为5个时间单位.可以看到,转移熵指标能够发现因果关系Gas→CO2.转移熵(TE)变量Gas变量CO25.2.2空气污染数据数据来自于http://lib.stat.cmu.edu/datasets/NO2.dat,例1对其进行了说明,原始数据是包含8个要素的动力系统时间序列,但其中有4个要素与整个系统关系很小,故在数据预处理时将其去掉了.为了保证时间单位一致,每一天只保留一个数据,共100组的数据.形式化描述为SCS=〈m,k,T,Em×k〉,m={Car,Temp,NO2,Wind},k=1,T=100,Em×k={Car(t),Car(t-1),Temp(t),Temp(t-1),NO2(t),NO2(t-1),Wind(t),Wind(t-1)}.可知,该系统共有12个候选因果关系{Car→NO2,Temp→NO2,Car→NO2,Car→Temp,NO2→Temp,Wind→Temp,Car→Wind,NO2→Wind,Temp→Wind,NO2→Car,Temp→Car,Wind→Page12Car}.表13给出了如何通过算法1,2以及可信度验证函数来判断和验证该系统的因果关系.表13中算法1和2得出判断结论的实验数据见表14的1~14行.表13中可信度验证函数得出判断结论的实验数据见表14的15行.其中,表13的第6列“依据”表示通过了表14中的哪几行得到的表13中的结论.如第1行“1,C→N,真,真,真,4,5,15”表示因果关系C→N通过算法1,2及可信度验证都被判断为真实的,判断过程通过表14中的4,5,15行得到.第3,6,12行表示在进行GEP函数拟合时,箭头左边的自变量无法出现在拟合函数中,所以也就自动的被判断为虚假因果关系.为节省篇幅将表13、表14中Car,Temp,NO2,Wind分别缩写为C,T,N,W.候选因果关系算法1算法2可信度验证依据1C→N真真真4,5,152T→N真真真4,5,153W→N———4C→T真假—13,145N→T假——126W→T———7T→W真真真7,9,118N→W真假—8,109C→W假——610N→C假——111T→C真假—2,312W→C———自变量因变量扰动1N,TCN+(-3)Infinity49122N,TCT+(-3)11749123TCT+(-3)761039449124C,TNC+(-6)645914395C,TNT+(-3)6414396C,T,NWC+(-6)Infinity379747C,T,NWT+(-3)79099379748C,T,NWN+(-3)15909379749T,NWT+(-3)65743797410T,NWN+(-3)9396783797411TWT+(-3)33323797412C,W,NTN+(-3)9430016313C,W,NTC+(-6)8.716314C,WTC+(-6)621516315C,TNC+(-3),T+(-3)11811在表13的5,9,10行中,由于算法1已经判断出这些关系是虚假的因果关系,故不需要继续使用算法2和可信度验证函数来进一步判断.在表13的4,8,11行中,算法1判断出的结果为真,而算法2判断出的结果为假,则又将排除这几行中的因果关系,而不需要继续使用可信度验证函数来进一步判断.表8的1,2,7行中,算法1,2判断出的结果均为真,需要继续用可信度验证函数验证.验证过程由表14的15行表示.可以看到,当同时对Car和Temp产生-3的扰动时,NO2的波动幅度仍然近似符合因果准则,即虽然118>10×11=110,但是118与110实际上很接近,故仍然说明Car→NO2,Temp→NO2的因果关系是可信的.最终得到的因果关系为{Car→NO2,Temp→NO2,Temp→Wind},由于大气中NO2的一个重要来源是汽车排放,光化学烟雾的产生就有NO2的参与,所以第1个因果关系是符合实际情况的.对第2个因果关系,文献[29]证实了随大气温度的上升,NO2浓度有上升趋势.对第3个因果关系,因为温度的变化会导致空气的流动从而产生风,该因果关系也是符合实际情况的.表15给出了采用格兰杰方法对该数据集进行两两因果分析的结果,其中原假设表示要素1不是要素2的原因,当p值小于0.05时拒绝原假设.格兰杰因果分析两个时间序列的时滞为5个时间单位.格兰杰方法发现的因果关系只有{NO2→Car},显然这不符合实际情况,因为公路上的车流量不会受到NO2浓度的影响,而主要和是否为上下班高峰期有关.其他几个因果关系格兰杰方法都未能发现.TEMP不是WIND的原因表16给出采用转移熵(TransferEntropy,TE)对数据两两因果分析的结果,两个时间序列时滞为5个时间单位.转移熵指标未能发现任何因果关系.转移熵(TE)变量NO2变量car变量temp变量wind变量NO2变量car0.2700变量temp0.34340.4006变量wind0.32840.39730.3003Page135.2.3睡眠窒息症病人数据实验旨在验证算法在不同数据规模上的效率和结果的一致性.数据来自文献[30],取B2.dat中前5000条记录,对数据进行了0均值和单位方差正规化.该数据包含两个要素,分别是患有睡眠窒息症的病人的心率(HeartRate,HR)和呼吸率(BreathRate,BR)的时间序列数据,形式化描述为SCS=〈m,k,T,Em×k〉,m={HR,BR},k=2,T=5000,Em×k={HR(t),HR(t-1),HR(t-2),BR(t),BR(t-1),BR(t-2)}.图7~图9给出了实验结果,从中可得出以下结论.(1)GEP对不同规模的数据均能拟合出适应度很高的函数.图7是当记录数从1000~5000时,分别以HR和BR为因变量,以另一要素为自变量进行函数拟合,得到的平均适应度与最优适应度的比值.可知在不同规模下,GEP均能达到很高适应度,这肯定了算法基于GEP进行函数拟合的可用性.(2)算法的挖掘结果对不同规模的数据具有一致性.图8、图9表示记录数从1000条逐步增加到5000条时,分别对以HR和BR为因变量的拟合函数进行扰动后得到的因变量的波动值以及相应的参考值,参考值表示由自变量拟合出的关于因变量的函数在整个时间序列上的最大函数值与最小函数值差值的平方.从图8可知,当以HR(t)为因变量时,均有波动值小于参考值.而在图9中由于每次实验得到的波动值都趋近于无穷大,故只有参考值随记录数增大的变化曲线,当以BR(t)为因变量时,均有波动值参考值,由定理2排除因果关系HR→BR.故各种数据规模下算法均可得到因果关系BR→HR.由于患有睡眠窒息症病人的呼吸是不正常的,故导致心率变化,故BR影响HR的结论是合理的.6结论及进一步工作实验结果表明对5.1节中的合成数据,本文所提出的方法能够挖掘出所有正确的因果关系(因为数据是合成的,所以正确因果关系就是已知的),而格兰杰因果分析方法和基于转移熵的方法均少发现了一对因果关系.由于5.2.1节中的实验数据只包含两个要素,所以本文的算法和两种对比算法均找出了正确的因果关系.值得指出5.2.2节中的数据是包含4个要素的空气污染数据,本文的算法所发现的3个因果关系的正确性在相关领域有专业的文献支持,或者是目前公认的环境科学的一些结论.而格兰杰因果分析方法只得到了一个因果关系,并且能够易知是不符合实际情况的,转移熵方法则未能找出该数据集中的任何因果关系.综上,本文提出的算法能够正确地挖掘出亚复杂动力系统各要素间的因果关系,特别是当系统要素大于两个时,本文的方法仍然能够得到正确的结论,而概率方法则不行.从实验分析中可以看出本文算法在以下几个方面具有较好的应用效果:首先,算法可以应用于气象复杂系统的因果分析中,5.2.2节只是对简单的气象要素进行了因果分析,还可以进一步对复杂气象要素间的因果关系进行分析,比如气象要素间的遥相关分析,气象极值要素之间的因果分析等.其次,由于生物体本身也是一个复杂系统,故算法还可以Page14对生物信号进行因果分析,5.2.3节对人体体征要素的时间序列进行了因果分析,还可对人体蛋白质序列,脑电波序列等各种生物信号要素进行分析.下一步工作主要是进一步提高抗噪算法对噪声要素的识别精度以及将因果分析结论运用到亚复杂动力系统的干预分析中.
