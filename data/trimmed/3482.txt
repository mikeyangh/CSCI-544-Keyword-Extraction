Page1一种障碍空间中的反犽最近邻查询方法于晓楠谷峪张天成于戈(东北大学信息科学与工程学院沈阳110819)(医学影像计算教育部重点实验室(东北大学)沈阳110819)摘要随着基于位置的服务(LBS)和物联网的快速发展,空间查询技术越来越重要,而空间查询中的最近邻查询及其各种变体有着广泛的应用.近几年,已有较多对于查询前k个反最近邻对象(RkNN)的研究,其中大部分针对的都是理想欧氏空间.而在真实的情况下,反k最近邻查询通常受障碍物影响.文中研究了障碍空间中反k最近邻查询算法,提出了一种基于障碍Voronoi图的高效的剪枝方法.根据Voronoi图和障碍距离的特性,大幅度减少了数据点处理个数.最后,作者使用真实的数据集和多种方式分布的模拟数据,验证了算法的高效性和准确性.关键词空间查询;反k最近邻(RkNN);障碍空间;Voronoi图1引言近年来,物联网和基于位置的服务[1]获得了越来越多的关注.空间查询作为重要的支撑技术,涉Page2泛的应用①.k最近邻查询反映了查询点受到哪些空间数据点影响较大,而反k最近邻查询则反映了查询点对哪些空间数据点影响较大.此外,现有的空间查询工作大多考虑理想的欧式空间和路网空间.然而,地面或室内移动的物体一般都会受到地理条件的限制(例如建筑、湖泊等),之间的最短距离必须考虑障碍物的因素.例如,在灾区医疗和餐饮安置点通过对其它居住安置点的反k近邻查询,来获取合理的资源配置,由于其它废弃形成的障碍,需要考虑障碍空间内的反k近邻查询方法.有关无障碍空间和路网上的kNN和RkNN查询以及障碍空间的kNN查询,都已经有较多的研究工作.对于无障碍空间的kNN查询,近年来广泛使用的是基于Voronoi图处理的技术.Sharifzadeh等人[9]给出了结合Voronoi图和R-tree的索引结构的方法,能够进行高效的kNN查询.无障碍空间中的RkNN查询是获取那些k近邻里面有查询点q的空间数据点.对于无障碍空间RkNN查询,文献[7-8,10]提出了无需预计算的RkNN查询方法.Stanoi等人[7]给出了在查询点q处将空间划分成六等份(每份为60°)的方法,可以证明在每一个区域离查询点q的第k个最近临的点以外的区域都可以被剪枝,得到这些未被剪枝的区域里的数据点就成为RkNN查询的候选点.Tao等人[8]提出了使用中垂线性质剪枝搜索空间的方法,有效的剪枝那些处在k个以上中垂线的半区间的数据点.Wu等人[10]提出一种新的剪枝方法———FINCH算法,该方法并未使用文献[8]提出的中垂线,而是使用一个多边形近似未被剪枝区域.文献[11]提出了使用Voronoi图的方法解决无障碍的RkNN查询方法.路网上的kNN查询也有相关研究,文献[12]使用基于Voronoi图的方法查询路网上的k最近邻.尽管这些方法能高效地执行kNN和RkNN查询,但它们都是在理想的欧氏空间即无障碍物空间中查询,而在现实场景中这种假设是不合理的.对于障碍空间中的查询,目前主要集中在kNN查询的研究.障碍空间中,kNN查询是获取在障碍距离上k个距离查询点q最近的空间数据点.Zhang等人[13]给出了在障碍空间中基于R-tree方法解决常见的空间查询,例如,范围查询、最近邻查询、e-距离连接查询、最近对查询.Xia等人[14]提出了障碍最近邻查询(ONN查询)方法,用增量的方式处理只与查询有关的数据点和障碍物,因此文献[14]过滤掉了大量数据点和障碍物.Gao等人[15]通过有效地分割对象行进的路径,提出了障碍空间内连续kNN查询的优化方法.但是在障碍空间中,现有的空间查询仅仅局限于上述以kNN查询为主的几种查询上,并没有涉及RkNN查询.因此在障碍空间中,如何查询反kNN对象是如今亟待解决的问题.本文给出一种基于障碍Voronoi图的高效搜索反kNN对象的方法.通过剪枝的方法,减少查询处理反kNN的代价.我们结合了划分空间六等份、障碍Voronoi图的性质等方法和R-tree索引结构,由Voronoi邻居增量地得到反kNN查询结果.本文的主要贡献如下:(1)我们形式化定义了障碍反kNN查询,在障碍空间中添加了一种新的查询.(2)我们将空间划分成六等份的方法用于障碍空间,并将此方法加以改进.(3)利用障碍Voronoi图的性质,我们设计了几种剪枝策略,基于过滤和求精的思想,大幅度地减少搜索障碍反kNN对象的时间和空间.(4)我们通过实验验证了本文提出的算法在时间和空间上的优越性.本文第2节形式化定义障碍空间反kNN查询,并给出相关定义;第3节详细描述提出的障碍空间中反kNN查询的高效处理方法,提出几种剪枝和求精的方法;第4节给出实验结果和数据分析;最后,第5节总结.2问题定义在给定的空间中存在着数据点和障碍物,设数据点集合为P={p1,p2,…,pn},障碍物集合为O={O1,O2,…,Om}以及一个查询点q.为了不失一般性,本文假设障碍物为线段形状,且障碍物不相交于数据点,即O={O1,O2,…,Om|Oi=Oi1Oi2,Oi1Oi2∩pj≠,i∈[1,m],j∈[1,n]}.查询点和数据点之间可能存在着障碍物,因此数据点移动到障碍物时,不能穿过障碍物,需要绕着障碍物移动,如图1所示.数据点p1和查询点q之间无障碍物,但是数据点p2和q之间有障碍物O1,所以p2移动到q需要绕过障碍物O1,可以经由p2→O11→q路径到达q或者经p2→O12→q到达q.由此可知在障碍空间中的两点之间的距离有可能需要绕①LvYing.Thekeytechnologiesresearchonkeywordsearchinthemobileenvironment(吕瑛:移动环境中关键词搜索的Page3过障碍物计算,下面给出障碍距离的定义.定义1.障碍距离.在有障碍物的空间中,欧氏距离记为deuc,若两点p和q之间无障碍物,则障碍距离即两点间的欧氏距离,即dobs(p,q)=deuc(p,q);若p和q之间有障碍物Ok,则障碍距离为这两点绕过障碍物的最短距离,即dobs(p,q)=min{deuc(q,Ok1)+deuc(Ok1,p2),由图1可知,|O11p2|=|O11a|,|O12p2|=|O12b|,因此点p2绕过障碍物O1到达点q的路径的长度为|qa|和|qb|,又|qa|<|qb|,因此点p2到查询点q的障碍距离为|qa|.根据数据点之间的障碍距离的定义,下面给出障碍Voronoi图的定义.为了帮助理解障碍Voronoi图,我们先介绍障碍中垂线.定义2.障碍中垂线.在障碍空间中,两点p和q的障碍中垂线上的点到p和q的障碍距离相等,记为lbisobs(p,q)={px|dobs(p,px)=dobs(q,px)}.引理1.障碍中垂线是由直线组成或由射线和曲线段共同组成.证明.当两点之间无障碍物时,障碍中垂线即为欧氏空间的中垂线;当两点之间存在障碍物时,在被障碍物遮挡的区域里的中垂线是双曲线的一部分.如图2所示,点q和p2的障碍中垂线是这样得到的:假设点q和p2无障碍,得到中垂线ln1n5;将q和障碍物的边界连线与直线ln1n5相交于点n2和n4,得到在ln1n5一侧查询点q不能移动到的区域O11n2n4O12;在此区域外,射线ln1n2和ln4n5即为障碍中垂线的一段;在此区域内,取任意一点x,使得x绕过障碍物O11O12到q的欧氏距离等于x到p2的欧氏距离,即|qO12|+|O12x|=|xp2|以及|qO11|+|O11x|=|xp2|,所以点x在以O12、p2为焦点、|qO12|为焦距的双曲线的一支(弧线n3n4)上以及以O11、p2为焦点、|qO11|为焦距的双曲线的一支(弧线n2n3)上.因此,点q和p2的障碍中垂线为由射线n2n1、弧线n2n3、弧线n3n4和射线n4n5组成.n个数据点的无障碍物的空间中,Voronoi图是由n个以数据点为中心的区域组成的,即V(P)={V(p1),V(p2),…,V(pn)},其中每个区域的边界b(pi)是所有到中心点距离最小的点的集合,即V(pi)={(pi,b(pi))|p∈b(pi),deuc(p,pi)deuc(p,pj),j≠i,j∈[1,n]}.结合前文的障碍距离,下面给出在障碍空间中的障碍Voronoi图的定义.定义3.障碍Voronoi图.障碍Voronoi图由n个以数据点为中心的障碍区域组成,即Vobs(P)={Vobs(p1),Vobs(p2),…,Vobs(pn)}.其中每个障碍区域的边界是所有到中心点的障碍距离最小的点的集合,即Vobs(pi)={(pi,bobs(pi))|p∈bobs(pi),dobs(p,pi)dobs(p,pj),j≠i,j∈[1,n]}.定理1.障碍Voronoi图的各个障碍区域V(pi)的边界bobs(pi)在数据点pi与其它各个数据点pj的障碍中垂线上,即p∈bobs(pi),p∈lbisobs(pi,pj),i,j∈[1,n],j≠i.证明.由定义3得到,障碍区域的边界上的点到中心点的障碍距离比到其它数据点的障碍距离小,又由定义2可知,到中心点的障碍距离和到其它数据点的障碍距离相等的点落在障碍中垂线上,因此,障碍区域的边界也落在相应的障碍中垂线上.我们假设障碍空间的数据点集为P={p1,p2,…,p31},障碍物集为O={O11O12,O21O22,O31O32},由定义3可以画出障碍Voronoi图如图3所示,例如障碍区域V(p3)的边界bobs(p3)就是数据点p3与p1,p2,p4,p5,p31,p29的障碍中垂线组成的.首先定义障碍空间中的kNN查询如下.定义4.障碍kNN查询.在障碍空间中,k最近邻查询返回k个距离查询点q最近的数据点,即kNNobs(q,k,P,O)={p∈P|x∈P|dobs(p,q)dobs(p,x)|<k}.如果多个数据点有相同的距查询点q第k个远的距离,那么这些点也都包含在kNN查询结果集中.Page4例如,图3中查询点q的障碍2NN为2NNobs(q,2,P,O)={p13,p7}.定义5.障碍RkNN查询.在障碍空间中,在数据集P中获取那些k个最近邻中包含查询点q的空间数据点,即RkNNobs(q,k,P,O)={p∈P|q∈kNNobs(p,k,P,O)}.例如,图3中查询点q的障碍R2NN为R2NN(q)obs(q,2,P,O)={p13,p17,p22}.3障碍R犽NN查询在本节中,我们给出在障碍空间中对于一个查询点q的RkNN查询算法.3.1约减数据集下面给出约减候选集的剪枝算法.引理2.只有到查询点q经过的最少数据点个数小于或等于k的那些对象才能放入候选集.证明.假设numOfObj(p,q)为对象p到查询点q需要经过最少的数据点的个数.当k=1时,即查询q的RNN,而那些能成为q的RNN的数据点p一定是q的Voronoi邻居的,即点p满足numOfObj(p,q)1;当k1时,假设numOfObj(pi,q)i,0ik,那么numOfObj(pk+1,q)k+1.又由Voronoi图的定义可以得到,pk+1是pi∈{p1,…,pk}的一个Voronoi邻居.因此,可以得到numOfObj(pk+1,q)max(numOfObj(p,pi))+1k+1,引理2得证.如图4所示,空间数据点集为{p1,p2,…,p6},障碍物集为{O11O12},查询点为q,数据点p5不能放入候选集,因为p5需要最少经过3个数据点到q,即p5→p3→p1→q;同理,数据点p4,p6也都不能放入候选集中;因此,此区域的候选集为阴影区域Scnd(0)={p3,p2,p1}.GD(P,q,k)方法:由引理2,取到查询点q的点满足经过不大于k个的数据点.如算法1所描述,首先构造一个最小堆,存放将要计算的数据点及其到查询点的距离.由VN(q)求出查询点q的邻居集合,计算这些邻居点到q点的障碍距离,再将这些邻居点放入最小堆.对于每次从堆中取出的元素e,若它到q点的经过的数据点个数不大于k,就将其加入候选集Scnd中;再求出元素e的邻居集合,若这些邻居没被访问过的话,将其numOfObject加1,放入最小堆和Visited集合中.算法1.GD(P,q,k).输入:查询点q,查询对象集P,RkNN查询的k值输出:约减的对象候选集Scnd1.MinheapH={};Visited={};2.ForeachpointpinVN(q)Do3.Add(p,1)intoH;addpintoVisited;4.WhileH≠Do5.Deheapanentrye;6.IfnumOfObj(e,q)kthen7.Add(e,dobs(e,q))intoScnd;8.ForeachpointpinVN(e)Do9.IfpVisitedthen10.numOfObj(p,q)=numOfObj(e,q)+1;11.add(p,numOfObj(p,q))intoH;12.addpintoVisted;13.ReturnScnd;引理3.对象p与查询点q之间经过若干对象如pi,连接p与pi,若无障碍物,则计数countNonObs(p,q)增加1.如果countNonObs(p,q)k,则对象p被剪枝.证明.对象p与pi之间若无障碍物,说明点p到pi一定比到查询点q的欧氏距离近,若p到q之Page5间存在障碍物,那么p到pi的障碍距离也一定比到q的近.当k=1时,这样的pi就有可能是p的NN,而q一定不能是p的NN;若k≠1时,只要这样的pi有不小于k个,那么p的kNN一定不能包含查询点q,即countNonObs(p,q)k时,p一定不是候选集里的对象.如图5所示,由于数据点p3与查询点q之间经过p2和p1对象,而且p3p1无障碍物,p3p2也无障碍物,所以p3的2NN一定不包含点q,因此点p3被移除候选集,候选集约减为阴影区域Scnd(0)={p1,p2}.CheckNumOfObs(Scnd(i),q,O,k)方法:由引理3查看候选集里的每一个对象p与它到的查询点q,若p与它经过的对象之间有k个以上无障碍物的对象,则p被剪枝.如算法2所示,对于候选集中的每个对象p,以p为圆心,|pq|为半径做圆R(p),若在此候选集中的对象e也在这个圆里,就考查p与e之间是否存在障碍物,若对于一个p,有多于k个无障碍物,则p就从候选集中去除.算法2.CheckNumOfObs(Scnd(i),q,O,k).输入:候选集Scnd(i),查询点q,障碍物集O,RkNN查输出:约减的对象候选集Scnd(i)1.count=0;2.ForeachpointpinScnd(i)Do3.ForeachpointeinR(p)∩Scnd(i)Do4.IfNonObs(p,e)==truethen5.count++;6.Ifcountkthen7.Scnd(i)=Scnd(i)-p;8.ReturnScnd(i);引理4.若候选集中的点p的Voronoi邻居都被剪枝了,则此点p也被剪枝.证明.假设在候选集中取一点为p,且点p的Voronoi邻居(如v)都被剪枝.由Voronoi图的性质知,p到q一定经过p的Voronoi邻居(如v),而countNonObs(v,q)k,从而得到countNonObs(p,q)k+1>k,由引理3知,点p被剪枝.PruneByNeighbor(Scnd(i),q)方法.由引理4对候选集对象进一步剪枝,如算法3描述,设置布尔变量nonPruneFlag为false来标记此对象是需要被剪枝的.对于候选集中每个对象(如p)的每个邻居,若都被剪枝,则此对象p也被剪枝.算法3.PruneByNeighbor(Scnd(i),q).输入:候选集Scnd(i),查询点q输出:约减的对象候选集Scnd(i)1.nonPruneFlag==false;2.ForeachpointpinScnd(i)Do3.Foreachpointe∈VN(p)Do4.Ife∈Scnd(i)then5.nonPruneFlag==true;6.IfnonPruneFlag==falsethen7.Scnd(i)=Scnd(i)-p;8.ReturnScnd(i);3.2障碍R犽NN查询下面介绍在障碍空间中,给出查询点q,数据点集P,障碍物集为O的RkNN查询.算法4描述了障碍空间的RkNN查询的过程.算法4.RkNNobs(q,k,P,O).输入:q:查询点输出:RkNN查询的结果Scnd1.For1i6DoScnd(i)=;Scnd=;2.SixRegionPartition(P,O);3.DrawVG(P,O);4.ForeachScnd(i)Do5.Scnd(i)=GD(P,q,k);6.Scnd(i)=CheckNumOfObs(Scnd(i),q,O,k);7.PruneByNeighbor(Scnd(i),q);8.ForeachpointpinScnd(i)Do9.pk=k-thNNofp;10.Ifdobs(p,q)>dobs(p,pk)Then11.Scnd(i)=Scnd-p;12.Scnd=Scnd∪Scnd(i);13.ReturnScnd;首先将空间划分成6等份区域,再由空间的数据点和障碍物画障碍Voronoi图;对于6个等份的每个区域中,进行数据约减:只取那些到查询点q经过数据点个数不大于k的数据点放入候选集(算法1的GD(P,q,k)),再查看候选集中的点p与它到q之前的所有点之间,若有不少于k个点无障碍物,则这样的点p就从候选集中去除(算法2Page6的CheckNumOfObs(Scnd(i),q,O,k)),若候选集中存在点p,它的所有Voronoi邻居都被移除候选集,则此点p也被移除候选集(算法3的PruneBy-Neighbor(Scnd(i),q));最后,对候选集中的每个对象p,计算p的第k个近邻点pk,若查询点q到p的障碍距离dobs(p,q)大于pk到q的障碍距离dobs(p,pk),则q的RkNNs里没有点p,因此从候选集中移除点p.最后,把6个区域的候选集合并起来,即为图6障碍RkNN查询(k=2)将空间分成6等份;在每一等份中分别对候选集进行约减,首先由算法1选择那些到查询点q经过的数据点个数不大于k的对象点,如region(0)里的p3,p4,p5,它们到q需要至少经过3个数据点,因此被剪枝掉,得到图6中非空白区域中的对象构成候选集;接着由算法2去除那些到此对象之前的数据点有不少于k个无障碍物的对象,例如region(5)中的点p29到p28和p27两个数据点都无障碍物,因此点p29被剪枝掉,得到图6中单斜线阴影区域中的对象构成的候选集;再由算法3剪枝掉那些它们的所有Voronoi邻居都被剪枝掉的数据点;最后,对于候选集中的每一个对象,分别计算它们的R2NNs,若q被包含在这些R2NNs里,则此对象点放入结果集中,可以得到如图6所示的双斜线阴影区域的结果集R2NN(q)obs(q,2,P,O)={p13,p17,p22}.所求结果.设定空间中数据点的个数为n,障碍物的个数为m,则预处理(即构建障碍Voronoi图)的时间为O(nlog(n+m)),设剪枝后剩余数据点的个数为n(nn),则查询处理时间为nlogn.如图6所示,障碍空间中,对象集为P={p1,p2,…,p31},障碍物集为O={O11O12,O21O22,O31O32},查询点为q,由障碍Voronoi图的定义,画出如图6所示的空间障碍Voronoi图.4实验结果与分析在这一节,我们用实验评估本文所提出的算法ORkNN的处理时间和I/O代价,并与用基本方法(Basic方法)查询障碍空间RkNN对象(即求出每个点的kNN,再找出这些kNNs里面包含有查询点q的数据点)进行比较.我们的实验使用C++语言实现,运行环境为InterCore2E84003.00GHzCPU、3.00GB内存和运行32位Windows7操作系统.本文使用模拟数据集和真实数据集验证所提出的算法.模拟数据集的大小和真实数据集的大小相同,数据点和障碍物的分布表示为(Distribute_Point,Distribution_Obstacle),其中Distribute_Point、Distribution_Obstacle取值为均匀分布(Uniform)、Page7真实分布(Real)、正态分布(Normal).真实数据集为包含76999MBRs的地势数据hypsogr(如图7所示)和包含36334MBRs的铁路线数据rrlines①(如图8所示).为不失一般性,假设障碍物为线段.我们使用两个R-tree分别索引数据点(hypsogr数据)和障碍物(rrlines数据).R-tree节点大小缺省值为4KB,k值缺省为10,查询点q随机从数据集中取出,障碍RkNN查询执行100次取平均值,实验结果显示出我们提出的算法处理的高效性.k值的影响.图9和图10分别给出了k值的变化对CPU时间和磁盘I/O代价的影响.由图9可以看出,k值从1变化到20的过程中,CPU时间随着k值的增加而增加.ORkNN方法的CPU时间增长率快于传统方法,是因为前者剪枝过程中时间随k增长得比传统方法增长得要快,而且由于两种方法的CPU时间差距较大,因此用时间的对数表示.实验结果表明本文提出的ORkNN方法明显好于传统Basic方法.图10给出了随着k值的增加对磁盘I/O代价的影响.两种方法的磁盘I/O代价都随着k值的增加而增加.这是由于k值越大,需要访问的数据点越多,磁盘I/O越大,而且由于我们的ORkNN方法仅需要访问离查询点较近的数据点,因此磁盘I/O代价要小很多.可以看出,ORkNN方法要优于传统方法.数据点个数的影响.为了研究数据点的密度对CPU执行性能和获得数据点个数的影响,我们给出了如图11和图12所示的实验结果.由图11可以得到,随着数据点数量的增加,我们的ORkNN方法的CPU用时下降,而传统的方法的CPU用时增加,而且ORkNN方法比传统方法的耗时少.这是因为对于ORkNN方法,数据点越密集,查询点和它的障碍Voronoi邻居之间越近,计算①R-treePortal-Spatial(geographical)Datasetsin2Dspace.Page8障碍距离的时候大多数只需要计算欧氏距离.而传统Basic方法需要计算每一个数据点的障碍反kNN,因此对于Basic方法,数据点越多,CPU用时越多.图12反映了随着数据点的数量的增加,传统Basic方法的磁盘I/O代价随之增加,而我们的ORkNN方法的I/O代价下降.这是由于Basic方法需要计算的每一个数据点,因而数据点越多,计算的数据点越多.对于ORkNN方法,数据点越密集,需要访问的障碍物越少,因而在每个区域里剪枝掉的数据点越多,所以ORkNN方法的磁盘I/O代价随着k值的增加而减少.图12数据点的个数对磁盘I/O代价的影响障碍物个数的影响.我们通过图13和图14研究障碍物密度的变化对执行效率的影响.由图13可知,障碍物密度越大,CPU执行时间越多,而且我们的ORkNN方法明显好于传统方法.这是由于障碍物个数越多,需要计算的障碍距离越多,CPU时间越大.而计算障碍距离要比计算欧氏距离用时更多,传统Basic方法需要计算每一个数据点的障碍距离,比ORkNN方法计算的障碍距离要多,因此它的CPU耗时更多.图14给出了不同数量的障碍物对磁盘I/O代价的影响.随着障碍物个数的增加,两种方法的I/O代价都随之增加,但是ORkNN方法由于有效的剪枝策略极大地减少了障碍物的访问数量,因此磁盘I/O代价明显比传统Basic方法的代价少很多.图14障碍物的个数对磁盘I/O代价的影响数据分布的影响.图15和图16分别给出了两种算法不同数据分布影响的实验结果.横坐标1,2,…,6分别代表数据点和障碍物分布(数据点分布,障碍物分布)的不同组合,分别对应为(U,R),(R,R),(N,R),(U,N),(R,N)和(N,N).例如,(U,N)代表数据点服从均匀分布,障碍物服从正态分布.图16不同数据分布对磁盘I/O代价的影响由图15给出了数据点和障碍物服从于不同的数据分布对CPU执行时间的影响情况.可以看出,数据分布的变化对CPU执行时间的影响不大,但是我们的ORkNN方法由于访问数据比Basic方法少,因此在CPU时间上优于传统方法.图16给出了不同的数据分布组合对数据点和障碍物在磁盘I/O代价上的影响.可以发现,数据分布的不同对磁盘I/O代价影响不大.ORkNN方法由于具有高效的剪枝方法,减少了大量访问数据Page9点和障碍物的个数,降低了磁盘I/O代价,因此ORkNN方法优于传统Basic方法.5结论本文研究障碍空间中反k最近邻查询算法.我们形式化定义了障碍反kNN查询,提出了一种基于障碍Voronoi图的高效的剪枝方法.将空间划分成6等份的方法用于障碍空间,并将此方法加以改进.根据Voronoi图和障碍距离的特性,大幅度减少了处理数据点和障碍物的数量.使用真实的数据集和多种方式分布的模拟数据的实验结果,表明了所提出算法的高效性和准确性.
