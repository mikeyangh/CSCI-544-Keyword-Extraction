Page1基于CEGAR的Web应用验证高洪皓1),2),3)缪淮扣1),3)曾红卫1)1)(上海大学计算机工程与科学学院上海200444)2)(上海大学计算中心上海200444)3)(上海市计算机软件评测重点实验室上海201114)摘要Web应用导航行为的建模和验证是可信Web工程研究的重点和难点.在深入分析用户和Web浏览器交互行为的基础上,文中引入On-the-fly策略并基于反例引导的抽象精化验证方法CEGAR对Web应用的导航行为进行建模和验证.在On-the-fly导航模型展开的过程中,根据检验性质采用增量式状态抽象方法构造Web应用导航抽象模型,通过确认抽象反例来识别伪反例,借助等价类精化方法消除抽象模型上的伪反例.这一方法可有效地缓解Web应用验证过程中出现的状态爆炸问题.关键词Web应用;导航模型;抽象精化;模型检验;伪反例1引言开展业务逐渐成为电子商务的主流趋势.越来越多的企业、单位、甚至个人都纷纷开始部署Web应用程序和云计算平台,以实现实时双向的商业合作和互联网的快速发展使得通过Web求解问题和信息沟通.然而,异构性、动态性、连接多样性以及控Page2制流可变性等特点,对Web应用的设计、实现、维护和管理提出了新的挑战.部署于网络中的Web应用是否正确实现了业务逻辑,是否存在安全隐患,需要对其进行必要的测试.Web应用的验证作为测试的一种辅助手段,不仅可以检验Web应用的安全性,而且还可以给出Bug缺陷所存在的位置.Web导航模型作为Web应用验证的重要模型已经得到了学术界和工业界的广泛认同,其为Web页面间的业务逻辑关系建立适合于检验的形式化模型.用户与Web应用直接进行交互,使得Web应用成为网络软件最直接的表现形式.然而,一方面,用户不仅可以在浏览器地址栏上输入URL直接访问页面,而且可以直接点击网页上的超链接随机地访问动态Web页面.由于用户交互行为的不确定性,导致设计阶段的静态需求分析方法无法对这一动态行为进行检验.另一方面,在Cache和Session作用下,用户还可以与浏览器按钮进行交互,包括前进和后退等按钮,访问先前已浏览的页面.如果Web应用导航行为的业务逻辑存在安全性缺陷,这些动作将影响Web应用的整体导航功能和性能,尤其是私密数据在用户消极地点击浏览器按钮时可能遭到破坏.考虑上述两方面问题,需要对Web应用的导航行为进行动态建模以实现携带私密数据页面的安全性验证.因此,作为Web应用研究的重点和难点,对Web应用导航行为进行形式化建模和验证成为Web工程亟待解决的实际问题.目前,基于模型检验(ModelChecking)[1]方法的Web应用建模和验证技术,吸引了国内外众多学者对其展开深入研究,并取得了一些初步的研究成果[2-5].Haydar等人[2]用通信状态机为Web应用建模,提出了一种从浏览器会话记录自动产生通信状态机的方法,该模型可用于Web应用的性质验证和回归测试.Donini等人[3]使用Web应用图WAG(WebApplicationGraph)对窗体、网页以及网页中的链接和动作进行形式建模以支持Web应用验证.Han等人[4]研究Web应用自适应导航行为,采用UML状态图对自适应导航进行建模并手工进行验证.然而,这类方法也有其不足的一面.随着系统规模的不断增大,刻画Web应用导航行为的模型状态及其迁移关系将呈现指数级增长,尤其是针对并发Web应用场景时更容易出现状态空间爆炸问题[6],其计算、验证和判定的复杂度也随之增加.而实际上,针对Bug缺陷而言,其往往存在于模型的某一较小范围内.检验性质在建立完整模型之后执行,不仅需要占用大量的状态存储空间,而且需要花费大量的搜索时间用于性质的可满足性判断.因此,如何对模型进行抽象精化验证已引起学术界和工业界的共同关注.Bryant等人[7]提出基于状态约减的有序二叉决策图(OrderedBinaryDecisionDiagrams,OBDD)方法能将与要验证的性质无关的状态进行合并从而构造简化的等价模型.Alur等人[8]提出基于迹(trace)状态约减技术的偏序规约(PartialOrderReductions,POR)方法,通过固定某些状态的次序,使检验只针对所有可能执行路径集合中的一个子集.Berezin等人[9-10]提出组合推理(CompositionalReasoning,CR)方法,利用系统的组合结构对问题进行分解,通过检验各子模型的性质来综合推导出整体模型的性质.Clarke等人[11-12]提出抽象精化技术(AbstractionRefinementTech-niques),包括存在性抽象和一致性抽象方法.其中,抽象(Abstraction)被认为是处理状态爆炸问题最便捷的方法,但该方法常会引入具体模型中不存在的附加行为,不能说明系统违背性质,这样的反例称为伪反例(SpuriousCounterexample).因此,需要确认反例的有效性并消除伪反例.于是,基于精化(Refinement)[13]的扩展技术被提出用于处理伪反例.它是一种等价状态划分方法,将一个失效状态(引起伪反例的具体状态集合)分割为多个抽象状态,从而消除抽象模型中的伪反例行为.Chen等人[14]采用On-the-fly方法对Web应用导航建模,重点研究基于浏览器交互覆盖准则产生性质并进行验证的方法.这种方法的优点是一旦验证算法找到一个反例,算法即可终止,而不必生成剩余的状态空间.On-the-fly技术[5]是一种局部模型检验技术,在构造系统全局模型的过程中检验性质的可满足性,根据所要验证性质的需要逐步展开系统所包含的状态,不需要事先构造完整的系统状态空间.上述方法都可以很好地解决内存不足和状态爆炸等问题.然而目前关于抽象验证方法在Web应用上的研究不多.Web应用的功能越复杂,导航模型将越庞大.为了应对Web应用验证中的状态爆炸问题,提高建模和验证的效率,本文结合On-the-fly方法对Web应用导航模型进行建模,改进基于反例引导的抽象精化框架(Counterexample-GuidedAbstractionRefinement,CEGAR)[13]以适用于Web应用导航Page3模型的安全性验证,称为基于On-the-fly导航模型反例引导的抽象精化(OTF-MC-CEGAR)框架.基于该框架的验证方法是一个“抽象-检验-精化”的循环过程.具体步骤如下:根据Web应用页面状态之间的导航关系动态构造On-the-fly导航模型,同时采用等价类抽象方法抽象模型,避免对无关状态进行(重复)计算.在抽象模型上检验给定的性质.如果性质不满足,在具体模型上检验抽象反例路径并确认反例的有效性.当确认抽象反例是伪反例时,对抽象模型进行精化以消除伪反例.如果性质得到满足,根据用户与Web应用的交互行为逐渐展开的导航关系上的增量状态,采用增量式状态抽象策略对状态进行抽象并在抽象模型上再次检验性质.一直执行这一迭代过程直至完整的Web应用导航行为的抽象模型建立完毕并得到检验.因此,本文Web应用验证方法不再需要为Web应用导航行为建立全局的具体状态空间,通过反例确认过程识别伪反例,可以提高Web应用验证的有效性,对Web应用的验证具有决定性的指导作用.本文第2节介绍Web应用的On-the-fly导航模型建模方法;第3节提出基于On-the-fly导航模型的抽象精化验证方法;第4节通过对比实验证明本文方法的有效性;最后是本文的相关工作与总结展望,并指出今后的研究方向.2Web应用导航模型建模本文考虑的Web应用的导航行为不仅与Web页面之间的导航关系相关而且还与Web浏览器的按钮交互行为有关.用户通过Web浏览器提供的按钮(Forward、Back、Refresh、Favorites等),可随时改变或中断Web应用的流程,影响Web应用的安全性.针对Back和Forward按钮状态,文献[15-16]基于可缓存机制Cache和Session将Web页面分为4种状态:(1)BDFD,即Back和Forward都是非使能的;(2)BDFE,即Back是非使能的,Forward是使能的;(3)BEFD,即Back是使能的,Forward是非使能的;(4)BEFE,即Back和Forward都是使能的.Web应用的每个页面根据浏览器动作派生不同的状态,通过组合这些页面间的导航行为,可以构造出Web应用的导航模型.然而,如果能在模型的小范围内就能发现并返回Bug缺陷,那么构造完整的Web应用导航模型将是浪费的.另一方面,由于每个页面存在前进和后退状态,当参与的页面越多时,导航行为的交互越复杂,建立Web应用导航模型的难度越大.基于此,为了实现根据所要验证性质的需要逐步展开Web应用系统所包含的状态并检验安全性,本文给出了适合于边建模边验证的Web应用导航模型.定义1.Web应用导航模型.Web应用的On-the-fly导航模型[5]是一个扩展的Kripke结构M=(S,I,AP,L,T),其中,(1)S是有限的状态集,表示逐渐展开过程中的状态空间.每一个状态由呈现给用户的Web页面以及加载该Web页浏览器的按钮状态构成.题集.(2)IS是初始状态集.(3)AP是标记网页和动作action的原子命(4)TS×S是迁移关系集.(5)L:S→2AP是状态标记函数,L(s)表示状态s下所有为真的原子命题集.在状态集S中,用状态P(XY)为每个网页以及加载该网页的浏览器动作进行标记,其中X、Y分别代表浏览器的按钮Back、Forward状态.令00代表BDFD,10代表BEFD,01代表BDFE,11代表BEFE.状态间迁移动作action由Web浏览器的链接和按钮行为决定.考虑到登入和登出操作权限,动作主要包括link、login、logout、back和forward等.状态标记函数L(P(XY))表示Web页面和浏览器按钮状态所组成的命题公式,例如L(P1(10))=P1∧back∧forward表示在P1页面上可以点击Back按钮后退,但不允许点击Forward按钮前进.此时如果导航行为模型上存在Forward动作使得状态P1(10)可转移,那么该导航行为是不正确的,但P1(10)页面允许通过超链接link动作进行页面导航.实例说明:只有授权用户才能访问私密网页集合组成的安全敏感区(SafetyCriticalRegion,SCR).如图1(a)所示,是一个审计管理系统实例.用户通过页面P2登入SCR区域,即虚线框表示部分{P3,P4,P5,P7}.在SCR内允许用户通过浏览器的Forward和Back按钮浏览和操作Web页面.当退出SCR时,从缓存队列中删除已缓存的私密Web页面.此时,安全性质描述为不允许用户通过点击浏览器Back或Forward按钮再次从公共网页直接访问SCR区内的页面.例如点击Back按钮从页面P6直接回到页面P5将是一个错误的导航行为.Page4图1Web应用的On-the-fly导航模型构造过程由于不需预先构造完整的导航模型,每个On-the-fly导航模型记录了Web应用在用户参与交互下逐渐展开的业务逻辑行为.例如,应用Web应用导航模型的定义得图1(b)模型Mb,其中S={P1(00),P2(10),P1(01),P3(00)};I={P1(00)};AP={P1,P2,P3,link,login,back,forward};L(P1(00))={P1,link};L(P2(10))={P2,back,login};L(P1(01))={P1,link,forward};T={(P1(00),P2(10)),(P2(10),P1(101)),(P1(01),P2(10)),(P2(10),P3(00))}.随着交互过程的深Page5入,状态逐渐被展开.图1(b)、(c)和图1(d)是图1(a)实例的On-the-fly导航模型构造过程示例,每条迁移被标注上动作便于说明,构造顺序依次为Mb→Mc→Md.在On-the-fly导航模型上执行验证,可以实现边建模边验证的效果.为了说明安全性检验,以CTL性质公式[1,5,17]AGp为例,其中p··=(P2→((back∨forward)∧AX(P3)))表示禁止用户通过浏览器按钮动作从非安全敏感区No-SCR直接进入安全敏感区SCR,即用户不允许从公共网页(如P2、P6)重新访问SCR内的私密网页(如P3、P5).显然,采用On-the-fly策略,反例路径P2(10)-〈〈forward〉〉-P3(00)在导航模型Mb即可被识别出来(图中带箭头的虚线即表示发现的错误迁移).此时,结束检验流程并提示用户错误路径以便进一步修改模型.相对于完整构造如图1(d)所示的导航模型,这种边构造模型边验证模型的检验方法在整个导航模型空间建立之前就可能给出了性质检验结果,可降低模型检验过程中的内存消耗和时间消耗.On-the-fly导航模型的优点是不需要事先构造完整的系统状态空间.性质检验在最优的情况下,计算复杂度O(1),然而,在最差的情况下,计算复杂度O(|M|),其中|M|表示整个导航模型的大小.对于存在并发导航行为的系统而言(如机票订票系统,一天服务数十万人次),组合模型趋于无穷大|M|→时,检验性质的可满足性将会不可避免地出现状态爆炸问题.又如在实时系统[18]中,如何约减状态并在时间约束范围内发现错误是非常重要的.因此,本文将反例引导的抽象精化模型检验方法(CEGAR)应用到On-the-fly导航模型中,将检验问题“Web应用导航模型M是否满足性质φ,即Mφ”转化为“Web应用抽象导航模型M^是否满足性质φ,即M^φ”.通过抽象技术,将等价状态进行抽象和约减,提取具有性质保持关系的状态及其交互行为,检验抽象模型是否满足给定的安全性.如果满足,那么说明原始模型中也保持这一安全性性质;反之,需要鉴别反例真实性.如果是伪反例,则需要消除该伪反例并再次迭代地进行性质检验.与传统抽象精化验证方法不同的是:本文方法实现一边构造Web应用导航模型,一边在反例引导下进行抽象精化验证,可有效地缓解Web应用验证过程中的状态爆炸问题.3On-the-fly抽象精化验证Clarke提出的CEGAR框架分为构造抽象模型、模型检验及对反例进行确认、针对伪反例精化模型3个阶段.然而,现有的大多数抽象精化方法[11,13,18-24]是在全局模型上进行的,抽象效率低且实现难度比较大.本文基于On-the-fly的反例引导抽象精化模型检验的方法能够在Web应用导航模型逐渐构造过程中,采用反例引导的抽象精化方法对Web应用导航模型进行抽象和验证,可以降低Web应用导航模型验证的复杂性.如图2所示,是本文设计的用于验证Web应用On-the-fly抽象精化验证工具平台原型的体系结构.具体过程说明如下:(1)产生一个初始化状态抽象函数,在已展开的Web应用导航模型中,采用等价类状态划分方法抽象状态,并根据验证性质的需要构造抽象Web应用状态模型.(2)在抽象模型上进行性质检验,如果抽象模型M^满足性质,则说明对应的具体模型M也满足性质,转步(4);反之,根据模型检验器输出的反例,需在具体模型M中检验抽象反例的有效性,当反例为真时,输出False;当确认反例为伪反例时,转至步(3).(3)通过精化等价关系将状态抽象函数精化.基于该新的抽象函数将抽象模型M^进行精化,使得抽象模型上不再存在伪反例,并重复执行步(2).(4)如果Web应用导航模型尚未构造完全,则继续展开Web应用导航模型,并转向步(1).如果Web应用的导航模型已完全展开且全局模型已通过性质检验,则输出True表明模型满足性质.3.1状态抽象抽象技术的重点在于如何进行状态合并.用状Page6态抽象函数h:S→S^表示将含有等价关系()的状态进行合并,即任意两个状态s1,s2:S满足s1s2,当且仅当h(s1)=h(s2).每个抽象状态s^对应具体模型M中的一个状态集(等价类),即h-1(s^)是等价状态的集合.因此,抽象结果是将状态s1和s2合并为抽象状态s^,且满足h-1(s^)={s1,s2}.目前普遍应用的抽象方法是存在性抽象方法(ExistentialAbstract)[25],其思想是:若两个抽象状态之间存在迁移,当且仅当这两个抽象状态分别存在一个对应的具体状态,即(t,t1)∈T^,当且仅当s:h-1(t),s1:h-1(t1)使得(s,s1)∈T,其中T^是抽象状态模型上的迁移关系集.定理1.抽象状态S^保持具体状态S的性质.(1)如果状态s1,s2:S并且s1和s2之间存在迁移T(s1,s2),抽象状态对应于s^1=h(s1),s^2=h(s2),那么s^1和s^2也存在迁移,即s1,s2·(h(s1)=s^1∧h(s2)=s^2∧T(s1,s2))→T^(s^1,s^2).(2)如果状态s是初始状态(I(s)=true),那么抽象状态s^也是初始状态(I^(s^)=true),即s·(h(s)=s^∧I(s))→I^(s^).如图3所示,存在4个抽象状态1^,2^,3^,4^,其中状态集合{1,2,3}的抽象状态为1^,状态集合{4,5,6}的抽象状态为2^,状态集合{7,8,9}的抽象为3^,状态集合{10,11,12}的抽象状态为4^.状态集合中的元素之间存在等价关系(),例如状态集合S={1,2,3}中,设h1,h2,h3分别是状态1,2,3对应的抽象映射函数,满足123使得h1(1)≡h2(2)≡h3(3)≡h({1,2,3})=1^.抽象状态之间的迁移关系必然对应于具体状态上的迁移关系,如抽象迁移T^(1^,2^)对应具体迁移T(2,4).具体状态的初始状态在抽象状态中也是初始状态,如对应于具体状态中初始状态1的抽象状态1^是抽象模型上的初始状态.基于On-the-fly导航模型的状态抽象是对存在性抽象[26]的一种改进方法.首先,根据安全性性质初始化导航模型的抽象;其次,在其后的导航模型On-the-fly构造过程中,对增量状态进行等价类划分、合并.最后,根据存在性抽象原则构造抽象模型.定义2.On-the-fly状态抽象方法.设Web应用导航模型Mi=(Si,Ii,APi,Li,Ti)是一个采用On-the-fly方法构造产生的第i个模型,AP^APi.令RSi×Si是状态集Si上关于AP^的等价关系(),满足s,s:Si,如果Li(s)∩AP^=Li(s)∩AP^,那么s和s存在等价关系R(s,s),它们可以进行状态合并.以Mi到Mi+1的导航模型构造过程为例,说明On-the-fly状态抽象方法如下:(1)定义Mi关于AP^和R的抽象结果M^i=Mi/(AP^,R)=(S^i,I^i,AP^i,L^i,T^i),其中:①S^i=(Si/R),即S^i是Si关于R的等价类划分.②I^i={s^:S^i|s:h-1(s^)·s∈Ii}.③L^i(s^)=Li(s)∩AP^,其中s∈h-1(s^).④s^1,s^2:Si·(s^1,s^2)∈T^i,当且仅当s1,s2:S·s1∈h-1(s^1)∧s2∈h-1(s^2)∧(s1,s2)∈Ti.(2)定义后继模型Mi+1关于AP^和R的抽象结果描述为M^i+1=Mi+1/(AP^,R)=(S^i+1,I^i+1,AP^i+1,L^i+1,T^i+1).令ΔS是基于On-the-fly方法构造的第i+1个模型Mi+1和第i个模型Mi之间增量状态集合.每个增量状态Δs∈ΔS而言,抽象过程分为以下两种情况处理.如果s^:S^i·L^i(s^)≠Li(Δs)∩AP^,则(1)S^i+1=S^i∪Δs.(2)I^i+1=I^i∪Δs,当且仅当Δs∈Ii+1;否则,(3)T^i+1=T^i∪(Δs,s),当且仅当s:S^i·(Δs,如果s^:S^i·L^i(s^)=Li(Δs)∩AP^,则I^i+1=I^i.s)T^i.Page7(1)S^i+1=S^i,其中s^=h(Δs).(2)I^i+1=I^i.(3)T^i+1=T^i∪(Δs,s),当且仅当Δs:ΔS,s:S^i·(s,s)∈Ti+1∧Ti+1/T^i.模型Mi+1是在模型Mi的基础上的增量抽象.在构造Mi+1的抽象过程中,第1种情况表明当前增量状态不与已抽象的状态存在等价关系,需要进行单独抽象.第2种情况表明当前增量状态与已抽象的状态存在等价关系,抽象状态不发生变化,只需考虑新增的迁移关系.随着导航模型的逐步展开,反复执行增量抽象,直到Web应用导航模型完全建立完毕才停止.在模型实际构造过程中,等价关系是基于检验性质构造的,结合每个抽象页面的AP^及待验证性质φ用于抽象模型,即AP^=AP∩APφ,其中APφ={p|p∈Atom(φ)},Atom(φ)是性质公式φ中的原子命题.抽象模型M^=M/(AP^,R)中就只包含与φ相关的原子命题,从而实现将与φ无关的其他原子命题从模型中约减.实例说明:假设图4(a)和(c)是基于On-the-fly建模过程产生的两个模型.采用定义2方法,图4(b)和(d)分别是图4(a)和(c)的抽象.以安全性φ=AG(P2→((back∨forward)∧AX(P3)))为例,由该性质得到APφ={P2,P3,back,forward}.在图4(b)中,状态{P1(00)}被抽象成为状态P^1,状态{P2(10)}被抽象成为状态P^2,状态{P3(00)}被抽象成为状态P^3,即h(P1(00))=P^1,h(P2(10))=P^2,h(P3(00))=P^3.在图4(d)中,检验到状态P4(00)与P^1中的状态具有等价性,即L(P^1)=L(P4(00))∩APφ,因此将其合并到抽象状态P^1之中,即h({P1(00),P4(00)})=P^1.如图4(b)所示,是图4(a)模型的抽象结果,其中增量状态、抽象状态、迁移关系及状态上原子命题的说明如表1(a)所示.如图4(d)所示,是随着On-the-fly导航模型的展开,对增量状态P4(00)进行的抽象,其中增量状态、抽象状态、迁移关系及状态上原子命题的说明如表1(b)所示.增量状态抽象状态迁移P1(00)P^1={P1(00)}—P2(10)P^1={P1(00)},P3(00)P3(00)P4(00)增量状态抽象状态迁移P1(00)P^1={P1(00)}—P2(10)P^1={P1(00)},P^2={P2(10)}{(P1,P2)link}L(P^1)≠L(P2(10))∩APφP^1={P1(00)},P^2={P2(10)},P^3={P3(00)}P^1={P1(00),P^2={P2(10)},P^3={P3(00)}在该过程中,4个状态和4个迁移分别抽象为3个状态和3个迁移.随着导航模型状态不断增加,抽象的效果将更趋于明显.由定义2On-the-fly状态抽象方法以及定理1的存在性抽象知:(1)如果状态s和s是等价类,那么在抽象函数h上是等价的,并且状态上的原子命题必然也是等价的,即L(s)=L(s);(2)每个抽象状态保留着具体状态的原子命题,即h(s)=s^→L^(s^)=L(s).因此,可得Web应用导航模型的抽象性质.定义3.导航模型抽象性质.通过On-the-fly方法抽象产生的抽象模型M^=(S^,I^,AP^,L^,T^)是具体模型M=(S,I,AP,L,T)的抽象,记为MaM^,它们满足如下性质:(1)I^(s^)是抽象初始状态,当且仅当s:S·(2)T^(s^1,s^2)是抽象迁移,当且仅当s1,s2:S·h(s1)=s^1∧h(s2)=s^2∧T(s1,s2).(3)L^(s^)=∪h(s)=s^L(s)∩APφ.(4)AP^AP.抽象具有性质保持定理[26].本文讨论的安全性性质φ是以ACTL描述的,如AGp,因为它在抽h(s)=s^∧I(s).Page8象过程中是保性质的.如果抽象模型上满足待验证的性质,那么具体模型也满足该性质.但是抽象技术的一个主要缺陷是抽象模型可能引入系统中不存在的附加行为,也可能由于过度的精化导致一些系统行为的丢失.因此,出现反例时,并不能说明具体模型也存在反例,而需确认反例的有效性.3.2反例确认将Web应用的导航抽象模型输入到模型检验器后,模型检验器基于遍历算法检验以时态逻辑性质描述的安全性性质.当抽象模型违背性质时,模型检验器输出反例,描述从起始状态到违反性质的状态的路径.此时,需确认抽象反例的有效性,即抽象反例是否在具体模型中存在相应的反例路径.如果存在,则抽象反例是一个真实的反例;反之,抽象反例是一个伪反例.定义4.反例路径有效性.为了便于说明,令抽象模型反例π^=〈s^1,s^2,…,s^n〉,描述从抽象状态页面s^1到s^n的导航路径是违反给定的安全性性质的.具体模型上也应该存在对应的反例路径[13],其表示为h-1π()^={〈s1,…,sn〉|∧n由于抽象反例路径上的每个状态页面可能对应多个具体状态页面,因此根据抽象反例路径的导航关系组成的具体反例路径集合称为具体反例路径.当具体模型的反例路径h-1π()^≠时,说明具体模型亦存在反例,其也违反了安全性性质,此时该反例是真实的.否则,说明具体模型上不存在相应的反例路径.在实际计算具体反例路径时,令任意s^i对应于具体模型上的状态可达集Si∷=Img(Si-1,T)∩h-1(s^i),其中Img(Si-1,T)表示可达状态集Si-1在迁移关系T的作用下得到的所有后继状态集合.令S1=h-1(s^1)∩I表示初始可达状态集.抽象反例路径是真实的,当且仅当满足:(1)实际路径h-1(π^)为非空集合;(2)对于所有1in,那么Si≠.根据抽象模型上的反例路径计算Si可以识别出伪反例存在的位置,即当Si=时,抽象模型存在伪反例.如图5所示,是图1(c)导航模型Mi的一个反例〈P^1,P^2,P^3,P^4〉,表示用户在Web浏览器上通过直接点击Forward按钮进入SCR区域,而对应的具体模型上却不存在相应的反例路径.由抽象状态和具体状态之间的关系,可达集计算如下S1={P1(00),P1(10),P1(01)},S2={P2(10)},S3={P3(00)},S4=Img(S3,T)∩h-1(P^4)=.可以发现由于S4=,抽象反例是伪反例.造成这一伪反例的原因是状态P3(01)和P3(00)被合并为同一抽象状态P^3.此时,抽象反例的导航行为在具体模型上不存在反例.定义5.失效状态.引起具体模型无法满足抽象反例路径的状态可达集Si≠称为失效状态.给定一个最大失效索引f,伪反例路径π^=〈s^1,s^2,…,s^f〉在具体模型上存在对应的最大反例路径,即可达集Sf≠,Sf+1=.失效状态根据Web应用的具体模型上页面导航关系划分为以下几种类型:(1)死状态集SD(Dead-endState).每个SD中的状态从初始状态出发都是可达的,但每个状态不存在后继迁移导航.此时,状态可达集Sf∈h-1(s^f)并且Sf+1=Img(Sf,T)∩h-1(s^f+1)=,每个Sf中的元素从初始状态集h-1(s^1)∩I都是可达的.因此SD=Sf.(2)坏状态集SB(BadState).每个SB中的状态从初始状态出发都是不可达的,但每个状态存在后继迁移导航,即存在一个从s^i到s^i+1的抽象迁移导航关系,使得h-1(s^i)中的坏状态与h-1(s^i+1)中的状态至少存在一个迁移导航关系.此时,坏状态集SB中没有任何一个状态与h-1(s^i-1)发生联系.坏状态从初始状态集是不可达的.因此SB={s:h-1(s^f)|s:h-1(s^f+1)·T(s,s)}.(3)无关状态集SI(IrrelevantState).它既不与前驱的状态发生关联,也不与后继的状态发生关联,即它既不属于死状态集也不属于坏状态集的状态.因此SI=h-1(s^f)\(SB∪SD).如图5所示,P3(00)∈SD是一个死状态,其后不存在任何向外的迁移导航路径;P3(01)∈SB是一个坏状态,其后存在迁移导航路径,但是从初始状态是不可达的;P3(11)∈SI是无关状态.正是因为Page9死状态P3(00)和坏状态P3(01)被抽象为同一抽象状态,Web应用的抽象模型上附加了一个导航行为T^(P^3,P^4),并引起了伪反例的出现.定义6.导航路径伪反例确认算法.定义4表明如果h-1(π^)=,则反例是一个伪反例使得状态可达集Si=.为了确认抽象导航模型上的反例是否为伪反例,算法1是用于计算Sf失效状态的SplitPATH算法[13].在初始化时S=h-1(s^1)∩I并设置j=1表示失效索引,当S不为空并且没有达到最大抽象状态时,进行循环处理.一旦当前抽象状态满足S=,则输出前一个失效状态Spre集合和失效状态索引j,用于确认反例的真实性.算法1.SplitPATH算法.输入:抽象模型、具体模型以及抽象模型上的一个反输出:如果反例是伪反例,返回抽象反例中的失效状态BEGINS··=h-1(s^1)∩I;j··=1;WHILE(S≠ANDj<n){j··=j+1;Sprev··=S;S··=Img(S,T)∩h-1(s^j);}ENDWHILEIFS≠THENoutput“counterexample”ELSEoutputj,SprevENDIFEND另一种复杂情况是存在套索[26]的反例路径π^=〈s^1,s^2,…,s^i〉〈s^i+1,s^i+2,…,s^n〉w,即在状态s^i+1和s^n之间出现无限循环.套索用来说明模型违背一个活性(liveness)性质.在Web应用导航模型的SCR区域的边界尤其需要重视套索反例的存在.一旦出现套索则可能影响私密数据页面的安全性,此时由于Web应用程序中维护Session的业务逻辑出现bug缺陷,容易导致用户登入和登出信息不一致,以及非法用户获取或继承某些限制级别的Web应用使用权限.为了检验实际循环是否与抽象循环一致,需将抽象循环中的反例进行展开.令k:[i+1,n]·s^k+j(n-i)=s^k,得到展开后的路径为π^unwind=〈s^1,s^2,…,s^i〉〈s^i+1,…,s^n〉〈s^i+1,…,s^n〉…然而,展开给定的一个抽象循环反例,具体模型可得到多个不同大小的循环路径.展开的结果表明:(1)每一个环可以在不同展开阶段重新开始循环;(2)执行结果将出现周期性;(3)随着循环展开状态的增加,计算复杂度将呈现指数级增长,且属于多项式计算NP-难问题.因此,展开这类套索反例过程中,需要考虑在最小循环上执行操作.如图6所示,图6(a)中的循环反例〈P^2〉〈P^3,P^4〉w被部分展平成图6(b),表明抽象页面P^4和P^3状态之间存在无限循环操作,那么用户可以通过点击Forward和Back按钮随意登入审计系统,使得P3页面出现P3(11)的错误状态.作为SCR页面,是不允许出现状态P3(11)的,因为P3(11)表示用户可以通过点击Back按钮直接退出系统,或点击Forward按钮直接进入系统.此时,或者是由于Session数据在用户退出之后未做清除,或者是由于当前用户登入过程中读取了其他历史用户的Session数据.检验和消除类似P3(11)状态的页面可以有效地保护SCR区域的安全性.定义7.循环伪反例确认算法.循环伪反例确认算法(SplitLOOP算法)和路径伪反例确认算法非常相似,不同的是SplitLOOP算法[13]计算最小循环展开中的反例.令抽象循环内所有抽象状态中的最小值min=Mini+1jn(|h-1(s^j)|)=Min{|h-1(s^i+1)|,…,|h-1(s^n)|},展开后的抽象循环路径表示为π^unwind=〈s^1,s^2,…,s^i〉〈s^i+1,…,s^n〉min+1.它是在最小循环次数min上将循环体展开所组成的路径.算法2是基于SplitPATH算法扩展的SplitLOOP算法.其中π^unwind通过函数unwind()计算将抽象反例展开,并通过SplitPATH算法来确认循环反例的有效性.Page10算法2.SplitLOOP算法.输入:带环的抽象套索反例输出:上一个可达具体状态Sprev,失效状态的索引点kBEGINmin=Min{|h-1s^i+1|,…,|h-1s^n|};π^unwind··=unwind(π^,min+1);computejandSprevasinSplitPATH(π^unwind);k··=LoopIndex(j);p··=LoopIndex(j+1);outputSprev,k,pEND函数LoopIndex(j)计算循环反例被展开后π^unwind在位置j上抽象状态的索引.当jn时,LoopIndex函数计算LoopIndex(j);当j>n时,LoopIndex函数计算LoopIndex([(j-(i+1))mod(n-i)]+(i+1)).如果抽象反例为伪反例,SplitLOOP算法输出Sprev和标记k,p并且满足以下条件:(1)所有Sprev中的状态都对应s^p抽象状态,即(2)所有Sprev中的状态从初始可达集S1=(3)假如k是循环索引p的后继.当p=n时,(4)如果没有从可达状态集Sprev到h-1(s^k)的Sprevh-1(s^p).h-1(s^1)∩I出发都是可达的.k=i+1,否则k=p-1.迁移,那么Img(Sprev,T)∩h-1(s^k)=.h-1(π^unwind)≠.(5)s^p是一个带环的失效状态.定理2.π^是有效的循环反例,当且仅当证明.首先,根据迁移函数T的迁移关系,将抽象模型上的循环反例映射为具体模型上的路径h-1(π^unwind)=〈a1,…,ai,b1n〉,该反例路径满足:(1)j:[1,i]·aj∈bmin+1h-1(s^j);(2)(j,k):[i+1,n]×[1,min+1]·bkh-1(s^j).设函数succ()表示后继,例如当1j<n时succ(j)=j+1,当j=n时,succ(j)=i+1.路径长度L··=i+(min+1)×(n-i).可将具体模型路径h-1(π^unwind)改写为path=〈d1…dL〉,其满足(1)d1∈h-1(s^1);(2)对于每个j<L,如果dj=h-1(s^k),那么dj+1=h-1(s^succ(k)),succ(k)表示k的后继.其次,证明循环反例π^是有效的h-1(π^unwind)≠假设具体模型存在反例,一旦反例包含循环.体,那么存在一个无限的路径,标记为I-Path=〈c1,c2,…〉满足c1∈h-1(s^1),对于所有j,如果cj=h-1(s^k),那么cj+1=h-1(s^succ(k)).根据上文h-1(π^unwind)改写为path=〈c1…cL〉,那么I-Path的有限前缀满足path路径表达必然被包括在h-1(π^unwind)中,因此h-1(π^unwind)≠.最后,证明h-1(π^unwind)≠循环反例π^是有效的.假设h-1(π^unwind)≠,存在一个状态在路径上至少出现2次[26],那么必然存在cα,cβ满足cα=cβ.由于状态重复出现,存在一条迁移关系T(cβ-1,cα),使得循环存在于cα和cβ-1之间,即〈c1,…,cα-1〉〈cα,cβ-1〉w反例路径也满足具体模型.因此,定理2得证.3.3抽象模型精化由于坏状态SB和死状态SD同时映射到同一抽象状态中,使得抽象模型上的抽象反例无法在具体模型上找到具体反例.精化的作用是对抽象模型进行变换以消除已经发现的伪反例.若抽象模型过于粗糙,则可能无法证明给定属性;而若抽象模型过于精细,则将增加对空间的需求.因此,如何控制抽象的精确程度,构造一个尽可能紧凑又能够验证给定属性的抽象模型,在效率和功能之间求得平衡[24,27-28],是精化面临的最大挑战.本文消除伪反例的方式是通过精化抽象函数来消除失效状态.设R1和R2是状态集S上的两个等价关系(),称R2是R1的精化,当且仅当,s1,s2:S·((s1,s2)∈R2→(s1,s2)∈R1).定义8.抽象模型精化.给定一个导航模型M=(S,I,AP,L,T)以及抽象函数h.令抽象函数h是抽象函数h的精化,满足如下约束:(1)对于s1,s2:S满足(h(s1)=h(s2))→(h(s1)=h(s2)).(2)对于s1,s2:S满足h(s1)=h(s2)同时也满足h(s1)≠h(s2).(3)对于s:SB,s:SD满足h(s)≠h(s).伪反例π^产生的原因之一是坏状态SB≠.为了使死状态SB和坏状态SD分离在不同的抽象状态中,定义一个精化的等价关系R用于处理失效状态s^f:s1,s2:s^f·((s1,s2)∈R(s1,s2:s^f+1·(s1,s1)∈T^∧(s2,s2)∈T^)∨(s:s^f+1·(s1,s)T^∧(s2,s)T^),即s^f中的两个状态s1,s2具有等价关系当且仅当s1,s2同时都有到s^f+1的具体状态的迁移或者都没有迁Page11移,因此R将s^f划分为两个等价类s^1(SI∪SD).算法3.抽象模型的精化算法.输入:一个抽象模型以及一个伪反例输出:输出一个精化后的抽象模型BEGINFOREACHi··=1TOmENDFOREACHEND算法3是抽象模型精化的具体算法.算法中Sf是根据反例确认算法识别伪反例路径上的失效状态,处理过程使得Sf中的SD和SB得以区分.为了识别哪些状态属于SD,哪些状态属于SB,首先令spre∈h-1(s^i-1)表示Sf前一状态,令snext∈h-1(s^i+1)是Sf的后一状态的.接着对每一个Sf中的状态进行判断,将属于SD或SI的状态映射到s^1映射到s^23种情况进行处理:(1)当(spre,sj)∈T∧(sj,snext)T时,表明当前抽象状态的具体状态sj是一个死状态,将其映射到抽象状态s^1snext)T时,表明当前抽象状态的具体状态sj是一个无关状态,将其映射到抽象状态s^1sj)T∧(sj,snext)∈T时,表明当前抽象状态的具体状态sj是一个坏状态,将其映射到抽象状态s^2如图7所示,是对图5发现的伪反例所进行的精化.图5产生伪反例的原因是状态P3(01)和P3(00)被合并为同一抽象状态P^3.根据算法3的精化算法,精化后的结果是分别将坏状态P3(01)和死状态P3(00)映射到抽象状态P^31和P^32以消除伪反例.对当前On-the-fly导航模型Mi进行精化完毕后,需再次检验性质是否在新的抽象模型里得到满足.如果仍存在伪反例,则再次精化抽象函数得到精化模型.迭代这一过程,直至不再出现伪反例为止.4实验与分析在本文Web应用的导航模型验证中,安全性性质主要涉及数据私密性确保授权用户的数据权限,Cache可缓存性实现了正确的业务逻辑,即导航行为不存在用户对SCR页面的非法访问.安全性采用AG()形式描述所谓的“坏的事情不会发生”,旨在限制用户通过点击浏览器按钮从非安全敏感区No-SCR直接到达安全敏感区SCR.采用点覆盖准则产生检验性质,其中=(p→(back∨forward∧AX(p1∨…∨pn)))用陷阱性质[17]描述,表示No-SCR区域页面不能通过back或forward按钮直接进入并访问SCR区域页面,p∈S是No-SCR区域页面,pi∈S是SCR区域页面.以图1(a)所示审计管理系统为例,得如下以ACTL描述的安全性性质.P4∨P5∨P7))).性质1.AG(P1→(back∨forward∧AX(P3∨性质2.AG(P2→(back∨forward∧AX(P3∨P4∨P5∨P7))).性质3.AG(P6→(back∨forward∧AX(P3∨P4∨P5∨P7))).将本文方法应用于On-the-fly导航模型实例中,预先植入了两类错误导航关系:一类是用于SCR区域安全性检验,构造不安全的Session数据控制逻辑,允许用户从No-SCR区域进入SCR区域;另一类则刻意去减少一些功能页面,以造成正常功能的不可达.为了实验分析本文所述方法的错误Page12发现能力,基于图1审计管理系统的实例,在SCR区域内增加了多个复杂的业务逻辑与No-SCR区域页面交互.如果模型检验工具NuSMV返回False检验结果,说明抽象模型中存在反例.根据本文OTF-MC-CEGAR方法确认反例的真伪,从而检验Web应用模型是否存在安全性问题.随着On-the-fly模型的展开,抽象精化验证也同时进行,并且分别记录On-the-fly导航模型的页面数(#S)、可能模型状态大小(#PS)、抽象模型大小(#AS)、迁移数(#R)、查找到第一个反例的时间(#T,单位为ms)、精化后的模型大小(#RS)、精化后的迁移数(#RR)等参数.模型状态大小#PS是参加交互的页面数#S的4倍,这是由前进/后退按钮决定.检验结果(#O)则用于表明Web应用导航模型是否符合安全性性质,输出No表明不存在安全性性质的反例,输出Yes表明存在安全性性质的反例.对比精化后的模型大小#RS和抽象状态#AS,可知是否存在伪反例.ID#S#PS#AS#R#T#RS#RR#OInitial141——1——141635<0.135No28325140.49616Yes313528253.221031Yes430120173212.51732No550200315834.94266Yes67028054120127.059129Yes712048076138432.081142Yes表2展示的是本文OTF-MC-CEGAR方法在实际Web应用导航模型验证所得到的实验数据,该Web应用的业务逻辑更加复杂.例如ID=1上有4个页面参与,可能的16个模型状态被抽象为3个抽象状态,检验结果表明模型不存在安全性问题.在ID=5上有50个页面参与,可能的200个模型状态被抽象为31个抽象状态,由于伪反例存在并被精化为42个抽象状态,检验结果表明模型存在安全性问题.依据表2,可以得出以下结论:(1)每次对抽象模型验证后,通过消除伪反例得到的精化模型,在下次On-the-fly导航模型的抽象中,只要增量式的进行抽象即可,这样可以提高抽象算法的效率和减少内存消耗.(2)精化的模型由于抽象状态必须在满足不出现伪反例的情况下进行等价划分,因此精化后的模型不但抽象状态增加,而且抽象状态之间迁移也随之增加.(3)采用OTF-MC-CEGAR方法在初始的几个抽象状态和迁移中,性质检验的效率与一般的模型检验方法没有大的区别.但是随着状态的增加,我们发现OTF-MC-CEGAR更适合于复杂状态建模和验证,如ID=6和ID=7情况下,不仅状态大量减少,而且验证的效率大大提高.接着,进行对比实验.以审计管理系统的Web应用检验为例,在图1(a)系统的基础上开发了几个新模块,包括银行对账单模块、邮件系统模块、第三方支付模块等,他们之间含有不同的安全敏感区SCR.这些页面的访问都需要授权,即不能直接通过点击浏览器按钮从非安全敏感区No-SCR直接进入安全敏感区SCR.经过扩展的Web应用系统具有复杂的用户导航行为模型,因此,不断增加用户访问Web应用的请求数以及访问业务逻辑数,构造导航模型,分别将本文的OTF-MC-CEGAR方法与有序二叉决策图(OrderedBinaryDecisionDiagrams,OBDD)方法、偏序归约(PartialOrderReduction,POR)技术方法和组合推理(CompositionalReason-ing,CR)方法在不同模型大小(分别考察50,100,200,300,500)下检验安全性性质.表3给出的是错误发现能力的对比实验,其中#S表示Web应用导航模型大小,#C表示发现的反例数目.通过表3可以发现本文方法比其他方法在模型大小比较大情况下具有更强的错误发现能力,因为基于On-the-fly方式的抽象方法更适合于边建模边验证的实现,在模型展开过程中,抽象精化循环更容易发现反例.而其他方法在全局空间上进行约减和抽象,有些错误被隐藏导致其错误发现能力受限.#COBDD1119406173#CPOR1623254045#CCR2127303838#COTF-MC-CEGAR1939627986为了比较发现错误的性能,在不同的模型大小下,第1个对比实验记录发现缺陷所消耗的时间,第2个对比实验记录发现缺陷所消耗的内存.预期期望是在不同模型大小下,所消耗的时间越小越好,所消耗的内存越少越好.如图8和图9所示,是各种方法在发现反例上所消耗的时间和内存的对比实验数据.从时间消耗上来看,本文方法所消耗的时间介Page13于其他3种方法之间.从内存消耗上来看,本文方法占明显优势.CR方法需分别建立Web应用中各模块的模型,并通过检验各子模型的性质来综合推导出整体模型的性质,因此,组合和推理的时间消耗相对其他3种方法都要大.POR方法从状态之间的偏序关系进行性质检验,因此效率很高(时间消耗很少),然而由于POR方法在内存消耗方面比较多,所以维持偏序关系的算法和数据格式的存储消耗是巨大的.OBDD方法内存消耗相对比较少,但是性质检验的计算时间却很高.采用On-the-fly策略不需要构造全局状态空间,而其他方法需在全局状态模型构造出来后再进行约减,因此,其他方法的内存需求量比较大.当模型状态大于100小于300时,本文方法的内存消耗虽然激增,但相对于其他3种方法要少;当模型状态大于300时,内存消耗的增量趋势近于平稳.这体现了On-the-fly方式抽象的优势,值得注意的是,由于抽象可能导致一些附加行为的产生,而这些行为可能导致伪反例.检验这些反例的真伪性消耗了部分时间,但相对而言时间消耗还是处于可接受范围之内.5相关工作由模型检验器输出的反例能表示模型违反给定检验性质的行为路径.Beyer等人[29]扩展模型检验器BLAST从反例中自动化产生测试套件并将该方法用于检查C程序的死锁代码位置点.为了实现在系统层面对未覆盖分支的可覆盖性分析和测试用例的产生,Fantechi等人[30]采用回溯算法解析模型检验器输出的反例以增强测试覆盖,利用组合性处理实际应用程序状态空间大的特性.Stefan等人[31]提出了一种基于反例解释的异常检测方法通过对比反例和正确迹(无死锁),抽取出动作序列用于帮助模型设计人员定位死锁出现的原因.目前,通过解析反例可得到测试序列和测试用例实例化,因此研究反例可用于软件测试、故障定位和分析等工作.基于模型的抽象对于理解现实系统的行为至关重要.因为对于复杂系统模型而言,模型的检验以及反例的输出都非常困难,需要抽象技术将一组行为等价或相似的动作或状态进行合并从而产生较小的行为模型.在抽象应用方面,Dams等人[32]将抽象技术扩展到PI演算方面.Saidi和Shankar[33]将谓词抽象集成到PVS系统中,该方法有利于确定模型何时进行抽象以及何时进行性质检验.Henzinger等人[34]提出了基于威胁驱动的抽象方法,它是一种懒惰抽象技术,可避免对无关状态进行计算.同样,模型检验工具BLAST在模型构造、检验、求精的循环中也采用懒惰抽象技术,使得模型检验效率得以提高.赵会群等人[35]提出了一种基于网构软件代数模型的可达性检测方法,把线性相关的网构进行压缩,从而有效地抑制状态的增长,但该方法实现比较困难.何炎祥等人[36]提出一种基于SMT求解器的路径敏感程序验证方法,利用最大强连通分量压缩循环路径,根据目标断言对控制流图进行切片,使用一种布尔表达式方法对路径空间进行抽象,结合抽象解释和符号执行技术对路径进行验证.然而,由于抽象过程中会引入一些额外的行为,导致抽象模型上产生的反例存在真实性.在抽象伪反例处理方面,Kurshan等人[19]采用局部约减方法将并发系统视为连续多个L-Process所组成,局部约减方法迭代地从采用变量依赖图描述的小局部开始,如果发现伪反例,引入一个额外的变量用来消除这一伪反例.Kurshan的方法需要预知各个部件Page14Process的行为,而在实际应用中是很难全面获取Web应用的行为的.Lind-Nielsen等人[20]设计的模型检验工具使用最小和最大近似值来处理CTL,这种近似值技术可以避免在精化步骤后重新检验整个模型.但合理选取近似值是精化迭代次数的决定因素,另外一方面考虑到CTL的反例是树结构反例,精化路由策略是发现伪反例的核心,也是最耗时的一步.Govindaraju和Dill[21]给出识别抽象反例发现的第一个伪反例的方法,但该反例与搜索策略有关.基于存在性抽象框架扩展的反例引导的抽象精化方法(CEGAR)[11,13]已经成为解决模型检验中状态爆炸问题的重要手段和技术.Aarts等人[22]提出了一种基于反例引导的抽象精化技术用于遗产系统行为自动机的学习和构造,可用于检验数据参数的等价性.Satpathy等人[23]给出了一种基于抽象精化和模型检验的测试用例产生方法,通过模型检验器产生反例表示测试用例,采用符号执行方法检验反例真实性,从而实现规格说明的覆盖以及获得精确的覆盖评估.Clarke等人[24]提出了采用BDD来证明抽象模型,用SAT-Solvers检验反例是否为伪反例,同时将精化方法运用抽象框架以消除伪反例.Stepha-nie等人[18]采用SAT求解器扩展CEGAR方法处理实时系统的安全性检验,提出了快速处理并行组合模型的抽象方法.虽然SAT求解速度很快,但是该方法处理状态时需考虑时钟变量,因此,计算量比较大且难应用于实际.在精化的控制方面,Das等人[27]提出一种基于需求驱动方式的抽象构造方法,基于反例分析,通过对抽象状态迁移关系的连续逼近实现抽象模型的逐步精化.Clarke等人[24]还提及了采用ILP和机器学习的方法来抽象精化大型复杂的系统,特别是采用机器学习的方法将产生伪反例的失效状态进行分隔.但该方法的关键因素是如何在机器学习过程中设置训练值,它与精化的效果直接相关.基于CEGAR的研究正逐渐被研究人员所接受并应用到解决实际问题中.在CEGAR应用方面,Wu等人[28]提出了基于反例引导的插值产生算法,将互模拟和SAT求解器应用到基于重解释插值的模型检验过程中,用于产生插值(Interpolation),并基于伪反例来防止插值被过度精化.前置条件对于理解、验证和调试程序非常重要.Seghir等人[37]扩展了CEGAR并将其应用到自动化前置条件的推理中,同时开发了工具P-Gen用于数组程序操作.针对多线程布尔程序的抽象策略问题,结合谓词抽象和CEGAR技术,Donaldson等人[38]提出了多线程感知的CEGAR技术并开发了工具SymmPa用于共享变量并发程序的代码分析,针对程序重复结构产生布尔程序模板,对其中状态爆炸问题采用对称技术进行简化.当然,CEGAR也可以应用到多学科交叉领域之中,如大数据、生物计算、智能交通和模式识别等方面.目前,一些学者已经开展了这些方面的应用研究.此外,针对概率系统的验证问题,Rohit等人[39]提出适用于马尔科夫检测模型的CEGAR方法框架.Hermanns等人[40]提出了概率CEGAR方法检验概率可达性性质,判断到达错误状态的概率是否超过给定的概率.然而,概率系统的建模和抽象由于引入概率计算问题,复杂度比较高,尤其是概率精度的控制.目前概率CEGAR在实际应用中未见太多的研究.6总结展望Web应用与人们的生活密切相关,是用户与互联网接触的桥梁和纽带.在信息高度发达的当今社会,确保Web应用交互行为的安全性及其所提供的功能的可用性,是可信Web应用研究的重点和难点.对Web应用的导航模型进行形式化验证是保证Web设计、开发、实现和运行的重要手段和前提保障.基于模型检验的Web应用建模与验证是非常有效的检验技术之一,但是在将模型检验应用于Web应用验证过程中常常存在状态爆炸问题.因此,迫切需要一套系统的Web应用建模和验证方法并能有效地缓减状态爆炸问题.基于以上目的,本文提出了基于On-the-fly导航模型反例引导的抽象精化OTF-MC-CEGAR方法,从Web应用的On-the-fly建模方法出发,增量式抽象Web应用导航模型,通过性质检验确认反例,并及时消除伪反例,从而有效地缓解Web应用检验过程中出现的状态爆炸问题.在进一步研究方面,Web应用导航行为除了本文所研究的替换式网页模式外,还涉及新窗口打开模式,以及Ajax技术实现的富客户端窗口模式.这些复杂模式将是我们下一步工作的重点.此外,由于时间约束和概率行为极大影响着Web应用的性能,我们还将研究基于概率的CEGAR方法在定量Web应用验证上的应用,从而实现对Web应用的功能性和非功能检验.Page15致谢在此,我们向对本文的工作给予支持和建议的所有同志表示感谢;感谢上海高校青年教师培养资助计划对本文工作的支持!
