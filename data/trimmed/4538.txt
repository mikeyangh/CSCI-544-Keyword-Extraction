Page1OnFlyP:基于定向边交换的分布式在线大图划分算法王志刚谷峪鲍玉斌于戈(东北大学信息科学与工程学院沈阳110819)摘要随着大数据时代的到来,基于云环境的大图迭代计算已经成为新的研究热点,其中提高图划分算法的执行效率和降低划分后子图之间的通信边规模是改善计算性能的关键.已有工作主要分为离线划分和在线划分两大类,无法在执行效率和通信边规模方面同时满足迭代处理需求.文中针对真实世界的大图,提出了聚簇系数概念,定量分析了顶点分布的局部性,以此为基础设计了一种基于定向边交换模型的分布式在线图划分算法(OnFlyP),可在迭代计算的数据加载阶段快速完成图划分,同时通过出边的交换有效降低通信边规模,以满足迭代计算需求.OnFlyP采用实时控制和最小对称矩阵控制实现负载均衡,前者具有较高的执行效率,而后者对降低通信边规模有较好的优化效果,可根据实际应用的处理需求灵活选择.最后,作者使用多种真实数据验证了OnFlyP算法的有效性.关键词在线大图划分;边交换;实时控制;最小对称矩阵1引言图可以表达复杂的结构和丰富的语义,其迭代分析算法在社交网络、Web、时空和科学数据计算等诸多领域都获得了广泛的应用[1-2].然而,数据规模的快速增长对高效迭代处理提出了严峻的挑战.例如,Google目前索引的网页数目已超过1万亿,而Facebook2012年的活跃用户已经超过10亿.为应对大图的迭代分析需求,近年来,基于云计算的大量分布式迭代处理系统被开发出来,如Pregel,Trinity,GPS,Giraph,Spark和BC-BSP等[3-9].这些系统通过表达力丰富的API简化了用户的分布式编程工作,并利用云计算环境的海量资源实现了大图的有效处理.图划分是Pregel等系统进行分布式计算的前提.由于图计算通常按照拓扑结构访问数据,所以每次迭代处理均会引入巨大的通信开销,这成为制约分布式处理性能的关键因素.因此,一个良好的划分算法应保证划分后的子图在负载均衡的前提下,减少子图之间的交互边(切分边)规模,从而减少网络通信.另一方面,云计算资源会随着并发处理作业数目的变化和集群中节点的增删而动态变化.Pregel等系统使用集群总任务数目来定量描述计算资源,使用空闲任务数目表征当前可用计算资源,并提供setTaskNum接口,允许用户在提交图处理作业时,根据处理需求和计算资源灵活定义本作业的任务数.因此,同一个图作业在不同时刻被提交时,其分布式任务数目不尽相同,我们称之为分布式处理粒度的弹性变化.这导致图数据需要按照当前的任务数目重新划分,划分结果的不可重用性使图划分的执行效率成为影响总计算代价的重要因素.然而,均衡图划分本身是一个经典的NP-Complete问题[10],目前的研究工作可以分为两类,以Metis[10]为代表的离线划分算法和以LDG[11]为代表的在线划分算法.前者可以显著优化切分边规模,降低迭代计算过程中的消息通信开销,因此受到学术界和工业界的广泛关注.然而,离线划分过程需要频繁访问图顶点,引入了昂贵的时间开销.面对海量图数据,例如Twitter图(4700万顶点,15亿出边),其执行时间超过8个小时[12],效率低下.在线划分算法可以在图处理系统的数据加载阶段完成图划分,仅扫描一次图数据.与离线划分算法相比,在线划分算法通过一定程度上牺牲划分效果,来获得较高的执行效率.但是,此类算法通常是集中式算法,这样便于维护复杂的启发式规则,保证相对较好的划分效果,但其扩展性显然受到单机处理能力的限制.虽然已经存在分布式在线划分算法的相关研究工作,但是启发式规则的维护开销仍然显著影响了算法的运行效率.综上所述,设计一种划分效果优异的快速的图分割算法,已经成为现有大图处理系统亟待解决的问题.实际上,真实图通常是通过广度优先搜索技术(Breadth-FirstSearch,BFS)爬取得到[13],以供Pregel等计算系统使用.我们称之为BFS生成图.这使得爬取后的真实图的顶点分布具有一定局部性,而已有的相关工作忽视了这一特性.因此,本文首先提出了反映顶点之间关联关系的聚簇系数概念,定量分析了顶点分布的局部性,然后据此设计了一种基于出边定向交换模型的分布式在线图划分算法OnFlyP.利用原始图的局部性特征,OnFlyP算法能够在保证分布式划分效率的前提下,有效降低实际计算过程中的网络通信开销.特别地,OnFlyP支持实时控制(OnFlyP-R)和最小对称矩阵控制(OnFlyP-M)两种负载均衡策略.前者可以获得更好的执行效率,而后者可以获得更佳的划分效果.在实际应用中,用户可以根据具体需求,自主选择不同策略.例如,针对单源最短路径计算等遍历式算法,迭代过程中通信压力较小,可以选择OnFlyP-R策略减少划分开销,提高整体处理效率.而对PageRank等通信密集型算法,可以选择OnFlyP-M策略以提高通信效率.综述,本文的主要贡献如下:(1)提出聚簇系数概念,定量分析了真实图(尤其是BFS生成图)的顶点分布的局部性.(2)设计了基于定向边交换模型的分布式在线图划分算法OnFlyP,并从理论上分析了BFS生成Page3图划分后的通信边规模的上界值.(3)设计了基于实时控制和最小对称矩阵控制的两种负载均衡策略,适用于不同实际需求.(4)在大量真实图上,对比了OnFlyP算法和集中式在线LDG算法,并在BC-BSP系统上验证了OnFlyP算法的有效性.本文第2节介绍相关工作;第3节通过描述Pregel系统处理流程,定义图划分概念;第4节首先分析BFS生成图的局部性特点,然后介绍OnFlyP划分算法,最后从理论上对划分效果进行分析;第5节给出实时控制和最小对称矩阵控制两种负载均衡策略,并对两种策略的适用性进行详细讨论;第6节展示真实图上的实验结果和数据分析;最后,第7节总结全文.2相关工作本节首先从离线划分和在线划分两个方面,对现有的静态的图划分算法进行介绍,然后简单总结动态的图划分方法,从而阐述本文工作与已有工作的区别.离线划分算法的一个经典处理方案是通过对原图的多级“coarsening”操作不断压缩图的规模,然后对压缩图采用Kernighan-Lin[14]或FM[15]等复杂算法进行初始划分,之后执行“uncoarsening”操作,得到最终的划分结果.Chaco[16],Metis[10]和Scotch[17]等都是面向集中式的多级划分算法库,且因划分后的子图具有较少的切分边而被业界广为青睐.此外,ParMetis[18]和PT-Scotch[19]等并行化版本可进一步提高扩展性.然而此类算法在“coarsening”阶段的最大匹配操作引入了昂贵的执行开销.因此,MLP[20]采用分布式的基于标签传播的连通域查找算法替换“coarsening”阶段的最大匹配,以降低执行开销.此外,部分工作直接采用标签传播进行图划分.例如,Ugander等人[21]提出一种分布式环境下的均衡的标签传播方法来解决图划分问题.每个顶点采取其邻居顶点具有的最多的标签作为自己的标签,而具有相同标签的顶点属于同一个划分后的子图.该方法采用线性规划来约束每个子图的大小,实现负载均衡.Rahimian等人[22]设计了JA-BE-JA算法,将顶点的标签称为color,每个顶点和自己的邻居以及部分随机顶点交换标签,以减少子图之间的交互边.JA-BE-JA采用模拟退火算法来避免算法陷入局部最优.进一步地,为满足实际应用中的多种需求,Slota等人提出一种基于标签传播的多目标划分方法PuLP[23].PuLP在不同的阶段针对不同的约束条件进行划分调整.然而,上述3种算法在标签传播过程中,每个顶点需要迭代更新自己所属的类别,所以仍需要扫描多次图数据,制约执行效率.此外,MLP区分了切分边和通信边的概念.如果从子图A指向子图B的切分边具有相同的目的顶点,那么在实际计算中,切分边产生的消息可以通过合并操作转化为一条网络消息,等价于一条通信边.因此通信边规模代表了实际的网络开销.在线划分算法假设图数据以顶点流或边流的方式到达,在流处理过程中根据已到达数据的分布信息,通过启发式规则计算决定当前图数据的划分位置.由于Pregel等系统在执行迭代计算前必须加载图数据,因此该方法可以在数据加载过程中实现图的在线划分.与Metis相比,该方法通过一定程度上牺牲切分边规模的优化效果来避免“coarsening”阶段的多次数据扫描,极大地提高了执行效率.集中式的LDG[11]和FENNEL[12]算法可以准确地实时维护数据的分布信息,保证了启发式计算结果的精度,切分边规模较少.进一步地,Nishimura等人[24]提出了“restreaming”方法,即相同的图数据被反复加载、处理时(例如,首次加载用于计算单源最短路径,第2次加载用于计算PageRank),可以利用上一次流式划分的结果,来改善本次划分的效果.实验表明,该机制可以提供与Metis近似的划分效果.PowerGraph提出了基于Vertex-Cut的Coordinated分布式流划分方法[25],通过建立分布式路由表记录数据的分布信息,实现了分布式的启发划分.鉴于Vertex-Cut机制可有效减少迭代计算的通信开销,GraphBuilder,GraphX和LightGraph等系统[26-28],均支持这种划分方法.然而,为提高路由表信息的准确性,分布式的Vertex-Cut机制必须引入昂贵的加锁开销,影响了实际运行效率.因此,PowerLyra[29]提供了一种基于Vertex-Cut和FENNEL的混合划分方式,用户需设定阈值,如果顶点的出度大于该阈值,执行Vertex-Cut以提高通信收益,否则采用FENNEL划分以提高划分执行效率并降低划分后子图的维护开销.此外,我们曾在BC-BSP[8]系统中设计了一种简单的VCCP方法[30],通过采用Vertex-Cut技术[25],可显著减少通信边规模,但对真实图会引入极大的负载偏斜.Hash划分可以视为一种最简单的分布式流划Page4分算法,其启发式规则为:通过顶点标签或边标签的HashCode值决定数据的存放位置.虽然Hash划分通常由于难以保留图的局部性而引入大量的通信开销,但可以在分布式环境下快速实现图的分割,因此被Pregel等系统作为默认的划分方式.上述图划分工作均是围绕静态图展开的,而实际应用中,对于Pregel等迭代处理系统,图是动态变化的.这是因为在迭代过程中,值达到稳定的图顶点通常不再参与后续计算,例如单源最短路径计算,所以实际参与计算的图数据是动态变化的.这使得初始的图划分可能产生负载偏斜,或者划分效果不再是最优的.因此,GPS[5],Mizan[31]和Xpregel[32]等系统均支持在迭代过程中动态重划分图数据,以提高整体运行效率.特别地,Shang和Jeffrey等人[33]分析了在不同迭代算法下图的动态变化特征,用于指导动态划分.动态划分机制是在给定的划分结果上进行动态调整.因此,与本文的工作是互补的,即本文提出的方法,也可以支持类似的动态调整操作.3问题定义本节首先以Pregel系统为例介绍了大图迭代计算流程,然后根据需求定义了图划分的相关概念.3.1大图迭代处理流程Pregel是Google公司为处理海量图数据而开发的基于BSP模型的分布式迭代处理系统.如图1所示,作为一个以顶点为中心的基于Master-Slave架构的系统,Pregel采用邻接表组织图数据.Master是分布式系统的控制中心,而Slave为工作节点.用户的图处理作业通过JobClient向Master提交,而Master将一个图处理作业分割为若干任务(Ti)并分配给Slave节点执行.具体计算流程为:(1)数据加载/划分,各任务从分布式存储系统并行加载图数据至本地,然后进行图划分,每个任务处理一个子图;(2)迭代处理,每次迭代计算视为一个超级步,两个超级步之间通过全局同步来协调各任务的处理进度,任务之间通过消息交换中间结果,在每个超级步中,图顶点接收消息、执行本地计算并发送消息,因此计算负载通常由出边数目决定;(3)迭代收敛后,保存计算结果.根据Pregel的处理流程,一个良好的图划分算法应满足如下约束:(1)在线划分,可根据任务数目,在加载的同时,在线完成图的分割;(2)任务是基本的计算单位,应满足出边数目的负载均衡;(3)减少任务之间的网络通信规模,即子图之间的通信边规模.3.2大图划分定义与传统的通用图划分不同,本节将根据3.1节的分析,定义分布式迭代计算环境下图划分的概念.定义1.图划分.给定有向图G=(V,E),包含|V|个顶点和|E|条边,图划分是将图G划分为K个子图Gi=(Vi,Ei),同时满足式(1)的约束,其中,|G|为计算负载,这里|G|=|E|,∪KEi∩Ej=,i≠j,而ρ为负载偏斜因子,理想值为1.0.式(1)中的Ecom定义2.通信边集合.给定一条边e=(u,v),如果u∈Vi∧v∈Vj,且i≠j,则称e为从子图Gi到子图Gj的一条通信边.子图Gi到Gj的所有通信边构成通信边集合Ecom我们将在第4节中,结合具体实例进一步介绍定义1和定义2.此外,为便于分析,本文假设图按照邻接表存储且图顶点按照存储顺序连续编号.4分布式在线图划分算法OnFlyP本节首先定量分析了BFS生成图中顶点分布的局部性,提出了OnFlyP划分算法,然后从理论上分析了OnFlyP算法的通信边规模的上界值.Page54.1真实图的局部性分析原始输入图通常是采用广度优先搜索(BFS)从物理世界抽取构建[13],其顶点的分布具有一定局部性,本文的OnFlyP算法正是利用这一特性来降低通信边规模.下面首先介绍相关概念.定义3.前向边集.在图的爬取过程中,假设Qw为顶点的BFS搜索队列,Qp为已搜索过的顶点队列,每次移除Qw的队首元素v,进行新的BFS扩展,然后将v放入Qp中.Γv为v的出边的目的顶点集合,则本次扩展中新加入Qw的顶点集合为Vnew={u|u∈Γv∧u(Qw∪Qp)},而与之关联的出边称为顶点v的前向边集Efor定义4.顶点分布的局部性.在BFS爬取过程中,采用邻接表顺序存储从Qw中移除的队首元素及其出边,则对于前向边集中的目的顶点,其存储顺序与图构建时的搜索顺序一致,在存储位置上相邻,称之为顶点分布的“局部性”.定义5.回溯边集.在BFS爬取过程中,令Ev为顶点v的出边集合,则与前向边集对应,回溯边集Ebackv={e|eEfor如图2所示,以1号顶点为起始顶点进行BFS搜索,邻接表中顶点的存储顺序就是原图中顶点的BFS拓扑排序结果.例如1号顶点的前向边集Efor{(1,2),(1,3)},则顶点2和3的存储位置必然是相邻的.此外,在真实世界中,顶点的出边行为通常具有相似性,即指向相同的顶点,以社交网络为例,这种相似性表现为A与B的好友在很大程度上是重叠的,比如他们共同关注某些明星.这种特性使得回溯边集中出边的部分目的顶点,与前向边集中的目的顶点相似,也具有顶点分布的局部性.定义6给出了出边分布相似性的度量方法,可用于度量图中顶点分布的局部性.定义6.出边分布的相似性.v,u∈V,使用Jaccard系数度量其出边的相似性(重叠程度[34]):s(Γv,Γu)=J(Γv,Γu)=s(Γv,Γu)值与相似性程度成正比.如图2中的顶点6,有E6={(6,2),(6,3),(6,7),(6,8)}和E1={(1,2),(1,3)},故s(Γ1,Γ6)=0.5.其中(6,7)和(6,8)属于Efor的目的顶点与Efor和{2,3}中集合内的顶点的存储位置临近.因此,s(Γ1,Γ6),可以反映出对应目的顶点分布的局部性.由上述分析可知,∑v,u∈V的顶点的规模成正比.然而,如果直接使用∑v,u∈VΓu)作为局部性的衡量指标,其过高的计算复杂度O((maxd)η)对于大图是不可行的,其中maxd为图G的最大出度,而η=|V|(|V|-1)/2,|V|为顶点数目.考虑到顶点顺序编号的情况下,编号值反映了其存储位置的“邻近程度”,因此我们采用聚簇系数来定量描述顶点分布的局部性.定义7.聚簇系数.给定真实图G=(V,E),令G和Grand的局部系数的比值为真实图的聚簇系数:C(G)=F(Grand)/F(G),其中,Grand是与真实图G对应的随机图,具有|V|个顶点和|E|条出边但顶点是随机分布的.局部系数F(G)由G中所有顶点的局部距离f(v)通过求和计算得到,f(v)的计算方式为f(v)=烄∑u∈sort(Γv烅0,烆其中,sort(Γv)表示将Γv中顶点按编号升序排序,Code(ui+1)为升序序列中第i+1个顶点ui+1的编号值.F(G)的值与局部性程度成反比,而C值则反映了真实图与随机图的局部距离的比值.给定顶点规模和出边规模后,F(Grand)的值是固定的,因此,C值与F(G)的值成反比,即与真实图的局部性程度成正比.第6节中的实验结果显示,真实图均具有较高的C值,尤其对于BFS生成图.聚簇系数只是用于验证真实图具有较高局部性的衡量指标,并不是OnFlyP算法的直接输入参数.但是这种局部性,是OnFlyP算法能够有效减少通信边规模的基础(见4.2.3小节).4.2OnFlyP划分算法OnFlyP算法依赖于4.1小节所分析的局部性,因此本节首先介绍我们在BC-BSP系统上已经实现的Range划分,可保留原始图局部性,然后描述OnFlyP划分的处理流程,最后分析BFS生成图经过Page6OnFlyP划分后,各子图间通信边规模的上界值.4.2.1BC-BSP的Range划分Range划分是保留原始图局部性(邻接表存储顺序)的一种直观方法,已被Giraph和BC-BSP所采用[6,8].在BC-BSP中,Range划分直接将原始图的邻接表文件切分为若干连续子块.若以HDFS为存储介质,在数据加载前,通过读取元数据信息,可将输入图按照字节大小均等划分为若干分片(Split),每个任务负责加载一个分片所对应的邻接表数据.K个任务并行加载的图数据直接驻留任务本地,然后建立反映顶点分布的路由信息表R={R1,R2,…,RK,RK+1},为后续迭代计算中的消息寻址提供服务.其中RK+1为G的最大顶点编号,Ri是Ti所加载图数据的最小顶点编号,且有Rx<Rx+1.给定消息的目的顶点v,根据式(2)可计算得到其所在任务Ti.i=x,RxgetId(v)<Rx+1,x∈[1,K](2)以图2为例,假设通过Range方法将原图划分为3个子图,则划分后的顶点集合为V1={1,2,3,4},V2={5,6},V3={7,8}.而路由信息表R={1,5,7,8}.由于按照字节大小均等分割,所以每个子图的负载|Gi|=|Ei|是相对均衡的.在本例中,有|G1|=5,|G2|=6,|G3|=5,负载偏斜因子ρ=1.125.Range划分保留了第4.1节中的局部分布特点.如顶点1、2和3均位于子图G1,由任务T1处理,所以边(1,2)和(1,3)不引入网络通信.注意到顶点5和6均是4号顶点的出边顶点且在存储位置上相邻,但由于三者所在子图不同,(4,5)和(4,6)成为通信边.类似地,回溯边(6,2)和(6,3)也是通信边.在4.2.2小节中,我们将介绍基于定向边交换模型的OnFlyP算法来降低上述通信边的规模.4.2.2OnFlyP划分首先引入定向边交换模型的概念.定义8.定向边交换模型.Range划分模式下,任务Ti加载的子图为Gi={Vi,Ei},任取顶点v∈Vi,则Ecom任务Tj,即为定向边交换模型.ij[v]=EcomOnFlyP划分是建立在定义8的基础之上.在OnFlyP划分中,迁移的出边Ecom以邻接表格式组织,其中Tj中的顶点v是冗余备份,记为vb,而Ti中的顶点v是主备份.为同步vb和v,迁移后为Gi添加一条出边,Ei=Ei∪{(v,Tj)}.而对Gj,有Ej=Ej∪Ecom定向迁移Ecom|Ecomij|-|Ecom时,才会降低通信边集的规模.具体地,对于顶点v,其出边迁移方向的集合为{Tx||Ecom表示v的出度顶点集合,则|Ecom后者可以通过路由表R使用式(2)快速计算得到.如图3所示,OnFlyP划分后,T1的顶点4将出边(4,5)和(4,6)迁移到任务T2,对应地,任务T2中的顶点6也将出边(6,2)和(6,3)迁移到T1,出边(6,7)和(6,8)迁移到T3.而T3中的顶点7和顶点8也做了类似处理.以G1为例,划分后,V1={1,2,3,4}∪{6,8},其中{6,8}为冗余备份顶点.任务T1与T2之间的通信边集为Ecom{(6,T1)},其中T2表示4号顶点在T2上存在冗余备份,而T1表示6号顶点在T1上存在冗余备份.显然,从网络通信角度,执行OnFlyP划分后,|EcomEcom2降为1,|Ecom21|的值由4降为2,类似地,|EcomOnFlyP算法采用Master-Slave架构,如算法1所示,在各任务加载数据前,Master首先从分布式文件系统上读取图G的元数据信息,建立K个Split分片供各任务加载图数据,然后Master读取每个分片对应的首条邻接表数据,得到每个任务负责处理的最小图顶点编号,从而构造路由表R,之后将R和Split信息发送给所有任务.算法1.分布式在线图划分算法OnFlyP.输入:待划分图G,任务数目K,图顶点数|V|输出:图划分结果{Gi}OnFlyP(G,K,|V|)1.Master:2.R=build(G,|V|);//构建路由表R3.sendRandSplitstoallTasks;4.Taski(Ti):5.receiveRandSplitifromMaster;6.WHILESpliti≠DO7.adj(v)=loadGraph(Spliti);//加载邻接表Page78.{(Tx,Ecom9.FOR(Tx,Ecom10.IFassert(Tx,Ecom11.send(v,Ecom12.updateEdges(adj(v));13.ENDIF14.ENDFOR15.ENDWHILE16.Vi=Vi∪Vb,Ei=Ei∪Esyn∪Ein;17.RETURNGi=(Vi,Ei);在Slave端,任务Ti的处理流程为:首先接收路由表R和对应的分片信息Spliti,然后逐条加载邻接表数据adj(v),将adj(v)中的出边按照定向边交换模型计算交换方向,其中(Tx,Ecomv可以迁移到任务Tx的出边集合为Ecom合{(Tx,Ecom行迁移判定,如果判定结果为true,则将(v,Ecom发送到任务Tx,同时将adj(v)的出边中的Ecom替换为Tx,否则不予处理.assert()的判定标准为当i≠x时,取|Ecom的返回值,否则assert()为false,以保证通信收益.不同的assert()判定方式将影响负载均衡和划分效果,我们将在第5节详细介绍.各任务上冗余备份顶点的集合记为Vb,用于同步冗余备份顶点的出边记为Esyn,接收的迁移边记为Ein.显然,算法1可在数据加载阶段在线完成图划分.4.2.3OnFlyP算法的通信边集与计算开销分析本节针对BFS生成图,从理论上分析OnFlyP算法划分后,子图之间的通信边集规模的上界值.引理1.图G=(V,E),假设通过OnFlyP算法分成K个子图Gi,由Gi与Gj之间的前向边集Efor所产生的通信边集记为for(Ecom则所有前向边集构成的通信边集规模的上限为{maxi,j∑i∈[1,K]∑j∈[1,K]证明.因K远小于|V|,可认为对v∈V,有v|<|Ev|=|Γv|<min{|Vi|},i∈[1,K],Γv为|Efor目的顶点集合.另一方面,由第4.1节分析知,Efor对应的目的顶点是严格连续分布的.因此,Efor迁移后,目的顶点最多跨越两个子图,而这种情况最多发生(K-1)次.因此冗余顶点的上限值为|V|+(K-1),即为通信边集规模.引理2.图G=(V,E),假设通过OnFlyP算法分成K个子图Gi,由Gi与Gj之间的回溯边集ij所产生的通信边集记为back(EcomEback于|V|,且回溯边所对应的目的顶点严格的连续分布,则G中由所有回溯边集构成的通信边集规模的上限为maxi,j∑i∈[1,K]∑j∈[1,K]证明.与引理1的证明过程类似,但由于回溯边集的目的顶点并非全局有序,每个顶点的回溯边均可能指向两个子图.所以每个顶点的回溯边被迁移后,最多产生两个冗余备份顶点.定理1.对于BFS生成图,采用OnFlyP算法划分为K个子图后,若K远小于|V|,且前向边集和回溯边集所对应的图顶点均严格连续分布,则所有子图之间的通信边集规模的上界值为3|V|+(K-1).证明.对于顶点v,其边集Ev=Eforv∩Eback有Efor份顶点规模的上限为|V|+(K-1)+2|V|.证毕.需要注意的是,OnFlyP算法虽可降低通信规模,但也增加了额外开销:备份顶点的同步消息开销和更新时的CPU计算开销,其对整体性能的影响可用式(3)估算.其中,x为备份顶点数目,cnet为一条消息的网络通信开销,ccpu为一个备份顶点更新时的计算开销,而assert()的判定标准为|Ecom2,因此降低的通信边规模X2x.此外,单位数据的网络传输开销通常大于其CPU计算开销,即cnet>ccpu,故有Φ(x)0,即不考虑负载偏斜所引起的水桶效应的前提下,OnFlyP会提高整体计算性能,且提升比例与备份顶点数目成正比.5负载均衡控制机制真实图通常存在幂率偏斜特点,即少数顶点关联了大部分边,在第4节的OnFlyP算法中,我们使ij[v]|2作为assert()的判定标准,可能会用|Ecom导致大量的出边被迁移到少数任务上,造成负载偏斜.本节我们将介绍两种负载均衡控制机制,作为OnFlyP算法中assert()的判定标准.5.1实时控制机制在实时控制机制中,我们为每个任务Ti设置一个维度为K的实时阈值向量θi.假设t时刻Gi欲向Gx执行send操作,则assert()判定方法为:如果满足|Ecomix是t时刻指向任务Tx的出边迁移阈值,而θtθt+,x∈[1,K].θtix[v]|θtPage8的结果实时更新.更新规则为:如果子图Gx在t时刻的负载大于平均负载,即real(Gx)|t>|E|/K,则send操作的返回值为false,θt则仍为2.据此,当send所指向的目的任务的负载过重时,将禁止其它任务向其继续转移出边.real(Gx)|t由式(4)计算得到,其中j,l∈[1,K]且均不等于x,load(Ex)|t是截至t时刻已加载的Gx中的出边数,t是Gx所接收的冗余顶点集合,而VsenVrec发送的冗余顶点集合.real(Gx)|t=load(Ex)|t+∑由于θt法继续更新,故之后Gi不可以向Gx转移出边,即使在t+Δt时刻real(Gx)|t+Δt|E|/K.我们称这种均衡控制机制下的划分为OnFlyP-R划分.实时控制机制是在划分时实时监控出边的定向交换,因此可以在数据加载的同时完成图数据划分,不会增加额外的划分开销.然而,该机制缺乏对全图的统计信息,考虑到各任务实际划分进度的不同,使ix被设置为无穷大的时间点具有随机性,难以保得θt证最终划分效果.例如,当任务Tx的划分进度较慢时,则t时刻子图Gx的迁出边较少,而其它任务迁移到Gx的出边较多,增大了t时刻θt大的概率.且在后续处理过程中,即使Gx继续迁移出边而导致real(Gx)|t+Δt<|E|/K,由于Gi端的θt+Δtix=θt体的出边迁移规模减少,限制了对通信边规模的优化效果.以图2中的图G为例,图4展示了实时控制机制下的一个可能的处理流程.在t0时刻,各任务完成初始化,准备加载图数据,因此实时负载均为0,阈值向量除θt始值2.假设t1时刻各子图之间产生send请求,则assert()判定结果均为true,允许执行.在t2时刻,以G1为例,已经加载5条边{(1,2),(1,3),(3,4),(4,5),(4,6)},其中{(4,5),(4,6)}迁移到G2,同时接收G2发送的出边{(6,2),(6,3)},故实时负载仍为5.需要注意的是,G1的send操作返回值为true,因为此时G2的负载为4,小于负载均值(16/3).但是G3的send操作返回值为false,因为接收G3发送的出边后,G2的负载为6,大于负载均值.所以,在t2时t2刻,θ12不变,但θ发送完出边{(8,2),(8,3)}后,G1的负载为7,超过均值,故θ才可以更新θt均衡.在最坏情况下,其余(K-1)个子图均需执行send之后,才可以完成阈值向量的更新.假设每次send的出边规模达到最大出度maxd,则负载偏斜因子为5.2最小对称矩阵控制本节介绍一种最小对称矩阵控制机制,通过两次遍历图数据,避免了实时控制机制下划分效果的不确定性.两次遍历分别完成如下工作:(1)加载数据并建立交换矩阵珨犕;(2)在珨犕的指导下,完成划分.该机制下的划分称为OnFlyP-M,算法2描述了划分过程.其中,第20行的“exchangeedges”过程,除assert()判定机制,均与算法1的第8~14行相同.算法2.最小对称矩阵控制的OnFlyP划分.输入:待划分图G,任务数目K,图顶点数|V|输出:图划分结果{Gi}OnFlyP-M(G,K,|V|)1.receiveRandSplitifromMaster;2.initializeMbymij=0;//初始化边交换矩阵3.WHILESpliti≠DO4.adj(v)=loadGraph(Spliti);//加载邻接表5.{(Tx,Ecom6.IF|Ecom7.8.9.save(adj(v));//保存邻接表数据至本地10.ENDWHILE11.initialize珨犕bym-12.FORmij∈MDOPage913.IFi≠jDO14.m-15.ENDIF16.ENDFOR17.initializegraph;//初始化图数据的本地读取句柄18.WHILEgraph.hasNext()DO19.adj(v)=graph.getNext();//读取本地邻接表数据20.exchangeedges;21.ENDWHILE22.Vi=Vi∪Vb,Ei=Ei∪Esyn∪Ein;23.RETURNGi=(Vi,Ei);M是一个K阶方阵,其中mij的值表示子图Gi与Gj之间的满足|Ecomij.矩阵建立完毕后,采用最小交换原则得到即Ecom对称的最小控制矩阵珨犕.在划分阶段,如果Gi向Gj迁移的总出边规模小于m-则为false,禁止Gi向Gj继续迁移出边.OnFlyP-M划分是建立在Range划分基础上,而Range划分本身可以保证各任务出边规模的近似均衡,故对OnFlyP-M,保证每个任务中迁入和迁出边的规模相等(对称交换),即可实现负载均衡.图5分析了OnFlyP-M算法的适用性.其中M是图G所对应的K阶方阵.这里,由于|Ecom|{(5,7)}|<2,不计入统计信息,故m23=2.此外,根据最小化原则,在最终的控制矩阵珨犕中,有m-m-31=min{m13,m31}=0.下面我们简单讨论OnFlyP-M算法的适用性.根据出边在子图之间的分布特征,我们可以归纳出3种极端分布:(1)均匀分布,指向各个子图的出边数目相同.这种分布下,对于控制矩阵珨犕,显然有m-min{mij,mji}=mij=mji.另一方面,对于无负载均衡控制的OnFlyP算法,等价于“最大控制矩阵”,m-匀分布下,OnFlyP-M可以在保证负载均衡的前提下,最大化参与迁移的出边规模,从而减少通信边ij=m-规模.(2)对角分布,各任务加载的出边均指向子图内部的顶点,子图之间没有交互边.此时已经达到最优划分,控制矩阵为0矩阵,不必执行出边迁移.(3)环形分布,当子图数目大于2时,显然有ij=m-m-参与交换的出边规模为0,无法优化通信边规模.根据第6节的测试结果,上述3种极端分布通常是不存在的.真实图中的出边分布介于3者之间,OnFlyP-M在实际应用中可以达到较好的优化效果.6实验结果与分析6.1实验方案与实验环境由于OnFlyP算法是利用原始图的局部性,实现划分效果和划分效率的综合收益,因此本文首先测试不同真实图的局部性(即聚簇系数C,见6.3小节),然后从通信边比例λ=|Ecom|/|E|和负载偏斜因子ρ(第3.2小节)两个方面测试不同划分算法在不同数据集上的划分效果(见6.4和6.5小节),之后以划分时的网络通信开销作为效率衡量标准测试了各算法的特征表现(见6.6小节),最后通过运行PageRank算法验证OnFlyP算法的实际运行效果(见6.7小节).参与对比测试的方法包括:Hash(分布式在线划分)、LDG(集中式在线划分)和OnFlyP(分布式在线划分).其中,OnFlyP算法按照均衡控制策略的不同,分为OnFlyP-B即无均衡控制策略(见4.2.2小节),用于6.3小节中测试真实图的局部性;OnFlyP-R,实时控制策略(见5.1小节);OnFlyP-M,最小对称矩阵控制策略(见5.2小节).本文在类Pregel的BC-BSP-1.0系统上实现了Hash划分和OnFlyP划分.输入数据采用邻接表组织,存放在分布式文件系统HDFS(版本:Hadoop-0.20.2).HDFS的文件块大小为默认的64MB.对于Hash划分,实现方式为将原始数据按照文件大小从逻辑上等分为K份(K为分布式任务数目,任务编号为1~K),然后各任务并行加载数据.针对每条邻接表记录,根据其源顶点的HashCode值,按照HashCode()modK+1计算其所属的任务编号,并发送到对应的任务.而LDG为集中式算法,因此输入数据和划分后的子图均位于本地文件系统.对于OnFlyP算法,先采用Range划分,将HDFS上的输入数据按照文件大小等分为K份,然后运行算法1完成划分,具体的执行逻辑随负载均衡控制策略而变化(见5.1节和5.2小节的描述).Page106.2集群配置与数据集实验集群由26台节点构成,使用一台Gigabit以太网交换机连接,每个计算节点配置酷睿i3-2100双核处理器,8GB内存,7200RPM硬盘,安装RedHatEnterpriseLinux6.1操作系统和JDK1.6.0编程环境.BC-BSP系统中每个任务,即每个JVM,内存大小设定为3GB.全部实验在4个真实图数据集上完成,包括Web数据:Ber-Stan①与Wiki②,和社交网络数据:S-LJ③与Twitter[35],具体描述如表1所示.其中,|V|表示图顶点的数目,而|E|表示出边数目.Ber-Stan是BFS生成图,其余3个数据集的性质未知.数据集Ber-StanS-LJWikiTwitter6.3真实图的局部性分析我们在4个真实数据集上测试OnFlyP-B划分方法,以证明真实图具有良好的局部性以及对OnFly-B算法的影响.表2展示了K=10时的测试结果.其中C为第4.1节中的聚簇系数,λ^是采用4.2.3小节中定理1得到的BFS图的λ上界值.数据/指标Ber-StanS-LJWikiTwitter显然,C越大,局部性越佳,实际λ值越低.然而,由于OnFlyP-B未采取负载均衡控制策略,所以负载偏斜因子ρ的值均比较大.此外,非BFS生成图的C均小于BFS生成图Ber-Stan,故λ值高于Ber-Stan.特别地,对于C值较小的Wiki,有λ大于上界值λ^.这是因为Wiki图的局部性相对较差,不能满足回溯边集目的顶点的严格连续分布,破坏了4.2.3小节中引理2的前提条件,导致冗余备份顶点的规模大于理论上限值2|V|,因此实际λ值比理论估计值λ^偏大.6.4划分效果分析本小节介绍Hash,LDG,OnFlyP-R和OnFlyP-M4种算法在不同数据集上的划分效果.本小节实验均设置K=20.图6展示了λ值.显然,Hash划分会导致90%以上的边成为通信边,这会在后续迭代计算中引入大量的通信开销.而集中式LDG和分布式OnFlyP-R则可以将λ值降低为40%至80%,OnFlyP-M进一步将该值降低为13%至45%.其中,除Hash外,其余3种划分算法对于原始图的局部性敏感.特别地,对于BFS生成图Ber-Stan,LDG算法的通信边规模是OnFlyP-M算法的2.6倍;Hash算法的通信边规模是OnFlyP-M算法的7.25倍.图7则对比了各种划分算法的负载偏斜因子.其中,Hash划分由于无法考虑出边数目的均衡,因此在幂率图Twitter上,ρ值较大,为1.53.此外,OnFlyP-R由于分布式环境下的负载检测具有滞后性,导致负载偏斜因子略高于1.0.而OnFlyP-M的偏斜由Range划分决定,由于后者只能保证各子图负载近似均衡(见4.2.1小节),故ρ≈1.0.6.5犓值对划分效果的影响本组实验分别在S-LJ和Twitter数据集上测试了不同K值对各种划分算法的λ值的影响.如图8和图9所示,随K值变化,OnFlyP-M的λ始终最低.①②③Page11特别地,对于S-LJ上的OnFlyP-R算法,随着K值增大,λ值逐渐降低.这是由于分布式粒度的增大,延迟了θt交换的出边规模增大,因此降低了λ值.理论上,当分布式任务的水桶效应较低时,OnFlyP-R算法的λ值有可能小于OnFlyP-M算法.然而,真实图通常具有幂率偏斜特点,尤其是Twitter,少数顶点关联了大部分出边,因此,在实际实验过程中,OnFlyP-R算法的λ值均大于OnFlyP-M算法.图10和图11则展示了不同K值对负载偏斜因子ρ的影响.LDG,OnFly-R和OnFly-M这3种划分算法对于数据集和K值的变化不敏感.而对Hash划分,由于Twitter数据集中顶点的出边规模具有幂率偏斜特性,故难以保证出边数目的均衡,ρ值较大.而K的不同取值,可能导致高出度顶点的分布发生随机变化,故ρ值随K的变化呈现随机波动.如图11所示,当K=10,15,20,25时,ρ值为1.51,1.26,1.53,1.24.6.6网络通信开销分析对于Hash,OnFlyP-R和OnFlyP-M划分,各任务加载的数据不一定驻留本地,例如任务Ti加载的数据,经过Hash运算后,需要通过网络发送给任务Tj维护.而对OnFlyP-R和OnFlyP-M划分,其加载的出边也可能需要通过网络发送给任务Tj.我们称该过程为shuffle阶段.显然,shuffle阶段会引入网络通信开销,且主要与参与shuffle的出边数目|ShuffleEdge|成正比.为便于对比不同数据集在划分时的网络开销,我们定义ratio=|ShuffleEdge|/|E|,作为衡量指标.由于LDG属于集中式划分算法,不计入对比分析.图12显示了不同划分算法在各种真实数据集上的测试结果(K=10).Hash划分由于不考虑局部性,大量出边被迁移,因此ratio值较高.而OnFlyP-R和OnFlyP-M仅需要迁移部分出边数据,且OnFlyP-R由于实时负载监控导致θt前被设置为无穷大,故迁移边规模小于OnFlyP-M.图13和图14分析了任务数目(子图数目)K对ratio的影响.对于OnFlyP-R和OnFlyP-M算法,Page12图8与图9和图13与图14的对比进一步表明ratio值与λ值成反比,即参与迁移的出边越多,对通信的优化效果越明显.6.7不同划分算法对实际迭代性能的影响我们在BC-BSP系统上运行PageRank算法,来验证各种划分方法对于提高实际迭代处理性能的效果.本实验采用Twitter数据,K=25,PageRank运行中平均每次迭代的计算时间如表3所示.其中划分时间包括数据加载开销、shuffle阶段的网络开销(6.6小节)和划分后的数据本地组织与存储开销三部分.特别地,由于LDG是集中式算法,本文首先在一台物理机上对数据完成LDG划分,然后将划分后的子图分别上传到HDFS,最后由BC-BSP系统的分布式任务按照Range划分,分别加载到本地并完成迭代计算.这里,每个子图是一个单独的文件,由一个任务独立加载.因此,LDG的划分时间,仅包含单机处理时间.表3不同划分算法在BC-BSP系统上的运行效果划分算法HashLDGOnFlyP-ROnFlyP-M在BC-BSP系统中,各任务加载的数据均是通过Split方式按照字节大小均衡切分得到,因此Hash,OnFlyP-R和OnFlyP-M的加载时间相同.根据6.6小节的分析,Hash划分由于需要大量交换图数据,网络开销增大,划分时间较高.OnFlyP-M由于需要扫面两次数据且shuffle的数据规模较多,所以划分时间高于OnFlyP-R.与上述3种方法对比,受单机处理能力限制,集中式LDG的划分时间最高.另一方面,从每步迭代时间来看,LDG划分下的迭代性能比Hash快18%,与文献[11]所报告的结果相近;而OnFlyP-M划分下的迭代性能比Hash划分快27%.从实验结果可知,OnFlyP-R和OnFlyP-M,分别在提高执行效率和降低通信边规模方面有较好的效果.对高频迭代算法,可选择OnFlyP-M,虽然执行效率略低,但是累加的迭代收益,会使整体性能优于OnFlyP-R;反之,应该选择OnFlyP-R.7结论和进一步工作分布式大图处理系统的研究与广泛应用,对图划分算法的效果和执行效率提出了严峻挑战.本文利用真实世界中图的局部性,在两种指标上获得了综合收益.具体地,本文首先提出聚簇系数概念,定量分析了顶点分布的局部特性,并在大量真实图上验证了结论的可靠性.其次,以真实图的局部性为基础,设计了高效的分布式在线图划分算法OnFlyP,支持实时控制(OnFlyP-R)和最小对称矩阵控制(OnFlyP-M)两种负载均衡策略,可由用户根据实际应用需求自行选择.大量真实图的实验结果和在BC-BSP系统上的实际迭代性能表明,OnFlyP在执行时间和划分效果方面,均优于现有的在线划分算法Hash和LDG.其中,OnFlyP-R的执行时间比OnFlyP-M的执行时间略低,但后者具有较低的通信边规模,对于高频迭代应用中网络通信开销的优化效果显著.根据OnFlyP-R和OnFlyP-M的实验对比结果,显然参与shuffle的出边规模与通信收益成正比.然而,目前的最小对阵矩阵控制机制,在面对环形分布或近环形分布(5.2小节)时,会严重降低shuffle的出边规模.实际上,最小对称矩阵的计算过程是针对仅有2个顶点构成的环路,可以扩展到环形分布中的多顶点环路.因此,下一步工作将研究环形分布下的控制矩阵计算方法,以增大出边交换的总规模,进一步降低通信边比例,提高OnFlyP-M算法的适用性.
