Page1操作系统形式化设计与安全需求的一致性验证研究钱振江1),2),3)黄皓1)宋方敏1)1)(南京大学计算机科学与技术系南京210046)2)(常熟理工学院计算机科学与工程学院江苏常熟215500)3)(伦敦大学国王学院伦敦英国WC2R2LS)摘要采用数学形式化方法对操作系统进行设计和验证可以保证系统的高度安全性.目前已有的操作系统形式化研究工作主要是验证系统的实现在代码级的程序正确性.提出一种操作系统形式化设计和验证的方法,采用操作系统对象语义模型(OSOSM)对系统的设计进行形式化建模,使用带有时序逻辑的高阶逻辑对操作系统的安全需求进行分析和定义.对象语义模型作为系统设计和形式化验证的联系.以实现和验证过的可信微内核操作系统VTOS为实例,阐述形式化设计和安全需求分析,并使用定理证明器Isabelle/HOL①对系统的设计和安全需求的一致性进行验证,表明VTOS达到预期的安全性.关键词操作系统;形式化设计;安全需求;一致性验证;定理证明;信息安全;网络安全1引言操作系统(OperatingSystem,OS)作为系统软件,由于其复杂性,其设计和实现的正确性很难用定量的方式进行描述和说明,而操作系统的正确性是信息安全的基础.采用形式化的方法对操作系统进行设计和验证[1-3]是操作系统领域公认的标准方法.澳大利亚NICTA实验室主导的seL4操作系统项目[1,4]在系统设计过程中采用函数式语言Haskell[5]来搭建系统原型,方便后期直接转换为形式化定理证明器Isabelle/HOL[6]所需的程序逻辑输入.seL4对系统按照不同的实现层次进行抽象,通过说明各种抽象层次在功能语义上的一致性来达到验证的目的[7-8].Verisoft项目提出对计算机系统进行普适形式化验证(pervasiveformalverification)[2],以实现对操作系统从底层硬件抽象到高层应用软件的完全验证[9],验证的层次是代码级的验证,即系统实现的正确性验证[10].耶鲁大学Shao等人领导的Flint项目对系统的程序验证逻辑进行改进[3],主要是对系统的各种功能模块的混合验证方法进行改进,目的是提高验证的效率[11-12].本文认为,采用形式化方法对操作系统进行设计和实现,以此来说明系统的正确性和保证系统的安全性,为达到这样的目的,首先需要使用形式逻辑验证操作系统的设计是否满足对系统的安全需求,进而验证操作系统的实现是否满足设计的要求.本文提出,不仅对系统实现(代码级)的验证需要使用形式化的方法,在系统设计(设计级)的过程中就需要使用形式逻辑来保证设计的正确性,从而最大程度上保证系统的正确性.本文提出一种形式化设计和验证相结合的方法,使用对象语义模型(OperatingSystemObjectSemanticsModel,OSOSM)[13]作为系统设计和验证之间的联系,利用包含时序逻辑(TemporalLogic,TL)[14]的高阶逻辑(Higher-OrderLogic,HOL)[15]描述系统的安全需求,并以我们实现的可信操作系统(VerifiedTrustedOperatingSystem,VTOS)为例,阐述使用形式化定理证明器Isabelle/HOL对系统的设计和安全需求的一致性进行验证的方法.本文第2节以VTOS微内核为例,采用微内核OS对象语义模型进行形式化建模;第3节对微内核OS的安全需求进行分析,并使用带有时序逻辑的高阶逻辑进行严格定义;第4节阐述使用定理证明器Isabelle/HOL对形式化设计与安全需求的一致性验证;第5节对本文的工作进行总结,并对我们进一步的研究方向进行展望.2对象语义模型本节阐述对象语义模型OSOSM的基本框架.OSOSM是一种针对操作系统的框架语义模型[13],将系统中各种行为的执行功效看成是对系统状态的改变或者迁移,对应地,将系统行为的主客体作为对象来看待,系统状态的转化看成是系统中行为的主客体对象相互作用的结果.OSOSM对系统的描述采用状态机的方式,使用状态轨迹来表达系统的运行变化.2.1OS对象的抽象OS为其他各种功能性的上层应用软件提供平台的支撑,是一个服务系统,对其他功能模块提出的服务请求、以及中断事件作出响应.OS对服务请求和中断事件的响应是通过系统行为来完成的,系统行为的主体通过对内核或者用户数据客体的检索、读取、修改或者创建等动作来完成功效.例如用户进程通过发送消息给服务进程请求进行系统调用,OS的消息处理行为根据用户进程和服务器的进程控制块、内核数据、系统状态等对象来完成功效.我们可以将系统行为的主客体抽象为对象,系统行为的功效是通过主客体的相互作用来完成的,进而实现对系统状态的改变.在这样的对象抽象的场景下,下一小节重点阐述OSOSM的整体框架.2.2OSOSM框架OSOSM采用分层结构,是一种开放式的框架语义模型,可以描述OS的功能模块的行为语义.OSOSM按照基本功效、具体实现、实现优化的递进层次来分层,区别于按照软件功能模块和硬件抽象的分层方式.为此,OSOSM层级结构包含基本功效层、实现层和优化层.基本功效层描述系统行为动作对系统状态改变的基本功效,关注系统状态改变的结果,不涉及处理的具体细节.实现层描述为了实现基本功效层的功能功效而引入的其他关键对象和行为语义函数.与指称语义[16]的概念相同,OSOSM使用对象集合上的语义函数来描述系统行为的功能语义.优化层描述为了提高实现层的语义函数和具体实现细节的效率和性能而引入的新的对象和语义函数.Page3为了表述的方便,我们以完全自主研发的安全可信操作系统VTOS为例来阐述OSOSM框架.VTOS是一种微内核架构的OS,设计和实现部分均经过形式化的验证,达到一定的安全标准级别.VTOS拥有安全核(securekernel)和访问控制机制,实现了虚拟内存管理、多核和多线程管理、文件系统管理以及安全网关等功能.限于篇幅,我们结合图1VTOS微内核OSOSM框架2.2.1基本功效层(1)对象集合基本功效层对象集合M1包含以下对象:①消息message=(m_source,m_type,m_content),m_source为消息发送进程对象标识,m_type为消息类型,m_content为消息体;②进程对象process=(proc_nr,p_messbuf,p_rts_flags,p_getfrom,p_sendto),proc_nr为进程对象标识,p_messbuf为消息缓冲区,p_rts_flags指示进程对象是否处于等待发送消息状态或者是等待接收状态,取值如RECEIVING和SENDING;p_getfrom为希望接收消息的目标进程对象标识;VTOS微内核部分的形式化设计和验证来阐述.VTOS微内核为服务进程以及设备驱动程序等提供功能服务,主要负责消息处理、进程调度以及中断处理.VTOS微内核OSOSM框架如图1所示.以下小节,对VTOS微内核的功能语义进行分解,包括对象以及行为语义.p_sendto为希望发送消息的目标进程对象标识;③系统状态state=(pset,process_q,sys_buffer,intr_source,next_running_proc),pset为当前进程对象的集合,process_q为就绪进程队列;sys_buffer为系统缓冲区,intr_source为中断源;next_running_proc为下一个将要运行的进程对象标识;④系统状态集S,S为系统状态state的集合.(2)行为语义①消息处理行为.在基本功效层,从功效上来说,微内核的消息处理行为是将发送者进程对象所指示的消息缓冲区中的消息体复制到接收者进程对象所指示的消息缓冲Page4区中.在这一层,我们主要考虑系统行为功效的完成.假设在状态s时进程p1向进程p2发送消息,在状态w时完成这一功效.其功效用逻辑公式表示如下:sendp1p2:w.pset.p2.p_messbuf··=s.pset.p1.p_messbuf烄ifs.pset.p2.p_rts_flags=RECEIVING∧(s.pset.p2.p_getfrom=ANY∨烅s.pset.p2.p_getfrom=p1)烆invariableifother假设在状态s时进程p2接收进程对象p1的消息,在状态w时完成这一功效.其功效用逻辑公式表示如下:receivep2p1:w.pset.p2.p_messbuf··=s.pset.p1.p_messbuf烄ifs.pset.p1.p_rts_flags=SENDING∧烅s.pset.p1.p_sendto=p2烆invariableifother②进程调度行为.VTOS微内核的进程调度行为包括schedule,dequeue和pick_proc操作行为.schedule是将被调度的进程对象加入到就绪进程队列中.假设在s状态下调度进程对象p,在状态w时完成这一功效.其功效用逻辑公式表示如下:dequeue将进程对象从进程队列中去除.如果一个进程对象被阻塞,那么这个进程对象将从进程队列中去除.假设在s状态下阻塞进程对象p,在状态w时完成这一功效.其功效用逻辑公式表示如下:pick_proc选择下一个将要运行的进程.在基本功效层,pick_proc不进行调度优化,为此选择进程队列首部的进程对象占有处理器CPU资源,这主要通过对系统状态state中next_running_proc域进行赋值来完成.VTOS微内核将在下一个时钟中断处理完成后切换next_running_proc域指向的进程对象来运行.关于调度优化部分,将在优化层进行阐述.假设在s状态下选择进程对象p占有CPU资源,在状态w时完成这一功效.其功效用逻辑公式表示如下:其中head操作子表示取队列的首部.pick_proc:w.next_running_proc··=heads.process_q③中断处理行为.VTOS微内核对硬件中断的处理,主要是通过发送消息给驱动程序进程对象,由驱动程序进程对象来进行相应的中断服务处理.在VTOS微内核对象语义模型中,从对象层次来说,VTOS微内核的中断处理行为的功效是根据不同的中断源,对系统缓冲区对象进行设置.本文主要描述键盘中断和磁盘中断.假设在s状态下发生键盘中断或者磁盘中断,在状态w时完成这一功效.其功效用逻辑公式表示如下:interrupt_handle:w.sys_buffer··=data_from_diskifs.intr_source=INTR_DISK烄data_from_input烅ifs.intr_source=INTR_KEYBOARD烆invariableifother其中data_from_disk表示从磁盘输入的数据,data_from_input表示从键盘输入的数据.2.2.2实现层涉及的其他数据对象和相关的语义函数.我们在设计上,对VTOS消息处理行为采用“汇合”机制,对方进程对象不在接收消息的情况下,发送进程将会阻塞;类似地,对方进程对象不在发送消息的情况下,接收进程将会阻塞.同时,由于各种执行主体作为独立的进程对象运行,消息处理的“汇合”机制导致系统中进程对象的过分同步,造成性能的下降,有可能引起死锁现象.为此,在实现层,我们在VTOS的消息处理行为中同时加入异步机制,引入一种特殊的消息方式,称为“通知”.如果接收者不在等待消息或者通知,通知的发送者也不会阻塞.通知信息不会丢失,该通知只是简单地被挂起.当目标进程执行接收动作时,通知将优先于消息被处理.在通知的设计上,通知体只包含发送者的标识信息,不包含具体的内容信息,接收者如果需要其他的必要信息,可以通过向发送者发送消息来请求相应的内容.实现层阐述实现基本功效层的系统行为功效所(1)对象集合实现层对象集合M2的定义如下:Page5①M2包含基本功效层对象集合M1;②进程对象process.实现层的进程对象process在基本功效层的基础上增加相应的数据成员对象:p_lastcall,s_notify_pending和s_msg_pending.p_lastcall为进程对象最近一次消息行为语义的标识信息.由于消息处理行为的语义函数需要保存结果信息,为此我们在进程process对象中引入p_lastcall对象来保存语义函数信息.p_lastcall=(nr_sys_call,result),其中nr_sys_call是行为标识,取值如SEND,RECEIVE和NOTIFY;result是语义函数结果信息,取值如ELOCKED(标识死锁),OK(标识消息处理行为完成,发送或者接收行为成功或者进程对象阻塞);s_notify_pending是记录所有向该进程对象发送通知的进程对象标识链表;s_msg_pending是记录所有向该进程对象发送消息的进程对象标识链表.(2)行为语义实现层行为语义主要包括消息处理行为send,notify和receive.①消息的处理行为send.假设在状态s时进程对象p1向进程对象p2发送消息,在状态w时完成这一功效.send行为在实现层的逻辑语义分情况描述如下:i.当目标进程对象p2也在发送消息,并且该消息的目标进程是p1,那么就会产生死锁.此时,系统状态state的变化主要为:进程对象p1中的p_lastcall值变为(SEND,ELOCKED),即记录发送进程对象在进行发送消息行为时发生死锁,等待系统的处理,其语义表示如下:w.pset.p1.p_lastcall··=(SEND,ELOCKED)ii.当目标进程p2正在等待消息,并且等待消息的来源进程标识是ANY或是发送进程p1,那么消息就成功发送,并修改目标进程p2的状态信息,将目标进程p2唤醒加入到进程队列,其语义表示如下:w.pset.p1.p_lastcall··=(SEND,OK)w.pset.p2.p_messbuf··=s.pset.p1.p_messbufw.pset.p2.p_rts_flags··=s.pset.p2.p_rts_flags-RECEIVINGschedule(p2)iii.当上面两种情况都不符合的情况下,发送进程p1进入阻塞状态,同时修改发送进程对象信息,并将发送进程对象p1加入到进程对象p2的等待发送消息进程对象链表(s_msg_pending域),其语义表示如下:w.pset.p1.p_lastcall··=(SEND,OK)w.pset.p1.p_rts_flags··=w.pset.p1.p_sendto··=p2w.pset.p2.s_msg_pending··=dequeue(p1)②通知的发送行为notify.假设在状态s时进程对象p1向进程对象p2发送通知,在状态w时完成这一功效.notify行为在实现层的逻辑语义分情况描述如下:i.如果进程对象p2处于接收状态,即w.pset.p2.p_rts_flags=RECEIVING,并且在等待p1或者ANY,那么p1直接将通知发送给p2,并修改p2的状态,将p2唤醒加入到进程队列,其语义表示如下:w.pset.p1.p_lastcall··=(NOTIFY,OK)w.pset.p2.p_messbuf··=(p1,Notify,NULL)w.pset.p2.p_rts_flags··=s.pset.p2.p_rts_flags-RECEIVINGschedule(p2)ii.如果进程对象p2不处于接收状态,通知不能成功发送,发送进程不会被阻塞.同时,该通知需要被挂起,以便将来进程对象p2能进行处理,我们采用的方法是在进程对象p2的s_notify_pending链表中记录下p1的标识信息.其语义表示如下:w.pset.p1.p_lastcall··=(NOTIFY,OK)w.pset.p2.s_notify_pending··=s.pset.p2.s_notify_pending#p1③消息的接收行为receive.假设在状态s时进程对象p2对发送给它的通知和消息进行处理,在状态w时完成这一功效.receive行为在实现层的逻辑语义分情况描述如下:i.如果存在进程对象正在向进程对象p2发送通知,则优先处理,这主要通过查看进程对象p2的s_notify_pending域来确定.s_notify_pending记录的通知信息从链表首部开始处理.由于采用异步模式发送通知,为此不需要唤醒链表首部对应的发送进程.其语义表示如下:w.pset.p2.p_lastcall··=(RECEIVE,OK)w.pset.p2.p_messbuf··=(heads.pset.p2.s_notify_pending,Notify,NULL)Page6w.pset.p2.s_notify_pending··=tails.pset.p2.s_notify_pending其中,tail操作子表示取链表除首部以外的部分;ii.如果不存在向进程对象p2发送的通知,但存在向进程对象p2发送的消息,这通过p2.s_msg_pending域进行判断.对于消息的处理,如果进程对象p2的接收对象(p_getfrom域)为ANY,则顺序从链表首部开始处理;否则,检查接收对象是否在s_msg_pending链表对象中,并进行相应的处理.其语义表示如下:w.pset.p2.p_lastcall··=(RECEIVE,OK)w.pset.p2.p_messbuf··=w.pset.(heads.pset.p2.s_msg_pending).p_messbuf烄ifs.pset.p2.p_getfrom=ANYw.pset.(s.pset.p2.p_getfrom).p_messbuf烅ifs.pset.p2.p_getfrom≠ANY∧s.pset.p2.p_getfrom∈s.pset.p2.s_msg_pending烆invariableifotherw.pset.(heads.pset.p2.s_msg_pending).p_rts_flags··=w.pset.(heads.pset.p2.s_msg_pending).p_rts_flags-RECEIVINGifs.pset.p2.p_getfrom=ANYw.pset.p2.s_msg_pending··=tails.pset.p2.s_msg_pending烄ifs.pset.p2.p_getfrom=ANYs.pset.p2.s_msg_pending\s.pset.p2.p_getfrom烅ifs.pset.p2.p_getfrom≠ANY∧s.pset.p2.p_getfrom∈s.pset.p2.s_msg_pending烆invariableifotheriii.如果进程对象p2的接收对象不处于发送状态,那么接收进程p2将被阻塞.其语义表示如下:w.pset.p2.p_lastcall··=(RECEIVE,OK)w.pset.p2.p_rts_flags··=s.pset.p2.p_rts_flags+RECEIVINGdequeue(p2)w.pset.(s.pset.p2.p_getfrom).p_rts_flags··=s.pset.(s.pset.p2.p_getfrom).p_rts_flags-RECEIVINGifs.pset.p2.p_getfrom≠ANY∧s.pset.p2.p_getfrom∈s.pset.p2.s_msg_pendingifs.pset.p2.p_getfrom=ANYifs.pset.p2.p_getfrom≠ANY∧s.pset.p2.p_getfrom∈s.pset.p2.s_msg_pendingschedule(heads.pset.p2.s_msg_pending)schedule(s.pset.p2.p_getfrom)2.2.3优化层优化层描述为了提高实现层的语义函数和具体实现细节的效率和性能而引入的新的对象和语义函数.为了高效地组织进程队列,我们按照进程优先级引入多级进程队列.(1)对象集合优化层对象集合M3定义如下:①M3包含实现层对象集合M2;②进程对象process.优化层的进程对象process在基本功效层和实现层的基础上增加相应的数据成员对象:p_priority和p_ticks_left.p_priority是进程对象的优先级,VTOS在设计上包含16级优先级队列,取值范围为0~15,0为最高级;p_ticks_left是进程对象的剩余时间片,用于衡量和计算进程对象的优先级;③系统状态state,优化层的系统状态state在基本功效层和实现层的基础上增加相应的数据成员对象:prev_proc,记录当前状态的上一个运行的进程对象;④在基本功效层和实现层中,系统状态state的process_q数据域是一个进程队列对象,由于我们在优化层引入多级进程队列,为此process_q数据域在优化层作为多级进程队列来看待,具体为一个从进程优先级到对应优先级的进程队列的映射,即输入一个进程优先级,得到该优先级对应的进程队列,从而实现多优先级进程队列.(2)行为语义针对优化层引入的多级进程队列对象,系统行为语义主要涉及对多级进程队列对象的操作,包括进程调度行为schedule,dequeue和pick_proc.多级进程队列入队操作行为schedule.在基本功效层,schedule行为将就绪进程对象插入到进程队列中.在优化层,由于引入了多优先级进程队列,为此首先需要根据进程的优先级和时间计算进程应该位于哪个队列,以及放在队列的首部或者尾部位置.假设在状态s时,系统执行“将进程对象p放进多优先级进程队列”的动作,在状态w时完成这一功效.schedule在优化层的逻辑语义分情况描述如下:①当进程对象p的p_ticks_left域不为0时,表示进程对象p时间片未用完,将进程p放入进程对象优先级p_priority域所对应的优先级队列的首部,其语义表示如下:Page7w.process_qs.pset.p.p_priority··=p#(s.process_qs.pset.p.p_priority)ifs.pset.p.p_ticks_left≠0②当进程对象p的p_ticks_left域为0,并且进程对象p不是内核进程(proc_nr>0),同时在系统的上一时间片已占有CPU资源(w.prev_proc=p),并且进程对象p不是最低优先级(p_priority<15)时,那么应该降低进程对象p的优先级,VTOS采用优先级增加1来实现,同时将进程对象p放入新的优先级队列的尾部,其语义表示如下:w.pset.p.p_priority··=s.pset.p.p_priority+1w.process_q(s.pset.p.p_priority+1)··=(s.process_q(s.pset.p.p_priority+1))#pifs.pset.p.p_ticks_left=0∧③当进程对象p的p_ticks_left域为0,并且进程对象p不是内核进程(proc_nr>0),同时进程对象p在系统的上一时间片未占有CPU资源(w.prev_proc≠p),并且进程对象p不是最高优先级(p_priority>0)时,那么应该提高进程对象p的优先级,VTOS采用优先级减少1来实现,同时将进程对象p放入新的优先级队列的尾部,其语义表示如下:w.pset.p.p_priority··=s.pset.p.p_priority-1w.process_q(s.pset.p.p_priority-1)··=(s.process_q(s.pset.p.p_priority-1))#pifs.pset.p.p_ticks_left=0∧④对于其他情况,将进程对象p放入进程对象优先级p_priority域所对应的优先级队列的尾部,其语义表示如下:w.process_qs.pset.p.p_priority··=队列中去除,其语义表示如下:(s.process_qs.pset.p.p_priority)#pifother多级进程队列出队操作行为dequeue.对应地,dequeue行为将进程对象从多优先级w.process_qs.pset.p.p_priority··=(s.process_qs.pset.p.p_priority)\p进程选择操作行为pick_proc.pick_proc行为在基本功效层选择下一个将要运行的进程,由于在优化层引入多优先级进程队列,pick_proc将在多级队列中选择就绪进程,按照优先级从高到低的顺序检查各级队列,每个队列中从首部开始选取.假设在s状态下选择多级进程队列中的进程对象占有CPU资源,在状态w时完成这一功效.其语义表示如下:pick_proc:w.next_running_proc··=pick_ps015子过程pick_ptbeginend定义如下:pick_ptbeginend··=pick_pt(begin+1)end烄ift.process_qbegin=NULL∧begin<endhead(t.process_qbegin)烅ift.process_qbegin≠NULLIDLE烆ifother3VTOS系统安全需求本节阐述VTOS系统的安全需求分析,并使用带有时序逻辑的高阶逻辑对安全需求进行了严格的定义.对于VTOS微内核部分,考虑到安全需求的多样性以及可验证性,我们主要分析的安全需求类型包括完整性、隔离性和机密性.对于完整性,传统的理解认为在系统运行过程中需要保证系统代码的完整性和数据完整性,即代码和数据不可被恶意地修改,这些可以通过访问控制策略实现.除了代码和数据完整性,我们认为还需要做到系统功效的完整性,即系统的功能行为始终能完成系统设计所期望的效果.对于隔离性,主要包括进程空间隔离性和进程行为的隔离性.进程空间隔离性是指进程对象的页表相互之间不存在交集.进程行为隔离性是指进程在运行过程中,相互之间不会干扰对方的行为.对于机密性,进程对象无法访问其他进程对象的私有数据部分,即进程对象的私有数据不会泄露给其他进程对象.限于篇幅,本文主要从系统功效完整性和进程行为隔离性这两方面,来对VTOS微内核的安全需求进行分析、定义和验证.OSOSM以高阶逻辑(Higher-OrderLogic,HOL)为元逻辑,支持基本的逻辑命题演算,并且包括简单类型理论(simpletypetheory)和类型化的λ演算(typedlambdacalculus),提供丰富的对象表达能力.在第2节的基础上,我们使用VTOS微内核的语义函数并结合时序逻辑来阐述VTOS的安全性Page8目标,其中时序逻辑主要是对安全需求中与时间有关的问题进行描述.下一小节首先对需求描述用到的时序逻辑进行说明.3.1时序逻辑时序逻辑用于描述系统关于时间问题的需求,包括线性时序逻辑(LinearTemporalLogic,LTL)和计算树逻辑(ComputationTreeLogic,CTL).LTL对时间的描述是线性(严格偏序)的,即在时间序列上任意两个时间点都是有前后关系的;CTL主要用于描述分支时间(branching-time)序列结构,即在时间序列上每个时间点允许存在分支的不同直接前驱和直接后继时间节点.时序逻辑中讨论的是时间序列,而OSOSM采用状态机的方式对系统进行描述,即描述的是状态序列.为此我们在使用时序逻辑对VTOS的安全需求进行描述时,将状态序列作为时间序列来看待.这存在一个问题,时间序列不存在“回归”现象,是一种树结构,而状态序列可能存在“回归”现象,即环结构,如s0→s1→s2→s3→s4→s0,这与时间序列存在不一致.为此我们对状态序列的描述进行不回归处理,如上述的状态序列表示成s0→s1→s2→s3→s4→s5,其中s0=s5.VTOS在每个状态下可能的后继状态是不确定的,这主要由系统的行为动作决定,因此是分支状态序列结构.我们采用CTL对VTOS的安全需求进行描述.CTL的时序描述符主要包括:路径分支描述A/E和序列路径描述G/F/X.假设θ为分支路径命题,时序描述符A/E定义如下:sAθ表示“从状态s开始,对于所有状态路径,命题θ成立”;sEθ表示“从状态s开始,存在某条状态路径,该路径上命题θ成立”;假设φ为序列路径命题,即对于单条路径的命题,时序描述符G/F/X定义如下:sFφ表示“从状态s开始,在单路径上将来某个状态,命题φ成立”;sGφ表示“从状态s开始,在单路径上将来所有状态,命题φ成立”;sXφ表示“在单路径上,对于状态s的下一个状态,命题φ成立”.路径分支和序列路径描述符相结合如图2所示.CTL中没有表示“动作对状态路径分支的影响”的方法,我们对其进行扩展,使用“s,action├β”来表示“在当前状态s下执行action动作后,在后续状态路径会满足β”,即当前状态s的直接后继根据action动作可以得到确定,如图3所示.以下章节从系统功效完整性和进程行为隔离性这两方面,并从消息处理、进程调度和中断处理的角度,开始对VTOS微内核行为的安全需求进行分析.3.2消息处理行为的功效完整性安全需求(1)消息发送行为send能正确地将发送者进程对象所指示的消息缓冲区中的消息体复制到接收者进程对象所指示的消息缓冲区中.谓词公式表示如下:s∈S,p1∷process,p2∷process.(s,(sendp1p2)├EF(λw∷state.w.pset.p2.p_messbuf=其中,λ运算用于对完成功效的状态进行抽象.对应地,通知发送行为notify能正确地将通知发送到接收者进程对象.谓词公式表示如下:s∈S,p1∷process,p2∷process.(s,(notifyp1p2)├EF(λw∷state.w.pset.p2.p_messbuf=Page9对于接收行为receive,由于消息、通知发送行为的正确性都依赖于接收行为,在φ1和φ2安全需求中已隐含接收行为的功效完整性,为此不单独对接收行为receive的功效完整性进行定义.(2)假设系统初始状态s0为可信状态,在s0的将来任何时刻,微内核的消息处理行为都能完成上述第1点的功能需求.谓词公式表示如下:3.3进程调度行为的功效完整性安全需求(1)微内核的多级进程队列入队操作行为schedule能正确地将进程加入到多级进程队列中.谓词公式表示如下:s∈S,p∷process.(s,(schedulep)├AX(λw∷state.i.0i15∧微内核的多级进程队列出队操作行为dequeue能正确地将进程从多级进程队列中删除.谓词公式表示如下:s∈S,p∷process.(s,(dequeuep)├AX(λw∷state.i.0i15→s∈S.(s,pick_proc├微内核的进程选择操作行为pick_proc能正确地将CPU资源分配给多级进程队列中的进程对象.谓词公式表示如下:AX(λw∷state.w.next_running_proc=pick_ps015))(φ6)(2)假设系统初始状态s0为可信状态,在s0的将来任何时刻,微内核的进程调度行为都能完成上述第1点的功能需求.谓词公式表示如下:3.4中断处理行为的功效完整性安全需求(1)微内核的中断处理行为能正确地根据不同的中断源,对系统缓冲区对象进行设置.谓词公式表示如下:s∈S.(s,interrupt_handle├AX(λw∷state.(2)假设系统初始状态s0为可信状态,在s0的将来任何时刻,微内核的中断处理行为都能完成上述第1点的功能需求.谓词公式表示如下:3.5进程行为隔离性需求微内核的进程行为不会受到其他进程对象的干扰,换句话说微内核的上述消息处理、进程调度以及中断处理行为在初始状态s0为可信的情况下,任何后续状态都能完成期望的功效,谓词公式表示如下:s0AG(φ1∧φ2∧φ4∧φ5∧φ6∧φ8)(φ10)上述安全需求以初始状态s0是可信状态为前提,我们通过可信启动来保证这一点.VTOS启动过程的安全保护由基于TPM的可信启动来完成.我们在VTOS中整合了tboot软件,通过对VTOS启动过程中系统镜像进行验证来防止对系统的恶意篡改和破坏,保证系统运行的初始状态的可信性.4VTOS设计与安全需求的一致性验证本节阐述VTOS形式化设计与安全需求一致性的验证.在第2节,我们使用OSOSM描述VTOS的设计,为此,一致性验证即是验证OSOSM模型的语义是否符合第3节提出的安全需求.我们借助定理证明器Isabelle/HOL来实现整个验证过程.验证方法分成3个部分:(1)利用Isabelle/HOL对第2节描述的OSOSM模型进行形式化建模;(2)安全需求的时序逻辑部分在Isabelle/HOL中的验证方法;(3)系统设计与安全需求的一致性验证.4.1Isabelle/HOL验证系统这一小节介绍验证过程将用到的Isabelle/HOL验证系统.Isabelle是一种定理证明器,主要用于验证使用逻辑系统描述的抽象问题,可以对计算机系统的程序逻辑进行严格的验证.Isabelle/HOL是对高阶逻辑的支持,采用函数式编程(functionalprogramming)的方式提供交互式的验证环境.Isabelle/HOL是一种类型系统(typesystem),类型变量(typevariable)可以采用a,b等方式来表达;对于类型的项(term)如x∷a,表示变量x是类型a的项.对于复杂数据类型的构造,可以采用3种方式:types,datatype和record.types用于定义数据类型的简化别名,如typespid=int,定义新类型pid是整数的别名;datatype用于定义复合的结构类型,如我们对于消息类型定义为Page10表示VTOS的消息类型包括6种普通消息格式和通知类型,以m_1~m_6和Notify表示.2.2.1节描述的消息对象,可以定义为record用于定义带名称的元组类型,如对于recordmessage=m_source∷pid表示消息message包含3个部分:m_source表示消息的来源,类型是pid,即进程标识符;m_type表示消息的类型,类型是新类型msg,msg描述消息的种类,可以使用datatype构造;m_content表示消息体,类型是字符串string.假设m的类型为message,引用成员域可以表达为如m_sourcem,表示引用m的m_source域.对于record类型的更新操作,假设m拥有值(|m_source=2,m_type=m_1,m_content=“request”|),那么更新操作表达为如m(|m_content··=“ack”|),表示对象m中m_content域修改为“ack”,其他域保持不变.对于函数定义,采用“=>”符号描述函数从定义域到值域的映射关系.函数更新操作表达为如g(x··=y),表示函数g在x处的值修改为y,定义域其他点保持不变.对于集合操作,可以采用“{s.Ps}”定义一个集合,其中所有的元素满足谓词公式P;对于集合的“补”操作,可以使用“-A”来表示集合A的补集.Isabelle/HOL支持lambda演算,例如对于集合运算Y=C∪X,C为集合常量,X、Y为集合变量,可以使用“λX.C∪X”来表示函数Y的操作子.Isabelle/HOL将关系(relation)作为2元对(pair)的集合来看待.对于关系的转置(converse)定义为:(a,b)∈M-1≡(b,a)∈M,M-1表示关系M的转置关系;关系的自反传递闭包(reflexivetransi-tiveclosure)使用如M来表示.对于集合在关系上的“象(image)”集合,使用如“MA”来表示,定义为b∈(MA)≡a∈A.(a,b)∈M,即“MA”表示由集合A中元素在关系M中的2元对的第2元组成的集合.下面我们阐述VTOS微内核模型OSOSM在Isabelle/HOL中的建模过程.4.2OSOSM的Isabelle/HOL方式建模4.2.1对象论域Isabelle/HOL方式定义如下:对于第2节描述的VTOS微内核对象论域,(ELOCKED|OK)"datatypertsflag=RECEIVING|SENDING|NULLdatatypedata=data_from_disk|data_from_inputtypespid=inttypesintr=INTR_DISK|INTR_KEYBOARDrecordmessage=m_source∷pidm_type∷msgm_content∷stringrecordprocess=proc_nr∷pidp_messbuf∷messagep_rts_flags∷rtsflagp_getfrom∷"pid|ANY"p_sendto∷pidp_lastcall∷"(SEND|RECEIVE|NOTIFY)×s_notify_pending∷"pidlist"s_msg_pending∷"pidlist"p_priority∷natp_ticks_left∷natrecordstate=pset∷"pid=>process"process_q∷"nat=>pidlist"sys_buffer∷dataintr_source∷intrnext_running_proc∷pidprev_proc∷pidS∷"stateset"其中,rtsflag为消息发送和接收状态的类型;intr为中断类型,包括硬盘中断INTR_DISK和键盘中断INTR_KEYBOARD;p_lastcall为进程对象最近一次消息行为语义的标识信息,定义为2元对,第1元取值SEND|RECEIVE|NOTIFY,第2元取值ELOCKED|OK.4.2.2VTOS微内核行为语义为语义采用Isabelle/HOL方式进行表达.下面我们对第2节中描述的VTOS微内核行(1)消息处理行为在基本功效层,从功效上来说,微内核的消息处理行为是将发送者进程PCB对象所指示的消息缓冲区中的消息体复制到接收者进程PCB对象所指示的消息缓冲区中.VTOS消息处理采用“汇合机制”,为此我们使用Isabelle描述时需要考虑3个状态:消息放送状态、消息接收状态、完成功效状态.消息、通知发送行为和接收行为具体定义如下:Page11definitionSysSend∷"pid=>pid=>state=>state"where"SysSendp1p2s≡(letnewp1_1=(psets)p1(|p_lastcall··=(SEND,ELOCKED)|);newp2_1=(psets)p2(|p_messbuf··=(p_messbuf((psets)p1)),p_rts_flags··=NULL|);newp2_2=(psets)p2(|s_msg_pending··=(s_msg_pending((psets)p2))@(p1#[])|)in(ifp_rts_flags((psets)p2)=SENDING∧thenSysSchedulep2(s(|pset··=(psets)(p1··=newp1_2,p2··=newp2_1)|))elseSysDequeuep1(s(|pset··=(psets)(p1··=newp1_3,p2··=newp2_2)|)))))"definitionSysNotify∷"pid=>pid=>state=>state"where"SysNotifyp1p2s≡(letnewp1=(psets)p1(|p_lastcall··=(NOTIFY,OK)|);newp2_1=(psets)p2(|p_messbuf··=(|m_source=p1,m_type=Notify,m_content=NULL|),newp2_2=(psets)p2(|s_notify_pending··=(s_notify_pending((psets)p2))@(p1#[])|)in(ifp_rts_flags((psets)p2)=RECEIVING∧definitionSysReceive∷"pid=>pid=>state=>state"where"SysReceivep2p1s≡(letp1_1=hd(s_msg_pending((psets)p2);m_type=Notify,m_content=NULL|),newp2_4=(psets)p2(|p_lastcall··=(RECEIVE,OK),p_rts_flags··=RECEIVING|)in(ifs_notify_pending((psets)p2)≠[]Page12其中,SysSchedule和SysDequeue为调度行为,在下面将定义.Isabelle/HOL中的列表“过滤”操作子filter将不满足谓词条件的列表元素删除,语义定义为filterP[]≡[]filterP(x#xs)≡(ifPxthenx#filterPxsIsabelle/HOL中的列表“蕴含”操作子mem判断元素是否在列表中,语义定义为definitionSysSchedule∷"pid=>state=>state"where"SysScheduleps≡(letpriority=p_priority((psets)p);newprocess_q_4=(process_qs)(priority··=((process_qs)priority)@(p#[]));thens(|process_q··=newprocess_q_2,pset··=(psets)(p··=newp_1)|)definitionSysDequeue∷"pid=>state=>state"where"SysDequeueps≡s(|process_q··=definitionSysPick_proc∷"state=>state"where"SysPick_procs≡s(|next_running_proc··=pick_ps015|)"primrecpick_p∷"state=>nat=>nat=>nat"where"pick_ptbeginend=(if(process_qt)begin=[]∧begin<endthenpick_pt(begin+1)endxmem[]≡Falsexmem(y#ys)≡(ify=xthenTrueelsexmemys)(2)进程调度行为微内核的多级进程队列入队操作行为schedule是将被调度的进程PCB对象加入到进程队列对象中.dequeue行为将进程对象从多优先级进程队列中去除.pick_proc行为从多优先级进程队列中选择将要运行的进程,根据第2节的语义描述,Isabelle/HOL方式描述如下:Page13数的定义.其中,primrec是Isabelle/HOL对原始递归函(3)中断处理行为definitionSysInterrupt_handle∷"state=>state"where"SysInterrupt_handles≡4.3时序逻辑在Isabelle中的验证方法第3节采用时序逻辑对VTOS微内核的安全需求进行了描述,为了使用Isabelle/HOL验证OSOSM与安全需求的一致性,首先需要解决Isabelle/HOL验证环境中构建时序逻辑的验证过程.时序逻辑在模型检测(modelchecking)中用于描述系统的需求规格说明(specification),各种模型检测工具都支持时序逻辑的验证.在定理证明器Isabelle/HOL中,使用时序逻辑对被验证的系统进行规格说明并验证的工作,存在如何对时序逻辑进行抽象描述的问题.VTOS形式化设计首次尝试在Isabelle/HOL环境、操作系统级的验证过程中实现对时序逻辑的描述.下面,我们阐述VTOS微内核安全需求的时序逻辑部分在Isabelle/HOL中的描述方法.VTOS将各种行为的执行功效看成是对系统状态的改变或者迁移,状态转换集合ST定义为ST∷"(state×state)set",表示系统中状态之间转换的集合,例如s2是s1的直接后继状态,则二元对(s1,s2)∈ST.对于第3节描述的安全需求的时序逻辑部分中的命题类型,我们定义如下:datatypeF=Atomic"atomic"|AndFF|表示命题公式类型F可以是“原子命题Atomic”、“合取命题And”、“析取命题Or”、“否定命题Negative”以及带时序逻辑的命题AG/EF/AX.状态可满足的原子命题集合定义为Sat_Atomic∷"state=>atomicset",状态s下可满足的原子命题集合表示为Sat_Atomics,Sat_Atomics≡{f.fs=True};VTOS微内核行为类型包括消息处理、进程调度和中断处理行为,其定义如下:微内核的中断处理行为的功效是根据不同的中断源,对系统缓冲区对象进行设置,本文主要描述键盘中断和磁盘中断.Isabelle/HOL方式描述如下:datatypeaction=sendpidpid系统行为单步执行引起的状态转换函数step定义如下:funstep∷"state=>action=>state"where"steps(sendp1p2)=SysSendp1p2s"|"steps(notifyp1p2)=SysNotifyp1p2s"|"steps(receivep2p1)=SysReceivep2p1s"|"steps(schedulep)=SysScheduleps"|"stepsinterrupt_handle=SysInterrupt_handles"下面我们定义安全需求命题满足性函数,即状态对安全需求命题的可满足性,和第3节保持一致,我们使用“sf”符号表示“在s状态下,命题f成立”.其定义如下:primrecsat∷"state=>F=>bool"("__")where"sAtomica=(a∈Sat_Atomics)"|"sAndbc=(sb∧sc)"|"sOrbc=(sb∨sc)"|"sNegatived=((sd))"|"sAGf=(w.(s,w)∈ST→wf)"|"sEFf=(w.(s,w)∈ST∧wf)"|"sAXf=(w.(s,w)∈ST→wf)"在第3节中,我们对时序逻辑进行了扩展,加入了动作对状态路径分支的影响,在Isabelle/HOL中的定义如下:definitionstep_sat∷"state=>action=>F=>bool""s,a├f≡stepsaf"集的函数:接下来我们定义求取满足安全需求命题的状态Page14primrecSAT∷"F=>stateset"where"SAT(Atomica)={s.a∈Sat_Atomics}"|"SAT(Andbc)=SATb∩SATc"|"SAT(Orbc)=SATb∪SATc"|"SAT(Negatived)=-SATd"|"SAT(AGf)={s.w.(s,w)∈ST→"SAT(EFf)=lfp(λX.(ST-1X)∪SATf)"|"SAT(AXf)={s.w.(s,w)∈ST→对于上述满足性函数SAT,原子命题满足性计算即是求对原子命题满足的状态集合;对于“反”命题即是原始命题可满足集合的补集;合取命题即是各命题可满足集合的交集,对应地,析取命题即是各命题可满足集合的合并;对于时序逻辑AG命题,即是求状态对象在自反传递闭包ST的后继状态(直接或者间接后继)的可满足性;对于时序逻辑AX命题,即是求直接后继的可满足性.对于时序逻辑“EFf”命题的满足性问题,首先图4VTOS中时序逻辑EF/AG验证方法4.4一致性验证本小节对VTOS的设计,即第2节阐述OSOSM语义模型,是否满足第3节的VTOS安全需求进行验证,即设计和安全需求的一致性验证.引理1.消息发送行为send功效完整性.OSOSM微内核消息发送行为满足φ1的功效完整性定义:lemmaSend_Effectiveness:"s∈S,p1∷process,p2∷process.(s,(sendp1p2)├EF(λw∷state.p_messbuf((psetw)p2)=证明.我们首先将“s,a├f”部分使用单步执行函数step的定义展开,然后构造消息发送行为实现语义函数SysSend中的接收状态和完成功效状态.如果在s的后继状态t(直接或者间接后继)执行receivep2p1或者receivep2ANY行为,这样的t即为接收状态,在t的直接后继状态w时,按照SysSend函数的定义,完成SysSend的功效,因此计算直接满足f的状态集,即“SATf”,这是基本步(basestep);然后假设已计算得到的结果状态集合为X,接下来计算这些直接满足f的状态的直接前续状态,即“ST-1X”,这是推演步(deductivestep);最后递归计算这些前续状态,即对X抽象后“λX.(ST-1X)∪SATf”的最小不动点(LeastFixedPoint),Isabelle/HOL中使用lfp函数来计算最小不动点.对于第3节描述的VTOS微内核安全需求φ1和φ2,是关于时序逻辑“EFf”命题的验证,按照上述“EFf”的SAT满足性的计算方法,在验证过程中,我们需要首先计算基本步,这通过构造行为的完成功效状态来实现;然后计算推演步,这通过说明基本步构造的完成功效状态是行为发生状态的后续状态来说明.φ3,φ7,φ9,φ10是关于时序逻辑“AGf”命题的验证,在验证过程中,首先说明当前状态满足命题f,然后验证在执行系统行为后的状态仍然能满足命题f,由此说明从此状态出发的任何状态路径上的所有点都满足命题f.如图4所示.(EF-intro)w即为完成功效状态.Isabelle/HOL证明过程如下:apply(simpadd:step_sat_defsat_defSysSend_def);apply(subgoal_tac"w=stept(receivep2p1)");apply(blast);apply(simpadd:SysReceive_def);apply(auto);done;其中,apply表示使用规则或者已证明的引理和定理来进行验证;simp方法对“s,a├f”部分使用单步满足性的定义(step_sat_def)和系统行为定义(SysSend_def)来进行展开并化简;subgoal_tac方法使用“w=stept(receivep2p1)”构造接收状态和完成功效状态;blast表示使用经典推理方法(classicalreasoningmethods)进行前向(forward)搜索验证;auto表示对验证目标进行简化,并根据已有结论和定义进行搜索验证.采用类似的基本步和推演步的构造方法,我们可以证明通知发送行为和接收行为的功效完整性.Page15引理2.通知发送行为notify功效完整性.OSOSM微内核通知发送行为满足φ2的功效完整性定义:lemmaNotify_Effectiveness:"s∈S,p1∷process,p2∷process.(s,(notifyp1p2)├EF(λw∷state.p_messbuf((psetw)p2)=定理1.消息处理行为完整性(MessageProcessIntegrity,MPI).假设系统初始状态s0为可信状态,在s0的将来任何状态下,微内核都具有消息发送行为功效完整性、通知发送行为功效完整性和接收行为功效完整性:theoremMPI:"s0AG((s∈S,p1∷process,p2∷process.(s,(sendp1p2)├EF(λw∷state.p_messbuf((psetw)p2)=(s∈S,p1∷process,p2∷process.(s,(notifyp1p2)├EF(λw∷state.p_messbuf((psetw)p2)=证明.从引理1,引理2可知,VTOS在完成微内核消息处理行为功效的同时,不会破坏完成功效状态下继续进行消息处理的能力,因此在系统初始状态s0为可信状态的情况下,任何后续状态都能保证消息处理行为的功效完整性.apply(simpadd:step_sat_defsat_def)apply(blastintro:apply(auto)done引理3.多级进程队列入队操作行为schedule功效完整性.VTOS微内核的多级进程队列入队操作行为schedule能正确地将进程加入到多级进程队列中:lemmaSchedule_Effectiveness:"s∈S,p∷process.(s,(schedulep)├pmem((process_qw)i))))"证明.从SysSchedule的定义可知,VTOS微内核根据被调度进程对象的剩余时间片和CPU资源的占用情况来设置进程对象的优先级,并将进程对象加入到新优先级对应的进程队列中,为此在完成功效状态下,进程对象必定在优先级从0到15的多级进程队列中.Isabelle/HOL证明过程如下:apply(simpadd:step_sat_defsat_defSysSchedule_def)apply(blast)apply(erulemem_def)apply(best)done其中“erulemem_def”表示利用Isabelle/HOL中list的mem函数定义来进行消除规则(elimina-tionrules)的前向推导;best方法表示采用最优查找(best-firstsearch)代替经典推理方法的深度查找(depth-firstsearch)进行搜索验证.证毕.采用类似的方法,我们可以证明多级进程队列出队操作行为dequeue的功效完整性和选择进程对象行为pick_proc的功效完整性.引理4.多级进程队列出队操作行为dequeue行为功效完整性.微内核的进程队列出队操作行为dequeue能正确地将进程从多级进程队列中删除:lemmaDequeue_Effectiveness:"s∈S,p∷process.(s,(dequeuep)├AX(λw∷state.i.(0i∧i15→(pmem((process_qw)i)))))"引理5.pick_proc行为功效完整性.lemmaPick_proc_Effectiveness:"s∈S.(s,pick_proc├AX(λw∷state.(next_running_procw)=定理2.进程调度行为完整性(ProcessDis-patchIntegrity,PDI).假设系统初始状态s0为可信状态,在s0的将来任何状态下,微内核都具有多级进程队列入队操作行为功效完整性、多级进程队列出队操作行为功效完整性和选择进程对象行为功效完整性.theoremPDI:"s0AG(s∈S,p∷process.(s,(schedulep)├AX(λw∷state.i.(0i∧i15∧(s∈S,p∷process.(s,(dequeuep)├AX(λw∷state.i.(0i∧i15→Page16(s∈S.(s,pick_proc├AX(λw∷state.(next_running_procw)=pick_ps015)))"证明.从引理3、引理4、引理5可知,VTOS在完成进程调度行为功效的同时,不会破坏完成功效状态下继续进行进程调度的能力,因此在系统初始状态s0为可信状态的情况下,任何后续状态都能保证进程调度行为的完整性.类似地,我们有中断处理行为的功效完整性.定理3.中断处理行为完整性(InterruptHandleIntegrity,IHI).假设系统初始状态s0为可信状态,在s0的将来任何状态下,VTOS的中断处理行为能正确地根据不同的中断源,对系统缓冲区对象进行设置:theoremIHI:"s0AG(s∈S.(s,interrupt_handle├AX(λw∷state.((intr_sources)=INTR_DISK→(sys_bufferw)=data_from_disk)∨((intr_sources)=INTR_KEYBOARD→(sys_bufferw)=data_from_input))))"证明.使用单步执行函数step展开后,根据SysInterrupt_handle的定义,VTOS微内核对中断的处理将根据中断源的类型如硬盘中断、键盘中断,进行设置系统缓冲区.apply(simpadd:step_sat_defsat_defSysInterrupt_handle_def)apply(case_tacintr_source)apply(auto)done其中“case_tacintr_source”表示对中断源变量intr_source进行分情况展开.我们的验证环境配置如表1所示.VTOS微内核部分的Isabelle/HOL验证工程代码量大概在23kSLOC(SourceLinesOfCode)左右,完整的验证耗时15min左右.名称HardwareDellStudioXPS9100StandardInstallationCPUMemoryDDR3SDRAMOSopenSUSEDesktop11.3StandardInstallationIsabelleIsabelle2009-2_bundle_x86-linuxStandardInstallationIsabelle的验证结果如图5所示.“Nosubgoals”说明Isabelle验证逻辑完整,不存在任何未证明的子目标.5结束语本文使用形式化方法对操作系统进行设计和验证,阐述在VTOS设计过程中构建对象语义模型OSOSM的方法,以此来对VTOS的设计进行形式化的描述.本文从系统行为功效完整性和进程行为隔离性的角度对微内核OS的安全需求进行了分析,使用带有时序逻辑的高阶逻辑对安全需求进行严格的定义和描述,并在定理证明器Isabelle/HOL环境中对系统的设计和安全需求的一致性进行验证,表明VTOS微内核系统行为的功效设计符合安全需求的定义.本文采用的对象语义模型OSOSM是一种开放的框架模型,可以实现对OS内核以及功能模块的描述.由于系统的各种功能模块往往采用多种不同的程序逻辑进行设计,并且涉及多种不同的抽象层次,如C语言层、汇编语言层和硬件实现层等,对于这些功能模块整合在一起的系统的正确性不能简单地认为是各个模块的正确性的合取.我们接下来的工作将从域理论(domaintheory)和类型论(typetheory)的角度来对系统的各个经过验证的模块的整合验证进行研究.致谢本文作者感谢本文的所有匿名审稿者!
