Page1基于One-test-at-a-time策略的可变力度组合测试用例生成方法王子元1),2),3)钱巨4),5)陈林1),2)徐宝文1),2)1)(南京大学软件新技术国家重点实验室南京210093)2)(南京大学计算机科学与技术系南京210093)3)(南京邮电大学计算机学院南京210006)4)(上海市计算机软件评测重点实验室上海201112)5)(南京航空航天大学计算机科学与技术学院南京210016)摘要组合测试可以有效地检测软件系统中由各个因素间交互作用所引发的软件故障.但传统的组合测试方法对系统中各因素之间的实际交互关系考虑不足,难以有效处理交互力度不统一的情况,进而可能导致测试用例的冗余和检错能力的降低.针对该问题,应在充分考虑因素间实际交互关系的基础上,使用可变力度组合测试方法,从而实现对于因素间实际交互关系的覆盖.为此,文中针对一种新的可变力度组合测试模型,提出了两种基于one-test-at-a-time策略的可变力度组合测试用例集生成算法.实验表明,相对于已有的具备类似功能的测试用例生成算法和工具,文中提出的算法在测试用例集规模和算法运行时间上均具备一定优势,并可适用于固定力度组合测试、可变力度组合测试等不同测试模型.关键词软件测试;可变力度组合测试;测试用例生成;交互关系1引言软件系统是一个复杂的逻辑系统,有很多因素都可能会影响软件系统的正常运行,这些因素可能包括系统的配置、内部事件、外部输入等.除了单个因素之外,这些因素之间的相互作用也可能会对系统的运行造成影响.组合测试作为一种科学、有效的软件测试方法,可以使用较少的测试用例有效地检测软件系统中各个因素以及它们之间的相互作用对系统产生的影响.组合测试方法主要可分为固定力度组合测试和可变力度组合测试这两种类型.其中,固定力度组合测试方法得到了最为广泛的研究和应用,并在很多实践中都取得了良好的效果.在固定力度的τ维组合测试中,人们一般简单地假设系统中任意τ个因素间均存在交互作用,并在上述假设的基础上设计τ维组合测试用例集以检测这些交互作用.但Cohen等人[1]提出,在很多软件系统中,不同因素之间的交互力度往往是不同的,Kuhn等人[2-3]对一些具体软件系统的分析结果也说明了这一点.对于这样的系统,往往很难寻找一个合适的正整数τ来进行固定力度的组合测试:(1)如果τ选取过大,则测试用例可能出现不必要的冗余,从而增加测试成本;(2)若τ选取过小,则某些因素间的交互作用将难以在测试中得到完全的检测,从而降低错误检测能力.为了解决上述问题,Cohen等人[1]在2003年提出了一种可变力度的组合测试方法.该方法在固定力度τ维组合测试的基础上,允许部分互不相交的因素子集中存在力度大于τ的交互作用,从而在一定程度上解决了上述问题.但是我们同时注意到,在Cohen等人提出的可变力度组合测试模型中,一方面仍然假设所有因素间均存在力度至少为τ的交互作用,另一方面则要求那些具有较高交互力度的因素子集互不相交.这样的限制可能会影响该模型的表达能力.可见,在充分了解软件中因素间交互作用的基础上,有必要对现有的组合测试模型进行进一步改进.为此,Schroeder等人[4]提出一种基于程序输入输出关系的测试模型.在该模型中,程序的每个输出变量均依赖于若干个输入变量的交互作用.我们则在该模型的基础上进一步扩展,提出一种新的可变力度组合测试模型[5-6].这种新的可变力度组合测试模型可以更为准确地描述系统中的因素间交互作用,进而为测试用例集的设计和生成提供更好的指导.在本文中,一般称Cohen等人提出的方法为“狭义”可变力度组合测试方法,以便于新旧两种方法的区分.在假设待测系统因素间交互关系已知的情况下,本文针对这种新的可变力度组合测试模型,提出了一系列基于one-test-at-a-time策略的可变力度组合测试用例生成算法,并通过实验对相关算法的性能进行分析和比较.实验结果表明,相对于已有的具备类似功能的测试用例生成算法和工具,本文提出的算法在测试用例集规模和算法运行时间上均具备一定优势.2模型及定义假设影响待测软件系统(SystemUnderTest,SUT)的因素共有n个,这些因素形成有限集合F={f1,f2,…,fn}.其中因素fi经过等价类划分等前期处理后共包含ai个可选取值,不妨假设该因素的可选取值集合为Vi={1,2,…,ai}(1in).一般地,如果某个SUT中所有因素取值数量均相等,即a1=a2=…=an,则称该SUT为单一水平系统;否则,称该SUT为混合水平系统.定义1.称一个n元组test=(v1,v2,…,vn)(v1∈V1,v2∈V2,…,vn∈Vn)为SUT的一条测试用例,相应地,称一个由多个这样的n元组所构成的集合为待测软件SUT的一个测试用例集.2.1已有组合测试模型在组合测试中,需要考虑因素之间的交互作用,并根据因素间的交互作用设计测试用例集,以覆盖某些给定的因素取值组合.首先,对固定力度组合测试和“狭义”可变力度组合测试的相关概念进行简要介绍[1,7].定义2.设犃=(ai,j)m×n为一个m×n的矩阵,其第j列表示SUT的因素fj,其中所有元素均取自集合Vj(j=1,2,…,n),即ai,j∈Vj.给定正整数τ(1τn),如果犃中任意τ列,即第i1,i2,…,iτ列均满足:Vi1,Vi2,…,Viτ中元素的所有的τ元组Page3合均在这τ列所组成的子矩阵中至少出现一次,则称犃为τ维组合覆盖表,记作犆犃(m;τ,F).其中,τ为犆犃(m;τ,F)的组合覆盖力度.显然,从犆犃(m;τ,F)中任取k列(τkn),其所构成的子矩阵的组合覆盖力度均为τ.因此,我们又称τ维组合覆盖表为固定力度组合覆盖表.定义3.对于一个τ维组合覆盖表犃,若F中存在t(t1)个互不相交的子集FiF(i=1,2,…,t),这些子集构成集合C.其中Fi(i=1,2,…,t)包含ni个因素,且这些因素对应的列所组成的m×ni的子矩阵犃i满足τi(τ<τini)维组合覆盖的条件,即犃i的组合覆盖力度不等于τ,则称犃为“狭义”可变力度的组合覆盖表,记作犞犛犆犃(m;τ,F,C).定义4.使用固定力度组合覆盖表和“狭义”可变力度组合覆盖表设计测试用例集的方法,可分别称之为固定力度组合测试方法和“狭义”可变力度组合测试方法.例如,对于一个如图1所示的面向对象系统进行类交互测试时,每次测试均需要从4个类体系结构(ClassCluster)中各选取一个子类组成一个具体的配置作为测试用例.我们将每个类体系结构作为一个因素,其中的子类作为该因素的可选取值,从而有F={23×3}(表示F中共含4个因素,可选取值的数量依次为2、2、2、3).若采用固定力度二维组合测试,则可以找到一个规模为6的二维组合测试用例集犆犃(6;2,F),从而保证任意两个因素间的所有二元取值组合均至少出现一次,如表1所示.在此基础上,进一步令C={{ClassA,ClassB,ClassC}},则可得到如表2所示的可变力度组合测试用例集犞犛犆犃(8;2,F,C).该测试用例集除保证二维组合覆盖外,还能保证ClassA,ClassB,ClassC3个因素间所有的三元取值组合均至少出现一次.ClassAClassBClassCClassDA1A1A1A2A2A2ClassAClassBClassCClassDA1A1A1A1A2A2A2A2在上述定义的基础上,本小节对新的可变力度2.2新的可变力度组合测试模型组合测试方法进行介绍[5-7].假设因素集合F中的一组因素间存在交互作用,则可以将这些因素收集为F的一个子集rF,从而使得子集中所有|r|个因素间存在一个力度为|r|的交互作用(或称之为|r|维交互作用).对于一个给定的子集r,相应的组合测试用例集应覆盖r中因素间所有的|r|元取值组合.类似的,系统SUT中的每一个交互作用均可抽象为这样的一个子集.假设SUT中共存在t个不同的交互作用,则可以构造一个由F的t个不同子集所组成的集合R={r1,r2,…,rt}.针对该SUT的组合测试用例集应覆盖R中所有子集所对应的因素间交互作用,即对于任一给定的rk∈R(k=1,2,…,t),测试用例集必须覆盖rk中因素间所有的|rk|元取值组合.例如,在对一个具有n个因素的系统进行固定力度二维组合测试时,测试用例集就必须覆盖R={{fi,fj}|fi,fj∈F,1i<jn}中的所有|R|=n×(n-1)/2个二维相互作用.定义5.称上述集合R为待测系统SUT的因素交互关系,简称交互关系;而R中的每一个元素rk∈R(k=1,2,…,t)均为SUT的一个因素组合覆盖需求,简称覆盖需求.本文中,我们不妨假设:(1)覆盖需求ri={fi,1,fi,2,…,fi,ni}∈R(i=1,2,…,t)中含有ni个因素且有ni>1;(2)因素集合F中的给定的两个因素fi,fj∈F(1i<jn)之间存在交互作用,当且仅当存在一个覆盖需求r∈R使得fi,fj∈r;(3)R中任意Page4两个覆盖需求ri1,ri2∈R(i1≠i2)之间不存在包含关系,否则若有ri1ri2,则可直接从R中删除ri1而不影响测试用例集的组合覆盖能力;(4)对于F中任意因素fi∈F(1in),至少存在一个覆盖需求r∈R使得fi∈r,否则说明fi不与F中的其它任何因素发生交互作用,不属于组合测试所考虑的范围.定义6.设犃=(ai,j)m×n为一m×n的矩阵,其第j列表示SUT的参数fj,其中所有元素均取自集合Vj(j=1,2,…,n),即ai,j∈Vj(i=1,2,…,m).给定SUT的一个组合覆盖需求rk∈R,由rk中的nk个因素所对应的列可组成一个m×nk的子矩阵犃k,若该nk个因素的所有nk元取值组合在犃k中均至少出现一次,则称犃满足覆盖需求rk.若任取rk∈R(k=1,2,…,t),均有犃满足rk,则称犃为满足交互关系R的可变力度组合覆盖表,并记为犞犆犃(m;F,R).结合定义5可知,对于交互关系R中的一个覆盖需求rk∈R(k=1,2,…,t),rk中因素间所有的|rk|元取值组合可以构成集合:CombSetk={(vk,1,vk,2,…,vk,nk)|vk,1∈Vk,1,相应的,R中所有覆盖需求所对应的组合可以构成集合:显然,一个满足R的可变力度组合覆盖表必须覆盖集合CombSet中的所有组合.定义7.使用可变力度组合覆盖表设计测试用例集的方法,称之为可变力度组合测试方法.不同于传统的固定力度维组合测试,在可变力度组合测试中,测试用例集不需要覆盖任意τ个因素之间的取值组合,仅需满足交互关系R中所有t个覆盖需求即可.而相对于“狭义”可变力度组合测试,新的可变力度组合测试方法可以更为准确地描述系统中因素间的交互关系.例如,对于图1所示的面向对象系统,因素交互关系可描述为R={r1,r2,r3},其中r1={ClassA,ClassB,ClassC},r2={Clas-sA,ClassD},r3={ClassC,ClassD}.若使用“狭义”可变力度力度组合测试模型,则存在如下可能:(1)令τ=2且C={r1},则R中所有覆盖需求均可满足,但原本不属于R的覆盖需求{ClassB,ClassD}也会被该模型包含在内;(2)令τ=1且R={r1,r2,r3},则不存在冗余的覆盖需求,但r1与r2间、r1与r3间以及r2与r3间均存在交集,不符合“狭义”可变力度组合测试模型的要求.进行可变力度组合测试的一个重要前提是获取待测系统的因素交互关系,这可以通过文档分析、静态代码分析等方式进行,本文对此不做赘述.假设已通过上述某种方式准确获取因素交互关系,我们重点考虑如何在此基础上生成规模尽可能小的可变力度组合测试用例集,以便在满足组合覆盖标准的前提下,尽可能节约测试成本.定理1.给定因素集合F,交互关系R以及正整数m<(a1×a2×…×an),生成一个规模为m,且满足交互关系R的可变力度组合测试用例集犞犆犃(m;F,R)是一个NP-C问题.证明.首先需证明该问题属于NP类,然后若存在一个已知的NP-C问题可在多项式时间内转化为该问题,或已知问题是该问题的一种特殊情况,即可证明该问题为NP-C问题.首先,给定一个测试用例集犜,判断其是否满足R中所有覆盖需求,需依次检查犜中的m条测试用例.而在检查每一条测试用例时,又需依次检查R中每个覆盖需求所对应的因素取值组合.因此,其时间复杂度不超过O|m2|2×∑t间可判定,说明该问题属于NP类.其次,已知固定力度二维组合测试用例集的生成问题是NP-C问题[8-9].如上文所述,二维组合测试用例集的生成问题是该问题在R={{fi,fj}|fi,fj∈F,1i<jn}时的一种特殊情况.因此,对于给定的F、R以及m,生成规模m的可变力度组合测试用例集是一个NP-C问题.由定理1可知,我们暂时无法使用多项式时间的算法生成最优的可变力度组合测试用例集.因此,本文主要研究如何使用启发式算法生成近似最优的可变力度组合测试用例集.3相关工作及存在的问题除Cohen等人提出的“狭义”可变力度组合测试方法外,近年来人们所做的其它一些工作也与可变力度组合测试方法相关.例如,Schroeder等人[4,10]提出的程序输入输出关系测试可看作是可变力度组合测试的一种特殊应用场景.而开源测试用例生成工具TestVectorGenerator(TVG)①以及①http://sourceforge.net/projects/tvg/Page5微软Czerwonka开发的工具PICT[11]也可以用于可变力度组合测试用例集的生成.在输入输出关系测试的模型中,X表示所有输入变量的集合,Y表示所有输出变量的集合;D(xi)表示输入变量xi的取值的集合,Tall=D(x1)×D(x2)×…×D(xn)表示输入变量的所有取值组合.在程序中,每一个输出变量依赖于一个或多个输入变量.用X(y)表示与输出变量y有关的输入变量的集合,用T(y)表示只与输出变量y有关的输入变量的值组合,该集合包含X(y)中所有输入变量的取值组合.在输入输出关系测试中,需要生成一个规模尽可能小的测试用例集犜Tall,使得对于任意y∈Y,X(y)中的所有组合均在T中出现至少一次.显然,若对于每一个y∈Y,都可将X(y)对应于可变力度组合测试模型中的一个覆盖需求,则集合{X(y)|y∈Y}恰好对应于可变力度组合测试模型中的交互关系R.相应的,输入输出关系测试中测试用例集的生成问题也与可变力度组合测试用例集的生成问题等价,即输入输出关系测试中最小测试用例集的生成也是一个NP-C问题[10].为解决输入输出关系测试中测试用例集的生成问题,Schroeder等人[4,10]提出了3种测试用例集生成算法.其中一种算法使用蛮力搜索的方式寻找最小测试用例集,显然对于此类NP-Hard问题是不适用的.另外两种近似算法算法分别名为Union和Greedy.其中Union的时间性能较好,最坏时间复杂度不超过O∑t生成的测试用例集往往规模较大;而Greedy可生成相对较小的测试用例集,但时间复杂度高达(Om×∑t除上述算法外,还有一些测试用例辅助生成工具也可用于可变力度组合测试用例集的生成,如TVG和PICT等.其中TVG内嵌一个非确定性算法,除可用于生成固定力度组合测试用例集外,也可针对给定的输入输出关系生成相应的测试用例集.TVG的主要缺陷在于所生成的测试用例集规模偏大,这一点将在后续的实验中给予说明.PICT主要用于生成固定力度组合测试用例集,但通过编辑输入文件中的“Sub-Model”域,该工具也可生成可变力度的组合测试用例集.PICT的主要问题是在生成可变力度组合测试用例集时时间性能不稳定,远差于其在生成固定力度和“狭义”可变力度组合测试k=1用例集时的时间性能,这一点也将在后续的实验中加以说明.此外,本课题组在组合测试领域的研究中,也曾对因素间交互关系的特殊性加以考虑.一方面,针对交互作用仅存在于相邻因素之间的情况,我们曾提出相邻因素组合测试方法并给出了可生成最小测试用例集的多项式时间算法[12],另一方面,针对新的可变力度组合测试模型,我们已经给出了ReqOrder、ParaOrder等测试用例集生成算法[5-6],其最坏时间复杂度分别为O∑t(O∑t4基于One-test-at-a-time策略的算法在固定力度组合测试用例集的生成中,one-test-at-a-time策略由于其简单、有效、便于扩展等特点,成为应用最普遍的方法之一[13-14].相应的,在可变力度组合测试用例集的生成中,这一策略也得到了应用.例如,在Schroeder等人[10]提出的输入输出关系测试及相应的测试用例集生成方法中,Greedy算法即采用了该策略.但由于该算法的时间性能较差,因此有必要对基于one-test-at-a-time策略的可变力度组合测试用例集生成方法进行进一步的研究.首先介绍使用one-test-at-a-time策略生成可变力度组合测试用例集的基本流程.首先需根据待测系统SUT的因素集合F和交互关系R生成集合CombSet,并使其包含所有需要被测试用例集覆盖的因素间取值组合.算法开始时,初始化一个包含0条测试用例的空测试用例集犜.此后,每次均从测试用例全集Tall=V1×V2×…×Vn中选择一条测试用例test,并将其加入测试用例集犜,如此反复直至集合CombSet中所有的组合均被测试用例集犜覆盖为止.该过程与固定力度组合测试用例集生成中one-test-at-a-time策略的流程基本相似,具体可见算法1.此后,测试用例集生成问题即转化为如何生成每一条测试用例这一相对简单的问题.算法1.One-test-at-a-time策略基本框架.输入:因素集合F,因素交互关系R输出:可变力度组合测试用例集犜1.Initialize犜[0…0][1…n];//初始化一个0×n的矩2.根据F和R生成集合CombSet;3.UncovCombSet··=CombSet;4.While(UncovCombSet≠)Page65.生成一条测试用例test,将其加入测试用例集犜;6.更新UncovCombSet,删除其中已被test覆盖的组合;7.EndWhile为了生成尽可能小的可变力度组合测试用例集,一种显而易见的方法就是使用贪心算法,即每步均选择一条最优的测试用例,使其最大限度地覆盖集合UncovCombSet中的组合.Schroeder[10]提出的Greedy算法即是如此.但可以证明,在one-test-at-a-time策略中生成一条最优测试用例是NP-Hard问题.这一结论不仅在固定力度组合测试用例集的生成中成立[15],在可变力度组合测试用例集的生成中也是如此.因此,Greedy算法在生成每一条测试用例时,都需要遍历规模为O∏n间.时间性能较差,难以适用于较大规模的问题.定理2.给定因素集合F,交互关系R,组合集合CombSet的一个真子集UncovCombSet以及一个正整数m<|R|,在使用one-test-at-a-time策略生成可变力度组合测试用例集的过程中,生成一条测试用例test使其覆盖UncovCombSet中恰好m个组合是一个NP-C问题.证明.首先,该问题属于NP类,即多项式时间可判定.具体来说,判断一条测试用例test覆盖集合UncovCombSet中组合的数量,需检查交互关系R中所有的覆盖需求,以判断该覆盖需求所对应的组合是否被包含在UncovCombSet中.该过程的时间复杂度不超过O∑t其次,在固定力度二维组合测试用例集生成问题中,已知上述结论成立[15].而正如上文所述,固定力度二维组合测试可看作是可变力度组合测试在R={{fi,fj}|fi,fj∈F,i≠j}时的一种特殊情况.因此,对于给定的F、R、UncovCombSet以及m,生SUT:F={f1,f2,f3}R={r1={f1,f2},r2={f1,f3}}UncovCombSet1={(1,1),(1,2)}UncovCombSet2=图2覆盖需求的优先级及其效果(r2中的因素随机取值)为了度量覆盖需求之间的这种优先级,有必要定义一个覆盖需求度量函数.由图2可知,覆盖需求rk的度量函数值应该与集合CombSetk中未覆盖组合的数量成正比.因此,不妨以CombSetk中未覆盖成一条测试用例使其覆盖UncovCombSet中恰好m个组合是一个NP-C问题.由上述结论可知,类似Greedy算法这样的贪心策略在处理大规模问题时是不可行的.因此,我们在使用one-test-at-a-time策略时,只能考虑使用多项式时间的算法生成近似最优的测试用例.4.1按照覆盖需求顺序生成单条测试用例针对一个给定的组合集合UncovCombSet生成一条测试用例,其最好情况是:对于交互关系中的每一个覆盖需求,均覆盖一个因素取值组合,且该组合属于UncovCombSet.为此,可以考虑将各个因素按照覆盖需求的顺序逐批次依次赋值.我们注意到,在生成这样一条测试用例时,不同的覆盖需求的优先级也是不同的.在直观上,如果一个覆盖需求rk∈R(1kt)所对应的组合集合CombSetk中有大量的组合尚未被已有测试用例覆盖,则在生成一条新的测试用例时,该覆盖需求应被优先考虑,以保证所生成的测试用例能覆盖CombSetk中至少一个组合.例如,考虑图2所示的极端情况:交互关系R包含两个覆盖需求r1={f1,f2}和r2={f1,f3},当one-test-at-a-time策略运行至某一步时,集合CombSet1和CombSet2中尚未被已有测试用例覆盖的组合分别构成集合UncovCombSet1={(f1=1,f2=1),(f1=1,f2=2)}和UncovCombSet2=.此时,若优先为r2中的因素赋值,则在没有导向的情况下,因素f1和f3的取值可随机选定,且f1=2的概率为50%.而一旦f1被赋值为2,当前所生成的这条测试用例就无法再覆盖UncovCombSet1中的任何组合,即对组合覆盖率的提高没有任何贡献,是一条冗余的测试用例.反之,若优先为r1中的因素赋值,可以从UncovCombSet1中选择组合(f1=1,f2=1)或(f1=1,f2=2),可保证覆盖至少一个组合.组合的数量与max1kt|CombSetk|的比值作为该函数的值.显然,该函数的值域为[0,1].此外,我们注意到交互关系中不同的覆盖需求之间可能存在交集.这样,在为某个覆盖需求rk中Page7的因素赋值时,其中的某些因素可能在处理其它覆盖需求时已被赋过值.相应的,集合CombSetk中可被选择的未覆盖组合也会受到限制,只有部分满足已赋值因素取值条件的组合可被统计并用于计算上述度量函数.例如,图2中的两个覆盖需求r1和r2间即存在交集,若优先处理r2并选择(f1=2,f3=1),则在处理覆盖需求r1时,CombSet1中只有那些满足条件f1=2的因素取值组合可能被选择.针对这一情况,有必要对度量函数进行调整,具体如下文所示.进一步地,在极端情况下,若当前覆盖需求rk中的所有因素均已被赋值,则说明CombSetk已存在一个组合被当前测试用例所覆盖.此时可分两种情况讨论:如果该组合此前尚未被已有测试用例覆盖,说明当前测试用例覆盖了一个新的组合,度量函数值应达到最大值1;反之,若该组合此前已被已有测试用例覆盖,则说明当前测试用例对于rk没有贡献,度量函数值为最小值0.综合上述分析,我们可以针对覆盖需求rk∈R(1kt)定义度量函数:ReqEvaluate(rk)=numk其中,numk表示集合CombSetk中未被已有测试用例覆盖、且满足已赋值因素取值条件的组合的数量.pk表示rk中已赋值因素的数量,即pk=|rk|-|rk|.若pk=nk,表示rk中所有因素均已被赋值.定义覆盖需求度量函数后,即可根据该函数的值来确定生成当前测试用例时各个覆盖需求处理的顺序.如上文所述,一条测试用例对于某个覆盖需求的贡献可用该覆盖需求的度量函数值来度量:当该覆盖需求所含的因素均已被赋值后,若有新的组合被当前测试用例覆盖,则对应的度量函数值为1;反之则为0.由此可见,在生成测试用例时,我们应使每个覆盖需求度量函数的值都尽可能的大.相应的,可以将所有覆盖需求度量函数值之和,定义为针对交互关系R的一个全局度量函数:GlobalEvaluate(R)=∑t在生成测试用例时,保证全局度量函数的值尽可能大即可.这样,我们就得到了在one-test-at-a-time策略中生成一条测试用例的一种可行方法.在该方法中,每次均选择一个覆盖需求度量函数值最大的覆盖需求,不妨假设其为rk(1kt),并保证该覆盖需求中至少含有一个尚未被赋值的因素.选择rk后,对于集合CombSetk中所有尚未被已有测试用例覆盖,且满足已赋值因素取值条件的组合,均尝试将其填充入当前测试用例,并计算赋值后全局度量函数的值.最后,选择一个使得全局度量函数值最大的组合,并最终按照该组合为rk中的因素赋值.该过程反复进行,直至F中所有的因素均在当前测试用例中被赋值.具体过程可见算法2.算法2.按照覆盖需求顺序生成单条测试用例的算法(DA-RO).输入:因素集合F,因素交互关系R,剩余组合集合输出:测试用例test1.Initializetest[1…n];//初始化一个长度为n的数2.DealedReq··=;3.DealedFactor··=;4.While(DealedFactor≠F)5.Fork··=1tot6.If(rk∈R-DealedReq)Then7.EndFor8.选择一个rk∈R-DealedReq,使得ReqEvaluate(rk)9.ForEachcomb∈CombSetk10.If(comb满足test中已赋值因素的取值条件)11.假设rk中因素按照comb赋值,计算赋值后12.EndIf13.EndFor14.选择一个comb∈CombSetk,使得GlobalEvaluate(R)15.依据组合comb对rk中的因素进行赋值;16.DealedFactor··=DealedFactor+rk;17.DealedReq··=DealedReq+{rk};18.EndWhile下面分析算法2的时间性能.首先,计算覆盖需求度量函数值所需的时间复杂度与覆盖需求、未覆盖组合的数量以及覆盖需求中已赋值因素的数量均有关,难以准确描述,只能得到一个上界O(|rk|×|CombSetk|),相应的,计算全局度量函数值所需的时间复杂度上界为O∑t选择一个覆盖需求时,最多需要比较所有t个覆盖需求对应的度量函数值,其时间复杂度不超过(O∑t1,2,…,t)中的因素进行赋值,需要针对集合CombSeti中所有尚未被覆盖、且满足已赋值因素取值条件的(|rk|×|CombSetk|k=1Page8组合分别计算交互关系度量函数值,其时间复杂度不超过O|CombSeti|×∑t上述操作最多进行min(t,|F|)次后,即可保证F中所有的因素都在当前测试用例中被赋值.因此,使用算法2生成一条测试用例所需的最坏时间复杂度为(O∑ti=1∑tk=14.2按照因素顺序生成单条测试用例针对一个给定的组合集合UncovCombSet生成一条测试用例,也可以考虑采取逐个因素依次赋值的方法进行.如AETG[16]、TCG[17]、DDA[18]等经典的固定力度组合测试用例集的生成算法即是如此.本小节将尝试使用逐因素依次赋值的方法来生成一条测试用例,该方法也可看做是DDA算法在可变力度组合测试用例集生成中的一种扩展.采取逐因素依次赋值的方式生成测试用例,首先必须应确定因素处理顺序.类似的,我们可以定义一个因素度量函数,并按照因素度量函数的值确定因素赋值的先后顺序.与覆盖需求度量函数的意义类似,计算因素度量函数的意义在于优先处理那些涉及更多未覆盖组合的因素.因此,可以考虑将因素度量函数定义为所有包含该因素的覆盖需求所对应的覆盖需求度量函数值之和,即FactorEvaluate(fi)=∑t其中,函数ReqEvaluate(rk,fi)是覆盖需求度量函数ReqEvaluate(rk)的一个变种,其定义为ReqEvaluate(rk,fi)=ReqEvaluate(rk),fi∈rk.显然,一个因素若被包含于数量较多的覆盖需求,且这些覆盖需求都具有较高覆盖需求度量函数值,则该因素也就具有较高的因素度量函数值.这样的因素在生成一条测试用例时也应尽早赋值,以尽可能提高测试用例对于未覆盖组合的贡献.由此,可得到在one-test-at-a-time策略中生成一条测试用例的另外一种可行方法.在该方法中,每次均选择一个因素度量函数值最大的因素,不妨假设其为fi(1in).选择因素fi后,对于因素取值集合Vi中的所有ai个取值,均尝试将其填充入当前测试用例,并计算进行该赋值后全局度量函数的值.最后选择一个使得全局度量函数值最大的取值,并最终按照该取值为因素fi赋值.该过程反复进行,直至F中所有的因素均在当前测试用例中被赋值.具体过程可见算法3.算法(DA-FO).算法3.按照因素顺序生成单条测试用例的输入:因素集合F,因素交互关系R,剩余组合集合输出:测试用例test1.Initializetest[1…n];//初始化一个长度为n的数2.DealedFactor··=;3.While(DealedFactor≠F)4.Fori··=1ton5.If(fi∈F-DealedFactor)Then6.EndFor7.从F-DealedFactor中选择一个因素fi,使得8.ForEachv∈Vi9.假设test[i]··=v,计算此时的GlobalEvaluate(R);10.EndFor11.选择一个取值v,使得全局密度最大;12.test[i]··=v;13.DealedFactor··=DealedFactor+{fi};14.EndWhile算法3在选择因素时,可能出现多个待选因素均具有最大度量值的情况.在为给定因素选择赋值时,这一情况也可能出现.与算法2类似,使用First策略选择其中下标最小的因素或取值即可.下面分析算法3的时间性能.在最坏情况下,每次为选择一个因素而计算F中所有n个因素的因素度量函数时,首先应计算R中所有t个覆盖需求所对应的覆盖需求度量函数,即选择一个因素所需的最坏时间复杂度为O∑t因素fi进行赋值,需要针对Vi中所有ai个可能取值分别计算全局度量函数的值,其时间复杂度为(Oai×∑t次后,即可保证F中所有的因素都在当前测试用例中被赋值.因此,使用算法3生成一条测试用例的最坏时间复杂度为O∑n可见,在∑n最坏时间复杂度低于算法2的最坏时间复杂度,而这一条件在大多数情况下是成立的.5实验为了检验算法的效果,我们基于算法2、算法3Page9分别实现了工具DA-RO、DA-FO,并将它们与一些已有的算法和工具进行比较.以下实验均在2.66GHzPentiumIV处理器、1GB内存的环境下进行.5.1可变力度组合测试用例集生成中的效果首先检验算法在生成可变力度组合测试用例集时的效果.我们将两种算法与ReqOrder、ParaOrder、Union、Greedy、PICT、TVG等算法和工具进行比较.其中PICT、TVG均下载自网络,Union、Greedy则按照文献[10]的描述实现.对于算法Greedy,尽管Cheng等人[19]针对其时间性能较差的弱点提出了一种解空间约简算法以提高其效率,但方法并非Greedy的变种或改进,而只是一种对算法输入进行预处理的方法.原输入约简后可作为Greedy的输入,也同样可以作为其它测试用例集生成算法的输入.考虑到该方法可能导致测试用例集规模增大,故我们在实现时不做考虑.下面讨论实验的输入.尽管文献[10,19]中已给出一些实验结果,但实验的输入数据却没有公开,因此我们需要设计实验方案.首先,选择因素集合F={310}和F={23×33×43×5}以分别代表单一水平表3可变力度组合测试用例集的规模及算法耗时(犉={310})|R|DA-RODA-FOReqOrderParaOrderUnionGreedyTVGPICT281(0.08s)81(0.02s)81(0.01s)81(0.01s)162(0.01s)81(1.04s)81(-)81(0.69s)381(0.11s)81(0.02s)81(0.01s)81(0.01s)242(0.01s)81(1.91s)84(-)-1086(0.44s)84(0.07s)99(0.01s)96(0.01s)503(0.01s)93(6.77s)86(-)-2095(0.98s)99(0.14s)128(0.01s)105(0.02s)858(0.02s)91(18.0s)105(-)-30116(1.98s)120(0.30s)157(0.01s)111(0.04s)1599(0.04s)109(34.0s)125(-)-40126(3.02s)123(0.44s)163(0.01s)120(0.05s)2057(0.06s)111(50.7s)135(-)-50135(3.74s)135(0.60s)172(0.04s)132(0.06s)2635(0.10s)125(70.2s)139(-)-60141(4.96s)142(0.77s)190(0.05s)144(0.08s)3257(0.15s)141(110s)150(-)-表4可变力度组合测试用例集的规模及算法耗时(犉={23×33×43×5})|R|DA-RODA-FOReqOrderParaOrderUnionGreedyTVGPICT264(0.04s)64(0.01s)64(0.01s)64(0.01s)104(0.01s)64(1.35s)64(-)64(0.71s)3144(0.24s)144(0.04s)144(0.01s)144(0.01s)248(0.01s)144(2.06s)144(-)-10144(0.71s)144(0.11s)144(0.01s)144(0.02s)505(0.01s)144(8.60s)144(-)-20160(1.78s)160(0.23s)166(0.01s)161(0.03s)929(0.01s)160(26.3s)161(-)-30165(4.35s)175(0.50s)204(0.01s)179(0.06s)1861(0.06s)162(66.8s)179(-)-40165(5.67s)172(0.65s)209(0.02s)183(0.11s)2244(0.08s)167(111s)181(-)-50182(7.96s)186(0.87s)229(0.02s)200(0.14s)2820(0.13s)183(161s)194(-)-60197(11.15s)200(1.22s)237(0.05s)204(0.16s)3587(0.21s)197(259s)209(-)-通过表3和表4可以看出,在大多数情况下Greedy都可生成规模最小的测试用例集,但其运行时间也是所有算法(不考虑TVG和PICT)中最长的.在本文提出的算法中,DA-RO共10次生成最小测试用例集,DA-FO共7次生成最小测试用例集.从总体上看,除Greedy外,DA-RO在所有算法中效果最好,DA-FO与ParaOrder效果相当,其次为TVG和ReqOrder,而Union的效果最差.在算法运系统和混合水平系统;其次,从给定的集合中顺序选择给定数量的覆盖需求,从而建立交互关系R(本次实验所使用的覆盖需求集合为附录中的ReqSet).出于两方面的原因,集合ReqSet中所有覆盖需求所含因素的数量(即该覆盖需求的交互力度)均在2~4之间:(1)Kuhn等人[2-3]曾指出,故障所对应的因素交互力度(FTFI)多数在2~4之间,且FTFI值为3以上的故障数量极少;(2)当交互关系R中出现极少数交互力度较大的覆盖需求时,测试用例集的规模将主要取决于这些交互力度较大的覆盖需求,而算法性能本身的影响力则相对比较小.表3和表4从测试用例集规模和算法运行的CPU时间这两个方面,给出了几种算法和工具在生成可变力度组合测试用例集时的效果.由于TVG基于GUI界面,难以精确统计CPU时间,因此没有给出其耗时方面的数据.对于PICT,尽管相关文献说明它能处理任意数量的覆盖需求(Sub-Mod-els)[11],但在实际运行中我们发现,当|R|>2且覆盖需求之间存在交集时,PICT就已难以正常运行,在运行长达1h的时间后仍然无法得出结果.行时间方面,ReqOrder用时最短,其次为ParaOrder和Union,DA-FO的时间性能略差于前三者,但优于DA-RO,这与前文中对时间复杂度进行理论分析的结果是基本吻合的.5.2固定力度和“狭义”可变力度组合测试用例集生成中的效果除检验算法在生成可变力度组合测试用例集时的效果外,我们还将检验它们在可变力度组合测试Page10的一种特例,即固定力度组合测试中的效果.由于已有实验结果表明Union和ReqOrder的效果相对较差,生成测试用例集的规模过大,因此在后续的实验中将不再考虑该算法.表5给出了13种算法和工具在生成固定力度表5固定力度3维组合测试用例集的规模DA-RODA-FOParaOrderGreedyTVGPICTAETGGAACAGA-NIPO-NIPOJennyS150475343484838333352474851S2646410664120111776464856464112S3213211225184239215194125125223173200215S4362359363325409369330331330389371366373S51592158716241474194916221473150114961769150216781572S6242237225220269241218218218336199239236S7119116108106133119114108106120113120130S8365369377388429368377360361373368464397注:S1:36;S2:46;S3:56;S4:66;S5:106;S6:57;S7:524232;S8:101624331.通过表5可以看出,相对于几种已有的专用于固定力度组合测试用例集生成的算法和工具(如GA、ACA、AETG),本文提出的两种算法在性能上存在一定的差距.而相对于几种可用于生成可变力度组合测试用例集的算法和工具,本文提出的算法除略差于Greedy,但在大多数情况下均优于ParaOrder、PICT和TVG.在本次实验中,尽管Greedy可以生成规模很小的测试用例集,但其时间性能依然是其最大的缺陷,例如对于输入S5,Greedy运行所需的CPU时间已接近1h,而其它算法和工具基本都可在10s之内得出结果.表6“狭义”可变力度组合测试用例集的规模犞犛犆犃(m;2,315,C)犞犛犆犃(m;2,435362,C)犞犛犆犃(m;2,320102,C)3维组合测试用例集时的结果.其中,AETG[16]、GA[20]、ACA[20]的数据来源于文献[20];GA-N、IPO-N的数据来源于文献[21];IPO[8]的数据通过运行工具TConfig①而得;Jenny的数据则通过运行开源工具Jenny②而得.最后,我们还对几种算法和工具在“狭义”可变力度组合测试用例集生成中的效果进行了检验.本次实验比较了本文提出的两种算法、Greedy、PICT、TVG以及Cohen等人[1]提出的专门用于生成“狭义”可变力度组合测试用例集的算法SA(SimulatedAnnealing).表6给出了几种算法和工具生成的“狭义”可变力度组合测试用例集的规模.该实验所使用的输入以及算法SA的数据均来源于文献[1].对于其中的部分输入,由于Greedy算法未能在1h的规定CPU时间内运行完毕而没有得到实验结果.①②Page11通过表6可以看出,使用模拟退火算法的SA对于所有输入均可生成最小的测试用例集.若不考虑SA所得的结果,则在其它算法和工具中,DA-RO共17次生成了最小测试用例集,DA-FO共12次生成了最小测试用例集,均明显优于其它算法和工具.我们还注意到,此前在测试用例集规模方面表现优异的Greedy在本次试验中没有任何优势,且对于部分输入由于其较差的时间性能而没有在规定CPU时间内得到结果.5.3实验结论通过以上共3组实验可以看出,本文提出的算法DA-RO和DA-FO在可变力度组合测试用例集、固定力度组合测试用例集以及“狭义”可变力度组合测试用例集的生成中均具有比较好的效果.其中DA-RO所生成测试用例集的规模普遍小于DA-FO,但时间性能则不及后者.由于上文所述的几种算法均为启发式算法,都不能保证生成最优解,因此在实际的测试工作中,综合运用各种测试用例生成方法,取长补短,可以取得更好的效果.而本文提出的算法在各场景下均具有一定的优势,在组合测试、尤其是可变力度组合测试用例集的生成时,可成为一种较优的选择.6小结针对传统的固定力度组合测试方法以及Cohen等人提出的“狭义”可变力度组合测试方法中所存在的问题,本课题组提出一种新的可变力度组合测试方法.这种新的可变力度组合测试模型可以更为准确地描述待测系统中的因素间交互作用,进而可为测试用例集的设计和生成提供更好的指导.针对这一模型,在假设因素间交互关系已知的情况下,本文给出了两种基于one-test-at-a-time策略的可变力度组合测试用例集生成算法.实验表明,本文提出的算法除在可变力度组合测试用例集的生成中具有很好的效果外,在固定力度组合测试用例集以及“狭义”可变力度组合测试用例集的生成中同样具有一定的竞争力.目前,组合测试领域的大多数工作关注于相对简单的固定力度组合测试模型.而事实上,不同类型组合测试模型的选择对于组合测试的应用起着至关重要的作用.因此,有必要深入研究组合测试的各种应用场景,总结更多、更详细的组合测试模型,指导人们迅速区分哪些软件系统或软件系统的哪些方面适合使用组合测试方法.此外,由于组合测试用例集的生成问题是NP-C问题,而元启发式搜索方法是一种解决NP-C问题的常用方法,因此有必要对其在组合测试用例集生成中的应用进行进一步的研究和探索.
