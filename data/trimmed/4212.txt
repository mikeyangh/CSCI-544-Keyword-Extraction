Page1回归测试数据进化生成巩敦卫任丽娜(中国矿业大学信息与电气工程学院江苏徐州221116)摘要采用遗传算法生成回归测试数据近年来得到普遍关注,该方法高效生成测试数据的前提是合理利用已有的测试数据形成初始进化种群,并设计有针对性的遗传操作.但是,到目前为止,相关的研究成果尚不多见.文中研究采用遗传算法生成回归测试数据以覆盖目标路径时,已有测试数据的利用问题,提出一种新的回归测试数据进化生成方法.该方法根据已有测试数据穿越的路径与目标路径的相似度,选择合适的测试数据,作为初始进化种群的部分个体.进一步,根据已有测试数据穿越的路径与目标路径不相同子路径的节点对应的输入分量,确定对进化个体实施遗传操作的位置.理论分析表明,所提方法可以有效提高测试数据生成效率.将所提方法应用于典型基准和工业程序的测试,并与已有方法比较,实验结果证实了所提方法的优越性.关键词回归测试;路径覆盖;测试数据生成;遗传算法;软件测试1引言软件测试的目的是发现被测软件(程序)中可能存在的缺陷或错误.即使没有发现缺陷或错误,也并不意味着被测软件就是完好的.同时,软件测试也可以提高被测软件的可信度[1].因忽视测试造成严重后果的例子不计其数,典型的例子如导致阿里亚娜5型火箭发射失败的软件缺陷,就是由于复用的代码没有经过充分的回归测试造成的.所谓回归测试,是指修改了程序代码后,对修改后程序重新测试,以确认修改没有引入新的错误,或导致其他代码产生错误[2].回归测试作为软件生命周期的一个重要组成部分,在软件测试中占有很大比重,软件开发的各阶段都会进行多次回归测试.在渐进和快速迭代程序开发中,程序新版本的连续发布,使回归测试更加频繁.在极端编程方法中,要求每天都进行若干次回归测试[3].据估计,回归测试在整个测试预算中占80%,在软件维护中占50%[4].因此,选择正确的回归测试策略,以提高回归测试效率,是非常有意义的.在生命周期中,一个软件会被频繁地修改,修改后的软件或者增加新的功能,或者变化原来的功能.随着软件的修改,原有测试数据集中的一些数据可能不再适用,使得采用这些测试数据运行修改后的程序难以揭示其中的问题[5].每次修改软件后,如果对该软件的所有目标路径都再重新生成新的测试数据,以进行回归测试,将无疑是一项非常繁杂的工作.将遗传算法用于测试数据再生成,从一定程度上提高了回归测试的效率,但是,仍然不能满足实际软件测试的需求.这是因为,已有的测试数据再生成方法,在种群进化过程中,没有充分利用已有测试数据提供的有用信息.这说明,研究新的回归测试数据生成方法,以充分利用已有测试数据的信息,对提高回归测试效率是非常必要的.本文研究采用遗传算法生成回归测试数据以覆盖目标路径时,已有测试数据的利用问题,提出一种新的回归测试数据进化生成方法.该方法根据已有测试数据穿越的路径与目标路径的相似度,选择合适的测试数据,作为初始进化种群的部分个体.进一步,根据已有测试数据穿越的路径与目标路径不相同子路径的节点对应的输入分量,确定对进化个体实施遗传操作的位置.通过理论分析,说明所提方法可以有效提高测试数据生成的效率.通过将所提方法应用于典型基准和工业程序的测试,并与已有方法比较,证实所提方法的优越性.本文的贡献体现在如下3个方面:(1)给出了采用遗传算法生成回归测试数据时,初始种群的构成方法.采用该方法构成的初始种群,其一部分个体来自已有测试数据集,且覆盖的路径与目标路径的相似度很大,提高了初始种群的性能;(2)给出了变异操作的位置,使得变异操作能够有效改变与目标路径未覆盖子路径对应的输入分量的值,以尽快覆盖这些子路径;(3)从理论上证明,所提方法可以提高测试数据生成的概率.本文第2节综述相关工作;回归测试数据生成问题的数学模型在第3节建立;第4节是本文的重点,给出采用遗传算法生成回归测试数据时,已有测试数据的利用方法,包括:利用已有测试数据的必要性、初始种群形成、遗传操作分量确定以及算法步骤等;算法的性能分析在第5节给出;第6节是所提方法在典型基准和工业程序的测试以及对比实验;最后,第7节总结全文,并指出需要进一步研究的问题.2相关工作为了测试修改后程序的正确性,利用已有测试数据集测试修改后程序,是一种可行的方法,这方面的研究工作包括测试数据缩减、测试数据选择以及测试数据扩大等.Nachiyappan等人[6]采用进化算法缩减回归测试数据时,基于已有测试数据形成初始进化种群,选择语句覆盖率较高且运行时间较短的个体作为父代个体,通过进化生成子代种群,由优化后的测试数据构成缩减测试数据集.Zhang等人[7]通过分析程序的树形结构,找到发生改变的路径,并确定影响路径改变的分支.对与修改点无关的分支树修剪后,生成测试数据,以覆盖修剪后树形结构包含的路径.Sun[8]利用缺陷对应的约束条件间的包含关系,减少需要覆盖的约束条件,以缩减覆盖约束条件的测试数据.在上述测试数据缩减方法中,Nachiyappan等人缩减测试数据集的过程较为繁琐和耗时;而Zhang等人与Sun的方法没有挖掘与应用已有测试数据提供的有用信息.测试数据的选择主要有基于语句和基于模型两种方法,其中,前者通过静态分析程序修改前后发生Page3变化的语句,选择测试数据[9-11],只适用于采用特定语言编写的程序;而后者通过对比程序修改前后对应模型的变化,选择测试数据.Ye等人[12]研究基于模型的测试数据选择问题,通过对比程序修改前后的活动图,找出有影响的、没有影响的以及删除的路径.基于测试数据与路径间的关系,对已有测试数据分类,以选择需要修改的测试数据.Kumar等人[13]分析修改前后程序的路径,选择新增加和发生改变的路径作为需要覆盖的路径.利用精英保留遗传算法,生成覆盖路径的测试数据.该方法通过路径选择达到测试数据选择的目的.El-hamid等人[14]通过功能相互作用图,获取程序发生的句法和语义变化,并仅选择与变化部分相关的测试数据.在上述基于模型的测试数据选择方法中,Ye与Kumar等人提出的方法均通过对比程序修改前后路径的变化,选择需要覆盖的路径,然后生成测试数据;El-hamid等人提出的方法只从已有测试数据中选择与变化部分相关的测试数据,没有考虑需要生成的新的测试数据.Shin等人[15]鉴于使用已有测试数据生成新的测试数据可以缩短测试数据生成时间,利用已有测试数据,考虑不同的测试变量搜索域和交互水平,基于搜索方法生成新的测试数据.Santelices等人[16]根据数据与控制的依赖关系,以与修改点相关的路径作为目标路径,生成的测试数据仅覆盖目标路径中受修改点影响的部分语句.Xu等人[17]应用已有测试数据运行修改后的程序,以发生改变的语句作为目标语句,根据目标语句的个数,选择一定数量的已有测试数据构成初始种群,并利用遗传算法生成覆盖目标语句的测试数据.在进化过程中,能够覆盖目标语句的新的测试数据不断并入到进化种群中,以引导测试数据的生成.在上述测试数据扩大方法中,Shin等人提出的方法以已有测试数据的邻域作为新的测试数据,使得生成的测试数据存在大量冗余;Santelices等人提出的方法没有考虑已有测试数据的应用;而Xu等人仅对已有测试数据进行数量的筛选,没有考虑这些测试数据的质量.可以看出,这些方法均没有充分利用已有测试数据提供的有用知识.如果将这些知识融入到基于遗传算法的测试数据生成过程,将无疑会充分发挥遗传算法生成测试数据的潜能,从而提高回归测试数据生成的效率.3问题建模本节建立回归测试数据生成问题的数学模型.记原来的程序为P,包含的路径为p1,p2,…,pm,其中,m是P包含的路径条数,已有的覆盖这些路径的测试数据分别为t1,t2,…,tm;对P修改后的程序为P,包含的路径为p1,p2,…,pm,其中,m是P包含的路径条数.现在的问题是:在P的输入域中寻找测试数据,使得以这些数据为输入运行P后,执行的路径分别是p1,p2,…,pm.一般来讲,修改前后的程序P和P的输入域相同,因此,如果记P的输入域为D,那么,t1,t2,…,tm∈D.本文采用遗传算法生成覆盖目标路径的测试数据.鉴于遗传算法是一种求解优化问题的方法,因此,需要首先将测试数据生成问题转化为优化问题.记P的输入为x,它可能是一个标量,也可能是一个向量,由具体的被测程序决定.容易知道x∈D.以x作为P的输入运行程序后,执行的路径记为p(x).如果存在i∈{1,2,…,m},使得p(x)等于pi,那么,x即为覆盖目标路径pi的测试数据.如果对任意i∈{1,2,…,m},p(x)均不等于pi,那么,可以利用文献[18]的方法,计算x对覆盖目标路径pi满足的程度,或者说,p(x)与pi的接近程度,记为fi(x),i=1,2,…,m.通常,fi(x)包含两部分,即层接近度和分支距离,其中,层接近度衡量测试数据穿越的路径偏离目标路径的程度,通过从左向右依次比较p(x)与pi各位的编码,记录对应编码位不相同的个数,除以目标路径的长度pi,得到的值即为p(x)与pi的层接近度;分支距离衡量使一个谓词为真(或假)的条件的满足程度,从左向右依次比较p(x)与pi各位的编码,记录第一个不相同的编码位,计算该编码位对应的节点处,x与使得该节点变成真(或假),从而使得p(x)与pi在该节点相同的距离,对该值标准化,作为分支距离.由此可知,p(x)越接近pi,fi(x)的值越小,特别的,当p(x)等于pi时,fi(x)的值为0.这样一来,覆盖目标路径p1,p2,…,pm的测试数据生成问题可以建模为如下最小化问题:Page4容易看出,式(1)由m个单目标子优化问题构成,因此,可以通过顺次(串行)求解这m个子问题,得到覆盖目标路径的测试数据.当然,也可以采用并行策略,同时求解这些子问题,从而提高测试数据生成的效率.本文的重点在于寻求测试数据生成过程中已有测试数据的利用方法,而非比较多个子问题并行/串行求解的效率,因此,本文采用串行方法求解这m个子问题.为便于说明,下面仅考虑第i个子问题的求解,即覆盖pi的测试数据生成问题,其数学模型为4测试数据生成4.1利用已有测试数据的必要性采用传统遗传算法直接求解式(2),是一种可行方法,也是最常用方法.遗传算法是一种弱方法[19],虽然通用性强,但是,对某一具体问题的求解效率未必很高.如果将已有知识融入到遗传算法的求解过程,无疑会充分发挥遗传算法的并行潜能,从而提高遗传算法的求解效率.因此,问题的关键在于有用知识的获取与合理利用.需要注意的是,我们解决的问题是回归测试的路径覆盖测试数据生成.既然是回归测试,就说明已经具有了覆盖原来程序目标路径的测试数据.一般来讲,覆盖相似目标路径的测试数据相差不大.如果分析已有测试数据覆盖的路径与目标路径的相似程度,并据此选择已有的测试数据,将能够得到一些有用知识,用于生成覆盖新路径的测试数据.利用已有知识的方式很多,可以用于生成初始种群,以提高初始种群的质量[20];可以用于确定遗传操作策略,以提高遗传操作的效率[21];可以用于调整控制参数,以控制种群的进化进程[22]等等.本文利用原来程序的目标路径及其测试数据,形成初始进化种群,并确定遗传操作分量,以提高覆盖新路径的测试数据进化生成效率.Bueno等人[23]曾指出,相似路径间的测试数据也有相似性,基于此建立了路径测试数据库,对于相似路径的测试数据生成,优先从数据库中选取已有测试数据作为初始种群.采用这种策略后,6个程序的测试数据个数平均减少了53%.这表明,利用已有测试数据形成初始种群,是非常必要的.4.2初始种群形成为了说明初始种群的形成,首先介绍一个概念.路径相似度是指路径相似的程度.现在说明两条路径相似度的计算方法.考虑程序P的两条路径pi和pj,形成这两条路径的节点序列分别为ni1,ni2,…,ni|pi|和nj1,nj2,…,nj|pj|,其中,|pi|和|pj|分别为pi和pj包含的节点个数.采用基于节点序列匹配的方法[24],找到路径pj中第一个与ni1相同的节点,并依次比较后续节点,直到遇到不相同节点,记为ni1,若连续相同节点数大于1,则将这段连续相同节点记为一段相同子路径,然后继续在pj的后续节点中找与ni1相同的节点,重复上述方法,直到节点ni|pi|.将pi和pj所有相同的子路径记为pi∩pj,其包含的节点个数为|pi∩pj|.那么,pi和pj的相似度记为s(pi,pj),可以表示为例如,3条路径p0:n0,n1,n2,n4,n5,n6,p1:n0,n1,n2,n3,n4,n5,n6和p2:n0,n2,n3,n4,n5,n6,那么,p0∩p1={n0,n1,n2,n4,n5,n6},s(p0,p1)=0.86,p0∩p2={n4,n5,n6},s(p0,p2)=0.50.以t1,t2,…,tm作为输入运行P后,执行的路径分别为p(t1),p(t2),…,p(tm).现在考察路径p(ti)和目标路径pj的相似度,i=1,2,…,m;j=1,2,…,m.记s(p(ti),pj)为sij,可以得到如下相似度矩阵,记为犛考虑矩阵犛的第j列元素,寻找所有i∈{1,2,…,m},使得sij1的相似度将很大.这意味着,用ti作为P的输入运行程序后,执行的路径将很接近pj.如果ti作为初始进化种群的个体,将有利于生成覆盖pj的测试数据,称它们为有用测试数据.为此,通过遗传算法生成覆盖pj的测试数据时,初始进化种群的一部分个体由t1,t2,…,tm中的有用测试数据构成,不妨记这些测试数据为t1,t2,…,tu,其中,u为有用测试数据的个数,其余个体在程序P的输入域D内随机生成.Page54.3遗传操作分量确定考察以t1,t2,…,tu作为输入运行P后,执行的路径p(t1),p(t2),…,p(tu).这些路径与目标路径pj比较后,得到与pj的不相同子路径分别为pj-p(t1)∩pj,pj-p(t2)∩pj,…,pj-p(tu)∩pj.影响这些子路径的输入分量可以通过文献[25]的方法得到,个数分别为n(t1),n(t2),…,n(tu).正是由于这些输入分量没有满足要求,使得执行的路径偏离了pj.为了生成覆盖pj的测试数据,需要通过对这部分分量进行遗传操作,以改变它们的取值.不妨设程序P的输入x包含ni个分量,那么,ti可以表示为不失一般性,假设ti的前n(ti)个分量需要改变,即需要改变的分量为ti,1,ti,2,…,ti,n(ti).现在考虑对个体ti的遗传操作.为便于处理,这里仅考虑对ti的变异操作.首先考虑ti的后ni-n(ti)个分量.由于这些分量可以覆盖pj的部分子路径,因此,在变异操作时,这些分量保持不变,记ti变异后的个体为ti,那么,ti的后ni-n(ti)个分量为ti,n(ti)+1,ti,n(ti)+2,…,ti,ni.然后考虑ti的前n(ti)个分量的变异操作.由于这些分量的影响,使得p(ti)的子路径偏离了pj的相应部分.为了生成覆盖pj的测试数据,需要对这些分量进行变异.为此,在ti,1,ti,2,…,ti,n(ti)中随机选择一个基因位,并生成一个[0,1)之间的随机数.当该随机数小于或等于设定的变异概率时,对选定的基因位在取值范围内用随机产生的一个值替代.记变异后的分量为ti,1,ti,2,…,ti,n(ti),其输入域分别记为Di,1,Di,2,…,Di,n(ti),容易知道,Dj∏nik=n(ti)+1ti=(ti,1,ti,2,…,ti,n(ti),ti,n(ti)+1,ti,n(ti)+2,…,ti,ni)(6)采用完全相同的方法,可以得到t1,t2,…,ti-1,ti+1,…,tu变异后的个体.对于初始种群中随机生成的个体,由于没有可供利用的信息,因此,仍然采用传统的方法实施交叉和变异操作,从而得到新的个体.4.4算法步骤的步骤如下:以生成覆盖pj的测试数据为例,本文所提算法1.设定算法所用参数的值;2.利用测试数据t1,t2,…,tm运行程序P,计算执行的{tik}D,那么,ti可以表示为路径p(t1),p(t2),…,p(tm)与pj的相似度;3.根据4.2节中的方法,得到有用测试数据t1,t2,…,tu,作为初始种群的部分个体,其余个体在程序P的输入域D内随机生成;4.以t1,t2,…,tu作为输入运行P后,根据执行的路径p(t1),p(t2),…,p(tu)与pj的不同子路径pj-p(t1)∩pj,pj-p(t2)∩pj,…,pj-p(tu)∩pj,确定影响这些子路径的输入分量ti1,ti2,…,tin(ti);5.判断算法是否满足终止条件,算法的终止条件是生成的测试数据覆盖修改后程序的目标路径,或算法达到最大进化代数.若满足,转步骤7;6.利用4.3节中的方法,对t1,t2,…,tu或其子代个体实施遗传操作;对于随机生成的个体或其子代个体,仍然采用传统遗传操作.产生下一代种群后,转步步骤5;7.算法结束,输出覆盖pj的测试数据.5性能分析本文主要提出2种新方法,一是4.2节的初始种群生成方法,另一个是4.3节的已有测试数据遗传操作分量的确定方法.测试数据进化生成问题,就是在软件输入域中搜索能够覆盖目标路径的测试数据.如果某方法生成覆盖目标路径的测试数据的概率大,那么,该方法生成的测试数据就能以高的概率覆盖目标路径,从而生成的测试数据的效率得到提高.因此,本节通过比较生成覆盖目标路径的测试数据的概率,验证4.3节介绍的方法的有效性,思想是:在输入域中,采样到的能够覆盖目标路径测试数据的个数与总的测试数据的比值越大,那么,找到能够覆盖目标路径测试数据的概率就越大.为m(D):首先,定义程序P的输入域D的一个测度,记容易知道,如果D分别是一维、二维和三维空间,那么,其常用测度分别为长度、面积和体积.进一步,如果D是一个超体,那么,其常用测度为超体积.设所有覆盖pj的测试数据构成的输入域为Dj,那么,D、DjPage6根据多重积分的性质,容易知道,输入域D越小,m(D)的值就越小.由图1中D、Dj可知,m(Dj)m(Dj对于任意的x∈Dj于Dj是固定的,因此,Dj考虑Dji的个体适应值的平均值表示如下:于Dj式中,|Dj的个体数量为n(DjF(Dj定理[4],可以知道:考虑第t代进化种群,记为x(t),其中属于Dji,t),根据基于遗传算法的测试数据生成模式迭代计算以后,可以得到i,T)n(Djn(Dj由于n(Dj的值是固定的.此时,若m(Dj体执行的路径越接近目标路径,使得F(Dj1,2,…,T-1越大,相应的,n(Dj那么,第T代种群找到覆盖pj的测试数据的概率,记为p(pj,T),可以表示为p(pj,T)=m(Dj)n(Dj由式(10)可知,m(Dji,T)的值也越大,那么,p(pj,T)也越大.对于测试数据ti,按照第4.3节的方法,如果需要改变的分量个数n(ti)越少,那么,m(Dj从而p(pj,T)的值就越大.这说明,采用本文方法充分利用了已有测试数据的有用信息,以减少个体需要改变的分量个数,缩小搜索空间,可以增加生成覆盖目标路径的测试数据的概率,从而提高测试数据进化生成的效率.6实验为了验证本文提出的回归测试数据进化生成方法的有效性,将本文方法与传统的回归测试数据生成方法以及随机法,应用于典型基准程序和工业程序的测试,以生成覆盖目标路径的测试数据.本文方法先计算已有测试数据覆盖的路径与目标路径的相似度,以筛选有用测试数据,作为初始种群的部分个体;然后,确定遗传操作分量;最后,利用4.3节中的方法,生成覆盖目标路径的测试数据.传统的回归测试数据生成方法直接将已有的测试数据作为初始种群;然后,利用遗传算法生成覆盖目标路径的测试数据.随机法则直接将修改后的程序作为新的被测程序,使用随机法生成覆盖目标路径的测试数据.所有程序均采用C语言编写,在VC++6.0环境下运行,机器主频为2.80GHz,内存为2GB.6.1测试程序选取1个基准测试程序sumday和4个工业程序,分别是sed_2[1].0、interserve、totinfo_2.0和spice,这些程序被广泛应用于验证不同测试数据生成方法的有效性[26].本文从这些测试程序中各选择1个子函数,各程序的信息如表1所列.程序行数节点数输入数输入范围sumday1973[0,2047]3sed_2[1].02563[0,2047]3interserve52104[0,512]4totinfo_2.0142306[0,32]6spice215649[0,128]96.2遗传策略与参数设置生成覆盖目标路径的测试数据时,不同的测试程序采用不同的种群规模及最大进化代数,如表2所列.除了本文方法对有用测试数据选取4.3节的实数变异算子以及变异概率为0.2以外,其余所有进化种群的个体均采用二进制编码,遗传操作算子均使用轮盘赌选择、单点交叉和单点变异,交叉和变异概率分别为0.7和0.2.sumdaysed_2[1].0interservetotinfo_2.0Page76.3实验设置对每一被测程序,每种方法分别运行20次,考察生成的测试数据是否来源于已有测试数据,统计它们在已有测试数据中的比例.比例越大,已有测试数据的利用率越高.此外,记录每种方法的耗时和进化代数,并计算它们的均值和标准差.为了说明本文方法的性能指标与对比方法是否有显著差别,采用右侧单边检验,μ1表示对比方法某指标的均值,μ2为本文方法相应指标的均值,置信水平为α=0.05,假设H0:μ1μ2;H1:μ1>μ2,H0的拒绝域t>t1-α(m+n-2)=1.684.若某性能指标的检验统计量t大于1.68,那么,拒绝该假设,说明本文方法的该性能指标明显优于对比方法.6.4sumday实验结果图2是sumday修改后的源程序以及节点与输入分量关系图.该程序以3个非负整数分别作为年月日输入,首先,判断年份是否为闰年;然后,对月和日的取值进行出错判断.若是非法数据,给出出错提示;否则,判断是哪个月份;最后,计算天数并输出.程序的修改点为n3,条件语句为if(day>month_day[month]||day>1||month>12||month<1),修改后,该条件语句变为if(day>month_day[month]||day<1||month>12||month<1).表3修改前sumday的目标路径及测试数据序号p1p2p3p4p5p6进行回归测试的目的,是确认修改是否引入新的错误.因此,对于修改后的sumday,需要选择能够穿越n3的路径.这里,选择pj:n1,n2,n3,n5,n6,n5,n6,n5,n7作为目标路径,该路径表示合法数据、闰年且月份为3.由式(3)可以得到已有测试数据覆盖的路径与pj的相似度,如表4所列.此外,该表还列出了各路径与pj不同的子路径以及这些子路径对应的输入分量.由表4可以得到,这6个测试数据覆盖的路径与pj的平均相似度为0.22.根据4.2节初始种群的形成方法,选择t1,t2,t3作为初始种群的部分个体.根据种群规模,其余个体随机生成.该程序有26条可行路径,已有测试数据对修改前程序的路径覆盖率为37.5%,已有测试数据集及其覆盖的目标路径如表3所列.合法数据,闰年,月份为1月合法数据,闰年,月份为12月合法数据,非闰年,月份为1月合法数据,非闰年,月份为12月测试数据已覆盖路径与pj的相似度不同子路径输入分量t1(1240,2,12)n1,n2,n3,n5,t2(2000,1,64)n1,n2,n3,n40.33n3,n5,n6,n5,t3(560,12,0)n1,n2,n3,n40.33n3,n5,n6,n5,t4(1897,13,25)n1,n3,n40t5(631,1,317)n1,n3,n40t6(2435,12,91)n1,n3,n40采用本文方法生成测试数据时,首先,需确认个体t1,t2,t3进行遗传操作的输入分量.如个体t1,利用4.2节的方法,可以得到t1覆盖路径p1与目标路Page8径pj的相同子路径为pj∩p1={n1,n2,n3,n5,n6,n5};然后,由4.3节的方法可知,不相同子路径为pj-pj∩p1={n6,n5,n7},那么,节点n5的直接相关输入分量为month,没有间接相关输入分量;节点n6,n7没有直接或间接相关的输入分量,与不相同子路径pj-pj∩p1相关的输入分量为month,如表4所列.在进化过程中,只对这些与不相同子路径有相关关系的输入分量进行变异操作,采用随机变异方法.对于个体t1,此处只有分量month需要进行变异操作,那么,生成一个[0,1)之间的随机数,当该随机数小于或等于设定的变异概率0.2时,在month的取值范围内,用随机产生的一个值替代原有值即可.不同方法生成的测试数据如表5所列.实验次数本文方法传统方法随机法有用测试数据数已有测试数据利用率(%)50170有用测试数据占有率(%)90100从表5可以看出,在20次实验中,本文方法和传统方法每次都能在最大进化代数内找到覆盖目标路径的测试数据,而随机法只有3次找到了覆盖目标路径的测试数据.使用传统方法生成的测试数据中,第1与第20次实验用到了1个已有测试数据,因此,已有测试数据利用率为17%;本文方法用到3个已有测试数据,分别为第1、8次实验用到的(2000,1,64),第2~7、11、12、14、15、17、18和20次实验用到的(1240,2,12)以及第10、13和16次实验用到的(560,12,0),因此,已有测试数据利用率为50%.这说明,本文方法能够充分利用已有测试数据集提供的测试数据.使用传统方法生成的测试数据中,只有2个来源于已有测试数据,因此,有用测试数据占有率为10%;本文方法有18个来源于已有测试数据,因此,有用测试数据占有率为90%,其中,有13个测试数据为(1240,3,12),来源于有用测试数据(1240,2,12).这说明,本文方法能够充分利用已有测试数据提供的有用信息,引导进化种群生成覆盖目标路径的测试数据.不同方法的进化代数和耗时的均值与标准差如表6所列.此外,该表还列出了不同方法进化代数和耗时均值的假设检验结果,其中,本文方法与传统方法均值假设检验的统计量为t1,本文方法与随机法均值假设检验的统计量为t2.表6不同方法的进化代数、耗时及其假设检验(sumday)均值3.3686.71958.60.0150.0780.016标准差1.7167.394.40.00040.0110.001t1t2由表6可以看出,本文方法生成测试数据需要的进化代数最少,只有3.3;传统方法和随机法分别为686.7和1958.6,远大于本文方法.这说明,本文方法生成覆盖目标路径的测试数据效率高.此外,本文方法进化代数的方差最小,只有1.7;传统方法与随机法分别为167.3和94.4.这意味着,本文方法生成覆盖目标路径的测试数据时,稳定性好.本文方法生成测试数据需要的时间远少于传统方法,也略少于随机法.这是由于,随机法生成测试数据时,既不计算个体适应值,也不进行遗传操作.由于这两个性能指标的检验统计量t1和t2的值均大于1.68,因此,本文方法在这两个性能指标上明显优于传统方法和随机法.6.5工业程序实验结果对于4个工业程序,各定义一个修改点.分别使用本文方法、传统方法以及随机法,生成覆盖修改后程序目标路径的测试数据.实验结果如表7和表8所列,其中,表7列出不同方法的已有测试数据利用率和有用测试数据占有率;表8列出不同方法的进化代数、耗时以及这些指标的假设检验统计量.由表7可知,随机法没有用到已有测试数据,因此,对于所有工业程序,已有测试数据利用率和有用测试数据占有率均为0.对于4个工业程序,本文方法的已有测试数据利用率均大于传统方法,特别是程序sed_2[1].0,本文方法的已有测试数据利用率为83%,远大于传统方法的33%.Page9sed_2[1].08333085200interserve6733080250totinfo_2.05714080150spice4422075150这说明,本文方法能够充分利用已有测试数据集提供的测试数据,并从中提取有用信息.另外,本表8不同方法的进化代数、耗时及其假设检验(工业程序)sed_2[1].0interservetotinfo_2.0spice35.0675.6437.60.003由表8可知,(1)本文方法能够以少的进化代数,生成覆盖目标路径的测试数据.对于sed_2[1].0、interserve和spice,随机法均无法在最大进化代数内生成覆盖目标路径的测试数据,因此,该方法生成测试数据的效率很低.对于sed_2[1].0、interserve、totinfo_2.0和spice,虽然传统方法能够在最大进化代数内生成满足要求的测试数据,但是需要的进化代数分别为904.9、402.0、1324.2和2144.2,分别大于本文方法的8.5、46.6、31.7和93.相应的检验统计量t1分别为5.08、5.52、8.54和11.45,均大于1.68,说明本文方法生成覆盖目标路径的测试数据需要的进化代数明显小于传统方法.(2)本文方法能够以少的耗时,生成覆盖目标路径的测试数据.对于sed_2[1].0、interserve、totinfo_2.0和spice,本文方法生成覆盖目标路径的测试数据需要的时间分别为0.018s、0.003s、0.016s和0.020s,分别小于传统方法的0.635s、0.034s、1.373s和2.826s,也分别小于随机法的0.397s、0.006s、1.367s和2.236s.通过观察这些程序运行时间对应的检验统计量t1的值(分别为5.17、文方法的有用测试数据占有率也均大于传统方法,在sed_2[1].0程序中,本文方法有17次实验生成的测试数据来源于已有测试数据,也即有用测试数据占有率为85%,而传统方法仅有4次实验生成的测试数据来源于已有测试数据,从而有用测试数据的占有率仅为20%.这说明,本文方法能够充分利用已有测试数据提供的有用信息,引导进化种群生成覆盖目标路径的测试数据.2000020000013.86、6.36和23.37,均大于1.68)可以发现,使用本文方法生成覆盖目标路径的测试数据需要的进化时间明显小于传统方法;此外,sed_2[1].0、totinfo_2.0和spice程序对应的检验统计量t2的值分别为179.66、19.87和33.14,说明对于这三个工业程序,本文方法生成覆盖目标路径的测试数据需要的时间也明显小于随机法.通过上述分析,可以得到如下结论:对于基准和工业程序,本文提出的回归测试数据进化生成方法,能够充分利用已有测试数据的有用信息,以少的进化代数和耗时,生成覆盖目标路径的测试数据.7结束语采用合适的方法生成用于回归测试的数据,是回归测试研究的重要内容.虽然已有遗传算法应用于回归测试数据的生成,但是已有研究缺乏对已有测试数据的充分利用,因此生成测试数据的效率有待进一步提高.本文研究采用遗传算法生成回归测试数据以覆盖目标路径时,已有测试数据的利用问题,提出一种Page10新的回归测试数据进化生成方法.该方法根据已有测试数据穿越的路径与目标路径的相似度,选择合适的测试数据,作为初始进化种群的部分个体.根据已有测试数据穿越的路径与目标路径不相同子路径的节点对应的输入分量,确定对进化个体实施遗传操作的位置.理论分析表明,本文方法充分利用已有测试数据的有用信息,以减少个体需要改变的分量个数,可以提高生成覆盖目标路径测试数据的概率.将所提方法应用于基准和工业程序的测试,并与传统回归测试数据生成方法和随机法比较,实验结果表明,本文方法能够充分利用已有测试数据的有用信息,以少的进化代数和耗时,生成覆盖目标路径的测试数据.本文方法选择有用测试数据时,仅考虑覆盖的路径与目标路径相似度大于均值的测试数据.事实上,也可以设置其他的标准,以选择已有的测试数据.比较不同选择标准对生成测试数据的影响,是需要进一步研究的问题.此外,本文仅考虑回归测试中单目标路径覆盖的测试数据生成问题.实际软件的复杂性,使得需要覆盖的目标路径通常很多.如何基于已有测试数据,同时生成覆盖多路径的测试数据,以提高测试数据生成效率,也是需要进一步研究的问题.
