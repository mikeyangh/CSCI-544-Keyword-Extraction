Page1基于关联数据的一致性和时效性清洗方法杜岳峰申德荣聂铁铮寇月于戈(东北大学计算机科学与工程学院沈阳110819)摘要数据一致性和数据时效性是大数据质量管理所关注的两个重要内容.条件函数依赖(CFDs)和时效约束(CCs)分别是用于分析数据一致性和数据时效性的有效技术手段.现实生活中的数据会夹杂一些关于一致性和时效性的潜在错误,这些错误又无法为CFDs和CCs检测和修复,最终影响数据的整体质量.值得一提的是,这些数据通常是相互关联的,这种关联关系可以用来发现数据中的潜在错误.文中使用了一种条件合并的函数依赖(CCFDs)将关联数据放在一起进行处理.基于此,该文提出了一种基于关联数据的一致性和时效性清洗方法.在数据清洗过程中,数据的检测和修复是两个相互影响的过程.所以,该文设计了一种新的自动清洗框架,迭代地进行数据检测和数据修复.其次,该文对关联数据的一致性和时效性清洗的相关问题进行了分析,并且证明了关于CCFDs和CCs的最小代价修复问题是一个Σp行修复.为了提高修复的准确性,该文还提出了一种修复序列图的概念.最后,通过在两组真实数据上进行实验,验证了方法的实用性和高效性.关键词数据一致性;数据时效性;大数据质量;关联数据;数据清洗1引言数据一致性和数据时效性是大数据质量管理的重要事务[1].由数据一致性和数据时效性引发的数据质量问题每年都会给社会造成巨大的经济损失.2006年,仅信誉卡信息管理一项事务中,由于冲突数据(不一致数据)造成的损失就高达48亿美元[2].在美国,时效错误数据占企业数据总数的0.6%~18.5%[2].冲突数据和时效错误数据相叠加而产生的错误数据将更为严重,根据德国数据分析机构的调查显示:“美国每年因为劣质数据而造成的损失高达6000亿美元”[3].所以,从数据一致性和时效性着手修复错误数据,提升数据质量,是一个非常重要的问题.在处理冲突数据和时效错误数据时,条件函数依赖CFDs[4](ConditionalFunctionalDependencies)以及时效约束CCs[5](CurrencyConstraints)都是进行数据管理的有效技术.其中,条件函数依赖可以检测某些特定条件下的冲突数据;时效约束可以对时效错误数据进行检测.进而,可以将条件函数依赖和时效约束混合使用,解决冲突数据和时效错误数据的叠加问题.但是,数据中可能会夹杂一些关于一致性和时效性的潜在错误,这些错误无法为条件函数依赖和时效约束所检测并加以处理,进而对数据分析造成影响,导致决策失误.如何解决数据中存在的潜在错误,就成为一个亟需解决的问题.现实生活中的事物都是相互关联的.对大数据而言,其数据的关联关系更加复杂.并且,这些关联关系有助于解决数据中的潜在错误.因此,本文的重点就是利用关联数据检测并修复数据中一致性和时序性问题.例1中举例说明了数据中潜在一致性和时效性问题.例1.Joe和Ada是一对夫妇.图1给出了关于实体Joe(e1)和Ada(e2)的个人信息关系实例,其关系模式R包含姓名(NM)、年份(Year)、婚姻状态(Sta)、性别(Gen)和家庭关系(Rel)这5个属性.在实体e1的关系实例中,高亮部分数据表示与实际情况相冲突的错误数据,括号内为相应的真实值.现实生活中,实体信息通常来自不同的数据源,并且数据源的置信度存在差异.所以,数据的修复代价也不尽相同.本文使用文献[6]中提出的方法计算源数据的置信度作为实体的修复代价权重.实体e1的数据修复代价权重wt为1和1.1,实体e2的数据修复代价权重wt为3.CFDs:1:NM,Year→Sta(tp{tp0(“Joe”,_‖_),tp1(“Ada”,_‖_)})2:Sta,Gen→Rel(tp{tp0(“married”,_‖_),tp1(“single”,_‖_)})CCs:φ1:t1,t2(t1Yeart2→t1Stat2)φ2:t1,t2(t1[Sta]=“single”∧t2[Sta]=“married”→t1Stat2)1和2是R上的条件函数依赖CFDs,tp为条件模板,φ1和φ2是R上的时效约束CCs.1表示,对于Joe和Ada,他们的年份可以唯一决定他们的婚姻状态.2表示,对于一个未婚或已婚的人而言,他的性别可以唯一决定他的家庭关系.φ1表示,一个人的婚姻状态会随时间的推移而保持或者发展,但是Page3不会出现倒退的情况.因而,一条记录的Year值越新,其所对应的Sta值或者保持不变,或者比其他记录的Sta值新.φ2表示,如果一条记录的Sta值为“single”,那么它比其他Sta值为“married”的记录要陈旧.在现实生活中,一个人的婚姻状态只能由“single”发展成“married”,或者保持“single”的状态,而不可能出现由“married”倒退回“single”的情况.1,2,φ1和φ2将作为用于检测实体e1,e2的一致性和时效性的约束规则.在进行一致性检测时,条件函数依赖模板中的每一项tpi将会被当成一条独立的规则,被分别用于数据的一致性检测.其中,2的tp0可以检测出e1中存在的数据冲突:记录t1,t2,t3,t5的Sta属性值均为“single”,并且它们的Gen属性值为“male”.然而,t1,t2,t5的Rel属性值“unmarried”与t3的Rel属性值“husband”却是相互冲突的.为了修复冲突数据,樊文飞等人[7]提出了一种代价最优的方法.该方法将t3的Rel属性值由“husband”修改为“unmarried”(因为修改t3需要改变1条记录,而修改t1,t2,t5需要改变3条记录).修改完后,关系中的所有数据都满足约束规则的要求,结束整个数据修复的过程.但是,一些错误数据却没有被检测出来,比如t2,t3,t5中的Sta属性值“single”(对于Joe和Ada夫妇,他们1972年的婚姻状态应该保持一致,同为“married”),这些数据将被遗漏并成为潜在错误.现实生活上,数据之间是相互关联的,并且应该将关联数据放在一起进行检测,而不是分开地、独立地进行.对于Joe和Ada夫妇,他们之间的数据是相互关联的,可以将e1和e2放在一起进行检测.同时,eCFDs[8]和CCFDs[9](ConditionCombinedFunc-tionalDependencies)验证了CFDs的可合并性.本文使用CCFDs对规则进行合并,得到的CCFDs如下所示:ψ1表示当把Joe和Ada的数据放在一起时,数据应该整体满足年份唯一决定婚姻状态的规则要求.使用ψ1,2,φ1和φ2对实体e1,e2进行检测时,ψ1将t1~t7放在一起检测,进而可以检测到t2,t5与t6之间发生的冲突,并将t2,t5的Sta属性由“single”修改为“married”.然后,φ1和φ2可以检测出t3与t2,t5之间发生的时序错误,将t3的Sta属性由“single”修改为“married”.接下来,2可以检测出t2,t3,t4,t5之间发生的冲突,将t2,t5的Rel属性由“unmarried”修改为“husband”.到此,数据中的所有错误均已被修复.因此,将关联数据放在一起更有利于检测和修复数据中的潜在错误.另外,人工处理潜在数据的代价过大,而且人工处理在分析潜在错误的过程中也极易发生错误.基于此,本文提出了一种自动清洗关联数据中一致性和时序性错误的方法.尽管,文献[5,10-11]提出了一些关于数据一致性问题和时序性问题的解决方法.但是,目前仍然缺少解决关于关联数据的一致性和时序性问题的相关方法.本文在研究关联数据的修复问题时,遇到了以下难题:(1)如何计算关联数据的修复代价?由于数据修复过程使用了关联数据,因此需要考虑关联数据对修复代价的影响.(2)如何计划合理的数据修复顺序?不同的修复顺序会产生不同的修复结果,其中的一些修复顺序可能导致错误的修复结果.对于之前给出的使用ψ1,2和φ1的修复方法,如果按照2→ψ1→φ1→2的顺序进行检测和修复,就会将t3和t4的Rel属性值改为“unmarried”而出现错误.所以,需要选择正确的修复顺序来克服错误的修复.(3)如何选取合适的修复目标值?从对上面修复顺序问题的描述中,可以看出某一次数据修改可能会对下一次的数据检测和修改造成影响.一方面,对于同一个错误,可能存在多个供选取的目标值;另一方面,某些目标值可能只是修复过程中的一个临时值,需要反复修改几次才能得到最终的修复状态.不论是多个目标值的选取还是临时状态值的选取,都需要选择一个合适的目标值,最终得到正确的修复结果.本文利用CCFDs和CCs,考虑数据之间的关联关系,提出了一种解决数据一致性和时效性混合问题的数据清洗方法,具体贡献如下:(1)提出了一种CCFDs和CCs的混合清洗方法,可以解决数据一致性和时效性的混合问题,并且分析了CCFDs和CCs混合规则的可满足性问题和蕴含问题.(2)设计了一种数据修复框架.考虑到数据检测和数据修复的相互作用,本框架迭代地进行执行这两个过程,直到得到一个一致的、时序正确的清洗结果.(3)提出了一种“修复序列图”的结构.在数据Page4修复的过程中,错误的修复顺序可能导致错误的修复结果.修复序列图可以计算出应该优先修复的数据错误,从而避免错误修复.(4)证明了关于CCFDs和CCs的最小代价一致性和时效性清洗问题是一个Σp题,进而提出了一种启发式的修复方法.(5)通过在HOSP数据集和NBA数据集上进行实验,说明了本方法的实用性和高效性.本文第2节介绍相关工作;第3节给出关于关联数据一致性和时效性清洗的相关概念;第4节提出一种一致性和时效性的清洗框架并介绍相应的检测方法和修复方法;第5节分析讨论实验结果;第6节总结全文工作并对未来工作进行概述.2相关工作数据质量的研究是一个传统问题,现存大量相关文献,但是在该领域中仍然存在一些问题需要探询.本文研究的问题亦在此领域范畴之内,主要研究的内容是:利用规则约束,解决关联数据中一致性和时效性问题.目前的研究中,与本文研究密切相关的相关工作主要类别于以下3个方面:(1)约束规则.约束规则是数据质量管理的一个重要技术,可以简单、快速地实现数据的检测与修复.约束规则有很多种类,如函数依赖FDs[1](FunctionalDependencies)、条件函数依赖CFDs[4]、否定约束DCs[12](DenialConstraints)、时效约束CCs[5]等.通过实践证明这些规则是非常有效的.在CFDs的基础上,eCFDs[8](extendedConditionalFunctionalDependencies)和CCFDs[9]分析了规则合并的可行性.本文使用CCFDs来检测关联数据的一致性.对于不同类型的规则,他们既可以独立运行,解决一类数据质量问题,也可以混合使用,同时解决多类数据质量的混合问题.文献[13]通过将匹配规则MDs(MatchingDependencies)与CFDs相结合,利用主关系中的记录指导从属关系中出现的错误修复.文献[14]分析讨论了CFDs和CINDs(Condi-tionalInclusionDependencies)之间的相互作用关系,进而混合使用CFDs和CINDs对多数据源中的数据冲突进行检测.文献[5]通过将CFDs和CCs结合使用,进而得到关于实体的一致的、最新的记录信息.与以往的研究有所区别的是,本文关心的是关联数据中的一致性和时效性问题,所以本文使用的是CCFDs和CCs.(2)数据一致性分析.数据一致性是数据质量管理研究的重要事务之一.解决数据一致性问题可以通过实体识别[15]等方法来实现.其中,使用规则约束来验证数据一致性并对其修复是最有效的一致性管理方法之一.文献[16-17]提出了一致性规则的发现方法.文献[18]研究了如何使用CFDs进行一致性检测和修复的相关问题.(3)数据时效性分析.时序错误的检测和错误数据的修复是时效性分析的两个关键问题.使用规则约束进行数据时效性分析是目前最有效的方法之一.文献[5]提出一种,在没有时间戳的条件下,使用时效约束查询数据时效的方法,以此来判定实体的最新状态信息.文献[19]提出了一种时效图的结构对数据的实效性进行判定.文献[20]通过结合使用规则和统计的方法对数据进行修复.此外,对于数据清洗而言,文献[11]提出了的多种修复过程和修复方法,对修复过程的相关问题进行了研究.本文具体研究了在CCFDs和CCs混合规则作用下,关于关联数据的一致性和时效性检测和修复问题.3相关概念本节针对关联数据的一致性和时效性清洗问题,首先对条件合并的函数依赖和时效约束进行介绍,然后提出了用于数据清洗的相关概念.本文使用关系数据的形式对实体进行描述,假定相同实体的数据已经经过识别并集中在一起.关系模式R=(犲id,狋id,A1,…,An),其中,犲id为实体编号,具有相同实体编号的记录都指向同一实体;狋id表示记录编号;A1,…,An表示R上的属性,dom(A)表示属性A的值域;R上的所有属性集合记作attr(R),N表示集合中的属性个数.3.1约束规则(1)条件合并的函数依赖CCFDs(Condition-CombinedFunctionalDependencies)[9].CCFDs是一种可以同时对多个条件值进行一致性检测的完整性约束.关系模式R上的一条CCFD记作其中:C为条件属性集合;Y为变量属性集合,C和Y由“|”分隔,并且C,Yattr(R),C∩Y=,C,Y合称为规则左部,记作LHS(ψ),单属性A称为规则右部,记作RHS(ψ);Y→A是一个标准函数依Page5赖;Sci是关于C的属性值集合,Scidom(C),Sc是Sci的集合,即Sc=∪Sci.并且对于任意元组ti,tj,如果ti[C],tj[C]∈Sci,ti和tj需要放在一起进行检测.ψ1是CCFDs的一个具体实例.特别地,2也可以表示成:Sc1{“single”}}.ψ2:(Sta|Gen→Rel,Sc)Sc{Sc0{“married”},I是R上的一个实例,ti,tj是I中的任意两个元组.一条条件合并的函数依赖ψ关于I是成立的,当且仅当,在ti[C],tj[C]∈Sci的条件下,如果ti[Y]=tj[Y],则有ti[A]=tj[A],并且记作Iψ.否则,记作I/ψ.Σψ是条件合并的函数依赖的规则集合,对于ψ∈Σψ,都有Iψ,则称Σψ关于I成立,记作IΣψ.对于CFDs,每一个tpi∈tp都是一条独立的规则:(X→A,tpi),那么也可以表示成:(C|Y→A,tpi).对于满足相同形式C|Y→A的CFDs,尽管tpi不同,它们的Y→A中包含的信息可能存在重叠的部分.相应地在现实生活中,隶属不同条件的事物,可能是相互关联的,从而共同遵从相同的规则.需要说明的是:①规则发现不是本文的主要工作,因而本文使用文献[9]提出方法,将规则合并在一起.然后由数据专家从中选取重叠部分较高的CCFDs,用于关联数据的一致性分析;②并不是所有的CFDs都能进行合并,有些CFDs可能存在冲突(比如,,,是3条CFDs规则,它们可能存在这样的情况:可以分别与和进行合并,但是不能与进行合并).本文采用不相交Sci的CCFDψ,即对于Sci,Scj∈Sc,有Sci∩Scj=.所以,同一CFD规则将不会被重复合并.(2)时序关系(CurrencyOrder).I是关系模式R上的实例,I中的关联数据ti和tj满足关于属性A的时序关系当且仅当下述条件同时成立:①ti[犲id]=tj[犲id];②tiAtj.其中,ti[犲id]=tj[犲id]表示ti和tj是关于同一实体犲id的不同记录.tiAtj表示ti关于属性A的时效性要高于tj,即ti[A]相比tj[A],更能表示犲id的最新情况.如例1中所给出的关于Joe的信息,t1,t2分别是Joe在1971年和1972年的Sta状态,那么t2[Sta]要更新一些,即t1Stat2.时序关系描述了关联数据之间的时间先后顺序,通常使用时序约束来具体描述数据之间的时序关系.时效约束CCs(CurrencyConstraints)[5].CCs是一种可以用来判定数据时效信息的规则约束.ti,tj是关系实例I中的任意两个元组,关系模式R上的一条CC记作其中,ω是约束的前件,使用断言的合取来进行表示,记作LHS(φ).断言包含以下3种具体形式:①偏序tiAltj,在ti和tj关于属性Al的顺序关系不相等的情况下,tiAltj也可以表示成tiAltj;②二元谓词ti[Al]opti[Al],op可以是=、≠、<、>、或中的其中一种;③常数谓词ti[Al]opc或者tj[Al]opc,c是一个常数.tiAltj是规则右部,记作RHS(φ).接下来,基于时效约束CCs,本文提出时序关系断言和时序关系表达式的概念,用来判断实例中元组是否存在时序性上的错误.定义1.时序关系断言(CurrencyAssertion).对于给定的元组ti,tj,它们关于时效约束φ的时序关系断言qφ定义为时序关系断言描述了经过φ推演后,元组ti,tj关于属性Ar的时序关系.定义2.时序关系表达式(CurrencyExpres-sion).Σφ是时效约束的规则集合,元组ti和tj关于Σφ的时序关系表达式Q定义为元组ti和tj是时序正确的,当且仅当,他们的时序表达式Q的值为真(True),即ti和tj的任意两个时序关系断言都不互为矛盾式.换言之,ti和tj经过Σφ推理得到的所有时序关系断言中,不会同时出现类似tiArtj和tiArtj的情况.实例I满足时效约束集合Σφ是成立的,当且仅当,对于ti,tj∈I,它们的时序表达式Q的值都为真,并且记作IΣφ.否则,记作I/Σφ.例2.例1中给出的实体e1的记录和时效规则集合CCsΣφ={φ1,φ2}为例,由t1[Year]=“1971”t2[Year]=“1972”可得t1,t2关于φ1的时序关系断言qφ1:t1Stat2.由t1[Sta]=“single”和t2[Sta]=“married”可得t1,t2关于φ2的时序关系断言qφ2:t1Stat2.那么,t1,t2关于φ1和φ2的时序关系表达式为Q=qφ1∧qφ2=t1Stat2∧t1Stat2=True.说明t1和t2之间没有发生时序性错误.对于e1中的所有记录t1~t5,其中所有的时序表达式Q都为真,那么e1中的元组都满足时序约束Σφ的要求,即e1Σφ.Page6用于数据清洗的混合规则集合记作Σ=Σψ∪Σφ,它是由CCFDs和CCs组成的混合规则集合.如果IΣψ并且IΣφ同时成立,那么称实例I满足混合规则集合Σ,记作IΣ.3.2修复代价修复代价是数据质量清洗过程中的一项基本衡量标准.设Σ=Σψ∪Σφ是由CCFDs和CCs组成的混合规则集合,t是实例I中存在错误的元组,对于任意规则η∈Σ,t是t关于η的修复目标元组,并且t与t只在RHS(η)属性上存在差别,4.3.3节将讨论如何选取修复目标元组.接下来,本文给出在η作用下,将t改为t的修复代价的计算方法.对于选取的不同类型的规则η,修复代价计算方法也有所不同.如果η是一条CCFD规则(C|Y→A,Sc),在修复的过程中,需要考虑关联数据对数据修复产生的影响.对于一个条件合并集合Sci∈Sc,同一Sci支配下的元组都是相互关联的.定义3.关联数据集(RelatedDateSet).在实例I中,元组t关于|I|2的关联数据集定义IC(t,η)为其中:Sci是η中包含t的条件合并集合;σf是关系数据库中的选择操作,f是进行选择的条件.IC(t,η)选取Sci中所有与t享有相同Y属性值和A属性值的元组作为t的关联数据.在进行数据修复的过程中,如果关联数据集的一个元组发生变化,集合中的其他元组也要随之变化.关联数据的选取同样会对修复代价权重造成影响.定义4.在关联数据集IC(t,η)中,元组t的关联数据的修复代价权重wt(t,η)定义为wt(t,η)=wt(t)+1其中,wt(ti)表示元组ti在实例I中的初始的修复代价权重.由于考虑了关联数据的影响,初始的修复代价权重得到了进一步加强.式(6)使用关联数据修复权重的平均值来描述元组t受关联数据的影响而导致的初始权重的变化情况.如果与t相关的元组ti的修复权重都比较高,那么t的修复代价权重的变化就比较大.例3.以t1,t2和CCFDψ1为例,其中的Sc0是包含t1,t2的条件合并集合,t1关于ψ1的关联数据集IC(t1,ψ1)={t1,t6},其关联数据的修复代价权重wt(t1,ψ1)=1+0.5×(1+3)=3;t2关于ψ1的关联数据集IC(t2,ψ1)={t2,t5},其关联数据的修复代价权重wt(t2,ψ1)=2.05.在考虑关联数据的影响的情况下,t1和t2的修复代价权重都得到了相应的增强.并且,关联数据的修复代价权重越大,t1和t2的权重变化也越大.如果η是一条CC规则,在修复代价的计算过程中,修复代价权重不会受其他元组的影响,可以直接计算求解.定义5.鉴于CCFDs和CCs对修复代价的影响不同,在η的作用下,元组t改为t的修复代价定义为cost(t,t,η)={wt(t,η)·Isrepair(t,t),如果η是CCFDwt(t)·Isrepair(t,t),其中,Isrepair(t,t)是一个判别函数:如果目标值t与初始值t不相同,那么将元组t改为t,并计算其修复代价.并且,修复代价权重越高,修复的代价也越大.例4.基于例3得到的关联修复代价权重,假设t2是修复的目标值,并且t2[Sta]=“married”,那么把t2修改为t2,对于单个元组进行修复的代价为cost(t2,t2,ψ1)=2.05.在考虑到关联数据的情况下虽然增加了修复代价,但是使用关联数据为修改提供参考可以提高修复的准确性.定义6.I是实例I关于规则集合Σ的修复目标实例,对于t∈I,η∈Σ,I存储了所有与之相对应的修复目标元组t.那么实例I关于规则集合Σ的修复代价定义为cost(I,I,Σ)=∑t∈I∑η∈Σ其中,f(t,η,I)是一个查询函数,利用索引从I中返回元组t关于规则η的修复目标元组.3.3问题定义后,本文需要解决的问题描述如下:在给出约束规则和修复代价的基本定义描述之最小代价修复.给定一个关系模式R上的多实体实例I以及条件合并的函数依赖Σψ和时效约束Σφ的混合规则集合Σ=Σψ∪Σφ,找到一个修复目标实例I,使得IΣ并且cost(I,I,Σ)最小,即不存在IΣ并且cost(I,I,Σ)<cost(I,I,Σ).进而,最小代价修复的判定问题表述为:对于给定的实例I、规则集合Σ及一个正整数k,是否存在一个修复Page7目标实例I,使得IΣ并且cost(I,I,Σ)k.定理1.最小代价修复的判定问题是一个Σp完全(NPNP)问题.证明.文献[5]通过“DNF”问题规约证明了在CFDs和CCs混合使用的情况下,进行最小代价修复的判定问题是一个ΣpDNF”即τ=XYδ,其中X和Y的真值集合为X={x1,…,xn}和Y={y1,…,ym},δ=C1∨…∨Cr,对于任意j∈[1,r],Cj=lj个变量或者X∪Y的补集中的一个元素,在此情况下,对τ进行真值判定就是“DNF”问题.对于一个由s条CFDs合并得到的CCFDψ,其修复问题可以在O(s)内转化成为CFDs的修复问题.同理对于CCFDs集合Σψ,其修复问题可以在O(|Σ|)内转化成为CFDs的修复问题,其中|Σ|表示Σψ中包含的CFDs规则数量.并且,CFDs规则的合并与CFDs-CCs的混合使用是相互独立的.规则合并不会对规则的混合造成影响.进而,CCFDs-CCs的规则混合可以通过CFDs-CCs的混合来实现.所以,使用CCFDs和CCs混合规则的修复问题可以在O(|Σ|)等价地转化成为CFDs和CCs混合规则的修复问题.那么,在CCFDs和CCs混合使用的条件下的最小代价修复的判定问题也是一个Σp4一致性和时效性混合清洗对于给定数据实例I和用于清洗的约束规则Σ,为了修复I中存在的一致性和时效性的问题,本文提出了一种一致性和时效性混合清洗框架,并讨论了清洗过程中的相关问题.4.1清洗框架定义.定义7.给定数据实例I及混合规则集合Σ,η∈Σ,η是一条异常规则当且仅当η至少满足以下其中一个条件:在描述清洗框架之前,首先给出异常规则的(1)η是一条CCFDψ并且I/ψ.(2)η是一条CCφ:ti,tj(ω→tiArtj),如果u,v∈I,φ∈Σ,使得u和v关于φ和φ的时序关系表达式Q=qφ∧qφ=False.异常规则表示的是在检测过程中发现数据错误的规则.接下来,给出一致性和时效性混合清洗框架的基本结构.如图2所示,框架中包含数据检测组件和数据修复组件两个部分.其中,数据检测组件利用CCFDs和CCs的混合规则进行检测,返回发现检测错误的异常规则.数据修复组件通过:(1)修复序列判别;(2)错误元组定位;(3)错误元组修复这3个过程对错误数据进行修复.然后,框架对修复的结果再次进行检测和修复,迭代此过程,直到数据的错误全部被修复并返回清洗后的实例I.算法1描述了清洗框架的执行过程.算法1.数据清洗方法cc-Cleaning(I,Σ).输入:I,Σ输出:I1.I=I;2.WHILETRUEDO3.Σ=cc-Detect(I,Σ);4.IFΣ≠THEN5.Σp=vr-Find(Σ),6.Γs=e-Locate(I,Σp),7.I=e-Repair(I,Γs),8.I=I;9.ENDIF10.ELSE11.RETURNI;12.ENDELSE13.ENDWHILE其中,cc-detect(I,Σ)是数据检测组件对应的方法.数据修复组件cc-repair(I,Σ)包含修复序列判别方法vr-Find(Σ)、错误元组定位方法e-Locate(I,Σp)和错误元组修复方法e-Repair(I,Γs).方法的细节将在4.2节和4.3节中进行介绍.讨论.本文将从以下4点对数据清洗框架进行讨论:(1)数据检测的返回值.不同于以往的检测过程[11,18],框架中的数据检测组件返回的是发现检测错误的异常规则,而不是实际发生错误的元组.因Page8为,在后续的修复过程中,需要判定哪些是需要优先修复的数据错误,哪些是不需要优先修复的数据.例1中,与φ1,φ2有关的数据错误应该在ψ1的错误数据解决之后进行.对于那些不需要优先修复的数据,实际元组的计算会造成一种资源的浪费.因此,使用异常规则可以减少这些不必要的计算代价.(2)检测和修复过程的迭代.一方面,数据中的潜在错误只能在经过一次修复之后才能被发现.如例1中,t3的潜在错误只有在φ1,φ2修复完后再次检测才能会发现.所以,需要使用迭代的方法解决数据中的潜在错误.另一方面,修复过程中可能会产生新的错误,这就需要重新进行一次检测来验证是否产生了新的错误.文献[1]中提出了一种迭代清洗的修复方法,针对检测得到的错误需要人为参与进行修复,并且由人为判定迭代的终止条件.区别于文献[1]的清洗过程,本框架使用一种自动迭代的数据清洗方法,在数据修复和程序终止的问题上可以避免某些人为因素产生的修复错误.(3)混合规则的可满足性和蕴含性.这两个问题是规则约束的两个基本问题.CCFDs和CCs的混合规则可满足性问题可以描述为:给定一个混合规则集合Σ=Σψ∪Σφ,是否存在一个完整实例I,使得IΣ.对于一个关系模式R,dom(A)表示属性A的有限阈值范围,那么R上的完整值域空间可以由所有属性的dom(A)的组合得到.完整实例是指包含一个完整值域空间的实例.规则的可满足性问题研究的是规则之间是否存在冲突的问题.例如,η,η是Σ中的两条规则,但是无论如何也找不到一个完整实例I,使I同时满足η和η.这说明η和η本身是冲突的,那么Σ不满足规则可满足性的要求.CCFDs和CCs的混合规则蕴含性问题可以描述为:给定一个混合规则集合Σ和一条规则η,对于所有实例I,如果同时有IΣ和Iη,那么称Σ蕴含η,记作Ση.并且,不包含蕴含关系的规则集合被成为最小规则集合.规则蕴含研究的是规则之间的推导关系:一条规则是否可以由其它规则的组合来推导得到.规则的蕴含性可以用来判别规则集合中是否包含冗余的规则.文献[5]通过“3-SAT”问题规约证明了CFDs和CCs混合规则的可满足性问题和蕴含问题分别是一个NP完全问题和一个co-NP完全问题.CCFDs是一类特殊的CFDs,并且CCFDs的相关问题可以在O(|Σ|)时间内转化成为CFDs的相关问题.所以,CCFDs和CCs混合规则的可满足性问题和蕴含问题同样是NP完全问题和co-NP完全问题.本文将使用同时满足可满足性的最小混合规则集合进行清洗.(4)程序的终止性.由于在修复过程中使用的是可满足的最小规则集合,所以框架在迭代修复后最终会达到终止的状态,并且终止的条件是数据中不再检测到新的错误.4.2数据检测对于给定的数据实例I和混合规则集合Σ=Σψ∪Σφ,针对框架中的数据检测组件,本文提出了一种数据检测方法cc-Detect(I,Σ),用以返回Σ的异常规则集合Σ.算法2描述了数据检测的执行过程.第3行中,I/η用来判断η是否是一条异常规则.首先区别规则η是一条CCFD还是一条CC,然后判断η是否满足I.算法2.数据检测方法cc-Detect(I,Σ).输入:I,Σ输出:Σ1.Σ=;2.FOReachηinΣDO3.IFI/ηTHEN4.Σ=Σ∪η;5.ENDIF6.ENDFOR7.RETURNΣ;复杂度分析.如果η是一条CCFD,I/η的检测过程可以在Θ(|I|2)完成,如果η是一条CC,I/η的检测过程可以在Θ(|Σφ|×|I|2)完成.其中,CCFDs和CCs规则数量的上界均为|Σ|.那么,算法2的计算复杂度为O(|Σ|2×|I|2).4.3数据修复数据修复组件针对数据检测组件返回的异常规则集合,通过修复序列判别,错误数据定位以及目标值选取3个过程来实现数据修复.4.3.1修复序列判别为了计算出异常规则集合Σ中需要优先修复的规则Σp,本文提出了规则序列图的定义.定义8.对于给定的规则集合Σ,其规则序列图定义为Gs(V,E),其中V=Σ.对于任意η1,η2∈Σ,如果RHS(η1)LHS(η2),则在η1,η2之间存在一条由η1指向η2的边,记作eij,则E={eij|i,j∈[1,|Σ|]}.例5.针对例1中出现的问题,使用Σ={ψ1,ψ2,φ1,φ2}作为数据清洗的混合规则集合.第1次迭Page9代的过程中,Σ={ψ1,ψ2}是得到的异常规则集合.Σ和Σ的规则序列图如图3所示.从图3右半部中可以看出,对ψ2的修复过程会受到ψ1的影响.所以,数据修复的过程需要找到需要优先修复的异常规则.值得一提的是,规则序列图中入度为0的规则不会受到其他规则的影响.所以,修复过程只需要选取这些入度为0的规则作为优先修复的规则即可.对于序列图非空,又不包含入度为0的规则的情况,即序列图中只存在回路.回路情况下求解最小修复代价时,就需要考虑回路中所有修复情况,这些修复会对后续的修复产生影响,进而通过这种动态规划的方法得到所有的修复策略并计算其修复代价.定理1中证明了最小代价修复是一个2完全问题.所以,本文采用了一种启发式方法,计Σp算回路中每一条规则所覆盖的错误元组修复代价权重总和,并选取总和最小的规则.算法3描述了修复顺序的判别方法的执行过程.算法3.修复序列判别方法vr-Find(Σ).输入:Σ输出:Σp1.Σp=,Gs(V,E)=G-gen(Σ);2.FOReachηinVDO3.IFdegree(η)==0THEN4.Σp=Σp∪η;5.ENDIF6.ENDFOR7.IFΣp=THEN8.Σp=Σp∪minwt(V);9.ENDIF10.RETURNΣp;第1行中,G-gen(Σ)按照定义的方法生成Σ的规则序列图.第2~6行计算Gs中入度为0的规则.第8行中,minwt(V)将从V中选取修复代价权重总和最小的规则.复杂度分析.规则序列图的生成过程可以在Θ(|Σ|2)完成.计算入度为0的规则可以在Θ(|Σ|)完成.随机挑选异常规则的过程可以在Θ(1)完成.并且|Σ|的上界为|Σ|.那么,算法3的计算复杂度为O(|Σ|2).4.3.2错误元组定位确定需要优先修复的规则以后,需要找到与规则相对应的具体的错误元组.错误元组不是单一存在的,他们都是与其它互相冲突而出现的,所以这些发生冲突的元组应该放在一起进行修复.进而,本文提出错误元组集合的定义.定义9.假设t是实例I存在错误的元组,η是关于t的异常规则,那么元组t关于η的错误元组集合S(t,η)定义为其中,(t,s)/η表示t,s关于η是相互冲突的.S(t,η)中存储了所有与t相冲突的元组s以及那些与t类似的元组.这些与t类似的元组虽然不与t发生冲突,但是它们与s发生冲突,所以它们都属于相同类别的错误,应该放在一起.另外,这些元组的错误元组集合是相同的,所以在实际使用的时候,会将它们合并在一起,只保留一个即可.最后,将所有的错误数据集合存储在集合Γs中.例6.回顾例1中的实例,t1与t3是关于ψ2相互冲突的.那么t1关于ψ2的错误数据集合S(t1,ψ2)={t1,t2,t3,t5}.虽然t2,t5与t1不发生冲突,但是t2,t5与t3却是冲突的,所以将它们放在一起.并且对于t1,t2,t3,t5,只保留S(t1,ψ2)即可.算法4描述了错误元组定位的执行过程.算法4.错误元组定位方法e-Locate(I,Σp).输入:I,Σp输出:Γs1.Γs=;2.FOReachηinΣpDO3.It=I;4.FOReachtiinItDO5.S(ti,η)=;6.FOReachtjinItDO7.IF(ti,tj)/ηTHEN8.S(ti,η)=S(ti,η)∪tj,It=It/ti;9.ENDIF10.ENDFOR11.IFS(ti,η)≠THEN12.FOReachtkinItDO13.IFti~tkTHEN14.S(ti,η)=S(ti,η)∪tk,It=It/tk;15.ENDIF16.ENDFOR17.Γs=Γs∪S(ti,η);Page1018.ENDIF19.ENDFOR20.ENDFOR21.RETURNΓs;第3行,It是一个临时实例,用来控制合并相同的错误元组集合.第6~9行用于找到所有与ti发生冲突的元组.第13行中,ti~tk用来判断ti与tk是否相似.第12~16行使用ti~tk找到所有与ti类似的元组.复杂度分析.(ti,tj)/η与ti~tk都可以在Θ(1)完成.发现冲突元组和发现类似元组的过程都可以在Θ(|I|2)完成.所以,算法4的计算复杂度为O(|Σp|×|I|2).4.3.3目标值选取对于数据修复过程而言,修复目标值的选取是一个关键问题.给定错误元组,选定不同的修复目标值,修复的结果不尽相同,与之对应的修复代价也有所不同.问题定义部分证明了最小代价修复问题是2完全(NPNP)问题.所以,本文设计了一种启一个Σp发式方法来选取修复目标值并对错误元组进行修复.算法5描述了目标值选取和错误修复的执行过程.算法5.错误元组修复方法e-Repair(I,Γs).输入:I,Γs输出:I1.I=I;2.FOReachS(t,η)inΓsDO3.tvalue=NULL,count=;4.FOReachviindom(RHS(η))DO5.cost=0;6.FOReachtiinS(t,η)DO7.ti=t-gen(ti,vi,RHS(η)),8.ENDFOR9.IFcost<countTHEN10.tvalue=vi,count=cost;11.ENDIF12.ENDFOR13.FOReachtiinS(t,η)DO14.I=repair(ti,tvalue,I);15.ENDFOR16.ENDFOR17.RETURNI;第3行,tvalue和count分别用来存储最小代价修复的目标值及其代价.第7行,t-gen(ti,vi,RHS(η))方法将ti的RHS(η)属性值改为vi,以此生成ti的目标元组.第4~12行计算关于S(t,η)的最小代价的修复目标值tvalue.第13~15行使用repair(ti,tvalue,I)将S(t,η)中的错误元组ti修改为tvalue.复杂度分析.对于如何选取最小修复代价的目标值,其计算代价为Θ(|Γs|×|S(t,η)|×|πRHS(η)(I)|),其中|Γs|×|S(t,η)|表示所有错误数据的数量,其上限为|I|×|N|.|πRHS(η)(I)|表示I关于属性RHS(η)的不同值的个数,其上限为|I|.对于所有错误数据的修复过程可以在Θ(|Γs|×|S(t,η)|)完成.另外,在目标值选取的过程中,cost(ti,ti,η)的计算代价为O(|I|).那么,算法5的计算复杂度为O(|I|3×|N|).但是,实际的错误量和不同值的个数分别远小于|I|×|N|和|I|,并且实验结果可以更好地说明这一点.5实验本文通过在两组真实数据上进行实验,来验证一致性和时效性混合清洗方法的性能.5.1实验设置硬件方面,本实验使用IntelCorei7-2600(3.4GHz)CPU,搭载8GBRAM的主机.程序方面,本实验使用Java语言进行实现,并且对于每组实验均重复5次,取平均值进行比较.实验数据集.本文使用HOSP和NBA两组真实数据,并使用实验中发现的规则对数据中本身存在的错误进行检测.(1)HOSP①.该数据集是一个真实数据集,来自于美国国民卫生服务中心,记录了病人在住院期间的医疗统计信息.HOSP数据集包含17个属性和1.3K个实体,并且包含了超过200KB的信息记录.(2)NBA.队员的信息数据Players和赛季比赛统计信息数据Stat是从体育信息数据库网站②上抽取得到真实数据表.NBA是由Players和Stat集成得到的数据集.在集成的过程中,使用eid作为连接属性,对两个表进行等值连接.融合后的NBA数据集的关系模式为(pid,name,team,league,tname,points,poss,allpoints,min,arena,opened,capacity,state),涉及758个实体,并且包含18753条记录.需要说明的是,HOSP数据集中本身存在冲突①②Page11数据和时序错误的数据,NBA是由于数据融合的过程而产生的数据的不一致和时序错误.对错误数据的甄别使用样本分析的方法,从数据中抽取样本采用人工甄别的方法找出数据中的错误.在具体的甄别过程中采用“封闭世界”原理,即只找出能够被确认是错误的数据,对于无法辨别的数据,且当做真实数据进行处理.规则集.本实验首先从HOSP和NBA数据集上分别抽取高质量的数据样本,然后使用文献[9]中提出的方法计算出所有的一致性候选规则,由领域专家从候选规则中选出适合的规则进行清洗.时效规则则由领域专家采用人工方法对数据进行分析得到.对于HOSP数据集,选取120条支持率大于0.05的CFDs(即每条规则至少可以控制200条记录)合并成19条CCFDs,然后与22条CCs进行混合.对于NBA数据集,选取190条支持率大于0.05的CFDs(即每条规则至少可以控制90条记录)合并成27条CCFDs,然后与35条CCs进行混合.以NBA数据集为例,表1给出了其中的部分规则.混合规则范例CCFDsψ1:(arena|→state,Sc)Sc{Sc0{“ConsecoFieldhouse”,“ToyotaCenter”,Sc1{“UnitedCenter”}}CCsφ1:t1,t2(t1[tname]=“NewOrleansJazz”∧φ2:t1,t2(t1[allpoints]t2[allpoints]→t1tnamet2)对比方法.为了便于观察分析修复方法的性能,本文使用如下的4种方法进行对比实验:(1)CCFD方法只使用CCFDs进行检测和修复;(2)CC方法只是用CCs进行检测和修复;(3)CFD+CC方法和(4)CCFD+CC方法分别使用CFDs-CCs和CCFDs-CCs的混合规则进行检测和修复.4种方法均按照本文提出的框架进行清洗,具体实现时只需要将输表2不同数据集上的检测效果HOSP0.0720.0590.1320.1390.4820.3920.8820.9250.1250.1030.2300.242NBA0.0580.0460.0990.1060.5270.4170.9010.9650.1040.0830.1780.191表3不同数据集上的修复效果HOSP0.0660.0560.1250.1320.4520.3720.8310.8820.1150.0860.2170.230NBA0.0540.0430.0950.1010.4910.3890.8620.9230.0970.0770.1710.181本文从总体性能、扩展性两个方面对修复方法入部分的规则约束替换成上述规则即可.同时,本文使用元组t关于属性A的属性值t[A]作为修复的基础计数单位,称为元子.在此基础之上,使用准确率、召回率和F-measure来评价检测方法的效果,其中检测准确率Pd=检测错误数召回率Rd=检测错误数于修复过程,只需要评价方法中的检测错误数换成正确修复数,得到修复准确率Pr、修复召回率Rr以及对应的Fr-measure.其中,检测错误数和正确修复数均由每次迭代检测和正确修复的属性值个数求并集得到.并且,召回率越高说明检测和修复的效果越好.5.2实验结果进行评估.5.2.1总体性能对修复方法的总体性能进行评价.检测和修复效果.表2和表3分别描述了在HOSP和NBA数据集上的检测效果和修复效果.从实验中可以看出:(1)检测和修复方法的召回率比对应的准确率和F-measure高.准确率由数据中的错误比例所决定,对于HOSP和NBA数据集,他们的错误率分别在15%和11%左右,另外,实际检测到和修复正确的错误数还要略少一些,所以得到的准确率较小,对应的F-measure也较小;(2)对于CCFD+CC,其修复召回率和检测召回率分别在92%以上和88%以上.这说明本文提出的方法具有非常显著的清洗效果.相比CFD+CC,CCFD+CC的检测结果和修复结果分别高出4%~6%和5%~6%.清洗过程中,考虑数据之间的关联关系更有利于发现数据中的潜在错误;(3)从召回率的角度来看,相比单独使用CCFD和CC,CCFD+CC可以得到更加准确的清洗结果,其检测结果和修复结果分首先,从检测和修复效果、运行时间、迭代情况Page12别高出二者总和的6%~10%和3%~4%.这说明规则之间是相互作用的,并且相互促进.运行时间.图4描述了4种算法中各个过程的运行时间分配情况.总体上看,CCFD+CC的运行时间最高,比CFD+CC高出7%.这种开销是由于在计算相关数据过程中,一些数据被重复计算所产生的,并且开销的程度是可以被接受的.从具体的时间分配上看,错误的检测、定位和目标值的选取这3个过程占主要时间开销.迭代情况.图5描述了HOSP数据集上的迭代情况.每一次迭代都会在上一次迭代的基础上进行.所以,随着迭代次数的增加,检测和修复的效果越来越准确.对于HOSP数据集,从第5次迭代开始清洗效果趋于稳定,到第7次迭代时,清洗过程终止.5.2.2扩展性接下来,本文在不同规则数量和不同元组数量情况下,研究修复方法的扩展性.本实验分别改变规则数量和元组数量,观察HOSP数据集上修复召回率、运行时间和迭代次数的变化情况.变化的规则数量.图6描述了在规则数量变化的情况下,清洗方法的性能变化.横坐标表示混合规则的数量,“+”的前后分别表示混合规则中CCFD的数量和CC的数量.在清洗的过程中,CCFD+CC方法使用规则总和进行修复,CCFD方法和CC方法分别使用与之对应的规则进行修复,CFD+CC方法则将其中的CCFD规则拆分成等价的CFD规则进行修复.从图6(a)可以看出,修复方法的召回率受规则数量的影响比较明显.这说明规则集合的数量越多、越完备,其修复的效果越好.实验中所给出的19+22条规则可以检测出数据中92%以上的错误,说明这些规则与数据中的错误是最为相关的.虽然可以通过增加规则数量的方法来提高检测的准确性,但是效果不会非常明显.所以,制定高质量的清图6不同规则数量的清洗结果(CCFD+CC)Page13洗规则,对进行数据修复至关重要.从图6(b)可以看出,CCFD和CC分别呈现正比增长和二次幂数增长,混合后的CFD+CC和CCFD+CC介于两者之间并大于CCFD的增长速度.从图6(c)可以看出,迭代次数随规则数量增加快速上升.需要说明的是,规则数量的增加可能增加修复序列的长度,进而增加清洗的迭代次数和清洗时间.另一方面,由于每次迭代后都需要重新对修复序列进行计算,所以无法对清洗的迭代次数和运行时间进行估计.在实际操作时,如果运行的时间过长,可以在清洗效果满足用户需求的情况下人为地进行程序终止.变化的元组数量.图7描述了在HOSP数据集上元组数量的变化对清洗方法的性能影响.从图7(a)可以看出,元组数量对修复召回率影响较小.新添加的元组中可能会包含一些关联数据,也可能会夹杂一些新的错误数据,这些会对请洗的结果产生波动.从图7(b)可以看出,4种修复方法的运行时间呈二次幂数增长.因为在第4节中各项算法复杂度分析中,关于元组数量I,数据检测和错误定位的复杂度均为|I|2,而目标值选取的复杂度虽然为|I|3,但实际的错误量会趋近于|I|2,所以整个方法的运行时间呈二次幂数增长.特别,在处理“大数据”的一致性和实效性的清洗问题时,并且结合图6给出的结论,可以通过适当减少迭代次数进行清洗,既可以缩短运行时间,又不会损失很大的清洗精度.对于本文使用的数据集,建议迭代次数缩短到原来的70%以上即可.如果采用并行计算,可以将数据按照80KB进行分片.从图7(c)可以看出,迭代次数随元组数量的增长而缓慢上升.这是因为新增加的元组中可能会夹杂一些新的潜在错误,从而增加了迭代次数.通过上述的总体性能实验和扩展性实验可以看出,本文提出的方法可以有效地解决数据中一致性和时效性的混合错误,并保持较高的清洗效率.6结束语基于条件合并的函数依赖CCFDs和时效约束CCs,本文提出了一种关于关联数据的一致性和时效性的清洗方法.利用CCFDs将关联数据放在一起,用以检测出数据中的潜在错误;同时将CCFDs和CCs进行混合,用以解决一致性和时效性的混合问题.本文对CCFDs和CCs混合的基本问题进行分析,并且分别证明了混合规则的可满足性问题和蕴含问题均是co-NP完全问题.为了对错误数据进行修复,本文提出了一种新的自动清洗框架.由于清洗中的检测过程和修复过程的相互作用关系,本框架采用一种迭代的方法对数据进行修复.基于本文提出的关联数据的修复代价模型,进一步证明了关于关联数据的一致性和时效性的最小代价修复问题是一个Σp启发式方法对数据进行修复.此外,为了得到正确的修复顺序,本文提出了修复序列图的概念,有助于找到需要优先修复的错误数据.最后,通过HOSP和NBA两组真实数据集上进行实验,证明了本文提出的修复方法的实用性和高效性.Page14未来我们将继续致力于研究数据检测和数据修复的相关问题.我们将重点研究:对于检测出的错误,是选择对错误数据进行修复还是对规则进行修复,并且如何修复.
