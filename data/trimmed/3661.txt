Page1多维代价图模型上最优路径查询问题的研究杨雅君高宏李建中(哈尔滨工业大学计算机科学与工程学院哈尔滨150001)摘要近年来,图数据模型被广泛地用于刻画现实世界中各种各样的实体间的复杂关系.最短路径查询是图研究领域中一类非常重要的查询并有着广泛的应用.然而,目前大多数关于最短路径的查询都是定义在单代价(权重)图模型下的.现实世界中,基于单一代价所选择的最短路径并不明智,比如路程最短的路径需要花费极高的费用.该文中,作者介绍了多维代价图模型的概念,并给出了多维代价图模型下基于函数的最优路径的定义.现有的计算最短路径的方法都利用了最短路径的子路径最优的性质:最短路径上的任意两点间的子路径是这两点的最短路径.因此,在计算最短路径的过程中,对访问过的每个顶点,只需保留起点到该点的最短路径即可.不幸的是,多维代价图模型下,当评分函数是非线性的时候,子路径最优的性质并不成立.因此,目前的方法均不能应用于多维代价图模型下基于函数的最优路径查询问题.该文给出了一个best-firstsearch分支界限法并给出3种优化策略.进一步,给出了一个顶点过滤算法,该算法能从图中过滤掉大部分不属于最优路径的顶点.最后,用真实数据集上的实验验证了算法的有效性.关键词多维代价图;最短路径;目标函数;路径查询1引言近年来,图数据模型被广泛地用于刻画现实世界中各种各样实体间的复杂关系,如交通网、XML数据库以及社交网络等等.其中,最短路径查询是图研究领域中一类非常关键的问题并有着重要的应用.例如,在交通网中,顶点代表城市,两个城市之间存在边意味着它们之间存在一条公路,最短路径查询返回两座城市之间最短的公路里程.社交网络中,顶点代表人,边代表人和人之间存在直接的交往关系,边的权值反映了两人直接关系的亲密程度,两点之间的最短路径则反映了社交网络中两人联系的紧密度.目前,大多数工作都假设图模型中边的代价(权值)是单一的.事实上,不同实体之间的关系可以从多个角度来进行考察,因而描述这些关系的边就需要用多个代价来进行刻画.比如在交通网中,两座城市之间建有一条高速公路,公路的长度、通过该公路的费用以及该公路的拥挤程度分别从不同角度刻画了通行这条公路的代价.因此,在描述该网络的图模型中,边上的代价应该是多维的,进而任意两个顶点间路径的代价也是多维的.现实生活中,用户对最短路径的选择应该是基于多维代价的综合考虑,仅仅依靠某一代价做出的最短路径选择并不明智.比如,公路网中,总路程最短的路径有着相当高的经济代价.在此情况下,用户宁愿选择一条路程稍长的路径,但是其经济代价远远小于路程最短的路径.因此,如何根据用户的喜好,返回给用户一个综合考虑的最优路径成为了一个重要的问题.本文假设用户给出一个评分函数f(·),f(·)反映了用户对不同类别的代价的重视程度,不同用户给出的函数f(·)可能不同.函数f(·)根据路径在多个维度上的代价计算出一个综合代价得分.给定起点和终点,本文的目的是找到函数f(·)下得分最小的路径,我们称之为基于函数f(·)的最优路径.Dijkstra算法是求解图上两点间最短路径的经典算法.Dijkstra算法的核心思想是利用了最短路径的子路径最优性质:最短路径上的任意一条子路径也是最短路径.因此,在计算最短路径的过程中,算法对访问过的每个顶点,只需要保存起点到该点的最短路径即可.目前有关最短路径的工作都是基于Dijkstra算法的核心思想[1-6].这些工作的主要方法是:在图上建立索引,索引内部顶点之间的最短路径已经被计算并且保存起来.当一个查询到来,算法先检索索引内部需要访问的最短路径,然后与索引外部的最短路径进行优化连接,最终得到查询结果.索引不同,算法效率也就不同.然而,这些方法,无论是在建立索引过程中,还是在利用索引完成最短路径查询时,都利用了子路径最优的性质:即只需维护索引内部顶点间的最短路径,同时,对运算过程中访问过的节点,只需维护起点到它的最短路径即可.不幸的是,当用户提供的评分函数是非线性的时候,子路径最优的性质在多维代价图中并不成立(详见2.2节).因此,目前关于最短路径的方法都不能解决本文所要面对的问题.运筹学领域中的相关研究表明,非线性代价函数在物流网应用中广泛存在.在物流网中,运输大量货物时,在不同时段或不同地段所花费的运输费用随着通行距离的不同而发生变化.如文献[7]所示,该费用是与距离相关的分段线性函数或者分段凹函数.这说明,该费用代价函数是与距离相关的非线性函数.进而,费用与距离以任何形式组合得到的函数也是非线性的.另外,在某些特殊情况下,如自然灾害中急需物资的运输或者战争中军需物资的运输,运输网络可能遭到破坏.如文献[8]所示,此时距离和费用的不同度量标准导致了非线性代价函数的存在(多项式函数或凸函数).本文中所给出的算法,可适用于各种类型的代价函数(线性的和非线性的).多维代价图上的多标准Pareto最优路径计算(MCPP)问题在运筹学领域被广泛研究[9-11].给定起点和终点,MCPP的目的是找到起点到终点的互不支配的全部路径,即Pareto最优路径.显然,一条Pareto最优路径也是一条skyline路径.大多数解决MCPP的方法都基于Dijkstra的算法思想,即任意一条Pareto最优路径上的子路径也应该为一条Pareto最优路径.这些方法需迭代地计算出目标Pareto路径所经过全部顶点的Pareto最优路径,并扩展出起点到终点的全部Pareto最优路径.MCPP与本文中问题的主要区别在于,MCPP要找到起点到终点的全部Pareto最优路径,而本文中的问题只需找到一条在评分函数f(·)下的最优路径即可.显然,找到全部Pareto最优路径之后再计算函数f(·)下的最优路径的效率十分低下,因为绝大部分Pareto最优路径并非函数f(·)下的最优路径,所以这些路径无需被计算出来.另一方面,这些方法只是Page3从理论上给出计算Pareto最优路径的方法,并没有从算法实际运行效率的角度设计算法和优化算法,也没有采用数据处理的优化技术.因此,这些方法需要承受较高的时间和空间开销.本文的主要贡献如下:我们首先给出了一个有效的best-firstsearch分支界限算法,该算法可以裁剪掉大量不是最优结果的路径.我们同时给出了两个优化剪枝策略以及快速计算和更新阈值的策略,这些策略均有效地提高了算法的效率.进一步地,我们给出一个过滤算法,该算法可以从图中过滤掉大部分不属于最优路径的顶点,从而缩小图的规模.最后,我们通过真实数据集上的实验验证了算法的有效性.本文第2节介绍多维代价图上最优路径查询问题的定义以及面临的挑战性问题;第3节给出best-firstsearch分支界限算法、剪枝策略以及快速计算和更新阈值的方法;第4节给出顶点过滤算法;第5节通过真实数据验证算法的有效性;第6节讨论相关工作;最后,我们总结本文.2问题定义及面临的挑战性问题在本节中,我们将介绍多维代价图模型以及在该图模型中最优路径查询问题的定义.2.1多维代价图的概念多维代价图是一个有向图,记为G=(V,E),其中V是图上的顶点集合,E是图上的边集合.E中每条边e记为e=(u,v),u,v∈V,e被称为u的出边或者v的入边,v称作u的出边邻居,u称作v的入边邻居.每条边e被赋予一组d维代价向量犮狅狊狋(e),犮狅狊狋(e)=(c1,c2,…,cd),表示通过该边所花费的d种代价,其中ci(i=1,2,…,d)为通过该边所花费的第i种代价的取值.举例说明,在公路网中,城市A与城市B之间存在一条有向边e,代表A通过e直接可达B.犮狅狊狋(e)=(c1,c2,c3)为边e上的一组三维代价向量,其中,c1表示A与B之间的欧氏距离,c2表示从A到B所花费的时间,c3表示从A到B所要花费的费用.在本文中,我们合理假设ci取值非负,因为现实世界中不存在小于零的代价.我们的方法可以方便地扩展到无向图上,对一条无向边e=(u,v),可等价地看作两条有向边e1=(u,v)和e2=(v,u),且犮狅狊狋(e1)=犮狅狊狋(e2)=犮狅狊狋(e).简单起见,本文只针对有向图进行讨论.一条路径p是一组由图上顶点所构成的序列,p=(v0,v1,…,vl),其中,vi∈V(0il)并且ei=(vi-1,vi)∈E(0<il).路径p被称作是简单的,当且仅当p上的顶点没有重复出现,即对任意的0i,jl,满足vi≠vj.路径p的代价犮狅狊狋(p)为p所经过全部边的代价的矢量和.令{e1,e2,…,el}为路径p所经过的全部边的集合,则路径p的代价为犮狅狊狋(p)=(c1(p),c2(p),…,cd(p)),犮狅狊狋(p)是所有犮狅狊狋(ej)的矢量和,即犮狅狊狋(p)=∑lci(p)=∑l为路径p和边ej在代价向量犮狅狊狋(p)和犮狅狊狋(ej)中第i个维度上的取值.评分函数f(·)是用户在多维数据空间中指定的一个聚集函数,它反映了用户对不同数据对象喜好程度的得分.f(·)将数据对象在各个维度上的取值聚合成一个值,通过每个数据的得分情况,返回给用户一个最满意的结果.一般地,分值越小,用户满意度越高.本文中,f(·)根据犮狅狊狋(p)计算路径p的得分.我们假设评分函数f(·)是单调递增的,即对于两条不同的路径p和p,如果对i,1id,都可满足ci(p)ci(p),并且i,1id,可满足ci(p)<ci(p),则有f(p)=f(c1(p),c2(p),…,cd(p))<f(c1(p),c2(p),…,cd(p))=f(p).这里,f(p)等同于f(犮狅狊狋(p)),方便起见,我们在下文中将统一记为f(p).评分函数的单调性是评分函数的一个普遍性质,并具有其合理性[12].其直观意义为:如果在各个维度上,数据对象p的代价都不大于另一对象p,则对p的评价应不差于p.下面,我们给出多维代价图上基于函数f(·)的最优路径的定义.定义1.基于函数f(·)的最优路径.给定多维代价图G(V,E)及评分函数f(·),s,t∈V是图上任意两点,令Ps,t表示s到t的所有路径的集合.s到t之间基于函数f(·)的最优路径,记为sp(s,t),定义为Ps,t中具有最小函数值f(·)的路径,即对p∈Ps,t,有f(sp(s,t))f(p).多维代价图上最优路径查询问题的定义为:输入:多维代价图G,起点s和终点t,函数f(·);输出:基于函数f(·)的s到t的最优路径sp(s,t).如图1所示,在本例中,我们选取评分函数为f(x,y)=x+y.考虑路径p:s→d→t,其代价向量Page4为犮狅狊狋(p)=(10,4),综合代价得分为f(p)=14.因此,路径p在所有s到t的路径中综合代价最小,则路径p为s到t的最优路径sp(s,t).2.2挑战性问题几乎目前的所有工作都是基于Dijkstra算法的改进,Dijkstra算法的思想是利用了最短路径的子路径最优的性质.我们以Dijkstra算法为例,说明最短路径的子路径最优的性质在多维代价图中并不成立.因此,现有的计算最短路径的方法不能直接应用到本文所要解决的问题.若评分函数f(·)是线性的,即对任意边ei,ej,满足f(ei+ej)=f(ei)+f(ej),则可将Dijkstra算法扩展到本文所要解决的问题.对图中的每条边e,先对e上的d维代价向量计算得分f(e),并将f(e)记为边e上的权重.根据权重f(e),在图G上应用Dijkstra算法所找到的最短路径p即为本问题的解.否则,存在另一条路径p,使得f(p)<f(p).根据函数f(·)的线性性质,得到f(p)=f(∑l∑lf(ei)<f(p)=f(∑ri=1Dijkstra算法正确性相矛盾.若评分函数f(·)是非线性的,即函数f(·)满足f(ei+ej)≠f(ei)+f(ej),则基于Dijkstra算法思想的方法不可应用到本问题中.在图1所示例子中,我们选取f(x,y)=x2+y2为评分函数.显然,该函数在{x0,y0}的区域内满足单调递增的性质.我们的目标为计算出基于函数f(x,y)的由s到r的最优路径.我们在该图上运行Dijkstra算法.当计算到顶点c的代价时,发现路径p:s→a→c的代价为f(1,6)=37,大于路径p:s→b→c的代价f(4,4)=32.因此,Dijkstra算法保存p为s到c的最优路径.当计算到顶点r的最优路径时,因为顶点r只连接一条由c出发的入边(c,r),所以Dijkstra算法计算s到r的最优路径sp(s,r)为p和(c,r)的连接,即sp(s,r)=p+(c,r)=(4,4)+(3,3)=(7,7),其得分为98.然而,正确结果sp(s,r)应为s→a→c→r,得分为f(4,9)=97<f(sp(s,r)).原因是多维代价图上并不具有最短路径的子路径最优的性质.显然,顶点s到顶点r的最优路径s→a→c→r中的子路径s→a→c并不是顶点s到顶点c的最优路径.此外,Dijkstra算法不更新已访问过顶点的代价,这导致无法在图G上找到基于非线性函数的最优结果.同样在图1所示例子中,我们的目标为计算s到t的基于函数f(x,y)=x2+y2的最优路径.我们发现s到d的代价得分小于s到c的代价得分,因此Dijkstra算法优先访问顶点d.当访问顶点c时,因为顶点d已访问过,算法不会更新s到d的代价,所以Dijkstra算法计算出s到t的最优路径为s→d→t,其得分为f(10,4)=116.实际上,s到t的最优路径为s→a→c→d→t,其得分f(7,8)=113<f(10,4).现有方法都利用了Dijkstra算法的核心思想,即最短路径的子路径最优性质.因此,它们都无法解决本文要面对的问题.枚举法是计算基于非线性函数f(·)最优路径的一种直接方法:给定起点s和终点t,首先找到s到t的全部路径并分别计算其得分,最后返回给用户得分最小的路径.设λ为图G的最大出度,即λ=max{d+(v)|v∈V},其中d+(v)为顶点v的出度,则该方法的搜索空间为O(λn),n为图中顶点个数.显然,该方法不可行.另外一种方法为预计算:我们先预计算得到图上任意两点之间的最优路径,当一个查询到来,可以在常数时间内将结果返回给用户.该方法的主要问题是无法应对用户给出不同的评分函数f(·).由于用户给出的评分函数千差万别,对某个f(·)预计算出的最优路径未必是在另一函数f(·)下的最优路径.多维代价图上的多标准Pareto最优路径计算(MCPP)问题在运筹学领域被广泛研究.给定起点s和终点t,MCPP目的是找到s到t的互不支配的全部路径,即Pareto最优路径.显然,一条Pareto最优路径即是一条skyline路径.解决MCPP问题的主要方法为标签法.其主要思想是:用一个优先队列维护图中顶点,并且对图中每个顶点v维护一组标签list(v),list(v)记录了起点s到v的Pareto最优路径.当一个顶点u从队列弹出后,扩展其邻居顶点v,并根据list(u)和边(u,v)更新list(v).当list(v)支配队列中所有顶点u的list(u)时,算法结束.这些方法的主要问题在于:(1)这些方法基于Dijkstra算法的思想,即Pareto最优路径上的子路径也一定是Pareto最优路径.因此,若依据路径p的函数值Page5f(p)来扩展优先队列中的顶点,会遇到与Dijkstra算法计算最优路径相同的问题,即无法找到最优路径.(2)在计算起点s到终点t所有Pareto最优路径的过程中,对所有Pareto最优路径经过的所有顶点v,这些方法都需要计算并维护起点s到顶点v的Pareto最优路径.显然,这导致了极高的时间开销和空间开销.(3)函数f(·)下的最优路径一定是一条Pareto最优路径,但一条Pareto最优路径未必是函数f(·)下的最优路径.因此,找到全部Pareto路径之后再计算函数f(·)下的最优路径的效率十分低下,因为绝大部分Pareto最优路径并非函数f(·)下的最优路径,所以这些路径无需被计算并且被维护起来.(4)这些方法大多数用于解决2维代价图上的MCPP问题,在高维度下,这些方法具有极低的效率甚至无法运行.相反地,本文提出的算法,在高维度下具有十分优秀的效率且随着维度的增高,算法效率不会受到明显的影响.此外,这些方法只是从理论上给出计算Pareto最优路径的方法,并没有从提高算法实际运行效率的角度来设计算法和优化算法,也没有用到数据处理中的优化技术.因此,这些方法需要承受较高的时间开销和空间开销.下文中,我们将给出一种有效的best-firstsearch分支界限算法,用于搜索非线性评分函数下起点到终点的最优路径.同时,我们给出3种优化策略,这些策略可以显著地提高算法效率.最后,我们给出一个顶点过滤算法,该算法可以过滤掉图中大部分不属于最优路径的顶点.3分支界限算法在本节中,我们首先提出一个best-firstsearch分支界限算法,该算法可以有效地裁剪掉大量不是最优解的路径,从而加速对非线性评分函数下的最优路径搜索.我们首先给出一个基本的分支界限算法,然后介绍提高算法效率的优化策略.3.1基本分支界限算法给定图G(V,E),图中所有由起点s出发的路径可以组织成一棵搜索树,其根节点是起点集合{s},任意一个非根节点代表一条从点s出发的路径(顶点序列).设C和C为搜索树上的两个节点,它们分别代表两条不同的路径.节点C是节点C的父亲节点,当且仅当它们满足以下条件:(i)CC且|C|=|C|+1;(ii)C\C中的唯一顶点v满足vC且v∈N+(u),u为路径C的终点,N+(u)表示u的出边邻居集合.这里,CC表示C是C的路径前缀,|C|表示路径C上的顶点个数,vC保证了将v加入C不会出现环路,即C是简单的.因此,起点s到终点t基于函数f(·)的最优路径查询问题,转化为树搜索问题:即在树上找到一个节点C,其所代表路径的终点为t,使得f(C)小于等于任何其他以t为终点路径C的评分f(C).下文中,我们直接用C来指代C所代表的路径和相应的代价向量.图2展示了图1例子中s到t路径的搜索树.我们利用一个最小堆H来维护搜索树上待搜索的节点,堆中的节点根据他们在函数f(·)下的得分排序.我们初始化堆H为只包括起点s的路径{s}.我们的算法在搜索树上执行best-first搜索,即每次弹出堆顶路径C,f(C)取值在堆中最小.我们用τ表示目前已探索到的s到t最优路径的得分,初始化时,τ=.若路径C的评分f(C)>τ,则搜索树上以C为根的子树可以被安全剪除,即对以C为根的子树上的任意一个节点C,都有f(C)>τ.引理1保证了该剪枝策略的正确性.引理1.对于搜索树上的任意两个节点C和C,如果C是C的祖先,则有f(C)f(C).证明.若C是C的祖先,由搜索树的定义,则C是C的路径前缀.根据函数f(·)的单调性,可以得到f(C)f(C).当路径C从最小堆H弹出时,我们假设路径C的终点为u.对u的任一以出边相连的邻居v∈N+(u),当v≠t时,我们首先判断将v添加进路径C是否会形成环路,即是否v∈C.若vC,我们计算新路径C=C∪{v}在函数f(·)下的得分.路径C的代价向量为犮狅狊狋(C)=犮狅狊狋(C)+犮狅狊狋(u,v),这里犮狅狊狋(u,v)为边(u,v)的代价向量.犮狅狊狋(C)已知,否则因无法计算f(C),C不会被加入堆H.C是C的孩子,若f(C)τ,根据引理1,我们可将以C为根的子树剪掉,否则我们将C加入堆H以待搜索.当v=t时,C是一条终点为t的路径.我们根据f(C)更新τ的取值.若f(C)<τ,我们用路径C代Page6本小节给出两种优化剪枝策略,在给出剪枝策替目前找到的终点为t的最优路径,并根据f(C)更新τ的取值.当v=t时,算法不会将C加入堆H.当最小堆H=,或者堆顶元素C的评分f(C)τ时,算法停止.显然,对堆中任意节点C,有f(C)f(C),而以C为根子树中的任意节点C,有f(C)f(C).此时,τ对应的路径即为起点s到终点t的最优路径.3.2优化剪枝策略略之前,我们首先介绍skyline路径的概念.定义2.路径支配.给定多维代价图G(V,E),令p和p是G上两条不同的路径,且路径p和路径p的代价向量分别为犮狅狊狋(p)=(c1(p),c2(p),…,cd(p))和犮狅狊狋(p)=(c1(p),c2(p),…,cd(p)).我们称p支配p,记作pp,当且仅当对i,1id,有ci(p)ci(p),且i,1id,有ci(p)<ci(p).这里,ci(p)和ci(p)为犮狅狊狋(p)和犮狅狊狋(p)中第i维的代价取值.定义3.skyline路径.给定多维代价图G(V,E)和图上两点u,v.Pu,v为u到v所有路径的集合.u到v的skyline路径集合,记为SKYPu,v,定义为所有不被Pu,v中其他路径支配的u到v路径的集合,即对p∈SKYPu,v,不存在p∈Pu,v,使得pp.显然SKYPu,vPu,v.基于skyline路径的剪枝规则:在搜索以{s}为根的搜索树的过程中,对图中每一个顶点u维护一个s到u的已探索到的skyline路径集合SKYPs,u.初始化阶段,SKYPs,u=.给定节点C,C所表示路径的终点为u,若p∈SKYPs,u,使得pC,则以C为根的子树可以被安全的剪除.否则,将路径C加入集合SKYPs,u.同时,若p∈SKYPs,u,Cp,则可将p从SKYPs,u中删除.引理2保证了该剪枝规则的正确性.引理2.设C和C是搜索树上两个不同的节点,且它们所代表路径的终点都为u.若CC,则起点s到终点t的最优路径不可能出现在以C为根的子树中.证明.不失一般性,设珟C为在C为根的子树中终点为t的路径,我们只需证明存在另外一条s到t的路径p,满足f(p)<f(珟C).由搜索树定义,得知C为珟C的路径前缀.令γ=珟C\C表示珟C中去掉前缀C后的子路径,γ的起点为u.若/v∈γ\{u},满足v∈C,则我们可连接C和γ得到路径p(因为C的终点和γ的起点都为u),且p中无环路.因为C可知f(p)<f(珟C).若v∈γ\{u},满足v∈C,令v为路径γ中最后一个出现在C的顶点.我们考虑C的路径前缀p,p的终点为v,则pC.又因CC,有pC.令γ为γ的路径后缀,γ的起点为v.我们连接p和γ得到路径p,p中无环路.因为p=p+γC+γ=珟C,所以有f(p)<f(珟C).在介绍第2个剪枝策略前,我们先介绍最优路径代价下界的定义.定义4.最优路径代价下界.给定多维代价图G(V,E),图G上的每条边e具有d维代价向量犮狅狊狋(e),这里,犮狅狊狋(e)=(c1(e),c2(e),…cd(e)).1,2,…,d为d张单代价加权图,i=(V,E)称为基于图G上第i维代价的加权图,i中任意一条边e的权值为ci(e).对于图G中任意两点u,v∈V,我们称=1,2,…,{集合,其中i为i上u到v的加权最短路径,路径i的代价为φi.我们称代价向量Φu,v=(φ1,φ2,…,φd)为多维代价图G上u到v的最优路径代价下界.对图G上u到v的任意一条路径p∈Pu,v,令其代价向量为犮狅狊狋(p)=(c1(p),c2(p),…,cd(p)),则我们有Φu,vp,即对i,1id,有φici(p).引理3说明Φu,v是图G上u到v最优路径的一个严格下界.引理3.Φu,v是图G上u到v的最优路径的一个严格下界,即不存在另一个下界Φu,v,对p∈Pu,v和Φu,v,有Φu,vp∧Φu,vΦu,v.证明.反证法.假设存在一个Φu,v,其满足Φu,vΦu,v,则i(1id),使得φi>φi.另一方面,因为i∈和Φu,vi,所以有φiφi.矛盾.证毕.基于最优路径代价下界的剪枝规则:我们预计算出图G上任意两点u,v之间的最优路径代价下界Φu,v.给定节点C,C的终点为u,我们根据u到t的最优路径代价下界估计一个下界LB(C),LB(C)=f(C+Φu,t),LB(C)表示在以C为根的子树中终点为t的路径的得分下界.若LB(C)τ,以C为根的子树可以被安全地剪除,引理4保证了该剪枝规则的正确性.引理4.C是搜索树上的节点且LB(C)τ,不失一般性,令珟C为在C为根的子树中终点为t的路径,则f(珟C)τ.证明.C所代表路径的终点为u,C为珟C的路径前缀,则γ=珟C\C表示珟C中去掉前缀C后的子路Page7径且γ的起点为u.γ是u到t的一条路径.根据u到t的最优路径代价下界的定义,我们有Φu,tγ.因此,C+Φu,tC+γ.根据函数f(·)的单调性,f(珟C)=f(C+γ)f(C+Φu,t)=LB(C)τ.证毕.算法1给出了best-firstsearch分支界限法计算最优路径的流程.实际上,图中会存在大量不属于最优路径的顶点,探索这些顶点会带来不必要的时间开销.将这些顶点从图中删除,不会影响查询结果的正确性.因此,如何判定一个顶点与最优路径无关,成为了一个关键的问题.在第4节,我们介绍一种快速顶点过滤技术,可以有效地从图中过滤掉大部分不属于最优路径的顶点,从而缩减图的规模.3.3快速计算和更新阈值在搜索过程中,阈值τ是一个关键的参数.显然,τ的取值越小,其剪枝能力越强.然而,在算法开始阶段,τ被初始化为,直到探索到一个终点为t的路径C时,裁剪规则才开始生效.因此,裁剪规则在算法开始阶段的裁剪能力非常低.下面,我们将给出一个预先快速计算τ以及搜索过程中快速更新τ的方法.给定多维代价图G(V,E)、起点s和终点t,考虑s到t的单代价最短路径集合={1,2,…,d}.显然,i也是多维代价图G(V,E)上的一条路径.此外,我们找到s到t的跳数最少的路径hop,即对p∈Ps,t,满足hopp,|p|为p中顶点个数.我们初始化τ=minf()i,f(hop)|1i显然,最优路径sp(s,t)的评分满足如下关系:f(Φs,t)f(sp(s,t))τ,f(Φs,t)为代价向量Φs,t的得分.实验证明,该方法给出的初始阈值τ具有很强的剪枝能力.我们同时给出一种在搜索过程中快速更新τ的方法.当路径C从最小堆H弹出时,假设其终点为u,同样考虑u到t的单代价最短路径集合=1,2,…,{一个得分上界UB(C),()UBC=min{f(C+i)|1id}.若UB(C)<τ,我们可将τ更新为UB(C).引理5保证了该更新规则的正确性.算法1.Find-sp(s,t)-Best-First-Search(G,s,t,f(·)).输入:多维代价图G,起点s,终点t,评分函数f(·)输出:最优路径sp(s,t)1.τ←,sp(s,t)←,H←{s},cost({s})←0;2.WHILEH≠DO3.letCbethepathbypoppingupthetopelementfrom4.IFf(C)τTHEN5.BREAK;6.FOREACHvertexv,v∈N+(u)∧vCDO7.C←C∪{v};f(C)←f(C+(u,v));8.IFv=tTHEN9.IFf(C)<τTHEN10.τ←f(C);sp(s,t)←C;continue;11.ELSE12.LB(C)←f(C+Φv,t);13.IFf(C)τTHEN14.prunethesubtreerootedatC;continue;15.IFp∈SKYPs,v,pCTHEN16.prunethesubtreerootedatC;continue;17.ELSE18.SKYPs,v←SKYPs,v∪{C};19.FOREACHp∈SKYPs,vDO20.IFCpTHEN21.SKYPs,v←SKYPs,v-{p};22.IFLB(C)τTHEN23.prunethesubtreerootedatC;continue;24.insertCintoHaccordingtof(C);25.RETURNsp(s,t),τ引理5.设C是搜索树上的一个节点,C所代表路径的终点为u,C的最优路径得分上界为UB(C),则存在一条s到t路径的p,f(p)UB(C).证明.设min为使得f(C+i)(1id)取值最小的路径i,则min是u到t的一条路径.若min∩C={u},则连接C和min得到一条路径p,其代价得分即为UB(C).若min∩C≠{u},则{u}min∩C.令v是路径min中最后一个出现在C中的顶点,即对v∈min∩C,v在min中位于v之前.令C为C中的终点为v的路径前缀,min为min中起点为v的路径后缀.我们连接C和min得到新路径p,p中无环路.因为pC+min,所以()fpfC+()min()UBC.4顶点过滤算法本节中,我们提出一个顶点过滤算法,该算法可以快速地从多维代价图G(V,E)中过滤掉大部分不属于最优路径的顶点,从而有效地缩减图G(V,E)的规模.我们首先介绍过滤索引,然后给出过滤算法.算法2.Vertex-Filtering(G,s,t,f(·)).输入:多维代价图G,起点s,终点t,评分函数f(·)输出:最优路径sp(s,t)Page81.τ←minf()i,f(hop)|1i2.FOREACHu∈VDO3.IFτ<f(Φs,u+Φu,t)THEN4.V←V-{u};5.FIND-sp(s,t)-Best-First-Search(G,s,t,f(·));6.RETURNsp(s,t),τ4.1过滤索引过滤索引是一个n×n的矩阵,n是图G上的顶点个数.矩阵中的行代表起点,列代表终点.矩阵中每个元素Au,v包括两个部分:(1)顶点u到顶点v的最优路径代价下界Φu,v;(2)u到v的单代价最短路径集合=1,2,…,{跳数最少的路径.过滤索引的空间开销为O(n2).4.2过滤算法当查询给定起点s、终点t以及评分函数f(·)后,根据过滤索引,可以确定图中哪些顶点能够在本次查询中被安全的删除.我们首先根据s到t的单代价最短路径集合和hop计算s到t的最优路径得分的一个上界τ,τ=min{f()i,f(hop)|1id}.若=,则算法直接返回s不可到达t.对于一个顶点u,如果有τ<f(Φs,u+Φu,t),则顶点u可从图G中删去,也就是说,s到t的最优路径一定不会经过顶点u.定理1保证了该算法的正确性.定理1.给定多维代价图G、起点s和终点t以及评分函数f(·).为过滤索引中s到t的单代价最短路径集合,≠.令τ为根据计算的起点s到终点t的最优路径的一个得分上界,这里τ=minf()i,f(hop)|1i点u,如果τ<f(Φs,u+Φu,t),Φs,u和Φu,t分别为s到u和u到t的最优路径代价下界,则s到t的最优路径必定不经过u.证明.只需证明对任何一条经过u的路径p,都存在一条不经过u的路径p,有f(p)<f(p).不失一般性,令p是一条经过u的路径,p由两个片段接组成:(1)s到u的片段ps,u;(2)u到t的片段pu,t.根据最优路径代价下界的定义,我们可知Φs,ups,u和Φu,tpu,t.因此,Φs,u+Φu,tp.由函数f(·)的单调性,得到f(Φs,u+Φu,t)f(p).令p为∪ho{}p中取得最小评分值的路径,即f(p)=τ.p是s到t的一条路径,p不经过u,否则与τ<f(Φs,u+Φu,t)矛盾.显然,我们有f(p)<f(Φs,u+Φu,t)f(p).在图1中所示的多维代价图G中,我们选取评分函数f(x,y)=x2+y2.目标为计算出基于函数f(x,y)的由s到t的最优路径.我们发现路径p:s→{a→c→d→t是s到t的一条单代价最短路径,且其得分113在所有单代价最短路径中最小.因此,我们选取τ=113.根据定理1,顶点b和顶点r以及它们所连接的边可以从图G中移除.过滤后的图G只包含顶点s,a,c,d,t.算法2给出了顶点过滤算法的流程.顶点过滤算法对图中每一个顶点u都要计算f(Φs,u+Φu,t),该计算过程的时间复杂度为O(1).因此,顶点过滤算法的时间复杂性为O(n).算法2得到新的顶点集合珟VV,珟V是V中所有不可被过滤掉的顶点集合.我们计算珟V在G(V,E)上的诱导子图G(珟V),并在G(珟V)上调用算法1.实验证明,过滤算法具有十分优秀的过滤能力.5实验结果和分析5.1数据集描述和实验设置我们在两个真实的图数据集上实现了本文的算法,并与目前计算多标准Pareto最优路径的最有效方法进行了比较.所有实验均在主频为2.5GHz的IntelCorei5CPU和内存为8GB的PC机上完成.我们使用的操作系统为Windows7.我们采用两个真实数据集进行算法性能测试.Californiaroadnetwork:本数据集描述的是美国加利福尼亚州道路交通网,包括21047个顶点和21692条边.该网络是一个无向图.本数据来自http://www.maproom.psu.edu/dcw.Slashdotdataset:Slashdot是一个技术新闻网站.本数据集中,用户代表顶点,顶点u到v的边代表用户u赞同用户v的评论.本数据包括20639个顶点和87627条边.该网络是一个有向图,本数据来自http://slashdot.org/.针对以上数据集中的每一条边,我们随机生成d(∈{2,…,5})维代价.对每一组数据集,我们分别生成规模为1000的查询集合,实验中的结果,是每个查询集合的平均值.我们选取评分函数f(x,y)=x2+y2.我们在实验中主要考察了以下几方面的内容:(1)图中代价维度d对算法性能的影响;(2)各个优化策略对算法性能的影响;(3)过滤算法对算法性能的影响.算法性能考察的指标为:(1)算法运行过程中访问的搜索树节点个数;(2)算法执行时间;(3)过滤算法过滤的顶点比例和运行时间.我们与SHARC算法进行了比较.SHARC算Page9法是目前计算多标准Pareto最优路径最有效的方法[10].我们先利用SHARC计算出起点到终点的全部Pareto路径,再分别计算这些Pareto最优路径在函数f(x,y)下的评分并找到评分最优的路径.5.2实验结果Exp-1:代价维度对算法性能的影响.我们考察了搜索树中被算法访问的节点数量和算法运行时间与代价维度d的关系.我们考察的算法有:BASIC、OPT和FILTER-OPT.BASIC是只应用了基本剪枝策略的分支界限法,OPT是应用了优化剪枝策略以及快速计算和更新阈值策略的分支界限法,而FILTER-OPT是应用了顶点过滤算法的OPT算法.图3给出了Californiaroadnetwork上的结果.图3(a)中,我们发现搜索节点数量随着d的增长而缓慢增长.其中,OPT增长较快,这是因为随着维度的增加,基于skyline路径的剪枝规则能力变弱.例如,2维代价下,路径p被p支配,但在3维代价下,该支配关系未必成立.FILTER-OPT增长较小,这是因为过滤算法已经过滤掉大量的顶点.通过图3(a),我们发现OPT搜索的节点数量比BASIC减少了50%以上,而FILTER-OPT搜索的节点数量比OPT减少了60%以上.因此,如图3(b)所示,FILTER-OPT的运行时间比OPT少了60%以上,而OPT的运行时间比BASIC少50%以上.图4给出了Slashdotdataset上的结果.同样地,由于FILTER-OPT采取了全部优化技术,它搜索的节点数量最少,运行时间最短,OPT次之,BASIC的性能最差.Exp-2:各个优化策略对算法性能的影响.在这部分实验中,我们分析了各个优化策略对算法性能的影响.其中,OPT是应用了全部优化策略的算法,SP是指从OPT中移除基于skyline路径的剪枝规则的算法,LB是指从OPT中移除基于最优路径代价下界剪枝规则的算法,FT是指从OPT中移除快速计算和更新阈值策略的算法.我们从搜索树上被访问的节点数量和算法运行时间两个方面考察了算法的性能.图5给出了Californiaroadnetwork上的实验结果.我们发现OPT搜索的节点数量和运行时间比其它算法都要少,这说明各个优化策略都能剪除大量的非最优解的路径.其中,基于最优路径代价下界的剪枝规则(LB)和快速计算更新阈值的策略(FT)效果最明显.在图5(c)中,我们比较了基本剪枝规则(BP)、基于skyline路径的剪枝规则(SP)和基于最优路径代价下界剪枝规则(LB)裁剪子树的能力.我们发现基本剪枝规则(BP)和基于最优路径代价下界(LB)的剪枝规则裁剪子树的能力最强.图6给出了Slashdotdataset上的实验结果.我们同样发现基于最优路径代价下界剪枝规则(LB)的剪枝能力最强.与Californiaroadnetwork不同,快速计算和更新阈值的策略(FT)的效果减弱.这是因为,与Californiaroadnetwork相比,Slashdotdataset的密度更高,因此算法可以快速探索到一条起点到终点的路径.因此,即使在算法开始阶段不计Page10算出一个初始阈值,也不会对算法性能造成明显的影响.同样地,在图6(c)中,我们发现基本剪枝规则(BP)和基于最优路径代价下界(LB)的剪枝规则裁剪子树的能力最强.Exp-3:顶点过滤算法的性能.图7给出了顶点过滤算法的效力和效率.如图7(a)所示,对Californiaroadnetwork,算法至少可过滤掉80%的顶点,对Slashdotdataset,算法至少可过滤掉60%的顶点.这是因为,Slashdotdataset的密度较高,所以其过滤效果减低.我们同时发现,过滤效果与维度d无明显关系.如图7(b)所示,顶点过滤算法具有十分优秀的时间效率,且其运行时间不受维度d影响.Exp-4:与SHARC算法的比较.我们分别在Californiaroadnetwork和Slashdot上与SHARC算法进行了比较.如图8(a)所示,在d=2时,本文算法比SHARC要快4倍以上,这是因为SHARC要计算出起点到终点的全部Pareto最优路径,而本文的算法只需要计算出一条路径.同时,我们发现SHARC的运行时间随着维度d的增加而快速增长.这是因为,随着维度的增加,Pareto最优路径的数量也急剧增长,因此在高维度下,计算Pareto最优路径的方法的效率很低.相反地,我们的方法不需要找到全部Pareto最优路径.绝大多数Pareto路径,在搜索过程中很早地从搜索树中被剪除.因此,在d=5时,我们的算法几乎100倍的快于SHARC算法.同样地,如图8(b)所示,在Slashdot数据集上,d=2时,SHARC算法与本文算法性能相近,但随着维度增加,SHARC算法的运行时间急剧增长,而我们算法的运行时间增长十分平缓.该组实验说明,计算两点间Pareto最优路径的方法并不适合于本文所要解决的问题.Exp-5:可扩展性测试.我们在人工合成数据集上测试了我们算法的可扩展性.我们生成了4个人工合成数据集,其顶点规模分别为20k,40k,60k和80k.我们分别在d=2和d=3的情况下,测试了这4个人工合成数据集上算法搜索的节点数量和算法的运行时间.图9给出了可扩展性测试的结果.我们发现,算法搜索的节点数量(图9(a))和算法的运行时间(图9(b))都随着顶点规模的增大而增加.在顶点规模为80k的情况下,本文算法的运行时间仍然小于1s,这说明本文算法在大规模数据集上仍然具有十分高效的效率.该组实验验证了本文算法具有十分优秀的可扩展性.Page116相关工作Dijkstra算法是最短路径查询的经典算法.当图的规模很大时,Dijkstra算法有着较大的时间开销.为了减小时间开销,现有工作都是先建立索引,预计算索引内部顶点间的最短路径.当查询到来后,利用索引完成查询.文献[1]提出了一种最短路径quad-tree机制,该方法预计算图中所有可能顶点之间的最短路径并用quad-tree将这些路径组织起来.然而,该方法并不适用于本文所要解决的问题.因为不同用户所给出的评分函数是不同的,针对某一用户评分函数建立的quad-tree并不能正确回答另一用户评分函数下的最优路径查询.文献[2]提出了压缩BFS-tree的概念,压缩BFS-tree利用图的对称性建立索引.文献[3]提出了TEDI方法,该方法利用树分解理论建立索引并完成最短路径查询.文献[4]基于顶点覆盖建立一个树结构索引,该索引能够达到较高的I/O效率.文献[5]考虑了标签限制下的最短路径查询问题.文献[6]提出了一种依赖查询的Landmark机制,该机制可以找到与查询点最接近的局部Landmark,并利用以该Landmark为根的最短路径树来完成查询.不幸的是,所有这些工作都利用了子路径最优的性质,即最短路径上的子路径也是最短路径.因此,无论是在建立索引过程中,还是在利用索引完成最短路径查询时,这些方法只需保存索引内部顶点间的最短路径即可,再利用这些最短路径进行连接组合得到结果.然而,在多维代价图中,最短路径子路径最优的性质并不成立,所以,这些方法都不能解决本文所提出的问题.多维代价图上的多标准Pareto最优路径计算(MCPP)问题在运筹学领域被广泛研究[9-11].给定起点s和终点t,MCPP目的是找到s到t的互不支配的全部路径,即Pareto最优路径.显然,一条Pareto最优路径也是一条skyline路径.解决MCPP的方法大多数采用的是标签法[9-10],该类方法也是基于Dijkstra算法的思想,即任意一条Pareto最优路径上的子路径也应该为一条Pareto最优路径.后续的工作[11]提出A搜索方法解决MCPP问题.这些方法需迭代地计算出全部Pareto最优路径所要经过全部顶点的Pareto最优路径,并据此计算出起点到终点的全部Pareto最优路径.MCPP与本文中定义问题的主要区别在于,MCPP要找到起点s到终点t的全部Pareto最优路径,而本文定义的问题只需找到一条在评分函数f(·)下最优的路径即可.显然,找到全部Pareto最优路径之后再计算函数f(·)下的最优路径的效率十分低下,因为绝大部分Pareto最优路径并非函数f(·)下的最优路径.此外,这些方法只是从理论上给出计算Pareto最优路径的方法,并没有从算法实际运行效率的角度设计算法和优化算法,也没有采用数据处理的优化技术.因此,这些方法需要承受较高的时间和空间开销.目前许多工作研究了图上基于最短路径的skyline查询问题[13-14].文献[13]提出了MSQ算法解决动态skyline查询问题.然而,该工作考虑的图模型仍然是单代价图模型.文献[14]解决了多维代价物流网中skyline和Top-k查询问题,图中每个顶点与查询点在不同维度上的最短路径代价作为该顶点的代价向量,然后根据该代价向量计算出skyline和Top-k结果.然而,该工作中的代价向量定义与本文不同,且查询目标不是路径,因此不能用于解决本文提出的问题.7结论本文中,我们研究了多维代价图模型下的最优路径查询问题.我们首先给出了多维代价图模型下,基于函数f(·)的最优路径查询的定义.然后,我们提出了一个best-firstsearch分支界限法并给出3个优化策略.同时,我们给出一个顶点过滤算法,该算法可以从图中过滤掉大部分不属于最优路径的顶点.最后,我们通过真实数据集上的实验验证了算法的有效性.
