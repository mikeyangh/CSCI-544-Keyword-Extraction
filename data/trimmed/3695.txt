Page1一种适合于频繁位置更新的网络受限移动对象轨迹索引丁治明(中国科学院软件研究所基础软件国家工程研究中心北京100190)摘要移动对象索引是支持海量移动对象管理的一项关键技术.目前的移动对象时空轨迹索引方法如STR-Tree、TB-Tree、FNR-Tree、MON-Tree等均直接以轨迹单元作为基本的索引记录单位,在位置更新时需要频繁地在索引中插入新的记录,从而严重地影响了数据库的总体性能.为了解决上述问题,文中提出一种网络受限移动对象的动态概略化轨迹R树索引(DSTR-Tree).DSTR-Tree将索引空间划分成等距格栅,并通过格栅单元对每一条移动对象轨迹进行概略化,然后以概略化轨迹单元为基本索引记录单位建立R树索引.由于概略化轨迹的粒度大大粗于原始轨迹,因此移动对象不需要在每次位置更新的同时触发索引更新,而仅需要在轨迹跨越当前格栅单元时才进行索引更新,从而显著地降低了索引更新的代价.实验结果表明,DSTR-Tree在移动对象数据库频繁位置更新的实际运行条件下,提供了良好的索引维护及总体查询处理性能.关键词移动对象;数据库;时空轨迹;概略化;索引1引言近年来,移动对象数据库(MovingObjectsDatabases,MOD)成为了一个热点研究领域并得到了国内外研究人员的广泛关注.移动对象数据库属于时空数据库(Spatio-TemporalDatabase)的范畴,是指对位置不断移动的物体或目标(如汽车、飞机、轮船、行人等)的动态位置及其它相关属性进行表示与管理的数据库[1].越来越多的应用要求对移动对象进行管理,而定位技术和无线通信技术的发展使得跟踪和记录移动对象的位置成为可能.在典型的移动对象数据库系统中,通常存放着海量移动对象的时空数据.例如,一个大中型城市的移动对象数目可以达到数百万甚至更多.为了支持对这些移动对象过去及当前位置的查询,有效的索引手段是需要解决的关键问题.在移动对象索引方面,人们已经进行了大量的工作,这些工作可以分为两大类:针对移动对象当前位置的索引和针对移动对象完整时空轨迹的索引.移动对象当前位置索引的典型代表是TPR-Tree[2],其基本思想是在R树索引的基础上,允许最小包容矩形(MBR)包含速度和方向等参数信息,从而使MBR能随时间参数进行变化,而不需要随着移动对象位置的变化频繁地修改索引记录.TPR-Tree提出后,人们在此基础上进行了大量的改进工作,提出了许多TPR-Tree的变种树如REXP-Tree[3]、TPR-Tree[4]、Bulk-loadingTPR-Tree[5]、HTPR-Tree[6]等.此外,文献[7-9]还针对移动对象当前位置索引中由于频繁位置更新所导致的写代价过高问题进行了优化.但是,所有上述索引均只能支持对移动对象当前时刻位置的查询,而不能支持对过去位置的查询.移动对象完整时空轨迹的索引包含了移动对象过去及当前的位置信息,因此比移动对象当前位置索引具有更为广泛的用途.这方面的研究工作又可以分为两大类:基于Euclidean空间的轨迹索引和基于交通网络的轨迹索引.基于Euclidean空间的轨迹索引以Euclidean轨迹单元为索引记录的基本单位进行索引的组织[10-13],其中每个Euclidean轨迹单元是X×Y×T空间中的一个直线段,这些直线段可以组织成R树、Quad树、GridFile等形式,从而支持对移动对象的快速搜索.上述方法的缺点在于Euclidean轨迹单元是直线,因此需要大量的轨迹单元来刻画复杂的移动对象轨迹曲线,效率较低.为了进一步提高效率,人们越来越多地转向基于交通网络的移动对象轨迹索引,并提出了多种方法[14-17].基于交通网络的移动对象轨迹索引一般采用双层结构,其中上层是一个2维的R树,用于对固定的道路网络进行索引;下层是一系列的R树,每个下层R树与一条道路相对应,用于对移动对象在该条道路中提交的轨迹单元进行索引.其中,每个轨迹单元对应于移动对象在曲线道路上的一段匀速行驶过程,可以刻画X×Y×T空间中的一个曲线段.与基于Euclidean空间的轨迹索引相比,基于交通网络的轨迹索引减少了轨迹单元的数目并降低了存储开销.尽管在移动对象轨迹索引方面人们已经取得了一些重要的进展,但是目前的索引方法还存在着诸多缺陷:(1)几乎所有的移动对象轨迹索引均以轨迹单元作为索引记录的基本单位,由于索引记录的粒度太细,每次当移动对象发生位置更新并产生新的轨迹单元时,均需要在索引中插入相应的索引记录,因此索引更新的频率等同于位置更新的频率,从而造成极大的索引更新开销;(2)目前已经提出的基于网络的移动对象轨迹索引方法均采用了双层索引结构,这种结构缺乏通用性,仅适合于在专用系统中实现,很难在通用的可扩充数据库系统(如PostgreSQL)中实现;(3)基于网络的移动对象轨迹索引仅能处理移动对象与路网匹配的情况,不能表示移动对象与路网匹配不上(如移动对象在电子地图之外的小路上行驶)的情况,缺乏灵活性.为了解决上述问题,本文提出一种新的移动对象轨迹索引方法:网络受限移动对象的动态概略化轨迹R树索引(DynamicSketched-TrajectoryR-TreeforNetwork-constrainedMovingObjects,简称DSTR-Tree).DSTR-Tree将索引空间X×Y×T划分成等距格栅,通过格栅单元对每一条时空轨迹进行概略化,并以概略化轨迹单元为基本索引记录单位建立R树索引.这种方法实际上对移动对象时空轨迹进行了粒度粗化.当发生位置更新时,如果新产生的轨迹单元没有跨越移动对象上次位置更新时所对应的格栅单元(该格栅单元称为移动对象的“活动格栅单元”),则不需要对索引进行任何修改;仅当新产生的轨迹单元跨越了活动格栅单元时才需要在Page3索引中插入新的记录,因此极大地降低了索引更新的代价,符合移动对象频繁位置更新的现实情况.此外,DSTR-Tree采用了一种典型的单层树型结构,可以轻易地在通用数据库系统如PostgreSQL中实现.最后,DSTR-Tree可以兼容移动对象在路网中和路网之外行驶的情况,具有充分的灵活性和实用性.本文第2节给出网络受限移动对象通用时空轨迹数据模型;第3节描述DSTR-Tree的基本结构及相关算法;第4节对实验结果进行分析;第5节给出相关结论.2网络受限移动对象的通用时空轨迹模型从抽象模型的角度来看,移动对象的时空轨迹对应于X×Y×T空间中的一条曲线.在移动对象数据库中,需要对上述曲线进行离散化才能被计算机处理.本节讨论时空轨迹的离散化表示方法.在移动对象轨迹的模型化方面,早期的工作采用的是直接基于Euclidean空间的表示方法[10,18],即通过X×Y×T空间中的一系列直线线段来表示轨迹.为了刻画复杂的轨迹曲线,通常需要大量的直线线段,这意味着移动对象数据库需要更多的位置更新和更多的存储空间来生成和管理这些轨迹.近几年来,越来越多的工作转向了基于路网的轨迹表示方法[15,19-20],即通过一系列基于路网的轨迹单元来表示轨迹,每个基于路网的轨迹单元刻画移动对象在曲线道路上的一段匀速行使过程.由于基于路网的轨迹单元对应于X×Y×T空间中的一段曲线,因此与基于Euclidean的表示方法相比,上述方法极大地降低了轨迹单元的数量和位置更新的代价.其缺点是无法表示移动对象与路网匹配不上的情况,如当移动对象在电子地图之外的小路或广场上行驶,或者当电子地图没有及时更新导致与实际道路不符时,均有可能出现移动对象与路网匹配不上的情况.为了克服目前移动对象轨迹模型化方法的缺陷,增加轨迹表示的通用性和灵活性,我们在本节给出一种通用的移动对象轨迹模型,作为DSTR-Tree索引的基础.该模型在主要考虑移动对象路网受限运动的前提下,兼容与路网匹配不上的特殊情况.为了讨论方便,我们假设移动对象在与路网匹配时采用文献[21]提出的基于路网的位置更新策略,即当移动对象跨越不同的道路时触发IDTLU位置更新;当移动对象的计算位置与GPS位置的差值达到规定的距离阈值ξd时触发DTTLU位置更新;当移动对象的行驶速度与上次位置更新时的速度差值达到规定的速度阈值ξs时触发STTLU位置更新;当移动对象与路网不能匹配时,采用基于固定时间间隔的位置更新策略(FTLU),即每隔规定的时间阈值ξt触发一次位置更新.此外,当移动对象的路网匹配状态发生改变(由匹配状态变成不匹配状态,或反之)时需要立刻进行位置更新.定义1(交通网络).交通网络N定义为其中,R是道路的集合,J是交叉路口的集合.定义2(道路).道路r定义为如下形式:其中,rid是道路标识;geo是该道路的地理几何形状;len是道路的长度;(jidj,posj)m所包含的各个交叉路口(见定义3)的标识以及它们在道路中的相对位置(设每条道路的总长度为1,则该条道路中的任一相对位置pos可以用[0,1]之间的一个实数表示).在上述定义中,道路的几何形状geo用一条折线pl表示,pl是由X×Y平面中的一组点所组成的序列,即其中,(x1,y1)为pl的起点,称为r的“0-端点”,(xn,yn)为pl的终点,称为r的“1-端点”.定义3(交叉路口).交叉路口j与实际交通网络中的交叉路口、道路出入口或道路端点相对应,定义为如下形式:其中jid是交叉路口的标识;loc是j的地理位置,用其(x,y)坐标表示;(ridi,posi)(1in)描述j所连接的第i条道路,其中ridi是道路标识,posi∈[0,1]是j在该条道路中的相对位置;m是j的连接矩阵,用以描述该交叉路口的各交通流之间的连通关系[19].定义4(网络位置).交通网络N中的任意一个网络位置npos可以包括两种情况:①位于某个交叉路口,此时可以直接以交叉路口的标识jid表示;②位于道路中,此时可以用其所在的道路标识rid及在该道路中的相对位置pos表示.因此网络位置npos定义为Page4npos=jid,npos位于交叉路口定义5(移动对象的运行矢量).移动对象mo在t时刻的运行矢量犿狏定义为其中,t是采集该运行矢量的时刻;(x,y)、v、d分别是移动对象在t时刻的位置、速度、方向;npos是犿狏对应的网络位置(当移动对象的位置与道路网络匹配不上时,npos取空值).在犿狏的各个参数中,t,(x,y),v,d是由GPS采样得到的,而npos是通过路网匹配得到的.如果npos为空,则犿狏称为Eulidean运行矢量;如果npos有具体的网络位置匹配值,则犿狏称为路网匹配的运行矢量.定义6(移动对象的时空轨迹).移动对象mo的时空轨迹traj是mo在行驶过程中通过位置更新操作所生成的一组运行矢量的序列,用以描述mo的位置随着时间变化的过程,定义为如下形式traj=(犿狏i)n一条时空轨迹可以看成是若干个轨迹单元(见定义7)所组成的序列,对应于X×Y×T空间中的一条曲线.图1给出了一个移动对象在路网中的行驶过程及对应得时空轨迹曲线.图1移动对象的行驶过程以及对应的时空轨迹移动对象的轨迹是通过位置更新操作得到的.目前已经提出了多种不同的位置更新方法[21-24].在位置更新中,移动对象原始提交的参数一般包含运行矢量中的t、(x,y)、v、d,而npos的匹配可以在移实际的当前位置及历史行驶过程;动对象端或者在服务器端完成.移动对象在行驶的过程中不断采集新的运行矢量并将之发送给服务器,因此服务器上保存的轨迹是不断增长的.每隔一段时间(如两个星期),数据库需要对轨迹数据进行转储,并生成新的移动对象关系表.一个理想的位置更新方法需要同时保证如下两个条件:(1)所生成的时空轨迹应精确地刻画移动对象(2)所生成的时空轨迹应包含尽可能少的运行矢量(或轨迹单元),并在其生成过程中采用尽可能少的位置更新操作.定义7(移动对象的轨迹单元).时空轨迹traj=(犿狏i)n的任意两个相邻的运行矢量犿狏i和犿狏i+1(1i<n)构成一个轨迹单元,记为μ(犿狏i,犿狏i+1).此外,traj的最后一个运行矢量犿狏n也对应着一个轨迹单元,记为μ(犿狏n)(我们称μ(犿狏n)为该移动对象的活动轨迹单元).根据不同的路网匹配情况,轨迹单元μ(犿狏i,犿狏i+1)(1i<n)可以被解析成不同的几何形态:(1)如果犿狏i和犿狏i+1均为路网匹配的运行矢量,则μ(犿狏i,犿狏i+1)称为路网匹配的轨迹单元,对应于X×Y×T空间中的一条曲线线段,该曲线线段反映移动对象沿着路网从犿狏i到犿狏i+1匀速行驶的时空过程(如图1(b)中的μ(犿狏1,犿狏2)、μ(犿狏4,犿狏5));(2)如果犿狏i和犿狏i+1之一或二者皆为Eulidean运行矢量,则μ(犿狏i,犿狏i+1)称为Euclidean轨迹单元,对应于X×Y×T空间中的一条直线线段,该直线线段反映移动对象从犿狏i到犿狏i+1匀速直线行驶的时空过程(如图1(b)中的μ(犿狏2,犿狏3)、μ(犿狏3,犿狏4)).对于活动轨迹单元μ(犿狏n),其几何形状可以通过如下方式求得(设每个移动对象有一个活动状态标记activeFlag,表示其是否处于联机行驶状态):(1)如果activeFlag=false,则移动对象处于离线关闭状态,此时μ(犿狏n)为空值;(2)如果activeFlag=true,则移动对象处于活动行驶状态,此时可以进一步细分为两种情况:(2.1)如果犿狏n是路网匹配的运行矢量,则μ(犿狏n)对应于X×Y×T空间中的一条曲线线段,该曲线线段反映移动对象沿当前道路按照犿狏n中描述的速度、方向匀速行驶至道路终点(见图2(a)中μ(犿狏n)的灰色曲线部分),并继续停留在道路终点τPage5时间(见图2(a)中μ(犿狏n)的黑色垂直线部分.τ的计算方法将在下面进一步分析)的行驶过程.上述μ(犿狏n)的几何曲线反映的是移动对象在犿狏n之后的计算位置.根据文献[21-22]的分析,移动对象的计算位置在按照犿狏n中的行驶参数到达当前道路终点之后,将继续停留在道路终点.(2.2)如果犿狏n是Euclidean运行矢量,则μ(犿狏n)对应于X×Y×T空间中的一条直线线段,该直线线段反映移动对象从犿狏n开始,按照犿狏n中的速度、方向等运行参数匀速直线行驶ξt时间的行驶过程(见图2(b)).图2活动轨迹单元μ(犿狏n)对应的几何曲线通过分析可知,μ(犿狏n)所对应的上述几何曲线的时间跨度能够保证下一次位置更新之前的所有计算位置都包含在该曲线中了.如果犿狏n为路网匹配的运行矢量(见上述(2.1)),则μ(犿狏n)几何曲线的时间跨度为按照最慢可能的速度到达道路终点所需要的时间;如果犿狏n为Euclidean运行矢量(见(2.2)),则μ(犿狏n)几何曲线的时间跨度为FTLU位置更新的时间间隔.因此可以保证,在上述时间跨度用完之前,必然会有新的位置更新产生.下面讨论上述(2.1)中τ的计算方法.如图2(a)所示,活动运行矢量犿狏n为路网匹配的运行矢量.设犿狏n=(tn,(xn,yn),vn,dn,nposn),且nposn=(ridn,posn).根据犿狏n中的参数,可以计算出移动对象在tn时刻离道路终点的距离为(1-posn)×length(ridn),其中length(ridn)为道路ridn的长度.移动对象按照vn的速度行驶至道路终点所需要的时间为tnorm=((1-posn)×length(ridn))/vn,而移动对象在不触发STTLU的情况下的最慢可能速度为(vn-ξs),因此在不触发位置更新的前提下最晚到达道路终点的时间为tslow=((1-posn)×length(ridn))/(vn-ξs),所以有3DSTR-Tree索引的结构及相关算法本节首先讨论DSTR-Tree的基本结构,然后给出DSTR-Tree索引的初始建立、动态维护及查询处理算法.3.1移动对象轨迹的概略化及DSTR-Tree索引的结构为了对轨迹进行概略化,首先需要对X×Y×T空间进行格栅化.设移动对象数据库的应用时空空间为Ix×Iy×It,其中,Ix=[x0,x1],Iy=[y0,y1],It=[t0,⊥](It的终点为⊥(未定义),因为当前时刻是不断增长的).在进行格栅化时,可以将Ix划分成n个等大小的子区域,每个子区域的大小为同理可以将Iy划分成m个等大小的子区域,每个子区域的大小为对于It,由于其终点未定义,可以将之划分成大小为Δt的等长时间段,即通过上述方法,Ix×Iy×It空间被划分成了等距格栅.格栅单元用其编号(Nx,Ny,Nt)来表示,其中Nx,Ny,Nt分别为该单元在X,Y,T轴所对应的子区域编号,例如图3中右上角标记灰色的单元编号为(4,3,2).将Ix×Iy×It空间进行格栅化之后,接下来需要对轨迹进行概略化,从而形成概略化的轨迹(SketchedTrajectory).为了方便叙述,称进行概略化之前的轨迹为“原始轨迹”.定义8(移动对象的概略化轨迹).设traj=((ti,(xi,yi),vi,di,nposi))n其概略化轨迹sketch(traj)是将traj轨迹曲线所穿Page6行的格栅单元的中心点通过直线线段连接起来所形成的轨迹,定义为如下形式:sketch(traj)=(cj)k其中cj=(tj,xj,yj)(1jk)是traj所穿行的第j个格栅单元的中心点的坐标.sketch(traj)中两个相邻的中心点cj和cj+1构成一个概略化轨迹单元(Sketched-TrajectoryUnit),记为μ^(cj,cj+1),它对应于X×Y×T空间中的一条连接cj和cj+1的直线线段.注意,概略化轨迹sketch(traj)中已经包含了traj的活动轨迹单元μ(犿狏n)的概略化信息.图3给出了对Ix×Iy×It空间进行格栅化及对原始轨迹进行概略化的例子.图3时空应用区域Ix×Iy×It的格栅化及原始轨迹的概略化如图3所示,概略化轨迹用大为减少的线段近似表示了原始轨迹的几何形状.同一条原始时空轨迹所对应的概略化轨迹的单元数目取决于格栅单元的大小:格栅单元越大,则概略化轨迹的单元数目越少,反之亦然.算法1描述了根据移动对象的原始时空轨迹生成概略化轨迹的过程.其中,函数getCellLocated(犿狏)计算运行矢量犿狏所位于的格栅单元,getCellsTrav-elled(μ)计算轨迹单元μ所穿行的格栅单元序列,extractCell(cellseq,i)从格栅单元序列cellseq中提取第i个格栅单元,getCenter(cell)计算格栅单元cell的中心点坐标,|cellseq|返回格栅单元序列cellseq中所包含的格栅单元数目,apppend(sketchTraj,center)将中心点坐标center添加到sketchTraj的最后,doNothing()不做任何事情而直接返回到主程序.算法1.移动对象概略化轨迹生成算法.全局变量:Ix×Iy×It//应用空间区域输入:traj=(犿狏i)n输出:sketchTraj=((tj,xj,yj))k1.sketchTraj=NULL;2.startingCell=getCellLocated(犿狏1);3.apppend(sketchTraj,getCenter(startingCell));4.IFn=1THEN5.IFactiveflag=FALSETHEN6.Return(sketchTraj);7.ELSE8.cellsTravelled=getCellsTravelled(μ(犿狏1));9.IF(|cellsTravelled|=1)AND10.Return(sketchTraj);11.ELSE12.FORj=2to|cellsTravelled|DO13.apppend(sketchTraj,getCenter14.ENDFOR15.ENDIF16.ENDIF17.ELSE//n>118.currentCell=startingCell;19.FORi=1ton-1DO20.cellsTravelled=getCellsTravelled(μ(犿狏i,犿狏i+1));21.IF(|cellsTravelled|=1)AND22.doNothing();23.ELSE//μ(犿狏i,犿狏i+1)穿越了多个格栅单元24.FORj=2to|CellsTravelled|DO25.apppend(sketchTraj,getCenter26.ENDFOR;27.currentCell=extactCell(cellsTravelled,28.ENDIF29.ENDFOR30.IFactiveflag=TRUETHEN31.cellsTravelled=getCellsTravelled(μ(犿狏n));32.IF(|cellsTravelled|=1)AND33.doNothing();34.ELSE35.FORj=2to|CellsTravelled|DO36.apppend(sketchTraj,getCenter37.ENDFOR38.ENDIF39.ENDIF40.Return(sketchTraj);41.ENDIFPage7在算法1中,函数getCellsTravelled(μ)的返回值可以包含一个或多个格栅单元,这些格栅单元的中心点被依次添加到sketchTraj中.通过算法1可以看出,当移动对象的原始轨迹单元不跨越格栅单元时,可以直接跳过该单元而不需要做任何处理;仅当原始轨迹单元跨越一个或多个格栅单元时,才需要生成相应的概略化轨迹单元.在特殊情况下(如移动对象沿某条道路长时间匀速行驶时),原始轨迹单元可能跨越多个格栅单元,此时需要将这些格栅单元的中心连线依次加入到概略化轨迹中(见图4(b)中的情况(3)).由于算法对活动轨迹单元也进行了相同的处理(见算法1第30~39行,其中活动轨迹单元μ(犿狏n)是根据移动对象最后一次位置更新时提交的行驶参数进行预测并实体化所得到的单元,如图2所示),从而使得移动对象即使长时间不进行位置更新时,DSTR-Tree中也预先包含了相应的概略化轨迹单元.这些预先计算的、与μ(犿狏n)相对应的概略化轨迹单元需要在下一次位置更新时进行调整和重新预测(见算法3).图4分析了在处理一个新的轨迹单元μ时会出现的3种典型情况,其中标记灰色的单元是currentCell所对应的格栅单元.在3种典型情况中,(1)和(2)较为常见,而(3)仅在偶然的情况下才会出现,这是因为格栅单元的粒度通常远大于轨迹单元的粒度,所以不会经常出现μ跨越3个或更多格栅单元的情况.通过图4可以看出,在DSTR-Tree中,选取合适的格栅单元大小是至关重要的.如果格栅单元过小,则会频繁地出现一个原始轨迹单元跨越多个格栅单元的情况,从而使得格栅化得不偿失;反之,如果格栅单元过大,又会导致索引块中无用记录增多,并进一步导致元组求精时间的增加.为了获得良好的总体性能,在确定格栅单元大小时,可以参照原始轨迹单元的大小按比例放大,使得一个格栅单元能够平均容纳φ个原始轨迹单元.根据具体的系统情况,φ可以取不同的值(φ还可以取小数,如1.5),见本文的实验部分.例如,设系统中移动对象的平均位置更新时间间隔为30s,平均速度为60km/h,30s对应的行驶距离为500m,所以原始轨迹单元的平均大小为500m×500m×30s.如果取φ=5,则格栅单元的大小可以确定为2500m×2500m×150s.在完成Ix×Iy×It空间的格栅化和原始时空轨迹的概略化之后,以每个概略化轨迹的各个轨迹单元为基本索引记录单位建立R树索引,即可得到DSTR-Tree.图5给出了DSTR-Tree的结构.在图5中,DSTR-Tree叶子结点中的记录项结构为〈MBR,PTmo,stu〉,其中stu为概略化轨迹单元,MBR为该概略化轨迹单元的最小包容矩形,PTmo为指向实际移动对象记录的指针或记录标识.中间结点的记录项为〈MBR,PTnode〉,其中MBR包含下层结点所有记录的最小包容矩形,PTnode是指向下层结点的指针.3.2DSTR-Tree索引的初始建立算法在移动对象数据库中初始建立DSTR-Tree索引时,需要对数据库中的每条时空轨迹进行概略化,并将概略化轨迹中的每个轨迹单元逐一插入到DSTR-Tree中.算法2给出了DSTR-Tree的初始建立算法.在DSTR-Tree对数据库中的轨迹数据进行处理的同时,移动对象数据库还会继续接收到新的位置更新消息.这些新位置更新消息被暂时缓存在buffer中,等数据库中的轨迹数据被处理完毕之后,再调用动态维护算法(算法3)处理这些新收到Page8的位置更新消息.算法2.DSTR-Tree的初始建立算法.输入:MObjs//移动对象的集合输出:dstrTree//DSTR-Tree1.dstrTtree=NULL;2.buffer=;3.asynExec(receiveLUMsg(buffer));4.FOREACHmo∈MObjsDO5.sketchTraj=skecth(mo.traj,mo.actviveflag);6.FOREACHskecthTrajUnit∈getUnits(sketchTraj)7.insert(dstrTree,indexRec(mo.id,8.ENDFOR9.ENDFOR10.WHILEbuffer≠DO11.lumsg=getLUMsg(buffer);12.IFnotIndexed(lumsg)THEN13.调用算法3根据lumsg对dstrTree进行维护;14.ENDIF15.ENDWHILE16.Return(dstrTree).在算法2中,函数asynExec(func)通过启动另一线程异步地执行函数func,receiveLUMsg(buffer)接收位置更新消息并存入到buffer中,getUnits(sketchTraj)返回sketchTraj中的所有轨迹单元所组成的集合,indexRec(moid,stu)根据移动对象标识moid和概略化轨迹单元stu生成相应的索引记录,getLUMsg(buffer)从buffer中取出(同时从buffer中删除)一个位置更新消息,notIndexed(lumsg)判断lumsg是否在相应的移动对象被处理之前已经写入其原始轨迹中了,这种情况下lumsg的信息已经包含在dstrTree中了,不需要再进行处理.需要注意的是,概略化轨迹及概略化轨迹单元仅在建立索引和维护索引的过程中使用,并不需要永久地保存在数据库中.3.3DSTR-Tree索引在位置更新时的动态维护算法在DSTR-Tree索引初始建立之后,当发生位置更新时,不仅需要在数据库中将新的运行矢量附加到轨迹中,而且还需要对DSTR-Tree进行动态维护.由于移动对象在行驶过程中不断地通过位置更新操作向数据库服务器发送新的运行矢量,因此其时空轨迹是随着新的运行矢量的加入而不断增长的.当原始轨迹的增长导致概略化轨迹的变化时,就需要同时对DSTR-Tree索引进行相应的修改.更具体地说,对于一个活动移动对象mo,设其原始时空轨迹为traj=(犿狏i)ndi,nposi))n((tj,xj,yj))k行矢量犿狏u时,需要将犿狏u附加到traj中.上述过程对应着原始轨迹的几何曲线的变化(见图6),部分情况下原始轨迹的变化也导致概略化轨迹的变化,此时需要对DSTR-Tree进行相应的修改.但由于概略化轨迹单元的粒度远大于原始轨迹移动单元的粒度,大部分情况下犿狏u加入到traj中不会对sketch(traj)造成任何改变,此时就不需要对索引进行任何修改.图6在发生位置更新时移动对象原始轨迹几何曲线的改变数据库服务器在接收到一个位置更新消息时对DSTR-Tree索引进行维护的过程如算法3所示.在该算法中,函数getTrajectory(moid)根据移动对象的标识在数据库中检索指定移动对象的轨迹(为了加快检索速度,可以基于轨迹数据建立以moid为关键字的B+树索引),final(traj)提取轨迹traj的最后一个运行矢量,getCellsTravelledExt(μ1,μ2,…)计算轨迹单元序列μ1,μ2,…所穿行的格栅单元序列,getSTUnits(cellseq)返回格栅单元序列cellseq对应的所有轨迹单元所组成的集合.在算法3中,cellsTravelledold是原活动轨迹单元μ(犿狏n)所穿过的格栅单元的序列,如〈cell3,Page9cell4〉.cellsTravellednew是μ(犿狏n,犿狏u)和μ(犿狏u)所穿行的格栅单元序列,如〈cell3,cell5,cell4〉如果二者不相等,则需要对DSTR-Tree进行调整,通过插入unitsInsert,并删除unitsDelete,可以将DSTR-Tree调整为与新概略化轨迹相对应的状态.算法3.位置更新时DSTR-Tree索引的维护算法.输入:LUMsg=(moid,t,(x,y),v,d,npos);1.犿狏u=(t,(x,y),v,d,npos);2.犿狏n=final(getTrajectory(moid));3.cellsTravelledold=getCellsTravelled(μ(犿狏n));4.cellsTravellednew=getCellsTravelledExt(μ(犿狏n,犿狏u),5.IFcellsTravelledold=cellsTravellednewTHEN6.doNothing();7.ELSE//概略化轨迹发生了变化8.unitsInsert=getSTUnits(cellsTravellednew)-9.unitsDelete=getSTUnits(cellsTravelledold)-10.FORskecthUnit∈unitsDeleteDO11.delete(dstrTree,indexRec(moid,skecthUnit));12.ENDFOR13.FORskecthUnit∈unitsInsertDO14.insert(dstrTree,indexRec(moid,skecthUnit));15.ENDFOR16.ENDIF在移动对象数据库中,每次收到一个新的位置更新消息LUMsg时,均需要将LUMsg插入到相应移动对象的轨迹中,同时调用算法3对索引进行维护.由于概略化轨迹的粒度远大于原始轨迹的粒度,大部分情况下算法3并不需要对索引作任何修改(见第5~6行),从而有效地降低了索引更新的代价.3.4基于DSTR-Tree的移动对象查询处理算法理方法.设有任一查询Q,其查询区域为本节分析基于DSTR-Tree的移动对象查询处其中Qx=[q0x,q1x],Qy=[q0在处理上述查询时,需要首先对查询区域range(Q)进行格栅化,即要将查询区域修正为以格栅单元的中心作为区域的起止点,如图7所示(为了方便叙述,称range(Q)为原始查询区域).在图7中,移动对象的原始轨迹和原始查询区域range(Q)相交,因此该移动对象理应作为索引的查询结果输出.但是,由于在DSTR-Tree中存放的是概略化轨迹,且该概略化轨迹与查询区域range(Q)并不相交,因此如果不对查询区域进行格栅化,则会漏检该移动对象.通过分析可知,由于所有经过相应格栅单元的原始轨迹都被映射到格栅单元的中心了,因此只要查询区域包含了格栅单元的中心即不会产生漏检.对查询区域格栅化的目标即是保证所有其原始轨迹与原始查询区域相交的移动对象,必然有其概略轨迹与格栅化查询区域相交.下面以Qx=[q0x,q1x]的变换为例,分析查询区域格栅化的过程.对q0x和q1x分别进行如下变换,可以将其起始点分别对应到相应格栅单元的中心:相应的变换,从而得到格栅化之后的查询区域.类似地,可以对Qy=[q0注意,格栅化之后的查询区域尽管在形式上表示为一个矩形区域,但由于区域的起始点可以相等,因此实际上可以对应于X×Y×T空间中的一条直线或者一个点.Page10在完成上述变换之后,可以根据格栅化后的查询区域对DSTR-Tree进行查询,得到一组候选移动对象的集合(见算法4中的filterResult).然后系统对filterResult中的移动对象按照查询条件逐个进行计算,并输出满足查询条件的移动对象作为最终查询结果.基于DSTR-Tree的查询处理算法如算法4所示.在该算法中,函数gridCenterAlign(range)对查询区域range进行格栅化,evaluate(moTuple,Q)根据查询Q对元组moTuple进行计算,如果元组不满足查询条件则返回NULL;否则返回查询计算的结果.算法4.基于DSTR-Tree的移动对象查询处理算法.输入:查询Q,其查询区域为range(Q)=Qx×Qy×Qt;输出:refineResult//Q的查询处理结果1.filterResult←Search(dstrTree,2.refineResult=;3.FOREACHPTmo∈filterResultDO4.moTuple=getTuple(PTmo);5.IFevaluate(moTuple,Q)≠NULLTHEN6.refineResult=refineResult∪个阶段:7.ENDIF8.ENDFOR9.Return(refineResult).如算法4所示,基于DSTR-Tree的查询分为两(1)索引筛选(Filtering)阶段,通过DSTR-Tree索引筛选出查询区域所对应的移动对象集合filterResult(该集合大于实际满足查询条件的移动对象集合);(2)元组求精(Refinement)阶段,对filterResult集合中包含的移动对象的数据库元组进行查询计算,并将最终结果refineResult返回给查询用户.通过算法4可以看出,数据库系统查询处理的总时间却取决于索引筛选时间和元组求精时间.其中,索引筛选时间又受到索引更新代价及索引查询代价的双重影响.通过分析可知,系统中格栅单元的粒度越大,则索引更新的代价越低,而filterResult中包含的无用记录越多,导致元组求精的代价越大;反之,系统中格栅单元的粒度越小,则filterResult中包含的无用记录越少,元组求精的代价也越小,但是索引更新的代价却越高,也会间接影响总体查询性能.由此可见,为了达到最佳的总体查询性能,需要选择合适的格栅单元粒度.4实验比较与分析在“基于路网的移动对象数据库及交通流统计分析系统(NMOD-TFSA)”[25]中,我们实现了本文提出的DSTR-Tree索引模块.NMOD-TFSA是在PostgreSQL8.2.4数据库内核及其空间数据扩展PostGIS的基础上实现的一个移动对象数据库系统,支持完整的空间数据类型、交通网络数据类型、移动对象时空轨迹数据类型以及丰富的时空查询与位置更新操作.NMOD-TFSA系统的结构如图8所示.图8NMOD-TFSA移动对象数据库系统的结构DSTR-Tree是在PostgreSQL所提供的通用索引框架GIST的基础上实现的.GIST是一个可扩充的通用树形索引框架,通过开放相应的索引记录结构定义以及排序、插入、删除、查询等函数,可以实现用户自定义的单层树形索引结构,如R树、R树等.由于DSTR-Tree是一种典型的单层树形结构,因此可以通过GIST无缝地在PostgreSQL中实现,这是与其它基于路网的移动对象索引相比所具有的优点之一.MON-Tree[15]、FNR-Tree[14]、NDTR-Tree[17]等均采用了双层结构,因此无法直接在GIST中实现.为了分析相关索引的性能,我们将DSTR-Tree与目前主流的移动对象轨迹索引方法进行了比较.由于已经提出的移动对象轨迹索引方法如STR-Tree、TB-Tree、MON-Tree、NDTR-Tree等均以原始轨迹单元作为索引记录的基本单位,因此它们在位置更新时具有相同量级的索引更新频率;此外,由于MON-Tree和NDTR-Tree采用双层结构,不能Page11在PostgreSQL中基于GIST直接实现,而DSTR-Tree的主要设计目的之一即通过单层通用的索引数据结构(详见第1节),来克服双层索引结构不易在通用DBMS中实现且无法兼容路网之外移动对象的局限,因此本文选择上述方法中最具有代表性的单层索引TB-Tree作为比较对象.由于TB-Tree是基于Euclidean空间的,而DSTR-Tree可以同时兼容Euclidean运行矢量和基于路网的运行矢量两种情况,为了保证实验结果的公正性,在实验中强制规定DSTR-Tree和TB-Tree均处理完全相同的基于Euclidean的轨迹,从而使得二者在相同的位置更新频率下进行比较和分析.此外,TB-Tree只能处理移动对象的历史轨迹信息,不能依据活动轨迹单元信息对当前位置进行估算.为了使之能对当前位置进行预测计算处理,将活动轨迹单元的插入与修正过程(见第3.3节)也加入到TB-Tree中.实验中的交通网络数据采用的是北京市的真实GIS地图数据(为了实验方便,我们仅选择了三级以上的道路),并通过一个数据转换程序,将GIS数据转换成了本文所定义的格式.移动对象的轨迹数据则采用了北京星通联华交通科技有限公司提供的北京市出租汽车GPS历史数据,通过一个回放程序重新再现移动对象的位置更新及轨迹生成过程.实验的硬件平台是GenuineIntel(R)CPU2140处理器,1.6GHz主频,1GB内存,运行Linux操作系统.表1列出了实验中的主要参数.参数名称参数值(单位)Nmo1000~9000NroutesNjunctsLon-range116.125~116.625地图的经度范围Lat-range39.75~40.083Duration10800(s)每一轮模拟持续的时间ξ65(s)tuSize1000m×1000m×65s原始轨迹单元平均大小φ2~10cellSizetuSize×φ(φ=2~10)DSTR-Tree进行空间划分时的在实验数据集中,原始轨迹单元的平均大小大约为tuSize=1km×1km×65s.DSTR-Tree格栅单元的大小取其φ倍,如当φ=5时,格栅单元的大小为cellSize=5km×5km×325s.为了实验方便,统一取φ为2、4、6,即比较cellSize分别取值为2km×2km×130s、4km×4km×260s、6km×6km×390s时的实验结果.总操作数来表示);在实验中比较的性能指标包括:(1)索引更新代价(以索引记录插入和删除的(2)索引所占用的存储空间大小;(3)数据库的查询处理时间;(4)数据库的查询处理时间与格栅单元大小之间的关系.索引更新代价的实验结果如图9所示.从图中可以看出,DSTR-Tree在各种参数条件下的索引更新代价都低于TR-Tree.由于DSTR-Tree加大了索引记录的粒度,不需要像TB-Tree那样在每次位置更新时都要往索引中写入新记录,因此减少了索引更新的次数.另外可以看出,DSTR-Tree的格栅粒度越大其索引更新代价越低,因为移动对象仅在其时空轨迹跨越格栅单元时才需要进行索引更新.图10给出了索引存储空间消耗的实验结果.从图中可以看出,DSTR-Tree在各种参数条件下的索引存储空间普遍低于TB-Tree.这是因为DSTR-Tree索引以概略化轨迹单元为索引记录的基本单位,而TB-Tree以原始轨迹单元为索引的记录单位.对于同一个移动对象,其概略化轨迹单元的数目远小于原始轨迹单元的数目,因此DSTR-Tree的记录数比TB-Tree要少,索引存储空间也小于TB-Tree.图11是移动对象数据库在频繁位置更新的动态运行条件下进行查询处理的时间.如前所述,查询处理时间由索引查找时间和元组求精时间组成.为了显示查询处理各阶段时间的细节,在图11(a)和图11(b)分别给出索引查询时间和元组求精时间的实验结果,在图11(c)中给出总体查询处理时间.Page12从图11(a)可以看出,DSTR-Tree的索引查找时间总体上低于TB-Tree,这是因为一方面TB-Tree比DSTR-Tree要大,因此索引查找需要扫描图11DSTR-Tree与TB-Tree的性能比较为了更好地分析查询响应时间与格栅单元大小的关系,变化φ的取值,从而得到格栅大小与查询响应时间的关系如图12所示(实验中移动对象的个数固定为5000个).更多的记录;另一方面,TB-Tree在索引查找的同时需要处理频繁的索引更新操作,而DSTR-Tree的索引更新代价要小得多.如图11(b)所示,总体上讲,DSTR-Tree的元组求精时间也少于TB-Tree.尽管TB-Tree比DSTR-Tree具有更高的准确率(即filterResult中包含的无用记录少),但是这一优势被频繁的索引更新操作抵消掉了.从图11(c)可以看出,在频繁位置更新的条件下,DSTR-Tree比TB-Tree具有更快的动态查询处理时间.查询处理时间是索引查找时间与元组求精时间之和,再加上一些额外的开销,它同样极大地受到索引更新代价的影响.此外,从图中还可以看出,DSTR-Tree的查询响应时间与格栅的大小不呈单调关系.从图中可以出看,在本文的实验环境下,当格栅大小是原始轨迹单元大小的4倍(即φ=4)时,系统能达到最佳的总体查询性能.格栅单元大小的选择与实验环境密切相关,通常的影响因素包括数据库Page13图12查询响应时间与格栅单元大小的关系服务器的读写负荷比例、元组求精计算速度、数据库写速度等.综合以上分析,与TB-Tree等以移动对象原始轨迹单元为基本索引单位的索引方法相比,DSTR-Tree在移动对象数据库频繁位置更新的现实动态运行条件下具有更好的总体性能.5结论移动对象索引是支持海量移动对象管理的一项关键技术.然而,目前的移动对象轨迹索引方法如STR-Tree、TB-Tree、FNR-Tree、MON-Tree、NDTR-Tree等均以轨迹单元作为索引的基本记录单位,每次位置更新的同时需要进行一次索引更新,从而极大地增加了索引更新的代价,限制了数据库系统所能支持的移动对象的规模.此外,现有的网络受限移动对象的轨迹索引只能支持移动对象与路网完全匹配的情况,且采用双层结构,缺乏必要的灵活性,影响了它们在实际应用系统中的广泛使用.为了解决上述问题,本文提出了一种网络受限移动对象的动态概略化轨迹R树索引(DSTR-Tree).DSTR-Tree以移动对象的概略化轨迹单元作为索引记录的基本单位,当移动对象不跨越格栅单元时不需要对索引进行更新,因此降低了索引更新的代价,有效地提高了移动对象数据库的动态查询性能.此外,DSTR-Tree采用典型的单层树形结构,可以无缝地在通用数据库框架如PostgreSQL中实现.最后,DSTR-Tree能够同时支持移动对象在路网内和在路网之外移动的情况,具有充分的灵活性和实用性.实验结果表明,DSTR-Tree在实际移动对象数据库频繁位置更新的现实条件下,提供了优秀的索引维护及总体查询处理性能.致谢感谢中国科学院软件研究所的郭黎敏博士在NMOD-TFSA系统实现及DSTR-Tree索引实验方面所作的大量工作!
