Page1时间依赖代价函数下的最优路径查询问题研究杨雅君高宏李建中(哈尔滨工业大学计算机科学与技术学院哈尔滨150001)摘要作者研究了时间依赖图下,具有时间限制的费用代价最优路径的查询问题.目前有关时间依赖图上的最短路径查询的研究工作解决的是最短旅行时间问题(TDSP),这些工作都利用了以下性质:到达某个顶点的最早时刻可以通过到达其邻居的最早时刻计算得出.然而,在计算具有时间限制的费用代价最优路径时,该性质并不成立.因此,目前解决TDSP问题的方法均不能解决文中面对的问题.对此作者提出一个新的算法用于计算时间依赖图模型上的满足时间限制的费用代价最优路径.该算法适用于有向图和无向图.作者证明了算法的时间复杂度和空间复杂度分别为O(knlogn+mk2logk)和O((n+m)k).最后,作者通过真实数据集上的实验,验证了该算法的有效性.关键词时间依赖图;代价函数;最优路径1引言图模型被广泛地用来刻画现实世界中各种各样实体间的复杂关系,如交通网、生物信息学、XML数据库以及社交网络等等.随着信息技术的发展,各个应用领域的信息量都呈现了爆炸性增长趋势.因此,图模型数据的规模也变得越来越大.最短路径查询Page2是图上一类经典的查询问题并有着重要的应用.目前,大多数的最短路径查询都是定义在静态图上的.然而,在现实应用中,图模型往往不是固定不变的,而是随着时间发生着演绎与变化.例如,在交通网中,很多的交通管理系统能够向用户提供实时的交通信息.这些系统包括:车辆信息和通信系统(VICS)和欧洲交通信息频道(TMC).VICS被应用于日本的城市交通管理,TMC则被广泛应用于欧洲、北美和澳大利亚的城市交通管理.这些交通系统所管理的交通网都可以被刻画为大规模的图数据模型.在这些模型中,通过一条边(道路)的代价不是一成不变的,而是会随着时间的变化而变化.因此,如何在与时间相关的动态图模型上计算最短路径,就成为了一个有着十分重要研究意义的问题.我们考虑物流网中的一个应用.快递公司需要从城市A运输一批货物到城市B,假设出发时间为t1,且客户要求在时刻t2之前收到货物.在该物流网中,通过每条公路有一个时间开销和价格开销.根据时间开销我们可以计算某条路径p是否满足时间限制,即是否能在时刻t2之前到达城市B.满足时间限制的路径可能有很多,因此,从这些满足时间限制的路径中,找到价格花费最少的路径,是一个有着十分重要应用意义的问题.一个交通物流网可以刻画为一个大规模图模型.图模型上的边(道路)可以用时间代价wi,j和费用代价fi,j(t)来描述.时间代价表示通过这条边所需要花费的时间,费用代价表示通过这条边所要花费的费用(金钱).对图中的任意一条边(vi,vj),通过(vi,vj)的费用代价fi,j(t)会随着vi上的出发时刻t的变化而变化,即fi,j(t)为出发时刻t的函数.我们称这样的图模型为时间依赖图模型.因此,上面的查询问题可以表示为:给定起点vs和终点ve,最早出发时刻td和最晚到达时刻ta,计算一条由vs到ve的路径p,该路径p需要满足两个条件:(1)时间限制.即要求路径p在时刻td之后从vs出发,在时刻ta之前到达ve;(2)在所有满足条件(1)的路径中,路径p的通行费用总和最小.目前,关于时间依赖图上的最短路径查询问题(Time-DependentShortestPath,TDSP)已经有了很多的研究工作[1-6].然而,这些工作主要解决的是最短旅行时间问题,即给定一个出发时刻t0,计算一个最早到达终点的时刻并找到其对应的路径;或者给定一个出发时间区间T,找到一条最优路径,其出发时间ts∈T,使得从起点vs到终点ve的旅行时间总和最小.这些工作仅仅假设图中的边只存在一个时间代价函数wi,j(t),即通过图中某条边的时间和该边起点上的出发时刻有关.在用时间代价函数刻画边上代价的时间依赖图模型中,我们用ti表示到达顶点vi的最早时刻,则ti满足以下递归关系:ti=min{tj+wj,i(t)|vj∈N-(vi)}.vj∈N-(vi)表示vj是vi的入边邻居,tj表示vj的最早到达时刻.该递归关系表示:顶点vi的最早到达时刻可以根据其入边邻居的最早到达时刻计算得出.目前,解决TDSP问题的研究工作都利用了这一性质.然而,在费用代价函数存在的时间依赖图模型上,该关系并不成立(详见2.2节).因此,目前解决TDSP问题的方法均不能解决本文面对的问题.运筹学领域中的一些工作研究了时间依赖图上的费用代价最优路径查询问题[7-11].然而,这些工作假定时间模型是离散的.在离散时间模型下,时间区间被表示为一系列离散时间点的集合[t1,t2,…,tT].对图上任意一条边(vi,vj),用户只能选择在某个给定时刻ti从vi出发.这些工作的主要问题有:(1)离散时间模型下不能找到精确的最优解.比如用户在时刻t到达顶点vi,ti-1<t<ti,ti-1和ti是给定离散时间区间内的两个相邻的离散时间点.用户能选择的通过边(vi,vj)的最早出发时刻为ti.然而,可能在时刻t出发才会使得通过边(vi,vj)的代价最小,这里t<t<ti;(2)这些方法只是从理论上给出计算最优路径的方法,并没有从提高算法实际运行效率的角度来设计算法和优化算法,也没有应用数据处理中的优化技术.所以,这些方法需要承受较高的时间和空间开销.因此,运筹学领域中的这些工作并不能很好解决本文所要面对的问题.本文中,我们研究了时间依赖图模型上的满足时间限制的费用代价最优路径的查询问题,本文中的时间模型是连续的,且允许存在等待时间以期待找到费用代价最小的路径.本文的主要贡献如下:(1)给出了一个新的算法计算时间依赖图模型上的满足时间限制的费用代价最优路径.该算法适用于有向图和无向图.(2)证明了算法的时间复杂度为O(knlogn+mk2logk),空间复杂度为O((n+m)k),这里n和m分别为图中顶点和边的数量;k为到达时间-最小代价函数上的分段区间数量(详见3.1节).(3)通过真实数据集上的实验,验证了我们算法的有效性.本文第2节介绍问题定义、现有的最有效的方Page3法以及它们存在的主要问题;第3节介绍如何计算时间限制下的费用代价最优的路径,该算法分为两个阶段:最小费用代价计算阶段和路径选择阶段;第4节通过真实数据集上的实验验证方法的有效性;第5节讨论相关工作;最后,总结本文.2问题定义本节中,将介绍时间依赖图的定义和时间依赖图上的具有时间限制的费用代价最优路径查询问题的定义.2.1时间依赖图模型的概念定义1.时间依赖图.时间依赖图是一个有向图,记作GT(V,E,W,F),其中V={vi}是图上的顶点集合;E=V×V是图上的边集合;W是边上的时间代价取值集合;F是边上的费用代价函数集合.对图中每条边(vi,vj)∈E,存在一个时间代价wi,j∈W和一个费用代价函数fi,j(t)∈F.wi,j是一个常数,它表示通过边(vi,vj)所要花费的时间.fi,j(t)是一个分段常量函数,fi,j(t)的直观意义是:如果在时刻t从顶点vi出发,则通过边(vi,vj)所要花费的费用代价为fi,j(t).无向图可以转化为有向图,即一条无向边等价于两条方向相反的有向边.本文中我们假设通过图中任意一条边的时间代价wi,j0.该假设是合理的,因为在现实世界中,不存在小于零的时间开销.类似地,我们假设fi,j(t)在任意时刻t的取值为正值,因为现实世界中不存在小于零的费用开销.本文中,fi,j(t)定义为分段常量函数,其形式如下:这里,[t0,tp]是函数fi,j(t)的定义域;常数ck为函数fi,j(t)在时间片段[tk-1,tk]上的取值.对fi,j(t)的分段常量假设是合理的.现实世界中费用代价函数取值是分段常量的情况十分普遍.比如,道路网中的某一条公路,在每天不同的时间区间内的收费标准不同.因此,通过该公路的费用代价函数即是一个分段常量函数.给定起点vs和终点ve,最早出发时刻td和最晚到达时刻ta,本文的目的是找到一条路径p,使得(1)p在时刻td之后离开vs,且在时刻ta之前到达ve;(2)在所有满足条件(1)的路径中,p的费用代价总和最小.给定一条路径p,其到达终点ve的费用代价与时间有关.对于任意一条边(vi,vj)∈p,离开vi的时刻不同,通过边(vi,vj)的费用也就不同.因此,路径p的费用代价也不同.本文中,允许等待时间,即到达顶点vi后,允许在vi等待一段时间ω(vi),以期待路径p的费用代价更小.下文中,我们用arrive(vi)和depart(vi)分别表示到达vi的时刻和离开vi的时刻.对vi∈V,有令路径p=v1→v2→…→vh,给定最早出发时刻td,和顶点vi上的等待时间ω(vi),有因此,给定最早出发时刻td和顶点vi上的等待时间ω(vi),对路径p上的每个顶点vi,沿路径p到达vi的代价costp(vi)可递归的定义为costp(v1)=0,costp(v2)=costp(v1)+f1,2(depart(v1)),…costp(vh)=costp(vh-1)+fh-1,h(depart(vh)).我们定义路径p的代价cost(p)=costp(vh).下面,我们给出时间依赖图上最优路径查询问题的定义.定义2.时间依赖图上的具有时间限制的费用代价最优路径查询问题.给定一个时间依赖图GT(V,E,W,F),起点vs,终点ve,最早出发时刻td和最晚到达时刻ta.时间依赖图上具有时间限制的费用最优路径查询问题的目的是找到一条路径p以及p上每个顶点vi的最佳等待时间ω(vi),使得(1)depart(vs)td∧arrive(ve)ta;(2)cost(p)在所有满足条件(1)的vs到ve的路径中最小.图1给出了一个时间依赖图的示例,图1(a)是一个时间依赖图GT,该图包含4个顶点和5条边.边(vi,vj)上的数字表示该边的时间代价wi,j,即通过边(vi,vj)要花费的时间.图1(b)~(f)分别给出了边(v1,v2),(v1,v3),(v2,v3),(v2,v4)和(v3,v4)的费用代价函数fi,j(t).给出一个图GT上的费用最优路径查询,vs=v1,ve=v4,td=0,ta=60,则费用最优路径为p:v1→v2→v3→v4,在顶点v1,v2和v3上的最佳等待时间分别为ω(v1)=0,ω(v2)=5和ω(v3)=0,路径p的代价为cost(p)=20.Page4图1时间依赖图GT2.2现有方法介绍及存在问题分析目前,时间依赖图模型上的最优路径查询问题主要集中于解决最短旅行时间的问题(TDSP)[1-7],即给定出发点vs、目的点ve和出发时间区间I,找到一条由vs到ve的最优路径和最佳出发时间ts∈I,使得该路径的旅行时间最短.在该类问题中,通过任意一条边(vi,vj)的时间wi,j(t)会随着vi的出发时刻t的变化而变化,wi,j(t)是一个与离开vi时刻有关的函数.我们将介绍两种计算最短旅行时间路径的最有效的方法,并分析这些方法为什么不能用于本文所要面对的问题.A算法.文献[3]提出了一种基于A算法的扩展算法KDXZ.KDXZ算法的思想是利用优先队列来维护所有待扩展的路径.假设pi为一条从起点vs到顶点vi的路径,需要注意的是,vs到vi可能存在许多条路径,这些路径可能同时被维护在优先队列中.每一条vs到ve的路径的旅行时间代价可以用以下函数计算:fpi(t)=gpi(t)+di,e-t.这里,gpi(t)表示在时刻t离开vs,并沿路径pi到达vi的时刻;di,e是一个估计的vi到ve的旅行时间下界,di,e=decu(vi,ve)/vmax,decu(vi,ve)表示vi和ve之间的欧氏距离,vmax表示网络中的最大速度.fpi(t)表示在时刻t离开vs,并沿路径pi到达ve的估计时间开销.每一次迭代中,算法从队列中挑选一条路径pi,使得mint{fpi(t)}在被队列维护的所有路径中最小.算法在路径pi末尾加入边(vi,vj)得到一条新路径pj,并将pj加入到优先队列.当vs到ve的路径pe第一次从队列中弹出时,算法终止.KDXZ算法不允许等待时间的ω(vi)存在.KDXZ算法主要存在3方面的问题:(1)KDXZ算法需要两点间的欧式距离和网络中的最高速度来估计旅行时间开销的下界.然而,在本文面对的问题中,边上的费用代价函数是任意的,且费用代价与时间开销不同,无法通过“距离/速度”的公式估计.因此,KDXZ算法无法用于本文的问题;(2)KDXZ算法的效率取决于所估计的下界对搜索空间的裁剪能力.然而,在大规模图上,KDXZ算法很难计算出一个较准确的下界.当图的规模很大,或者起点和终点的距离很远时,KDXZ算法的效率很低;(3)在最坏情况下,KDXZ算法可能要枚举每一条起点到终点的路径并将其维护在优先队列中.因此,KDXZ算法的时间和空间复杂度是图中顶点规模的指数级.2S算法.文献[5]中提出了目前解决TDSP问题的最有效算法2S,该算法基于Dijkstra算法的思想.2S算法主要分为:(1)最早到达时刻函数计算阶段;(2)路径选择阶段.在阶段(1),算法根据以下公式计算最早到达时刻函数:gi(t)=minvj∈N-(vi),ω(vj)gi(t)是一个与出发时刻t相关的函数,它表示在时Page5刻t离开起点vs的所有路径中,到达顶点vi的最早时刻.N-(vi)表示顶点vi的入边邻居集合,即N-(vi)={vj|(vj,vi)∈E}.算法用优先队列维护图中所有顶点vi的最早到达时间函数gi(t)和一个时间区间[ts,τi].gi(t)在区间[ts,τi]内的取值是准确的.当顶点vi从队列中弹出时,算法根据式(1)来更新函数gi(t)和区间[ts,τi].若更新后的时间区间[ts,τi]≠I,I为给定的出发时间区间,则算法将vi重新插回队列.当终点ve的最早到达时间函数ge(t)在整个区间I内取值确定后,算法结束.在阶段(2),算法根据ge(t),找到起点vs到终点ve旅行时间最短的路径.该算法的时间复杂度为O((nlogn+m)α(T)),n为图GT中顶点数量,m为图GT中边的数量,α(T)为更新ge(t)和区间[ts,τe]的次数.2S算法是一个两阶段搜索算法,它存在的主要问题有:(1)2S算法的核心是利用式(1)计算最早到达时间函数.然而,式(1)所蕴含的关系在本文所面对的问题中并不成立.我们用例子说明.图1中,目标为计算v1→v4的代价最小的路径.对顶点v4的入边邻居v3,我们发现到达v3的最小费用代价为g3(15)=5,即在时刻15离开v1,通过边(v1,v3)到达v3的费用代价最小(费用为5).此时,到达v3的时刻为30.因此,根据式(1),通过顶点v3到达v4的最小费用代价为g3(15)+w3,4(30)=5+35=40.显然,该结果是错误的.因为,从v1出发,通过顶点v3到达v4的最优路径为v1→v2→v3→v4,其费用代价为20.造成该问题的原因是:一条费用代价最优路径上的子路径未必是费用代价最优的.考虑一条vs到vi的费用代价最小的路径pi,vj为vi的入边邻居,vs到vj的费用代价最小的路径为pj,沿pj到达vj的时间为tj.此时,可能存在另外一条vs到vj的路径pj,其到达vj的时间为tj,pj的费用略微大于pj的费用,但在时刻tj后通过边(vj,vi)的最小费用远远大于在时刻tj后通过边(vj,vi)的最小费用,即min{wj,i(t)|ttj}min{wj,i(t)|ttj}.因此,式(1)不能通过到达顶点vj的最小费用计算出到达顶点vi的最小费用.如图1例中,v1到v4的最优路径为v1→v2→v3→v4,其子路径v1→v2→v3并不是v1到v3的最优路径;(2)该算法的更新次数α(T)没有上界保证,如果对图中顶点估计的最早到达时间函数不准确,α(T)取值可能很大,从而影响了算法的效率.综上所述,与TDSP问题不同,费用代价最优路径并不具备子路径最优的性质,因此解决TDSP问题的方法并不能解决本文所要面对的问题.运筹学领域中的一些工作研究了时间依赖图上的具有时间限制的费用代价最优路径问题[7-11].然而,这些工作中假定时间模型是离散的.在离散时间模型中,时间区间被表示为一系列离散时间点的集合[t1,t2,…,tT].给定图中任意一条边(vi,vj),用户只能选择在某个给定时间点ti离开vi.这些工作的主要问题有:(1)在离散时间模型下无法找到问题的最优解.例如,假设在时刻t到达顶点vi,ti-1<t<ti,这里ti-1和ti是给定离散时间区间内的两个相邻的离散时间点.离散时间模型下,通过边(vi,vj)离开vi的最早时刻为ti.然而,在时刻t出发才能使得通过边(vi,vj)的代价最小,这里t<t<ti,离散时间模型无法取到时刻t,因此也就不能找到费用最优的路径;(2)这些方法只是从理论上给出计算费用最优路径的方法,并没有从提高算法实际运行效率的角度来设计算法和优化算法,也没有应用数据处理中的优化技术.因此,这些方法需要承受较高的时间和空间开销.本文中,我们给出了一种有效的计算时间依赖图上具有时间限制的费用代价最优路径的算法,该算法是一个两阶段搜索算法.在第1阶段,我们计算起点vs到达终点ve的最小费用代价(详见3.1节和3.2节).在第2阶段,我们根据第1阶段的结果,找到起点vs到ve的最优路径和路径上每个点的最佳等待时间.我们算法的时间复杂度为O(knlogn+mk2logk),空间复杂度为O((n+m)k).3两阶段搜索算法在本节中,我们提出一个有效的两阶段搜索算法.首先介绍如何根据顶点vj的到达时间-最小代价函数更新其邻居vi的到达时间-最小代价函数;然后,介绍算法的第1阶段,即计算起点vs到终点ve的最小费用代价;再次,介绍算法的第2阶段,即如何根据起点vs到终点ve的最小费用代价,找到满足时间限制的vs到ve的费用最优路径和路径上每个顶点的最佳等待时间;最后,分析算法的时间复杂度和空间复杂度.算法1给出了两阶段搜索算法的流程.算法1.两阶段搜索算法.Two-Step-Search(GT,vs,ve,td,ta)输入:依赖图GT,起点vs,终点ve,最早出发时刻td,最Page6输出:费用代价最优路径p,p上各点等待时间ω(vi)1.Computing-ge(t)(GT,vs,ve,td,ta);2.ifge(t)≠then3.Path-Selection(ge(t),GT,vs,ve,td,ta);4.returnp,ω(vi)foreachvi∈p;5.elsereturn.3.1更新到达时间-最小代价函数首先介绍什么是到达时间-最小代价函数.给定时间依赖图GT,对任意一个顶点vi∈GT,在时刻td之后离开起点vs,并且在时刻t到达顶点vi的路径p可能存在很多,我们用Ps,i,td(t)表示这些路径的集合.用gi(t)表示所有这些路径中的最小代价,即需要注意的是,路径p上允许等待时间的存在,只要路径p能够满足出发时刻和到达时刻的要求,即满足departp(vs)td,表示路径p在时刻td之后离开起点vs;arrivep(vi)=t,表示路径p在时刻t到达顶点vi.gi(t)是一个随着t变化的函数,我们称之为顶点vi的到达时间-最小代价函数,它反映了在时刻t到达顶点vi所要花费的最小费用.引理1.给定时间依赖图GT,若图中任意一条边上的费用代价函数fi,j(t)是分段常量函数,则对vi∈V,vi的到达时间-最小代价函数gi(t)也是分段常量函数.证明.因为用代价函数fi,j(t)是分段常量函数,gi(t)的取值为路径所经过边上各个常量值的求和,因此,gi(t)也为分段常量函数.证毕.下面,介绍如何计算gi(t).令顶点vj是顶点vi的一个入边邻居,即vj∈N-(vi).假设gj(t)已知,我们可以根据gj(t)更新gi(t).更新过程分为两步:(1)计算gj→i(t),gj→i(t)表示:通过顶点vj到达顶点vi的到达时间-最小代价函数;(2)利用gj→i(t)更新gi(t).显然,如果不允许等待时间的存在,即ω(vj)=0,则有该公式的意义如下:如果在时刻t-wj,i到达顶点vj,其最小费用代价为gj(t-wj,i).因为ω(vj)=0,所以需要立即离开顶点vj,此时通过边(vj,vi)的费用为fj,i(t-wj,i).因为通过边(vj,vi)的时间开销为wj,i,所以通过顶点vj且在时刻t到达顶点vi的最小费用代价为gj(t-wj,i)+fj,i(t-wj,i).本文中,我们允许存在等待时间ω(vj),以期待在时刻t,gj→i(t)能取到最小的费用代价.因此,gj→i(t)=gj(t-wj,i)+fj,i(t-wj,i).gj→i(t)=mint,ω(vj){gj(t)+fj,i(t+ω(vj))}这里,t+ω(vj)为离开顶点vj的时间,即在时刻t到达顶点vj后,等待ω(vj)时间后再离开顶点vj.因此,当在时刻t到达顶点vj后,如果要保证在时刻t到达顶点vi,则需要选取合适的等待时间ω(vj),满足t=t+ω(vj)+wj,i.在允许等待时间存在的情况下,给定时刻t,计算gj→i(t)的问题等价于找到一个最优的t和ω(vj),满足t-wj,i=t+ω(vj),使得式(2)中gj→i(t)最小.给定到达顶点vi的时刻t,离开顶点vj的时刻也就被确定为t-wj,i.因此,此时通过边(vj,vi)的费用代价也就被确定为fj,i(t-wj,i).根据gj→i(t)的定义,我们知:gj→i(t)=mintt-wj,i根据以上式(3),计算gj→i(t)等价于找到最优的时刻t,tt-wj,i,使得gj(t)最小,也就是说,对于每一个出发时刻t-wj,i,我们只需找到一个与fj,i(t-wj,i)对应的最优gj(t),并与fj,i(t-wj,i)求和即可.我们给出一个有效的算法计算函数gj→i(t).给定顶点vj的到达时间-代价函数gj(t),gj(t)的定义域为[λj,ta].λj为在时刻td离开vs,能够到达顶点vj的最早时刻,也就是说,当在最早出发时刻td从起点vs出发时,我们不可能早于时刻λj到达顶点vj.进一步地,通过顶点vj到达顶点vi的最早时刻为λj→i=λj+wj,i.我们只需计算gj→i(t)在区间[λj→i,ta]内的取值即可.对于边(vj,vi)的费用代价函数fj,i(t),只需考虑fj,i(t)在区间[λj,ta-wj,i]内的取值即可.因为当离开顶点vj的时刻晚于ta-wj,i时,不可能在最晚到达时刻ta前到达顶点vi,所以也不可能在最晚到达时刻ta前到达终点ve.算法2.更新算法.Updating-gi(t)(gi(t),gj(t),fj,i(t))输入:gi(t),gj(t),fj,i(t)输出:gi(t)1.αj←ta-wj,i;2.whileαj≠λjdo3.gαj←min{gj(t)|tαj};4.φαj←min{t|gj(t)=gαj,tαj};5.foreachtimesub-interval[tx-1,tx][φαj,αj]do6.gj→i(t+wj,i)=fj,i(t)+gαj;7.αj←φαj;Page78.gi(t)←min{gi(t),gj→i(t)};9.returngi(t).算法2给出了计算gj→i(t)的流程.我们用[λj,αj]表示fj,i(t)的未处理区间,即区间[λj,αj]内的fj,i(t)没有找到最优的gj(t)使得式(3)取值最小.初始化阶段,αj=ta-wj,i.算法1不断更新未处理区间[λj,αj],当fj,i(t)在全部时间区间[λj,ta-wj,i]内都找到对应的最优gj(t)时,gj→i(t)在区间[λj→i,ta]内的取值即被确定,算法结束.值,即我们用gα初始化阶段,由于gj(t)为分段常量函数,令φαj为tαj条件下使得gj(t)取值为gαφαj实质上是gj(t)在取值为gα端点.因此,gα应的最优gj(t).我们考虑代价函数fj,i(t)在区间[φαj,αj]内的取值.因为fj,i(t)为分段常量函数,所以fj,i(t)在区间[φαj,αj]内也是分段常量函数.不失一般性,我们设fj,i(t)在区间fj,i(t)内分为q个子区间[t0,t1],[t1,t2],…,[tq-1,tq],这里,t0=φαj,tq=αj.假设fj,i(t)在子区间[tx-1,tx]内取值为cx,则gj→i(t)在区间[tx-1+wj,i,tx+wj,i]内的取值为j.cx+gα需要注意的是,为了方便讨论,本文假设gj(t)和fj,i(t)上的所有分段区间均为闭区间.开区间存在时,我们的方法仍然有效.对gj(t),当gα时间区间为开区间时,φαj取值为该开区间的左端点即可.在计算gj→i(t)时,如果gαfj,i(t)上的子区间的一端为开区间,则计算出的gj→i(t)在对应区间上的对应一端也为开区间.当在区间[φαj,αj]内的fj,i(t)都找到其对应的最优gj(t)后,gj→i(t)在区间[φαj+wj,i,αj+wj,i]内的取值即计算完毕.此时,我们令αj←φαj,并在区间[λj,αj]内重复以上过程.当φαj=λj时,意味着区间[λj,αj]内的fj,i(t)均可找到对应的最优gj(t),因此,我们可计算出gj→i(t)在区间[λj+wj,i,αj+wj,i]内的取值.至此,gj→i(t)在全部区间[λj→i,ta]内的取值计算完毕,算法结束.我们用图2中的例子说明gj→i(t)的计算过程.如图2所示,图中实线代表函数fj,i(t)在区间[λj,ta-wj,i]内的取值,图中虚线代表函数gj(t).初始化阶段,αj=ta-wj,i.当tαj时,gj(t)的最小取值为gααj,即此时φαj=φ1为φ1αj,ta-wj,i]内找到对应的最优gj(t),我们可根据[φ1j和fj,i(t)在区间[φ1gαgj→i(t)在区间[φ1在区间[φ115+10=25.第2次迭代中,算法2将αj更新为φ1此时,tαj下能取到gj(t)的最小值gα应的φαj为λj.因为φαj=λj,算法2在区间[λj,φ1内找到fj,i(t)对应的最优gj(t)为gα将gj→i(t)在区间[λj→i,φ1j+fj,i(t)=20+10=30.此时,在全部区间gα[λj,ta-wj,i]内,fj,i(t)都找到与之对应的最优的gj(t),进而函数gj→i(t)在全部区间[λj→i,ta]的取值也计算完毕,算法结束.下面,我们给出定理证明算法2的正确性.定理1.给定时间依赖图GT,vi,vj∈GT且vj∈N-(vi).令gj(t)为顶点vj的到达时间-最小代价函数,则算法2计算的gj→i(t)是在此gj(t)下最优的,即如果顶点vj的到达时间-最小代价函数为gj(t),则对t∈[λj→i,ta],gj→i(t)是所有通过顶点vj并且在时刻t到达顶点vi的路径中最小的费用代价取值.证明.不失一般性,对t∈[λj→i,ta],令j→i(t)为通过顶点vj并且在时刻t到达vi的最小费g用代价.我们只需证明gj→i(t)=gj→i(t)为最优的费用代价,所以有gggj→i(t).下面,我们证明gj→i(t)gj→i(t)和gj→i(t)所代表的路径都是在时刻t到达g顶点vi,所以他们离开顶点vj的时刻均为t-wj,i,从而他们通过边(vj,vi)所花费的费用也均为fj,i(t-wj,i).由gPage8和其中,g代表的路径中到达顶点vj时的花费的费用代价,t和t分别为其到达顶点vj的时刻.显然,我们有tt-wj,i和tt-wj,i.根据算法2可知,gj(t)选取的是tt-wj,i条件下函数gj(t)能取得的最小函数值,因此,我们有gj(t)ggj→i(t)g定理1说明了算法2得到的gj→i(t)是最优的.令gi(t)为顶点vi上现有的到达时间-代价函数(可能不是最优的),可以根据gj→i(t)来更新gi(t).对t∈[λj→i,ta],有由于gi(t)和gj→i(t)均为分段常量函数,在对应的每个时间子区间内,只需取gj→i(t)和gi(t)的最小值作为更新后gi(t)的函数值即可.图3中的例子展示了如何更新gi(t).图3(a)中,虚线为gj→i(t),实线为现有的gi(t).我们发现在区间[5,15]内,gj→i(t)取值为20,小于gi(t)取值.因此,区间[5,15]内的gi(t)取值更新为20.区间[25,30]和[30,35]内gj→i(t)取值分别为15和20,均小于gi(t).因此,区间[25,30]内gi(t)更新为15,区间[30,35]内gi(t)更新为20.图3(b)中给出了更新后的gi(t)函数.gi(t)=min{gj→i(t),gi(t)|t∈[λj→i,ta]}.在本节中,我们介绍算法1的第1阶段,即如何3.2计算到达终点的最小费用代价计算起点vs到终点ve的最小费用代价.3.2.1计算到达终点的最小费用代价预处理阶段,我们需计算起点vs到图中任意顶点vi的最早到达时间λi.考虑仅以时间代价wi,j为权值的图GT,我们在GT上运行现有最快的单源最短路径算法,即可计算出到达各个顶点vi的最小时间代价.将该时间代价与最早出发时刻td相加,即可计算出各个顶点vi的最早到达时刻λi.目前,最快的单源最短路径算法的时间复杂度为O(nlogn+m).我们用ge(t)表示终点ve的到达时间-最小代价函数ge(t)在区间[λe,ta]上的最小值,则ge(t)即为满足时间限制的起点vs到终点ve的最小费用代价.本节的目标即是计算ge(t).算法3给出了计算ge(t)的流程.对图中任意顶点vi,我们用Ti表示顶点vi最早-最晚到达时刻区间,即Ti=[λi,ta].算法3逐步地更新区间[λi,ta]内的函数gi(t).我们用Si表示gi(t)已确定取值的区间,用τi表示当前的gi(t)在Ti-Si上的最小取值.算法3.最小费用代价计算算法.Computing-ge(t)(GT,vs,ve,td,ta)输入:时间依赖图GT,起点vs,终点ve,最早出发时刻输出:ge(t)1.gs(t)←0;τs←0;Ss←Ts2.QbethepriorityqueueinitiallycontainingV;vi←vs;3.whilevi≠vedo4.Let[tai,tbi]bethetimeslotτicorrespondingto;5.gi(t|t∈[tai,tbi])←τi;Si←Si∪[tai,tbi];6.foreachvj∈N+(vi)do7.Updating-gj(t)(gj(t),gi(t),fi,j(t));8.τj←min{gj(t)|t∈Tj-Sj};9.ifSi≠Tithen10.τi←min{gi(t)|t∈Tj-Sj};11.enqueue(Q,vi);12.vi←dequeue(Q);13.ge(t)←τi;14.returnge(t).初始化阶段,对于起点vs,其gs(t)、Ss和τs被初始化为gs(t)←0,Ss←Ts,τs←0.显然,如果从起点vs出发,则在任何时刻t到达起点vs的最小费用代价均为0.因此,函数gs(t)在全部区间上是一个取值为零的常数.对于其它任意顶点vi≠vs,其gi(t)、Si和τi分别被初始化为gi(t)←,Si←,τi←.这意味着在任何区间上都没有确定函数gi(t)的取值.我们使用一个优先队列Q维护图中的顶点.优先队列Q根据τi的取值由小至大地弹出队列中的顶点.初始阶段,队列Q包括全部顶点vi∈V.当终点ve第1次从队列Q中弹出时,算法结束.在每次迭代中,τi取值最小的顶点vi从队列Q中弹出.令τi取值对应的区间为[tai,tbi].因此,顶点vi的到达时间-最小代价函数gi(t)在[tai,tbi]上的取Page9值即为τi.这一事实我们将在下面给出定理证明.我们将区间[tai,tbi]加入顶点vi的已确定区间集合Si来更新Si,即Si←Si∪[tai,tbi].然后,对顶点vi的所有出边邻居vj∈N+(vi),根据算法2更新区间[λi→j,ta]内的gj(t).同时,算法更新τi.当算法更新完顶点vi的所有出边邻居vj的gj(t)后,算法判断gi(t)的取值是否在全部区间上已经被确定,即是否Si=Ti.如果Si=Ti,则函数gi(t)在全部区间Ti=[λi,ta]内的取值已经确定,这说明gi(t)在任意时刻t∈Ti的取值不可能被更新得更小.因此,我们可以将顶点vi从队列Q中移除.如果Si≠Ti,我们则计算当前gi(t)在区间Ti-Si内的最小值τi,并将顶点vi重新插回队列Q中.这里注意的是:当前的gi(t)不一定是最优的,当顶点vi的入边邻居从队列Q中弹出时,gi(t)可能会被更新,同时,τi也会被更新.当终点ve第1次从队列Q中弹出时,ve对应的τe是即函数ge(t)在全部区间[λe,ta]上的最小取值ge(t)(此事实我们将给出定理证明).因此,起点vs到终点ve的最小费用代价ge(t)已经被计算出来,图4图1例中到达时间-最小代价函数更新过程第2次迭代中,我们发现顶点v3在未确定区间T3-S3上的最小取值为τ3=5.τ3取值在队列Q中最小,因此顶点v3被弹出.如图4(b)所示,我们发现τ3=5对应的取值区间为[30,60],因此,区间[30,60]内的g3(t)取值即被确定为5.我们将区间[30,60]加入S3,即此时S3=[30,60].顶点v4为顶算法终止.3.2.2例子演示说明我们用图1中所示的例子来演示运算过程.在该例中,我们给出费用最优路径查询,该查询中,vs=v1,ve=v4,td=0,ta=60.首先利用现有的最短路径算法计算出GT中各个顶点v1,v2,v3,v4的最早到达时间:t1=0,t2=10,t3=15,t4=25.因此,函数g1(t),g2(t),g3(t)和g4(t)的取值区间分别为T1=[0,60],T2=[10,60],T3=[15,60]和T4=[25,60].图4给出了计算起点vs到终点ve的最小费用代价的过程.初始化阶段,优先队列Q仅包含起点v1,其对应的τ1=0,S1=T1,g1(t)=0.这意味着,在任何时刻t∈T1,到达v1的费用代价为0.因为,从v1到v1不需要花费任何费用.当v1从队列中弹出后,对v1的两个出边邻居v2,v3,算法分别计算g1→2(t)和g1→3(t),并更新g2(t)和g3(t).g2(t)和g3(t)在本次迭代后的取值如图4(a)和图4(b)所示.顶点v2和v3插入队列.因为S1=T1,即g1(t)在全部区间上的取值已经确定,所以,v1从队列Q中移除.点v3的出边邻居,我们计算g3→4(t)并更新g4(t).本次迭代后的g4(t)在图4(c)中给出.顶点v4插入队列.此时,g3(t)的未确定取值区间变为T3-S3=[15,30],且当前g3(t)在T3-S3上的最小值为20.因此,τ3被赋值20,顶点v3被重新插回队列Q中.第3次迭代中,顶点v2在未确定区间T2-S2内Page10的最小取值为τ2=10.τ2取值在队列Q中最小,因此顶点v2被弹出.如图4(a)所示,我们发现τ2=10对应的取值区间为[10,60],因此,g2(t)在全部区间T2上的取值即被确定为10.顶点v3和顶点v4为顶点v2的两个出边邻居,我们分别更新g3(t)和g4(t),更新后的g3(t)和g4(t)分别在图4(d)和图4(e)中给出.此时,g3(t)在未确定区间T3-S3内的最小值τ3也被更新为15.由于g2(t)在全部区间T2上的取值已经确定,因此,顶点v2从队列Q中移除.第4次迭代中,顶点v3在未确定区间T3-S3=[15,30]内的最小取值为τ3=15,τ3取值在队列Q中最小,顶点v3被弹出.如图4(d)所示,τ3=15对应的区间为[20,30],g3(t)在区间[20,30]内的取值即被确定为15.我们将区间[20,30]加入S3.此时,S3=[20,60].g3(t)的未确定取值区间变为T3-S3=[15,20].根据当前的g3(t)更新v3的出边邻居v4的g4(t),更新结果在图4(f)中给出.当前g3(t)在未确定取值区间[15,20]内的最小值为20,因此,τ3被更新为20,顶点v3被重新插入队列Q中.第5次迭代中,顶点v4在未确定区间T4上的最小取值为τ4=20,τ4取值在队列Q中最小,顶点v4被弹出.因为v4为终点,算法结束.起点v1到终点v4的最小代价即为20,τ4对应的时间区间为[30,35].3.2.3正确性证明下面证明算法3的正确性,我们首先给出定理2证明当顶点vi从队列中弹出时,在τi取值对应的区间内,真正的gi(t)的取值即为τi.定理2.给定时间依赖图GT,令vi为算法3第k次迭代过程中从队列Q中弹出的顶点,其τi对应区间为[tai,tbi],则顶点vi的到达时间-最小代价函数gi(t)在区间[tai,tbi]上的取值即为τi.证明.只需证明对任意时刻t0∈[tai,tbi],gi(t0)=τi即可.因为gi(t)是顶点vi的到达时间-最小代价函数,根据定义,我们可知gi(t0)τi.下面,证明τigi(t0).不失一般性,设在时刻t0到达顶点vi且费用代价为gi(t0)的路径为因此,沿着该路径p,到达顶点vx(1xh)的时刻和费用代价分别为tx和gx(tx).以示区分,我们用gkx(tx)表示在第k次迭代时顶点vx的到达时间-最小代价函数.这里需要注意的是,gkx(t)不一定等于顶点vx真正的到达时间-最小代价函数gx(t).我们首先考虑顶点vh,在第k次迭代时,gk的取值为gkgh(th);(2)gk优的到达时间-最小代价函数在时刻th的取值,则不可能出现gkfh,i(t0-wh,i)又分为两种情况:(a)fh,i(t0-wh,i)=0;(b)fh,i(t0-wh,i)≠0.在情况(a)下,若时刻th的gh(t)的取值已经被确定,则意味着顶点vh已经在h(th)时从队列Q中弹出过.因此,算法3已经τh=gkh(th)更新过gi(t)的取值.根据算法2的正确利用gk性,我们有τigk取值未被确定,则τi=gkτi,此时应该弹出顶点vh,与条件矛盾.注意:gk不可能大于τi.因为gk和gi(t0)τi,所以gk们得出τigh(th)=gh(th)+fh,i(t0-wh,i)=gi(t0).我们考虑情况(b),因为fh,i(t0-wh,i)≠0,所以h(th)=gh(th)<gi(t0).这意味着顶点vh已经在gkh(th)时从对列Q中弹出过.因此,算法3已经τh=gkh(th)更新过gi(t)的取值.根据算法2的正确利用gk性,我们有τigk因此,在情况(1)下,有τigi(t0).下面,讨论情况(2),我们证明情况(2)不可能发生.为证明此事实,我们考虑顶点vh-1,在第k次迭代时,gkh-1(th-1)同样分为两种情况:gkh-1(th-1)=gh-1(th-1)和gkh-1(th-1)>gh-1(th-1).类似证明情况(1)下的τi=gi(t0),我们证明在gkh-1(th-1)=gh-1(th-1)时,有gk因此,只需证明gkh-1(th-1)>gh-1(th-1)不可能发生.类似地,我们仅需要证明gkh-2(th-2)>gh-2(th-2)不可能发生,递归地,仅需证明gk1(t1)>g1(t1)不可能发生.因为g1(t1)在第1次迭代中,即起点vs从队列Q中弹出时已经被计算出,则gk1(t1)=g1(t1).矛盾.因此,情况(2)不可能发生.综上所述,我们得出τigi(t0).因此,τi=gi(t0).定理2说明,每次顶点vi根据τi的取值从队列Q中弹出时,vi的到达时间-最小代价函数gi(t)在τi对应区间上的取值即为τi.当算法3把全部区间上的gi(t)取值确定时,该gi(t)即为真正的gi(t).下面给出定理3证明,τi即为顶点vi的真正的gi(t)在区间Ti-Si内的最小取值.定理3.给定时间依赖图GT,令vi为算法3第k次迭代时从队列Q中弹出的顶点,gi(t)为顶点vi的真正的到达时间-最小代价函数,则此时的τi即为Page11gi(t)在区间Ti-Si上的最小值.证明.反证法.假设存在时刻t0∈Ti-Si,使得gi(t0)<τi.不失一般性,我们设在时刻t0到达顶点vi且费用代价为gi(t0)的路径为沿着该路径p,到达顶点vx(1xh)的时刻和费用代价分别为tx和gx(tx).与定理1证明类似,我们用gkx(t)表示在第k次迭代时顶点vx的到达时间-最小代价函数.gki(t0)的取值只能分为两种情况:(1)gki(t0)=gi(t0);(2)gki(t0)>gi(t0).在情况(1)下,因为gki(t0)=gi(t0)<τi,所以顶点vi会根据gki(t0)取值弹出,与条件矛盾.因此,我们只需证明情况(2)不会发生.此证明过程与证明定理1中情况(2)的过程相同.因为情况(1)下出现矛盾,情况(2)不会发生,所以假设不正确,定理得证.证毕.定理3说明了顶点vi跟据τi从队列Q中弹出时,τi即为gi(t)在未确定取值区间Ti-Si内的最小取值.因此,当终点ve首次从队列Q中弹出时,其τe即为ge(t)全部区间Te上的最小值,即起点vs到终点ve的最小费用代价ge(t).推论1.给定时间依赖图GT,对于顶点vi,设i和τqi为顶点vi第p次和第q次从队列Q中弹出τp时的τi取值,若p<q,则τp队列Q中弹出时的Si,因为p<q,所以Sp此,Ti-Spi和Ti-SqSp3.3寻找最优路径和最佳等待时间下面介绍算法的第2阶段,即如何根据最小费用代价ge(t)找到起点vs到终点ve的最优路径p,以及p上的每个顶点的最佳等待时间ω(vi),使得路径p的代价等于最小费用代价ge(t).算法4给出了计算最优路径p和最佳等待时间ω(vi)的过程.算法4的基本思想是:从终点ve开始,依次找到顶点vi在路径p上的前驱邻居顶点vj.初始化阶段,我们令vi←ve.算法4.路径选择算法.Path-Selection(ge(t),GT,vs,ve,td,ta输入:ge(t),GT,vs,ve,td,ta输出:p,p上各点等待时间ω(vi)1.vi←ve;p←;gi(ti)←ge(t);ti←t;2.whilevi≠vsdo3.foreachvj∈N-(vi)do4.iftjti-wj,i,gi(ti)=gj(tj)+fj,i(ti-wj,i)证明.令Sp5.p←p+vj;ω(vj)=ti-wj,i-tj;6.vi←vj;ti←tj;break;7.returnp,ω(vi)foreachvi∈p.每次迭代过程中,我们计算顶点vi在路径p上的前驱邻居顶点vj.设在路径p上,到达顶点vi的费用代价为gi(ti),到达顶点vi的时刻为ti.初始化阶段,gi(ti)←ge(t),ti←t.t可取为ge(t)上ge(t)取值所对应时间区间内的任意一个时刻.对于任意vj∈N-(vi),即vj为vi的入边邻居,如果tj,tjti-wj,i,使得则顶点vj为顶点vi在路径p上的前驱邻居顶点,tj为路径p上到达顶点vj的时刻.这样的vj一定存在,因为在算法3中,gi(ti)的取值是根据此gj(tj)计算得到的.因此,在顶点vj上的最佳等待时间为当算法4找到起点vs,即vi=vs时,算法结束.此时,路径p上的所有顶点和每个顶点上的等待时间均已经计算出来.我们用图1和图4中的例子说明该计算过程.从图4中,我们得知到达顶点v4的最小费用代价为g4(t)=20,其对应区间为[30,35],我们任取其中一个时刻t=30.因此对于顶点v3,离开顶点v3的时刻为t-w3,4=30-10=20.我们发现在t3=20时,g3(t3)=15,则g3(t3)+f3,4(t-w3,4)=g3(20)+f3,4(30-10)因此,顶点v3为终点v4在最优路径p上的前驱邻居顶点,且顶点v3上的最佳等待时间ω(v3)=0.第2次迭代中,因为t3=20,所以对于顶点v2,离开顶点v2的时刻为t3-w2,3=20-5=15.我们发现对于时刻t2=10,有g2(t2)=10,且满足g2(t2)+f2,3(t3-w2,3)=10+5=15=g3(t3),因此,顶点v2为顶点v3在路径p上的前驱顶点,且顶点v2上的最佳等待时间ω(v2)=5.同理,在第3次迭代中,我们找到顶点v2的前驱邻居顶点v1.因为v1为起点,所以算法结束.3.4时间复杂度和空间复杂度分析3.4.1时间复杂度我们首先分别分析算法2、算法3和算法4的时间复杂度,最后给出整体算法1的时间复杂度.设图中顶点数量和边的数量分别为n和m,图中顶点vi的到达时间-最小代价函数gi(t)的平均的分段区间数量为k.Page12引理2.算法2的时间复杂度为O(klogk).证明.算法2中,需要计算gαj,所以需要将这k个分段区间上的常数取值排序,该过程时间复杂度为O(klogk).计算φαj只需找到gαj对应时间区间的左端点即可,该操作需要O(1)的时间.在计算gj→i(t)过程中,需要计算出gj→i(t)在全部区间[λj→i,ta]内的不同分段上的取值.因此,计算gj→i(t)的过程时间复杂度为O(k).同样地,更新gi(t)的时间复杂度也为O(k).因此,算法2的时间复杂度为O(klogk).引理3.算法3的时间复杂度为O(knlogn+mk2logk).证明.算法3中的每次迭代过程中,最多有n个顶点同时被维护于队列Q中.我们利用Fibonacci堆[12],则将顶点vi弹出队列的操作需要花费O(logn)时间,而插入队列的操作需要O(1)时间.当顶点vi从队列Q中弹出后,需要更新vi的出边邻居vj的到达时间-最小代价函数gj(t).令d+(vi)为顶点vi的出度,则这一操作的时间复杂度为O(d+(vi)klogk).因此,算法3中一次迭代过程的时间复杂度为O(logn+d+(vi)klogk).由定理3和推论1可知,算法3依据gi(t)在不同分段的取值大小依次弹出顶点vi.最坏情况下,顶点vi被弹出的次数为O(k)次.因此,算法3的时间复杂度为O∑vi∈V引理4.算法4的时间复杂度为O(mk).证明.算法4的每次迭代过程中,对一个顶点vi,需要检查其所有入边邻居vj.对每一个入边邻居vj,需要检查其到达时间-最小代价函数gj(t)在tti-wj,i时,是否存在取值满足公式gi(ti)=gj(tj)+fj,i(ti-wj,i),该操作的时间复杂度为O(k).因此,每一次迭代中,对顶点vi,计算其前驱邻居顶点的时间复杂度为O(d-(vi)k).因为最优路径p上不存在环,对图中任意一个顶点vi最多计算一次其前驱邻居顶点,所以,算法4的时间复杂度(d-(vi)k(为O∑vi∈V定理4.算法1的时间复杂度为O(knlogn+mk2logk).算法1是计算起点vs到终点ve,具有时间限制的费用最优路径p和p上每个顶点vi的最佳等待时间ω(vi)的算法.证明.因为算法3和算法4是算法1的两个阶段,所以根据引理3和引理4,我们可知算法1的时间复杂度为O(knlogn+mk2logk).证毕.3.4.2空间复杂度定理5.算法1的空间复杂度为O((n+m)k).证明.算法3和算法4为算法1的两个阶段.在优先队列Q中,算法3至多维护n个顶点.对每个顶点vi,算法需要维护其到达时间-最小代价函数gi(t).对图中每条边,算法3和算法4需要维护其费用代价函数fi,j(t).因此,算法1的空间复杂度为O((n+m)k).4实验结果和分析我们在真实的数据集上实现了本文的算法,并与TCSP-AWT算法[7]进行了对比.TCSP-AWT算法是目前解决具有时间限制的费用最优路径查询的最有效的算法,TCSP-AWT算法用于计算离散时间模型下的费用最优路径.所有实验均在主频为2.5GHz的IntelCorei5CPU和内存为4GB的PC机上完成.我们使用的操作系统为Windows7.4.1数据集描述和实验设置我们在以下真实数据集上进行了算法的测试:Californiaroadnetwork.本数据集描述的是美国加利福尼亚州道路交通网,包括21047个顶点和21692条边.其中,顶点代表道路的交叉口或者道路的端点,边代表道路片段.本数据来自http://www.maproom.psu.edu/dcw.我们在该数据集上生成了4个规模不同的时间依赖图,其顶点规模分别为2K,5K,10K和20K.在这些时间依赖图上分别进行了算法测试,以考察算法的可扩展性.针对数据集中的每一条边,我们随机生成其时间代价wi,j和费用代价函数fi,j(t).对于fi,j(t),限定其定义域为[0,2000].2000表示2000个时间单位(秒或者分).将fi,j(t)的定义域随机分成k个片段,在每一个片段上赋予一个常数取值.因此,fi,j(t)为一个分段常量函数.对算法TCSP-AWT,我们每隔一个时间单位采样一个离散时间点.例如,对查询区间[0,1000],采样的离散时间点个数即为500个.对每组数据集,分别生成规模为1000的查询集合,实验中的结果,是每个查询集合结果的平均值.用TWO-STEP标记我们的算法.我们在实验中考察了以下几方面的内容:Page13(1)图中顶点数量对算法性能的影响;(2)图中边的数量对算法性能的影响;(3)起点vs和终点ve之间距离对算法性能的影响;(4)最早出发时刻和最晚到达时刻的时间区间[td,ta]对算法性能的影响;(5)费用代价函数fi,j(t)上分段区间数量k对算法性能的影响.算法性能考察的指标为:(1)算法运行时间;(2)算法运行时的内存开销;(3)每个顶点从队列中弹出的平均次数;(4)TCSP-AWT算法的相对误差,我们将其定义为(c-c)/c,这里,c为TCSP-AWT算法结果的代价,c为最优结果的代价.我们的算法基于连续时间模型,所以不存在误差.4.2实验结果实验1.顶点数量对算法性能的影响.在图5中,我们考察顶点数量对算法性能的影响.本组实验图5顶点数量对算法性能的影响实验2.边的数量对算法性能的影响.图6中,我们考察图中边的数量对算法性能的影响.本组实验中,我们固定图中顶点数量为10K,边的数量从10K变化到80K,费用代价函数的分段数量k=10,最早出发时刻和最晚到达时刻区间T=[0,1000],TCSP-AWP算法的时间点个数l=500.通过图6中,边的费用代价函数的分段数量为k=10,最早出发时刻和最晚到达时刻区间T=[0,1000],TCSP-AWP算法的时间点个数l=500.如图5(a)和图5(b)所示,我们的算法的运行时间和内存开销均远远小于TCSP-AWT算法.这是因为TCSP-AWT算法需要计算在每个时刻到达图中每个顶点的代价,并对这些代价进行组合以求得最小代价.我们的算法比TCSP-AWT算法快了20倍,内存开销少了近500倍.我们发现,算法的运行时间和内存开销都随着顶点数量的增加而增大.在图5(c)中,我们发现每个顶点从队列中弹出的平均次数与顶点数量变化无关.在图5(d)中,我们发现TCSP-AWT算法的相对误差随着顶点数量的增加而增大.这是因为,顶点规模变大时,起点和终点之间的距离增大.因此,在路径上累积的误差值就会变大.(a)和图6(b),我们同样发现,我们的算法在时间和空间上都要优于TCSP-AWT算法.图6(c)中,我们发现,随着边的数量的增加,每个顶点从队列中弹出的平均次数有所减少.这是因为,边的数量增加导致图的密度增大,进而图中任意两点之间的距离减少.因此,算法可以更快地计算出到达终点的最小费用,Page14从而减少了每个顶点的弹出次数.然而,边的数量增加,导致了顶点的邻居数增加,当顶点从队列弹出时,更新其所有邻居到达时间-最小代价函数的时间开销也就增大.因此,在图6(a)中,算法运行时间会图6边的数量对算法性能的影响实验3.起点和终点之间距离对算法性能的影响.图7中,我们研究了起点与终点之间距离变化对算法性能的影响.本组实验中,图中顶点数量为20K,起点与终点之间的距离从5变化到10.费用代价函数的分段数量k=10,最早出发时刻和最晚到达时刻区间T=[0,1000],TCSP-AWP算法的时间点个数l=500.通过图7(a)和图7(b),我们发现,算法的运行时间和内存开销对起点和终点之间距离的变化并不敏感.这是因为,起点和终点之间距离最短的路径在很多情况下并不是费用代价函数下最优的路径.与边的数量变化不同,本组实验中,图的密度没有增加,仅仅是起点和终点之间的距离发生变化.因此,在图7(c)中,顶点从队列中弹出的平均次数也没有显著变化.在图7(d)中,我们发现TCSP-AWT算法的相对误差随着起点和终点之间距离的增大而增大,其原因是,随着起点与终点之间距离增大,路径上的累积误差也会增大.随着边的数量的增加而增加.图6(d)中,我们发现TCSP-AWT算法的相对误差随着边的增加而减小.这是因为,边的增加使得起点和终点之间的距离减小,所以,路径上累积的误差也会减小.实验4.查询时间区间的距离对算法性能的影响.图8中,我们考察了查询时间区间对算法性能的影响.本组实验中,图中顶点数量为10K,最早出发时刻固定为0,最晚到达时刻从600变化到1200,因此,TCSP-AWP算法的时间点个数从300变化到600.费用代价函数的分段数量k=10.图8(a)和图8(b)中,我们的算法时间和空间开销受查询时间区间变化的影响很小.这是因为,虽然查询时间区间变大,但费用代价函数分段数量没有改变.相反地,因为查询时间区间变大,导致TCSP-AWT算法的离散时间点增多,所以,TCSP-AWT算法的时间和空间开销都增加.图8(c)中,每个顶点的平均弹出次数没有受到明显影响.图8(d)中,我们发现,TCSP-AWT算法的相对误差也没有明显变化.实验5.费用代价函数的分段区间数量对算法性能的影响.在图9中,我们研究了费用代价函数分段区间数量对算法性能的影响.本组实验中,图中顶Page15图7起点和终点间距离对算法性能的影响图8查询时间区间对算法性能的影响Page16点数量为10K,边上的费用代价函数的分段区间数量从5变化到20,最早出发时刻和最晚到达时刻区间T=[0,1000],TCSP-AWP算法的离散时间点的个数l=500.通过图9(a)和图9(b),我们发现,算法的运行时间和内存开销均随着函数分段区间数量的增加而增加.这是因为,当函数分段区间数量增加时,更新图中顶点到达时间-最小代价函数的开销增大.我们的算法在时间和空间上都要优于TCSP-AWP算法.通过图9(c),我们发现,每个顶点从队列中的弹出次数随着函数分段数量的增加而增加.这是因为,当费用函数分段区间数量增加时,顶点上图9费用代价函数分段数量对算法性能的影响5相关工作目前,关于时间依赖图上的最短路径查询问题(TDSP)已经有了很多的研究工作[1-6,13-15].然而,这些工作主要解决的是最短旅行时间问题,即在时间依赖图模型上找到一条起点到终点的路径,使得该路径的时间代价总和最小.这些工作主要分为两类,一类基于离散的时间模型,另外一类基于连续的时间模型.文献[13-15]研究了离散时间模型下的时间的到达时间-最小代价函数的分段数量也会增加.所以,顶点从队列中弹出次数也就会增加.在图9(d)中,我们发现TCSP-AWT算法的相对误差也随着函数分段数量的增加而增加.这是因为,当分段数量增加时,费用代价函数的取值数量也会增加,所以,费用代价函数取值发生变化时刻位于两个离散时间点之间的机会也就增加.当到达某个顶点时,TCSP-AWT算法无法找到通行下一条边的最优代价的机会也就增加.因此,TCSP-AWT算法的相对误差会随着函数分段区间数量的增加而增加.依赖最短路径查询.文献[14]中,图上每一条边被赋予一组聚集属性,该聚集属性表示了这条边在不同时刻所呈现的状态.文献[13]将出发时间区间平滑地离散为k个时间点,并依据这k个时间点将图中顶点和边复制k次,因此,时间依赖图被转化了一个规模增大k倍的静态图.文献[13]进而给出了如何在这个静态图上完成最短路径查询的方法.这些基于离散时间模型的方法并不能回答连续时间模型下的最短路径查询问题.文献[1-6]研究了连续时间模型下的最短路径查询问题.文献[1]提出了一种基于Page17Bellman-Ford算法思想的方法.对图中任意顶点vi,该方法迭代的计算到达顶点vi的最早时刻,并利用这些中间结果,最终计算出到达终点ve的最早时刻.最后,根据该时刻找到旅行时间最短的路径.文献[2]提出了道路网中的速度流模型,该模型下,图中每条边的通过速度可以用一个分段线性的函数表示.该文作者提出一个基于Dijkstra算法思想的方法计算速度流模型下的最快路径查询问题.文献[3]提出了一种基于A算法的扩展算法.该算法的主要思想是用一个优先队列维护所有待扩展的路径.对任意一点vi,起点vs到vi的最早到达时间函数被维护在优先队列中,该算法通过顶点vi到终点ve的欧氏距离和网络中的最大速度,预估顶点vi到终点ve的时间.算法根据预估时间弹出队列元素,并找到起点到终点的最短旅行时间路径.文献[4]介绍了如何应用数据挖掘的方法找到各种条件下描述道路通过速度的模型.文献[5]是目前最有效的解决TDSP问题的方法.该方法采用两阶段搜索策略.第1阶段,用优先队列更新图中所有顶点最早到达时间的函数,并最终计算出终点ve的最早到达时间函数.第2阶段,根据ve的最早到达时间函数找到旅行时间最小的路径.然而,这些解决TDSP问题的研究工作都利用了以下性质:到达顶点vi的最早时刻可以根据到达其入边邻居的最早时刻计算得出.然而,在计算具有时间限制的费用代价最优路径时,该性质并不成立.因此,目前解决TDSP问题的方法均不能解决本文面对的问题.运筹学领域中的一些工作研究了时间依赖图上具有时间限制的费用代价最优路径的查询问题[7-11].然而,这些工作假定的时间模型是离散的.在离散时间模型中,时间区间被离散化为时间点的集合[t1,t2,…,tT].对图上任意一条边(vi,vj),用户只能选择在某个给定时刻ti离开顶点vi.这些工作的主要问题有:(1)离散时间模型下不能找到精确的最优解;(2)这些方法只是从理论上给出计算最优路径的方法,并没有从提高算法实际运行效率的角度来设计算法和优化算法,也没有应用数据处理中的优化技术.所以,这些方法需要承受较高的时间和空间开销.因此,运筹学领域中的这些工作也不能很好地解决本文所要面对的问题.6结论本文中,研究了时间依赖图上具有时间限制的费用代价最优路径的查询问题.我们首先给出了时间依赖图模型的定义以及时间依赖图上具有时间限制的费用代价最优路径查询的定义.然后,给出了一个有效的算法计算时间限制下的费用代价最优路径.同时,证明算法的时间复杂度和空间复杂度分别为O(knlogn+mk2logk)和O((n+m)k).最后,通过真实数据集上的实验验证了算法的有效性.在后续的工作中,我们将考虑时间代价函数和费用代价函数共同作用下的最优路径查询问题,以及在时间依赖图模型上多维代价的最优路径查询问题.
