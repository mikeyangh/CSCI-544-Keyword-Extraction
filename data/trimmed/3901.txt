Page1基于相变存储器和闪存的数据库事务恢复模型范玉雷孟小峰(中国人民大学信息学院北京100872)摘要随着闪存容量不断增大、价格不断下降,闪存在实际存储系统上得到了越来越广泛的应用.但是,闪存的页级读写、异位更新、有限寿命等阻碍了闪存数据库系统的性能提升,尤其是事务恢复.闪存的异位更新使得影子页技术可以很好地支持闪存数据库事务恢复,同时也给闪存数据库带来新挑战,如事务管理、缓冲区管理.相变存储器凭借其比闪存更高的读写速度、更小的读写粒度、更长的寿命成为了下一代主流存储技术,所以相变存储器可以用于解决在闪存数据库中使用影子页技术所产生的事务管理和缓冲区管理问题.该文基于相变存储器和闪存混合式存储提出一种全新的数据库事务恢复模型———SPFP.该模型充分利用相变存储器的特性完成事务管理.为支持非强制缓冲区管理,基于SPFP提出了一种优化的数据库事务恢复模型———SPFLP,利用相变存储器记录更多事务信息.实验结果表明,相较于全闪存存储的数据库系统,SPFLP大大提高了基于混合存储的数据库事务处理性能.关键词闪存;相变存储器;数据库;事务恢复1引言随着闪存技术的飞速发展,闪存的容量在不断增大,闪存的单位价格也在不断降低,因此闪存在存储系统中得到了广泛应用,小到传感器,大到大型服务器,都充分发挥了其小巧轻便、抗震、耐高/低温、耗电量小、读写速度快等特性[1].闪存具有完全不同于磁盘的物理特性,如非对称读写、页级读写、写前擦除、异位更新、有限寿命等,所以学术界和工业界在基于闪存的数据库系统的研究方面进行了大胆尝试并取得了突出的科技成果.相变存储器(PhaseChangeMemory,PCM)是非易失随机访问存储器(Non-VolatileRandomAccessMemory,NVRAM)中的一种,同时还是具有磁盘和内存优势特性的下一代主流存储技术[2].相比于内存和闪存,相变存储器提供了很多吸引人的适合于数据库事务处理的新特性.相比于内存,相变存储器具有与内存相近的读速度,同时还具有非易失性.相比于现有的闪存,相变存储器具有高出两个数量级以上的读写速度,同时还具有细粒度的原位更新特性,并且相变存储器不具有闪存的写前擦除特性.所以研究者将要面临新的问题“如何修改数据库使其充分利用新硬件相变存储器的优势特性”[3].因此本文充分考虑相变存储器,重新审视闪存数据库的事务处理模块.在数据库管理系统中,事务恢复是数据库事务处理的一个重要模块.写前日志技术[4]和影子页技术[5]是两种经典的事务恢复技术.写前日志技术是基于磁盘的原位更新设计的,原位更新使得原有旧版本数据被覆盖,故通过记录日志来记录更新操作,在恢复过程中通过读取日志进行相应的Redo/Undo操作进而获取最准确的数据.写前日志技术在记录数据更新的同时,还需要一些特殊的日志用来记录事务状态、检查点等信息,用以完成事务恢复.由于闪存存储器多采用异位更新模式,所以写前日志技术不适用于基于闪存的数据库系统.影子页技术是基于异位更新设计的,故影子页技术可以很好地用以支持闪存数据库的事务恢复,但同时影子页技术对闪存数据库也提出了两个新的挑战———事务管理和缓冲区管理.首先,在事务执行和恢复过程中需要进行有效的事务元信息管理.其次,像磁盘数据库一样,闪存数据库系统也需要支持非强制的缓冲区管理策略,进而提高整个系统的性能.相变存储器具有内存和闪存的优势特性,如按位修改、非易失等,所以本文利用相变存储器解决影子页技术应用在闪存数据库系统中所带来的事务管理和缓冲区管理问题.由于相变存储器允许按位修改、具有与内存相当的读速度、具有比闪存高两个数量级的读写速度,所以可以使用相变存储器对事务进行管理,包括事务ID和事务状态等信息.同时为了支持非强制的缓冲区管理策略,需要对事务进行的操作进行更详细的记录和维护,比如事务操作类型和事务操作内容等.本文针对基于相变存储器和闪存的数据库系统设计了全新的事务恢复模型.总体来说,本文的主要贡献如下:(1)提出了基于相变存储器和闪存的数据库事务恢复模型SPFP,并阐述了在SPFP模型下的正常事务处理方式;(2)设计了适用于SPFP模型下的数据库故障(3)提出了支持非强制缓冲区管理的数据库事务恢复模型SPFLP,并阐述了在SPFLP模型下的正常事务处理方式;(4)设计了适用于SPFLP模型下的数据库故障恢复方法.本文第2节简单介绍闪存、相变存储器以及相关工作;第3节提出基于相变存储器和闪存的数据库事务恢复模型SPFP,并阐述事务正常处理方式、数据库故障恢复和闪存空间回收方法;在第4节,本文提出基于SPFP优化的数据库事务恢复模型SPFLP,并详细描述事务正常处理方式、数据库故障恢复方法;第5节通过实验对比分析阐述SPFP和SPFLP的性能优势;在第6节作简单总结.2研究背景及相关工作恢复方法和闪存空间回收方法;由于闪存和相变存储器都各自具有一些适合于数据库的优良特性,所以需要结合两者的优势充分提高数据库系统的性能.2.1闪存和相变存储器和磁盘一样,闪存和相变存储器都是非易失存储器.如图1所示,闪存设备由一组闪存芯片组成,每个闪存芯片内部按照块进行组织,块是闪存擦除操作的基本单元.块是由若干页组成,页是读写操作的最小单元.一个闪存页分为数据区和空闲区,数据区主要存储用户数据,空闲区主要存储校验码和逻Page3辑页地址等元信息.典型的数据页大小为2KB+64KB,其中2K为数据区,64B为空闲区.NAND闪存常用于存储数据,根据存储密度又可以把NAND闪存分为SLCNAND闪存和MLCNAND闪存[6].由于MLCNAND闪存的应用广泛性,本文意在研究基于MLCNAND闪存的数据库系统.不同于磁盘,闪存无机械组件,所以闪存具有较高的读写性能[7],并且单个请求响应延迟主要取决于数据传输的总量.由于闪存具有写前擦除等特性,异位更新常被实现在闪存转换层(FlashTransla-tionLayer,FTL)中,用于解决写前擦除的约束[8].如图1所示,闪存转换层是承接上层应用的关键组件.闪存转换层为上层提供读写接口和事务操作接口(提交、回滚和恢复).如图2所示,闪存转换层在内存维护一个直接映射表(DirectMappingTable,DMT),用于记录逻辑地址到物理地址的映射;每个闪存物理页的空闲区内的逻辑地址形成了一个反向映射表(InverseMappingTable,IMT),用于在系统启动时在内存重建直接映射表.直接映射表和反向映射表对于异位更新的实现是至关重要的.异位更新策略产生了大量的无效数据页,故在闪存转换层维护了一个垃圾回收模块,定期的或者不定期的回收无效数据页.由于闪存块具有有限的擦除次数,单个闪存块的损坏会导致整个闪存芯片不可用,所以需要在闪存转换层中维护一个磨损均衡模块,用以实现整个闪存的均匀使用.根据地址映射的粒度可以把闪存转换层分为4类:页级映射、块级映射、块页混合映射和其它[9].相变存储器采用了与闪存完全不同的材料,采用材料的晶体和非晶体两种状态来区分1和0.内存、磁盘、闪存和相变存储器的硬件性能如表1所示[3].除了非易失和高密度之外,相变存储器还具有如下特征[1-2,10]:(1)细粒度的操作.与闪存相比,它没有写前擦除和基于页的访问约束,允许按位修改和访问,所以可以像内存一样支持小粒度的原位更新;(2)非对称的读写速度.写延迟大概是读延迟的20倍;(3)有限寿命.但比闪存寿命要长,可支持106~108次写操作.参数密度读延迟(粒度)写延迟(粒度)持久性内存1X20~50ns(64B)20~50ns(64B)N/APCM2~4X~50ns(64B)~1μs(64B)106~108闪存4X~25μs(4KB)~500μs(4KB)104~105磁盘N/A~5ms(512B)~5ms(512B)2.2相关工作对于基于闪存存储器的数据库系统,事务恢复方面的工作较少.安士通等提出了基于影子页技术的事务提交策略[11],充分利用了SLCNAND闪存独有的部分页写特性.在闪存页的空闲区维护操作该数据页的事务元信息,当事务状态发生变化(事务由运行状态变为提交状态或者回滚状态),只需要更新该页的空闲区,而不需要新产生闪存页,因为SLCNAND闪存页支持多次写操作.但是SLCNAND闪存相比于MLCNAND闪存容量较低且单位容量价格较高,使得SLCNAND闪存应用范围较小.本文主要针对MLCNAND闪存进行数据库恢复研究.需要注意的是MLCNAND闪存不具有部分页写特性.在文献[12-13]中,卢泽萍等人设计了基于异位更新优化的日志结构,只记录更新前后的数据页地址,大大减小了日志存储空间.在此基础之上,作者优化了事务恢复策略,利用日志记录的新旧版本数据页地址可以进行快速恢复,同时通过Page4同一事务日志之间的链接跳读日志减少长事务的恢复时间.但是日志结构的小粒度写并不适合于页级读写粒度的闪存设备.研究人员开始重新审视基于相变存储器的系统的设计和优化.综合文献[2,14],有3种可用的基于相变存储器的层次架构:(1)相变存储器为主存的辅助存储器,外存为磁盘[2];(2)相变存储器作为主存,磁盘为二级存储设备[2];(3)相变存储器和闪存同时做二级存储设备[14].基于相变存储器存储性能考虑,使用相变存储器作为辅助存储器可能更实用.第一个原因是相变存储器具有持久性的限制,其写入延迟还稍高于DRAM.其次,在未来几年内,相变存储器性能赶不上DRAM性能.基于第1种架构,Gao等人[15]提出一种利用相变存储器减少日志代价的方法,并且在该文中仍然使用相变存储器进行数据页的缓冲.但是相变存储器的写速度距离内存的写速度仍然有两个数量级的差别,并且随着内存技术发展,内存容量也在不断增大,所以尽量充分利用内存缓存数据,使用相变存储器作为永久存储来提高整体性能.Lee等人[16]首先在2007年提出了一种基于页内日志的闪存数据库系统,即在闪存块内分为两个区———数据区和日志区.数据区用以存储用户数据页.日志区只记录当前块内数据页的更新.内存有数据缓冲区和日志缓冲区分别对应数据区和日志区.但是为了尽可能降低数据丢失,日志缓冲区的日志页要小于数据缓冲区的数据页.由于闪存只支持页级读写,日志页的读写浪费了闪存空间,所以Lee等人[14]提出了一种利用相变存储器加速页内日志的方式,数据区更新产生的日志放到相变存储器上,因为相变存储器支持小粒度的读写操作.本文针对第3种存储结构展开研究.3基于影子页的数据库恢复模型SPFP利用相变存储器维护事务元信息,在闪存数据库中实现影子页恢复技术.3.1SPFP模型框架基于影子页的数据库恢复模型SPFP的基本思想:利用影子页跟踪用户对闪存数据页所进行的更新操作,并使用相变存储器记录事务最终状态.如图3所示,闪存数据页的空闲区维护3个信息:该闪存数据页对应的逻辑地址、指向该闪存数据页前一个版本的指针和产生该闪存数据页的事务ID.事务ID是产生该闪存数据页的唯一标识.空闲区信息主要用于完成事务恢复和垃圾回收.MLCNAND闪存设备没有部分页写特性(SLCNAND闪存设备的独有特性),但是为了完成事务正常处理和恢复必须要进行事务管理,即追踪并记录事务执行的状态变化(正在执行/提交/回滚).由于相变存储器允许进行细粒度的访问和原位更新操作,所以本文借助相变存储去实现高效的数据库恢复模型.在事务回滚或者系统启动时,相变存储器的数据和闪存数据页空闲区的元数据可以用来取消事务所进行的更新和系统恢复.基于磁盘的数据库管理系统,缓冲区缓存经常访问的数据库磁盘页面.缓冲区管理策略对事务处理能力有巨大影响.在本部分,缓冲区管理策略采用Steal和强制的缓冲区管理策略.换句话说,事务提交之前允许数据页写到闪存上,并且只有事务更新的所有数据页都刷出到闪存之后才可以提交事务.但是对于缓冲区管理,我们需要做一些假设.首先,采用页级并发控制协议处理更新冲突.其次,采用写回缓冲区策略:直到事务提交或者数据缓冲页需要从缓冲区换出的时候,才在闪存上为更新操作真正创建影子页.内存数据结构有直接映射表、新映射表(NewMappingTable)和事务表(TransactionTable),如图3所示.直接映射表维护最新的已提交的逻辑地址到物理地址的映射〈LBA,PBA〉.新映射表维护当前正在运行的事务内的更新操作产生的逻辑地址到物理地址的映射〈LBA,PBA〉.事务表存储每个事务的当前状态(即运行、提交或回滚).由于采用哈希索引直接映射表,所以直接映射表中可以不实际Page5存储逻辑地址LBA.由于事务提交或者回滚之后,事务的最终状态写入到相变存储器中,所以实际上内存中只需要记录正在运行的事务ID即可.如图3所示,外存存储器主要由两个部分组成,数据存储在闪存中,事务最终状态存储在相变存储器中.对于闪存,每个闪存数据页包括一个数据区和空闲区,分别用于存储用户数据和一些元数据.空闲区元数据包括该数据页的逻辑地址LBA,产生该数据页的事务ID,指向该数据页前一个版本的指针Link(为空表示该数据页是第1个版本),通过该指针把所有版本的数据页链接起来,可记录数据页的更新历史.对于相变存储器,我们只记录每个事务的事务ID和事务的最终状态(C/A,如果为1代表事务最终提交;如果为0代表事务最终回滚).3.2正常事务处理基于SPFP模型,我们详细描述正常事务处理,包括数据页更新、事务提交和事务回滚.数据页更新.当一个事务T(ID为xid)更新逻辑地址为lpa、物理地址为ppa的数据页pp,SPFP执行以下3个步骤:(1)如果事务T不存在于事务表中,把事务T的ID及其状态〈xid,Inprogress〉插入到事务表中;(2)在闪存上创建一个影子页pp,物理地址为ppa,同时把逻辑地址lpa、产生该影子页的事务T的唯一标识xid以及该影子页前一个版本的物理地址ppa插入到该影子页空闲区的LBA、XID和Link区域;(3)把〈lpa,xid,ppa〉插入到新映射表中,用以在事务结束之后保证直接映射表的正确性.事务提交.当一个事务T(ID为xid)提交,SPFP执行以下3个步骤:(1)把〈xid,1〉写入到相变存储器中;(2)把新映射表中所有属于事务T的〈lpa,xid,ppa〉合并到直接映射表中,替换掉直接映射表中具有相同逻辑地址lpa的〈lpa,ppa〉,同时把这些〈lpa,xid,ppa〉从新映射表中删除;(3)从事务表中删除事务T.事务回滚.当一个事务T(ID为xid)回滚,SPFP执行以下3个步骤:(1)把〈xid,0〉写入到相变存储器中;(2)把新映射表中所有属于事务T的〈lpa,xid,ppa〉从新映射表中删除;(3)从事务表中删除事务T.3.3闪存空间回收当闪存设备的空闲空间低于预设的阈值,系统就会触发垃圾回收模块,回收废旧页.废旧页包括以下3种类型:未提交事务产生的数据页、回滚事务产生的数据页、提交事务产生的已过时的数据页.事务状态在识别前两种数据页的过程中起到了至关重要的作用.事务状态可以通过读取相变存储器快速获得,因为相变存储器的读速度接近于内存的读速度.对于第3种数据页,必须要结合相变存储器上存储的事务状态和闪存数据页空闲区的事务唯一标识XID以及指向前一个版本的指针Link等信息才能完成识别.垃圾回收如算法1所示.算法1.垃圾回收.FOR每个闪存数据页DOlpa,xid,link=该页空闲区LBA、XID、Link域值;ppa=该页物理地址;stat=读取相变存储器获取事务xid的状态;IFstat==0THEN释放ppa对应闪存页;把ppa加入到空闲页列表中;ELSE释放link对应闪存页;把link加入到空闲页列表.对于每个闪存数据页,首先要获取该页空闲区的元数据LBA、XID、Link的值,然后再读取相变存储器获取创建该页的事务状态.如果事务状态为0,即事务未提交或已回滚,则当前数据页无效,则可以对该数据页进行回收,并把该页地址加入到空闲页列表中以备后用.如果事务状态为1,即事务已经被提交,因为可以确保该数据页的前一个版本无效,所以可以回收link指向的闪存数据页,并把link加入到空闲页列表中以备后用.3.4数据库故障恢复遇到系统正常关机或系统故障后重启数据库时,恢复过程被触发.它意在恢复最新版本的数据页以及重建直接映射表.重建直接映射表的目的意在为用户索引到正确的数据.在恢复过程中,数据页的有效/无效识别是关键,根据3.3节描述可知无效的数据页可以通过事务状态和数据页空闲区元信息识别出来.识别出无效数据页之后剩下的就是有效数据页.然后,读取有效数据页获取地址映射信息构建直接映射表.在恢复过程中引入一个数据结构,即物理页状态位图,如图4所示.在物理页状态位图中,每一位对应一个物理页,用以标识这个物理页是有效还是无效.如果为1,对应物理页有效;如果为0,对应物理页无效.默认情况下,所有闪存数据页都是有效地,即物理页状态位图为全1.物理页状态位图只在数据库系统故障恢复时才创建使用,系统正常运行时不需要创建Page6维护.恢复过程如算法2所示.算法2.恢复.初始化PBA-bitmap为全1;FOR每个闪存数据页DOlpa,xid,link=该页空闲区LBA、XID、Link域值;ppa=该页物理地址;stat=读取相变存储器获取事务xid的状态;IFstat==0THEN根据ppa设置PBA-bitmap的相应位为0;ELSE根据link设置PBA-bitmap的相应位为0;FORPBA-bitmap中的每个位DOIF这一位为1THENppa=该位对应的物理地址;lpa=获取ppa页空闲区LBA域值;把〈lpa,ppa〉插入到直接映射表.在恢复过程之初,首先要初始化PBA-bitmap为全1,即所有闪存数据页都有效.在第1个循环中,通过读取每个闪存数据页的空闲区元数据获取创建该页的事务xid、该页对应的逻辑地址lpa和该页的前一个版本地址link,然后根据事务xid读取相变存储器获取该事务的最终状态.如果事务状态为0,即事务未提交或已回滚,则当前数据页无效,则置PBA-bitmap的第ppa位为0;如果事务状态为1,即事务已经被提交,因为可以确保该数据页的前一个版本无效,则置PBA-bitmap的第link位为0.最终获得每个闪存数据页的最终状态位图PBA-bitmap.最后,根据PBA-bitmap的每一位信息来重建直接映射表.如果位信息为1,则该位对应的ppa闪存数据页有效,读取该页空闲区的LBA信息lpa,把〈lpa,ppa〉插入到直接映射表中.虽然某些闪存数据页需要进行两次读操作,尤其是第2次读还是随机读操作,但是闪存的随机读顺序读性能都比较好,所以对于性能的影响并不是很大.4扩展数据库恢复模型SPFLP非强制缓冲区管理策略是数据库管理系统中的一种常用策略.非强制缓冲区管理允许数据页在事务提交之后刷写到外存上,进而大大提高缓冲区性能.非强制缓冲区管理策略需要在外存记录事务操作的详细信息.日志是记录事务操作详细信息的一种方式,但是日志多通过顺序写和顺序读的方式完成日志记录和事务恢复.而相变存储器支持像内存一样的随机操作,并且相变存储器具有较好的读性能,而写性能也要比闪存要好很多,所以本部分提出了一种基于SPFP的优化的能够支持非强制缓冲区管理的数据库事务恢复模型SPFLP.4.1SPFLP模型架构如图5所示,SPFLP模型与SPFP模型基本上相同,唯一的不同点在于相变存储器上的数据结构需要重新设计以达到记录事务更新操作的详细信息的目的.在SPFP中,相变存储器只需要存储事务ID和事务最终状态标识位.在SPFLP中,相变存储器不但要记录事务ID和事务最终状态,还需要记录事务内每个更新操作的操作类型(插入/更新/删除)和更新操作内容.事务内每个更新操作作为链表的一个节点,所有更新操作构成一个链表,链接到事务ID和事务最终状态信息后面.事务开始时,在相变存储器上加入一个不带事务状态的链表头.对于SPFP模型和SPFLP模型,相变存储器上的事务状态信息和闪存数据页空闲区的元信息的产生及操作过程是一样的,闪存空间回收算法仍可使用算法1,这里就不再赘述.图5支持非强制缓冲区管理的数据库恢复模型SPFLP4.2正常事务处理基于SPFLP模型,我们详细描述正常事务处理中的数据页更新和事务回滚.事务提交过程与SPFP模型中的事务提交完全相同.数据页更新.当一个事务T(ID为xid)中更新操作(操作类型为U)对逻辑地址为lpa、物理地址为ppa的数据页pp进行操作时,SPFLP执行以Page7下4个步骤:(1)如果事务T不存在于事务表中,把事务T的ID及其状态〈xid,Inprogress〉插入到事务表中;(2)在闪存上创建一个影子页pp,物理地址为ppa,同时把逻辑地址lpa、产生该影子页的事务T的唯一标识xid以及该影子页前一个版本的物理地址ppa插入到该影子页空闲区的LBA、XID和Link区域;(3)把操作类型和操作内容形成一个链表节点,然后插入到相变存储器的事务xid之后的链表中;(4)把〈lpa,xid,ppa〉插入到新映射表中,用于事务结束之后保证直接映射表的正确性.事务回滚.当一个事务T(ID为xid)回滚,SPFLP执行以下4个步骤:(1)把〈xid,0〉写入到相变存储器中;(2)把相变存储器上的xid对应的链表空间释放;(3)把新映射表中所有属于事务T的〈lpa,xid,ppa〉从新映射表中删除;(4)从事务表中删除事务T.4.3数据库故障恢复在SPFLP中仍然需要借用PBA-bitmap这个数据结构来完成数据库故障恢复,即重建直接映射表.非强制缓冲区管理策略可能导致已经提交的数据页在数据故障前未来得及刷出到闪存上,进而导致数据丢失,所以只能通过相变存储器上的事务更新操作记录来重建数据,进而获取正确的直接映射表.恢复过程如算法3所示.同算法2,要设置PBA-bitmap为全1,然后通过读取相变存储器和闪存数据页空闲区元数据可以判断数据页的有效/无效,然后根据数据页的有效无效进行其它操作.对于未提交或已回滚事务产生的数据页,则置PBA-bitmap的第ppa位为0;对于已提交数据页,同样置PBA-bitmap的第link位为0.由于ppa闪存数据页已经存在于闪存之上,所以相变存储器上的产生ppa的操作记录已经无效,所以需要把产生ppa闪存数据页的事务操作记录从相变存储器中的事务xid后的链表中删除并释放空间.算法3.恢复(SPFLP).初始化PBA-bitmap为全1;FOR每个闪存数据页DOlpa,xid,link=该页空闲区LBA、XID、Link域值;ppa=该页物理地址;stat=读取相变存储器获取事务xid的状态;IFstat==0THENELSEFOR相变存储器中的每个事务DOIF事务状态为1THENIF事务状态为0ThenFORPBA-bitmap中的每个位DOIF这一位为1Thenppa=该位对应的物理地址;lpa=获取ppa页空闲区LBA域值;如果事务状态为0,则可以完全释放该事务对应的链表节点.如果事务状态为1,则需要根据事务对应的链表中的每个节点的更新操作内容产生相应的闪存数据页,把修改前的闪存数据页对应的PBA-bitmap位置0,并且把新产生的闪存数据页对应的PBA-bitmap位置1,最后把该链表节点从该链表中删除并释放空间.最终获得正确完整的闪存数据页的最终状态位图PBA-bitmap.最后一步和SPFP模型中的相同.虽然在算法3中需要对相变存储器进行读写操作,但是相变存储器具有接近内存的读性能,并且写性能也介于内存和闪存之间,因此系统整体性能不会受到太大影响.5实验结果与分析本部分通过TPC-C[17]基准测试验证本文提出的SPFP和SPFLP模型的性能.首先描述实验环境,然后对比全闪存的影子页恢复方法和本文两个模型的性能.5.1实验环境为了更好地展示性能,本文实现了Trace驱动的闪存模拟器和相变存储器模拟器,通过参数配置可以模拟MLCNAND闪存芯片和相变存储器.实验平台采用Lenovo昭阳K46A,其处理器为Intel酷睿i5450M,双核4线程,内存大小2GB.操作系统使用的是Fedora14,内核版本为Linux2.6.35.鉴于此,配置相变存储器大小为1GB,MLCNAND闪存大小为32GB.保留闪存10%的空间用于空间回收,空间回收阈值设置为全部可用空间的5%.我们实现了全闪存的影子页恢复技术(SP)、采用组提Page8交的全闪存的影子页恢复技术(GSP)、SPFP和SPFLP4种事务恢复模型,事务并发处理采用严格的两阶段加锁机制.缓冲区采用常用的缓冲区替换策略LRU.在PostgreSQL8.4上运行TPC-C事务并记录数据访问请求,获得标准的在线事务处理负载,即TPC-C负载Trace.我们利用50个客户端和20个仓库产生该Trace,用于测试SP、GSP、SPFP和SPFLP的性能.同时,事务的回滚比率设置为默认值5%.闪存和相变存储器的参数详见表1.其它参数详见表2.参数逻辑页大小缓冲池大小组提交策略参数值4KB5.2性能对比分析从事务吞吐(单位时间内处理事务数)、事务执行时间(Trace的总执行时间)、空间回收代价(空间回收执行时间)和恢复代价(恢复执行时间)4个方面对比了SP、GSP、SPFP和SPFLP4种恢复模型.实验对比数据如图6~图9所示.如图6和图7所示,SPFP的事务吞吐和事务执行时间都要优于SP和GSP,因为相变存储器的读写速度要远高于闪存的读写速度.采用组提交策略的GSP会丢失一定量的已提交数据.SPFLP的吞吐能力和事务执行时间也要略优于SPFP.虽然在SPFLP中更新操作会产生大量对相变存储器的写操作,但是SPFLP所采用的非强制缓冲区管理策略却极大地减少了对闪存的写操作,并且闪存的写操作延迟要远大于相变存储器的写操作延迟,所以整体上来说SPFLP性能还是优于SPFP的事务并行处理性能.由于在获取事务状态过程,SP要比GSP读取更多的闪存页,所以SP空间回收代价和数据库恢复代价要大于GSP空间回收代价和数据库恢复代价,如图8和9所示.在获取事务最终状态时,SPFP和SPFLP都不需要读闪存,所以SPFP和SPFLP的空间回收代价和数据库恢复代价要低于SP和GSP的空间回收代价和数据库恢复代价.由于SPFP和SPFLP采用同样的空间回收机制,SPFP和SPFLP具有相同的空间回收代价,如图8所示.如图9所示,SPFLP的恢复代价大于SPFP的恢复代价,主要原因有以下3点:(1)相变存储器上的事务信息增多,SPFLP记录了事务更新操作的所有信息;(2)SPFLP在完成恢复过程中需要删除和释放节点空间;(3)SPFLP在完成恢复过程中需要改变链表节点中指向下一个节点的指针.而由表1可知,相变存储器的写性能和读性能要相差两个数量级,所以会消耗更长的时间来完成系统故障恢复.6结论相变存储器同时具有内存、磁盘和闪存的优良特性,在数据库系统中充分发挥相变存储器的优势特性以提高整个数据库系统的性能成为了新的研究热点.本文基于相变存储器和闪存的混合存储架构提Page9出一种基于影子页的数据库事务恢复模型SPFP,利用相变存储器进行事务管理.随后基于SPFP提出了一种支持非强制缓冲区管理策略的数据库事务恢复模型SPFLP,利用相变存储器跟踪并记录事务更新操作.通过实验证明SPFP和SPFLP模型能够大大提高事务处理能力.
