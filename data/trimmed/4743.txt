Page1面向移动应用软件信息泄露的模型检测研究1)(南开大学计算机与控制工程学院天津300350)2)(山东交通学院信息科学与电气工程学院济南250357)摘要移动平台上的应用软件私密信息泄露漏洞关注违背用户意愿的接口或数据暴露,而泄露形式和内容的复杂性增添了该类漏洞的检测难度.现有方法主要利用传统的静态数据流分析及动态监控等技术,易发生漏报和误报,且无法处理隐式信息泄露问题.该文首次将基于线性时序逻辑(LinearTemporalLogic,LTL)的模型检测技术应用于移动软件信息泄露检测上,提出了一种基于安全要素语句插装的泄露检测方法.文章首先针对代码中的安全要素提出一种信息泄露抽象关系模型;其次设计驱动生成规则和插装算法,在目标应用上生成可规约系统;继而设计具有通用意义的LTL泄露检测属性并利用符号执行技术优化检测算法;最后构建支持移动平台的模拟方法库,开发了原型检测系统(LeakageFinderofAndroid,LFDroid).公开数据集实验及对比分析表明,该文方法可以为含有隐式信息泄露数据集提供更为精确的漏洞检测,相较于传统方法准确率和召回率均具有明显优势,除此之外亦发现了3个真实移动应用的5个隐式泄露漏洞威胁.关键词模型检测;移动应用软件;信息泄露;线性时序逻辑;漏洞检测1引言当前,移动终端设备由单一的通信功能向智能化、便捷化、复杂化转变,相应的支撑这一转变的操作系统平台也得到飞速发展.其中,GoogleAndroid系统成为普及率最高的移动系统平台,根据IDC分析显示,在2015年第一季度,Android系统已占据了智能手机市场78%份额①.以GooglePlay为例,作为全球最大的商业化Android应用市场,迄今为止已经包含了超1000万个Android应用软件,平均每月新增近3万新型应用②.除此之外,其他众多的Android市场同样包含数量惊人的应用产品.这些移动应用因其能够提供种类繁多的特色功能而被用户广泛接受和使用,因而不免涉及诸多安全敏感(security-critical)的应用场景.用户逐渐习惯于利用移动设备处理日常生活及工作所产生的各类数据,而这些数据可能包含大量的私密信息,例如,通讯录,短信,地址,电子邮件,好友信息以及财产安全相关的网银账户、密码等.这些私密信息的泄露会严重威胁用户安全并影响系统的正常运行,例如,一个典型的扣费软件会利用获取的电话号码、IMEI(InternationalMobileEquipmentIdentity)、ICCID(IntegrateCircuitCardIdentity)、网银用户名、密码等隐私信息,执行话费、流量相关的恶意扣费以及网银的额外支付,因此私密信息泄露漏洞都应被尽早地检测与防范.近年来,无论应用开发者、应用分发市场还是用户,对于隐私泄露防范意识和投入均有所提高,也涌现了大量的泄露检测工具,一些针对直接的、显式的信息泄露检测技术相继出现.然而这些检测技术的出现也客观促使了攻击者加速改进其攻击手段,使得移动平台信息泄露呈现出从直接化向间接化、从简单化向复杂化、从显式的信息泄露向隐式泄露转变的趋势.相对于显式泄露将私密信息直接暴露出来,隐式泄露则更为隐秘,它通过函数、分支结构等控制流转换,将原私密信息包装之后再输出.隐式泄露的结构特性增添了其检测的难度,一方面隐式信息流改变了原私密信息的格式或内容,往往不易引起用户注意.另一方面对隐式泄露漏洞的利用更为复杂,这也使得应用开发者和运营商对其放松警惕而忽略检测.对此,King等人[1]利用实验充分说明了隐式信息泄露检测具有重要的实用价值,但需开发出有效的检测工具以降低检测成本及出错率.当前对于Android应用信息泄露检测的研究日渐兴起[2-10],然而仍缺少有效手段准确检测隐式信息泄露[2].现有的检测方法主要基于污点跟踪分析技术,即对敏感私密信息进行静态跟踪[2-5]或动态监控[9-10].污点分析从一个预定的敏感源source(例如设备ID,地理位置信息及通讯录等)跟踪敏感污点数据的流动,直到数据到达一个给定接收点sink(例如短信发送或者日志输出).当前污点分析可较为精确地定位泄露的关键对象,在显式泄露检测领域被证明是有效的,然而对于隐式信息而言,由于其无规律的内容转换会对分支结构的执行造成影响,进而左右程序控制流走向,因此上述方法对隐式流跟踪是无效的,隐式泄露检测对于各种基于流分析的方法[2,4-5]而言被证明是一个棘手的挑战.Android应用泄露检测的另一挑战来自于Android平台自身特征.不同于传统的JAVA应用程序需要根据主函数确定单一的程序入口,Android系统应用没有主调用函数,而是以事件回调作为驱动,因此对于Android应用的测试工作较之传统的应用软件测试更具难度,因其需要充分考虑应用组件的生命周期以及各回调事件的发生序列,且随着事件的增加,该序列集合的规模将呈爆炸性增长.针对上述挑战,本文首次将基于线性时序逻辑LTL(LinearTemporalLogic)[11]的模型检测技术①②Page3应用于Android应用信息泄露检测上,提出一种基于安全要素语句插装的泄露检测方法.该方法简化了信息流细节,仅关注敏感源与危险接收点之间的关系,提取私密信息泄露抽象模型,并利用现有的LTL模型检测技术进行检测.为了提高检测算法的执行效率,利用符号执行求解优化合适的输入值域.最后开发了原型检测系统LFDroid(LeakageFinderofAndroid),在公开数据集上的对比实验表明本文方法的有效性.本文第2节给出研究动机及示例;第3节设计并提出抽象的信息泄露模型;第4节阐述可规约代码生成过程;第5节抽象基于泄露检测场景下的迁移模型,设计LTL模型属性及检测算法;第6节实验及对比分析;第7节讨论算法的适用性;第8节总结与下一步工作.2研究动机及示例首先利用一个典型的代码示例说明隐式信息泄露的发生原理及本文的研究动机.该示例代码来自EC-SPRIDE研究机构所贡献的DroidBench1.2.该示例代码片段实现了一个简单的设备ID输出功能.主函数如图1(a)所示,该主函数将电话管理器的ID经多种方式转化后通过日志打印出来.而ID的转化则依据图1(b)和图1(c)所示的两类混淆函数.其中,图1(b)所指示的混淆函数1通过将字符串型的ID转化为整型,从而达到混淆的效果;而图1(c)所指示的混淆函数2则利用更为复杂的Character.forDigit函数进行转化.该示例代码存在隐式的信息泄露隐患,且由于打印信息与ID内容1.publicclassImplicitFlow1extendsActivity{2.@Override3.protectedvoidonCreate(BundlesavedInstanceState){4.super.onCreate(savedInstanceState);5.setContentView(R.layout.activity_implicit_flow1);6.TelephonyManagertelephonyManager=(TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);7.//source8.Stringimei=telephonyManager.getDeviceId();9.StringobfuscatedIMEI=obfuscateIMEI(imei);10.writeToLog(obfuscatedIMEI);11.//hardtodetect12.obfuscatedIMEI=reallyHardObfuscatedIMEI(imei);13.writeToLog(obfuscatedIMEI);14.}15.privatevoidwriteToLog(Stringmessage){16.Log.i(“INFO”,message);//sink17.}18.}1.privateStringobfuscateIMEI(Stringimei){inobfuscateIMEIforcharacter:”+c);(b)IMEI混淆函数1图1示例代码完全不符而不易察觉.私密的设备ID信息通过函数调用分别流向switch分支语句和forDigit转换函数,从而构成了两条隐式信息流,攻击者可以通过劫持日志信息反向判断用户的设备ID.首先考虑利用经典泄露检测工具FlowDroid[2]进行检测,FlowDroid是一款由EC-SPRIDE项目组开发的开源工具,它主要面向Android应用信息泄露进行静态流污点检测,已成为当前众多信息泄露检测研究的参照基础[6-8],影响广泛.该方法首先会定位到泄露的敏感源入口,即Stringimei=telephonyManager.getDeviceId(),继而通过赋值引用对污点变量的值进行传播,然而当传播进入混淆函数1,由于遇到分支结构(语句4~16),传播不会以直接赋值的方式继续,而实际上通过switch语句影响控制流走向,从而发生关于敏感信息的隐式泄露.对于混淆函数2,污点通过语句4传播至变量imeiAsChar,而另一个受污染的变量newOldIMEI(语句5),由于没有充分的传播条件,从而造成漏报.FlowDroid方法的优势在于可以准确跟踪泄露信息流的轨迹,以及处理对象、域和上下文敏感等因素,然而对于代码混淆而形成的隐式信息流,由于敏感流信息转化的多样性和复杂性使得其无法从代码分析层面进行准确推断.其次考虑选择动态污点分析技术[9-10]加以解决,由于动态技术采用字节码层面的污点标记,并实时监控Android应用的运行状态与结果,不可避免地增加了系统开销.另外在隐式泄露转换过程中,标记将随着转换的发生而停止传播,因此仅靠标记初始污点的办法无法从结果标记中得出结论,从而无法适用于隐式泄露检测.Page4一种直接的处理方法是忽略分支条件或函数体限制,直接将污染传播至条件语句或关键函数所关联的所有变量(如图1(b)中result以及图1(c)中的numbers,imeiAsChar以及newOldIMEI),而这种对路径不敏感的处理方式会造成过度污染问题,极易造成误报.由此可见,隐式的信息泄露会对纯静态代码分析造成困难,假使忽略混淆转化的细节,通过分析建模信息流要素,如危险源点source与接收点sink,继而挖掘目标源码中所存在的要素关系,将会使得隐式泄露检测成为可能,且简化了实现过程和开销.下面首先定义信息泄露的安全要素,提出基于安全要素的信息泄露抽象关系模型.3抽象的信息泄露关系模型3.1安全要素定义定义1.安全要素.安全要素是一个五元组K,K={type,fun,para,pos,var},其中type是要素类型集合且包含两种类型:source和sink;fun是要素所包含的调用函数集合;para是敏感参数集合;pos是要素的位置信息;var是关联变量集合.表1典型安全要素要素类型SourceSink3.2抽象的信息泄露关系模型定义2.泄露关系.假设对于source型安全要素k1={source,f1,p1,pos1,var1}及sink型要素k2={sink,f2,p2,pos2,var2},存在ve及ve变量上的两个取值val(ve1变量上的两个不同取值val(ve(a)(val(ve(b)((val(ve安全要素是泄露的关键部分,一个移动应用中的安全要素数量不固定,可能为多个,也可能没有.source要素指向私密信息首次出现的代码片段,sink要素指向输出型代码片段,pos用于要素定位,为后续插装及结果生成提供支持,para是要素的私密函数、变量或常量,而fun是调用para的相关类、对象或函数,var是与para或fun相关的变量集合,如果para以函数或变量形式出现,则var包含para.通常,source要素除了para之外,会赋值给一个变量,因而额外关联一个var,而sink类型要素行使输出功能,其参数决定了信息泄露过程中sink要素的内容含量,且参数可能为常量而不一定会关联变量.例如,一段source要素代码为imei=convertId2Format(mTelephonyMgr.getDeviceId());其中:mTelephonyMgr.getDeviceId()为关键私密参数构成para;convertId2Format是自定义函数,其功能是将私密信息转换为固定格式从而构成fun;而变量imei被fun赋值,它与mTelephonyMgr.getDeviceId()一同构成var.典型的安全要素功能和危害如表1所示.其中,→表示当左部成立则右部也成立.则称k1与k2存在泄露关系,记为k1→val()与val()通过固有赋值或用户输入确定.例如,在图1(a)中,imei为source要素的var元素之一,它的val()取值原本为设备的唯一识别码,然而亦可通过插装等手段为其重新赋值.值得说明的是,如果sink要素的参数全为常量,则其var集合可能取空,此时需要在原始要素基础上增加新的要素变量,相关内容将在下节介绍.Page5泄露关系确立了两个安全要素之间是否具有存在泄露的可能.具体表现在参数是否具有特定的关联,该关联分为两个步骤,其一是source要素与sink要素关于的某一参数值成对出现;其二是当source要素在其定义域内变换成某一个特定参数值时,对应的sink参数值亦会发生变化.值得注意的是,定义2中泄露关系仅涵盖目标系统中包含明显的source,sink安全要素的信息泄露场景.而其他形式的泄露,如Android平台本身的泄露漏洞以及移动设备远程连接过程中所发生的信息泄露等场景不在本文讨论范围内.定义3.显式泄露关系.假设存在source型安全要素k1={source,f1,p1,pos1,var1}及sink型要素k2={sink,f2,p2,pos2,var2},满足var1∩var2≠,则称k1与k2存在显式泄露关系,记为k1称〈k1,k2〉为显式泄露关系对.由于var1与var2具有相同的交集,预示着交集元素之间没有复杂的值转化,可以通过静态的数据流分析确定由source变量转变为泄露函数参数的可行路径.当目标源码中存在显式泄露关系,其污染信息流也是显式的.值得一提的是,由于var1与var2的交集元素相同,则交集元素的值也相同,该特性可作为后续检测显式泄露关系的重要依据.定理1.已知目标源码中两个安全要素.若k1证明.已知k1,则一定存在vi且有(1)假设取值val(vi(val(vi1)=a)→(val(vi(2)当另一赋值(val(vi由于val(vi其中,D1为vi由(1)和(2)的结论可得k1→泄露的本质是敏感信息在多个可能的取值中确定某个值或范围,因此vi值范围不会是一个确定的值,所以一定能够得到其取值域中的某个(val(vi说明显式关系是一般泄露关系的特例.定义4.隐式泄露关系.假设存在source型安全要素k1={source,f1,p1,pos1,var1}及sink型要素k2={sink,f2,p2,pos2,var2},满足定义2泄露关系且有var1∩var2=,则称k1与k2存在隐式泄露关系,记为k1隐式泄露和显式泄露共同构成了一般泄露关系.在信息泄露检测过程中,隐式泄露关系常常易被忽视,这是因为source要素与相应的sink要素之间是间接关联的,这种间接关联需通过多次值变换才得以显现.从代码层面,已有的静态流分析技术无法准确跟踪污点流向,而动态泄露检测往往着重分析单次运行结果,亦无法准确检测隐式泄露.由定义2~4,抽象信息泄露关系模型得以建立.4可规约代码生成目标源码中的安全要素往往复杂难以操作且缺少初始化赋值,导致模型检测无法直接进行,因而需要首先生成可用于模型规约的中间代码,生成过程利用插装实现.4.1生成规则及算法首先根据诸如表1中的安全要素典型特征,扫描得到各安全要素的内容及位置,继而根据生成规则将源码转化为可规约代码.在原安全要素基础上,构造新的可供模型检测的要素形式,所定义的生成规则如下.规则1.在source类要素之后生成新关联变量;而在sink类要素之前生成新关联变量.规则2.如果source要素除参数外无关联变量,生成一个新变量替代原要素.规则3.对于每个sink要素的参数,生成一个新关联变量.规则4.对于source要素除参数外的关联变量,利用一个随机常量对其初始化.规则5.对于sink要素的新关联变量,利用参数原型对其赋值.规则6.为每段待测源码生成一个驱动主函数,将source与sink要素分别按序调用.主函数的生成过程在后面章节详细描述.定理2.对于可规约代码中的任意安全要素key,均有变量v或变量集合V与之对应,且在信息泄露过程中,变量v或集合V可代替key的内容.证明.对source和sink要素分别讨论:(1)对于source要素k(src),假设k(src)的参Page6数变量集合为P_SRC,k(src)的关联变量集合为V_SRC,则在原始代码中:(a)若V_SRC-P_SRC=,由规则2生成的新变量nv可代替k(src).(b)若V_SRC-P_SRC≠,不妨设变量v∈V_SRC-P_SRC,由定义1及其释义可得v属于k(src)的非参数关联变量,在k(src)之后存在赋值vk(src),从而v可代替k(src).(2)对于sink要素k(sin),假设k(sin)的参数变量集合为P_SIN,由规则3,对于任意p∈P_SIN将被一个新变量nv∈NV取代,NV为新变量集合.根据定义1及其释义,k(sin)的信息内容k(sin)P_SIN,因此k(sin)程中NV可代替k(sin)内容.综上,定理得证.定理3.可规约代码中若存在source安全要素k(src)和它的一个非参数关联变量v,则v的取值与k(src)无关.证明.由规则1和规则4,在可规约代码中,若存在k(src)及赋值vk(src),则在k(src)之后必存在赋值vinit(R),其中init(R)是一个初始化随机量,且无任何其他对v的操作,因此v的取值仅与init(R)有关,而与k(src)无关.定理4.可规约代码中sink要素插装内容不改变原目标代码的执行逻辑.证明.可规约代码sink要素的插装内容I(sin)=Gen(nv)+Asg(nv),其中Gen(nv),Asg(nv)分别表示对sink要素的新变量生成和赋值,设nv为生成的任一新变量,则分情况讨论:(1)对于Gen(nv)而言,由规则1,3可知,若存在k(sin),则Gen(nv)存在且nv不被本程序的任何变量或函数引用,因此不改变原代码执行(2)对于Asg(nv)而言,不妨设p为任一sink要素k(sin)的参数,则由规则5,存在赋值nvp,而此时处于右部的p值不变,则其后的k(sin)亦不变,因此也不改变原代码执行.综上,定理得证.定理2,3表明可规约代码生成规则保证了对应目标代码的任一安全要素均被相关变量所替代,且替代后的要素变更将会对后续程序造成影响,便于进行泄露检测.同时定理4保证了可规约代码除source赋值外,不会脱离原目标代码,其检测结果将反映目标代码中存在的漏洞威胁.根据规则1~6,得到可规约代码的生成算法如算法1所示.算法1.可规约代码生成算法.输入:待测目标安全要素输出:可规约的系统代码1.PROCEDURERulableSystem(A)//A为待测目标安全要素2.FOREACH(kinA)3.IF(source==k.type&&NULL==(k.var&k.para))THEN4.k.var.add(createNewVar());//为每个无额外变量的source生成新关联变量5.moveTo(k.pos+1);6.k.var_new=randomValue();//利用随机常量初始化source变量7.ELIFsink==k.typeTHEN8.FOREACH(pink.para)9.k.var.add(createNewVar());//为每个sink参数生成新关联变量10.moveTo(k.pos-1);11.k.var_new=p.var;//将参数赋值给新关联变量12.ENDFOR13.ELSE14.output(“invalidk”);//无效的要素15.ENDIF16.ENDFOR17.IF(!createDrive())THEN18.output(“failedtogeneratedriven”);//无效的驱动19.ENDIF20.ENDPROCEDURE对于具备安全要素的目标系统,通过定义2利用模型检测验证该系统泄露与否,在形式上应符合下列条件:(1)具备通用的source与sink要素变量;(2)要素变量能够方便获取;(3)Source要素变量值易于变更.算法1通过语句4对于每一个无关联变量的source要素生成一个新要素变量,并且利用语句6赋给一个随机初始值,该初始值通过函数随机变更,从而满足条件(3);而语句7~12,对于每一个sink要素根据其参数生成对应的关联要素变量.由于新生成的要素变量形式和名称被设计为通用已知的,因此在检测过程中易于获取,从而满足条件(1)和(2).总体而言,算法1的初始化插装使得程序中的安全要素变得易于修改和获取,为后续模型检测工作提供便利.Page7为了描述清晰,使用一个典型的示例代码(如图2所示,更多示例可见①)描述生成过程,该示例代码描述了一个简单的打印经纬度功能的Activity,当用户的位置发生改变时,函数onLocationChanged()将会被回调,当再次回调onResume()时发生位置信息泄露.1.publicclassLocationLeak1extendsActivity{2.privateStringlatitude=“”;3.privateStringlongitude=“”;4.@Override5.protectedvoidonCreate(BundlesavedInstanceState){6.super.onCreate(savedInstanceState);7.setContentView(R.layout.activity_location_leak1);8.LocationManagerlocationManager=(LocationManager)getSystemService(Context.LOCATION_SERVICE);9.LocationListenerlocationListener=newMyLocationListener();10.locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,5000,10,locationListener);11.}12.protectedvoidonResume(){13.super.onResume();14.if(longitude.compareTo(“112.5”)>0&&longitude.compareTo(“127.5”)<0){15.Log.d(“Longitude”,“Longitudeisbetween112.5and127.5”);//sink16.}17.Log.d(“Latitude”,“Latitude:”+Double.toString(latitude));//sink18.}19.privateclassMyLocationListenerimplementsLocationListener{20.publicvoidonLocationChanged(Locationloc){//source21.longitude=Double.toString(loc.getLongitude());22.latitude=Double.toString(loc.getLatitude());23.}24.}25.}经过插装转化,由规则所生成的可规约函数代码如图3所示.在此仅展示关键的source和sink要素所在函数(onResume()和onLocationChanged())转化结果,而主调用函数的生成过程将在后面章节具体阐述.图3中生成模块首先匹配到程序的安全要素,即图2中的语句15,17,21,22.对于两个sink要素,根据规则1和规则3,分别在原要素之前为其参数生成新的要素变量sink1和sink2,并插装于原sink要素之前.根据规则5,对于sink要素所生成的要素变量sink1,sink2,分别利用参数原型longi-tude和latitude对其赋值.而由于两个source要素已有对应的关联变量longitude和latitude,不符合规则2,无需生成新的要素变量.继而根据规则4,利用初始化函数为source要素赋值,赋值语句安排在source要素之后,并利用初始化函数init()为其构造初始值.1.publicvoidonResume(){2.super.onResume();3.if(longitude.compareTo“112.5”)>0&&longitude.compareTo(“127.5”)<0){4.sink1=“Longitudeisbetween112.5and127.5”;5.Log.d(“Longitude”,“Longitudeisbetween112.5and127.5”);//sink,leak}6.sink2=latitude;7.Log.d(“Latitude”,“Latitude:”+latitude);//sink,leak8.}9.}10.privateclassMyLocationListenerimplementsLocationListener{11.publicvoidonLocationChanged(Locationloc){//source12.longitude=Double.toString(loc.getLongitude());13.longitude=init(3,2);14.latitude=Double.toString(loc.getLatitude());15.latitude=init(3,2);16.}17.Randomrandom=newRandom(42);18.publicvoidinit(domain,randN){19.Stringbase=“0123456789”;20.StringBufferran=newStringBuffer();21.for(inti=0;i<domain;i++){22.intnumber=random.nextInt(randN);23.ran.append(base.charAt(number));24.}25.returnran.toString();26.}4.2驱动主函数与传统应用软件不同的是,Android应用以事件来驱动运行,缺少真正意义上的主函数,这意味着其执行路径将随着系统与用户之间的上下文需求关系不断发生变化,函数调用顺序不确定,增加了检测的难度.因此除了处理过程内逻辑之外,需要一个合适的驱动函数安排可行的类函数执行序列,从而模拟应用程序可能运行的不同方式.而Android异步事件发生是随机的,如果考虑所有可能的事件排序,将会造成序列爆炸.对此,文献[2]提供了一种路径不敏感的模拟主函数构建方法.该方法首先为每个Android组件按照生命周期生成一个调用图,继而利用回调函数扩展该调用图,最终得到一个完整的函数调用序列.本文在文献[2]关于生命周期建模的基础上,设计了适用于抽象信息泄露模型的驱动主函数生成方法.在阐述驱动生成规则之前为了便于描述,首先定义一些概念.定义5.要素函数.若一个回调函数中包含source要素或sink要素,则称该函数为要素函数.若其包含source要素,称为source函数;包含sink要素,则称为sink函数.定义6.全要素函数.若一个函数中既包含source要素又包含sink要素,称为全要素函数.①Report2.https://github.com/guochenkai88/-/blob/mas-ter/technical_report2.pdfPage8下面定义驱动主函数序列生成过程所依据规则.规则1.若目标代码不具有source函数或sink函数中的任意一种,则不予生成.规则2.排序须先source函数后sink函数.规则3.目标程序及xml文件中所注册的回调函数扩展至onResume()与onPause()方法之间.规则4.对全要素函数连续回调两次,且位于onResume()方法之后与onPause()方法之前.规则5.除Android生命周期回调需要,不重复调用任意非全要素回调函数.定义7.合法序列.符合驱动生成规则且成员数量不少于2的函数序列,称为合法序列.定理5.对任意一条合法序列,具有至少一条包含由source要素到sink要素的子序列.证明.分情况讨论.(1)当合法序列中无全要素函数时,由规则1和规则2容易得证.(2)当合法序列中包含全要素函数F时,假设其中的source要素和sink要素分别记为k(src)与k(sin),则有以下情形:(a)k(src)在k(sin)之前,此时假设F为合法序列中除F之外的任一函数,则序列[F,F]即是符合条件的子序列.(b)k(src)在k(sin)之后,此时根据规则4,F被调用两次,要素的执行顺序为k(sin)→k(src)→k(sin)→k(src),包含k(src)→k(sin).综上,定理得证.定理6.除Android生命周期执行需要,任意一条合法序列不包含重复的子序列.证明.利用反证法,不妨假设除Android生命周期执行需要,一条合法序列包含两个重复的子序列均为[F1,F2](更多成员的子序列可类推),则由规则5,F1,F2须均为全要素函数.此时,若F1=F2,则F1被调用4次,不符合规则4;若F1≠F2,则F1与F2均不被连续调用,不符合规则4.因此该子序列不存在,定理得证.定理5和定理6表明驱动生成规则能够生成包含检测要素的合法序列,且能有效降低重复遍历的开销.图2示例代码的组件对象生命周期控制流图如图4所示.其中llonLocationChanged()函数作为回调函数,发生的时机应该在llonResume()函数与llonPause()之间,从而图中的所有生命周期函数均可成为该回调函数的后继节点,然而却并非所有函数均可成为其前驱节点,因为图中llonDestroy()函数至该回调函数是不可达的.函数驱动序列生成过程如算法2所示.算法2.函数驱动序列生成算法.输入:待驱动函数集合输出:函数驱动序列1.PROCEDUREDrivenGen(F)//F表示目标应用中的待排函数集合2.key_fun_couple=getKeyFunctionCouple(F);//提取F中的要素函数对3.key_source_fun=key_fun_couplesource;4.key_sink_fun=key_fun_couplesink;5.keyPaths=Paths(key_source_fun,key_sink_fun);//提取经过source和sink的路径集合6.FOREACH(pinkeyPaths)7.IF(Rules(p))THEN8.driven_list=p;9.break;10.ENDIF11.ENDFOR12.returndriven_list;13.ENDPROCEDURE算法2用于模拟每对安全要素的生命周期回调函数执行顺序.首先由语句2~4通过驱动生成模块扫描所有的安全要素关系对,继而语句5由图4中Page9生命周期可达序列,构造可达的安全要素路径序列集合.通过语句6~12选择一条符合规则1~5的函数流向,并保存路径节点.这样保证了算法2的生成结果中,任意source和sink要素都具有不多于1条合法序列,避免了重复生成影响运行效率.据算法2得出图2示例代码中所生成的主函数驱动序列如图5所示.由于源码中没有对onStart(),onPause()等函数进行重载,因此在序列生成过程中对上述函数不做考虑.5基于泄露场景的LTL模型检测模型检测已被证明在验证计算机软硬件系统特别是安全攸关系统的正确性方面具有优势[11].它能够遍历系统路径以保证检测的精度,并关注系统的时序状态性质从而对系统做出准确的性质判断.5.1迁移系统定义8.迁移系统[11].一个迁移系统是一个Kripke结构的四元组K=(S,s0,T,L),其中S是有限的状态集合,s0∈S是初始状态,TS×S是迁移关系集合,L:S→2AP是标记函数,AP是原子命题集合.L(s)表示状态s中真值为真的命题集合.定义9.泄露检测场景系统状态.泄露检测场景下的系统状态s是一个二元组s=(E,V),其中E是安全要素变量执行次数集合,V是变量当前取值集合.在泄露检测场景下,对于一个迁移系统而言,系统的状态s由安全要素变量执行情况及取值决定,且状态本身根据程序控制流的运行实现相互迁移.为了验证泄露场景下定义3中的显式关系,需要处理程序运行过程中的系统状态细节,判断各个状态所存在的时序性质.而对于定义4中的隐式关系,仅根据某次执行的结果难以判断,需要设置对比进程.为了描述清晰,图6从控制流的角度将图2示例的可规约代码抽象成一个泄露场景可规约迁移系统形式.图中显示了状态S1至S10的状态取值情况.可规约迁移系统自起始状态开始,经一般控制流运行进入S1状态,在S1状态下根据longitude状态赋值的不同,选择进入不同的后继状态(S2,S7,…),如此形成多对对比进程,这些对比进程在迁移系统中根据已有的状态条件发生不同的流向,从而产生大量的系统路径和状态.当进入S2后,无论latitude取何值,将不会对sink1造成影响;而进入S7后,sink1将会被赋值为指定字符串值.对于泄露检测场景下可规约迁移系统的生成,以第4节生成可规约源码为基础,通过运行所生成的可规约代码,监测进程控制流的执行轨迹,获取安全要素执行状态,从而产生系统的状态集合,而状态之间通过控制流变换形成迁移.5.2LTL时态逻辑属性构造模型检测是基于时态逻辑(temporallogic)进行的,时态逻辑与一般系统性质的区别在于,它所针对的模型是一个动态的迁移系统,因此它可以验证系统在任意运行状态所符合的性质以及状态与状态之间的时序属性.Page105.2.1LTL语法结构线性时序逻辑LTL是最为流行的模型检测时态逻辑形态之一[12],它允许使用指示未来的连接词,其语法结构如定义10所示.定义10.LTL语法[11].线性时态逻辑(LTL)有如下BNF(Backus-NaurForm)范式给出的语法:∷=⊥|(X)|(F)|(G)|(U)|(W)|(R),其中:p是命题原子,连接词X,F,G,U,W和R称为时态连接词,分别表示“下一个状态”,“某个未来状态”,“所有未来状态”,“直到”,“释放”和“弱-直到”.5.2.2显式泄露属性对于显式泄露LTL属性的构造需要满足定义3的要求,无需考虑对比进程,仅需单次执行即可完成检测.本文利用值的等量关系来验证定义3,即是通过值的等量关系来验证变量的相等关系.显式泄露相应的LTL属性设计如下:LTLSpec∷=X(∧p1∷=F(source_var==sink_var);p2∷=F(source_fun.call==true);p3∷=F(sink_fun.call==true);p4∷=F((source_var==init)其中,LTLSpec表示程序无显式泄露情形下的属性,由于描述无泄露情况较为复杂,考虑首先描述定义2中的泄露关系属性,然后取反.X表明跳过初始状态的不确定影响,实验过程中发现一些程序的初始状态是不确定的永真或永假,即在不加X的情况下,可能会出现当之后的条件并未被满足时,其结果也显示满足,因此加上X限制从而跳过初始状态,避免上述误报发生.source_var与sink_var分别表示某次执行的source和sink相关变量值,而source_funcall与sink_funcall分别表示某次执行的source函数和sink函数是否被调用.p1表明泄露需要在程序运行中的一个状态(F指示)下,出现source变量与sink变量等值.p2,p3察觉函数是否被调用,p4限定了source与sink的赋值内容和时机.显式泄露验证过程中需要考虑以下几种特殊情况的发生:(1)source与sink变量在均未赋值的情况下,二者值恰好相等.(2)source与sink要素在运行异常而导致source函数或sink函数没有被调用的情况下,二者值恰好相等.(3)source变量值在不经过数据流情况下,与sink变量值恰好相等.定理7.若一对source和sink变量在未被赋值的情况下恰好相等,则该对要素变量不满足显式泄露条件.证明.分情况讨论:(1)当source变量未被初始化赋值时,显式泄露属性p4条件中source_var==init将不被满足,p4也不被满足.(2)当sink变量未被赋值时,p4条件中sink_var==init将不被满足,p4也不被满足.综上,当一对source和sink变量在未被赋值时无法满足泄露条件,定理得证.定理8.在程序运行异常而导致source函数或sink函数没有被调用的情形下,若一对source和sink变量的值恰好相等,则该对要素变量不满足显式泄露条件.证明.分情况讨论:(1)当程序运行异常而导致source函数没有被调用时,显式泄露属性p2条件中source_funcall==true将不被满足,p2也不被满足.(2)同理,当sink函数没有被调用时,显式泄露属性p3条件中sink_funcall==true将不被满足,p3也不被满足.综上,在source函数或sink函数没有被调用情形下将无法满足泄露条件,定理得证.定理7和定理8表明显式泄露属性可以修正(1)、(2).对于条件(3)而言,由于source与sink变量的值相等,且sink将与source相等的值用以传播,即使二者无内在的数据流关联,亦说明source实质上发生了泄露.5.2.3隐式泄露属性对于隐式泄露,仅一次进程执行无法获取source与sink变量的变化关系(如定义4),需要在驱动函数中考虑对比进程.隐式泄露相应的LTL属性设计如下:LTLSpec∷=X(∧p1∷=F(∨p2∷=F(source1_fun.call==true);p3∷=F(source2_fun.call==true);p4∷=F(sink1_fun.call==true);p5∷=F(sink2_fun.call==true);Page11p6∷=F((source1_var==init_src1)U(sink1_var!=Null));p7∷=F((source2_var==init_src2)U(sink2_var!=Null)).隐式泄露所考虑的特殊情况与显式泄露一致,但需不断生成对比进程进行判断,由于对比进程的生成依靠source值的更换,由定义4仅需判断sink值的等量关系即可,即p1所表示的不同的执行中sink值的等量关系.p2至p7分别表示与显式泄露对等的细节,上述各属性符号的解释同显式泄露,属性中source与sink后面的数字表示执行序数.定理9.若一对source和sink变量在未被赋值的情况下满足定义4,则该对要素变量不满足隐式泄露条件.证明.同定理7,一对source和sink变量在未被赋值的情况下无法满足隐式泄露属性的p6或p7.定理10.在程序运行异常而导致source函数或sink函数没有被调用的情形下,若一对source和sink变量满足定义4,则该对要素变量不满足隐式泄露条件.证明.同定理8,一对source和sink变量在程序运行异常而导致source函数或sink函数没有被调用的情形下无法满足隐式泄露属性p2至p5的其中之一.定理9和定理10表明隐式泄露属性可以防止赋值和程序异常方面导致的误报.5.3安全要素LTL验证算法检测工作的关键在于对模型进行属性验证,而在实际中一个目标系统往往存在多个source或sink要素,如果循环对比每一个安全要素对,则会对同一条路径生成多次驱动函数,造成额外的效率开支.算法3用于处理多重要素的LTL属性验证,使得每个source与其所有后继sink要素都可以得到验证,且无重复验证并减少驱动的生成次数.算法3.多重安全要素LTL验证算法.输入:待测的可规约系统源码输出:结果列表ResultList1.PROCEDURELeakDetect(RA)2.FOREACH(〈source,sink〉!==NULL)3.IF(!〈source,sink〉.visited)THEN4.drvn_list=geneDriven(〈source,sink〉)//为要素对生成驱动5.visitedEachSS(drvn_list);//将驱动要素节点设置访问并将要素指向该驱动6.ENDIF7.IF(〈source,sink〉.drvn_list!=NULL)THEN8.source_base=init;D=input_init;9.ltl_buchi=ltl.convert2Buchi();//将LTL属性转变为Buchi10.proc_base=genePro(source_base,drvn_list);//生成基准进程11.WHILE(!traversedIsEnd)DO12.source_peer=random(D);13.proc_peer=genePro(source_peer,drvn_list);//生成并初始化对比进程14.15.new_state=catchCurrentState();16.curModel=createModel(new_state);//在状态集上生成模型17.ltl.violated=curModel.inter(ltl_buchi);//模型与属性做交运算18.IF(ltl.violated)THEN19.resultList.setLeakFlag();20.resultList.leakpos.add(violated.pos);//添加属性违反的sink位置信息21.break;22.ENDIF23.proc_peer.nextState();24.ENDWHILE25.D.delete(source_peer);26.27.ENDWHILE28.ENDIF29.ENDFOR30.returnresultList;31.ENDPROCEDURE以验证图3可规约代码的隐式属性为例,对于目标系统中可能存在多对安全要素问题,通过分析source要素特点,其两两之间是相互独立的,算法首先利用语句2定位到每一对〈source,sink〉,即〈longitude,sink1〉,〈longitude,sink2〉,〈altitude,sink1〉,〈altitude,sink2〉,再通过语句3~5为每一对〈source,sink〉生成唯一的合法驱动,为了避免重复的驱动生成,为驱动的每一个安全要素对添加一个访问标记,当驱动运行后设置其所包含的所有〈source,sink〉访问标记,并将要素对指向该驱动.这样实际上图3中所有的要素对均指向[onCreate(Bundle)→MyLocationListeneronLocationChanged(Location)→onResume()]这一条驱动序列.继而对于每一对安全要素对,验证其可规约代码的显式和隐式属性,在此主要描述隐式属性的验证,显式验证无需生成对Page12比进程,其他同理.以〈longitude,sink1〉为例,当基准进程的初始化取值为100,对比进程的初始化取值为120时,由5.2.3节其隐式属性生成如下:LTLSpec∷=X(∧p1∷=F(sink1!=sink1);p2∷=F(MyLocationListeneronLocationChanged==true);p3∷=F(MyLocationListeneronLocationChanged==true);p4∷=F(onResume==true);p5∷=F(onResume==true);p6∷=F((longitude==100)U(sink1!=Null));p7∷=F((longitude==120)U(sink1!=Null)).由于验证隐式属性需要通过运行不同进程比较sink结果,因而语句8,10和语句12,13分别通过对longitude进行不同的初始化取值从而生成基准和对比进程.对于LTL属性的处理,利用传统的buchi自动机转化算法(语句9),与目标状态模型做交运算(语句15~17),根据交运算的结果判断属性是否违反从而给出结果(语句19~20),对于图3的示例,当基准进程的初始化取值为100,对比进程的初始化取值为120时,符合隐式泄露属性,继而停止循环,报告隐式泄露.算法中,由于语句8中的source的定义域D可以通过人工制定阈值限界从而得到有效控制,加之模型检测工具中利用偏序规约、抽象等方法进行路径约减,整体的遍历过程将得到有效缩减.5.4基于符号执行的算法优化算法3由语句8用户自定义阈值后通过语句12在阈值范围内取随机量,以此对遍历定义域做了阈值限制.然而在实际应用中可能由于sink要素所在路径条件超出阈值而造成漏报,同时如果定义域阈值设置过大,则时间开销将随之增加,本文利用符号执行技术作为辅助的优化方法来解决上述问题.隐式泄露的真正信息由source数据本身转化为sink要素的参数,该转化过程主要基于三种途径:类函数、分支语句以及二者的结合.对于不带分支语句的类函数,其sink变量根据source变量的值而变化,该情况(如图1(c))利用小范围的source阈值遍历可顺利检测;相对于类函数,分支语句内部的source变换往往基于分支条件,需要掌握路径中的条件分界,否则无法高效地遍历分支.基于此,利用现有的符号执行[13-15]技术首先得到关于source到sink的路径条件集合,再通过约束求解得到合适的测试条件域,从而使得source变量可以根据条件域精准赋值,提高检测效率.6实验分析6.1实验环境及工作流程本文实验环境为Windows7操作系统,内存为4GB,CPU为IntelCore(TM)i3-2120@3.30GHz.为了验证文中算法在检测Android应用软件信息泄露方面的有效性,本文设计并实现了一个基于LTL模型检测的移动应用信息泄露检测原型工具LFDroid.开发工具基于MyEclipse9.0,JDK1.6,apk反编译工具apktool①、dex2jar②以及作为支撑环境的JPF(JavaPathFinder)[16]系列工具,包括JPF-CORE,JPF-SE,JPF-LTL.JPF是一款被广泛使用的针对JAVA语言的模型检测平台,它构建了独立的JAVA字节码虚拟机,并使用了偏序规约来抑制状态爆炸问题,同时具备很强的扩展性.其中,JPF-CORE是JPF平台的核心引擎,JPF-SE[17]是JPF的一种关于符号执行的扩展工具,它利用JPF生成符号状态,并使用了多种约束求解技术(Omegalibrary,CVC-Lite,YICES等)来求解条件数据,已被用于多种并行的Java程序测试用例生成.同样作为JPF的扩展,JPF-LTL③用于验证JAVA程序的时序属性,支持方法调用和变量属性的验证.选择JPF系列工具作为系统支撑工具的理由在于它们能够有效处理JAVA语言的模型检测任务.由于Android应用的开发语言是基于JAVA语言的,因此JPF相较于其他模型检测工具在Android程序应用上更具优势.LFDroid的工作流程大致包括以下步骤:(1)调用工具反编译待测的Android应用apk文件,解析其中的manifestxml清单文件(用于组件注册、隐式Intents分析)、layoutxml文件(用于事件回调分析)以及src源代码;(2)通过安全要素和驱动序列生成规则及算法,在源码的基础上生成可规约代码;(3)根据检测需求生成对应的显式泄露和隐式泄露LTL属性;(4)调用JPF-LTL实施模型检测,优先实施显式泄露检测,再执行隐式检测;(5)当检测失效或无泄露时,调用符号执行重新规划初始值,继而执行二次隐式检测(若符号执行失败则作为无漏洞①②③Page13处理);(6)记录运行时间及检测结果,生成检测报告.图7展示了LFDroid的工作流程.6.2模拟库搭建使用JPF来检测Android应用程序的安全性泄露问题,面临的挑战之一是如何让运行于DVM(DalvikVirtualMachine)的Android程序在JVM(JavaVirtualMachine)上运行.为了应对这一挑战,本文首先尝试引入Robolectric①的影子库实现Android的库类,从而消除异构虚拟机上的不兼容性,然而,由于Robolectric库和的android.jar之间诸多复杂的不相容性难以解决,上述方法被证明不可行.于是本文采取利用建立局部的模拟库替代Android库的方法,设计了相应自定义功能模型和模拟类,利用这些自定义代码,可以模拟源码函数的返回值,参数类型,以及对象和函数的调用逻辑.使用这些内置方法和类,Android应用程序可以顺利被编译成JVM字节码.由于Android模拟库的构建不是本文方法关键部分,因此现阶段我们只针对目标源码开发了功能较为基本的模拟类库以及在目标应用中所出现的特定类方法.在开发过程中,对于简单功能的方法直接返回随机值,而不必运行其内部逻辑,当涉及ICC机制等复杂数据类型时,模拟类实现了将源方法给定的参数传递给目的函数,而对于GUI功能,其对应方法所需接收的值被指向配置文件.表2列举了部分已实现的模拟库方法.事件LifecycleGUIICC6.3实验评价方法本文实验采用的数据集为:(1)DroidBench1.2.该数据集包含60个开源的Android应用,设计者通过人工为其注入了52个信息泄露漏洞,这些漏洞所分布的数量和位置是已知的,且还包含一些误报陷阱,它为泄露检测工作制造了多种挑战,包括数组与列表的下标混淆,进程通信组件ICC(Inter-ComponentCommunication)、代码混淆、反射以及隐式泄露等.当前,该数据集已成为Android信息泄露检测公认数据集,且围绕该数据集已进行了多项高水平研究[2-6].(2)ICC-Bench②.ICC-Bench数据集是由Aman-droid[18]工具所引入的另一类Android信息泄露数据集,现阶段已有多项泄露检测研究工作基于该数据集[18-20].它包含16个开源并已知漏洞的应用,其中的10个为隐式Intents,5个为显式Intents,1个为动态注册组件.由于该数据集主要针对组件间通信泄露的检测,为了增加隐式泄露的成分,人工植入了20个隐式泄露漏洞.考虑到实验公平性,该组数据集的植入方式按照DroidBench中Implicit的漏洞逻辑而并非自身设计,目的是为了检验本文算法在检测组件间通信方面的准确性.实验对比工具及方法如下:(1)FlowDroid.FlowDroid是一款针对Android应用的静态污点分析工具,为了提高检测精度,它保持了对上下文、数据流、对象等敏感,并对Android生命周期进行了完备的建模;(2)Amandroid[18].Amandroid是一款先进的致力于组件间通信泄露检测的静态分析工具,①②Page14它依靠复杂的数据流分析预测泄露的发生.6.4实验结果与分析6.4.1检测结果说明在DroidBench与ICC-Bench上的对比实验结果分别如表3和表4所示,其中“LOC”表示程序规表3DroidBench数据集对比实验结果Android应用DirectLeakInactiveActivityLibrary1&2LogNoLeakObfuscation1PrivateDataLeak1~3366&261&339ArrayAccess1&2HashMapAccess1ListAccess1AnnonymousClass1Button1~3LocationLeak1~3MethodOverride1MultiHandlers1Ordering1Unregister10.088&0.224&0.095.52&6.310.112&6.39&0.15610.19&11.21&0.22FieldSensitivity1~4288&280&279&26754&54&4&546.29&4.4&0.08&5.86InheritedObjects1ObjectSensitivity1&24.33&9.82Exceptions1~4301&303&303&3004&4&54&40.087&0.081&4.88&0.0810.139&0.125Loop1&2SourceCodeSpecific1StaticInitialization1UnreachableCodeImplicitFlow1ImplicitFlow2ImplicitFlow3ImplicitFlow4CommunicationIntentSink1&2ActivityLife1~4282&271&266&2694&4&4&40.094&0.105&0.099&0.097生命周期事件4/404/404/400.084&0.82ApplicationLife1~3303&312&3860.12&0.103&0.137BroadcastLifecycle1SeviceLifecycle1Reflection1~4339&344&360&3504&54&54&540.122&5.23&6.39&5.85Total从结果中可以看到,LFDroid可以检测出Droid-Bench数据集中用例ImplicitFlow1~4的8个隐式漏洞以及ICC-Bench数据集中所植入的20个隐式漏洞中的16个,总体对隐式漏洞的检测召回率达到87.5%,而FlowDroid和Amandroid却不支持隐式漏洞的检测.另外在误报方面,LFDroid总共发生了5次误报,明显优于FlowDroid的21次和Amandroid的10次.然而也仍需看到LFDroid仍然存在一些漏报和误报,具体分析这些错误的原因如下:模的统计包括了源码中的java,xml,txt格式文件,“#S”表示模型状态数量,“MT”表示方法在模型检测阶段的用时,而对比结果中的“TP”表示正确检出的漏洞数,“FP”表示错误检出的漏洞数,表4中“#IN”为植入的隐式漏洞数量.MT(sec)0.0720.0881.300.0915.725.5500.08700.2550.090.0820.11--5.550.49210.2113.3923.630.1020.1150.1161.05对于DroidBench而言:(1)在对用例IntentSink1的分析过程中,没有将setResult函数当作sink要素,从而发生漏报;(2)由于JPF-LTL暂不支持静态初始化,因此检测StaticInitialization1用例时发生了漏报;(3)由于JPF暂时不支持反射机制的原因,使得用例Reflection2~4发生了漏报.而对于用例Reflection1,LFDroid直接将反射对象当作一般对象处理,因而能够顺利检测;(4)用例Ordering1因为没有准确驱动生命周期顺序,而造成误报;(5)用例Unregister1因为没有准确处理未注册的回Page15调函数,而造成误报;(6)用例AnnonymousClass1与MultiHandlers1在建模过程中没有仔细处理LocationListener中的源入口函数,从而发生漏报.对于ICC-Bench(modified)而言:(1)对于用例ICC_Implicit_Data2_Imp,LFDroid对Intent.setType未做处理,因此造成FooActivity未接收到Intent,产生漏报,相应的隐式泄露也被漏报;(2)对于用例ICC_Implicit_Mix1_Imp和ICC_Implicit_Mix2_Imp,LFDroid系统对于Intent.setDataAndType未做处理,因此导致FooActivity与HookActivity均未接收到Intent,产生3个漏报,相应的隐式泄露也被漏报;(3)对于用例ICC_Explicit_Src_NoSink_表4植入后ICC-Bench数据集对比实验结果Android应用ICC_Exp_IICC_Imp_Action_IICC_Imp_Category_IICC_Imp_Data1_IICC_Imp_Data2_IICC_Imp_Mix1_IICC_Imp_Mix2_IICC_DynRegRec1_IICC_Exp_NoSrc_NoSink217ICC_Exp_NoSrc_SinkICC_Exp_Src_NoSinkICC_Exp_Src_Sink_IICC_Imp_NoSrc_NoSink248ICC_Imp_NoSrc_SinkICC_Imp_Src_NoSink_I318ICC_Imp_Src_Sink_I6.4.2精度分析图8和图9展示了在仅有显式泄露漏洞的情形下,各工具方法的准确率和召回率比较.当仅有显式泄露漏洞时,LFDroid的总体准确率依然比AmandroidImp,由于LFDroid忽略了显式Intents的跳转目的限制,从而造成误报,相应的隐式泄露也造成误报.表3中一些代码规模几百行左右的应用实例,其状态数量仅为4左右,通过排查发现这些实例均仅包含单一、直接的显式泄露漏洞,对于这类漏洞,验证程序仅需抽象2对安全要素对比状态即可发掘漏洞,因此状态数较少.本文方法所抽象的状态数与代码中安全要素数量及漏洞性质有关,在安全要素数量较少的情况下,对于显式漏洞而言,仅需抽象较少状态即可检测全部漏洞;而对于隐式泄露,由于需要生成对比进程,因此状态数会急剧增长.检测难点高7.5%,这是因为LFDroid的模型检测过程进行了代码执行,因此对于诸如数组、列表等结构的混淆误报可以很好地避免.然而由于LFDroid运行环境限制,需要依赖现有的模型检测工具以及自身构建的模拟库,这些环境的局限造成较多漏报,使得图9Page16中LFDroid的召回率要低于Amandroid.特别是在DroidBench数据集上,由于用例逻辑较为多样,使得LFDroid的召回率低于其他两种工具.图10和图11展示了在带有隐式泄露漏洞情形下,相应的准确率和召回率比较.图10与图8中FlowDroid与Amandroid两种工具检测准确率没有变化,隐式泄露检测没有增加其TP和FP,说明它们不支持隐式泄露检测.而LFDroid的准确率变化主要来自DroidBench的4个Impilicit-Flow用例,分别增加了1.5%的DroidBench准确率和0.9%的总体准确率.对于ICC-Bench而言,由于LFDroid检测隐式与显式漏洞的TP和FP均相同,因此准确率没有变化.由于LFDroid对隐式泄露漏洞检测的良好支持,实验中的检测召回率达到85.7%,使得图11的总体召回率要明显高于其他两种工具.6.4.3时间效率分析表3和表4的模型检测时间显示,时间开销与状态规模相关,其主要表现在无泄露及要素数量较多时状态规模及检测时间均发生剧烈增长.一方面,当程序中具有sink要素但没有泄露时,检测会遍历阈值,使得消耗较大.另一方面,时间效率和目标系统中source与sink要素的数量具有直接关系,由于模型检测需要对程序中的每一对安全要素模拟执行,状态规模和检测时间会随着安全要素对的数量成倍增长.表5列出了3种工具的检测时间对比,LFDroid的检测平均时间略高于其他两种工具,分别是它们的1.715倍和2.029倍.为了分析LFDroid检测时间的构成,本文统计了各重要模块的平均时间开销如表6所示,发现除去必要的解析时间,大部分的时间用于产生可规约代码,而模型检测部分的时间开销仅占总开销的12%.6.4.4符号执行优化的影响LFDroid利用符号执行对算法进行优化,目的是为了解决隐式泄露中的路径遍历所带来的状态爆炸问题.为了说明符号执行优化对本文方法的作用,本文对比了“无符号执行”和“带有符号执行”时DroidBench中的4个隐式泄露用例的执行情况,对比结果如表7所示.表7符号执行优化DroidBench隐式检测效果的影响Android应用ImplicitFlow1ImplicitFlow2ImplicitFlow3ImplicitFlow4Total这里由于FP均为0,因此仅列出TP的结果.从对比中可以看出,当无符号执行优化时,在指定阈值下会出现对ImplicitFlow2~4隐式漏洞的漏报,这是因为这些隐式信息流对条件变量的变化不敏感.然而通过符号执行选取条件初始值,可顺利检出该数据集中所有的隐式泄露漏洞.时间方面,对于ImplicitFlow1而言,由于阈值内检测可以直接发现漏洞,没有经过符号执行阶段,Page17从而检测时间与无符号执行相同.然而其后的用例中无符号执行时用时较少,这是因为符号执行及之后的隐式检测过程占用了一定的时间消耗.另外在以准确率为目标的检测过程中,当检测失效时,为了更精准地发掘漏洞,实际检测中会增加阈值范围,用时间换取精度,使得检测用时也会相应增加,因此表中给出了“”,表示多于当前值.由于对比数据集用例规模均较小(小于400行),且分支条件简单,相应符号执行的时间开销较小,然而随着代码规模的上升,其扫描和约束求解的代价也将随之增加,检测的代价将会明显上升,这也将成为今后算法改进的重要方向.6.4.5市场软件分析利用LFDroid发现了3款实际Android市场应用软件中所存在的隐式漏洞问题,该3款市场应用在FlowDroid和Amandroid上均检测失败.检测结果如表8所示,其中“LOC”为程序规模,“Source/Sink”表示程序中所蕴含的source和sink要素数量,#S表示状态数,MT表示模型检测用时,#R表示检出漏洞数,#TR表示经排查后的真实漏洞数.其中,GpsTracker来自GooglePlay,其他两款来自国内安卓应用市场.LFDroid在检测这些市场应用时,在原有模拟库基础上补全了支持目标应用的库函数,如增加了Preference及sqlite等Android类的支持,并利用FlowDroid所使用的敏感函数集合来定位各安全要素.在这些目标程序中,GpsTracker是一款简单的定位跟踪软件,用于跟踪手机去向、紧急状态下的位置定位以及计算机主的移动距离,LFDroid发现了其1条隐式流存在于其Atracker-Activity组件中,通过人工排查,该隐式流使得当敏感信息myimg.length()大于10时,sendMessage的sink会被触发.而LoveSMS是一款供恋人之间发送私密短信的应用,LFDroid检测出18处漏洞,均是以Log作为sink,其中显式漏洞8条,隐式10条,通过进一步分析,在10条隐式漏洞中,有8条是通过Intent.getAction来作为敏感条件变量,这里我们不认为它会造成实质性的危害,因此予以排除.DeerEword是一款与好友共享位置信息的应用软件,LFDroid检测出了其中两个很具危险性的隐式漏洞,在其AlarmRecv模块中,敏感信息SimSerial通过两个Post函数作为条件分支而传播给指定站点,该漏洞可以使用户在不知情的状态下泄露他们的Sim序列号.从结果中可以看出,当目标程序中安全要素数量较大时,检测时间将相应增加,这与6.4.3节中的结论一致.Android应用LOC/KSource/Sink#SMT/s#R#TRGpsTracker2.8LoveSMSDeerEwordTotal6.5适用性讨论本文方法可用于一般Android应用程序在源码开发阶段的信息泄露检测,也可用于开发完成后无代码混淆的apk格式Android应用程序信息泄露检测.在处理较大规模的目标程序时,该方法的处理能力依赖于以下因素.首先,由于方法本身属于模型检测算法在程序分析方面应用,因而其处理能力与检测算法的处理能力和效率直接相关,由于状态爆炸一直是限制模型检测应用的难题,当目标程序中分支结构、安全要素变量过多时,模型的状态数量会剧烈增长,导致检测效率低下甚至无法运行;同时,本文方法也依赖于支撑工具的处理能力,当前JPF所处理的目标代码行数一般不超过10k级别,并且不支持一些特殊的代码形式如自定义的classloader,native类、反射等.另外,由于方法的优化过程中利用符号执行限制分支范围,当分支条件中的变量类型或结构过于复杂时,将影响约束求解的处理效力.最后,由于目前对于Android应用在JAVA虚拟机上的运行,需要依赖人工搭建的模拟库函数,因此当程序中出现模拟库中不支持的函数类型时,将会发生运行时错误.现阶段本文方法适用于代码行数10k级别以下,不具有JPF、符号执行及模拟库无法处理的代码形式,且安全要素数量较少的目标代码.然而随着模拟库构建的不断完善,模型检测算法的持续优化以及符号执行处理能力的提高,本文方法在检测Android应用信息泄露方面的前景也会愈发广阔.7相关工作由于Android应用以JAVA语言为编码基础,本文利用了面向JAVA的模型检测程序分析工具JPF来执行分析.关于模型检测在代码分析方面的应用工作,现有较为成熟的针对程序分析的模型检测工具如面向C语言或C++的BLAST[21],CBMC[22],CPAchecker[23],SATABS[24]等.其中BLAST是一种主流的针对时序安全属性的C语言自动化验证Page18工具.CBMC是针对限界模型检测的C语言模型检测分析器.CPAchecker提供了一种可配置的程序分析(ConfigurableProgramAnalysis)方法.SATABS利用SAT求解器精确地处理ANSI-C标准语义.在泄露分析方面,除FlowDroid和Amandroid等静态分析工具之外,较为流行的还有DTA++[25],TaintDroid[9],SpanDex[26]等动态分析工具.其中,DTA++利用动态污点传播技术来限制程序中的隐式信息流,通过监控跟踪输入标记的传播轨迹判断流传播,当遇到控制流结构时,DTA++会分析分支内容是否揭露了全部私密信息,而后再决定是否传播标记.TaintDroid是将动态污点传播应用到Android信息泄露保护的代表性工具,它扩展了Android的运行环境用以对程序进行精准跟踪,然而它不能支持隐式泄露检测.SpanDex在Taint-Droid基础上,加入了符号执行因素用于分析计算控制流的分支范围,从而达到限制私密信息传播的目的.动态污点传播技术虽然在准确性上具有优势,然而由于其只能覆盖有限的执行路径,因此无法全面胜任信息泄露漏洞的检测工作,仅可用于限制泄露的实时发生.由于模型检测具有遍历程序分支状态的先天优势,因此利用模型检测技术一方面可以规避动态污点跟踪的覆盖局限,另一方面遍历执行程序逻辑也可有效提升静态分析的准确性.当前,利用模型检测技术进行Android信息泄露分析工作日渐兴起.其中,DroidPF[27]利用模型检测生成应用的调用驱动,从而解决Android事件驱动的回调问题,然而DroidPF不支持隐式信息流的检测.文献[28]将Android应用转化为一种PushDown系统,并运用模型检测技术执行转化后的Android恶意软件,以此进行有效识别,该工作也不支持隐式信息流的检测.本文利用模型检测的优势,可以有效弥补上述工作在隐式泄露检测方面的不足.8结束语本文利用时序属性验证的模型检测技术对Android平台应用信息泄露漏洞进行检测,主要工作集中在两点:第一,提出了抽象信息泄露关系模型,利用程序中安全要素的泄露关系,可以有效检测目标应用中的显式和隐式信息泄露漏洞,特别在实验中对于隐式泄露漏洞检测召回率达到85.7%,优于相关的流分析对比工具.第二,利用模型检测技术模拟执行可规约的目标源码,可以有效避免流分析过程中的代码结构混淆问题,从而降低误报的发生.对比实验表明,相较于现有的移动平台信息泄露检测工具,本文方法在检测含有隐式信息泄露漏洞的数据集时,召回率和准确率均有明显优势,并由于阈值限制和符号执行的运用,在时间开销上与对比方法无显著差异.另外,在对比工具检测失败的状态下,利用本文方法发现了3款真实移动应用的相关泄露漏洞.下一步的研究内容主要包括:(1)进一步完善和扩展模拟运行库的构建,支持更加复杂的程序运行逻辑;(2)完善对组件间通信、handleMessage等回调机制的支持,降低由此而引发的误报及漏报;(3)完善模型检测优化方案,进一步降低由符号执行引起的检测开销;(4)根据显式和隐式泄露的类型和易测程度,建立泄露危险等级评估机制,制定危害程度标准将检测结果量化.致谢感谢课题组刘磊、李鹏、苑立英等同学在数据收集、实验系统实现等方面所做的工作.感谢审稿专家所提出的宝贵意见!
