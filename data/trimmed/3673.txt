Page1时间敏感数据流上的频繁项集挖掘算法李海峰章宁朱建明曹怀虎(中央财经大学信息学院北京100081)摘要数据流中的数据分布随着时间动态变化,但传统基于事务的滑动窗口模型难以体现该特征,因此挖掘结果并不精确.首先提出时间敏感数据流处理中存在的问题,然后建立基于时间戳的滑动窗口模型,并转换为基于事务的可变滑动窗口进行处理,提出了频繁项集的挖掘算法FIMoTS.该算法引入了类型变化界限的概念,将项集进行动态分类,根据滑动窗口大小的变化对项集进行延迟处理,仅当项集的类型变化界限超出一定阈值的时候才进行支持度的重新计算,能够达到剪枝的目的.在4种不同密度的数据集上完成的实验结果显示,该算法能够在保证内存开销基本不变的情况下显著提高计算效率.关键词频繁项集;数据流;时间敏感;滑动窗口;数据挖掘1引言频繁项集是Agrawal在1994年提出来的[1],其动机是为了寻找超市事务数据的频繁集,用以分析客户的购买行为.近年来随着在众多行业中广泛的应用,频繁项集挖掘的研究受到了广泛关注,逐渐发展成为数据挖掘中的重要分支,其目标是在数据集中寻找用户感兴趣的模式,例如关联规则[2]、序列模式[3]、数据相互关系[4]等.网络及大规模商业集成等应用的普及产生了大量的流数据.数据流是动态数据的一种典型代表,具Page2有高速、无限、连续且动态变化的特点,在数据流的环境下,频繁项集的挖掘算法必须用有限的内存空间去保存和处理数据,而且需要实现对数据的增量分析处理.这些挑战成为研究数据流管理和挖掘的人员关注的焦点.通常来说,用户关注的是数据流最近到达数据的分析结果,因此研究人员提出了衰减模型[5-6]和滑动窗口模型[7-19]以降低存储和计算代价.文献[5]为了反映数据流的变化趋势,采用衰减因子来降低历史数据的影响.算法estDec采用格来保存显著项集,并通过其子集进行支持度的估计,其过程分为4个阶段:参数更新、计数更新、延迟插入和频繁项集选择.采用衰减因子虽然可以有效反映数据流变化趋势,但无法记忆过去某段时间的内容,因此无法满足用户对历史项集支持度的查询,文献[6]则维护了比前缀树压缩率更高的基于后缀的频繁项集森林(IsFI-forest),提出的算法DSM-FI采用了宽松的最小支持度作为阈值来得到潜在的频繁项集.文献[7]结合了滑动窗口的优点,在算法FP-stream中采用倾斜窗口来保存每个频繁项集的支持度,为了节省空间,倾斜窗口将时间段进行不同粒度的划分,越靠近当前时间点的时间段粒度越小,这样就可以在满足用户时间相关查询的情况下降低空间代价.文献[8]采用了以事务作为基本单位的滑动窗口作为挖掘模型,提出的算法estWin将潜在频繁项集定义为显著项集,而忽略非显著项集的处理,通过数据流滑动窗口的长度来估计项集是否显著,确定监控项集的内容.文献[9]提出的算法Stream-Mining采用了两次扫描来得到结果,第一次扫描获取候选集,对只包含两个项目的项集进行挖掘,而对其它长度的项集则根据apriori性质进行挖掘,其精确度由给定的参数来确定.为了有效压缩数据并且便于项集操作,StreamMining采用了名为treehash的数据结构,通过项目的统计减少子集的检测,并通过事务的在线监测来减少子集的插入.文献[10]为了处理数据流的大型滑动窗口,提出了算法SWIM.SWIM将窗口分为多个块,每次更新一块数据来提高效率,并且根据FP-tree条件树的概念,用模式树PT直接保存频繁模式.据此还提出了两种算法DTV和DFV以及二者的混合算法,通过条件计数来完成频繁模式的验证,可以得到精确的计算结果.文献[11]完成了同样问题的改进算法.文献[13]为了检测项目出现的最大频率,以减少用户对参数的设置,重新定义了频繁项目的频繁度,并提出了一种高效的针对新型频繁项目挖掘的方法.文献[12]扩展了这种定义方法,挖掘在不同滑动窗口中具有最大频率的频繁项集.文献[14]则利用项目的信息来提高挖掘频繁项集的效率.尽管以上方法能够高效地完成对滑动窗口中的数据挖掘,但均是基于事务作为基本单元的挖掘方法,也就是说,滑动窗口的大小根据事务数量来决定,这种方法存在一定的弊端.文献[15]假定每次进入滑动窗口的事务数量不等,首次提出了时间相关的数据流模型[16],并给出了基于块的频繁项集的挖掘算法,为了从历史数据流中获取项集支持度,该算法采用衰减计数表来存储和估计数据信息,并通过数据合并以减少内存使用.其主要问题在于,尽管使用了错误报警机制,该算法挖掘的结果仍然存在一定的误差.文献[17]为了降低删除滑动窗口中的事务对挖掘结果的影响,提出了两种算法:第1种算法ATS是基于平均时间戳的,根据平均时间值与当前时间值的比较,来判断项集是否符合一致性分布,决定是否剪枝该项集.第2种算法FCP是基于支持度的变更点的,通过比较项集发生的当前时间与最后一次发生的时间来决定当前时间是否为支持度的变更点,以改变项集第一次出现的时间,从而达到缩小滑动窗口的目的.文献[18]扩展了FCP算法来解决文献[15]中提出的问题,即挖掘以时间戳作为基本单位的滑动窗口,用PS-tree来保存频繁项集,用局部贪婪算法来处理每个时间单元到达大量数据的情况,但该算法同样没有解决结果存在误差的问题.文献[19]也提出了一种时间敏感的数据流挖掘算法,但该算法并没有针对该模型的特点进行优化,因此算法的效率不高.本文针对以上问题,结合时间敏感数据流的特性,提出了一种高效而且精确的频繁项集挖掘算法.本文的主要贡献如下:(1)提出了基于时间区间的滑动窗口模型,该模型与传统滑动窗口模型中以事务数量作为衡量滑动窗口大小的方式不同,更能够体现现实中数据流的时间特性.(2)将提出的滑动窗口模型转换为传统的基于事务的可变滑动窗口模型,并根据该模型定义了基于相对支持度的频繁项集的挖掘问题.(3)引入了类型变化界限的定义,将项集进行动态分类,通过延迟处理来裁剪冗余数据计算,进而提出了高效的频繁项集挖掘方法,该方法能够在保Page3证节省空间代价的同时,提高挖掘的效率.(4)通过在两种真实数据集和两种模拟数据集上完成了算法的实验验证,并与该问题的Nave算法进行了对比,实验表明了本文算法的可行性和高效性.本文第2节介绍频繁项集的相关知识;第3节提出时间敏感的滑动窗口模型以及转化后的可变滑动窗口模型,并据此提出本文需要解决的问题;第4节提出基于类型变化界限的频繁项集挖掘算法FIMoTS;第5节通过实验进行算法验证;第6节是本文的总结.2预备知识频繁项集是数据集中发生次数不小于用户定义阈值的项集.用Γ={i1,i2,…,in}来表示所有不同项目的集合,其中|Γ|=n表示Γ的长度,称长度为k的Γ的子项集X为k-项集.为了简单起见,可以把项集X={x1,x2,…,xm}表示为x1x2…xm.给定数据集D={T1,T2,…,Tv},每一个Ti(i=1,…,v)表示一个基于Γ的事务,包含事务id和对应的项集X.对于事务T=(tid,X)来说,如果存在项集Y使得YX,则称事务T支持项集Y,所有D中支持项集图1基于事务的滑动窗口与基于时间戳的滑动窗口Y的事务集合称为Y的覆盖,表示为cover(Y,D)={T|TD∧YX∧X∈T}.Y的绝对支持度是覆盖其事务的集合大小,表示为Λ(X,D)=|cover(X,D)|,其相对支持度是Y在D中发生的概率,即Y的绝对支持度与数据集D大小的比值,表示为Λr(Y,D)=Λ(Y,D)|D|.给定相对最小支持度阈值λr,如果Λr(Y,D)λr,则称项集Y为频繁项集.3基于时间戳的滑动窗口模型3.1研究动机数据流具有动态性,其数据受到实际应用和网络环境的影响,到达数量的分布是不均匀的,也就是说,数据到达具有时间相关性,而过期数据往往不受关注.例如,在超市中,由于客流量在不同时间段的不同,交易在客流高峰期会集中出现,而在其它时段出现的较为稀疏.传统的滑动窗口模型通常采用事务数量来决定窗口大小,这存在一定的缺陷.图1描述了这一数据流到达情况,并展示了采用基于事务的处理模型和基于时间戳的处理模型时滑动窗口中数据的变化情况,同时,将基于时间戳的模型转换为基于事务的处理模型,并与前者进行了对比.如图1(a)所示,假如每个时间段Ti是超市中的半天时间,Page4而管理员在T6的结束时刻希望看到的是当天销售情况的分析,即T5到T6期间的销售分析,那么待分析的数据应该为{ac,cd},而如果用基于事务数量的滑动窗口模型(图1(b),假定滑动窗口大小为5),实际分析的数据为{bcd,ad,bcd,ac,cd},也就是说,实际分析了两天的数据,这样的结果与管理员希望得到的结果是有误差的.因此,需要基于时间戳来决定滑动窗口的大小,精确的定位用户需求,图1(c)显示了基于时间戳的滑动窗口模型,该模型能够体现用户对近期数据分析的需求.图1(c)中的模型可以转化为基于事务的可变滑动窗口模型,如图1(d)所示.在该图中,滑动窗口的大小会随着时间的变化而变化.在这样的滑动窗口中,以绝对最小支持度作为阈值的方法不再适用,这是因为在动态变化的滑动窗口中,不同时间段的事务数量分布不均匀,从而导致挖掘的结果不准确.例如,在图1(d)中,假定一个项集在滑动窗口中的一半以上事务中出现则认为该项集为频繁项集,那么在[T1,T5]范围内,共有7个事务,最小支持度为4,其频繁项集为{b:4,c:5,d:5};但是在[T2,T6]范围内,如果最小支持度依然保持为4,其频繁项集变为{c:4,d:4}.但该范围内只有5个事务,其最小支持度应变为3,也就是说,{cd:3}应该也是[T2,T6]范围内的频繁项集,但该项集由于使用固定的绝对最小支持度阈值而被忽略了,显然这是不合理的.3.2问题提出根据上文所述,本文需要解决的问题是采用相对最小支持度来挖掘以时间戳为基本单位的滑动窗口模型上的频繁项集.如图1(c)所示,当新时间段的事务到达时,滑动窗口中最早时间段的事务将被删除.尽管也有一些研究以时间作为单位进行研究,但通常是通过批处理的方式[20]来完成挖掘,这种方式无法实时获取数据挖掘的结果,因此不属于时间敏感性挖掘方法.从已有的文献来看,近两年针对该问题的研究没有形成较好的解决思路,其方法有待于进一步改进.3.3Nave算法该问题的简单解决方法是:扫描初始滑动窗口,获取所有的频繁项集和部分非频繁项集;随着滑动窗口的移动,每次事务插入和删除,均全部扫描已得到的项集并计算其支持度,根据支持度的类型变化剪枝或生成新的项集.这也是文献[19]的解决思路.该解决方法的缺点在于,每次的滑动窗口均需要大量的数据扫描、比较和计算,其计算开销较大.4FIMoTS算法在动态变化的滑动窗口模型中,项集具有以下在数据流中,当给定了阈值后,用户通常只关心频繁项集是什么,而很少关心频繁项集的支持度具体是多少,最大频繁项集的挖掘就是源于这种假设.基于这个观察,本文将项集按照其支持度与最小支持度阈值的差值进行了分类,采用枚举树作为数据结构保存数据大纲,并提出了FIMoTS算法来解决第3节中提出的问题,该算法分别对事务到达和离开滑动窗口的情况进行了处理,利用项集的时间属性进行计算剪枝.4.1数据结构的性质.性质1.给定项集I,如果I是频繁项集,对于新到达事务T来说,若IT,I仍然是频繁项集,否则I可能变为非频繁项集.性质2.如果I是非频繁项集,对于新到达事务T来说,若IT,I仍然是非频繁项集,否则I可能变为频繁项集.根据以上性质可知,随着滑动窗口大小的变化,绝对最小支持度阈值不断调整,使得没有支持度变化的项集也会发生类型更改,也就是说,一旦滑动窗口中的内容发生变化,就必须检测所有的项集,这样会产生大量不必要的计算开销.为了节省计算开销,需要对项集按照待处理时间进行划分.定义了项集的类型变化界限.定义1.类型变化上界.对于项集I来说,如果新到达ub-1个事务一定不能使得I发生类型变化(从频繁变为非频繁,或从非频繁变为频繁),而新到达ub个事务可能使得I发生类型变化,则称ub为I的类型变化上界,表示为ub(I).定义2.类型变化下界.对于项集I来说,如果删除lb-1个事务一定不能使得I发生类型变化,而删除lb个事务可能使得I发生类型变化,则称lb为I的类型变化下界,表示为lb(I).定理1.对于当前滑动窗口D(|D|=z)来说,给定项集I,采用分数的形式表示最小支持度和I的支持度,其相对支持度为Λr(I)=a最小支持度为λr=c么当满足dPage5类型不变;如果I为非频繁项集,那么当满足adb×b-a|D|<d证明.(1)当I为频繁项集,也就是a讨论:当滑动窗口中增加了n个事务时,在极端情况下,n个事务都不包含I,则I的支持度变为az/bI仍然是频繁项集,则有az/badbcz;当滑动窗口中删除了m个事务时,在极端情况下,m个事务都包含I,则I的支持度变为az/b-m若I仍然是频繁项集,则有az/b-mbd-bcz,也就是说,|D|=z-mdad-bc(2)当I为非频繁项集,也就是a面讨论:当滑动窗口中增加了n个事务时,在极端情况下,n个事务都包含I,则I的支持度变为az/b+nz+n,若I仍然是非频繁项集,则有az/b+n即n<cb-adbd-bcz,也就是说,|D|=z+n<d当滑动窗口中删除了m个事务时,在极端情况下,m个事务都不包含I,则I的支持度变为az/b非频繁项集,则有az/b引理1.若I为频繁项集,其类型变化上界为ub(I)=add-cz[z-db×b-a化上界为ub(I)=d下界为lb(I)=z-ad证明.从定理1可以看出,根据I的不同类型,其类型在一定滑动窗口范围内是不发生变化的,因此超出了这个范围的临界值就是I的类型变化界限.性质3.对于频繁项集来说,其类型变化界限随着支持度的增大而增大.性质4.对于非频繁项集来说,其类型变化界限随着支持度的增大而减小.为了实现快速的项集匹配和增量处理,在内存中采用枚举树结构保存项集信息.在枚举树中,父结点项集是子结点项集的子集;根结点和中间结点均为频繁项集,而叶结点代表非频繁项集或没有兄弟结点的频繁项集.采用三元组〈it,sup,ts〉来表示每个结点,其中,it代表一个项集,并具有唯一的词典顺序(用表示,例如,abc表示a的词典序小于b的词典序,且b的词典序小于c的词典序,那么,由a、b和c组成的项集可以按照唯一的顺序进行排列,即abcabacbcabc,同一层中的结点按照词典顺序的升序排列);sup表示项集的相对支持度;ts表示项集最近更新的时间戳,记录时间戳的目的是为了防止在树的遍历过程中重复计算.另外,在枚举树中,用ib数组保存非频繁项集的类型变化界限值,用fb数组保存频繁项集的类型变化界限值:两个数组中的每个元素分别由二元组〈iub,ilb〉和〈fub,flb〉组成,分别保存类型变化上界值、类型变化下界值,每个元组通过指针指向对应结点,该指针称为界限指针.假定最小支持度为1/3,图2显示了图1(c)中初始滑动窗口所对应的枚举树.度对应唯一的类型变化界限.定理2.给定相对最小支持度,每个相对支持证明.令相对最小支持度为λr=cI的相对支持度Λr(I)=acd,如果存在另外一个项集J的相对支持度Λr(J)=aPage6bz<cz+1=adb-aa和ab必然大于等于1于1,显然是矛盾的;同理,也不可能存在lb(I)=lb(J).因此命题得证.为了创建枚举树,首先创建代表空项集的根结点,然后在根结点下创建|Γ|个不同项目i对应的结点ni,并计算相应的类型变化界限;最后,针对每个结点进行递归处理,生成其子孙结点,直到生成的结点对应的项集为非频繁项集.该算法如下所示.算法1.频繁项集挖掘的初始化算法INITIAL.输入:滑动窗口D,项目结点相对最小支持度λr,枚举输出:枚举树ET方法:1.ifnI.sup<λrthen2.计算I的类型变化界限,生成类型变化界限数组3.else4.foreachnI的兄弟结点nJdo5.ifnJ.supλrthen6.生成结点nI∪J;7.计算其支持度和类型变化界限,生成类型变化8.endif9.endfor10.foreach新生成结点nI∪Jdo11.调用INITIAL(D,λr,nI∪J);12.endfor13.endif数据流进入滑动窗口的最初阶段,可以看作是对静态数据的挖掘.算法1是一个深度优先算法,描述了初始阶段的频繁项集挖掘过程,并生成枚举树.4.2事务删除处理当一组事务Φ从滑动窗口中删除的时候,假设被删除事务的数量为n,根据类型变化下界和支持度的不同,分别进行处理:所有类型变化下界小于等于n的项集I均有可能发生类型变化,需要通过重新计算来确定类型变化界限.若I为频繁项集,那么只有当I被该组中的每个事务均包含时,I的类型才可能发生变化;若I是非频繁项集,那么只有当I不被该组中的所有事务包含时,I的类型才可能发生变化.所有类型变化下界大于n的项集均不可能发生类型变化.此时,一方面需要更新类型变化下界;另一方面,为了保证在删除事务后所有类型变化上界正确,对于每个未处理的项集I来说,若I是频繁的,则假设每个被删除的事务均包含I;若I是非频繁的,则假设每个被删除的事务均不包含I,用来更新类型变化上界.定理3.令相对最小支持度为λr=c假设被删除事务数量是n,则项集I的类型变化下界lb(I)变为lb(I)-n.若I为频繁项集,其类型变化上界ub(I)变为ub(I)-d-c项集,其类型变化上界ub(I)变为ub(I)-d-c[]n.c证明.当被删除事务数量为n时,对于类型变化下界大于n的项集I(支持度为a但为了保证项集在极限情况下的类型正确,需要假设每个被删除事务均会影响项集的类型变化,若I为频繁项集,那么其新支持度变为az/b-n类型变化下界为lb(I),则有az/b-n-lb(I)从定理2可知lb(I)=ad-bcn,假设新类型变化上界为ub(I),则有az/b-nz-n+ub(I)<cbcz[ad-bc为非频繁项集,那么其新支持度变为az/b型变化下界为lb(I),则有az/b理2可知lb(I)=z-ad设新类型变化上界为ub(I),则有az/b+ub(I)可知ub(I)=bc-add-c[]n.c例1.图3是滑动窗口中删除了事务abc和bd后的枚举树,最小相对支持度为1/3,其过程可描述如下:对频繁项集的类型变化界限,首先根据定理3Page7进行更新,得到{-1:0}①、{2:1}和{5:3}三组值.对于{-1:0}对应的项集a、bc、bd和cd分别进行支持度和类型变化界限计算,其中a、bc和bd对应的类型变化界限为{2:1},而cd对应的类型变化界限为{5:3}.对非频繁项集的类型变化界限,首先根据定理3进行更新,得到{1:2}和{0:-1}两组值.对于{0:-1}对应的项集ac和bcd分别进行支持度和类型变化界限计算,其中ac对应的类型变化界限为{1,2},而bcd变为频繁项集,对应的类型变化界限为{2:1}.4.3事务插入处理当一组事务Φ进入滑动窗口的时候,假设被插入事务的数量为n,根据类型变化上界和支持度的不同,分别进行处理:所有类型变化上界小于等于n的项集I均有可能发生类型变化.若I为频繁项集,那么只有当I不被该组事务包含时,I的类型才可能发生变化;若I是非频繁项集,那么只有当I被该组中的所有事务所包含时,I的类型才可能发生变化.所有类型变化上界大于n的项集I均不可能发生类型变化.对于这样的项集来说,一方面要更新类型变化上界.另一方面,为了保证在插入事务后所有类型变化下界正确,对于每个未处理的项集I来说,若I是频繁的,则假设每个插入事务均不包含I;若I是非频繁的,则假设每个插入事务均包含I,用来更新类型变化下界.定理4.假设被插入事务数量是n,则项集I的类型变化上界ub(I)变为ub(I)-n.若I为频繁项集,其类型变化下界lb(I)变为lb(I)-c若I为非频繁项集,其类型变化下界lb(I)变为lb(I)-d-c证明.同定理3.例2.图4是滑动窗口中插入了事务abcd后的枚举树,最小支持度为1/3.其过程可描述如下:对频繁项集的类型变化界限,首先根据定理4进行更新,得到{0:0}和{1:2}和两组值.对于{0:0}对应的项集a、b、bc、bd和bcd分别进行支持度和类型变化界限计算,得到支持度均为3/6,类型变化界限为{4:2}.对非频繁项集的类型变化界限,首先根据定理4进行更新,得到{0:0}.对对应的项集ab、ac和ad分别进行支持度和类型变化界限计算,其中ab对应的类型变化界限为{2,3},而ac和ad变为频繁项集,对应的类型变化界限为{1:1};同时,生成新的项集acd,其支持度为1/6,类型变化界限为{2,3}.4.4算法设计与优化讨论根据定理3和定理4可以将事务的插入和删除操作合并在一起,算法2是FIMoTS的总体思路.该算法会在新的数据到达时,分别扫描类型变化界限数组,更新类型变化界限值,并将其中变为0或者负值的界限值所指向的结点进行支持度的重计算,并根据其新的类型变化界限重新归类.算法2.FIMoTS算法.输入:滑动窗口D,项目结点相对最小支持度λr,被删输出:枚举树ET方法:1.foreachfb[i]do2.fb[i].flb=fb[i].flb-|Φ|-c①{-1:0}分别对应类型变化上界和类型变化下界.Page83.fb[i].fub=fb[i].fub-d-c4.endfor5.foreachfb[i]do6.iffb[i].flb<=0orfb[i].fub<=0then7.foreachfb[i]指向的结点nIdo8.计算I的新支持度和新类型变化界限值,9.ifnI.sup<λrthen10.剪枝nI的所有子结点;11.endif12.endfor13.endif14.endfor15.foreachib[i]do16.ib[i].ilb=ib[i].ilb-|Φ|-d-c17.ib[i].iub=ib[i].iub-c18.endfor19.foreachib[i]do20.ifib[i].ilb<=0orib[i].iub<=0then21.foreachfb[i]指向的结点nIdo22.计算I的新支持度和新类型变化界限值,23.endfor24.foreach新频繁结点nIdo25.调用INITIAL(D,λr,nI);26.endfor27.endif28.endfor在流数据挖掘过程中,在重新计算某个项集的支持度时,增量计算能够提高挖掘效率,用在枚举树中结点的时间戳可以实现该计算方式.假设滑动窗口当前到达Ti处,而目前需要处理的结点I保存的时间戳为Tj,也就是说,I在时间戳Tj后就没有更新过,其支持度为a离开的事务重新计算支持度:若滑动窗口包含了n个时间戳的项集,Ti-n到Tj-n期间共有x个事务,包含I的有y个事务;Ti到Tj期间共有t个事务,包含I的有s个事务,则I的新支持度为a-y+s定理5.给定最小相对支持度λr=c窗口D,为了保证项集I支持度的增量更新,需要保存2|D|个事务.证明.不失一般性,假设项集I在Ti时刻为频繁项集,且在Tj时刻需要更新,也就是说,此时I的类型变化界限是小于或者等于0的.由于在滑动窗口移动过程中,插入和删除事务均假设对I的支持度产生影响,那么从Ti-n到Tj-n之间事务数量的最大值就是能够保证I在事务删除时能够进行增量更新需要保存的事务数量.为了保证该最大值,则需要将从Ti到Tj之间事务数量的最小化,以及I支持度的最大化,即在a-y+ss=0为前提求得x的最大值.由于只有每个删除事务均包含I,才能使得I的支持度降低,所以应满足x=y,给定最小相对支持度λr=c|D|的情况下才可能使得I变为非频繁项集,即最多需要保存包含滑动窗口在内的2|D|个事务.证毕.如图5所示,采用了扩展的FP-tree[21]来维护数据流中的原始数据,不但可以降低内存使用代价,还可以满足事务删除处理的需要.扩展的FP-tree不是仅仅保存最小支持度以上的项目集合,而是保存了所有滑动窗口中事务的项目集合,这样可以迅速计算支持度.另外,由于保存了事务的完整信息,扩展的FP-tree可以实现增量更新.根据定理5,扩展的FP-tree维护了2|D|个事务,为了便于识别,在实现中增加了时间戳集合,用来标识每个时间段到达的事务.定理6.给定最小相对支持度λr=c窗口D(|D|=z),如果在一个时间戳内有m个事务到达,同时有n个事务离开,那么有以下结论成立:(1)对于一个频繁项集IΛr(I)=a()b来说,其类型变化界限可以持续在(ad-bc)z间戳内不需要重新计算.限可以持续在(bc-ad)z(2)对于一个非频繁项集I来说,其类型变化界Page9要重新计算.证明.(1)从引理1可以看到一个频繁项集I的类型变化上界ub(I)≈ad-bc达时,根据定理3,ub(I)应减去d-cub(I)应减去m,平均看来,ub(I)在经过t=ad-bc熿bczd-ccn+燀负值,同样,其类型变化下界lb(I)≈ad-bc定理3和定理4可知,它将在t=(bd-bc)n+[(ad-bc)z(2)证法同(1).5实验用VisualC#在内存为2GB,CPU为PetiumDual1.6GHz,操作系统为WindowsXP的机器上实现了FIMoTS算法,并与Nave算法进行比较.本文没有与文献[18]的研究结果进行对比,这是因为尽管与文献[18]中研究的问题类似,但由于图6不同最小支持度情况下的运行时间代价比较文献[18]的挖掘结果存在误差,而本文则是对结果的精确挖掘,二者不具有可比性.采用了4种标准的数据集作为实验的测试数据集,包括2种由IBM的数据生成器生成的模拟数据集T10I4D100K和T40I10D100K以及2种真实数据集KOSARAK和MUSHROOM,其中KOSARAK是匈牙利一家在线新闻门户网站的点击流数据,MUSHROOM记录了不同品种的蘑菇特性.表1列举了4种数据集的主要数据特征.数据集事务T10I4D100K10000010.1129870T40I10D100K10000039.6477942KOSARAK9900027.11249736841MUSHROOM812923.02323119选取了每个数据集的前n个事务作为初始滑动窗口的数据内容,剩余的事务作为新增数据.在实验过程中为了体现数据流的时间特性,将数据随机划分为块,每个块对应一个时间戳到达的事务,其中包含θ个事务(θ是随机生成的数值,该数值在[0,0.01n]内变化).以KOSARAK数据集为例,如果选择前20000个事务作为初始滑动窗口的内容,则将在后续的事务中每次随机选择[0,200]之间的事务数量作为一次到达的数据量.5.1运行时间代价比较图6显示了Nave算法与FIMoTS算法在不同Page10最小支持度阈值λr情况下每个事务的平均运行时间代价.从4种不同密度数据集上的运行情况来看,Nave算法的运行时间普遍达到FIMoTS算法运行时间的十倍左右,在最小支持度比较高的情况下能够达到将近百倍甚至上千倍,说明FIMoTS通过剪枝获得了较高的计算效率.但是,其计算效率的提高并不是随着最小支持度呈现线性变化,如在KOSARAK中最小支持度为0.08时,其运行代价反而要高于最小支持度为0.07和0.09的运行代价,说明该算法在剪枝的过程中具有随机性,与具体数据内容有关.另外,比较在同一阈值下的运行时间,可以看到,MUSHROOM的数据密度比较大,因此其运行时需要的计算代价也较大,且FIMoTS算法的优化效果没有十分明显,而在KOSARAK上,尽管其数据密度较小,但某些事务很长,最长达到了2497,表2结点更新数量比较Nave算法的更新结果增加结点数量删除结点数量最终结点数量数据集最小支持度初始结点数量KOSARAK0.0018301295070733982786050367305827860MUSHROOM0.1212769424547517860021945692179201510452194569T10I4D100K0.00154309651891609175340705146060486534070T40I10D100K0.011054435331555311232107475831945529913210747586总结数据流中的数据具有时间相关性.本文提出了一种能够体现数据流时间特性的频繁项集挖掘方法FIMoTS.该方法引入了类型变化界限的概念,将数据快速保存到枚举树中,利用类型变化界限的不同对项集进行动态分类,在数据到达和数据离开的时候,根据滑动窗口大小的变化进行计算裁剪,仅对超出类型变化界限的项集进行处理;另外,讨论了采用时间戳进行增量计算的优化策略.实验结果表明,与Nave方法相比,该方法能够在不增加内存开销的情况下显著提高计算效率,是可行的,有效的.
