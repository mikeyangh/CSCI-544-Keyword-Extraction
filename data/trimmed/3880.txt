Page1一种有效的GLR分析器错误恢复方法许福1)刘辉2)孙俏1)陈志泊1)王春玲1)1)(北京林业大学信息学院北京100083)2)(北京航空航天大学计算机学院北京100191)摘要传统的分析器生成器多采用LALR(1)、LL(1)等确定性分析方法.近年来,随着软件再(逆向)工程的发展,GLR等非确定性的分析方法逐渐应用到分析器生成器中,但目前尚未有公开发表的文献提出并解决了自动生成的GLR分析器的错误处理和恢复问题.文中提出了一种基于子串分析的错误恢复方法,实验结果表明,该方法可以有效侦测和恢复输入串中的语法错误,具有较高的错误处理效率,有望应用到以GLR为核心算法的分析器生成器中.关键词GLR;语法分析器;分析器生成器;错误处理;错误恢复1引言LALR(1)、LL(1)等确定性方法长期统治计算机语言的语法分析.进入21世纪以来,语法分析技术正经历确定性分析向非确定性分析的转型过程[1-2].作为非确定性分析方法中的典型代表———GLR[3],也Page2分析错误主要包括词法错误、语法错误、语义错误和逻辑错误4类.词法错误的处理比较简单,不再赘述.语义错误和逻辑错误,与语言语义和执行模型密切相关,难以实现通用的、语言无关的语义错误和逻辑错误处理.无特殊说明,本文提及的错误处理和恢复专指语法错误的处理和恢复.GLR是由LR扩展而来的一种分析方法,LR错误处理方面的研究结果较多,对GLR的错误处理策略具有借鉴作用.本文首先介绍LR常用的错误处理和恢复策略,在此基础上,讨论GLR的错误处理和恢复方法.2LR错误处理和恢复骤:错误侦测、错误报告和错误恢复[5].LR分析器的错误处理过程包括3个典型步(1)错误侦测.错误侦测是指侦测文法或输入串中存在的错误.通常文法出错的概率较小,大都是输入串出错.本文讨论的错误处理和恢复专指输入串的错误处理和恢复.“正确前缀性质”[6],是LR错误侦测的基础,可保证总能侦测到输入串中的非法符号,且已移入的符号总是文法中某句子的合法前缀.为行文简洁,本文用“非法符号”泛指输入串中的错误,用“错误符号”专指输入串中的第一个非法符号.有限状态机和LR(1)分析器具备“立即错误侦测性质”[7],当首次扫描到错误符号时,就可以立即侦测到错误.与此不同,满足“正确前缀性质”的LR分析器在执行移进动作时才能检测到错误,在这之前可能已额外执行了多步归约动作.LALR(1)和SLR(1)分析器不具备立即错误侦测性质[7],但所有LR类分析器都满足正确前缀性质.(2)错误报告.分析器需要以恰当的形式报告侦测到的错误.文献[8]总结了良好的错误报告应满足的几个指标:①正确报告错误,不误报、漏报错误;②尽早报告错误;③错误报告友好,应基于直观的文法和输入串,而不是抽象的分析状态和分析动作;④避免重复报告相同错误;⑤分析器应能从错误中恢复,从而可以侦测后续的更多错误.(3)错误恢复.错误恢复是指,遇到非法符号时,适当调整分析栈和输入串,使分析过程可以继续进行.包括更正性、非更正性两类错误恢复方法.其中,前者修改分析栈或输入串;后者不修改,而是跳过一个或多个符号,从输入串某个位置继续分析.Error产生式[9]是应用较多的一种更正性错误恢复方法,通过插入形如“A→αerrorβ”的产生式执行恢复.其中,error被当作特殊的终结符,遇到错误后,Follow(error)[8]成为同步符号.error产生式恢复效果较好,但依赖于开发者的个人技巧,无法实现自动的错误处理和恢复.除error产生式外,也存在基于短语的错误恢复[7]、局部错误恢复[10]、全局错误恢复[11]等其它更正性错误恢复方法.其中,基于短语的错误恢复方法恢复能力较强,但处理效率较低,有时不得不借助其它的恢复策略(如后文提及的恐慌式错误恢复)执行二次恢复.局部错误恢复效率较高,但有时也不得不二次恢复.全局错误恢复理论上效果最好,但时空复杂度太高.非更正性错误恢复中最常用的是“恐慌式错误恢复”(panicmoderecovery)[8].其恢复策略是,从错误符号开始,跳过若干个输入符号,直至遇到某个可接受的同步符号.该方法的优点是实现容易;缺点是恢复效果依赖于同步符号定义的优劣,且跳过的部分未做检查,可能包含语法错误.Richter[12]提出了另外一种非更正性的错误恢复方法(后文简称Richter算法).其算法依据是,错误符号后的字符串可能是文法中某个句子的子串或后缀.在介绍该算法前,先介绍几个相关概念.定义1.后缀语言、后缀文法、后缀分析器.令上下文无关语言L对应的文法为G,文法G对应的分析器为M.如果语言L的所有句子由且仅由语言L句子的后缀组成,则称L为L的后缀语言;L对应的文法G称为G的后缀文法;文法G对应的分析器M称为M的后缀分析器[12].基于定义1的表述,标准Richter算法的分析过程如下:启动分析器M分析输入串,遇到错误符号时,M报告错误,并启动后缀分析器M继续分析.若M又遇到语法错误,则M报告错误,同时将M重置到初始状态,继续对剩余串执行分析.Richter算法具有不重复报告错误、不报告虚假错误、能一次侦测多个错误的优点,但也存在明显缺点:(1)后缀文法可能引入分析冲突.即使原始文法是确定性文法,其后缀文法往往也不是确定性文法.采用传统的LL(k)、LR(k)方法难以分析该类后缀文法;(2)标准Richter算法在后缀文法中增加了大量产生式,分析性能低.Page3也存在其它LR错误恢复方法[13-15].这些方法针对特定对象有比较好的恢复效果,但依赖于分析对象特点和设计者的个人技巧,不适合作为通用分析器生成器的自动错误处理和恢复方法.3GLR错误侦测GLR分析栈相当于多个并行的LR分析栈,只要存在语法错误,各个分析栈总能侦测到,满足“正确侦测错误”这一指标.GLR错误侦测的效果与底层采用的分析表密切相关.首先考察采用LR(1)分析表的情形.LR(1)具有立即错误侦测性质,从单一分析栈上看,采用LR(1)分析表的GLR分析器也具有立即错误侦测性质.但与LR分析器不同,GLR并行试探所有可能的分析分支,因此,当一条LR分析栈侦测到错误时,还不能立即认定为语法错误,还需要试探其它分析分支.只有所有的LR分析栈都遇到语法错误,才能真正报告错误.因此,即使采用LR(1)分析表,GLR也不具备立即错误侦测性质.对于采用LALR(1)或SLR(1)分析表的GLR分析器,由于每条分析栈本身就不具备立即错误侦测性质,GLR分析器也不具备该性质.综上,不管采用哪种LR分析表,GLR方法都不满足立即错误侦测性质,但满足正确前缀性质.4GLR错误恢复本文认为,Richter算法适合作为GLR分析器的错误处理和恢复方法.除上文提及的不重复报告错误、不报告虚假错误、能一次侦测多个错误等原因外,选择该算法还有其它几个原因:(1)该算法具备语言无关性,能满足通用GLR错误恢复方法的语言无关性要求;(2)不更改输入串和分析栈,避免了修改GLR图栈带来的复杂性;(3)无需手工修改文法,对开发者的个人技巧依赖较少;(4)GLR算法能容忍后缀文法的二义性,可弥补Richter算法应用于确定性分析器生成器的不足;(5)后缀文法和后缀分析器可自动构造,便于实现自动化的错误处理和恢复.原始Richter算法没有给出子串分析器的构造算法,且后缀分析器规模过大.Rekers给出了一个实用的子串分析器构造算法,优化了后缀文法构造,避免了文法规模过大问题[16].本文选择以Richter算法和Rekers的子串构造方法为基础,对其进行优化和改进,使之能应用于GLR的错误处理和恢复.Richter算法和Rekers算法应用于GLR分析器的自动错误处理和恢复时,存在4个方面不足,下面针对这4个方面的问题给出相应的解决方案.1)前面的语法错误可能掩盖后续的语法错误.不仅Rekers算法如此,所有基于Richter方法的子串构造算法都存在该问题,看一个具体例子.例1.多行注释是常见的语法结构,通常把它当作无效语法成分,在词法分析阶段滤除.但在优质打印(prettyprinter)程序中,多行注释却是有效语法成分.对于图1所示实例,若遗漏了“/”,后续的输入串会被子串分析器正常识别,直至遇到“/”.在这种情况下,遗漏了“/”会掩盖后续所有错误,导致错误侦测失效.为解决错误掩盖问题,本文引入了一个特殊属性“disable_substring”.在文法描述时,可以附着在产生式后,禁止对该产生式进行子串匹配.比如,对于例1,可添加图2所示的disable_substring属性声明,以解决错误掩盖问题.多行注释→/不含/的任意字符串/{disable_substring}2)可能导致无限死循环.对于形如A→αAβ的产生式(其中,α、β代表任意终结符、非终结符的组合,但不能同时为空串,否则该规则为有害规则[8]),若子串分析器只识别了右侧的结构A,这种情况下执行归约可能使算法陷入死循环.Rekers算法对此类情况没有进行判别,本文对此进行了修正,禁止对此类表达式归约.3)分析效率低.Rekers算法的设计目的是支持语法制导编辑器的字符串自动补全,其分析的输入串通常很短,性能方面能满足设计用途,但将其应用到GLR的错误处理和恢复,却存在严重的性能瓶颈,主要表现在以下几方面:从错误符号开始的输入串,可能是多个句子的子串,算法会并行试探所有可能的分支;分析过程中遇到冲突将导致图栈裂变,降低GLR的分析速度;标准的GLR移进和归约动作执行复杂,执行性能低.严格来讲,后两项不属于Rekers算法的固有缺陷,而是GLR方法的缺陷.但一个实用的错误恢复方法,必须能同时处理合法输入串和非法输入串,二Page4者的分析性能都很重要.本文从以下3方面对上述性能瓶颈进行了优化.(1)缩减恢复分支数量错误符号后的子串可能匹配多个恢复分支,标准Richter算法会为每个分支启动一个子串分析器.如果分支数很多,将严重影响算法性能.为解决该问题,本文设计了交互式的分支选择算法,图3给出了算法的执行流程.分析器开发者可根据已分析的前文,筛选出可行的恢复分支,减少并行执行的子串分析器数量,进而提高执行速度.if(PARSING_ERRORorACTION[topstat,lookahead]>1){selected=UsrSolvingRoutine();/回调用户的错误处理例程或switch(selected){caseRi:DoReduce(ruleRi);/按照产生式Ri归约/break;caseSi:DoShift(statei);break;default:DoAll(topstat,lookahead);/执行所有可能的分析动作/}}(2)减少图栈裂变分析冲突会造成图栈裂变,导致GLR执行速度变慢.本文采用两种手段减少图栈裂变:一是采用图3的交互式分支选择算法,对多个冲突分支进行剪枝;二是采用更强能力的分析表.显然,采用LALR(1)、LR(1)等强能力分析表比采用LR(0)表遇到的冲突少.此外,增大向前看符号k,也可以减少冲突.理论上讲,GLR分析器可以使用任何类型的LR分析表.采用哪种类型的分析表,采用多大的向前看符号长度,分析效率最高呢?对于第1个问题“采用什么类型的分析表”,文献中提及的GLR算法多采用LR(0)表,主要用于自然语言分析.自然语言文法规则众多,并且高度歧义,这两个特征决定了LR(0)表更适合作为其GLR分析器的分析表.因为LR(0)表在LR类分析表中状态数最少,构造和查询效率最高.自然语言是典型的高度二义性文法,大多数冲突为全局二义性冲突,不能通过展望更多向前看符号予以解决.应用于自然语言处理的GLR分析器,采用LALR(1)等强能力分析表比采用LR(0)表分析效率并无明显提升[17].程序设计语言文法与自然语言文法不同.首先,文法规模小,远低于自然语言文法[18],分析表构造和查询效率较高.其次,文法歧义较少,且大部分属于局部二义性,一般可通过向前展望一个或多个符号予以解决.对于程序设计语言文法,采用LALR(1)等强能力分析算法,一般可明显增强算法的识别能力.对于第2个问题“采用多大的向前看符号长度”,Parr[19]对22种程序设计语言分析器的向前看符号长度进行了研究,约有98.8%的分析决策只需展望一个向前看符号(k=1).如果k=n(n>1)不能确定分析决策,那么k>n通常也不能确定[17],即k值的增大并不能显著增强分析器的识别能力.这说明,对于程序设计语言的语法分析,k=1是最实用的向前看长度.综上,应用于程序设计语言分析的GLR分析器,采用SLR(1)、LALR(1)、LR(1)等强能力分析表比采用LR(0)分析表理应获得更好的分析性能.SLR(1)、LALR(1)、LR(1)3种分析表哪种更合适呢?进行一下定性分析.SLR(1)通过计算非终结符的Follow集,可以处理部分LR(0)无法分析的文法,分析能力略强于LR(0).LR(1)是3种分析表中能力最强的,但构造分析表的时空代价很高.LALR(1)分析能力介于SLR(1)和LR(1)之间,其分析表规模和LR(0)相同,远小于LR(1)的分析表规模,但和LR(1)分析能力接近.本文选择LALR(1)作为GLR分析器的分析表,尽管其存储和查询效率低于LR(0),但程序设计语言的文法冲突较少,且绝大多数为局部二义性冲突,可以通过向前展望一个或多个符号予以解决,采用LALR(1)分析表可有效减少GLR的图栈裂变,理应使算法获得更好的总体性能.对于LALR(1)分析表的自动构造,教科书[7-8]介绍的方法是合并LR(1)自动机中的同心项目集.这种方法易于理解,但效率很低.在实践中,人们之所以使用LALR(1)分析表而不用LR(1)分析表,主要原因就是构造LR(1)分析表的时空代价较大.显然,合并同心项目集方法存在同样问题.YACC[20]、Bison①等LALR(1)分析器生成系统采用的是另外一种方法.该方法包含两个步骤:首先,根据文法构造其LR(0)自动机;其次,以LR(0)自动机和文法为输入,计算LR(0)项目的LALR(1)向前看符号集.本文研究小组采用了类似的方法,自行设计实现了LALR(1)分析表的快速生成算法[21].采用LALR(1)分析表可以自动消除程序设计①FreeSoftwareFoundation.Bison-GNUparsergeneratorPage5语言文法中的常见二义性冲突.对于其它的分析冲突,GLR算法将模拟多个LR分析器,沿着所有可能的冲突分支执行分析,最终可能出现两种不同性质的冲突:(a)局部二义性冲突.这种冲突是由于向前看符号长度不够引起的,会导致图栈的暂时分裂,读入足够多的符号后,GLR会自动选择正确分支,废弃错误分支;(b)全局二义性冲突.这种冲突是由于文法的全局二义性引起的,会导致图栈的永久分裂,用户需要进一步对其剪枝消歧.(3)优化移进和归约执行动作GLR分析的实质是,模拟多个并行的LR分析栈.即使分析栈并未裂变,是简单的线性栈,GLR仍要执行复杂的移进、归约检查.这是造成其性能瓶颈的重要原因.本文根据图栈的结构特征对移进和归约这两种主要的分析动作进行了优化,让GLR分析器在不同条件下执行不同类型的分析动作.动的栈顶状态;(a)图栈是一条线性栈,尚未分裂,只有一个活(b)对于某个活动栈顶状态n和输入符号t,只存在一个归约动作:ACTION[n,t]=RA→α,其中,产生式A→α的右部符号长度|α|j-i,j是栈顶状态n所在结点的同步位置,i是距离该结点最近的分支结点的同步位置.本文将GLR算法在每一个分析步累计读入的符号数称为同步位置,并在算法中增加了同步位置的计数器.同步位置的概念可用图4说明,各个结点的同步位置已在顶部用虚线标出.图栈的分支结点是指入度或出度大于1的状态结点.比如,图4中结点0、4、5均为分支结点.针对移进动作的操作优化GLR移进动作的主要开销是,每次移进后均要比较新增状态是否存在于活动栈顶状态集中,并检查是否需要合并分析栈.在很多情况下,GLR图栈并未分裂,是一个简单的线性栈,此时只需直接移进,无需进行上述比较和检查.根据图栈是否已分裂,本文把移进动作分为两类:(a)直接移进.执行直接移进动作,此时不进行(b)标准移进.执行标准GLR移进动作,此时需要跟活动栈顶状态集比较,若栈顶状态有重复,执行分析栈合并.活动栈顶状态集比较和分支合并检查;针对归约动作的操作优化程序设计语言语法冲突较少,图栈在大多数情况下为线性栈或近线性栈.因此,在算法运行的绝大部分时间,图栈的结构特征满足下列两个条件中的一个或两个:在一个活动栈顶状态,按某一产生式A→α的归约动作可分为3类:(i)直接归约.若图栈的结构特征满足上述条件(a),则执行直接归约动作,此时,只需从栈顶弹出|α|个状态,然后压入新栈顶,无需在活动栈顶结点集中搜索和判断新增状态是否存在,无需搜索和维护归约路径.(ii)简单归约.若图栈的结构特征不满足上述条件(a)而满足条件(b),则执行简单归约,执行流程跟直接归约相同.(iii)标准归约.若图栈的结构特征既不满足条件(a),也不满足(b),则执行标准GLR归约.采用上述优化策略后,分析程序设计语言语法时,大部分情况下分析栈处于线性结构,GLR主要执行直接移进和直接归约两种动作.即使分析过程中遇到少量冲突,图栈的结构特征在大部分时间内也满足条件(a)或条件(b),算法执行的主要动作仍然是时空开销较小的直接移进、直接归约或简单归约动作.4)缺少必要的错误处理和控制机制.Rekers算法虽然给出了子串分析器的构造算法,但设计意图不是用于分析器的错误处理,缺少必要的运行时控制机制.因此,需要对其进行调整,使其支持GLR分析器的自动错误处理和恢复.算法1和算法2给出了本文设计的错误处理和恢复算法伪代码.算法1中的步1和2直观易懂,不再赘述;步3可采用算法2执行分析.算法1.GLR错误处理和恢复算法.输入:文法G=(N,T,P,S),输入串输出:输入串的分析结果(分析树或分析森林)步骤:1.为文法G生成LALR(1)分析表M、GLR分析器和子串分析器;Page62.利用GLR分析器分析输入串.若无语法错误,分析结束;若有语法错误,启动子串分析器对剩余输入串serr执行分析.若定义了交互式错误恢复例程,利用该例程对可用恢复分支剪枝;3.利用算法2对剩余输入串serr执行分析.算法2.GLR子串分析算法.输入:文法G=(N,T,P,S),文法G的LALR(1)分析输出:输入串serr的分析结果(分析树或分析森林)1.voidSubstringRecognize()2.{3.IntegerShiftCount=0//移入符号数目置04.TokencurrentToken=serr的第一个符号5.6.//查询分析表M中可以移入当前符号的所有状态7.ArrayInitialShiftStates=LookupShiftState(currentToken)8.while(currentToken!=EOSand//尚未达到输入串结尾9.InitialShiftStates==)//任何一个状态都不能10.{11.//创建新的分析栈,栈顶标记为错误状态结点12.StackNodenewNode=13.从新分析栈newNode栈顶到原分析栈target添加一条14.当前的错误符号作为有向边的语义值15.ShiftCount++//移入符号数目加116.currentToken=serr的下一个符号17.target=newNode//保存当前的分析栈18.//重新查询分析表中可以移入当前符号的所有状态19.InitialShiftStates=LookupShiftState(currentToken)20.}21.//对所有的错误符号执行归约22.ReduceNotParsed(target,ShiftCount)23.24.//若输入串中的每个符号都是错误符号,或M中不存在25.//移入输入串中的下一个符号,直接返回26.if(currentToken==EOSorInitialShiftStates==)27.return28.29.//若找到了可以移入当前符号的一组状态,30.//取出其中的每个状态,令该状态为m31.foreachstateminInitialShiftStates32.{33.创建一条独立的分析栈L,m为栈底,标记m为L的初34.利用L对剩余输入串(即currentToken以后的输入串)35.}36.}37.38.ArrayLookupShiftState(Tokent)39.{40.查找分析表M中的所有状态,找出可以移入符号t的41.returnS42.}算法2中,行首数字为语句行,“//”开头的为程序注释,其它自然语言或伪代码均为有效代码.算法2的执行流程如下:首先,查询分析表M,找到可移入当前符号的所有状态(第7行).如果所有状态都不能移入当前符号,说明该符号为错误符号,跳到下一个输入符号继续检测.这样,可以找出所有连续的错误符号(第8~20行).之后,执行归约把这些错误符号挂接到最终的分析树(分析森林)中(第22行).经上述分析后,如果已到达输入串结尾或者未找到任何状态可移入当前符号,则直接返回(第26~27行);否则,为每个状态创建一条分析栈,对剩余的输入串进行分析(第31~35行).除33~34行语句外,算法2的其它语句均直观易懂.下面介绍一下33~34行代码的处理逻辑.为便于理解,假定执行到33行时剩余的未分析串为t1t2…tn-1tn,则当前符号为t1.若有多个可移入t1的状态或遇到了分析冲突,GLR会创建多条分析栈并行处理.为讨论简单,对其中的一条进行考察,令该分析栈为L1,栈顶状态为m.初始时,L1移入t1,然后对输入串t2…tn-1tn执行分析.在分析过程的某一时刻,面临输入符号ti(2in-1)时,L1有如下可能的分析动作:(1)shiftS.移入ti,将状态S压入分析栈L1,准备处理下一个输入符ti+1;(2)error.从活动栈顶状态中删除分析栈L1的栈顶,废弃分析栈L1;(3)reduce:A→αβ,其中α、β为任意终结符或非终结符的组合.根据分析栈长度|L1|和产生式右部符号串|αβ|长度关系的不同,有3种情况:(3.1)|L1|>|αβ|.这说明产生式A→αβ右部的所有结构完全在分析栈L1中,且L1中某个状态n存在针对A的转移(GOTO关系)状态ngoto.此时按标准的GLR算法归约,从L1弹出|αβ|个元素后,状态n应位于L1栈顶,将ngoto压入L1,分析器准备处理符号ti.(3.2)|L1|=|αβ|.这说明产生式A→αβ右部的所有结构恰好在L1中.执行归约动作,从L1弹出|αβ|后将清空分析栈L1,此时不清楚哪些状态y满足GOTO(y,A)=z,需查询分析表M,找出所有满足条件的状态y.Rekers算法在该步骤会为每个可能的状态都创建一条新分析栈,这可能导致分支数量急剧增长,分析性能显著下降.本文通过两种措施修正:①若产生式右部包含A,检查αβ中除A外的其它结构是否能推导出空串.若能推导出空串,执行归约会令算法陷入死循环,因此应停止归约.若不满足上述关系,则执行第②步骤;②检查是否定义了错误处理回调函数.若存在,利用剪裁的分支继续分析.若未定义回调函数,为每Page7个状态y新建一条分析栈,栈底为y,将y标记为子串分析器的初始状态,利用算法2分析后续子串ti…tn-1tn.(3.3)|L1|<|αβ|.这说明产生式A→αβ右部只有部分结构在L1中.包括3种细分情况:①L1只识别了β,执行归约会识别输入串的前缀,即a1…akt1…ti-1(其中a1…ak为缺失的输入串);②L1只识别了α,执行归约会识别输入串的后缀,即t1…ti-1a1…ak(其中a1…ak为缺失的输入串);③L1只识别了产生式的中间部分,执行归约会识别输入串的前缀和后缀,即a1…akt1…ti-1b1…bp(其中a1…ak和b1…bp为缺失的输入串).步骤(3.3)中L1仅识别了部分子串,可能导致例1提及的错误掩盖问题.需检查A→αβ是否具有disable_substring属性.若有,则不执行此归约.步骤(3.3)中执行归约后将清空分析栈L1.此时,Rekers算法会导致步骤(3.2)类似的问题.可以通过以下措施修正:检查αβ是否包含符号A,若包含A且分析栈L1只识别了A,执行归约将令算法陷入死循环,应停止归约.如不满足上述条件,则执行步骤(3.2)第②步相同的检查处理.步骤(3)的归约动作的伪代码如下所示.boolSubstringReduce(Productionprod,Stackstack){if(|stack|>|prod|)//prod结构完全在stack中{return执行标准GLR归约过程}elseif(|stack||prod|){if(|stack|<|prod|){if(prod具有disable_substring属性)}NonterminalA=prod左侧非终结符if(|stack|==|prod|andprod右侧包含A){//若prod右侧A的左右符号均可推出空串,停止归约if(Nullable(LeftA)andNullable(RightA))returnfalse//拒绝归约}if(|stack|<|prod|andprod右侧包含A且stack上仅识returnfalse//该归约可能陷入无限死循环,拒绝归约//从分析表查找可以移入(GOTO关系)A的所有状态StateSetallStates=LookupGOTO(A)//调用用户自定义的错误处理回调函数StateSetfilterStates=UserFilterCallBack(prod,stack,emptystack//清空现有分析栈//取出集合filterStates中的每一个状态,令该状态为mforeachstateminfilterStates{新建分析栈L,其中m为栈底,标记m为L的初始结点,利用L对剩余字符串进行分析}returntrue//返回true表示接受并处理了归约}}5实验结果为验证算法的有效性和性能,本文设计了两组实验.第1组(5.1节),通过实例剖析算法的执行过程,评价算法的错误报告效果.第2组(5.2节),通过构造Java分析器,评价算法性能.5.1算法运行剖析及错误报告评价例2.图5给出了一个文法G[S],表1是该文法对应的LALR(1)分析表.从表1可看出,状态5包含reduce-reduce冲突.G[S]可接受的符号为i、j、k.输入串iij是文法的合法句子,给其植入两类典型错误:一类是文法不识别的输入串;另一类是文法可识别但非法的输入串(图6).算法的执行步骤如下所示.1.初始时执行正常GLR分析,得到的分析栈如图7所示.其中,方块表示状态,状态间的箭头表示状态的构造关Page8系,箭头上的连线表示语义值;2.执行归约检查:活动栈顶为状态13,向前看符号为m,不能执行任何归约动作.执行移进检查:活动栈顶为状态13,不能移入符号m,GLR分析器报错,启动子串分析器进行错误处理;3.子串分析器的输入符号串为mnik.表1中不存在能移入符号m、n的任何状态,循环执行算法2中第8~20行处的代码两次,子串分析器报错,把错误符号串挂接到最终的分析结果中(图8);图8执行错误处理:把非法符号mn挂接到结果中4.执行算法2中第8~20行代码,currentToken=i.执行19行处的语句,InitialShiftStates={0,2,10,12,15},可移符号i的状态共有5个.为展示错误处理算法的完整运行效果,此处不执行交互式剪枝.执行算法2中31~35行处的代码,为5个状态分别创建分析栈(a)、(b)、(c)、(d)、(e)(图9);5.子串分析器移入i(图10).注意:5条栈对应5种不同的错误恢复决策,不能执行栈合并;图10执行错误处理:5条分析栈均移入符号i6.对5条栈分别执行子串分析.以分析栈(a)为例.①执行归约检查.活动栈顶为状态5,面临的向前看符号为k,应执行归约动作R8,即用产生式G→i归约.此时,分析栈长度为2,归约产生式长度|G→i|=1,执行GLR标准归约,分析器到达状态6.状态6在输入符号为k时执行动作R9,即用产生式E→G归约,此时,分析栈长度为2,归约产生式长度|E→G|=1,执行GLR标准归约,分析器到达状态4;②执行移进检查.活动栈顶为状态5、6、4.状态5、6不能移入符号k,这两条分支被废止.状态4执行动作S11转移到状态11(图11);③执行归约检查.活动栈顶为状态11,面临的向前看符号为$,不能执行归约;④执行移进检查.活动栈顶为状态11,输入串已读取完毕,不能移入符号$,且分析器不处于接受状态,分析栈(a)分析完毕,报错退出(图12);图11执行错误处理:分析栈(a)执行第一次归约-移进图12执行错误处理:分析栈(a)分析完毕,发现错误对分析栈(b)、(c)、(d)、(e)执行子串分析后,最后得到的分析结果如图13~图16所示.图13执行错误处理:分析栈(b)分析完毕,发现错误图15执行错误处理:分析栈(d)分析完毕,发现错误Page97.步6的5条栈都分析完后,需要把子串分析器的分析结果合并到最终结果中.其中,分析栈(a)、(b)、(d)可以分析完全部输入串;分析栈(c)和(e)不能分析完输入串,中途报错停止.错误恢复的本质是从多个可能的恢复决策中选择“最合理”的决策.如果用户知道如何处理错误,可利用图3的交互式算法剪枝.否则,算法自动选择“最合理”的决策.本文算法判断分支是否合理的依据是看输入串的分析程度,能分析越多输入串的分支,算法认为其恢复效果越好.如果两个恢复分支能分析的输入串符号数量相同,选择其中的第一个.本例中用户没有交互式剪枝,按上述逻辑,分析栈(a)的结果应作为最终分析结果,最后得到的完整的分析树(分析森林)如图17所示.以上对本文设计的GLR错误处理和恢复算法进行了详细剖析.下面针对错误报告的主要指标,结合例2,评价算法的错误报告效果.(1)正确报告错误.对于植入的两类典型错误,算法都能有效侦测,没有错报和漏报错误,符合该指标;(2)能尽早报告实验编号源文件行数单词数VPGE(tree)VPGE(notree)Bison(notree)表2VPGE和Bison生成的分析器性能对比执行时间/clock309346143103183268648474862321115525327132569829632181310295746169815220452823765607906324398177512855410136864838620881128831957742662278403799165349515238818843035259938160078894322585963694617221659329281283975175397757969437820错误.从例2可看出,错误的侦测点和错误的产生点并不一致,不满足立即错误侦测性质,但满足正确前缀性质,部分符合该指标;(3)错误报告友好.从例2可看出,算法能获知错误发生时的产生式和输入串的处理位置,符合该指标;(4)避免重复报告相同错误.符合该指标;(5)能一次侦测尽可能多的错误.从例2可看出,算法可以从两类典型语法错误中恢复,能侦测后续错误,符合该指标.5.2算法性能评价本文给出4组实验结果以评估算法性能.实验1评估正常GLR分析时的分析性能;实验2考察正常GLR分析切换到子串分析时的性能;实验3考察输入串中的错误数量对算法性能的影响;实验4考察子串分析和正常GLR分析的性能对比.实验1.正常GLR分析性能.为验证正常GLR分析的性能,本文用项目小组研制的VPGE分析器生成器和目前公认的应用最广、速度最快的LALR(1)分析器生成器Bison各生成了一个Java1.4版分析器.Java1.4的官方文法采用EBNF范式定义,本文将其改写为BNF范式,共包含216条产生式.对于该文法,Bison报告235个语法冲突,共317个LALR(1)自动机状态.由于LALR(1)分析器不能分析冲突文法,本文对文法进行了改写,改写后包括278条产生式,Bison报告0个冲突,448个LALR(1)自动机状态.选择Java文法的原因有两方面.一方面,Bison生成的LALR(1)分析器不允许分析表中存在冲突,而Java1.4文法恰好可以改写为LALR(1)文法;另一方面,Java文法在程序设计语言文法中属于中等规模复杂度文法,具备了命令式程序设计语言的各种典型语法特征.利用改写后的Java文法,笔者用VPGE生成了GLR分析器,用Bison生成了LALR(1)分析器.两个分析器都由C语言实现,只执行语法分析,不执行用户自定义的语义动作,表2是两者的时间性Page10能对比①.从表2可看出,VPGE生成的GLR分析器比Bison生成的LALR(1)分析器执行语法分析慢2~5倍.考虑到实际分析器中语法分析所占的时间比重很小(参见表3),大部分时间都消耗在语义动作等其它开销上,而语义动作等其它代码是用户编写的,可认为两个分析器执行这部分代码的时间相同.因此,即使VPGE生成的分析器语法分析速度比Bison生成的分析器慢些,并不会显著影响总分析速度.得出该结论的前提是,纯语法分析时间占总分析时间的比重要足够小.为考察这一点,看一下例3.例3.上文Bison生成的Java分析器只执行语法分析,不执行任何语义动作.GNU的Java编译器使用了同样的文法,它执行语法分析、语义动作、代码优化、代码生成、程序链接等各个过程.本文用Bison生成的Java分析器和GNU的Java编译器对同一组测试文件分析,这样就可估算出一个实际应用中纯语法分析时间的比重,表3给出了实验数据.源文件实验编号1224545814129803881800.01522201058125533748433510090.02534111772188637630311656180.062410674908439815635557382980.12454636215481793087973563332250.244686324026833088567116804859550.2837137386418852520276171585565470.3068180988498869854687224669178380.31192251810578887535785274146975720.3191038152178588146215954444131565040.329从表3可看出,在源文件规模较小时,语法分析时间的比重很小.随着源文件规模的增大,语法分析时间比重逐渐增大,最后稳定在0.320%左右.基于上述数据,考察一下VPGEGLR分析器和BisonLALR(1)分析器的总分析速度对比.令Bison生成的LALR(1)分析器总执行时间为Tb,语法分析时间占总执行时间的百分比为m;VPGE生成的GLR分析器总执行时间为Tv,对同样的文法进行纯语法分析时(不执行任何其它动作)比Bison的LALR(1)分析器慢k-1倍(k>1),则Tb和Tv满足根据表3数据,m值约为0.320%,k的值为3~6,给k取平均值4.5,可得到Tb/Tv=98.89%.这说明,若Bison生成的LALR(1)分析器执行语法分析时间占总执行时间的0.320%,VPGE生成的GLR分析器执行纯语法分析比Bison生成的LALR(1)分析器慢3.5倍(k=4.5),则VPGE生成的GLR分析器总速度大约是Bison生成的LALR(1)分析器总速度的98.89%.综合上述分析,可推论:若文法为无二义性的LALR(1)文法或者包含少量冲突的近LALR(1)文法,VPGE生成的GLR分析器和Bison生成的LALR(1)分析器总执行速度具有可比性.GLR算法历史上经历过多次改进,Rekers[22]做出了最后一次重要修正,使其能处理文法中的循环产生式和ε-产生式,并且在ASF+SDF元环境中进行了实现验证.文献[22]中报告Rekers生成的GLR分析器比YACC生成的LALR(1)分析器慢10至20倍,该文献没有说明使用的YACC版本,事实上,作为YACC的升级软件———Bison在性能方面已优于YACC.由此可以推断,本文实现的GLR算法性能优于Rekers实现的GLR算法.从表2还可看出,构造分析树(分析森林)消耗了大量时间.Bison不构造分析树(分析森林),不支持语法分析后的剪枝消歧,限制了分析器调试和语义处理的灵活性.VPGE中是否构造分析树(分析森林)可通过开关控制.调试过程中,可构造分析树(分析森林),这样尽管分析时间较长,却给调试带来了方便.调试完毕后,可禁用分析树构造,以提高分析性能.实验2.正常GLR分析切换到子串分析的性能.本例在测试源文件中植入一个错误,通过插入探针确定执行时间,表4给出了实验结果.从中可看出,不同规模(行数)的源文件,从正常GLR分析切换到子串分析的时间开销基本一致.实验编号源文件行数单词数执行时间/ms123456781600788942932928128396①实验机配置:AMDAthlon(TM)XP2500+、1GRAM、Page11实验3.输入串的错误数量与算法性能关系.本例测试源文件约16000行,给其随机植入不同数量的错误,表5给出了实验结果.从中可看出,子串分析器的执行速度跟输入串的错误数量密切相关,错误越多,执行时间越长.表5还给出了植入错误和检出错误的对比,从中可以看出,算法具有良好的错误侦测能力.实验编号单词数植入的188941128893210388918204889034058887070688828110107189007887811601582445688872322021727904实验4.子串分析与正常GLR分析的性能对比.本例采用实验2相同的测试文件,表6给出了错误植入前后的执行时间对比.从中可看出,子串分析的性能跟输入串规模正相关,输入串越长,算法执行时间越长.从表6还可看出,子串分析的性能较正常GLR分析性能低,比后者慢2~3倍左右.表6子串分析器跟标准GLR分析器性能对比实验编号14310210232111543218130945282375512855409620881128717579916534948338160078894212349329281283962828Rekers算法主要用于可视化编辑器的字符串自动补全,缺少本文算法的运行时错误处理和恢复机制.文献[16]中给出的输入串长度都很短,最长包含500个符号,植入一个错误时执行时间约为0.4s.从表6可看出,本文算法分析1154个符号(植入一个错误)耗时约22ms.文献[16]只提及测试机环境是SUNSPARC工作站,无从确知其速度与笔者计算机速度的关系,单纯从执行时间上不能判断出两者的绝对速度关系.6结论本文以Richter算法和Rekers算法为基础,借鉴LR的错误处理策略,设计实现了GLR的错误恢复算法.分析了Richter算法和Rekers算法存在的问题,从4个方面进行了优化:(1)解决了原算法存在的错误掩盖问题;(2)修正了原算法可能的死循环问题;(3)优化了算法的执行速度;(4)添加了必要的运行时错误处理和恢复机制.实验部分通过一个完整实例,剖析了算法的执行过程,评价了错误报告效果.通过Java程序设计语言的系列实验,评价了算法在GLR错误处理和恢复时的性能.通过表6可以看出,子串分析比正常GLR分析慢2~3倍,后续需进一步优化子串分析性能.实际分析场景中,正确串一般占绝大多数,错误串只占少数.在这种情况下,主要执行正常GLR分析.本文算法对此已做过多层次优化,分析效率较高.此外,用户也可以通过交互式的分支选择例程,进一步提升算法性能.综合上述分析,可以得出结论,本文算法可用于程序设计语言GLR分析时的自动错误处理和恢复,具备实际推广应用价值.
