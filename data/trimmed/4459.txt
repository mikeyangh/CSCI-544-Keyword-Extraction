Page1一种基于Hash函数和分组密码的消息认证码徐津1),2)温巧燕1)王大印3)1)(北京邮电大学网络与交换技术国家重点实验室北京100876)2)(北京电子科技学院北京100070)3)(中国科学院信息工程研究所北京100093)摘要基于Hash函数的HMAC是一种应用最为广泛的消息认证码,但最近的研究指出HMAC不仅易受到相关密钥攻击,在多用户环境下也易受到攻击.为了避免这些问题,我们对HMAC进行了改进,基于Hash函数和分组密码设计了一种新的消息认证码HBMAC.在分组密码是伪随机置换和Hash函数所使用的压缩函数是伪随机函数的基本假设下,使用共享随机函数模型证明了HBMAC的安全性.同时,还提出了HBMAC和HMAC的算法实现,并基于典型数据对两种算法的性质和效率进行了分析.结果表明,与HMAC相比,HBMAC在安全性和效率上取得了更好的折衷.关键词消息认证码;压缩函数;分组密码;伪随机置换;可证明安全;密码学1引言网络技术的迅猛发展给人们带来方便之际,也Page2有的通讯都会受到攻击者的攻击.2002年美国公布的旨在确保国家信息安全的《联邦信息安全管理法案》中,定义“信息安全”是保护信息和信息系统,以避免未授权的访问、使用、泄漏、破坏、修改或者销毁,确保信息的完整性、保密性和可用性.其中,完整性是指防止不恰当的信息修改和破坏,也确保信息的不可否认性和可认证性;保密性是指对信息访问和公开的授权限制,包括对个人隐私和私有信息的保护;可用性是指对信息的及时和可靠的访问.鉴于信息安全受到的威胁,需要密码学提供一种机制,来保证信息的私密性、完整性和不可否认性等.其中使消息的接收者可以验证该消息确实是来自所声称的主体,且在传输的过程中未曾受到未经授权的截取、重发、修改、伪造或插入消息,即为保证消息的完整性.密码学中用来保证消息完整性的重要工具就是消息认证码(MessageAuthenticationCodes,MAC).在网络通信和电子商务中,很多时候数据的完整性是至关重要的,因此消息认证码得到了快速的发展,现已广泛应用于各类Internet协议,如IPSecurity(IPsec)①、SecureSocketsLayer(SSL)②/TransportLayerSecurity(TLS)③、SecureShell(SSH)④、SimpleNetworkManagementProtocol(SNMP)⑤等.此外,很多标准化组织也开始了消息认证码的标准化工作.日本、英国和中国采用的MAC标准是国际标准ISO/IEC9797中的Cipher-BlockChainingMessageAuthenticationCode(简记为CBC-MAC)和Hash-basedMessageAuthenticationCode(简记为HMAC),韩国的标准等同于国际标准RFC4493.MAC的保护机制:首先在参与通讯的双方间通过秘密信道共享一个密钥K,双方通过公开信道通讯时(这里使用Alice和Bob分别代表参与通讯的两方),Alice如果要传送一个消息给Bob,首先将这一消息使用MAC生成算法和共享密钥K计算出一个认证标记,称为MAC值,然后将此标记附加在这一消息之后一起传送给Bob.接收后,Bob使用MAC验证算法和共享密钥K计算接收到消息的认证标记,并和他所接收到的标记进行比较.如果两个标记相同,MAC验证算法输出为1,Bob就认为消息在传送过程中没有被未经授权的篡改;如果两个标记不相同,MAC验证算法输出为0,Bob就认为消息在传送过程中被篡改了.MAC的保护机制过程如图1所示.MAC的攻击类型:根据攻击者的攻击对消息完整性安全造成的危害,针对MAC的攻击分为下面几种类型.(1)存在性伪造(ExistentialForgery).攻击者构造了一个消息,并伪造了该消息的认证标记.如果该消息和伪造的认证标记以几乎为1的概率通过验证,即使这个消息有可能没有意义,但是在存在性伪造下也称对消息认证码的攻击成功.(2)选择性伪造(SelectiveForgery).攻击者可以选取某个消息伪造其认证标记,并以几乎为1的概率通过验证.(3)通用性伪造(UniversalForgery).攻击者可以选取任意消息伪造其认证标记,并以几乎为1的概率通过验证.(4)密钥恢复(KeyRecovery).攻击者能恢复密钥,这样一来攻击者和Alice一样,可以生成任意消息的合法的认证标记.类似于加密机制,这种攻击是最具破坏性的.此外,区分攻击也是一类攻击方法,有专门针对使用前缀的消息认证码的区分攻击,如文献[1].还有将消息认证码和随机函数进行区分的R-型区分攻击(Distinguishing-RAttack),以及将消息认证码内部的具体密码元件和随机函数进行区分的H-型区分攻击(Distinguishing-HAttack).详细定义见文献[2].根据攻击者的能力大小,针对MAC的攻击又可以分为下面几种类型.(1)无消息攻击.攻击者无法获得任何消息及①②③④⑤Page3其对应的合法认证标记.(2)已知消息攻击(knownmessageattack,简记为kma).攻击者能知道一些消息及其相应的合法认证标记.(3)选择消息攻击(chosenmessageattack,简记为cma).攻击者能选取一些消息并得到其相应的合法认证标记.其中,选择消息攻击是最强的,它赋予攻击者最大的能力,而存在性伪造则是攻击成功中相对最弱的,对消息的完整性构成的危害也最小.本文在讨论消息认证码的安全性时,主要考虑其在选择消息攻击下的不可伪造性.本文第1节是引言,介绍消息认证码的重要性和现实意义;第2节介绍本文中用到的基本符号;第3节给出消息认证码的安全模型、HMAC的定义及安全性;第4节给出一种全新的消息认证码HBMAC的定义及其安全性证明;第5节对HBMAC进行优势分析;第6节为总结和展望.2基本记号下面给出本文中用到的密码学基本符号和定义.二进制串(string)是指一个由0和1组成的有限序列,也称为比特串.一个特定对象的上标n则意味着该对象的长度为n.例如0d意味着长度为d的0串,{0,1}n则表示长度为n所有的二进制串.块(block)是一个长度固定的二进制串,该长度称为块的长度.|X|表示串X的比特位长度.如果X是一个空串,则|X|=0.在对比特串的处理过程中,经常将其分成块,例如串X可以按n比特分成m=[|X|/n]块,其中最后一块可能少于n比特,其余的块都是n比特.‖M‖表示所分成的块的个数.X‖Y表示串X和Y的连接,例如x‖σ表示串x和σ的连接.F(·,·)表示函数F具有两个输入,有时使用如下写法:F(k,x)=Fk(x).攻击者(Adversary)又称敌手,是指攻击密码方案的算法,这个算法通常是随机的,简记为A.预言机(Oracle)是指攻击者A能访问的资源,例如加密算法、解密算法等.攻击者A用到的OracleO一般放在A的右上角,用AO表示.AO=1表示能访问O的攻击者A最后输出1的事件,AO=0表示能访问O的攻击者A最后输出0的事件.O(·)表示OracleO有一个输入,如果需要表示AO输出的值,用x←AO(·)表示,其中x的类型同AO输出的类型一致.Rand(a,b)表示所有从集合a到集合b的函数.如果m和n是整数,那么Rand(m,n)表示所有从集合{0,1}m到{0,1}n的函数的集合.Perm(a)表示所有在集合a上的置换的集合.Perm(n)表示{0,1}n上所有置换的集合.这个集合也可以看成是所有的由集合k中元素唯一确定的置换的集合.x←$B表示从一个集合B中随机地选取一个元素.例如符号ρ←$Rand(a,b)表示随机地从集合Rand(a,b)中选取一个函数.π←$Perm(n)表示随机地从集合Perm(n)中选取一个置换.Pr[K←{0,1}n:AF(·)=1]表示在密钥K随机选择的情况下,拥有OracleFK(·)的攻击者A返回1的概率.分组密码Ek可以看成是这样一个函数:其中,k是有限集并且每个Ek(·)是一个在集合{0,1}n上的置换,通常也可写作E(k,·).3相关工作3.1可证明安全性早期的密码算法是没有安全性证明的,其安全性都是基于安全性分析的,在理论上不能完全保证其安全性.密码研究者们提出一个设想:定义一个主安全属性,算法只要满足这一属性就能完全保证它的安全性.基于这一设想密码研究者们提出了可证明安全理论.对应于Shannon[3]的完善安全性,1984年,Goldwasser和Micali在文献[4]中提出了语义安全(semanticsecurity)的定义,首次从计算角度给出了加密方案的安全性定义,这篇文章标志着现代密码学可证明安全研究的开始.这里的可证明安全性是指:在讨论整个密码方案的安全性的过程中,通过归约(reduction)的方法,将方案的安全性归结为底层密码学原语(primitive)的安全性,即证明如果原语是安全的,那么方案也是安全的,或者证明如果存在攻破方案安全性的算法,那么利用此算法,可以构造出攻破原语安全性的算法.这里的原语是密码学中Page4最基本的研究单位,例如困难问题、分组密码、Hash函数等.一般来讲,由公钥密码构造的算法归约到困难问题,由对称密码构造的算法则归约到分组密码,由Hash函数构造的算法归约到Hash函数.一般来说,根据构造方法的不同,消息认证码的安全性可以归约到分组密码或Hash函数.而Hash函数和分组密码的安全性由其伪随机性来定义.Bellare等人使用图灵测试的思想,定义了Advantage(优势)函数,简记为Adv函数,一般会配合上标、下标以及括弧来使用,其完整形式如Advprf了函数F区分于prf(Pseudo-RandomFunctions),也就是伪随机函数的概率.括弧内的内容既可以是某个攻击者,也可以是攻击者所耗费的资源,如时间、查询次数等.优势函数通常由一个攻击者发起的实验来定义,下面给出一个具体的例子.攻击者A能访问理想的随机函数族g,以及函数族F,但访问均在黑盒状态下进行,攻击者A能且只能根据输入及输出来判断是随机函数g还是F.使用数学语言可描述如下.定义1.g:{0,1}l→{0,1}L是一个随机函数族,F:{0,1}k×{0,1}l→{0,1}L是一个函数族,攻击者A可以访问从两个函数族中随机选取的一个函数,通过询问最后作出判断,如下定义两个实验:Expprf-0g←$Rand(D,R)d←AgreturndA区分F和随机函数g的prf-advantage被定F(A)=Pr[Expprf-1对于t,q,μ,定义F的prf-advantage为义为Advprf其中,最大值是在所有具有时间复杂度为t,查询次数为q,查询的总位长为μ的攻击者A中取.经过实际检验,分组密码E和随机置换区分的优势Advprp所以说分组密码是一个伪随机置换(Pseudo-RandomPermutations,PRP).而Hash函数H和随机函数区分的优势Advprf不可区分的,所以说Hash函数是一个伪随机函数,后面将给出具体的定义.1994年,文献[5-6]中Bellare、Kilian和Rogaway首次将CBC-MAC的安全性归约为分组密码的伪随机性,即证明了如果分组密码是伪随机置换,那么CBC-MAC是安全的消息认证码.此后,出现了大量的论证消息认证码安全性的文章,这些文章都是证明如果存在攻破要论证的消息认证码的安全性的算法,那么利用此算法,可以构造出攻破分组密码安全性的算法.例如基本加密模式的安全性[7]、OCB模式[8]的安全性、CWC模式[9]的安全性等.现在几乎所有提出来的消息认证码都有安全性证明,是否是可证明安全的已经成为评价消息认证码最基本的指标之一.3.2MAC的安全模型在Alice和Bob采用MAC算法通讯的过程中,攻击者可以自由地窃听Alice和Bob之间的通讯信道,并且可以自由地修改或创建信道中传送的消息.如果攻击者能够成功地使Bob相信一个经过篡改的消息(该消息不曾被Alice传送过)来自于Alice,就称攻击者进行了成功的伪造.下面在讨论消息认证码的安全性时,允许攻击者在选择消息攻击下进行攻击,即攻击者能够得到任何他想得到的消息和标记.在这种情况下,如果攻击者不能进行成功的伪造,那么称消息认证码在选择消息攻击下是安全的.消息认证码在选择消息攻击(cma)下的不可伪造(unforgeability,简记为uf)安全性可以用下面的实验定义:Expuf-cmak←$K(M,σ←)AFk(·)IFFk(M)=σandMwasnotaqueryofAtoitsoracleTHENreturn1elsereturn0A是攻击者,可以访问oracleFk.A选择一系列消息向oracleFk发起询问,获得他想得到的消息认证标记.这个阶段可以看成是A的学习阶段,然后A进行伪造,给出一对(M,σ).如果Fk(M)=σ,并且M从未被查询过,则攻击者攻击成功,实验返回1;否则攻击失败,返回0.一个好的消息认证码应该使得被伪造的概率是可忽略的,一般用符号Advuf-cma中Advuf-cma3.3HMAC的定义HMAC是效率很高、应用很广、性质很好、安全性很强的一种MAC,目前已被采纳为IP安全协议强制执行的认证算法.HMAC是由Bellare等在文献[10]中提出的,Page5其要求所使用的Hash函数具有迭代结构(如MD5①、SHA1②、SHA2③等).所谓迭代结构就是反复地使用压缩函数f将长消息映射为短消息.这个压缩函数f具有两个输入:一个是长度为l的链变量k,一个是长度为b的数据块x,表示为fk=f(k,x).以SHA1为例,b=512,l=160.举例来说,如果处理消息x=(x1,x2,…,xn),其中每个xi均是长度为b的块,i=1,…,n,n是总块数,那么由压缩函数f构造的Hash函数的结构如图2所示.图2中犐犞为初始向量,是一个固定的值,用于处理第一块消息.但实际上由于消息的长度是任意的,而压缩函数能处理的数据块长度只能是b,这就必须对消息进行填充,使其成为b的整数倍.填充算法必须是一个一一映射,以保证两个不同的消息在填充后仍然不相同.一个典型的填充函数是填入|x|的值,并填充一些额外的比特(比如说0或1)使得所得到的比特串变成b的整数倍.因为涉及到算法的实现,这里借鉴Hash函数SHA1的填充方法给出填充算法pad(x)[11],具体过程如下:如果让H(·)代表初始向量固定为犐犞且具有迭代结构的Hash函数,定义H(k,x)=H(k‖x),那么HMAC(k,x)的构造方法如下:其中,pad(k)表示把函数的输入也就是密钥k,通过补0的方式填充为长度为b的二进制串.同时为了避免使用两个密钥,减少密钥开销,Bellare等建议通过分别异或一个常值来生成k1和k2,其中opad和ipad为两个b比特的常数,ipad表示二进制数00110110重复b/8次,opad表示二进制数01011010重复b/8次.算法如图3所示.这种设计有一个典型的优点就是算法不依赖于任何具体的Hash函数,底层的Hash函数就相当于黑盒,可以根据需要方便地选择任何的Hash算法,这一特性称之为黑盒.3.4HMAC的安全性在可证明安全性理论出现之前,密码研究者们用各种方式对HMAC进行攻击,如碰撞攻击、扩展攻击、分割征服攻击[10]等,但这些方法都没有好的效果,对HMAC最好的攻击仍然是生日攻击和穷尽密钥搜索攻击.后来Bellare等人基于HMAC中两个密钥k1和k2相互独立的假设,在文献[12]中给出了HMAC的严格安全性证明,将其安全性同底层Hash函数的安全性关联起来.这一分析考虑了对于HMAC任何形式的攻击,而不是有限的可能的攻击,很好地量化了Hash函数的安全性和基于该Hash的HMAC的安全性之间的紧密关系,实现了HMAC安全性的归约.换句话说,如果发现HMAC安全性存在问题,那么底层的Hash函数必然存在问题.因此,在理论上证明了HMAC的安全性,也验证了之前的攻击实践.但随着研究的进展,出现了新的攻击方法即相关密钥攻击,而且它已经成为现代密码学安全性中①②③Page6一个重要准则[13].因此,文献[14]注意到需调用两次Hash函数H,但两次所使用的密钥间存在相互关联,不相互独立的关系.而利用这一关联,即k1k2=ipadopad,可以构造对HMAC相关密钥攻击.鉴于这一特性,NealKoblitz等①提出在多用户环境下,HMAC也易受到攻击.针对这些情况,本文对HMAC进行了改进,将算法中用到的两个密钥减少到一个,提出了一种新的基于Hash函数和分组密码的消息认证码,从而消除了两个密钥之间存在的相关性,保证了在多用户环境下用户密钥选取的独立性,有效避免了上述文献中提到的问题.4HBMAC的定义及安全性证明设计新的消息认证码算法是一个困难的过程,首先算法需要是可证明安全的,并且证明过程还要尽可能的简洁易懂,其次要使得消息认证码的效率尽可能的高,性质尽可能的优良,这几点要求本来就是相互矛盾的.HBMAC(MessageAuthenticationCodeBasedonHashFunctionandBlockCipher)算法设计充分考虑了安全性、效率和性质.与HMAC相比,HBMAC在安全性和效率上取得了更好的折衷.4.1HBMAC的定义来构造的,所以将其称为HBMAC.H的定义同HMAC中的H定义.假设H的输出等于分组密码的分组长度,二者都为l,那么HBMAC的构造方法如下:HBMAC是使用Hash函数和分组密码的组合其中,x是任意长度的输入消息,M表示对x填充后的消息,pad(x)为按照前面算法描述进行填充,k是长为l的密钥,pad(L)表示为对L通过补0的方式填充成长度为b的二进制串,E表示分组密码.算法如图4所示.对于HBMAC,在Hash函数的压缩函数是伪随机函数、分组密码的分组长度等于Hash函数输出的长度、分组密码是伪随机置换的基本假设下,本文证明了该消息认证码安全性的界为Advuf-cma其中,AHBMAC为针对HBMAC的攻击者,共进行了q次查询,BA为针对分组密码的攻击者,进行了q+1次查询,AH为针对Hash函数的攻击者,共进行了2次查询.4.2HBMAC的安全性证明首先给出可证明安全中的几个基本定义,然后证明HBMAC所基于的Hash函数是计算上几乎泛的,最后构造了两个实验,证明了HBMAC的安全性.4.2.1基本定义在可证明安全理论中,使用优势函数来度量一个算法与一个理想的算法之间的差别.如果这个差别是可忽略的,就认为该算法是安全的.这里给出可证明安全中经常用到的优势函数的定义.定义2.假定A是一个具有Oracle的攻击者,Ao表示A可以查询OracleO.不失一般性,假定攻击者从来不查询该Oracle定义域之外的值,并且从来不重复查询已经查询过的值,那么在进行了一定数量的查询之后,攻击者A输出一个值,这个值要么是0,要么是1.定义优势函数为Advprp该式表示在经过了一定数量的查询之后,当给定的Oracle为Ek(·)时攻击者A输出1的概率与当给定的Oracle为π(·)时攻击者A输出1的概率之差.其中k随机地从K中选择,π随机地从置换族①NealKoblitz,AlfredMenezes.AnotherlookatHMAC.Page7Perm(n)中选择.该式度量了分组密码E:K×{0,1}n→{0,1}n和随机置换之间区分的概率.在安全性证明中一般都默认算法中所使用的分组密码的E(A)可忽略.Advprp类似地,定义一个从{0,1}n到{0,1}n的函数族F:K×{0,1}n→{0,1}n,其中K是有限集.给定k∈K,函数组也可记作Fk(·)=F(k,·).Rand(n)表示所有{0,1}n→{0,1}n的函数的集合.定义:Advprf该式度量了函数F:K×{0,1}n→{0,1}n和随机函数之间区分的概率.以上这些定义由Goldwasser和Bellare①给出.引理1.攻击者A区分一个n比特的伪随机置换E和一个随机函数的优势Advprf的界:定义3.固定定义域D和值域R.如果对于每其中,q为攻击者A对Oracle的查询次数,该引理的证明可参见文献[5].4.2.2计算上几乎泛的Hash函数泛Hash函数族是1979年由Carter和Wegman提出的,它广泛应用于计算机科学的各个领域,包括密码学、复杂性理论、编译器以及数据库.文献[15]给出了泛Hash函数的概念,文献[16-17]在此基础上,给出了基于压缩函数的Hash函数H是计算上几乎泛的函数的定义.在下面的讨论中,假定Hash函数的定义域和值域都是有限的二进制串的集合,并且值域要小于定义域.个x,y∈D,其中x≠y,那么称一个有限的Hash函数集合H={h:D→R}是泛的.定义4.设H:{0,1}k×D→R是一个函数族,AH是一个攻击H的攻击者,它返回定义域中的两个消息,它的au优势定义为H(AH)=Pr[H(k,M1)=H(k,M2)∧M1≠Advau其中,∧表示逻辑“和”.若该优势函数在资源限定的情况下很小,则说该函数是计算上几乎泛的,记作cAU.在压缩函数是伪随机函数的假设下,文献[12]中给出了由压缩函数基于迭代结构构造的Hash的优势函数的界,指出这一优势是可忽略的,也就证明了由压缩函数构造的Hash函数在有密钥的情况下是计算上几乎泛的.4.2.3安全性证明关于HBMAC的安全性有如下定理.定理1.设q,t1是整数,A是攻击HBMAC的攻击者,E是长度为l比特的PRP,lp表示查询的总的明文比特长度,那么Advuf-cma有如下不等式成立:Advuf-cma证明.本文在选择消息攻击下,使用标准的消息认证码安全模型来考虑HBMAC的安全性:攻击者A获得HBMAC的Oracle,在进行了q次询问之后攻击者发起伪造攻击.A的攻击过程如下:Expuf-cmaHBMAC,Ak←$KL=Ek(0)WhenAaskMi,replywithEk(H(L,Mi))(M,σ)←AIFEk(H(L,M))=σandMwasnotaqueryofAtoitsoracleTHENreturn1elsereturn0从消息认证码安全性的定义中可以知道HBMAC,A等于实验Expuf-cmaAdvuf-cma假设A是攻击消息认证码HBMAC的攻击者,在实验Expuf-cma最多是t,设计一个攻击者BA,它是区分伪随机置换E:{0,1}l×{0,1}l→{0,1}l和随机函数Rand(l,l)的一个算法.BA拥有一个Oracle,该Oracle为f:{0,1}l→{0,1}l.BA在运行的过程中调用A,当A询问时,BA使用自己的Oracle模拟A的Oracle来回答,最后当A输出它的伪造时,BA验证,如果验证通过,则返回1,此时BA认定所使用Oracle是一个伪随机置换;否则就返回0,此时BA认定它自己的Oracle是随机函数.假定在实验Expuf-cma也就意味着A进行了q-1次查询,1次验证.下面是实验BA的实现代码.①GoldwasserS,BellareM.LectureNotesonCryptograhpyPage8ExpBfL=f(0)Fori=1,…,q-1doWhenAasksitsoraclesomequeryMigenerateanoncenoniandanswerwithf(H(L,Mi))EndforAoutputs(M,σ)σ←f(H(L,M))IFσ=σandMwasnotaqueryofAtoitsoracleTHENreturn1elsereturn0在实验的最初阶段,BA查询它自己的Oracle在0点的值,然后把返回值赋予L,当A查询M1时,算法BA使用它自己的Oracle计算f(H(L,Mi)),并把f(H(L,Mi))返回给A.A继续进行查询,直到q-1次,然后停止,输出一个伪造对(M,σ).BA验证这个伪造对,如果正确,就返回1.使用符号D表示攻击者Bf用B表示事件f←$Rand(l,l),在实验中Oraclef的输入互不相同的事件使用Z表示.在证明之前首先注意到下面两个事实:事实1.Advuf-cma义该式显然成立.事实2.对于任何事件A,B和C,Cc表示事件C的补事件.Pr[A|B]=Pr[A∩B]那么根据定义2有E,BA=Pr[BfAdvprf下面分别求Pr[D|B∩Z]和Pr[D|B∩Zc].首先考虑Pr[D|B∩Z],当事件B和Z同时发生的时候,也就是说f←$Rand(l,l)并且f的输入互不相同.在这种情况下,攻击者A每次查询之后得到的都是一个随机值.因为f是一个随机函数,而且M没有被查询过,从而σ=f(H(L,Mi))的概率最多是2-l,即Pr[D|B∩Z]2-l.下一步考虑Pr[D|B∩Zc].在这种情况下,f←$Rand(l,l),该随机函数的输入有碰撞.不考虑攻击者如何利用这个碰撞来攻击,只要发生碰撞就认为攻击者能够使用这次碰撞成功伪造消息.下面计算这个碰撞的概率.设Ci表示直到第i个查询时才发生碰撞的概率.C0表示第一次查询得到L时发生碰撞的事件,显然有Pr[C0]=0.如果任意两个消息之间碰撞的概率都是ε,那么Pr[Ci]=iε,这是因为有i个不同的值可能与之发生碰撞,从而Pr[D|B∩Zc]∑q+1由定义4知,ε=AdvauPr[D|B∩Zc](q+1)(q+2)值,因此有从而有AdvprfE,BAAdvuf-cma由于攻击者BA进行了q+1次询问,移项并使用引理1得下面继续进行分析:HBMAC(t,q,lP)=maxA{Advuf-cmaAdvuf-cmamaxAAdvprpmaxA{AdvprpAdvprp上面的第1个等式是由定义1得来的,第2行的不等式则应用了上一步的结果,后面的推导就是简单地利用最大值的性质.Page95HBMAC的优势分析相关密钥攻击[18-19]是Biham和Knudsen针对分组密码提出的,用于从区分攻击[20-21]到密码恢复攻击[22]的各种安全性分析,已经成为主流密码学的挑战之一.对于如何避免这一问题,密码学工作者们做了大量的工作,但只有文献[23-25]给出了少数积极的结果.Bellare认识到构造相关密钥安全的伪随机函数和伪随机置换对研究理想密码很有意义,2010年Cash在文献[26]中基于DDH/DLIN假设构造了一个相关密钥安全的伪随机置换,这是一个突破性的进展.虽然该构造已经证明是可行的,但其效率低下,很难实际应用.2013年文献[13]虽然对其进行了改进,但要求底层Hash函数是基于分组密码构造的,和基于Mekle-Damgrd结构的Hash函数相比,效率上仍然处于劣势.显然,采用上述方法解决HMAC的问题并不理想.此外,文献[14]也给出了一种解决这一问题的办法,即在消息前增加一个比特或一个字节,但文献[27]的研究则证明了这一改进在密钥较长时面临安全风险.本文另辟蹊径,为解决HMAC易受相关密钥攻击和在多用户环境下的安全问题,同时在效率上取得优势,通过和分组密码相结合的方法,构造了一种新的基于Hash函数和分组密码的消息认证码HBMAC.表1对HBMAC和HMAC的性质进行了对比.需要的密钥个数是否抵抗相关密钥攻击是否具有黑盒特性有无弱密钥Hash函数的密钥由分组密码来生成,保证了不同密钥之间相互的独立性,能够避免相关密钥攻击和多用户环境下的安全风险,这些风险均源自使用了两个密钥.此外,还避免了文献[27]中提到的存在弱密钥的安全风险的问题.同时,HBMAC算法还具备黑盒特性,分组密码及底层的Hash函数均可以根据需要进行灵活选择.在效率方面,HBMAC较HMAC减少了一次消息填充和两次Hash迭代运算,增加了两次分组密码计算,而其他计算过程完全一致.当处理较长消息时,这一改变对性能影响可以忽略.在处理较短消息时,由于分组密码计算要慢于Hash函数,效率会略有下降,事实上在实际应用中可以通过分组密码预计算的方法降低这一影响.在某些具体的运用环境中,如安全性要求较高的银行认证系统中,此类消息认证算法具有一定的优势.在HBMAC具体实现上,底层Hash函数可选择SHA2-256,其分组长度为512bits,输出长度为256bits,分组密码选择分组长度和密钥长度均为256bits的Rijndeal算法.在HMAC具体实现上,底层Hash函数可选择SHA2-256.表2和表3分别列出了在上述实现下,HB-MAC和HMAC针对长度分别为128bits、512bits、1024bits、1536bits以及n×512+mbits(其中m为小于448的正整数)消息的计算量.消息分组长度PCHCEC1024bits1536bitsn×512+mbits2n+40其中,1PC表示一次对消息的填充计算,1HC表示一次Hash迭代计算,1EC表示一次分组密码计算.消息分组长度PCHCEC1024bits1536bitsn×512+mbits1n+22从表2及表3中可以看出,随着消息长度的增加,Hash迭代计算呈线性增长,而消息填充计算和分组密码计算则为一个固定值.HBMAC的输出可根据需要选取,最长支持256bits的认证标记,如需要较短认证标记,可直接对其输出进行截断操作.举例来说,如需要128bits的认证标记,可直接选取分组密码输出的前128bits,只是其安全性会随着认证标记的缩短而降低.此外,在计算消息认证码之前,进行密钥编排和Ek(0)的预计算,可有效提升HBMAC算法的计算效率.6总结和展望为解决HMAC面临的相关密钥攻击的风险问Page10题,结合当前密码学研究进展,本文另辟蹊径,通过和分组密码相结合,构造了一种新的基于Hash函数和分组密码的消息认证码HBMAC,该算法不仅有效地避免了相关密钥攻击,确保了安全性,通过分组密码加密模式的选择,还很好地保证了算法的效率.此外,本文巧妙地设计了两个区分实验,完全模拟了攻击者伪造HBMAC消息认证码的过程,在分组密码是伪随机置换和Hash函数所使用的底层压缩函数是伪随机函数的基本假设下,证明了HBMAC的安全性.在消息认证码的研究中,基于Hash的消息认证码一直是研究热点,一些人热衷于研究新的攻击方法,一些人热衷于不断完善和提升其安全性,如本文和文献[28],基本理念恰是一攻一防,相互促进,相得益彰.随着研究的不断深入,尤其是新的分析工具的出现和理论的实际运用,这一热点还将长期存在下去.此外,随着云计算的发展,用户大量的数据将存储在云端,云端数据的完整性保护也是一个巨大的课题.由于云环境的特殊性,数据的修改将在云端由托管方进行修改,用户如何确保托管方在完整的数据上实施了合法授权的修改,这是目前需要研究的问题.Gennaro①和Catalano等人[29]已经在这方面做了一些探讨性工作,提出了同态消息认证码的概念,但离实际使用还有一段距离,需要研究者们不断去改进和完善.致谢感谢参与审稿的专家和编辑老师,他们诚恳地提出了修改意见,这些意见都十分宝贵,对我以后的学习和科研有很好的帮助!
