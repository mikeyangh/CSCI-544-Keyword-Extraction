Page1Java程序混淆技术综述王建民1),2),3)余志伟1),2),3),4)王朝坤1),2),3)付军宁1),2),3)1)(清华大学软件学院北京100084)2)(清华信息科学与技术重点实验室北京100084)3)(信息系统安全教育部重点实验室北京100084)4)(清华大学计算机科学与技术系北京100084)摘要软件混淆技术已经广泛应用于抵制逆向工程和重组工程.文中从混淆技术的历史发展角度对现有的混淆技术理论、算法、攻击模式和评估进行了综述,将Java程序混淆算法分为类内混淆和类间混淆两个类别,并对其中的各类算法进行详尽的阐释.最后在现有工作的基础上,展望了软件混淆技术未来的发展与研究方向.关键词程序混淆;软件水印;防篡改;软件版权保护1引言随着计算机软件的广泛使用,软件的安全问题严重威胁着软件产业的发展,主要表现为:软件攻击者获得试图攻击的软件备份之后,成功地破解软件.现有的调试和编辑工具,使直接检查或修改二进制程序代码变得更加容易.因此,通常情况下攻击者会重组或破解软件,导致软件的使用控制机制失效.破解后的软件可以非法向大众分发,更加助长了软件盗版问题.Java程序由于平台无关性得以在Internet上迅速传播和使用.但同时,Java语言的这一特性也带来了保护知识产权方面的新问题.Java语言为了支Page2持平台无关性,采用了Class这种字节码文件格式①.经过预编译之后,Java源代码指令转化为字节码,而后在虚拟机上解释执行.由于Java字节码的设计是为了使语言更简洁、更具有平台独立性和网络灵活性,它的指令集相对简单通用,每一个类编译成一个单独的文件,Class文件保留方法变量名称等大量语义信息.这些特点都导致Java字节码更容易被反编译为Java源代码.攻击者通过反编译和反汇编技术,获得软件的全部或部分源代码,从而获取关键信息如核心算法、秘密信息等为自己所用.目前已图1软件混淆技术应用本文从混淆技术的发展过程角度,对现有的混淆技术进行综述.首先,在第2节介绍Collberg和Thomborson等人[2]最早提出的混淆技术的形式化定义;第3节介绍混淆算法的分类、各类算法的原理及其实现方法;第4节介绍针对混淆算法的理论研究以及攻击模式;第5节阐述针对混淆算法的评估度量;最后总结并展望混淆技术的前景.2软件混淆技术基本原理软件③混淆技术是在1997年由新西兰Auck-land大学的Collberg和Thomborson等人[2]首先提出的.混淆技术属于一种重要的软件保护技术,其本质是利用程序等价变换的方法,将原始程序转变为语义等价、难以被理解或反编译的程序.同时,他们还阐述了对于混淆算法的分类及其评估方法,并分别就每一类混淆技术提出了若干算法.这些理论及算法对混淆技术的发展起到了提纲挈领的作用.在Collberg和Thomborson提出的理论中,混淆技术可以视为一种高效的程序变换技术,它将原始程序P转换成新的程序P.P与P相比具有相同的外部行为,并且代码安全性能更强.其形式化定义如下:设T是从原始程序P到目标程序P的一个变换,P=T(P).如果该变换满足下列条件,就称P=T(P)为一个软件混淆变换:有许多Java的反编译工具,如Jad②、Mocha[1]等,都是常用的针对Java字节码文件的反编译器.因此,防止针对Java字节码文件的静态分析和反编译攻击的要求,显得更加迫切.混淆技术可以被理解成为是一种特殊的编码技术,目前被广泛地应用于软件知识产权保护领域.通常所说的混淆是指对拟发布的应用程序进行保持语义的混淆变换,使得变换后的程序和原来的程序在功能上相同或相近,但是更难以被静态分析和逆向工程所攻击,如图1所示.可结束也可不结束;相同的输出结果;的运行时间在一个有限的范围内;①若P无法结束或者以错误的状态结束,则P②若P结束,则P也必须结束并且产生和P③对于完成某特定的计算任务,P比P多消耗④攻击者将P恢复为P所耗费的时间大于将P转换至P的时间.其中,P为未经混淆的程序,即原始程序,而P为混淆后的程序.对于任意的合法输入,P与P输出相同的处理结果,即满足程序语义等价性.3软件混淆技术的分类Java文件经过编译生成类文件.类文件分为不同的字段,包括魔数(magic)、版本(version)、常量池(constantpool)、访问标识(accessflags)、(this)类、(super)类、接口(interfaces)、域(fields)、方法(methods)和属性(attributes).根据混淆算法针对的对象不同,可以将混淆分为类内混淆和类间混淆.类内混淆指混淆的作用范围在某个类文件内部,基于字节码的类内混淆作用对象主要是上述类①②③Page3文件结构方法(methods)中的code字段.类间混淆指混淆作用于两个或者两个以上的类文件,实现的方式主要包括类合并以及类拆分等.3.1类内混淆类内混淆实现的方式主要包括数据混淆、控制流混淆、切片混淆和针对特定工具的混淆.3.1.1数据混淆数据混淆的原理是通过对常量、变量和数据结构这些程序的基本组成元素进行修改的方式,增大攻击者进行逆向工程的难度.数据混淆包括:变量存储和编码混淆、变量聚合混淆、顺序调整混淆、词法混淆以及移除注释和调试信息混淆.3.1.1.1变量存储和编码混淆(1)分裂变量混淆分裂变量混淆[2-3]将较为简单的数据结构或数据类型(例如int、boolean等)分解为一些变量的组合,从而达到隐藏原始数据的效果.(2)将静态数据转换为与程序相关的数据以一个静态的字符串为例,可以通过混淆变换将其转化为一个函数或一段子程序,从而在程序执行的过程中通过调用生成相应的字符串[2].这种变换的实现并不困难,但应用时需要考虑以下这对矛盾的制约因素:①在常见的应用程序中都包含大量的静态数据,如果对所有的静态数据都进行混淆,将导致代码的执行代价和传输代价显著增加;②如果仅对关键的静态数据进行混淆,则为反混淆者寻找关键数据提供明显的提示.所以,如何把握①和②的平衡点,是需要在实践中解决的问题.(3)改变编码方式混淆和改变变量生命周期混淆改变编码方式混淆隐藏了真实的数据,使原程序更加复杂[2].下面是一个改变编码方式混淆的例子:用表达式i=c×i+u替代整型变量i,其中c和u为整型常数.原程序:inti=1;while(i<1000){…A[i]…i++}.混淆后的程序:inti=11;while(i<8003){…A[(i-3)/8]…i=i+8}.此外,也可以把局部变量改变为全局变量,从而改变变量的生命周期.(4)变量替换改变变量的类型,例如将一个整型变量更改为一个整型对象.这种操作的目的在于,利用Java的自动回收垃圾机制及时清理一些变量的使用信息,从而增大逆向工程的难度[2].3.1.1.2变量聚合混淆(1)合并变量混淆合并变量混淆算法的原理是:在保持程序语义等价的前提下,将两个或两个以上的数值变量V1,V2,…,Vn合并为一个变量Vm整型变量可被合并为一个64位整型变量.为了增加混淆变换的弹性,可以考虑在程序中添加不影响原始变量值的伪操作.(2)数组重构混淆数组重构混淆有多种实现方式,主要包括数组分裂变换(将一个数组拆分为两个子数组)、数组合并变换、数组折叠变换和数组辗平变换[2].为了获得更好的效果,可以将某些上述变换组合使用.3.1.1.3顺序调整混淆程序员在进行程序设计时,通常会把逻辑上相关的数据放在物理上相邻的位置.因此可以通过顺序调整把逻辑上相关的数据分散在物理上不相邻的位置,从而增大攻击者分析程序的难度.顺序调整混淆主要有重新调整实例变量顺序混淆、重新调整方法顺序混淆、重新调整数组顺序混淆[2].3.1.1.4词法混淆词法混淆的原理是通过对函数和变量的名称进行扰乱,使其违背见名知义的软件工程原则[4].这类混淆变换大多针对Java语言设计,其原理是依照Java虚拟机规范(TheJavaVirtualMachineSpeci-fication)中有关类文件结构的规定,对常量池中存储类、域、方法和变量名字的“CONSTANT-Utf8-info”类型数据项加以混淆.词法变换混淆具有单向的性质,且无额外的执行代价,在保护知识产权的实践中得到了广泛的应用.目前的Java字节码混淆器和混淆编译器大多支持这一功能,可见词法变换具有良好的可行性.为了提高混淆算法的隐蔽性,DeAR和VanLO[5]提出了使用标识符交换来进行词法变换的方法,其思想是将标识符作交换,而不是将其更改成毫无意义的名字.标识符交换包括交换变量名、交换函数名和交换类名3个步骤.使用标识符交换进行词法变换提高了算法的隐蔽性,同时也保留了标识符,这使得该混淆算法不再具有单向性,为反混淆提供了可能性.Chan等人[4]在2002年提出了一种具体的基于修改和重用标识符的词法混淆算法.其基本的思想是尽可能多地对标识符进行重用,通过对标识符的多次重用来迷惑攻击者.此外,这种算法将复杂的标识符用简单的标识符代替,因此具有减小字节码文件体Page4积的作用.3.1.1.5移除注释和调试信息混淆程序的注释和调试信息在一定程度上为攻击者理解程序语义提供了便利,去除此类信息可以有效阻碍攻击者对程序的理解.移除注释和调试信息混淆的主要实现方法是去除注释和调试信息等源代码格式化信息,以及将原有标识符替换为无意义的标识符.这是一种单向的变换,源文件在经过混淆之后无法恢复[3].该混淆方法操作简单,但是强度较差,因为移除的调试信息量较小.这种移除信息的混淆方法对程序运行的时间和空间复杂度几乎没有影响[2].混淆器Crema①是一个典型的应用实例.3.1.2控制流混淆程序的控制转换过程的信息是追踪定位程序状态的重要线索,如何保护这部分信息也是软件保护中很重要的一个环节.控制流图(ControlFlowGraph,CFG)是程序可能执行流程的图形化表示,它可以用来描述程序的控制转换.一个程序可以被分成由一系列无分支的代码组成的基本代码块,这些基本块作为控制流图的结点,而图的边即为各个基本块之间可能的跳转关系.控制流混淆的目的就是改变或复杂化程序的控制流,使程序更难以破译.控制混淆可采用的手段很多,比如应用不透明谓词增加伪造分支、加入可导致反编译错误的指令(例如在Java字节码中添加goto语句等)、将一段代码转换为内联函数调用等[2].3.1.2.1控制计算混淆(1)通过不透明谓词加入不会被执行的分支语句对于一串语句S,利用不透明谓词可以构造出两种变换[6].第1种是增加恒真或恒假的不透明谓词,构造出一条不会被执行的分支,该分支上可以没有语句,也可以有和S不同的语句;第2种是利用时为真时为假的不透明谓词,令它的两个分支上的语句都与原语句S相同.其中第2种混淆变换能够较好地抵抗动态分析.(2)循环条件插入变换通过不透明谓词使一个循环的终止条件变得更为复杂,可以达到对循环进行混淆的目的[2].两种可能的变换原理如图2所示.其中f和g是判断谓词k,j的表达式.(3)将可化简的控制流转换为不可化简的控制流通过将一个结构化的循环变换为含有多个入口的循环,可以将可化简的控制流转换为不可化简的控制流[2].其原理如图3所示,主要是利用不透明谓词加入的假分支,生成循环交叉,从而使控制流图难以被反编译.图3可化简的控制流图转换为不可化简的控制流图示意(4)并行化代码并行化代码是编译器优化程序性能的重要方法之一[2].这一技术可以用于混淆程序控制流,从而增大攻击者理解程序的难度.具体地,有两种实现方式:①在程序中添加伪造的进程代码(dummyprocess);②将一组串行程序并行化.使用并行化代码算法,需要注意代码中的数据依赖关系,否则可能破坏程序的语义等价性.3.1.2.2控制聚合混淆通过方法内联变换和将某些代码片段转换成为①VanVH.Crema-TheJavaobfuscator.http://web.inter.Page5子程序,可以改变程序自身的控制流图.这种混淆方法是单向的,具有较好的鲁棒性[2].(1)方法交叉调用和方法克隆其主要思想如图4所示,合并两个调用方法的参数列表和主体,并增加一个参数或全局变量(图4中的intV),用以声明执行时具体应当调用哪一个方法.方法克隆的目的是混淆程序的方法调用关系,克隆的方法应与原方法看似区别但又具有相同的语义[2].图4方法交叉调用对于控制混淆如何抵抗自动化分析工具的攻击,也有不少研究.Wang[7]提出了通过更改跳转指令实现控制混淆的一种方法,使得编译时候每一个跳转指令的目标都是未知的.Chow等人[8]提出了一种相似的方法,通过一个有限状态自动机来控制程序的跳转语句.根据以上的控制混淆算法理论,Low[9]在1998年提出了针对Java代码的控制混淆算法实现.对于不透明谓词的设计,Majumdar等人[6]在2006年为分布式系统的混淆补充了一种分布式不透明谓词.应用该不透明谓词可以有效地抵抗多种自动静态分析的攻击.3.1.3切片混淆切片通常是用来帮助理解程序的,而混淆的目的是使程序更难以被理解.Drape等人[10-11]提出了切片混淆算法,使得混淆过的程序能够更好地对抗切片分析攻击.定义Slice(P,S,V)用来标记程序P在状态S时,对应的变量集V的一个后向切片(backwardsslice),指令out表明V中变量的输出.图5中显示了一个包含有变量i,x,y的程序,当输出为y时的程序切片:黑体部分为切片时可观测到的变量值.此时变量x不在观测范围内.切片混淆(slicingobfuscation)算法的主要思想就是尽可能多地将多个变量的值放入到切片的观察范围之内,增加使用切片分析程序的攻击者的困难(2)循环变换循环变换可以采用循环模块化(将循环区间划分为多个模块)、循环展开(拓宽循环的步频)和循环切割(将一个循环转换为多个循环)等方法实现.3.1.2.3控制顺序混淆控制顺序混淆的实现原理为:随机打乱表达式、基本块、方法和类的顺序,使攻击者难以理解程序的正确意图.使用该方法要注意一些有依赖关系的数据在重新排序之后是否合法.程度[11].切片混淆的主要方法有:增加恒假谓词、变量编码和增加循环变量.增加恒假谓词是在恒假谓词的假分支上增加令x与y相关的函数;变量编码是在不改变语义的情况下将y的表达式重新编码为与x相关的表达式;增加循环变量是在循环变量中添加与x,y相关的变量.图6至图8分别描述了这几种方法的实现.intbogus(intn){inti=0;intx=0;inty=1;while(i<n){i++;if(i<5||x<y)x=x+i;elsey=xi;y=yi;}out(x);out(y);}图6增加伪造分支Page6Majumdar等人[12]从单词计量、结果求和、定位时间等角度验证了切片混淆的方法能够增强程序抵抗切片分析攻击的能力.3.1.4针对特定工具的混淆针对特定工具的混淆是针对自动化的反编译和反混淆工具提出的混淆方法,旨在阻止这类自动化工具的使用,或者增加其使用难度和代价[2].该类混淆方法与前面提到的3种类别的混淆,最大的不同之处在于,前3种混淆技术主要是针对程序的阅读者,即针对的是人;而后者针对的是自动化的反混淆以及反编译工具.针对特定工具的混淆可以通过与其他的混淆技术综合使用从而达到更好的鲁棒性[2].在实际操作中,可以在循环体内部加上伪造的无用变量,形成数据依赖,增加反混淆的自动工具分析难度.例如在程序的某处使用了反向循环的混淆,为了防止这一变换被反编译器分析破解,可以采用图9所示方法:在这个例子中,增加了B数组,for循环的前后向顺序会对B数组的各个元素产生影响,从而形成数据依赖,阻止反编译器变换循环的方向.这一混淆方法的弹性,取决于添加伪造数据的复杂度.For(i=0;i<=10;i++){A[i]=i;}例如,针对Mocha[1]这一反编译工具,我们可以采用这样的措施造成它反编译失败:在每个方法的每一条返回语句之后增加额外的指令.在不影响程序行为的前提下,造成Mocha的崩溃.Batchelder等人[13]在2007年较为详细地阐述了如何利用Java字节码与Java源代码之间指令规范的不同,在字节码的级别进行可以导致反编译失败的控制流混淆.例如利用jsr-ret指令取代普通的if-goto;针对模式匹配的反编译器,将load指令提到if指令之前;在子类构造函数中对父类的调用进行外包等等.3.2类间混淆Sosonkin等人[3]在2003年提出了3种分别基于类的合并、类的拆分以及类型隐藏的类间混淆算法.3.2.1类合并类合并算法的主要思想是合并两个或多个类各自包含的变量和函数,根据需要重命名变量或函数标识符[3].若待合并的类中有标识符相同的变量或非构造函数,则将其改为不重复的新标识符;若待合并的类中有标识符及参数都相同的构造函数,无法随意更改标识符,则合并后为其中一个增加伪造的参数;若待合并的两个类之间有继承关系,则合并后增加一个布尔型的私有变量用于区分标识符相同的函数,图10是类合并的一个例子.Originalclasses:classA{privateinti;publicA(){i=5;}publicbooleanm(){returni<0;}}classBextendsA{publicB(){super();i=10;}publicbooleanm(){returni<10;}}classC{voidn(){Aa;if(…){a=newA();}else{a=newB();}am();}}3.2.2类拆分类的拆分算法首先分析判断待拆分的类内部的继承和方法调用关系[14],观察它们是否能够进行拆Page7分.对于可拆分的类,主要方法是将一个类C拆分为C1,C2两个类,且C2是C1的子类,并确保C中的每个方法和变量,在C2中均包含或由C1继承,图11是类拆分的一个例子[3].Originalclasses:classC{privateinti;privatedoubled;protectedObjecto;publicC(){i=5;d=1.0;o=newObject();}publicC(intiarg,doubledarg){i=iarg;d=darg;o=newObject();}publicbooleanm1(){returni<0;}publicvoidm2(){d=3.0;m3(3);}protectedvoidm3(intiarg){i=iarg;m4(newObject());}publicvoidm4(Objectobj){o=obj;}}classD{voidn(){Cc=newC();if(cm1){…}cm2;cm4;}}3.2.3类型隐藏类型隐藏算法是利用Java中的接口来声明待混淆类的变量和方法,而原先的类则实现这些接口,具体实现无需改动[3].算法的关键部分是每一个接口只随机包含一个待混淆类中公开的方法的子集.除类合并算法之外,另外两种混淆算法对程序运行时间的影响较小.4软件混淆算法的攻击模式4.1混淆算法的理论研究Barak等人[15]曾经证明,如果把混淆的过程看作是一个“虚拟黑箱”(virtualblackbox),即要求被混淆过的程序的输入输出应当完全相同于原程序.满足这一性质的混淆器是不可能实现的.然而“虚拟黑箱”的要求过于严格,在较宽泛的限制中,混淆器是可以实现的.Lynn等人[16]在Barak的证明基础上给出关于程序混淆第一个“积极的”结果:提出了几种针对复杂的访问控制函数的混淆方法,并进行了验证.Wee等人[17]也针对“虚拟黑箱”理论,阐述了关于点函数的混淆,证明在黑箱条件下对点函数混淆的存在性.关于混淆技术理论,还存在较大的研究空间.4.2混淆算法的攻击模式4.2.1针对数据混淆算法的攻击假定T是对程序P的一个单向的混淆变换,当且仅当从原始程序P除去某些信息后,无法通过混淆后的程序P恢复出P[18].词法变换是最典型的不可逆混淆算法.虽然对于经过词法变换的程序进行攻击不可能恢复程序的原貌,但只要理解程序各个模块的含义就可能对程序产生威胁.例如根据无法被混淆的系统API名称等关键字,攻击者可以推测出该模块的大致功能.Cimato等人[19]提出基于字节码中的标识符修正的反混淆方法.该方法可以用于攻击标识符重命名的混淆算法.4.2.2针对控制流混淆算法的攻击目前,针对控制流混淆算法的主要攻击方法是动态分析.Udupa等人[20]指出了动态分析对大部分混淆算法的攻击作用,并阐述攻击模型.对于控制流混淆而言,变换后生成的程序中若存在始终不执行的分支,通过动态分析就能找到对破解程序有用的信息.针对控制流混淆,还有黑盒测试攻击[21],该方法通过对程序进行黑盒测试,了解各个类及其函数的功能,从而获取攻击者需要的信息.这种方法对大多数的混淆变换均能加以攻击.同时,该方法也存在着一定的局限性:黑盒测试缺乏自动分析工具,需要依靠大量的人力来完成分析工作.同时,Udupa等Page8人[22]还提出将静态分析与动态分析相结合的反混淆方法.Lakhotia等人[23]提出可以用抽象栈图的方法检测混淆后程序中的调用关系.Chen等人[24]提出使用面向方向的语言AspectJ的字节码工具破解混淆算法,该方案可以修正混淆后的程序的方法.表1是对上述典型攻击方式的简单阐释.基于字节码中的标识符修正方法数据混淆(标识符重命名)动态分析;静态分析;静态和动态分析结合使用AspectJ分析5混淆算法的评估上述混淆算法的效用如何,需要一个对混淆算法进行评价的标准.文献[2]中提出了3个评估混淆算法的指标,分别为程序增加的复杂度即强度(potency)、算法抵抗机器攻击的能力即弹性(resili-ence)以及由于对代码转换而带来的额外开销(cost).强度(potency)表征混淆算法为程序所增加的良好的混淆算法应当使其强度和弹性最大化,同时最小化开销.表2对上述混淆算法做了一个综合的评估.表2混淆算法3项指标评估作用范围类内类间基于类变换的混淆基于上述评估指标,Naeem等[25]对现有的一些反编译器和混淆器的性能进行了评估,针对前者有Jad、SourceAgain①,针对后者则主要包括JBCO[26]以及KlassMaster②.2007年,Anckaert等人[27]提出了基于软件复杂度的度量方法用以评估混淆和反混淆的质量.这里的度量指标包括4个:程序代码、控制流、数据和数据流.2008年,Ceccato等人[28]提出一种新的评估方复杂度以及理解的困难程度.程序主要有7类属性决定它的复杂程度,分别是程序长度、循环复杂度、嵌套复杂度、入度出度复杂性、数据流复杂度、数据结构复杂度和面向对象的特性(包括方法个数、继承树深度等指标).混淆算法对程序这些属性的值提升越多,它的强度性能越好.弹性(resilience)表征混淆算法抵抗攻击的能力.弹性由两个部分组成:一部分是攻击者为了攻克算法,设计并实现一个相应反混淆器所需花费的时间;另一部分是反混淆器对混淆算法进行反混淆所花费的开销[24].弹性区别于强度的主要特点是针对自动化的反混淆工具,而强度针对的是程序的阅读者.开销(cost)衡量的是混淆算法给程序带来的额外开销.开销包括有两个方面:一方面是在对程序混淆时所花费的开销;另一方面是混淆后的程序相对于原始程序执行时所增加的时间复杂度以及空间复杂度.强度(高/中/低)弹性(好/中/弱)开销(高/中/低)法:根据攻击者理解和更改混淆后代码的难易程度来度量混淆算法的质量.这种方式与上述方式最大的不同之处在于考虑了攻击者这一因素,通过比较测试者(程序员)对混淆和未混淆的代码进行攻击时的表现,来经验性地评估混淆算法.实验得到的结果是,混淆以后的代码与未混淆代码相比,前者被攻击①②tor.http://www.zelix.com/klassmasterPage9成功的概率是后者的1/7.可见,混淆算法可以显著增加测试者理解代码的难度.2009年,Tsai等人[29]提出了用于评估和分析控制流混淆算法的框架.借助基于图的表示方法,许多现有的控制流变换都可以转化为原子操作表示.同时,他们还提出了一种对混淆变换效果定量分析度量方法,帮助评估控制流混淆的弹性以及开销代价.6总结与展望混淆技术是一种可用于抵制逆向工程和重组工程、对软件知识产权进行保护的程序变换技术.使用混淆技术虽然会使代码的效率有一定程度的降低,但是它的实现代价相对较小,因而在近年引起了广泛的关注[2,25,30-33].由于混淆技术不改变程序功能的特性,并且有些词法混淆算法甚至可以减小原程序的体积,因此混淆技术得以在保护移动代码方面得到广泛的应用.受移动平台资源的限制,今后混淆技术的研究方向一方面要加大混淆的力度,增加攻击者反编译的难度,另一方面也要考虑降低混淆算法对目标程序的运行负担.文献[26,32]探讨了混淆技术在移动代理上的应用.目前保护软件知识产权的新技术主要有3种:混淆技术、软件水印技术和防篡改技术[25].这3种技术各有特长,将它们互相结合使用,可以给予目标软件更为可靠的保护,这也是目前研究的一个重要方向.混淆技术的主要目的是增加攻击者对程序进行反编译的难度和代价,因而可以用于提高防篡改技术的保护力度[8,34-36].此外,混淆技术可以增强软件水印的鲁棒性,使软件系统的安全性更强.例如不透明谓词除了上文提到的用于控制流混淆之外,也经常用于在程序中添加软件水印[37-38].孙光等人[39]提出将程序的编译混淆,而不是混淆程序本身.但是该方法还有若干问题需要考虑,比如加入水印后的软件执行效率问题,不同水印算法与混淆算法结合的顺序等.最后,对于混淆算法的评估、正确性验证以及如何研制高效可靠的混淆算法,也是将来的发展方向之一.致谢在此,我们向对本文的工作给予支持和建议的同行,尤其是奥克兰大学的Thomborson教授给予的指导和帮助表示感谢!
