Page1PrivateCheckIn:一种移动社交网络中的轨迹隐私保护方法霍峥孟小峰黄毅(中国人民大学信息学院北京100872)摘要移动设备的发展及无线网络的普及促使移动社交网络的出现及发展.签到服务作为移动社交网络中的主流应用,存在着严重的轨迹隐私泄露风险.文中针对签到服务中假名用户的轨迹隐私泄露问题,提出了一种轨迹隐私保护方法PrivateCheckIn.该方法设计了一种签到序列缓存机制,通过为缓存的签到序列建立前缀树、对前缀树进行剪枝及重构形成k-匿名前缀树,遍历k-匿名前缀树得到k-匿名签到序列,达到了轨迹k-匿名的隐私保护效果.文中证明了PrivateCheckIn方法既能保护假名用户的轨迹隐私,又确保损失签到位置最少,有效地保证了用户体验.通过构建前缀树的方式获取轨迹k-匿名集降低了计算代价.最后,文中在真实数据集上与(k,δ)-anonymity方法进行了充分的对比实验,验证了PrivateCheckIn方法的准确性与有效性.关键词数据库应用;隐私保护;位置隐私;轨迹隐私;移动社交网络1引言无线通信设备的发展以及3G、WIFI的普及,促使了一种新的应用———移动互联网的产生和发展.而移动互联网与传统的社交网络相结合,产生了移动社交网络(MobileSocialNetworkServices,MSNS).移动社交网络中的用户不仅可以获知自己的位置、获取相关服务(比如查找最近的餐馆、酒店等),还可以发现近邻好友,在某个语义位置签到,分享照片及旅行轨迹等等,这种应用模式为用户提供了虚拟与现实相结合的社交平台,近年来发展迅速.著名的移动社交网站四方网①在2011年底已突破千万用户.其它的移动社交网络,如GoogleLatitude②,FacebookPlaces③等也正在持续增长.国内的相关服务兴起稍晚但发展迅速.街旁④、切客⑤等移动社交网站已有数百万用户.签到服务是移动社交网络中的主流应用.在签到服务中,用户使用带有定位功能的移动设备向MSNS服务器发送自己所在的地理位置,选择地理位置对应的语义位置(通常是商家)进行签到.目前,四方网的签到数据已达5亿多条.国内的切客、街旁等签到服务也有近亿条的签到数据.签到服务的流行主要有以下原因:(1)签到服务的社交特性是吸引用户的重要因素,用户可以将自己的签到位置分享给好友或分享到其它社交网络中,以便了解朋友动态,增进彼此的互动;(2)服务提供商与商户设计了丰富的激励措施以提高用户参与的积极性.例如,当用户在某个位置的签到次数达到某个标准时,可以获得勋章、荣誉称号等奖励.除此之外,激励措施还为用户提供了各种实际优惠.例如,多次在某咖啡馆签到即可获得打折卡、免费饮品等.总的来说,签到服务具有以下特征:(1)语义性.用户往往是在某个语义位置进行签到,例如超市、酒吧等,而不是在某个具体的地理位置签到;(2)历史性.随着时间的推移,孤立的签到位置信息会形成一条签到轨迹;(3)非实时性.从签到方式来看,签到服务不存在实时性问题,系统仅在用户打算签到的位置提供签到记录即可.然而,隐私泄露已成为用户使用签到服务的首要障碍.用户签到的位置越多,就能获得越多的奖励和参与乐趣,但隐私泄露的风险也越大.位置隐私是指用户访问过的敏感位置不愿被外界知晓.敏感位置可以是普遍意义上的隐私位置,如医院、酒吧等,也可以是用户自定义的敏感位置.由签到服务的特征分析可以得出,用户签到的位置是具体的语义位置,往往精确到商家或者具体地点,容易导致用户的位置隐私的泄露[1].轨迹隐私是指用户运行轨迹本身包含的敏感位置,或者由运行轨迹构成的其它敏感信息,如用户行为模式等.用户一段时间内的签到记录形成的轨迹,可导致用户的行踪暴露[2].攻击者可以据此分析出用户当天的行为模式,进而对用户的身份进行推测,甚至能够预测出用户未来的轨迹.保护用户的轨迹隐私也能保证其位置隐私不泄露.隐私保护技术既要求保护用户的轨迹隐私,又要保证较高的用户体验.签到服务中的用户体验是由用户的有效签到位置来体现的.因此,隐私保护算法需尽量保留用户的拟签到位置,提高签到成功率.基于位置的服务(Location-BasedService,LBS)中的位置隐私保护技术[3-7]及轨迹数据隐私保护技术[8-13]已取得一些研究成果,但均不能直接用于移动社交网络中.近年来,研究者针对移动社交网络中的隐私问题进行了研究,但研究内容集中在移动社交网络中的位置推理攻击[14]、移动社交网络中的位置与缺席隐私保护、近邻服务中的位置隐私保护[15-16]三方面.而针对签到服务中的轨迹隐私泄露问题并未见研究工作.移动社交网络中有两类用户:一类是用真实姓名做用户名的实名用户,攻击者可以直接将用户与现实生活中的个体联系起来;另一类是使用昵称做用户名的假名用户,攻击者很难直接将其和现实生活中的个体联系起来.本文主要研究签到服务中假名用户的轨迹隐私,并假设其用户名不能作为QI(Quasi-Identifier)属性唯一识别用户.本文的主要贡献有以下几点:(1)提出了一种签到服务中的轨迹隐私保护方法PrivateCheckIn.该方法在中心服务器结构上实现,能有效保护移动社交网络中假名用户的轨迹隐私,保证攻击者从签到序列中识别出某个假名用户的概率至多为1/k.(2)PrivateCheckIn方法用缓存的用户签到序列构造前缀树,通过对前缀树进行剪枝、重构生成k-匿名前缀树,遍历k-匿名前缀树可生成满足轨迹k-匿名的可签到序列.(3)本文证明了PrivateCheckIn方法的损失签到位置最少,即在达到轨迹k-匿名隐私保护度的同①②③④⑤Page3时,保证签到成功率最高.此外,通过对比实验可以看出,PrivateCheckIn方法有效降低了达到轨迹k-匿名的计算代价.(4)本文在真实数据集上对PrivateCheckIn方法与经典轨迹隐私保护方法(k,δ)-anonymity[11]进行对比实验.实验结果表明在达到相同隐私保护效果的情况下,PrivateCheckIn在签到成功率和运行时间上均优于(k,δ)-anonymity.本文第2节主要介绍移动社交网络中的隐私保护的相关工作;第3节介绍PrivateCheckIn方法的系统结构;第4节详细介绍PrivateCheckIn的实现过程;实验及结果分析在第5节;最后,第6节总结本文内容,展望未来研究工作.2背景及相关工作2.1移动社交网络中的隐私保护移动社交网络中的隐私保护技术研究主要集中在以下3个方面:位置隐私推理攻击、MSNS中的位置和缺席隐私保护和近邻服务中的位置隐私保护.位置隐私推理攻击是签到服务中一种复杂的攻击模式.它是指攻击者利用背景知识(在MSNS中指用户的社会关系及历史签到数据)推导用户在某时刻的位置.文献[14]提出了一种在移动社交网络中推导用户位置的方法.该方法通过用户n个朋友在t时刻的位置以及时刻t的属性(具体包括t是工作日或周末,上下班时间或其它时间段等)判断该用户在t时刻的位置.作者采用动态贝叶斯网络作为预测模型,并用真实的签到数据训练该模型.文献[14]提出的推理攻击方法可达到80%的精确度.文献[17]最早研究了移动社交网络中的位置隐私保护技术,作者指出MSNS中存在两种隐私威胁:位置隐私和缺席隐私.缺席隐私是一种特殊的位置隐私,指攻击者可以确定用户在某个时间段内不在某个位置.缺席隐私的泄露对用户有同样的危害.假如某用户在距其住址距离为d的商户签到,根据最大运行速度、路网状况等信息,攻击者可获知该用户在某段时间内一定不在家中,从而进行入室行窃等危害用户利益的行为.作者提出了一种空间泛化和延迟发布相结合的方法,保护用户的位置隐私和缺席隐私.文献[15-16]提出了一种近邻服务中的位置隐私保护方法.在近邻服务中,当用户在某个朋友的附近时,系统自动将用户的位置告知其朋友,这样可能导致用户位置隐私泄露给不可信的朋友或者服务提供商.作者在文献[15]中提出了两种基于对称加密算法的协议保护用户的位置隐私.2.2轨迹隐私保护技术轨迹隐私保护技术分为假轨迹法、抑制法和泛化法3类.假轨迹法[7]利用假轨迹扰动真实轨迹达到隐私保护的目的.文献[7]中提出的方法通过旋转用户的真实轨迹生成假轨迹.假轨迹的引入降低了攻击者识别真实轨迹的概率.抑制法[8-9]指限制发布轨迹上某些敏感位置或可能导致敏感信息泄露的轨迹片段.文献[8]假定攻击者已知某些用户访问过的位置或轨迹片段,在发布原始轨迹数据时,能导致整条轨迹被识别的片段将被限制发布.文献[9]研究了位置跟踪服务中的轨迹隐私保护技术.用户进入敏感区域后位置更新被抑制.当且仅当有k个用户进入该区域后才允许用户更新位置信息.区域的敏感度是根据区域内的用户数与总用户数的比值计算的,区域中的用户越少,敏感度越高.泛化法是目前主流的轨迹隐私保护技术,轨迹k-匿名[11]是泛化法的代表.为了降低信息扭曲度,轨迹k-匿名需找到距离较近的k条轨迹构成匿名集,最后发布k条轨迹对应采样点的匿名区域.寻找轨迹k-匿名集的方法有两大类,一类是通过整条轨迹的聚类找到距离相近的k条轨迹[11];另一类是通过轨迹上的近邻采样点位置构造轨迹k-匿名集[12-13].无论用何种方式,为了降低信息扭曲度,都必须遵循k条轨迹之间距离尽可能小的原则.文献[18]针对轨迹数据挖掘中可能频繁访问模式的应用,提出了一种保护频繁访问模式的轨迹隐私保护方法BF-P2kA.该方法也是以前缀树为基础构建轨迹k-匿名集,然而,该工作与本工作的不同之处在于以下几点:(1)PrivateCheckIn方法主要应用在移动社交网络的签到服务中,BF-P2kA方法是应用在数据挖掘中的轨迹k-匿名方法,算法的衡量标准不同;(2)BF-P2kA方法没有预处理操作,将不同时段的轨迹数据进行k-匿名,这种做法可满足保护数据频繁访问模式的隐私保护,但并不能保证移动对象的个体隐私不泄露;(3)BF-P2kA方法在重构轨迹数据时,未考虑所有被剪枝的或未被重构的轨迹数据,也没有通过增加假采样位置提高重构率,因此未做到损失采样位置最少.3PrivateCheckIn方法系统结构本文提出的PrivateCheckIn方法在中心服务器系统结构上实现,如图1所示.中心服务器系统结构由客户端、隐私保护服务器及服务提供商3部分组Page4成.其中,隐私保护服务器和MSNS用户都是可信的,系统中只有假名用户使用隐私保护服务.恶意攻击可能来自于服务提供商或其它方面的攻击.隐私保护服务器部署在可信的第3方上.中心服务器结构之所以在用户与服务提供商之间加入隐私保护服务器,是因为无法确定服务提供商是可信的,这是由于一些不负责任的服务提供商出于商业目的将其收集的位置记录卖给其它机构.导致攻击者通过买来的数据获取这些对象的签到记录,进而锁定一些攻击对象.在签到服务中,采用中心服务器结构实现隐私保护有如下优势:(1)用户不直接与服务提供商交互,有利于保护用户的隐私;(2)隐私保护服务器掌握全局信息,易于实现隐私保护算法;(3)隐私保护服务器承担了隐私保护算法的计算,避免了客户端的大量计算,减轻了客户端的压力.用户使用签到服务前向隐私保护服务器发送注册请求.用户注册模块负责处理用户注册、存储用户设定的个性化隐私保护参数,主要包括:隐私保护参数k、最长时间容忍度Δt、预定义敏感位置集合(SensitiveLocationPrivacyRegion,SPR).当用户准备签到时,将“预签到”命令发送给隐私保护服务器.预处理模块判断用户提交的位置是精确的地理位置还是语义位置.如果是语义位置,则直接缓存用户的签到位置;如果是地理位置,该模块向服务提供商发起匿名查询,获得附近的兴趣点(PointofInterest,POI),返回给用户,用户选择合适的兴趣点再次预签到.预处理模块还负责删除签到序列中用户预定义的敏感位置.隐私保护模块根据用户签到序列构建前缀树,对前缀树进行剪枝和重构生成k-匿名前缀树.最后,遍历k-匿名前缀树得到可签到的k-匿名序列,并向服务提供商签到.4PrivateCheckIn轨迹隐私保护方法4.1预备知识定义1.签到序列.用户ui在某个位置的签到记录可表示为(li,ti),其中li表示签到位置的ID,ti表示签到时间.签到记录按时间排序构成了用户ui的签到序列Chi={(l1,t1),(l2,t2),…,(ln,tn)}.签到序列中的位置集合称为该用户的签到位置集合.定义2.安全签到序列.给定用户ui及其预定义敏感位置集合SPR、签到序列ChSi及对应的签到位置集合ChSiL,当且仅当ChSiL中不包含任何属于SPR的位置,即li∈ChSiL,liSPR时,称ChiS是ui的安全签到序列.定义3.k-匿名签到序列.给定用户ui及其预定义的隐私保护参数k、最长时间容忍度Δt,当且仅当有其它k-1个用户在Δt时间内与ui有相同的签到序列时,签到序列kChiS称为ui的k-匿名签到序列.k-匿名签到序列中的位置集合称为ui的k-匿名签到位置集合.如果某个用户的签到序列是k-匿名签到序列,其轨迹隐私泄露概率Pex1/k[11],其中k是用户设置的隐私保护参数.定义4.损失签到位置.设用户ui的签到位置集合为ChiL,其k-匿名签到位置集合为kChSiL.损失签到位置集合L可表示为L={li|(li∈Chi&&likChSiL)‖(li∈kChSi&&liChiL)}.损失签到位置即k-匿名签到位置集合与原始签到位置集合相比,减少或增加的签到位置.PrivateCheckIn算法包括以下几个步骤:1.签到序列预处理.即,将用户签到序列中属于SPR的位置删除;构建签到序列等价类,将起止签到时间相近的序列放入同一个等价类.2.将等价类中的签到序列按签到位置ID排序,并构建前缀树.然后,根据隐私保护参数k对前缀树剪枝,将支持度小于k的节点或路径剪除.3.用剪除的路径重构前缀树,以减少损失签到位置.最后,对重构后的k-匿名前缀树进行遍历,得到可签到的k-匿名序列.步1的处理比较简单,本节其余内容主要介绍如何生成损失签到位置最少的k-匿名签到序列.4.2前缀树的构建与剪枝前缀树是一种紧凑的序列表示方式,用前缀树存储签到序列更节省存储空间.此外,由于用户的签到位置是语义位置,即使在同一个语义位置签到时所处的地理坐标不同,也会得到相同的签到位置ID.因此,用前缀树表示签到序列是有效且可行的.定义5.前缀树.前缀树PT可表示为如下的三元组PT=(N,E,Root(PT)).其中,N表示前缀树中节点的集合;E表示前缀树中边的集合;Root(PT)N是前缀树的虚拟根节点.在前缀树中,每个节点(除了根节点)有唯一的父节点,且有唯一一条路径从根节点到达该节点.对于Page5除根节点的任何节点n∈N可表示为〈ID,item,support,children〉.其中,ID表示该节点的标识符;item表示数据;support表示该节点的支持度;chil-dren表示该节点的子节点.算法1给出了构建前缀树的过程.算法1.构建前缀树.输入:签到序列等价类EC输出:前缀树PT1.foreachsequenceChSiinECdo2.Pathl=Longestprefixof(Root(PT),ChSi);3.addChSitoPathl;4.foreachnodeniinPathldo5.ni.support=ni.support+support(ChSi);6.end7.foreachniinChSibutnotinPathldo8.ni.support=support(ChSi);9.end10.end11.return(PT)前缀树中每个节点表示一个签到位置(位置ID相同即为同一个签到位置).算法1首先在前缀树PT中找到安全签到序列ChSi的最大前缀,放入Pathl中(第2行).最大前缀Pathl是指,在PT中不存在另一前缀Pathl,它即是ChSi的前缀且长度大于Pathl.其次,将序列ChSi添加到包含其最大前缀的路径上,更新最大前缀Pathl上每个节点的支持度值(第3~6行).对于在ChSi中且不在Pathl中的节点,将其支持度置为ChSi的支持度(第7~9行),最后返回前缀树PT.定义6.k-匿名前缀树.当且仅当除根节点以外的所有节点的支持度都大于或等于k时,前缀树PT为k-匿名前缀树.PrivateCheckIn方法将轨迹k-匿名问题转化为生成k-匿名前缀树的问题.如果用户的签到序列生成的前缀树为k-匿名前缀树PTk,遍历PTk得到的签到序列满足轨迹k-匿名.算法1生成的前缀树不图2前缀树构建及剪枝例子一定是k-匿名前缀树,算法2对前缀树进行剪枝,将支持度小于k的节点或路径剪除.算法2.前缀树剪枝.输入:前缀树PT,最小支持度k输出:剪枝后的前缀树PT1.Clist←;2.ifni.support<kthen3.ifniisaleafnodeanddepth>2then4.PT←PT-ni;5.else6.foreachnjinPath(ni,PT)do7.nj.support=nj.support-ni.support;8.Clist=SetofsequencesinPath(niPT);9.endfor10.PT←PT-subtreeinducedbyni;11.else12.foreachnc∈ni.childrendo13.Clist∪前缀树剪枝(ni,PT,k);14.endfor15.endif16.return(PTandClist)算法2从根节点开始扫描前缀树中的所有节点,当某个节点ni的支持度小于k时,则对ni剪枝.根据节点类型的不同,剪枝分两种情况处理:(1)如果ni是叶子节点且深度大于2,则直接将ni删除,不影响其父节点的支持度(第3、4行);(2)如果ni是非叶子节点或叶子节点深度小于等于2,需剪除掉包含ni的整条路径,即以ni为终点的路径上所有节点的支持度减去节点ni的支持度(第5~9行).其中Path(ni,PT)表示前缀树PT中到达节点ni的路径.Clist中存储的是剪除的序列,但不包括剪除的单个叶子节点(第10行).算法2对ni的子节点也进行相同的剪枝操作(第12~14行).最终返回剪枝后的前缀树PT以及剪除的序列集合Clist(第16行).图2给出了使用算法1和算法2构建前缀树及剪枝的例子,其中,k=3.Page6为了减少剪除的签到序列,减轻重构时的计算代价,算法2将深度大于2的叶子节点、深度小于等于2的叶子节点和非叶子节点分开处理.由图2(b)和图2(c)的对比可以看出,整条序列L3→L4→L5、L2→L7→L8→L9被剪除,序列L2→L7→L10上的节点L10、序列L1→L2→L3→L4→L5上的节点L5、序列L1→L3→L4→L5→L6上的节点L6被剪除,而Clist中仅保存签到序列L3→L4→L5和L2→L7→L8→L9,并没有将支持度不足k的叶子节点所在的路径完全剪除,降低了重构时的计算代价.遍历剪枝后的前缀树得到如图3所示的签到序列.可以看出,用户u9和u11的签到序列被完全被剪除,即签到位置完全丢失.为了减少损失签到位置,提升用户体验,Private-CheckIn方法引入了重构前缀树的过程.4.3重构前缀树重构前缀树的目的是减少损失签到位置,其主要思想是在前缀树上为已剪除的签到序列寻找合适的路径,若存在路径使得重构剪除序列增加的节点数小于剪除的节点数,那么重构操作可以减少损失签到位置.为使重构时增加的损失签到位置最少,需找到剪除序列与前缀树所表示序列的最长公共子序列,其定义如下所示.定义7.最长公共子序列.给定两个签到序列S1和S2,如果存在子序列Ssub满足SsubS1,SsubS2,且不存在子序列SsubSsub满足上述条件,则称Ssub是S1和S2的最长公共子序列.例如,给定序列L1→L2→L3→L4→L5和L1→L3→L4→L6,其最长公共子序列为L1→L3→L4.算法3给出了利用最长公共子序列重构前缀树的过程.算法3.重构前缀树.输入:剪枝后的前缀树PT,剪除的序列集合Clist输出:k-匿名前缀树PTk1.foreachdistinctS∈Clistdo2.LCS=最长公共子序列(S,PT);3.Pleast=PT中包含LCS的最短路径;4.ifPleast≠andlength(Pleast)<2×length(S)5.foreachnodeniinPleastdo6.ni.support=ni.support+support(SinClist);7.endfor8.endif9.endfor10.foreachleafnodeniinPTdo11.while(ni.support<ni.parent.support)12.ni.support++;13.endwhile14.endfor15.return(PTk)算法3输入剪枝后的前缀树PT以及剪除的序列集合Clist,输出k-匿名前缀树PTk.针对Clist中的每个待重构序列S,找到S与PT所表示序列的最长公共子序列,存入LCS中(第1、2行).Pleast中存储的是PT中包含LCS的最短路径(第3行).所谓最短路径是指,PT中不存在任何从根节点到叶子节点的路径,即包含LCS且长度又小于Pleast.若最短路径Pleast的长度小于S长度的2倍,则将S添加到最短路径上(第4~8行).如果叶子节点的支持度小于其父节点的支持度,直接增加叶子节点的支持度,直至与其父节点的支持度相等为止(第10~14行).图4与图5分别表示重构后的k-匿名前缀树与最终生成的可签到序列.图5中,每个用户至少有k-1个用户与其有相同的签到序列.4.4算法分析PrvateCheckIn算法的可用性与效率体现在以下两方面:(1)可签到序列达到了轨迹k-匿名且保Page7证损失签到位置最少.每个假名用户通过签到序列被唯一识别的概率至多为1/k,参见定理1;(2)PrivateCheckIn算法的时间复杂度为O(n×len),参见定理2.定理1.PrivateCheckIn算法生成的可签到序列满足轨迹k-匿名且损失签到位置最少.证明.首先证明PrivateCheckIn算法生成的可签到序列满足轨迹k-匿名,然后证明可签到序列的损失签到位置最少.前缀树构建算法将假名用户的签到序列表示为前缀树,每个节点的支持度为签到序列中包含该节点的用户数.前缀树剪枝算法将所有支持度小于k的节点或路径剪除,其余节点的支持度至少为k.遍历k-匿名前缀树生的签到序列满足轨迹k-匿名.损失签到位置主要发生在前缀树剪枝和前缀树重构过程中,预处理过程中删除SPR中的敏感位置是用户的设置导致的,与算法性能无关.前缀树剪枝算法将支持度小于k且深度大于2的叶子节点及支持度不足k的非叶子节点所在的整条路径剪除.剪除的叶子节点只有一个签到位置,不需要重构操作已是最少损失位置.支持度不足k的路径通过重构可减少损失签到位置.重构算法找到包含最大公共子序列的最短路径,若该最短路径的长度小于需重构序列长度的2倍,则进行重构,反之,则不进行重构.这是由于在这种情况下的重构反而会增加损失签到位置的数量.上述规则保证了添加或删除的签到位置数最少,即损失签到位置最少.证毕.定理2.PrivateCheckIn算法的时间复杂度为O(n×len).证明.设签到序列集合中含有n条签到记录,且签到序列的平均长度为len.算法1需扫描每一个签到记录,以便查找每个签到序列的最大前缀,查找最大前缀的时间复杂度为O(len),因此构建前缀树算法的时间复杂度为O(n×len).在最坏情况下前缀树PT含有n个节点.算法2在最坏情况下需检查前缀树中每个节点的支持度,因此其算法复杂度为O(n).算法3为Clist中每个序列执行一趟算法.一趟前缀树重构算法的复杂度取决于求最长公共子序列的时间复杂度.查找两个序列的最大公共子序列的时间复杂度为O(len2),前缀树PT中并未删除签到序列,因此PT中包含的签到序列个数与签到序列集合中的一致,即n/len个.算法3需计算PT所表示的每个序列与待重构序列的最大公共子序列,其时间复杂度为O(len2×n/len),即O(n×len).PrivateCheckIn算法的时间复杂度为O(n×len).5实验结果及分析5.1实验设置PrivateCheckIn算法采用Java实现,在Q84002.6GHz处理器、4GB内存的Windows7平台上运行.本文采用的数据集是来自移动社交网络Gowalla和Brightkite上的真实签到数据[19].数据集Gowalla收集了从2009年2月至2010年10月的签到数据;数据集Brightkite收集了从2008年10月至2010年10月的数据.本文对两个数据集进行了预处理,只保留签到位置在加州的数据,数据集属性如表1所示.签到位置数量GowallaBrightkite675809541169151169435443556443556用户密度/(个·(km2)-1)GowallaBrightkite0.030.0244.7157.366.296.10平均签到时间间隔/hGowallaBrightkite40.3156.8119.0215.39轨迹隐k-匿名算法(k,δ)-anonymity[11]通过聚类找到轨迹k-匿名集,它达到的轨迹隐私保护效果与PrivateCheckIn算法相同,可作为对比算法.(k,δ)-anonymity的输出结果是轨迹采样点的k-匿名区域序列.匿名区域在签到服务中不可用,本实验将匿名区域覆盖的签到位置作为有效输出.若匿名区域序列覆盖了k个用户的签到位置,则构成可签到序列,匿名成功.(k,δ)-anonymity方法聚类后生成的簇经过时空变换过程转化为半径至多为δ的簇.时空变化是指将在半径δ之外的轨迹采样点“挪动”到半径δ之内.本实验中δ的取值参照文献[11].显然,在签到服务中的时空变换有诸多劣势:(1)挪动后的地理坐标不一定是语义位置,造成签到失败;(2)时空变换导致簇半径变小,导致某些簇覆盖不足k个用户的签到位置,造成k-匿名失败.不满足轨迹k-匿名的签到序列将被删除,形成损失签到位置.5.2实验结果及分析本实验在不同的参数取值下,测试签到成功率Page8和算法运行时间,以验证PrivateCheckIn方法的准确性与有效性.实验设置的参数包括隐私保护参数k、签到序列长度len以及最长容忍时间Δt.其中,签到成功率Cs反映了k-匿名签到序列中包含用户原始签到位置的比例,用式(1)衡量.Cs=|kChSiL|-|kChSiL|-|ChSiL|其中,|kChSiL|表示k-匿名签到序列的签到位置数量;|ChSiL|表示原始签到序列中的签到位置数量.PrivateCheckIn方法仅为假名用户提供隐私保护,本实验假设数据集中所有用户均为假名用户,并将历史签到序列视为用户缓存的签到序列.图6签到成功率与隐私保护参数k隐私保护参数与签到成功率.图6展示了隐私保护参数k的取值对签到成功率的影响.隐私保护参数k的取值从5增加到12.从图6可以看出,签到成功率随隐私保护参数k的增加而减小.k的增大导致PrePrune和PrivateCheckIn剪枝的节点和路径增加,造成更多的损失签到位置,导致签到成功率下降.k的增大导致(k,δ)-anonymity方法匿名失败的签到序列增多,也导致了签到成功率的下降.由对比实验可以看出,PrivateCheckIn的签到成功率最高.3个算法在Brightkite数据集上的签到成功率均低于在Gowalla数据集上,这是由于Brightkite数据集较稀疏,用户数和签到数均小于Gowalla.PrivateCheckIn的签到成功率在两个数据集上均高于60%,明显优于PrePrune,前缀树重构有效地提高了签到成功率.另外,隐私保护参数k取值较小时,重构前缀树提升的签到成功率并不明显,随着k的增加,PrivateCheckIn方法提升的签到成功率越来越明显,最大值出现在图6(a)中k=12时,PrivateCheckIn方法比PrePrune的签到成功率提升了14.5%.(k,δ)-anonymity方法的签到成功率在两个数据集上均不如PrePrune和PrivateCheckIn,这是由5.2.1签到成功率签到成功率是衡量用户体验的重要参数.为了对比前缀树重构前后签到成功率的变化,本文将仅包含前缀树构建和剪枝的算法记为PrePrune,包含前缀树构建、剪枝及重构的算法记为PrivateCheckIn,对比算法记为(k,δ)-anonymity.实验分别在Gowalla和Brightkite两个数据集上进行,在每个数据集中随机选取3000个用户的签到序列,在测试隐私保护参数k与序列长度len对签到成功率的影响时,不考虑最大时间容忍度的变化.图6~图8展示了3个算法的平均签到成功率.于聚类算法是以签到序列距离为基础的,如果签到数据在地理上分布稀疏,易造成簇半径过大,导致匿名失败,而匿名失败后的签到序列被全部删除,也导致损失签到位置的增加.PrePrune和PrivateCheckIn方法不考虑签到位置之间的距离,地理上稀疏的签到对其影响不大.从图6两个子图的对比也可以看出(k,δ)-anonymity受数据稀疏程度的影响.在图6(a)中,(k,δ)-anonymity的签到成功率和PrePrune较为接近,而图6(b)中(k,δ)-anonymity的签到成功率与PrePrune的差距变大,这是由于Brightkite数据集的稀疏性使得(k,δ)-anonymity的签到成功率更低.签到序列长度与签到成功率.图7表示签到序列长度对签到成功率的影响.签到序列长度取值为5~30,每次增加5.签到序列长度的取值与数据集属性有关.Gowalla收集了用户16个月的签到数据,其平均签到序列长度为44.71;Brightkite收集了用户24个月的签到序列,平均长度为57.36.用户缓存签到序列的时间远远小于数据集跨越的时间,因此,len最大值取为30是合理的.本实验在随机选取的3000名用户的签到序列上截取或随机补足满足长度要求的值,在k=10时进行了实验.从图7中可以看出,签到序列长度len的增加导致Page93个算法的签到成功率的下降,len的增长对PrePrune和PrivateCheckIn的签到成功率影响较大,这是由于签到序列越长,完全相同的签到序列越少,生成k-匿名前缀树的过程会造成更多的损失签到位置.签到序列长度len值较小时,重构前缀树对提升签到成功率的贡献较大,随着len值的增长,重构算法所提升的签到成功率越来越低.这是由于随着序列长度的增加,重构时需要添加更多的损失签图7签到成功率与签到序列长度的关系最长容忍时间与签到成功率.图8表示最长容忍时间对签到成功率的影响.最长容忍时间即用户缓存签到序列的时间.在数据集属性分析中,本文通过实验获取了两个数据集的签到时间间隔,如表1所示.最长容忍度Δt的取值为1~5倍平均签到时间.在本实验中,k的取值为10,对签到序列长度len没有特殊限制.图8是Δt的变化对签到成功率的影响.3个算法的签到成功率随最长容忍时间的增加而增加,这是由于缓存的签到序列越多,PrePrune图8签到成功率与最长容忍时间Δt的关系由3组对比实验可以看出,PrivateCheckIn方法在签到成功率上明显优于(k,δ)-anonymity方法.5.2.2算法效率测试算法效率的实验在数据集Gowalla上取不同的隐私保护参数k值(取值5~15,递增2)和签到序列长度len值(取值5~30,递增5),针对每个k到位置,使签到成功率的提升不明显.len的增长对(k,δ)-anonymity的签到成功率影响不大,这是由于序列长度的增加仅影响了轨迹距离,且对影响有限,因此,对聚类结果的影响也比较小.虽然len取值为30时,PrivateCheckIn方法的表现一般,但在len取值小于20时,签到成功率仍能达60%以上.由用户的平均签到序列长度可以看出,缓存15~20个签到位置已能满足大多数用户的需求.和PrivateCheckIn越容易生成k-匿名前缀树,而签到序列较少时,生成k-匿名前缀树易造成更多的损失签到位置,(k,δ)-anonymity方法也是同理,缓存的签到序列越多,越可能通过聚类找到k-匿名集.在Δt取5倍平均签到时间时,PrivateCheckIn在两个数据集上的签到成功率均可达70%左右.对用户来说,若想获得较好的签到成功率,可以将缓冲时间设置得较长.和len值分别运行算法PrivateCheckIn和(k,δ)-anonymity1000次,图9所示为两个方法在Gowalla数据集上的平均运行时间.Brightkite数据集大小与Gowalla相差不大,运行时间非常接近,本实验只展示了两个算法在Gowalla上的运行时间.在图9(a)的实验中,不限制签到序列的长度,在图9(b)的Page10实验中,隐私保护参数k=10.从图9(a)可以看出,随着隐私保护参数k的增加,两个算法运行时间也不断增加.对PrivateCheckIn来说,k的增加导致在剪枝过程中有更多的路径被剪除,并存储在Clist中,增大了重构过程的开销.对(k,δ)-anonymity来说,k的增大导致聚类代价的增大,造成运行时间的增加.从图9(b)中可以看出,两个算法的运行时间随着签到序列长度的增长而增加,PrivateCheckIn的增大趋势明显大于(k,δ)-anonymity.这是由于增加签到序列长度len意味着生成的前缀树深度更大,图9算法运行时间对比6结论与展望针对移动社交网络中假名用户的位置及轨迹隐私泄露问题,本文提出一种基于前缀树的轨迹隐私保护方法PrivateCheckIn.该方法用缓存的用户签到序列构造前缀树,通过对前缀树的剪枝及重构找到用户的k-匿名签到序列.PrivateCheckIn方法适用于移动社交网络中的签到服务,在保护用户轨迹隐私的同时保证了较高的签到成功率.此外,该方法简化了寻找轨迹k-匿名集的过程,提高了隐私保护算法的运行效率.通过与(k,δ)-anonymity方法的对比实验验证了PrivateCheckIn方法的准确性和有效性.今后的研究将考虑如下两个方面:(1)隐私保护服务器的部署问题.目前,移动社交网站数目繁多,如何将本文提出的隐私保护服务应用在多个移动社交网络上是一个值得研究的问题,此外,隐私保护服务器的运行、维护问题也值得深入探讨;(2)移动社交网络中更复杂的攻击模型,例如,结合用户的社会关系等背景知识产生的隐秘位置推理攻击.在该攻击模型下的隐私保护也是值得深入研究的问题.在查找最大前缀时需要的时间较长.而对(k,δ)-anonymity来说,增大序列长度仅影响轨迹距离计算的代价,对总体运行时间的影响有限.图9展示的运行时间是PrivateCheckIn算法在整个数据集上的运行时间,平均每个签到序列所需的处理时间较短,例如,在Gowalla数据集上k=5时,平均每个用户的处理时间仅为2ms(31s/15116个签到序列).由对比实验可以看出,构建前缀树为基础的方法PrivateCheckIn在效率上明显优于以聚类为基础的(k,δ)-anonymity方法.
