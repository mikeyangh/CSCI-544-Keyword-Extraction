Page1数据流上近似非可导项集的挖掘算法黄崇争1),2)李海峰3)陈红1)1)(中国人民大学信息学院北京100872)2)(广西建设职业技术学院计算机与信息技术系南宁530003)3)(中央财经大学信息学院北京100081)摘要频繁项集是通过对大规模数据进行挖掘获取的代表数据模式的知识结构.非可导频繁项集作为频繁项集的有效压缩方式,能够高效深入地挖掘海量数据、稠密数据与数据流当中的规律.针对项集在计算界限值时代价昂贵的缺点,提出了近似可导项集的概念,并基于纵向数据格式实现了挖掘算法MANDI,能够提高支持度计算和项集间操作的速度.另外,为了满足数据流实时、快速的特点,讨论并证明了近似可导项集的增量性质,提出了可动态更新的算法UANDI.通过实验验证了两种算法的可行性和有效性.关键词近似非可导频繁项集;纵向数据格式;数据流;数据流挖掘1引言频繁项集是Agrawal在1994年提出来的[1],其动机是为了寻找超市事务数据的频繁集以分析客户的购买行为.近年来随着在众多行业中广泛的应用,频繁项集挖掘受到了广泛关注,逐渐发展成为数据挖掘中重要的分支,其目标是在数据集中寻找用户感兴趣的模式,例如关联规则[2]、数据相互关系[3]和序列模式[4]等.随着网络及大规模商业集成等应用Page2的出现,海量数据、稠密数据和数据流的产生,频繁项集挖掘逐渐不能满足用户的需要,这主要体现在两个方面:一方面,在数据高度相关或者最小支持度设置过低的情况下,会生成大量的频繁项集,这些频繁项集的数量甚至超过了原有数据集中数据的数量,浪费了大量的系统资源;另一方面,频繁项集本身包含了大量的冗余信息,影响了用户的判断.因此,简单的频繁项集挖掘对于用户来说已经意义不大.研究人员开始寻找频繁项集的压缩表示方法,希望去除频繁项集中的冗余数据,实现有效的数据精简.迄今为止,已经找到了包含闭合频繁项集[5-7]、最大频繁项集[8-9]、无关频繁项集[10]和非可导频繁项集[11-15]在内的多种压缩表示.在这些压缩表示中,非可导频繁项集被证明是最小的压缩表示方式[14],不但可以节省大量系统资源,而且能够使用户更好地理解关联规则[15],因此具有重要的意义.非可导频繁项集是在2002年根据演绎规则[11]提出来的.目前已经提出的挖掘非可导项集的算法有NDI[11]、QIE[12]以及dfNDI[13]等.NDI是最简单的基于Apriori的宽度遍历算法,通过候选集的生成,扫描数据库得到频繁项集,并进一步计算以判断项集是否可导;dfNDI利用一种新颖的方法,通过项集的逆序分析实现了深度遍历;另外,QIE针对非可导项集计算边界时的巨大计算量进行了改进,用数组来保存需要边界计算的项集,有效提高了性能;文献[15]将非可导项集应用到关联规则挖掘上,取得了良好的效果.文献[14]综述了非可导项集挖掘的方法,并与其它频繁项集的压缩表示方式进行了比较.但是,这些算法都是针对静态数据集来挖掘精确的结果,具有以下的缺点:首先,一旦数据增加,算法需要重新运行来获取新的结果;其次,由于需要多遍扫描数据库来计算支持度,算法的计算代价偏高;最后,在项集变长的情况下,决定项集是否可导的计算量迅速增加,计算代价昂贵.综上所述,以上算法都不能有效处理数据动态变化的情况.本文在这些研究的基础上,从挖掘结果的近似性,改变数据格式和增量式挖掘3个方面来考虑数据流上非可导项集挖掘,主要贡献有(1)提出了近似非可导项集的概念,可以有效地实现搜索空间的剪枝和计算代价的降低,通过设置近似参数,可以实现算法性能与结果精确度的折衷.(2)提出了基于纵向数据格式的近似非可导项集挖掘算法,只需要扫描数据集一次就可以完成支持度计算,降低了算法的运行时间.(3)目前国内外还没有关于近似非可导项集增量式挖掘的工作.本文对近似非可导项集的性质进行了研究,证明了近似非可导项集在新数据库中的不变性,通过维护近似非可导项集的临界项集集合实现增量式更新算法,以处理动态变化的数据流数据.(4)在两种模拟数据集和两种真实数据集上进行了算法的实验验证,并与迄今为止性能最好的非可导项集挖掘算法dfNDI进行了比较,实验结果表明了本文两种算法的可行性和有效性.本文第2节介绍非可导项集的相关知识;第3节提出近似非可导项集的概念与基于id列表的纵向数据格式;第4节提出近似非可导项集的挖掘算法MANDI;第5节提出近似非可导项集的增量更新算法UANDI;第6节是算法的时间复杂度分析;第7节是实验;第8节是本文的总结.2预备知识2.1频繁项集频繁项集是数据集中发生次数不小于用户定义阈值的项集.用Γ={i1,i2,…,in}来表示所有不同项的集合,其中|Γ|=n表示Γ的数量,称长度为k的Γ的子项集X为k-项集.为了简单起见,可以把项集X={x1,x2,…,xm}表示为x1x2…xm.给定数据集D={T1,T2,…,Tv},每一个Ti(i=1…v)表示一个基于Γ的事务,包含事务id和对应的项集X.对于事务T=(tid,X)来说,如果存在项集Y使得YX,则称事务T支持项集Y,所有D中支持项集Y的事务集合称为Y的覆盖,表示为cover(Y,D)={T|TD∧YX∧X∈T}.Y的绝对支持度是其覆盖集合的大小,表示为Λ(X,D)=|cover(X,D)|,其相对支持度是Y在D中发生的概率,即Y的绝对支持度与数据集D大小的比值,表示为Λr(Y,D)=Λ(Y,D)|D|.给定最小支持度阈值γ,如果Λ(Y,D)γ,则称项集Y为频繁项集.2.2纵向数据格式数据集的纵向表达方式是指采用二元组(item,tidlist)形式表示的数据库,即每个项目i对应覆盖该项集的事务id列表TS(i).给定数据库D,对于项集I={i1,i2,…,im}来说,I的事务id列表可以通过每个项目的事务id列表得到,即TS(I)=TS(i1)∩TS(i2)∩…∩TS(im),项集I的支持度Λ(I)即TS(I)中含id的数量.例1.图1中的数据集可以表示为(itemset,tidlist)的形式.可以看到,项目a被全部事务覆盖,Page3对应的id列表为TS(a)={1,2,3,4,5},因此a的支持度为5.对于项集ab,其对应的id列表TS(ab)=TS(a)∩TS(b)={2,3,5},因此ab的支持度为3.2.3演绎规则非可导项集的概念来源于演绎规则[11].给定项目a,a的逆表示为a-.一个事务T如果覆盖a-即T不覆盖a.一个泛化项集就是项目与项目的逆组成的集合,给定项集I=X∪Y,基于I的泛化项集表示为G=XY-.如果一个事务T={tid,J}满足XJ且T∩J=,则称T支持G.例如,在Γ={a,b,c,d}的情况下,给定泛化项集G=abcd,那么对于数据集{ab,abc}来说,因为ab覆盖a和b,但不覆盖c和d,因此ab支持G;而abc虽然覆盖a和b,但同样覆盖c,因此abc不支持G.演绎规则是通过包含排除(inclusion-exclusion)原则[16]推导出来的,给定基于项集I=X∪Y的泛化项集XY,演绎规则可以表示为Λ(XY)=∑XJI(-1)|J/X|Λ(J),从而得到以下的定理.定理1[11].令Γ表示不同项目的集合,对于项集I,如果XIΓ且Y=I/X,则有以下不等式成立.Λ(I)∑XJIΛ(I)∑XJI演绎规则RX(I).例2.表1是项集I=abc针对每个XI的IXabcΛ(abc)Λ(ab)+Λ(ac)+Λ(bc)-Λ(a)-abcaΛ(abc)Λ(ab)+Λ(ac)-Λ(a)abcbΛ(abc)Λ(ab)+Λ(bc)-Λ(b)abccΛ(abc)Λ(ac)+Λ(bc)-Λ(c)abcabΛ(abc)Λ(ab)abcacΛ(abc)Λ(ac)abcbcΛ(abc)Λ(bc)abcabcΛ(abc)02.4非可导项集从项集I的演绎规则可以得到I的支持度Λ(I)基于每个XI的界限ulX(I).当|I\X|是奇数的时候,ulX(I)为Λ(I)的上限,表示为uX(I),uX(I)的最小值称为Λ(I)的最小上限,表示为mu(I);当|I\X|为偶数的时候,ulX(I)为Λ(I)的下限,表示为lX(I),lX(I)的最大值称为Λ(I)的最大下限,表示为ml(I).因此,Λ(I)的最大下限和最小上限组成了Λ(I)的范围区间,即Λ(I)∈[ml(I),mu(I)].如果ml(I)=mu(I),那么Λ(I)=ml(I)=mu(I),称I为可导项集,可导项集是单调的,即对于两个项集S和T且ST,如果S是可导的,那么T也是可导的;反之,如果ml(I)≠mu(I),则称I为非可导项集.非可导项集有以下性质.性质1[14].给定项集IΓ和项目a∈Γ\I,有mu(I∪a)-ml(I∪a)mu(I)-ml(I)性质2[14].项集I的支持度Λ(I)的范围区间大小mu(I)-ml(I)随着项集长度增大呈指数趋势降低.给定事务数据库D和项集IΓ,如果|I|>log2(|D|)+1,那么I一定是可导的.例3.给定事务数据集{abc,ab,ac,bc},对于abc来说,有和Λ(abc)即Λ(abc)∈[1,1],所以abc是可导项集;对于ab来说,有和Λ(ab)l(ab)=2即Λ(ab)∈[2,3],所以ab是非可导项集.另外,根据性质1,因为ababc,所以mu(abc)-ml(abc)=0(mu(ab)-ml(ab))/2=1/2成立.3近似非可导项集3.1定义与性质根据定理1可知,对于一个项集I来说,如果I的长度为m,计算I范围区间的代价最多达到了2m次,已经成为非可导项集挖掘中耗时最多的计算之Page4一,为了尽快实现剪枝,防止非可导项集的长度太大,提出了近似的非可导项集的概念,来降低运行时间的代价.定义1(近似非可导项集).给定整数θ0,对于项集I来说,如果存在X,YI使得uX(I)-lY(I)θ,则称项集I为近似可导项集,反之称I为近似非可导项集.θ称为近似参数.近似非可导项集是非可导项集的扩展,当θ=0的时候,近似非可导项集挖掘变为精确的非可导项集挖掘.通过近似参数的调整,可以提高非可导项集挖掘的灵活性和健壮性,保证在不同的计算环境下用尽可能少的时间得到合理的结果.性质3.近似可导项集是单调的.证明.令近似参数为θ,给定项集S,T和项目a,T=S∪a,如果S是近似可导项集,则存在X,YS使得uX(S)-lY(S)θ,根据性质1可知,至少存在X,YT使得uX(T)=mu(T)和lY(T)=ml(T),即存在X,YT,使得uX(T)-lY(T)=mu(T)-ml(T)mu(S)-ml(S)uX(T)-lY(T)θ,所以T也是近似可导项集.近似非可导项集具有3方面的优势:首先,近似可导项集的单调性允许算法进行搜索空间的剪枝,可以减少项集的存储代价;其次,与可导项集必须基于每个项集的子项集计算界限相比,近似可导项集的界限计算有了更容易获取的目标,只需要根据项集的部分子项集来进行计算就可以得到期望的结果;最后,由于近似可导项集提供了更宽松的范围区间,因此可以使得项集的范围区间能够更加快速地收敛,从近似非可导项集变为近似可导项集,不仅可以提前剪枝,而且进一步减少了项集界限计算的代价.例4.对于图1的数据集来说,令最小支持度γ=2,近似参数θ=1.对于项集ab来说,Λ(ab)∈[3,4],当采用精确的挖掘方法时,ab是非可导项集,因此其超集仍然可能是非可导项集,因此需要进一步生成ab的超集{abc,abd,abe},并计算相应的支持度和界限;当采用近似的挖掘方法时,ab是近似可导项集,因此其超集都是近似可导项集,可以全部被裁剪.对于项集abc来说,假定需要计算其界限,当采用精确的挖掘方法时,需要根据abc的子集{ab,ac,bc,a,b,c}分别计算界限,计算的数量为6次;当采用近似的方法时,当计算出ubc(abc)=2和la(abc)=1时,由于ubc(abc)-la(abc)=1,即可以停止计算,计算的数量为4次.3.2数据结构为了描述分析各种搜索空间的剪枝策略,避免冗余项集的生成和检测,引入项集之间的词典序.给定项目a、b和c,定义三者的词典序abc,通过这种方法,可以建立数据库所有项集的唯一顺序,在图1的数据库中,对于项集ab,ac,abc来说,其顺序为ababcac.由于采用纵向数据格式不需要重新扫描数据库即可以得到支持度,因此在以往采用纵向数据格式的算法中,无论是频繁项集挖掘算法Eclat[17]、闭合频繁项集挖掘算法CHARM[7],还是最大频繁项集挖掘算法MAFIA[9],都具有良好的性能.因此本文借鉴了以往基于纵向数据格式的算法,应用于非可导项集的挖掘.采用了三元组〈it,sup,TS〉来保存每个项集.其中it用来保存项集,每个项集根据字符的词典序排序,可以提高项集的交并操作的速度,降低冗余项集的检测和生成代价;sup用来保存项集在数据集中的支持度;TS用来保存数据集中覆盖项集it的事务的id列表.4近似非可导项集挖掘算法MANDI定义2(临界近似可导项集).给定项集I,如果I是近似可导的,并且任给JI,J都是近似非可导的,则称项集I为临界近似可导项集.定义3(临界非频繁项集).给定项集I,如果I是非频繁的,并且任给JI,J都是频繁的,则称项集I为临界非频繁项集.MANDI算法是基于Apriori的宽度遍历算法,采用基于非频繁项集的单调性来裁剪非频繁项集,采用基于近似可导项集的单调性来裁剪近似非可导项集.为了实现剪枝,MANDI算法保存了近似非可导频繁项集的临界项集集合:一部分是最有希望成为频繁项集的临界非频繁项集的集合IFSD,另一部分是最有希望成为近似非可导项集的临界近似可导项集的集合DISD.给定图1的前4个事务,最小支持度γ=2,近似参数θ=1,如图2所示,可以得到近似非可导项集集合{a,b,c,d,e,de}、临界近似可导项集集合{ab,ac,ad,ae}和临界非频繁项集集合{f,bc,bd,be,cd,ce}.可以看到,尽管abc,abd,abe,acd,ace,bde,cde都是非频繁项集,但由于它们有非频繁的子集,因此他们不是临界非频繁项集,可以被剪裁掉;而尽管ade是近似可导项集,但它有可导子Page5集{ad,ae},因此它不是临界近似可导项集,可以被剪裁掉.对于每个项集I,MANDI算法通过I的子集的事务id列表来计算支持度,如果I是非频繁的,将I存入临界非频繁项集集合IFSD,并且停止生成I的超集;如果I是频繁的,则计算I的界限,如果I是近似可导的,将I存入临界近似可导项集集合DISD,否则将I存入近似非可导项集集合NDISD,并生成I的超集.算法1.MANDI(D,γ,θ,NDISD,DISD,IFSD).输入:数据集D,相对最小支持度γ,近似参数θ输出:近似非可导项集集合NDISD,临界近似可导项begin1.扫描数据集D,生成D的纵向表达方式Dv;2.l=1;NDISD={};DISD={};IFSD={};3.Cl=Dv;//Cl表示长度为l的项集的集合;4.whileCl非空do5.Gen={};6.foreachCl中的项集Ido7.ifΛ(I)γthen8.根据每个XI计算I的上限uX(I)和下限9.if存在X,YI使得10.DISD=DISD∪I;11.else12.NDISD=DNISD∪I;13.Gen=Gen∪I;14.endif15.else16.IFSD=IFSD∪I;17.endif18.endforeach19.生成Gen中项集的超集集合Cl+1;20.根据Gen中项集的id列表计算Cl+1中项集的id21.l=l+1;22.endwhileend例5.假设数据集D为图1中的前4个事务,令最小支持度γ=2,近似参数θ=1.MANDI算法的执行过程如下所示:1.扫描数据集D,有C1={〈a,4,(1,2,3,4)〉,〈b,2,(2,3)〉,〈c,2,(3,4)〉,〈d,2,(2,4)〉,〈e,2,(2,4)〉,〈f,0,()〉},得到NDISD={a,b,c,d,e},DISD={},IFSD={f}和Gen={a,b,c,d,e}.2.生成C2为{〈ab,2,(2,3)〉,〈ac,2,(3,4)〉,〈ad,2,(2,4)〉,〈ae,2,(1,2)〉,〈bc,1,(3)〉,〈bd,1,(2)〉,〈be,1,(2)〉,〈cd,1,(4)〉,〈ce,1,(4)〉,〈de,2,(2,4)〉},得到NDISD={a,b,c,d,e,de},DISD={ab,ac,ad,ae},IFSD={f,bc,bd,be,cd,ce}和Gen={de}.3.生成C3为空,算法结束.5近似非可导项集更新算法UANDI定理2[18].给定一个增加的事务S={tid,T}和项集I,令N=T∩I,对于每个项集XI,用lX(I)和uX(I)表示I在原数据集D中的下限和上限,用lX(I)和uX(I)表示I在新数据集D∪S中的下限和上限,有以下公式成立.如果NI并N=X,有如果NI并且N≠X,有如果N=I,有推论1[18].给定项集I,增加一个新事务S={tid,T}只会使得mu(I)-ml(I)的值增大,且最多增大1.推论2.增加事务不会将近似非可导项集变为近似可导项集,但可以将近似可导项集变为近似非可导项集.证明.给定近似参数θ,对于近似非可导项集I来说,mu(I)-ml(I)>θ,根据推论1,增加新事务会提高mu(I)-ml(I)的值,所以mu(I)-ml(I)>θ仍然成立,所以I仍然是非可导项集;对于近似可导项集I来说,mu(I)-ml(I)θ,增加新事务可以提高mu(I)-ml(I)的值,所以mu(I)-ml(I)可能变为大于θ的正整数,所以I会变为近似非可导项集.根据推论2可以知道,原数据集中的近似非可导项集在增加数据后中仍然是近似非可导的.这种情况下,只要检测原数据集的临界项集是否改变,并Page6进行相应的扩展,就可以得到新数据集的近似非可导项集集合.令原数据集为D,新增数据集为d,则合并后的新数据集为D∪d.在增加d后,采用UANDI算法对d进行扫描,更新原数据集的近似非可导项集的支持度,并重新计算临界项集集合的支持度和界限,就可以生成更新后的近似非可导项集集合NDISD∪d,临界近似可导项集集合DISD∪d和临界非频繁项集集合IFSD∪d.算法2.UANDI(D,d,γ,θ,NDISD∪d,DISD∪d,IFSD∪d).输入:原数据集D,新增数据集d,相对最小支持度γ,输出:近似非可导项集集合NDISD∪d,临界近似可导begin1.扫描数据集d,更新NDISD,DISD和IFSD中项集2.foreachDISD中的项集Ido3.根据每个XI计算I的上限uX(I)和下限lX(I);4.if任给X,YI都有uX(I)-lY(I)>θthen5.将I从DISD移到NDISD中;6.调用过程Explore(NDISD,DISD,IFSD,I,7.endif8.endforeach9.foreachIFSD中的项集Ido10.ifΛ(I)γthen11.根据每个XI计算I的上限uX(I)和下限12.if存在X,YI使得uX(I)-lY(I)θthen13.将I从IFSD移到NDISD中;14.调用过程Explore(NDISD,DISD,IFSD,I,γ,θ);15.else16.将I从IFSD移到DISD中;17.endif18.endif19.endforeachendExplore(NDISD,DISD,IFSD,I,γ,θ)全局变量:队列Gen={};begin1.foreachNDISD中与I长度相同的项集Jdo2.if|I∩J|=|I|-1then3.K=I∪J;4.根据I与J的id列表计算K的id列表和支5.ifΛ(K)γthen6.根据每个XK计算I的上限uX(K)和下7.if存在X,YK,使得uX(K)-lY(K)θ8.DISD=DISD∪K;9.else10.NDISD=NDISD∪K;11.push(Gen,K);12.endif13.else14.IFSD=IFSD∪K;15.endif16.endforeach17.whileGen非空do18.K=pop(Gen);19.调用过程Explore(NDISD,DISD,IFSD,K,20.endwhileend例6.假设图1中的前4个事务为原数据集D,后2个事务为新增数据集d,令最小支持度γ=2,近似参数θ=1.UANDI算法的执行过程如下所示.1.扫描数据集d,得到更新后的近似非可导项集集合NDISD={〈a,5,(1,2,3,4,5)〉,〈b,4,(2,3,5,6)〉,〈c,3,(3,4,5)〉,〈d,4,(2,4,5,6)〉,〈e,3,(2,4,6)〉,〈de,3,(2,4,6)〉},近似可导项集集合DISD={〈ab,3,(2,3,5)〉,〈ac,3,(3,4,5)〉,〈ad,3,(2,4,5)〉,〈ae,2,(2,4)〉}和非频繁项集集合IFSD={〈f,0,()〉,〈bc,2,(3,5)〉,〈bd,2,(2,5)〉,〈be,2,(2,6)〉,〈cd,2,(4,5)〉,〈ce,1,(4)〉}.2.对于DISD中的每个项集分别计算上下界,ab,ac,ad,ae仍然可导,因此NDISD和DISD没有变化.3.对于IFSD中的新频繁项集计算上下界,可知bc,bd,be,cd变为非可导项集,因此得到NDISD={a,b,c,d,e,bc,bd,be,cd,de},DISD={ab,ac,ad,ae}和IFSD={f,ce}.4.对NDISD中新的近似非可导项集bc,bd,be,cd分别调用过程Explore,得到NDISD={a,b,c,d,e,bc,bd,be,cd,de},DISD={ab,ac,ad,ae,bde}和IFSD={f,ce,bcd,bce}.5.结束.6算法时间复杂性分析如算法1所示,MANDI算法的实际运行时间取决于非可导项集的数量和长度,并且与近似参数θ相关:非可导项集的数量越多,且平均长度越大,则运行时间越长;θ越小,精确度越高,需要完成的界限计算量越大,则运行的时间越长.假设长度为i(1in)的非可导项集的数量为mi,且计算非可导项集上下界限的平均时间为t,则MANDI算法的时间复杂度为Ot∑nPage7大小随着项集长度的增大而呈指数级增长,但实际性能却要好得多.首先,给定数据集D,对于一个项集I来说,其界限计算代价不是随着项集I的长度增长无限变大的,从性质2可知,如果|I|>log2(|D|)+1,则I一定是可导的,即使在最坏情况下最小支持度为1时,其界限计算的时间复杂度为O(2log2(|D|)+2|I|)=O(|D||I|);其次,根据定义1可知,项集的界限不需要进行完全计算即可获得;最后,由于只需要考虑挖掘非可导项集,因此真正需要计算的结点并不多.如算法2所示,UANDI算法的实际运行时间与临界项集的数量有关,但主要取决于新增数据集中的非可导项集的数量和长度.这是因为每次生成一个非可导项集的时候,需要调用Explore函数来生成新的项集.其时间复杂度与MANDI算法相同.7实验用VisualC++在内存2GB,CPU为Xeon2.0GHz,操作系统为WindowsServer2003的机器上实现了MANDI和UANDI算法,并与目前性能最优的非可导项集挖掘算法dfNDI进行比较.另外,采用了4种标准的数据集作为实验的测试数据集:其中包括两种由IBM的数据生成器生成的模拟数据集T10I4D100K和T40I10D100K以及两种KDDCUP2000采用的真实数据集BMS-POS和BMS-Webview,其中BMS-POS是商品零售数据,图3T10I4D100K数据集BMS-Webview是电子商务网站的点击流数据.表2列举了4种数据集的主要数据特征.为了便于比较,给定数据集D,以下实验均采用绝对支持度完成挖掘,绝对支持度的值通过给定的相对支持度与|D|的乘积得到.数据集事务T10I4D100K10000010.1129870T40I10D100K10000039.6477942BMS-POS5155976.511641657BMS-Webview596012.512674977.1静态数据中的性能比较选取了每个数据集的前80%作为静态数据集.图3~图6的(a)部分显示了算法MANDI和dfNDI在不同支持度下的平均运行时间代价(每事务)的比较,为了体现近似性,MANDI分别采用近似参数θ=0,2,4完成挖掘.之所以这样取值,是因为根据性质1,项集支持度的范围区间随着项集长度的增大是呈2的指数级递减,因此θ以2的指数作为取值可以实现最大程度的优化.MANDI采用了纵向数据格式,能够迅速完成支持度计算,而dfNDI由于采用了深度遍历数据的方式,在一定程度上能够提高数据查找的速度,并减少冗余数据的产生.可以看到,在θ=0的时候,MANDI实际上是完成精确的挖掘,除了在数据集T10I4D100K上的性能与dfNDI相似外,MANDIPage8图4T40I10D100K数据集图5BMS-POS数据集在其它数据集上的性能均优于dfNDI.当近似参数θ增大的时候,减少了非可导项集的数量和项集界限的计算量,MANDI算法的性能有了进一步的提高.从图中可以看到,θ的值越大,其计算时间越少.7.2动态数据中的性能比较选取了每个数据集的前80%作为原数据集,剩余的20%作为新增数据集.图3~图6的(b)部分显示了算法UANDI和dfNDI在不同支持度下的平均运行时间代价(每事务)的比较.可以看到,即使在θ=0的时候,UANDI的性能仍然要远高于dfNDI,这是因为与dfNDI需要重新对整个数据库进行挖掘相比,UANDI只需要考虑处理原数据集中的临界项集集合即可.这样不需要重复计算原有数据集中项集的界限,节省了大量的计算开销.从图中可以看到,UANDI提高了至少2倍以上的计算性能,最多能够提高10倍左右.同样,在θ增大的情况下,Page9图6BMS-Webview数据集UANDI算法的性能有了进一步的提高.随着θ的变大,尽管UANDI算法中非可导项集数量变小,但这是因为最深层的非可导项集变成了临界项集,所以UANDI算法不会产生错误的非可导项集,即UANDI算法产生的结果一定是精确结果的子集或真子集.因此,我们只比较了UANDI算法的精确度.图3~图6的(c)部分显示了在不同的θ取值情况下UANDI算法挖掘结果的精确度,即UANDI算法与dfNDI算法的的非可导项集数量的比值.可以看到,当θ=0的时候,UANDI算法挖掘的结果精确度为100%,随着θ的增大,精确度有所降低,当θ=2的时候,精确度能够保证在90%以上,当θ=4的时候,精确度有了比较明显的下降,但仍然保持在最低75%的水平之上.综合以上的实验,可以看到MANDI算法尽管只是采用广度遍历的方式,但在支持度计算方面进行了优化,仍然能够达到提高性能的目的;而UANDI算法则通过增量式的更新来处理新增数据,减少了数据的重复计算,使得性能有了一个数量级的飞跃;另外,由于引入了近似参数,使得算法的实现更加灵活,能够在保证用户要求精确度的同时进一步降低计算代价,从图中可以看到,算法能够在保证精确度90%以上的情况下将性能提高3~5倍.8总结非可导项集挖掘是频繁项集挖掘的重要分支之一.本文提出了一种快速灵活的基于纵向数据格式的近似非可导项集挖掘方法MANDI,通过近似参数的调整,来实现性能与精确度的有效折衷.另外,本文针对数据流的特点对数据的增量更新进行了研究,证明了非可导项集在新增数据的情况下的不变性,提出了近似非可导项集的增量更新算法UANDI,通过维护近似非可导项集的临界项集集合实现增量式的挖掘.实验证明这两种算法是可行的、有效的.
