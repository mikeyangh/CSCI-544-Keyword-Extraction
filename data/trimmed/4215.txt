Page1一种软件测试需求建模及测试用例生成方法杨波1)吴际1)徐珞1),2)毕考1)刘超1)1)(北京航空航天大学计算机学院北京100191)2)(华北计算机研究所北京100083)摘要测试在需求分析阶段就开始介入,不仅能帮助开发人员更有效地完善需求,也能让测试人员设计出更贴近需求的测试.同时当需求进行了更改之后,测试人员也能及时和准确地了解需求的变化、更改测试需求.利用模型驱动的思想,对测试需求的概念进行阐述.定义了一种测试需求的元模型和测试需求建模方法,利用测试需求建模方法,可以得到测试需求模型,从而得到相应的测试目标,生成所对应的测试用例.并给出了对SIP协议进行测试的实验分析,在其中体现了利用测试需求建模得出的测试需求模型的作用.关键词需求工程;软件需求;软件测试;测试需求;模型;测试用例1引言长时间以来,需求和测试被认为存在先后的顺序关系.在进行软件需求分析阶段,测试被认为还没有开始.随着软件规模的扩大,这个观点得到了纠正.软件的需求与测试之间存在很紧密的联系,很Dorothy[1]指出,在软件的需求分析阶段,测试就开Page2始介入的话,能够使得软件的需求分析更加详尽.软件系统的需求是软件系统设计与实现的基础,需求质量会影响架构师设计出的架构、程序员写出代码,并且也会影响测试人员进行测试.随着软件系统规模和复杂性的增加,软件测试的任务也变得越来越复杂与繁重.为了减少测试过程的盲目性,提高测试过程的效率,在需求分析的开始阶段,就对测试任务进行明确的分析,对测试目标进行有效的组织,并进行准确的记录显得尤为重要.正如需求分析是软件系统设计与实现的基础,软件测试也应该以准确而详尽的测试需求分析为基础.有以下几个特点:在尽可能早的时候就开始进行的软件测试行为(1)软件的测试在被测系统的需求分析之时,就应该开始进行,在开发者与用户进行沟通之后,双方根据系统的需要,以及测试的需要,制定出相关的需求之后,测试的需求就可以通过被测系统规格说明或被测系统模型建立.这样在软件系统生命周期的早期,测试人员便可着手设计系统的测试计划、分析系统测试任务的规模并对合适的资源进行安排.整个从需求开始阶段就进行的测试,不仅对于完善需求有很大的帮助,同时对整个测试过程来说也有着十分重要的意义.(2)在理解清楚软件需求的基础之下,能够对软件的测试规划产生积极的影响[2].如果对软件的需求理解有误,那么将会导致对测试的需求理解错误,使测试过程产生偏差,要修正测试并重新实施可能会造成大量的人力、时间与资金的浪费.(3)软件的需求有时会发生变化,这在很多软件项目当中非常常见,而往往需求的变化会带来测试的变化,从软件的需求分析阶段就开始进行软件测试的规划与设计,能够在需求变化时,准确地找到测试当中可能变化的内容,从而快速地进行相应的补充或者调整.(4)软件的需求和软件的测试之间没有明显的先后之分,需求工程师和测试工程师之间可以相互合作,共同完善需求,这对于需求很重要,对测试也很重要.(5)在软件开发过程中,软件缺陷越早被发现,改正它的代价就越小.根据美国国家标准技术研究所(NIST)估计,在发布后修正缺陷的代价是在单元测试阶段修正的30倍.而IBM的估计更是高达上百倍.因此,遵循尽早开展测试的原则,不仅可以提高软件质量,同时也能够降低开发成本.(6)“重用”是软件开发中的一个重要问题[3-5].这种“重用”的思想对测试也产生了影响.一方面,由于被测系统中存在着重用的功能模块,因此势必引发了对重用相应的测试用例的诉求;另一方面,大量的已有测试制品(如测试设计、代码、自动化工具等)对于测试系统开发而言也是一笔宝贵的财富,重用这些制品势必可以提高新系统的开发效率.因此在测试活动变得越来越复杂的今天,需要测试需求作为测试活动的基础,用于描述测试目标,精确定义需要测试的内容,并指导整个测试过程的进行.在不同的文献与测试工具中,对于测试需求有不同的理解和描述方式.IBM公司RationalRobot①利用自然语言来描述测试需求,并以层次结构的方式进行组织,以作为整个测试过程的基础.欧洲电信标准化协会(ETSI)对一致性测试过程定义了一套方法学[6]:测试人员首先基于被测系统需求规格说明或协议标准文档等设计测试套结构(TestSuiteStructure,TSS)与测试目标(TestPurposes,TP),然后通过测试目标TP得到抽象测试用例(AbstractTestCases,ATC),通过测试套结构与测试目标(TSS&TP)得到抽象测试套(AbstractTestSuite,ATS),最后通过抽象测试用例ATC得到可执行测试用例,通过抽象测试套ATS得到可执行测试套.其中测试套结构与测试目标(TSS&TP)起到测试需求的作用,对测试目标进行分组并描述,作为后续测试活动的前提与基础.测试目标的概念在一致性测试领域得到了广泛的接受,除了欧洲电信标准化协会定义了TPLan语言[7],用来对测试目标进行半形式化的描述之外.Jard等人[8]将TP定义为一种包含接受和拒绝两个特殊状态的输入输出的标记迁移系统,并且通过形式化测试目标,来指导测试用例自动生成.Tretmans等人[9]也研究了测试目标描述和自动测试生成问题.另外,conformiq②使用模型标注的方式来表达测试需求,在利用conformiq来进行测试设计时,需要先使用UML2.0的状态机模型对SUT进行描述,接着再利用专门的语言来对状态机模型进行标注,标记出那些必须要覆盖的状态和迁移.这些标注都在此后的测试生成阶段,成为一个个对应的测试目标,这样在生成测试用例的过程当中,conformiq①②Page3可以找到相应的测试用例来覆盖这些目标.考虑到测试需求在不同的文献和工具当中的理解和定义并不相同,对测试的需求的描述方式也不一样.而测试的需求在整个测试过程当中相当重要,为此提出一种测试需求模型,来指导测试人员开展后续测试活动、方便测试人员与设计人员之间的沟通,还可在之后介绍的模型驱动测试的过程中对测试系统模型的生成提供必要信息.模型驱动测试使用测试模型表示测试架构和测试行为,使用图形化的方式创建测试模型.图形化的测试模型便于测试人员理解和修改.这样将对基于特定语言的难于理解的测试脚本的维护转化成对通用直观的测试用例模型的维护,从而降低了测试人员的工作量,提高了工作效率.模型驱动测试可以实现从模型到测试脚本的自动转化,从而保持模型和测试脚本的同步.当应用程序发生变动时,测试人员只需要对测试模型进行修改,并通过测试模型自动生成测试脚本.模型驱动测试可以有效地减少测试这一软件开发过程中初始阶段的工作量,并提高测试的覆盖率[10-11].目前,测试占据软件开发项目的30%~70%时间和资源的花费.模型驱动测试的这种新的方法和相关的工具集将提高软件开发者和测试者工作效率,并且在保持软件质量高标准的同时,减少产品投入市场的时间.测试需求模型的引入是模型驱动测试方法学的完善和补充,在系统设计模型向测试设计模型的转换过程中,测试需求模型提供必要的信息,对转换过程起指导作用;同时,通过测试目标生成测试用例,避免了基于测试过程中通过某种覆盖准则生成测试用例的盲目性,实现了生成的测试用例向相应的被测系统需求的向上追溯,使得测试人员更好的对整个测试过程进行评估.测试需求模型的应用场景如图1所示.首先通过测试需求元模型及其相关约束定义测试需求建模语言,这是整个测试需求模型的基础;然后基于测试需求建模语言的定义构造可视化的建模环境,用以对测试需求进行建模以及对测试需求模型语义正确性的自动化验证;同时,定义测试需求描述语言,可以实现由测试需求模型到测试需求描述脚本的自动转换;最后,由测试需求模型可以自动生成抽象测试用例.针对软件的需求和软件的测试之间存在的关系,提出了一种软件测试需求的定义,并且给出了测试需求建模的方法,利用模型驱动的思想,对软件的测试进行设计.第2节提出了测试需求的定义和测试需求模型,并且给予详细描述;第3节主要讲述如何从测试需求模型当中的描述模型生成测试用例;第4节给出使用本文方法进行的实验,并对实验结果进行分析;第5节给出相关工作的介绍;最后在第6节对本文工作进行总结和展望.2测试需求2.1测试需求定义件工程术语表[12]中对软件需求的定义.本文提出的测试需求的定义,参考了IEEE软测试需求的定义如下.(1)为了达到用户的测试目标,测试系统需要满足的条件或能力.(2)为了满足合同、测试标准、规范或其他强制性要求,测试系统需要具备的条件和能力.(3)对于(1)或(2)中条件或能力的清晰的、无二义性的表述.测试需求的好坏与整个测试过程紧密相关,对于一个良好的测试需求,我们希望它能够具备以下6个特征:(1)完整性.测试需求当中的每一项内容都必须是描述清楚的,以便测试人员在测试时获得所需要的必要的信息.(2)正确性.正确反应了测试任务和用户的要求.(3)可追溯性.从测试需求可向上回溯到系统需求和设计,向下追踪到测试用例.(4)清晰性.测试需求描述是清晰的、无二义性的,为了保证测试需求的清晰性,测试需求建模语言Page4(6)可行性.每一项测试需求在已有的条件下必须具备尽可能严格的语法和语义定义.(5)一致性.测试需求中各部分内容的描述是一致的,不存在相互矛盾的地方,在建模元素之间的关联关系和约束关系要进行明确的定义.都是可以测试、可以实施的.2.2测试需求模型随着软件系统的复杂程度越来越高,如何有效地对软件系统进行测试成为了重点关注的问题.模型驱动测试[8]是一种新颖而具有发展前景的自动化测试方法,它为测试人员提供了简便有效的方式,从而来实现高效自动化的测试.这种新的方法及其工具集不仅能够提高测试人员的工作效率,并且能够减少产品投入市场的时间.测试需求模型需要能够对测试需求进行可视化、无二义性的描述,因此该模型需要描述哪些方面是需要被测试的:模型需要具备严格的语法和语义,将测试需求和被测系统的功能以及性能需求对应;该模型还需要是能够保证测试是完整的,这样可以通过模型检查的技术,来保证模型各部分具有一致性;测试需求模型能够指导测试的设计与测试用例图2测试需求元模型测试需求元模型主要分为4个部分:测试特征元模型(图2中的TestCharacteristicDiagram)、基于被测系统用例的测试需求描述元模型(图2中的UseCaseDiagram)、基于被测系统构件的测试需求描述元模型(图2中的SUTArchitecture)以及测试目标分组及描述元模型(图2中TestPurpose-GroupDiagram).它们分别从不同的方面对测试需求进行描述.这4个部分相对独立但又相互关联,对于完整的测试需求模型而言缺一不可.的生成,这样使得测试需求具有可行性;测试需求模型还能建立起被测系统需求到测试设计的可追溯的关系.在接下来,将用测试需求的元模型对测试需求模型进行详细的描述.2.2.1测试需求元模型随着UML与MDA的兴起和流行,模型已经成为软件开发的核心制品,而模型重要性的提升使得建模语言以及定义建模语言的元模型逐渐成为软件开发中的一个核心要素.软件开发往往涉及多个领域,而不同的领域往往需要不同的建模语言及建模工具.但是,手工地为不同的建模语言开发建模工具代价高昂.元建模技术[13]是解决这个问题的方法之一,通过元建模,可以根据领域需要定制合适的元模型以定义领域建模语言,进而自动生成支持该建模语言的建模工具.大量的工程实践表明,与领域建模以及MDA相结合,元建模可以大幅度地提高软件开发效率.测试需求元模型作为测试需求建模的基础,定义了测试需求模型中的各种核心概念以及核心概念之间的关系与依赖.本文提出的测试需求模型的元模型如图2所示.2.2.2测试特征元模型测试特征的概念参考了OMG对服务质量特征的定义.测试特征①(图3中的TestCharacteristic)是一组可定量表达的特性,独立于其所度量的具体元素.测试特征可以是对测试过程中被测系统行为特征的描述,如响应时间等,也可以用于描述测试系统自身的特征,如测试系统需模拟并发用户的数目以及测试数据选择策略等.测试需求建模语言的设计使得建模人员可以将测试特征针对领域进行扩Page5展,使得测试特征的核心内容不至于过于庞大,同时也可满足不同领域测试人员的需要.测试特征的维度(图3中的Dimension)是对测试特征描述进行量化表达的视角与方法.如当测试特征为某一系统函数的响应时间时,测试人员选择的度量方式可以是函数一次执行的延迟、所有执行的平均延迟或是延迟时间的方差.测试特征可能需图3测试特征元模型2.2.3测试目标分组及描述元模型测试目标的规格说明需要具有一定的逻辑结构[7].在本文中采用分组的方式对测试目标进行组织.如可以通过区分测试目标(图4中的TestPurpose)为功能性测试还是非功能性测试、测试目标涉及哪个功能模块等方式将测试目标进行分组.对测试分组(图4中的TestGroup)的划分可以有不同的粒度,每个分组可以有自己的子分组,直至具体到相应的测试目标.对于每一个测试目标,都需要对其进行相应的描述.测试目标是从执行某一特定的测试场景或者路径,或是验证特定需求的特性角度对测试用例的一个精确目标的描述.测试目标比测试用例更加抽象,更加简洁,更加清晰并独立于被测系统的设计与实现.本文对测试目标描述的定义参考了UML顺序图,采用类顺序图的形式来实现对测试目标的描述.在本文中,测试目标实际上是测试人员所关注的测试系统与被测系统交互的消息序列,测试需求描要若干不同维度的量化值,如被测系统可靠性这一测试特征,需要修复时间、失效时间等度量方式.单一的量化值无法全面的对测试特征进行描述.因此测试特征维度的引入是十分必要的.另外一个与测试特征密切相关的概念是测试约束.测试约束在测试目标分组与描述模型中用于对相应的测试目标进行约束.述中的发送消息(图4中的SendMessage)与接收消息(图4中的ReceiveMessage)表示测试人员在本测试目标中所关注的消息序列,希望测试用例可以对其进行覆盖.而拒绝消息(图4中的RefuseRe-ceiveMessage)表示测试人员所不关心的消息,即不希望测试用例执行时测试系统会与被测系统就此消息进行交互.同时,在测试需求描述中可以引入测试约束模型元素用于对测试目标进行约束.测试约束对与之相关联的测试特征(图3中的TestCharacteristic)的取值进行了约束.测试约束有两种类型(图4中的ConstraintConnectionType),其中OFFERED类型为测试系统自身需要满足的约束,测试系统需满足此约束条件才能正确完成测试工作,如测试系统模拟的并发用户数目必须达到某一值,或测试系统提供的数据必须约束在某一特定区间之内.而REQUIRED类型的测试约束为被测系统的行为需满足的约束,如被测系统响应时间需小于某一确定值.Page6图4测试目标分组及描述元模型2.2.4基于被测系统构件的测试需求描述元模型基于被测系统构件的测试需求描述模型通过对被测系统相应的构件图进行标注,来描述测试需求中的被测软件实体EUT与测试端口.对测试人员关注的构件(图5中Component)进行标注(图5中TestObjectEUT)表示此构件为被测软件实体,在后续的测试过程中需要对其进行相应测试;定义测试系统的端口(图5中TestObjectPort)用于标注相应图5基于被测系统构件的测试需求描述元模型的被测系统接口(图5中Interface),并定义允许的输入消息类型与输出消息类型.2.2.5基于被测系统用例的测试需求描述元模型用例图是一种基于场景的可视化表示方法,用来描述和论证系统大粒度的行为模式及其连接方式,它为高级的体系结构设计提供了系统行为框架并从体系结构的角度给系统行为赋予了一定的特征,测试人员利用它可以从较高的抽象层次来理解Page7系统的行为.从用户的观点出发对系统建立模型是用例要完成的任务,一组用例就是从用户的角度出发对如何使用系统的描述.因此用例为测试提供了良好的基础.基于被测系统用例的测试需求描述模型以被测系统的用例图为基础,如图6所示.根据测试目标分组及描述模型中定义的测试目标对相应的用例(图6中的UseCase)进行标注(图6中的TestPur-poseForUseCase),向测试人员指明对此用例的测试对应于哪一测试目标.通过测试目标生成相应的测试用例集之后,测试人员便可使用此测试用例集对用例进行相应测试.图6基于被测系统用例的测试需求描述元模型表1基于用例的测试需求描述元模型的约束与测试特征元模型的约束约束1:对用例进行标注的测试目标必须在测试目标分组及描述模型中已定义约束2:用例参与者需与相应用例相关联约束3:用例不能重名约束4:测试目标标注必须对相应用例进行标注约束5:测试特征不能重名contextTestCharacteristics2.4模型验证虽然模型的语法符合要求,但可能会因为测试2.3元模型OCL约束对测试需求元模型进行定义之后,还需要使用OCL[14-15]对测试需求元模型进行相应约束,以保证测试人员建立的测试需求模型在语义上的正确性.对测试需求元模型的约束按模型元素所在的不同组成部分进行了分类,以基于用例的测试需求描述元模型与测试特征元模型的OCL约束为例.该约束如表1所示.表1为基于用例的测试需求描述元模型与测试特征元模型的OCL约束,主要包括对用例的测试需求标注的相应约束(约束1)以及对用例及参与者的相应约束(约束2、3).人员的疏忽或测试需求分析本身的错误,导致模型在语义上存在错误.例如用于标注某个用例的测试Page8目标未在测试目标分组与描述模型中定义,或是不同的测试目标拥有相同的ID等.如果存在这些错误,测试人员很难人工的去对测试需求模型元素进行逐个检查,这样不仅时间代价过大,效果也极不理想.因此,测试需求模型语义检查的自动化是十分必要的.通过设置测试需求模型的语义约束规则.当使用OCL进行约束时,以元模型中的元类为上下文(context)的每个不变式(invariant)在这个元类的实例的整个生命周期中必须为真,这些不变式是模型中模型元素必须满足的约束.OCL语言给出了对测试需求元模型的无二义性的约束,其每一约束都对应于对测试需求模型的一条约束规则.通过这样约束的规则,可以对模型进行验证.2.5测试需求描述脚本测试需求描述脚本以简练的形式描述并保存了对测试需求的描述,测试需求建模方法可通过测试需求模型自动生成测试需求描述脚本.在需要的情况下,测试人员可基于被测系统模型通过测试需求描述脚本还原测试需求模型.为了规范生成测试需求描述脚本,定义了一种测试需求描述语言,用于测试人员编写测试需求描述脚本,作为对测试需求的文本描述形式.相较于测试需求模型,测试需求描述脚本剥离了被测系统模型中与测试需求无关的部分,如被测系统各个不需要被测试的构件与接口的关系、各用例与参与者之间的关系等.测试需求描述脚本以简练的形式描述并保存了对测试需求的描述,测试需求建模平台可通过测试需求模型自动生成测试需求描述脚本.在需要的情况下,测试人员可基于被测系统模型通过测试需求描述脚本还原测试需求模型.3基于测试需求模型的测试用例生成测试需求模型对测试需求进行了直观且无二义性的描述,作为整个测试活动的基础,能对后续测试过程进行有效的指导.通过测试需求模型与被测系统模型生成测试用例,所生成的测试用例对应于测试需求模型中相应的测试目标,通过此测试目标可进一步追溯到作为测试目标设计依据的被测系统需求,从而实现了从系统需求到测试用例的向下追踪与从测试用例向系统需求的向上回溯.3.1输入输出的标记迁移系统测试用例通过被测系统模型与测试需求模型中的测试目标描述模型生成.首先需将被测系统的状态图模型(在经过需求分析阶段,经过多次的与用户沟通,可以借助相关的建模工具得到).转换为标记迁移系统.标记迁移系统是一种在计算机辅助设计和验证中得到广泛使用的形式模型,其结点代表系统的状态或配置,边代表在行为发生时状态或配置之间的转移.本文对标记迁移系统进行适当的扩展,以区分输入行为与输出行为,称其为输入输出标记迁移系统.它是一个四元组,定义如下:其中,QM是状态的有穷非空集合,qM0QM是初始状态.AM是行为字母表,它被划分为两个子:AM=AMI∪AMO.其中AMI是输入字母表,AMO是输出字母表.→MQM×AM×QM为状态转移函数.为方便描述,以字符?开头的行为表示输入行为,以字符!开头的行为表示输出行为,如?a表示输入行为a,即aAMO;!b表示输出行为b,即bAMO.3.2测试用例生成为了得到测试用例,需要将被测系统的状态图模型转换为标记迁移系统S(Specification):S=(QS,AS,→S,qS0).其行为字母表AS=ASI∪ASO,ASI与ASO分别为被测系统的输入与输出.根据测试系统的状态图,利用标记迁移系统S生成算法,可以得到对应的标记迁移系统,在标记迁移系统S生成算法中,首先通过ConstructFrom(SpecificationNodenode)方法以被测系统状态图模型的开始状态为起点对状态图模型进行遍历,将其结构信息保存在标记迁移系统中,然后将标记迁移系统中同时拥有输入输出消息的转移进行分裂,并插入新建立的中间状态节点.生成算法如下所示.于输入消息与输出消息,设置算法1.标记迁移系统S生成.输入:被测系统状态图Statechart输出:元素类型为SpecificationNode的顺序容器SListBEGIN得到Statechart的BeginState状态;构造BeginState的相应SpecificationNode对象调用方法ConstructFrom(BeginSN);FORSList中的每个元素的每个转移信息(Specifi-IF转移信息对应的Statechart中的Transition同THEN将此转移信息分裂为两条转移,分别对应cationNodeAndEdge对象)时拥有输入与输出消息BeginSN并添加到容器SList;Page9创建新的SpecificationNode它们的message属性与messageType属性,并作为这两个转移的中间节点;ELSE设置相应message属性与messageType属性;ENDIFENDFOREND例如:图7显示了某被测系统的状态图与标记迁移系统S.测试需求模型中的测试目标描述模型同样需要转化为相应的标记迁移系统TP(TestPurpose),以作为测试选择的指导规则,标记迁移系统TP的定义如下:其拥有两种结束状态:AcceptTPQTP,RefuseTPQTP.它的行为字母表与标记迁移系统S的行为字母表相同,即ATP=AS.AcceptTP表示状态被测试目标所接受,如果达到此状态,则测试判定成功,测试通过;RefuseTP表示状态在此测试目标下不被关注,测试判定未定义.例如:图8左侧为图7所示的测试需求模型中的测试需求描述模型视图.在测试需求描述中,由被测系统向测试系统反馈的消息若使用虚线图符,表示此测试目标拒绝此消息,即此测试目标不关注到达此消息的消息序列.图8中右边的图形为左侧模型生成的测试目标TP,需要强调的是,在测试目标中定义的消息序列仅仅限定了它们的先后次序,并不要求它们是连续的,在系统的实际行为中它们之间可存在其它消息或消息序列,由此也体现了测试目标的抽象性.从图8中可以看出,当测试需求描述中的测试系统向被测系统发送输入消息,如果得到的输出是消息H,测试目标则会拒绝此消息.如果在一定的时限之内没有收到消息为H的输出,测试系统将会向被测系统发送输入0,如果在之后收到被测系统的输出消息为P,测试目标则会接受此消息.在分别生成标记迁移系统S与标记迁移系统TP后,需要将它们进行同步为新的标记迁移系统,以得到标记迁移系统S中被标记迁移系统TP所接受的行为以及被标记迁移系统TP所拒绝的行为.标记迁移系统S与测试目标的TP的同步S×TP是一个输入输出标记迁移系统SP=(QSP,ASP,→SP,qSP0),SP有两个不相交的状态集合:AcceptSPQSP,RefuseSPQSP.标记迁移系统SP标识出了标记迁移系统S中被标记迁移系统TP接受的行为(如果被测系统行为这些行为序列一致,则测试通过)与被标记迁移系统TP拒绝的行为(表示测试目标不关心被测系统的这些行为).接下来需要通过选择标记迁移系统SP中被测试目标接受的行为来得到相应的测试用例.一个测试目标可能对应很多个测试用例,首先通过标记迁移系统SP生成包含对应测试目标所有测试用例信息的标记迁移系统ATC(AllTestCases),ATC=(QATC,AATC,→ATC,qATC0),ATC拥有两个结束状态:PassQATC,FailQATC,它们分别代表对测试的不同判定.由图7的标记迁移系统S与图8的标记迁移系统TP,可以得到标记迁移系统SP和ATC,如图9Page10所示.图9左侧的标记迁移系统SP由图7中的标记图9标记迁移系统SP与ATC算法2.标记迁移系统SP生成.输入:标记迁移系统S,标记迁移系统TP输出:元素类型为SPNode的顺序容器SPListBEGIN由标记迁移系统S与标记迁移系统TP的初始节点创建SPNode类型的对象init;为SPList添加对象init,置init的相应tag值为0,表示未被处理;FORSPList中每个tag为0的元素element通过element的S_id得到标记迁移系统S中相应状态节点Snode;相应状态节点TPnode;通过element的TP_id得到标记迁移系统TP中FORSnode的每个后继转移Sne创建SPNode类型的对象child;IFTPnode有后继转移TPne,且其消息与Sne上的消息相同THEN由TPne对应的后继状态的id与Sne对应的后继状态的id初始化SPNode类型的对象child;ELSE由TPne对应的后继状态的id与element的ENDIF在element的children容器中中加入SPNode对迁移系统S与图8中的标记迁移系统TP生成.下面给出标记迁移系统SP的生成算法.置child的verdict值与TP中相应状态节点IFSPList中没有childTHEN将child加入SPList;置child相应tag为1;ENDIFENDFORENDFOR从SPList中的Accept状态节点开始,对标记迁移系END最后,通过ATC生成相应的测试用例集.首先生成标记迁移系统形式的测试用例TC:TC=(QTC,ATC,→TC,qTC0).其拥有两种结束状态:PassQTC,FailQTC,它们分别代表对测试结果的不同判定.行为字母表ATC=ATC试用例的输出必须为被测系统的允许输入;ATCO,即测试用例的输入只能为被测系统的输出.AS图10展示了通过图9中的ATC所生成的测试用例集.以初始节点为起点,搜索可到达Pass状态节点的所有路径,其中每一路径与路径中状态节点到节点的转移为一个测试用例,由此得到此测试目标对应的测试用例集.Page114实验分析4.1实验方案设计目前人们使用的网络主要有两种,一种是语音网络,一种是数据网络.语音网(例如PSTN)使用电路交换,质量和流量控制等被嵌入网络中.PSTN网可以保证语音质量,但不能有效地使用网络资源,同时也很难扩展新的业务.数据网(例如Internet)使用分组交换,质量和流量控制等则在终端系统中实现,因而更加灵活,更加容易扩展,也更容易实现新的业务.近年来由于数据网的快速发展,出现了IP电话.IP电话有两套独立的协议,H.323以及SIP.H.323协议是由ITU提出的,同时也是实现最多的协议,被众多产品支持.SIP协议是由IETF提出的,提出时间相对晚一些,然而由于它具有很好的可扩展性,互操作性,协议本身也更简单一些,SIP正变得更加流行.个简单流程,这个流程如下.含有会话请求的INVITE消息;实验选取了SIP协议建立会话并进行释放的一1.用户代理A通过代理服务器向用户代理B发送包2.用户代理B根据INVITE消息中携带的会话描述符信息,通过代理服务器向用户代理A回送一个“180振铃”作为应答;3.若用户代理B的用户接受呼叫,则用户代理B返回一个“200OK”应答;4.用户代理A收到“200OK”应答后发出一个ACK请求,完成一个三次握手过程,会话开始;5.当用户代理A的用户希望结束会话时,通过用户代理A直接向用户代理B发送一个请求;BYE请求返回一个“200OK”应答.6.用户代理B收到BYE请求后结束会话,并为这个通过SIP的这个工作流程,进行如下实验:1.建立被测系统的测试需求模型;2.在测试需求模型中人为插入语义故障,模型验证对模型进行自动语义验证并报告相应错误;3.通过测试需求模型生成相应测试需求描述脚本;4.生成相应测试目标描述对应的测试用例.4.2实验结果以及分析本文基于Eclipse3.5、GMF2.2版本开发了测试需求模型可视化系统.型编辑器包括菜单视图、导航视图、属性视图、编辑器视图和工具栏.基于GMF开发的模型编辑器的编辑器视图中的图形显示对应两个xml格式文件,提供了对模型元素语义和模型元素图形化表示的存储功能.1.测试需求建模实验根据SIP协议标准[16]建立相应的测试需求模型.测试特征分为通用测试特征(generalchar-acteristics)与测试人员为对SIP测试所特化的测试特征(SIPspecifiedcharacteristics).通用测试特征Sequence的维度consecutive用于表示在测试目标中定义的消息序列是否需要在其相应的测试用例中连续出现;通用测试特征Load的维度concurrency用于表示测试中的并发数;通用测试特征Response-Time的维度duration表示相应的时间间隔,而测试特征SIP_ResponseTime特化了ResponseTime,表示测试中相应的时间间隔(维度duration)以毫秒(ms)为单位.根据上面的流程,可以得到测试特征模型视图.如图11所示.利用测试需求模型可视化系统,建立测试目标分组及描述模型视图.此视图以树形结构展示测试目标分组.与根节点相关联的矩形内为对相应测试分组的描述.对于测试分组节点与测试目标节点可进行相应的测试约束标注,如图中的测试约束上下文为Load,表示此测试约束对应的测试特征的名字;测试约束项限定了对应测试特征维度的取值,要Page12求测试系统的并发数在190与200之间,由于是对测试系统的约束,因此约束类型为OFFERED.测试图12测试目标分组及描述模型视图图13为测试目标节点TP-2对应的测试目标描述模型视图,用于描述在此测试目标中所关注的测试消息序列,作为指导测试人员设计测试用例或是自动生成测试用例的基础.此测试目标主要关注SIP协议中通话结束后的释放过程:期望测试系统模拟远端用户代理通过SIP端口向被测系统(本地用户代理)发送消息BYE,若被测系统通过SIP端口返回消息200_for_BYE则测试通过,在这两条消息中可以存在其他的消息序列,并不要求它们是连续的.在图13中对发送消息BYE与返回消息200_for_BYE进行了相应的测试约束标注,测试约束对应于测试特征模型中的测试特征SIP_Response-Time,约束项对测试特征的维度duration的取值进行了约束,表示这两条消息之间的时间间隔需小于500ms,这是对被测系统响应时间的要求,因此测试约束类型为REQUIRED.基于用例的测试需求描述模型如图14所示.参与者分别为客户代理(UserAgent)与代理服务器目标分组树以测试目标节点为叶节点.测试目标节点TP-2所显示的测试目标描述模型如图12所示.(SIPProxyServer).用例图中只对3个用例进行了建模,其中用例CallAsCaller表示本地用户代理通过代理服务器向远端用户代理发起对话,与其关联的矩形为测试需求标注,表示此用例对应的测试目标为TP-1;用例RemoteHangUp表示远端用户代理主动结束对话,对应测试目标为TP-2;用例User-HangUp表示发起对话的本地用户代理结束对话,对应测试目标为TP-3.对SIP协议建立的测试需求模型中基于被测系统构件的测试需求描述模型视图如图15所示.构造型为〈〈Component〉〉的矩形为被测系统构件,构造型为〈〈interface〉〉的矩形为被测系统接口.对被测系统构件的标注表示此构件为被测软件实体EUT,下图表示仅需对Main_Control构件(对应于客户代理)与SIP_Protocol构件(对应于SIP协议的具体Page13实现)进行测试,而并不关注SIP协议所处理的具体多媒体会话及相应的实时传输协议(RTP),因此Media_Manager构件与RTP_Protocol构件未被标注.对被测系统接口的标注表示测试系统通过相应的端口与此接口通信,并定义了端口允许通过的消息类型.下图中GUI接口允许的输入消息类型为用户操作UserOp类型,允许的输出类型为显示消息PromptMsg类型;SIP接口允许的输入、输出消息类型均为SIP消息类型SipMsg.图15基于被测系统构件的测试需求描述模型视图2.在测试需求模型中人为插入语义故障,模型验证对模型进行自动语义验证并报告相应错误.测试需求模型中人为插入若干有代表性的语义故障以检测测试验证能否自动识别.为此,对所建立的测试需求模型元素进行了如下更改以插入故障:(1)删除测试目标分组及描述模型中的TP-3测试目标节点;使测试需求模型不满足测试目标分组与描述元模型的约束集合中的约束1以及表1中的约束1;(2)将基于被测系统构件的测试需求描述模型中的TP-2测试目标节点的测试目标描述模型中SIP_ResponseTime约束的duration维度的Dimen-sionName属性更改为“delaying”;使测试需求模型不满足描述元模型的约束集合中约束8;(3)将测试特征模型中测试特征Load的name属性更改为“Sequence”,与测试特征Sequence的name属性相同;使测试需求模型不满足描述元模型的约束集合中的约束7与表1中的约束5;(4)删除基于被测系统构件的测试需求描述模型中的Main_Control组件的测试需求标注;使测试需求模型不满足基于用例的测试需求描述元模型的约束与测试特征元模型的约束集合中的约束6;(5)删除基于被测系统构件的测试需求描述模型中的GUI接口的测试需求标注中的PortOut;使测试需求模型不满足基于用例的测试需求描述元模型的约束与测试特征元模型的约束集合中的约束1;(6)更改基于被测系统构件的测试需求描述模型中的SIP接口name属性为“NetPort”;使测试需求模型不满足测试目标分组与描述元模型的约束集合中的约束6;插入上述典型的语义故障之后,在测试需求模型可视化系统对测试需求模型进行自动验证,显示的错误信息图16所示的.其中error1由上面的更改3引起;error2由更改5引起;error3与error8由更改4引起;error4与error5由更改6引起;error6由更改2引起;error7与error9由更改1引起.脚本.3.通过测试需求模型生成相应测试需求描述4.生成相应测试目标描述对应的测试用例.选取建立的测试需求模型内的测试目标TP-2来生成其相应的测试用例集.图17为通过测试需求模型可视化系统建立的SIP状态图模型,表示客户代理的状态转移过程,作为生成测试用例所需的被测系统模型.图中除了会话建立与释放的过程,还包括取消(CANCEL)会话的过程,如状态图中的转移T7、T12、T13以及T14.被测系统状态图模型中转移的描述对应着相应转移的触发消息以及在转移过程中被测系统的反馈消息.如图17所示,SIP从“Init”状态到“Calling”状态的转移所对应的描述为“T1GUI:invite/SIP:INVITE”,其中“T1”表示此转移对应的序号为1;“GUI:invite”为此转移的触发消息,冒号前的GUI表示被测系统接收消息的接口,冒号之后的invite表示触发消息的具体内容;斜杠“/”之后的内容为被测系统在此转移过程中的反馈消息,冒号前的SIP表示被测系统反馈消息的接口,冒号后的INVITE为客户代理发送消息的具体内容.当本地客户代理向目标地址发送INVITE请求之后,由Init状态进入Calling状态,这时若对端Page14直接返回200_for_INVITE(SIP应答,状态码200,表示成功),则客户代理进入Ready状态会话开始;若对端返回183_for_INVITE(SIP应答,状态码183,表示振铃),则客户代理进入Ringing状态并等待对端的同意消息,直至收到200_for_INVITE,则进入Ready状态开始会话.如果希望会话结束,会出现两种情况:一种是本地客户代理请求结束会话,另一种是对端客户代理请求结束会话.而测试目标TP-2所关注的是对端客户代理请求结束对话的情况.在测试需求模型可视化系统上TP-2对应的测试目标描述模型界面,并选择图17中的状态图作为被测系统模型,进行此测试目标对应的测试用例集的自动生成.通过测试目标TP-2生成的测试用例集可以在测试需求模型可视化系统上直接展示,如图18所示.测试目标TP-2关注远端客户代理请求释放对话的过程.此测试目标生成了两个测试用例(见附录3):TestCase1对应于图16中SIP状态图的状态转移序列BeginState→T0Init→T1Calling→T5Ready→T11EndState;TestCase2对应于SIP状态图的状态转移序列BeginState→T0Init→T1Calling→T3Ringing→T6Ready→T11EndState.这两个测试用例均用于测试TP-2所关注的会话释放过程.而测试目标TP-2的设计基于被测系统的需求规格说明中的相应需求,从而实现了从系统需求到测试用例的向下追踪与从测试用例向系统需求的向上回溯,当测试活动中某一测试用例判定不通过时,可明确的向测试人员指出系统实现与规格说明中不一致的具体需求.生成测试用例过程的中间形式,包括测试目标描述模型生成的标记迁移系统TP、被测系统模型生成的标记迁移系统S以及标记迁移系统SP、ATC以及存储测试用例信息的标记迁移系统TC,它们的具体信息在生成之后被打印出来,通过这些信息可以完全还原相应的标记迁移系统.5相关工作讨论5.1模型驱动测试模型驱动架构(MDA)是OMG提出的方法学,MDA强调整个系统开发过程由对软件系统的建模行为驱动,完成系统需求分析、架构设计、构建、测试、部署运行和维护工作.模型驱动架构不仅可以应用到平台相关系统、平台独立系统和系统代码生成这些抽象层次的系统建模,而且也可以用到测试建模.MDA基于UML以及其它工业标准,支持软件设计和模型的可视化、存储和交换[17,21].和传统UML模型相比,MDA能够创建出机器可读和高度抽象的模型,这种模型通过转换(Transformation)技术可自动转换为代码、脚本、数据库定义以及各种平台部署描述,使建模语言不仅仅用作分析设计语言,更可用作为一种高级编程语言.模型驱动测试是一种新颖而具有发展前景的自动化测试方法,它为测试人员提供了简便有效的方Page15式,从而来实现高效自动化的测试.这种新的方法及其工具集不仅能够提高测试人员的工作效率,并且能够减少产品投入市场的时间[27-28].Dai等人[18-19]提出了一种模型驱动的测试方法.该方法以U2TP①测试建模语言为基础,提出了一个模型驱动的测试过程(如图19所示).其中,包括多种模型之间的转化,涉及平台无关系统设计模型(PIM)、平台相关系统设计模型(PSM)、平台无关测试设计模型(PIT)、平台相关测试设计模型(PST)、系统代码、测试代码等.Baker等人[20]在传统的V模型[22]的基础上提出模型驱动测试模型.在该模型中,单元测试、集成测试、系统测试等各个测试阶段都有一个对应的建模活动,所建立的模型可转换为TTCN-3或JUnit代码,进而得以自动化执行.在平台独立测试设计模型向测试代码转换的过程的研究中[23],主要是在参考U2TP标准定义测试系统元模型以用于对测试系统进行建模[16,24-25],Bi等人[25]并基于eclipse上的GMF(GraphicalModelingFramework,图形建模框架)框架构造了可视化的测试系统建模工具,然后以测试系统元模型与TTCN-3元模型的映射关系为基础,实现了测试系统模型向TTCN-3代码的转换.本文的工作是在Bi等人[25]的基础上来进行的,和之前的工作一样,本文的工作也参考了U2TP规范定义.5.2基于模型的测试基于模型的软件测试属于基于规范的软件测试范畴,其特点是:在产生测试例和进行测试结果评价时,都是根据被测系统的模型及其派生模型进行的.基于模型的测试最初应用于硬件测试,广泛应用于电信交换系统测试,目前在软件测试中得到了一定应用,并在学术界和工业界得到了越来越多的重视.基于模型的测试实践为模型驱动的软件测试方法奠定了基础.基于模型的软件测试可以根据软件行为模型和结构模型生成测试用例[26-27],当前软件规模庞大也使基于程序的测试十分困难,而基于模型的软件测试方法不仅可以有效地提高测试效率,提高测试例生成的自动化程度,也有利于评价测试结果.在基于模型的测试中,采用某种覆盖准则来指导测试用例的生成,并决定何时来终止测试.覆盖准则是指测试需要满足或覆盖软件的哪些具体元素.对于基于模型的测试目前从设计模型到测试模型自动转换的研究成果不多,更多的研究集中在通过设计模型直接生成测试用例或测试代码.其优势在于快速生成测试代码;不足之处在于缺少对测试的描述,很难复用、演化以及根据用户需求定制测试代码.5.3基于测试系统模型的TTCN-3代码生成本文的工作是在Bi等人[25]的基础上来进行的,和之前的工作一样,本文的工作也参考了U2TP规范定义.Bi等人在参考U2TP标准定义测试系统元模型,提出了测试系统元模型,以作为对测试系统进行建模的基础.然后基于测试系统元模型采用eclipse平台上的GMF框架构建了可视化的测试系统模型编辑器.为实现测试系统模型向TTCN-3代码的转换,并且参考了TTCN-3元模型[28],定义出测试系统元模型向TTCN-3元模型的映射关系.Bi等人的研究主要是关注测试模型向测试代码的转换.我们提出的是基于被测系统模型来指导生成测试需求模型,将测试需求和被测系统的功能以及性能需求对应,这样以指导测试人员开展后续测试活动、方便测试人员与设计人员之间的沟通,还可在模型驱动测试的过程中对测试系统模型的生成提供必要信息,具有重要指导意义.6总结与展望本文参考模型驱动测试的思想,定义了一种用于描述测试需求的可视化建模语言,用以对测试需求进行直观且无二义性的描述,作为测试活动的基础,对指导后续测试活动的开展具有重要意义.同时①www.omg.org/technology/documents/modeling_spec_cat-Page16本文开发了相应的测试需求建模可视化系统,使得测试人员可对测试需求进行建模、分析与验证;并通过被测系统模型与测试需求模型中相应测试目标生成测试用例,展现了测试需求模型以及测试需求建模方法在模型驱动测试方法学中的意义.本文对测试需求的概念以及测试需求模型描述的内容进行了分析,并为系统设计模型向测试系统模型的转换提供信息.本文考虑到通用性,对于各个不同特定领域的测试需求描述可能不够完整,仍有自己的局限性.另外,本文对测试需求的研究工作还没有在工业化的软件系统的开发过程中得到应用与实践,因此未来也需要在这个方向进行努力.致谢北京航空航天大学软件工程研究所模型驱动测试小组成员之前所做了大量工作,特别是已经毕业了的陈辛夷等同学付出了许多劳动,在此表示感谢.最后要感谢百忙之中评阅论文的各位专家!
