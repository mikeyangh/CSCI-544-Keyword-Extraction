Page1基于偏序规律的μ-演算一阶谓词界程逻辑模型检测江华(闽南师范大学粒计算重点实验室福建漳州363000)(韶关学院信息科学与工程学院广东韶关512005)摘要基于μ-演算的一阶谓词界程逻辑,用谓词变量构造不动点公式,方便描述闭环系统的性质,公式语义简洁.该逻辑在有限控制移动界程上的模型检测目前性能最好的算法的时间复杂度与公式中不动点算子交错嵌套深度d呈指数关系,空间复杂度与d呈线性关系.文中设计了一个基于μ-演算的一阶谓词界程逻辑在有限控制移动界程上的模型检测高效算法,这也是目前已知的第3个同类算法,算法的时间复杂度与d/2+1呈指数关系,空间复杂度与d呈线性关系.文中所做的工作有:(1)找到了基于μ-演算的一阶谓词界程逻辑模型检测计算过程中的中间结果满足的两组偏序关系;(2)利用找到的偏序关系设计了一个快速模型检测算法;(3)分析了算法的复杂度.关键词模型检测;移动界程;μ-演算;嵌套谓词等式系1引言Cardelli等人于2000年提出,用于分布式移动计算系统的形式化建模与验证,空间描述能力强.2000年Cardelli等人[2]首次提出界程逻辑,具备同时表达进程在时间和空间上演变的能力.2001年Cardelli移动界程演算(MobileAmbients)[1]最先由Page2等人[3]将受囿名量词和新名量词引入界程逻辑;Cardelli等人[4]和Zilio①分别在一些界程逻辑片断中引入不动点算子,但是这些逻辑片断没有受囿名量词.中国科学院林惠民院士[5-6]于2004至2005年提出了基于μ-演算的一阶谓词界程逻辑,引入新名字量词和不动点算子,用谓词变量构造不动点公式,简化了公式语义.在移动界程模型检测方面,Cardelli等人[2]和Charatonik等人[7]研究了几种有穷界程和有限界程的模型检测问题,Charatonik等人[8]对上述模型检测算法的复杂度进行了分析,2002年Charatonik等人[9]提出了有限控制移动界程(Finite-controlMobileAmbients,FMA),并提出了针对FMA的模型检测算法,但上述这些研究工作采用的逻辑都没有递归,是有穷的.林惠民院士[5]于2004年提出了第一个针对有限控制移动界程上基于μ-演算的一阶谓词界程逻辑模型检测算法,指出算法是可判断的;江华和李祥[10]于2009年研究了有限控制移动界程上基于μ-演算的一阶谓词界程逻辑模型检测问题,设计了一个局部模型检测算法,算法时间复杂度的指数部分是O(d),d是界程逻辑公式中不动点算子交错嵌套深度,这是自林惠民院士的研究工作之后的又一个基于μ-演算的一阶谓词界程逻辑模型检测算法.μ-演算模型检测技术[11-14]自提出以后,在有限控制并发系统的设计与验证中得到了广泛应用.设n为变迁系统状态规模,k为μ-演算公式中不动点算子嵌套深度,d为μ-演算公式中不动点算子交错嵌套深度.根据Tarski不动点定理[15],在完全μ-演算全局模型检测计算时,可以用逐次迭代来计算包含不动点算子嵌套的μ-演算公式,μ-演算全局模型检测算法的时间复杂度为O(nk+1).1986年Emerson和Lei[16]证明了μ-演算公式中相同类型的不动点算子嵌套时可以不改变模型检测算法的复杂度,据此设计的μ-演算全局模型检测算法的时间复杂度为O(nd+1).随后Andersen[17]、Cleaveland和Steffen等人[18-19]对文献[16]的算法进行了一些改进,但算法的时间复杂度不变.1994年Long等人[20]对用Tarski不动点定理计算μ-演算公式的计算过程进行了细致的分析,找到了计算过程中的中间结果间存在的一组偏序关系,据此设计了一个时间复杂度和空间复杂度同为O(nd/2+1)的μ-演算全局模型检测算法.2010年江华[21]对d=4的μ-演算全局模型检测的计算过程进行了深入分析,找到了其计算过程中的中间结果间存在的两组偏序关系,据此设计的μ-演算全局模型检测算法的时间复杂度与d/2呈指数关系,空间复杂度为O(dn).相关的工作还有:Liu等人[22]于1998年提出了一个高性能的命题μ-演算局部模型检测算法;刘剑和林惠民院士[23]于2003年证明了模态图与谓词μ-演算公式在语义上的一致性.近几年在移动界程演算模型检测方面的研究还有:2011年Fabio和Giacoma[24]提出了一个有限进程移动界程的图形表示方法,实现了对递归语义的图形化建模;Brodo[25]对π-演算和移动界程的描述能力进行了研究,通过提出轨迹模拟和轨迹中止的概念从而针对模型中的闭环提出了一个解决方案.2012年Aman和Ciobanu[26]提出了一个移动界程的改良版本———parMA,给出布尔可满足问题基于parMA的求解方案;Ali等人[27]结合面向服务的体系结构(Service-OrieritedArchitecture,SOA)建模语言和移动界程,提出了界程-SOA模型并开发了相应的建模工具,允许图形化建模移动的SOA模型.2013年Unal等人[28]提出了XFPM-RBAC(XML-basedFormalPolicylanguageforMobilitywithRole-BasedAccessControl),用移动界程和界程逻辑描述角色的移动性和角色的安全规则;Bodei等人[29]结合CCS演算、π-演算和移动界程提出了LINK演算,能很好地对开放的多进程系统进行描述和建模.2014年Aman等人[30]提出了行为时序逻辑移动界程演算,通过实例展示了该演算的描述和验证能力.2015年Siewe[31]提出了基于移动界程的隐私类型系统,确保隐私信息在计算过程中的安全性.本文通过挖掘基于μ-演算的一阶谓词界程逻辑模型检测算法在计算过程中中间结果间存在的偏序关系,设计出高性能的移动界程模型检测算法,大大降低了基于μ-演算的一阶谓词界程逻辑模型检测算法的复杂度,使之更接近实际应用的需要.本文的研究方法与文献[21]所用的研究方法类似,均是挖掘按照Tarski不动点定理计算不动点时中间结果间存在的偏序关系来优化算法设计,且本文算法与文献[21]中算法具有相同的时间复杂度和空间复杂度.但是本文与文献[21]有两点重要的区别:①ZilioSD.Fixedpointsintheambientlogic[C/OL].ProceedingsPage3(1)两者研究的对象不同,本文研究的是基于μ-演算的一阶谓词界程逻辑模型检测算法,文献[21]研究的是命题μ-演算模型检测算法;(2)算法类型不同,本文算法属于局部模型检测算法,文献[21]中算法属于全局模型检测算法.2移动界程演算令是名字可数集,n,m,…∈,是进程变量可数集,X,Y,…∈,移动界程演算语法的BNF定义如下[1]:M∷=capabilitiesinncanentern|outncanexitn|openncanopenn|εnullpath|M.McompositepathP,Q∷=processes0inactivity|P|Qcomposition|(νn)Pnamerestriction|n[P]ambient|M.Pcapabilityaction|(n).Pinput|〈n〉output|Xvariable|fixX.Precursion进程P中的自由名字、受囿名字、自由变量和受囿变量分别记为fn(P)、bn(P)、fv(P)和bv(P),如果bv(P)=∧fv(P)=,则称P为闭进程,闭进程集合记为,如果两个进程只是受囿名字和受囿变量不同,称这两个进程α-等价,α-等价的进程相互之间语义完全一致,P[m/n]表示用m替换P中的自由名字n.基于模型检测算法的可判断性,本文只考虑有限控制界程[9]的模型检测.下面的结构同余关系(≡)和归约关系(→)构成了移动界程的语义.移动界程的结构同余关系(≡)定义[1]如下:StrReflP≡PStrSymmP≡QQ≡PStrParZeroP|0≡PStrTransP≡Q,Q≡RP≡RStrparCommP|Q≡Q|PStrParAssP|(Q|R)≡(P|Q)|RStrResZero(νn)0≡0StrResPar(νn)(P|Q)≡P|(νn)Qifnfn(P)StrResRes(νn)(νm)P≡(νm)(νn)PStrResAmb(νn)(m[P])≡m[(νn)P]ifn≠mStrFixSelffixX.X≡0StrRecfixX.P≡P[fixX.P/X]移动界程的归约关系(→)定义[1]如下:RedInn[inm.P|Q]|m[R]→m[n[P|Q]|R]RedOutm[n[outm.P|Q]|R]→n[P|Q]|m[R]RedOpenopenn.P|n[Q]→P|QRedI/O(n).P|〈q〉→P[q/n]RedResP→Q(νn)P→(νn)QRedParP→QP|R→Q|RRedAmbP→Qn[P]→n[Q]Red≡P≡P,p→Q,Q≡QP→Q3基于μ-演算的一阶谓词界程逻辑本文采用的界程逻辑是由文献[6]提出的基于μ-演算的一阶谓词界程逻辑(以下简称界程逻辑).记是名字变量可数无穷集,x,y,…∈,∩=,是谓词变量可数无限集,X,Y,…∈.界程逻辑语法的BNF定义如下[6],满足n∈∪:A,B∷=propositions⊥|⊥|0|A∧B|A∨B|A|B|AB|n[A]|A@n|n?A|A○/n|□·A|◇·A|x.A|x.A|x.A|F(n-)F∷=predicatesX|νX.F|μX.F|(x-)A界程逻辑公式有命题和谓词两类.谓词都有确定的目数,命题抽象和谓词应用时,要求目数一致.公式A中的自由名字变量和自由谓词变量分别用fnv(A)和fpv(A)表示.名字计值环境用ρ表示,ρ[u/x]表示将ρ在x处的值修改为u.谓词计值环境用ξ表示,ξ[f/X]表示将ξ在X处的取值置换为f,ξ[ξ]表示将ξ在上的取值置换为ξ的相应取值.界程逻辑公式的语义归纳定义[6]如下:⊥ξρ=⊥ξρ=0ξρ={P|P≡0}A∧Bξρ=Aξρ∩BξρA∨Bξρ=Aξρ∪BξρA|Bξρ={P|P≡Q|RandQ∈Aξρ,R∈Bξρ}ABξρ={P|ifQ∈AξρthenP|Q∈Bξρ}n[A]ξρ={P|P≡ρ(n)[Q]forsomeQ∈Aξρ}A@nξρ={P|ρ(n)[P]∈Aξρ}n?Aξρ={P|P≡(νρ(n))QforsomeQ∈Aξρ}A○/nξρ={P|(νρ(n))P∈Aξρ}Page4□·Aξρ={P|Q,P→QQ∈Aξρ}◇·Aξρ={P|Q,P→Q∧Q∈Aξρ}x.Aξρ=∩nAξρ[n/x]x.Aξρ=∪nAξρ[n/x]x.Aξρ=∪nfn(A){P|P∈Aξρ[n/x]andnfn(P)}F(n-)ξρ=Fξρ(n-)Xξρ=ξ(X)νX.Fξρ={f|fFξ[f/X]ρ}μX.Fξρ={f|fFξ[f/X]ρ}(x-)Aξρ=n-.Aξρ[n-/x-]基于模型检测算法的可判断性,本文只考虑不含并发伴随算子“”、受囿谓词变量闭且名字闭的公式在有限控制界程上的模型检测.4嵌套谓词等式系及模型检测算法[10]嵌套谓词等式系与界程逻辑公式从语义的角度看是等价的,嵌套谓词等式系是界程逻辑公式更一般意义的表示形式[10].4.1嵌套谓词等式系的语法包含不动点类型的谓词等式形如X(x-)=σ,等式中X为谓词变量,x-为互不相同的一列名字变量且fnv()={x-},σ={μ,ν},为命题,中没有不动点算子.嵌套谓词等式系定义为嵌套谓词等式系中ε代表空序列.中等式左边出现的变量为左谓词变量,且互不相同,左谓词变量集合记为lhs(),lhs()即的受囿谓词变量集;各等式右边出现的谓词变量为右谓词变量,右谓词变量集合记为rhs(),rhs()-lhs()为的自由谓词变量集.对于等式系,,若lhs()∩lhs()=,用∷表示将两个等式系连接在一起而得到的新等式系.4.2嵌套谓词等式系的语义{x-},在ξ上的语义(解)ξ定义[10]如下:设是嵌套谓词等式系,ξ是环境,fnv()=若≡ε,ξ=ξ;若≡(X(x-)=ν),ξ={f|f(x-)若≡(X(x-)=μ),ξ={f|f(x-)ξ[f/X]};ξ[f/X]}.4.3界程逻辑公式转换为嵌套谓词等式系界程逻辑公式σX.A中,谓词变量X的不动点类型记为X.σ,如果X∈fpv(A),则称X依赖X,记为〈X,X〉.谓词变量X的交错嵌套深度ad(X)定义如下:ad(X)=1+max{ad(X)|〈X,X〉∧X.σ≠X.σ},其中max{}=0.根据定义,若fpv(A)={X},则ad(X)=1.令:p∈{⊥,⊥,0},∈{∧,∨,|},∈{□·,◇·,x,x,x},∈{n[],@n,n?,○/n},则(B)∈{n[B],B@n,n?B,B○/n}.算法1[10].命题转换为嵌套谓词等式系(详见附录1).4.4模型检测算法及其复杂度算法2[10].有限控制移动界程上的基于μ-演算的一阶谓词界程逻辑局部模型检测算法(详见附录2).op(A)定义如下:op(p)=0,op(A1A2)=1+op(A1)+op(A2),op(A)=1+op(A),op((A))=1+op(A),op(Y(n-))=0,op(((x-)A)(n-))=op(A),op((σX.((x-)A))(n-))=1+op(A).算法2的核心思想是依据Tarski不动点定理,采用目标驱动策略,尽量减少重复计算量,以提高算法性能.算法2中计算结点的数据结构为(P,X(x-,,σ,id),val),其中,P为进程,X(x-)=σ为等式,id为等式所处的交错嵌套深度,val为结点值,当σ=ν,计算初值val=true,当σ=μ,计算初值val=false.算法2运行时,各结点均从初值开始计算,最先计算不动点交错嵌套层次最深(id=d)的结点,当id=d层的所有结点的值到达当前不动点值时,开始计算id=d-1层的结点.id=d-1层只要有结点值发生改变,id=d层的所有结点均需从初值重新计算.当id=d-1层结点值到达当前不动点状态后,计算id=d-2层的结点.id=d-2层只要有结点值发生改变,id=d和id=d-1层的所有结点均需从初值重新计算.整个计算过程中,只要有结点值发生改变,那么比该结点交错嵌套层次深的所有结点均需从初值重新计算,直至最外层(id=1)的所有结点到达不动点,计算停止.公式A中包含的所有算子的数量记为op(A),Page5定义为进程P在运行过程中子界程最大并行度par(P)(1)P≡0:par(P)=0(2)P≡M.P:par(P)=max(1,par(P))(3)P≡a1[P1]|a2[P2]|…|ak[Pk]:par(P)=(4)P→P:par(P)=max(par(P),par(P))记公式A中含算子‘?’的数量为op?(A),含量词‘,’的数量为op,(A),含算子‘|’的数量为op|(A),含算子‘□·,◇·’的数量为op□·,◇·(A),含算子‘∧,∨,|’的数量为op∧,∨,|(A);bn(P)的规模记为|bn(P)|;进程P和公式A中自由名字集规模和名字集规模分别记为|fn(P,A)|和|N(P,A)|;记VLTS(P)为进程P对应的标号转移系统(LTS)的结点规模.若算法2中InstallSet()函数产生的计算结点集规模为Μ,则有[10]Μ=VLTS(P)×[op(A)+op∧,∨,|(A)]×2par(P)×op|(A)×|N(P,)|op,(A)×[1+|bn(P)|]op?(A).从文献[10]可知,如果公式的交错嵌套深度为d,利用算法2进行模型检测的时间复杂度为O(((M+d)/d)d),空间复杂度为O(M).5计算过程规律提取及算法改进若J,K为计算结点集合,且满足(1)|J|=|K|;(2)集合内各结点的val取值唯一,即(P,X(x-,,σ,i),false)和(P,X(x-,,σ,i),true)不可能同时出现在同一集合中.定义1.在J,K上定义算子:若JK,则(P,X(x-,,σ,i),false)∈J(P,X(x-,,σ,i),false)∈K∨(P,X(x-,,σ,i),true)∈K;(P,X(x-,,σ,i),true)∈J(P,X(x-,,σ,i),true)∈K.显然,关系是自反、反对称和传递的,是计算结点集上的一个偏序关系.设交错嵌套深度为4且最内层不动点算子为最大不动点的嵌套谓词等式系:4表示最内层等式块,1,3对应的不动点类型σ1=σ3=μ,2,4对应的不动点类型σ2=σ4=ν,1,2,3,4等式块对应的结点集合记为R1,R2,R3,R4,其中Ri=Ri0∪Ri1∪Ri2(1i4)(Ri0,Ri1,Ri2在算法2中定义和赋值).在界程P上,依据算法2计算R1时,有计算序列R0为初始状态,由算法2中函数InstallSet()赋值,Rω为到达不动点状态.当R1取值为Rj12,Rj11Rj10为当前不动点状态.当R1取值为Rj1计算序列为Rj1j20当R1取值为Rj13时,计算R4的计算序列为Rj1j2j30Rj1j2j34,…,Rj1j2j3ωRj1j2j32依据算法2计算,各层结点的计算顺序为1=f1(Rj1Rj1+12=f2(Rj1Rj1(j2+1)3=f3(Rj1Rj1j2(j3+1)4=f4(Rj11,Rj1j2Rj1j2j3(j4+1)具体fi的定义如定义2.定义2.fi的定义.fi(R1,R2,…,Rd){while(Ri0≠){4,…,R101ω依据算法2对等式系(1)对应结点进行计算,记4,R0002R00013,R012,R0101R00ω3,…,R01ωR0123,R1011R101Rj1j2…ji-1ki=Rj1j2…ji-1k由于σ1=σ3=μ,R0false;σ2=σ4=ν,Rj10true.设等式块1∷2∷3∷4对应结点的计算函数分别为f1,f2,f3,f4,则有Page6}return(Ri);}从fi定义可知,fi为单调函数.计算R4时,在计算序列Rj1j2j304中,由于σ4=ν,R4中各结点的val值或保持Rj1j2j3ω初值true不变,或为false,且一旦结点val值改变为false后,在Rj1j2j30中不再发生改变,各中间结果间满足Rj1j2j3ωRj1j2j324Rj1j2j31计算R3时,σ3=μ,各中间结果间满足Rj1j20Rj1j213Rj1j22计算R2时,σ2=ν,各中间结果间满足Rj1ωRj122Rj111…RωR2计算R1时,σ1=μ,各中间结果间满足R0引理1.用算法2对式(1)进行迭代计算,则有(1)Rj1(j2+1)j3ω(2)Rj1j2ω证明参见附录3.当R1取值为Rj13时,计算R4的计算序列为Rj1(j2+1)j30Rj1(j2+1)j34,Rj1(j2+1)j32Rj1(j2+1)j31Rj1(j2+1)j3ω44=Rj1(j2+1)j30Rj1j2j30以不必从Rj1(j2+1)j304,…,Rj10j3ωRj1(j2-1)j3ω保证计算结果的正确性.通过选取序列Rj1j2j3ω4,…,Rj10j3ωRj1(j2-1)j3ω4的计算初值,可以有效的利用之前的计算Rj1(j2+1)j3ω结果,减少迭代计算的次数,提高模型检测算法的性能.因R(j1+1)j203R(j1+1)j2ωRj1j2ω3开始计算,而是从序列R0j2ωRj1(j2+1)03中任选一个值开始计算,同样可以保证计算的Rj1j2ω正确性,减少迭代计算次数,提高模型检测算法的性能.根据以上分析,对谓词等式系(1)对应结点进行计算时,可在算法2的基础上,对计算过程进行优化,改进后的算法为算法3.在算法3中,Ri=Ri0∪Ri1∪Ri2,a,b数组分别存放R3,R4迭代计算过程中的迭代序号和最新计算数据.a[j]保存序列R0j0计算数据,b[k]保存序列Rj10k04中最新计算数据,当j1改变时,b数组重新初Rj1ωkω始化.算法3.函数formulaChangToequation()见算法1,Model-Check(P,F),InstallSet((P,X(n-,,σ)))和ValueRecord((P,X(x-,,σ)))见算法2.ValueSet()函数重定义如下:ValueSet()//嵌套谓词等式系的计算{R1=R0a[0:|R00for(i=0;i<=|R0R2=R00b[0:|R000for(j=0;j<=|R00for(;k<=|R000Page73∷4,各层计算结点的计算序列为1=S10,R00(R04,…,R000ωR00024,R0023,(R0020R001ω3,R012,(R010R00ω4,…,R010ωR010(l+2)4,…,R011ωR011(l+2)4,R013…,R012ω3,k)=(R00ω(R1004,R10(k+1)R10kω4,R10(k+2)R10(k+1)ω4,l)=(R10kω(R11k03,((R11(k+1)0R11(k+1)4,…,R11(k+1)ωR11(k+1)(l+2)2,R2R1ω1,…,Rω在计算序列中,赋值语句只是读取已有数据,Si0保存i对应的计算结点,其中结点值均取初值.定理1.用算法3计算,如果ModelCheck(P,F)最后计算结果(P,X(x-,,σ,id),val).val=true,则PF,否则P/F.证明参见附录4.定理2.利用算法3对嵌套谓词等式系(1)进行计算,时间复杂度为O((M+d)2).r1=f1(R1,R2,R3,R4);//计算Ri+1if(r1==R1)break;//到达当前不动点elseR1=r1;}}例1.根据算法3,嵌套谓词等式系1∷2∷证明参见附录5.定理3.算法3的空间复杂度为O(M).证明参见附录6.6算法应用范围扩展6.1σ4=μ的情形小不动点的嵌套谓词等式系:设交错嵌套深度为4且最内层不动点算子为最4为最内层等式块,不动点类型分别为σ1=σ3=ν,σ2=σ4=μ,1,2,3,4等式块对应的结点集为R1,R2,R3,R4.由于σ1=σ3=ν,R0true;σ2=σ4=μ,Rj10false.等式块1∷2∷3∷4对应结点的计算函数分别为f1,f2,f3,f4,则有1=f1(Rj1Rj1+12=f2(Rj1Rj1(j2+1)3=f3(Rj1Rj1j2(j3+1)4=f4(Rj1Rj1j2j3(j4+1)具体fi的定义见定义2.当R1取值为Rj1时计算R4,有计算序列Rj1j2j304.由于σ4=μ,在计算过程中,R4中各结点Rj1j2j3ω的val值或保持初值false不变,或为true,且一旦结点val值改变为true之后,在Rj1j2j304,…,Rj1j2j3ωRj1j2j32果间满足Rj1j2j30σ3=ν,各中间结果间满足Rj1j2ω3Rj1j20Rj1j21σ2=μ,各中间结果间满足Rj102.Rj1ωσ1=ν,各中间结果间满足Rω引理2.用算法2对式(2)进行迭代计算,则有(1)Rj1j2j3ω(2)R(j1+1)j2ω证明与引理1的证明类似,证明略.根据引理2,可用算法3来计算嵌套谓词等式系(2)对应结点的不动点值.6.2嵌套深度为犱的情形算法3讨论的是交替深度d=4的算法.下面将算法3推广到d>4的情形.对于嵌套谓词等式系(3):令n=(d+3)/4,将1,2,…,d按从左到右的顺序进行分块,4个一组,如果dmod4=0,则可以分为n=d/4块:A0=(1,…,4),A1=(5,…,Page8算法4.算法4.对编号为x的等式块对应的计算结8),…,An-1=(d-3,…,d).如果dmod4≠0,则分为n=d/4+1块:A0=(1,…,4),A1=(5,…,8),…,An=(4n+1,…,d).嵌套谓词等式系(3)对应结点模型检测算法如点进行计算.ValueSetx()//计算块号为x的嵌套谓词等式系对应结点{Rx,1=R0//初始化ax数组for(ix=0;ix<=|R0Rx,2=R00//初始化bx数组rx,1=fx,1(R1,R2,…,Rd);//计算Ri+1if(rx,1==Rx,1)break;//Rx,1到达当前不动点Rx,1=rx,1;}}在算法4中,ValueSetx()计算编号为x的等式系模块对应的结点,ValueSetx()嵌套调用了ValueSetx+1(),计算交错嵌套层次更深的等式系对应结点的当前不动点值.fx,i对应f4x+i,Rx,i对应R4x+i,计算编号为n的等式系模块时,循环次数为模块中不动点算子交错嵌套深度.用算法4计算时,最先调用ValueSet1(),ValueSet1()调用ValueSet2(),ValueSet2()调用ValueSet3(),…,ValueSetn-1()调用ValueSetn().当编号为n的等式块对应的结点到达当前不动点时,计算编号为n-1等式块对应的结点.当编号为n-1等式块对应的结点集中有结点值发生改变,此时继续调用ValueSetn(),直到编号为n的等式块对应的结点再一次到达当前不动点,流程返回ValueSetn-1().如此反复,直到编号为n-1的等式块对应的结点集到达当前不动点,流程转移到ValueSetn-2()进行计算,….这样一直计算下去,直到编号为1的等式块对应的结点集到达当前不动点,整个计算流程结束.定理4.用算法4对嵌套谓词等式系(3)对应的结点集进行计算,算法时间复杂度为O((M+d)d/2+1).证明参见附录7.定理5.用算法4对嵌套谓词等式系(3)进行计算,算法空间复杂度为O(M).证明参见附录8.例2.对嵌套谓词等式系(3)对应的结点进行计算,设各等式块对应的计算结点数均为40,利用本文算法与文献[10]中的算法计算,当不动点算子交错嵌套深度d取不同值时,在最坏的情况下(各计算结点val值最终均由初值翻转后才到达最终不动点),各函数的计算次数和|f|的值见表1.表1本文算法与文献[10]中算法计算时各函数计算量比较mi=40d=1d=2d=3d=4d=5d=6d=7d=87结束语本文对基于有限控制移动界程的μ-演算一阶谓词界程逻辑局部模型检测算法进行了深入的分析和研究,指出文献[10]中模型检测算法在计算过程Page9中,中间结果间存在两组偏序关系,并据此提出了一个局部模型检测快速算法,算法的时间复杂度与d/2+1呈指数关系,空间复杂度与M呈线性关系,d为公式中不动点算子交错嵌套深度,M为计算结点集规模.据本文作者所知,这是继文献[5,10]后,目前公开的第三个基于有限控制移动界程的μ-演算一阶谓词界程逻辑局部模型检测算法.相比之前出现的同类算法,其性能得到了大大提高.本文的研究成果在促进界程逻辑模型检测技术的推广应用方面以及在推进界程逻辑模型检测理论的深入研究方面均意义重大.同时,本文的研究方法同样适应于π-演算和CCS演算局部模型检测算法的设计.致谢本文在研究过程中,得到了中国科学院软件研究所林惠民院士、李广元研究员和福建省粒计算重点实验室祝峰教授的大力指导和支持,在此深表感谢!
