Page1基于软件网络的服务自动分类和推荐方法研究潘伟丰1),2)李兵1),3)邵波1)何鹏1)1)(武汉大学软件工程国家重点实验室武汉430072)2)(浙江工商大学计算机与信息工程学院杭州310018)3)(武汉大学复杂网络研究中心武汉430072)摘要服务的分类和推荐方法对于服务管理和组合都具有重要意义.文中利用服务组合历史,从面向服务软件的结构角度研究了服务分类和推荐方法:提出面向服务软件的软件网络模型,并用于抽象面向服务软件的拓扑结构;利用复杂网络社区发现算法对软件网络进行聚类,从而实现服务的自动分类;利用软件网络描述服务之间的可组合关系及其强度,并基于服务的使用场景提出了相应的服务推荐算法.使用ProgrammableWeb上API服务和mashup应用的真实数据来说明该文方法的有效性.从实验结果可以看出,该方法可以准确地实现服务分类,整个聚类的纯净度达到了86.8%,同时推荐的服务也比较有意义,这对于解决服务计算中的一些问题,包括服务的管理、检索、组合等都具有一定的意义.关键词服务分类;服务组合;社区发现;复杂网络;服务计算1引言面向服务的计算(Service-OrientedComputing,SOC)是针对分布式系统的新型计算模式,为解决分布异构环境中跨组织敏捷应用集成问题带来了诸多便利,已成为软件领域最热门的话题之一[1].SOC倡导以服务及其组合为基础构造应用的开发模式,导致软件系统的主要形态、生产方式、运行方式和使用方式都发生了巨大变化,软件系统正处在一个由软件服务实体组成的开放协同的软件环境中[2].从传统的基于SOAP的Web服务到目前REST风格的Web服务以及mashup/API服务等,服务的种类日益丰富,应用领域也不断拓展,以服务为中心的互联网正在形成.随着软件体系结构研究的深入,人们逐渐意识到软件结构是决定软件质量的重要因素[3].一些研究者基于软件的网络结构(软件网络),采取软件工程和复杂网络相关理论相结合的研究方法,以分析软件结构特征为着眼点,以理解软件的结构特征为软件开发和维护提供支持为目标,从表征、分析、度量和应用4个方面对软件的静态结构进行系统分析,取得了可喜的成果,这些成果对指导软件的开发和维护具有重要的指导意义[4-12].如今面向服务软件(Service-OrientedSoftware,SOS)日益成为主流,我们有必要研究SOS的结构,挖掘结构中蕴含的知识,从而更好地指导SOS的开发.不断出现的在线服务和SOS注册中心(如ProgrammableWeb①、seekda②、myExperiment③等)为我们从结构角度研究SOS提供了一个契机.服务发现和服务组合吸引了国内外众多学者的关注,成为SOC领域中的关键问题[13].但是目前的服务缺少分类信息,给服务发现、检索以及服务资源的管理带来不便.如果采用手工的方式对服务分类,当服务数量很大时显然是不可取的,因此如何实现服务的自动分类构成SOC的挑战.与此同时,服务组合中服务的可组合关系往往是根据服务间的输入输出来进行判断的,均遵循了文献[14]中的服务匹配原则,但这一原则过于严格.那么除了输入输出匹配外,是否存在一种新的服务匹配方法能够挖掘服务间的潜在可组合关系?本文针对上述两个问题展开研究,通过对服务组合历史,即已有SOS结构的分析,挖掘结构中蕴含的知识,最终实现服务的自动分类和服务推荐(文中将SOS看成大粒度的服务).我们把这种方法称为从历史学习的方法(LearnFromHistory,简称LFH方法),并以ProgrammableWeb上API服务和mashup应用的真实数据为例进行验证.LFH方法将面向对象(Object-Oriented,OO)软件的软件网络模型引入SOS研究中,提出了SOS的软件网络模型.基于该软件网络模型,提出了基于复杂网络社区发现的服务自动分类方法.同时,提出了一种服务推荐方法,该方法可以推荐与一个或多个服务匹配的其它服务.实例研究表明,本文的方法在实现服务自动分类和服务推荐方面是有效的.本文第2节介绍相关工作;第3节将详细地介绍LFH方法,包括SOS的软件网络模型、服务的分类方法、服务的推荐算法等;第4节将以Program-mableWeb上的mashup、API服务的真实数据验证LFH方法的有效性;第5节介绍本文方法的应用平台;最后是结论与展望.2相关研究复杂网络为我们研究系统结构及其动力学行为提供了有力的工具.近年来,一些研究者将复杂网络相关理论引入软件工程中,构建软件网络模型,用于分析OO软件的结构特征及其动力学行为.复杂网络理论强调从整体上认识、理解和控制系统,而非关注局部.研究系统在整体上表现的特征可以为我们理解软件系统提供新的维度.2002年,Valverde等人[4]首先将复杂网络方法引入软件结构分析中.他们将系统的类图用无向网络来抽象,即网络中的节点表示系统中的类,节点间的边表示类间的关系,如继承(inheritance)、关联(association)等.他们用这种方法抽象JDK1.2和UbiSoftProRally2002,并用复杂网络中的相关方法分析这些软件网络的统计特性.他们发现,这两个软件的软件网络具有与其它复杂网络类似的“小世界”和“无标度”特性.同时,他们认为软件开发中的局部优化过程可能是导致软件网络呈现这些特性的原因.在软件系统中,系统模块(类、方法等)之间的关系(协作、调用等)反映了系统的控制流.因此,软件①②③Page3网络中的边的方向是有意义的[5].2003年,一些研究者使用有向网络研究软件结构.Myers使用有向网络表示软件系统的结构,分析了3个OO软件的类协作图(classcollaborationgraph)和3个面向过程软件的静态过程调用图(staticprocedurecallgraph).他们发现:(1)这些有向软件网络尽管来自不同系统,甚至是用不同类型语言(面向过程/对象)开发的系统,但是都具有“小世界”和“无标度”特性;(2)出入度分布的幂指数存在不平衡性,即出度分布的幂指数大于入度分布的幂指数;(3)出度与入度之间存在负相关性,他们认为这可能与软件重用有关,即简单的类(出度小的类)容易被重用,因此入度大.Valverde和Sole使用有向网络描述软件系统的类图(classdiagram)对系统的结构进行研究.他们发现,类粒度的软件网络除了具有“小世界”和“无标度”特性外,同时具有层次性(hierarchical)和模块性(modularity)[6].之后,人们开始从不同粒度(方法、类、包、文件等)对大量开源软件的结构进行研究.Moura等人将C和C++语言开发的系统在文件级(头文件)抽象成网络,即头文件为节点,头文件的共现关系抽象成边.他们发现这样的网络也具有“小世界”和“无标度”特性,并指出:“软件随时间增长是软件呈现无标度特性的原因,软件性能的优化是软件具有“小世界”特性的原因”[7].LaBelle和Wallingford[8]在包粒度将软件系统看成网络,对一些软件的依赖网络进行分析,发现这样形成的网络同样具有“小世界”和“无标度”特性.Valverde和Sole[9]将类和类的方法都抽象为节点,方法访问类的关系抽象成类节点和方法节点间的边,他们发现这样构建的软件网络图1LFH方法框架也同样具有“小世界”和“无标度”特性.国内的研究人员在这方面也做了些实证研究,如李德毅、李兵等人[10-12]对Java语言编写的若干软件系统以及Linux等进行分析,发现了其中的“小世界”和“无标度”特性.以上这些工作都是针对面向过程或OO软件展开研究的,针对SOS的工作很少见到.但是随着近年来SOC的快速发展,面向服务的思想已经被许多软件工程师所接受.基于服务的应用正在获得强劲发展势头,因此有必要分析SOS的结构,以指导SOS的管理和开发等工作.本文的工作正是围绕这点展开的,主要探讨服务的自动分类和推荐方法,因此与以前针对面向过程软件和OO软件所开展的工作有显著区别.3LFH方法从面向结构的程序设计到面向对象/构件程序设计,再到面向服务的软件开发方式,软件的设计和实现的重点已从实现局部的编程难题,转向了如何将代码有效地进行组织,特别是对于大规模复杂软件系统而言,结构的组织就尤为重要.与此同时,使用自然语言或符号语言(如OWL-S[15])这种一维的知识表示方式来描述服务,无法从全局的角度呈现SOS的复杂结构.LFH方法使用软件网络这种二维知识表示方法抽象SOS的拓扑结构,并进而指导服务的自动分类和推荐.图1给出了LFH方法的基本框架.以下各小节将对框架中的部分内容进行说明,并给出相关概念的定义.Page43.1数据收集随着服务数量的增加,在线的服务注册中心为服务开发者和服务消费者提供了一个服务交易的场所,如ProgrammableWeb、seekda、myExperiment等.注册中心通常是按照特定的注册模型进行注册的,包含了服务的元信息,如服务的名称、描述、地址、标签、提供者等.对于一些由服务构成的SOS(大粒度服务)甚至包含构成这个SOS的服务列表.LFH方法将收集注册中心中各类服务以及由这些服务构成的SOS的元信息(如名称、描述、标签等),并存于本地数据库.这些爬下来的数据可能存在一些噪声,如作为标签的单词拼写错误、服务重复注册等.LFH方法对收集到的数据进行预处理,通过一些算法修正单词的拼写错误、删除重复注册的服务等,尽量排除数据中的噪声.数据的收集可以借助一些整站下载器,如Tele-portUltra①、webzip②、WinHTTrack③等来完成,即:首先,用整站下载器将网站中的相关页面以html静态页面的形式爬到本地;然后,编写一些脚本解析html页面中的相关字段存于本地数据库中;最后,再对收集到的数据进行预处理以减少噪声.3.2SOS的软件网络模型SOS通常由若干(0)服务辅以一定的编程组合而成,因此可以看成一种更大粒度的服务.文中将由单个服务构成的软件看成一类特殊的SOS.SOS和服务之间的这种宏观组合关系可以使用网络模型来抽象.下面首先给出SOS相应软件网络的定义.定义1(SOS-服务网络).SOS-服务网络(简称SOS2S)可以用一个二部图表示,即SOS2S=(NSOS,Ns,D).其中,NSOS为SOS节点的集合,表示所有SOS的集合;Ns是服务节点的集合,表示SOS使用的所有服务的集合;D是一个无向边的集合,表示SOS对服务的使用关系.SOS2S的边只存在于不同类型节点间,即D={{sosi,sj}},sosi∈NSOS,sj∈Ns.SOS2S的连接矩阵ψ描述了SOS节点和服务节点间的连接关系:其中,ψ是一个A×B的二值矩阵,A=|NSOS|表示SOS的数量,B=|Ns|表示服务的数量.若ψij=1,则第i个SOS节点和第j个服务节点间存在有边相连,否则不存在边.SOS2S表示的是两类不同节点(SOS节点和服务节点)间的关系.同类型节点间的关系(SOS和SOS的关系或服务和服务的关系)可以通过对SOS2S作投影得到(如图2所示).定义2(SOS-SOS网络).SOS-SOS网络(简称SOS2)可以用一个单模无向图表示,即SOS2=(NSOS,DSOS).其中,NSOS为SOS节点的集合,表示所有的SOS的集合;DSOS是一个无向边的集合,表示SOS间共用服务这种耦合关系,即若两个SOS共用服务,则代表这两个SOS的节点间存在一条无向边.SOS2的连接矩阵ψSOS可由ψ得到,即其中,ψSOS务的数量,ψSOS因此,若ψSOS存在共用服务的耦合关系({sosi,sosj}∈DSOS),它们ij个服务;否则这两个SOS间没有共用任何共用ψSOS服务({sosi,sosj}DSOS).同时,我们给SOS2中每条边赋予一个权值,用于刻画这条边两端节点代表的SOS间的相似度.第i个SOS节点和第j个SOS节点之间的边权wSOS定义如下:其中,ws到的相似度;wtij是通过使用的标签计算得到的相似度;a和b是相应分量的权重,且满足0a,b1,a+b=1.通过调节a和b的值,我们可以满足不同的服务分类需求.SOS使用的服务代表了其功能,如果我们主要从SOS的功能构成角度对其分类,则a可以设置得相对大些;SOS使用的标签代表了提供者对该SOS的认识,如果我们主要从提供者认知角度对其进行分类,则b可以设置得相对大些.本文中a=0.9,b=0.1.我们使用Jacard相似度系数(Jacardsimilaritycoefficient)来计算两个SOS之间的相似度.给定两个集合E和F,则它们之间的Jacard相似度系数计算如下:所以ws①②③Page5其中,Nis和Njs(Nit和Njt)分别表示第i个和第j个SOS使用的服务集合(标签集合).定义3(服务-服务网络).服务-服务网络(简称S2)可以用一个单模无向图表示,即S2=(Ns,Ds).其中,Ns为服务节点的集合,表示所有SOS所使用服务的集合;Ds是一个无向边的集合,表示服务间的共现关系,即若两个服务共同作为某个SOS的构成部分,则代表这两个服务的节点间存在一条无向边.S2的连接矩阵ψs可由ψ得到,即其中,ψsii表示服务i参与的SOS的数量.因此,若ψsψs则服务i和j之间存在共现关系({ai,aj}∈Da),否则不存在共现关系({ai,aj}Da).同时,我们也给S2中每条边赋予一个权值,用图2SOS2S、SOS2和S2构建举例3.3SOS和服务的自动分类3.3.1SOS的自动分类社区结构是复杂网络中一个重要的特性,它是一种介于宏观和微观之间的网络特征,是真实世界中许多复杂网络所具有的一种普遍性质.研究表明,社区结构和网络的功能(鲁棒性、高速传播性等)有着紧密的关系.网络社区结构的检测是揭示网络结构和功能之于刻画这条边两端节点代表的服务间可以组合的可能性.服务节点i和j间边的权值ws其中,Nks是第k个SOS使用的服务的数量.显然,ij描述了服务i和j间可以组合的可能性大小.wsws值越大,则服务i和j间可以组合的可能性越大.因此,S2实质上包含了从已有SOS中获得的服务之间是否可以组合的知识.可以想象,SOS越多,服务之间可以组合的知识就越丰富,当SOS的数量趋于无穷时,S2中将包含服务间的所有可组合关系.但是,SOS的数量往往是有限的,所以已有SOS中服务之间真实的连接网络ωs=(Ns,Es)和S2满足图2显示的是从我们收集的真实API服务和mashup应用数据(详见第4节)中构建的SOS2S、SOS2和S2.其中,mashup应用对应SOS,API服务对应服务.间关系的重要基础,成为了最近几年的研究热点.复杂网络采用图作为表示形式,因此很多在计算机领域被广泛应用的图分割算法都可以直接应用于复杂网络的社区检测,如Kernighan-Lin算法[16]、谱分割法[17-18]等.但传统图分割算法倾向于把网络分成规模相近的子图或要求网络的社区数目已知,而这两点往往是很难满足的,因此复杂网络领域出现了很多新的社区发现方法,按照边的连接权值可以分为:Page6无权网络的社区发现方法[19-20]和加权网络的社区发现方法[21-22];按照节点的隶属度可以分为:硬划分的社区发现方法[20-22]和模糊社区发现方法[23-24];按照发现的策略可以分为:层次算法[20-25](分裂和凝聚)和最优化算法[26];或者分为全局社团发现方法[20-22,25-26]和局部社区发现方法[27-28]等.本文使用复杂网络社区发现算法,对SOS2进行社区划分,可以对大量SOS(大粒度服务)进行聚类,进而对服务进行聚类.目前用于评价社区划分质量的指标不少:Mancoridis等人提出了模块化质量MQ(ModularizationQuality);Tucker等人提出EVM函数(EVMFunction);Newman提出了模块度Q[29].本文使用应用比较广的模块度Q作为评价指标.鉴于本文中待划分的网络SOS2是一个加权网络,我们使用针对加权网络的Q来评价社区划分的质量.其中,Q是网络的模块度;weii表示两个端点都在社区i的边其边权和占总边权和的比例;wai表示至少有一个端点在社区i的边其边权和占总边权和的比例.如何计算Q值对算法的性能具有重要的影响,特别当网络的规模很大时.本文将计算Q的增值ΔQ,而不是Q,这一思路与文献[29]同.将一个节点从社区i移动到社区j造成的Q值的变化可以计算如下:ΔQ=weij+weji-2waiwaj,社区i和j是相连的0,{正如前面所述,目前用于社区划分的算法很多,本文从算法复杂性角度出发,选择使用Newman提出的快速算法对SOS2进行聚类,其时间复杂度为O(n·logn),n为网络节点数.但是原始的快速算法是针对无权网络的,为了使其可以处理边权为实数的网络,我们对其做了必要的修改.修改后的快速算法MFA描述如下.算法1.修改后的快速算法MFA.输入:弱连通网络输出:Q和聚类结果1.假定SOS2中每个节点都是一个社区,并根据式(10)2.WHILE社区总数大于1{3.根据式(11)依次计算有边相连社区合并后的4.更新weij、waij和Q;5.}6.选择使Q最大时的网络划分,输出相关结果;7.RETURN.社区发现算法往往是针对弱连通图进行的,MFA以SOS2的弱连通子图(WeaklyConnectedGraph,WCG)作为输入,输出模块度Q和聚类结果.MFA针对的是已经收集到的SOS的分类,那么对于后续新加入的SOS我们该如何确定其类别呢?LFH将分两种情况实现新增服务分类,即:(1)如果这个SOS与现有SOS有联系(共用部分服务),即在SOS2中代表这两个应用的节点间有边相连,我们将该SOS分类到与其相连的那些SOS中产生最大ΔQ的那个SOS所在的类别中.这种方法与我们以前用社区发现算法实现OO软件类重构的方法类似,详见文献[30].(2)如果这个新增SOS与现有SOS没有任何联系(没有共用任何API服务),我们先将该SOS归为未分类.随着更多的SOS通过(1)、(2)的方式不断加入,先前那些未分类的SOS(包括不在WCG中的SOS和新加入但是未分类的SOS)这时可能与其它已分类SOS有联系,这时我们可以对这些未分类的SOS按照(1)的方法再进行分类.如图3所示,每个黑色节点代表一个SOS,边上的文字是其名称,虚线圈起来的SOS属于一个类别.在LFH方法中,对每个新增的SOS(记为SOS_e)分类时将完成以下步骤:1.判断节点SOS_e与哪些节点有直接的联系:节点SOS_e与类别Cx内的SOS_c和类别Cy内的SOS_d有直接联系,而与类别Cu中的SOS_f没有直接的关系(肯定不会移动至没有直接关系的类别Cu).2.LFH方法会试探性地将节点SOS_e移至有直接关系的其它类,即:从类别Cz分别移至类别Cx和类别Cy,然Page7后计算在这两次移动过程中产生的ΔQ,即ΔQzx和ΔQzy.如果ΔQ<0,则令ΔQ=0.3.比较ΔQzx和ΔQzy的大小:如果ΔQzx>ΔQzy,则将节点SOS_e从类别Cz移至类别Cx;如果ΔQzx<ΔQzy,则将节点SOS_e从类别Cz移至类别Cy;如果ΔQzx=ΔQzy,则将节点SOS_e随机移至类别Cx或类别Cy之一,即若rand(0,1)>1/2,则将节点SOS_e移至类别Cx,否则将节点SOS_e移至类别Cy.3.3.2服务的自动分类我们认为,服务的类别并不是先验的,而是由用户的使用及其应用情境所决定.也就是说,服务的类别由其被使用的SOS的类别来分类.在具体实施服务分类前,我们首先定义服务相对于社区(类别)的权值.第j个服务sj相对于SOS的第k个类别Ck的权值Wk类,其时间复杂度为O(N2s).算法2描述如下.公式中的标识符与其第一次出现时的意思相同.LFH方法根据算法2来对API服务进行分算法2.服务分类算法SCA.输入:服务集合Ns输出:各服务对应的类别名注:cNum对应SOS分类数;W[k]用于存储服务相对1.WHILENs中服务节点数大于1{2.取Ns中一个服务sj,并将其从Ns删除;3.fork=0tocNum{4.计算sj相对类别k的Wk5.}6.取max(W[k])对应的下标k(若W[k]中有多个7.令sClu[j]=k;/将sj归入获得最大Wk8.}9.输出sClu[]中元素;10.RETURN.3.4服务推荐3.4.1SOS2S结构特征分析现有的SOS包含了SOS对服务的使用模式,分析这些使用模式可以为我们推荐服务和构建SOS提供指导.因此,本小节我们首先分析一下SOS2S的一些基本结构特征.为了后面工作的需要,我们使用二部图研究中比较常用的度数中心度(DegreeCentrality,DC)指标来分析SOS2S的结构特征.定义4(度数中心度[31]).在二部图中,一个点的度数中心度是该节点所隶属的事件数,一个事件的度数中心度是该事件所拥有的行动者数.本文中,服务的度数中心度描述了该服务参与的SOS的数量.SOS的度数中心度描述了SOS使用的服务的数量.这两个度数中心度反映了SOS和服务的使用模式,即SOS使用几个服务,服务被几个SOS使用.这里我们主要使用SOS的度数中心度为推荐服务和构建SOS提供指导.在得到SOS的度数中心度后,我们将分析这些数值的分布,从而确定大部分SOS使用服务数的一个较小范围[A,B].譬如如果有100个SOS,这100个SOS使用的服务数从1个到30个不等,但是若90%(这个数字可以由用户设定,建议大于80%)以上的SOS使用的服务数都小于10,那么我们就设置[A,B]为[1,10].[A,B]实际上是构成SOS服务数的一个范围,我们新开发的SOS所使用的服务数也在很大概率上是属于这个范围.3.4.2服务推荐算法如前所述,SOS包含了服务的使用模式,从SOS2S得到的S2自然也包含了服务之间的使用模式.S2中任意长度的路径实际上就是一个潜在的SOS.因此,要构建新的SOS,只需要依据一定的规则对S2进行遍历即可.同时,我们将度数中心度最大的几个服务称为平台服务,它们成为很多SOS的构成单元.通过对SOS2S作投影操作可以得到SOS2S相应的S2.我们将基于S2来为构建SOS的用户推荐服务.首先我们将SOS开发中,服务的使用场景分为以下3种类型:(1)用户还未选择任何服务;(2)用户已选了一个服务;(3)用户已选了n(n>2)个服务.针对每一种应用场景我们都提出了相应的推荐方法.服务的推荐算法SRA见算法3,其时间复杂度为O(n·logn),n为网络节点数.由于网络的规模比较大,节点间的连接可能会比较稠密,为了提高推荐算法的效率,我们在算法中提供了一个边权过滤值wth(wth∈[0,1]),用于将那些边权值很小的边过滤掉.同时,从3.4.1小节的分析我们可以知道,SOS一般有B个以内的服务构成,所以在推荐算法中,针对应用场景3,我们限定推荐的服务路径长度l在B个以内,即lB.同时,SOS是个大粒度的服务,SOS的推荐可以由构成它的服务的推荐来实现,即将构成该SOS的所有服务作为推荐算法的输入.服务推荐算法SRA描述如下.Page8算法3.服务推荐算法SRA.输入:S2、用户已选择的服务集合Ssel、待推荐的服务输出:推荐的服务集合1.IFSselisNULLTHEN//场景(1)2.推荐平台服务;3.ELSEIF|Ssel|=1THEN//场景(2)4.IFDC(k)kTHEN5.在S2中选择与服务k相连的节点中,节点间边6.ELSEIF1<DC(k)<kTHEN7.在S2中选择与服务k相连的节点中,节点间边8.ELSE//场景(3)9.ForSsel中任一节点组合Ns和Ne10.求S2中以Ns为起点,Ne为终点,包含Ssel中其11.按照路径长度对Sroute中的路径归类,输出每一类12.RETURN.4实例分析为了说明LFH方法的具体实施过程,同时验证其有效性,本文将结合ProgrammableWeb上mashup应用和API服务的真实数据,进行实证分析.4.1数据来源ProgrammableWeb是著名的mashup应用和开放API服务目录,罗列了5000多个mashup应用和3000多个API服务,并提供了mashup和API的一些注册元信息,包括它们的名称、URL、提供者、标签等.API是服务,mashup是由服务组合得到的SOS,也可以看成大粒度服务,它包含服务组合的历史信息,符合本文工作的要求.因此,本文以ProgrammableWeb上的mashup、API服务的真实数据为例展开研究.图4所示的是ProgrammableWeb上名称为SkiBonk①的mashup应用的一些注册元信息,包括mashup应用的名称、描述信息、使用的API服务和标签等.我们使用自己开发的网爬工具将Program-mableWeb上从2005年(建站时)到2011年1月12日(本文工作开展时)所有mashup应用的名称、描述信息、API服务和标签信息(图4中方框部分)爬了下来,存储在本地数据库中.这些数据是后续工作的基础.ProgrammableWeb上的数据都是由用户提交的,存在一定的随意性.在数据收集的过程中,我们发现这些数据存在一些错误:(1)有些mashup存在重复注册现象.一些mashup虽然它们名称不一样,但是它们其它的信息都一样.这些mashup在我们的数据集中只保存一份.(2)有些mashup仅提供了名称,但是其它我们所需的注册信息缺失了.这些mashup将不作为我们的实验数据.同时,用于标识mashup的标签也存在不一致,同一种含义的标签有多种不同的表现形式,如“api”、“Api”和“APIs”都表示API,但是形式不同,有些标签甚至拼写错误.LFH方法使用文献[32]中的SuffixStripping算法对标签进行预处理,将同意异形的词都转化成同一词性,尽量消除存在的不一致性.最终,我们的数据集包含5115个mashup应用、750个API服务和1489个标签,数据集可以从文献[33]下载.4.2mashup和API服务的自动分类4.2.1mashup的自动分类通过解析所获得的数据,我们构建了所有mashup应用和API服务之间的SOS2S(mashup是SOS、API是服务).通过对SOS2S作投影操作,我们可以得到SOS2S相应的SOS2,该SOS2拥有5115个节点和2660793条边.但是这个SOS2并非一个弱连通图,它由97个弱连通子图构成.图5显示了各个弱连通子图包含的节点数,其中最大弱连通子图(MaximumWeaklyConnectedGraph,MWCG)有4973个节点,最小的子图节点数仅为1(孤立点).MWCG的节点数占了SOS2总节点数的①SkiBonk在programmableWeb上的网址.http://www.Page997.2%,而其余的弱连通图的节点数占了不到4%,统计上忽略它们不会对结果产生太大的影响.因此,本文使用SOS2的MWCG作为分析对象.我们将MWCG作为MFA算法的输入,聚类后图5图6从图5(b)我们可以发现,类6至类17中mashup应用节点数都在20以内(合计58个节点),相比网络规模总节点数4973而言很小,统计上我们可以将这些类忽略.因此,我们这里主要考虑前5个分类.为了验证分类结果是否有意义,我们手工对5个分类中共4915个mashup应用进行分析.通过分析每个mashup应用的描述(description)信息,从描述信息判断其功能及所述的领域,最终将这4915个mashup进行手工分类.在分类1中(如图6(a))除CrowdMatchviaHotorNot、GuessWhoisHotter、Hard、HotCap-tcha、HotOrNotHook-Up、HotOrNotLiveGadget、HotOrNotOddOutGame、JesusSpeaks、metamedias、ScoreSum、Snaparazzi这11个mashup应用以外,其余都是跟手机移动通信密切相关的.而这11个应用得到17个分类(社区),各分类的规模如图5(b)所示,部分分类结果及其网络图见图6所示.那些不在MWCG中的mashup应用,我们将其标识为未分类.之所以也被划分到分类1中,是因为它们使用的API服务也被分类1中其它的mashup应用频繁使用.在分类2中(如图6(b))除TheFiveSpace、Rosetta、WeatherholicDynamicImages、StockaholicDynamicChart这4个mashup应用以外都是跟在线办公(在线文档处理)密切相关的.而这4个应用被划分到分类2中,同样也是因为它们使用的API服务被分类2中其它的mashup应用频繁使用.分类3中主要是一些与出行相关的mashup应用,包括道路、交通、住宿、餐饮、天气等.当然,这些mashup应用中好多也用到了地图方面的API服务.在分类4中主要是一些与地图相关的mashup应用,且大多数应用都使用了GoogleMaps这个API服务,甚至好多应用仅由这一个API服务构成,如Openmaps、RateMyStreet等.在分类5中主要是一些与社交网Page10络(Flicker、Twitter、Facebook、Youtube、Delicious、wiki、amazoneBay)密切相关的mashup应用.此外,也包括了一些出行、桌面应用、手机软件、政治等相关的应用.这些应用之所以也分到了这个类中,是因为它们都是使用了与Twitter、Facebook等相关的API服务.分类3至分类5的网络规模比较大,用网络图显示不够清晰,故这里我们将它们省略了,相关数据可从文献[33]下载.为了评价分类的有效性,人们提出了很多度量方法,如外部度量、内部度量和相对度量等[34].我们选用外部度量中的纯净度指标(ClusterPurity,CP)[35]来检验本文方法的有效性.下面首先给出纯净度指标的定义.定义5(聚类纯净度[35]).令D表示待聚类的数据集合,C表示D上的某次聚类划分,Ck∈C为该聚类结果中的一个簇,S表示D上的标准聚类结果,s∈S为该聚类结果中的一个标准簇,则Ck类的纯净度CP(Ck)定义为该类数据占整个簇的比例,即其中|·|表示集合·中的元素个数.本文中标准聚类结果S是通过我们手工分类得到的.在此基础上,整个划分C的纯净度CP(C)是所有簇的纯净度的均值,即CP反应了聚类结果的准确性,其值越高说明聚类效果越好,纯净度能对聚类结果进行较为全面合理的评价.本文方法所得各个簇的纯净度如表1所示,整个聚类的纯净度为86.8%.4.2.2API服务的自动分类在得到了mashup应用的分类后,我们按照SCA算法实现API服务的分类.各类别中的API服务数量如表2和图7所示.表2中显示的是5个主要分类的结果(对应4.2.1节mashup应用的5个主要分类),图7显示的是所有分类的结果.其中第0类表示这些API没有被分类.因为我们的分类是针对mahsup的分类结果来对API分类的.mashup分类的时候针对的是MWCG进行的,忽略了那些不在这个MWCG中的节点.所以这些mashup应用使用的部分API就无法实现分类.为了检验LFH方法对新增mashup应用分类的有效性,我们又将ProgrammableWeb上2011年2月1日至2011年2月28日(本文工作结束时)新增的85个mashup应用的元信息爬了下来.在这85个mashup应用中,共有30个mashup应用使用了2011年1月12日(4.1节数据收集之时)后注册的新API服务,如mashup应用ComparePricesDis-count-Malin.com使用了Kelkoo,player4you使用了GoogleFont,mapTheGraph!使用了FacebookGraph等.这些mashup应用在与其它mashup应用计算相似度的时候,这些新API服务没有参与计算,因此会对相似度值产生影响.所以使用了这些新API服务的mashup应用并不作为我们的检验数据.因此我们的检验数据集由剩下的55个mashup应用构成.我们按照3.3.1节介绍的方法对这新增的55个服务进行自动分类,然后将自动分类的结果与手工分类的结果进行对比,我们发现55个mashup应用中,其中48个分到了正确的类别中,只有7个mashup应用的分类错误.可见LFH方法对新增mashup应用的分类具有很好的效果.4.3API服务推荐通过解析所获得的数据,我们构建了所有Page11mashup应用和API服务之间的SOS2S(mashup是SOS、API是服务).如图8所示,其中圆形节点对应mashup应用(共5115个),方形节点对应API服务(共750个),两类节点间的边代表mashup应用使用API服务的关系.图9表3度数中心度top-10的mashup和API服务mashup应用mashup应用mashup应用mashup应用SociotocoSearchmashup应用mashup应用mashup应用ConnectorLocalmashup应用mashup应用MapsShownToMe21mashup应用API服务API服务API服务API服务API服务AmazoneCommerce358API服务API服务API服务MicrosoftVirtualEarth173API服务API服务通过对SOS2S作投影操作,可以得到SOS2S相应的S2(如图10).S2包含750个节点,9415条边,我们使用度数中心度指标DC来分析该SOS2S的结构特征.图9显示了具有某一度数中心度的mashup应用和API服务的数量.可以发现,大部分mashup应用具有较小的度数中心度(80.1%的mashup应用的度数中心度仅为1和2),只有1.1%的mashup应用度数中心度大于10,平均每个mashup应用度数中心度仅为13.8.这说明大部分mashup应用仅由少量的API服务组合而成.与此同时,大部分的API服务具有较小的度数中心度(50.7%的API服务度数中心度仅为1和2),只有17.9%的API服务度数中心度大于10,平均每个API服务的度数中心度为9.5.这说明大部分API服务仅参与了少量的mashup应用.度数中心度最大的10个mashup应用和API服务(平台API服务)如表3所示.由97个弱连通子图构成,其中最大的弱连通子图有651个节点,最小的子图节点数仅为1(孤立点).节点边上的标签是该节点所属分类的一个标识符.为了使图显示的清晰,我们忽略了每个节点对应API服务的名称.Page12为了检验本文构建的S2是否有意义以及API服务推荐方法是否有效,我们仍然使用4.2.2节收集的55个mashup应用进行验证.在这55个mashup应用中,mashup应用使用的API服务的个数从1(如ColorPal)到20(如TheMusicFeed)不等,但98.2%的mashup应用其使用的API服务个数仍在10个以内.SRA按3种使用场景进行推荐,使用场景不同,推荐过程存在差异.这里我们以每个mashup应用使用的API服务集合作为SRA的输入,看S2中是否存在一条仅包含这几个服务的路径,以此作为检验S2和算法有效性的标准.我们发现,在这55个mashup应用中,仅RhythmandBluesmashup这个mashup应用对应的MTV,GoogleCustomSearch两个API服务在S2中找不到一条仅包含这两个服务的路径,其余的54个mashup应用中,它们每个mashup使用的API服务集合在S2中都有一个仅包含这几个API的路径与之对应,这说明推荐SRA确实可以通过S2为用户推荐有效的API服务,以简化mashup应用的构建.5应用及工具开发S2R2(SoftwareServiceRegistryandRepos-itory)①是武汉大学研发的一个语义互操作性软件服务注册管理平台.该平台通过研究互联网上软件服务的基础理论与方法、技术标准,开发实现软件服务资源管理与服务的基础设施平台及其关键技术,提供一个统一的软件服务注册管理平台,有效管理各种已注册软件服务,方便用户找到所需服务.以这一平台为基础,建立软件服务开发的基础设施,改善软件服务质量,同时,推动面向服务的软件开发新技术的应用,实现软件服务资源的交流与共享.目前该平台主要由服务(Web服务、mashup应用、API服务等)注册子系统、服务管理子系统、本体注册管理子系统和语义查询子系统4个部分组成(如图11所示).S2R2系统的详细描述请见文献[36].我们已经将LFH方法应用于mashup应用注册和API服务查询2个模块中,提供对mashup应用和API服务分类以及API推荐的支持.当用户通过S2R2平台注册一个mashup应用时,在输入该mashup应用使用的API后,后台程序会通过算法2为其推荐可能的类别.图12(a)显示的是注册mashup应用Localley②时,在输入Facebook、GoogleMaps和Twitter后,为其推荐“社交网络”类别的例子.当用户在某个mashup应用开发平台中开发mashup应用时,当通过S2R2平台查询一个或多个API服务时,S2R2也会按照算法3推荐若干可与已有API服务组合的API服务,并以列表和网络图两种方式显示给用户.图12(b)对应场景1,即在用户还未选择任何API服务时,为其推荐平台API服务的情形.图12(c)对应场景2,即在用户已输入一个API服务23时,为其推荐可以组合的其它API服务的情形.图12(d)对应场景3,即在用户输入API服务23和GoogleMaps时,为其推荐可组合API服务路径的情形.LFH方法提供了一种利用历史信息从结构角度挖掘知识的方法,虽然本文以API服务和mash-up应用为载体来进行说明,但是只要有SOS,可以获得服务和软件之间的这种构成关系,我们就可以用LFH方法来对服务和软件(大粒度服务)进行分类,并进行服务的推荐.本文提出的服务分类方法可以用于服务注册管理系统中,为服务提供分类信息,提高服务发现、检索以及服务资源管理的效率.与此同时,目前服务组合中服务的可组合关系往往是根据服务间的输入输出来进行判断的,本文提供了一种从结构角度挖掘服务组合关系的方法,为服务组合开辟了新的思路.SOS2S可以推广至一般的SOS和服务之间关系的网络,从而可以让我们获得一些知识,如软件是如何使用服务的、服务是如何在不同的软件中使用①②Page13图12功能示例图的、多个软件如何使用相同的服务等.这些知识包含了一些服务使用的正确经验,可以作为推荐系统的一部分,从而指导面向服务的软件的开发.SOS2可以推广至SOS之间的网络,从而为我们提供了一种基于关系的软件查找方式.我们借助SOS构成的网络来查找功能相似的软件,从而为用户提供多种选择可能.同样的,S2也可以推广到一般的服务网络,可以帮助我们挖掘服务之间可能的组合关系,并可以通过图的遍历推荐潜在的服务组合方案,也就是潜在的SOS,从而为SOS的开发提供支持.因此,本文提出的LFH方法对于服务的管理、查找、推荐和自动组合都有一定的意义,可以为实现SOS开发提供部分支持.6结论与展望本文利用服务组合历史信息,用软件网络抽象面向服务软件,提出了从拓扑结构角度实现服务分类和推荐的LFH方法:利用软件网络上的复杂网络社区发现实现服务的自动分类,这对于服务组织管理具有重要意义;利用软件网络刻画服务之间的可组合关系,并基于该网络实现服务的推荐,为服务组合提供了新思路.最后,本文以ProgrammableWeb上mashup应用和API服务的真实数据为载体进行实例研究,在说明LFH方法具体实施过程的同时验证了其可行性和有效性.本文方法在服务的管理、查询、组合等方面都具有较好的应用前景.下一步我们将考虑如下研究工作:(1)本文构建的S2中有很多边其实是无效的,我们将利用服务的其它信息(如输入、输出等)对服务进行二次匹配,尽量减少无效边的数量,提高服务推荐的准确度;(2)本文构建的SOS2尽管考虑了标签的作用,但是语义信息的利用仍不足,我们拟利用服务的描述文档,将文档之间的相似性也加入mashup应用之间相似度的计算中;(3)本文最后以ProgrammableWeb上mashup应用和API服务的真实数据验证LFH方法的有效性,我们拟用其它类型的服务和基于服务的应用来验证本文方法的有效性.
