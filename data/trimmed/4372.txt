Page1一种基于虚拟基本块和格式化标签的控制流检测方法李建立1),2)谭庆平1)谭兰芳1)徐建军1)1)(国防科技大学计算机学院长沙410073)2)(中国电子系统设备工程公司研究所北京100141)摘要空间辐射环境中,大量的宇宙射线经常导致星载计算机出现瞬时故障,这些故障的主要影响之一是引发程序控制流错误.文中提出了一种软件实现的控制流检测方法CFCAF.CFCAF基于插入虚拟基本块后的控制流图对基本块分类,并为基本块设计格式化标签,然后在基本块内插装标签更新、比较指令,实现对基本块之间、基本块内和过程间调用的控制流检测.CFCAF的特点是可以根据可靠性和性能的需求进行灵活配置.对CFCAF及目前有代表性的两个同类算法进行的故障注入实验结果表明,CFCAF算法以平均41.7%的性能代价和平均34%的空间代价,使程序的平均失效率降到了5.2%,在3个同类算法中,CFCAF算法具有较低的时空开销和最高的可靠性.关键词瞬时故障;控制流错误;虚拟基本块;格式化标签;故障注入1引言空间环境中,大量的宇宙射线经常导致星载计算机出现瞬时故障.瞬时故障虽然持续时间很短,但却有可能导致灾难性后果.我国1990年发射的“风云一号”气象卫星就是由于瞬时故障造成了姿态控制系统失效,使得卫星提前退役[1].瞬时故障出现的概率既与宇宙射线的强度有关,又与芯片晶体管密度、门阀电压等有关.近年来随着处理器逐步采用纳米级制造工艺,在处理器性能得到大幅度提高的同时,由于集成电路特征尺寸的减少、晶体管密度的增加、电源电压的降低和频率的升高,使得处理器对于造成瞬时故障的各种噪声干扰变得更加敏感[2].针对瞬时故障,现有的故障检测方案可分为硬件方案和软件方案.其中硬件方案主要通过重复设置硬件电路来实现检错,如三模冗余技术(TripleModularRedundancy,TMR)[3],或者通过设置专门的硬件检错电路来实现,如看门狗技术(Watchdog)[4-5].传统的硬件方案需要修改硬件体系结构,使成本和开发周期都大大增加.斯坦福大学可靠计算中心(CRC)和美国宇航局喷气推进实验室(JPL)合作开发了ARGOS[6-7]项目,该项目提出一种软件实现的硬件故障容忍技术(SoftwareImplementedHardwareFaultTolerance,SIHFT)[8],太空实验的结果表明,该技术利用软件的方法使基于商用现货(CommercialOff-The-Shelf,COTS)的系统达到了与采用硬件容错方案的抗辐照芯片相近的可靠性,同时使系统性能提高了一个数量级.相比硬件故障检测技术,基于软件的故障检测技术无需对底层硬件进行修改,可以在现有硬件基础上以尽可能低的成本提高其可靠性,而且还具有低功耗、可灵活配置等优点.计算机程序运行是构成程序的指令序列按照预定顺序执行的过程,其中正确的执行顺序即控制流是程序正确执行的基础,如果控制流出现错误,则程序很可能得到错误的结果.发生在程序计数器(PC)、存储空间、地址计算单元等位置的瞬时故障可能导致跳转指令的跳转目标错误,还可能破坏指令操作码,将非跳转指令修改为跳转指令或者将跳转指令修改为非跳转指令.现有的针对控制流错误的软件检测技术大多是采用标签分析的方法,其基本原理是:在编译时将程序划分为基本块,并为每个基本块分配不同的静态标签,程序运行时根据当前控制流计算出一个动态标签,通过比较动态标签和静态标签是否一致来确定控制流是否出错.基于标签分析的控制流检测方法在程序内部插装少量的指令,可以检测出绝大部分的控制流错误.文献[9]中提出的CFCSS算法是采用标签分析方法的典型算法.CFCSS只需在编译时为基本块分配静态标签和标签差量,然后在基本块首部插入少量检测指令即可检测控制流错误,但算法存在不少检测盲点:由于CFCSS算法只在每个基本块首部插入检测指令,所以算法无法检测出从一个基本块内部到下一个基本块首部的错误跳转;另外,控制流错误不仅可能表现为基本块之间的控制流错误,也可能表现为基本块内和过程间调用的控制流错误,CFCSS算法只能检测出基本块之间的控制流错误.文献[10]中提出的RSCFC算法是基于标签分析的另一个典型算法.RSCFC首先设计了一种特殊格式的关系标签,并将基本块间的控制流关系编码进了关系标签中,然后在基本块的首部和尾部分别插装标签的更新、比较指令.RSCFC算法相比CFCSS算法明显提高了故障检测率,但是算法插装的指令较多,性能开销较大.另外,RSCFC算法用标签中的1位对应表示1个基本块,标签能够表示的块数受限于机器字长,在32位体系结构下,RSCFC算法的关系标签仅能表示31个基本块(有1位被算法保留使用).尽管RSCFC可以在基本块数大于31时将基本块分组,然后在组间和组内嵌套应用算法检测机制,但这无疑会使算法的性能代价增加很多.其他控制流检测算法[11-16]的基本原理与CFCSS或RSCFC相似,不同算法的区别主要体现在标签设计和插装的指令.而且总体上来说,这些控制流检测算法都存在性能和可靠性平衡问题.我们此前基于改进RSCFC算法提出了ECCFS[17]算法,该算法基于基本块分类设计格式化标签,使标签所能表示的基本块数目比RSCFC有明显增多,算法的检测能力也有所提高.但是ECCFS在程序基本块分类较多时,标签表达能力有明显降低,算法的性能也需要进一步提高.为了克服已有算法的不足,以较低的性能代价获得更好的故障检测能力,本文提出了一种基于虚拟基本块和格式化标签的控制流检测算法CFCAF(ControlFlowCheckingbasedonAbstractbasicblockandFormattedsignature).首先通过在控制流图中插入虚拟基本块,并基于新的控制流图为基本块设计格式化标签,CFCAF有效解决了RSCFC标签表达能力弱的问题.然后通过在基本块内插装标签检测指令,CFCAF以较小的时空开销实现了对基本块之间、基本块内和过程间调用的控制流检测.CFCAF的实现还是可配置的,用户可根Page3据性能和可靠性的需求灵活调节.本文第2节详细介绍CFCAF算法的设计,包括基于基本块分类的标签设计、基本块间的控制流检测、基本块内及过程间的控制流检测;第3节对CFCAF的故障检测能力进行分析;第4节研究CFCAF在RISC平台下的实现优化方法;故障注入实验的结果及比较分析则在第5节给出;最后在第6节总结本文工作.2CFCAF算法2.1基于基本块分类的标签设计基本块的定义为:程序中能够顺序执行的指令序列的最大集合,这组指令只有一个入口和一个出口,入口就是第一条指令,出口就是最后一条指令.基本块中除了最后一条指令可能是转移指令外,其他指令都不能是转移指令.用V={v1,v2,…,vn}表示基本块的集合,用E={brij|brij代表从结点vi到结点vj的跳转}表示基本块间跳转关系的集合.这样,一个程序就可以用一个控制流图P={V,E}表示.如图1所示为一个指令序列及其控制流图.在一个控制流图中,若边集E中存在一条从结点v1到v的边,则称结点v1为结点v的前驱结点.若集合E中存在一条从结点v到v2的边,则称结点v2为结点v的后继结点,并且若v2的存储空间同时紧接在v后面,则称结点v2为结点v的直接后继结点,而结点v为v2的直接前驱结点.若程序沿着brij表示的控制流方向执行,但brij图2基本块分类示例为了分析基本块的这种分类冲突关系,需要基于控制流图导出冲突图[17]:冲突图是无向图,冲突图中的结点和控制流图相同,若两个结点在控制流图中有共同的前驱结点,则这两个结点在冲突图中有一条边连接.图3(a)即为图2(a)中控制流图对应的冲突图.冲突图中的边代表了基本块分类时的互斥关系,即一条边连接的两个结点不能分为同一类.可以直观地认为,如果冲突图中不含3阶完全子图,则可基于冲突图将基本块分为两类,否则就会出现并不在边集E中,则说明程序运行发生了控制流错误,brij是非法跳转.由程序汇编代码生成的控制流图中:若一个基本块B最后一条指令是无条件跳转指令或者不是跳转指令,则B只有一个后继结点;若B最后一条指令是条件跳转指令,则B有两个后继结点,且其中一个是其直接后继结点.所以在程序不存在过程调用的前提下(程序存在过程调用的情形将在2.4节讨论),每个基本块最多有两个后继结点.因此可以根据基本块间的前驱后继关系将基本块分为两类,即将拥有共同前驱结点的后继结点分为不同的类别.但是在一些特殊情形下,无法直接将基本块分为两类.如图2(a)所示,v4和v5有共同的前驱结点v1,v5和v6有共同的前驱结点v2,因此可以将v4、v5和v6分别归为1类、2类和1类,但是v4和v6又有共同的前驱结点v3,此时v4和v6的分类出现了冲突.分类冲突.定义不含任何指令的空基本块为虚拟基本块.CFCAF针对冲突图中的3阶完全子图,任取其中一个结点,并在该结点和其直接前驱结点之间插入虚拟基本块,对加入虚拟基本块后的程序分析可以得到新的控制流图,而新的控制流图中的结点即可分为两类.如图2(b)所示,假设v4的直接前驱结点是v1,则可以在v1和v4之间插入一个虚拟基本块vabb,得到新的控制流图.基于新控制流图的冲突图如Page4图3冲突图示例图3(b)所示,通过插入一个虚拟基本块vabb消除了3阶完全子图.基于新的冲突图的标签分类结果如图2(b)中所示.CFCAF分别为1类和2类结点分配不同格式的静态标签Sl和Sh.静态标签是每个基本块的唯一标识.在32位体系结构下,标签Sl和Sh均设计为16位,其中高k位为保留位(2k<16),且保留位的最高位均固定为0,Sl的保留位最低位为0,Sh的保留位最低位为1.保留位的数据取决于检测机制的需要和k的取值,我们以k值取2为例说明标签设计和算法的原理.根据如图4所示的格式设计,当k值取2时保留位Sk为二进制码00,Sk为二进制码01.CFCAF还要为每个基本块分配一个路由关系标签L,保存其后继基本块的信息.如图4(c)所示,L标签低16位是1类后继基本块的静态标签Sl,高16位是2类后继基本块的静态标签Sh,因为程序的基本块被分为两类,所以程序的控制流信息都可以嵌入到L标签中.按照图2(b)中的基本块分类,若保留位数k=2,静态标签Sabb、S4、S5、S6可分别设计为十六进制码0x4007、0x4、0x5、0x4006,则v1的L标签为0x40070005,v2的L标签为0x40060005,v3图5基本块间控制流检测示例的L标签为0x40060004,虚拟基本块vabb只有一个1类后继基本块,所以其L标签为0x4.RSCFC算法在32位体系结构下,其标签只能表示31个基本块.而CFCAF的标签在保留位数k=2时则可以表示(215-1)个基本块,可以满足大部分应用的需要.对于少数超出标签表达能力的程序,可以将程序的基本块分为不同的区域,为每个区域分配区域码后,在区域首部向特定存储空间写入区域码,然后在区域尾部取出该数据和预定的区域码比较,即可实现区域间的控制流检测,在区域内部则可以嵌套应用CFCAF方法.2.2基本块间的控制流检测CFCAF使用通用寄存器G和P专门保存动态标签和路由关系标签,并利用插装到每个基本块的标签更新指令不断地更新动态标签,然后利用每个基本块中插装的比较检测指令判断动态标签是否和当前基本块的静态标签相同,如果相同则认为程序控制流正常,程序继续执行,否则认定程序控制流遭到破坏,跳转到错误处理程序.对图2(b)中的部分基本块插装指令后的结果如图5所示,指令#1、#2被插入到基本块首部,指令#3、#4被插入到基本块尾部,如果基本块最后一条指令是跳转指令,那么指令#1、#2、#3、#4还要插在跳转指令之前,图中基本块尾部的虚线框表示基本块最后一条指令可能是跳转指令.Page5指令#1和#2是动态标签更新指令,在程序正确执行时,可以将G中的数据更新为当前块的静态标签.指令#1通过和掩码0xffff进行按位与操作取出存放在P中低16位的静态标签,指令#2则通过逻辑右移16位取出存放在P中的高16位静态标签,所以指令#1和#2要分别插入到1类块和2类块的首部.指令#3将P中的值更新为当前块的路由关系标签.指令#4比较动态标签是否和当前块的静态标签相同,如果相同则程序继续往下执行,否则跳转到错误处理程序.图5中G和P的初始值分别是0和0x1,基本块v1执行结束后,G和P的值分别被更新为0x1和0x40070005.如果v1沿着合法跳转1继续执行,则在v5首部G被更新为0x5,指令#4判断出G的值和v5的静态标签相同,因此可以确认程序跳转正确;如果v1沿着非法跳转2执行,则在v4首部G被更新为0x5,指令#4判断出G的值和v4的静态标签不同,因此可以确认程序跳转错误.2.3基本块内的控制流检测所谓基本块内的控制流错误是指在同一个基本块内部,控制流从一条指令跳到另一条指令.出现这种现象的主要原因是PC寄存器遭到破坏,或者指令操作码遭到修改,使得普通指令变成了跳转指令.一般情况下,程序出现这种错误的概率很小,但对于一些数据处理程序(如矩阵乘法),程序内部的部分基本块可能包含很多条指令,对这种程序进行基本块内控制流检测就十分必要.目前能够检测基本块内控制流错误的算法不多.文献[18]中引入了一个局部标签,并在基本块内部插入一些针对局部标签的加法操作,最后进行比较检测.不发生块内控制流错误的情况下,局部标签累加的结果应该为0,否则可以断定存在块内控制流错误.这种方法加强了对块内控制流的检测,但插入的指令较多,并且需要专用一个寄存器保存局部标签,这就意味着更高的存储开销和性能开销.CFCAF结合我们此前在文献[19]中提出的方法,以更低的性能代价实现了块内控制流检测.为了实现块内控制流检测,CFCAF需要为1类和2类基本块新分配一个入口标签Sl和Sh,除了保留位外,入口标签的其他位和同一基本块的静态标签相同.新的基本块路由关系标签L中则嵌入后继基本块的入口标签.入口标签的保留位设计和k的取值有关,我们以k取2为例说明标签设计和块内控制流检测的原理.如图6所示,Sl的保留位设计为二进制码11,Sh的保留位设计为二进制码10.如图7所示,基于新分配的标签,CFCAF在基本块中部新插入指令#5、#6,指令#5利用异或操作将G的最高两位取反,指令#6通过减法操作将最高两位数值减去1.而指令#3则修改为将新的路由关系标签L存入P中.基于这些指令,当基本块内控制流正常时,指令#1或#2将动态标签G更新为当前块的入口标签,基本块中部的指令#5或指令#6则通过修改保留位将G值修改为当前块的静态标签,最后指令#3和#4更新路由关系标签,并将G和静态标签比较,从而判断出不存在块内和块间控制流错误.当发生跳过#5或#6的块内控制流错误后,动态标签在基本块尾部的值仍为入口标签,因此可以通过比较判断出控制流错误.CFCAF在基本块间控制流检测的基础上,通过在标签中保留一些位和在基本块中部插入一些指令即可实现块内控制流检测,这种检测机制不需要额外占用寄存器和插装较多的指令,因此其需要的时空开销比较小.另外,这种方法还可以根据性能和可靠性的需要灵活配置.首先可以通过设置保留位数k,控制可以插入到基本块中部的最大指令数量,进一步增强算法对块内控制流的检测能力,例如k=3时,可以设置1、2类块的静态标签保留位分别是二进制码010和011,设置1、2类块的入口标签保留位分别是二进制码000和101,并在1类块中部等间距插入两条加法指令,每条指令将保留位加1,在2类块中部等距离插入两条减法指令,每条指令将保留位减1,这样即可加强对块内控制流的检测;另外在k值确定的情况下,根据基本块的大小不同,还可以灵活选择在基本块中部插入的指令数量,例如在上述k=3的情况下,可以将1类块中部的两条减1指令合并为一条减2指令;如果一个基本块Page6不需要块内控制流检测,则可以选择不实现块内检测机制,此种情况下只需将其静态标签而不是入口标签嵌入其前驱块的路由关系标签中即可.2.4过程间的控制流检测过程间的控制流检测问题较基本块之间的控制流检测更为复杂,现有的大多数控制流检测算法并不将过程间调用作为划分基本块的依据,实际上是忽略了这个问题.少数控制流检测算法虽然实现了过程间的控制流检测,但存在不少漏洞,例如文献[16]中提出的SIED算法在被调用函数头部设置一个函数标签,然后在函数返回后通过比较标签是否一致判断是否存在过程间调用错误.但是,当对一个函数存在多次调用时,如果函数返回点出现了混淆,算法则无法检测出错误.CFCAF算法通过改进基本块分类方法和插装部分新指令,可以有效地检测过程间的控制流.CFCAF将函数调用也作为划分基本块的依据,并且所有的基本块一起分配标签.由于一个函数可能被多次调用,所以函数返回指令所在的块可能会有多个后继基本块.因此在进行2.1节的基本块分类时,需要先将控制流图中代表函数返回的边屏蔽,即不考虑函数的返回关系.CFCAF还需要对部分基本块的插装指令进行改进,如图8所示,除了图中列出的指令外,CFCAF在基本块中其他位置插入的指令不变.CFCAF在函数调用块中新插入1条标签更新指令#7,指令中的标签Lexit只嵌入了本次函数调用块对应返回块的静态标签.被调用函数的入口块中插入了指令#8,将G中的Lexit保存在被调用函数的堆栈空间中.被调用函数的出口块则利用指令#9从堆栈中弹出Lexit到P中.由于每次函数调用时已经将对应返回块的静态标签信息保存,所以CFCAF可以克服SIED的问题.CFCAF也可以处理嵌套、递归等复杂的情况.CFCAF利用函数的堆栈空间保存信息,不需要额外的寄存器,这种方法不会带来明显的存储压力.另外这种方法只多插入了2条指令,所以性能开销也比较小.3CFCAF检错能力分析由于空间环境中瞬时故障发生的概率很小,所以可以假设程序一次运行过程中最多只发生一次单粒子翻转,而程序运行时也至多发生一次控制流错误.另外,CFCAF无法检测数据流错误,因此对于由于条件跳转的“条件”数据错误引起的跳转错误,需要结合数据流检错算法检测,这里不加讨论.首先分析CFCAF对块内和块间的控制流错误检测能力.针对不同类别的基本块,CFCAF在其不同位置共插入了6条指令#1~#6实现对块间和块内的控制流检测(假设块内检测机制只插入1条指令).这6条指令将基本块分成了不同的区域,定义r(#n)为指令#n到同一个基本块内的前一条插装指令之后的区域,例如r(#1)包含指令#1,r(#5)包含指令#5以及指令#1和指令#5之间的指令.用#x→#y表示在执行区域r(#x)的某条指令之前,控制流直接跳转到了区域r(#y)中的指令,则除了控制流跳转到程序空间之外的情况,所有的控制流跳转都可以表示为一个区域到另一个区域的转移.而对于控制流跳转到程序空间之外的情况,底层硬件机制或操作系统一般可以检测,这里不作讨论.如表1所示,表中列举了源基本块Vsource到目的基本块Vsink跳转的不同情形,并分为了源、目的基本块相同和源、目的基本块不同两类,另外表中组合还暗含了目的基本块是合法后继和目的基本块不是合法后继两种情形.表1中用“”表示该种控制流错误可以被算法检出.如Vsource≠Vsink时的#5→#3错误,即程序执行完#1后跳过了#5,因为G中保存的入口标签没有被指令#5更新为静态标签,所以在执行指令#4时,可以检测出控制流错误.再如Vsource=Vsink时的#2→#6错误,即控制流从前驱块的尾部直接跳到了指令#6,因为此时的G中保存的是前驱块的静态标签,其保留位只可能是00或01,因此执行完#6后,保留位会变为11或00,而2类块的静态标签保留位是01,所以执行到指令#4时,可以检测出这个控制流错误.Page7表1CFCAF检测能力分析source#1#2#3#4#5#6#1×-----#2×-----#3××-×-×××--#4×××-×-----#5×-×-×-#6×--×-×表1中用“×”表示该种控制流错误会被算法漏检.如Vsource≠Vsink时的#4→#1错误,即源基本块的#3执行后,控制流跳转到了目的基本块的首部,当目的基本块是源基本块的合法后继时,由于P中含有目的基本块的入口标签,所以目的基本块中的标签更新、检测和控制流正常时一样,算法会误判控制流正常.而Vsource=Vsink时的#5→#5错误,即#1和#5之间小区域内的控制流错误,因为不会影响标签的更新,所以同样无法被算法检出.这类错误是算法块内控制流检测机制的主要盲点.表1中的“-”则表示此类控制流错误不可能发生、不会影响程序的结果,或者利用操作系统或底层硬件的超时机制可以检测出来.如Vsource=Vsink时的#1→#4错误,当目的基本块是合法后继时,此错误即执行完指令#4后,再次重复执行指令#4,这种错误不会影响程序结果.若基本块内的一个错误跳转是逆向的,而且这个错误是由于静态的代码空间被修改导致的,那么程序运行就会出现死循环,必须利用操作系统或底层硬件的超时机制检测.例如Vsource=Vsink时的#3→#6错误就是这类错误的典型.从表1中可以看出,算法不能检测到的块内和块间控制流错误只占少数.这些错误主要表现为:(1)目的基本块和源基本块有共同的前驱块且源基本块只有一个前驱块;(2)目的基本块恰好是源基本块的后继;(3)被插装指令分割出来的小区域内部的控制流错误.对于前两类错误,根据直观理解,可以确定其发生的概率是很小的.而最后一类错误发生的概率则与算法在基本块中部等间距插入的指令数量有关.一般情况下,插入的指令数量越多,这类错误发生的概率就越小,但算法的性能开销也就越大,这就需要充分利用算法的可配置性.现在讨论CFCAF算法对过程间控制流的检测能力.CFCAF算法为了检测过程间的控制流,在相关的基本块中新插入了指令#7、#8、#9,这些指令对基本块同样有分割作用,因此这种机制的可靠性分析和前述检测能力分析方法类似.分析的结果表明,除了一些极端情况下的控制流错误无法检测外,算法同样能检测出绝大部分的过程间控制流错误.出现的检测盲点包括:程序执行完函数调用块的指令#7后,直接跳到了返回块的指令#3,并且返回块是1类块,此时由于G中保存的就是返回块的静态标签,所以这种错误无法被算法检出;类似的盲点是控制流在指令#8执行后跳转到指令#3,发生漏检的原因和上述情况相同.假设程序指令数量为N,函数返回块划分为1类块的概率为1/X,X1,则上述情况发生一次的概率为1/(X×N×(N-1)),因此这种错误发生的概率是极小的.总结来说,CFCAF对过程间控制流的检测机制是可靠的.4基于RISC的实现优化CFCAF作为一种汇编级的检错算法,其性能及可靠性不可避免地会受到底层体系结构的影响.目前,RISC体系结构因其简单高效而被中、高档服务器和嵌入式平台普遍采用,因此我们重点研究了算法在RISC平台下的实现.如图9所示,我们以RISC家族的MIPS32指令集说明算法的基本实现.图9中的指令分别是图7中对应位置操作的实现,需要说明的是#4是立即数条件陷入指令,实现的功能是比较G和静态标签S,若不相等则陷入异常,执行用户定义的错误处理操作.用这条指令实现#4的好处是可以节省1个寄存器和少插入1条指令,并且提高了算法的可靠性.原因是MIPS下的比Page8较指令不支持立即数操作数,需要先把立即数加载到通用寄存器再进行比较操作.另外需要指出的是,RISC32的大部分立即数操作指令只支持16位立即数,当立即数大于16位时,就需要先用2条指令将立即数加载到寄存器中再进行操作.如图9中的指令#3,li指令是编译器支持的伪指令,当标签数据L大于16位时,li在程序链接时会转换成2条其他指令来实现,如指令“liP,0x80012003”就会被转换为指令“luiP,0x8001”和“oriP,0x2003”,其中,第1条指令为加载后移位指令,第2条指令为按位或指令.因此,RISC下的立即数操作数大于半字时,即意味着要额外插入1~2条指令处理立即数,甚至还需要再占用一个寄存器.CFCAF由于标签设计的特点,在RISC下实现时,除了指令#3可能会转换成2条指令外,其余指令都不需要再插入指令处理立即数.因此在只实现基本块间控制流检测的前提下,CFCAF在每个块内只需要插入3~4条指令,且整个算法实现只用到2个通用寄存器.由于使用32位标签,CFCSS算法则需要插入3~7条指令,并使用2~4个寄存器.即便不考虑程序基本块数大于31个时使用嵌套机制额外插入的指令,RSCFC算法仍需要在每个块内插入6~9条指令,使用1~2个寄存器.CFCSS算法同样可以限制标签为16位,降低时空开销,但本身已受限于机器字长的RSCFC算法却无法这样优化.CFCAF虽然因引入虚拟基本块而额外插入一些指令,但绝大部分程序不需要或者只需要插入少量虚拟基本块,综合考虑,仍然可以认为CFCAF在RISC下是一种比较高效的算法.5实验结果及分析我们在RedHatLinux9.0下使用模拟器SimpleScalar[20]对CFCAF进行故障注入实验.SimpleScalar是目前学术界最为流行的体系结构模拟器,其开发工具集可以配置成许多不同体系结构的模拟器,如PISA、Alpha、PowerPC和x86等.其中,PISA指令集是一种类似MIPS的RISC指令集,也是我们实验使用的指令集.实验采用了矩阵乘法MM(20×20的矩阵)、冒泡排序BS(随机选取的20个整数)、斐波那契FIB(计算第20项斐波那契数)和PI程序(蒙特卡罗法求π值)4个基准测试程序作为测试用例.为了比较CFCAF和同类算法在开销和检错能力方面的差别,我们还选取了CFCSS算法和RSCFC算法一同进行故障注入实验.5.1CFCAF时空开销评估由于程序在不同平台下的执行时间大不相同,况且不同的源程序采用控制流检测技术后的代码大小和执行时间也迥然不同,所以表2中只给出了应用检错算法的程序和源程序时空开销的比值.开销程序MM1.1261.2851.1411.3401.5201.293BS1.3101.6611.3611.4451.6471.387PI1.2881.6591.3471.3051.4761.316FIB1.7272.5901.8181.3761.4941.365平均1.3631.7991.4171.3671.5341.340从表2中可以看出,相比其他算法,CFCSS算法的性能开销是最小的,平均为36.3%,这一方面是因为CFCSS的检测机制比较简单,插装指令较少,另一方面则是因为测试程序较小,我们将其标签限制在了16位.CFCAF的性能开销是可调节的,实现时可以根据需要配置是否实现块内或过程间检测机制,对块内检测机制,同样可以根据块的大小进行配置.我们对CFCAF的基本块内控制流检测机制进行了精密配置,当基本块长度Len<3时不插入块内检测指令,当2<Len<10时在基本块中部插入1条指令,而Len>9时则在基本块中部等间距插入两条指令,最终算法的性能开销平均为41.7%,只比CFCSS算法略有增加.尽管因为程序规模小,不需要应用嵌套机制,但由于第4节分析的原因,RSCFC算法的性能开销仍然是最大的,平均达到了79.9%.在3个算法中,RSCFC算法的空间开销也是最大的,而由于加载标签数据的指令li是伪指令,执行时可能会转换为两条指令,所以CFCAF的空间开销比CFCSS略小,但其性能开销却比CFCSS大.5.2CFCAF检测能力评估我们通过改造SimpleScalar代码实现故障注入的实验结果统计,因为在SimpleScalar的程序中可以直接获得或修改系统的状态信息,如寄存器数据、系统时钟、指令地址和操作码,以及系统异常等,所以改造SimpleScalar的程序可以使我们方便地注入故障(修改PC寄存器或者指令操作码等),也可以帮助我们区分出不同的运行结果.实验针对每次程序运行注入1位翻转,注入的位置包括PC和代码存储空间(MEM).PC故障在程序运行时动态注入,即在随机时刻随机翻转PC寄存器中的一位.MEM故障则通过静态注入实现,即在程序运行前向代码Page9段注入一位翻转故障,注入这类故障的目标包括:修改跳转指令的操作码为非跳转指令;修改非跳转指令的操作码为跳转指令;修改跳转指令的目标地址.每个版本程序进行2100次故障注入实验,其中注入PC和注入MEM的比例为16.注入的故障按程序运行结果可以分为5类[17]:(1)Correct.注入的故障未影响程序结果,程序正常结束且结果正确;(2)Wrong.故障未被发现,程序正常结束但结果错误;(3)Exception.注入的故障导致异常被系统检出,如地址访问越界、指令无法解析等;(4)Timeout.故障导致的程序死循环、挂起等引发超时;(5)Detected.检错算法检测出注入的故障.由于出现第2类故障时危害较大,并且其他几类故障不影响程序运行或者可以靠各种现有机制检测出来,因此控制流检测算法的主要目标是减少第2类故障,定义失效率表3源程序和CFCAF程序故障注入结果程序结果Correct368567100265633387366294830458621028975891Exception7678715693173182396771764443553463493582Timeout47102023291119201193193154658434093Wrong1411271421213133173892748264571573606812Detected0000000099109154151254206224222表4CFCSS和RSCFC程序故障注入结果程序结果Correct3553555277692278974547633657721920721686Exception7260463760151255362348545829658532648781Timeout221134762326088152172192485760Wrong1281038052911101056510083783385938721Detected43831061122702242932799098111160244207287252空开销接近CFCSS算法的前提下,在3个算法中具有最高的可靠性.通过比较可以发现,检错算法的故障检测率(Detected故障占该类故障总数的比例)在注入PC故障时要明显高于注入MEM故障时,而且注入PC故障时,不同算法的故障检测率差别更为明显,这是由于注入PC故障可以有效地引发控制流错误,而注入MEM故障时,则出现了大量不影响程序运行的故障,因此注入PC故障可以更好地检验算法的检测能力.在注入PC故障时,CFCAF的故障检测率平均为42.8%,明显高于CFCSS的28.7%和RSCFC的38.3%.统计2100个故障中各个版本程序的失效率如图10所示,从图中可以看出,实现了检错算法的程序失效率较源程序均有明显降低,证明算法是有效的,而在不同算法分别应用到同一个程序时,CFCAF算法的失效率总是最低的,平均为5.2%.综合5.1节可以得出结论,CFCAF算法在时(FailRate)为第2类故障占注入故障总数的比例.表3和表4中给出了各个版本程序注入PC故障和MEM故障的结果(表中SourceCode指源程序).从表中可以看出,注入MEM故障时,相对于源程序,实现了检错算法的程序结果正确的次数明显增多.结果正确的可能原因包括:PISA指令集中有大量的保留位,故障注入这些位置不会影响程序运行;注入故障的指令可能在运行时没有被执行;或者注入故障的数据没有被使用,例如修改了条件跳转的目标地址,而实际并未执行跳转.因为实现了检错算法的程序使上述几种因素出现的概率都有所增加,因此结果正确的次数明显增多.注入MEM故障时,实现了检错算法的程序出现异常和超时的次数均有减少,这种现象和结果正确的概率增加有关,也和检错算法在异常、超时前检测出部分故障有关.MMBSPIFIBMMBSPIFIB6结论硬件瞬时故障可以通过修改PC寄存器等方式Page10影响程序正常的控制流,高可靠系统必须具备对程序控制流错误进行检测的能力.本文针对瞬时故障导致的程序控制流错误,提出了一种新的控制流检测算法CFCAF.CFCAF是一种汇编级的容错算法,算法通过为基本块设计格式化标签和在基本块内插装标签更新、比较指令,实现了对基本块之间、基本块内和过程间调用的控制流检测.相比已有算法,CFCAF具有标签表达能力强、时空消耗小、检错能力强和可配置的特点.与目前两个有代表性的算法进行比较的结果表明,CFCAF算法具有较小的时空开销和最高的可靠性.
