Page1数据集成环境下一种高效一致性聚集查询张晓刚1)杨路明2)潘久辉1)1)(暨南大学计算机科学系广州510632)2)(中南大学信息科学与工程学院长沙410083)摘要对于不一致数据库上的一致性聚集查询问题,Fuxman扩展基于合取查询类Cforest的一阶查询重写方法并给出了查询重写算法RewriteCount和RewriteAgg来分别处理包含不同聚集函数的查询.算法产生的重写聚集查询能够使用SQL语句表达,但是其性能却不够理想.文中重点考虑在数据集成环境下如何有效地提高一致性聚集查询的整体性能,通过OR-database集成模式有效地隔离集成数据库的一致性部分和非一致新部分,并在此基础上同样针对合取查询类Cforest上的分组聚集查询提出了基于OR-database的一致性查询重写算法RewriteCount_OR(主要处理Count函数)和RewriteAgg_OR(主要处理Max,Min和Sum函数),后面的查询代价比较及模拟实验都表明:与Fuxman的一致性聚集查询方法相比,文中的一致性聚集查询方法在OR-database集成数据库上具有明显的性能优势.关键词一致性查询;聚集查询;完整性约束;修复;查询重写;不一致集成数据库1引言数据集成[1]的目标是联合一个分布、自治及异构数据源集合的数据并为用户提供它们的统一视图.那么在数据集成环境下,满足各自数据源完整性约束的数据仍可能因违反全局模式的完整性约束而导致集成数据库的不一致.例如,不同数据源记录了同一个雇员不同的薪水和地址而导致信息不一致,而数据集成系统需要为查询用户提供该雇员一致的信息.如何从不一致的数据库中返回一致性的查询结果呢?这就是一致性查询(ConsistentQueryAnswering,CQA)所要解决的问题[2].对此,Arenas等人在文献[3]中首先提出了基于不一致数据库修复的查询重写方法,但是它仅考虑了无量化或无析取的一阶查询及二元完整性约束;Fuxman等人[4]在主键约束下的一阶查询重写上取得重要突破,通过查询连接图定义了一个合取查询类Cforest并给出其一阶查询重写算法,并对Cforest上的聚集查询给出了基于范围语义[5]的一致性查询重写算法RewriteCount和RewriteAgg[6]并被实际应用到ConQuer系统[7]中;Wijsen[8-10]在非一致数据库的一阶合取查询方面也做了大量工作,但主要是在Fuxman的基础上对满足没有自连接和非环条件的布尔合取查询的一阶可表达性进行深入研究,但这样的布尔查询在实际用户查询中很少出现;基于逻辑程序描述修复并通过怀疑推理计算CQA是更一般化的方法[11-13],它能够处理任意的一阶查询及通用完整性约束,其通常需要付出的计算复杂性却达到了ΠP问题是很难和现有商业数据库技术结合而得到广泛的应用;其他关于不一致数据库上聚集查询的研究则主要集中在概率数据库模型方面[14-17]或其他完整性语义约束方面[18-20],它们显然不是本文所要面对的传统数据集成环境.Fuxman的一致性聚集查询可以用SQL语句表达,对于非一致数据库不管是数据源的本地数据库还是集成系统的全局数据库该方法都是适用的,很好地解决了一致性聚集查询重写的可实现问题,但其对不一致数据库实例形成的环境、过程及如何有效提高一致性聚集查询性能等问题没有深入考虑.实际上,数据源数据库由于本地完整性约束机制而产生违反主键约束的情况较少,更多的情况是在数据集成环境下由于缺少全局完整性约束机制而导致非一致集成数据库的产生.对于数据集成环境下CQA问题的解决,可以在数据集成构建时就充分考虑一致性聚集查询如何高效地实现.因此,本文通过OR-database集成模式有效隔离集成数据库的一致性部分和非一致性部分,同样针对合取查询类Cforest上的分组聚集查询提出了基于OR-database集成模式的一致性聚集查询重写算法,并且在给出了重写算法正确性证明之后,通过一致性聚集查询代价分析比较和基于TPC-H基准的模拟实验表明:与Fuxman的一致性聚集查询方法相比,本文的一致性聚集查询方法在基于OR-database的集成数据库上具有更好的整体性能.2OR-database数据集成模式如果用Dom(Ai)表示属性集合U={A1,A2,…,Am}上关系模式R(U)的第i个属性域,则R的关系实例r就是Dom(A1)×Dom(A2)×…×Dom(Am)的一个子集,而一个关系数据库模式是一个关系模式集合Σ={R1,R2,…,Rn},一个关系数据库实例则是Σ上的关系实例集合I={r1,r2,…,rn}.OR-database[21]是定义在包含简单常量和有限可选常量(即OR-object)集合上的非确定性数据库,它代表了一个关系数据库集合,即用确定的域可选常量替换每一个OR-object所获得的确定性数据库实例集合.考虑到数据集成环境下一致性聚集查询重写的实现及效率问题,本文采用如下的关系模式来表示非确定性数据库OR-database.定义1.设ATOMIC常量域Dat和OR-object标识常量域Dor是两个不相交的可数无限常量集合,定义在D=Dat∪Dor上表达OR-database关系数据库模式Σ包含ATOMIC和OR-objects两类关系,每个ATOMIC关系R都存在一个OR-object关系R_or与之对应.如果用Key(x)和Nokey(x)分别表示x的主键及非主键,则Σ的R及R_or应该满足:(1)Dom(Key(R_or))Dor∧Dom(Key(R))Dat;(2)Key(R_or)Nokey(R)∧Nokey(R_or)=Nokey(R)-Key(R_or).关系模式Σ通过OR-objects关系R_or存储对应ATOMIC关系R中出现的OR-objects,即违反主键约束的元组集合,R仅保留一个元组并通过外键引用R_or中的OR-objects,同时设置Nokey(R)冲突属性值为未知.定义2.一个三元组〈Σ,,〉可以形式化的Page3表达一个数据集成系统的数据集成系统需要满足下面3个条件:(1)全局模式Σ是基于OR-database的关系模式,同时包含ATOMIC关系和OR-objects关系.(2)数据源模式是非OR-database的关系模式,仅包含ATOMIC关系.(3)模式映射是扩展Source-to-TargetDependencies(STDs)[22-24]并允许出现谓词递归并可表示为ψΣ(狓,狌):-φ(狓,狔),λΣ(狓,狑)的依赖集,其中ψΣ(狓,狌)和λΣ(狓,狑)都是模式Σ上的原子或原子否定构成的合取公式,而φ(狓,狔)是模式上的任意一阶公式.设s,g分别为数据源模式和全局模式Σ的数据库实例,如果s和g满足模式映射,即对中的每一条依赖规则ψΣ(狓,狌):-φ(狓,狔),λΣ(狓,狑)都有:对任意元组犪,犮如果存在某元组犲使得数据库实例s和g满足φ(犪,犮)∧λ(犪,犲),则必定存在一个元组狏使得数据库实例g满足ψ(犪,狏).例1.存储雇员信息的OR-database数据集成系统=〈Σ,,〉的全局模式Σ={e(ename,sal,or_id),e_or(or_id,sal)},其中的ename和or_id分别是ATOMIC关系e和OR-object关系e_or的主键,并且e通过外键or_id引用e_or中的OR-object;包含两个本地雇员信息数据库的源模式={s1:emp(ename,sal),s2:employee(name,salary)};同样的,下划线属性为关系主键.中映射s1源数据到全局模式Σ的元组依赖规则应包括(1)~(3),这里x,y,z∈Dat∧y≠z,珘o∈Dor,两个特殊的属性值“_”代表未知,而“⊥”代表不确定.(1)e(x,y,_):-emp(x,y),z.e(x,z,_),e(x,⊥,珘o);(2)e(x,z,_)∧e(x,⊥,珘o)∧e_or(珘o,z)∧e_or(珘o,y):-emp(x,y),z.e(x,z,_);(3)e_or(珘o,y):-emp(x,y),e(x,⊥,珘o)3条规则表达了s1的数据如何被集成到全局模式Σ中.其中,(1)表明如果s1的emp存在元组(x,y)并且Σ的e不存在主键为x的其他元组时e中应包含元组(x,y,_);(2)表明如果emp存在元组(x,y)并且Σ中的e存在元组(x,z,_)时e中应用元组(x,⊥,珘o)代替它并且e_or中应包含元组(珘o,z)和(珘o,y);最后的(3)表明如果emp存在元组(x,y)并且Σ的e存在元组(x,⊥,珘o)时e_or中应包含元组(珘o,y).同理,s2到Σ的映射只需把其中的emp改成employee即可,所有规则中未知及不确定属性值在实际商业数据库中可用空值(null)来表示.例如:假设s1的emp包含元组(Jenny,3000)和(Alice,3200),s2的employee包含元组(Jack,2800)和(Alice,3500),那么Σ的e为空时,对s1的元组(Jenny,3000)来说满足规则(1),则元组(Jenny,3000,null)应出现在e中,此时对元组(Alice,3200)来说同样满足规则(1),则e也应该包含元组(Alice,3200,null);这时,对s2的元组(Alice,3500)来说满足规则(2),在e中应该由元组(Alice,null,#1)代替元组(Alice,3200,null)并且e_or应该同时包含元组(#1,3200)和(#1,3500);当然,如果此时数据源还存在另外元组(Alice,4000),那么其显然满足规则(3),此时e_or中还应该包含元组(#1,4000).3OR-database聚集查询的一致性3.1OR-database全局模式的完整性约束完整性约束表达数据语义一致性,DBMS一般通过事务管理维护其有效性,最常用的完整性约束是函数依赖(FunctionalDependency,FD)和包含依赖(InclusionDependency,IND),例如主外键约束.如果属性集X为关系R(U)的主键即Key(R)=X,则主键约束X→U就是一个函数依赖;对关系R(U)和S(V)来说,外键约束R(W)S(Z)就是一个包含依赖,其中WU,ZV并且Z=Key(S).那么,OR-database全局模式Σ上的完整性约束集合定义了来自各数据源的数据应该满足的语义一致性.定义3.OR-database全局关系模式Σ上的完整性约束C仅包括主外键约束,Σ上的集成数据库实例g如果满足C则称g关于C是一致的,记为gC;否则称g关于C是不一致的,记为g/C.定理1.对基于OR-database的数据集成系统=〈Σ,,〉,如果所有数据源实例s关于的主外键约束Cs是一致的,那么Σ上的OR-database集成数据库实例g关于Σ的完整性约束C不一致只需满足下面两个条件之一:(1)设ATOMIC关系Ri存在主键,如果Ri的OR-objects关系Ri_or实例ri不空,则有g/C.(2)设ATOMIC关系Ri的属性A∈Nokey(Ri)是参考ATOMIC关系Rj的外键,如果它们的实例ri和rj满足ri中存在元组t使得t[A]Dom(Key(rj))或Ri的OR-objects关系Ri_or实例ri存在元组t使得t[A]Dom(Key(rj))时,则有g/C.全局关系模式Σ能够表达OR-database,但Σ的集成数据库实例是否是非一致的,关键还是看该Page4数据库实例是否违反了Σ上的主外键完整性约束,而上述定理给出了集成数据库实例g分别违反主外键的条件,定理的证明详见附录.3.2全局模式上聚集查询的一致性回答定义4.设C是OR-database全局模式Σ上的主外键约束,Σ(g)表示Σ的一个集成数据库实例g的元组集,如果g也是Σ的一个实例并且Σ(g)是满足gC的Σ(g)最大子集,则称g是g关于C的一个修复,如果用RepairsC(g)表示g关于C的所有修复,则有g∈RepairsC(g).对OR-database上聚集查询的一致性问题,本文沿用文献[3]基于修复的观点来解决并且获取修复的操作仅考虑元组删除[4,25].OR-database集成数据库实例g的一个修复g就是通过删除g中违反主外键约束的一个最小元组集而获得,即删除每个ATOMIC关系实例中不存在参考引用的元组使其满足外键约束,并删除对应OR-objects关系的一个最小元组集使其满足主外键约束.本文考虑的OR-database全局模式Σ上的聚集查询Caggforest同样是建立在文献[4]提出的合取查询类Cforest之上,并通过扩展分组及聚集操作得到的.定义5.设q是一个聚集合取查询,q∈Caggforest当且仅当它具有如下形式:select狕,[count()|F1(狏1),F1(狏2),…,Fm(狏m)]from[q(狕)|q(狕,狌)]groupby狕这里q是Σ的ATOMIC关系上一个合取查询类Cforest中的查询,狏1,狏2,…,狏m是由狌中变量构成的向量,count()为元组计数函数而F1,F2,…,Fm是向量狏1,狏2,…,狏m上的可能为min,max或sum的聚集函数,称狕为分组变量并称狏1,狏2,…,狏m为聚集变量.这里特别注意,Cforest类的查询q的连接图(joingraph)[4]必须满足是一个森林,所有的非键-键连接是完全连接且不出现重复关系3个条件.另外,在全局模式Σ的ATOMIC关系上执行合取查询q时,如果元组or_id属性值引用OR-objects关系元组,则需要连接OR-objects关系元组以形成连接元组集合代替原始元组.OR-database全局模式Σ上的分组聚集查询q可能因为Σ的集成数据库实例g的非确定性而导致查询结果的不一致性,所以基于修复的Σ上分组聚集查询q的一致性回答语义可以作如下定义.定义6(分组聚集查询的一致性回答).设Σ为一个OR-database全局关系模式,C是Σ上的主外键约束,g为Σ的数据库实例,并设q为拥有自由变量狕和v的聚集查询,这里v可能是由聚集函数计算得来的数值域变量,满足下面三个条件的元组(狋,bgl,blu)被称为是聚集查询q的一致性查询回答,记为(狋,bgl,blu)∈CQAC(q,g),其中bgl和blu分别为狋在q中的最大下界和最小上界.(1)对每一个g关于C的修复g,存在某个d使得(狋,d)∈q(g)并且满足bgldblu.(2)存在某个g关于的修复g满足(狋,bgl)∈q(g).(3)存在某个g关于的修复g满足(狋,blu)∈q(g).4聚集查询重写4.1聚集查询的一致性回答OR-database全局模式Σ上的用户查询可能因为Σ的集成数据库实例g不一致而返回不一致结果,定义5给出了OR-database上聚集查询的一致性语义.基于查询重写计算CQA的最大优势就是无需明确地构建修复,而是通过查询变换获得新的一阶查询并直接运行在不一致数据库上获得与原查询同样预期的结果.用户查询是基于ATOMIC关系,如果ATOMIC关系R中存在元组狋且其外键or_id上的值非空,则其必然引用了非空OR-objects关系R_or中的元组,由定理1可知g不一致.此时的一致性查询重写就需要通过连接ATOMIC关系R及其OR-objects关系R_or获取一致性查询回答.例2.同样存储雇员信息的OR-database全局模式Σ={emp(ename,dept,sal,or_id),emp_or(or_id,dept,sal)},C是Σ上的主外键约束,其中下划线字段为关系主键,不同关系中同名的非主键属性与主键属性之间存在外键约束.假设Σ上的一个集成数据库实例g如表1所示.表1OR-database模式Σ的一个集成数据库实例犵enamedeptsalor_idor_iddeptsalJennyFinance3000null#1Finance3000Smithnull3000#1#1Account3000JackSales2800null#2Sales3500Alicenullnull#2#2Finance3200JohnAccountnull#3#3Account2800RoseSales3500null#3Account2500Page5根据前面定理1,集成数据库实例g显然是非一致的,接下来考虑ATOMIC关系emp上的一个分组聚集查询q,它要求统计各部门的雇员薪水总和,该查询可以使用式(1)形式的语言表达如下:由前面定义4和定义6,设非一致的数据库实例g的修复集合为RepairsC(g),则RepairsC(g)一共包含8个数据库修复,而分组聚集查询q的一致性回答CQAC(q,g)可以通过RepairsC(g)的所有修复计算获得,即有CQAC(q,g)={(Account,[2500,5800]),(Finance,[3000,9200]),(Sales,[6300,9800])}.查询的一致性回答表明会计部薪水总和在2500~5800之间,财务部的薪水总和在3000~9200之间,而销售部的薪水总和在6300~9800之间.当然,CQAC(q,g)也可以通过重写的一致性查询Q(d,low,up)=Qg(d,low)∧Ql(d,up)直接在非一致性数据库实例g上执行获取,那么分别计算各部门薪水总和最大下界和最小上界的子查询Qg(d,low)和Ql(d,up)分别可以表示为Qg(d,low)=selectd,sum(s)aslowfromQg(e,d,s)groupbydQg(e,d,s)=selectnamease,deptasd,salassfromempwhereor_id==nullunionselectnamease,emp.deptasd,min(emp_or.sal)assfromemp,emp_orwhered!=nullandemp.or_id=emp_or.or_idgroupbye,dQl(d,up)=selectd,sum(s)asupfromQl(e,d,s)∧Ql(e,d,s)=selectnamease,deptasd,salassfromempwhereor_id==nullunionselectnamease,emp.deptasd,max(emp_or.sal)assfromemp,emp_orwhereemp.or_id=emp_or.or_idgroupbye,d4.2聚集查询重写算法Qg(d,low)groupbyd针对OR-database全局模式Σ上的分组聚集查询q,本节给出它的一致性查询重写算法,其中的子查询q为ATOMIC关系上符合Cforest的合取查询.分组聚集查询q主要考虑基于包语义的返回包元组个数的count(),及返回包元组求和、最大和最小(sum,max和min)这4个聚集函数.下面首先对带有count()的分组聚集查询q,提出OR-database的一致性查询重写算法,算法如下所示.算法1.RewriteCount_OR(q,C).输入:具有如下形式的聚集查询qselect狕,count()fromq(狕)groupby狕,这里q为Cforest中的合取查询,C为Σ的关系集合上的主外键约束.输出:Q,q的一致性查询重写设G为q的连接图,R1(狓1,狔1,o1),R2(狓2,狔2,o2),…,Rm(狓m,狔m,om)为G所有树的根,设狓=∪i=1,2,…,m狓i,狕=狕-狓且q=狑.(狑,狕),设狑=狑-狓,q(狓,狕,狅)=狑,狅.(狓,狑,狕,狅),这里狅为R1,R2,…,Rm的or_id属性变量向量,即狅=〈o1,o2,…,om〉,而狅为狕所在关系or_id属性变量向量并满足狅=狅-狅.Qg(狕,low)=select狕,count()fromq(狓,狕,狅)where狕!=nullgroupby狕Ql(狕,up)=select狕,count()fromQl(狓,狕)∧Qg(狕,low)groupby狕Ql(狓,狕)=select狓,狕fromq(狓,狕,狅)where狅=nullunionselect狓,狕fromq(狓,狕,狅)∧Ri_or(oi,狕i,_)∧…∧Rj_or(oj,狕j,_)Q(狕,low,up)=Qg(狕,low)∧Ql(狕,up)RETURNQ(狕=狕i∪…∪狕j,狅=〈oi,…,oj〉,1ijm)上的主外键约束.算法2.RewriteAgg_OR(q,C).输入:具有如下形式的聚集查询qselect狕,[max(u)|min(u)|sum(u)]fromq(狕,u)groupby狕同样的,q为Cforest中的合取查询,C为Σ的关系集合输出:Q,q的一致性查询重写设G为q的连接图,R1(狓1,狔1,o1),R2(狓2,狔2,o2),…,Rm(狓m,狔m,om)为G所有树的根,设狓=∪i=1,2,…,m狓i,狕=狕-狓且q=狑,狅.(狑,狕,u,狅),设狑=狑-狓,q(狓,狕,u,狅)=狑狅.(狓,狑,狕,u,狅),这里狅为R1,R2,…,Rm的or_id属性变量向量,即狅=〈o1,o2,…,om〉,而狅为狕所在关系or_id属性变量向量并满足狅=狅-狅Qg(狓,狕,u)=select狓,狕,ufromq(狓,狕,u,狅)where狕!=nullandu!=nullunionselect狓,狕,min(u)fromq(狓,狕,狌′,狅)∧Ri_or(oi,狕i,_)∧…∧Rk_or(ok,狕k,u,_)∧…∧Rj_or(oj,狕j,_)where狕!=nulland狌′=nullgroupby狓,狕Ql(狓,狕,u)=select狓,狕,ufromq(狓,狕,u,狅)where狕!=nullandu!=nullPage6unionselect狓,狕,max(u)fromq(狓,狕,狌′,狅)∧Ri_or(oi,狕i,_)∧…∧Rk_or(ok,狕k,u,_)∧…∧Rj_or(oj,狕j,_)groupby狓,狕(狅=〈oi,…,oj〉,1ikjm)IFtheaggregatefunctionismaxTHENQg(狕,low)=select狕,max(u)fromQg(狓,狕,u)groupby狕Ql(狕,up)=select狕,max(u)fromQl(狓,狕,u)∧ELSEIFtheaggregatefunctionisminTHENQg(狕,low)=select狕,min(u)fromQg(狓,狕,u)groupby狕Ql(狕,up)=select狕,min(u)fromQl(狓,狕,u)∧ELSEIFtheaggregatefunctionissumTHENQg(狕,low)=select狕,sum(u)fromQg(狓,狕,u)groupby狕Ql(狕,up)=select狕,sum(u)fromQl(狓,狕,u)∧ENDIFQ(狕,low,up)=Qg(狕,low)∧Ql(狕,up)RETURNQ4.3重写算法的正确性定理2.设OR-database全局模式Σ上的主外键约束为C,q(狕,v)是满足式(1)形式的分组聚集查询并且Q为本文查询重写算法RewriteCount_OR(q,C)或RewriteAgg_OR(q,C)返回的一致性查询重写,并设g为Σ的集成数据库实例;那么对任意元组狋和一个数值对low和up都有(狋,low,up)∈CQAC(q,g),当且仅当(狋,low,up)∈Q(g).上述定理表明:对满足Caggforest类的任意分组聚集查询q,本文查询重写算法RewriteCount_OR或RewriteAgg_OR所产生的查询重写Q就是q的一致性查询重写,即本文重写算法是正确的.那么,关于定理的证明,根据前面关于分组聚集查询的一致性回答的定义6,对全局模式Σ的一个不一致集成数据库实例g来说,需要证明:(1)对每一个g关于C的修复g,存在某个d使得(狋,d)∈q(g)并且满足lowdup.(2)存在某个g关于C的修复g满足(狋,low)∈q(g).(3)存在某个g关于C的修复g满足(狋,up)∈q(g).定理的详细证明过程参见附录.5一致性聚集查询代价比较5.1一致性聚集查询代价构成数据集成环境下,比较本文基于OR-database的查询重写与Fuxman查询重写两种一致性聚集查询方法整体代价应该包含:全局模式的集成数据库生成代价,用户聚集查询的重写代价以及重写后的一致性聚集查询执行代价.首先考虑集成数据库的生成代价,传统数据集成系统=〈Σ,,〉和基于OR-database的数据集成系统=〈Σ,,〉集成相同数据源模式的数据,它们的主要区别是全局模式Σ是传统关系模式而Σ是OR-database关系模式,并且全局模式不同导致模式映射不同.为了便于代价的量化比较,不妨假设Σ={R1,R2,…,Rn},Σ={R1,R2,…,Rn,R1_or,R2_or,…,Rn_or},两种集成数据库实例分别用g和g表示,设每一个Ri(1in)的元组数为ki及主键冲突元组所占比例为p,单个元组插入到Ri的代价为c而piki个主键冲突元组需要更新Ri中主元组代价及插入到Ri_or中的代价均为c,那么集成数据库g和g的生成代价Cost(g)和Cost(g)可以分别表示为Cost(g)=∑n显然,基于OR-database集成数据库的生成代价仅比传统集成数据库的生成代价多p%,而数据集成系统中主键冲突元组的比例一般都是很小的,再加上集成数据库实例的生成代价是一次性的,与集成数据库实例上大量用户查询的重写与执行代价相比,OR-database数据集成模式带来的实例生成代价增加部分就显得微不足道了.接下来考虑用户聚集查询的重写与执行代价,对于满足Caggforest类的任意分组聚集查询q,Fuxman的重写算法和本文的重写算法能够分别获得一致性查询重写Q和Q.其中,Fuxman的RewriteCount或RewriteAgg都需要调用Cforest合取查询类的一致性重写算法RewriteForest,其可能根据查询q的连接图调用递归算法RewriteTree,递归调用的次数取决于构成连接图的关系个数,假设查询q涉及关系个数为m(mn)并且其连接图构成一棵树,如果查询重写算法RewriteTree每个关系节点处理算法RewriteLocal的代价为常量时间d,则其查询重写代价为线性时间md;而本文的RewriteCount_OR或RewriteAgg_OR是直接使用m个ATOMIC关Page7系及其OR-objects关系来产生查询重写Q,其重写代价也等于常量时间d,与RewriteLocal的代价相同,显然在查询重写的代价上本文算法明显低于Fuxman的重写算法.另外,在用户聚集查询的整个重写与执行代价中,查询重写的关系数线性时间或常量时间的生成代价与其在关系数及关系元组数上函数时间的执行代价相比不在同一个数量级上,即查询重写的生成代价远远小于其执行代价,再加上前面的关于集成数据库实例的生成代价分析与比较可知,要从代价方面对比两种一致性查询方案的优劣,可以通过集中比较两种重写的一致性查询在集成数据库实例上的执行代价来进行.5.2一致性聚集查询执行代价比较i=1i=1对Caggforest查询q的两种一致性查询重写Q和Q,采用线性工作度量[24]作为它们的代价模型并使用查询执行时的关系扫描元组数作为度量标准,则它们的查询代价Cost(Q)和Cost(Q)根据连接图形成了不同的取值范围.注意,T1,T2,…,TK(0Km-1)为查询Q递归执行中形成的临时关系而R_or1,R_or2,…,R_orm为与R1,R2,…,Rm(mn)对应的OR-object关系.c∑m|Ri|Cost(Q)c∑mc∑m|Ri|Cost(Q)c∑m当式(4)和(5)的下界代表q的合取子查询连接图为包含m棵树(仅有根节点)的森林时,并且查询返回的自由向量狕仅出现关系R1,R2,…,Rm的主键上,R1,R2,…,Rm之间如果存在相同的存在变量,它们的连接也仅为键键连接,根据查询重写Q和Q的定义可知它们的查询代价相等即为R1,R2,…,Rm的元组数之和;式(4)和(5)的上界则表示当q的合取子查询连接图为包含m个节点的树(即只有一个连通分支)时,q的合取子查询涉及R1,R2,…,Rm这m个关系的连接,一致性检查是Q和Q的最大不同.Q对Ri的查询一致性检查是在Ri本身中完成的,其查询代价为c|Ri|2.由于q一致性结果的需要计算聚集函数的上下界,则Q在关系Ri上的总查询代价为c(|Ri|2+|Ri|),另外,由于Q的一致性查询结果是通过在R1,R2,…,Rm上递归执行一致性检查来获得并形成临时关系,所以最终的Cost(Q)需要包含临时关系的查询代价;而Q则是通过Ri的OR-object关系R_ori检查查询一致性,所以其查询代价仅为c(|Ri|+|R_ori|),同样,Q在关系Ri上的总查询代价为c(2|Ri|+|R_ori|).对一般的分组聚集查询q,其合取子查询的连接图是介于上下界之间并可能包含多个连通分支,如果在R1…Rm中出现某一个关系Ri单独形成树的情况,并且狕中变量出现在Ri的非主键上,此时Q和Q在Ri上的查询代价是c(|Ri|2+|Ri|)和2c|Ri|,但如果Ri出现在多节点的树中即Ri涉及与其他关系连接时,Q和Q在Ri上的查询代价则是c(|Ri|2+|Ri|)和c(2|Ri|+|R_ori|).通常,|Ri||R_ori|甚至对|Ri|来说|R_ori|可以忽略不计,显然无论哪种情况Cost(Q)都达到|Ri|2而Cost(Q)仅为|Ri|,并且Q的查询代价还要包含其递归执行过程中产生的临时关系查询代价,所以Cost(Q)Cost(Q).两者的本质差别是由于查询重写的数据一致性检查是在原关系Ri还是在|R_ori|中进行造成的,这也充分地验证了OR-database集成模式有效隔离集成数据库的一致性部分和非一致性部分带来的查询执行代价上的优势.6实验为了比较RewriteCount_OR或RewriteAgg_OR产生的聚集查询重写与Fuxman的聚集查询重写的执行代价,考虑如下的模拟实验:实验根据是否基于OR-database集成关系模式使用TPC-H标准在Oracle10g上创建了OR-database全局模式与普通全局模式,并使用数据产生器DBGen分别产生大小为0.25GB、0.5GB、1GB、2GB、4GB的实验数据,然后选择执行不同的聚集查询及其一致性查询重写并且比较它们的平均执行时间.实验的运行环境为IBMTHINKPADT400,2.8GHzIntelCore2DuoCPU,4GBDDR3RAM,Seagate160GB(7200RPM),操作系统为Windows7.首先,考虑TPC-H标准中关系customer,orders和lineitem上包含一个聚集函数sum的查询Q3以及关系orders和lineitem上包含两个聚集函数sum的查询Q12,选择数据库大小从0.25GB到4GB变化,不一致数据比例为5%的情况下,比较原始的不一致查询,Fuxman给出的一致性聚集查询Page8重写1及本文算法的一致性聚集查询重写2的查询执行代价,实验结果如图1和图2所示.实验结果表明:无论是包含一个sum的Q3还是包含两个sum的Q12,它们的原始查询及两个一致性查询重写在数据库大小从0.25GB到4GB增长时的执行代价变化趋势基本一致.与查询重写1的执行代价相比,查询重写2的代价明显地降低仅比并原始不一致查询的代价高出不到10%的比例.同时,对比图1和图2可以发现,包含两个sum的Q12的查询重写2与查询重写1代价之差明显地大于仅包含一个sum的Q3的查询重写2与查询重写1的代价之差.然后,实验选择最大关系lineitem上包含8个聚集函数的查询Q1,其他条件与前面的实验保持一致的情况下再次对比原始查询,查询重写1及查询重写2的执行代价,实验结果如图3所示.此时,Q1查询重写2与查询重写1的代价之差随着数据库大小的增长而急剧增加,并且增加幅度远远大于图1和图2,但是查询重写2的代价与原始查询代价的变换趋势却基本保持一致.最后,实验选择关系lineitem上包含一个sum的聚集查询Q6,数据库大小固定为1GB,不一致数据比例从5%~25%变化时,对比原始查询,查询重写1及查询重写2的执行代价变化趋势,实验结果如图4所示.显然,随着不一致数据比例的增长,原始查询与查询重写2的执行代价基本保持不变,但查询重写1的执行代价出现了明显地增长.7结论本文主要考虑数据集成环境下如何有效提高不一致数据库上一致性聚集查询的整体性能问题.首先,通过OR-database集成模式有效地隔离集成数据库的一致性部分和非一致性部分;然后在此基础上对合取查询类Cforest上的分组聚集查询提出了基于OR-database的一致性查询重写算法;最后基于线性工作度量的查询代价分析与比较以及Oracle10g不一致数据库上的TPC-H模拟实验都表明:与Fuxman的一致性聚集查询方法相比,本文提出的一致性聚集查询方法在OR-database集成数据库上具有非常明显的性能优势.Page9
