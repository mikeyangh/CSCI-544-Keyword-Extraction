Page1基于悖论证明与局部搜索的不可满足子式求解算法张建民沈胜宇李思昆(国防科学技术大学计算机学院长沙410073)摘要随着软硬件设计规模日益增加,功能越来越复杂,功能验证与调试在整个设计周期中占有的比重越来越大,迫切需要高效的方法诊断与定位设计中的错误,而求解不可满足子式可以显著提高自动化工具定位错误的效率.近年来,求解不可满足子式的算法多是基于DPLL(Davis-Putnam-Logemann-Loveland)回溯搜索过程的完全算法,很少有研究涉及到不完全方法.文中针对求解不可满足子式的不完全方法,提出了悖论证明与悖论解析树的概念,并提出一种启发式局部搜索算法,从布尔公式的悖论证明中求解不可满足子式.算法首先采用融合了布尔推理技术、动态剪枝方法及蕴含消除方法的局部搜索过程,逐步构建悖论证明所对应的悖论解析树;然后调用递归函数搜索悖论解析树,最终得到不可满足子式.基于实际测试集与随机测试集进行了实验对比,结果表明文中提出的算法优于同类算法,而且动态剪枝与蕴含消除技术能够有效地减少存储空间及运行时间.关键词形式化验证;可满足问题;不可满足子式;悖论证明;局部搜索1引言近年来,随着软硬件设计规模的不断增加,功能越来越复杂,导致功能验证与调试的周期越来越长,往往占到整个设计周期的60%以上.而诊断与定位错误又是其中非常耗时耗力的阶段,这类应用可以规约为合取范式(ConjunctiveNormalForm,CNF)格式的布尔公式.如果应用出现错误与不一致,例如FPGA布线不通或代码出现错误,表明布尔公式不可满足,要求快速定位公式不可满足的缘由,查找导致赋值冲突的更小集合,即求解原始公式的不可满足子式.求解不可满足子式在很多领域中都具有非常重要的应用价值与理论意义,例如软硬件形式化验证与电子CAD等,因此如何高效提取不可满足子式逐渐成为近几年来软硬件形式化验证领域的研究热点与重要突破方向.不可满足子式的求解算法按照问题的解决策略能够划分为完全方法与不完全方法.一般来讲,完全方法最终总能够求得应用问题的准确解,但不足之处在于算法的时间复杂度会随待解决问题规模的增加成指数级增长.而不完全方法的优点是搜索效率高、运算速度快,但有时无法给出问题的精确解.近十年来由于基于DPLL回溯搜索过程的SAT求解技术不断提高,因此布尔不可满足子式的求解算法多数基于这种完全方法[1-8].但是近几年来逐渐出现了一些研究基于不完全方法来提取布尔不可满足子式的情况.研究人员[9]提出了一个关于公式中命题变元真值指派的关键短句的概念,并且基于关键短句,利用局部搜索过程提取布尔不可满足子式.但算法本质上仍是依赖于完全方法的SAT求解技术,依据SAT求解过程中短句被赋值为假的频率,从而判定该短句能否加入不可满足子式.在文献[10]中提出了可满足问题的经典挑战:(在未来10年内)实现一种局部搜索算法,能够求解公式的不可满足性.然而直到10年后才有学者[11-12]首次提出了求解公式不可满足性的局部搜索算法.但是这两种算法仅能证明公式是否不可满足,而不能求解公式的不可满足子式.那么直到目前为止,还没有出现能够高效提取布尔不可满足子式的不完全方法.针对布尔不可满足子式的快速求解问题,本文给出了悖论证明与悖论解析树的概念,并提出一种从公式的悖论证明中高效求解不可满足子式的局部搜索算法.算法首先通过局部搜索过程,逐步建立原始公式不可满足性的悖论证明.而悖论证明中包含了公式不可满足的必要短句,从中提取所有原始公式的短句,就得到不可满足子式.为了避免局部搜索的过度随机性,算法包含多种启发式的布尔推理技术.当产生的新短句添加到公式中时,采用一个蕴含消除过程来剔除公式中的冗余短句,同时提出一种悖论剪枝方法来动态地削减证明序列,以提高求解效率,减小搜索空间.最后根据公式的悖论证明构造悖论解析树,并通过一个递归过程搜索悖论解析树的叶节点,最终得到不可满足子式.局部搜索算法具有运算速度快、搜索效率高的优点,尤其针对某些类型的问题,例如2-SAT、3-SAT问题,是很高效的方法,并且很多实际应用都能转化为2-SAT或3-SAT求解问题,例如FPGA布线与经典鸽笼问题.因此基于FPGA布线测试集与鸽笼测试集,将本文算法与求解不可满足子式的贪心遗传算法[4]进行了对比,结果表明该方法优于贪心遗传算法.3-SAT问题是SAT测试集中一类典型的问题,并且其他类型的SAT问题都可以转换为3-SAT问题求解,因此基于随机2-SAT与3-SAT测试集,将本文算法与同类的AMUSE算法[1]进行了对比,结果表明该算法优于AMUSE算法.2基于悖论证明的局部搜索算法CNF公式的构建规则是:变元(x)及其否定形式(x)称为文字,短句是由n(n0)个文字通过析取操作组成,当n=0时称为空短句(⊥),公式是由m(m1)个短句的合取构成.定义1.可满足问题.给定一个CNF公式φ:φ=∧ni=1Ci,其中短句Ci=∨jxj∨kxk,V={x|x∈φ}表示变元集合.给定一个赋值M,M表示从φ的变元集合V到真值{true,false}的映射:V→{true,false}|V|.如果存在一个赋值M,使得φ=true,即Mφ,那么称公式φ是可满足的;若对于任意的赋值M,都有M/φ,则称公式φ是不可满足的.定义2.不可满足子式.给定一个CNF公式φ,ψ是公式φ的一个不可满足子式当且仅当ψ是不可满足的,并且ψφ.合取范式公式的消解规则为Page3表示为((A∨x)∧(B∨x))(A∨B),其中变元x是消解元,A与B由n(n0)个文字通过析取操作构成,(A∨x)与(B∨x)称为消解母式,而式(1)中的(A∨B)叫做消解式.短句(x)与(x)的消解式为空短句.每次在两个短句上应用式(1)的消解规则产生消解式叫做一个消解步骤.若干个消解步骤,其中每一步都使用前面步骤产生的消解式或原始公式中的短句作为当前的消解母式,就称为消解序列.引理1.公式φ是不可满足的当且仅当存在一个有穷消解序列,其中某个步骤的消解式为空短句⊥.定义3.悖论证明.给定一个不可满足的CNF公式φ,N={C0,C1,…,Cn}为φ的一个有穷消解序列.若N的最终消解式为空短句,即Cn=⊥,构造一个由消解步骤构成的集合R={Pi|Pi为(Cj,Ck)Cl,其中Cj,Ck,Cl∈N},则R称为φ的一个悖论证明.显然地,悖论证明是一类特殊的消解序列,由于其某个步骤的消解式为空短句,因此涵盖了CNF公式不可满足的缘由.那么易证下面的结论.结论1.给定一个CNF公式φ,φ是不可满足的当且仅当φ至少包含一个悖论证明R.若令集合D=Cla(φ)∩Cla(R),其中Cla(φ)={C|C为φ中短句},Cla(R)={C|C为R中短句},那么ψ=∧C∈DC⊥成立,且ψ是φ的不可满足子式.满足下面的条件:定义4.悖论解析树.若一个有向树T(V,E,r)(1)包含唯一的根结点,对应的短句Cr=⊥;(2)v∈V\L,其中L表示T中叶结点的集合,假设v及其父结点p∈V与q∈V分别对应的短句为Cv、Cp与Cq,那么Cp∧CqCv;而边epv∈E与eqv∈E分别表示从父结点p与q指向子结点v.则称T(V,E,r)为悖论解析树.给出不可满足公式φ的一个悖论证明R,那么对应于R的悖论解析树T(V,E,r)的构造规则为:空短句⊥对应根结点r;假设R中的任意一个消解步骤为(C1,C2)C,那么C、C1与C2分别对应T中的结点{v,v1,v2}V,而边{e1,e2}E分别由结点v1与v2指向v.通过该规则,能够将一个悖论证明从最终的消解式⊥开始,一直回溯到原始公式中的短句,逐步构造出悖论解析树.那么,根据公式φ的悖论解析树T(V,E,r),如何求解φ的不可满足子式?根据结论1与定义4,易证下面的结论.结论2.给定不可满足公式φ的一个悖论证明R,T(V,E,r)为R对应的悖论解析树,那么T(V,E,r)中所有叶结点对应的短句,构成φ的一个不可满足子式.由于局部搜索算法具有运算速度快、求解效率高的优点,所以根据上述结论,将局部搜索算法用于高效构建证明公式不可满足性的悖论解析树,而后通过递归过程搜索悖论解析树的所有叶节点,从而求解不可满足子式,图1给出了算法的伪代码.R2bLSAtoExtractUS(formula)1.refuted=false2.iteration=03.sequence=4.while((iteration<MAXITER)and!refuted)do5.if(Unit_Clause_Propagation()返回UNSAT)6.refuted=true7.sequence=sequence∪{消解的短句}8.elseif(存在二元短句)then9.Binary_Clause_Resolution()10.Non_Tautology()11.Equality_Reduction()12.No_Same_Clause()13.sequence=sequence∪{消解的短句}14.else15.随机地选择两个短句进行消解16.sequence=sequence∪{消解的短句}17.Subsumption_Elimination(resolvent)18.Trace_Updating(resolvent)19.if(formula.size>MAXSIZE)then20.从formula中随机地删除短句C21.Trace_Pruning(C)22.iteration++23.if(refuted==true)then24.print“unsatisfiable”25.SmallUS=Compute_US(sequence)26.else27.print“unresolved”28.returnSmallUS该算法的输入是CNF公式formula,输出是不可满足子式SmallUS.算法启发式或随机地选择两个短句进行消解,目标是消解式为包含更少文字的短句或空短句(⊥),直到产生一个悖论证明或循环次数到达预设值.在消解过程中,算法将每一次应用消解规则的消解步骤都保存到sequence中,如果公式是不可满足的,最终必会得到空短句.而后根据不可满足性的悖论证明sequence,构造一个树结构,而后根据结论1和结论2,利用高效的树搜索算法,快速得到原始公式formula的不可满足子式.图1算法的第5行采用单元短句传播函数判别公式是否不可满足,由于两个单元短句根据式(1)得到⊥是CNF公式formula不可满足的充要条件.若上述判别失败,则在算法第8行探测是否存在二元短句;若存在,则应用4种布尔推理技术加速消解过程.其中函数Binary_Clause_Resolution按照Page4式(1)的原理消解二元短句;Non_Tautology用于移除包含极性相反文字的短句;等价约简函数是将公式中等价的变元进行替换;而No_Same_Clause删除重复的短句.如果没有单元短句与二元短句,那么随机选择两个短句进行消解,其原则是被选择的概率与包含极性相反文字的数目成正比.当产生的消解式加入到公式中时,蕴含消除过程Subsumption_Elimination用来删除公式中存在蕴含关系的冗余短句.但是随着公式与消解序列的持续增加,会消耗更多的存储空间,并降低搜索效率,因此提出一种悖论剪枝方法.它包含两个函数:首先Trace_Updating函数为每个加入公式的消解式resolvent初始化并维护2个域值;而后随机选择短句C移除时,Trace_Pruning函数删除与短句C相关、但与证明不可满足性无关的消解步骤.在算法第7、13、16行,将消解出⊥的消解母式,并入悖论证明sequence集合中,而后构造一个悖论解析树,并通过递归函数Compute_US搜索悖论解析树,最终得到不可满足子式SmallUS.3实验结果与分析实验采用两类测试集:一类是来源于实际问题的测试集,另一类是随机生成的测试集.本文的算法测试集变元数短句数极小不可满足表13种算法在测试集上的实验结果fpga_routing11017401100.12900.29fpga_routing21425110.021200.29900.359fpga_routing31833260.13100.080.6390.10.79fpga_routing42241572.16141.21.1591.281.29fpga_routing5264912051.91527.63.25925.22.99fpga_routing63057timeouttimeout182.510.69171.08.759fpga_routing73465timeouttimeout358.017.59321.014.19fpga_routing83873timeouttimeout617.023.49566.118.59fpga_routing94281timeouttimeout1040.128.09941.021.69fpga_routing104689timeouttimeout1690.036.591507.027.19hole123103003003hole26910900.1900.119hole31222102200.382200.4622hole42045104500.524500.5545hole5308110.028100.64810.10.6581hole64213310.081330.10.781330.10.77133hole75620410.92040.51.122040.441.0204hole872297151.929722.810.829720.68.9297hole99041511304.0415682.625.3415605.821.0415hole101105611timeout1850.058.85611689.046.5561集中的6个公式,GGA算法在3600s无法求解不可下面分析3种算法在测试集上的运行结果,除满足子式,记为“timeout”.通过进一步对比分析基公式hole6外,R2bLSA算法与R2bLSA+RP+SE本算法与完整算法的结果可以发现,对于较大的公算法都优于GGA算法.另外对于FPGA布线测试基于C++与STL实现.算法输入都是DIMACSCNF格式的公式,超时设置为3600s.算法所运行的机器配置为Athlon2@1.6GHzCPU,内存为1GB,操作系统是RHELLinux.3.1实际测试集基于经典的鸽笼测试集以及FPGA布线测试集,将本文提出的算法与贪心遗传算法GGA[4]进行了对比.为了验证蕴含消除与悖论剪枝方法的效果,将两个过程从算法中移除,剩余的算法称为基本R2bLSA,而整个算法表示为R2bLSA+RP+SE.表1给出了3种算法的实验结果.表中首先是测试集的名字及其变元数与短句数;后面1列给出了该公式所有极小不可满足子式的总数,由文献[3]中的算法求得,但有5个FPGA测试集公式在3600s内无法得到极小不可满足子式总数,记为“timeout”;而后2列表示GGA算法求解不可满足子式的时长与大小;第7~9列分别表示基本R2bLSA算法的运行时间、运行时占用的存储空间与不可满足子式包含的短句数;最后3列是R2bLSA+RP+SE算法的运行时间、占用的存储空间及不可满足子式所包含的短句数.所有算法的运行时间都是以秒(s)为单位,存储空间以MB为单位.表1中加粗的数据表示对应算法的运行时间最短或存储空间占用最小.基本R2bLSA算法时间存储空间大小Page5式,完整算法比基本算法快10%左右,存储空间占用少20%左右;并且随着公式所包含的变元数与短句数逐渐增加,完整算法变得更加高效;但是当公式较小时,基本算法更加有效,这是由于蕴含消除与悖论剪枝方法在运行时所取得的收益小于其消耗所致.3.2随机测试集3-SAT问题是SAT测试集中一类典型的问题,并且其他类型的SAT问题都可以转换为3-SAT问题求解,因此为了验证本文算法的有效性,基于随机3-SAT和2-SAT测试集,将完整的R2bLSA算法与AMUSE算法[1]进行了实验对比.AMUSE算法是一种完全方法,能够高效地求解不可满足子式.采用经典的k-SAT公式生成方法产生测试集,其输入参数包括变元数N、短句数C以及短句所包含的文字数k.构造k-SAT公式的过程为:从N个变元中随机地选取m个变元,其中分别以概率p,m=k;以概率1-p,1mk;而后以概率q构成正文字或负文字,从而组成m元短句.图2给出了R2bLSA算法与AMUSE算法在随机2-SAT测试集上的实验结果.图3是R2bLSA算法与AMUSE算法基于随机3-SAT测试集上的实验结果.实验时的参数设置为N=200,概率p=q=0.5,公式所包含的短句数从100~2000,每组测试集递增100个短句.从图2和图3的实验结果可以看出,本文的R2bLSA算法优于AMUSE算法,尤其是随机2-SAT测试集;并且随着公式长度的增加,R2bLSA算法的性能优势更加明显.其主要原因包括以下3点:(1)在进行公式的可满足性判定时,就以优化的数据结构保存了求解不可满足子式所需要的信息,因此提取不可满足子式的过程非常高效;(2)R2bLSA算法的可满足性检测过程实现简单,单位时间内执行的循环次数更多;(3)R2bLSA算法中包括很多针对长度较小的短句,尤其是二元短句的优化技术,而随机2-SAT与3-SAT测试集中包含很多单元短句与二元短句.4结束语针对如何高效求解布尔不可满足子式的问题,提出了悖论证明与悖论解析树的概念,并且提出一种融合布尔推理、蕴含消除以及悖论剪枝等多种启发式技术的局部搜索算法.基于实际测试集进行了实验,结果表明局部搜索算法优于贪心遗传算法;基于随机测试集进行了实验,结果表明局部搜索算法优于AMUSE算法;并且通过实验说明,动态剪枝与蕴含消除技术能够有效地减少存储空间及运行时间.
