Page1固定移动融合网络中基于资源挑战的垃圾语音防范方法何光宇1),2)闻英友2)赵宏1)1)(东北大学信息科学与工程学院沈阳110004)2)(东软集团研究院沈阳110179)摘要以经典单向函数为基础,设计并验证了一种用于垃圾语音(SpamoverInternetTelephony,SPIT)防范的方法.该方法利用资源挑战机制,要求垃圾语音的发送者消耗大量系统资源来破解谜题才可以发送语言会话请求.谜题设计算法避免了相关研究存在的缺陷,使得方法更加安全、可靠;谜题破解算法要求发送者对CPU与Memory进行双重消耗,从而缩小不同配置终端在破解过程中的消耗差距.对方法进行仿真实验,分析结果表明方法具有很好的有效性与适用性.关键词SPIT;单向函数;资源消耗;谜题设计;谜题破解1引言在传统IP网络环境下,Spam被概括地定义为非预期的信息通信.EmailSpam即垃圾电子邮件,作为典型代表给传统互联网带来了严重的安全威胁和经济损失[1].随着IP应用的普及以及基于IP多媒体子系统(IMS)的固定移动融合(FixedMobileConvergence,FMC)网络的发展,基于SIP[2]协议的Page2与EmailSpam不同,SPIT具有实时性和直接性的特点,因此具有更大的威胁.垃圾语音以音频作为内容承载手段,使得较为成熟的基于内容过滤的EmailSpam检测方法难以实施.融合网络的开放与互通也使得简单的黑白名单机制不再适用.针对SPIT检测与防范的重点和难点,相关组织、学者在综合检测与防范模型[6-10]、实体认证方法[15-16]、行为分析方法[17-19]、信任评判方法[20-22]、音频检测方法[23-24]、资源消耗方法[27-29]等方面展开研究,并进行仿真验证[25-26]与分析评估[11-14],其中资源消耗方法能够对潜在的SPIT发送者进行资源挑战,发送者需要消耗大量系统资源与时间才能应对挑战,对以高频、广域为目标的SPIT攻击来说是一种行之有效的防范手段.然而目前研究成果也存在一些问题与不足.Dwork等人[27]与Banerjee等人[28]提出的方法仅对发送者的CPU资源进行消耗,由于不同终端的CPU频率存在很大差距,因此该方法的性能波动较大.Abadi等人[29]提出的方法主要对发图1体系结构改造后的体系结构增加了ResourceChallenger与ResourceResponder,二者为逻辑功能组件,可以部署为独立的物理实体,也可以集成到Proxy与Teminal中,分别实现对caller系统资源的挑战及对callee挑战的应答.图2给出了改造后基于SIP协议的VoIP会话流程.(1)每次OutBound的Terminal发来Invite请求,InBound的ResourceChallenger都会设计一个迷题,作为Challenge发送给caller;(2)caller利用功能组件ResourceResponder来破解迷题,并将答案作为Response返回给送者的内存资源进行消耗,由于不同终端的内存频率差距相对较小,因此规避了性能波动的问题.然而以上3种方法的挑战空间有限,SPIT发送者可以对挑战的计算结果进行缓存,也可以预先计算出不同挑战对应的结果,从而轻松应对挑战.本文提出一个基于资源挑战的SPIT防范模型,并对模型做形式化的描述.针对模型中关键算法进行重构与改进,克服了现有研究成果的问题与不足.第2节给出基于资源挑战的SPIT防范模型;第3节描述模型的具体算法;第4节通过实验分析模型及算法的性能与效用;第5节对全文进行总结.2基于资源挑战的SPIT防范模型2.1体系结构与流程逻辑境进行改造,增加一些功能组件,如图1所示.为了实现资源挑战机制,需要对传统VoIP环ResourceChallenger;(3)ResourceChallenger对答案进行验证,如果答案错误则发送Bye拒绝请求,如果答案正确则向callee转发Invite请求;(4)callee判断是否接受请求,如果拒绝则发送Bye请求,如果接受则发送OK应答;ACK请求,进而双方建立媒体会话;(5)如果callee返回OK应答,则caller发送(6)会话完成后,callee发送Bye请求,caller返回OK应答,会话结束.Page3图2流程逻辑2.2形式化描述为了准确、规范地展现模型,支撑模型完备、无二义性的实现,本小节给出形式化的描述.由于SIP会话基于事务,因此对SIP事务有限状态机(SIPTransactionFiniteAutomation,ST-FA)进行改进,使其能够支持SPIT防范的需要.ST-FA按照处理的请求是否为INVITE分为INVITE类型与Non-INVITE类型,本文阐述的SPIT防范方法作用于连接建立阶段,因此下面给出改进后的客户端(UAC)与服务器端(UAS)的INVITE类型的ST-FA.定义1.一个用于SPIT防范的客户端ST-FA是一个五元组(Qc,Σc,δc,qc,Fc),其中:Qc是一个有穷状态的集合,用来表示客户端会话建立过程中的各个状态,定义为{Calling,Proceeding,Computing,Pending,Completed,Terminated};Σc是导致状态变迁的各种信息的集合,定义为{Request,Response};δc:Qc×Σc→Qc是状态转换函数,图3给出了在任一状态qpre∈Qc时,发送请求req∈Σc或收到应答resp∈Σc后应该进入的下一状态qpost∈Σc;qc∈Q是起始状态,即发起会话请求时的状态Calling;F∈Q是接受状态,即会话结束后的状态定义2.一个用于SPIT防范的服务器端Terminated.ST-FA是一个五元组(Qs,Σs,δs,qs,Fs),其中:Qs是一个有穷状态的集合,用来表示服务器端会话建立过程中的各个状态,定义为{Proceeding,Designing,Pending,Verifying,Completed,Con-firmed,Terminated};Σs是导致状态变迁的各种信息的集合,定义为{Request,Response};Page4δs:Qs×Σs→Qs是状态转换函数,图4给出了在任一状态qpre∈Qs时,发送请求req∈Σs或收到应答resp∈Σs后应该进入的下一状态qpost∈Σs;qs∈Q是起始状态,即收到会话请求时的状态Proceeding;Fs∈Q是接受状态,即会话结束后的状态Terminated.3模型中关键算法3.1算法设计原则基于资源挑战的方法本质上是通过对caller系统资源的消耗,利用技术手段从经济性层面实现对SPIT攻击的防范.为了解决现有研究成果存在的问题,提高方法的鲁棒性与实用性,在设计时需要遵循以下原则:(1)caller需要耗费大量系统资源来破解callee设计的迷题才可以成功发送语音请求,而callee只需消耗极少资源便可设计谜题并验证答案的正确性;(2)迷题需要对caller的CPU与Memory进行双重消耗,最大程度缩小配置不同的终端破解迷题时的差距;(3)实现一次一问,避免结果被多次使用;(4)随机挑选迷题空间,使得缓存前续计算结本节后续给出迷题设计及破解的算法,并讨论果与预先计算不可行.给出的算法如何满足设计原则的要求.3.2迷题设计算法迷题设计的核心思想是ResourceChallenger利用单向函数的不可逆性迫使ResourceResponder通过穷举的方法来计算其逆函数,从而达到资源消耗的目的.典型的单向函数有大素数因数乘积与大指数求幂模运算,为了与主流密码系统相一致,并控制自变量与值域的范围,本文选择后者.其中a称为底数,x称为指数,n称为模数,y称为余数.此时ResourceChallenger的挑战是一个三元组Challenge={a,n,y}.ResourceResponder需要遍历x∈Domain(x)={x|1xn-1},寻找x使得y=f(x).在该算法中,设离散型随机变量M表示ResourceResponder找到x需要计算的次数,其概率分布为P{M=mj=j}=pj=1n-1.于是M的数学期望和方差分别为可见ResourceResponder找到特定的x的偶然性比较大,即不同挑战对ResourceResponder的资源消耗不够稳定.因此对该算法进行改进,利用多次遍历来降低单次遍历存在的高偶然性问题.改进后的算法中,ResourceChallenger首先选定x0,然后利用式(4)重复执行k轮得到xk.为了针对每个xi+1可以找到唯一的xi与之对应,式(1)中模数选择素数记为p,a选择群G=〈Z根,Domain(x)={x|1xp-1}.此时挑战是一个四元组Challenge={a,p,k,xk}.ResourceResponder收到Challenge后,首先遍历xk-1∈Domain(x),找到xk-1使得xk=f(xk-1).如此重复遍历k轮以找到x0=x0.设离散型随机变量M1,M2,…,Mk分别表示第k轮找到xk-1需要计算的次数,M表示表示找到x0需要计算的总次数,M=∑k数,M1,M2,…,Mk相互独立,于是M的数学期望和方差分别为Page5D(M)=∑k随着k值的增加,该算法可以有效避免单次遍历的高偶然性,然而由于式(1)引入了模运算,使得x0到xk序列中容易出现循环,即xi=xi+c.ResourceResponder在逐轮遍历中发现循环后,可以在c轮内找到x0=x0,得到破解捷径从而逃避大量的资源消耗.解决的方法是在谜题设计的每一轮加入该轮的信息i,从而保证x0到xk序列中不存在周期性循环.ResourceChallenger在每次计算f(xi)后将其与i做异或操作,从而避免了周期性循环.然而异或操作的结果可能超出Domain(x),因此还要与p做模运算.模运算的结果可能为0,因此令f(0)=0.异或操作还可能破坏xi+1与xi的一一映射关系,因此需要对x0到xk序列求和得到sum.此时挑战是一个五元组Challenge={a,p,k,xk,sum}.ResourceResponder收到Challenge后,每轮遍历都要选择f(xi)Xori的值为xi+1或xi+1+p.进行k轮遍历计算得到x0,并用x0到xk的和sum与sum进行比较,如果相等则计算结束,否则选择其它组合继续计算,直到sum与sum相等.算法目前已经具有一定的实用性,但在k确定的情况下,Challenge={a,p,k,xk,sum}中xk可取不同值的数量为p.因此ResourceResponder可以缓存以往计算得到的xk对应的x0,也可以在闲暇的时间预先计算出每个xk对应的x0,从而轻松的应对挑战.针对这个问题的解决方法是,在每次设计Challenge时,加入临时信息从而使得预先计算与缓存结果不再有效.烅烄xi+1=烆ResourceChallenger每次挑战前,随机选择一个变量token∈Domain(x).当轮次i为奇数时,计算f(xi)并与i做异或操作,再与p做模运算;当轮次i为偶数时,计算f(xi)并依次与i和token做异或操作,再与p做模运算.重复执行k次得到xk,此时挑战是一个六元组Challenge={a,p,k,xk,token,sum}.ResourceResponder如何破解该谜题,在下面给出详细阐述.3.3迷题破解算法ResourceResponder收到Challenge={a,p,k,xk,token,sum}后采用递归的方法进行破解.递归函数的形式参数为3元组{l,x,s},其中l代表当前的轮次,x代表当前轮次xl的值,s代表到当前轮次为止已得到的xl的和,即s=∑k递归初始时,l=k,x=xk,s=xk.如果l=0且s=sum,则递归结束,返回x0=x.如果l=0且s≠sum,则返回上层函数.如果l≠0,则令x=x,并执行如下计算:x=xXorl-1,i为奇数遍历Domain(x),如果找到x使得x=f(x).递归调用该函数,此时形式参数赋值为3元组{l-1,x,s+x}.如果没有找到x,并且xN-p,则递归调用该函数,此时形式参数赋值为3元组{l,x+p,s}.利用该递归函数进行谜题破解,至少要进行l轮遍历,每轮遍历都需要依次取x∈Domain(x),计算f(x).因此理性的ResourceResponder会首先进行一次全遍历,存储x→f(x)的映射关系,在每个轮次的遍历中只需要反向查询便可找到x对应的x.反向查询实质上是对Memory的随机访问,随机访问的效率取决于Memory的时钟频率,较之CPU的频率(通常333MHz-n×3GHz,几十倍),Memory的频率(通常333MHz~800MHz,几倍)在不同终端之间差别较小,因此采取对ResourceResponder的Memory进行消耗,可以在很大程度上缩小不同配置的ResourceResponder破解谜题所消耗的资源的差距.4实验与分析为了验证本文提出的资源挑战方法,搭建仿真环境进行实验与分析.由于关注的重点是该方法对ResourceResponder的CPU与Memory的消耗情况以及该方法面对不同类型与配置的ResourceResponder所表现出的适用性,实验选择3台不同类型与配置的计算机作为ResourceResponder,观察它们在解决谜题过程中的表现,从而验证本文提出的方法的有效性.表1给出作为ResourceResponder的3台计算机的配置信息.Page6Machine表1ResourceResponder配置信息表2给出了对于不同Challenge={a,p,k,xk,token,sum},ResourceResponder进行破解的资源消耗情况.其中大素数p=9973,其本原根a=11,token=8888.ResourceChallenger在设计谜题时,x0选择1234,轮次k从100到1500以100等差递增.C/R分别代表用A、B、C配置的计算机进行谜表2谜题设计与破解的资源消耗A0.03/2.460.05/3.890.06/6.450.09/9.730.11/14.750.13/19.960.14/26.630.15/33.110.16/41.070.17/51.520.17/61.600.17/72.960.18/84.790.18/98.210.19/112.10图5给出了不同配置的ResourceResponder破解轮次递增的Challenge时所需要的时间,该图反映出本文提出方法的一些特性:(1)随着轮次的增加,破解谜题的时间也随之增加;(2)破解谜题所需时间的增加从平缓趋向剧烈;(3)ResourceResponder破解谜题所需时间的差异要小于其配置的差异.这些特性证明了本文提出的谜题设计与破解方法的有效性以及适用性.题设计与破解所需的时间,单位为s.文献[29]实验用到Server、Desktop、Laptop配置差距与本文实验用到A、C、B计算机配置差距相当,文献[29]实验结果表现出性能差异为182442,本文实验结果表现出性能差异为202327,可见本文算法性能明显优于文献[29]的算法性能.图6和图7分别给出不同配置的ResourceResponder破解轮次递增的Challenge时CPU与内存的消耗.由图可知,破解谜题过程几乎占用ResourceResponder的全部CPU资源,符合资源消耗的思想;并且对Memory的使用基本恒定在23MB,这说明进行资源挑战不要求ResourceResponder具有大量内存,该方法可以推广至PDA、智能手机等终端设备.Page75结束语本文提出的基于资源挑战的SPIT防范方法,克服了相关研究中存在的消耗抖动较大,存在破解捷径、重复利用计算结果、预先计算等诸多缺陷,并且实现了对ResourceResponder的CPU与Memory的双重消耗.仿真实验的分析结果表明,该方法可以根据实际需要设计出任意难度的谜题,并可以扩展到PDA、智能手机等终端设备,具有很好的有效性与适用性.
