Page1面向MAX/MIN优化的SQLWindow函数处理马建松王科强宋光旋张凯王晓玲金澈清(华东师范大学数据科学与工程研究院上海市高可信计算重点实验室上海200062)摘要Window(窗口)函数作为关系数据库领域中数据分析技术的一种解决方案,其精妙的语义特征使其能代替自连接(SelfJoin)和相关子查询(SubQueries)等完成传统复杂查询功能,现已被广泛应用到互联网应用的数据管理和分析中.在目前互联网应用步入大数据时代的背景下,针对高吞吐和实时响应等需求,已有的Window(窗口)函数的处理性能已经出现了瓶颈.文中首先介绍了关系数据库中窗口函数在执行器中的两阶段执行框架,然后基于PostgreSQL数据库中原有MAX/MINWindow(窗口)函数执行框架,提出了一种基于临时窗口的优化方法,来优化SQLWindow查询针对MAX/MIN函数的处理,并给出了查询代价的分析模型,从理论上分析了该算法的性能.通过与现有商业数据库SQLServer进行性能上的对比,验证了该方案的有效性.关键词Window函数;查询处理;性能优化;MAX/MIN;PostgreSQL1引言随着互联网的普及和互联网用户数量的不断增加,互联网应用逐渐进入了大数据时代.大数据时代的来临,使得互联网应用面临着数据的爆发式增长.由于用户数据中包含了丰富的用户行为模式信息,因此,大数据量的用户数据对互联网应用来说变得越来越重要.如何存储和分析这些大数据成为了互联网应用中的难题.随着用户对数据处理效率的要求不断提高,融合数据存储和数据分析的内数据库分析(In-DatabaseAnalytics)技术,受到了越来越多企业和研究者的关注.Window(窗口)函数作为关系数据库领域中内数据库分析技术的一种解决方案,最初以扩展文档的形式被引入到SQL:1999,之后不久,SQL:2003就正式规范了Window(窗口)函数的标准,并在后续的标准版本中有所丰富与扩展.Window函数拥有SQL语句惯有的简洁构成模式,但是其精妙的语义特征使其能代替自连接(SelfJoin)和相关子查询(SubQueries)等完成传统复杂查询的功能.在数据处理中,窗口概念的引入使得计算被应用到特定的数据集合(dataset)上,或者说是一个窗口所包含的元组(tuple)之上.在此基础上,随之产生了一系列常规分析函数.例如,平均值(average)、累积求和(sum)、最大值(max)、最小值(min)、排序(ranking)、百分比(percentile)等.这些函数都可以用一条SQL语句精确、直观、有效地表达出来.现今,主流商业数据库系统中都实现了Window函数以支持数据分析任务,比如DB2的联机分析处理(OnlineAnalyticalProcessing,OLAP)函数,Oracle的解析函数(analyticfunction)和SQLServer的Window函数等.随着互联网应用逐渐步入大数据时代,Window函数也逐渐被应用于各类互联网应用的数据管理和数据分析中,如商务智能的查询报表和各类分析应用.越来越多的企业级数据的查询和分析逐渐将旧的查询替换成Window函数的方案.Window函数在数据查询和分析中的应用使得查询处理更加高效,尤其是可以有效地消除效率低下的自连接(SelfJoin)和相关子查询(SubQueries)[1-2],而且查询处理过程中可以尽可能地减少临时表的使用.尽管Window函数在数据查询和分析中可以尽可能地提高查询效率,其执行框架也设计的足够精简,但由于其应用场景的多样性使其在实现时并没有得到足够的优化.在目前互联网应用步入大数据时代的背景下,针对高吞吐和实时响应等需求,已有的Window函数的处理性能已经出现了瓶颈.因此,针对特定的数据分析场景,需要设计出更适合Window函数执行的优化方法.1.1Window函数Window函数由一个分析函数和一个窗口定义子句构成.在标准SQL的定义中,使用窗口定义函数所作用于的上下文区间,窗口的具体规范则由一个OVER子句来定义.例1.给定一张员工工资表empsalary(如表1所示),包含3个属性,empno、depno和salary(其中empno是主键).empno指的是员工的员工编号(唯一的),depno指的是部门编号,salary指的是员工工资.下面是一条带Window函数的SQL查询语句.表示将所有员工按部门号划分,按员工编号排序,将每位员工的工资与前后20位比较,得到工资最高的员工的工资.SELECTempno,depno,salary,MAX(salary)OVER(PARTITIONBYdepnoORDERBYempnoROWSBETWEEN10PRECEDINGAND10FOLLOWING)Fromempsalary;empnoPage3如例1中的SQL语句所示,Window函数包含一个分析函数(例1的SQL语句中为MAX函数)和一个规定窗口大小的OVER子句.其中OVER子句中包含了3个组成部分:(1)PARTITIONBY子句.PARTITIONBY子句用来定义数据分区,形式为PARTITIONBYexpr_list.后面的属性值expr_list决定了数据表按照哪些属性进行划分,expr_list的值相同的元组属于同一个分区.(2)ORDERBY子句.ORDERBY子句用来定义数据排序模式,形式为ORDERBYorder_list.后面的属性值order_list决定了数据表按照哪些属性进行排序.(3)ROWS子句.ROWS子句用来定义Window函数中一个窗口的大小,形式为ROWSBETWEENpre_valueandpost_value.其中pre_value包含了UNBOUNDEDPRECEDING(窗口的起始位置为分区的第一个元组)、valuePRECEDING(窗口的起始位置为当前行的前value个元组)和CURRENTROW(窗口的起始位置为当前行)3种,post_value包含了UNBOUNDEDFOLLOWING(窗口的终止位置为分区的最后一个元组)、valueFOLLOWING(窗口的终止位置为当前行的后value个元组)和CURRENTROW(窗口的终止位置为当前行)3种.数据表中的每一个元组作为当前行都对应一个窗口,窗口的大小由OVER子句确定,其定义跟当前行相关的一个元组的集合(元组的集合通常包括一个或者多个元组,也可以是整张数据表).例1中的SQL语句部分查询结果如表2所示.salary123456789101112131415…窗口函数的计算过程包括3个过程:分区、排序和确定窗口大小.如图1所示.(1)分区是将输入元组分成相互独立的组,不同组的元组在计算时不会出现在同一窗口内,接下来的排序和确定窗口大小的工作都是在各个分区内进行,分区间相互不影响.基于这种特性,窗口函数其实非常适合于并行计算,在多核计算机上,我们可以将每个分区的任务放到不同的核上独立运行,从而提高计算效率.(2)排序则比较简单,在每个划分内部运用ORDERYBY子句指定的属性列进行排序即可,整个流程与通常使用的排序子句并无不同.(3)确定窗口大小这一步主要是在分区内为当前的元组确定窗口函数所能作用的范围,这个范围是以当前元组为中心与它相邻的某些元组构成.SQL中有两种确定范围的模式:ROW和RANGE.ROW模式比较简单,只需指定当前元组与在它之前或者之后的元组数量即可.RANGE模式则是根据当前元组的数值来确定,凡是满足数值范围的与之相邻的所有元组都构成窗口.如图2所示,当前元组为灰色部分的元组,采用ROWBETWEEN2PRECEDINGAND2FOLLOWING子句确定的窗口是从当前元组往前取两个相邻的元组和往后取两个相邻元组构成的,也就是[5,5.5,6,6.5,7].而采用RANGEBETWEEN2PRECEDINGAND2FOLLOWING子句确定窗口大小时,首先要取出当前元组的值,然后往前或者往后读取相邻元组的值,如果两个值的差不超过2,那么这个元组就包含在图2当前元组(图中的灰色部分)的取值为6(当窗口范围为2时,row模式的窗口为[5,5.5,6,6.5,7];而range模式对应的窗口为[4,4.5,5,5.5,6,6.5,7,7.5,8])Page4窗口之中,直到差值超过2也就确定了窗口的边界,也就是[4,4.5,5,5.5,6,6.5,7,7.5,8].从中我们可以看出来,ROW模式窗口数量相对固定,RANGE模式则与元组的取值紧密相关,因此窗口大小不确定.1.2相关工作当前,主流的数据仓库厂商,如Teradata、Green-plum等,针对高吞吐量、实时响应(比如作弊检测、风险控制)等应用都提供了不同程度的内数据库分析支持.Window函数针对每个窗口都会计算出一列额外的属性.GROUPBY及其3类扩展:GROUPSETS、ROLLUP和CUBE,是将数据表中的数据按照不同的划分方式进行分组,然后对每个组内的元组进行各种数据操作,其操作方式跟Window函数类似.但是,如文献[3-5]等关于GROUPBY及其扩展的优化工作,并不适用于Window函数的执行框架.主要有两方面的原因:(1)GROUPBY及其扩展的计算模式和Window函数的计算模式并不一样.Window函数在保留原始数据的基础上,计算出额外属性列,输出结果可以包含原始表的详细信息,而GROUPBY及其扩展是在数据表分组的基础上得出数据操作的信息,因此GROUPBY及其扩展的输出最多保留分组信息;(2)GROUPBY及其扩展中,数据操作是针对整个分组的,而Window函数的语意特性更强,在分组的基础上可以指定任意物理上或逻辑上的窗口大小.数据流领域也引入了窗口的概念.在数据流领域,由于数据是持续不断产生的,因此,处理的数据具有数据量大和持续更新等特性.在数据流领域,由于数据其特有的特征,将整个数据作为操作的对象是基本不可能的,常用的数据操作方法是使用滑动窗口(slidingwindow)来处理最新到达的数据,并在窗口范围内进行数据上的操作.针对数据流上的窗口操作,尤其是聚合(aggregate)操作,已经有了大量的研究工作.如文献[6]对经典的top-k问题做了研究,文献[7]则在滑动窗口中加入了语义信息.由于在数据流处理过程中,其数据访问和结果要求与关系数据库存在差异,因此许多优化策略在关系数据库中并不适用.文献[8]则针对滑动窗口计算过程中存在的很多重叠部分,提出了一种基于计算共享思想的优化方法.在连续查询领域(continuousquery),文献[9-12]也是基于这种计算共享思想对计算过程进行了相应的优化.重排序和顺序调用是Window函数执行过程中的两个重要阶段.文献[13-17]是重点关注Window函数执行优化工作的几篇文献.其中,文献[13]提出了一种基于全排序(fullsort)的重排序方法,文献[14]则在此基础上提出了更高效的哈希排序(hashsort)和分段排序(segmentsort).文献[15]则从排序顺序(sortorder)和排序共享(sortshare)的角度,提出了一种协同排序技术,其排序代价极为接近全局最优.文献[16]基于窗口分组共享的思想针对顺序调用阶段进行了优化,文献[17]基于segment树共享的思想针对顺序调用阶段进行了优化,都是一个通用框架,但不能保证每种类型的函数处理都能达到最优.1.3知识预定义为了尽可能全面、细致地量化Window函数在数据库中的执行过程的消耗,在描述Window函数的消耗模型时需要用到以下几个参数,如表3所示.参数nWiwiseriRiCCt2Window函数执行过程2.1两阶段执行框架Window函数的执行过程被分为两个部分(如图3所示):(1)重排序阶段:根据PARTITIONBY子句和ORDERBY子句将表进行划分和重排序;(2)顺序调用阶段:得到重排序后的表,对窗口内的元组依次调用转移函数(transitionfunction),依次得到转移值(transitionvalue),拥有最终计算函数(finalfunction)的Window函数通过调用最终计算函数得到每个窗口的最终结果值.如果一条查询中含有多个窗口函数,且每个函数的窗口定义都不一样,则会形成一条窗口函数链,顺序的执行窗口函数,当前窗口函数的输出结果,可以作为下一个窗口Page5函数的输入,每个窗口函数执行前都会有一个相应的重排序操作.通过分析发现,重排序阶段对于所有类型的聚集函数来说基本一致.主要的不同体现在执行的第2阶段,也就是顺序调用阶段.顺序调用实际也包含两个过程,第1个过程是顺序地接收处理每一个划分,第2个过程则顺序地将窗口函数作用于划分中的每一行对应的窗口上,这两个过程对于所有窗口函数都是一样的.但不同类型的函数在窗口上具体如何执行又各有不同,主要分为3类:分布型函数、偏移类函数和聚集类函数.(1)分布型函数,边框不会起作用,即在窗口函数的具体运算时,其窗口大小为1,也就是只包含当前行,因此计算过程非常简单,只需遍历一遍数据.即使是求百分比的函数,最多只需要再对每个分割提前做一次统计,然后这个统计值就可用于当前分割中所有行的计算,所占百分比通过当前行的值与这个统计值相除即可求出.这样对于每个分割,最多只需要扫描两遍数据,一遍用于计算统计值,一遍用于获取当前行.(2)偏移类函数,其函数意义是将划分内的所有元组向前或者向后移动一段距离,对于这类函数,只需要在计算第一个元组时,确认其位置,然后顺序从该位置往后读取即可.(3)聚集类函数计算的对象是一个集合里的所有行,与传统的聚集函数类似,只不过聚集的范围被限定在当前窗口,每个窗口聚集函数都有一个转移函数和一个可选最终计算函数与之对应.计算的过程会维护一个转移值,转移值本身可以是基本数据图4PostgreSQL中MAX/MINWindow函数在顺序调用阶段的执行过程类型也可以是抽象类型.在重排序阶段,MAX/MINWindow函数跟其他Window函数一样,主要是针对PARTITIONBY子句和ORDERBY子句对表进行划分和重排序.由于MAX/MINWindow函数并没有最终计算函数,因此每个窗口得到的最终转移值即为该窗口的最终结果值.因此,对于MAX/MINWindow函数,在顺序调用阶段,主要是对重排序后的表中的每一个窗口中的元组去顺序调用转移函数求转移值的过程.2.2顺序调用阶段的执行过程本文是针对窗口聚集函数中的MAX/MIN进行优化.在顺序调用阶段,主体的计算过程是由转移函数完成的.对于像AVG等拥有最终计算函数的Window函数,最终结果是由最终计算函数获得.对于像MAX/MIN等函数,并不拥有最终计算函数,其最终结果就是最终获得的转移值.定义1.窗口(Window).由OVER子句定义的包含一系列元组的集合(包含了一个起始位置和一个终止位置,并且拥有其对应的转移值),Wi(s,e,TV).其中Wi指一个分区中的第i个窗口,s指窗口Wi的起始位置,e指窗口Wi的终止位置,TV指窗口Wi的转移值.对于例1中的SQL查询,PostgreSQL中的Window函数在顺序调用阶段的执行过程如图4所示(有色的元组表示此窗口的当前行,黑色实体箭头表示转移值的计算过程):对于第一个窗口W1,窗口的起始位置为r1,终止位置为r11.转移函数依次作用于窗口中的每一个元组之上,获得的最终转移Page6值即是窗口W1要求的最终结果值.对于窗口W2,起始位置为r1,终止位置为r12.相对于窗口W1来说,只比其多出了位置r12处的这一个元组.因此,对于窗口W2来说,并不需要重新计算r1至r11的元组的转移值.只需将窗口W1的转移值W1.TV赋予窗口W2的转移值W2.TV,并计算r12处的元组的转移值,得到的最终转移值即是窗口W2要求的最终结果值.接下来的计算过程都是如此直到窗口W12.从窗口W12开始,窗口的起始位置不再是r1,开始逐渐依次增加.对于窗口W12,计算过程与窗口W1类似,转移函数依次作用于窗口中的每一个元组之上,最终的转移值即是要求的最终结果值.后面的W13、W14等窗口的计算过程同窗口W12类似.算法1.PostgreSQL顺序调用算法.输入:经过重排序的表T输出:每一个元组所对应的窗口的MAX/MIN函数值1.FOR表T中的每一个分区PDO2.FOR分区P中的每一个窗口WiDO3.初始化Wi.s,Wi.e,Wi.TV;4.IFWi.s==Wi-1.sTHEN5.6.7.8.ELSE9.10.11.RETURNWi.TV;PostgreSQL中的MAX/MINWindow函数,在顺序调用阶段,转移函数执行过程的具体算法如算法1所示:首先,初始化当前窗口的参数(s,e,TV),并将读指针置于窗口的起始位置.当前窗口的起始位置与上一个窗口的起始位置比较,如果位置不相同,则遍历窗口内的所有元组,并计算其相应的转移值(第8~10行).如果位置相同,则只需遍历与上一个窗口相比新增的元组,并计算其相应的转移值(第4~7行).2.3消耗模型为了更好的发现MAX/MINWindow函数在顺序调用阶段执行过程中存在的瓶颈,我们建立一个量化模型去刻画其在数据库执行过程中的消耗.首先,我们假设表中共有n个元组(n1),n个元组处在同一分区中,且在Window函数顺序调用阶段的执行过程中,每一个元组进行数据读取和转移函数计算的总消耗为C.由于表中的每一个元组作为当前行时都会唯一的确定一个窗口,因此,包含有n个元组的表,在Window函数执行过程中共有n个窗口的函数值需要计算.在此,我们假设n个窗口的大小都是w,且每个窗口的起始位置相对于上一个窗口都向下平移一个元组.则传统计算框架中,Window函数在顺序调用阶段的消耗为从中可以看出,在每一个元组的数据读取和计算消耗固定的情况下,执行过程中的瓶颈主要存在于元组重复地进行数据读取和计算,也就是在窗口头部发生变化时,上一个窗口的转移值无法重新利用,需要从头重新计算,而两个相邻窗口转移值计算时的数据大部分都是重叠的,因而计算效率非常低.当然这种默认的方式在有些情况下也是有比较不错的效率,之前求取的消耗代价nwC是在假设窗口大小固定,依次下移的前提下计算的.如果窗口定义时采用类似BETWEENUNBOUNDEDPRECEDINGandCURRENTROW的方式,即窗口大小是从第一行到当前行,那么默认的这种执行方式除了第一次需要遍历所有元组之外,每次只需要额外计算一个新的转移值即可,计算消耗为这时消耗代价仅为O(n)级别.只不过在实际应用当中采用这种定义方式的情况相比BETWEENvaluePRECEDINGandvalueFOLLOWING的定义方式要少很多,不具有代表性,我们着重讨论更为一般的情况,以后不做特殊说明都是指最为一般的情况.3基于临时窗口的MAX/MINWindow函数优化MAX/MINWindow函数是不拥有最终计算函数的Window函数.因此,每个窗口的最终转移值即是其要求的Window函数值.优化MAX/MINWindow函数的核心思想是在函数执行过程中维持一个临时窗口,其中包含了此临时窗口对应的临时转移值,用于共享计算.以此来减少在顺序调用过程中重复进行的数据元组的读取和计算消耗.3.1优化执行过程定义2.临时窗口(TemporaryWindow).临Page7时产生的包含一系列元组的集合(包含了一个起始位置和一个终止位置,并且拥有其对应的临时转移值),TW(h,t,TTV).其中h为临时窗口TW的起始位置,t为临时窗口TW的终止位置,TTV(TemporaryTransitionValue)为临时窗口TW的临时转移值.对于例1中的SQL查询,其优化算法的执行过程如图5所示(图中有色元组为每个窗口的最大值所处位置):对于第一个窗口W1,转移函数依次作用于窗口中的每一个元组之上,与此同时,并记录下图5计算过程由于R12小于TTV,因此我们只需将临时窗口的终止位置(t)的值由r11更新为r12即可.后面的窗口的执行过程与窗口W2的计算过程类似.对于窗口W12,其起始位置与上一个窗口W11相比向下移动了一个元组,但是并没有超过记录的临时窗口的起始位置,因此决定了,窗口W12中的前20个元组中的最终转移值为记录下来的临时窗口的临时转移值(TTV).对于前20行元组,我们无需重复的进行数据读取和调用转移函数,只需将临时窗口的临时转移值(TTV)赋给窗口W12的转移值(W12.TV)即可.接下来,我们只需对r22处的元组进行数据读取和调用转移函数,并更新临时窗口的终止位置.同理,窗口W13的计算过程也与窗口W12的计算过程类似.但是,对于窗口W14来说,其起始位置(r4)超过了临时窗口的起始位置(r3),因此,临时窗口已经不再适用于窗口W14的计算过程.因此,窗口W14的计算过程与窗口W1的类似,转移函数依次作用于窗口中的每一个元组之上,与此同时,并记录下最大转移值的位置(r12)作为临时窗口的起始位置(h),记录下窗口的终止位置(r24)作为临时窗口的终止最大转移值的位置(r3)来作为临时窗口的起始位置(h),记录下窗口的终止位置(r11)作为临时窗口的终止位置(t)以及记录下最大转移值作为临时窗口的临时转移值(TTV).对于窗口W2,起始位置为r1,终止位置为r12.相对于窗口W1来说,只比其多出了位置r12处的这一个元组.因此,对于窗口W2来说,并不需要重新计算r1至r11处的元组的转移值.只需将窗口W1的转移值W1.TV赋予窗口W2的转移值W2.TV,并计算r12处的元组的转移值,得到的最终转移值即是窗口W2要求的最终结果值.位置(t),记录下最大转移值作为临时窗口的临时转移值(TTV).对于窗口W15,由于其起始位置(r5)没有超过临时窗口的起始位置(r12),因此,窗口W15的计算过程与窗口W12类似.后面的窗口的计算过程以此类推.计算过程中,不仅需要更新临时窗口的终止位置,同时还需要更新临时窗口的临时转移值和其起始位置.例如,对于例1中的SQL查询,我们假设前11个窗口的计算过程如图6中所示一样(前21行中的最大值为R3的值),并且R22的值大于R3的值.因此,对于窗口W12来说,由于其起始位置(r2)并没有超过临时窗口的起始位置(r3),因此,r2处到r21处的元组并不需要重复的进行数据读取和调用转移函数,只需对r22处的元组进行数据读取和调用转移函数即可.由于R22的值大于R3的值,因此我们需要将临时窗口的临时转移值更新为R22的值,并且将临时窗口的起始位置由r3更新为r22.对于窗口W13来说,其起始位置(r3)没有超过临时窗口的起始位置(r22),因此,计算过程类似于窗口W2.同理,后面的窗口的计算过程以此类推.Page8图6更新过程算法2.TW(TemporaryWindow)顺序调用优化算法.输入:经过重排序的表T输出:每一个元组所对应的窗口的MAX/MIN函数值1.FOR表T中的每一个分区PDO2.初始化h,t,TTV;3.FOR分区P中的每一个窗口WiDO4.初始化Wi.s,Wi.e,Wi.TV;5.IFWi.s==Wi-1.sTHEN6.7.8.9.10.11.12.t←Wi.e;13.ELSEIFWi.shTHEN14.Wi.TV←TTV;15.16.17.18.19.20.t←Wi.e;21.ELSE22.23.24.25.26.27.t←Wi.e;28.RETURNWi.TV;MAX/MINWindow函数TW(TemporaryWin-dow)顺序调用优化算法在顺序调用阶段执行过程的具体算法如算法2所示:对于数据表中的每一个分区,初始化临时窗口的参数(h,t,TTV)(第2行).对于分区中的每一个窗口,初始化当前窗口的参数(s,e,TV),并将读指针置于窗口的起始位置(第4行).当前窗口的起始位置与上一个窗口的起始位置相比较,如果位置相同,则只需遍历与上一个窗口相比新增的元组,并计算其相应的转移值.与此同时,如果转移值不等于临时窗口的临时转移值,就更新临时窗口的起始位置和临时转移值.所有元组遍历结束后更新临时窗口的结束位置(第5~12行).如果位置不相同,则比较当前窗口的起始位置与临时窗口的起始位置.如果当前窗口的起始位置不大于临时窗口的起始位置,首先将临时窗口的临时转移值赋予当前窗口的转移值,并遍历临时窗口的终止位置后直到当前窗口的终止位置处的元组及计算相应的转移值.与此同时,如果转移值不等于临时窗口的临时转移值,就更新临时窗口的起始位置和临时转移值.所有元组遍历结束后更新临时窗口的结束位置(第13~20行).如果当前窗口的起始位置大于临时窗口的起始位置,遍历窗口内的所有元组,并计算其相应的转移值.与此同时,如果转移值不等于临时窗口的临时转移值,就更新临时窗口的起始位置和临时转移值.所有元组遍历结束后更新临时窗口的结束位置(第21~27行).3.2消耗模型与PostgreSQL原有顺序调用阶段的消耗模型类似,我们假设表中共有n个元组(n1),n个元组处在同一分区中,且在Window函数的执行过程中,每一个元组的数据读取和计算消耗为C.假设n个Page9窗口的大小都是w,且每个窗口的起始位置都相对于上一个窗口向下平移一个元组.更新一次临时窗口信息的消耗为Ct.优化后的方法计算效率和数据分布有一定的关系,在最好情况下是不需要重新遍历窗口,也就是说在当前窗口起始位置快要逼近临时窗口起始位置时,正好更新临时转移值,因为CCt这种情况下的消耗接近于nC.而在最坏情况下,每一次都需要重新选择临时转移值,也就是退化为没有优化的情况,消耗变成nw(C+Ct).最好和最坏不具有代表性,下面我们讨论更为一般的情况.对于第一个窗口,我们需要将从窗口起始位置到窗口终止位置处的所有元组依次进行数据的读取和计算,并且更新临时窗口的信息.因此,对于第一个窗口的消耗为其中pt指的是每次遍历一个元组时需要更新临时窗口信息的平均概率.对于后面的窗口,当窗口的起始位置没有超越临时窗口的起始位置时,共用临时窗口的信息(同时更新临时窗口的信息).当窗口的起始位置超过临时窗口的起始位置时,无可避免的需要重新遍历窗口内的所有元组.因此.剩余窗口的消耗为Costw2→wn=(n-1)p(wC+Ct+(w-1)ptCt)+其中p指的是一个窗口需要重新遍历全部元组的平均概率.总消耗为Cost=(1+(n-1)p)wC+(1+(n-1)p)Ct+令f=Cost-Costpg,则得f=(n-1)(w-1)Ctptp+(n-1)(w-1)Cp+(w-1)Ctpt+nCt+(n-1)(1-w)C.当w=1并且p=1时,f=nCt>0.当w>1时,函数f简写形式如下:由于CCt,很显然θ2>θ4,θ1>θ3.令θ4-θ1>0,化简得Cw>1时,1+较大时1+CCt(尤其是数据量足够大,致使数据库工作内存已经无法存放所有数据,使得部分数据不得不存放在磁盘上),即θ4-θ1>0成立,从而得到θ2>θ4>θ1>θ3.令θ1=200,θ2=1110,θ3=22,θ4=-1100可得如下函数图像(图7).其中横轴为p,纵轴为pt,竖轴为f.随着窗口w和数据量n的逐渐增加,θ4对整个函数下移的影响要远比其他3个参数对函数上移的影响大.因此,窗口越大,数据量越多,优化效果越明显.由于pt指的是每次遍历一个元组时需要更新临时窗口信息的概率,p指的是一个窗口需要重新遍历全部元组的概率,因此pt、p反映了一种数据分布趋势.由以上分析可以看出,数据分布与取值函数越趋于一致,优化效果会越好.3.3总结本节主要介绍MAX/MIN窗口函数的优化算法并分析其计算效率.我们的MAX/MIN窗口函数优化算法简单而有效,仅仅在PostgreSQL默认执行算法的基础之上增加一个结构用于存放临时转移值,从额外空间消耗的角度上来说几乎可以忽略.但是从时间消耗的角度上,通过我们前两部分的介绍可以知道,优化后的算法在绝大多数情况下是远好于默认执行方法,即便在最差情况下也仅仅是退化为与默认算法同等的时间复杂度.表4默认执行方式与优化执行方式消耗代价比较执行情况最好情况最差情况一般情况对于默认执行方式最好情况所采用的窗口定义形式(BETWEENUNBOUNDEDPRECEDINGandPage10CURRENTROW),我们的优化策略依然能够保证最少消耗为nC.而我们优化策略在最坏情况下,只比默认执行策略多消耗nwCt,多出的开销是为了维护临时窗口信息.最为重要的是,上述两种极端情况在实际查询当中所占的比例很低,也就是说大多数情况下,优化策略能够发挥其作用,对于系统效率的提高大有裨益.更为具体的优化的效果我们将在下一部分通过实验加以说明.4实验结果与分析4.1实验环境我们更改了PostgreSQL9.3.6的内核,实现了基于临时窗口的MAX/MINWindow函数优化算法.我们将其与MicrosoftSQLServer2012(ExpressEdition)共同部署在一台ThinkPadX220i电脑上.CPU型号是Intel(R)Core(TM)i3-2310MCPU@2.10Hz,内存4GB1333MHzDDR3.所有数据库的工作内存(work_mem)设置为500MB.4.2实验数据本文的实验数据是使用TPC-HDBGEN生成的.指令如下:生成的是TPC-H中的表“order”,指令1生成的数据集大小为170MB,包含1500000条元组,指令2生成的数据集大小是1.7GB,包含15000000条元组.4.3SQL查询语句本文实验采用的SQL查询如下所示:SELECTo_totalprice,MAX(o_totalprice)OVER(ORDERBYo_orderkeyROWSBETWEENframeoffsetPRECEDINGANDframeoffsetFOLLOWING)FROMorder;我们通过更改参数frameoffset来改变实验中窗口的大小.4.4实验对比(1)PG:PostgreSQL中原有的顺序调用算法;(2)TW:TW(TemporaryWindow)顺序调用优化算法;(3)SQLServer:MSSQLServer2012(ExpressEdition).4.5实验结果本文的实验对比方法有3种:(1)PostgreSQL数据库,原有执行框架;(2)实现了基于临时窗口的MAX/MINWindow函数优化算法的PostgreSQL数据库;(3)MicrosoftSQLServer2012(ExpressEdition).图8是本文实验采用的SQL查询在170MB数据集上的SQL查询执行时间对比图.其中横轴为frameoffset,大小从10到500,纵轴为SQL查询执行时间,单位为秒(s).由图中可以看出,采用优化算法TW的执行效率要远好于PG和SQLServer.而且,随着窗口的增大,TW的执行效率的提升越来越明显,其基本稳定在5s之内,相比之下,PG和SQLServer的执行时间已经增长到几百秒.图8MAXWindow函数执行时间(170MB)图9是本文实验采用的SQL查询在1.7GB的数据集上的SQL查询执行时间对比图.其中横轴为frameoffset,大小从10到500,纵轴为SQL查询执行时间,单位为秒(s).与图8结果类似,采用优化算法TW的执行效率要远好于PG和SQLServer.图9中3种数据库的SQL查询执行时间,相比于图8都要有所上升,这是因为数据集的增大导致了查询处理过程中相应窗口的数量也随之增加,使得查询处理时间随之上升.Page11图10是TW在不同数据集和不同的窗口大小下SQL查询执行时间结果图,其中横轴是frameoffset,纵轴是SQL查询执行时间.由图7可以看出,基于临时窗口的MAX/MINWindow函数优化算法TW,在数据集大小一定的情况下,SQL查询的执行时间随着窗口大小的变化基本维持稳定,并不会出现较大幅度的改变.相比于PG、SQLServer在数据集一定的情况下,SQL查询执行时间随着窗口的增大而呈指数级增长,TW的这一特性,在数据处理中会更加有优势.5结束语针对MAX/MINSQLWindow函数在顺序调用阶段的执行,本文提出了一种基于临时窗口的优化算法.利用执行过程中产生的一些临时结果,极大地避免了数据库中元组的重复读取和调用转移函数,从而大大提高了MAX/MINSQLWindow函数在顺序调用阶段的执行时间和效率.与现有的算法相比,该算法在保证结果正确的基础上极大提高了运行效率,其独有的特性在处理大数据时也有明显的优势.致谢北京EMC实验室的曹逾博士对本文的模型完善和实验设计提出了有益的建议.评审老师对本文提出了宝贵的修改建议.在此表示感谢!
