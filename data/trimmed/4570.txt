Page1基于变异分析和集合进化的测试用例生成方法巩敦卫2)1)(中国矿业大学计算机科学与技术学院江苏徐州221116)2)(中国矿业大学信息与电气工程学院江苏徐州221116)3)(江苏师范大学计算机科学与技术学院江苏徐州221116)4)(中国矿业大学理学院江苏徐州221116)摘要变异分析能够辅助生成有效的测试用例集,然而,高昂的测试代价,严重影响了这一技术在实际软件测试中的广泛应用.文中基于弱变异分析,研究求解测试用例生成问题的新方法,以高效地生成具有很高缺陷检测能力的测试用例集.该方法首先利用变异前后的语句,构造变异分支,并将所有变异分支集成到原程序,形成新的被测程序;然后,以测试用例集作为决策变量,根据该测试用例集对变异分支的覆盖信息,构造目标函数,建立新的测试用例生成问题的数学模型;最后,采用集合进化优化方法求解上述模型时,设计具有针对性的适应度函数和进化策略,使得一次求解该模型,生成杀死所有变异体的测试用例.将所提方法应用于13个基准和工业程序的测试,并与传统的遗传算法进行了比较.实验结果表明,所提方法能够高效地生成测试用例,且生成的测试用例具有更高的缺陷检测能力.关键词软件测试;变异测试;变异分支;测试用例生成;集合进化1引言变异测试通过向原程序人为地注入缺陷[1],以模拟软件中的实际缺陷.被注入缺陷的程序副本称为变异体.采用相同的测试输入,分别执行原程序和变异体,如果某测试用例能够从执行结果上区分某变异体和原程序,则称该变异体被杀死;如果任何测试用例都不能杀死某变异体,则称该变异体为等价变异体.变异测试常被用于评价现有测试用例集的质量;也被用于辅助生成单元测试用例,其准则为所生成的测试用例集能够杀死所有变异体.对于给定的测试用例集,其杀死的变异体数量占所有非等价变异体的百分比,称为该测试用例集的变异得分.变异得分是衡量测试用例缺陷检测能力的重要指标[2].因此,基于变异分析,能够生成具有更高缺陷检测能力的单元测试用例集.变异测试不仅可以模拟现实中的各种缺陷,还能够选择缺陷发生的位置[3].但是,实际的软件规模大、复杂度高[4],从而产生的变异体为数众多.此时,为了生成有效的测试用例集,以最大限度地杀死变异体,必须反复执行原程序和变异体,这显著增加了测试用例生成的成本,从而,严重影响了这一测试用例生成技术的实用性.变异体约简是减小变异测试代价的有效途径,然而,现有变异体约简方法,其约简力度和有效性仍需进一步提高.弱变异测试能够降低程序的执行代价,但是,其降低幅度仅为50%左右.更重要的是,现有基于变异分析的测试用例生成方法,每次仅以杀死一个变异体作为目标,生成测试用例,使得测试用例生成的效率降低.这表明,研究新的方法,以提高基于变异分析的测试用例生成效率,是非常必要的.迄今为止,相关的研究仍非常少.本文基于弱变异测试准则,研究新的测试用例生成方法,以高效地生成具有很高缺陷检测能力的测试用例.所提方法根据弱变异测试转化思想[5],将所有变异体转化为变异分支,并集成到原程序中,形成新的被测程序之后,建立新的测试用例生成问题的数学模型,并采用集合进化优化方法求解上述优化模型,以生成杀死所有变异体的测试用例.13个基准和工业程序的测试结果表明,所提方法能够有效提高测试用例的生成效率.本文第2节综述相关的研究工作,并说明本文的研究动机;第3节详细阐述所提方法,包括变异测试转化、问题的表示以及测试用例生成问题的数学模型;所建模型的集合进化求解方法,将在第4节给出;第5节通过对比实验,评价所提方法的性能;最后,第6节总结本文所做的工作,并提出后续的研究问题.2相关工作本节首先简述变异测试的思想;然后,综述现有基于变异分析的单元测试用例生成方法;考虑到进化优化在测试用例生成中已经取得丰硕的研究成果,并对基于变异分析的测试用例生成问题具有很强的指导作用,最后,阐述已有的基于进化优化的测试用例生成方法.2.1变异测试变异测试最早由DeMillo等人[6]和Hamlet[7]提出,目前,已广泛应用于C、Java、SQL等各种语言以及单元、集成等软件测试的各个层次.变异测试已经取得丰硕的研究成果,并应用于工业程序的测试[8].然而,高昂的测试代价,始终是变异测试难以回避的问题.研究合适的方法,降低变异测试代价,成为该领域的热点方向之一.通过抽样和选择变异测试方法,以减少所需杀死的变异体数量,是降低变异测试代价的有效方法.其中,抽样方法仅选择一定比例的变异体执行测试[9-10],但是,随着抽样比例的减少,变异测试的充分度将明显下降[11].选择方法通过舍弃某些变异算子,减少生成的变异体数量[12-13],然而,被舍弃变异算子的增多,将导致变异得分显著降低.此外,高阶Page3变异体虽然也能够有效减少变异体的数量[14-16],可是,高阶变异体生成的代价,将随着阶次的增多而急剧攀升.弱变异测试是另一类降低测试代价的有效方法[17].弱变异测试要求测试用例必须能够执行到变异语句,且执行变异语句后的状态发生改变,即满足可达性和必要性条件[18].而强变异测试则进一步要求改变的状态必须影响程序的执行结果,即满足充分性条件.研究表明,满足必要性条件的测试用例,能够在很大程度上满足充分性条件[19-20].绝大多数情况下,弱变异测试是强变异测试的有效替代,且弱变异测试能够节省一半的测试成本[21-22].基于弱变异测试准则,Durelli等人[23]利用现有托管执行环境和底层虚拟指令集,构建虚拟机集成的弱变异测试环境,能够显著提高变异测试效率.Kim等人[24]针对非解释性系统执行速度快的特点,建立新的弱变异测试方法,该方法降低了非解释性变异测试系统的执行代价.把变异体转化为变异分支,Papadakis等人[5]将弱变异测试问题,转化为分支覆盖问题,从而进一步提高弱变异测试的效率.Papadakis等人[25]还分析变异体所在的路径,以选择变异体执行弱变异测试,从而增强了所生成的测试用例的有效性.2.2基于变异分析的测试用例生成测试用例生成是指根据特定的测试准则,例如分支覆盖,产生满足需求的测试用例.作为直接面向缺陷的测试技术,变异测试能够辅助生成具有很高缺陷检测能力的单元测试用例.但是,基于变异测试,如何高效地生成测试用例,相关的研究成果却很少.基于约束的测试用例生成(Constraint-BasedTestdatageneration,CBT)方法是较早基于变异分析生成测试用例的研究之一,该方法将杀死变异体的条件转化为约束,并通过约束求解的方法,生成测试用例[26].实验表明,CBT生成的测试用例,能够杀死约90%的变异体[19].动态域约简(DynamicDomainReduction,DDR)方法对CBT进行改进,并通过回溯搜索,生成测试用例[27-28].但是,DDR和CBT由于采用符号执行方法,导致生成测试用例的代价高、适应范围窄.动态符号执行(DynamicSymbolicExecution,DSE)方法虽然改进了传统符号执行方法[29-30],但是,由于过分依赖约束求解器,使得DSE生成测试用例的效率尚需进一步提高.上述方法都基于程序的控制流图(ControlFlowGraph),仅考虑程序语句之间的控制依赖关系,而忽略了它们之间的数据依赖关系.同时考虑这两种关系,对DDR方法进行改进,能够提高测试用例的生成效率[31].此外,根据同一位置变异语句之间的相似性,将这些变异体组合成少数复合变异体,进一步降低了测试用例生成的代价[32].但是,上述研究在问题的求解方法上,仍局限于传统的约束求解方法,导致测试用例生成的效率难以显著提高.2.3进化优化的测试用例生成近年来,进化优化方法广泛应用于软件测试,尤其用于解决传统结构化测试用例的生成[33-41]问题.在传统的结构化测试中,Harman等人[38]利用多目标优化方法搜索测试用例,但是,每次仅针对一个测试目标,生成相应的测试用例.Fraser等人[39]利用遗传算法(GeneticAlgorithm,GA),生成高质量的测试用例集,然而,该方法目前仅应用于传统的结构化测试.Jia等人[14-15]利用进化优化方法,生成更难杀死的高阶变异体,以反映实际软件中的复杂缺陷.Fraser等人[3]利用进化优化方法,提高测试用例生成的自动化程度.Souza等人[42]统计了基于变异分析生成测试用例的相关19篇主要论文,发现采用GA的就有6篇.可见,在基于变异分析的测试用例生成问题上,进化优化已经成为主要方法.尽管如此,与传统结构化测试用例生成相比,对基于变异分析的测试用例生成问题的研究仍然很少;而且,现有的这类方法,其测试用例生成效率仍有待于更进一步提高.由于弱变异测试效率明显高于强变异测试,Papadakis等人[5]基于弱变异测试准则,构建变异分支,将弱变异测试问题转化为分支覆盖测试问题,从而,进一步提高弱变异测试效率.然而,在生成测试用例时,仍采用符号执行等复杂且低效的方法;尽管也使用了进化优化方法,但是,每次仅以一个分支作为目标,生成一个测试用例.Papadakis等人的弱变异测试转化方法非常实用,然而,为数众多的变异体导致过多的测试目标.采用进化优化方法生成测试用例时,一个个体仅表示一个测试用例;当一个个体包含多个测试用例时,相应的进化优化方法称为集合进化[43-44].集合进化非常适合于生成杀死多个变异体的测试用例.鉴于此,本文为了提高测试用例的生成效率,基于弱变异测试转化方法,建立新的测试用例生成问题的数学模型,并通过集合进化,生成杀死所有变异Page4体的测试用例.3问题建模本节基于弱变异测试转化方法,将变异体杀死问题转化为分支覆盖问题;基于转化后的分支覆盖问题,建立测试用例生成问题的数学模型.3.1变异测试转化记被测程序为P,s为P的一条语句(取其主要表达式),对s实施某变异算子,得到相应的变异语句s,用s替换P中的s,生成变异体m.根据弱变异测试准则,对于变异体m,如果存在测试用例能够执行到变异语句s,且执行该语句后的状态发生改变,即s!=s,那么,变异体m被杀死.如果将s!=s作为条件,构建分支语句b,那么,覆盖b真分支的测试用例,必然满足杀死m的必要条件,即以弱变异测试准则杀死m.表1变异分支构建原语句(s)变异算子AORBAORSAOIUAOISAODUAODSRORCORCODCOISORLORLOILODASRS将B的变异分支,依次插入到P的相应位置,使得被插入的分支,与变异前语句具有相同的可达性.这样,所有变异体转化为等量的变异分支,并全部融入到P中,即可得到一个新的被测程序P.鉴于变异分支在P中不执行任何实质性的操作,因仅需通过“!=”组合变异前后的语句s和s,就能够构建新的分支b,其中,s为变异前语句,s则为s的一条变异语句.因此,新分支的构建方法非常容易.可见,每个分支b对应一个变异体m,每个m可以产生一个b,分支b和变异体m一一对应,因此,b称为变异分支.对于P,将所有变异前后的语句进行上述组合,得到一个变异分支集B,对应的变异体集为M.为了更清晰说明变异分支的构建方法,采用MuClipse[45]的全部15类方法级(Method-Level)变异算子,针对各种语句,列出所构造的变异分支,如表1所列.例如,表1中对原语句s,a+b,实施AORB变异算子,得到一条变异后语句s,ab,组合得到变异分支b,if((a+b)!=(ab)).当然,对a+b实施AORB变异算子,还可以产生其他3条变异语句:a-b、a/b和a%b,相应地,还可以构建3个变异分支,表1中仅列出1条.a+ba+ba+b-a+ba>b!(a>b)a>ba>>ba|ba+b~a+ba+=b此,对原程序的执行不会构成任何影响.对于转化后的程序P,覆盖B的测试用例集,必然能够以弱变异测试准则杀死M.至此,杀死P的所有变异体M的变异测试问题,转化为以P的变异分支集B为目标分支的覆盖测试问题.Page5图1以三角形分类程序Triangle[14]为例,说明弱变异测试的转化过程.其中,(a)为Triangle的部分代码;利用变异测试工具MuClipse,对语句5实施ROR变异算子,得到的变异分支如(b)所示;对语句6实施AORB变异算子,得到的变异分支如(c)所示.将(b)和(c)的分支植入到原程序中,其中,(b)所示的分支被植入到(a)的语句5之前,(c)所示的分支被植入到语句6之前.将Triangle的所有可变异语句,都进行上述操作,即可得到转化后的新程序P.…1.if(a<=0‖b<=0‖c<=0){2.return4;3.}4.inttrian=0;5.if(a==b){6.trian=trian+1;7.}8.if(a==c){9.trian=trian+2;10.}11.if(b==c){12.trian=trian+3;13.}…(a)Triangle的部分代码这种转化方法能够进一步减少弱变异测试代价.覆盖P中所有变异分支的测试用例集,必然能够以弱变异测试准则杀死所有变异体.但是,P中融入大量的变异分支,使得被测程序异常复杂.事实上,选择MuClipse的所有方法级变异算子,对Triangle实施变异,共产生325个变异体,即P新增了325个变异分支.可见,该转化方法显著增加了转化后问题求解的难度.尽管进化优化方法能够生成期望的测试用例集,但是,一次运行仅生成一个测试用例,使得测试用例生成的效率大大降低.鉴于此,建立合适的测试用例生成问题的数学模型,以提高测试用例生成的效率,是非常必要的.3.2测试用例生成问题的数学模型通过变异测试转化,不需要同时执行变异体和原程序,仅需分析P中每个变异分支是否被覆盖,根据弱变异测试准则,即可判定某变异体是否被杀死.因此,覆盖B的测试用例集,就是所要生成的测试用例集.然而,对于转化后的新程序P,由于融入太多的变异分支,使得测试用例生成的效率显著降低.对于转化后的被测程序P,需要覆盖的分支集为B,包含|B|个变异分支.设测试输入x∈D,D为输入域,对于变异分支bi∈B,设x对bi真分支的分支距离为fi(x)[34].以x为决策变量,分支距离fi(x)为目标函数,记为yi,那么,yi取得最小值的充要条件是x覆盖bi的真分支.对于简单谓词的分支距离,其计算方法如表2所列;而复合谓词的计算方法则如表3所列.表3中distA(x)(distB(x))表示,以x作为测试输入,复合谓词A(B)的分支距离.对于本文如果采用“!=”连接的是两个复合谓词,例如A!=B,可以转化为(!A&&B)‖(A&&!B)的形式.分支条件a>=ba>ba<=ba<ba==ba!=b复合形式这样,覆盖分支bi的测试用例生成问题,就转化为函数fi(x)的最小化问题.由于共有|B|个变异分支,因此,共有|B|个最小化问题,其数学表示为例如,变异分支bi为“if((a==b)!=(a<b))”(如图1(b)所示).该分支条件为复合谓词,等价于“(a==b)‖(a<b)”.因此,以x为输入,其分支距离fi(x),为两个简单谓词“(a==b)”和“(a<b)”分支距离的复合形式:式(2)中,dist1分支距离,dist2fi(x)=0时,x覆盖“if((a==b)!=(a<b))”的真分支.覆盖bi的测试输入,可能同时覆盖B的其他Page6分支.因此,选取未被覆盖的变异分支bi∈B,作为下一个目标分支,生成覆盖bi真分支的测试用例,同时记录B中其他被覆盖的分支,直至B中所有分支都被覆盖.对于式(1)中的每一个最小化问题,仅生成一个测试用例.为了生成覆盖B的测试用例集,必须反复执行优化过程.下一小节将建立一个新的测试用例生成问题的数学模型,通过求解该模型,能够生成覆盖B的测试用例集.3.3测试用例集生成问题的数学模型鉴于式(1)中的决策变量x仅表示一个测试输入,因此,每次求解仅能生成一个测试用例.如果期望生成覆盖B中所有变异分支的测试用例集,需要对式(1)进行多次求解.为了提高测试用例生成效率,本节将建立一个新的数学模型,使得一次求解能够得到覆盖B的所有变异分支的测试用例集.令X=(x1m|B|,那么,X为一个测试输入集.对于变异分支bi∈B,我们期望存在能够覆盖bi的xfi(xfi(x的充要条件为Fi(X)=0.k)=0.令Fi(X)=min(fi(xm)),那么,x对于变异分支集B,令F(X)为反映测试输入集X覆盖B的函数.以X为决策变量,F(X)为目标函数,那么,F(X)取得最小值的充要条件是X覆盖B中的所有变异分支,即F1(X),F2(X),…,F|B|(X)同时取得最小值.因此,基于变异测试的测试用例生成问题的数学模型可以表示为minF(X)=(F1(X),F2(X),…,F|B|(X))s.t.X=(x比较式(1)和(3)可知,①式(3)的决策变量包含若干测试输入,而式(1)的决策变量仅表示一个测试输入;②式(3)以X覆盖B的所有变异分支的情况,作为优化目标,而式(1)仅以x覆盖变异分支bi的情况,作为优化目标;③对式(3)的一次求解,将生成一个覆盖B的测试用例集,而对式(1)的一次求解,仅生成覆盖bi的一个测试用例,这样一来,为了生成覆盖B的测试用例集,需要多次求解式(1).由此可知,通过求解式(3),能够生成覆盖所有变异分支的测试用例集,它们即可杀死所有的变异体.下一节将给出通过集合进化求解式(3),生成测试用例的方法.4基于集合进化的测试用例生成本节阐述用于求解式(3)的集合进化优化方法,包括适应度函数、进化算子以及算法步骤.4.1适应度函数根据程序输入的类型,采用合适方法,得到与某一决策变量取值对应的个体编码.不失一般性,仍记决策变量X=(x覆盖B的所有变异分支的情况,可以通过∑反映.考虑到∑价X的性能,对∑要的.记归一化∑此作为X的适应度函数,那么,Fit(X)可以表示为由式(4)可知,X中某一分量越接近于覆盖B的某一变异分支,那么,Fit(X)越小;当X中的某一或多个分量覆盖B的所有变异分支时,Fit(X)=0.需要说明的是,在变异测试中,对于某一被测程序,往往存在一或多个等价变异体.利用第3.1节的转化方法,得到的转化后程序中,也存在一定数量的变异分支,使得任何测试用例都不可能覆盖它们,这类变异分支称为不可覆盖变异分支.对于不可覆盖变异分支,不存在X,使得Fit(X)=0.为了避免不可覆盖变异分支对测试用例生成的影响,在生成测试用例之前,我们通过静态分析方法,排除这些变异分支.4.2进化算子本小节将设计集合进化算子,包括交叉、变异以及选择算子.(1)交叉算子交叉是产生新个体的主要来源.鉴于式(3)的决策变量包含若干测试用例,因此,不仅考虑个体之间的交叉,还考虑个体内部的交叉,以提高测试用例的性能.对于个体X1=(x12,…,x2x22,…,m.选择x1的交叉如图2所示,图中,通过交叉产生的新个体分别记为X1和X2.Page7X1=(x11,x1X2=(x21,x2对于个体X1=(x1i,…,x1lx12两个测试输入.选择x1k部的交叉如图3所示.记通过交叉产生的两个新的测试输入分别为x1i和x1x1j,得到的新个体分别为X1和X1.x1i=(x11i,x12x1j=(x11j,x12(2)变异算子在集合进化中,变异是产生新个体的辅助手段.对于个体X1,首先,选择测试输入x1作,即生成新的测试输入x1用x1i代替X1中的x1(3)选择算子在集合进化中,通过选择算子,确定遗传到下一代的个体.交叉和变异操作不断产生新的个体,并加入到当前种群中.选择这些个体进入下一代的方法是:首先,计算这些个体的适应值;然后,对种群中个体按照适应值大小排序;最后,选择适应值最小的若干个体,形成下一代种群.4.3算法步骤本文提出的测试用例生成过程,如算法1所示.算法1.基于集合进化的测试用例生成.输入:集合进化参数输出:测试用例集BEGINsetParameters();//参数设置initialize(pop);//初始化种群generation←0;//进化代数DOWHILE(generation<max_allow_evolve)ENDWHILEEND5实验本节通过实验评价所提方法的性能,首先,列出需要解决的问题;然后,介绍采用的基准与工业程序;接着,说明实验过程;最后,分析实验结果.5.1需要解决的问题本文提出一种基于变异分析和集合进化的测试用例生成方法,为了评价该方法的性能,需要回答如下4个问题:(1)所提方法能否降低测试用例生成的成本?这里,通过生成测试用例需要的迭代次数和时间,反映测试用例生成的成本.(2)生成的测试用例能否基于弱变异测试准则有效杀死变异体?这里,通过基于弱变异测试准则,被杀死的变异体个数与非等价变异体个数的比,反映测试用例杀死变异体的有效性.(3)生成的测试用例能否基于强变异测试准则有效杀死变异体?这里,通过基于强变异测试准则,被杀死的变异体个数与非等价变异体个数的比,反映测试用例杀死变异体的有效性.(4)集合进化参数的取值是否影响所提测试用例生成方法的性能?鉴于集合规模是集合进化特有的参数,因此,这里通过集合规模的取值对生成测试用例的性能,反映集合进化参数对所提方法的影响.5.2被测程序本节选择13个Java源程序,作为被测程序,如表4所列,表中J1、J2和J3选自文献[5]的变异测试实验程序;J4不但是[5]的实验程序,也是文献[14-15]的案例分析程序;J5是文献[46]的变异测试实验程序;J6~J12是Apache开源项目的程序类①,其中,J6、J8、J9、J12和J13曾作为文献[3]的部分实验程序.在所有13个实验程序中,J1~J5是变异测试常用的基准程序;J6~J13常作为变异测试或其他软件测试的部分程序.利用Metrics1.3.6统计程序的基本信息②,可以得到,这13个程序共包含2412行代码,其中,J1~J5包含166行,而后8个程序类占90%以上的代码行数.此外,这些实验程序共包含151个方法.鉴于这些方法中的多数为形如“getXXX()”、“setXXX()”的简单方法,因此,仅测试46个较复杂的方法.采用MuClipse1.3的所有方法级(Method-Level)变异算子,共生成4320个变异体.①②Page8表4被测程序被测试个数IDJ1J2J3J4J5J6J7J8J9J10J11J12J135.3实验过程实验的运行环境为Intel(R)Core(TM)2DuoCPUE7400@208GHz2.79GHz,2.00GB内存,MicrosoftWindowsXPSP3操作系统,以及EclipseSDK4.2.2集成开发环境.变异体的执行和强变异测试结果的统计,都采用MuClipse工具.基于JUnit4①框架,每个测试类封装若干测试方法,每个测试方法包含多个形如“assertXXX()”的测试用例.基于弱变异测试转化方法,首先,对每个被测程序运行MuClipse,以生成所有的变异体;然后,对变异体生成过程中的日志文件“mutation_log”自动解析,并构造相应的变异分支,得到变异分支集B;最后,将B中所有分支依次插入到原程序P中,得到转化后的新程序P.基于第4节的方法,开发实验的原型系统,以生if((a==b)!=(a<b)){FX[22]=0;trian=trian+1;图4实例代码2111221252213346成期望的测试用例.该原型系统包含10个基本类和36个方法,分别实现基于GA和本文方法的测试用例生成.鉴于GA是一种常用的优化方法,而且,目前GA已经作为基于变异分析的测试用例生成的主要方法[3,47-51],因此,利用本文方法和GA分别生成测试用例,并进行相应的实验分析和比较.为此,将式(1)中的目标函数归一化为fiti(x)=1-e以此作为GA中进化个体x的适应度函数.图4以分支语句“if(a==b){trian=trian+1;}”(图1中(a)的5~7行)为例,列出实验的部分实例代码.其中,(a)为利用GA生成测试用例的部分实例代码;(b)为采用本方法生成测试用例的部分实例代码.(a)中数组fx[i]与3.2节中的fi(x)相对应,用于记录对应变异分支的分支距离;(b)中FX[i]与3.3节中的Fi(X)相对应,用于记录对应变异分支的分支距离.(b)本文方法生成测试用例①http://www.junit.orgPage9采用GA生成测试用例时,设当前目标分支为fx[11]所对应的变异真分支,当测试输入为x=(3,2,4)时,fx[11]=1,适应度函数fit11(x)=1-e-1;通过相应的遗传操作后,当x=(3,3,4)时,fx[11]=0,适应度函数fit11(x)=1-e-0=0;此时,fit11(x)取得最小值,即fx[11]所对应的变异真分支被覆盖.采用本文方法生成测试用例时,由于X包含若干测试输入,依次运行这些测试输入,如果,X能够使所有FX[i]都取“0”,那么,∑FX[i]=0,适应度函数Fit(X)=1-e-0=0,取得最小值,即X覆盖了所有变异真分支.GA和本文方法相关参数的取值如表5所列,表中,pcr_inter_set表示个体之间的交叉概率,pcr_inner_set表示个体内部的交叉概率;pcross表示GA的交叉概率;pmutation表示GA和集合的变异概率.此外,这两种方法的种群规模均为100.为了得到性能优越的算法参数,经过多次实验运行确定一组优化的参数取值,如表5所列.当然这些算法的取值并非最优,事实上,对该方法参数取值的优化,已经超出本文的研究范围.表6生成测试用例需要的迭代次数和时间IDJ1J2J3J4J5J6J7J8J9J10J11J12J13Sum.36383.2132670.80由表6可知,①对于所有被测程序,采用本文方法,共生成233个测试用例,迭代次数为3258.0,耗时为50304.44ms;采用GA共生成247.8个测试用例,迭代次数为36383.2,耗时132670.8ms,迭代次数和耗时分别为本文方法的16.3和2.13倍;②迭代次数比最大的程序是J10,为50.2,说明采用本文方法,能够大幅度降低生成测试用例需要的迭代次数;③时间比最大的程序是J7,将近7,说明采用本参数pcrosspmutationpcr_inter_setpsel_cr_inner_setpcr_inner_setsizepopulation5.4结果与分析对转化后的实验程序,利用GA和本文方法,分别生成测试用例,并回答第5.1小节提出的4个问题.(1)测试用例生成的成本为了评价不同方法生成测试用例的成本,分别采用GA与本文方法,生成测试用例,统计生成这些测试用例需要的迭代次数和时间(单位:ms).实验中,根据GA生成的测试用例数量,设置本文方法中集合的规模.10次实验结果的平均值,如表6所列,表中,迭代次数(时间)比是GA生成测试用例需要的迭代次数(时间)与本文方法的比值.本文方法时间/ms27.1743.39116.373504.415128.57499.898634.918887.48325.89233.6122699.5552.64150.5650304.44文方法,能够显著减少生成测试用例需要的时间.上述实验结果表明,采用本文方法生成测试用例,需要的成本明显低于GA.(2)测试用例对弱变异测试的有效性根据弱变异测试转化方法,测试用例对变异分支的覆盖率,能够反映对弱变异测试的有效性.表7列出了不同程序的变异分支,以及不同方法生成的测试用例对变异分支的覆盖情况.Page10表7测试用例对变异分支的覆盖情况IDJ1J2J3J4J5J6J7J8J9J10J11J12J13Sum.由表7可知,①13个被测程序共有4320个变异分支,其中,不可覆盖变异分支有390个;②采用GA生成的测试用例,覆盖了4320-390=3930个可覆盖变异分支中的3892.6个,平均覆盖率为99.47%;③采用本文方法生成的测试用例,覆盖了3893.9个变异分支,平均覆盖率为99.49%.这说明,基于弱变异测试准则,本文方法得到变异测试有效性不弱于GA.表8测试用例对强变异测试的有效性GAIDJ1J2J3J4J5J6J7J8J9J10J11J12J13Sum.由表8可知,①采用两种方法生成的测试用例,均能杀死超过95%的变异体,其中,GA生成的测试用例,能够杀死3568.3个变异体,变异得分为97.64%,而本文方法生成的测试用例,能够杀死3576.4个变异体,变异得分为97.92%;②采用本文方法生成的测试用例,对于程序J1、J3和J6,得到100%的变异得分,对程序J9的变异得分最低,为95.25%;③利用GA生成的测试用例,对于程序J1和J6,得到100%的变异得分,对程序J3则取得GAAvg.=99.47(3)测试用例对强变异测试的有效性基于强变异测试准则,分别采用GA和本文方法生成的测试用例,执行变异测试,根据被杀死的变异体个数与非等价变异体个数的比,计算变异得分,如表8所列.鉴于强变异测试准则杀死变异体的条件,强于弱变异测试准则,因此,表8中等价变异体的个数为642,多于表7中不可覆盖变异分支的个数.变异得分/%100.00100.00Avg.=97.6498.17%的变异得分,对程序J9的变异得分最低,为95.35%.这说明,基于强变异测试准则,采用本文方法生成的测试用例,总体上其有效性不低于GA.(4)集合规模对本文方法性能的影响测试用例的数量和质量决定测试的成本和有效性[52].第1部分的实验结果表明,采用本文方法,能够生成更少的测试用例,从而降低了变异测试的成本.鉴于本文方法生成测试用例的个数,与集合规模Page11密切相关,因此,本部分考察集合规模对本文方法性能的影响,并基于此,设定集合规模的合理取值.通过设置集合规模的不同取值,生成不同个数表9最小测试用例生成成本及其有效性IDJ1J2J3J4J5J6J7J8J9J10J11J12J13Sum.时间/ms28.5651.4343244.7811330.4031850.14100424.63由表9可知,①对于所有13个被测程序,采用本文方法,生成的测试用例最少为182个,比表6中的本文方法减少了51个;②本文方法生成测试用例需要的迭代次数略高于表6中的本文方法;③对于所有被测程序,本文方法生成最小测试用例,需要的时间略多于表6中的本文方法;④采用本文方法生成的最小测试用例,虽然能够保持与表7中本文方法相同的变异分支覆盖率,但是,强变异得分略低于表8中的本文方法.这说明,无论是迭代次数还是时间,集合规模确实影响本文方法生成测试用例的性能;小的集合规模虽然生成的测试用例个数少,但是,生成这些测试用例需要的迭代次数和时间均增加,使得测试用例生成的成本也增加.通过上述实验结果与分析,可以得到如下结论:采用本文方法生成测试用例,能够有效降低测试用例生成的成本,且生成的测试用例对于弱变异和强变异测试准则都有效.此外,集合规模也影响变异测试的执行成本和测试用例生成成本.6总结尽管弱变异测试能够降低变异测试的成本,但是,如何借助弱变异测试准则,以高效生成具有很高缺陷检测能力的测试用例,至今缺乏有效的方法.本文基于弱变异分析,研究测试用例生成问题,建立了一种新的测试用例生成问题的数学模型,并的测试用例,统计生成这些测试用例需要的迭代次数和时间,此外,计算这些测试用例的分支覆盖率和变异得分,如表9所列.287.165927.556027.92747.50410.54275.9763.01179.67提出了用于求解上述模型的集合进化方法,以生成期望的测试用例.主要贡献包括:(1)以若干测试用例形成的集合,作为决策变量,以这些测试用例对变异分支的覆盖情况,作为目标函数,建立了本文测试用例生成问题的数学模型,使得通过对该模型的求解,能够生成杀死所有变异体的测试用例;(2)提出了采用集合进化方法求解上述模型时,适应度函数和进化算子的设计方法,其中,适应度函数与归一化后的目标函数密切相关,进化算子不但包括个体之间和内部的交叉,还包括个体变异;(3)通过将所提方法应用于13个基准和工业程序的测试中,并与GA进行比较,从测试用例生成成本、测试用例对弱变异和强变异测试的有效性多方面,评价所提方法的性能.此外,还考察了集合规模对本文方法生成测试用例性能的影响.需要说明的是,本文方法的集合规模在整个进化过程中是不变的,而集合规模却影响本文方法生成测试用例的性能.如果采用合适的策略,在种群进化过程中,变化集合规模,将能够进一步降低测试用例生成的成本,从而提高本文方法的性能,这是需要进一步研究的问题.此外,本文方法的性能,仅通过较小规模的被测程序评价,在规模更大、更复杂程序中的应用,也是需要进一步研究的问题.致谢各位审稿专家对本文提出了宝贵评审意见,这些评审意见对提高论文水平具有很大的帮助.编辑付出了辛勤工作.在此一并致谢!Page12
