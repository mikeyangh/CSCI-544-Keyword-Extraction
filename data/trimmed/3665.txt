Page1基于程序特征谱整数溢出错误定位技术研究惠战伟黄松嵇孟雨(解放军理工大学指挥自动化学院南京210007)(全军军事训练软件测评中心南京210007)摘要随着软件业的飞速发展,人们对软件质量的要求也越来越高.整数溢出错误以其高危性和隐蔽性成为影响软件安全性和可靠性的重要因素之一.如何准确定位整数溢出错误是软件安全领域研究的热点.论文改进了现有错误定位模型,构建了整数溢出错误定位模型INTRank.实验结果表明:基于INTRank模型的语句可疑度估计方法可以较为准确地计算语句可疑度,使得程序员能够按照基于语句可疑度的优先级顺序检查源代码,找出导致整数溢出错误的原因,同时本文方法具有较低的漏报率.关键词整数溢出错误定位;程序特征谱;定义使用对覆盖;分支覆盖1引言对于应用于航空航天、过程控制、核子能源、交通运输和医疗卫生等任务关键领域的软件,其计算结果的正确性是可靠性和安全性的关键部分.整数溢出错误是导致软件计算出错的原因之一.由于检测每个算数操作结果的代价太大,无法承受,许多商业软件中的整数溢出错误基本上没有得到有效检测.若程序对一个整数求出了一个非期望值,并且这些非期望值被用于数组索引或者循环变量等情形时,就会产生软件安全漏洞.这些安全漏洞通常会导致灾难性的后果.如1996年6月4日欧洲Ariane5火箭爆炸事故[1]和2004年12月25日Comair航空Page2公司的机组调度软件崩溃[1]都是由整数溢出错误引发的.整数溢出错误在程序运行时存在数据流和控制流两种传播形式,并且在一组测试执行中,程序正常执行和异常终止执行有可能同时存在.本文基于上述两方面的考虑实现了对现有错误定位模型的改进,提出了一种新的错误定位模型INTRank.本文通过实验表明:使用基于INTRank的方法有助于程序员按照一定的优先级顺序检查代码,可以为其提供有效的诊断线索;基于INTRank模型的语句可疑度估计方法提高了定位整数溢出错误的准确率,从而提升了软件开发和维护的效率,同时整数溢出错误的漏报率也显著降低.2相关工作2.1整数溢出错误定位主要有以下3种类型:(1)监控系统运行时的指令操作.按照整数溢出错误的特征制定一定的判定准则,在程序运行时监控整数溢出错误是否发生.例如南京大学陈平等人[2]研究的BRICK可以实时监控程序运行中所有运算操作,利用一定的判定机制检测并定位整数溢出错误;目前针对整数溢出错误定位的检测和定位方法以上这些技术实质上都是用整数溢出的静态或国防科学技术大学卢锡城等人[3]利用程序语言的抽象语义设计实现了一个自动化整数出错误测试系统.(2)利用污点分析技术或者类型推理技术找到发生整数溢出错误的位置.例如Ceesay等人[4]通过一个基于Cqual[5]的静态工具来追踪不可信数据;Ashcraft等人[6]采用基于程序员编写的编译扩展来追踪不可信数据,并在追踪过程中检测程序错误.以valgrind[7]、memcheck[8]和Aftersight[9]等系统为代表的动态污点追踪与传播技术,可以在不需要任何源码的情况下,运行时检测程序执行路径中是否存在如下错误:对未初始化内存的引用、悬挂指针和内存泄漏等.防护机制.(3)安全整数类、C编译器扩展等整数溢出错误例如IntSafe、SafeInt[3]等整数溢出编程防护机制被集成到编译器中帮助程序员避免不安全的整数操作.者动态规约作为判定依据直接定位整数出错误发生的位置,这种方法有明显的局限性,如定位错误类型有限,存在不同程度的漏报率以及无法向程序员提供诊断线索等问题.2.2软件错误定位方法为了解决错误定位过程中消耗时间多的问题,研究人员提出了多种自动化的错误定位技术,目前有多种自动化软件错误定位技术分类方法.按照获取错误定位所需数据方法的不同,可以分为基于程序特征谱(Spectra-BasedFaultLocalization,SBFL)的定位技术和基于模型(Model-BasedFaultLocali-zation,MBFL)的定位技术.本文采用Wong等人[10]的分类方法,基于程序特征谱错误定位技术中与本文相关的两种代表性的错误定位技术包括:(1)基于程序特征谱覆盖统计的错误定位技术Tarantula[11]是一种基于可执行语句命中谱的自动化错误定位技术.Tarantula利用测试用例产生的执行追踪信息(程序特征谱)和执行结果信息(失效或通过),计算每个语句的可疑度.虞凯等人[12]利用多种程序特征谱模型,考虑控制与数据依赖关系捕捉程序的异常行为,在可疑度估计阶段,虞凯等针对两种缺陷类型分别建立可疑度计算模型CDBug和DDBug;最后将这两种计算模型整合,可以在预先不知道程序所包含缺陷类型的情况下确定语句的可疑度.(2)基于程序特征谱比较的错误定位技术NNQ[13](NearestNeighborQueries)是Renieris和Reiss提出的基于程序特征谱比较的错误定位方法.NNQ方法假设存在有一个失效运行和许多成功运行,运用一种距离度量方法,搜索与失效运行最“相似”的成功运行,比较这两种运行,排除同时被成功运行和失效运行所覆盖的语句,最后产生一个包含可疑语句集的报告.NNQ采用Hamming距离和排列距离两种方法度量两个程序特征谱之间的相似度.程序员检查生成的可疑语句集,如果错误语句确实存在于可疑语句集,那么错误定位成功;如果可疑语句集中没有错误语句,那么首先通过构造程序依赖图(图的节点是语句,边包括数据依赖边和控制依赖边),检查其它节点中最近节点,直至找到错误语句.这种方法的优点是可以利用最近邻居模型有目的地选取用于错误定位的测试用例,而缺点是往往错误语句不会被可疑语句集包括,程序员需要检查更多的代码才能定位错误语句.基于程序特征谱软件错误定位技术是一种利用Page3程序的运行覆盖信息和运行结果反向推理程序失效原因的错误定位方法.本文将基于程序特征谱的错误定位用于整数溢出错误定位,目的是解决现有整数溢出错误定位技术不能有效地支持程序员调试修改程序的问题.3基于程序特征谱整数溢出的错误定位方法3.1问题分析首先本文通过一个引例(表1)说明现有基于程序特征谱的错误定位模型被用于定位整数溢出错误表1引例mid.c#include〈stdio.h〉main(intargc,charargv[]){intx,y,z,m;if(argc<4){fprintf(stderr,”Error\n”);exit(1);}x=(shortint)atoi(argv[1]);//截断错误7y=atoi(argv[2]);z=atoi(argv[3]);m=z;if(y<z){if(x<y)m=y;elseif(x<z)m=x;}elseif(x>y)m=y;elseif(x>z)m=x;printf(“%d\n”,m);}T1:x=7,y=5,z=2T2:x=1,y=2,z=3T3:x=-317696,y=2,z=-63579T4:x=2,y=5,z=7T5:x=-327696,y=-65579,z=-3控制依赖(分支)T1T2T3T4T5表2LOUPE和CP计算分支可疑度和定义使用对可疑度(11,12)(11,16)(12,13)(12,14)(14,15)(16,17)(16,18)(18,19)时,存在准确率低的问题,引例来自乔治亚工学院①.用LOUPE模型[12]和CP模型[14]分别计算引例中语句的可疑度,本文发现:分别按照两个模型计算错误语句7的可疑度时,语句7的可疑度都不为最大值.下面分别分析LOUPE模型和CP模型不能准确定位整数溢出错误的原因:(1)LOUPE模型基于如下假设,即程序错误发生后,其直接控制依赖或者直接数据依赖的语句“立刻”导致程序状态发生偏差.LOUPE模型中的非分支判断语句的可疑度值和包含该语句的定义使用对可疑度的平均值有关;而分支判断语句的可疑度计算还需考虑其分支的可疑度.如表2所示,语句14LOUPE模型分支可疑度/CP模型分支可疑度①http://www.static.cc.gatech.edu/aristotle/Tools/Aris-totle/samples/mid.c.Page4数据依赖(定义使用对)T1T2T3T4T5(7,12,x)(7,14,x)(7,15,x)(7,16,x)(7,18,x)(7,19,x)(8,11,y)(8,12,y)(8,13,y)(8,16,y)(8,17,y)(9,10,z)(9,11,z)(9,10,z)(9,14,z)(9,18,z)(10,20,m)(13,20,m)(15,20,m)(17,20,m)(19,20,m)ResultPPFPF注:“”表示程序分支或定义使用对被测试用例覆盖.测试用例与表1相同.(s14表示语句14)所在定义使用对(9,14,z)和(7,14,x)的可疑度值都为0.707,按照LOUPE模型计算suspd(s14)=(0.707+0.707)/2=0.707,另外分支判断语句14仅存在分支(14,15),且分支(14,15)的可疑度为0.707,所以按照LOUPE计算模型suspc(s14)=0.707-0=0.707.susp(s14)=max(suspc(s14),suspd(s14))=0.707.因为包含语句7(s7表示语句7)的定义使用对(7,18,x)、(7,19,x)的可疑度都为0,在取平均数时对语句7可疑度值的计算产生干扰,所以真正的错误语句s7的可疑度值为suspd(s7)=(0.707+0.707+0.707+0.408+0+0)/6=0.422(因为s7为非分支判断语句,所以仅考虑suspd(s7)),0.422并不是最大可疑度值.(2)CP模型仅考虑控制流传播,导致模型只能分析到基本块层次,对于基本块中的语句则不能很好地区分可疑度.如表1所示,语句7~语句10属于同一个基本块,所以使用CP模型计算这些语句的可疑度值的结果相同.并且因为CP模型仅考虑影响控制流的错误,所以影响控制流的分支判断语句12的可疑度为1(为最大值),如表3所示,程序正是执行到语句12才与正确的控制流发生偏离.3.2前提假设在程序执行过程中,错误语句会影响程序的某种状态(值或控制流),然后这种错误的转换会通过程序的继续执行,将受影响的程序状态传播至程序最终产生失效的位置[15].如表1所示,T5:x=-327696,y=-65579,z=-3为失效测试用例,原因是在程序入口处对变量x赋值时,由于使用强制类型转换(atoi()函数返回值为int型),将输入参数由int型转换为shortint,由于输入参数x=-327696<-32768(shortint型的最小值),满足了触发截断错误的约束条件,程序发生截断错误,使得x实际接受的值为-16(被影响的程序状态).错误的x值被用于if条件语句作为控制流的判断条件,最终导致程序失效.控制流分析变量名定义定义使用分析如表3所示,当程序执行失效测试用例T5时,控制流与预期的正确执行之间发生偏差,正确执行应该是(4,7)→(11,12)→(12,13),但是实际执行为(4,7)→(11,12)→(12,14)→(14,5);同时变量x、z的使用语句也与正确的执行不一致,如表3所示.因此整数溢出错误发生后控制流和数据流都有Page5可能发生偏差,而且程序错误语句往往与程序发生状态偏差的位置存在一定的“传播距离”.因此可以得出以下结论:(1)在程序执行过程中,整数溢出错误语句会对程序状态产生影响,而错误状态的传播则会通过数据流或者控制流.(2)失效测试用例所覆盖的分支或者定义使用对中,存在某个分支或者定义使用对的可疑度为最大值.如表2所示,定义使用对(9,14,z)和分支(14,15)分别为失效测试用例T5所覆盖的定义使用对和分支,同时他们的可疑度值都为最大值1.基于以上两点,可以确定整数溢出错误定位模型的前提条件:(1)程序错误状态传播方式包括数据流传播和控制流传播.所以本文同时建立基于定义使用对覆盖特征谱和基于分支覆盖特征谱的错误定位模型,最后将两种模型整合.(2)在程序执行过程中,由于程序的错误状态在语句之间通过数据流或控制流传播,因此程序语句可疑度之间存在相关性.同时,可以得到本文方法的应用范围:(1)如果整数溢出错误发生后程序仍得出正确结果,则此方法无效.(2)如果整数溢出错误发生后立刻对程序执行状态产生影响,或者错误语句相对独立(即与其他语句不存在依赖关系),则此方法与现有方法相比没有明显优势.3.3本文方法在3.2节基础上本文提出一种面向整数溢出错误的错误定位模型INTRank,如图1所示.INTRank模型具体分为以下5个步骤:(1)收集程序特征谱信息.(2)计算分支和定义使用对的可疑度.我们选取Ochiai公式[16]作为分支和定义使用对的可疑度计算公式,如下所示:sim(e)=a10其中,a10表示覆盖到边e的失效测试用例数,a11表示覆盖边e的成功测试用例数,a00表示未覆盖边e的失效测试用例数.相似性系数公式Ochiai原本被运用于植物学分类领域,文献[16]中Abreu等人将现有的相似性系数公式用于软件错误定位,比较发现Ochiai的性能一直优于其它相似性系数公式.(3)计算错误传播率.错误传播率是指程序错误状态经过某分支(或者定义使用对)传播影响程序状态的可能性.如表2中,定义使用对(8,11,y)和定义使用对(9,11,z)的可疑度都为0.632,所以定义使用对(8,11,y)的错误传播率:prob(8,11,y)=suspdu-pair(8,11,y)(4)建立语句可疑度之间的线性关系.本文借鉴CP模型的方法用线性关系近似表示语句可疑度之间存在的相关性.但是与CP模型不同,本文考虑在程序执行中程序错误状态终止传播情形(例如程序异常终止),因此对程序中任意语句s在整数溢出错误传播过程中的情形做以下假设:情形1.程序执行过程中,程序的错误状态经语句s传播至下一个语句s,语句s为语句s在分支覆盖图或者定义使用对覆盖图中的子节点.情形2.程序执行过程中,程序的错误状态在语本文将两种情形的概率之和作为语句s的可疑句s处终止.度值.本文将程序分支覆盖图和定义使用对覆盖图抽象为一个有向无环图G,将错误状态传播抽象为错误状态在G中节点向相邻节点迁移.Page6假设本文得到节点A所有出边和入边的可疑度,分别是入边suspedge(e1),suspedge(e2)和出边suspedge(e3),suspedge(e4),如图2所示.对于情景1,则用全概率公式表示节点A的可疑度susp(1)E)susps(E),这里P(A|D)表示节点D被错误状态影响时,错误状态由A迁移至D(即通过e3传播)的概率,即错误传播率.P(A|D)susps(D)表示节点D被错误状态影响时,节点A包含缺陷的可能性,同理P(A|E)susps(E)表示节点E被错误状态影响时,节点A包含缺陷的可能性.这里P(A|D)=prob(e3),P(A|E)=prob(e4).因此对于情形1,susp(1)prob(e4)susps(E).对于情形2,由于节点A无子节点,本文直接将包含节点A的所有入边的可疑度求和作为节点A的可疑度,susp(2)直觉上在有向无环图G中,包含节点A的所有边中,入边数越多,则发生情形2的可能性越大,同样出边数越多情形1发生的可能性越大,故本文得到式(1):susps(A)=ein其中情形1的可能性为eout点A的出边数与包括节点A的所有边数之比;情形2的可能性为ein数与包括节点A的所有边数之比.当eout例如节点A为程序出口语句,或者在执行所有测试用例时程序都异常退出,当ein节点A无入边,例如节点A为程序入口语句.按照式(1),本文将程序中每个语句的可疑度写成方程组的形式.分别在数据流和控制流情形下建立关于语句可疑度的线性方程组,并将可疑度计算过程转化为求解n元线性方程组问题,使用高斯消元法求解方程组.(5)诊断报告.①模型整合由于不知道整数溢出错误发生后错误状态是通过控制流还是数据流传播,对于语句ni,本文使用式(2)计算最终语句ni的可疑度.susp(ni)=max(suspdu(ni),suspb(ni))(2)式(2)表示语句ni的可疑度为suspdu(n1)(数据流传播)和suspb(ni)(控制流传播)中可疑度较大的值.②特殊情况处理若语句ni不属于任何定义使用对,则suspdu(ni)=0;若语句ni不属于任何分支,则其suspb(ni)=0.③语句排序本文用秩(rank)表示语句在诊断报告中的排名,秩越小表示被程序员检查的优先级越高.本文采用last-line策略处理语句可疑度值相同的情况,即对于所有可疑度值相同的语句在取初始排序中最后一个语句的秩作为这些语句的秩.表1中本文使用INTRank模型计算语句可疑度,错误语句7的可疑度为0.421,为第二大的可疑度值.4实验评价4.1实验概述本文选择两个任务关键软件(tcas和schedule)作为被测程序,tcas和schedule均来自SIR的西门子测试套件①.实验的软件环境是CentOS4.8操作系统,JDK1.6.0_13,glibc2.2.3;硬件环境是DellOPI-PLEX755,Intel双核处理器.本实验环境中整型变量取值范围如表4所示.我们使用WET②运行架构收集分支和定义使用对覆盖信息.①②Page7整数类型shortint4.2实验数据4.2.1故障注入由于tcas程序中主要是逻辑运算,无内存使用函数,并且只有少量算数运算,因此本文在tcas中仅注入截断错误,即将int型强制转换为shortint.由于变量Own_Tracked_Alt和Other_Tracked_Alt分别表示为己方飞机所在海拔高度和被侦测飞机所在海拔高度,获取极端数据的可能性大(整数溢出错误的发生往往与输入极端数据有关[3]),所以本文分别在这两个变量的定义语句和使用语句注入截断错误.注入故障的策略主要分为单故障注入和多故障注入.v1~v6为单故障版本,v7~v19为多故障版本.schedule中使用了动态链表数据结构,所以本文选择最容易引发内存安全问题的malloc()函数和最容易引发算数溢出的计数器变量(n变量和mem_count变量)注入整数溢出错误.本文在schedule中注入了算数溢出和符号错误,v1~v6为单故障程序版本,v7和v8为多故障程序版本.4.2.2测试数据本文从tcas/testplans.alt/testplans-bigcov中选择suite.271作为初始测试用例,将每个测试用例中的第4个和第6个参数同时加上32767,例如97611537839010002641741100转化为9761138145390337672641741100.这样参数变量Own_Tracked_Alt和Other_Tracked_Alt的取值范围正好控制在[32767,2147483647],满足截断错误的触发条件.另外本文通过代码覆盖率检测工具gcov验证,转化后的测试用例集分支覆盖率为100%,语句覆盖率为98.63%,如图3所示.由于tcas中存在不可达语句,所以语句覆盖率不能达到100%,此为软件设计错误,在本实验中不予考虑.schedule的测试用例本文选择/testplans.alt/testplans-bigcov/suite1000作为测试用例以保证最大覆盖率如图4所示.4.3评价分析4.3.1评价方法准确性进行评估.本文使用文献[17]中的评价方法对错误定位的错误定位方法的准确性可以表述为,按照错误定位模型对语句的可疑度排名顺序检查代码,程序员找到错误语句之前所必须检查的代码数量.程序员检查的语句数越少,说明错误定位方法准确性越高,同时也说明无需检查的代码数越多.本文用无需检查代码占可执行语句数的比例定量表示错误定位方法的准确性.定义错误定位方法的准确性为对于多故障版本程序前提下的错误定位方法的其中,rank表示诊断报告中语句的秩,total表示可执行语句总数.准确性本文使用文献[18]的评价方法.多故障版本程序前提下的错误定位方法准确率为找到首个错误语句前必须检查的语句个数,占可执行语句总数的百分比.定义漏报率为其中,D为诊断报告中注入错误的数量,E为注入错误的总数量.本文定义整数溢出错误定位方法定位整数溢出错误的能力C为NP=0的程序版本数占所有注入相同整数溢出错误类型的程序版本数的百分比4.3.2实验结果(1)单故障程序版本本文列出了tcas和schedule程序各个单故障版本的错误定位准确率的对比图如图5和图6所示,另外本文将q值划分为5个区间,统计了每种方法的q值在这5个区间中的分布如表5和表6所示.Page8图5tcas错误定位方法准确率对比(单故障版本)图6schedule错误定位方法准确率对比(单故障版本)表5tcas各单故障版本准确率狇的区间分布q的划分区间LOUPE模型0.8~1.0500.6~0.80.4~0.6500.2~0.40~0.2表6schedule单故障版本准确率狇的区间分布q的划分区间LOUPE模型0.8~1.0500.6~0.833.333.300.4~0.60.2~0.416.716.700~0.2(2)多故障程序版本tcas和schedule程序各个多故障版本的错误定位准确率如图7、图8所示.另外与单故障程序版本类似,本文分别将q的值划分为5个区间,统计了每种方法q的值在这5个区间中的分布如表7所示.表7tcas多故障版本程序错误定位准确率狇的区间分布q的划分区间LOUPE模型0.8~1.038.40.6~0.830.80.4~0.630.80.2~0.400~0.20(3)现有整数溢出错误检测工具结果本文选择现有的两种典型整数溢出错误检测工具作为研究对象.splint为静态分析工具,可以使用类型推理方法检测源代码中的类型冲突.valgrind-memcheck为动态检测工具,运用动态追踪污点传播技术监控不信任数据,若不信任数据在内存分配函数使用中造成空指针使用、内存泄露等错误,则工具报错.两个工具的检测结果如下.版本号注入v114100v112550v2150v1224100v314100v1324100v414100v142550v514100v1524100v6150v162550v724100v1724100v8260v182550v92550v192550v1024100版本号注入v1139100v5139100v21400v61400v31400v7239100v4139100v82410版本号注入v110100v1120100v210100v1220100v310100v1320100v410100v1420100v510100v1520100v610100v1620100v720100v1720100v820100v1820100v920100v1920100v1020100表11valgrind-memcheck检测结果(schedule)版本号注入v110100v5110v210100v6110v3110v720100v410100v82150Page94.3.3实验讨论(1)错误定位模型有效性对比tcas程序中如图5和表6所示,对于本实验中注入的6个单故障版本程序,本文方法优于现有错误定位方法.将q的范围划分为5个区间,统计每个方法的准确率在各个区间的个数,结果发现6个单故障版本程序中本文方法的准确率100%在0.8~1.0之间,LOUPE仅有50%,CP模型的准确率则均匀分布在中间3个区间内.而在schedule的单故障程序中,本文方法有83.3%的q值在0.8~1.0之间,如表6所示.如图7和图8所示本文方法对于tcas多故障程序版本情况下发现首个错误语句的效率明显优于现有方法.虽然v9程序LOUPE的准确率比本文方法高,但是其平均准确率却低于本文方法.v10和v17版本程序,LOUPE的准确率与本文方法相同,但是平均准确率同样低于本文方法.所以本文方法对于实验中的多故障程序版本准确率总体上优于LOUPE和CP.在13个多故障版本的tcas程序中,本文方法有92.3%的q值在0.8~1.0之间(如表7),说明本文方法定位多故障的准确率优于现有方法.(2)与现有整数溢出错误定位工具比较从本实验结果发现splint可以检测符号错误和截断错误,但是无法检测算数溢出.而valgrind-memcheck可以检测发生在malloc函数使用中的整数溢出错误,但是错误报告仅仅定位到错误语句所在函数(如图9),并不能指导程序员有效地调试程序.并且在tcas的检测过程中,由于tcas没有内存使用函数,因此valgrind-memcheck不报错.本文分别列出本实验的每种方法对3种整数溢出的定位能力C,即NP=0的程序版本数占所有注入相同整数溢出错误类型的程序版本数的百分比,如表12所示.从中可以发现静态分析工具可以有效地定位符号错误;基于程序特征谱的整数溢出错误定位方法可以定位全部算数溢出错误,而splint和valgrind-memcheck无法定位算数溢出错误.(3)进一步分析整数溢出错误在程序运行中通过数据流和控制流传播,而现有的CP模型只考虑通过控制流传播的程序错误,因此使用本文提出的INTRank模型定位整数溢出错误的准确性比CP模型高,如图5~图8所示.由于程序语句之间存在数据或者控制依赖关系,因此程序语句的可疑度之间同样存在相关性.现有LOUPE模型虽然考虑到语句之间存在控制依赖和数据依赖关系,但是该模型将分支和定义使用对的可疑度直接作为语句可疑度的作法忽略了整数溢出错误在程序运行时存在一定的“传播距离”.因此INTRank模型的准确性比LOUPE模型高,如图5~图8所示.在与现有整数溢出错误检测方法的对比中,本文方法和现有基于程序特征谱错误定位方法基本上能够定位所有整数溢出错误定位类型(CP除外,如表12所示),漏报率极低.这是由于基于程序特征谱错误定位方法是从程序运行结果反向推理程序失效的原因.无论程序中存在何种类型整数溢出错误,只要导致程序失效,基于程序特征谱错误定位方法就能定位该错误.表12检测3种整数溢出错误的能力犆的对比类型截断错误15.800100100100符号错误10037.510010075算数溢出05结论与展望本文在分析整数溢出错误在程序运行时的传播特征基础上建立了错误定位模型INTRank,提出了基于INTRank模型的语句可疑度方法,最后实现了原型工具INT-LM,运行界面如图10所示.通过对tcas和schedule进行故障注入,生成27个故障版本程序,故障类型涵盖截断错误、符号错误和算数溢出这3种基本类型.实验结果显示:(1)在满足测试用例最大覆盖率前提下,本文方法可以较准确地定位注入的整数溢出错误语句.(2)单故障程序前提下,INTRank模型定位tcas6个故障版本程序中整数溢出错误的准确率100%在0.8~1.0之间,schedule的6个故障程序中有83.3%的准确率在0.8~1.0之间.而多故障Page10前提下INTRank模型的准确率总体上优于LOUPE和CP模型,这也进一步说明在满足测试用例最大覆盖率前提下,直接将定义使用对或者分支的可疑度赋值于语句的方法不能实现对整数溢出错误的准确定位.程序语句不能视为相互独立的个体,他们之间的可疑度值可以近似为一种线性关系.(3)基于程序特征谱整数溢出错误定位技术的漏报率比splint和valgrind-memcheck低.实验结果表明,splint和valgrind-memcheck都存在漏报现象,特别是算数溢出的漏报率达到100%;而本文方法可以定位所有注入的整数溢出错误,漏报率为0.本文在某些方面还有待进一步的改进和探索.由于本文实验中的初始测试输入数据均来自西门子测试套件①,因此下一步应该研究面向整数溢出错误定位的测试输入数据生成方法.本文实现的原型工具使用WET运行架构获取覆盖信息,但是WET运行架构的运行开销比较大,会产生大量冗余信息,目前此工具只能运用于中小规模程序,所以如何高效地获取程序运行信息将是下一步的研究重点.
