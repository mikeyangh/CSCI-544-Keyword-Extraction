Page1一种有效的海量数据Top-犽Dominating查询算法韩希先李建中高宏(哈尔滨工业大学计算机科学与技术学院哈尔滨150001)摘要在多准则决策支持等多个应用中,top-kdominating查询是一种十分实用的查询,它在潜在的巨大的数据空间中返回k个支配分数最大的元组.现有算法,要么需要为特定的属性组合构建索引,要么需要较大的I/O费用或内存费用,从而无法有效处理海量数据上top-kdominating查询.文中提出一种新的查询算法TDEP,该算法利用以较小代价为每个属性构建的有序列表来有效返回海量数据上的top-kdominating查询结果.文中将TDEP算法的执行明确地分为两个阶段:增长阶段和收缩阶段.在每个阶段,TDEP算法以round-robin方式读取涉及到的有序列表并维护候选元组,直到满足结束条件.文中分析了两个阶段的执行行为,提出一种新的不需要重新读取有序列表的支配分数计算方法.同时,文中还提出有效的早剪切操作,可以有效减少TDEP算法需要维护的候选元组数量.实验结果表明:和现有算法相比,TDEP算法具有较大的性能优势.关键词海量数据;top-kdominating查询;TDEP算法;有序列表;早剪切操作1引言在许多应用中,偏好查询是一种十分重要的查询类型,它在潜在的巨大的数据空间中返回用户感兴趣的数据.偏好查询主要包括两种查询类型:top-k查询和skyline查询.在top-k查询中,用户通常给定一个单调的评分函数来计算每个元组的分数,top-k查询从数据空间中返回k个分数最小的元组[1].不失一般性,我们假设人们更喜欢较小的数值而不是较大的数值.图1给出的是关于旅馆的数据集,人们关心的属性是旅馆的价格(x)以及其离海滩的距离(y),给定评分函数F=x+y,top-2查询返回的结果是p1和p8.Top-k查询的优点是它可以控制返回的结果数量,但是其问题在于,找到一个合适的评分函数却不是一件容易的事情,而且不同的评分函数通常会产生不同的结果,此外,top-k查询的结果受维度之间的不同标度的影响.另一方面,给定skyline准则的属性集合AS,skyline查询返回不被其它对象支配的所有对象[2].确切地说,元组t1支配元组t2,如果t1的所有AS属性的值都不大于t2的AS属性的值,并且在其中至少一个属性上,t1在该属性的值小于t2在该属性的值.如图1所示,给定属性x和y作为skyline准则,skyline查询返回的结果是p1、p2和p8.Skyline查询的优点在于,它不需要特定的评分函数,并且它的结果不受维度之间不同标度的影响.但是,其问题在于skyline查询的结果大小无法控制,而取决于skyline准则的大小、元组数量和数据分布.近来,研究人员开始关注一种新的类型的偏好查询:top-kdominating查询[3-4],该查询指定属性集合作为skyline准则,以此来确定元组间的支配关系.对于每一个元组t,该元组的支配分数dom(t)被定义为被该元组支配的元组数量,top-kdominating查询返回支配分数最高的k个元组.如图1的数据集所示,top-2dominating查询的结果是p1和p3,其中,dom(p1)=4,dom(p3)=3.从实际应用的角度来看,top-kdominating查询有效结合top-k查询和skyline查询的优势,同时克服其缺点,其优势在于:(1)该查询不需要指定评分函数;(2)该查询的结果数量是可以控制的;(3)该查询的结果不受维度间不同标度的影响.自从Papadias等人[3]引入top-kdominating查询的思想来扩展skyline计算,研究人员已经提出一系列算法来处理该查询.一类算法,例如K-domina-ting_BBS[3]和CBT[4],利用在数据集上构建的R-tree结构来减少需要探索的数据空间并返回top-kdominating结果.但是,这类方法的问题在于,为了构建覆盖所有skyline准则的top-kdominating查询,这类方法所需要的预构建费用和存储负载太高,其应用受到严重限制,只能为选择的小部分属性组合构建索引.另一类算法,例如FNP[5]和DA[6],则不需要在特定属性集合上构建数据结构.FNP算法可以在非索引的数据集上执行top-kdominating查询,但是该方法需要对数据集执行3轮扫描操作,在海量数据上其I/O费用过于昂贵.DA算法要求为每个属性维护一个有序列文件,根据指定的skyline准则读取涉及到的有序列文件,渐进地返回查询结果.但是,该方法的问题在于,在海量数据上执行时,该方法需要维护的候选元组较多,而且在计算元组的支配分数时该算法需要重新读取有序列文件的元组,这些问题都严重影响了该方法的执行效率.综上所述,现有算法无法有效地处理海量数据top-kdominating查询.考虑到现有方法存在的问题,本文提出一种新的算法TDEP(Top-kDominatingwithEarlyPrun-ing)来有效处理海量数据上的top-kdominating查询.TDEP算法利用较低费用构建的数据结构来有效减少查询涉及到的I/O费用.给定表T(A1,A2,…,AM),TDEP算法为每个属性Aj构建一个有序列表Lj(1jM),Lj维护对应属性值按升序排列的元组的位置索引.给定skyline准则{A1,A2,…,Am},TDEP算法明确地把top-kdominating查询的执行过程划分成两个阶段:增长阶段和收缩阶段.在增长阶段,TDEP算法以round-robin方式读取涉及到的Page3有序列表{L1,L2,…,Lm},维护候选元组信息.当有k个候选元组其对应的属性A1,A2,…,Am都出现时(这样的元组也称为终结元组),增长阶段结束,此时top-kdominating查询的结果肯定包括在当前已获得的候选元组中.接着,在收缩阶段,TDEP算法继续对{L1,L2,…,Lm}执行round-robin方式读取,并维护当前支配分数最大的k个终结元组.当top-kdominating查询结果的阈值超过其它非终结元组的支配分数上界时,TDEP算法结束并返回结果.类似于DA算法,TDEP算法也是在面向列存储模型上执行,但是本文的创新之处在于:(1)TDEP算法在计算终结元组的支配分数时不需要重新读取有序列表的元组,而只需要利用已获得的候选元组信息.(2)TDEP算法在查询执行开始就可以对候选元组执行有效的剪切操作.本文提出了对TDEP算法的理论分析,估计了增长阶段和收缩阶段的扫描深度和需要维护的候选元组结果,提出了有效的早剪切方法以及其理论剪切效果.本文的实验结果表明:TDEP算法和现有方法相比,其加速比可达2个数量级,需要维护的候选元组减少可达2个数量级.本文的主要贡献如下:(1)提出一种新的海量数据上的top-kdomina-ting查询算法,利用低费用构建的数据结构,来有效返回查询结果.(2)提出一种有效的支配分数计算方法,只需(3)对增长阶段和收缩阶段的执行行为进行理(4)提出有效的早剪切方法,并且提出其数学(5)用实验结果表明,TDEP算法相比较于现有方法具有明显的优势.本文第2节给出本文的预备知识;第3节给出top-kdominating查询的两阶段执行分析;第4节提出TDEP算法的基本执行过程,早剪切方法包括在第5节;第6节评价TDEP算法的性能;相关工作和结论分别在第7节和第8节.2预备知识2.1Top-犽dominating查询给定具有n个记录的表T(A1,A2,…,AM),t∈T,令t[i]表示元组t的属性Ai的值.不失一般性,令ASsky={A1,A2,…,Am}表示top-kdomina-要利用已获得的候选元组信息来进行计算.论分析.分析及有效的实现方法.ting查询涉及到的skyline准则,元组间的支配关系定义在ASsky上.t1,t2∈T,我们称t1支配t2(表示为t1t2),如果j(1jm),t1[j]t2[j],并且j(1jm),t1[j]<t2[j].t∈T,t的支配值dom(t)表示T中被t支配的元组数量,即()domt=t∈T|t{Top-犽dominating查询:给定表T以及skyline准则ASsky,top-kdominating查询返回表T的k-子集R,使得t1∈R,t2∈(T-R),dom(t1)dom(t2).根据支配分数的定义,如果t1t2,那么dom(t1)>dom(t2).本文频繁用到的符号如表1所示.符号T用于top-k支配查询的数据表M表T的维度n表T的元组数量ASskyTop-k支配查询涉及的skyline准则mASsky的大小dpgrw增长阶段的扫描深度dpshr收缩阶段的扫描深度HTTDEP中维护候选元组的Hash表MH维护当前具有最大支配分数的k个终结元组的最小堆domthresTop-k支配查询结果的分数阈值Lj表T中属性Aj对应的有序列表Lj[1,i]有序列表Lj的前i个元组2.2DA算法在垂直划分的有序列文件上,Tiakas等人[6]提出一组算法来处理任意skyline准则的top-kdomi-nating查询,其中,DA算法(DifferentialAlgorithm)的性能优于其它的算法,因此这一部分主要介绍DA算法.给定skyline准则ASsky={A1,A2,…,Am},DA算法以round-robin方式读取涉及到的有序列文件{SC1,SC2,…,SCm},获得的候选元组存储于辅助的B-树结构Set-B+,并记录每个候选元组的出现次数.当扫描深度为pos时获得一个终结元组t,即该候选元组的A1,A2,…,Am属性都已经出现,这里的扫描深度表示文件的位置.DA算法首先计算该终结元组的支配分数(估计值)dom(t)=n-pos①,并将该终结元组插入最大堆HP.接着,DA算法移除HP中的最大元素t1,如果t1的支配分数为估计值,则计算其准确的支配分数dom(t1),比较该值和当前HP的最大元素t2的支配分数dom(t2)的关系,如果dom(t1)<dom(t2),则将t1重新插入到HP,否则,输出t1为top-kdominating查询的结果.该过程迭代执行,直到输出k个结果为止.①本文假设元组处于一般位置[7].Page4DA算法的关键问题在于,如果当前移除的元素t1的支配分数为估计值,如何有效计算其准确的支配分数.在获得第1个终结元组tf时,令tf在列文件SC1,SC2,…,SCm的出现位置分别为lpos1(tf),lpos2(tf),…,lposm(tf),DA算法重新从列文件SC1,SC2,…,SCm的起始位置开始扫描,直到分别扫描到列文件SCj(1jm)第lposj(tf)个元组,令UDj表示SCj的前lposj(tf)-1个元组,则domt()f=n-∪mDA算法并没有真正维护集合UDj,而是只计算其大小,这是通过利用Set-B+中候选元组的出现次数来实现的.DA算法在执行过程中维护一个合适的已获得准确支配分数的终结元组tb及其出现的位置lpos1(tb),lpos2(tb),…,lposm(tb),在计算下一个出现的终结元组tp的准确支配分数时,令tp在列文件中出现的位置分别为lpos1(tp),lpos2(tp),…,lposm(tp),DA算法不需要从列文件SC1,SC2,…,SCm的起始位置开始扫描,而只需要分别从列文件SCj(1jm)的第lposj(tb)元组的位置开始,并根据lposj(tb)和lposj(tp)的大小关系,来决定对列文件SCj采用前向扫描或者后向扫描,直到扫描到第lposj(tp)个元组,采用与计算tf的准确支配分数类似的方式来计算tb的准确支配分数.这里,DA算法维护合适的tb的信息来最小化所需要的I/O费用,即最小化∑m行过程中,DA算法采用minimumabsolutediffer-enceofpositionspreservation规则,更新维护的合适的终结元组的信息.虽然DA算法提出了一系列剪切操作来提高其执行效率,但是其提出的剪切规则主要是用于处理获得的终结元组,而对于Set-B+维护的候选元组,其剪切效果却不好,尤其是在找到k个终结元组之前,DA算法无法剪切任何候选元组.而且,由于需要计算终结元组的准确支配分数,在找到k个终结元组之后,DA算法也需要继续维护那些理论上可以剪切的元组.从而,在海量数据上执行时,DA算法需要维护较多的候选元组,尤其当维护的候选元组超过内存容量时,内存中的候选元组需要利用磁盘作为中转空间,更加影响算法的性能.此外,DA算法利用重新读取列文件来计算终结元组准确支配分数的方式也增加了其执行的费用.因此,通过分析有序列文件上查询的执行行为,本文对top-kdomi-nating查询的执行过程进行明确划分,提出有效的剪切方法来减少需要维护的候选元组,并且不需要重新读取列文件来计算终结元组的准确支配分数,从而能有效提高算法的性能.3两阶段执行分析自从Fagin等人的开创性的工作[8]以来,在垂直划分的有序列文件上执行偏好查询是研究人员的一个自然选择[9-10],即以round-robin的方式读取涉及到的有序列文件,维护候选元组,逐渐更新候选元组的相关信息,直到满足结果输出条件.通常,这种方法不需要读取全部的列文件元组就可以返回查询结果.对于t∈T,令tpi表示元组t的位置索引,即元组t在表T中的出现位置.如果t是T的第i个元组,则tpi=i,我们令T(i)表示T中位置索引为i的元组.在本文提出的算法中,我们只需要考虑每个列文件的值的大小关系,而不需要知道具体的数值,因此用到的有序列文件只包括每个元组的位置索引.以下,本文称这样的列文件为有序列表.给定表T(A1,A2,…,AM),其对应的有序列表集合LS={L1,L2,…,LM}构建方法如下:(1)表T被分解为一组列文件CS={C1,C2,…,CM},列文件Cj的模式为Cj(Aj,PI),这里PI表示元组的位置索引,而Aj则表示元组T(PI)的对应属性值.(2)对每个列文件Cj根据属性Aj的升序执行排序,排序后的列文件保留PI属性从而获得有序列表Lj.i1,i2∈Lj,i1i2,TLji()()1[j]TLji()()2[]j.我们发现,在有序列文件上执行top-kdomina-ting查询的算法,其执行过程可以分为两个阶段:增长阶段和收缩阶段.增长阶段包括top-kdominating算法的开始,直到该算法获得k个终结元组为止.在这个阶段,算法不断维护获得的候选元组.当算法获得k个终结元组后,定理1证明最终的top-kdominating结果肯定在已经获得的候选元组中.定理1.当增长阶段结束时,top-kdominating结果包括在已经获得的候选元组中.证明.假设当前算法已经获得k个终结元组,令tild表示其中支配分数最低的终结元组.t∈T,如果tpi没有在增长阶段出现,那么j(1jm),tild[j]t[j],tildt,dom(tild)>dom(t).元组t肯定不是top-kdominating结果.增长阶段结束后,top-kdominating算法进入Page5收缩阶段.在这一阶段,对于任意新获得的候选元组,如果在其之前没有出现,那么该候选元组肯定不是top-kdominating结果.同时,利用新获得的信息,算法可以剪切某些新生成的终结元组,从而最终获得查询结果.根据这一部分的分析,我们发现现有的DA算法在增长阶段没有执行任何剪切操作,而只是剪切在收缩阶段出现的部分终结元组.而且,DA算法需要重新读取有序列文件的数据来计算每个终结元组的支配分数,增加了查询处理的I/O费用.接下来,我们将提出一种新的top-kdominating查询算法,该方法将有效减少执行过程中需要维护的候选元组数量,而且不需要重新读取列文件来计算支配分数.4TDEP算法在这一节,我们将介绍TDEP算法在增长阶段和收缩阶段的具体执行.4.1增长阶段给定top-kdominating查询的skyline准则ASsky={A1,A2,…,Am},TDEP算法读取涉及到的有序列表集合LS={L1,L2,…,Lm},并且在Hash表HT中维护需要的信息.这里,HT初始为空,每个记录的格式为(key=pi,value=(counter,position)),其中key表示获得的位置索引值,value维护该位置索引值出现的次数counter和相应的位置数组position[1,…,m],position数组初始值为Long.TDEP算法在增长阶段的执行过程如下所示:(1)TDEP算法以round-robin方式读取L1,L2,…,Lm.对于获得的位置索引值pi=Lj(pos),算法检查HT是否含有以pi为键的记录,如果不存在,则在HT中插入一条新的记录(pi,(1,position[j]=pos)).否则,该Hash表存在以pi为键值的记录(pi,(counter,position)),更新该记录为(pi,(counter+1,position[j]=pos)).如果该位置索引的出现次数等于m,该位置索引对应的元组称为一个终结元组.(2)TDEP算法对L1,L2,…,Lm的round-robin读取不断执行,直到出现k个终结元组.此时增长阶段结束,定理1证明top-kdominating查询结果的位置索引包括在Hash表HT的键值集合中.增长阶段结束时,TDEP算法首先为生成的k个终结元组分别计算其支配分数,然后将这些终结元组插入最小堆MH中,MH的最小支配分数domthres作为top-kdominating查询结果的阈值,任何支配分数低于该阈值的元组都不是top-kdomi-nating查询结果.下面,我们介绍如何不重新读取有序列表,仅仅利用Hash表维护的信息来计算终结元组的支配分数.给定增长阶段获得的任意终结元组ti,该元组对应的HT记录的键值为tipi,我们得到该记录的值为(m,positionti),positionti[1],positionti[2],…,positionti[m]维护的分别是tipi在L1,L2,…,Lm出现的位置.我们遍历Hash表HT的所有记录,并且维护数组sum[1,…,m],该数组的初始值都为0.rec∈HT,如果数组recposition的m个元素满足条件recposition[j]<positionti[j](1jm)的个数为jsat,我们对sum[jsat]的值自增1.这样,对HT遍历完毕后,sum[j]维护的就是在获得终结元组ti时位置索引出现j次的候选元组数量(不考虑tipi),终结元组ti的支配分数:该计算公式解释如下:如图2所示,TDEP算法获得tipi时,终结元组ti无法支配的元组的位置索引包括在∪mpositionti[1]-1],L2[1,positionti[2]-1],…,Lm[1,positionti[m]-1]中分别出现1次、2次、…、m次的位置索引,同时,在考虑支配关系时,我们也不考虑元组对其自身的支配,因此我们得到如上的计算公式.这里,Lj[1,i]表示有序列表Lj的前i个元组.当然,如果维护的候选元组数量较多,内存无法容纳全部的候选元组,那么Hash表的一部分数据就需要输出到磁盘上,从而对于Hash表相关的操作就需要涉及到磁盘上的数据.但是根据如下的描Page6述,一般来说,TDEP算法在海量数据上维护的候选元组是可以容纳在内存中的.增长阶段结束后,最小堆MH维护着当前获得的k个具有准确支配分数的终结元组,TDEP算法进入收缩阶段.4.2收缩阶段收缩阶段的执行过程如下所示:(1)TDEP算法从增长阶段结束位置继续对L1,L2,…,Lm执行round-robin方式读取,以类似于增长阶段的方式在Hash表HT中维护并更新对应的记录信息.令pi=Lj(pos)是当前获得的位置索引,很明显,此时任何非终结元组的支配分数不超过(n-pos).(2)当获得一个终结元组ti时,计算其精确的支配分数dom(ti),如果dom(ti)>domthres,则移除最小堆MH的最小元素,将ti插入到MH中,并更新domthres为MH的当前的最小支配分数.根据定理2,如果domthresn-pos,则TDEP算法结束,最小堆MH维护的就是top-kdominating查询的结果.否则,继续执行对L1,L2,…,Lm的round-robin读取操作.定理2.在收缩阶段,给定TDEP算法的当前扫描深度为pos,如果domthresn-pos时,TDEP算法结束.证明.令TDEP算法的扫描深度为pos时,获得的终结元组集合为TISpos,最小堆MH维护的是TISpos中准确支配分数最大的k个终结元组.已知,t∈(T-TISpos),元组t的支配分数肯定不超过(n-pos).所以,如果domthresn-pos,则t∈(T-TISpos),t的支配分数小于MH的最小支配分数.4.3一些改进这一部分,我们介绍如何对TDEP算法做进一步的改进.方法1.在计算终结元组的准确支配分数时,TDEP算法不需要重新读取有序列表的元组,而只需要对Hash表HT执行一轮顺序扫描.当内存维护的候选元组较多时,对HT的一轮扫描会造成较大的内存费用.因此,本文采用批量计算终结元组的精确支配分数的方法来分摊对HT一轮扫描的费用.对于扫描过程获得的每k个终结元组,TDEP算法并不是对于单个终结元组进行处理,而是利用对HT的一轮扫描来同时计算k个终结元组的准确支配分数.这样就分摊了对于HT一轮扫描的费用.方法2.在收缩阶段,最小堆MH维护着目前出现的k个具有最大准确支配分数的候选元组,令其中的最小元素是timh,对于收缩阶段获得的任何终结元组ti,如果timhti,那么TDEP算法不需要计算ti的准确支配分数,因为dom(ti)<dom(timh),从而ti不是top-kdominating查询的结果.当然,在比较timh和ti的支配关系时,TDEP不需要读取它们的真正的属性值,而只需要判断其对应的位置索引在有序列表的位置.5剪切技术这一部分,我们介绍如何对TDEP算法执行剪切操作,从而改进top-kdominating查询算法.由于本节的重点在于讨论剪切操作,为更清晰地分析问题,本节假设表T的各属性均匀独立分布.5.1候选元组数量首先,我们分析TDEP算法需要维护的候选元组数量.令增长阶段结束时,算法对有序列表的扫描深度是dpgrw,这里的扫描深度指的是对L1,L2,…,Lm分别读取的元组数量,令收缩阶段结束时,算法对有序列表的扫描深度是dpshr.t∈T,我们有Ptpi∈Lj[1,dpgrw令t在增长阶段成为一个终结元组为一次成功事件S1,那么成功事件S1的概率是psuc=dpgrw()n成功事件S1的次数满足二项分布BD1(n,psuc).根据DeMoivre-Laplace定理[11],在海量数据上二项分布BD1可替换为正态分布ND(n×psuc,n×psuc×(1-psuc)).我们以极高概率(0.999968)保证,当时,成功事件S1的次数不小于k,其中a=n2+16n,b=-2nk+16()n,c=k2[9].令NUM(tpi,dpgrw)表示位置索引tpi在L1[1,dpgrw],L2[1,dpgrw],…,Lm[1,dpgrw]中出现的次数,则NUM(tpi,dpgrw)满足二项分布BD2(m,dpgrwn).在增长阶段,HT维护的记录数量NUMgrw计算为NUMgrw=∑mdpgrw)nPage7m-j表示位置索引tpi在增长阶段出现j次的概率.当增长阶段结束时,top-kdominating查询的支配分数阈值domthresn-m×dpgrw,这个值在TDEP算法的执行过程中是单调非递减的(mono-tonicallynon-decreasing).在收缩阶段,令pos是当前的扫描深度,任何非终结元组的支配分数不超过(n-pos),那么当domthresn-m×dpgrwn-dpshr时,TDEP算法肯定结束,忽略不等号,我们取利用以上的分析结果,当收缩阶段结束时,TDEP算法维护的终结元组个数为n×dpshr()nj=1Hash表HT中维护的记录个数为NUMshr=∑m我们发现,TDEP算法在执行期间需要维护的候选元组数量和skyline准则m的大小成指数关系,和元组数量n以及结果数量k成线性关系.在海量数据上执行时,TDEP算法仍然需要维护较多的元组.下面,我们介绍如何执行剪切操作来减少需要维护的元组数量.5.2剪切思想给定终结元组ti,我们重新考虑其支配分数的计TDEP算法所维护的候选元组的主要用途为(1)维护元组位置及出现信息来生成终结元组.(2)计算终结元组的准确支配分数.根据5.1节的分析结果,终结元组的数量占所有候选元组的比例较低,如果在计算终结元组分数时不需要维护所有的候选元组,那么我们就可以有效减少TDEP算法维护的元组数量.算公式()domti=n-∑m表示当出现终结元组ti时位置索引出现j次的候选元组的数量(不考虑tipi).对于sum[1]的值来说,我们实际上可以通过终结元组出现的位置以及其它的sum[j](2jm)的值计算获得.给定终结元组ti对应的HT记录值(m,positionti),sum[1]的值计算为sum[]1=∑msum[j]),该值可以解释如下:∑m表示L1[1,positionti[1]-1],L2[1,positionti[2]-j=21],…,Lm[1,positionti[m]-1]出现的总的位置索引值的数量,其中包括出现过一次和多次的位置索引,∑m置索引值在L1[1,positionti[1]-1],L2[1,positionti[2]-1],…,Lm[1,positionti[m]-1]出现的总次数,因此,∑msum[j])的结果就是我们需要的出现一次的位置索引的数量.所以,支配分数计算公式可以修改为()domti=n(-∑msum[j)]-1,即TDEP算法不需要维护在其执∑mj=2行期间只出现一次的候选元组,也可以计算每个终结元组的支配分数.j=1根据以上的分析,早剪切规则如下所示.早剪切规则.t∈T,如果tpi在收缩阶段结束前只出现一次,那么TDEP算法不需要维护tpi.早剪切规则的直观思想在于,如果tpi在收缩阶段结束前只出现一次,那么计算终结元组的支配分数时,该位置索引最多出现一次,我们有(1)在TDEP算法结束时,T(tpi)肯定不是终结元组.(2)即使不维护该tpi,TDEP算法也可以计算终结元组的支配分数.t∈T,如果TDEP算法在round-robin扫描过程读取到位置索引tpi=Lj(pos),那么tpi被剪切的概率该公式解释如下:TDEP算法要剪切tpi,就要求所有1jm且j≠j,tpiLj1,dp[]shr,而tpiLj1,dp[]shr的概率是1-dpshrn,因此我们得到Ppru的计算公式.我们注意到,虽然表T的维度M可能很大,但是用户每次感兴趣的通常是其中的一小部分[6].在实际应用中,决策人员利用的skyline准则一般都不大,TDEP算法的早剪切操作可以取得较好的剪切效果.例如,给定n=109,m=3,k=10,早剪切的剪切比例为0.98,早剪切操作可以剪切绝大多数的候选元组.5.3实现方法虽然实现早剪切操作并不容易,TDEP算法利Page8用指数间距bloomfilter表来有效实现这一目标,快速地判断给定位置索引是否在某有序列表的指数间距位置索引范围内.定义1(指数间距bloomfilter表).给定具有n个元素的有序列表Lj,EGBFTj是Lj上的指数间距bloomfilter表,如果它满足条件:(1)|EGBFTj|=log2n;(2)EGBFTj(i)表示在Lj[1,2i]的元素上构建的bloomfilter(0ilog2n).给定有序列表Lj,EGBFTj需要的空间大小取决于元素数量n和假阳性率fpr.利用a-bit的位向量和b个独立Hash函数,EGBFTj(i)是构建在2i个元素上的bloomfilter.如果b=aln2率fpr=()1长度a=2i×log2(1/fpr)/ln2[12].令SIZEEGBFTj表示EGBFTj的大小,我们有SIZEEGBFTj=∑log2nlog2(1/fpr)/ln2.本文设定fpr=0.001,SIZEEGBFTj不到有序列表Lj的大小的45%.TDEP算法为每个有序列表都构建指数间距bloomfilter表.利用5.1节获得的dpshr,TDEP算法在执行之前将EGBFT1(log2dpshr),…,EGBFTm(log2dpshr)载入内存.对于当前获得的位置索引pi=Lj(pos),TDEP算法判断,如果pi没有包含在其它全部m-1个有序列表的前2log2dpshr个元组,则pi被早剪切,否则pi就维护在Hash表HT中.这里,收缩阶段的扫描深度被扩展到其最小的指数间距上界,所以估计扫描深度的概率值实际上要超过其原本就极高的理论值(0.999968).由于收缩阶段的扫描深度扩展以及bloomfilter的内在的假阳性问题,TDEP算法不能保证将在收缩阶段结束前只出现一次的候选元组全部剪切,所以TDEP算法在计算终结元组ti的支配分数时的实际计算公式如下:()domti=n(-∑m理论分析和实验结果表明,早剪切方法需要的额外数据结构的大小远小于减少的候选信息的大小,TDEP算法有效减少维护信息所需要的费用.当数据的各属性不满足均匀独立分布时,剪切技术的实现可以采用文献[9]的方法.6实验评价6.1实验设置这一部分评价TDEP算法的性能.我们利用Java语言实现TDEP和DA算法,jdk版本为jdk-7u21-windows-x64,实验在LENOVOThinkCentreM8400T上执行(Intel(R)Core(TM)i7-3770CPU@3.40GHz(8CPUs)+32GB内存+64bitWindows7),数据存储在SeagateExpansionST-BV3000300(3TB)磁盘.其中,DA算法根据文献[6]实现,同时实现其DR1-DR3剪切、EPR1-EPR6剪切和IPR1剪切.在实验执行之前,我们对涉及到的列文件执行排序操作,这就使得DA算法不需要构建额外的B+-树来读取每个有序列的元组.此外,实验都采用Hash表来维护DA算法和TDEP算法的候选元组,我们发现Hash表来维护候选元组的性能要优于文献[6]中采用单独的B+-树来维护的方法.本文选择DA算法进行比较的原因在于:(1)DA算法和TDEP算法都是基于有序列文件的算法.(2)现有的top-kdominating算法,例如CBT[4]需要构建辅助的R-tree结构,FNP算法[5]需要对数据文件执行3轮扫描来处理top-kdominating查询,而在文献[6]中,这些算法都和DA算法进行了比较,DA算法的性能优于现有其它算法.因此,实验部分和DA算法进行比较足够评价TDEP算法的性能.实验部分从如下几个方面来评价TDEP算法:元组数量(n)、结果数量(k)和skyline准则大小(m),实验参数的设置如表2所示.实验考虑的元组数量分别为1×109,2×109,3×109,4×109和5×109,默认值为1×109;考虑的返回结果数量分别为10,20,30,40和50,默认值为10;考虑的skyline准则大小为2,3和4,默认值为3.Tuplenumber(109)1,2,3,4,5Skylinecriteriasize2,3,4需要的数据结构在实验之前预构建获得,涉及到的列文件均匀独立分布.这里简单介绍预构建的执行结果.对于元组数量为1×109的列文件,排序时间为2217.705s,生成EGBFT结构的时间为622.824s.Page96.2实验1:元组数量的效果给定k=10和m=3,实验1评价当元组数量(n)变化时TDEP算法的性能.如图3(a)所示,TDEP算法的执行速度比DA算法快41.14倍,这充分说明在海量数据上TDEP算法比DA算法的性能优势.图3(b)给出了TDEP算法的执行时间分解,我们看到增长阶段和收缩阶段的执行时间基本类似.图3(c)给出TDEP算法和DA算法的扫描深度,其中对于TDEP算法分别提供了增长阶段深度、收缩阶段深度和估计的增长阶段深度.我们发现,TDEP算法和DA算法结束时的扫描深度很接近,同时估计的增长阶段深度大于实际的增长阶段深度,从而证明了本文的分析.图3(d)比较TDEP算法和DA算法读取的元组数量,可以看到TDEP算法需要读取的元组数量比DA算法少12.39倍,其原因在于,不同于DA算法,TDEP算法计算准确图3元组数量的效果支配分数时不需要重新读取有序列表的元组.图3(e)给出了TDEP算法和DA算法维护的候选元组数量,我们看到TDEP算法维护的元组数量比DA算法少39.89倍.如图3(f)所示,早剪切操作可以剪切至少96%的候选元组.我们看到,实际的剪切比例要小于估计的剪切比例,这是因为:(1)为保证结果的正确性,TDEP算法总是保守地估计扫描深度;(2)在进行实际剪切操作时,指数间距bloomfilter表将收缩阶段的扫描深度扩展到最小的指数间距上界;(3)bloomfilter内在的假阳性.总的来看,随着元组数量的增大,早剪切的比例也随之增大.这里在n=2×109时,早剪切比例比较突出,其原因在于,虽然此时收缩阶段的深度增加了,但是TDEP算法载入的bloomfilter的范围仍然和n=1×109的一样(224),而当元组数量继续增加到n=3×109,TDEP算法载入的bloomfilter的范围就增大到225.Page106.3实验2:返回结果数量的效果给定n=109和m=3,实验2评价当结果数量(k)变化时TDEP算法的性能.如图4(a)所示,TDEP算法的执行比DA算法平均快93.73倍,并且加速比随着k值的增大而增大,当k=10时,加速比为32.52,而当k=50时,加速比则提高到152.86,这在图4(d)中可以得到解释.图4(b)给出了TDEP算法的时间分解.如图4(c)所示,我们发现DA算法和TDEP算法的扫描深度随着k值的增大而线性增长,实际的增长阶段深度小于估计的增长阶段深度.如图4(d)所示,TDEP算法读取的元图4结果数量的效果6.4实验3:skyline准则大小的效果给定n=109和k=10,实验3评价当skyline准则大小(m)变化时TDEP算法的性能.如图5(a)所示,随着涉及到的skyline准则的增大,TDEP算法和DA算法的执行时间都迅速增加,TDEP算法的执行时间比DA算法平均少31.94倍.图5(b)显示组数量平均比DA算法少39.77倍,并且随着k值的增大,DA算法读取的元组数量和TDEP算法读取的数量的比值也在增大,这是由于DA算法需要重新扫描有序列文件来计算准确支配分数,所以它读取的元组数量随着返回结果数量增加而增长幅度较大,而TDEP算法需要读取的元组数量则只和扫描深度相关,其增长速度较缓慢.如图4(e)所示,TDEP算法维护的候选元组数量比DA算法少29.5倍.如图4(f)所示,虽然理论剪切比例在k值变化时逐渐减小,但是TDEP算法的早剪切比例基本保持在96%.在m值较大时,收缩阶段的执行时间逐渐大于增长阶段的时间,这是由于此时TDEP算法的收缩阶段获得较多的终结元组,从而需要较多的计算其准确支配分数的费用.图5(c)给出算法的扫描深度,可以看到随着m值的增大,DA算法和TDEP算法的扫描深度呈指数增长趋势.如图5(d)所示,TDEPPage11算法需要读取的元组数量比DA算法少24.07倍,并且随着m值的增大,两种算法需要读取的元组数量的比值越来越大,这是DA算法计算准确支配分数的方式和较多的终结元组引起的.如图5(e)所示,TDEP算法维护的候选元组数量比DA算法少图5skyline准则大小的效果6.5实验4:真实数据实验4使用的真实数据来自某通信公司的通讯记录,该通话记录被划分为多个分片,每个分片包括107条元组,每条元组包括72个属性,我们选择其中方差最大的3个属性作为skyline准则.给定m=3和k=10,实验4选择5个分片的数据来评价TDEP算法.如图6(a)所示,TDEP算法的执行时间比DA算法快13.71倍.由于真实数据的数据量较小,则增长阶段和收缩阶段的执行时间相对较少,如图6(b)所示,相对地,载入bloomfilter的时间占执行时间的比例较大.图6(c)给出了算法的扫描深度,如图所示,在真实数据上,TDEP算法估计的171.04倍,并且两者的比值随着m值的增大而减小,这可以从图5(f)中得到解释.随着m值的增大,TDEP算法的早剪切比例下降的幅度较大,从m=2时的0.997下降到m=4的0.789,这也符合本文对早剪切操作的数学分析.增长阶段的深度接近于其实际的收缩阶段的深度,并且在n=2×107,3×107,3×107估计的增长阶段深度超过了实际的收缩阶段的深度.如图6(d)所示,TDEP算法读取的元组数量比DA算法少14.18倍.同时,根据图6(e),TDEP算法维护的候选元组数量比DA算法少23.41倍.图6(f)给出了早剪切操作的剪切效果,我们发现在实际数据上,TDEP算法的剪切效果不低于86%,并且在n=2×107,3×107,3×107时,实际剪切效果要优于理论剪切效果,这是实际的数据分布以及早剪切操作共同作用的结果.Page12图6真实数据的效果7相关工作Top-kdominating查询结合了top-k查询和skyline查询的优点,从而越来越得到研究人员的关注.Papadias等人[3]首先引进top-kdominating查询的思想来扩展skyline查询,并提出K-domina-ting_BBS算法来处理该查询.K-dominating_BBS查询首先利用BBS算法计算数据集的skyline结果SKY,同时计算每个skyline点的支配分数,在SKY中移除并返回其中支配分数最大的skyline点p1作为top-kdominating查询的一个结果.接下来,K-dominating_BBS在p1的支配区域中计算局部skyline结果SKY及其每个点的支配分数,在SKY-p()1∪SKY中移除并返回其中支配分数最大的点p2,该过程迭代执行,直到返回k个结果.Yiu等人[4]提出基于aR-tree(aggregateR-tree)的CBT算法来有效处理top-kdominating查询.CBT算法从根开始遍历aR-tree,在集合S中维护其子节点,同时计算对应的支配分数上界和下界.接下来,CBT算法选择集合S中的优先级最大的一个元素来扩展集合S,即移除该元素,插入其子节点,计算对应的支配分数上界和下界,并更新集合S中其它元素的支配分数上界和下界,剪切S中无用的并不可能包括最终结果的元素,并且在最小堆W中维护集合S中支配下界最高的k个元素.该过程一直进行直到集合S中不包括非叶子节点,此时,最小堆W中维护的就是要求的结果.Yiu等人[5]提出FNP算法在非索引数据上处理top-kdominating查询,该算法的执行需要对数据集执行3轮扫描:counterpass、filterpass和refinementpass.Counterpass在内存维护网格文件来记录落入每个单元的点的数量,从而方便接下来的操作中计算支配分数的上界和下界.Filterpass在扫描的同时,利用网格单元的支配分数的上界和下界以及其之间的支配关系来剪切那些不符合要求Page13的点,未剪切的点在查询的候选结果集合中存储.Refinementpass则通过一轮扫描操作来计算候选结果集合中元素的支配分数,最终获得top-kdominating查询的结果.Tiakas等人[6]提出一组算法(BSA、UA、RA和TA)在垂直划分的有序列文件上渐进地处理sub-spacetop-kdominating查询.这组算法采用round-robin方式扫描涉及到的有序列文件,维护获得的候选元组及其出现次数.最大堆HP维护获得的终结元组,即所需要的属性在列文件中都已经获得的候选元组.对于每次获得新的终结元组,算法计算其支配分数(估计值),然后插入HP,选择并移除HP中当前支配分数最大的终结元组t1,如果t1的支配值是估计值,则计算其精确支配分数,然后选择HP中当前支配分数最大的终结元组t2.如果t1的支配分数小于t2的支配分数,则将t1重新插入到HP中,否则直接输出t1为一个top-kdominating查询结果.该过程不断执行,直到输出k个结果为止.BSA、UA、RA和DA算法的区别在于,它们计算终结元组t1的精确支配分数的方法不同,DA算法的性能超过其它3个算法.DA算法维护一个之前已经计算准确支配分数的终结元组tp在列文件中的出现位置,在计算下一个终结元组t1的精确支配分数时,根据t1在列文件中的位置以及tp的位置关系,对列文件执行前向和后向扫描来计算其准确支配分数.在其它的领域,top-kdominating查询也得到较为广泛的应用.Lian等人[13]考虑如何在不确定数据库上执行概率top-kdominating查询(PTD),即在不确定数据库中返回期望动态支配最多不确定元组的k个不确定元组.文献[13]利用aR-tree来有效处理PTD查询,提出有效的剪切方法来剪切PTD查询的搜索空间.Skoutas等人[14]提出如何搜索基于多准则匹配下的top-kdominatingweb服务,并且提出3种支配分数的定义来评价匹配结果:dominatedscore、dominatingscore和dominancescore.对于每一种支配分数,文献[14]提出有效算法来获得top-kdominantweb服务.Zhang等人[15]定义概率阈值top-kdominating查询,给定概率阈值q,该查询在不确定数据库中返回支配其它对象数量最多的k个对象.通过应用大数定理及其数学特点,文献[15]提出一种有效的剪切技术来加速精确算法的执行,还提出一个随机算法来协调执行效率和查询准确度,利用gCaR-tree来返回满足任意精度的近似结果.Kontaki等人[16]提出数据流上的连续top-kdominating查询问题,提出的精确算法利用事件调度技术来有效避免昂贵的支配分数计算费用,提出两个近似算法,以快得多的相应时间返回满足给定概率保证的结果.8结论本文考虑在海量数据上执行基于任意skyline准则的top-kdominating查询的问题,本文的分析发现现有方法无法有效处理该类型的查询.本文提出一种新的top-kdominating查询算法TDEP,该算法利用为每个属性构建的有序列表,可以有效减少查询涉及到的I/O费用和内存费用,从而有效返回查询结果.TDEP算法的执行分为两个阶段:增长阶段和收缩阶段.增长阶段对有序列表执行round-robin扫描操作,直到获得k个终结元组,而收缩阶段则继续对有序列表进行扫描,直到满足结束条件.本文提出一种有效的支配分数计算方法,只需要利用已获得的元组信息就可以获得结果.本文提供了TDEP算法在两个阶段执行行为的理论分析,并提出有效的早剪切策略来减少其执行期间维护的候选元组,从而提高执行效率.本文提供的较全面的实验结果表明,TDEP算法和现有算法相比具有较大的性能优势.
