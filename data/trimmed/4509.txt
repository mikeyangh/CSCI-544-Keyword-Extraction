Page1基于逻辑shapelets转换的时间序列分类算法1)(北京交通大学计算机与信息技术学院北京100044)2)(交通数据分析与挖掘北京市重点实验室北京100044)3)(西北大学电子工程与计算机系埃文斯顿美国60201)摘要时间序列shapelets是序列之中最具有辨别性的子序列.解决时间序列分类问题的有效途径之一是通过shapelets转换技术,将其发现与分类器的构建相分离,其主要优点是优化了shapelets的选择过程并能够灵活应用不同的分类策略.但此方法也存在不足,仅仅简单地应用这些shapelets而忽略它们之间的逻辑组合关系,有可能降低分类的效果;另外,离线式的发现shapelets的过程是相当耗时的.文中针对后一个问题,采用了一种基于智能缓存的计算重用技术,将发现shapelets的时间复杂度降低了一个数量级.在此基础上,作者提出了一种基于合取或析取的逻辑shapelets转换方法,并通过在多个经典的基准数据集上测试,表明了该方法能够在提升分类准确性的同时保持shapelets所具有的解释力.关键词时间序列;分类;shapelets;逻辑shapelets1引言一条时间序列是一组序列数据,它通常是在相等间隔的时间段内,依照给定的采样率,对某种潜在过程进行观测的结果.时间序列数据广泛地存在于商业、农业、气象、生物科学等诸多领域.在时间序列分类问题中,我们将任意实值型有次序的数据看作一条时间序列[1].它与传统分类问题之间的差别在于,对于传统分类问题而言,属性次序是不重要的,并且变量之间的相互关系独立于它们的相对位置;而对于时间序列数据而言,在寻找最佳的辨别性特征时,变量的次序起着至关重要的作用[2].因此,时间序列分类问题已成为机器学习领域的特殊挑战之一.在过去的十多年中,针对时间序列分类问题的研究主要集中在基于不同距离度量方式的最近邻(1-NN)算法上,如基于欧氏距离或者动态时间规整(DynamicTimeWrapping,DTW)的1-NN等[3-4].近年来,基于时间序列shapelets的分类算法引起了相关研究者极大的兴趣.所谓的时间序列shapelets是序列之中最具有辨别性的子序列[5].最初的基于shapelets的分类算法是由Ye等人[5-6]所提出的,其采用信息增益度量数据的分裂点,并通过递归搜索最具有辨别性的shapelets来构建决策树.如图1所示,对于经典的Gun/NoGun(手中有枪/没枪)问题[5],最佳shapelet如粗黑线标注部分所示,它能够对Gun/NoGun数据集进行准确的分类.Mueen等人[7]提出了使用逻辑shapelets来构建决策树的思想,并采用加速技术和剪枝策略来提升文献[5]中算法的可解释性和运行效率.Rakthanmanon等人[8]针对原有的shapelets发现算法在时间效率上的不足,提出了一种基于SAX(SymbolicAggregateapproXimation)表示的快速shapelets发现算法,此算法在提升发现shapelets速率的同时保证了一定的分类准确性.相比较于具有较高分类准确率且易于实现的1-NN分类器,时间序列shapelets的优点主要在于两个方面.(1)分类结果的可解释性更强.原因是1-NN分类器只能说明被分类对象与所分到的类别间具有较大的相似性,但没有指出它与其他类别之间具体的不同点,而shapelets可以较为充分地解释各类之间的差异(如图1所示),即具有较强的辨别性.(2)分类速度更快.首先,由于shapelets比较的是子序列(一般情况下比原始的时间序列要短)之间的相似性,所以不像基于实例的方法那样需要对比整个数据集.其次,shapelets能够非常简洁紧凑地表示一个类的概念,有时我们仅需要一个shapelet就可以出色地完成分类任务,此简洁性意味着分类所需要的时间和空间大量地减少,所以shapelets具有较快的分类速度.上述的几种方法都是在发现shapelets的同时构建分类器.而Bagnall等人[2]强调了数据转换在时间序列分类中的重要性,其为解决数据转换后可能引起的准确率大幅度差异问题,提出了一种集成学习技术来提升分类性能.Lines等人[1]提出了一种基于shapelets转换的时间序列分类方法,即将shapelets的发现与分类器的构建过程相分离,其主要优点是优化了shapelets的选择过程并能够灵活应用不同的分类策略.另外,shapelets也被广泛应用于时间序列聚类[9]、早期分类问题[10]和姿势辨别问题[11]等等.尽管基于时间序列shapelets的方法是目前解决时间序列分类问题的有效途径之一,它仍存在着许多不足.以Lines等人提出的基于shapelets转换的方法为例,一是仅仅简单地应用这些shapelets而忽略它们之间的逻辑组合关系,有可能降低分类的效果.如图2所示,单个shapelet无法对SonyAIBOPage3Robot数据集进行严格区分,此时需要联合多个shapelets,即使用逻辑shapelets才能准确区分两种类别;二是尽管发现shapelets的过程是离线计算的,它仍然需要消耗大量的时间.针对上述两点不足,本文的主要贡献在于两个方面.首先是应用了一种基于智能存储和计算重用的技术,将发现shapelets的时间复杂度降低了一个数量级.其次,我们在此基础上提出了一种基于合取或析取的逻辑shapelets转换方法.具体做法是首先找到k个最好的逻辑shapelets,然后通过计算这些逻辑shapelets与原有时间序列间的距离,将原有时间序列转换成新的拥有k个属性的数据,同时也把时间序列分类问题转化成了传统的分类问题.此方法在保持shapelets的解释力的同时提升了分类的准确性.本文第2节将阐述时间序列分类问题的相关定义和符号;在第3节,将回顾一下文献[1]中提出的算法;第4节将阐述本文所应用的加速技术以及基于逻辑shapelets转换的时间序列分类算法的基本思想;在第5节,本文将进行实验描述并评估所提出的算法;第6节进行相应的总结以及对进一步工作的展望.2符号与定义将时间序列分类问题定义为从一系列标定的时间序列训练集上建造分类器的过程.假设有n条时间序列,D={T1,T2,…,Tn},每一条时间序列有m个观测值和一个类值ci,即Ti=〈ti1,ti2,…,tim,ci〉.目标是构造一个将时间序列的观测值映射到类值的函数.为方便起见,假设每一条时间序列具有相同数目的观测值.文中涉及的主要符号如表1所示.T,X,Ydist(x,y)subdist(x,y)C(x,y)μx,σx,μy,σy定义1.时间序列及其子序列.时间序列T是一条长度为m的实值序列,可表示为t1,t2,…,tm.一条时间序列的子序列Si,l=ti,ti+1,…,ti+l-1是一个T中从位置i开始长度为l的连续的子序列,其中1lm,1im-l+1.注意,数据t1,t2,…,tm是按照时间顺序排列的,两两之间具有相同的时间间隔.时间序列的子序列可以当作是时间序列的局部特征.假设一条时间序列的长度为m,其子序列的最小长度为1,最大长度为m,那么它能有m(m+1)/2个子序列.定义2.时间序列间的距离.所有的分类问题都依赖于数据间的相似性度量,时间序列分类问题也不例外.对于给定的具有相同长度m的两条时间序列X和Y,我们可以使用规范化的欧氏距离来度量它们之间的不同.如式(1)所示.注意,为获得两条时间序列之间距离的有效比对并保证缩放和偏移的不变性,在计算真正的距离之前,必须使用z-规范化方法(如式(2)所示)对每条时间序列进行规范化处理[12].因为缩放和偏移上甚至是一丁点的不同都有可能对形状的相似性比对造成巨大的影响,所以这是至关重要的一步.此处珡X为时间序列观测值的均值,δx为时间序列观测值的标准差,xnorm为z-规范化后的时间序列观测值.从式(1)可以得到,两条时间序列间距离计算的复杂度和时间序列的长度呈线性关系.相比之下,将采用从X和Y推演而得到的5个数据来计算X与Y之间的规范化欧氏距离,这些数据被称为充分统计量(sufficientstatistics)[7,13].它们分别为∑x,∑y,∑x2,∑y2和∑xy.通过使用此方式计算规范化的欧氏距离,可以重新利用计算的中间结果并降低计算规范化欧氏距离的时间复杂度.本文将在第4节进行具体的阐述,相应的计算公式如下.一条时间序列X的均值和方差可以通过式(3)和(4)计算.X与Y之间的欧氏距离可以通过式(5)和(6)计算.Page4许多时间序列数据挖掘算法(如1-NN分类、聚类算法等)只需要对比相等长度的时间序列.相比之下,时间序列shapelets需要测试一个短的时间序列(即shapelet)是否在某一特定阈值下包含于一个更长的时间序列中.为得到此结果,短的时间序列必须在长的序列上滑动以得到它们之间的最佳比对结果,称此距离度量为子序列距离,并定义为或者根据充分统计量可表示为sufficientdist(x,y)=2(1-Cs(x,y这里X与Y是两个长度分别为m和n的时间序列(mn),y|x|表示时间序列Y中长度为|x|的子序列.相应地在上述定义中,μy和δy分别表示Y中从l+1位置开始的m个连续值的均值和标准差.注意,subdist()和sufficientdist()得到的是两个序列间的最短距离.定义3.熵.假设数据集D中包含N条时间序列,类的个数为C,类ci在数据集D中有ni个实例,并且n1+n2+…+nC=N.由于本文采用信息增益度量来评价shapelets的辨别能力,首先需要在此回顾一下熵的概念.数据集D的熵定义为定义4.分裂点.一个分裂点为一个元组(s,t),这里s表示一个子序列,t表示距离的阈值.一个分裂点(s,t)将数据集D分割成两个不相交的子集,其中Dleft={x:x∈D,subdist(s,x)t},Dright={x:x∈D,subdist(s,x)>t},并且N1=|Dleft|,N2=|Dright|.定义5.信息增益.一个分裂点(s,t)的信息增益为I(s,t)=E(D)-定义6.分裂间隔.一个分裂点的分裂间隔为G(s,t)=即为分裂点右侧实例的平均距离减去分裂点左侧实例的平均距离.定义7.Shapelet.数据集D中的一个shapelet是由D中某一实例T的一个子序列S和一个分裂点的阈值t所组成的元组(S,t),它试图将数据集D分割成两个不同的群组.现在将用图3所示的例子来解释shapelet的概念.左边方框中是一个候选的shapelet,右边的orderline记录了该候选shapelet与数据集D中每条时间序列之间的距离,t为最佳的分裂阈值.在图3中,数据集D为经典的Gun/NoGun数据集,圆形表示NoGun类时间序列与候选shapelet之间的距离,它们与候选shapelet间的距离较小;矩形表示Gun类时间序列与候选shapelet之间的距离,它们与候选shapelet间的距离较大.orderline创建之后,就可以计算候选shapelet的分裂点、分裂间隔以及信息增益等.最终选取最优的一个或多个shape-lets进行分类.需要注意的是,当我们对shapelets排序时,优先选择信息增益较大的shapelet;若两个shapelet的信息增益相同,则优先选择分裂间隔较大的shapelet;若两者的分裂间隔也相同,则优先选择长度较短的shapelet;若两者长度相等,则优先选择先产生的shapelet.也就是说,使用分裂间隔以及shapelet的长度等作为打破平局的方法.3Shapelets转换技术Lines等人[1]提出了一种基于shapelets转换的时间序列分类方法,此方法的主要贡献是将shapelets的发现与分类器的构建相分离,避免了文献[5]中发现shapelets时贪心的递归搜索过程,并允许转换后的数据应用于不同的分类器中.相应的算法实现主要包括3个步骤:首先,通过一次扫描数据集,找到最好的k个shapelets;其次,将每一条时间序列转Page5换成具有k个属性的实例.即让每个属性代表一个shapelet,属性值为该shapelet与时间序列间的距离,这样就创建了一个新的转换后的数据集;最后,将转换后的数据集用于贝叶斯网络、决策树、1-NN等分类器进行分类.具体的描述见算法1.算法1.Shapelets发现算法ShapeletFilter(D,min,max,k).输入:时间序列数据集D,最小长度min,最大长度输出:k个最好的shapeletskShapelets1.kShapelets←;2.FORi←0to|D|DO{D中的每一条时间序列Ti}3.shapelets←;4.FORl←mintomaxDO{Ti中的每一个长度}5.FORu←0to|Ti|-l+1DO{每一个起始位置}6.S←Ti(u,l);7.FORm←0to|D|DO{计算候选shapeletS与8.Ds←狊狌犫犱犻狊狋(S,Tm);9.orderline←sort(Ds);10.quality←assessCandidate(S,orderline,Ds);11.shapelets.add(S,quality);12.sortByQuality(shapelets);13.removeSelfSimilar(shapelets);14.kShapelets←merge(k,kShapelets,shapelets);15.RETURNkShapelets;算法1描述了从数据集中抽取k个最好的shapelets的过程.根据min和max参数设置的范围,每一条时间序列的每一种可能长度的子序列都被做了相应的评估,并最终得到最好的k个shapelets.初始时kShapelets为空(第1行).得到一个候选的shapelet之后,需要计算该shapelet与每一条时间序列间的距离并构建orderline(第7~9行).如算法描述的第9~11行所示,得到一个shapelet的orderline之后,将对其评估并得到它的最大信息增益,然后将其加入到候选shapelets中.在对候选shapelets进行排序时(第12行),主要根据其信息增益的大小进行排列,具体打破平局的方法参见第2节定义7.若两个shapelets来自同一条时间序列并有重叠之处,则认为它们是自相似的,此时需要移除自相似的shapelets(第13行).一旦得到一条时间序列中所有不相似的shapelets,就将它们和现有的最好的shapelets相结合,并保留最好的k个(第14行).候选shapelets与时间序列间距离的计算方法如算法2所示.Shapelets与时间序列比对时,都进行了规范化处理(第2,5行).需要注意的是,在计算距离之前重复地进行规范化会消耗大量的时间,而且同一个序列可能会被规范化多次,而本文将在4.1节所介绍的技术成功避免了这一点.算法2.规范化子序列距离subdist(x,y).输入:时间序列x和y,|x||y|输出:x与y的规范化距离1.bestSum←MAX_VALUE;2.x←zNorm(x);3.FORi←0to|y|-|x|+1DO{y中的每一个起始4.sum←0;5.z←zNorm(yi,|x|);6.FORj←0to|x|DO{计算欧氏距离}7.sum←sum+(zi-xi)2;8.bestSum←min(bestSum,sum);9.RETURN(bestSum/|x|)1/2;得到k个最好的shapelets之后,利用它们将原有的时间序列转换成新的数据集的算法描述如算法3所示.算法3.Shapelets数据转换TransformData(S,D).输入:最好的k个shapeletsS,数据集D输出:转换后的数据集output1.output←;2.FORi←0to|D|DO{D中的每一条时间序列Ti}3.transformed←;4.FORj←0to|S|DO{S中的每一个shapelet}5.dist←狊狌犫犱犻狊狋(Sj,Ti);6.transformed.add(dist);7.output.add(transformed);8.RETURNoutput;对于D中的每一条时间序列Ti,它的子序列距离通过与Sj(j=0,…,k-1)计算得出(第2~5行),得到的k个距离用于构建转换后数据集,即新的数据集中每一条实例具有k个属性,每一个属性值都对应于相应的shapelet到原始时间序列的距离(第6~7行).4加速技术与逻辑shapelets下面,将首先介绍一种更加有效率的时间序列间距离的计算方法[7,13],然后阐述逻辑shapelets转换的基本思想,并给出具体的算法描述.4.1充分统计量在第3节所描述的算法中,对于数据集D中的任意一条时间序列Dx,Dx中起始于任何位置的任意长度的子序列Si都可能是一个候选的shapelet.Page6当计算Si与其他时间序列如Dy之间的距离时,需要将Si在Dy上逐步滑动来找到最小的距离.如图4所示,对于数据集D中的任意两条实例Dx和Dy,S1和S2均为长度为l的子序列,若要计算S1与S2之间的距离,首先需要对S1与S2进行规范化处理,然后计算S1与S2中每一对实值间的距离并取和.显然,当S1与S2的长度和起始位置不断变化时(图4中的虚线所示),会造成许多重复的冗余的计算,若能够将这些计算的中间结果存储起来,等需要的时候直接提取出来,运算效率会得到明显的提升,充分统计量方法恰恰做到了这一点.针对每一对时间序列(Dx,Dy),可以计算5个数组,M,Sx,Sy,Sx2和Sy2.其中数组Sx,Sy用于存储时间序列Dx和Dy中观测值的累加和,即∑x,∑y;数组Sx2和Sy2用于存储Dx和Dy中观测值平方的累加和,即∑x2,∑y2.M是一个用于存储Dx和Dy中不同子序列的乘积和∑xy的二维数组.初始时,所有的数组都被初始化为0,具体表示如下:在式(17)中,t=|u-v|,u和v分别为Dx和Dy中子序列的起始位置.这5个数组并称为Statsx,y.当计算过Statsx,y之后,首先根据它得到序列的均值与方差,然后根据式(5)和(6)计算得到规范化的欧氏距离.具体的算法描述如算法4所示,均值、方差以及任意长度子序列乘积和的计算如下所示.l-1xu+iyv+i=M[u+l-1,v+l-1]-M[u-1,v-1]∑i=0算法4.规范化子序列距离sufficientdist(u,l,Statsx,y).输入:起始位置u,长度l,x与y的充分统计量Statsx,y输出:xu,l与y的规范化子序列距离1.bestSum←MAX_VALUE;2.{M,Sx,Sy,S23.FORi←0to|y|-|x|+1DO{y中的每一个起始4.d←由式(5)和(6)所得到的距离;5.bestSum←min(bestSum,d);6.RETURN(bestSum/|x|)1/2;在算法sufficientdist(u,l,Statsx,y)中,输入为时间序列Dx中某一子序列的起始位置u、长度l以及事先计算好的Statsx,y,输出为子序列通过不断地滑动而得到的与Dy间的最小距离.通过与算法2比较可以得出,subdist(x,y)在计算规范化的子序列距离时,最坏情况下的时间复杂度为O(m2),而充分统计量的计算方法省略了内部的for循环,即只需要O(m)的时间复杂度.所以,依据sufficientdist(u,l,Statsx,y),将获取子序列距离的时间复杂度降低了一个数量级.由于发现shapelets时需要计算每一个候选shapeletS与每一条时间序列T之间的子序列的距离,所以同时也将发现shapelets的时间复杂度降低了一个数量级.4.2逻辑shapalets一个shapelet是由数据集D中某一实例的一个子序列S和一个分裂点阈值t所组成的元组(S,t).很容易想到单个shapelet不足以区分不同的类别的情景.如图5所示,采用一个简单的人造的例子来进行说明.数据集D中包含两类时间序列,A类时间序列既包含波峰又包含波谷,B类时间序列只包含波峰或波谷.假设shapeletsS1,S2,S3的分裂阈值分别为t1,t2,t3,从而可以观察到,(S1,t1),(S2,t2),(S3,t3)都不能很好地将A,B类区分开.当将(S1,t1)和(S2,t2)联合起来时,可以发现,A类和B类被明Page7显地区分了.因此,为达到最好的区分效果,考虑将逻辑操作增加到shapelets的转换中.图5单个shapelet无法区分不同类别的例子图5中所示的逻辑操作是合取操作,用符号“∧”表示,即(S1,t1)∧(S2,t2),同样析取操作用符号“∨”表示.当将逻辑操作加入到shapelets的发现过程中之后,有可能出现(S1,t1)∨(S2,t2)∧(S3,t3)这样一种析取操作与合取操作同时出现的情况,为保持逻辑操作的简洁性,本文只考虑两种情况,一种情况是只有合取操作,另一种是只有析取操作.具体定义如下.定义8.逻辑shapelets.数据集D中的一个逻辑shapelets是一个元组,由D中一个或多个实例的多个子序列所组成,同时包含一个分裂点阈值t以及一个逻辑操作标识opt(opt大于等于0为合取操作,小于0为析取操作),它试图将数据集D分割成两个不同的群组.其可表示为(〈S1,S2,…,Sn〉,t,opt),n(n2)为逻辑shapelets中所包含经典shapelet的个数,并且S1,S2,…,Sn相互之间不重叠.4.3发现逻辑shapelets发现k个最好的逻辑shapelets的算法如算法5所示.与算法1相比较可以发现,两者的前半部分基本相同,但本文在寻找逻辑shapelets时采用了充分统计量技术(第5~12行).注意,文献[7]中使用充分统计量来递归地发现当前最好的shapelets,而本文直接用其来发现k个最好的逻辑shapelets.另外,如第13~16行所示,每找到一个候选shapelet,都对它进行评估,并调用LogicalShapeletsCache()函数来寻找是否有其他shapelet能够与当前shapelet相联合,从而提高它的信息增益以及辨别力.当一条时间序列中的所有逻辑shapelets都被评估之后,调用sortByQuality()函数进行排序(第18行),排序方法与定义7中介绍的相一致,然后移除自相似的逻辑shapelets(第19行).若两个逻辑shapelets中存在来自同一条时间序列并有重叠之处的shapelets,则认为它们是自相似的.自相似的逻辑shapelets中排序靠后者将被移除掉.一旦得到一条时间序列中所有非自相似的逻辑shapelets,就将它们和当前最好的逻辑shapelets相结合,并保留当前最好的k个(第20行).注意当调用mergelogical()函数时,仍需要进行自相似性检测,因为不同时间序列的子序列有可能合取或析取同一子序列.算法5.发现逻辑shapeletsLogicalShapelet-Filter(D,min,max,k).输入:时间序列数据集D,最小长度min,最大长度输出:k个最好的逻辑shapeletskLGShapelets1.kLGShapelets←;2.FORi←0to|D|DO{D中的每一条时间序列Ti}3.logicalshapelets←;4.tempLGShapelets←;5.x←Ti;6.FORj←0to|D|DO{计算x与Tj的充分统计量}7.y←Tj;8.Statsx,y←{M,Sx,Sy,S29.FORl←mintomaxDO{每一个可能的长度}10.FORu←0to|Ti|-l+1DO{每一个起始位置}11.FORm←0to|D|DO{计算候选shapeletS与12.Ds←狊狌犳犳犻犮犻犲狀狋犱犻狊狋(u,l,Statsx,y);13.orderline←sort(Ds);14.quality←assessCandidate(S,orderline,Ds);15.tempLGShapelets.add(S);16.tempLGShapelets←犔狅犵犻犮犪犾犛犺犪狆犲犾犲狋狊犆犪犮犺犲(D,17.logicalshapelets.add(tempLGShapelets);18.sortByQuality(logicalshapelets);19.removeSelfSimilarlogical(logicalshapelets);20.kLGShapelets←mergelogical(k,kLGShapelets,21.RETURNkLGShapelets;获取逻辑shapelets的算法如算法6所示.此算法是一个递归算法,当逻辑shapelets中shapelet的数目超过阈值n或者找不到比当前shapelet/逻辑shapelets更好的逻辑shapelets时,递归循环终止(第1~3行,18~25行),所以此算法得到的是合取或析取后能够使当前shapelet/逻辑shapelets的信息增益最大的子序列.本文仍采用充分统计量来计Page8算子序列距离(第6~8行).若一个候选shapeletS与LogicalShapelets是自相似的,则不再访问此shapelet(第9~12行).当得到一个候选shapelet的orderline之后,需要将此候选shapelet的orderline与当前shapelet/逻辑shapelets的orderline相结合,构建逻辑shapelets的orderline(第15~16行).但对于逻辑shapelets中的合取与析取操作,怎么定义它的orderline呢?如第16行所示,这里采用一种比较简单的方式来联合各个shapelet的orderline,从而组成逻辑shapelets的orderline.对于“∧”操作,各个shapelet的orderline上相应实例的最大距离将被当做新的orderline上的距离;而对于“∨”操作,则选择最小的距离.注意,这些操作并不影响熵和信息增益的计算.算法6.获取逻辑shapeletsLogicalShapelets-Cache(D,min,max,n,lgshapelet,orderline).输入:时间序列数据集D,最小长度min,最大长度max,输出:逻辑shapeletsLogicalShapelets1.LogicalShapelets←lgshapelet;2.IFnLogicalShapelets.size()3.RETURNLogicalShapelets;4.BestQuality←lgshapelet.quality;5.tempLGShapelets←;6.FORi←0to|D|DO{D中的每一条时间序列Ti}7.FORj←0to|D|DO{计算Ti与Tj的充分统计量}8.Statsx,y←{M,Sx,Sy,S29.FORl←mintomaxDO{每一个可能的长度}10.FORu←0to|Ti|-l+1DO{每一个起始位置}11.IFselfSimilaritylogical(LogicalShapelets,S)12.CONTINUE;13.FORm←0to|D|DO{计算候选shapeletS与14.Ds←狊狌犳犳犻犮犻犲狀狋犱犻狊狋(u,l,Statsx,y);15.lgorderline←sort(Ds);16.orderline←mergeTwoLines(lgorderline,17.quality←assessCandidate(S,orderline,Ds);18.IFquality.betterthan(BestQuality)19.tempLGShapelets←lgshapelet;20.tempLGShapelets.add(S);21.BestQuality←quality;22.LogicalShapelets←tempLGShapelets;23.IFLogicalShapelets.size()<n24.LogicalShapelets←犔狅犵犻犮犪犾犛犺犪狆犲犾犲狋狊犆犪犮犺犲(D,25.RETURNLogicalShapelets;另外,采用逻辑shapelets进行时间序列转换时有可能发生过拟合现象.若所发现的逻辑shapelets为(S1,t1)∨(S2,t2)∨…∨(Sn,tn),其中n为数据集D中某一类时间序列(如A)的实例个数,Si(i=1,2,…,n)为类A中不同实例的子序列.此时,在数据转换之后所有类标为A的实例与此逻辑shapelets所对应的属性值均为0,并且抽取的逻辑shapelets的数量和质量也会因此而降低(小于k),进而降低分类的准确性.为避免过拟合现象,一般情况下,将逻辑shapelets中经典shapelet的数量设置为2,并根据数据集的大小进行不断调整,最大数量硬性规定为5.4.4转换时间序列采用逻辑shapelets转换的主要动机之一是为了将时间序列分类问题应用于传统的分类算法上.当抽取k个逻辑shapelets之后,将对初始数据集进行基于逻辑shapelets的时间序列转换,数据集中的每一条时间序列被转换成拥有k个属性的实例,每个属性的值对应于该时间序列与逻辑shapelets之间的距离.如算法7所示,距离的计算采用了4.1节所描述的充分统计量技术(第7、9行),当逻辑操作标识opt大于等于0时,表示合取操作,此时需计算逻辑shapelets中每一个shapelet与当前时间序列间的距离,并取最大者作为转换后实例的属性值.opt小于0则取最小值.算法7.逻辑shapelets转换TransformData(S,D,opt).输入:最好的k个逻辑shapeletsS,数据集D,逻辑操输出:转换后的数据集output1.output←;2.FORi←0to|D|DO{D中的每一条时间序列}3.transformed←;4.FORj←0to|S|DO{S中的每一个逻辑shapelets}5.FORm←0to|Sj|DO{Sj中的每一个shapelet}6.IF(opt0){合取操作}7.dist←Max(狊狌犳犳犻犮犻犲狀狋犱犻狊狋(u,l,Statsx,y));8.ELSEIF(opt<0){析取操作}9.dist←Min(狊狌犳犳犻犮犻犲狀狋犱犻狊狋(u,l,Statsx,y));10.transformed.add(dist);11.output.add(transformed);12.RETURNoutput;初始的时间序列数据集被转换之后,即可应用于传统的分类算法如贝叶斯分类器、决策树、1-NN等等.本文将在第5节验证所提出算法的分类准确率.Page94.5分类与准确率计算分类器在给定测试集上的准确率是分类器正确分类的测试集元组所占的百分比.发现k个最好的逻辑shapelets之后,通过将初始数据集转换成新的数据集,就可以将时间序列分类问题转换成传统的分类问题,并使用传统分类器在测试集上的分类准确率来评价逻辑shapelets转换的表现.如算法8所示,首先将训练集和测试集分别转换成新的训练集和测试集(第1~2行),然后根据转换后的训练集和相应的分类算法建造分类器,此处的分类器C可以是贝叶斯分类器、决策树、1-NN分类器等等(第3行).最后,针对转换后测试集中的每一条实例,若分类器预测的类标与真实类标相同,则计数值加1(第5~9行),最终返回该分类器的分类准确率(第10~11行).算法8.分类准确率Accuracy(C,D,T).输入:分类器C,训练数据集D,测试数据集T输出:分类准确率accuracy1.D←犜狉犪狀狊犳狅狉犿犇犪狋犪(S,D,opt);2.T←犜狉犪狀狊犳狅狉犿犇犪狋犪(S,T,opt);3.C←BuildClassifier(C,D);4.accuracy←0;5.FORi←0to|T|DO{T中的每一条时间序列Ti}6.class_label←getClasslabel(Ti);7.predict_label←ClassifyInstance(C,Ti);8.IFpredict_label.equal(class_label)9.accuracy←accuracy+1;10.accuracy←accuracy/|T|;11.RETURNaccuracy;5实验评估在此部分,将评估所应用的加速技术以及逻辑shapelets转换技术.首先,将应用充分统计量技术后的ShapeletFilter算法[1]命名为ShapeletAcc算法,由于相关的时间复杂度分析已在4.1节中给出,本文将从时间上对比ShapeletAcc算法与Lines等人提出的ShapeletFilter算法[1];然后通过实验验证使用逻辑shapelets转换进行分类的准确性.所采用的数据集由Ding等人[3]以及Keogh等人①所提供.所有的算法和实验都是在Weka框架下实现的.5.1参数设置本文所提出的算法需要从时间序列数据集中抽取出k个逻辑shapelets,由于k值仅仅表示抽取的逻辑shapelets的数量,它并不影响得到的逻辑shapelets的质量,但我们无法保证设置的k值能够转换出最适合分类的数据.当k值设置过小时,所得到的逻辑shapelets可能不足以提供分类决策所需要的信息;而k值设置过大时,可能造成过拟合现象或降低重要逻辑shapelets的辨别性.在实验中,为保持k值设置的一致性和简洁性,我们将k值设置为m/2,这里m为时间序列中属性的个数.另外,算法中的两个长度参数min和max的设置也是一个难题.由于它们定义了候选shapelets/逻辑shapelets的长度范围,参数设置不正确时可能发现不了最具有辨别性的shapelets/逻辑shapelets,从而对分类器的准确率造成影响.同样为保持最大长度和最小长度设置的一致性和简洁性,统一将最小长度设置为m/10,最大长度设置为m/2.5.2速度对比此处将对比基于shapelets转换的ShapeletFilter算法和本文使用充分统计量之后的改进算法ShapeletAcc.尽管采用充分统计量之后,发现shapelets的速率得到了很大的提升,但由于在寻找逻辑shapelets时需要重复地遍历数据集,一般情况下,发现逻辑shapelets需要消耗较多的时间.虽然改进了原有算法的效率,但发现shapelets的过程仍是一项耗时的工作,所以尽量采用实例或属性较少的数据集进行测试,并舍弃了那些无法在24h之内得到结果的数据集.所采用的数据集如表2所示.SonyAIBORobotSurfaceSonyAIBORobotSurfaceIIsynthetic_controlTwoLeadECGDiatomSizeReductionECGFiveDayGun_PointItalyPowerDemand①KeoghE,XiX,WeiL,RatanamahatanaCA.TheUCRPage10表格的第1列为数据的名称,发现k个shapelets的过程是在各个数据的训练集上完成的,时间的单位为s,所得数值均为10次测量求平均值的结果.从表中可以看到,ShapeletAcc算法的运行时间明显少于ShapeletFilter算法,最大的加速比可达47.78倍,更直观的图形表示如图6所示.图6ShapeletAcc与ShapeletFilter的加速比5.3逻辑shapelets转换与shapelets转换的对比此部分将对比基于逻辑shapelets转换的时间表3逻辑shapelets转换与shapelets转换的对比算法LG-ANDLG-ORShapeletsLG-ANDLG-ORShapeletsLG-ANDLG-ORShapeletsLG-ANDLG-ORShapeletsLG-ANDLG-ORShapeletsLG-ANDLG-ORShapelets91.0293.5192.3589.3081.0183.3299.3999.9199.8288.6685.2287.2293.2096.0293.49100.0099.5499.19从表3中可以观察到,多数情况下,基于逻辑shapelets转换的算法LG-AND和LG-OR在各种类型分类器上的表现优于shapelets转换算法[1].平局的情况大多出现在以信息增益为度量的决策树或决策树组合模型中,如三者在C4.5算法的准确率对比上出现了5次平局.究其原因,是因为在选取shapelets或者逻辑shapelets时采用信息增益作为度量标准,而C4.5算法在选择信息增益最大的属性时,必然优先选择与信息增益最大的shapelet或者逻辑shapelets相对应的属性,若两者在决策树的序列分类算法和基于经典shapelets转换的时间序列分类算法.在进行逻辑shapelets转换时,我们考虑只是合取或者只是析取这两种情况,分别将两种算法命名LG-AND和LG-OR.需要注意的是,初始时,将k值设定为m/2,m为时间序列中属性的个数.为保持对比的公平性,当逻辑shapelets的个数小于m/2时,将补入经典的不相似的shapelet以满足相应的个数.若发现的全部shapelets的个数n小于m/2,则将k值设置为n.为避免偏差,在进行实验时,所有的逻辑shapelets和经典shapelets都是从训练集中抽取出来的,然后再将训练集和测试集分别转换成新的适用于不同分类器的数据.所有的分类器都是根据训练集建立然后在测试集上进行测试的.由于实验是在Weka框架下进行的,所采用的分类器均使用了Weka的默认设置.具体的分类准确率对比如表3所示.某条路径上的信息增益相同(此时逻辑shapelets的分裂间隔较大)或相近,则会生成类似的决策规则.在LG-AND和LG-OR的对比中,LG-AND在14个分类器上优于LG-OR,LG-OR在15个分类器上占优,两者持平7次,所以从整体上说,LG-AND与LG-OR的表现差别不大.5.4逻辑shapelets转换与其他分类器的对比1-NN分类器是当前解决时间序列分类问题的最好分类器之一,为进一步验证本文所提出的基于逻辑shapelets转换的时间序列分类算法的性能,在此Page11部分,将对比基于欧氏距离的1-NN分类器和基于逻辑shapelets转换的1-NN分类器.另外,本文也对比了基于逻辑shapelets转换后的C4.5分类器和直接采用shapelets实现的决策树[4]的分类准确性.从表4SonyAIBORobotSurfaceSonyAIBORobotSurfaceII表4准确率对比LG-1NN/%5.5实验总结首先,通过相应的时间对比实验,验证了充分统计量技术能够大幅度提高shapelets的发现效率;其次,通过与基于shapelets转换的时间序列分类算法和其他经典时间序列分类算法的对比实验,验证了所提出的基于逻辑shapelets转换的时间序列分类算法的分类准确性.同时,在实验过程中也发现了一些shapelets转换技术的缺点,比如分类器训练时间较长,k值以及shapelets最大最小长度的设定比较困难等.6结论与展望在本文中,介绍了一种用于快速发现shapelets的充分统计量技术,并针对shapelets的不足,提出了一种基于逻辑shapelets转换的时间序列分类算法,通过实验验证了所提出算法的分类准确性.基于逻辑shapelets转换的缺点之一是训练时间相对较长,一种潜在的缓解方式是通过对训练集采样,即使用原始数据的一小部分子集来发现逻辑shapelets.另外,还可以进一步考虑聚类相似的逻辑shapelets,然后从每一簇中得到一个代表性的逻辑shapelets来代替寻找k个逻辑shapelets进行数据转换等.致谢在此需要感谢JasonLines提供关于shapelets转换的源代码和针对相关问题的解答.同时也感谢匿名审稿人对本文提出宝贵意见!
