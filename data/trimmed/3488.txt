Page1CoPrivacy:一种用户协作无匿名区域的位置隐私保护方法黄毅霍峥孟小峰(中国人民大学信息学院北京100872)摘要基于位置的服务的广泛应用给人们的生活带来了极大的便利.但是用户在享受这些便利服务的同时,个人的位置隐私也面临着严重的威胁.目前,典型的位置隐私保护技术是基于中心服务器的位置k-匿名方法.该方法容易使中心服务器成为性能瓶颈和集中攻击点,也容易造成查询处理过程的复杂化,且牺牲了用户的服务质量.文中提出了一种用户协作无匿名区域的隐私保护方法CoPrivacy,该方法通过用户之间协作形成匿名组,匿名组内的用户用该组的密度中心代替真实位置发出查询,并增量地从服务器获得近邻查询结果.组内成员通过近邻查询结果与自身位置之间的距离计算得出精确的查询结果.CoPrivacy在不使用匿名区域的情况下达到了k-匿名的效果,不牺牲用户的服务质量,并且提高了匿名系统的整体性能,简化了服务提供商的查询处理过程.文中在真实数据和模拟数据集上进行了充分的实验,验证了该方法的优越性.关键词基于位置的服务;位置隐私;隐私保护;用户协作;增量近邻查询1引言随着无线通信和移动定位技术的不断发展,特别是移动网络和GPS定位技术的普及和广泛应用,促使一种新的应用模式———基于位置的服务(LocationBasedServices,LBS)的产生和发展.简而言之,LBS是由位置服务提供商提供的基于用户位置的增值服务[1],目前主要有这几种应用:基于位置的旅游信息服务(如查询“离我最近的博物馆”等)、基于位置路线导航(如查询“最近的加油站/电影院”等)、基于位置的紧急救援服务(如查询“离我最近医院”等)和基于位置的广告服务(如“向超市10m范围内的客人发送优惠券”等)[2]等.这些查询大多都依赖k近邻(k-Nearest-Neighbor,kNN)查询.基于位置服务的广泛应用给人们的生活带来了极大的便利,然而,用户在使用这些服务时,可能面临着隐私泄露的威胁.恶意的位置服务提供商或其它针对位置服务器的攻击者根据用户位置和查询内容信息鉴别出用户身份,进而获得用户的隐私信息.为了解决位置服务中的隐私保护问题,文献[3]最早提出了位置k-匿名模型.它的基本思想是在发布用户位置的时候,用一个覆盖其它k-1个用户的匿名区域代替用户的真实位置,从而使得位置服务提供商无法从k个用户中鉴别出某个用户.目前大多数基于k-匿名模型的研究[4-8]都采用如图1所示的基于中心服务器(TrustedThirdPartybased,TTP-based)的结构.用户将其位置信息、查询内容和隐私需求k发送给中心匿名服务器(TTP),匿名服务器根据用户的隐私需求k,将用户的精确位置扩展为包含其它k-1个用户的匿名区域,然后再将该区域和用户的查询发送给位置服务提供商.得到结果集后,匿名服务器根据用户的位置,从结果集里计算出满足用户查询需求的精确结果,再返回给查询用户.然而,使用中心服务器结构存在一些问题,主要体现为以下几点:(1)中心服务器容易成为系统性能瓶颈和集中攻击点;(2)中心服务器掌握所有用户的位置信息和查询信息,如果被黑客攻击,隐私泄露严重;(3)使用中心服务器代理查询会消耗额外的计算资源和通信代价.鉴于中心服务器结构的诸多不足,越来越多的研究采用无中心服务器结构的隐私保护方法[9-13].大多数无中心服务器结构的方法都采取用户协作的方法来计算满足k-匿名的区域,这样虽然避免出现性能瓶颈和集中攻击点,但基于匿名区域的查询仍然需要位置服务提供商和用户端进行大量的计算和较大的通信代价,此外,这些方法大多假设协作用户之间是可信的,如果恶意用户相互串通,其他用户的隐私将受到威胁.文献[13]提出了SpaceTwist方法,用户随机选取自己真实位置附近的点作为锚点,然后使用该锚点代替自己的真实位置向位置服务提供商发起增量近邻查询,再根据用户真实位置和返回的结果进行计算,得到精确的查询结果.虽然SpaceTwist避免了使用匿名区域查询造成的高计算代价和通信代价,但是SpaceTwist缺少用户之间协作,无法达到位置k-匿名.根据文献[13]的分析,攻击者通过分析用户的查询,可以将用户的位置限定在一个区域中,如果该区域只有一个用户发起查询,攻击者就有可能根据查询内容鉴别出用户,进而获得该用户的隐私.结合用户协作结构和增量近邻查询处理的优点,本文提出了一种基于用户协作的隐私保护方法CoPrivacy,该方法不需要中心服务器,不生成匿名区域,用户之间通过单跳和多跳协议形成匿名组.组内用户使用该组形成区域的密度中心作为锚点,并使用该锚点代替自己的真实位置向服务提供商发起增量的近邻查询[14],最后,每个用户根据自己的真实位置和增量近邻查询返回的结果计算得到精确的近邻查询结果.此外,用户可以根据自己的隐私需求,指定个性化的匿名参数k.同时,为了达到更好的隐私保护效果,用户可以指定相对的隐私保护区域半径s,进一步提高位置隐私保护度.本文的贡献主要表现在以下几个方面:(1)提出了一种新的基于用户协作的无匿名区域的隐私保护方法CoPrivacy,不使用中心服务器,杜绝了性能瓶颈和攻击中心.(2)以SpaceTwist增量近邻查询方法为基础设计了一种新的锚点的产生策略,该策略在不使用匿名区域的情况下达到位置k-匿名,保证了匿名区域最小半径s,提高了隐私保护度,简化了查询处理过程.由于采用了增量近邻查询,保护位置隐私的同时Page3不用牺牲用户的服务质量.(3)在用户协作的系统结构下,提出了一种通信协议,使系统中的节点可以通过较少的通信代价找到k-匿名组.(4)针对本文提出的方法在真实数据和模拟数据集上进行了充分的实验,验证了该方法的优越性.本文第2节主要介绍位置隐私保护的相关工作;第3节介绍CoPrivacy的系统架构;第4节详细介绍CoPrivacy的实现算法;实验结果展示和分析在第5节;最后,第6节总结本文工作,展望未来研究工作.2背景及相关工作从系统结构的角度来看,LBS中的隐私保护方法主要分为两类:基于中心服务器的位置隐私保护方法和无中心服务器的位置隐私保护方法.其中无中心服务器的隐私保护方法又可进一步分为用户协作的方法和无协作的方法.下面将分别介绍一下基于中心服务器和无中心服务器的两类位置隐私保护方法.2.1基于中心服务器的位置隐私保护方法基于中心服务器的隐私保护方法最早被提出来并获得了广泛的研究.文献[3]最早提出了时空匿名方法,将k匿名模型应用于位置隐私保护.但它假设所有用户拥有相同的隐私需求参数k,用户无法根据自身需求指定个性化的隐私需求.此外,它独立处理每个用户的请求,伸缩性比较差.文献[4]提出了CliqueCloak方法,支持个性化的隐私需求参数k,但限于计算复杂度,CliqueCloak仅支持比较小的隐私需求参数k,一般为5~10.文献[7]对文献[4]的工作进行了改进,除了支持个性化的隐私需求参数k外,还允许用户指定可以容忍的最长匿名延迟时间和匿名空间的最大值.文献[5]提出了casper方法,主要关注基于匿名区域的查询处理方法.文献[6]使用有向图来表示用户之间的关系,要求用户同时被其它k个匿名区域覆盖,达到了更好的隐私保护效果.文献[8]提出了PrivacyGrid方法,将空间分割成网格,使用自顶向上的方法求取匿名区域.同时,它引入了位置l-多样化的概念,增强了用户的隐私保护效果.由于位置k-匿名方法将一个点扩大为一个匿名区域,在达到位置隐私保护的同时,往往以牺牲用户的服务质量作为代价.隐私保护度越高,服务质量就越低,这也成为位置k-匿名方法的主要缺点之一.2.2无中心服务器的位置隐私保护方法无中心服务器的用户协作方法与我们提出的方法最为接近.用户通过相互协作,形成满足k-匿名的用户组,再使用组内用户的最小边界矩形或者假位置代替用户真实位置向位置服务提供商发起查询.文献[9]提出了P2P空间匿名方法,用户之间通过自组织通信形成用户组,再计算组内用户的最小边界矩形,发起查询的用户从组内用户中随机选取一个邻居作为代理,由代理替用户向位置服务提供商发起查询,并将结果转发给发起查询的用户.文献[10]提出了Prive方法,它基于希尔伯特曲线,将所有用户信息构建成一颗分布式的B+树,根据B+树中节点信息来形成基于希尔伯特曲线的k-匿名区域.文献[11]提出了一种基于假数据的方法,用户向其真实位置中添加高斯噪音,发送给TTP,TTP收到k个用户的位置信息后计算出一个假位置,k个用户都使用该假位置代替其真实位置,达到k-匿名的效果.文献[12]对文献[11]的工作进行了扩展,将基于中心服务器结构转换成基于用户协作的结构.无用户协作的方法是指用户主动降低位置信息的质量,通常有使用假位置或加密的方法实现位置隐私保护.文献[13]提出了SpaceTwist方法,用户随机选取自己真实位置附近的点作为锚点,然后使用该锚点代替自己的真实位置向位置服务提供商发起增量近邻查询.如图2所示,SpaceTwist维持供应空间和需求空间两个参数,其中供应空间是以锚点为圆心,包含位置服务提供商返回的所有近邻结果的圆形区域;需求空间是以用户真实位置为圆心,以用户与他已经发现的第k个近邻为半径的圆形区域.查询开始时,供应空间为空,需求空间为整个空间.位置服务提供商不断返回近邻查询结果,供应空间会不断扩展而需求空间会不断收缩,当供应空间完全覆盖需求空间时,用户已经找到查询的k个近邻,查询结束.Page4虽然SpaceTwist避免了使用匿名区域查询造成的高计算代价和通信代价,但是SpaceTwist缺少用户协作,且无法达到位置k-匿名,隐私保护度不高.根据文献[13]的分析,攻击者通过分析用户的查询,可以将用户的位置限定在某个区域中,如果该区域只有一个用户发起查询,攻击者就有可能根据查询内容鉴别出用户,进而获得用户的位置隐私和查询内容隐私.文献[15]中提出了一种使用中心服务器的改进算法,使得SpaceTwist达到k-匿名的效果.本文与上述工作的不同之处在于:本文提出的方法在不使用中心服务器的系统结构下,不使用匿名区域就可以达到位置k-匿名的效果,避免了系统瓶颈和攻击中心,并且采用增量近邻查询方式向服务提供商发出查询,可以获得精确的查询结果.该方法在提高了位置隐私保护度的同时并不牺牲用户的服务质量,并且简化了服务提供商的查询处理过程.根据我们的调研,目前尚未发现类似的工作.3CoPrivacy方法系统结构随着移动设备的发展,客户端的计算能力和存储能力大幅提升,将计算模块放入客户端的系统结构变得切实可行.本文提出的CoPrivacy系统结构由移动用户和服务提供商两部分组成.移动用户通常为含有定位设备的手机或者其他终端,它包含了通信协议、位置匿名以及查询处理3个模块.位置服务提供商为提供位置服务的服务器,它主要提供基于位置的近邻查询、范围查询等服务,如图3所示.在我们提出的系统架构中,假定所有的移动用户都是可信的.在通信协议模块中,移动用户支持两种通信方式:P2P通信和无线互联网通信.其中P2P通信方式用来与其他移动用户进行自组织通信,无线互联网用来向位置服务提供商发起查询并取得查询结果.P2P通信可以通过无线局域网(WLAN)或蓝牙等方式实现,无线互联网主要为基于移动基站的2G或3G网络.该模块包含了一种用户协作的通信协议,移动用户通过单跳或多跳的方式向近邻的移动用户互相通信.在位置匿名模块中,移动用户可以根据自己的隐私需求设置个性化隐私保护参数k和s.其中,k表示相对匿名度,即用户与其他k-1个移动用户无法区分.s表示用户的相对匿名区域半径.通信协议模块中得到近邻用户后,位置匿名模块根据用户设置的参数将至少k个用户组成一个匿名组,计算该匿名组所在区域的密度中心作为锚点.查询处理模块中,匿名组中的用户使用该匿名组的锚点代替自己的真实位置向服务提供商发出增量近邻查询.每个用户根据自己的真实位置和增量近邻查询返回的结果计算得到精确的近邻查询结果,并保证返回近邻查询结果覆盖的区域半径大于等于s.4CoPrivacy位置隐私保护方法在上述系统结构下,本文提出了一种基于用户协作的无匿名区域的位置隐私保护方法CoPrivacy.这部分将对算法的具体处理过程做详细描述.4.1预备知识示为以下形式:定义1(查询Q).用户发出的查询Q可以表其中:经度;y表示位置的纬度;l=(x,y)表示查询发出的位置,x表示位置的v表示查询发出时的运动速度;t表示查询发出的时刻;con表示用户输入的查询内容;k表示用户指定的匿名参数;s表示用户指定的匿名区域半径.参数l,v,t可由GPS定位设备直接获得;参数con,k,s是需要用户指定的内容.参数k和s是用户设置的隐私保护参数.k越大,隐私保护效果越好,但需要更长的时间来发现近邻用户;s越大,用户的隐私保护效果越好,但是增量近邻查询处理时间越长.定义2(k-匿名组kAG).可以形式化地表示为其中:gid表示该匿名组的标识符;k表示该匿名组中含有的成员个数;anchor表示该匿名组的锚点,也就是每个成员发出查询时使用的位置,它可以通过计算匿名组的密度中心获得.Page54.2用户协作与位置匿名在用户协作的隐私保护系统中,查询用户有三种状态:不在任何匿名组中;已在匿名组中但未获得锚点;已在匿名组中且已获得锚点.不在任何匿名组中的用户在发出查询时通过P2P单跳或多跳通信的方式发现近邻用户,如果近邻用户的数目大于k,则形成满足k-匿名的匿名组,此时,组内的用户已在匿名组中,但未获得锚点;然后,计算该组用户的MBR密度中心所在的位置作为锚点,最后以广播的形式将锚点发送给组内的所有用户,组内用户都在匿名组中,且获得了锚点.最后,用户用锚点代替自己的真实位置发出查询,查询结束后,匿名组解散,用户重新回到初始状态.具体来说,上述过程可以分为节点发现、计算锚点、广播锚点3个步骤.步骤1.节点发现.不在任何匿名组中的查询用户rq发出查询.rq首先生成新的组编号gid,并将广播跳数h设置为1,已发现邻居节点集P置为{φ},已发现节点个数n置为|P|,即为0,组内用户隐私需求参数k为用户隐私需求参数rq.k(算法1第2~5行).然后广播节点发现的消息FORM_GROUP,消息内容为参数h和gid(算法1第7行),并等待邻居节点的响应.接收到响应消息的节点集合为P后,rq将n置为P中节点个数,并将k更新为P中所有节点最大的隐私需求参数k(算法1第8~10行).然后再比较n和k-1,如果n>k-1,说明发现的节点数已经满足所有节点的匿名需求参数k,不再广播节点发现的消息;否则先比较P和P,如果二者相等,说明增加跳数无法发现更多的节点,无法通过广播节点发现的消息获得更多用户,节点发现结束,匿名失败;如果二者不相等,说明增加广播跳数可以发现更多用户,将h加1,P置为P,继续广播节点发现消息FORM_GROUP,等待用户响应(算法1第12~16行).节点发现完毕后,用户rq将自身节点加入到已发现邻居节点集P,已发现节点个数n加1(算法1第18行).算法1.节点发现Discover-Peers.1.//节点为rq2.生成gid3.设置跳数h←14.rq.gid←gid5.已发现的节点集合P←{φ},发现的节点个数n←6.whilen<k-17.广播发现节点消息FORM_GROUP,消息内容为8.接收到响应消息的节点集合为P9.n=|P|10.k←P中所有节点的最大k值11.ifn<k-1then12.ifP=Pthen13.循环结束14.endif15.h←h+1;P←P16.endif17.endwhile18.P←P∪{rq};n←n+119.//计算锚点20.R←P中所有节点的MBR21.c←R中MBR的密度中心点22.rq.anchor←c23.rq.gn←n24.//广播锚点25.广播获得锚点的消息ANCHOR_ACQUIRED,消邻居节点r0在收到节点rq发送的节点发现消息FORM_GROUP后的处理流程如算法2所示.r0首先检查r0.gid是否为空,或者r0.gid是否等于接收到的gid(算法2第2行),如果不满足条件,则说明用户已经加入别的组,不用响应当前接收到的FORM_GROUP消息,如果满足条件,r0首先将自己的组编号r0.gid置为接收到的gid,将已发现的节点集合Tp置为{φ}(算法2第3~4行).然后,r0检查接收到的广播跳数h,如果h>1,说明接收到的FORM_GROUP消息需要多跳广播,r0将h减1后继续广播FORM_GROUP消息(消息内容为h和gid)并等待邻居节点的响应.接收到邻居节点的响应后,r0将响应节点Tp集合设置为已发现的节点集合Tp(算法2第6~10行).最后,r0将包含自身的编号id,位置r0.l,隐私需求参数r0.k,运动速度r0.v和时间戳t的元组加入Tp,并将Tp发送给请求节点rq(算法2第11~12行).步骤2.计算锚点.用户rq发现邻居节点集P后,首先计算P中所有节点的MBR为R,然后计算R的密度中心c作为锚点.最后将自身的锚点rq.anchor置为c,组内用户个数rq.gn置为n(算法1第20~23行).算法2.响应节点发现Response-Discover-Peers.输入:广播跳数h,组编号gid1.//节点本身为r0,请求节点为rq2.ifr0.gid=NULLorr0.gid=gidthen3.r0.gid←gid4.已发现结点集合←{φ}Page65.ifh>1then6.h←h-17.广播发现节点的消息FORM_GROUP,消息内8.接收到响应消息的节点集合为Tp9.Tp←Tp10.endif11.Tp←Tp∪{〈id,r0.l,r0.k,r0.v,t〉}12.将Tp发送给请求节点rq13.endif步骤3.广播锚点.用户rq计算得到锚点c后,将广播获得锚点消息ANCHOR_ACQUIRED,消息内容为c,n,h和gid,将获得的锚点广播给组内的所有用户.邻居节点r0接收到获得锚点消息ANCHOR_ACQUIRED的处理流程如算法3所示.算法3.响应获得锚点Response-Anchor.输入:锚点c,组内用户个数n,广播跳数h,组编号gid1.//节点本身为r02.ifr0.gid=gidthen3.r0.anchor←c4.r0.gn←n5.ifh>1then6.h←h-17.广播获得锚点的消息ANCHOR_ACQUIRED,8.endif9.endifr0首先检查自身的组编号r0.gid是否与接收到的gid相同(算法3第2行),如果不相同则不做出响应;如果相同则将自身的锚点r0.anchor置为接收到的锚点c,将组内用户个数r0.gn置为接收到的参数n(算法3第3~4行).最后检查接收到的广播跳数h,如果h大于1,说明接收到的ANCHOR_ACQUIRED消息需要多跳广播,r0将h减1,再广播一次获得锚点消息ANCHOR_ACQUIRED,消息内容为c,n,h和gid(算法3第5~8行).通过上述3个步骤,发出查询的移动用户通过相互协作组成了匿名组,且组内的每个移动对象都得到了锚点.此时,用户可以用锚点代替自己的真实位置发出查询.4.3增量近邻查询处理用户获得锚点后,首先对比自己的隐私需求参数k和组内用户个数gn.如果gnk,用户所在的匿名组满足用户的k-匿名需求,用户可以直接使用获得的锚点向位置服务提供商发起增量近邻查询,如果gn<k,用户所在的匿名组不满足用户的k匿名需求,为了满足用户的k匿名需求,还需向位置服务提供商发起k-gn次假查询.增量近邻查询的流程如算法4所示.用户维持一个按照增量查询返回结果同用户距离dist(p,r0.l)顺序建立的大顶堆Wk,用来记录目前已经发现的k个近邻,初始化插入r0.n组〈NULL,〉到Wk,需求空间γ为中堆顶元组的距离,供应空间τ为0.用户使用锚点位置r0.anchor向位置服务提供商发起增量近邻查询,会不断接收的返回的INN查询结果.对于每一个接收到的近邻结果p,首先使用dist(p,r0.anchor)更新用户的供应空间τ,然后判断此时用户与p点距离dist(p,r0.l)是否小于γ,如果小于则用p,dist(p,r0.l)更新Wk,用Wk堆顶元组的距离更新γ.当τ>γ+dist(r0,r0.anchor)并且τ>r0.s,表示供应空间完全覆盖需求空间和用户指定的最小隐私区域,此时用户已经获得r0.n个最近邻Wk,结束增量近邻查询.由增量近邻查询处理过程可知,用户最终得到的是精确的查询结果,本文提出的方法在实现位置隐私保护的同时,并未牺牲服务质量.算法4.增量近邻查询INN-Query.1.//节点本身为r02.Wk←按照查询结果同用户距离顺序建立的大顶堆3.初始化插入r0.n组〈NULL,〉到Wk4.供应空间大小τ←05.需求空间大小γ←Wk堆顶元组的距离6.使用锚点位置r0.anchor向位置服务提供商发起增7.whileγ+dist(r0,r0.anchor)>τandτ<r0.s8.从位置服务提供商接收到的响应包为S9.forS中每一个点p10.τ←dist(p,r0.anchor)11.ifdist(p,r0.l)<γthen12.用p,dist(p,r0.l)更新Wk13.γ←Wk堆顶元组的距离14.endif15.endfor16.endwhile17.结束增量近邻查询18.returnWk4.4算法分析服务质量以及算法时间复杂度进行分析.4.4.1隐私保护度与服务质量分析CoPrivacy算法从两个方面保证了算法的隐私度:k-匿名和用户指定最小区域s.即使在攻击者知晓本节将主要对CoPrivacy算法的隐私保护度、Page7移动对象分布的前提下,位置k-匿名能保证披露风险低于1/k.最小区域s可以保证k个用户的位置分布不至于过于密集.当攻击者不知晓移动对象的分布情况时,位置k-匿名的披露风险为1/ClocakArea,其中CloakArea表示相对匿名区域面积,即以锚点为圆心,以s为半径的圆形区域面积.在服务质量方面,本文所采用的增量近邻查询是一种精确的查询方法[13].在保护移动对象位置隐私的同时并未牺牲任何服务质量.4.4.2算法复杂度分析移动客户端的计算能力有限,所以匿名算法不能过于复杂.在CoPrivacy中,仅最先发起查询的用户需要计算该组的锚点,其它客户端仅需进行与周围客户端通信、接受锚点等操作.因此,客户端匿名算法的时间复杂度为O(k),k为移动用户指定的匿名需求参数.5实验5.1实验环境算法采用Java实现,在Q84002.6GHz处理器、4GB内存的Windows7平台上运行,采用真实的数据集和模拟数据集两组数据进行实验.真实数据使用北京市出租车一天中产生的GPS数据集,区域面积约为25.07km×16.78km,以下简称为出租车数据集;模拟数据集由移动数据管理研究业界认可的ThomasBrinkhoff路网数据生成器[16]生成,它以城市Oldenburg的交通路网(区域面积为23.57km×26.92km)作为输入,生成模拟的移动用户数据,以下简称为Oldenburg数据集.如果没有具体说明,实验中使用数据的默认参数值如表1所示.移动用户数量匿名需求参数k隐私保护区域半径s用户近邻查询需要的近邻个数n位置服务提供商中查询对象个数实验模拟一个半双工的网络通信信道,带宽为1Mbps,移动用户使用该信道进行P2P通信;同时假设移动用户与位置服务提供商之间使用3G网络通信,带宽为2Mbps.移动用户之间P2P通信消息和位置服务提供商返回的消息都是64字节.我们在真实数据集和模拟数据集上对CoPrivacy方法的平均响应时间、匿名成功率、用户协作平均通信消息量、增量近邻查询平均结果大小等方面进行实验,评估了算法的可伸缩性以及隐私保护度,并用CoPrivacy方法和基于中心服务器的PrivacyGrid方法进行了对比,充分证明了本文提出方法以及文献[9]提出的方法的优越性.5.2可伸缩性及隐私保护度在可伸缩性实验中,使用出租车数据集和Oldenburg数据集评估系统平均响应时间、匿名成功率、用户协作平均通信消息量、增量近邻查询结果大小4个参数随移动用户个数从1000增加到10000的变化情况.响应时间指用户发起从发现邻居形成匿名组开始到获得所需的n个近邻查询结果所耗费的时间;匿名成功率指成功匿名的移动用户(指匿名组内用户个数大于或者等于用户的隐私需求参数k)同系统中全部移动用户个数的比率,需要注意的是匿名失败的情况下,通过发起假查询,用户仍然能获得不错的隐私保护效果;用户协作平均通信消息数量指移动用户通过发现邻居形成匿名组到获得锚点平均传输的消息数量;增量近邻查询结果大小指用户向位置服务提供商发起增量查询到获得精确所需的n个近邻总共传输的近邻个数.如图4所示,从两类数据的结果来看,随着系统中移动用户数量的增加,用户查询的平均响应时间变短,并趋于平稳,匿名成功率增加,逼近100%,用户协作通信消息量和近邻查询平均结果大小都减小并趋于平稳.这是因为在区域大小未发生改变的情况下,随着移动用户数量增加,移动用户密度变大,CoPrivacy方法形成匿名组并找到锚点的速度和成功率都升高了.此外,密集的用户使得生成匿名组的Page8MBR面积变小,生成的锚点位置更为接近用户的真实位置,使得增量近邻查询需要的查询结果减少.当用户数大于4000后,曲线趋于平稳,这是因为用户数量大于4000后,移动用户已经足够密集,增加用户对用户形成匿名组获取锚点的过程没有太大影响,进而对用户增量近邻查询的过程也没有太大影响.由上述实验结果和分析可以得出,CoPrivacy具有良好的可伸缩性.图4也表明,CoPrivacy方法在北京市出租车的真实数据的整体运行效果会比在Oldenburg数据集上运行效果稍差,这是因为北京市的路网类似棋盘状的布局,出租车分布比较均匀,没有特别的密集区域,CoPrivacy方法形成匿名组的时候需要更多的多跳通信,用户所在匿名组的MBR面积更大,导致了更高的通信代价和查询结果数量;而Olden-burg路网布局比较凌乱,会形成特定的密集和稀疏区域,更利于用户之间协作形成匿名组.5.3与传统匿名方法的对比文献[8]中提出的PrivacyGrid方法是一种比较典型的采用中心服务器结构的位置隐私保护方法,因此,我们采用PrivacyGrid与本文提出的CoPrivacy方法在匿名成功率、匿名处理时间以及查询结果大小上进行对比.本文将PrivacyGrid方法中用户的各项隐私需求参数同本方法设置一致,匿名参数k的取值从5变动到25,其它参数为表1中的默认值.使用Oldenburg数据集评估两种方法.如图5所示,随着用户隐私需求参数k的增加,CoPrivacy方法的匿名成功率有轻微的下降,匿名处理时间和查询结果大小都有比较明显的上升.这是因为增加k意味着CoPrivacy方法需要发现更多的用户,而系统中移动用户数量没有增加,所以用户需要更长的时间来发现邻居,形成更大的匿名组,进而导致锚点与用户真实位置距离变大,增量查询结果大小变大.图5同时也表明,与PrivacyGrid方法相比,CoPrivacy方法可以达到几乎等同的成功率.当k值增加的时候,CoPrivacy方法需要更长的匿名处理时间,这主要是因为CoPrivacy方法使用P2P多跳通信来发现邻居用户,网络通信代价较大,而PrivacyGrid匿名处理在服务器端,没有网络延迟,然而PrivacyGrid通常无法获得精确的查询结果,而在本文提出的方法中,虽然查询时间有所增加,但用户得到的是精确的结果.此外,在同样的k值下,CoPrivacy方法查询结果大小比PrivacyGrid方法的查询结果小,当k值增加时差距更为明显,充分说明了CoPrivacy方法的优越性.5.4对比用户协作匿名方法实验也将CoPrivacy与无中心服务器的方法进行了对比.采用文献[9]提出的P2P空间匿名方法.P2P空间匿名方法是一种在无中心服务器架构下的典型隐私保护方法[9].实验在Oldenburg数据集上进行,P2P空间匿名方法中用户的各项隐私需求参数同CoPrivacy设置一致,匿名参数k从5变动到25,其它参数为表1中的默认值.分别从平均响应时间、用户协作平均通信消息量和增量近邻查询结果大小三个方面对两种方法进行评估.如图6所示,随着用户隐私需求参数k的增加,图6CoPrivacy与P2P空间匿名方法的对比Page9两种方法在平均响应时间、用户协作平均通信消息量和增量近邻查询结果三方面都有所上升.相比于P2P空间匿名方法,CoPrivacy方法在用户协作平均通信消息量和增量近邻查询结果方面有明显的优势,但在平均响应时间方面稍逊一筹.因为P2P空间匿名使用主动模式发现邻居用户,在形成匿名组后,不断发送消息维持匿名组信息,因此能更快地形成匿名区域,从而减小响应时间.但维持匿名组需要更多的用户协作通信,同时P2P空间匿名使用基于匿名区域的查询方法,导致更多的查询结果传输.6结论和展望传统的位置隐私保护方法大多采用基于可信第三方的结构,在匿名服务器端使用满足k匿名的匿名区域代替用户真实位置进行查询处理,这往往需要服务器端和用户进行大量的计算,同时可信第三方容易成为系统的性能瓶颈和集中攻击目标.本文提出了一种用户协作的无匿名区域的隐私保护方法,该方法通过用户之间协作形成匿名组,匿名组内的用户用组的密度中心代替真实位置发出查询,并增量地从服务器获得近邻查询结果.组内成员通过近邻查询结果与自身位置之间的距离计算得出精确的查询结果.该方法在不使用匿名区域的情况下达到了k匿名的效果,不牺牲用户的服务质量,并且提高了匿名系统的整体性能,简化了服务提供商的查询处理过程.本文在真实出租车数据和模拟数据集上进行了充分的实验,证明了该方法的优越性.由于CoPrivacy方法中假定了参与协作的移动用户都是可信的,未来研究工作可以在系统中存在半可信或不可信的用户上展开.
