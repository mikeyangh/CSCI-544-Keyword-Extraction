Page1基因组一般移位排序问题的多项式时间算法尹晓朱大铭(山东大学计算机科学与技术学院济南250101)摘要基因组移位排序在基因组重组排序计算研究中占有重要位置.交互型移位和非交互型移位均为移位的特殊形式.目前见到的多种移位排序算法均是针对交互型移位而得到的,未见基因组一般移位排序计算的研究结果.文中讨论包括交互型移位和非交互型移位的一般移位排序问题的求解方法,给出该问题的一个多项式时间算法.算法的关键在于将一般移位排序问题在线性时间内归约为交互型移位排序问题,利用交互型移位排序的算法来求解一般移位排序.作者的算法证实了Ozery-Flato等关于一般移位排序问题可以多项式时间解决的猜测.关键词算法;基因组重组;移位;移位距离;计算生物学1引言过程.基因组重组的生化过程非常复杂,但可将其归为3种基本操作,即反转(reversal)、移位(transloca-tion)和转位(transposition).基因组重组排序要求基因组重组是基因组改变基因排列顺序的生化计算将一个基因组转化为另一个基因组的最短重组Page2操作序列,从而推断生命的演化过程.基因组重组排序多年来一直是计算生物学的热点问题.有向基因组反转和移位排序多项式算法的设计成功,应是20世纪90年代人们用“计算”解决分子生物学问题的典型贡献[1-2],有关反转和转位排序问题的算法与复杂性主要研究结果见文献[3-7].本文讨论基因组的移位排序算法.移位交换基因组中两条染色体的前缀或后缀.若交换的两部分都不为空,则为交互型移位,否则为非交互型移位.所谓交互型移位排序,即只通过交互型移位对基因组进行排序.Hannenhalli最先给出了交互型移位排序问题的多项式时间算法,时间复杂性为O(n3)[2],其中n为基因组中基因的个数.之后,朱等将文献[2]算法的时间复杂度改进为O(n2logn)[8].刘等进一步将算法的时间复杂度改进为O(n2)[9].最近Ozery-Flato等将交互型移位排序算法的时间复杂度改进为O(nnlog槡n)[10],这是目前最好的交互型移位排序算法.交互型移位排序要求源基因组和目标基因组必须具有相同的尾基因集合.然而,在实际的基因组重组排序实例中,源基因组和目标基因组未必具有相同的尾基因集合.可以认为,两个基因组具有不同尾基因集合,是因非交互型移位形成的.非交互型移位有3种形式:合并(fussion)、分裂(fission)与分裂-合并(fission-fussion).合并将两条染色体连接为一条,因而消除两个尾基因;分裂将一条染色体断为两条染色体,从而产生两个新的尾基因;分裂-合并先将一条染色体分裂为两段,再将其中一段与另一条染色体合并.Hannenhalli设计了考虑反转、交互型移位和非交互型移位的多项式算法[11].Tesler将Hannen-halli的算法实现为基因组排序软件[12],供同行测试和使用.但在实际基因组比较中,人们还需经常考虑只包括交互型移位和非交互型移位的基因组重组排序结果.Ozery-Flato曾在文献[13]中猜测,包括交互型移位和非交互型移位的移位排序问题可以多项式时间解决,但至今未见有人给出该问题的算法与复杂性研究结果.我们将包括交互型移位和非交互型移位的移位排序问题称作一般的移位排序问题.本文讨论一般移位排序问题的求解方法,给出该问题的一个多项式时间算法.本文算法证实了Ozery-Flato的猜测.下面将交互型移位排序问题简称为SRT(SortingbyReciprocalTranslocations),将一般移位排序问题简称为SGT(SortingbyGeneralizedTranslocations).2预备知识基因组是染色体的集合,每条染色体表示为一个整数序列,其中的整数表示基因.在整数前增加一个符号±,表示基因在染色体中的相对方向.例如,{(3,-5),(2,4,-6),(-1,7)}表示一个包含7个基因3条染色体的基因组.一个基因在同一个基因组中只出现一次,因此若基因组A含有n个基因,则采用整数集{1,2,…,n}表示A中的所有基因.设S=(x1,x2,…,xl)为染色体中的一段基因序列,-S=(-xl,-xl-1,…,-x1)表示S的逆序.给定两条染色体X和Y,若X=Y或X=-Y,则X与Y实际表示同一条染色体,称X与Y等价.若基因组A中的每条染色体X,在基因组B中都存在一条染色体Y与X等价,则称A与B等价,记作A=B.给定两条染色体X=(X1,X2),Y=(Y1,Y2),其中X1,X2,Y1,Y2表示基因序列.移位将X中的基因序列X1或X2,与Y中的基因序列Y1或Y2交换.移位有两种类型:P-P移位和P-S移位.P-P移位将(X1,X2),(Y1,Y2)变为(Y1,X2),(X1,Y2);P-S移位将(X1,X2),(Y1,Y2)变为(-Y2,X2),(Y1,-X1).若X1,X2,Y1,Y2都不为空,则该移位为交互型移位.除了交互型移位外,还有3种非交互型移位:分裂、合并、分裂-合并.分裂将一条染色体断开,形成两条染色体.X的分裂将X=(X1,X2)变为(X1)和(X2).合并将两条染色体首尾连接,形成一条染色体.染色体X,Y合并后可得到(X,Y),(-X,Y),(X,-Y)或(-X,-Y).分裂-合并先将一条染色体分裂为两段,再将其中一段连接到另一条染色体上.X=(X1,X2)与Y的分裂-合并有4种可能的结果:(X1),(Y,X2);(X1),(-X2,Y);(X1,Y),(X2)或(Y,-X1),(X2).3种非交互型移位都可看作是移位时交换的某段基因序列为空的特殊情况.例如,X分裂为(X1)和(X2)可看作是(X1,X2)与“空染色体”(,)移位得到(X1,)和(,X2).X,Y合并为(X,Y)可看作是(X,)与(,Y)移位得到(X,Y)和(,);X=(X1,X2)与Y分裂-合并得到(X1),(Y,X2),可看作是(X1,X2)与(Y,)移位Page3得到(X1,),(Y,X2).设有一条染色体X=(x1,x2,…,xm),将x1和-xm称作X的尾基因.X的尾基因集合记为Tails(X)={x1,-xm}.基因组A的尾基因集合记为Tails(A)=∪X∈ATails(X).例如,Tails({(1,-3,-4),(-5,-2,6)})={1,4,-5,-6}.若基因组A、B满足Tails(A)=Tails(B),则称A与B是同尾基因组.交互型移位排序问题要求源基因组和目标基因组必须是同尾基因组.2.1同尾基因组的断点图给定一条染色体X=(x1,x2,…,xm),将X的每个基因xi都用一个有序的点对(l(xi),r(xi))代替:若xi的符号为+,则l(xi)=xti,r(xi)=xhi;若xi的符号为-,则l(xi)=xhi,r(xi)=xti.由X可得到一个点序列l(x1)r(x1)l(x2)r(x2)…l(xm)r(xm).下面我们也将染色体X的点序列直接称作染色体X.对于1im-1,称r(xi)与l(xi+1)在X中相邻.若X是基因组A的染色体且点u,v在X中相邻,则称u,v在A中相邻.给定同尾基因组A、B,用以下方法构造断点图G(A,B):点集为V={u:u=xt或xh,其中x为A中的基因}.设u,v∈V,若u,v在A中相邻,则在u,v之间连黑边;若u,v在B中相邻,则连灰边.设A(或B)的基因数为n,染色体数为N,则G(A,B)的黑边和灰边数目都为n-N.设g=(u,v)为G(A,B)中的一条灰边,若u,v在A中位于同一条染色体,则称g为体内灰边;否则,称g为体间灰边.G(A,B)中点的度都为0或2,因而G(A,B)可唯一地分解为黑边和灰边交替且顶点互不重叠的圈.只有一条黑边的圈称作短圈,否则称作长圈.当A=B时,G(A,B)由n-N个短圈构成.2.2最小子排列和偶隔离带给定基因组A的染色体X上的一段基因序列I=xi,xi+1,…,xj,则I在G(A,B)中对应点序列l(xi)r(xi)l(xi+1)r(xi+1)…l(xj)r(xj).定义V(I)=∪ikj设I=xi,xi+1,…,xj为A的染色体X的一段基因序列,I=xi,permutation(xi+1,…,xj-1),xj为B的染色体Y的一段基因序列,其中permutation(xi+1,…,xj-1)表示xi+1,…,xj-1的一个重排列.若permutation(xi+1,…,xj-1)≠xi+1,…,xj-1,则称I为基因组A的一个子排列.将不包含任意其它更小子排列的子排列称为一个最小子排列,简记为MSP(MinimumSubPermutation).子排列I在G(A,B)中表现为由点集IN(I)支撑的一个子图,满足:(1)该子图中不存在边(u,v)使u∈IN(I)而vIN(I);(2)该子图至少包含一个长圈.下面也直接将(最小)子排列I在G(A,B)中对应的子图称为(最小)子排列.若G(A,B)满足:(1)MSP数为偶数;(2)所有的MSP均被同一个子排列所包含,则称G(A,B)包含一个偶隔离带.2.3交互型移位距离同尾基因组A和B的交互型移位距离即从A转化为B的最少交互型移位次数,记作dr(A,B).令c(A,B)和s(A,B)分别表示G(A,B)中的圈数和MSP数.定义参数f(A,B),f(A,B)=定理1(Hannenhalli)[2].同尾基因组A、B的交互型移位距离dr(A,B)=n-N-c(A,B)+s(A,B)+f(A,B).3一般移位排序下面我们讨论A、B不一定是同尾基因组的一般情况.将交互型移位和非交互型移位统称为移位.基因组移位排序问题描述如下:实例———基因组A、B,A和B具有相同的基因将A转化为B的最少移位次数称为A与B的移位距离,记为d(A,B).3.1加帽基因组给定两个基因组A={X1,X2,…,XM},B={Y1,Y2,…,YN},其中Xi(1iM)和Yj(1jN)分别为A和B的染色体.首先给A、B添加基因,构造同尾基因组^A、^B.所添加的基因集合为Caps={C1,C2,…,C2n},其中对于1k2n,Ck={n+k}.将Caps中的元素均称作帽子.^A、^B的构造方法如下:给A的每条染色体Xi的左右两端分别添加帽子C2i-1和C2i,并添加n-M条由两个帽子构成的“空染色体”,得到基因组^A={^X1,^X2,…,^Xn},其集合{1,2,…,n}.和最短移位序列.目标———计算将A转化为B的最少移位次数Page4in时,^Xi=(C2i-1,C2i).给B的每条染色体Yi的左右两端分别添加(-1)j+1Cj和(-1)kCk,并添加n-N条“空染色体”,得到基因组^B={^Y1,^Y2,…,^Yn},其中,当1iN时,^Yi=((-1)j+1Cj,Yi,(-1)kCk);当N<in时,^Yi=((-1)j+1Cj,(-1)kCk),1j,k2n且每个帽子在^B中只出现一次.我们将^A、^B分别称为A、B的加帽基因组.B共有(2n)!/2n-N(n-N)!个加帽基因组.将B的加帽基因组的集合记作Γ.例如:A={(3,4),(2,1)},B={(1),(2),(3,4)},A的加帽基因组^A={(5,3,4,6),(7,2,1,8),(9,10),(11,12)},B的其中一个加帽基因组为^B={(5,1,6),(7,2,8),(9,3,4,10),(11,12)}.3.2用交互型移位模拟一般移位设X=(X1,X2),Y=(Y1,Y2)为A中的两条染色体.其中,X1,X2,Y1,Y2表示基因序列,并且可以为空.相应地,^A中一定存在两条X,Y添加帽子后的染色体^X=(^X1,^X2)=(Ck,X1,X2,Ck+1),^Y=(^Y1,^Y2)=(Cl,Y1,Y2,Cl+1).其中,^X1=(Ck,X1),^X2=(X2,Ck+1),^Y1=(Cl,Y1),^Y2=(Y2,Cl+1).显然,^X1,^X2,^Y1,^Y2都不为空,因而对X,Y做一次交互型移位、合并、分裂或分裂-合并一定等价于对^X,^Y做一次交互型移位.反之,设ρ为作用于^A的染色体^X,^Y的一个交互型移位.用ρpp(^X,^Y,X1X2,Y1Y2)表示在^X的X1,X2和^Y的Y1,Y2之间断开做P-P移位,用ρps(^X,^Y,X1X2,Y1Y2)表示在^X的X1,X2和^Y的Y1,Y2之间断开做P-S移位.有如下情况:(1)^X,^Y都不是空染色体.设^X=(Ck,X1,X2,Ck+1),^Y=(Cl,Y1,Y2,Cl+1),其中X1,X2,Y1,Y2为非空的基因序列.相应地,A中一定存在两条染色体X=(X1,X2),Y=(Y1,Y2).若ρ=ρpp(^X,^Y,X1X2,Y1Y2),则得到的新染色体为(Ck,X1,Y2,Cl+1)和(Cl,Y1,X2,Ck+1).显然,去掉帽子后,ρ等价于X,Y的交互型移位ρpp(X,Y,X1X2,Y1Y2).同样,ρps(^X,^Y,X1X2,Y1Y2)等价于ρps(X,Y,X1X2,Y1Y2).若ρ=ρpp(^X,^Y,CkX1,ClY1),则得到新染色体(Cl,X1,X2,Ck+1)和(Ck,Y1,Y2,Cl+1).这时ρ只是在^X,^Y之间交换帽子Ck,Cl,并没有改变染色体X,Y.我们将这种操作称作换帽.同样,ρpp(^X,^Y,X2Ck+1,Y2Cl+1),ρps(^X,^Y,CkX1,Y2Cl+1)和ρps(^X,若ρ=ρpp(^X,^Y,CkX1,Y2Cl+1),得到新染色体(Cl,Y1,Y2,X1,X2,Ck+1)和(Ck,Cl+1).这时ρ等价于X,Y的合并.同样,ρpp(^X,^Y,X2Ck+1,ClY1),ρps(^X,^Y,CkX1,ClY1)和ρps(^X,^Y,X2Ck+1,Y2Cl+1)都等价于X,Y的合并.若ρ=ρpp(^X,^Y,X1X2,ClY1),则得到新染色体(Ck,X1,Y1,Y2,Cl+1)和(Cl,X2,Ck+1).这时ρ等价于X,Y的分裂-合并.同样地,ρps(^X,^Y,X1X2,ClY1),ρpp(^X,^Y,X1X2,Y2Cl+1),ρps(^X,^Y,X1X2,Y2Cl+1),ρpp(^X,^Y,CkX1,Y1Y2),ρps(^X,^Y,CkX1,Y1Y2),ρpp(^X,^Y,X2Ck+1,Y1Y2)和ρps(^X,^Y,X2Ck+1,Y1Y2)都等价于X,Y的分裂-合并.(2)^X不是空染色体,^Y是空染色体.设^X=(Ck,X1,X2,Ck+1),^Y=(Cl,Cl+1),其中X1,X2不为空.相应地,A中一定存在一条染色体X=(X1,X2).若ρ=ρpp(^X,^Y,X1X2,ClCl+1),则得到新染色体(Ck,X1,Cl+1),和(Cl,X2,Ck+1).去掉帽子后,ρ等价于X的分裂.同样地,ρps(^X,^Y,X1X2,ClCl+1)也等价于X的分裂.ρpp(^X,^Y,CkX1,ClCl+1),ρpp(^X,^Y,X2Ck+1,ClCl+1),ρps(^X,^Y,CkX1,ClCl+1),ρps(^X,^Y,X2Ck+1,ClCl+1)都是换帽操作.(3)^X,^Y都是空染色体.设^X=(Ck,Ck+1),^Y=ρpp(^X,^Y,CkCk+1,ClCl+1)和ρps(^X,^Y,CkCk+1,ClCl+1)都是换帽操作.根据以上讨论可知,A的交互型移位、分裂、合并、分裂-合并都对应于^A的一个交互型移位,^A的交互型移位则对应一个换帽操作或者A的一个交互型移位、分裂、合并或分裂-合并.下面我们证明A和B的移位距离d(A,B)恰好等于^A与B的所有加帽基因组的交互型移位距离的最小值.定理2.d(A,B)=minB^∈Γdr(^A,^B).证明.对A做移位ρ后得到的新基因组记为A·ρ.假设A转化为B的最短移位序列为ρ1,ρ2,…,ρk,即A·ρ1·ρ2·…·ρk=B.对于1ik,ρi都对应基因组^A的一个交互型移位ρ^i,即^A·ρ^1·ρ^2·…·ρ^k=^B,^B∈Γ.因而d(A,B)=kdr(^A,^B)minB^∈Γdr(^A,^B).设dr(^A,^BOPT)=minB^∈Γdr(^A,^B),假设^A转化为^BOPT的最短交互型移位序列为ρ^1,ρ^2,…,ρ^t,即^A·(Cl,Cl+1).Page5作,则对应A的一个移位.设ρ^1,ρ^2,…,ρ^t中的非换帽操作数为s,将这s个操作重新编号为ρ^1,ρ^2,…,ρ^s,st.对于1is,ρ^i对应A的一个移位ρi,即A·ρ1·ρ2·…·ρs=B.因而d(A,B)st=minB^∈Γdr(^A,^B).根据定理1和定理2,可用如下方法计算A和B的移位距离与最短移位序列:针对B的加帽基因组集合Γ中的每个基因组^B,使用解答SRT问题的算法计算dr(^A,^B),选择使dr(^A,^B)达到最小的加帽基因组^BOPT,则可由^A转化为^BOPT的交互型移位距离与最短交互型移位序列,得到由A转化为B的移位距离与最短移位序列.这种计算方法关于n是指数时间的.下面我们将与^A的交互型移位距离最小的B的加帽基因组总记作^BOPT.我们将在断点图的基础上构造部分图,利用部分图的性质和定理1的交互型移位距离公式,设计一个在n的多项式时间内计算^BOPT的算法,从而给出一般移位排序的图1部分图GP(A,B)与构造断点图时选择哪个B的加帽基因组无关.GP(A,B)由黑边和灰边交错的圈和路径构成.若一条路径只有一条黑边,则称之为短路径,否则称作长路径.给GP(A,B)添加n+N条灰边可将其变为完整的断点图,其中n-N条灰边连接两个A-cap,2N条灰边连接一个A-cap和一个B-tail.每种添加灰边的方式都确定了一个B的加帽基因组.根据定理2,要计算^BOPT,只需找一种添加灰边的方法,使得GP(A,B)添加灰边后得到的断点图的交互型移位距离最小.将GP(A,B)中的路径分类:两端都为A-cap的路径为AA路径;一端为A-cap一端为B-tail的路径为AB路径;两端都为B-tail的路径为BB路径.GP(A,B)中的AA路径数与BB路径数之差为n-N.GP(A,B)中圈和路径的总数记作l(A,B),多项式算法.4基因组移位排序算法4.1部分图在Γ中任选一个B的加帽基因组^B,构造断点图G(^A,^B).在G(^A,^B)中,每个帽子都对应一个度为0的点和一个度为2的点.将对应于帽子的度为2的点称作A-cap.每个A-cap都通过灰边与另一个A-cap或B的尾基因的点邻接.若A-cap通过灰边与A-cap邻接,则表示^B中的一条空染色体.将与A-cap邻接的B的尾基因的点称作B-tail.在G(^A,^B)中去掉以A-cap为端点的灰边,得到的图称作G(^A,^B)的部分图.将这个部分图记作GP(A,B).例如,给定基因组A={(2,1,3,5),(6,8,-7,4,10,-9)},B={(1,2,3,4),(5,6,7),(8,9,10)},断点图G(^A,^B)如图1(a)所示,部分图GP(A,B)如图1(b)所示.BB路径数记作p(A,B).4.2半最小子排列设I为^A中的一段基因序列,若点集IN(I)支撑的GP(A,B)的子图满足以下条件,则称该子图为一个真子排列:(1)不存在边(u,v)使u∈IN(I),vIN(I);(2)至少包含一个长圈;(3)不包含路径.若一个真子排列不包含其它真子排列,则称之为真最小子排列,简记为RMSP(RealMinimumSubPermutation).若IN(I)支撑的GP(A,B)的子图满足以下条件,则称该子图为一个半子排列:(1)不存在边(u,v)使u∈IN(I),vIN(I);(2)至少包含一个长圈或长路径;(3)不包含AA路径和BB路径.若一个半子排列不包含其它半子排列和真子排列,则称之为半最小子排列,简记为SMSP(SemiMinimumSubPermuation).Page6例如,图1(b)所示部分图中由点集{11h,2t,2h,1t,1h,3t}支撑的子图是一个SMSP.SMSP和RMSP的区别在于:SMSP一定包含AB路径,而RMSP不包含任何路径.若将一个SMSP中的AB路径都用灰边闭合,则该SMSP变为RMSP.将GP(A,B)中的SMSP数记作sm(A,B),RMSP数记作r(A,B).设S1,S2是GP(A,B)中的两个SMSP,若图2相互依赖的SMSP和路径性质1.设S1和S2为两个相互依赖的SMSP,添加一条灰边连接S1中AB路径的A-cap和S2中AB路径的B-tail,则S1和S2合并为一个新的SMSP.性质2.设P1为一条AA路径,P2为一条BB路径,P1和P2相互依赖.若添加一条灰边连接P1和P2,则会产生一个新的SMSP.引入参数ds(A,B).若GP(A,B)满足:sm(A,B)=2且这两个SMSP相互依赖,则定义ds(A,B)=1;否则定义ds(A,B)=0.引理1.若GP(A,B)满足ds(A,B)=0,则总能添加sm(A,B)/2条灰边,使GP(A,B)中减少2×sm(A,B)/2个SMSP.证明.在GP(A,B)中添加sm(A,B)/2条灰边减少2×sm(A,B)/2个SMSP的方法如下:将GP(A,B)中相互依赖的SMSP对的数目记作v.若v=1,可知除了相互依赖的一对SMSP外,GP(A,B)中还存在其它SMSP(否则ds(A,B)=1).在相互依赖的一对SMSP中取一个SMSP,记作S1.另取一个SMSP,记作S2.添加一条灰边将S1中的AB路径的A-cap与S2中AB路径的B-tail连接.若v>1,将相互依赖的SMSP对记为PS1,PS2,…,PSv.对于1iv-1,添加一条灰边连接PSi中一个SMSP的AB路径的A-cap与PSi+1中一个SMSP的AB路径的B-tail.这时图中任意两个SMSP都不相互依赖.任取两个SMSP,添加灰边连接一个SMSP的AB路径的A-cap与另一个SMSP的AB路径的B-tail,直到图中的SMSP数小于2为止.上述过程中每次添加灰边所连接的两个SMSP都不相互依赖,因而每次都会减少2个SMSP,因此总共减少了2×sm(A,B)/2个SMSP.证毕.(1)S1和S2位于同一半子排列中;(2)S1和S2所在的染色体上没有RMSP,则称S1,S2相互依赖.例如,图2(a)中S1,S2相互依赖.设P1,P2分别是GP(A,B)中的AA路径和BB路径,若(1)P1和P2的所有顶点均位于同一染色体X;(2)除P1和P2外,X上没有其它路径;(3)X上没有RMSP或体间灰边的端点,则称P1,P2相互依赖.例如,图2(b)中P1和P2相互依赖.引理2.总能添加p(A,B)条灰边将GP(A,B)中的每一条BB路径都与一条AA路径连接,且添加灰边后不产生新的SMSP.证明.在GP(A,B)中添加p(A,B)条灰边的方法如下:将GP(A,B)中相互依赖的路径对的数目记作w.若w=1,可知除了相互依赖的路径对中的AA路径外,GP(A,B)中一定还存在其它AA路径.添加一条灰边将相互依赖的路径对中的BB路径与路径对外的一条AA路径连接.若w>1,将GP(A,B)中相互依赖的路径对记为PP1,PP2,…,PPw.对于1iw-1,添加一条灰边连接PPi中的BB路径与PPi+1中的AA路径.这时图中任意一对AA路径和BB路径都不相互依赖.继续添加灰边将其余的BB路径与任意AA路径连接,直到图中不存在BB路径为止.上述过程共添加了p(A,B)条灰边,且每条灰边连接的BB路径与AA路径都不相互依赖,因而不会产生新的SMSP.4.3计算移位距离在GP(A,B)中添加灰边后形成的断点图可能包含偶隔离带,下面考察可能导致偶隔离带形成的部分图结构.(1)若GP(A,B)中有偶数个RMSP,且所有的RMSP都被同一真子排列包含,则称GP(A,B)包含一个真偶隔离带.图3(a)所示结构就是一个真偶隔离带.(2)若GP(A,B)中有偶数个RMSP,所有的RMSP不能被同一真子排列包含,但都被同一个半子排列包含,则称GP(A,B)包含一个半偶隔离带.图3(b)所示结构为一个半偶隔离带.半偶隔离带一定包含一条长的AB路径,而真Page7偶隔离带不包含任何路径.若半偶隔离带中的AB路径都闭合,则变为真偶隔离带.(3)若GP(A,B)包含真偶隔离带,sm(A,B)2,并且有两个SMSP与所有的RMSP都被同一个半子排列所包含,则称GP(A,B)包含强偶隔离带.图3(c)所示结构为一个强偶隔离带.(4)若GP(A,B)有奇数个RMSP,所有的RMSP都位于同一条染色体X,并被同一个真子排列或半图3可能导致偶隔离带形成的部分图结构注意,GP(A,B)最多只能包含一个真偶隔离带、半偶隔离带、强偶隔离带或弱偶隔离带.引入参数o(A,B)和δ(A,B).o(A,B)的取值方法定义为:如果r(A,B)为奇数,则o(A,B)=1;否则o(A,B)=0.δ(A,B)∈{0,1,2},δ(A,B)的取值方法较复杂,我们逐条给出如下:若GP(A,B)满足下列条件之一,则δ(A,B)=2.(α1)包含真偶隔离带,且sm(A,B)=0;(α2)包含强偶隔离带,且sm(A,B)=2.若GP(A,B)满足下列条件之一,则δ(A,B)=1.(β1)包含强偶隔离带,sm(A,B)>2;(β2)包含真偶隔离带,不包含强偶隔离带,(β3)包含弱偶隔离带,且sm(A,B)=1;(β4)包含半偶隔离带,且sm(A,B)为偶数;(β5)包含半偶隔离带,sm(A,B)=1,且唯一的(β6)ds(A,B)=1且o(A,B)=0.其它情况下,δ(A,B)=0.下面在表示部分图GP(A,B)满足δ(A,B)取值条件时,直接使用前面给出的条件编号.我们将给出移位距离的精确下界,并证明移位距离可以达到这个下界,从而给出基因组一般移位排序算法.SMSP与半偶隔离带被同一半子排列包含;sm(A,B)>0;假设在GP(A,B)中添加n+N条灰边g1,g2,…,gn+N得到G(^A,^B),即GP(A,B)=G0G1g→2…gn+→NGn+N=G(^A,^B).Gi的各项参数li、子排列包含.若X上存在一个SMSP,该SMSP与所有的RMSP都被同一个半子排列所包含,则称GP(A,B)包含弱偶隔离带.若将弱偶隔离带中的SMSP闭合为RMSP,则它会变为真偶隔离带或半偶隔离带.例如,图3(d)和(e)所示的两种结构都是弱偶隔离带,(d)中的SMSP闭合后变为真偶隔离带,(e)中的SMSP闭合后变为半偶隔离带.pi、ri、smi、dsi、oi、δi与在GP(A,B)中的定义相同.对于参数,令Δi=i-i-1,设Δi=(li-pi-ri-(smi+oi)/2-δi)-(li-1-pi-1-ri-1-(smi-1+oi-1)/2-δi-1).引理3.对于i,1in+N,任何情况下添加灰边gi都满足Δδi-1.证明.因为δ∈{0,1,2},若δi-1∈{0,1},显然有Δδi-1,因而只需证明当δi-1=2时δi>0即可.当δi-1=2时,有以下两种情况:(1)Gi-1满足条件(α1).若gi连接一对相互依赖的AA路径和BB路径,则会产生一个SMSP,这时Gi满足条件(β2),δi=1.其它情况下gi都不会增加SMSP,Gi仍满足条件(α1),δi=2.(2)Gi-1满足条件(α2).若gi将一个SMSP变为RMSP,则Gi满足条件(β3),δi=1;若gi将两个SMSP中的AB路径连接,则这两个SMSP都被破坏,smi=0,因而Gi满足条件(α1),δi=2;若gi将一个SMSP中的AB路径与其它路径连接,则会减少一个SMSP.这时Gi满足条件(β2),δi=1;若gi连接一对相互依赖的AA路径和BB路径,则会产生一个新的SMSP.这时Gi满足条件(β1),δi=1.其它情况下gi都不会增加或减少SMSP,Gi仍满足(α2),δi=2.上述情况都有δi>0,因而结论得证.证毕.引理4.c(^A,^B)-s(^A,^B)-f(^A,^B)l(A,B)-p(A,B)-r(A,B)-(sm(A,B)+o(A,B))/2-δ(A,B).Page8证明.只需证明对于i,1in+N,都有Δi0,则结论得证.这是因为c(^A,^B)=ln+N,s(^A,^B)=rn+N,pn+N=smn+N=0,f(^A,^B)=on+N+δn+N=(smn+N+on+N)/2+δn+N,因而c(^A,^B)-s(^A,^B)-f(^A,^B)=ln+N-pn+N-rn+N-(smn+N+on+N)/2-δn+Nl0-p0-r0-(sm0+o0)/2-δ0=l(A,B)-p(A,B)-r(A,B)-(sm(A,B)+o(A,B))/2-δ(A,B).在下面的证明中,对于固定的i,略去参数下标“i”.根据gi分为下述多种情况讨论.情况1.gi闭合一条AB路径.若gi不改变SMSP的数目,则Δl=Δp=Δr=Δo=Δsm=0.但gi有可能将半偶隔离带变为真偶隔离带,因而Δδ0,显然Δ0;若gi将一个SMSP变为RMSP,则Δl=Δp=0,Δr=1,Δsm=-1.Δo可能为1或-1,下面分别讨论:情况1.1.若Δo=1,则Δ(sm+o)/2=0,又由引理3可知Δδ-1,因而Δ0.情况1.2.若Δo=-1,则Δ(sm+o)/2=-1.若要证明Δ0,只需证明Δδ0即可.若δi-1=0,显然Δδ0.由Δr=1和Δo=-1可知ri-1为奇数,因而δi-1≠2.若δi-1=1,由ri-1为奇数可知Gi-1只能满足条件(β3).添加gi后,唯一的SMSP变为RMSP,Gi包含真偶隔离带或半偶隔离带且smi=0,因而满足条件(α1)或(β4),显然Δδ0.上述情况都满足Δδ0,因而Δ0.情况2.gi连接一条AB路径的A-cap和另一条AB路径的B-tail,Δl=-1,Δp=Δr=Δo=0.gi最多可减少两个SMSP,因而Δsm可能为0、-1或-2,下面分别讨论:情况2.1.若Δsm=0,则Δ(sm+o)/2=0.又由引理3可知Δδ-1,因而Δ0.情况2.2.若Δsm=-1,则Δ(sm+o)/2=0或-1.若Δ(sm+o)/2=0,显然Δ0.若Δ(sm+o)/2=-1,要证明Δ0,只需证明Δδ0即可.若δi-1=0,显然Δδ0.由Δ(sm+o)/2=-1和Δ(sm+o)=-1可知smi-1+oi-1为奇数,因而δi-1≠2.若δi-1=1,由smi-1+oi-1为奇数可知Gi-1只能满足条件(β1)、(β2)或(β5).若Gi-1满足条件(β1)或(β2),减少一个SMSP后,Gi可能满足条件(β1)、(β2)、(α1)或(α2),显然Δδ0;若Gi-1满足条件(β5),减少一个SMSP后,Gi满足(β4),Δδ=0.以上情况都满足Δδ0,因而Δ0.情况2.3.若Δsm=-2,则Δ(sm+o)/2=-1.若要证明Δ0,只需证明Δδ0.若δi-1=0,显然Δδ0.若δi-1=1,又由Δsm=-2可知smi-12,因而Gi-1可能满足条件(β1)、(β2)或(β4).若Gi-1满足条件(β1)或(β2),减少两个SMSP后,Gi可能满足条件(β1)、(β2)、(α1)或(α2),显然Δδ0;若Gi-1满足(β4),减少两个SMSP后,Gi仍然满足(β4),Δδ=0.若δi-1=2,由smi-12可知Gi满足条件(α2),减少两个SMSP后Gi满足条件(α1),Δδ=0.以上情况都有Δδ0,因而Δ0.情况3.gi连接一条AA路径和一条BB路径.若这两条路径不相互依赖,则SMSP的数目不变,Δl=Δp=-1,Δr=Δo=Δsm=0.但gi有可能产生半偶隔离带,因而Δδ0,可得Δ0.若这两条路径相互依赖,则会产生一个新的SMSP,Δl=Δp=-1,Δr=Δo=0,Δsm=1.Δ(sm+o)/2可能为0或1,下面分别讨论:情况3.1.若Δ(sm+o)/2=1,又由引理3可知Δδ-1,因而Δ0.情况3.2.若Δ(sm+o)/2=0.要证明Δ0,只需证明Δδ0.若δi-1=0,显然Δδ0.由Δ(sm+o)/2=0和Δ(sm+o)=1可知smi-1+oi-1为奇数,因而δi-1≠2.若δi-1=1,由smi-1+oi-1为奇数可知Gi-1可能满足条件(β1)、(β2)或(β5).若Gi满足条件(β1)或(β2),增加一个SMSP后Gi仍然满足条件(β1)或(β2),Δδ=0;若Gi满足条件(β5),增加一个SMSP后,Gi满足条件(β4),Δδ=0.上述情况都有Δδ0,因而Δ0.情况4.gi连接一条AB路径的B-tail和一条AA路径(或gi连接一条AB路径的A-cap和一条BB路径,或gi连接一条AB路径的A-cap和一条AA路径).gi最多减少一个SMSP,Δl=-1,Δp=Δr=Δo=0,Δsm可能为0或-1,根据情况2.1和情况2.2可知Δ0.情况5.gi闭合一条AA路径.所有参数保持不变,Δ=0.情况6.gi连接两条AB路径的A-cap.gi最多减少两个SMSP,Δl=-1,Δp=1,Δr=0,Δsm-2,Δo=0,又由引理3可知Δδ-1,因而Δ0.情况7.gi连接两条AA路径.Δl=-1,Δp=Δr=Δsm=Δo=Δδ=0,Δ=-1.若添加到Gi-1中的一条灰边gi满足Δi=0,则将gi称作有效灰边.下面我们证明总能找到n+NPage9条有效灰边依次添加到GP(A,B)中,将其变为断点图G(^A,^BOPT).在下面引理和定理的证明中,对于固定的“i”,略去参数下标.引理5.设S为Gi-1中的一个SMSP且S包含2条AB路径.若gi为闭合S中一条AB路径的灰边,那么gi一定是有效灰边.证明.因为S中包含两条AB路径,闭合其中一条AB路径后,S在Gi中仍然是SMSP,即Gi中SMSP的数目不变,其它参数也不变,因而Δ=0.根据引理5,下面可假设Gi-1中的SMSP都只包含一条AB路径.引理6.若Gi-1满足dsi-1=1,则总能找到一条有效灰边gi,使得添加gi后的图Gi满足dsi=0.证明.因为dsi-1=1,可知Gi-1中存在一对相互依赖的SMSP,记作S1,S2.下面给出找满足上述条件的有效灰边gi的方法:(1)若oi-1=1,则δi-1=0.令gi为闭合S1(或S2)中的AB路径的灰边,则S1(或S2)变为RMSP,dsi=0.因为新的RMSP与原有的RMSP位于不同的染色体,因而δi=0.gi令Δl=Δp=0,Δr=1,Δo=Δsm=-1,Δδ=0,因而Δ=0.(2)若oi-1=0,则Gi-1满足条件(β6),δi-1=1.若ri-1>0,令gi为闭合S1(或S2)的AB路径的灰边,则S1(或S2)变为RMSP且该RMSP与原有的RMSP位于不同的染色体,dsi=δi=0.Δl=Δp=0,Δr=Δo=1,Δsm=Δδ=-1,Δ=0.若ri-1=0,令gi为连接S1中的A-cap和S2中的B-tail的灰边.gi将S1,S2合并为一个SMSP,dsi=δi=0.Δl=-1,Δp=Δr=Δo=0,Δsm=Δδ=-1,Δ(sm+o)/2=0,Δ=0.引理7.若Gi-1包含真偶隔离带且smi-1>0,则总能找到一条有效灰边gi,使得添加gi后的图Gi满足:(1)dsi=0;(2)Gi不包含真偶隔离带或者Gi满足条件(α1).证明.Gi-1可能满足条件(α2)、(β1)或(β2).下面对这3种情况分别给出找满足上述条件的有效灰边gi的方法:(1)若Gi-1满足(α2),设强偶隔离带中的两个SMSP为S1,S2.令gi为连接S1的AB路径的A-cap和S2的AB路径的B-tail的灰边.添加gi后,S1,S2不再是SMSP.显然dsi=0并且Gi满足条件(α1).Δl=-1,Δp=Δr=Δo=0,Δsm=-2,Δδ=0,因而Δ=0.(2)若Gi-1满足(β1)或(β2),用以下方法选择一个SMSP,记作S:若Gi-1中存在一对相互依赖的SMSP,则令S为其中一个SMSP;否则,令S为任意一个SMSP.令gi为闭合S中AB路径的灰边,则S变为RMSP,δi=0.上述选择S的方式可以保证dsi=0.ri为奇数,显然Gi不包含真偶隔离带.Δl=Δp=0,Δr=Δo=1,Δsm=Δδ=-1,因而Δ=0.引理8.若Gi-1包含弱偶隔离带且Gi-1中至少有一条AA路径,则总能找到一条有效灰边gi,使得添加gi后的图Gi满足:(1)dsi=0;(2)Gi不包含真偶隔离带,弱偶隔离带或半偶隔离带.证明.下面分3种情况给出找满足上述条件的有效灰边gi的方法:(1)若smi-1=1,可知Gi-1满足条件(β3),δi-1=1.设S为Gi-1中唯一的SMSP.令gi为连接S的AB路径的B-tail与一条AA路径的灰边.添加gi后S不再是SMSP,显然dsi=smi=0且Gi不再包含弱偶隔离带.因ri为奇数,因而Gi也不包含真偶隔离带或半偶隔离带.Δl=-1,Δp=Δr=Δo=0,Δsm=Δδ=-1,可得Δ=0.(2)若smi-1=2,则δi-1=0.设这两个SMSP为S1,S2.令gi为连接S1的AB路径的A-cap和S2的AB路径的B-tail的灰边.添加gi后S1和S2不再是SMSP,显然dsi=smi=0且Gi不包含真偶隔离带、弱偶隔离带或半偶隔离带.Δl=-1,Δp=Δr=Δo=0,Δsm=-2,Δδ=0,Δ=0.(3)若smi-1>2,则Gi-1中至少存在一个与弱偶隔离带不同染色体的SMSP.用以下方法选择一个SMSP,记作S:若Gi-1中存在一对相互依赖的SMSP,则令S为其中一个SMSP;否则,令S为任意一个与弱偶隔离带不同染色体的SMSP.令gi为闭合S的AB路径的灰边,gi将S变为RMSP.选择S的方式可以保证dsi=0.在Gi中新的RMSP与其它RMSP不位于同一染色体,因而Gi不包含真偶隔离带、弱偶隔离带或半偶隔离带.Δl=Δp=0,Δr=1,Δo=Δsm=-1,Δδ=0,Δ=0.引理9.若Gi-1包含半偶隔离带,dsi-1=0且Gi-1中至少有一条AA路径,则总能找到一条有效灰边gi,使得添加gi后的图Gi满足:(1)dsi=0;(2)Gi中不包含真偶隔离带或半偶隔离带.证明.设P为半偶隔离带中的长AB路径.Page10SMSP.找满足上述条件有效灰边gi的方法如下:(1)若smi-1为偶数,则Gi-1满足条件(β4),δi-1=1.令gi为连接P的B-tail与一条AA路径的灰边.SMSP的数目不变,因而dsi=dsi-1=0.因为一条染色体上只有两个A-cap,因而添加gi后,所有的RMSP一定不被同一半子排列包含,即Gi不包含半偶隔离带.Δl=-1,Δp=Δr=Δo=Δsm=0,Δδ=-1,因而Δ=0.(2)若smi-1为奇数,下面分两种子情况讨论:(2.1)若smi-1=1,设S为Gi-1中唯一的若Gi-1满足条件(β5),则δi-1=1.令gi为闭合S中的AB路径的灰边.添加gi后S变为RMSP,ri为奇数且smi=0,因而dsi=0且Gi不包含半偶隔离带.gi满足Δl=Δp=0,Δr=Δo=1,Δsm=Δδ=-1,Δ=0.若Gi-1不满足条件(β5),则δi-1=0.令gi为连接S中AB路径的A-cap与P的B-tail的灰边.添加gi后smi=dsi=0.由于在Gi-1中半偶隔离带与S不被同一个半子排列包含(否则,Gi-1满足条件(β5)),因而添加gi后所有的RMSP不再被同一半子排列包含,即Gi不包含半偶隔离带.Δl=-1,Δp=Δr=Δo=0,Δsm=-1,Δδ=0,可得Δ=0.(2.2)若smi-1>1,则δi-1=0.这时Gi-1中一定存在一个与半偶隔离带不同染色体的SMSP,按以下方法选择一个SMSP,记为S:若Gi-1中有一对相互依赖的SMSP,则令S为SMSP对中的一个SMSP;否则,令S为任意一个与半偶隔离带不同染色体的SMSP.令gi为连接S中AB路径的A-cap与P的B-tail的灰边.显然gi是体间灰边,因而Gi不再包含半偶隔离带.选择S的方法可以保证dsi=0.Δl=-1,Δp=Δr=Δo=0,Δsm=-1,Δδ=0,可得Δ=0.上述情况中gi均没有闭合路径P,因而Gi也不引理10.总能找到p(A,B)条灰边将GP(A,B)中的每一条BB路径都与一条AA路径连接,添加灰边后不产生新的SMSP,也不产生半偶隔离带.证明.由引理2可知,存在p(A,B)条灰边将每一条BB路径都与一条AA路径连接,不会产生新的SMSP.下面我们修改引理2的添加灰边的方法,使之也不产生半偶隔离带.按照引理2添加灰边产生半偶隔离带只有一种情况:GP(A,B)中包含偶会包含真偶隔离带.数个RMSP,这些RMSP位于同一条染色体X;X上没有体间灰边的端点;X上有一条AA路径和一条BB路径,分别记作P1和P2.当且仅当添加灰边连接P1和P2时会产生半偶隔离带.这种情况下,因n>M,可知GP(A,B)中一定有一条位于X之外的短AA路径,记作P3.添加灰边将P2与P3连接,即可保证不会产生半偶隔离带.性质3.若Gi-1满足以下3个条件:(C1)dsi-1=0;(C2)Gi-1不包含弱偶隔离带或半偶隔离带;(C3)Gi-1不包含真偶隔离带或者Gi-1满足条件(α1),在Gi-1中添加一条灰边gi,若gi令Δds=0且gi不在Gi中产生新的SMSP和半偶隔离带,则gi一定满足Δδ=0.定理3.总能找到n+N条有效灰边添加到GP(A,B)中,使其变为断点图G(^A,^BOPT).证明.假设已经在GP(A,B)中添加了i-1(S1)若Gi-1中存在包含两条AB路径的SMSP,则添加灰边闭合其中一条AB路径.由引理5可知,添加的灰边都是有效灰边.条灰边得到Gi-1.(S2)若Gi-1满足dsi-1=1,则根据引理6,总能找到一条有效灰边gi,使得Gi满足dsi=0.(S3)若Gi-1包含真偶隔离带且smi-1>0,则根据引理7,总能找到一条有效灰边gi,使得添加gi后的图Gi满足:(1)dsi=0;(2)Gi中不包含真偶隔离带或者Gi满足条件(α1).(S4)若Gi-1包含弱偶隔离带,因为n>M并且前面的步骤中都没有减少AA路径,可知Gi-1至少包含一条AA路径,根据引理8,总能找到一条有效灰边gi,使得添加gi后的图Gi满足:(1)dsi=0;(2)Gi中不包含真偶隔离带、弱偶隔离带或半偶隔离带.(S5)若Gi-1包含半偶隔离带且dsi-1=0,因为n>M并且前面的步骤中都没有减少AA路径,可知Gi-1至少包含一条AA路径,根据引理9,总能找到一条有效灰边gi,使得添加gi后的图Gi满足:(1)dsi=0;(2)Gi中不包含真偶隔离带或半偶隔离带.又因为无论如何添加灰边半偶隔离带都不会转化为弱偶隔离带,因而Gi中也一定不包含弱偶隔离带.先按照(S1)在GP(A,B)中添加灰边,使部分图中每个SMSP只包含一条AB路径.再按照(S2~S5)在部分图中添加灰边,设得到的新部分图仍为Page11Gi-1,则Gi-1一定满足性质3中的条件(C1)、(C2)和(C3).下面的步骤总假设Gi-1满足这3个条件,并在证明中直接利用性质3.(S6)若smi-12,由于dsi-1=0,根据引理1总能找到smi-1/2条灰边减少2smi-1/2个SMSP.其中每条灰边都满足Δds=0且不会产生新的SMSP和半偶隔离带,因而都满足Δl=-1,Δp=Δr=Δo=0,Δsm=-2,Δδ=0,可得Δ=0.(S7)若smi-1=1,设唯一的一个SMSP为S.因为Gi-1中存在SMSP,显然n>M.又因为前面的步骤都没有减少AA路径,因而Gi-1中一定有一条AA路径.若oi-1=0,添加gi将S中的AB路径的B-tail与一条AA路径连接,则S不再是SMSP.gi满足Δl=-1,Δp=Δr=Δo=0,Δsm=-1,Δδ=0,因而Δ=0.若oi-1=1,添加gi闭合S中的AB路径,则S变为RMSP,gi满足Δl=Δp=0,Δr=1,Δo=Δsm=-1,Δδ=0,因而Δ=0.(S8)若pi-1>0,即Gi-1中存在BB路径,因为前面的步骤都不会改变BB路径和AA路径的数目,根据引理10,总能找到pi-1条灰边将Gi-1中的每条BB路径都与一条AA路径连接.该过程中不产生新的SMSP和半偶隔离带,因而每条灰边都满足Δl=Δp=Δr=Δo=Δsm=Δδ=0,Δ=0.(S9)若Gi-1中既没有SMSP也没有BB路径,添加灰边gi闭合任意一条路径,gi不改变任何参数,因而Δ=0.循环利用上述方法就能添加n+N条有效灰边到GP(A,B)中,得到断点图G(^A,^BOPT).证毕.定理3的证明过程给出了寻找n+N条有效灰边的方法,根据该方法在GP(A,B)中添加n+N条灰边可将其变为断点图G(^A,^BOPT).根据定理2,^A和^BOPT的交互型移位距离恰好等于A,B的移位距离.用SRT的算法对^A和^BOPT进行交互型移位排序,^A和^BOPT的最短交互型移位序列即可模拟出A和B的最短移位序列.完整的基因组移位排序算法Generalized_Sorting(A,B)给出如下.算法1.Generalized_Sorting(A,B).1.任选一个B的加帽基因组^B,构造断点图G(^A,^B)2.构造部分图G=GP(A,B)3.对于G中所有包含两条AB路径的SMSP,添加灰4.ifG中有2个SMSP,并且这两个SMSP相互依赖5.按引理6找一条有效灰边g添加到G中,即6.ifG包含真偶隔离带,且G中的SMSP数大于07.按引理7找一条有效灰边g,G=G+{g}8.ifG包含弱偶隔离带9.按引理8找一条有效灰边g,G=G+{g}10.ifG包含半偶隔离带11.按引理9找一条有效灰边g,G=G+{g}12.whileG中有路径13.ifG中的SMSP数不少于214.令sm为G中的SMSP数,按引理1找sm/215.elseifG中只有一个SMSP16.ifG中的RMSP数为偶数,17.令g为连接SMSP中的AB路径的B-tail18.else19.令g为闭合SMSP中的AB路径的灰边,20.elseifG中有BB路径21.令p为G中的BB路径数,根据引理10找p22.else23.令g为闭合任意一条路径的灰边,G=G+{g}24.endwhile25.根据G计算B的最优加帽基因组^BOPT26.用SRT的算法对^A和^BOPT进行交互型移位排序27.用^A和^BOPT的交互型移位序列模拟A和B的移下面我们分析算法Generalized_Sorting(A,B)的时间复杂度.步1~2构造断点图和部分图需O(n)时间,步3~24添加n+N条有效灰边可在O(n)时间内完成,步25计算^BOPT需O(n)时间.步26采用SRT的算法对^A和^BOPT排序可在O(nnlog槡n)时间内完成[10].因而Generalized_Sorting(A,B)的时间复杂度为O(nnlog槡n).
