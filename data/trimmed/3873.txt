Page1C2E:一个高性能的EPCCL编译器刘大有1),2)赖永1),2)林海3)1)(吉林大学计算机科学与技术学院长春130012)2)(吉林大学符号计算与知识工程教育部重点实验室长春130012)3)(沈阳师范大学软件学院沈阳110034)摘要提出一个新的基于DPLL的编译算法KCDP,从而成功地将EPCCL理论和SAT求解联系起来,使得目前很多应用在基于DPLL的SAT求解器中先进的技术都能被引入到EPCCL理论的编译中以提高编译效率;提出规约规则,并基于该规则,提出能在多项式时间内终止的REDUCE算法对EPCCL理论进行规约;结合KCDP和REDUCE算法,实现了编译器C2E,并在随机问题和国际通用的测试用例上测试了C2E的编译效率和编译质量,实验结果表明,无论从编译效率还是编译质量来说,C2E都是一个高性能的EPCCL编译器.关键词知识编译;EPCCL理论;DPLL程序;规约规则1引言通用形式下的命题推理问题是不易处理的(intractable),从而限制了自动推理技术的应用[1-4].为此提出了众多解决方案,知识编译就是其中一种.知识编译的主要思想是将推理过程分为两个阶段:离线的编译阶段(off-linecompilationphase)和在线Page2的查询阶段(onlinequery-answeringphase).在离线时将命题公式编译为易处理的目标语言(targetlanguage),从而能更有效地支持在线查询.到目前为止,存在的知识编译语言包括Horn理论[1],本原蕴含/本原蕴含式(primeimplicates/implicants)[5-6]、OBDD[7]、DNNF[4,8]、EPCCL理论[9]等.EPCCL理论是林海和孙吉贵于2004年提出的,同时,他们在文献[10]的基础上提出了基于扩展规则的EPCCL编译算法KCER.基于EPCCL的知识编译方法无论在编译阶段还是查询阶段都是基于扩展规则的,其它方法都基于归结原理[11],而扩展规则方法是一种与归结互补的方法,因此基于EPCCL的知识编译方法是一种新颖的方法.目标语言对在线查询的支持程度直接影响其在实际问题中的应用.Darwiche和Marquis在文献[12]中提出了7种用来衡量目标语言的查询标准,并指出OBDD<和MODS满足所有标准,为最易处理的语言.文献[8]提出了DNNF的一类新的满足这些查询标准的子集d-DNNFT.在此基础上,本文证明了EPCCL理论同样能满足这些查询标准,因此EPCCL与OBDD<、MODS和d-DNNFT并列为最易处理的目标语言.知识编译和SAT求解之间存在紧密的联系.DPLL程序[13]在SAT求解领域被广泛关注,许多当前最有效的求解器如BerkMin[14]和MiniSat[15]等都基于该程序.在文献[16]中,Huang和Darwiche提出了一种新的知识编译思路,即对DPLL程序作了不同的修改,然后通过跟踪搜索过程,将其映射为不同的目标语言,包括OBDD,FBDD和DNNF.在此基础上,本文提出了一个基于DPLL的编译算法KCDP.该算法的意义在于将EPCCL理论和SAT求解联系起来,从而使得目前很多应用在基于DPLL算法的SAT求解器中的先进技术都能被引入到EPCCL理论的编译中,以提高编译效率.对于给定公式,可能存在多个EPCCL与之等价,因此,编译结果的规模直接关系到在线查询的效率,是衡量编译器编译质量的重要标准.基于此,本文提出了规约规则,并基于该规则提出了REDUCE算法对EPCCL理论进行规约.本文证明了RE-DUCE算法能在多项式时间内终止.REDUCE算法的意义在于能缩小EPCCL理论的规模,从而更好地支持在线的查询.最后,本文结合KCDP和REDUCE算法,实现了编译器C2E,并在随机问题和国际通用的测试用例上对其进行了测试.实验结果表明C2E的编译质量和编译效率都优于之前存在的基于KCER算法的编译器.2EPCCL理论及其支持的查询在本文中,Χ={x1,…,xn}表示布尔变量集.文字是变量xi或它的否定xi.给定一个文字l,若l为xi,则其否定l为xi;若l为xi,则其否定l为xi.子句C是若干文字的析取.给定一个子句C,若存在某个文字及其否定都出现在C中,则称C为重言子句.模为0的子句称为空子句,模为1的子句称为单元子句,模最大的非重言子句称为极大项.项T是若干文字的合取.当不存在某个文字及其否定都出现在项中,称项一致.合取范式(CNF)是若干子句的合取.下面给出两个子句互补的定义.定义1.给定两个C1和C2,如果存在一个变量x使得文字x和x都出现在子句C1∨C2中,则称C1与C2互补.根据上述定义,有如下结论成立:重言子句与任意子句互补;与空子句互补的只能是重言子句;如果一个子句与另外的子句C互补,则它与任何包含C的子句互补.下面给出EPCCL理论的定义[9].个子句都互补,则称该公式为EPCCL理论.定义2.给定一个CNF公式,若其中任意两对于一种知识编译语言,Darwiche和Marquis认为有意义的查询包括:一致性(consistency)、有效性(validity)、项蕴含(implicant)、蕴含子句(clausalentailment)、蕴含句子(sententialentailment)、等价(equivalence)、模型计数(modelcounting)、模型枚举(modelenumerating),并在此基础上提出了表1中衡量知识编译语言易处理程度的查询标准[12].下面证明EPCCL理论满足所有标准.实际上,林海和孙吉贵已经在文献[9]中证明了EPCCL理论满足CO和CE.在给出证明之前,我们首先给出conditioning[4]的定义和一个引理.定义3.对于给定的公式Σ和一致的项T,若文字l出现在T中,则将Σ所有的l出现置换为1,若其否定l出现在T中,则将Σ所有的l出现置换为0,最后所得的结果称为Σ对于T的conditioning(记为Σ|T).Page3标记COVACEIMEQSECTME我们称一种编译语言L满足CD当且仅当给定该语言的公式Σ和一致性项T,能在多项式时间内得到与Σ|T等价的L语言下公式.引理1.EPCCL满足CD.证明.对于给定的EPCCL理论Σ和一致性项T,将Σ|T中所有包含1的子句删除,然后删除所有的0,最后得到的CNF公式为与Σ|T等价的EPCCL理论,显然该过程能在多项式时间内完成.定理1.EPCCL理论满足表1中所有查询标准.证明.CO:因为EPCCL满足CT,而CT蕴含CO.VA:因为EPCCL满足CT,而CT蕴含VA.CE:CD和CO蕴含CE(文献[12]中引理A.4).IM:CD和VA蕴含IM(文献[12]中引理A.7).EQ:给定EPCCL理论Σ1和Σ2,判定Σ1Σ2是否成立只需判定Σ1Σ2和Σ1Σ2是否同时成立,而EPCCL满足SE,因此其满足EQ.SE:给定EPCCL理论Σ1和Σ2=C1∧…∧Cm,Σ1Σ2成立当且仅当Σ1C1,…,Σ1Cm都成立.EPCCL满足CE,因此其满足SE.CT:使用文献[17]中的#ER算法和文献[18]中的CER都能在多项式时间内对EPCCL理论进行模型计数.ME:CD和CO蕴含ME(文献[12]中引理A.3).3基于DPLL的编译算法DPLL程序是最著名的完备SAT求解算法.基于该算法,Birnbaum和Lozinskii设计了模型计数算法#DPLL(如图1).#DPLL算法的求解过程使用搜索树进行描述,搜索树按照如下步骤建立:首先,建立根节点,标记该节点为待求解的CNF公式①,并将它作为当前节点;开始执行算法;当算法执行第1行,第2行或者第8行时,回溯到当前节点的父节点;当算法执行第4行,建立当前节点的子节点,将连接当前节点和子节点的边标记为l,将子节点标记为{C\{l}|C∈,lC},然后将子节点视为当前节点;当算法执行第6(7)行,建立当前节点的子节点,将连接当前节点和子节点的边标记为x(x),将子节点标记为{C\{x}|C∈,xC}({C\{x}|C∈,xC}),然后将子节点视为当前节点;当算法终止时,搜索树成功建立了.Procedure#DPLL(,A)1.ifisemptythenreturn2n-|A|2.ifthereexistssomeemptyclauseinthenreturn03.ifcontainsunitclause{l}then4.return#DPLL({C\{l}|C∈,lC},A∪{l})5.ChooseavariablexthatappearsinΦ6.tmp←#DPLL({C\{x}|C∈,lC},A∪{x})7.tmp←#DPLL({C\{x}|C∈,xC},A∪{x})8.returntmp+tmp给定搜索树中的叶子节点,本文称由从根节点到该叶子节点的路径上出现的文字组成的子句为该叶子节点对应的子句.显然,不同的叶子节点对应的子句必然互补.本文称一个子句出现在搜索树中当且仅当搜索树中存在某个叶子节点对应该子句.下面举例说明搜索树的结构:例1.给定={x1∨x2,x1∨x3,x1∨x3},根据#DPLL算法,搜索树如图2所示.在树中出现的两个子句分别为C1={x1,x3}和C2={x1,x2},显然二者互补.KCDP算法如图3.由KCDP算法可知,执行DP(,φ,{})(第7行),φ中任意子句都包含C.粗略地说,KCDP算法使用DP算法将扩展为EPCCL理论.因此从本质上讲,KCDP算法也是基①这里用一个CNF公式标记一个节点意味着:若公式中含空Page4于扩展规则的.ProcedureKCDP()1.φ←{}2.whileisnotemptydo3.selectaclauseCform4.←-{C}5.←{{l}|l∈C}∪{C|C(C∈∧l∈Ciffl∈C)}6.φ←{}7.DP(,φ,{})8.φ←φ∪φ9.←φProcedureDP(,φ,A)1.ifisemptythenφ←φ∪{A};return2.ifthereexistsanemptyclauseinthenreturn3.ifcontainsunitclause{l}then4.returnDP({C\{l}|C∈,lC},A∪{l})5.ChooseavariablexthatappearsinΦ6.DP({C\{x}|C∈,xC},A∪{x})7.DP({C\{x}|C∈,xC},A∪{x})我们证明KCDP算法的正确性如下.定理2.给定一个CNF公式,执行完KCDP算法后,是一个等价于原公式的EPCCL理论.证明.我们使用循环不变式证明结论,即证明φ始终是EPCCL理论;φ中任意子句都与中子句互补;执行循环后,(\{C})∪(φ∪φ)等价于∪φ,其中\{C}和φ∪φ为下次循坏中的和φ.开始时,为待编译的CNF公式,φ为空集.显然满足循环不变式的要求.退出循环时,根据循环不变式,φ为等价于原公式的EPCCL理论.(\{C})∪(φ∪φ)∪φ.只需证明(\{C})∪φ.(第5行)对应的搜索树中任意子句都包含C,因此有Cφ,于是(\{C})∪φ.下面证明C能扩展出的任意极大项必然弄假(-{C})∪φ①,即(-{C})∪φC,于是(\{C})∪φ.若C不弄假\{C}中任意子句,则C必然满足,也即C的某个子集必然出现在对应的搜索树中,即C弄假φ.φ∪φ为EPCCL理论.φ为EPCCL理论;根据搜索树,φ也是EPCCL理论;对于任意C∈φ,C与C互补,任意φ都是C的超集,因此C与φ中任意子句互补.任意子句C∈φ∪φ都与\{C}中任意子句C互补:若C∈φ,显然与C互补;否则C∈φ,由C中所有文字组成的赋值必然满足{l|l∈C},因此C与C互补.根据定理2,KCDP为一个合格的EPCCL编译算法.有如下两种途径提高KCDP算法的效率:(1)将SAT求解领域的先进技术引入到KCDP算法中;(2)提供一种启发式在第3行中选择较好子句进行求解.直观上看,为了使(第5行)中的单元子句尽量地多,应该选择最长的子句作为C.下面举例说明KCDP如何运行.例2.给定={x1∨x4,x2∨x4,x1∨x3∨x4,x1∨x3,x1∨x2},从中选出一个子句,假设为C=x1∨x4,因此={x1,x4,x2∨x4,x1∨x3∨x4,x1∨x3,x1∨x2},执行DP后,φ={x1∨x2∨x3∨x4};从={x2∨x4,x1∨x3∨x4,x1∨x3,x1∨x2}选出一个子句,假设为C=x2∨x4,因此={x2,x4,x1∨x3∨x4,x1∨x3,x1∨x2},执行DP后,φ={x1∨x2∨x4};从={x1∨x3∨x4,x1∨x3,x1∨x2}中选出一个子句,假定为C=x1∨x3∨x4,因此={x1,x3,x4,x1∨x3,x1∨x2},执行DP后,φ={x1∨x3∨x4};….最后,φ={x1∨x2∨x3∨x4,x1∨x2∨4对EPCCL理论的规约将给定的CNF公式编译为EPCCL理论后,编译结果的规模直接影响到以后的查询效率,因此其非常重要.从例2可知,我们能对最后的编译结果φ进行处理,从而压缩其规模,以提高在线的查询效率.例如,我们能将x1∨x2∨x3∨x4和x1∨x2∨x3∨x4置换为x1∨x2∨x3.我们将这一操作称为规约规则:定义4.给定CNF公式和其中的两个子句C=l1∨…∨ln∨l和C=l1∨…∨ln∨l,我们称从C和C到l1∨…∨ln的操作为规约规则,称l1∨…∨ln为对C和C使用规约规则的结果.规约规则刚好是扩展规则的反面,而扩展规则是与归结互补的方法,因此规约规则是一种特殊的归结.规约规则具有如下属性:定理3.将CNF公式规约为后,等价于,如果是EPCCL理论,则仍然是EPCCL理论.证明.等价性是显然的,因此我们仅给出结论的第2部分的证明.假设我们用l1∨…∨ln替换C=l1∨…∨ln∨l和C=l1∨…∨ln∨l.为了证明属于EPCCL理论,只需证明l1∨…∨ln与任意子句C∈\{C,C}互补.若C为重言子句,显然l1∨…∨①在本文中,一个极大项弄假(满足)一个公式意味着由极大Page5ln与C互补;否则,因为C同时与C和C,必然存在变量x使得文字x出现在l1∨…∨ln中同时{x,x}C∨l1∨…∨ln.因此若是EPCCL理论,则仍然是EPCCL理论.对于两个非重言子句,能规约的必要条件是它们的长度相等.而对于EPCCL理论中的等长非重言子句,我们利用如下性质判定它们能否被规约:定理4.给定EPCCL理论中长度相等的非重言子句C1和C2能被规约当且仅当|C1\C2|=1.证明.()显然成立.()假设C1\C2={l},因为C1\C2=C1\(C1∩C2),于是(C1∩C2)=C1\{l},又因为C1和C2等长,必然存在l使得(C1∩C2)=C1\{l},因为C1和C2为非重言子句且C1与C2互补,必然有l=l,因此C1和C2能被规约.综上,结论成立.综上所述,我们提出REDUCE算法对EPCCL理论进行规约(如图4).事实上,该算法对一般的CNF公式同样有效.需要注意的是,如果REDUCE算法能规约出空子句(第8行中的条件成立)说明必然不可满足,反之并不成立.例如EPCCL理论={x1∨x2∨x3,x1∨x2∨x3,x2∨x3,x1∨x2,x1∨x3}是不可满足的,但是显然利用REDUCE算法并不能规约出空子句.ProcedureREDUCE()1.Deleteallthetautologiesfrom.2.Classifyalloftheclausesofaccordingtotheirsizes,where1storestheclauseswhosesizeis1,…,nstorestheclauseswhosesizeisn,and0isanemptyset3.fori=n,…,1do4.whilethereexiststwoC1andC2suchthat|C1\C2|=1do5.C←C1\C26.i←i\{C1,C2}7.i-1←i-1∪{C}8.if0isnotemptythen←false9.else←{1,…,n}定理5.给定一个CNF公式,算法REDUCE能在多项式时间内终止.证明.显然第1行和第2行能在多项式时间内执行完.对于第4行到第7行的循环,每循环一次,则i的大小减少1.因此,最多循环|i|次.同时,每次循环显然在多项式时间内执行完毕.因此算法REDUCE能在多项式时间内终止.证毕.例3.我们对如下公式运行REDUCE算法:={x1∨x2∨x3∨x4,x1∨x2∨x3∨x4,x1∨x2∨x3∨x4,x1∨x3∨x4,x1∨x2∨x3,x1∨x2}.由于φ中不存在重言子句,直接对φ按照长度进行划分如下:4={x1∨x2∨x3∨x4,3={x1∨x3∨x4,x1∨x2∨x3};2={x1∨x2};1={};0={}.将x1∨x2∨x3∨x4和x1∨x2∨x3∨x4规约为x1∨x2∨x3;将x1∨x2∨x3和x1∨x2∨x3规约为x1∨x2;将x1∨x2和x1∨x2规约为x1.因此,最后的结果为φ={x1∨x2∨x3∨x4,x1∨x3∨x4,x1}.从例3中可以看出,经过规约后,能明显地减小原子句集的规模,因而能提高在线的查询效率.5C2E及实验结果根据KCDP和REDUCE算法,我们实现了EPCCL编译器C2E.在文献[17]中,为了和#ER算法进行比较,我们实现了#DPLL算法.C2E中的KCDP算法是在#DPLL算法的基础上实现的.在实现REDUCE算法的过程中,考虑到通常需要规约的子句集的规模都比较大,我们利用哈希表加速求解.哈希表的主键值为子句中出现的变量的下标的和.显然,只有同主键值的子句才有可能被规约.我们在随机问题和国际上通用的测试用例上测试了C2E的编译效率和编译质量(使用子句数目进行衡量),并与文献[9]中的KCER算法进行了比较.实验平台如下:CPU:P4-2.8GHz,内存:512MB;操作系统:WindowsXP.限于篇幅,本文仅列举部分实验结果(见表2).在表2中,前8个为随机的InstanceKCER(50,20,3)0.2953920.0374360.084330(50,20,4)0.72216210.11177920.1110775(50,30,3)11.501531060.641558930.8067548(50,30,4)--4.1910620396.09504813(100,20,3)0.9861330.0563860.063645(100,20,4)2.22291050.13206590.1412301(100,30,3)--0.661507750.7481257(100,30,4)--12.52221268027.191109662uf20-011.0995230.0696590.085184blockworld-anomaly30.45189370.06108510.284842pigeon-hole-6--28.84529417204.8481440par8-1-c3.1344430.0844430.4264aim50_1-6yes1-30.112560.022560.2350aim50_1-6no-32.3975240.1975240.271590Page6SAT问题,后6个为benchmark实例;随机问题用(c,v,k)表示,其中c表示子句数,v表示变量数,k表示子句的长度;time为对应算法的运行时间;size为执行算法后得到的EPCCL理论的规模(用子句数衡量);-表示对于给定实例算法因内存溢出而导致无法求解.实验结果表明:无论是随机问题还是benchmark实例,通过KCDP算法编译后的EPCCL理论的规模相差不大,也即KCDP和KCER编译质量相差不大,但是KCDP的编译效率明显高于KCER;对于其中的某些问题,KCER因内存溢出而无法完成求解,KCDP能成功编译它们;REDUCE算法能够明显地压缩EPCCL理论的大小,考虑到编译都是离线进行,而编译后的目标语言的大小直接影响在线的查询效率,因此,REDUCE算法是很有意义的;总体来说,KCDP和REDUCE算法的总的求解时间仍然少于KCER算法,而运行KCDP和REDUCE算法得到的EPCCL理论的规模明显小于通过KCER算法编译后的EPCCL规模,因此无论从编译效率还是编译质量来说,C2E都是一个优秀的EPCCL编译器.需要指出的是,目前基于DPLL的高效的SAT求解器中,使用了诸如冲突学习,两个观察变量的BCP等先进技术,这些技术都能引入到C2E中;同时,能设计启发式策略加速求解.因此C2E还拥有很大的提升潜力.6结语EPCCL理论是一种新的知识编译语言.本文提出一个新的基于DPLL的编译算法,成功地将EPCCL理论与SAT求解联系起来,从而使得目前很多应用在基于DPLL的SAT求解器中的先进技术都能引入到EPCCL理论的编译过程中,从而提高编译效率.在此基础上,为了压缩EPCCL理论的规模,本文提出了规约规则.并基于该规则提出了REDUCE算法,该算法能在多项式时间内对EPCCL理论进行规约.最后,我们结合KCDP和REDUCE算法,实现了编译器C2E,并在随机问题和国际通用的测试用例上对C2E进行测试.实验结果表明,无论对于随机问题还是benchmark实例,在编译质量相当的情况下,KCDP的编译效率明显优于KCER;REDUCE能明显地压缩EPCCL理论的规模.考虑到能将SAT求解中的先进优化技术引入到C2E中以及设计好的启发式策略引导编译,以进一步提高编译效率,这两方面将是我们下一步工作的重点.
