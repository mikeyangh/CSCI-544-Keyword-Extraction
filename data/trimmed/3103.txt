Page1高效的随机访问分块倒排文件自索引技术刘小珠1),2)彭智勇3)陈旭3)1)(武汉大学软件工程国家重点实验室武汉430072)2)(武汉理工大学自动化学院武汉430070)3)(武汉大学计算机学院武汉430072)摘要针对倒排索引空间开销大、查询时间效率低以及难以同时支持连接布尔查询和排序查询的问题,提出了一种同时提高空间效率与查询时间效率的高效随机访问分块倒排文件自索引RABIF.为了在降低空间消耗的同时支持连接布尔查询与排序查询,RABIF将倒排列表进行合理地分块,然后对每个子块的不同部分采用相应的压缩方式,在不需要插入任何附加辅助信息的前提下实现压缩索引的快速定位与随机访问.理论分析及实验结果表明,与忽略倒排文件自索引SIF相比,提出的RABIF空间开销平均减少5.3%,布尔查询时间平均减少17.8%;对于0.2%与1%排序查询,查询时间分别平均减少34.4%与27.5%.关键词倒排文件;自索引;时间效率;空间效率;随机访问1引言随着文本信息量的迅速增长,对高性能全文检索系统的需求越来越迫切.如何快捷有效地管理和检索文本这种非结构化的数据成为一项紧迫的研究任务[1-2].由于倒排索引技术具有实现相对简单、查询速度快以及易于支持同义词查询等扩展功能的优点,被广泛应用于大规模文本集[3]与其它各种信息的检索[4-5].但面对与日俱增的海量文本信息,倒排索引空间开销大、查询效率低的弊端日益凸现[6],如何在降低倒排索引存储空间的同时提高查询效率成为全文检索的突出问题.采用适当的编码策略对倒排索引进行压缩,不仅可以节省存储空间,而且可以减少查询时读取索引数据所需的磁盘I/O次数与时间,从而提高检索速度[1,7-8].因此,当前大多数研究都集中在如何对倒排索引进行有效的压缩方面[1-3].为了降低倒排索引的存储空间,Moffat等[9]提出了一种递归的二进制内插编码(BinaryInterpolativeCoding,BIC)算法对倒排索引进行压缩;BIC利用相邻两个数的信息,对单调递增的倒排列表进行紧凑的递归编码,不仅压缩率高,而且解码速度快;该算法还考虑了文档中词出现的频率分布,以聚类(clustering)的方式对倒排列表的压缩性能进行优化,有效地提高了索引的空间效率.文献[10]采用基于字行的二进制编码方式(Word-AlignedBinaryCode,WABC)对索引进行压缩;该编码具有字节操作的优点,其紧凑的二进制特性不仅保证了索引的压缩性能,而且提高了查询时倒排列表的解码速度.针对WABC中每个字(32比特)存在部分比特浪费的缺点,Anh等[11]提出了一种压缩性能更高的滑动(sliding)压缩算法;其思想是充分利用每个字中的剩余比特存储索引信息,提高空间利用率;但其解压复杂性更高,在一定程度上降低了查询性能.考虑到倒排列表中数据分布的特性,文献[12]提出了一种基于聚类的混合编码压缩算法;该算法根据设定的阈值,将倒排列表中的整数按其差值与阈值之间的大小关系分成不同的簇,然后对小于阈值的簇与大于阈值的簇分别采用不同的压缩编码算法,以提高索引的空间性能;但如何确定合适的阈值以及这种混合编码方式在查询时的解码性能如何,该文并没有阐述.文献[13]中同时考虑了搜索引擎中的索引压缩与索引缓存机制,并对变比特编码等几种压缩算法的性能进行了比较分析.为了进一步提高检索性能,文献[14-17]对倒排列表文档标识(Identity,ID)整数集的升序特征进行了研究,通过更加紧凑的表示方法、快速求交集算法以及对文档ID顺序进行优化,提高查询效率.文献[7-8,18]通过实验研究进一步表明了对索引进行压缩不仅可以提高空间效率,而且有助于提高访问速度.为了在降低倒排索引存储空间的同时提高查询效率,Moffat等[3,19]提出了一种有效的忽略倒排文件(SkippedInvertedFile,SIF)自索引(Self-index);SIF将倒排列表分成多个子块,通过在相邻子块间插入少量的忽略信息(Skippinginformation),使得查询时只需对压缩索引进行部分解码,从而提高检索的时间效率;当选择合适的子块大小并以递归方式对倒排列表进行压缩时,可以提高存储空间与查询时间效率;但该方法存在以下问题:(1)加入的辅助信息增加了索引的空间消耗,尤其是当子块较小时,辅助信息所造成的额外空间开销将不可忽略,空间效率将大大下降;(2)无法找到合适的子块大小使得空间效率与连接布尔查询、排序查询等性能同时提高.尽管上述研究工作对倒排索引的时间和空间性能进行了改进,但仍然存在以下问题[20]:(1)倒排文件存储空间与查询时间效率还有待进一步提高.上述方法大多只针对其中的一个性能进行研究,或提高了一个性能却导致另一个性能恶化.如何实现空间效率与时间效率的性能折衷具有相当的挑战性.(2)上述研究方法并没有充分考虑索引查询的可扩展性,无法同时适应不同查询方式快速定位与解码的要求,导致查询性能相差较大.如排序查询需要访问倒排列表中的词频信息,现有方法必须完全解码索引才能实现词频信息的访问,导致时间消耗较大.(3)当倒排列表被分成大量的小块时,现有方法不仅会导致大量的额外空间开销,而且由此产生的磁盘I/O时间将超过压缩所带来的性能.本文针对倒排文件空间开销大、查询效率低以及难以同时支持连接布尔查询和排序查询的问题,提出一种同时提高存储空间与查询效率的高效随机访问分块倒排文件自索引RABIF.RABIF将倒排列表进行合理地分块,然后对每个子块的不同部分采用相应的压缩方式,以提高索引的压缩率;同时采用高效的二进制内插编码方式,在不需要插入任何附加辅助信息的前提下实现压缩索引查询的快速定位,使得压缩索引具有随机访问能力,在查询时只对索引中需要的部分进行解码,以提高检索的时间效率.与现有的工作相比,提出的RABIF自索引具有Page3以下特点:(1)在不插入任何附加辅助信息的前提下,压缩的RABIF索引具有快速定位与随机访问能力;(2)具有快速的连接布尔查询与排序查询性能;(3)同时提高了存储空间效率与查询时间效率.2随机访问分块倒排文件自索引为了在提高索引空间效率的同时,支持高效的连接布尔查询和排序查询,提出的倒排文件自索引RABIF的思想是:将倒排列表进行分块,构造一种具有随机访问功能的分块倒排列表.每个子块由两部分组成:第一部分为定位部分.采用d-gap压缩方式,实现压缩索引查询的快速定位,使得压缩索引在不解压的情况下具有子块级的随机访问能力,以提高查询时间效率;第二部分为信息部分.以部分解码的方式支持连接布尔查询与排序查询,并以高效的二进制内插编码方式进行压缩,在不需要插入任何辅助信息的前提下,实现查询时子块内信息的随机访问与快速定位功能,在减少空间消耗的同时提高查询效率.2.1索引结构与创建提出的倒排文件自索引RABIF的结构如图1所示.索引由词典(Dictionary)和分块倒排列表(Postinglists)组成.词典包含两部分信息:(1)词wi以及包含该词的文档数量si;(2)指向包含wi具体位置信息的分块倒排列表Lblocki由m个子块SBr(r∈[1,m])组成,每个子块表LblockSBr包括定位部分Locr与信息部分Ir.定位部分Locr为子块SBr的第一个文档标识(Identity,ID)与累计词频信息序列对;除了第m个子块SBm的信息部分Im保持原倒排列表Li中文档ID与累计词频信息序列对的格式外,其它子块的信息部分Ir由其它k-1个信息对分别按文档ID与累计词频的升序排列而成的两个列表LDr与LFr组成.对于包含n个信息序列对(dj,fqj)的倒排列表Li:Li=(d1,fq1),(d2,fq2),…,(dn,fqn)(1)其中dj表示文档的ID,且有dj<dj+1,j∈[1,n-1],fqj表示该词在文档dj中出现的次数.分块倒排列表Lblocki的构建算法BIL如算法1所示.算法1.分块倒排列表构建算法BIL.输入:倒排列表Li,每个子块包含的信息序列对数k输出:分块倒排列表Lblock1.对Li中的词频fqj以累加方式得到累计词频fj,并用fj替换fqj,实现fj的升序排列.2.以k个信息序列对为单位将Li分成m个子块SBr.3.对前m-1个子块SBr的信息部分Ir,分别将文档ID与累计词频按照其原来的先后顺序排成文档ID和累计词频两个列表LDr与LFr.对LDr与LFr采用C2编码方式进行压缩.4.对所有子块SBr的定位部分Locr以及第m个子块SBm的信息部分进行d-gap压缩,并采用编码方式C1进行压缩.5.返回分块倒排列表Lblock根据BIL算法,首先用fj替换词频fqj:然后将倒排列表Li分成m个子块SBr(r∈[1,m]),且每个子块包含定位部分Locr与信息部分Ir.则有其中k为每个子块中包含的信息序列对的数量.对于第m个子块,其信息序列对的数量可能小于k.根据BIL算法的第3步,对于定位部分Locr有其中dr和fr分别表示第r个子块的第1个信息序列对的文档ID与累计词频,且有对于信息部分Ir有Ir=(LDr,LFr),烅烄(dk(m-1)+2,fk(m-1)+2),…,(dn,fn),r=烆LDr=(dk·(r-1)+2,…,dk·r),r∈[1,m-1](9)LFr=(fk·(r-1)+2,…,fk·r),r∈[1,m-1](10)然后对LDr与LFr采用C2编码方式进行压缩.根据BIL算法的第4步,对所有子块的定位部Page4分进行d-gap压缩后有dr=d1,fr=f1,从表达式(8)中可以看出,由于第m个子块SBm的信息部分Im维持原倒排列表Li中信息序列对格式,即当j∈[(m-1)k+1,n]时,信息部分格式为(dj,fj),因此采用d-gap压缩后有dj=dj-dj-1,j∈[(m-1)k+2,n](13)fj=fj-fj-1,j∈[(m-1)k+2,n](14)然后采用编码方式C1进行压缩.经过BIL算法后有i=BIL(Li)=(Loc1,I1),…,(Locj,Ij),…,Lblock2.2分块倒排列表的编码为了尽可能降低分块倒排列表Lblocki的每个子块SBr的定位部分Locr、信息部分耗,LblockIr的两个列表LDr与LFr分别采用不同的编码方式C1和C2进行压缩.当子块SBr的定位部分Locr采用编码方式C1进行压缩时,所需比特数用BC1,k(Locr)表示;当子块SBr信息部分Ir的两个列表LDr与LFr采用编码方式C2进行压缩时,存储这两种信息所需要的比特数分别用BC2,k(LDr)和BC2,k(LFr)表示.由于每个子块SBr的定位部分Locr只包含一个信息序列对,因此可以采用压缩性能好的Golomb编码进行压缩(当然也可以采用其它性能更好的编码算法).为了在不加入任何辅助信息的前提下,支持倒排列表的随机访问与快速定位以提高查询的时间效率,关键的问题是寻找一种有效的编码方式,这种编码方式在对每个块中信息部分的文档ID和累计词频进行压缩后具有精确的寻址和随机访问能力.这意味着子块SBr的信息部分Ir的编码方式必须满足以下条件:(1)在不附加任何辅助信息的前提下,具有块间忽略功能,这要求在当前已知定位部分Locr与Locr+1的信息时,能计算出下一个子块Ir+1的地址;(2)支持块内定位功能,即在实现子块定位后,能在压缩的子块上,实现块内任意元素的随机访问、定位与解码功能.二进制内插编码BIC[9]不仅可以对升序的整数集进行有效压缩,而且在已知升序的整数集的最小整数与最大整数时,能有效地计算出压缩该整数集所需的空间消耗.BIC编码的这些特点与倒排列表中文档ID本身就是升序排列、所要实现的精确寻址和随机访问能力相吻合.因此,如果通过块间忽略功能,得到当前已知定位部分Locr与Locr+1的信息时,就可以在满足上述条件的同时准确地计算其压缩后所需要的比特数,进而实现上述两个条件所需满足的功能.因此本文采用高效的二进制内插编码BIC对信息部分的两个列表LDr与LFr进行压缩.根据二进制内插编码BIC的原理,对于子块SBr信息部分Ir的升序列表LDr,其k-1个整数经过编码后所占用比特数取决于列表中整数的取值范围D.为了在无需对LDr解码的前提下计算出LDr所占的空间,可由已知的SBr定位部分Locr的文档号dk·(r-1)+1与下一个子块SBr+1定位部分Locr+1的文档号dk·r+1来计算D.因此,对于子块SBr的信息部分列表LDr有BC2,k(LDr)=BBIC,k(D)同理,对于子块SBr的信息部分列表LFr有BC2,k(LFr)=BBIC,k(fk·r+1-fk(r-1)+1-1)(17)BBIC,k(D)=0,对于二进制内插编码BIC有对于子块SBr的信息部分Ir的两个列表LDr与LFr,其文档dk·(r-1)+1+j与对应词频fk·(r-1)+1+j之间的物理位置满足以下关系:BBIC,k,r(dk·(r-1)+1+j,fk·(r-1)+1+j)=(k-j)k-1·BBIC,k(dk·r+1-dk·(r-1)+1-1)+(j-1)k-1·BBIC,k(fk·r+1-fk(r-1)+1-1),j∈[1,k-1]例1.某词wi的倒排列表Li包含n=10个信息序列对Li=(1,2),(2,3),(4,1),(5,2),(6,4),(8,2),(10,3),(12,1),(15,3),(17,2),当k=4时,对Li进行BIL编码.根据算法1,首先用表达式(2)求累计词频并进行替换有L1i=(1,2),(2,5),(4,6),(5,8),(6,12),(8,14),(10,17),(12,18),(15,21),(17,23).然后以k=4个序列对为单位对Li进行分块:L2i=[(1,2),(2,5),(4,6),(5,8)],Page5接着对前m-1(10/4-1=2)个子块的信息部分分别按文档ID与累计词频进行升序排序有L3i=[(1,2),(2,4,5),(5,6,8)],然后对前m-1个子块的信息部分进行BIC编码,由Loc1=(1,2)与Loc2=(6,12),此时LD1的3个整数的取值范围一定在[2,5]之间,即最多有4个取值,只需要2比特对每个整数进行编码.同理,对于LF1的3个整数的取值范围一定在[3,11]之间,最多有9个取值,只需要4比特.依此类推,BIC编码后可得L4i=[(1,2),(00,10,11),(0010,0100,0110)],[(6,12),(001,011,101),(001,100,101)],[(15,21),(17,23)].接着对每个子块的定位部分及最后一个子块的信息部分进行d-gap压缩有L5i=[(1,2),(00,10,11),(0010,0100,0110)],[(5,10),(001,011,101),(001,100,101)],[(9,9),(2,2)].最后对该部分进行参数为3的Golomb编码有L6i=[(00,001),(00,10,11),(0010,0100,0110)],[(101,11100),(001,011,101),(001,100,101)],[(11011,11011),(001,001)].2.3分块倒排列表的解码与随机访问为了便于解码,需要已知当前子块SBr定位部分Locr与下一个子块SBr+1的信息来计算编码所需的比特数.因此,其存储顺序作如下调整:i=Loc1,Loc2,I1,Loc3,I2,…,Locm,Im-1,ImLblock用P(Loc1)表示分块倒排列表Lblock子块SB1的定位部分Loc1的物理地址,则可计算出i中任意子块SBr的定位部分Locr与信息部分IrLblock的两个列表LDr与LFr的所有地址:P(Locr)=pi,r=1,烄P(Loc1)+BC1,k(Loc1),r=2,P(Loc1)+∑r-1烅∑r-2烆P(Ir)=P(LDr)=P(Loc1)+∑2烄P(Loc1)+∑r+1烅∑r-1烆P(LFr)=P(Ir)+BC2,k(LDr),r∈[1,m](23)对于子块SBr的列表LDr的第j个文档ID的物理地址Pd(LDr,j)有Pd(LDr,j)=P(LDr)+(j-1)其中P(LDr)与BC2,k(LDr)分别由表达式(22)与(16)计算.同理,对于子块SBr的列表LFr的第j个文档累计词频的物理地址Pf(LFr,j)有Pf(LFr,j)=P(LFr)+(j-1)其中P(LFr)与BC2,k(LFr)分别由表达式(23)与(17)计算.子块SBr信息部分Ir的两个列表LDr与LFr中任意的文档dk·(r-1)+1+j与对应词频fk·(r-1)+1+j的地址,在已知P(Ir)与P(LFr)的前提下,通过表达式(24)与(25)得出.如算法2所示.分块倒排列表的解码与随机访问算法BILDRA算法2.分块倒排列表解码与随机访问算法BILDRA.输入:pi,Lblock输出:d对应的词频fq1.根据pi利用式(21)计算P(Loc1),根据C1解码得2.for(i=2;in/k;i++){3.if(d==dk·(i-2)+1)4.returnfqk·(i-2)+1.5.else6.由式(21)计算P(Loci)并解码得(di,fi),根7.if(d∈(dk·(i-1)+1,dk·i+1))8.returnBRA(P(Loci-1),Ii-1,Loci-1,Loci,d).9.elsePage610.continue11.}12.return0.BILDRA算法首先通过对子块的定位部分解码,确定查询文档d所在子块.然后调用块内随机访问算法BRA,实现子块内的快速定位与随机访问.块内随机访问算法BRA如算法3所示.算法3.块内随机访问算法BRA.输入:P(Locr),Ir,Locr,Locr+1文档号d输出:d对应的词频fq1.根据式(22)计算P(LDr).2.if(d==dk·r+1+1)3.根据式(24)求Pd(LDr,1),并对LDr的第一个文4.if(d==dtemp)5.根据式(25)和式(2)求Pf(LDr,1)解码计算fq6.returnfq.7.elseif(d==dk·(r+1)+1-1)8.根据式(24)求Pd(LDr,k-1),并对LDr的第k-19.if(d==dtemp)10.根据式(25)和(2)求Pf(LDr,k-1)解码计算fq.11.returnfq.12.else13.采用折半查找算法14.if(dj==d)15.根据式(25)计算Pf(LFi-1,j)与Pf(LFi-1,16.returnfq.17.else18.return0.19.return0.块内随机访问算法BRA,首先判断查询文档d与当前子块定位部分文档ID号dk·r+1及下一个子块定位部分文档ID号dk·(r+1)+1之间的关系,对于d==dk·r+1+1与d==dk·(r+1)+1-1两种特殊的情况,可以直接解码得到词频,其它情况采用折半查找算法进行定位,提高解码与查询效率.包含词wi,并返回词频.例2.对例1中的数据实现查询:文档8是否由表达式(20)可知Li经过编码后的实际存储结构L7i为L7i=(00,001),(101,11100),根据词表指向倒排列表的指针pi,得P(Loc1)=pi.根据编码方式可得BC1,4(Loc1).由BILDRA算法的步1与步6可得(d1,f1)=(1,2)与(d2,f2)=(5,10)以及(d1,f1)=(1,2)与(d4+1,f4+1)=(d1+d2,f1+f2)=(6,12).由于8>d4+1,因此必须找到下一个子块的定位部分Loc3.根据BILDRA算法,计算出:P(Loc3)=P(Loc1)+BC1,4(Loc1)+BC1,4(Loc2)+对Loc3进行解码得(d3,f3)=(9,9)以及(d8+1,f8+1)=(d3+d4+1,f3+f4+1)=(15,21).此时有8∈(d4+1,d8+1),因此对第2个子块的信息部分进行块内随机访问算法BRA.根据BRA,采用折半查找算法,此时对LD2的第i(i=(k-1)/2=1)个文档ID进行解码.可知LD2的第1个文档ID与8相同.因此根据式(25)计算词频的地址,并得累加词频值14,该值减去f4+1,即得频率为2.3性能分析3.1空间性能分析表Lblock间BLblock中N为Lblock证明.包含n个信息序列对的分块倒排列表i,有2n个整数,其取值范围为[1,N].用LblockB[N,2n]表示压缩2n个文档ID与词频所需要的比特数,对于Golomb编码有[9]B[N,2n]2n·(2+log2N/(2n()))(26)当用Golomb编码对Lblock位部分Locr以及最后一个子块的信息部分进行编码时,所需要的空间为定理1.包含n个信息序列对的分块倒排列i,在最坏情况下,采用BIL进行编码所占空i为2n2+log2kLoc=[2n-2(m-1)(k-1)]·BGolomb其中m为子块数量,由表达式(4)计算.码,其所需空间为对于前m-1个子块的信息部分,采用BIC编Page7I=∑m-1BBIC(k-1)∑m-12(k-1)(m-1)1+log2N分块倒排列表Lblock考虑最坏情况下,即取m=n/k=n对式(29)进行简化有i=2n2+log2kBLblock定理1得证.从表达式(30)可以看出,BLblock随着k的增加而减小,但k的取值必须满足范围约束条件k∈[2,n-1].推论1.在最坏情况下,提出的RABIF自索引比SIF自索引[3,19]的空间消耗小BGolombskipping_information表示SIF自索引中插入的m个其中BGolomb忽略信息采用Golomb编码所需的空间.证明.对于SIF自索引,根据其结构所需存储空间BGolombSIF为BGolomb其中BGolombpointerdr+1)采用Golomb编码所需的空间,pointerdr+1为指向下一个子块忽略信息对的地址指针;BGolombI表示前m-1个子块的信息部分,采用Golomb编码所需的空间:BGolombI2(m-1)(k-1)2+logNBGolomb=2(m-1)(k-1)1+logN由表达式(28)与式(33)有BGolomb因此在最坏情况下,提出的RABIF自索引比SIF自索引的空间消耗小:推论1得证.3.2时间性能分析根据文献[3,9]的研究表明,BIC的解码时间性能与Golomb相当,而且在某些情况下略优于Golomb.以下分析中假设BIC与Golomb的解码时间性能相同,即两种方法解码一个(dj,fj)所需的时间均为td.定理2.对包含n个信息序列对的分块倒排列i,查找项为q个时,其最小查询时间Tmin为表Lblock4+n槡(td1+q所需的时间,tr为读取一个(dj,fj)所需的时间.证明.考虑最坏情况下,需要将整个倒排列表i读入,即需要将n个信息序列对都读入内存,则Lblock时间为trn.在最坏情况下,Lblock定位部分Locr(r∈[1,m])都需要解码,则所需时间为tdm;每个子块的列表LDr最坏情况下折半查询需要解码一半,而LDr中的每一个文档ID解码时间为td/2,则所需时间为q·k-1的文档ID地址后,LFr部分可直接解码得到词频,则所需时间为q·td2.因此有解码时间Td为Td=tdm+q·k-1而总时间T是读取时间与解码时间Td之和,因此有由于m满足表达式(4),代入有对于提出的RABIF自索引,显然当k为具有最小的解码时间Td,min与总时间Tmin值:定理2得证.推论2.在最坏情况下,提出的RABIF自索引比SIF自索引的查询时间消耗小k-1证明.对于SIF自索引,在最坏情况下,倒排列表中所有m个子块的辅助信息(该信息是一个信息序列对)都需要解码,则所需时间为tdm;另外,Page8SIF中并不具备块内的随机访问能力,因此最坏情况下,SIF需要将块内的所有k个信息序列对进行解码,这里我们取其平均解码时间,也就是只需要对k/2个信息序列对进行解码所需的时间td·k/2,因此查询项为q个时,可得解码时间Td,SIF的表达式为由于SIF自索引中插入了m个子块的辅助信息,因此在最坏情况下,需要将整个倒排列表读入,因此其读取时间为tr(n+m).则总时间TSIF为从编码方式的角度而言,RABIF定位部分以及最后一个子块的编码方式与SIF相同;而不同之处在于RABIF中没有插入辅助信息,RABIF中前m-1个子块的信息部分的编码方式采用的是BIC编码.当假设BIC与Golomb的解码时间性能相同,即两种方法解码一个(dj,fj)所需的时间均为td时,可得提出的RABIF自索引,在最差情况下比SIF自索引的查询时间消耗小:推论2得证.定理3.在最坏情况下,对包含n个信息序列对的分块倒排列表Lblock使空间与查询时间性能最优的k的取值范围为[min(2n/槡q,n-1),max(2n/槡q,n-1)].证明.根据定理1可知,在最坏情况下,采用BIL进行编码所占空间BLblock的增加而减小,但k的取值必须满足范围约束条件k∈[2,n-1].因此k为n-1时,空间性能最优.根据定理2,对于提出的RABIF自索引,显然当k为2n/槡q时具有最小的解码时间与查询时间值.因此有同时优化空间与查询时间性能的k取值范围为k∈[min(2n/槡q,n-1),max(2n/槡q,n-1)](44)4实验结果为了验证提出的RABIF自索引的性能,对其所占空间大小与查询时间效率进行测试,并与SIF自索引进行了对比.实验数据均在以下硬件实验平台下测试获得:CPU3.0GHz、硬盘240GB、内存1GB、操作系统WindowsXP.实验数据来自武汉市专利局,数据大小为193.2GB,该表中含有42个属性,其中40个属性是文本类型,对这40个文本属性均建立了全文索引.提出的RABIF自索引与SIF自索引均在开源Clucene①搜索引擎上实现,系统实现中将Clucene搜索引擎的索引结构以及编解码方法分别替换为RABIF与SIF,其它部分功能(如分词、建词表等),直接采用了Clucene系统中的方法.对于Clucene搜索引擎,其压缩后的倒排列表文件所占空间大小为22.5GB.4.1空间性能图2所示为Clucene系统不考虑分块机制时索引大小以及经过两种自索引压缩后索引大小的实验结果.如图2所示,由于没有考虑分块机制,Clucene系统所产生的索引大小为22.5GB,与k值无关.提出的RABIF自索引所占的空间比例明显小于SIF,两种自索引所占空间比例平均相差1.16GB.随着子块中信息序列对数量k的增加,两种索引所占的空间都将逐渐减小.RABIF索引所占空间从25.7GB降低到21.71GB,原因是当k增加时,每个子块内相邻两个数的平均间隔将越来越小,采用BIC编码时所需的比特数也越少,因此存储空间消耗逐渐降低.对SIF其值从28.035GB降低为22.52GB,原因在于当k增加时SIF索引需要插入的冗余信息比例将减少,因此所占空间比例逐渐降低.随着k值的增加,两种索引的空间比例差越来越小.上述实验结果与表达式(30)与(34)的理论分析基本一致,即RABIF索引所占空间与k成反比;随k值的增加SIF索引插入的冗余信息比例将减少,两种索引空间大小的差值减小.另外,SIF索引所占空间大小始终大于Clucene压缩后倒排列表文件大小,当k为257时,此时SIF的索引大小与Clucene①CLuceneSearchEngineWiki.RetrievedOctober21,2007,Page9系统相当.而当k为33与65时,RABIF索引所占空间分别为22.79GB与22.25GB,其大小为Clu-cene系统所形成索引大小的101.3%与98.9%.这表明,当k达到65时,索引所占空间将小于Clucene压缩后倒排列表文件大小,而且随着k的增加进一步降低,当k增加到1025时候,RABIF索引所占空间为21.71GB.这也表明RABIF具有降低索引空间消耗的优势.4.2查询时间性能图3所示为子块中信息序列对数量k分别取5、129与1025时,RABIF与SIF两种自索引以及Clucene系统随连接布尔查询词增加时的性能.从图3可以看出,RABIF与SIF两种索引的布尔查询性能明显优于Clucene系统的性能.其主要原因在于RABIF与SIF两种索引采用了快速的定位功能,能明显地提高查询的性能.同时,对于RABIF与SIF,k值越小,RABIF与SIF两种索引的布尔查询性能越好.对于相同的k值,RABIF索引时间性能明显优于SIF,布尔查询时间平均减少了17.8%.当k分别取5、129与1025,与SIF相比,RABIF的查询时间平均小0.152s、0.164s与0.168s,时间差值基本保持在0.16s.这与表达式(43)的理论分析结果基本一致,即两种索引查询时间的差值与查询项q及子块数量m有关,而td的取值一般为毫秒级,因此,两种索引查询时间的差值约等于mtr.另外当k分别取5、129与1025时,根据定理3的理论分析,此时由于n为48671,通过分析计算此时可得q分别为3893.7、5.9与0.1.图3中所示,由于图中q的取值范围为[2,18],因此RABIF查询性能的最小值分别出现在q为18、6与2时,这与理论分析一致.当k为5时,查询词的数量对SIF索引性能影响并不明显.而当k值为129与1025时,多词查询时间将随查询词数量的增加而呈线性增长.因此,对于布尔查询,SIF索引中k的取值应小于129.对于RABIF索引,从图3中可以看出,只有当k取1025时,查询时间的大小才随查询词数量的增加而增长明显.因此k的取值范围更广,其值在5~1025之间时都具有良好的布尔查询性能.图4所示为子块中信息序列对数量k增加时,两种自索引0.2%排序查询的性能.由于Clucene系统中并没有采用分块的方法,其0.2%排序查询时间性能与k无关,时间大小为1.73s.如图4所示,RABIF的时间性能优于SIF,尤其是当k>33时,性能差更明显,两者时间差从0.28s增加到1.32s;与SIF相比,查询时间平均减少了34.4%.对于SIF索引,当k的取值为5~17时,查询时间并没有明显的变化,均小于1.3s.但随着k值的增加,查询时间从1.5s迅速增加到2.8s.因此,对于排序查询,SIF的性能受k值的影响显著,且k<33时性能较好,此时其时间性能为1.5s,而当k值增加到65时,查询时间将增加到1.81s,比Clucene系统的性能更差.其原因在于k值越大,每个子块的信息对越多,在排序查询时解码所需的时间越长.而RABIF的时间性能基本在1.4s以下,原因是RABIF索引中每个子块的解码与k的取值相关性不大,只要已知该词的分块倒排列表的指针pi,就可以实现随机访问与解码等功能.这也表明RABIF排序查询时,k取值范围更大.k51733651292575131025Page10表1所示为1%排序查询时,两种索引在k取不同值时的查询性能.对于1%排序查询,此时Clucene系统查询时间大小为3.91s,与k值无关.从表1中的实验数据可以得出与图4基本一致的结论:提出的RABIF索引具有明显的时间性能优势,与SIF相比,查询时间平均减少了27.5%,与Clucene系统相比总是低于其查询时间;RABIF索引排序查询时k取值范围为[5,1025],而对于SIF,当k>65时,其性能将比Clucene系统差.4.3讨论通过上述实验,可以得到如表2所示优化性能的k值范围.对于空间性能,k值越大两种索引所占的空间越小.当k>33时,提出的RABIF索引所占空间小于Clucene压缩后倒排列表文件大小;对于SIF,当k>129其空间大小为101.7%与Clucene压缩后倒排列表文件大小相当.对于连接布尔查询,SIF索引中k的取值小于129时,多词连接布尔查询性能较好;而k值在5~1025之间时RABIF都具有良好的布尔查询性能.对于排序查询,SIF索引k的取值应小于33,而k值对RABIF的排序查询时间性能并不明显.因此,SIF算法难以同时实现空间与时间性能的优化,而当k∈(33,1025)时提出的RABIF算法性能得以优化.空间性能布尔查询时间性能排序查询时间性能k取值范围5结束语针对倒排文件空间开销大、查询效率低以及难以同时支持连接布尔查询和排序查询的问题,提出了一种同时提高存储空间与查询时间效率的高效随机访问分块倒排文件自索引RABIF.为了支持连接布尔查询与排序查询,RABIF将倒排列表进行合理地分块,然后对每个子块的定位部分与信息部分分别采用Golomb与BIC编码进行压缩,降低倒排列表的空间消耗;在不需要插入任何附加辅助信息的前提下,RABIF具有快速定位功能,使得压缩后的索引具有子块级与子块内信息的随机访问能力,显著地提高了查询时间效率.理论分析与实验结果表明,当k为65时,RABIF索引所占空间将低于Clucene压缩后的倒排列表文件大小;与SIF相比,布尔查询时RABIF索引的k值范围更大,查询时间平均减少了17.8%;对于0.2%与1%排序查询,RABIF查询时间比SIF平均减少了34.4%与27.5%.当k∈(33,1025)时提出的RABIF算法能同时提高存储空间与查询时间效率.考虑到压缩算法性能对系统性能的影响,下一步的工作将在此基础上,考虑采用性能更优的压缩算法对倒排列表进行编码,进而提高系统的时空性能;并研究高效的索引动态更新机制.致谢衷心地感谢审稿专家与同行富有建设性的意见和建议,感谢武汉大学软件工程国家重点实验室数据库新技术研究小组老师和同学们的大力支持和帮助!
