Page1基于连续模型和动力学仿真模型的高密度人群仿真算法孙立博孙晓峰秦文虎(东南大学仪器科学与工程学院南京210096)摘要为了真实模拟高密度下的人群运动,文中提出了一种将人群运动连续模型和人群动力学仿真模型相结合的高密度人群仿真算法.该方法首先将人群假设为连续的流体,并进行密度场的转化;然后通过计算最大速度场和单位消耗场,建立全局的动态势能场,并根据势能场的梯度得到期望的全局速度场;接着利用有限压缩性规则对人群的密度进行限制,通过高密度环境下产生的压力项校正速度场,从而插值更新人群位置,并对更新后的人群做最小距离限制,实现网格内部个体之间的避碰;最后引入GPU加速算法实现高密度人群快速仿真.仿真结果表明,基于连续模型和动力学仿真模型的高密度人群仿真算法能够逼真地模拟向同一目标或指定目标运动、躲避动静态障碍物、人群交汇等多种场景下的人群运动,这对现实生活中交通疏散方案的制定具有一定的指导意义.关键词虚拟人群仿真;连续模型;有限压缩性规则;GPU加速1引言近年来,随着虚拟现实技术的不断发展和完善、图形硬件运算速度的快速提高,虚拟人群仿真技术越来越被人们广泛关注,逐渐成为计算机图形学及相关领域的研究热点.虚拟人群仿真技术在城市规划、影视娱乐、军事训练、疏散模拟、大型体育仿真、古遗产还原重建等领域都有着广泛的应用前景:(1)在城市规划领域,随着汽车保有量和城市人口规模的不断增加,上下班高峰期的道路拥堵问题严重困扰着人们的日常生活.通过引入虚拟人群仿真技术,根据人群的出发时间、目的地和道路的实际状况,可以为人群和通行车辆规划出拥堵少的路径,达到减少人们等待时间,保证道路基本畅通的目的.(2)在影视娱乐方面,《权力的游戏》中恢宏的军队对战场景印证了引入大规模群体动画的必要性,其不仅可以为观众带来超级震撼的视觉体验,而且可以极大地减少动画师的手工操作,并为导演进行更完美的构思提供有效途径.(3)在军事训练方面,很多特种兵的实战化训练都是比较危险的,引入群体仿真技术,不仅可以在一定程度上降低训练的危险系数、保证战士的安全,还可以提高训练效率,为全面提升我国军事力量奠定基础.(4)在疏散模拟领域,如何在紧急情况发生时,迅速将人员撤离到安全场所是人们关注的重要问题.通过引入虚拟人群仿真技术,不仅可以判断建筑物的出口数量、出口位置等设计是否合理,还可以根据人群疏散仿真的结果,为建立人群的应急疏散方案提供帮助,并在此基础上进一步验证方案的有效性和合理性.(5)在大型体育仿真方面,直接根据导演的创意进行真人彩排,不仅需要大量的人员配合,更需要花费大量的时间去验证进而修改完善编排方案.而引入虚拟人群仿真技术,就可以有效地解决上述问题,使导演在短时间内完成精彩绝伦的设计成为可能,北京奥运会惊艳全球的开幕式就是最好也是最有力的证明.(6)在古遗产还原重建方面,虽然重现古建筑原貌是人们关注的首要问题,但是将该时期的居民也包括其中,不仅可以提高场景的生动性,而且可以使人们对古建筑所反映的历史和文化有更加直观和深入的认识.目前根据不同的仿真目的,我们可以将虚拟人群仿真方法分成两类:第1类是宏观仿真方法,第2类是微观仿真方法.宏观仿真方法主要侧重于整个群体的真实性,也就是不再著重于个体,而是使人群整体的运动看起来真实即可.比较有代表性的方法包括Treuille等人[1]提出的连续人群运动模型和Narain等人[2]提出的将离散和连续表示相结合的可扩展的动力学人群仿真方法.Treuille等人将运动看成是粒子能量最小,人群按照目标的不同进行分组,并且结合全局的路径规划和局部的碰撞避免,保证人群所走的路径是最优化的.在连续人群运动模型中,Treuille等人还考虑了人群密度对速度的影响.即当人群密度较低时,人群保持最大的速度前进,而当人群密度较高时,速度会受到相应的影响,密度越高,速度越小,这会给人比较真实的感觉.另外,由于人群是按照目标是否相同进行划分的,所以一个组内的人群只做一次路径规划,这样使用的计算资源也就相应减少,从而保证人群运动是实时的.Narain等人对密集人群所表现出的聚集行为进行仿真,其使用混合方法,即将agent看成是离散个体和连续整体的统一体.在进行连续性设置时,将单一不可压缩性的动态限制条件引入到模型中,对大规模的人群行为进行建模并且对密集度较高的场景中人与人之间的碰撞避免进行加速.当人群密度较高时,由于每个个体的自由受到了周围个体的限制,因此Narain等人将人群建模成可以用密度和流速描述的连续流体,并把局部避碰映射转换到流体域,从而得到限制人群流的可变参量,这个限制量就是单一不可压缩限制(UnilateralIncompressibilityConstraint,UIC).该方法的具体实现可描述如下,其将局部规划模块和全局规划器相结合,首先通过全局规划器获得每个agent的理想速度,其次将agent的离散集合用密度和速度转换成连续表示,再次引入UIC来确定合理的速度域.所谓UIC,是根据人群的特性提出来的,当密集度较高时,人群虽然很像流体系统,但是也不完全相同.这就意味着它既不是完全不可压缩的,又不是完全可压缩的.也就是说,可以使用UIC对人群的密度加以限制,从而使其密度不可以无限制地增大,这也保证了人与人之间的距离不会过小.最后,每个agent根据真实速度进行运动,从而实现位置上的更新.微观仿真方法侧重于个体行为的真实性和多样Page3性,也就是说其对每个agent都进行行为建模,包括感知、规划、心理、性格、情感等.目的是使每个agent在对待同一事件时,能够表现出不同的反应,从而提高仿真的真实性.根据研究方式的不同,微观仿真方法又可细分为基于模型的方法和基于数据驱动的方法.基于模型的方法以社会力模型[3]、元胞自动机模型[4]和基于规则的模型[5-6]为主要代表.社会力模型以牛顿力学为基础,假设个体受到社会力的作用,其可认为是社会心理和生理的“力”的合力,从而来控制人群运动.由于社会力模型为每个个体解牛顿力学方程,将人与人之间、人与静态障碍物之间的斥力,人与目标之间的引力以及摩擦力考虑进来,并且对个体行为合理建模,因此能够真实地再现人群拥挤时的挤压力,逼真地模拟紧急状态下人群的疏散过程.元胞自动机模型将人的运动限制于离散的方格之中,方格的大小固定了人群的密度,使得人群流量不真实.而且由于其在时间和空间上都是离散的,所以用该方法仿真出来的人群运动不连续,因而缺乏真实性.基于规则的模型在人群密度较低或者中等的情况下,能够仿真出更加真实的人群运动,但是不能处理人与人之间的接触,因此无法仿真出挤压的效果.鉴于人群行为本身的多样性和复杂性,基于模型的方法大多是针对人群行为模型的某一方面展开研究的,因此近年来涌现出很多扩展模型[7-8]对其进行丰富和完善.基于数据驱动的方法主要包括运动捕获数据驱动的方法[9-10]和真实录像分析的方法[11-12].运动捕获技术可以很容易地获得很多真实人体运动的数据,因此使用这一技术生成群体动画在目前非常流行,也得到了广泛应用.但是运动捕获技术也存在一些不足,它需要对数据进行运动编辑(motionediting)、运动重定向(motionretargeting)或者使用运动图(motiongraph)等技术自动生成相似动作间的转换从而增加了更多新的动作片段,以实现对更多种身材比例的模型进行运动控制,达到更真实模拟人群运动的目的.基于真实录像分析方法的思想是通过对真实人群的例子或者对拍摄到的真实视频中人群的运动轨迹进行观察分析,从而仿真人群行为,以达到更加真实再现实际场景的目的.该方法近来也成为研究学者关注的焦点.最近,很多采用GPU仿真人群的研究也取得了一定的成果[13].Courty等人[14]早期在快速人群的研究中就实现了GPU人群仿真的效果,与CPU相比,它的加速性能得到了显著的提高.Erra等人[15]在GeForceFX5800的GPU上实现了基于离散行为模型的大规模群体(boids)仿真.Richmond和Romano[16]提出了一种利用GPGPU实现的基于个体的行人仿真,取得了不错的效果.他们设计了一个支持GPU脚本的界面,这样就可以定义更多复杂的个体行为.为了提高仿真性能,行人的数据和仿真都放在GPU中进行,达到了减少数据传输花费的目的.同样地,他们通过GPU上的LOD系统提升了渲染和仿真性能.D’Souza和他的团队[17]在GPU上模拟了大型人群,仿真的个体数量超过了200万,并达到了每秒更新50次的效果.他们用GPU纹理存储器来保存个体的属性,然后利用GLSL来编写着色语言.Passos等人[18-19]在最近的一个研究中通过NVIDIA的CUDA技术证明了实时的大规模人群仿真是具有可行性的.他们成功地模拟了超过100万的boids,并且将帧速保持在30帧左右,效果相当于利用多核CPU模拟的15000个boids.实验结果表明基于通用并行计算的方法能极大地增强实时人群仿真的效果.Karthikeyan[20]也在他的硕士学位论文中利用CUDA技术对虚拟人群进行渲染,并对比了在GPU和CPU上的动画计算.结果表明,GPU能够比CPU节约1000个左右虚拟角色的计算.综上所述,当仿真中小规模人群时,采用微观方法能够体现个体行为的真实性、完整性和差异性,但是不管采用基于模型的仿真方法还是基于数据驱动的仿真方法,都会面临对数据的需求量较大,处理起来比较繁琐的问题或者对行为建模时考虑的因素过多而使得算法的计算复杂性增高的问题;而当仿真较大规模人群时,由于计算资源消耗增大,采用宏观方法更为合适.本文旨在模拟高密度下的人群运动过程,比较注重仿真的实时性而对个体行为的差异性不做过多要求,因此我们将采用基于连续流体模型[1]的宏观方法对人群进行仿真.考虑到人群在密度较高时,既不是完全不可压缩的,也不是完全可压缩的,为了突出人群的这一特性,本文在Treuille等人[1]提出的连续人群运动模型的基础上引入了有限压缩性规则[2],对人群的密度加以合理地限制,并引入GPU加速算法提高仿真速度,从而比较真实地模拟了各种场景下的人群运动.本文第2节阐述基于连续模型和动力学仿真模型的高密度人群仿真算法的总体框架、局部人群密度的定义以及各算法的具体步骤;第3节介绍人群仿真算法在GPU上的扩展;第4节通过多组仿真实验,对提出的算法进行验证,并对仿真结果进行详Page4细的分析;第5节比较并分析本文提出的算法和已有的虚拟人群宏观仿真方法;第6节总结全文.2基于连续模型和动力学仿真模型的高密度人群仿真算法2.1高密度人群仿真算法框架通过对体育馆离场时高密度人群的运动观察发现,人群在向各出口运动的过程中,个体的自由度会由于附近人群的限制而大大降低,这与流体运动非常相似.因此,本文将人群看作一组连续的个体,通过密度和流动速度来表示它们的特性;而随着人群密度的增加,会出现个体之间发生碰撞的现象,故本文将局部避碰方法引入连续场中,以更好地控制人群的行为.本文提出的高密度人群仿真算法的总体框架如图1所示:在每一个时间步长,首先将离散的人群转化成基于密度场(densityfield)和速度场(speedfield)的连续表示方法,然后在局部避碰方法中利用有限压缩性规则(UnilateralIncompressibilityConstraint,UIC)对连续人群中的个体速度进行校正,并插值得到个体的实际运动速度;最后将两者结合起来,更新人群的位置,从而实现高密度人群仿真.2.2基于连续流体的全局规划算法本文采用Treuille等人[1]的方法将人群看作一组连续的个体.为了体现人群的流动特性,我们首先做4个重要的假设.假设1.人群中的每个人都试图到达一个目标G,这个目标点或目标区域对于每个人来说都是唯一的.假设2.人群会尽可能地以最大速度运动,也就是说存在一个最大速度场f使得在位置狓沿θ方向运动的行人的速度可用式(1)来表示:其中,狀θ=[cosθ,sinθ]T表示指向方向θ的单位向量.当人们能够畅通无阻地移动时,他们通常会选择一些特定的路线,比如行人过马路时会走斑马线;人们会选择一条比较熟悉的路线行走,尽管该路线可能要远一些.为了体现人群的上述特性,引入不适度函数这一概念,动态的不适度可用来仿真人群之间以及人群与障碍物之间的避碰行为.假设3.存在一个不适度函数g,在其他条件相同的情况下,如果g(狓0)>g(狓),人们则会选择向狓点移动而不是向狓0点移动.一般来说,人们会选择最短路径到达目标位置.但实际上,人们会更趋向于避免拥挤堵塞和环境不好的路径(即不适度较高的区域),也就是说,人们会在选择路径时综合考虑如下3个方面的因素,力图使三者的线性组合最小化:(1)路径长度;(2)到达目标位置所需的时间;(3)沿着路径方向单位时间内的不适度.假设4.若Π是所有可行路径的合集,当速度场f,不适度g和目标位置G都确定时,行人所选择路径P∈Π的代价可以用式(2)表示:其中:第1项为路径长度的耗费,第2项为移动时间的耗费,第3项为不适度引起的耗费.α,β和γ分别为各自的权重;ds表示路径长度的积分,而dt表示时间的积分,这两个变量的关系如下:通过式(3),化简可以得到其中,C≡可以由用户根据场景进行设置.接下来进行密度场的转化,并在每一时间步长,为每一组人群计算最大速度场和单位消耗场.其中,为了保证每一组人群选择的路径都是最优路径,定义势函数,在目标点时=0;而在其他点时满足eikonal方程:其中,单位消耗场C是沿着势函数梯度方向的.根据式(5),可得到每个人在点狓(二维坐标)处的速度:Page5·表示速度;f(狓,θ)为运动方向上最大允许的其中:狓速度值.最后构建全局动态势能场,并根据势能场的梯度得到期望的全局速度场,从而驱动人群运动.鉴于建立动态势能场是整个算法中最复杂最耗时的步骤,本文将对其详细介绍.由于隐式的eikonal方程不能直接计算出来,因此需要采用有效的方法来解决.目前,有效的解决方法主要采用Rouy和Tourin[21]提出的迭代算法和Sethian[22]提出的快速行进法(FastMarchingMethod).迭代算法对每一个网格点都进行迭代更新直至其收敛为止,该方法虽然易于实现,但是由于其对每一网格点都进行访问并评估直至所有网格点收敛,因此该方法的效率不高.而快速行进法(FMM)则采用波阵面窄带的思想,通过维护堆结构选择算法1.快速行进法.输入:gridsU,网格数量num_grids,目标G势能G,图2快速行进法输出:场景的势能场Φ1.KList={UG},UList=U-UG,CList=null;2.whilelength(KList)num_grids3.forUiinUdo4.5.6.7.8.9.10.11.endif12.endfor性地更新网格点,在大小为M×N的网格上,FMM算法的时间复杂度仅为O(MNlog(MN)).鉴于FMM在速度上的优势以及其在各个领域的广泛应用,我们选择使用快速行进法来求解eikonal方程,以达到保证全局规划算法效率的目的.快速行进法的基本思想如图2所示,首先将场景中已划分好的网格存入3种列表:已知列表、未知列表和候选列表,设目标处的势能为0,并将相应的网格存入已知列表,其余的网格存入未知列表,势能设为;然后将与已知列表中网格相邻的未知网格存入候选列表,并通过方程的有限差分法估计候选列表中各网格的势能;最后将势能最小的候选网格存入已知列表,再根据更新后的已知列表确定相应的候选列表,并计算候选列表的势能;重复这些过程,直到将所有的网格都存入已知列表,候选列表为空为止.这样场景的势能场Φ就确定完毕了.快速行进法的实现可描述如算法1.13.forCiinCListdo14.15.endfor16.找出CList中势能最小网格Ck=argmin((Ci))17.将Ck添加到KList18.endwhile有限差分是微分方程的一种近似数值解法,该方法的基本原理是利用网格剖分将连续的定解区域用离散化网格来代替;将待解方程中的微商用各离散点上的函数的差商来近似,积分采用积分和来逼近.这样,待求的微分方程定解问题即可转化为相应的有限差分方程组问题,通过求解有限差分方程组即可获得原问题在离散点上的近似解,最后,再应用插值方法便可从离散解求得定解问题在整个场域上的近似解.通常利用有限差分法计算所采用的步骤可概括如下:Page6(1)采用一定的网格剖分方式离散化场域;(2)进行差分离散化处理,用离散的、含有限个未知数的差分方程组来近似代替场内具有连续变量的偏微分方程及其边界条件;(3)结合选定的代数方程组的解法,编写程序获得差分方程组的数值解.如图3所示,假设需要为网格M求解eikonal方程,首先要找到x轴和y轴两个方向上具有较低消耗的相邻网格单元:然后通过向后差分求解方程的有限差分近似值,其中,M满足如下关系:如果mx或者my由于邻近网格的势能都是无穷而没有定义,上述方程中就应该去掉该轴项.在计算得到M后,即可通过其与相邻网格的势差求得梯度,并可进一步地根据梯度求得该点的速度场狏,而在使用局部避碰算法对速度狏进行校正之后,就可以通过对速度场的插值来更新每一个人的位置.鉴于计算动态势能场需要遍历场景的每一个网格,当场景面积比较大、划分的网格数比较多时,运算量就会变得非常庞大,直接影响全局规划算法的运行效率,而考虑到人群有可能只集中到某一区域,在其他区域分布较少,本文首先采用AABB轴向包围盒法(如图4所示)来确定人群的分布范围,然后只对位于包围盒内部的网格执行密度场和速度场的更新,而对于没有人群分布的网格(区域A、区域B和区域C)不再进行密度场和速度场的计算,这样就可以在一定程度上降低全局规划算法的计算复杂性,以保证算法的实时性.2.3基于UIC的局部避碰算法在进行2.2节的处理后,我们可以将人群看作带有密度和流动速度的连续流体,理论上在该模型中不会出现两个人相交的现象;当两个人互相靠近时,密度会变得非常高,速度方程完全由平均速度项决定,这样他们之间的相对速度就会降为零.但实际上,该方法只能解决网格之间的人群相交问题,对于在同一网格内的两个人可能发生碰撞的问题并不能很好地解决,因此该方法只适合仿真中密度人群.当人群密度非常高时,场景所划分的一个网格单元中就包含了很多人,这时需要将局部避碰算法引入到连续场中,从而获得一些变量的约束条件.本文结合Narain等人[2]的方法,将一种可以与基于流体的全局规划算法相结合的基于UIC的局部避碰算法引入进来,从而实现大规模人群的仿真.有限压缩性规则(UIC)在宏观上能够保证个体之间不发生碰撞.首先,我们对全局场进行设置,用连续密度场和速度场来表示人群的状态和运动.这是一个类似于流体的系统,但是,其与物理流体又不完全相同.它既不是完全可压缩的,因为人群不能被无限度地压缩;也不是完全不可压缩的,因为人群可以轻易地聚集或分散从而改变密度.因此,可以将两者结合起来,把人群看做一种单向不可压缩的流体,也就是说可直接对人群的密度设置约束条件,防止其超过最大密度值ρM.假设个体之间距离小到一定值后就不会再靠近,该距离即为人与人之间的最小距离,用dmin表示,据此可以给出人群密度ρM为UIC限制规则:Page7其中:ρM之间相互接近的程度.根据人群模型的连续性,密度ρ和速度狏满足连续方程:为了确保满足UIC限制,我们需对期望速度狏~进行校正,使得密度ρ保持在合适的范围内,最终的校正速度狏在某种程度上接近期望速度狏~并能维持UIC限制条件,具体方法见文献[2].假设人群都尽量以最大的速度向他们期望的方向运动,同时还要避免碰撞,那么校正速度狏的选择旨在使积分∫ρ狏·狏~最大化,当然还要满足最大运动速度狏vmax的限制.根据上述条件,可以得到校正速度狏的最佳形式:其中,“压力”p满足如下条件:在式(12)、(13)中,p表示人群流中存在一个非负压力项,其用来防止人群聚集导致密度高于最大值ρM.在压力p的影响下,个体会加强对速度的校正,以获得最大允许速度vmax.式(12)也可以如式(14)表示:直观地说,压力只有在密度取最大值的时候才出现;当密度小于最大值时,个体不会很密集,相互之间所造成的影响比较小,人群可以比较自由地流动.使用UIC规则只能确保个体之间在整体上保持运动速度与方向的一致性,为了达到更好的效果,我们需要在每对独立个体之间执行最小距离规则,即查找出每对距离小于一定值的个体,将他们均匀地分开.执行最小距离规则的算法过程如图5所示.2.4算法流程如图6所示,将全局规划与局部避碰相结合,总结人群仿真算法的实现步骤如下:(1)在每个时间步长的开始,已知每个个体的位置狓i,根据人群分布计算AABB包围盒从而确定网格更新范围;(2)执行全局规划算法,将离散的人群转化为密度场表示;(3)对每组人群,构建相应的单位消耗场,并计算动态势能场及其梯度,从而计算速度场;(4)利用基于UIC的局部避碰算法,计算校正速度场;(5)获得每个个体的实际速度,并进行下一时间步长位置的更新;(6)最后,对更新的位置执行两两最小距离限制,从而避免个体之间的碰撞.3人群仿真算法在GPU上的扩展本文采用的全局规划算法是基于连续流体的方法,这种基于空间网格计算的方法特别适合模拟大量个体.整个环境由一个消耗函数来表示,该函数通过eikonal方程来计算从任何位置到目标位置的剩余势能.沿着这个势能场的梯度前进,就能确保人群沿着最短路径向目的地移动.虽然该方法为每一组人群只规划一次路线,能够节约计算资源,但是其在每一步都进行密度场和速度场的计算,运算量还是很大的,当人群数目不断增多时,还是会影响算法的实时性.因此,本节将高Page8图6基于连续流体模型和动力学仿真模型的密度人群仿真算法在GPU[23]上进行扩展,从而进一步提高算法的效率.3.1基于GPU的快速迭代法在2.2节提到的所谓eikonal方程,是一个非线性的偏微分方程,可以表示如下:H(狓,狓)=(狓)2-其中:Ω表示所在的n维空间;(狓)表示到目标点所需要经历的时间或者距离,而f(x)表示速度函数.在2.2节中,我们所采用的解eikonal方程的方法是快速行进法,但是该方法并不适合于并行处理,这就会影响算法的运行效率.本节为了提高人群仿真算法的实时性,采用快速迭代法[24-25]在GPU架构中求解eikonal方程.这里首先介绍GPU架构,以便更好地阐述快速迭代法的特点.CUDA是由著名显卡厂商NVIDIA公司提出的一种基于GPU通用并行计算的架构①,它利用GPU的处理能力,通过并行计算来大幅提升计算性能.在CUDA推出之前,GPU的并行计算一直受限于图形API的着色模型,只有符合顶点着色器和片元着色器属性的问题才能利用GPU去并行处理.为了让GPU并行计算变得更加简单实用,NVIDIA公司以C语言为基础,对其架构进行了一些扩展和两项改进,让开发者能够根据CPU和GPU的架构分配代码和数据.在支持CUDA的GPU架构下,一个程序可以分成两个部分:主机端(host)和设备端(device).在CPU上运行的部分即为主机端,而在GPU上运行的部分即为设备端,设备端又可被称为“Kernel(内核函数)”.通常显卡内存中的数据由主机端程序复制提供,经由GPU执行Kernel对数据处理完成后,再由主机端程序将其取回.以并行计算为核心思想的CUDA技术将GPU视为一个协处理器,通过对线程(Thread)这一基本单元的分配和管理来实现并行计算,其中,线程内部的代码按顺序执行,而各线程之间的代码按并行执行.共享同一存储空间协助完成计算的多个线程组成一个线程块(ThreadBlock),大小相同且相互独立的一组线程块可构成一个Kernel,其中,各线程块也按并行执行.CUDA执行时,将Kernel函数设计成可并行处理的数据,并由主机端发送到GPU上的Grid(网格)上执行,其中,每个Grid由若干个Block组成,而每个Block又可以执行多个线程.CUDA架构的基本原理如图7所示.区别于传统的GPU顺序处理流程“顶点处理器操作顶点属性变量———片元处理器处理片元及相关数据———像素操作输出结果”,支持CUDA的GPU引入了流式多处理器(SM),大大提高了CUDA的并行计算能力,例如,GTX295中包含了60个SM,每个SM中又包含8个流处理器(SP),每个SP处理执行一个线程,一个Block单元必须分配到同一个SM中,它是一种单指令多数据(SIMD)的执行方式.这种执行方式是CUDA高速运算的基础,同时由于SM还拥有片内共享存储器,因此可降低片外访问延迟.快速迭代法是Jeong等人[24]通过对Rouy等人[21]提出的迭代算法和Sethian[22]提出的快速行进①NVIDIACorporation.NVIDIACUDAComputeUnifiedPage9图7CUDA架构基本原理图法(FMM)进行分析而开发出来的求解eikonal方程的方法.快速迭代法整体运算性能好,适合并行扩展,主要具有如下特点:(1)算法不设置特定的更新顺序;(2)算法不需要另外使用一个数据结构来进行分类排序;(3)算法能够同时更新多个网格点.与快速行进法不同,快速迭代法(FastIterativeMethod)不需要建立一个复杂的数据结构来保存所有网格的信息,而是通过建立一个激活列表来保存需要被更新的网格点.每次迭代,都对激活列表进行扩展,并同时更新所有受影响的网格点.本文通过逆向差分方法求解当前网格势能的局部近似值,当势能收敛时就将该网格点从激活列表中移除.势能收敛的判断方法为计算当前势能值与之前势能估计值的差,判断其是否在固定的阀值ε内.与快速行进法类似,采用Godunov逆向差分方法,通过式(16)来估算该网格的势能值:[(Ui,j-U其中:UUi,j+1),(x)+=max(x,0),Uij表示网格(i,j)处势能的离散估计值.3.2快速迭代法的流程与实现快速迭代法包括以下两个部分:(1)初始化.设置网格的边界条件和初始值,将目标网格的每一相邻网格加入激活列表L,而将其他网格点的值设为;(2)更新.对激活列表L中的每个网格x∈L,根据式(16)计算新的势能值Ux,并与原来的值进行比较以判断其是否收敛;若收敛,则将该网格所有不在激活列表L中并且未收敛的相邻网格加入到激活列表L中,然后将该网格从激活列表L中移除;为了保证新加入激活列表L的网格能够在下一次迭代中得到更新,本文使用双向链表来表示激活列表L.重复更新步骤,直到激活列表L为空.快速迭代法中的更新算法可用伪代码形式描述,具体步骤请参见算法2.算法2.更新算法Update(X).输入:网格集合X,激活列表L输出:各网格收敛的势能值1.Initialization(X:gridpoints,L:activelist):2.foreachxinXdoPage103.ifxissource4.5.6.end7.foreachxinXdo8.ifanyneighborofxissource9.10.end11.UpdategridpointsinL:12.whileLisnotempty13.foreachxinLdo14.15.16.17.18.19.20.21.22.23.24.图8快速迭代法(1)当特征路径的方向与窄带推进的方向之间的夹角小于45°时,与快速扫描法[26]的原理类似,只进行一次更新,激活列表中网格的势能值就不再改变,也就是说,更新一次后,激活列表中网格的势能值已收敛,窄带可向其一阶邻居网格推进;(2)当特征路径的方向与窄带推进的方向之间的夹角大于45°时,对于特征路径的方向发生改变的网格,其势能值起初会由于使用错误的迎风相邻网格计算而导致需要在后续的迭代中对其进行修正,因此,该网格不会从激活列表中移除直到其更新至正确的势能值.也就是说,即使特征路径的方向改变使得窄带范围增大,波前扩展将势能值本已收敛25.26.27.28.29.30.end31.end图8显示了快速迭代法的二维迭代过程.左下角的网格为起始点,黑色网格表示已计算过势能的网格,灰色网格表示处于激活列表中的网格,黑色箭头表示窄带的推进方向.图8(a)是初始状态,图8(b)是第1次更新后的状态,图8(c)是第2次更新后的状态.灰色网格的势能值只能由相邻的黑色网格决定,因此激活列表中所有的灰色网格都能同时进行势能值的更新.快速迭代法虽然为迭代算法,即会一直更新激活列表中的网格直到其收敛为止.但在大多数情况下,网格只需要迭代一次就能获得收敛的势能值.为了更清晰地说明该现象,本文进行如下分析:首先,定义特征路径为从某一网格到另一网格的最优轨迹;然后根据特征路径与窄带推进的方向夹角,从两方面进行讨论.的网格重新放入激活列表中,也会由于新信息的扩展而计算得出该网格正确的势能值.因此,即便在最坏的情况下,快速迭代法的性能也是次优的.Jeong通过实验表明:快速迭代法的运行时间一般仅为快速行进法的一半.4仿真结果本文的硬件实验平台为一台PC电脑,CPU为Core双核E8400,主频为3.0GHz,内存为4GB,显卡为NVIDIAGeforce9800GT.本文设计的全部实验场景主要采用Unity3D引擎搭建,算法由C#语Page11言加以实现.在本文实现的全局规划算法中,为了计算单位消耗场,我们设定路径长度、时间和不适度的权值分别为α=1、β=1、γ=1.本文构建的高密度虚拟人群仿真界面如图9所示,用户在进入每个场景之前,可以对人群参数进行图9主菜单与人群设置界面图10显示了单组人群向同一目标点行进的过程,其中,用户设置的人群数量为12人,个体半径为0.15m,最小距离为0.4m,最大速度为1.2m/s;根据场景的大小和人群的数量,用户将场景划分为14×10的网格.图10(a)显示了人群的初始状态,即将人群的初始位置和目标点(显示为黑色立方体)设置完成,并在初始位置绘制人群,显示为白色圆柱体;在图10(b)中,人群聚集到一起并向同一目标点图10单组人群向同一目标运动(右侧黑色立方体为目标位置)设置,主要包括虚拟人群的数量,个体的半径,个体之间的最小距离,个体的最大运动速度;同时也可以对场景网格进行设置,包括网格的单位长度和X轴、Y轴方向的网格数.设置完成之后,用户可以根据自己的意愿,模拟不同场景下、不同数量的虚拟人群运动.运动,在运动的过程中个体之间没有发生碰撞;图10(c)显示了人群即将到达目标点的情形,这里有必要强调的是为了防止人群最后全部集中在目标点上,本文允许先到达目标点的个体先行离开;与图10(b)相比,在图10(d)中,由于未使用最小距离规则限制,可以看出在同一网格的内部,个体相互重叠在一起,发生了碰撞,这与现实生活中的人群运动严重不符.Page12图11和图12为某一时刻检测到的人群密度场和速度场的分布,其中,为了更清晰地体现密度场和速度场的特性,用户同样将场景划分为14×10的网格.从图中可以看出,每个人只对其相邻网格的密度产生影响(可参见图4,相邻网格在二维平面中即指其上、下、左、右4个网格),而对其他网格密度的影图11某一时刻的人群密度场图12某一时刻x轴方向的速度场图13显示了两组人群在无障碍物的场景中交汇的情形,其中,为了便于区分,将一组人群显示为白色,而将另一组人群显示为黑色,每组人群的数目均为120人.在图13(a)中,两组人群由初始位置分别向对方所在的位置,也就是其目标点运动;在图13(b)中,每组人群以尽可能大的速度运动;当发现自己即将与对面的人群发生碰撞导致不适度升高时,两组人群会重新计算密度场和最大速度场,从而改变运动方向来避免碰撞的发生,如图13(c)、(d)所示;在成功避免碰撞后,两组人群重新以最大速度向目标点前进,如图13(e)所示;最终,两组人群成功到达目标点,如图13(f)所示.图14显示了虚拟人群及其所在场景的三维效果图,其中,静态障碍物用正方体表示,4组人群用圆柱体表示.每组人群数量均为25人,拥有相同的目标.图15显示了4组人群在有障碍物的场景中交汇的二维效果图,其中,4组人群用不同灰度区别.图15(a)显示了4组人群的初始状态,即每组人群都在初始位置准备向各自的目标点———对角线位置运动;在图15(b)中,4组人群分别以最大速度向目响可忽略不计.进一步地,速度场是在计算动态势能场及其梯度后,根据式(7)计算得到的,速度场受到人群密度场的影响,即在低密度区域,速度在平面上保持常量;而在高密度区域,速度则取决于附近人群的流动,即逆流时速度会受到抑制,而顺流时则无影响.标点运动;在图15(c)、(d)中,当靠近静态障碍物时,由于不适度升高,4组人群在重算速度场后,采用改变运动方向的方式成功躲避静态障碍物;图15(e)和(f)显示了4组人群交汇的过程,为了保证人群之间不发生碰撞,本文在每一时间步都计算密度场,构建单位消耗场,从而计算速度场,并采用UIC规则对速度场进行校正;图15(g)显示了4组人群成功避碰后,继续向目标点运动的过程;图15(h)显示了4组人群最终顺利到达目标点的情形.从以上的仿真过程可以看出,本文采用的基于连续流体模型和动力学仿真模型的高密度人群仿真算法能够很好地完成对同一目标、指定目标、躲避障碍物、多组人群交汇等不同情况的模拟,适用于仿真各种人群的运动场景;同时由于引入UIC限制条件和使用最小距离规则,算法能够很好地仿真个体之间的避碰行为;进一步地,本文提出的高密度人群仿真算法还允许用户对人群参数和场景参数进行设置,也就是说,虚拟人群既可以自主运动,也可以根据用户的意愿进行运动.因此,本文提出的虚拟人群仿真算法适合于模拟高密度环境下的人群运动.Page13图13两组人群的交汇过程Page14图144组人群交汇的三维场景如图16所示,Unity3D引擎能够实时地检测场景的一些状态,包括帧数、占用的线程数、内存以及纹理等信息.实验中的所有个体都由Unity内部提供的三维圆柱体表示,势必会占用一定的资源,而且算法整体上计算量非常庞大,从表1即可看出,当人数增加至200人时,算法的运行效率急剧下降,帧速仅有1.8fps,难以达到实时的效果.引入GPU加速算法后,由于GPU采用高度并行化的SIMD多处理器架构,同一指令可由多个流处理器的执行单元同时执行,因此,与在CPU上执行的快速行进法(FMM)相比,在GPU上执行的快速迭代法(FIM)速度提高了很多,从表2即可看出,网格数为32×32,原本需要70ms的计算缩短到13.6ms就能解决,而网格数为256×256,原本需要140ms的计算缩短到18.3ms就能解决,加速效果非常明显,因此,本文对高密度人群仿真算法在GPU上所进行的扩展,确实为提高人群仿真的实时性做出了贡献.表2快速行进法与快速迭代法在不同场景下的运行时间场景网格数16×1632×3264×64256×2565比较与讨论目前,已有很多工作对虚拟人群进行仿真,包括宏观仿真方法和微观仿真方法.而宏观仿真方法尤以Treuille等人提出的连续流体模型和Narain等人提出的动力学仿真模型最具代表性.本文提出的高密度人群仿真算法属宏观仿真方法的范畴,该方法结合了连续流体模型和动力学仿真模型的优点,即在保证人群运动真实、合理、自然的同时,还考虑了人群在高密度情况下体现的既不是完全可压缩的、也不是完全不可压缩的特征.下面通过表3对本文提出的高密度人群仿真算法与连续流体模型及动力学仿真模型进行比较和分析.在避免路径拥堵及陷入死锁方面,全局规划算法具有绝对的优势,动力学仿真模型由于主要侧重局部避碰,对此考虑较少,只使用简单的路线图方法作为全局规划器,虽然也能完成规划任务,但是在预测路径拥堵、防止路径陷入局部最优或者死锁方面尚有不足;而对于人群数目不断增多,人群密度却不能无限制地升高的问题,连续流体模型并没有考虑.本文提出的方法结合了全局规划算法和基于UIC的局部避碰方法的优势,虽然每一时间步都进行密度场和速度场的更新,使得计算量较大,运行效率下降,实时性难以保证,但是在引入局部人群密度概念和GPU加速以后,算法的实时性得到提高,从表3即可看出,同样是对2000人进行仿真,连续流体模型在引入单独的并行绘制线程后,帧速为24fps;动力学仿真模型由于仅关注个体之间的局部避碰,因Page15图154组人群交汇的仿真过程Page16图16场景实时状态表3虚拟人群宏观仿真方法对比无有,使用UIC规则有,使用UIC规则Treuille等人提出的连续流体模型Narain等人提出的动力学仿真模型我们的高密度人群仿真算法此运行效率较高,帧速为62fps;而本文提出的算法帧速为28fps,也就是说,在引入AABB轴向包围盒确定人群的分布范围后,就不需要对没有人群分布的网格进行密度场和速度场的计算,这在一定程度上节省了计算资源;而且,将全局规划算法在GPU架构上进行扩展后,也使得实时性不再成为制约本文提出的高密度人群仿真算法的瓶颈.另外,在用户交互控制方面,连续流体模型允许用户创建移动的障碍物来达到调整不适度从而验证仿真人群对动态环境反应性的目的;动力学仿真模型对此方面没有考虑;而本文算法允许用户设置人群的数量,个体的半径,个体之间的最小距离,个体的最大运动速度以及场景的网格数目,即在交互控制方面给予用户足够的自由度,以达到仿真各种场景下不同规模人群运动的目的.6结论本文提出了一种基于连续流体模型和动力学仿真模型的高密度人群仿真算法.首先,本文实现了基于连续流体模型的全局规划算法,通过4个重要的假设,根据人群初始位置和目的地求出人群的密度场以及最大速度场,从而构建单位消耗场,再根据动态势能场及其梯度计算速度场.其次,引入基于UIC限制规则的局部避碰算法,通过对密度的控制来校正速度值.然后,将全局规划和局部避碰相结合,即利用校正得到的速度值更新人群的位置,最后再利用最小距离限制保证网格内部的个体之间不发生碰撞,从而实现适用于高密度情况的人群仿真算法.通过多组实验对本文提出的高密度人群仿真算法进行验证,结果表明该算法能够模拟各种场景下的人群运动,仿真效果良好.考虑到在人数较多的情况下,整体计算量比较庞大,算法的运行效率下降,难以达到实时的效果,本文又进一步对高密度人群仿真中的全局规划算法在GPU上进行了扩展,达到了加速的目的,有效地提高了算法的实时性.在高密度虚拟人群仿真中,如何在保证速度的同时,突显人群中每个个体行为的社会性和智能性,一直都是研究的热点问题,希望在下一步工作中能够对该方面进行更深入的研究.一种值得尝试的方案是与微观仿真方法相结合,通过模拟个体的心理、性格以及情感因素,更逼真地反映人群的各种特性.Page17
