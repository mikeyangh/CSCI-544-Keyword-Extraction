Page1能量高效的无线传感器网络空间范围查询处理算法刘亮秦小麟郑桂能李博涵(南京航空航天大学信息科学与技术学院南京210016)摘要现有无线传感器网络空间范围查询处理算法能量消耗大且当节点失效时查询处理过程易被中断,无法返回查询结果.文中提出了一种能量高效的算法ESA(Energy-efficientSpatialwindowqueryprocessingAlgorithm).它将查询区域划分为若干个网格,每个网格中有一个簇头节点负责收集所在网格中其它节点的感知数据,对这些数据进行聚集运算得到部分查询结果,并将其发送至下一个网格的簇头节点,直至收集到查询区域内所有节点的感知数据,以生成最终的查询结果.ESA算法只需查询区域内的节点发送一次数据消息,减少了发送的数据消息数目.根据ESA的能耗公式给出了两种网格划分和簇头节点选择算法,以降低算法分发查询消息消耗的能量.设计了一种利用节点冗余保证查询处理过程鲁棒性的算法,避免了ESA因节点失效而中断.提出了两种感知数据收集算法,以减少簇头节点收集其邻居节点感知数据的能耗.最后,对ESA算法和现有的IWQE算法(Itinerary-basedWindowQueryExecution)的性能进行了系统的理论和实验分析.分析结果表明:在绝大多数情况下,ESA算法在能量消耗、查询成功率和查询结果质量方面优于IWQE算法.关键词物联网;无线传感器网络;查询处理;空间范围查询;能量高效;容忍节点失效1引言无线传感器网络作为物联网的重要组成部分,在灾害搜救、环境监测、医疗卫生、智能家居等领域有着广阔的应用前景,是当前信息技术领域的一个研究热点.在许多传感器网络应用中,用户经常提交空间范围查询[1]以获得网络覆盖范围内某局部区域的信息,如当前时刻某区域核辐射最大值、受困人员数目、海洋某区域的平均温度等.考虑到传感器节点的能量通常由电池供应十分有限,且受传感器网络规模、工作环境等因素的制约,难以为节点补充能量.因此,能量高效的空间范围查询处理是目前迫切需要解决的问题.针对传感器网络环境下的空间范围查询,现有基于树的算法[2-12]依赖于预先构造的树形网络拓扑.由于受周围环境和节点移动的影响,传感器网络拓扑结构频繁发生变化,导致维护树形网络拓扑的代价太大.现有基于路线的算法IWQE[1](Itinerary-basedWindowQueryExecution)沿一条或多条根据网络拓扑动态生成的路线收集查询区域内节点的感知数据,有效地降低了网络拓扑变化对查询处理的影响,但该算法还存在如下问题:(1)能量消耗较大;(2)节点失效时查询结果全部丢失;(3)当查询区域内存在不包含节点的子区域时,无法得到正确的查询结果.针对这些问题,本文提出了一种能量高效的传感器网络空间范围查询处理算法ESA(Energy-effi-cientSpatialwindowqueryprocessingAlgorithm).在查询处理过程中,ESA根据网络拓扑将查询区域划分为一系列网格,在每个网格中挑选出一个簇头节点用于收集网格中其它节点的感知数据,对收集到的数据集合进行聚集运算(如求最大值、求和等),然后将聚集后生成的部分查询结果发送至下一个网格的簇头节点,如此继续,直至到达最后一个网格,该网格的簇头节点生成最终的查询结果,将其返回至基站.本文提出了两种网格划分和簇头节点选择算法,以减少分发查询消息的能耗;提出了两种分别用于稳定网络和不稳定网络的感知数据收集算法,以减少簇头节点收集其邻居节点感知数据的能耗.为了降低算法因节点失效而中断的概率,本文设计了一种利用节点冗余恢复查询处理过程的算法.理论和实验结果表明:在绝大多数情况下,ESA算法优于现有的IWQE算法.相比现有的算法,ESA算法具有如下优点:查询区域内的所有节点只需发送一次数据消息,减少了发送的数据消息数目.当节点失效时,ESA算法利用备份节点恢复查询处理过程,提高了算法的鲁棒性.当查询区域中的某个子区域不存在节点时,ESA利用位置路由协议绕过该子区域,消除了空洞区域对查询处理的影响.ESA仅要求节点维护其邻居节点位置信息,根据该信息动态地进行网格划分和选择网格的簇头节点,避免了网络拓扑变化对查询处理的影响.本文第2节介绍相关工作和背景知识,并分析现有算法存在的问题;第3节首先通过一个示例阐述本文提出的算法ESA的思想和优势,然后给出ESA的能量消耗公式,并对ESA中的关键问题———网格大小设置、网格簇头节点的选择策略等进行研究,并对ESA算法和现有的IWQE算法的能耗进行理论分析;第4节通过实验对ESA和IWQE算法进行比较;第5节总结全文并给出未来的研究方向.2相关工作现有空间范围查询处理算法可以分为两类.(1)基于树的算法.文献[2]提出了TAG(TinyAggregationserviceforad-hocsensornetworks)算法.它通过消息泛洪协议将查询消息发送到网络中的所有节点,组织这些节点成一棵以基站为根的树.满足查询条件的节点将感知数据发送至其父节点,Page3父节点对自己和孩子节点发送的感知数据进行聚集,将聚集运算后的结果发送到上一层节点,如此继续,直至到达基站,生成最终的查询结果.文献[3-5]将空间索引R树[13]的思想应用于TAG中,每个节点维护其孩子节点的最小边界矩形.节点收到查询消息后,仅将查询消息发送到最小边界矩形与查询区域相交的子节点,减少了分发查询消息的能耗.文献[6]提出了TAG的改进算法STWinFlood(Spatio-TemporalWindowFloodalgorithm).它包含3个阶段:①基站利用位置路由协议[14]将查询消息发送到查询区域内的查询协调节点,即距离查询区域中心最近的节点;②查询协调节点将查询消息泛洪至查询区域内的所有节点,这些节点收到查询消息后,将感知数据按查询消息泛洪过程中形成的自己到查询协调节点的最短路径返回至查询协调节点;③查询协调节点按第一阶段发现的路由将查询结果返回至基站.相比TAG,STWinFlood仅将查询消息发送到满足查询条件的节点,减少了能量的消耗.文献[7-12]研究了连续近似聚集查询,利用节点感知数据具有时间相关性减少了相似感知数据的发送.文献[15-16]利用采样技术减少参与查询处理的节点数目,通过设置合理的采样概率保证查询结果质量满足精度要求的同时尽量降低能耗.文献[17]针对当查询区域内节点非均匀分布时,现有算法的查询结果不准确,提出了三种感知数据加权算法以提高查询结果的正确性.(2)基于路线的算法.由于传感器网络拓扑结构频繁发生变化,为了保证查询结果的正确性,基于树的算法需要维护树形网络拓扑,这样带来了大量的能量消耗.针对该问题,文献[1]提出了一种基于路线的数据收集算法(Itinerary-baseddataCollectionalgorithm,用IC表示).它沿一条根据网络拓扑动态生成的路线收集查询区域内节点的数据.路线上的节点(查询节点)首先将查询消息(包含查询区域、路线、聚集函数和查询字段等信息)广播至其邻居节点(数据节点).紧接着,数据节点收到查询消息后将其感知数据发送给查询节点,最后查询节点对本地的感知数据、从上一个查询节点接收到的部分查询结果和数据节点的感知数据进行聚集运算,生成新的部分查询结果,并将其发送给下一个查询节点,如此继续直至收集到查询区域内所有节点的感知数据.以图1中的网络为例,图中两个节点之间的边表示它们能够互相通信.以S1为起点,采用IC算法计算区域ABCD最大温度的过程如图2所示.节点S1先将查询消息广播至其邻居节点,当前时刻S1的邻居节点{a,b,c,d,S2}收到查询消息后,分别将其监测的温度数据发送给节点S1.S1收到邻居节点发送的温度数据后,计算出节点集合{a,b,c,d,S1,S2}的最大温度max{a,b,c,d,S1,S2}.然后节点S1根据其当前时刻的邻居节点信息选择在查询路线方向前进距离最大的节点S2作为下一个查询节点,将max{a,b,c,d,S1,S2}的值发送至S2.值得注意的是,若此时有新的节点移动到节点S1的通信半径内且该节点在查询路线方向上的前进距离最大,则S1选择该节点作为下一个查询节点.S2收到消息后,广播查询消息至其邻居节点,S2的邻居节点{a,b,c,d,e,f,S1,S3}中未发送感知数据的节点{e,f,S3}将感知数据发送至S2,S2利用S1发送的包含max{a,b,c,d,S1,S2}的消息、邻居节点发送的感知数据可以计算出max{a,b,c,d,e,f,S1,S2,S3},并将其发送至下一个查询节点.如此继续,直至到达节点S4,S4计算出区域ABCD的最大温度.图1示例网络图2基于路线的数据收集算法对于空间范围查询,文献[1]提出了基于IC的IWQE算法(查询路线如图3所示).它首先利用位置路由协议[14]将查询消息发送至查询区域内的一个节点,然后该节点利用IC算法沿图3所示的路线收集感知数据并对查询区域内节点的感知数据进行聚集运算,计算出最终的查询结果,最后利用位置路由协议将其返回至基站.为了保证能收集到查询区域内所有节点的数据,文献[1]证明查询路线的宽度不能超过节点通信半径的槡3/2倍.另外,文献[18-20]利用IC算法处理K近邻查询,即获得距离某位置最近的K个节点的感知数据.Page4基于路线的算法根据实时的网络拓扑信息动态地形成查询路线,因而相比基于树的算法,能有效地消除网络拓扑变化对查询处理的影响.但它还存在如下问题:(1)能量消耗较大.理想情况下,查询区域中的每个节点只需发送一次数据消息.但若采用基于路线的算法,每个数据节点需要发送一次感知数据消息,而所有查询节点(除第一个查询节点外)需要发送一次感知数据消息和一次部分查询结果消息,即发送本地的感知数据至上一个查询节点和发送聚集后的部分查询结果至下一个查询节点;(2)当查询节点失效时查询结果全部丢失.如图2所示,在查询处理过程中,当查询节点(如S2、S3等)失效时,则查询结果丢失且查询处理过程无法继续进行,无法返回查询结果;(3)无法保证查询线路的连通性.在图2中,若节点e、f、S3不存在,则节点S2收集完其邻居节点的感知数据后,查询处理过程被迫中断,无法收集到节点g、h、i、j、S4的感知数据.3能量高效的传感器网络空间查询处理算法3.1假设与符号定义本文采用文献[1,18-20]相同的假设.所有传感器节点均维护其一跳邻居节点的位置信息.节点传输半径相等且为R.平均每个节点有nn个邻居节点.节点发送和接收1字节数据消耗的能量分别为Et和Er,广播一个1字节数据时,广播节点和接收节点消耗的能量之和为E.易知E=Et+nn×Er.由于无线通信的广播特性,节点单播1字节数据时网络消耗的总能量也为E.点a和b之间的距离记为fd(a,b).空间范围查询用SWQ(sw)表示,其中sw为一矩形查询区域,其宽度、高度、面积分别记为w、h和A.sw中的节点数为M.查询消息包的大小为Sq.感知数据消息、经过聚集运算后的部分查询结果和最终的查询结果消息大小均相等且为Sa.处理空间范围查询网络消耗的总能量Etotal=Ef+Ec+Eb,其中,Ef表示将查询消息发送到查询区域内的一个节点消耗的能量;Ec表示在查询区域内分发查询和收集感知数据消耗的能量;Eb表示将最终的查询结果返回基站消耗的能量.算法执行过程中发送的感知数据消息、部分查询结果消息统称为数据消息.3.2算法思想为了避免现有算法的问题,本文提出一种能量高效的空间范围查询处理算法ESA,如图4所示,ESA算法分为3个阶段:(1)利用位置路由协议将查询消息发送至查询区域内的一个节点.本文称该节点为查询区域起始节点,如图4中的节点a.(2)从查询区域起始节点开始,根据实时的网络状态将查询区域划分为若干个网格.每个网格中有一个簇头节点cg负责收集所在网格g中其它节点的数据,根据其邻居节点位置信息计算下一个网格gn的大小及下一个网格的簇头节点cgn,并将查询消息和经过聚集运算后生成的部分查询结果广播至簇头节点cgn.网格大小和网格簇头节点满足以下约束条件:ESA约束条件:网格gn中的所有节点均在簇头节点cg的通信半径内,且网格gn中除簇头节点cgn之外的所有节点均能与cgn通信.由于无线通信的广播特性,cgn收到cg发送的部分查询结果和查询消息的同时,gn中的所有节点均能收到该消息.gn中的节点收到cg发送的查询消息后,依次广播其感知数据至cgn.cgn收到gn中节点发送的感知数据后,根据cg发送的部分查询结果、gn中节点发送的感知数据和cgn本地的感知数据,生成新的部分查询结果,并将该部分查询结果和查询消息广播至下一个网格的簇头节点.如此继续,直到遍历完查询区域内的所有节点,计算出最终的查询结果.(3)查询区域最后一个网格的簇头节点利用位置路由协议将第二阶段生成的最终查询结果返回至基站.Page5对于图1中的网络,以S1为起点,采用ESA算法计算区域ABCD(其宽度小于节点间通信半径)最大温度的过程如图5所示.由于节点集合{a,b,c,d,S2}均在节点S1的通信半径内,且S2在{a,b,c,d}的通信半径内.节点S1选择其邻居节点S2作为簇头节点收集网格ABEF中节点的数据.它先将查询消息和它的温度数据广播至其邻居节点S2,由于无线通信的广播特性,节点a、b、c、d均能接收到该消息.邻居节点{a,b,c,d}收到查询消息后分别将其感知的温度数据广播给节点S2.S2收到邻居节点{a,b,c,d}和S1发送的温度数据后,计算出到网格ABEF为止的部分查询结果,即节点集合{a,b,c,d,S1,S2}的最大温度max{a,b,c,d,S1,S2}.由于{e,f,S3}均能收到S2发送的消息且S3在{e,f}的通信半径内,节点S2选择S3收集网格EFGH中的数据.S2将查询消息和max{a,b,c,d,S1,S2}的值广播至S3.节点{e,f}均能收到该消息包.它们收到消息后,将温度数据发送至S3,S3利用S2发送的包含max{a,b,c,d,S1,S2}的消息、{e,f}发送的温度数据可以计算出到网格EFGH为止的部分查询结果max{a,b,c,d,e,f,S1,S2,S3},并将其广播至下一个簇头节点.如此继续,直至到达节点i,i计算出区域ABCD的最大温度.在上述例子中,为了计算区域ABCD的最大温度,ESA算法需要发送4个查询消息和13个数据消息(包含感知数据消息和部分查询结果消息),而基于路线的算法需要发送4个查询消息和16个数据消息.可见,ESA减少了发送的数据消息数目,从而降低了能量的消耗.本文将在3.4节对两种算法的能量消耗进行理论分析.由于受到节点软硬件故障、节点能量不足、节点休眠等因素的影响,传感器节点失效频繁发生.ESA算法利用无线通信的广播特性,以避免节点失效对查询处理的影响.如图5所示,在S2收集网格ABEF的感知数据过程中,由于节点{a,b,c,S1}均在彼此的通信半径内,根据无线通信的广播特性,节点{a,b,c,S1}均能分别计算出网格ABKL的部分查询结果max{a,b,c,S1}.以节点a为例,节点S1、b、c发送感知数据至节点S2时,节点a能监听到这些信息.节点a根据这些接收到的感知数据能计算出网格ABKL的部分查询结果max{a,b,c,S1}.当查询处理过程中节点S2失效时,可以从这些节点恢复执行,继续收集区域KLCD中的数据.同理,当节点S4失效时,节点g和h可以作为节点S4的备份节点继续查询处理过程.可见,相比IWQE算法,ESA算法利用节点冗余恢复查询处理过程,降低了算法因节点失效而中断的概率.另外,当查询区域中的某子区域不存在节点时,ESA算法利用位置路由协议绕过该子区域继续执行.如图6所示,fd(S2,G)和fd(S2,K)的大小为节点的通信半径且fd(E,G)<fd(F,K).由于节点S2在区域EFGK中没有邻居节点,区域EFGK成为“空洞区域”,查询处理无法继续进行.为了避免该问题,本文采取如下方法:S2收集完网格ABEF中节点的感知数据后,以网格GHIJ的中心为目的位置(其中fd(G,J)的大小为节点的通信半径),利用位置路由协议将部分查询结果和查询消息发送至网格GHIJ中的节点以绕开“空洞区域”.在图6中,图5利用ESA算法计算区域图6绕过不存在节点的ABCD的最大温度示意区域示意Page6以网格GHIJ的中心为目的位置,部分查询结果和查询消息通过位置路由协议发送至网格GHIJ中的节点f后,从节点f开始继续查询处理过程.3.3算法设计下面首先对ESA算法的能耗公式进行推导,然后根据该公式给出降低ESA能耗的方法,最后基于该方法优化ESA算法的参数设置.假设ESA算法将查询区域划分为Ng个网格gi(1iNg),在网格gi中的节点集合记为nsi(1iNg),对应的簇头节点记为ci(1iNg).ESA约束条件可以形式化为fd(n,ci)R,n∈nsi-ci,1iNgfd(ci-1,n)R,n∈nsi,2iNg(1)由ESA算法的执行过程可知,查询区域起始节点需要发送一次查询消息给c1.所有簇头节点(除最后一个簇头节点外)需将部分查询结果和查询消息发送至其下一个簇头节点.查询区域内除簇头节点之外的节点均需将感知数据发送至簇头节点.因此,ESA算法在查询区域内分发查询和收集感知数据消耗的能量为Ec(ESA)=SqE+(Ng-1)SqE+化简后,可以得到可以看出,其能量消耗由两部分组成:(1)发送数据消息带来的能耗,即查询区域内的非簇头节点将感知数据发送至其所在网格的簇头节点;簇头节点将部分查询结果发送至下一个簇头节点.(2)发送查询消息带来的能耗.即查询区域起始节点发送一次查询消息至第一个簇头节点,查询区域内每个簇头节点(最后一个簇头节点除外)发送一次查询消息至其下一个簇头节点.为了计算精确的查询结果,理论上查询区域内的所有节点(生成最终查询结果的节点除外)均需至少发送一次感知数据消息或部分查询结果消息.因而根据式(3)可知,ESA算法发送数据消息的能耗无法降低.因此,为了减少ESA算法的能量消耗,应在满足ESA约束条件的前提下尽量降低发送查询消息带来的能耗,即减少簇头节点的数目.显然,簇头节点的数目与网格的大小、网格簇头节点选择策略有关.为了求出Ng的最优解,需要收集查询区域内节点的拓扑信息,这会带来大量的能量消耗.另外,即使能获得这些信息,受节点移动、周围环境等因素的影响,网络拓扑结构频繁发生变化,求出的Ng最优解变得毫无意义.基于上述分析,本文采用如下方法:在查询处理过程中,网格簇头节点根据其所有邻居节点当前的位置,动态地选择下一个网格的簇头节点和计算下一个网格的大小.考虑到Ng=A/Ag,其中Ag表示网格的平均面积,由式(3)可知,Ag越大,则Ec(ESA)越小.因此,在满足ESA约束条件的前提下,使得每个网格gi(1iNg)的面积尽可能大,可以增大Ag,从而降低算法的能量消耗.算法1.GBA.输入:簇头节点c,Nc输出:c的下一个网格的高度h,1.cgn=NULL;2.IFNc.size==03.h=0;RETURN;4.ENDIF5.//对Nc中的所有节点按其到线段CD的距离从小6.SNc=sort(Nc);7.cgn=SNc[1];8.i=SNc.size;9.WHILEi>110.//检查SNc[i]是否能与节点集合11.//{SNc[1],…,SNc[i-1]}中任何一个节点通信12.IFfc(SNc[i],{SNc[1],…,SNc[i-1]})is13.cgn=SNc[i];BREAK;14.ELSE15.i=i-1;CONTINUE;16.ENDIF17.ENDWHILE18.h=dist(cgn,CD).下面给出两种计算网格大小和网格簇头节点的算法:基于簇头节点前进距离的算法GBA(GridBasedAlgorithm)和基于网格面积的算法GAA(GridAreabasedAlgorithm).不失一般性,以图7中的网络为例,以c为圆心R为半径的圆与查询区域交于点P和点S.显然,区域CDPS中的节点均在网格ABCD的簇头节点c的通信半径内.区域CDPQ中的节点d、e、f均在彼此的通信半径内,节点d、f、g均能互相通信.簇头节点c在区域CDPQ中的邻居节点集合记为Nc.假设函数ns(x)返回在区域x中节点集合.函数dist(n,l)返回节点n到线段l的距离.对于节点n和节点集合s,若节点n能Page7与节点集合s中的所有节点通信,则函数fc(n,s)返回真,否则返回假.簇头节点c收集完网格ABCD中节点的数据后,继续收集区域CDEF中节点的数据.簇头节点c的下一个网格记为gn,gn的簇头节点记为cgn.c根据其邻居节点信息计算cgn和gn的高度h的方法如下:(1)网格大小和网格簇头节点计算方法①基于簇头节点前进距离的算法GBAGBA的核心思想是:对Nc中的所有节点按其到线段CD的距离从小到大排序,排序后的节点列表记为SNc.在SNc中查找节点SNc[i](其中1i|SNc|),满足条件:节点集合{SNc[1],…,SNc[i-1]}中的任意一个节点能与SNc[i]通信.簇头节点c的下一个网格的簇头节点设置为满足上述条件且i值最大的节点x.簇头节点c的下一个网格的高度设置为x到线段CD的距离.GBA算法的伪代码详见算法1.值得注意的是算法1的第2行,若Nc为空,则下一个网格的高度设置为0.此时,区域CDPQ成为空洞区域,ESA算法利用位置路由协议绕过该空洞区域.如图7所示,显然,只有网格CDGH、CDIJ、CDKL和CDMN有可能成为簇头节点c的下一个网格.在这些网格中,由于节点g不在节点e的通信半径内,GBA算法选择网格CDKL作为节点c的下一个网格,节点f作为下一个网格的簇头节点.②基于网格面积的算法GAAGAA的核心思想是:对Nc中的所有节点s,计算s作为簇头节点时,其对应的满足ESA约束条件且面积最大的网格gs;然后在Nc中选择使得下一个网格面积最大的节点x作为下一个网格的簇头节点,簇头节点c的下一个网格设置为x对应的满足ESA约束条件且面积最大的网格gx.若Nc中存在多个节点使得gn面积最大,则在这些节点中选择距离线段CD最远的节点作为gn的簇头节点.GAA算法的伪代码与GBA类似,因而在此不再赘述.如图7所示,Nc={d,e,f,g}.若选择节点e作为节点c下一个网格的簇头节点,则其对应的满足ESA约束条件且面积最大的网格是CDKL,而节点d、f对应的网格为CDMN,节点g对应的网格为CDGH.由于节点集合{d,e,f,g}中使得gn面积最大的节点为d、f且dist(d,CD)>dist(f,CD).算法GAA选择网格CDMN作为簇头节点c的下一个网格,节点f作为下一个网格的簇头节点.(2)网格簇头节点失效时如何恢复执行如图8所示,节点c收集完网格ABCD中节点的数据后,将部分查询结果和查询消息发送至下一个网格CDMN的簇头节点f.节点f收集网格CDMN中节点的感知数据后,生成新的部分查询结果并将其发送至节点i,继续查询处理过程.在上述查询处理过程中,当网格CDMN中的非簇头节点(如节点d)失效时,则仅丢失了该节点的感知数据,但不影响查询处理过程的继续执行;而当簇头节点f失效时,则查询处理过程中断且部分查询结果全部丢失.本文利用节点冗余以避免该问题,具体如下:在网格CDMN内可以找到一个网格rg,网格rg中的任意两个非簇头节点能够互相通信,称该网格为候选恢复网格.例如图8中节点d、e、g均能相互通信,因而网格CDGH、CDIJ、CDKL均是候选恢复网格.本文定义所有候选网格中面积最大的网格为恢复网格.如图8中的网格CDKL.网格CDMN中的所有节点均将感知数据发送到簇头节点后,由于恢复网格中的任意两个非簇头节点可以相互通信,因此,恢复网格中的任意一个节点均能分别计算出到所在恢复网格为止、除簇头节点之外的部分查询结果.例如,图8中的节点d、e、g均能分别计算出到网格CDKL为止的部分查询结果max{a,b,c,d,e,g},即网格ABKL的查询结果.当簇头节点失效时,恢复网格中的节点能够代替簇头节点继续查询处理过程.例如,当图8中的簇头节点f失效时,节点e能够代替它继续收集区域KLEF中节点的数据.图7网格大小和网格图8簇头节点失效时Page8(3)感知数据收集算法簇头节点cg收集所在网格g中其它节点的感知数据结束后,将查询消息和聚集后的部分查询结果发送至下一个网格gn的簇头节点cgn.网格gn中的其它节点均能收到该消息.若这些节点收到消息后同时发送感知数据至簇头节点cgn,会产生消息碰撞,造成大量的消息重传.因此,需要对其进行调度,减少消息碰撞的概率,从而减少能量的消耗.不失一般性,以图9为例,簇头节点c收集完网格ABCD中节点的数据后,将部分查询结果和查询消息发送至下一个网格CDMN的簇头节点f,网格CDMN中的节点{d,e,f,g,h,i}均能收到该消息.这些节点收到查询消息后,需要将本地的感知数据发送至簇头节点f.分两种情况讨论.情况1.簇头节点f收集网格CDMN中的感知数据时,网格gn中的节点拓扑稳定.本文首先提出一种基于距离的算法DC(Distance-basedDataCollectionAlgorithm),然后针对该算法的不足,提出一种改进算法IDC(ImprovedDistance-basedDataCollectionAlgorithm).①基于距离的感知数据收集算法DC,即网格CDMN中的节点按其到线段CD的距离从小到大排序,依次发送感知数据消息,具体过程如下:3.若i为1,则节点s立即将其感知数据发送至簇头节点f;若i>1,则节点s等待节点sns[i-1]发送感知数据消息结束后,发送感知数据消息至簇头节点f.在DC算法中,i:1i<|sns|,节点sns[i+1]监听节点sns[i]发送完感知数据消息后,立即发送其感知数据,这样保证消息不发生碰撞的同时减少了感知数据收集过程消耗的时间.但该算法要求满足条件:节点sns[i+1]在节点sns[i]的通信半径内.上述条件并不恒成立.如图9所示,若采用DC算法收集网格CDMN中的感知数据至簇头节点f,正确的感知数据发送顺序是d、e、g、h、i.但由于节点e和g、节点g和h、节点h和i不能互相通信,带来以下问题:节点i根据其邻居列表信息可知:它应在节点g之后发送感知数据消息,但实际上应该在1.对所有在网格CDMN中的节点s,它收到簇头节点c发送的查询消息后,分别根据自己的邻居节点列表计算出在网格CDMN中的邻居节点集合ns(CDMN);2.节点s对集合ns(CDMN)-f中的节点按其到线段CD的距离从小到大排序,排序后的列表记为sns,假设节点s在列表sns中的位置序号为i,其中1i||sns|,其中|sns|为列表长度;节点h之后;在感知数据收集过程的起始阶段,节点d、g、h根据其各自的邻居列表信息可知:没有节点先于它们发送感知数据消息,因而同时发送感知数据消息至节点f,导致消息碰撞.实际上此时应当只有节点d发送感知数据消息.②改进的基于距离的感知数据收集算法IDC考虑到簇头节点能与所在网格中的任意一个节点通信,簇头节点根据其邻居节点信息能计算出无消息碰撞的感知数据发送顺序.下面利用该特性提出一种基于DC算法的改进算法IDC.IDC算法用到的符号和定义如下:网格CDMN中的节点集合记为ns(CDMN).节点集合x中的节点按其到线段CD的距离从小到大排序后的有序列表记为sns(x).s:s∈ns(CDMN),ng(s)表示节点s在网格CDMN中、除簇头节点f之外的邻居节点.有序节点列表x中在节点s之前和之后的节点分别记为prev(s,x)和next(s,x).将在节点s之前和之后发送感知数据消息的节点分别定义为s的前驱节点和后继节点.如图10(a)~(c)所示,节点s位于线段IJ上.定义网格GHIJ和IJKL分别为节点s的上网格和下网格,其中,fd(I,H)=fd(I,L)=R.显然,可以得出以下结论.结论1.若节点集合ng(s)中存在节点在s的上网格中(如图10(a)所示),则等式prev(s,sns(ng(s)))=prev(s,sns(ns(CDMN)))成立;若不存在,则等式prev(s,sns(ng(s)))=prev(s,sns(ns(CDMN)))不一定成立.结论2.若簇头节点c在节点s的上网格中且prev(s,sns(ng(s)))=NULL(如图10(b)所示),则prev(s,sns(ng(s)))=prev(s,sns(ns(CDMN)))=Page9NULL,即节点s是网格CDMN中发送感知数据消息的起始节点.结论3.若ng(s)中存在节点在节点s的下网格中(如图10(c)所示),则等式next(s,sns(ng(s))=图10节点的前驱和后继节点示意图基于上述分析,IDC算法流程如下:对于网格CDMN的簇头节点f,它收到节点c发送的查询消息后,根据其维护的邻居节点集合计算出网格CDMN中发送感知数据消息的起始节点,并判断簇头节点c是否在该起始节点的上网格中;若否,则发送start消息给该起始节点(start消息用于通知节点开始发送感知数据消息至节点f).该起始节点收到start消息后,发送感知数据消息至簇头节点f.对于网格CDMN的任意一个非簇头节点s,它收到节点c发送的查询消息后,进行以下步骤:中的邻居节点集合ng(s),转到步2;1.根据其维护的邻居节点列表计算出在网格CDMN2.节点s根据结论2判断是否是网格CDMN中发送感知数据消息的起始节点,若是,则立即将其感知数据发送至簇头节点f;若否,转到步3;3.节点s根据结论1判断prev(s,sns(ng(s)))是否等于prev(s,sns(ns(CDMN))):(a)若是,则节点s在节点prev(s,sns(ng(s)))完成发送感知数据消息后,立即发送感知数据消息至簇头节点f;(b)若否,则等待簇头节点f发送的start消息.收到簇头节点f发送的start消息后,发送其本地的感知数据至簇头节点f,然后转到步4;4.节点s根据结论3判断next(s,sns(ng(s))是否等于next(s,sns(ns(CDMN))),若否,则发送coordinate消息至簇头节点f.coordinate消息用于通知簇头节点f计算节点s的后继节点并将start消息发送至该后继节点.f收到该消息后,根据其邻居节点列表计算next(s,sns(ns(CDMN))),并将start消息发送至该节点.值得注意的是,在IDC算法中,当网格CDMNnext(s,sns(ns(CDMN)))成立;若不存在,则等式next(s,sns(ng(s)))=next(s,sns(ns(CDMN)))不一定成立.中的节点s根据其邻居节点集合计算出的next(s,sns(ng(s))不等于next(s,sns(ns(CDMN)))时,它发送coordinate消息至簇头节点f.节点f根据其邻居节点集合计算s的后继节点,并发送start消息至该节点,从该节点开始继续数据收集过程.以图9为例,节点d根据结论2可以判断出它是起始节点.节点e根据结论1可知它的前驱节点是d,且根据结论3可知,它无法根据自己的邻居节点集合计算出正确的后继节点.因此,节点d将感知数据发送至簇头节点f后,节点e发送coordinate消息和感知数据至节点f.f收到该消息后,根据其邻居节点集合,计算出e的后继节点为g,然后发送start消息至节点g.节点g收到节点f发送的start消息后,继续后面的数据收集过程.情况2.簇头节点f收集网格CDMN中感知数据时网格gn中的节点拓扑频繁变化.本文提出一种基于角度的感知数据收集算法AC(Angle-baseddataCollectionalgorithm),即类似于文献[1]基于竞争的算法,网格CDMN中的节点收到簇头节点c发送的查询消息后,各自计算其到簇头节点f的角度a,并按公式max_delay×(a/(2π))(其中max_delay表示簇头节点完成数据收集花费时间的最大值)计算其发送感知数据的时间.该算法的性能取决于max_delay的估计值是否准确.若max_delay的估计值比实际值大,则会导致感知数据收集过程消耗的时间变长;若估计值比实际值小,则容易造成消息碰撞问题,浪费了能量的同时增加了感知数据收集过程消耗的时间.为了避免这些问题,本文采用如下Page10方法:由于网格gn中的节点均在簇头节点c的通信半径内,因此簇头节点c能计算出网格gn中的节点数目Num(gn).可以得到其中,T表示收集一个节点的感知数据需要花费的时间.簇头节点c计算出max_delay后,通过将其附加在查询消息中,发送至网格gn中的节点.3.4理论分析文献[1]没有对IWQE算法的能耗进行理论分析,下面先给出IWQE的能耗公式,然后与本文提出的算法进行比较.为了便于理论分析,假设查询处理过程中节点不失效.记IWQE算法的查询节点数目为Nq,其路线宽度和ESA算法的网格宽度均设置为w1(w1<R).由IWQE算法的执行过程可知:每个查询节点需要广播一次查询消息,查询节点的邻居节点集合中未发送感知数据消息的节点发送感知数据消息至查询节点,每个查询节点(最后一个查询节点除外)将部分查询结果和查询消息发送到下一个查询节点,或者当下一个查询节点已经收到了查询节点发送的查询消息时,则查询节点只需将部分查询结果发送到下一个查询节点.因此,IWQE算法在查询区域内分发查询和收集感知数据消耗的能量的最大值和最小值分别为Emaxc(IWQE)=NqSqE+(M-1)SaE+Eminc(IWQE)=NqSqE+(M-1)SaE+化简后,可以得到Emaxc(IWQE)=(2Nq-1)SqE+(M+Nq-2)SaEEminc(IWQE)=(Nq-1)SqE+(M+Nq-2)SaE因此,由式(7)和(8)可得Ec(IWQE)=(αNq-1)SqE+(M+Nq-2)SaE其中,1α2.由于在基站、查询区域固定的情况下,Ef(IWQE)=Ef(ESA),Eb(IWQE)=Eb(ESA)且Ef和Eb为一常量.根据式(3)和(9),可以得出以下结论:IWQE算法和ESA算法的能量消耗均与查询消息大小、感知数据消息大小成正比;当感知数据消息大小增大时,IWQE算法消耗能量的增幅大于ESA算法.对于用户提交的快照空间范围查询[1](例如获得查询区域sw当前时刻的平均温度),IWQE算法与ESA算法消耗的能量之差为Etotal(IWQE)-Etotal(ESA)=Ec(IWQE)-Ec(ESA)=(αNq-Ng-1)SqE+(Nq-1)SaE(10)其中,1α2.化简式(10)后,可以得到Etotal(IWQE)-Etotal(ESA)=IWQE算法的查询节点数目Nq为其中,AdvIWQE表示IWQE算法中相邻查询节点在查询路线方向上的距离的平均值.ESA算法的簇头数目Ng为其中,AdvESA表示ESA算法中网格的平均高度.对于一些查询任务固定的传感器网络应用,查询信息通常直接存储于每个传感器节点中,因而可以认为Sq=0.在这种情况下,ESA算法优于IWQE算法,节省的能量大小约等于(Nq-1)SaE.另外,当Sq≠0且SaSq时,则(αNq-Ng-1)SqE的值相比(Nq-1)SaE可以忽略不记,ESA算法优于IWQE算法,节省的能量大小约等于(Nq-1)SaE.当Sq≠0且SaSq不成立时,由于Nq(Ng)的值与路线宽度(网格宽度)、节点密度、节点通信半径、网络拓扑、查询区域内节点分布等因素有关,难以求解,因而在第4节通过实验对其进行分析和比较.对于连续空间范围查询(例如每隔1秒钟获得查询区域sw的平均温度),由于发送感知数据的能量消耗与发送查询消息消耗的能量相比可以忽略不记.IWQE算法与ESA算法消耗的能量之差为Etotal(IWQE)-Etotal(ESA)≈K(Nq-1)SaE其中,K表示连续空间范围查询对应的快照空间范围查询个数.因此,ESA算法优于IWQE算法,节省的能量大小为K(Nq-1)SaE.4仿真评价为了对算法的性能进行比较,我们在文献[21]的仿真器上实现了IWQE算法和ESA算法.为了描述方便,记采用GAA(GBA)算法的ESA算法为ESA-GAA(ESA-GBA).实验的硬件环境为P4(2.66GHz)CPU,512MB内存;软件环境为Ubuntu操作系统、Eclipse开发工具.实验的参数选择如下:Page11根据文献[22],无线通信模块发送和接收1字节数据的能量消耗公式为Et=α+γ×le,Er=β.采用文献[23]的参数:γ=10pJ/(bit·m2),α=45nJ/bit,β=135nJ/bit,e=2.其它参数如表1所示.查询区域占网络覆盖区域的百分比网格宽度占通信半径的比率IWQE算法路线宽度占通信半径的比率槡3/24.1比较ESA-GAA和ESA-GBA的能量消耗表2和表3分别显示了节点数目为320和800时,查询区域大小对ESA-GAA和ESA-GBA算法能量消耗的影响.可见,当节点密度较小时,ESA-GAA和ESA-GBA的能量消耗近似相等;当节点密度较大且查询区域较小时,在绝大多数情况下,ESA-GBA略优于ESA-GAA;当节点密度较大且查询区域较大时,在绝大多数情况下,ESA-GAA略优于ESA-GBA.由于在各种实验参数条件下,ESA-GAA与ESA-GBA能量消耗相差较小,在后面几组实验中,为了描述方便,仅给出ESA-GBA的实验结果.查询区域占网络覆盖区域的百分比查询区域占网络覆盖区域的百分比4.2比较ESA簇头节点数目和IWQE查询节点数目由式(11)可知,Etotal(IWQE)与Etotal(ESA)之差主要由Nq和Ng决定,本组实验分析Nq和Ng与节点密度、查询区域大小、网格大小(路线宽度)之间的关系.图11显示了节点密度对Nq和Ng的影响.可见,Ng>Nq,且随着节点密度的增大,Ng和Nq均变小,Ng降低的幅度小于Nq.这是因为:为了减少查询处理过程发送的数据消息数目,ESA要求网格的大小和簇头节点的选择满足ESA约束条件而IWQE算法没有该约束.因而AdvESA<AdvIWQE,且当节点密度增大时,AdvESA的增幅小于AdvIWQE.图12显示了查询区域大小对Nq和Ng的影响,可见,当查询区域较小时,Nq和Ng相差不大.随着查询区域的增大,根据式(12)和(13)可知,可以近似认为Ng和Nq与查询区域面积成正比,因而Ng和Nq均变大.图13显示了网格宽度对Nq和Ng的影响.实验中IWQE算法的路线宽度与ESA算法中的网格宽度相等.可见,随着路线宽度的增大,AdvIWQE基本保持不变,根据式(12)可知,Nq近似与路线宽度成反比,因而Nq逐渐变小.对于ESA算法,当网格宽度较小时,查询路线较长,使得Nq较大;当网格宽度较Page12大时,为了满足ESA约束条件,AdvESA较小,使得Nq较大.因此,随着网格宽度的增大,Nq呈现先减小后增大的趋势.4.3比较ESA算法和IWQE算法的能量消耗图14和图15分别显示了查询区域大小和节点密度对算法能量消耗的影响.可见,当查询区域或节点密度较小时,Nq和Ng相差不大且需要收集的感知数据数目较小,因而两种算法的能耗相差不大.随着节点密度和查询区域的增大,两种算法因分发查询和收集感知数据消耗的能量均增大,因而总能量消耗均增大.随着查询区域(节点密度)的增大,Nq也随之增大,根据式(11)可知,相比IWQE算法,ESA算法少发送了(Nq-1)个数据消息包,大大降低了算法的能量消耗.当网络中的节点数目取320~1600之间时,ESA算法减少的能量占IWQE算法总能耗的比例为[9.57%,27.57%].图16显示了网格宽度对能量消耗的影响.可见,随着路线宽度的增大,Nq变小,根据式(9)可知,IWQE算法消耗的能量逐渐减小.而对于ESA算法,Nq呈现先减小后增大的趋势,根据式(3)可知,其能量消耗也呈现先减小后增大的趋势.4.4比较ESA与IWQE的查询成功率和查询结果质量本组实验比较IWQE和ESA算法在不同失效节点数目、查询区域大小、节点密度和网格宽度条件下的查询成功率和查询结果质量.查询成功率定义为sr=se/te,其中,te表示算法运行的总次数,se表示算法成功返回查询结果至基站的次数.与文献[1]相同,查询结果质量定义为rq=cn/tn,其中,tn表示在查询区域内的节点数目,cn表示在查询区域内且被算法遍历到的节点数目.采用表1中的实验参数,失效节点数目设置为4,即节点失效的比例为0.5%.图17显示了失效节点数目对查询成功率和查询结果质量的影响.由于在IWQE算法中,任意一个查询节点失效会导致查询结果全部丢失且无法返回查询结果,因而IWQE算法的查询成功率和查询结果质量均随着失效节点数目的增大急剧下降.而ESA算法在簇头节点失效时从冗余节点恢复执行,降低了查询处理过程中断的概率,因而其查询成功率和查询结果质量随着失效节点数目的增大较缓慢地下降.图18显示了查询区域大小对查询成功率和查询结果质量的影响.可见,两种算法的查询成功率和查询结果质量随着查询区域的增大均下降,且IWQEPage13算法急剧下降,而ESA算法较缓慢的下降.这是因为:在失效节点数目固定的情况下,随着查询区域的增大,算法执行过程中遇到失效节点的概率增大,导致两种算法的查询成功率和查询结果质量均下降.图17失效节点数目对查询成功率和查询结果质量的影响图18查询区域对查询成功率和查询结果质量的影响图19显示了网络节点密度对查询成功率和查询结果质量的影响.节点数目分别取160×2,160×3,…,160×10,失效节点数目分别取2,3,…,10.可见,在失效节点比例固定的情况下,随着网络节点密度的增大,IWQE算法的查询成功率和查询结果质量基本不变,而ESA的查询成功率和查询结果质图19网络节点密度对查询成功率和查询结果质量的影响在IWQE算法中,任意一个查询节点失效则查询处理过程中止,而ESA算法只有在簇头节点及其所有备份节点同时失效的情况下才会中断,提高了查询处理过程的鲁棒性.量有显著的提高.尤其,当节点密度较大时,节点失效对ESA的影响可以忽略不记.其原因是:当网络节点密度变大时,ESA算法簇头节点的备份节点数目也随之增大,有效地降低了查询处理中断的概率.Page14图20显示了网格宽度对查询成功率和查询结果质量的影响.在实验中,IWQE算法的路线宽度取值与ESA算法的网格宽度相同.可见,随着网格宽度的增大,IWQE和ESA算法的查询成功率和查询结果质量均呈现先增大后减少的趋势.其原因是:当ESA算法的网格宽度(IWQE算法的路线宽度)较小时,两种算法的查询路线较长,使得Ng和Nq较大.对于IWQE算法,Nq越大,则查询处理过程因查询节点失效的概率越大;对于ESA算法,网格的平图20网格宽度对查询成功率和查询结果质量的影响5总结与展望现有传感器网络空间范围查询处理算法能量消耗大且查询处理过程容易因节点失效而中断,无法获得查询结果.本文提出了一种综合考虑能量消耗和节点失效的算法ESA.它仅要求查询区域内的每个节点发送一次数据消息,降低了能量消耗.为了减小查询处理因节点失效而中断的概率,我们设计了一种利用节点冗余恢复查询处理过程的算法,实验结果表明该算法有效地保证了ESA算法查询处理过程的查询成功率和查询结果质量,且随着节点密度的增大,ESA算法的查询成功率和查询结果质量显著提高.尤其当节点密度较大时,节点失效对ESA算法查询处理的影响可以忽略.因此,在绝大多数情况下,本文提出的算法优于IWQE算法.文献[18-20]采用了IWQE类似的思想处理K近邻查询,本文指出的问题在这些算法中依然存在,将ESA算法中的思想应用于K近邻查询算法是我们下一步的工作.致谢感谢加拿大Alberta大学AlexandruComan以及审稿专家,他们提出了宝贵的意见!均面积与Ng成反比,使得簇头节点的备份节点数目减少,因而IWQE和ESA算法的查询成功率较低且查询结果质量较差;当ESA算法的网格宽度(IWQE算法的路线宽度)较大时,对于ESA算法,为了满足ESA约束条件,AdvESA较小,使得Ng较大;对于IWQE算法,查询区域内不在查询节点通信半径内的数据节点数目随着路线宽度变大而增大,使得查询成功率较低且查询结果质量较差.
