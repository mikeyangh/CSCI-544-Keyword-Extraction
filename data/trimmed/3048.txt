Page1一种求解认知难题的模型检测方法骆翔宇1),2)苏开乐3)顾明1)3)(北京大学信息科学技术学院北京100871)1)(清华大学软件学院信息系统安全教育部重点实验室北京100084)2)(桂林电子科技大学计算机与控制学院广西桂林541004)摘要用公告逻辑建模并求解和与积认知难题.提出一种动态认知模型,将环境认知模型与公告导致的认知模型线性组合,从而在时态认知逻辑模型检测技术中扩展支持公告逻辑的建模与验证.该模型检测方法不仅可以用于搜索认知难题的所有解,而且可以验证相关的时态认知性质,这一特性是当前认知逻辑模型检测工具MCK、MCMAS和DEMO不能完全支持的.作者采用OBDD开发了相关的符号化模型检测工具MCTK并对和与积难题进行建模和验证,实验结果说明了文中方法的正确性和高效性.关键词模型检测;OBDD;公告逻辑;时态认知逻辑;和与积难题1引言认知难题(epistemicriddles)的一个共性是在一个多主体系统(multi-agentsystem)中经过一系列关于主体的知识或无知的公告后,主体将获知环境中的事实.在任一系统全局状态中,每一主体只能访问自身的局部状态(即全局状态的一部分).如果系统状态域是所有主体局部状态集合的全笛卡尔积,则所有主体的一个公共知识是任一主体均不能获知其他主体局部状态的相关信息,这时主体公告他的无知对于其他主体来说是没有价值的;否则主体的无知公告对其他主体来说是有价值的.认知难题的例子有和与积问题[1]、泥巴小孩问题[2]、谁是和问题[3]以及俄罗斯牌[4]信息安全协议等.本文以经典的和与积问题为案例研究认知难题的自动求解算法.1969年,Freudenthal首次在文献[5]中用Dutch语言解释了和与积问题,接着在1970年求得该问题的解[6].我们引用文献[1]中对该问题的描述如下:主体J向S和P说道:我有两个不同的整数x和y,它们满足1<x<y和x+y100.我将秘密地把和s=x+y告诉S,而把积p=xy告诉P.请你们确定这两个数(x,y)是什么.J将和与积分别秘密告知S和P后,发生如下对话:(1)P说:“我不知道这两个数”;(2)S说:“我早已知道你不知道这两个数”;(3)P说:“我现在知道这两个数了”;(4)S说:“我现在也知道这两个数了”.请问这两个数(x,y)是什么?由于主体只是公告了他们关于这两个数的知识或无知,并没有这两个数的具体描述,因此初看起来这些公告对于主体推测这两个具体的数是没有价值的.然而事实并非如此,主体可通过其他主体的公告逐步推断出这两个数的实际值.例如,这两个数不是2和4,因为只有2和4的积是8,这样P可推断出这两个数是2和4.这两个数也不是素数,因为两个素数的积是唯一的,因此P也可根据积推断出这两个素数.此外,这两个数也不是14和16,因为素数7和23的和同样是30,而素数7和23可被P推断出,因此如果和是30,那么S应该认为P可能知道这两个数.然而S却说他知道P不知道这两个数.因此这两个数不可能是14和16.通过此类推断,S和P可逐步排除那些不可能的数对,最终得到该问题的唯一解是(4,13).和与积问题可建模为一个多主体系统(MAS).多主体系统领域关注于主体的知识、信念、愿望和意图等精神状态的形式表示与推理.而动态认知逻辑(DynamicEpistemicLogic)则用于研究主体个体知识或群体知识通信所导致的主体知识的变化.公告逻辑(PublicAnnouncementLogic)也是一种动态认知逻辑,由于其可直接描述主体或主体群体的公告,因此非常适用于和与积这类问题的建模.vanDitmarsch等在文献[7]中宣称他们首次用动态认知模型检测工具DEMO[4]解决了该问题,但是他们也说明了时态知识逻辑[2,8]模型检测工具MCK0.2.0[9]和MCMAS0.7[10]不能解决该问题,因为他们的规格描述语言的条件语句中不支持知识逻辑公式的描述.本文提出一种动态认知模型,使得我们可以在我们的时态认知逻辑模型检测工具MCTK[11-12]基础上扩展支持公告逻辑的建模和验证.我们在MCTK中实现了该模型检测方法并解决了和与积问题,实验结果表明了我们的方法不仅正确,而且与vanDitmarsch等在文献[7]中基于DEMO的方法相比,我们的方法在效率上占有绝对优势.从另一个角度来说,我们的方法结合了传统时态认知逻辑模型检测技术与公告逻辑建模与验证方法,这一特性是MCK、MCMAS和DEMO等工具不能完全支持的.本文第2节介绍公告逻辑;第3节介绍基于公告逻辑的和与积问题建模方法;第4节介绍基于MCTK的认知难题建模与验证方法,包括动态认知模型及其符号化描述语言:多主体有限状态程序;第5节介绍基于MCTK的和与积问题建模方法;第6节给出实验结果;最后在第7节总结并讨论下一步研究工作.2公告逻辑给定一个主体集合Ag={1,…,n}和原子命题集合P,公告逻辑的语法归纳定义如下:其中p∈P,a∈Ag并且ΓAg.Kaφ读作“主体a知道公式φ成立”.CΓφ读作“公式φ成立是主体群体Γ的公共知识”.而[φ]ψ读作“公式ψ将在公告φ之后成立”.现在,我们可以在认知模型上定义公告逻辑的语义.令Le是环境中的状态集Page3合,Li是每一主体i∈Ag的局部状态集合,我们定义S=Le×L1×…×Ln为(全局)状态集合.V:P→(S)是一个评价函数.对于任意p∈P,V给出使得p为真的所有状态的集合.我们为每一主体i∈Ag赋予一个状态集合上的认知等价关系~i.定义函数li:S→Li,用于从一个全局状态s∈S中获取主体i的局部状态.这样,对于任意s,s∈S,s~is当且仅当li(s)=li(s).这意味着对于主体i来说,s和s是不可区分的.公告逻辑的语义归纳定义如下:(1)M,spiffs∈V(p),其中p∈P;(2)M,sφiffM,s/φ;(3)M,sφ∧ψiffM,sφ并且M,sψ;(4)M,sKiφiff对于任一满足s~is的状态(5)M,sCΓφiff对于任一满足s~Cs∈S,M,sφ;s∈S,M,sφ,其中~C(6)M,s[φ]ψiffM,sφ蕴含M|φ,sψ.M|φ=〈S,V,~1,…,~n〉也是一个认知模型,其中S={s∈S|M,sφ};对任一p∈P,V(p)=V(p)∩S;对任一i∈Ag,~i=~i∩(S×S).给定一个认知模型M和一个公式φ,φ在M有效(记为Mφ)当且仅当对于任一M中的状态s,M,sφ.3基于公告逻辑的和与积问题建模本节采用公告逻辑对和与积问题进行建模.首先确定该问题涉及的原子命题集合和主体集合.从引言可知,整数对(x,y)包含于I={(x,y)∈N2|1<x<y并且x+y100}.因此,需要用14个命题变量{x6,x5,…,x0}和{y6,y5,…,y0}对x和y进行二进制编码.我们分别用符号Eix和Ejy表示命题“x=i”和“y=j”.例如,E13x表示命题逻辑公式x6∧x5∧x4∧x3∧x2∧x1∧x0.由于文献[1]中至少需要194个命题符号表示x和y的每一取值,因此与文献[1]中的编码方法相比,我们的方法更加紧凑.现在考虑主体集合.由于主体J用于确保其他主体获得该问题相关的背景知识,其扮演的角色类似于多主体系统中的环境,因此在建模中不需考虑主体J的知识.这样,主体集合就是Ag={S,P}.命题“S知道(x,y)是(4,13)”可表示为公告逻辑公式KS(E4x∧E13式表示命题“S知道(x,y)”.首先,对于主体S,我们可分别用KSx=∧0i6(KSxi∨KSxi)和KSy=∧0i6(KSyi∨KSyi)表示命题“S知道x”和“S知道y”.例如,公式KSx意味着S知道x的所有二进制编码变量的取值.因此,命题“S知道(x,y)”可表示为KS(x,y)=KSx∧KSy.类似地,命题“P知道(x,y)”可表示为KP(x,y)=KPx∧KPy,其中KPx,KPy的结构类似于KSx,KSy.这样,该问题的4个公告可依次表示为KP(x,y),KSKP(x,y),KP(x,y)和KS(x,y).现在,我们可以在该问题的认知模型上解释这些公告了,其中I={(x,y)∈N2|1<x<y并且x+y100}.对于任意的整数x,y,x,y∈I,(x,y)~S(x,y)当且仅当x+y=x+y;(x,y)~Px,y当且仅当xy=xy.评价函数V定义为:对任一i(=0,…,6),V(xi)={(x,y)∈I|((x/2i)mod2)=1};V(yi)={(x,y)∈I|((y/2i)mod2)=1},其中“/”是整数求余运算符.评价函数V根据x和y的二进制编码规则为每一状态(x,y)赋予在其上为真的命题变量集合.最后,我们可定义模型有效公式Θ[KSKP(x,y)][KP(x,y)][KS(x,y)](E4x∧E13来表示数对(4,13)是和与积问题的唯一解.根据文献[1,7]的分析方法,我们认为公告(1)是多余的,因为公告(2)中的“S早已知道”表明了“P不知道这两个数”在系统的初始环境中就已经成立了,并不是公告(1)导致的结果.因此下文中忽略公告(1).4基于MCTK的认知难题模型检测方法本节将扩展我们的基于OBDD(OrderedBinaryDecisionDiagram)的时态认知逻辑模型检测工具MCTK[11-12],从而支持认知难题中的知识计算和公告逻辑的建模与验证.4.1动态认知模型EpistemicModel)是认知模型的一个扩展,其中我们提出一种新的动态认知模型(Dynamic(1)(φ1,…,φm)是m个公告的有序序列,每一公告由命题认知公式(命题逻辑公式与知识模态词Page4的组合)表示.φ1表示第一个公告.对任一i∈{1,…,m-1},φi+1将会在φi公告之后公告.(2)S=W×A是(全局)状态集合,其中W是可能世界集合,由原子命题集合P编码.A是从0到m的整数域,用于对φi公告后的每一可能世界赋予标识码i∈A.(3)V=VW∪VA是评价函数VW和VA的组合,其中VW:P→(W)为每一原子命题p∈P赋予一个使得p为真的所有可能世界集合.对于每一i∈A,VA:A→(W)为φi公告后的每一可能世界赋予一个标识码i.注意,VA(0)是任何公告之前的初始环境中的可能世界集合.(4)~i=S×S.我们为每一主体i∈Ag赋予一个状态集合S上的认知等价关系~i.简便起见,我们将前面提到的函数li:S→Li适当扩展,用于从状态S中获取主体i的局部状态.我们假设对于任一(w,a)∈S,li((w,a))均包含a.这样,对于任意状态(w,a),(w,a)∈S,(w,a)~i(w,a)当且仅当li((w,a))=li((w,a)).这意味着如果(w,a)~i(w,a)则a=a.因此w和w对于主体i来说是不可区分的,并且主体i知道所有公告发生的次序.我们的目标是将动态认知模型构造为m+1个认知模型M0,…,Mm的线性时态组合,其中是公告前的初始环境认知模型,θW是整个动态认知模型的初始可能世界集合.V0=V0W∪VA,其中对每一p∈P有V0W=VW(p)∩θ.对任一i∈Ag,我们定义VA(0)=θ和~0i=~i∩((θ×0)×(θ×0)).对每一i(=1,…,m),认知模型Mi+1与Mi的时态迁移关系如图1所示,表示公式φi+1将在Mi模型上评估,并在下一时态步被公告,公告所得的认知模型就是Mi+1.也就是说Mi是公告φi后得到的认知模型,其定义为其中WiWi-1是Mi的可能世界集合.Vi=ViW∪VA,其中对每一p∈P有ViAg,我们定义VA(i)=Wi和~i(Wi×i)).在图1的Mi+1中,我们定义Wi+1=Wi∩φWii+1,其中φWii+1是在当前模型Mi的可能世界集合Wi上满足φi+1的可能世界集合.因此Wi+1=Wi∩φWii+1意味着Wi+1是可能世界集合Wi中满足公告φi+1的子集.也就是说Wi+1={w∈Wi|Mi,(w,i)φi+1}.忽略整数域A,由公告逻辑语义容易证明Mi+1Mi|φi+1.这样,m个公告发布后,认知难题的所有解就是最后一个认知模型Mm的可能世界集合Wm.4.2多主体有限状态程序现在,我们可以将动态认知模型符号化地表示为一个多主体有限状态程序=〈x∪α,θ(x)∧α=0,τ(x∪α,x∪α),其中,(1)x={x1,…,xk}是可能世界集合的编码变量.α={a0,…,ab-1}是用于表示整数域A=[0,m]的b个二进制编码变量,其中b=log2(m+1).对每一i(=1,…,m),我们用命题“α=i”表示公式φi已被公告.这个命题可通过二进制编码规则表示为α上命题公式Ei公式φi已被公告.注意Em话的结束.为便于阅读,我们在下文中交替使用α=i或Eiα.由于任一S中的全局状态可表示为x∪α上的一个赋值,则(S)中的任一状态集合也可表示为x∪α或其真子集上的公式.(2)θ是x上的公式,表示初始环境中的可能世界集合.命题“α=0”表示为公式E0TRUE表示所有公告还未发布.我们称θ(x)∧α=0为初始条件.(3)状态迁移关系τ(x∪α∪x∪α)定义为下列公式的合取其中x={x1,…,xk}是x的一个复制版本,用于编Page5码迁移关系中的下一状态.α={a0,…,ab-1}是α的一个复制版本,用于编码α的下一值.(4)对每一i∈{1,…,n},Oix∪α是主体i的可观察变量集合.我们假设αOi,使得所有主体均能观察(知道)公告的发布次序.(5)对任一命题变量p∈x∪α,如果状态(w,a)∈V(p),则(w,a)(p)=TRUE,这里在如图1所示,在迁移关系τ中,式(1)约束所有认知模型Mi(i=1,…,m)中对x的解释都与初始环境认知模型M0的相同,使得所有认知模型Mi的可能世界集合都约束为初始环境认知模型可能世界集合的一个子集.式(2)在最后一个认知模型Mm中实现“自环”迁移关系,表示问题的解维持不变.我们在图2中定义认知约束构造函数EpistemicConstraint(型Mi(i=1,…,m)的可能世界集合Wi,并为Wi的每一可能世界赋予一个标识码i.Wcurr和Wnext分别是当前和下一认知模型的可能世界集合.注意,初始环境的可能世界集合θ(x)并不能从MCTK的输入语言中直接提取.但是初始环境的状态集合Init(x∪α)可从输入语言中以关键词“INIT”为前导的语句中获得,因此我们可在图2第2行通过OBDD计算αInit(x∪α)来获得θ(x).第4行的公式φWcurr上一个认知模型Mi的可能世界集合Wcurr上计算满足公告φi+1的可能世界集合.公式φWcurr如等式(4)所示.φW=OBDDfunctionEpistemicConstraint(1OBDDR··=TRUE;2OBDDWnext,Wcurr··=αInit(x∪α);/Wcurr··=θ(x)/3fori··=0tom-1do4Wnext··=Wcurr∧φWcurr5R··=R∧((α=i∧Wnext)→α=α+1);6R··=R∧((α=i∧Wcurr∧Wnext)→α=α);7Wcurr··=Wnext;8returnR;我们稍后解释等式(4).从图2第4行中可看到Wnext是Wcurr中满足公告φi+1的可能世界集合.为了构造Mi和Mi+1的线性时态关系,我们通过第5、6行在迁移关系中增加两个约束.第5行约束只有在满足Wnext的当前认知模型Mi的可能世界子集中,α才会在下一步中加1.在与式(1)的共同约束下,第5行可保证下一认知模型的可能世界集合为Wnext,同时赋予每一可能世界一个标识码i+1.第6行约束在不满足Wnext的当前认知模型Mi的可能世界子集中,α的值将在下一步中保持不变.同样在与式(1)的共同约束下,第6行可保证当前认知模型中不满足下一认知模型的可能世界仍然保留在当前认知模型中.另一个增加此约束的重要原因是可保证构造出来的迁移关系是完全的(total)[13],这意味着对动态认知模型中的任一状态,至少存在一个迁移使得当前状态变迁到另一状态.这种迁移关系的完全性是多数主流模型检测技术所要求的.由上述关于多主体有限状态程序们可通过图3中的一个简单函数计算出认知模型Mi(i=0,…,m)的可能世界集合(表示为Gi4.3MCTK中知识与时间模型检测算法的实现本节考虑如何在MCTK中实现基于OBDD的知识和时间模型检测算法.该算法涉及到两种关于知识模态词的模型检测算法,一种是基于某一认知模型的,而另一种是基于整个动态认知模型的.第2种知识检测算法同时支持时态算子.我们首先考虑基于认知模型的知识检测算法.事实上,该算法就是等式(4)的最后一行公式.等式(4)的前3行布尔构造是平凡的,我们重点关注φ=Kif的情况,这一情况由命题2定义.在证明命题2之前,我们首先介绍局部(local)命题[14]的概念,然后给出命题1.一个i-local命题在认知关系~i导出的状态等价类的所有状态中均有相同的解释.形式地,给定一个认知模型M和一个主体i,一个公式φ是i-local当且仅当对M的任一状态s,如果M,sφ,则对于任一满足s~is的状态s,M,sφ.这样,i-local公式是否成立仅取决于主体i的局部状态.生成的认知模型Mj(j=0,…,m),则一个公式φ在Mj中是i-local当且仅当存在一个Oi上的命题公式ψ使得Mj(φψ),即对任一可能世界w∈Wj有Mj,(w,j)(φψ).命题1.给定一个由多主体有限状态程序Page6由于本文考虑的认知模型可视为一个“平坦的”模型,即该模型包含一个初始状态集合,其中任一状态均不会迁移到新的状态.然后在此平坦的认知模型上计算主体知识.然而我们在文献[11-12]中提出的知识模型检测算法是基于整个系统的有限状态空间的,即认知模型的状态集合是从初始状态出发,不断展开迁移关系得到的系统全局可达状态集合.由于关于知识的模型检测算法思想都是基于局部命题语义的,因此命题1的证明过程类似于文献[11]中的命题1,只是各自考虑的状态集合有所不同.这里忽略证明过程.生成的认知模型Mj(j=0,…,m)和一个命题认知公式φ,则MjKiφ(x∪α-Oi)(Gj与上述关于命题1的解释相同,命题2的证明过程类似于文献[11]的命题3.这里忽略证明过程.现在,我们可以通过下式用OBDD计算M中的全局可达状态集合G(命题2.给定一个由多主体有限状态程序lfp[Z(θ(x)∧E0((x∪α)(Z∧τ(x∪α,x∪α)))x∪α其中lfpZξ(Z)是从x∪α上的布尔公式到x∪α上的布尔公式的操作ξ的一个最小不动点.ψx∪α是将ψ中的x∪α变量替换为x∪α中的相应变量之后得到的公式.G(到.注意图4并不是上述最小不动点的直接实现,而是做了一些优化.在图4中,第4行用upper保存当前的可达状态集合.第5行从上次新产生的状态集合lower开始计算所有可能的直接后继状态的集合image,这时得到的image是建立在x∪α之上的.第6行把image变换为x∪α之上的公式后将其合并到可达状态集合R中.第7行将产生的新状态集合保存到lower后重新循环搜索可达状态,直至没OBDDfunctionG(1OBDDlower(x∪α)=init(2OBDDR(x∪α)=init(3while(lower(x∪α)!=FALSE)do4OBDDupper(x∪α)=R(x∪α);5OBDDimage(x∪α)=x∪α.(lower(x∪α)∧6R(x∪α)=R(x∪α)∨imagex∪α7lower(x∪α)=R(x∪α)∧upper(x∪α);8returnR(x∪α);实际上,状态集合Si也可由图3的函数计算得有任何新的状态产生为止,即lower(x∪α)==FALSE.从G(G()实际是所有Mi(i=0,…,m)的状态集合Si的并集.由于每一Si是附带标识码α=i的可能世界集合Wi,因此可能世界集合Wi可由公式α(G(α=i)计算得到,其中通过存在量化将附加的公告变量α消除了.这样,最后一个公告φm发布之后,认知难题的所有解就是由公式α(G(的可能世界集合.到,因此可能世界集合Wi也可由公式αG(表示.公式αG(界集合θ(x)以及公告序列,而α(G(要构造迁移关系τ(x∪α,x∪α)并计算全局可达状态集合G(计算效率高于α(G(需得到该问题的解,则执行公式θ(x)和αG(的计算即可.如果我们还需对主体知识在时态上的变化进行检测,则两种可能世界集合的计算方法都是必需的.如图1所示,通过将动态认知模型构造为m+1个认知模型M0,…,Mm的线性时态组合,我们可以符号化地表示为多主体有限状态程序,这与我们在文献[11-12]中所用的带n个主体的有限状态程序兼容.这样,我们不仅可以对认知难题进行公告逻辑建模并搜索所有解,而且可以沿用我们在文献[11-12]中开发的模型检测算法验证问题相关的一些时态认知性质.这一特性不能被DEMO、MCK和MCMAS等认知逻辑模型检测工具完全支持.关于我们的时态认知逻辑模型检测方法并不是本文的主要内容,详细内容请查阅文献[11-12].我们将在下文通过实例说明这一特性.5和与积问题的MCTK建模我们的模型检测工具MCTK[11]是在时态逻辑模型检测工具NuSMV2.1.2基础上扩展实现的,在NuSMV输入语言基础上扩展支持对主体可观察变量的定义,使得我们可以在MCTK中描述和与积问题的多主体有限状态程序(图5所示):Θ=〈x∪α,θ(x)∧α=0,τ(x∪α,x∪α),OS,OP,(KSKP(x,y),KP(x,y),KS(x,y))〉.Page71MODULEmain()2VAR3a:0..3;--announcementvariable,m=34x:2..100;y:2..100;5sum:4..200;product:4..10000;6S:SumAgent(sum,a);7P:ProductAgent(product,a);8INITx>1&y>x&x+y<=100&91011TRANSnext(x)=x&next(y)=y&121314MODULESumAgent(Observablesum,Observableav)15MODULEProductAgent(Observableproduct,Observableav)在图5中,第3行定义一个整型变量a,这一变量名专为表示公告动作α而保留.根据第3行的分析结果,我们只对公告(2)、(3)和(4)建模,因此变量a的取值范围是[0,3].整数变量x和y表示数对.为了使主体S和P分别只能观察到和与积,我们建立两个附加的整型变量sum和product,分别表示x和y的和与积.因此,Θ的变量集合x∪α是a,x,y,sum和product的二进制编码变量的集合.第8~9行根据题意约束这4个整型变量的初始值,构造出Θ的初始条件θ(x).第10行意味着在初始环境中没有发生任何公告.第11~12行表示式(1),使得4个整型变量的初始值一旦在θ(x)的约束下被随机选定,则始终保持不变.注意到在MCTK中,用“next(v)”表示变量v的下一版本v.第13行表示式(2).在此我们并没有显式地构造式(3),即EpistemicConstraint(Θ),这是因为当前实现的MCTK输入语言不支持可能世界集合的表示和φW的计算.我们在MCTK内部实现函数EpistemicConstraint(Θ)并在MCTK构建了基于OBDD的基本迁移关系之后调用.这样,我们就可以通过OBDD合取操作在OBDD表示的基本迁移关系中加入认知约束EpistemicConstraint(Θ).第14~15行是主体S和P的模块定义,其中的形式参数sum和av对于S是可观察的,而product和av对于P是可观察的.第6~7行声明主体实例S和P,S和P的实际参数分别是{sum,a}和{product,a},这意味着S的可观察变量集合OS是整型变量{sum,a}的二进制编码变量集合,而P的可观察变量集合OP是整型变量{product,a}的二进制编码变量集合.将公告变量a加入主体S和P的可观察变量集合的目的是使得他们知道公告的发布次序.6实验结果我们已成功实现本文提出的认知难题模型检测工具MCTK,其中的算法是基于科罗拉多大学FabioSomenzi开发的CUDDOBDD软件包实现的.我们在一台配置为P86002.4GHzCore2Duo处理器和4GB内存,操作系统为Ubuntu8.10Linux系统的笔记本电脑上用MCTK验证了和与积问题.验证所需时间约48s,包括符号化模型构建时间和公式G(Θ,3)的计算时间.消耗12425.712KB内存.模型检测结果是G(Θ,3)(E4x∧E13味着当且仅当初始世界是(4,13)时,才可能依次发布公告(2)、(3)和(4).换句话说,和与积问题的唯一解是(4,13).这一结果与文献[1,7]得到的一致.为了与文献[1,7]的试验结果进行比较,我们在同一实验平台上,基于动态认知模型检测工具DEMO验证了文献[1]中图1描述的和与积问题,得到的结果也是只有唯一解(4,13).其中采用Haskell编译器GHC6.8.2对该问题模型描述程序进行编译.执行该编译程序得到结果所需时间大约是12min20s.消耗9319.284KB内存.显然,除了消耗的内存多一些外,我们的工具MCTK的效率与DEMO相比占有绝对优势.初略分析的结果是DEMO可以看作是基于显式状态建模的模型检测方法,其内部可能没有采用优化技术,因此基本上只能对单一状态进行操作.而我们的模型构建和公式检测都采用基于OBDD的符号化方法,可以用公式紧凑地表示状态集合并在其上执行各种高效的逻辑运算.因此与DEMO相比,我们的符号化方法可处理更大规模的问题,验证效率更高.在MCTK的具体实现中,我们不仅支持时态认知逻辑ECKLn(CTL[15]与认知模态词的组合)的模型检测,而且还在NuSMV的CTL模型检测算法上扩展支持认知模态词的检测检测算法,因此支持计算树认知逻辑CTLK的模型检测,对于时态部分只包含CTL时态算子的公式,CTLK的模型检测效率更高.我们也对和与积问题验证了一些时态认知性质.我们首先验证了CTL性质其中时态算子“AG”表示“任一路径的任一状态”或“始终(always)”.验证所需时间约49s.消耗12425.712KB内存.这一性质表示一旦第3个(最后一个)公告发布了,则认知模型中只有一个可能世Page8界(4,13),这就是该问题的解.这一性质说明了我们构建的动态认知模型是正确的.第2个被验证性质是一个CTLK公式:AG(((x=4&y=13&a=2)->其中“sumKx”表示公式KSx,“sumKy”表示公式KSy.验证所需时间约60s.消耗12425.712KB内存.这一性质表示如果数对(x,y)是(4,13),则P宣告他不知道这两个数之后,S将会知道(x,y)就是(4,13);但是如果数对(x,y)不是(4,13),则P宣告他不知道这两个数之后,S仍然不知道这两个数.我们还验证了第3个CTL性质(x=4&y=13)->AG(a=2->(x=4&y=13)).这一性质表示如果(x,y)的初始值为(4,13),则(4,13)必然保留在P宣告他不知道这两个数之后得到的认知模型中.结合第2个性质,可推断在P发布公告后S将宣告他知道这两个数.这就是该问题的实际情况.7结论及未来工作本文首先用公告逻辑对和与积问题进行建模,然后用MCTK的输入语言即多主体有限状态程序描述该问题.该问题的动态认知模型可通过MCTK从多主体有限状态程序自动编译生成.结合我们在文献[11-12]中开发的时态认知逻辑符号化模型检测方法,我们可将问题求解和时态认知模型检测的算法转化为一系列基于OBDD的运算.实验结果表明了我们的方法的正确性和高效性.将来我们考虑在此基础上扩展更常见的通信方式(如点对点通信、组群通信和广播等)的建模与验证方法,还可考虑支持多协议会话的建模等,从而扩展动态认知的建模能力并提高验证算法效率,有望解决更多的认知难题.本文的工作也可进一步扩展到更复杂的安全协议形式化验证领域.
