Page1Piccolo算法的差分故障分析赵光耀1)李瑞林2)孙兵3),4)李超1),3)1)(国防科学技术大学计算机学院网络技术与信息安全研究所长沙410073)2)(国防科学技术大学电子科学与工程学院长沙410073)3)(国防科学技术大学理学院数学与系统科学系长沙410073)4)(中国科学院软件研究所信息安全国家重点实验室北京100190)摘要Piccolo算法是CHES2011上提出的一个轻量级分组密码算法,它的分组长度为64-bit,密钥长度为80/128-bit,对应迭代轮数为25/31轮.Piccolo算法采用一种广义Feistel结构的变种,轮变换包括轮函数S-P-S和轮置换RP,能够较好地抵抗差分分析、线性分析等传统密码攻击方法.该文将Piccolo算法的S-P-S函数视为超级S盒(SuperSbox),采用面向半字节的随机故障模型,提出了一种针对Piccolo-80算法的差分故障分析方法.理论分析和实验结果表明:通过在算法第24轮输入的第1个和第3个寄存器各诱导1次随机半字节故障,能够将Piccolo-80算法的密钥空间缩小至约22-bit.因此,为安全使用Piccolo算法,在其实现时必须做一定的防护措施.关键词差分故障分析;超级S盒;轻量级分组密码;Piccolo算法1引言来越受到人们的重视.由于物联网中许多设备的计算能力较低、存储空间小、资源有限,传统的加密算法不能得到很好的应用.在此情况下,设计一种执行随着物联网技术的不断发展,数据安全问题越效率高、资源消耗少的密码算法来保护微型设备间Page2的信息传输安全显得越来越重要.近年来,轻量级密码算法的设计与分析受到了人们的广泛关注,密码学者提出了许多轻量级密码算法,如MIBS[1]、LED[2]、HIGHT[3]、LBlock[4]、PRESENT[5]、KLEIN[6]等.Piccolo[7]算法是在CHES2011上提出的一种轻量级密码,由日本索尼公司的Shibutani等学者设计,它的分组长度为64-bit,密钥长度可以为80-bit或128-bit.与其它的轻量级算法相比,Piccolo算法最大的优点是其能耗极小,而且只需额外增加少量的硬件开销,便可同时支持加解密,因而尤其适用于低能耗设备.Biham和Shamir首次在文献[8]中将差分分析[9]的思想推广至差分故障分析,用来对DES类的密码算法进行攻击,使得现实环境中的分组密码受到了更大的威胁.近些年来,人们利用该思想陆续对一些轻量级密码算法进行了分析,包括Keeloq[10-11]、MIBS[12]、LED[13-14]①、LBlock[15]、HIGHT[16]等.差分故障分析的一个关键问题是如何合理地建立故障模型,包括故障诱导的时间、位置和取值.在实际攻击当中,需要根据加密算法的结构、轮函数的特点、算法实现的软硬件环境以及攻击所采用的设备[17-18]来确定究竟采取哪一个模型更加适合.目前,对Piccolo算法的传统安全性分析主要有Biclique攻击[19].本文在对算法组件进行深入分析后,提出了一种针对Piccolo-80算法的差分故障攻击方法,能够以较少的故障注入次数,在较短的时间内恢复出种子密钥.理论分析和实验验证表明,诱导2个故障即可将80-bit的种子密钥空间减少到约22-bit.本文第2节简单介绍Piccolo算法;第3节给出算法的一个等价结构,并对Piccolo算法的S盒以及S-P-S结构的差分特性进行描述;第4节给出对Piccolo算法的差分故障分析,包括基本思想、详细的攻击步骤和攻击的复杂度分析;第5节给出攻击的实验结果;第6节对全文进行总结;附录给出攻击的一组实验结果.2Piccolo算法首先给出本文所用记号,然后简要介绍Piccolo算法.2.1符号及术语说明a(b):长度为b-bit的数据a;a|b:数据a与b的级联;a←b:将b的值赋给a.ΔOUTFi:第i轮F变换层的输出差分,ΔOUTFi=ΔOUTFiΔOUTi:第i轮的输出差分,ΔOUTi=ΔOUTiΔOUTiXL或XR:X的左(或右)半部分.若X为16位,则XL表示X的高8位;半字节:长度为4-bit的向量.2.2Piccolo算法Piccolo算法分组长度为64-bit,密钥长度可为80-bit和128-bit,对应的算法分别记为Piccolo-80和Piccolo-128,迭代轮数分别为25和31.本文研究对象为Piccolo-80.为表述方便,以下如无特别说明,Piccolo均指Piccolo-80.Piccolo算法所采用的结构是广义Feistel结构的一种变体,如图1所示,该结构包括4个分支(寄①另可参见:ZhaoXin-Jie,GuoShi-Ze,ZhangFan,WangPage3存器),每个分支(寄存器)包含16-bit数据.Piccolo算法每轮包含两类变换:轮函数F:(0,1)16→(0,1)16和轮置换RP:(0,1)64→(0,1)64(最后一轮除外,仅包含轮函数F),其中F函数采用S-P-S三层结构(见图2),P变换采用有限域GF(16)上的矩阵,定义如下轮置换RP则是基于字节的位置变换,如图3所示.Piccolo算法的密钥扩展算法比较简单,采用基于置换的实现方法,这在一定程度上减少了硬件开销,同时也使得轮密钥建立时间更短.密钥扩展算法使用80-bit的种子密钥k(80)作为输入,输出4个16-bit的白化密钥wki(16)(0i<4)和50个16-bit的轮密钥rkj(16)(0j<50).首先将80-bit的种子密钥k80划分为5个16-bit的字:k(80)=k0(16)|k1(16)|k2(16)|k3(16)|k4(16),轮密钥可按如下方式得到:wk0←kL0|kR1,wk1←kL1|kR0,wk2←kL4|kR3,wk3←kL3|kR4;fori←0to(r-1)do:(rk2i,rk2i+1)←(con2i,con2i+1)其中的轮常数为如下形式:(con2i,con2i+1)←(ci+1|c0|ci+1|{00}2|ci+1|c0|ci+1){0f1e2d3c}16,这里ci是将i表示成5-bit的二进制数,如c13={01101}2.不难发现,白化密钥wk2和wk3对应于种子密钥中的k3、k4,最后一轮的轮密钥rk48、rk49与种子密钥中的k0、k1则只相差一个轮常数.3Piccolo算法组件性质3.1Piccolo算法的一个等价结构及差分传播性质通过分析,我们发现可以根据轮置换的逆变换,将Piccolo算法的第25轮轮密钥进行拆分重组,上移一轮后作为第24轮的白化密钥.图4所示为算法最后两轮等价结构,其中rk46,rk47用虚线表示,旨在说明对应的轮密钥也可以上移至前一轮.Piccolo算法结构属于广义Feistel结构的变种,且RP变换是基于字节的置换,容易得到以下差分传播性质:ΔOUTFi1=(ΔOUTi+10)L|(ΔOUTi+12)R(1)ΔOUTFi3=(ΔOUTi+12)L|(ΔOUTi+10)R(2)3.2Piccolo算法S盒的差分特性本节简单描述Piccolo算法中S盒(S:的差分特性.假设给定α∈{z∈42|S(zα)S(z)=β},N(α,β)=#IN(α,β),称α为S盒的输入差分,β为S盒的输出差分.Piccolo算法S盒差分分布性质如表1所示.N(α,β)出现次数概率N(α,β)≠0时所占比重平均值01590.6212720.2814240.0941610.004表1说明,当给定α∈Page4S(zα)S(z)=β,62.1%的情况无解,而在有解的情况下,74.2%的情况下有2个解,24.7%的概率有4个解,且解的平均个数为2.65(=1.484+0.988+0.176).3.3S-P-S结构差分特性Piccolo算法中F函数采用S-P-S三层结构,与传统的S-P结构相比,其混淆性能更强.由于Picco-lo算法采用的S盒是有限域GF(16)上的一个置换,P置换采用的是GF(16)上的矩阵犕,所以将S-P-S结构看成一个大的S盒,其输入和输出均为16-bit,可视为有限域GF(216)上的一个置换.这类似于文献[20]中提出的超级S盒(SuperSbox)的概念①,只需将密钥加部分的密钥取为全零即可,如图5所示,其中灰色底纹表示活跃的半字节.将3.2节中定义的IN(α,β)及Nα,()β推广至超级S盒,即IN(α,β)={x∈Nα,()β=#IN(α,β),其中SS表示超级S盒,α∈162,β∈特性:下面给出几种特殊情形下超级S盒的差分传播(1)输入差分仅在单个半字节上非零的情形.这种情况下,输入差分有4×(24-1)=60个可能取值,我们考虑输出差分的分布情况,此时输入/输出差分对(α,β)取值共有60×216=3932160种,统计N(α,β)的取值情况,结果见表2.表2说明,当超级S盒的输入差分只有单个半字节非零时,在所有输入/输出差分对(α,β)中,平均意义下,有15.3%的(α,β)对应的N(α,β)≠0,且N(α,β)的平均值为6.53.表2输入差分在单个半字节上非零时超级S盒差分特性N(α,β)出现次数最大值概率累加值平均值0332972400.84700≠0602436960.15339321606.53(2)输入差分为(α1,α2,0,0)或(0,0,α3,α4)(αi非零)的情形.此时,输入差分共有2×(24-1)2=510个可能取值,考虑输出差分的分布情况,输入/输出差分对共有510×216种取值,统计N(α,β)的取值情况,结果如表3所示.表3说明,当超级S盒的输入差分形式为(α1,α2,0,0)和(0,0,α3,α4),其中αi非零时,平均意义下,26.3%的概率N(α,β)≠0,且当N(α,β)≠0时,其平均值为3.8.表3输入差分为(α1,α2,0,0)和(0,0,α3,α4)时N(α,β)出现次数最大值概率累加值平均值02462668400.73700≠08796676960.263334233603.80(3)超级S盒的扰动差分传播特性.为了确切地研究Piccolo算法故障攻击时超级S盒的差分传播性质,我们根据攻击算法所示的差分传播特点(图9,图10),建立图6所示的差分分析模型.仍然考虑输入差分为(α1,α2,0,0)或(0,0,α3,α4)(αi非零)的情形.假设给定输入差分α时,输出差分共有n个可能值.图6中βi表示α对应的第i个输出差分值;θ表示输出差分的未知部分(扰动),经过分析,θ共有32个可能值,θi表示θ的第i个可能取值.①输入差分α∈{(α1,α2,0,0)|αi≠0}.对随机给定的α,首先获得其所有可能的输出差分组成的集合OUTDα,因此对于任意β∈OUTDα,必有N(α,β)>0,此时我们对β进行一个扰动获得γ=βθ,其中θ∈{(θ1,0,0,0),(0,θ2,0,0)|θi∈N(α,γ)>0是否成立.对随机给定的α和θ,我们可以利用如下的算法1得到N(α,γ)>0成立的平均概率P以及成立时方程SS(αx)SS(x)=γ解的平均数目M.①另可参见:DaemenJ,RijmenV.Two-roundAESdifferen-tials.CryptologyePrintArchive,2006,http://eprint.ia-Page5算法1.超级S盒的扰动差分传播特性.输入:Set(α)={(α1,α2,0,0)|αi≠0},输出:P及MCOUNT(α,β)=0,Aγ(α,β)=0Forα∈Set(α)OUTDα←{β|N(α,β)>0}P(α)=∑β∈OUTDαM()α=∑β∈OUTDαEndForP=∑α∈Set(α)M=∑α∈Set(α)②输入差分α∈{(0,0,α3,α4)|αi≠0}.分析过程与①类似,区别仅为θ∈{(0,0,θ3,0),(0,0,0,θ4)|θi∈①②情形下,输入差分均有(24-1)2=225个可能取值.按照图6所示的模型分别得到超级S盒图7Piccolo差分故障分析的相关记号示意图4.2Piccolo算法差分故障分析的模型和原理Piccolo算法采用的S盒输入输出均为4-bit,所以我们采用基于半字节的随机故障诱导模型.假定攻击者可以对算法运行过程中某时刻的指定存储单对应的扰动差分传播性质,见表4.表4超级S盒的扰动差分传播特性(α犻非零)α的取值形式(α1,α2,0,0)(0,0,α3,α4)4对Piccolo算法的差分故障分析4.1基本记号和符号为简单起见,给出以下基本记号和符号(见图7):记明文为P=(X0|X1|X2|X3),密文为C=(C0|C1|C2|C3);INi:第i轮的输入,INi=INi0|INi1|INi2|INi3,IN0=P;OUTi:第i轮的输出,OUTi=OUTi0|OUTi1|OUTi2|OUTi3,OUT25=C;OUTFi:第i轮F变换层的输出,OUTFi=OUTFi0|OUTFi1|OUTFi2|OUTFi3,RP(OUTFi)=OUTi;INSSiL或INSSiR:第i轮左边(或右边)F函数(超级S盒)的输入;OUTSSiL或OUTSSiR:第i轮左边(或右边)F函数(超级S盒)的输出;〈X〉:X所有可能取值的集合;〈X〉:X所有可能取值的个数;ΔX:X的差分值,即假设有两个X:x1,x2,则ΔX=x1x2.元(如第i个寄存器)诱导随机的半字节故障,但不知道故障对应的半字节在存储单元中的位置及具体取值.对于同一个明文P,攻击者可以获得其在某一未知密钥MK下加密所得的正确密文和错误密文.Page6对Piccolo算法的差分故障分析原理如下:对任意明文P进行加密,获取对应的正确密文C.当加密过程运行到第24轮时,在输入的第1个和第3个寄存器中各诱导一次半字节随机故障,并记录相应的错误密文CA和CB.根据收集到的正确密文与错误密文,利用超级S盒的差分特性对白化密钥wk2和wk3进行筛选.然后利用剩余的wk2和wk3值对密文C作一轮解密,同样利用超级S盒的差分特性确定rkL49|rkR48以及rkL48|rkR49的候选值,依据密钥扩展算法,得到MK的所有可能取值,最后利用P和C进行验证,确定唯一正确的MK.注意到很多采用广义Fesitel结构的分组密码的故障分析方法均采用了上述类似模型,而在实际攻击过程中,根据攻击者拥有的攻击设备和条件,诱导的故障可能并不在我们期望的存储单元中(如第24轮的第1个和第3个寄存器中),这时我们可借助于错误密文与正确密文的差分来判断故障诱导的位置是否恰好在所需的寄存器上.如图8所示,若故障发生在第24轮输入的第2个寄存器上(不论发生在哪个半字节位置),则对应密文差分的活跃字节数不超过3个.类似地,若故障发生在第24轮的第4个寄存器上,则对应密文差分的活跃字节数也不超过3个.而由图9和图10可知,若故障发生在第24轮的第1个和第3个寄存器上,则对应密文差分的活跃字节数超过4个.进一步,若(ΔC0)R=0,则故障位于第1个寄存器;若(ΔC0)R≠0,则故障位于第3个寄存器.图8在第24轮输入的第2个寄存器处诱导随机半字节由以上分析可知,通过观测正确密文与对应错误密文的差分,可以有效地判断故障所在的寄存器,快速筛选出有效的错误密文进行分析,从而提高攻击的效率.图9诱导的随机半字节故障在A处时差分传播示意图图10诱导的随机半字节故障在B处时差分传播示意图4.3攻击的详细步骤攻击过程按照如下5个步骤进行:1.故障诱导和数据收集.任意选择一个明文P,在种子密钥MK的作用下加密,记录正确密文C,当算法运行至第24轮时,在输入的第1个和第3个寄存器中分别诱导随机半字节故障,并记录相应的错误密文CA和CB.这里,CA表示故障位于IN240处(图9中的A所示位置)时对应的错误密文,CB表示故障位于IN242处(图10中的B所示位置)时对应的错误密文.故障诱导后引入的差分传播如图9和图10所示.2.获取wk2,wk3,rk48,rk49的所有可能候选值.2a.通过正确密文C与错误密文CA,得到F函数亦即超级S盒的输入/输出差分,根据超级S盒的差分特性进行筛选,获得所有可能的输入值INSS25L及INSS25R,由于IN-SS25Lwk2=C0,INSS25Rwk3=C2,可得wk2的候选值集合〈wk2A〉,wk3的候选值集合〈wk3A〉.进一步,利用C与错误密文CB进行分析,可得到wk2的候选值集合〈wk2B〉及wk3的Page7候选值集合〈wk3B〉.求〈wk2A〉与〈wk2B〉的交集,得到筛选后的wk2候选值集合〈wk2〉;求〈wk3A〉与〈wk3B〉的交集,得到筛选后的wk3候选值集合〈wk3〉.2b.利用步2a中得到的wk2∈〈wk2〉,wk3∈〈wk3〉,对C及CA、CB进行一轮解密,并记录对应的差分值(ΔOUTF24)A及(ΔOUTF24)B及由正确密文C进行一轮解密得到的OUTF240及OUTF242.利用超级S盒的差分特性,可获得所有可能的输入值INSS24L及INSS24R,由于INSS24L(rkL49|rkR48)=OUTF240,INSS24R(rkL48|rkR49)=OUTF242,可得rkL49|rkR48及rkL48|rkR49的候选值集合〈rkL49|rkR48〉、〈rkL48|rkR49〉.3.根据密钥扩展算法,得到MK中对应的k3,k4,k0,k1对应的候选值集合〈k3〉,〈k4〉,〈k0〉,〈k1〉.4.穷搜索k2,得到MK的候选值集合〈MK〉.5.利用P和C,通过EMK(P)=C验证,得到唯一正确密钥MK.4.4复杂度分析步2a的复杂度.通过步1中收集到的正确密文C与错误密文CA,可以确定ΔINSS25L,ΔINSS25R的值,由于故障位置未知,ΔOUTSS25L及ΔOUTSS25R分别有2×24=32种可能取值.按照3.3节所述分析模型,超级S盒的输入差分α值已经确定,但它对应的输出差分β未知,但我们知道输出差分候选值共有32个,在这32个可能取值中,31个可以视为对β扰动之后得到的差分γ,根据超级S盒的扰动差分传播特性(表4),平均意义下α和γ能够匹配的概率为42.6%且匹配后的平均值为3.675.由此可得,平均意义下INSS25L共有3.8+31×0.426×3.675≈52个可能取值;类似地,INSS25R约有3.8+31×0.43×3.684≈53种可能取值,对应可得〈wk2A〉≈52,〈wk3A〉≈53;同样地,利用C与错误密文CB进行分析,可得平均意义下,〈wk2B〉与〈wk3B〉也分别为53和52.由于正确的wk2和wk3一定会包含在各个候选值集合中,而216×(52/216)×(53/216)<1,所以平均意义下,对两次的候选值集合求交集后,〈wk2〉=1,〈wk3〉=1.步2b的复杂度.由3.2节所述差分传播性质(1)和(2)可知,(ΔOUTF241)A、(ΔOUTF243)B可直接由对应的密文差分观测到.求交集后〈wk2〉=1,〈wk3〉=1,利用wk2和wk3进行一轮解密后,(ΔOUTF240)A及(ΔOUTF242)B的取值也可相应确定,即超级S盒的输入/输出差分均可确定.根据超级S盒差分特性(表2),可得平均意义下rkL49|rkR48的候选值个数为6.53个,rkL48|rkR49的候选值个数也为6.53个.步3的复杂度.根据密钥扩展算法知〈k3〉=1,〈k4〉=1,〈k0〉×〈k1〉=(6.53)2≈25.4.步4的复杂度.穷搜索k2,可得到MK的候选值个数为N=1×1×25.4×216≈221.4个.注意到在随机给定超级S盒输入/输出差分的情况下,要找到所有合适的输入值,需进行216次搜索.步2a需要2×216×32=222次搜索,步2b需要2×216次搜索,即在得到MK候选值前共需要约222次搜索.若采用预计算模式,即事先计算并存储超级S盒输入/输出差分与输入值的对应关系,则可省去搜索时间,但需要耗费约60×216×16+510×216×16bits≈226Bytes的存储空间.分析结果表明,通过在第24轮输入状态的第1个和第3个寄存器各诱导1个随机半字节故障,利用正确密文与2个错误密文进行分析,能够将Piccolo算法80-bit的密钥空间缩小至约22-bit.5实验及结果在PC机上(CPU:PentiumDual-CoreE67003.20GHz,RAM:2GB)使用C++语言编程(VisualC++6.0)对本文给出的攻击方法进行了200次模拟实验.对k0,k1,k3,k4共64-bit的种子密钥搜索空间分布情况进行统计,结果如图11所示,64-bit种子密钥的平均搜索空间约为6-bit,加上对k2的搜索,对种子密钥的搜索空间平均约为22-bit.附录给出了一组实际的攻击实验数据及其结果.图11对64-bit密钥(k0,k1,k3,k4)的搜索量分布图6结语本文提出了在半字节随机故障诱导模型下对Piccolo-80算法的差分故障分析方法,给出了Piccolo算法的一个等价结构,将S-P-S结构整体视为超级S盒,并根据所采用的故障模型研究了超级S盒的部分差分传播性质.理论分析和实验结果表明,在第24轮的第1个和第3个寄存器各诱导1个随机半字节故障,可将80-bit的密钥空间缩小至约22-bit.Page8这表明为安全使用Piccolo算法,在其实现时必须做一定的防护措施.
