Page1一个高效BDD的简洁实现苏开乐1),2)吕关锋3)宋炯1)1)(浙江师范大学数理信息工程学院浙江金华312004)2)(清华大学清华-阿姆斯特丹逻辑学联合研究中心北京100084)3)(北京工业大学计算机学院北京100022)摘要二叉判定图BDD作为一种表示和操作布尔函数的数据结构,被广泛地应用在模型检测、系统验证等领域.在最坏情况下,BDD的空间规模是指数级的,因此为了设计和实现一个高效BDD包,研究者们做了大量技术性工作,同时涌现出多个高效BDD包.为了节省空间和提高运算速度,这些BDD包的实现都限定了一个较小的变量个数上限(不超过216),然而这种限定同时也限制了BDD包的适用性.为了突破这种限制,文中给出了一个高效的BDD包实现,该包在采纳了经典BDD包高效实现技术的同时,使用了内存分片分配、轻量级垃圾回收等技术.这些技术使得BDD包在保持高性能的情况下,将可处理的变量规模提高到232,与现有BDD包的处理规模216相比,大大提高了BDD包的适用性.实验证明其性能非常接近可获得的最快的216变量规模的BDD包———CUDD.关键词二叉判定图;布尔函数;内存分配1引言二叉判定图(BinaryDecisionGiagram,BDD)作为布尔函数的一种等价表示形式,最初被成功应用在模型检测[1-2]、系统验证[3]等领域.由于BDD所具有的压缩表示特点,使其作为一种重要的数据结构得到了越来越广泛的应用,如知识表达与推理[4]、命题公式可满足问题(SAT)[5]、安全协议验证[6]、网络可靠性测量[7-8]等.尽管BDD是对布尔函数的一种压缩表示(与真值表等价),但其对空间的需求仍然很高,有可能是指数级的;同时时间复杂度在最坏情况下也是指数级的(因为判定一个布尔公式是恒真式问题是co-NP的).为了节省空间和赢得时间,现有的BDD包的实现,往往使用16位比特来表示变量,这就意味着,BDD包最多能够支持216(65536)个变量.216个变量对于一些应用领域来说显然太小,例如对于命题公式可满足问题(SAT).为了提高求解SAT问题的效率,Franco[5]把BDD作为预处理工具,而SAT问题中公式的变量数可能是10万级甚至100万级;作者在研究安全协议验证[6]问题时,为了提高处理速度和压缩空间,在生成验证规范过程中使用BDD来表示中间结果,而其变量数也很可能超过216个.所以216这个变量上限极大地限制了BDD包能够处理的问题规模,从而限制了BDD包的应用.因此一个高效的可处理大规模变量的BDD包成为一种现实需求.本文给出了一个BDD包的实现,其主要优点或目标体现在:用32位比特表示变量,即可处理变量数达到232;速度可比目前可获得的最好的BDD包;实现目前BDD包的所有重要算子;用标准C++实现,做到代码简洁,接口明确,便于用户使用(目前开源的高效BDD包实现都较复杂,甚至与平台具有一定相关性,不方便用户使用).第2节给出BDD及经典BDD包高效实现的扼要介绍;第3节给出新BDD包的实现技术;第4节给出实验结果;第5节讨论相关工作,总结全文,并指出下一步工作.2二叉判定图BDD是一种表示布尔函数的高效方法.它首先是作为二叉判定树(BinaryDecisionTrees,BDT)被提出的.在BDT中,每个非终结节点被布尔变量x,y,z,…标注(记为var(v),v为节点),终结节点用1或0标注,每个非终结节点v有两个后继节点,记为low(v)(当v赋值0时)和high(v)(当v赋值1时).BDT不是布尔函数的高效简洁表达方法,因为它大小和真值表一样.Bryant在文献[9]中阐明如何通过使用两个限制来得到BDD的规范表达:首先,变量出现的顺序要保持一致;其次,不存在同构的子树和多余的节点.概括起来,有3种方法可得到BDD的简洁规范形式:(1)删除多余终结节点:只留下一个(1或0,或两者)终结节点,删除其余终结节点,并使指向被删除终结节点的连接指向剩下的相应节点.(2)删除多余的非终结节点:如果一个节点n的Then和Else边都指向节点m,则删除n节点,并且把指向它的所有连接都指向m节点.(3)如果二个非终结节点u和v有var(u)=var(v),low(u)=low(v)并且high(u)=high(v),则删除u或v,并且重定向所有指向它的连接指向另一节点.重复上述方法,直到BDD的大小不再改变,则得到BDD的唯一规范表示(ROBDD)[9].这可通过一从底向上的过程得到,时间复杂度是线性时间.经典的BDD包的高效实现主要采用了以下几项技术[10].2.1节点的表示节点的结构中主要包括变量以及两个后继节点Then和Else.我们一般称该变量为顶变量(TopVariable).在BDD中每个节点都表示一个布尔函数,而顶变量就表示在整个布尔函数中最小的变量.这种节点的定义方式,思想主要来自ITE(If-Then-Else)算子.ITE(If-Then-Else)算子F,G,H为布尔函数,ITE(F,G,H)定义如下:ITE(F,G,H)=F×G+~F×H;基本的二元逻辑运算都可以通过ITE运算来表示,因此现有的高效BDD包都把ITE算子作为实现核心,即把每个节点都表示为ITE(v,Then,Else),当变量v取值为1时该布尔函数等价于Then节点表示的布尔函数,否则等价于Else节点表示的布尔函数,例如:A+B+C=ITE(A,1,ITE(B,1,ITE(C,1,0))).ITE实际上是一个递归的运算,它的实现过程如下所示.Page3ITE(F,G,H)If是终结情况ElseIf在计算表中找到该节点(F,G,H)ElseENDIF2.2唯一表在BDD的生成过程中会产生大量的节点,能够有效地管理这些节点对于实现一个高效的BDD包是非常重要的.而唯一表(UniqueTable)的作用就是管理BDD中所有的节点.为了维持BDD的规范性,唯一表一般是采用哈希表的结构,它将一个三元组(v,G,H)同节点F=(v,G,H)映射.每个节点在唯一表中存在一个入口,即每个节点在唯一表中都有一个唯一的ID(索引),所以当添加一个节点时,需要对唯一表进行查找,判断该节点是否已经存在.若存在则将该节点返回,否则添加新节点,以此来维持BDD的规范性.唯一表可以通过这种方式建立一个多根的BDD节点图来表示出所有用户布尔函数.2.3计算表在生成BDD的过程中会产生很多的中间结果,计算表(ComputedTable)就是一个存储运算结果的哈希表.它将一个三元组(F,G,H)同该操作的结果进行映射.当构建BDD节点的时候,如果ITE(F,G,H)已经在计算表中,并且该结果已经找到,就可以快速地将结果返回而不需要进行重新计算.因此计算表可以有效地提高运算的速度.但在处理冲突的方式上,它同唯一表有所不同.唯一表中处理冲突的方式是产生一个冲突链,而计算表为了节省运算中消耗的空间,它并不存储所有的运算结果,而是将旧的结果冲掉,并存储新的结果.2.4垃圾回收机制为了节省空间,必须对死节点进行删除.文献[9]中提到垃圾回收(GarbageCollection)虽然会消耗一定的时间但会节省出大量的空间,所以应该适当地调用垃圾回收.在执行垃圾回收过程中对于是否删除某节点,判定的标准是该节点的参考次数(RefCount).当垃圾回收启动的时候会删除掉所有参考次数等于0的节点,即死节点.当死节点的个数达到一定程度的时候就启动垃圾回收机制将所有死节点进行删除.对死节点参考次数的更新是一个递归运算.如果节点的参考次数更新为0时,它的Then,Else下的所有节点的参考次数也会递归地减少.当查询计算表返回的是死节点(还没有被删除)的时候,会执行复苏操作,将该节点下的所有死节点复苏.2.5补边在BDD运算中可能会产生节点G和节点~G(G的取反操作),二者除了终端节点互换以外,其他性质都是一样,因此补边(ComplementEdges)作为一种能够有效提高空间利用率的方法被提出来.在生成过程中只对G分配空间,对~G不再额外分配空间,只需要对节点指针的最后一位进行标识,如果最后一位为1就是~G,否则为G.3新BDD包的高效实现技术主要体现在几个关键技术上:节点表示、唯一表、垃圾回收、计算表等.具体如下.3.1BDD节点的表示structDDNode{intVar;intRefCount;intThen;intElse;intNext;}.在经典的BDD包实现中,为了节省空间(从而提高速度)往往把Var(变量编号)和RefCount(参考次数)合在一个int中,Var被分配16比特,Ref-Count被分配不超过16个比特.所以当RefCount超过216时,该节点将永远不会被删除.而这里,RefCount用32个比特表示,这样死节点不被删除的可能性极小,从而提高空间利用率.DDNode的总长度是20个字节.同时使用了补边技术,即用节点地址最低比特位表示该BDD是否为补.3.2唯一表同传统思想不同的是我们并没有直接对唯一表Page4采用哈希表的结构而是先将它进行划分.划分的标准就是节点的顶变量的不同,根据不同将它划分为多个模块(模块的个数等于变量个数),其中每个模块都采用哈希表的结构.它的结构如下.#defineDDint//DDNode地址typedefstructUTableNodeStruct{DDSlot;//内存块;DDNode地址集合intSlotSize;//内存块长度intLoadCount;//填充个数intShiftSize;//偏移值}UTableNode;当插入新的节点时,我们不再将一个三元组(v,G,H)同节点F=(v,G,H)直接映射,而是首先根据节点顶变量的不同,将节点划分到唯一表的不同模块中,然后根据(G,H)将该节点映射到指定模块的哈希表中.我们这样做的好处主要是先通过顶变量将节点最大限度分散开,避免由于节点集中而造成冲突链过长的问题,从而提高节点查找效率.并且每个哈希表的映射只有两个变量,这样将有益于提高查找命中率.我们将每个模块的SlotSize初始为一个较小的值(256),当LoadCount达到一定程度时再对它进行扩容,这样可以有效地节省空间,提高空间的利用率.另外由于采用的是内存连续分配的技术,使得查找过程比采用链表的方式更节省时间.相对于当今的高速CPU,主存的延迟是BDD包性能的主要瓶颈[11].所以对于BDD节点,我们采用了内存分片分配的技术来实现,主要思想如下.(a)初始化:分配连续k兆空间(比如k=50);(b)新增加节点时,如果现有空间足够,则插(c)新连续分配k兆空间,插入新增节点.新增节点算法伪代码如下:Find_or_Add_Unique_Table(v,A,B)//v是变量,A、B为BDD节点pos=该节点在唯一表中的位置R=在pos位置下查找该节点IfR不为空,即该节点已经存在ReturnREndifIf装载率超过阈值重新分配更大的空间;EndifNode=从节点管理器中获取空闲节点位置设置节点Node属性将该节点插入到唯一表中ReturnNode入,否则转(c);这使得内存的使用是成块递增的,在一定程度上保证节点在内存中距离较近和满足时间序(即子节点在父节点之前创建).这样做的好处主要体现在提高CPUCache的命中率,从而提高BDD运算速度[11].3.3垃圾回收在创建BDD的过程中会产生大量的垃圾节点,在传统的高效实现过程中,为了节省空间,提高查找速度,当死节点的个数达到一定程度的时候,就启动垃圾回收机制将所有死节点进行删除.但这种对内存的不断分配和释放过程往往会造成空间利用率不高.为了提高内存的重用性,我们并没有在内存中真正删除死节点,只是做了一个标记,当需要分配新节点时,根据这个标记,可判断是否重用该节点空间.从而避免了对内存的不断释放和申请.垃圾回收是以牺牲时间来换取空间的方法,所以对垃圾回收的调用必须有一定的限制.因此我们为了保证空间利用率,同时方便用户使用,在初始情况下允许用户自主决定垃圾回收的调用条件,在计算过程中,根据节点的产生情况对该条件进行适当调节.这样既不会高频率地调用垃圾回收,又不会因垃圾节点过多而导致空间不足的情况,最大限度地提高了空间利用率.算法伪代码如下:Garbage_Collection()For每个内存分片Endfor//---------处理计算表---------------//For计算表中每个位置Endfor//------------处理唯一表------------//For唯一表中每个位置Endfor3.4计算表尽管我们采用了内存分片分配,但是在计算时,仍然以节点地址作为操作数,所以计算表的实现仍Page5然与经典的BDD包高效实现保持一致[10].4实验结果根据本文提出的技术思想,我们用标准C++实现了一个BDD包(记为MiniBDD①),代码量接近1200行.我们实验环境是Pentium4PC2.8,1GB内存,Linux操作系统.对比对象是著名的BDD包———CUDD(http://vlsi.colorado.edu/~fabio/,版本2.4.1).测试用例为SuperscalarSuite1.0(trace格式)②.实验结果如表1所示,并图形化显示为图1.测试用例时间dlx2_cc_bug01dlx2_cc_bug02dlx2_cc_bug03dlx2_cc_bug04dlx2_cc_bug05dlx2_cc_bug06dlx2_cc_bug07dlx2_cc_bug08dlx2_cc_bug09dlx2_cc_bug10dlx2_cc_bug11dlx2_cc_bug12dlx2_cc_bug13dlx2_cc_bug14dlx2_cc_bug15dlx2_cc_bug16dlx2_cc_bug17dlx2_cc_bug18dlx2_cc_bug19dlx2_cc_bug20从表1可以看出,MiniBDD运算速度和CUDD非常接近(平均时间之比为1.0651,图1中大部分点落于主对角线附近区域内).内存方面:二者节点数一样,MiniBDD每个节点20字节(232个变量规模),而CUDD为16个字节(216个变量规模).由于MiniBDD采取的是内存分片分配策略,因此MiniBDD的内存消耗可能会比4×NodeCount多一部分,多出的这一部分最多是内存分片的大小,平均情况下,多出的部分是内存分片大小的一半.当然,内存分片大小是可控的,我们可以根据实际应用环境适当调节分片大小,在保证性能的情况下尽量减少内存的消耗.5相关工作及结论为了在BDD操作中提高高速缓存的性能,Long在文献[11]中提出了节点在内存中连续分配的策略,但没有做分片处理,同时所有节点都必须严格遵守在时间序上的一致性.这样一来,在垃圾回收的时候,工作量较大,并且非常复杂.Janssen[12]也采用类似内存分配策略,但不再使用指针来标注节点,而是用一个和节点位置相一致的整数表示,同时也要求所有节点都必须在时间序上保持一致,垃圾回收同样非常复杂.二者的BDD包可处理的变量个数上限都是216.为了突破现有高效BDD包对变量个数的限制(不大于216),本文给出了一个最多支持232个变量的高效BDD包的实现技术.该BDD包对空间的利用率很高,主要体现在:(1)在内存上采取分片分配;(2)垃圾回收过程不删除节点(只是将死节点进行标识)这种轻量级的垃圾回收机制;(3)唯一表使用动态分配内存的方法,在BDD的生成过程中根据节点产生情况,自动调节该表的大小.我们使用标准C++完整地实现了一个高效BDD包———MiniBDD.MiniBDD实现简洁(C++源代码不到1200行),实验证明其性能与著名的BDD包———CUDD的最新版本(2.4.1)非常接近(时间之比为1.0651).在MiniBDD基础上,通过实现动态计算表技术,我们可以得到的一个更为高效版本的BDD包———CacBDD[13].因为变量顺序会直接影响到BDD的大小,所以我们下一步的工作重点是实现变量的动态排序[14].
