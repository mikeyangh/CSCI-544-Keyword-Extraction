Page1面向业务流程的数据模型异常检测方法刘之强李红燕王磊曲强(北京大学信息科学技术学院北京100871)(机器感知与智能教育部重点实验室北京100871)摘要当前,流程驱动的信息系统构建方式得到了越来越广泛的应用.在流程驱动的方式中,流程模型对数据模型有着不可忽视的影响.但是当前的数据模型异常检测方法都是针对数据模型本身的特点而未考虑流程模型.同样,流程模型的验证方法也缺乏对数据模型的考虑.文中提出并分析了面向业务流程的数据模型的异常问题,并给出了其3种基本类型.为了检测这些异常,文中提出了Data-processGraph(DP-Graph)模型,将数据模型和流程模型放在统一的架构下进行研究.而后,基于DP-Graph,文中提出了DPGT算法,有效地实现了面向业务流程的数据模型异常检测.文章中的实验结果验证了DPGT算法对于这些异常的高检出率.关键词数据模型异常检测;业务流程管理;工作流模型验证;信息系统构建1引言传统的信息系统构建方式是数据驱动(data近年来,随着业务流程管理[1](businessprocessPage2management)越来越受到重视,流程驱动的构建方式得到了广泛的应用.这种构建方式是指将业务流程模型作为整个系统构建的出发点,通过对流程模型的精化,衍生出诸如数据模型等其它的模型.传统的数据模型的异常检测方法主要关注于数据模型本身的静态属性,比如数据模型本身的约束、是否满足范式要求等.但是,这些方法没有考虑业务流程对数据模型的影响.对于业务流程驱动的信息系统中数据模型的异常检测,需要综合考虑数据模型和业务流程模型的特点.因为即使在数据模型和业务流程模型本身均正确的情况下,仍会出现数据模型相对于流程模型的不一致,即出现数据模型的异常.本文立足于面向业务流程的数据模型异常检测,提出了自己的模型和方法并给出了相应的实验图1CCTV物资管理系统模型片段(2)条件不能被满足.由于数据约束条件value500的存在,任务“材料管理”和“退货”永远不能被执行.(3)数据前提冲突.任务“使用申请”有一个前提数据对象Assetrecord.但这个数据对象是由一个不被触发的任务“库房登记”创建的.这样任务“使用申请”就会执行失败.从以上的应用场景,可以发现在面向业务流程的时候,数据模型会发生一些与流程模型的不一致,即异常.通过日常的项目工作,可以发现这些异常具有如下的3个特点:(1)这些异常在数据模型中是普遍存在的.在结果.为了直观地说明面向业务流程时数据模型会发生的异常,本文给出图1所示的来自CCTV(ChinaCentralTelevision)物资管理系统的模型片段.图1展示了系统中的一个数据模型片段及其对应的流程模型片段(使用BPMN符号[2]表示).综合考虑数据模型与流程模型之间的交互性,在此例中可以发现以下几种由于数据模型不合理导致流程模型出现的异常:(1)数据创建失败.在业务流程中的任务“设备录入”创建Equipmentinfo数据对象,但是此时数据模型中Equipmentinfo其依赖的数据对象Treatment还未创建.CCTV物资管理系统(业务流程模型包含6个子流程,97个任务,数据模型包含124个实体)中,在数据模型与流程模型各自均正确的前提下,发现上述3种错误43个.在实际的医院信息系统中(HospitalInformationSystem)仅住院管理部分就发现了上述错误101个.可见在实际的信息系统构建过程中,数据模型异常的发生是具有普遍性的.(2)某些异常会直接导致系统运行时出错.而解决这次错误要涉及代码级的改动.系统也必须在进行代码改动后重新上线.(3)利用人工的方法来检测这些异常对工作人员素质要求较高.这项工作需要工作人员既熟悉数Page3据模型又熟悉业务流程模型.并且从上面的CCTV物资管理系统和HIS的例子也可以发现,实际项目中数据模型和业务流程模型的庞大也使得人工检测这些异常变得枯燥乏味.因此,寻求自动化的方法来高效而准确地发现这些异常十分具有现实意义.解决面向业务流程的数据模型异常检测问题是具有挑战性的.发生这些异常的时候,数据模型和业务流程模型本身都是正确的.这些异常的产生从根源上来说是由于数据模型与流程模型之间的不一致性.因此,想要检测这些异常就必须将数据模型和流程模型二者联系在一起.但此前并没有建立这两者之间联系的方法.为了解决这个问题,本文提出了Data-ProcessGraph(DP-Graph)模型来联系这两个模型,并给出了DPGT方法来检查这些异常.本文第2节主要讨论一些相关工作;第3节具体分析并给出面向业务流程的数据模型异常问题的分类;第4节提出DP-Graph模型来联系数据模型与业务流程模型;第5节给出DPGT方法来检测面向业务流程模型的数据模型异常;第6节给出相应的实验结果.最后是对全文的总结.2相关工作2.1数据模型异常检测对于数据模型本身的正确性检测,已经有非常成熟的工具[3-4].常见的数据建模工具都提供针对诸如ER模型或者关系模型的检查功能,比如SybasePowerDesigner、ERWin、RationalRoseEnterprise等.这些针对数据模型的检测主要针对数据模型结构方面的异常,例如数据模型的自洽、约束的一致性、是否满足范式要求等静态特征.但这些检测完全没有考虑业务流程对数据模型的影响.在本文后续篇幅中讨论数据模型异常检测问题时,假定所讨论的数据模型已经通过了这些检查,是自身静态结构正确的数据模型.2.2业务流程验证实现面向业务流程的数据模型异常检测,应该了解一些传统的业务流程验证方法.近年来,业务流程验证在流程模型管理领域引起了极大的关注.以往有从多个不同的视角来针对业务流程的研究,比如控制流(controlflow)、数据流(dataflow)和业务流程的时间坐标等.业务流程模型中的控制流的验证方法主要是针对业务流程模型本身来分析其控制流中的异常问题.典型的方法有Petri-net[5-6]、YAWL[7]和UML活动图[8-9]等.为了分析流程模型中的异常,一系列方法比如线性代数[10](linearalgebraic)、有限状态验证[11](finitestateverification)以及可覆盖图形分析[12](coverabilitygraphanalysis)等方法被提出来.一些流程模型验证的工具也被设计并实现了,比如Wofan[13]、WofanYAWL[12]等.但这类方法的主要问题是仅仅考虑了流程模型本身,并未考虑与流程模型相关的数据模型,从而并不支持数据模型的异常检测.当前也有一些基于数据流(dataflow)的业务流程模型验证方法[14-15].这类方法可以检测并发现诸如数据丢失(missingdata)、数据冲突(conflictingdata)以及数据冗余(redundantdata)等.这类方法仅仅考虑了在工作流模型中的数据,并未对静态的数据模型有所考虑,忽略了数据对象之间的相关性.例如数据模型中的依赖性问题,这类方法并不能检测出.在文献[16]中给出了数据模型与业务流程模型之间的相互关系,提出了结合业务流程模型来进行数据模型验证的重要性.但是并没有给出面向业务流程模型的数据模型异常检测方法.3面向业务流程模型的数据模型异常分析的数据产品是由数据模型定义的.作为流程的控制条件.主要有两种情况:流程中任务的执行常常依赖特定的数据对象[16].为了分析面向业务流程的数据模型异常,首先要理解数据模型和业务流程模型之间的交互方式.这种交互方式可以分成两大类:(1)数据产品(dataproducts).业务流程所操作(2)基于数据的控制(data-basedcontrol).数据①任务的数据前提(tasks’datapreconditions).②数据驱动的流程控制(data-basedcontrol).业务流程的控制结构可以被数据影响[16].面向业务流程模型的时候,数据模型之所以后发生异常正是由于这两者之间的交互性,图2从流程模型影响数据模型和数据模型影响流程模型两个维度来分析面向业务流程时数据模型中可能出现的异常.Page4从图2的分析,可以得到基于业务流程模型的数据模型3种基本的异常:(1)数据依赖关系异常DDA(DataDependenceAnomaly).对应第1部分实例中的第1个错误.由于数据对象所依赖的数据对象未创建,流程模型中的任务创建的数据对象不能成功插入数据模型.根本原因是该数据对象所在的数据模型中的依赖关系设计不合理.(2)数据对象定义冲突DDC(DataDefinitionContradiction).对应第1部分的第3个错误.流程中的某个任务的前提数据对象在任务触发的时候仍然未创建,导致任务不能继续执行.这个异常的出现是由于有些数据对象在定义时未考虑到创建该数据对象的任务和将该数据对象作为前提的任务之间的关系.该数据对象必须根据流程的实际情况进行重新定义.(3)数据约束条件冲突DCC(DataCondition图3Data-processGraph实例E=Ddepend∪DCvariable∪Pprecedence∪CTtrue∪CTfalse∪定义1(DP-Graph).DP-Graph是一个有向图,DP-Graph=〈V,E〉,其中V为顶点集:V=Dataos∪D_Constrains∪Task∪Gateways∪Conditions,Contradiction).定义第1部分中的第2个错误.该错误发生的主要原因是数据约束条件的不合理.由于某些不合理的数据约束条件,流程中的某些分支将会永远无法达到.为了检测这3种基本异常,下文提出了DP-Graph以建立数据模型和流程模型之间的联系并给出了DP-Graph的构造方法.而后基于DP-Graph,本文提出了面向业务流程的数据模型异常检测方法DPGT.4Data-ProcessGraph(DP-Graph)在实际的信息系统构建过程中,数据模型与业务流程模型是两个分离的部分.为了对数据模型中的面向流程模型的异常进行检测,必须给出数据模型与业务流程模型之间关系的统一描述模型.通过这个模型,才能把数据模型和流程模型放在一个统一的框架下研究,从而检测出面向业务流程的数据模型中的异常.本文给出了一种DP-Graph(Data-ProcessGraph)模型来描述数据模型与业务流程之间的关系.DP-graph由一组顶点集和一组边集构成,顶点集包含了从数据模型和业务流程模型中抽取的对象,边集用来表达各种对象之间的关系.构建的DP-Graph实例.图3是一个根据图2中的数据模型和流程模型DPpreconditions∪PDcreate∪PDdelete∪Cvariable.顶点集V由5个子集组成:Dataos,D_Constrains这两个集合包含了从数(1)Dataos={d1,d2,…,dv}(v0),是数据对据模型中抽象出来的元素.Page5象集合,其中di是数据对象.(2)D_constrains={dc1,dc2,…,dcp}(p0),是数据约束条件集合,其中dcp是一个数据约束条件,由关于数据对象的谓词表示.Tasks,Gateways,Conditions这3个集合包含了从业务流程模型中抽象出来的元素.(3)Tasks={t1,t2,…,tm}(m1),是业务流程中任务的集合,其中ti是任务.(4)Gateways={g1,g2,…,gn}(n0),是流程控制节点集合,其中gi是控制节点对象.(5)Conditions={c1,c2,…,cu}(u0),是业务流程中控制条件的集合,其中ci是一个控制条件,表示为关于数据对象的谓词.素之间的关系:边集E由9个子集组成:Ddepend、DCvariable这两个集合包含了数据模型元(1)DdependDataos×Dataos,表示数据对象之间的依赖关系,〈d1,d2〉∈Ddepend,表示数据对象d1依赖于d2.(2)DCvariableD_Constrains×Dataos,如果〈dc,d〉∈DCvariable,表示数据对象d是数据约束dc的一个变量.Pprecedence、CTtrue、CTfalse这3个集合表示业务流程模型元素之间的关系:(3)Pprecedence(Tasks∪Gateways)×(Tasks∪Gateways∪Conditions),是流程元素的前驱-后继关系.(4)CTtrueConditions×(Tasks∪Gateways∪Conditions),是触发关系,指的是Condition满足时要触发的流程元素.(5)CTfalseConditions×(Task∪Gateways∪Conditions),是触发关系,指的是Condition不满足时要触发的流程元素.DPpreconditions、PDcreate、PDdelete和Cvariable这4个集合表示了业务流程模型元素与数据模型元素之间的关系.(6)DPpreconditions(Tasks∪Gateways)×Dataos,是业务流程元素对数据对象的依赖关系.(7)PDcreateTasks×Dataos,如果〈t,d〉∈PDcreate,任务t创建数据对象d.(8)PDdeleteTasks×Dataos,如果〈t,d〉∈PDdelete,任务t删除数据对象d.(9)CvariableConditions×Dataos,如果〈c,d〉∈Cvariable表示数据对象d是数据约束c的一个变量.Gateway定义了流程控制流的逻辑节点,与流程的基本控制结构模式相对应,Gateway能表达各种控制流的逻辑分支以及合并的语义.定义2(Gateways).Gateway是一个5元组:Gateway=〈Type,ControlRules〉,其中ControlRules是一组控制流的触发规则,采用Datalog形式定义,型如这条规则表示“如果ta完成而且条件cab满足,则触发任务tb”.控制流的路由通过触发规则表示.以上给出了DP-Graph的定义,现在分析给出DP-Graph的特点:(1)DP-Graph是一个形式化的图定义.它将数据模型与业务流程模型之间的关系通过图的边抽象地表示出来.(2)DP-Graph是一个面向分析的图.它的定义是为了检测数据模型中相对于业务流程模型的异常,忽略了对于该分析没有价值的信息.(3)DP-Graph独立于特定的数据模型和流程模型描述语言.只要有关于数据模型和流程模型足够多的信息,就可以创建出DP-Graph.为了实现基于DP-Graph的异常检测,首先要构建DP-Graph.下面讨论DP-Graph的构建算法.对于一种业务流程构建方式而言,需要根据它的数据模型和流程模型来构建DP-Graph.DP-Graph本质上是一个有向图,可以用邻接表和邻接矩阵的数据结构来表示.根据流程模型和数据模型来构建DP-Graph,可以首先通过对数据模型中Ddepend的分析,生成DP-Graph中数据模型对应的邻接表D-Graph.然后再对流程模型中的Pprecedence、CTtrue、CTfalse元素进行分析,生成DP-Graph与流程模型中对应的邻接表P-Graph.而后DCvariable和Cvariable两种元素可以用邻接矩阵表示.最后再用3组共6个邻接表来表示D-Graph和P-Graph之间的关系DPpreconditioins、PDcreate、PDdelete,便构建出了完整的DP-Graph.可见一个DP-Graph共包括8个邻接表和两个邻接矩阵.具体的构建算法如算法1所示.算法1.DP-GraphConstruction.输入:数据模型dm,流程模型pm输出:DP-GraphDPG变量定义:邻接表DG,PG,DP1,DP2,PDC1,PDC2,邻接矩阵犆犞,犇犆犞1.创建邻接表D-GraphDG,DG的每个节点对应于Page62.ForeveryDdepend中的元素〈Dm,Dn〉3.DG[m]链接n;4.创建邻接表P-GraphPG,5.ForeveryPprecedure中的元素〈Pm,Pn〉和CTtrue中的6.PG[m]链接n;7.ForeveryCTfalse中的元素〈Pm,Pn〉8.PG[m]链接n;9.创建邻接表DP1和DP2来表示DPpreconditions,两个10.同理创建邻接表PDC1和PDC2来表示PDcreate;11.同理创建邻接表PDD1和PDD2来表示PDdelete;12.创建邻接矩阵犆犞和犇犆犞;13.犆犞矩阵的每一行对应一个Conditions,每一列对应14.犇犆犞矩阵的每一行对应一个Constraints,每一列对15.将犆犞和犇犆犞的所有元素初始化为0;16.ForeveryDCvariable的元素〈DCm,DOn〉17.犇犆犞[m][n]←1;18.ForeveryCvariable的元素〈Cm,DOn〉19.犆犞[m][n]←1;20.DG,PG,DP1,DP2,PDC1,PDC2,PDD1,PDD2,下面分析DP-Graph构建算法的复杂度.该算法共需要构建8个邻接表和两个邻接矩阵.设流程模型任务数为t,流程控制条件数为k,控制变量数为l.数据模型数据对象数为d,数据约束条件数为m,约束变量数为n.复杂度为O(4t+4d+kl+mn).图4DP-Graph状态空间5基于DP-Graph的数据模型异常检测本文提出的异常检测方法的主要思想是基于DP-Graph,应用一组状态转移规则,搜索系统的状态空间,从而发现异常状态.首先,本文给出DP-Graph的状态空间.这些状态空间可以看作是真实系统状态的仿真.然后,相关的异常状态的定义也会被给出.最后,本文给出了一些推动算法进程的状态转移规则.5.1状态空间DP-Graph的状态由任务、数据对象和控制条件的状态构成.本节给出了任务、数据对象和控制条件状态定义,并以此为基础定义了DP-Graph的状态空间.定义3(DP-Graph状态空间).DP-Graph的状态空间定义为笛卡尔积:犛dpg=TS×DS×CS,其中TS,DS和CS分别是Tasks,Dataos和Condi-tions的状态空间.其中TS=Tasks{initial,ready,waiting,running,DS=Dataos{defined,undefined,waiting},CS=Conditions{undefined,waiting,图4展示了任务、数据对象和控制条件的状态转移图.其中灰色表示的是与数据和流程一致性异常有关的状态,这将在定义6中详细解释.状态之间的转移即推理规则将会在5.2节中给出详细定义.Page7在系统状态中,有两个特殊的状态需要专门定义,分别是初始状态和结束状态.初始状态标志着系统执行最初的状态,结束状态标志着系统执行的完成.定义4(初始状态).初始状态(startstate)是一个状态向量犛犞start=〈TSV,DSV,CSV〉∈犛dpg,其中并且定义5(结束状态).结束状态(successfulstate)是一个状态向量犛犞successful=〈TSV,DSV,CSV〉∈Sdpg,其中TSV(t)=complete,t=TendDP-Graph可以看作是对业务流程模型和数据模型构成的系统的一种抽象描述.系统执行过程中所能到达的状态是整个DP-Graph状态空间的子集.在第3部分所给出的基于流程模型的数据模型3种异常反应在DP-Graph的状态空间中,就是本文定义6要定义的异常状态.常状态:定义6(异常状态).下面3种状态即为基于流程模型的数据模型异(1)数据依赖关系异常DDA(DataDependenceAnomaly)状态,当且仅当(∧D_Constrains→true(c))∨(∧D_Constrains→f()alsec),其中“∧D_Constrains”代表D_Constrains集合中所有元素的合取.(2)数据对象定义冲突DDC(DataDefinitionContradiction)状态,当且仅当dwaiting()d∨tsuspended(t).(3)数据约束条件冲突DCC(DataConditionContradiction)状态,当且仅当cwaiting()c∨twaiting(t).在图4中,灰色标出的状态是与基于流程模型的数据模型异常有关的状态.5.2推理规则定义本节定义了一组状态转移规则,用来表达DP-Graph的状态转换.应用这组规则,可以进行推理,从而检测可能到达的异常状态.一条状态转移规则表示为一条逻辑语句,形如:ab,其中a是条件,b表示应用规则的结果,下面用t,c,d,g来分别表示task,condition,dataos和gateway4种元素.状态转移规则定义如下,根据它们实际语义的不同分为5个规则组,分别与流程执行的不同环节对应.规则组1(选择).规定处在当前状态的流程可以选择执行的任务.ready(t)∧Pdpd(t)running(t),其中Pdpd(t)d(〈t,d〉∈DPprecondition→defined(d)).如果任务t的全部前提数据都存在,则t进入运行状态.ready(t)∧Pdpswaiting(t).规则组2(操作).表示任务执行数据操作引起的状态转移.undefined(d)∧t(running(t)∧〈t,d〉∈PDcreate∧Pddd(d))defined(d),其中Pddd()dd(〈d,d〉∈Ddepend→defined(d)).如果数据d所依赖的数据全部存在,则任务t可以创建数据d.undefined(d)∧running(t)∧〈t,d〉∈PDcreate→Pddd(d)waiting(d)∧suspended(t).数据d所依赖的数据未创建,则t进入suspen-ded状态,d进入waiting状态,发生异常.running(t)∧defined(d)∧〈t,d〉∈PDdeleteundefined(d);defined(d)∧d,t(〈d,d〉∈Ddepend∧running(t)∧defined(d)∧〈t,d〉∈PDdelete)undefined(d).删除数据d的同时删除所有依赖d的数据对象.规则组3(唤醒).表示数据状态的改变触发相应流程元素状态的变化.waiting(t)∧d(〈t,d〉∈DPpreconditions→defined(d))ready(d);waiting(c)∧d(〈c,d〉∈Cvariable→defined(d))uncertain(c);waiting(d)∧d(〈d,d〉∈Ddepend→defined(d))defined(d);suspended(t)∧d(〈t,d〉∈PDcreate→waiting(d))running(t).规则组4(完成).表示任务完成时状态的改变.running(t)∧d((〈t,d〉∈PDcreate→defined(d))∧(〈t,d〉∈PDdelete→undefined(d)))complete(t).规则组5(触发).表示对后续任务的触发.Page8Pprecedenceover(t)∧ready(t);complete(t)∧(over(t)∨initial(t))∧〈t,t〉∈t执行完成后,开始执行t的后续任务t.complete(t)∧〈t,g〉∈Pprecedenceg.ControlRules;Pttc(t,c)∧true(c)∧〈c,t〉∈CTtrue∧(over(t)∨initial(t))over(t)∧ready(t),其中Pttc(t,c)complete(t)∧〈t,c〉∈Pprecedence;Pttc(t,c)∧false(c)∧〈c,t〉∈CTfalse∧(over(t)∨initial(t))over(t)∧read(t);Pttc(t,c)∧uncertain(c)∧PcanBeTure(c)∧〈c,t〉∈CTtrue∧(over(t)∨initial(t))over(t)∧ready(t)∧true(c),其中Pcanbeture(∧D_Constrains→false(c));Pttc(t,c)∧uncertain(c)∧PcanBeFalse(c)∧〈c,t〉∈CTfalse∧(over(t)∨initial(t))over(t)∧ready(t)∧false(c),其中Pcanbefalse(∧D_Constrains→ture(c)).检测是否存在不可达分支.Pttc(t,c)∧undefined(c)waiting(c).5.3DPGT:基于DP-Graph的数据模型异常检测方法根据前面定义的推理规则,本文提出了面向业务流程模型的数据模型异常检测算法DPGT(DP-GraphbasedDetection).DPGT的基本思想是在DP-Graph的基础上,应用前面定义的状态转换规则,搜索DP-Graph的状态空间,检查前面定义的异常状态,从而发现面向流程模型的数据模型异常.DPGT基本过程是从初始状态开始,应用状态转换规则,得出所有可能到达的状态,当所有可达状态搜素完毕时算法结束.过程中记录下发现的异常状态.下面是基本的DPGT算法.算法2.DP-GraphBasedDetection.输入:DP-Graphdpg,状态向量狊狏输出:错误状态变量定义:StackSVstack,状态向量狋犲犿狆狊狏,狋犲犿狆狊狏2,1.SVstack.push(SVstart);2.whileSVstack非空3.狊狏=SVstack.pop();4.检查狊狏是否异常状态;5.if狊狏不是“结束状态”;6.rs←所有“就绪”状态的任务;7.if(rs非空)8.报告非正常终止(死锁);9.else10.forrs中的每个任务11.犜犲犿狆狊狏←狊狏;12.应用“choose”(dpg,狋犲犿狆狊狏);13.应用“operation”(dpg,狋犲犿狆狊狏);14.应用“awaken”(dpg,狋犲犿狆狊狏);15.应用“complete”(dpg,狋犲犿狆狊狏);16.for每个“trigger”规则17.狋犲犿狆狊狏2←狋犲犿狆狊狏;18.应用“trigger”(dpg,狋犲犿狆狊狏2);19.if狋犲犿狆狊狏2未访问过20.SVstack.push(狋犲犿狆狊狏2);21.endfor22.endfor23.endwhile以下是对DPGT算法进行复杂度分析.DPGT算法的本质是按照多个不同的执行序列来依次模拟地执行流程中的各个任务,在执行的过程中发现数据模型的异常.不妨设执行一个任务的平均时间为1,算法复杂度的关键便是检测并行分支中的不同任务执行序列的个数.假如有m个并行分支,每个分支有n个任务,可能的执行序列个数是Cn3n×…×CnCn的状态,故总的复杂度为O(Cnmn×mn).Cn6实验本次实验是基于CCTV物资管理系统来进行的.中央电视台物资管理系统包含了复杂的业务流程模型和数据模型,业务流程模型包含6个子流程,97个任务,数据模型包含124个实体.业务流程的构建以及任务操作的描述在PASE[17]中完成.该系统是一个典型的信息系统.首先用文献[14]中提出的工作流模型中的data-flow验证方法进行实验.在相关工作部分已经分析过该方法是基于流程模型中的动态数据,并不针对于数据模型.这种方法对于数据对象定义冲突(DDC)异常(对应于该方法中的missingdata情况)在流程模型中可以检测出来.但由于其并未考虑数据模型中的依赖关系和约束条件,其对于其它两类异常是无能为力的.表1是这种方法在CCTV物资管理系统中的实验结果.该表列出了异常发现的数量.这些异常便是第3部分提出来的数据依赖关系异常(DDA)、数据对象定义冲突(DDC)以及数据约束条件冲突(DCC).Page9检测项目实际数量检测数量异常检出率/%DDA数量10DDC数量21DCC数量12异常总数43下面便对DPGT方法实现的模型验证器在系统设计中进行了试用.表2是DPGT方法的实验结果.表2DPGT在CCTV物资管理系统上的实验结果检测项目实际数量检测数量异常检出率/%DDA数量10DDC数量21DCC数量12异常总数43DPGT方法对于这3种异常均有较高的检出率,即其在检测面向业务流程的数据模型异常方面是非常有效的.这些异常有很多是隐蔽的,在模型设计中经常被忽略.DPGT方法的应用减少了这种错误,使得系统模型更加规范,增强了系统健壮性,减轻了系统测试和修改的工作.有些异常DPGT方法并没有检出,但是可以通过系统测试发现,经过分析仍然划归流程-数据一致性导致的数据模型异常.异常的检出率并未达到100%,原因在于CCTV物资管理系统流程中包含一些现阶段的DPGT算法尚未完全支持的高级流程模式[18]和即席流程[17]定义.7总结和展望随着流程驱动的建模方式的广泛应用,数据模型面向业务流程的异常也越来越频繁地出现,而并没有现成方法来自动化地检测这些异常.本文提出并分析了基于流程模型的数据模型异常并将这些异常分成数据依赖关系异常、数据对象定义冲突、数据约束条件冲突三类.为了实现自动化地对这些异常进行检测,本文提出了DP-Graph模型来联系数据模型和流程模型并基于DP-Graph提出了DPGT异常检测方法.文章给出了DPGT算法在CCTV物资管理系统项目中应该的实验结果,验证了DPGT算法检测面向流程模型的数据模型异常的高检出率,证明了该方法在实际模型构建中的实用性.在以后的工作中,会增加DPGT检测算法对即席流程[15]的支持.
