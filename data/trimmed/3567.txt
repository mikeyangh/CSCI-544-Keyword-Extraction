Page1物联网环境下LED轻量级密码算法的安全性分析李玮1),2),3)谷大武2)赵辰1)刘志强2)刘亚2)1)(东华大学计算机科学与技术学院上海201601)2)(上海交通大学计算机科学与工程系上海200240)3)(上海市信息安全综合管理技术研究重点实验室上海200240)摘要LED算法是于2011年CHES会议中提出的一种新型轻量级密码算法,用于在物联网环境下保护RFID标签以及智能卡等设备的通信安全.文中提出并讨论了一种针对LED算法的差分故障攻击方法.该方法采用面向半字节的随机故障模型,通过在LED算法中导入故障,分别仅需要3个错误密文和6个错误密文,即可恢复LED算法的64bit和128bit原始密钥.实验结果表明,针对LED算法的差分故障攻击方法不仅扩展了故障诱导的攻击范围,而且提高了故障诱导的效率,减少了错误密文数,从而为故障攻击其它轻量级密码算法提供了一种通用的分析手段.关键词物联网;RFID;轻量级密码算法;LED;差分故障分析1引言随着信息技术、计算机技术以及微电子技术的Page2法却无法很好地解决,主要原因是物联网上使用的应用组件不同于传统的台式机和高性能计算机,是计算能力相对较弱的微型计算处理设备,运算存储能力有限.所以,数据安全受到极大威胁.在这种情况下,轻量级密码算法受到人们的广泛关注.与传统密码算法相比,轻量级密码算法的执行效率更高、计算资源消耗更少、适合计算能力有限的RFID(RadioFrequencyIdentification,射频识别)标签等微型计算设备使用.在2011年召开的CHES会议上Guo等人[1]提出的LED算法就是这样一种典型的轻量级密码算法,与其它轻量级密码算法相比,它的软硬件执行效率更高、适应环境能力更强,是轻量级密码算法中的佼佼者.在物联网环境下,轻量级密码算法的许多硬件实现和以硬件为表现形式的软件实现环境中,譬如RFID标签、智能卡、密码协处理器、密码芯片等,攻击者往往不仅具备传统密码攻击的条件,而且还可以通过电路剖析和软件逆向分析等手段获得算法的硬件实现结构和编码实现方法,并可以观察和测量密码变换信息,“干预”密码变换的正常运行使其出错.攻击者利用这些额外出错信息有可能实现比“黑盒攻击”更有效的密码破译.人们通常把这种环境下的攻击称为“故障攻击(FaultAnalysis)”[2].在故障攻击中,差分故障攻击(DifferentialFaultAnalysis,DFA)较容易实施且最难防御,攻击者通常只需获得密码器件的几个或几十个故障密文,就能以很低的计算量和存储量达到很高的成功率[3].因此,差分故障攻击凭借其成功的攻击效果和潜在的发展前景,已成为密码分析和密码工程领域发展最为迅速的方向之一.目前,LED算法的安全性研究仅限于传统密码分析,例如差分分析、线性分析和代数攻击等[1].在抗差分故障攻击的安全性方面,国内外尚未发现有公开发表的结果.因此,研究LED算法的安全性,提出有效的差分故障攻击方法,对于保护物联网的通信安全,对于增强密码设备的自主设计、开发和分析,无疑具有重要意义.在深入分析和测试LED算法后,本文提出了一种针对LED算法的高效差分故障攻击方法.该方法针对物联网的环境特性,结合了随机故障模型和差分分析,以较少的故障密文数即可恢复原始密钥.结果表明,本文提出的方法仅需要3个和6个错误密文即可分别破译LED算法的64比特和128比特原始密钥.本文第2节介绍差分故障攻击的相关工作;第3节简单介绍LED算法;第4节提出差分故障分析LED算法的方法;第5节针对不同故障模型下,给出扩展的差分故障攻击方法;第6节给出攻击的计算复杂度分析;第7节介绍实验及相关结果分析;第8节总结并指出下一步的研究方向.2相关工作差分故障攻击方法是一种新型的密码分析方法.1997年,Biham和Shamir[3]针对DES算法首次提出了差分故障攻击方法.该方法先在算法运行时引入故障,使算法执行某些错误的操作、过程,并产生错误的结果,再利用这些结果,结合算法自身的数学特性和差分分析,破译出算法的关键信息(密钥).后来根据不同的基本假设和故障模型,研究学者对AES算法进行了深入的研究[4-9].DES算法和AES算法的破译历程为其它密码的差分故障攻击奠定了坚实的基础.后来,SMS4[10]、ARIA[11]、PRESENT[12]、KEELOG[13]等算法相继被验证具有差分故障攻击的隐患.从差分故障攻击方法的发展情况来看,成功实现该方法需具备两个重要条件,即基本假设和故障模型.基本假设是差分故障攻击成功实现的外部条件.因为差分故障攻击方法与密码算法的实现环境密切相关,所以分析人员需要能够运行包含密码算法的实体(软件、设备、芯片等),并能够选择和记录实体的输入和输出情况.选择明文攻击是一种常被采用的基本假设.此外,导入理想的故障,实现合适的故障模型,是差分故障攻击成功实现的内部条件.通常,一个故障模型由三元组(时刻、位置、动作)构成:(1)故障时刻.攻击需要精确控制错误发生的时刻,例如在运算进行时,将故障引入到某一个范围内(某些轮).(2)故障位置.攻击需要精确控制错误发生的位置,例如将故障引入到某一指定的记忆单元,包括寄存器的某些位(或半字节、字节).(3)故障动作.攻击需要精确控制错误发生的行为,通常分为设定故障位置的值取反、设定故障位置的值为预定值(已知故障值)、随机设定故障的值(未知故障值).在基本假设一定的情况下,故障模型的选择范围越宽,则说明此分析技术适用范围越广.在基本假Page3设和故障模型一定的情况下,攻击所需要的故障密文数越少,说明此分析技术的攻击效果越好.因此,在面向密码算法的差分故障攻击方法中,国内外已有的研究工作主要集中在针对一些典型密码算法的安全性实现上,但是由于一些新型轻量级密码算法具有适用于物联网环境中的独特设计结构,其抗差分故障攻击的安全性还尚未被研究.针对这些新型算法,例如LED算法,结合基本假设和故障模型,提出一种适用范围广并且攻击效果好的差分故障攻击方法,对物联网环境下密码算法的安全实现和数据安全,具有重要意义.3LED算法简述LED是一种具有SPN(Substitution-PermutationNetwork,代换置换网络)结构的迭代型分组密码算法,分组长度为64bit,密钥长度分别为64bit或图1LED算法的加密过程加密过程包含了以下5个基本运算:与子密钥进行异或.(1)AddRoundkey(子密钥加变换).中间状态(2)AddConstants(常数相加变换).中间状态(3)SubCells(信元代替变换).将中间状态中的与常数相加.128bit.根据密钥长度的不同,加密过程对应的轮数分别为32轮和48轮,表示为LED-64和LED-128,如表1所示.由于解密过程与加密过程的结构相同,并且子密钥的使用顺序相同,因此本文仅介绍加密过程和密钥编排方案.密码算法分组长度/bit密钥长度/bit轮数LED-64LED-12864用Ze2中的元素称为半字节.LED算法中使用的基3.1术语说明节,Z4本运算主要有异或()、乘法(·)和连接(‖).3.2加密过程为X=(X0,X1,…,X15)∈(Z4(Y0,Y1,…,Y15)∈(Z4密钥K1∈(Z4LED算法的加密过程如图1所示.设明文输入每4bit通过S盒非线性地变换为另外一个半字节.(4)ShiftRows(行移位变换).对一个状态的每一行循环不同的位移量.第零行移位保持不变,第1行循环左移4bit,第2行循环左移8bit,第3行循环左移12bit.(5)MixColumnsSerial(列混合变换).对一个Page4状态逐列进行变换,通过与矩阵相乘实现.算法2所示,轮数l分别为32轮、48轮.LED-64和LED-128的加密过程分别如算法1、算法1.LED-64加密过程.输入:X,K输出:YSTATE=X;fora=1to8doendforY=AddRoundKey(STATE,K1).算法2.LED-128加密过程.输入:X,K输出:YSTATE=X;fora=1to6doendforY=AddRoundKey(STATE,K1).在LED-64算法中,K通过密钥编排方案生成3.3密钥编排方案了K1,它们的关系为在LED-128算法中,K通过密钥编排方案生成了K1和K2,它们的关系为4LED密码的差分故障攻击方法4.1基本记号和符号记X∈(Z4分别为密文、错误密文、差分密文,K∈(Z4始密钥,K1、K2∈(Z4记MCr-1为第r轮AddConstants运算的输入,ACr为第r轮SubCells运算的输入,SCr为第r轮ShiftRows运算的输入,SRr为第r轮Mix-Columns-Serial运算的输入,其中,1rl.记ΔMCr-1为第r轮AddConstants运算的差分输入,ΔACr为第r轮SubCells运算的差分输入,ΔSCr为第r轮ShiftRows运算的差分输入,ΔSRr为第r轮MixColumnsSerial运算的差分输入,其中,1rl.记AddConstants-1、SubCells-1、ShiftRows-1和MixColumnsSerial-1分别为AddConstants运算、SubCells运算、ShiftRows运算和MixColumns-Serial运算的逆运算.此外,第r轮SubCells运算的差分输入和差分输出满足IN(ΔACr其中,S表示4×4的S盒变换.4.2基本假设和故障模型本文采用的差分故障攻击的基本假设为:对同一个明文,我们可以获得在同一个密钥作用下的正确密文和错误密文.LED算法采用半字节为基本单位的运算,因此,我们采用面向半字节的随机故障模型,诱发加密算法中单轮运算存储的单元发生4bit的随机错误,而且无需知道具体错误位置和错误值.在本节中,单轮运算的轮数指LED-64算法中的倒数第3轮,或LED-128算法中的倒数第3轮和倒数第7轮.4.3基本步骤1.选择任一明文进行加密,获得该明文对应的正确密文.2.当LED算法的加密过程运行到倒数第3轮运算时,在此轮进行故障诱导,并获得错误密文.结合差分分析,能够恢复出该轮子密钥的部分信息;重复这一环节,直至完全恢复出子密钥K1.如果原始密钥为64bit,转向步4;否则,转向步3.3.选择相同明文和原始密钥再次进行加密,当加密过程运行到倒数第7轮时,对此轮进行随机故障诱导,从而获得错误密文.然后,利用步2中已经恢复出的子密钥K1,对最后4轮进行解密;由解密得到的中间值,结合差分分析,恢复出该轮子密钥的部分字节信息;重复这一过程,直至完全恢复出子密钥K2.4.使用已经恢复出子密钥,根据密钥编排方案,计算出Page5原始密钥的值.4.4具体过程正确密文Y.1.随机选择一个明文X,获得在原始密钥K作用下的2.恢复子密钥K1,过程如下:对明文X在原始密钥K作用下再次加密,当算法运行到倒数第3轮的AddConstants(或SubCells、ShiftRows、基于半字节随机故障的基本假设,计算ACl的第j个字节值满足图2LED算法最后3轮中的故障扩散路径j和ΔACl其中0j15,ΔSCl通过收集相同明文和不同故障导致的多个故障密文,利用ΔSClACl的唯一值.在实际运算时,仅根据上述公式进行推导,j的值难以唯一确定,且计算复杂度较高.在后文4.5节ACl中,我们提出了一种高效方法推导出ACl的唯一值.在ACl的唯一值确定后,计算MCl的值:MCl=MixColumnsSerial(ShiftRows(SubCells(ACl))),因此,K1的值为3.如果原始密钥长度为128bit,需对明文X在密钥K作用下再加密,当算法运行到倒数第7轮(即第42轮)时,诱导其输入产生4bit的随机故障.根据步2推导出的K1直接解密最后4轮运算,获得倒数第5轮(即第44轮)的输出值为AddConstants-1(ACl-3),则推导出倒数第5轮SubCells运算的差分输出值为ΔSCl-4=ShiftRows-1(MixColumnsSerial-1(ΔMCl-4))=ShiftRows-1(MixColumnsSerial-1(AddConstants-1(ΔACl-3)).利用关系:j)S(ACl-4S(ACl-4收集相同明文和不同故障产生的多个错误密文,利用MixColumnsSerial)运算时,诱导其输入发生4bit的随机故障,由此得到的故障密文记为Y,则计算差分密文的值为故障导入后的扩散图如图2所示,则ΔSCl为ΔMCl=(YK1)(YK1)=ΔY,ΔSCl=ShiftRows-1(MixColumnsSerial-1(ΔMCl))ΔSCl-4和ΔACl-4之间的关系,循环运算取ACl-4的交集,直至恢复出ACl-4的所有字节,进而推导出K2的值:K2=MCl-4AddConstants-1(ACl-3)=MixColumnsSerial(ShiftRows(SubCells(ACl-4)))AddConstants-1(SubCells-1(ShiftRows-1(MixColumnsSerial-1(AddConstants-1(SubCells-1(ShiftRows-1(MixColumnsSerial-1(AddConstants-1(SubCells-1(ShiftRows-1(MixColumnsSerial-1(AddConstants-1(SubCells-1(ShiftRows-1(MixColumnsSerial-1(YK1)))))))))))))))).4.根据密钥编排方案,计算出原始密钥K的值.在LED-64算法中,K=K1;在LED-128算法中,K=K1‖K2.4.5推导犃犆犾的高效方法在诱导故障的过程中,我们发现4bit随机故障值通过第l-2轮SubCells、ShiftRows和MixCol-umnsSerial的运算后,会影响到下一轮AddConsta-nts输入的16bit,这16bit继续影响到密文输出的全部字节.在步2中,为了恢复出子密钥的值,如果直接采用穷尽搜索ACl的方法,计算复杂度将达到264,并且难以恢复出它的唯一值.这样的穷尽搜索方法在实际中将降低攻击的速度.因此,本节提出一种有效的运算方法,充分利用故障扩散的关系来计算ACl.在已知差分密文的情况下,第l轮SubCells运Page6算满足以下差分关系(ΔY0,ΔY7,ΔY10,ΔY13)=(S(ACl(ΔY1,ΔY4,ΔY11,ΔY14)=(S(ACl(ΔY2,ΔY5,ΔY8,ΔY15)=(S(ACl(ΔY3,ΔY6,ΔY9,ΔY12)=(S(ACl如图2所示,在第l-2轮AddConstants运算中诱导半字节的随机故障后,我们观察到加密过程中含有一个重要的特性:ΔACl中包含16个非零半字节差分值,这16个值是由ΔACl-1中的4个非零半字节差分值扩散而成,并且ΔACl-1中的4个非零半字节差分值是由ΔACl-2中的随机半字节故障值扩散而成,因此,ΔACl的值满足以下关系式(图3):ΔACl==根据SubCells运算输入输出满足的差分关系,结合半字节故障扩散的路径,认为ΔACl的所有可能值最多为其中,24·22表示第l-1轮ΔMCl-1四列的可能值范围(假设导入故障位置列数一定),22表示故障扩散存在四种情况,如图3所示.由于ΔMCl-1的取值范围与ΔACl的范围相同,且已知ΔY每一列值的情况下,可以逐列求出ACl的值.从而,一次故障导入所需的复杂度降低为如果不利用上述ΔACl的特性,其取值范围为264,搜索空间为全集,难以恢复唯一值.最后,继续导入随机故障,重复上述运算,直至恢复出的ACl中的每个元素仅为唯一值.5扩展的差分故障攻击方法5.1故障位置判断方法基于以上对故障位置和错误密文数的分析,如Page7图3LED算法故障扩散的4种情况果步2中故障没有被导入指定位置(倒数第3轮),而是被导入到最后两轮运算中,这样做的结果必然降低了故障导入的效率,而且增加了恢复原始密钥所需的故障密文数.因此,我们提出一种判断方法用以区分最后3轮运算的导入位置.当随机故障被导入在加密算法中,密文的差分输出与故障的导入位置存在以下3种情况:(1)如果故障被导入在最后一轮运算中,则ACl全部字节中仅发生4bit变化,从而加密过程的Sub-Cells输出全部字节中也只出现4bit变化,记为λ0∈2\{0}.因此,λ0经过ShiftRows运算和MixCol-Z4umnsSerial运算后,密文的差分输出值ΔY必满足下列值之一:{MixColumnsSerial(ShiftRows(λ0,0,0,…,0)),MixColumnsSerial(ShiftRows(0,λ0,0,…,0)),MixColumnsSerial(ShiftRows(0,0,λ0,…,0)),…,MixColumnsSerial(ShiftRows(0,0,0,…,λ0)),λ0∈Z4的差分输出的所有字节出现规律性变化.经统计,共有240(=15×16)个值,因此,密文(2)如果故障被导入在倒数第2轮运算中,则ACl全部字节中仅发生16bit变化,从而加密过程的SubCells运算输出的全部字节中也只含有16bit变化,记为{λ1,λ2,λ3,λ4}∈{Z4λ3,λ4}经过ShiftRows运算和Mix-ColumnsSerial运算后,密文的差分输出值ΔY必属于下列集合:{MixColumnsSerial(ShiftRows(λ1,0,0,0,λ2,0,0,0,λ3,0,0,0,λ4,0,0,0)),MixColumnsSerial(ShiftRows(0,λ1,0,0,0,λ2,0,0,0,λ3,0,0,0,λ4,0,0)),MixColumnsSerial(ShiftRows(0,0,λ1,0,0,0,λ2,0,0,0,λ3,0,0,0,λ4,0)),MixColumnsSerial(ShiftRows(0,0,0,λ1,0,0,0,λ2,0,0,0,λ3,0,0,0,λ4)),{λ1,λ2,λ3,λ4}∈{Z42}4\{0}}.经统计,共有262140(=65535×4)个值,因此,密文的差分输出的所有字节出现规律性变化.(3)如果故障被导入在倒数第3轮运算中,则ACl全部字节中会发生64bit变化,从而加密过程的SubCells运算的输出字节全部发生变化,密文的差分输出值均没有上述规律性变化.因此,为了辨别故障导入的存储单元,仅需计Page8算正确密文Y和错误密文Y的差分输出ΔY.在基本假设中,当故障位置被诱导在加密算法最后3轮中任意存储中间单元时,如果ΔY的值属于262380(=240+262140)个值中的一个,则说明故障导入的位置在存储单元最后两轮中,否则故障导入的位置在倒数第3轮中.这种方法简单易用,可以有效地提高故障导入的效率,并且可以降低恢复子密钥时所需的错误密文数.5.2扩展的故障模型通过采用面向半字节的随机故障模型,分析人员每次诱发单轮运算存储值发生4bit的随机错误,并且无需知道具体错误位置和错误值.此单轮运算指LED-64算法中的倒数第3轮,或LED-128算法中的倒数第3轮和倒数第7轮.在物联网实际环境中,这一故障模型范围较窄,在实际中攻击者具有将故障导入到其它轮位置的能力.因此,我们利用5.1节故障位置分布规律,将故障模型中的单轮运算扩展为以下情况:1.选择明文攻击,获得该明文对应的正确密文.2.在算法加密过程中进行故障诱导,根据差分密文的结构判断出故障导入轮数.如果故障导入轮数不合适,重新诱导故障,直至合适故障出现,并获得所需要的错误密文.利用差分分析,恢复出该轮子密钥的部分字节信息;重复这一过程,直至完全恢复出子密钥K1.如果原始密钥为64bit,转向步4;否则,转向步3.3.利用步2中已经恢复出的子密钥K1,对最后4轮进行解密.在加密过程的倒数第5轮运算之前进行故障诱导,根据倒数第5轮差分输出的结构判断故障导入轮数.如果故算法中的倒数第2轮和倒数第6轮.算法中的倒数第3轮和倒数第7轮.(1)LED-64算法中的倒数第3轮,或LED-128(2)LED-64算法中的倒数第2轮,或LED-128(3)LED-64算法中的倒数第1轮,或LED-128算法中的倒数第1轮和倒数第5轮.值得注意的是,在情况(1)(2)下,差分故障分析可以成功实现并恢复子密钥;在情况(3)下,在没有故障其它信息的帮助下(例如,已知故障的汉明重量),我们依靠差分故障攻击难以直接恢复子密钥,仅能判断故障导入位置.5.3扩展攻击的基本步骤分析人员可以实际条件的不同,选择合适的故障模型.在扩展的故障模型下,攻击方法仍与原方法类似,仅需在子密钥恢复前对故障位置进行判断,从而采取性能更好的差分故障攻击方法.总体而言,基本过程如下:障导入轮数不合适,重新诱导故障,直至合适故障出现,并获得所需要的错误输出.由解密得到的中间值,结合差分分析,恢复出该轮子密钥的部分字节信息;重复这一过程,直至完全恢复出子密钥K2.4.使用已经恢复出子密钥,结合密钥编排方案,计算出原始密钥的值.6复杂度分析在攻击过程中,恢复一个子密钥所需要的故障密文数由故障诱导的位置和故障模型决定.在理想的故障模型下,如果故障发生在最后一轮的运算中,则非线性层的输入中仅有一个4bit发生变化,说明通过差分故障攻击仅能恢复出该轮子密钥的4bit,为了恢复一个子密钥的所有字节,必须诱导大量的故障;如果4bit故障发生在最后一轮之前的某一轮运算中,即该轮非线性层的差分输入和差分输出仅包含一个非零4bit值,线性变换的扩散性使得其差分输出含有多个非零4bit值.因此,经过若干轮运算后,最后一轮非线性层的差分输入和差分输出包含多个非零4bit,依靠这种方法可以提高故障导入的效率.在推导子密钥的交集推导运算中,至少需要两个故障导入,我们通过求候选子密钥的交集直至推导出包含唯一值,因此恢复一个子密钥所需的最少故障密文数理论值为其中,n表示SubCells运算的输出比特数,d表示通过两个故障密文可恢复出的子密钥比特数.如果d=0,则表明攻击没有恢复出子密钥的任何比特,因此最少故障密文数理论值为0.在诱导一个故障发生时,穷尽搜索所需的最大复杂度为其中,n表示SubCells运算的输出比特数,si表示一个S盒的输入比特数,x表示使用S盒进行并行计算的个数.在一个故障模型中,恢复原始密钥所需要的攻击复杂度为其中si为一个S盒的输入比特数,n表示SubCellsPage9运算的输出比特数,d表示通过故障可恢复出的子密钥比特平均数,g表示恢复原始密钥所需要的最少子密钥数目.以子密钥K1的推导为例,本节说明攻击过程的复杂度与故障导入的位置直接相关.在加密算法运算过程中,故障可以被随机地导入最后一轮、倒数第2轮和倒数第3轮运算中的存储单元中.如果故障被导入在最后一轮运算中,那么加密过程中最后一轮SubCells的输入和输出仅发生4bit的变化,此时差分故障分析难以直接恢复子密钥.如果已知故障的某些信息,例如已知故障汉明重量,则差分故障分析可以成功实现.在这种情况下,为了恢复出子密钥K1的所有字节,必须在最后一轮运算中多次导入故障.根据SubCells运算的差分关系,如果要成功恢复出子密钥的4个比特位,即恢复出一j的值,则分析过程至少需要2个不同的错误个ACl密文(故障发生在同一半字节位置,但其错误值可以是随机的,且已知故障汉明重量)即可.因此,要想唯一地恢复出子密钥的全部字节,理论上至少需要32个不同的错误密文.以此类推,要恢复出其它子密钥,理论上至少需要32个错误密文.也就是说,要完全恢复LED算法的64bit和128bit原始密钥,理论上分别至少需要32个和64个错误密文,攻击所需的复杂度分别为和此时,n=64,si=4,x=4,d=4,g=1(LED-64算法)或g=2(LED-128算法).如果故障被导入在倒数第2轮运算中,以导致加密过程中最后一轮SubCells的输入和输出仅发生16bit的变化,为了恢复出子密钥K1的所有字节,必须在倒数第2轮运算中多次导入故障.并且,要成功恢复出子密钥的某16bit,至少需要2个不同的错误密文(故障发生在同一半字节位置,但其错误值可以是随机的).因此,唯一地恢复出子密钥的全部字节,理论上至少需要8个不同的错误密文.以此类推,要恢复出其它子密钥,理论上也至少需要8个错误密文.也就是说,要完全恢复LED算法的64bit和128bit原始密钥,理论上分别需要8个和16个错误密文,攻击所需的复杂度分别为和其中,n=64,si=4,x=4,d=16,g=1(LED-64算法)或g=2(LED-128算法).如果故障被导入在倒数第3轮运算中,则加密过程中最后一轮SubCells的输入输出均发生16个半字节的变化.这样一次故障导入可以恢复出子密钥的16个半字节,要成功恢复出子密钥K1的全部字节,则平均需要2个不同的错误密文(故障可发生在任一字节位置,且其错误值可以是随机的).以此类推,要恢复出其它子密钥,理论上只需要2个错误密文.也就是说,要完全恢复LED算法的64bit和128bit原始密钥,理论上分别需要2个和4个错误密文,攻击所需的复杂度分别为和其中,n=64,si=4,x=4,d=64,g=1(LED-64算法)或g=2(LED-128算法).7攻击实验和结果分析在普通PC机器(CPU为AMDsempron(tm)processor2600+1.60GHz,内存2GB)上我们使用C语言编程实现了本文给出的攻击方法,其中故障诱导得到错误密文的过程用计算机软件模拟,完成了1000组实验.在一定的基本假设下,我们针对不同的故障模型,用以恢复LED算法的密钥.实验基本过程如下:首先,选定一个故障模型,即故障的时刻、位置、动作分别为加密算法倒数第3轮(或倒数第2轮)运算、4bit故障、随机未知故障值;或加密算法最后一轮运算、4bit故障、限定未知故障值;其次,在故障模型下,通过选择明文及相应的正确和故障密文对,对密码算法的执行过程进行差分分析,给出计算子密钥信息的步骤和数学表达式;最后,结合故障位置判断方法,利用计算机程序模拟该故障模型,对实验中得到的数据进行数学处理和计算,求得若干子密钥,结合密钥编排方案求出原始密钥.以LED-64子密钥恢复为例.为了恢复子密钥的唯一值,我们通过收集相同明文和不同故障导致Page10的多个故障密文,运算取ACl的交集,直至恢复出ACl的所有字节.在实验中,我们采用并行恢复ACl的四列值的方式,基于一个正确密文和一个故障密文时,ACl的每一列可能侯选值个数均值为29.4、25.5、28.7以及18.3;基于一个正确密文和两个故障密文时,ACl的每一列可能侯选值相交个数均值为1.0、1.6、1.9、1.3;基于一个正确密文和两个故障密文时,ACl的每一列侯选值个数均值为0.6、0.5、0.6以及0.6.以上数据表明,仅依靠一次故障导入无法推导出ACl任一列的唯一值,也就无法推导ACl的唯一值,即子密钥的唯一值.因此,在差分故障攻击的分析过程中,通常需要使用至少两次故障导入才能恢复子密钥的唯一值,结合LED算法的特性,实验表明:在半字节故障模型下,在第2次故障导入时,利用两次故障求出的候选子密钥集合进行相交,分布如图4所示,其中数目为1的比例为58%,说明子密钥已经被唯一恢复出来的成功率为58%;数目为2及以上的比例为42%,说明其余的子密钥仍存在多个候选值;继续进行第3次故障导入,分布如图5所示,其中数目为1的比例为92%,说明子密钥已经被唯一恢复出来的成功率为92%;数目为2及以上的比例为8%,说明其余子密钥仍存在多个候选值.从以上实验推出,如果仅进行两次故障导入,唯一恢复子密钥的成功率为58%;如果进行三次故障导入,唯一恢复子密钥的成功率为92%.研究结果说明,LED密码不能抵抗差分故障攻击.在面向4比特的随机故障模型下,分析人员可以通过差分密文的特性,检测并判断合适的故障位置.实验表明,每次可以诱发单轮存储中间值发生错误,在恢复子密钥成功率较高的情况下,恢复64bit密钥最少仅需要3个故障密文,恢复128bit密钥最少仅需要6个故障密文,耗时不超过1s.此方法针对物联网环境中的不同设备,因此适应性广,不仅扩大了故障导入范围,而且提高了故障诱导的效率,如表2和表3所示.故障模型理论错误第32轮、4bit、限定3248229230第31轮、4bit、未知812227228第30轮、4bit、未知23225226第48轮和第42轮、第47轮和第43轮、第46轮和第44轮、故障模型理论错误4bit、限定64922302314bit、未知16242282294bit、未知8结束语本文提出并讨论了LED算法抗差分故障攻击的安全性.理论分析和实验结果表明,LED算法易受差分故障攻击威胁.在选择明文攻击下,通过扩展故障诱导的位置至加密算法的最后若干轮运算,能够以较少的错误密文数筛选出候选子密钥,进而恢复出LED算法的原始密钥,达到既扩展故障诱导的攻击范围,又减少错误密文数,提高故障诱导攻击成功率的目的.此方法有助于优化差分故障攻击方法的攻击性能,提高故障攻击的效率和实用性.下一步的研究方向是从故障诱导的随机性和通用算法结构等方面对差分故障攻击方法进行探索,采取措施优化其攻击性能,提高攻击的实用性和效率.在后续的研究中,我们将扩展故障攻击的分析对象,并从软硬件设计和通用算法结构上对差分故障攻击进行探索.致谢感谢本文审稿专家和编辑所提出的宝贵意见和建议!Page11
