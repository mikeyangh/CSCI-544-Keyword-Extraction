Page1基于模糊XML的小枝查询处理刘健马宗民璩秋龙(东北大学信息科学与工程学院沈阳110004)摘要现实世界中存在大量的不精确和不确定信息,因此,针对模糊数据的表示和处理的研究工作已经广泛展开.作为下一代Web语言,XML已经成为当前Web数据表示与交换的标准.不精确和不确定数据的出现对XML提出了新的挑战,现有的研究成果已不能满足模糊XML环境下智能化数据管理的迫切需求.为此,文中在模糊XML数据模型的基础上,从编码技术入手,讨论模糊XML环境下的结点编码问题,进而研究模糊XML环境下的小枝查询问题.文中提出了基于模糊XML的小枝模式匹配算法,给出了加速小枝匹配的索引算法,并最终通过实验证明了所提方法的优越性.关键词Web;模糊数据;XML;小枝匹配;索引1引言随着Web的广泛使用,互联网已成为人们获取信息的主要工具.由于互联网数据存在着异构性,为Page2的子集,其目标是允许普通的SGML在Web上以目前HTML的方式被服务、接收和处理.与HTML相比,XML提供描述结构化数据的格式,具有简单、自我描述的特点.XML是一个格式独立、与平台和应用程序无关的语言,只要应用程序支持XML词汇,就能在应用程序之间无缝的交换数据.因此,处理XML数据的理论和技术成为了数据库领域中的一个研究热点.目前的研究主要包括XML数据模型的研究、XML数据存储、查询和索引等方向.鉴于查询技术在数据管理中的突出地位,如何有效的查询XML数据自然地成为了目前XML方向研究的焦点,引起了学术界的高度关注[1-6].例如,文献[1]中给出了在匹配过程中利用小枝分解查询处理再合并结果的方法寻找匹配解的Stack-Tree算法.但这种分解的方法通常会产生大量无用的中间结果,因此会带来较大的查询开销.为了提高查询效率,文献[2]提出了整体匹配的查询策略,该方法能在仅扫描一次结点的基础上,避免不必要的中间结果的产生,从而保证其高效性.在现实世界应用中,信息通常是不精确和不确定的.现实世界具有主观性,因此,某些数据在本质上是具有模糊性的.例如,对于一部电影的评价,不同的人会有不同的倾向性,其结果必然会导致评分存在不精确和不确定性.基于关系数据模型的模糊关系数据库已经引起了学者广泛的研究[7-9],当前对模糊数据的研究主要集中在不精确和不确定信息概念数据模型、面向对象数据库和模糊数据库概念设计上,而对在XML环境下如何有效表示和查询不精确和不确定信息的研究还很少,只有含不完全信息的XML[10-11]和含概率信息的XML[12-15]在研究文章中有所讨论.文献[15]在简单概率模型和模糊树模型的基础上,分析了概率XML信息的有效表示问题,同时也解决了概率XML的更新问题.文献[12]提出了一种基于概率树结构的概率XML模型ProTDB,该模型将数据信息直接存储在XML数据库中,解决了实际应用中关系数据库难于表述概率结构数据的问题.鉴于小枝查询在XML查询问题中占据核心地位,文献[16]提出了一种基于投影的概率XML小枝查询算法,但该算法需要对XML数据进行重复读取以获得最终匹配结果,这需要较高的代价.借鉴整体匹配的思想,文献[17]利用阈值信息对XML数据进行预先过滤,提升了不确定XML环境下的小枝查询算法效率.从现有的关于模糊XML研究的主要文献来看,该领域虽然吸引了一批学者开展研究工作,但是整体来说研究成果还很少[18-23],特别对模糊XML环境下的小枝查询问题的研究还处于起步阶段,许多重要的理论问题和技术难点当前还是研究空白,现有的研究成果无法满足在模糊XML环境下高效处理数据的需求.为此本文将重点研究如何在模糊XML环境下高效地执行小枝查询.本文讨论了模糊XML环境下的结点编码技术,并在此基础上,设计了一种高效的小枝匹配算法.同时本文给出了适于用模糊XML的索引算法,该算法利用索引加速了无关结点的过滤,进而提升了小枝查询的效率.本文第2节介绍模糊XML数据模型的背景知识;第3节介绍现有的模糊XML结点编码技术;第4节研究模糊XML环境下的小枝匹配问题;第5节讨论如何利用索引提升小枝查询效率;第6节展示实验结果;第7节总结全文.2模糊XML数据模型模糊XML文档中有两类模糊性:(1)一类是元素的模糊性,可使用成员度与这样的元素关联;(2)一类是元素属性值的模糊性,用可能性分布表示这样的值.依据文献[20-21]的介绍可知,一个取值为[0,1]的可能性属性“Poss”应当首先引入,它与一个称作“Val”的模糊构造子共同用于说明一个给定元素存在于XML文档的可能性.以图1中的第3行为例,〈ValPoss=“0.8”〉表明给定的部门“计算机科学与工程”这个元素属于“香港城市大学”的可能性等于0.8.对于可能性为1.0的元素,标签对〈ValPoss=“1.0”〉和〈/Val〉可以从XML文档中省略掉.基于标签对〈ValPoss〉和〈/Val〉,元素的可能性分布可以表示出来,而可能性分布也可以用于表示模糊的元素值.为此,需要引入一个称作“Dist”的模糊构造子,以说明一个可能性分布.一个Dist元素典型地有多个Val元素作为孩子元素,每一个孩子元素带有一个相关联的可能度.例如回顾图1中的例子,第24~34行和第38~44行分别表示学生“TomSmith”的年龄和电子邮件地址可能性分布.应当说明的是,在实际应用中新增加的模糊标签(模糊结点Dist,Val和Poss)可能在源文档中已经存在.此时为了避免混淆,我们可以利用XML命名空间(namespaces)来解决命名冲突的问题.具体来讲,我们将在这些模糊标签前添加独特的标示符(例如用f:Dist,f:Val等表示模糊构造子)用以制Page31.〈universities〉2.〈universityUName=“香港城市大学”〉3.〈ValPoss=“0.8”〉4.〈departmentDName=“计算机科学与工程”〉5.〈employeeFID=“85431095”〉6.〈Disttype=“disjunctive”〉7.〈ValPoss=“0.8”〉8.〈fname〉ChrisFung〈/name〉9.〈position〉副教授〈/position〉10.〈office〉B1024〈/office〉11.〈course〉数据库系统〈/course〉12.〈/Val〉13.〈ValPoss=“0.6”〉14.〈fname〉ChrisFungr〈/name〉15.〈position〉教授〈/position〉16.〈office〉B1024〈/office〉17.〈course〉数据库系统〈/course〉18.〈/Val〉19.〈/Dist〉20.〈/employee〉21.〈studentSID=“96421027”〉22.〈sname〉TomSmith〈/name〉23.〈age〉24.〈Disttype=“disjunctive”〉25.〈ValPoss=“0.4”〉23〈/Val〉26.〈ValPoss=“0.6”〉25〈/Val〉27.〈ValPoss=“0.8”〉27〈/Val〉28.〈ValPoss=“1.0”〉29〈/Val〉29.〈ValPoss=“1.0”〉30〈/Val〉30.〈ValPoss=“1.0”〉31〈/Val〉31.〈ValPoss=“0.8”〉33〈/Val〉32.〈ValPoss=“0.6”〉35〈/Val〉33.〈ValPoss=“0.4”〉37〈/Val〉34.〈/Dist〉35.〈/age〉36.〈sex〉Male〈/sex〉37.〈email〉38.〈Disttype=“conjunctive”〉39.〈ValPoss=“0.60”〉TSmith@yahoo.com〈/Val〉40.〈ValPoss=“0.85”〉T.Smith@yahoo.com〈/Val〉41.〈ValPoss=“0.85”〉T.Smith@hotmail.com〈/Val〉42.〈ValPoss=“0.55”〉TSmith@hotmail.com〈/Val〉43.〈ValPoss=“0.45”〉TSmith@msn.com〈/Val〉44.〈/Dist〉45.〈/email〉46.〈/student〉47.〈/department〉48.〈/Val〉49.〈/university〉50.〈universityUname=“东北大学”〉51.〈/university〉52.〈/universities〉定模糊标签的有效命名空间,从而避免命名混淆的问题.模糊XML文档可以用包含精确结点(即非模糊构造子和可能性属性结点)、模糊构造子(Val和Dist结点)和可能性属性(Poss结点)的标签树来表示.下面我们将给出模糊XML数据模型的形式化定义.定义1.模糊XML文档树定义为一个六元组T=(V,E,r,φ,ε,δ),其中:(1)V表示有限结点集,V=Vcri∨Vcon∨Vposs,其中Vcri表示精确结点的集合,Vcon表示模糊构造子结点的集合,Vposs表示可能性属性结点的集合;Vcon=VDist∨VVal,VDist表示Dist模糊构造子的集合,VVal表示Val模糊构造子的集合.(2)EV×V为边的集合.(3)r为树T的根结点.(4)φ:Vcri→L表示精确结点的标示函数,其中L表示元素和属性名的集合;φ:Vcon→{“Dist”,“Val”,“Poss”}表示模糊结点的标示函数,v∈VDist,φ(v)=“Dist”,v∈VVal,φ(v)=“Val”,v∈Vposs,φ(v)=“Poss”.(5)ε:Vleaf→D表示叶子结点的数据值,其中Vleaf表示叶子结点的集合,D表示数据值的集合.(6)δ:Vcri∨Vposs→p表示结点的可能性值,0p1.3结点编码所谓XML结点编码,是指按照某种规则对XML树的每一个结点分配唯一的编码,目的是通过任意两个结点的编码,能够直接判断两个结点之间的结构关系(祖先-后代关系或者父子关系),进而提升XML数据处理的效率.在模糊XML环境下,为了高效的处理数据,我们同样地引入了结点编码的思想.依据文献[18]的介绍可知,我们可以用一个五元组(DocId,LeftPos:RightPos,LevelNum,Fuzzy,FuzzySequence)表示模糊XML中的结点编码信息,其中,(1)DocId是文档的标识;(2)LeftPos和RightPos按照先序遍历和回溯的位置编号.LeftPos是在第一次访问该结点时产生的序列号信息,RightPos是在遍历完该结点的所有后裔结点后再一次访问该结点时产生的序列号信息.若LeftPos=RightPos,则此时结点是叶子结点;(3)LevelNum标识结点所在的层数信息.通常认为根结点为第1层,每向下一层,LevelNum都会自动加1;(4)Fuzzy标识结点的性质(区分精确结点和模糊结点),是一个布尔值信息.若Fuzzy=1,则表示该结点为模糊结点;若Fuzzy=0,则表示该结点为精确结点;(5)FuzzySequence是一个有序模糊结点集,用来存储从根结点到当前结点路径下经过的模糊结点名称、类型、隶属度信息.当从根结点到当前结点路径下不存在模糊结点时,FuzzySequence为空.Page4图2是基于模糊XML文档的编码实例,这里我们用“圆”表示精确结点,用“三角”表示模糊结点.简便起见,本文用Vi表示FuzzySequence信息.由图2模糊XML结点编码下面考虑模糊XML中结点间的结构关系判定问题,由于模糊信息的存在,我们需要在上述编码基础上对结点间结构关系,尤其是父子结构关系进行重新定义.此时,结点间结构关系有如下定义.定义2.设结点Node1(D1,L1:R1,LN1,F1,FS1),Nodei(Di,Li:Ri,LNi,Fi,FSi),Noden(Dn,Ln:Rn,LNn,Fn,FSn),1in,分别表示模糊XML中的结点编码信息:(1)若D1=Di,L1<Li,Ri<R1,F2∩Fk∩Fi-1=0(2ki-1,i3),则Nodei是Node1的后代结点,二者之间的结构关系是祖先-后代关系(AD);(2)若D1=Di,L1<Li,Ri<R1,F1∪Fi=0,LN1+1=LNi,则Node1是Nodei的实父结点,二者之间的结构关系是实父子关系(RPC);(3)若D1=Dn,L1<Ln,Rn<R1,F1∪Fn=0,LN1+i=LNn,且Fi=1,则Node1是Noden的实父结点,二者之间的结构关系是实父子关系(RPC);(4)若D1=Di,L1<Li,Ri<R1,F1∪Fi=1,LN1+1=LNi,则Node1是Nodei的模糊父结点,二者之间的结构关系是模糊父子关系(FPC).在模糊XML中,父子关系PC可以进一步分为实父子关系RPC和模糊父子关系FPC.由定义2可知,(1)若结点m的LeftPos值小于结点n的LeftPos值,且结点m的RightPos值大于结点n的RightPos值时,则结点m必为n的祖先结点;(2)若结点m的LeftPos值小于结点n的LeftPos值,且结点m不是n的祖先结点,假设结点k的LeftPos值大于结点n的LeftPos值,则m一定不是k的祖先结点;(3)若在同一根到叶路径下,结点m和n之间不存在其它结点,且m和n同为精确结点,则m和n必图2可知,该编码方案具有极强的描述性,能有效地支持精确结点和模糊结点的识别,为模糊XML中的小枝匹配处理奠定基础.为实父子关系;(4)若在同一根到叶路径下,精确结点m和n之间存在χ个结点,且这χ个结点同为模糊结点,则m和n必为实父子关系;(5)若在同一根到叶路径下,结点m和n不同为精确结点,且m和n之间不存在其他结点,则m和n必为模糊父子关系.下面将通过图2具体实例说明模糊XML中的结构关系,其中结点CV0,…,CV10为精确结点,结点V1,V2,V3,V4,V5为模糊结点.首先,由于CV0的LeftPos值小于CV8的LeftPos值,且CV0的RightPos值大于CV8的RightPos值,所以CV0和CV8之间的结构关系为AD.由于CV1的LeftPos值小于CV3的LeftPos值,且CV1不是CV3的祖先结点,因此对于LeftPos值大于CV3的LeftPos值的任意结点(如CV4,CV5,…,CV10),CV1不可能为其祖先结点.精确结点CV1和CV2之间不存在其它结点,因此可知CV1和CV2的结构关系为RPC.对于精确结点CV3和CV4,由于CV3和CV4之间的结点同为模糊结点,因此可知CV3和CV4之间的结构关系也是RPC.对于结点V1和CV1,由于不同为精确结点,因此V1和CV1之间的结构关系为FPC.同样可知CV9与V5以及V2与V3之间的结构关系同为FPC.4模糊XML中的小枝查询本节将在讨论模糊XML成员度的评估以及小枝匹配定义的基础上,给出小枝查询算法TwigFX.4.1成员度评估和小枝匹配在模糊XML树中,通常会存在下面3类包含Page5模糊信息的结构树[23]:(1)模糊信息只出现在单一路径中(第1类).(2)模糊信息出现在分叉树中(第2类).(3)模糊信息出现在复杂树中(第3类).任意复杂的模糊XML树都可以看成是由上述三类模糊树结构合并而形成的.在对模糊XML数据进行查询时,首先要保证返回的结果绝对可能性不能低于给定的阈值限制.这是因为在实际应用中可能性过低的结果对用户来说通常是无意义的.我们选用一个整体成员度信息δwhole来表示返回结果的绝对可能性.图3举例说明了在模糊XML中模糊信息可能出现的位置以及相应的整体成员度的计算方法.简便起见,图中只标注了成员度信息.其中A,B,C和D分别代表结点信息,δ1,δ2,δ3分别表示的A,B,C成员度信息(相对可能性),δwhole表示整体成员度.绝对可能性可以用返回结果的所有成员度信息的交来计算得出.在以往的模糊系统中,成员度之间的交运算通常是采用Zadeh的最大最小技术[24-25].该技术反映了人们对待利害的取舍原则,具有计算简便等特点,因此成为最为广泛的一对算子.然而,在模糊XML小枝查询过程中,通过该算子得到的结果与参与运算的各个成员度信息缺乏有效的交互.例如,假设a到b的路径下的相对可能性为0.5(简记为δ(a→b)=0.5),且δ(a→c1)=0.6,δ(a→c2)=0.7,此时在Zadeh运算符的交运算作用下,有δ(a→b且a→c1)=δ(a→b且a→c2)=0.5.而在实际应用中上述交运算结果对于用户来说应该是有所区别的.另外,若已知δ(a→b且a→c2)=0.5且δ(a→b)=0.5,此时通过Zadeh运算符的反向计算并不能确定δ(a→c2)的具体值,只能是获得一个可能取值区间.由此可以看出Zadeh运算是一种粗粒度运算,使用其计算得到的结果可能会与用户意图有所偏差.因此,本文选取支持隶属度交互计算的Einstein算子[23]作为支持模糊XML小枝查询的交运算因子,即有这里δi和δj分别表示结点i和j的成员度,δwhole表示i和j经过交运算后得到的整体成员度.XML中的小枝查询实际上是对XML文档中的多个结点作选择谓词运算.小枝查询上的每一个结点,都有相对应的谓词(在小枝或者文本值上),结点之间满足一定的结构关系(祖先-后代关系或者父子关系).在模糊XML环境下,小枝查询的主旨就是搜索模糊XML树得到满足给定小枝模式的查询结果.定义3.给定一个小枝查询模式Q和一个模糊XML数据库D,Q在D上的一个匹配是指在Q的结点与D的结点之间存在这样的一个映射关系:(1)对应于查询结点的目标结点所含的数据必须满足查询结点上的谓词条件;(2)目标结点间的结构关系与查询结点组合间的结构关系必须一致;(3)在D中目标结点间的整体成员度要不小于给定的阈值u(0u1).应当说明的是,对出现在局部路径i→j中的多重模糊信息,我们将尝试对其进行修正处理以得到一个综合的局部修正成员度δrevise(i,j).通过处理第3节介绍的编码方案中的FuzzySequence特征,我们可以得到一个包含路径i→j中的所有成员度信息的集合f(i,j),即f(i,j)=(FSj-FSi).此时,局部修正成员度δrevise(i,j)可计算如下:这里ft是集合f(i,j)中的元素,χ是集合中元素的个数.现举例说明模糊XML文档中的小枝匹配结果.图4给出了两个不同结构的小枝查询(简便起见,图中用“/”表示PC关系,“//”表示AD关系),其中,Q1是一个简单的PC路径查询,Q2是一个带分支结构的AD路径小枝查询.在图2中数据树上查询Q1,由模糊XML环境下的小枝匹配定义可知,图2中共有3个可能数据树满足给定的查询模式,它们分别是m1:{CV0→CV3→Vδ(2,3)→CV4},m2:{CV0→CV3→Vδ(2,4)→CV5}和m3:{CV0→CV9→V5→CV10}.这里,Vδ(2,3)和Vδ(2,4)是局部修正成员度,δ(2,3)=δ2∩δ3≈0.07,δ(2,4)=δ2∩δ4=0.25.如果给定阈值为0.1时,此时只有m2和m3是满足Page6查询模式的结果,而m1不是.这是因为m1的整体成员度小于给定的阈值,也就是说m1并不满足模糊XML环境下的小枝查询定义,因此其将不会作为结果输出.4.2小枝匹配算法4.2.1相关符号为了简化描述,首先将对本节使用的一些符号进行说明.假设小枝查询模式Q,它的根结点为q,在不引起混淆的情况下,通常也直接使用q表示以q为根结点的小枝查询模式.分别用Sq和Tq表示小枝查询模式q中的每一个查询结点q所对应的栈和流信息.流Tq是查询结点q在XML文档流中所对应的所有数据结点的有序列表,这里的数据结点是XML文档树中的元素结点,流Tq的所有数据结点按(DocId,LeftPos)升序排列.针对小枝查询模式Q使用如下的结点函数[23]:isLeaf:Node→Bool;isRoot:Node→Bool;Parent:Node→Node;children:Node→{Node};subtreeNodes:Node→{Node}.其中,subtreeNodes(q)返回查询Q中的结点q和它的所有后裔结点.(i,j)计算路径i→j下的局部修正成员度,若i,j之间存在模糊信息,则有(i,j)=δrevise(i,j);否则(i,j)=1.针对流Tq使用如下函数:eof,advance,next,nextL和nextR.其中,next(Tq)函数获得流Tq中当前数据结点的下一个数据结点,advance(Tq)函数使流Tq的指针指向下一个数据结点(即指针下移操作),nextL(Tq)和nextR(Tq)函数分别返回流Tq中下一个数据结点的LeftPos和RightPos值.针对栈Sq的函数有empty、pop、push、topL和topR,最后两个函数返回栈顶数据结点的LeftPos和RightPos值.4.2.2TwigFX算法下面将具体给出TwigFX查询算法,TwigFX算法通过两阶段操作找到满足小枝查询的匹配结果.在第1个阶段(第1~15行),输出满足从根到叶子的单个路径查询以及阈值限制的局部匹配结果,第2阶段(第16行)将得到的局部匹配结果合并生成满足给定小枝查询的最终匹配结果.算法1.TwigFX(Q).输入:小枝查询Q,XML文档流T,阈值u输出:Q的匹配结果1.whilenotend(q)2.qact=getNext(q)3.if(notisRoot(qact))4.cleanStack(parent(qact),nextL(qact))5.endif6.if(isRoot(qact)∪notempty(Sparent(qact)))7.cleanStack(qact,nextL(qact))8.moveToStack(Tqact,Sqact,pointertotop(Sparent(qact)))9.if(isLeaf(qact))10.showSolutionsWithBlocking(Sqact,1)11.pop(Sqact)12.endif13.elseadvance(Tqact)14.endif15.endwhile16.mergeAllPathSolutions()FunctioncleanStack(S,a)1.while(notempty(S)∧(topR(S)<a))2.pop(S)3.endwhileFunctionmoveToStack(Tq,Sq,p)1.push(Sq,(next(Tq),p))2.advance(Tq)Functionend(q)1.returnni∈subtreeNodes(q):isLeaf(ni)→eof(Tf)TwigFX算法在第2行循环调用getNext获得下一处理结点,第4行和第7行过滤掉不能被扩展成为最终匹配的结点,第16行合并所有满足从根到叶子的单个路径查询以及阈值限制的局部匹配并生成最终的小枝匹配结果.getNext算法主要用来保证其返回的每一个结点都具有一个扩展解(即这些结点满足模糊XML中的小枝匹配定义且都会参与生成最终的匹配结果).若getNext(q)返回查询树q中的结点为qi,则qi满足:(1)必须至少有一个扩展解;(2)如果qi有兄弟结点,则它的兄弟结点也必须有扩展解(否则在第9行将返回一个更低层的查询结点,也就是说同一层的兄弟中,qi的LeftPos值是所有的兄弟中最小的);(3)若qi!=q,则qi的LeftPos值要比q的LeftPos值小,也就是说,qi的父亲结点也不具有扩展解.Page7算法2.getNext(q).1.if(isLeaf(q))2.while((parent(qi),qi)<u∪(q,qi)<u)3.advance(q)4.returnq5.while((parent(qi),qi)<u∪(q,qi)<u)6.advance(q)7.forqiinchildren(q)8.ni=getNext(qi)9.if(ni≠qi)returnni10.nmin=minargninextL(Tni)11.nmax=maxargninextL(Tni)12.while(nextR(Tq)<nextL(Tnmax)orwholeM(Tq)<u)13.advance(Tq)14.if(nextL(Tq)<nextL(Tnmin))returnq15.elsereturnnminFunctionwholeM(q)1.forqiinchildren(q)2.mi=subWholeM(qi)3.mj=subM(qi)//subM(qi)returnsδrevise(parent(qi),qi)4.m=mi×mj5.returnm×supM(qi)//supM(qi)returnsδrevise(q,qi)FunctionsubWholeM(q)1.forqiinchildren(q)2.mi=subWholeM(qi)3.mj=subM(qi)4.returnm=mi×mj从查询根结点出发,getNext(q)首先判断当前结点是否为叶子结点,若是叶子结点,则找到符合查询条件的叶子结点返回(第4行).第6行过滤不满足阈值限制((parent(qi),qi)u且(q,qi)u)的结点.在第8~10行,我们循环调用getNext来返回给定q结点,在这个过程中,需要保证其孩子结点都有扩展解.在第10~15行,getNext(q)通过递归调用从最左边的叶子结点开始向上检查,查找尽可能高的具有扩展解的查询结点.若流Tq不存在Tni的公共祖先,则返回具有最小LeftPos值的孩子结点nmin,此时getNext将进入第9行并依次返回结点ni.下面将通过例子说明TwigFX如何通过getNext算法在图5所示的模糊XML数据上查询图4中的小枝模式Q2.图5中每个元素的下标表示该元素所在的数据序列中的顺序,简便起见,我们用一个上下双向箭头表示在两个结点i,j间存在模糊信息,它们之前的值表示其局部修正成员度δrevise(i,j).流A,B,C和D初始指向a1,b1,c1和d1,假设给定的阈值为0.2.算法首先调用getNext(A)来判断A是否有解,由于A是根结点且(a1,a1)=1,满足匹配条件,所以对A的孩子B调用getNext算法,由于(a1,b1)=0.9>0.2,故对B的孩子C和D调用getNext算法并判断其是否有解,在调用getNext(C)的时候,由于C是叶子结点且(a1,c1)=0.9×0.8/(1+0.1×0.2)≈0.71>0.2,所以c1被返回上一层(getNext(B))调用.同理,在调用getNext(D)的时候,由于D是叶子结点且(a1,d1)=0.9×0.7/(1+0.1×0.3)≈0.61>0.2,所以d1被返回上一层(getNext(B))调用.由subWholeM(b1)=0.8×0.7/(1+0.2×0.3)≈0.53>0.2且wholeM(b1)=0.53×0.9/(1+0.37×0.1)≈0.46>0.2可知,结点b1具有扩展解,所以b1被返回上一层(getNext(A))调用.由于a1是b1的父结点,也就是说a1满足匹配条件我们将其压入栈SA中.接下来将对具有最小LeftPos值的b1调用getNext算法进行新一轮的判断,由先前的分析我们已经知道b1同样具有扩展解,所以我们将b1压入栈SB中.类似地,c1和d1分别被压入栈SC和SD中.进而可知,(a1,b1,c1,d1)是查询的一个匹配结果.接下来进入新一轮循环,算法再次调用getNext(A),重复先前的调用过程,首先对A的孩子B调用getNext算法,再对B的孩子C和D调用getNext,由于subWholeM(b2)=0.5×0.5/(1+0.5×0.5)=0.2,而wholeM(b2)=0.2×0.8/(1+0.8×0.2)≈0.14<0.2,进而可知,结点b2不具有扩展解,此时b2将被跳过,并将流数据TB向下移动到b3.再经过两次调用getNext(A),当前流指针将指向(a2,b3,c3,d3),在下一次调用getNext(A)时,由于(a1,c3)=0.6×0.2/(1+0.4×0.8)≈0.09<0.2,可知其不具有扩展解,所以将流数据TC向下移动,经过4次对流数据TC的判断,直到流数据TC的末尾也未发现满足(q,qi)u条件的C结点.类似地,直到流数据TD的末尾也未发现满足(q,qi)u条件的D结点.据此可进一步判断,流数据TA和TB余下的结点都不具有扩展解,至此算法处理完毕.Page8定理1.算法TwigFX能保证只有能形成最终匹配解的有用元素可以入栈且每个局部匹配解都将参与到最终解的构成中.证明.根据算法2可知,getNext算法所返回的查询结点q都可以得到一个能形成最终匹配解的有用元素Tq.由算法1可知,如果一个元素不能形成最终的匹配解,则相应的流数据在算法1的第13行将前移到下一个元素;若一个元素能形成最终的匹配解,则它将被压入栈中保存,此时该元素和其他关联栈中的元素之间满足给定查询的结构以及阈值的约束条件.因此每个仅由有用元素构成的局部匹配解将参与到最终的匹配解的构成中.证毕.定理2.对于给定的小枝查询Q和模糊XML文档D,算法TwigFX正确返回Q在D上的所有解.证明.算法1递归调用算法2用以返回具有扩展解的每一个结点.由定理1可知,所有有用元素都将入栈保存.当处理到查询叶子元素时,将在算法1第10行产生相应的局部匹配解,并将在算法1第16行形成最终匹配解.由于产生的局部匹配解包含了能形成最终匹配解的所有有用元素,因此说算法TwigFX能正确返回给定查询Q在模糊XML文档D上的所有解.在最坏情况下,对于仅包含祖先后代边的小枝查询TwigFX算法的I/O和CPU时间复杂度与n个输入列表大小和最后匹配结果大小的总和成线性关系,即为O(|T1|+|T2|+…+|Tn|+|output|),与从根到叶子路径查询的局部匹配结果的大小无关;空间复杂度(即栈链的大小)是n个输入列表大小总和与模糊XML文档树高度的n倍两者中的最小值,即为min(|T1|+|T2|+…+|Tn|,n×height(T)).应当说明的是,对于包含父子边的小枝查询,TwigFX算法不能保证I/O和CPU是最优的.此时,对于小枝模式的一条从根到叶的路径查询,算法可能产生一个局部匹配结果,它不能和其他的局部匹配结果进行合并连接.5优化TwigFX算法需要对所有的输入列表分别顺序扫描一次以获得所有匹配结果,当输入列表很大时,这种扫描往往会需要一定的I/O开销.在实际处理中我们通常可以利用索引来尽可能多地跳过并不参与合并连接的数据结点,进而提升小枝匹配效率.为此在传统XB-tree[2]基础上,本节将着重介绍如何在模糊XML环境下利用XB-tree索引来加速小枝匹配.在模糊XML中,XB-tree中的每一个结点都代表一组流数据(该组流数据中的任意结点i都包含在限定的(LeftPos:RightPos)区间内,即其满足i.LeftPos>LeftPos和i.RightPos<RightPos),位于XB-tree的叶子结点(简称叶子页)记录着包含编码信息(LeftPos:RightPos,LevelNum,Fuzzy,FuzzySequence)的XML流数据,而XB-tree中的非叶子结点(简称非叶子页)中只存储索引范围信息,而并不包含实际的XML流数据,用(LeftPos:RightPos,N.pointer)形式来记录其信息内容,其中N.pointer是一个指针,该指针指向XB-tree的一个孩子,该孩子中的所有数据都包含在(LeftPos:RightPos)区间内.XB-tree中每一结点P都含有一个指针P.Parent和一个整数P.ParentIndex,P.Parent指向该结点的父结点,P.ParentIndex用于定位父结点中的一个元素(该元素记录索引范围信息),该元素的指针指回当前结点P,XB-tree中结点按照LeftPos值的升序顺序排列.我们将用指针actPointer=(actPage,actIndex)来维护并记录当前数据流的位置.当XML数据发生更新时,对于需要删除的XML结点,我们只在该删除结点作删除标记,而并不在其物理结构上真正删除该结点,从而保持索引结构的完整性.此时,XB-tree索引维护的主要问题就转变成了新插入结点或子树的编码更新问题.在实际维护中,我们可以在建立XB-tree索引的过程中预留部分空间以便未来新结点的插入,即当插入结点时尽量引起叶子页的内部调整,而不是整个索引文件结构的调整,从而增强XB-tree索引的可维护性.XB-tree索引的所需空间大小等于叶子页所占空间与非叶子页所占空间之和.假设一个页(数据块)的大小为N,每个页中必须保留的最小空间比例为1-p,XML结点数为n,叶子页中每个索引行的大小为m,非叶子页中每个索引行的大小为k,则可知所需的XB-tree叶子页的个数为mn/Np,所需非叶子页的个数为mnk/(Np)2.因此XB-tree索引的大小为mn(Np+k)/Np2.应当指出的是,由于我们为每个查询结点q所对应的流Tq数据结点都建立了一个对应的XB-tree索引,且在索引建立以及维护过程中采用了预留空间以及添加删除标记的策略,因此所建索引具有很好的可伸缩性.XB-tree主要有两个操作:(1)advance操作,如果Page9当前指针actPointer=(actPage,actIndex)没有指向最后一个结点,我们只是简单的前移actIndex,否则我们利用(actPage.parent,actPage.parentIndex)来代替actPointer,并将它前移;(2)drilldown操作,如果当前指针actPointer=(actPage,actIndex)中actPage不是XB-tree中叶子页,而N是第actIndex个结点时,我们将用(N.pointer,0)替换actPointer来指向N.Pointer中的第一个孩子结点.算法3.TwigIndex(Q).输入:小枝查询Q,XML文档流T,阈值u输出:Q的匹配结果1.whilenotend(q)2.qact=getNextNode(q)3.if(isPlainValue(Tqact))4.if(notisRoot(qact))5.cleanStack(parent(qact),nextL(qact))6.endif7.if(isRoot(qact)∪notempty(Sparent(qact)))8.cleanStack(qact,nextL(qact))9.moveToStack(Tqact,Sqact,pointertotop(Sparent(qact)))10.if(isLeaf(qact))11.showSolutionsWithBlocking(Sqact,1)12.pop(Sqact)13.endif14.elseadvance(Tqact)15.endif16.elseif(notisRoot(qact)∩empty(Sparent(qact))∩17.advance(Tqact)18.elsedrilldown(Tqact)19.endwhile20.mergeAllPathSolutions()下面我们将介绍基于索引的TwigIndex算法,该算法是在TwigFX算法基础上利用XB-tree索引来尽可能多地跳过并不参与连接的结点.在模糊XML环境下生成的所有匹配解要经过三重过滤:第一重过滤是指当前结点qact与它的查询父亲结点parent(qact)要满足条件(parent(qact),qact)u的限制,不满足此限制的结点将首先被过滤掉;第二重过滤是指当前结点到查询根结点qroot需满足(qroot,qact)u的限制,不满足此限制的结点将被过滤掉;第三重过滤是指如果当前结点是分支结点的话,则它需要满足wholeM(qact)u的条件限制,不满足该限制的结点并不会参与最终匹配,因此也应该被过滤掉.TwigIndex算法同样也分两阶段执行,在第一阶段(第1~19行)将输出经过三重过滤满足从根到叶子的单个路径查询的局部匹配结果,第二阶段(第20行)将前一阶段得到的局部匹配结果合并得到最终解.函数isPlainValue(第3行)是一个bool函数,若当前结点流指针指向XB-tree的叶子页结点,则其返回true,否则将返回false.一旦确认当前结点为XB-tree叶子页结点时,TwigIndex将对栈中结点进行清栈(第5行和第8行),并输出经过三重过滤的从根到叶子的单路径解(第11行).若当前结点qact不是根结点,其父结点栈Sparent(qact)为空,且其父结点流中当前结点Tparent(qact)的LeftPos值大于当前结点流中结点Tqact的RightPos值,此时当前结点Tqact及其后代结点都不能参与生成最终解,因此它们将被直接跳过(第16~18行).与getNext类似,getNextNode首先将对当前结点进行判断,并过滤掉不满足前两重过滤条件的结点(第3和6行).紧接着,将对当前结点的每一个孩子递归调用getNextNode(第7~9行),若调用后的结点ni不是当前孩子结点或是isPlainValue返回false值,则将返回ni,因为:(1)如果递归调用后得到的结点不是当前孩子结点,则存在具有更小LeftPos值的可能满足查询的结点没有处理;(2)若isPlainValue(Tni)返回false值,则不能确定当前结点是否有扩展解(因为XB-tree非叶子页只存储索引范围信息,而并不包含实际的XML流数据),所以同样需要返回ni.getNextNode算法主要用来返回一个结点,该结点若是XB-tree非叶子页中的一个结点,则它将不会成为最终解的一部分,此时将进入TwigIndex算法的第16~18行运行;若其是XB-tree叶子页中的一个结点(该结点已经过三重过滤),则将进入TwigIndex算法的第4~15行运行.算法4.getNextNode(q).1.if(isLeaf(q))2.while(parent(qi),qi)<u∪(q,qi)<u)3.advance(q)4.returnq5.while((parent(qi),qi)<u∪(q,qi)<u)6.advance(q)7.forqiinchildren(q)8.ni=getNextNode(qi)9.if(ni≠qi∪notisPlainValue(Tni))returnni10.nmin=minargninextL(Tni)11.nmax=maxargninextL(Tni)12.while(nextR(Tq)<nextL(Tnmax)orwholeM(Tq)<u)13.advance(Tq)14.if(nextL(Tq)<nextL(Tnmin))returnq15.elsereturnnminPage10下面将通过例子说明TwigIndex算法如何在图6所示的模糊XB-tree上执行图4中的小枝查询Q2.初始状态时,A,B,C和D4个流指针分别指向(1225,pointer),(310,pointer),(49,pointer)和(1623,pointer).第一次调用getNextNode(A)时,将调用getNextNode(B),进而调用getNextNode(C)和getNextNode(D).调用getNextNode(C)时将返回当前C的指针(49,pointer),因为该结点是非叶子页结点且其RightPos值大于父亲流B当前结点的LeftPos值,因此流C的指针将指向(45,4,0,0.90.80.7)(参见TwigIndex算法的第18行).同理调用getNextNode(D)时流D的指针将指向(1617,4,0,0.80.70.8).返回getNextNode(B)的调用后,将返回当前结点(310,pointer),因为流B当前结点的RightPos值小于父亲流A当前结点的LeftPos值,且A栈为空,B不为根,所以TwigIn-dex将流B的指针前移到结点(1324,pointer),由此直接跳过了流B中不参与匹配的结点((310,3,0,0.90.8)和(69,4,0,0.90.80.7)).当第二次调用getNextNoede(A)时,同样地递归调用getNextNode(B),继而递归调用getNextNode(C)和getNextNode(D).getNextNode(C)将返回(45,4,00.90.80.7),getNextNode(D)将返回(1617,图6模糊XB-tree6性能测试与分析6.1实验设置为了评价算法的性能,我们进行了大量的实验,本节描述实验的结果,并对其进行分析.我们选择了基于PossibleWorlds的EVALDP算法[16]以及C-Twig算法[18]作为基于整体匹配方法的代表与本文提出的算法进行比较.选取它们作比较是因为它们是目前处理基于模糊XML小枝查询问题中4,0,0.80.70.8).当返回getNextNode(B)调用时,由于流C当前结点的LeftPos值小于父亲流B当前结点的LeftPos值,所以流C的指针前移到结点(78,5,0,0.90.80.70.6).再次调用getNextNode(A)时,TwigIndex会重复前两次调用getNextNode(A)的过程,将会返回流C中结点(78,5,0,0.90.80.70.6),并将指针下移到结点(1415,4,0,0.80.70.6).下一次调用getNextNode将返回流B中结点(1324,pointer),在处理完流B中结点(1318,3,0,0.80.7)后进入下一次getNextNode调用时,将对流A中返回结点(1225,2,0,0.8)入栈,此时流A处理完毕.下一次调用getNextNode将对流B中结点(1318,3,0,0.80.7)入栈,并下移当前指针到结点(1924,3,0,0.80.7).同样地将对流C中返回的结点(1415,4,0,0.80.70.6)以及流D中返回的结点(1617,4,0,0.80.70.8)入栈处理并下移对应的当前指针,输出匹配结果((1225,2,0,0.8),(1318,3,0,0.80.7),(1415,4,0,0.80.70.6),(1617,4,0,0.80.70.8)是Q2的第一个解).在下一次调用getNextNode时,由于流D中的当前结点(2223,4,0,0.80.70.1)不能满足三重过滤的要求,且流A,B,C和D都已指向末尾,故整个处理完毕.非常有代表性的算法.所有的测试程序均用JAVA编写,实验测试平台是采用IntelPentiumDual1.80GHzCPU、1GBRAM、160GB硬盘、WindowsXP专业版的PC机.实验采用了XML数据集①TreeBank和Mondial,其中,TreeBank数据集的大小为82MB,有2437666个元素结点,最大深度是36,平均深度为7.9.①UniversityofWashingtonXMLRepository.AvailablefromPage11Mondial数据集的大小为1MB,有22453个元素结点,最大深度是5,平均深度为3.6.TreeBank数据集深度较大,结点数量和类型较多,相对来说,Mondial数据集深度较小,结点数量和类型较少.为了与现有的基于模糊XML的小枝查询算法进行有效比较,我们选用了文献[16]中使用的RandomWalk的方法来生成模糊XML文档.所谓RandomWalk是指对于一个随机选取的结点v,随机生成模糊结点(生成过程中可以控制模糊结点的数量,模糊结点的成员度取值范围为[0,1])作为v的孩子结点,新生成的模糊结点将作为原来v的孩子结点的父结点.为了方便测试,我们从TreeBank中抽取部分并采用RandomWalk方法生成3个不同大小的FTreeBank测试数据集(简记为FTB1,FTB2和FTB3,默认情况下将选取FTB3作为FTreeBank的测试数据集),这3个数据集分别包含100万,150万和200万个结点.我们用RandomWalk方法同时生成了FMondial测试数据集,该数据集包含4万个结点.生成的FTreeBank和FMondial保留了TreeBank和Mndial数据集的深度和结点类型等结构特征,具体使用到的查询如表1和表2所示.查询FT1FT2FT3FT4查询FM1//mondial//country//province//cityFM2//country[//population]//province//nameFM3//mondial//country[//province]//populationFM4//mondial[/continent]//country[/province]//border6.2实验结果与分析为了评估算法的性能,我们选取访问结点数量图7FTreeBank上算法性能比较和执行时间作为评价指标,前者能反映算法跳过不相关结点的能力,而后者用于反映算法的综合性能.首先分别在具有不同结构的FTreeBank和FMondial数据集上对所有算法进行测试,实验结果如图7和图8所示.从图7(a)和图8(a)可知,在处理小枝查询时,TwigIndex需要访问的结点数目明显要少于其他算法.这是因为:(1)EVALDP在合并局部解过程中需要重复读取大量的中间连接结点;(2)C-Twig和TwigFX在生成结果过程中,虽然不存在重复读取中间结点的问题,但是仍需访问所有输入列表中的结点;(3)TwigIndex既不存在重复读取中间结点的问题,又不需要对所有输入列表中的结点进行扫描,而是利用索引大量地跳过了并不参与合并连接的结点.另外,从图7(b)和图8(b)可以看出,EVALDP需要的运行时间最多,C-Twig次之,接下来是TwigFX,而TwigIndex要明显地快于其他算法.这是由于:(1)EVALDP未充分对不参与合并连接结点进行过滤,进而产生了大量无用的中间结果,带来了较大的查询开销;(2)尽管C-Twig和TwigFX读取相同数量的结点,但C-Twig是在合并之后再对中间结果进行整体成员度过滤,而TwigFX则是在getNext过程中对返回结点进行整体成员度过滤.这也就是说,C-Twig仍然会产生一定的冗余中间结果,自然也需要一定的额外开销.但是由于TwigFX仍需扫描一次所有输入列表中的结点,并没有充分跳过不参与合并连接的结点,因此查询效率仍有提升空间;(3)TwigIndex利用索引和阈值信息,充分过滤了不参与合并连接的结点,因此性能要优于其他算法.从图7和图8可以看出,TwigIndex在不同结构的数据集下始终要比TwigFX、C-Twig和EVALDP的执行效率高很多.由此可以分析出,本文所提出的索引优化技术对于具有不同结构的模糊XML数据集都能起到提升查询性能的作用.Page12图8FMondial上算法性能比较图9给出了所有算法在不同大小FTreeBank数据集(FTB1、FTB2和FTB3)下执行FT4查询时的访问结点数目以及查询响应时间的变化曲线(因为FT1、FT2和FT3的变化曲线图与FT4类似,简便起见,我们这里省略了FT1、FT2和FT3的变化曲线图).从图9中可以看到,随着访问结点数目的增加,所有算法的执行时间都会平稳地增大,但图9不同大小FTreeBank数据集下算法性能比较图10给出了查询FM4随着FMondial文档中模糊结点数目变化时查询响应时间的变化曲线(因为FM1,FM2和FM3的变化曲线图与FM4类似,简便起见,我们这里省略了FM1,FM2和FM3的变化曲线图).从图10中可以发现,TwigFX和Twig-Index在模糊结点数目增多时其所需执行时间都比较稳定.由此可以分析出模糊XML文档中模糊结点数目对查询性能影响并不是很大.这是因为TwigFX和TwigIndex只需要扫描与查询有关的输入列表中的结点(而不是所有结点),就可以得到所有参与合并连接的结点,因此,其运行时间并不会随模糊结点的增多而发生显著变化.另外从图10中还可以看出TwigIndex始终保持着对TwigFX的性能优势,而这种优势并不随模糊结点数目变化而变化.这是因为TwigIndex比TwigFX更能有效地过滤掉不参与合并连接的结点,因此,TwigIndex的查询性能更高.TwigIndex在所有测试集下始终要比TwigFX、C-Twig和EVALDP更加高效.由此可以分析出,本文所提出的索引优化技术对于不同大小的模糊XML数据集都能起到提升查询性能的作用.结合之前图7和图8的实验结果可以有效地证明,本文所提出的索引方法对查询优化起作用,能显著地提升模糊XML环境下的小枝查询性能.7结论XML已经成为了当前Web信息表示和交换的标准.在实际应用中,由于信息通常具有不精确和不确定性,因此模糊XML的研究得到了广泛的重视.本文针对XML查询中的核心操作-小枝查询匹配问题进行了研究,讨论了模糊XML环境下的小枝Page13查询及其索引技术,研究了如何在模糊XML环境下实现对小枝模式的查询匹配.在引入编码技术的基础上,本文设计了一种高效的小枝匹配算法,另外,本文还设计了适于用模糊XML数据的索引算法,利用其尽可能多地跳过并不参与合并连接的数据结点,进而提升整体小枝查询算法的效率.未来工作将继续关注模糊XML环境下包含父子边的小枝查询优化技术以及如何在动态更新情况下查询小枝模式和建立索引等问题.
