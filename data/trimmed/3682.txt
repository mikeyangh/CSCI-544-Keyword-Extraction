Page1一种基于用户偏好自动分类的社会媒体共享和推荐方法贾大文1)曾承1)彭智勇2)成鹏1)阳志敏1)卢舟1)1)(武汉大学软件工程国家重点实验室武汉430072)2)(武汉大学计算机学院武汉430072)摘要社会媒体应用已成为Web应用的主流,以用户为中心并且海量媒体数据由用户自生成是社会媒体Web应用的重要特征.应对目前社会媒体环境中信息过载的问题,信息的共享和推荐机制发挥着重要的作用.文中分析了目前主流社会媒体网站基于用户自建组的信息共享机制所存在的问题以及传统推荐技术在效率上的问题,提出了一种新的基于用户偏好自动分类的社会媒体数据共享和推荐方法.直观上讲,该方法的本质是把用户对具体媒体对象的偏好转化成用户对媒体对象所蕴含兴趣元素的偏好,然后把具有相同偏好的用户,即对若干兴趣元素上的兴趣度都相同,自动聚合成为一个“共同偏好组(CPG)”.文中提出了基于CPG的社会媒体信息共享和推荐的架构,设计实现了CPG的自动生成算法,通过随机生成模拟数据集实验详细分析了算法性能的影响因素,并与现有类似功能算法进行了效率对比,实验结果表明算法可适用于具有海量用户的社会媒体应用.关键词Web数据共享;共同偏好组;社会媒体推荐1引言由用户生成内容的社会媒体(SocialMedia)存在信息过载的问题.社会媒体网站是以用户为中心,具有海量、无序的用户产生的数据.一方面,媒体数据和用户数据都十分庞大,而且不断有新用户加入以及每天都会大量新的数据上传;另一方面,社会媒体数据存在无序的特点,大多数社会媒体是无结构化数据,如视频、图片、文本日志等,这类数据都具有多语义的特点,即每个对象包含多种类别、多粒度的语义信息.社会媒体和网页一样具备海量信息的规模,但又无法直接应用现有成熟的网页信息检索技术对其进行排序,这给Web社会媒体数据的分类以及检索带来困难.在线共享和推荐的方式是目前社会媒体信息传播的主要途径.为了满足信息共享的需要,大多数社会媒体网站提供了用户自建组的机制.文献[1]指出超过一半的Flickr用户把他们的图片放入了至少一个组中,这表明了大量用户有参与组的行为和需要.用户建立或加入组有两个目的,一是为了信息共享,其二是为了社交的目的,同一组里面的成员代表他们有着跟组的主题相关的兴趣和爱好[2].一般来说,一个组代表了一个主题,对这个主题感兴趣的用户可以加入组,成为组的成员并可以上传与主题相关媒体数据到组里面.通过对Flickr研究表明,向组中加入图片是图片数据传播的主要原因[3-4].无疑,组机制是一种十分有效的社会媒体信息共享和传播的机制.但目前主流的社会媒体网站所支持的用户自建组机制存在如下问题[5-8]:(1)多同主题的组.每个用户都能随意创建自己想要的组,这使得和同一个主题相似的组的数目很多.例如,Flickr中有28109个关于“cat”的组,而且数目不断增加。面对如此多同主体的组,用户如何选择合适的组加入成为一个难题;同时由于一个主题存在多个组,具有相同兴趣的用户必将分散到不同的组里面,造成信息不能很好地共享的问题.(2)媒体数据多语义性.一般来说,一个媒体对象会和多个主题相匹配,而根据上条所描述的,一个主题会和多个组相对应,因此,根据现有组共享机制,一个用户若想充分地共享自己的数据就需要把一个媒体数据人工地加入到不同主题下的不同组里面.(3)用户的无意识兴趣.用户本身是对某些主题感兴趣,但其自身没有意识到已经存在这样的组可以进行数据的共享和交互.即使用户自身愿意参与到组里面进行信息共享的,仍然存在大量这种无意识的用户错过信息共享的机会.(4)数据噪音.我们把和组里面和组的主题不相关的数据称为数据噪音.媒体对象是人工加入到组里面的,用户加入数据的随意性使我们无法确保对象是和组的主题相关的,事实上,对象和组的主题不一致的现象很常见.以上提到的问题给社会媒体信息的共享和传播带来了阻碍.为了解决上述问题,本文提出了一种基于用户偏好的组自动生成方法.与用户手动创建的组进行区分,我们把本文提出的基于用户偏好的系统自动生成组称为“共同偏好组(CommonPreferenceGroup,CPG)”.本文研究基于以下假设:用户对一个社会媒体对象感兴趣是因为用户对媒体对象所蕴含的一些语义元素感兴趣.在这个假设下,我们把用户对许多单一媒体对象的喜好转化为用户对某个语义元素或语义元素的集合的兴趣.本文也把语义元素称为兴趣元素.每个用户对每个语义元素都可以有自身的喜好程度,我们把同一语义元素上的一种喜好程度称为偏好.如果一系列用户对若干语义元素上的每个元素都具有相同的喜好程度,则称这群用户在这些语义元素上具有共同的偏好,把那些有共同偏好的用户聚集成一个组,也就是共同偏好组(CPG).社会媒体应用环境下,CPG形成过程可简要描述如下:在社会媒体环境下,用户会对某些媒体对象感兴趣,一般来说,系统会提供某些功能让用户来表达他们的喜好,如星级评分,或设置“喜欢”按键.从每个媒体对象都可以抽取出多个语义元素,那么一个用户对媒体对象感兴趣也就是说用户对蕴含在这些媒体对象下的语义元素感兴趣.通过对每个用户喜欢的媒体对象抽取语义并对语义进行统计分析,可以知道用户对哪些语义喜好以及喜好的程度.直观上说,CPG就是在某些语义元素上,具有相同喜好程度的用户的集合.无论是从媒体信息共享推荐的角度还是从用户社交的角度来看,CPG均与传统自创建组机制不同,CPG有如下优点:(1)一个CPG和一组加权的语义相对应,表明这个CPG里面的用户在这些语义上具有相同的兴趣度,因此通过CPG,用户可以发现自己的偏好以及和自己具备相同偏好的其他用户;Page3(2)CPG是自动生成的,系统根据对用户行为分析得到用户兴趣,把用户自动加入到相应的CPG中;(3)媒体对象也被自动加入到对应的CPG中,而无需手动加入.本文的贡献有如下几个方面:(1)分析了目前自建组机制在社会媒体共享方面存在的问题.和推荐系统架构.(2)提出CPG概念以及基于CPG的数据共享(3)设计CPG自动生成算法,并提出了基于CPG协同兴趣发现的思想.(4)实现了CPG的自动生成算法,通过随机生成模拟数据集实验详细分析了算法性能的影响因素,并和已有类似的算法进行了性能对比.实验结果表明了该算法可适用于具有海量用户的社会媒体应用.本文第2节给出CPG相关问题和定义的描述;第3节提出基于CPG的社会媒体数据共享和推荐的系统架构;第4节阐明CPG的生成过程,设计并实现一种CPG自动生成算法;第5节通过大量的模拟实验来分析各种参数对算法复杂度的影响,同时还将与类似功能算法做性能比较;第6节对本文相关工作进行讨论;第7节总结全文并给出后继工作的想法.2概念定义本节将给出相关的主要概念和形式化的定义.对于传统推荐系统包括的主要概念有用户(User)、对象(Object)、评分(Rating)、归档信息(Profile)和用户-对象矩阵(User-ObjectMatrix,犝犗犕).整个推荐过程是通过用户对初始对象的评分建立用户的Profile来预测用户对其它对象的评分.系统根据预测结果对待推荐对象进行排序并确定是否把对象推荐给该用户.构建犝犗犕的过程是推荐系统的基础.定义1.用户-对象矩阵(犝犗犕).用户对象矩阵记录用户对对象的评分,表示用户对象的喜好程度.犝犗犕可以表示成三元组〈User,Object,Rating〉,其中,User表示用户的集合;Object表示对象的集合;Rating表示用户对对象的评分的所有取值.犝犗犕可以看成一个从用户和对象到评分值的函数.我们前面提到了目前社会媒体具有海量用户和数据的特点,并且用户和数据的数量每天快速增长.本文提出了基于共同偏好组(CommonPreferenceGroup,CPG)的信息共享和推荐方式,本文新增加了几个概念:兴趣元素(Interest-Element)、兴趣度(Interestingness)和用户-兴趣元素矩阵(User-ElementMatrix,犝犈犕),共同偏好组(CommonPreferenceGroup,CPG),组偏好关系-对象矩阵(PGR-ObjectMatrix,犘犗犕).通过对犝犈犕挖掘生成CPG,然后构建犘犗犕进行推荐.定义2.兴趣元素(Interest-Element).兴趣元素是包含在对象里面的能够影响到用户对该对象兴趣的特征或语义元素.不同兴趣元素之间可以有组合关系和泛化关系.定义3.兴趣度(Interestingness).兴趣度是描述用户对每个兴趣元素感兴趣的程度的量化值.定义4.用户-兴趣元素矩阵(犝犈犕).用户兴趣元素矩阵记录每个用户对每个兴趣元素的兴趣度.犝犈犕可以表示成三元组〈User,Interest-Element,Interestingness〉,其中,User表示用户的集合;Interest-Element表示兴趣元素的集合;Interestingness表示用户兴趣度的有所取值.犝犈犕可以看成一个从用户和兴趣元素到兴趣度的函数.犝犈犕:User×Interest-Element→Interestingness.定义5.共同偏好组(CPG).一个共同偏好组是犝犈犕中的子集,这个子集满足以下条件,同一个CPG里面的所有用户对这个CPG里面的每个兴趣元素都有相同的兴趣度.生成的CPG包括两个关系,组-用户关系(User-GroupRelation,UGR)表示CPG所包含的用户,组偏好关系(Preference-GroupRelation,PGR)表示CPG所包含的兴趣元素及其兴趣度.定义6.共同偏好组-对象矩阵(犌犗犕).共同偏好组-对象矩阵记录共同偏好组和对象之间的相似性.犌犗犕可以表示成三元组〈CPG,Object,Similarity〉,其中,CPG表示共同偏好组的集合;Object表示对象的集合;Similarity表示CPG的组偏好关系和目标对象特征的相似性.犌犗犕可以看成一个从CPG和对象到相似度的函数.显然,共同偏好组的数量将远远少于用户数,即和传统用户-对象矩阵相比较,犌犗犕的计算复杂度将会大大降低.这种推荐模式将适用于海量用户和数据的环境.Page43基于CPG的社会媒体共享和推荐系统架构为了弥补传统基于用户自建组的信息共享方式和传统推荐系统的问题,本节提出了一种基于用户偏好组的社会媒体数据共享和推荐的架构,如图1所示.我们可以想象每一个媒体对象基本上都是一个独一无二的个体,然而其所包含的让用户感兴趣的兴趣元素却具有共同性.本研究基于的假设是用户对一个社会媒体对象感兴趣是因为用户对媒体对象所蕴含的兴趣元素感兴趣.在目前社会化网络环境下,我们通过分析用户行为,很容易得到用户与对象图1基于CPG的信息共享和推荐系统架构4CPG自动生成CPG自动生成的过程即从犝犈犕找出对应UGR和PGR的过程.我们定义minUsers来表示构成一个CPG所要求的最少用户的数目.4.1建立用户兴趣元素矩阵用户兴趣元素矩阵(犝犈犕)记录每个用户对每个兴趣元素的兴趣度.从媒体数据对象中抽取蕴含用户偏好的兴趣元素来构建犝犈犕是此方法的基础.兴趣元素的抽取过程需要考虑两个方面:(1)兴趣元素可以通过预定义或通过抽取媒体对象语义的方式获得.不管采取哪种方式,兴趣元素应该与用户之间的喜好关系.通过前面所提到的假设,我们的目标是把用户和对象之间的喜好关系转化为更具有一般性的用户和兴趣元素之间的喜好关系,建立用户兴趣元素矩阵(犝犈犕).通过犝犈犕,可自动生成CPG.同一个CPG里面的所有用户符合一个共同的偏好,即对系列兴趣元素都具备同样的兴趣度.用户通过社会化网络上的行为被自动分类到了一起,而且知道之所以被聚到一起的原因,即具备什么样的共同偏好.待推荐对象包括媒体对象和新加入系统的用户.先通过提取媒体对象或新用户的兴趣特征,推荐算法可以通过待推荐兴趣特征,同CPG中的PGR做相似性比较,最后确定是否把待推荐信息加入到相应的CPG中.真实兴趣相符合;(2)媒体对象兴趣元素抽取的过程要尽可能地准确.IESpace表示所有让用户感兴趣的兴趣元素的集合,oe表示对象o所蕴含的兴趣元素.一个用户会和若干媒体对象交互.ObjectSpace表示所有的媒体对象,ufavorite表示用户喜好的对象集合.基于式(1)、(2),用户偏好upreference可以推导出来,一个用户u的偏好upreference是指用户u所感兴趣的所有兴趣元素以及对每个兴趣元素兴趣度λi.Page5根据式(3),我们可以建立用户偏好矩阵.4.1.1兴趣度的确定方法为了区分不同用户对同一兴趣元素喜好的差异性,本文提出了兴趣度的概念.兴趣度,即用户对兴趣的偏爱喜好程度.完成用户的兴趣发现之后,针对不同的兴趣,结合每个用户与所有推荐信息的交互次数来衡量用户在该兴趣上的兴趣程度.兴趣程度与兴趣度的关系是兴趣程度是一个绝对的数值,而兴趣度是一个相对的兴趣等级.用户ui在兴趣元素e上的兴趣程度θei的计算公式为其中,INe表示用户ui的交互频率;α用来避免出现除零情况.其中,sumINi表示用户ui的总交互次数;avgIN表示平均每个用户的交互次数.交互频率是为了平衡用户行为习惯对真实兴趣程度的影响.兴趣度λ由量化式(4)中的用户对某个兴趣元素的兴趣程度θ值得到.4.2CPG生成算法本小结给出一个简单的例子直观地说明CPG生成的原理(如图2所示),并详细介绍算法的过程.本例中定义用户集U={u1,u2,u3,u4,u5},兴趣元素集E={e1,e2,e3,e4,e5},用户对兴趣元素的兴趣度量化成为3种{λX,λY,λZ},本例给定minUsers=2.如图2(a)所示,用户对每个兴趣元素的兴趣度都记录在犝犈犕中.下一步是挖掘CPG集合,如图2(b)所示,不同形状的区域代表不同的CPG,本例中有3个CPG.根据CPG,组-用户关系和组偏好关系将很容易推导出来,分别如图2(c)和图2(d)所示.本节给出了具体CPG自动生成算法,并基于图2详细描述算法过程.第1步.把用户按照其偏好聚集,即把每种兴趣元素下,不同兴趣度的用户都聚成一个单元.通过用户兴趣元素矩阵犝犈犕,很容易可以得到用户聚集表(如表1所示).对于表中每个字段p,如果字段p包含的用户数大于或等于minUsers,则把p加入initialList中,否则就从表中删除.最后intialList中的字段可以看成满足条件的只包含单个兴趣元素的CPG.λXu1,u3λYλZu4,u5u4,u5算法1.UserClustering.输入:犝犈犕(用户兴趣元素矩阵)输出:initialList描述:把犝犈犕转化成用户聚集表,表里面每个字段p1.从犝犈犕中抽取用户集合U,兴趣元素集合E和兴2.for每个兴趣元素ei∈E3.for每个兴趣度λj∈Λ4.if(用户u对ei的兴趣度为λj)5.把用户u加入字段p(eiλj)中;6.endif7.endfor8.if(p(eiλj)中用户数目大于等于minUsers)9.把p(eiλj)加入到initialList中;10.endif11.endfor第2步.生成包含多个兴趣元素的CPG.对initialList中的每个字段p(eiλj),我们将其与表1中位于其所在列后面的列的有效字段(即字段中所包含的用户数大于或等于minUsers)进行∩操作.∩操作是指两个字段p中的偏好eiλj的并集以及两个字段所包含用户u的交集.以第一个字段p(e1λX)为例,表2给出了p(e1λX)与表1中位于p(e1λX)所在列后面列中有效字段进行∩操作后得到的用户交集结果.删除结果中用户数目小于minUsers的字段,把结果加入Page6intersectionList(eiλj)中.定义CCL(eiλj)(CandiateCPGList)来存放对initialList中的每个字段p(eiλj)处理后所生成的候选多兴趣元素CPG.把intersectionList(eiλj)中的每个元素与CCL(eiλj)中的所有元素依次进行∩操作后的结果加入CCL(eiλj)中,每次循环的最后intersectionList(eiλj)中的元素自身也需要加入到CCL(eiλj)中.表2字段狆(犲1λ犡)与其它字段∩操作的结果λX狌1,狌3λYλZ算法2.CreateCandidateCPGList.输入:p,initialList输出:CandiateCPGList描述:对initialList中的每个字段p,将其与表1中其1.CCL(p)={};2.for(每个initialList中的字段pj)并且(pj的兴趣元3.users=pj.users∩p.users;4.preferences=pj.preferences∪p.preferences;5.if(users数目大于minUsers)6.将元素〈{preferences},{users}〉加入到7.endif8.forintersectionList(p)的每个元素ti9.MergeCandidateCPGList(ti,CCL(p));10.将ti加入CCL(p);11.RemoveOverlapped(CCL(p));12.endfor13.ReturnCCL(p);14.endfor以字段p(e1λX)为例,intersectionList(e1λX)={〈{e1λX,e2λY},{u1,u3}〉,〈{e1λX,e3λX},{u1,u3}〉}.(1)对元素〈{e1λX,e2λY},{u1,u3}〉,先将其与CCL(e1λX)合并,但目前CCL(e1λX)为空,无法生成新的多兴趣元素CPG,所以仅把元素〈{e1λX,e2λY},{u1,u3}〉本身加入到CCL(e1λX).此时CCL(e1λX)={〈{e1λX,e2λY},{u1,u3}〉}.(2)对元素〈{e1λX,e3λX},{u1,u3}〉,先与目前CCL(e1λX)中的元素〈{e1λX,e2λY},{u1,u3}〉进行∩操作.前面定义了∩操作是指对元素的偏好集合求并集,用户集合求交集,其目的是检测当前元素能否为目前的候选CPG带来更多的兴趣元素(算法2中,MergeCandidateCPGList用于实现这一功能).结果产生了新元素〈{e1λX,e2λY,e3λX},{u1,u3}〉,将其加入CCL(e1λX),同时还要将元素〈{e1λX,e3λX},{u1,u3}〉本身也加入CCL(e1λX).CCL(e1λX)={〈{e1λX,e2λY},{u1,u3}〉,〈{e1λX,e2λY,e3λX},{u1,u3}〉,〈{e1λX,e3λX},{u1,u3}〉}.此时我们发现元素〈{e1λX,e2λY,e3λX},{u1,u3}〉完全覆盖了元素〈{e1λX,e2λY},{u1,u3}〉和〈{e1λX,e3λX},{u1,u3}〉,元素A被元素B覆盖是指,A.preferenceB.preference并且A.usersB.users.所以如果CCL中的一个元素被另一个元素所覆盖,需要从中删除被覆盖元素(算法2中,RemoveOverlapped用于实现这一功能).第3步.对initialList中每个元素,重复步2.对initialList中的每个元素,我们都通过重复步2得到一个对应的CCL,如表3所示.每个CCL中的候选CPG已经消除了覆盖的情况,但由不同字段产生的候选CPG还是可能存在覆盖,所以需要查找出被覆盖的元素并删除(RemoveRedundent用于消除不同CCL间元素的覆盖).p(e1λX)p(e1λZ)p(e2λY)p(e2λZ)p(e3λX)p(e4λY)p(e5λY)我们可以看到由字段p(e2λY)产生的CCL(e2λY)被已有的〈{e1λX,e2λY,e3λX},{u1,u3}〉覆盖,所以需要删除.实际上,如果字段p中的用户是已经计算过的字段p的子集,那么由字段p生成的CCL必然被字段p所生成的CCL覆盖.最后,我们把所有CCL产生的无覆盖元素加入CPGList中.有了CPGList,可以很容易得到UGR和PGR.算法3.CreateCPGList.输入:犝犈犕(用户兴趣元素矩阵)输出:CPGList1.CPGList={};2.initialList=UserClustering(犝犈犕);3.foreachelementp∈initialList4.CCL(p)=CreateCandidateCPGList(p);5.将CCL加入到tempList;Page76.endfor7.foreachCCL(pi)∈tempList8.foreachCCL(pj)∈tempList9.ifpj.eafterpi.e10.RemoveRedundent(CCL(pi),CCL(pj));11.endif12.endfor13.endfor14.CPGList=tempList;15.ReturnCPGList.4.3基于协同的CPG合并思想前面的一节详细讨论了CPG自动生成的具体过程.算法从犝犈犕中挖掘出所有的CPG.这就可能出现一种情况就是,很多的CPG只有少量用户和用户偏好的差异,如图3所示,CPG1和CPG2仅在兴趣元素e1上存在少量差异.如果大量这类CPG存在的话会造成CPG数目变得很大,由第2节给出的定义6可知,生成CPG的目的之一是改变传统通过直接比较用户对对象的评分的关系,从而提高推荐效率,而如果类似这种大同小异的CPG数目很多的话,效率就得不到保证.所以这里采用协同过滤思想对CPG进行合并,CPG合并不仅能减少CPG的数目以提高推荐效率,同时还能发现用户潜在可能的兴趣偏好,以提高推荐的新颖度.同时,用户能通过这种途径发现潜在的新的兴趣喜好.当两个CPG的相似度值H(CPG1,CPG2)高于一定阈值ψ,两个CPG将合并成一个CPG,一种简单的合并方法就是找出同时包含两CPG最小矩形,这就意味着新的CPG中的某些用户以前不存在的兴趣元素会得到自动填充.5实验结果与分析我们用Java实现了CPG自动生成算法,并设计了一系列的实验来对算法效率进行了分析.实验环境为2.8GHzCPU和4GB内存的PC,Windows7操作系统.5.1CPG生成算法性能分析本小结对提出的CPG生成算法的效率进行详细的分析.采用生成随机数据的方法构建模拟数据集,分别生成稠密用户兴趣元素矩阵犕d和稀疏用户兴趣元素矩阵犕s.犕d中的每个元素均随机填充兴趣度值,而犕s中为每个用户随机填充5~10个兴趣元素的兴趣度,其它为空.根据CPG生成算法的原理,有4个参数〈U,E,N,minUsers〉会对算法性能产生影响,其中,U指用户数目;E是兴趣元素数目;N是指不同兴趣度的个数;minUsers指生成CPG所需要包含的最少用户数目.本文分别分析CPG自动生成算法对这4个参数效率方面的敏感度.如图4所示,图中纵坐标代表毫秒(ms)级别的时间开销.图4表示算法效率与用户数量U的关系.可以看出,当用户数目成倍迅速增长时,时间开销增长仍呈较慢的线性增长,这说明算法对用户数目的容忍度高,特别是在计算矩阵中数据稀疏的条件下.实际应用中,数据将会是稀疏的,说明算法将有能力处理实际中大规模用户条件下CPG的自动生成的任务.图5表示兴趣元素的数目E对算法性能的影响.其它参数条件相同的情况下,左侧主坐标轴表示稠密矩阵犕d的时间开销,而右侧次坐标轴表示稀疏矩阵犕s的时间开销.针对犕d,兴趣元素数目E的增加意味着整个矩阵中增加了更多的元素,每增加一列元素都可能导致与其它列中的元素组合出新Page8的CPG,换言之,兴趣元素数目E的变化对算法开销影响很大.然而,对于犕s,每个用户仅随机填充5~10个兴趣元素的兴趣度,即整个矩阵中元素个数相对固定,E增加只会使得矩阵变得更加稀疏.当矩阵稀疏度达到一定程度后,能组合为满足条件的CPG的数目将会变少.正如图中所示,随着E的增长,算法的实际开销反而会降低.犕d与用户对所有兴趣元素都感兴趣的极端情况相对应,由于用户在一定时期内的兴趣是稳定的,真实数据的分布会更加接近犕s.不同的是,用户的兴趣数目可能不会均匀分布.图6表示参数minUsers不同情况下的算法时间复杂度.随着设定的CPG最少用户量的提高,算法第1步中intialList过滤掉的元素以及第2步中intersectionList过滤掉的元素则越多,算法速度将会越快.当最少用户数大到一定程度,算法复杂度趋于稳定.图7表示不同兴趣度的个数对性能的影响.算法开销随着兴趣度个数的增加呈现出先递增后再递减的现象.而峰值出现的原因是当兴趣度区分不明显时,多数用户会被划分到同一CPG中,导致算法效率提高;但是,当兴趣度个数超过峰值后,由于差异性过大,会导致满足条件的CPG大幅减少,从而使得算法时间开销急剧下降.下面本文用一组实验来分析兴趣度峰值大小与参数之间的关系.对犕d而言,兴趣度峰值呈现如下规律:(1)峰值与最小用户数目的关系结果说明兴趣度峰值与最少用户数成反比.(2)峰值与兴趣元素数目的关系结果说明兴趣度峰值与兴趣元素个数无关.(3)峰值与用户数目的关系结果说明兴趣度峰值与用户数目成正比.对犕s矩阵而言,兴趣元素个数也会对峰值产生影响.如前文所述,兴趣元素个数决定了犕s矩阵的稀疏度.当稀疏度一定时,上文结论仍然适用.最终实验得到的结果是,兴趣度峰值的大小与用户数目和最小用户数目的比值相关,并且也与犝犈犕的稀疏度相关.Page95.2相关算法对比分析本文提出的CPG自动生成算法和关联规则问题中频繁闭项集的挖掘(FrequentClosedItemsetMining)算法有类似之处[9].不同之处在于,那些算法的输入相当于一个布尔类型的矩阵,而本文算法输入的用户兴趣元素矩阵犝犈犕中带有不同的兴趣度值,布尔矩阵可以看成是兴趣度个数只有一个的特例.传统关联规则问题中的支持度Support的语境可以和本文提出的CPG自动生成问题中最小用户数minUsers与用户总数U的比值对应.在本文应用中,关联规则问题中的置信度Confidence不需要考虑.本文将CPG自动生成算法与其类似算法ECLAT[11]的频繁闭项集实现[10]进行了效率对比实验.由稠密到稀疏,我们分别选取了3种数据集来进行算法性能对比.分别是稠密真实数据集Chess以及两组稀疏数据集T40I10D100K,T10I4D100K.实验数据为从Chess数据集中选取前1000条记录,图8实验结果对比6相关工作就我们调研的情况来看,目前还没有关于自动生成用户兴趣组的研究.本文与两个方面的研究进行比较来体现本文的意义.6.1组推荐技术因为社会媒体的组是用户自定义生成的,所以一个主题对应多个组,如前面所提到的,组的数目甚至可以达到上万个.因此,对一个用户而言,如果其对一个主题感兴趣,那么他不可能加入所有相关的组里面去,对于用户而言,很难确定把媒体对象发布到哪个组里面以及如何找到适合自己的组.许多研究关注于对象与组的匹配[6-8],还有一些研究关注把组推荐给用户[4,12].这些推荐机制优点是找出最适合的Top-k的组推荐给用户或媒体对象,但其仍然不能满足媒体对象充分共享的任务,具有相同兴趣的用户仍然分离在不同的组里面,组与组之间对从T40I10D100K数据集中选取前10000条记录以及T10I4D100K选取了前20000条记录.选取的数据集可以直接在ECLAT实现算法上运行,同时需要转换为我们算法中的犝犈犕结构再使用CPG-MINING算法运行.阈值对ECLAT算法而言是表示生成频繁项所需要的最少记录数目,决定了支持度的大小,对我们的算法(CPG-MINING)而言是指最小用户数.图8给出了这两种算法的性能对比结果,从图中可以看出,ECLAT算法不适合稠密数据集,且对支持度的改变比较敏感,如图8(a)所示,对于较为稠密的Chess数据集,支持设定低于0.8(即图(a)中阈值小于800)时,算法将无法得到结果;对较为稀疏的数据集,如图8(b)、(c)所示,随着支持度的降低,ECLAT算法运行时间将急剧增长.结果表明我们提出的算法在各种条件下的效率均优于类似算法ECLAT的效率.象不能共享.另一方面,某些用户可能明显具备相同的兴趣,但他们忽视了这样的组的存在,结果他们不能认识彼此,信息也不能共享.基于CPG的方法,媒体和用户是自动分配到相应的CPG之中.6.2社会媒体推荐技术从社会媒体推荐技术的角度来考虑,研究着重于推荐算法的准确性方面.这些推荐方式包括基于内容的(Content-based)[13-14]、协同过滤的(CollaboratingFiltering)[15-17]、人口统计学的(Demographic)[18]以及混合式的(Hybrid)[19-20]等推荐方法.文献[21]提出了基于内容/相似度的推荐技术用于社会媒体推荐.当将现有技术用于社会媒体推荐,我们发现了一个普遍的问题,现有技术都是把单个对象推荐给单个用户,但社会媒体具有海量用户以及海量数据的特点,并且用户和媒体的数目每天都在不断增加,这些方法主要考虑推荐算法的准确性而忽略了推荐的效率问题.尽管时间效率问题在推荐系统里面不像在检索系统里面那么关键,但我们认为在海量数据Page10环境下考虑推荐算法的时间效率是十分必要的.显然,共同偏好组的数量将远远少于用户数,即和传统用户-对象矩阵相比较,共同偏好组-对象矩阵的计算复杂度将会大大降低,这种推荐模式将适用于海量用户和数据的环境.7总结与展望本文分析了目前社会媒体网站中组机制的不足以及相关的推荐技术,提出了一种基于用户偏好的潜在组自动生成机制用于社会媒体数据的共享和推荐,设计并实现了CPG自动生成方法,并通过实验详细分析影响算法性能的各种因素.实验结果表明该算法的正确性与高效性,可适用于具有海量用户的社会媒体应用.同时,本文提出了基于CPG的数据共享和推荐系统架构,如要真正基于此架构实现具备实用性的推荐系统还需继续研究完善,解决如下若干问题:(1)实现从用户行为得到实际的用户偏好矩阵的过程,包括兴趣元素的确立、社会媒体语义挖掘以及兴趣度的确立;(2)推荐算法的研究,包括用户的自动加入和退出机制、待推荐媒体数据和CPG的推荐匹配算法以及CPG的演变机制;(3)进一步提高CPG生成算法的效率以适应海量用户和提高更细粒度兴趣元素条件下的算法效率.此外,我们将进一步思考CPG用于信息共享和推荐的其它适用环境.
