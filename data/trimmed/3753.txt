Page1求解三维装箱问题的多层启发式搜索算法张德富1)彭煜2)张丽丽1)1)(厦门大学信息科学与技术学院福建厦门361005)2)(香港大学计算机科学系香港)摘要文中提出了一个高效求解三维装箱问题的多层启发式搜索算法.该算法基于块装载的思想,按照块选择算法确定每个阶段采用的块,然后以一种固定的装载方式装载块,直到无法继续装载.文中的主要贡献在于发展了一个有效的复合块生成算法,特别的,提出了基于多层搜索的块选择算法,该算法用多层搜索来评价可行块,然后选择最合适的块进行装载.对1500个三维装箱问题测试数据的计算结果表明,提出的算法几乎在所有测试数据上的填充率都超过了目前已知的优秀算法.关键词三维装箱问题;启发式算法;深度优先搜索1引言在物流、运输等工业领域,经常会遇到三维装箱问题.如何提高装箱的效率,已经成为科学研究和实践中非常关注的一个重要课题.求解装箱问题的高效求解算法,对降低成本、提高企业的赢利能力,有Page2箱问题和多容器装箱问题;同构装箱问题(只含一种类型的箱子)和异构装箱问题(包含多种类型的箱子).本文研究单容器装箱问题,其形式化的定义可以描述如下:给定一个容器(其体积为V)和一系列待装载的箱子,容器和箱子的形状都是长方体.问题的目标是要确定一个可行的箱子装载方案,使得在满足给定装载约束的条件下,使容器中所装箱子总体积S(或者填充率S/V×100%)尽可能的大.可行装载方案要求必须满足如下两个条件:(1)任一装载的箱子不能与其它装载箱子或者(2)所有装载的箱子以与容器平行的方式装载.此外,根据实际问题的需要,本文还考虑如下约容器互相重叠.束条件:(C1)方向性约束.在许多应用中,箱子的装载有方向性约束.也就是说,每个箱子只有它的1条或2条边可以竖直放置作为高度,即箱子的某个面必须朝上.(C2)稳定性约束.在实际应用中,例如物流领域,装载必须满足稳定性约束.这意味着每个被装载的箱子必须得到容器底部或者其它已经装载箱子的支撑.根据实际应用需要,有完全支撑约束,即被装载箱子的底部必须跟其它已经装载箱子完全接触,不允许底部有悬空的部分,部分支撑约束指的是装载箱子的底部,可以允许部分悬空.由于三维装箱问题是一个典型的NP难题[2],因此不存在多项式时间复杂度的最优求解算法.用传统的精确算法求解这类问题,会发生“组合爆炸”的现象.虽然一些研究采用了精确算法,但其求解的规模有限,因此启发式求解方法成为理论研究和实际应用的首选.对于三维装箱问题,基于垂直“层”或“墙”概念的启发式算法比较多.George等人[3]首先提出了基于层的启发式方法.Bischoff等人[4]比较了14种基于层的方法.Bortfeldt等人[5]在层概念的基础上,设计了一种混合遗传算法.Pisinger[6]基于层的概念,将整个容器空间分成若干垂直的层,再将层分成若干水平或垂直的条形,然后利用背包问题的算法来求解.Bischoff等人[7]针对异构装箱问题,以自底向上的摆放思想,提出了基于平面的算法.Gehring等人[8]基于塔的概念,设计了一个遗传算法.Bort-feldt等人[9]提出了一个禁忌搜索算法.与“塔”和“层”的概念不同,Eley[10]设计了基于同类块(Block)的算法.Bortfeldt等人[11]进一步拓展了“块”的概念,然后使用禁忌搜索寻找最优的装载序列作为问题的近似解.Moura等人[12]基于“剩余空间”的概念提出了一个贪心随机自适应搜索算法(GRASP).Parreo等人[13]进一步发展和改进了该算法,取得了不错的结果.Parreo等人[14]基于最大空间的概念,提出了一个可变邻域搜索算法.Fans-lau等人[15]基于“块”的概念,提出了“复合块”的思想,然后设计了一个有效的启发式树状搜索算法,是目前解决装箱问题最有效的算法.此外Ngoi、Bischoff、Morabito、Sixt、Gehring、Lim、Juraitis和Bortfeldt等人也报告了其它一些有趣的启发式算法,并将他们应用到三维装箱问题中[16-24].国内学者对三维装箱问题的研究,也取得了一些不错的结果[25-31],例如张德富等人[29]提出了一个混合模拟退火算法,Huang等人[31]提出了一个有效的拟人型穴度算法.本文在文献[15,29]研究的基础上,提出了一个多层启发式搜索算法,这个算法与文献[15]不同的地方在于,文献[15]采用基于整数拆分的树状搜索算法,而本文采用深度+宽度搜索的思想,提出多层搜索算法,能更有效地评价可行块以便选择一个近似最优的块进行装载.与文献[29]最大的不同在于文献[29]从一个初始装载序列出发,采用模拟退火算法来搜索一个好的装载序列,作为问题的近似解,而本文采用构造性算法,用多层搜索思想来选择一个近似最优块进行装载,然后逐步构造直到获得一个装载序列.实验结果验证了提出算法的有效性,而且本文算法超过了已出版的优秀算法.2多层启发式搜索算法2.1基本的块装载启发式算法因为装箱问题本身的复杂性和实际应用的需要,必须使用启发式方法才能有效地生成装载方案.一个优秀的启发式算法不但应该能迅速找到解,而且应该尽可能地找到接近最优的解,同时算法还应该展示必要的灵活性使其能够适应不同的场合和需求.本文提出的基于块装载的三维装箱问题的求解算法,是受日常装箱经验的启发而提出的,一些算法思想与文献[11,29]中的类似.算法1给出了基本的块装载启发式算法的具体描述,算法首先根据输入参数指定的isComplex生成所有可能的简单块或复合块;接着初始化当前部分装载方案,并开始装载过程;每个装载阶段,算法从剩余堆栈栈顶取出一个空间space,用GenBlock-Page3List算法生成它的可行块列表;当列表不为空时,FindNextBlock算法选择一个块进行装载并加入当前部分装载方案,接着采用GenResidulSpace划分未填充的空间并将它们插入堆栈;当列表为空时,算法TransferSpace尝试将space中可利用的部分转移到堆栈中相应的剩余空间.算法1.块装载启发式算法.BasicHeuristic(isComplex,searchParams,problem)ifisComplexthenblockTable··=GenComplexBlock(problem.container,elseblockTable··=GenSimpleBlock(problem.container,endifsetsearchparametersaccordingtosearchParamsps.avail··=problem.numps.plan··={}ps.volume=0ps.spaceStack··={}ps.spaceStack.push(problem.container)whileps.spaceStack≠{}dospace··=ps.spaceStack.top()blockList··=GenBlockList(ps.space,ps.avail)ifblockList≠{}thenelseendifendwhilereturnps.plan其中,space表示剩余空间,采用参考点加3边长度的方法来表示;problem包含容器、box列表以及可用箱子向量,形式化表示了一个装箱问题;block结构表示块,可以是简单块或复合块,它有一个re-quire向量指出其包含的所有箱子的数量.关于算法采用的数据结构以及有关变量的含义,可以参看文献[29].下面,本文提出的多层启发式算法,以块装载启发式算法为基础,嵌入了下面两个核心算法.2.2简单块、复合块及其生成算法简单块是由同一朝向的同种类型的箱子堆叠而成的,箱子和箱子之间没有空隙,堆叠的结果必须恰好形成一个长方体.GenSimpleBlock算法[29]枚举所有可行的组合(nx,ny,nz),并将其对应的简单块加入块表.其中可行组合应满足:所包含的箱子数目小于对应可用箱子数目,且块大小应小于容器大小.复合块是通过不断组合简单块而得到的,其定义[29]如下:(1)简单块是最基本的复合块.(2)给定两个复合块a,b.可以按3种方式进行组合得到复合块c:按x轴方向组合,按y轴方向组合,按z轴方向组合.c是包含a、b的最小长方体.显然,按照上述定义,复合块的数量将是箱子数目的指数级,而且任意组合生成的复合块中可能有很多空隙,非常不利于装载.因此,有必要对复合块施加一定的限制,本文的限制条件基本上同文献[29],但是本文还考虑下列条件:如果考虑约束C2,受复合块中空隙的影响,复合块顶部有支撑的可放置矩形可能很小,为了保证在后面的装载过程中剩余空间不会由于失去支撑而浪费可用空间,我们限定顶部可放置矩形与相应的复合块顶部面积的比至少要达到MinAreaRate.上述条件是文献[15,29]中没有考虑的,它能减少对块的搜索,加快计算的速度.在满足以上约束的情况下,块数目仍然可能很大,生成算法将在块数目达到MaxBlocks时停止生成.根据复合块的定义,可以得到最终的复合块生成算法2.此算法首先调用简单块生成算法生成所有可能的简单块;接着,迭代MaxTimes次,在每一次迭代中,对于任何两个已生成的复合块a、b,尝试按x轴、y轴、z轴方向进行组合;如果组合满足前面所述的组合限制条件,则将新生成的复合块c加入块列表.算法2.复合块生成算法.GenComplexBlock(container,boxList,num)blockTable··=GenSimpleBlock(space,boxList,num)fortimes··=0toMaxTimes-1donewBlockTable··={}foreacha,binblockTabledoifa.times=timesorb.times=timesthenPage4endifendforblockTable··=blockTable+newBlockTablereduceduplicatedblockinblockTableendforsortblockTablebydecreasingvolumeofblocks.returnblockTable介绍了块的概念后,下面描述可行块列表生成算法GenBlockList(space,avail).该算法用于从blockTable中获取适合当前剩余空间的可行块列表.其中,blockTable是在算法开始时预先生成的所有可能的块的列表,以避免重复计算.这样,在某一时刻计算某一个剩余空间的可行块列表时,只要扫描blockTable,找出所有能放入该剩余空间且能被当前剩余箱子满足的块即可.这样使得基本的块装载启发式算法与块生成算法完全无关,块生成算法可以根据需要进行定制而不影响块装载启发式算法.算法GenBlockList(space,avail)描述了可行块列表生成算法,该算法扫描blockTable,返回所有能放入剩余空间并且有足够剩余箱子的块.由于blockTable是按块中箱子总体积降序排列的,返回的可行块列表blockList也是按箱子总体积降序排列.在每个装载阶段一个剩余空间被装载,装载分为有可行块和无可行块两种情况.在有可行块时,算法按照块选择算法选择可行块,然后将未填充空间划分成新的剩余空间,这里划分的策略是使划分出的剩余空间尽可能地大.图1给出了具有稳定性约束的剩余空间的划分过程.令x轴、y轴和z轴上的剩余长度分别为mx、my、mz.如果mymx,则按图1(a)划分,划分空间的入栈顺序为spaceZ,spaceX,spaceY;如果mxmy,则按图1(b)划分,空间的入栈顺序spaceZ,spaceY,spaceX.在无可行块时,当前剩余空间被抛弃,若其中一部分空间可以合并到当前堆栈中的其它空间,则进行空间转移,重新利用这些空间.可转移空间可以被转移给剩余空间堆栈中来自同一次划分的其它空间以重新利用.可转移空间的重新分配实际上就是对未填充空间的重新划分.因此,可以通过重新划分未填充空间来达到再次利用可转移空间的目的.TransferSpace(space,spaceStack)实现空间转移,此过程判定当前剩余空间与栈顶的一个或两个剩余空间是否是由同一次划分而产生的,若是则将可转移空间转移给相应的一个或两个剩余空间.其中一些细节,可参考文献[29].2.3基于多层搜索的块选择算法Fanslau等人[15]采用如下基于整数拆分的树状搜索算法进行块选择:给定一个整数拆分d0+d1+…+dn-1=d,搜索分为n层,r为初始根节点,在第i层从根节点ri出发进行一次深度为di的搜索,选择最优的叶节点作为新的根节点ri+1,rn是最终的搜索结果.为限制搜索的开销,每次搜索的节点数目限制为bi=max{b|bdi<effort}.尽管这种算法取得了相当优秀的结果.但是,仔细分析该算法的执行过程,它仍然有一些缺陷:(1)在指定整数拆分下,算法每个阶段只选择当前状态下的局部最优解,并在下一阶段以此为基础进行搜索.但是局部最优毕竟不是全局最优,一旦在某个阶段选择错误,后续的评估结果就必然会出现偏差.虽然算法通过枚举所有的整数拆分允许搜索更多的节点,但是由于每次总是选择局部最优的那个节点,算法很难选取到那些要到很大的深度才能体现其优势的块.Page5(2)算法在执行搜索过程中,有很大一部分重复计算,一方面是因为不同的整数拆分方式有一部分重叠,另一方面是因为不同拆分所找到的节点很可能是相同的.针对树状搜索算法的两个缺陷,本文提出了多层启发式搜索,这里“层”的概念对应于整数拆分里面的每一个拆分,但是每一层的深度为1.第i层的节点是初始局部装载方案装载了i个块以后的结果.该算法与基于整数拆分的树状搜索算法最大的不同在于:在第i层,算法不再只选择一个块继续搜索,而是选择最优的MaxHeap个局部装载方案,采用不同的深度d调用深度优先搜索算法,并将所有搜索结果都插入到相应第i+d层的结果中去.在每个层上,算法使用堆存储最优的MaxHeap结果.算法从0层开始迭代,直到depth层结束.整个算法的运行过程类似树状搜索,不过此时在每个层上有至多MaxHeap个节点被扩展,并且已计算的上层节点不会被再次计算.算法3.多层启发式搜索.MultiLayerSearch(ps,depth,maxD,MaxHeap,ef-fort)result.volumeComplete··=0addpstoheap[0]forlayer··=0todepth-1dokeepheap[layer]containingonlythebestMax-Heapelementsforeachpsinheap[layer]doendforendforreturnthemaximuminheap[depth]算法3描述了多层启发式搜索算法.depth参数描述了要装载的块数目;maxD指定了在每个层上将尝试的最大深度值;MaxHeap如前所述是每个层上用堆维护的最优的部分装载方案的最大数目;branch表示可放置块的最大数目,意味着当前层的宽度;effort正如前文所述用于限制每次搜索访问的节点的数目,对于每一个搜索深度d,相应的分支数目b被计算出以用于搜索.算法4是改进的带深度限制的深度优先搜索算法,其不只是记录局部最优解,而且将所有叶子节点的评估结果都加到相应层上.其中PlaceBlock,RemoveBlock抽象了块装载和块移除的过程.算法.算法4.改进的带深度限制的深度优先搜索DepthFirstSearch(ps,depth,branch,layer)ifdepth≠0thenspace··=ps.spaceStack.top()blockList··=GenBlockList(ps.space,ps.avail)ifblockList≠{}thenelseendifelseComplete(ps)addpstoheap[layer]endif算法5描述了块装载算法,主要的任务是将块和栈顶空间结合成一个装载加入当前装载方案,移除栈顶空间,去掉已使用箱子,然后划分未填充空间并加入到剩余空间堆栈中.其中TransferSpace用于将新生成的剩余空间加入堆栈,TransferSpaceBack是其逆过程,用于取消被加入的剩余空间以便进行搜索.当搜索进行到目标深度时,Complete(ps)算法每次放入体积最大的块直至获得一个完整的装载方案.算法5.块装载算法.PlaceBlock(ps,block)space··=ps.spaceStack.top()ps.spaceStack.pop()ps.avail··=ps.avail-block.requireps.plan··=ps.plan+(space,block)ps.plan.volume··=ps.plan.volume+block.volumeps.spaceStack.push(GenResidulSpace(space,block))算法6描述了块移除算法,它是算法5的逆过程,完成的工作包括从当前部分装载方案中移除当前块所属的装载,恢复已使用箱子,移除空间堆栈栈顶的3个划分出来的剩余空间,并将已使用剩余空间重新插入栈顶.算法6.块移除算法.RemoveBlock(ps,block,space)ps.avail··=ps.avail+block.requireps.plan··=ps.plan-(space,block)ps.plan.volume··=ps.plan.volume-block.volumePage6remove3topspacesfromps.spaceStackps.spaceStack.push(space)图2(a)和(b)分别显示了多层启发式搜索算法的两个运行实例,图中只列出了最优节点相关的路径和分支,忽略了其它一些节点.图2(a)显示了一个典型的运行结果,算法从第0层开始执行深度为1和2的深度优先搜索,在1层中算法扩展最优的两个节点,其中一个节点以深度2执行另一次深度优先搜索后找到整个过程中的最优节点(见图中灰色节点).图2(b)描述的实例运行过程类似,区别在于这一次最优节点是在一次深度为2的深度优先搜索后接着一次深度为1的搜索中找到的.现在利用多层搜索算法来设计块选择算法.由于k+1层最优的N个解很可能只来自k层最优的N个解,我们不需要对所有的可行块执行最大深度的多层搜索,可以用不同的深度进行搜索,每次采用贪心算法过滤掉一些不够优秀的可行块.只要保证选择的N足够大,使得最终的最优解以很大概率被包含即可.算法7描述了块选择算法的结构.算法采用递增的搜索深度执行多层搜索,遍历整个可行块列表,尝试装载当前块到当前部分装载方案,然后用多层搜索来评估此部分装载方案,并将多层搜索的最优填充值作为被选块的适应度.排序块列表中块的适应度,每次过滤掉一半不够优秀的块,直到可行块数目不大于N.最后返回具有最大适应度的块.如果考虑C2约束,则只要判断当前块的底部是否有满足要求的支撑即可.算法7.块选择算法.FindNextBlock(ps,blockList)fordepth··=1tomaxDepthdoforeachblockinblockListdoendforsorttheblockListbydecreasingfitnessifsize(blockList)>2Nthenelseendifendforreturntheblockwithmaximumfitness3实验与结果3.1算法参数和测试数据本文的多层启发式搜索算法(MLHS)以C++实现,实验程序运行在Intel?Xeon?X5460@3.16GHz处理器上.运行环境为DebianLinux,编译器为gcc4.3.2.实验中设置的各项常数如表1所示.常数项值MinFillRate0.98复合块的最低填充率MinAreaRate0.96可放置矩形与相应复合块顶部面积比MaxTimes5生成块的最大复杂次数MaxBlocks10000最大块数目N16每层最优解数目maxD2每层搜索尝试的最大深度MaxDepth6分层搜索的总次数MaxHeap6每层扩展的节点数MLHS将在不同的参数设置下运行,参数按照从简单到复杂的顺序执行,并选择其中最优的结果作为最终解.由于当前一组参数被执行完毕后,所有程序运行时间可能会超过时间限制(Time-Limit).因此,当算法运行超过时间限制则在完成当前参数下的计算后,不再执行下一组参数.实验中一共采用6组参数设置,如表2所示.其中图2描述了参数2的参数设置,其分支branch=2.Page7参数12参数23参数34参数45参数56参数67本文实验采用的测试数据来自文献[17],包括BR1~BR15一共1500个三维装箱实例,它们可以从OR-Library①下载或者http://59.77.16.8/Download.aspx#p4网站上下载.这些实例共分为15种类型,每类100个问题.每类问题中有一定数量的相同类型(具有相同的长宽高)的箱子,这15类问题中箱子的类型数从1到100,异构性由弱到强,能够很好地测试算法在不同异构性装箱问题中的表现.其中,BR1~BR7的箱子类型数为3~20,属于弱异构装箱问题;BR8~BR15的箱子类型数从30~100,属于强异构装箱问题.3.2计算结果对于来自文献[17]的1500个实例,许多研究者表3各种算法对BR1~BR7的填充率比较H_BR[17]GA_GB[8]TS_BG[9]PTSA[11]顺序C193.2393.2792.8692.4091.6190.8689.6592.0并行C193.5293.7793.5893.0592.3491.7290.5592.7MFB算法[21]随机启发式算法[22]H_B[23]SPBBL-CC4[24]组合启发式算法CH[28]C189.9491.1392.0991.9491.7291.4590.9491.32GRASP[12]maximal-space[13]VNS[14]HSA[29]CLTRS[15]FDA[30]MLHS从表3中可以看出,多层启发式算法MLHS几乎在每类问题上的填充率都超过了目前已知的算法,平均填充率超过了所有比较的算法.当只考虑C1时,MLHS在BR1~BR7上的平均填充率达到了95.34%,比当前最新的VNS[14]、FDA[30]、最好的CLTRS[15]分别提高了0.81%,1.81%和0.32%.当C1和C2均考虑时,比当前较新的HSA[29]、最好的CLTRS[15]分别提高了1.39%和0.47%.表4给出了各个算法在BR8~BR15上的运行对它们或其中一部分做过测试.比较的算法包括顺序和并行执行的禁忌搜索算法(PTSA)[11]、MFB算法[21]、随机启发式算法[22]、H_B算法[23]、启发式算法(SPBBL-CC4)[24]、组合启发式算法(CH)[28].这些算法致力于研究弱异构装箱问题,即仅测试BR1~BR7.特别地,本文还比较了H_BR算法[17]、GA_GB算法[8]和禁忌搜索算法TS_BG[9]、贪心随机自适应搜索算法(GRASP)[12]、maximal-space算法[13]、可变邻域搜索算法(VNS)[14]、混合模拟退火算法(HSA)[29]、最新的基于整数拆分的树状搜索算法(CLTRS)[15]以及FDA算法[30].这些算法测试了BR1~BR15的1500个实例.此外Huang等人[31]提出的A2算法只计算了BR8~BR15.上述比较的算法均满足方向性约束C1,有些算法也满足稳定性约束C2,它们的计算结果均直接来自于相应文献.表3与表4报告了这些算法与MLHS的计算结果,斜体数据表示问题满足约束C1和C2.表中所有的数据表示填充率(%),即不同算法针对一类问题所得到的平均填充率,而Mean表示算法对所计算问题类的平均填充率.结果.对强异构问题,MLHS的优势更大,所有数据上的结果均超过比较的算法.当只考虑C1时,MLHS在BR8~BR15上的平均填充率达到了93.59%,比当前最新的VNS[14]、FDA[30]和最好的CLTRS[15]分别提高了2.13%、1.69%和0.71%.当C1和C2均考虑时,比当前较新的HSA[29]和最好的CLTRS[15]分别提高了2.91%和1.01%.①OR-Library.http://people.brunel.ac.uk/~mastjjb/jeb/info.htmlPage8表4各种算法对BR8~BR15的填充率比较算法H_BR[17]GA_GB[8]C1&C287.5286.4685.5384.8284.2583.6782.9982.4784.71TS_BG[9]GRASP[12]A2[31]maximal-space[13]C191.0290.4689.8789.3689.0388.5688.4688.3689.39VNS[14]HSA[29]CLTRS[15]FDA[30]MLHS此外,对BR1~BR15数据,当考虑约束C1时,MLHS算法(CPU为3.16GHz)的平均运行时间为197.33s,而CLTRS(CPU为2.6GHz)的平均运行时间为320s.当考虑约束C1和C2时,MLHS的平均时间为187.26s,而CLTRS的平均时间为320s.相对来说,MLHS算法所需要的时间更短.由于三维装箱问题具有很大的实用价值,许多研究者对其进行研究,填充率越来越接近最优,因此提高填充率已经越来越困难,但是MLHS对BR数据集,当考虑C1、C1&C2时,仍然比当前最好的算法分别平均改进0.52%、0.74%.这表明多层启发式搜索算法求解三维装箱问题非常有效,同时我们也观察到解的优秀程度在一定意义上是可以被继承的,即一个优秀解很可能导出另一个优秀解.这个特点可以描述为:虽然k层上的最优解不一定是k+1层上最优解的父节点;但是,k层上最优的N个解很可能包括了所有k+1层上最优的N个解的父节点.这就是为什么多层启发式搜索算法比基于整数拆分的树状搜索算法更优秀的关键原因,只选择一个最优解有可能错过下一层的最优解,而选择多个最优的解进行后续搜索将以更大的概率包含下一层的最优解.4结束语在文献[15,29]研究工作的基础上,本文提出了一个非常有效的多层启发式搜索算法.该算法引入了复合块的概念,并对其加以限制,同时提出了基于多层搜索的块选择算法,使得对于装载方案的评估更加准确而迅速,从而得到很好的计算结果.当然,由于装箱问题的复杂性以及启发式算法本身的缺陷,本文算法还有一些不足之处.例如,随着实例规模的增大,复合块的生成方式更多,搜索树填充率/%也会更复杂,可能需要较长的计算时间.因此,将来的工作是进一步优化算法,提高计算速度,同时,结合实际的应用,考虑更多的约束条件.
