Page1自动获取派生谓词规划领域的通用规划蒋志华1)饶东宁2)姜云飞3)杨天奇1)1)(暨南大学信息科学与技术学院计算机科学系广州510632)3)(中山大学信息科学与技术学院软件研究所广州510275)2)(广东工业大学计算机学院广州510090)摘要通用规划(解)是针对某个领域的像算法一样的规划解,通过对其的解释可以直接得出具体问题的规划解,而不需要调用任何规划系统.但是目前通用规划的提取只能在一些简单或者特殊的领域中进行,没有推广到复杂或者一般的规划领域.该文提出在包含派生谓词的规划领域自动获取通用规划的方法.与已有获取方法不同的是:首先,基于派生谓词规则,文中方法明确指出派生谓词目标与动作效果之间的依赖关系,用以完善通用规划中动作应用的目的;其次,在提取过程中借助角色来帮助识别规划解中的循环结构.实验结果表明,文中方法不仅容易在派生谓词规划领域中获取通用规划,而且还能够以较好的性能求解一类以派生谓词为主要目标的规划“难”题.该文是在派生谓词规划领域中提取通用规划的首创性工作.关键词人工智能;智能规划;派生谓词规划领域;通用规划解1引言近年来,通用规划(generalizedplans)[1-8]问题成为智能规划(automatedplanning)领域的一个广为关注的热点.与传统规划不同,通用规划针对规划领域制定规划解,而不是局限于某个具体规划问题.研究通用规划的初衷主要是为了避开代价高昂的搜索空间.有了通用规划,就可以以较小的计算代价来求解规模大的规划问题.对于某些特殊领域的大规模问题,通用规划的求解优势非常明显.例如,Winner[9]在其2008年的博士论文中报告了所开发的通用规划程序DsPlanner和规划系统FF以及MIPS在经典规划领域中的求解能力比较(如图1所示).可以看到,在领域对象数超过1000的大规模Rocket问题中,即使是采用了爬山法这样快捷的局部启发式搜索的FF也因搜索空间过大而无法求解,而DsPlanner在领域对象数达到60000时,依然可以在40s以内找到问题的解.而且,学习这样的一个DsPlanner程序所花时间不到一秒.这表明在某些特殊领域通用规划具有较强的求解大规模问题的能力.图1DsPlanner、FF和MIPS在Rocket领域的求解时间比较虽然通用规划的研究取得了一定的成果,但是目前其研究方面非常有限.通用规划受到指责的方面主要在于其描述形式不统一,适用领域少,缺少正确性和完备性证明以及不保证最优解等等.例如,就适用领域而言,目前仅可以在少数十几个简单或特别构造的规划领域上提取通用规划(如表1所示).它们都是STRIPS[10]风格加上简单的感知动作,并且要求训练例包含明显的循环结构.然而,在遇到非经典的规划情景时,例如需处理不确定动作效果(non-deterministicactioneffects)、时态约束(temporalconstraints)、观测变量(observablevari-ables)或者公理(axioms)时,通用规划从描述方式到提取方法都会变得非常困难.因此,通用规划还有很长的路要走.不过,近年来,规划社区给予通用规划极大的关注.在2009年的ICAPS①和2011年的AAAI②上分别举行了以其为主题的workshop,一些有影响力的文章也分别在AI[11]、IJCAI[7,12]、AAAI[5]和ICAPS[2,13-14]上登出.领域Accumulator[7]两个加法器和整数N,使得UnitDelivery[5]运输货物到目的地GreenBlock[13]找到木块塔中的第一个绿色NGoodEggs[7]打蛋直到盘中有连续N个Recycling[2]分类纸质物品和玻璃物品STRIPS;感知动作StripedTower[5]蓝色木块和红色木块交替放Y-Transport[5]所有物品运送到某地Corner[13]agent从西南角走到东北角STRIPSDiagonalReturn[4]agent先走到东北角,然后再在通用规划的众多困境中,我们认为首要任务是推广其适用领域,这样才能吸引更多的研究学者来解决它其它方面的不足.基于本文作者的前期工作[15-19],我们在此文中提出在包含派生谓词的规划领域中提取通用规划的一般方法.派生谓词(derivedpredicates)描述动作的非直接效果,其定义规则是规划领域描述语言(PlanningDomainDescriptionLanguage,PDDL)中领域公理(axioms)的标准形式[20].已有研究证明[21],在限定领域描述长度以及最优解长度为多项式级别的前提下,派生谓词是PDDL中不可替代的基本语言要素.在包含派生谓词的规划领域中,往往需要推理技术和搜索技术巧妙地结合在一起,这增加了求解的难度.而当问题所包含的对象数多或者规则集庞大时,求解过程更是异常复杂.因此,如果能够自动获取派生谓词规划领域的通用规划,将为避开搜索求解过程的复杂性和难度提供很好的途径.为此,本文在获取通用规划的一般方法上进行了改进,主要特色如下:利用派生谓词规则刻画动作效果与派生谓词目标之间的①②Page3依赖关系,用以完善动作应用目的;利用角色特征来帮助识别循环结构.相比已有方法,本文方法突破了通用规划适用领域的局限,并且以良好的性能来求解该领域的规划问题.本文第2节介绍研究背景;第3节介绍在派生谓词规划领域获取通用规划的方法,包括确定通用规划的描述形式以及具体的提取步骤;第4节给出相关的实验与分析;最后是结语和未来工作展望.2派生谓词规划领域派生谓词规则是PDDL中的公理,用来描述事物间的因果联系.它对状态进行推理以包含各种动作的衍生效果(ramificationeffects)[22].早期对领域公理处理的方法主要将其转换为别的语言要素.例如,Gazen等人[23]最先提出将公理转化为新的动作,公理的条件对应动作的前提,公理的结论对应动作的效果.但是这种转换忽略了以上所说的二者语义差别.Garagnani[24]在上述方法的基础上增加了“推导事实”(deductionfacts)来跟踪公理的应用,以消除语义差别.Davidson等人[25]把新增加的谓词不断地和公理进行合一,使得规则所有可能产生的影响都编码成领域动作的条件效果.以上3种方法都称为编译方法.但已证明了编译方法的低效性[21],因此只适合求解小规模问题.自2004年的国际规划大赛(InternationalPlanningCompetition,IPC)以后,有少数几个优秀的规划系统支持派生谓词,例如LPG-td[26]、SGPlan[27]、FastDownward[28]和Marvin[29]等,因此形成了目前处理派生谓词的主要方法.LPG-td不改变已有动作模型,在求解过程中建立规则图,并计算派生谓词实例的激活集(亦称为激活集法),以替代其在动作图中的出现.SGPlan不直接处理派生谓词,但是它在问题分解后调用LPG-td作为底层规划器来处理包含派生谓词的子问题.FastDownward和Marvin采用的方法相同:每应用一个领域动作后,需删除所有原来成立的派生谓词实例,然后再由规则重新推导出新实例直至到达状态的不动点.采用激活集法的LPG-td在IPC2004上性能最为优良,但是其主要缺点也很明显:采用与状态有关的激活集导致重复计算;激活集的估值困难;难以处理大规模问题等.后来蒋志华等[15-16]定义了与状态无关的激活集来避免重复计算,并通过规则集约简来加速激活集的查找.FastDownward和Marvin采用的是逻辑推理方法,特殊的删除机制保证后继状态扩充的正确性.但是当规则的数量众多时,其推理的复杂性大大增强.一个包含派生谓词的规划领域称为派生谓词规划领域(planningdomainswithderivedpredicates).定义1.派生谓词规划领域[30].设L={p1,…,pn}是有限的谓词符号集合,派生谓词规划领域是一个六元组Σ=〈S,A,X,B,D,R〉:(1)S是状态集合,S2L;(2)A是动作集合,A={a|a=〈pre(a),add(a),del(a)〉}.pre(a)、add(a)、del(a)2L,pre(a)是动作a的前提集合,add(a)是动作a的增加效果集合,del(a)是动作a的删除效果集合;(3)X是转换函数,X(s,a)=(((s-del(a))∪add(a))\R(s)),当原子动作a在s中是可应用的;(4)B是基本谓词符号集合;(5)D是派生谓词符号集合,且B∩D=;(6)R是派生谓词规则集合,R={r|r=(derived(d?狓)(f?狓))}.在定义1中,函数将状态s映射为在规则集R下的扩充状态,即(s)=s∪R(s),其中R(s)表示在状态s下应用规则集R所推导出的派生谓词实例集合.原子动作a在状态s中是可应用的,当且仅当pre(a)(s).在派生谓词规则r=(derived(d?狓)(f?狓))中,(d?狓)是单个派生谓词,(f?狓)是由基本谓词和派生谓词组成的逻辑公式.一个派生谓词规划问题是派生谓词规划领域的实例,其可定义为三元组∏=〈Σ,I,G〉,其中Σ是规划领域描述,I是初始状态,G是目标条件.定义2.规划解[30].派生谓词规划问题∏=〈Σ,I,G〉的解是一个原子动作序列π=〈a1,a2,…,an〉,该动作序列产生一个状态变换序列〈s0,s1,s2,…,sn〉,使得(1)s0=(I);(2)pre(ai)(si-1),si=X(si-1,ai),1in;(3)Gsn.与经典规划问题一样,派生谓词规划问题的解仍是一个动作序列,通过应用它使得初始状态转换到目标状态.只不过在每次应用完一个动作之后,要对新产生的状态进行规则集下的闭包运算,使得后继动作的派生谓词前提能够包含在新状态中.Page43通用规划提取方法3.1描述形式PDDL目前还没有扩展对通用规划的描述.本文参照Winner等人[6,8]所使用的通用规划形式,提出基于PDDL3.0的BNF描述的通用规划(如图2所示).〈genelizedplan〉····=PROGRAM(DOMAIN〈name〉)BEGIN〈statements〉END〈statements〉····=(〈actions〉)〈statements〉····=(WHILE〈conditions〉DO〈statements〉ENDWHILE)〈statements〉····=(IF〈conditions〉THEN〈statements〉ENDIF)〈actions〉····=(〈action〉)〈action〉····=(〈action-symbol〉〈typedlist(variable)〉)〈action-symbol〉····=〈name〉〈conditions〉····=(and〈in-predicate〉)〈in-predicate〉····=(inCurState〈predicate〉)〈in-predicate〉····=(inGoalState〈predicate〉)〈predicate〉····=(〈predicate-symbol〉〈typedlist(variable)〉)〈predicate-symbol〉····=〈name〉〈variable〉····=?〈name〉简单来说,用IF-THEN来表示选择结构,用WHILE-DO来表示循环结构,两个特殊谓词inCurState(P)和inGoalState(P)分别表示P在当前状态下是否成立和P在目标状态下是否成立.例1.在BlockWorld领域的基础上,构造一个ColorBlockTower领域(如图3所示).该领域中每个木块或者是红色(斜条纹方块表示)或者是蓝色(竖条纹方块表示).有一个特殊的蓝色木块是底木块(一直放在桌面上,不能移动).初始状态中蓝色木块和红色木块随意放置,目标状态中要求所有红色木块均放在蓝色木块的上方并保持塔结构.Color-BlockTower领域描述见附录1,该领域包含动作pickup、pickuptable、putdown和putdowntable,分别表示从一个木块的顶部拾起另一木块、从桌上拾由于ColorBlockTower领域的目标只要求所有红色木块在蓝色木块的上方,并没有具体要求哪些木块一定要放在哪些木块的上面,因此其目标状态不是某个具体状态,而是由多个具体状态构成的集合.该领域目标可以用下列逻辑公式(1)来描述:xy(color(xblue)∧color(yred)→above(yx))andxy((notbottom(x))∧bottom(y)→above(xy))满足式(1)的任一状态即为目标状态.由于领域描述中包含派生谓词规则,因此ColorBlockTower是一个派生谓词规划领域.对于基于搜索的规划系统来说,由于ColorBlockTower问题的目标状态不唯一(实际上数量非常多),导致其估值困难,搜索空间庞大,因此是一类非常难求解的问题(不像Rocket问题,其目标状态唯一).详细情况请参看第4节实验分析部分的表5和表6.起木块、把一个木块放在另一木块的上面和把木块放在桌上.该领域包含派生谓词above,表示一木块在另一木块的上方,但不一定相邻.此外,用谓词color表示木块的颜色,用谓词bottom来标识底木块.例2.针对上述ColorBlockTower领域,按照图2列出的规范,一个手工编写的通用规划如下:PROGRAM(DOMAINColorBlockTower)BEGIN(1)WHILEinCurState(empty)andinCurState(on(?x-BLOCK?y-BLOCK))andinCurState(clear(?x-BLOCK))DO(2)pickup(?x?y)(3)putdowntable(?x)(4)ENDWHILE(5)IFinCurState(empty)andinCurState(ontable(?x-BLOCK))andinCurState(color(?x-BLOCKblue-COLOR))andinCurState(clear(?x-BLOCK))andinCurState(bottom(?z-BLOCK))andinCurState(clear(?z-BLOCK))andinGoalState(above(?x-BLOCK,?z-BLOCK))THEN(6)pickuptable(?x)(7)putdown(?x?z)(8)ENDIF(9)WHILEinCurState(empty)andinCurState(ontable(?x-BLOCK))andinCurState(color(?x-BLOCKblue-COLOR))andinCurState(clear(?x-BLOCK))DO(10)IFinCurState(color(?y-BLOCKblue-COLOR))andinCurState(clear(?y-BLOCK))andinCurState(bottom(?z-BLOCK))andinCurState(above(?y-BLOCK?z-BLOCK))Page5andinGoalState(above(?x-BLOCK,?z-BLOCK))THEN(11)pickuptable(?x)(12)putdown(?x?y)(13)ENDIF(14)ENDWHILE(15)WHILEinCurState(empty)andinCurState(ontable(?x-BLOCK))andinCurState(color(?x-BLOCKred-COLOR))andinCurState(clear(?x-BLOCK))DO(16)IFinCurState(bottom(?z-BLOCK))andinCurState(clear(?y-BLOCK))andinCurState(above(?y-BLOCK?z-BLOCK))andinGoalState(above(?x-BLOCK,?z-BLOCK))THEN(17)pickuptable(?x)(18)putdown(?x?y)(19)ENDIF(20)ENDWHILEEND例2所示的通用规划表明,形成图3中目标状态的步骤如下:第1~4步将所有非底木块放在桌上;第5~8步选择一个蓝色木块放在底木块上;第9~14步将剩余的蓝色木块依次放在木块塔的顶部;第15~20步将所有红色木块依次放在木块塔的顶部.该通用规划在红色木块数#RED1且蓝色木块数#BLUE2的条件下可以求解ColorBlock-Tower领域的所有问题.3.2提取方法与动作模型的学习[17-18]一样,人工编写通用规划往往需要大量的专家知识,并且容易出错.因此,本节提出自动获取派生谓词规划领域的通用规划的具体方法.实际上,适合提取通用规划的规划领域往往具有两个主要特征:一是问题的规划解包含反复出现的动作子序列;二是问题所包含的对象可以划分类别(class)或者角色(role).这两个特征提供了形成通用规划中的循环结构的可能性.提取方法总体思路如下.如前所述的主要提取方法[2-8,11]中均有值得借鉴和不可取的地方.例如,“条件语句合成法”[6,8]将规划解转换为条件语句,然后通过因果链来识别并行子规划,是非常直观地从具体解的结构来分析通用解的构成.但是该方法的主要缺点在于规划解的参数均为变量,这使得识别循环的过程(需要大量的变量匹配)非常复杂.而“抽象状态计数法”[2,4-5,11]将对象转换为角色,通过对角色成员的计数来帮助形成循环结构.不过它的主要问题在于,通用解的构成不是来自于具体解的结构分析,而是来自于具体解在抽象状态空间中应用的轨迹搜索.因此,提取通用解的主要时间花在轨迹搜索上,并且在他们自己的文章中[11]也承认通用解结构可读性差,需要后期的调整和修改.因此,本文取长补短,结合以上两种方法的优点,既采用角色的概念帮助识别循环又采用条件语句的形式进行直观分析,同时加上派生谓词规则所蕴含的特殊谓词依赖关系,从而提出派生谓词规划领域的的通用规划获取方法.获取过程如图4所示.共分成3个阶段:第一是产生条件语句阶段.该阶段将基于具体规划解建立规则规划图(ruleplangraphs),当然需要在具体问题描述已知的前提下.然后,基于规则规划图将每层动作转化为条件语句.第二是识别循环阶段.该阶段将对象常量转化为其所属的角色,然后将重复出现的条件语句用循环结构来替换.第三是调整阶段.该阶段将前面获取结果中的角色转化为对象变量,从而形成标准描述下的通用规划.3.2.1产生条件语句之间的联系,本文提出规则规划图.其定义如下:为刻画规划解中动作直接效果与派生谓词目标定义3.规则规划图.给定一个派生谓词规划问题∏=〈Σ,I,G〉和其解π=〈a1,a2,…,an〉,可产生一个状态转换序列Sπ=〈s0,s1,s2,…,sn〉.基于π和Sπ,可构造一个具有n个动作层和n+1个命题层的规则规划图,使得第i层动作层只包含动作ai(1in),第j层命题层为sj(0jn),并且对于第i-1层命题层中所有p∈pre(ai)对应的节点引实线边指向ai,从ai引实线边指向第i层命题层中所有p∈add(ai)对应的节点.对于任意在第i层命题层(0in)可应用的派生谓词规则r=(derived(d)(f1andf2and…andfk)),其中d是派生谓词实例,fj(1jk)是基本谓词或派生谓词实例,均有规则边从fj对应的节点指向d对应的节点.规则规划图结合了规划图[31](plangraphs)和规则动作图(ruleactiongraph)[26]的特点,三者更细微的区别请见表2.在定义3中,状态转换序列Sπ=〈s0,s1,s2,…,sn〉的产生如定义2所示,均为动作应用之后的扩充状态.为了有效地识别规则推导链,命Page6题层中不再表示动作的删除效果,是一个完整状态而不是状态的超集.规则规划图的一个例子如例3所示.表2规则规划图、规划图和规则动作图之间的区别动作层只有一个动作多个动作只有一个动作命题层单个扩充状态状态超集动作前提集合层数规划解步骤数扩展至不动点规划解步骤数规则边有用途描述规划解状态空间搜索规划空间搜索例3.一个ColorBlockTower问题及其规划解如图5所示.其中B4是底木块.图5表明左边的初始状态经过应用中间的动作序列可以转化为右边的目标状态(满足式(1)).基于附录1给出的动作模型,该规划解对应的规则规划图如图6所示.图6规则规划图(细实线箭头表示前提或增加效果,粗实线箭头表示规则边,带下划线的斜体命题表示目标)产生条件语句的具体过程如算法1所示.算法1.产生条件语句.输入:规划问题∏=〈Σ,I,G〉及其规划解π=〈a1,…,an〉输出:条件语句集合IFS=〈IFS1,…,IFSn〉1.RAG=build-rule-plan-graph(∏,π)2.FORi=1TOnDO3.IFSi_C=pre(ai),IFSi_G=4.FOReachb∈add(ai)inRAGDO5.IFbholdsinGTHENIFSi_G=IFSi_G∪{b}6.FOReachdisaderivedpredicatefactand7.IFexistsarule-edgelinkrfrombtodin8.IFSi_G=IFSi_G∪{d}9.IFSi=“IFinCurState(IFSi_C)andinGoalState10.THENai11.ENDIF”12.RETURNIFS=〈IFS1,…,IFSn〉算法1的第1步从问题描述∏和规划解π中生成规则规划图RAG(如定义3所示),第2~11步基于RAG提取动作ai对应的条件语句IFSi.如图2所示,条件语句的条件部分是由谓词inCurState或inGoalState所构成的逻辑公式,结论部分是通用规划语句.由于一个动作对应一个条件语句,因此算法1所产生的条件语句是不嵌套的.总的来说,动作的全部前提加入到inCurState中(第3步),作为目标出现的动作直接效果(第5步)或直接效果所推导出的派生谓词目标(第6~8步)加入到inGoalState中.最后,算法的第9~11步形成以动作为结论的条件语句.定理1.算法1的时间复杂性为O(n×Maxadd×Page7Nderived_goal),其中n为规划解中动作个数,Maxadd为动作增加效果数的最大值,Nderived_goal为目标状态sn中派生谓词目标的个数.证明.设规划解为π=〈a1,…,an〉,Maxadd=max{m|m=|add(ai)|,1in},则在为每个动作生成条件语句时,判断其增加效果是否为目标需要O(Maxadd)时间,判断增加效果与派生谓词目标之间是否存在规则链需要O(Maxadd×Nderived_goal)时间,因此算法1所需的时间为O(n×(O(Maxadd)+O(Maxadd×Nderived_goal))),即O(n×Maxadd×Nderived_goal).下面具体说明inCurState和inGoalState的构成.关于inCurState的构成,由于动作可应用的充要条件是其前提在状态中均成立,因此至少应将动作前提全部加入到inCurState中.其它可能需要的条件在后面的调整阶段补充.关于inGoalState的构成.由于动作的直接效果只能是基本谓词,因此根据其与目标的联系可以分为以下4种类型:(1)被动作删除的效果,实质上是某个被删除的前提,如图6中第0层命题层的on(R1,B1);(2)动作的增加效果,正好是原问题的目标,并且没有被任何后继动作删除且一直保持到目标状态;(3)动作的增加效果,没有被任何后继动作删除且一直保持到目标状态,与目标状态中的其他命题推导出派生谓词目标,如图6中第24层命题层的on(R1,R2),与命题above(R2,B1)推导出派生谓词目标above(R1,B1);(4)动作的增加效果,只是为后续动作提供因果链支持,如图6中第1层命题层的holding(R1)是第2层动作putdowntable(R1)的前提.因此,根据以上分类,应将第2种动作效果以及第3种动作效果所推导的派生谓词目标加入到inGoalState中.inCurState表示动作应用条件,inGoalState表示动作应用目的,它们的合取构成完整的条件部分.例4.图6中动作a1=pickup(R1,B1)对应的条件语句IFS1如下:IFS1:IFinCurState(empty)andinCurState(clear(R1))andinCurState(on(R1,B1))THENpickup(R1,B1)ENDIF动作a24=putdown(R1,R2)对应的条件语句IFS24如下:IFS24:IFinCurState(holding(R1))andinCurState(clear(R2))andinGoalState(above(R1,B4))andinGoal-State(above(R1,B3))andinGoalState(above(R1,B2))andinGoalState(above(R1,B1))THENputdown(R1,R2)ENDIF以上条件语句的构成虽然与“条件语句合成法”(以下简称“合成法”)中的相似,但是产生过程明显不同.算法1为规划解中的每个动作生成相应的条件语句,而“合成法”将整个规划解转换为一个条件语句.此外,算法1将动作前提全部加入到inCurState中,而“合成法”只将前后动作的因果链所支持的命题加入到inCurState中,形成了某些情况下动作应用条件的丢失.3.2.2识别循环为了方便识别循环,需将条件语句中的对象转化为角色.原则上属于同一角色的对象没有差异,即先处理谁或后处理谁没有本质分别,存在着一定的可替换性.在Srivastava等人[11]的工作中,将角色定义成由单目谓词(unarypredicates)所构成的抽象谓词(abstractpredicates)集合.在本文中,由于考虑到领域常量的存在,我们将抽象谓词的概念扩展到多目谓词上.定义4.抽象谓词.对一个规划领域而言,抽象谓词指的是领域描述中的单目谓词,或者是只包含一个变量而其他变量均为领域常量的多目谓词.定义5.角色[11].对一个规划领域而言,角色指的是对象所满足的抽象谓词集合.抽象谓词也称为角色的特征.定义6.角色成员[11].对一个规划问题而言,角色成员指的是满足角色特征的对象集合.一般地,角色role的成员集合用函数member(role)来表示.在角色定义的基础上,首先,为了最大程度地反映角色的差别,约定所有对象都满足的抽象谓词不属于任意角色的特征.其次,可以证明角色将问题中所包含的对象进行了划分.每个对象只能属于一个角色,对象和角色之间是多对一的关系.引理1.如果一个对象属于多个角色,那么总可以创建新的角色使得这个对象唯一地属于该新角色.证明.先讨论对象同时属于两个角色的情况.设在规划问题∏=〈Σ,I,G〉中,对象o∈member(role1)且o∈member(role2)(role1≠role2),其中角色role1={p1,…,pk1},角色role2={p1,…,pk2},p1,…,pk1和p1,…,pk2均为抽象谓词.由于o分别满足抽象谓词集合{p1,…,pk1}和{p1,…,pk2},因此有o同时满足抽象谓词集合{p1,…,pk1}∪{p1,…,pk2}.创建新角色role12,使其role12={p1,…,pk1}∪{p1,…,pk2},则有o∈member(role12).又因为role1≠Page8role2,因此有role12≠role1且role12≠role2.从member(role1)和member(role2)中分别删除o,使得o唯一地属于角色role12.当对象同时属于多个角色时,总可以通过以上两两抽象谓词集合合并的过程来产生新角色,使得对象唯一地属于最后创建的新角色.证毕.例5.如附录1所示,ColorBlockTower领域的谓词集合为{on(?x-BLOCK,?y-BLOCK),ontable(?x-BLOCK),clear(?x-BLOCK),empty,holding(?x-BLOCK),above(?x-BLOCK,?y-BLOCK),bottom(?x-BLOCK),color(?x-BLOCK,?y-COLOR)},其中关于COLOR类型的领域常量为{blue,red}.该领域包含3种角色:BLUE_BOTTOM={bottom(?x),color(?xblue)}BLUE={color(?xblue)}图7例3的角色成员图(椭圆框里是角色名及其抽象谓词集合,椭圆框下面是角色成员集合)通过引理1,可以很容易得到以下定理.定理2.在一个规划问题中,每个对象只能属于除去OBJECT之外的唯一角色.为了识别循环,需要定义规划解中的子规划(subplans).规划解中的每个动作称为一个规划步(planstep).子规划是由连续的规划步序列组成.重复出现的子规划可以形成循环结构.为此,定义子规划所覆盖的条件语句序列集合如下.定义7.子规划所覆盖的条件语句序列集合.设规划解π=〈a1,…,an〉对应的条件语句集合为IFS=〈IFS1,…,IFSn〉,子规划πsub=〈ai,…,aj〉,其中1i<jn,其所覆盖的条件语句序列集合定义为IFSSequenceSet(πsub)={IFS_s1,…,IFS_sm},1mn/(j-i+1),其中IFS_sk=〈IFSki,…,IFSkj〉(1km),且IFSkl包含动作al(ilj).RED={color(?xred)}对于例3所示的规划问题,其对象集合为{R1,R2,R3,B1,B2,B3,B4},则有member(BLUE_BOTTOM)={B4},member(BLUE)={B1,B2,B3},member(RED)={R1,R2,R3}.事实上,还可以定义一个最顶层角色OBJECT,其抽象谓词集合为空,它包含一个规划问题的所有对象.OBJECT可以在无语义歧义的情况下帮助调整循环结构(见第3.2.3节).通过最顶层角色和领域角色,可以形成一个规划问题的角色成员图(如图7所示).该图是一个有向无环图.沿着箭头方向,下层角色的特征包含上层角色的特征,下层角色的成员集合包含于上层角色的成员集合.图7显示了例3中规划问题对象的初始角色关系(图7(a))和利用引理1调整后的最终角色关系(图7(b)).另|IFSSequenceSet(πsub)|表示πsub所覆盖序列的个数.在定义7中,条件语句包含某个动作,指的是条件语句中动作与所包含的动作属于同一动作模型,但不一定是同一个动作实例,即对象常量可以不同.例6.在图5所示的规划解π=〈a1,…,a24〉中,设其对应的条件语句集合为IFS=〈IFS1,…,IFS24〉,则其中重复出现的子规划为πsub1=〈pickup,putdowntable〉,πsub2=〈pickuptable,putdown〉,它们覆盖的条件语句序列集合分别为IFSSequenceSet(πsub1)={〈IFS1,IFS2〉,〈IFS3,IFS4〉,〈IFS5,IFS6〉,〈IFS7,IFS8〉,〈IFS9,IFS10〉,〈IFS11,IFS12〉},IFSSequenceSet(πsub2)={〈IFS13,IFS14〉,〈IFS15,IFS16〉,〈IFS17,IFS18〉,〈IFS19,IFS20〉,〈IFS21,IFS22〉,〈IFS23,IFS24〉}.Page9识别循环的具体过程如算法2所示.算法2.识别循环.输入:条件语句集合IFS=〈IFS1,…,IFSn〉,角色集输出:通用规划GP1.FORj=1TOkDON_role[j]=02.FORi=1TOnDO3.FOReachobjectowhichstillappearsinIFSiDO4.IFexistssomerolejsuchthato∈member(rolej)5.N_role[j]=N_role[j]+16.letrolej(N_role[j])replacealltheoccurrences7.FOReachsub-planπsubinIFSDO8.IF|IFSSequenceSet(πsub)|2THEN9.index=110.WHILEindex〈|IFSSequenceSet(πsub)|DO11.findthemaximalsequence〈IFS_sindex,…,12.IFindex=index13.THENindex=index+114.ELSE15.make_loop(〈IFS_sindex,…,IFS_sindex〉)16.remove〈IFS_sindex,…,IFS_sindex〉from17.index=index+118.GP←IFS19.RETURNGP过程1.make_loop(〈IFS_si,…,IFS_sj〉).(1)AssumethatIFS_si=〈IFSi1,…,IFSik〉,whereIFSi1,…,IFSik∈IFS,andIFSi1=“IFinCurState(IFSi1_C)andinGoalState(IFSi1_G)THENai1ENDIF”(2)LetWSij=“WHILEinCurState(IFSi1_C)andinGoalState(IFSi1_G)DOai1IFS_s(i+1)IFS_sjENDWHILE”(3)MakeWSijtaketheplaceof〈IFS_si,…,IFS_sj〉inIFS算法2的第1~6步将条件语句中的对象转换为角色.由于多个对象可以属于同一角色,为了保证对象标识的一致性,角色用数字进行编号以标识不同的对象.要注意的是,角色替换的范围是整个规划解IFS,而不是单个条件语句IFSi.算法2的第7~17步将重复出现的子规划序列转换为循环结构.在子规划所覆盖的条件语句序列集合中,从第一个序列开始(第9步),找最长的可合一的序列子集(第10步).合一指的是通过对应角色的替换,使得条件语句完全相同.而角色替换的前提是角色相同,但是编号不同,不同角色不能替换.如果不存在可合一的序列,则从下一个序列开始找最大合一的过程(第13步).如果存在可合一的序列,则将这些序列转换为循环语句(第15步),并替换该序列子集出现在条件语句集合IFS中,然后从该序列子集的下一序列继续开始找最大合一的过程(第17步).其中循环语句的形成如过程make_loop所示:用子规划序列中第一个条件语句的条件部分(包括inCurState和inGoalState)作为循环语句的条件,用其包含的动作以及剩余的条件语句作为循环语句的语句体.定理3.算法2的时间复杂性为O(Nobject×Nrole+Nobject×n+Npredicate×n2),其中Nobject为规划问题所包含的对象数,Nrole为领域的角色数,Npredicate为规划领域的谓词集合大小,n为条件语句集合的大小.证明.设条件语句集合IFS=〈IFS1,…,IFSn〉,对于每个对象,找到其所属的角色需要O(Nrole)时间,在IFS中完成替换需要O(n)时间,因此算法的第1~6步所花的时间为O(Nobject×Nrole+Nobject×n).算法的第7~8步需确定子规划,每找到一个子规划需在IFS中扫描找其所覆盖的条件语句序列集合,因此总共花的时间为O(n2).由于条件语句所包含的谓词数不超Npredicate的常数倍,因此判断两个条件语句是否合一需花O(Npredicate)时间.判断两个条件语句序列对应位置是否合一需花O(Npredicate×n)时间.因此,算法的第11步找最长可合一序列子集需花O(Npredicate×n2)时间.算法的第16步形成循环语句需花O(n)时间.因此,算法2的时间复杂性为O(Nobject×Nrole+Nobject×n+Npredicate×n2).证毕.例7(续例3~6).将图5的规划解所生成的条件语句的对象用角色来替代(经过算法2的第1~6步),结果如下:IFS1:IFinCurState(empty)andinCurState(clear(RED1))andinCurState(on(RED1,BLUE1))THENpickup(RED1,BLUE1)ENDIFIFS2:IFinCurState(holding(RED1))THENputdowntable(RED1)ENDIFIFS3:IFinCurState(empty)andinCurState(clear(BLUE1))andinCurState(on(BLUE1,BLUE2))THENpickup(BLUE1,BLUE2)ENDIFIFS4:IFinCurState(holding(BLUE1))THENputdown-Page10table(BLUE3)ENDIFtable(BLUE1)ENDIFIFS5:IFinCurState(empty)andinCurState(clear(BLUE2))andinCurState(on(BLUE2,RED2))THENpickup(BLUE2,RED2)ENDIFIFS6:IFinCurState(holding(BLUE2))THENputdown-table(BLUE2)ENDIFIFS7:IFinCurState(empty)andinCurState(clear(RED2))andinCurState(on(RED2,BLUE3))THENpickup(RED2,BLUE3)ENDIFIFS8:IFinCurState(holding(RED2))THENputdowntable(RED2)ENDIFIFS9:IFinCurState(empty)andinCurState(clear(BLUE3))andinCurState(on(BLUE3,RED3))THENpickup(BLUE3,RED3)ENDIFIFS10:IFinCurState(holding(BLUE3))THENputdown-IFS11:IFinCurState(empty)andinCurState(clear(RED3))andinCurState(on(RED3,BLUE_BOTTOM1))THENpickup(RED3,BLUE_BOTTOM1)ENDIFIFS12:IFinCurState(holding(RED3))THENputdowntable(RED3)ENDIFIFS13:IFinCurState(clear(BLUE3))andinCurState(on-table(BLUE3))andinCurState(empty)THENpick-uptable(BLUE3)ENDIFIFS14:IFinCurState(holding(BLUE3))andinCurState(clear(BLUE_BOTTOM1))andinGoalState(above(BLUE3,BLUE_BOTTOM1))THENputdown(BLUE3,BLUE_BOTTOM1)ENDIFIFS15:IFinCurState(clear(BLUE2))andinCurState(ont-able(BLUE2))andinCurState(empty)THENpick-uptable(BLUE2)ENDIFIFS16:IFinCurState(holding(BLUE2))andinCurState(clear(BLUE3))andinGoalState(above(BLUE2,BLUE_BOTTOM1))THENputdown(BLUE2,BLUE3)ENDIFIFS17:IFinCurState(clear(BLUE1))andinCurState(on-table(BLUE1))andinCurState(empty)THENpick-uptable(BLUE1)ENDIFIFS18:IFinCurState(holding(BLUE1))andinCurState(clear(BLUE2))andinGoalState(above(BLUE1,BLUE_BOTTOM1))THENputdown(BLUE1,BLUE2)ENDIFIFS19:IFinCurState(clear(RED3))andinCurState(ontable(RED3))andinCurState(empty)THENpickuptable(RED3)ENDIFIFS20:IFinCurState(holding(RED3))andinCurState(clear(BLUE1))andinGoalState(above(RED3,BLUE_BOTTOM1))andinGoalState(above(RED3,BLUE3))andinGoalState(above(RED3,BLUE2))andinGoalState(above(RED3,BLUE1))THENputdown(RED3,BLUE1)ENDIFIFS21:IFinCurState(clear(RED2))andinCurState(ontable(RED2))andinCurState(empty)THENpickuptable(RED2)ENDIFIFS22:IFinCurState(holding(RED2))andinCurState(clear(RED3))andinGoalState(above(RED2,BLUE_BOTTOM1))andinGoalState(above(RED2,BLUE3))andinGoalState(above(RED2,BLUE2))andinGoalState(above(RED2,BLUE1))THENputdown(RED2,RED3)ENDIFIFS23:IFinCurState(clear(RED1))andinCurState(ontable(RED1))andinCurState(empty)THENpickuptable(RED1)ENDIFIFS24:IFinCurState(holding(RED1))andinCurState(clear(RED2))andinGoalState(above(RED1,BLUE_BOTTOM1))andinGoalState(above(RED1,BLUE3))andinGoalState(above(RED1,BLUE2))andinGoalState(above(RED1,BLUE1))THENputdown(RED1,RED2)ENDIF在子规划πsub1=〈pickup,putdowntable〉所覆盖的条件语句序列集合中,没有序列是合一的,因而不形成循环结构.而在πsub2=〈pickuptable,put-down〉所覆盖的条件语句序列集合中,〈IFS15,IFS16〉和〈IFS17,IFS18〉通过替换{BLUE1/BLUE2,BLUE2/BLUE3}①,形成最长合一序列,因此可形成循环结构(经算法2的第11~15步):WS15-18:WHILEinCurState(clear(BLUE2))andinCurState(ontable(BLUE2))andinCurState(empty)DOpickuptable(BLUE2)IFinCurState(holding(BLUE2))andinCurState(clear(BLUE3))andinGoalState(above(BLUE2,BLUE_BOTTOM1))THENputdown(BLUE2,BLUE3)ENDIFENDWHILE类似地,〈IFS21,IFS22〉和〈IFS23,IFS24〉通过替换{RED1/RED2,RED2/RED3},形成最长合一序列,因此也可以形成循环结构:WS21-24:WHILEinCurState(clear(RED2))andinCurState(ontablepickuptable(RED2)IFinCurState(holding(RED2))andinCurState(clear(RED3))andinGoalState(above(RED2,BLUE_BOTTOM1))andinGoalState(above(RED2,BLUE3))andinGoalState(above(RED2,BLUE2))①在〈IFS17,IFS18〉中,用BLUE2来替换BLUE1,用BLUE3Page11andinGoalState(above(RED2,BLUE1))THENputdown(RED2,RED3)ENDIFENDWHILE3.2.3调整上述阶段通过同类角色的替换来识别循环,有时候效果是非常有限的.例如,子规划πsub1=〈pick-up,putdowntable〉所覆盖的条件语句序列结构非常相似,但是由于涉及的角色不同,因此不能合一.为了尽可能识别循环,在进入调整阶段(或称后处理阶段),需根据问题特征,对已产生的结果进行半自动化或自动化的调整.首先进行人工参与的半自动化调整过程.在例7所示的子规划πsub1所覆盖的条件语句序列集合{〈IFS1,IFS2〉,〈IFS3,IFS4〉,〈IFS5,IFS6〉,〈IFS7,IFS8〉,〈IFS9,IFS10〉,〈IFS11,IFS12〉}中,我们发现这些语句中都没有出现inGoalState谓词,即它们所包含的动作与目标没有直接关联,即应用这些动作只是为产生目标创造中间条件.而上述条件语句序列因为角色不同而不能形成循环语句,因此在没有与目标直接关联的情况下,我们可以认为不同角色可能不存在差异.这样的调整是试探性和经验性的,精确的理论证明费时费力,其代价是值得商榷的.观察图7,发现这些条件语句中所涉及的角色BLUE、RED和BLUE_BOTTOM具有共同的上层角色OBJECT,因此考虑以下替换:〈IFS1,IFS2〉:{RED1/OBJECT1,BLUE1/OBJECT2}〈IFS3,IFS4〉:{BLUE1/OBJECT1,BLUE2/OBJECT2}〈IFS5,IFS6〉:{BLUE2/OBJECT1,RED2/OBJECT2}〈IFS7,IFS8〉:{RED2/OBJECT1,BLUE3/OBJECT2}〈IFS9,IFS10〉:{BLUE3/OBJECT1,RED3/OBJECT2}〈IFS11,IFS12〉:{RED3/OBJECT1,BLUE_BOTTOM1/可以使得{〈IFS1,IFS2〉,〈IFS3,IFS4〉,〈IFS5,IFS6〉,〈IFS7,IFS8〉,〈IFS9,IFS10〉,〈IFS11,IFS12〉}形成最长合一序列,因此经过算法2的make_loop过程可以形成如下循环结构:WS1-12:WHILEinCurState(empty)andinCurState(clear(OBJECT1))andinCurState(on(OBJECT1,OBJECT2))DOpickup(OBJECT1,OBJECT2)IFinCurState(holding(OBJECT1))THENputdowntable(OBJECT1)ENDIFENDWHILE其次进行自动化调整.这个步骤主要完成两个方面的工作:一是简化条件语句,如果同一语句中前后两个动作存在着因果链关系,则因果链所支持的前提在前一个动作完成的状态中必然成立,因此可以在后一个动作的条件语句中删除;二是将角色转换为对象变量,使用角色是为了方便识别循环,而在解析通用规划程序时需还原为谓词的参数,因此在条件语句中添加角色的特征谓词,即可将角色转换为变量.具体过程见算法3.算法3.后处理算法.输入:通用规划GP输出:经过调整的通用规划GP1.FORanytwoactionsaiandai+1insomesamestate-2.IFthereexistsacausallinkai→pai+1THENremovespfromthepredicateinCurStateoftheconditionstatementwhichcontainsai+1inGPmentofGPDO3.FOReachroleinGPDO4.replacerolewithsomevariable,andatthesametimeaddtheabstractpredicatesetofroleintothepredicateinCurState定理4.算法3的时间复杂性为O(n),其中n是规划解的长度.定理4的证明相对简单.完成算法3所述的两方面工作,需两遍扫描通用规划GP,因此时间复杂性是O(n).例8.例7中的通用规划解经过调整阶段后,结果如下:WS1-12:WHILEinCurState(empty)andinCurState(clear(?x))andinCurState(on(?x,?y))DOpickup(?x,?y)putdowntable(?x)ENDWHILEIFS13:IFinCurState(clear(?x))andinCurState(ontable(?x))andinCurState(empty)andinCurState(color(?x,blue))THENpickuptable(?x)ENDIFIFS14:IFinCurState(holding(?x))andinCurState(color(?x,blue))andinCurState(color(?y,blue))andinCurState(bot-tom(?y))andinCurState(clear(?y))andinGoalState(above(?x,?y))THENputdown(?x,?y)ENDIFWS15-18:WHILEinCurState(clear(?x))andinCurState(ontablePage12(?x))andinCurState(empty)andinCurState(color(?x,blue))DOpickuptable(?x)IFinCurState(clear(?y))andinCurState(color(?y,blue))andinCurState(above(?y,?z))andinCurState(color(?z,blue))andinCurState(bottom(?z))andinGoalState(above(?x,?z))THENputdown(?x,?y)ENDIFENDWHILEIFS19:IFinCurState(clear(?x))andinCurState(ontable(?x))andinCurState(empty)andinCurState(color(?x,red))THENpickuptable(?x)ENDIFIFS20:IFinCurState(clear(?y))andinCurState(color(?y,blue))andinCurState(above(?y,?z))andinCurState(color(?z,blue))andinCurState(bottom(?z))andinGoalState(above(?x,?z))andinGoalState(t(color(?tblue)→above(?x,?t)))THENputdown(?x,?y)ENDIFWS21-24:WHILEinCurState(clear(?x))andinCurState(color(?x,red))andinCurState(ontable(?x))andinCurState(empty)DOpickuptable(?x)IFinCurState(clear(?y))andinCurState(color(?y,red))andinCurState(color(?z,blue))andinCurState(bottom(?z))andinCurState(above(?y,?z))andinGoalState(above(?x,?z))andinGoalState(t(color(?tblue)→above(?x,?t)))THENputdown(?x,?y)ENDIFENDWHILE在例8中,首先要注意的是在同一个语句(不管是IFS或WS)中,相同的变量名代表同一变量,不同的变量名代表不同变量.其次,在WS1-12中,由于存在着因果链pickup(?x,?y)holding(?x→)putdowntable(?x),因此条件得到约简.类似的情况也发生在WS15-18和WS21-24中.最后,根据原有目标描述xy(color(xblue)∧color(yred)→above(yx))以及已得到的通用规划语句中已经包括所有对象的事实,在WS21-24中增加全称量词(IFS20也是类似的处理),使得inCurState(color(?t1,blue))andinCurState(color(?t2,blue))andinCurState(color(?t3,blue))andinGoalState(above(?x,?t1))andinGoalState(above(?x,?t2))andinGoalState(above(?x,?t3))改写为inGoalState(t(color(?tblue)→above(?x,?t)))这样改写之后的通用规划语句不仅摆脱了学习用例对其形式的束缚,而且还增强了可读性.最后,要说明的是,对于ColorBlockTower领域而言,例8中的通用规划解实际上包含以下几个步骤:第1步(WS1-12):将不是底木块的所有木块均放在桌上;在底木块上;木块塔上;木块塔上.4实验分析第2步(IFS13~IFS14):选择一个蓝色木块放第3步(WS15-18):将剩余的蓝色木块依次放在第4步(IFS19~IFS20):选择一个红色木块放在塔顶的蓝色木块上;第5步(WS21-24):将剩余的红色木块依次放在本实验部分开发一个系统GPLANNERDP,用以验证以上算法(算法1~3)的可行性以及评估通用规划的质量.整个系统GPLANNERDP用EclipsePlatform(Version3.3.2)开发,由三部分组成:Gp_learn.c、Gp_instance.c和Gp_testdata.c(如图8所示).Gp_learn.c实现算法1~3,用于提取通用规划.它需要从具体规划解文件Solution.txt中获取动作序列,从领域描述文件Domain.PDDL中读取动作模型、派生谓词规则以及领域类型信息等,从具体问题描述文件Problem.PDDL中读取初始状态、目标状态、问题对象以及角色信息等,而产生的通用规划解保存在文件GP.txt中.Gp_testdata.c用于从给定的参数随机生成测试问题(存放于文件Test_Problem.PDDL中).Gp_instance.c是一个通用规划的解释程序,基于测试问题的信息,执行通用规划所表示的程序,从而得到具体问题的解(存放于文件Test_Solution.txt中).Page13系统GPLANNERDP三个部分的具体实现步骤见表3.其中需特别说明的是Gp_instance.c的第4个步骤.通用规划的执行像程序一样,顺序地从第一个语句开始,直到最后一个语句.如果待执行的是条件语句,只需执行一次,即在当前状态下找到一组满足应用条件的对象实例,执行动作并扩充状态,即可执行下一条语句.然而,如果待执行的是循环语句,则可能会执行多次,直到不存在满足应用条件的对象实例为止.当执行完整个通用规划程序后,如果所产生的终止状态满足目标条件,则宣告成功求解,否则宣告失败.在执行过程中,每执行完一个动作,需用实例化规则对当前状态进行推导使其包含所有应该成立的派生谓词实例.本实验主要评估提取通用规划的复杂性和规划实例化的复杂性.前者是指从具体规划解中提取通用规划解所花的时间.后者是指从通用规划解中获取实例规划解所花的时间.机器环境为CPU(Celeron2.66GHz)+RAM(1GB)+Windows2008+gcc4.3.0,开发平台为EclipsePlatform(Version3.3.2).实验领域及结果如表3.表3系统GPLANNERDP各部分的具体实现步骤程序Gp_learn.cGp_instance.cGp_testdata.c4.1ColorBlockTower领域该领域是本文学习通用规划的例子领域,完整领域描述见附录1.它改编于经典的BlockWorld领域,要求把所有红色木块放在蓝色木块的上方.学习到的一个通用规划解如例8所示.表4给出了在不同规模的训练例下提取通用规划所花的时间.提取的结果为:当红色木块数#RED2且蓝色木块数#BLUE3时,学习到的通用规划均如例8所示.表4提取ColorBlockTower领域通用规划所花的时间问题参数#RED=3#BLUE=40.0280.0100.0000.038#RED=6#BLUE=80.0840.0080.0000.092#RED=7#BLUE=90.1120.0090.0010.122#RED=7#BLUE=100.1300.0100.0010.141#RED=8#BLUE=100.1520.0090.0010.162#RED=9#BLUE=100.1880.0080.0010.197#RED=10#BLUE=100.2010.0100.0010.212在表4中,T1,T2和T3分别表示实现算法1、2和3所花的时间,T表示提取通用规划(运行Gp_learn.c)所花的总时间.从表4中可以看到:(1)T一般很小,不超过1s;(2)T2和T3不受问题规模的影响,比较稳定;(3)T1随着问题规模的增大而逐步增加,因为其包含的步骤如规划图的建立和为扩充状态而进行的规则实例化都与问题规模有关.表5给出GPLANNERDP用学习到的通用规划来求解规划问题实例的时间开销,同时与另外一个能够求解派生谓词规划问题的规划系统LPG-td[26]进行比较.LPG-td在规划空间进行局部搜索,为处理派生谓词建立规则图,并使用激活集来替换动作图中的派生谓词实例.LPG-td在IPC-4(唯一引入派生谓词规划领域的国际规划竞赛)上表现优异,而其它具有相似能力的规划系统不仅性能不佳而且还存在一些严重的局限.例如Marvin不能直接处理ADL风格的派生谓词规划问题,只能先将其编译成STRIPS风格然后再进行求解,因此不适宜用于性能比较(本文的测试问题均为ADL风格).测试问题用Gp_testdata.c来生成,即输入问题参数#RED和#BLUE(其中一个蓝色木块作为底木块),随机产生木块的初始位置(即每个木块可选择放在桌上或者其它木块之上).对于相同的一组问题参数,随机生成3个问题(初始状态不同,目标状态相同),来测试该问题规模下的求解时间,结果如表5所示.Page14表5使用通用规划求解ColorBlockTower问题并与LPG-td进行比较#RED=2#BLUE=3#RED=3#BLUE=4#RED=5#BLUE=6#RED=6#BLUE=8#RED=7#BLUE=9#RED=7#BLUE=10#RED=8#BLUE=10#RED=9#BLUE=10#RED=10#BLUE=10在表5中,#RED和#BLUE是问题规模的参数,分别表示红色木块和蓝色木块的个数.No表示问题编号.#I表示初始状态的命题数,#G表示满足目标条件的命题数.由于同组的规划问题随机生成,因此#I可能不相同,但是#G相同.在GPLANNERDP的实验数据中,#instance表示尝试满足语句应用条件的对象实例的总和.实际上,在应用通用规划时,也存在着搜索空间,只不过其中的结点是对象实例,而不是状态.#instance反应了此搜索空间的大小,也解释了为什么在问题规模变大时,应用通用规划求解也需花较长的时间.运行LPG-td时采用“-n2”模式,即每次返回两个解,第2个解在第1个解的基础上改进质量,是“-speed”模式和“-quality”模式的一种折衷.为了比较GPLANNERDP和LPG-td的性能,参照近似算法的性能测试法,定义性能比η如下.定义8.性能比.定义性能比η{=maxCGPlanCLPGCLPGC}GPlan999202018363436444640525248585652626460645864666268标,CLPG表示LPG-td的性能指标.(3)在相同的问题参数下,GPLANNERDP求解同组问题所需时间近似,因此尽管规划问题随机生成,但是问题参数足以说明问题求解难度.由于规划问题是极小化问题(需时间最少或动作最少),性能比越大,表示两个算法的差距越大,而且性能指标小的一方越优越.从表5中可以看到:(1)LPG-td对于参数#RED5且#BLUE6的问题无法求解(在进行一段时间后,自动退出),而GPLANNERDP均可以求解这些,尽管对于规模较大的问题(例如#RED=10且#BLUE=10),其需要较长的时间(因为需尝试的实例多);(2)根据性能比,相比较LPG-td而言,GPLANNERDP在更短的时间内返回更好的解,并且性能比的值都比较大(例如#RED=3且#BLUE=4时),表明GPLANNERDP在求解ColorBlockTower问题时比LPG-td要优越得多;Page15还需要补充说明的是:第一,LPG-td难以求解的主要原因是因为该类问题目标状态不唯一(实际上数量非常多),造成估值困难,搜索空间异常庞大;第二,不像Rocket问题(如图1所示),其目标状态唯一,因此在领域对象较多时,不管是规划系统还是通用规划程序都能在一定程度上求解,而对于ColorBlockTower问题而言,在其领域对象不多时,由于目标状态的多样性问题本身就难以求解了,因此通用规划程序在两个领域的求解时间不具有可比性.此外,只要给定充足的时间和计算资源,例8所示的通用规划可以求解问题参数#RED2且#BLUE3的任意ColorBlockTower问题.4.2只有above目标的BlockWorld领域该领域在BlockWorld的基础上增加了派生谓词规则,其完整领域描述见附录2.为了增加难度,本文对该领域的测试问题做了特殊的约束,即目标条件全部由above谓词组成.该领域的问题参数为#BLOCK,表示木块的个数.为了得到求解率高的通用规划解,需在领域中增加额外的派生谓词及其规则.增加的派生谓词包括good-position(?x-block)和link(_?x-block?y-block_),前者表示木块?x处于适宜的位置,无需再挪动,后者表示木块?x与木块?y之间有链接关系._是参照逻辑程序设计的匿名变量标记,表示0个或者多个参数.它们的推导规则如下:R1:(:derived(link?x?y)(above?x?y))R2:(:derived(link?x?y?z)(or(and(above?x?y)(above?y?z))(and(above?x?y)(above?x?z))(and(above?x?z)(above?y?z))))R3:(:derived(link_?x_)(and(link_?x)(link?x_)))R4:(:derived(good-position?x)(or(exists(?y-block)(and(link_?x?y_)(on?x?y)))(not(exists(?y-block)(and(link_?x?y_)对上述谓词和规则的解释如下.link是一个带有可变参数的谓词,表示多个木块之间有从上往下的相对位置关系.它突破了above的限制,因为后者只表示两个木块间的上下相对位置关系.link由above进行直接或间接推导,对于不确定的位置关系进行明确约束,例如规则R2,这种约束显然不是唯一的,但是只要满足原始目标的含义即可.规则R3对于首尾变量相同的链接关系进行连接,期望以长的链接来取代短的子链,以减少匹配的候选.规则R2和规则R3还保证了木块处于唯一的链接关系中.规则R4定义处于适宜位置的木块,或者为按照链接关系已放好的木块,或者为没有跟其它木块有任何链接关系而放在桌上的木块.在增加了这些谓词和规则后,原问题的目标条件变为x(good-position(?x)).学习到的一个通用规划如下.实际上,对于#BLOCK2的训练例学习到的通用规划均相同.WS1:WHILEinCurState(empty)andinCurState(clear(?x))andinCurState(on(?x,?y))DOpickup(?x,?y)putdowntable(?x)ENDWHILEWS2:WHILEinCurState(empty)andinCurState(clear(?x))andinCurState(ontable(?x))andinCurState(not(good-posi-tion(?x)))DOpickuptable(?x)IFinCurState(clear(?y))andinCurState(good-position(?y))andinCurState(link(_?x?y_))andinGoalState(good-position(?x))THENputdown(?x,?y)ENDIFENDWHILE该通用规划由两个while语句组成.WS1负责把所有木块放在桌上,而WS2则把原above目标中涉及的木块按照链接关系放置好,而没有链接关系的木块仍然留在桌上.上述通用规划给出了满足目标条件的一种特定形式的解,而非问题的所有可能解,这是因为目前找包含所有解的通用规划与找可满足问题的所有解一样困难.上述通用规划的获取时间与ColorBlockTower领域的实验结果非常类似(一般不超过1s),这里不再赘述.测试问题用Gp_testdata.c来生成.输入问题参数#BLOCK,随机产生木块的初始位置.above目标同样随机生成,但是其个数控制在#BLOCK/3~#BLOCK的范围之间.对每组问题参数随机生成2个问题来测试,结果如表6所示.LPG-td同样运行在“-n2”模式下.从表6中可以看到:(1)LPG-td无法求解参数#BLOCK9的问题,而GPLANNERDP均可以求解,尽管对于规模较大的问题(例如#BLOCK=15),GPLANNERDP可Page16表6使用通用规划求解只有above目标的BlockWorld问题并与LPG-td进行比较#BLOCK=4#BLOCK=6#BLOCK=7#BLOCK=8111621020.155#BLOCK=911469410825.118#BLOCK=101158138766133.702#BLOCK=1211855420.121#BLOCK=1512288223937.288能需要较长的时间;(2)根据性能比,相比较LPG-td而言,GPLANNERDP在更短的时间内返回更好的解,并且性能比的值都比较大(例如当#BLOCK7时),表明GPLANNERDP在求解只有above目标的BlockWorld问题时比LPG-td要优越得多;(3)尽管问题参数相同,但是由于随机生成的规划问题的个体差异(主要是目标状态不同),GPLANNERDP的求解时间有时大相径庭(例如#BLOCK=15).因此在该领域中问题参数不足以说明问题的求解难度.5结束语本文提出在派生谓词规划领域提取通用规划的一般方法.该方法扩展了现有通用规划研究的适用领域,还能用来求解一类特别“难”的派生谓词规划问题.这类问题由于目标状态不唯一,导致基于搜索的规划系统难以求解.而通用规划之所以能够求解,是因为其通过描述动作应用的条件和目的,可以在相对简单的实例空间内进行搜索从而避开庞大的状态或者规划空间.与以往通用规划的研究不同,本文将集中在STRIPS领域的提取方法推广到派生谓词规划领域.具体提取过程分为3个步骤:根据实际规划解构造规则规划图从而产生包含动作应用条件和8101414141824182624302226303640目的的条件语句;将条件语句中的对象角色化从而识别循环结构;将角色参数化从而得出算法形式的通用规划解.本文实现了一个产生和应用派生谓词规划领域通用规划的系统GPLANNERDP,在一些实验领域上的结果表明根据以上步骤提取的通用规划不仅容易获取,而且求解性能也颇佳.本文的工作尽管取得了初步的成果,但是未来还有许多工作需继续进行.这主要体现在以下三个方面.首先,用通用规划来求解问题实例的时间应进一步减少,即在应用语句时不是盲目地搜索实例,而可以考虑有启发性地选择实例.这可以借助于主动学习(activelearning)[32-33]技术来进行.主动学习指的是选择性地使用实例来进行学习.其目标是尽可能地用最少的实例来学习到精确的规则或者模型,这样可以加快学习的速度.在主动学习中,一般通过询问来选择实例,询问可以是关于实例或者关于实例的特征.借助于主动学习,在通用规划应用的实例空间中,我们可以优先选择与当前状态有关联的实例来产生具体动作.关联性可体现在具有相同的对象或者参数等方面.这样通过启发式地选择实例,加快通用规划求解问题实例的过程.其次,应给出本文方法在正确性方面的初步证明.这里正确性指的是在什么情况下一定可以从通用解中找出具体问题的具体解,也称为通用规划的Page17适用条件.从通用规划的研究历史可以看到,提出提取方法是相对简单的,而要证明方法的正确性却是比较困难的.一些方法借助逻辑程序理论来保证其正确性[3,7],而另一些方法在非常严格的限制条件下给出可适用的条件[11,34].本文提出了在非经典规划领域下的通用规划的提取方法,解决如何处理派生谓词以及如何增加语义关联等问题,并且通过实验来证明方法的可行性和优越性.但是,在正确性证明方面,本文缺乏深入的探讨.因此进一步的研究工作可以考虑利用逻辑程序或者增加限制条件来证明通用规划的正确性.再有,将本文方法推广到其它的规划领域.这些规划领域或者具有复杂的动作模型,或者具有多元化的规划目标.如果动作模型具有不确定性、时态或者数值等复杂特征,那么对于通用规划的提取方法来说无疑是非常大的难题.这可以作为通用规划研究的一个长期目标.但是在多元化的规划目标中,能保证最优解的通用规划是非常有意义的.目前也有一些研究提出学习最优规划的方法[35-36].通用规划的最优性需要严格的形式化方面的证明,在目前的研究状况来看,这一方面还很欠缺.因此通用规划的最优性也是未来的主要研究方向之一.
