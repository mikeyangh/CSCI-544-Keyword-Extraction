Page1(犾,犱)-模体识别问题的遗传优化算法霍红卫郭丹丹于强张懿璞牛伟(西安电子科技大学计算机学院西安710071)摘要转录因子结合位点识别在基因表达调控过程中起着重要的作用.文中提出了一种贝叶斯模型驱动的模体识别的遗传优化算法GOBMD(GeneticOptimizationwithBayesianModelforMotifDiscovery).GOBMD首先使用一个基于位置加权散列的投影过程,将输入序列中的l-mers投影到k维(k<l)子空间,找出DNA序列中的起始良好候选模体,作为遗传算法的初始群体,以进一步求精.在遗传迭代过程中,采用结合贝叶斯模型的适应度函数指导进化过程.模拟数据的实验结果表明,与Gibbs、WINNOWER、SP-STAR、PROJECTION这些模体识别算法相比,GOBMD在对植入(l,d)-模体识别时有较好的性能,能够解决大部分挑战性的植入(l,d)-模体识别问题.此外,作者用Boxplot显示了上述模体识别算法在模拟数据识别上的性能系数分布,结果表明GOBMD具有较好的效率.针对真实生物序列的实验结果同样表明了GOBMD算法的有效性.关键词模体识别;遗传算法;贝叶斯模型;散列;投影1引言识别未经比对的DNA序列中的模式(也称模体)是生物信息学中的一个基本问题,对于发现调控信号和破解基因组中的调控编码有着重要的意义.虽然近20年来,出现了解决该问题的很多算法,但由于模式通常较短、退化以及规律性较差,使得设计一种识别隐含在给定未比对序列中模体的方法仍然是一个难题[1].模体识别算法可以分为3大类[2]:(1)基于单个基因组的共调控基因的启动子序列识别模体的算法;(2)基于多个物种的单个基因的直系启动子序列(即进化足迹)的识别模体的算法;(3)基于共调控基因和进化足迹的启动子序列识别模体的算法.早期的模体识别算法分为两类:词枚举法和位置权重矩阵(PositionWeightMatrix,PWM)更新法.词枚举法表示简单,利于使用统计方法准确枚举模体在基因组中的生物学意义,并能保证全局最优性.但这种方法只适合于较短模体[3].YMF[4]是基于词枚举的方法,它使用三阶马尔可夫模型来对背景序列建模,输出Z-得分最大的模体.其它方法还有基于统计推理的WORDUP[5]以及基于后缀树的WEEDER[6].Marsan和Sagot[7]扩展了这种方法,采用优化的数据结构(如后缀树)改进了这种方法的性能,并用于复合模体的识别.MITRA算法[8]是以Pevzner和Sze[9]提出的WINNOWER算法为基础,采用不匹配树作为数据结构,提出了修剪模式空间的新方法MITRA,该方法可以更有效地使用相似对信息,可以解决像二联体这样的复合模式识别问题,也能求解(15,4)问题.基于谱的方法[10-11]在实际中非常有用,但不能保证收敛到最佳二分体信号,且在检测较弱的二分体信号时可能失效.基于概率模型的方法需要使用最大似然估计或贝叶斯推理来估计其参数.在基于概率模型的方法中,是使用位置权重矩阵表示模体模型.虽然基于概率模型的方法要求较少的参数,但是这种方法依赖于调控区域的概率模型,对于输入数据的微小变化非常敏感.这种方法能够定量捕获一组DNA位点的变异信息.最有代表性的方法有BioProspector[11]、CONSENSUS[12]和MEME[13].BioProspector是一种基于吉布斯采样的方法,它使用0~3阶的马尔可夫背景模型,模型参数由用户给定,或者从一些特定序列估计而得,模体的统计重要性由MonteCarlo方法所估计的得分分布来确定.CONSENSUS是一种基于贪心概率模型的方法,它根据大方差统计法来估计一个给定的信息容量的统计意义,并输出具有最大信息容量的位点.MEME扩展了Lawrence和Reilly[14]提出的模体发现的EM算法,将每个长为l的子序列l-mer转化为一个字符概率矩阵,并使用此矩阵作为EM算法的起点.在模体已知信息较少的情况下,可以识别未经比对的生物高分子序列中的新的模体.算法输出具有最强统计意义的模体(E-值).这种方法几乎保证了EM算法的良好起始点.然而,对于各种长度的l-mers(如6~30),检查所有可能的起始点对于大型数据集而言,计算复杂度较高,计算时间较长.AlignACE[15]是一种基于吉布斯采样的方法,它使用最大先验对数似然(MaximumaPriorilog-likelihood,MAP)得分来评价所采样的不同模体.PROJECTION算法[16]通过投影模板将输入序列中的每个l-mer投影到一个较小的空间中,再使用EM算法进行求精.Xie等人[17]首先枚举出长为12~22的l-mer的候选列表,然后对于人类基因组的一组非编码保守元素,统计匹配上的实例个数.算法MDScan[18]首先搜索ChIP-array高度丰富的片段,得到多个候选模体模式,然后通过贝叶斯统计公式导出的统计得分函数来指导更新过程,不断更新和求精候选模体.Zhang等人[19]提出了一种结构模体提取算法EXMOTIF.最近,Bi[20]提出了在局部比对空间中进行随机采样的模体识别的蒙特卡罗EM算法MCEMDA.MCEMDA从初始模型开始,然后迭代执行蒙特卡罗模拟,并进行参数更新,直到收敛.Davila等人[21]提出了植入(l,d)-模体识别的快速精确算法,可以解(17,6)和(19,7)这样的难题.Zare-Mirakabad等人[22]提出了基于遗传算法识别二联体模式的方法,建立了以SP值、匹配数和信息容量多个目标的适应度函数.Li[23]提出了耦合EM算法的遗传算法来识别二联体的方法.Wei和Jensen[24]使用位置权重矩阵作为模体描述模型,并在标准遗传算法的基础上,引入了面向模体识别问题的两个特定的遗传算子.Huo等人[25-26]提出了模体识别的优化遗传算法.由于遗传算法在进行全局搜索时,还维持着一个候选解组成的群体,这样遗传算法就比那些局部搜索和单点搜索方法更有效,然而,基于遗传算法的Page3模体识别方法,由于表示候选模体的初始群体是随机产生的,加之搜索空间巨大,需要较大的群体规模和迭代次数,这样就会对遗传算法的速度和有效性产生一定的影响.本文中我们提出了模体识别的新算法GOBMD(GeneticOptimizationwithBayesianmodelforMotifDiscovery),并将该算法应用于转录因子结合位点的识别.GOBMD结合随机投影策略和散列法计算出候选模体,作为遗传算法的初始群体进行优化,在适应度函数中结合信息熵和贝叶斯模型,更准确地表征了每个候选模体的特征.此外,对结果采用局部优化技术,提高了识别性能.模拟数据的实验结果表明,与Gibbs、WINNOWER、SP-STAR、PROJECTION这些经典的模体识别算法相比,GOBMD在进行植入模体识别时有较好的性能,能够解决大部分挑战性的植入模体问题.同时,我们利用图盒对这些方法的性能系数的统计意义做了阐述,结果表明GOBMD具有较好的效率.针对真实数据的实验结果同样表明了GOBMD算法的有效性.2方法概述2.1植入(犾,犱)-模体识别问题所谓植入模体识别问题,是指在含有植入模体实例的DNA序列中定位出植入模体实例的过程.由于基因变异的影响,植入(l,d)-模体的各个植入模体实例并不完全匹配,而是在部分碱基位上存在变异.植入(l,d)-模体识别问题(Planted(l,d)-MotifProblem,PMP)的形式定义如下.定义1.给定含有植入模体实例的DNA序列的一个集合S={s1,s2,…,st},|si|=n,i=1,2,…,t,及未知模体M的长度l,满足0d<l<n.(l,d)-模体识别问题定义为:确定一个满足|x|=l的l-merx(称为模体),使得si中存在长为l的模体实例xi,满足x与xi至多在d个位置不同,i=1,2,…,t.生物信息学中通常用l-mer表示长为l的序列.如果植入模体实例是完全保守的,即模体位点未发生变异,那么植入(l,d)-模体识别问题可以简化为计算长度为l的子串在DNA序列中出现次数的问题.如果植入模体实例不是完全保守的,那么植入(l,d)-模体识别问题的实质是一种相似比对.Buhler和Tompa[16]对植入(l,d)-模体识别问题的难度进行了详细的概率分析,并且导出在每条DNA序列至少包含一个植入模体实例的情况下,植入模体实例个数的期望值为E(l,d).其中Pd是含有d个变异的植入模体实例出现在DNA序列的某个位置的概率,n是DNA序列的长度,t是DNA序列的个数.数学期望E的意义在于能够事先估计求解植入(l,d)-模体识别问题的难度,这个计算结果表示随机生成的t条长度为n的DNA序列中可能存在的植入模体实例个数的期望值.2.2GOBMD算法优化遗传算法GOBMD首先利用随机投影算法RPS[25]所构造的模体候选集作为初始群体P0;然后,执行遗传算法的迭代过程,在适应度函数中结合了信息熵及贝叶斯模型,用以评价每个个体,并通过交叉算子和变异算子的作用,更新每一代群体,不断重复这个过程,直到收敛;最后,执行局部优化过程,消除遗传迭代后结果可能出现的漂移问题.GOBMD模体发现算法如下所示.算法.GOBMD(t,n,l,d,k,θ,m,pc,pm).1.createtheinitialpopulationP0byRPS2.evaluatethepopulationinP0withBayesianscoring3.while(stoppingcriteriaisnotsatisfied)do4.performselectionoperator5.performmutationoperator6.performcrossoveroperator7.evaluatecurrentpopulation8.performtheelitiststrategy9.localoptimization10.return其中,k为投影规模;θ为桶的阈值;m为投影次数;pc、pm分别为交叉概率和变异概率,我们将在4.1节详细讨论这些参数的选取和计算.2.3基于散列的随机投影在随机投影算法RPS[25]的每一次投影中,序列中的每个l-mer按照投影模板被投影到相应的桶中,计算每个合格桶(桶中序列数达到给定阈值的那些桶)的位置权重矩阵犠,进而计算出每条输入序列中在该矩阵下具有最大似然比的一个l-mer,并记录其所在位置.从而得到t个l-mer,由此计算出其频率权重矩阵犉犠犕及其一致序列,该一致序列即为初始群体的一个个体.图1给出了一个一致序列的构造过程.Page4比对矩阵ACGTTAGT犉犠犕一致序列ACGTACGT从每条DNA序列中选出一个位置,由所有这些位置处的l-mer可构造出一个比对矩阵.图1中的比对矩阵是5个8-mer构成的比对矩阵实例.然后,统计出这个矩阵中每列中字符的频率,选择每列中频率最大的字符,即可得到一致序列.对于每个合格桶,均可构造出这样的一个个体.基于随机投影策略的初始群体的构造过程如图2所示.投影算法RPS在每一次投影前随机选取1~l个碱基位中的k(kl)个无重复的投影位置组成的集合p,p={pi|1ik<l,1pil}.然后,算法通过一个投影函数f,根据投影位置集p将DNA序列中的每个l-mer投影到相应的桶中,接着进入下一次投影.经过m次投影之后,就会发现某些桶内的l-mer和模体的一致序列在许多碱基位上是相同的,这样就为进一步搜索提供了较好的初始点,同时,缩小了搜索空间.为了保证经过m次k个位置的投影之后,能以高概率(95%以上)得到至少一个较好的初始点,文献[16]给出了成为合格桶的阈值θ的经验值4,以及投影大小k和投影次数m的具体的计算方法.在同一个合格桶中的l-mer的共同的特征是:在投影的相应位置上的碱基都相同.对于合格桶中的l-mer,可以计算出其一致序列,在此基础上,再对合格桶施加一个逐步求精的迭代步骤就可以还原出原始模体.根据投影位置集p及对应位置上的碱基,可以构造一个散列函数,来实现这个投影过程,并将散列函数值作为桶的标识.桶的标识计算如下:对l-mer在投影位置上的碱基进行数字编码,A为1,C为2,G为3,T为4,在k个投影位置之外的碱基编码为0,即投影时不考虑其它位置上的碱基.可以看出这是一个5进制数的编码.给定投影位置集p以及l-mer,定义l-merx的第j个位置的权值w(j)为其中,b为b进制的基数,对于DNA序列,b取值为5.定义l-merx在投影p下的散列值hp(x)为其上每个位置权值与其对应碱基编码乘积之和模B的结果:其中,p为投影位置集;xj是与l-merx的第j个位置的碱基所对应的数字编码,范围为[1,4],B是散列表的大小.将有相同散列值的l-mer存放到同一个桶中,桶的标识即为该散列值,如图3所示.图3随机投影(其中l=7,k=4,p=(1,2,5,7))当m次投影结束之后,由合格桶的集合构造遗传迭代需要的初始群体P0,具体的构造方法是根据合格桶内的所有l-mer形成该桶的位置权重矩阵犠,在每条输入序列中寻找一个使L(x|犠)达到最大的l-merx,将找到的t个l-mer形成它们的一致序列和频度权值矩阵犉犠犕,将该一致序列作为个体放入初始群体集合P0中.其中P(xi|犠)为碱基xi在位置权重矩阵犠的第i列出现的概率.3编码及适应度函数在每一次投影结束之后,保存产生的合格桶到Page5一个集合中,该集合内的元素在m次投影之后全部为较优的初始模体(合格桶),在该集合中挑选部分或者全部的合格桶形成初始群体,在初始群体的基础上执行遗传算法的迭代过程,终止时最优的个体为所查找的模体.3.1个体表示由于初始群体是由存放合格桶的集合形成的,那么每个合格桶就对应着初始群体中的一个独立个体(这里按照初始群体对个体数目不做限制进行讨论).首先将每个合格桶数据结构转化为初始群体中图4一个8元组的构造过程3.2适应度函数首先通过RPS构造出候选模体,将其作为遗传算法的初始群体,其中每个个体对应着一个位置权重矩阵.然后,通过交叉算子、变异算子等的操作,产生新一代群体,新群体中的每个个体所对应的位置权重矩阵为新的位置权重矩阵,使用更新后的位置权重矩阵扫描输入数据的结合位点.最后,结合贝叶斯模型[24,27],计算比对结合位点(矩阵)的得分值,作为结合位点适应度的评价.如式(5)所示.ψent(A)=|A|logp^0其中,|A|是预测的位点数,即在序列集合里出现的植入模体实例个数之和;p^0=|A|/L是预测的模体实例出现的频率,其中L=Σi(li-w+1)表示模体A中潜在的模体实例个数之和;∑w预测模体的矩阵频率θ^jk和背景频率θ0k之间的相对图5变异算子的每个个体.采用如下方法:首先由合格桶内的所有l-mers计算出该桶的位置权重矩阵犠;然后,在每条输入序列中找出一个使得似然L(x|犠)达到最大的l-merx.对于t条输入序列,可以找出t个这样的l-mer,由这些l-mer所在相应序列中的位置可构成一个t-元组(b1,b2,…,bt),如图4所示,其中bi表示模体在第i个序列中起始位置.将每个这样的t元组作为群体中的一个个体.重复这个过程,由每个合格桶都可得到一个t-元组,从而也就形成了遗传算法的初始群体.熵.通常将少量的伪数目β加到预测模体矩阵的每个元素上,以确保模体的位置权重矩阵中的所有元素θ^jk均不为零.3.3遗传算子变异算子作为一种局部随机搜索算子,可以保证遗传算法群体的多样性,它与交叉/选择算子结合在一起,保证了遗传算法的有效性.本文算法采用单点变异,变异算子在个体(b1,…,bi…,bt)中随机选择一个位置i,然后以概率pm对该位置上的值bi进行变异,发生单点变异后的个体为(b1,…,bi…,bt),即序列i中的植入模体实例起始位点由序列i的第bi个位点变成了序列i的第bi个位点,如图5所示.在图5中,元组(4,3,5,9,2)的第3个位置上的值发生了变异,即在DNA序列集S中的第3条序列的模体实例的起始位点发生了变化,变异前模体起始位点为第5个位置,变异后模体起始位点为第4个位置,相应的植入模体实例从ATCCGT变成了CATCCG.Page6本文算法采用单点交叉.首先将初始群体中的个体随机配对.对于每对个体(a1,…,at)和(b1,…,bt),随机选择交叉点,执行交叉操作,生成的两个新个体(a1,…,ac,bc+1,…,bt)和(b1,…,bc,图6交叉算子选择算子在当前群体中随机选择M次,每次选择两个个体组成竞赛小组(tournament),比较组内两个个体的适应度,将适应度高的个体遗传到下一代群体当中.除此之外为了保证适应度最高的个体不出现退化且不会使算法迅速收敛到局部最优,GOBMD算法保存当前群体中适应度最高的个体,使它不参与交叉运算与变异运算,最后用它替换本代群体经过交叉、变异操作后所产生的适应度最低的个体.4实验结果与分析4.1参数设置在序列集合中,t表示DNA序列个数,序列长度用n表示,在模拟数据中t和n对所有模体识别问题都相同;在真实生物数据中,t和n的值与具体数据有关.l表示模体或模体实例的长度,d表示不匹配碱基数.除此之外,GOBMD在使用投影策略生成初始解空间时,还需要确定3个重要参数:投影规模k、投影次数m和桶的阈值θ.4.1.1投影规模投影规模k必须大小合适才能够保证算法正常运行.如果k过大,会导致l-mer的投影过于分散,投影到每个桶中的l-mer数量非常少,不容易构造出良好的候选模体,不利于迭代算法进一步求精;反之如果k取值过小,会造成投影效果过于集中,即很多l-mer都被投影到同一个桶中,使得桶中含有很多噪声(无用信息),同样不利于算法查找正确的模体.ac+1,…,at),如图6所示.在图6中,交叉前的一对个体是(4,3,5,9,2)和(3,2,4,1,6),随机选择的交叉点是元组的第3个位置,单点交叉操作后,产生两个新个体(4,3,5,1,6)和(3,2,4,9,2).假设将t(n-l+1)个来自背景序列的l-mer随机投影到总共4k个桶中,设E为平均每个桶含有的l-mer的个数,则得我们希望每个桶中来自于背景序列的l-mer个数越少越好,因为背景序列是随机生成的,不含植入模体的信息,局部搜索算法如果针对随机生成的数据展开计算,不仅增加计算上的负担,而且影响算法进一步求精的准确性,干扰正常的局部搜索.所以代表背景序列l-mer平均到每个桶中的个数E越小越好,通常要求E<1,这里取E0.90,则上式可以写成由上式解出k,可得本文中k取值为log4t(n-l+1)()0.90.4.1.2投影次数接下来确定算法的投影次数m.由于投影是随机且均匀地在1~l个位置中选择k个投影位置.而模体在l个碱基位置中的d个位置发生变异得到模体实例,那么模体实例被投影到存放植入模体的桶的概率为p(l,d,k)为存放植入模体的桶是指桶内存放的l-mer大多数是模体实例,并且有足够的数量来启动一个针对Page7该桶的局部搜索过程.通常认为这样的桶经过求精步骤最终得到植入模体的可能性很大.设Bt,p(x)表示在t次独立的伯努利实验中,至多有x次成功的概率,每次实验成功的概率为p.则在算法执行的每一次循环(投影)中,有不超过θ个模体实例投影到存放植入模体桶中的概率是Bt,p(l,d,k)(θ).算法总共执行m次循环(投影),则在一次循环中,至少有θ个模体实例投影到植入模体的桶中的概率为q,执行的每次投影中至多有θ个模体实例投影到存放植入模体桶中的概率是B,令q0.95,则为了保证植入模体桶中有足够多的模体实例,令q0.95,保证以高概率启动一个局部搜索过程,则上式可写为解出上式中的m,可得本文中m取值为log(1-q)4.1.3桶的阈值算法需要选择3个关键的参数,即投影规模k、投影次数m以及桶的阈值θ.选择合适的参数,可以减少对无意义的数据进行处理的时间,同时可以避免随机生成的背景数据对模体发现算法的干扰,从而提高局部搜索算法的正确率.因为要将t(n-l+1)个l-mer散列到4k(一种实现方式,所选取的散列表大小)个桶中,如果4k>t(n-l+1),桶中所含l-mer的平均数将会小于1.对于2.1节描述的模拟数据的挑战性植入模体问题,以及关于它的难度的分类[25],可以选择足够大的k,来满足这个低噪声的条件,且不违反约束条件k<l-d.因为它们所含的模体实例总数不超过20,因而,我们不能期望在合理的投影次数中,有太多的实例散列到同一个桶中.因此,桶的阈值大小设置为3~4.实验中θ取值4.4.2在模拟数据上的实验结果与分析按照文献[16]提供的数据生成方法来构造模拟数据集.该集合包含20个序列,每条序列600个碱基.序列中的背景序列随机生成,然后,在每条序列中随机选择一个植入模体的起始位点,把有d个变异位点的植入模体实例l-mer植入到背景碱基序列中.每次运行的投影位置数k=7,桶的阈值θ=4,交叉概率pc=0.3,变异概率pm=0.001,投影次数m是根据公式求得的.针对每种模体识别问题,运行程序20次,取20次的平均值作为算法在模拟数据上的最终识别结果.用性能系数|K∩P|/|K∪P|作为度量对算法识别的正确率进行评估[9],其中K表示在t个植入模体实例中的t×l个残基位置集合,P表示算法预测的t个模体实例所对应的残基位置集合.表1中列出的结果是Gibbs、WINNOWER、SP-STAR、PROJECTION和GOBMD算法求解植入(l,d)-模体识别问题时,20次运行结果的平均性能系数,其中第2~5列结果来自文献[16],m为投影次数.表1识别信号较弱模体的平均性能系数比较(l,d)GibbsWINNOWERSP-STARPROJECTIONGOBMDm(10,2)0.200.780.560.820.9472(11,2)0.680.900.840.910.98616(14,4)0.020.020.200.770.932647(15,4)0.190.920.730.930.98172(16,5)0.020.030.040.700.7251292(17,5)0.280.030.690.930.976378(18,6)0.030.030.030.740.8142217(19,6)0.050.030.400.960.997711从表1中可以看出,WINNOWER和SP-STAR算法[9]成功解决了(15,4)-模体识别问题,但对于信号强度较(15,4)弱一些的模式,如(14,4)-,(16,5)-和(18,6)-模体识别问题却无能为力.PROJEC-TION[16]和GOBMD可以解决信号较弱的植入模体识别问题.虽然PROJECTION和GOBMD均能求解诸如(9,2),(11,3),(13,4),(15,5)和(17,6)这样的信号极弱的模体识别问题,但实验结果表明,GOBMD的性能更好一些,如表2所示.表2识别信号极弱模体的平均性能系数比较(11,3)(13,4)(15,5)(17,6)图7用Boxplots①显示了上述模体识别算法在模拟数据识别上的性能系数分布,其中纵坐标表示①LaneD.BoxPlots,ConnexionsWebsite.http://cnx.Page8性能系数.图7中的加号(+)表示算法的性能系数的平均值,组成方格的上面一条横线是75%的性能分布线,下面的一条横线是25%的性能分布线,在25%分布线和75%分布线之间的那条线是50%的性能分布线.例如,在GOBMD算法的方格图中,25%的分布线对应的性能值是0.814,算法识别的问题中有25%的性能系数小于等于0.814.除了基本的方格以外,图中给每个方格上下还标识了附加线,以表明性能系数数据分布的额外信息,加水平表3真实生物序列信息preproinsulin(11429)metallothionein(13627)YeastECB(2631)图8显示了GOBMD算法预测的preproinsulin、DHFR、metallothionein、c-fos和YeastECB的模体序列logo图以及已公布的模体序列logo图.线是为了使垂直线更明显.从图7可以看出,比之Gibbs、WINNOWER、SP-STAR、PROJECTION这些算法,GOBMD的平均性能系数较大,识别效果较好,尤其是对于(11,2),(15,4),(17,5),(19,6)这样的问题,它们的性能系数接近为1.对于(10,2),(11,2)这样的模体识别问题,GOBMD算法也有优势.但是,在背景序列中有一些模体实例,它们比信号微小模体更保守,GOBMD可能把它们作为更高优先级的识别结果,这样就会出现在背景序列中识别信号微小模体时,无法准确地找到该模体,导致识别率极低的情况.4.3在真实数据上的实验结果与分析我们使用GOBMD算法来查找几个真核基因上游的已知转录调控元件以测试其有效性.其中同源序列取自以下4种类型基因的上游区域的各种生物体[28].这4种类型的基因是preproinsulin、DHFR、metallothionein和c-fos.已知它们包含了特定转录因子的结合位点.我们还测试了取自酵母S.cerevisiae的一组启动子区域,已知它们包含一个共享细胞周期依赖性启动子.这些序列的信息如表3所示.算法中使用的参数设置如下:交叉概率为1,变异概率为0.0001,终止代数设为30代,群体大小设为500.AOTUSTRIVIRGATUSCAVIAPORCELLUSMELANOGASTER表4给出了GOBMD所找到的同源序列、已公开的结果[28]以及识别的正确率.Page9图8序列logo图表4真实生物数据识别结果preproinsulinCAGCCTCAGCCCCCDHFRmetallothioneinCTCTGCACRCCGCCCc-fosYeastECB5结论本文提出了一种最优化遗传算法,它能够有效地解决植入(l,d)-模体识别问题.基于随机投影策略,为最优化遗传算法生成初始解空间,使最优化遗传算法有个好的起点,接下来利用贝叶斯打分函数作为适应度函数,引导遗传算法做一系列进化迭代,最终识别出来的最优个体Aopt作为最优化遗传算法识别出的最优植入模体.从随机投影中获得的结果为遗传算法提供了一个好的起点.这种随机投影策略也能够很好地优化其它启发式算法,例如模拟退火算法、Gibbs采样算法.虽然GOBMD在很多种情况下效果很好,但是在真实生物数据中,背景核苷分布完全不同于独立随机分布模式.如果样本中的核苷分布是偏移的,模体识别将变得非常困难,也就是说,在真实数据中,一些核苷比其它核苷更频繁出现.算法GOBMD通过适度的移动,改变最优模体的偏移现象.PublishedMotifCAGCCTCAGCCCCCATTTCGCGCCACTCTGCACRCCGCCCTTTCCCNNTNAGGAAA(16,5)0.8875GOBMD可以扩展到未知模体宽度,也可以在大的生物数据集上测试GOBMD,而且在处理各种模体模式时,GOBMD可以变得更加灵活.另外,可以设计新的散列函数式的投影部分变得更加有效,也可以对投影部分和遗传算法的进化部分实现并行,提高算法的运行速度.
