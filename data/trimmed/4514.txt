Page1多重二次背包问题的量子进化求解算法郑建国1)1)(湖北汽车工业学院汽车动力传动与电子控制湖北省重点实验室湖北十堰442002)2)(东华大学智能系统研究中心上海200051)摘要多重二次背包问题是二次背包与多重背包两种NP(Non-DeterministicPolynomial,非确定多项式)难问题融合后的一种新问题,由于其决策变量间具有高耦合性,已有的启发式算法求解效率和精度不够理想.针对这一问题提出一种量子进化求解算法,这种算法的量子观测操作能将部分约束处理与观测一步完成,解码效率高且不易陷入局部极值.算法中的量子更新采用自适应调节整体更新方式,相比传统查表方式更简洁和高效.算法还设计了一种局部和全局修补算子以保证解的可行性.另外,设计的交换算子能增强算法在约束边界的搜索性能.标准算例测试实验的结果表明文中提出的求解算法比传统算法的精度和效率更高.关键词多重二次背包问题;量子进化计算;约束优化;组合优化1引言多重二次背包(QuadraticMultipleKnapsackProblem,QMKP)由Hiley等人[1]在2006年提出,在金融、库存管理、生产计划调度、机场车站布局、密码设计、通讯基站优化、集成电路设计等方面得到了广泛应用,在最近几年也得到了学者的广泛关注[2],QMKP是二次背包问题(QuadraticKnapsackProblem,QKP)和多重背包(MultipleKnapsackProblem,MKP)两个经典难问题融合后的一个新问题.由于MKP和QKP同属NP难题,这种融合并不是问题简单的扩充,而是多约束问题的一种交叉渗透,一定程度上改变了问题的本质,增加了问题难度,使得求解算法发生了较大变化,加之问题决策变量间高耦合性,所以其求解极具挑战性.QMKP不仅在理论和应用两方面都具有重要研究价值[2],而且也是一个较新的研究课题,直至最近几年才引起国内外学者的广泛关注.从已有的文献看,求解QMKP主要分精确算法和启发式算法两类.精确算法比较有代表性的是2010年Quadri等人[3]提出的分支定界精确算法、2011年Wang等人[4]提出的具有线性表示的分支定界法.精确算法只能求解小规模QMKP,难以满足实际需求,所以实际中大多会寻找一种启发式算法求解.如Hiley等人[1]在2006年提出了贪婪启发式爬山算法求解.Sara等人[5]2007年提出了一种拥有改进变异算子的遗传算法,这种变异算子不但能提高解质量而且能有效避免变异后不可行解的产生.Singh等人[6]提出了一种稳态遗传算法(SSGGA),算法思想反复选择两个父代交叉产生子代去替代种群中较差个体,其不同之处是种群每次迭代并不完全被替换,始终保持拥有较优个体,算法能更快找到更好解.2010年Sipahioglu等人[7]提出了一种基于可行解的次梯度遗传算法(MSGGA),次梯度方法在处理约束时不必考虑惩罚参数,处理相对简单.另外2010年Sundar[8]提出了利用人工蜂群算法(ABC)求解QMKP的方法.从已有文献看,出现的启发式算法多采用遗传算法,这些遗传算法中虽融入了不同算子用于改进性能,但由于遗传算法进化过程中不可避免会产生构造块破坏和早熟问题.并且遗传算法局部搜索能力不强,交叉操作会破坏个体的约束条件,导致种群中优秀可行解信息丢失,使得其处理QMKP效果并不理想.而人工蜂群算法虽性能比遗传算法有提高,但由于编码特点使得其更适合处理连续优化问题,处理组合优化问题不具备优势.量子进化算法(Quantum-inspiredEvolutionaryAlgorithm,QEA)由Han等人[9]2002年提出,它将量子比特引入个体编码,其编码并不直接代表问题解,而是解的概率分布.QEA能有效克服遗传算法的构造块破坏问题,在解决遗传算法求解不理想的问题,尤其是那些非线性、多变量耦合的高维复杂问题时已展现出优异的性能,已成功应用于0-1背包、流水线调度、车辆路径、旅行商等问题求解[10].目前,国内外少有利用QEA求解QMKP的相关研究.鉴于QEA在求解多变量耦合组合优化问题方面特有优势,本文针对QMKP提出了一种量子进化算法求解方法,这种算法在编码设计、量子观测、约束处理、量子更新等方面与传统QEA相比都进行了全新的设计,通过国际上通用的测试用例实验证明该算法比其他已出现的相关算法性能更加优秀,算法的搜索精度和效率更高.2QMKP的数学模型为了更好地描述QMKP问题,下面定义QMKP相关数学符号含义[1]:J={j|j=1,…,n}:物品项集合;K={k|k=1,…,m}:背包集合;xjk=pij:当物品i与j被放入同一背包的协作价值;pj:当物品j放入任何背包的价值;Ck:背包k的容量;wj:物品j的重量;εjk=QMKP可以看作给定n个物品集合J、m个背包,在每个背包容量Ck约束下,使得总利润f(X)最大化,即maxf(X)=∑Page30wjCk<∑j∈nX=[xjk]n×m,xjk∈{0,1},j∈{1,2,…,n},k∈{1,2,…,m}ε=[εjk]n×m,εjk∈{0,1},j∈{1,2,…,n},k∈{1,2,…,m}P=pi[]jn×n,pij0;pij=pji;ifi=j,pij=0约束式(2)保证了放入每个背包的物品不超过其容量Ck;约束式(3)保证了每项物品j最多放入一个背包中;式(4)为没有单个重量大于背包容量的物品,且背包容量小于物品总重量.在QMKP中,如果当m=1时就成为QKP问题;当i≠j,pij=0且m=1时,QMKP就成为经典的0-1背包问题(KnapsackProblem,KP).虽然QKP和KP的决策变量数都为n,但QKP比KP困难得多,其目标函数值不但受每一项自身的影响,而且还受协作项的影响,QKP不存在多项式的近似算法.然而,QMKP比QKP还复杂许多,它的决策变量数为n×m.所以对于高维QMKP,精确算法几乎难以求解.3求解QMKP量子进化算法描述3.1量子比特量子比特是量子最基本信息单元,它是一个二维Hilbert态空间的量子体系,其态空间有两个基态,记为|1〉和|0〉.记号|〉称为Dirac记号,量子比特可以是量子基态|1〉和|0〉线性组合,量子叠加态表示为[9]|φ〉=α|0〉+β|1〉,其中α和β是复数,分别表示状态|0〉和|1〉概率幅,对量子比特测量时从|1〉和|0〉的叠加态坍缩到与测量结果相应的特定状态,且α和β的关系满足如下归一化条件:|α|2+|β|2=1.3.2编码设计QMKP涉及n×m个决策变量,可采用0/1矩阵[狓jk]n×m表示候选分配方案,这种编码虽简单,但决策变量间受式(3)的约束限制,须对X的每一位进行约束处理,处理代价太大.由问题定义知,对每一物品项j的分配方案仅在{0,1,2,…,m}集合中取值.所以采用式(8)为问题的分配方案.其原理如图1,假设物品项n=15,背包数m=3,那么每一物品项取值为该物品放入的背包,将未放入的物品看成放入一特殊背包0,这种分配方案决策变量为X=(x1,x2,…,xn),xj∈{0,1,…,m}(8)这种分配方案的好处是每一物品项都能满足式(3)的约束限制,无需额外再进行约束处理.基于式(8)的分配方案,本文针对传统QEA和新设计的量子编码方案进行了比较,下面分别描述.3.2.1传统QEA编码方案传统QEA的量子编码为式(9)所示.其原理(图2)是对每一项物品用log2m个量子比特观测得到0/1字符串,再将其映射为{0,1,…,m}集合中的整数,进而获得分配方案X=(x1,x2,…,xn).图中假设背包m=3,每一物品项包含量子比特为2.3.2.2针对QMKP的量子编码方案新设计的量子编码方案为式(10)所示:其原理如图3,每一项物品用m+1个量子比特编码,量子比特观测的结果直接为{0,1,…,m}集合中的数.图中每个量子包含m+1比特,分别代表背包0-m,这里的量子观测与普通观测不同.以上两种方案中,传统QEA的编码方案总编码量为n×log2m,而新的编码方案为n×(m+1),所以编码效率传统QEA更好,但其存在几个缺陷:(1)量子观测存在Hamming悬崖问题,算法局Page4部搜索能力不强;(2)量子观测值可能超出最大背包数m,使得观测值与背包取值区间不一致,需额外的转换代价;(3)背包取值为整数,使得量子更新较复杂.虽然新的编码方案长度比传统QEA略大,但其具有以下优点:(1)量子观测方式简单,能直接将量子比特观测为QMKP的分配方案,避免了取值区间转换代价;(2)能处理任意背包大小的QMKP问题,且每个背包被观测到的概率均等;(3)避免了量子观测过程中的Hamming悬崖问题,算法局部搜索能力更强;(4)量子进化过程始终保持概率运算,量子更新更加简洁.根据以上分析,针对QMKP新的编码方案更合理,在算法中假设在第t代,其种群表示为其中:Z为种群大小;t为进化代数;qtZ个体由式(10)的量子构成[9].qt3.3量子观测由于算法的编码方案与传统QEA有较大差别,需对量子观测进行重新定义.下面先对背包选中概率进行定义.定义1.任一物品项j,被选中放入背包k的概率为pj_select(k):根据pj_select(k)定义知,|αk|2越大其对应的背包k被选中概率越高.量子观测过程,首先计算每一量子比特的累积概率.然后产生一随机数,判断该随机数落在累积概率的区间,该区间对应的量子比特下标就为观测值[11].这种观测方式,能将量子比图4局部修补算子原理特映射到集合{0,1,…,m},其过程如算法1.算法1.量子观测算法.1.Observation(q)2.计算pj_select(k)3.cp_αjk=cumsum(pj_select(k))%计算累积概率4.FORj=1:n5.FORk=0:m6.IF(rand0,[]1<cp_αjk)THEN7.xj=k,BREAK;8.ENDIF9.ENDFOR10.ENDFOR11.RETURN(X)3.4修补算子量子观测得到的分配方案可能并不满足约束条件,本文采用直接修补算子对约束进行处理[12].根据QMKP特点本文设计了两种修补算子:局部修补算子和全局修补算子,下面先对一些符号进行定义.定义2.集合drk(X)=(drk1,drk2,…,drkn)为分配方案X对应背包k的相对价值密度,其值为式(13)与传统的价值密度不同之处是它不但考虑每项物品的价值而且考虑QMKP中出现的所有协作项价值,避免了未出现在背包中的物品协作价值也被统计的问题[13],能更真实的反映每一物品对于该背包的真实价值密度信息.3.4.1局部修补算子局部修补,是单独对每个背包进行处理,包括卸载变异和装载变异2个阶段,在这过程中式(13)的排序将作为变异准则.其原理如图4.修补前对价值密度各项进行升序排序.在卸载变异中,首先,将禁止放入背包k的物品卸载,即将背包中xj=k且εjk=0的项变异为xj=0.然后,选择背包k中价值密度最低的项变异,并判断变异后的方案是否满足约束条件(2),如果不满足依次寻找次低价值密度的物品项卸载,直到满足约束条件.完Page5成卸载变异后进入装载变异阶段,在未装入物品中寻找εjk=1且装入背包k后能满足约束条件的物品进行变异.局部修补算子伪代码描述如算法2.算法2.局部修补算子.1.Local_Repair(X,k)2.计算drkj(X)3.IX=sort[drkj(x)]4.FORj=1:n5.IF(xj=kandεjk=0)THEN%禁止放入背包k6.xj←0;7.ENDIF8.ENDFOR9.(IF∑10.FORj=IX(1):IX(n)%相对价值密度升序变异11.IF(xj=k)THEN12.xj←0;13.14.ENDIF15.ENDIF16.ENDFOR17.ELSE18.FORj=IX(n):IX(1)%相对价值密度降序变异19.IF(xj=0ANDεjk=1)THEN20.xj←k;21.图5全局修补算子原理3.5交换算子交换算子是为增强算法局部搜索能力而设计,其原理如图6所示.随机选择两个背包中物品交换,图中执行了2种类型交换:一是背包0和背包k中物品交换;二是包a和s物品交换.交换时需注意物品都应满足ε条件限制,两类交换执行比例用pc表示.如果交换后满足约束且适应度值提高,交换成功.交换算子伪代码描述如算法4.算法4.交换算子.1.Exchange()X2.IF(rand0,[]1<pcandxj≠xi,xj≠0,xi≠0and22.xn-j←0,BREAK;23.ENDIF24.ENDIF25.ENDFOR26.ENDIF27.RETURN(X)3.4.2全局修补算子局部修补后,各个背包都能满足约束条件(2),但修补过程中未放入背包的物品(背包0)不断变化,且有些物品受εjk限制,所以对所有背包局部修补后还应对背包0中的物品逐一检查是否有可行的分配方案,使未分配的物品数尽量最小.其原理如图5所示,图中通过检查背包0中的二个物品可分别放入背包k,s.全局修补算子伪代码描述如算法3.算法3.全局修补算子.1.Global_Repair()X2.FORtheitemsj∈{xj=0}3.FORk=1m4.IF(εjk=1)THEN5.xj←k;6.7.8.9.ENDIF10.ENDIF11.ENDFOR12.ENDFOR13.RETURN(X)3.xjxi;%交换值4.ENDIF5.FORtheitemsi∈{xi=0}6.FORtheitemsj∈{xj=k}7.IF(εi(x8.xjxi;9.ENDIF10.ENDFOR11.ENDFOR12.RETURN(X)Page6图6交换算子原理3.6量子更新本算法量子更新将以m+1个量子比特串为整体进行更新,将观测的xj值与最优分配方案作为依据.在这里,量子更新利用量子门作用于量子角上,使相位发生改变从而改变α,β概率幅,最终影响量子比特串观测到0-m的概率分布.量子旋转门犝门定义为犝=[cosΔθj0-sinΔθj0sinΔθj0cosΔθj更新操作描述为αt+1αt+1j0j1[t+1j0βt+1j1β[cosΔθjm-sinΔθjmsinΔθjmcosΔθj其中(Δθj0,Δθj1,…,Δθjk,…,Δθjm)为旋转角,取值为式(16),其中b为个体的历史最优解,bj为其j分量,f(X)为个体的适应度值,xj为该量子个体的观测j分量.(Δθj0,…,Δθjs,…,Δθjk,…,Δθjm)=(-ξ×|j0,…,-ξ×|js,…,ξ×|jk,…,-ξ×|jm),iff(X)<f(b)&&bj=xj=k(-ξ×|j0,…,-ψ×|js,…,ψ×|jk,…,-ξ×|jm),iff(X)<f(b)&&bj=k&&烄烅(0|j0,…,0|js,…,ξ×|jk,…,0|jm),(-ξ×|j0,…,ξ×|js,…,-ψ×|jk,…,-ξ×|jm),iff(X)>f(b)&&bj=k&&烆=k(fmax-f(X))2(fmax-favg)度,favg为当前群体平均适应度,ξ在区间[0.001π,-0.005π]取值,ψ在区间[0.005π,-0.01π]取值,k为背包数.小,当个体比平均适应度差,将加大其旋转幅度,反之将减小其旋转幅度,而且背包数量越多旋转角幅度越大.3.7算法流程算法5.求解QMKP的量子进化算法.1.t=0,InitializeQ(0),(α0,β2.MakeP(0)byObservation(Q(0)),P(0)={X03.Local_RepairP(0()),Global_RepairP(0());4.EvaluateP(0),getf(P(0));5.StorethebestsolutionsamongP(0)intoB(0);6.WHILE(nottermination-condition)DO7.t=t+1;8.MakeP(t)byObservation(Q(t-1));9.Local_Repair(P(t)),Global_RepairP(t());10.EvaluateP(t),getf(P(t));11.IF(rand[0,1]<pc)THEN12.ExchangeP(t());13.EvaluateExchangeP(t());14.IF(ExchangeP(t())betterthanP(t))THEN15.UpdataP(t);16.ENDIF17.ENDIF18.UpdateQ(t)usingU(t);19.StorethebestsolutionsamongB(t-1)andP(t)20.StorethebestsolutionbamongB(t);21.IF(migration-condition)THEN22.Globallyorlocallymigrate;23.ENDIF24.ENDWHILE3.8时间复杂度分析求解QMKP算法的计算复杂度主要体现在两方面:一是适应度函数评价代价;二是种群约束处理和进化操作代价.由QMKP定义可知,第1种计算代价的时间复杂度为O(Max_gen×Z×n2×m).在Page7第2种计算代价中,算法5中修补算子将对每个背包的候选解价值密度排序,假设应用折半法排序,则修补算子时间复杂度为O(Z×nlogn),在步12执行交换算子时,考虑最坏情况,即每个背包物品数量相同,则交换算子复杂度为O(n2/m).因此算法约束处理和进化最坏情况复杂度为O(Max_gen×Z×n×max(pc×n/m,logn)).Max_gen代表最大迭代次数,pc为交换率,max(pc×n/m,logn)为取两个值中最大.由于目前求解QMKP算法都采用直接修补算子方式对约束进行处理,所以本文算法与其他算法第2种计算代价相当.另外,由以上分析知:适应度函数评价为求解QMKP算法的主要计算代价,所以本文算法与其他求解算法一样,时间消耗是等量级的.即整个算法的计算代价主要体现在适应度函数评价,算法种群数将对计算代价影响较大.4实验测试为评价本文算法性能,我们采用30个国际上通用的大规模二次背包测试用例①进行测试.这些测试用例的pij非零比例为75%,问题维数分别为100和200,背包数m分别取3、5、10这3种情况进行测试.4.1参数设置为与其他算法相比,QEA算法种群取Z=20,最大迭代次数Max_gen=1000,算法的量子更新参数ξ=0.005π、ψ=0.01π,算法的交换率pc=0.7.每个测试用例重复测试测30次.设εjk=1,每个背包的容量取值相等,且为测试用例维数(n)背包数(m)表1100维几种算法获得的最优解统计值SS-GA3166969786691723276976968941480643356375769935696941336972169373232699776969817710032714690566850831369146686393406816466585693446920371694626904123669504692732231003368668547679393616876367557832676436625768776685181996863567960407688116862816510034666696466900343769907691018616862665018696966967740699866968821770028697851881003566869480685783416941068856306NANA695206926214669679691362476967969274212100514014888848138286486634767874947449459024867548414125492224893719649222489901941005242848686480283174899048175398477664703248916483762494931348908203493284891412810053411473964697024447512466235034800846587481264781515648472478753804847248022328100544004946848864254498454919429546921460634972449297150501995001819750246500881521005540047982472983114792547230554NANA487464814826748710484101334872048581991001001012002913628665262266032568168828767277232917928762136298752942920829892296171511001022143036730031187286632781539129824293443064030357120309393069813430939307019610010320528838282972382617625038562279602728228857285611522946528984247293312897322110010420030624303461992970128592333307122913531039305812383166331219176316633125015410010520029375289562062713025937650NANA296412924014730219297362133027729887188实验平台为Matlab7.6,DellVostro电脑,PentiumDual-CoreCPUE54002.70GHz,2GB内存,MicrosoftWindowsXP操作系统.4.2与当前具有竞争力的算法比较分析目前求解QMKP具有代表性和竞争力的算法主要有:Hiley等人[1]提出的爬山算法(HJ-SHC)和具有爬山算子的遗传算法(HJ-GGA)、Singh等人[6]提出的分组遗传算法(SB-SSGGA)、Sara等人[5]提出的标准遗传算法(SS-GA)、Sundar等人[8]提出的人工蜂群算法(ABC).将本文算法和这些算法进行比较.它们分别对100维和200维测试用例独立运行30次,测试结果表中最优表示30次测试找到最好解,平均为30次最优解的平均值,标准差为30次结果的标准差值.为比较本文算法与其他算法的求解质量,我们根据文献[14]提供的方法,进行了近似两样本T检验,其显著性水平a=0.05,在结果表中列出t0和自由度f,若T检验显著,则表示两种算法的均值存在显著性差异,从而将均值较优的算法表示为“+”,均值较差的算法表示为“-”,若T检验不显著,则表示两种算法的均值不存在显著性差异,两算法都表示为“+”[15].4.2.1100维测试分析100维测试结果如表1,在表1中粗体表明最好的结果,NA表示不存在(下同).其30次的收敛曲线由图7表示.结合图7和表1不难看出:100维QMKP测试中100_5(m=5)和100_3(m=10)的QEA最优解比SB-SSGGA和ABC略低,100_5(m=①http://cedric.cnam.fr/~soutif/QKP/QKP.htmlPage83)、100_1,3(m=5)、100_2,4(m=10)这3个解与ABC相当,剩下10个问题在最优解、均值、标准差都优于其他所有算法.从收敛图看出,相同问题时背包数量越大QEA算法收敛速度越慢.比如,在100维m=3问题中,迭代到700代左右已经接近最优解,而m=10时接近900代时才趋于收敛.图7也可以看出100维的测试问题在1000次迭代,基本上都能找到比较理想的最优解.图7100维测试问题收敛曲线表2100维测试几种算法T检验比较T-testn=100,m=3n=100,m=5n=100,m=104.2.2200维测试分析200维的测试结果如表3,其30次的收敛曲线由图8表示.从表3不难看出:200维测试中QEA求解的平均值仅有200_3(m=3)比SB-SSGGA略低,其他14个测试问题的最优解、均值、标准差都优于其他所有算法.从收敛图看,虽然问题维数增加到200,但QEA算法在1000次迭代中基本上都能找到比其他算法更好的最优解.通过T检验可知(表4),本文算法与ABC算法比较,除200_2,4,5(m=5)和200_1,4,5(m=10)求解没有显著优势外,剩下9个问题求解具有显著优势;而QEA与SB-SSGGA比较,200_1,3(m=10)相当;200_3(m=3)求解,SB-SSGGA比QEA具有显著优势;而剩下的12个问题,QEA具有显著优表2为QEA100维测试结果的平均值与其他几种算法的T检验结果,从表中不难看出,本文算法与ABC算法比较,除100_2,3,4(m=10)和100_1,2(m=5)求解没有显著优势外,剩下10个问题求解具有显著优势;而QEA与SB-SSGGA比较只有100_1,5(m=3)相当,其他问题具有显著优势;比较HJ-GGA和HJ-SHC算法,在15个问题求解QEA具有显著优势.t0fQEAHJ-GGA13.1125+12.075+12.1121+15.8128+16.0130+17.976+22.198+23.2118+53.1124+67.4127+56.9122+61.0109+53.7130++———+——————————势;从T检验结果看,QEA比HJ-GGA和HJ-SHC算法在15个问题求解具有显著优势.综合表1~表4看,QEA求解的最好解中仅2个解略比已有最好解低,有5个解与已有最好解相当,有23个解比其他算法更好.QEA求解的平均值仅有2个分别比ABC和SB-SSGGA略低,其他都好于其他算法,且QEA算法的标准偏差更小.QEA求解QMKP的性能与其他几种算法存在显著性差异.另外,我们还发现求解200维问题比100维问题时QEA算法优势更明显,这主要由于200维的求解难度远大于100维,其他算法求解效果不够理想,而QEA的优势更加突出.这也说明QEA在求解QMKP这种高维多变量耦合的组合优化问题方面更具有优势.Page9测试用例维数(n)背包数(m)表3200维几种算法获得的最优解统计值SS-GA200311311269447267765809268919265523182026110625430126935126850638126973626711810712703652693285002003214142553402536289172529772493003409NANA2557592548164382561952539178962566772556684642003313422686822673318632677312646892860NANA26939326906121026889026707911252695782688163552003415652452292438818462431922378375179NANA24575124434336724620524461810222464242453914632003513362772212759808332777622742543109NANA2778422770484592794902766051444279542278226504200517861823741812035961795251774381331173905170447183318182197485184448183047736184529184020483200528481721191705059471680211639173014NANA172158170861748173575171739736173968171843722200538051843621829795951814121785162361NANA184727183975403186107185060469186432185227452200549391638321625847451601461562463435NANA164066163083525165273164042778166024164098745200558011897561885976641873331854711179NANA190069189183334192764190474102119282719050195220010139311023810902850710200298962137410600810094011052810975530411100010962571411114710984464120010242410273410159560592359874003301NANA1033631022224301035401026035231040251028804552001034021117701104425371038481005282362NANA112273111658274112509111388509113534111768448200104469954539454453285801814812077NANA9583995019338968599568254696929957334932001054001142601128285861050781028571742NANA114585113607442115125113910591115189114076575表4200维测试几种算法T检验比较T-testn=200,m=3n=200,m=5n=200,m=10图8200维测试问题收敛曲线5算法优势与特征分析由于不同作者的算法,其算法机制及仿真环境都不尽相同,一般来说,使用相同的评价次数来比较不同算法的性能是相对比较公平和简便的方法.由前面分析可知,算法最大开销主要为适应度函数评--+-------+-+--价,所以算法的种群数量越小,其计算代价越低.分别对HJ-SHC、HJ-GGA、SB-SSGGA、SS-GA算法和本文算法的函数评价次数进行统计分析,见图9.由图9看出,由于QEA种群数仅取20,而其他算法取值为100或200,QEA求解代价明显较低.分析算法可以知道,之所以QEA种群数偏小,是因为一个量子个体qi可代表所有可能候选解Xk线性Page10叠加|ψqj相对偏低,且也更适合求解决策变量高耦合的组合优化问题.为清晰地展示这种特征,下面以求解100_1(m=3)一次典型运行为例进行说明.图10记录了算法的寻优过程,其中图10(e)为整个量子种群Q的进化情况,X,Y,Z坐标分别表示量子个体、进化代图10100_1(m=3)测试问题一次典型运行6结论本文针对多重二次背包这样一个NP难新问题数、函数适应度值.其他图为种群中的一个量子个体q2的相关进化情况.图10(a)为量子个体q2的变化,图10(f)为q2对应的量子角(部分)变化,图10(b)、(c)分别记录了q2量子的观测解及修补后的分配方案X,另外图10(d)为X对应的函数值f(X),图10(g)~(i)分别为背包1~3中的物品重量.可以看出,在600代前q2量子观测并修补产生大量可行解(反映在图10(c)中,600代前颜色不断变化).这些可行解函数适应度在不断提高(图10(d)),并向最优解靠近.100_1测试问题的解:F=69714,C=669.通过图10可以看出,仅一个q2量子就可以表示函数值处于[0,69714]之间的所有可行解空间.所以,在这种进化模式中,理论上仅一个量子个体就可以寻找到QMKP的最优解.由于这种特点,算法在求解QMKP时表现出种群规模较小、全局寻优能力和并行搜索能力强的特征.提出一种量子进化求解算法,算法具有以下优点:采用量子编码,进化过程始终保持概率运算,能有效处理QMKP高维多变量耦合问题,算法能避免类似遗传算法构造块破坏问题,具有种群规模小、多样性保Page11持好、全局寻优能力和并行搜索能力强等特点;与传统QEA相比,设计的编码和量子观测方式能够保留量子编码优势的同时,还能将QMKP的部分约束处理与观测一步完成,解码效率高,同时还避免了量子观测的Hamming悬崖问题,算法局部搜索能力更强;设计的约束处理算子和交换算子能有效处理QMKP的约束限制;与传统QEA相比,量子采用整体更新方式,更新更加简洁和高效,具有自适应调节能力.由于本文提出的算法具有以上特点,在对30个国际上大规模QMKP的算列测试中,该算法与其他已经出现求解QMKP的启发式算法比较,求解精度和效率更高,算法具有较好鲁棒性.多重二次背包问题在许多领域都有应用,国外也有专门针对QMKP问题的研究团队,这些足以看出对其研究的重要性.量子算法在QMKP问题上的成功应用,一定程度上丰富了QMKP求解方法,为这方面的研究提供了一种新的思路,促进了利用量子算法求解QMKP的研究进一步开展.
