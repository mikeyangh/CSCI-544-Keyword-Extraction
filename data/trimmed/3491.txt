Page1PCPF:一种面向多媒体数据库中高维向量匹配的并行索引结构陈慧中1),2)陈永光3)景宁1)陈荦1)1)(国防科学技术大学电子科学与工程学院长沙410073)2)(西南电子电信技术研究所上海分所上海200434)3)(军械工程学院石家庄050003)摘要提高特征向量的匹配效率是将高维局部特征运用于多媒体数据检索的关键.面向多核处理器架构,提出一种新的PCPF索引以及PCPF并行构建与并行查询匹配算法.PCPF并行构建算法通过量化特征向量构建近似向量空间上的高维索引结构,并进行空间划分并行构建多个子索引分支;PCPF并行查询匹配算法利用优先队列在邻近子分支上并行过滤得到近似近邻候选集,精确计算候选实际特征向量得到最终近邻.实验及分析表明,与经典的BBF算法相比较,PCPF通过降低了磁盘I/O和浮点运算次数以及并行优化,显著提升了查询匹配效率,总体匹配精度也有所提高.关键词特征向量匹配;多媒体检索;BBF;高维kNN查询1引言多媒体数据库由于存储对象(如图片、音频、视频等)内容丰富,信息量大,通过传统的元数据检索方式获取对象不能完全满足需求.基于内容的检索技术能根据视觉等内容特性将与用户感兴趣的多媒体对象从大容量的数据库中检索出来,以实现更为高效而广泛的应用.近来,随着基于内容的多媒体检索技术的不断发展,局部特征由于其稳定性高、独特性好、信息量丰富等优点已经成为多媒体对象特征描述的研究热点[1].然而,在实际检索过程中,由于局部特征数量大,描述向量维数高,使得在大规模多媒体数据库中进行向量匹配计算量大,效率低下.因此,如何高效地匹配检索样例与多媒体数据库对象间的大量高维特征向量成为提高检索效率的关键所在.建立高维索引是解决问题的有效途径[2],相关的研究结果包括:va-file[3]向量近似的思想,是使用二进制串近似实际向量,通过过滤与精确查找两个步骤使高维情况下的查询效率仍然优于顺序查找.va+-file[4]是通过将数据集转换到KLT域并实施均匀的量化划分,提高了va-file的过滤效率.iDis-tance[5]是将高维数据空间进行划分,并为每个划分建立一个参考点,使用B+-树结构组织参考点,在此基础上实现kNN近邻查询.LSH[6]通过一组Hash函数将邻近的高维点集映射到Hash表的同一个桶中,以此得到对近邻的快速查询.LSB-tree[7]使用B-tree取代Hash结构,从而以较小的代价得到了相似的查询效率优化.基于聚类分解的B+-tree[8]采用类B+-tree的索引结构,通过聚类分解,对数据进行更细致的划分来减少查询的数据访问.MS-tree[9]通过一种最大间隙空间映射策略,设计了索引的构建与范围查询处理算法.MRSVQH[10]根据随机选择的若干子向量的L2范数对特征向量进行量化和散列,搜索时仅考虑与查询向量有相同Hash值的特征向量集合,缩减了搜索范围.上述研究大多是针对通用k-NN查询做出优化,其中一些对于高维向量的查询匹配效率并不理想,还有一些存在索引结构理想化复杂化等问题,因而在多媒体数据库高维特征向量的实际匹配中应用较少.Lowe[2]为其著名的SIFT局部特征推荐了一种Best-Bin-First(BBF)近似查询匹配算法[11],BBF算法基于k-D树索引,查找最近邻时,首先遍历到查询点所在的桶,遍历过程中将每一个节点通过计算比较到查询点的距离压入一个优先队列堆栈中.然后从该桶包含的点开始向上回溯,计算比较当前近邻,当搜索到叶节点时,下一搜索节点通过优先队列顶部出栈获得,以继续搜索,直至达到最大搜索次数时终止.BBF算法是针对高维特征向量的匹配问题设计,采用优先队列和限制查询回溯次数等方法提高了查询效率,成为目前使用最为广泛的高维特征向量匹配方法.此外,当前多核处理器得到了广泛的应用,在单机多核的架构下,由于单个线程在某一时刻仅能被一个处理器核执行,传统的单线程串行算法不能充分有效地利用多核处理器的计算资源.由此,本文从多媒体数据检索实际应用需求出发,以提高高维向量查询匹配效率为目的,针对BBF算法遍历及回溯阶段磁盘I/O较大的缺陷,基于单机多核架构下的多线程并行模式,提出一种新的并行压缩优先过滤索引(ParallelCompressedPriorityFilter,PCPF).本文的主要贡献包括:(1)在BBF算法的基础上,引入向量近似的思想,考虑多核处理器条件下的并行优化,提出一种新颖的高维向量匹配并行索引结构PCPF,给出了索引构建与查询匹配算法.(2)对提出的PCPF并行构建与查询匹配算法进行了详细的算法时间复杂度分析.(3)在Benchmark图片库和实际多媒体数据库基础上,对PCPF索引进行了大量的测试实验,结果表明:PCPF算法在多媒体数据库高维向量查询匹配效率上较BBF算法有大幅提高,同时取得了较好的匹配效果.2问题描述基于内容检索多媒体数据库时,首先通过对检索样例提取多个局部特征,产生高维特征描述向量集合.然后将样例的特征向量与存储于数据库中单个多媒体对象的特征向量集合逐一匹配,计算得到匹配度,匹配度越高则相关度越高.这里,特征向量的匹配与匹配度的定义如下.定义1(特征向量的匹配).令狇为检索样例S的一个特征向量,犞为数据库中一个多媒体对象G的特征向量集合.狅1,狅2分别为狇在犞中的最近邻与次近邻.δ为匹配门限,0<δ1.若则称狇在犞中与狅1成功匹配;反之,狇无匹配结果.其中,匹配门限δ对于不同的实际数据集可通过实验取得,一般情况下,在文献[2]中推荐取0.6,在文献[12]中推荐取0.7.定义2(特征向量的匹配度).令犙为检索样Page3例S的特征向量集合,犞为数据库中一个多媒体对象G的特征向量集合.定义匹配度:match(S,G)=‖{狇}‖根据上述定义,检索样例与数据库中一个多媒体对象的匹配度由两者特征向量的匹配个数计算得到,特征点匹配的过程实际上就是一个特征向量空间中最近邻与次近邻的查询过程.因此,高维向量空间中的2-NN查询是实现快速匹配的实际关键问题,定义如下.定义3(2-NN查询).令狇=(q1,q2,…,qD)为一个待匹配高维向量,犞={狏}={(v1,v2,…,vD)}为检索库中一个多媒体对象的特征向量集合.求取狅1={o11,o12,…,o1D},狅2={o21,o22,…,o2D},使得(1)狏=(v1,v2,…,vD)∈犞且狏≠狅1图1PCPF总体框图示意对特征向量狇进行查询匹配时,首先对狇进行KL变换并量化压缩;量化后的近似查询向量运用PCPF查询匹配算法通过索引文件过滤得到候选的近似特征向量集合;然后在此候选集中进行精确计算与排序,得到最近邻与次近邻,以此计算是否匹配成功(步骤如图1中浅色箭头所示).3.1数据压缩预处理在构建索引及查询之前,为了消除数据各维间的相关性、得到更为平均的量化划分,从而提高查询效率.依据文献[4]中的方法对数据集进行压缩预处理:KL变换,位分配及量化.KL变换将数据集转换到KLT域,以此消除各维之间的互相关,使各维的数据间相互正交.位分配算法根据数据的分布情况为各维分配量化位数,令第i维上的数据方差为σi,总共的可分配位数为b,分配给第i维的位(bit)数为bi,则有b=∑bi.位分配主要步骤如下:1.令k=0.对于第i维,令si=σi,bi=0.(2)狏=(v1,v2,…,vD)∈犞且狏≠狅1,狅2这里,使用常用的欧式距离(EuclideanMetric)作为特征向量间的距离度量,实际计算时,为了节省计算开销,有时不进行开方操作.3并行压缩优先过滤索引PCPFPCPF是一种面向多媒体数据库中高维向量的快速匹配设计的静态索引,其主体流程包括索引的构建以及查询匹配两大部分.构建PCPF索引时,首先对原始数据集进行KL变换、量化压缩等数据压缩预处理步骤,然后根据PCPF索引结构对预处理后的近似向量集合构建高维向量近邻PCPF索引,同时保留KL变换后的数据集作为实际向量集合(步骤如图1中深色箭头所示).2.求j=max-1si,则3.k←k+1.若k>b,则终止;反之,重复步2.图2给出了一个二维实际数据集的KL变换和量化位数分配示例.量化根据位分配算法得到的可分配位数划分各维,在向量空间形成多个胞腔(cell),以二进制串唯一地表示单个胞腔,并作为胞腔内原始特征向量的近似表示,图3给出了一组量化后的二维向量示例.量化可以通过均匀地将原始向量分配给不同的ps个线程并行完成.Page43.2PCPF索引结构PCPF索引结构使用一种类k-D树森林的结构来组织量化压缩后的近似特征向量.PCPF结构不具有一般树形结构唯一的根节点,它的第一层是一个链表结构,由KL变换后的第一维按数据均匀划分而成.每一个链表的元素可以看作一棵子树的“根节点”,称为“首层节点”,每个首层节点下采用k-D树结构形成一棵子树分支.所有节点均包含一个指针序列,序列内元素指向相同近似向量对应的一个或多个原始特征向量在磁盘文件中的位置.图5索引结构示意3.3PCPF构建算法基于PCPF的索引结构,提出一种可并行的PCPF构建算法,共分为3个步骤:压缩预处理、数据子集划分和并行索引构建.先对预处理后的数据集进行一定的划分,在此基础上再并行地对划分后的数据集进行索引的构建.数据子集划分时,对于预处理后k维近似向量空间中的数据集犃,‖犃‖=N,将第一维均匀划分为s个区间,形成大小分别为N1,N2,…,Ns的s个子集:犃1,犃2,…,犃s.这里,由于经过KL变换,预处理后的近似向量空间在第一维上包含了最大的能量,方差为最大(见图2(b)示意),同时近似向量点具有相对均匀的分布,因此本文选择第一维作为划分的依据.划分的区间个数s代表了可并行的程度,作为并行执行时划分线程的数目,一般与处理器核数相匹配.并行索引构建时,对于每个子集,并行构建一个类k-D树结构:在方差最大的第i维上进行分割,分割点为该维数据的中间数m,则两侧各有相同数量的点,生成一个节点以存储i与m.小于m的点划分PCPF的节点可以分为三类:首层节点top_node、中间节点mid_node和叶结点leaf_node,节点的定义和主要包含元素如图4所示.top_nodesplitbrotherim犪狏LChildRChildplstmid_nodeim犪狏LChildRChildplstDistleaf_node犪狏plstDist其中,split为首层节点的分割点,brother为指向下一个首层节点的指针,i为子树当前分割的维数,m为子树当前分割点,犪狏为当前节点对应的近似向量,LChild为左子树指针,RChild为右子树指针,plst为指向实际向量的指针序列,Dist记录了查询遍历时节点至查询点的距离.图5给出了二维的图3数据PCPF索引结构示意.为左子树,否则划分为右子树,在两棵子树上递归进行上述划分步骤,直至子树仅包含一个点.子集上的第一个分割点作为该子树的根节点,即首层节点.无子树的点作为叶结点,其它作为中间节点.在每个子集犃j上构建完成一棵深度为log2Nj的二叉平衡树后,将首层节点以链表形式按子集划分区间的顺序连接起来,从而完成PCPF索引构建.PCPF构建算法的详细步骤描述如下,其中,步1预处理原始数据集;步2~4划分数据子集;步5~9构建索引.算法1.PCPF_Construct.Input:犞:SetofRealVectors,s:NumberofSubsets;Output:rootLst:ListofTop-LevelNodes;1.犃←Preprocess(犞);2.letdimensionrangeDR←FirstDR(犃);3.splitj←(DR×j)/s,j=1,2,…,s,splitj∈{split};4.犃1,犃2,…,犃s←Divide(犃,{split})5.foreach犃jdo6.rootj←BuildTree(犃j);7.rootj.split←splitj;8.rootLst.Insert(rootj);Page59.endfor;10.returnrootLst;FunctionBuildTree(setofvectors犃)1.i←Max-1(Variance(d)),d=1,2,…,D;2.Node.犪狏←Median_i(犃);3.Node.m←Node.犪狏i;4.Node.i←i;5.犃犔←,犃犚←;6.foreach犪=(a1,a2,…,aD)∈犃do7.ifai<Node.mthen犃犔←犃犔∪犪;8.else犃犚←犃犚∪犪;endif;9.endfor;10.Node.LChild←BuildTree(犃犔);11.Node.RChild←BuildTree(犃犚);12.Node.plst←RealAddrs(Node.犪狏);13.returnNode;3.4PCPF查询匹配算法进一步提出并行压缩优先过滤(PCPF)查询匹配算法.根据索引结构,查询匹配通过查询向量集在各子树上并行查询完成.对于一个查询向量,其匹配过程分为3个阶段:预处理、量化过滤与精确查找阶段.预处理根据构建索引时的参数进行KL变换与量化近似操作,得到量化的近似查询向量,并根据划分的犃1,犃2,…,犃s子集将查询向量分配到距第一维分量最近的分割点相邻的二棵查询子树犃j,犃j+1上;在量化过滤阶段,采用基于BBF算法思想的优先队列递归分别在犃j,犃j+1上并行查找获得量化查询向量的近似近邻候选集,候选集大小设定为C,C2,最大搜索次数分别为Tj和Tj+1,满足Tj×Nj+1=Tj+1×Nj且Tj+Tj+1=T.在精确查找阶段,读取候选集对应的实际向量并分别计算到查询向量的精确距离,排序得到距离最小的最近邻与次近邻,根据式(1)计算是否匹配.对所有查询点匹配完毕之后,根据式(2)计算匹配度.PCPF查询匹配的并行分为两个层面:第1层面是单个向量查询匹配时,在两棵相邻子树上并行查找近似候选集;第2层面是对于查询样例的多个特征向量,同时在s棵子树上执行第一层面的操作.PCPF查询算法使用曼哈顿距离定义近似向量空间上的距离关系:令犪狇=(aq1,aq2,…,aqD)为查询向量狇的近似向量,犪=(a1,a2,…,aD)为一个索引数据集的近似向量,则距离:PCPF查询匹配算法的详细步骤描述如下,其中,步1~9预处理查询向量集;步11~25量化过滤候选近邻;步26~32精确查找匹配.算法2.PCPF_Match.Input:犙:SetofQueryVectors,rootLst:Top-LevelNodesOutput:match:MatchedRatio;1.犃犙←Preprocess(犙);2.letmatchednumbermn←0;3.letsearchtreesLst←;4.foreach犪狇=(aq1,aq2,…,aqD)∈犃犙do5.foreachrootj∈rootLstdo6.ifIsMin(|aq1-rootj.split|)then7.sLst.Insert(rootj,rootj+1);8.endif;9.endfor;10.letsetofcandidates犆犃犖犇←;11.foreachrootj∈sLstdo12.letcurrentnodeNode←rootj;13.letpriorityqueue犘犙←;14.whileNodeisnotleaf_nodedo15.犘犙.Push(Node);16.if犪狇[Node.i]<Node.犪狏[Node.i]then17.Node←Node.Lchild;18.else19.Node←Node.Rchild;20.endif;21.endwhile;22.letCthnearestdistanceDistc←;23.letcurrentsearchtimet←0;24.CPF_Search(Node);25.endfor;26.foreachpt∈犆犃犖犇[c].plst,c=1…Cdo27.min1←min‖(pt)-狇‖;28.min2←second_min‖(pt)-狇‖;29.endfor;30.ifmin1/min2<δthen31.mn←mn+1;32.endif;33.endfor;34.match←mn/‖犙‖;35.returnmatch;FunctionCPF_Search(currentnodeNode)1.whiletTjdo2.ifDIST(Node.犪狏,犪狇)Distcthen3.犆犃犖犇.Insert(Node);4.if犆犃犖犇.sizeCthen5.Distc←DIST(犆犃犖犇[C-1].犪狏,犪狇);6.犆犃犖犇.Delete(犆犃犖犇[C]);7.endif;8.endif;9.t←t+1;10.ifNodeisleaf_nodethen11.Node←犘犙.Pop();Page612.CPF_Query(Node);13.endif;14.endwhile;4算法复杂度分析本节对提出的PCPF构建算法与查询匹配算法的时间复杂度进行理论分析.这里,定义一个D维向量在一个维度上的基本运算为一次基本运算,则一个D维向量上的相应运算的运算量为D.4.1构建算法时间复杂度在构建PCPF索引前,首先需进行预处理操作,其中KL变换复杂度为O(DN3);量化位数分配的复杂度为O(D2N);量化复杂度为O(DN),量化操作可以完全均匀地划分给ps个线程执行,因此其理论复杂度可由其中一个线程上的复杂度代替,为O(DN/ps).故总的量化预处理复杂度为O(DN3)+O(D2N)+O(DN/ps).构建PCPF索引时,划分数据子集的复杂度为O(N).然后在每个数据子集上建立索引分支,每个字分支根据k-D树的构建复杂度为O(log2(DNj)).并行子索引构建复杂度其实为最大子集合上的构建复杂度,即O(log2(DMax(Nj))),当子集完全划分时,取得最佳值,为O(log2(D(N/s))),最差情况下,数据划分极度不均匀,可视作所有向量集中于一个子集的极端情况,等同于s=1时,为O(log2(DN)).则构建PCPF索引复杂度为O(N)+O(log2(DMax(Nj))),最优划分情况下为O(N)+O(log2(D(N/s))),最差划分情况下为O(N)+O(log2(DN)).总体的构建时间为数据预处理和索引构建两部分之和,依据上面的分析结果消减低次项及系数,为O(DN3)+O(D2N).4.2查询匹配算法时间复杂度查询匹配单个向量时,首先进行预处理,此时预处理参数已确定,不需重新计算,因此单个D维向量的KL变换计算复杂度为O(D),量化复杂度为O(D),因此,总体预处理复杂度为O(D).查询匹配分别在相邻的两个子树分支上进行,对于每棵子树而言,遍历阶段复杂度为O(log(DNj)),回溯阶段复杂度为O(DTj).并行查询匹配复杂度为最深的一棵子树上的查询匹配复杂度,当子集完全均匀划分时,子树分支深度一致,取得最佳值,为O(log(D(N/s)))+O(D(T/2)),最差情况下,数据划分极度不均匀,可视作仅构建了一棵索引子树,即s=1,此时复杂度为O(log(DN))+O(DT).总体的单个向量查询匹配时间为预处理和索引构建两部分之和,依据上面的分析结果消减低次项及系数,为O(log(DN))+O(DT).对M个向量进行查询匹配时,可分配到不同子树并行执行,最佳情况下,子集完全均匀划分且M个查询向量也完全均匀分布,此时复杂度为O(log(D(M/s)(N/s)))+O(D(MT/s)),最差情况下,等同于s=1,为O(log(DMN))+O(DMT).消除低次项和系数后,M个向量并行查询匹配的时间复杂度为O(log(DMN))+O(DMT)).5实验及结果分析为了验证PCPF索引性能,本文基于多媒体数据库进行了并行效率实验、索引构建效率实验、查询匹配效率实验和查询匹配效果实验.实验中,主要比较了PCPF与经典的BBF算法,同时为了更好地分析实验结果,本文也对单线程串行执行的PCPF算法进行了实验,作为参考对比.本文采用2个图像数据库作为实验数据来源,一个包含从benchmark图片库COREL中精选的10个主题共1000张图像;另一个为实际工作中使用的月球空间数据影像库,共包含3227张月球表面图像.图像高维特征向量采用SURF[12]特征,图像平均特征点数目为10933,90%的图像特征点数目分布在5000~15000之间.实验硬件环境:IntelCorei32.93GHz4核CPU,2.0GBRAM,采用MicrosoftWindowsXPProfessional操作系统.实验软件开发环境:VC2008+OpenCV2.0.实验相关参数如下:特征向量默认维数为128,总量化位数为210,PCPF与BBF算法搜索次数T按文献[2]推荐设置为200,默认候选集大小C为2,默认匹配门限δ为0.7,预处理线程数目ps=s.5.1并行效率实验PCPF索引面向单机多核架构采用多线程框架完成并行索引构建与查询匹配.并行效率实验旨在测试线程数目对于效率的影响,这里,使用并行加速比和并行效率衡量,定义如下:图6给出了实验结果,(a)为构建PCPF索引时不同线程并行执行下的加速比与效率,是选自COREL和月球库的10组平均大小为10000的向量集合的构建平均值,横坐标指示了线程数目s=2,3,…,10.(b)为查询匹配的结果,查询向量集合大小为500~1000.Page7从图6可以看出,在实验采用的四核处理器环境下,在不同线程下,构建加速比为1.57~2.89,并行效率为0.45~0.79;查询匹配的加速比为1.12~1.71,并行效率为0.28~0.73.并行加速比在s=4,即与处理器核数相匹配时取得最大值,线程数小于处理器核数时递增,超过时递减.并行效率随着线程数目增加而递减.根据实验结果可以得出,并行线程数目s等于处理器核数core时,可以得到最优的性能提升;s<core时,由于没有充分利用每个处理器的计算资源,加速比较小,但此时一方面由于实际利用核数(即式(7)中的分母)也较少,另一方面存在空闲处理器可以处理操作系统等的计算请求,故并行效率较高;s>core时随着线程数目的增加,维护多个线程本身的开销增大,并行加速比与效率均有所下降.此外,构建算法的性能提升优于查询匹配算法,这是由于对向量集合构建索引前经过了一系列预处理,使得数据集分布较为均匀,因此各线程负载较为均衡;而查询向量合集本身并非均匀分布,而其预处理采用的KL变换基以及量化维数等参数均是根据数据库中多媒体对象的向量集合的数据分布计算到,并不一定能很好地划分查询数据集而使各线程负载十分均衡,因此,数据分布的差异使并行性能提升也有所不同.由此,PCPF通过多处理器架构下的多线程并行执行得到了明显的性能优化,并行线程数目等于处理器核数时为最优,因此,在后续实验中,取s=4.5.2索引构建效率实验索引构建效率实验旨在评估PCPF对特征向量数据集构建索引的时间消耗.事实上,索引的构建在查询匹配之前完成并与多媒体对象一起存储于数据库中,其时间消耗并不影响检索效率.但由于PCPF为静态索引,即当一个多媒体对象特征向量集合改变时,将重新建立索引,故我们也对此进行评估.图7给出了实验结果,图(a)比较了从5k~15k的不同规模的向量集合上构建PCPF索引和BBF索引时的时间消耗,每个构建时间均为10个向量集合的构建平均值,来源为月球图像库;图(b)比较了不同维数(D=20,50,80,120)的向量集合上构建PCPF索引和BBF索引时的时间消耗,同样为10个向量集合的构建平均,来源为COREL图片库.从图中可以看出,采用串行(s=1)的方法构建PCPF索引耗时大于BBF索引构建,其时间增长随数据集增大和维数增加而增加.并行PCPF构建与BBF构建耗时十分接近.串行PCPF耗时较多的主要原因是为了提升查询性能进行了KL变换、位分配及量化等压缩预处理步骤,这些操作的计算复杂度较高(见4.1节分析)从而引起额外耗时,并且计算量随数据集增大和维数增加均有增加,这与BBF索引直接构建于原始数据集上有所不同.而并行PCPF由于采用多线程方式执行,大大降低了构建时间,虽然有些情况下略高于BBF,但总体来说,差别不大.由此,PCPF索引通过并行构建降低了索引结构优化引起的构建时间增加,其构建时间在不同数据集大小和维数下与BBF相接近.5.3查询匹配效率实验查询匹配效率实验比较了PCPF算法对匹配查询向量集合的磁盘I/O与时间消耗.图8和图9分别给出了查询匹配的磁盘I/O总字节数和平均单个向量查询匹配耗时比较试验结果,取10个大小为500~1000的查询向量集合匹配时的平均值.图(a)比较了在5k~15k的不同规模的向量集合上匹配查询向量集合的I/O与时间,实验影像库为月球图像库,图(b)为不同维数向量集下的结果,采用COREL图片库.从图8中可以看出,随着索引向量集规模N的增加和维数D的增大,BBF算法的I/O急剧增加,而Page8PCPF算法增量平缓.N=10000时,串行执行的PCPF算法比BBF算法I/O减少50%以上;N=15000时,可减少60%以上;D=50时串行PCPF磁盘访问量为BBF的60%不到,D=120时仅为30%不到.这是由于N和D增加时,通过BBF算法匹配的实际向量访问增长较快,而PCPF算法仅需多读取少量的近似向量,需访问的实际向量大小仍由候选集大小决定,数目很少,因而增量不大.并行PCPF的匹配总I/O字节数与串行执行的相差不多,总体略偏少一些,其原因在于,一个向量在查询匹配时并行算法只遍历两棵邻近搜索子树,而非全部近似向量.图9显示,N=10000时,串行的PCPF查询匹配耗时仅不到BBF的50%;N=15000时,为40%左右;对于不同维数,D=50时耗时为40%左右,D=120时为35%左右.这是由于PCPF查询匹配时通过访问近似向量减少了磁盘I/O,且使用二进制运算求取近邻矢量减少了浮点运算次数,因此即使串行执行也明显优于BBF算法.PCPF经过多线程并行执行,进一步提高了查询匹配效率,平均单个向量的匹配耗时与BBF相比仅为其15%~50%.由此,PCPF查询匹配时磁盘I/O少于BBF算法,查询匹配耗时大幅减少,效率明显优于BBF算法.5.4查询匹配效果实验查询匹配效果实验用于检验PCPF算法效率的提高对匹配效果的影响.实验使用10幅包含光度变化、噪声污染、角度变换和尺度变换的样例图片与实验库中图像相匹配取平均值,采用查全率(Recall)-查错率(1-Precision)曲线,衡量不同算法的匹配效果,理想状态的查全率-查错率曲线应收缩于(0,1)点,即查错率为0,查全率为1.其中,查全率(Recall)和查错率(1-Precision)定义如下,在实验中通过调整δ的设置计算取得.从图10中可以看到,通过串行执行的PCPF、PCPF和BBF算法得到的匹配效果十分接近,其中最好的是串行执行的PCPF查询匹配算法,其较好的效果一方面是由于其与BBF均为近似查找算法;另一方面有可能是由于通过近似向量来过滤匹配的方法一定程度上降低了第二近邻的查找准确率,因此增加了匹配成功率,从而提升了查全率,降低了查错率(参见式(1)).并行PCPF查询匹配算法由于在查询过程中没有完全遍历所有的子树以求取第一近邻,所以其匹配效果较串行情况较差,有时接近于BBF算法,但总体匹配效果仍略好于BBF.由此,PCPF算法效率的提升非但没有导致匹配精度的下降,反而能比BBF算法取得更好的匹配效果.6总结与展望本文针对多媒体数据库对象检索中的高维特征向量匹配问题,基于多核处理器架构,提出一种新的并行压缩优先过滤索引(PCPF).PCPF采用并行构建算法量化特征向量并构建多个索引子分支,并利用优先队列并行过滤多个子分支得到近似近邻候选集来提高查询匹配效率.实验证明,PCPF并行构建与查询匹配算法在多核处理器架构下取得了良好的并行效果,较经典的BBF算法在查询匹配性能上有大幅提升,同时提高了匹配效果,并且没有明显地增加构建时间.在实际多媒体检索应用中,特征向量分布具有一定的规律,合理的聚类十分重要,不但能有效提升检索效率,更能增加检索结果的准确性.PCPF索引构建时仅考虑数据集的均匀划分,而没有加入聚类的考虑.对此,后续工作将通过分析向量集合的分布特性,研究合理的聚类对于索引性能与效率的影响.致谢感谢中国科学院国家天文台提供了嫦娥二号月球遥感影像数据作为本文的实验数据来源之一(月球空间数据影像库)!Page9
