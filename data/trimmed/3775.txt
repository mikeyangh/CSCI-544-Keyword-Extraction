Page1基于环境的多形态时间需求建模方法陈小红1),2),3)刘静1)1)(华东师范大学上海市高可信计算重点实验室上海200062)2)(北京大学高可信软件技术教育部重点实验室北京100871)3)(浙江师范大学计算机软件与理论省级重中之重学科浙江金华321004)摘要时间需求作为嵌入式系统的关键要素,其重要性越来越突出.但是目前的时间需求存在着多样的环境时间描述与单一的软件时间描述融合问题.文中在基于环境的功能性需求的基础上,提出基于环境的多形态时间需求建模方法,试图在需求层次上为该问题提供解决方案.文中构建了支持这个方法的多形态时间需求模型,在环境因素的基础上增加了多形态时间描述,并提出该需求模型制导的需求建模过程,帮助需求分析员在功能性需求的基础上建模时间需求.文中还给出了从多样的环境时间描述得到软件时间需求规约的步骤,指导需求分析人员抽取时间需求规约.关键词时间需求;多形态时间;基于环境建模;嵌入式系统1引言嵌入式系统是近年来的研究热点,新近提出的物联网[1]和信息物理融合系统(Cyber-PhysicalSystems,CPS)[2]都建立在其基础之上.在嵌入式系统中,实时是关键要素之一.实时需求的研究工作主要集中在实时系统中,方法主要采用时态逻辑和时态逻辑的扩展[3-4]对时间点和时间段做定性与定量的描述与分析.现在的需求工程方法,比如面向目标的方法[5]和面向主体和意图的方法[6],也采用时态逻辑或其扩展对时间点和时间段进行描述.我们以前的工作也针对嵌入式系统,从环境建模的角度对时间点和时间段进行刻画[7].而物联网和CPS等的提出,对时间需求又提出了新的挑战.以CPS为例,CPS是一类在环境感知的基础上,深度融合了计算、通信和控制能力的可控、可信、可扩展的网络化物理设备系统[8].简单来说,CPS系统就是开放的嵌入式系统加上网络和控制功能,其面临的环境多样,包括自然环境、建筑、机器,当然也包括人类自身.这样的环境随时间连续变化,在时间描述上可能多样,比如本文案例中使用汽车曲轴转过的角度描述时间.而对CPS软件来说,其时间描述单一,因此就存在着多样的环境时间描述与单一的CPS软件时间描述之间的融合问题.多样的时间描述问题也出现在了软件工程其它领域.在同步语言[9]中,为了解决这个问题它引入了多形态时间.时间单位不仅仅限于物理时间的秒、微秒等.在同步程序中,可以出现类似“这个任务必须在10ms之内完成”的语句,也可以出现“这个车必须在50m之内停住”的语句.10ms和50m都是表示时间的截止,这就是多形态时间.法国国家信息与自动化研究所INRIA的Andre等人将多形态时间引入到系统建模中去,为实时嵌入式系统构建了规范MARTE(ModelingandAnalysisforReal-TimeEmbeddedSystem)[10],将时间定义为一组时钟,每个时钟都有自己的时间单位.在此基础上,他们还创建了时钟约束语言CCSL(ClockConstraintSpecifi-cationLanguage)[11],用于实现时间的同步.本文将多形态时间的概念引入到需求建模中来,尝试在需求层次上解决多样的环境时间描述与单一的软件时间描述的融合问题.我们以前的工作提出了基于环境建模的功能性需求建模方法[12].该工作将环境看作是一组与软件交互的实体(又称问题领域),将需求看作是预期问题领域的变化,即期望的环境变化.我们认为,问题领域是现实世界的一部分,有自己的生命.从直觉上讲,每个问题领域的时间都可以建模成(或者参考)一个时钟,该时钟可以有自己的时间单位.因此,结合我们前期的工作[12]和MARTE/CCSL[10],本文提出构建基于环境的多形态时间需求建模方法,跟其它需求工程方法相比,其主要特点有:(1)它是基于环境的建模,建立在现实世界问题领域的基础上,有着坚实的现实基础,也建立在功能性需求之上;(2)它支持多形态时间建模,适合描述多样的环境时间和单一的软件时间.为了支持基于环境的多形态时间需求建模方法,本文首先构建了基于环境的多形态时间需求模型,在环境因素的基础上增加了多形态时间描述,由此在基于环境变化描述的功能性需求的基础上描述多样的软件环境时间约束和软件时间约束,包括最基本的时间点和时间段的描述,并提出该需求模型制导下的建模过程,以指导需求分析人员使用该需求模型进行时间需求建模.最后采用该方法对汽车领域进行了应用,验证了本文方法的有效性.本文第2节给出多形态时间需求模型;第3节给出该时间需求模型制导下的时间需求建模过程;第4节采用汽车领域的具体案例来验证方法的可行性;最后,第5、6节讨论相关工作并总结全文.2多形态时间需求模型在我们以前的功能性需求模型的基础上[12],本文进一步将跟功能相关的概念与多形态时间的概念关联起来,扩展该需求模型,得到多形态时间需求的概念模型,如图1所示.图1白色矩形框中的概念及其关联来自我们以前的工作,总结了问题框架方法[13]的概念和关联,表示了基于环境软件问题的基本概念及关联:(1)软件问题(Problem)处于一组现实世界的问题领域(ProblemDomain)当中,其目的是开发一个软件机器(Machine),以满足客户的需求(Requirement),其中软件机器的环境就表示为一组问题领域的集合,需求就表示为问题领域的预期变化.(2)在软件机器和问题领域存在共享的现象(Phenomenon),这就是在机器和问题领域之间的交互(Interaction).需求通过软件机器与环境的交互实现.(3)每个交互有一个发起方,一个接收方,发起方和接收方必须一方是机器,另一方是问题领域.每个交互必须还有内容,那就是现象,现象可以分为事Page3图1多形态时钟需求概念模型件(Event)、状态(State)和值(Value).由上述描述可以看出,基于环境的功能性需求模型的核心概念是问题领域和交互,它们都有环境因素信息.围绕这些环境因素,进行与时间相关的扩展,得到图1灰色矩形框中表示的概念.这些概念大部分来自MARTE,根据需求阶段的特征,又重新进行了定义.首先考虑扩展交互.原来工作假设交互瞬间发生,不考虑持续时间.但在实际情况中,有些交互的发生需要花费一定时间.根据其持续与否,将交互分为瞬时交互(InstantInteraction)和持续交互(Dura-tionInteraction)两种.持续交互也可以用两个瞬时交互表示,一个表示持续交互的开始,一个表示持续交互的结束.每个持续交互都有持续时间,这个持续时间可以由开始瞬时交互和结束瞬时交互之间的时间差(Duration)来表示.与MARTE类似,我们也将时间(Time)看作时钟(Clock)的集合.这些时钟本质上是连续的(dense),因为在现实世界中,每种物品都有连续的生命周期.一个时钟可以是精密时钟(ChronometricClock),也可以是逻辑时钟(LogicClock),每个时钟有自己的时钟类型(ClockType)、时间单位(Unit)和一组可选性质(OptionalProperty).不同类型的时钟,时间单位选择不同.精密时钟的时间单位是常见单位,比如秒或者其它衍生的单位.大多数逻辑时钟使用一个普遍的时间单位tick,也可以使用像处理周期这样的单位,或者使用物理数量,像本文案例中使用的角度.时钟的可选性质包括分辨率(Resolution)、初始值(Offset)和最大值(MaximalValue).每个时钟都包含一组有序的时间点(Instant).时间点和时间点之间存在着各种时间点关系(InstantRelation).时间点和时间点之间的时间差距称为时间差或时间段(Duration).为了显式地表示时间点及其关系,定义了时间点图(InstantGraph).不同的时钟由于其时间点之间存在的关系,使得它们之间也存在着约束关系,这种关系我们称时钟约束关系(ClockConstraintRelation).这两组概念(图1中的白色和灰色矩形框)通过如下关系关联在一起:每个问题领域都有(或者参考)某个时钟;每个问题领域的每个交互(特指瞬时交互,若为持续交互就转换成瞬时交互)发生的时刻都是该时钟的一个时间点.表1给出了上述概念的具体含义及其层次.概念问题机器问题领域与软件系统交互的现实世界实体需求交互瞬时交互交互的发生瞬间完成持续交互交互的发生需要花费一定时间现象事件在特定时刻发生、出现的个体状态变量和值之间的关系,可以随时间改变值时钟类型时钟的种类精密时钟指向物理时间的时钟逻辑时钟关注时间点之间的顺序,而忽视时间点之间的时钟时间单位测量时间所用的基本单位时间点特定的时刻时间段时间区间时间点关系时间点之间的关系时钟约束关系时钟之间的关系时间点图显式表示时间点及时间点关系的图可选特性可能具有的能够刻画时钟的特性分辨率时钟的粒度最大值时钟时间点能达到的最大值初始值时钟的开始值Page4基于上述的概念模型,本文给出一些关键概念的形式化定义,包括时钟、时间点图、时间差、一些时钟约束关系和交互等.由于时钟的多形态特性,本文在MARTE时钟模型的五元组定义基础上,增加了可选属性来描述多形态时钟,得到时钟定义,如定义1所示.定义1.时钟(Clock).其中,I={instant1,instant2,…,instantn}是时间点instanti(1in)的集合.这些时间点都是时钟的里程碑,它们记录了在其生命周期中有意义的时刻.这些时间点有两种记录方式,一种是用交互发生的时刻来记录(@tinteraction),另一种是其时钟变量的赋值.<是定义在I上的类序关系,命名为严格先于.D={d1,d2,…,dn}是标签的集合,D中的每一λ:I→D是一个标签函数.U是时间单位符号.O是一组可选属性的集合,包括分辨率、最大值和初始值.时间点图是直观地表达时钟内或时钟之间时间点及时间点之间关系的图.该图可以形式化地定义为一个2元组,如定义2所示.个元素di(1in)表示一个有意义的交互.定义2.时间点图(InstantGraph).其中,Ins={instant1,instant2,…,instantn}是一组时间点的集合.RelsIns×Ins是Ins集合中时间点之间的二元关系集合.二元关系可以分为3种[10]:先于(Precedence,)、同时发生(Coincident,≡)和严格先于(StrictPrecedence,<),其中先于关系包含同时发生的情况,而严格先于关系不允许同时发生.这3种关系的图形表示如图2所示.时钟约束关系可以靠时间点之间的关系来定义.文献[11]给出了很多种关系,下面介绍本文用到的过滤(filterBy)关系,它描述了两个时钟时间点之间的“过滤”对应关系,即一个时钟的时间点都是依靠另一个时钟的时间点通过某种形式的过滤得到.其具体定义见定义3.定义3.过滤(filteredBy).其中A和B都是时钟,ω是一个二进制数.A的时间点由B的时间点通过ω过滤器构造出来.关于时间点与时间点之间的时间差,与MARTE类似,本文用时差算子(Durationopera-tor,-)来描述.与原定义中的时间单位秒(s)不同,本文采用多形态时间单位.其具体定义见定义4.定义4.时差算子(Durationoperator,-).a-b<tunit<=>b<a<b+tunit,其中,a和b都是时间点,“+”是延迟算子,unit为任意时间单位.交互作为一个非常重要的概念,从它出发的关联有3个,因此,我们将交互定义为一个四元组(其中一元为交互名称),其具体定义见定义5.Interaction··=〈Int,Sender,Receiver,Content〉,其中,定义5.交互(Interaction).Int是交互的名称.Sender是发起方.Receiver是接收方.Content是发送方和接收方共享的现象.3多形态时间需求建模过程遵循图1给出的多形态时间需求模型,我们定义了一个多形态时间需求建模过程,如图3所示.它包含4大步骤,即为每个问题领域进行时间建模,确定时钟的约束关系,构建时间点之间的定量关系和抽取时间需求规约.下面介绍具体步骤.Page53.1问题领域的时间建模本步骤的输入是问题图[13],包含所有的问题领域和交互,输出为带有时钟的问题图.根据时钟的定义,我们设计如下4个子步骤来完成:(1)定义使用时钟这一步首先检查是否有现成的时钟可用,若无,考虑从如下几个方面定义新的时钟:时钟类型(是精密时钟还是逻辑时钟)、时间单位和可选特性(包括分辨率、最大值、初始值)等.对于问题图中的任一问题领域,其任一连续属性都可以考虑作为一个逻辑时钟,比如本文案例中使用曲轴角度作为一个时钟,其角度的任一取值都是该时钟的一个时间点.(2)识别时钟时间点集合由时钟的定义知,上一步定义的时钟,其能识别的时间点是与这个问题领域相关的瞬时交互发生的时刻,或者该时钟对应连续属性的一个取值.需要注意的是,所有的时间点都为瞬间发生,应该对应到瞬时交互,所以要先对问题图中的持续交互作预处理,将它们转换为瞬时交互.由于一个持续交互可以分为很多个持续交互,每个持续交互又可以由开始瞬时交互和结束瞬时交互表示,因此,一个持续交互可以转换为多个瞬时交互.(3)识别时间点定性关系对于(2)中识别出的时间点集合,需要确定它们之间的关系,这些关系包括第2节中介绍的先于()、严格先于(<)和同时发生(≡).这3种关系都具有传递性,也就是说满足如下性质:点之间的关系.其中a,b为时间点,R可以为<,或者≡.据此,确定时间点之间的关系可以分为两步:①确定具有明确关系的时间点.②根据传递性采用推理机推理未明确的时间(4)画出时间点图经过上述3个步骤,得到时钟的6元组定义,将时钟的时间点和时间点之间的关系体现在图形上,就得到了其时间点图.对于问题图中的任一问题领域,重复步骤(1)~(4),可以得到该问题领域使用(或者参考)的时钟,我们在问题图中引入一个时钟符号(),其中的文字表示时钟名字.将该符号放在问题领域之上,表示该领域使用的是该时钟,由此得到带有时钟的问题图.3.2时钟约束关系确定上一步得到了多个不同时钟,这些时钟并不是以有很多种,比较常用的有:孤立存在的,它们共存在于一个系统之中,因此,它们必然存在着某种关系.根据文献[11],其时钟约束关系可以分为两种:(1)基于同时发生关系(≡)的时钟关系,它可等价关系Equal(A,B),时钟A与B是等价的.子时钟AisFinerThanB,表示B是A的一个子时钟.它又包含好多种,前一章介绍的filteredBy算子也是其中的一种.(2)基于优先关系()的时钟关系,它可以有很多种,比较常用的有:周期性BisPeriodicOnA,表示时钟B是A的弱子时钟是子时钟的变体,将子时钟时间点之的交互表述.某些时间点的周期性表示.间≡关系换为即可.在文献[11]还提出很多不同的时钟约束关系,详细内容请参阅文献[11].对于任意两个时钟,先看它们之间满足什么关系,然后采用上述关系进行描述.通过这一步,我们得到时钟约束关系集合.3.3时间点之间的定量约束除了定性关系之外,还要确定时间点之间的定量关系,也就是时间差,这个时间差的时间单位为其参考时钟的时间单位.束有3种表达方式:间点b之后t单位时间内发生.t单位时间点上发生.之后t单位时间之后发生.3.4需求规约抽取通过前面3步,我们得到时间需求描述,包括软件与其交互环境发生什么样的交互,这些交互之间存在什么样的时间约束.一般来说,需求描述了对环境现象的期望关系,而软件需求工程的目的是要得到需求规约,用来描述软件在环境中的期望行为.为了成为一条需求规约,一个需求必须遵守至少如下3条规则[14]:规约全部存在于机器和环境的接口.时间差我们采用时差算子(-)来表示,相关约(1)a-b<()tunit表示时间点a必须在时(2)a-b=tunit表示时间点a在时间点b之后(3)a-b>tunit表示时间点a必须在时间点b(1)需求提到的环境现象都要和机器共享,即(2)所有要约束的现象都要直接由机器控制.(3)所有期望对交互的约束必须用之前发生过Page6从问题图上可以看出,我们的交互在软件和环境的接口上,且由软件接收或发起,因此,条件(1)和(2)肯定可以满足.为了满足(3),还必须要知道这些交互的先后顺序及相关约束.本文需求规约里面涉及到持续交互,为了清晰起见,我们将需求规约分为两层表示:第1层是整体规约,表明在问题图中所有交互(包括持续交互和瞬时交互)的关系,第2层是对第1层中涉及到的持续交互的规约表示.整体规约采用顺序流来表示,顺序流由交互关系确定,交互关系有两种,一种是瞬时交互与瞬时交互的关系,跟时间点关系相同,第二种是瞬时交互与持续交互的关系,持续交互可以简化为开始瞬时交互,这样就将持续交互与瞬时交互关系转化为瞬时交互与瞬时交互间关系了.据此,将整体规约定义为一个二元组,其具体定义见定义6.定义6.整体规约(OverallSpec).其中,IS={int1,int2,…,intn}是所有交互的集合.<是定义在IS上的严格先于关系集.这样的整体规约也可以用一个图形来表示,圆圈表示交互,箭头表示交互发生的严格先于关系,阴影圆圈表示开始,双圈(中间的圆圈有阴影)表示结束.所有交互.整体规约可以采用如下步骤获取:(1)获取所有的上层交互,包括在问题图中的(2)对于瞬时交互,根据3.1~3.3节得到的对应时间点关系直接排序.(3)对于持续交互,在3.1~3.3节得到的关系基础上,使用它的开始瞬时交互替换该持续交互,然后根据传递性、时钟约束关系推导出该持续交互与其它瞬时交互对应时间点的关系.关于持续交互规约,有两层意思需要表达.首先要表达持续交互的整个流程,包括从开始瞬时交互到结束瞬时交互的所有交互及其关系,它不因有无软件观察而开始或结束,一直按照自己的规律运行.另一个需要表达的是软件需要观察到的从开始交互到结束交互过程.由此,用一个四元组来定义持续交互规约,其具体定义见定义7.定义7.持续交互规约(DurationInstantspec).DurationInstantspec··=〈IS,<,OI,OE〉,其中,有瞬时交互inti(1in)的集合.IS={int1,int2,…,intn}是这个持续交互的所<是定义在IS上的严格先于关系集.OI是软件所要观察的开始瞬时交互.OE是软件所要观察的结束瞬时交互.这样的持续交互规约也可以用一个图形来表示,其图示如图4所示.圆圈表示交互,箭头表示交互流,阴影圆圈表示观察开始交互,双圈(中间的圆圈有阴影)表示观察结束交互.图4的含义如下:a为一个持续交互,它由瞬时交互b开始,经c到d结束,软件关注的是开始瞬时交互b,当观察到瞬时交互c发生后,软件将不再关注交互a了.因此,c作为一个观察结束瞬时交互存在于a中.根据上面的定义知,可以分两步取得持续交互的规约:(1)确定持续交互的所有的瞬时交互及其顺序关系.(2)确定软件观察的开始瞬时交互和结束瞬时交互.一般来说,观察开始瞬时交互就是该持续交互的开始瞬时交互.4案例研究4.1汽车应用领域问题描述本文使用汽车领域中的点火系统和爆震控制系统来进行方法验证.点火系统使用4冲程发动机,它包括4个阶段:进气、压缩、燃烧膨胀和排气.这些阶段都是曲轴驱动的,可以由曲轴转动的角度来衡量.在发动机点火时,由于点燃火花塞需要一定的延迟才能在燃烧室产生火花,点火花必须在理论点火点(TIDC)之前产生.在压缩阶段,在点火确定点(IgnitionDecisionPoint,IDP)之后,点火系统要决定产生火花的最佳角度.具体的过程涉及到很多点火点,如图5所示.产生电火花的简化流程如下:根据当前空气/汽油比率和当前发动机的速度,查询点火控制曲线图(MAP)得到基本点火提前角Page7(BIAA).然后修正BIAA数据,得到修正点火提前角(CIAA).修正涉及到很多因素,比如,缸温、缸压、爆震等.本文为了简化,只考虑爆震因素.修正会带来两个结果:CIAA和爆震窗(KnockAcquisitionWindow,KAW)信息.这组行为序列是由点火确定点(IDP)触发的.图5中还有最大点火提前角(MIAA),它对应最坏的情况(最大的引擎速度和最大允许提前角).爆震指得是在发动机燃烧阶段在设计的点火角之前,由于种种原因导致燃气混合物自行点火燃烧,此时,由于燃烧所产生的巨大冲击力与活塞运动的方向相反而引起发动机震动现象.这种现象会导致发动机动力下降、油耗增加、噪音加大等,可能会对气缸造成不可逆转的损害.爆震控制系统检测和修正这种现象.它包含一个或多个爆震传感器和一个控制器,获得和计算修正.爆震信号的获得在爆震窗(KAW-KnockAcquisitionWindow)期间执行.开始点(KAW-Start)和持续时间(KAW-Duration)可能有变化,变化依赖于上一次燃烧阶段测量得到的爆震强度(KnockIntensity,KI).KI值也将用于调整点火提前角.爆震过程由压缩阶段的ITDP触发,其具体过程如下:根据上次爆震强度KI修正之后得到本次KAW,等待延迟的KAW-Start,然后执行爆震信号获取(KSA)活动(由KWB和KWE来表示其开始和结束),KSA获取填充到一个Buffer里面,然后再由Filtering读取,Filtering的最后结果就是KI.更多关于汽车点火系统和爆震控制系统的细节,请参见文献[15].4.2时间需求建模4.2.1问题图及交互预处理根据上述的汽车点火系统(IgnitionSystem,IS)的陈述,得到其问题图,如图6所示.其含义为:IS为要创建的系统;IS将要与气缸(Cylinder,CR)、爆震控制系统(KnockSystem,KS)、凸轮轴(Camshaft,CAS)、曲轴(Crankshaft,CRS)和修正(Correction,CN)这些问题领域进行交互;IS的需求就是要确定点火的最佳时机(deter-minethebestsparktiming);IS与问题领域的交互(包括需求引用和约束),如表2所示.将其中的持续交互转换为瞬时交互,如表3所示.交互名发起方接收方内容交互类型int1CRISSpeed,AFInstantint2ISCRsparkInstantint3KSISKIInstantint4CRSISangleDurationint5CASISangleDurationint6CNISKAWInstantint7CRISCycleDurationDurationInteractionint4int5int7图6中的问题领域爆震控制系统(KnockSystem,KS)指得是图7中要开发的爆震控制系统.图7是爆震控制系统的问题图,其中,KS为要创建的系统;KS将要与气缸(Cylinder,CR)、爆震传感器(KnockSensor,KE)、曲轴(Crankshaft,CRS)和修正(Correction,CN)这些问题领域进行交互;KS的需求就是要提供爆震强度(provideknockintensity).Page8图6汽车点火系统问题图图7爆震系统问题图KS与问题领域的交互(包括需求引用和约束),如表4所示,将其中的持续交互转换为瞬时交互,如表5所示.交互名发起方接收方内容交互类型int26KSCRKSAInstantint27KSCRFilteringDurationint28KSCRKIInstantint29KEKSsignalInstantint10CRSISITDCInstantint30KSCNKAWDurationint31CRKSKIInstant表5爆震控制系统持续交互转换为瞬时交互DurationInteractionInstantInteractionContent4.2.2问题领域的时间建模对于问题图中的每个问题领域,都要对其进行时间建模.接下来的步骤(1)~(3)详细建模了点火系统的问题领域,(4)中建模了爆震控制系统的问题Page9领域.在开始之前,首先为物理时间定义一个理想时钟idealClk,它是一个精密时钟,可以被任意时钟引用.(1)凸轮轴(Camshaft)凸轮轴是直接驱动摇臂和气门的推杆装置,通过它可以控制节气门,由此控制空气进入发动机.在4冲程发动机中,一个循环它转过360°,粗略来讲,从0°到90°为发动机进气阶段,从90°到180°为压缩阶段,从180°到270°为燃烧阶段,从270°到360°为排气阶段.凸轮轴的角度可以定义为一个逻辑时钟camClk,其每个角度的位置可以作为这个时钟的一个时间点.在时钟camClk中,其时间单位可以定义为°CAM,分辨率为(比如)0.5,初始值为0,最大值为360,所有的这些值的单位都是°CAM.这个时钟的时间点可以由时钟变量的取值来标识.根据上述描述知道,需要标识的时间点有0°CAM,90°CAM,180°CAM,270°CAM,360°CAM,其中0°CAM和360°CAM重叠.也可以由对应的交互发生的时间点来表示:@tint13,@tint14,@tint15,@tint16,@tint13,其中@tint13表示int13发生的时间点,@tint13表示新一轮int13发生的时间点,其它的表示类似.时钟camClk的时间点图如图8所示.(2)曲轴(Crankshaft)曲轴是引擎的主要旋转机件,装上连杆后,可将连杆的上下(往复)运动变成循环(旋转)运动,曲轴的旋转是发动机的动力源.在4冲程发动机中,一个循环它转过2圈,即720°.曲轴转动的角度可以定义为一个逻辑时钟crkClk,其每个角度的位置可以作为这个时钟的一个时间点.在时钟crkClk中,其时间单位可以定义为°CRK,分辨率为(比如)0.5,初始值为0,最大值为720,所有的这些值的单位都是°CRK.这个时钟的时间点可以由时钟变量的取值来标识.根据上述描述知道,需要标识的时间点有0°CRK,180°CRK,360°CRK,540°CRK,720°CRK,其中0°CRK和720°CRK重叠.这些时间点也可以由一些特殊的交互发生的时刻表示,这两种表示之间的对应关系如表6所示.0180360540720@int8@int9@int10@int11@int7时钟crkClk的时间点图如图9所示.(3)气缸(Cylinder)和爆震控制系统(KS)这两者的时间都可以用曲轴的角度来刻画,所以还是采用crkClk来描述它们.它们涉及的交互之间存在着一定的先后顺序关系.首先要读取当前曲轴角度(int4),读取当前空气/汽油比率和当前发动机的速度(int1),根据爆震强度(int3)进行提前角修正,得到点火时刻(int2)和爆震窗(int6).上述交互之间存在如下偏序关系:这些交互都是发生在压缩阶段的,存在如下3条关系:①读取当前空气/汽油比率和当前发动机的速度(int1)肯定要发生在进气关闭Intakecloses(int19)之后,所以有②得到点火时刻int2必然发生在压缩关闭CC(int21)之前,因此有③从理论上来讲,由于气缸的4个冲程状态,在气缸的各个状态交互之间应该存在着这样的偏序关系:@tint18<@tint19<@tint20<@tint21<@tint22<@tint23<@tint24<@tint25即气缸的进气开始IO(int18)之后是进气结束IC(int19),然后压缩开始CO(int20),CC结束(int21),然后燃烧开始CP(int22),结束CL(int23),最后排气开始EO(int24)和结束EC(int25).但是实际上,气缸的EC(int25)在IO(int18)之后发生,CO(int20)在IC(int21)之前发生,CC(int21)跟CP(int22)同时发生且发生在ITDC(int10),EO(int24)在CL(int23)之前发生,IO(int18)在EC(int25)之前发生.因此,实际上,关系(4)应该是@tint18<@tint25<@tint20<@tint19<@tint21=@tint19<@tint24<@tint23由此得到其时间点图,如图10所示.Page10(4)爆震控制系统的问题领域时间建模爆震控制系统的问题领域包括CR、KE、CRS和CN,这些问题领域的时间都可以通过曲轴的转角来衡量,所以,全部采用时钟crkClk来衡量.它们涉及的交互之间存在着一定的先后顺序关系.首先,由ITDP(int10)触发爆震过程,然后根据上次爆震强图11带有时钟的点火系统问题图图12带有时钟的爆震系统问题图度KI(int31)修正之后得到本次KAW(int30),接下来执行爆震信号获取(KSA)活动(int26),读取Filtering(int27),最后得到KI(int28).上述交互发生的时间点之间存在如下关系:根据上面建模结果,最终可以得到带有时钟的点火系统和爆震系统问题图,如图11和图12所示.Page114.2.3构建时钟约束关系(1)camClk和crkClk由于凸轮轴和曲轴是机械上联系在一起的,后者比前者快一倍.因此,时钟camClk和crkClk紧密地相互依赖,这种依赖关系可以由时钟约束filteredBy来表示.图13表示了这两个时钟之间时间点之间的关系.图13时钟camClk和crkClk之间的时钟约束时钟约束显示camClk是crkClk的一个子时钟,其中camClk的时间点和crkClk的每两个时间点之间存在同时发生关系.其具体的时钟约束为Clock.Constraint1:ClockConstraint1:对camClk和crkClk的约束camClk=crkClkfilteredByob(10)其中,ob(10)是一个周期性的二进制子代表1010…(其实也就是10的无限重复).实际上,时间点之间的关系为时间点0.5×(k-1)mod720°CRK关联在第k(k=1,2,…)个crkClk的时间点.(2)crkClk和idealClk一个发动机的最大速度为4500转/分,而一圈所花时间为360°CRK,则最大的发动机速度为(4500/60)×360=27000°CRK/s,因此有ClockConstraint2:对crkClk和idealClk的约束1°CRK37μs4.2.4构建时间点之间的定量约束(1)点火系统的约束首先,在点火系统中,气缸的状态和曲轴的位置之间存在着一定的关系,因此在气缸的交互和曲轴的交互发生的时刻点存在着定量的关系.比如,@tint25(exhaustcloses)在OTDC位置出现之后5~20°CRK,因此存在如下约束:即为@tint8+5°CRK@tint25@tint8+20°CRK(6)类似地,可以得到Constraint1:@tint18=@tint8-[10..16]//IO在OTDC前10°~16°CRK发生@tint19=@tint9+[40..60]//IC在FBDC后40°~60°CRK发生@tint24=@tint11-[45..60]//EO在SBDC前45°~60°CRK发生@tint25=@tint8+[5..20]//EC在OTDC后5°~20°CRK发生@tint23=@tint11//CL和SBDC同时发生@tint21=@tint22=@tint10//CC和CP和ITDC同时发生根据上述关系和式(5),可以推导出如下交互发生的时间顺序关系:@tint18<@tint8<@tint25<@tint20<@tint19<@tint21=@tint22=tint10<@tint24<@tint23=@tint11(7)其次,点火系统的一系列动作由IDP触发,而IDP出现在一个固定的曲轴角度,它的每次出现即为时钟crkClk的一个时间点.而最佳的点火提前角(AIAA)的位置肯定会出现在最大点火角(MIAA,对应着最坏的情况)之前.因此,点火控制行为的间隔(从readingspeedandAF(int1)到ignitingspark(int2))必须比图5中的δm(从IDP到MIAA的时间差)要小.对这个间隔约束可以描述为Constraint2:(2)爆震控制系统的约束首先考虑爆震窗.每个气缸都有对KI的存储,因此,没有额外的约束.但是,Buffer是每个气缸共享的,这就意味着每个气缸的Filtering操作必须在下一个气缸的KSA操作开始之前完成.爆震窗(KAW)在55°CRK(KAWS)之前开始,最多将会持续55°CRK(KAWD).因此,在最坏的情况下,整个操作将在110°CRK下完成.由此得到如下约束:Constraint3:对KAW的约束KAW.start55°CRKKAW.duration55°CRK即@tint3255°CRK接下来考虑Filtering操作.先考虑单缸发动机的情况.在爆震控制活动中,Buffer是一个关键的资源,它由KSA写入,由Filtering读取.在k次循环的Filtering中,必须在下一次循环k+1的IDP点出现之前给出爆震强度KI.IDP点通常是一个固定的角度(比如,在ITDC之后665°,或者正好在ITDC之前55°).假设给定爆震窗开始的最大值为KAWSmax和爆震窗的持续间隔为KAWDmax,可以推导出Page12Filtering.duration665-KAWSmax-KAWDmax.若KAWSmax=KAWDmax=55°CRK由此可以得到如下约束:Constraint4:单缸发动机的Filtering约束Filtering.duration555°CRK即@tint35-@tint34555°CRK在多气缸的情况下,对Filtering的duration的约束也就更严格.交互(ITDC,KWB…)可以由汽缸号来标识:ITDCm、KWBm、KWEm和KIDm都指汽缸m的交互,而ITDCn指得是汽缸n,它是下一个点火的汽缸.注意,KID的最后期限已经不是IDP,而是ITDCn.时间间隔不再是ITDCk和IDPk+1之间的665°CRK间隔,而是在ITDCm和ITDCn之间的720/4=180°CRK,这就给4缸发动机留下了180-110=70°CRK的过滤间隔.因此,得到如下约束5:Constraint5:4缸发动机的Filtering约束Filtering.duration70°CRK即@tint35-@tint3470°CRK因此,在最大的发动机速度下,Filtering.duration不应该超过70×37=2590μs,比单汽缸的情况要少很多.4.3软件需求规约的抽取4.3.1点火系统(IS)根据第3章中软件需求规约的获取步骤,我们首先构建其整体规约.根据问题图1和表2知,上层的交互有int1,int2,int3,int4,int5,int6,int7.由表3知,int4的开始瞬时交互为int8,int5的开始瞬时交互为int13,int7的开始瞬时交互为int18,结束瞬时交互为int25.这些交互中已经明确关系的有@tint4<@tint1<@tint3<@tint2<@tint6(由式(1)知).其它的推理过程如下:由式(2)知,@tint19<@tint1由式(5)知,@tint18<@tint19由传递性可得@tint18<@tint1由int7和int18关系可得由Constraint1知:@tint18=@tint8-[10..16]则@tint18<@tint8根据int7和int18以及int4和int8的关系,可得根据时钟约束关系ClockConstraint1知,int8应该和int13同时发生,所以根据式(1)、(8)、(9)和式(10),得到点火系统的整体需求规约如图14(a)所示,其含义为点火系统IS查询气缸状态(int7)、查询曲轴的旋转角度(int4)和凸轮轴角度(int5),当到达IDP点时,查询当前空气/汽油比率和当前发动机的速度(int1)、爆震强度KI(int3),根据点火时机点火(int2),并设置爆震窗(int6).上述需求整体规约中的int4,int5,int7都属于持续交互,分别用图14(b)、(c)、(d)中的持续交互规约表示.以int4为例,根据图14(b),可以看出其经历了从OTDC(int8)到FBDC(int9)到ITDC(int10)到SBDC(int11)到IDP(int12)的全过程,当观察到它到达IDP时,触发了其它的交互.关于int5,int7的描述详见图14(c)和(d).这些交互之间要满足Constraint1和Constraint2的约束关系.4.3.2爆震控制系统(KS)与点火系统类似,可以得到爆震控制系统的需求整体规约,如图15(a)所示,其含义为:爆震控制系统KS查询曲轴的旋转角度(int4),当到达ITDP点(int10)时,查询上次爆震强度KI(int31),等待延迟的KAW(int30),执行信号获取(KSA)活动(int26),获取爆震信号(int29),然后执行Filtering过滤(int27),得到KI(int28).对于其中涉及的持续交互int4,int27,int30,我们分别采用持续交互规约来表示,结果如图15(b)、(c)、(d)所示.需要指出的Page13是,图15(b)中的int4与图14(b)的int4经历相同,不同之处在于观察结束点不同,图15(b)中当观察到ITDP点(int10)时,软件就触发了爆震的其它活动.图15(c)、(d)则分别表示了Filtering和KAW的开始和结束.这些交互要满足Constraint3与Constraint4(单缸发动机)或者Constraint3与Constraint5(4缸发动机)的约束关系.5相关工作比较跟本文相关的工作有多形态时间、时间需求建模、问题框架方法和需求规约的抽取.多形态时间(MultiformTime)最早在反应式同步语言[9]中定义和使用.它认为事件流可以用不同的时间单位来度量.MARTE(ModelingandAnalysisofReal-TimeEmbeddedsystems)是OMG组织公布的实时嵌入系统的建模规范[10].它将多形态时间引入其时间模型.它将时间定义为一组有不同时间单位的时钟.这些时钟可以离散,也可以连续.另外,它还定义了相应的时钟约束语言CCSL(ClockConstraintSpecificationLanguage).该工作是本文工作的研究基础,本文的时间模型也是多形态时间模型,不同之处在于它专门为需求阶段量身打造,其时钟是连续模型,既能描述现实世界,也能描述基于现实世界的变化.我们将时间需求建模分为3种,基于时序逻辑的时间需求建模、基于MARTE的时间需求建模和基于时间自动机等形式化方法的时间需求建模.基于时序逻辑的时间需求建模在现代需求工程方法中出现的比较多.例如,面向目标的方法[5]与面向主体和意图的方法[6].面向目标的方法将目标看作是需求的来源,KAOS(KnowledgeAcquisitioninAuto-matedSpecification)[16]是其代表性工作.KAOS中包含很多传统的时序算子和混合附加的实时算子,由此来确定涉及实时期限的性质.它使用带类型的一阶时序逻辑建模实时特性.面向主体和意图使用参与者作为线索来识别需求,其代表性工作是i框架[17]和FormalTropos[18].FormalTropos语言用由KAOS激发的时序规约语言补充i.FormalTropos也使用带类型的一阶时序逻辑建模实时特性.上述基于时序逻辑的工作,都采用时序逻辑或其扩展对时间需求进行建模,针对时间点和时间段进行了定性与定量的描述.它假设时间领域离散,其时间模型为基于物理时间的多时钟模型,很难精确地捕捉和推理涉及时间的连续变量.多时钟模型涉及多个时钟,这些时钟可以为物理时钟,也可以为逻辑时钟,但这些时钟的时间单位相同,分辨率也相同.这些模型没有解决环境时间的多度量描述的问题.跟它们相比,除了物理时间之外,由于时间的多形态表示,本文方法还可从其它角度来定义逻辑时间,其时间单位可以不同,分辨率也可以不同,更加适用于描述多样的环境.另外,本文方法从环境出发建模时间,也更加适用于描述环境时间,跟上述其它需求工程方法相比,更适合解决多样的环境时间描述与单一软件时间描述的融合问题.基于MARTE的需求工程方法不多.2011年我们将问题框架和MARTE/CCSL结合起来,为嵌入式系统提供了一个时间描述机制[7].该工作将每个问题领域跟一个时钟关联在一起,并将该问题领域涉及的交互对应到该时钟的时间点上,由此构造了嵌入式系统的时间模型.该工作主要针对时间点和时间段进行了描述.实际上,该时间模型是离散的多时钟模型.形式化方法在时间模型上有很多工作.比如由Alur和Dill[23]提出的时间自动机(TimedAutomata),它在有限状态自动机的基础上增加了取实数值的时钟变量用以刻画连续变化的时间,可以准确地表示实时系统的各种带时间约束的行为.由周巢尘院士和Hoare等人[24]联合提出的时段演算(DurationCalculus),能够应用于对混合系统的实时需求进行刻画和精化以及用来计算关于系统需求的满足概Page14率.由牛津大学的Reed和Roscoe等人[25]提出的时间通信顺序进程(TimedCommunicatingSequentialProcess,TCSP),引入了时间因子的概念,并定义了一些带有时间因子的算子,实现了实时性的相关描述和分析.这些形式化的时间模型不大适合在需求的早期使用,且它们大部分是多时钟模型,也存在不能描述多度量方式的环境时间问题.基于环境的问题框架方法[13]是本文工作的基础.问题框架方法中涉及时间需求的工作比较少.Lavazza等人[19]使用时间事件来触发在特定时间点要做的特定系统行为.Nelson等人[20]为地理领域提出了12个地理问题框架,其中一个是跟时间相关的,称为趋势/时序框架,这个框架捕获了这样的问题:当比较不同时间的同一区域的两个地图时,什么发生了变化?Barroca等人[21]使用Timer作为问题领域的一部分,机器可以观察和重置Timer,Timer也可以被客户观察到.Timer提供了事件可以报告流逝的时间.Bianco等人[22]使用情景研究问题框架,情景可以用事件现象来表示,其时间约束是用来推理系统的性能.这些工作都基于时序逻辑及其扩展.跟上述基于问题框架的时间建模方法相比,我们的时间需求模型是一个多形态时间模型,它建模连续时间,从现实世界出发,从不同的角度看待时间和描述时间,其时间单位多样,分辨率也不同,适合建模多样的环境时间.由于我们的时间约束基于问题领域和交互,而这二者是功能性需求的主要成分,因此我们的方法植根于功能性需求之上,这使得时间需求有牢固的实现基础.需求规约的抽取工作跟本文关系最密切的是Jackson等人[14]的工作.他们是从需求中抽取需求规约的专门工作,跟本文工作相比,他们具有更全面的抽取过程,包括如何从需求中通过环境推理出软件应该具备的行为.它也涉及到一些实时需求,与他们不同的是,我们的工作里面涉及了一些持续交互,并以特定的方式表达了出来.6结束语时间需求是嵌入式系统的核心,其成功描述是实现该系统的关键,因此时间需求建模的重要性毋庸置疑.提出构建基于环境的时间需求模型,主要贡献有:本文在我们前期的功能性需求建模的基础上,(1)以基于环境的功能需求建模为基础,在交互和问题领域两大环境因素的基础上构建多形态时间需求模型,为基于环境的非功能需求建模开辟了道路.(2)支持多形态时间建模,从多种角度看待和描述环境时间,适合描述多样的环境时间和单一软件时间.本文的主要工作包括:(1)构建了一个多形态时间需求模型,提供了描述时间需求的基本概念和术语,以帮助进行时间需求的描述.(2)在多形态时间需求模型的制导下,提供了一个时间需求的建模过程,支持从功能性需求到时间需求的描述.(3)提供了从时间需求模型到需求规约的转换.通过上述工作,可以得到时间软件需求规约,这样的规约为进一步设计和开发具有强时间约束且与环境多实时交互的软件提供了依据.目前,本方法提出的时间需求规约还没有进行验证,下一步的工作就是对它们进行验证,并建立工具支持建模和自动化验证.
