Page1基于全局同步逻辑时间的访存依赖约减方法唐士斌1),2)宋风龙1)张帅1),2)范东睿1)刘志勇1),3)1)(中国科学院计算技术研究所计算机体系结构国家重点实验室北京100190)2)(中国科学院大学北京100049)3)(移动计算与新型终端北京市重点实验室北京100190)摘要并发执行的并行多线程程序执行过程中,不同的访存顺序会得到不同的执行结果.由于再次执行时,难以重现首次执行时的错误,导致并行程序的调试非常困难.确定性重放是解决该问题的一种方法,目的是通过记录并行程序执行过程中的不确定性事件,然后利用记录的事件重现出程序的原始执行.然而,已有的确定性重放方法会产生大量的记录日志,如何减小记录日志是确定性重放领域的研究热点,在实际应用中也是非常具有挑战性的问题.为了减小记录日志的开销,文中提出了一种基于逻辑时间的访存依赖约减方法,并在支持松弛存储一致性模型的处理器上提出具体的实现技术,该方法利用了访存依赖对应的逻辑时间之间的序关系进行约减.通过模拟评估所提出方法的性能和可扩展性.其中,在8核模拟平台上,通过Splash2测试程序进行评估,结果显示所提出的记录方法平均日志开销为0.11Bytes/Kilo-Instruction,与目前最好的访存依赖约减方法Timetraveler相比提高了75%;通过4核、8核和16核平台的评估结果,表明所提出约减方法具有较好的可扩展性.关键词多核;并行程序;确定性重放;访存冲突1引言目前,主流的处理器设计多采用多核或者众核结构.为了充分发挥多核与众核的计算能力,采用并行方法进行程序设计是必然的趋势.但是,并行程序中存在不确定性,这种不确定性导致多次执行同一并行程序会得到不同的结果.该问题使得调试并行程序难度高、周期长.为了解决该问题,研究人员提出了确定性记录与重放方法.该方法分成两个阶段:记录与重放.在记录阶段中,方法监控程序的行为并记录执行中的不确定性事件.在重放阶段中,利用记录的事件重现出程序被记录时的行为.并行程序执行过程中的不确定性事件主要分成两类:一类是程序外部事件引起的不确定,如中断、程序输入等;另一类是程序内部的访存顺序引起的不确定(以下简称访存依赖).与外部的不确定性相比,访存依赖的发生隐含在多线程的访存交互当中,该类不确定性发生频率高,故难以完整记录.因此,如何检测并记录访存依赖成为确定性重放领域的热点问题.研究人员进行了大量的研究,相关工作分成两类:纯软件方法与硬件辅助方法.在纯软件方法中[1-4],监控程序的访存行为是通过修改页表或者对应用程序插桩来实现.该类方法的优点是,机制的实现不需要硬件设备,在现有硬件的基础上就可以实现重放.但是,当被记录的并行程序访存交互频繁时,纯软件方法的运行时开销大,并且难以长时间在线工作[5].在由硬件辅助实现的方法中[6-16],增加了硬件设备来检测访存依赖,因此大大降低了运行时开销.但是,记录过程中生成了大量的记录日志,该日志不仅占用了片上存储空间,同时将其导出到片外会占用系统访存带宽.为此,如何减小记录的日志成为确定性重放领域的研究热点.其中,有代表性的工作有文献[6,8,10-11,13].研究人员利用访存依赖之间的传递关系[17],提出了约减访存依赖的方法[10].文献[6]基于该研究进一步采用矢量合并的方法,将多个平行的访存依赖合并成一项.这两种方法利用点到点的方式来保存依赖关系,可以最大程度地保存重放时的并行度.然而,它们的缺点是日志开销大,其原因有两点:首先,在方法中用来保存依赖关系的数据结构占用字节多,每项数据结构由4个域组成,分别为源处理器标识符、源处理器逻辑时间、目标处理器标识符、目标处理器逻辑时间;其次,这两种方法仅能约减由两个处理器参与的依赖,不能约减更多处理器参与的依赖关系.为了获取更好的约减效果,研究者提出了在动态指令片段之间建立逻辑时间的方法[11,13,18].其中,动态指令片段是指一段不与外界通信的连续指令.该类约减方法从3个角度减少日志开销:(1)减小日志项的长度,该类方法每个日志项仅由两个域组成:指令块包含的指令数、指令块对应的时钟;(2)合并多项依赖关系,在该类方法中一条日志项可以表示一段动态指令片段内的多条依赖关系;(3)实现多处理器之间的传递约减.在文献[8]中,研究人员提出了更高效的约减方法,该方法利用了处理器中物理时钟之间的优先关系.但是,上述方法的日志开销依旧太大,在线记录会影响系统的整体性能.针对无数据竞争的程序,研究者提出了一种方法,可以确定地执行并行程序[19].该方法通过确定同步操作之间顺序,保证了无数据竞争的程序的确定性.与确定性重放方法相比,确定性执行的优点是零日志开销,但是,方法需要为不确定性事件建立顺序,此过程引入巨大的运行时开销.此外,该方法不能保证存在数据竞争的程序在执行时的确定性.为了在真实的处理器中实现重放方法,越来越多的研究工作开始关注对松弛存储一致性模型的支持[6-9].这些研究工作重点讨论如何在支持TSO(TotalStoreOrder)存储一致性模型的处理器中实现确定性重放.为了避免重放时的死锁问题,文献[6,8]提出了记录读操作返回值的方法,而在文献[7]中则采用了记录动态指令片段中没有完成的写操作的数量的方法.尽管上述两种方法实现起来Page3都比较简单,但都存在日志开销过大的问题.为了降低日志开销,在文献[9]中提出了检测违反顺序一致性语义的方法.但该方法仅适用于基于“侦听”的缓存一致性协议,而不适用于基于“目录”的缓存一致性协议.针对目前的方法都存在日志开销大的问题,本文提出了一种基于全局同步逻辑时间的访存依赖约减方法.该方法利用访存操作逻辑时间之间的序关系,来约减访存依赖.具体操作为,当处理器检测到一对依赖关系,表示为A→B.当操作A的逻辑时间小时,则该依赖关系可以被约减.为了追求更好的约减效果,本文提出了懒惰同步逻辑时间的方法,该方法在不引入大量的同步日志开销的同时,在记录过程中建立了全局同步的逻辑时间,保证了几乎所有的访存依赖都能被约减.为了将本文的方法在真实的处理器中实现,本文讨论了松弛存储存储一致性模型对重放的影响以及解决方法.为了还原真实的执行过程,该方法记录了被推迟执行的访存指令.同时,本文还提出了基于乱序指令窗口来检测破坏顺序一致性语义的方法.本研究的贡献有3点:(1)提出了访存依赖约减方法.该方法利用逻辑时钟之间的优先关系,来约减访存依赖.(2)提出了懒惰的逻辑时钟同步方法.此外,针对不同的缓存一致性协议,本文提出了不同的同步策略.(3)针对支持松弛存储一致性模型的处理器,本文提出了检测破坏顺序一致性语义的方法,并记录了乱序行为来避免重放时的死锁.本文第2节主要介绍确定性记录方法中访存依赖约减与对松弛存储一致性模型支持的相关工作;第3节具体描述本文的约减方法以及该方法如何支持松弛的存储一致性模型;第4节给出具体实现与重放算法;第5节对约减方法进行实验评估;最后一部分是全文总结.2研究背景确定性重放方法,通过记录原始执行的不确定性事件,保证了并行程序在多次重放中行为与原始执行行为一致,大大提高了并行程序的调试效率.在确定性重放研究工作中,日志产生速度与如何在松弛存储一致性系统中实现一直受到广泛关注,下面分别介绍相关研究工作.2.1访存依赖的约减方法在确定性重放中,需要在日志中记录首次执行中的不确定性事件,然而过快的日志产生速度限制了该方法的实用性,原因如下:首先,程序中导致错误的根源与发生错误的现场之间,程序已经执行了很久,追踪到错误根源需要长时间记录执行状态;其次,将日志从处理器导出到稳定的存储设备中占用系统带宽资源,影响系统性能;最后,有限的存储设备无法承受无限增长的日志.为此,十年来,硬件记录方法的一个研究热点是减小记录访存依赖的日志开销.主要的方法分成两大类:第1类方法采用传递关系约减访存依赖[6,10,17,20].该方法利用偏序集合中的传递关系约减冗余的访存依赖关系,如图1所示,图中存在4条依赖关系,分为两类:Rd_A→Rd_B和Wr_B→Wr_A属于默认的程序序引起的依赖关系,而Rd_A→Wr_A与Rd_B→Wr_B属于处理器间的访存依赖.根据访存依赖关系的传递依赖原则,虚线表示的依赖关系可以通过另外3条实线表示的依赖关系推导得出,因而不需要记录该依赖关系Rd_A→Wr_A.基于传递关系的约减方法采用点到点的格式保存依赖关系.这种格式可以精确地还原依赖关系,不会引入顺序化,因此最大程度地保存了重放并行度.但是,该方法其对日志的约减效果不好,其原因有两点:(1)该方法保存依赖关系的数据结构复杂,保存的每个依赖项都由4个域组成,它们分别是源处理器的标识符、源处理器的逻辑时间、目标处理器的标识符和目标处理器的逻辑时间.如图1所示,日志项格式为CoreID(Rd_B),LogicTime(Rd_B),CoreID(Wr_B),LogicTime(Wr_B).(2)该约减方法保存的是两两处理器之间的关系,故只能适用于两两处理器之间的约减,不能扩展到更多处理器.第2类方法通过建立动态指令片段来约减访存依赖[11-14].该方法通过访存地址签名管理一段时间内不与外界通信的访存指令的地址,并且通过该签名检测这段动态指令是否与外界发生通信.如果有Page4通信发生,则该方法保存动态指令片段包含的访存指令数与Lamport时钟[18].如图2所示,当执行访存操作Wr_C时,因为依赖关系Wr_A→Rd_A的存在,签名集合中的操作Rd_C已经被删除,因此不能检测到依赖关系Rd_C→Wr_C.也就是说,虚线表示的依赖关系Rd_C→Wr_C,可以通过另外5条依赖推导得出,即Rd_C→Wr_A→Rd_A→Rd_B→Wr_B→Wr_CRd_C→Wr_C.由上述过程可以看出,该类方法可以取得更好的约减效果,主要有以下3个原因:(1)日志格式短,每个日志项仅需要保存该段动态指令的指令数与Lamport时钟;(2)一个日志项可以表示一段动态指令内部的多条点到点依赖关系;(3)基于Lamport时钟的约减,可以将传递约减应用到多个处理器之间,提高约减效率.然而,该方法约减日志开销的同时,将记录过程中并行执行的指令强制顺序化,限制了重放时的并行度.2.2在松弛存储一致性模型上实现重放的方法为了更好地实现访存依赖约减,已有的确定性重放研究工作[10-15,20]都假设目标系统采用理想的存储一致性模型,即顺序一致性模型.然而,在真实的处理器设计中考虑到性能的因素,松弛存储一致性模型被广泛地采用.因此,近期越来越多的研究工作开始关注在松弛存储一致性模型中支持确定性重放[6-9].文献[6,8]提出的方法,能够在支持TSO(TotalStoreOrder)存储一致性模型的处理器中实现确定性重放.该方法通过记录读操作的返回值来避免重放时的死锁问题.文献[7]利用指令窗口的概念,首次在TSO存储一致性模型上支持基于动态指令片段的访存依赖记录方法,该方法在动态指令窗口结束时记录未完成的写访存操作数量,来避免重放时的死锁问题.文献[9]是在文献[12]的基础上进行的扩展,该方法支持多种松弛存储一致性模型,不仅限于TSO(TotalStoreOrder)存储一致性模型.然而在文献[9]中,仅简单地指出支持多种松弛存储一致性模型,并没有对松弛存储一致性模型进行严格的定义.在文献[8]中,没有给出支持松弛存储一致性模型的具体实现.与已有工作不同,本文的方法支持维护弱写原子性的松弛存储一致性模型,对适用的模型的定义更加准确,同时详细讨论了在该类存储模型上的实现.写原子性在现代处理器中通过缓存一致性协议保证,然而为了获取更高的性能,在实现中往往实现了弱写原子性的松弛存储一致性模型,弱写原子性是指在写操作全局可见之前读操作可以提前读到本地的写操作,例如写缓存中的数据在维护缓存一致性之前,本地的读操作就可以读取.文献[21-22]指出弱写原子性在现代处理器中得到了广泛的支持,如ARM、X86、SPARC和PowerPC等.3访存依赖约减方法并行程序的不确定性事件主要分成两类,外部的不确定性与访存顺序的不确定性.其中,外部的不确定性事件在串行程序中同样存在,在并行程序出现之前就引起了研究人员的关注,目前的软件方法可以很好地解决此类不确定性.然而,并行程序中的访存顺序的不确定性,尤其当并行程序在多核处理器上执行时,此类不确定性事件隐含在内存数据交互当中,其发生的频率高且难以检测.为此,访存依赖的记录与约减受到研究人员的广泛关注[6,10-14].针对已有的记录方法日志开销大的问题,本文利用访存指令逻辑时间之间的优先关系,提出了建立全局逻辑时间约减访存依赖的方法.3.1基于逻辑时间约减访存依赖的方法如图3所示,箭头Rd_A→Wr_A表示的是基于缓存一致性协议检测到的一对访存依赖.在物理时间上一定满足Time(Rd_A)<Time(Wr_A).如果在每个时钟周期执行的访存指令数(MemoryInstructionPerCycle,MIPC)接近的处理器中,可以得出这两条指令的访存指令数(MemoryInstructionCounter,MIC)满足MIC(Rd_A)<MIC(Wr_A).本文中的逻辑时间通过访存指令数表示.Page5基于此观察,本文提出了基于逻辑时间的访存依赖约减方法.方法要求:当检测到一对访存依赖X→Y时,如果满足约减条件MIC(X)<MIC(Y),则认为该访存依赖隐含在逻辑时间之间的序关系当中.如图3所示,执行指令Rd_A的逻辑时间为30,执行指令Wr_A的逻辑时间为65,访存依赖Rd_A→Wr_A满足约减条件MIC(Rd_A)<MIC(Wr_A),因此访存依赖Rd_A→Wr_A可以被约减.3.2建立全局同步的逻辑时间的方法根据3.1节描述的访存依赖约减方法,可知处理器间的MIPC是否同步会直接影响访存依赖的约减效果.具体来说,当一对访存依赖X→Y发生时,在存储端可以观察到执行这两条访存指令的物理时间满足Time(X)<Time(Y).如果执行他们的处理器之间的访存执行速度(MIPC)接近,则该依赖一定满足约减条件MIC(X)<MIC(Y),访存依赖X→Y可以被约减.然而在真实的系统中,由于缓存命中率、分支预测准确率等因素的影响,处理器之间执行访存的速度(MIPC)往往不同.本文将不同处理器执行的访存指令的数值差记为δMIC.随着执行的推进,处理核间的δMIC逐渐累加,导致物理时间小的访存指令,反而MIC值更大.如图4所示,对于访存依赖Wr_A→Rd_A.尽管访存依赖的物理时间上满足Time(Wr_A)<Time(Rd_A),但逻辑时间上不满足约减条件MIC(Wr_A)<MIC(Rd_A),因此基于逻辑时间的方法不能约减该访存依赖.同理图4中,所有的访存依赖都不能被约减.图4不同步的逻辑时间导致大量的访存依赖无法约减为了取得更好的约减效果,本文提出一种懒惰同步逻辑时钟的方法,该方法在保证所有访存依赖关系均可约减的同时,不会引入大量的日志开销.懒惰的逻辑时间同步要求:当且仅当检测到一对访存依赖不能被约减时,才将发生依赖的两处理器的逻辑时钟进行同步.如图5所示,处理器0收到处理器1发起的请求消息后,处理器0检测到一对访存依赖Rd_A→Wr_A.从图中可以看出,该访存依赖的逻辑时间不满足约减条件MIC(Rd_A)<MIC(Wr_A).为了使后续的访存依赖可以被约减,在检测到不能约减的访存依赖Rd_A→Wr_A时,同步处理器0与处理器1的逻辑时钟.同步操作要求,处理器0在应答消息中携带其当前的逻辑时间,处理器1在收到应答消息后,根据消息中的逻辑时间,执行逻辑时间同步操作.此外,从图5可以看出时钟同步信息依赖确认消息.然而并非所有的缓存一致性协议都支持确认消息,如侦听协议.为此,本节分别针对目录协议与侦听协议,提出了两种逻辑时钟同步策略:基于应答消息的同步与基于请求消息的同步.3.2.1基于应答消息的同步策略该同步方法主要用于存在显式确认消息的缓存一致性协议中,如基于目录的协议,具体算法如算法1所示.该方法的基本思想是:在收到一致性请求算法1.基于应答消息的同步算法.CMIC:CurrentMemoryInstructionCountinlocalRMIC:MICinrequestmessageXMIC:MICinresponsemessageAHMIC:MICinlocalaccesshistoryOnreceivingcoherencerequestforblockb{1.Receive(b,RMIC)2.GetAHMICaboutb;3.If!exist(AHMICaboutb)4.AHMIC=CMIC;5.CompareAHMICwithRMIC6.If(AHMIC>=RMIC)7.Sendreplywith(CMIC);8.Else9.Sendreplynormally;}Onreceivingcoherencereplyforblockb{10.Receive(b,XMIC);11.Ifexist(XMIC)Page612.Log(CMIC,XMIC-CMIC);13.UpdateCMIC=XMIC;}Oncommittinginstructionsforblockb{14.UpdateAHMICwithCMIC;}消息时,利用消息内的访存地址进行访存冲突检测,如果检测到访存依赖且该依赖不能通过逻辑时间的序关系进行约减,则在应答消息中携带应答方的逻辑时间(访存指令数)(语句1~语句9).在请求方收到应答消息时,如果消息中要求更新请求方逻辑时钟,则请求方更新逻辑时钟,同时在日志中记录访存依赖(语句10~语句13).当处理器提交访存指令时,更新本地存储中的逻辑时间(语句14).基于应答消息的同步策略执行过程,如图6(a)和表1(a).具体的步骤为:①处理器0执行读访存操作Rd_A;②处理器1执行写访存操作Wr_A.为了维护缓存的一致性,处理器1向处理器0发送请求消息(该消息用来无效处理器0缓存的地址A的数据),处理器1在消息中负载逻辑时间30(MIC=30);③当处理器0收到请求消息以后.首先,进行访存冲突检查,并检测到访存依赖Rd_A→Wr_A;然后,比较访存依赖之间的逻辑时间(MIC(Rd_A)=90)>(MIC(Wr_A)=30),得到该访存依赖不满足约减条表1逻辑时钟同步策略(a)基于应答消息的同步处理器核0执行读操作Rd_A30y:Wr_A处理器核1提交写操作Wr_A处理器核0收到请求消息,检测到访存依赖x→y,并且MIC(x)>MIC(y)处理器核1收到应答消息,根据消息中携带的逻辑时间同步本地时间,同时记录同步信息(MIC=30,Offset=66)(b)基于请求消息的同步30y:Wr_A处理器核1提交写操作Wr_A步骤190x:Rd_A2396收到请求消息4步骤190x:Rd_A23453.2.2基于请求消息的同步策略该同步方法主要用于不存在显式确认消息的缓存一致性协议中,如基于共享总线的侦听协议,具体算法如算法2所示.该方法的基本思想:总线上所有件;最后,处理器0回复应答消息,并负载当前逻辑时钟96(MIC=96);④处理器1在收到应答消息以后.首先,读取消息中的逻辑时间(XMIC=96);然后,保存同步逻辑时间的信息(MIC=30,Offset=66);最后,将本地的逻辑时钟同步到96.其中,同步偏移的计算方法为Offset=XMIC-MIC(处理器1).处理器核0执行读操作Rd_A(50),若该值小于请求消息中的值,则将其更新为90处理器核1读取地址A侦听到的最大逻辑时间(90),与当前执行写操作的逻辑时间(30)进行比较,因为90>30,则更新当前的逻辑时间为91.处理器核1发出请求,携带逻辑时间91的访存请求被侦听(语句1),并在本地缓存中保存侦听到的每个缓存块的被访问的最大逻辑时间(语句2).当本地发起数据请求时,读取缓存中对应数据的逻辑时间(语句3),与本地当前逻辑时间做比较(语句Page74),如果本地逻辑时间较大,则不作处理,如果缓存中保存的逻辑时间较大,则更新本地逻辑时间,并将本次更新保存到日志中(语句5~语句9).请求消息中携带最大的逻辑时间(语句10).算法2.基于请求消息的同步算法.CMIC:CurrentMemoryInstructionCountinlocalRMIC:MICinrequestmessageSHMIC:LargestMICinsnoopinghistoryOnreceivingcoherencerequestforblockb{1.Receive(b,RMIC);2.UpdateSHMIConb,SHMIC=max(SHMIC,}Onsendingcoherencerequestforblockb{3.GetSHMICaboutb;4.CompareSHMICwithCMIC;5.If(SHMIC>CMIC)6.Log(CMIC,SHMIC-CMIC);7.CMIC=SHMIC8.RMIC=CMIC;9.Endif10.Send(b,RMIC)}基于请求消息的同步策略执行过程,如图6(b)和表1(b).具体的步骤为:①处理器0执行读访存操作,携带逻辑时间90(RMIC=90);②处理器1侦听到的请求,将请求中的逻辑时间与本地侦听历史中保存的地址A的逻辑时间(50)进行比较,请求中的逻辑时间大于本地侦听历史保存的逻辑时间,则更新侦听历史的逻辑时间到90;③处理器1发起写操作;④处理器1读取侦听历史中的逻辑时间90,而当前执行写操作的逻辑时间为30,通过比较可知,侦听历史中的逻辑时间更大,则更新写操作的逻辑时间到91;⑤处理器1发出请求,携带逻辑时间91.3.3支持松弛存储一致性模型多数确定性重放的研究工作都假设目标系统采用顺序一致性模型来简化设计方案.然而,在真实的处理器中多采用松弛存储一致性模型.为此,本节详细讨论了松弛存储一致性模型对重放的影响,以及如何在松弛存储一致性模型上检测并记录破坏顺序一致性语义的访存行为.3.3.1松弛存储一致模型对重放的影响本节以TSO(TotalStoreOrder)存储一致性模型为例,说明在保证写原子性的松弛存储一致性模型中,乱序执行如何造成重放的死锁问题.在TSO存储一致性模型下,图7给出了处理器0与处理器1的程序片段,表2给出了一次具体的执行顺序,执行步骤为:①处理器0执行访存操作Wr_A=1,该访存操作在引退之后,并没有提交到存储系统,而是缓存在写缓存当中;②处理器0执行访存操作Rd_B(0),并读到地址B的旧值0;③处理器1执行访存操作Wr_B=1,该访存操作立即提交到存储系统当中;④处理器0收到地址B的使无效操作ReceiveINV(B),该消息无效本地缓存的B的旧值;⑤处理器1的读操作Rd_A(0),并读到地址A的旧值0;⑥处理器1收到地址A的使无效操作ReceiveINV(A),此时处理器0将访存操作Wr_A=1提交到存储系统当中.表2TSO存储模型下的执行过程(初始化犃=0,犅=0)①Wr_A=1②Rd_B(0)③④Receive⑤⑥根据上述执行顺序,建立了如图7所示的访存依赖关系1:Rd_A→0:Wr_A与0:Rd_B→1:Wr_B.在重放过程中,根据记录的访存依赖关系与默认的程序序,便产生了图7中的死锁问题,0:Wr_A→0:Rd_B→1:Wr_B→1:Rd_A→0:Wr_A.3.3.2记录破坏顺序一致性语义的操作图7死锁问题的存在是因为在程序的执行过程中,程序序0:Wr_A→0:Rd_B没有被遵守,同时该乱序执行表现出了破坏顺序一致性语义的行为特征.为了避免重放时的死锁问题,本文记录了程序执行过程中破坏顺序一致性语义的操作.为了记录此类乱序操作,本文提出了一种新的日志项(指令延迟日志项).该日志项是一个二元组Page8(A,D),表示指令A没有遵守顺序一致性模型中规定的程序序,而是延迟了D条指令之后才被执行.如图7所示,写访存操作Wr_A在引退之后没有立即提交到存储系统当中,而在访存操作Rd_B引退之后才完成提交操作.因此为了记录真实执行过程,需要增加一条延迟日志(20,5),其中20是指令Wr_A的MIC索引,5表示推迟多少条指令之后执行.3.3.3检测破坏顺序一致性语义的访存操作在乱序执行的指令窗口当中,程序序的依赖总是从逻辑时间小的指向逻辑时间大的指令.根据默认的程序序,可以得出重放死锁的充要条件,如图8所示.条件1.流水线中存在已经提交但并未引退的指令A.该指令在引退之前,收到来自访存指令M的缓存一致性消息,并且二者存在依赖关系.其中,指令A占用乱序指令窗口的第ROB-2项,ROB表示乱序指令窗口的项数.条件2.流水线中存在未提交的访存指令B,占用乱序指令窗口的第X项.该指令与访存指令N存在依赖关系N→B,且X<ROB-2.条件3.在其他处理器之间,存在访存依赖M→N.从上述描述中可以看到,条件3的检测需要从多个处理器核中提取信息,实现硬件开销大.为此,本文将条件1与条件2作为检测破坏顺序一致性语义行为的必要条件,当检测到条件1与条件2同时发生时,则认为有破坏顺序一致性语义的行为发生.如图8所示,在指令流水线中,访存指令A提交到存储系统当中但并未引退,访存指令B尚未提交到存储系统当中.当访存指令B被提交到访存系统时,检测到访存指令A已经收到来自指令M的缓存一致性消息,则本文的方法认为检测到了破坏顺序一致性语义的行为.此时,记录访存指令B在程序序的逻辑时间与其被延迟执行的指令条数,表示为MIC(B),Offset,其中,Offset=ROB-2-X.4约减机制实现与重放算法本节讨论了实现中的具体问题.已有的研究工作[10-11,13,23]对硬件实现确定性记录方法中存在的问题(如检查点(checkpoint)实现等)进行了详细的讨论.本节主要讨论在本文方法的实现过程中所特有的问题.4.1利用缓存实现访存依赖检查在基于指令块的确定性记录实现[7,9,11,14-15]中,多采用签名的方法管理访存地址的集合,同时利用访存指令数管理逻辑时间(在本文中将签名与访存指令数统称签名状态).然而,在支持松弛存储一致性模型的乱序处理器中,维护签名状态与存储系统的一致是非常复杂的.为此,本文中采用基于缓存的检测与记录方法.本节以投机的读访存操作为例,说明已有方法在维护签名状态与缓存状态一致时存在的问题.文献[7]提出在指令的引退阶段修改签名的状态.然而,此刻的读操作已经提交到了存储系统当中,因此签名状态落后于缓存状态,基于该签名状态进行访存依赖检查会漏掉依赖关系.与之不同,文献[11,15]提出在指令的提交阶段修改签名状态.尽管该方法能够保持签名状态与缓存状态的一致,但是投机读操作可能被刷掉,当投机读操作被刷掉以后,对签名状态执行删除操作则会影响之前的访存操作,造成签名状态与程序行为的不一致,基于该签名状态同样会漏掉访存依赖.鉴于已有方法存在的问题,本文的实现基于缓存进行访存冲突检查.实现中,为每个缓存块增加一个域用来保存访问该缓存块的最近一次访存操作对应的逻辑时间,以及一个有效位表示该逻辑时间是否有效.访存冲突检查的具体操作如下:①当收到缓存一致性请求时,在乱序指令窗口中检查是否存在投机读操作与请求中的地址发生冲突;②如果不存在冲突,则通过缓存中的逻辑时间建立访存依赖关系;如果存在冲突,则建立两条依赖关系A与B.其中,依赖关系A是通过已经引退的访存指令建立的,而依赖关系B是通过该投机操作建立的依赖关系;③当投机读操作退出乱序指令窗口时,如果该投机操作是被刷掉的,则保留依赖关系A;否则,保Page9留依赖关系B.4.2缓存中的替换操作对同步的影响在基于应答消息的同步策略中,当收到对地址A的请求消息时,记录硬件需要从缓存中提取本地对地址A的最后一次操作的逻辑时间(记为LC-Last).如果因为缓存的替换操作,造成保存LC-Last的缓存块被替换出缓存,则用处理器当前的逻辑时间(记为LC-Current)代替LC-Last.由于LC-Current一定大于LC-Last,因此通过当前逻辑时间建立的依赖关系蕴含了通过最后一次操作时间建立的依赖关系.在基于请求消息的同步策略中,缓存记录的侦听历史中的最大逻辑时间(记为LC-Snooping),由于LC-Current可能小于LC-Snooping,因此当缓存LC-Snooping的缓存块被替换出缓存时,不能使用LC-Current进行代替.为了保证所使用的逻辑时间一定大于侦听历史中保存的逻辑时间,本文的方法在每个处理器中增加一个寄存器,用来保存侦听到的最大逻辑时间(记为LC-Max).当保存LC-Snooping的缓存块被替换出缓存以后,则用LC-Max代替.4.3重放算法本节重放算法的核心是:在重放过程中要保持访存指令数(逻辑时间)的全局同步.算法3给出了基于全局同步逻辑时间的重放算法.首先,算法读取本地日志中保存的依赖关系Order;然后,执行初始化,将各自的访存指令计数器MIC置零(语句1~语句2);最后,循环执行结构体(语句3~语句12).在该循环中,首先,所有的处理器执行一次栅栏同步(语句4);然后,处理器对计数器MIC执行加一操作(语句5);再然后,根据依赖关系判断是否需要等待被依赖指令的完成,无需等待则执行一条访存指令(语句6~语句8);最后,算法判断访存依赖是否已经失效,如果已经失效,则根据依赖关系更新访存指令数(语句9~语句11).算法3.重放算法.Order:MemorydependenceMIC:MemoryInstructionCount1.Order=Pop_order_from_log();2.MIC=0;3.While(1){4.Barrier(global)5.MIC++;6.Wait=check_dependece(Order,MIC);7.If(!wait)8.Step_one_memory_Operation();9.IfPassed(Order,MIC)10.Update(MIC,Order)11.Order=Pop_order_from_log()12.}本文重点讨论了基于全局逻辑时间的访存依赖约减方法,并分析了该方法在支持松弛存储一致性模型的处理器上的实现.本节实现的重放算法效率仍有进一步提高的空间,可以通过放松同步的次数,将约减判定条件由单条指令判定改进为一段动态指令统一判定.该优化方法可以大幅提升重放效率,将作为本文未来的研究工作.5实验评估5.1实现平台本文采用的模拟平台是GEMS与Simics模拟平台.其中,Simics模拟器在功能上模拟了商业级SPARC服务器,可以启动没有任何改动的Solaris10操作系统,GEMS是在Simics基础上开发的时序模型.本节评估使用的测试程序是Splash2[24],表3给出了被模拟系统的参数配置.默认核数8核缓存一致协议MESI协议L1缓存L2缓存ROB项数645.2实现结果5.2.1顺序一致性模型下的访存日志开销本节的实验比较了不同的同步策略对访存依赖约减的影响,同时与已有的研究工作进行了对比.图9给出了基于Splash2测试程序的实验结果.对于适用于目录协议的基于应答消息的同步策略,结果显示,多数程序的访存依赖日志开销在0.05Bytes/Kilo-Instruction~0.15Bytes/Kilo-Instruction之间.最坏情况下日志开销为0.2Bytes/Kilo-Instruction,为平均值0.11Bytes的1.8倍,可以看出该方法的约减效果相对稳定,不会因为程序行为的不同而波动较大.此外,适用于侦听协议的基于请求消息的同步策略,平均日志开销为0.13Bytes/Kilo-Instruction,约为基于应答消息的同步策略的1.18倍.Page10与其他的测试程序相比,LU算法测试程序的日志开销最小,这是因为在LU算法测试程序中访存冲突总数最少.如图10所示,可以发现约减算法的约减比例在不同程序之间是相对稳定的,不能约减的访存冲突占总冲突的0.1~0.35.此外,不同于其他的程序,在LU算法测试程序中基于请求消息的同步算法优于基于应答消息的同步算法.其原因是,通常情况下基于应答消息的同步算法能更快地同步逻辑时间,因此该方法取得的约减效果往往更好.然而在LU算法测试程序中,访存冲突之间的间距大,不同的逻辑时间同步算法之间的约减效果差异不大,同时基于应答消息引起的过度同步问题导致在LU算法测试程序中基于请求消息的同步算法优于基于应答消息的同步算法.图10在8核平台上执行64个软件线程时,在顺序存储一致性模型下,本节对比了本文的方法与目前最好的约减方法[8,14].本文提出的方法平均日志开销为0.11Bytes/Kilo-Instruction.而文献[8]的平均日志开销为0.55Bytes/Kilo-Instruction,文献[14]的平均日志开销为0.44Bytes/Kilo-Instruction.通过对比,本文提出的方法比文献[8]的方法减少了80%,比文献[14]的方法减少了75%.5.2.2顺序一致性模型下约减方法的可扩展性图11、图12分别给出了在16与32软件线程下,不同的同步策略需要记录的日志随核数的变化.如图11所示,当执行16个软件线程时,基于应答消息的同步策略在4核、8核、16核平台上的平均日志开销为0.11Bytes/Kilo-Instruction、0.15Bytes/Kilo-Instruction、0.02Bytes/Kilo-Instruction;基于请求消息的同步策略在4核、8核、16核平台上的平均日志开销为0.16Bytes/Kilo-Instruction、0.18Bytes/Kilo-Instruction、0.03Bytes/Kilo-Instruction.如图12所示,当执行32个软件线程时,基于应答消息的同图1116个软件线程时,处理器核数对约减方法的影响图1232个软件线程时,处理器核数对约减方法的影响Page11步策略在4核、8核、16核平台上的平均日志开销为0.10Bytes/Kilo-Instruction、0.12Bytes/Kilo-Instruction、0.05Bytes/Kilo-Instruction;基于请求消息的同步策略在4核、8核、16核平台上的平局日志开销为0.14Bytes/Kilo-Instruction、0.15Bytes/Kilo-Instruction、0.06Bytes/Kilo-Instruction.同时图13评估了软件线程数与核数同步变化时,不同策略的日志开销.在4核4线程、8核8线程、16核16线程的平台上,基于应答消息的同步策略的平局日志开销分别为0.09Bytes/Kilo-Instruc-tion、0.15Bytes/Kilo-Instruction、0.02Bytes/Kilo-Instruction;基于请求消息的同步策略的平局日志开销分别为0.12Bytes/Kilo-Instruction、0.17Bytes/Kilo-Instruction、0.03Bytes/Kilo-Instruction.图13软件线程数与处理器核数同步变化时,根据上述结果可以发现,本文提出的访存依赖约减方法可扩展性良好,日志开销不会随着核数的增加不断增长.同时,基于应答消息的同步策略最大日志开销为0.28Bytes/Kilo-Instruction,基于请求消息的同步策略最大日志开销为0.35Bytes/Kilo-Instruction.此外,很多应用在处理器核数为8时记录的访存日志开销取得最大值,该现象的产生是受约减前要记录的访存日志密度与约减效率共同制约的(约减后的日志密度=约减前的日志密度×约减效率),约减前要记录的访存日志密度随着核数的增加在降低,而约减效率随着核数的增加也在降低(值在变大).因此,约减后的日志开销是一个上升函数与下降函数的乘积,在可观测的范围内,该曲线存在多种可能情况(递增、递减、抛物线),其结果如图11、图12、图13所示.5.2.3基于松弛存储一致模型的日志开销为了支持松弛存储一致性模型,本文讨论了破坏顺序一致性语义行为的检测与记录方法.图14给出了记录违反顺序一致性行为需要的日志开销,该实验结果基于应答消息的同步策略.从图中可以看出,平均而言该部分的日志开销的比重较小,约占总日志开销的11%.尽管实验结果表明,在松弛存储一致性模型下,违背顺序一致性结果的情况发生概率很低,但是捕捉该类行为对保证重放的正确性是极为重要的.6结论基于多核处理器的并行程序设计是未来程序设计的发展方向.但由于并行程序调试困难,并行程序的生产率不高,限制了并行程序的发展进程.为了解决该问题,研究人员提出了确定性重放方法.然而目前的方法不仅日志开销大,并且无法在支持松弛存储一致性模型的处理器中实现.针对这两个问题,本文的主要贡献有3点:(1)提出访存依赖约减方法,其日志开销比目前约减效果最好的方法Timetra-veler减少75%;(2)提出了懒惰的逻辑时间同步方法,并针对不同的缓存一致性协议提出两种同步策略;(3)提出了在支持松弛存储一致性的处理器中实现约减方法的机制.尽管本文的日志约减方法可以大大减小日志开销,但由于使用了逻辑时间默认的序关系,降低了重放的速度.下一步工作中将研究如何使用粗粒度的逻辑时间来取代单条指令的逻辑时间进行约减,以Page12提高重放速度.致谢审稿专家与编辑部老师为本文提出了宝贵的修改意见,作者在此表示衷心的感谢!
