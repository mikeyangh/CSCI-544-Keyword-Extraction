Page1工作流可满足性(≠)计数的固定参数线性算法1)(浙江科技学院信息与电子工程学院杭州310023)2)(深圳大学计算机与软件学院广东深圳518060)3)(南加州大学软件工程中心美国洛杉矶CA90089)摘要工作流可满足性(WorkflowSatisfiability,WS)(≠)判定给定授权和互斥约束下的资源分配是否存在,是工作流访问控制中的基本问题.目前可以通过寻找一个具体的解来完成该判定,相应问题称为WS(≠)决策,现有的最低时间复杂度为O(2|S|(|C|+|U|2))(S,C,U分别为步骤集、约束集、用户集).然而,仅WS(≠)有解时,工作流授权规划未必合理,对资源异常可能缺乏鲁棒性.若能统计所有解的个数,不仅可判定WS(≠)有解与否,还能为授权规划提供重要的参考,相应的问题称为WS(≠)计数.该文提出WS(≠)计数问题,并根据Bjorclund关于集合划分权重和的结果证明其时间复杂度为O(2|S||U|),即其以|S|为固定参数,关于|U|线性时间可解,由此降低了当前的WS(≠)判定时间复杂度.进而,该文提出了一种快速的动态规划递推式,并全面优化Bjorclund方法的空间利用方式,使该文算法的实际性能随之提高,而O时间复杂度不变.随机合成数据集上的实验表明,该文最终的计数算法相对前述决策算法,执行时间平均降低了93%,峰值空间平均降低了87%,而求解规模提高了44%.关键词工作流;访问控制;资源分配;可满足性;职责分离1引言工作流管理是企业过程再造的核心技术[1],也是网格、云服务等计算体系结构的关键组成.它关注业务过程规划组织、执行控制和分析验证的自动化,由此高效调动人员、应用和数据,实现充分的商业价值.在工作流管理系统中,业务过程被划分为一组有序的步骤(任务),并统一调度执行.为了保障业务安全,防止非法访问与职权滥用,必须建立适当的访问控制机制.工作流访问控制贯穿业务过程的规划与执行,分为授权、约束和资源分配3个部分.在业务规划阶段,将每个步骤的执行权限分配给一组候选用户,称为授权.授权可以采取基于角色的访问控制[2]、基于任务的授权控制[3]等方式,最终将建立步骤与用户的二元关系.用户(或应用、Web服务等执行资源)必须具备其授权步骤的执行能力,但尚不能在工作流的任何案例中执行这些步骤.在业务执行阶段,为每个步骤指派唯一的用户,负责该步骤在当前案例中的执行,称为资源分配[1].资源分配使用户在特定案例中切实获得步骤的执行权限.如果步骤之间存在冲突或敏感关系,那么在同一案例中,它们的执行用户之间也必须满足一定的关系,称为约束.根据步骤关系的不同及其对用户关系的要求,可以定义多种类型的约束.例如职责分离[4]禁止某些利益冲突的步骤由同一用户执行,以免出现借机欺诈.若职责分离特指其二元情形,则也称为互斥约束,记为≠.例如报销和审核、编程和测试等都具有互斥关系.给定授权和约束,是否存在可行的资源分配,使得任何步骤的执行用户均满足预先授权,又不违反任何约束?这就是工作流的可满足性(WorkflowSatisfiability,WS).WS是工作流访问控制的基础性问题[5],因为它决定着受限于访问控制策略的业务过程能否得以实施.WS有多方面的含义,若问题目标是判定可行资源分配是否存在,则称为WS判定(Determining),记作?WS.此问题关系到访问控制规划是否正确.进入案例执行时,还须具体给出一个可行的资源分配[5-6],相应的问题称为WS决策(Decision),记作WS.求解WS也是回答?WS的一条途径.WS研究通常针对特定的约束类型(在括号中标注,例如互斥约束WS记为WS(≠)),目前主要集中于各类约束下的WS.2010年,Wang等人[5]指出由于职责分离是必不可少的约束类型,WS问题本质上是NP完全的.他们给出了一种O(|S||S|+1|C|)时间的WS(≠)算法(S,C分别为步骤和约束集).2013年,Crampton等人[6]将WS(≠)的时间复杂度降低至O(2|S|(|C|+|U|2))(U表示用户集),并对多种约束下的WS进行了研究.然而,一个工作流即使是决策可满足的,仍可能因为执行期间的资源失效,导致案例处理中断甚至资源分配无解.第2节给出的引例说明,通过合理的授权规划来增加资源分配解的数量,将能有效提高工作流在资源异常情况下的鲁棒性.给定约束,统计在某种授权下资源分配可行解的个数,称为WS计数(Counting),记作#WS.它与工作流的资源鲁棒性有密切联系.其一,引例表明#WS为资源鲁棒性的度量提供了参考性指标.其二,为精确度量这种鲁棒性,Wang等人已经提出了工作流k弹性(WorkflowkResiliency,WR(k))概念,即当任意k个资源失效时WS总保持成立.WR(k)验证可分解为C(|U|,k)个?WS问题,而#WS为?WS的回答提供了一条非WS的途径.其三,授权规划通常存在多次试误,相应的WR(k)验证只是完成排除,有可能用更简单的条件检查来代替.由于WR(k)对WS解的数量有一定要求,例如只有1个WS解不可能保证WR(1)成立,#WS为这种条件的构造提供了Page3潜在的途径.此外,合取范式可满足性(ConjunctiveNormalFormSatisfiability,SAT)、约束可满足性(ConstraintSatisfiability,CS)等经典问题均包括决策和计数两个方面.决策强调给出具体可行的解,而计数侧重整体和统计特征,其结果互为补充.它们从不同角度进行可满足性判定,有利于深入理解其内在逻辑,拓宽求解途径.#SAT和#CS的研究已有多年的历史,出现了很多重要的算法与应用[7-8].目前,WS研究主要集中于决策.然而,无论作为资源鲁棒性的参考指标,还是WR(k)排除条件的构造途径,或回答?WS的另一途径和WS本身的重要侧面,#WS研究都是不可或缺的.由于长期实践证明职责分离是业务安全的基础性原则[4,9],而其最典型的情况是二元互斥.本文将对相应的#WS(≠)问题进行研究.在此之前,Wang等人[5]已在WS研究中引入了参数化复杂性[10],本文将从这一角度进行#WS的研究.对于WS(≠),Crampton等人[6]给出了O(2|S|(|C|+|U|2))的参数化时间,是其已知最低的时间复杂度,而他们的求解方法依赖于Bjorclund[11]关于集合最大权划分的有力结果.Bjorclund为解决集合划分问题发展了一种赋权集容斥原理和快速文将基于这一方法来建立#WS(≠)的算法.本文的主要贡献在于,基于前述思路给出一种O(2|S||U|)时间的算法,表明#WS(≠)固定参数线性时间可解.本文算法时间复杂度优于前述Crampton的WS(≠)算法,因而给出了目前最低的?WS(≠)时间复杂度.不仅如此,本文还提出了一种快速的动态规划递推式,并对Bjorclund方法的空间利用进行优化,使本文#WS(≠)算法在保持时间复杂度的前提下,进一步提高实际性能.本文第2节通过实例来引入WS计数问题;第3节介绍预备知识,包括参数化算法、赋权集容斥原理、快速给出各类WS问题的定义;第5节根据Bjorclund关于划分权重和的结果证明#WS(≠)的时间复杂度,事实上也给出了一种#WS(≠)算法;第6节改进Bjorclund的划分权重和求解方法,由此得到一种性能更为优化的#WS(≠)算法,并表明其保持第5节所得时间复杂度;第7节对本文两种算法进行实验研究,并与现有代表性WS(≠)算法就WS判定性能进行对比;第8节介绍和分析相关工作;第9节总结全文.2引例一个物料采购工作流如图1所示,包括5个步骤:申请采购(s0)、创建订单(s1)、验收货物(s2)、准备支付(s3)和同意支付(s4).在s0中,根据生产需求拟定物料请购单,提交订货;在s1中,审核采购需求、选择供货商,创建并发出订单;在s2中,对供货商发来的物料进行检验,确认符合订货要求;在s3中,若订货价格基本合理则创建支付申请;在s4中,根据货物验收单等凭据对支付申请进行审批.由于支付涉及资金流出,必须通过一定的规则来保证业务安全.为了控制不合理订货,订货人不能准备支付.为了分离实物验收和价格检查两项控制职能,验收货物和准备支付不能由同一人执行.为了防止申请者自我审批,一个人不能既申请采购,又创建订单,也不能既准备支付,又同意支付.将这些规则表达为互斥约束,如图2所示.图中顶点表示步骤,而边表示步骤间的互斥关系.假设有5个用户,记为u0,u1,u2,u3和u4,负责该工作流的处理.如图3给出了两种可能的授权方案,在每个步骤旁边列出了其所有授权用户.容易看出,授权1只有一种可行的资源分配.如果用从步骤集到用户集的函数π来描述,则表示同一案例中s0,s1,s2,s3和s4分别由u0,u1,u2,u3和u4执行.该资源分配依赖于每个用户,任何用户作为执行资源失效(如离职)都会使相关案例处理中断,新案例的资源分配无解.采用该授权方案时,工作流是决策可满足的,但是缺乏必要的资源鲁棒Page4性,即在资源异常情况下维持运转的能力,无法在缺少某些资源时仍然给出资源分配可行解.将授权1中步骤s2,s3的授权用户u2,u1进行对调,即得授权2.它有如下5种可行的资源分配:(1)π(s0)=u0,π(s1)=u1,π(s2)=u1,π(s3)=u2,π(s4)=u3;(2)π(s0)=u0,π(s1)=u1,π(s2)=u1,π(s3)=u2,π(s4)=u4;(3)π(s0)=u0,π(s1)=u1,π(s2)=u3,π(s3)=u2,π(s4)=u3;(4)π(s0)=u0,π(s1)=u1,π(s2)=u3,π(s3)=u2,π(s4)=u4;(5)π(s0)=u0,π(s1)=u1,π(s2)=u1,π(s3)=u3,π(s4)=u4.其中第(1)、(3)种资源分配不依赖于u4,第(2)种不依赖于u3,第(5)种不依赖于u2,只有第(4)种依赖所有用户.采用授权2时,不论单独缺少用户u2、u3还是u4,对新到达案例,总存在资源分配可行解.受影响的原有案例,通过适当调整也可以迁移到相近的解,继续其处理.该授权方案同样决策可满足,而且比前一方案更能抵抗资源异常的干扰,在此意义上也更为合理.由本例可见,工作流的资源鲁棒性与可行资源分配的数量有密切关系.解的数量是其多样性的集中体现.解集越大,替代的资源分配方式越多,工作流对单一资源的依赖性也越低,从而越少受资源异常的干扰.解集大小对资源鲁棒性的影响不是绝对的,但是为其提供了一个重要的参考指标.3预备知识本节介绍必要的预备知识.约定Z+表示非负整数集,并记N={1,2,…,n}.3.1参数复杂性与犗分析经典复杂性理论表明,NP难问题不太可能存在多项式时间的有效算法.在实际应用中,多采用近似或智能算法求解,无法获得可重复的精确解.20世纪90年代,Downey和Li等人[10,12]提出了参数化复杂性理论,为求解此类问题开辟了一条新途径.他们发现很多问题具有f(k)p(n)形式的复杂度,其中k和n反映不同输入的规模,f(k)是关于k的任意函数,而p(n)是关于n的多项式函数.在k不超过某个固定值的条件下,问题复杂度是n的多项式,从而可以有效求解.当问题复杂度很高时,通常采用O记法进行分析.它是O表示法的简化,可以反映算法的主要开销[13].设c为任意正常数,若p(n)表示关于n的多项式,则O(cnp(n))可以简化表示为O(cn).3.2赋权集容斥原理容斥原理是一种基本的组合计数方法,在有限集元素计数问题中有广泛的应用.它可以推广到赋权有限集上[11],如下面的定理.定理1.设S为有限集,w:2S→Z是其子集格上的权函数,即2S为w赋权集.又设{Si|i∈I}是S的一组子集,其中I为整数下标集.若将S记为∩则有3.3快速有着重要应用[14].下面介绍它的一种形式及快速计算方法.定义1.设S={s1,s2,…,sn},2S为w赋权集,定义函数g^:2S→Z+,使得对任何SS,g^(S)等于S所有子集的w权重之和,即g^(S)=∑SS根据w计算g^的过程称为通过定义直接进行下面的定理给出了一种根据w计算g^的递推式.定理2.设g0,g1,…,gn是一组从2S到Z+的函数,且对任何SS,gi(S)定义为gi(S)=则当g0=w时,gn=g^.若以O(2n)空间存储所有中间的g^i,则g^可通过O(2nn)次加法求得,称为快速Page53.4集合划分权重和本文提出的#WS(≠)问题可归结为集合划分权重和问题,其定义如下.定义2.设w1,w2,…,wk:2S→[-M,M]Z是集合S={s1,s2,…,sn}子集格上的k个权函数.若SiS(1ik),则称tk=(S1,S2,…,Sk)为S上的k元组,将其集合记为Tk.令权函数w:Tk→Z,使对任意tk∈Tk,w(tk)=∏1ik权集.若∪(S1,S2,…,Sk)为S的k划分(划分块可为空).集合划分权重和,即S所有k划分的w权值之和.文献[11]利用赋权集容斥原理与快速合的方法求解该问题,得到了O(2nklogM)的时间复杂度,其求解方法介绍如下.将Tk中所有k划分的集合记为Pk,对其应用赋权集容斥原理可得w(Pk)=∑J{1,2,…,n}(n)k(SJ)为SJ={sj∈S|j∈JN}上满足|S1|+式中T|S2|+…+|Sk|=n的k元组tk=(S1,S2,…,Sk)的集合.由此可得w(Ti:2S→Z(1ik,0mn).设w(m)式中g^(m)[-M,M],使得对SS,则任取SS,因此,从w(m)变换求出所有g^(m)[11]引理6).为了进一步利用g^(m)下递推式进行动态规划g(p,q,r,SJ)=r烄∑烅m=0g((p+q)/2+1,q,r-m,SJ)},p<qg^p烆由该式求得g(1,k,n,SJ)即为w(T动态规划缓存中间所有g(p,q,r,SJ),避免重复计算,每个w(TlogM)时间内完成计算(文献[11]引理6).4问题定义本节定义WS(≠)相关问题.设U={u1,u2,…,uk}表示用户集,S={s1,s2,…,sn}表示步骤集.定义3.工作流(S,)是步骤的偏序集,其中表示步骤间的执行顺序.任取s,s两个步骤,若s<s,则s先于s执行.将工作流的一次执行称为一个案例.定义4.工作流授权AS×U是二元组的集合,表示以S为步骤集的工作流在用户集U上的权限分配情况.若(s,u)∈A,则用户u是步骤s的一个候选执行者.定义5.互斥约束XS×S是无序二元组的集合,表示步骤间的职责分离关系.若(s,s)∈X,则在同一案例中,s和s不能由同一用户执行.定义6.设SS,函数π:S→U称为S上的资源分配.所有S上的资源分配的集合记为∏不引起混淆时,将S上的资源分配简称为资源分配.对S上的资源分配π:(1)若任取s∈S均有(s,π(s))∈A,则称π是基于A的.(2)若存在(s,s)∈X使得π(s)=π(s),则称π违反X.定义7.互斥约束工作流可满足性,记为WS(≠),是一个二元组〈A,X〉,从中可以引出以下3个问题:(1)WS(≠)判定问题,记为?WS(≠),要求判定基于A且不违反X的资源分配是否有解.当?WS(≠)的回答为Yes/No时,称WS(≠)成立/不成立.(2)WS(≠)决策问题,记为WS(≠),要求给出一个基于A且不违反X的资源分配,或指出其无解.(3)WS(≠)计数问题,记为#WS(≠),要求统计基于A且不违反X的所有资源分配解的个数,即WS(≠)所有可能解的个数.其中WS(≠)属于NP问题,其解可在多项式时间内验证.5#WS(≠)的固定参数线性复杂度本节将通过归结为集合划分权重和问题,证明#WS(≠)具有O(2|S||U|)时间复杂度.一个资源分配给出了步骤集S上的一个|U|-划分,第1i|U|个划分块由该资源分配指派用Page6户ui执行的所有步骤构成,若ui未被指派执行任何步骤,相应的划分块为空.反过来,S上的任何|U|-划分也给出了一个如此含义的资源分配.该资源分配是可行的,当且仅当每个划分块满足以下要求:(1)第i个划分块中,任何步骤的授权用户中均含有ui.(2)对每个划分块,当其中所有步骤由同一用户执行时,不违反X中任何约束.由于#WS(≠)对所有可行资源分配计数,可将其转化为对符合条件(1)、(2)的|U|-划分计数.根据这两个条件选取适当的权函数,可进一步将问题转化为求集合划分权重和,相应有以下定理.定理3.#WS(≠)=(S,U,A,X)可在O(2nk)=O(2|S||U|)时间内求解.证明.记SA(ui)={s∈S|(s,ui)∈A}(1i|U|),表示用户ui根据A有权执行的所有步骤.取权函数wi:2S→{0,1}[-2,2],使对任意SSwi(S)=1,SSA(ui)∧(s,s)∈X({s,s}S)0,{否则任取S上的|U|-划分pk=(S1,S2,…,Sk),划分块Si符合前述条件(1)、(2)当且仅当wi(Si)=1.令w(pk)=∏1ik当且仅当w(pk)=1,于是可行资源分配的数量即为S上所有|U|-划分的w权重和.由3.4节可知,此划分权重和可在O(2nklog2)=O(2nk)时间内求得,这也就是#WS(≠)=(S,U,A,X)的时间复杂度.上述结论表明#WS(≠)以|S|为固定参数,关于|U|线性时间可解.此结果优于WS(≠)目前的最低时间复杂度O(2|S|(|C|+|U|2))[6],从而也降低了?WS(≠)的时间复杂度.文献[11]未分析集合划分权重和问题的空间复杂度,但其求解过程(参见3.4节)中需要在步骤集S的子集格上计算|U|·|S|个快速ζ变换,使得集合划分权重和与#WS(≠)的空间复杂度至少为O(2|S||U|).空间复杂度高是上述方法固有的特点,然而文献[11]的空间利用方式缺乏深入规划,造成了进一步的浪费.特别地,即使空间充裕,算法的实测时间性能仍不够理想.6优化的#WS(≠)固定参数线性算法本节将在赋权集容斥原理与快速架下,通过更有效地动态规划和空间利用来求解集合划分权重和问题,由此给出一种时间和空间复杂度均为O(2|S||U|)的#WS(≠)算法,而其实际的时间和空间开销明显降低.为了简化公式表述,约定两个记法mp,q=(p+q)/2,lp,q=q-p+1.当p,q的形式比较复杂时,也分别写成m(p,q)和l(p,q).下面首先在1.4节给出的集合划分权重和求解框架中,引入一种更有效的动态规划递推式.在该框架中,由容斥原理将赋权集上所有k划分的权重和转化为一组独立w(Tn,SJ)(JN),的计算;并利用快速数wi(1ik)计算g^(m)原理和n,SJ),关键在于适当的动态规划.文献[11]采用式(5),将g(p,q,r,SJ)递推分解为g(p,(p+q)/2,m,SJ),g((p+q)/2+1,q,r-m,SJ)的一组乘积之和,递推终止时分解为单独的g^(m)0,则其参与的所有乘积均为0,对g(p,q,r,SJ)的值没有贡献.而采用式(5),递推终止前,只能假设所有g^(m)i(piq)对g(p,q,r,SJ)都有贡献,无法及时进行剪枝,这就影响了计算性能的进一步提高.基于上述分析,本文提出一种有利于快速剪枝的递推式,如下面的定理4.定理4.设g^(m)由式(4)定义,式中w(m)式(6)定义,任取SJS,1p,qk,0rp,qn,定义g(p,q,rp,q,SJ)如式(7).则当p<q且rp,q=r时,g(p,q,rp,q,SJ)等于式(5)给出的g(p,q,r,SJ).g(p,q,rp,q,SJ)=烄r(mp,qg^(r(m烅rq,p∑p,q=0rg(mp,q+1,p,rq,p-rp,q,SJ)},q<pg^(r烆p(SJ),p,p证明.当p<q且rp,q=r时,将式(7)变形得g(p,q,r,SJ)=r{g^(m)烄∑m=0烅g(p,mp,q-1,t,SJ)}},p<qg^(r)烆p(SJ),Page7该式与式(5)以不同方式计算同样的g(p,q,r,SJ),也就是式(7)中的g(p,q,rp,q,SJ)(p<q).证毕.根据这一定理,可以用式(7)取代式(5)来计算g(1,k,n,SJ),即w(T每次递推都要代入g^(m)r-m,SJ)的多次调用,若g^(m)用分枝可以剪去.分析定义可知,若|SJ|<m,或者SJ中基数为m的子集wi权值为0,均有g^(m)此对任意1ik,在有m和SJ两个维度的g^(m)矩阵中,至少有近一半的0值.这就为前述剪枝的效果提供了一定的保证.在本文定理3(将#WS(≠)归结为集合划分权重和,从而可以利用其求解框架)和定理4(提出一种新的动态规划递推式)的基础上,进一步对空间利用进行优化,给出#WS(≠)算法如下.算法1.CountingWorkflowSatisfiability(≠).输入:(S,U,A,X),其中AS×U,XS×S输出:符合A且不违反X的资源分配的个数1.对每个1ik,根据式(6)计算wi:2S→{0,1}并保存结果.分为以下3步:1.1遍历X判定每个SS是否违反约束,保存结果.1.2遍历A,求每个ui(1ik)的授权步骤集,记为SA(ui),并保存结果.1.3对每个1ik和SS,若SSA(ui)且S不违反约束,wi(S)←1,否则wi(S)←0.所有wi计算完成后保存结果,每个wi占用n位二进制以备重复利用,释放1.1、1.2两步保存的结果.2.求g^(m)并保存.分为以下2步:2.1对每个1ik,0mn,根据式(3)由wi计算w(m)i:2S→{0,1}并保存.2.2对每个1ik,0mn,根据式(4)由w(m)g^(m)i.采用快速ζ变换,令g0=w(m)推式求gn=g^(m)g1的存储,然后令j←1,根据gj-1对所有SS计算gj(S),并写入其存储空间,再根据gj对所有SS计算gj+1(S),并清空整个gj占据的存储,用来存放gj+1(相当于j←j+1,重复上一步操作),如此交替(循环),直至求出gn.此时若gn位于辅助空间中,将其复制到最初g0=w(m)快速ζ变换均如此计算,并共用前述辅助空间.所有g^(m)算完成后,释放辅助空间.3.根据式(1),采用部分求和方式计算w(Pk).先将部分和置为0,依次对每个JN计算(-1)n-|J|w(T加入部分和,最终结果即为w(Pk).其中每个w(T即g(1,k,n,SJ),根据式(7)由g^(m)划,令其共用同一块缓存.以上算法描述中,g^(m)的结果均可能为大整数,其可能值的长度随问题规模增长,实现时应保证其空间分配.g^(m)值为C(n,n/2)(n元集中n/2组合的个数,也就是n元集中具有相同基数的子集最大可能的数量),小于2n,所占据的二进制位数不超过n.关于g(1,k,n,SJ)的估值,有如下不等式.定理5.设g^(m)由式(4)定义,式中w(m)式(6)定义,则任取SJS,1p,qk,0rp,qn有g(p,q,rp,q,SJ)g(p,q,rp,q,S)[(rp,q+1)2n]q-p+1[(n+1)2n]q-p+1(8)证明.见附录.因此,g(p,q,r,SJ)不超过lp,q[n+log(n+1)]位二进制.由于w(Pk)∑JN2n(k+1).w(Pk)的二进制位数不超过klog(n+1)+n(k+1)位.上述大整数的运算时间也可能超出常量范围.设某个整数二进制位数为p(n),则其加减和比较运算需O(p(n))时间,乘法运算需O(p(n))时间[15].下面通过逐步分析,确定算法1的时间和空间复杂度.1.1由于x=|X|=O(n2),|2S|=2n,判定S是否违反某个约束需要进行O(n)次比较,本步共需O(2nnx)=O(2nn3)=O(2n)时间,保存结果需要O(2n)空间.1.2由于|A|=O(nk),本步需O(nk)时间,而|SA(ui)|=O(n),保存所有SA(ui)需要O(nk)空间.1.3判定SSA(ui),需要O(n2)时间,再利用1.1步保存的结果,可在常数时间内求出wi(S).本步共需O(2nn2k)=O(2nk)时间,保存结果需要O(2nnk)=O(2nk)空间.第1步共需O(2nnx+nk+2nn2k)=O(2nk)时间,最大空间占用O(2n+nk+2nnk)=O(2nk),出现在第1.3步.2.1用O(n)时间求出S的基数后,利用1.3步保存的wi,只需常数时间即可确定w(m)O(2nn2k)=O(2nk)时间,保存结果需要O(2nnk)=O(2nk)空间.2.2本步共有nk个快速ζ变换,完成计算需要O(2nn2k)次O(n)位加法,其时间复杂度为O(2nn3k)=O(2nk).在第2.2步w(m)O(2nn)=O(2n)大小的辅助空间,较之粗放的利用方式,每次快速ζ变换降低了(n-1)/(n+1)的空间占用.第2步共需O(2nn2k+2nn3k)=O(2nk)时间,最大空间占用为O(2nnk+2nn)=O(2nk),出现在第2.2步.3.先对g(1,k,n,SJ)的计算进行分析.根据式(7)计算Page8g(1,k,n,SJ),递推完全终止时,将分解为若干g^(r)g(p,p,r,SJ),其下标1pk,有k个不同的值.不妨设k=2h+1-1,根据式(7)计算g(1,k,n,SJ)的过程可以表示为一棵有k=2h+1-1个叶结点的递推树,如图4所示.树的深度为2h,其根结点位于第0层.此递推树是以一棵深度为h的正则完全二叉树为基础,将每个内结点(图中矩形框)扩展为2个内结点(以垂直边相连的一对黑色结点)和一个叶结点(阴影结点)而得.基础二叉树有2h+1-1个结点,其中2h-1个内结点,故递推树有2h+2-3个结点,其中2h+1-2个内结图4g(1,k,r1,k,SJ)的递推树根据式(7)的终止条件,任何叶结点g(i,i,ri,i,SJ)的值即g^i有开销.对所有内结点的计算开销,按图4中的矩形框分组来分析.每个矩形框包含g(p,q,rp,q,SJ)(p<q)和g(q,p,rq,p,SJ)两个内结点,根据式(7),其递推分解关系如图5所示.图5g(p,q,rp,q,SJ)和g(q,p,rq,p,SJ)的递推分解因0rp,qn,结点g(p,q,rp,q,SJ)可能有O(n)个不同任务,最大为rp,q=n.0r(mp,q,mp,q)rp,qn,故结点g(q,p,rq,p,SJ)上也可能有O(n)个不同任务,最大为rq,p=rp,q-r(mp,q,mp,q)=n-0=n.由于动态规划缓存任务的计算结果,每个不同的任务即使被多次调用,也只需计算一次.因此,该矩形框的递推计算开销(不含子结点的计算开销)包括(On·∑点(偶数层和奇数层各有2h-1个),k=2h+1-1个叶结点(阴影结点2h-1个,白色结点2h个).给定SJS,结点g(p,q,rp,q,SJ)(1p,qk)对任意0rp,qn计算式(7)给出的函数g(p,q,rp,q,SJ),不同rp,q(若p,q的形式比较复杂,可记为r(p,q))对应不同任务,根结点g(1,k,r1,k,SJ)上只有一个rp,q=n的任务.递推树中的边表示调用关系,父结点根据式(7)将自身的每个任务分解为若干对子任务,每一对子任务分别调用两个子结点进行计算,然后将其结果相乘,所有乘积的和,即为父结点任务的计算结果.次乘法和等量的加法.加数和乘数均不超过g(p,q,rp,q,SJ)的最大可能值,故一次加法或乘法分别需O(lp,q[n+log(n+1)])或O(lp,q[n+log(n+1)])时间.因此,该矩形框的递推计算总时间为如前面分析,单个g(p,q,rp,q,SJ)或g(q,p,rq,p,SJ)占据O(lp,q[n+log(n+1)])位二进制,而矩形框中有O(2n)个不同任务,存储它们的计算结果,所需空间开销为在进一步分析之前,给出递推树及其基础二叉树的如下性质.定理6.对递推树的任意结点g(p,q,rp,q,SJ),称lp,q=|q-p|+1为其宽度,从而同一矩形框中两个内结点宽度相同,称其为矩形框的宽度.此时有(1)第0th-1层任何矩形框的宽度均为lt=2h-t+1-1.(2)第0th-1层所有矩形框的宽度之和Lt=2tlt=2h+1-2t.证明见附录.现在,第0th-1层所有2t个矩形框的递推Page9计算时间之和为O(2tlt[n4+n3log(n+1)])=O((2h+1-2t)[n4+n3log(n+1)])=O(k[n4+n3log(n+1)]).第t层所有2t个矩形框的空间开销之和为O(2tlt[n2+nlog(n+1)])=O(k[n2+nlog(n+1)]).所有h=log(k+1)-1层矩形框的递推计算时间之和O(klog(k+1)[n4+n3log(n+1)])即为总的计算时间.由于根结点只有r1,k=n的任务,而此结果计入了该结点0r1,kn所有任务的递推计算时间开销,因而偏于保守.所有h=log(k+1)-1层矩形框的空间开销之和为以上分析了对特定的SJS,计算g(1,k,n,SJ)所需的时间和空间开销.因为有2n个JN,计算所有的g(1,k,n,SJ)需要的时间之和为O(klog(k+1)2n[n4+n3log(n+1)])=O(2nk).由于根据g(1,k,n,SJ)计算w(Pk)时,逐一计算每个g(1,k,n,SJ)并将其加入部分和,不必事先全部计算,特别是各g(1,k,n,SJ)重复利用动态规划缓存(O(klog(k+1)[n2+nlog(n+1)])),而部分和只占据O(klog(n+1)+n(k+1))空间,故第3步的最大空间占用为O(klog(n+1)+n(k+1)+klog(k+1)[n2+nlog(n+1)])即O(kn2),出现于计算g(1,k,n,SJ)的动态规划.综合1~3步的分析,整个算法的时间和空间复杂度均为O(2nk),即O(2|S||U|).其中最大空间占用出现在第2步.7实验研究本节将对相关WS算法进行实验研究,所有算法均以C++实现,涉及大整数运算均使用GMP算术库.实验环境为3.4GHzCorei3CPU、16GBRAM、RedHatEnterpriseLinux764bit虚拟机(宿主系统为Windows7).由于缺少相关的标准数据集,将通过一定规则随机生成测试数据.在所有数据中均取A=S×U,这是S和U可提供的最大负载(可能的资源分配数量达到最大).实验1.WS(≠)判定性能对比WS(≠)判定有WS(≠)和#WS(≠)等多种途径.本文给出了两种#WS(≠)算法(定理3和算法1).文献[6]给出了目前时间复杂度最低的WS(≠)算法.在此之前,有时间复杂度分析结果的WS确定性算法主要有文献[5,16-17],均基于穷举搜索.不同在于文献[16]枚举所有的资源分配解,文献[5]排除了授权用户数|UA(s)|>|S|的步骤,当|U||S|时与文献[17]等价,发现一个解则返回,比枚举所有解更快.因此选择文献[17]的WS版本作为穷举搜索算法的代表.本实验将对4种算法的实际性能进行比较.按以下规则随机生成17组数据,并在测试结果转折处,按同样的规则补充了12组数据:将|S|的值指定为8~24;在0.25|S|~0.75|S|之间随机生成|U|的值(|U||S|时,WS(≠)必然成立,只需令所有步骤的执行用户均不相同);在任意两个步骤之间,以0.15的概率决定是否生成互斥约束(每个步骤已有各自的授权要求,而约束是根据步骤间关键联系施加的进一步访问控制,其密度通常不太高).在所得数据上,4种算法的执行时间和峰值空间如表1所示(—表示执行时间超过2h,×表示进程内存分配失败被杀死),比较如下.穷举搜索算法空间开销最低,并且稳定.当步骤数为8~13时,其执行时间也是最少的,均在0.25s以内,主要原因是算法的初始开销极低,且输入规模足够小,能够以很高的概率快速找到一个解.但是由于时间复杂度高,当步骤数达到14以后,执行时间增长很快,仅在3组数据上取得了优于多数算法的效率.该算法在2h时间和16GB内存限制下可计算的输入规模为19个步骤和5个用户,但小于此规模时,已出现时间性能急剧恶化的情况.文献[6]的算法空间开销最大,并且随输入规模的增大而快速增长,导致其可计算的数据规模最小,为16个步骤和9个用户.相对于穷举搜索算法,当步骤数为14~16时,在4组数据上降低了执行时间,最大降幅达到98%或以上,开始体现出时间复杂度上的优势.随着输入规模的增加,该算法的执行时间以一种较为稳定的方式增长,没有剧烈的随机波动.对于定理3的方法,在前述限制下可计算的最大规模为19个步骤和5个用户,与穷举搜索算法相同,在小于此规模时,已经出现了空间性能恶化的情况.在步骤数为8~13时,时间性能弱于穷举搜索算法,但其绝对时间差不超过0.93s.在步骤数达到14以后,相对于穷举搜索算法,在共同可计算的12组数据上,有8组数据将执行时间降低了58%~99.8%,仅4组数据执行时间增加,但绝对时间差在45.6sPage10之内,较明显体现了低阶指数时间复杂度的优势.相对于文献[6]的算法,在共同可计算的数据上,执行时间降低了61%~95%,体现了相同固定参数下线性时间算法的优势,同时空间占用也降低了25%~78%.对于算法1,可计算的最大规模为23个步骤和7个用户,明显优于其它算法.仅按步骤数规模计算,相对于穷举搜索算法和定理3的算法提高了21%,相对于文献[6]的算法提高了44%.在时间和空间性能上,相对于穷举搜索算法,在步骤数为8~13时,时间性能虽然较弱,但绝对时间差不超过0.41s,在步骤数为14~24时,对共同可计算的12组数据,有9组数据的执行时间降低达50%~99.9%,表14种WS(≠)判定算法的时间/s和空间/MB代价文献[6]1234567891011121314151617181920212223242526272829实验2.算法1的时间复杂度.本文给出两种#WS(≠)算法均具有O(2|S||U|)时间复杂度.由于定理3已将其时间复杂度归结为集合划分权重和,而算法1经过了较为复杂的分析,这里仅对后者进行实验,以验证分析结果.本实验首先对算法1的执行时间仅随步骤数量的变化趋势进仅2组数据执行时间增加,但绝对时间差不超过17.1s.相对于文献[6]的算法,在共同可计算的14组数据上,执行时间降低了81%~99%,平均为93%,空间占用降低了32%~99.6%,平均为87%,时间和空间性能均取得更大的优势.相对于定理3的方法,执行时间降低了25%~80%,平均为56%,表明本文提出的递推式收到了良好的剪枝效果.对步骤数为11~24的15组(共同可计算)数据,空间占用降低了81%~99%,对步骤数为8~10的3组数据,空间占用降低了7%~39%,这是因为输入规模较小时,初始开销占主导作用,整体差别不大.空间占用平均降低了84%,算法1采取的空间优化措施,作用非常明显.空间20.819.045.9171.2306.6541.4917.02574.94079.14079.04867.64867.87408.012557.0×××××××××××××××行实验.在0约束的情况下,取|U|=5,8,11,14和17,令|S|从1变化到21,测试执行时间的变化.取约束数量为0的原因是.(1)根据随后实验3的结果,在|S|和|U|相同时,约束越少,负载越大,所需执行时间越长.(2)便于步骤数量自由变化,例如|S|=1,2,3,Page114和5时,约束的数量不能超过0,1,3,6和10个,约束数量越多,步骤数量的取值范围越窄.(3)不需要考虑约束拓扑的影响.同样数量的约束在同样数量的步骤之间有多种分布方式,所形成的负载并不相同.当步骤数量变化时,即使控制约束数量不变,仍然存在约束拓扑的变化.而在0约束情况下,约束拓扑总是相同的.测试结果如图6所示,执行时间比函数2|S|的增长略快.因算法1的时间复杂度为O(2|S||S|4|U|),实验结果与理论分析是相吻合的.接下来让用户数量变化,对算法1的执行时间进行测试.取实验1的第3,6,13,22和26组数据,其|S|分别为10,13,16,19和22,保持|S|和X不变,让|U|从2增加到20,测试算法1的执行时间如何变化,结果如图7所示.令|S|=22,忽略一个常数因子的差异,所有执行时间曲线均以关于|U|的线性函数2|S||U|为上界,这与算法1的最坏时间复杂度O(2|S||U|)是吻合的.实验3.约束规模对本文算法时间性能的影响.本实验对本文两种算法的时间性能做进一步研究,测试它们与约束规模之间的相关性.按以下规则生成数据:将|S|的值指定为9,12,15,18和21;在0.3|S|~0.7|S|之间随机生成一个|U|的值;对每一组|S|和|U|,在任意两个步骤之间,以0.9的概率决定是否生成互斥约束.对前面所得每一组数据,逐渐删除约束,测试算法执行时间如何变化,结果如图8所示.可以看到,当约束逐渐增加时,两个算法的执行时间均呈降低趋势.这主要是因为约束密度增加使得权函数wi(1ik)和w(m)(0mn)的数值变小,从而递推式中加法和乘法运算的速度变快,动态规划的效率提高.对|S|为9,12的小规模数据,在上述趋势之外,某些点的函数值出现了较大波动,可能有以下原因.(1)权函数计算需要遍历约束集,随约束规模增长耗时增加.这部分计算的时间复杂度为O(2|S||S|2),而动态规划部分的时间复杂度至少为O(2|S||S|3|U|),这两部分开销随约束密度增长的变化趋势相反.尽管后者对整体执行时间起决定作用,然而当|S|较小时,前者的影响也相对明显,因而造成了一定的波动.(2)在对数纵坐标下,当函数值较小时,其波动也更为明显.8相关工作8.1工作流访问控制从Thomas等人[3]提出基于任务授权的概念开始,工作流访问控制研究已有超过20年的历史.有关研究主要集中在授权机制设计[3,18-20]、约束表达能力与描述语言[18,22]、约束冲突与冗余分析[16,23]等方面,较少考虑访问控制对资源分配的影响.Bertino的模型最早涉及WS相关问题,后经更多研究者工作的推动,近来Crampton在WS问题上取得了显著的成果,下面择要进行介绍.1999年,Bertino等人[16]提出了一种基于规则的约束描述语言,包含来自用户、步骤和角色等集合Page12的常/变量,以及反映它们之间关系的多种谓词,可以描述规划、执行阶段分别检测的静态、动态约束以及需要两个阶段共同检测的混合约束.在该语言中,通常的授权和约束都可以表达为规则.利用形如user(u,s)←的规则可以描述授权;cannot_dou(u,s)←must_executeu(u,s)可以描述互斥约束;must_executeu(u,s)←可以描述资源分配.将WS(≠)相应的约束和授权表达为一组规则之后,所谓用户规划过程将生成与规则基一致的所有资源分配,并利用启发式规则优化其排序.根据其规则一致性标准,这些资源分配就是WS(≠)的所有解.用户规划对O((|R|·|Umax(R)|·|Nact(S)|)|S|)种可能进行一致性验证,本质上是一个穷举搜索过程,其中R是角色集,Umax(R)是单个角色的最大用户数,Nact(S)是单个步骤在工作流结构中的出现数.通常用户有一到多种角色,|R|·|Umax(R)||U|,而每个步骤只有一次出现(不同出现看作不同步骤),|Nact(S)|=1.因此,用他们的算法求WS(≠)的所有解,进而统计其个数,所需时间不低于O(|U||S|),高于本文的结果.2003年,Atluri等人[24]将上述方法用于工作流委托授权中的可满足性问题.他们增加了delegate和volunteer两组谓词,将委托和受托关系也表达为规则.通过角色和用户规划,生成与规则基一致的所有资源分配.然而,他们只是扩展了Bertino方法的应用范围,并未改进规划算法及其性能.2008年,Crampton等人[17]在讨论委托对资源分配的影响时,给出了工作流可满足性的判定算法.该?WS算法穷举搜索整个解空间,对于只考虑互斥约束的情形,时间为O(|U||S||S|2),高于本文结果.2010年,Wang等人[5]证明只考虑职责分离的WS可以在O(|S||S|+1|C|)时间内解决.由于对授权用户数超过|S|的步骤,总可以指派恰当的用户避免与其它步骤冲突,他们只对剩余的步骤进行穷举求解.如果只考虑互斥约束,其时间复杂度为O(|S||S||C|),高于本文的结果.值得注意的是,Wang等人进一步讨论了工作流k-弹性问题,也就是删除任意k个用户后的工作流可满足性.与本文提出的#WS相比,k-弹性可以更精确地衡量工作流在资源失效情况下的鲁棒性.他们证明此问题是NP难的,属于coNPNP(其补问题可以为带喻示NP的非确定性图灵机所判定),但未进行求解.2011年,Basin等人[26]在支持循环和选择路由的工作流中讨论了考虑互斥和绑定约束的可满足性决策问题,并给出了多项式时间的近似算法.绑定约束要求两个步骤必须由同一用户完成,考虑这一约束并不复杂,并且有利于降低问题规模.他们的算法除了缺乏精确性,还依赖于授权用户在步骤之间的均匀分布.2013年,Crampton等人[6]对第4节所述的WS(≠)问题进行了研究,这是目前与本文最为相关的工作.他们通过判定当每个步骤子集由每个用户执行时是否导致违反约束的情况,将WS(≠)归约为集合最大权划分问题.归约过程需要O(2|S|(|C|+|U|))时间,而集合最大权划分可以利用O(2|S|p(|U|))空间,在O(2|S||U|2)时间内解决[12],整体所需时间为O(2|S|(|C|+|U|2)).他们进一步证明,根据颇有影响的指数时间假设[26],该时间的指数阶很难获得明显改进[6].这是迄今关于WS(≠)的最好理论结果.相比他们的工作,通过计数途径进行WS(≠)判定,取得了更好的时间复杂度.本文的#WS(≠)和Crampton的WS(≠)求解方法均需O(2|S|p(|U|))空间,这是它们的主要缺陷.Crampton的方法依赖于Bjorclund有关集合最大权划分的结果,只给出了归约方法.本文不仅基于Bjorclund对集合划分权重和的结果确定了#WS(≠)的时间复杂度,而且通过挖掘问题特征,在集合划分权重和求解框架中提出了新的动态规划递推式,在保持时间复杂度的前提下明显优化了实际执行时间,并通过优化空间利用方式,大幅度降低了动态规划和快速变换部分的空间开销.Crampton使用的归约方法不限制约束类型,且在一定条件下保持时间复杂度,但他们以此为基础,为更多约束类型设计了有针对性的算法,取得了丰富的结果.本文的#WS算法同样可对适度推广的约束类型保持现有时间复杂度.不过,针对多种约束情形的优化,还有待继续研究.8.2工作流资源分配资源分配为工作流各步骤指派执行资源,若进一步给出对执行起/止时间的计划,则称为资源调度.随着网格和云工作流的兴起,步骤的候选资源主要由自动化服务来提供,资源分配问题也称为服务组合.不论以何种形式提出,资源分配始终是工作流管理的核心主题之一.相关研究主要关注成本约束下的性能目标,据此给出优化的资源分配策略,或者给定策略进行性能与成本的分析.成本约束将资源分配映射为某种Page13业务成本,例如工资、处理时间等等,并对其加以限制.而性能是面向应用或系统的优化目标.应用性能为用户所关注,在面向服务体系中也称为服务质量(QualityofService,QoS),例如平均或总处理时间、处理时间波动性、执行成功率等.系统性能聚焦于内部机制的合理性,例如资源利用率、系统吞吐量、能量耗费等.成本约束和性能目标统称为分配准则,两者并无绝对的分别.不同的成本和性能指标选择与组合方式,形成了不同的资源分配需求.分配准则从需求角度提出,而体系结构可能对其计算方式产生影响.例如在云环境中,服务价格计费可以基于虚拟机实例数量、虚拟机执行时间单元数或一定的计费周期,步骤执行、数据传输、数据存储的计费方式及其对工作流单次执行价格的影响程度也不相同,并且公有云、私有云和混合云有着不同的计费模型[27].在应用性能的优化方面,例如Zeng等人[28]对状态图表示的工作流,将处理时间、价格、可用性和声誉等QoS指标加权归一作为优化目标,并建立关于截至期限、价格、声誉、执行成功率和可用性等指标的全局性约束,基于混合整数规划方法进行求解,不但为工作流每个步骤选定执行服务,而且可以求出其预期开始时间;Jia等人[29]对有向无环图(DirectedAcyclicGraph,DAG)表示的工作流,以截止时间约束下执行成本为优化目标进行资源分配,方法是通过步骤聚合简化过程结构,并将截至期限约束分解到各聚合步骤,然后在聚合步骤上进行Markov决策,求出其中每个步骤的执行服务及其时间槽;于炯等人[30]以DAG过程结构为基础,对关键和非关键路径总执行时间的差异情形进行分类,据此设计资源分配算法,平衡了案例执行成功率与算法自身的效率;Alrifai等人[31]改进了Zeng的方法,将每个步骤的候选服务按其QoS值划分为若干等级,利用混合整数规划将全局性约束分解到每个步骤,然后在不违反局部约束的前提下根据局部QoS进行服务选择,可以快速找到全局次优解;Abrishami等人[32]对云环境中的DAG表示的科学工作流,以截至期限约束下的价格最小为目标进行优化资源分配,主要方法是通过关键路径分析将截至期限分解到每个步骤,在此前提下为每个步骤选择价格最低的服务,其特点是考虑了服务切换引起的数据传递延迟以及云服务计费按一定时间单位取整造成的影响;等等.在系统性能的优化方面,例如Bittencourt等人[33]对共享同一组资源的多工作流调度问题进行研究,实现了最小完成时间下的最大公平性;田国忠等人[34]研究了多个具有截止期限约束的工作流共享资源调度的问题,在最大化多工作流吞吐量的同时,尽可能降低了执行费用;等等.在给定策略的性能与成本分析方面,例如Eder等人[35]通过对路由选择可能性的分析得出案例可能执行路径的分布,并根据步骤的执行时间计算总体执行时间的分布;刘胜等人[36]对基于4种模式组合的过程结构,在案例到达间隔和资源服务时间服从负指数分布的情况下,对先来先服务的资源调度策略进行性能分析,得出了案例执行时间的分布;等等.这些研究所考虑的分配准则首先是时序相关的,例如总执行时间或截止期限是占据支配地位的指标,通常还需要根据价格、可用性、执行成功率、声誉等其它指标进行整体优化.在不同的研究中,这些指标可能被建模为柔性的优化目标,或者刚性的约束[27].然而,作为一种具有刚性特点的资源分配准则,安全因素所受到的重视还很不够[27,37].现有少量研究涉及域间信任,例如文献[38]定义了处理不可移动数据的不可移动步骤,要求其只能在特定数据中心边界内执行,文献[39]允许有一定安全级要求的步骤在公有云上执行,或者消息传递安全性,例如文献[40]研究了服务组合的消息签名与加密完整性,等等.但是,未见考虑执行资源访问控制约束的工作.9结论与未来工作WS是工作流访问控制的基本问题,现有工作主要局限于其决策问题,本文提出了其计数问题,分析了该问题的研究意义和应用价值.对于只考虑互斥约束的WS计数问题,即#WS(≠),本文基于集合划分权重和的结果证明其存在O(2|S||U|)时间的算法,表明此问题固定参数可解,对任意固定的|S|,可在关于|U|的线性时间内解决.随后,本文在基于赋权集容斥原理与快速ζ变换的集合划分权重和求解方法中提出了一种有利于快速剪枝的动态规划递推式,并对此方法的空间利用情况进行系统优化,由此提出另一种O(2|S||U|)时间的#WS(≠)算法.实验表明,相对于改进前,执行时间平均降低了56%,空间占用平均降低了84%,而可求解的问题规模提高了21%.由于对应的决策问题,即WS(≠),时间复杂度为O(2|S|(|C|+|U|2)),所以本文算法也降低了WS(≠)判定的时间复杂度.实验表明,相对于该WS(≠)算法,本文算法的执行时间平均降Page14低了93%,空间占用平均降低了87%,而可求解的问题规模提高了44%.除为WS(≠)判定提供了当前时间复杂度最低的算法,本文的#WS(≠)算法可为工作流抗资源失效鲁棒性的验证提供新的手段.作为下一步工作,我们将对更多约束类型的#WS进行研究.致谢感谢匿名评审人对初稿提出了严格而富有帮助的意见,使本文在研究程度上得以深化,组织表达也更为清晰!
