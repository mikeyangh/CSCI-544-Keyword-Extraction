Page1一种提高时序安全属性静态检测实用性的方法霍玮1)李丰1),2)丁兆伟1)桑春雷1),2)张兆庆1)冯晓兵1)1)(中国科学院计算技术研究所计算机体系结构国家重点实验室北京100190)2)(中国科学院研究生院北京100049)摘要程序时序安全属性可以用有限状态自动机(FSM)来描述,对该属性的静态检测是当前研究的热点之一.该文提出了FSM切片技术,以需求驱动的模式抽取出关于时序安全属性等价的程序切片.该切片使检测规模减小、程序结构简化,因而减小了检测中组合爆炸情形出现的机会,最终使时序安全属性的静态检测在准确性和可伸缩性上都得到了提高.实验表明,FSM切片可以使Saturn的可伸缩性平均提高到原来的6.34倍,使Fastcheck的准确性平均提高到原来的1.20倍.关键词有限状态自动机;时序安全属性;切片技术;程序静态检测;F-衡量1引言当今软件系统已经逐渐深入到社会的各个领域,软件的正确性问题得到人们的广泛关注,成为一个研究的热点.使用自动化的程序静态检测工具辅助程序开发是提高软件正确性的有效方法之一.当前,对于程序静态检测工具的研究取得了很大的进Page2展,产生了很多优秀的成果.根据其使用的典型技术不同,可以将这些工具粗略的分为三大类:扩展静态检测器(extendedstaticchecker)[1-2]、软件模型检测器(softwaremodelchecker)[3-4]和程序静态分析器(programstaticanalyzer)[5-6].程序的时序安全属性具有非常广泛的描述能力,可以描述计算机软硬件资源的安全使用规则(比如内存、文件或锁等),也可以描述软件系统中的编程规则[3,7]等.所以,对于程序时序安全属性的检测是程序静态检测领域的重要研究课题.通常,可以使用有限状态自动机(FSM)来描述程序的时序安全属性.定义1(有限状态自动机).M是一个五元组:M=(Q,Σ,δ,q0,F).其中,Q为状态的非空有限集合;Σ是动作集合;δ是状态转移函数,δ:Q×Σ→Q;q0是M的初始状态;F是M的终止状态集合.图1和图2分别给出了使用有限状态自动机描述的关于文件操作规则和内存操作规则的时序安全属性(双线框状态表示终止状态).目前已有很多静态检测工具可以检测程序的时序安全属性,其中具有代表性的有软件模型检测器SLAM[3]、BLAST[4];程序静态分析器Saturn[5]、Fastcheck[6]、ESP[8]、MYGCC[9]等等.虽然这些工具使用的技术不同,但一般从检测的准确性(precision)和可伸缩性(scalability)两方面来衡量它们的水平.实际上,检测的准确性和可伸缩性是一对矛盾.为了获得更高的检测准确性,就需要使用更高精度的程序分析,这就会增加分析的时空开销,在最坏情况下可能导致指数级的增加,使得检测的可伸缩性受到很大限制.所以上述工具在准确性和可伸缩性上进行了不同的权衡.然而,由于工具在检测的过程中没有充分利用程序信息,它们在准确性和可伸缩性上都存在提高的空间.对于BLAST、Saturn等高准确性的检测工具,它们在使用高精度的程序分析技术(比如路径敏感分析)时,由于没有利用检测的相关性而导致分析的时空开销代价过高,使得它们的可伸缩性受到很大影响;对于Fastcheck、MYGCC等高可伸缩性的检测工具,它们在追求高效、高可伸缩时,由于不“安全”地使用保守的数据流信息,甚至没有使用数据流信息,从而降低了它们的准确性.针对以上问题,本文提出了FSM切片技术,使得程序时序安全属性的静态检测在准确性和可伸缩性两方面都得到了显著提高,并获得了更好的平衡.不同于传统的切片标准,该技术使用有限状态自动机作为切片标准,以需求驱动的模式利用切片技术提取出部分原程序,使得切片后程序与原程序关于时序安全属性具有语义等价性.由于程序切片减小了待检测程序的规模,从而提高了检测的可伸缩性;更重要的是,程序切片简化了待检测程序的结构,特别是降低了复杂程序结构对程序分析复杂度的影响,减少了检测中组合爆炸情形出现的机会,因而提高了分析的精度,最终提高了检测的准确性.实验表明,使用FSM切片技术可以使Saturn的可伸缩性在最好情况下提高到原来的1314倍,平均提高到原来的6.34倍;使Fastcheck的准确性在最好情况下提高到原来的2.19倍,平均提高到原来的1.20倍.本文第2节给出研究的动机和示例;第3节给出FSM切片的定义和计算FSM切片的算法;第4节讨论FSM切片的实现要点;第5节讨论静态检测中准确性和可伸缩性的衡量标准;第6节对FSM切片的作用进行实验;最后是结论以及下一步的工作计划.2研究动机及示例下面通过分析典型程序静态检测工具检测的工作过程,讨论这些工具存在的问题,并展示FSM切片技术在提高检测准确性和可伸缩性上的作用.考虑使用Saturn对图3(a)中代码进行内存时序安全属性检测.该段代码来源于SPECCPU2000中的ammp并稍作简化.Saturn的工作流程是:首先对源程序进行建模;然后对编码后的程序进行路Page3径敏感的指针分析,并将结果记录在带路径信息的位置集合①中;最后根据检测目标文件指定的步骤完成检测.其中后两个步骤占检测总时间的90%以上.这段大约1067行的程序(包含空行),含有大量的循环和分支语句.由于Saturn在检测含有循环的代码时,会将循环展开有限次,然后再简化成分支语句进行检测.所以根据我们的统计,这段代码大约含有4亿多条程序路径.由于路径数量太过巨大,使得Saturn中路径敏感的指针分析和对错误路径的符号执行这两步都无法在设定的时间和空间内(100s处理器时间和512MB内存)完成,最终使得Saturn图3代码示例考虑使用Fastcheck检测图3(b)中代码.该工具使用基于值流分析的检测技术.它首先利用定值引用分析给全程序建立值流图,然后使用上下文敏感的切片技术计算出值流切片并对该切片进行(部分)路径可行性分析来完成检测.但是为了提高可伸缩性,它的定值引用分析是基于流不敏感、上下文不敏感指针分析(Steensgaard指针分析)的结果,在这样建立的值流图中可能会存在伪值流关系(即定值引用关系与控制流关系不符),将导致检测的准确性降低.对于该段代码,语句10使得指针分析分析出指针f和g别名,于是在值流图((b)图下半部,节点中标出其对应的语句号)中使用一个节点表示(阴影节点).由于语句9对该节点代表的变量进行定值而语句3对该节点代表的变量进行引用,这样在值流图上会存在由语句9到语句3的值流关系,这个值流关系是违反了控制流顺序的伪值流关系.但它的无法完成对该段代码的检测.实际上程序中大部分的循环和分支语句并不影响对该段代码进行时序安全属性静态检测的结果,如图中循环和分支语句所示,所以可以使用FSM切片技术简化该段代码,只保留与检测相关的语句.这样经过切片预处理后,该段代码只含有约26万条程序路径,路径减少了99.9%以上.使用Saturn检测切片后的程序,不仅可以完成检测,而且能够准确地报告出这段代码关于内存的时序安全属性是正确的.可见,FSM切片技术可以提高Saturn检测时序安全属性的准确性和可伸缩性.1.FILEf;2.voidmyclose(){3.fclose(f);4.}5.voidmain(){6.FILEg;7.f=fopen();8.myclose();9.g=fopen();10.f=g;11.}存在使得Fastcheck认为语句9打开的文件在程序结束前由语句3关闭,从而产生漏报.使用切片预处理后,语句10由于与检测语句9打开的文件是否关闭无关而被切除,这样消除了由于f和g别名带来的伪值流影响,使得Fastcheck可以正确地检测出语句9打开的文件指针在程序结束前泄漏,从而在提高Fastcheck的可伸缩性的同时提高了Fast-check的准确性.考虑使用BLAST检测图3(c)中的代码.该代码是BLAST相关文章中常用示例.BLAST是典型的软件模型检测器,它使用的是反例制导的抽象精化(counter-exampleguidedabstractionrefinement)检测机制.该机制的主要流程是:首先根据初始谓词对程序进行抽象(即谓词抽象),该步骤需要定理证①GuardedlocationsetsPage4明器的支持,是检测过程中主要的时间开销之一;然后在抽象的程序上(一般为布尔程序)检测程序的时序安全属性.如果没有发现错误则证明原程序正确;如果发现错误,则根据抽象程序中的错误路径在原程序上找到对应的程序路径,并且判断该路径的可行性,这个步骤需要符号执行,也是检测过程中主要的时间开销之一.如果该路径可行,则报告该错误;如果路径不可行,则根据不可行的原因修改谓词,然后再进入谓词抽象阶段,重复上述过程.基于这个机制,BLAST在检测图3(c)中代码时,为了发现在语句2中条件为假的情况下语句10是否可达,需要依次地发现1000个谓词{i==0},{i==1},{i==2},…,{i==999}(即进行谓词抽象1000次),直到当{i1000}时才能在抽象程序中发现一条可以到达语句10的可能路径.找到该路径在原程序中对应的路径〈2,4,5,6,7,…5,6,长度为3005的路径上进行符号执行,计算得到路径条件为{a0∧a<0},所以这条路径不可行,语句10在语句2中条件为假时不可达.然而从需求驱动的角度考虑,语句10是否可达直接取决于语句9中条件是否为真.而语句9对语句4、5、6、7既没有控制依赖,也没有数据依赖,所以语句9中条件的值与语句4、5、6、7无关.这正是切片技术可以给出的结论.所以经切片预处理后,BLAST对语句1、2、3、9、10、11组成的程序切片进行验证可以得到相同的结论,但是可以避免上述步骤,从而在保持BLAST检测准确性的同时,提高它的可伸缩性.综上可见,使用切片技术对程序进行“预处理”后,不仅仅使得程序的规模减少,而且使得检测工具可以仅对与检测目标相关的程序部分进行重量级的程序分析,最大程度地避免无关程序部分特别是可能导致组合爆炸的程序成分(如分支、上下文等)对程序分析时空开销的影响,从而有效地缓和了分析精度和效率的矛盾,使得检测工具可以达到更高的准确性和可伸缩性.3FSM切片FSM切片技术是提高程序静态检测准确性和可伸缩性的一个关键技术.相对于传统切片技术中使用给定语句的变量作为切片标准,FSM切片技术使用描述程序时序安全属性的有限状态自动机作为切片标准.同时,与传统程序切片应用于程序调试、测试或理解等不同,FSM切片是服务于程序时序安全属性的静态检测.所以,FSM切片利用了传统切片并与领域知识相结合,是切片技术的拓广和新应用.这种新应用也缓解了切片技术的主要问题:切片程序往往过大而无法应用于人工分析.因为FSM切片是服务于自动的程序静态检测,所以FSM切片对于原程序任何的减少都直接导致检测时间的减少和可伸缩性的提高.并且由于切掉了与FSM无关的程序部分,往往还简化了程序结构和复杂的变量关系,从而有利于提高检测的准确性.本文首先给出FSM切片的定义,然后讨论计算FSM切片的算法.3.1FSM切片的定义定义2(FSM切片).程序P的一个FSM切片S(fsm)是一个程序P,其中fsm是给定的时序安全属性描述,并且:(1)P是从P中删除0条或多条语句获得;(2)对于fsm描述的时序安全属性,P是P的安全抽象.定义3(安全抽象).给定程序的一个时序安全属性p,用有限状态自动机M=(Q,Σ,δ,q0,F)描述,称程序P是P的安全抽象,(1)如果P中存在路径path=s1,s2,…,sn,使得M终止于错误状态f∈F,则在P中存在路径path=s1,s2,…,sm使得M的同一实例终止于相同的错误状态;并且设path在P中的路径条件为pc,path在P中的路径条件为pc,则pcpc.(2)如果P中存在路径path=s1,s2,…,sn,使得M终止于正常状态f∈F,则在P中存在路径path=s1,s2,…,sm使得M的同一实例终止于相同的正常状态;并且设path在P中的路径条件为pc,path在P中的路径条件为pc,则pcpc.这里的路径条件是指:对于给定的程序路径p,通过符号执行得到它的一组关于变量初始值的约束,并且p是可行的,当且仅当路径条件可被满足.这里使用有限状态自动机M的实例这个概念,是因为对于给定的有限状态自动机,一个程序中通常存在多组该自动机的动作语句,为保证检测算法的正确和叙述方便,我们称每组动作语句构成该自动机的一个实例.比如给定的时序安全属性为文件操作,则我们称程序中所有与该自动机相关的文件操作函数为动作语句.因为程序中每个被操作的文件都应该遵循该安全属性,所以我们首先需要将这些动作语句按照其操作的文件对象进行分组(每一组动作Page5语句是关于同一个文件的操作),然后对每组动作语句所代表的不同文件操作自动机实例分别进行检测.安全抽象指出了如果原程序中存在违反时序安全属性的错误,则该错误也存在于抽象后的程序中;如果原程序中的操作遵守时序安全属性,则抽象后的程序也遵守该属性.3.2FSM切片的算法FSM切片的算法是以文献[11]中上下文敏感的过程间切片算法为基础设计的.因为相比于传统的切片技术,FSM切片的切片标准不是确定程序位置上的程序变量而是描述时序安全属性的有限状态自动机,所以在进行FSM切片的过程中首先需要进行有限状态自动机的实例化.然后对于每一个自动机实例,以其中的动作语句作为切片标准,使用上下文敏感的过程间切片算法,从而得到这个自动机实例的FSM切片.3.2.1实例化有限状态自动机实例化有限状态自动机,即根据给定有限状态自动机的状态迁移函数找到程序中的所有动作语句并进行分组.算法1给出了实例化的算法.算法1.实例化有限状态自动机.procedureInstFsm(P,M)n←1E[1..m]←//cleararrayEforalle:q0→actionq∈δdoendforfori←1,ndoendforreturnEendprocedure该算法分为两步,第1步确定实例化标准.对于描述计算机系统软硬件资源操作的有限状态自动机,它的状态迁移函数在程序中对应的动作语句一般是函数调用,并且该函数操作的资源一般使用指针变量来代表,所以可以根据指针变量对象作为实例化的标准.为此我们首先确定程序中所有被操作的资源,即在程序中找到与导致初始状态转移的状态迁移函数所匹配的所有动作语句,这些语句中所操作的指针变量就代表所有被操作的资源.我们将这些语句记录并把每一条语句(准确地说是语句所操作的指针变量对象)作为一个实例化的标准.算法1中第1个最外层For循环即完成上述功能.其中Match(st,action)用来判断函数调用st的函数名是否与状态迁移函数action的函数名相同.第2步根据实例化标准完成实例化.我们对于每一个实例化标准,从这个标准开始遍历程序所有语句,如果动作语句所操作的指针变量与该标准所操作的指针变量是别名关系,则它们操作的是同一资源,该语句与实例化标准属于同一个有限状态自动机实例.这样便可完成有限状态自动机的实例化.算法1中第2个最外层For循环即完成上述功能.其中Belong(st,st_set)用来判断函数调用st与集合st_set中的任意函数调用是否操作的是同一资源,即属于同一个有限状态自动机实例;一个数组E中的元素用来记录一个有限状态自动机的实例.3.2.2FSM切片算法2给出了完整的FSM切片过程.算法2主要包含3个步骤.首先对有限状态自动机进行实例化;然后,使用文献[12]中算法建立系统依赖图,再对每一个有限状态自动机实例,依次以每一个动作语句作为切片标准,使用文献[11]中算法(以Inter-Slicing函数代表)进行上下文敏感的过程间切片,并将切片结果合并,计算得到一个有限状态自动机实例的FSM切片.通常,切片的结果只是语句的集合,所以最后还需要使用FSM切片的结果,在原程序中提取出切片结果指示的语句从而得到最终的自动机实例的FSM切片.该算法将原程序的FSM切片结果记录在数组P中,数组中的每一个元素记录的是每一个实例的FSM切片结果.可以证明算法2得到的结果就是FSM切片(见附录).算法2.FSM切片算法.precedureFsmSlicing(P,M)//1.InstantiatetheFSME←InstFsm(P,M)//2.FSMSlicingPage6BuildingSystemDependenceGraphGforPS[1..|I|]←fori←1,|E|doendfor//3.ConstructSlicefori←1,|S|doendforreturnPendprocedure以图3(b)作为示例说明.在实例化阶段,找到文件操作有限状态自动机的实例化标准分别是语句7和语句9.对于语句7,在程序的遍历过程中,找到语句3与其处于同一个实例化标准下(操作同一个文件指针对象),所以语句7和语句3属于有限状态自动机的同一个实例.对于语句9,由于从语句9开始遍历无法到达语句3,所以语句3与语句9不属于同一个有限状态自动机实例.这样,程序中有两个自动机实例{E[1]={3,7},E[2]={9}}.以E[1]作为切片标准进行切片,得到的结果如图4(d1)所示;以E[2]作为切片标准进行切片,得到的结果如图4(d2)所示.4FSM切片实现要点以FSM切片技术为核心,我们在Open64开放源码高级编译系统的基础上实现了一个FSM模型驱动的检测编译框架,称为Fedora.该检测编译框架以编译技术为基础支撑,以FSM切片技术为核心,对输入的C程序检测给定的程序时序安全属性.图5给出了Fedora的总体结构(阴影部分表示对Open64的扩充与改造).Open64①是一个开发源码的编译研究平台,具有良好的程序分析框架,非常适合作为实现检测工具的基础架构.Fedora提供了图形用户接口,使用户可以直观、方便、快速地描述有限状态自动机,提供待检测的时序安全属性.在该框架下,我们与MYGCC进行了集成实验.通过利用图形用户接口描述有限状态自动机,并将该自动机自动地转换成MYGCC能够接受的condate(MYGCC中描述待测性质的格式),可以极大地减少用户负担,这说明Fedora具有很好的易用性.同时,我们改造Open64中的过程间分析框架为全程序分析框架,支持实现流敏感、上下文敏感的过程间分析,能够提高切片的精度,满足FSM切片的需求.在当前的框架上,使用的是Steensgaard的流不敏感、上下文不敏感指针分析,并在构建程序的静态单赋值形式之前进行全程序的副作用分析以精化定值引用信息,建立更精确的静态单赋值形式.在这个以静态单赋值形式为中间表示的全程序分析框架上,我们实现了程序依赖图以及系统依赖图的建①http://www.open64.net/Page7立,并按照算法2实现了FSM切片算法.然后,我们根据FSM切片的结果提取出FSM切片,再使用第三方的检测工具,完成时序安全属性的检测.5可伸缩性和准确性的评价标准本文主要是衡量FSM切片技术对于时序安全属性静态检测可伸缩性和准确性的提高,所以需要确定合理的可伸缩性和准确性的评价标准.5.1可伸缩性评价标准对于可伸缩性的评价,当前主要有两个标准:每秒钟能够检测程序的行数(检测速率,单位千行/s);在合理的时间内能够检测的最大程序规模.对于第2个标准,由于“合理的时间”这种说法很难量化,并且很多工具在检测中可以设定最大的时空开销来强制完成检测(如Saturn),使得其在理论上可以检测任意规模的程序,所以第2个标准并不合理,故本文使用第一个标准来量化评价检测的可伸缩性.5.2准确性评价标准对于准确性的评价,当前主要使用误报率作为衡量标准.然而,当前的程序静态检测工具由于技术上的原因或实现上的原因,一般既不是可靠的(即存在漏报)也不是完备的(即存在误报).所以仅用误报率不能全面客观地评价准确性.本文提出了借鉴信息检索领域中的F-衡量来作为静态检测工具准确性的评价标准.定义4(F-衡量).TP、FP、TN、FN的含义精确率(precision)=|TP|召回率(recall)=|TP|Fβ-衡量(Fβ-measure)=见6.1节.精确率的含义是对于产生的关于程序错误的检测报告中,所包含的程序中真实存在的错误的比例.所以精确率是衡量误报情况的一个指标.召回率的含义是对于程序中真实存在的错误,能够包含在生成的程序错误报告中的比例.可见召回率是衡量漏报情况的一个指标.一个好的检测工具应该具有高精确率和高召回率.但是,通常情况下,精确率和召回率很难同时做到最好.所以评价一个检测工具的准确性,应该能够综合检测的精确率和召回率,使这两个指标达到一个好的平衡.这时,可以使用精确率和召回率的加权的调和平均来作为指标.这就是F-衡量.其中β∈[0,),表明的是召回率比精确率的重要性高的比例.我们认为,检测工具应该尽可能多地发现程序中的真正错误,而用户对误报具有一定的容忍性,也就是召回率要比精确率重要,故基本的要求是β>1.在本文实验中,选取β=4①.6实验6.1实验方法对于时序安全属性,本文选取文件时序安全属性(文件FSM)和内存时序安全属性(内存FSM),如图1和图2所示,检测程序中是否存在文件指针泄露和内存泄露的错误.对于第三方的检测工具,本文选取Fastcheck和Saturn.Fastcheck和Saturn都是代表性的程序静态分析工具,但是两者各具不同的特点,如第2部分所讨论.Fastcheck由康奈尔大学开发,具有高可伸缩性,但由于不安全地使用别名信息、只进行部分的路径敏感分析(不计算路径条件)等而影响了准确性.本文实验中选取的是Fastcheck的最新版本,Fastcheck1.0.Fastcheck内置了检测文件时序安全属性和内存时序安全属性的功能,可以直接进行本实验.Saturn由斯坦福大学开发,由于支持路径敏感的过程间分析而具有很好的检测准确性,但可伸缩性受到较大限制.本文实验中选取的是Saturn的最新版本,Saturn1.1.在使用Saturn检测文件时序安全属性和内存时序安全属性时,需要提供属性描述文件.为此我们在能力范围内反复地手工调整该属性描述文件以尽可能地发挥Saturn的检测能力.本实验的过程如下:对于每一个待测用例,首先分别针对每一个时序安全属性,计算FSM切片(将每个实例的FSM切片结果合并求得原程序的FSM切片),并根据切片结果利用分析工具exceptor(基于Crystal实现②)在原程序中取出FSM切片.在给定时序安全属性和待测用例的情况下,使用Fast-①β=8、β=10,发现当β>4以后,F-衡量的值随β增大变化②Page8check和Saturn分别对原程序和FSM切片进行检测,共得到4个测试报告.这4个报告其实是关于同一个程序检测同一种错误.所以,对每个报告的每一个条目逐一进行人工确认,并将每一个条目划定到以下4类之一:报告是错误且是实际存在的违反时序安全属性的错误(TP),报告是错误但实际是遵守时序安全属性的情况(FP),报告是正确且实际上也是遵守时序安全属性的情况(TN),报告是正确但是实际存在违反时序安全属性的错误(FN).由于Fastcheck和Saturn只能检测C程序,所以我们根据程序规模,选取了SPECCPU2000、SPECCPU2006①中的部分C程序(包括浮点程序和定点程序)和OpenSSH②中部分程序.这些测试用例都是源自现实中广泛使用的应用程序,覆盖了相当广泛的应用领域,能够体现不同的应用程序特征,代码规模从几千行到几十万行,能够全面客观地衡量FSM切片和Fedora的有效性.6.2实验环境本实验的所有实验数据均是在同一台服务器上测得.该服务器是一台双处理器的机器,每个处理器都是IntelXeon(R)E5430,含有4个处理器核,主频为2.66GHz,每个核私有64KB的一级Cache,每两个核共享6MB的二级Cache,并支持64位指令集.该服务器具有16GB的内存和1T的硬盘,预装有64位的RedHat企业版Linux5.2,内核版本2.6.18.Fastcheck的运行选项是其默认的选项;Saturn的运行选项也是其默认选项,对于每个函数的处理,限制使用512MB的内存和100s的处理器时间.测试用例的简单描述如表1所述.用例名称规模/千行sftpssh-agentssh-rand-helper1.5175.vpr177.mesa188.ammp253.perlbmk254.gap300.twolf403.gcc433.milc445.gobmk458.sjeng482.sphinx3表2Fastcheck可伸缩性实验结果286.1(278.5)0.7(0.3)0.1(0.1)0.3(0.1)3.1(1.2)2.3(2.0)1.7(0.6)8.1(0.9)4.8(2.5)117.4(59.6)3.1(0.7)8.4(4.0)6.2(4.3)3.6(1.1)用例名称描述用例名称描述OpenSSH系列远程访问服务器175.vprFPGA线路布局403.gccC程序编译器177.mesa3维图形库433.milc量子色动力学188.ammp计算化学445.gobmk人工智能程序GO253.perlbmkPerl程序解释器458.sjeng国际象棋计算254.gap聚合理论解释器482.sphinx3语音识别6.3实验结果6.3.1可伸缩性表2和表3分别给出了使用FSM切片对于Fastcheck和Saturn进行可伸缩性实验的结果.对于每个工具检测的每个时序安全属性,分别给出了检测原程序的时间(第3列和第5列)和检测FSM切片的时间(第4列和第6列,该时间已包含计算FSM切片的时间,并在括号内给出).表中黑体表示最好情况.这样我们就可以根据程序的规模来计算每次检测的检测速率.FSM切片对于Fastcheck和Saturn的可伸缩性提高如图6和图7所示.两图中Y轴表示的是FSM切片使得可伸缩性提高的比例(将原程序的检测速率进行归一化处理).①②Page9用例名称规模/千行sftpssh-agentssh-rand-helper1.5175.vpr177.mesa188.ammp253.perlbmk254.gap300.twolf433.milc445.gobmk458.sjeng482.sphinx3表3Saturn可伸缩性实验结果66.4(0.3)0.1(0.1)4.2(0.1)394.3(1.2)5.1(2.0)697.9(0.6)55495(281.5)87912(0.9)2392(2.5)190.8(0.7)1807(4.0)1318(4.3)834.2(1.1)对于177.mesa,文件FSM切片可以使Fastcheck的可伸缩性提升高达原来的5.62倍,尤其使Saturn的可伸缩性提升高达原来的1314倍.这主要因为mesa的文件FSM切片仅为原程序的0.56%.平均而言,文件FSM切片使得Fastcheck可伸缩性提高到原来的1.48倍,使Saturn的可伸缩性提高到原来的6.34倍.在内存时序安全属性的实验中,内存FSM切片可以使Fastcheck的可伸缩性提升高达原来的4.82倍,使Saturn的可伸缩性提升高达原来的4.09倍.平均而言,内存FSM切片使得Fastcheck的可伸缩性提高到原来的1.23倍,使得Saturn的可伸缩性提高到原来的1.88倍.6.3.2准确性对于文件时序安全属性和内存时序安全属性,我们使用Fastcheck和Saturn分别检测原程序和FSM切片,并对所得到的报告逐一进行确认和分类.我们对我们能够确定的检测报告(排除复杂测试用例和FSM切片算法的实现对报告确认的干扰)分别列入表4和表5中,同时给出了根据5.3节的公式计算出的F-衡量的值.其中黑体部分表示FSM切片可以提高检测准确性的测试用例.FSM切片对于Fastcheck和Saturn检测文件时序安全属性和内存时序安全属性准确性的提高分别如图8和图9所示.两图中Y轴表示的是FSM切片对于准确性提高的比例(将原程序的F-衡量值进行归一化处理).图8FSM切片对检测文件时序安全属性准确性的提高图9FSM切片对检测内存时序安全属性准确性的提高Page10表4文件时序安全属性检测结果例子名称ssh-rand-helper10001.0010001.0010001.0010001.00177.mesa20201.0020201.0020201.0020201.00254.gap300.twolf302901.00302901.00302901.00302901.00445.gobmk20401.0020401.0020401.0020401.00458.sjeng20101.0020101.0020101.0020101.00464.h264ref10640.2120630.4140610.8140610.81482.sphinx3402070.38902020.83602050.56902020.83表5内存时序安全属性检测结果例子名称sftpssh-agent10220.3520210.6810220.3530201.00175.vpr32053720.3234053700.3410374610.9910374610.99188.ammp300430.91310420.94290440.89320410.97433.milc20027350.3822225330.415122540.935122540.93445.gobmk809140.38909130.42200920.91220901.00检测程序,所以它的优势就在于可伸缩性比较好;相反,Saturn由于使用路径敏感的分析,可伸缩性则受到了限制.FSM切片不仅减少了程序规模,而且简化了程序结构和复杂的变量关系,特别是减少了可能导致程序分析指数爆炸的程序成分比如分支语句,这样就提高了Saturn中的路径敏感的程序分析效率,这加速了FSM切片对于Saturn可伸缩性的改善.6.4.2准确性无论是文件FSM切片,还是内存FSM切片,都可以使Fastcheck检测时序安全属性准确性提高.这主要是因为召回率的提高,而召回率提高的原因,主要是FSM切片克服了Fastcheck中不“安全”技巧的影响.FSM切片去掉了程序中与检测FSM无关的部分,降低了程序的复杂性,可以使指针分析得到更精确的结果以间接地消除部分不“安全”的使用,如图3(b)代码所示,从而使漏报减少,相对召回率提高.无论是文件FSM切片,还是内存FSM切片,都可以使Saturn检测时序安全属性的准确性提高.准确性的提高同样也主要来源于召回率的提高,而召回率提高的原因,主要是FSM切片可以提高Saturn中指针分析的效率.值得指出的是,因为Saturn使用的路径敏感的指针分析可能导致组合爆炸问题,所以Saturn中设定了分析每个函数所可以使用的最大内存量和最长处理器用时,使得发生组合爆炸的情况下,检测仍得以进行.对于测试用例中从图8中可以看出,文件FSM切片没有使任何一个工具的检测准确性降低.对于Fastcheck,文件FSM切片可以使其准确性提升高达原来的2.19倍,平均提高到原来的1.20倍;对于Saturn,文件FSM切片可以使其准确性提升高达原来的1.48倍,平均提高到原来的1.05倍.从图9中可以看出,内存FSM切片没有使任何一个工具的检测准确性降低.对于Fastcheck,内存FSM切片可以使其准确性提升高达原来的1.96倍,平均提高到原来的1.15倍;对于Saturn,内存FSM切片可以使其准确性提升高达原来的2.88倍,平均提高到原来的1.24倍.6.4讨论6.4.1可伸缩性从横向上看,文件FSM切片对于可伸缩性的提高要明显好于内存FSM切片,这两个工具都体现出了这一特点.这是因为,通常情况下,程序中与操作文件相关的语句要明显少于与操作内存相关的语句,所以文件FSM切片要明显小于内存FSM切片,相应的,文件FSM切片对于检测时间的减小也要大于内存FSM切片对于检测时间的减小,这样文件FSM切片对于可伸缩性的改善要好于内存FSM切片.从纵向上看,FSM切片对于Saturn的可伸缩性改善要明显优于对Fastcheck的改善,实验的两个时序安全属性都体现了这一点.这与工具本身的特点相关.Fastcheck的设计理念就是尽可能高效地TPFPTNFNF4TPFPTNFNF4Page11的大函数,Saturn很难在这些规定值内完成预定分析,从而导致漏报.而FSM切片有效地减小了函数规模,简化了程序结构,降低了程序复杂性,使得Saturn可以在规定值内完成预定分析,如图3(a)中代码所示,使得召回率提高.7结论及下一步工作计划软件正确性问题,随着信息技术的发展,越来越多地得到了人们的广泛重视.在软件开发中使用程序静态检测工具是一种有效的提高软件正确性的方法.当前有代表性的静态检测工具由于使用的技术不同而在检测的准确性和可伸缩性上进行不同的权衡.然而,这些工具在检测过程中,没有以检测需求为驱动,没能充分利用已有程序信息,使得它们的准确性和可伸缩性都受到了不同程度的损失.本文在分析和总结这些典型检测工具工作特点的基础上,针对时序安全属性的检测,提出了FSM切片技术.不同于传统的切片标准,该技术使用有限状态自动机作为切片标准,以需求驱动的模式利用切片技术提取出部分原程序,在减少程序规模的基础上简化了程序成分和复杂变量关系,是使检测的准确性和可伸缩性获得更好平衡的关键技术.本文基于传统上下文敏感的过程间切片算法,给出了FSM切片算法,并以该算法为核心实现了Fedora检测编译框架原型系统.实验表明,FSM切片可以使Saturn和Fastcheck检测的可伸缩性和准确性都取得明显提高.对于文件时序安全属性的FSM切片,可以使Saturn的可伸缩性平均提高到原来的6.34倍,准确性平均提高到原来的1.05倍;可以使Fastcheck的可伸缩性平均提高到原来的1.48倍,准确性平均提高到原来的1.20倍.对于内存时序安全属性的FSM切片,可以使Saturn的可伸缩性平均提高到原来的1.88倍,准确性平均提高到原来的1.24倍;可以使Fastcheck的可伸缩性平均提高到原来的1.23倍,准确性平均提高到原来的1.15倍.对于FSM切片技术,我们的进一步工作包括:一方面是改进现有切片算法,进一步提高切片的效率和准确性;另一方面是在切片的过程中,进一步使用有限状态自动机所描述的语义,构造不确定状态切片.不确定状态切片是在现有FSM切片的基础上,将确定能够导致有限状态自动机转移到正确终止状态或错误终止状态的语句进一步切除,只保留导致有限状态自动机进行不确定转移的程序成分,这样可以进一步减少FSM切片规模,使得静态检测在可伸缩性和准确性上得到更好的改善.
