Page1组合测试故障定位的关系树模型钮鑫涛1)聂长海1)CHANAlvin2)1)(南京大学计算机软件新技术国家重点实验室南京210023)2)(香港理工大学电子计算学系香港)摘要组合测试是一种重要的软件测试方法,该方法通常采用覆盖表作为测试用例集,适用于检测系统中由特定配置组合引发的故障.覆盖表中的一条引发系统故障的测试用例含有多个配置组合,如何确定其中哪个或哪几个配置组合引发系统故障有助于系统开发人员检测出故障原因并做出改进.目前已有一些研究尝试解决上述问题,然而这些方法都没有对待定元组关系进行深入的研究与分析,因此定位过程代价很大并且定位结果也并不完整.文中构建了一个待定元组关系树(TupleRelationshipTree,TRT)来描述所有待定元组的关系,利用TRT可以减少生成附加测试用例的数量,并且由于TRT给出全部待定元组的清晰视图,可以避免漏掉分析可能的待定元组,特别是有重叠部分的故障元组.基于TRT,我们提出了4种选择策略来辅助故障定位.系统的实验表明:其中的路径方法可以以较高的效率得到一个比已有方法更加完整的故障定位结果.关键词组合测试;故障定位;待定元组关系树;有重叠部分元组;选择策略;软件测试1引言组合测试旨在发现由系统配置组合,输入组合等各种参数组合交互引发的故障.在该测试方法研究领域,有两个关键问题:(1)如何构造尽可能小的测试用例集来覆盖尽可能多的交互组合;(2)在一条测试用例触发故障后如何定位出引发故障的配置组合.目前已有大量的文献对问题1做出了深入的研究与分析,但对于问题2,现有研究仍有很多不足[1].假设系统受到n个参数的影响,而1条测试用例就是这n个参数的具体配置实例.如1个网页应用可能受到操作系统、网络带宽、浏览器、音频解码器的影响(每个参数的可选值如表1),那么1条测试用例就是这4个参数的具体取值实例,如(Windows,200MB,Chrome,AC3Filter).表1一个待测系统SUT(SystemUnderTest)配置表实例操作系统网络带宽浏览器解码器Windows50MBChromeAC3FilterMacOS200MBFirefoxMPEGUbuntu1GBOperaAC-3ACM如果要对该系统进行充分测试,需要34=81条测试用例,当参数个数n很大,参数可选值很多时,充分测试所需要的测试用例数成几何级数趋势增长,实际应用是不可行的,这种情况下测试用例的选择显得非常重要.组合测试追求用最少的测试用例实现对各种参数组合的覆盖,该测试方法使用覆盖表作为测试用例集,能够检测到系统中由特定参数交互而引发的故障.然而虽然利用覆盖表测试能够检测系统中是否存在这种类型的故障,但却无法诊断失败测试用例中具体哪一个或哪几个配置组合是引发故障的原因.事实上,执行测试时若有一条这样的测试用例出错,将会有2n-1(n是此SUT受影响参数的个数)个可能的参数配置组合是触发故障的原因.比如对于出错的测试用例(MacOS,50MB,Chrome,AC-3ACM),可能的故障组合有:[MacOS,50MB,Chrome,AC-3ACM]、[MacOS,50MB,Chrome,-]、[MacOS,50MB,-,AC-3ACM]、[MacOS,-,Chrome,AC-3ACM]、[-,50MB,Chrome,AC-3ACM]、[MacOS,50MB,-,-]、[MacOS,-,Chrome,-]、[MacOS,-,-,AC-3ACM]、[-,50MB,Chrome,-]、[-,50MB,-,AC-3ACM]、[-,-,Chrome,AC-3ACM]、[MacOS,-,-,-]、[-,50MB,-,-]、[-,-,Chrome,-]、[-,-,-,AC-3ACM],一共有24-1=15个.诊断出其中哪一个或哪几个配置组合触发了系统故障有利于查出系统的错误原因,因为这将会大大减少待测系统所需要检测的范围.解决此问题的最简单的方法是穷举,逐个分析判断2n-1中每个组合是否为故障源,很容易知道其算法复杂度为O(2n),在参数个数很大的情况下是不可行的.通过仔细观察1条测试用例对应的配置组合,我们可以发现以下两个规律:(1)如果1个配置组合已确定为故障源,那么所有包含此配置组合的配置组合必然是故障源(比如若[-,-,Chrome,-]是故障源,那么[-,50MB,Chrome,-]、[-,-,Chrome,AC-3ACM]等包含[-,-,Chrome,-]的配置组合必然是故障源);(2)如果一个配置组合已确定为非故障源,那么此组合包含的所有配置组合必然是非故障源(比如若[-,50MB,Chrome,-]是非故障源,那么[-,-,Chrome,-]、[-,50MB,-,-]两个配置组合必然是非故障源).这意味着我们不必一一检查1条错误测试用例对应的每个配置组合是否是引发故障的根源.因为只要找出其中一批配置组合,并且确定这批配置组合中每一个组合是否是引发故障的根源,就可以通过以上两条规律确定相关联(即包含和被包含关系)的配置组合是否为故障源.而只要合理的选择确定其中的一批配置组合,我们就可以确定一条出错测试用例所有的配置组合中的每一个配置组合是否为故障源.在此之前,人们已经提出了一些方法,如Nie和Leung[2]逐个替换法、Ghandehari等人[3]利用元组可疑度排序和Zhang和Zhang[4]FIC搜索等,然而这些方法都没有很好的利用组合配置之间的关联,定位代价往往很大且定位结果不是很精确.对于一条错误的测试用例,为了能够找到规模尽可能小的一批配置组合并确定这些组合是否是故障源,从而达到能够确定这条测试用例对应的所有配置组合中的每一个配置组合是否为故障源,必须要充分利用配置之间的关联,因此本文提出了一种基于元组关系树(TRT)的方法.该方法首先根据配置组合之间的关系来关联所有组合并形成树状结构,然后选择一种策略来挑选未被确定的组合配置中的一个进行分析判断其是否为故障源,此后我们将根据分析的结果和相关理论来确定与此组合相关Page3的配置组合是否为故障源.这个过程一直持续到没有未被确定的组合为止.如何在剩下的未被确定的配置组合中挑选一个进行分析是此方法的一个重点,并且它在很大程度上决定本文方法的性能.我们提出了4种不同的挑选策略,并且设计实验来比较这4种策略和随机挑选策略的性能.本文还将此方法应用于对真实软件TCAS的模块进行故障分析.本文的贡献点如下:(1)本文提出的方法可以分析一个出错测试用例的所有可能配置组合,改进了已有研究中定位不准确或只能定位t-way及以下和非重叠故障的不足.(2)提出了元组关系树模型来关联所可能的故障组合从而减少了所需分析的未被确定的配置组合的个数.(3)基于元组关系树,本文提出了4种搜索策略,并给出了这些策略和随机选择策略的性能对比.(4)本文给出了此方法在实际应用中的故障定位分析实例.本文第2节给出基本定义和定理的描述;第3节描述TRT模型和定位流程;第4节给出4种选择策略的描述;第5节描述实验及结果分析;第6节给出关于算法代价的一些讨论;第7节相关工作和比较;第8节给出总结和未来工作.2基础背景假设待测软件SUT有n个参数ci(i=1,2,…,n),每个参数ci的可选值是一个有限集Vi,|Vi|=ai.不是一般性,我们设a1>a2>…>an.为了能够清楚的介绍我们的方法,我们需要引入一些定义和定理,其中有部分定义沿用了Nie和Leung[2]中的相关定义.2.1定义定义1.我们称由系统n个参数的具体赋值序列(v1,v2,…,vn)(v1∈V1,v2∈V2,…,vn∈Vn)为待测系统SUT的一个测试用例.定义2.对于待测系统SUT,取某k个参数赋予特定值而形成的组合[-,…,vl1,-,…,vlk,…]为k值元组(k>0),不引起混淆的情况下简称为元组,其中‘-’表示此处参数的取值待定.实际上,此处定义的元组和引言中的配置组合是同一个概念.例如对于表1中SUT,[MacOS,-,Chrome,-]就是一个2值元组.定义3.我们称一个k值元组为故障元组,当且仅当任何包含此元组的测试用例都会触发故障.相反,若存在至少一条测试用例包含此元组且通过测试,就称此k值元组为正确元组.举个例子,对于元组[-,200MB,-,-],如果所有包含此元组的测试用例都会出错,即(Windows,200MB,Firefox,AC3Filter)、(Ubuntu,200MB,Chorme,MPEGLayer-3)等等都没有通过测试,那么[-,200MB,-,-]就是故障元组.同样的,若对于元组[-,200MB,-,-],我们发现了一条测试用例如(Windows,200MB,Chrome,AC3Filter)通过测试的话,那么[-,200MB,-,-]就是正确元组.注意:正确元组不需要所有包含它的测试用例都正确,只需找到一条包含此元组,且通过的测试用例就能证明待测元组为正确元组,下面的情况是合理的:[-,200MB,-,-]为正确元组,测试用例(Windows,200MB,Chrome,AC3Filter)通过,而测试用例(Ubuntu,200MB,Opera,AC-3ACM)出错.上述情况意味着(Ubuntu,200MB,Opera,AC-3ACM)包含了引发故障的元组,但这个元组不是[-,200MB,-,-].定义4.设TupleA为m值元组,TupleB为k值元组,有m>k,并且所有TupleB中的元素也都在TupleA中,那么我们称TupleA为TupleB的父元组,TupleB为TupleA的子元组,表示成“TupleBTupleA”,如果m=k+1,那么这两个元组是直系关系.如元组[MacOS,50MB,Chrome,-]为元组[MacOS,-,-,-]的父元组,而元组[MacOS,50MB,Chrome,-]为元组[MacOS,-,Chrome,-]的直系父元组.定义5.一个元组如果是故障元组,并且其所有子元组都是正确元组,那么就称此元组为最小故障元组.如[Windows,200MB,-,AC3Filter]为最小故障元组的条件为:本身为故障元组,而其子元组[Windows,200MB,-,-]、[Windows,-,-,AC3Filter]、[-,200MB,-,AC3Filter]、[Windows,-,-,-]、[-,200MB,-,-]、[-,-,-,AC3Filter]都为正确元组.最小故障元组是引起系统故障的最小单元,定位出最小故障元组有助于系统开发人员分析系统的故障所在并做出改进.Page42.2定理定理1.一条通过的测试用例所包含的所有元组都是正确元组.证明.由定义3知,对于一个元组,若能找到一条测试用例含有此元组且没有引发故障,那么此元组为正确元组.而对于这条通过的测试用例里包含的任意一个元组,由于这条包含它的测试用例没有引发故障,因而都是正确元组.定理2.有元组TupleA,TupleB和TupleC,满足TupleCTupleB,TupleBTupleA,那么TupleCTupleA.证明.由定义4知,对于TupleC中任何一个元素Vni必在TupleB中,而在TupleB的元素也必在TupleA中,即Vni也在TupleA中,根据定义3,TupleC为TupleA的子元组,而TupleA为TupleC的父元组,即TupleCTupleA.这条定理表明只需记录元组的直系子元组和直系父元组,即可找其所有的父元组和子元组.定理3.一个元组若是故障元组,那么其所有父元组都是故障元组.证明.对于一个故障元组,如果存在此元组的一个父元组是正确元组,根据定义3可知,即我们能找到一条测试用例包含这个父元组且通过测试.而根据定义4,这个测试用例显然也包含此元组,即可推出此元组是正确元组,这与此元组是故障元组矛盾,定理成立.定理4.一个元组若是正确元组,那么其所有的子元组都是正确元组.证明.对于一个正确元组,根据定义3,我们能够找到一条测试用例包含此元组且通过测试,那么根据定义4,这条通过的测试用例必然也包含这个元组的所有子元组,因此这个元组的所有子元组都是正确元组.3故障定位模型根据定理3、4,我们知道在确定了一个元组为正确元组或故障元组后能够推断出其父元组或子元组为正确元组或故障元组,这将大大减少所需分析判断的待定元组个数,从而减少附加测试用例的生成.因此,本文的方法首先需要构造一个元组关系树来记录所有待测元组和它们之间的关系,然后基于元组关系树给出完整的定位过程.3.1元组关系树(TRT)一棵完整的元组关系树由节点和连接节点之间的有向线段组成.其中,节点代表错误测试用例中的元组.有向线段连接的两个节点所表示的元组之间存在直系父子关系,从直系父元组指向直系子元组.根据定理2,我们可以递归获得所有父子关系元组.图1给出了测试用例(1,2,3)对应的元组关系图.3.1.1节点状态TRT中有3种节点状态:深色、浅色和白色,分别表示所对应元组的3种状态:故障、正确和未知.如图2中,元组[1,2,3],[1,-,3]为故障元组,元组[-,2,-],[1,-,-]为正确元组,元组[1,2,-],[-,2,3],[-,-,3]为未知元组.3.2最小故障元组定位模型构造、已知元组状态初始化和定位流程.本文的定位模型由4个部分组成:输入、TRT(1)输入本文方法接受一个执行过后测试用例集和参数配置为输入.根据文献[1],覆盖表对于发现交互故障的作用很明显,对于一个k维的覆盖表,可以以100%的概率击中值小于等于k的元组故障,而以至少1/(|Vk+1|×|Vk+2|×…×|Vm|)的概率击中m值元组故障(m>k).因此,此模型一般情况下的输入测试用例集为一个覆盖表.不失一般性,我们将所有参数的可取值映射到从1~Maxi(i=1,2,…,n)连续的整数值上,其中Maxi=ai,相应的我们将参数配置设为一个Maxi(i=1,2,…,n)的数组.同样我们将测试用例集中的具体参数配置值映射到整数值上.表2和表3分别给出了参数配置和执行过后的测试用例集.Page5参数1参数2参数3参数43测试ID11211通过21322通过31133通过42223通过52331失败62112通过73232通过83313通过93121通过(2)元组关系树的构造得到模型的输入后,我们对引发故障的测试用例构建一个元组关系树,此树将所有候选元组(可能是最小故障元组)尽可能联系起来,为接下来的定位提供两个信息:①所有需要分析的元组;②这些元组之间的关系.对于表3中第5条失败的测试用例,我们构造如图3的元组关系树.(3)初始化已知元组利用已执行的覆盖表和相关定义我们可以确定TRT中部分元组为故障元组或正确元组.首先,可以得知树中的顶部元组必定是故障元组.因为所有包含此元组的测试用例都引发了故障,事实上,所有包含此元组的测试用例只有唯一的一个,就为该元组对应的测试用例.初始工作还需要利用到覆盖表中所有通过的测试用例,根据定义3,我们将树中所有出现在通过的测试用例中的元组标记为正确元组.此步骤可以减少树中需要分析的元组,从而减少了所需生成附加测试用例的个数.对于上述例子,初始化之后可得到图4所表达的元组关系树.图中树的根节点所代表的元组标记为故障元组,而由于所有叶子节点所代表的元组都在通过的测试用例中出现过,因此都标记为正确元组.(4)定位流程根据最小故障的定义,要确定一个元组为最小故障元组,我们需要确定此元组是故障元组,并且还要能够确定其所有子元组都为正确元组.那么仅有上述3步还不足以定位出最小故障元组,因为上述元组关系树中还有很多元组节点仍是未知节点.因此若要实现定位出测试用例中的最小故障元组,就需要通过某种方法来确定TRT中所有的未知元组是故障元组还是正确元组.为了能够方便确定元组状态,我们将引入如下假设.假设1.每次生成的附加测试用例不会引入新的最小故障.根据这个假设,我们可以得出如下引理.引理1.对于一个待测元组,生成的含有此元组的附加测试用例如果引发故障,那么此待测元组必为故障元组.证明.假设如果这个待测元组不是故障元组,根据定理4,其所有子元组也都不是故障元组,由于最小故障的存在性[2],那么这个测试用例必定存在其他新的最小故障.这与假设矛盾,因此待测元组必为故障元组.有了如上假设和引理之后,我们给出此方法的定位过程的描述(过程1).此方法首先判断有没有未知元组需要分析(行1),然后从这些未知元组中挑选出一个(行2).之后将生成一个测试用例包含此元组(行3)并且执行(行4).如果测试用例引发故障,那么就设此元组和其所有父元组为故障元组(行5~9)如果测试用例通过就设此元组和其所有子元组为正确元组(行10~14).过程1.定位过程.1.WHILEunknown_tuples≠Do2.tuple=choose(unknown_tuples)3.test_config=gen_extra(tuple)4.result=exec(test_config)5.IFresult==failTHEN6.set(tuple,bug)Page67.FOReach_fatheroftupleDO8.set(each_father,bug)9.ENDFOR10.ELSE11.set(tuple,right)12.FOReach_childoftupleDO13.set(each_child,right)14.ENDFOR15.ENDIF16.ENDWHILE假设通过定位流程,我们的TRT演变成图5的形式.此时TRT中所有元组都已经得到确定,根据最小故障元组的定义,对此树遍历后很容易发现[2,-,3,-]和[-,3,3,1]就是最小故障元组.44种选择策略上一节介绍了定位的基本流程,其中在定位方法中有一个非常重要的步骤就是从剩下的未知元组中挑选一个待测元组用于分析.如果剩余的未知元组个数很多,那么这个步骤将会很大程度上影响本文算法的性能.本节我们将给出4种不同的挑选策略.4.1深度优先深度优先算法的伪码如过程2所示.深度优先策略首先构造一个具有先后顺序的待测元组列表(行3~5),这个列表中所有元组遵循着TRT中节点深度优先的顺序(后序)依次排列.选择时挑选列表中的第1个未知元组用于测试(行15~21).过程2.深度优先法.1.list=[]//元组集合2./构造依深度优先排序的元组集合/3.方法dep_first_construct:4.root=TRT.root5.depthFirst(root)6./深度优先算法(后向)/7.方法depthFirst(tuple):8.IFlist.contain(tuple)THEN9.RETURN10.ENDIF11.FOReach_direct_childoftupleDO12.depthFirst(each_direct_child)13.list.append(tuple)14.ENDFOR15./挑选方法/16.方法choose:17.tuple=null;18.WHILEtuple==null‖!tuple.isUnkownDO19.tuple=list.next()20.ENDWHILE21.RETURNtuple例如,对于图4中初始化之后的TRT,我们按照深度优先(后序)的顺序排列元组,结果为{[2,-,-,-],[-,3,-,-],[2,3,-,-],[-,-,3,-],[2,-,3,-],[-,3,3,-],[2,3,3,-],[-,-,-,1],[2,-,-,1],[-,3,-,1],[2,3,-,1],[-,-,3,1],[2,-,3,1],[-,3,3,1],[2,3,3,1]},然后选择第1个未被确定的元组———[2,3,-,-].选择该元组之后,执行的步骤如过程1所示的流程相同,即先对[2,3,-,-]生成一条附加测试用例,这条附加测试用例应与原测试用例尽量不同,我们不妨设为(2,3,2,2),执行这条测试用例,如果执行结果通过,则设此元组和此元组的所有子元组———[2,-,-,-]、[-,3,-,-](这两个元组在初始化时已经被设为正确元组,因此无需重复设置)为正确元组,反之,设此元组和此元组的所有父元组———[2,3,3,-]、[2,3,-,1]、[2,3,3,1](其中[2,3,3,1]在初始化已被设为故障元组,无需再设)为故障元组.此后继续选择元组测试直到TRT中没有未被确定元组为止.4.2广度优先广度优先算法伪码如过程3所示,它的算法流程和深度优先算法很相似,除了构造先后顺序列表时,此方法将所有的元组按照广度优先的策略排列.同样对于图4中初始化之后的TRT,这里我们按照广度优先的顺序排列元组,结果为{[2,3,3,1],[2,3,3,-],[2,3,-,1][2,-,3,1],[-,3,3,1],[2,3,-,-],[2,-,3,-],[2,-,-,1],[-,3,3,-],[-,3,-,1],[-,-,3,1],[2,-,-,-],[-,3,-,-],[-,-,3,-],[-,-,-,1]},然后选择第1个未被确定的元组———[2,3,3,-].此后步骤与4.1节相同.过程3.广度优先法.1.list=[]2./构造依广度优先排序的元组集合/Page73.方法breadth_first_construct:4.queen=[]5.queue.append(TRT.root)6.widthFirst(root)7./广度优先算法/8.方法breadth_first(tuple):9.FOReach_tupleofqueueDO10.list.append(each_tuple)11.queue_next=[]12.FOReach_tupleofqueueDO13.FOReach_direct_childofeach_tupleDO14.IF!list.contain(each_direct_child)THEN15.queue.append(each_direct_child)16.ENDIF17.ENDFOR18.ENDFOR19.breadth_first(queue_next)20.ENDFOR21./挑选方法/22.方法choose:23.tuple=null;24.WHILEtuple==null‖!tuple.isUnkownDO25.tuple=list.next()26.ENDWHILE27.RETURNtuple4.3贪心策略贪心策略算法伪码如过程4所示.此算法每次挑选“贪心值”最大的待测元组(行22~29).若一个元组不是未知元组,其“贪心值”为-1(行2~3,即只挑选未知元组分析),除此之外,“贪心值”是此元组未知子元组数目与未知父元组数目中较小的值(行5~21),选择这个值作为贪心值的理由是我们想通过确认一个元组后能达到覆盖确认尽可能多的元组.如若[2,3,-,-]有3个未知父元组和两个未知子元组,当此元组被确认之后我们至少可以覆盖确认两个元组.同样的对于[2,3,2,-]若有3个未知子元组和一个未知父元组,在其确认之后我们会至少覆盖确认一个元组.因此元组[2,3,-,-]的“贪心值”大于[2,3,2,-],在挑选时优先挑选元组[2,3,-,-].过程4.贪心策略.1.方法gv(tuple)://元组贪心值定义2.IF!tuple.isUnkownTHEN3.RETURN-14.ENDIF5.unkownChildNum=06.unkownFatherNum=07.FOReach_childoftupleDO8.IFeach_child.isUnknownTHEN9.unkownChildNum++10.ENDIF11.ENDFOR12.FOReach_fatheroftupleDO13.IFeach_child.isUnknownTHEN14.unkownFatherNum++15.ENDIF16.ENDFOR17.IFunkownChildNum>unkownFatherNum:18.RETURNunkownFatherNum19.ELSE20.RETURNunkownChildNum21.ENDIF22.方法choose:23.tuple=TRT.root24.FOReach_tupleofTRT:25.IFgv(each_tuple)>gv(tuple):26.tuple=each_tuple27.ENDIF28.ENDFOR29.RETURNtuple事实上,每次迭代后元组的“贪心值”都会变化.因为一旦我们确认了某个元组,那么TRT中某些元组的未知子元组和未知父元组数目会相应的发生变化.4.4路径法过程5.路径法.1.currentPath=[]//当前由元组构成的路径2.head=0//路径头结点3.middle=0//路径中间节点为了方便描述路径法,我们先介绍如下3个定义.定义6.路径是TRT中的一个元组序列,这个序列的每两个相邻的元组中,前一个都是后一个的直系父元组,后一个是前一个的直系子元组.[2,-,-,-]就是一条路径.如[2,2,3,1]→[2,2,3,-]→[2,-,3,-]→定义7.我们称一条路径为未确定路径,当且仅当这条路径所包含的所有元组都为未确定元组.定义8.我们把一个TRT所有的未确定路径中,拥有元组数最多的那条路径称为此TRT的最长未确定路径.这个策略的伪码如过程5所示.“currentPath”变量存储着一条路径,而head,middle,tail是指向这条路径中的元组的指针,其中head和tail之间的所有元组都是未被确定元组.在选择元组步骤(行20~23)此策略需要先要做一个预处理(行21)然后再挑选路径中middle所指向的元组(行23).Page84.tail=05.lastChosed=null//上次挑选的元组6.方法reset:7.currentPath=get_longest_path(TRT)8.head=middle=09.tail=currentPath.size10.方法choosingPreprocess:11.IFlastChosed.isRightTHEN12.tail=middle-113.ELSE14.head=middle+115.ENDIF16.middle=(head+tail)/217.IFtail<headTHEN18.reset()19.ENDIF20.方法choose:21.choosingPreprocess()22.lastChosed=currentPath[middle]23.RETURNlastChosed由于deltadebugging[5]在搜索故障空间上的高效性,因此在预处理步骤(行10~19)中我们根据上一次迭代的结果使用二分法,当上一次挑选的元组被确认为正确元组,那么其所有的子元组都为正确元组,对应这条路径中位于此元组后面的元组都将会被标记为正确元组,之后我们将tail指向位于middle所指元组的前一个元组(行11~12)以保证tail和head之间的元组都为未被确定元组,相反,如果上一次所选元组为错误元组,那么我们就设路径中位于此元组前面的元组为故障元组,相应的我们将head指向位于middle所指元组的后一个元组(行13~14).然后根据二分法将middle指向tail和head中间的元组(行16).如果当前路径里所有的元组都已被确认,我们将会重新挑选一条最长未被确定路径(行17~19).在重新设置步骤(行6~9)中,我们将会先找到一条最长未被确定路径(限于篇幅,这里不给出如何得出最长未被确定路径的算法),然后设head指向这条路径的第一个元组(行8),tail指向这条路径的最后一个元组(行9).middle第一次也指向路径的第一个元组(行8),这是因为我们想要尽快得知这条路径中是否含有故障元组.如对于一条路径{[1,2,3,4,-],[1,2,3,-,-][1,-,3,-,-],[1,-,-,-,-]},我们首先选择[1,2,3,4,-]作为middle指向的元组,如果这个元组是正确元组,那么我们将立即得知这条路径没有故障元组,而若在第一次挑选元组过后,发现此元组为故障元组,那么下面则会使用二分设置middle指向中间的元组———[1,-,3,-,-].5实验我们采用两种类型的实验,模拟实验和真实软件实验.5.1模拟实验在模拟实验中,我们假设待测系统SUT受8个参数影响,每个参数有3个可选配置值.我们做3组模拟实验,分别考虑如下3种故障类型.第1组实验.假设出错的测试用例中只包含单个t值故障元组(t=2,3,4,以下两组实验类似).例如,(1,2,2,2,1,1,2,3)只包含[1,2,-,-,-,-,-,-]这一个2值故障元组,其余元组都是正确元组.当该错误的测试用例只包含一个t值故障元组时,所有可能的t值故障元组有Ct时,C28=28,t=3时,C3我们对1个测试用例植入1个单个故障后,用4个选择算法对这个故障测试用例进行定位,将定位所需的额外测试用例个数记录下来.此外我们还添加了随机选择这一策略作为一个benchmark,对随机选择策略(即每次随机挑选一个未知元组测试)我们进行了100次实验,取所需额外测试用例数的平均值作为结果记录下来.我们依次植入所有t值故障(t=2,3,4),每次都按如上方法执行分析,最后我们将所有结果以盒图的形式显示,即对每种算法显示出此算法所需要的额外测试用例数的分布情况.实验结果见图6(a).第2组实验.假设出错的测试用例中包含两个有重叠的t值故障元组.此组实验中故障的测试用例包含两个t值故障元组,且这两个故障元组至少含有一个重叠元素.如(1,2,2,2,1,1,2,3)包含两个如下故障:[1,2,2,-,-,-,-,-],[-,-,2,2,-,1,-,-].我们循环取两个单个故障元组(没有重复),保留有重叠元素的所有两个故障元组对,并依次植入这样的故障对.每次植入故障对后,我们采用如第1组实验中的方法记录4种选择策略和随机策略的所需额外测试用例个数,实验结果见图6(b).第3组实验.假设出错测试用例中包含两个没有重叠的t值故障元组.Page9图6模拟实验统计结果此组实验中故障的测试用例包含两个t值故障元组,且这两个故障元组没有重叠元素.如(1,2,2,2,1,1,2,3)包含两个如下故障元组:[1,2,-,-,-,-,-,-],[-,-,2,2,-,-,-,-].与第2组实验类似,我们循环取两个故障元组(没有重复),不同的是,这一组实验保留的是所有没有重叠元素的元组对,之后步骤和第2组实验相同,实验结果见图6(c).根据以上3组实验,我们可以看出就所需额外测试用例个数而言(越少越好),深度优先性能在所有情况下都是最差的,路径法则相反,在所有情况下都是最优的,其余3种算法:随机选择、广度优先和贪心则差不多,而就稳定性,即对于1个测试用例,不同故障元组(同值)对定位结果的影响而言,贪心算法和路径法不太稳定,受此影响较大,而随机选择、深度优先和广度优先则受此影响较小.5.2真实软件实验我们使用交通避免碰撞系统(TCAS)作为待测软件[6],这是一个包含多个C模块的benchmark程序,曾被用作其他软件测试方法[7-10]的测试对象.这个程序有12个输入,文献[7]将每个参数的输入空间划分为若干个等价类,我们将采用和文献[7]相同的输入配置,如图7所示.此程序的输出是alt_sep,有3个取值.5.2.1实验设计实验中,我们将采用此软件的一个正确的版本和一个故障版本(植入和文献[10]相同的故障)作为实验对象.对于一个具体输入我们通过观察故障版本和正确版本的结果是否一致来判断此输入是否引发故障.我们将采用本文的定位分析系统对TCAS故障版本分析故障原因.5.2.2实验步骤(1)对待测系统生成2维覆盖表测试用例集.(2)依次执行测试用例集中的每条测试用例.(3)对这个执行过后的测试用例集采用本文中的定位模型进行最小故障元组定位(挑选策略选用Page10路径法).(4)分析结果.5.2.3实验结果(1)使用AETG工具[11](AETG是一个基于贪心策略的覆盖表生成方法,具有较高的效率和广泛的应用),我们生成了一个12×112的2维覆盖表;(2)执行这个覆盖表,我们得出了一个如图8所示的错误测试用例和其余111个正确测试用例;Cur_Vertical_Sep=601High_Confidence=1Two_of_Three_Reports_Valid=1Own_Tracked_Alt=1Own_Tracked_Alt_Rate=601Other_Tracked_Alt=2Alt_Layer_Value=0Up_Separation=500Down_Separation=0Other_RAC=2Other_Capability=2Climb_Inhibit=1(3)用定位模型系统对这个执行过后测试用例集进行分析定位出的最小故障元组为以下3个.(a)[Cur_Vertical_Sep=601,High_Confi-dence=1,-,-,Own_Tracked_Alt_Rate=601,-,Alt_Layer_Value=0,-,-,-,Other_Capa-bility=2,-];(b)[Cur_Vertical_Sep=601,High_Confi-dence=1,-,-,Own_Tracked_Alt_Rate=601,-,-,-,Down_Separation=0,-,Other_Capa-bility=2,-];(c)[Cur_Vertical_Sep=601,High_Confi-dence=1,-,-,Own_Tracked_Alt_Rate=601,-,-,Up_Separation=500,-,-,Other_Capa-bility=2,-].5.2.4结果分析两个元组a,b相似度(Sab)的计算公式:此过程生成了29条额外的测试用例.为了评价我们程序的定位结果,我们将先给出其中,NumSameab是两个元组固定参数值相同的个数,而NumDiffab是元组固定参数值不同的个数,NumMaxab为两个元组的固定参数个数最多的元组的固定参数个数.如对于元组[-,1,2,-]和元组[2,1,1,-],由于他们固定参数值相同的参数只有1个,为第2个参数,都取1,而固定参数值不同的也只有1个,为第3个参数,第1个元组取2,第2个元组取1,而固定参数个数最多的是第2个元组,个数为3.因此它们的相似度为(1-1)/3,即0/3.我们将实际定位出来的元组和测试用例中包含的真实故障元组的相似度称为故障相关性,也就是说,故障相关性越高,实际定位元组就越接近真实的故障元组,定位结果也就越精确.为了得出我们定位结果的故障相关性,我们先通过代码审查分析,得出测试用例中包含的真实故障元组为[Cur_Vertical_Sep=601,High_confi-dence=1,-,Own_Tracked_Alt=1,Own_Tracked_Alt_Rate=601,Other_Tracked_Alt=2,Alt_Layer_Value=0,Up_Separation=500,Down_Separation=0,-,Other_Capability=2,Climb_Inhibit=1],然后通过式(1)我们计算出了定位结果故障相关性的值,结果列入表4中.而文献[10]中最终定位故障元组为[Cur_Vertical_Sep=601,High_confidence=1,-,-,Own_Tracked_Alt_Rate=601,-,-,-,-,-,-,-],根据式(1),其故障相关性为3/10,即定位精度要小于本文的结果.5.2.5改进实验仔细分析源代码(图9),我们发现此段代码第6行和第12行返回了同样的结果:alt_sep=UNRE-SOLVED,如果没有进入这段代码段(行2~13),结果同样是返回alt_sep=UNRESOLVED.这样的结果会扰乱我们的定位效果,因为如果一个测试用例使得正确版本和错误版本执行不同的Page11逻辑段,那么应该认为此测试用例触发故障,但由于两个版本执行结果相同,此故障就被忽略,从而认为此测试用例通过.为了克服这一因素引起的扰乱,我们对TCAS代码进行改动,将第6行和第8行的代码alt_sep=UNRESOLVED改为与UNRESOLVED不同的值,分别设为UNRESOLVED1和UNRESOLVED2.修改后,我们的错误测试用例包含的真实故障元组变为[Cur_Vertical_Sep=601,High_confi-dence=1,-,-,Own_Tracked_Alt_Rate=601,-,-,-,-,-,Other_Capability=2,-],而定位出的最小故障模式为[Cur_Vertical_Sep=601,High_confidence=1,-,-,Own_Tracked_Alt_Rate=601,-,-,-,-,-,Other_Capability=2,-].故障相关性为4/4,即定位结果和真实故障完全一致.6讨论TRT方法需要先列出所有可能的配置组合,并构成树形结构.此树形结构对于我们的方法有如下3个重要作用.(1)可以快速检索出1个元组的相关子元组和父元组.(2)可以查看当前还有哪些未被检测的元组,为下一次迭代挑选待测元组提供候选对象集.(3)查看是否所有的元组都被检测到,为算法终止提供了依据.然而,树形结构需要程序提供空间存储,在参数个数很小的时候,这个树形结构的规模很小,问题不大,但是一旦参数个数增大,树形结构的规模将会很大,程序需要花费很大的空间代价来存储这样一个树形结构,为了解决此问题,实际实现过程中我们可以不必在内存中储存这样的树形结构,取而代之的是我们需要做出如下的措施:(1)动态的计算一个元组的相关子元组和父元组,而不是事先储存其关系.这个动态的计算的过程所需的代价很小.(2)由于没有存储未被检测的元组,为了检测一个元组是否是未被检测的元组,我们需要将每一次迭代的元组和其确定后的状态(即是否为故障元组)存储下来.然后对于一个新挑选的元组,我们只需根据通过定理3和4,即判断是否是已测正确元组的子元组或已测故障元组的父元组.如果都不是,那么这个新挑选的元组就是未被检测元组,反之就是已被检测元组(由于实际需要检测的元组个数并不多,因此这种存储的代价很小).(3)使用一个变量来标记当前未被确定元组的数量(初始为所有可能配置元组的个数),每次确定了一个元组为故障元组或非故障元组,这个变量就减1.因此程序终止的条件就是这个变量是否为0.但是由于没有存储树形结构,虽然我们可以通过策略2判断出一个元组是否为未被检测元组,我们却不能很直观的得到未被测试元组的候选集,因此这会很大程度上影响到算法的挑选策略.从而我们需要新的方法来获得未被测试元组候选集或部分未被测试元组候选集.目前我们还没有得到在不存储树形结构的情况下高效的挑选候选集的策略.这会是我们未来工作的一个重要部分.7相关工作和对比Nie在文献[12]提出一种分析故障元组的方法,该方法将发现错误的测试用例中包含的故障模式与未发现故障的测试用例所包含的故障模式进行比对排除,以缩小可能的故障模式范围,但这种方法效果很差,特别是在使用覆盖表进行测试时,几乎无法缩小这个可疑故障模式范围.然后用一些附加测试用例进行补充测试,进一步缩小这个范围.在文献[13]中Nie等人对此方法做出了改进,该方法将一条发现故障的测试用例所包含的可能的故障模式表示成一个偏序集,这样通过发现故障的测试用例和未发现故障的测试用例形成的偏序集的做差,形成的新的偏序集,最后将这个偏序集的极小元看做最大可能的故障模式,虽然此结果比之前的结果改进很多,但该方法找出来的还只是可能的故障模式.而在文献[2]中,Nie对此方法继续完善,提出了组合测试中的“最小故障模式”概念,并给出了定位最小故障模式的重要基础理论和方法.Wang的方法[14]是Nie的一个迭代改进方法.通过多次迭代修改参数达到进一步从可能故障元组中约减正确元组.不过Wang方法的有效性建立在很多假设之上,如只含有一个最小故障和多个非重叠故障等假设,限制较多.Zhang在文献[4]中提出了FIC和FIC_BS两种定位方法,该文采用错误的测试用例作为种子初始化,然后通过自适应修改种子用例的一些对应参数值从而生成附加测试用例并执行,重复此动作直至找到最小故障元组为止,而对于多个故障的情况,Zhang实现定位了没有重叠的故障元组.Zhang的Page12方法能够以生成较小的附加测试用例个数达到定位出任意大小的故障元组,但是Zhang不能定位出有重叠的故障.Ghandehari等人[3]在其中使用t-way覆盖表作为定位输入,然后按元组的可疑程度输出可能的故障元组.该文定义了元组可疑程度、元组环境可疑程度,并根据这两者来对待定元组进行排序,对可疑程度较大元组生成附加测试用例,然后迭代分析排序.可知Ghandehari的定位需要的限制条件较少,但是只能定位出t值或小于t值的元组,并且他们的结果并不保证排序靠前的就是故障元组.Yilmaz等人[15]中提出了一个机器学习的方法来实现组合故障定位.该方法建立了一种分类树,通过使用覆盖表作为训练集来实现树的划分,并使用该树做故障诊断.该方法可以诊断多种错误状态,而不只是文中所约定的只有错误和正确两种状态,但是由于使用机器学习,此方法在定位上不是很准确,会遗漏和错评一些测试用例.并且此方法只定位错误频率达到3%以上的组合,而对于一些高维的组合,由于出现频率小,不会被此方法侦测到.基于Yilmaz的方法的一些限制如:现实软件测试缺少选择覆盖强度的指导性建议、对先生成的低维覆盖表的利用、非确定性故障的影响,Fouché在文献[16]提出了利用可增长式的覆盖表对故障进行诊断,即在测试过程中先生成低维覆盖表进行诊断,然后不断增加覆盖强度实现对高维故障的诊断,此方法能够尽早的发现低维的故障,较传统的生成固定的覆盖表定位有所提高,但是定位过程同样忽略了错误频率较低的故障.针对前两种机器学习方法的限制:对高维强度的组合故障定位不足,Shakya等人在文献[10]提出了一种扩展方法,此方法在已有的测试用例基础上分析再生成下一批测试用例,确保尽可能生成的测试用例都错误,以提高分类树的分类准确度,同时他们还对不引发故障的参数进行过滤以简化分类树.他们的方法目前只有初步结果.本文方法的特点在于可以定位出任意维度(值)的故障,并且对于测试用例多个故障的情况,尤其是重叠的故障都可以很好的定位,其中路径法可以以生成较少的附加测试用例情况下定位出测试用例中的最小故障元组.7.1和已有算法的对比我们对定位故障方法中的4个指标:能够定位出的故障元组维度的限制、能否定位有重叠的故障、新引入故障对算法是否有影响和定位结果是否精确进行考察.对比结果如表5所示.可以看出在能够精确定位结果的算法中,只有本文算法可以定位出有重叠的故障.算法定位维度重叠故障引入故障结果精确本文算法任意√×√Zhang任意××√Wang任意××√Nie任意√√×Ghandeharit√√×Shakyat√√×Yilmazt√√×Fouchét√√×此外,我们还需要考虑到我们的算法所需成本大小,即所需附加测试用例个数的多少.为此,我们取已有工作中需要附加测试用例数最少的算法FIC_BS[4]与我们的算法进行对比.对比试验中用到的模拟待测模拟系统的配置参数个数分别为8、10、12、14和16,每个配置有3个取值,我们采用第5节中的实验方法来对比FIC_BS和路径法两个算法,只比较单个故障的情况(FIC_BS不能定位出有重叠的两个故障).对比结果如图10显示.图10中我们可以看出,在k=8,t=3、k=8,t=4、k=10,t=4和k=12,t=4这4组实验中,我们的结果(平均值)要比Zhang的方法要好,其余结果比Zhang差,但是差别不超过4个.并且在k、t相同的情况下,我们的定位结果中所需要的最小附加测试用例往往要比Zhang小,但是我们的方法的稳定性不如Zhang.对比结果表明本文算法在可以定位出有重叠的故障基础上牺牲的效率并不高.8总结和未来工作本文提出一种新的定位模型来定位组合测试中的最小故障元组,此方法利用元组关系树TRT来记录所有需要分析的元组和它们之间的关联,基于TRT我们给出了4种挑选策略.通过模拟实验我们得知路径法能以最少的生成附加测试用例数达到定位目标.我们的方法可以在保证结果精确的前提上定位出有重叠的故障,这是现有方法所不具备的功能.本文还使用此方法对真实软件TCAS的模块做了故障分析,实验结果显示我们的方法比以往的方法更能精确的发现故障源.然而,本文方法使用了很大的空间来存储Page13图10路径法(PATH)与FIC_BS对比图TRT,其空间复杂度为O(2n),虽然我们给出不需要存储TRT就可以进行定位的措施,但是目前我们还没有得到高效的得出候选集的策略.并且该方法仍基于不引入故障的假设之上,若软件故障较多,在生成附加测试用例引入新的故障可能性很大的情况下,我们的定位结果精度将降低.未来我们将对在不存储树形结构的情况下得出候选集的策略做出深入的研究,使其能够动态并高效的返回全部或部分未被测试元组的候选集.并且需要改进算法使得本方法对可引入故障的SUT也能很好的定位出故障源,从而提高算法的鲁棒性.致谢匿名审稿人对本文提出了非常有帮助的修改意见,对改进本文质量起到了非常重要的作用,在此表示感谢!
