Page1科学计算浮点数据的高性能无损压缩何克晶(华南理工大学计算机科学与工程学院广州510641)摘要科学计算在科学界及工业界发挥着越来越重要的作用,所随之产生的科学数据也越来越多.因二级存储(如硬盘)的读写速度通常较慢,庞大的数据量除了占据存储空间之外,还影响着系统性能.文中通过系统研究浮点数据的特性,建立预测精度和压缩比之间的关系的理论体系.通过利用科学数据之间的相关性,采用多种预测器以及高效熵编码方法,提出一种科学数据高性能无损压缩方法.该方法既不需要使用者有关于原始数据的先验知识,也不需要使用者自行设计预测器.通过与其他压缩方法进行比较,结果表明文中方法的压缩比远高于其他方法,并同时具有恒定的海量压缩吞吐量.该方法已被应用于大规模颗粒动力学仿真系统的数据压缩.关键词科学计算;浮点数据;无损压缩;高性能1引言随着科学计算技术在科学界及工程界的广泛应用,所随之产生的科学数据也越来越多.主要的科学Page2查点数据量也非常大.因硬盘I/O操作通常较慢,庞大的数据量除了占据存储空间之外,还影响着系统性能.为了减少科学数据所需的存储空间大小,许多研究者都借助压缩工具来对数据进行压缩.目前最广为采用的有两种方式:第1种方式在数据产生之后,再借助第三方的压缩工具进行压缩.第2种方式中,压缩算法作为模拟软件的数据过滤器(filter),数据通过过滤器处理,直接产生压缩后的数据.不管哪种方式,借助的都是通用压缩算法.科学数据与通常数据有着本质的不同.在模拟系统中,科学数据多是以高精度浮点数的形式存在,所产生的检查点数据和结果数据也多是一维或者多维的浮点数组.通用压缩算法对于文本的压缩效果很好,但无法充分利用科学数据本身以及浮点数本身的特性,从而导致最终的时间性能和空间性能较差.本文提出一种科学数据高性能无损压缩方法,它通过利用科学数据之间的相关性以及浮点数本身的特性来进行预测编码,从而进行快速有效的科学数据压缩.该方法既不需要使用者有关于原始数据的先验知识,也不需要使用者自行设计预测器.该方法既可作为单独科学数据压缩工具的内核使用,也可作为模拟软件的高性能数据过滤器.通过与常用压缩工具进行比较,结果表明该方法在时间性能和空间性能上均优于通用算法.该方法已被应用于大规模离散元科学仿真系统的数据压缩.本文第2节介绍相关研究;第3节给出该科学数据高性能无损压缩方法的详细介绍,包括系统框架和该方法的关键技术:预测器、熵编码等;第4节对该方法进行评估;第5节总结全文.2相关工作目前对通用科学数据的压缩较多采用的还是通用压缩方法和工具,如Gzip、Bzip2等.有部分研究对科学模型以及网格(Mesh)数据的压缩进行了探索.其中最有代表性的为文献[1-2].这些研究往往通过对三维网格数据进行分析处理,从而对相应的几何数据和连通性数据进行去冗余压缩.Isenburg等[3]针对网格数据多为浮点数的特点,设计了针对浮点数存储格式的网格数据压缩方法.随后,Lindstrom等[4]通过使用Lorenzo预测器[5],继续将该方法拓展到具有空间冗余性的浮点数据压缩.在本文的横向比较中,该方法简称PLMI.该方法只适用于具有空间冗余性的空间数据,如二维图像、三维速度场数据等.并且使用时必须显式指定每个数据维的大小.Engelson等[6]使用外延预测器来压缩存储模拟数据.该方法对平滑变化的数据效果较好,对通用的科学数据压缩效果较差.Ratanaworabhan等[7]根据前若干个数据,使用差分预测器进行浮点数的预测压缩,能达到1.6左右的几何平均压缩比.Burtscher等[8-9]设计了高通量的浮点数据压缩方法,能达到1.9左右的几何平均压缩比.在本文的横向比较中,该方法简称FPC.相关研究均没有研究预测精度和压缩比之间的关系.本文通过系统分析,建立预测精度和压缩比之间的解析关系.并采用多种预测器以及高效熵编码方法,得到远高于相关研究的压缩比,并同时具有恒定的海量压缩吞吐量.3科学数据的高性能无损压缩方法3.1IEEE浮点数结构现今计算机系统中普遍采用的都是1985年的IEEE二进制浮点数算术标准(IEEE754)[10].在该标准中,定义了被广泛使用的32位二进制浮点数(单精度)和64位二进制浮点数(双精度)的存储格式.在2008年新的IEEE浮点数算术标准(IEEE754-2008)[11]中,新增定义了128位二进制浮点数、64位十进制浮点数以及128位十进制浮点数,5种基本浮点数格式中的3种如图1所示.其中两种128位的格式因篇幅关系并未列出.对于二进制浮点数而言,数值由下式表示:十进制浮点数的格式类似,只是在组合域(combina-tionfield)中,除了用W位来编码指数,其余的5位共32种组合中的30种组合用来编码归一化后的十进制数的整数部分(0~9共10种取值)与3种指数值.剩余的2种组合分别表示无穷大与Page3NaN.t位的尾数部分采用密集十进制(DenselyPackedDecimal,DPD)编码3t/10位十进制数的小数部分.因32位和64位二进制浮点数最为常用,并且IEEE754-2008标准同时定义了若干种交换格式用于在不同的浮点数实现中进行数据交换,所以本文以32位和64位二进制浮点数为例,将它们统称为浮点数.但本文的方法同样适用于其它的浮点数格式,甚至非标准IEEE格式.需要注意的是,IEEE标准中并没有定义浮点数在机器中的字节存储顺序.有的采用小端法(littleendian)进行存储;有的则采用大端法(bigendian)进行存储.字节存储顺序并不影响压缩算法,但为了行文方便,本文均以小端法为例.3.2科学数据压缩原理他数据有诸多本质区别:作为科学数据主体的浮点数据与文本数据等其(1)虽然浮点数本身是字节对齐的(byte-aligned),但各组成部分(如符号位、指数部分和小数部分)均不是字节对齐的.传统的基于字节的压缩方法不顾浮点格式的物理意义,而强行把数据分割成以字节为单位(图2).因物理意义丢失,从而使得不管是字典法还是统计法,效果均不理想.图2传统基于位的方法不能利用浮点数的格式特征(2)即使是以位为单位的预测方法,比如一些基于上下文的预测压缩方法[12-13],因无法考虑到浮点数各个位的意义并根据其重要性进行区别对待,从而导致需要处理的上下文过多,占用大量的内存空间和压缩时间,还不能得到较优的压缩比.为了在快速压缩的同时得到高压缩比,压缩方法需要充分利用浮点数的特征.主要的特性包括:(1)指数部分的数值(E)可以基本代表该浮点数的范围.尾数部分对数值范围的影响度随着与LSB位距离的减小而指数降低.所以,某浮点数的大范围基本上用符号位S、指数E及少数几个尾数位即能确定.也就意味着,可以用最靠近MSB的若干位,来近似整个浮点数.定义1.区间.对浮点数F,定义(-1)SEF-S为该浮点数所位于的区间.对于两个二进制浮点数F1、F2,如果符号位SF1=SF2,并且指数位EF1=EF2,则称F1与F2属于同一个区间.同时,把它们的尾数分别简记为TF1与TF2.若F1、F2位于不同区间,则将F1与F2的区间之差定义为两者之间的区间距离.定义2.前导零数.数值串N中第一个非零字符前面的零字符的个数,简记为LZC(N).定理1.如果两个浮点数F1、F2位于同一个区间,记二进制异或运算为,则平均的LZC(F1F2)约等于W+2.证明.F1,因F2与其位于同一区间,根据定义1,可知它们的前W+1位均相同.F2的尾数部分共t位,共有2t种可能性.其中有1种可能性是LZC(TF1TF1)=t(F1=F2时),2t-x-1种可能性为LZC(TF1TF1)=x(x={0,2,…,t-1}).假设这2t种可能性出现的概率一样,则平均而言:LZC(TF1TF2)=从而LZC(F1F2)=W+1+LZC(TF1TF2)≈W+2引理1.如果两个浮点数F1、F2位于同一个区间,且尾数部分的前n位相同,则平均的LZC(F1F2)等于W+2+n-(1/2t-n).证明.尾数部分共t位,如前n位相同,则变化的只可能是后t-n位.将t-n代入定理(1)中t,再加上尾数部分相同的前n位,从而有LZC(TF1TF2)=n+2t-n-1故LZC(F1F2)=W+2+n-(1/2t-n).得证.证毕.定理2.如果两个浮点数F1、F2位于同一个区间,且尾数部分的前n位相同,则它们之间的最大相对误差为1/2n-1/2t.证明.若尾数部分前n位相同,相对误差最大的情况只能出现在尾数部分前n位均为0,且其中一个浮点数(F1/F2)的后t-n位为0,而另一个浮点数(F2/F1)的后t-n位为1的时候.这时两者之差的绝对值为两者绝对值的最小值为Page4式(5)除以式(6)之后可得两者之间的最大相对误差为1/2n-1/2t.得证.定理3.如果两个浮点数F1、F2不位于同一个区间,但它们的前n位相同,则平均的LZC(F1F2)约等于n+1.证明.类似引理1,将符号位、指数部分和尾数部分共W+t+1位作为一个整体考虑,将W+t+1类比于引理1中的t,将n类比于引理1中的n,通过类似于定理1和引理1的证明可知:LZC(F1F2)=n+1-(1/2t+W+1-n)≈n+1(7)定理4.如果两个浮点数F1、F2不位于同一个区间,但它们的前n位相同,则它们之间的最大相对误差为22W-n+1-1.证明.因F1、F2之间的最大相对误差为min(|F1|,|F2|)=最大相对误差当两个浮点数其中一个的后W-n+1位指数位及尾数位全为0,且另一个的后W-n+1位指数位及尾数位全为1时取到.此时E1与E2两者分别为2W-2W-n+1与2W-1,而T1与T2分别为0与2t-1.代入式(8),有最大相对误差为min(|F1|,|F2|)≈2×22W-1-22W-2W-n+1但我们注意到,定理2及定理4的逆命题均不成立.即,根据最大相对误差,并不能确保两个浮点数的二进制表示的前若干位相同.为了建立平均相对误差到平均的LZC(F1F2)的映射关系,有如下定理.定理5.如果两个浮点数F1、F2的符号位相同,且两者中绝对值较大者与绝对值较小者的比值为r,则它们的区间距离为log2r或log2r.证明.(1)当log2r为整数时,这时因为r为2的整数次幂,故F1与F2的尾数部分相同.根据式(1),知此时的比值r为2|E1-E2|.再根据定义1,它们的区间距离为|EF1-EF2|,也即log2r.符合定理5.(2)当log2r为非整数时,此时记F1与F2中绝对值最小者为Fmin,绝对值较大者为Fmax.假设Fmin位于某一区间i,则当|Fmin|取最小值时,因|Fmax|>|Fmin|×2log2r,且|Fmax|<|Fmin|×2log2r,故此时Fmax必位于区间i+(-1)Slog2r.当|Fmin|取最大值时,同样因|Fmax|>|Fmin|×2log2r,且|Fmax|<|Fmin|×2log2r,故此时Fmax必位于区间i+(-1)Slog2r.且因为区间i+(-1)Slog2r与区间i+(-1)Slog2r为相邻区间,故当Fmin值在区间i内变化时,Fmax必定也在区间i+(-1)Slog2r与区间i+(-1)Slog2r变化.也即两者的区间距离为log2r或log2r.得证.引理2.如果两个浮点数F1、F2的符号位相同,且两者中绝对值较大者与绝对值较小者的比值为r,记F1与F2中绝对值较小者为Fmin,Fmin所在区间的绝对值最小值的浮点数为B.则当Fmin/B∈[1,2log2r/r)时,F1与F2的区间距离为log2r,当Fmin/B∈[2log2r/r,2)时,两者的区间距离为log2r.证明.当Fmin/B∈[1,2log2r/r)时,这时Fmax=Fmin×r∈[rB,2log2rB),与B所在区间(也即Fmin所在区间)区间距离为log2r.当Fmin/B∈[2log2r/r,2)时,这时Fmax=Fmin×r∈[2log2rB,2rB),与B所在区间(也即Fmin所在区间)区间距离为log2r.得证.引理3.如果两个浮点数F1、F2的符号位相同,且两者中绝对值较大者与绝对值较小者的比值为r,则两者之间的平均区间距离为log2r+1-2log2r/r.证明.根据引理2,F1与F2之间的平均区间距离应为(2log2r/r-1)×log2r+(2-2log2r/r)×log2r=(2log2r/r-1)×(log2r-1)+=log2r+1-2log2r/r注意,本引理及上述证明对r为2的整数次幂亦成立.得证.定义3.区间内距离.若浮点数F1与F2位于同一区间,定义|TF1-TF2|为两浮点数之间的区间内距离.可见,区间内距离的取值范围为[0,2t-1].定理6.如果两个浮点数F1、F2位于同一区间,且区间内距离固定为d,记max(X,0)为X#,则它们之间的平均LZC(TF1TF1)为∑t(2t-d).证明.当区间内距离为d时,记F1与F2中较大者为Fmax,较小者为Fmin,则二元对(Fmin,Fmax)共Page5i=1i=1有2t-d种不同组合.假设这2t-d种组合均匀分布,平均每种出现一次,这时容易验证当t=1时,定理6成立,即平均的LZC(TF1TF1)为(2-2d)#/(2-d).设定理6对t=j时成立,则这时2t-d种组合每种出现一次时总的LZC(TF1TF1)为∑j(2j-2id)#.那么当t=j+1时,因为这时尾数Ti=1的2j+1种组合可以看成是在t=j的2j种组合的基础上,前面分别补上了0和1,且在最前面补多了一位,除了Fmin尾数首位为0且Fmax尾数首位为1的d种组合外,剩下的((2j+1-d)-d)#=(2j+1-2d)#种组合的LZC(TF1TF1)均增加1.从而有如下递推关系:∑(Fmin,Fmax)LZC(TF1TF2)|t=j+1=∑(Fmin,Fmax)LZC(TF1TF2)|t=j×2+(2j+1-2d)#[=∑j[=∑j=∑j即当t=j+1时,2j+1-d种组合每种出现一次时总的LZC(TF1TF1)为∑j+1LZC(TF1TF1)为∑j+1定理6对t=j+1亦成立.由归纳法知,当t为浮点数的尾数部分位数时,定理6亦成立.得证.证毕.3.3高性能无损压缩方法算法能得到的压缩比与预测误差直接相关,其关键在于预测误差前导零LZC(F1F2)的平均个数.因此,为了得到高性能无损压缩方法,本文继续针对F1、F2位于同一区间及不同区间的情况下,LZC(F1F2)的平均值进行理论分析.间,且区间内距离固定为d,则引理4.如果两个浮点数F1、F2位于同一区(1)它们之间的平均LZC(TF1TF1)当d=0时为t,当d≠0且d2t-1时可近似为[(t-2-log2d)2t+2d]/(2t-d),当d>2t-1时为0;(2)它们之间的平均LZC(F1F2)当d=0时为W+1+t,当d≠0且d2t-1时可近似为W+1+[(t-2-log2d)2t+2d]/(2t-d),当d>2t-1时为W+1.最坏情况下的近似相对误差约为1%.i=0证明.命题(1).容易验证当d=0时平均LZC(TF1TF1)为t.当d为2的整数次幂时,定理6的结果等于[(t-2-log2d)2t+2d]/(2t-d),当d>2t-1时为0.当d不是2的整数次幂时,设d∈[2j+1,2j+1],此时根据定理6算出的准确结果为[(t-j-1)2t-2t-jd+2d]/(2t-d),与引理4的近似值之间的误差为[log2d-(j-1+2-jd)]2t/(2t-d).设j1=log2d-j,其中j1∈(0,1],故近似误差又可表示为(1+j1-2j1)2t/(2t-d).易知,当j=t-2,j1≈0.58的时候,这时的近似误差取得全局最大值(最坏情况)约为0.136.命题(1)得证.命题(2).因为最后压缩的时候,是对整个浮点数进行编码,故需要考虑整个预测误差的前导零数,即LZC(F1F2).根据定义1和定义2,当F1、F2位于同一区间时,LZC(F1F2)=W+1+LZC(TF1TF1),故命题(2)的前3部分得证.根据定理6,对于64位浮点数而言,这时的LZC(F1F2)的准确值为14.故最坏情况下的近似相对误差约为0.136/14≈1%.得证.引理5.如果两个浮点数F1、F2位于不同区间,且它们的区间距离为d(d>0,d2W),则它们之间的平均LZC(F1F2)可近似为[(W-1-log2d)2W+1+2d]/(2W+1-d),近似的平均相对误差约为1%~2%.证明.将符号部分与指数部分共W+1位,类比于引理4中的尾数部分t位,除物理意义不同外,所有的推算不变.根据引理4的命题1,即得引理5的近似值.同样根据引理4可知若d∈[2j+1,2j+1],准确结果为[(W-j)2W+1-2W+1-jd+2d]/(2W+1-d),近似的相对误差为[(j-1+2-jd)-log2d]2W+1/[(W-j)2W+1-2W+1-jd+2d].因这时的区间距离为指数部分之差,即使实际值与预测值之间差1030倍,它们之间的区间距离d也只是为100(2100≈1030).也就是说,d的取值通常较小.为了对近似所引起的误差有直观认识,分别取d={1,2,…,100},图3表述了准确值及近似值随d变化的关系.当d∈[1,100]时,计算可知平均相对误差约为1.4%,得证.根据引理2可知,若两个浮点数F1、F2的符号位相同,且两者中绝对值较大者与绝对值较小者的比值为r(r1),则当r<2时,F1与F2有可能位于同一区间(概率为2/r-1)或者相邻区间(概率为Page6图3LZC(F1F2)的近似值和准确值之间的误差2-2/r);当r2时,F1与F2则不可能位于同一区间.r<2的情况.此时,若F1与F2位于同一区间,设所在区间的绝对值最小值的浮点数为B,此时F1的范围为[B,2B/r),区间内距离d∈[(r-1)×2t,(2-2/r)×2t).当r∈(1,4/3]时,(r-1)×2t2t-1且(2-2/r)×2t2t-1;当r∈(4/3,3/2]时,(r-1)×2t2t-1且(2-2/r)×2t>2t-1;当r∈(3/2,2)时,(r-1)×2t>2t-1且(2-2/r)×2t>2t-1.设引理4中的W+1+[(t-2-log2d)2t+2d]/(2t-d)为f(d),因为∫f(x)dx=(W-1)x-t2tln(2t-x)+其中Li2()为二重对数(dilogarithm)函数.所以,当F1与F2位于同一区间,LZC(F1F2)同为3-r-2()r×2t×∫(2-2/r)×2t2-2()r2t(W+1)+∫2t-1烄(r-1)×2t烅3W+1,烆将式(12)代入式(13),并进行化简后可得当r∈(1,4/3]时,式(13)成为W-1+当r∈(4/3,3/2]时,式(13)成为W-1+再根据引理5,LZC(F1F2)异为[(W-1)2W+1+2]/(2W+1-1),再根据F1与F2有2/r-1的概率同区间,有2-2/r的概率位于相邻区间,故LZC(F1F2)=LZC(F1F2)同×(2/r-1)+r2的情况.此时,根据引理2可知有2log2r/r-1的概率F1与F2的区间距离为log2r,2-2log2r/r的概率两者的区间距离为log2r.此时的平均区间距离可近似为log2r,再根据引理5,可知此时的平均LZC(F1F2)为设原始浮点数及预测器的预测值分别为F与珟F,当两者符号位相同时,此时的最大预测误差err为r-1(err珟F/F-1).而因为F与珟F共有LZC(F珟F)个前导零,假设极限情况时冗余前导零的信息量趋近零,则此时的压缩比Rc为(W+1+t)/[W+1+t-LZC(F珟F)].根据式(13)~(17),图4描述了最大预测误差err与压缩比Rc之间的关系.此关系仅适用于F与珟F符号位相同的情况,当符号位不同时,因此时的LZC(F珟F)为0,故采用其他方法进行压缩(见第3.3.2与3.3.3节).从图4中可见,预测的准确性直接影响到压缩比.当相对预测误差小于1时,压缩比以较快的下降速度从25下降到1.2左右.当相对预测误差从1增加到10300时,压缩比也缓慢地由1.2降低到1.01.分析表明,为了得到较高的压缩比,就必须使用较准Page7确的预测算法,或者混合使用多种预测算法.进行高性能科学数据压缩的关键在于根据浮点数的存储格式,设计先进的预测算法,并对原始值F与预测值珟F之间的差值进行高性能编码.本文所提出的科学数据高性能无损压缩系统的结构如图5所示.系统结果主要分为预测和编码两部分,将在以下章节中对其进行详细分析.3.3.1数据预测根据图4,数据预测的准确性直接关系到最终的压缩比.因科学数据的不同,使用单一的预测算法往往不能永远得到很好的预测精度,而预测精度的下降将会导致压缩比的急剧下降.为此,有必要使用混合式预测算法,同时采用多种预测器,然后再在多个预测结果中选择最接近真实值的预测结果.但采用多种预测算法也会带来一定的负面影响,首先,会增加编码器和解码器的复杂性.虽然在多处理器系统上或者使用硬件实现时,多个预测器可以并发工作,但对多个预测器进行同步仍会影响到系统的效率.而在串行系统上,预测部分的执行时间会随着预测器数目的增多而线性增加.其次,预测之后需要记录预测器的编号以用于解码,从而会增加需要编码的数据量.为了在预测精度和速度之间取得一个平衡,本文使用2个预测器,一个用于预测比较平缓的数据,另一个差分预测器用于预测变化的数据.如图5所示,普通预测器以Fi的值作为索引,查找预测表,得出Fi+1的预测值珟Fi+1,珟Fi+1与Fi+1的异或值将会送给选择器和前导编码器进行编码.对于差分预测器而言,区别在于预测器是根据Fi-Fi-1来得到Fi+1-Fi的预测值.所以差分预测器的输入是Fi-Fi-1,而其输出与Fi求和之后作为Fi+1的预测值珟Fi+1.差分预测器的工作机理决定了差分预测器能较好地预测线性增长的数据(一阶差).因普通浮点数的加减法有时是不可逆的,因此图5中的求和器使用的是与浮点数二进制相对应的整数的加减法.本文采用的普通预测器为FCM[14],采用的差分预测器为DFCM[15].实验表明,这两种预测器对于浮点数据能有较好的预测精度.为了减少预测表的存储空间,本文采用Hash表的方式来存储预测表.而在实现时,本文使用前面若干个真实值的组合作为Hash表的索引,来得到预测值,从而增加预测的精度[8].3.3.2异或编码和前导编码在得到真实值F的预测值珟F之后,本文将使用熵编码方法来编码F与珟F的“差值”ΔF.具体来说,本文将ΔF定义为F珟F,并将ΔF分为前导零部分和非零部分.对于前导零部分将使用熵编码进行压缩传输,而对于非零部分将进行非压缩传输.设ΔF的符号位为S,设除符号位外,ΔF的最后非零位在第k位(k∈[0,W+t-1]),则当ΔF非零时,使用熵编码传输S与k,再无压缩传输的后k位(当k=0时,无需传输非零部分).当ΔF为零时,则只需要使用熵编码传输0.本文的ΔF定义与文献[7]的定义相同,但不同于文献[7]直接传输ΔF,本文根据浮点数的存储结构,将ΔF分为符号位和非符号位分别处理.对于符号位和前导零,使用快速的变长熵编码压缩方式,从而可以获得更高的压缩比.比如:若F与珟F分别为-0.01和0.011,这时的ΔF所对应的16进制表示为8002FDCA45A25DC1.若使用本文的方法,除了前导零熵编码之外,只需要存储后面的49位,而文献[7]的方法则需要存储所有的64位,还需要4位来定长编码前导零.文献[4]将ΔF定义为F-珟F,虽然这种定义更为直接,主要的缺点包括:(1)因直接对浮点数的减法有时并不可逆,即使用F-珟F得到ΔF,但用珟F+ΔF并不一定能准确无损地得到F.特别是当编码器和解码器位于不同的系统,使用了不同的编译选项时更是如此.然而,对于现实中的科学数据压缩,不可能要求编码和解码都在同一系统上,使用同一程序完成.所以,在对F与珟F进行减法操作前,就必须将它们映射成整数进行操作.若采用常规的映射方法,则最小正浮点数将会映射成00…0,而最大负浮点数将会映射成10…0,从而使得两者的整数距离很大.为解决这个问题,文献[3-4]都采用特别的映射方法.这种额外的映射将会增加编码器的复杂度,并降低编解码的效率.(2)需要记录ΔF的符号位信息.因ΔF大于零及小于零的概率基本相等,所以即使使用熵编码,也需要约1比特来存储符号位信息.Page8总体而言,实验表明,两种ΔF定义所获得的压缩比没有明显区别,但本文所采用的方式在编解码速度上更为高效.3.3.3高效熵编码通过图5所示的“选择与前导编码器”之后,输出数据包括预测器标志位C(1位),ΔF的符号位S(1位)以及除符号位外,ΔF的最后非零位位置k.k的范围为[0,W+t-1].本文使用k=W+t来特别标记除符号位外,ΔF的其他位全零的情况.故熵编码的输入为三元组〈C,S,k〉.本文使用(k2+C1+S)的移位运算将三元组转换成整数,再使用熵编码器对该整数进行编码.本文选择Range编码[16]作为熵编码方法.Range编码的机理与算法编码类似,但与算术编码的输出以位为单位不同,Range编码的输出以字节为单位.所以,在现代计算机系统结构下,Range编码的速度会比算法编码要快,且压缩比类似.同时,Range编码不受专利的限制,可以自由使用在科学研究系统中.本文选择准静态概率模型(QuasistaticProba-bilityModel)[17]作为Range编码器的概率模型.准静态概率模型并不在编码每个符号后都更新概率表,而只在每编码若干个符号之后,才更新一次概率表.通过准静态概率模型和Range编码器,本系统的熵编码部分能在编码效率和压缩比之间取得良好的平衡.熵编码后的三元组与ΔF的后k(k可能为0)位通过同步混合,从而形成了最终的压缩数据流.3.3.4解码器与编码器相对应的解码器结构如图6所示.普通预测器根据Fi得到预测值珟Fi+1,1,差分预测器根据Fi和Fi-1得到预测值珟Fi+1,2.压缩数据流通过熵解码,得到三元组〈C,S,k〉.前导解码器根据S和k进行前导解码,得到ΔF.“2选1”处理根据C来决定是用珟Fi+1,1还是珟Fi+1,2来作为珟Fi+1.最后,通过异或珟Fi+1与ΔF得到Fi+1.4性能评估及推广应用4.1性能评估与分析下面通过将本文提出的科学数据无损压缩方法与其他的压缩方法在压缩速度和压缩比两方面进行比较,从而说明本文提出的科学数据无损压缩方法在速度和效果两方面的高性能.4.1.1评价指标主要的评价指标包括:(1)压缩比.压缩之前数据量与压缩之后的数据量之间的比值.为了减少极大值的影响,本文采用几何平均值作为多个数据压缩比的平均值.(2)吞吐量/速度.单位时间内能处理的数据量的大小.分为压缩吞吐量和解压缩吞吐量,以Mb/s或MB/s为单位(1MB/s=8Mb/s).运算吞吐量与运算时间成反比,若压缩吞吐量为XMB/s,则意味着每压缩1MB的数据需要1/X秒.(3)内存使用量.压缩比与内存使用量之间的关系.4.1.2实验环境为了说明本压缩算法的适用性,实验在一台普通的笔记本电脑上进行.处理器为1.83G的32位Intel双核CoreDuoT2400.为了减小并行双核的影响,在BIOS中禁用了双核功能.该处理器的L2缓存为2MB,前端总线为667MHz.系统内存为双通道DDR2667MHz2GB(1GB×2).操作系统为UbuntuLinux8.04(Hardy),内核版本为2.6.24-24.程序采用gcc4.2.4(g++)编译,编译选项只简单的使用了”-O3”选项.4.1.3实验设计为了与其他压缩算法具有对比性,本文没有刻意对具体实现进行优化.所有的输出均重定向到了/dev/null.测试数据集采用文献[8]的科学数据.参与比较的压缩算法和软件包括Bzip2、FPC[8-9]、Gzip和PLMI[4].为了使所有的输入文件都缓存到内存,所有的程序都执行了5遍,以最短的时间作为执行时间.所有的时间值以系统的time命令所得出的用户态和内核态(系统态)时间之和为准.内存使用量以系统报告的为准.4.1.4分析与评价通过对各种算法分析比较,得出了压缩比比较表,如表1所示.其中Bzip2和Gzip均采用1~9压缩等级中最好的结果.FPC采用1~25压缩等级中最好Page9的结果.各种数据上最优的压缩结果采用粗体标出.msg_bt1.1021.2881.1301.1991.374msg_lu1.0211.1731.0551.1341.266msg_sppm6.9335.2987.4313.2497.760msg_sp1.0751.2621.1081.1121.360msg_sweep3d1.2943.0891.0921.3304.036num_brain1.0431.1641.0641.2451.244num_comet1.1731.1571.1621.2651.249num_control1.0301.0501.0581.1241.147num_plasma5.78915.0481.6081.063227.0obs_error1.3393.6031.4481.3654.421obs_info1.2172.2731.1541.0562.544obs_spitzer1.7521.0271.2321.0751.101obs_temp1.0241.0191.0361.0881.100算术平均1.9842.9581.6601.33119.662几何平均1.5201.9451.3471.2632.702由表1可看出,本文提出的方法在大多数数据集上明显优于其他压缩算法.因为“num_plasma”数据的重复率比较大,且变化较缓慢,从而预测精度较高,预测误差前导零的个数多,熵编码效率高,所以得到了高达227的压缩比.所得到的算术平均压缩比和几何平均压缩比也明显高于其他算法.为了减少极大值对平均值的影响,以下均以几何平均值为准.图7描述各种方法及其相应的各种压缩等级与几何平均压缩比之间的关系.从图7中可看到,多数压缩算法的平均压缩比只能达到1.5,FPC的平均压缩比最高可达1.94(压缩等级为25),此时FPC算法需要514MB的内存空间(图8).而本文算法的平均压缩比最高可达2.7(压缩等级为25),远高于其他算法.当压缩等级为18时即可得到1.97的平均压缩比(图7),此时本文算法所需要的内存空间仅为7MB(图8).所以,不难看出,不管是在最重要的压缩比上,还是空间复杂度上,本文的算法均要远优于其他算法.图8各种方法的平均压缩比与内存使用量之间的关系图9描述了压缩比与系统压缩吞吐量之间的关系.当使用”catfile>/dev/null”实测不压缩时(压缩比为1),系统的最大吞吐量为12Gb/s.故所有的吞吐量均根据系统最大吞吐量进行了均一化.从图中可看到,所有其他算法的吞吐量都随着压缩比的增加而急剧减少,而本文方法的吞吐量随着压缩比的变化基本保持不变.FPC方法在低压缩比时拥有较高的吞吐量.但当压缩比较高时(>1.8),FPC算法的吞吐量与本文相近.而在此时,FPC算法需要的内存远高于本文方法.图9各种方法的平均压缩比与压缩吞吐量之间的关系以上的实验结果及分析表明:(1)本文所提出的科学数据无损压缩方法的压缩比均远优于其他算法.本文方法的最高平均压缩比可高达2.7,而其他算法的最高平均压缩比只能达到1.94.(2)本文方法的空间复杂度(内存使用量)同样优于其他算法.在低压缩比(1→1.7)时,各种算法的内存使用量相近,均为2MB左右.而当中等压缩比(1.7→2)时,本文方法的内存使用量远低于其他算法.只有本文方法能达到高压缩比(>2).(3)本文方法的压缩吞吐量随着压缩比的变化基本保持恒定.在低压缩比时,系统吞吐量优于Gzip,远优于Bzip2,但低于FPC.当中等和较高压Page10缩比时,吞吐量与FPC相近.4.2压缩其他格式的浮点数数据虽然之前所描述的算法以及性能评估都是以64位浮点数为例,但本科学数据无损压缩方法同样适用于其它格式的浮点数数据,比如32位的浮点数和128位的浮点数数据压缩.数据的压缩比与科学数据的本身精度相关.64位浮点数能表示的范围比32位浮点数更宽,且精度更高.对于同一个应用而言,相比32位浮点数而言,当使用64位浮点数存储时,对存储位的利用率更高.如当存储圆周率PI时,若使用32位浮点数,需要用到1个符号位、1个指数位和23个小数位(总体利用率78%);而若使用64位浮点数,需要用到1个符号位、1个指数位和52个小数位(总体利用率84%).所以,对同一个应用,32位数据比64位数据稍易进行压缩.根据式(14),也可得到类似的结论.当预测误差为1%(r=1.01)时,若使用的是32位浮点数,根据式(14)知可压缩的前导零数目约为13.2,压缩比约为1.7.而若使用的是64位浮点数,同样根据式(14)知可压缩的前导零数目约为16.2,压缩比约为1.34.4.3应用本文方法主要应用于科学计算中二进制原始浮点数据的无损压缩.因压缩后的数据小于原始数据,采用压缩算法有利于节省存储空间及减少数据传输时间.若用户需要将一个1GB的数据通过网络从一个地点传输到另一地点,即使采用的是100Mb/s的高速以太网(实际速率约为10MB/s),在最理想情况下需要的传输和存储时间为100s,且接收者需要存储1GB的数据.为了减少需要传输和存储的数据量,许多科学计算工作者采用通用压缩工具(如Gzip)压缩数据.仍以上述分析为例,Gzip使用默认参数时几何平均压缩比约为1.34,压缩吞吐率约为16MB/s,解压缩吞吐率约为75MB/s.考虑到压缩,解压缩和传输可由处理器和网络适配器同时进行,若在传输的同时进行压缩和解压缩,则总时间只由系统瓶颈决定.由图9可知,除Bzip2外,各压缩算法的吞吐率均大于10MB/s,大于网络传输速率.在计算与传输重叠时,总时间约为(1000MB/1.34)/(10MB/s)≈74.6s;计算与传输串行时,总时间约为74.6s+1000MB/(16MB/s)+1000MB/(75MB/s)≈150s.且只需要存储746MB的数据.而若采用本文方法,当几何平均压缩比为2.7时,压缩吞吐率约为29MB/s,解压缩吞吐率约为25MB/s.在计算与传输重叠时,总时间约为(1000MB/2.7)/(10MB/s)≈37s;计算与传输串行时,总时间约为37s+1000MB/(29MB/s)+1000MB/(25MB/s)≈111s.且只需要存储370MB的数据.由此可见,在计算与传输重叠时,通过压缩数据带来的性能提升是很明显的.即使在计算与传输串行时,也能在速度相近的情况下,大幅度减少需要的存储空间.而实际的互联网传输速率往往远低于100Mb/s,以ADSL宽带为例,最大上行速率512kb/s,最大下行速率8Mb/s(=1MB/s),导致传输时间大大增加,从而采用本文方法的效果更为明显.本文方法已被应用于颗粒材料的大规模动力学过程仿真中.主要包括颗粒材料的堆积过程模拟研究和颗粒的相分离现象模拟研究.在这些仿真中,涉及到107规模的颗粒体在真三维环境中的动力学过程,每个模拟步产生数GB的数据.为了对这些海量数据进行存储,必须使用本文的高性能无损压缩方法.这些应用的具体信息请参见文献[18-21].5总结及未来工作本文提出了高性能的科学数据无损压缩算法.通过与其他算法进行比较,本文所提出的方法的压缩比均远优于其他算法,最高平均压缩比可高达2.7,而其他算法的最高平均压缩比只能达到1.94.本文方法的空间复杂度(内存使用量)同样优于其他算法.在低压缩比(1→1.7)时,各种算法的内存使用量相近,均为2MB左右.而当中等压缩比(1.7→2)时,本文方法的内存使用量远低于其他算法.同时,本文方法在低、中、高压缩比时,均具有高吞吐量的特点,数据处理能力在中、高压缩比时远高于通用压缩算法.本文提出的方法特别适合海量科学数据的高压缩比无损传输和存储.在本文中,只考虑了前导零的熵编码,在接下来的研究中将继续考虑后缀零的影响.同时,因为预测算法和预测精度对于压缩比至为关键,在后续研究中还将考虑其他多种预测算法以及基于概率模型的预测算法自适应选择和混合.在应用方面,除了已应用了本文方法的大规模颗粒动力学模拟之外,还将根据其他大规模实际科学计算和工程仿真的需求,对本文方法进行进一步推广和改进.Page11
