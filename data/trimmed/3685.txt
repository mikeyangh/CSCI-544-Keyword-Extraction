Page1无线传感器网络中Skyline节点连续查询算法信俊昌王国仁(医学影像计算教育部重点实验室(东北大学)沈阳110819)(东北大学信息科学与工程学院沈阳110819)摘要作为多目标决策的重要手段之一,Skyline节点查询在传感器网络应用中发挥着非常重要的作用.文中深入地分析了Skyline节点查询的性质,提出了基于过滤的Skyline节点连续查询算法(FIlterbasedSkylinemoniToringalgorithm,FIST).FIST算法共包括自底向上、自顶向下和混合3种过滤方式,均通过在传感器节点设置本地或全局过滤器来避免不必要的数据传输,进而节约传感器节点的能量.自底向上过滤方式通过缓存先前Skyline结果作为本地过滤器来避免数据重复传输,而自顶向下过滤则通过设置超立方体作为全局过滤器来避免数据反复更新.由于两者各有利弊,因而提出了混合过滤方式,通过为节点选择合适的过滤器来扬长避短.大量仿真实验的结果表明,FIST算法能有效地减少Skyline节点连续查询过程中传感器节点的通信代价,进而降低传感器网络的能量消耗.关键词无线传感器网络;Skyline节点查询;能量有效性;过滤1引言随着传感技术、通信技术和嵌入式技术的发展,无线传感器网络(WirelessSensorNetwork,WSN)在安全防御、交通管理、医疗卫生和灾难预防等领域得到了非常广泛的应用[1-2].由于硬件发展水平的限制,传感器节点通常利用电池作为电源.由于传感器网络大都工作在湖泊、沼泽、沙漠和火山口等人类不易接近的恶劣环境中,更换电池或者为电池充电都是十分困难的.因此,能量高效性是无线传感器网络应用所面临的主要挑战之一.作为多目标决策的重要手段之一,Skyline查询得到了广泛的研究[3-4].在d维数据库D中,如果对象p在任何一维都不比对象q差,并且在至少一维比对象q好,那么对象p支配对象q.D中所有不被其它任何对象所支配的对象构成了D的Skyline.如图1所示,虚线上的n1、n2和n6构成了图中数据的Skyline.在一些传感器网络应用中,用户往往只关心哪些节点是Skyline节点,而不关心Skyline节点感知数据的具体数值,称之为Skyline节点查询.例如,在森林监控应用中,若某个地点温度高、湿度低,则该林区更容易发生火灾;反之,则不容易发生火灾.因此,护林员只需要知道哪些林区是火灾的高危区,而不需要知道高危林区温度与湿度的具体数值,即可实现对高危林区的重点防控.此时,护林员可以只需向部署在林区的传感器网络发送Skyline节点连续查询,就可以时刻知道哪些林区具有高温度、低湿度,从而第一时间发现火灾隐患并采取措施防止火灾的发生.已有算法大都假定数据保存在一个集中式服务器并且在该集中式环境下计算Skyline.由于无线通信对节点能量消耗的巨大影响,将所有的感知数据都收集到基站是不可取的,因而需要研究能量高效的分布式算法处理传感器网络中的Skyline节点查询.通过分析Skyline节点查询的性质,提出了一种新颖的基于过滤的Skyline节点连续查询算法(FIlter-basedSkylinenodemoniToringalgorithm,FIST)连续查询传感器网络中的Skyline节点.FIST算法通过在传感器节点设置本地或全局过滤器来抑制不必要的数据传输,进而节约节点的能量.根据过滤器的设置规则,FIST算法可以分为自底向上过滤、自顶向下过滤和混合过滤3种方式.本文的主要贡献点如下:(1)提出了本地过滤器和全局过滤器,深入地分析了两种过滤器的有效性.(2)以上述过滤器为基础,提出了自底向上、自顶向下和混合共3种连续Skyline节点查询过滤机制.(3)设计了详尽的性能评价实验,实验结果表明FIST算法极大地降低了连续Skyline节点查询过程中传感器节点的数据传输量.本文第2节介绍相关的研究工作;第3节对研究的问题进行描述和分析;第4节介绍基于过滤的Skyline节点连续查询算法FIST;第5节通过实验对FIST算法的性能进行验证;最后,第6节总结全文.2相关工作Chen等人[5]研究了传感器网络中的连续Skyline查询问题,提出了基于层次型路由结构的过滤算法MINMAX来减少网络中的数据传输量.文献[6-7]研究了传感器网络中的滑动窗口轮廓查询.前者提出了一种基于元组过滤器和格过滤器的算法来连续地查询传感器网络中的滑动窗口轮廓;后者提出了基于映射的过滤方式来提高计算的性能.通过映射函数将感知数据映射到整数空间,再以整数空间的Skyline作为过滤器来减少网络的数据传输量.文献[8]研究了传感器网络中的多Skyline查询优化问题,提出了基站与节点两阶段优化的多Skyline查询算法.Shen等人[9]研究了传感器网络中基于位置的二维Skyline查询并提出了按照距离从近到远的顺序计算每个环中的Skyline的Ring-Skyline算法.Su等人[10]提出了基于聚簇型路由结构的以数据为中心的Skyline查询算法SkySensor.SkySensorPage3算法通过不同节点发出的多个Skyline查询共享同一感知数据搜集过程来降低每个查询的能量消耗进而提高查询的执行效率.3预备知识在本节中,首先详细阐述传感器网络中的Skyline节点查询;接着,分别介绍本地过滤器和全局过滤器并且深入分析两种过滤器的过滤原理和有效性.3.1问题描述询的定义如下.基于Skyline查询的基本概念,Skyline节点查定义1.传感器网络中的Skyline节点查询返回所有不被其它节点所支配的节点.节点ni支配节点nj当且仅当节点ni的感知数据ri支配节点nj的感知数据rj,即在任何一维ri都不比rj差(k,ri.vkrj.vk),并且在至少一维比rj好(l,ri.vl<rj.vl).利用集中式算法在基站计算Skyline节点是实现Skyline节点连续查询的最基本也是最“昂贵”的方式.由于Skyline节点查询可分解[6],可以利用网内计算技术[11]的方式来提高算法的能量有效性.如图2所示,传感器节点n1、n2、n3、n4和n5构成了一棵以n1为根的路由树.节点旁边表格里显示的是连续3个时刻对应节点采集的感知数据.其中,第1列是数据的采集时刻,其余两列则是具体的感知数值.集中式算法需要将所有感知数据传输到基站,那么3个时刻共传输33个元组.而利用网内计算技术[11],则每个节点只需传输以自己为根的子树的局部Skyline结果,避免了只属于局部Skyline而不属于全局Skyline的元组的传输,那么3个时刻只需要传输21个元组.然而,在网内计算方法中,仍然有大量的无用数据在网络中传输.例如,节点n4在第2个时刻的感知数据为(65,33),由于该数据只被节点n3的感知数据支配,会被依次地传输到n2和n1,而实际上,(65,33)不属于最后的Skyline结果,因此节点n4并不是Skyline节点.基于过滤的FIST算法的目标就是减少网络中类似的不必要的数据传输.传感器节点采集的传感数据是对周围环境的温度、湿度和光照等连续物理量的离散采样,因此,不同时刻的传感数据之间具有非常密切的时间相关性[12].因而可以利用统计信息在节点设置过滤器,利用过滤器阻止不必要的数据传输.根据过滤器的产生方式,可以将其分为本地过滤器和全局过滤器.3.2本地过滤器本地过滤器的基本思想是每个传感器节点保存前一个时刻的Skyline作为过滤器用来避免相同数据的重复传输.同时,父节点也保存本地过滤器的一个副本以便保持两者之间的同步.如果节点采集的感知数据属于局部Skyline并且与前一时刻的感知数据相同,由于该感知数据已经存储于父节点的副本中,因而不需要将其传输到父节点;只有感知数据虽属于局部Skyline却与前一时刻的感知数据不同,才需要将其传输到父节点.由于该类过滤器是传感器节点根据自身的局部Skyline设置的,使用的是本地信息,所以称之为本地过滤器.如图2所示,每个传感器节点都设置了一个本地过滤器,即时刻0的局部Skyline.本地过滤器中每个元组的第一个元素表示感知数据的节点编号,其余元素为感知数据的数值.例如,传感器节点n2的本地过滤器包含元组(2,12,43)和元组(4,63,36).在时刻1,节点n4的感知数据从(63,36)变成了(65,33),其余节点的感知数据没有发生变化.此时,节点n4的局部Skyline变为(4,65,33),由于没有包含在本地过滤器中,因此需要传输给它的父节点n2.节点n5的局部Skyline未发生变化,因此不需向父节点n2传输数据.接着,节点n2根据从n4接收到的更新信息和本地存储的信息计算得到局部Skyline{(2,12,43),(4,65,33)}.元组(2,12,43)与过滤器中的元组相同,不需要进行传输;而元组(4,65,33)与过滤器中的元组不同,需要传输到父节点n1.由于节点n3的局部Skyline没有发生变化,因而不向节点n1发送消息.接着,节点n1计算新的局部Skyline,发现局部Skyline结果与本地过滤器完Page4全相同,因此不需要向父节点n1传输任何数据.最后,基站没有收到任何更新信息,可以判定时刻1的Skyline与上时刻的Skyline相同.时刻2和时刻3的处理过程与时刻1的处理过程类似.这样在3个连续时刻共有9个元组在传感器网络中传输,与网内计算[11]相比节约了12个元组的数据传输代价.3.3全局过滤器当传感器节点采集的感知数据不稳定时,本地过滤器的过滤效果将会变得很差.利用全局知识为每个传感器节点设置一个超立方体作为过滤器来阻止无用数据传输是一个很自然的想法.基站中也同步保存着这些超立方体过滤器的副本以便基站可以随时了解感知数据分布的大致情况.传感器节点只向基站报告超出了超立方体的范围的感知数据,而基站则根据超立方体过滤器的副本和接收的感知数据更新信息来求解Skyline节点集合.根据超立方体之间的关系,传感器节点可以划分为Skyline节点、非Skyline节点和未确定节点3类.基站需要获取未确定节点的感知数据来得到最终的Skyline节点集合.首先,分析超立方体之间的关系;接着,介绍如何判断一个节点是Skyline节点还是非Skyline节点.定义2.给定两个区间a(a.l,a.u)和b(b.l,b.u).如果a.ub.l,则称之为区间a支配区间b,记为ab;如果a.l<b.l且a.u>b.l,则称之为区间a和b关系不确定,记为a?b.图3中给出了区间a和区间b之间相互关系的例子.超立方体可以表示为I1×I2×…×Id.在区间关系的基础上,超立方体之间的关系如定义3所示.定义3.给定两个超立方c和d.如果在所有维超立方体c的区间均支配d的区间,则称之为超立方体c支配超立方体d,记为cd;如果在某一维超立方体c的区间支配d的区间,而在另外一维超立方体d的区间支配c的区间,则称之为超立方体c和d互相不支配,记为c<>d;在其余情况下,超立方体c和d的关系并不明确,称之为超立方体c和d之间的支配关系不确定,记为c?d.图4中详细地描述了二维环境下超立方体c和超立方体d之间的上述3种相互关系.之间的关系具有下列性质.hj,则t∈hi,t∈hj,tt.得hihjk,hi.Ik.uhj.Ik.l.k,t.vk>hj.Ik.l,所以k,t.vk<t.vk.设t和t是数据空间中的两个元组,超立方体定理1.给定两个超立方hi和hj,如果hi证明.根据定义3中超立方体之间的关系,可又因为t∈hik,t.vk<hi.Ik.u,并且t∈hj因此,根据支配关系定义可得tt.证毕.定理1说明了什么样的传感器节点可以作为非Skyline节点被提前过滤.下面的引理和定理将说明什么样的传感器节点为Skyline节点.引理1.给定两个超立方hi和hj,如果hi<>hj,则t∈hi,t∈hj,t<>t.证明.根据定义3中超立方体之间的关系,hi<>hjjk,hi.Ikhj.Ik并且l,hj.Ilhi.Il.t∈hi∧t∈hj∧hi.Ikhj.Ikt.vkt.vk,t∈hi∧t∈hj∧hj.Ilhi.Ilt.vlt.vl.因此,根据支配关系定义可得t不能支配t并且t不能支配t,即t<>t.引理2.给定3个超立方hi、hj和hk,相应的元组ti∈hi,tj∈hj,tk∈hk,如果hi<>hj且hjhk,则元组tk肯定不支配ti.证明.用反证法证明.假设tkti,根据引理1,hjhktjtk.因为tkti,所以tjti.又根据引理1,hi<>hjti<>tj,与前面推出的tjti相矛盾.因此,元组tk肯定不支配ti.证毕.定理2.设H={h1,h2,…,hn}是超立方体的集合,T={t1,t2,…,tn}是满足i,ti∈hi的元组集合.同时,设HS=Skyline(H)是集合H的Skyline集合,HN=H-HS是非Skyline的集合.如果HS中的超立方体hi与HS中其它任意超立方体hj之间都满足hi<>hj,那么ti∈Skyline(T).证明.根据定义3,可得hk∈HN,hl∈HS,hlhk.根据已知hj∈HS(j≠i),hi<>hj,可得hi<>hl.根据引理2,hlhk且hi<>hltk∈hk,tk不Page5支配ti.又根据引理1,hj∈HS(j≠i),hi<>hjti<>tj.因此,不存在元组tj∈hj(j≠i)满足tjti,所以ti∈Skyline(T).定理2说明了如何判断一个传感器节点为Skyline节点.如果根据定理1和定理2都无法判断传感器节点到底是Skyline节点还是非Skyline节点,那么该节点为未确定节点.此时,基站需要获取未确定节点的感知数据以消除上述情况带来的影响.显然,超立方体过滤器的效果依赖于需要获取感知数据的未确定节点的数量.由于超立方体过滤器需要基站根据整个传感器网络的统计信息进行设置,使用的是全局信息,所以称之为全局过滤器.首先,基站根据历史信息建立各个传感器节点的感知数据模型,即感知数据的概率密度函数.然后,根据感知数据模型计算一个初始过滤器设置方案,为每个节点计算并设置一个超立方体作为全局过滤器.接着,如果新的感知数据落在超立方体的范围之内,说明没有通过过滤,因而不需要向基站传输任何信息;反之,如果新的感知数据落在超立方体的范围之外,说明通过了过滤,意味着Skyline节点集合可能发生改变,因而需要将感知数据的变化通知基站.基站收到该消息后,意识到Skyline节点集合可能发生变化,重新计算传感器网络中的Skyline节点集合,同时根据需要进行过滤器的调整.给每个传感器节点都设置一个合适的全局过滤器是一个非常复杂的工作,需要解决下面3个问题.(1)感知数据建模.精确的感知数据模型是给每个传感器节点都设置一个合适过滤器的必备条件之一.维护精确的感知数据模型需要频繁的数据更新操作,将消耗节点的大量能量.如何利用较少的能量消耗来维护较为精确的感知数据是需要面临的一个重要挑战.(2)过滤器的设置.通常情况下,需要尽可能地选择更好的过滤器设置方案来减少网络的数据传输量,然而,从大量的过滤器设置方案中选择出最好的方案要花费很大的计算代价.如何利用较少的计算代价得到较好的过滤器设置方案是问题的难点.(3)查询结果维护.如果传感器节点没有向基站提交任何数据更新信息,那么Skyline节点查询的结果保持不变;一旦传感器节点向基站提交了数据更新信息,基站需要根据过滤器设置方案和收到的数据更新信息重新计算Skyline节点查询的结果.如图5所示,根据近期的历史统计信息,基站为传感器节点n1、n2、n3、n4和n5分别设置了超立方体(二维时为矩形)[60,100)×[30,100)、[10,20)×[20,50)、[20,40)×[0,20)、[40,100)×[20,100)和[20,100)×[50,100)作为过滤器.在时刻0和时刻1,全部5个传感器节点的感知数据都在各自的过滤器的内部变化,因此不需要向基站提交任何的数据更新信息.值得注意的是,超立方体[10,20)×[20,50)中的每个元组始终都支配超立方体[20,100)×[50,100)中的所有元组,因此节点n2的感知数据支配节点n5的感知数据,即节点n2支配节点n5.同样地,节点n3支配节点n1和节点n4.同时,由于超立方体[10,20)×[20,50)中元组的第一维都小于超立方体[20,40)×[0,20)中元组的第一维,并且超立方体[10,20)×[20,50)中元组的第二维又大于超立方体[20,40)×[0,20)中元组的第二维,因此,超立方体[10,20)×[20,50)和[20,40)×[0,20)中的元组互相不支配,也即是节点n2和节点n3互相不支配.根据上述分析可知,无论是时刻0还是时刻1,网络中的Skyline节点集合始终为{n2,n3}.在时刻3,节点n2的感知数据变为(2,23,18),超出了超立方体过滤器[10,20)×[20,50)的范围,因此需要向基站提交感知数据更新信息.新的元组(2,23,18)与超立方体[20,40)×[0,20)和[20,100)×[50,100)在某些维度空间存在着交集,导致了节点n2与节点n3和n5之间的关系无法确定,意味着无法直接判断哪些节点为Skyline节点.因此,基站需要获取节点n3和n5当前的感知数据消除Skyline节点集合的不明确性.在这个过程中,一共需要在传感器网络中传输7个元组的数据包和1个广播包.Page63.4过滤器开销分析传感器节点n的本地过滤器由以n为根的路由子树的局部Skyline节点的感知数据构成,如果以n为根的路由子树包含的节点数目为s,则节点存储本地过滤器的空间复杂度为O(logd-1s)[13],其中d为感知数据维数.由于本地过滤器完全由节点维护,因而未给基站带来任何的额外开销.传感器节点n的全局过滤器由基站分配的超立方体构成,因此全局过滤器的空间复杂度为O(d),其中d为感知数据维数.需要注意的是,当传感器节点数目增加时,Skyline节点的数量也相应增加,全局过滤器的粒度将越来越小,其过滤效果当然也逐渐削弱.因此,全局过滤器更适合于中小规模的传感器网络,如何在大规模网络环境下进行过滤将是未来的研究工作之一.全局过滤器的初始化和维护均需要基站发送大量的信息,因而假设基站具有持续的能量供应并且无线通信范围可以覆盖所有的传感器节点[14],换言之,基站发送的广播信息可以不经过任何节点的转发而直接发送到所有的传感器节点.此时,基站的能量消耗将不会影响传感器网络的使用寿命,全局过滤器的优化效果将非常显著.顺便提一下,如果基站使用多跳的方式向传感器节点发送消息,FIST算法同样有效,只是优化效果略微有所下降.4基于过滤的Skyline节点连续查询4.1自底向上方式在自底向上方式的初始阶段,可以利用网内计算[11]的方法得到各节点的局部Skyline作为本地过滤器.在算法后续执行过程中,为了动态地维护本地过滤器,传感器节点除了需要保存局部Skyline之外,还需要缓存所有子节点的局部Skyline,以便在收到子节点的更新信息后,可以准确地计算出新的局部Skyline.这样,传感器节点需要存储的信息包括以下两个部分:(1)缓存.所有子节点的本地过滤器,即所有子节点的局部Skyline构成的集合.(2)过滤器.本地过滤器,即节点前一时刻的局部Skyline.既然本地过滤器中的信息在父节点中存在完整的备份,那么传感器节点只需要向父节点传输新的局部Skyline与本地过滤器中的Skyline不同的部分即可,包括以下3个部分:(1)当非局部Skyline节点的感知数据发生变化使之成为新的局部Skyline节点时,由于父节点中没有存储任何关于该局部Skyline元组的相关信息,因此它的节点编号和感知数据都需要传输给父节点,以便父节点将其加入缓存.(2)当局部Skyline节点的感知数据发生变化并且仍然为局部Skyline节点时,由于父节点存储的数据不再正确,因此它的节点编号和感知数据都需要传输给父节点,以便父节点可以替换缓存中的数据.(3)当局部Skyline节点的感知数据发生变化并且变为非局部Skyline节点时,只需要将它的节点编号告知父节点,使之将其移出缓存即可.总体上说,传感器节点需要传输的信息共包括两个部分:一个是节点编号的集合,记为Sid;另一个是(节点编号,感知数据)构成的集合,记为St.其中,集合St中的节点既可能是新的局部Skyline节点,也可能是感知数据发生变化的旧的局部Skyline节点.传感器节点修改缓存、重新计算局部Skyline节点集合并且维护本地过滤器的具体过程如算法1所示.首先,传感器节点合并所有子节点发送的更新信息,将其与新采集的感知数据合并得到新数据集(第1~5行);其次,根据Sid集合中的信息,将其中包含的肯定不属于新的局部Skyline的传感器节点移出缓存(第6行);接着,根据St集合中的信息,将新的局部Skyline节点的编号和感知数据插入缓存,同时更新旧的局部Skyline节点的感知数据(第7行);然后,利用缓存中的信息计算新的本地Skyline节点集合(第8行);再计算出新的局部Skyline与本地过滤器间的不同部分,生成发送到父节点的数据包(第9~15行);最后,将新的局部Skyline设置为新的本地过滤器(第16行).算法1.自底向上过滤算法.输入:子节点消息集合M,缓存Cache,本地过滤器输出:提交到父节点的数据包M1.foreachelementminMdo//合并子节点数据2.tempID=tempID+m.Sid;3.tempSet=tempSet+m.St;4.endfor5.tempSet=tempSet+r;//加入本地的感知数据6.Cache.Delete(tempID);7.Cache.Update(tempSet);Page78.S=Skyline(Cache);9.foreachelementpinSdo10.ifpisnotcontainedinFilterthen11.M.Sid=M.Sid+{p.id};12.else13.M.Sid=M.Sid+{p};14.endif15.endfor16.Filter=S17.returnM.另外,当传感器网络规模扩大或者感知数据维数增加时,Skyline结果的数量急剧增加,从而造成本地过滤器的缓存规模过大,无法完全保存在传感器节点的有限内存中.此时,每个传感器节点可以随机或者有选择地选取一个局部Skyline结果的子集作为本地过滤器,选择的元组数量由传感器节点存储能力决定.当传感器节点向父节点传输局部Skyline结果时,将被选中加入本地过滤器的元组打上标签,以便父节点可以将其缓存以便保证父节点与子节点之间的缓存同步.4.2自顶向下方式如前所述,自顶向下的过滤方式主要包括感知数据建模、过滤器的设置和查询结果维护3个主要问题,下面逐一加以阐述.4.2.1感知数据建模感知数据的建模过程就是求解每个传感器节点的感知数据分布满足的概率密度函数.概率密度函数的具体形式由应用环境决定.理论上说,任何形式的概率密度函数都是可行的,只是效率略微有所区别.首先,由网络管理员指定描述感知数据分布的概率密度函数的具体形式;其次,传感器节点利用已有的机器学习算法计算模型中的参数,将所得的参数提交基站;最后,基站根据接收到的参数确定各传感器节点的感知数据模型,根据这些模型计算初始过滤器设置方案.在计算过程中,基站保存所有传感器节点的感知数据模型作为全局信息,以便保持基站与传感器节点之间的同步.感知数据时刻发生着变化,感知数据模型也需随之动态变化.一般情况下,传感器节点需要及时地将感知数据模型的变化通知基站,以便基站能快速地调整过滤器设置方案.然而,当感知数据模型更新频率过高时,模型的维护过程将花费传感器节点巨大的通信代价.利用假设-检验方法可以很好地解决上述问题.如果新采集的感知数据落在超立方体的范围内,说明根据当前感知数据模型计算的过滤器有效,因而认为当前的感知数据模型有效;如果新采集的感知数据落在超立方体的范围外,则利用假设-检验方法来对模型的参数逐一进行检验.在检验过程中,一旦某个参数未通过检验,说明当前的感知数据模型失效,重新计算模型中的参数并且将新参数提交基站.通过上述方式,基站可以及时地根据新的感知数据模型对过滤器的设置方案进行动态调整,从而提高传感器网络的总体运行效率.由于传感器节点通常都携带着多种不同类型的传感设备,因此,采用多元高斯分布对传感器节点采集的多维感知数据进行建模.多元高斯分布是一元高斯分布的扩展,具体函数如式(1)所示:p(狓)=1其中,μ是感知数据分布的均值;Σ为感知数据的协方差矩阵,其对角线元素是对应维度的数据方差,而其非对角线元素是对应两个维度的数据协方差;模型中每维数据对应着传感器节点的一种传感设备.为了便于对感知数据模型进行动态维护,每个传感器节点在保存提交给基站的数据模型f(μ,Σ)的同时,时刻计算并更新着感知数据的重要统计信息,如均值珡X和协方差矩阵犛等.当新采集的感知数据没有通过过滤器时,认为感知数据模型有效,不需要进行任何处理;一旦新采集的感知数据通过了过滤器,则认为感知数据模型可能会失效,对感知数据模型进行假设-检验.在假设-检验过程中,首先进行均值的检验,检验方程如式(2)所示:T2=n(珡X-μ)Σ^-1(珡X-μ),Σ^=犛一旦T2的数值大于指定的阈值,说明均值μ检验失败,需要重新计算感知数据模型并将新模型的参数提交基站.如果通过了均值检验,则继续进行方差检验,检验方程如式(3)所示:L=(n-1)[ln|Σ|-p-ln|Σ^|+tr(Σ^Σ-1)],Σ^=犛同样,当方差Σ检验失败时,需要重新计算感知数据模型并将新模型的参数提交基站.基站可以根据新模型对过滤器的设置方案进行动态调整.通过假设-检验可以有效地避免感知数据模型的频繁更新,节约了传感器节点巨大的通信代价.同Page8时,假设-检验的时间复杂度是o(d2),与巨大的通信代价相比,计算过程只消耗较少的能量,可以忽略不计.4.2.2过滤器的设置当所有传感器节点的感知数据均未通过本地过滤器的过滤时,基站不需要从网络中获取任何辅助信息就可以根据过滤器设置方案FS={hi|i=1,2,…,|N|}准确地计算出网络中的Skyline节点集合,那么该方案就是一个合理的过滤器设置方案.不失一般性,将传感器节点分为候选Skyline节点和候选非Skyline节点两类,分别用NS和NN表示.显然,可行的过滤器设置方案需要满足{ni|hi∈Skyline(FS)}=NS.定理3.设H={h1,h2,…,hn}是超立方体的集合,HS是H的一个子集.如果HS中的任意两个超立方体hi和hj满足hi<>hj,同时对H-HS中任何超立方hk,HS中都存在一个hl满足hlhk,那么,HS=Skyline(H).可行的过滤器设置方案可以保证当所有传感器需要满足以下两个条件:证明.(1)Skyline(H)HS:根据已知条件可知,H-HS中任何超立方hk都不属于Skyline(H),所以可得Skyline(H)HS.(2)HSSkyline(H):根据已知条件,HS中的任意两个超立方体hi和hj都满足hi<>hj,可知HS中的任何一个超立方体hi都属于Skyline(H),所以HSSkyline(H).综上所述,HS=Skyline(H).证毕.根据定理3,一个可行的过滤器设置方案至少(1)NS集合内的传感器节点的超立方体过滤器之间互不支配,即ni,nj∈NS,hi<>hj.(2)NN集合内的传感器节点的超立方体过滤器需至少被NS集合内的一个传感器节点的超立方体过滤器所支配,即nj∈NN,ni∈NS,hihj.如果过滤器设置方案满足上述两个条件,那么当传感器节点采集的感知数据都在各自的超立方体过滤器内变化时,NS集合中所有的传感器节点共同构成了网络中的Skyline节点集合.图3中的候选Skyline节点集合NS={n2,n3};候选非轮廓节点集合NN={n1,n4,n5},传感器节点设置的过滤器满足上述两个条件.在时刻1和时刻2,由于没有任何感知数据的更新消息提交基站,因而Skyline节点集合始终为{n2,n3}.节点的感知数据都在各自的超立方体过滤器内变化时,不需要在网络中传输任何数据信息就能准确地计算出Skyline节点集合.因此,可以认为这种情况出现的概率越高,过滤器设置方案的过滤效果越好,如式(4)所示:满足:(1)ni,nj∈NS,hi<>hj.(2)nj∈NN,ni∈NS,hihj.将条件中的超立方体之间的关系转化为感知数据的关系,可以得到式(5):且hj.Il.lb>hi.Il.ub.满足:(1)ni,nj∈NS,k,l∈D,hj.Ik.ub<hi.Ik.lb(2)nj∈NN,ni∈NS,k∈D,hi.Ik.ub<hj.Ik.lb.过滤器设置方案在计算一个非线性约束的非线性优化问题时,计算的空间代价和时间代价都很高.为了适应传感器网络应用的需要,通过放宽上述两个约束条件来减少计算的复杂度.首先,对于NS中的任何两个传感器节点ni和nj及其对应的超立方体过滤器hi和hj,如果指定两个维,使其保证互不支配关系,那么条件(1)就变成了线性约束.为了使过滤器的过滤效果最大化,选择满足式(6)的两维来保证hi和hj的互不支配关系:Maximize(r-i.vk-r-式中,r-i是ri的均值期望.接着,对NN中的传感器节点ni,如果指定NS中一个节点nj,使得hj确定支配hi,保证ni确定不是Skyline节点,那么条件(2)也变成了线性约束.为了使过滤器的过滤效果最大化,选择满足式(7)的节点nj使之能支配ni,同时称节点nj为ni的支配节点,节点ni为nj的被支配节点.经过上述两步简化,非线性约束的非线性优化问题转化为线性约束的非线性优化问题,可以利用粒子群优化算法[15]来解决.化简后的线性约束的非线性优化问题如式(8)所示:Page9hj.Ik.lb.hj.Il.lb>hi.Il.ub.满足:(1)ni,nj∈NS,k,l∈D,hj.Ik.ub<hi.Ik.lb且(2)nj∈NN,ni∈NS,k∈D,hi.Ik.ub<当传感器节点的感知数据模型发生变化时,需要将新模型的参数提交基站,基站根据新模型相应地调整过滤器设置方案.每次调整设置方案都需要重新计算所有传感器节点的超立方体过滤器并将它们下发到相应的传感器节点,过滤器的维护过程将导致巨大的通信代价,显然是不合算的.因此,FIST算法中考虑只调整受影响较大的一部分传感器节点的过滤器,其余节点的过滤器保持不变.设感知数据模型发生变化的节点为ni,那么传感器节点过滤器的调整方案可以分为4种情况:(1)ni是Skyline节点,模型变化后还是Skyline节点.除了ni本身的过滤器hi之外,其原来的被支配节点和新的被支配节点的过滤器也需要调整.(2)ni是Skyline节点,模型变化后为非Skyline节点.除了ni本身的过滤器hi之外,其原来的被支配节点、新的支配节点和新支配节点的被支配节点的过滤器都需要调整.(3)ni是非Skyline节点,模型变化后还是非Sky-line节点.除了ni本身的过滤器hi之外,其原来的支配节点和新的支配节点的过滤器都需要调整.(4)ni是非Skyline节点,模型变化后为Skyline节点.除了ni本身的过滤器hi之外,所有Skyline节点的过滤器都需要调整.经过这样的处理,过滤器维护过程的计算代价显著降低;同时,由于只有少数传感器节点的过滤器发生了变化,过滤器维护过程中的通信代价也随之降低.4.2.3查询结果维护为传感器节点设置了过滤器后,传感器节点一旦发现某一时刻的感知数据超出了过滤器的范围,就将数据的变化即刻提交基站.在同一个时刻,可能有多个节点同时向基站提交感知数据的更新信息,在树型路由环境下,可以采用网内计算[11]的办法来减少网络中的数据传输量.基站收到所有数据更新信息后,用完整的感知数据元组替换过滤器设置方案中对应的超立方体,得到由感知数据元组和超立方体共同组成的混合集;接着,将元组看作是超立方体的特例,求出该混合集的Skyline结果集HS.根据定理2,一旦HS中的超立方体hi与HS中的其它任何超立方体hj(j≠i)之间都满足互不支配关系,那么相应的传感器节点ni将肯定为Skyline节点.如果超立方体hi不满足上述条件,基站将不能确定节点ni是否为Skyline节点,此时,基站需要获取相关节点的感知数据重新计算Skyline节点集合.涉及的关键问题包括中间节点的网内计算算法和基站的查询结果维护算法.通过在中间节点判断感知数据是否被其它节点的感知数据所支配,可以避免一些不必要的数据传输.中间节点的具体计算过程如算法2所示.首先,传感器节点合并所有子节点发送的更新信息,将其与新采集的感知数据合并得到新数据集(第1~5行);接着,计算该数据集的局部Skyline结果(第6行);如果本地的感知数据未通过过滤器,则将其从Skyline结果中移除(第7~10行);最后,将不属于Skyline结果且通过了过滤器的传感器节点的编号加入Sid(第11~15行).算法2.自顶向下过滤算法(节点).输入:子节点消息集合M,本地的感知数据r输出:提交到父节点的数据包M1.foreachelementminMdo//合并子节点数据2.M.Sid=tempID+m.Sid;3.tempSet=tempSet+m.St;4.endfor5.tempSet=tempSet+r;//加入自己新采集的数据6.M.Sid=Skyline(tempSet);7.ifpassFilter(r)==falsethen//过滤感知数据8.tempSet=tempest-r;9.M.Sid=M.Sid-r;10.endif11.foreachelementtintempSetdo//生成数据包12.ift.idisnotcontainedinM.St13.M.Sid=M.Sid+{t.id};14.endif15.endfor16.returnM.基站每个时刻对Skyline节点查询结果进行维护的具体过程如算法3所示.首先,将编号出现在Sid中的节点从保存的过滤器集合中移除(第1~3行);其次,用St中完整的感知数据元组替换过滤器集合中对应的超立方体得到混合集(第4~6行);然后,计算该混合集的Skyline(第7行);接着,找到所有不确定是否为Skyline节点的传感器节点,从这些节点获取必要的感知数据(第8~16行);最后,根据获取的感知数据计算该时刻的Skyline节点查询结果(第17行).Page10算法3.自顶向下过滤算法(基站).输入:节点的感知数据更新消息M;基站保存的过滤输出:Skyline节点集合S1.foreachelementiinM.Siddo//移除非Skyline节点2.H=H-hi;3.endfor4.foreachelementtinM.Stdo5.replacehiinHwitht;6.endfor7.S=Skyline(H);//计算过滤器中的Skyline8.foreachelementpinSdo9.foreachelementqinSdo10.ifp≠q且q?qthen11.Sprobe=Sprobe+{p.id,q.id};12.endif13.endfor14.endfor15.probethenodesappearinSprobe;16.replacethehypercubeinSwiththenewdata;17.S=Skyline(S);18.returnS.4.3混合过滤方式自底向上和自顶向下的过滤器方式各有利弊.在自底向上的过滤方式中,一旦感知数据发生了变化,节点马上将其提交基站,基站可以直接得到Skyline节点查询结果.因此,该种方式的查询响应时间较短,但是消耗较多的能量.在自顶向下的过滤方式中,基站只有在获取了相关传感器节点的感知数据后,才能确定最终的Skyline节点查询结果,所以查询响应时间较长;而此时节点设置的过滤器由元组变成了超立方体,因而过滤范围变大,过滤效果也更好,消耗的能量一般也较少;然而,有时虽然传感器节点的感知数据没有超出超立方体的范围,也可能因为其它节点感知数据的变化使得该节点是否为Skyline节点变得不确定,从而需要获取该节点的感知数据,造成过滤效果的显著下降,将消耗节点较多能量.为了更好地利用两种过滤方式的优点,回避它们的缺点,提出了混合过滤的方式,通过为传感器节点选择“最合适”的过滤器达到减少节点能量消耗的目的.如图6所示,传感器节点n2、n3和n5的数据相对稳定,选择自底向上的方式过滤;而节点n1和n4的数据变化相对频繁,选择自顶向下的方式过滤.在每个时刻,节点n2、n3和n5都时刻将数据变化报告基站,一共需要在网络中传输4个元组.在时刻1和时刻2,节点n1和n4的数据均没有超出各自立方体过滤器的范围,因而不需要向基站提交任何数据更新消息;在时刻3,节点n4的数据超出了超立方体的范围,需要向基站提交数据更新消息,同时由于节点n3和n5的数据已知,因此不需要从网络中获取任何数据就可以得到网络中的Skyline节点集合.混合过滤方式在3个时刻一共需要在网络中传输5个元组,与上述两种过滤方式相比,效率有了进一步的提高.基于上述原理,得出混合过滤方式的基本思想:将传感器节点分成两类,一类是数据变化频率较低的节点,使用本地过滤器(自底向上地过滤),这样既避免了数据的大量重复传输,也避免了节点被频繁访问;另一类是数据变化率较高的节点,使用全局过滤(自顶向下地过滤),避免了大量的不必要的数据更新.在介绍具体的传感器节点分类方法之前,先讨论两种过滤方式的过滤效果.设传感器节点ni的数据变化率为αi,当节点ni使用自底向上的过滤方式,也即是使用本地过滤器时,只有数据发生变化时才需要向基站传输消息.因此,节点ni不需要传输消息的概率如式(9)所示,将此概率称为该方法的获益.当传感器节点ni使用自顶向下的过滤方式,即(1)如果节点ni是候选非Skyline节点,nj是支配它的Skyline节点,那么无论节点nj采集的感知数据rj是否在超立方体hj内变化,只要节点ni采集的数据ri在超立方体hi内变化且元组rj支配hi,不需要知道ri的具体数值就可以确定ni不属于Skyline节点集合,所以ni不需要向基站传输任何数据;否使用全局过滤器时,可以分为两种情况:Page11则,ri或因为通过了过滤,或因为与感知数据元组rj的关系无法确定而需要被ni传输到基站.此时,自顶向下的过滤方式的获益如式(10)所示.BenifitT(ni)=P(ri∈hi)×P(rjhi)(10)(2)如果节点ni是候选Skyline节点,候选Skyline节点集合为NS,那么只要ri在超立方体hi内变化且NS中所有节点采集的感知数据都与hi互不支配,不需要知道ri的具体数值就可以确定ni属于Skyline节点集合,所以不需要向基站传输任何数据.此时,自顶向下的过滤方式的获益如式(11)所示.BenifitT(ni)=P(ri∈hi)×∏nj∈NS(i≠j)P(rj<>hi)显然,当BenifitB(ni)BenifitT(ni)时,传感器节点ni应该使用自底向上的过滤,此时称ni为B节点;而当BenifitB(ni)<BenifitT(ni)时,传感器节点ni应该使用自顶向下的过滤,此时称ni为T节点.混合过滤方式中过滤器的设置方案如下:首先,基站根据所有节点的感知数据模型计算初始的全局过滤器设置方案;然后,计算各节点分别使用自底向上和自顶向下的方式过滤时的获益,并根据上述的原则将传感器节点分组;最后,基站广播所有T节点的全局过滤器,没有收到全局过滤器的节点使用自底向上的方式过滤.由于使用的是多跳的路由树结构,两组传感器节点往往需要互相转发消息,如果节点利用这些消息来过滤自己的数据将进一步减少网络中的通信代价.由于B节点发送的消息里包含的是连续两个时刻Skyline的不同部分,只有被上一级B节点完全接收,才能保证两者数据之间的一致性.一旦被某个T节点修改,那么这种一致性就将被破坏.例如,B节点ni发送的消息中的元组t被T节点nj所过滤,它的上一级B节点nk就不能收到元组t.在下一个时刻,如果t是全局Skyline,那么它也一定属于节点ni的局部Skyline,根据自底向上的过滤原理,节点ni不需要传输元组t,而在上一级B节点nk的缓存中不包含t,所以计算的局部Skyline中也就不包含t,导致基站不能得到正确的Skyline结果.因此,在混合过滤方式中,B节点的消息只能在B节点中修改,而不能在T节点中修改.在自顶向下的过滤方式中,上下级节点之间不存在同步的问题,节点只需要通知基站采集的感知数据是否通过过滤,若通过过滤则通知是否属于Skyline.当通过过滤的节点确定不属于Skyline时,只需要将其编号告知基站即可.因此,T节点发送的消息可以在B节点中修改,只需要保留被支配节点的编号.混合过滤方式中,中间节点的计算过程与算法1和算法2类似,只需做少量修改即可.基站接收到所有的数据更新后,将两组节点的感知数据合并成一个数据集,其余处理过程与算法3相同.5性能评价与分析在本节中,分别利用人工合成数据集和真实数据集对各算法的性能进行了详细的比较和分析.实验的硬件环境为2.0GHzDELLPC,512MB内存,80GB硬盘.5.1实验设置型主要包括:在实验中,参与性能分析及比较的算法及其变准算法).算法.询算法.(1)TAG.利用网内计算的轮廓监控算法(基(2)MinMax.文献[5]中提出的Skyline查询(3)SkySensor.文献[10]中提出的Skyline查(4)BF.采用自底向上过滤方式的FIST算法.(5)TF.采用自顶向下过滤方式的FIST算法.(6)HF.采用混合过滤方式的FIST算法.实验环境由JAVA语言实现,实验中随机地在面积为n个平方单位的区域内随机部署n个传感器节点,使得每个节点所占的平均面积为1个平方单位.同时将传感器节点之间的通信半径设置为槡22个单位长度,并且规定传感器节点可以发送的最大数据包长度为48字节.测试数据被均匀地分布在n个传感器节点上,且每个时刻,每个节点采集一个新的感知数据,因此,整个传感器网络中每个时刻将产生n个新的元组.表1列出了实验中所要考察的主要参数及其变化范围和默认值.每次实验变化其中一种参数,而将其余参数设置为默认值.考察的主要性能指标为传感器网络中的平均通信代价和查询的平均响应时间.(1)平均通信代价.平均每个时刻的通信代价包括过滤器维护代价和Skyline数据的传输代价.(2)平均响应时间.将TAG算法执行一次网内计算过程的时间设为1个时间单位,其余算法计Page12算与它的相对数值,SkySensor算法的响应时间为结果返回跳数与TAG算法路由树深度的商.参数默认值数据维数节点数目300100,200,300,400,500数据变化率85%75%,80%,85%,90%,95%分布协方差σ5.2合成数据测试实验中的合成数据生成过程如下:首先,利用标准的数据集生成工具[3]分别生成一则独立分布和反相关分布的数据;接着,以这些数据作为均值利用多元高斯分布生成器产生[0,1]d的合成数据.(1)独立分布的性能图7表明,随着数据维数的增加,各算法的通信代价也随之增加.原因在于数据维数的增加使得节点被支配的概率降低,导致了Skyline节点数量的增加.由于数据变化率在数据维数变化时保持恒定,因此BF算法的通信代价相对于TAG算法减少的比例相对稳定.MinMax中的元组过滤器在独立分布下有很好的过滤效果,因此优于BF算法.SkySensor将数据传输到聚簇的代价不再被多个查询所分担,因而传输代价最高.维数的增加使得数据超出超立方体范围的概率增加,不仅使得网内计算过程中的数据传输量增加,也使得全局过滤器的计算和维护代价增加,因此TF和HF的通信代价都随着维数的增加而急剧增加.BF与TAG都利用网内计算,响应时间为1个时间单位;MinMax是两阶段算法,响应时间为2个时间单位.SkySensor需要按顺序访问各聚簇,因而响应时间随着维数的增加而增加(聚簇数等于维数).TF经常需要到网络中获取数据来确认Skyline,响应时间始终为2个时间单位;而HF中,大部分对结果影响较大的数据已经利用自底向上的方法获取,与TF相比响应时间显著缩短.图8表明,随着传感器节点数目的增加,各算法的通信代价相应增加.TAG、BF、MinMax和SkySensor的通信代价增长较快,BF与TAG的比例比较稳定,TF和HF增长相对缓慢.原因在于节点数目的增加造成参与计算元组数量的增加,也导致了Skyline结果数量的增加;同时节点数目的增加也造成了平均路由跳数的增加,所以各算法的通信代价增加.BF的性能只依赖于数据变化率,它与TAG通信代价的比例相对稳定.因为节点数目的增加对超立方体的过滤能力没有产生直接影响,所以TF和HF的通信代价增长相对缓慢.由于作为参照的路由树深度增加,SkySensor的响应时间随着节点数目的增加稍微有所减少,除SkySensor外各算法在响应时间方面的表现与数据维数变化时一致.图9表明,随着数据变化率的增加,TAG、MinMax、SkySensor、TF和HF算法的通信代价比较稳定,BF算法的通信代价成比例增长.因为BF算法的过滤原理依赖于数据变化率,一旦连续时刻数据相同的概率降低,那么过滤效果也随之降低,所以通信代价随着数据变化率的增加成比例增加.TAG未使用任何过滤措施,通信代价只和参与计算元组数量及维数等相关,与连续时刻的数据是否变化无关;MinMax和SkySensor与连续时刻的数据是否变化无关;TF和HF中使用的超立方体的过滤效果只和数据分布有关,与前后时刻的数据是否相同也无关.因此,TAG、MinMax、SkySensor、TF和HF算法的通信代价比较稳定.在响应时间方面的表现依旧相同,TAG和BF的响应时间始终为1个时间单位,SkySensor的响应时间接近3个时间单位,MinMax和TF的响应时间始终为2个时间单位,HF的响应时间介于BF和TF之间.Page13图8节点数目的影响图9数据变化率的影响在节点感知数据分布对算法影响的测试中,不失一般性地,假设感知数据模型协方差矩阵中的各元素均相同,将整个数据空间划分为n份,平均每份空间的半径设为σ.图10说明了各算法在数据分布协方差变化时的性能变化规律.TAG、MinMax、SkySensor和BF算法不依赖于数据的分布,因而通信代价相对比较稳定.随着协方差的增加,传感器节点感知数据的分布区域也随之扩大,也就导致了感知数据超过超立方体范围的概率增加,随之而来的是大量的查询重计算和过滤器的频繁更新,导致图10数据协方差的影响TF算法的通信代价显著地增加.HF算法的通信代价始终低于TF算法,且随着TF算法的变化趋势而变化.在响应时间方面,各个算法的表现与前面测试的结果保持一致,进一步说明了响应时间与仿真参数的变化无关.(2)反相关分布的性能为了更好地说明算法的性能,在反相关分布下也进行了算法性能的测试.如图11所示,TAG、SkySensor、BF、TF和HF算法在反相关分布下的表现与独立分布数据的性能表现基本一致,只有Page14MinMax算法的性能变得较差,原因在于反相关分布时元组过滤器的过滤效果下降.同时,HF算法的图11反相关分布的性能分析5.3真实数据测试实验中的真实数据集选择了热带海洋与大气项目(TropicalAtmosphereOcean,TAO)产生数据中的动力高度、等温面深、相对湿度和海面气象等4维数据来进行测试.在测试中,分别对数据维数为2、3和4时各算法的有效性进行了验证.图12表明,TAG算法的通信代价始终最高,BF算法的通信代价始终低于TAG的通信代价,证明了真实感知数据依然具有很强的时间相关性.TF和HF比BF算图12真实数据的性能分析性能始终优于其它的算法,进一步证明了算法的有效性.法节约了更多的通信代价.同时,在响应时间方面的结论与合成数据时的结论保持一致.5.4实验总结综上所述,TF和HF算法在通信代价上的表现远远优于其它算法;而HF算法在响应时间方面优于TF算法.由于传感器节点携带的能量有限,通信代价是衡量算法性能的最重要指标之一,因此可以得出如下结论:HF算法是计算及维护Skyline节点查询综合性能最优的算法.Page156结论深入地研究了传感器网络中的Skyline节点连续查询处理技术,提出了基于过滤的Skyline节点连续查询算法FIST,利用设置在传感器节点的本地或者全局过滤器来避免不必要的数据传输,进而节约传感器节点的能量.根据过滤器设置方式的不同,FIST算法分为自底向上(BF)、自顶向下(TF)和混合(HF)3种不同的过滤方法.TF利用前一时刻的局部Skyline作为本地过滤器来避免数据的重复传输;TF利用感知数据的统计规律为节点分配超立方体作为过滤器来避免不必要的数据更新.HF综合了BF与TF的优势,通过将节点划分为两大类来充分发挥两种过滤器算法的优势,一类节点使用本地过滤器,另一类使用全局过滤器.最后,通过合成数据和真实数据对算法的有效性进行了验证.结果表明,FIST算法极大地减少了Skyline节点连续查询过程中传感器网络内的数据传输量.
