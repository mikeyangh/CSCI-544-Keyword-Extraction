Page1KFUR:一个新型内核扩展安全模型马超1)尹杰1)刘虎球1)李浩2)1)(清华大学计算机科学与技术系北京100084)2)(西安电子科技大学计算机科学与技术学院西安710126)摘要保障内核扩展的安全性对操作系统具有重要意义.当前存在大量针对内核函数使用规则的攻击,内核扩展中也存在大量违反内核函数使用规则的错误,因此针对内核函数使用规则的安全性检测十分必要.虽然存在多种提高内核扩展安全性的方法,但很少有方法对内核函数的使用规则进行安全性检测.文中设计了KFUR(KernelFunctionUsageRule)内核扩展安全模型系统,用于在运行时检测内核扩展调用内核函数是否遵守内核函数使用规则.如果内核扩展调用内核函数满足模型安全运行条件,则允许对该内核函数进行调用,否则将错误报告给操作系统内核并终止该内核扩展的运行.文中所述研究在Linux操作系统上对KFUR安全模型系统进行实现,并将其运用于e1000网卡驱动、SATA硬盘驱动和HDA声卡驱动内核扩展.安全性评测表明安全模型系统能够对内核函数使用规则进行安全性检测,性能评测表明安全模型系统带来的开销很小.关键词操作系统;KFUR安全模型;内核扩展;内核函数使用规则1引言内核扩展是可以在运行时添加到操作系统内核中的功能模块.如图1所示,在通用操作系统中,内核扩展运行于内核态,可以访问几乎所有计算机系统的资源,具有很高的特权.因此,内核扩展的安全性直接影响操作系统的安全性.由于内核扩展可以动态添加和删除,因此操作系统大量使用内核扩展实现各种功能.在Linux操作系统中,代码量占操作系统代码总量70%的设备驱动就是作为内核扩展运行的[1].但是内核扩展中存在很大的安全隐患,CVE(CommonVulnerabilitiesandExposures)①中报告了大量针对内核扩展的攻击,并且针对内核扩展的攻击仍然在不断出现.因此,提高内核扩展的安全性具有重要意义.CVE报告指出,大量的攻击和内核函数使用规则相关.内核函数使用规则是指使用一类相互依赖的内核函数需要遵守的规则.例如,Linux操作系统中的自旋锁可以用于保证对临界区的互斥访问,接口函数中有加锁和解锁两类操作,其中“自旋锁不能在未被加锁之前解锁”是一条关于自旋锁的内核函数使用规则.同样,对内存使用相关的函数来说,“被释放的内存不能再进行操作,除非重新被分配”是必须要遵守的一条规则.违反内核函数使用规则会造成整个操作系统的崩溃、机密信息被窃取等严重后果.操作系统的崩溃会带来很大的损失,如表1所示为不同应用1分钟宕机的代价②.而在Linux操作系统中,作为内核扩展运行的设备驱动失效的频率是其它部分的3~7倍[1],在LinuxKernelMailList③中报告了在内核扩展中存在大量内核函数使用规则相关的错误.目前已经提出很多方法提高内核扩展的安全性.Mondrix[2]和Loki[3]等基于特殊硬件对内核扩展进行隔离;Minix3[4]和SUD[5]等提出将设备驱动放到用户态执行;也有一些研究者将内核扩展放到隔离的虚拟机中运行[6-7];SafeDrive[8]和LXFI[9]使用隔离机制来提高在内核态运行的内核扩展的安全性.SafeDrive主要解决内核扩展违反类型安全的问题,LXFI主要针对内核函数完整性进行检测.内核函数完整性检测是针对具体的内核函数接口调用进行的检测,但并没有对内核函数使用规则进行检测.Ball等人[10]在SDV(TheStaticDriverVerifiertool)中提出了大量需要被检测的内核函数使用规则.大量提高内核扩展安全性的方法没有被主流操作系统使用的主要原因之一是性能问题.虽然这些方法能够提高内核扩展的安全性,但同时会带来很大的开销.本文设计了一种新型安全模型系统———KFUR内核扩展安全模型系统,能以很小的开销对内核函数使用规则进行检测,防止针对内核函数使用规则的攻击和程序员编码错误导致的违反内核函数使用规则对操作系统造成的破坏.首先,本文提出了内核函数使用规则的KFUR安全模型,用于判断内核扩展调用内核函数是否遵守内核函数使用规则.基于内核函数使用规则的KFUR安全模型,在Linux操作系统上实现了KFUR内核扩展安全模型系统.该安全模型系统由三部分组成:内核函数使用规则库、检测标记和动态检测器.内核函数使用规则库根据KFUR安全模型实现了需要被检查的内核函数使用规则.在内核扩展代码中插入少量检测标记,在运行时,插入的标记将触发动态检测器的运行.动态检测器根据内核函数使用规则库判断内核扩展对内核函数的调用是否安全.为了提高KFUR内核扩展安全模型系统的性能,设计了快速Hash算法用于存储数据.本文将KFUR内核扩展安全模型系统运用于e1000网卡驱动、SATA硬盘驱动和HDA声卡驱①②③Page3动内核扩展并采用错误注入的方法进行安全性评测,评测结果表明KFUR内核扩展安全模型系统能够有效地进行安全性检测.分别使用netperf①基准测试程序、dd命令测试和postmark基准测试程序、realplayer声音播放和soundrecorder声音录制对e1000网卡驱动、SATA硬盘驱动和HDA声卡驱动进行性能评测,评测结果表明KFUR内核扩展安全模型系统仅带来很小的开销.本文第2节介绍近年来在提高内核扩展安全性方面的工作;第3节对KFUR安全模型进行描述;第4节对KFUR内核扩展安全模型系统的主要组成部分进行详细的描述;第5节给出安全性评测结果;第6节给出性能评测结果;第7节对全文进行简要总结.2相关工作目前已经有很多提高内核扩展安全性的方法,下面将分类进行介绍.一些对内核扩展进行隔离的方法需要依赖特殊的硬件.Mondrix[2]基于Mondriaan内存保护机制实现了对内核扩展的隔离.Mondriaan内存保护机制采用对中央处理器的流水线进行修改,对load,store指令进行权限检测等方法实现了对多个受保护的内存域共享同一线性地址空间的细粒度内存保护方法.但是,Mondriaan内存保护机制所依赖的硬件目前还不存在.Loki[3]基于标签内存机制实现隔离.通过使用标签内存机制,Loki将安全策略和物理内存予以关联,简化了安全机制的实现.但Loki依赖于HiStar操作系统的特殊结构,不能被应用于主流实用的操作系统中.一些研究者采用将内核扩展移到用户态运行的方法来达到提高安全性的目的.Minix3[4]操作系统的设备驱动在用户态运行,但其性能与运行在内核态的设备驱动相比较差.Leslie[11]提出的将设备驱动移到用户态运行的方法可以保证良好的性能,但需要对设备驱动代码进行重写.SUD[5]采用在用户态模拟Linux操作系统内核环境的方法将Linux操作系统的设备驱动在不进行修改的情况下移到用户态运行.有些研究者使用虚拟机提高内核扩展的安全性.Fraser等人[6]把内核扩展放到隔离的虚拟机中运行,在保证了安全性的同时可以实现内核扩展被多个操作系统共享.LeVasseur等人[7]通过将内核扩展和相应的操作系统同时运行于隔离的虚拟机中来提高安全性并实现内核扩展的复用.但采用虚拟机技术对内核扩展进行隔离会带来很大的性能开销.TwinDrivers[12]提出将内核扩展中影响性能的部分放到虚拟机虚拟层的方法提高内核扩展的性能.有很多使用软件方法实现的隔离机制用于提高内核扩展的安全性.SFI(Software-basedFaultIsolation)[13]隔离机制实现了一种单一地址空间的隔离机制,它将内核扩展的代码和数据加载到逻辑隔离的内存域.SFI还对内核扩展的代码进行修改,使内核扩展不能写或者跳转到其所在内存域以外的地址.XFI[14]隔离机制能够提供灵活的访问控制和完整性保证.SafeDrive[8]通过在编写内核扩展时添加标记,对内核扩展违反类型安全的问题进行检测和恢复.LXFI[9]通过在内核扩展代码中添加对象访问权限的授予、回收和检测标记,采用介于操作系统和内核扩展之间的隔离机制实现对内核扩展使用内核函数的完整性检测.LXFI能够对同一内核扩展的不同实例实现不同的隔离.目前很少有能够对内核函数使用规则进行检测的方法,另外,大多数提高内核扩展安全性的方法都会带来较大的开销.事实上,在使用内核扩展时,需要对内核函数的访问予以约束,该约束完全可以通过定义规则的形式实现对内核扩展中的函数使用进行检测和约束.鉴于此,本文设计和实现了KFUR内核扩展安全模型系统,用于对内核函数使用规则进行检测.在设计安全模型系统时充分考虑了性能问题.3内核函数使用规则KFUR安全模型这一节首先对KFUR安全模型进行描述,然后基于该模型对内核函数使用规则进行建模.3.1KFUR安全模型KFUR安全模型由访问主体、系统状态、访问客体、初始状态、不安全状态、转移条件和转移函数7个部分组成.下面将分别对这7个部分进行描述.访问主体:是指提出访问请求的实体,使用符号s表示,访问主体的集合使用符号S表示.系统状态:是指KFUR模型在某一时刻的快照,使用符号q表示,系统状态的集合使用符号Q表示,系统初始状态使用符号q0表示,不安全状态①Netperf:Anetworkperformancebenchmark,version2.50Page4使用符号qe表示.访问客体:是指接受访问主体访问的实体,使用符号o表示,访问客体的集合使用符号O表示.访问客体中包括一个或多个访问属性,访问属性为在某一系统状态下访问客体允许被访问的方式,使用符号p表示.访问方式用符号m表示.访问客体的访问属性可以表示为p(o)={(q0,m0),(q1,m1)…(qn,mn)}.转移条件:是指发生状态转移的条件,使用符号a表示,转移条件的集合使用符号A表示.转移函数:是指发生状态转移时模型发生的变化,使用符号f表示,转移函数的集合使用符号F表示.转移函数的输入和输出为访问客体和系统状态,可以描述为(qn,o1,…,on)×f→(qn+1,o1,…,on),其中qn为模型当前处于的状态,当某个转移条件发生时,触发相应的转移函数对模型进行改变:一是对模型进行状态转移,即由qn转化为qn+1,二是对访问客体的访问属性进行变更,即由o1转化为o1等.转移函数分为两类:满足安全要求的转移函数和不满足安全要求的转移函数.满足安全要求的转移函数可以使模型转移到系统的安全状态,不满足安全要求的转移函数将使模型转移到系统的不安全状态.这样,KFUR模型可以表示为七元组:KFUR模型安全运行的充分必要条件为:不存在状态转移使模型进入不安全状态.如果状态转移始终发生在安全状态之间,则该模型安全运行,如果模型状态转移到了不安全状态,则表示有违反安全性的行为发生.3.2内核函数使用规则的KFUR安全模型内核函数使用规则KFUR安全模型的访问主体为所有调用内核函数的内核扩展;访问客体为内核函数使用规则中涉及的内核函数、变量和内存区域,访问方式主要有3种:只读、可写和可调用;系统状态为内核函数使用规则中的状态;转移条件为对内核函数使用规则中涉及的内核函数进行调用;转移函数即为内核函数使用规则中的规则,即判断当前状态能否进行相应的操作,如果允许,则转移到另一个安全状态;如果规则不允许,则转移到不安全状态.下面以自旋锁为例对内核函数使用规则的KFUR安全模型进行描述.自旋锁的使用规则有:(1)自旋锁在使用前必须进行初始化;(2)自旋锁不能在未被加锁之前解锁.如图2所示为e1000_read_eeprom函数的源代码,代码中使用了e1000_eeprom_lock自旋锁,在调用函数e1000_do_read_eeprom之前调用spin_lock加锁函数进行加锁,在e1000_do_read_eeprom函数执行完毕后调用spin_unlock解锁函数解锁.1.staticDEFINE_SPINLOCK(e1000_eeprom_lock);2.s32e1000_read_eeprom(structe1000_hwhw,u16offset,3.{4.s32ret;5.spin_lock(&e1000_eeprom_lock);6.ret=e1000_do_read_eeprom(hw,offset,words,data);7.spin_unlock(&e1000_eeprom_lock);8.returnret;9.}在第5行代码执行完毕时自旋锁e1000_eeprom_lock处于加锁状态,自旋锁内核函数使用规则的KFUR安全模型如下,其中只读访问方式使用符号r表示,可写访问方式使用符号w表示,可调用访问方式使用符号c表示.S={e1000网卡驱动};O={DEFINE_SPINLOCK,spin_lock,Q={0,1,2,3,4};p(DEFINE_SPINLOCK)={(0,c)};p(spin_lock)={(1,c),(2,c),(3,c)};p(spin_unlock)={(2,c)};p(e1000_eeprom_lock)={(2,w)};q0={0};qe={4};A={callDEFINE_SPINLOCK;callspin_lock;F={(0,DEFINE_SPINLOCK,e1000_eeprom_lock{0,w})×f→(1,e1000_eeprom_lock{1,w}),(1,spin_lock,e1000_eeprom_lock{1,w})×f→(2,e1000_eeprom_lock{2,w}),(2,spin_lock,e1000_eeprom_lock{2,w})×f→(2,e1000_eeprom_lock{2,w}),(2,spin_unlock,e1000_eeprom_lock{2,w})×f→(3,e1000_eeprom_lock{3,w}),(3,spin_lock,e1000_eeprom_lock{3,w})×f→(2,e1000_eeprom_lock{2,w}),(0,spin_lock,e1000_eeprom_lock)×f→Page5(4,e1000_eeprom_lock),(0,spin_unlock,e1000_eeprom_lock)×f→(4,e1000_eeprom_lock),(1,spin_unlock,e1000_eeprom_lock)×f→(4,e1000_eeprom_lock),(3,spin_unlock,e1000_eeprom_lock)×f→(4,e1000_eeprom_lock)}.对于如上模型的转移函数,仅标出了访问客体发生变化的访问方式.该模型安全运行的条件是不存在某次状态转移使安全模型转移到状态4.4KFUR内核扩展安全模型系统如图3所示,KFUR内核扩展安全模型系统由三部分组成:内核函数使用规则库、检测标记和动态检测器.内核函数使用规则库中包含被检查内核函数使用规则的KFUR安全模型描述,作为动态检测器进行检测的依据.检测标记为插入到内核扩展代码中的标记,在运行时,检测标记触发动态检测器进行检测.如果发现异常,则通知操作系统内核终止内核扩展的运行.本文在Linux操作系统上实现了KFUR内核扩展安全模型系统.4.1节对内核函数使用规则库进行介绍,4.2节对检测标记进行介绍,4.3节对动态检测器进行介绍.4.1内核函数使用规则库内核函数使用规则库中的内核函数使用规则基于KFUR模型实现.为了提升访问内核函数使用规则KFUR模型中访问方式相关数据的性能,本文设计了快速Hash算法,用来存储访问方式相关数据.访问客体分为两类:一类是变量和函数,另一类是内存区域.如果访问客体为变量或函数,则采用一种简单的Hash算法存储.假定变量或函数的地址为A,Hash表大小为N,Hash值为K,则该Hash算法的Hash函数如下:Hash值即为变量地址或函数地址在哈希表中的位置.为了处理发生碰撞即该位置已经存有其它变量地址或函数地址的情况,哈希算法为每个位置开辟了一个小的碰撞处理表,变量地址或函数地址存放在碰撞处理表中的位置采用和如上哈希函数类似的计算方法,即用变量或函数的地址和碰撞处理表的大小做模运算.如果该位置仍然存在冲突,从该位置起依次查询是否有空位,直到找到空位为止.如果在某一位置的碰撞处理表中没有空位,则到哈希表下一位置的碰撞处理表中寻找空位.该算法能够实现对变量或函数地址的快速添加、查询和删除.在实际应用中,存在大量查询内存区域子区间的访问方式的情况,比如需要对某个结构体中的某一项是否允许被访问进行查询.例如在表2中存放了一些内存区域的信息,内存区域的信息由内存起始地址和内存大小两部分构成.在实际应用中存在如表3所示的查询.例如表3中第1项为对内存起始地址为2155,内存大小为3的内存区域的访问方式进行查询,可以看到表2的第1项为内存起始地址为2140,内存大小为33的内存区域,因此表3中第1项查询的内存区域应当允许被访问.针对这种特定的场景,本文设计了一种新型的快速哈希算法进行存储.该哈希算法的哈希函数为:首先得到内存区域的大小为几位数,假设为n位数,内存起始地址为As,然后按照如下公式计算哈希值:123…123…哈希值即为内存区域在哈希表中的位置.如果该位置已经存储了其它内存区域,采用如算法1所示方法进行碰撞处理.Page6算法1.内存区域存储碰撞处理算法.输入:内存区域起始地址,内存区域大小1.初始化循环变量i←1;2.计算As/10(n+i)的值,并判断该值是否为0,如果不为0,执行下一步;如果为0,跳转到步4;3.内存区域存储的位置为:(As/10(n+i))%N,如果Hash表中该位置为空,则将内存区域存储到该位置,算法执行结束;否则跳转到步5;4.从位置(As/10(n+i-1)+1)开始顺序查找Hash表,如果Hash表中该位置为空,则将内存区域存储到该位置,算法执行结束,如果找不到空位置说明Hash表已满报错;5.i←i+1.4.2检测标记在内核扩展中需要添加的检测标记主要有两类:一类是注册和初始化标记,即在待检测变量定义时,添加的向动态检测器注册和初始化该待检测变量的标记;另一类是检测标记,即在内核扩展调用内核函数前,添加的触发动态检测器进行检测的标记.第一类标记需要将待检测变量、待检测变量所要遵守的内核函数使用规则作为参数传递给动态检测器;第二类标记需要将待检测变量、待调用函数、所要遵守的内核函数使用规则作为参数传递给动态检测器.检测标记的添加可以由编译器来完成.仍然以e1000网卡驱动e1000_read_eeprom函数中使用的e1000_eeprom_lock自旋锁为例进行说明.从图2中可以看到,自旋锁e1000_eeprom_lock作为全局变量被定义和初始化.向动态检测器注册和初始化待检测变量e1000_eeprom_lock自旋锁的标记被添加到e1000网卡驱动的初始化函数e1000_probe中,自旋锁e1000_eeprom_lock、自旋锁应当遵守的内核函数使用规则作为函数参数传递给动态检测器.在e1000_read_eeprom函数中调用spin_lock加锁函数之前插入检测标记,将自旋锁e1000_eeprom_lock、函数spin_lock和自旋锁应当遵守的内核函数使用规则作为函数参数进行传递,同样也在调用spin_unlock函数之前插入检测标记.4.3动态检测器动态检测器在运行时对内核扩展进行检测.注册和初始化标记触发动态检测器完成对需要被检测的变量进行注册和初始化,动态检测器将该变量作为访问客体进行存储.例如,在对待检测的自旋锁进行注册和初始化后,该自旋锁作为访问客体具有在状态1可写的访问属性.检测标记根据内核函数使用规则对当前函数调用是否正确进行检测.如果对内核函数调用正确,则允许该内核函数运行,同时完成KFUR模型的状态转移.例如,被初始化的自旋锁在调用加锁函数spin_lock后,自旋锁处于KFUR模型的状态2,在调用解锁函数spin_unlock后,自旋锁处于内核函数使用规则KFUR模型的状态3.如果在某状态调用不允许调用的函数或访问不允许访问的内存时,动态检测器会向操作系统内核报错,操作系统内核终止该内核扩展的运行.例如,如果在状态3时调用spin_unlock函数,自旋锁将会转移到KFUR模型的状态4,即到达了不安全状态,因为这一调用违反了“自旋锁不能在未被加锁之前解锁”的自旋锁使用规则.5安全性评测本节对KFUR内核扩展安全模型系统进行安全性评测.5.1节采用错误注入测试的方法对系统进行评测,5.2节将KFUR内核扩展安全模型系统和SDV进行比较.5.1错误注入测试为了对KFUR内核扩展安全模型系统的检测能力进行评测,本文采用错误注入测试方法.其中,Linux内核版本为2.6.36.1,GCC编译器的版本是4.3,选择e1000网卡驱动、SATA硬盘驱动和HDA声卡驱动内核扩展分别进行测试.对于e1000网卡驱动,以自旋锁、内存和网络数据包处理三类内核函数使用规则进行测试.首先选择自旋锁进行测试.如上文所述,函数e1000_read_eeprom中配对使用了自旋锁加锁函数spin_lock和自旋锁释放函数spin_unlock.将函数调用spin_lock删除,这样就违反了自旋锁不能在未被加锁之前解锁的使用规则.如果KFUR内核扩展安全模型系统正常运行,应当能够向操作系统内核进行错误报告,并且e1000网卡驱动内核扩展的运行将被终止.动态检测器采用向Linux操作系统的日志记录文件输出错误信息的方式进行报错.运行e1000网卡驱动,在Linux操作系统日志记录文件中找到了动态检测器输出的错误信息,并且e1000网卡驱动内核扩展的运行被终止.Linux操作系统内核提供给内核扩展的内存函数接口有内存分配函数malloc、在一段内存中填充某个给定值的函数memset、内存区域拷贝函数memcpy、内存释放函数free等.在使用内存函数接口时,被free函数释放的内存不能成为memset和memcpy函数的参数.Page7e1000网卡驱动函数e1000_setup_tx_resources中配对使用了内存分配函数vmalloc和内存释放函数vfree.在vfree函数后添加memset函数填充被释放的内存.运行e1000网卡驱动,同样可以在Linux操作系统的日志记录文件中找到动态检测器输出的错误信息.Linux操作系统的网络模块为内核扩展提供了很多接口函数,如图4所示.其中,前两个函数用于分配sk_buff结构体,第3个到第6个函数用于释放sk_buff结构体,这4个释放函数在不同情况下被使用.其它函数用于对sk_buff结构体进行不同的操作.因此,这些函数不能在sk_buff结构体被释放后使用.另外,函数skb_pull用于从数据包的头部删除数据.因此,这个函数不应当出现在e1000网卡驱动内核扩展中.1.structsk_buffalloc_skb(unsignedintlen,intpriority);2.structsk_buffdev_alloc_skb(unsignedintlen);3.voidkfree_skb(structsk_buffskb);4.voiddev_kfree_skb(structsk_buffskb);5.voiddev_kfree_skb_irq(structsk_buffskb);6.voiddev_kfree_skb_any(structsk_buffskb);7.voidskb_put(structsk_buffskb,intlen);8.unsignedcharskb_push(structsk_buffskb,intlen);9.intskb_tailroom(structsk_buffskb);10.intskb_headroom(structsk_buffskb);11.voidskb_reserve(structsk_buffskb,intlen);12.unsignedcharskb_pull(structsk_buffskb,intlen);13.intskb_is_nonlinear(structsk_buffskb);14.intskb_headlen(structsk_buffskb);数据包发送函数e1000_xmit_frame使用了sk_buff结构体.在变量定义后,调用dev_kfree_skb_any释放sk_buff结构体,然后调用skb_transport_offset访问被释放的sk_buff结构体.在运行时动态检测器成功检测出了异常并报告给了linux操作系统内核.在e1000_xmit_frame函数中调用skb_pull函数,同样也被动态检测器成功检测.除对e1000网卡驱动进行上述针对性注入测试外,还进行了其它一些针对性注入测试,测试结果如表4所示.从表4可以看出,KFUR内核扩展安全模型系统能够检测出所有被注入的错误.另外,对于e1000网卡驱动还进行了随机测试.每次测试随机对一些内核函数调用进行删除或随机添加一些内核函数调用,导致内核函数使用规则被违反.从表4可以看出,KFUR内核扩展安全模型系统每次都能成功检测.设备测试方法测试用例个数成功检测个数e1000网卡针对性错误注入30SATA硬盘针对性错误注入20HDA声卡针对性错误注入25SATA硬盘驱动中存在大量自旋锁相关的内核函数调用,采用和e1000网卡驱动类似的方法进行了安全性评测.对于HDA声卡驱动,对自旋锁、内存进行了安全性评测,评测结果如表4所示.实验结果表明KFUR内核扩展安全模型系统均能成功检测错误.5.2相关技术比较SDV采用模型检测方法对Windows操作系统的设备驱动是否遵守内核函数使用规则进行检测,并找出了很多Windows操作系统设备驱动违反内核函数使用规则的问题.KFUR内核扩展安全模型系统在如下两方面优于SDV.首先,SDV是一种静态检测方法而KFUR内核扩展安全模型系统是动态检测方法.SDV仅能检测出静态存在于设备驱动中违反内核函数使用规则的情况,而对由于系统运行时的安全攻击造成的违反内核函数使用规则的情况则无法检测.KFUR内核扩展安全模型系统能够动态实时检测违反内核函数使用规则的情况并及时向操作系统内核报告,进行相应的处理,保证了操作系统运行时的安全.其次,SDV采用模型检测技术.现有模型检测技术时间开销较大,对于代码量大的设备驱动无法在有限的时间内进行检测,而KFUR内核扩展安全模型系统仅需要很小的开销.6性能评测同样采用e1000网卡驱动、SATA硬盘驱动和HDA声卡驱动内核扩展进行性能评测.性能评测用于评价KFUR内核扩展安全模型系统对内核扩展性能的影响.本文采用netperf基准测试程序对e1000网卡驱动的性能进行评测.实验环境包括一台客户端计算机和一台服务器计算机及千兆网络.客户端计算机和服务器计算机的配置如表5所示,KFUR内核扩展安全模型系统实现在客户端计算机中.Page8CPUIntel(R)Core(TM)2Duo内存2GBDDR2硬盘320GB7200r/min1TB7200r/min网卡Intel82540EMGigabit选择netperf基准测试程序中的TCP_STREAM、UDP_STREAM、TCP_RR和UDP_RR四种测试分别对原始Linux操作系统和添加KFUR内核扩展安全模型系统后的Linux操作系统进行测试.TCP_STREAM用于对TCP的吞吐量进行测试;UDP_STREAM用于对UDP的吞吐量进行测试;TCP_RR和UDP_RR用于测试KFUR内核扩展安全模型系统所带来的延迟.测试时间均为10s.TCP_STREAM的发送缓冲区大小为16384字节,接收缓冲区大小为87380字节.每条消息的大小为16384字节.在UDP_STREAM测试中,发送端UDP套接字的大小为114688字节,接收端UDP套接字的大小为114688字节,每条消息的大小为1024字节.图5和图6分别为TCP_STREAM、UDP_STREAM吞吐量和CPU占用率的测试结果.图中“Linux”表示原始Linux操作系统的测试结果,“KFUR”表示添加KFUR内核扩展安全模型系统后的Linux操作系统的测试结果.图5TCP_STREAM和UDP_STREAM测试的吞吐量图6TCP_STREAM和UDP_STREAM测试的CPU占用率对于TCP_STREAM测试,采用KFUR内核扩展安全模型系统和不采用KFUR内核扩展安全模型系统的吞吐量基本相同,采用KFUR内核扩展安全模型系统的CPU占用率仅比不采用KFUR内核扩展安全模型系统高0.15%.UDP_STREAM和TCP_STREAM测试的结果类似,采用KFUR内核扩展安全模型系统和不采用KFUR内核扩展安全模型系统的吞吐量基本相同,采用KFUR内核扩展安全模型系统的CPU占用率比不采用KFUR内核扩展安全模型系统的CPU占用率高1.04%.在TCP_RR测试和UDP_RR测试中,发送缓冲区的大小为16384字节,接收缓冲区的大小为87380字节.采用KFUR内核扩展安全模型系统时吞吐量略低于不采用KFUR内核扩展安全模型系统,CPU占用率略高于不采用KFUR内核扩展安全模型系统,测试结果分别如图7和图8所示.图8TCP_RR和UDP_RR测试的CPU占用率对添加了KFUR内核扩展安全模型系统的硬盘驱动和未修改的硬盘驱动的性能进行比较,首先使用dd命令对硬盘读速度、硬盘写速度和硬盘读写混合速度进行测试,测试结果如表6所示.硬盘读速度硬盘写速度硬盘读写速度采用postmark基准测试程序对多个文件并发访问进行测试.设置文件大小下限为10000字节,文件大小上限为20000字节,事务数为50000次,Page9并发文件数从1000到2000次,文件读取速度和写入速度分别如图9和图10所示.可以看出,加入了KFUR内核扩展安全模型系统的硬盘驱动和未修改的硬盘驱动相比性能相差不大.对添加了KFUR内核扩展安全模型系统的声卡驱动和原始声卡驱动进行性能比较,采用realplayer和soundrecorder分别进行声音的播放和录制,比较其CPU占用率,实验结果如图11所示.从网卡驱动、硬盘驱动和声卡驱动的实验结果可以看出,KFUR内核扩展安全模型系统对于内核扩展的性能影响不大.KFUR内核扩展安全模型系统能在保持性能良好的情况下提高内核扩展的安全性.7总结内核扩展的安全性对于操作系统十分重要,不安全的内核扩展导致操作系统内核崩溃、机密数据被窃取,带来了巨大的损失.本文提出KFUR内核扩展安全模型系统,该安全模型系统能以很小的开销对内核扩展调用内核函数时,是否遵守内核函数使用规则进行检测,从而提高内核扩展的安全性.接下来将对内核扩展的其它安全性问题进行研究,提出实用的、高性能的提高内核扩展安全性的方法,进一步提高操作系统的安全性.致谢本文作者得到了清华大学计算机科学与技术系操作系统实验室的老师和同学们的许多帮助和建议,在此表示感谢.感谢审稿人对本文提出宝贵意见和建议!
