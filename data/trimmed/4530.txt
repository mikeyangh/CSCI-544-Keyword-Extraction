Page1不一致数据上查询结果的一致性估计刘雪莉李建中(哈尔滨工业大学计算机科学与技术学院哈尔滨150001)摘要主键约束是描述关系数据一致性的常用方法,基于主键约束的数据一致性修复返回一个极大子集,子集中不同数据的主键不同.对于合取查询Q,一致性合取查询返回一个答案集合,答案集合是Q在数据集合I的每一个修复下查询结果的交集.文中将Q在I中的查询结果满足一致性的个数占总的结果个数的比例定义为查询结果的一致性程度.若Q不可一阶表达且不能在多项式时间内得到其一致性解,则当Q答案个数超过30时,使用抽样的方法给答案集合一致性程度的一个(ε,δ)-估计.由于布尔合取查询的一致性判定问题是coNP-完全问题,因此在估计过程中,使用攻击图,通过攻击图对布尔查询q进行改写近似判断q近似一致性回答.实验表明了估计算法和近似判定算法具有较高的效率和准确率.关键词主键约束;一致性查询;合取查询;近似一致性1引言近年来,数据质量问题引起了人们的高度重视.数据质量是数据分析结论有效性和准确性的基础,Page2国银行业,由于信息的不一致性导致的失察信用卡欺诈在2006年大约造成了48亿美元的损失;而在数据仓库项目的开发过程中,数据清洗通常需要花费30%~80%的开发时间和开发预算①.数据的一致性是指数据集合中不包含语义错误或相互矛盾的数据[1].例如,数据(国码=“86”,区号=“10”,城市=“上海”)含有语义错误,因为10是北京区号而非上海区号.目前关于数据不一致性的研究主要从两个方面着手:(1)不一致数据的检测和修复;(2)不一致数据上的一致性查询.不一致数据的检测方面,基本方法是建立一组一致性质量规则,若数据集合中存在着不一致信息,则不一致信息将会违背相应的规则从而被检测出来.数据修复是通过尽可能少的修改数据,使得数据集合满足一致性规则集合.然而,数据修复存在着一些问题:首先,删除不一致数据可能会造成有用信息的缺失;其次,并不能保证修复之后的数据一定是正确的,存在着将正确数据修复为错误数据的可能性.基于此,文献[2]提出了一致性查询问题.一致性查询处理是指回答用户查询时仅使用不含错误的信息.文献[2]中使用数据修复来定义一致性查询结果,对于一个主键约束的数据集,它的一个修复可以通过从数据集中挑选出任意两个主键都不相同的极大子集得到.显然,一个不一致的数据集合可能有多种修复.一致性查询结果指的是查询结果中的每一条记录都出现在对所有的修复进行查询的结果中.然而,数据的所有修复具有指数级可能空间,即使只考虑主键约束,一致性查询也是coNP-完全问题.更重要的是,不一致的数据中也可能包含着用户需求的信息,只返回一致性的查询结果丢失了查询相关的有价值数据,返回的结果可能并不能满足用户的需求,但是返回全部结果又使用户对查询的准确度没有了解,从而造成错误的认知,甚至做出错误的决策.因此,本文考虑,返回所有的查询结果,并给定查询结果的一个一致性估计,使得用户获得查询结果的一致性程度,了解查询结果的总体特征.本文只考虑主键约束下不一致数据集查询结果的一致性估计.例1.关系表nba(Player,Season,Age,Tm,Lg,PTs)描述了球员参加NBA比赛的基本信息,如表1所示.其中Player表示球员的名字,Season,Age,Tm,Lg,PTs分别描述了NBA赛季,年龄,所属球队,联赛,总的得分信息.Player,Season下的下划线表示Player,Season是nba表的主键.假设查询q(x,t)=nba(x,y,z,t,l,g),由一致性查询的定义,若用户只返回一致性的查询答案,则查询的一致性答案集合为{(QuincyAcy,TOR),(JeffAdrien,CHA)}.PlayerQuincyAcy2013-14JeffAdrien2013-14JeffAdrien2013-14ColeAldrich2013-14ColeAldrich2013-14显然,答案集合漏掉了ColeAldrich的信息,这可能是用户想要获得的.为了尽可能全面回答用户的查询,本文返回所有的查询答案,同时给出查询答案的一致性准确程度给用户以指导,使得用户对查询的可靠性有一个大致的了解.在此次查询中,(ColeAldrich,NYK)和(ColeAldrich,TOT)是不一致的.一致性回答个数为2,总的回答个数为4,若将一致性准确率定义为一致性回答的个数占总回答个数的比例,则一致性准确率从为2/4=1/2.用户可以根据一致性准确率信息判断查询信息的可用性.从例1中可以看出,为了估计查询结果的一致性程度,需要确定答案集合中的每条元组的一致性.此问题可以形式化定义为CERTAINTY(q)问题,即CERTAINTY(q)={I|对于数据集I的每一个修复,之前的研究[3]指出此问题的复杂度上界为coNP-完全,当q是一阶可表达时,复杂度降为一阶查询的复杂度AC0.q是一阶可表达的是指q可以经过一阶改写得到一个一阶查询q,q返回所有修复下满足q的答案集合,即q的一致性答案集合.q可以改写成SQL语句直接对关系数据集进行查询,也就是说,可以在多项式时间内得到查询的一致性结果,这使得一阶表达在一致性查询中有着重要的作用.然而,目前并没有一个可一阶表达与一致性查询判定易解的一个充要条件.因此,针对不可一阶表达的查询,本文引入了近似一致性的概念.本文的主要贡献如下:(1)定义了查询结果的一致性程度估计,当查询不可一阶改写时,使用抽样的方法给出了一致性程度的一个(ε,δ)-估计.①WoolseyB,SchulzM.Creditcardstatistics,industryPage3(2)对于不可一阶改写的查询,定义了新的查询改写qrelax,设计判定算法使用qrelax的中间结果近似判定查询回答中元组t的一致性.(3)当合取查询中出现环以及自连接时,定义了查询改写qacylic和qsjf,用来判定其回答的近似一致性.(4)实验验证了估计和近似判定算法的效率以及准确率.本文第1节描述问题的背景和意义;第2节介绍相关工作;第3节给出背景知识介绍;第4节提出不可一阶改写查询答案一致性程度的(ε,δ)-估计算法;第5节介绍不可一阶改写查询的近似一致性判定方法;第6节使用实验验证估计算法的效率和准确性以及近似判定算法的效率和准确率;第7节总结全文以及提出未来工作.2相关工作针对数据不一致问题,目前的处理方法主要有两种.一种是建立描述一致性的相关规则,一旦数据集合中数据集违反了规则,则对数据进行修复使其处于一致的状态.近年来随着数据质量越来越引起人们的重视,越来越多的规则被提出用来描述数据的一致性.主要有以下几种:否定约束[4]、包含依赖[5]、外键约束和函数依赖[6]、聚集约束[7]、元组生成和等值生成依赖[3].同时有多种修复方式,例如:对称差分修复[3]、子集修复[8]、基数修复[9]、基于更新的修复[10]、投影连接修复[11]等.即使检测出不一致数据,也可能没有确定的方法在保证数据真实准确的条件下完全修复不一致.基于此,文献[12]第一次提出了一致性查询问题,一致性查询问题是指在存在不一致性数据的数据集合中,不完全修复数据情况下,查询得到一致性的查询结果,而查询结果的一致性由不一致数据的可能修复定义.文献[3]定义了修复语义下的一致性查询,即查询需要满足所有的修复.文献[13]是数据修复和一致性查询回答的一个综述.国内也对一致性查询处理问题有了综述相关的研究[14].文献[15]研究了基于空值的一致性查询处理,将一致性约束转换为和查询相关的约束,查询过程中将不一致属性作为空值进而返回一致的查询结果,此方法得到的查询结果可能会丢失有用数据.目前关于主键约束,子集修复的一致性查询已经有较多的研究成果.文献[16]提出了EQUIP系统解决合取查询的一致性查询问题,其将一致性查询的补问题规约到01整形规划问题,通过求解规划方程去掉不满足一致性的解,最终得到一致性的回答.此外,基于析取逻辑程序以及稳定语义模型可以解决任意合取查询的一致性回答问题[17],且一致性限制并不局限于主键约束.然而其复杂度为Π献[18-19]首次提出并研究了CERTAINTY(q)问题,即布尔查询的一致性判定问题.研究一致性查询的一个重要成果是一阶查询改写,一阶查询改写指将初始查询进行一阶改写,使得执行改写之后的查询可以得到原查询在数据集中的一致性查询结果.文献[18-19]定义了一个可以一阶改写的不带自连接的合取查询类Cforest,该类中的所有查询均可改写为一阶查询,从而在多项式时间内返回查询的一致性回答.同时,他们指出对于q=xy(R(x,y)∧R(y,z))不在Cforest中,然而其是一阶可表达的.文献[20]提出了一个包含一阶可表达的查询的更大的类,指出不在该类中的涉及到两个不同关系表进行连接操作的查询一定是不可一阶改写的(关系表的个数大于2时没有此结果).后来又给出了无环无自连接的合取查询一阶可表达的充分条件,其通过建立攻击图,当攻击图无环时则可得到查询时是一阶可表达的.此外,文献[21]研究了满足函数依赖的情况下基于主键约束的一致性查询问题,其首先认为数据库是部分一致的(满足函数依赖),基于此研究了CERTAINTY(q,Σ)问题.即在满足函数依赖集合Σ的情况下,q是否是一阶可表达的,此问题限制q不带自连接.文献[22-23]研究了CERTAINTY(q)的变种:计数的复杂性问题,记为#CERTAINTY(q).给定一个数据集db,#CERTAINTY(q)返回满足q的db修复的个数,同时指出了对于不带自连接的合取查询q,#CERTAINTY(q)是P问题或是#P-完全问题.本文的工作和查询一阶改写及#CERTAINTY(q)问题相关.然而,不同于之前的工作,当查询不可进行一阶改写时,本文并不确切地计算#CERTAINTY(q)的值,因为此问题可能是难解的.相应的,给定一个元组t,计算#CERTAINTY(q(t))的一个下界,当其满足给定的阈值时,近似认为t属于一致性回答.3背景知识首先,我们在3.1节介绍一致性查询的模型,3.2节给出查询一阶可表达的判定方法.Page43.1一致性查询模型定义1.不一致性.对于描述一致性的规则(约束)集合Σ,数据集合I称为一致的,当且仅当满足IΣ,否则,I成为不一致数据集.定义2.修复r是不一致数据集I关于规则集合Σ的一个修复当且仅当:(1)rΣ,(2)不存在r满足rΣ且r的修复代价小于r.定义3.一致性查询.给定规则集合Σ以及不一致数据集I,对I的任意查询q,其一致性查询结果定义为CQAq有可能修复.本文研究的不一致查询问题的一致性约束规则为主键约束,修复类型为子集,查询类型为合取查询.若关系数据集I满足主键为x,关系模式为R(x,y,z)的主键约束,则对于t1,t2∈I,若t1.x=t2.x,则t1.y=t2.y且t1.z=t2.z.将数据集中具有相同主键的元组结合称为一个块,假设主键值为a,记#block(a)为主键值为a的元组集合的个数.数据集I关于规则集合Σ的修复r是子集修复当且仅当:(1)rΣ,(2)不存在|r|<|r|且r是I的一个修复.合取查询是包含选择、投影和连接操作的查询,其datalog表示形式为q(u0):-R1(u1),R2(u2),…,Rn(un),其中R1,…,Rn表示关系名,u0,u1,…,un是相应关系表中的自由元组,由常量和变量组成,Ri(ui)称为q中的原子公式.当q中所有表名只出现一次时,称查询q为不带自连接的查询.当u0为空时,q为布尔合取查询.3.2查询一阶可表达的判定主键约束下基于子集修复的合取查询的一致性查询是coNP-完全问题.然而,对于合取查询的一些子查询,可以在多项式时间内计算其一致性查询结果.此类子查询具有的一个重要性质即一阶可改写.文献[24]中给出了无循环无自连接的一致性合取布尔查询一阶可改写的必要条件(见定理1),其通过查询q的join树[25],建立查询q的攻击图,根据攻击图给出查询的一阶改写查询q,使用q对数据进行查询操作,查询的结果等价于q的一致性查询结果.定理1.假设q为非循环无连接布尔连接查询,若q对应的攻击图Gq无环,则CERTAINTY(q)是一阶可表达的.攻击图的建立需要join树,查询q的join树是一个无向连通树,树中的每个节点表示查询中的一个原子公式且满足如下条件:若变量x出现在两个不同的原子公式Ri和Rj中,则x出现在连接Ri和Rj的唯一路径上的所有原子公式中.若一个查询存在join树,则称该查询是无环的.查询q的攻击图为一个有向图,攻击图中的顶点由q的原子公式构成.原子公式具有主键约束,主键约束使得原子公式所代表的关系表中存在着属性值间的函数依赖.例如,在原子公式F:R(x,y,z)中,X是R的主键,则存在着函数依赖{x}→{x,y,z},可以简写为x→xyz(等价于x→yz).此函数依赖不同于一般意义上的函数依赖,显然,此函数依赖的变量与查询相关.记集合κ(q)为查询q中的函数依赖集合.集合F+,q为F的主键集合KVars(F)关于原子q\{F}中的函数依赖集合的属性闭包.其中,属性闭包的概念来源于关系数据库理论,如果Σ是属性集U上的函数依赖,XU,则X关于Σ的属性闭包是集合{A∈U|ΣX→A}.攻击图中有一条从F到原子公式G的边当且仅当F+,q不包含join树中F到G的唯一路径上出现的所有变量.例2.查询q:-R1(x,y),R2(u,x),R3(y,x,z),R4(x,z)的join树和攻击图为图1[21]所示.对于无环查询q的攻击图Gq,若图中顶点F=R(x,y)的入度为0,则称F不被任何顶点攻击,设q=q\{F},φ(x,y)为q(x,y)的一阶改写,则q可一阶改写为Rewrite(F,q)=xy(R(x,y)∧y(R(x,y)→φ(x,y)).4问题定义及估计算法4.1问题定义一致性查询估计的目标是估计查询结果的一致性程度,一致性程度是指查询结果中是一致性查询回答占总的查询结果的比例.可以用一个概率值来描述,记为一致性程度pc,此估计问题形式化定义如下:Page5问题:一致性查询估计输入:合取查询Q,D,主键约束集合Σ输出:Q(D)的一致性程度pc已知当查询Q一阶可表达时,可以在多项式时间内得到Q的一致性回答,因此,估计算法需要首先判断Q是否是一阶可表达的.当查询可一阶表达时,则可以直接执行其一阶改写后的查询,得到一致性答案集合,使用一致性答案集合的元组个数除以Q(D)中的元组个数,计算一致性程度估计pc.当查询不可一阶表达时且不能在多项式时间内计算其一致性查询结果时,需要近似的估计查询结果的一致性程度.下一节(4.2节)说明当查询不可一阶可表达时,如何估计查询结果的一致性程度.4.2一阶不可表达的查询结果一致性估计当Q不可一阶表达时,且Q的一致性回答不能在多项式时间内计算时,需要Q(D)中的每条元组,将其元组t的属性值赋给Q后形成布尔查询q=Q(t),判断q的一致性回答是否为“是”,当q的一致性回答为“是”时,t是Q的一致性回答.然而,当查询结果集很大时,若是对每一条元组都判断其是否是一致的回答将会非常耗时.因此,当查询的个数大于30时,本文将采用抽样的方法给出查询结果pc的一个(ε,δ)-估计p^c,(ε,δ)-估计的定义见定义4.当查询结果小于等于30时,对答案集中的每一条元组,判定其一致性,返回一致性的元组在答案集合中的比例.定义4.(ε,δ)-估计.对于任意ε(ε0)和δ(0δ1),I^是估计量I的估计值,如果Pr(|(I^-I)/I|ε)δ.其中Pr(X)随机事件X发生的概率,称I^是I的(ε,δ)-估计.将Q(D)做为总体,可以用随机变量Xi表示Q(D)中第i个元组ti的一致性.其中,Xi=1表示ti是一致的答案,即对于数据所有的修复,ti都出现在查询的结果中.Xi=0表示ti是不一致的答案,即存在一个修复,在此修复下,ti不出现在查询的结果中.基于此,抽样算法如算法1所示.算法1.抽样算法.1.根据ε,δ确定抽样的次数;2.对Q(D)进行重复抽样,判定抽出的样本的一致性;3.计算Q(D)的一致性程度估计p^c.算法第1步需要确定抽样次数,抽样次数由ε,δ决定.由定理2可知,抽样的次数和查询回答的个数无关.定理2.如果抽样次数n满足:np^c是pc的(ε,δ)-估计,其中δ/2是标准正态分布的δ/2分位点.证明.p^c的方差var(p^c)=由n24ε2+1知:n-1可得var(p^c)又由0E(pc)=pc1,var(p^c)可得δ/2×var(p^c槡)εpc则由中心极限定理可得Pr(|p^c-pc|δ/2×var(p^c槡))δ则Pr(|p^c-pc|εpc)δ,即Pr(|(p^c-pc)/pc|ε)δ.算法第2步需要对抽出的样本进行一致性判定,即判定t∈CERTAINTY(q)?已知此问题的上界是coNP-完全问题,因此在NP≠P的假设下没有确定的多项式时间算法判定查询是否有一致性答案.基于此,对于复杂度为coNP-完全问题的一致性查询,定义了近似一致性判定.第5节介绍近似一致性判定算法.对于不可一阶表达,但是一致性回答可以在多项式时间内获得的查询.例如,查询Q(z,w):-R1(x,y,z),R2(y,x,w),其不可一阶改写,然而,可以在多项式时间查询得到其一致性解.此类查询的一个重要特征是连接属性全部出现在查询的主键变量集合中.对于此类查询,可以首先对其攻击图进行去环查询改写(见定义7),在去环查询得到的结果集中在多项式时间内过滤掉不满足一致性的解,从而精确的计算一致性程度.5近似一致性判定算法由于当查询无环且不存在自连接时,定理1成立,因此本文分两种情况考虑布尔查询q的一致性判定.5.1节针对无环无自连接的查询,5.2节简单地说明了查询有环或是自连接时的处理方法.5.1无环无自连接的查询近似一致性判定算法当Gq有环时,使用攻击图无法在多项式时间内判定CERTAINTY(q),因此,本节提出了近似一致性判定的概念.在介绍近似一致性判定之前,我们首Page6先介绍一致性准确率的概念.定义5.一致性准确率.假设数据实例I有n种修复,元组t∈q(I)在n中修复下被返回,则t的一致性准确率为n/n.在近似一致性判定中,使用一致性准确率来表示一致性的近似程度.定义6.近似一致性回答(τ-CERTAINTY(q)):给定近似阈值τ(0<τ<1),对于t∈q(I),如果t的准确率ptτ,则t为q的τ-近似一致性回答.当τ=1时,t为q的一致性查询回答,若CER-TAINTY(q)不是一阶可表达的,则CERTAINTY(q)可能是co-NP完全问题.因此,设τ<1,计算t的τ-近似一致性回答判定答案.通过观察我们发现:对于q,若q的一致性回答为“是”,则去掉Gq的环,对其进行改写得到qrelax,则qrelax的一致性回答为“是”,即所有提供q一致性回答为“是”的中间结果是所有提供qrelax一致性回答为“是”的中间结果的子集.因此,定义了查询的去环操作,如定义7所示.定义7.去环查询改写.对于无环无自连接的合取查询q(u0)=R1(u1),R2(u2),…,Rn(un),n1,若q的攻击图存在环Ri,Rj,…,Ri,则存在一个查询qrelax(u0)=R1(u1),R2(u2),…,Rn(un),n1,ui为Ri中修改的变量集合.若qrelax的攻击图无环,且不存在u,使得uu,则称qrelax是q的一个去环查询改写.例3.设q1=R1(x,y),R2(z,y),则改写后的查询qrelax=R1(x,y),R2(z,y).去环操作放松了查询条件,减少了连接属性的个数.因此,去环之后的查询qrelax和原来的查询q在查询结果上有定理3所描述的关系.此外,提供qrelax一致性回答为“是”的中间结果包含执行q一致性查询的中间结果.基于此,本文使用qrelax的中间结果近似判定q的一致性回答是否为“是”.定义8形式化定义了近似判定q的一致性回答需要用到的qrelax的中间结果.定理3.查询q的改写qrelax的一致性查询结果为否,则q的查询结果为否.显然,由于qrelax实际上放松了q的查询条件,定理3成立.定义8.见证元组集合.设qrelax是q的一个去环查询改写,若qrelax的一致性回答为是,则见证元组集合witness(Ukey,U)为使得qrelax回答为是的中间结果集在Ukey,U属性集上的投影.其中Ukey,U由常量和变量组成,Ukey表示q改写生成qrelax时改变的原子的主键值,U表示改变后的原子变量和被改变的原子变量组成的变量对的值.例4.查询q1的见证元组集合witness(x,z,(y,y))为R1,R2的笛卡尔集.若qrelax的一致性回答为“否”,则由定理3,q的一致性回答为“否”.假设执行qrelax一致性回答为“是”,执行过程中生成的witness(Ukey,U)中有元组t使得t.U中每对值相等,则可以根据t计算满足q的修复比例,即一致性准确率,近似判断q的一致性回答.满足q的修复由两部分组成:(1)t.Ukey=t.Ukey,t.U≠t.U且t出现在witness中的元组加上t所代表的修复个数之和,记满足条件的元组个数为l.此部分元组满足修复的比例为frac_part1=l/#t,其中#t=#block(t.xi).比如表3中t,t1,t2,t3,t4,l=5,∏1ikfrac_part1=5/#t;(2)t.Ukey=t.Ukey且不出现在witness中的元组集合所代表的修复个数.比如元组(a,…,c,(0,1),…(1,1)).(1)和(2)组成的元组共有#t个,需要为#t-l个元组计算其所能代表的q满足的修复个数.查看表,如果存在t5,t6类型的元组,即t.Ukey≠t.Ukey使q为“是”,则说明在取t5,t6所在的元组为数据修复的一部分时,xk所在的关系表中主键为c值的元组可以任取组成完整的修复.t5,t6的不同在于t5.x1=t.x1,t5提供的修复比例为(#t-l)·#block(x1)/(#t·#t5),t6提供的修复比例为(#t-l)/(#t·#t5).这是因为对(2)中满足条件的每个元组而言,t5类型的元组满足部分修复为形成t5的xk所在的关系表中的元组,主键为d值中的一条,以及形成t5的x1所在的关系表中主键值为a的一条,以及其他关系表的任意修复.因为a已经出现在t中,因此,其代表的修复比例为#block(x1)/(#t·#t5).然而,t5和t6提供的修复中有重复的情况,需要减去交集,即交集占的修复比例为1/(#t5·#t6).因此,假设有m条类似于t5,t6这样的元组t1,…,tm,则其提供的修复比例为p=(#t-l)p(frac_t1∪…∪frac_tm),frac_ti为元组ti提供的修复比例,其中frac_ti=∏1ik.ti.xi=t.xip(∩frac_ti)=∏1/#ti,p可使用相容事件发生的概率公式计算.然而,当m较大时,计算为指数时间.由于p(#t-l)p(frac_ti),因此我们可以首先计算单个元组提供的修复比例,将p=p+p和给定的近似性阈值比较,以尽早终止算法.显然,当处理完所有的(1)(2)类型的元组时,p<1,则q的一致性答案返回“否”.Page7t0t1t2t3t4t5t6…具体判定算法如算法2所示.算法2.近似一致性判定.输入:查询q的去环查询改写qrelax,近似性阈值τ输出:q的近似一致性回答“是”(1)或者“否”(0)1.一阶改写qrelax为qfo,执行qfo,记录见证元组集合witness(Ukey,U),设Ukey={x1,…,xk},U={(y1,y1),…,(ym,ym)},若qfo结果为空,则返回“0”;2.否则,删除witness(Ukey,U)中U中yi≠yi的元组.若删除后有元组t,对于1ik,#block(t.xi)=1,则返回“1”;3.否则,寻找元组t,使得∏1ik过程1和过程2计算返回结果.过程1.1.寻找witness中t.Ukey=t.Ukey,t.U≠t.U记满足条件的元组个数为l;2.p=(l+1)/#t.过程2.1.寻找witness中t.Ukey≠t.Ukey的元组集合t1,…,tm.j=1;2.计算p=(#t-l)p(∪3.若p+pτ且j<m,则返回“1”;若j=m,p+p<1,则返回“0”;若p+p<τ且j<m,则j=j+1,返回步2.近似一致性判定算法第1步需要将qrelax改写为一阶查询,之后可以将一阶查询修改为SQL语句,在现有的支持SQL操作的数据库上如PostSql,可以直接执行.若执行查询后查询结果为空,由定理3,直接返回q的一致性回答为“否”,否则,算法在第2步中判断是否由一致性的数据可以使q的回答为“是”.若有,则说明不一致数据集无论怎么修复,都存在元组使得q的回答为“是”,即一致性判定结果为“是”.若不存在这样的一致性元组,则算法执行第3步.分之前介绍的两种情况计算满足q的回答为“是”的修复比例.在计算过程中,如果计算的修复比例pτ时,算法终止,返回“是”.显然,若t不是q的一致性查询回答,算法提前结束,然而t可能为τ-CERTAINTY(q).在估计查询答案集合的一致程度时,若将t作为满足τ-CERTAINTY(q)的答案返回,则会过高的估计查询的一致程度,因此,只有当t在当前计算中不能断定其是不一致时,才考虑近似一致性,近似认为t是一致的.算法的正确性分析.对于witness中某个固定的t,算法考虑了t所涉及到的关系表的主键在所有可能下的修复情况,因此,当τ=1时,算法能够确定的计算出所有满足q的修复比例.当计算的修复比例为1时,确定的说明了q的一致性回答为“是”,否则,则说明q的一致性回答为否.τ<1时,当p>τ时,近似返回了q的一致性回答为“是”;当p<τ且算法终止时,q的一致性回答可确定为“否”,即对于“否”的答案,算法返回的结果都是确定的.对于“是”的答案,算法返回的结果可能是近似一致的.算法的时间复杂度分析.对于q(u0)=R1(u1),R2(u2),…,Rm(um),m1,攻击图建立的时间为O(m3),无循环改写和一阶改写为常数时间.设Ri的元组个数n,算法第2步的时间为O(nm),算法第2步最坏情况下为m个表的笛卡尔积,即O(nm).第3步最坏情况下需要调用过程X,假设witness最坏情况下为O(nm),则计算p需要花费的时间为nm+C2m,因此总的时间复杂度为O(2n2n下τ=1时计算q答案为“是”时的修复个数为#p-完全问题[23].然而,在现实数据库中,由于多表连接结果远小于O(nm),且给定的τ<1,数据集的不一致性很小,造成且生成的witness表也不会太大.因此,算法在执行过程中的时间复杂度要远远低于指数级.实验很好地说明了这一点.5.2循环和自连接的查询τ-近似一致性回答判定对于无循环的合取查询,可利用join树建立权重攻击图,而有循环的合取查询,不存在join树.文献[24]中指出有环的查询可以使用intersection树建立攻击图.然而,intersection树建立的攻击图不唯一,因此存在误判的情况,即攻击图无环时,查询不一定可一阶改写.考虑到此情况,本文将在建立攻击图之前改写查询q,将导致环出现的查询变量使用新的变量代替qacylic,然后为新的查询建立攻击图.此时,当攻击图中无环时,由定理1可得,qacylic是一阶可表达的.显然,qacylic的回答为“是”并不意味着q的一致性答案为是.此时,我们需要计算qacylic计算过程中生成“是”的中间结果改写后变量的赋值是否Page8和原始变量值相等,可以使用5.1节算法近似判断q的一致性.当攻击图有环时,需要对qacylic进行查询改写,此时qacylicrelax括qacylic中的变量以及新的改写新加的变量集合,之后的过程同5.1节相同.对于存在自连接的查询,假设查询q中存在自连接R(x,y)∧R(y,z),则引入新的原子公式R,使得R(x,y)∧R(y,z)改写为R(x,y)∧R(y,z),形成新的查询qsjf,然后将qsjf作为无自连接的查询判断其回答的一致性.无论qsjf是否可一阶表达,都需要在witness中判断是否(x=y)∧(y=z).6实验当q(u)为合取查询时,在主键约束下解决CERTAINTY(q(u))问题主要有Conquer[18]和EQUIP[16]两个系统,其中Conquer系统适用于查询可进行一阶改写的情况.此系统将改写过后的一阶查询再次改写为SQL语句,可以在任意不一致的数据集中得到一致的查询结果.显然,此系统不依赖于数据集,仅依赖于查询语句.EQUIP系统则适用于所有的合取查询,该系统将数据集和查询规约成一个0-1整数规划(BIP)问题.通过解方程组得到不满足一致性查询的解,将不一致解全部去掉之后得到最终一致性的查询结果.较之Conquer系统,此系统依赖于数据集,当数据集改变时,整数规划方程需要重新建立.由于系统性能受多种因素的影响,例如,数据集的不一致程度,查询解空间的大小等.目前,并没有一个基准的测试用于比较其各自的性能[21].不过,大量的实验表明,如果查询是一阶可表达的,则将一阶查询变换为SQL语句的执行效率要高于EQUIP系统的效率.这是因为BIP问题是NP-完全问题,而一阶查询的问题复杂性为AC0.不同于Conquer系统和EQUIP系统,本文不关注于求解查询的一致性答案,而是评估查询q在不一致数据集中的查询结果的一致性.显然,对于不涉及到数据集中不一致数据的查询结果,其一定是一致的.对于涉及到不一致数据的查询结果,则需要评估其一致性,因此,实验关注于评估的效率和评估的准确度以及不一致程度对评估准确度和效率的影响.6.1实验配置和数据集本文的实验在PC机上运行,其内存4GB,硬盘500GB,CPU为Pentium@2.93GHz,操作系统为Windows7,所有算法用C++实现.其中,查询实验使用PostgreSQL,版本为9.3.4-3.(1)基准查询.对于不同的查询,一致性查询问题的复杂度从多项式时间到coNP-完全不等.因此,我们设计多组查询针对不同的情况对查询的一致性进行估计.查询从时间复杂度上可分为3组:①可进行一阶改写的查询;②多项式时间,但是不可进行一阶改写;③coNP-完全.对于多项式时间但是不可进行一阶改写的查询,可以对其进行qrelax改写之后在多项式时间过滤掉不满足q一致性回答的qrelax回答.3组查询设计来源于文献[16],如表3所示.可一阶改写查询多项式时间但不可一阶改写查询coNP-Hard查询(2)真实数据集.真实数据集是NBA球员数据集①.该数据集来源于篮球信息的一个网站以及维基百科,由3个表组成:球队信息team,由68条记录构成,球员球队关系表play_team,由9413条记录构成;以及教练球队关系表team_coach,由639条记录构成.由于数据的记录时间不同,若选择合适的主键,则存在着不一致的数据.例如,在球员球队关系表中,假设以球员作为主键,则球员可能会在不同的时期属于不同的球队.受数据集的限制,我们设计两类真实数据集上的查询:一类为多项式时间可解的,另一类的计算复杂度为coNP-完全,查询设计如下:q1(y,z)=team(x),play_team(y,x),q2(y,z)=team(x),play_team(y,x),其中x表示球队,y表示球员,z表示教练.q1的一致性回答在多项式时间内可以,q2则不可以.(3)合成数据集.由于TPC-H的数据集大多不能表示不可一阶改写的查询的语义特征,因此,本文设计数据来验证基准查询的性能和估计的准确性.数据集的生成由两部分组成:①根据查询生成一致①http://www.basketball-reference.com和wikipediaPage9的数据集.为了方便查询的执行,数据集中的属性值类型均为数字类型,数据集中关系表的主键根据选择的基准查询来确定,关系表的规模相同,在生成关系表时,使得任意两表连接的结果大概占原始表的20%;②在一致的数据集中引入不一致性.采用的方法为在一致的数据集中加入新的元组,新元组的主键值来源于一致数据集中的主键值.此过程由两个参数控制:①#conflicts,即加入元组的个数;②key_size,即主键相同的元组的个数,默认为2.(4)参数设置.设计近似一致性的近似阈值为0.5;抽样算法中ε为0.1,δ为0.2.6.2实验结果实验的目标是验证估计算法的效率和估计的准确率,以及判定算法的效率和准确率.我们首先在真实数据集上验证估计和判定算法的效率和准确率.之后在合成数据集上更深一步地挖掘算法所具有的特征.数据集中,不违背主键约束的数据是一致的,从这部分数据中查询所得到的结果也是一致的.因此,每次实验我们将查询结果集ans分为两个部分:ansc和ansn.其中ansc代表从一致的数据中查询得到的答案,ansn表示从剩下的数据中查询得到的结果和ansc的差集.显然,在验证估计算法时,ansc集合中答案的一致性判定为1,只需对ansn中的答案进行近似一致性判定时.实验过程中抽样算法执行五次,其平均值为算法的效率和评估的准确度,同时对抽出的样本计算其判定的平均准确率.6.2.1真实数据集上算法的效率和准确性由于q1在多项式时间内可以查询到其一致的解.因此,其一致性为q1经过一阶改写的查询得的结果集的个数占q1查询的结果个数的比例,估计的准确度为1.此时,不需要进行近似一致性判定.对于q2,首先要对其进行qrelax改写,在qrelax查询的结果集中进行抽样,判断样本的近似一致性.两个查询的效率和准确率如表4所示.表4真实数据上的一致性查询效率及有效性查询q1q2cons(q1)cons(q2)由表4可以看出,一致性查询的时间要远远大于查询时间,其中,q2的一致性查询我们采用EQUIP中的方法得到查询结果.q1的一致性估计的准确度为100%,一致性判定准确率也为100%,这是因为我们可以在多项式时间内求得q1的一致性回答.q2的一致性判定准确率为85%,其一致性估计的准确度由两个因素决定:抽样算法给定的δ以及近似一致性估计所带来的误差.实验中查询生成112724条结果记录.其中ansn的个数为103165:抽样算法抽出42条记录判断一致性.从图中可以看出,其总的误差为15%.准确率没有超过90%的原因是由于近似一致性估计中错误的将不一致的答案判成了一致性答案.近似一致性判定的平均准确率为70%.6.2.2合成数据集上算法的效率和准确度.为了进一步研究算法的性能,我们在合成数据集上进行了一系列的实验.首先验证了评估算法的时间效率.图2比较了基准的6个查询直接查询得到查询结果的时间效率以及查询一致性结果的效率.从图中可以看出,Q2的一致性查询时间较长,这是因为Q2的一阶改写较为复杂.Q5,Q6的一致性判定为coNP-完全问题.在实际判定时,由于连接结果可能很小,可迅速的判断出其一致性,即近似估计算法在实际计算中效率不会很差.其次,实验比较了评估算法的准确性.评估的准确性由两部分确定:(1)抽样算法的相对误差造成的准确性降低;(2)判定算法中判定查询结果是一致的时候,使用了近似的方法,使得最终结果可能会出现将一致的数据误判为不一致的数据,进而造成评估值小于实际值.图3中由于近似阈值设置在0.5,即当50%的修复被满足时认为元组在一致性结果集中,造成了coNP-Hard查询的准确率最低在50%左右.显然,能够一阶改写的查询的评估准确率为100%,不能被一阶改写然而可以在多项式时间内可解的查询可以使用本文介绍的qrelax改写方法,得到精确的一致性解.Page106.2.3参数对算法性能的影响.首先我们考虑抽样算法关于(ε,δ)的相对误差以及样本容量对相对误差的影响.实验取ε为0.05,0.1,0.15,0.2,δ的值取0.1,即10%.实验结果如图4、图5所示.从图4中我们可以看出,抽样算法的相对误差控制在δ附近,当ε取0.05时,相对误差的值为8%,ε越大,相对误差越小.图5表明了随着样本容量的增加,相对误差逐渐减小.当抽样的样本量为总体的20%时,相对误差低于3%.这是因为当样本容量增加时,更能够反映样本的总体特征,从而使评估值更接近实际.其次,考虑了在近似一致性判定算法中,近似阈值τ对近似一致性判定准确率的影响.此组实验取Q5查询5次测试的平均结果,结果如图6所示.可以看出,随着近似阈值的增大,判定的准确度随之增加.当近似阈值为0.7时,一致性判定的准确率在90%以上.显然,当近似阈值较大时,若一个元组是不一致回答,则其被判定为不一致的机会也大大增加,使得最后误判的结果数量减小,从而提高准确率.此外,我们还分析了数据集不一致程度以及查询结果集的大小对评估算法效率的影响,实验结果如图7、图8所示.当不一致程度增加时,满足一致性的查询回答减少,对于coNP-Hard一致性查询来说,其判定时间也会减少,见图7中Q5,Q6的评估时间,也随之减少,对于多项式时间及一阶可改写查询来说,其变化较少,只是因为不一致程度的增加不会改变数据集的扫描次数,对时间效率上不会有太大的影响.而查询结果集的大小对一致性查询和近似一致性查询的影响很小,查询时间紧随着结果集的增大有着小幅增长.需要注意的是对于coNP-Hard一致性查询来说,由于结果集在抽样之后可以一次性的判定其一致性,因此,结果集的增加不会使时间变化过大.Page117结论和未来工作本文研究了违背主键约束的不一致数据集中的查询结果一致性估计问题.当查询不可一阶改写且不能在多项式时间计算时,采用简单抽样的方法给出了合取查询结果集关于一致性准确率的(ε,δ)-估计.抽样算法均匀随机的抽取查询答案集合,判定样本的一致性.由于判定答案是否是一致性回答的问题可能是难解的,本文定义了近似一致性,以大于给定的近似阈值来判定答案的一致性.下一步工作将考虑一致性依赖是其他形式,比如函数依赖时查询结果的一致性估计问题,以及不一致数据程度对查询结果一致性的影响.
