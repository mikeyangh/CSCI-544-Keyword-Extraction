Page1一种求解MPMGOOC问题的启发式算法武优西1),5)吴信东2),5)江贺3),5)闵帆4),5)1)(河北工业大学计算机科学与软件学院天津300130)2)(合肥工业大学计算机科学与信息工程学院合肥230009)3)(大连理工大学软件学院辽宁大连116621)4)(漳州师范学院粒计算重点实验室福建漳州363000)5)(佛蒙特大学计算机系佛蒙特州伯灵顿05405美国)摘要具有间隙约束和一次性条件的最大模式匹配(MaximumPatternMatchingwithGapsandOne-OffCondition,MPMGOOC)是一种具有通配符长度约束的模式匹配问题,其任务是寻找彼此互不相关的最多出现.文中基于一种新的非线性数据结构———网树,提出了一种解决MPMGOOC问题的启发式算法.与树结构不同之处在于,除根结点外,网树中任何结点可以多于1个双亲结点.文中给出了网树的定义及其相关的概念和性质.基于这些概念和性质,提出了一种选择较优出现(SelectingBetterOccurrence,SBO)的启发式算法.该算法在搜索一个出现的循环中,采用了贪婪搜索双亲策略(StrategyofGreedy-SearchParent,SGSP)和最右双亲策略(StrategyofRightMostParent,SRMP)寻找相同叶子的两个出现并选择其中较好的出现作为SBO算法的结果.SGSP策略的核心思想是每一步都寻找当前结点的一个近似最优双亲(ApproximatelyOptimimalParent,AOP);SRMP策略的核心思想是每一步都寻找当前结点的最右双亲结点.实验结果表明,在多数情况下SBO算法可以获得更好的解且解的质量较其它算法有显著的提高.文中不但提供了一个解决MPMGOOC问题的启发式算法,更重要的是对于求解其它复杂问题具有一定的参考价值.关键词模式匹配;通配符;一次性条件;网树;启发式算法1引言模式匹配问题(也称串匹配问题)是计算机科学的基本问题之一,它是网络安全[1]、信息检索与过滤[2]、文字处理[3]、计算生物学[4]等重要领域的核心问题,同时也是模式挖掘技术的核心与基础[5-7].而带有通配符的模式匹配与模式挖掘使得问题变得更加复杂[8].在带有通配符的模式匹配研究中,主要有两类研究成果,一类偏向于通配符通配的字符长度是固定的;另一类偏向于通配符通配的长度是有约束的.Fischer和Paterson[9]在1974年第一次从理论复杂性角度对带有通配符的模式匹配问题进行了研究.近年来,通配符通配的长度是可变的问题正引起人们的广泛关注.Manber等人[10]提出的算法有效地解决了只有单个可变长度通配符的模式匹配问题;He等人[8]致力于通配长度小于指定值的频度模式挖掘问题;Huang等人[11]致力于具有多个可变长度通配符和一次性条件的频度模式挖掘问题;Min等人[12]提出了一个算法PAIG-RST(ReducedSpaceandTime),该算法有效地解决了具有多个可变长度通配符的模式匹配问题;Chen等人[13]提出了用于在线求解具有间隙约束和一次性条件的最大模式匹配问题(MaximumPatternMatchingwithGapandOne-OffConstraints,MPMGOOC)的SAIL算法,然而该算法不是一个完备的离线算法[11].本文提出的基于网树的启发式算法,可很好地求解离线MPMGOOC问题.网树结构(简称网树)[14]是对树结构进行拓展的一种新的非线性数据结构.网树不但具有很多树结构的概念,如树根结点、叶子结点、双亲、孩子、路径、层等概念,而且除根结点外网树结构中任何结点可以有多个双亲结点.为了解决MPMGOOC问题,本文先将该问题转化为一棵网树,并在网树上构造了许多新的概念和性质,基于这些概念和性质,提出了一个选择较优出现SBO(SelectingBetterOccur-rence)的启发式算法.SBO算法在计算一个出现的循环中,利用结点的最小根和最大根的概念和性质对问题的全局约束进行了考虑;利用结点的树根路径数、叶子路径数和树根-叶子路径数等概念与性质实现对位置出现数的计算.在此基础上形成了一个寻找出现的策略———贪婪搜索双亲策略SGSP(StrategyofGreedySearchParent),该策略的核心思想是每一步都寻找当前结点的近似最优双亲结点AOP(ApproximateOptimizationParent).此外,本文利用结点的最右双亲结点、最小根和最大根等概念实现了另外一个寻找出现的策略———最右双亲策略SRMP(StrategyofRightMostParent).SBO算法择优使用SGSP和SRMP策略的结果并以此求解MPMGOOC问题.SBO算法的空间复杂度和时间复杂度分别是O(W×m×n)和O(W×n×(n+m×m)),这里m,n和W分别是模式串P和序列串S的长度以及模式串P的最大间距.本文在实际生物数据上进行了72组对比性实验,实验结果显示:(1)在其中69个实例中,SBO算法的结果好于或持平于SAIL算法的结果;(2)SBO算法较大幅度地提高了SAIL算法的解的质量;(3)在其中56个实例上SBO算法取得了4个算法中最好的结果,而另外16个实例均十分接近最好解.因此通常情况下,SBO算法不但可以获得更好的解,而且解的质量较SAIL算法有较为显著的提高.本文第2节论述问题的定义并通过实例来解释MPMGOOC问题及其相关概念;第3节给出网树的概念和性质;第4节给出SBO算法同时对SBO算法的时间复杂度和空间复杂度进行分析,用实例说明算法的工作原理;第5节给出实际生物数据的测试结果并对结果加以分析;第6节给出本文结论.Page32问题定义尽管Chen等人[13]最早提出了该问题,但本节对该问题的定义进行重新描述,并增加一些新的概念和符号.通过一些实例对这些定义、概念和符号进行解释.定义1.给定一个模式串P=p0[min0,max0]p1…[minj-1,maxj-1]pj…[minm-2,maxm-2]pm-1和一个序列串S=s0s1…si…sn-1以及两个整数值最小长度Minlen和最大长度Maxlen,这里m和n分别是模式串P和序列串S的长度,pj≠(0<jm-1),si≠(0in-1).是通配符,可以匹配任何给定的字符.minj-1和maxj-1是给定整数值,代表模式字符pj-1和pj之间通配符可以匹配的最小和最大长度,这里0minjmaxj.W=max(maxj-minj+1)称为模式串P的最大间距.Minlen和Maxlen称为全局约束,minj和maxj称为局部约束[13].定义2.如果一个位置索引序列A=〈a0,…,aj,…,am-1〉服从如下约束条件这里0jm-1且0ajn-1,则称A是P在S中的一个出现[13].定义3.令集合T(S,P)代表模式串P在序列串S中的所有出现,集合T(S,P)的长度用|T(S,P)|来表示.定义4.给定两个出现B=〈b0,…,bj,…,bm-1〉和C=〈c0,…,ck,…,cm-1〉,如果存在bj=ck,则称出现B与出现C相关并称出现B和C都包含位置bj,这里0j<m且0k<m;否则称出现B和C互不相关.定义5.T(S,P)中子集T1(S,P)满足的任何两个出现都是彼此不相关的,则称子集T1(S,P)是具有间隙约束和一次性条件的模式匹配PMGOOC(PatternMatchingwithGapsandOne-OffCondi-tion).满足PMGOOC的最大子集T1(S,P)称为具有间隙约束和一次性条件的最大模式匹配MPMGOOC(MaximumPatternMatchingwithGapsandOne-OffCondition).定义6.给定一个出现B=〈b0,…,bj,…,bm-1〉和一个集合D={d0,…,dr,…,dl-1},如果bj=dr,则称出现B与集合D相关,这里0j<m且0r<l.与集合D相关的所有出现的数目称为集合相关数,用RS(D)来表示.定义7.与出现B相关的所有出现的数目称为出现相关数,用RO(B)表示;包含位置i(0i|S|-1)的所有出现的数目称为位置相关数,用RP(i)来表示.定义8.假定eD1且D2=D1∪{e},增加e后,多增加的相关出现的数目称为新增数,用I(e,D1)来表示,其计算方法为I(e,D1)=RS(D2)-RS(D1).定义9.令B=〈b0,…,bj,…,bm-1〉是给定模式串P和序列串S下的一个出现,在一次性条件(One-OffCondition)下,新序列串S=s0s1…sk…sn-1是在出现B下的新序列,记为(S-B),其sk计算方法如下:这里X表示为一个不可匹配的字符.下面给出3个实例对问题的定义及其相关概念与符号进行解释.例1.给定模式串P=a[0,1]b[0,1]c,序列串S=aabbcc以及最小和最大长度分别为MinLen=3,MaxLen=5.依据给定条件可知,模式串P在序列串S中所有出现T(S,P)是{〈0,2,4〉,〈1,2,4〉,〈1,3,4〉,〈1,3,5〉},故|T(S,P)|为4.依据定义5可知,MPMGOOC问题的解是{〈0,2,4〉,〈1,3,5〉},因为这两个出现是T(S,P)中互不相关最大子集.例2.与例1相同的P,S及全局约束条件,并令两个出现B=〈0,2,4〉和C=〈1,3,4〉,D={2,3}和i=2.依据定义4可知,出现B和C是相关的,因为出现B和C中都包含位置4;依据定义6可知,出现B和C都与集合D是相关的,因为出现B和C分别包含2和3,而2和3是集合D的两个元素.依据定义6和7可知,RO(B)=3,RO(C)=4,RP(i)=2以及RS(D)=4.依据定义9可知,在one-off条件下,在出现B下的新序列串为aXbXcX.例3.与例1相同的P,S及全局约束条件,并令e=3且D1={2,4}.依据定义6和8可知,RS(D1)=3且I(b,D1)=RS({2,3,4})-RS({2,4})=1.Page43网树的定义及性质文献[14]最早给出了网树的定义,但是为了求解MPMGOOC问题,本节在网树定义的基础上,给出了网树的一些新概念和性质并对这些概念和性质进行了解释.定义10.网树[14]是一种每条边具有“双亲-孩子关系”或“孩子-双亲关系”边标签的有向无环图DAG(DirectedAcyclicGraph)且网树中每个结点都可以有0个或多个孩子结点以及0个或多个双亲结点.网树还具有如下5个性质:(1)网树是树结构的拓展,它具备很多与树相似的概念,如根结点、叶子结点、层、双亲、孩子等概念;双亲结点;路径数可以不唯一;(2)一棵网树可以有多个根结点;(3)除根结点之外网树的其它结点可以有多个(4)从任意一个结点到达网树的一个根结点的(5)相同结点名称的结点可以在网树的不同层上多次出现.定义11.如果网树中所有结点都仅出现一次,可以直接使用结点的名称来表示该结点;否则如果结点i在不同层上多次出现,用ni的结点i.定义12.如果结点b在结点c与某一根结点的路径上,则称结点b是结点c的祖先.当前结点看作是自身的一个祖先.结点c的祖先集是由结点c的所有祖先构成的,用A(c)表示.定义13.给定一个结点集合D={d0,d1,…,dl-1},集合D的所有元素的祖先集的交集称为集合D的共同祖先集(Commonascendant),用C(D)表示,其计算方法为C(D)=A(d0)∩A(d1)∩…∩A(dl-1)(3)定义14.从结点ni树根路径数RPN(RootPathNumber),用Nr(ni来表示.根结点ni1的树根路径数为1,即Nr(ni1)=1.结点的树根路径数之和,即性质1.结点ni这里nikj-1是结点ni亲数.定义15.从结点ni径数称为叶子路径数LPN(LeafPathNumber),用Nl(nij)来表示,这里m是网树的深度.叶子nim的叶子路径数为1,即Nl(nim)=1.性质2.结点ni结点的叶子路径数之和,即这里nikj+1是结点ni子数.定义16.从所有根结点到第m层叶子结点的所有路径中包含结点ni径数RLPN(Root-LeafPathNumber),用Np(ni表示.性质3.结点ni路径数与其叶子路径数之积,即性质4.位置i的位置相关数是网树中结点名称是i的结点的树根-叶子路径数之和,即这里m是网树的深度.定义17.位置i在集合D的共同祖先集中的所有树根路径数称为位置i在集合D的路径分支数,用pb(i,D)来表示.性质5.位置i在集合D的路径分支数是共同祖先集C(D)中结点名称是i的结点的树根路径数之和,即这里l是共同祖先集的深度.为了解决MPMGOOC问题的全局约束,本文定义了结点的最小根和最大根的概念.定义18.一个结点可以抵达的最小根结点名称称为该结点的最小根;其可以抵达的最大根结点名称称为该结点的最大根.一个网树根结点的最小根和最大根都是其自身.性质6.结点的最小根和最大根分别是其所有双亲结点的最小根集合中的最小值和最大根集合中的最大值.亲结点称为该结点的最右双亲结点.定义19.结点的所有双亲结点中最后一个双图1给出了一棵网树.在这棵网树上,有一些结点名称多次出现.例如结点3既在第1层上出现又Page5在第2层中出现.本文采用n31和n32来分别描述第1层和第2层的结点3.结点n11、n21和n31是图1中网树的3个根结点;n22、n53和n63是网树的3个叶子结点.结点n32有两个双亲结点,分别是n11和n21.网树中,每条边具有“双亲-孩子关系”或“孩子-双亲关系”的标签.从其中任何一种边标签看网树,网树都是一种有向无环图,因此网树是一种具有边标签的有向无环图.如果不考虑边标签,图1中网树将有一个环路{n21,n32,n63,n42,n21}.网树的另外一个特征是从一个结点到达网树的一个根结点的路径数可以不唯一.例如图1中,叶子结点n63访问根结点n21有两条不同的路径,分别为{n21,n32,n63}和{n21,n42,n63}.在图1中,结点n63的祖先集(A(n63))为{n11,n21,n31,n32,n42,n63}.集合{n53,n63}的共同祖先集是{n11,n21,n32}.结点n32的树根路径数Nr(n32)为2,因为结点n32有两个双亲结点n11和n21且Nr(n11)=Nr(n21)=1.Nl(n32)=2,因为结点n32有两个孩子结点n53和n63且Nl(n53)=Nl(n63)=1.Nl(n22)=0,因为结点n22不能到达第3层结点.Np(n32)=Nr(n32)×Nl(n32)=4,因为图1的网树中,有4条不同的树根-叶子路径包含结点n32,即{n11,n32,n53},{n11,n32,n63},{n21,n32,n53}和{n21,n32,n63}.同理,Np(n22)=Nr(n22)×Nl(n22)=0,因为Nl(n22)=0.依据性质4可以计算,包含3的位置相关数RP(3)=Np(n31)+Np(n32)=5.pb(3,{n63})=Nr(n31)+Nr(n32)=3,因为结点名称为3的结点在集合{n63}的共同祖先集中出现两次;pb(2,{n63})=Nr(n21)=1,因为结点名称为2的结点在集合{n63}的共同祖先集中仅出现一次;结点n63的最小根为1,因为结点n63有两个双亲结点n32和n42且它们的最小根分别为1和2;结点n63的最大根是3;结点n63的最右双亲结点是结点n42.4算法设计为了求解MPMGOOC问题,一个合理的启发式策略是每次选择出现相关数较小的出现B作为结果.而为了找到这个出现B,第2个合理的启发式策略是每次选择新增数较小的点以便形成出现B.而每次查找并计算新增数较小的点的时间复杂度较高,第3个启发式策略是用位置相关数较小的点来替代新增数较小的点.本文利用每个结点的树根路径数RPN、叶子路径数LPN及树根-叶子路径数RLPN等网树的特殊概念及其性质实现对位置相关数的计算.本文还利用了网树的最大根和最小根的概念与性质,对MPMGOOC问题的全局约束条件进行考虑.这样将MPMGOOC问题等价地转换为一棵网树,并在此基础上设计出SGSP策略,实现了计算一个出现B1.因此在SGSP策略中应用了第2和第3个启发式策略.此外,本文还利用最右双亲结点、最小根和最大根等概念设计了SRMP策略,实现了求解一个出现B2.SBO算法是择优使用B1或B2,进而进一步实现每次选择出现相关数较小的出现这个启发式策略.4.1提出算法4.1.1SBO算法SBO算法的第1步是将模式匹配问题转化为一棵网树,即依据P和S创建一棵网树[14].当接收一个字符si(0i<n),检查si是否满足如下3条规则,如果满足相应规则,则按照对应规则创建一个结点或一条边,具体如下.规则1.如果si=p0,则在第1层创建结点ni1;规则2.如果si=pj且i与第j层某个结点j-1的距离满足局部约束条件(minj-1i-e-1nemaxj-1),则在第j层创建结点ni新建结点ni亲关系”;规则3.如果结点ni局部约束条件(minj-1i-q-1maxj-1),则可以在这两个结点之间建立“双亲-孩子关系”和“孩子-双亲关系”.SBO算法的第2步是依据定义18和性质6计算每个结点的最小根和最大根.之后,SBO算法在该网树下解决MPMGOOC问题,具体方案如下:如果出现B的相关出现数越小,则出现B越有可能是一个最优出现.为了找到相关出现数较小的出现,SBO算法从网树最后一个叶子结点开始依次向前查找包含该叶子结点的出现.为了找到局部最优解,SBO算法采用了SGSPPage6和SRMP两种策略寻找具有相同叶子结点的两个出现,并在两个出现中选择相关出现数较小的出现作为SBO算法的一个最优出现.之后依据定义9重新计算新序列串,并在新序列串中寻找下一个最优出现.迭代此过程,直至所有叶子结点都被检测一遍为止.因此SBO算法给出如下.算法1.SBO.输入:P=p0[min0,max0]p1…[minm-2,maxm-2]pm-1,输出:解C1.依据P和S建立一棵网树;2.计算每个结点的最小和最大根;3.fork=第m层叶子结点数downto1step-14.B1=SGSP(第k个叶子结点);5.y1=RO(B1);6.B2=SRMP(第k个叶子结点);7.y2=RO(B2);8.if(y1<y2)B=B1elseB=B2;9.C=C∪B;10.S=S-B;11.依据新的S重新计算各个结点的RPN;12.nextk13.returnC.4.1.2SGSP策略为了找到包含第m层叶子结点f的出现B,SGSP的核心思想是采用贪婪策略寻找局部最优解,即m-1次寻找当前结点的近似优化双亲结点AOP.所谓当前结点的AOP是指在满足全局约束的双亲结点中查找位置相关数最小的双亲结点作为当前结点的AOP;若两个双亲结点的位置相关数同样小,则在已获得路径B的共同祖先集中选择路径分支数最大的双亲结点作为当前结点的AOP.因此SGSP策略可描述为:首先计算每个结点的RPN、LPN和RLPN,然后计算每个位置的位置相关数,之后SGSP迭代m-1次寻找当前结点的AOP,具体给出如下.算法2.SGSP.输入:叶子结点f输出:出现B1.依据性质1计算每个结点的树根路径数;2.依据性质2计算每个结点的叶子路径数;3.依据性质3计算每个结点的树根-叶子路径数;4.依据性质4计算每个位置的位置相关数;5.B[m-1]=f;6.forj=m-2downto0step-1do7.依据性质5计算每个位置x的在已有路径B下8.r=B[j+1].number_of_parents;9.B[j]=B[j+1].parent[r-1];10.fork=r-2downto0step-1do11.ifB[j+1].parent[k]满足全局约束then12.if(RP(B[j])>RP(B[j+1].parent[k]))13.if((RP(B[j])=RP(B[j+1].parent[k])14.endif15.endfor16.endfor17.returnB4.1.3SRMP策略为了找到包含第m层叶子结点f的出现B,SRMP算法核心思想是每次迭代过程中都选择满足全局约束的最右双亲结点,具体给出如下.算法3.SRMP.输入:叶子结点f输出:一个出现B1.B[m-1]=f;2.forj=m-2downto0step-1do3.迭代查找一个满足全局约束的最右双亲结点作4.endfor5:returnB4.2复杂性分析SBO算法的空间复杂度是O(W×m×n),因为网树的深度为m,网树上每层最多有n个结点,每个结点最多有m个双亲结点,这里m、n和W分别是模式串P和序列串S的长度以及模式串P的最大间距.在讨论SBO算法的时间复杂度之前首先讨论SGSP和SRMP策略的时间复杂度.易知策略SRMP的时间复杂度为O(W×m).而SGSP的时间复杂度分析如下:SGSP的第1行和第2行(为每个结点计算RPN和LPN)的时间复杂度都是O(W×m×n),由于每个双亲-孩子关系都需要考虑,而按照算法的空间复杂度分析可知网树最多有W×m×n个双亲-孩子关系;SGSP的第3行和第4行的时间复杂度都是O(m×n),因为每个结点都需要被计算,而网树上最多有m×n个结点;第7行的时间复杂度为O(m2×W),因为计算pb(x,B)的时间复杂度是B的共同祖先集下结点的数量(其为O(m2×W)),这样第6~16行的时间复杂度为O(m3×W).故SGSP策略的时间复杂度为O(W×Page7m×(n+m2)).SBO算法的时间复杂度分析如下:由算法的空间复杂度分析易知,SBO算法的第1行和第2行的时间复杂度都是O(W×m×n);算法的第4行的时间复杂度是O(W×m×(n+m2));而给定一个出现B,计算S=S-B的时间复杂度是O(m);RO(B)的计算方法采用|T(S,P)|-|T(S,P)|的方法,因为计算|T(S,P)|的时间复杂度是O(W×m×n),所以计算RO(B)的时间复杂度也是O(W×m×n).SBO算法第6行的时间复杂度是O(W×m);第8~10行的时间复杂度均是O(m),因为模式串P的长度为m;第11行的时间复杂度是O(W×m×n).这样算法从第3行到第12行的时间复杂度为O(W×m×(n+m2)×n/m)=O(W×n×(n+m2)),因为该问题的出现数最多为n/m个.故算法SBO的时间复杂度为O(W×n×(n+m2)).图2实例求解示意图网树第4层的最后叶子结点是n74,因此SBO算法调用SGSP和SRMP两种策略来分别计算两个包含结点n74的出现.SGSP策略工作过程如下:第1行按照性质1计算每个结点的RPN值.例如Nr(n32)是2,因为结点n32有两个双亲结点n11和n21且Nr(n11)=Nr(n21)=1,每个结点的RPN值在图2(b)中每个结点的上方给出.第2行按照性质2计算4.3运行实例例4.给定模式串P=a[0,1]a[0,1]a[0,1]b,序列串S=aaaaaabb以及最小和最大长度Minlen=4,Maxlen=7.依据网树的创建规则,创建结果如图2(a)所示.从图中可以看出,某些位置索引被创建为多个网树结点,例如:位置索引2被创建为3个网树结点,分别位于网树的第1、2和3层,因为s2=a可以与p0=a,p1=a和p2=a分别匹配.依据性质6对每个结点的最小根和最大根进行了计算,其结果给出在每个结点的上方.使用结点的最小根和最大根可以判断当前结点及其祖先集结点是否满足全局约束.例如因为结点7的最小根和最大根分别为1和3且4=Minlen7-3+17-1+1Maxlen=7,所以结点7及其祖先集结点都满足全局约束.易知本实例中所有匹配都满足全局约束.每个结点的LPN值.例如Nl(n23)=Nl(n33)=0,因为结点n23和n33都不能抵达网树的第4层叶子结点;Nl(n32)=3,因为结点n32有两个孩子结点n43和n53且Nl(n43)=1,Nl(n53)=2,每个结点的LPN值在图2(b)中每个结点的右边给出.第3行按照性质3计算每个结点的RLPN值.例如Np(n32)=Nr(n32)×Nl(n32)=6,每个结点的RLPN值在图2(b)中每个Page8结点的左边给出.第4行按照性质4计算每个位置的位置相关数.例如RP(2)=NP(n21)+NP(n22)+NP(n23)=7;同理RP(0)=1,RP(1)=3,RP(3)=8,RP(4)=8,RP(5)=8,RP(6)=8且RP(7)=4.第6~16行是迭代寻找一个包含叶子结点n74的出现B.SGSP首先找结点n74的近似优化双亲结点AOP,结点n53是结点n74的AOP,因为结点n74只有一个双亲结点n53.接下来寻找结点n53的AOP,从结点n53的双亲结点中选择位置相关数最小的结点作为其AOP,结点n53有两个双亲结点,分别是结点n32和n42且RP(3)=RP(4)=8.在这种情况下,需要比较位置3和4在结点集{n53,n74}的共同祖先集中的路径分支数,即pb(3,{n53,n74})和pb(4,{n53,n74}).图2(c)给出了结点集{n53,n74}的共同祖先集,由于pb(3,{n53,n74})=Nr(n32)+Nr(n31)=3且pb(4,{n53,n74})=Nr(n42)=2,这样结点n32被看作是结点n53的AOP,因为SGSP策略选择路径分支数较大的双亲结点作为当前结点的AOP且I(3,{n53,n74})<I(4,{n53,n74}).最后SGSP计算结点n32的AOP,结点n32有两个双亲结点n11和n21.结点n32的AOP是结点n11因为RP(1)=3<RP(2)=7.因此SGSP策略计算结果为〈1,3,5,7〉.依据SRMP策略,当叶子结点n74给定后,容易找到结点n53是结点n74的最右双亲结点;而结点n42是结点n53的最右双亲结点;而结点n31是结点n42的最右双亲结点.因此SRMP策略计算结果为〈3,4,5,7〉.SBO算法选择SGSP和SRMP策略的结果中相关出现数较小的出现作为算法的一个出现.易知RO(〈1,3,5,7〉)和RO(〈3,4,5,7〉)分别是7和8,所以SBO算法选择〈1,3,5,7〉作为算法的一个出现.在出现〈1,3,5,7〉不再被使用的情况下,新序列串为aXaXaXbX.SBO算法的第11行重新计算了在新序列串下各个结点的RPN.图2(d)中给出了在新序列串下的网树,此时SBO算法的结果为〈0,2,4,6〉.故SBO算法针对本问题找到的解为〈0,2,4,6〉和〈1,3,5,7〉.5实验结果与分析5.1实验结果本节采用真实生物数据用来对比SAIL算法[13]和SBO算法的性能.此外,本文还将SGSP和SRMP两种策略分别形成了两个可以单独计算MPMGOOC问题的算法,并分别命名为贪婪搜索双亲算法AGSP(AlgorithmofGreedySearchParent)和最右双亲算法ARMP(AlgorithmofRightMostParent).所有4种算法的源代码已全部公开①.实验运行的软硬件环境为:酷睿2双核T7100、主频1.80GHZ、内存1.0GB、WindowsXPSP2操作系统的笔记本.猪流感H1N1病毒在2009年大流行,其病毒的DNA序列可在美国国家生物计算信息中心的网上下载②.该病毒有很多候选序列,本文选择于2010年3月30日公布的一个结果(A/Managua/2093.01/2009(H1N1))中的全部8个片段③作为测试序列(见表1).序号片段名称S1Segment1CY0585632286S2Segment2CY0585622299S3Segment3CY0585612169S4Segment4CY0585561720S5Segment5CY0585591516S6Segment6CY0585581418S7Segment7CY058557982S8Segment8CY058560844Min等人[12]在其研究工作中给出了一些模式串,由于其中P5模式串不能在DNA序列中应用,所以本文选择其余的4个模式串(P1~P4)作为本文的部分测试模式串.此外本文又另外构造了5个新的模式串,表2给出了本文的全部9种模式串.序号P1a[0,3]t[0,3]a[0,3]t[0,3]a[0,3]t[0,3]P2g[1,5]t[0,6]a[2,7]g[3,9]t[2,5]a[4,9]P3g[1,9]t[1,9]a[1,9]g[1,9]t[1,9]a[1,9]P4g[1,5]t[0,6]a[2,7]g[3,9]t[2,5]a[4,9]P5a[0,10]a[0,10]t[0,10]c[0,10]g[0,10]g656P6a[0,5]t[0,7]c[0,9]g[0,11]gP7a[0,5]t[0,7]c[0,6]g[0,8]t[0,7]c[0,9]g749P8a[5,6]c[4,7]g[3,8]t[2,8]a[1,7]c[0,9]g2252P9c[0,5]t[0,5]g[0,5]a[0,5]a①②③Page9表3给出了这4种算法的运行时间复杂度.4种算法在S2这个最长序列上的全部9种模式下的运行时间对比表以及在P1模式下的全部8种序列上的运行时间对比表分别见表4和表5.算法名称SAIL[13]ARMP注:①文献[13]给出SAIL算法时间复杂度为O(n+klmW),k和l分别为pm-1在S中出现的频度和出现的最大跨度.由于k的数量级为O(n),l的数量级为O(W×m),因此SAIL算法时间复杂度可以描述为O(W2×n×m2).②尽管SRMP策略时间复杂度为O(W×m),但是在形成ARMP算法后,在每次求解一个出现前,需要执行依据新的S重新计算各个结点的RPN操作,所以ARMP算法时间复杂度为O(W×n2).表4S2序列上的全部9种模式下的运行时间算法名称SAIL474763473116323116ARMP47297609437735656344234562AGSP47438875563844735421265656SBO61468922594969797469282687表5P1模式下的全部8种序列上的运行时间算法名称SAIL3147313131161616ARMP6347637963161616AGSP7847639447161616SBO7861639463161616①注:当运行时间过短情况下,计算机不能准确报告运行时间,所以本文采用“16”表示运行时间小于或等于16ms.这4种算法在全部的72个实例上的测试结果见表6.为了直观地显示每个问题的最好解,表6中最好解都采用加粗方式显示.模式算法名称P1P2P3P4模式算法名称P5P6P7P8P95.2实验结果分析(1)在解较少的情况下,SAIL算法可以取得较好的性能且ARMP、AGSP和SBO算法的运行时间较短.由表6可以看出,P1模式在8个测试序列上解较少.在此情况下,SAIL算法都能够取得最好解;然而当解较多的情况下,SAIL算法很难取得最好解.尽管ARMP、AGSP和SBO等3种算法时间复杂度较高,但是在解较少的情况下,这3种算法实际运行时间较短;然而当解较多的情况下,这3种算法实际运行时间较长并与算法的时间复杂度相吻合.这是由于当解较少的情况下,问题相对较为简单,对应的网树结构也比较简单,这样SAIL算法就能够取得最好解并且基于网树的3种算法也能很快找到解.因此P1模式不具有普遍意义,在后面的讨论中,将忽略P1模式下的8个实例的结果.(2)SAIL算法不适合求解离线MPMGOOC问题.表3和表4可以看出,SAIL算法的时间复杂度最低且SAIL算法的实际求解速度最快,这充分说明SAIL算法适用于求解在线问题.但是在求解离线问题时,SAIL算法解的质量差.在64个实例中,SAIL算法仅有3次取得了最好解,说明SAIL算法在求解复杂的离线问题时较难获得最好解.此外,SAIL算法解的质量相对较差,例如在“P8-S2”实例上,SAIL算法的解为66,但是求解到的最好解为78.在64个实例中,SAIL算法的解与最好解之差大于或等于4的实例共有26个.这些都充分地说明了SAIL算法解的质量较差,所以SAIL算法不适Page10合求解离线MPMGOOC问题.(3)在运行时间增加不大的情况下,SBO算法的质量最好,说明了SBO算法可以较好地求解离线MPMGOOC问题.尽管SBO算法中包含SGSP和SRMP两种策略并择优使用其结果,但是从表4可以看出这样的时间开销并不大.而在解的质量方面,SBO算法较其它3种算法都有显著提高.具体分析如下:与SAIL算法相比,在64个实例中,有60个实例SBO算法的解结果好于SAIL算法且其中23个实例两种算法解之差大于或等于4;在“P3-S5”实例上,SBO算法与SAIL算法同时取得了最好解;在“P3-S7”、“P3-S8”和“P6-S4”实例上,SBO算法的解较SAIL算法的解都只差1.此外,在很多实例上SBO算法大幅度地提高了SAIL解的质量.例如在实例“P8-S2”上,采用SAIL算法的结果仅为66,而采用SBO算法的结果为77,提高幅度非常显著.这充分地说明了SBO算法显著地改善了SAIL算法的解的质量.与ARMP算法相比,有32个实例SBO算法的解好于ARMP算法且其中有9个实例两种算法解之差大于或等于3;在18个实例上SBO算法的解与ARMP算法同为最好解;在余下的14个实例中,仅在“P6-S4”实例上差距显著(SBO算法的解为143,而ARMP算法的解为147),在“P4-S2”实例上SBO算法较ARMP算法差2,而其余的12个实例SBO算法较ARMP算法都仅差1.这充分地说明了SBO算法解的质量好于ARMP算法.与AGSP算法相比,有41个实例SBO算法的解好于AGSP算法且其中有15个实例两种算法解之差大于或等于3;在21个实例上SBO算法的解与AGSP算法相同;在“P3-S1”和“P3-S8”两个实例SBO算法的解比AGSP算法差1.这充分地说明了SBO算法解的质量好于AGSP算法.(4)SBO算法之所以能够取得良好的解是因为SBO算法多次运用启发式策略,实现了每次选择出现相关数较小的出现这个启发式策略.但是本文注意到,应用这个启发式策略在求解MPMGOOC问题时,不一定都能得到最好解.实验结果显示,SBO算法在16个实例上未能取得最好解.因此即使存在第3种策略求解出现并择优使用这3种策略结果的算法,也不能保证其结果一定优于SBO算法.综上所述,与其它3种算法相比,SBO算法的解的质量最好且与基于网树的SRMP和SGSP两种算法相比,时间开销增加不大,充分说明了SBO算法适用于求解离线MPMGOOC问题.6结论由于网树是一个新的数据结构,其区别于树结构的概念在于:一个非根网树结点可以有多个双亲结点.因此网树有许多特有概念和性质,如最小根、最大根、树根路径数、叶子路径数、树根-叶子路径数、共同祖先集、最右双亲结点等概念.为了求解MPMGOOC问题,一个合理的启发式策略是每次选择一个出现相关数较小的出现B作为结果,而为了找到这个出现B,一个合理的启发式策略是选择新增数较小的双亲结点作为当前结点的双亲结点,但是由于计算新增数的时间复杂度较高,所以采用位置相关数最小的双亲结点作为当前结点的AOP.本文利用了网树的每个结点的RPN、LPN和RLPN等概念和性质对位置相关数进行了计算.在此基础上,本文又利用共同祖先集、最小根、最大根、最右双亲结点等概念设计出SGSP策略和SRMP策略用来计算出现.本文提出的SBO算法择优地使用这两种策略的结果.通过实际的生物医学数据测试表明,SBO算法的解的质量明显优于AGSP、ARMP和SAIL等算法,这是由于在SBO算法中多次运用了启发式策略.SBO算法的空间复杂度和时间复杂度分别是O(W×m×n)和O(W×n×(n+m2)),这里m、n和W分别是模式串P和序列串S的长度以及模式串P的最大间距.我们相信网树将在更多的领域得到应用,并引起更广泛的理论研究.
