Page1Piccolo密码代数故障分析研究赵新杰1),2)郭世泽2)王韬1)张帆3)刘会英1)黄静4)王平5)1)(军械工程学院信息工程系石家庄050003)2)(北方电子设备研究所北京100083)3)(康涅狄格大学计算机科学与工程系斯托斯康涅狄格州美国06269)4)(清华大学计算机科学与技术系北京100084)5)(航天恒星科技有限公司北京100086)摘要应用代数故障分析方法,对Piccolo密码抗故障攻击安全性进行了评估.首先利用代数方法建立Piccolo密码等效布尔方程组;然后通过故障攻击手段获取故障密文并将故障注入差分进行表示,给出了一种故障注入位置未知情况下的故障差分布尔方程组表示方法;最后使用CryptoMiniSAT解析器求解联立方程组恢复密钥.结果表明,代数故障分析相比传统差分故障分析具有以下优点:(1)在线故障注入较少,在Piccolo-80第23轮注入4bit故障,1次故障注入即可恢复80位密钥;(2)离线分析方法简单,无需结合算法和故障模型判断故障位置,执行繁琐的故障差分传播分析,自动化程度较高;(3)计算资源利用率高,可将故障攻击下的密钥恢复转化为代数方程求解问题,充分利用计算资源;(4)通用性较好,可扩展到宽度故障模型、深度故障模型、其它版本的Piccolo密码以及多种分组密码,有望成为评估分组密码抗故障攻击能力的通用方法.关键词代数故障分析;故障模型;CryptMinisat;Piccolo;轻量级分组密码1引言现实世界中,密码算法大都在特定的密码设备中实现.一般情况下,密码设备均能正确地执行各种密码运算,但在有外界干扰情况下(温度、电压、电磁脉冲等扰动)[1-2],密码设备可能会出现寄存器故障或运算错误,利用这些故障行为或错误信息来恢复密钥的方法即是故障攻击.由于现代密码设备大都基于电子技术进行实现,接口也相对比较简单,较易受到外界干扰,故障攻击已成为最有效的旁路攻击方法之一.1.1相关工作故障攻击由Boneh等人[3]于1996年率先提出,并成功攻破基于CRT方式实现的RSA签名算法.之后,Biham和Shamir[4]将该方法推广至DES,由于攻击时采用了差分分析思想,推广的方法被称为“差分故障分析”(DiffertialFaultAnalysis,DFA).此后密码学家又实现了针对ECC[5]等公钥密码,AES[6]、Camellia[7-9]、SMS4[10]、LED[11-15]等分组密码,RC4[16]、Trivium[17]等流密码的多种差分故障分析.然而差分故障分析也具有一定的缺点:(1)攻击者需要结合算法结构和操作对故障传播过程进行分析,并进行繁琐的手工密钥推导,通用性较差;(2)即使在相同故障模型下,针对同一密码算法分析中,受研究者对算法结构的认知能力和故障挖掘方法所限制,常会得到不同的实验结果[11-15],对故障的分析利用率未达到最大;(3)对于某些密码算法设计、宽度故障、深轮故障模型,故障差分的传播特征将更为复杂,差分故障分析的难度将大大增大.研究自动化、通用化的密钥分析方法一直是故障分析尚待解决的一个问题.代数分析[18]是近年来提出的一种密码分析方法,将密钥求解转化为代数方程组求解问题,利用解析器工具进行密钥自动化求解,可充分利用计算资源,为密码分析提供了一种新的自动化、通用化分析手段.将代数分析方法同故障分析结合起来,开展代数故障分析,有望弥补传统差分故障分析的不足.代数故障分析由Courtois等人[19]在2010年提出,对DES进行了攻击,结果表明通过穷举24位DES密钥,在DES加密第13轮注入1bit故障,对于1次穷举可在1min内恢复密钥;2011年,Mohamed等人[20]将代数故障分析扩展至流密码Trivium,用于提高攻击差分故障分析,结果表明仅需两次故障注入对420bit密钥流进行分析即可恢复Trivium密钥;2012年,Zhao等人[13]和Jovanovic等人[15]将代数故障分析扩展至LED分组密码,结果表明1次故障注入使用普通PC机分析即可在1min内恢复LED密钥.随着电子信息技术和普适计算的发展,RFID标签和无线传感器网络深入到人们生活的方方面面,如何在此类资源受限的环境下提供信息安全保障成为重点和难点问题.轻量级密码算法正是在这种趋势上发展起来的,典型算法包括:PRESENT[21]、MIBS[22]、GOST[23]、KLEIN[24]、LED[25]、Piccolo[26]等,这些算法大都可在3000个门电路内硬件实现,特别适用于轻量级密码设备加解密需要.由于其轻量级的设计和实现原则,轻量级密码设备的防护程度不高,导致其易遭受故障注入的威胁.此外,此类密码算法代数结构相对比较简单也导致其代数方程求解复杂度较低,这都为代数故障分析研究提供了故障注入和分析的有利条件.本文代数故障分析研究主要针对CHES2011会议上提出的轻量级分组密码Piccolo.Piccolo密码分组长度为64位,密钥长度为80位和128位,对应算法分别为Piccolo-80和Piccolo-128,迭代轮数分别为25轮和31轮.算法采用非平衡型Feistel结构,每轮使用2个F函数,基本运算单元为Nibble(4bit).2012年,Wang等人[27]应用Biclique分析方法,对全轮的Piccolo-80算法和Page328轮的Piccolo-128算法安全性进行了分析,攻击数据复杂度分别为248和224个选择密文,时间复杂度分别为278.95和2126.79次加密.在Piccolo故障攻击方面现有工作有两例,均基于差分故障分析方法实现.一是由Jeong[28]在2012年9月的Eprint2012/399报告上提出,通过在Piccolo倒数第2轮F函数的1个输入左寄存器注入1个字节故障,6次故障注入可将Piccolo-80密钥搜索空间降低到224,应用类似方法,8次故障注入可将Piccolo-128密钥搜索空间降低到240.二是赵光耀等人[29]在计算机学报2012年9月信息安全专辑上提出,通过在Piccolo倒数第2轮F函数的2个输入左寄存器分别注入1个Nibble故障,2次故障注入可将Piccolo-80密钥搜索空间降低到222.此外,上述结果还表明,Piccolo密码抗故障攻击至少要防护倒数两轮.如何进一步延伸故障注入轮数、降低故障注入次数、简化故障分析过程是本文Piccolo密码故障分析重点要解决的问题.1.2本文工作故障攻击进行了评估,主要创新点如下:论文应用代数故障分析方法,对Piccolo密码抗(1)提出了一种故障注入索引未知条件下的故障差分表示方法.在差分故障分析中,攻击者需根据密文差分手动分析故障在倒数几轮的传播路径,并判断故障注入索引,在此基础上进行繁琐的密钥分析.现有代数故障分析研究均假定故障注入位置是已知的,由于针对的分组密码算法密钥长度较短(DES和LED均为64bit),攻击所需的故障注入次数较少(DES和LED需要1次),可能的故障注入位置有限,攻击者可穷举执行多次代数故障攻击.对于某些故障攻击场景下,如深轮故障攻击或者较长密钥的分组密码故障攻击,故障注入次数需要多个.如果每次故障注入的位置均为未知,多次故障注入对应的故障位置组合数量较大,应用差分故障分析和现有代数故障分析的复杂度也较高.本文提出故障注入索引未知下的故障差分表示方法,较好地解决了该问题.即使在多次故障注入条件下,改进代数故障分析可将每次注入的故障差分使用代数方程组表示出来,然后执行1次代数求解即可恢复密钥,提高了故障分析的效率,降低了故障分析复杂度.(2)实现了多种故障模型下的Piccolo密码代数故障分析.应用提出的改进代数故障分析方法,我们实现了多种故障模型下的Piccolo优化故障攻击.结果表明:基于Nibble或字节故障模型,通过在倒数第3轮的1个F函数输入寄存器注入故障,1次故障注入即可恢复Piccolo-80密钥,通过在倒数第4轮的1个F函数输入寄存器注入故障,2次故障注入即可恢复Piccolo-80密钥;基于Nibble或字节故障模型,通过在倒数第2或3轮注入2次故障、倒数第5或6轮注入1次故障,3次故障注入即可恢复Piccolo-128密钥;这些结果不仅降低了故障注入次数,而且还延伸了Piccolo故障分析轮数.此外,本文提出的代数故障分析方法通用性较强,可将其成功扩展至DES、PRESENT、LED、GOST等分组密码,均实现最小故障次数下的故障分析.1.3结构组织本文第2节介绍Piccolo算法;第3节介绍差分故障分析原理、差分故障分析不足及代数故障分析原理;第4节介绍Piccolo代数故障分析方法;第5节给出Piccolo代数故障分析实验及结果;第6节对代数故障分析的特点和公开问题分析讨论;第7节为结束语.2Piccolo算法2.1符号定义P,K,C:加密明文、主密钥、密文.r:迭代轮数.ki:密钥K的第i个16bit.wki:第i个16bit白化密钥.rki:第i/2轮16bit轮密钥.a|b:连接操作.a(b):b表示a的比特数量.{a}b:用b为底表示a.2.2加密函数设计Piccolo密码设计[26]采用广义Feistel宏观结构,加密过程如图1(a)所示.每轮由两个F函数(F:{0,1}16→{0,1}16)、轮密钥加函数AK和轮置换函数RP(RP:{0,1}64→{0,1}64)组成.初始64bit明文输入可被划分两部分(每部分32bit),两部分输入的左16bit和前白化密钥进行异或(AddWhiteningKey,AWK操作),然后执行若干轮加密迭代(最后一轮没有使用RP轮置换函数),输出的64bit同样划分为长度为32bit的两部分,两部分的左16bit分别和后Page4图1Piccolo密码算法设计白化密钥进行异或,最终得到64bit密文输出.F函数由查找S盒-列混淆-查找S盒3个操作顺序组成,AK函数将F函数输出同16bit轮密钥进行异或(AddRoundKey,ARK操作),RP函数将输入的64bit划分为8个字节,然后执行图1(b)所示的基于字节的置换操作.下面对F函数的两个操作进行简单介绍:(1)Nibble代换:将输入的16bit分为4个Nibble,执行4次查找4进4出S盒操作.令x为S盒输入,S[x]为S盒输出,Piccolo密码S盒设计如表1所示.xS[x]xS[x]01234567(2)Nibble混淆:将4×4的列混淆矩阵犕乘以4个Nibble输入组成的4×1矩阵,得到16位输出.2.3密钥扩展设计为提高硬件执行效率,降低密钥扩展开销,Piccolo的密钥扩展设计相对较为简单.在密钥扩展中,引入了一系列的16bit常量组,Piccolo-80和Piccolo-128的密钥扩展中使用的第i个16bit常量分别用con80i和con128i来表示.(1)Piccolo-80密钥扩展设计将主密钥K按16bit划分为5部分,分别用k0,k1,k2,k3,k4来表示,然后根据式(1)生成64位白化密钥和25轮的轮密钥,其中r=25.wk0←kLfori←0to(r-1)do(rk2i,rk2i+1)←(con80(2)Piccolo-128密钥扩展设计将主密钥K按16bit划分为8部分,分别用k0,k1,k2,k3,k4,k5,k6,k7来表示,然后根据式(2)生成64位白化密钥和31轮的轮密钥,其中r=31.wk0←kLfori←0to(2r-1)doif(i+2)mod8=0then(k0,k1,k2,k3,k4,k5,k6,k7)←(k2,k1,k6,k7,k0,k3,k4,k5)rki←k(i+2)mod8con128i3故障分析3.1问题提出本质上来说,分组密码故障分析主要利用密码正确/错误密文同故障传播中涉及到的相关密钥之间的关系进行密钥破解.以针对加密过程的故障攻击为例,令T表示密码运行试图干扰的加密中间状态,f表示注入故障的中间状态和正确中间状态之Page5间的差分值;g()表示自密码注入故障后的加密运算函数,Kf表示自故障注入后经故障传播涉及到的相关密钥变量,h()表示根据密钥扩展得到的Kf和主密钥K之间的相关函数,C和C分别表示正确和错误密文.对于正确的加密样本来说,正确密文C=g(T,Kf);对于注入故障的加密样本来说,错误图2分组密码故障分析原理3.2差分故障分析现代分组密码大都使用S盒查表操作提高密码非线性度和软件执行效率,但恰恰是由于S盒的非线性特性,导致其面临严重的故障攻击威胁.假如在分组密码查表时,在最后一轮对未知查表输入值a导入随机字节故障f,一般来说,攻击者可得到密文差分f(如一个字节或Nibble),且满足通过一定分析可获取最后一轮S盒输入a,主要思路是通过故障分析降低f的搜索空间,然后将a的所有候选值、f候选值、f值代入式(3),满足等式的值作为a的有效候选值;由于a值常同扩展密钥紧密相关,结合密文可获取相关扩展密钥;最后根据需要进行多样本分析或者迭代分析直至获取主密钥.可以看出,差分故障的关键在于如何获取非线性部件S盒的故障输入和输出差分.对于大部分Feistel结构的分组密码差分故障分析来说,由于其半扩散特性,如果F函数只有1组查找S盒操作,F函数的输入和输出差分常可从密文差分中获取,然后代入式(3),得到查找S盒索引a及输出S[a],在此基础上进行密钥恢复[9].以Camellia最后一轮故障攻击为例,在Camellia加密最后一轮左寄存器Lr-1导入单字节故障f,故障传播如图3所示.易见,通过对密文差分进行分析可得到最后一轮查找S盒的输入差分f和输出差分f,故障位置也可直观得到.将a(a=L0个候选值、f、f值代入式(3),满足等式的值作为a的有效候选值.由于L0半部分C0密文C=g(T,Kf,f);结合Kf和主密钥K之间的相关函数Kf=h(K),3种等式联立,攻击者即可得到密钥的部分候选值集合,对密文输出的不同部分或者多个密文分析后可得到这些密钥集合的交集,正确的密钥肯定在交集中,进而实现密钥破解.图2给出了分组密码故障分析的原理示意图.次导入不同索引位置故障可恢复64位密钥krkw3,然后通过在其它轮导入故障,经分析得到足够的相关密钥恢复初始主密钥.然而,对于Piccolo分组密码来说,其Feistel结构中的两个F函数分别由查找S盒-列混淆-查找S盒操作组成,虽然最后一轮两个F函数的故障输入差分(f1和f3)和故障输出差分(f2和f4)均为已知,如图4所示,但由于轮密钥加操作和白化密钥加操作的影响,攻击者并不能应用其计算出每个F函数的第1组查找S盒的故障输出差分和第2组查找S盒的故障输入差分,如果想对其进行有效分析只能借助于超级S盒概念[30],将F函数的3个操作视为一个超级S盒,在此基础上进行密钥分析.Jeong[28]和赵光耀等人[29]的Piccolo密码攻击均为借鉴超级S盒思想实现.总之,应用传统的差分故障分析方法进行密钥分析变得较为复杂,且攻击复杂度将随着故障深度延伸和宽度扩展变得越来越大.Page6图4Piccolo密码最后一轮故障传播图3.3代数故障分析为克服传统差分故障分析不足,寻找通用、自动化的密钥恢复手段,将代数分析同故障分析结合开展代数故障分析是一个可行的思路.如图5所示,代数故障分析一般可分为3个阶段:密码算法方程组构建、故障注入及利用和代数方程组求解.其中,P、Xi、C分别表示明文、中间状态以及密文,K、rk分别表示主密钥和轮密钥.f和g分别表示加密操作和密钥扩展.Xi和C分别表示故障中间状态及错误密文,ΔXi和ΔC则表示注入故障差分和密文差分.(1)密码算法代数方程组构建将密码算法表示为关于明文P,中间变量X,密文C,密钥K的代数方程组,在密码代数方程组构造中,最为关键的部分是如何构造S盒、模加、模减等非线性部件以及矩阵乘法等复杂线性部件的代数方程组.需要说明的是,由于故障攻击主要利用正确密文和错误密文进行密钥恢复,为加快解析器方程组求解速度,在构建加密过程和密钥扩展方程组时,经验表明从密文开始逆向构建解密方程组效果比较好.(2)故障注入及利用在构建密码算法等效代数方程组之后,需要进行故障注入和利用.故障注入的方法有很多,如光学辐射诱导、电压故障诱导、临界温度诱导、电磁辐射诱导等.由于故障注入不是本文研究重点,更多相关内容可参考文献[1-2].故障利用的主要思想是将故障注入差分ΔX和密文输出差分ΔC使用代数方程组表示,同密码算法代数方程组联立,降低代数方程组的求解复杂度,加快方程组求解速度.(3)代数方程组求解将故障信息代数方程组同密码算法方程组联立后,密钥恢复攻击等价于方程组求解问题.典型的代数方程组求解主要包括基于可满足性问题[31](使用zChaff、Minisat、CryptoMinisat等解析器)、基于最优化问题(使用CPLEX、SCIP解析器)、基于线性化(直接线性化XL、扩展线性化XSL)、基于Grbner基[32]等方法.4Piccolo代数故障分析4.1故障模型设定Piccolo算法可采用以Nibble(4bit)、字节(8bit)甚至字(32bit)为基本运算单位进行实现,本节故障模型主要面向Nibble的随机故障模型,但其分析方法可被扩展到其它故障模型.此外,如无特别说明,下文中Piccolo均指Piccolo-80算法.本节故障模型如图6所示,其基本假设如下:攻击者每次可以诱发Piccolo加密过程中某一轮F函数的一个运算单元发生错误,但无需知道具Page7图6故障模型体错误位置和错误值.对于Piccolo攻击,本节假定攻击者可在Piccolo加密倒数第3轮,即第23轮的F函数输入产生一个Nibble的故障,具体的故障注入位置有多种,如第23轮F函数输入、第22轮F函数Nibble混淆、第22轮F函数第2组Nibble代换、第22轮轮密钥加等位置,具体可见图6中任意的一个箭头所标示位置.需要说明的是,我们统一将能使第23轮F函数输入产生1个Nibble的故障模型都视为第23轮故障模型.此外,对同一个明文而言,攻击者可获得同一个密钥作用下的正确密文和错误密文.4.2密码代数方程组构建由于故障攻击从密文开始进行分析,因此建立Piccolo密码解密方程组可以加速代数故障攻击求解过程,该思想在文献[13]也有所说明.假定Ai=Ai,1(16)|Ai,2(16)|Ai,3(16)|Ai,4(16)表示第i轮64bit输出,Bi=Bi,1(16)|Bi,2(16)|Bi,3(16)|Bi,4(16)表示第i轮RP函数64bit输出,C=C1(16)|C2(16)|C3(16)|C4(16)表示64bit密文,Ai,j(16)、Bi,j(16)、Aj(16)宽度为16bit(1i25,1j4).由于Piccolo密钥扩展较为简单,下面仅给出Piccolo解密方程组构建方法,如式(4)所示.Page8C=C1|C2|C3|C4烄A25,1=C1wk2,A25,2=F(A25,1)C2rk48A25,3=C3wk3,A25,4=F(A25,3)C4rk49fori=24to2do{Ai+1=RP(Bi)Ai,1=Bi,1,Ai,2=F(Ai,1)Bi,2rk2i-2烅Ai,3=Bi,3,Ai,4=F(Ai,3)Bi,4rk2i-1}A2=RP(B1)A1,1=B1,1wk0,A1,2=F(A1,1)B1,2rk0A1,3=B1,3wk1,A1,4=F(A1,3)B1,4rk1烆P=A1,1|A1,2|A1,3|A1,根据式(4)可以看出,如何构建F函数中的Nibble代换和Nibble混淆是重点和难点问题,下面分别给出其具体构建方法.(1)Nibble代换代数方程组构建令X=X1|X2|X3|X4和Y=Y1|Y2|Y3|Y4分别表示Nibble代换的16bit输入和输出,则Y可表示为Y1=S(X1),Y2=S(X2),Y3=S(X3),Y4=S(X4)式(5)中,S()表示一次查找S盒操作.假设S盒输入和输出分别用x1|x2|x3|x4和y1|y2|y3|y4来表示,我们利用基于布尔函数理论,参考文献[33]中方法,将Piccolo的S盒用4个等式表示出来:烄烅x3x4+x1x2x3=0y4+x1+x2+x3+x1x3+x1x4+x2x4+x3x4+x1x2x3+x2x3x4烆(2)Nibble混淆代数方程组构建令X=X1|X2|X3|X4和Y=Y1|Y2|Y3|Y4分别表示Nibble混淆的16bit输入和输出,则Y可表示为烄烅烆其中,“·”表示GF(24)域上的乘法运算.在Nibble混淆中,输出矩阵由混淆矩阵犕和输入状态矩阵相乘得到,对于某次乘法操作来说,根据犕中的3个不同元素,将4bit输入x1|x2|x3|x4转化为对应4bit输出y1|y2|y3|y4,不同矩阵元素对应输出如表2所示.元素y1y21x1x22x2x3x1+x4x13x1+x2x2+x3x1+x3+x4x1+x4将式(5)~(7)代入到式(4),每个解密轮需引入544个变量和928个ANF等式.另外,每轮扩展密钥需引入32个变量和32个ANF等式,白化密钥需引入64个变量和64个ANF等式.4.3故障差分利用与表示下面给出故障注入索引未知条件下的故障差分表示方法.以Piccolo密码代数故障分析中故障差分表示为例,令第23轮的正确输入X用x1|x2|…|x16表示,X注入一个Nibble的随机故障后的值用Y=y1|y2|…|y16来表示,Z表示故障差分,则Z可表示为Z=z1|z2|…|z16,zi=xiyi,1i16(8)将Z划分为4个Nibble,假设可表示为Z1|Z2|Z3|Z4,Zi=z4×i-3|z4×i-2|z4×i-1|z4×i(1i4),再引入4个比特的变量ui来表示Zi是否为故障注入Nibble,则ui可表示为ui=(1z4×i-3)|(1z4×i-2)|(1z4×i-1)|(1z4×i),如果ui=0,则表示Zi为故障注入Nibble,否则不是故障注入位置.因为仅有1个Nibble出现故障,则u1|u2|u3|u4中只有一个为0,则可表示为(1-u1)∨(1-u2)∨(1-u3)∨(1-u4)=1,根据上面方法,基于Nibble的故障差分可用式(8)~(10)来进行表示,代数方程十分简单.每次故障注入仅需引入24个变量和47个ANF等式.需要说明的是,上述公式经简单扩展后可适用于基于其它宽度的故障差分表示,如字节故障差分、字故障差分等.4.4代数方程组求解典型的代数方程组求解工具有很多,本文主要选取基于可满足性问题的CryptoMinisat解析器.在代数方程组构建过程中,布尔降幂和布尔切割是两大难题.CryptoMinisat解析器较好的解决了布尔切割问题,对于x1+x2+…+xn这样的一个异或操作,如果变量2到n+1分别表示x1到xn,则该异或操作可用“x123…n+10”一条语句表示.攻击中首先将Piccolo加密和旁路泄露布尔方程组转化为符合CryptoMinisat输入格式的文本文件,然后以命令行方式调用解析器进行求解.Page95攻击实验5.1实验配置本文主要对故障分析进行研究,故障注入不是本文的研究重点,故文中故障均为计算机仿真模拟实现,使用C++编程语言(VisualC++6.0环境)通过修改Piccolo加密过程仿真故障注入.在方程组求解过程中,使用CryptoMinisat解析器进行密钥求解,解析器版本为2.9.4,运行解析器的PC机配置为Intel(R)Core(TM)I7-2640M、2.80GHz、4GB内存、WindowsXP64位操作系统.5.2Nibble故障模型下Piccolo-80攻击实例的一个实例:下面给出Nibble故障模型下的代数故障分析(1)Piccolo代数方程组构建首先产生随机明文P=0X3CB19A75B8B476DC,密钥K=0XCE076DFB5300F7EA6BF1,正确密文C=0XBC81C26238001C7C.根据4.2节方法建立对P用K进行Piccolo正确加密的完整代数方程组,全轮共引入17129个变量和28016个ANF等式,每个脚本553K大小.(2)故障注入及故障差分表示通过计算机软件仿真Piccolo加密倒数第3轮输入注入一个Nibble的故障,得到错误密文C=0XC6F545612C08C9D4,将故障样本的倒数3轮加密用代数方程表示.在此基础上,应用4.3节方法将注入的故障差分进行表示.(3)基于可满足性的代数方程求解使用CryptoMinisat进行密钥求解,结果如表3所示.编号2至81依次表示80-bit初始密钥比特,编号为正表示对应密钥位为1,否则为0.根据表3,编号密钥21221-42062131231-430-630-40-240-440641-50251-450-65061261-460-66071271-47067181281-480681-90291-490-690-100301501701-110-310511-710-120321521721-130331531731-140-340-540741151351551751编号密钥161-360561761171371571771-180-380581-780191-390591-790201401601-800-210411-610811求解密钥二进制表示为11001110000001110110110111111011010100110000000011110111111010100110101111110001,转化为16进制即CE076DFB5300F7EA6BF1,同真实主密钥一致,攻击成功.攻击中,随机产生10组不同的密钥和明文,执行了10次实验.1次故障注入条件下,使用Crypto-Minisat解析器的密钥求解时间如表4所示.最短求解时间为0.5h,最长时间为10h,平均求解时间约为5h.相比Jeong[28]攻击需要的6次和赵光耀等人[29]攻击所需要的2次故障注入,本文只需1次故障注入.表4基于CryptoMinisat解析器的密钥求解时间序号时间/h序号样本14.7样本20.5样本36.4样本42.3样本510.0样本105.6此外,本文还在注入两次Nibble故障条件下进行了两类攻击实验,分别执行100次攻击实验.第1类是将故障注入到加密第24轮输入,两次故障注入可在20min左右恢复80位密钥;第2类是将故障注入到加密第23轮输入,80位密钥求解可在700s内完成,平均时间为200s,密钥求解时间分布如图7所示.Page105.3不同故障模型下Piccolo-80攻击实验中,考虑两种故障模型,(1)8bit和16bit不同宽度的故障模型,(2)第22轮F函数输入产生一个Nibble的故障模型(故障注入位置可在第22轮F函数输入,第21轮F函数Nibble混淆、第2组Nibble代换、轮密钥加等位置),对Piccolo-80算法分别执行了10次代数故障攻击实验,攻击实验结果如表5所示.第23轮8bit故障模型1第23轮16bit故障模型1第22轮4bit故障模型2第22轮8bit故障模型2可见基于第23轮宽度故障模型,攻击仅需1次故障注入即可恢复密钥;基于第22轮深度故障模型,攻击仅需2次故障注入即可恢复密钥.5.4Piccolo-128攻击为验证攻击对其它密钥长度的Piccolo算法适用性,本文将攻击扩展到Piccolo-128算法,基于不同故障位置,执行了多种故障攻击实验(每种分别执行10次攻击实验).同时,由于Piccolo-128的密钥长度更长,同Piccolo-80代数故障攻击相比,Piccolo-128攻击所需故障次数要稍微多些.根据Piccolo-128算法设计,恢复主密钥需要至少恢复最后4轮扩展密钥,因此需要在倒数第2或3轮和5或6轮注入多次故障实现.本文Piccolo-128代数故障攻击模型、故障注入次数和平均密钥求解时间如表6所示.第29轮(2个)+第29轮(2个)+第30轮(2个)+第26轮Nibble故障(1个)3第27轮Nibble故障(1个)3第27轮Nibble故障(1个)3第26轮Byte故障(1个)3第27轮Byte故障(1个)3第27轮Byte故障(1个)3第29轮(2个)+第29轮(2个)+第30轮(2个)+根据表6,代数故障攻击成功所需的故障注入位置比较灵活,在倒数第2或者第3轮注入2次故障、倒数第5或者6轮注入1次故障,共3次故障即可快速恢复128位完整密钥.5.5其它分组密码攻击为验证攻击方法对不同分组密码的适用性,我们还将攻击扩展到AES、DES、PRESENT、LED、MIBS、GOST等密码算法,执行多种代数故障分析实验.攻击者仅需建立密码算法和故障模型对应的代数方程即可,无需对故障注入位置(已知故障注入轮的某个操作,但轮中具体操作的位置未知)、故障传播过程进行繁琐的手工分析,可最大程度利用计算资源,攻击所需故障注入次数和平均密钥求解时间如表7所示.表7不同轻量级分组密码代数故障攻击结果密码算法AES倒数第3轮字节故障DES倒数第5轮单比特、PRESENT倒数第3轮Nibble故障230sMIBS倒数第3轮Nibble故障110minLED[13]倒数第3轮Nibble故障13minGOST倒数第3,5,7,9轮Nibble故障82min需要说明的是,表7中这些分组密码代数故障分析所需故障注入次数均为目前最小值.如在DES密码攻击中,如果能够在第12轮注入单比特、单Nibble或单字节故障,1次故障注入平均即可在2min内恢复密钥,相比Courtois等人[19]应用代数故障分析需在已知24bit密钥前提下实施、CHES2009上Rivain[34]应用差分故障分析需要的7~11次故障注入的结果要好.此外,我们还可以看出代数故障分析通用性良好,分析过程比较简单,将传统差分故障分析中手工分析的复杂性转化为解析器求解代数方程中自动分析的计算复杂性,对于代数结构简单的轻量级分组密码算法和合适的故障模型,密钥求解时间较短,如DES、PRESENT、MIBS、LED、GOST;而对于采用了大S盒、代数结构较为复杂的分组密码算法,密钥求解时间较长,如AES.相信未来随着代数方程求解算法和解析器的改进,针对复杂代数结构分组密码算法下的代数故障攻击效果将会逐渐接近甚至超越差分故障分析.6代数故障分析讨论6.1特点分析本文应用代数故障分析方法对Piccolo进行改进故障分析,并对DES、PRESENT、MIBS、LED、GOST等轻量级分组密码开展了大量的扩展分析实Page11(2)离线分析方法简单.在故障分析过程中,攻击者只需建立密码算法、故障注入差分的方程应用解析器进行密钥求解即可,无需结合算法和故障模型对故障的差分传播特征逐轮进行繁琐的差分故障分析,无需对故障注入位置进行手工推断,自动化程度较高.(3)计算资源利用率高.可将故障攻击下的密钥恢复转化为代数方程组求解问题,将密码分析质的困难性转化为量的复杂性,是一种脑力劳动的机械化.分析适用于计算机计算,从而可以充分利用计算机优势,实现金钱到能力的转化.验.结果表明,轻量级分组密码代数故障分析具有下列特性:(1)在线故障注入较少.以Piccolo-80故障分析为例,在其加密第23轮注入一个宽度为4bit的故障,故障数值和位置均为未知,1次故障注入平均经5h离线分析、2次故障注入平均经3min离线分析即可恢复80位完整密钥,故障注入次数最少.(4)扩展性通用性良好.一是适用故障模型扩展性好.针对Piccolo-80密码,分析可被直接扩展到8bit、16bit等宽度故障模型以及第22轮深度故障模型;二是适用密码算法通用性好,分析可被扩展至Piccolo-128密码,仅需3次故障注入分析即可恢复128位密钥,故障注入轮位置可有多种选择;此外,分析还可适用于DES、PRESENT、LED、MIBS、GOST等分组密码算法,均能在较低故障注入次数下实现密钥恢复.鉴于代数故障分析的以上优点,我们认为其未来有望成为密码算法抗故障攻击安全性评估的一般性方法.6.2公开问题方面:代数故障分析未来研究工作主要有以下3个(1)代数故障分析求解速度优化在代数方程组求解过程中,密码算法和故障信息利用不同的方法,使得建立的代数方程组的变量个数、ANF等式数量都有很大差别,对应的密钥求解速度也有一定的差异,未来如何找到影响攻击中代数求解速度的因素,对于优化代数故障分析、扩展到复杂的密码算法来说十分重要.(2)代数故障分析的复杂度评估代数故障分析可在宽度故障、深度故障模型下成功实施,此时由于故障传播特征变得尤为复杂,使得攻击者很难应用传统的数学分析方法进行量化评估,因此亟需研究新的、通用性的评估方法,以实现针对不同故障模型、不同密码算法的代数故障分析复杂度评估.(3)抗代数故障分析分组密码算法设计本文大量的扩展实验表明,现有轻量级分组密码抗代数故障分析能力仍然较差.未来如何设计抗代数故障分析能力较好的轻量级分组密码,尤其是其中非线性S盒部件的设计,是一个尚待研究的问题.7结束语本文提出一种改进的代数故障分析方法,解决了故障注入索引位置未知的故障差分表示问题,应用改进代数故障分析方法对Piccolo密码抗故障攻击安全性进行分析,并在不同故障模型、不同Piccolo版本、不同分组密码开展了代数故障攻击实验.结果表明:同传统差分故障分析相比,轻型分组密码代数故障分析具有在线故障注入少、离线分析简单、扩展性通用性好等优点,可将密钥恢复转化为代数方程求解问题,最大程度利用计算资源.本文研究对改进轻型分组密码设计、加强实现防护、提高应用安全性具有一定借鉴意义.致谢感谢评审专家们的辛勤工作,感谢国防科学技术大学李瑞林在代数故障攻击中的精彩讨论和宝贵建议!
