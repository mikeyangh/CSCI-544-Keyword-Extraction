Page1EasiSNP:一种基于时空属性的传感器网络编程方法邱杰凡1),2)李栋1)石海龙1),2)崔莉1)1)(中国科学院计算技术研究所北京100190)2)(中国科学院大学北京100049)摘要由于资源受限的传感器节点易受到外界环境因素的干扰,造成传感器网络具有较强的动态性;而移动节点的引入,会加剧网络的动态性.为了消除网络动态性的影响,需要在每个节点上设计复杂的冗余机制,增加了开发难度.为此,作者提出了一种基于时空属性的编程方法———EasiSNP.通过编写EasiSNP顶层应用程序,可以直接对接口进行编程,由计算机根据接口绑定的时空属性生成任务块,并通过任务块迁移机制,由网络动态选择合适的节点执行任务块.此外,作者设计了相应的EasiSNP程序解释系统和运行时系统,前者实现了EasiSNP顶层应用程序的正确解释以及任务块的生成,后者保证了任务块能够被顺利迁移和执行.实验表明基于时空属性的编程方法EasiSNP在提高网络健壮性的同时,能够以较少的开销构建复杂的应用.关键词传感器网络;编程方法;时空属性;任务块迁移机制1引言当前无线传感器网络主要是由低功耗节点构成.节点在通信资源和能耗方面受到严格的限制,容易受到外部环境因素的干扰,造成传感器网络本身具有较强的动态性.特别是在一些应用场景中,需要引入移动节点协助静态节点完成感知任务.移动节点在空间位置上的不断变化,很难保证其通信的可靠性,因而进一步加剧了传感器网络的动态性.针对这种网络动态性,编程者需要设计相应的冗余机制,确保节点失效或者节点位置改变时,不会对传感器网络的正常工作造成影响[1].然而冗余机制的引入会使针对传感器网络的应用程序开发变得异常复杂,为了提高网络的健壮性,编程者不得不考虑各种突发情况并为每个节点编写专门的代码,势必减少对整体编程逻辑的思考[2].进而,在一个由“人-机-物”组成的物联网环境中,传感器网络将不再仅仅作为物联网中面向“物”的感知前端,局限于感知周围环境信息等简单任务,而是可以根据“人”的动态需求,执行相应的任务[3].需求的动态性表现为需求的发起在时间和空间上具有不确定性以及需求的内容具有不确定性.因此需要感知层网络具备和“人”直接进行交互的能力,甚至在某些情况下将“人”的行为融入感知层网络的任务执行[4-5].以我们在太湖上部署的蓝藻监测打捞感-执系统(Cyber-PhysicalSystem,CPS)为例[6],传感器节点将采集到的感知数据发送给云端进行处理后,再由云端向执行单元指派打捞任务.形成一个由传感器网络感知到云端处理,再到执行单元执行的闭环系统,如图1所示.然而由于节点间通信受到天气、湿度等外界环境因素的影响,感知节点可能暂时性的脱离网络,导致感知数据的延时甚至丢失.另一方面,由于太湖的特殊性,执行单元只能依据云端早先提供的策略进行打捞,即使进入传感器网络的感知区域之后,也无法通过与传感器网络实时交互了解当前蓝藻的爆发情况.针对这些问题,我们提出了一种基于时空属性的传感器网络编程方法———EasiSNP.它继承了NesC语言中接口(interface)的概念[7],可以通过编写顶层应用程序(topapplication)直接描述节点上不同接口的相互作用关系,而不再针对具体某个节点进行编程,以较低的编程开销,描述复杂的节点间图1太湖蓝藻监测打捞感-执系统(①传感器节点感知环境信息,通过多跳方式向汇聚节点传输感知数据;②汇聚节点通过3G网络将感知数据发往云端;③云端处理数据并制定相应打捞策略;④告知执行单元打捞策略;⑤执行单元依据打捞策略前往指定域作业)协同.同时,该方法允许编程者定义接口和节点的时空属性,通过一套轻量级的任务块迁移(taskblockmigration)机制,由网络根据编程者定义的时空属性动态地选择能够执行任务的节点.为了实现基于时空属性的编程,我们还设计了EasiSNP的程序解释系统和运行时系统.程序解释系统负责将EasiSNP顶层应用程序解释为具有时空属性的NesC程序,并根据满足时空属性的节点进一步生成对应的任务块(taskblock).运行时系统负责将任务块迁移并加载执行,它包含了节点运行时系统和后台运行时系统.前者主要维护本地节点的信息以及任务块的加载,后者主要负责维护当前全网节点的信息并提供查询功能.生成任务块时,程序解释系统可以通过后台运行时系统查询节点的相关信息.最后,我们针对第一代蓝藻监测打捞感-执系统的不足,编写了针对蓝藻打捞的EasiSNP顶层应用程序.新的顶层应用程序实现了根据打捞执行单元的空间位置动态对周围蓝藻信息的实时访问.并且通过基于时空属性的编程方法将具有移动特性的打捞执行单元抽象为移动节点(Mobile),协助失效节点完成阻塞数据的传输.仿真实验表明,新的顶层应用可以有效降低由于节点失效导致的数据延时.本文的贡献主要集中在以下3个方面:(1)为了降低针对传感器网络编程的复杂度,提出了一种基于时空属性的接口编程方法,设计了时空属性的定义方法以及绑定操作,并且通过程序Page3解释系统实现顶层应用程序到任务块的转化.(2)为了消除传感器网络动态性影响,提出一种轻量级的任务块迁移机制,以替换的思想动态调整任务块的执行节点,并通过运行时系统实现任务块的动态加载和执行.(3)以当前的蓝藻监测打捞感-执系统作为应用背景,编写EasiSNP顶层应用程序.并且通过仿真实验验证了顶层应用程序在降低数据延时方面的有效性.本文第2节简要地介绍相关研究背景;第3节简述EasiSNP组成以及执行流程;第4节将给出EasiSNP的具体实现;第5节针对具体应用场景验证EasiSNP的有效性,并对实验结果进行分析;第6节介绍相关工作;最后在第7节给出结论和未来的工作.2研究背景EasiSNP继承了NesC语言中接口(interface)的概念,并且将传感器网络操作系统TinyOS作为实现平台.NesC[7]是一种基于组件的编程语言,它体现了一种面向事件驱动的编程思想.NesC组件的行为由接口进行定义.接口可以分为命令接口(commandinterface)和事件接口(eventinterface).命令接口是由组件提供给编程者的功能实现;事件接口是编程者提供组件的执行实现.命令接口的实现通常由底层TinyOS系统提供.上层应用通过命令接口调用实现对底层系统函数的向下调用.我们称这些底层系统函数为命令函数(commandfunction).事件接口的实现通常由上层应用提供.底层TinyOS系统通过事件接口调用实现对应用层函数的向上触发.我们称这些应用层函数为事件函数(eventfunction).NesC程序(.nc文件)的编译可分为两个阶段.(1)NesC编译器根据输入的节点类型将NesC程序翻译为标准C程序(App.c).App.c包含了一个被裁剪过的TinyOS操作系统以及编程者自定义的应用程序.在App.c中,命令函数和事件函数都被转化为标准C函数.(2)根据节点处理器的类型选择合适的交叉编译器(如msp430-gcc),生成处理器可以直接运行的二进制可执行文件.在一个动态网络中,编程者无法预知当前符合时空属性的节点,因此需要节点提供相应的时空信息,以进一步确定编译参数.EasiSNP默认采用DV-Hop[8]和FTSP[9]作为获取绝对空间位置和全局时间的手段.DV-Hop是一种基于节点连通度(connectivitydegree)的非测距节点自定位算法.通过测定当前节点与多个位置已知节点的最少跳数(smallesthops)信息来计算当前节点所处的位置.这种定位算法对节点的资源要求不高,不需要添加额外的定位设备,且定位精度与节点密度密切相关.因此在低密度感知节点的应用场景中,编程者也可以通过描述相对空间位置和信号覆盖范围来定义空间属性,不强制所有节点具备自定位能力.FTSP是一种全局时间同步协议,它能够以较低的通信开销建立整个网络的全局时间.每个被同步的节点都会维护一张来自于已经被同步节点的列表.通过线性回归的方法推理节点局部时间与全局时间的关系,并做出调整.3EasiSNP概述图2给出了EasiSNP的系统结构框架.它由程序解释系统、后台运行时系统和节点运行时系统3部分组成.程序解释系统在计算机端运行,主要负责将顶层应用程序解释为NesC程序,并调用NesC编译器生成节点可执行的任务块.后台运行时系统在计算机端运行,它主要负责维护全网络的节点状态信息,同时为程序解释系统提供查询服务.节点运行时系统运行在节点端,主要负责维护本地节点状态信息以及任务块的迁移和加载.在向传感器网络部署顶层应用程序之前,网络中的节点需要向后台运行时系统进行注册.后台运行时系统需要维护全局节点信息表(详见表1)用于保存注册节点的信息.图3给出了部署一个顶层应用程序的执行流程.首先,程序解释系统将顶层应用程序翻译为多个独立的NesC程序.每个NesC程序都具有独立的时空属性.程序解释系统向后台运行时系统发出查询请求,后台运行时系统需要对全局节点信息表进行检索,搜索能够满足NesC程序时空属性的节点,并返回节点类型信息.Page4图3EasiSNP执行流程节点号节点类型空间位置信息邻居节点信息开放接口列表事件接口状态表已保存任务块程序解释系统根据返回的节点类型信息,选择合适的编译参数和交叉编译器,对NesC程序进行编译,生成节点可执行的任务块.NesC程序的空间属性也作为任务块的空间属性被添加到相应的任务块管理列表(详见表2)中.程序解释系统需要修改全局节点信息表中对应节点的信息表项.后台运行时系统通过任务块迁移机制,将新任务块迁移到对应的节点上.任务块编号任务块保存地址接口调用列表空间属性当前绑定节点ID备用绑定节点ID序列在节点端,任务块被下载到指定位置后,节点运行时系统会判断主内存中预设的任务块存储空间是否够用.如果任务块的存储空间即将被耗尽,则需要节点运行时系统将部分失效任务块从节点主内存中迁移到节点的外部扩展存储器中.然后,节点运行时系统修改节点上相关的函数管理列表,将新的任务块与底层TinyOS系统进行链接.最后,重启节点,开始执行新的任务块.4EasiSNP的实现本节将介绍EasiSNP的具体实现.4.1节和4.2节将重点介绍在EasiSNP顶层应用程序中如何定义时空属性以及如何对接口编程.4.3节以及4.4节介绍顶层应用程序分解以及任务块生成.4.5节介绍如何加载任务块到节点上.4.6节介绍任务块迁移机制,并对任务块迁移机制的适用情况进行说明.4.1时间/空间属性的定义任务块的空间属性可以通过绝对空间位置、相对空间位置以及通信覆盖范围3种方式进行定义.绝对空间位置需要指定一个具体空间坐标,后台运行时系统将搜索位于这个坐标附近的节点,其定义方式如式(1)所示:[x,y]表示一个具体的二维平面坐标(当然可以推广到三维空间坐标[x,y,z]).Dist是容忍距离,当节点与设定坐标点[x,y]的距离小于Dist时,可以认为节点满足所定义的空间属性.如果Dist设置为0,则认为只有距离坐标点最近的节点满足所定义的空间属性.设定容忍距离可以形成一个搜索圆面,如果在这个范围内存在合适的节点,则后台运行时系统会记录对应的节点号;反之,如果没有满足定义的节点,返回编程失败的信息.相对空间位置是在相对于某个已知节点的空间范围内进行空间位置的定义,其定义方式如式(2)所示:ReltLoc(Node_ID,Direction/Angle,Dist)(2)Node_ID是已知节点A的ID号,并且假设节点A的空间坐标也是已知的.Direction/Angle分别表示方向和角度.可选的方向(direction)包括:[East/West/North/South/Left/Right].编程者也可以设定一个具体的角度(Angle)范围,例如:[45,75].通过设定搜索的方向/角度以及容忍距离,可以形成一个搜索扇面.位于这个扇面内的节点是满足相对空间属性定义的节点;如果没有节点位于这个搜索扇面中,则返回编程失败的信息.编程者也可以通过若干个节点的通信覆盖范围来刻画一个模糊的覆盖空间范围,其定义方式如式(3)所示:[Node1,Node2,…,Noden]表示若干节点的ID的集合.通过检索这个集合内节点一跳(hop)范围内的节点,可以得到若干个被集合内节点共同覆盖的节点.这些被覆盖到的节点位于一个不规则的几何图形内.任务块的时间属性可以通过绝对时间和相对时间进行定义.绝对时间一般需要使用全局时间同步协议(如FTSP)获得,其定义方式如式(4)所示:AbsTime(StartTime,TimeOut,Shot/Peri,Interval)StartTime表示任务开始执行的绝对时间.TimeOutPage5是容忍时长,如果任务开始时间之后没有被立即执行,那么可以等待的容忍时长为TimeOut;如果在这个时间段内任务还是没有被执行,则认为任务执行失败.在对时间不敏感的应用场景中,编程者可以通过设定一个较大的TimeOut值,尽可能让任务被执行.Shot和Peri用于区分单次触发模式和周期触发模式.单次触发模式表示被触发的任务在执行完毕后,将不再执行,直到下一次被触发.周期触发表示任务被触发后,将由运行时系统每间隔一段时间触发任务,除非显式地取消触发,否则周期性触发将一直保持下去.Interval是周期触发的时间间隔,如果选择单次触发(Shot),则该参数为Null.相对时间是以事件的发生作为开始标志,其定义方式如式(5)所示:ReltTime(Event,TimeOut,Shot/Peri,Interva)Event是触发任务的具体事件.由于事件的发生具有不确定性,因此任务的触发具有一定的不确定性.由于TinyOS采用了事件驱动(event-driven)的编程模式,事件接口调用可以用于表示某个事件的发生.因此如果被绑定的事件位于节点本地,可以直接利用TinyOS提供的事件接口调用进行触发;否则,事件的发生位于其它节点上,需要通过节点运行时系统进行触发.我们将在4.3节详细讨论这个问题.4.2接口编程实现EasiSNP继承了NesC语言中接口的概念.在编写顶层应用程序时,可以在不指定具体节点的情况下,直接对接口进行编程.程序解释系统将自动寻找能够提供接口的节点.顶层应用程序主要包含以下3种要素:(1)接口提供者(InterfaceProvider).接口提供者是一种特殊的变量,它声明了需要提供的接口调用.每个接口提供者需要和一个能够提供接口的具体节点进行绑定.对节点的绑定将由后台运行时系统和程序解释系统协同完成,对编程者不可见.(2)接口调用(InterfaceCall).接口调用分为命L7TimeBind(Leds[i].leds.TurnOn(),ReltTime(Leds[i-1].leds.On,Shot,Null));L8TimeBind(Leds[i-1].leds.TurnOff(),ReltTime(Leds[i].leds.On,Shot,Null));}图4跑马灯的顶层应用程序令接口调用和事件接口调用.其中TinyOS实现的命令函数由上层应用通过命令接口调用进行触发;编程者定义的事件函数由底层TinyOS通过事件接口调用进行触发.节点上具体接口调用的信息可以从全局节点信息表中获得.当节点进入网络时,需要向后台运行时系统进行注册.后台运行时系统在接受节点注册信息后,会在全局节点信息表中增加一个节点信息表项,如表1所示.出于对节点安全性的考虑,节点并未开放所有的接口调用.未开放接口调用的信息不会被放入节点注册信息中,也是无法被访问.此外,由于TinyOS对事件函数的触发固定的,每个事件接口调用只能对应于一个事件函数,因此需要记录当前开放的事件接口调用是否已经被占用.(3)绑定操作(BindOperation).利用绑定操作可以将时间属性和空间属性与具体对象进行绑定.空间属性绑定操作如式(6)所示:SpaceBind(InterfaceProvider,SpaceAttribute)其中,InterfaceProvider是接口提供者,可以通过后台运行时系统获得;SpaceAttribute是空间属性,它可以由4.1节中的3种方式进行定义.与空间属性类似,时间属性的绑定操作如式(7)所示:TimeBind(InterfaceCall,TimeAttribute)(7)其中,TimeAttribute是时间属性,可以通过相对时间和绝对时间进行定义;InterfaceCall是具体接口提供者能够提供的接口调用.很明显,时间绑定操作与空间绑定操作的被绑定对象是不同的.这是由于接口提供者是与具体节点绑定;而接口调用的空间属性是由具体节点的空间属性决定.将空间属性与接口提供者进行绑定,也就确定了接口调用的空间属性.另一方面,接口调用与代码开始执行的时间密切相关,因此接口调用需要直接与时间属性进行绑定.图4展示了一个具有跑马灯效果的EasiSNP顶层应用程序.它实现了多个节点上LED灯的协同Page6循环闪烁.简要说明如下:首先在L2中定义了Cont个接口提供者Leds.通过查询后台运行时系统,程序解释系统将获得至少Cont个能够提供接口leds的节点作为备用节点(接口leds中实际上包含了若干接口调用.如果不做声明,直接定义接口leds则表明需要包含leds中的所有接口调用).如果能够提供所需接口调用的节点数量少于Cont个,EasiSNP系统可能无法完成编程.接下来,Leds[0]将作为跑马灯的起始点被初始化(L3~L4).通过SpaceBind操作要求接口提供者Leds[0]与距离原点[0,0]最近的节点进行绑定;并且通过TimeBind操作将Leds[0]的命令接口调用leds.TurnOn()与一个绝对时间属性进行绑定,即在10:00pm打开一个距离原点最近节点上的LED,并且以2s作为时间间隔周期触发接口提供者Leds[0]上的命令接口调用leds.TurnOn().在循环体中,Leds[i]将通过SpaceBind操作和某个在空间位置上位于Leds[i-1]左面的节点进行绑定(L5~L8).然后将Leds[i]的命令接口调用leds.TurnOn()与事件接口调用Leds[i-1].leds.On()定义的相对时间属性进行绑定.将Leds[i-1]的命令接口调用leds.TurnOff()与事件接口调用Leds[i].leds.On()定义的相对时间属性进行绑定.其最终效果是当前节点LED的开启状态将触发位于它左边的下一个节点LED的开启操作,同时下一个节点LED的开启状态将触发位于它右边节点LED的关闭操作.4.3顶层应用程序分解EasiSMP顶层应用程序不能直接被传感器节点执行,需要程序解释系统将顶层应用程序分解为节点可执行的任务块(taskblock),过程如图5所示.程序解释系统首先会对顶层应用程序中定义的接口提供者进行一次检索,并建立检索表.由于每个接口提供者将对应于一个节点,因此它所提供的接口调用将被放入同一个.nc文件中.同时,程序解释系统会向后台运行时系统查询当前哪些节点能够提供这些接口调用.如果没有找到合适节点,程序解释系统会向编程者反馈没有节点可以提供这些接口调用.考虑到网络的动态性,未来新加入的节点可能具备所需的接口调用,因此编程者也可以通过设定较大TimeOut,在当前执行顶层应用程序的条件不具备时,忽略程序解释系统的反馈.网络会在条件满足时,以best-effort的方式执行顶层应用程序[10].接下来,程序解释系统将继续检索顶层应用程序中的SpaceBind和TimeBind操作.SpaceBind操作将接口提供者与编程者定义的空间属性进行绑定.由于每个接口提供者都会对应独立的.nc文件,因此每个.nc文件都将附加一个空间属性,如图5所示.TimeBind操作将接口调用与编程者定义的时间属性进行绑定.如图6(a)所示,与绝对时间绑定的接口调用可以通过节点运行时系统提供的全局时间事件接口调用进行触发.被绑定的接口调用将转化为全局时间事件函数(FTSPTimerFired)的内容.如果全局时间事件函数直接由底层TinyOS进行触发,由于底层TinyOS的代码不能被修改,实际上只能提供有限个数的对全局时间事件函数的触发.当多个任务块部署到节点上时,可能需要对多个全局时间事件函数进行触发.在这里需要节点运行时系统对多个全局时间事件接口进行协调,即由TinyOS触发节点运行时系统,然后由节点运行时系统触发对应的全局时间事件函数.与相对时间绑定的接口调用可以通过具体的事件接口调用进行触发.但是具体到每一个事件,需要区分事件本身是否发生在节点本地,换而言之,需要判断事件接口调用的提供者与接口调用的提供者是否相同.如图6(b)所示,如果事件发生在节点本地,即事件接口调用的提供者和接口调用的提供者均为接口提供者B,则可以由本地节点的底层TinyOS提供的事件接口调用直接触发.如果事件本身不是发生在节点本地,即需要由接口提供者A提供事件接口调用.如图6(c)所示,接口提供者A提供的事件接口调用需要触发一个特殊的事件函数,其内容是告知当前接口提供者A所绑定节点的运行时系统事件已经发生,由这个节Page7图6绑定时间属性转化示意图点运行时系统向接口提供者B所绑定节点的运行时系统传递事件发生的消息.而接口提供者B所绑定节点的运行时系统在接受到这个消息后,会触发相应的事件函数,其内容是执行被绑定的接口调用.由于接口调用的时间属性是由事件接口调用转化而来.如果当前节点不能提供这个事件接口调用或者开放的事件接口调用已经被占用,则意味着当前的节点不能够满足接口调用绑定的时间属性.4.4任务块生成从图5中可以看出,任务块是由NesC程序生成的可执行代码以及相关函数管理列表组成,其中可执行代码的生成与节点类型密切相关.在程序解释系统生成附加有空间属性的.nc文件后,需要第2次向后台运行时系统发起查询请求.查询的范围是首次查询中可以充当接口提供者的节点;查询内容是这些节点当前的空间位置是否满足.nc附加的空间属性,以及是否能够提供时间属性转化来的事件表3函数管理描述(CalledCommandFunctionList,CCFL)(FunctionIndirectCallList,FICL)(FunctionAddressVectorList,FAVL)4.5任务块加载命令函数是节点底层操作系统TinyOS的一部分.它们在任务块迁移之前,已经保存在节点上,其函数地址是固定的.当任务块迁移到节点上时,任务块中对命令函数的调用指令需要根据命令函数的实际地址进行修改.但是,为了使任务块能够在节点之间进行迁移,又不可能频繁修改任务块中所有对命令函数的调用指令,我们使用寄存器间接寻址的方接口调用.程序解释系统会根据反馈回来的节点信息,选择合适的编译参数和交叉编译器,对.nc文件中的NesC程序进行编译,生成节点可执行代码.如果满足任务块时空属性的节点数量仍然超过所需,由于任务块可以通过内部迁移保存在节点的外部扩展存储器中(详见4.5节),程序解释系统会优先选择已保存有当前任务块的节点,并将剩余节点作为备用节点.最终,任务块的相关信息被记录到任务块管理列表中,方便以后对该任务块的迁移.表2显示了一个任务块管理列表中的表项.此外,为了使任务块能够在节点上顺利加载和执行,需要在任务块中附加两个函数管理列表:被调用命令函数列表(CalledCommandFunctionList,CCFL)和事件函数列表(EventFunctionList,EFL),如表3所示.两个函数列表分别用于任务块对命令函数的调用和底层TinyOS对事件函数的调用,如图7所示.法实现对节点上的命令函数进行调用,具体方法如下所述.在生成任务块时,任务块中每一条对命令函数的调用指令都被修改为寄存器间接寻址模式,如式(8)所示:与传统寄存器间接寻址不同,我们在这里通过对二进制代码的修改,实际上使用寄存器Rx保存了基Page8图7命令函数与事件函数的链接与调用(其中:(1)任务块与命令函数的链接;(2)TinyOS系统与事件函数的链接;地址,而cont的值将由程序解释系统根据对命令函数进行调用的指令在任务块中的地址顺序决定.相同的调用指令可能出现在任务块的不同地址上,以低地址的调用指令为准.同时,任务块中附加的CCFL包含了任务块中所有被调用命令函数的编号,并且编号的存储顺序按照调用指令在任务块中的保存地址以由低到高的顺序进行排列.节点运行时系统需要维护两个关于命令函数的列表:命令函数列表(CommandFunctionList,CFL)和函数地址向量表(FunctionAddressVectorList,FAVL).CFL保存了当前节点上所有命令函数的入口地址.FAVL是根据每个加载到节点上的任务块动态生成的,它记录了在任务块中调用的命令函数真实入口地址.由于使用了寄存器间接寻址的方式对命令函数进行调用,FAVL函数入口地址的顺序与CCFL中的函数排列顺序保持一致.考虑到可能存在多个任务块在节点上运行,可以通过对寄存器(Rx)进行初始化,给每个任务块的FAVL分配独立的存储空间,如式(9)所示:其中FAVL_addr是任务块对应的FAVL首地址.这条初始化语句必须放置在任务块的起始位置.当任务块加载到节点中时,节点运行时系统需要根据当前已存储FAVL的情况修改这条语句.图7中(1)所标识的路径显示了任务块的调用指令与命令函数的链接过程.首先节点运行时系统获得当前任务块对应FAVL的首地址,并通过式(9)中的赋值命令将这个首地址赋值给寄存器Rx.然后运行时系统会读取CCFL,并在CFL中查找对应函数的真实入口地址.这些真实入口地址将按照CCFL中函数的排列顺序生成FAVL.最终,节点运行时系统会将任务块的FAVL保存在节点主内存中.图7中(3)所标识的路径显示了一个任务块中的调用指令(call32(Rx))对TinyOS中的命令函数(Led0.TurnOn())进行调用的过程.任务块中对命令函数进行调用的指令需要从FAVL中获得命令函数的真实地址(0x4100).另一方面,事件函数在任务块中定义,由底层TinyOS进行调用.TinyOS对事件函数的调用指令已经在主程序中固定,不能被修改.而事件函数的真实地址只有任务块在迁移到节点上之后才能被确定.EasiSNP采用函数的间接调用解决这个问题[11].如图7所示,节点运行时系统需要维护一个函Page9数间接调用表(FunctionIndirectCallList,FICL).如果节点开放了某个事件接口调用,则对应事件函数的调用指令需要指向FICL中的某个表项.FICL每个表项保存一条对事件函数的调用指令以及一条返回指令.由于任务块对于事件接口调用具有独占性,因此所有加载到节点上的任务块将共享同一个FICL.当节点运行时系统发现当前事件接口调用已经被某个任务块占用,在这个任务块失效之前,节点将不能再提供对应的事件接口调用.任务块中附加的EFL包含了任务块中所有事件函数的相对地址(相对于任务块首地址).当任务块加载到节点上时,需要根据这条相对地址实时计算出事件函数的真实入口地址,并修改相应的FICL表项.图7中(2)所标识的路径显示了一个主程序(TinyOS)中的调用指令与事件函数Time1.fired()的链接过程.首先节点运行时系统获得任务块在节点主内存中的起始地址(0x8000).然后在这个起始地址的基础上,根据EFL中的事件函数的相对地址($+0x124)计算出事件函数真实入口地址(0x8124).最终,根据事件函数的真实入口地址修改FICL中对应的表项.图7中(4)显示了主函数中的调用指令对任务块中的事件函数进行调用的过程.调用指令并没有直接跳转到事件函数Timer1.fired()上,而是先跳转到FICL中的对应表项.该表项中包含了函数Timer1.fired()的真实地址,并由表项中的调用指令完成对Timer1.fired()的调用.4.6任务块迁移传感器网络的动态性决定了任务的执行存在不可预知性.特别是基于时空属性进行编程时,由于存在多种影响时空属性的外部因素,即使任务块已经被加载到各个节点上,也不能保证顶层应用程序能够顺利执行.为此我们提出了任务块迁移机制,其核心思想是如果节点不能满足任务块的时空属性或者节点失效时,任务块将被迁移.任务块迁移机制包含节点内迁移和节点间迁移,前者主要降低了节点重复加载相同任务块带来的额外开销,后者实现了任务块在节点之间的动态部署.节点内迁移是将主内存中保存的任务块转存到节点外部扩展存储器上.当前主内存中可能保存了若干失效任务块,例如由时间属性定义的单次触发(shot)任务块在被执行后,可能很长一段时间不再被执行;或者,节点离开了当前位置,新的空间位置不能满足任务块的空间属性,此时任务块将不再有效.在节点主内存容量有限的情况下,节点运行时系统需要动态使用新加载任务块覆盖失效任务块.但是如果未来部署的顶层应用程序,仍需要节点执行这部分失效任务块时,不得不将它们重新传输到节点上.特别当需要频繁重复部署多个顶层应用程序时,相同任务块在网络中的重复传输会造成较大的额外开销.因此将失效任务块迁移到节点的外部存储器中,可以在很大程度上节省由于重传任务块带来的能量开销,同时也缩短了部署时间.节点间迁移是指将任务块由源节点传输并加载目标节点上.按照源节点的不同,可以分为计算机端到节点端的迁移和节点端到节点端的迁移.节点端到节点端的迁移主要适用于当前节点的空间位置无法满足任务块的空间属性时,将任务块迁移到备用节点上.节点运行时系统发现节点位置发生变化后,会发出位置变更消息给后台运行时系统.后台运行时系统将完成3步工作:(1)通过检索任务块列表,检查新的空间位置是否满足任务块绑定的空间属性.(2)如果有任务块在节点位置改变后失效,检查是否有备用节点满足当前失效任务块的空间属性.(3)选择合适的备用绑定节点作为替换节点.在位置改变节点与替换节点之间建立传输管道,将任务块发往替换节点.计算机端到节点端的迁移是指计算机端重新将任务块迁移到备用节点之上.当节点失效(如信道不稳定、电池耗尽等)时,已经无法将其保存的任务块进行传输,这些任务块由计算机端重新部署到备用节点之上.实际上,根据具体节点是否永久性脱离网络,需要进行分别处理.如果节点是永久性脱离,则部署到备用节点之上的任务块不会再发生变化.否则,如果当前节点只是暂时性脱离,因为当前节点可能是满足任务块时空属性的最优节点,我们仍然希望当它恢复时够继续执行任务块.因此部署到备用节点之上的任务块需要通过节点内部迁移保存到外部扩展存储器中.当最优节点再次失效时,不再需要从计算机端向备用节点加载任务块,而直接进行任务块切换.Page105实验结果与分析在本节中将通过实验验证EasiSNP的有效性.5.1节介绍分析了两个应用于蓝藻监测打捞感-执系统的顶层应用程序.5.2节将从编程开销、通信开销和存储开销3个方面对EasiSNP的性能进行分析.最后在5.3节通过仿真实验测试EasiSNP在减少数据延时方面的有效性.5.1实验场景介绍当前,我们在太湖部署的蓝藻监测打捞感-执系统采用了TD-CDMA(3G)和802.15.4两种网络.感知层网络采用树状拓扑结构,传感器节点通过802.15.4网络,以多跳传输的方式将感知数据发往汇聚节点(sink).汇聚节点将各个节点的数据进行简单处理后,通过3G数据网络发往云端.由于802.15.4网络是一种低功耗低速率的个人局域网络,其通信链路易受到天气等环境因素的影响.在采用树形拓扑的感知层网络中,单个转发节点的信道阻塞,可能导致大量需要转发的数据被阻塞,不利于对蓝藻爆发的实时监控.通过编写EasiSNPRealTime(Sensor[i].CheckChanel.Jam,30min,Peri,1min);}L15TimeBind(ExecUnit.DataProcess.Forward,ReltTime(ExecUnit.DataProcess.SaveDone&/L16TimeBind(Sink.Send_3G.send,ReltTime(Sink.DataProcess.Savedone,100ms,Shot,Null));图8协助数据转发的顶层应用程序另一方面,移动的执行单元可能在打捞的过程中,希望实时获得当前局部的蓝藻信息.为此,我们设计了图9所示的EasiSNP顶层应用程序,ExecUnit动态地与距离其4跳范围内的Sensor进行绑定(L8).4跳范围内的Sensor对水质的温度和酸碱度进行周期采样,并将采样数据发往执行单元(L7~L10).基于以上两个例子程序以及图4所示的跑马顶层应用程序,可以要求网络本身寻找位于失效节点附近的有效节点,协助数据的转发.根据太湖监测环境的特殊性,协助数据转发的节点可以由执行打捞任务的移动执行单元充当.图8给出了协助数据转发的顶层应用程序.在这个顶层应用程序中,首先声明4种接口提供者(L1~L10):Sink、Sensor、Forwarder和ExecUnit.首先,Sensor在一跳范围内绑定一个ExecUnit,并且测试能否得到下一跳Forwarder的回应.如果没有回应,则说明到下一跳Forwarder的信道可能阻塞,事件Jam发生.Sensor把数据发送给ExecUnit(L11~L13).ExecUnit在保存完整的数据之后,会触发SaveDone接口调用,表示数据可以被转发出去.这时如果ExecUnit能够到达Forwarder的一跳范围内,则将数据发送出去(L14~L15).同时,如果这些数据被转发到Sink,则会触发Sink上的SaveDone接口调用.由L16可知,Sink立即会调用Send_3G.Send向云端传输这些数据.值得注意的是由于充当接口提供者Forward和Sink的节点将由网络动态指定,因此汇聚节点可能同时充当这两个接口提供者的角色.灯顶层应用程序,我们设计了3个实验场景测试EasiSNP的各项性能:Case1.编写跑马灯的顶层应用程序,并部署到网络中.跑马灯仅是通过邻节点LED状态对当前节点上LED灯进行控制,控制逻辑较为简单,编写和传输的代码量较小.Case2.编写实时采集数据的顶层应用程序,并Page11部署到网络中.实时采集数据主要是对普通感知节点的温度和湿度传感进行数据采集和传输.普通节点的空间属性需要通过跳数(hop)定义,且移动节点的位置是不断变化的,因此需要向节点加载一个能够动态分析距离移动节点跳数的代码段.ReltTime(Sensor.WaterTempra.StartDone&Sensor.WaterPH.StartDone,100ms,Shot,Null));图9实时采集感知数据的顶层应用程序5.2EasiSNP的开销3个方面对EasiSNP的性能进行测试.本小节将从编程开销、传输开销和存储开销编程开销是指为了完成某个特定目标,所需编写程序的代码量.EasiSNP以接口与时空属性进行绑定的方式直接对节点上的接口进行编程,可以使编程者在编写代码时较少考虑具体细节,将大量的解释工作留给程序解释系统,从而降低了编程开销.我们以NesC语言作为比较对象,并且将编写代码的行数作为衡量编程开销的指标[12].表4给出了直接使用NesC语言实现Case1~Case3中的顶层应用程序所需编写代码量.EasiSNP顶层应用的代码量明显少于NesC程序的代码量.以Case1中的跑马灯程序为例,编程者直接使用NesC进行编程时,需要编写相应的配线文件(configuration)和模块文件(module)[7].其中配线文件约为32行,模块文件约为198行.而在EasiSNP中,只需要编写8行代码,所需要编写的代码行数相差将近25倍.NesCEasiSNP8EasiSNP的通信开销主要来自于对任务块的传输.图10给出了在使用NesC直接编程后,将产生的节点可执行代码通过两种代码更新方法Stream[13]和EasiCache[11]产生的通信开销.可以看出,EasiSNPCase3.编写协助数据转发的顶层应用程序,并部署到网络中.在协助数据转发的场景中,普通节点除了要分析当前距离移动节点跳数之外,还需要对信道是否阻塞进行判断.同时,由于汇聚节点与普通感知节点存在差异性,需要根据汇聚节点的具体类型,生成专门的可执行代码,因此传输代码量较大.的通信开销明显少于Stream,但是高于EasiCache.这是由于EasiCache是一种增量式的代码更新方法,它通过仅仅传输原有旧程序与更新程序的差异部分,极大地降低了代码更新的通信开销.Stream需要将整个更新程序进行传输,通信开销较大.尽管EasiSNP没有采用增量式代码更新方法,但是由于任务块的代码量要远小于主程序,因此仍然可以保持较低的通信开销.表5给出了4轮重复部署Case1~Case3中的顶层应用程序后,EasiSNP和EasiCache产生的通信开销.在每一轮中,需要将3个例程全部重新部署一遍.在第1轮部署中,EasiSNP需要传输不同的任务块,其传输开销明显高于采用增量式代码更新方法的EasiCache.但是在随后的3轮部署中,EasiSNP仅仅传输少量的控制命令(8Bytes)就可以完成重复部署,这主要得益于通过节点内部迁移将失效的任Page12务块保存到节点的外部扩展存储器中.当部署过的顶层应用程序再次被重新部署到网络中时,可以直接将所需的任务块放入处理器的主内存中,而无需再次传输.EasiSNP8122242424EasiCache490617201124916EasiCache也采用了类似的缓存思想,它通过将频繁更新的代码缓存在RAM中,也可以在一定程度上消除重复升级带来的冗余传输.但是受到RAM容量的限制,能够缓存在RAM中的代码远远少于EasiSNP放入外部扩展存储器中的任务块.因此使用EasiCache尽管每次需要传输的代码量较前一轮都在逐渐减少,但是仍然超过EasiSNP的传输代码量.由于节点上存储资源较为有限,需要考虑EasiSNP对节点存储资源的影响.EasiSNP的存储开销主要来自于3部分:任务块、节点运行时系统以及各种函数管理列表,如图11所示.图11EasiSNP各部分的内存开销(以msp430f1611为例,节点运行时系统需要8KB左右的存储空间.函数管理列表总共大约需要5KB的存储空间.其中命令函数列表是由主程序中所能提供的命令接口数量决定的,大小相对固定.命令函数列表中单个表项需要3Bytes的空间,通常节点能够存储的命令函数在大约在150~200个之间,因此需要1KB的空间存放命令函数列表.而函数地址向量表是由节点运行时系统根据当前加载的任务块生成的,它的大小也是与任务块中需要调用的命令函数数量密切相关.当存在多个任务块是,通常需要分配1.2KB~1.5KB的存储空间.最后,函数间接调用表保存了底层TinyOS对任务块中的事件函数的间接调用命令,其大小是由TinyOS所能提供的事件接口的数量决定.一般事件接口数量在100~200个之间.由图7可知,每个函数间接调用表的表项大约需要8Bytes,分配2KB~2.5KB可以满足需求.整个EasiSNP节点运行时系统需要占用11KB~12KB的空间.对于资源有限的节点来说还是可以承受的.这主要是因为程序的核心功能被放到了任务块中执行,主程序中更多的是一些针对底层硬件的驱动程序.并且任务块可以动态迁移到不同节点上提高了节点间的协同能力,可以进一步消减单个节点上主程序所需存储空间.通常任务块的大小在1KB~4KB之间,在充分考虑存储安全的基础上,保留7KB~8KB的空间作为任务块的存储区域.当多次对节点加载任务块后,主内存可能无法对所有的任务块进行保存,因此需要通过节点内迁移将失效的任务块保存到节点的外部扩展存储器上.由于外部扩展存储器拥有较大的存储空间因此可以同时存储多个任务块.图12显示了分别经过30次不重复更新时,存储失效任务块所需要空间占外部扩展存储器总空间(>512KB)的比例.我们发现保存这些失效任务块不会对扩展存储器造成很大影响.图12保存失效任务块所需的外部扩展存储空间5.3EasiSNP的动态性分析我们使用NS-3①网络仿真工具模拟了一个拥有60个传感器节点的蓝藻监测打捞感-执系统,如图13所示.60个节点被分为3簇,部署在2km×2km的水域内.簇内采用树形拓扑结构,簇头节点即为汇聚节点,汇聚节点通过3G数据网络将感知数据传回.传感器节点每隔1min进行一次数据采样,并通过802.15.4网络将数据发往汇聚节点.受环境因素影响,802.15.4网络的无线信道存在不稳定性.通过NS-3随机产生了4个失效节点(a3,b2,c2,d3).①NS-3.http://www.nsnam.org/documentation/Page13数据被阻塞在失效节点的邻节点(a4,b3,c3,d4).假设每个失效节点的失效时间均为30min.我们通过式(10)定义被阻塞数据在这段时间内的平均延时:其中Amoutsample是失效时间内的采样次数,Delaysum是数据的总延时.在没有其它节点帮助失效节点进行传输的情况下,30min内数据的总延时如式(11)所示:Delaysum=(Delaymax+Delaymin)×AmoutsampleDelaymax和Delaymin是在节点失效时间内,采样数据的最大和最小延时.由设定可知,在30min内,感知节点共进行了30次采样,数据的最大延时和最小延时分为为30min和1min,在节点失效的30min内的数据平均延时为15.5min.图13蓝藻监测打捞感-执行系统部署示意图引入打捞执行单元(ExecUnit)以12节(22km/h)的平均速度在这片水域随机游走,并且假定执行单元上具备与传感器节点进行通信的能力.将Case2中协助数据传输的顶层应用程序部署到网络上.顶层应用程序首先在计算机端被分解为若干任务块,这些任务块通过3G数据网络被下载到汇聚节点上,然后这些任务块被分发到失效节点附近的节点上.当移动的打捞执行单元接近汇聚节点或者失效节点附近水域时,这些任务块被下载到执行单元上.随后,当执行单元移动到失效节点附近时,将代替失效节点完成数据的转发.表6给出了执行单元到达失效节点附近的时间.相对于执行单元的运动时间,执行单元与感知节点之间的通信时间几乎可以忽略不计.执行单元将转发其到达之前被阻塞的采样数据,因此可以将这个时间作为这部分阻塞数据的延迟时间,新的Delaysum重新表述为式(12):Delaysum=Tarive×Amoutsample+Delaymax+Delay其中,Tarive是执行单元的到达时间;Amountsample是执行单元到达之前执行采样的次数;Delaymax、Delaymin和Amountsample分别是在执行单元离开之后,采样数据的最小延时、最大延时以及执行采样的次数.以节点b2失效为例,由于节点b2无法转发数据,数据被阻塞在了节点b3.从图13中可以看到,执行单元在3.18min到达sink1附近并下载到任务块.在0.34min后,执行单元到达失效节点b2附近.根据顶层应用程序,执行单元作为(ExecUnit)会在节点b3和转发节点b1(Forwarder)之间重新建立连接,帮助阻塞在b3节点上的采样数据(包含[b3,b4,b5]的采样数据)完成传输.在Tarive=3.52这个时间点之前进行了3次采样,而执行单元离开后又发生了27次采样,其平均数据延时为12.16min.图14给出了通过执行单元协助传输后,如图13所示蓝藻监测打捞感-执系统中失效节点附近被阻塞数据的平均延时.可以看到4个失效节点附近的图14蓝藻监测打捞感-执系统中失效节点附Page14数据延时都有所降低.比较特殊的是失效节点a3附近被延时的数据.当执行单元经过a3附近时,其行驶路线远离可以作为转发节点的a2,因此没有把节点a2作为接口提供者Forwarder.而是将执行单元路径上的节点e7作为转发节点,完成了数据的转发.实际中,由于很难预先估计到执行单元会移动到什么位置,也无法确定哪些节点能够充当转发节点.通过设定较大的触发延时(TimeOut),并将Forwarder对应的任务块暂时保存在执行单元上.一旦执行单元发现了满足任务块时空属性的节点,即把这个任务块加载到节点上,完成数据转发.6相关工作早期的研究已经提出了若干种针对传感器网络的编程方法[7,14-16].这些编程方法大多数是针对具体节点的编程,可以归为节点级(node-level)编程.例如,TinyOS需要使用一种事件驱动的编程语言NesC进行编程[7].由于NesC编写的应用程序主要是针对传感器节点,需要编程者对顶层硬件有一定了解,开发难度较大,也不易于对节点进行动态配置.为了方便对节点进行动态配置,Levis等人[14]提出了一种基于虚拟机的编程方法ASVM.这种编程方法通过提供少量针对特殊应用的指令,可以极大地降低更新代码的代码量.但是由于ASVM只能采用紧凑型代码进行编程,导致编程灵活性不佳,表达能力有限.SensorWare[15]采用了一种基于Tcl控制脚本语言,主要应用于网络重编程,但是其应用对象是资源丰富的硬件平台,对于资源受限的传感器节点并不适用.因此,如何高效地对传感器网络进行编程是当前亟待解决的问题.目前的研究普遍认为利用高度抽象的网络级(network-level)宏编程(macropro-gramming)可以在一定程度上解决这些问题[17-21].宏编程方法的核心思想是不明确指定编程的节点,而是通过描述网络的行为以及网络中实体(entity)的相互作用关系,由网络自适应地选择合适节点完成相应任务.例如,为了尽量消除移动节点给网络带来的动态性,在文献[19]中提到一种空间编程(SpatialProgramming)方法,它将节点动态地与空间地理位置进行绑定.当节点位置移动时,网络在指定的空间位置上自动绑定新的节点.这种方法的缺点在于资源有限的传感器网络节点缺乏有效的定位手段,很难将节点定位到一个绝对空间位置上去.基于Agent的中间件Agilla[20]能够在运行时将应用动态部署到传感器网络上.但是Agent之间只能通过元组空间(tuplespace)实现数据交换,缺乏有效地协同.文献[21]将手机网络作为感知层网络,通过编程的方法实现了由“人”到“人”的参与感知[5],但没有考虑如何与传感器网络进行协同,以实现“物”与“人”的交互.7结束语当前作为感知层的传感器网络通常是由资源受限的传感器节点组成,传感器节点的正常工作经常受到外界环境因素的影响,造成传感器网络具有较强的动态性.同时,移动节点的引入会加剧网络的动态性.为了增强网络的健壮性,编程者不得不预先设计各种冗余机制,加大了对传感器网络的编程难度.本文提出了一种基于时空属性的网络编程方法———EasiSNP.它通过定义接口和节点的时空属性,使用接口描述网络的行为,从而不需要再对具体节点进行编程,降低了编程的复杂度.并且采用替换的思想,通过任务块迁移机制自主地选择最优的节点执行任务,尽量消除外界环境因素和移动节点给网络带来的影响.在未来的工作中,我们将继续研究如何把这种基于时空属性的编程方法应用到更具有普遍性的移动终端.通过移动终端与传感器网络的融合,在真正意义上使“人”成为物联网的一部分.
