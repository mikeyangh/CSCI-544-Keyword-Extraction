Page1DNA序列中基于适应性后缀树的重复体识别算法霍红卫王小武(西安电子科技大学计算机学院西安710071)摘要现有的在DNA序列中识别重复体的算法多数是基于比对的,对识别速度和吞吐量有很大的限制.针对这个问题文中根据一个平衡重复体的长度和频率的定义,提出了一种基于Ukkonen后缀树的快速识别重复体的RepSeeker算法.算法采用最低限制频率,最大程度地扩展了重复体的长度,同时为了进一步地提高RepSeeker算法的效率,对Ukkonen的后缀树构造算法进行了适应性改进,在构造时加入RepSeeker算法所需的结点信息并将叶子结点和分支结点加以区分,从而使得RepSeeker算法能通过直接读取结点信息来求得子串频率和子串位置.这种改进较大地提高了RepSeeker算法的性能,而且空间开销不大.实验中使用了NCBI中的9条典型DNA序列作为测试数据,并对后缀树改进前后的重复体识别算法做了比较分析.结果表明,RepSeeker在没有损失精度的情况下缩短了算法的运行时间.实验结果与理论上的分析一致.关键词重复体识别;适应性后缀树;Ukkonen算法;RepSeeker算法1引言基因组中含有许多重复元素.例如,在人类基因组的约3.2×109个碱基对中超过50%已被识别为各种重复元素[1-2].重复体识别对于分析新的基因组非常重要[3],这是因为:(1)重复体以各种方式引导着基因组的进化过程;(2)在进行同源查找之前需要对重复体进行掩模.而在实际中有各种各样的重复体,大多数重复体的功能并未完全被理解和定义[4].当前研究表明某些重复体在基因表达和转录调控方面起着重要作用[5].与重复体结合的碱基可能导致基因重组,使基因组发生重大变化.重复体种类繁多,它们包含着几个到数百的碱基对,有些可达上万碱基对.一些人类的遗传疾病诸如脆性X染色体综合症、亨延顿氏症以及弗里德共济失调都与重复体长度的不规则性有关[6].一个重要的生物信息学问题是如何快速识别并有效地表示基因组中的重复体.目前,解决重复体识别的方法大致有两类:RepeatMasker[7]根据一个已经注释的重复体数据库对已知重复体进行查找.这个数据库很大程度上依赖于同源序列的相似性.这种方法不能用于处理新的基因组序列,是因为它不能为新测序的基因组构建所需的库信息.而且,对于新的基因组,它的重复体库需要手工编撰,因为这种方法是面向特定基因组的.对RepeatMasker数据库的从头识别仍然是生物信息学中的一个挑战问题[8].REPuter[9]是另一种方法,它摘取具有最大长度的所有重复体的相似对,并把重复体定义为一组具有最大长度的相似字符串对.这两种方法都没有考虑重复体的出现次数.一般而言,在真实生物序列中,重复体会出现多次.例如,在人类基因组中Alu出现106次.在复杂的基因组中,转座子一般出现几十万次.因此,在识别方法中结合重复体的频率更合理.具有生物意义的重复体的定义必须考虑重复体的长度和频率.一些研究表明准确地定义重复体是不容易的.一些方法只能找到短的重复序列或串联重复序列.它们难以找出长且散布的重复序列.最近的一些方法集中在识别重复体的边界上.Price等人提出了RepeatScout算法[10],该方法使用高频l-mer种子来查找重复体的边界,且用贪心法扩展每个种子,使之成为更长的同源序列.Edgar和Myers研制了RILER软件包[11],通过刻画重复体特征和局部比对来识别具有可靠边界的重复体.意识到重复体出现频率的重要性,已有几种方法把长度和频率结合在重复体的定义中.Zheng和Lonardi[12]给出了一种基于后缀树来查找DNA序列中重复体的方法,且时间复杂度为O(n2f)[13].Zheng和Lonardi算法的效率不高,是因为对于数十万碱基对长度的DNA序列,算法仍然难以有效工作.Σ表示一个有限非空字母表.字符串和字母用斜体字体.|S|表示字符串S的长度.S[i]表示字符串S中的第i个字符,1i|S|.S[i,j]表示S的子串S[i]S[i+1]…S[j],1尽管在试图定义和识别一个序列中重复体已有大量成果,重复体查找仍然是一个挑战性的问题.文献[8]使用了局部序列比对策略和A-Bruijn图来解重复体查找问题.然而,基于A-Bruijn图的方法的分析非常复杂和困难.此外,这种方法需要对输入序列进行双序列局部比对.其性能主要依赖于局部比对的结果.Gu等人[14]提出了一种基于精确字统计法来估计大型真核基因组中重复结构出现频率的方法,该方法对比期望出现次数多的寡核苷酸进行分类.本文中按照文献[12]中对重复体的定义,对Ukkonen后缀树构造算法做了适应性的改进,提出一种快速识别重复体的算法RepSeeker.RepSeeker算法使用最低频率限制,并扩展重复体的长度使之达到最大.在后缀树的构造过程中,对叶子节点进行编号,并把叶子节点的信息加入到分支节点中,叶子节点和分支节点所包含的信息不同,以使RepSeeker算法能够直接从节点中获得子串的频率和位置信息.这种改进大大提高了RepSeeker算法的性能,而且空间开销不大.RepSeeker算法使用来自NCBI中的9条序列进行了性能测试.并对改进前后算法的性能作了比较.实验结果表明,对其数据结构所做的改进大大降低了RepSeeker算法的运行时间,同时又保证了识别的精度.实验结果与理论上的分析一致.2RepSeeker算法2.1表示、约定及基本定义Page3ij|S|.约定S[i,i]=S[i].L-串(或L-子串)是一个长为L的字符串(子串).Ai表示A在S中的第i个出现.Ai表示A的第i个拷贝.有时我们会交替使用这些表示,因为根据上下文就可以明确它们是表示子串还是表示子串所在位置.如果字符串A是字符串S的一个子串,且在S中出现多次,则称A是S的一个重复体.在分子生物学中,重复体就是一个碱基序列在染色体中多次出现的拷贝.阈值是指一个重复体在一个序列中重复出现次数所指定的最小值.滑动窗口(见图1)是某个定长的可视框.2.2定义定义1.设A是S的一个重复体,(A1,A2,…,Am)是A在S中出现的一个有序表,Ai是A在S中的第i个出现,m是A在S中的出现次数,且m2.设B是A的一个子串,(B1,B2,…,Bk)是B在S中出现的一个有序表,k是B在S中的出现次数.如果B在A中从位置s开始,那么B=A[s,s-1+|B|],0s|A|-|B|.如果k=m且每个Bi在Ai中出现的偏移量相同,则称B是A的一个子重复,i=1,2,…,m.定义2.A是S的一个非平凡子串,当且仅当A是S的一个非空、真L-子串,0<|A|<|S|,L是重复体的最小长度.定义3.如果A是S的一个具有最大长度的非平凡子串,且A在S中至少出现Fm次,A的每个非平凡子串是A的一个子重复,其中Fm是指定的重复体最小出现频率,则称A是S的一个基本重复体.性质1.如果A是S的一个基本重复体,且出现频率为f,那么A的每个L-子串出现频率均为f.证明.略.结论可由定义直接而得.上述性质使我们在计算重复体的出现频率时,可以删除大多数非候选的重复体.在计算中,使用后缀树作为基本数据结构,来统计具有给定阈值的其L-子串的频率.2.3算法描述RepSeeker算法首先找出输入序列S中的所有基本重复体,然后输出重复体的一个有序表.重复体表中的元素是一个数对,表示一个重复体在输入序列中的起始位置和结束位置.因此,识别基本重复体的问题可以转换为寻找重复体的边界问题.因而,RepSeeker算法检查输入序列中每个位置,并确定一个位置是否是重复体的一个边界.使用穷尽算法查找基本重复体是不切实际的,因为在S中有O(n2)个子串,对于每个长为m的子串,需要检查O(m2)个子串.因而,我们构造输入序列S的一棵后缀树,帮助进行频率统计.按照性质1,可得:如果A是S的一个基本重复体,那么A的所有L-子串出现频率相同,且至少为Fm.于是,RepSeeker算法计算出所有L-子串的出现频率,并根据频率数组把频率相等且至少为Fm的放在一块中.由于这只是一个必要条件,RepSeeker算法会检查这些块,并分裂那些包含非子重复的块.进而,算法对所得重复体进行扩展,最终进行分类.RepSeeker算法由以下5步组成.第1步.计算子串在滑动窗口中的频率.我们把重复体的最小长度L作为滑动窗口的宽度,并计算长度为W的子串在此窗口中出现的频率.滑动窗口每次向右移动一个位置.设频率数组为f,f[i]表示在位置i开始的L-子串的出现次数,即S[i,i+L-1]的频率.图1中显示了输入序列S的频率数组f的值.在图1中,f[0]=3表示在位置0开始的长为4的子串S[0,3]在S中出现3次,S[0,3]=“ABCD”;f[5]=3表示在位置5开始的长为4的子串S[5,8]在S中出现3次.第2步.求出频率相等的块.根据第1步中计算的频率数组,可以计算出出现次数至少为Fm的L-子串的起始位置和结束位置.在RepSeeker算法中,使用l和r分别记录它的左右边界(即起始位置和结束位置).如果分别来自l数组和r数组的两个元素在输入序列S中的位置相同且位置为i,那么它们表示同频率的候选重复块(l[i],r[i]).基于频率数组f,我们把序列划分成同频率的块.特别是,对于任何位置i,如果f[i]≠f[i-1],那么位置i是这个同频率块的起始位置;如果f[i]≠f[i+1],说明同频率块的最后L-子串在位置i开始,也就是说,i+L-1是这块的结束位置.每当得到一个起始位置或结束位置时,就把这个位置插入到l数组或r数组中.完成l数组或r数组的计算之后,接下来是对l数组和r数组中的元素进行配对.(l[i],r[i])是我们所找到的第i个相同频率块.例如,对于l[0]=0且r[0]=9,图1中的块S[0,9]=“ABCDEEBCAD”是一个频率相等块,它的长为4的7个子串出现频率一样.对于图1中的示例,去掉频率小于Fm(=3)Page4的子串后,最终频率相等块为S[0,9],S[12,21],S[24,28],S[29,33]和S[36,41].第3步.子重复检查.对从第2步得到的块进行检查,设某一块Di=S[i1,i2],块长度为length,出现频率为k,其块内所有长度为L的子串的频率为m,若k<m,则块Di内含有不是子重复的子串.从左到右依次求出块Di中所有长度为L的子串在S中的出现位置,然后对开始位置相邻的两个子串的出现位置序列进行比较,若存在对应次序上的位置不相邻,则分裂块Di.例如,图1中,子串S[0,9]的发生频率为2,但在第2步中被识别为重复体,通过子重复检查,发现S[1,4]=“BCDE”的出现位置为{1,13,30},S[2,5]=“CDEE”的出现位置为{2,14,36},两子串的第3次出现位置不相邻,因此将2插入l数组,将5插入r数组.对数组l和r的插入要求进行有序插入,即插入后数组仍保持有序.所以S[0,9]可分裂成S[0,4],S[2,7],S[5,9]3个重复体.第4步.重复体扩展.为了尽可能得到更长的重复体,我们归并有重叠的重复体,如果归并后的重复体频率至少为Fm.具有较高频率的重复体仍然被保留下来,较低频率的重复体被扩展.令重复体A和B含有重叠块,重叠块称为C.归并满足的条件如下:且其中merop为重叠率,OP为指定最小重叠率,A∪B为归并A与B之后的结果,frequency为归并后子串的出现频率.例如,在图2中,假设重复体A和B分别在输入序列中出现3次和2次.由图2可得A1和B1有公共重叠子块.如果A和B的重叠率至少为OP,且归并之后的结果块M1至少出现Fm次,那么我们进行归并,也即实施了扩展.同样,归并A3和B2得到M2.最终,B1和B2分别被扩展至M1和M2.第5步.重复体归类.将相同的重复体归为一类.2.4RepSeeker算法RepSeeker算法如下.RepSeeker(S,L,Fm)Input:stringSwithlengthn,minimumlengthLofOutput:classificationlistofallrepeatsinSthatap-0.createasuffixtreeforthestringS1.fori←0ton-Ldo2.f[i]←frequencyoftheithL-substringinS3.createD:anarrayofrepeatblocksinS4.iff[0]Fmthenadd0inlarray5.fori←1ton-L-1do6.iff[i]Fmthen7.iff[i]≠f[i-1]thenaddiinlarrayasa8.iff[i]≠f[i+1]thenaddi+L-1inrarray9.fori←0to|l|-1do10.D[i]←(l[i],r[i])11.D←{D[0],D[1],…,D[k-1]},sum←|D|12.Check(D)13.Extend(D)14.Classify(D)Check(D:anarrayofblocksofequalfrequency)1.fori←0tosum-1do2.iff[l[i]]≠f(D[i])then3.forj←0to|D[i]|-Ldo4.P[j]←sortedlistofpositionsofoccurrencesof5.fork←0to|D[i]|-L-1do6.form←0tof[l[i]]-1do7.ifP[k+1,m]≠P[k,m]+1then8.insertl[i]+k+1intolandkeepitsorder9.insertl[i]+k+L-1intorandkeepitsorder10.sum←sum+1Extend(D:anarrayofelementaryrepeats)1.fori←1tosum-1do2.ifmerop(i,i+1)OPandfrequencyofmerged3.then4.D[i]←(l[i],r[i+1])5.i←i-1,sum←sum-1Classify(D:anarrayofextendedrepeats)1.fori←0tosum-1do2.class[i]←repeatsequaltoD[i]RepSeeker算法工作如下.第1~2行计算S的所有L-子串的频率.第4~8行找出频率至少为Fm的所有重复块的起始位置和结束位置.第9~10行对l数组和r数组中元素配对.子例程Check检查块Di是否包含非子重复.子例程Extend归并满足条件的重复体,以达到扩展的目的.子例程Classify对重复体归类输出.Page52.5后缀树在RepSeeker算法中的作用后缀树数据结构对于RepSeeker重复体识别算法的有效实现起着至关重要的作用.在图3中,我们从T出发到叶子结点,可得到该序列的一个后缀.设序列P是k个后缀的公共前缀,而对于整个序列来说,P出现了k次.这样我们可以通过遍历同一“主干”下的叶子数目,来确定该“主干”在序列中的出现次数,也即频率.RepSeeker算法的主过程第2~3行用后缀树求得频率数组f.存在的问题:(1)为了得到子串P的频率,我们必须遍历N下所有叶子结点,来计算叶子数目.对于DNA序列来说,通过遍历来获取所需信息的时间需求是无法忍受的.(2)Ukkonen构建的后缀树,结点是按顺序分配的,没有对叶子结点和分支结点的区分.我们不能通过叶子的序号来得到重复体的出现位置.在第3步的子重复检查中,要通过KMP[15]来解决.在第5步的重复体归类中,要通过甚至时间复杂度为O(n2)的算法来完成.3对Ukkonen算法的适应性改进3.1Ukkonen后缀树构造过程Ukkonen后缀树构造算法[16-17]的基本思想是对于字符串S的每个前缀S[1..i]构造一个隐后缀树Ti,从T1开始,逐步增加i,直到完成Tn的构造,i=1..n.若字符串S的长度为n,则构造算法分成n步,对于每一步i+1,又分成i+1个扩展,每个扩展代表了S[1..i+1]的i+1个后缀中的一个后缀,在第i+1步的第j个扩展中,算法首先找到从根节点开始标记子串S[j,…,i]的路径的结束位置,然后将字符S(i+1)加入该子串尾对它进行扩展,除非S(i+1)已经存在.因此,在第i+1步,字符串S[1,…,i+1]首先被插入树中,然后插入S[2,…,i+1],S[3,…,i+1],以此类推.在i+1步的第i+1个扩展中对S[1..i]的空后缀进行扩展,确保向树中插入了单个字符S(i+1)(除非S(i+1)已经存在).树T1是标记为S(1)的单条边.在后缀树算法构造过程中,引入了扩展后缀树的3个规则以及后缀链使算法的时间复杂度为O(n).算法的详细描述见文献[16-17].3.2Ukkonen算法特征分析这个算法有几个显著的特点:一旦一个结点被作为叶子结点创建,那么它始终都是叶子结点,将不会有子孙结点.更重要的是,在每次将一个前缀插入到树中,就机械地用一个相同的字符去扩展每一个指向叶子结点的边,而这个字符必然是新后缀的最后一个字符.3.3构建后缀树时的改进后缀树对RepSeeker算法的主要贡献在于,它能快速地求出定长子串P在S中的出现频率,也就是求出有相同前缀P的后缀个数.如图3,利用后缀树计算子串频率传统的方法是:(1)从树根找起,先找到与P相匹配的树的主干;(2)遍历以结点N为根的所有叶子结点,所得的叶子结点数就是要求的P的频率.第1步可以在线性时间内找到N,第2步则要遍历以N为根的树,对于RepSeeker算法中,用移动窗口求频率数组,总共要遍历|S|-L个这样的树.而查找重复体的副本位置,Ukkonen构建的后缀树无所适从.为了高效实现RepSeeker算法,我们对Ukkonen构建后缀树的算法进行了适应性改进.改进主要是在构造时加入了结点信息,包括两点:(1)在构建后缀树时,对叶子结点和分支结点进行区分,做不同的编号.结点总个数初始化为2×|S|,给叶子编号是从0开始,每次加1,给分支结点编号从尾部开始,每次减1.(2)在分支结点处加入结点信息,包括当前结点下的叶子数以及叶子序号.以2.3节中的算法为据,首先给结点数组中每一个成员加入parent变量,保存父结点编号.通过parent,给新叶子结点的所有父结点加入新的结点信息,即叶子数加1,并在结点信息数组中加入新叶子编号.图4显示了字符串agagagcagagt所对应的改进后的适应性的后缀树.结点5上的信息3138表明,该结点下有3个叶子结点,它的后缀在字符串中出现的位置为1,3和8.Page6图4字符串agagagcagagt所对应的适应性的后缀树3.4改进对算法的支持质的提高.优点主要表现在两方面:对Ukkonen后缀树改进后,带来了算法速度上(1)用移动窗口求频率数组时,求每一窗口内子串的频率可在O(L)时间内完成,L为窗口宽度,即如图3中,求P的频率就等于是在找到主干P的终止结点N,找到后读取信息即可.而匹配P的过程是在HASH表中进行的,只需进行主干P路径上的结点数次比较,便可找到N.时间复杂度由O(nlog(n))降为O(n).(2)在子过程Classify中,无需进行二重循环式的比较,和求频率数组一样,只需找到当前重复体的结束结点,读取结点信息即可,结点中的后缀位置信息就是该重复体的副本分布位置.时间复杂度由O(n2)降为O(n).(3)更重要的是,加入结点信息所用的时间只是在找新叶子的父结点,parent变量是结点数组的索引号,找父结点的时间复杂度为O(1)×父结点个数.因此改进后的Ukkonen算法在构造速度方面几乎没有受到影响.4时间和空间复杂度分析在对后缀树构造算法改进之后,算法主过程RepSeeker(S,L,Fm)的第1~3步,在后缀树上查找长度为L的子串是在Hash表上进行的,所以计算频率数组时间复杂度为O(n).算法主过程RepSeeker(S,L,Fm)的时间复杂度依赖于子过程Check的时间复杂度.子过程Check是一个多重循环过程,第1层循环遍历所有频率相等且大于限定频率Fm的所有块.第2层循环用宽度为L的移动窗口对每个块进行分析.第3层循环的循环次数为当前移动窗口内子串的发生位置的频率.设频率相等块的个数为N,移动窗口可移动次数为M,窗口内子串的平均发生频率为f,那么可以看出检查过程运算次数为N×M×f,时间复杂度为O(N×M×f).分析出算法的时间复杂度为O(MN).算法在运行过程中存储边的信息到散列表中,这个表的大小一般不超过|S|×2.1.结点存储在顺序数组中,大小为|S|+1.由于对Ukkonen后缀树的适应性改进,增加了结点信息,从而加大了算法对于空间的要求.设新增结点信息平均空间需求为|X|,由于只是在分支结点上加入了结点信息,叶子结点所需空间为|M|,所以结点总的空间应为(|S|+1)×|X|+|M|×(|S|+1)/2.5实验5.1实验参数设置程序RepSeeker在MicrosoftVisualC++6.0环境上通过C++语言实现.算法取移动窗口宽度L为20,最低限制频率为3,合并重叠序列时重叠限制比例为25%.本实验测试机器为Intel3GHz,1GB内存的计算机.5.2实验结果实验使用大小不等的DNA序列作为测试对象,以识别出的重复体个数、最大重复体及其长度、重复体的归类表作为测试的结果.并与改进前的指标进行了对比.表1列出了实验结果.Page7表1重复体识别算法在后缀树改进前后的性能序列名长度限制频率X141121522613AL5938532232763AC0085831224933CU210914314333NC_0074103663543DOGHUMAN3M290001035.3结果分析基于表1的实验结果,分别从重复体识别结果和运行时间两个方面进行分析.对于重复体识别结果,从实验结果来看,改进后的后缀树对RepSeeker算法提供了强有力的支持,使其在计算速度上得到了很大程度的提高.对于长度较小的序列时间性能的提高意义不大,如DNA序列文件AC008583,运行时间都是在100s以内;而对于大序列,如DNA序列文件HUMAN3M,运行时间减少了5个小时左右.从运行时间上看,RepSeeker算法在改进了后缀树后优于改进前的算法,这也证明了算法在时间复杂度上有所改进的分析.下一步算法将在如何减少算法的空间需求上做改进,将在引入新的数据结构上做进一步的探索.6结论本文根据当前重复体识别算法中存在的问题提出了一种基于Ukkonen后缀树算法的准确重复体的快速识别算法RepSeeker.RepSeeker算法将对近似重复体和重复结构的识别提供强有力的支持,算法在快速识别重复体的同时定位了每一个重复体序列的左右边界,并把每一个重复体归入相应的类.算法无论是在计算频率、检查子重复、重复体合并以及最后的重复归类都充分运用了改进后的适应性后缀树构造算法,从而较大地提高了运行速度.实验结果表明RepSeeker算法的运算速度相对改进Ukkonen算法前的算法得到了很大的提高,是一种有效的重复体识别算法.
