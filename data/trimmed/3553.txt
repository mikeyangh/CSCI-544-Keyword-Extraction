Page1参数配对及狀-way组合覆盖算法研究黄陇1)杨宇航1)李虎2)1)(总参陆航研究所北京101121)2)(中国软件评测中心北京100044)摘要组合测试是软件测试数据生成研究的一个重要领域,其中参数配对组合测试的应用最为广泛.对常用的参数配对组合覆盖方法进行了综述分析.目前主流的配对覆盖算法AETG和IPO所存在的主要问题是在确定水平取值时,具有盲目性和随机性,从而难以控制测试用例的规模.为此提出了改进的AETG算法和IPO算法,改进算法通过对参数进行预处理以及综合考虑各因素的水平组合等手段,对测试用例的规模进行控制,采用更加完备的方法尽早确定水平取值.为验证新算法的有效性,进行了仿真实验和实际测试,结果表明,改进算法所生成的测试用例数量要少于原算法,测试用例约减效果更为明显;测试用例数与配对数之间、测试用例数与因素水平数之间存在着某些规律性的联系,分析得出了一系列相关的结论.在配对覆盖的基础上,提出了遗传算法与AETG算法相结合的n-way组合覆盖算法,证明了其时间复杂性较已有算法得到了改善.关键词组合测试;配对测试;n-way覆盖;算法1引言问题Q:在软件功能测试中,针对测试场景中的某个被测方法,当该方法中各个参数的初始取值确定后,如何进行各参数取值的组合以生成测试用例,从而驱动该方法能够执行,并达到最佳的测试效果.解决Q的核心在于选取方法参数的哪些取值组合进行实际测试,亦即如何从大量的参数数据组合中(完全组合在实际测试中通常不可行)挑选适量的具有代表性、典型性的数据组合,使得用较少的测试用例即可对被测方法进行较为全面和客观的测试.这种通过检查系统参数的取值组合来进行充分的测试就是组合测试,组合测试已被软件业公认为是一种行之有效的测试方法[1].根据观察,对于很多应用程序来说,很多错误都是由少数几个参数的相互作用导致的.例如Kuhn和Reilly分析了Mozilla浏览器的错误报告记录,发现超过70%的错误是由某两个参数的相互作用触发的[2].因此在Q中应用最为广泛的是配对组合测试,即保证任意2个参数的所有可能取值的组合至少被一个测试用例覆盖.目前,学术界从不同角度提出了一些解决该问题的方法,下面先对这些方法进行评述,然后讨论改进的AETG、IPO算法,在此基础上,进一步提出一种n-way组合覆盖算法.2常用的参数配对组合覆盖方法综述从算法设计的基本原理上看,目前常用的参数配对组合方法可以分为试验设计方法、直接搜索方法和代数方法3大类.2.1试验设计方法在试验设计(DOE)中,将方法调用中的各个参数称为因素,而将各个参数的所有可能的取值称为水平.DOE方法最早是针对硬件系统的测试而提出的[3],但同样可以将其思想应用于软件测试.(1)全面试验全面试验即对所有因素的所有水平之间的各种组合情形均进行相应的试验.对于有k个因素,每个因素有li(1ik)个取值的情况,全面试验需要∏kli个测试用例.全面试验的优点是各参数的所有i=1取值组合情况都能得到测试,可以发现任何和参数组合相关的错误.但是当k和li都较大时,所需要的测试用例的数量将会非常庞大,这对于资源有限的(2)单因素轮换试验为了减少全面试验的次数,出现了单因素轮换试验.它只考虑单个因素的不同取值的变化情况,其它因素则固定不变.此方法虽然产生的测试用例数量较少,但它存在着以下局限性:首先变化因素的选择具有随机性,且取决于人的主观判断;其次当因素个数比较多时,不能有效地覆盖那些固定因素之间的取值组合情况,而这些组合情况却是数量众多的.此方法通常适用于某一因素在执行时起决定作用的情形.(3)正交试验设计正交试验设计是一种基于正交表的试验方法[4].正交表是一个二维阵列,其行表示测试用例,每一列表示一个因素,行列交叉点表示因素的某个取值.通常用Ln(qs)表示一个等水平的正交表,其中L表示正交设计,n为测试用例数,即行数;q表示水平数;s为因素个数,即列数.例如L9(34)表示有4个因素,每个因素有3个水平,则需要安排9次试验即可.正交试验设计的优点是满足配对组合覆盖的要求,有大量已知的表可直接使用;其局限性是等概率覆盖使得测试用例的数量增多;此方法适用于水平数不多且能够构造出相应的正交表的情形.软件测试来说,通常是不可行的.(4)均匀试验设计均匀设计是由中国科学院应用数学研究所方开泰教授和中国科学院王元院士共同提出的一种试验设计方法[5].均匀设计的基本思想就是在确定试验布点时,只考虑试验点的“均匀分散”性,而不考虑其“整齐可比”性,从而大大减少了试验次数.均匀设计的试验方案是通过均匀设计表来实现的,通常表示为Un(qs),其中U表示均匀设计,n为测试用例数,即行数;q表示水平数;s为因素个数,即列数.在实施均匀设计时,首先根据因素数和水平数选择合适的均匀设计表,然后填写该表,以生成相对应的参数数据组合表.当各个因素的水平数不完全相同时,称之为混合水平的均匀设计.对于这种情形,可以采用两种方法加以解决:一是直接选用合适的混合水平均匀设计表;二是采用拟水平技术.此方法的优点是测试用例数量比较少,而其局限性是不能保证满足配对组合覆盖,并且所需要的均匀设计表可能不存在.2.2直接搜索方法(1)AETG方法AETG(AutomaticEfficientTestGenerator)[6]Page3是美国贝尔实验室的Cohen和Dalal等人提出的一种启发式两两组合覆盖(也可扩展至n维组合覆盖)测试数据生成工具.其基本思想是每次生成一个测试用例,以覆盖最多的未被覆盖的配对组合,直到覆盖所有的配对组合.因此该方法实际上是一种贪心算法.(2)IPO方法IPO(In-Parameter-Order)方法[7],是由美国北卡罗来纳大学计算机系的Lei和Tai提出的一种启发式配对组合覆盖生成算法,也是一种贪心算法.其基本思想是首先生成任意两个参数的所有配对,然后依次进行水平扩展和垂直扩展.水平扩展即每次新加入一个参数,并确定其取值;在水平扩展之后,通过垂直扩展来补充尚未被覆盖的配对组合.它与AETG的根本区别是它不是同时考虑所有参数,而是每次渐进考虑一个参数.(3)解空间树方法文献[8]提出了一种新的启发式配对组合覆盖测试数据生成方法,称之为基于解空间树模型算法.解空间树的第一层树根结点有b1个分支,分别表示参数p1的b1个取值,第2层的每个树根结点有b2个分支,分别表示第2个参数p2有b2个取值,依次类推,第n层的每个树根结点有bn个分支,分别表示第n个参数pn有bn个取值.这样从树根开始到底层叶结点的所有路径即构成了配对覆盖测试集TSn.(4)人工智能方法采用遗传算法(GA)、模拟退火算法(SAA)等人工智能方法来求解配对组合覆盖测试数据生成问题,也是近年来学术界的一个研究方向.该类方法的典型代表有:文献[9]使用模拟退火算法产生交互测试用例,其过程是首先任意选择一个初始可行的覆盖矩阵犛N×K(N为初始选择的测试用例数,K为因素个数);然后改变犛中某个元素的值,生成犛;若cost(犛)<cost(犛),则接受犛,否则按e-(cost(犛)-cost(犛))/T的概率接受犛(其中,cost()为未覆盖的n-way组合数,T为控制温度,其值缓慢变化T··=αT(0<α<1));当cost(犛)=0时,算法停止.该方法综合考虑了运算效率和运算结果之间的关系,但只对规模较小的组合覆盖问题可行,当3-way覆盖时效果即欠佳;同时初始覆盖矩阵构造困难,并且较为费时.Shiba等人[10]提出将遗传算法和蚁群算法(AntColonyAlgorithm)应用于组合覆盖测试数据生成.对于遗传算法,该文描述了编码、适应性函数、遗传操作等在组合覆盖问题中的可应用性,但并未进行详细的讨论,也没有给出具体的实现算法;对于蚁群算法,实际上是一种图论遍历方法,即每次选择启发值和生物信息值高的线路作为测试用例.2.3代数方法(1)正交矩阵方法正交矩阵方法的理论基础是拉丁方和正交拉丁方[11].对于r个n阶的正交拉丁方,可以构成一个复合矩阵(即正交矩阵),矩阵中的元素是由r个n阶方阵的对应元素构成的数组,则根据该矩阵,可以得到有r+2个参数、每个参数有n个取值的配对覆盖组合测试用例.通常将正交矩阵表示为犗犃λ(N;t,k,v)[9],该矩阵是N×k矩阵,任何N×t的子阵中t列的所有组合都出现λ次,对于软件测试而言,只需λ=1即可.也就是说,N表示组合测试用例的个数,t表示t-way覆盖,k表示参数的个数,v表示各参数的取值个数.Bose[12]最早提出了犗犃(n2;2,n+1,n)的构造方法,在此基础上,Bush[13]又进一步构造出了正交矩阵犗犃(nd;d,n+1,n).正交矩阵方法有以下局限性:(1)并不是对于所有的因素和水平组合情形,都存在正交矩阵,特别是对于存在的n阶(参数的取值个数)的正交拉丁方(最多有n-1个),通过构造正交矩阵,最多可以解决n+1(n-1+2)个参数的配对组合覆盖测试数据生成问题;(2)任两个因素的各水平组合等概率出现,这对于试验设计是必须的,但对于软件测试并不是必须的,造成了测试用例数量的增长;(3)正交矩阵的构造比较复杂,工作量大;(4)要求各参数的取值个数相同,使其不具有应用的广泛性.此方法适用于阶数(取值个数)为素数幂的情形.(2)整数线性规划方法根据运筹学的基本原理,可以采用{0,1}整数规划方法来求解配对组合覆盖问题[14-15].其基本思想是:设有k个因素,每个因素有n个取值,其测试用例总数为T=nk,分别用xi(i=1,…,T)表示;配对组合数目为T=k()2n2,构造整数线性规划表,该表共有k()2n2+1行,nk+1列.其中,令xj=1,j=0,1,…,T-1,测试用例j被选中烄xj=0,j=0,1,…,T-1,测试用例j未被选中aij=1,i=0,1,…,T-1,第i个成对组合被测试烅aij=0,i=0,1,…,T-1,第i个成对组合未被烆Page4j=0则已选择的所有测试用例为∑T-1被覆盖的次数为∑T-1标,∑T-1aijxj必须大于或等于1,即每个成对组合至少被覆盖1次.因此,就将成对组合覆盖转化为整数线性规划求解问题.其约束条件为∑T-10,1,…,T-1,目标函数为Min∑T-1该方法虽然构思较为巧妙,但实际求解时,例如有5个参数,每个参数取3个值,则求解时间就超过6.5个小时[14],因此该方法不实用.(3)基于正交表的方法日本大阪大学的Kobayashi和Tsuchiya等人[16]提出了一种基于正交表的代数方法.该方法的基本思想是通过正交表、具有块结构的表和通过近似方法构成出来的混合覆盖表等基本成分之间的交叉重叠算法来构造新的配对组合覆盖表[8].由于正交表和块结构的表都是通过有限域来构造的,因此该方法主要考虑的是当因素的取值个数d为素数幂的情形,对于不是素数幂的情况,则选择大于d且和d距离最小的素数幂做近似处理.但某些情况下,近似处理的误差是比较大的.(4)TConfig方法[13-14]加拿大渥太华大学的Williams提出了用覆盖矩阵(覆盖矩阵犆犃与正交矩阵犗犃的区别在于前者只要求各配对组合出现1次,但不要求等概率出现,而后者则需要等概率出现)方法构造满足成对覆盖要求测试用例的算法.该算法以正交矩阵为基础,采用递归构造方法,通过不断扩大因素的值来构造覆盖矩阵.TConfig方法具有代数推导的精确性,并且已有了相应的自动化工具的支撑.但该方法的局限性在于由于它使用的是添加构造块的模式,而构造块是基于正交矩阵的,因此它适用于各个因素的水平数相同的情形,对于其它情况则采取比较粗糙的近似方法.2.4小结由于配对组合覆盖测试数据生成问题是NP问题,在某些情况下只能得到近似最优解,因此需要根据实际情况灵活选择不同的方法.试验设计方法的技术基础是已经存在的正交设计表和均匀设计表,但对于很多情况仍然没有构造出相应的试验设计表,因此该方法实际应用的局限性较大.而直接搜索方法与代数方法相比较,具有以下优点:(1)灵活性强.对于增加或减少因素以及因素取值个数的变化等情况,直接搜索方法可以通过在原来求解结果的基础上进行适当调整与附加运算即可得到新解,而代数方法一般则需要依据新的参数信息重新进行计算;(2)运算简便.直接搜索方法大多是通过基础的组合数学方法即可得到解,而代数方法通常需要复杂的矩阵运算方能完成,并且计算量较大;(3)适应性广.直接搜索方法可以适用于各种因素与水平相组合的情形,但代数方法由于受到正交矩阵的限制,不具有通用性,只对某些特定类型的因素和水平情形才可解,目前对于水平为素数幂的正交矩阵有着比较好的构造方法,虽然可以通过它来生成新的覆盖矩阵,但与最小覆盖矩阵之间通常有较大的误差;(4)从实现原理上来看,直接搜索方法比代数方法更贴近于软件测试的基本思想,即用尽可能少的测试用例覆盖尽可能多的配对组合.在直接搜索方法中,AETG和IPO是两种最为经典、实际应用最为广泛的配对组合覆盖方法.相对于其他搜索方法,贪心算法的处理速度是最快的,在工业界中的实用性是最强的,并且很多贪心算法都能支持部分非经典的组合测试.那么在继承良好执行性能的前提下,如何尽可能地减少测试用例的数量,从而减少测试成本,是一个值得深入研究的问题.而AETG和IPO算法在生成测试用例时,均具有盲目性和随机性,未从整体上充分地考虑所有因素的各水平之间的组合情形,造成了对测试用例数量的控制效果不佳,并且难以得出规律性、指导性的结论.为此,本文在AETG和IPO方法的基础上,分别提出了改进的配对组合覆盖测试数据生成算法.3改进的AETG算法3.1算法的基本思想改进的AETG算法仍然属于贪心算法,但其生成参数值的策略发生了变化.原算法在依据配对组合生成参数值的过程中所存在的最大问题是具有一定的盲目性和随机性,进而影响到了测试用例的约减效果及算法的效率.每一组测试用例中首参数的选择对于该组测试用例的生成具有重要的影响,遵循贪心算法中最大覆盖的原则,应当将所有参数的各个取值进行综合考虑,得到全局最优解作为首参数,而不是随机选择,这样就可以尽早地覆盖更多的配对组合,将个别的未覆盖配对进行后续处理,能够更快地实现全配对覆盖;对于每一组测试用例而言,某个参数取值的确定,也应当将其各个水平在未覆Page5盖配对中出现的次数进行综合考查,即不仅要考虑其与已确定取值的参数的水平的组合情况,也要考虑其与未确定取值的参数的水平的组合情况,这样才能保证每一组测试用例真正实现对最多配对的覆盖.3.2改进点新AETG算法同原算法相比,主要作了3个方面的改进,如表1所示.改进点1初始时,各参数未排序,2每次随机选择参数作为3确定新参数值时,只执行3.3算法描述输入:k个参数,每个参数有li(1ik)个取值,未被输出:配对组合覆盖测试用例集PC算法:对k个参数依其li(1ik)值的大小进行降序排列,当取值个数相同时,按字典序排列//将取值个数多的参数排在前面,使其能够较快地收s=1;WhileUP≠do{Ifs==1thendo{选择序列中第一个参数p1及其一个水平值表2改进AETG算法与原算法的实验比较原AETG算法序号1k=4,l1=l2=l3=l4=32k=5,li=3(1i5)3k=5,li=6(1i5))4k=10,li=2(1i10)5k=13,li=3(1i13)6k=3,l1=l2=2,l3=37k=6,l1=2;l2=l5=3;8k=8,l1=l5=3;l2=l7=5;9k=11,l3=l5=2;l6=5;10注:k为因素个数,li(1ik)为各因素的水平数.Ifs<>1thendo{假设参数p1,…,pj的值已经确定,对于1ij,pi的取值为vi,则按照下面的方法确定pj+1的取值vj+1:首先执行向前匹配;//向前匹配将p1,p2,…,pk的一组取值作为一个元素加入UP=UP-{加入pj+1所新覆盖的配对组合集};s++;}EndwhileReturnPC.3.4实验方案与结果针对等水平和混合水平的不同情形,分别采用原AETG算法和改进的AETG算法进行了10组实验,生成了相应的测试用例,见表2.Page63.5算法分析未被覆盖的配对组合集Uncover的初始大小为|Uncover|=C2考虑最内层的循环操作,Pi(1ik)(P表示参数),确定其每个取值vj(vj∈Pi)所覆盖的Uncover中的元素的个数这一操作的时间复杂性为O(|Uncover|),因此对于一个参数Pi的取值的确定需时间O(|Uncover|×d),故在一个测试用例中,确定所有k个参数的取值的时间复杂性为O(|Uncover|×d×k),由文献[17]可知,配对组合覆盖的测试用例数的上界是-log(k(k-1)d2/2)/log(1-1/d2)+1,因此,确定参数取值操作阶段的时间复杂性为O(|Uncover|×d×k×-log(k(k-1)d2/2)/log(1-1/d2)+1).算法在执行确定参数取值操作之前,首先进行了k个参数的排序,该操作耗时O(klogk),因此改进AETG算法的总时间复杂性为O(|Uncover|×d×k×-log(k(k-1)d2/2)/log(1-1/d2)+1+klogk),即O(C2-log(k(k-1)d2/2)/log(1-1/d2)+1+klogk).另一方面,该算法生成配对组合覆盖测试用例集所依赖的是参数个数及各参数的取值个数,在实际情况中这些值都是有限的,即未被覆盖的配对组合集UP总能执行到空集,因此该算法是能终止的.4改进的IPO算法4.1算法的基本思想改进IPO算法仍然采用逐个考虑各个参数的递增策略.设有k个参数,每个参数有li(1ik)个取值,则满足配对覆盖的测试用例的下界为max(li×lj)(1i.jk),因此按照水平数将各参数进行排序,可以有效提高算法的执行效率;根据水平数最多的两个因素p1、p2建立起的配对组合测试用例集PC的基数要大于pi(i>2)的水平数,若每次加入新因素后都进行垂直扩展,则会引入大量的无关值,不利于后续因素的加入,因此应当先水平扩展至所有参数,再进行一次性垂直扩展,最大限度地减少无关值;在参数pi(1ik)的水平扩展阶段,对于pi之前的无关值,考查其与pi的配对覆盖情况,用未覆盖的配对值取代无关值;在参数pi(1ik)的垂直扩展阶段,可以将其看作是AETG算法实施的初始环境,采用改进的AETG算法可以进一步约减测试用例.4.2改进点新IPO算法同原算法相比,主要作了3个方面的改进,如表3所示.改进点原算法1初始时,各参数未排序,2针对每个参数,都进行3在垂直扩展阶段处理4.3算法描述输入:p1…pn共n个参数,每个参数的取值集合T1…Tn输出:配对组合覆盖测试用例集PC算法:对n个参数依其|Ti|(1in)值的大小进行降序排列,当取值个数相同时,按字典序排列;对于前两个参数p1,p2,建立配对组合测试用例集PC;PC={(v1,v2)|v1∈T1,v2∈T2分别是参数p1,p2的Ifn==2thenReturnPC;/依次加入新因素,只考虑水平扩展,不考虑垂直//当所有因素当加入后,进行一次性垂直扩展PC=callIPO_V(PC,UP);//垂直扩展FunctionIPO_H(PC,pi){UP={pi和p1,p2…pi-1的各参数取值所构成的配s=min(|Ti|,|PC|);forj=1tosdo{Ifs==|PC|thenReturn;Page7}EndforUP=UP-{扩展后所新覆盖的配对组合};//当新加入参数pi的各水平值都已追加到|PC|个测//试用例后,对于pi前面的元素pj(1ji)中的无//关值做处理Ifpi是最后一个参数,then用pj值域中的随机值代Elseif(pj.w,pi.u)出现在UP中thenEndifReturn(PC,UP);EndifEndfunction.FunctionIPO_V(PC,UP){PC=;表4改进IPO算法与原算法的实验比较序号1n=4,|Ti|=7(1i4)2n=7,|Ti|=4(1i7)3n=7,|Ti|=2(1i7)4n=8,|Ti|=2(1i8)5n=10,|Ti|=3(1i10)6n=3,|T1|=|T2|=2,|T3|=37n=6,|T1|=|T6|=3,|T2|=2;|T3|=5;8n=6,|T1|=|T6|=3,|T2|=|T3|=4;9n=7,|T1|=|T6|=5,|T2|=|T5|=3;10n=8,|T1|=2,|T2|=4;|T3|=|T4|=3;配对总数29433684112405162492385071674.5算法分析未被覆盖的配对组合集Uncover的初始大小为|Uncover|=C2在水平扩展阶段,产生的测试用例数为d2个,Pi(3in)(P表示参数),确定Pi取值这一操作最多可耗时O(|Uncover|×(d2-1))(最多需进行PC=PC∪PC;Endfunction.4.4实验方案与结果针对等水平和混合水平的不同实例,分别采用原IPO算法和改进的IPO算法,进行了10组实验,生成了相应的测试用例,见表4.d2-1次不同取值能覆盖Uncover中元素个数的比较).因此对于k个参数而言,其时间复杂性为O(|Uncover|×(d2-1)×(n-2)),在垂直扩展阶段,需要新生成的测试用例数量最多为-log(n(n-1)d2/2)/log(1-1/d2)+1-d2个,因此确定参数取值操作阶段的时间复杂性为O(|Uncover|×d×Page8n×(-log(n(n-1)d2/2)/log(1-1/d2)+1-d2)).算法在执行确定参数取值操作之前,首先进行了n个参数的排序,该操作耗时O(nlogn),因此改进的IPO算法的总时间复杂性为O(|Uncover|×(d2-1)×(n-2)+|Uncover|×d×n×(-log(n(n-1)d2/2)/log(1-1/d2)+1-d2)+nlogn),即nd2(d2n-2d2-k+2+dn)×(-log(n(n-1)O(C2d2/2)/log(1-1/d2)+1-d2)+nlogn).另一方面,该算法生成配对组合覆盖测试用例集所依赖的是参数个数及各参数的取值个数,在实际情况中这些值都是有限的,即在水平扩展和垂直扩展阶段所执行的循环都是可以终止的,因此该算法是能终止的.5实验结果分析及结论通过以上实验可以直观地看出,改进的AETG和IPO算法所生成的测试用例的数量在总体上要优于原算法,虽然在某些情形下约减的测试用例数量不是很多,但对于软件测试而言,即使约简数量很少的测试用例,对测试成本的节约和效率的提高也具有不可忽视的作用[18].同时,由于改进算法仍然属于贪心算法,其实际执行性能的优越性得到了保证.即改进算法在保持原算法良好执行性能的基础上,提高了计算结果的精确度.另一方面,改进AETG算法直到未被覆盖配对组合集为空才停止执行,而改进IPO算法在最终的垂直扩展阶段也直到未被覆盖配对组合集为空才停止执行,因此两种算法都保证了所生成的测试用例实现了对所有配对组合的覆盖,即改进算法的测试覆盖充分性与原算法是等价的,因此其揭示错误的能力也保持等价.5.1测试用例数量约减效果根据上述实验结果,得到两个改进算法与原算法对于测试用例数量的约减情况,如图1和图2所示.图1改进AETG算法与原算法测试用例数量比较图2改进IPO算法与原算法测试用例数量比较改进AETG算法在等水平和非等水平两种情形对测试用例的约减效果见图3和图4.图4非等水平时改进AETG算法的约减效果改进IPO算法在等水平和非等水平两种情形对测试用例的约减效果见图5和图6.Page9图6非等水平时改进IPO算法的约减效果通过分析,可以得出下述结论:结论1.对于AETG算法,当满足等水平情形时,水平数越多,则改进算法与原算法相比对测试用例数量的约减效果越明显,因素数越多,约减效果越明显;当满足非等水平时,因素数越多,则约减效果越明显.结论2.对于IPO算法,当满足等水平情形时,因素数越多,约减效果越明显,水平数越少,则约减效果越明显:当满足非等水平时,各因素水平相差越小,或各因素的水平总数越多,则约减效果越明显,因素数越多,约减效果越明显.5.2测试用例数与配对总数的关系通过对图7~10进行分析,可以得出如下结论:结论3.对于AETG算法,当满足等水平情形时,在一般情况下,配对总数增长,则测试用例的数量也增长,二者成正比关系;当满足非等水平时,测试用例数与配对总数无固定的正反比关系,测试用例的数量关键取决于因素水平的个数.结论4.对于IPO算法,当满足等水平情形时,测试用例数与配对总数无固定的正反比关系,测试用例的数量关键取决于因素水平的个数;当满足非等水平时,在一般情况下,配对总数增长,则测试用例的数量也增长,二者成正比关系.5.3测试用例数与因素数水平数的关系依据图1~图6,从另一个角度进行分析,即可得到改进算法生成的测试用例数与不同因素数水平数组合之间的关系,有以下结论:结论5.对于AETG算法,当满足等水平情形时,首先考虑水平数,水平数越少,则生成的测试用例越少,当水平数相同时,因素数越少,则测试用例Page10越少;当满足非等水平时,不同水平的个数越少(即越接近于等水平),测试用例越少,当不同水平的个数相同时,因素数越多,则测试用例越多.结论6.对于IPO算法,当满足等水平情形时,水平数增多,则生成的测试用例明显增多,当因素数相同时,水平数微小变化,则测试用例将大幅增长,而当水平数相同时,因素数小幅增加,则测试用例也小幅增加;当满足非等水平时,在一般情形下,各因素的水平总数越多,则测试用例也越多.6实例验证在对某遥控软件[19]的测试过程中,分别应用原AETG、IPO算法以及改进的AETG和IPO算法生成了测试用例.该软件的定时开功能的执行需要3个参数:时钟类型、受控设备类型以及开启时间.其中各参数的类型和取值如下:时钟类型:字符型,取值为系统时钟和自定义时钟;受控设备类型:字符型,取值为电器设备、工控设备、包装设备、检测设备和照明设备;开启时间:数值型,取值为10s,99s,100s,101s,600s.上述3个参数的配对总数为45,使用原AETG方法生成了28个测试用例,而应用改进的AETG算法则只需要25个测试用例;虽然使用原IPO方法和改进的IPO算法均生成了25个测试用例,但由于后者无需进行垂直扩展,因此生成测试用例的速度要优于前者.使用改进算法生成的测试用例进行实际测试,取得了较好的效果.值得指出的是,改进的AETG和IPO算法对于参数配对组合覆盖测试而言,各有其不同的适用场合.改进的AETG算法适用于参数个数比较稳定的情形,而对于参数个数经常变化的情形,则使用改进的IPO算法效果较好.7犖-way组合覆盖算法按照Nair等人[20]的观点,对于规模较小的问题,配对覆盖就能够发现大多数错误,并且AETG的测试实践也给予了证明[21].Dunietz等人①[22]认为3-way覆盖可以有效地进行代码块覆盖,而更高阶的覆盖可以实现代码路径的覆盖.因此,在前面分析了配对组合覆盖的基础上,有必要进一步讨论n-way组合覆盖测试数据生成问题.目前针对n-way组合覆盖算法的研究大多是以现有的配对组合覆盖算法为基础,将其进行扩展,以推广到n-way的情形.但随着参数个数的增多,其算法的时间复杂性也急剧增加.Williams[14]在其博士论文中提出可采用正交阵列犗犃(ρd,n+1,n,d)作为初始构造块,通过水平和垂直方向的矩阵连接运算来建立d-way的覆盖测试用例矩阵.但当使用犗犃(8,3,2,3)时,实验结果表明丢失了72个3-way覆盖测试用例,造成误差较大.因此该方法需要进一步完善.文献[8]基于AETG和IPO方法,分别将其推广到n-way组合覆盖的情形,提出了两种n-way组合覆盖测试数据生成算法,并进行了实验分析.但是随着维数n的增长,该文所提出的两种算法生成测试用例所耗费的时间也迅速的增长,因此需要进一步研究时间复杂性更低的新算法.Ahmed[22]在其博士论文中系统地讨论了DOE方法在软件测试中的应用,但该文未解决n-way参数交互及混合水平参数组合的问题.通过分析可以看出,目前n-way组合覆盖算法存在的主要问题是时间复杂性过高,因此在保证n-way组合覆盖目标的前提下,需要降低算法的时间复杂性.对于n-way覆盖问题,从另一个角度,我们可以将k个参数的不同取值组合看作是对k个数值的一个编码排序问题,因此可以借鉴遗传算法的基本思想来解决该问题.由于n-way覆盖问题是一个NPC问题[23],因此在使用遗传算法时,为了提高搜索速度和精度,还需要采用启发式方法加以补充.为此,本文提出了一种将遗传算法和AETG方法相结合的算法,较好地解决了n-way覆盖测试数据生成问题,并通过与文献[8]中的方法进行比较,说明新方法的时间复杂性得到了改善.7.1算法描述输入:设有k个参数,P1,P2,…,Pi(1ik),每个参输出:n-way组合覆盖测试用例集T算法:确定初始种群规模N=d,形式为NS=SS…S(1Sd),Pi=S(1ik);①DunietzIS,EhrlichWK,SzablakBD,MallowsCL,Ian-Page11将d个染色体放入T中;初始化染色体组规模g=d;GA:Whileg<dndo{//dn是使用确定性遗传算法生EndwhileAETG:WhileUncover<>do{Endwhile7.2时间复杂性分析文献[8]中提出的n-way覆盖算法,是将AETG算法由配对覆盖扩展而成的.下面将本文所提n-way覆盖算法(GA-AETG)的时间复杂性(记为O(G))与文献[8]中n-way覆盖算法的时间复杂性(记为O(A))进行分析比较.Uncover=Cn在GA-AETG中,通过先执行GA算法,使×d2n+1×k.Uncover得到减少:继续执行AETG过程后,O(G)为O(G)=(Uncover)2×k×d=[Cn则时间复杂性减少量为O(A)-O(G)=(Cnd3)操作,造成新增加的时间复杂性为只要证明O(G)>O(G)即可.变异操作均要进行两个染色体适应值的比较).另一方面,由于在GA-AETG中首先执行GAO(G)=Cn因为n2,所以O(A)-O(G)(Cn下面采用数学归纳法加以证明.当n=2时:O(G)=(C2因为k2,显然有O(G)>O(G).设当n=p时,有O(G)>O(G),则当n=p+1时,由于(Cp所以,Cp(p+1)Cp+1(p+1)Cp+12d2p×(p+1)d3Cp+1kkd由于要保证对任意随机变化的d,k,p均成立,因此必有Cp+1Page12即Cp+1有(Cp+1即O(G)>O(G)得证.通过以上分析可以看出,本文所提n-way覆盖算法(GA-AETG)在满足参数n-way组合覆盖的基础上,其时间复杂性较文献[8]中算法的时间复杂性得到了优化与改善.8结束语本文首先对常用的参数配对组合覆盖方法进行了归纳与整理,分析比较了各种方法的优缺点及使用时机,用于指导实际的组合测试工作;对AETG算法和IPO算法分别进行了改进,实验结果表明新算法所生成的测试用例的数量要优于原有算法,即在保持原算法良好执行性能的基础上,提高了计算结果的精确度;基于实验结果,分析了测试用例数与配对组合总数、测试用例数与因素水平数之间存在的联系;在配对组合覆盖的基础上,进一步提出了基于遗传算法和AETG的n-way覆盖算法,证明了其时间复杂性较已有算法得到了改善.需要进一步研究的问题包括:考虑参数之间具有相互作用的情形,如何生成组合测试用例;开发相应的自动化组合测试工具等.
