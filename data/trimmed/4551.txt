Page1一种高效率的实时协同编辑中的意图保持操作转换算法1)(武汉大学计算机学院武汉430072)2)(软件工程国家重点实验室武汉430072)摘要作为一类高级分布式系统,实时协同编辑系统允许不同地点的用户同时编辑共享文档,具有高响应性和高并发性的特点.操作转换(OperationalTransformation,OT)算法能够保留所有用户操作的效果并维护数据的一致性,是协同编辑系统首选的并发控制方法.为了提高远程操作的响应时间,文中提出了一种意图保持的OT算法(MergingOperationsbasedOperationalTransformation,MOOT).该算法基于这样一个事实,大多数情况下,协同编辑中插入操作的数量明显多于删除操作.因此,MOOT构造了一种优化的操作历史结构,即删除操作排在插入操作前面,避免算法的计算时间依赖于大多数操作.更进一步,MOOT在重构过程中移除无效操作,有效的压缩了操作历史的大小.为了验证算法的有效性,在不同插入比例情况下,将MOOT算法与当前性能最优的ABT算法进行了对比实验.实验结果表明,MOOT算法具有更高的计算效率,在合理的比例情况下,其计算时间大约是ABT算法的计算时间的十分之一.关键词实时协同编辑;并发控制;操作转换;社交网络1引言2013年图灵奖得主LeslieLamport①的主要成就来源于1978年发表的一篇关于分布式系统的论文[1].该篇论文是计算机科学史上引用率最高的论文之一(oneofthemostcitedinthehistoryofcomputerscience).作为分布式系统的进一步发展,实时协同工作系统在继承了Lamport事件关系的基础上,所演化出的操作转换(OperationalTrans-formation,OT)算法吸引了相关学者的大量的研究.OT作为一种乐观并发控制算法,被广泛用于支持纯文本②、Word和PowerPoint[2-3]、Spreadsheet[4]、2D图像[5]、2D和3D图形[6-7]以及CAD[8-10]的协同编辑工作.随着移动计算、云计算、大数据的发展,OT算法的性能逐渐成为关注的焦点.Shao等人[11]指出实现意图保持且经过严格证明的ABT算法(Admissibility-BasedTransformation)在计算性能上优于其他的OT算法.基于ABT算法框架[12]、支持String操作的ABST[13],异步协同的ABTS[11]以及支持anyundo的ABTU[14]等算法相继被提出.ABT算法维护特殊的操作历史HB(HistoryBuffer),即插入操作在删除操作之前,避免了删除操作对插入操作的影响,很自然地保持了操作对象之间的位置关系.与已有的OT算法相比,ABT算法不仅能够实现意图保持而且具有更高的计算效率.但是,ABT算法的计算时间严重依赖于插入操作的数量.相关文献表明[15],在协同编辑中插入操作的数量远远多于删除操作,插入操作占总操作数80%是一个比较合理(reasonable)的比例.因此,ABT算法重构的HB结构并非是最合理的.另一方面,协同编辑过程中存在着许多无效操作对(插入的对象随后又被删除),将它们从HB中移除不仅不会影响其他操作,而且能够减少不必要的计算.基于以上两点考虑,本文提出了一种合并无效操作的MOOT算法(MergingOperationsBasedonOperationalTransformation).本文第2节为OT相关的研究工作;第3节为OT的基本模型与算法分析;第4节为MOOT算法的详细描述;第5节为MOOT算法的实例分析;第6节为实验研究;第7节为全文总结.2相关工作Ellis等人[16]在1989年首次提出操作转换的概念,建立了OT算法的基本模型.第一个OT算法(dOPT)被成功应用到了协同编辑系统Grove.基于dOPT算法,杨光信等人[17]提出了面向对象数据模型的并发控制方法.Ressel等人[18]发现了dOPT的“puzzle”(某些场景下各个站点的结果不一致)并提出转换函数正确性的充分必要条件(TP1和TP2).之后,不断有新的算法被提出,尽管声称能够满足TP1和TP2,但随后都被其他算法证明存在“puzzle”.设计满足TP2条件的转换函数是非常困难的.2014年Randolph等人[19]指出,非全序OT算法的转换函数都不能同时满足TP1和TP2条件.经过自动机合成的正确转换函数需要为操作添加额外的信息.大部分OT算法通过控制过程(也称作集成过程)摆脱了TP2对转换函数的限制.这类算法不需要转换函数在所有情况下都能获得正确的结果.控制过程负责调度远程操作与操作历史中的操作进行转换,根据操作的全局顺序来产生唯一的转换路径.SOCT4[20]利用集中式的sequencer产生全局有序的操作序列,GOTO[21]结合状态向量和站点优先级来判断操作之间的全序关系,TIBOT[22]定义的全序要求各个站点的逻辑时钟是同步的.每一个操作在所有站点进行转换的操作序列都是相同的,最终得到的操作历史也是相同的.控制过程还有另外一个作用,就是处理偏并发操作的集成.在协同编辑环境下,并发操作有可能①②Page3产生于不同的文档状态,导致操作对象的位置不具有可比性[23].因此,直接调用转换函数可能会导致结果不一致的情况发生.GOT[24]算法补充了基本操作转换的概念,提出了包含转换IT(InclusiveTransformation)的逆过程排除转换ET(ExclusiveTransformation).ET能够将不同文档状态下的操作转换成相同状态下的操作.交换两个操作的执行顺序是先调用ET然后调用IT,这个过程被封装为SWAP函数.Suleiman等人[25]提出了前向转换FT(ForwardTransposition)和后向转换BT(BackwardTransposition)的概念.通过文献[26]的分析,FT和BT本质上分别等价于IT和SWAP.SOCT2[25]的控制过程接收到远程操作后,将站点的操作历史分类排列,因操作在前,并发操作在后,并发操作序列是需要进行转换的.该排列被大多数OT算法用来寻找并发操作集.Sun等人认为转换函数和控制过程是松散耦合的.转换函数定义操作之间的互相转换,与具体的应用相关,而控制过程负责调度远程操作与HB中的操作进行转换,是独立于具体应用的.因此,Sun等人[3,27]将控制过程封装成通用协同引擎GCE(GenericCollaborativeEngine),并应用到单用户程序向多用户的透明转换.意图保持是一种更加严格的一致性.Sun等人[28]最早提出OT算法不仅要实现结果一致性,而且要保证最终的结果反应了操作的意图,即意图保持.然而意图的定义一直是模糊的.Li等人[29-30]认为意图保持包含了结果一致,并明确的将操作的意图定义成操作作用对象之间的位置关系.全序的OT算法在静默状态(协同会话结束)的结果依赖于操作的全序关系,不一定能够保持操作的意图.TTF[31]利用分布式系统中的墓碑(Tombstone)概念,保留被删除的字符,使得对插入操作的转换具有位置单调递增的性质,能够保持操作对象之间的前后关系.TTF需要在站点同时维护物理视图和逻辑视图,物理视图保存了逻辑视图中被删除的对象,用户与逻辑视图进行交互,而待转换的操作都是基于物理视图的.这种方法的空间消耗比较大,并且视图之间的转换也需要耗费大量计算时间.LBT[32]为协同编辑中的所有对象定义全局顺序,但是从偏序推演到全序的过程需要花费大量的计算时间和空间.ABT在所有站点维护插入在前删除在后的HB结构,避免了删除操作对插入操作的影响,简化了意图保持的实现过程.在实时协同编辑中,可选的乐观并发控制算法还包括CRDT(CommutativeReplicatedDataType)[33-35].CRDT通过为协同编辑过程中出现的每一个对象定义全局有序并且唯一的标识,实现操作之间的可交换性,最终确保结果一致.与CRDT相比,意图保持的OT实现了更强的一致性,结果更接近用户的实际意图.目前,CRDT方法还没有得到广泛的实际应用.文献[36-37]提供了ABT算法与其他OT算法在集成远程操作时的性能比较.实验结果表明,ABT算法是当前效率最高的操作转换算法.然而,ABT重构的操作历史是否是最优的,值得商榷.3OT基本模型与算法分析OT算法从协同编辑系统中抽象出两个元操作(插入、删除),操作的对象是线性排列的.OT算法能够推广到其他具有复杂结构的协同系统[38].操作之间的先后关系建立在Lamport定义的“happened-before”理论基础之上.站点执行的操作都被保存在HB中.操作转换的基本思想是本地操作立即执行,远程操作经过转换之后再执行,各个站点按照不同的顺序执行操作之后获得相同的结果.定义1.因果关系.给定任意两个分别位于站点i和站点j上的操作Oa和Ob,称Oa和Ob存在因果关系(记作Oa→Ob),当且仅当Oa和Ob满足下列3个条件之一:(1)i=j并且操作Oa发生在Ob之前;(2)i≠j并且操作Oa在站点j的执行先于操作Ob的产生;(3)存在操作Ox,并且有Oa→Ox和Ox→Ob.定义2.并发关系.给定任意两个操作Oa和Ob,称Oa和Ob存在并发关系(记作Oa‖Ob),当且仅当Oa和Ob既不满足Oa→Ob,也不满足Ob→Oa.根据定义1、2,图1(a)中操作o1与o2是并发关系,图1(c)中o1与o2是因果关系.每个操作都会携带状态向量犛犞(StateVector)的信息,用来判断操作之间的关系.犛犞是一个长度固定的向量,长度等于协同站点的数目,其中每个分量对应该站点已执行操作的数目.如果操作o1来自站点i,o2来自站点j,并且犛犞o1Page4为了方便讨论,共享的文档通常被看作是字符的集合,字符串(起始位置为0).协同编辑中的两个基本操作:ins(p,c)表示在位置p插入字符c;del(p)表示删除位置p的字符.每个站点对应一位用户.图2解释了操作转换的基本思想.两个用户共同编辑文档(初始为“abc”),站点1发起操作o1=ins(2,d),站点2同时发起操作o2=del(1).本地产生的操作都会被立刻执行,然后广播给其他站点.其中,犛犞o1=[00]、犛犞o2=[00],o1‖o2.当站点2接收到站点1的插入操作时,由于已经删除了b,操作o1被转换到位置p=1执行.同理,当站点1接收到站点2的操作时,由于插入的字符d并没有移动字符b的位置,所以仍然执行del(1).最终,两个站点都获得了一致的结果.Ressel等人[18]提出了OT算法的充分必要条件TP1和TP2,分别对应图1(a)和图1(b)的场景.TP1确保两个并发操作o1‖o2,先执行o1再执行o2的结果等于先执行o2再执行o1的结果.TP2确保3个并发操作o1‖o2‖o3,o3对[o2o1]和[o1o2]转换之后得到相同的形式,其中[o2o1]和[o1o2]的执行效果相同.定义3.偏并发关系.当两个并发操作产生于不同的文档状态时,称这两个操作是偏并发关系.操作的位置p都是相对于某个文档状态的,不同文档状态下的p不具有可比性.站点产生操作o时的文档状态称作o的定义状态,也称操作上下文(operationcontext)[39],记为C(o).文档状态由从原始状态到当前状态所执行的操作序列来表示.在图1(c)中,C(o3)=[]、C(o2)=[o1]并且o2‖o3,因此o2与o3是偏并发的关系.假设o1=ins(2,a)、o2=ins(3,b)、o3=del(2),o3对[o1o2]转换之后得到o3=del(4),o1对o3转换之后得到o1=ins(2,a).由于C(o2)≠C(o3),o2对o3直接转换之后得到o2=ins(2,b),[o1o2o3]≠[o3o1o2],造成了不一致的结果.可以看出,偏并发操作之间不能直接进行转换.定义4.等价操作集合.从同一文档状态出发,执行两个不同操作集合之后得到相同的状态,它们被称作等价操作集合.在接收到所有操作之后,尽管每个站点执行了不同的操作序列,但是满足TP1和TP2条件的转换函数能够保证所有站点已执行的操作集是等价的.另外,控制过程也会根据已执行的操作构造等价的操作历史.3.1转换函数OT算法需要定义元操作之间的互相转换,称作包含转换函数IT.按照已经建立的符号,对于任何一个操作o,o.t表示操作的类型(插入、删除),o.c表示操作的作用字符,o.p表示操作的位置,o.id表示产生该操作的站点标识,o.num表示该操作是站点的第num个操作.操作转换只会改变o.p的值,其他属性保持不变.IT(o1,o2)要求o1和o2是定义在相同文档状态下的并发操作,转换之后C(o1)=C(o2)+[o2].为了处理偏并发操作,OT算法定义了IT的逆过程排除转换函数ET,目的是将在不同状态下产生的操作转换到相同状态下.函数1、2给出了常见的转换函数的具体定义.代表空操作,不产生任何实际效果.函数1.IT(o1,o2):o1.1.o12.IFo1.p>o2.p3.IFo2.t=ins4.o1.p··=o1.p+1;5.ELSE6.o1.p··=o1.p-1;7.ENDIF8.ELSIFo1.p=o2.p9.IFo1.t=o2.t=inso1.id>o2.id10.o1.p··=o1.p+1;11.ELSIFo1.t=delo2.t=ins12.o1.p··=o1.p+1;13.ELSIFo1.t=o2.t=del14.o115.ENDIF16.ENDIF17.RETURNo1;函数2给出的ET的定义并没有包括所有的情况.假如o1=ins(p+1,c)、o2=ins(p,c)、o3=del(p),那么IT(o1,o3)=IT(o2,o3)=ins(p,c).可Page5以看出,IT不是单射函数,所以ET并不能满足可逆的要求.这种情况下,只有在调用IT(o1,o3)之前记录o1的位置信息,ET(o1,o3)时才会返回o1.关于ET和IT的可逆性将在4.3节进行详细讨论.SWAP函数通过先调用ET(o1,o2)得到o1,再调用IT(o2,o1)得到o2,实现交换操作的执行顺序,[o2o1]=[o1o2].函数2.ET(o1,o2):o1.1.o12.IFo1.p>o2.p3.IFo2.t=ins4.o1.p··=o1.p-1;5.ELSE6.o1.p··=o1.p+1;7.ENDIF8.ELSIFo1.p=o2.p9.IFo1.t=o2.t=del10.o1.p··=o1.p+1;11.ENDIF12.ENDIF13.RETURNo1;3.2控制过程控制过程负责调度远程操作与站点HB中的操作进行转换.如果远程操作o的因操作还未被接收,则将该操作加入到等待队列中,直到发生在o之前的所有操作都已接收,o才会被控制过程集成到HB中.只有操作上下文相同的操作才能通过操作转换获得可交换执行.因此,控制过程的首要任务是寻找远程操作o正确的操作上下文环境.当站点调用控制过程集成操作o时,显然接收站点已经将o所有的因操作集成到了HB中.如果能够将o的因操作和并发操作区分开来,那么因操作集合就等价于C(o).然后,对并发操作逐个进行包含转换,将操作的定义状态递增到当前的文档状态,即可获得该操作在远程站点的执行形式.具体而言,假如两个站点的操作历史如下:站点1.H1=[o1ao1bo1c];站点2.H2=[o2ao1ao2bo1bo2c],站点2接收到操作o1c.C(o1c)=[o1ao1b],而C(o2a)=[],不能直接调用IT(o1c,o2a).如果站点2的H2=[o1ao1bo2ao2bo2c],C(o1c)=C(o2a),o1c=IT(o1c,o2a)并且C(o1c)=C(o2b).依此类推,o1c对[o2ao2bo2c]转换之后等同于当前文档状态下产生的操作.关键的步骤在于构造H2的等价操作集合H2.Suleiman等人[25]设计了Separate函数,负责把HB重构成因操作在前并发操作在后.具体做法:从左到右扫描站点操作历史H并用l记录当前访问的最后一个因操作在H中的位置,如果H[i]是操作o的因操作,则将操作H[i]交换到H[l+1]所在的位置;如果H[i]是o的并发操作,则跳过当前位置;遍历结束之后,H[0:l]即为操作o的因操作.ITSQ函数是对单个操作转换的封装,表示操作o对操作序列sq进行包含转换.图3描述了Suleiman等人的HB结构.函数3.Separate(H,o):l.1.l··=-1;2.FORi··=0upto|H|-1//|H|表示H中操作的3.oi4.IF犛犞o5.FORj··=idowntol+2do6.SWAP(H[j],H[j-1]);7.ENDFOR;8.l··=l+1;9.ENDIF;10.ENDFOR;11.RETURNl;从以上的分析可以看出,OT算法集成远程操作的性能瓶颈在于Separate函数,找出远程操作的并发操作集Hc需要耗费O(|H|2)的计算时间.函数4.ITSQ(o,sq):o.1.o··=o;2.FORi··=0upto|sq|-13.o··=IT(o,sq[i]);4.IFo=//如果o是空操作5.BREAK;6.ENDIF;7.ENDFOR;8.RETURNo;Page63.3一致性模型协同编辑系统的一致性模型定义为下面的3个条件:(1)因果保持.如果o1→o2,则在所有站点o1都在o2之前执行.(2)结果一致.当产生的所有操作在每个站点执行之后,所有的站点得到相同的结果.(3)意图保持[28].对于任何一个操作o,在远程站点执行的效果与该操作在本地站点执行的效果相同,且o的执行不改变并发操作的效果.意图保持能够尽量保证最终的结果符合用户的意愿.由于Sun等人[28]的意图定义比较模糊,Li等人[29]将操作的意图定义成操作作用对象之间的位置关系.假如从全局观察所有站点执行的操作,作用对象之间形成了全序的位置关系,遵循这种关系的操作也就意味着操作意图的保持.图4描述了3个站点的协同过程.在图4(b)~(e)中,有向边的起点所代表的字符在前,终点代表的字符在后.图4(a)中,初始位置关系就是初始文档中字符的先后关系,所有站点都是一致的.在各个站点的本地操作执行之后,y和x之间的位置关系就确定了.随着远程操作的执行,之前建立的位置关系可能被破坏.根据图4(c)能够推导出y在x前面,而图4(d)中加入远程操作之后,x到y有了通路,在图中形成了环路,违背了已建立的位置关系.图4(e)给出了意图保持的正确结果.如果随机定义图4(a)中3个操作之间的全局顺序,所有站点都能得到一致的结果.不同的顺序将产生不同的结果axyc或者ayxc.然而Sun等人认为在结果一致的前提下,两种结果都能保持意图.4MOOT算法协同编辑环境中存在大量的无效操作,即插入某个对象之后,这个对象又被随后的操作删除.这样的一对插入删除操作不会改变文档状态,合并的效果等同于空操作.如果移除HB中的无效操作,能够减少操作历史中的操作数目,从而减少在集成远程操作时所耗费的计算时间.ABT算法构造了特殊的操作历史结构,获得了更高的计算效率.然而站点HB的等价操作集合并非是唯一的,与ABT相比,MOOT算法提出了一种更优的HB结构.4.1HB排列结构在没有使用全序的OT算法中,操作历史中的操作按照站点的执行顺序排列.在集成远程操作时,首先调用Separate函数划分出并发操作集Hc,然后调用ITSQ函数对Hc进行包含转换,总共花费计算时间O(|H|2+|Hc|).非全序OT算法的HB中的操作是按照操作的全序顺序排列的.由于并发操作之间并没有自然的先后关系,所以全序的定义依赖于人工干预,并且需要兼容因果关系.站点可以按照全局顺序接收操作,而这种方式容易造成比较大的延时.站点也可以按照因果顺序接收,如果违背了全局顺序则利用Undo/Do/Redo的模式维护全序的HB结构,这种方法需要大量的重复计算,效率非常低.ABT算法提出了一种特殊的排列结构,即插入操作在前删除操作在后,记H=Hi·Hd.为了讨论方便,将这种排列结构称作IDHB.在集成本地操作时,产生的操作o被立即执行.然后,调用ET排除删除操作的影响得到o,并广播o到其他远程站点.同时,为了继续维护IDHB这种结构,如果o是插入操作,则将o添加到Hi中;如果o是删除操作,则将o添加到Hd中.在集成远程操作o时,首先调用Separate(o,Hi)将插入操作集Hi划分成因操作集Hih和并发操作集Hic.操作o对Hic进行包含转换得到o,再对Hd进行包含转换得到o,o就是远程操作在本站点的执行形式.当o是删除操作时,将o添加到Hd中,时间复杂度为O(|Hi|2+|Hic|+|Hd|);当o是插入操作时,将o与Hd中的每个操作进行交换,最终将o添加到Hi中,耗费计算时间O(|Hi|2+|Hic|+2|Hd|).可以看出ABT算法在集成远程操作的计算时间主要取决于插入操作集的大小.Page7在编辑文档时,插入操作的数量明显多于删除操作的数量.因此,MOOT算法构造了删除操作在前、插入操作在后的DIHB(Delete-InsertHB)结构,使得算法集成远程操作的计算时间取决于较小的操作集.4.2意图保持尽管HB可以重构成任何等价操作集合,但并不是所有的结构都能遵循一致性模型.2014年Sun等人[40]穷举了造成OT算法不能满足意图保持的puzzle,得出的结论是所有的puzzle都源自于一组特殊的操作位置关系(o1=ins(p+1,c1)、o2=del(p)、o3=ins(p,c2)并且o1‖o2‖o3).因此,有必要分析在这种特殊情况下,DIHB能否实现意图保持.图5描述了在这种特殊的场景下,DIHB维护数据一致性的过程.假设在同一个位置插入字符,站点优先级小的操作位置p保持不变,优先级大的操作位置p加1(site1<site3).图5中,站点1和站点2的操作历史都是相同,最终的结果也是相同的,即满足了Sun等人提出的意图保持条件,但不符合Li等人提出的操作位置关系的保持.按照作用关系图,可以判断y在x前面.在站点2,由于删除操作会对插入操作的位置造成影响,导致原本不在相同位置的插入操作需要在同一个位置进行比较,经过站点优先级比较之后,x出现在了y的前面,形成了环路.因此,要想保持插入对象之间的位置关系,插入操作需要保存在位置p之前所执行的删除操作的信息.利用Randolph等人[19]提出的满足TP1和TP2条件的包含转换函数,可以实现Li等人提出的意图保持标准.插入操作添加属性nd(numberofdeletedoperations),记录在位置p之前执行的删除操作的数目,相当于保持了插入操作之间的位置关系.如果两个相同位置的插入操作进行转换,首先比较nd的大小,nd大的操作位置加1而nd小的操作位置不变,其次再比较站点优先级.该方法在TTF[31]算法中已经证明能够保持作用对象之间的位置关系.在转换过程中,nd也会根据删除操作而变化.给定操作o1=ins(p,c,nd,id)和o2=del(p),如果o1.p>o2.p,则o1=IT(o1,o2)并且o1.nd加1.在图6中,由于nd属性的引入,DIHB结构能够保持作用对象之间的位置关系.在站点2,站点1的操作ins(2,x,0)和站点3的操作ins(1,y,0)对del(1)进行转包含转换之后都变成了在位置p=1上的操作,通过比较nd,可以判断出y应该在x前面,站点3的操作在站点2按照原始形式执行.4.3ET和IT的可逆性重构等价操作历史依赖操作的可交换性.根据3.1节的描述,当o1.t=ins、o2.t=del且o1‖o2时,IT(o1,o2)不是可逆的.然而,MOOT算法并不会在这种情况下调用ET(o1,o2).维护DIHB结构不需要交换插入操作到删除操作的前面,因此并发操作之间具有可交换性.当o1和o2是因果关系的时候,ET也不一定是可逆的.例如,来自同一个站点的两个操作o1=ins(1,a)、o2=ins(2,b),o2=ET(o2,o1)=ins(1,b),再调用IT(o2,o1)=ins(1,b)≠o2.根据总结,只有当同时出现以下情况时,(1)o1.t=o2.t=ins;(2)o1→o2;(3)o2.p=o1.p‖o2.p=o1.p+1;ET(o2,o1)不是可逆的,记ET返回false.MOOT算法不会向前交换HB中两个插入操作的位置,因此除去上述情况的因果操作之间也具有可交换性.Page8从上面的分析可以看出,当HB中两个相邻的插入操作具有特殊位置关系时,ET不是可逆的.文献[41]指出这种关系在远程站点依然成立.如果已知操作位置的间距,很容易根据其中一个操作推导出另外一个操作.例如,已知ET(o1,o2)=false并且o1.p-o2.p=0,那么o1在远程站点的HB也位于o2之后,并且o1.p=o2.p.4.4压缩策略DIHB结构能够方便地识别出无效操作对.在重构HB的过程中,需要将删除操作交换到插入操作的前面.如果操作o1删除的对象就是另外一个操作o2插入的对象时,那么操作o1依赖于o2的存在,无法将o1交换到o2之前执行.在图7中,当调用SWAP交换del(1)和ins(1,a,0)时返回false,可以判断出两个操作是无效操作.HB中不需要保存无效的操作,移除它们不影响其他操作.在本地站点,如果产生的删除操作o1不能与HB中的插入操作o2交换,则从HB中移除o2并更新与o1已交换位置的操作的nd属性.同时,将o1作为o2的undo操作广播到其他站点.当远程站点接收到undo(o2)时,首先,在HB的第k个位置取出该操作;然后,将o2与k+1到n位置上的操作逐一交换位置得到o2,o2的逆操作即为o1的执行形式;同时将o2从HB中删除.每个操作都由站点id以及逻辑时钟num组成的二元组唯一确定,访问HB中的任何一个操作是很方便的.从上面的过程可以看出集成undo操作的时间复杂度是线性的.4.5Undo扩展作为错误恢复的重要机制,实时协同编辑系统需要支持anyundo(undoanyoperationsatanytime)[23,42].由于MOOT提出的压缩机制,HB中的某些操作会被删除,造成undo目标操作的丢失.为了能够支持undo功能,本文给出一种可行的处理方法,即在每个协同站点额外维护完整的HB(FullHB,FHB)以及压缩过的HB(CompressedHB,CHB).MOOT的压缩策略并非是发出真正的undo命令,而是对撤销操作的模拟.为了能够区别undo操作,可以设置其他的标志来表示删除操作抵消插入操作的请求.利用已有的undo算法和FHB计算undo/redo操作的执行形式o,将o加入到FHB.而CHB则用于计算普通操作o的执行形式.由前面的叙述可知,FHB和CHB是等价操作集合.4.6算法描述每个站点不仅会产生操作也会接收其他站点的操作.每个站点需要维护接收队列R和状态向量犛犞.本地站点i产生的操作o会被立即执行,然后调用函数IntegrateLocal将HB重构成DIHB,犛犞[i]=犛犞[i]+1,并广播请求r.算法1排除插入操作Hi对操作o的影响得到o.根据前面的叙述,不是所有的操作都能交换执行顺序.如果SWAP(o,ox)=false,其中ox∈Hi,r表示成六元组〈o.id,o.num,flag,ox.id,ox.num,o.c〉,当o.t=ox.t=ins时,flag=(o.p-ox.p)表示o和ox的位置关系;当o.t=del并且ox.t=ins时,flag=undo表示o作为ox的undo操作.如果SWAP(o,ox)=true,其中ox∈Hi,r表示成四元组〈o.id,o.num,flag,o〉.算法1.IntegrateLocal.输入:站点产生的操作o输出:广播到其他站点的请求r1.o··=o;2.Fork··=|Hi|-1downto03.[o,isValid]··=ET(o,Hi[k]);4.IFisValid=false5.r··=〈id,num,0/1/undo,Hi[k].id,6.RETURNr;7.ELSE8.IFo.t=del9.IT(Hi[k],o);10.ENDIF11.ENDIF12.ENDFOR13.r··=〈id,num,null,o〉;14.IFo.t=ins15.Hi.add(o);16.ELSE17.Hd.add(o);18.ENDIF19.RETURNr;Page9站点j接收到站点i的请求时,首先判断是否满足因果接收条件.如果犛犞j[i]=r[2]-1,则调用IntegrateRemote函数;否则,加入接收请求队列R.站点调用线程周期性的访问R,寻找满足条件的请求并处理.在集成远程操作时,根据请求r推导出待集成的操作o,经过转换得到的o就是远程操作在本站点的执行形式.如果r.flag=undo,则根据4.4节描述的过程进行计算;如果r.flag=0/1,则在HB中的第k个位置取出〈id=r[4],num=r[5]〉的操作ox,o.p=ox.p+0/1,将o与k+1到n位置上的所有操作进行包含转换得到o,执行o;如果flag=null,则首先调用Separate(o,Hd)将删除操作集Hd转换成因操作集Hdh和并发操作集Hdc.然后,对Hdc进行包含转换得到o,再对Hi进行包含转换得到o.当o是插入操作时,将o添加到Hi中;当o是删除操作时,将o对插入操作集Hi进行对称包含转换,最终将o添加到Hd中.算法2.IntegrateRemote.输入:接收的请求r输出:远程操作o的执行形式o1.IFr.flag=undoTHEN2.o··=Hi[k];//Hi[k].〈id,num〉=〈r[4],r[5]〉3.o··=SWAP(o,Hi[k+1:|Hi|-1]);4.o··=inverse(o);Hi.delete(o);5.ELSEIFr.flag=0/16.o··=Hi[k];//Hi[k].〈id,num〉=〈r[4],r[5]〉7.o··=ins(o.p+0/1,r[6],o.nd,r[1],r[2]);8.o··=ITSQ(o,Hi[k+1:|Hi|-1]);9.ELSE10.o··=r[4];11.ndc12.o··=ITSQ(o,Hdc);13.IFo=THEN14.RETURNo;15.ENDIF16.IFo.t=insTHEN17.o··=ITSQ(o,Hi);Hi.add(o);18.ELSE19.ox20.FORk··=0upto|Hi|-121.oy22.ox23.Hi[k]··=IT(Hi[k],oy);24.ENDFOR25.o··=ox;Hd.add(o);26.ENDIF27.ENDIF28.RETURNo;4.7性能分析本地产生的操作o都会被立即执行,耗费计算时间O(1).如果o.t=ins,调用ET排除Hi中所有操作的影响并遍历Hd计算o.nd,耗费计算时间O(|Hi|+Hd|);如果o.t=del,调用SWAP将o交换到所有插入操作的前面,耗费计算时间O(|Hd|).当站点接收到远程操作o,首先调用Integrate-Remote计算出o在本站点的执行形式o,然后执行o.如果接收到的请求r.flag=0/1(本质上接收的是插入操作),则首先在Hi找到相关操作ok并求出o,然后调用ITSQ(o,Hi[k+1:|Hi|-1])计算出o,耗费计算时间O(|Hi|);如果r是undo请求(本质上接收的是删除操作),则也是首先在Hi找到相关操作ok并调用SWAP将其交换到Hi的尾部得到ok,o等于ok的逆操作,耗费计算时间O(|Hi|);如果请求r.flag=null,则首先调用Separate函数将H划分成Hd·Hi,然后调用ITSQ(o,Hdc+Hi)计算出o,耗费计算时间O(|Hd|2+|Hdc|+|Hi|),对于删除操作,还需要将o调整到Hi之前.表1给出了集成操作到HB中的计算时间复杂度,包括操作的执行时间以及维护DIHB结构的时间.插入操作删除操作本地操作都是先执行然后才被集成到HB中,因此集成本地操作的过程不会影响操作的执行.而接收到的远程操作则要求尽快得到执行,集成远程操作的计算效率决定了操作的响应时间.在上面的讨论中,根据〈id,num〉找到第k个位置上的操作,可以通过遍历Hi的方式也可以通过建立哈希表来访问.算法维护HB需要耗费O(|H|)的空间.5实例分析本节用一个实例场景来解释MOOT算法的执行过程.协同场景为3个站点的协同,站点之间的优Page10先级设定为site1<site2<site3,初始编辑状态s=“abc”.3个站点并发产生操作o1=ins(2,y)、o2=del(1)和o3=ins(1,x).站点1在接收到o2之后产生o4=ins(2,z);站点3在接收到o1之后产生操作o5=del(1).各个站点发送、接收操作的顺序如图8所示.最终所有站点得到一致的结果“ayzc”.在站点1:o1立即执行,H1=[o1];接收到o2,调用IT(o2,o1)得到o2=del(1),执行o2,H1=[o2o1],其中o1=IT(o1,o2)=ins(1,y,1);o4立即执行并对o1进行排除转换ET(o4,o1)=false,将请求r=〈1,2,1,1,1,z〉广播到其他站点,H1=[o2o1o4];接收到o3,由于o3‖o1‖o2,o3=ITSQ(o3,H1)=ins(1,x,0),执行o3,H1=[o2o1o4o3];接收到o5,由于o5是o3的undo操作,o5=inverse(o3)=del(1),执行o5,将o3从H1中删除,H1=[o2o1o4].此时s=“ayzc”.在站点2:o2立即执行,H2=[o2];接收到o1,o1=IT(o1,o2)=ins(1,y,1),执行o1,H2=[o2o1];接收到o3,o3=ITSQ(o3,H2)=ins(1,x,0),执行o3,H2=[o2o1o3];接收到o4,在H2中找到o1,o4=ins(2,z,1),o4=IT(o4,o3)=ins(3,z,1),执行o4,H2=[o2o1o3o4];接收到o5,由于o5是o3的undo操作,o3=SWAP(o3,o4)=ins(1,x,0),o4=ins(2,z,1),H2=[o2o1o4o3],o5=inverse(o3)=del(1),执行o5,从H2中删除o3,H2=[o2o1o4].此时s=“ayzc”.在站点3:o3立即执行,H3=[o3];接收到o1,将o1与o3进行包含转换得到o1=ins(3,y,0),H3=[o3o1];o5立即执行,o5=SWAP(o5,o1)=del(1),o1=IT(o1,o5)=ins(2,y,1),ET(o5,o3)=false,恢复o1.nd=0,从H3中删除o3并将r=〈3,2,undo,3,1,x〉发送出去,H3=[o1];接收到o2,o2=IT(o2,o1)=del(1),执行o2,H3=[o2o1],其中o1=IT(o1,o2)=ins(1,y,1);接收到o4,在H3中查找到o1,o4=ins(2,z,1),执行o4,H3=[o2o1o4].此时s=“ayzc”.6实验研究由于ABT的时间复杂度低于当前其他的OT算法,因此本文通过比较MOOT和ABT算法的性能来检MOOT算法的性能.所有的算法都采用C#编写.对比实验运行的计算机配置为IntelQuadQ83002.5GHz和2GBRAM.操作系统是Windows7Ultimate32.参照文献[11,15,37],实验模拟两个站点之间的协同.首先,站点1和站点2并发地产生M个操作和N个操作;然后,测试将这N个操作集成到远程站点1的计算时间.在300000个字符的文档上产生插入、删除操作,操作的位置是均匀分布的.M和N的取值在300~3000之间,步长为300.测试在插入操作占比例60%和80%时,MOOT和ABT算法集成远程操作的计算时间.实验结果展示在图9~图12中.图9ABT在插入操作比例为60%时的计算时间图10MOOT在插入操作比例为60%时的计算时间Page11图11ABT在插入操作比例为80%时的计算时间图12MOOT在插入操作比例为80%时的计算时间在插入操作比例为60%时,MOOT集成远程操作的计算时间比ABT提高了20%左右,并且二者都随着M的增大呈现多项式增长.ABT耗费大约50s集成N=2400个操作到远程站点HB(M=1500个操作)而MOOT能集成2700个操作.当M=2100的时候,MOOT每集成300个操作需要大约10s的计算时间,ABT则需要大约12s.在插入操作比例为80%(文献[15]中指出的reasonable比例)时,MOOT计算效率比ABT提高了接近10倍.当M=2400的时候,MOOT每集成300个操作花费4s的计算时间,而ABT需要35s.当M=3000的时候,MOOT集成3000个操作总共需要61s,而ABT大概需要560s.从图9到图12可以看出,随着插入操作增多,ABT算法的计算时间不断在增加,而MOOT算法的计算时间却在减少.假如响应时间要求不高于100ms,M和N则需要取合适的值.例如,当插入比例为80%时,MOOT算法能够在100ms内集成10个操作到M=2100的远程站点.由于产生的操作位置是均匀分布的,因此无效操作和r.flag≠null的比例非常小.如果20%的删除操作是为了撤销之前插入操作的效果,那么集成操作到M=3000和M=2400的远程站点耗费的时间是相等的.可以预期在实际应用中,MOOT算法计算效率更高.总之,与ABT算法相比,MOOT在集成远程操作时性能上有较大幅度的提升.7总结MOOT算法利用了协同编辑环境的两个特性,即协同站点的操作历史保存了大量无效操作以及插入操作的比例大于删除操作.本文提出的DIHB结构能够有效减少HB中操作的数量,同时避免算法的时间复杂度依赖于多数操作.MOOT算法不仅能够满足意图保持的条件而且提高了OT算法的计算效率.下一步的工作,考虑将MOOT算法扩展到支持复杂对象的实时协同.
