Page1FClock:一种面向SSD的自适应缓冲区管理算法汤显孟小峰(中国人民大学信息学院北京100872)摘要现有的各种基于闪存的缓冲区管理算法针对闪存读写代价的不对称性进行改进,实际中既存在同一闪存读写代价的不对称性问题,也存在不同闪存不对称性之间的巨大差异性问题,而后者一直没有得到足够的重视.文章提出一种基于闪存硬盘(SSD)的自适应缓冲区管理算法FClock,FClock将数据页组织为两个环形数据结构(CC和DC),分别用于存储缓冲区中的只读数据页和已修改数据页.当需要选择置换页时,FClock使用基于代价的启发式来选择置换页,可在未修改的数据页和已修改的数据页之间进行公平的选择,适用于不同种类的SSD.针对数据库、虚存和文件系统中数据页访问存在高相关性的特点,提出基于“平均命中距离”的访问计数方法来调整数据页的访问频率.基于不同SSD和不同存取模式的实验结果说明,FClock的综合性能优于已有方法.关键词闪存;数据库;缓冲区;置换策略;CLOCK1引言基于闪存的存储设备以其低延迟、低能耗、小巧轻便及高抗震性等特点广泛应用于移动设备上,随着闪存容量的不断增大和价格的降低,其应用领域已逐步扩展到个人计算机和企业服务器市场.过去几年NAND型闪存的容量不断增长,并且这种趋势将至少持续到2012年[1].目前各种应用中都将闪存硬盘SSD看成一个块设备并使用与磁盘一样的存取接口,但这两种硬盘的I/O特性却存在很大的差异.闪存硬盘的随机读速度远快于其随机写速度,在一些对性能要求苛刻或者涉及频繁数据处理的应用场合,如数据库服务器,如果不能根据闪存的特性来设计合适的数据结构和算法,就难以获得最佳性能.缓冲区是现代计算机最基本的组成部分之一.它在存储系统、数据库、网络服务器、文件系统以及操作系统中都有广泛的应用.缓冲区置换算法的任何进展都会影响现代计算机的整体性能.假设用磁盘做辅存且读写操作的时间延迟相同,那么对于给定大小的缓冲区,现存的缓冲区置换算法[2-8]的目标就是最小化缓冲区的缺页率.当缓冲区已满并且请求的数据页不在缓冲区中时,缓冲区置换算法首先从当前缓冲区选择一个用于置换的数据页,如果所选的数据页是脏页(其内容被修改过),就必须将该页的内容写回硬盘,然后才能将请求的数据页读入缓冲区,以保证数据的一致性.这种操作可能会成为系统性能的瓶颈,这是因为请求页的线程或进程必须等待写操作的完成.早在20年前,Effelsberg等[9]已经认识到缓冲区中数据页的读写状态是影响置换策略的重要因素,由于闪存硬盘有望替代磁盘成为新一代的数据存储设备,并且闪存硬盘的读写代价存在不对称性问题,在设计置换策略时更应考虑读写状态的差异性.针对闪存读写操作的不对称性问题,近几年研究者已经提出了几种适用于闪存的缓冲区置换策略[10-14].然而,这些置换策略在实际中存在以下问题:(1)适用的闪存硬盘类型有限已有的基于闪存的缓冲区置换算法的基本假设是闪存的随机读代价相对于随机写代价来说可忽略不计,因此这些缓冲区置换策略都是通过无条件先置换只读页来减少随机写操作的次数,从而提高系统的性能.然而,如图1所示,该假设和实际情况并不相符,即随机读代价和随机写代价相比,并非在所有情况下都可以被无条件忽略.尽管所有的闪存设备都表现出较快的随机读速度和较慢的随机写速度,但对于不同的闪存设备而言,读写代价的比例差别很大,显然在不考虑只读页的操作代价和访问频率的情况下就无条件首先置换只读页是不合理的.图1NAND闪存硬盘随机读(RR)和随机写(RW)消耗的时间比例(X轴为9种闪存硬盘,1是三星MCAQE32G8APP-0XA,2是三星K9WAG08U1A,3是三星K9XXG08UXM,4是三星K9F1208R0B,5是三星K9GAG08B0M,6是现代HY27SA1G1M,7是三星K9K1208U0A,8是三星K9F2808Q0B,9是三星MCAQE32G5APP①)(2)多线程处理能力不足①已有的基于闪存的缓冲区置换策略都是基于LRU置换策略进行改进,LRU的优势在于它实现简单,操作代价低,但LRU也有自身的局限性:①每次命中的数据页必须移动到最近使用(MRU)的位置.实际中多个线程可能都试图移动各自的数据页到MRU位置,而MRU位置通过锁保护来保证一致性和正确性.由于所有命中操作都在等待该操作的完成,就会引起大量锁争用的问题.在高性能和高吞吐量环境中,例如虚存、数据库、文件系统和存储控制器中,这种情况是不可接受的.②LRU没考虑数据页的“访问频率”.和LRU对应,CLOCK算法克服了LRU算法的上述缺点.通过将数据页组织成时钟形式的环形缓冲区,CLOCK算法无需在每次命中数据页后移动数据页的位置,因此不会出现锁争用的问题.因此,CLOCK算法在实际系统中,如DB2、SQLServer、Postgresql等,得到了广泛应用.针对现有基于闪存的缓冲区置换算法存在的问题,本文提出一种基于闪存的clock算法FClock来解决以上问题.FClock为每个数据页维护一个“访问位”并将缓冲区中的数据页组织成两个时钟形式①http://www.datasheetcatalog.netPage3的环形结构CC(CleanClock)和DC(DirtyClock),分别用于管理未修改的数据页和修改过的数据页.当数据页被初次读入缓冲区时,它的访问位被置为0.当命中某个数据页时,将其访问位加1.当需要选择一个置换页时,FClock并非直接置换出未修改页,而是首先根据启发式规则判断被置换的数据页是已修改页还是未修改页,然后再从DC或者CC中找访问位是0的数据页进行置换,以此来进行自适应的调整.最后,受文献[3]的“局部性过滤”原则的启发,FClock使用基于平均命中距离的技术来消除短期频繁访问而长期不访问的数据页长时间驻留内存的问题.2背景及相关工作2.1闪存存储器一般来说,有两种不同类型的闪存芯片,分别是NOR型闪存和NAND型闪存.NOR型闪存芯片和EPROM以及SRAM一样,有专用的地址和数据总线;而NAND闪存芯片无专用的地址和数据总线,用一个IO接口来控制输入输出.NOR型闪存芯片可用来替换可编程的只读存储器(PROM)和可擦除的PROM(EPROM)来进行有效的随机存取;NAND型闪存芯片由于其存储容量较高,主要用来存储数据.闪存硬盘(SSD)中使用的通常是NAND型芯片.NAND型闪存芯片上有3种基本操作:读、写和擦除.读和写都是以数据页为单位进行操作;擦除是以块为单位进行操作,一个块通常包含64个页.NAND型芯片不支持原地更新,如果某个页上有数据,就无法对该页直接进行覆盖写操作.为了避免对某些块进行频繁的写和擦除操作之后所造成的数据块失效的问题,通常使用磨损平衡技术将写和擦除操作均匀地分布在所有的数据块上.为了克服闪存芯片的物理限制,闪存硬盘利用一个软件层来模拟块设备的功能,并尽量使得擦除操作的延迟不为用户所见,这个软件层通常称为闪存转换层(FTL),它一般存储在SSD的ROM芯片中.FTL的主要作用是将对一个数据页的写请求重新映射到一个已擦除的空白数据页上.因此,FTL需要维护一个内部映射表来记录逻辑地址和物理地址之间的映射信息.该映射表在系统启动时构造,并在SSD的易失性存储器中进行维护.FTL的实现细节与具体的设备相关,由制造商提供,对用户是透明的.2.2缓冲区置换策略典型的计算机系统包含两层存储器,分别是主存(缓冲区)和辅存(外部存储介质,如磁盘或者SSD).缓冲区的存取速度远快于辅存,二者一般使用相同大小的数据页.已有基于磁盘的缓冲区置换策略[2-8]假定每次置换操作的代价相同,其目标是最小化缓冲区的缺页率.缺页率反映了必须从辅存读入缓冲区的数据页的比例.CLOCK[2]、FBR[3]、LRU-K[4]、2Q[5]、LIRS[6]、ARC[7]和LRFU[8]等算法主要通过使用启发式方法来提高系统的性能,通过考虑数据页在缓冲区中的滞留时间和使用频率来减少缺页率.由于闪存的读写时间不对称,以上假设对于闪存来说是不成立的.因此,当设计基于闪存的缓冲区管理算法时,需要考虑读写的不对称性问题.具有不对称存取时间的缓冲区置换问题可模拟成加权缓冲区问题,其目的是最小化请求序列的总代价.针对该问题,文献[15]提出了复杂度为O(sn2)的最优离线算法,其中s表示缓冲区中数据页的个数,n表示请求序列的长度.该问题可进一步归结为最小代价最大流问题[16]进行求解.由于该算法的时间和空间复杂度很高,即使提前知道完整的请求序列,其运行也需要耗费大量的时间和空间资源.对于在线算法,不可能提前知道任何未来的请求序列.研究者已经提出了许多在线的基于闪存的缓冲区管理算法.基于闪存的缓冲区置换策略(FAB)[11]维护了一个块层LRU链表,同一物理块的数据页被聚集到一起.FAB主要用在多数写请求都是顺序写的便携式媒体播放器上.BPLRU[12]也维护了一个块层LRU链表.与FAB不同,BPLRU使用SSD内部的RAM作为缓冲区,将随机写变成顺序写来提高写操作的效率和减少擦除操作的次数.CFLRU[10]是利用闪存读写性能的不对称性提出一种优先置换只读页的缓冲区置换策略,这种策略假设闪存的写代价远远大于读代价.CFLRU的基本思想如图2所示.其中LRU链表分成两个部分:工作区(WorkingRegion)和置换区(Clean-FirstRegion).每当发生缺页中断时,如果在置换区中存在只读的数据页,CFLRU就会从中选择最近最少使用的只读页进行置换,如图2的p6.只有当置换区中没有只读页时,才选择链表尾部的修改页p7进行置换.置换区的大小是由参数w控制的.Page4基于相同的思想,文献[13]将CFLRU置换区中的数据页根据其修改状态组织为不同的队列,从而可以将选择置换页操作的时间复杂度降为O(1).CFDC[14]通过对CFLRU置换区中的数据页进行重新组织来提升CFLRU算法的执行效率.如图3所示,CFDC的缓冲区也分为两部分,分别是工作区(WorkingRegion)和置换区(PriorityRegion).在CFDC的置换区中,根据数据页是否为修改页将其组织到两个队列中,其中只读页放在Cleanqueue中,所有的修改页放在不同的Cluster中,这些Cluster用Dirtyqueue进行组织,同一个集合中修改页的物理位置比较接近.和FAB算法的块层LRU算法相比,CFDC中的块大小是可变的.3FClock算法3.1数据结构如图4所示,FClock将缓冲区中的数据页根据其读写状态组织为两个环形数据结构CC和DC,分别维护只读页和修改页.假定缓冲区可以存放s个数据页,则|CC∪DC|=s∧CC∩DC=.FClock维护了一个全局计数器Counter,每当发生一次数据页请求,Counter值加1.对于缓冲区中的每个数据页p,FClock为其关联3个变量:T、C和I,其中T表示p进入缓冲区的时间(当时的Counter值),否则为最近一次被命中的时间);C是p的访问位计数器,表示p被访问的频繁程度;I表示p最近两次被命中之间对其它数据页访问的次数,称为“命中距离”.例如,假设数据页的请求序列为“r1,r2,r3,r4,r1”,则在访问完第一个r1之后,Counter=1,因此r1.T=1,第二次访问完r1后,r1.I=Counter-r1.T-1=3,表示最近两次命中r1之间对其它数据页进行了3次访问,r1.T=Counter=5.另外FClock还为CC和DC各维护一个变量F,用于表示CC和DC从最近一次命中数据页后到目前为止发生页缺失的次数.图4中的虚线环用于处理循环和序列模式的数据页访问,称为子环,CC和DC中的子环分别用SCCC和SCDC表示.本文所用符号的意义如表1所示.符号名称CC维护只读页的clock(CleanClock)DC维护修改页的clock(DirtyClock)s缓冲区可容纳的数据页个数SCCCCC中的子环SCDCDC中的子环ζ过去s次访问的命中页的平均访问间隔CrCw向SSD写入一个数据页的代价MCCMDCRCCRDCCounter全局计数器3.2基于代价的置换页选择策略如果缓冲区满且当前请求的数据页p在缓冲区中,则可直接从缓冲区中访问此页;反之,FClock置换策略将按照“代价”从CC或DC中选择一个页x进行置换,并从SSD读入数据页p.FClock的基本思想是:CC和DC的大小应该和其在过去一段时间内由于数据页缺失所付出的代价成比例(式(1)).假设缓冲区最多可放s个数据页,FClock的置换策略可表述为:若|CC|<βs,则DC过大,那么选择DC中指针所指的计数为0的数据页进行置换;反之从CC中选择计数为0的数据页进行置换.本文中过去一段时间指过去s次访问,CC的代价记为CCC,DC的代价记为CDC.式(1)表示CC的大小占总缓冲区的比例.当数据页驻留缓冲区时,在连续两个物理操作之间可能发生多次逻辑操作.尽管物理操作体现了Page5CC和DC实际付出的代价,访问序列却是以逻辑操作的方式呈现的.虽然逻辑操作和物理操作不同,但对于系统的性能来说都有影响.一方面,物理操作对存取模式变化本身的反应比较迟钝;另一方面,虽然考虑逻辑操作可以快速侦测存取模式的变化,但对于存取模式剧烈变化的情况不太适用.可见,单纯使用任何一种操作计算代价都不够全面.为了最小化物理操作的代价,受文献[17]的启发,本文提出一种基于时钟数据结构并结合物理操作和逻辑操作优点的代价计算方案.假定对数据页的存取是相互独立的,缓冲区可以存放s个数据页,n是被处理文件中数据页的个数,则对某个数据页的逻辑操作在缓冲区中命中的概率是s/n,而一个逻辑操作被转换为物理操作的概率是(1-s/n).如式(2)和式(3)所示,本文提出的代价计算方案同时考虑了逻辑操作和物理操作.CDC=(RDC·(1-s/n)+MDC)·(Cw+Cr)(3)当选择一个置换页时,通过考虑逻辑操作的影响,FClock可以较快识别存取模式的变化并进行相应的调整.而且,由于物理操作的影响也考虑在内,FClock可以适应存取模式剧烈变化的情况.如前所述,代价的计算基于过去一段时间内(s个数据页访问)的统计结果.本文通过使用一个最大长度为s的队列来记录过去一段时间数据页的访问情况,队列中每个元素e对应了一次数据页的访问,e由两个数据成员组成:nC和bHit,其中nC的取值可以是CC或者DC,表示相应的数据页请求发生在CC或者DC中,bHit表示对数据页的访问请求是否命中,以此来区别逻辑操作和物理操作.基于该队列,可以在每次发生数据页请求时,在O(1)代价的基础上更新CC和DC的代价值.由于队列长度有限,因此维护该队列所需的内存非常有限.代价的计算分为3步:(1)去除头元素eh,(2)加入新元素et,(3)根据以上介绍的方案计算代价CCC和CDC.其中第(1)步去除队头元素后,和第(2)步加入新元素后需要根据去除的元素和加入的新元素修改当前CC和DC对应的逻辑操作和物理操作的次数.3.3数据页访问位修改策略虚存、数据库以及文件系统中经常会出现对同一个数据页多次连续访问后不再访问或者间隔较长时间后再访问的问题.假设频繁访问的数据页之间的间隔大于两倍缓冲区大小.原始的clock算法(即二次机会算法的改进)为每个数据页关联一个访问位,数据页初次进入缓冲区时,访问位置0,当某个数据页在缓冲区中命中时,访问位置1,当时钟指针扫过该页且其访问位为1时,访问位置0.显然这种方法会每隔一段时间(大于两倍缓冲区大小)将频繁访问的数据页置换出缓冲区.而改进的clock算法要么在每次访问后都让访问位加1,要么在加1的基础上为访问位设定一个最大值,都会导致短时间内频繁访问但以后不再访问的数据页长时间驻留内存.因此,对于短时间内频繁访问的问题,本文提出用平均命中距离来解决这一问题.定义1(平均命中距离ζ).对于过去一段时间的访问序列“r1,r2,…,rn”而言,平均命中距离指该序列中所有被命中的数据页的命中距离的平均值,计算方法见式(4),其中m指过去n次访问数据页时命中的次数.例如,对于访问序列“r1,r2,r2,r3,r2,r5,r1,r2”而言,假设缓冲区大小为8,初始状态为空.当访问最后一个r2时,可知在过去8次访问中,r1在第7次访问时被命中,其命中距离r1.I=5,而r2在第3、第5及第8次访问时被命中,其命中距离分别为0、1和2.由式(4)可知该序列过去8次访问的平均命中距离是(5+0+1+2)/4=2.FClock使用平均命中距离来衡量某次命中是否为短时间内的频繁访问,其访问位修改策略可表述为:如果某个数据页的命中距离不小于平均命中距离ζ,则该数据页的访问计数加1,否则保持不变.需要注意的是,虽然从表面上看该策略可能造成一直频繁访问的数据页的访问位永远不能增加的问题,实际上,如图5和算法1所示的过程,Hash表中维护了数据页的有效访问位置,通过该变量,可知频繁访问数据页的访问位的值会得到慢慢增加.这一点在算法1后面的例子中进行具体的说明.Page6由于平均命中距离是基于过去一段时间的访问序列来进行计算的,每当执行一次新的数据页访问时,如果按照式(4)进行计算的话,显然时间复杂度太高.为此,本文提出一种在常量时间内计算平均命中距离的方法.如图6所示,计算平均命中距离时使用两种数据结构,分别是队列和Hash表.队列用于维护过去一段时间内数据页的访问情况,本文实验中,过去一段时间指过去s次数据页的访问,s是缓冲区中最多容纳的数据页个数,队列中元素的成员I、T、C的意义在3.1节进行了阐述.Hash表用于记录在过去s次访问中队列中的数据页在队列中的有效位置,该有效位置用于计算每个数据页的命中距离以及整个缓冲区的平均命中距离ζ.限于篇幅,这里用例子来说明如何在常量时间内计算平均命中距离ζ.例如,对于访问序列“r1,r2,r1,r1,r3,r1,r3”,假设s=6,初始情况下队列和Hash表均为空.为了说明的方便,Hash表中数据页在队列中的位置用数据页的T值表示.该序列的处理过程如下:(1)访问r1(图5(a)),r1的I、T的值分别是0、1,ζ=0,然后将r1加入Hash表中;(2)访问r2(图5(b)),r2的I、T值分别是0、2、0,ζ=0,然后将r2加入Hash表中;(3)访问r1(图5(c)),r1的I、T值分别是0、3,由于r1命中,通过r1在Hash表中找其在队列中的有效位置1,得到有效位置处的T值1,进而可以得到r1的命中距离1.由于1>ζ=0,将Hash表中r1的有效位置对应的I值更新为1,同时更新Hash表中r1的有效位置更新为3,最后计算平均命中距离ζ=1;(4)访问r1(图5(d)),r1的I、T值分别是0、4,由于r1命中,通过r1在Hash表中找其在队列中的有效位置3,得到有效位置处的T值3,进而可以得到r1的命中距离0.由于0<ζ=1,则Hash表中r1的有效位置及其对应的I值不变,最后计算平均命中距离为ζ=0.5;(5)访问r3(图5(e)),r3的I、T值分别是0、5,由于r3没有命中,将r3及其有效位置5加入Hash表中,ζ保持不变;(6)访问r1(图5(f)),r1的I、T值分别是0、6.由于r1命中,通过r1在Hash表中找其在队列中的有效位置3,得到有效位置处的T值3,进而可以得到r1的命中距离2.由于2>ζ=0.5,则Hash表中r1的有效位置3对应的I值变为2,同时将Hash表中r1的有效位置更新为6,最后计算平均命中距离为ζ=1;(7)访问r3(图5(g)),r3的I、T值分别是0、7.由于r3命中,通过r3在Hash表中找其在队列中的有效位置5,得到有效位置处的T值5,进而可以得到r3的命中距离1.由于1ζ=1,则Hash表中r3的有效位置5对应的I值变为1,同时将Hash表中r3的有效位置更新为7,最后计算平均命中距离为ζ=1.计算平均命中距离的方法在FClock算法中用update(ζ)来表示.3.4FClock算法FClock算法的具体流程如算法1所示.在缓冲区未满的初始阶段,即|CC∪DC|<s,如果请求页p没有命中(算法1中的CaseII),则根据对p的读(8~10行)或者写(12~14行)操作类型从SSD上读取到CC或者DC中,最后在第15行更新平均命中距离的值.如果p命中,即p∈CC∪DC,对应算法1的CaseI,如果p∈CC(第1行),则CC的逻辑操作次数加1,然后将其命中距离置0;否则如果p∈DC(第2行),则DC的逻辑操作次数加1,然后将其命中距离置0.如果操作类型是write并且p∈CC(第3行),则将p从CC中移到DC中.在第4行,如果p的命中距离不小于平均命中距离,则将p的访问计数加1.最后在第5行更新平均命中距离的值.算法1.FClock(pagep,typeT)./FClock在每次系统请求数据页p时被触发,T表示CaseI:p∈CC∪DC/p被命中/1.if(p∈CC)then{RCC←RCC+1;CC.F←0;}2.else{RDC←RDC+1;DC.F←0;}3.if(T=writeandp∈CC)thenMoveptoDC;4.if(p.Iζ)then{p.C←p.C+1;}5.update(ζ);CaseII:pCC∪DC/p没有命中/6.if(|CC∪DC|=s)thenevictPage();7.if(T=read)then8.RCC←RCC+1;MCC←MCC+1;9.fetchpfromthedisk;10.Insert(p,CC);11.else12.RDC←RDC+1;13.fetchpfromthedisk;14.Insert(p,DC);Page7SCDC);15.update(ζ);过程1.evictPage()1.β←CCC/(CCC+CDC)CaseI.|CC|<βs/DC过大,从DC中移除数据页/2.MDC←MDC+1;3.LetqbethepagepointedbyclockhandofDC(or4.while(q.C>0)do{q.C←q.C-1;q←q->next;}5.writeq’scontenttoSSD;deleteq;CaseII.|CC|βs/CC过大,从CC中移除数据页/6.LetqbethepagepointedbyclockhandofCC(orSCCC);7.while(q.C>0)do{q.C←q.C-1;q←q->next;}8.deleteq;过程2.Insert(p,clockx).1.if(clockx.Fλ|clockx|)then2.addptoSCclockx;3.elseaddptoclockx;4.clockx.F←clockx.F+1.如果缓冲区已满,当数据页命中时,其操作和前面一段所介绍的内容相同.如果数据页没有命中,则FClock会在算法1的第6行首先调用evictPage()从CC或者DC中选择一个数据页进行置换.evict-Page的具体操作见过程1,其基本思想和计算方法已在3.2节中进行了说明.然后在第7~14行根据对p的操作类型从SSD读入p并将其放入CC或者DC中,最后在第15行更新平均命中距离的值.在FClock中,将数据页插入CC(DC)时,调用了Insert()过程,在第1行会判断CC(DC)的F值(自从最近一次命中后发生的连续页缺失次数),如果F>λ|clockx|,则FClock认为目前的数据页存取模式为序列存取,同时构造CC(DC)的子环SCCC(SCDC),并将p放入SCCC(SCDC)中;否则直接在第3行将p放入CC(DC)中.注意子环SCCC(SCDC)是CC(DC)的一部分.在第4行,将CC(DC)的缺页数F加1.过程Insert中λ是调节因子,取值在[0,1]区间.例如,对于访问序列“r1,r2,r1,r1,r3,r1,r3”而言,其过程如下:(1)访问r1,没命中.从SSD上读入r1并按照其操作类型放入CC或者DC中,同时在算法1的第15行使用3.3节介绍的方法更新ζ=0.(2)访问r2,没命中.处理过程同(1).(3)访问r1,命中.则在算法1的第4行根据r1.I=1>ζ=0,则r1.C加1,如图5(c)所示,然后更新ζ的值为1.(4)访问r1,命中.由于r1.I=0<ζ=1,则r1.C保持不变,如图5(d)所示,然后更新ζ的值为0.5.(5)访问r3,没命中.和r2的处理相同,如图5(e)所示,ζ保持不变,r3.C=0.(6)访问r1,命中.注意这时r1.I的计算依赖于图5(e)中的Hash表,可知r1的有效位置为3,进而可知r1.I=2>ζ=0.5,因此r1.C=r1.C+1=2,如图5(f)所示,然后在算法1第5行更新ζ=1.(7)访问r3,命中.由于r3.I=1ζ=1,因此r3.C加1,如图5(g)所示,随后在算法1第5行更新ζ=1.3.5分析FClock的自适应性体现在两方面:(1)基于代价的置换策略,当需要选择一个置换页时,FClock从CC或者DC中根据各自的累加代价和公平地选择合适的置换页.当读操作较多时,CC会慢慢变大,相反,DC会慢慢变大.因此FClock能很好地处理同一闪存读写的不对称性以及不同闪存读写不对称性的巨大差异性,可以应用到不同类型的SSD上;另外,由于FClock在计算代价时同时考虑了物理操作和逻辑操作,FClock可以适应不同的存取模式.(2)FClock使用平均命中距离来控制数据页的引用计数,可以使得频繁访问的数据页的引用计数的值慢慢而不是快速增加,可以避免二次机会算法快速换出间隔较长时间后频繁访问的数据页被过早换出的问题,同时可以避免每次命中就加1的改进CLOCK算法所造成的无用数据页长时间驻留内存的问题.和CFLRU及CFDC相比,FClock考虑了引用计数,并且可以避免LRU、CFLRU及CFDC存在的锁争用问题.FClock可以很好地处理序列存取模式.当需要处理序列引用时,FClock使用F来检测CC(DC)的页缺失次数,当达到一定程度时,即可认为出现了序列存取模式,这时,FClock通过构造CC(DC)的子环SCCC(SCDC)来处理新来数据页的插入和移除操作,从而不会对子环以外的数据页产生影响.相比之下,CFLRU及CFDC没有考虑存取模式的影响,这一点在第4节的实验结果部分也得到了证明.当循环请求序列涉及的操作类型既包含读操作,也包含写操作时,FClock可以很好地处理循环存取模式.原因在于闪存读写代价不对称,而FClock根据代价而不是存取的先后顺序选择置换页,因此对于长循环而言,FClock将打乱循环存取模式的置换顺序.相比之下,CFLRU和CFDC由于首先置换只读页,因此可以一定程度上打乱循环存取模式的置换顺序,但FClock的自适应性使得这种Page8打乱存取模式的行为具有自适应性,可以根据不同闪存的读写特点进行调整,而CFLRU和CFDC不具备这一特点,从而导致其性能下降,这一点在第4节的实验结果中也得到了进一步证明.4实验4.1实验环境本文的实验目的是验证FClock算法针对不同读写代价的SSD的有效性.我们选择两种SSD进行实验:(1)三星MCAQE32G5APP,简便起见,用FD1表示;(2)三星MCAQE32G8APP-0XA,用FD2表示.FD1和FD2的随机读写的比率分别是1118和12.这两个闪存硬盘的读写性能存在巨大的差异,这是因为FD1是由MLC类型的NAND芯片构成,而FD2是由SLC类型的NAND芯片构成.对SSD来说,缓冲区置换算法的性能受物理读写次数的影响,然而FTL层的实现是设备相关的,由硬盘制造商提供,并没有为用户提供跟踪读写次数的接口.因此,我们选择使用模拟器[18]来进行测试.我们实现了5种置换策略来进行比较,即LRU、CLOCK[2]、CFLRU[10]、CFDC[14]及本文提出的FClock.所有的置换策略都用VisualC++实现的.我们将CFLRU算法中“置换区”的“窗口大小”设为缓冲区大小的75%,将CFDC的“置换区”的“窗口大小”设为缓冲区的50%,将CFDC的“聚类大小”设为64.参数取自对应文献实验中所采用的数值.我们将数据库的文件大小模拟为64MB,相当图7不同方法在FD1上运行T1~T4时读次数比较于32000个的物理页,每页为2KB.缓冲区的大小范围从2000个页到8000个页.本文实验中,模拟器假定数据页的大小是2KB,每个数据块包含64个数据页.我们生成了4种类型的测试数据,其统计数据如表2所示,其中“读/写比率”列中的“x%/y%”表示对某种测试数据来说,所有请求的x%为读操作、y%为写操作;“局部性”列中的“x%/y%”表示对某种测试数据来说,在y%的页上有x%的操作.编号总的请求读/写比例局部性T1300000090%/10%60%/40%T2300000080%/20%50%/50%T3300000060%/40%60%/40%T4300000080%/20%80%/20%表1中读写代价Cr和Cw可以通过SSD的技术手册得到,或者通过执行一定量的读写操作后取平均值来获得.本文实验所用数据来自于技术手册.我们选择以下标准来评价缓冲区置换策略:(1)物理读操作的次数,(2)物理写操作的次数,(3)运行时间.其中运行时间是通过将读操作和写操作次数之和相加得到的.4.2性能比较和分析4.2.1读写操作代价差异巨大的SSD上性能比较读操作性能比较.图7展示了4种已有方法和基于本文提出的基于代价的FClock方法在FD1上运行T1、T2、T3及T4时随机读次数比较.可以看出,和LRU及CLOCK相比,基于闪存的算法Page9(CFLRU、CFDC、FClock)需要更多的读次数,但本文提出的方法FClock所需的读次数在T1到T4上远少于CFLRU和CFDC.可见,不考虑只读页的操作频率就直接进行置换导致CFLRU和CFDC需要付出很多不必要的物理读操作.写操作性能比较.图8展示了4种已有方法和基于本文提出的基于代价的FClock方法在FD1上运行T1、T2、T3及T4时随机写次数比较.可以看出,基于闪存的算法(CFLRU、CFDC、FClock)涉及图8不同方法在FD1上运行T1~T4时写次数比较图9不同方法在FD1上运行T1~T4时运行时间比较的写操作的次数远少于基于磁盘的LRU和CLOCK算法.同时,尽管CFLRU首先置换只读页,本文提出的方法FClock依然好于CFLRU,原因是进行置换时,由于FD1的读写比例差异巨大,本文方法将在缓冲区中保留更多的修改页.运行时间比较.图9展示了不同方法在FD1上运行T1、T2、T3及T4时运行时间的比较.可以看出,基于闪存的算法(CFLRU、CFDC、FClock)所需的运行时间远少于LRU和CLOCK算法.这是因为Page10对于FD1来说,读写代价相差118倍,而且对基于闪存的置换算法来说,CFLRU和CFDC优先置换只读页,FClock算法给予写操作更高的权重,因此会大量减少写操作的次数,最终导致整体性能提升.4.2.2读写操作代价差异小的SSD上的性能比较读操作性能比较.图10展示了4种已有方法和基于本文提出的基于代价的FClock方法在FD2上运行T1、T2、T3及T4时随机读次数比较.可以看出,和LRU及CLOCK相比,CFLRU和CFDC由于优先置换只读页,因此需要更多的物理读操作.FClock既考虑了不同读写状态的数据页操作代价,同时也能更好地处理数据页的存取模式,整体而言,图10不同方法在FD2上运行T1~T4时读次数比较图11不同方法在FD2上运行T1~T4时写次数比较虽然也给予写操作较大的权重,但依然能达到和LRU及CLOCK算法类似的读操作次数.写操作性能比较.图11展示了不同方法在FD2上运行T1、T2、T3及T4时随机写次数比较.可以看出,由于CFLRU和CFDC无条件优先置换只读页,因此所需写操作的次数最少.而本文提出的方法综合考虑存取模式及物理操作代价,因此在读写操作代价相差不大的情况下,与CFLRU和CFDC相比,将更多考虑读操作的权重,因此写操作的次数明显多于CFLRU和CFDC,但仍然少于LRU和CLOCK算法.运行时间比较.图12展示了不同方法在FD2Page11图12不同方法在FD2上运行T1~T4时运行时间比较上运行T1及T2后的运行时间比较.可以看出,由于FD2读写操作的代价相差不大,而CFLRU和CFDC的读操作次数远远多于其他方法,因此二者所需的总运行时间远多于其他方法.而本文提出方法的读次数和LRU及CLOCK差不多,且写次数比LRU及CLOCK少,因此整体性能最好.4.2.3不同SSD硬盘的性能比较通过比较图7~图12可以看出,对于读写操作代价差异巨大的SSD,如FD1、LRU和CLOCK的整体性能不如基于闪存的置换算法,但对于读写操作代价差异不大的SSD,如FD2、LRU和CLOCK的整体性能要好于CFLRU及CFDC,而本文提出的FClock在选择置换页时,根据操作的代价进行操作,可以在只读页和修改页之间进行公平的选择,因此可以适用于不同读写比例的SSD.5结论和展望针对现有基于闪存的缓冲区管理算法没有考虑不同闪存读写代价不对称性之间的巨大差异性问题以及LRU算法存在锁争用问题,本文提出一种基于闪存硬盘(SSD)的自适应缓冲区管理算法FClock,FClock将缓冲区中的数据页组织为只读环和修改环,使用基于代价的启发式来选择置换页,可在未修改的数据页和已修改的数据页之间进行公平的选择,适用于不同种类的SSD及存取模式.针对数据库、虚存和文件系统中数据页访问存在高相关性的特点,提出基于“平均命中距离”的访问计数方法来调整数据页的访问频率.基于不同SSD和不同存取模式的实验结果说明,FClock的综合性能优于已有方法.
