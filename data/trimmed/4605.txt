Page1面向动态环境的复合服务自适应方法姜伟3)1)(中国科学院计算技术研究所前瞻实验室北京100190)2)(中国科学院大学北京100149)3)(中国石油长城钻探工程有限公司测井技术研究院北京100101)摘要质量敏感的自动服务组合技术旨在从海量Web服务中生成满足用户功能性和非功能性需求的复合服务.这类技术通常假设服务环境静态不变.然而,对真实网络环境下服务的调研结果表明,实际情况与此不符:互联网中每天都会新增或消失大量的Web服务,出现因网络故障、延迟等原因而失效或QoS发生变化的Web服务.该文针对动态服务导致复合服务失效或QoS变差的问题,提出了一种基于事件驱动机制的复合服务自适应方法,可实时处理多种不同类型的动态服务,自动地对复合服务进行检查和更新.最后,文中对自适应方法进行了理论分析及实验验证:与WS-Challenge2009和2010的冠军系统QSynth相比,文中方法在人工服务数据集和真实QoS数据集上均获得更优的性能.关键词动态服务;服务组合;自适应;服务计算;云计算1引言随着服务计算在人类生产、生活领域的不断普及与推广,Web服务的种类和数量也在急剧增多[1].为满足用户快速、准确获取相关服务的需要,诸多网站,如xmethods.net、seekda.com提供了Web服务的查询与注册功能.然而,单个Web服务的功能有限,多数情况下需要将分布在互联网上松散耦合的多个Web服务组合成功能更加丰富的复合服务(ServiceComposition,SC).由于Web服务网络的规模和复杂度持续提升,Web服务组合已成为一个典型的NP(Non-DeterministicPolynomial)难问题[2].为此,相关研究者提出自动服务组合(AutomaticServiceComposition,ASC)技术来重用已存在的Web服务,通过对其进行自动组合来满足用户的功能性需求.目前,ASC已受到学术界和企业界的广泛重视,并涌现出大量成熟的应用.例如,Amazon[3]和SAP[4]公司均在真实场景下利用自动服务组合进行建模.同时,为保证复合服务SC的服务QoS(QualityofService,QoS),近年来,质量敏感的自动服务组合受到众多研究人员的关注.但是大部分工作往往假设服务特性静态不变.当前,已有研究者指出,基于服务的系统日益受到动态变化的服务环境带来的压力,需要持续增强系统的可用性、可靠性以及可扩展性[5].此外,文献[6]对服务功能性演化(如接口的变化)做了研究.为了对真实环境下服务的功能性和非功能性演化进行更为广泛和全面的调研,在2013年11月至2014年2月期间,我们对网络上公开的Web服务进行了总计11个星期的监控.这些Web服务分别抓取自seekda.com,webservicelist.com和xmethods.net.表1给出连续两周抓取数据的对比结果,其中约有4%至8%的Web服务发生了变化.调研结果显示,互联网中每天都会新增或消失大量的Web服务,出现因网络故障、延迟等原因而失效或QoS发生变化的Web服务.与我们的结论类似的是,一些更早期的研究工作[1,7]揭示出在2006年10月至2007年10月期间,约有21%的被监控的Web服务失效.这些动态变化的Web服务会对已存在的复合服务产生负面影响:(1)功能失效;(2)非功能性需求难以满足.为了消除上述负面影响,保证复合服务相关应用的可用性和可靠性,需要处理Web服务发生的各种变化,以便复合服务能够正确的反映当前的服务状态并实际可用.连续两周对比1vs.22vs.33vs.44vs.55vs.66vs.77vs.88vs.99vs.101222510vs.1112370本文以表2所示Web服务为例,解释并说明动态服务对复合服务的影响.表1中给出8个Web服务及其相关信息.其中,服务的QoS表示该服务的响应时间.假设某用户输入的查询请求为:根据所在地地址、饮食偏好(如火锅)和行程要求(如目的地距离当前地址小于20km)等信息,获取相关酒店的行车路线.为满足用户的这一查询请求(功能性需求),程序需要自动选择合适的服务构建复合服务.此外,为了快速响应用户请求并返回结果(非功能性需求),在此场景下,我们还要求复合服务的总体响应时间尽量缩小.根据表1所示服务,可构建复合服务SC1:{w2→w4→w8→w7}以满足上述要求.然而,当w8失效时,我们无法找出一个具备相同功能的服务对w8进行替换.此时,为了仍然满足用户的要求,需要对复合服务内部的组合逻辑进行重新调整.例如,我们可构建出满足需求的复合服务SC2:{w2→w3→w7},然而其逻辑结构与SC1不同.由此可见,动态调整复合服务,不仅需要1-1替换,而且需要n-m替换.Web服务输入参数输出参数W1W2W3W4W5W6W7W8参数含义:a:所在地地址;b:行程要求;c:饮食偏好;d:酒店行车路线;e:城市名称;f:城市邮编;g:酒店邮编;h:酒店地址;i:酒店电话;j:酒店名称;k:酒店级别.针对动态变化的服务环境,在自适应服务选择(AdaptiveServiceSelection)领域,诸多研究者使用整数规划[8-9]、启发性算法[10]、马尔可夫决策[11]、基于区域的重配置[12]、排队论[13]、遗传算法[14]、部分筛选(partialselection)[15]和服务关联分析[16]等策Page3略对运行时失效的服务进行替换.通常,这些自适应服务选择的方法首先预定义组合模板来描述复合服务的组合逻辑.然后,利用模板中抽象的服务类在运行时绑定具体的服务实例.这类方法的不足之处在于:(1)依赖预定义模板,无法自动搜索出复合服务;(2)受限于模板中定义的组合逻辑,难以发现新的具有不同逻辑结构的复合服务作为替代方案;(3)仅能感知和处理模板内部的服务类别,不能利用模板所包含的服务类别之外的服务进一步改善复合服务的服务QoS;(4)采用运行时被动处理的方式,难以对失效的复合服务进行主动发现和更新;(5)每次只能处理一个动态服务,效率较为低下.为了克服上述不足并解决动态环境下自动服务组合带来的挑战性问题,基于我们之前的工作QSynth[17-18],本文提出了一种复合服务自适应方法来应对动态变化的服务环境.基于该方法,我们扩展了原有系统并将其称为QSynth+.QSynth+基于服务依赖图(图1)工作.该图用反向索引表表示,能够准确表达Web服务之间的依赖关系.基于该图,QSynth+首先检索出满足查询请求且服务QoS最优的复合服务;其次,从发布/订阅网络中接收动态服务事件;再次,根据动态变化的服务更新服务依赖图;最后,当原有最优复合服务失效或QoS变差时,基于更新后的服务依赖图,利用复合服务自适应算法生成新的复合服务.需要指出,QSynth可通过重新查询获取最新的复合服务.然而,利用重新查询无法直接获取哪些Web服务发生了变化或受到了影响.因此,在动态环境下,为确保复合服务的正确性,QSynth需对所有的请求进行重新查询,这种频繁的查询操作会严重影响系统的效率.与之相比,QSynth+能够识别出受影响的复合服务,同时只需更新少量受影响的服务状态,无需针对同一请求进行反复或重新查询,因此可极大地提升系统的性能.本文的主要贡献包括:(1)引入了一种新颖的复合服务自适应机制进行动态环境下的自动服务组合,并通过事件驱动的方法主动发现和处理动态变化的服务.(2)提出了一种高效的复合服务自适应算法.该算法无需预定义组合模板,能够感知模板内部和外部的所有服务,不仅支持服务的一对一置换,而且支持更为复杂的逻辑重构.同时,该算法可采用批处理的方式一次性处理多个动态变化的服务.(3)实现了QSynth+系统,并在人工和真实数据集上对系统的性能和准确性进行了有效评估.本文第2节综述与本文相关的研究工作;第3节介绍预备知识并给出问题定义;第4节阐述系统的工作机理和相关算法细节;第5节对核心算法的复杂度、性质和开销进行分析;第6节讨论实验结果;第7节总结全文.2相关工作服务选择和服务组合是与本文研究内容较为相关的工作.本节从两方面分别阐述相关工作进展并进行讨论.2.1服务选择服务选择是服务计算领域中的一个重要研究方向,已经吸引了众多研究者的关注,并取得了许多显著的创新成果[6-16].服务选择以某一预定义组合模板作为输入,并定义模板中的结点为抽象服务类别.其目的是从众多功能属性相同但QoS不同的候选服务中选择满足用户要求的Web服务,将其作为服务实例与模板结点对应的服务类别进行绑定,使组合后的复合服务满足局部和全局QoS(GlobalQoS,GQ)的约束要求.针对动态变化的服务环境(如当服务失效或QoS变化时),一些服务选择的研究工作提出了相应的服务替换策略,如混合整数规划[8]、区域重配置[12]、整数规划[9]、启发式算法[10]、马尔可夫决策[11]、排队论[13]、遗传算法[14]、部分筛选(partialselection)[15]和服务关联分析[16]等方法重新绑定符合要求的新服务.但是,服务选择方法受限于预定义模板,其包含的服务类别和组合逻辑必须事先给出,因此无法根据动态变化的服务环境进行合理更改.与之相比,本文提出的方法能够处理模板中已定义服务类别之外的新增服务,并可根据当前服务网络的状态对复合服务的组合逻辑进行调整.此外,我们对动态服务进行实时监控,一旦动态服务发生,就主动对其进行处理,实现满足用户需求的复合服务的主动发现和更新.2.2自动服务组合自动服务组合通过重用互联网上来自第3方提供者的Web服务,对多个原子服务进行组合来构建功能丰富、多样化以及个性化的复合服务.每个复合服务定义了若干原子服务的组合逻辑和调用次序,并满足用户的功能性和非功能性需求.面对日益增长的服务数量,相关研究者提出了众多自动服务组Page4合方法[17-22]以解决人工服务组合所带来的费时、低效和易错等问题.上述自动服务组合方法均假定在服务静态不变的环境下,如何求取满足功能或服务QoS最优或近似最优的复合服务.例如,QSynth[17]旨在解决QoS最优的海量语义服务快速组合问题,通过输入查询请求,构建相应的复合服务.然而,每当服务动态变化时,这类方法必须对所有已构建的复合服务进行重新求取,效率十分低下(见第6节实验部分),因此并不可取.文献[23-24]提出利用人工智能规划的方法处理动态服务并对复合服务进行相应更新.然而,由于未考虑服务的QoS,这些方法通常不能保证更新后的复合服务依然满足非功能性需求.文献[25]提出了一种面向动态服务环境的服务组合方法,基于最短路径的图搜索算法搜索出链状的复合服务.但是,这种方法无法搜索出实际中存在的非链状复合服务,如可建模为有向无环图(DirectedAcyclicGraph,DAG)形式的复合服务(见第3.2节).文献[26-27]分别给出了面向动态环境的自动服务组合方法,然而,这些方法只关注服务功能性因素的变化(如服务接口的变化),而未考虑服务QoS这类非功能性因素变化的影响,难以推荐出满足QoS最优约束的复合服务.与上述两个工作相反,文献[28-29]专注于根据原子服务QoS的变化改善复合服务的服务质量,而未对服务功能性因素变化的情形给出解决方案.综合以上分析可知,面向动态服务环境且质量敏感的自动服务组合的相关研究较少,目前尚缺乏成熟完整的解决方案,需要有针对性的进行专门的研究.下节将介绍必要的预备知识,并据此定义本文要解决的问题.图1服务依赖图3预备知识与问题定义3.1相关术语介绍本文使用的相关术语及其定义见表3.术语服务QoSWeb服务(wi)查询请求R参数匹配Web服务匹配3.2服务依赖图为准确地表达Web服务集合中包含的依赖关系以及QoS等信息,我们使用服务依赖图G=(W,E)对表2所示Web服务进行建模,如图1所示.本文将基于此图进行质量敏感的自适应服务组合.在G中,节点集W表示Web服务集合,wk∈W,wk=(k,I,O,Q).其中,k是节点wk的标识,I和O分别表示wk对应的Web服务的输入参数集合和输出参数集合,Q为wk的QoS.有向边集E表示Web服务匹配集合,该集合满足:ek∈E,ek=(wu,wv,).其中,wu和wv分别是边的头结点(headtagekPage5node)和尾节点(tailnode),wu是wv的直接前继,wv是wu的直接后继,wu对应的方法匹配wv对应的方法.ek的标记tagek(1)tagek∈wu.O;(2)tagek∈wv.I.需要特别指出,当查询请求R发起时,图中将动态生成临时的起始节点Start和终节点End,如图1中两个椭圆形节点所示,它们满足:(1)(Start.I=)∧(Start.O=R.I);(2)(End.I=R.O)∧(End.O=).我们利用反向索引表存储和构建服务依赖图.本文将在4.1节将对此进行详述.与经典图论的节点可达性不同,G的节点可达性如下.定义1.节点的可达性.给定服务依赖图G=(W,E),在一次从起始节点Start开始的搜索过程中,wi∈W,wi可达当且仅当input∈wi.I,pi=〈Start,…,wi-1,wi〉,使得路径pi中的边e=(wi-1,wi,tage)满足tage=input.在定义1中,一个节点wi可达,不仅要求从Start到wi存在路径,而且要求存在从Start到wi的路径集合,使得该路径集合必须包含wi的全部输入参数作为Tag的入边.这不同于经典图论的节点可达性.在经典图论中,判断一个节点wi是否可达,只需判断从Start到wi是否存在路径即可.基于节点的可达性定义,本文提出的搜索算法在访问节点时遵循如下原则:若一个节点wi可达,则可访问wi的后继节点,否则,不能访问.因此,当wi输入参数还未被全部获取时,定义1中的可达性能够避免本文算法因调用该服务而错误地获取其输出参数.例如,在图1中,当从Start开始搜索时,首先找到路径p=〈Start,w4〉.然而,此时w4并不可达,原因在于w4的另外一个输入参数f作为Tag的入边未被p包含.3.3问题定义基于服务依赖图,文献[17]提出质量敏感的自动服务组合问题.定义2.最优质量敏感的自动服务组合问题.给定查询请求R和服务依赖图G=(W,E),加权函数ω:M→R表示从节点集合到实数集合的映射.从G中找出一个子图SG表示满足R的复合服务对应的子图.SG定义了其蕴含的服务(w1,w2,…,wn)的调用次序,这些服务满足下述条件:(1)wi.I∪(2)R.O∪子图SG的权重值是指SG包含节点的权重值的聚合值:ω(SG)=SG.GQoS.若令SGAll表示所有满足R的候选复合服务集合,则最优复合服务的GQ(GlobalQoS)定义为δ=Min{ω(SGi)|SGi∈SGAll}.SG满足下述条件:(3)ω(SG)=δ.需要指出,定义1中的条件(1)、(2)定义了复合服务需满足的功能性需求,即满足查询请求,而条件(3)则定义了复合服务需满足的非功能性需求,即其GQ为最优.为解决上述问题,QSynth基于t1时刻的服务依赖图搜索出复合服务以满足查询请求.当服务动态变化时,我们需对QSynth系统进行扩展,根据图中服务的最新状态持续更新已有的复合服务,保证其可用性.为此,本文提出了质量敏感的复合服务自适应问题.定义3.最优质量敏感的复合服务自适应问题.给定查询请求R,服务依赖图G=(W,E)和满足定义2中条件的复合服务SG.当G被动态更新为G=(W,E)时,自动更新SG为SG,使SG蕴含的服务依然满足定义1中的条件(1)、(2),同时保证SG的GQ最优性.3.4全局QoS计算规则本小节将进行说明服务依赖图中的GQ计算规则.该计算规则与QoS类型和图的组合模式相关.3.4.1QoS类型文献[30-31]将QoS分为两类:(1)否定型,即QoS值越大,服务QoS越差,比如响应时间和价格;(2)肯定型,即QoS值越大,服务QoS越好,比如吞吐量和声誉.同时,为了对多个QoS进行统一度量,按照度量方式的不同又可把QoS分为以下4种类型:(1)累加型,如响应时间.对于两个顺序调用的服务,其全局响应时间可由各服务的响应时间累加获得;(2)最小值型,如吞吐量,两个顺序调用的服务的全局吞吐量,由具有最小吞吐量的服务决定;(3)乘积型,如声誉、可靠性;(4)最大值型.文献[32-33]给出了更多可供参考的QoS类型及分类策略,本文不再赘述.3.4.2组合模式本文的复合服务自适应算法将返回相应子图表示满足需求的复合服务.多数情况下,这些子图Page6呈现为有向无环图DAG的形式.DAG中主要包含3种组合模式:顺序(Sequence)、合并(Joint)与分叉(Split),如图2所示.对于少量含有环的复合服务,本文将使用Unfolding方法[21]对环进行剔除操作.3.4.3GQ计算规则服务的GQ计算规则由图的组合模式(见图3)和QoS类型共同决定.以响应时间为例①,其作为服务的第j维QoS时的全局计算规则如表4所示②.模式顺序合并分叉首先,在顺序模式中,因为服务依次被顺序调用,所以采用累加型函数计算服务w的第j维QoS的全局聚合值,即最后一个被调用服务w的全局响应时间由其所有前驱的响应时间和w自身的响应时间累加获得.其次,在合并模式中,当服务w1-wn均已能够被调用时,才可调用服务w.因此,w的第j维GQ由w1-wn中第j维GQ最差的节点决定.同时又因为响应时间属于否定型,所以采用最大值函数和累加型函数计算服务响应时间的全局聚合值,即合并节点w的全局响应时间是所有前驱响应时间的最大值与其自身响应时间之和.最后,在分叉模式中,当w能被调用时,则可调用其分支节点w1-wn中的任一节点.因此可采用累加型函数计算GQ聚合值,即分支节点的全局响应时间由其分叉节点m的全局响应时间和其自身的响应时间累加得到.例1.以图1为例,利用表4中的GQ计算规则可得(Start节点的QoS———响应时间设置为0):w4.GQoS=∑(max{Start.GQoS,w2.GQoS},需要特别指出,若w的同一输入参数由两个以上的服务提供,则本文选择其最优提供者作为其前驱节点.任一可达节点的输入参数的最优提供者定义如下.定义4.节点输入参数的最优提供者.即该节点所有可达前驱中,提供该输入参数且GQ最小的前驱结点.其形式化定义如下:给定服务依赖图G=(W,E),wi∈W,inputi∈wi.I,inputi的最优提供者为popt,popt∈W,当且仅当popt满足:(1)popt.status=enabled;(2)popt.o=inputi;(3)popt.GQoS=Min{w.GQoS|w∈W∧例2.以图1为例,节点w7的输入参数h可由w3(status=enabled,GQ=700),w5(status=disabled,GQ=+)和w8(status=enbbled,GQ=300)提供,根据定义4,w7的输入参数h的最优提供者为w8.因此,w7.GQ=w8.GQ+w7.QoS=300+300=600.4质量敏感的复合服务自适应为处理动态变化的服务,我们将复合服务自适应算法集成到QSynth系统中,设计并实现质量敏感的自适应服务组合系统———QSynth+.如图3所示,该系统主要包含4个主要的工作步骤:(1)最优复合服务构建.解决质量敏感的自动服务组合问题(定义1),生成t1时刻满足用户查询请求且服务QoS最优的复合服务.同时,保存服务的中间状态信息,例如,在当前查询中,服务是否可达以及服务的GQ等信息.(2)动态服务监控与处理.监控发生变化的动态服务.同时,对动态服务进行分析,判断动态服务是否对当前已构建的服务依赖图和t1时刻的最优复①②Page7图3系统工作流程合服务产生影响.(3)服务依赖图结构更新.更新因动态服务的影响而发生结构变化的服务依赖图.例如,根据步骤2的监控结果,须将新增服务w9添加到图3(步骤3)所示的服务依赖图中.(4)复合服务自适应.解决质量敏感的复合服务自适应问题,根据需要自动更新复合服务.其基本处理流程是:首先,依据更新后的服务依赖图,找出图中受动态服务影响的服务并按照次序更新受影响服务的状态,例如GQ等;其次,判断复合服务是否受到动态服务环境的影响,即是否还满足用户查询请求和服务QoS最优;最后,利用反向搜索仅更新受影响的复合服务,而保留未受影响的复合服务.以图3(步骤4)所示的最优复合服务为例,由于新增服务w9亦提供其包含原子服务w8的输入参数g且w9在更新后的服务依赖图中可达,w8的GQ可能因w9的加入而发生改变.根据表4中的规则可知w9.GQ>w4.GQ(400>200).因此,w9为非参数g的最优提供者,最终不影响w8的GQ.综上,最优复合服务无需更新.下文将首先介绍QSynth+依赖的数据结构,然后分别对上述3个步骤进行详细介绍.4.1数据结构本文使用的数据结构包括反向索引表(InvertedIndexTable,IIT),服务节点(ServiceNode),可达前置表(ReachablePreconditionTable,RPT),如图4所示.反向索引表.表示和存储服务依赖图.表中的项为键值对(输入参数,节点列表).其中,键为参数,其值为需要该参数作为输入的节点列表.利用反向索引表,可避免传统的图存储结构(如邻接表和邻接矩阵)带来的计算复杂度较高的问题,从而能有效提升最优复合服务的搜索效率[17].服务节点.存储节点及其相关信息.本文使用七元组表示节点,具体形式为{wi,Iwi,Owi,Q,GQ,Count,Status}.其中,wi是节点对应Web服务的标识.Iwi和Owi分别表示节点的输入和输出参数集.Q表示节点自身的QoS.GQ表示从起始节点到当前Page8节点的GQ.Count用来记录节点需要的输入参数的个数,初始值设定为节点输入参数集的大小.Status表示节点的状态,默认状态为不可达,记为disabled.在算法执行过程中,如果Count值减为0,则令Status为可达态,记为enabled.需要特别指出,在执行过程中,算法将根据实际情况对相应节点的GQ,Count以及Status进行动态更新.可触发参数表.存储算法执行过程中可达节点的输入参数及其最优提供者的相关信息.需要指出,由于我们采用反向索引表构建服务依赖图.若记c为服务输入参数的平均个数,p为单个输入参数服务提供者的平均个数,n为服务依赖图中的节点总数,则构建服务依赖图的时间复杂度为O(n×c×p).利用反向索引表中记录的键-值对信息(输入参数-服务列表),可知与某服务接口参数匹配的前继服务和后继服务.由于服务的语义不是本文研究的重点,所以在本文的服务模型中,按照通常自动服务组合领域的惯例,我们对服务参数的语义进行了简化处理,服务接口之间的匹配是按照参数类型的匹配进行判断.例如,当一个服务A的输出参数是另一服务B的输入参数时(参见本文3.1节“参数匹配”和“服务匹配”),A和B就被视为匹配.此外,因为服务依赖图由数据结构反向索引表唯一定义和表达,所以服务依赖图也唯一.4.2最优复合服务构建为解决质量敏感的自动服务组合问题,我们利用基于前向搜索的Sim-Dijkstra算法生成最优复合服务的中间信息,然后利用后向搜索生成最优复合服务.4.2.1Sim-Dijkstra算法为求取最优复合服务,我们在之前的工作[18]中提出了Sim-Dijkstra算法.该算法的基本思想是根据查询请求,执行一次从始发端点Start到终止端点End的前向搜索,找出位于两端点之间所有状态可达的节点,并利用可达前置表存储和记录所有可达节点输入的最优提供者.例3.当不考虑动态服务时,以图3(步骤1)为例说明Sim-Dijkstra算法的执行过程,见表5.4.2.2后向搜索Sim-Dijkstra算法结束后,将获得存储在可达前置表中关于可达节点的相关信息.利用这些信息,可求取满足查询请求的最优复合服务.具体过程如下:从End到Start发起一次后向搜索.在搜索过程中,对于当前的节点,选择可达前置表中记录的该节步骤123w4(200);w3(700);w1(800)e(100,w2);f(100,w2)4w8(300);w3(700);w1(800)5w7(600);w3(700);w1(800)6End(600);w3(700);w1(800)点输入参数的最优提供者,并将其作为当前节点的前驱节点,直至反向回溯至Start节点.例4.利用表5中的RPT项,可构建图3所示的最优复合服务,具体过程见表6.步骤1234564.3动态服务监控与处理在QSynth+系统中,我们采用soapUI①对Web服务及其QoS进行监控和获取,然后按照文献[35]中阐述的方法从发布/订阅的网络中接收关于动态服务的事件.例如,当某个服务wi的响应时间超出指定阈值(如大于4s)时,相应的事件将动态生成并路由至系统中.对于接收到的动态服务,QSynth+按照不同的处理策略将其可分为4类,分别为:(1)新增服务(C1):服务依赖图中新加入的服务;(2)失效服务(C2):服务依赖图中已存在但当前不可用的服务;(3)接口变化服务(C3):服务依赖图中已存在但接口信息(如输入、输出参数)发生变化的服务;(4)QoS发生变化的服务(C4).根据分析可知,这些动态服务将会产生如下影响:(1)动态服务将引起服务依赖图结构的改变.因此,本文将相应地对存储服务依赖图的反向索引表和服务节点进行更新操作.例如,图3中的新增服务w9,其输入参数包括c和e.对于该服务,我们首先在服务节点中添加新表项,用于注册w9的相关信息,然后,根据参数c和e查找反向索引表中相应的表项,将w9添加到c和e对应的节点列表中.①http://www.soapui.org/Page9(2)动态服务将引发某些Web服务的状态变化,如GQ或可达状态的变化.例如,新增服务w9在更新后的服务依赖图中的状态为可达,因此w9可能影响其可达后继节点的GQ或可达状态.(3)动态服务将造成某些复合服务的失效或服务QoS下降.此时,必须对受影响的复合服务进行更新,以满足用户的功能性和非功能性需求.尽管利用QSynth重新查询一次可获取当前状态下最新的复合服务,然而每当出现新的动态服务时,QSynth就需要对所有存在的复合服务进行重新查询,效率极为低下,故不能采用.本文4.5节将给出效率更高的方式判断缓存中(已存在)的复合服务是否受到影响,从而决定是否对其进行更新.4.4服务依赖图结构更新算法由4.3节可知,4类动态服务会对服务依赖图产生影响.按照动态服务的类型,本文分别使用如下策略进行服务依赖图的更新:首先,对于新增服务,在服务依赖图中添加相应的节点;其次,对于失效服务,从服务依赖图中删除相应的节点;再次,对于QoS发生变化的服务,更新服务依赖图中相应节点的QoS值;最后,对于接口变化的服务,分为两步处理:(1)在服务依赖图中删除原有服务;(2)将服务作为新增服务处理.因此,按照上述方式,我们已将4类动态服务转换为3类动态服务.服务依赖图结构更新算法见算法1,其具体过程为:首先,处理接口变化服务,即将原有服务归类为失效服务,同时将接口变化后的服务归类为新增服务(第1~4行).其次,处理新增服务.算法将在反向索引表和服务节点中添加其对应的表项(第5~15行).再次,处理失效服务.算法将从反向索引表和服务节点中移除相应表项(第16~23行).最后,处理QoS发生变化的服务.算法将更新服务节点中相应节点的QoS(第24~26行).算法1.服务依赖图结构更新算法.输入:原始服务依赖图IIT&Nodes输出:新服务依赖图//处理接口变化服务集合C31.FOREACHServiceu∈C32.C1.add(originalu);3.C2.add(changedu);4.ENDFOR//处理新增服务集合C15.FOREACHServicev∈C1do6.Nodes.add(v);7.FOREACHpar∈v.Ido8.entryIIT.findByKey(par);9.IFentry≠THEN10.listentry.nodeList;11.list.add(v);12.ELSE13.IIT.addNewEntry(par,v);14.ENDFOR15.ENDFOR//处理失效服务集合C216.FOREACHServicew∈C2do17.Nodes.remove(w);18.FOREACHpar∈w.Ido19.entryIIT.findByKey(par);20.listentry.nodeList;21.list.remove(w);22.ENDFOR23.ENDFOR//处理QoS变化服务集合C424.FOREACHServicex∈C4do25.x.updateQoS();26.ENDFOR4.5复合服务自适应算法当接收到动态服务事件后,QSynth+利用复合服务自适应算法根据实际情况生成新的最优复合服务.该算法的基本思想是:首先,判断服务依赖图中的动态服务是否影响其他服务的状态.如果动态服务的加入或删除不影响其他服务的状态,则无需更新其他服务的状态,否则,需要从动态服务开始,在服务依赖图中依次更新受影响服务的状态.其次,若原有复合服务包含受影响的服务,则需要对此复合服务进行更新,否则,可维持原有复合服务不变.复合服务自适应算法见算法2,其具体步骤如下:(1)分析动态服务的影响,识别出可能引起其他服务状态变化的动态服务(第1~12行).具体而言,一方面,对于新增服务,当服务依赖图添加该服务后,重新获取其GQ.新的GQ将存储到newGQ变量中,newGQ初始值为+.若新增服务的newGQ不等于+,则该服务加入服务依赖图后,将可能会影响其后继节点的状态.例如,该服务不可达的后继节点可能因新增服务节点变为可达.另一方面,对于失效服务与QoS变化的服务,若其原始的GQ不等于+,则该服务节点的删除或QoS更新会影响其可达后继节点的状态.例如,当失效服务节点被删除后,其原本处于可达状态的后继节点可能变为不可Page10达.当服务QoS变化后,其可达后继节点的GQ将可能会受到影响.(2)更新受影响服务的状态(第13~26行).在该步中,算法首先利用优先队列PQ存储第一步中识别出的可能影响其他服务状态的动态服务.然后,循环弹出PQ中的服务并进行相应处理.定义pqQoS=min(newGQ,GQ).受Dijkstra算法启发①,算法2按照pqQoS从小到大顺序依次更新服务状态,即PQ优先弹出pqQoS最小的节点.这种更新顺序可避免服务状态的反复更新.以图3为例,假设w2和w4是动态服务,其QoS发生了变化.若先更新w4,接着处理w8,w7和End,则当更新w2时,会引起w4,w8,w7和End的再次更新.一种较好的更新次序应为:先更新w2,然后依次处理w4,w8,w7和End.利用优先队列PQ,算法2可有效避免上述示例中服务状态的冗余更新.本文第5节将对此进行详细讨论.对于每个弹出的服务,在当前服务依赖图中重新获取其输入的最优提供者.若其输入的最优提供者发生变化,则更新相关RPT表项.此时,由于该服务的直接后继节点可能受到上述更新的影响,算法2将把这些后继节点放入PQ中等待下次处理.(3)当优先队列中所有服务处理完毕时,根据需要生成新的复合服务(第27~32行):①若End节点的GQ变为+,则表明查询请求已不能满足.此时,算法2无法生成新的、可供替换的复合服务;②若End节点的GQ不等于+,则检查原有复合服务是否包含受影响的服务(即GQ发生变化的服务).如果包含,就需要反向生成新的复合服务,否则保留原有复合服务不变.算法2.复合服务自适应算法.输入:新服务依赖图IIT&Nodes输出:新最优复合服务SC//识别可能影响其他服务的动态服务1.FOREACHServiceu∈C1do2.u.GQ+;3.u.newGQu.getGQ();4.IFu.newGQ≠+THEN5.PQ.add(u);6.ENDIF7.ENDFOR8.FOREACHServicev∈C2∪C4do9.IFv.GQ≠+THEN10.PQ.add(v);11.ENDIF12.ENDFOR//更新受影响服务状态13.WHILEPQ≠do14.wPQ.popOpt();15.FOREACHpar∈w.O16.newProvidergetOptP(par);17.IFpar.provider≠newProviderTHEN18.entryRPT.findByKey(par);19.IFentry≠THEN20.entry.optGQnewProvider.GQ;21.entry:providernewProvider;22.ENDIF23.PQ.add(w.directSuccessors);24.ENDIF25.ENDFOR26.ENDWHILE//复合服务更新27.IFEnd.GQ=+THEN28.Returnnoresults;29.ENDIF30.IFServicex∈SCx.GQ≠X.newGQTHEN31.ReturnSCbybackwardsearch;32.ENDIF例5.如图3(步骤4)所示,当新增服务w9加入到服务依赖图中时,表7给出了复合服务自适应算法的具体过程.从表7中可以看出,尽管w9也提供了最优复合服务,包含原子服务w8的输出参数g,但是该最优复合服务未受到影响,因此无需更新.步骤1235自适应算法分析本节首先分析了复合服务自适应算法(算法2)①令v为始发节点,为解决单源最短路径问题,Dijkstra算法Page11的时间复杂度,然后给出算法重要性质的定义及证明,最后讨论了算法需要的额外开销.5.1时间复杂度记c为服务输入参数的平均个数,m1、m2、m3和m4分别为新增服务数、失效服务数、接口变化服务数和QoS变化服务数,k为优先队列PQ中服务节点的最大数目.若记n为服务依赖图中的节点总数,则推断出nc为服务依赖图中边的数量.算法2第1行到第12行的时间复杂度是O(m1×c+m2×c+2m3×c+m4×c)=O(m×c),其中m为动态服务总数.算法2第13行到第26行对PQ中服务的处理操作的时间复杂度为O(klogk+kkc).其中O(klogk)为维护优先队列①的开销,O(kkc)为处理每个节点的开销.算法2中第27行到32行调用后向搜索的时间复杂度为O(nc+n).综上,算法2的时间复杂度为O(m×c+klogk+kkc+nc+n).5.2算法性质定理1.可终止性.算法经过有限步后停止.证明.在算法2中,当优先队列为空时,算法将终止.因为每个服务节点最多放入优先队列中一次,所以该队列最大值为n.每次循环算法均会弹出队列中的元素,故最多经过n步后,算法将会终止.定理2.完整性.在动态服务环境下,只要存在满足查询请求的复合服务,复合服务自适应算法就能够将其找出.证明.若查询请求可被满足,则End节点可达,即End节点的GQ不等于+.算法2依据不同类型的动态服务对其受影响服务的状态进行相应更新,仅按照pqQoS调整可达服务节点的更新顺序,而没有剪枝或剔除任一可达服务节点.因此,只要End节点可达,算法2就可找出能够抵达End节点的复合服务.定理3.最优性.复合服务自适应算法得到的复合服务SC是GQ最优的.证明.假设存在一复合服务SC,SC.GQ<SC.GQ,即SC优于SC,等价于至少存在参数par,其提供者为服务w和w,其中,w∈SC,w∈SC,且w.GQ<w.GQ.由题设可知算法2返回SC而非SC.同时,根据算法2第10行,算法总是取par的最优提供者,因此算法2返回SC表明w.GQ<w.GQ,与假设矛盾.定理4.单次更新性:复合服务自适应算法对受影响的服务只进行一次状态更新.证明.设存在两个动态服务w1和w2,且w1.pqQoS<w2.pqQoS.根据算法2第8行,算法先更新w1的GQ,再更新w2的GQ.假设更新w2后,w1的GQ受到影响,需要再次更新,则表明w2位于某一从Start节点到w1的路径中.因为在这种情况下,w2的GQ更新才会传播影响到w1的GQ.根据算法2可知:首先,对于所有新增服务,根据算法2第2行,其对应的GQ原值———GQ=+;其次,对于所有失效服务,由于这些服务将从服务依赖图中删除,其对应的GQ新值———newGQ=+.综上,可得(1)若w1∈C1,w2∈C1,则(2)若w1∈C1,w2∈C2,则:(3)若w1∈C1,w2∈C3,则:(4)若w1∈C2,w2∈C1,则:(5)若w1∈C2,w2∈C2,则:(6)若w1∈C2,w2∈C3,则:(7)若w1∈C3,w2∈C1,则:(8)若w1∈C3,w2∈C2,则:(9)若w1∈C3,w2∈C3,则:上述9种情形可囊括所有动态服务类型.以第1种情形为例,当w1,w2均被加入到服务依赖图中后,由于w2位于某一从Start节点到w1的路径中,根据3.4节中QoS的计算规则易得w1.newGQ>w2.newGQ.因为①本文采用Relaxedheap实现优先队列.Page12w1.pqGQ=min{+,w1.newGQ}=w1.newGQ;w2.pqGQ=min{+,w2.newGQ}=w2.newGQ.所以有w1.pqGQ>w2.pqGQ,与假设矛盾.以此类推,易得所有9种情形均与假设矛盾.证毕.5.3额外开销算法2的额外开销包括:(1)不仅要存储Sim-Dijkstra算法返回的最优提供者信息,还需要存储其他非最优提供者信息.例如,当最优提供者失效时,自适应算法可利用其他提供者生成当前状态下的最优结果.总之,算法2需要存储额外的服务节点的状态信息、RPT表项等;(2)需在数据结构中添加newGQ和pqQoS两个新变量.尽管上述开销使得算法2需占用更多的存储空间,但是无需从头开始搜索和求取满足用户需求的复合服务.在多数情况下,算法2只需更新少量受影响服务的状态,与重新查询相比,效率更高,从而能够满足实时响应的需要.本文第6节对此进行了实验验证.6实验6.1实验设置为应对动态服务,基于复合服务自适应算法,本文实现了QSynth+系统来进行自适应服务组合.实验设置介绍如下.对比系统:(1)QSynth,每当动态服务发生时,表8测试数据集4(5),8(4.4),12(4.3),第1组:不同参数类型总数第2组:不同复合服务层数第3组:不同服务总数第4组:不同动态服务总数评估指标:为了对相关系统进行评估,本文采用如下3个的评价指标、效率、敏感性和准确性来对系统的优劣进行统一衡量.具体而言,效率用来评估服务依赖图的构建时间和系统的响应时间,即系统从接收到动态服务到生成新的复合服务所消耗的时间.敏感性:衡量系统对QoS变化程度是否敏感,即QoS变化是否对系统效率造成剧烈影响.准确性用来测试系统返回的复合服务是否满足查询请求和服务QoS最优的要求.实验环境为2.4GHzCPU,4GBRAM,Windows7操作系统.重新执行查询;(2)QSynth+,扩展后的QSynth系统,使用复合服务自适应算法动态更新复合服务;(3)QSynth+,使用无优先队列版本的复合服务自适应算法的系统,以不考虑服务更新次序的方式执行复合服务自适应算法.测试数据集:(1)人工数据集:利用公开的WebServiceChallege测试集生成器①生成测试数据集.利用该测试集生成器的可调参数,即服务数目,服务输入参数类型数目和复合服务层数(一般而言,层数越多,则复合服务越复杂),我们生成了包含不同参数类型数量、不同层数、不同服务数和不同动态服务数的测试集,见表8;(2)真实QoS数据集,采用文献[36]提供的数据源,我们搜集并整理了2000个真实服务在不同时刻的QoS,并提取其中的响应时间赋值给测试集生成器生成的服务集合②.实验中,我们将在每个测试集中按照随机方式生成动态服务.在真实QoS数据集中,我们根据真实服务的QoS变化设置动态服务的QoS.每个测试集包含如下3个文件:WSDL(描述服务及接口信息),OWL-S(描述概念(参数类型)信息),WSLA(描述服务的QoS信息).上述3个文件是描述Web服务的国际标准,进行实验对比的3个系统将分别读取这些文件以及描述查询请求的查询文件,处理动态服务并求取新的满足查询请求且服务QoS最优的复合服务.8(4.4)8(4.4)8(4.4)实验方法在表8给出的4组测试数据集中,由于数据集中的动态服务是按照随机方式生成的,实验中存在随机因素.为了消除最终实验结果的随机性,我们在不同数据集上进行了多次独立地实验.具体而言,针对任意一组数据集,我们分别对不同系统进行了10次测试.每次测试中均按照随机方式生成①②Page13动态服务.最终,实验将选取10次测试结果的平均值作为最终实验结果.6.2效率评估6.2.1服务依赖图构建时间评估本文算法基于服务依赖图搜索最优的复合服务.服务依赖图的创建是算法高效运行的前提.图5(a)和图5(b)分别给出了在不同参数类型总数和不同服务总数下的服务依赖图的创建时间.从图中可以看出,随着参数类型总数和服务总数的增加,服务依赖图的创建时间也在不断增大.这是因为图的复杂性与服务节点和参数类型的数目相关.从图5中可以看出,当参数类型总数或服务总数达到万级规模时,图的创建较为高效,其时间消耗均在6000ms之内.6.2.2系统查询响应时间的评估本文实验采用人工生成服务的QoS和真实服务的QoS,分别在表8所示的4组测试数据集上对QSynth、QSynth+和QSynth+进行了效率评估.由图6可知,总体上,QSynth+性能最优,其查询响应时间平均仅为QSynth查询响应时间的10%~40%.这是因为每当动态服务产生时,QSynth均需重新执行查询,从头开始搜索整个服务空间,而QSynth+只需要更新部分受动态服务影响的服务状态,无需搜索整个服务空间.因此节省了时间消耗.同时,相比于QSynth+,QSynth的查询响应时间平均提升了4%~30%.这是因为QSynth+使用的复合服务自适应算法未考虑服务的更新次序问题,因此会消耗额外的时间对受影响的服务进行多次、反复地更新.此外,我们综合图6所示的4组测试数据集上的实验结果对系统效率依赖的4个重要因素,即参数类型总数、复合服务层数、服务总数以及动态服务总数的影响分别进行了分析.结果如下:如图6(a)所示,当参数类型总数由1000增长到25000,复合服务层数、服务总数和动态服务总数分别固定为8、6000和100时,3个系统的查询时间消耗不随参数类型总数增长而呈现线性增长的趋势,这表明系统相关的算法复杂度并不直接依赖于参数类型的数量.根据本文第5节以及文献[18]中关于算法复杂度的分析,文本算法的时间复杂度主要取决于动态服务的数量,而QSynth的算法复杂度则与图中服务节点的总数以及边的数目相关.如图6(b)所示,当复合服务层数由4增长到24,参数类型总数、服务总数和动态服务总数分别固定为15000、6000和100时,3个系统的查询时间消耗在总体上呈现增长趋势.因为一般而言,层数越多,则复合服务越复杂,系统耗费的查询时间也应该越多.然而,当复合服务层数为20时,各系统查询的时间消耗反而比复合服务层数为12和16时更低.对此我们进行了分析,并在表8第3列给出了各复合服务每层的平均服务数(四舍五入).由此可得,测试集中20层的复合服务尽管层数较多,但相比12层和16层的复合服务,其包含的服务节点总数较少.根据本文第5节以及文献[18]中关于算法复杂度的分析,3个对比系统的时间复杂度分别取决于动态服务的数量和图中服务节点的总数以及边的数目,而非直接取决于复合服务层数.因此,在实验中,尽管复合服务层数为20,但是其包含的节点总数相对较少,因此各系统查询的时间消耗相对较低.如图6(c)所示,当服务总数由1000增长到10000,参数类型总数、复合服务层数和动态服务总数分别固定为15000、8、100时,QSynth的查询响应时间明显依赖于Web服务集的规模———服务数量越大则查询响应时间越长.这是因为每当动态服Page14务产生时,QSynth均需重新执行查询,从头开始搜索整个服务空间,因此查询的响应时间主要取决于服务数量的大小.而对于QSynth+和QSynth+,其查询响应时间不明显依赖于Web服务集的规模.这是因为复合服务自适应算法只需要更新部分受动态服务影响的服务状态,无需搜索整个服务空间.因此,当服务数量呈现增长趋势时,其响应时间未随之明显增大.如图6(d)所示,当动态服务总数由50增长到500,参数类型总数、复合服务层数和服务总数分别固定为15000、8、6000时,3个系统的查询的总体时间消耗均呈现上升的趋势.其中,QSynth的增长幅度较大,而QSynth+和QSynth+的增长幅度较小.这是因为对于QSynth而言,每新增一个动态服务,意味着增加一次搜索整个服务空间的时间,因此时间消耗的增长幅度较高.与之相比,当动态服务发生时,由于QSynth+和QSynth+可避免重新搜索,消耗时间较少,因此增长幅度也较低.此外,从图7可以看出,各系统在真实QoS服务数据集上的表现与上述实验结果类似.图6和图7给出的QSynth+和QSynth+的查询时间消耗是服务依赖图更新与自适应算法执行时间的总和.实验中,我们还跟踪和记录了不同数据集上服务依赖图更新的性能,其时间消耗稳定在1ms~5ms之间.相比总体时间消耗,所占比例很低.图更新的低耗时与其采用的存储结构———反向索引表密切相关:本文的图更新算法的执行时间主要取决于动态服务包含的参数个数,而访问反向索引表中参数对应数据项的时间复杂度仅为O(1).因此,图的更新较为高效.为了分析动态服务对其他服务的影响,当层数为8、参数类型数为15000、服务数为6000、动态服务数为100时,我们在图8中给出各系统处理单个动态服务的查询响应时间.从图7可以看出,QSynth处理每个动态服务的时间较多而总体方差较小,而QSynth+和QSynth+处理每个动态服务的时间较少但总体波动较大.这一结果表明:(1)每个动态服务的影响区域不同,因此使用复合服务自适应算法系统的处理时间变化较大;(2)每个动态服务的影响区域有限,因此使用复合服务自适应算法只需更新相对更少的受影响服务的状态,从而获得比重新查询更高的效率.我们还考察了QSynth+在批处理方面的性能.当层数为8、参数类型数为15000、服务数为6000Page15时,如图9所示,QSynth+一次性处理50~600个动态服务时间消耗为14ms~28ms.这一结果远远低于每次仅处理一个动态服务的处理方式所耗费的时间(2880ms①).然而,当一次处理的动态服务数量超过500时,使用QSynth进行重新查询反而效率更高.这一结果表明,当一次性处理的动态服务数量超过某一阈值(如500)时,可选择使用重新查询的方式.然而,在实际中,同一时刻产生大量动态服务的情况并不多见,因此多数情况下选择QSynth+会获得更高的效率.6.3敏感性评估本节我们重点针对QoS变化是否对系统的查询响应时间造成影响进行了分析和比较.从图10中可以看出,当层数为8、参数类型数为15000、服务数为6000、动态服务数为100时,动态服务的QoS分别增加10ms、50ms、100ms、200ms和300ms时,QSynth+响应时间的波动范围为402ms~513ms,①由图7可知,Qsynth+处理单个动态服务的平均时间为Page16QSynth+响应时间的波动范围为484ms~591ms,QSynth响应时间的波动范围为2159ms~2297ms.这一结果表明,当QoS发生变化时,被评估的3个系统的效率均未产生较大波动.因此,它们对QoS的变化并不敏感.6.4准确性评估本节评估各系统的准确性,即其返回的复合服务是否满足查询请求且保证全局QoS最优.一方面,我们认真检查各系统返回的复合服务,核对复合服务中包含的原子服务是否均可触发,即复合服务是否可执行以满足查询请求.另一方面,QSynth系统已被理论和实验证明其返回的复合服务是全局QoS最优的[18],并且在动态更新后的图中搜索不影响其最优性.因此,通过比较QSynth返回结果的全局QoS与其他系统返回结果的全局QoS是否相等,即可判断当前系统返回的复合服务是否是全局QoS最优的结果.我们对6.3节实验中相关系统返回的所有结果都进行了上述两方面的检验.结果显示,QSynth+和QSynth+返回的复合服务与QSynth的返回结果一致且均可正确执行,同时全局QoS相等.这表明基于复合服务自适应算法的QSynth+能够应对动态变化的服务环境,根据需要自动地更新复合服务,保证更新后的结果仍然满足查询请求且全局QoS最优,系统准确率为100%,进一步验证了第5节中给出的算法性质.7结论针对动态变化的服务环境,本文对质量敏感的自动服务组合系统QSynth进行了扩展,设计并实现了一个新的复合服务自适应系统———QSynth+.在该系统中,我们引入了事件驱动机制并提出了一种新颖的复合服务自适应算法,使其能够主动地处理各种不同类型的动态服务,同时避免搜索整个服务集合空间,仅更新部分受影响服务的状态,有效地提升了系统的效率.此外,QSynth+不仅支持服务的1-1替换,而且能够根据需要变更复合服务的组合逻辑,以支持服务的n-m替换.与已有方法相比,QSynth+采用的数据结构更加复杂,并需存储中间的搜索结果(参见5.3节),这是它的代价.然而,本文提出的算法具有最优性和完整性,并且通过重用已有的中间搜索结果,仅对局部受影响服务进行更新,无需重新搜索整个服务空间.实验结果表明,在服务总数达到万级规模时,其依然能够保证算法的执行时间在500ms~600ms之间,并且在不同的测试集上均能准确反映用户的功能性和非功能性需求,具有较高的系统响应速率和较好的可扩展性.本文只针对统一语义框架下服务的自动组合问题展开相关研究.然而,现实中的服务匹配往往异常复杂.对于同一个意义,不同服务可能存在不同的表述方式.例如,在描述服务信息的WSDL文件中,关于“城市”这个概念,不同的服务提供者可能使用形式完全不同的词汇(例如“city”和“town”)进行描述.为了避免现实问题因过于复杂而无解,我们采用科学问题常用的研究策略,在某些方面做了一定的简化处理,比如本文简化了语义和服务匹配,然后抽象出问题模型,并进一步提出解决方法.自动服务组合是学术界较为关注且算法研究较多的领域.在这个领域中,相关的研究工作通常都对现实问题进行了一定程度地简化,例如将其抽象为“最短路径”或“最优DAG”等图论问题.此外,这些抽象出的问题不仅可用于服务组合,也可应用于其他领域,例如供应链领域.在供应链领域,一个相似的问题是如何根据不同的目标(例如最小费用、最短生产周期),选择合适的原材料和加工厂完成产品的制造.因此,本文抽象出的问题模型不仅可以用于自动服务组合,也可以应用于其他领域.在未来的工作中,我们将主要从以下两个方面进一步加强研究:(1)根据实际需要,在算法中引入更多维度的QoS,深入研究多维QoS场景下复合服务的自适应机制;(2)目前QSynth+仅针对最优(Top1)复合服务进行自适应更新.为了在动态服务环境下更好的满足用户的偏好(如中国大陆用户通常选择百度搜索服务而非谷歌搜索服务)以及解决负载均衡(避免过分使用热门复合服务或原子服务)等问题,我们将进一步对支持Top-k查询的Page17QSynth系统[18]进行扩展,研究并解决前k个最优复合服务的自适应问题.
