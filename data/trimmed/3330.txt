Page1基于相点分析的移动数据索引技术叶小平1)郭欢2)汤庸1)陈罗武2)周畅1)廖青云1)1)(华南师范大学计算机学院广州510631)2)(中山大学计算机科学系广州510275)摘要一维(有效)时间区间(VT)和二维最小限定矩形(MBR)是移动数据基本的时空单元,两者性质不同,应用中也有差异.现有移动数据查询通常是将相关数据转换为高出原空间情形“一维”的空间数据,其优势在于可充分使用现有空间数据索引技术.文中主要贡献在于研究基于过去和当前时间查询的移动数据索引模式,该索引模式能够表征时空各自特性并实现时空模块的整合配置.首先,文中将有效时间期间VT和空间MBR统一描述为广义区间,并通过区间数将其转化为平面上相点,实现了数学上的整合表述与刻画;同时,根据VT和MBR各自反映的时空特征,引入了基于时态拟序的时间相点线序划分和基于扩展KD-tree的空间相点MBR分类,建立时空相点分析基本框架;然后,在相点分析框架内实现时间和空间索引模块组建和整合配置,实现了移动数据索引模式Modim;另外,研究了基于当前与现在时间Modim数据查询以及索引增量式更新算法,并建立相点编码方案以实现最终查询结果的重构;最后,设计相关仿真以实现对Modim性能评估,与现有相关工作进行基本比较的结果表明文中工作是可行的和有效的.关键词广义区间和相点分析;移动数据索引;基于过去与当前数据查询;增量式动态更新1引言时空数据具有时间和空间双重特征.时间特征通常通过时间期间(period)例如有效时间期间VT描述;空间特征通过近似基本图形例如最小限定矩形MBR描述.VT和MBR分别是欧氏空间中一维和二维基本图形,两者差别较大,在实际应用中,数据实体的时间和空间特征信息相互关联,需要统一刻画和管理.自20世纪90年代初期以来,作为一种处理时空对象的新型数据管理技术,时空数据库(STDB)迅速兴起发展.进入21世纪,随着车载定位设备、PDA和移动电话等无线移动定位技术设备快速发展,移动数据管理的应用需求越来越迫切,涉及领域也越来越广阔,相关研究已经成为STDB研究热点,并形成对移动数据(位置信息随时间变化的空间实体)进行管理的专门研究领域———移动对象数据库(MovingObjectsDatabases,MOD).移动点对象空间特征由空间点来描述,随着时间变化相应空间点在三维时空(x,y,t)中形成的曲线称为轨迹线(trajectory).为了便于进行数据库处理,人们提出采样处理和函数描述两种方式来处理轨迹线[1].MOD需要管理庞大移动数据,为了减小搜索空间,提高查询性能,研究和开发有效的数据索引已成为MOD数据查询的基本途径.从时态角度考虑,现有索引可分为基于过去、基于过去和当前以及基于当前和未来位置信息的三种类型.基于过去时间索引主要有基于传统空间索引[2-4]、基于多版本结构与重叠技术索引[2,5-7]及面向移动对象轨迹查询等[4,8-9];基于过去和当前时间索引主要有2+3R-tree等[10-14];基于当前和未来时间的预言性索引主要有PMR-Quadtree等[15-18].上述工作具有以下特征:(1)基于过去时间数据索引是MOD数据查询的基础.对于数据库而言,其管理对象主要是已经成为事实的数据实体即历史数据,它们既是数据库海量数据的主体,也是确定当前数据和预测未来数据的基础.在实际应用中,通常会出现大量的和经常性的对移动对象在过去某时间位置的回溯查询.(2)数据库本质上不能存储和管理基于当前和未来时间的数据,在实际过程中,只能根据过去信息对其进行“判断”或“预测”,其结果具有某种不确定性.在基于过去和当前时间索引中,主要使用过去信息对“当前”进行判断;在基于当前和未来索引中,则将移动对象位置表示为时间函数进行未来预测,这两种模式本质上应该不属于数据索引范畴,但移动数据频繁更新和应用需求会导致在“过去”、“当前”和“未来”之间进行常规性转换、参照与整合,实际应用的推动和理论研究的挑战使得它们成为当前MOD领域的热点.(3)与时空数据索引类似,现有移动数据索引工作主要是从空间角度出发,将时间看做新增空间维,将移动数据看做是比原有空间更高一维的纯空间数据.由此可充分借鉴空间数据索引技术特别是R树技术,有效展开相关研究与应用开发.但如何更好体现一维VT和二维MBR之间的差异还有待探讨.例如,时间总是一维的,而空间是多维的;时间维是单向而空间维是双向;时间维有有效时间维和事务时间维之分,而所有空间维却无本质上差异等.“二维”空间和“一维”时间组成的三维“时空”和三维“纯”空间不完全等同,这种本体差异会影响相关索引技术的查询效率,有必要将移动对象的时间和空间属性进行区别处理和有效整合.本文主要贡献是从时间和空间信息配置整合出发,研究一种基于过去时间的移动对象数据索引技术,该索引辅助以适当机制,还可实现基于过去和当前时间的移动数据查询.首先,本文建立时空信息统一分析处理的数学框架,即将时间区间VT和空间MBR分别看做一阶和二阶“广义”区间,并通过一阶和二阶区间数(一阶区间数的有序对)将其转换为相平面上的一阶和二阶相点,从而将数据时间和空间信息进行“统一”描述和分析;其次,建立基于相点分析的索引实现机制,即通过引入时态拟序建立时间相点划分,通过基于MBR分类的扩展KD-Tree完成空间相点划分;第三,按照“先时间再空间”方式,通过较为精细的方式研究了基于“区间套接”的Page3时间和空间索引配置机制,建立一种基于时空整合的移动对象过去和当前数据索引模型Modim,讨论了基于Modim的数据查询和更新算法,同时研究基于相点编码的最终查询结果重构;最后,通过采用适当数据进行基本仿真,完成了Modim与现有相关工作的比较评估,其中包括查询仿真、更新仿真以及索引空间耗费和整合机制仿真,实验结果表明了本文工作的可行性和有效性.本文研究实际上涉及时态信息和应用场景的有效整合.由于一般时态数据管理通常都需要有效处理数据时态信息和应用过程本身确定的场景信息,例如时态对象数据中的时态和面向对象场景、时态XML数据中的时态和文档结构场景、时态数据空间中的时间和多种共存的实际场景等,因此,本文工作对此类问题的讨论也可提供借鉴.本文第2节讨论时间相点与空间相点分析,为时空分析提供基本数学框架;第3节研究移动对象数据区间树型模型Modam和基于Modam的索引模式Modim;第4节讨论基于Modim数据操作(数据查询和索引更新);第5节完成实验仿真和基本评估.2相点分析在二维欧氏空间中,坐标轴上区间[x1,x2]([y1,y2])称为一阶区间;两条相邻边分别平行于坐标轴的矩形称为二阶区间.设(x1,y1)和(x2,y2)分别为二阶区间w的左下和右上顶点坐标,则可将w看做两个一阶区间[x1,y1]和[x2,y2]的有序对,即w=([x1,y1],[x2,y2])并简记为w=[x1,y1;x2,y2].一阶和二阶区间统称为广义区间(generalintervals),其意义在于可将其转换为“区间数”和“区间数对”.定义1(一阶区间数和一阶相点).一阶区间w=[x1,x2]对应的一阶相点R1(w)=R1([x1,x2])=(x1,x2)=(Sta(w),End(w)),Sta(w)=x1,End(w)=x2分别称为相点R1(w)的水平与竖直坐标.一阶区间w=[x1,x2]对应的一阶区间数Fnum(w)=Lnum([x1,x2])=f1(x1,x2)×10α+f2(x1,x2),其中,f1和f2分别是关于[x1,x2]的1-1映射函数,α是所涉及一阶区间端点数最大者的数位.一阶区间、一阶区间数和一阶相点相互唯一确定.定义2(二阶区间数和二阶相点).二阶区间w=[x1,y1;x2,y2]对应的两个二阶区间数(secondintervalnumber)S1([x1,y1;x2,y2])和S2([x1,y1;x2,y2])如下:S1(w)=S1([x1,y1;x2,y2])S2(w)=S2([x1,y1;x2,y2])其中,s11,s12和s21,s22分别是x1,y1,x2,y2的函数,α是所涉及二阶区间端点数最大者的数位.二阶区间w=[x1,y1;x2,y2]对应的二阶相点定义为两个二阶区间数的有序对:理论研究和实际应用中的数据对象通常会涉及到一阶区间之间或二阶区间之间的相交、相离、包含等各种关系,其中比较基本的是包含关系,在一定意义下,其它关系可转化为包含关系.以下以相点分析为基础,研究区间之间的包含关系.2.1一阶相点分析设数据u的区间属性Intval(u)为一阶区间[Sta(Intval(u)),End(Intval(u)),其中,Sta(Intval(u))End(Intval(u)).所考虑区间集合记为Γ.在不引起混淆时,本文除特别说明,Γ可同时表示数据点集合与相应区间集合,u可同时表示数据点与相应区间Intval(u),并且简记Intval(u)=[Sta(u),End(u)).2.1.1相点关系间关系:定义3(区间关系).在Γ上引入如下两个区(1)uvIntval(u)Intval(v),其中u,v∈(2)u~v(Sta(u)<Sta(v))∨(Sta(u)=Sta(v)∧End(u)End(v)),其中u,v∈Γ,u=Intval(u)=[Sta(u),End(u)),v=Intval(v)=[Sta(v),End(v)).可验证,“”和“~”是Γ上满足自反性和传递性的拟序关系(pseudo-order),本文同时以Γ表示相应拟序集.当拟序是线序时,则称其为拟线序(pseudo-linearorder),简称线序(linearorder).定义4(拟序矩阵).设u=Intval(u)=[Sta(u),End(u))=[i,j),i1iin,j1jjm,i1=minΓ{Sta(u)},in=maxΓ{Sta(u)},j1=minΓ{End(u)},jm=maxΓ{End(u)}.uij=[i,j)=ij看作在i-j平面上的点,由Γ在i-j平面确定的如图1所示(反上三Γ;若(uv∨vu),则称u,v互不相容Page4角)矩阵称为基于Γ的拟序矩阵并记为TOM(Γ).对ui0j0∈TOM(Γ),通过ui0j0将TOM(Γ)分为4个区域:UL(ui0j0)={vij|ii0,j0j},UR(ui0j0)={vij|i0i,j0j},DL(ui0j0)={vij|ii0,jj0}和DR(ui0j0)={vij|i0i,jj0}.上述各式中如果仅“<”成立,则称相应区域为开区域并分别记为OUL,OUR,ODL和ODR.易知,TOM(Γ)=UL∪ODL∪DR∪OUR.同时,给定一个线序分支L,可以将时态矩阵划分为4个闭区域UL(L)=UL(maxL),UR(L)=∪vi∈LUR(vi),DL(L)=∪vi∈LDL(vi)和DR(L)=DR(minL),相应的开区域可类似定义.定理1(拟序矩阵性质).u0,v0∈TOM(Γ),(1)u0v0v0∈UL(u0);(2)v0u0v0∈DR(u0);(3)u0,v0不相容v0∈OUR(u0)∨v0∈ODL(u0).证明.(1)设u0=[i0,j0),v0=[k0,l0),u0v0k0i0,j0l0v0∈UL(u0).同理可证(2)和(3).2.1.2线序划分定义5(线序划分).设LΓ,L为Γ中线序分支(LinearOrderBranch,LOB)u,v∈L,uv∨vu∨v=u.L中最大、最小元分别记为maxL和minL.设Δ是LOB组成的集合且∪Li∈Δ称Δ为Γ的一个线序划分(LinearOrderPartition,LOP).{u1,u2,…,un}.令i=1,j=1;算法1.LOP并行算法———下优先算法.输入:时间区间集合Γ={u1,u2,…,un}输出:线性划分LOP1.将Γ所有元素按照“~”排序,不妨设排序后就为Γ=2.LOBi=,添加uj到LOBi队列末尾,j=j+1;3.若j>|Γ|,算法结束;否则,k=1,Tail(LOBi)表示3.1.若k<i且ujTail(LOBi),添加uj到LOBi队列3.2.若k>i,则i=i+1,转步2;3.3.若ujTail(LOBi),i=i+1,转步3.1;4.分别输出各LOBm(1mi)中所有元素,这些元素组成一个线性分支,且所有LOBm(1mi)组成Γ上的一LOBi队尾元素:末尾,j=j+1,转步3;个LOP.Γ上可有多个LOP,从时态查询效率而言,需考虑“最小”的LOP(见4.1.2节中算法2后的分析).定义6(“最小”线序划分).设Δ0是Γ上LOP,Δ为Γ上任一LOP,Δ0是Γ上“最小”LOP(Least-LOP)|Δ0||Δ|,其中,|Δ|表示Δ的基数.定理2(最小LOP).由算法1得到LOP具有最小性.证明.设Δ0=〈L1,L2,…,Ln〉由算法1获得,其中Li具计算顺序.以下证明Li,Lk∈Δ0,(i≠k,不妨设i<k)Tail(Li)和Tail(Lk)互不相容.反设Tail(Li)与Tail(Lk)相容.(1)若Tail(Li)Tail(Lk),由定理1可知Tail(Li)∈DR(Tail(Lk)),故Tail(Lk)~Tail(Li),由算法1搜索顺序Tail(Lk)先于Tail(Li)被搜索到,且搜索到Tail(Li)时,Tail(Li)Tail(Lk),所以Tail(Li)会被添加到Lk尾端,这与Tail(Lk)矛盾.(2)若Tail(Lk)Tail(Li),则Tail(Lk)∈DR(Tail(Li)),由算法1搜索顺序可知Tail(Li)必定先于Tail(Lk)被搜索到,且搜索到Tail(Lk)时,Tail(Lk)Tail(Li),故Tail(Lk)会被添加到Li的尾端,这与Tail(Li)矛盾.由此可知至少存在|Δ0|个不相容元素Tail(Lj)(1jn),其中每个元素在任何一种LOP构造方法中都会确定一个LOB,因此任何LOP至少有|Δ0|个LOB.算法1的时间复杂度分析如下:步1排序复杂度为O(nlogn);步2和步3为常数复杂度;步4需扫描n个时间区间,对于当前扫描的时间区间Pj,LOP中至多有j个线性分支,每次循环最多需执行j次判定操作,因此步4复杂度为1+2+…+n=n(n+1)/2=O(n2);步5复杂度为O(n).所以算法1时间复杂度为O(n2).算法1则给出一个并行获取LOP所有LOB的下优先算法,即一次扫描可获取所有LOB.在并行算法中,当时间区间VT可并入多个LOB时,VT将被并入第一个包含其的LOB.定理3.设由算法1得到LOP〈L1,L2,…,Ln〉(Li具计算顺序),则Li(1i<n-1),Li+1位于OUR(Li).证明.(1)假设Li+1∈ODL(Li),若Sta(max(Li+1))<Sta(max(Li)),由算法1中LOB的生成顺序可知,Li+1一定先于Li生成;若Sta(max(Li+1))Page5Sta(max(Li)),设Li={u1,…,un}且ui是Li中最后一个位于UL(Li+1)区域内的元素,则{u1,…,ui,Li+1}构成一个线序分支.与已知矛盾.(2)假设Li+1∈UL(Li),则有min(Li+1)∈UL(max(Li)),即max(Li)min(Li+1),此时{Li+1,Li}可以归并为一个LOB,与已知矛盾.(3)假设Li+1∈DR(Li),则有max(Li+1)∈DR(min(Li)),即max(Li+1)min(Li),此时{Li,Li+1}可以归并为一个LOB,与已知矛盾.由上述(1)(2)(3)可知Li+1位于区域OUR(Li)内.推论1.在定理3条件下,{Sta(maxLi)|1in}和{End(minLi)|1in}均按升序排列.2.2二阶相点分析对二阶区间w=[x1,y1;x2,y2],在定义2中取s11=x2,s12=x=x2-x1,s21=y2,s22=y=y2-y1,此时R2(w)=R2(x1,y1;x2,y2)=(x2×10α+x,y2×10α+y)=(x2x,y2y).二阶相点所在平面称为空间相平面(PhasePlane,PPL).PPL中水平轴和垂直轴分别称为0-相轴和1-相轴.二阶区间到二阶相点存在1-1对应,以下将不区分.2.2.1二阶相点性质定理4(二阶区间相互关系的相点描述).设R2(i)=[x1(i),y1(i);x2(i),y2(i)],R2(j)=[x1(j),y1(j);x2(j),y2(j)],x(i)=x2(i)-x1(i),y(i)=y2(i)-y1(i),x(j)=x2(j)-x1(j),y(j)=y2(j)-y1(j).若R2(i)R2(j),则x2(j)x(j)x2(i)x(i)∧y2(j)y(j)y2(i)y(i).证明.设α为坐标值中最大位数,由矩形的包含关系可知x(i)x(j)∧y(i)y(j),从而有R2(i)R2(j)x2(j)x1(i)∧y2(j)y1(i)(x2(j)×10α+x(j)x2(i)×10α+x(i))∧(y2(j)×10α+y(j)y2(i)×10α+y(i))x2(j)x(j)x2(i)x(i)∧y2(j)y(j)y2(i)y(i).推论2.x2(j)x(j)<x2(i)x(i)∨y2(j)y(j)<y2(i)y(i)(R2(i)R2(j)).2.2.2MBR划分对给定空间点P(x2x,y2y),以点P的x坐标为基点按y轴方向可将相平面划分为Px(I)(横标大于x的区域)和Px(II)(横标小于等于x的区域);同时,以点P的y坐标为基点按x轴方向可将相平面划分为Py(I)(纵标大于y的区域)和Py(II)(纵标小于等于y的区域),如图2所示.由定理4,给定空间相点Q,包含Q的相点P只能位于Qx(II)或Qy(II),而被Q包含的相点P只能位于Qx(I)或Qy(I).设{M0,M1,M2,…,Mn}是所考虑轨迹线段的MBR集合对应的空间相点集合.由M0以x坐标为基点对相平面进行划分,其中每个划分区域对应M0一个子结点位置(M0x(II)为左子结点,M0x(I)为右子结点).考察M1位于M0划分位置情况,例如,M1∈M0x(II),将M1置于M0左子结点,然后M1以y坐标为基点将区域M0x(II)进行划分,然后依次考虑其它相点情形.此时,每层结点划分基点对应的坐标轴定义为levelimod2,其中,leveli表示结点所在层次,且0为x轴,1为y轴.这里假设树根结点所在层为0层,其子结点为第1层,依此类推等,相关情形如图3所示.按照文献[19]基本思想,由上述循环可建立相平面上的KD-Tree(KD-TreebasedonPhasePlane,PPKDT).PPKDT根结点和内结点都至多具有两个子结点,每个子结点Mc都位于其父结点Mf相应划分区域内,如果Mc∈Mf(II)(Mf(I)),则称Mc为Mf的左(右)子结点,由左(右)子结点Mc开始的子树称为Mf的左(右)子树.Page62.3一阶相点编码定义7(区间树型结构).如果一个数据文件D能够表示为树型结构且满足下述条件,则称该数据文件D具有区间树型结构,简称为区间树并记为IntD.(1)结点入边标记为该数据结点的某个基于一阶区间的属性标签.(2)结点u是v的父结点,则u,v满足定义3中拟序关系:vu,即Intval(u)Intval(v).定义8(相点编码,Intcode(u)).u∈IntD,相点编码Intcode(u)=〈Code(u),Erf(u)〉,其中(1)Code(u)为u在f1(End(u),Sta(u))=End(u)-Sta(u),f2(End(u),Sta(u))=Sta(u)时的一阶区间数,即Code(u)=(End(u)-Sta(u))×10α+Sta(u),α是IntD所有区间跨度最大者数位.(2)Erf(u)为u扩展先序编码,即常规先序遍历过程中,在保证严格单调增加情况下结点编号非连续取值,其作用是为数据更新(插入)预留必要编码空间.设Dproc(u)表示在扩展先序遍历中u的直接前驱;j-Dproc(u)表示u在IntD中第j层上在扩展先序编号最小的前驱(depth(u)<j);j-ancestor(u)表示u在IntD第j层的祖先结点.由定义8可知,结点区间属性和相应相点编码相互确定,即由结点的区间属性(相点编码)可以推知该结点的相点编码(区间属性).u=j-Dproc(v)∧depth(v)<j;u=j-ancestor(v)∧depth(u)=(depth(v)+1);depth(v)=depth(u)∧u=Dproc(v).定理5(相点编码性质).(1)u=j-ancestor(v)(Code(v)Code(u))∧(2)u=father(v)(Code(v)Code(u))∧(3)u=proceeding-sibling(v)左兄弟结点证明.(1)必要性.若u是v的j-祖先结点,则由定义7中“(2)”可知Intval(v)Intval(u),故Code(v)Code(u),再由于v在第j层只能有一个祖先结点可知u=j-Dproc(v)充分性.由Code(v)Code(u),则u不能是v的后裔结点;由depth(v)<j,有两种情形:①v在以u为根的子树上,因此u是v的祖先结点.②u位于v所处子树左上方,u所在第j层存在先序编号小于u编号的结点u0作为v的前驱,这与u=j-Dproc(v)矛盾.(2)是“(1)”的推论,(3)由扩展先序概念即可得到.定理5表明,相点编码同时确定了IntD数据结点区间属性和结构信息,可提升数据重构效率.对于上述区间树,常规情形下需同时建立和存储结点语义标签、区间属性标签和用于查询结果重构的编码信息,对于IntD中结点,只需相应语义标签和相点编码,进行数据更新时,原有相点编码方案也可不需经常改变.3移动数据索引模型移动对象与其它时空对象相比,位置总在连续发生改变,如果限于一般时空模型框架,需周期性刷新以保证位置信息随时有效.这种频繁变动会带来巨大更新开销.Sistla[20]和美国伊立诺依大学芝加哥分校的Wolfson等[21]针对移动对象数据特性分别提出相应数据模型.本文建立一种基于相点分析的移动对象数据模型.3.1数据模型为有效存储和管理移动对象轨迹,通常预设一系列时间点t1,t2,…,tn对移动对象位置和速度等基本信息进行取样.设移动对象对应于上述时间点的位置为P1,P2,…,Pn,将Pi和Pi+1通过直线段相联,由此得到的折线段(polyline)称为移动对象轨迹(线),连接相邻两取样点的直线段称为轨迹线段(linesegment,线段);轨迹线段端点称为更新点,更新点P对应的采样时间称为更新时间,记为UT(P).为了简化表述层次,本文中研究的数据单元是轨迹线,基元是轨迹线段.设轨迹线段u以P1(x1,y1),P2(x2,y2)为始点和终点,u的有效时间为VT(u)=[VTs(u),VTe(u)),其中VTs(u)=UT(P1)∧VTe(u)=UT(P2),u的最小限定矩形为MBR(u)=[x1,y1;x2,y2].轨迹线Trj有效时间是Trj的生命周期,Trj最小限定矩形为其所有轨迹线段MBR的MBR,分别记为VT(Trj)=[VTs(Trj),VTe(Trj))和MBR(Trj).轨迹线Trj和轨迹线段u都分别具有相应的一阶区间属性(VT)和二阶区间属性(MBR).轨迹线和其包含轨迹线段满足如下时间约束:(1)设ui-1和ui是两相邻轨迹线段,则VTe(ui-1)(2)轨迹线Trj有效时间是其所有轨线段有效当VTe(Trj)=Now,则称Trj“在线”(online),VTs(ui).时间并集:∪ui∈TrjVT(ui)VT(Trj).Page7否则称Trj“离线”(offline),分别记为Trjon和Trjoff,Trjon表示相关对象“截止”当前时间(CurrentTime,CT)仍然运动.本文将Now绑定于CT.定义9(最新更新点与最新轨迹线段).设P是轨迹线Trj的更新点,如果UT(P)Now∧(UT≠UT(P),UTUT(P)Now),则称P是Trj的最新更新点,记为PLAST.以PLAST为终点的轨迹线段称为最新轨迹线段(lastlinesegment)并记为u=Slat(Trj)定义10(移动对象查询数据模型,Modam).移动对象数据模型Modam=(MT(Modam),AU(Modam)):结点;(1)MT(Modam)是具四层结点的树型结构:①根结点层.第1层中结点为唯一(虚拟)根②移动对象层.第2层中结点为各个移动对象结点O;③轨迹线层.第3层中结点为各个移动对象轨迹线结点Trj;④轨迹线段层.第4层中结点为各个轨迹线中的线段结点S.(2)AU(Modam).当前时间位置信息辅助处理机制.设PNEXT为Trj最新更新点PLAST之后下一个更新点,有UT(PLAST)NowUT(PNEXT),由于已知PLAST信息,而PNEXT未知.如果需查询当前时间信息,需要“预测性”构建PNEXT.本文采用线性函数方法[1]构建PNEXT以得到当前时间位置的(不确定)信息.待当前时间Now超过UT(PNEXT)后,再将实际更新点PNEXT正式存入数据库.由历史信息判断当前时间位置主要是将文献[1]中方法进行适当技术扩充,同时,由于AU(Modam)本质上并不属于数据索引范畴,本文对此不进行具体讨论.为简化叙述,本文以下提及的Modam是指MT(Modam).对Modam中结点u赋予有效时间VT(u)(一阶区间)属性和最小限定矩形MBR(u)(二阶区间)属性,其中,非叶结点的有效时间为其所有子结点有效时间的并集,MBR(u)为包含其所有子结点MBR的MBR.由定义10,Modam是一种树型结构,Modam中结点n(j)=(ID(n(j)),VT(n(j)),MBR(n(j)),Stru(n(j)))=(ID(n(j)),Intcode(n(j)),MBR(n(j))),其中,ID(n(j))和Stru(n(j))分别表示结点的ID和结构信息,Intcode(n(j))表示基于VT(n(j))和Stru(n(j))的相点编码,而1j4分别表示相应结点为根、移动对象、轨迹线和轨迹线段.不失一般性,本文以下设Modam仅由根、轨迹线和线段三层组成.例1.设移动对象生成10条轨迹线,对应的Modam如表1所示,Sij表示第i条轨迹线的第j个线段.表1移动对象轨迹线NoVT(x1x2,y1y2)TcodeNoVT(x1x2,y1y2)TcodeTrj1[1,15][16,17]1401,0010Trj6[2,12](23,24)1002,0220S11S12S13Trj2[1,12](26,38)1101,0050Trj7[1,12](38,28)1102,0260S21S22S23Trj3[1,12](27,36)1101,0090Trj8[1,12](38,37)1101,0300S31S32S33Trj4[1,12](16,26)1101,0140Trj9[1,12](16,38)1101,0340S41S42S43Trj5[1,15](28,17)1401,0180Trj10[1,15](36,18)1401,0380S51S52S533.2索引模型定义11(移动数据索引模型,Modim).移动S61S62S63S71S72S73S81S82S83S91S92S93S101S102S103数据索引模型Modim=(root,Tindex,Sindex,Integ)为时态索引和空间索引整合的四层树型结Page8构,首层结点为根结点root;Tindex是针对Modam中第二、三层的时态索引模块,Sindex是空间索引模块,Integ是时态和空间索引模块的整合机制.(1)时态索引模块.Tindex=(NT,VT,ET)为基于一阶相点分析的两层结构.①轨迹线层.轨迹线结点按照“”得到的LOB;②轨迹线段层.由轨迹线层中每个结点中元素在Modam中的子结点按照“”得到的LOB.NT是Tindex所有索引结点相点编码集;VT是Tindex中所有结点(LOB)集合;ET为相应边集合.时态索引结点(LOB)nt=(Intcode(nt),〈max(nt),min(nt)〉),其中Intcode(nt)为nt相点编码,min(nt),max(nt)分别为nt最小和最大元.(2)空间索引模块.Sindex=(NS,QS,ES),NS是Sindex中所有索引结点相点编码集合;QS是对Sindex中叶结点层每个LOB基于KD-Tree而做出PPKDT集合;ES为相应边集合.空间索引结点ns=(Pcode(ns),R2(ns)),Intcode(ns)和R2(ns)为ns相点编码和二阶相点.在Modim中每条轨迹线段的时间和空间数据只存储一次,因此Modim的空间复杂度为O(n),其中n为轨迹线段数.(3)时空索引整合模块Integ.为提高时空查询效率,一个时态索引叶结点LOB通常需要对应多棵空间索引树.如果只对时态索引结点LOB建立一棵空间索引树,当LOB只有较少数据点满足时态查询条件时,仍需对其中所有数据进行空间搜索,从而降低了查询效率.此时可有多种配置方法,本文采用区间套接技术(intervlenet),即由minLOB开始取分割点将LOB进行适当分割,再对由minLOB到每个分割点的LOB片段对应的数据点分别建立空间索引,使得每个LOB对应一个空间索引序列,其中可基于“等距”选取分割点,而分割点数目可由实际表3时间线序分支模式索引节点nt(1)STDBnt(2)Trj([1,15],[1,12],(2,12])nt(3)Tseg([1,7],[1,5],(1,3],[2,3])(S31,S51,S71),(S21,S91),(S11,S81,S101),(S41,S61)nt(4)Tseg([3,11],[3,9],(5,9],[7,9])(S62,S82),(S12,S42,S102),(S22,S92),(S32,S52,S72)nt(5)Tseg([9,15],[9,12],(11,12])各个LOB(n2(3),n2(4),n2(5))中元素对应的空间映射数对如表4所示,PPKDT如图6所示.问题确定.分割点与空间索引树相互对应,分割点可标识相应空间索引树(例如给出相应编号),对于满足时态查询的数据,比较其与分割点关系,可确定需查找的空间索引树.设有LOB如图4所示,选取分割点为VT2,VT4,VT6,相应空间索引树记为Sindex1,Sindex2,Sindex3.设具时间区间VTi的数据点对应的空间相点为Pi(1i2),各索引树和索引点如表2所示.其中,Sindex1是对LOB中前两个点建立索引,Sindex2对LOB前4个点建立索引,而Sindex3则是对整个LOB建立空间索引.查询时如果该LOB满足时态条件的LOB片段为{VT1,VT2,VT3,},则应查询空间索引树Sindex2.空间索引树索引值Sindex12Sindex24Sindex36(P1,P2,P3,P4,P5,)P6对LOB建立多棵空间索引树,通常会提升查询效率,但空间耗费也随之增加.空间索引树数量确定需要根据实际问题要求和索引中LOB的规模确定.本文5.2.1节将对空间索引树个数增加时索引的空间耗费和查询效率进行具体探讨.空间索引树具相同结构和操作(查询,更新),为突出基本思路,本文以下举例均假设对整个LOB建立空间索引.例2.例1中移动对象数据对应时间线序分支如表3所示,时态索引模式如图5所示.(Trj1,5,10),(Trj2,3,7,8,9),(Trj4,6)(S13,S53,S103),(S23,S33,S43,S73,S93),(S63,S83)最终移动对象数据索引模型如图7所示(为简明起见,空间索引中叶结点的4个空指针未画出).Page9图5时态索引模式Tindex图6PPKDT构造图7移动数据索引模式ModimPage104数据操作4.1数据查询数据索引是对数据库中已有数据(称为历史的过去数据)的查询技术,在整个移动数据查询领域,历史数据查询是对当前时间位置判断和未来位置预测的基础和出发点.对于移动对象数据查询Q=(ID(Qt),VT(Q),R(Q))来说,如果VTe(Q)-VTs(Q)≠0,则称为时空区域查询,否则称为时间片查询.从应用角度考虑,移动数据查询主要是关于轨迹信息查询,此时需根据时空数据自身特征,检查一个对象轨迹中的多条线段.实际应用中,移动数据查询基本时间粒度是“时间点”和“时间区间”,而空间查询粒度是“轨迹线片段”和“轨迹线段”.时间点可看作特殊时间区间,轨迹线段组成轨迹线片段(轨迹线),因此“搜索给定时间区间P内与给定空间MBR具有某种拓扑关系的轨迹线段”可作为移动对象数据基本查询.不失一般性,本文考虑上述两种基本查询:(1)轨迹线段查询.Qts=(ID(Qts),VT(Qts),R(Qts));(2)轨迹线片段查询.Qt=(ID(Qt),VT(Qt),R(Qt)),其中,ID(Q)为查询对象(轨迹线段或片段)标识,(VT(Q),R(Q))为时空查询窗口,VT(Q)=[VTs,VTe),(VTs可与VTe相等,此时时间区间退化为时间点),R(Q)=[x1,y1;x2,y2].对Q来说,查询输出D=(ID(D),VT(D),R(D)),其中,ID(Q)=ID(D)∧VT(D)VT(Q)∧R(D)R(Q).4.1.1轨迹线段查询算法2.轨迹线段查询算法.输入:查询Q=(ID(Q),VT(Q),R(Q)),其对应平面输出:满足查询要求轨迹线段1.LOB时态查询.1.1.时态过滤.设各索引结点对应LOB集合为{Li0}(为了简便记,也以Li0记相应时空索引结点);索引结点Li0=(ni0(j),〈max(Li0),min(Li0)〉),其中ni0(j)和〈max(Li0),min(Li0)〉分别表示Li0的先序结点编号、最大及最小时间期间.由推论1可知,在LOP{Li1,Li2,…,Lin}中,{VTe(minLi)|1in}按升序排列.首先在{VTe(minLi)|1in}中执行二分查找,找到最后一个满足VTe(minLi)VTe(Q)的线序分支,不妨设该线序分支为Lin;然后在{Li1,Li2,…,Lin}中依次判定满足VTs(minLi)VTs(Q)的线序分支,此时得到的所有线序分支均为时态过滤结果.1.2.时态查询.由步1.1可知,所有候选索引结点Li0均满足min(Li0)VT(Q),即候选结点中一定存在满足时间约束的数据实体.①如果max(Li0)VT(Q),则Li0中元素都是查询结果.②否则,将Li0中结点按时间包含关系排序为[u]i1,[u]i2,…,[u]in(即[u]i1[u]i2…[u]in),其中[u]ii表示时间期间相同的结点集合.通过对{[u]i1,[u]i2,…,[u]in}的结束时间执行二分查找,选取满足VTe([u]ii)VTe(Q)的最后一个结点[u]ii,则线序分支片段LOBs={VT([u]i1),VT([u]i2),…,VT([u]ii)}中的所有元素都是时态查询结果.2.基于PPKDT空间查询.对经过时间筛选的LOB或LOBs,在相应PPKDT中进行空间查找.设线序分支L0对应的PPKDT为T0,而M0=root(T0),设M0k表示点M0以坐标轴k为平面划分基点(k=x,y),根据定理4可得到下述查询情形.2.1.如果PQ∈M0x(II),则此时M0的左子树为查询候选结果.如果PQx=M0x∧PQyM0y,则M0为空间查询候选结果.设M0左子树的根结点为M1,M1将M0x(II)区域分为M1y(I)和M1y(II),此时判断PQ在M1的位置:①如果PQ∈M1y(II):如果PQx=M0x∧PQy=M1y,则M1和M1y(II)区域内的所有元素均为空间查询候选结果,查询结束;否则,需在M1y(II)区域内递归查找结果,即在M1的左子树查找,同时,如果PQy=M1y∧PQx>M1x,则M1为空间查询候选结果.②如果PQ∈M1y(I),则需要在M1y(I)和M1y(II)区域内递归查找结果,即分别在M1左子树和右子树查找,同时,如果PQx>M1x,则M1为空间查询候选结果.2.2.如果PQ∈M0x(I),则M0的左子树和右子树都为查询候选结果;同时,如果PQyM0y,则M0为空间查询候选结果.设M0的左子树的根结点为M1,M1将M0(II)区域分为M1y(I)和M1y(II);M0右子树的根结点为M2,M2将M0x(I)区域分为M2y(I)和M2y(II),此时判断PQ在M1和M2的位置:①PQ∈M2y(I),如果PQxM2x,则M2为空间查询候选结果;然后分如下3种情况考虑:(i)若PQy=M1y,则M1y(II)中所有元素均为空间查询候选结果,然后在M2y(I)和M2y(II)中递归查找.(ii)若PQy>M1y,则M1和M1y(II)中所有元素均为空间查询候选结果,然后在M1y(I),M2y(I)和M2y(II)中递归查找.(iii)若PQy<M1y,则需要在M1y(II),M2y(I)和M2y(II)中递归查找.②PQ∈M2y(II),如果PQy=M2y∧PQxM2x,则M2为空间查询候选结果;分下述3种情况考虑:(i)若PQy=M1y,则M1和M1y(II)中所有元素为空间Page11(ii)若PQy>M1y,则M1和M1y(II)中所有元素均为空间查询候选结果,再在M1y(I)和M2y(II)中递归查找.(iii)若PQy<M1y,则需在M1y(II)和M2y(II)中递归查询候选结果,再在M2y(II)中递归查找.查找.3.空间查询结果确定.设时空索引得到查询结果集为{Di},此时得到的只是“可能”结果,还需进行最后确定.已知(Q(x2)Di(x2))∧(Q(y2)Di(y2)),因此只需考察(Q(x1)Di(x1))∧(Q(y1)Di(y1))是否成立,再由适当数据编码将结果进行装配得到所需轨迹线或轨迹线片段.4.时态查询和空间查询整合.当时态查询结果为整个LOB时,由空间查询结果对应的ID即可得到满足时空索引查询的结果;当时态查询结果为LOB片段,则将空间查询结果的ID与LOB片段中ID比较得到索引的时空查询结果.通过基于LOB时态查询和PPKDT空间查询,分别得到满足时态要求轨迹线段ID集合和满足空间要求轨迹线段ID集合,通过求两集合交集得到最终满足时空要求的轨迹线段ID集合.特别,在时态查询中,若整个LOB都是时态查找结果,则对该LOB进行空间查询后,所得空间查询结果都最终满足时态和空间查询要求,这部分空间查询结果不需进行求交集,直接加入最终结果集中.求交集过程采用Hashing方法:先对Tindex查询结果集中ID进行Hashing存储,再对Sindex查询结果集中ID进行Hashing查找,在线性时间内求得两集合交集,从而提高求交集效率.由算法2中步1中的时态查询过程可知,给定时间区间集Γ,当LOB越少时,单个LOB包含的时间区间越多,通过LOB的最大或最小元或执行二分查找可确定或排除的满足时态约束的结点就越多,相应时态查询效率也越高.这也是2.2.2节中讨论最小LOP的原因.算法2时间复杂度分析:步1中,步1.1时态过滤耗时主要是对{VTe(minLi)|1in}的二分查找和后序判定过程,假设共有k个线序分支,则该部分的查询时间复杂度最大为O(logk)+O(k).步2.2时态查询耗时主要是对满足时态排序的LOB中元素时间终点执行二分查找,设LOB含有n个元素,则相应时间复杂度最大为k×O(logn);步2是对步1中满足时态约束LOB对应的PPKDT执行空间查询,设相应LOB含有n个元素,且所有元素满足空间约束,此时KD-Tree查询时间复杂度最大为O(n1/2+n),故步2的查询时间复杂度最大为k×O(n1/2+n);经过空间查询得到的满足空间约束的元素最多有kn个,此时步3和步4的时间复杂度最大均为O(kn),算法2时间复杂度为O(kn).4.1.2轨迹线查询算法3.轨迹线片段(轨迹线)查询算法.输入:查询条件Q=(ID(Q),VT(Q),R(Q)),其对应[5,12],R(Q)=[3,5;7,8]的轨迹线片段.输出:满足查询要求轨迹线片段1~4.同算法25.轨迹线段装配.设经过上述步1~4获取的满足查询条件的轨迹线片段集合为{S1,S2,…,Sn},根据各轨迹线段的时态编码将属于同一条轨迹线的连续轨迹线段装配为一条轨迹片段.例3.在例2中查询符合时空约束VT(Q)=步1~2.时态过滤与查询.由于min(nt(3))VT(Q),故nt(3)中的所有数据项都不满足时态要求;由于max(nt(4))VT(Q),但min(nt(4))VT(Q),则对线序分支nt(4)进行二分查找,获取满足时态要求的线段集为T4={S22,S92,S32,S52,S72};由于max(nt(5))VT(Q),但min(nt(5))VT(Q),则对线序分支nt(4)进行二分查找,获取满足时态要求的线段集为T5={S23,S33,S43,S73,S93,S63,S83};步3.空间查询.计算R(Q)对应的平面相点为PQ=(74,83):(1)对nt(4)对应的PPKDT进行搜索:PQ位于PPKDT根结点对应相点(52,51)Ix-区域中,由于PQy>63,(52,51)为空间查询候选结果,由于(52,51)左子树不空,(52,51)左、右子树为查询候选结果.(52,51)左、右子树根结点分别为(41,62)和(72,62),下面考虑PQ与(41,62)和(72,62)位置关系:PQ位于(72,62)Iy-区域中,由于PQx>72,(72,62)为空间查询候选结果;PQy>(41,62)y,(41,62)和其IIy-区域内元素为空间查询候选结果,然后在(41,62)Iy-区域、(72,62)Iy和IIy区域内进行查找:①(41,62)的Iy-区域.(41,62)右子树根节点为(51,63),PQ位于(51,63)Ix-区域中,由于PQy>63,(51,63)为空间查询候选结果,由于(52,51)左子树不空,(52,51)左子树和右子树都为查询候选结果.(52,51)左子树根结点为(41,72),右子树为空,由于PQy>72,(41,72)为空间查询候选结果.由于(41,72)左右子树均为空,该查询分支结束.②(72,62)的Iy和IIy区域.(72,62)的左右子树的根节点分别为(53,51)和(62,72),PQ位于(62,72)Ix-区域中,由于PQy>72,所以(62,72)为空间查询候选结果.由于PQx>53,所以(72,62)的左子树中的所有元素均为空间查询候选结果.由于(62,72)左子树不为空,(62,72)左子、右子树为查询候选结果.(62,72)左子树根结点为(62,73),右子树为空,由于PQy>73,(62,73)为空间查询候选结果.由于(62,73)左右子树均为空,该查询分支结束.此时空间查询得到候选结果集为{(51,63),(42,51),(41,62),(62,73),(62,72),(41,72),(53,51),(52,51),(52,41),(72,62)},对应的轨迹线段为{S102,S42,S62,S72,Page12S92,S22,S12,S32,S52,S82},由各线段始点与空间查询窗口左下顶点确定最后的空间查询结果为S4={S72,S92,S22}.(2)对nt(5)对应的PPKDT进行搜索:PQ位于PPKDT根结点对应相点(72,61)Ix-区域中,由于PQy>61,(72,61)为空间查询候选结果,由于(72,61)左子树不为空,(72,61)左、右子树为查询候选结果.(72,61)左、右子树根结点为(61,72)和(83,73),下面考虑PQ与(61,72)和(83,73)位置关系:PQ位于(83,73)IIy-区域中,由于PQy>(61,72),(61,72)和其IIy-区域内元素为空间查询候选结果;然后在(61,72)的Iy-区域,(83,73)Iy和IIy区域内进行查:①(61,72)Iy-区域.(61,72)的右子树根节点为(62,81),PQ位于(62,81)Ix-区域中,由于PQy>81,(62,81)为空间查询候选结果.由于(62,81)左子树不为空,(62,81)左、右子树为查询候选结果.(52,51)左右子树根结点为(61,82)和(71,81):PQ位于(71,81)Ix-区域中,由于PQy>(71,81)y,(71,81)为空间查询候选结果.由于PQy>(61,82)y,(61,82)和其IIy区域内所有元素为空间查询候选结果.然后在(61,82)Iy-区域,(71,81)Iy和IIy区域内进行查找.相应区域为空,该查询分支结束.②(83,73)Iy和IIy区域.(83,73)左右子树根结点分别为(81,71)和(82,81),PQ位于(82,81)IIx-区域中,且PQx<(81,71)x,只需分别查询(82,81)和(81,71)IIx-区域.(81,71)IIx-区域:(81,71)左子树根结点为(73,71),PQ位于(73,71)Iy-区域中,且PQx>(73,71)x,(73,71)为空间查询候选结果.由于(81,71)的IIx-区域和(73,71)Iy和IIy区域均为空,该查询分支结束.此时空间查询候选结果集为{(73,71),(62,61),(72,61),(62,81),(61,72),(71,81),(61,82)},对应轨迹线段为{S63,S43,S33,S23,S13,S93,S103}.由各线段始点与空间查询窗口的左下顶点确定最后空间查询结果为S5={S63,S43,S33,S23,S13,S93,S103}.步4.时空整合.时空查询最终结果为时态查询与空间查询结果的交集,ST4=S4∩T4={S72,S92,S22},ST5=S5∩T5={S63,S43,S33,S23,S93},最终查询结果集为ST=ST4∪ST5={S72,S92,S22,S63,S43,S33,S23,S93}.步5.轨迹线片段装配.根据结果集ST中各线段对应时态编码(此时各线段均在同一层)和定理5可知,S22(Intcode=〈0405,0070〉)是S23(Intcode=〈0309,0080〉)的左兄弟,S92(Intcode=〈0405,0360〉)是S93(Intcode=〈0309,0370〉)的左兄弟,因此S22和S23为属于同一轨迹线的连续线段,装配为一条轨迹片段,同理S92和S93可装配为一条轨迹片段.查询输出结果为{{S72},{S92,S93},{S22,S23},{S63},{S43},{S33}}.4.2索引更新由于MOD通过传感器采集数据,移动对象数据库中数据更新主要是随着时间演进,更新点向前推移而导致的轨迹线插入操作.Modim采用分层索引方式,轨迹线段插入首先导致Tindex更新,即LOB更新.因为基于Tindex中每个LOB构建Sindex,由此又导致Sindex更新.本文Sindex基于PPKDT构建,Sindex更新通过KD-Tree更新机制实现[19].因此,以下仅讨论Tindex的增量式更新,即插入新数据后,索引在尽可能小数据范围内进行调整,并使得调整后结果与对整个数据重建索引(完全式更新)一致.注意到离线轨迹线本身不涉及任何更新运算,移动对象的数据插入操作实际上可分为在线轨迹线延伸和新轨迹线插入两种类型.4.2.1在线轨迹线延伸非最近轨迹线段上方区域.定理6.在TOM(Γ)中,最新轨迹线段在所有证明.由于UT(PLAST)Now<UT(PNEXT),当下一个更新点PNEXT到来时产生的最新轨迹线段Slat(Trj)的有效时间终点为UT(PNEXT).因此,在时间相平面中,相点VT(Slat(Trj))的纵坐标VTe(Slat(Trj))大于所有已有相点的纵坐标.证毕.在线轨迹线插入就是对原有轨迹线延伸.对于在线轨迹线,其延伸过程是,将Now绑定于进行数据操作的当前时间CT1,设CT0是前次插入时间,对每条轨迹线Trj,找出相对于CT0和CT1的最近更新时间UTCT0(Trj)和UTCT1(Trj),由UTCT0(Trj)和UTCT1(Trj)之间的更新点可以确定一条新的轨迹线段.设up是这样的轨迹线段,由定理6,up的插入可分为如下两种情况.(1)DR(VT(up))=,此时VT(up)单独构成一个LOB.(2)DR(VT(up))≠,由定理6可知,LOB0,max(LOB0)在VT(up)下方,此时,将VT(up)添加到LOB0构成新的LOB1,且VT(up)=max(LOB1)对于多个up情形(如图8所示),先针对其进行构建新的LOB,再将各个min(LOB)按照始点递增排序,依次应用上述两种情况即可.由推论1可知,所有线序分支最大元的始点是按升序排列的,上述轨迹线段插入分类中,通过对所Page13需要插入的新轨迹线可以分为在线和离线两种有线序分支最大元的始点进行二分查找即可判定相应的操作.因此轨迹线延伸的时间复杂度为O(logk),其中k为线序分支数.4.2.2新轨迹线插入情形.(1)新插入在线轨迹线.此时将新插入轨迹线的所有轨迹线段分为在线和离线两部分,对于离线部分采用同下述(2)同样的处理方式,而对于在线部分则按照4.2.1节中在线轨迹线延伸相同的处理方式.(2)新插入离线轨迹线.此时主要是将轨迹线和轨迹线段插入相应层的LOP中.由于索引各层LOP的动态更新方式相同,而轨迹线段是轨迹线的组成基元,为突出基本思想,不妨假设插入单个轨迹线段u0,即索引更新仅发生在叶结点层,设叶结点层的LOP={L1,L2,…,Lk}且按生成顺序排序.结点u0的插入过程可能会引起相关线序分支的分裂和新线序分支的建立,该算法的总体思想为:从L1开始查找时间区间VT(u0)应插入的第一个线序分支Li,将VT(u0)插入,同时根据线序分支的性质调整Li中的元素,即将Li中属于OUR(VT(u0))的分支片段移出至subL;如果Li不存在,即线序分支L1,L2,…,Lk中的所有时间区间均位于OUR(VT(u0))或ODL(VT(u0))内,则VT(u0)单独构成一个线序分支.如果subL不为空,则从Li+1开始对subL做类似处理,直至subL为空.具体算法如算法4所示.算法4.基于插入的线序分支更新算法.输入:按生成顺序排序的线序分支L1,L2,…,Lk,新插输出:更新后的线序分支序列1.令i=1;subL={VT(u0)};2.如果maxLk∈ODL(subL)或者minLk∈ODL(subL),则subL单独构成一个线序分支Lk+1,转步9;3.如果i>k或者maxLi∈OUR(subL)∧minLi∈图9subL单独构成一个LOBOUR(subL),则subL独立构成一个线序分支Lk+1,转步9;4.如果maxLi∈ODL(subL)或者minLi∈ODL(subL),i=i+1,转步3;5.如果maxLi∈DR(subL),则Li={subL,u1,…,um},转步9;转步9;6.如果minLi∈UL(subL),则Li={u1,…,um,subL},7.如果maxLi∈UL(subL),找到Li中属于UL(subL)区域的最后一个元素uj:7.1.如果uj+1∈ODL(subL),i=i+1,转步3;7.2.如果uj+1∈DR(subL),则Li={u1,…,uj,subL,uj+1,…,um},转步9;7.3.如果uj+1∈OUR(subL)∧minLi∈OUR(subL),则Li={u1,…,uj,subL},subL={uj+1,…,um},i=i+1,转步3;7.4.如果uj+1∈OUR(subL)∧minLi∈DR(subL),找到位于DR(subL)区域的第一个元素uk,Li={u1,…,uj,subL,uk,…,um},subL={uj+1,…,uk-1},i=i+1,转步3;8.如果maxLi∈OUR(subL)∧minLi∈DR(subL),找到位于DR(subL)区域的第一个元素uj,Li={subL,uj,…,um},subL={u1,…,uj-1},i=i+1,转步3;9.按顺依次输出所有线序分支.算法4的时间复杂度分析:设所有线序分支共包含n个时间区间,步1~步9至多对每个时间区间访问一次,所以算法4时间复杂度为O(n).考虑分支片段subL的插入过程,对于当前的线序分支Li,算法4主要考虑以下3类情况:(1)subL单独构成一个新的线序分支:①所有线序分支均位于OUR(subL)区域内(步3),如图9(a)所示;②所有线序分支均位于subL的左下方(步2),如图9(b)所示;③线序分支{L1,L2,…,Li}中的所有元素都位于subL的左下方,线序分支{Li+1,Li+2,…,Ln}中所有的元素都位于OUR(subL)区域内(步3,步4,步7.1),如图9(c)所示.Page14(2)subL直接并入Li内:图10(a)所示;①subL作为Li的最大元并入Li中(步5),如②subL作为Li的最小元并入Li中(步6),如图10subL直接并入Li(3)subL并入Li内,且需分裂Li:uj}和Li2={uj+1,…,um}:(步7.3),如图11(a)所示;①Li分裂为两个线序分支片段Li1={u1,…,(i)将subL插入Li1的尾部,并递归插入Li2(ii)将subL插入Li2的首部,并递归插入Li1图11subL并入Li内并分裂Li5仿真与评估本文实验硬件环境为处理器IntelPentiumDual1.602Hz,内存2GB;软件环境为:操作系统WinXPSP2,编程语言Java,集成开发环境采用Eclipse3.4.本文数据集由GSTD[22]生成,相关参数设置如下:数据时间和空间域为(0,1),移动点对象初始空间位置分布和快照间的时间间隔采用Gaussian分布,移动对象初始数目为2000,再以每次2000的步长递增至20000.此外,对GSTD生成数据集进行必要处理,即将一个对象相继两快照合并成一条线段(tid,sid,ts,te,xs,xe),其中tid,sid分别表示考虑对象的标识和编码,ts和xs以及te和xe分别为前后两个快照的时刻和空间位置,从而GSTD数据集被转换为由移动对象轨迹线段组成的集合.在数据查询和更新处理中,索引实现和相应数图10(b)所示;图10(c)所示.③将subL插入Li中间的位置(步7.2),如(步8),如图11(b)所示.②Li分裂为3个线序分支片段Li1={u1,…,uj},Li2={uj+1,…,uk-1}和Li3={uk,…,um},然后将{Li1,subL,Li3}构成一个完整的线序分支,并递归插入Li1(步7.4),如图11(c)所示.据结构装载于主存当中.实验对Modim、TB-tree和遍历查询(Erg)中的区域和时间片查询进行比较.每类查询包含1000个查询实例,统计结果取1000个查询的平均值,而每类更新包含100次更新实例统计结果取100次更新的平均值.另外,在查询和更新仿真中,Modim中时空整合采用两棵KD-Tree,其理由见5.2节.TB-tree[4]是由Pfoser等提出的用来保存移动对象的历史轨迹信息的索引结构,作为管理轨迹线的典型索引结构,其叶结点仅包含属于同一轨迹线的线段,这种存储方式使得TB-tree对于纯粹时空查询具有较高查询效率,因此本文采用TB-tree作为仿真比较对象.5.1时空数据查询5.1.1时空区域查询时空区域查询分为时空窗口同时变、时间窗口变空间窗口不变、时间窗口不变空间窗口变3种情形.Page15(1)时空查询窗口同时变化.设时空平台为单位立方体(STUC),考察时间维、空间x维和空间y维跨度分别为STUC相关跨度的1%,10%和20%的时空区域查询窗口.实验结果如图12~14所示.图12查询窗口跨度为STUC的1%的情形图13查询窗口跨度为STUC的10%的情形图14查询窗口跨度为STUC的20%的情形由图12~14可知,Modim、TB-tree和Erg查询耗时随数据量增加而呈近似线性增长,以Modim为优.(2)时间变化空间不变.采用10000个移动对象,固定空间查询跨度为时空单位立方体空间相应跨度的10%,时间查询跨度按照其取值分别为1%,5%,10%,15%,20%,实验结果如图15所示.图15空间维跨度固定为STUC的10%的情形(3)空间变化时间不变.采用10000个索引对象,固定时间查询跨度10%,变化空间查询跨度,其取值分别为1%,5%,10%,15%,20%,实验结果如图16所示.此时,当时间查询跨度保持不变时,由于TB树空间查询机制基于R-树,当空间查询跨度增加时,相应搜索范围将会缩小,查询效率会随之提高;Modim空间查询机制KD-Tree与TB树不同,相应查询耗时基本平稳.另外,还可知若将modim和TB-Tree用于一个时间跨度固定的“纯粹”空间部分查询(切块查询),modim性能也较TB-Tree为优,即Modim为纯空间查询提供了新思路.5.1.2时间片查询此时,时空查询在STUC时间轴上投影为时间点,空间查询在各维上投影分别为STUC对应跨度的1%、10%和20%,相应结果如图17~19所示.由图17~19可知,Modim、TB-tree查询耗时随数据量增加呈近似线性增长,其中以Modim性能为优.图17查询空间投影为STUC相应维的1%的情形图18查询空间投影为STUC相应维的10%的情形Page16图19查询空间投影为STUC相应维的20%5.2索引空间与整合机制5.2.1索引空间如前所述,本文索引贡献在于时空处理模块的分置与整合,其中整合对索引查询性能有着重要影响.通过实验发现,若在索引中直接由时间模块的LOB直接进行空间索引树构建,则系统查询效率可低于遍历.但较为精细的整合会带来索引规模扩大.近年来“索引规模大于实际数据”问题已引起人们关注,这一方面是由于包括移动数据在内的各类新型数据具有更加复杂的结构,其查询和更新突破了常规数据管理框架;其次,由于硬件功能快速提高,“以空间换时间”已经成为可能.实际上,TB-Tree的数据规模就远远大于实际数据规模.这里的问题在于,较大规模的索引结构能否带来更为有效的查询效应.本文采用LOB分段对应空间索引树情形.时空整合中采用KD-tree个数建立Modim所占用空间(MB)与TB-tree占用空间情形(取2,4,6,8,10和12棵KD-tree)占用空间比较如图20所示,由此可知,在对应1,2,4,6棵KD-tree时,Modim空间占有情况均小于TB-tree;当取8棵KD-tree时,与TB-tree相当;而在超过8棵时,Modim的空间占有情况大于TB-tree.采用不同KD-tree个数建立相应Modim在时间区域查询(10%时间跨度)耗费时间与TB-tree查询时间耗费比较(取2,4,6,8,10和12棵KD-tree)时间耗费比较如图21所示.由图21可知,当KD-tree个数增加时,Modim查询效率也在增加,且相对TB-tree查询效率增长较快.5.2.2整合机制由图20和图21可知,在整合机制中增加KD-Tree个数会有效提高查询效率,但相应Modim所占用空间也会增加.因此,需要深入考察KD-Tree增加时,Modim空间占用和查询时间之间联系.本文中查询效率和空间消耗的增长率分别采用下述公式(k=2,4,6,8,10,12,分别表示采用KD-Tree个数):时间增长率=(QueryTime1-QueryTimek)/Query-Time1,空间增长率=(IndexSizek-IndexSize1)/IndexSize1.其中,QueryTimek和IndexSizek分别表示有k棵空间索引树时移动数据索引结构k-Modim的查询时间和索引结构大小.给定k(k=2,4,6,8,10,12)棵KD-Tree,对2000个移动对象以2000增量增加到20000时得到的时间和空间增长率进行平均,得到相应平均时间和空间增长率变化图22所示.由图22可知,随着整合机制的强化即KD-Tree个数增加,Modim查询效率增加幅度小于索引空间的增加幅度.按照公式TS-rate=(Query-Time1-QueryTimek)/(IndexSizek-IndexSize1)得到查询时间与索引空间变化的比值(按各种轨迹线个数情况进行平均)如图23所示.由图23可知,查询效率的增长总体而言会随着整合机制强化而低于索引空间的增长,这就为实际应用中的情形提供了灵活的选择,即对资源较为丰富而对查询效率要求较高的情形,可以选择较多的KD-Tree个数;反之,则可以选择较少的KD-Tree.当然,较强的整合机制会带来索引更新的复杂性,因此,需要结合实际情况综合考虑.由图22和图23可知,当k=2时,Modim查询效率的增长高于索引空间的消耗,这就是在查询和更新实验中选用两棵KD-Tree的原因.Page175.3增量式更新5.3.1在线轨迹线更新随着时间的消逝,如果移动对象继续运动,MOD会不断地接收和存储已有移动对象新的轨迹线段信息,而新插入轨迹线段的时间信息也是递增的,新插入轨迹线段的端点时间也随之递增,因此新插入轨迹线段时间区间的端点时间会大于等于数据库中已有的时间点.插入一条轨迹线段时,随着数据量变化增量式更新与完全式更新所耗费时间比较如图24所示.数据量为10000,插入轨迹线条数变动时,增量式与完全式更新时间耗费情形如图25所示,其中采用100次实验的平均数据.从图24~25可知,基于Modim的增量式更新———插入平均耗时几乎为0,而完全式更新则耗时将要高出许多,但两者总体趋势大都保持不变.5.3.2插入新轨迹线Modim的插入更新主要分为移动对象历史轨迹线的插入以及移动对象轨迹线段的插入.插入新的历史轨迹线会打乱原有LOB的部署,但采用4.2节中插入算法,仍然可以做到增量式更新.图26是插入一条轨迹线而数据量增加的情形,图27表示在数据量为10000时,新插入轨迹线由100增加到1000时情形,其中,轨迹线仍由GSTD生成,每条轨迹大约包含15个轨迹线段.在增量式更新中,时态索引模块按照算法4进行,空间索引模块按照KD-Tree进行[19].从图26可知,每次插入一条历史轨迹线时,基于Modim的增量式更新耗时几乎为零;而由图27可看出,当每次插入多条轨迹线时,基于Modim的增量式更新和完全式更新所耗费的时间都在增加,但增量式更新耗时远小于完全式更新,这是因为完全式更新是通过重新建立索引来实现对历史轨迹线段的插入,而基于Modim的增量式更新是按照算法4对时态索引模型Tindex进行更新,这也说明了算法4的有效性.6结语现有MOD索引多是将时间维看作普通空间维处理,即将时间维“统一”在空间维框架中.实际上,还可以从本体角度出发,研究体现时间维和空间维基本固有特征和有效整合的索引机制.这里需要讨论两个基本问题,一是充分体现时间和空间本身特点,由此会带来理论研究和技术提升的一些基本课题;二是研究将时空整合一体的构建机制.本文主要工作是将时间属性和空间属性分别看做一阶和二阶区间属性,并将它们转化为相平面中的相点,研究了Page18相点分析技术和基于相点编码方法.以此为基础,本文研究一种新颖移动数据索引模式Modim.Modim可较好反映时间和空间各自特点,能够实现基于过去和当前轨迹线查询,且表现出较为优越的查询性能;同时能够实现增量式的动态更新,具有较为理想的索引更新时间和空间复杂度.本文的相点分析技术有利于描述和研究时态和空间索引各自特性,其中的时空模块配置有助于对时空整合机制进一步研究,也有可能为处理时态和其它重要应用中场境整合研究(例如时态对象数据中的时态和对象场景,时态XML中时态和半结构场景以及时态数据空间中的时态和多种共存场景等)提供借鉴.
