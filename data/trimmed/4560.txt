Page1一种基于新型图模型的API推荐系统姜伟3)1)(中国科学院计算技术研究所前瞻实验室北京100190)2)(中国科学院大学北京100149)3)(中国石油长城钻探工程有限公司测井技术研究院北京100101)摘要对象实例化是软件工程类库复用中一个常见、复杂的问题.即根据已知源类型的对象,用户需要编写代码对目标类型进行实例化.研究人员提出了若干种API自动推荐系统辅助用户解决上述问题.然而这些系统不能同时兼顾准确率和查全率,因此在一定程度上影响了系统的实用性.该文提出了一种兼顾准确率和查全率,基于新型图模型的API推荐系统———APISynth.在查全率方面,APISynth使用一个新颖的全局图模型来表达类库中所有的API依赖关系和API历史使用信息.利用新的全局图模型具有的特殊Tag元素和可达性质以避免错误的API调用.在准确率方面,APISynth首先将对象实例化问题建模为Top-K子图查询问题,然后设计一种新的支持DAG形式解的图搜索算法,避免了传统的最短路径图搜索算法导致的查不准问题.实验结果表明,与现有多种方法相比,APISynth在准确率和查全率两方面均获得了较大提升.关键词代码辅助工具;API推荐工具;代码复用1引言随着计算机在人类生产、生活领域的不断普及,以及云计算、大数据等新兴计算模式的不断出现,以社交网站、搜索引擎为代表的超大型应用系统得到了迅猛发展.在此背景下,计算机应用的复杂性不断增加,软件系统的规模也进入了爆发性增长的历史时期,软件开发和维护的代价一直在持续增大.如微软的Windows操作系统的代码规模已经超过4000万行,多个版本的Linux操作系统的代码规模均在亿行以上,开源Hadoop的代码量达到了230万行①.包括Yahoo、Cloudra、Facebook在内的数十家大型软件公司和近万名开发者构成了庞大的Hadoop社区,每年贡献的新增代码量都高达30~40万行②.在这些超大规模、大型群体参与的软件系统开发过程中,类库复用可以有效地提高软件开发人员的编程效率、改善软件的质量[1].然而,由于类库中API的数量巨大并且使用方式复杂,类库复用的过程中往往也会涉及很多复杂的工作[2].对象实例化,作为其中的典型代表,就是类库复用中的一个突出的挑战性问题.其根本目标是根据已知类型的对象获取未知类型的对象(或称为对未知类型的实例化).即给定起始点类型(SourceType)和终点类型(DestinationType)作为输入查询,输出从起始点类型到终点类型的方法调用序列[3].面对规模和复杂性不断增长的软件系统,依靠手工查找、比对的方式实现对象实例化低效且易错.GEF(GraphicalEditingFramework)作为一个常用Eclipse的图形交互类库,就涉及35万行代码③,共计6万多个API方法.开发人员使用这个类库时,需要阅读海量的、甚至未及时更新的参考文档来找到一个正确的对象实例化方案.据有关研究人员统计,编程人员查找和理解现有API用法的时间占用了超过40%的编程时间[4].因此,如果能够自动地完成对象实例化工作,为开发人员推荐最相关的方法调用序列,将极大地减少用户查找、理解、组合和调试的工作量,进而降低人工错误率,提高软件的质量.因此,面向对象实例化的自动API推荐引起了诸多研究人员的关注[2-3,5-6],已成为一个研究的热点[7].这些相关工作中实现的对象实例化工具[2-3,5-6]被称为API推荐系统.这些API推荐系统[2-3,5-6]首先搜集查询(Source,Destination)涉及的类库源码或代码样例,然后采用本文称之为全局连通图[2]或局部非连通图[3,5-6]的模型对代码中包含的API依赖关系进行建模.其中,前者对类库源码中所有API的依赖关系进行统一建模,而后者则分别对单个类文件或方法进行建模.在图模型的支持下,二者采用基于图搜索[2-3,5]或模式匹配[6]的方法来生成从起始点类型(SourceType)到终点类型(DestinationType)的子图.每个子图表示的方法调用序列就构成一个解.Prospector[2]是一种基于全局连通图模型的方法.它可以完整刻画类库中所有类型之间的转换关系,每一种可能的方法调用序列都可以从中找到.理论上这种方式具有很好的查全率.实际情况中,由于方法调用通常需要满足一个或多个输入参数的需求,方法调用序列常常会呈现为有向无环图(DAG)的形式.然而,由于Prospector采用最短路径搜索算法,不能直接支持DAG图形式解的搜索,在搜索过程中会导致不少方法的输入参数未能被实例化.为了解决这一问题,Prospector将这些参数作为自由变量(freevariable),要求开发人员手工输入新的查询搜索这些自由变量的实例化解,并组合这些解来生成最终结果.可见,这种需要人工干预才能推荐出完整解的工作机制,会在一定程度上影响用户体验.同时,Prospector也无法对人工组合后的解进行精确的优劣排序,易导致用户选择无效解.第2节将给出一个具体的示例对Prospector存在的问题予以说明.本文的实验结果也表明该方法在准确性方面存在明显不足.与之相比,文献[3,5-6]采用了基于局部非连通图模型的机制,它们的图模型包括多个局部非连通图,分别表达某个方法或类文件内部的API依赖关系.单个局部图规模相对较小,能够大大地减少问题空间,因此有利于系统准确率的提升.但是,这类方法的图模型不能表达孤立局部图之间的API依赖关系,难以对类库中所有的API依赖关系进行完整刻画,因此容易产生遗漏,造成系统查全率的下降.尽管文献[6]提出一种查询分裂的技术可以实现跨多个局部图的搜索,但是它使用语句间的控制流构建图模型,无法对API之间的数据依赖关系进行刻画,从而①②③Page3使其能够描述的解空间变小,降低了系统的查全率.表1对现有工作的特点进行了总结和分析.由此可知,现有方法要么查全率不足,要么准确性无法保障.为了解决这一问题,本文提出了一个新的全局表1对象实例化自动推荐方法的总结与对比API依赖描述数据依赖控制依赖典型工具Prospector[2]√ParseWeb[5]×XSnippet[3]GraPacc[6]本文的主要贡献包括:(1)提出一个新的加权全局连通图模型.能够准确地表达相关类库包含的API依赖关系以及API历史使用信息.与现有全局连通图模型不同,本文的图模型中节点表示API方法;边用于连接输入类型(接收者和方法的参数)与输出类型(方法的返回值)相匹配的方法,以此表示方法间的数据依赖,每条边带有一个参数标签(Tag);API历史使用信息(API方法在相关项目中被使用的频率)用于对图模型进行完善和补充:将其作为服务质量QoS(QualityofService)赋值给相应的节点.与经典图论不同,本文借助新元素Tag提出了新的可达性定义,以满足搜索DAG子图的需求.(2)提出一种新的图搜索算法.借助新型图模型的结构及可达性质,提出了新的Top-K子图查询问题来建模方法调用序列的查询问题,并提出了关键路径松弛算法及DAG子图排序方法,指导编程人员选择正确结果.(3)通过一系列对比实验对所提出的方法进行系统化验证,实验结果表明,本文的方法获得了更高的查全率和准确率.本文第2节介绍相关工作;第3节阐述加权API图模型;第4节对系统进行整体概述;第5节阐述算法细节;第6节讨论实验结果;第7节进行全文总结.2相关工作本节首先综述对象实例化推荐工作的进展;然后介绍其他较为相关的工作.2.1对象实例化推荐为便于讨论,本文根据图模型的异同,将现有方连通图模型———加权API图,给出了新的不同于传统图论的可达性定义及搜索算法,并设计实现了一个新的API推荐系统———APISynth,来帮助编程人员完成对象实例化的任务.×√×√法分为两类:基于全局图模型的方法[2]和基于局部图模型的方法[3,5-6].需要指出,尽管Nguyen等人[6]将文献[6]归类为代码补全方法,但是由于该方法也可用于解决对象实例化的问题,本文也将其纳入本节一并讨论.为了更直观地描述现有方法的特征,尤其是相关图模型的结构,以图1所示代码为例,本文在图2中给出各方法提出的图模型.为便于表述,下文将使用代码的符号简记形式(图1右侧)进行相关问题的阐述.图2相关工作图模型示例(基于图1示例代码建模)2.1.1基于全局图模型的方法Prospector[2]根据类库中的API依赖关系构建图模型.图中的节点表示对象类型;边表示API方法调用,用来实现类型之间的转换.图2(a)展示了Prospector构建的图模型.基于该图,Prospector将对象实例化问题建模为一个传统的图搜索问题———Page4最短路径问题,并使用路径搜索算法求取起点类型到终点类型的方法调用序列.这些方法调用序列在图中表现为路径或DAG的形式.例如,当方法调用序列中存在带参数的方法调用时,该序列在图中将呈现为DAG的形式.然而,Prospector采用最短路径搜索算法不能直接求取DAG形式的解,因此需要额外的人工干预,具体过程见表2.步骤1234由表2可知,当满足查询的最终结果表现为DAG形式时,搜索过程中就会产生自由变量.此时,Prospector需要人工干预才能生成有效解.但是过多的人工干预易造成错误操作,导致不正确结果的生成,从而降低了系统的准确率.此外,Prospector对结果的评价也不够精确和全面.这一问题也存在于DAG图形式的服务组合问题中[8-10].本文称此问题为“弱DAG机制”问题.已有的研究工作表明,带参数API的调用在实际应用中往往占有较大比例,例如在3个典型的Java项目(Eclipse3.6.2,Tomcat7.0,JBoss5.0)中,带参数API方法的调用次数的平均占比为59%[11].此外,本文对GEF类库的统计结果表明,带参数API方法的占比也达到28%.据此可知,对象实例化查询的解以DAG形式出现的概率较高,而由此引发的弱DAG机制问题会显著影响Prospector的准确率.2.1.2基于局部图模型的方法基于局部图模型的方法[3,5-6]将相关的API依赖关系建模为多个图模型.每一个图仅对应于一个特定单元的代码,例如类库中的一个类文件[3]或者代码样例中一个API方法包含的内部代码[5-6].这类方法构建的图模型由多个仅仅表达局部、特定单元API依赖关系的图组成,因此可称之为局部图模型.文献[3,5-6]构建的局部图模型分别具有不同的特点.例如,在文献[3]构建的图中,节点表示一条代码语句,边表示语句调用次序,如图2(c)所示;文献[5]与文献[2]构建的图较为相似,不同点是前者在图中增加了专门指向方法参数的边,如图2(b)所示;文献[6]构建的图中包括3类节点:数据节点(数据类型)、动作节点(方法调用)和控制节点(循环、分支),同时使用数据依赖边和控制依赖边刻画节点间的关系,如图2(d)所示.上述工作采用的求解策略也具有差异性.与文献[2]相似,文献[3,5]也将对象实例化问题建模为最短路径问题,并使用标准的图搜索算法在局部图模型上查找解.与之不同,文献[6]则通过模式匹配的方式解决对象实例化问题:首先使用专门的工具Grouminer[8]将局部图模型中频繁出现的子图抽取为模式;然后使用与查询匹配的模式来生成子图形式的解.局部非连通图模型可以压缩问题空间,因此有利于提高系统的准确率.但是这种非连通图无法表达图与图之间的关系,因此会遗漏掉部分有效解,从而降低系统的查全率.有研究者可能会质疑,可通过构建跨局部图的API依赖连通局部图,从而提升系统的查全率.然而,当这些局部图连通后,文献[3]所提出的模型将与全局连通图模型相似,仍会带来“弱DAG机制”的问题.与文献[3]不同,文献[5-6]提出的每个孤立的局部图存在根据语句调用次序构建的边.然而,在局部图模型中,图与图之间却不会存在语句调用关系.因此文献[5-6]无法实现局部非连通图的“连通”.此外,本文还注意到文献[5]提出了一种查询分裂的技术,能够实现跨图搜索.但是这一技术的局限性在于跨图搜索的载体必须为根据语句控制流构建的图模型.但是由于这类图模型无法表示API之间的数据依赖关系,其能够描述的解空间有限.因此,即使采用查询分裂技术,文献[5]的查全率依然有提升空间.本文在实验部分对此进行了验证.综上,现有工作难以兼顾准确率和查全率.2.2其他相关工作文献[12-20]根据用户的需求进行代码推荐,是与本文较为相关的研究工作.CodeBroker[12]和Strathcona[13]首先分析用户Page5正在编辑的代码来抽取上下文信息;然后从代码库中查找与上下文相似的代码样例.然而,这些方法的输出仅仅是与上下文信息相似的代码样例,而不是满足对象实例化查询的方法调用序列.文献[14-18]利用数据挖掘技术推荐代码.这些方法采用关联规则挖掘[14-16]、随机游走[17]、时序模式挖掘[18]等策略推荐代码.但是,这些方法的输入不支持对象实例化查询,因此不能生成满足要求的方法调用序列.文献[19-20]采用信息检索技术搜索样例代码.通常,这些工作首先对代码库中的源文件进行索引;然后通过信息检索技术(如关键词匹配)来查找相关的代码样例.文献[19]对13个典型的代码搜索引擎(如Codease①,GoogleCodeSearch②,Krugle③)进行了对比.然而,代码搜索引擎常返回海量、结构复杂的结果页面,使用户很难快速地定位正确解.上文介绍了相关工作,接下来阐述本文为刻画类库API依赖关系所构建的图模型,本文设计的搜索算法将根据此图进行求解.3加权API图模型3.1相关术语介绍本文使用的相关术语及其定义见表3.术语方法(mi)服务质量QoS查询R方法匹配全局服务质量GQoS3.2WAG图模型为准确地表达相关类库包含的API依赖关系以及API历史使用信息,本文设计了一个新型的加权API图模型(WeightedAPIGraph,WAG)G=(M,E)对API依赖关系进行建模,如图3所示.本文将基于此图来搜索满足对象实例化查询的解.在WAG中,节点集M表示API方法集合,mk∈M,mk=(k,I,o,ω).其中,k是节点mk的标识,I和o分别表示mk对应方法的输入参数类型集合和唯一的输出参数类型.mk有相应的权值(即方法的QoS),由加权函数ω:M→R给出.有向边集E表示方法匹配集合,该集合满足:ek∈E,ek=(mu,mv,tagek其中,mu和mv分别是边的头结点(headnode)和尾节点(tailnode),mu是的mv直接前继,mv是mu的直接后继,mu对应的方法匹配mv对应的方法.ek的标记tagek(1)tagek=mu.o;(2)tagek∈mv.I.需要特别指出,当查询请求R发起时,图中将动态生成临时的起始节点Source和终节点Destination,它们满足:(1)Source.I=∧Source.o=R.S;(2)Destination.I=R.D∧Destination.o=null.此外,WAG也可以处理下述两类特殊情形:情形1(向上转型):在面向对象的编程语言中(如Java),因为向上转型(即将子类对象转换为父类对象)为永远安全的操作,所以尽管有些向上转型操作未在相关源代码中出现,本文也将在图中构建表示这类操作的节点;情形2(静态方法):由于调用静态方法无需输入接收者对象,当查询请求发起时,将构建从起始点到静态方法对应节点的边.3.3图性质与经典图论的节点可达性不同,WAG图的节点可达性如下.定义1.节点的可达性.给定WAG图G=(M,E),在一次从起始节点Source开始的搜索过程中,mi∈M,mi可达当且仅当inputi∈mi.I,pi=〈Source,…,mi-1,mi〉,使得路径pi中的边e=(mi-1,mi,tage)满足tage=inputi.①②③④I表示包含输入参数的集合,而使用小写字母o表示单个返Page6在定义1中,一个节点mi可达,不仅要求从Source到mi存在路径,而且要求存在从Source到mi的路径集合,使得该路径集合必须包含mi的全部输入类型作为Tag的入边.这不同于经典图论的节点可达性.在经典图论中,判断一个节点mi是否可达,只需判断从Source到mi是否存在路径即可.基于WAG图的搜索算法在访问节点时遵循如下原则:若一个节点mi可达,则可访问mi的后继节点;否则,不能访问.特别地,当在WAG图上进行搜索时,可访问mi的后继节点的含义为:可调用mi对应的API方法获取mi输出类型的对象.因此,当mi输入类型的对象还未被全部获取时,定义1中的可达性能够避免错误地调用该方法获取其输出类型的对象.例如,在图3中,当从Source开始搜索时,首先找到路径p=〈Source,m1,m2,m4〉.然而,此时m4并不可达.原因在于m4的另外一个输入类型D作为Tag的入边未被p包含.需要指出,在传统的全局连通图模型中,其节点的可达性质与经典图论相同:对于任意节点mi,当存在从起始节点到mi的路径时,mi即为可达.它不能保证被调用的API方法的所有输入类型均已被实例化.例如,在图2(a)中,当从节点C开始搜索时,尽管可通过访问边C.m4使得节点E可达,但是此时API方法C.m4的另外一个输入D还未被实例化,从而将导致自由变量的出现.根据第1节中的分析可知,这将引发“弱DAG机制”问题,因此会显著影响相关系统的准确率.综上所述,与现有全局连通图模型相比,本文提出的WAG模型能够更准确地描述API方法能否被调用,因此可以基于WAG及其节点可达性质设计新的搜索算法来提高系统的准确性.可见,在对象实例化领域,加权API图模型的提出弥补了现有全局连通图模型的不足,是本文的一个主要创新.3.4问题定义给定查询请求R,本文将其对应的对象实例化问题转化为基于WAG模型的Top-K子图查询问题.定义2.Top-K子图查询问题.给定查询请求R和WAG图G=(M,E),加权函数ω:M→R表示从节点集合到实数集合的映射.子图集合SGAll表示所有满足R的方法调用序列对应子图的集合.SGAll中的每个子图定义了其蕴含的方法(m1,m2,…,mn)的一个调用结构,这些方法满足如下关系:(1)mi.I∪(2)R.D∪子图SGi的权重值是指SGi包含节点的权重值的聚合值:ω(SGi)=SGi.GQoS.定义最优子图SG的GQoS为δ=Min{ω(SGi)|SGi∈SGALL}.SGAll中的最优子图定义为权重ω(SGi)=δ的任何子图.Top-K子图集合SGTop-K表示SGAll中权重值最优的K个子图组成的集合,它们满足:(3)Max{ω(SG)|SG∈SGTop-K}Min{ω(SG)|SG∈SGAll-SGTop-K}.由上述定义可知,在WAG图中找出满足查询请求R的前K个GoS最优子图的问题等价于Top-K子图查询问题.本文将在第5节详细阐述Top-K子图查询问题的图搜索算法.此外,本文的目标子图是一个个DAG形式的解,只有在特殊情况下才是链状解(子图中所有方法的输入参数均为一个).例1.以图3为例,给定对象实例化查询(A,D),图中矩形框内的图可作为一个DAG形式的解.3.5QoS类型与计算规则WAG中子图GQoS的计算规则将在本小节进行说明.该计算规则与QoS类型和调用模式相关.3.5.1QoS类型文献[21-22]定义了两类QoS:(1)否定型,即QoS值越大,服务质量越差,比如响应时间和价格;(2)肯定型,即QoS值越大、服务质量越好,比如吞吐量和声誉.同时,为了对多个QoS进行统一度量,按照度量方式的不同又可把QoS分为以下4种类型:(1)累加型,如使用次数,两个API总的使用次数由两个API各自的使用次数累加得到;(2)最小值型,如吞吐量,两个顺序调用的API处理数据的全局吞吐量,由具有最小吞吐量的API决定;(3)乘积型,如声誉、可靠性;(4)最大值型.在本文中,方法的QoS将利用API方法在相关项目中的使用次数进行计算.式(1)给出了具体的计算方式:mi.QoS=Log烄烅烆+,在式(1)中,mi.Count表示方法mi的在相关项目中被使用的次数,Max和Min分别表示所有方法中,被使用的最大次数和最小次数.本质上,式(1)计算出的QoS值是方法调用次数的正则化形式.因为Page7方法的QoS越小表明方法被使用的频率越高,被采纳的可能性也越高,所以QoS越小的方法服务质量越优,反之越差.因此,本文设计的QoS属于否定型.3.5.2GQoS计算规则GQoS的计算规则由图的组合模式和QoS类型共同决定.在组合模式方面,WAG模型中包含的原子结构可被顺序、合并和分叉3种组合模式充分描述,如图4所示.在QoS类型方面,本文定义的QoS表示API的调用次数,适用于累加型度量标准.据此可定义相关组合模式的GQoS计算规则,如表4所示.模式顺序合并分叉在顺序模式中,因为节点依次被顺序调用,所以采用累加型函数计算GQoS聚合值.即最后一个被调用节点m的由其所有前驱的QoS和其自身的QoS累加得到.在合并模式中,当m1-mn均已能够被调用时,才可调用节点m.在本文中,m的GQoS由m1-mn中GQoS质量最差的节点决定,同时又因为节点的QoS属于否定型,所以采用最大值函数和累加型函数计算GQoS聚合值.即合并节点m的GQoS是所有前驱GQoS的最大值与其自身QoS之和.在分叉模式中,当m能被调用时,则可调用其分支节点m1-mn中的任一节点.因此可采用累加型函数计算GQoS聚合值,即分支节点的GQoS由其分叉节点m的GQoS和其自身的QoS累加得到.例2.以图3为例,利用表4中的GQoS计算规则可得m4.GQoS=∑(max{m2.GQoS,m3.GQoS},m4.QoS)需要指出,WAG图中任意子图SGi的GQoS是根据SGi中所有节点QoS按照指定规则计算出的聚合值.该值最终等于SGi中终结点的GQoS.4APISynth系统概述本文设计并实现了APISynth系统,该系统实现了Top-KDAG图搜索算法.如图5所示,APISynth包括图构建模块、解搜索模块和结果排序模块.图构建模块负责分析类库源码并构建WAG模型,包括代码分析器和图模型构建器.代码分析器负责分析源代码,生成API依赖信息和QoS信息.软件分析技术可分为静态分析和动态分析两类[22].借助工具Spoon①和Javassit②,本文对类库源码进行了静态分析,抽取其中的API依赖关系.图模型构建器则负责构建WAG模型.解搜索模块完成Top-K子图查询,包括关键路径搜索器和DAG构建器.前者负责生成关键路径.后者负责构建每一条关键路径对应的DAG.结果排序模块使用排序处理器对推荐结果进行排序.下文将分别对3个模块中的工作进行介绍.4.1WAG图的存储结构及构建鉴于WAG图的特殊结构和新的节点可达性质,为提高搜索算法的效率,本文未使用经典的图存储结构,如邻接表或邻接矩阵表示WAG,而是设计了新型的存储结构,如图6所示,包括节点表,倒排索引表和可触发参数表.①②Page8节点表用来存储节点及其相关信息.本文使用五元组表示节点,具体形式为{mi,Imi,Omi,selfQoS,GQoS,Number,Status}.其中,mi是节点的标识;Imi和Omi分别表示节点的输入参数集和输出参数集;selfQoS表示节点自身的QoS;GQoS表示从起始节点到当前节点的全局QoS;Number用于记录节点需要被实例化的输入参数的个数,初始值为节点输入参数集的大小;Status表示节点的可达状态,默认状态为不可达,记为disabled.在搜索过程中,当Number变为0时,将Status置为enabled,表示节点可达.需要指出,GQoS、Number和Status将在搜索过程中动态更新(见第5节).倒排索引表用来表示和存储WAG.表中的项为键值对(参数,节点集).其中,键为参数,其值为需要该参数作为输入的节点集合.倒排索引表的使用能极大提高Top-K子图的搜索效率.尽管与传统的邻接表和邻接矩阵相比,使用倒排索引表存储图将耗费更多的内存空间,然而这对主流计算机并不构成挑战性问题.本文将在6.3.3小节对此进行讨论.可触发参数表(ReachablePreconditionTable,RPT)用来存储搜索过程中可达节点的输入参数及其最优提供者的相关信息.4.2Top-犓子图搜索本小节阐述Top-KDAG图搜索算法,它能直接求取DAG形式解,而不仅仅是传统最短路径算法求取的链状解.因此,基于Top-KDAG搜索算法的APISynth系统无需人工干预,可自动地完成对象实例化解的推荐.对于DAG形式的子图,本文作者观察到其包含一条特殊路径p,满足p.GQoS=DAG.GQoS.p被称为次DAG的关键路径.受此启发,算法首先生成关键路径;然后基于关键路径构建DAG图形式的解.因此,Top-K子图查询问题简化为求取Top-K条关键路径.根据以上分析,本文需要解决如下问题:(1)如何在未知DAG的情况下求取关键路径?(2)如何根据关键路径构建DAG,并保证DAG全局服务质量的最优性以及DAG中的节点均满足定义1中的可达性质?(3)如何求取更多条关键路径以获得K个GQoS最优的DAG?Top-KDAG搜索算法通过4个主要步骤解决上述问题,如图7所示(算法细节见第5节).(1)执行一次从Source节点开始的前向搜索,在搜索过程中确认所有可达的节点,并记录可达节点相关的信息,如GQoS和节点输入的最优提供者.(2)根据步1中记录的信息,执行一次从Desti-nation节点开始的后向搜索,求取出GQoS最优的关键路径kpopt,并将其放入优先队列中.(3)弹出优先队列中的关键路径,并利用其构建DAG.如果DAG的数量小于设定的阈值,则执行步4;否则,终止.(4)对当前弹出的关键路径使用“松弛”操作来生成其他GQoS较差的关键路径.然后返回步3以生成更多的DAG.4.3结果排序为减少开发人员检查结果的次数,需要对候选结果进行排序,将优越的结果推荐给开发人员.本文采用4个度量标准对结果进行评价,包括GQoS、节点个数、边数和直径(关键路径的长度)①.本文使用的排序准则为上述4个度量值越小,结果排名越高.其合理性体现为:(1)GQoS反映了一个子图对应方法调用序列的总体使用频率,而优先选择较常使用的代码是编程人员的共识[3];(2)其余①可根据需要将4个度量标准扩展至更多个.Page93个度量标准反映了一个子图对应代码的数量(度量值越小,代码量越小).据统计,编程人员倾向使用代码量小的方案[2-3].传统方法[2-3,5-6]仅采用路径长度来评价结果的代码长度.与之不同,本文综合考虑了待评价结果中包含的节点、边和直径等信息,因此可令DAG图形式解的优劣得到更全面、准确地反映.本质上,此处的排序问题是一个多对象多属性的排序问题.这与数据库领域的多维排序类似.因此,本文的排序算法可借鉴经典的多维数据集排序算法———Fagin算法[23].算法流程如图8所示.首先,计算DAG形式解的4个度量值(Criteria1~Criteria4),并分别根据不同的度量标准对结果进行排序(为提高效率,该过程可并行执行).式(2)定义了DAG图形式解SGi度量值的计算规则:SGi.Score=烄SGi.Ck-Min{Ck}Max{Ck}-Min{Ck}烅1,烆其中,Ck(k∈1,2,3,4)表示相应的度量标准的得分.Max(Ck)和Min(Ck)分别表示所有结果中Ck度量标准的最大得分和最小得分.其次,生成各度量标准的评分表(List1~List4),并计算聚合值得到最终评分:其中,权值ω满足∑5Top-犓DAG搜索算法详解本节详细阐述Top-KDAG搜索算法.它包括3个核心模块:(1)最优关键路径求取①;(2)如何根据关键路径构建DAG;(3)如何通过对当前关键路径进行松弛操作,生成新的关键路径.5.1最优关键路径求取(步1~2)算法的前两步旨在求取GQoS最优的关键路径.为此,本文实现了Sim-Dijkstra算法.算法的基本思想是:(1)根据查询请求,执行一次从端点Source到端点Destination的前向搜索,找出两端点之间所有可达的节点;(2)将每个可达节点输入的最优提供者记录到可触发参数表RPT中;(3)当前向搜索结束后,发起一次后向搜索过程Backward-KP求取最优关键路径.5.1.1相关概念定义3.节点输入的最优提供者.即该节点所有可达前驱中,提供该输入且GQoS最小的前驱结点.其形式化定义如下:给定WAG图G=(M,E),mi∈M,inputi∈mi.I,inputi的最优提供者为popt,popt∈M,当且仅当popt满足:(1)popt.status=enabled;(2)popt.o=inputi;(3)popt.GQoS=Min{m.GQoS|m∈M∧m.o=inputi∧m.status=enabled}.定义4.关键前驱.即某节点所有输入的最优提供者中GQoS最大的那个最优提供者.其形式化定义如下:给定WAG图G=(M,E),mi∈M,节点Mi的关键前驱定义为π(mi)=mkp,当且仅当节点mkp满足:(1)mkp∈M;(2)mkp.o∈mi.I;(3)mkp.GQoS=Max{inputi.popt.GQoS|inputi∈mi.I}.例3.以图3为例,对于m4的两个输入C和D,它们对应的最优提供者分别为m4的前驱m2和m3.并且有(m2.GQoS=4.5+3.7=8.2)>(m3.GQoS=7.2).由此可知,m2是m4的关键前驱.定义5.关键路径.即DAG中一串顺序相连的关键前驱构成的路径.其形式化定义如下:在WAG图G=(M,E)中,给定从mi节点到mj节点的子图SG,则SG的关键路径为p=〈mi,mi+1,…,mj〉,当且仅当p中节点满足:例4.图9展示了一个DAG及其关键路径.①与最优DAG对应的关键路径为最优关键路径.Page10需要指出,关键路径不是一条随意选取的普通路径,它的GQoS与DAG的GQoS相同.5.1.2Sim-Dijkstra算法Sim-Dijkstra算法使用一个优先队列enabled-Nodes存储未处理的可达节点.队列enabledNodes的性质是优先弹出具有最小GQoS的节点.其巧妙之处在于能够避免可达节点的多次更新处理,提高算法效率.具体过程见算法1:首先,使用Source节点来初始化enabledNodes(第1~2行);其次,使用popBest()①操作优先弹出enabledNodes中GQoS最好(最小)的节点.然后,对于每个enabledNodes中弹出的节点v,如果v的输出(par)未被存储到RPT中,算法将添加相关的项(par,v.GQoS,v)到RPT中(第4~7行);最后,对于v的每个后继节点u,令其Number值减1,以表示这些节点的相关输入已被实例化.因此,当u的Number值为0时,其状态将被置为可达(第8~11行).上述操作会不断循环执行以获得新的可达节点并将它们存储到enabledNodes中.当enabledNodes为空时,算法将终止.需要指出,Sim-Dijkstra算法能够确保每一个RPT表项中参数(par)的提供者(provider)均为其最优提供者.究其原因在于优先队列enabledNodes中GQoS最好的节点popt总是被优先处理.因此,popt输出参数M将优先存入RPT表中.当其他提供参数M的节点再被处理时,根据算法1第5行中的判断逻辑,这些节点将不能作为M的提供者存入RPT表项中.综上所述,当算法1结束后,RPT表中所有参数的提供者均为其最优提供者.算法1.Sim-Dijkstra算法.输入:WAG图模型、优先队列:enabledNodes输出:节点可达信息(RPT表项)1.初始化优先队列enabledNodes;2.enabledNodes.add(Source);3.WHILEenableNodes≠DO4.venableNodes.popBest();5.IFv.oRPT.keys()THEN6.FOREACHnodeu∈v.successorsDO7.RPT.addentry(par,v.GQoS,v);8.u.Number--;9.IFu.Number=0THEN10.u.GQoSgetGQoS(u);11.enabledNodes.add(u);12.ENDIF13.ENDFOR14.ENDIF15.ENDWHILE例5.以图3为例说明Sim-Dijkstra算法的执行过程,见表5.步骤enabledNodes(GQoS)123455.1.3Backward-KP过程利用Sim-Dijkstra算法输出的RPT表,本文采用Backward-KP过程生成所需关键路径,具体过程见算法2:首先,依次初始化栈kpStack和关键前驱变量keyPredecessor(第1~2行);其次,将keyPredecessor中的节点入栈,并利用RPT表记录的参数的最优提供者信息迭代求取当前节点的关键前驱,当keyPredecessor中的节点为Source时,终止迭代(第3~6行);最后,依次弹出kpStack中的节点生成关键路径(第7行).算法2.Backward-KP过程.输入:节点可达信息、节点输入的最优提供者输出:关键路径1.初始化栈kpStack;2.keyPredecessorDestination;3.WHILEkeyPredecessor≠SourceDO4.kpStack.add(keyPredecessor);5.keyPredecessorπ(keyPredecessor);6.ENDWHILE7.keyPathkeyPredecessor+kpStack.popall();例6.以图3为例说明上述执行过程,见表6.①popBest()是优先队列的元素弹出操作.在实验中,优先队Page11步骤1234565.2DAG解构建(步3)关键路径用于指导构建DAG(当解为链状形式时,此步骤将被省略).具体过程如下,从Destination到Source发起一次沿关键路径的后向搜索生成DAG:对于关键路径上的节点,其关键输入参数的提供者为关键前驱;对于其他输入参数,选取不改变当前节点关键前驱的提供者.对于非关键路径上的节点,根据RPT存储的信息查找其输入参数的最优提供者.需要指出,按照上述过程构建的DAG,其GQoS与关键路径的GQoS相同.例7.以图3为例说明DAG的构建过程,见表7.步骤1234565.3关键路径松弛(KPL)算法(步4)如果构建的DAG的数量小于阈值K时,本文将对最优关键路径进行松弛操作来生成服务质量较差的其他关键路径.这些新的关键路径将继续指导构建与其对应的DAG.本文将被松弛的关键路径称为最优关键路径,通过松弛操作生成的路径称为非最优关键路径.定义6.松弛①操作Loose.松弛操作的作用对象是关键路径上的节点,它旨在改变当前关键路径上某个节点的关键前驱,以获取该节点新的关键前驱,从而令新关键前驱的GQoS仅大于旧关键前驱的GQoS.形式化定义如下:对于关键路径p=〈mi,mi+1,…,mj〉,mk∈p,其关键前驱mkp=mk-1,k>i.给定mk的可达前驱集合Pmk(1)m.status=enabled;(2)m.o∈mk.I;令mkp=Loose(mk),则Mkp满足:(3)mkp∈Pmk-mkp;(4)mkp.GQoS>mkp.GQoS,k>i;(5)mkp.GQoS=Min{m.GQoS|m∈Pmi-mkp}.例8.以图10为例解释松弛操作.选取m4作为松弛节点.由图10可知,m4输入参数的提供者包括m3、m2和m5,这些节点的GQoS分别为7.2、8.2和15.其中,m4的关键前驱为m2.根据松弛操作的定义可得m5=Loose(m4).非最优关键路径生成:按照从Destination节点到Source节点的顺序,依次对关键路径的节点mk进行松弛操作.若存在mkp=Loose(mk),则首先由mkp节点开始执行Backward-KP过程求取一条从Source到mkp的路径,然后将这条路径与最优关键路径包含的从mkp到Destination的子路径进行组合,得到新的关键路径.需要指出,新求取的关键路径的GQoS将差于(大于)原有关键路径的GQoS.例9.以图10为例,其最优关键路径为〈Source,m1,m2,m4,Destination〉(GQoS=9.9).图中的虚线双箭头标明了一条非最优关键路径,其具体生成过程见表8.步骤123456本文结合松弛操作实现了关键路径松弛KPL(Key-PathbasedLoose)算法.当使用最优关键路径①本文之所以使用“松驰”这个动词表示其他非最优主路径的Page12不足以生成足够数量的DAG时,KPL算法能够找出定义2中满足查询R的Top-K子图.算法的具体过程见算法3:首先,分别使用最优关键路径和数值k初始化优先队列keyPaths和阈值变量threshold(第1~2行).keyPaths的性质是具有最小GQoS的关键路径将优先弹出.其次,对keyPaths进行循环操作.当keyPaths不为空时,弹出当前最优的关键路径并构建该关键路径对应的DAG(第4~5行).如果DAG的数量满足阈值要求,则算法结束;否则,更新阈值,并对当前关键路径的节点进行松弛操作.同时,联合Backward-KP过程生成新的GQoS较差的关键路径,并将这些关键路径存储到keyPaths中(第7~11行).算法3.KPL算法.输入:最优关键路径P,阈值k输出:Top-K子图1.keyPathsP;2.thresholdk;3.WHILEkeyPaths≠DO4.keyPathkeyPaths.popBest();5.DAGskeyPath.constructDAGs();6.IF|DAGs|thresholdTHENreturn;7.thresholdthreshold-|DAGs|;8.FOREACHnodev∈keyPathDO9.newKeyPathLoose(v)Backward-KP();10.keyPaths.add(newKeyPath);11.ENDFOR12.ENDWHILE6实验6.1实验设置基于Top-KDAG搜索算法,本文实现了APISynth系统来自动地进行对象实例化推荐.实验设置介绍如下:实验环境.2.4GHzCPU,4GBRAM,Windows7操作系统.对比方法.基于全局图模型的方法Prospector①[2]、基于局部图模型的方法②ParseWeb[5]和GraPacc[6].测试数据集.公平起见,实验基于对比工作使用的类库和必要的Java依赖包构建图模型.具体而言,与Prospector和ParseWeb对比时使用了GEF(GraphicalEditingFramework)类库,而与GraPacc对比时使用了JavaSDKUtility(java.util,java.io)类库.此外,基于GEF类库的Logic③项目源码将用于统计相关API的使用频率.测试查询.实验使用了50个(Source,Destination)形式的查询进行对比实验.其中包括选自文献[2,5]的42个已有查询,以及本文为实验设计的8个查询.需要指出,满足实验所用查询均需要完成较为复杂的编程任务:需要调用构造器函数或执行向上、向下转型操作或调用静态方法.度量准则.针对一个查询任务,API推荐系统将生成多个候选结果供开发人员选择.为了对相关推荐系统进行评估,本文采用推荐系统常用的评价指标,如查全率、准确率和F值来对推荐结果的优劣进行统一衡量.因为候选结果中排名第一的结果的重要程度最高,所以本文采用信息检索领域广泛使用的度量指标P@1评估准确率.具体而言,查全率(Recall)表示可被满足的查询在所有查询中的比例.准确率(P@1)表示在可被满足的查询中,候选结果列表中Top1结果为正确的查询的比例.F值表示准确率和查全率的调和平均:F-score=2/(1/P@1+1/Recall).6.2对比实验6.2.1APISynthvs.Prospector基于文献[2,5]中的查询,本文对比了APISynth和Prospector的推荐结果.实验结果见表9、表10、表11和表12中的相关列:Prospector能够支持的查询数量分别为18,7,6和8,而APISynth则分别为20,11,10④和8.实验结果表明在能够支持的查询方面,APISynth优于Prospector.原因分析如下:实验中,对于需要DAG形式解的查询,Prospector会返回大量无关的结果,其正确的结果往往被淹没在海量的无效解中.与Prospector相比,APISynth能够直接搜索出DAG形式的解,能对其进行全面、准确评价,因此提升了系统的准确率.需要特别指出,APISynth唯一未能解决的查询任务是表9中的(AbstractDecoratedTextEditor,ProjectViewer).根据分析,本文作者发现GEF类库中不包含ProjectViewer类型,因此该查询任务也不能被其他方法解决.①②③④Page13表9基于文献[2]中使用查询任务的实验对比结果InputStreamStringTableViewerIWorkbenchScrollingGraphicalViewerFigureCanvasKeyEventEnumerationSelectionChangedEventISelectionImageRegistryMapIViewPartTableViewerIEditorSiteStringIWorkbenchPageIWorkbenchPageIFileIWorkbenchWindowAbstractGraphicalEditPartConnectionLayerIWorkspace注:PROS:Prospector,APIS:APISynth,Nil:当前候选结果集中被评判为正确结果的个数为0.表10基于文献[5]中使用查询任务的实验对比结果ISelectionIStructuredSelectionICompilationUnitYesYesYesElementChangedEventICompilationUnitYesYesYesIEditorPartIEditorPartViewPartTextEditorActionTextEditorActionITextEditorAbstractDecoratedTextEditorITextEditorITextEditor注:PARS:ParseWeb,PROS:Prospector,APIS:APISynth.表11基于Logic项目相关查询任务[5]的实验对比结果SourceIPageSiteActionRegistryIActionActionRegistryProviderIPageSiteProviderIPageSitemanagerStringCompositeCompositeGraphicalViewerThumbnailGraphicalViewer注:NO:推荐结果集的大小,RA:用户期待结果的排名,PARS:ParseWeb,PROS:Prospector,APIS:APISynth,Nil:当前候选结果集中被评判为正确结果的个数为0.表12基于JavaSDKUtility相关查询任务的对比结果SourceFileReaderInputStreamBufferedReader16Nil104121LinkedHashMapIteratorArrayListFileWriterFileInputStreamDataInputStream36Nil201121FilePattern注:NO:推荐结果集的大小,RA:用户期待结果的排名,GraP:GraPacc,PROS:Prospector,APIS:APISynth,Nil:当前候选结果集中被评判为正确结果的个数为0.6.2.2APISynthvs.ParseWeb基于文献[5]中的查询本文对APISynth和ParseWeb进行了对比实验.实验结果见表10和表11的相关列:ParseWeb支持的查询数量分别为11和8,而APISynth则分别为11和10.实验结果表明,在支持的查询数量方面APISynth优于ParseWeb.原因分析如下:由于ParseWeb使用语句间的控制流构建图模型,无法对更为精细的API之间的数据依赖关系进行刻画,将造成某些查询请求无法被满足.下面以图11为例对此进行解释.当编程人员输入查询(GraphicalViewer,IFigure)时,尽管示例代码包含满足查询的方法调用序列,然而ParseWeb不能根据这段代码推荐出相关的解.原因在于ParseWeb无法分析出方法getGraphical-Viewer()返回值为GraphicalViewer这一数据依赖关系,从而无法匹配查询包含的类型.6.2.3APISynthvs.GraPacc本小节实验对比了APISynth和GraPacc[6].实验结果见表12:APISynth能够支持所有的查询,而GraPacc仅支持4个查询.实验结果表明,在支持的查询数量方面,APISynth优于GraPacc.原因分析如下:因为GraPacc不能利用跨模式的API依赖,所以减少了推荐出正确解的可能性.此外,GraPacc还受限于模式库中模式的数量.例如,因为满足查询(InputStream,BufferedReader)的方法调用序列未包含在模式库中,所以GraPacc不支持该查询.Page146.3评价与分析根据上述对比实验的结果,本文从3个方面对相关工作进行评估,包括推荐结果的正确性、最优结果的检测次数以及推荐系统的响应时间.6.3.1正确性根据对比实验结果,本文对相关工作的准确率、查全率和F值这些反映结果正确性的指标进行了评估.需要指出,在被评估的相关工作中,APISynth和Prospector是基于全局图模型的方法,而ParseWeb和GraPacc是基于局部图模型的方法.本文采用专家组评判的方法对推荐结果的正确性进行评判.专家组成员包括7名具备3年以上Java表13实验结果评价APISynthParseWeb查全率P@1F值Check#6.3.2结果检测次数衡量API推荐系统的一个重要指标是系统能否提高开发人员的编程效率.为此,依据对比实验结果中的Rank值,本文统计了用户在找到期望结果之前,需要检测候选结果的平均数目.例如,若期望结果的Rank值为k,则表明找到该结果之前需要用户从头开始查阅排名靠前的k-1个结果,于是共检测结果数目为k次.因此,实验计算了相关表中的rank列值(表9、表11和表12)的平均值作为结果检测次数,如表13中的Check#所示.公平起见,实验只选取对比方法双方均可支持的查询任务作为统计源.实验结果表明,与其他方法相比,使用APISynth可显著减少正确结果的检测次数,因此能提高开发人员的编程效率.6.3.3系统响应时间APISynth借助特殊的数据存储结构能极大地提升算法的执行效率.实验结果表明,APISynth完成一次查询的平均时间通常在200ms以内,足以满足开发人员在系统响应速率方面的要求.需要指出,虽然相比邻接表或邻接矩阵等传统图存储结构,本文采用的存储结构需要耗费更多的内存空间,但是实验结果表明,这对于当今拥有GB级别内存的主流计算机不构成挑战性问题.本文对APISynth运行时占用的内存进行了跟踪统计.结果显示,APISynth工作时平均只消耗15MB的内存来存储GEF类库及其依赖库.据统计,GEF类库及其依编程经验的程序员.具体而言,多数专家支持的推荐方案将最终被评判为正确结果.本文将记录候选结果集中第1个被评判为正确结果的位置,如表9、表11和表12的Rank列所示.当候选结果集中没有任何结果被评判为正确时,相应的rank值将置为Nil.表13给出了准确率、查全率和F值的评估结果.由此可知,与基于局部图模型的方法相比,API-Synth将系统的查全率平均提升了40%;而与基于全局图模型的方法相比,APISynth将系统的P@1提升了34%.此外,与其他方法相比,APISynth将F值平均提升了21%.这表明APISynth能够更好地兼顾查全率和准确率.0.800.560.662.25赖库包含的方法和对象数目均在60000以上,而常用的44个类库的方法和对象数目均小于5000[6,11].综上可知,APISynth在多数情况下可以高效地工作,而不会受到内存容量的限制.7结论针对对象实例化,本文设计并实现了一种基于新型加权API图(WAG)的API推荐系统———APISynth.新型WAG图可更全面、准确地描述API的调用依赖关系,有效地提升了推荐系统的查全率.此外,本文提出的基于WAG图的Top-KDAG搜索算法可直接搜索DAG形式的解使得系统能对其进行准确地评分.基于真实类库数据集进行的对比实验表明,与现有方法Prospector、ParseWeb和GraPacc相比,APISynth在准确率和查全率两方面获得了更好的表现.同时APISynth的响应时间在200ms以内,能较好地满足开发人员的需求.在未来的工作中,我们将主要从以下两个方面进一步加强研究:(1)根据实际需要,在搜索算法中引入更多维度的QoS,深入研究多维QoS场景下最优方案的求取机制;(2)当类库版本变更时,由于类库中API的变化,原有支持旧版本类库的推荐结果常在新版本类库环境下发生编译错误.为此,我们将研究如何根据新旧版本之间的差异实现过时推荐结果的主动发现和自动迁移.Page15
