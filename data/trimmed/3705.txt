Page1基于证书强指定验证者签名方案李继国1)钱娜1)黄欣沂2),3)张亦辰1)1)(河海大学计算机与信息学院计算机系南京210098)2)(新加坡管理大学信息系统学院新加坡)3)(福建师范大学数学与计算机科学学院福州350007)摘要借鉴无证书指定验证者签名的思想,提出了基于证书密码体制的强指定验证者签名的概念和安全模型.构造了基于证书的强指定验证者签名方案并分析了方案的通信代价和计算代价.基于GBDH困难问题假定,在随机预言模型下证明了方案对适应性选择消息攻击是存在不可伪造的.提出的方案较好地解决了基于身份指定验证者签名中的密钥托管问题.此外,提出的方案具有通信代价低、能够抵抗密钥替换攻击等优点.关键词公钥密码学;基于证书签名;强指定验证者签名;GBDH问题;随机预言模型1引言Jakobsson等人[1]在1996年欧密会(EurocryptPage2名的验证.这样既解决了普通签名中任何人都可以验证签名的问题,又解决了不可否认签名中签名人完全控制签名的问题.指定验证者签名的概念随后被扩展到强指定验证者签名[2]和广义指定验证者签名[3].强指定验证者签名中任何人都能生成一个与原始签名具有相同分布的副本,只有指定验证者借助自己的私钥才能验证原始签名的有效性.在强指定验证者签名中,知道两个可能的签名者(A0,A1)和指定验证者B的公钥,任何人无法区分一个指定验证者签名是A0指定验证者B的签名还是A1指定验证者B的签名.广义指定验证者签名具有保护签名持有者隐私的特殊性质,即允许任何一个签名持有者(可以不是签名者)通过引入验证者的公钥将签名指定给他所期望的任意指定验证者,指定验证者能够验证签名有效性,但无法使其他人相信这个事实.原始的指定验证者签名多是基于传统的公钥密码体制.传统的公钥密码体制中签名者的公钥本质上就是签名者自己选择的一个随机字符串,无法证明给定签名者的身份,需要一个可信的第三方用一个证书来将公钥和签名人的身份联系起来,所以在验证一个签名之前首先需要验证公钥的有效性.2004年,Susilo、Zhang和Mu[4]提出了基于身份的强指定验证者签名.2009年,Kang等人[5]提出了基于身份的强指定验证者签名方案的安全模型并给出了一个具体的构造.上述方案较好地解决了传统公钥密码体制的两次验证问题,可是基于身份的指定验证者签名存在密钥托管问题.2007年,王晓峰等人[6]提出了新的基于身份的广义指定验证者签名方案,通过引入两个PKG的方法部分解决密钥托管问题.为了更好地解决密钥托管问题,很多专家学者提出了无证书的指定验证者签名方案[7-8].2006年Huang、Susilo、Mu和Zhang[7]提出了无证书的指定验证者签名的定义,并给出了一个具体的方案,解决了传统公钥密码体制和基于身份密码体制中存在的固有问题.2008年,Chen等人[8]也提出了一个高效的无证书短指定验证者签名方案.随后,Yang等人[9-10]首先形式化了无证书强指定验证者签名的定义和安全模型并提出了一个较为高效的无证书强指定验证者签名方案.但是,无证书公钥密码体制中仍存在需要安全通道来传输秘密值的缺陷.在2003年的欧密会上,Gentry[11]提出了基于证书密码体制,克服了基于身份公钥密码体制和传统公钥密码体制的缺陷.因为证书只是为了证明用户公钥的真实性以及与身份的惟一对应关系,证书并不需要保密,所以很好地解决了基于身份密码体制中PKG与用户之间的密钥传递需要安全信道问题.与无证书公钥密码体制相比,由于证书的存在,它也避免了无证书公钥密码体制容易遭受公钥替换攻击问题以及KGC与用户之间的密钥传递需要安全信道问题.在CT-RSA’04上,Kang和Park等人[12]首次提出了基于证书签名方案,并在随机预言模型证明了安全性.Li等人[13]把密钥替换攻击引入到基于证书密码体制中,指出Kang和Park等人[12]提出的基于证书签名方案不能抵抗密钥替换攻击,并且对Kang和Park等人的基于证书签名方案的安全模型进行了增强.进一步,基于计算Diffie-Hell-man假定他们提出了一个新的基于证书签名方案,并在增强的安全模型下证明了方案的安全性.与现有的基于证书签名方案相比,提出的方案具有签名长度短,计算代价低等优点.Wu等人[14]提出了一个更加合理和精确的基于证书签名的安全定义.在该定义中,根据攻击者具有的能力区分了三种类型的攻击者.进一步,提出了一个从任意安全的无证书签名方案构造基于证书签名方案的一般方法,并证明了方案的安全性.Au等人[15]提出了基于证书的环签名方案,较好地解决了传统PKI中复杂的证书链验证问题,并在随机预言模型下证明了方案的安全性.Liu等人[16]提出两个新型的基于证书签名方案,一个是不使用双线性对的方案,在计算代价上具有一定优势,另一个方案是在标准模型下证明方案的安全性.Zhang[17]指出Liu等人[16]提出的不使用双线性对的基于证书签名方案是不安全的.2009年,Li等人[18]提出了一个基于证书代理签名方案,并在随机预言模型下证明了方案的安全性.Ming和Wang[19]提出了一个高效的基于证书签名方案.2010年,Li等人[20]提出两个能抵抗密钥替换攻击的基于证书签名方案.第一个方案,基于计算Diffie-Hellman假定,在随机预言模型下证明提出的方案对自适应选择消息攻击是存在不可伪造的,具有较短的签名长度,较小的计算代价等优点,是一个可证安全的高效签名方案.第二个方案,首次构造了标准模型下安全的基于证书签名方案,并在计算Diffie-Hellman假定下证明方案对自适应选择消息攻击是存在不可伪造的.最近,Li等人[21]提出一个基于证书的高效短签名方案,签名和验证仅需一个Pairing运算,签名长度为一个群元素,非常适合于计算和应用在带宽受限的网络环境中.Page3本文将基于证书的概念引入到指定验证者签名中,借鉴无证书指定验证者签名的思想,提出了基于证书强指定验证者签名的概念和安全模型.基于GBDH困难问题假定,构造了一个基于证书强指定验证者签名方案,分析了方案的通信代价和计算代价.在随机预言模型下,证明了方案的安全性.较好地解决了传统公钥密码体制签名中需要二次验证的问题、密钥替换攻击问题和基于身份指定验证者签名中的密钥托管问题.2双线性映射及困难问题2.1双线性映射定义1.双线性映射.设G1是阶为大素数q的加法群,G2是阶为大素数q的乘法群.P是G1的生成元,G1,G2之间的映射e:G1×G1→G2如果满足以下性质,称为双线性映射:双线性性.对所有P,Q∈G1,a,b∈Zq,有非退化性.存在P,Q∈G1,使得e(P,Q)≠1;可计算性.存在一个有效的算法,对所有P,Q∈e(aP,bQ)=e(P,Q)ab;G1,可以计算e(P,Q).2.2困难问题设G1是阶为大素数q的加法群,G2是阶为大素数q的乘法群.P是G1的生成元,e:G1×G1→G2是双线性映射.定义2.CBDH问题(ComputationalBilinearDiffie-HellmanProblem).给定P,aP,bP,cP∈G1,其中a,b,c∈Z定义3.DBDH问题(DecisionalBilinearDiffie-HellmanProblem).给定P,aP,bP,cP∈G1,其中a,b,c∈ZP)abc是否成立,如果成立则输出1;否则输出0.定义4.GBDH问题(GapBilinearDiffie-HellmanProblem).给定P,aP,bP,cP∈G1,其中a,b,c∈Ze(P,P)abc∈G2的值.3基于证书强指定验证者签名的定义和安全模型3.1基于证书强指定验证者签名的定义基于证书强指定验证者签名(CBSDVS)系统中有3个实体参与,签名者IDA、指定验证者IDB以及可信第三方CA.该系统由设置、用户密钥产生、证书产生、签名、验证、副本模拟6个算法组成.设置:输入安全参数l,生成系统参数param.CA选择主密钥msk,并计算主公钥mpk.公开参数params={param,mpk}.用户密钥产生:输入参数params,输出用户的私钥-公钥对(sIDi,PIDi),i=A,B.证书产生:输入参数params、用户的身份IDi、公钥PIDi以及主密钥msk,CA生成该用户的证书certIDi,i=A,B.签名:输入参数params、消息m、IDA的证书certIDA、私钥sIDA以及IDB的公钥PIDB,输出有效的消息签名对(m,δ).验证:输入参数params、消息签名对(m,δ)、IDB的私钥sIDB、证书certIDB以及IDA的公钥PIDA,判断签名δ是否是消息m上的有效指定验证者签名,输出d∈{acc,rej}.副本模拟:这个算法是由验证者运行,用来生成一个与原始签名不可区分的副本.3.2基于证书强指定验证者签名的安全模型类似于无证书指定验证者签名方案,基于证书强指定验证者签名方案也定义了两类具有不同能力的敌手.第一类敌手AI可以按照自己的意愿替换所有用户的公钥,并得到替换公钥后对应的私钥,并且能够得到除目标指定验证者之外用户的私钥.还能得到除目标签名者以外的用户的证书和替换公钥后的证书,但是不能得到主密钥.这类敌手还可以欺骗任意第三方用替换后的公钥来验证签名有效性.第二类敌手AII模仿一个恶意的证书发放者,拥有主密钥,故可以产生任意用户的证书.基于证书强指定验证者签名的安全性用下面两个挑战者与敌手之间的游戏来描述.3.2.1CBSDVS游戏1敌手的适应性选择消息攻击.(1)初始化.挑战者运行设置算法产生系统参数param和主公钥mpk,并公开参数params={param,mpk}.同时,挑战者运行用户密钥产生算法产生PIDi,i=A,B.(2)用户公钥替换.敌手AI随机选择公钥PIDi替换任何用户IDi的公钥PIDi,并且AI知道PIDi对应的私钥sIDi.(3)密钥询问.敌手AI询问除指定验证者IDB之外的用户IDi的私钥sIDi,运行用户密钥产生算法产生用户的私公钥对(IDi,sIDi,PIDi),i∈{1,2,…},用以下挑战者与敌手交互的游戏,模拟第一类Page4将sIDi返回给敌手AI.(4)证书询问.敌手AI询问除目标签名者IDA之外的用户(IDi,PIDi)对应的证书,运行证书产生算法产生certIDi,返回certIDi给敌手AI.(5)签名询问.询问对消息m的签名,用签名算法产生签名δ,返回δ给敌手AI.(6)验证询问.询问消息签名对(m,δ,PIDA),运行验证算法判断是否是有效的消息签名对,返回d∈{acc,rej}给AI.满足:(7)伪造.敌手AI给出三元组(m,δ,PIDA)(a)δ是在公钥PIDA下对消息m的有效签名,(b)IDB都没有在密钥询问中出现过;(c)IDA没有在证书询问中出现过.用以下挑战者与敌手交互的游戏,模拟第二类且m没有在签名询问中询问过;3.2.2CBSDVS游戏2敌手的适应性选择消息攻击.(1)初始化.挑战者运行设置算法产生系统参数param,主密钥和主公钥对(msk,mpk),并公开参数params={param,msk,mpk}.同时,挑战者运行用户密钥产生算法产生PIDi,i=A,B.(2)密钥询问.询问非目标用户(除目标签名者IDA和目标指定验证者IDB之外的用户)IDi的私钥sIDi,运行用户密钥产生算法产生用户的私公钥对(IDi,sIDi,PIDi),i∈{1,2,…},将sIDi返回给敌手AII.(3)签名询问.对消息m进行签名询问,用签名算法产生签名δ,返回δ给敌手AII.(4)验证询问.询问消息签名对(m,δ),运行验证算法判断是否是有效的消息签名对,返回d∈{acc,rej}给敌手AII.(5)伪造.敌手给出二元组(m,δ)满足以下条件:(a)δ是对消息m的有效签名,且m没有在(b)IDA,IDB都没有在密钥询问中出现过.4基于证书强指定验证者签名方案设置:输入系统安全参数l,输出系统参数{G1,G2,q,e,P},其中,G1是阶为大素数q的加法循环群;G2是阶为大素数q的乘法循环群;P是G1的生成元;e:G1×G1→G2是双线性映射.签名询问中询问过;CA做如下操作:(1)随机选择秘密值s∈Z计算它的主公钥mpk=Ppub=sP.(2)选择两个Hash函数H0:{0,1}×G1→G1;H1:0,{}1×G2×G2→G1.(3)公开参数params=(G1,G2,q,e,P,H0,H1,Ppub),主密钥msk=s保密.用户密钥产生:用户IDi选择自己的私钥sIDi,计算对应的公钥PIDi=sIDiP,生成自己的私公钥对(sIDi,PIDi),i∈{A,B}.证书产生:CA用系统参数和主密钥msk来产生用户证书.(1)用户IDi发送一个数据串data给CA,这个数据串包含了用户的公钥信息PIDi和身份信息IDi.(2)CA像传统PKI注册公钥一样验证用户信息,如果满足公钥PIDi是用户IDi的有效公钥,计算QIDi=H0(IDi,PIDi)∈G1,certIDi=sQIDi,并将证书certIDi发送给用户IDi,i∈{A,B}.签名:用户IDA对消息m签名,并指定验证者IDB.验证:用户IDB验证签名的有效性.副本模拟:用户IDB能够生成有效的副本.对于基于证书强指定验证者签名方案,如果签名者IDA正确地执行签名算法产生的签名δ,指定验证者IDB可以通过验证算法验证δ是有效的.Page5δ=H1(m,K1,K2)=H1(m,e(sIDBQIDA,Ppub+PIDA),e(PIDA,certIDB+sIDBQIDB)).5安全性分析定理1.假设敌手AI是CBSDVS方案的第一类适应性选择消息攻击敌手,在最多询问了qH1个H1询问、qs个签名询问、qV个验证询问之后,能够伪造成功的概率是ε.存在一个算法B可以利用AI以概率ε(1-1/(2l-qH1-qS))qV+1ε解决GBDH问题,其中l是CBSDVS方案的安全参数.证明.给定一个GBDH问题实例P,P1,P2,P3∈G1,其中P1=aP,P2=bP,P3=cP,a,b,c未知.我们构造算法B,B模拟挑战者与敌手AI交互,并在DBDH预言机的帮助下,计算e(P,P)abc∈G2的值.在证明过程中我们假设敌手AI不会重复两个相同请求.设置:输入安全参数l,输出系统参数{G1,G2,q,e,P}.方案中的两个目标用户为签名者IDA和指定验证者IDB.B令Ppub=P1=aP,PIDB=P2=bP,随机选择sIDA∈Zq,e,P,Ppub,sIDA,PIDA,PIDB}发送给敌手AI.密钥询问:B保存一个(IDi,sIDi,PIDi,ai)元组的列表L,这个列表初始化为{(IDA,sIDA,PIDA,0),(IDB,⊥,PIDB,0)}.敌手AI询问IDi,B随机选择sIDi∈Z入到L中,返回sIDi给敌手AI.替换公钥:敌手AI替换用户IDi的公钥为PIDi,其中PIDi=sIDiP(sIDi已知),将L中的(IDi,,,)替换为(IDi,sIDi,PIDi,1).H0询问:B保存一个(IDi,αIDi,QIDi)元组的列表H0,H0初始化为空.敌手AI询问IDi,B查询L.(1)如果IDi在L中不存在,B随机选择sIDi∈q,计算PIDi=sIDiP,将(IDi,sIDi,PIDi,0)加入到LZ中.随机选取αIDi∈ZαIDi,QIDi)加入H0中,返回QIDi给敌手AI.(2)如果IDi在L中已存在,(a)如果IDi≠IDA,随机选取αIDi∈Z(b)如果IDi=IDA,随机选取αIDi∈ZQIDi=αIDiP,将(IDi,αIDi,QIDi)加入H0中,返回QIDi给敌手AI;QIDi=αIDiP3=αIDicP,将(IDi,αIDi,QIDi)加入H0中,返回QIDi给敌手AI.证书询问:敌手AI询问用户IDi的证书,B查询L列表.(1)如果不存在,B随机选择sIDi∈ZPIDi=sIDiP,将(IDi,sIDi,PIDi,0)加入到L中.随机选取αIDi∈Z加入H0中.计算certIDi=αIDiPpub,并返回certIDi给敌手AI.αIDiPpub,返回certIDi给敌手AI;(2)如果存在,(a)如果IDi≠IDA,查询H0,计算certIDi=(b)否则IDi=IDA,拒绝敌手请求.H1询问:B保存了一个(mi,K1i,K2i,δi,Pi元组的H1,这个列表初始化为空.敌手AI询问元组(mi,K1i,K2i).(1)如果不存在元组(mi,,,,)在H1中,B随机选择δi∈G1,满足(,,,δi,)不在H1中,添加(mi,K1i,K2i,δi,⊥)到H1中,并返回δi给敌手AI.(2)如果存在元组(mi,,,,)在H1中,如果存在(mi,K1j,K2j,δj,⊥)形式的元组,则(mi,K1i,K2i)≠(mi,K1j,K2j),B随机选择δi∈G1,满足(,,,δi,)不在H1中,添加(mi,K1i,K2i,δi,⊥)到H1中,并返回δi给敌手AI;否则存在(mi,⊥,⊥,δj,Pj证K2i=?e(PjP2,P3,K1i/e(QIDA,sj判断是否是DBDH元组(Pj时对应的IDA的公钥的值).(a)如果不同时满足上述两个条件,B随机选择δi∈G1,满足(,,,δi,)不在H1中,添加(mi,K1i,K2i,δi,⊥)到H1中,并返回δi给敌手AI;(b)如果同时满足上述两个条件,B用(mi,K1i,K2i,δj,Pj组,并返回δj给敌手AI.签名询问:B模拟签名算法,在任意时间敌手AI可以询问签名算法.在接收到敌手请求IDA)之后,B检查H1.(mi,Pi(1)如果不存在元组(mi,,,,)在H1中,B随机选择δi∈G1,满足(,,,δi,)不在H1中,添加(mi,⊥,⊥,δi,Pi手AI.(2)否则存在元组(mi,,,,)在H1中.如果存在(mi,⊥,⊥,δj,PjPiIDA≠Pj不在H1中,添加(mi,⊥,⊥,δi,Pi回δi给敌手AI;否则存在(mi,K1j,K2j,δj,⊥)形式的元组,验Page6证K2j=?e(PiP2,Q3,K1j/e(QIDA,si机,判断是否是DBDH元组.(a)如果不同时满足上述两个条件,B随机选择δi∈G1,满足(,,,δi,)不在H1中,添加(mi,⊥,⊥,δi,Pi(b)如果满足上述两个条件,B用元组(mi,K1j,K2j,δj,Pi并返回δj给敌手AI.验证请求:B模拟验证算法,在任意时间敌手AI可以询问验证算法.在接收敌手AI请求(mi,δi,IDA)时,B查看H1.Pi(1)如果不存在(,,,δi,)在H1中,B拒绝(mi,δi),它是一个无效的签名.(2)否则,存在一个(,,,δi,)在H1中.(a)如果存在一个元组(mi,,,δi,Pi(b)如果存在一个元组(mi,K1i,K2iδi,⊥),B中,B接收它为一个有效的签名;K2=e(PIDA,certIDB+αIDBPIDB),K1=e(QIDA,sIDAPIDB)e(sIDBQIDA,Ppub)验证K2i=?e(PiP2,Q3,K1i/e(QIDA,si判断是否是DBDH元组,如果满足上述两个条件则接收它为一个有效的签名.否则拒绝它,认为它是一个无效的签名.注1.这个算法如果发生这种情况,(mi,δi)是个有效的签名,却没有在H1询问和签名询问中询问过,将失败.因为H1是一个一致性的描述,这种情况发生的可能性小于1/(2l-qH1-qS),则验证请求成功的概率为大于(1-1/(2l-qH1-qS))qV.伪造:假设敌手AI给出一个有效的指定验证者签名(m,δ,PIDA),满足:(a)m没有在签名询问中询问过;(b)IDB都没有在密钥询问中出现过;(c)IDA没有在证书询问中出现过.因为(m,δ)是一个有效的消息签名对,意味着以概率1-1/(2l-qH1-qS)存在一个(,,,δ,)元组在H1中.在定义的安全模型中,说明了m没有在签名询问中询问过,所以(,,,δ,)元组是在H1询问中得到的值.也就是说存在一个(m,K1,K2,δ,⊥)在H1中满足:计算(K1/e(QIDA,sIDAPIDB))-αIDA=e(P,P)abc,因为K1,QIDA,PIDB,sIDA,αIDA已知,所以B可以成功地解决GBDH问题.B成功的概率大于(1-1/(2l-qH1-qS))qV+1,因此能够成功解决GBDH问题的概率是ε(1-1/(2l-qH1-qS))qV+1ε.证毕.定理2.假设敌手AII是CBSDVS方案的第二类适应性选择消息攻击敌手,在最多询问了qH1个H1询问、qs个签名询问、qV个验证询问之后,伪造成功的概率是ε.则存在一个算法B可以利用AII以概率ε(1-1/(2l-qH1-qS))qV+1ε解决一个GBDH问题,这里面的l是CBSDVS方案的安全参数.证明.给定一个GBDH问题实例P,aP,bP,cP∈G1,我们构造算法B,B模拟挑战者与敌手AII交互,并在DBDH预言机的帮助下,计算e(P,P)abc∈G2的值.在证明过程中我们假设AII不会重复两个相同请求.设置:输入安全参数l,输出系统参数{G1,G2,q,e,P}.两个目标实体,签名者IDA和指定验证者IDB.B随机选择s∈ZaP,PIDB=bP,QIDA=cP,随机选取αIDB∈ZQIDB=αIDBP.将{G1,G2,q,e,P,Ppub,PIDA,PIDB}发送给敌手AII.密钥询问:B保存一个(IDi,sIDi,PIDi)元组的列表L,这个列表初始化为{(IDA,⊥,aP),(IDB,⊥,bP)}.敌手AII询问IDi,如果IDi∈{IDA,IDB},拒绝敌手请求.否则,B随机选择sIDi∈q,计算PIDi=sIDiP,将(IDi,sIDi,PIDi)加入到LZ中,返回sIDi.H1询问:B模拟Hash函数H1,在任意时间敌手AII可以询问这个随机预言H1.为了回答这些请求,B保存了一个(mi,K1i,δi,ci)元组的H1.这个列表初始化为空.敌手AII询问元组(mi,K1i),B将(P,QIDA,PIDA,PIDB,K1i/e(certIDA,PIDB))输入DBDH预言,判断它是否是DBDH元组.(1)如果(P,QIDA,PIDA,PIDB,K1i/e(certIDA,PIDB))是DBDH元组,(a)如果不存在元组(mi,,,)在H1中,B随机选择δi∈G1,满足(,,δi,)不在H1中,并设置ci=1,添加(mi,K1i,δi,1)到H1中,并返回δi给敌手AII;(b)如果有元组(mj,K1j,δj,)在H1中,则mi=mj,K1i≠K1j,B随机选择δi∈G1,满足(,,δi,)不在H1中,并设置ci=1,添加(mi,K1i,δi,1)到H1中,并返回δi给敌手AII;Page7(c)否则存在这样形式的一个元组(mi,⊥,δi,1),它只能在签名询问中产生并加入到H1中.用元组(mi,K1i,δi,1)替换H1中的元组(mi,⊥,δi,1),并返回δi给敌手AII.(2)如果(P,QIDA,PIDA,PIDB,K1i/e(certIDA,PIDB))不是DBDH元组,B设置ci=0,随机选择δi∈G1,满足(,,δi,)不在H1中,添加(mi,K1i,δi,0)到H1中,并返回δi给敌手AII.签名询问:B模拟签名算法,在任意时间敌手AII可以询问签名算法.在接收到敌手AII请求mi之后,B查询H1.(1)如果不存在元组(mi,,,)在H1中,B设置ci=1,并随机选择δi∈G1,满足(,,δi,)不在H1中,添加(mi,⊥,δi,1)到H1中,并返回δi给敌手AII.(2)否则存在元组(mi,,,)在H1中,则存在元组(mj,K1j,δj,cj)在H1中,满足mi=mj.(a)如果cj=1,意味着(P,QIDA,PIDA,PIDB,K1i/e(certIDA,PKIDB))是DBDH元组,返回δj给敌手AII;(b)如果cj=0,挑战者设置ci=1,并随机选择δi∈G1,满足(,,δi,)不在H1中,添加(mi,⊥,δi,1)到H1中,并返回δi给敌手AII.验证请求:B模拟验证算法,在任意时间敌手可以询问验证算法.B回答敌手AII请求.在接收敌手AII请求(mi,δi),B查看H1.(1)如果不存在(,,δi,)在H1中,B拒绝(mi,δi),它是一个无效的签名.(2)否则,存在一个(,,δi,)在H1中,(a)存在一个元组(mi,⊥,δi,1)或者(mi,K1i,δi,1)在H1中,B接受它为一个有效的签名;(b)否则,B拒绝它,认为它是一个无效的签名.表1计算代价、通信代价及相关性质分析文献[4]方案BP+E+3M+H+I2BP+E+M+H|G1|+2|Zq|文献[5]方案2BP+E+2M+HBP+E+M+H2|G2|文献[6]方案3BP+4M+3H2|G1|文献[7]方案BP+M+H+I3BP+M+H|Zq|文献[8]方案BP+M+H|Zq|文献[9]方案BP+4M+H文献[10]方案4M+H+I2BP+E+M+H2|G1|本文方案2BP+2M+1H2BP+2M+1H|G1|由表1分析可知,本文方案的计算代价与文献[6-7]相当,略低于文献[4-5,8-10].但是与其它BP+2M+H|G1|+|G2|注2.这个算法如果发生这种情况,(mi,δi)是个有效的签名,却没有在H1询问和签名询问中询问过,将失败.因为H1是一个一致性的描述,这种情况发生的可能性小于1/(2l-qH1-qS),则验证请求成功的概率大于(1-1/(2l-qH1-qS))qV.伪造:假设敌手给出一个有效的指定验证者签名(m,δ).满足:(a)m没有在签名询问中询问过;(b)IDA,IDB都没有在密钥询问中出现过.因为(m,δ)是一个有效的消息签名对,意味着以概率1-1/(2l-qH1-qS)存在一个(,,δ,)元组在H1中.在定义的安全模型中,说明了m没有在签名询问中询问过,所以(,,δ,)元组是在H1询问中得到的值.也就是说存在一个(m,K1,δ,1)在H1中满足K1=e(sIDBQIDA,Ppub+PIDA)=e(certIDA,PIDB)e(QIDA,P)sIDAsIDB,即K1/e(certIDA,PIDB)=e(QIDA,P)sIDAsIDB=e(P,P)abc,因为K1,certIDA,PIDB已知,所以B可以成功地解决GBDH问题.B成功的概率大于(1-1/(2l-qH1-qS))qV+1,因此能够成功解决GBDH问题的概率是ε(1-1/(2l-qH1-qS))qV+1ε.6计算代价与通信代价分析下面我们将分析本文的计算代价与通信代价,并定义表1中需要用到的标识符.|G1|:G1中元素的长度;|Zq|:Zq中元素的长度;BP(bilinearpairingoperation):双线性对操作;M:G1中的模乘操作;E(exponentiationinG2):G2中的指数操作;I:取逆操作;H(hashfunctionoperation):Hash操作,假设在群G1上的加法操作为可忽略.本文方案与其它相关方案的性能及优缺点比较结果如表1所示.签名长度强指定验证者签名密钥托管安全信道方案相比,本文方案也具有明显的优点:(1)签名长度最短(仅为群G1中的一个群元素);(2)满足强指Page8定验证者签名的性质;(3)不使用安全信道;(4)较好地解决了基于身份指定验证者签名方案中的密钥托管问题.7结束语指定验证者签名由于其具有的特殊性质,已经被广泛地应用在生活的各个领域.本文首先提出了基于证书强指定验证者签名的概念和安全模型,然后构造了基于证书强指定验证者签名方案.基于GBDH假设,在随机预言模型下证明了方案对适应性选择消息攻击是存在不可伪造的.提出的方案能够抵抗密钥替换攻击问题并且较好地解决了基于身份指定验证者签名中的密钥托管问题.我们分析了方案的通信代价和计算代价,方案的签名长度仅为群G1中的一个群元素,是目前签名长度最短的基于证书签名方案之一,非常适合通信受限的网络环境中.方案的计算代价略高,为4个双线性对操作,下一步将把减少计算代价作为研究工作的重点.致谢匿名审稿专家对本文进行了仔细审阅并提出了宝贵的修改意见,作者在此表示衷心感谢!
