Page1基于GINI指数分类的嵌入式CPU功耗预测方法王海高岭宋振孝戴小平卢怡杰(西北大学信息科学与技术学院西安710069)摘要文中提出了一种基于嵌入式系统CPU功耗预测并对其进行低功耗优化的方法.引入GINI指数的构建训练分类器,利用PowerTop工具对系统CPU进行监测,并以此作为训练数据集,将该分类器封装到系统中,对嵌入式系统的CPU频率、电压及所处的状态进行预测.通过仿真实验表明,该方法在系统负载较小的情况下,对嵌入式CPU功耗的优化的效果更好.关键词GINI指数;功耗预测;机器学习;CPU功耗;移动互联网1引言近年来,互联网已扩展到以智能手机作为代表性接入设备的移动时代.根据2013年2月14日全球技术研究和咨询公司据分析机构Gartner发布的新闻公告显示,虽然2012年全球手机销量为17.5亿部,比2011年下降1.7%,但2012年智能手机的销量创记录的达到2.07亿,比上年同期增长38.3%,预计2013年智能设备(智能手机及平板电脑)的销量将会突破十亿大关.其次,伴随智能终端数量的快速增长,移动应用的深度与广度也得到进一步的发展,并几乎涵盖了传统网络应用的所有层面.现在的问题是移动应用增加了,移动终端的功能增加了,但移动终端的供电能力却没有同比例的先行增长,特别是在保证移动重点性能的前提下如何来降低功耗的问题没有得到有效的解决.因此要使得移动应用进一步深入普及,迫切需要解决“性能-功耗”优化问Page2题,以有效延长移动设备的待机时间及有效工作时间.如何更好的控制嵌入式软件功耗成为当今技术发展的一大热点问题.高功耗的嵌入式设备不仅会降低设备性能指标,还会增加系统的不稳定性,电池温度每上升10,系统失效率将提高1倍[1].降低嵌入式设备功耗研究包括硬件低功耗设计和软件低功耗设计.嵌入式系统的重要特点之一就是工作负载的不均匀性以及动态变化性,可以通过动态关闭设备或者动态调节处理器的工作电压来取得系统性能和功耗之间的平衡.而且由于系统支持ACPI[高级配置和电源管理接口],易于将低功耗设计策略嵌入到系统内核中.鉴于以上原因,本文提出了一种基于GINI指数分类方法,将学习到的分类器作为预测模块,插入到已有的系统对CPU所处状态进行预测.以达到最大化的降低系统的功耗,提高其性能的目的.2相关工作目前大量的优化方法集中在硬件级[1-4]、编译级[5]、系统级[6]等方面,还没有从根本上实现降低功耗的预期目标.在对嵌入式系统功耗的研究中,基于不同的设计目标提出了很多的方法,例如文献[7]提出了基于CSP的构件化嵌入式软件能耗分析与评估研究方法,文献[8]提出了基于模拟器的嵌入式操作系统能耗估算与分析.文献[9]提出的基于并行度分析模型的GPU功耗优化技术,这些多数都是从指令级角度及硬件方面考虑的[10-13].但是从对系统CPU所处的状态进行功耗优化来考虑,这些方法都有其一定的使用局限性[14].3基于GINI指数的分类预测方法分类是机器学习和数据挖掘的一种重要方法.分类是通过对已有标记数据集的学习,构建具有一定泛化能力的分类器,分类器能把未知数据映射到分类器可区分的给定类别.已有的分类方法有:决策树、贝叶斯网络、遗传算法、粗糙集、k-最临近法等等[15].在已有分类方法中,决策树方法具有计算量小、易于理解、同时适应处理连续和离散数据,能够明确的给出最具区分能力的属性等优点,受到重视和被广泛的应用[16].本文提出的基于GINI指数的分类预测方法正是决策树的一种.3.1决策树算法决策树方法通过对实例进行归纳学习,从无次序、无规则的实例集合构建起一个使用树型结构来表示的分类器.构建决策树的分成两个阶段:决策树生成与决策树修剪.因为决策树创建相对复杂程度更高,因此我们讨论重点落在树的创建上.决策树的建立是一个递归的过程,构造树的通用过程如下:(1)从训练样本中选取有代表性的单个结点,开始构造树.(2)如果所有样本都属于该结点类.则用该结点的类标号标记此树,称该结点为叶子结点.(3)否则以信息熵的信息增益作为度量,选择分类能力最大的结点属性作为决策树的当前结点.(4)针对每一个训练属性的值构建一个分支,并据此分支值对样本进行划分.(5)算法递归形成各个划分上的判定树.如果某个样本已经出现在一个构造过的节点上,则该节点所有后代都不再进行考虑.算法终止条件:①样本的所有给定结点都属于同一类.②可以进一步划分样本的属性已经不存在.出现这种情况后,就会使用一种称为多数表决的方法,将剩余的样本结点转换成树叶,以样本中元组个数所属类别最多的那个类别作为标记.GINI指数等.类创建一个树叶.③如果某一分枝没有样本,则以样本中的多数属性选择度量有信息增益(informationgain)、在树的构建过程中,有两个关键问题:(1)分割点选取;(2)如何分割数据.决策树算法在对数据进行分类的时候,选取哪个属性作为分割点是一个重要的问题.可以用来作为判定分割属性的方法有诸如ID3,C4.5算法中根据信息熵原理总结的信息增益与信息增益率,CART、SLIQ以及SPRINT算法中的GINI指数等.虽然ID3与C4.5算法在对训练样本集的学习中能够挖掘尽可能多的信息,但是由于利用了信息熵的原理,因而其生成的决策树分支较多,规模较大,算法的可伸缩性与并行性较差.而使用GINI指Page3数来作为判定分割点的标准,则简化了生成决策树的规模,提高了决策树生成的效率.并且在算法的可伸缩性与并行性方面的性能也有较大提高.因此本文利用GINI指数来判定分割点,降低了计算任务的复杂性,从而达到减少在计算方面的开销的目的.3.2基于GINI指数的分类方法分裂指数是用来度量属性分裂规则优劣程度的一个量度,即我们用来判定选择哪一个属性作为创建决策树的分割点的依据.基尼指数(GINICoeffi-cient)是意大利经济学家基尼(CorradoGini,1884~1965)于1912年提出的用于定量度量的确收入差异程度的指标.当我们在选择分割属性的时候遇到离散型属性,首先将其属性分组,然后根据各属性的取值将其排序,以方便计算.如果我们在选择分割属性的时候遇到连续型属性,首先对该连续型属性的值进行排序,得到一组有序的数据集,然后对该数据集使用一个称为游标的标尺来标记,将其分为两个部分,这样就相当于将其离散化成两个值.分别计算这两部分数据的GINI指数,然后将游标向后移动一位,继续对数据进行划分,再分别计算这两部分数据的GINI指数,直到将数据划分完毕,对所计算的GINI指数进行比较,选择最小的那个作为这组数据的分裂指标[17].计算具体GINI指数的方法如下:关的类,则设数据集S有n条记录,分别属于c个互不相其中Pj=m/n,m为S中属于类j的记录个数.如果集合S划分为两个子集S1,S2,分别对应n1,n2条记录,那么这个分割的GINI指数就是Ginisplit(S)=n1nGini(S1)+n2nGini(S2).若这个值越小,则这个分裂规则越好.例如,现在有n个连续型属性,首先将此n个属性进行排序,对于排序完成的数据集,我们用一个称为游标的标尺来对数据进行划分.这个游标主要是用来对我们所要处理的数据进行标识.当我们进行数据处理时,移动游标,分别将数据划分为游标左端与右端两部分(Cbelow-Cabove),即1-(n-1),2-(n-2),3-(n-3)…(n-2)-2,(n-1)-1,并且这些数据都是按照从大到小的顺序排列的.分别根Cbelow与Cabove作为分割标准[18].据不同的Cbelow与Cabove,计算出:Ginisplit(S1)=Gini(S1(1))+Gini(S1(n-1)),Ginisplit(S2)=Gini(S2(2))+Gini(S2(n-2))…Ginisplit(Sn-1)=Gini(Sn-1(n-1))+Gini(Sn-1(1)).选择这些Ginisplit中的最小值,并以最小值的基于GINI指数的分类方法通过划分连续型属性值,将其离散化为两个值,大大简化了计算复杂度,提高了效率,是一种简单有效的方法,且其效果经过证明也是非常理想的.4Linux内核中CPU的工作状态基于Linux的嵌入式系统中,CPU的工作功耗是整个系统中至关紧要的部分,如何降低CPU的工作功耗,关系到整个系统节能工作的成败.对于处理器功耗的控制的一种手段就是降低CPU的工作频率以及使处理器长期处在无任务调度的睡眠状态下.在Linux系统中通过ACPI可以实现对处理器的各种工作状态的控制,并且通过CPUfreq子系统可以实现对处理器动态频率的控制.4.1ACPI中处理器的状态ACPI即AdvancedConfigurationandPowerManagementInterface,高级配置电源管理接口[19].1997年由Intel、Microsoft、Toshiba所共同制定提供操作系统应用程序管理所有电源管理接口.在处理器电源管理中,它定义了处理器的4个状态:C0、C1、C2、C3,当处理器处于C1、C2、C3态时,比C0态能耗低,散热也低,处理器处于睡眠态,不执行指令,也就是所谓的低功耗工作状态.(1)C0态这是处理器正常工作状态,可以执行指令,也是正常能耗状态.(2)C1态通过“HLT”指令进入,所有处理器都支持此状态.从C1到C0的唤醒时间最短,任何CPU唤醒事件,例如处理器产生中断,必须返回C0态.(3)C2态处理器时钟和I/O缓冲停止,它比C1态能耗低.可通过P-LV3寄存器进入此状态.从C2态进入C0态需要至少100ns.在此状态时,任何CPU唤醒事件,也都需要返回C0态.Page4(4)C3态与C2态类似,总线和PLL均锁定,内存关闭,保持CACHE,因此能耗比较低,但C2态大,唤醒需一定时间.在此状态时,任何CPU唤醒事件,也都返回C0状态.CPU的睡眠程度越深,能耗越低,因此为了节能需要尽可能让CPU更多处于C1、C2、C3等状态.由于任务的不确定性导致CPU在此4种状态间频频切换,会产生大量因切换而带来的能耗开销.对这些开销进行控制,可以更好的控制CPU的功耗.处理器的电源状态如图1所示.4.2CPUfreq子系统2.6.10Linux以上所支持的CPUfreq子系统可以动态地调节处理器的频率.可以用CPUfreq子系统和内核调控器来修改处理器的频率,改善系统的效率.当处理器以较低的时钟速度运行时,它们消耗的电能和产生的热量也相对较少.CPUfreq结构利用调控器来为系统设置静态或动态电源策略.动态调控器可以根据CPU利用率来调整CPU频率,从而有助于节省电能,且不会牺牲性能.图2显示了CPU频率,电压和功耗之间的关系.所谓的CPU性能状态(P-state),是与CPU频率和电压相关的运转状态.C-state对应相应的处理器工作状态,CPU在不同状态之间进行切换的时候也会产生额外的功耗,如果CPU在进入一个休眠状态后需要立即唤醒,那么由此产生的功耗比处于休眠状态节省的功耗还要多,因此便达不到节省系统功耗的目的.如何让CPU更多的处于低电压低频率的工作状态并且又不影响系统的整体性能即避免产生额外的功耗便是整个问题的关键.这里我们提出了基于GINI指数的分类预测方法,对系统任务进行分类预测,从而使CPU更多的处于低电压低频率的工作状态,达到降低系统功耗的目的.5能耗预测模块的构造建立能耗预测模块的过程可以分为3个阶段:(1)通过系统监测获取训练数据集;(2)使用基于GINI指数的分类方法通过训练集生成分类器;本文通过PowerTop记录系统运行的各种参数(3)能耗预测.5.1训练数据采集以得到能耗预测模块所需的训练数据.5.2分类器训练传统的动态电压调节算法都是按一定周期去检测CPU使用率,以此为根据动态调节CPU电压及频率进行“性能-功耗”优化.动态调节CPU电压和频率一般分为两类:任务外(intra-task)方式和任务内(inter-task)方式.这里主要介绍任务内(inter-task)方式.根据依据的信息不同,任务内(inter-task)方式可分为3类:(1)基于任务最后期限作为CPU调节的依据,根据最坏情况下任务需要的时间,计算下一个时间段的大小.由于难以获得任务的最后期限信息,因此此方法可行性不高.(2)实时检测任务执行过程,例如创建、删除、切换及系统调用等,据此作为调节CPU的依据.检测任务的这些特征信息会带来额外的消耗,大约占1%~4%.(3)按一定周期监测CPU使用率,通过对下一个时间段CPU使用率进行预测来调节CPU.这种方式实用性强,且实现简单.在本文中,我们从另一个角度去考虑,每个任务Page5在执行的时候不是一直在占用CPU,而是会不断唤醒CPU,因为任务在执行的时候需要准备数据并做出相应的处理,然后当这些处理完毕的时候,才会去中断CPU的休眠状态,让CPU执行.然后再做相应的准备工作,反复占用CPU运行,直到运行完毕.首先,根据所获取信息,判断一个任务是属于CPU密集型任务(C)还是I/O密集型任务(IO),不同类型的任务需要不同的运行策略,非CPU密集型任务可以暂时不去唤醒CPU,而是等待合适的时间再去唤醒CPU,这样可以让CPU在更多的时间内处于低电压低功耗的休眠的状态,然后根据任务单位时间内唤醒CPU的次数,计算其处于C0状态(运行态)以及C1,C2,C3等状态(低功耗态)的比例,并根据其不同的比例把任务分成高功耗任务与低功耗任务.对于高功耗任务,我们让其更多的时间处于CPU较高频率与电压状态,即尽快执行完毕.对于低功耗任务,我们则根据系统情况,让其更多的处于低电压低频率状态,从而达到降低系统功耗的目的.根据所获得的历史数据,更新所有进程在已执行时间内的CPU使用率,设Q为最小时间段长度,每隔Q的时间后产生一个时钟中断.进程i的CPU使用率为ei/I,其中ei为该进程的执行时间,I为计时器的间隔时间长度.进程的执行时间需要根据系统最佳性能进行标准化.例如,假定CPU频率最大值为600MHz,某个进程在CPU频率为300MHz时执行了10ms,标准化后其执行时间为5ms.通过正在进行的优先级及时间片预测下一阶段将要运行的进程,算法进一步预测下一个周期CPU可以使用的频率,并根据系统所获取的数据,预测最佳的系统模式,这样做既保证进程的执行,又节约系统功耗.5.3预测算法能耗预测算法过程如下:(1)首先分析任务运行中的参数值,包括任务类型、需唤醒CPU次数等;(2)根据分析得到的数值,使用分类器对任务所属类型进行分类;(3)根据(2)中分类结果,判断任务执行时合适的唤醒CPU时间以及预测下个任务执行时CPU所处的最佳状态,将结果返回给用户.预测过程的算法如下.算法1.预测过程算法.输入:将在CPU中运行的任务样本X输出:任务类别S//输入为系统将要运行的任务样本X//输出为x的预测判断结果//S为判断任务运行中处理器所处的状态,分为S0、S1、S2、S3(S0中处理器80%的时间处于C0状态,并将处理器电压频率调至最高,其他时间处于C1等低功耗状态.S1中处理器60%的时间处于C0状态,并将处理器电压频率调至比在C0状态时低一些,S2中处理器40%的时间处于C0状态,并将处理器电压频率调至比在C1状态时低一些,S3中处理器20%的时间处于C0状态,并将处理器电压频率调至最低)的类别的建议;1.S=0;2.从数据库表中取出任务X的数据;3.根据获得的任务X的运行状态参数,按照已训练好的分类器预测其运行中需唤醒CPU的次数,与外设的交互时间以及在处理器中的运行时间;4.根据预测的结果给出任务X运行时CPU的状态,S5.将预测的结果返回给系统;6.结束;7.返回最终的结果.算法在判断每个任务所属的类型及其在运行过程中所需要唤醒的等CPU的次数以及由此引起的CPU的状态的变化方面具有简单、有效且差错率小的特点.最终结果反馈给用户即系统,使系统确定其CPU可以处于哪一个低功耗的工作状态且不牺牲其性能,从而达到降低系统功耗的目的.5.4自动更新能耗预测模块持续记录数据,定期重新生成分类器.通过保持训练数据的时效性来确保预测的准确.6仿真实验分析为了展示我们在系统电源管理上的优化效果,在这里通过模拟单一任务在单处理器中按照分类策略预测算法与无分类策略预测算法运行的情况,并进一步对两种运行方式的结果进行对比分析,可以发现我们提出的分类预测方法在系统能耗的节省方面达到了预期效果.6.1实验准备本实验使用MatLab进行系统能耗仿真,使用WEKA分析仿真数据,仿真系统在单核情况下运行单任务.假设没有任何能耗优化策略情况下系统的能耗为1,即作为比较的基准.通过系统仿真,观察Page6并记录系统在没有应用任何策略的情况下的运行情况,然后再观察并记录在应用了分类策略的情况下的系统运行情况,最后将运行结果进行汇总为对比分析做准备.6.2实验数据分析获取训练数据与分类器训练的主要任务就是确定要研究的任务类型及其在系统运行中的能耗情况.根据前面所提出的算法的需要,需要模拟程序运行过程中使处理器处于工作的时间,与外设进行数据交互的时间、唤醒CPU的次数.根据最后模拟的运行结果判断任务运行过程中处理器所应处的工作模式类型.根据对已有研究成果的学习,系统任务的运行情况是一个随机的过程,对任务运行时具体的实验数据的提取存在一定的困难,因此在这里对数据需要进行一定的假设.利用PowerTop对系统运行的情况进行监控,可以发现任务在运行的过程中,前面提到的3个指标大体上服从一种平均分布,我们假设要模拟的实验数据服从平均分布情况,对其数据在一定范围内进行限制设置.在仿真实验中,实验条件设置如下:(1)任务在处理器中的运行时间(T1)限制为(2)任务与外设的交互时间(T2)限制为1~200,(3)任务唤醒CPU的次数(R1)限制为1~50,1~100,单位为毫秒(ms).单位为毫秒(ms).单位为次/毫秒(次/ms).6.3实验结果与分析用MatLab随机生成两千组数据作为我们模拟的任务,每组数据包含3个数,分别代表处理器运行时间、与外设交互时间以及唤醒CPU次数,在这里我们不考虑其他因素对任务实际运行中的能耗影响.为了得到最终需要的分类结果,在这里我们为T1,T2,R1分别赋予一个影响因子,考虑到对系统能耗的影响不同,分别赋予的因子为0.8,0.2,0.05,结合影响因子计算出每个任务产生的系统能耗.表1给出了模拟的任务数据,最后一项系统功耗是结合影响因子及处理器工作时处于不同的电压频率计算得出.通过表1的数据我们可以看到,当任务在处理器中运行的时间接近,而与外设的交互时间不一样时,例如任务1与任务2,他们与外设的交互时间相差很大,但是最终消耗的系统能耗确相差不大,再看任务1与任务1998,它们在运行过程中与外设交互的时间相差无几,但是在处理器中的运行时间相差很多,最终消耗的系统能耗相差了3倍之多,这说明与外设交互时消耗的能耗占整个任务运行期间消耗的系统能耗比例很低,唤醒CPU产生的系统功耗也只占总的系统能耗的一小部分,大部分的能耗由任务在处理器中运行时产生.图3反应了任务在没有应用任何运行策略时所产生的系统能耗的曲线图.在这里为了绘图的方便,我们选取前100个任务作为样本,使大家可以清晰的看到运行效果.任务号处理器运行123456199819992000接下来使用WEKA来分类数据达到模拟分类器的效果,首先将数据按类别排序分别计算其GINI指数,计算方法按照前面提出的算法进行.按照计算所得的GINI指数对任务进行分类,对于高功耗的任务,使其处于分类结果中的S0,然后依次按照计算得出的功耗数值分为S1,S2,S3,将数据代入WEKA中,分类效果及分类树情况分别如图4与图5所示.通过实验可以看到,我们所提出的分类算法在类型分类的正确率上达到了96%,为接下来的系统预测算法提供了有效性的保证.为了验证所提出的算法的节能效果,在这里我们将前面所选取的100个任务样本在应用分类算法之后重新进行运行分析,结果如图6所示.Page7图4WEKA数据分类效果图5WEKA分类树结果图6前100个样本的应用分类策略的运行效果从图6可以看出,应用了分类策略之后,相对于系统运行在没有应用任何策略时,系统首先会将功耗较低的任务按照优先级尽量放在最前面执行,以使系统可以在不影响性能的前提前尽量减少系统功耗,而把高功耗的任务集中到一起,使系统在性能最优且尽量可以完成任务的前提下减少系统功耗.对图6进行具体分析,系统开始的时候会利用模拟的分类器,首先根据获取的运行信息对的系统接下来将要运行的任务进行分类,判断其所属功耗类型,然后将其提交给系统并对系统的运行状态给出建议.系统按照预测算法给出的预测结果建议进行运行,首先让更多的在分类的时候被划归于S3状态的任务先执行,在图中表现为一开始的系统处于消耗较低能耗的状态运行,此时CPU的电压频率会维持在一个较低的水平,因为此时运行的任务对系统的性能要求不高,所以总体上看并没有降低系统性能.接下来对于能耗比较大的任务,系统会逐步提高其CPU的电压频率以满足任务的需求,并在此基础上尽可能的将系统的运行结束时间提前,从而达到功耗优化的目的.与没有应用任何策略的运行结果相比较,应用分类策略运行时节省的系统能耗达到了32.61%.这在很大程度了减少了系统的能耗,达到了系统功耗的优化效果.为了让大家有一个直观的观察效果,在这里我们将两者运行结果合并到一起,如图7,从图中可以更加直观的看到我们所提出的算法的节能效果.虽然算法在执行计算的时候会相对增加约2%的系统消耗,Page8但是与取得的节能效果相比,增加的开销可以忽略.为了进一步验证算法的有效性,我们从所模拟的实验数据中取出8组,每组100个,分别进行无任何策略的运行,加入分类算法策略的运行,将最终的结果进行对比分析,更加说明了算法的有效性.图8~图15展示了我们所进行的8次模拟实验结果,从图中可以很直观地看到系统的节能效果.对于8组实验的模拟结果,将在无策略运行下的能耗与在分类策略运行下的能耗进行统计分析,如表2所示.通过计算对比,8组实验的系统功耗平均降低了30.71%,基于这样一个实验事实,可以得到这样的结论:我们所提出的算法在系统功耗的优化方面确实取得了预期效果.Page9实验组号12345678在这里我们还应该考虑到一个系统运行时间的问题,相比较于没有应用分类策略的系统运行时间,应用了分类策略之后,系统在运行时间上会有一定的增加,这是由于对系统的运行状态进行调整之后,有些任务在运行的过程中,处理器的状态会被调整到一个较低的电压及频率上,那么运行时间不可避免的要出现增加,图16显示模拟的20组实验中无分类策略运行与有分类策略运行时系统的能耗情况.从图中我们可以看到,与没有运行任何策略的情况相比,应用了GINI指数分类策略之后,系统在能耗方面有了显著的降低了.实验的结果与理论计算的结果基本吻合,从实验模拟与理论计算两个方面都验证了结果的有效性.虽然有时候在某些任务的运行中出现了系统能耗的增加,但是相对于系统整个运行过程中节省的能耗,增加的能耗完全在可以接受的范围.7结论本文将机器学习的理论应用于嵌入式CPU能耗的预测,提出的基于GINI指数分类策略的功耗优化预测方法,可以更好的对系统状态进行预测,对于降低系统功耗有明显的效果.我们下一步的工作包括:进一步细化完善能耗的分析与评估的方法体系开发嵌入式系统的软件建模与验证的原型工具,并将继续加强对预测算法的优化,进一步探索更好的分类模型.致谢匿名审稿专家对本文提出了宝贵修改意见,在此表示由衷的感谢!Page10
