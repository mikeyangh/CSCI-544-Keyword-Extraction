Page1XML的结构完整性约束推理张剑妹1),2)陶世群2)梁吉业2)曹峰2)1)(长治学院计算机系山西长治046011)2)(山西大学计算机与信息技术学院太原030006)摘要为了有效地优化XML路径表达式查询,给出了一个XML结构完整性约束体系,这个体系全面描述了XML文档中节点或路径之间的结构关系,包括必需性包含、排他性包含、路径蕴涵、路径互斥和路径同现.在此基础上研究了XML结构完整性约束的逻辑蕴涵和一致性问题.文章首先采用约束重写技术将各种约束改写为路径蕴涵约束;然后给出了一组路径蕴涵的推理规则;最后以路径蕴涵闭包为工具证明了推理规则的完备性并给出了XML结构完整性约束的一致性判断方法.关键词XML结构完整性约束;逻辑蕴涵;一致性;推理规则;路径蕴涵闭包1引言随着Web上大量XML数据的出现,如何高效地管理和查询XML数据成为亟待解决的问题.为Page2作为XML文档的主要模式规范,DTD(DocumentTypeDefinition)[6]和XMLSchema[7]虽然定义了XML文档中允许出现的元素类型、属性及其顺序和结构嵌套关系,但是不能处理元素或路径之间复杂的结构关系,例如:在一个文档中,从一个节点出发的路径要求(或排斥)另一个路径.如果有一种机制能说明XML元素或路径之间的这种结构关系,那么,在XML查询编译时,便可以有效地识别:(1)路径表达式中的冗余条件;(2)路径表达式中不相容的条件;(3)路径表达式中的冗余步;从而删除冗余条件,减少冗余步,以最小化路径表达式,改善XML查询的性能.为此,我们引入了XML结构完整性约束的概念,并研究了它的逻辑蕴涵和一致性问题.目前,对XML结构完整性约束的研究还比较少,文献[8-9]等研究了半结构化数据中节点的边约束,这些研究可以说是最早的结构完整性约束的研究.文献[10]提出了使用DTD中隐含的结构完整性约束进行XPath路径表达式查询优化的方法.文献[11]研究了XML文档中路径蕴涵、路径互斥和路径同现三种结构约束及其逻辑蕴涵和一致性问题,但其定义是使用仅包含父-子关系的简单路径表达式给出的.文献[12]研究的XML树模式约束是使用包含“/”、“//”、“[]”和“”的XPath路径表达式子集对文献[11]中的结构约束的扩展,而在实际应用中这种树模式约束又显得过于复杂.文献[13]研究了DTD中隐含的元素之间的排他性包含和必需性包含关系,但其目的是为了PAT代数表达式的等价转换和充分利用结构索引,因此,排他性包含的概念与本文的排他性包含有着本质的区别.本文研究了包含路径蕴涵、路径互斥、路径同现、元素之间的排他性包含和必需性包含5种结构关系的XSICs的逻辑蕴涵和一致性问题.与文献[11-12]的结构约束不同,为了既能满足路径表达式查询最小化的需要又便于推理证明,XSICs中的路径蕴涵和路径互斥是使用包含“/”和“//”的线性路径表达式定义的.由于“//”的不确定性,线性路径表达式之间的包含关系要远远复杂于简单路径之间的包含关系,但又不同于文献[12]中的树模式之间的包含关系,而这种包含关系的确定恰恰是推理的关键所在.如何有效地描述线性路径表达式之间的包含关系是我们必须解决的一个重要问题.此外,我们引入了元素必需性包含和排他性包含两种结构包含关系.元素之间的结构包含关系与路径之间的结构关系以一种复杂的方式相互作用着,为了对XSICs进行有效的逻辑推理,必须将这两类结构关系有机地结合起来.如何将这两类结构关系结合起来是我们面临的又一个重要问题.毋庸置疑,约束类型和约束定义的不同将导致推理规则及其相关证明的巨大差异,从而直接影响着XSICs一致性问题的解决方法.文章第2节介绍一些背景知识,并提出了子路径的概念;第3节给出XSICs中5种结构关系的语法和语义定义,并详细阐述对这几种结构关系进行约束重写的技术;第4节给出一组推理规则和路径蕴涵闭包的概念及其计算方法,并证明这组推理规则的正确性和完备性;第5节讨论XSIC的一致性问题;第6节总结全文并指出未来的研究方向.2背景知识2.1XML文档树XML文档通常可以表示为节点标签的树,树中每个节点与文档的一个元素、属性或值(文本)相对应,边表示节点之间的嵌套关系.这里假定有3个两两不相交的集合:E是元素类型的有限集;A是属性名的有限集,单元素集{S}表示文本.XML文档树的形式化定义[2]如下.定义1.一个XML文档树T被定义为一个六元组T=(V,lab,ele,att,val,r),其中:V是节点的有限集;lab是一个从V到E∪A∪{S}的映射.每个v∈V,如果lab(v)∈E,则v是一个元素;如果lab(v)∈A,则v是一个属性;如果lab(v)=S,则v是一个文本节点;ele和att都是从V到V的部分映射.每个v∈V,如果lab(v)∈E,则ele(v)是V中的一个元素和文本节点序列,att(v)是V中的一个属性集;每个v∈ele(v)或v∈att(v),v叫作v的孩子节点且从v到v有一个边;val是一个从V到字符串的部分映射.每个v∈V,如果lab(v)∈A或lab(v)=S,则val(v)是v的一个字符串值;r是文档树中唯一的一个根节点(即文档节点)且r∈V.图1给出了一个关于论文出版数据的XML文档树.为了表示简单,图中忽略了文本节点和根节点.本文对属性和元素采用相同的处理方法,因此不严格区分属性和元素,即下文的节点类型泛指元素类型或属性名.Page3图1XML文档树示例2.2路径表达式及相关符号在XML文档树上,由节点序列构成的路径唯一确定一个节点,这样的路径叫作文档路径;路径表达式决定XML文档中的路径形式,它定义了一种导航XML文档的查询并返回指定路径所能访问到的节点集的方法.一个路径表达式对应于若干条文档路径,也就是说,从一个起始节点开始,路径表达式将返回一个节点集合.除非特别指明,下文中提到的路径均指路径表达式.本文的路径表达式是不包含通配符“”的XPath表达式,其语法定义如下:P∷=e|.|/P|//P|P/P|P//P|P[P],e∈E∪A,其中,“.”表示当前上下文节点;“/”和“//”分别表示节点类型之间的直接包含关系(父-子关系)和间接包含关系(祖先-后代关系);“[]”中的路径表达式是谓词.以“/”开始的路径表达式是绝对路径,它从文档的根节点开始定位路径;其它路径表达式为相对路径.定义2.线性路径表达式的形式为P=c1e1c2e2…cnen,其中,ei∈E(i=1,2,…,n-1),en∈E∪A,ci∈{/,//}(i=1,2,…,n);特别地,当ci=“/”(i=1,2,…,n)时,P叫作简单路径表达式.定义3.设线性路径表达式P=c1e1c2e2…cnen,Q=c1e1c2e2…cmem,若mn,ci=ci且ei=ei(i=1,2,…,m),则Q是P的路径前缀;当m=n时,称P等于Q,记为P=Q.任何路径P都是其自身的路径前缀.线性路径表达式P中节点类型的个数是P的长度,记为|P|.下文用P∈LP表示P是一个线性路径表达式.类似于文档树,路径表达式也可以表示为树形结构,这种树形结构被叫作树模式.图2给出了路径表达式/papers/paper[.//section][.//section//para-graph]/title的树模式.路径表达式中的每个节点类型与树模式中的一个节点相对应,其中实心节点为表达式的返回节点.单线边(叫作孩子边)和双线边(叫作后代边)分别与表达式中的“/”和“//”相对应.若(u,v)是孩子边,则节点v被叫作节点u的孩子节点;若从u到v有一个边序列,则节点v被叫作节点u的后代节点.为了区分绝对路径和相对路径,在树模式中引入了一个根节点#.和文档树一样,lab(v)表示树模式中节点v的标签.2.3子路径定义4.P,Q∈LP,Np和Nq分别表示P和Q的树模式的节点集,Q是P的子路径,当且仅当存在一个映射f:Nq→Np满足如下条件:(1)保持节点类型,即v∈Nq,若lab(v)=e,则lab(f(v))=e;(2)保持边关系,即u,v∈Nq,若(u,v)是孩子边,则在P的树模式中,f(v)是f(u)的孩子节点;若(u,v)是后代边,则在P的树模式中,f(v)是f(u)的后代节点.根据子路径的定义,线性路径表达式“//paper//section”是“//paper/sections/section//paragraph”的子路径,但“/paper//section”不是“//paper/sections/section//paragraph”的子路径.显然,任何路径表达式P和其路径前缀都是该路径表达式的子路径,本文使用Subpaths(P)表示路径表达式P的子路径集.3XSICs的定义描述元素或路径之间结构关系的完整性约束叫作XML文档的结构完整性约束(简称XSICs).Page4XSICs描述元素或路径之间的蕴涵、互斥、同现以及元素之间的结构包含关系.这些结构关系可分为两类:基于路径的XSICs和基于元素的XSICs.3.1基于路径的XSICs基于路径的XSICs描述路径之间的蕴涵、互斥和同现关系(下文简称为路径约束).任意给定一个XML文档树T,V表示T中的节点集,u[P]表示在T中从节点u开始沿着路径P可以访问到的节点集.若用ε表示空路径,则u[ε]={u},r[ε]={r}.路径蕴涵、路径互斥和路径同现定义如下.定义5.C,P,Q∈LP,u,v,v∈V,则(1)路径P蕴涵Q,记作C(P→Q);如果uv(u∈r[C]∧v∈u[P]→v(v∈u[Q])),则T满足C(P→Q),记作TC(P→Q);(2)路径P与Q互斥,记作C(P∨Q);如果uv(u∈r[C]∧v∈u[P]→v(v∈u[Q]))且uv(u∈r[C]∧v∈u[Q]→v(v∈u[P])),则T满足C(P∨Q),记作TC(P∨Q);(3)路径P与Q同现,记作C(PQ);如果C(P→Q)∧C(Q→P),则T满足C(PQ),记作TC(PQ).其中:①路径C为约束的上下文路径,它指定路径约束关系在文档树的哪个子树上成立,且规定C为简单路径表达式.当C=ε时,表明特定的路径约束关系在整个文档树中成立,且上下文路径ε可以被缺省.②P和Q分别叫作约束的前件路径和后件路径;C是P和Q的公共路径前缀.当|P|=|Q|=|C|+1时,路径蕴涵、互斥和同现表示兄弟元素之间的蕴涵、互斥和同现.为了书写简单,在约束实例中通常将P和Q写成相对于C的相对路径.例如:在图1所示的XML文档树中,如下路径约束成立:φ1/papers/paper(subtitle→authors/author/name)φ2/papers/paper(title.//author/name)φ3/papers/paper(type/jourpaper∨conference)通俗地讲,路径蕴涵C(P→Q)表示在C所确定的XML文档子树上,如果路径P存在,那么路径Q也一定出现;如果两个路径相互蕴涵则称这两个路径同现;路径互斥C(P∨Q)则表示在C所确定的XML文档子树上路径P与路径Q不能同时出现.3.2基于元素的XSICs基于元素的XSICs描述了元素之间的蕴涵、互斥、同现和结构包含关系.由于元素之间的蕴涵、互斥和同现关系是路径蕴涵、互斥和同现关系的特例,因此,这里只讨论元素的结构包含关系.根据元素的结构包含关系在查询优化中的不同作用,将其分为排他性包含和必需性包含(下文简称为元素包含约束),定义如下.定义6.P,Q∈LP,ei∈E,ej∈E∪A,u,v,v1,v2∈V,则(1)元素ei必需包含ej,记作eiej;如果u(lab(u)=ei→v(lab(v)=ej∧v∈u[P])),则T满足eiej,记作Teiej;(2)元素ei排他包含ej,记作eiej;如果u(lab(u)=ei∧v1v2(v1∈u[P]∧v2∈u[Q]∧lab(v1)=lab(v2)=ej)→P=Q),则T满足eiej,记作Teiej.例如:在图1所示的XML文档中,下列约束成立:定理1.ei,ej∈E,ek∈E∪A,如果eiej这个定理说明了必需性包含的传递性,其正确且ejek,则eiek.性是显然的.3.3XSICs的约束重写为了便于推理,本文将元素包含约束、路径同现和路径互斥约束表示为等价的路径蕴涵约束.由于路径同现是双向的路径蕴涵,因此,下面着重讨论路径互斥约束和元素包含约束的约束重写问题.3.3.1路径互斥的约束重写如前所述,路径互斥C(P∨Q)表示在C所确定的XML文档子树上,一个路径P存在必然排斥另一个路径Q的存在.为了使用路径蕴涵表示这样的语义,引入了“逻辑非”运算符“”,即P表示P不存在.这样C(P∨Q)就可以表示为C((P→Q)∧(Q→P)).引入“逻辑非”运算符后,线性路径表达式和线性路径表达式集之间的成员关系定义如下:给定任意线性路径表达式集B和一个线性路径表达式Q,Q∝B当且仅当P∈B且Q∈Subpaths(P);Q∝B当且仅当P∈B且P∈Subpaths(Q).3.3.2必需性包含和排他性包含的约束重写由于元素包含约束与路径约束之间的相互作用,如何将两类约束有机地结合起来是进行XSICsPage5推理的一个必要条件.在关系数据库中,通常采用chase技术改写查询使之包含完整性约束的作用[14].本文采用同样的技术改写路径约束集使其集成元素包含约束的作用.下面的定理陈述了元素包含约束与路径蕴涵之间的关系.示P中的节点类型集,则有定理2.令P=c1e1c2e2…ckek,用Nodes(P)表(1)若eiej且ei,ej∈Nodes(P)(i<j,i=1,2,…,k-1,j=2,…,k),则c1e1…ciei//ej…ckek→P;(2)若ek-1ek且ek-1,ek∈Nodes(P),则c1e1c2e2…ck-1ek-1→P;(3)若eien且ei∈Nodes(P)∧enNodes(P)(i=1,2,…,k),则P→c1e1c2e2…ciei//en.证明.(1)从排他性包含的定义可以直接得出这个结论是正确的.(2)假设ek-1ek成立,而c1e1c2e2…ck-1ek-1→P不成立,则在XML文档中路径c1e1c2e2…ck-1ek-1存在时P不一定存在,即在该文档中有无ek作为后代节点的ek-1节点存在,这与假设ek-1ek相矛盾,因此假设不成立.(3)从必需性包含的定义可以直接得出这个结论也是正确的.从这个定理出发,可以直接得到一个使用元素包含约束chase路径约束集的方法.给定一个元素包含约束集Ω和一个路径约束集Σ,首先计算约束集Ω的闭包Closure(Ω),然后使用Closure(Ω)改写路径约束集Σ使之集成元素包含约束的作用.方法如下:(1)首先使用约束集Ω初始化Closure(Ω),然后根据定理1检查Closure(Ω)中的每个约束:如果eiej且ejek,则在Closure(Ω)中添加约束eiek,直到Closure(Ω)不再发生变化为止.(2)依次检查Σ中的每个路径表达式P=c1e1c2e2…ckek,若eiej∈Closure(Ω)且ei,ej∈Nodes(P)(i<j,i=1,2,…,k-1,j=2,3,…,k),则将c1e1…ciei//ej…ckek→P添加到Σ中;若ek-1ek且ek-1,ek∈Nodes(P),则将c1e1c2e2…ck-1ek-1→P添加到Σ中;若有eien∈Closure(Ω)且ei∈Nodes(P)∧enNodes(P)(i=1,2,…,k),则将P→c1e1c2e2…ciei//en添加到Σ中.(3)重复(2)的操作,直到路径约束集Σ不发生变化为止.例1.给定约束集Σ={φ1,φ2,φ3}和Ω={φ4,φ5,φ6},其中,φ1、φ2和φ3为3.1节中的路径约束,φ4、φ5和φ6为3.2节中的元素包含约束,使用我们的chase技术得Closure(Ω)={φ4,φ5,φ6,papername};chase后的路径约束集Σ={φ1,φ2,φ3,/papers/paper//author→/papers/papaer//author/name,/papers/paper→/papers/paper//name,/papers/paper/authors/author→/papers/paper/authors/author/name,/papers/paper→/papers/paper//author,/papers/paper//author/name→/papers/paper/authors/author/name}.4XSICs的逻辑蕴涵类似于关系数据库中的函数依赖,XSICs之间也存在逻辑蕴涵问题,XSICs逻辑蕴涵的定义及相关概念如下.定义7.给定一个XSICs集Σ和一个XSICsφ,如果每一个满足Σ的XML文档也满足φ,则称Σ逻辑蕴涵φ,记为Σφ;一个XML文档T满足一个XSIC集Σ,记为TΣ.定义8.给定一个XSICs集Σ,被Σ所蕴涵的XSICs集合叫作Σ的闭包,记为Σ+.使用3.3节中的约束重写技术,可以将所有的约束改写为路径蕴涵约束.因此,XSICs逻辑蕴涵问题被转化为路径蕴涵约束的逻辑蕴涵问题.解决逻辑蕴涵最有效的方法是给出一个有效的、完备的推理规则.不失一般性,下面给出了一个路径蕴涵约束的推理规则集,并证明这个推理规则集的有效性和完备性.4.1XSICs的推理规则C(P→Q).C(P→Q).规则1.C(P→Q),C∈Subpaths(C)规则2.C(P→Q),C∈Subpaths(C)规则3.C(P→Q),C(Q→S)C(P→S).规则4.C(P→Q),C(Q→S)C(P→S).规则5.C(P→Q),C(S→Q)C(P→S).规则6.P,Q∈LP,Q∈Subpaths(P)P→Q.4.2推理规则的有效性推理规则的有效性是指每个能由XSICs集Σ使用推理规则推导出来的路径蕴涵约束一定被ΣPage6所逻辑蕴涵,也就是说这些推理规则是正确的.定理3.推理规则1~规则6是正确的.(1)规则1、2的正确性规则1的正确性是显然的.根据路径约束的定义,上下文路径为简单路径表达式.这种情况下,路径C确定的子树一定在其子路径C所确定的子树范围内,既然在C所确定的子树上P出现时Q一定出现,那么在包含该子树的子树上P出现时Q也一定出现.类似于规则1,在XML文档树上,路径C所确定的子树一定在其子路径C所确定的子树范围内,在C所确定的子树上P出现时Q不出现,那么在该子树上的任何子树上P出现时Q也不会出现.因此,规则2也是正确的.得到.这里不再赘述.(2)规则3、4的正确性规则3、4的正确性可以直接从路径蕴涵的语义(3)规则5的正确性证明.假设C(P→Q)和C(S→Q)成立,但C(P→S)不成立,则至少在一个C确定的XML文档子树上(记作Ts),P和S同时存在;又因为C(S→Q)成立,因此,在这个子树Ts上,P和Q同时存在.这与C(P→Q)相矛盾,故假设不成立.(4)规则6的正确性规则6陈述了这样的事实,在XML文档的任何子树上,一个路径存在,其子路径必然存在.其正确性也是显然的.4.3推理规则的完备性4.3.1路径蕴涵闭包闭包的概念.定义9.给定一个XSICs集Σ和一个上下文路径C,路径P关于Σ和C的路径蕴涵闭包是在Σ和C下路径P所蕴涵的全部路径的最小集,记为P+(Σ,C),即P+(Σ,C)={X|C(P→X)可使用推理规则从Σ推出,其中X∈{Q,Q}}.令Δ为路径约束集,Ω为元素包含约束集,Σ=Δ∪Ω,Last(P)表示P的最后一个节点类型.P+(Σ,C)的计算算法如下.为了证明推理规则的完备性,引入了路径蕴涵算法1.Closure-Comp(Σ,C,P).输入:non-emptyΣ,C,P∈LP输出:P+(Σ,C)ifConstraint-Rewrite(Δ)==thenreturn;Σ=Constraint-Chase(Δ,Closure(Ω));i=0;A=;Bi={P};Bi+1=;if(PΔei∈Nodes(P)eiex∈Σ)ifei=Last(P)thenBi={P//ex};elseforeachφ==C(P→Q)∈Σif(C∈Subpaths(C)‖C==ε)thenA=A∪{φ};foreachφ==C(P→Q)∈Σif(C∈Subpaths(C))thenA=A∪{φ};/规则2/dowhileBi≠Bi-1i=i+1;Bi=Bi-1;foreachX∈Biforeachφ==C(P→Y)∈A/对Bi进行最小化处理/foreachP∈Biif(Q∈BiQ∈Subpaths(P))thenBi=Bi-{Q}foreachP∈Biif(Q∈BiP∈Subpaths(Q))thenBi=Bi-{Q}returnBi.算法2.Constraint-Rewrite(Δ).输入:非空路径约束集Δ输出:改写成路径蕴涵形式的约束集Δforeachφ∈Δifφ==C(PQ)thenreplaceφwithC(P→Q),C(Q→P);ifφ==C(P∨Q)thenif|C|=1thenreturnelsereplaceφwithC(P→Q),C(Q→P);returnΔ.算法Constraint-Rewrite(Δ)将路径同现和路径互斥约束改写为路径蕴涵约束.算法Constraint-Chase(Δ,Closure(Ω))使用元素包含约束chase的路径约束集Δ,使其集成元素包含约束的作用.由于chase过程中不能处理Δ中没有路径P时元素包含约束对Δ的影响,因此,在对Bi进行初始化时考虑了这种情况.Page7路径P关于Σ和C的路径蕴涵闭包是在Σ和C下P所蕴涵的全部路径的最小集.也就是说,任何路径及其子路径(路径的否定及其子路径的否定)在P+(Σ,C)仅出现一次.此外,一个路径Q及其否定形式Q也不可能同时出现在路径蕴涵闭包P+(Σ,C)中,否则该约束集是不一致的.第5节将讨论结构完整约束集的一致性问题,这里不妨先假设给定的约束集是一致的.4.3.2完备性证明引理1.φ:C(P→X)(X∈{Q,Q})可以使用XSICs推理规则从Σ中推出当且仅当X∝P+(Σ,C).这个引理的证明可以直接从路径蕴涵闭包的定义得出.引理2.令X∈{Q,Q},如果P不出现在文档树T中,则对T中的任意线性路径C和Q,都有TC(P→X)成立;如果C不出现在文档T中,则对T中的任意线性路径P和Q,都有TC(P→X)成立.证明.由于C(P→Q)(或C(P→Q))表示对任何满足C(P→Q)(或C(P→Q))的XML文档,在C所确定的文档子树上,如果路径P出现,则路径Q一定出现(或不出现);但如果路径P不出现,那么无论路径Q是否出现,也无论出现什么样的路径Q,C(P→Q)(或C(P→Q))都成立,这既符合逻辑也符合路径蕴涵的语义要求.同理,如果路径C不出现在文档中,则不论出现什么样的路径P和Q,也不论P和Q以什么样的关系出现,TC(P→X)都成立.定理4.推理规则1~规则6是完备的.推理规则的完备性是指给定一个路径蕴涵约束集Σ,对任何一个路径蕴涵约束φ,如果Σφ,则φ一定能使用推理规则1~规则6从Σ中推出.根据逆否命题的等价性,如果某个路径蕴涵φ:C(P→X)(X∈{Q,Q})不能使用推理规则1~规则6从Σ推出,则φ一定不为Σ所逻辑蕴涵.也就是说至少存在一个XML文档树T,使得TΣ,但T|≠φ.证明.假设φ:C(P→Q)(或φ:C(P→Q))不能使用推理规则1~规则6从Σ推出,证明存在一个XML文档树实例T,T满足Σ但不满足φ.(1)采用下列方式构造一个XML文档树T,使得P+(Σ,C)中除Q(或Q)以外的所有路径出现在T上.①将P+(Σ,C)分为两个子集P+(Σ,C)1和P+(Σ,C)2,其方法如下:中P+(Σ,C)1为所有无逻辑非符号的路径的集合,表示被P蕴涵的所有路径;后者是带逻辑非符号的路径组成的集合,表示在路径C所确定的子树上被P排斥的所有路径;②从P+(Σ,C)1(或P+(Σ,C)2)中删除路径Q(或Q),若φ:C(P→Q),在P+(Σ,C)1中查找路径Q;如果无Q,则在P+(Σ,C)1查找满足Q∈Subpaths(Q)的Q;若在P+(Σ,C)1中有Q(或Q),则从P+(Σ,C)1中删除(Q或Q);若φ:C(P→Q),在P+(Σ,C)2中查找路径Q;如果无Q,则在P+(Σ,C)2查找满足Q∈Subpaths(Q)的Q;若在P+(Σ,C)2中有Q(或Q),则从P+(Σ,C)2中删除Q(或Q),且在P+(Σ,C)1中添加Q(或Q).如果在P+(Σ,C)2中找不到Q和Q,则直接在P+(Σ,C)1中添加Q.③建立一个文档节点D,将C的第一个节点类型作为文档的根元素节点连接到D上,依次为C中的其它元素类型各建立一个节点,并用单线连接.④将P+(Σ,C)1中的路径按其路径表达式规定的结构关系连接在文档的C子树上,构成一个子树T1;连接方法如下:i.对P+(Σ,C)1中的每个路径S,将其转换为以C为上下文路径的相对路径,为S的第一个节点类型建立一个节点并将其连接在C的最后一个节点类型所对应的节点上;ii.为S的其它节点类型各建立一个节点,无论结点类型之间是直接包含关系还是间接包含关系,都用单线连接.⑤如果P+(Σ,C)2非空,则产生一个T1的副本T2,从T2中删除路径P(或P且P∈Subpaths(P)).将P+(Σ,C)2中的路径连接到T2的C子树上,连接方法同④;⑥将T1的文档节点和根元素节点与T2的文档节点和根元素节点合并在一起,构成一个由两个子树T1和T2组成的无文本节点和属性值的文档树实例T.当然我们可以给T添加任意文本节点,而不影响下文的证明.例2.假定Σ为例1中改写后的约束集,构造一个满足Σ但不满足约束/papers/paper(type/jourpaper→conference)的文档树.P+(Σ,C)={/papers/paper/type/jourpaper,Page8经过第②步处理后得P+(Σ,C)1=P+(Σ,C),P+(Σ,C)2=.构造的文档树T如图3所示.以r[C](即paper节点)为根的子树.注意:因为P+(Σ,C)2=,所以该文档树只有一个(2)证明该文档树T满足Σ,也即对任何ψ∈Σ,Tψ.假设任一路径蕴涵ψ:C(P→X)(X∈{Q,Q}),ψ∈Σ,但文档T|≠ψ,则①若C不出现在文档T中,则根据引理2得Tψ,与假设T|≠ψ相矛盾;②若P不出现在文档T中,则根据引理2得Tψ,与假设T|≠ψ相矛盾;③若C和P都出现在文档T中,则有P∝P+(Σ,C).根据引理1得C(P→P)成立;若X=Q,即C(P→Q)∈Σ.由于上下文路径C出现在文档T中,根据P+(Σ,C)的计算方法可知C=C或C∈Subpaths(C),由推理规则1得C(P→Q);再根据推理规则3得C(P→Q),由引理1知Q∝P+(Σ,C).因此Tψ,与假设T|≠ψ相矛盾;若X=Q,即C(P→Q)∈Σ.由于上下文路径C出现在文档T中,根据P+(Σ,C)的计算方法可知C=C或C∈Subpaths(C),由推理规则2得C(P→Q);再根据推理规则4得C(P→Q),由引理1知Q∝P+(Σ,C).因此Tψ,与假设T|≠ψ相矛盾;由此可见,TΣ.(3)证明文档树T不满足φ:C(P→Q)(或φ:C(P→Q)),即T|≠φ.设Tφ,若φ:C(P→Q),则Q和P必出现在T的同一子树T1上,即Q∝P+(Σ,C)1,也即Q∝P+(Σ,C);若φ:C(P→Q),则P出现在T的子树T1上且Q出现在子树T2上,即Q∝P+(Σ,C)2,也即Q∝P+(Σ,C);根据引理1,φ能由Σ使用推理规则1~规则6推出,与假设“φ不能由Σ使用推理规则1~规则6推出”矛盾,因此T|≠φ.综上所述,路径蕴涵φ:C(P→X)(X∈{Q,Q})不能由Σ根据推理规则推出,则φ一定不为Σ所逻辑蕴涵,所以推理规则1~规则6是完备的.5XSICs的一致性和结构完整性约束相关的另一个判定性问题是它的一致性问题.类似于文献[11],XSICs的一致性定义如下.定义10.给定一个线性路径表达式的有限集B和B上的一个XSICs集Σ,是否存在一个文档树T,使得P∈B,P都出现在T中且TΣ.如果有这样的文档树T存在,则XSICs集Σ是一致的(或可满足的).造成XSICs不可满足的原因是XSICs集中的约束本身的不一致性和约束之间的不一致性.其可能出现的情况有3种:首先,一个路径互斥约束的上下文路径的长度不能等于1,如果上下文路径长度为1,则表明在XML文档树的根元素节点下,一条路径的存在排斥另一条路径,这显然是不可能的[11].这个问题在约束重写时(算法2)已得到了解决.其次,如果两个路径互斥,则其中的一个不能被另一个直接或间接地蕴涵.最后,如果两个路径互斥,则这两个路径不能被同一个路径直接或间接地蕴涵.本文利用路径蕴涵闭包解决XSICs的一致性问题.定理5.若P为约束集Σ中的任意约束的前件路径,如果P+(Σ,C)=,则Σ是不可满足的.该定理的正确性是显然的,P+(Σ,C)=意味着约束重写后的约束集Σ为空;而造成这种结果的直接原因是路径互斥的上下文路径长度等于1.引理3.若C(X→Y)成立,且X∝P+(Σ,C),则Y∝P+(Σ,C).证明.如果X∝P+(Σ,C),则有C(P→X);又因为C(X→Y)成立,根据规则3得C(P→Y),所以Y∝P+(Σ,C).推论1.若C(X→Y)成立,且X∝P+(Σ,C),则Y∝P+(Σ,C).引理4.如果C(P→Q)且Q∈Subpaths(Q),Page9则C(P→Q)一定成立.证明.因为Q∈Subpaths(Q),根据推理规则6得Q→Q成立;又因为C(P→Q),根据推理规则5得C(P→Q).引理3及其推论说明了如果一个路径蕴涵的前件路径在某个路径蕴涵闭包,则其后件路径也一定在该路径蕴涵闭包,也说明了在一个路径蕴涵闭包中若同时存在Q和Q,则表明这个路径既蕴涵Q也排斥Q,因此Σ是不可满足的.根据引理3和4可以得出:如果在一个路径蕴涵闭包中存在Q和Q,若Q∈Subpaths(Q),则该路径既蕴涵Q又排斥Q,因此Σ也是不可满足的.定理6叙述了XSICs集内约束之间不一致性的判断方法.定理6.令+(Σ,C)表示在上下文路径C下,Σ中所有约束的前件路径的路径蕴涵闭包的集合,即+(Σ,C)={P+i(Σ,C)(i=1,2,…)中存在Q和Q使得Q∈某个P+Subpaths(Q),则Σ是不可满足的.这个定理的正确性在引理3和4的分析中已经得到证明,这里不再赘述.需要强调的是在实际应用中,计算路径蕴含闭包时并不需要穷举Σ中的所有约束的上下文路径,而是根据Σ中的路径互斥约束决定计算哪些上下文路径下的路径蕴涵闭包.限于篇幅,不再给出XSICs一致性的判断算法.6结束语XML结构完整性约束表示了XML文档中元素或路径之间的结构关系,本文把XML结构完整性约束看成一个独立的模式体系研究了它的推理问题.文中定义了5种结构完整性约束的语法和语义,给出了一组有效的、完备的XML路径蕴涵约束的推理规则.借用关系数据库中函数依赖闭包的概念,本文提出了路径蕴涵闭包的概念及其计算方法.以此为工具,证明了推理规则的完备性,解决了XML结构完整性约束的一致性判断问题.在以后的工作中,我们将进一步研究XML结构完整性约束在路径表达式查询优化中的作用,探讨如何利用XML结构完整性约束对路径表达式进行最小化处理.此外,XML结构完整性约束可以看成是对DTD的扩展和补充,今后我们的另一个主要研究课题是如何使用XSICs来扩展DTD,得到所有路径表达式的路径蕴涵闭包,从而对路径表达式查询进行全面的优化.
