Page1针对RSA算法的踪迹驱动数据Cache计时攻击研究陈财森1),2)王韬2)郭世泽3)周平2)1)(装甲兵工程学院科研部北京100072)2)(军械工程学院信息工程系石家庄050003)3)(北方电子设备研究所北京100083)摘要Cache计时攻击是旁路攻击领域的研究热点.针对滑动窗口算法实现模幂运算的RSA算法,分析了RSA算法访问驱动Cache计时攻击的难点,建立了踪迹驱动数据Cache计时攻击模型.在攻击模型与原有踪迹驱动计时攻击算法的基础上,利用幂指数与操作序列的相关性、窗口大小特征和预计算表索引值与窗口值的映射关系,提出了一种改进的幂指数分析算法,并给出了利用幂指数dp和dq的部分离散位恢复出私钥d的格攻击过程.利用处理器的同步多线程能力实现了间谍进程与密码进程的同步执行,针对OpenSSLv0.9.8b中的RSA算法,在真实环境下执行攻击实验.实验结果表明:新的分析算法大约能够获取512位幂指数中的340位,比原有算法进一步降低了密钥恢复的复杂度;同时对实际攻击中的关键技术以及可能遇到的困难进行分析,给出相应的解决方案,进一步提高了攻击的可行性.关键词RSA密码算法;旁路攻击;数据Cache计时攻击;踪迹驱动;滑动窗口算法;网络安全;信息安全1引言RSA算法是目前最为广泛使用的公钥密码算法之一,其安全性是依赖于大整数因式分解的困难性,一定长度的密钥从数学分析的角度上能够保证私钥的安全性.然而随着旁路分析的发展,研究结果表明,由于采用窗口算法实现的RSA算法存在查找预计算表的操作,导致其遭受数据Cache攻击的威胁.自从Kocher[1]和Kelsey等人[2]提出将高速缓冲存储器Cache的行为信息作为旁路泄露信息的思想以来,不少密码分析学家针对各种密码算法的Cache攻击展开研究.2002年,Page[3]提出了一种针对DES的Cache攻击方法,利用访问Cache时命中与失效的时间差异信息与S盒查找表的索引值以及子密钥的相关性,缩小密钥的搜索空间,将DES密钥搜索空间由56位降低到32位;2004年,Bernstein①提出并实现了一种针对OpenSSL中AES算法的时序驱动Cache计时攻击方案.由于分组密码算法实现过程中大部分存在查找S盒的操作,导致很容易遭受Cache攻击,因此起初的研究大都针对分组密码展开,而针对公钥密码算法的Cache攻击研究相对较晚.2005年,Percival[4]首次提出了利用多线程间共享Cache资源的特点,使间谍进程能够与密码进程同步执行,并监视密码进程实现过程中访问Cache的状态信息,设计并实现了一种针对采用滑动窗口算法实现的RSA算法Cache计时攻击方案.2007年,Aciicmez等人[5]提出了一种新的旁路攻击概念.微架构攻击(Micro-architecturalAttack,MA),将攻击的微处理器部件单元由数据Cache扩展到包括指令Cache和分支预测单元等微架构元器件,主要提出了基于指令Cache[6]和BPU[7]的攻击模型与算法,但只停留在理论验证和仿真实验阶段,而且实验细节及实验结果很少公开.国内在密码Cache计时攻击方面的研究起步较晚,而且大都是针对分组密码算法,针对公钥密码算法的Cache攻击研究较少,仅仅停留在攻击机理研究阶段.目前针对密码算法的Cache攻击按照采集的时间类型不同可分为时序驱动攻击①、访问驱动攻击[8]和踪迹驱动攻击[9].时序驱动攻击采集的是密码进程整个加解密时间,执行操作简单,但所需样本量非常大,且易受外界因素的干扰;访问驱动攻击利用间谍进程采集密码进程加解密过程中访问Cache的特征信息,利用密码进程查找表操作导致间谍进程二次访问时命中和失效的时间差异以及查找表索引值与密钥信息的相关性进行密码分析,主要适用于基于S盒查找的分组密码算法,对于不存在查找表操作或查找表很小的公钥密码算法执行此类攻击存在一定的困难性;踪迹驱动攻击利用间谍程序采集密码进程一次加解密过程中每次查表Cache访问的命中和失效信息,具有采集方法复杂、分析方法简单的特点,先前的大部分研究是通过采集功耗[10]或电磁②的手段进行的,需要物理接触密码设备,实施起来较为复杂.本文主要针对RSA算法的踪迹驱动Cache计时攻击展开研究.利用采用滑动窗口算法实现模幂运算过程中预计算表的查找操作导致的Cache命中与失效特性,建立基于数据Cache的踪迹驱动攻击模型;利用间谍进程采集密码进程执行过程中泄露的Cache访问踪迹,获取算法执行的关键操作序列,提出由算法操作序列推导出幂指数位信息的分析方法;利用窗口大小特征以及预计算表索引值与窗口值的相关性,提出一种能进一步缩小幂指数搜索空间的算法;最后在具有同步多线程能力的处理器上执行攻击实验,精心编写能够与密码进程同步执行的间谍程序,在真实环境下针对OpenSSLv0.9.8b密码库中的RSA算法执行攻击,对攻击过程中的难点进行分析并给出相应的解决方案.设计并执行实验成功获取幂指数dp和dq大约340位的幂指数值,再运用格攻击的分析方法推导出完整的密钥值,验证了①②Page3密钥分析方法与踪迹驱动攻击的正确性和可行性.目前在国内外研究中,针对RSA算法的踪迹驱动Cache计时攻击研究成果不显著,还没有提出一种通用的针对公钥密码算法踪迹驱动Cache计时攻击分析算法,原有的攻击大都通过修改源码的方式将间谍进程嵌入密码进程的方式实现,实现两个进程间的假同步,而且实验还处于仿真验证阶段,尚未有真实环境下的攻击实验结果公开.依据研究现状,本文的主要贡献有:(1)通过分析RSA密码算法的内部执行操作流程,结合针对分组密码算法的访问驱动攻击原理,指出针对RSA算法访问驱动Cache计时攻击的困难性,依据踪迹驱动攻击原理,建立了一种通用的踪迹驱动数据Cache计时攻击模型.(2)结合OpenSSL密码库中BIGNUM类型的数据结构,深入分析了RSA算法实现过程中相关算法内部执行状态,利用幂指数位与平方乘法操作序列的相关性以及预计算表虚拟内存地址与Cache组的映射关系,在原有分析算法的基础上,提出了一种基于窗口大小特征的分析算法,进一步提高Cache计时信息的利用率,缩小了密钥的搜索空间.(3)在实际环境下执行Cache攻击实验,对攻击的关键技术和可能遇到的难点进行分析,主要对有效信息筛选、Cache组定位以及索引值与Cache组的映射等关键性问题进行阐述,并给出了相应的解决方案.(4)给出由幂指数dp和dq的部分离散位信息推导出完整私钥d的格攻击过程.针对OpenSSLv0.9.8b密码库中的RSA算法,在同步多线程(SMT)处理器上执行攻击实验,采集真实的数据Cache访问时间,真正实现间谍进程与密码进程同步执行.实验获取512位幂指数中大约340位离散的位信息,利用给出的格攻击算法恢复完整密钥,证明比原有算法进一步缩小了密钥搜索空间.本文第2节给出RSA算法及滑动窗口实现算法、Cache访问机制和Cache计时攻击等相关知识;第3节给出了查找预计算表访问Cache时间泄露和密钥分析的机理,分析了针对RSA算法访问驱动Cache计时攻击的困难性,建立了基于数据Cache的踪迹驱动攻击模型;第4节依据攻击模型,给出由Cache踪迹信息推算幂指数的分析算法;第5节分析了实际攻击中存在的难点,并给出相应的解决方案;第6节设计并实现针对OpenSSL的RSA算法Cache攻击实验,给出密钥推导过程,对实验结果进行对比分析并讨论;第7节进行总结.2相关知识2.1RSA算法及其实现RSA密码算法[11]是目前最为广泛使用的公钥密码算法,是第一个既能用于数据加密也能用于数字签名的算法.密钥的构造过程:首先选择两个素数p和q,计算N=pq,随机选取加密密钥e,满足ed=1mod(p-1)(q-1),然后采用欧几里得扩展算法获得解密密钥d,则d=e-1mod(p-1)(q-1).其中e和N公开,d为私钥.设M表示明文,C表示密文,则算法的加密操作为C=MemodN,解密操作为M=CdmodN,实现算法的核心是模幂运算:S=mdmodN.目前流行使用的OpenSSL密码库③是广大密码分析学家关注的主要对象,为了更好地掌握时间泄露机理,现对RSA算法中模幂运算具体实现进行分析.最简单的实现方式是平方乘算法,即将模幂运算分解成一系列平方和乘法运算,包括从左到右和从右到左两种算法.但平方乘算法存在运算速度慢的缺点,为了提高RSA执行速度,1982年比利时的Quisquater等人[12]首次应用著名的中国剩余定理提高了RSA算法的运算速度,将mdmodN分解为mdpmodp和mdqmodq,降低计算复杂度,大约能够提高4倍的执行速度.OpenSSL算法库在实现模幂运算时,采用滑动窗口算法[13].它是一种优化的快速计算模幂运算算法,将模幂运算分解为一系列的乘法运算和平方运算,幂指数以一定大小的窗口在二进制幂指数上进行滑动,利用预计算表中的元素直接作为乘数,减少乘数重复计算的步骤,提高运算效率.该思想也在DSA、ECC等公钥密码算法中得到了应用,是本文重点关注的实现算法,具体描述如算法1所示.算法1.模幂运算的滑动窗口实现算法.输入:m、N和d=(dn-1,dn-2,…,d1,d0),win_size输出:S=mdmodN初始化表T[2(win_size-1)]S=1;For(k=n-1,k>0,k--){③TheOpenSSLProject:OpenSSL.TheopensourcetoolkitPage4IF(dk==0){FOR(i=1;i<win_size;i++){获取窗口位数wend和窗口值wvalueFOR(j=0;i<wend;j++){}S=S×T[wvalue1]modN;k=k-wend;}ReturnS;算法1中,窗口大小win_size与幂指数d的长度l有关,在OpenSSLv0.9.8b中,通过调用BN_window_bits_for_exponent_size()函数计算出对应窗口大小,当l671时win_size=6,当671>l>239时,win_size=5.对于通常采用的1024位RSA密钥来说,CRT实现算法中涉及的幂指数dp和dq的长度约为512,因此对应的窗口大小为5.2.2Cache工作原理为解决CPU与主存之间速度不匹配的问题,现代微处理器和微型计算机中,大都采用高速缓存Cache[14],为处理器提供一种快速方便地访问最频繁访问的数据和指令的方式,依据级别不同可分为L1Cache、L2Cache甚至还有L3Cache,依据类型可分为数据Cache和指令Cache.为了解决直接映射高速缓存中冲突不命中造成的问题,目前Cache一般采用组相连的结构,设整个Cache包括S个Cache组,W路组相连,每个Cache行大小为B字节,每个Cache组有W个Cache行,则Cache总大小为S×W×B字节.Cache的工作原理[14]:以数据Cache为例,当处理器需要从主存读取数据时,它首先检测这些数据是否存在数据Cache中,如果存在,处理器立即读取这些数据,而不需要访问主存(发生Cache命中);否则,处理器必须从更高一级的Cache或主存中读取数据(发生Cache失效),同时将数据的副本存储在Cache中,可以使得以后对整块数据的读取都从缓存中进行,不必再调用内存.每一次Cache失效都会产生对更高一级存储器的访问,从而导致额外的存取延迟时间或较大的能量消耗.另外CPU与Cache之间的数据交换以字为单位,而Cache与主存之间的数据交换是以字块为单位.而且根据程序局部性原理,会把包括要访问的数据在内的一整块Cache行B字节大小的数据从主存读出,装载入Cache中.当需要驱逐Cache时,为了保证CPU访问时有较高的命中率,缓存中的内容应该按一定的算法替换.通常采用的算法是“最近最少使用算法”(LRU算法),将最近一段时间内最少被访问过的Cache行淘汰出局.具体查找Cache行是否存在的过程如下:在组相连的Cache结构中,Cache组中的任何一行都可以包含被映射到这个组的存储块,因此Cache在寻找一个有效的行时,必须搜索组中的每一行,检查其标记与地址中的标记是否相匹配.如果在Cache中找到了,则发生命中,块偏移从这个块中选择一个字,否则发生失效,需要从主存载入再读取.以本文采用的IntelPentium4处理器的L1数据Cache结构为例,给出虚拟内存地址的逻辑结构图如图1所示,为后面的密钥分析算法做准备.总大小为16KB,Cache行大小为64字节,8路组相连,因此共256个Cache行被分为32个Cache组.在目标系统中每个虚拟存储器地址被分为3个部分:最低6位为块偏移位,用于选择每个Cache行中64个字节起始位置;与之邻近的5位为组索引位,用于选择32个相连的Cache组,剩余的21位为标记位,用于区分关联到相同Cache组的地址,标记位与索引位连起来唯一地标识了存储器中的每个块.图1目标系统中虚拟存储器地址的逻辑结构图Cache攻击正是利用Cache访问的时间或者能量消耗差异信息,得到Cache“命中”和“失效”特征信息,然后使用相应的旁路信息分析方法,缩小密钥搜索空间甚至得到完整密钥.2.3Cache计时攻击Cache计时攻击[15]属于微架构攻击的一种,主要利用密码算法在加解密过程中通过微架构元器件Cache泄露出来的时间信息,结合明文或密文,以及Cache行为和密钥信息的相关性来进行密钥分析的一种攻击方式,属于旁路攻击的范畴.依据Cache工作原理可知,密码进程访问数据时,由于目标数据当前是否存在于Cache中可通过计时手段的方式进行判断,同时由于“命中”与“失效”的时间差异信息和密钥往往是紧密相关的,所以只要能采集到足够多的时间旁路信息,结合分析算法就有可能推测出密钥.Page5根据Cache类型,可将计时攻击分为数据Cache攻击、指令Cache攻击两种[15].由于现代分组密码大多使用S盒查找表实现非线性混淆,而查找表需要对数据Cache进行访问,所以目前利用数据Cache进行的攻击对象主要为分组密码,如DES[3]、AES①;另外有部分公钥密码算法,如RSA[4],采用窗口算法实现实现模幂运算时,存在查找表的操作,同样存在遭受数据Cache计时攻击的可能;现代公钥加密系统大都利用经典数学问题的单向陷门特性,使用了大量的指令访问操作,其加解密过程中由于密钥位值不同所要进行的指令访问操作数目有很大的区别,此时会导致对指令Cache访问次数及时间存在很大区别.所以,目前利用指令Cache的攻击对象主要是公钥加密系统,如RSA[5-6]、DSA[16]、ECC[17].指令Cache攻击不在本文的讨论范围内,本文主要针对数据Cache计时攻击进行分析.根据所采集的时间信息类型的不同[18],可将计时攻击分为时序驱动①、访问驱动[8]、踪迹驱动[9]3种方式.时序驱动攻击采集的是密码进程整个加解密时间,采集方法简单,平台适用性强,但所需样本量大,一般都要百万计,离线分析方法比较复杂.更重要的是,在远程环境中,网络传输时延甚至是抖动时延都会大大影响计时的精度,采集到精确的加密时间显得极为困难.访问驱动攻击[8]主要利用间谍进程两次采集密码进程加密或解密前后访问的Cache组集合差异信息,采集方法比时序驱动稍显复杂,但分析方法比较简单,在木马植入技术日趋成熟的今天,攻击实现的可行性比较强,但该攻击方式主要适用于针对使用S盒的分组密码算法的攻击,对于公钥密码算法存在一定的困难性,具体在3.1节进行分析.踪迹驱动攻击[9]比访问驱动攻击信息采集精度更高,攻击方需要采集密码进程一次加密或解密过程中每次查表Cache访问的命中和失效信息,一般通过功耗检测手段进行,但该手段需要特殊的信息采集设备而且需要物理接触密码设备,实现起来比较复杂.采用计时的手段,利用处理器的同步多线程技术可实现间谍进程与密码进程的同步执行,不断监视密码进程执行过程中Cache访问的状态信息,可获取密码进程执行过程的整个踪迹,理想情况下一条完整的踪迹信息就足以推算出整个密钥,无论在本地还是远程攻击中都具有较强的可行性.通过分析对比发现,采用滑动窗口算法实现的公钥密码算法都存在遭受踪迹驱动攻击的可能性,本文以RSA算法为分析对象,研究基于数据Cache的踪迹驱动攻击模型以及算法.2.4预先定义为了更好地描述攻击过程,事先做如下说明:(1)Cache结构参数本文主要针对组相连的Cache结构,W路组相连,每个Cache组包含W个Cache行,每个Cache行大小定义为B字节,每个行由S个元素组成,整个Cache大小为S×W×B字节,每一路Cache的大小为S×B字节.用S0,S1,S2,…,Ss-1分别表示S个Cache组,Si0,Si1,…,Si(w-1),0i<W,表示第i个Cache组的w个Cache行,以此类推.(2)RSA密钥的推导采用中国剩余定理实现RSA算法的模幂运算mdmodN,模数N长度为β-bit,将其分解为mdpmodp和mdqmodq的计算,其中dp和dq约为β/2-bit,只要能够获取dp和dq中的任何一个数,就可通过e.dp=1mod(p-1)或e.dq=1mod(q-1)计算素数p或q;如果只能够获取dp或dq一半以上的位信息,可利用格基化约减的方法因式分解模数N,从而计算出私钥d.本文为了描述方便,以模幂运算mkmodn为分析对象,幂指数k为攻击要获取的目标,n为模数.(3)间谍进程、密码进程与攻击进程定义间谍进程为SP,密码进程为CP,攻击进程为AP.(4)窗口实现算法的参数定义滑动窗口大小为win_size,预计算表为T[2(win_size-1)],每次滑动的窗口大小为wend,对应的二进制值为wvalue;如果是固定窗口算法,窗口大小为win_size时,预计算表为T[2win_size].win_size的大小由幂指数长度决定,依据OpenSSLv0.9.8b的实现方式,当β/2671时win_size=6,当671>β/2>239时win_size=5.由于私钥d只包含在RSA的解密或签名计算中,如无特别说明,本文的Cache计时攻击针对2014-bit的RSA解密算法,β/2大约为512,因此窗口大小win_size=5.3基于数据Cache的踪迹驱动攻击模型3.1针对RSA算法访问驱动Cache计时攻击的困难性访问驱动Cache计时攻击[8]主要利用Cache访Page6问时间不确定性和Cache存储空间资源共享机制,利用间谍进程监视密码进程Cache访问操作,在密码进程一次或多次解密后,通过计时方法采集间谍进程二次访问数据的Cache“命中”和“失效”特征信息,间接得到密码进程的Cache访问信息并对其进行分析,预测加密查表索引信息,根据查表索引、明文(或密文)对以及密钥之间的关系缩小密钥搜索空间.由于多次执行密码进程会导致Cache“命中”和“失效”信息混乱,因此攻击一般采取在间谍进程连续两次运行之间仅仅进行一次加密或解密操作,从而使间谍采集密码进程执行过程中所有可能的Cache访问行为.针对分组密码算法的访问驱动攻击算法,主要是基于算法实现过程中,查找表相关信息与明文(或密文)和子密钥三者之间存在异或操作关系,即查找表的相关信息不仅仅与子密钥有关,还受输入的明文或密钥影响.攻击利用不同的明文执行操作,采集某一轮操作过程中的Cache访问行为,即查找表的信息,对所采集的信息依据是否具有某一相同Cache组命中或失效的信息进行筛选,再利用三者之间的相互关系,在一定样本量情况下,通过直接分析法或排除分析法推导出子密钥的字节信息,逐步推导出某一轮的扩展密钥信息,最后再利用子密钥和主密钥的扩展关系恢复完整密钥.在针对公钥密码算法的访问驱动攻击方面,主要涉及滑动窗口实现算法中,利用预计算表的索引图2踪迹驱动Cache计时攻击模型为了方便描述,图2中对内存结构和Cache结构进行了简化,假设CP预计算表数据和SP数据在主存中所占的内存块分别用CTD和SPD表示,CTD大小即为预计算表的大小,SPD大小和Cache存储空间大小相同(图2(a)).踪迹驱动Cache计时值与窗口值的对应关系,推导出幂指数的片段信息,但该方法在实现过程中具有一定的困难性.(1)由幂指数滑动的窗口值决定预计算表的索引值,因此预计算表的相关信息只与幂指数相关,而与输入和输出值无关.(2)由滑动窗口实现算法可知,实现过程中如果幂指数位存在若干相同的窗口值,则会对同一预计算表的对应元素多次访问.由于预计算表的大小一般较小,当窗口大小为5时,其大小有16个元素,即有16种可能的窗口值{1,3,5,…,29,31},且多个元素可能被映射到相同的Cache组,如果幂指数包含全部的窗口值,则预计算表中的每个元素都会被访问,导致无法推导并区分出窗口值及各个窗口值的数目.(3)最主要是访问驱动攻击采集整个密码执行过程的Cache访问状态,而没有记录获取Cache组访问“命中”和“失效”的顺序以及次数,从而不能判断窗口值的位置,导致即使能够获取了部分窗口值,最多也只有80=16×5个窗口位,这对于恢复512位幂指数,其计算量仍然是不可忍受的.3.2踪迹驱动Cache计时攻击模型踪迹驱动攻击比访问驱动攻击信息采集的精度更高,需要间谍进程SP与密码进程CP同步执行,采集CP一次解密过程中每次查表Cache访问的命中和失效序列,利用获取的状态序列推导出幂指数k的值.具体攻击模型如图2所示.攻击步骤如下:(1)采集一条Cache踪迹计时信息.间谍进程与密码进程在同一台PC上同步运行,攻击进程AP控制间谍SP在CP执行解密之前先启动,将SPD数据全部加载到数据Cache中,清空整个Cache(图2Page7(b));然后触发AP执行CP解密操作,运算过程中可能会执行查表操作,从而将SP部分预先加载的数据从Cache中驱逐出去,而将查到的表元素加载到Cache中(图2(c));SP与CP同步执行,循环访问私有数据SPD并测量访问每个Cache行的执行时间,SP再次对所有私有数据SPD进行访问时,对那些已被CP从Cache中驱除出来的数据进行访问时会发生Cache“失效”,需访问更高一级的存储器而消耗更多的时间(图2(d)),如果CP没有执行查表操作,则访问时发生Cache“命中”(图2(e)),并通过计算每个Cache组中所有Cache行访问时间之和作为每个Cache组的访问时间.(2)采集完整的Cache踪迹计时信息:AP使SP以一定的频率按照步骤(1)循环执行整个Cache填充并测量每个Cache组的执行时间,不断获取CP执行时的Cache访问踪迹,直到CP执行完毕,将采集的踪迹计时信息按照时间顺序进行排列,最终得到整个CP执行的Cache踪迹计时信息(图2(f))和CP的执行踪迹(图2(g)).(3)分析Cache踪迹计时信息:根据所采集的计时信息,推算出CP执行过程中的操作序列,利用查表操作与CP算法执行的操作序列相关性,得到部分幂指数的位信息,再依据查找表Cache组与查表索引值之间的映射关系以及查表索引值与窗口位的对应关系,恢复幂指数的窗口位信息,然后运用格攻击[22]推导算法恢复完整密钥.4踪迹驱动Cache计时攻击算法4.1Cache踪迹计时数据采集依据建立的踪迹驱动计时攻击模型,为间谍进程SP分配与L1数据Cache大小相等的字节数组A[0,…,S×W×B-1],依据Cache的结构特征,让SP从A中每隔B字节顺序读取数组数据元素占据整个Cache,初始化Cache的状态,为采集CP执行时的Cache踪迹做准备,具体数据采集步骤如下:(1)在Cache状态初始化完毕后,AP通知CP开始对随机生成的密文执行解密操作;(2)在CP的执行过程中,SP与其同步执行,不断访问数组A的元素,按照元素A[i×S×B+j×B],0i<W,0j<S的顺序进行访问,并测量访问每个Cache行的时间,从而获取每个Cache组中所有Cache行的访问时间,循环一次操作就可获取一条踪迹计时信息集合Ttl,0t<Time,0l<S,Time为SP循环采集的总次数,如果发生查表操作,则同时获取表的索引值Kindex(3)设置Time的值,使得SP在CP执行完毕之后才停止循环已采集完整的踪迹计时信息集合T,重复步骤(2),直到CP执行完毕,将所采集的计时信息集合以及查表索引值集合分别保存为T和K.4.2幂指数分析算法(1)基于查找表与操作相关性的指数位推导算法由算法1的执行过程可以看出,只有执行乘法运行时才会发生查表操作,其余的均为平方操作.而且滑动窗口算法中每个窗口值都是奇数,即窗口最后一位的值为1,因此如果发生查表操作即可推算出相应的指数位为1;另外窗口每次滑动都是以一定窗口的大小进行滑动的,窗口的首位值为1,滑动时是以指数位为1开始计算窗口大小的,由于win_size=5,因此从执行的平方乘法操作序列可以发现,如果连续出现5次以上的平方操作时,可推算出窗口大小开始计算前滑过指数位是0的数目.图3举例给出幂指数位与操作序列的映射关系.图3给出执行过程中观察到的部分操作序列,可以看出起始操作为乘法操作,由前面分析可以判断对应的指数位为1,以窗口大小win_size=5开始从左向右滑动,除第一个平方操作外,共有3个窗口,以乘法操作为结束点;可以判断第一个窗口大小1wend12,2种可能情况,因此推算出指数位片段k1={x1};从k3开始出现连续5个以上的平方操作序列,第3个窗口大小为1wend35,5种可能情况,推算出指数位片段k3={000},k4={xxxx1}.如果wend3=1,k4={00001};如果wend3=2,k4={00011};如果wend3=3,k4={001x1},以此类推;同样推导出k2={xxxx1}.依据该方法大约可以推导出512位幂指数中256位的值.(2)利用窗口大小的特征缩小幂指数空间除了利用操作序列进行指数位片段的推导外,还可以利用窗口大小的特征缩小幂指数空间.从算法1可知,窗口是以win_size=5进行滑动的,以指数位为1结束,当滑动的窗口小于5时,可以判断窗口Page8之后存在与win_size的差值数目相等的幂指数位为0.以图3为例,由于k1={x1},1wend12.当wend1=1时,k1={01},则可推算出k2={00001};当wend1=2时,k1={11},则可推算出k2={000x1}.利用这一特征关系可以进一步缩小密钥的搜索空间,并有利于定位索引值与Cache组的对应关系.(3)依据查找表索引值与窗口位对应关系的幂指数窗口位推导算法从算法1发现,查找预计算表的索引值Kt等于wvalue1,而且由于wvalue为奇数,即wvalue=2×Kt+1,因此如果知道表的索引值就可以计算出对应的窗口值wvalue.攻击过程中是利用预计算表与Cache组的映射关系,通过间谍进程监视Cache组的访问状态判断出是否发生查表操作,对表中的哪些元素进行访问,从而获取索引值,推算出窗口位,理论上能够恢复完整的幂指数位.本文针对的窗口大小为5,预计算表的大小为16个元素,据OpenSSL提供的BIGNUM类型分析可知,每个元素的大小为20个字节,共320个字节,而Cache行大小为64字节,因此16个预计算表元素对应5~6个连续Cache组区域,即多个表元素会被映射到同图4采集的Cache计时数据的伪彩色图表示结果图4中用颜色的深浅表示访问每个Cache组的时钟周期数,颜色越深表示所消耗的时间越短.横坐标X表示循环的序列,对应于采集的时间顺序,纵坐标Y表示32个Cache组对应的计时数据.从图中可以明显判断CP是从X=25时开始执行解密操作的,因为此时只执行SP进程,基本上访问所有的Cache组都发生Cache命中,除了部分受系统进程干扰外.从X=80时开始出现有规律的Cache访问踪迹,可以判断CP此时开始执行滑动窗口计算;利用同样的方法可以判断CP执行滑动窗口计算的结束位置以及整个模幂运算执行完毕的位置,从而筛选出对应于滑动窗口算法执行过程的计时信息集一个Cache组,因此实际攻击时无法精确定位索引值,而是通过定位Cache组缩小索引值的搜索空间.5攻击难点分析及解决方案5.1计时信息筛选由于SP采集的信息包括CP运行前后的Cache访问状态,而且在CP运行过程中,也并非一开始就执行滑动窗口算法操作,其中还包括蒙哥马利乘法运行时需要将参与运行的数进行蒙哥马利形式变换,临时变量的初始化与释放等其它运算操作,因此首先需要对采集的数据进行筛选,尽可能剔除与滑动窗口算法操作无关的Cache访问状态对应的计时信息.为了保证SP是在CP执行前启动,在CP执行完毕后终止,当AP启动CP时,先调用高精度休眠函数nanosleep,将休眠时间精确到毫微秒级的,实验中设置的timespec的参数为{0,0x28000},SP循环采集的次数为4000次,采集的部分结果以伪彩色图表示如图4所示.合Ts.5.2预计算表对应Cache组的定位本文针对OpenSSL密码库的RSA算法执行攻击,win_size=5时,预计算表的大小为16个元素,每个BIGNUM变量的大小为20个字节③,在Cache行大小为64字节的Cache中,整个320字节大小的预计算表对应于5~6个连续Cache组区域.对前面筛选的Ts中的每一个Cache组访问时间取平均值,结果如图5所示,从图中可以看出6个连续出现的较小值(图中标注映射Cache组范围的区域)刚好对应于图4中的第11~16行,因此可以判断出预计算表对应Cache组的起始位置.Page9图5Ts中32个Cache组对应的平均访问时钟周期分布情况由于320字节大小的预计算表刚好等于5个Cache行的大小,因此只有当第一个表元素的起始位置对应于Cache行的偏移地址为0时,预计算表对应的Cache组数目才为5,否则都为6.5.3预计算表索引值与Cache组的映射当依据查找表索引值与窗口位对应关系推导出幂指数窗口位时,需要知道预计算表索引值与Cache组的映射关系.由于预计算表的16个元素映射到5~6个Cache组区域,而且表元素在Cache中存储是连续的,从图1虚拟存储器地址的逻辑结构可以看出,当块偏移地址为0时,第1个表元素对应Cache行的起始位置,此时预计算表刚好映射到5个Cache组区域,可以很快从定位的5个Cache组中推算出第1个Cache组映射的索引值为{1,3,5,7},第2个Cache组映射的索引值为{7,9,11,13},依次类推.而实际情况下往往不是这样的,从实验结果可知,预计算表往往占据6个Cache组区域,第1个或最后一个Cache组可能映射1~3个表元素索引值,其余均映射4个表元素索引值.从OpenSSL密码库可知预计算表元素的类型为BIGNUM,该类型为结构体,共包含5个结构体元素③,且每个结构体元素的大小均为4个字节.由于元素在Cache中的存储是连续的,因此对于64字节的Cache行大小,可以推算出第一个表元素在对应Cache组中的Cache行起始位置有16种可能情况,攻击时需要对每种可能性进行分析.实际上可以依据4.2节中基于窗口大小特征的幂指数空间缩小算法,通过判断相邻索引值的Cache组映射情况,结合算法的操作序列,能够进一步缩小这16种可能的情况.例如推算出相邻的两个表索引值1与3分别映射到相邻的两个Cache组区域,则可以将Cache行起始位置的情况缩小为4种情况,再分别对每种情况分析判断后面索引值对应的Cache组是否正确,经过多次分析能够确定或进一步缩小Cache行的起始位置,从而能够利用索引值推导出对应窗口位的可能值.6实验结果及分析6.1实验配置与攻击步骤Cache攻击可以在同步多线程(SMT)处理器上执行,也可以在普通单线程处理器上执行.但是在SMT处理器上,比较容易实现间谍进程与密码进程在同一个物理核中的两个虚拟核上同步执行[19],并监视密码进程的执行过程.而在单线程处理器上实现攻击则较为困难,攻击者需要利用间谍进程与密码进程之间的“Ping-Pong”效应切换两个进程的执行进度,通过操作系统的调度机制,恶意垄断CPU周期[20].本文为了便于研究,在具有SMT能力的Pentium4处理器上执行攻击实验,具体实验环境配置如表1所示.表1针对RSA算法的Cache攻击实验环境配置配置项操作系统超线程是否开启OpenSSLCPU内存L1CacheCachesize:16KBassociativesize:8wayL2CacheCachesize:2048KBassociativesize:8way在Linux操作系统中,攻击进程AP启动间谍进程SP,同时利用fork函数创建一个带有独立虚拟地址空间的新进程,执行解密操作,当fork在新进程中返回时,新进程现在的虚拟存储器刚好和调用fork时存在的虚拟存储器相同,使得间谍进程与密码进程共享同一数据Cache.为了保证SP能够在CP执行前启动,而在CP执行完毕后终止,当AP调用fork函数启动CP进程时,先调用高精度休眠函数nanosleep,将休眠时间精确到毫微秒级,实验中设置timespec的参数为{0,0x28000},同时依据CP的执行时间长短以及SP单次采集数据所需的时间长短,设置SP循环采集的次数为4000次.实验过程中,为了提高采集数据的精度,最小化其它系统进程.Page106.2踪迹信息采集依据L1Cache结构,SP的构造大小为16KB的字节数组A[16384],以64为步长,逐次访问A[index]、A[index+0x800]、A[index+0x1000]、A[index+0x1800]、A[index+0x2000]、A[index+0x2800]、A[index+0x3000]、A[index+0x3800],其中index=j×64,0j<32,并通过调用CPU的时间戳指令RDSTC,测量访问每个Cache组中所有Cache行的时钟周期数ti,从而获取一条计时踪迹图6部分Cache计时数据的伪彩色图表示结果6.3幂指数分析针对图6结果,利用前面的分析方法,可以推导出算法执行的平方乘法操作序列.图中圈出了乘法操作发生的序列,其余为平方操作,因此对应的操作序列为“MSSSSMSMSSSSMSSSMSSM”,其中S表示平方操作,M表示乘法操作,依据算法1可知第一个操作为乘法操作.对筛选过的Cache计时数据Ts,利用4.2节的密钥分析算法,对幂指数位的值展开分析.在一次实验中,OpenSSL密码库随机生成的1024位RSA密钥,对于第一个512位幂指数dp,共执行88次乘法操作,511次平方操作,出现69次5个连续的平方操作,利用操作序列与幂指数相关性可推算出dp中89个值为1的比特位(包含第一位的值为1),121个值为0的比特位,并通过平方操作数目可知第1个窗口值为1;利用窗口大小特征可推导出剩余的302个幂指数位中15个值为0的比特位;最后利用索引值的映射关系缩小窗口位的搜索空间大约能够获取115位左右的幂指数位,最终大约获取340位的值.利用相同的方法可以获取第2个幂指数dq的大约340位的信息.6.4密钥推导理论上利用前面3种幂指数分析算法可完整推算出幂指数的值,但实际攻击中一方面由于临时变Ti={t0i,t1i,…,t31i}.从采集的实验结果可知:平方操作没有执行查表操作时对应的时钟周期数为165~220;乘法操作发生查表时对应的时钟周期数为280~330.采集的Cache计时结果以伪彩色图表示为如图4,利用前面的分析算法对采集的数据进行筛选,同时定位Cache组的范围以及预计算表索引值对应Cache行的起始位置.下面对其中的部分结果进行分析,如图6所示.量也可能映射到预计算表所映射的Cache组中,导致SP无法采集有效的信息;另一方面由于同一个Cache组映射于多个表索引值,同一个表索引值可能对应于两个相邻的Cache组,因此攻击者只能获取dp和dq的部分信息,还需要利用获取的信息推导出私钥d的值.尽管文献[21]已经表明在获得其中一个因子一半的位数时,就足以在多项式时间内采用格基约化[22]的方法分解模数N,但是这一方法的前提是获得的密钥位必须是连续的,使得该方法不适合本文的攻击.因此必须找到一种新的方法能够利用我们所获取的信息因式分解模数N.给定模数N和公钥e,假设我们已经获取CRT算法中通过模p和q所获取的幂指数dp和dq的部分信息,那么从RSA的结构我们可以得到edp≡1(modp-1)和edq≡1(modq-1).那么设kp,kq∈Ze可得edp≡kp(p-1)+1和edq≡kq(q-1)+1.利用上面等式经过简单的代数计算可得等式:Nkpkq=(pkp).(qkq)=(edp+kp-1).(edq+kq-1)接下来构造一个满足等式(1)mode.2n的4维数组(kp,kq,dp,dq)集合Sn,n表示dp和dq的位长度,并且与所获取的dp和dq的部分观察值匹配,其Page11中0dp,dq<2n.其中集合S0=(kp,kq,0,0),则有Nkpkqmode=(kp-1).(kq-1)mode,那么kq由N和kp的值唯一确定,且|S0|<e.此外,如果我们获得集合Sn,由于dp的第nth位可能为0或者1,那么可以通过遍历Sn中的dp第nth位值的两种情况,组成2个4元组计算得到Sn+1,再通过等式(1)判断dq第nth位的值,并且抛弃其它任何不满足该等式的4元组候选值.如果我们都无法确定指数dp和dq第nth位的值,则有|Sn+1|=2|Sn|,其中|Sn|表示集合Sn的大小;如果我们知道其中一个指数第nth位的值,那么Sn中每个4元组与Sn+1有唯一匹配的4元组,则有|Sn+1|=|Sn|;如果两个指数第nth位的值都知道的话,那么Sn+1的大小约为Sn的一半.Sn≈e×(1/2)k×2l,其中k表示dp和dq第nth位值都已知的数目,l表示dp和dq第nth位值都未知的数目.由于获取的dp和dq的部分信息是随机分布的,因此Sn的大小随着n的逐渐增大,会以e为起始点呈随机分布趋势,但由于已经获取的幂指数位数目比未知幂指数位数目多,因此Sn的大小随着n的增大会呈整体下降趋势.当已知位的数目多于一半时,最终S512的大小小于e.那么一旦获取S512就可以简单地测试剩余的候选指数位,因式分解模数N从而恢复出密钥d的值.利用6.3节获取的dp和dq的部分信息进行分析,其中e=65537,集合Sn的大小与n的关系如图7所示,总共需要遍历的集合数目大约为3.97×106个即可获得私钥d的值.获取dp和dq的部分信息分布不同,Sn的大小也随之更改.总体上,获取的信息越丰富,恢复私钥d的复杂度越小.6.5结果对比分析与讨论目前国外在踪迹驱动数据Cache计时攻击研究中,主要针对分组密码算法展开,而针对RSA算法的研究相对较少,只有Percival利用多线程间共享Cache资源的特点,提出了一种针对RSA算法的Cache计时攻击思想[4],并进行实验验证;国内在该领域的研究还仅处于理论研究阶段,并没有进行实验验证.本文与分组密码算法的Cache攻击①[3]、针对RSA算法的指令Cache攻击[5-6]以及功耗踪迹分析[10]因分析对象、方法不同而不具有太大的可比性,因此只与文献[4]做如下比较:(1)原有的攻击算法针对OpenSSLv0.9.7c的RSA执行攻击实验,实验中在平方操作中手工加入时延,以控制间谍进程与密码进程的执行时机,从某种意义上来说还只是处于仿真实验阶段,并没有应用于实际的攻击;本文在SMT处理器上,针对版本较新的OpenSSLv0.9.8b中的RSA算法执行攻击实验,真正意义上实现了间谍进程与密码进程的同步执行,而且还给出了实际攻击中密码进程执行踪迹起始点以及滑动窗口算法执行起始点和结束点的判断方法,对预计算表映射的Cache组进行定位,确定了表索引值与Cache组的映射关系,筛选出有用的Cache计时踪迹,执行真实环境下的攻击.(2)原有的分析算法大约能够获取512位幂指数中的310位;本文在原有分析算法的基础上提出了一种新的幂指数分析算法,利用窗口大小特征和索引值与Cache组的映射关系,大约能够获取512位幂指数中的340位,进一步减小了密钥分析的复杂度.(3)原有攻击算法在获取部分的幂指数位信息后,只指出能够用格攻击的思想恢复完整的私钥,并没有给出具体的推导算法;本文分析并参考了利用dp和dq部分连续幂指数位恢复私钥d的推导算法,给出由部分离散幂指数位恢复完整私钥d的格攻击过程,并结合实验结果进行复杂度分析.通过前面的分析,我们运用踪迹驱动数据Cache攻击模型以及算法,实现了对OpenSSL密码库中RSA算法的Cache计时攻击.攻击算法在理论上,只需要采集一次密码算法执行的Cache计时踪迹,就能够恢复出完整的密钥,不像时序攻击一样需要采集百万次以上的数据,能够有效地缩小密钥的搜索空间,提高Cache攻击的效率.利用精心编写的间谍进程不仅能够执行本地攻击,而且利用植入木马的方式同样能够作用于远程攻击.在未来的研究工作中,针对实际的攻击过程,还有如下的问题值得注意:(1)由于受操作系统中其它进程噪声的干扰,影响Cache组定位的精度,可能在同一次采集的计Page12时数据中,同时出现多个Cache组访问失效的情况,很难精确定位具体的Cache组.(2)经研究发现OpenSSL中采用BIGNUM类型的大数操作过程中需要分配临时变量,分配的数目与操作的复杂度有关,以BN_CTX类型进行内存的动态分配,因此同样会对Cache组访问时间的采集以及预计算表对应Cache组的定位带来一定的影响.(3)预计算表不像分组密码算法的S盒是固定不变的,它是在模幂运算中动态生成的,因此可能每次执行时所得到的预计算表对应的Cache组位置以及数目都不相同,会对分析算法带来一定的影响.综上所述,新的攻击算法尽管能够比原有算法进一步缩小密钥的搜索空间,但是在实际攻击应用中仍有不少困难需要克服,在下一步的研究中,我们需要研究如何尽量排除或减小噪声的影响,比如可以采用汇编语言实现间谍进程,使其中部分指令能够绕过Cache的方式执行,从而减少间谍进程本身记录Cache访问时间等操作对Cache的影响;寻找能够进一步消除或减小噪声的数据分析方法,同时给出能够有效抵御Cache计时攻击的措施.7结论本文对RSA算法的踪迹驱动Cache计时攻击进行了一些相关研究,建立了针对RSA算法的踪迹驱动数据Cache计时攻击模型,提出了能够进一步有效利用采集的Cache计时信息的分析算法,指出实际攻击过程中存在的难点并给出相应的解决方案,最终针对OpenSSL密码库的RSA算法进行攻击实验验证,研究结果表明:采用滑动窗口算法实现模幂运算的RSA算法存在遭受Cache计时攻击的安全漏洞,此类攻击方式对其它同样采用窗口算法实现的公钥密码算法安全性带来一定的威胁,能够作用于“Cache-Memory”层次存储结构的计算机平台;针对RSA算法的访问驱动Cache计时攻击存在一定的困难性,新的幂指数分析算法能比原有攻击算法能够获取更多的幂指数位,进一步缩小了密钥恢复的复杂度;由于此类攻击相比较于时序驱动攻击和访问驱动攻击所需的样本量小,攻击性强,应引起充分的关注.在实际攻击过程中,由于Cache计时攻击受外界因素影响较大,不同的执行环境、不同的密码库以及密码算法实现方式等因素都会影响攻击的执行效果,仍然存在噪声干扰大以及Cache组定位不准等问题;另外如何寻找一种既能有效抵御此类攻击又能保证密码算法性能的防御措施,这都需要我们做进一步的工作.
