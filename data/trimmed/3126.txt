Page1一种基于索引的高效犽-支配Skyline算法印鉴姚树宇薛少锷杨文新刘玉葆(中山大学信息科学与技术学院广州510006)摘要由于在多标准决策支持等应用上具有重要的意义,skyline查询成为近年来数据库和数据挖掘领域的一个研究热点.然而随着数据集维数的增加,数据点之间形成支配关系的可能性越来越小,导致了skyline点数目过多而无法提供任何有效信息.为了在高维数据集中找到更重要和更有意义的skyline点,人们提出了k-支配skyline的定义.但现有的用于k-支配skyline的算法在时间效率、空间复杂度和渐进输出性上都有待提高.该文提出了一种基于索引的高效k-支配skyline算法,通过为数据集建立两个索引,算法可以高效地进行计算,在时间、空间和渐进性上均优于现有的算法.关键词skyline;决策支持;k-支配skyline;基于索引1引言助用户做出决策的一个新的应用,由Borzsonyi、Kossmann、Stocker等在2001年的ICDE上提出[1],近年来已成为数据库和数据挖掘领域的研究Skyline查询是从数据库中抽取有趣信息以帮热点之一.Skyline查询从数据集中抽取不被其他任Page2何数据点支配(dominate)的数据点集合.一个数据点p支配另一个数据点q,当且仅当点p在所有维上的取值都不比q差,并且在至少一个维上的值比q好.而一个多维数据集的skyline则是该数据集上不被任何其它数据点支配的点所组成的集合.在实际应用中,查询对象往往是高维数据集,随着数据集维数的增加,一个点支配另一个点的概率变得非常小,这导致计算出来的skyline数据集规模太大,甚至接近原数据集的大小,无法提供给用户有意义的信息.为了在高维空间中寻找出更重要和更有意义的skyline点集,Chan等[2]提出了在数据集中计算k-支配skyline的概念.通过弱化“支配”的定义,来提高数据点之间形成“k-支配”关系的概率,使得查询出来的结果数据集规模更小,具有更好的决策支持作用.由于k-支配skyline的特殊性,传统skyline算法[3-7]等不适用于k-支配skyline查询.目前在k-支配skyline的计算上主要有3种算法,在时间效率、空间复杂度和渐进性上都存在不足.本文提出一种基于索引的高效算法,通过预处理建立数据集的两个索引,在计算过程中依靠索引让数据集中最有可能属于k-支配skyline的数据点被优先处理,迅速返回部分查询结果,而不属于结果的数据点则能尽快被淘汰掉,减少多余的比较,从而使算法在时间效率和渐进输出性上有较大提高,与此同时算法还降低了计算需要的空间开销.实验结果表明其性能比现有3种算法都好.本文第2节介绍k-支配skyline的定义;第3节介绍现有3种算法的基本思想以及存在的不足;第4节提出基于索引的k-支配skyline算法,介绍算法的基本思路和具体实现;第5节是对本文提出的算法与现有3种算法进行实验比较和分析;第6节是小结.2概念描述在解决高维空间中skyline数据集过大的问题上,目前有几种主要的方法,如文献[8-9]通过挖掘更严格定义的skyline来降低结果数据集的规模.更为直观和有意义的是k-支配skyline的挖掘,本节将首先介绍k-支配skyline的相关定义,下一节介绍并分析现有算法的缺点.给定一个d维空间S={s1,s2,…,sd},称数据集D={p1,p2,…,pd}是S上的数据集,如果D中的每一个数据点pi∈D是S空间中的一个d维数据点.用pi.sj表示数据点pi的第j个维度的值.对于每个维度si,假设在它的整个值域上存在一个全序关系,表示为i.这里i根据不同情况或者用户的不同选择可以是>或<的关系.为了简便,不失一般性,本文后面都假设i代表>关系,并且用符号>代替符号i.定义1.k-支配(k-dominate)[2].称一个点pi在空间S上k-支配另外一个点pj,当且仅当SS,|S|=k,使得sr∈S,有pi.srpj.sr,并且st∈S使得pi.st>pj.st.定义2.k-支配skyline(k-dominantskyline)[2].一个点pi成为空间S上关于数据集D的一个k-支配的skyline点,当且仅当不存在任何点pj,满足pi∈D,pj≠pi,并且使得pjk-支配pi.用DSP(k,D,S)代表空间S上关于数据集D的k-支配skyline点集.显然,当k=d时,k-支配关系等同于传统sky-line支配关系.定理1.对于一个给定空间S上的任意数据集D,其k-支配skyline数据点的数量随着k的取值变小而呈单调递减[2],即|DSP(k,D,S)||DSP(k+1,D,S).为了证明上面定理,我们先证两个引理.引理1.对于任意两个点pi和pj,如果点pi(k+1)维-支配点pj,则点pi必定k维-支配点pj.证明.根据k-支配的定义,若点pi(k+1)维-支配点pj,则存在S={s1,s2,…,sk+1}S使得对于任意st∈S,有pi.stpj.st,并且至少存在一个sr∈S满足pi.sr>pj.sr.显然,取sr∈S,并任取另外k-1个st∈S组成k个维度,则在这k个维上pi.stpj.st且pi.sr>pj.sr.因此pik-维支配点pj.引理得证.引理2.如果一个点是k维-支配的skyline点,则它也是(k+1)维-支配的skyline点.即如果pi∈DSP(k,D,S),则pi∈DSP(k+1,D,S).证明.用反证法.假设存在一个点pi∈D,满足pi∈DSP(k,D,S),但piDSP(k+1,D,S),则必然存在另外一个点pj∈D,使得点pj(k+1)维-支配点pi.又由引理1我们可以得出,点pjk维-支配点pi,由此推出点piDSP(k,D,S),与假设矛盾.定理得证.Page3由上述两个引理,定理1得证.根据定理1,可以得出对于一个数据集,只要给定足够小的k,则能够将最终k-支配skyline点的数量控制在一个有效的范围里,以便于向用户展现结果,这保证了k-支配skyline查询的有效性.k-支配skyline具有一个特殊的性质:对于一个数据集中的数据点,它们之间可能形成循环的k-支配关系.表1的例子说明了这种循环的k-支配关系.当k=3时,数据点ak-支配点b,点bk-支配点c,点ck-支配点d,而点d则反过来k-支配点a,4个点之间形成了循环的k-支配关系.这种循环的支配关系给k-支配skyline的计算带来了困难,传统的skyline算法不适用于k-支配skyline的计算.3相关研究现有的k-支配skyline查询算法主要有3种:One-Scan算法、Two-Scan算法还有SortedRe-trieval算法[2],下面简要介绍这3种算法,详细细节可参看文献[2].One-Scan算法使用与传统的循环嵌套算法(BNL)相似的思想,它主要基于以下两个特性.它是在假设一个数据点p∈D不是一个k-支配的skyline点的前题下.性质1.数据集D中必定存在一个传统的skyline点q,满足点qk-支配点p.性质2.数据点p有可能不被D中的任一k-支配skyline点所k-支配.根据性质2,要判定数据集D中的一个点p是否被数据集k-支配,仅仅用点p与D中所有k-支配skyline点去比较是不够的.而根据性质1,只要再将p与数据集D中所有传统skyline点进行比较就能判定它是否是一个k-支配的skyline点.基于以上两个性质,One-Scan算法通过计算出数据集D的传统skyline点集,并用它们来淘汰D中的非k-支配数据点,从而求解出结果.一般在算法的进行过程中,会维护两个中间数据集:(1)候选k-支配skyline数据点集R.(2)候选非k-支配skyline点的传统skyline数据点集T.对每个新处理的数据点,首先与T中的点进行比较,如果数据点被T中的点所支配则直接丢弃.如果不被支配则再与R中的点比较,判断其是否是候选k-支配skyline点,如果是则将其插入R中,否则插入T中.虽然One-Scan算法不需要任何的预处理,并且只需要对数据集进行一次扫描,然而为此算法必须在整个处理过程中保留所有的传统skyline数据点,在高维的数据集,尤其是高维反相关的数据集中,传统skyline数据集几乎接近于原数据集的大小.在这种最坏情况下,算法需要多于原数据集一倍的额外空间来记录两个中间数据集.与此同时,算法的时间开销也非常大,经过分析其计算时间与数据集中的传统skyline点数成正比.Two-Scan算法为了降低计算对于空间的要求,通过对输入数据集的两次扫描,算法可以不需要维护中间数据集T.在第一次对数据集的扫描中,循环地将D中的每一个点p与候选k-支配skyline数据集R中的每一个点进行比较,如果p被R中任意点k-支配,则丢弃p,否则将其插入R中,并且将R中被pk-支配的点删除掉.在第一次扫描处理结束后,根据性质2,R中包含了非k-支配skyline的点.因此算法通过第二次扫描去除R中的错误结果,将R中的点与D中的每个点进行比较.如果R中的一个点p被D中的任意点k-支配,则将p丢弃.经过第二轮扫描后得到的数据集R就是D中的k-支配skyline点集.Two-Scan算法的效率主要取决于在第一次扫描过程中,保存在R中的候选k-支配skyline数据点能否有效地淘汰掉大部分不属于结果的数据点.如果在第一次扫描过后,R中的非k-支配skyline点数量很少,则第二次扫描的代价很小,从而整个算法的性能会比较好.但是,由于存在着循环k-支配的关系,算法可能在第一次扫描过后在数据集R中保留了大量非k-支配skyline数据点,使得第二轮扫描的计算开销会很大,在最坏情况下算法的总时间复杂度会超过One-Scan算法,并且空间开销上也体现不出优势.对于大规模的数据集,计算时间可能很长,用户往往希望算法能够在计算过程中快速地返回部分结果,实现渐进输出.前两种算法都必须在计算结束后Page4才能返回查询结果,因此不具备渐进性.SortedRetrieval算法可以实现结果的渐进输出,它的思想来源于文献[3].首先算法将数据集D中的点根据每一个维度si∈S分别进行排序(降序排序),将每个维度的排序结果存储在|S|个数组中.在具体的实现过程中,为了节省存储空间,一般用指针代替实际存储的数据点.算法在处理过程中维护一个数据集T,一开始将T初始化为D.不同于前两个算法顺序地对数据集D进行扫描,SortedRetrieval算法反复地用一个选择函数在这|S|个数组中选择一个数组,对该数组上未被处理的具有最小值的一堆数据点进行计算,将被k-支配的数据点从T中丢弃,同时将被确定为属于k-支配skyline的数据点输出.这个过程反复循环,直到数据集T为空.在算法的处理过程中,一个数据点p只要满足以下两个条件,就可以被判定为是k-支配的skyline点:(1)p没有被已经处理过的数据点所k-支配(即p仍然留在数据集T中);(2)p已经被算法处理过d-k+1次.根据以上条件,算法不需要完成全部计算就可以提前输出部分结果.由于SortedRetrieval算法根据各个维度对数据进行了预排序,因此在计算过程中具有支配能力的数据点有较高的概率被提前处理并用于快速淘汰其它不属于结果的数据点.同时算法具备了渐进性.然而,由于SortedRetrieval算法需要记录每个维度的预排序结果数组,在具体实现中虽然用指针可以避免冗余存储数据点,但是|D|个指针数组也使得算法需要的额外空间开销很大.同时,预排序的开销并不一定能保证算法在性能上比另外的算法有更好的表现.尤其在反相关的数据集中,大部分数据点只能在算法的结束阶段才被输出,这时算法在计算效率上并不比Two-Scan算法高,再加上预排序的开销,性能反而更差了.这种不理想效果很大程度上是因为每个维度的预排序结果数组只保留了单个维度的信息,而没有根据k值对数据点进行一个综合的考虑.4基于索引的高效犽-支配Skyline算法4.1算法的基本思想性3个方面进行考虑.(1)时间效率的改进为了提高算法的时间效率,应该尽可能地减少我们的算法从时间效率、空间开销和渐进输出点与点之间的比较次数.在对数据集D进行k-支配skyline查询的过程中,如果算法在判定一个数据点p∈D是否属于k-支配skyline数据集时,能够将p优先与D中具有较强k-支配能力的数据点进行比较,则对于大部分非k-支配skyline数据点,算法可以快速地将它们淘汰掉,从而节省了大量比较,提高了效率.为了实现这一优化目标,算法需要建立一个关于数据集D中各个数据点k-支配能力的索引.(2)提高渐进输出性一个渐进性良好的算法必须能够在计算初期快速返回部分结果.为了尽快输出结果,在对数据点的处理过程中算法应该优先选择那些有较高概率属于结果数据集的点进行处理.在算法对数据点进行处理时,如果能够在未被处理的数据点中优先选择具有较大可能成为k-支配skyline的点,则可以更快地找到大部分目标数据点,从而减少算法需要维护的中间数据集的大小,并且能够较快地返回部分计算结果,保证算法良好的渐进性.为此,算法还需要建立一个关于数据集D中各个数据点成为k-支配skyline点能力的索引.通过建立以上的两个索引表,算法在处理过程可以根据第2个索引来选择要处理的数据点,再将当前处理的数据点根据第1个索引的顺序与其它数据点进行比较,这样算法就能够快速识别并返回真正的k-支配skyline点,同时快速淘汰其它的非结果数据点,实现高效率和良好渐进性的计算.(3)减少空间开销空间开销的优化目标是减少计算过程中需要的额外空间,并且保持开销大小的稳定.由于我们只为数据集建立两个索引,比起需要建立|S|个预排序数组的SortedRetrieval算法,能够大大降低建立索引的空间开销.同时改进算法使得计算过程中不需要保留中间结果,这样与需要暂存中间数据集的One-Scan和Two-Scan算法相比不仅空间开销减少了,而且开销的大小也保持稳定.4.2算法的具体设计1)建立两个索引表:Ability表和Possibility表根据优化的基本思想,我们要为数据集建立索引,首先要对一个数据点p∈D,定义它k-支配其它数据点的能力和成为k-支配skyline数据点可能性的形式描述.这里假设D所在的空间S上每个维度都具有相同的取值范围,并且取值都不为负数(实际应用中可Page5以通过对数据集的规范化预处理来满足这一条件).(1)根据k-支配skyline的定义,一个数据点只要在任意k个维度上取值优于另一个数据点,则k-支配的关系成立.如果一个点在k个维上取值很好,则它k-支配其它点的能力就会比较强.因此,一个点的k-支配能力直观上可以用它取值最优的k个维上的数值之和来表示.对于一个D中的数据点p∈D,关于参数k,它的k-支配能力用bestKDim(p,k)表示:其中maxdim(p,i)为数据点p所有维上取值第i大的值.式(1)直接对数据点取值最优的k个维求和,对于各个维上数值差别很大的数据,会造成数据点的某些维在总和中具有过高的权重,因此直接用k个维之和不能很好地反应数据点的k-支配能力.考虑下面的例子,表2中分别是数据点p和q的两个最优维度(k=2).如果使用式(1)来表示数据点的k-支配能力,则点q的k-支配能力强于点p.然而实际上,点p比点q具有更大可能支配其它数据点.如图1所示:在各自取值最优的2维空间上点p比点q具有更大的k-支配面积.图1的例子同样可以扩展到k大于2的情况,因此为了更客观地反应数据点的k-支配能力,应该用数据点最优的k个维的乘积来表示,将bestKDim(p,k)修改为考虑到当k的取值较大时,式(2)在算法的实际i=1实现中容易导致溢出.为了解决这一问题,我们可以引入对数函数ln(x),注意到有(假设对于任意的p和i,maxdim(p,i)>0)(ln∏k再考虑到取值为0的情况,在算法中对每个maxdim(p,i)先加1再求相应的对数函数值(根据前面的假设,每个维度的取值均非负).对于一个D中的数据点p∈D,关于参数k,它的k-支配能力最后表示为bestKDim(p,k)=∑k即bestKDim(p,k)为点p所有维中取值最大的k个维上数值加1关于对数函数ln(x)的值之和.表3中分别是数据点p和q的两个最优维度用式(1)与使用式(4)做度量的数值.可以看出,在直接求和的情况下q优于p,而在使用对数函数之后,p优于q.显然,从图1直观上我们知道p在大部分情况下比q具有更强的k-支配能力,在直接求和的情况下,q只要在一个维上有非常好的取值,就可以弥补另外一个维上的缺陷,这使得总和不能客观反映各个维的情况.而通过使用ln(x)之后的总和则可以防止单个维度权重过高,从而更全面地反映数据点的k-支配能力.pq根据式(4)对bestKDim的定义,为数据集中的每一个数据点p计算其bestKDim(p,k)值,然后根据该值由高到低建立所有数据点k-支配能力的索引Ability表.(2)一个数据点要成为k-支配skyline,必须保证不被数据集中任意其它数据点所k-支配.如果一个点在最差的k个维上的取值仍然比较好,则它很难被其它点所k-支配,有很大的可能成为k-支配skyline点.因此,一个数据点成为k-支配skyline点的可能性可以直观地用它取值最差的k个维上的数值之和来表示.与(1)同理,对于一个D中的数据点p∈D,关于参数k,它成为k-支配skyline数据点的能力用worstKDim(p,k)表示:Page6worstKDim(p,k)=∑k其中mindim(p,i)为数据点p所有维上取值第i小的值,即worstKDim(p,k)为点p所有维度中取值最小的k个维上数值加1关于对数函数ln(x)的值求和.根据worstKDim的定义,为数据集中的每个数据点p计算其worstKDim(p,k)值,然后根据该值由高到低建立所有数据点成为k-支配skyline可能性的索引Possibility表.2)根据索引进行计算在建立完数据集的两个索引之后,算法根据索引进行计算.按照Possibility表的索引顺序选择数据集中的点进行处理.对每个处理的数据点p,将它按照Ability表的索引顺序与其它数据点进行比较,一旦p在计算过程中被其它点k-支配,则立即将其淘汰.若点p与Ability表中的所有点比较后仍未被淘汰,则p成为k-支配skyline点,可以立即输出.接着算法再从Possibility表中取下一个点进行判断,如此迭代直到所有点都被处理过则算法结束.3)计算过程中的进一步优化对于数据集中每一个k-支配skyline点,算法必须将它与所有点都进行比较.这是因为只有与所有的数据点都进行比较之后,算法才能确定一个点属于k-支配skyline.然而,在Ability表中排在后面的那些点其k-支配能力很弱,对于在Possibility表中排名很前的数据点,将它们进行比较是多余的,算法应该尽可能减少这种无意义的比较.实际上在计算过程中依靠索引不仅可以提高对非结果数据点的淘汰效率,而且在判断一个k-支配skyline点时也可以减少不必要的比较.为此在算法中我们需要用到一个定理以实现进一步的优化,下面我们提出并证明这个定理.定理2.对于数据集D中的两个数据点p和q,关于参数k,如果满足worstKDim(p,k)bestKDim(q,k),则点p不会被点q所k-支配.证明.用反证法.假设数据集D中存在两个数据点p和q,关于参数k,满足worstKDim(p,k)bestKDim(q,k),又点qk-支配点p.由于点qk-支配点p,根据k-支配的定义,则存在S={s1,s2,…,sk}S,满足st∈S,有p.stq.st,且存在st∈S,使得p.st<q.st.由于对数函数ln(x)是(0,+)上的单调递增函数,因此,∑st∈Sln(p.st+1)<∑st∈S同时,根据worstKDim(p,k)的定义,有worst-KDim(p,k)∑st∈S的定义有∑st∈S以推出这与前面的假设worstKDim(p,k)bestKDim(q,k)矛盾,结论得证.根据以上定理,在算法的计算过程中,如果正在处理的数据点p的worstKDim值大于或等于Ability表中未与p比较的数据点的bestKDim值,则可以提前判定点p是k-支配skyline点,不需要继续与Ability表中的剩余点进行比较.4)算法的伪代码描述算法具体实现的伪代码描述如算法1.算法1.Index-Based(D,S,k).;算法输入包括3个参数,D代表查询的数据集,S代表数据集所在的空间,k代表查询k-支配skyline.;算法输出D中的k-支配skyline数据集R.1.foreverypointp∈Ddo2.computethebestKDim(p,k)andworstKDim(p,3.initializethemarkerforp,isDominated=false4.sortDinnon-ascendingorderofeachpoint’s5.sortDinnon-ascendingorderofeachpoint’s6.initializethesetofk-dominantskylinepointsR=7.initializethecursorforPossibility,cworst=18.while(cworst|D|)do9.letpbethepointpointedbyPossibility[cworst]10.if(p.isDominanted=false)then11.initializethecursorforAbility,cbest=112.while(cbest|D|)do13.letqbethepointpointedbyAbility[cbest]14.if(worstKDim(p,k)bestKDim(q,k))then15.breakoutoftheinnerwhile-loop16.if(pk-dominatesq)then17.q.isDominanted=true18.if(qk-dominatesp)then19.p.isDominated=truePage720.breakoutoftheinnerwhile-loop21.cbest=cbest+122.if(p.isDominanted=false)then23.insertpintoR24.cworst=cworst+125.returnR在算法的开始阶段,首先为每个数据集D中的数据点p∈D,根据参数k计算其worstKDim(p,k)和bestKDim(p,k)值,并为每个点初始化一个标识变量isDominated=false,用来记录该数据点是否已经被其它数据点所k-支配(步2~3).接着根据D中数据点的worstKDim(p,k)值,按照单调递增顺序来建立关于D中数据点成为k-支配skyline点能力的索引表Possibility[1…|D|].再根据所有点的bestKDim(p,k)值,按照单调递增顺序建立关于数据点k-支配能力的索引表Ability[1…|D|](步4~5).建立完索引后,算法按照Possibility[1…|D|]表的索引顺序选择要处理的数据点(步8~9).对每个处理的数据点p,按照Ability[1…|D|]表的索引顺序选择数据点q跟p进行比较,并根据比较的结果更新点p和点q的标识变量isDominated(步11~20).注意到在处理每个数据点p之前,算法都先判断p的标识isDominated,如果为true则可以直接忽略(步10).因为点p有可能在被Possibility[1…|D|]表索引之前就被Ability[1…|D|]表索引用来与被处理的数据点进行比较,算法通过isDominated值便可以尽可能避免重复的比较.此外,在处理一个数据点p时,如果对于Ability[1…|D|]中剩余的任意数据点q,worstKDim(p,k)值不小于bestKDim(q,k)值,则根据定理2,p可以被确认为k-支配skyline点,因此不需要再继续比较下去(步14~15).这一优化步骤可以进一步避免计算中多余的比较,提高算法性能.在每一轮循环结束后,算法可以直接判定该轮循环中所处理的数据点是否是k-支配的skyline点,因此能够在每一轮循环结束后立即返回已经计算的结果(步22~23),从而具有比SortedRetrieval算法更好的渐进性.5分析与实验5.1空间开销和渐进性分析(1)空间开销设数据集D的维数为d,包含的点数为n,设算法的参数为k.对于给定的数据集D和参数k,本文提出的Index-Based算法的空间开销是稳定的.它需要建立两个索引,所需要的空间大小与数据集的维数d无关,只受数据集点数n的影响,建立索引需要的空间开销为Ο(2n).此外,算法在执行过程中没有中间结果需要存储,因此算法总的空间复杂度也为Ο(2n).在高维空间中,随着维数d的增加,Index-Based算法相对于其它3种算法在空间复杂度上的优势会更加明显,显示出良好的可扩展性.并且在输入数据集大小超过可用内存空间的情况下,这一优势显得更为重要,能避免算法的大量IO操作.(2)渐进输出性Index-Based算法根据索引优先选择具有最大可能成为结果的数据点进行处理,因此在算法的执行初期就能返回大部分的执行结果,具有良好的渐进性.表4对4种算法在空间开销和渐进性这两个方面进行了总结.One-Scan不稳定Ο(dn)差没有Two-Scan不稳定Ο(dn)差没有SortRetrieval稳定Ο(dn)差差Index-Based稳定Ο(2n)好好5.2时间效率实验为了评估算法的时间效率,将本文提出的算法与现有的3种k-支配skyline算法进行对比.对4种算法均采用相同的编程语言和运行环境(表5).编程语言运行环境C++,用VC6.0开发和编译(1)实验参数说明实验中合成数据集所使用的数据生成器由香港中文大学提供,合成数据集需要用到如表6的参数.Distribution用于skyline算法测试的数据集一般有以下3种分布:正相关(correlated)、独立(independent)和反Page8相关(anti-correlated).在正相关的数据集中,各个维度的数值大小之间呈正相关的关系.在独立分布的数据集中,各个维度在取值上互不相关.在反相关数据集中,由于各维度的数值之间是反相关的关系,任意一个数据点在某个维度上数值很高,则会在另外一个维度上数值较低.在下面的实验中,将对4种算法在表6中各个参数变化下的性能进行比较.在默认的情况下,各个参数设置为d=15,Size=100000,Distribution=Independent,k=11.为了便于描述,对各个算法及其扩展算法,下文中将使用如下简称:OSA代表One-Scan算法,TSA代表Two-Scan算法,SRA代表SortedRetrieval算法,IBA代表IndexBased算法.(2)合成数据集测试结果图2是4种算法在参数k变化下的性能比较,从图中可以看出,OSA的性能总体上是最差的.TSA在参数k较小的情况下,性能比SRA更优,这是由于k越小则数据点形成k-支配关系的可能性越大,在第一轮扫描中TSA能够淘汰掉大部分的数据点.但是随着k的增长,TSA性能下降很快,在反相关数据集测试中当k=14时TSA的计算时间甚至超过了OSA.SRA的性能相对比较稳定.在4种算法中,IBA性能稳定,并且计算速度始终保持最快.图3是关于数据集维数变化的测试结果(其中10D6K表示d=10,k=6).OSA的性能虽然受维数增加的影响不大,但总体上仍是最差的.TSA受维数变化的影响最大,在维数d=20的独立分布和反相关分布数据集上TSA的时间开销甚至是两倍于OSA.SRA和IBA算法表现稳定,而IBA比SRA受维数增加的影响更小,在所有算法中是最优的.图4是在数据集大小Size变化下的算法性能比较,随着数据集规模的增加,OSA的性能严重下降.另外3种算法的表现是IBA最好、TSA其次,然后是SRA.这表明IBA算法比其它3种算法有更好的可扩展性.Page9图4在数据集大小Size变化下的算法性能(3)真实数据集测试结果NBA球员统计数据集①包含了NBA所有球员在各个赛季表现的统计,包括得分、篮板、抢断等等共17项技术统计,整个数据集共17801个数据点.对数据集的测试主要测试k-支配算法在不同的k值下的性能表现.从图5的实验结果看,在NBA统计数据集中,由于数据量不是很大,在参数k小于12的时候,k-支配skyline点非常少,不需要预计算的TSA速度是最快的.不过随着k的增加,TSA的时间开销迅速增加,很快超过了平均性能最差的OSA.而IBA性能非常稳定,在总体表现上明显优于另外3种算法.6结论k-支配skyline通过降低对于“支配”的定义,使得挖掘出来的k-支配skyline数据集具有更重要的意义和作用.然而由于k-支配skyline的特殊性质,传统的算法无法适应其计算要求,而现有根据k-支配skyline定义提出的算法在时间效率、空间复杂度和渐进性上都存在不足.本文提出一种基于索引的k-支配skyline算法,通过建立两个有效的索引,算法可以尽量减少数据点之间的比较次数,提高了时间效率;尽可能快地返回查询结果,具有良好的渐进性;只使用两个索引,并且不需要保存中间结果,节省了计算的空间开销.实验证明本文提出的算法比现有的3种算法有更好的性能.k-支配skyline研究方面还有很多改进和扩展的空间,如:能否通过建立更加复杂有效的索引,使得算法能够具有更好的效率和可扩展性.与此同时,子空间skyline的挖掘是skyline的另一个研究热点,而k-支配skyline算法的特殊性质使得其在子空间skyline计算上具有重要意义,如何将两者进行结合是一个值得深入探讨的问题.
