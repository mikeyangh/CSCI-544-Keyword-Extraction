Page1VMSPY:一种自动化的虚拟机客户机系统函数截获和控制方案余劲黄皓(南京大学软件新技术国家重点实验室南京210093)(南京大学计算机科学与技术系南京210093)摘要如何有效保证云平台虚拟机客户机系统安全运行是目前的热点研究问题,客户机系统函数的截获和控制方法是实现监控客户机系统的关键技术之一.已有基于操作系统内核接口的安全监控方案和基于虚拟化技术的虚拟机自省方案中所采用的函数截获和控制方法虽能满足安全监控的需求,但仍存在一些缺陷:函数截获动作容易被旁路;系统调用截获方式单一且局限,无法截获客户机应用程序内部函数;无法控制函数的执行流程;安全机制引入较大额外性能开销等.该文提出了一种基于虚拟化技术的自动化客户机系统函数截获和控制方案VMSPY.作者在VMM中实现模块的主要功能,通过反汇编引擎对客户机系统代码自动分析,动态生成并在合适位置插入经过设计的特权指令序列,实现对客户机操作系统的系统调用截获,在不受地址随机化技术的影响下对应用程序内部函数截获;在VMM中按策略自动模拟执行被截获函数的代码指令序列,实现对客户机系统调用函数和应用程序函数的执行流程控制;通过内存页权限机制保护在客户机系统中插入的特权指令序列,防止客户机系统对监控模块的影响;通过一种缓存机制,尽可能地减少额外性能开销.关键词虚拟化;函数截获;安全监控;执行流;云计算;XEN1引言近年来,随着计算机网络、虚拟化、分布式计算和数据存储等多种技术的进步,云计算作为多种技术混合发展的产物得到飞速发展,越来越多的企业将业务部署到云平台上.如何有效保证云平台虚拟机客户机的应用程序安全运行是目前的热点研究问题.客户机系统函数的截获和控制方法是实现监控客户机系统的关键技术之一,按实现方式主要分为两类:第一类是基于操作系统内核接口实现的强制访问控制、系统调用跟踪和各种应用层沙盒技术等.这类方案中所采用的系统函数截获方法虽然能满足监控功能的需求且部分方案性能优秀,但仍然存在如下问题:(1)默认操作系统内核是安全可信的,系统调用截获等安全监控功能依赖于操作系统内核提供的机制实现,安全监控功能会因为操作系统内核安全漏洞失效;(2)部分方案需要对操作系统代码进行修改,操作系统的兼容性差;第二类是基于虚拟化技术实现的虚拟机自省方案,这类方案中所使用的系统函数截获和控制方法很好的屏蔽了客户机系统对监控模块的影响,但仍存在如下问题:(1)客户机的系统调用截获方式单一,无法截获客户机应用程序的内部函数;函数的执行流程;(2)无法控制客户机系统调用或应用程序内部(3)部分方案需要在新创建虚拟域中实现安全监控模块,对被截获函数进行监控和分析.客户机系统函数截获路径较长,存在多次上下文切换,引入较大的额外性能开销.本文设计并实现了一种自动化的虚拟机客户机系统函数截获和控制方案VMSPY,主要特点如下:(1)在VMM中通过反汇编引擎动态对客户机操作系统内核或应用程序代码进行扫描分析,自动生成一段经过设计的陷入代码,自动查找合适的插入位置插入陷入代码,自动分析获得被截获函数的参数,实现对任意版本客户机操作系统的任意系统调用的截获,在不受地址随机化技术的影响下实现对应用程序内部函数的截获.(2)在VMM中按策略自动生成一段经过设计的客户机系统指令序列,可模拟被截获函数的正常执行流程和异常返回执行流程,实现对客户机系统调用函数和应用程序函数的执行流程控制.(3)在具有最高特权级的VMM中实现安全监控模块,并通过基于内存页权限机制保护在客户机系统中插入的陷入代码,安全监控模块和插入代码不受客户机操作系统内核安全漏洞的影响.(4)利用一种缓存机制,尽可能地减少额外性能开销.本文将在第2节详细介绍目前相关技术的研究工作现状;第3节详细说明我们方案的设计思想和各创新点的核心原理;第4节介绍我们已实现的原型系统;第5节阐述VMSPY在安全和性能上的实验评估;第6节介绍对现有系统的不足和对未来工作的展望.2相关工作基于操作系统内核接口或函数实现的安全监控Page3方案,按用途分为两类:第一类是基于操作系统内核接口实现的强制访问控制系统,例如SELinux①等.基于操作系统内核接口实现的应用程序系统调用跟踪模块,例如ptrace②和utrace③等.第二类是基于操作系统内核接口和内核函数实现的应用程序沙盒.例如:LXC④方案利用操作系统提供的接口构造一个类似“chroot”的轻量级虚拟化的程序执行环境,可控制运行其中应用程序对操作系统的各种资源访问,并达到几乎和原生程序相同的性能.Bryan等人[1]设计的Vx32方案将客户机实例放入一个LDT,利用另一个新建的LDT保护客户机实例.运行中通过段异常机制触发并动态翻译重写客户实例中的跳转指令,限制被监控客户实例代码的跳转范围.Bennet等人[2]设计的NativeClient方案为浏览器插件应用进程构建一个隔离的执行环境,通过模块间交互接口、浏览器交互接口和系统调用抽象接口等与操作系统交互,保证网页插件应用和操作系统之间的隔离.它内部沙盒采用与Vx32类似的思想实现,外部沙盒通过ptrace监控被监控进程的操作系统调用执行情况.Suman等人[3]设计的沙盒方案TxBox利用事物机制包装进程的系统调用,模拟系统调用的结果,监控系统调用执行情况,当发现进程异常后终止进程并关闭和删除进程相关资源,回滚恢复进程初始状态.上述两类方案中对系统调用或应用程序函数的截获均依赖于操作系统内核提供的接口或函数,默认操作系统内核是安全可信的,因此会因为操作系统内核的漏洞而导致安全监控失效.其中TxBox方案虽然性能较好,但是需要对客户机操作系统代码进行修改,兼容性较差.其中ptrace方案需要通过大量用户态和内核态之间的切换来实现对目标进程的监控事件响应,引入了极大的额外性能开销.utrace方案利用回调函数机制和统一的内核函数截获处理引擎在内核中重构了ptrace的底层功能实现,已获得了极大的性能提升,对单个系统调用单次截获仅有0.16μs的额外性能开销[4].式可分为两类:基于虚拟化技术的虚拟机自省方案,按实现方第一类在新建的独立的虚拟域中构建客户机系统监控程序,例如:Suman等人[3]提出的在独立虚拟域中构建的客户机指令检测系统方案,Tamberi等人[5]提出的在独立虚拟域中构建监控系统监控并保护客户机操作系统用户态进程的方案PsyTrace,Dolan-Gavitt等人[6]提出的利用动态切片技术在独立虚拟域中重构客户机操作系统管理工具的方案Virtuoso,Jones等人[7]提出的在独立虚拟域中构建检测客户机操作系统恶意隐藏进程系统方案Lycosid,Srinivasan等人[8]提出的将客户机操作系统中可疑进程动态迁移到独立的虚拟域中,并分析其行为的方案ProcessOut-Grafting,Zou等人[9]提出的在独立虚拟域中构建的基于事件通知的客户机监控方案,Wu等人[10]提出的在独立虚拟域中构建基于特权指令钩子技术的客户机系统监控方案EagleEye,Hizver等人[11]提出的在独立虚拟域中构建的基于客户机内存扫描技术的客户机监控系统等.上述方案需要额外构建一个独立虚拟域作为监控程序或客户机应用程序副本的运行环境,虽然在一定程度上可轻松准确的重现出客户机系统中被截获函数的执行环境,获得函数执行语义.但新创建的独立虚拟域增加了额外的系统资源开销.对于客户机系统中每一个函数的截获动作都需要通过事件通道或自定义内部接口,经VMM返回到新创建的虚拟域中分析,客户机系统、虚拟机监控器VMM和新创建虚拟域之间存在大量上下文切换,增加了系统额外的性能开销.其中EagleEye方案所采用的函数截获方法与本方案类似,但本文所述方案在陷入代码自动化生成与插入、被截获函数参数分析、客户机指令模拟、客户机函数执行流程控制等几方面提出更灵活的思想,本文所述方案在VMM中实现主要的安全功能.第二类在VMM中构建客户机系统监控程序,例如:Monirul等人[12]提出的通过客户机系统中构建监控模块监控客户机系统,再在VMM中构建保护模块保护客户机系统中的监控模块的双层监控方案SIM,Xiong等人[13]提出的在VMM中构建客户机操作系统的系统调用的监控方案,Li等人[14]提出的利用在客户机操作系统内核中构建信息获取模块获取客户机系统运行语义,在VMM中构建监控模块监控客户机操作系统系统调用和寄存器的双层①②③④Page4监控方案VMInsight,Dinaburg等人[15]提出的在VMM中构建对客户机操作系统的系统调用、上下文切换和内存访问的监控方案Ether等.其中文献[12,14]中的方案需要在客户机系统内核中增加额外的代码来实现对客户机系统函数的截获和客户机当前执行上下文信息的获取,黑客可以通过分析等方法对监控模块进行针对性的破坏使安全监控失效.其中文献[12-13,15]中的方案通过设置SYSENTER_EIP_MSR中的异常值触发vmexit实现对系统调用的截获,此类方法对通过int80或其他触发机制实现的系统调用无法兼容.并且上述所有的方案都无法实现对任意版本客户机操作系统的任意系统调用或应用程序内部函数的截获,也无法实现对被监控函数执行流程的控制.3系统设计3.1函数截获及执行流程控制硬件虚拟化技术将传统操作系统的特权级ring0到ring3又划分为root和non-root两个级别,当客户机系统执行一些敏感指令或虚拟化相关指令时,会触发non-root到root的切换.通常在root级别中运行VMM,在non-root级别中运行客户机系统.从安全监控的角度来看,硬件虚拟化技术为我们提供了一个隔离且安全的监控代码运行环境,如果我们能在VMM中实现对客户机系统函数的截获和控制,将最大化的屏蔽客户机操作系统对截获和控制功能的影响.如何让客户机操作系统或应用程序的函数执行时陷入到VMM中是需要解决的首要任务.以Intel的VT-x[16]技术为例,其提供了VMCS结构用于保存客户机操作系统和VMM切换时的上下文信息,以及虚拟化相关的配置信息.其定义了CPUID、GETSEC、INVD、XSETBV和VMLUNCH等指令执行为无条件事件,VMCS中配置的I/O访问、中断、MSR寄存器访问等为有条件事件.当无条件事件和有条件事件发生时,客户机系统会触发VMexit陷入到VMM中.经过分析我们可以在应用程序或操作系统函数代码中任意位置插入特定的敏感指令,使得客户机应用程序或操作系统内核按照我们的需要触发VMexit陷入到VMM中.Vt-x定义的敏感指令都有具体的功能,我们选择的敏感指令必须在内核态和用户态均能被调用,其原有功能必须相对简单和独立.我们最终选择cpuid作为陷入动作触发的敏感指令,陷入机制如图1所示.cpuid原本的功能是为了获取cpu信息而设计的指令,输入参数保存在eax寄存器中,输出参数保存在ebx、ecx和edx中.我们在eax中填充特殊的自定义传入参数来区别正常的cpuid事件处理、截获函数的cpuid事件处理以及被截获函数类型信息,并且在VMM中原有cpuid指令处理代码流程中增加相应的处理代码.例如:在eax中存入54321代表截获系统调用sys_open函数的事件发生.按照上面的要求陷入代码需要“mov54321,%eax”和“cpuid”两条语句总共7个字节大小.如果在插入陷入代码位置的函数代码执行上下文中eax的值是有意义的,即eax的值会被后续代码使用,我们还需要在陷入代码中增加保存当前eax值的语句.为满足这个要求我们又需要从ebx、ecx或edx寄存器中选择一个在当前客户机函数执行上下文中无意义的寄存器来临时保存当前的eax值.在陷入VMM执行完控制功能后增加恢复eax原有值的处理代码.例如:edx中的值在当前的函数代码上下文中没有意义,我们选择edx作为缓存寄存器临时保存eax的值,陷入代码扩展为“mov,%eax,%edx”、“mov54321,%eax”和“cupid”3条语句总共9个字节大小.如果函数代码中没有符合7个字节或9个字节大小的陷入代码插入位置,我们通过在陷入代码中增加nop指令来调整陷入代码的大小,陷入代码的汇编代码和机器码对照如表1所示.Page523序号汇编代码1mov54321,%eaxcpuidmov%edx,%eaxmov54321,%eaxcpuidnopmov%edx,%eaxmov54321,%eaxcpuid我们通过在VMM中移植并修改了开源的udis86①反汇编引擎实现自动化客户机代码分析功能.反汇编引擎扫描并完成对指令前缀、指令、操作数等的识别.完成基本指令识别以后,我们的分析代码对被识别指令语句进行进一步的分析,完成自动生成陷入代码、查找合适插入位置和插入陷入代码等功能.算法的基本判断条件判断过程中,我们宏观上认为从函数入口开始到被陷入代码覆盖的客户机代码结束为止的范围里,如果出现对eax~edx寄存器的引用行为,那么eax~edx就是有意义的.具体根据不同指令的特点,通过如下两条简单规则区别一些细节:(1)在被陷入代码覆盖的客户机代码指令语句范围里,除pop指令以外所有只有一个操作数图2eax~edx是否有意义判断算法流程指令的操作数、逻辑判断指令的两个操作数和其他所有两个操作数指令的源操作数中出现eax~edx寄存器,则eax~edx有意义;(2)在从函数入口地址到陷入代码插入之前的客户机代码指令语句范围里,pop指令的操作数和除逻辑判断指令以外所有有两个操作数指令的目的操作数出现eax~edx寄存器,则eax~edx有意义.此算法目前相对简陋,仅在本论文方案的实验上可用,有待后期完善,算法流程如图2所示.我们事先在VMM中的监控程序中准备好如下18种构成陷入代码基本指令语句的机器码:(1)mov54321,%eax;(2)mov54322,%eax;(3)mov54323,%eax;(4)mov54324,%eax;(5)mov54325,%eax;(6)mov54326,%eax;(7)mov54327,%eax;(8)mov54328,%eax;(9)mov54329,%eax;(10)mov54330,%eax;(11)mov54331,%eax;(12)mov54332,%eax;(13)mov54333,%eax;(14)mov%ebx,%eax;(15)mov%ecx,%eax;(16)mov%edx,%eax;(17)cpuid;(18)nop.算法按需求组合出陷入代码.构建陷入代码和查找陷入代码位置的基本算法判断条件是:(1)被覆盖的客户机指令语句VMM能够模拟;(2)客户机被截获①Udis86.http://sourceforge.net/projects/udis86/,2015,Page6函数代码中存在大小最小为7个字节或9个字节的多条完整的指令语句;(3)若当前客户机从函数入口地址开始扫描,存在7个字节大小指令语句中,eax的值是无意义的,按照7个字节构建陷入代码,插入位置是当前扫描结束位置;(4)若当前客户机从函数入口地址开始7个字节范围内执行指令上下文中,eax的值是有意义的,从函数入口地址开始以9个字节为最小单位扫描,确保ebx、ecx和edx中有一个是无意义的,并按照9个字节或者更多字节构建陷入代码,超过9个字节的部分用nop指令填充,插入位置是当前扫描结束位置;(5)若当前指令上下文中eax~edx均有意义,则从当前位置按照算法判断条件开始一次新的扫描,直到找到合适的插入位置为止.扫描过程中我们通过一个数据结构数组记录被陷入代码覆盖的客户机指令语句块,待陷入VMM以后识别并模拟客户机指令时使用.在算法基本判断条件执行之前,我们给算法增加了一系列可自定义的额外判断条件,用于处理特别的情况,例如:希望将陷入代码插入到某个内核函数调用以后的位置,即从函数入口地址偏移一段距离以后再开始基本算法条件分析判断.我们通过查找客户机代码中内核函数对应的call指令语句调用位置,并从下一条指令语句开始进行基本条件判断分析的方法实现,算法流程如图3所示.函数被拦截并陷入到VMM中执行完控制功能以后,为保证当从VMM切换回客户机以后应用程序能继续正常运行,我们需要在VMM中模拟执行被陷入代码覆盖的原有函数指令语句.在陷入VMM后通过硬件提供的VMCS结构(以intel平台为例)获得vm-exit事件发生前的客户机寄存器信息,并在VMM中模拟执行被覆盖的函数代码并填充VMCS结构中受影响的寄存器,最后返回客户机系统,完成整个模拟执行的过程.能模拟的指令类型越多,我们就越容易找到合适的陷入代码插入位置.由于x86的指令系统复杂且指令类型众多,我们这里仅实现12类在VMM中相对容易实现模拟且在客户机系统代码函数中常见的主要指令语句.经过分析利用模拟这12类指令语句的组合,我们已经可以在客户机系统的系统调用或内部函数中找到合适的陷入代码插入位置,表2详细介绍了这几种类型语句和与其匹配的在VMM中模拟执行的等价操作.对于表中未列出的多媒体指令、涉及IO操作的指令的模拟相对困难,但在经过仔细分析和设计后理论上都可以在VMM中实现模拟,未来我们将完善这部分工作.序号1客户机系统函数mov%eax,%ebx(mov指令的变种指令movsb、movsw等的模拟类似)2cmp%eax,%ebx3and%eax,%ebx(xor等逻辑计算指令的模拟类似)sub0x8,%esp(add等算术指令语句4操作类似)5jmp0x12345678(ja,jbe,jz等变种指令的模拟类似,仅需在执行前加上对sf,zf或of等标志位的判断)6mov%eax,0x123456787push%ebp8pop%ebp9lds(0x12345678),%eax(les指令的模拟类似,只是其中地址+4所存的值赋给es)10lea(0x12345678),%eaxcall0x12345678(callreg等语句的模11拟采用类似步骤)12retPage7图3陷入代码自动生成及插入位置扫描算法流程在VMM中除了可以模拟被覆盖的函数指令正常执行流程以外,我们还可以通过构建并模拟执行其他指令序列的方式改变客户机系统函数的原有执行流程.例如:查找被截获函数调用ret指令地址0x12345678,在VMM中模拟执行“jmp0x12345678”实现被截获函数的直接返回,或者构造eax寄存器的值,直接在VMM中模拟执行ret指令,实现自定义的被截获函数异常返回.甚至可以通过详细分析和巧妙设计,使拦截函数执行其他高级功能以后再返回等动作.如何准确获得被截获函数在客户机系统中当前的执行语义是实现高级监控功能的基础.函数的执行语义简单来说概括为3点:(1)函数执行了什么功能;(2)函数的调用者是谁;(3)函数的传入参数是什么.函数执行的功能可通过函数名或分析代码事先确认.函数的调用者一般都是指具体的进程.在VMM中通过硬件提供的VMCS结构,可获得函数被截获时客户机系统所有寄存器的值,并可访问客Page8户机系统所有的地址空间.通过放在内核栈中的thread_info结构得到task_struct结构,通过task_struct结构获得进程号、进程名等所有调用者的信息.函数的传入参数数量通过对函数代码分析事先确认.函数的传递方法一般是通过寄存器传递、约定存储单元传递、利用CALL后续区域传递和堆栈传递4种传递方法,其中第1种和第4种是最常用的方法,本方案暂时只对这两种方法进行说明.函数通过寄存器传递参数所使用寄存器一般是从eax开始到edx结束,通常的函数入口处会有一个或连续的几个push指令,保存ebp、edi和esi的值,后面紧接着一个或几个mov指令,如果mov指令的源操作数是eax~edx寄存器,那么可确认寄存器内存储的是通过寄存器传递进来的参数.向后扫描会出现一句sub指令操作esp,这句是为了给函数本地局部变量预留空间,再向后扫描如果发现有mov指令并且源操作数是对esp加上一个偏移,例如:0x10(esp),则可确认此动作是将栈上存储的函数参数传递给寄存器.上述规则只是按照通常的规律总结的,可完成对目前方案中已实现截获的系统调用或函数的参数获取,并没包含所有的情况,完备的判断条件将在未来的工作中完成.在本方案中由反汇编引擎在生成并插入陷入代码阶段自动完成函数参数地址的获取和保存,待被截获函数陷入VMM后,通过之前保存的地址直接获得传入参数,详细流程如图4所示.3.2系统调用截获和控制按照前面章节介绍的方法,结合具体的操作系统实现,我们实现了对系统调用函数的截获和控制,此种方案不受客户机操作系统版本影响,可对任意系统调用截获和控制.以Linux系统中的open系统调用为例,我们尝试拦截open系统调用对应的do_sys_open内核函数,主要有4个关键问题需要解决:(1)获得内核函数的虚拟地址.现代Linux操作系统中,内核代码是被映射到高端地址区域并常驻内存的,我们可通过etc目录下的System.map文件或者proc目录下的kallsyms文件中查找,或者编写模块通过kallsyms_look_up函数查找到需要截获的内核函数的地址.(2)找到合适的陷入代码插入位置.通过VMM中的反汇编引擎对客户机内核反汇编得到汇编代码,反汇编引擎自动扫描代码找到安装陷入代码的合适位置.在do_sys_open函数代码中,反汇编引擎算法选择从函数入口开始偏移10个字节的位置,选择这里作为陷入代码的插入位置的原因除了前面所介绍的扫描算法基本判断条件以外,又加入了一个附加条件,即从第一个call指令后作为扫描的起点.增加这个条件是为了找在do_sys_open函数中调用的getname内核函数位置,把陷入代码插入到getname调用后面.这样做的目的是内核函数getname把do_sys_open函数传入的文件名参数从用户态拷贝到内核地址空间,我们在VMM中获取系统调用参数时,无需再模拟客户机系统执行拷贝动作.(3)获得函数传入参数信息.反汇编引擎通过对客户机代码分析,记录函数参数传入方式和存储参数的寄存器名称或栈偏移.(4)插入陷入代码.在客户机操作系统初始化阶段或运行阶段,通过VMM中的处理代码直接修改客户机系统内存中指定地址区间的内容,插入陷入代码.(5)获取被监控系统调用的运行上下文信息.在VMM中我们通过对esp的后12位(启用4K大小内核栈)或者13位(启用8K大小内核栈)清零的方式找到应用程序内核栈中thread_info结构的指针,根据偏移量找到指向task_struct结构的task指Page9针,再根据结构中各成员的偏移量得到进程名、进程号等信息,通过之前记录的寄存器名或栈偏移获得函数传入参数.总体来说系统调用的监控流程分为陷入代码的安装和运行时监控两个部分,详细完整的整体流程如图5所示.图5系统调用陷入代码安装及运行时被截获和控制流程3.3应用程序函数截获和控制结合前面章节介绍方法,结合具体的应用程序实现,我们实现了对应用程序调用的内部函数的截获和控制方案,此种方案将不受地址随机化技术的影响,可对任意应用程序的任意函数截获和控制.以linux系统为例,要完成对应用程序函数的监控,有4个关键问题需要解决:(1)判断当前加载的进程是否是我们监控的进程.程序加载阶段通过上一节介绍的方法对exec系统调用进行监控,通过其第一个参数得到当前加载的进程名称,确定当前加载的进程是否是我们期望监控的进程.(2)获得被监控应用程序函数的映射地址.应用程序是elf格式的,在load_elf_binary函数执行流程中调用的内核函数elf_map函数完成应用程序的代码段和数据段到虚拟内存的文件映射,start_thread函数实现启动进程.一般情况下通过对应用程序反汇编获取被监控内部函数的虚拟地址和函数的名称.如果客户机系统启用应用程序地址随机化(ALSR)特性,每次加载时应用程序基址、共享库基址、代码段、数据段、栈、堆等的映射地址会改变,在这种情况下需要通过额外的两个步骤来获得其内部函数经过随机化后的准确内存地址:①通过反汇编引擎分析应用程序,计算出被监控函数在代码段中的偏移;②通过上一节介绍的方法,在load_elf_binary函数执行路径中调用完elf_map的位置上设置陷入代码,陷入VMM通过elf_map的返回值获取进程随机化后的映射地址.(3)插入陷入代码.由于操作系统是通过缺页的形式来为应用程序分配实际的物理内存的,所以我们需要等应用程序运行以后,在操作系统为其实际分配物理页并写入代码段内容以后,在应用程序进程对应的内存中插入陷入代码.在启用内存虚拟化技术的系统中,以影子页表为例,最终的物理页创建会通过在VMM中的影子缺页处理函数完成,通过在影子缺页处理函数sh_page_fault中增加相关处理代码,来捕捉实际物理页分配和写入代码段内容这个时机,并通过反汇编引擎生成并插入陷入代码.(4)获得函数传入参数信息.反汇编引擎通过对客户机代码分析,记录函数参数传入方式和存储参数的寄存器名称或栈偏移.(5)获取被监控应用程序函数的运行上下文信息.当应用程序被陷入代码陷入到VMM中以后,通过之前记录的寄存器名或栈偏移获得函数传入参数.总的来说,应用程序函数的监控分为:应用程序陷入代码安装和运行时监控两个部分,详细流程如图6(a)和图6(b)所示.3.4关键数据保护我们的监控模块主要由在虚拟机管理系统中的静态策略和策略配置工具、VMM中的监控模块主体代码和插入在客户机系统中的陷入代码三部分组成.我们默认VMM和虚拟机管理系统是安全的,Page10图6应用程序函数陷入代码安装及运行时被截获控制流程本方案将无法抵御利用VMM或虚拟机管理系统漏洞对平台攻击的场景,在今后的工作中计划完善这部分工作.下面以intel的cpu、xen虚拟化平台和影子页表内存虚拟化技术为例说明对这三部分的保护方案.构建的监控模块的主体代码是属于VMM的一部分,对上层客户机系统来说是不可见的,唯一与客户机系统交互的接口是由cpu硬件控制的vm_exit和vm_entry动作,因此在客户机系统中的恶意程序很难直接破坏和影响监控模块的主体代码.在客户机操作系统内核或应用程序代码段插入的陷入代码是监控模块能够正常工作的关键.修改代码段的动作是在VMM中完成的,客户机系统中的恶意程序很难直接破坏或影响这个流程.陷入代码被安装在应用程序进程的代码段或内核代码段,这个区域客户机操作系统默认设置为只读,一旦客户机系统中的恶意程序尝试修改这些页将会触发影子缺页并通过vm_exit陷入VMM,我们在VMM中的影子缺页处理函数中增加一些处理代码,实现捕捉并禁止这种修改陷入代码的动作,保护我们插入的陷入代码不被客户机系统中的恶意程序破坏.即使恶意软件发现陷入代码插入客户机系统的位Page11置,它也无法轻易旁路我们的监控.监控模块的策略配置工具和静态策略放置在虚拟机管理系统中,通常在客户机系统启动时策略就已配置好,在运行过程中可以通过策略管理接口进行修改,管理接口对客户机系统也是透明的,客户机系统中的恶意程序无法直接干预这个动作,整体关键数据保护架构如图7所示.3.5性能优化外性能开销主要包括两个方面:经过分析,本方案中因为安全监控而引入的额(1)我们对客户机操作系统内核和应用程序代码段设置了许多的陷入点,每一次陷入和恢复将会发生一次客户机系统和VMM之间的上下文切换;(2)在VMM中需要模拟执行被陷入代码覆盖的指令语句.针对第一点,监控程序自身隔离的核心思想是将程序主体放在VMM中,我们无法避免因上下文切换带来的额外性能开销.针对第二点,在VMM中模拟执行函数指令语句时,主要产生的性能损失是部分模拟执行的指令语句需要通过内存虚拟化机制对客户机内存地址进行额外的寻址处理.以Xen系统下的影子页表技术为例,影子页表保存客户机虚拟地址(gva)到主机物理地址(hpa)的映射,p2m表来保存客户机物理地址(gpa)到主机物理地址(hpa)的映射关系,并通过对影子缺页的方式完成客户机页表和影子页表间的同步.我们在VMM中对客户机内存地址的寻址处理一般要经过如下几个步骤:户机页框号;(1)通过影子页表逐层遍历客户机页表获得客(2)通过p2m表找到客户机页框号对应的物理页;(3)将物理页映射到VMM的空间;(4)对映射好的地址进行操作;(5)解除物理页的映射.如果需要对客户机系统的一个大块内存区域进行读写操作,需要以物理页为单位,重复上述过程.经过分析发现,在客户机系统运行时,每当被插入陷入代码的函数执行时,会不停地陷入到VMM中的监控模块被我们监控.如果模拟执行的指令中有需要对客户机系统内存地址做寻址操作的动作,每次陷入总是做重复的寻址操作.我们通过一种缓存机制来降低这部分性能损失,在第一次陷入VMM时做客户机地址内存地址寻址处理步骤中的第(1),(2),(3)步,并将映射完成的结果保存到缓存中,等后续陷入VMM需要对同一个客户机内存地址做寻址操作时,直接使用之前缓存的结果执行第(4)步,跳过前面的3个步骤,通过减少对相同客户机虚拟地址做重复寻址处理的方式达到性能优化的目的.最后在清理监控策略的时候执行第(5)步,删除缓存中的映射关系.整体流程如图8(a)和图8(b)所示.4系统实现我们在Ubuntu12.04LTS64位版本操作系统平台上结合xen-4.3.1虚拟机平台软件系统实现了我们的原型系统,客户机操作系统为CentOS5.8.目前的原型系统实现了对自己编写的用户态程序test_open调用的openC库函数以及客户机系统的sys_open、sys_close、sys_read、sys_write、sys_link、sys_unlink、sys_rename、sys_lseek、sys_mkdir和sys_rmdir文件系统相关系统调用的截获和执行流程控制.同时通过内存页的权限机制结合VMM中的监控模块对陷入代码进行保护.系统分为静态策略文件、管理配置工具、策略解析模块和监控模块.监控模块中的反汇编引擎通过移植和修改udis86实现,管理配置工具以控制台形式运行于domain0的用户态,它将用户配置的xml格式的策略文件初步解析后通过ioctl传递给运行在domain0内核态的策略解析模块,策略解析模块通过hypercall将策略传递给VMM中的监控模块.策略监控模块对策略进行进一步解析,并完成策略的配置和监控环境的准备工作,监控模块收到上层Page12图8客户机虚拟地址寻址优化前后流程对比配置的策略后,通过反汇编引擎自动生成并插入陷入代码,然后等待函数被调用时陷入VMM执行控制功能.整体系统架构图如图9所示.5系统实验5.1实验环境我们的实验环境由物理主机、经过修改的xen系统、linux客户机系统和监控工具软件组成.物理主机配置为2.2GHzIntelCoreTMi7-2720QM8核处理器,8GB内存,1TB硬盘,软件系统是基于xen-4.3.1修改的虚拟机监控器.特权虚拟域Domain0的配置为2.2Gx8CPU和8GB内存,运行的软件系统是内核版本为Linux3.8.0-29-generic的64位ubuntu操作系统.DomainU的配置为2.2Gx1CPU和512MB内存,运行的软件系统是内核版本为Linux2.6.32.1的32位CentOS5.8操作系统.我们监控程序的管理配置工具运行在Domain0的用户态,策略解析模块运行在Domian0的内核中,监控模块整合在xen的VMM中.5.2功能实验我们分别对我们编写的应用程序test_open中的用户态函数open和内核系统调用sys_open、sys_close、sys_read、sys_write、sys_link、sys_unlink、sys_rename、sys_lseek、sys_mkdir和sys_rmdir等系统调用设置了监控点,实时截获其执行情况.test_open的功能是计算调用一次open等函数所需要的时间并将结果打印在屏幕上.我们通过策略设置禁止C库函数open和系统调用sys_open正常返回,如图10(a)所示,test_open程序正常执行时会打印出统计时间的信息,然后进入while循环等待退出.如图10(b)所示如果策略设为禁止执行open时,test_open程序的用户态open函数被监控模块控Page13制,直接跳转到程序末尾的while循环中,不执行中间的过程,因此没有打印统计信息.如图10(c)所示,test_open通过系统调用执行的内核函数sys_open被监控模块控制,跳转到sys_open返回的位置并返回错误值,使得用户态的open函数显示无法打开指定文件.图10test_open测试程序正常运行和函数被截获后运行效果如图11(a)所示,xen打印了我们在应用程序test_open执行过程中,xen中反汇编引擎自动生成并插入陷入代码的流程.如图11(b)所示,xen打印了截获并控制用户态open函数的流程.如图11(c)所示,xen打印了我们在应用程序test_open执行过程中,截获并控制系统调用open函数的流程.如图11(d)所示,我们设置允许文件系统相关系统调用被调用,xen打印了截获并控制客户机文件系统图11自动插入陷入代码及函数被监控运行效果Page14相关系统调用的流程.如图12(a)所示,正常情况下test_open的代码段加载到0x0804800.如图12(b)所示,我们在编译test_open时加上-fPIE-pie选项①,开启应用程序地址随机化功能后,每次启动应用程序时,程序代码段将会被映射到不同的虚拟地址.图12test_open测试程序启用地址随机化后前后内存布局在开启地址随机化功能后,我们依然可以成功劫持test_open中的用户态open函数并跳转到程序末尾的while循环中,不执行中间的过程,效果和图7(b)一样.如图13所示,xen打印了我们在开启地图13启用地址随机化后test_open的用户态open址随机化后,监控test_open的用户态open函数的流程.5.3安全实验我们的监控主体代码在VMM中实现,即使黑客已经获得了客户机系统的控制权也无法直接对监控功能主体代码进行破坏.黑客唯一有可能破坏的是我们插入客户机系统中的陷入代码,因此我们的安全实验主要证明当黑客获得客户机系统控制权后,无法破坏在客户机系统中插入的陷入代码.如图14所示,我们有针对性的编写了rootkit并装载到客户机系统的内核中,该rootkit会尝试修改我们在客户机系统内核代码段中插入的陷入代码序列.VMM捕捉并禁止了rootkit这个修改行为,在客户机系统中的rootkit无法破坏陷入代码,无法旁路我们的监控功能.5.4性能实验第1个实验我们通过在客户机系统用户态运行一个自己编写的程序test_open,该程序会调用open等函数并计算出调用函数的总时间.test_open在客户机原生系统、VMSPY开启监控客户机open系统调用关闭性能优化、VMSPY同时开启监控客户机open系统调用和性能优化、VMSPY开启监控test_open的C库函数open关闭性能优化和VMSPY同时开启监控test_open的C库函数open和性能优化5种场景下测量单次调用open的额外负载.如图15所示,test_open调用1次open,监控open系统调用时,VMSPY开启性能优化的总时间比不开启性能优化缩短了4191ns,性能提高了40%(场景3和场景2相比).VMSPY开启性能优化情况下和原生系统相比多用了3515ns,性能损失大约为35%(场景3和场景1相比).VMSPY监控open用户态函数时开启性能优化监控用户态open函数的总时间比不开启性能优化优化缩短了2585ns,性①Position-Independent-Executable.https://gcc.gnu.org/online-Page15能提升了26%(场景5和场景4相比).VMSPY开启性能优化情况下和原生系统相比多用了384ns,性能损失为3%(场景5和场景1相比).第2个实验我们设置VMSPY和基于utrace实现的标准linux监控软件systemtap①对客户机系统所有进程的sys_open、sys_close、sys_read、sys_write、sys_link、sys_unlink、sys_rename、sys_lseek、sys_mkdir和sys_rmdir文件系统相关系统调监控.在客户机原生系统、VMSPY开启监控关闭性能优化、VMSPY同时开启监控和性能优化、systemtap开启监控4种场景下,执行dd、编译内核和执行unixbench这3个应用,分别测试IO性能、随机调用系统调用性能和系统调用负载性能.如图16(a)所示,在4种场景下分别执行timeddif=/dev/hdaof=/testbs=4kcount=100000命令,计录读写4K内容100000次的总时间.VMSPY开启性能优化比不开启性能优化缩短了2.6s,性能提高了16%(场景3和场景2相比).VMSPY开启性能优化比原生系统多用了5s,性能损失63%(场景3和场景1相比).systemtap开启监控比原生系统多用了0.2s,性能损失为2%(场景4和场景1相比).可见我们的性能优化是有效果的但是和systemtap相比还存在差距.如图16(b)所示,在4种场景下执行“timemakebzImage”命令,计算客户机编译内核的总时间.VMSPY开启性能优化比不开启性能优化缩短了10s,性能提高了2.8%(场景3和场景2相比).VMSPY开启性能优化比原生系统多用了37s,性能损失11%(场景3和场景1相比).systemtap开启监控比原生系统多用了17s,性能损失为2.2%(场景4和场景1相比).可见我们的性能优化是有图16IO读写、编译内核及Unixbench的性能测试效果的,追平了systemtap的性能.如图16(c)所示,在4种场景下运行unix-bench,我们截取其中SystemCallOverhead的测试结果,unixbench执行的测试内容是在10s内执行7个样本,每个样本不停地调用getpid系统调用,最终统计在1s内调用系统调用的次数.VMSPY开启性能优化比不开启性能优化每秒增加了16899次调用,性能提高了3.5%(场景3和场景2相比).①Systemtap.https://sourceware.org/systemtap/,2015,8,Page16VMSPY开启性能优化比原生系统每秒少453867次调用,性能损失48%(场景3和场景1相比).systemtap开启监控比原生系统每秒少了311650次调用,性能损失为33%(场景4和场景1相比).可见我们的性能优化是有效果的但是和systemtap相比还存在差距.6结束语本文提出了一种自动化的虚拟机客户机系统函数截获和控制方案VMSPY.将其应用到基于虚拟化技术的云计算平台上可在一定程度上解决传统监控方案带来的安全性、兼容性和性能问题,解决基于虚拟化自省技术方案的函数截获不灵活、额外资源和性能开销高的问题.方案中所采用的函数截获和控制方法仅实现了针对文件系统相关系统调用的截获和控制,经过进一步的工作可快速实现针对进程间通信、网络通信和内存访问等其他系统调用的截获和控制.方案中基于反汇编引擎实现的自动指令识别和模拟功能还不能识别和模拟所有的客户机指令,需要经过更多的研发工作后才可支持.方案中主体功能工作在VMM中,依然存在准确获取客户机系统的语义问题,如果需要实现复杂的监控功能还有很多的工作要做.在性能方面我们虽然通过缓存机制提升了部分性能,但是目前的架构仍然会因为陷入点的增加,导致性能额外开销呈线性递增,并且与systemtap等监控软件相比还存在性能差距.未来将考虑按监控对象和监控类型统一处理陷入行为,尽可能地减少陷入次数,以获得更好的性能.方案中默认虚拟机管理系统和VMM是安全的,未来将继续研究针对这两部分攻击的内容,提高方案的整体安全性.目前的监控程序是基于xen虚拟化平台和linux客户机操作系统,仅实现原理性功能验证的原形系统,未来可按照需求重新设计开发出适用于多种不同操作系统和不同虚拟化平台,具备更多复杂安全功能的实用化监控系统.致谢本文作者感谢所有的审稿者!
