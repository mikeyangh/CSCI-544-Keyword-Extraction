Page1基于稀有数据扑捉的路径覆盖测试数据进化生成方法张岩1),2)巩敦卫1)1)(中国矿业大学信息与电气工程学院江苏徐州221116)2)(牡丹江师范学院工学院黑龙江牡丹江157012)摘要采用遗传算法自动生成路径覆盖的测试数据是软件测试自动化研究的热点.现有方法设计适应值函数时,对穿越难以覆盖节点的稀有数据保护不够理想,因而影响测试数据生成效率的提高.文中在测试数据进化生成时动态扑捉稀有数据,通过统计每代种群中目标路径各节点被穿越的个体数量,得到个体对生成穿越目标路径测试数据的贡献,以此作为权重调整个体的适应值,使得稀有数据的适应值增加,以便在后续进化中得到保留,从而提高测试数据生成的效率.基准程序和工业用例的测试结果表明,与传统方法及随机法比较,文中方法生成覆盖路径的测试数据效率较高.关键词软件测试;路径覆盖;遗传算法;稀有数据;适应值调整1引言软件测试能有效保障软件的质量,按照测试过程的不同,分为静态测试和动态测试[1],都是为了发现程序代码可能存在的缺陷,但前者不执行程序代码,而后者则基于测试数据运行程序代码,测试数据的自动生成是该类测试的关键.按照生成测试数据依据的信息来源,动态测试又被分为黑盒测试、白盒测试以及二者融合的测试.路径覆盖测试属于白盒测试,它要求在测试过程中尽可能覆盖程序所有能够达到的路径.单锦辉等人认为,许多软件测试问题都可以归结为路径覆盖测试数据生成问题[2].该问题描述为:对于被测程序的任意一条目标路径,在程序的输入数据范围中寻找一个测试数据,保证以该数据作为输入,所经过的路径为目标路径.自动求解上述问题将有效缩短软件测试的时间,提高测试效率,节约软件开发的成本.遗传算法是求解路径覆盖测试数据自动生成问题的有效方法,近年来国内外的相关研究成果较多.Ahmed和Hermadi[3]、Bueno和Jino[4]、Lin和Yeh[5]、Watkins和Hufnagel[6]、Malhotra和Garg[7]以及Irfan和Ranjan[8]等都利用遗传算法得到满足路径覆盖的测试数据;Wegener等人[9]给出多种路径覆盖准则,谢晓园等人[10]提出了基于相似性度量的适应值构造方法.众所周知,遗传算法通过适应值评价个体的优劣,进而引导算法搜索最优解,适应值函数的设计直接影响算法找到最优解的速度.现有的适应值函数设计方法都只考虑单一个体满足目标路径的程度,没有有效利用进化种群所反映出的综合信息,即没有考虑个体穿越的节点是否为目标路径难以覆盖的节点,因此没有给予穿越难以覆盖节点的个体较高的适应值,从而使穿越难以覆盖节点的稀有数据没有得到有效保护;尤其对于大型复杂程序,目标路径的节点个数较多,或是在搜索空间爆炸性增长时,这种问题尤为突出.如果采用适当的方法对穿越难以覆盖节点的稀有数据进行正确判断,并通过调整适应值对其进行保护,将能有效提高测试数据的生成效率.目标路径节点被覆盖的难易程度可通过静态分析得到,但是会花费较多的分析时间,而且容易出现错报和漏报等现象.使用遗传算法生成测试数据时,多个个体同时并行搜索最优解,进化中的每一代都会以这些个体对应的测试数据运行被测程序,目标路径节点被穿越的个体数量直接反映了该节点被覆盖的难易程度,即难以覆盖的节点仅有较少个体穿越;相反,容易覆盖的节点却有较多个体穿越.因此,通过统计这些个体穿越目标路径节点的情况,即可得到节点被覆盖的难易程度.本文通过统计测试数据进化生成中个体穿越目标路径的节点情况,评价个体对生成穿越目标路径测试数据的贡献(简称个体贡献度),并用一个精确值表示,以此作为权重调整个体的适应值,使得穿越难以覆盖节点的个体获得较高的适应值,从而在进化中得到保留,以提高测试数据生成的效率.将本文的方法用于基准程序和复杂的工业用例的测试,结果表明,本文方法生成测试数据的效率较高.2常见适应值函数设计方法为了介绍方便,先给出几个基本概念.记被测程序为F,与F有关的概念如下:(1)节点.F的一个基本执行单元称为节点,其在F的任何一次运行中,要么都执行,要么都不执行.节点可能是分支语句的前件、一条语句或多条连续语句.如图1(a)为文献[11]用到的三角形分类程序,语句左边的标号为节点编号.节点1、3、5、7等为分支语句的前件,节点8、11、12等只包含1条语句,节点2、4、6等由多条连续的语句构成.(2)控制流图[1].F的控制流图是一有向图G=(N,E,s,e),其中,N是节点集,边集E={〈nodei,nodej〉|nodei,nodej∈N,且nodei执行后可能立即执行nodej},s和e分别为程序的入口和出口节点.如图1(b)为图1(a)所示的三角形分类程序的控制流图.(3)路径[12].F的路径p是控制流图的节点序列“s,node1,node2,…,noden,e”,其中,nodei∈N(i=1,2,…,n),且〈s,node1〉∈E,〈nodei,nodei+1〉∈E(i=1,…,n-1),〈noden,e〉∈E.图1(b)的“s,1,2,3,4,5,6,7,9,13,15,16,e”为三角形分类程序的一条路径.用遗传算法生成覆盖目标路径的测试数据,需要把该问题转化为一个优化问题,适应值函数的设计是求解该问题的关键,因此众多学者针对适应值函数的构造给出多种方法[13],大体分为分支距离Page3(branch_distance)、层接近度(approach_level)以及二者结合的方法.2.1分支距离计算方法分支距离是当个体执行路径偏离目标分支时反映偏离该分支的大小.Korel采用改变变量方法生成测试数据时,给出一种分支距离的计算方法,详见文献[12].如图1(a)的程序中,假定其第1个分支节点的谓词(a>=b)的真分支为目标分支,该方法的分支距离函数为b-a,对于第t代的第i个个体xi(a=10,b=20,c=30)的分支距离为20-10=10,该值越小说明个体xi越接近该目标分支;当有多个目标分支没有达到时,将这些分支的分支距离之和作为个体xi的相对于目标路径的分支距离.Tracey进一步给出各分支谓词的分支距离计算函数及针对含有复合谓词情况的计算方法,其方法与Korel提出的方法相似,只是在谓词计算结果为假值时多使用一个正常数K,使目标函数总是返回一个大于或等于0的值,如果违背期望目标分支,则目标函数值大于0,而当执行了目标分支时,该值等于0,详见文献[14].2.2层接近度计算方法层接近度表示输入变量所穿越路径与目标路径的接近程度.假设第t代的第i个个体xi穿越的路径为p(xi),目标路径为p0,其节点个数表示为|p0|,比较p(xi)与p0的各个节点,将层接近度记为approach_level(t,i),常见的层接近度计算方法是:统计p(xi)未穿越p0中节点的个数,记为α(xi),用其除以目标路径p0的节点个数,即若p(xi)=“1,2,4,5”,p0=“1,2,3,5”,则按照上述方法计算得approach_level(xi,t)=1谢晓园等人[10]针对路径覆盖测试数据进化生成问题,给出测试数据与目标路径距离的如下计算方法:distance(test,target)=length(target)-similarity(track,target),其中,length(target)是目标路径的长度,similarity(track,target)是用测试数据穿越路径与目标路径相同节点个数表示的相似度,并进一步给出了3种不同的计算相似度的方法.我们曾提出一种新的适应值函数计算方法[15],该方法针对多目标路径覆盖测试数据生成问题,将所有目标路径用赫夫曼编码表示,根据个体穿越路径与目标路径编码的匹配程度设计适应值函数,实际上也给出了一种表示层接近度的新方法.后来,我们又给出覆盖大规模路径的测试数据生成方法,该方法的适应值函数仅考虑个体穿越路径与目标路径从前至后连续相同节点的个数[16].2.3分支距离与层接近度结合的计算方法Wegener等人[9]及Ahmed等人[3]在多路径覆盖测试数据生成中,均采用分支距离与层接近度之和作为个体适应值.即第t代种群中第i个个体的适应值fit(xi,t)计算方法如下:fit(xi,t)=approach_level(xi,t)+branch_distance(xi,t).一般来说,分支距离的大小与输入数据有关,其值可能会远大于层接近度的值,因此分支距离常被执行规范化处理.McMinn[17]及Harman等人[18]给出的适应值函数是将规范化后的分支距离与层接近度结合,即fit(xi,t)=approach_level(xi,t)+其中,normalize(d)=1-1.001-d,将分支距离规范化到[0,1)内,进化过程中将适应值函数最小化.Arcuri[19]分析不同的分支距离规范化方法,提出Page4一种新的规范化方法,该方法将原有的分支距离除以该值再加上一个大于0的常数,即normalize(d)=d(β为大于0的常数),并验证了新方法的优越性.d+β上述方法有效解决了路径覆盖测试数据自动生成问题,但均只考虑单一个体满足目标路径的程度,没有考虑个体穿越的节点是否为目标路径难以覆盖的节点,因此不能保证对穿越难以覆盖节点的个体给予较高的适应值,从而穿越难以覆盖节点的稀有数据没有得到保护.鉴于此,本文根据个体穿越节点的难易程度调整不同个体的适应值,使稀有数据的适应值得到增加,可以有效保护这些稀有数据,从而提高测试数据生成的效率.调整适应值的方法是通过统计种群中个体穿越目标路径节点的信息,计算个体对目标路径的贡献程度,以其作为权重调整个体适应值.下面首先介绍个体贡献度的定义及求解方法.3个体贡献度计算应用遗传算法生成测试数据时,有大量数据运行被测程序.穿越路径节点的测试数据个数与该节点被穿越的概率有关,概率越大,穿越该节点的数据越多,即个体数越多,从而测试数据越容易生成;概率越小,穿越该节点的测试数据越少,从而测试数据越难以生成.本文将难以穿越的节点称为小概率节点,穿越小概率节点的测试数据为稀有数据.使用遗传算法生成测试数据时,穿越小概率节点的个体对生成穿越目标路径的测试数据的贡献大.因此,本文基于每代种群的个体穿越目标路径节点信息计算个体的贡献度.在目标路径的节点中,有些节点被任何个体穿越的路径包含,为程序运行的必经节点.如果考虑这些节点,将无助于区分个体的优劣,还会增加计算量.因此,在计算个体的贡献度时,先对目标路径的节点约简.3.1路径节点约简(1)必经节点.从程序的起点到终点必须经过的节点,称为必经节点.以任何数据运行被测程序都穿越必经节点,如图1中的节点1、3、5、7、16均为必经节点.(2)选经节点.程序的节点中,除必经节点之外的节点,称为选经节点.不是所有的测试数据都能穿越选经节点,如图1中的节点2、4、6、8、9、10、11、12、13、14、15均为选经节点.只有选经节点能反映一条路径的走向,如图1中选择路径“s,1,2,3,4,5,6,7,9,13,15,16,e”,那么,2、4、6、9、13、15为反映路径走向的选经节点.必经节点不能区分测试数据对穿越目标路径的贡献,因此没有必要统计这些节点被测试数据穿越的情况,仅考虑选经节点即可.于是,在计算个体贡献度时先对目标路径进行约简.(3)约简方法.去除路径中的必经节点、起始节点和终止节点,仅用选经节点表示路径.如图1所示,若目标路径为“s,1,2,3,4,5,6,7,9,13,15,16,e”,不考虑起始和终止节点,有11个节点,该路径可约简为“2,4,6,9,13,15”,仅包含6个节点;若目标路径为“s,1,2,3,5,7,9,10,11,16,e”,约简后为“2,9,10,11”,仅包含4个节点.对路径的约简将使程序插桩和个体贡献度计算量大大减少.被测程序可能含有循环结构,这样目标路径中的某个节点可能在其中出现一次,也可能出现多次.不同个体执行该节点的次数可能不同.下面先给出目标路径中不包含循环执行节点的个体贡献度计算方法;再进一步给出包含循环执行节点的个体贡献度的计算.3.2个体贡献度计算记种群规模为m,目标路径p包含n个节点,有n个选经节点,均不在循环结构中.对于第t代种群的个体xi,按照如下方法,计算该个体对生成穿越目标路径p的测试数据的贡献度.通过统计目标路径的节点被个体穿越的情况,得到个体穿越矩阵,记为狋狉犪狏(t),表示如下:node1node2…noden狋狉犪狏(t)=其中,cij(t)=1,xi穿越nj根据狋狉犪狏(t),计算第t代种群中穿越节点nodej(j=1,2,…,n)的个体数目,记为sj(t),容易得到sj(t)=∑m个节点的贡献度Qj(xi,t)可以表示为Page5由式(1)可知,穿越小概率节点的个体比较少,从而这些个体具有较大的贡献度,最大值为1,对应仅有一个个体穿越的情况;穿越容易覆盖节点的个体相对较多,从而这些个体具有较小的贡献度,最小值为0,对应没有穿越任何选经节点的个体.这些值可以构成个体对目标路径节点的贡献度矩阵,记为犮狅狀狋狉(t),并表示如下:node1node2…noden犮狅狀狋狉(t)=矩阵的行代表第t代种群的某个体对目标路径不同节点的贡献度,矩阵的列代表不同个体对目标路径某节点的贡献度.容易理解,如果某个体对目标路径的多个节点的贡献度都比较大,那么该个体对目标路径的贡献度也比较大.因此,个体对目标路径的贡献度可以通过该个体对目标路径的所有节点的贡献度求和得到,记为Q(xi,t),那么,Q(xi,t)可表示为稀有数据,那么该个体的贡献度就会较大.由式(2)可知,如果某个个体对应的测试数据是例如,对于图1的目标路径“s,1,2,3,4,5,6,7,9,10,11,16,e”,约简后,该路径可以表示为“2,4,6,9,10,11”,若种群规模为5,进化到第3代时5个个体x1,x2,…,x5穿越的路径分别为p(x1)=“s,1,2,3,4,5,6,7,9,13,15,16,e”,p(x2)=“s,1,3,5,6,7,8,16,e”,p(x3)=“s,1,2,3,5,6,7,9,13,15,16,e”,p(x4)=“s,1,3,4,5,6,7,9,10,12,16,e”,p(x5)=“s,1,2,3,5,6,7,8,16,e”,则个体穿越矩阵和贡献度矩阵分别为24691011狋狉犪狏(3)=和24691011犮狅狀狋狉(3)=从而,这些个体的贡献度分别为可以看出,不同个体对目标路径的贡献度得到有效区分.3.3对循环结构的处理在循环体中的节点可能在目标路径中出现多次.如路径p=“s,node1,node2,…,noden,e”,约简后选经节点可能会有重复的情况.不失一般性,这里假设前n个节点不重复,n<n,并记节点nodej在p中出现的次数为r(nodej)(j=1,2,…,n).对于目标路径的每个节点,统计穿越该节点的个体数目,记xi穿越目标路径的前n个节点的次数分别为ri(nodej)(j=1,2,…,n),那么,设定xi对目标路径节点nj的贡献度修正系数为例如,节点node1在目标路径p中出现3次,则r(node1)=3,如果个体x1穿越的路径执行1次node1,则r1(node1)=1,由式(3)可得1(x1)=如果个体x2穿越的路径执行3次node1,则r2(node1)=3,由式(3)可得Page61(x2)=如果个体x3穿越的路径执行7次node1,则1(x3)=0.2.这样,根据个体穿越目标路径节点的次数与目标路径本身执行该节点次数的接近程度,修正个体对目标路径节点的贡献度,保证次数越接近目标路径的要求,贡献度修正系数越大;与目标路径次数相同时,贡献度修正系数达到最大值1.对于包含循环体结构在内的所有程序,xi对目标路径节点nj的贡献度可以表示为此时,个体xi对目标路径的贡献度为Q(xi,t)=∑n使用此贡献值作为权重调整个体适应值,得到基于稀有数据有效扑捉的路径覆盖测试数据进化生成方法.4基于稀有数据有效扑捉的路径覆盖测试数据进化生成使用遗传算法生成路径覆盖的测试数据,需将路径覆盖测试数据生成问题转化为函数优化问题.具体过程为:(1)在程序的输入空间中随机生成一定数量的测试数据,对其进行编码成为进化个体作为初始种群;(2)循环执行以下操作:将解码后的进化个体作为程序的输入,执行插桩后的被测试程序;通过适应值函数评价进化个体的优劣;采用遗传算子生成新的进化种群.如此反复,解码后的优化解就可能是穿越目标路径的测试数据.其中,个体编码方法、解码方法以及遗传算子中的交叉和变异方式,均可以根据数据特点选择不同的方法,此不赘述.适应值设计是影响算法效率的关键,本文基于个体的贡献度调整个体的适应值,得到基于稀有数据扑捉的路径覆盖测试数据进化生成方法.4.1适应值函数调整记第t代个体xi穿越的路径为p(xi),目标路径为p0,xi的层接近度为approach_level(xi,t),计算方法采用统计个体穿越路径p(xi)与目标p0相同节点的个数,用其除以目标路径的节点数来计算,该值越大个体越优;分支距离为branch_distance(xi,t),计算方法与Tracey方法相同,为了权衡其与层接近度的大小,并统一为最大化运算,将其采用1.001-branch_distance(xi,t)进行规范化,其值越大个体越优,于是xi的适应值fit(xi,t)可表示为fit(xi,t)=approach_level(xi,t)+1.001-branch_distance(xi,t)(6)将式(5)作为式(6)的权重调整原来的适应值,得到调整后的个体的适应值记为f(xi,t),表示如下:f(xi,t)=fit(xi,t)·Q(xi,t)=(approach_level(xi,t)+1.001-branch_distance(xi,t))·∑nj=1在传统适应值函数的基础上,乘以体现个体贡献度的权重,对穿越小概率节点的个体,赋以较大的权重,保证其有较高的适应值,从而使稀有数据得到有效保护.4.2性能分析为了便于分析,假设目标路径不包含循环执行的选经节点,并在种群进化到第t代,有2个体x1和x2,穿越的路径分别为p(x1)和p(x2).与目标路径对照,除了分别穿越目标路径在第j和第k个节点上不同外,其余都相同.按照传统的适应值计算方法,它们对应的层接近度将相等.这里假设它们对应的分支距离也相等,则按照式(6)计算得到fit(x1)=fit(x2).如果穿越目标路径的第j个节点的个体数少于穿越目标路径的第k个节点的个体数,即sj(t)<sk(t),则由式(1)得Qj(x1,t)>Qk(x2,t).由于两个体穿越目标路径其它节点都相同,即Qy(x1,t)=Qy(x2,t),y≠j或k,于是由式(2)得Q(x1,t)>Q(x2,t),假设第j个和第k个节点均不是循环体中的节点,从而由式(5)得Q(x1,t)>Q(x2,t).也就是说,按照传统的适应值计算相等的情况下,由于两个体穿越目标路径节点的难易程度不同,导致本文方法对应的适应值调整权重不同.按照本文方法,由式(7)得到x1和x2的适应值分别为即两个体的适应值不同,f(x1,t)>f(x2,t).这样,根据进化过程中个体的贡献度调整个体的适应值,可以使得穿越难以覆盖节点的稀有数据获得较高的适应值,有利于在后续进化中保留下来.上述分析表明,通过本文提出的调整策略,对于覆盖目标路径的难以覆盖的选经节点的进化个体,其适应值能够得到增加,这样增大了这些进化个体Page7参与后续遗传操作的机会,从而提高了生成覆盖目标路径的测试数据的效率.4.3算法步骤[20]数赋值;1.确定目标路径,插桩被测程序,并对算法的控制参2.将种群初始化;3.分别将每个进化个体解码,并以其为输入运行被测程序;4.判断是否有个体穿越路径与目标路径完全相同.若有,保存该个体,并转至步骤8;5.判断是否达到事先设定的最大进化代数,若达到,则停止种群的进化;6.依据式(7)计算进化个体的适应值;7.对种群依次实施选择操作、交叉操作以及变异操作,生成子代种群,并转至步骤3;8.停止种群的进化过程,解码保存的进化个体,输出穿越目标路径的测试数据.5实验为了验证本文方法的有效性,被测程序选择了2个基准程序和6个工业用例,均为C语言程序,仿真环境为VC++6.0,实验机器主频和内存分别为2.80GHz和2GB.5.1对比方法与参数设置选择如下两种对比方法:一是文献[17]方法,这里称其为传统方法.该方法使用分支距离和层接近度结合作为适应值,与本文方法均采用遗传算法进化生成测试数据.本文方法是在其基础上增加了对稀有数据的扑捉技术.与其对比,是为了验证本文方法生成测试数据的效率是否有所提高.另一种是随机法[21],该方法在程序的输入域随表1三角形分类程序实验设置及实验结果评价次数平均值数据范围[1,128]5050007125.00.0008100120315.30.0121100.00128055.30.0008100.00[1,256]501000010910.70.0012100318240.00.0335100.00535965.00.0037100.00[1,512]1002000030540.70.00411001225290.30.168686.671673340.00.012480.00[1,1024]2005000098440.30.01551004727740.70.590580.005832380.70.041966.67为535965.0次,约是本文方法的49.1倍.其它3种数据范围得到的结果也类似,说明本文方法的优势十分明显.(2)从运行时间平均值上看,只有数据范围在[1,128]时,本文方法为0.0008s,与随机法相同,其由表1可以看出:(1)对于每种数据范围,本文方法都以最少的评价次数成功生成了测试数据.如数据范围为[1,256]时,本文方法的评价次数为10910.7;传统方法为318240.0,约是本文方法的29.2倍;随机法机生成均匀分布的测试数据,通过运行被测程序,判断是否找到穿越目标路径的测试数据.该方法为常见的测试数据生成对比方法.为保证抽样个体间的差异尽可能的小,3种方法采用相同的种群规模及初始种群.本文方法和传统方法使用的遗传算法控制参数也相同,个体均采用二进制编码,采用轮盘赌选择、单点交叉、单点变异,交叉和变异概率分别设定为0.9和0.3.每种算法运行过程中,如果生成了穿越目标路径的测试数据或者是达到了预先设定的最大进化代数则终止.由于不同作者的算法,其算法机制不尽相同,一般来说,在相同的仿真环境下,使用找到覆盖目标路径的测试数据需要的平均评价次数来比较不同算法的性能,是相对比较公平和简便的方法,评价次数越少,说明算法的性能越好;同时,由于算法的运行时间一方面与评价次数有关,另一方面也体现了算法每次评价个体耗时的多少,为了体现不同算法的时间消耗,实验过程中也记录了各种算法多次运行的总时间,求得每次运行的平均时间进行比较,该时间越少,说明算法效率越高;此外,还比较了生成测试数据的成功率,该值越大,说明算法越有效.5.2基准程序实验为避免随机性对各算法性能的影响,本组实验设定每种方法均运行15次.5.2.1三角形分类程序首先,对图1所示的三角形分类程序进行实验.选择一条难度较大的路径,即等边三角形“s,1,2,3,4,5,6,7,9,10,11,16,e”作为目标路径,输入数据的范围分4种情况,不同情况选择不同的种群规模和最大终止代数,实验设置及结果如表1所列,其中,成功率指在最大运行代数之内成功生成测试数据的实验次数与实验总数(即15次)的比值.传统方法运行时间平均值/sPage8它数据范围本文方法都明显优于传统方法和随机方法;可以看出,随机法的时间消耗相对于评价次数来说,要少得多,这是由于随机法不涉及对每个个体的适应值计算时间,而且每一代个体均由随机生成,使得时间消耗较少;传统方法评价次数虽然少于随机法,但是由于每个个体适应值计算以及交叉变异操作产生新个体都需要消耗时间,总体运行时间较多;本文方法虽然个体生成过程与传统方法相同,但是通过对适应值的调整,对生成最优解十分有利,使得评价次数大大减少,因此评价时间达到最少,这说明本文方法生成测试数据的效率明显高于其它两种方法.(3)在输入数据的范围小时,每种方法都能成功生成测试数据.随着输入数据范围的增加,生成测试数据的难度也不断增加,传统方法和随机法都有生成测试数据失败的情况.如输入数据的范围是表2大搜索空间下三角形分类程序实验设置及实验结果数据范围评价次数平均值[1,2048]20060000190400.00.01361009892247.71.817760.0011315746.70.074333.33[1,4096]20070000304800.00.110410013604260.33.675826.6714000000.00.11920.00[1,8192]20080000691840.00.507610015469982.04.28126.6716000000.00.17810.00[1,16384]200900001299760.01.875210018000000.05.98090.0018000000.00.34120.00[1,32768]2001000002364224.04.125010020000000.07.56110.0020000000.00.38970.00从表2可以看到,当数据范围变大,导致搜索空间爆炸性增长的情况下,(1)随机法对于小概率的情况,很难生成测试数据,在本组实验的5种数据范围情况下,只有范围在[1,2048]时有5次成功生成了测试数据,因此成功率为5/15≈33.33%,其它实验均没有生成需要的测试数据,成功率均为0.(2)传统方法的评价次数比随机法少,但是远多于本文方法,导致平均运行时间也比本文方法多很多;生成测试数据的成功率虽高于随机法,但是远不如本文方法,该方法在数据范围是[1,2048],[1,4096]和[1,8192]时,生成测试数据的成功率分别为60.00%,26.67%和6.67%,尤其是在范围扩大到[1,16384]和[1,32768]时,成功率为0,即15次实验中每次达到最大运行代数,都没能生成需要的测试数据;这说明传统方法在搜索空间爆炸性增长的情况下很难奏效.(3)本文方法随着数据范围的加大,虽然评价次数逐渐增多,运行时间也随之变长,但是仍能有效生成测试数据,而且测试数据生成率均为100%,这[1,512]和[1,1024]时,传统方法生成测试数据的成功率分别为86.67%和80.00%;随机法分别为80.00%和66.67%.这说明,随着问题难度的加大,本文方法的优势更加明显.为了进一步验证本文方法在搜索空间爆炸性增长情况下的算法性能,选择三角形分类程序更大的输入范围进行实验.实际上,当输入的3个数据范围均为[1,2048]时,搜索空间为[1,2048]3,此空间中共有数据20483个,而能够穿越等边三角形路径的测试数据只有2048个,因此,生成需要的测试数据的概率为2048/20483=2-22,显然生成等边三角形的概率很小,继续加大被测程序的输入数据范围时会导致搜索空间爆炸性增长,在种群规模不变的情况下,种群中的稀有数据变得更加稀少,此时保护穿越难以覆盖节点的稀有数据更加重要.仍以等边三角形路径为目标路径.实验设置及结果如表2所列.传统方法运行时间平均值/s说明本文方法在搜索空间爆炸情况下对测试数据生成效率仍有所改进.5.2.2冒泡排序程序为了验证本文方法在包含循环结构的基准程序上的有效性,选择按照升序排列数据的冒泡排序程序作为被测程序,对8个[1,65535]范围内的数据排序.种群规模为100,最大终止代数为1000.选择一条8个数逆序排列的测试数据穿越的路径作为目标路径,3种方法各独立运行15次,得到的实验结果如表3所列,由于实验过程中统计的是15次运行的总时间,所以没有给出算法每次运行时间,而是用总时间求得平均运行时间列在表3的最后一列.本文方法23206.715(100%)0.1409传统方法50953.313(86.7%)0.1781随机法58273.312(80%)由表3可以看出:(1)本文方法能在设定的进化代数内成功生成测试数据,成功率为100%;传统方法成功次数为Page913,成功率为86.7%;随机法成功次数为12,从而生成测试数据的成功率为80.0%.(2)对于每次实验,本文方法总以最少的评价次数生成穿越目标路径的测试数据,平均评价次数为23206.7,不足传统方法50953.3次的一半,更少于随机法的58273.3次.(3)本文方法的平均运行时间为0.1409s,小于传统方法的0.1781s,但是大于传统方法运行时间的一半,这说明,相对于评价次数上与传统方法的差别,本文方法在运行时间上与传统方法的差别变小,这是由于本文方法在个体贡献值计算上需要耗费一定的时间所致.总体看来,对于两个基准测试程序,与传统方法和随机法相比,本文方法在生成测试数据的成功率、评价次数以及运行时间上均有明显的优势.被测程序表5工业用例实验结果传统方法space(fixgramp)8934.13798.50.029910014213.88739.20.033710019273.312319.40.0367100space(fixsgrid)5498.92911.10.031210012215.75643.80.039910016296.88451.90.0407100tot_info690465.722094.98.84301001046532.932442.58.0167721590486.754076.55.619740replace871308.028076.726.51121001953761.644287.941.8813662539860.772127.88.902126sedflex由表5可以看出:(1)从评价次数均值来看,本文方法所用的评价次数仍然明显少于传统方法和随机法.(2)从评价次数标准差来看,本文方法的标准差最小,这说明本文方法比另外两种方法的稳定性好.(3)从运行时间平均值来看,和传统方法比,只有“tot_info”程序本文方法平均运行时间为8.8430s,略高于传统方法的8.0167s,其它被测程序本文方法的运行时间均少于传统方法;和随机法比较,对于成功率相同的space(fixgramp)和space(fixsgrid)程序,本文方法平均运行时间少于随机法.(4)从成功率来看,由于space程序的两个函数相对简单,3种方法都成功生成了测试数据,即成功率都是100%.但是,对于比较复杂且目标路径节点个数较多的tot_info和replace程序,测试数据生成的难度较高,传统方法的成功率分别为72.0%和66.0%;随机法分别为40.0%和26.0%;但本文方法的成功率仍均为100%,每次都成功生成了测试数据,特别是对于更加复杂的sed和flex程序,传统5.3工业用例实验为进一步验证本文方法在工业用例上的有效性,选择6个工业用例[22]进行实验,每个程序随机选择一条可行路径作为目标路径.程序描述及参数设置如表4所列.被测程序代码space(fixgramp)90181002000space(fixsgrid)115121001500tot_inforeplacesedflex本组实验,设定每种方法分别独立运行50次,统计评价次数的平均值及标准差、生成测试数据的成功率、运行时间平均值如表5所列.评价次数标准差运行时间方法和随机法的成功率都很低,而本文方法生成测试数据的成功率仍为100%.以上实验充分验证了本文方法的优越性,但在比较本文方法与传统方法或是与随机法的测试数据生成效率是否有显著性区别时,实际上是需要对这些算法性能进行总体的推断.而对两个总体进行比较时,常见的方法是通过多次实验采集到这两个总体的样本,根据这些样本的不同来推断总体的不同.而根据样本推断总体特性的一种有效的数理统计方法是假设检验.假设检验是统计推断的一个重要分支[23],根据样本分布规律和概率原理,由样本结果去推断总体特征.本文采用假设检验方法通过实验结果对算法的实际性能进行预测.设本文方法、传统方法和随机法每次运行的评价次数分别为X1、X2和X3,为方便表述,每种方法对不同被测程序使用相同的符号,则X1、X2和X3都是随机变量.另外,因为X1、X2和X3的值都受很多随机因素的影响,在多次实验时它们服从正态分布.设Xi~N(μi,σ2i),i=1,2,3.比较每种方法随机变Page10量的平均值μi(i=1,2,3)的大小.其值越小,则该方法生成测试数据需要的评价次数期望值越低,表明该方法生成测试数据的效率越高.以工业用例space(fixgramp)为例,给出利用假设检验对μ1和μ2进行比较的具体过程.考虑到样本方差是总体方差的无偏估计,因此,用样本方差的值作为对总体方差的估计值,即用样本标准差的值作为对总体标准差的估计值[24],得到σ1=3798.5和σ2=8739.2.样本容量n1=n2=50,珡X1=8934.1,珡X2=14213.8,显著性水平α的值为0.01.第1步.建立原假设H0:μ1μ2和对立假设H1:μ1<μ2;第2步.构造统计量U1=珡X1-珡X2第3步.给出拒绝域U1=珡X1-珡X2第4步.计算统计量的值:U1=珡X1-珡X2σ21n1+σ22n槡2第5步.给出结论:因为U1=-3.92-Zα=-2.325,落在拒绝域内,因此,拒绝H0,接受H1,即认为本文方法评价次数的期望值比传统方法明显小[24].这说明,与传统方法相比,本文方法生成测试数据需要的评价次数明显少.在相同的显著性水平α=0.01下,σ1=3798.5,σ3=12319.4,样本容量n1=n3=50,建立假设和对立假设分别为H0:μ1μ3;H1:μ1<μ3,构造统计量并计算U2=珡X1-珡X3这说明,本文方法生成测试数据需要的评价次数明显少于随机法.其它5个程序比较结果如表6所列.由表6可以看出,对所有工业用例,本文方法需要的评价次数都明显少于其它两种方法.总体看来,对于工业用例,本文方法不仅具有最高的成功率;需要的评价次数也明显少于其它两种方法;在生成测试数据成功率相同的情况下,本文方法的用时最少.这充分说明,本文方法生成覆盖目标路径的测试数据效率高.被测程序对比方法计算统计量的值给出结论space(fixsgrid)tot_info传统方法U1≈-64.14<-2.325接受H1:μ1<μ2replace传统方法U1≈-145.97<-2.325接受H1:μ1<μ2sed传统方法U1≈-16.94<-2.325接受H1:μ1<μ2flex传统方法U1≈-25.53<-2.325接受H1:μ1<μ26总结本文给出一种个体对生成穿越目标路径的测试数据贡献度的计算方法,并基于个体的贡献度调整个体的适应值,使穿越难以覆盖节点的个体具有较高的适应值,从而在后续进化中得到保留,有效提高了测试数据生成的效率.算法分析及在基准程序与工业用例的实验结果表明,与传统方法和随机法相比,本文方法生成测试数据的效率较高.需要注意的是,本文考虑的是单路径覆盖测试数据进化生成问题.今后将进一步研究一次运行遗传算法,同时生成多个目标路径覆盖测试数据时,个体贡献度的计算方法,提高多路径覆盖测试数据的生成效率.
