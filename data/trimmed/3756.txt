Page1支持频繁位置更新的不确定移动对象索引策略丁晓锋金海赵娜(华中科技大学服务计算技术与系统教育部重点实验室武汉430074)(华中科技大学集群与网格计算湖北省重点实验室武汉430074)摘要移动数据采集和处理技术的迅速发展给研究人员提出了新的应用需求,如何在频繁位置更新应用中索引不确定移动对象的当前及未来位置信息成为当前的研究热点之一.TPU树是针对不确定移动对象的当前及未来位置信息索引的策略,其具有较高的概率域查询效率,但是其采用的传统自顶向下更新算法,存在频繁位置更新效率低下的问题.通过在TPU树上增加一个记录不确定移动对象状态特征的更新备忘录(UM)内存结构,文中提出了一种支持频繁位置更新的不确定移动对象索引策略TPU2M树,并在此基础之上提出了一种改进的基于备忘录(MMBU/I)的更新/插入算法.代价分析和实验仿真表明,采用MMBU/I算法的TPU2M树频繁更新性能大大优于TPU树和ABx树索引,且概率查询性能与传统索引大致相当,因此具有很好的实用价值和广泛的应用前景.关键词不确定移动对象;索引结构;基于备忘录更新;TPU树;概率查询1引言近年来,伴随着科学技术的不断进步,人们对数据的采集方式呈现多样化和对数据处理技术的逐步深入研究,不确定性数据得到学术界和工业界的广泛重视[1-2].在诸多应用如实时交通信息管理与导航、军事监控和民航管制中,移动终端的实时位置信息的不确定性普遍存在,如何对移动终端的不确定性实时位置信息进行监控和管理是一个至关重要的问题[3-5].传统数据库索引技术是为存储精确的数据而设计,其索引结构中存储移动对象的精确位置,因此无法有效地管理不确定性数据,从而学术界和工业界对研发新型的不确定性数据管理技术提出了要求.针对如何高效管理移动对象实时变化的精确位置信息,研究人员提出了一系列的索引模型,根据位置信息的不同类型,大致可以分为两类[6]:一类是针对移动对象历史位置信息的索引;另一类是针对移动对象当前及未来位置信息的索引.其中包括许多基于参数化的索引方法来对移动对象当前及未来位置信息进行管理,如TPR树[7]及其变种TPR树[8]、REXP树[9]和STAR树[10]等.TPR树及其变种TPR树由于沿用了传统R树的查询,插入及删除等算法而成为目前广泛使用的精确移动对象当前及未来位置信息索引方法,但其固有的自顶向下(top-down)更新模式,由于较大的I/O代价而难以满足大量并发更新的要求.REXP树借用TPR树的时间参数策略,通过在R树上添加数据的有效期属性,提高了失效数据的删除效率,从而表现出比较好的更新性能.STAR树在处理简单更新时也表现出很好的性能.研究人员提出能同时对移动对象历史、当前及未来位置信息进行索引的模型(BBx树[11]、RPPF树[12]).但上述索引方法包括R树家族[3]均不能很好地处理移动对象频繁位置更新.Lee等人[13]提出了基于R树的自底向上(Bottom-UpUpdate,BUU)更新思想,其更新过程起始于要求更新的叶节点,无需浪费大量查找时间,从而大大提高动态更新性能,但辅助索引的维护和大量内存空间的占用导致系统稳定性较差,且不能很好地解决频繁大幅度位置更新问题.针对如何管理和查询对象的不确定性位置信息,Tao等人[1]提出了基于R树的不确定对象索引策略U树,其固有的良好动态结构可以使得数据对象以任何次序更新或插入,而且对不确定数据本身的概率密度分布(ProbabilityDensityFunction,PDF)没有任何限制.文献[4]针对支持不确定移动对象当前及未来位置信息索引和查询的问题,提出了一种基于U树的高效率当前及未来不确定位置信息检索的索引结构TPU树,并提出了一种改进的基于p-bound的域查询(Modifiedp-boundBasedRangeQuery,MP_BBRQ)处理算法.实验表明,采用MP_BBRQ算法的TPU树概率域查询效率可以得到很大程度的提高.最近,Zhang等人[5]提出来一种基于Bx树的不确定移动对象索引策略ABx树,利用矩形框推论法则(Rectangleinference)和蒙特卡洛(Monte-Carlo)模拟相结合的方法预测移动对象未来的大概位置信息,并提出了高效的概率范围查询和概率K最近邻查询算法.但由于上述索引采用传统的自顶向下更新方法,不断变化的不确定移动对象位置信息,会使得更新过于频繁而导致系统资源枯竭,从而影响系统的响应时间和查询效率.本文针对支持频繁位置更新的不确定移动对象当前及未来位置索引方法,提出了一种基于TPU树与更新备忘录(Update-Memo,UM)内存结构的TPU2M树,并提出了一种改进的基于备忘录更新/插入(ModifiedMemo-BasedUpdate/Insert,MMBU/I)算法.TPU2M树在基本TPU树结构上,增加了记录不确定移动对象状态特征的UM内存结构.MMBU/I算法利用UM控制不确定移动对象的位置更新,在保留原有记录的情况下首先插入新记录,这样就减少了查找原有记录的磁盘I/O,从而很大程度上提高了记录的更新效率,然后TPU2M树利用空间清理器,定期清除索引树叶节点中包含的旧记录,同时维护并限定UM内存结构的大小,为索引树高效稳定运行提供保证.本文的主要贡献如下:(1)本文引入了一种新颖的数据结构———UM内存结构.通过与传统的索引结构TPU树相结合,提出了一种新的不确定移动对象索引结构TPU2M树.(2)本文出了一种改进的基于备忘录的更新/插入MMBU/I算法,采用合适的TPU2M树索引,显著地提高了大量不确定移动对象并发更新的效率,并利用自底向上的更新思想来进一步提高索引树的更新效率.(3)本文引入了空间清理器,利用合适的运行机制可显著地稳定TPU2M树的运行效率.(4)设计了详细的性能评价实验,并与传统算法进行了比较.实验结果表明,采用MMBU/I算法Page3的TPU2M树动态更新性能大大优于TPU树和ABx树索引,查询性能与同类索引大致相当.本文第2节详细描述TPU2M树不确定移动对象索引的内部结构,及其更新与查询处理算法;第3节引入了空间清理器并具体讨论其对TPU2M树索引性能的影响;第4节给出不同更新策略的代价分析;第5节给出实验结果;第6节对全文工作进行总结,并介绍了未来的研究方向.2TPU2M树不确定移动对象索引U树是Tao等人[1]提出的一种针对不确定对象当前位置信息管理的索引模型,丁晓锋等人[4]在此基础上提出了针对不确定移动对象的TPU树索引策略.U树及TPU树采用传统的删除加插入两阶段更新策略,即当移动对象发出位置或速度更新请求时,算法首先从索引树根节点开始,依次比较此对象原有MBR(VBR)与中间节点MBR(VBR)大小,直至在叶节点中找到移动对象所在的索引项并删除,然后再执行一次自顶向下的搜索,在合适位置中插入新的移动对象记录.自顶向下的更新模式非常简单直观,有助于索引结构的维护.但由于所有的移动对象位置记录存储在索引树的叶节点中,采用此种模式往往从根节点开始搜索相关记录,从而具有很高的搜索定位代价,在频繁更新应用中必然导致索引树查询性能的下降.鉴于此,我们采用类似于文献[14]中基于备忘录(Memo-BasedUpdate,MBU)更新的思想来提高TPU树的动态更新和访问效率.并利用Lee等人[13]提出的自底向上(BUU)的更新思想来进一步提高索引树的频繁更新效率.根据基于备忘录更新的思想,索引结构必须能够区分相关移动物体位置的新旧记录,因此利用一个记录移动物体更新状态的更新备忘录(UM)内存结构来标识移动物体的最新位置记录.为了将位置更新记录及时插入到索引树中,我们提出了改进的基于备忘录更新/插入(MMBU/I)算法,思想如下:首先判断其是否超出所在叶节点的MBR(VBR)范围之内,若未超出范围,则直接更新叶节点页面及数据页面即可;否则,算法不需首先查找并删除相应的旧记录,而是允许同一对象的若干新旧位置记录共存于索引树中,即直接利用标准的TPU树插入算法自顶向下进行搜索,在合适的叶节点中插入新记录,并同时更新UM内存结构的在TPU2M树中能否有效地管理和维护不确定移动对象的新旧记录是影响索引树性能的关键.我们引入时间戳(time-stamp)概念来标识记录的新旧程度.在TPU树基本索引结构基础上,每个TPU2M树叶子节点的记录项都添加了一个标识该记录插入时间的time-stamp属性,记录形式为〈oid,PCR(pi),VBR,ptr,time-stamp〉,oid,PCR(pi),VBR,ptr,time-stamp分别表示不确定移动对象标识、Pi限定性区域、速度包围框、节点磁盘页面地址、时间戳.为方便快速区分移动对象的最新记录和若干旧记录,TPU2M树引入了辅助内存结构UM,其包含数据项的记录形式为〈oid,Slatest,Ntotal〉,oid,Slatest,Ntotal分别表示不确定移动对象标识、不确定移动对象oid的最新时间戳、不确定移动对象oid在索引树中的记录总数.例如,〈100,20090623001,5〉表示标识为100的不确定移动对象在索引树中共有5条记录,其中具有时间戳‘20090623001’的记录是最新位置记录.为进一步加快移动对象在UM中的查找速度,TPU2M树索引还增加了一个建于移动对象标识oid之上的辅助索引(Hash)来定位不确定移动对象在UM中的位置.另外,当空间清理器清除叶节点中包含的旧记录之后,TPU2M树需要以自底向上的方式动态调整树结构,这就要求各节点能够访问父节点磁盘页面,因此,我们修改了TPU树索引节点的记录结构,增加了一个指向父节点磁盘页面地址的物理指针parent-ptr.TPU2M树索引节点记录形式为〈block,level,num_entries,entry,…,entry,parent-ptr〉,其中block表示该节点所在的磁盘页面号;level表示该节点在索引树中的层次(叶结点层次为0,根节点层次最大);num_entries表示该节点中包含的记录项数目.相关内容以标识新旧记录.TPU2M树在记录更新次数达到一定条件时激活空间清理器,然后空间清理器依据UM内存结构的内容清除当前叶子节点中包含的所有旧记录.2.1TPU2M树索引结构图1所示为支持MMBU/I算法的TPU2M树索引结构.其中右上角为辅助内存结构UM.特别地,考虑到大部分不确定移动对象都会发生位置更新从而在索引树中存在多条记录,我们在UM的记录的部分结构中,使Ntotal标识不确定移动对象在索引树中的总记录数,这样就保证UM在大小相当Page4的情况下,避免终因Ntotal仅仅标识不确定移动对象的旧记录数所引起的记录幻像问题.此外,内存结图1支持MMUB/I算法的TPU2M树结构2.2MMBU/I算法当不确定移动对象发出位置更新请求时,新的位置记录信息要求被TPU2M树索引,算法首先根据UM中的记录确定移动对象的叶节点,并判断其是否超出所在叶节点的MBR(VBR)范围之内,若未超出范围,则直接更新叶节点页面及数据页面,否则更新过程等价于在索引树中插入新记录,因此,插入新记录和更新索引树中原有记录在TPU2M树中具有相同的处理过程,其关键在于如何处理产生的移动对象位置信息新记录.图2(a)所示为TPU2M树的插入处理过程.其中关键的MMBU/I算法思想如下:首先给预处理的新记录分配时间戳,执行标准的TPU树插入算法在索引树中插入新记录,然后更新内存结构UM的内容,如果新记录的oid在UM中不存在,则插入新的UM数据项并设置相应Slatest为time-stamp,Ntotal为1;否则,将相应UM数据项中的时间戳更新为time-stamp,且移动对象oid的记录总数加1.算法1描述了MMBU/I算法.算法1.MMBU/I算法.Input:oid,newPCR,newVBROutput:updatedTPU2M-treeBegin1.time-stamp←stampcounter;2.newrecord=〈oid,newPCR,newVBR,time-stamp〉;3.insertthenewrecordtotheTPU2M-tree;4.searchoidinUpdateMemoUM;5.ifnoentryisfoundinUM6.theninsert(oid,time-stamp,1)toUM;7.else8.fentry←entryfoundinUM9.fentry.time-stamp←time-stamp构UM为索引结构快速准确在叶子节点中定位不确定移动对象的存储位置提供了可靠保证.10.fentry.Ntotal++;11.endifEnd2.3查询处理TPU2M树的查询处理过程类似于TPU树.但由于移动对象的若干旧记录和新记录共存于TPU2M树中,因此需要在结果集中剔除满足条件的旧记录,保留满足条件的最新记录.查询处理过程如下:首先利用标准TPU树查询处理算法,得到实际结果的候选集,然后利用UM作为过滤器清除候选集中的旧记录.图2(b)所示为TPU2M树的查询处理过程.UM过滤器的工作原理如下:比较候选集中叶子节点记录项与相应UM数据项的时间戳大小,若叶节点记录项的时间戳等于UM数据项的时间戳,则此记录为最新的不确定移动对象位置信息记录,并保存在最终结果集中,否则,此记录作为旧的移动对象位置信息记录而被清除.算法2描述了Filter算法.Page5算法2.Filter算法.Input:leafentryeOutput:answer-setBegin1.searche.oidinUpdateMemoUM;2.fentry←entryfoundinUM;3.ife.time-stamp==fentry.time-stamp4.thenanswer-set←fentry;5.endif6.returnanswer-set;End3空间清理器大量移动对象位置信息旧记录的存在势必影响TPU2M索引树的查询和更新效率,因此,我们使用空间清理器(spacecleaner)定期清除TPU2M树中包含的旧记录,并动态维护UM内存结构的大小,从而提高索引树的整体效率.空间清理器利用清除(Clean)算法处理索引树中存在的移动对象位置信息旧记录,空间清理器的工作原则主要有两条:懒散处理(lazily)和批量删除(batches),即索引树因更新或插入操作产生的移动对象旧记录,并没有被清理器当即删除,而是根据一定清理周期,在索引树当前操作的叶节点内批量删除该节点包含的所有移动对象旧记录.Clean算法负责清除指定叶节点中包含的所有移动对象旧记录.Clean算法首先将指定叶节点中的所有记录项与相应UM数据项作比较,删除判定出的旧记录,并对相应UM数据项作修改,然后根据该节点清除后的情况,动态调整索引树结构,算法3描述了Clean算法.算法3.Clean算法.Input:leafnodeNOutput:cleanedTPU2M-treeBegin1.foreachentryeinN2.searche.oidinUM;3.fentry←entryfoundinUM;4.ife.time-stamp==fentry.time-stamp5.thenec++;//eccountsthelatestentry6.else7.deleteefromN8.fentry.Ntotal--;9.iffentry.Ntotal==010.thendeletefentryfromUM;11.endif12.endif13.endfor14.ifec<MINentries//theminimumnumberofen-15.thenreinserttheremainingentriesofNintothe16.elseadjusttheNandN’sancestorsinabottomup17.endifEnd另外,我们引入检查率(inspectionratio,ir)来衡量空间清理器检查叶节点的频率.检查率ir定义为:在时间段T内,被清理的叶节点个数C与TPU2M树更新次数U的比率,即ir=C/U.其大小设置直接影响到TPU2M树的清理周期,对索引树整体性能有至关重要的影响.较低的检查率虽然提高了TPU2M树的更新效率,但因此导致的过多移动对象位置信息旧记录会影响TPU2M树的查询效率;相反,检查率偏高将引起清理器频繁的扫描叶节点,在不同的触发机制下会影响到索引树的更新效率.因此,检查率ir的设置在TPU2M树更新和查询效率之间存在平衡,我们将在代价分析和实验仿真中进一步说明.4代价分析为方便对TPU2M树索引性能和不同的更新策略进行代价分析,参照文献[14]我们约定所需代价参数如下:L为索引树中叶子节点的个数;E为辅助内存结构UM中记录项的大小;H为索引树的高度;M为索引树中不确定移动对象的总个数以及移动对象更新总次数U.4.1失效率与UM大小根据空间清理器在TPU2M树中的运行机制,存在于叶子节点中的所有旧记录,在空间清理器的一次运行之后将被全部清除,而每个叶子节点在索引树累计至L/ir次插入/更新操作才被清理器扫描一次.因此,在最坏情况下索引树中包含旧记录的个数为L/ir.作为TPU2M树中重要性能指标之一的失效率(obsoleteratio,or),我们定义为索引树中旧记录个数占移动对象总数量的比率.较高的失效率意味着过多移动对象位置信息旧记录存在索引树中,因而影响TPU2M树的查询效率.失效率在索引树中Page6旧记录个数达到顶峰时具有上限值L/(ir×M),因此很容易得到TPU2M树中失效率的平均值为L/2(ir×M).假设每一个不确定移动对象旧记录占用内存结构UM一个数据项,则UM的上限尺寸为(L×E)/ir,且UM在索引树中的平均大小为(L×E)/2ir.不难发现失效率or和UM大小都与叶子节点个数L成正比,而L远远小于移动对象总个数M,因此失效率与UM在都保证了较小的值,使得UM在内存中得以有效运行,从而确保了索引树高效稳定的性能.为进一步证明本索引的有效性,既新增内存结构UM的空间复杂度对索引性能的影响是甚微的,我们假设不需要删除索引树中冗余的旧记录,且移动对象的总数M保持不变,若一个float或int型数占4个Bytes,那么UM的大小等于M×(4+4+4)Bytes=12M(Bytes),当M取实验系统中最大的值10Million时,UM所占的最大内存为120MB,远小于系统提供的内存,因此,空间复杂度的增加对索引性能的影响是微小的.4.2更新代价我们依次分析并给出3种不同更新策略:自顶向下更新、自底向上更新,以及基于备忘录更新所需的磁盘I/O次数,如表1所示.其中自顶向下更新代价由两部分构成:(1)查询并删除旧记录的代价;(2)插入新节点的代价.由于索引树包含节点之间的区域重叠性,查询一条记录在最好情况下也要访问H个节点,在最坏情况下要访问L×(L-1)/4个节点.搜索到旧记录后要进行删除操作并写回磁盘,在没有节点下溢或上溢的情况下至少需要一次写磁盘.插入新记录需要首先访问H个节点以搜索到合适的叶子节点,然后对该叶子节点进行读写磁盘操作.因此,自顶向下更新策略的一次更新在最好情况下需要2×(H+1)次磁盘I/O,最坏情况下需要L×(L-1)/4+H+2次磁盘I/O.更新策略自顶向下自底向上备忘录当新记录插入到旧记录所在的原始叶子节点时,自底向上更新策略取得最小更新代价3次磁盘I/O:读取辅助索引以定位到原始叶子节点,然后读取并写回该叶子节点.当新记录插入到与旧记录所在原始叶子节点不相关的叶子节点时,自底向上更新策略取得最大更新代价H+6次磁盘I/O:读取辅助索引以定位到原始叶子节点,然后读取并写回该叶子节点,访问H个节点以搜索到合适的叶子节点,然后对该叶子节点进行读写磁盘操作以插入新记录,最后写回辅助索引以定位新记录.基于备忘录的更新策略只需考虑将新记录直接插入到叶子节点的代价,因此,无论是最好或者最坏情况下该更新策略均需要H+1次磁盘I/O.需要指出,由于TPU2M树中使用的空间清理器在索引树当前操作节点中进行清理工作,因此清除旧记录并不需要多余的磁盘I/O.索引树的高度通常在4层左右,因此基于备忘录更新在平均情况下具有最小的磁盘I/O次数.5实验仿真与性能评估为切实评价TPU2M索引树在不确定移动对象频繁位置更新情况下的索引性能,我们设计了一组实验,对文中提出的算法给出了验证分析,同时对TPU树,ABx树和TPU2M树进行了性能比较.实验数据集采用文献[15]中基于道路网络的移动对象产生器随机生成.在10000km×10000km空间区域内模拟1M~10M移动对象的运动情况,其中默认值为1M.每个移动对象的不确定区域是半径为50km的圆圈,概率密度分布为平均分布或高斯分布.在初始时刻t每个移动对象选择一个目的地开始运动,到达目标之后发出位置更新请求并重新随机选择一个新目的地运动.其中,移动对象运动目的地设为5000个MBR,移动速度在[20,50]之间均匀分布.值得注意,移动对象可以从系统中消失,也可以加入新的移动对象,但移动对象总数小于系统设定的值.实验中的主要参数如表2所示,其中粗体字为默认值.不确定对象的数量数据空间不确定半径检查率更新次数移动距离对移动对象数据集,我们基于Gist分别构建TPU树和TPU2M树索引,节点大小均设置为1KB,中间节点扇出两者均为27,叶子节点的扇出随Page7U-catalog的大小而变化,并设定U-catalog=10,页面缓存大小均为100KB.基于Bx树构建ABx树索引,节点大小设置为1KB.索引树根节点常驻缓存中,并使用最近最少使用(LUR)缓存替代策略.实图3检查率的影响检查率ir的大小直接影响到辅助内存结构UM的大小,TPU2M索引树的查询和更新时间以及失效率or.图3比较了不同ir大小情况下内存结构UM的大小和失效率.正如第4节中分析的结果:UM的大小以及失效率均与检查率成反比增长.从实验可以看出,随着检查率的逐渐增加,内存结构UM的大小与索引树的旧记录比率呈下降趋势.这是由于较大的检查率会引起空间清理器更加频繁地删除UM中多余的记录项和清理叶子节点中过时的移动对象旧记录,很大程度减少内存结构的大小与TPU2M树的旧记录占用率,从而为移动对象新记录开辟更多新的插入空间.不难发现,在检查率增至20%时,移动对象旧记录比率急剧下降至2%,此为UM尺寸的大小和TPU2M树产生较为理想的更新与查询效率提供了最佳时机,因此在下面的实验当中,我们均设定检查率ir=20%.5.1更新代价为全面验证TPU2M树在更新策略上的最优性,我们分别比较了不同更新次数、更新幅度以及不同的移动对象个数对索引树更形性能的影响.其中,图4(a)比较了不同索引方法在每隔100k次更新后的更新性能.可以看出,TPU2M树的更新性能在频繁更新中相对于传统索引TPU树和ABx树具有绝对的优势.图4(b)比较了在不同移动更新幅度情况下TPU2M树与TPU树和ABx树动态更新所需要的平均磁盘I/O次数.特别地,不确定移动对象位验硬件环境是:Intel(R)Pentium(R)Dual-Core2.50GHz的CPU,内存为2048MBRAM;软件环境是:WindowsXP操作系统和VisualC++6.0集成开发环境.置更新保持较高的频率,平均更新次数在100k左右.可以看出,TPU2M树的更新所需平均磁盘I/O维持在50次左右不变,具有很好的动态更新性能.而TPU树和ABx树则始终保持着相对较高的磁盘I/O次数.这是由于TPU2M树的更新过程利用UM内存结构,在索引树中无需查找旧记录而直接插入不确定移动对象的新记录.而且,TPU2M树在较小位置更新幅度的情况下,可以采用更新代价较低的自底向上方法,因此更新代价可以得到进一步减少.而TPU树和ABx树由于传统的自顶向下更新过程,使得更新代价相对最高.图4(c)比较了在逐渐增加不确定移动对象数量的情况下3种索引的更新所需平均磁盘I/O次数.不难看出,TPU树和ABx树的更新代价随着不确定移动对象个数的增加趋于增加的趋势,这是由于所查找定位节点个数的增加使得更新代价逐渐增加,而TPU2M树的更新代价基本不受移动对象个数的影响.这是由于TPU2M树的更新代价由插入新记录和清除旧记录两部分组成,而这两阶段的代价正如第4节分析显示并不受移动对象个数的影响.因此TPU2M索引树具有良好的可扩展性.图4(d)给出了在不同移动对象数量情况下TPU2M树需要辅助结构内存空间的大小.不难发现,内存结构UM大小与不确定移动对象个数成线性增长,所以内存结构UM的大小相对于索引树TPU2M的大小同样是可扩展的.Page8图4更新性能比较5.2查询代价索引树中旧记录的存在势必影响TPU2M树的概率查询效率.图5显示了TPU2M树与TPU树和ABx树3种索引结构在回答200个窗口查询所需要的平均磁盘I/O次数.查询窗口范围大小记为qRlen,速度矢量记为qVlen,窗口查询时间记为qTlen,概率阈值记为Pc(Pc的默认值设为0.6).其中,图5(a)和(b)比较了3种不同索引方法在每隔100k次更新后的查询性能,可以看出,TPU2M树在频繁更新下的查询所需平均磁盘I/O次数只是略高于TPU树和ABx树.图5(c)和(d)比较了3种不同索引方法在更新幅度不断增加情况下的查询性能.可以看出,即使发生了较大位置幅度的频繁更新,TPU2M树一直保持着较好的查询性能,平均磁盘I/O次数只是略高于TPU树和ABx树.这是由于较低的旧记录比率2%保证了TPU2M树中包含有限的不确定移动对象旧记录.值得一提的是,TPU2M树的查询性能在不确定移动对象的更新幅度小于100km之前,基本上与TPU树和ABx树具有相同的概率查询效率,并只在位置更新幅度达到100km时略微高于TPU树和ABx树.这是由于TPU2M树在位置更新幅度达到100km之前,大部分采用自底向上的更新方法动态扩展叶子节点及父节点大小以适应新的位置信息记录,之后则删除索引树中多余的旧记录,从而保证了内存结构UM具有较小的容量,进而使得内存结构和索引树本身更加紧凑,具有与TPU树和ABx树相当的概率窗口查询处理效率.5.3最近邻查询图6显示了TPU2M树与TPU树和ABx树3种索引结构在回答50个最近邻查询所需要的平均磁盘I/O次数.由于不确定移动对象是随机地分布在一个区域中的,因此最近邻查询返回的是当前时间点上有可能成为查询点最近邻居的移动对象.指定的概率阈值记为Pc(Pc的默认值设为0.5),那么查询结果是返回所有最近邻概率大于等于0.5的移动对象.其中,图6(a)比较了3种不同索引方法在每隔100k次更新后的最近邻查询性能,跟窗口查询具有相似的结果,TPU2M树在频繁更新下的查询所需平均磁盘I/O次数略高于TPU树和ABxPage9图5查询性能比较图6最近邻查询性能比较树.不难发现,由于最近邻查询的计算复杂度高于窗口查询,因此3种索引结构在处理最近邻查询时的平均磁盘I/O次数也较高.图6(b)比较了3种不同索引方法在更新幅度不断增加情况下的最近邻查询性能.跟窗口查询相似,即使移动对象发生了较大位置幅度的频繁更新,TPU2M树一直保持着较好的查询性能,平均磁盘I/O次数只是略高于TPU树和ABx树.不难发现,TPU2M树的最近邻查询性能在更新幅度不超过100km之前,基本上与TPU树和ABx树具有相同的处理效率.这是由于TPU2MPage10树在位置更新幅度未达到100km时,基本上采用自底向上的更新方法动态扩展叶子节点及其父节点以适应新的位置信息记录,随后删除多余的旧记录,从而保证了内存结构UM较小的容量,使得内存结构和索引树更加紧凑,从而具有与TPU树和ABx树相当的概率最近邻查询处理能力.6结论本文在不确定移动对象当前及未来位置索引技术TPU索引树基础之上,针对不确定移动对象频繁位置更新带来的系统效率低下问题,提出了一种支持频繁大幅度位置更新的移动对象索引策略———TPU2M树.与传统的索引方法相比,其增加了一个记录移动对象状态特征的更新备忘录UM内存结构,并提出了一种改进的基于备忘录(MMBU/I)更新/插入算法.实验仿真表明,采用MMBU/I更新算法的TPU2M索引树频繁更新效率大大高于TPU树和ABx树,并且查询效率与同类索引大致相当.在基于位置的服务、移动计算等具有频繁更新要求的应用领域,TPU2M索引树具有较高的实用价值和广泛的应用前景.下一步的研究方向是在不确定移动对象的环境中,将问题扩展到支持局部位置更新及高级概率查询如Top-K查询、Skyline查询等.
