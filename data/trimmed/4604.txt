Page1基于可验证计算的可信云计算研究1)(北京邮电大学计算机学院北京100876)2)(北京邮电大学软件学院北京100876)3)(北京邮电大学可信分布式计算与服务教育部重点实验室北京100876)摘要云计算的可信性直接决定了其能否被广泛使用和推广.如果能使得云计算用户验证存储在云平台的数据的完整性或者在云平台执行的程序的正确性,将会大大加快云计算的应用.而可验证计算协议可检测出远程服务器返回的程序执行结果是否正确,且不需要将远程服务器所执行的程序再重新执行一遍.因此,近年来,可验证计算协议引起了学术界和工业界的广泛关注,成为实现可信云计算的一种建设性思路.文中在系统梳理和总结可验证计算协议国内外相关研究的基础上,依据可验证计算协议的实施流程对其按照编译处理和证明系统分类.其中,依据可验证计算协议使用的编译器的复杂程度,分为使用简单编译器的可验证计算协议和使用复杂编译器的可验证计算协议;依据证明系统的分类,主要研究基于交互式证明系统的可验证计算协议和基于论证系统的有预处理的可验证计算协议.随后对依据证明系统划分的每一分类,围绕基本定义、典型协议原理及流程、适用应用场景、性能分析等问题,对基于可验证计算的可信云计算进行了综述.最后,总结和展望了待解决的关键性问题和未来的研究方向.上述工作将对可验证计算协议在云计算中的应用起到一定推动作用.关键词云计算;可验证计算;云安全;交互式证明系统;论证系统1引言云计算[1]作为一种新兴的网络计算商业服务模式,使得用户可以随时在远端的云服务器存储数据和运行程序.但这种新兴的计算模式在给用户带来诸多便利性的同时,也带来了一些新的安全挑战.用户可能担心云计算平台本身的安全性,比如云平台漏洞和错误配置、管理员的恶意行为等等,而这都可能直接导致用户数据的完整性和隐私性受到危害,导致用户应用程序无法正确执行[2-3].这就产生了一个问题:用户如何相信云提供商执行的程序结果是正确的?如何确保存储在远端的数据的完整性和私密性?检测远程服务器返回的结果是否正确的传统解决方案有以下几种:(1)采用审计的方法,即随机选取服务器执行的一小部分程序进行验证,这就可能发生错误执行的程序没有被服务器验证的情况,所以说这种方法必须假设错误执行的程序的发生频率是很小的;(2)利用可信硬件[4-5]和远程证明[6-7]来保证远程服务器运行的程序是正确的,但是这种方法必须假设云提供商是完全可信的,由于硬件基础设施是在云提供商的控制之下,如果云提供商内部人员恶意控制了可信硬件(如CPU、TPM),就无法保障云提供商运行的程序的机密性和可验证性.而且还需要假设存在一个可信链,而运行时可信链的建立在可信计算领域依然是一个难题.事实上,在实际的云计算应用场景中这两个假设通常是无法满足的.在云计算场景中,用户无法完全相信云提供商,即使用户出于声誉的考虑相信云提供商本身,也无法相信其内部管理人员;(3)采用冗余计算的方法,用户可以让多个远程服务器把相同的程序执行多次,然后检测他们返回的结果是否一致[8-12].但这在云计算中也是行不通的,云计算中的软硬件平台配置通常是相同的,而这违背了冗余计算中错误必须Page3是不相关的假设,且远程服务器很容易窜通,合谋返回一个错误的程序执行结果.而可证明数据持有[13](ProvableDataPossession,PDP)方法和可恢复证明[14](ProofofRetrievability,POR)方法可以用来确保存储在远端的数据的完整性,避免云提供商删除和篡改数据.相比PDP方法,POR除了能确保数据的完整性之外,还能确保数据的可恢复性,但是PDP和POR无法确保在云提供商端执行的程序的正确性.另一方面,基于复杂性理论的交互式证明系统(InteractiveProofsystem,IPs)[15-19]和概率可验证证明系统(ProbabilisticallyCheckableProofsystem,PCPs)[20-23]以及密码学理论[24-29]构造的可验证计算协议能以很高的正确率检测出远程服务器返回的程序执行结果是否正确并且不需要对远程服务器(云提供商)做任何假设.可验证计算协议致力于设计验证者与证明者之间的协议,协议允许在计算能力上相对较弱的验证者(如云计算中的用户)将其程序发送到一个计算能力强大的,但不可信的证明者(例如云提供商),并要求证明者执行其发送的程序.所设计的协议应确保证明者不但返回程序的执行结果给验证者,并且使得验证者相信这个程序执行结果是正确的.其主要目标是使得服务器在发送程序执行结果的同时提供程序正确执行的证据,而用户验证证据的过程必须要比用户自己执行程序的开销小(当然有时由于资源比如存储的限制,用户根本无法自己执行程序,在这种情况下是指和假设用户有足够的资源执行程序时的开销相比要小).近年来,由于云计算的兴起和复杂性相关理论以及密码学理论的进一步发展,可验证计算协议的研究重新受到了关注.Ishai等人[30]阐述了如何使用简单的PCPs和密码学承诺来验证通用计算;Goldwasser等人[18]把交互式证明系统应用于用特定电路表示的计算中;Gentry等人[31-32]在全同态加密领域的突破性研究使得起源于GGP的通用计算的非交互式协议的构造有了理论依据[22,25].这些研究具有重大意义,基于这些理论的改进使得可验证计算协议最终得以适用于某些特殊构造的应用场景,但是仍然无法适用于通用的云计算场景.然而可验证计算协议领域的工作目前进展很快,相信在不久的未来将可以应用于云计算的实际场景中.目前使用可验证计算的思路和方法来构建可信云计算,解决云计算中所有权和管理权分离所带来的信任问题的工作还很少.所以本文的主要贡献是系统的梳理和总结可验证计算协议领域的工作.出于本文的研究目的,更关注适用于构建可信云计算的可验证计算协议或者对可信云计算的构建提供建设性思路的可验证计算协议;关注性能合理的,适用于通用场景的,和无条件的(即除了相关的密码学协议假设不做任何假设)可验证计算协议;关注只需要一个证明者,并试图将理论付诸实践的协议.不关注基于特定计算的可验证计算协议[32,34-41],不关注基于多个证明者的可验证计算协议[33],不关注应用同态加密的可验证计算协议,因为同态加密目前还无法适用于实际场景.接下来的章节中,本文首先介绍可验证计算协议的问题描述和设计原则,接着介绍如何生成协议需要的计算模型,然后依据可验证计算协议的协议流程分别对目前的协议做出分类,之后详细说明每个分类的进展情况.最后,总结和展望该领域目前存在的问题和未来的研究方向,以期对其在国内的研究起到一定推动作用.2问题描述和协议设计原则问题描述:验证者V把程序f和输入变量狓发送给证明者P,P计算f(狓),并把f(狓)赋值给变量狔,返回狔给V,然后V和P以如下方式进行交互:(1)如果狔=f(狓),那么P应该能向V证明狔的正确性,即使得V接受狔.其中,证明可以通过回答V提出的一些问题完成,也可以通过给V提供一个证书完成.(2)如果狔≠f(狓),V能以很高的概率拒绝接受狔.可验证计算协议的设计必须满足3个基本原则:(1)协议应该使得验证者的开销比其在本地执行程序f(狓)的开销要低,但可以允许证明者为达到协议的目标产生合理的开销,因为提供运行程序的正确性保障本身就需要用户付出一定的代价,在云计算实际场景中,表现为云提供商可能会对需要提供程序正确执行证据的用户收取额外的费用;(2)不能假设证明者完全遵守协议,也就是说证明者可能是恶意的,这和云计算中不能假设云提供商是完全可信的实际场景也是十分吻合的;(3)f应该是通用程序,然而在具体的协议设计中,可能需要对f表示的程序做一些假设,从而通过限制可验证计算协议适用的应用程序种类使得协议的性能达到实际应用场景的要求,但是可验证计算协议的设计原Page4则依然是尽量能表示通用程序.通常的安全保障工具比如说病毒检测关注的都是不正确的行为的识别和防范,可验证计算协议则有所不同,其不关心证明者可能的不正确行为,比如犯了什么错误,出现了什么故障等等,而只关心其执行程序的结果是否是正确的,却无法推测程序错误执行的原因.这和云计算中用户对于程序执行的要求也是相符的.3协议流程和关键3.1可验证计算协议流程可验证计算协议的流程主要包括编译处理和证明系统,具体流程如图1所示.首先是编译处理阶段,验证者V和证明者P将高级语言(比如C语言)编写的程序转换成一组布尔电路集(根据协议的不同,也可以是其他计算模型比如算术电路集或者约束集等).具体方法在第4节详述.接下来,P和V进行一系列协议交互,不失一般性,这里用布尔电路集犆表示程序f.V把输入变量狓传输给P,P计算犆,输出程序执行结果狔和犆正确执行的一组轨迹{犆,狓,狔}给V,{犆,狓,狔}也称为犆的一个可满足性赋值狕(步骤②).其中,犆正确执行的一组轨迹是指犆的输入线路被赋值为狓,输出线路被赋值为f(狓)时,电路集中所有电路门的赋值集合.在程序执行的过程中,证明者P获得了正确计算电路的执行轨迹{犆,狓,狔}(步骤②).如果P声称的输出狔是不正确的,即狔不等于f(狓),那么对于{犆,狓,狔},就不可能存在一个有效的执行轨迹(电路犆正确计算的一个证明).因此,如果P能够对{犆,狓,狔}构建一个有效的执行轨迹,那么就一定能使得验证者V相信它返回的结果是正确的.显然,电路正确计算过程中的各个门的赋值本身就能说明存在有效的执行轨迹.但是,如果需要V依次验证所有电路门在计算电路过程中的值,进而确定程序是否正确执行,这个工作量和V本地执行f是相当的,这就违背了可验证计算协议设计的基本原则.所以,图中第③步就需要证明者对程序执行轨迹编码,生成一个很长的字符串,并使得不同的执行轨迹生成的编码在所有不同的位置的取值是不相同的.这样,验证者就可以通过检查随机选择的编码的特定的位置的取值,来验证执行轨迹的有效性,进而对返回的结果采取特定的测试来确定证明者返回的结果是否正确.但是由于编码很长,读取其需要的时间开销也相应很大,验证者就不可能取回程序执行轨迹的所有编码来完成验证过程.而且,出于时间开销的考虑,证明者也不可能把执行轨迹的所有编码都写出来,因为验证者只需要查询几个特定位置的值(检查编码的一小部分)就可以完成验证,如果把所有编码都写出来,大部分工作就是被浪费的.然而,不可能让验证者询问证明者特定位置的编码包含的结果,因为元素的随机性在协议中是非常重要的,可以用来防止证明者的欺骗.假如验证者的询问事先被证明者了解到,证明者就可能设计好相应的回答来欺骗验证者.因此,验证者必须仔细慎重的选择(构造)要查询的编码位置(第④步).而这也是可验证计算协议设计的核心问题.3.2可验证计算协议的理论依据理解可验证计算协议的原理和流程关键在于理解两个等价关系,如图2所示.如3.1节所述,可验证计算协议的流程主要包括编译处理和证明系统.其中,编译处理阶段,编译器完成高级语言程序到电路集或者约束集(可以看做方程组)等计算模型的转化,其实现的理论依据在于等价关系:程序执行的正确性等价于电路集或者约束集可满足问题.定义1.电路集是可满足的.给定输入狓,输出狔,存在一组所有中间电路线的赋值狕,使得电路线所有的电路门都可以同时满足,则称电路集是可满足的,且狕称为犆(犡=狓,犢=狔)的可满足赋值[42].定义2.约束集是可满足的.给定输入狓,输出狔,存在一组犣=狕,使得C(犡=狓,犢=狔)中的约束能Page5同时满足,则称约束集是可满足的,且犣=狕称为犆(犡=狓,犢=狔)的可满足赋值[43].定理1.程序执行的正确性等价于约束集/电路集是可满足的,对于所有的狓,狔,狔=f(狓)当且仅当约束集/电路集犆(犡=狓,犢=狔)是可满足的[42-43].证明系统的主要作用在于依据编译器输出的采用特定计算模型表示的应用程序,设计验证者V(等同于用户)和证明者P(等同于云提供商)之间的交互协议,保证用户应用程序执行的正确性.其理论依据在于使用代数化方法构造如图2第2个等价关系:电路集或者约束集可满足问题等价于一类很难计算但是容易验证的问题,比如说QAP(QuadraticArithmeticProgram)理论中的整除关系.至此,验证程序是否正确执行的问题转化成了验证特定代数关系是否满足的问题.4计算模型生成原理流程为了应用IPs和PCPs理论构造可验证计算协议,必须先把高级语言程序转换成IPs和PCPs判定器可以接受的计算模型,比如说电路集和约束集.Cook-Levin理论[44]表明这种转换理论上是可以的,因为任何程序f都可以用图灵机来模拟,同时图灵机可以转换成布尔电路,且不会超过程序的步骤.目前可验证计算协议中编译器都是基于Fairplay和Benjamin编译器设计的,常用的计算模型主要有电路集和约束集两种.Fairplay和通常的硬件编译器[45-51]不同,不能使用寄存器,没有时序逻辑,通过FairplayWeb网站[52]可以获取该编译器.Fairplay可以用来把高级语言编写的程序编译成一组布尔电路集,但这种高级语言并不是通常所说的高级语言,而是一种类似Pascal或者C语言的子集的程序语言,称为(安全函数定义)SFDL语言.Benjamin提出的编译器[43]继承并改进了Fairplay编译器,用于把高级语言表示的程序编译成一组约束集.这种编译器也引入了一种类似SFDL的高级程序语言,称为扩展函数描述BFDL.不失一般性,本文以Benjamin编译器为例说明从高级语言程序(C语言为例)转化成约束集的原理和工作流程.BFDL的语法很容易理解,很多地方都是从C和Pascal语言继承的.BFDL语言使用C风格的语法,是一种静态类型语言,支持类型引用.其程序结构如图3:第一部分是类型声明,定义将要使用的数据类型、支持布尔型、整型、结构体和数组.BFDL编译器不支持数据下标为变量的程序代码.图4是Benjamin编译器的执行流程.①使用BFDL编译器把BFDL语言表示的代码经过函数内联、循环展开等步骤编译成单赋值列表;②使用修改过的SFDL中的优化方法来减少单赋值列表中的赋值描述数量;③把赋值描述列表转换为可验证计算协议比如Zaatar和Ginger可以接受的约束集.下面以计算一个m=14的输入数组中出现目标关键字的次数的程序为例说明从C语言到约束集的编译处理过程,图5是C语言描述示例,图6是相应程序依据定义[43]编译的BFDL语言描述实例.图7和图8显示了上述范例从BFDL代码到单赋值形式(程序的中间表示)、再从单赋值形式到约束集的转化.从图8中,可以看出图6中第19行的循环已经展开,if语句通过构造一个复用转化器表示成单赋值形式.图7[43]中列出了布尔表达式和约束的对应关系.其他诸如条件语句、不等测试、比较操作和约束的对应关系见文献[43].而从单赋值形式到约束集的转化由上述规则直接转化.表1给出了布尔表达式和约束的对应关系.Page6布尔函数FALSEX2,NOTX1NOTX1X1,NOTX2EQUALX1→X2烄犆=烅Mcond烆5可验证计算协议分类5.1依据编译器复杂程度分类由第3节所述,可验证计算协议主要流程包括编译处理和证明系统两个阶段,所以下文将依据协议流程对不同协议分类,如图9,并说明每种分类的特点和典型协议.本文提到的协议中的编译处理都是直接使用Fairplay和Benjamin编译器或者对其改进后使用,生成证明系统可以接受的计算模型.依据可验证计算协议使用的编译器的复杂程度,可以分为简单编译器的可验证计算协议和复杂编译器的可验证计算协议.简单的编译器是指不支持内存随机存取的编译器,即不考虑内存概念,假设程序的输入都来源于验证者.简单编译器的可验证计算协议包括GKR[18]、CMT[53]、Thaler[54]、Allspice[55]、Pepper[56]、Ginger[57]、Zaatar[58]和Pinocchio[59]等,其中Pinocchio是第一个直接接受C语言程序的协议,而其他协议则需要先将C语言程序转化为另一种指定的高级语言比如BFDL语言,然后再转化成证明系统可以接受的计算模型.GKR使用算术电路作为计算模型,相比较之前协议使用的布尔电路减少了程序编译的开销.CMT、Thaler、Allspice、Pepper基本沿用了GKR中的编译器,且Pepper对算术电路进行了简化,Ginger扩展了算术电路模型表示的程序种类,使得模型包含浮点数类型,不等测试,逻辑表达式,条件语句等等,因而使得模型能表示的程序更加接近于通用程序.Allspice编译器通过增加了一个静态分析器来自动确定并运行Zaatar或GKR两个协议中效率较高的一个,增加了协议的可扩展性.复杂编译器的可验证计算协议包括Pantry和BCGTV[61].复杂的编译器支持内存操作,这更符Page7合实际应用场景.Pantry中的编译器改进了Zaatar和Pinocchio使用的编译器,结合了不可信存储中使用的技术[62-65],使用Merkle-hash树来支持内存随机存取.通过构建一个二叉树来表示内存,二叉树的每个叶节点存储相应内存地址的值,每个内部节点存储作用于其子节点的抗冲突哈希函数的值.每当验证者通过(根节点值、内存地址)二元组访问一个内存地址(叶节点)时,证明者可以通过提供沿叶节点到根节点“证明路径”的所有值来“证明”其返回值是正确的.证明者欺骗验证者的唯一方法是通过找到哈希函数中的冲突.由于Pantry使用的抗冲突哈希函数的计算函数可以有效地表示成约束集,从而使得内存操作也可以有效的表示成约束集.如果把内存操作也看作普通的程序,就可以实现包含内存操作的程序的可验证计算了.更重要的是,Pantry支持“远程输入”,这使其能更好的支持MapReduce程序,且在MapReduce程序中为了降低开销定义了GetBlock和PutBlock两种元操作来代替构造Merkle-hash树.BCGTV基于文献[28,58,66],把程序编译成一种特殊的电路表示[67],并把这种计算模型称为TinyRAM.BCGTV适用于通用程序,它支持所有的C程序,包括独立于数据的循环和RAM,但不支持“远程输入”.然而BCGTV的通用性是通过牺牲协议性能来达到的,这使其编译器的开销通常比Pinocchio和Zaatar编译器开销高好几个数量级.从性能考虑,BCGTV仍无法用于实际应用程序.5.2依据证明系统分类依据可验证计算协议的证明系统的构造方法不同可将协议分为3大类:基于交互式证明系统的可验证计算协议、基于论证系统的有预处理的可验证计算协议和基于论证系统的无预处理的可验证计算协议.本文不讨论基于论证系统的无预处理的可验证计算协议,因为无预处理的论证系统大多基于shortPCPs[68-71],由于其开销过大,仍处于理论研究阶段,还无法用于实际的应用程序.IPs和PCPs理论表明对于给定的数学论断,证明者有能力使得验证者相信论断的正确性.IPs和PCPs理论为可验证计算协议证明系统的构造提供了非常强的保证,使其可以抵御任意的恶意证明者.本文说任意的恶意证明者是指不仅包括故意作恶的证明者,还包括不可预期的行为导致的故障或错误.交互式证明系统由Goldwasser、Micali和Rackoff[19]以及Babai分别提出[15].两种定义是等价的[72],其中Babai的系统又称为公开投币系统(Pulic-CoinSystem).定义3.一个语言L{0,1}的交互式证明系统[19]是一个由证明者P和验证者V组成的交互过程,对于任意的输入串x,他们的交互过程满足如下的条件:(1)验证者V是一台多项式时间的、带外部信息源的随机图灵机;(2)证明者P的计算能力无限制;P是一个串函数:{0,1}→{0,1};(3)正确性要求:①完备性.如果x∈L,存在P,证明者P能以至少2/3的概率使得验证者V接受;②可靠性.如果xL,则对于任意P,至多只能以1/3的概率使得验证者V接受.文献[19]进一步证明了其完备性可以达到1-1/nk,可以把交互式证明系统记为k-(V,P)(x),其中|x|=n,在计算过程中至多交互k(n)次,k(·):N→N是一个多项式时间内可计算函数.为了描述方便,本文把交互式证明系统k-(V,P)(x)称为一个含有外部信息源的判定器,判定器V(·,·)按如下方式工作:(1)在输入带上放置输入x,外部信息源记为π,π也称为证明串,放置在一条专用证明带上,这里证明带充当证明者P;(2)计算过程中产生w个地址:i1,…,iw;依照i1,…,iw(i1,…,iw依赖于随机选择),从证明带上获取一个“局部证明”:z=π[ir(3)计算V(x,z).在多项式时间内验证一个解是否正确的问题存在交互式证明系统[16-17],由上述可见,应用交互式证明系统来设计可验证计算协议,实际上就是设计一个判定器.对于给出的某个程序的计算结果,P总是要设法让V相信程序执行结果的正确性(无论这个结果本身是否正确).交互式证明系统通常含有一个随机操作机制,因为V可能有很多问题(即地址)需要P来证明,但又没有足够的时间验证,所以只能随机的选择一些问题,同时V依靠使用随机串机制来防止P的“欺骗”.P通过上述多轮交互过程,判断P给出的证明过程是否足以证明程序正确执行.论证系统[24,34,73-74]实际上也是一种特殊的交互式证明系统,其中,交互的次数最多为两轮,证明者P的计算能力限制在多项式时间内.在本文中,我们Page8将基于论证系统的可验证计算协议和基于交互式证明系统的可验证计算协议分成不同的类别讨论,主要基于以下考虑:(1)本文中讨论的基于交互式证明系统的可验证计算协议,其交互轮数是指多于两轮的交互,而基于论证系统的可验证计算协议,其交互的轮数被限制在两轮之内,由此带来的协议的性能开销和支持的安全属性都会有很大的不同,在表2详细对比;(2)基于交互式证明系统的可验证计算协议和基于论证系统的可验证计算协议由于协议交互的轮数不同,使得协议具体的构造也有显著的不同,这在本文后续关于协议的具体介绍中会有体现.表2基于交互式证明系统和基于论证系统的协议比较计算能力初始阶段开销证明者开销程序种类交互轮数零知识性公开可验证性文献[30]说明所有有效的论证系统的构造都依赖于PCPs.PCPs以及基于此的论证系统实现起来相当复杂,是无法用于实际应用场景的可验证计算协议的,所以基于论证系统的有预处理的可验证计算协议使用的都是特殊构造的PCPs.所谓预处理,也称为协议的初始阶段,是需要证明者预先做一个承诺或者验证者预先加密询问向量.依据预处理的方法不同,可验证计算协议又可以分为使用基于承诺方案的论证系统的可验证计算协议和使用加密询问向量的论证系统的可验证计算协议.有预处理的协议的优势在于其适用于数据并行度高的应用程序,因为此类情形下,验证者能把初始阶段的开销分摊给同一程序中的多个实例,这样才能使得其开销可以被实际应用程序所接受(即当同一程序被独立应用于许多不同的输入实例时有效),这和云计算应用场景也十分吻合.承诺方案[75]是一种基本而用途广泛的密码学原语,是理论密码学中重要的基本模块之一.承诺方案由两个概率多项式时间(ProbabilisticPolynomial-Time,PPT)算法组成,分别称为承诺方和接收方.承诺方案允许承诺方对选定的值或者声明进行承诺(即计算承诺函数的值).承诺方案有两个阶段:承诺阶段和公开阶段.在承诺阶段,承诺方发送其秘密输入(选择的值或者声明)m的承诺值给接收方;在公开阶段,承诺方可以公开其秘密输入m.接收者计算承诺值,并与承诺方发送的承诺值相比较,若相等则承诺被接受否则被拒绝.承诺方案要满足隐藏性和绑定性两个性质.隐藏性即接收方根据承诺值不能计算关于承诺方秘密输入m的信息.绑定性即承诺方一旦做出承诺,则无法改变其值,也就是说承诺方不能将承诺值公开为两个不同的m和m.基于承诺方案的论证系统的交互一共有两轮,也称为基于交互的论证系统,承诺方的角色由证明者代替,接收方的角色由验证者代替,验证者首先需要证明者对执行轨迹(证据)的编码作出一个承诺.在第2轮中,验证者询问其要查询的证据的位置,然后证明者回答证据在特定位置的值,证明者的回答必须和承诺一致.使用加密询问向量的论证系统由于验证者在协议的初始阶段发送加密后的询问向量给证明者之后,无需验证者在每个实例再重新发送询问向量,从而也称作无交互的论证系统.然后,在之后的验证阶段,验证者和证明者使用复杂的密码学协议实现如下的步骤:证明者响应询问向量,但不知道具体要询问的证据的位置,使用证明者的答案,验证者使用PCP来验证答案,正如使用基于承诺方案的论证系统的协议一样.使用基于承诺方案的论证系统的可验证计算协议和使用加密询问向量的论证系统的协议的比较如表3所示,前者使用了较少的加密机制,前者验证者发送明确的询问向量,而后者需要证明者计算加密过的询问向量的值.然而,后者提供了前者没有的功能,支持公开验证性和零知识性,且减少了交互的轮数,允许初始阶段的开销在相同的计算中的所有计算实例分摊.表3基于承诺方案和使用加密询问向量的协议比较交互轮数密码学公开验证零知识初始阶段基于交互式证明系统的可验证计算协议与基于论证系统的有预处理的协议的比较如表2所示.前者优点主要有3个;(1)即使对有无限计算能力的证明者也是安全的,而后者只是针对多项式时间的证明者是安全的;(2)交互式证明系统对简单的并行计算能完全不需要预处理阶段,对数据并行的计Page9算预处理阶段开销也相对较小,而论证系统中验证者固有地需要一个预处理阶段且开销很大;(3)交互式证明系统在它适用的情况下可使得证明者的开销大大减少,并且事实上对像矩阵乘法这样的基本操作完全可以避免编译成电路的开销.具体而言,Zaatar的证明者是比没有正确性验证的计算慢大约3个数量级,这与CMT中实现的GKR中证明者的开销大致相符,但由于生成计算模型的开销,它比CMT为“规范化”电路实现的交互式证明系统所能达到的速度要慢且开销大(规范化电路是指易于用加法器和乘法器计算的电路).交互式证明系统也有其固有的缺点:(1)它们只适用于深度小的电路(即并行计算);(2)它们不支持“非规范化”电路,实际上缺乏对非规范化电路的支持是使用交互式证明系统所固有的.这意味着,某些种类的计算,如那些涉及许多随机访问存储器或排序/比较操作的计算在交互式证明中是有一定问题的;(3)交互式证明系统不能支持有些属性像Pinocchio的零知识性和公开验证性;(4)交互式证明系统对证明者和验证者之间的互动需要多轮的对数运算,而论证系统通常只需要一轮或者两轮交互.下两节将按照可验证计算协议依据证明系统的分类详述每一种分类的相关研究成果,其中,在对每一种分类的典型系统的描述基本遵从如下顺序:从效率最高的但最不通用的协议到更为通用但效率较低的协议.6基于交互式证明系统的可验证计算协议本文首先说明交互式证明系统是如何使验证者V确信它接收到的程序执行结果是正确的,如图10所示.假设要执行的程序是计算输入为狓的函数f.首先,验证者在把输入狓和f传输给证明者,同时随机选取关于输入的低阶多项式扩展函数的值[17](比如加权和)作为秘密s,s不依赖于要执行的程序,因此无需在输入要执行的程序之前选取秘密s.接下来,P和V进行一系列交互(d轮,d为电路层数),这些交互的目的在于V控制并引导P从生成V0(0,0,…,0)=犚0递归到Vd(犣d)=犚d(从一层的电路门的值的低阶多项式扩展函数的某个点的值递归到下一层的电路门的值的低阶多项式扩展函数的某个点的值,其中低阶多项式扩展函数是每层的线性组合,如加权和),Vd是输入x的低阶多项式扩展函数,V此时的任务就是计算Vd在特定点Zd的函数值,并检测和P的回复是否一致.在这个过程中,V发送给P询问向量犣i=(z1,z2,…,zm),P计算犚i=Vi(犣i),用犚i回复V的询问.这些询问向量(一共d个)都是相关的,V递归检测P对所有询问向量的回复是否一致.V随机生成的询问向量使得P对第一个询问向量的回复包含所执行的程序f的结果的声称值.同样的,P对最后一个询问的回复包含一个关于V的输入变量的低阶多项式扩展函数的某个点的值的声称犚d.如果P对所有向量的回复都是一致的,且声称的值犚d和犚d的真实值相匹配,然后P使得V确信其遵守了协议,即正确的执行了程序,因此接受结果.否则,V知道P在某个点欺骗它,因此拒绝接受.交互式证明系统在可验证计算协议中的理论应用起源于GKR协议[18],代表协议有CMT[53],Allspice[55],Thaler等人[54].Goldwasser、Kalai和Rothblum(GKR)在2008年提出了一个强大的交互式证明系统用于验证程序执行的正确性.其中,验证者的成本随着电路的深度呈线性增长(深度小意味着程序的并行性更好),所以该系统仅实现了在电路具有较小深度时的一个高效验证.而实际中云计算中的大多计算(应用程序)都表现出大量的并行性.GKR协议如图11所示,P和V就输入为两个变量(输入变量和声称的输出变量)的函数生成的分层算术电路达成共识.算术电路就像布尔电路一样,只是其输入是域F中的元素,而不是布尔值,且相比之前计算与或非操作,算术电路是执行域F上的加乘门运算.假设电路的输出层是层d,输入层是层0.GKR协议如下迭代运行,每一轮运行对应于电路的每一层.第1轮运行中,V引导P通过一系列的Page10询问向量和响应从声明电路的输出演绎到声明秘密s.V发送的询问向量可以看作有限域F中的随机向量,P的响应是低阶多项式的值,每一个返回的多项式的值依赖于相应的询问向量.第1轮中秘密s是层d-1的电路门的值的纠错码的几位的组合.然而V并不能直接计算这个s,要计算s必须计算电路的之前所有层,这样会使得可验证计算协议变得毫无意义.因此,V必须使得P能告诉它s的值.同时V必须确认P返回的s是正确的而不是恶意作假的值.这正是第2轮要实现的内容,V指引P从声明秘密s到声明d-2层电路门值的纠错码中的几位的组合,作为新的秘密s.如此迭代,直到输入层.这时,秘密正是输入纠错码的几位的组合,V就能自己预先计算这个秘密.任何良好的纠错码都满足属性:如果x和x在一个地方不同,那么Enc(x)和Enc(x)在很多地方都不同.正是由于Enc(x)的纠错码具有这样的属性,才使得V具有强大且准确的验证能力.这样,IP协议中,即使是P反转了一个消息中的一位,那么P不得不在随后的一个点做出不一致的声称,或者不得不在秘密s的值的声称的几乎每个地方都撒谎.这时V就能以很高的频率检测到P的欺骗行为.CMT协议和Thaler协议在2012年实现并改进了GKR协议.CMT协议假设Vi为每层电路的评估函数,并定义了两个连接谓词addi(g1,g2,g3)和multi(g1,g2,g3),使用连接谓词来表示评估函数,使得评估函数的形式正好与和校验协议一样,从而使用和校验协议的d个实例(d为电路的层数)来校验评估函数.协议的交互要使得从声明V0(0)=0演绎到声明V1,进而演绎到V2,直到输入的声明,这时,V就可以直接检查其是否正确.协议对CMT适用的计算种类性能比较高,很大部分是因为CMT协议不需要密码学操作和假设.CMT使得证明者的运行时间从O(S3)降低到O(SlogS),其中S为电路门的数目.实验表明,验证者的成本是非常低的,但CMT协议对GKR的实现有两个缺点:(1)证明者的运行时间仍然是一个瓶颈,其相比没有正确性保证的程序多花了大约3个数量级的开销;(2)除非该电路的布线满足“规范化”条件(电路易于加乘门计算),否则验证者需要一个高成本的预处理阶段来“提取”关于电路的布线信息.Thaler协议[54]进一步改进了CMT.Thaler对于某些种类的程序,证明者的开销可以降低为本地执行程序所需开销的常数级别,这在可验证计算协议领域是非常大的一个改进.首先,对于“规范化”电路(朴素naive矩阵乘法、模式匹配和FFT等满足此条件),证明者的运行时间可从O(SlogS)降低到O(S).具体而言,对于这些电路,证明者现在运行速度比不能保证正确性的电路计算大约慢10倍.第二,Thaler协议给出了用于矩阵乘法的一个简单协议,完全去除了电路表示的开销,使证明者除执行程序的开销外,只需O(n2)的开销来证明程序执行结果是正确的.然而,因为CMT协议最初就是为流程序设计的(验证者处理并丢弃输入),使得Thaler协议更适用于流程序,且对模型的要求有很多限制,要求电路必须是规范化的相似并行结构.显然,并不是所有应用程序都可以用这样的模型表示.2013年,Allspice协议[55]对CMT的限制条件作了改进,使得其通用性更强,并将CMT协议和后边提到的Zaatar协议集合成系统的子协议模块,通过一个静态分析器计算各自的效率来决定具体使用哪个协议.7基于论证系统的有预处理的可验证计算协议7.1使用基于承诺方案的论证系统基于承诺方案的论证系统,结合承诺方案和线性PCPs来构造论证系统,其在可验证计算系统中的应用起源于IKO协议[30],典型协议有Pepper[56]、Ginger[57]和Zaatar[58].Ishai,Kushilevitz和Ostrovsky(IKO)在2007年Page11提出了一个使用线性PCPs[20]代替shortPCPs[68-70](shortPCPs是之前的论证系统使用的非常复杂的复杂度理论)构造论证系统,从而减少了证据的长度和复杂性,使得可验证计算协议的实用性有了很大的改进.线性PCPs是指证据π是线性函数,即π(狇1+狇2)=π(狇1)+π(狇2),狇1和狇2是询问向量.一个线性函数π:π(狇)=犕·狇.特别的,当b=1时,π返回犕和输入变量的点积.对于线性函数,求其给定点的值是很容易的.下面详细描述IKO协议原理,主要分为两个部分:假设证据π是有限域上的线性函数,第一部分说明π的编码和构造线性PCPs;第二部分说明V如何和π(P)交互.首先,说明π如何编码原始证据(即电路的可满足性赋值)的,V首先构造一个多项式P(犣),使得P(狕)=0和高级程序编译生成的电路C的可满足赋值狕是等价的,π的构造必须能求解此多项式.P(犣)按如下方式构造:对于C(一共s个电路门)中的每个门,V构造一个变量犣i∈{0,1}来表示电路门i的输出.同时,V依照表4中的规则构造一个算术约束.如果门i是犣j和犣k的与门,那么V构造约束犣i-犣j·犣k=0;如果门i是犣j的非门,那么构造约束1-(犣i+犣j)=0;如果门i是第j个输入的输入门,那么构造约束犣i-inj=0;针对表示电路输出的最后一个门构造约束犣s-1=0.通过组合所有的约束来构造多项式P(犣):P(犣)=∑i犣=(犣1,…,犣s),每一个Qi(犣)由一个约束(比如犣i-犣j·犣k=0)给定.vi是V从有限域因为{Qi(犣)}都是度为2的函数,V可以把P(犣)表示如下:式中:{r2,r1,r0}由{Qi(犣)}和{vi}决定,r2∈s,r0∈.这样V可以通过询问〈r2,狕狕〉和〈r1,狕〉的值进而计算P(狕).为了说明编码,这里令〈狓,狔〉表示两个向量狓和狔的内积,令狓狔表示外积狓·狔T.由此,可以构造一个正确的证据神谕π来编(1),π码电路C的可满足赋值狕,写作〈狕,狕狕〉,意味着π=(π狕狕〉.以下解释P(狕)=0和狕是可满足赋值的等价性,首先这里假设给V的是语义正确但不可满足的π,也就是说,π=〈狕,狕狕〉,但是狕是不可满足赋值.那么要使得P(狕)=0,必然存在至少一个i使得Qi(狕)≠0,也就是说当且仅当vi·Qi(狕)=vi·Qi(狕),测试才可以通过.这种概率是很低-∑i≠i的,{vi}是在狕之后选择的,所以出错的概率不会超过1/.接着说明V和π(P)的交互.如图12所示在V发送f和狓并获得P执行的结果狔之后,V执行承诺方案的承诺阶段,验证者V选取随机向量狉∈应用同态加密算法(这里并不需要假设加密函数是全同态的[76])得到Enc(狉)发送给证明者P,P计算Enc(π(狉))并发送给V,然后V生成针对PCP方案的=14个询问向量和针对承诺方案的=14个询问向量,P响应V的询问向量.这轮交互也说明了V可以通过针对π的常数个询问向量就可以验证电路是否可满足.PCP方案验证分为4类:第1类称为电路测试,验证P(狕)=0是否成立.V选择狇12∈R狇14∈R(π(狇11)-π(狇12))+(π(狇13)-π(狇14))+r0是否等于0,即π路C的可满足赋值且π被正确的计算了,那么z同样满足所有的{Qi(犣)},P(狕)=0,验证就可以通过.如果狕不是可满足赋值,这同时意味着C不可满足,那么{vi}选择的随机性使得P(狕)不可能等于0,V以极大的概率拒绝.第2类称为线性测试[77-78],验证对于狕,πPage12〈·,u〉是否成立,V针对π验证响应结果.狇1,狇2∈R狇1+狇2,狇6=狇4+狇5.如果验证通过,V就可以确认(2)和ππ验证两个线性函数的形式是否正确,也就是说检测u=狕狕.V构造4个查询并响应验证结果.狇7,狇8∈s和狇10∈RR通过,电路测试才有效.线性测试、二次正交测试和电路测试是为了解除电路测试中π(2)和π(1)是互相一致的线性函数的假设.也就是说若假设π是无效的,它编码的一定是不可满足的赋值,而实际上一个恶意构造的神谕π可能不满足这个假设.第4类测试称为一致性测试,使用基于同态加密的承诺方案.测试P的响应是否和之前对(π的)PCPs的线性特征做出的承诺相一致.在承诺方案的公开阶段,V解密得到π(r),选取随机向量狇∈发送(狇,r+α狇)给P,获得P返回的π(狇)和α∈π(r+α狇),α是从域π(r+α狇)=π(r)+απ(狇)是否成立.通过并行运行承诺方案的多个实例(每一次V需要询问π都需要一个实例,仿佛P的响应是由若干个非共谋神谕提供的,每一个PCP询问由一个神谕提供),IKO协议把使用线性函数的PCP协议转换成论证系统[19,24].如果C是可满足的,那么V一定相信π,否则,C是不可满足的,V让测试通过的概率不超过常数κ(对于任意珘π).如果重复ρ次,构造询问μ=2·ρ个,那么可靠性错误ε=κρ.然而,IKO无法用于实际,其对验证者需要高开销的预处理阶段.即使是对一个m×m的矩阵乘法,验证者的开销也达到109·m6,要比本地执行矩阵乘法的开销多109·m3.这些开销来源于程序的编码编译、大量的密码学承诺和大量的初始阶段开销.虽然IKO协议通过承诺方案降低了证据的复杂性和长度,却使得并行承诺开销很大.承诺需要密码学操作,IKO协议过度的调用承诺实例使得协议无法用于实践.Pepper[56]和Ginger[57]在2012年改进IKO协议,使得协议有效的支持批处理,大大减小了验证者和证明者的开销.利用批处理(同一个程序的不同输入实例)来分摊验证者初始阶段的开销.通常需要大量实例并行才可以使得协议有实际意义.Pepper相比IKO的直接实现开销降低了1017.用算术电路代替布尔电路并简化算术电路减少了程序编码的开销;通过降低承诺实例的调用降低了承诺的开销,如图13可以看出,相比IKO,Pepper不需要每次询问证据π时都调用一次承诺实例,同时提供了更好的安全性;通过批处理来分摊验证者的开销,图13中标识的消息在批处理的多个实例中只需执行一次;针对特殊场景降低了PCP编码的冗余度从而减少了证明者P的开销.Pepper协议中证明了这些改进并没有改变IKO协议的完备性和可靠性.然而Pepper协议的计算开销和网络开销依然很大,适用的应用种类有限,局限于顺序结构的数值计算.Ginger协议[57]进一步降低了开销,其证明了一致性测试是包含线性测试的,即使是一个恶意的证明者也一定会提供线性的π,从而去除了图13中的PCP验证的线性测试.如图14所示,V以如下方式构造查询:狇1,狇2∈R狇5←r1+狇1,狇6←r2+狇4,且在二次正交测试和电路测试中重用了部分询问向量,使得一个实例中PCP验证中询问的次数从13降到了6,进一步降低了询问的次数.Ginger协议扩大了应用的适用类型,使得程序包括浮点数、不等测试、逻辑表达式,条件语句等等.但仍不能很好的处理循环.且相比较Pepper,Ginger编译器可以自动完成绝大部分程序的编译.Page13然而Ginger协议有一个严重的问题,就是证明者的每个实例的工作和验证者生成询问向量的初始阶段的开销是计算规模大小的二次方.Ginger针对特定程序(比如矩阵乘)通过手工裁剪证据向量和询问向量来解决这个问题,但是这只适用于某些应用场景.Pepper和Ginger协议仅仅在有重复结构的顺序结构程序是有意义,而且他们针对不同的应用程序需要特殊构造的PCP.且为了使得Pepper和Ginger协议获得好的性能从而能用于实际,在程序的通用性上做了限制,只适用于特定种类的程序.Zaatar协议保留了Pepper和Ginger协议的大部分结构,并对其做了改进,引入了(GGPR)[28]中的基于QAPs的线性PCP取代了Arora等人[20]中的线性PCP,和Ginger协议的承诺方案相结合,使得验证者的初始阶段的开销和证据π的长度等于程序运行时间和程序长度之和的线性函数,从而使得证明者的开销接近线性.虽然这种编码引入了额外的开销,但这些开销相对Ginger协议以及之前的同类协议来说仍旧是最优秀的.证明者的开销和Ginger中最优化的手动构造的程序协议基本一致.在大部分程序种类中,基本取代了Pepper和Ginger协议.Zaatar协议可以自动将程序编译成约束集,Pepper和Ginger协议都是手动构造的.基于一些基准测试(排序、聚类分析、最短路径),Zaatar协议的证明者的性能降低了3~6个数量级,验证者的性能也降低了3~6个数量级,因而验证者的批处理实例可以降低到上千个计算.同时由于用户愿意为安全保证付出一定的代价,这使得Zaatar协议在实际应用中的开销已经可以接受,且批处理和付费问题等特征和云计算的当前应用也一致.比如说,大规模的科学模拟计算通常有重复的结构,MapReduce程序的map阶段也如此,但是由于其使用的计算模型的局限性,使得Zaatar协议还无法应用于云计算场景,因为它需要验证者本地拥有所有的输入.为了使得Zaatar协议能应用于MapReduce程序,需要修改协议,使得协议能够处理远程输入的场景,比如下一节介绍的和不可信存储[64-65,79-80]集成的Pantry协议.7.2使用加密询问向量的论证系统相比使用基于承诺方案的论证系统,使用加密询问向量的论证系统需要验证者预先加密它的询问向量,证明者无法看到询问的实际内容.随后,在验证阶段,验证者和证明者使用复杂的密码学协议实现如下的流程:证明者回答询问向量,而不能分辨询问向量询问的证据的位置,验证者用密钥解密验证者的响应.有了证明者的响应,验证者继续执行PCP验证,就如使用基于承诺方案的论证系统的协议一样.这个方法在文献[28,66]中详细说明,文献[59-60]改进和实现了该方法.Parno等人[59]提出Pinocchio协议,其第一次使用了加密询问向量的论证系统的方法,这对于用户的隐私有重要的意义.Pinocchio协议不但实现了GGPR中的证据编码,还实现了其复杂的密码学协议,使得Pinocchio协议具有零知识性和公开可验证性,任何拥有密钥的用户都可以验证程序是否正确执行,只要其生成的询问向量是正确的.加密询问向量的论证系统很大的一个优点是可以重用询问向量,大大减少了询问向量生成的时间,而且使得协议中交互的次数更少,在每一个程序的初始阶段之后,验证者只需发送每一个实例的输入数据即可,所以也称为无交互的论证系统.从定性的分析来看,Pinocchio协议具有更好的分摊性.如图15所示Pinocchio协议可以把每一个程序的初始阶段的开销分摊给未来的所有此程序的实例,而使用基于承诺的论证系统的可验证计算协议只是把每一个程序的初始阶段开销分摊给一次批处理中的所有实例.虽然复杂的密码学协议的应用相比基于承诺的协议而言给初始阶段带来了一些额外的开销,但这些开销比较小,而且通过分摊可以使开销忽略不计.图15Pinocchio和基于承诺方案的协议区别尽管Pinocchio协议已经在可验证计算领域取得了很大的突破,但是其所采用的计算模型仍不能Page14很好的表示通用程序.首先,协议需要在编译时定义循环的次数.其次,不支持间接内存引用,这就无法表示通用程序中的RAM操作.第三,这些程序不支持远程输入,也就是说验证者必须处理所有的输入和输出,这就无法表示MapReduce程序,远程数据库查询等等,无法适用于云计算中.Pantry协议[60]对其进行了进一步的改进,把Pinocchio协议和不可信存储技术[62-65,79-81]相结合,引入了存储的概念,使用Merkle-hash树技术来支持内存随机存取,其中hash函数采用Ajtai[82-83],其相比SHA-1,时间开销只是其10%.Pantry协议定义了如图16两个基本原语PutBlock和GetBlock,使用编译器将其表示成约束集CH和CH然后使用PutBlock和GetBlock来构建可验证的MapReduce、可验证的RAM、远程数据库的可验证的查询.以MapReduce为例说明,如图17所示,程序员使用C语言和block=GetBlock(name)和name=PutBlock(block)原语来构建可验证的MapReduce框架,只是输入和输出文件用其内容的摘要来表示.如此构造的程序,Pantry协议则可以直接把程序作为Pinocchio协议的输入程序来处理.同时Pantry也可以集成Zaatar协议,只是如果要提供公开可验证性和零知识性,就必须集成Pinocchio协议处理.Pantry协议是目前处理验证者不包含所有输入的程序的可验证计算的唯一协议.由于Pantry协议中验证者不处理输入,节省了CPU和网络开销.但是由于hash函数的开销很大,使得Pantry协议无法适用于内存密集型程序.而且由于hash函数的开销,使得需要很多的计算实例才可以分摊初始阶段的开销.Pantry对于数据库查询应用,数据库只能有一个写入者,这离实际的数据库应用的可验证计算还有一定的距离.8问题与展望目前可验证计算协议还只是“玩具”系统,由于性能开销过大,仍无法真正用于通用应用程序和云计算的实际场景中.本文说这些协议接近实际场景,是因为相对于相关理论的直接实现所产生的开销来说,这些协议已经有了质的飞跃.在特定构造的程序中,这些协议还是有意义的.而且,在某些需要牺牲性能来换得安全性的场景下,比如在高确保计算场景中,为了掌握部署在远端的机器的运行是否正常,通常愿意花费比较大的代价.更幸运的是,现有可验证计算协议基于性能的考虑要求证明者有大量空闲的CPU周期,验证的程序有多个不同的实例(同一程序、不同输入),这些和数据并行的云计算场景十分吻合,因而研究可验证计算协议,对于解决引言中提出的云计算中的程序执行的可信问题从而构建可信的云计算是有意义的.然而,可验证计算协议领域以及其构建可信云计算领域在以下几个方面还有待进一步的研究:(1)相关的理论工具还有待于进一步改进.一方面需要通过理论工具的研究和改进来降低验证者和证明者的开销,尤其是要把证明者的开销降低到一个合理的范围,使得协议真正能用于实际的场景中.验证者的开销可以分为固定的开销(可以分摊,通常指每个程序或者每次批处理的初始阶段的开销)和可变的开销(程序的每个实例的验证开Page15销).研究如何降低验证者的可变开销,研究能否使用密码学操作和复杂的理论工具来降低或取消验证者初始阶段的开销.改进基于无预处理的论证系统的可验证计算协议,使得其能用于实际场景.另一方面,研究利用理论工具来建立更加合理的计算模型,用于高效的表示通用程序,从而提高协议的效率.目前的系统要不不能很好的处理循环结构,要不就是编译的代价太高无法实用.BCGTV协议可以处理独立于数据的循环的程序,但是其对于程序转化成特殊的电路模型引入了过大的开销.BCGTV和Pantry协议可以处理包含RAM的程序,但是Pantry协议对内存操作转换成约束集也引入了过大的开销(目前,在T机器运行的一些计算机程序原本需要T步,转换成由电路计算远远超过T步).有必要改进这两种计算模型使得其既可以很好的处理循环结构和RAM,又不至于引入过大的开销.或者设计新的更加高效的计算模型来表示通用计算.(2)在系统和编程语言方面值得研究.针对已有的电路和约束计算模型,设计定制的高级程序语言,降低程序到计算模型的转化开销.目前,一些可验证计算协议编译处理和证明系统的工作已经有所交叉,而且很多协议在并行计算中性能更优,由于计算模型的高效转化,可以使得验证的效率提高.所以设计一整套相应的高级语言程序、计算模型、验证机器十分必要.目前还没有协议在真实的云计算场景中测试,开发适用于云计算实际场景的支持并发、访问控制、合理结构的数据库应用的可验证计算,使得协议支持多用户数据库,才能更好的构建可信的云计算.(3)改变协议的目标和原则,减少可验证计算协议的限制条件,比如可验证计算协议的无条件假设,即除了密码学假设之外不做任何其他假设.如果假设多个证明者之间不能相互交互、合谋,那么多证明协议相对单证明者的开销则降低很多.实际上,如果假设两个证明者至少有一个是计算正确的,就可以使得很多协议能用于特定构造的场景中.(4)增加安全相关的属性用于构建可信的云计算.Pinocchio、Pantry协议说明了在证明者对验证者隐藏询问信息的场景下的简单应用,还有很多地方值得研究,比如说提供隐私相关的其他安全属性,可以用来保护云计算用户的隐私.再比如说公开可验证性的特性使得任何拥有密码的用户都可以验证其可信性,这为第3方审计来保证云计算的可信性提供了良好的思路.可验证计算协议把复杂的密码学和理论计算机科学的研究成果用于实际本身就具有里程碑的意义.基于证据的可验证计算协议是一个趋势,这不仅使理论应用于实际,而且开创了理论计算机新的研究领域.虽然可验证计算协议的性能和在云计算实际场景中的部署还有一定的距离.但是以当前的研究节奏,相信不久的将来,就会有基于证据的可验证计算协议应用到云计算的真实场景中.而且,可验证计算的潜力很大,远远不只是云计算.如果这个领域的研究性能降低到合理的范围,除了验证云计算之外,还有更大的价值.将会有新的方法来构建协议,在任何一个模块为另一个模块执行程序的场景中都可以应用.包括微观层面(microlevel),如果CPU可以验证GPU,则可以消除硬件错误;宏观层面(macrolevel)分布式计算将基于不同的可信假设构建.而且,随着计算能力的增加和计算成本的下降,原本无法实践的协议也可以用于实际场景中.
