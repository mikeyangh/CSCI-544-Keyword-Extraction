Page1大规模RFID系统中一种能量有效的丢失标签快速检测算法张士庚1),3)刘光亮1)刘璇2)王建新1)1)(中南大学信息科学与工程学院长沙410083)2)(香港理工大学计算机系香港)3)(计算机软件新技术国家重点实验室(南京大学)南京210046)摘要在基于主动式标签构建的RFID系统中,如何以能量有效的方式检测出丢失标签是一个重要的研究问题.针对多阅读器RFID系统,首次提出一种基于虚拟布鲁姆过滤器的丢失标签检测算法BMD,能够以较低的能量开销快速地检测出丢失标签.算法的核心思想是让标签在一个查询帧中对RFID阅读器进行多次回复,并基于回复信息构造若干“虚拟”布鲁姆过滤器来进行丢失标签检测.理论分析和仿真结果均表明了BMD算法的有效性.相比于传统的基于标签标识号收集的检测方法,BMD算法的能耗要低一个数量级,算法执行时间减少了最高达52%;相比于当前最好的单阅读器丢失标签检测算法IIP,BMD算法的能耗要低两个数量级以上,并且算法执行时间减少了最高达80%.关键词无线射频识别;丢失标签检测;布鲁姆过滤器;能量有效;物联网1引言无线射频识别(RFID)技术是物联网体系中一种不可或缺的核心关键技术,目前已经被广泛地应用于包括物流追踪、仓储管理、智能交通等许多领域.在这些应用中,每个货物上都安装一个RFID标签(Tag),该标签存储了货物对应的相关信息,如产品标识号和货物状态等.利用预先部署的RFID阅读器(Reader),可以通过无线电信号对RFID标签中存储的数据进行读写,从而有效地对货物状态进行追踪和管理.与传统的二维码和条形码等技术不同,RFID阅读器可以在相对较大的范围内对标签中的数据进行读写,并且不需要阅读器与标签之间满足视距(lineofsight)传输,因而能够极大地提升读取效率.目前,RFID自动识别技术以及相关研究已经成为国内外研究的热点问题[1-5].RFID标签可以分为两类[1,4]:主动式标签和被动式标签.主动式标签利用内嵌的电池和阅读器进行通信,而被动式标签通过反射RFID阅读器发射的信号来与阅读器通信.相比于被动式标签,主动式标签可以提供更多的附加功能,如对周围环境信息进行感知等,因此目前在很多的应用中大量使用的是主动标签,特别是在对贵重物品或者大型物品的监控方面更是如此[6-8].由于主动式标签是利用内嵌电池供电的,因此针对基于主动式标签构建的RFID系统来设计能量有效的监控和识别算法是目前国内外学术界的一个关注热点[4,7-8].在RFID系统中,如何快速检测丢失标签从而快速发现丢失的货物是一个很重要的研究问题.例如,假设有一个武器仓库,其中存储了大量的枪支.如果有人未经允许将仓库中的武器私自带出,将会对社会安全造成极大的隐患.因此,我们需要对仓库中的枪支进行严密监控,在武器丢失时(在RFID系统中表现为对应的标签丢失)能够及时地检测出该事件并判断出是哪件武器丢失.理论上,我们可以通过读取所有标签的标识号,并将所搜集到的标签集合与系统中存储的标签集合进行对比来检测出丢失标签.然而,目前RFID标签的识别仍然是一个比较耗时的过程:标签识别的吞吐量只有100个~200个/s[3,6,9].当系统规模很大时(大型超市中的标签数目可能达到几十万甚至上百万),利用标签读取的方法来检测丢失标签是一个很耗时的过程.更重要的是,RFID标签的识别需要传输标签的标识号,而这是一个非常耗能的过程,特别是对于使用内嵌电池供电的主动标签来说.因此,如何在不收集标签标识号的情况下,以一种能量有效的方式快速准确地检测出系统中的丢失标签,是近年来RFID研究领域中的一个重要研究方向.在本文中,针对基于主动式标签构建的RFID系统,我们提出了一种能量有效的快速丢失标签检测算法.其核心思想是通过让标签在一个查询帧中对阅读器进行多次回复来构建“虚拟”的布鲁姆过滤器(Bloomfilter),然后基于所构造的虚拟布鲁姆过滤器来判断标签是否丢失.由于布鲁姆过滤器能够以较小的空间开销表示元素与集合的从属关系[10],因此我们所构建的虚拟布鲁姆过滤器能够以较小的时间开销来检测出标签是否存在于系统中.更重要的是,我们所提出的算法既不需要收集标签标识号,也不需要向标签广播大量的信息,从而能够极大地降低通信开销,达到节省能量的目的.我们所提出的算法适用于包含多个阅读器的大规模RFID系统.本文主要创新点如下:(1)针对基于主动式标签构建的多阅读器RFID系统,首次提出一种基于虚拟布鲁姆过滤器的丢失标签检测算法BMD,能够以较低的能量开销快速地检测出丢失标签.(2)对算法的性能进行了理论分析,从理论上推导出了在保证检测概率的前提下的关键系统参数的最优值,以达到最小化标签平均能耗的同时减少检测时间的目的.(3)通过仿真证明了所提出算法的有效性.相比于传统的基于标签标识号收集的方法,本文所提出算法的标签平均能耗要低一个数量级以上,并且检测时间减少了最高达52%.相比于当前最好的单阅读器丢失标签检测算法IIP[11],BMD算法的能耗要低两个数量级以上,并且算法执行时间减少了最高达80%.本文在第2节介绍相关工作;在第3节给出系统模型和问题定义;在第4节介绍所提出的BMD算法,并对算法性能进行了理论分析,讨论了如何设置系统参数来最小化标签能耗和算法执行时间;第5节给出仿真结果并进行了讨论;最后,第6节进行总结并探讨将来研究方向.2相关工作早期RFID领域的研究大多集中于如何设计高Page3效的RFID标签识别协议来提升标签识别的吞吐量[5,12-16].现有的RFID标签识别协议可以分为两种:基于ALOHA的协议和基于树的协议.在基于ALOHA的协议[13-16]中,标签和阅读器之间的通信划分成帧,而帧又进一步划分为不同的时隙.当一个标签收到阅读器的查询命令后,就会在当前帧中随机选择一个时隙对阅读器进行回复.如果在某个时隙中只有一个标签对阅读器进行回复,则该标签能够被阅读器正确识别.如果在当前帧完成之后还存在未识别的标签,则阅读器启动一个新帧来对剩余未识别的标签进行继续识别.在基于树的协议中[1,4-5],阅读器在每次的查询命令中广播一个前缀信息,所有满足这个前缀的标签均会向阅读器发送回复.阅读器检测回复是否冲突.如果回复冲突,则阅读器通过更改前缀将回复的标签分成两部分,并通过广播不同的新前缀来让不同的标签子集合回复.当阅读器检测到只有一个标签回复时,则成功识别该标签.虽然已有的RFID标签识别协议可以用于检测丢失标签,但是标签的识别耗时较大,并且标签ID的传输会造成较大的通信开销.特别是对依赖电池供电的主动标签来说,利用RFID识别来进行丢失标签检测所消耗的能量过高.与直接收集标签标识号的方法相比,我们所提出的BMD算法不仅极大地降低了能量消耗(标签的平均能耗降低了一个数量级以上),而且有效地减少了算法执行时间.目前已经有学者展开了在不收集标签标识号的情况下来检测丢失标签的研究[11,17].在文献[17]中,作者提出了一个概率性的丢失标签检测算法.该算法通过比较阅读器在每个时隙期望得到的回复状态和实际检测到的回复状态来判断系统中是否有标签丢失.但是该算法不能准确地确定具体是哪些标签丢失.在文献[11]中,作者针对单阅读器RFID系统提出了一个高效的丢失标签检测算法IIP(Itera-tiveID-freeProtocol).在该算法中,阅读器首先根据系统中存储的标签信息来计算一个帧前向量(pre-framevector)并将该向量广播给系统中所有的标签.系统中的标签收到该向量后,根据向量中的值来判断自己是否应该向阅读器发送回复.当阅读器收集到标签的回复后,IIP协议就可以判断出哪些标签是未丢失的并基于此计算出一个帧后向量(post-framevector)来通知这些标签在下一个帧中退出协议.当所有的标签均回复后,IIP协议即可判断出丢失标签.由于阅读器可以利用一个标签ID发送多位向量,因此IIP可以快速地检测丢失标签,其对每个标签的平均检测时间可以达到一个常数值(约0.86ms).同时该算法不仅能够检测是否有标签丢失,还能够准确地确定出是哪些标签丢失.然而,在IIP协议中,每个标签需要从阅读器接收大量的信息,对于主动式标签来说IIP会带来较大的能量开销.在文献[8]中作者指出,主动标签的能耗主要取决于发送和接收数据量的多少.在IIP协议中,标签需要接收阅读器发送的大量信息,因而不适合于用主动标签构件的大规模RFID系统.同时,当IIP协议应用到多阅读器RFID系统中时,其执行时间也会大大增加.这是因为在协议执行过程中的每一轮,IIP协议都要根据系统中所有的标签来计算前置向量和后置向量,并广播给所有的标签.同时,在IIP协议中阅读器需要将系统中所有标签的回复收集完成后才能够计算出后置向量,这使得IIP协议无法并行执行.在多阅读器环境下,由于阅读器之间的冲突,多个阅读器需要调度交替执行.假设需要k轮才能将所有的阅读器调度执行完毕,则IIP协议的执行时间会变为单阅读器情况下的k倍.因此,在多阅读器环境下,IIP协议的执行时间将会大为增加.与前述工作相比,本文中提出的方法通过构造虚拟布鲁姆过滤器来检测丢失标签.在该方法中,标签和阅读器之间的通信数据量较少,因此能够极大地降低标签的能量消耗.同时,利用多阅读器之间的并行性,本文所提出的方法能够有效地减少检测时间,适用于多阅读器大规模RFID系统中的丢失标签检测.3系统模型和问题定义3.1系统模型我们考虑的RFID系统由3部分组成:一个后台服务器,一组RFID阅读器以及大量的RFID标签.图1给出了一个包含3个RFID阅读器的例子.在系统中,后台服务器负责对阅读器进行协调和调度,来确定不同阅读器的工作次序以避免冲突,并设定各阅读器的工作参数.这里,我们假设后台服务器和各个RFID阅读器之间存在着有线或无线的高速连接,服务器和阅读器之间可以进行直接通信来交换信息.阅读器在服务器所分配的时间段中利用服务器所确定的参数与自己覆盖范围内的标签通信,并将所收集的标签回复信息传回给服务器进行处Page4理.与已有的工作[16-17]一致,这里我们假设后台服务器存储着系统中所有标签的信息(包括当前系统中仍存在的标签和丢失的标签).图1系统模型示意图(黑色的点表示丢失标签)在协议运行过程中,RFID标签接收阅读器的查询命令,并返回相应的回复信息.我们假设阅读器和标签之间的通信采用帧-时隙ALOHA协议(FrameslottedALOHAprotocol).在该协议中,阅读器和标签之间的通信划分为帧进行.在每个帧中,阅读器广播查询命令并指明当前帧所包含时隙的个数,每个标签在帧中随机选择一个时隙对阅读器进行回复.具体来说,在每个查询帧的开始,阅读器广播两个参数:帧大小f和一个随机数s,其中f指明了该帧包含的时隙个数,而s用来帮助标签在该帧中随机选择一个时隙对阅读器进行回复.假设标签T的标识号为TID.当收到阅读器所广播的参数后,标签T利用一个Hash函数H将自己的标识号映射到[0,f-1]中的一个值:sc=H(TID‖s)modf,并在第sc个时隙回复阅读器.根据回复标签数目的不同,时隙可以分为3种不同的类型:(1)空时隙,其中没有标签回复;(2)单时隙,仅有一个标签回复;(3)冲突时隙,有两个以上的标签同时回复.只有在单时隙中回复的标签才能够被正确识别,而在冲突时隙中回复的标签必须参加下一个帧继续识别.随机数s的作用是让同一个标签在不同的帧中选择不同的时隙回复,以避免冲突始终存在.在我们的系统模型中,与已有工作[7-8,18]类似,对基本的帧-时隙ALOHA通信协议进行了一些改动.首先,在基本帧-时隙ALOHA协议中,标签将它们的标识号(ID)回复给阅读器.而在我们的系统模型中,标签不需要向阅读器回复自身标识号,而仅仅需要向阅读器发送一个1比特的短回复.目前在标签集合动态监控方面的研究大都基于这种改动的ALOHA协议(见文献[7-8,18]),并且当前的RFID标签,例如飞利浦I-CODE标签[6]与EPCClass1Gen2标签[9]等均可以支持这种操作.其次,我们假设一个RFID标签在一个帧中可以选择多个时隙对阅读器进行多次回复.这要求一个RFID标签同时产生多个Hash值.这可以通过在标签中存储多个Hash函数或者在一个帧的开始发送多个随机数来实现.这种技术已经在很多RFID识别技术研究领域采用,包括标签搜索[18]、标签数据收集[8]以及标签数目估计[19]等.在本文中,我们通过让阅读器在一个帧的开始发送多个随机数来实现这种功能.在多阅读器RFID系统中,相邻阅读器之间会产生两种冲突[20-22],如图2所示.第1种称作阅读器-阅读器冲突(Reader-ReaderCollision,简称为R-R冲突).如图2(a)所示,当标签T同时处在两个阅读器A和B的读取范围之内时,A和B之间就会产生R-R冲突.这种情况下,如果阅读器A和阅读器B同时广播查询请求,标签T收到的信号将会受到干扰从而不能正确地对查询命令进行解码.第2种冲突称为阅读器-标签冲突(Reader-TagColli-sion,简称为R-T冲突).如图2(b)所示,当阅读器A位于另一个阅读器B的读取范围内时,标签T向A发送的回复可能会被阅读器B的信号所干扰,从而不能正确解码.相互之间会产生冲突的阅读器不能同时工作.在多阅读器RFID系统中,我们要通过对阅读器的工作次序进行调度,来避免这两种冲突.我们将基于图着色算法来对不同阅读器的工作次序进行调度,详见第4.3节.3.2问题定义在这一节我们给出问题的定义.在很多情况下,我们需要保证丢失标签以一定的概率被检测出来.记系统中所有标签的集合为W,而所有丢失标签的集合为M.我们的问题定义如下:假设已知系统中标签集合W.基于前述系统模Page5型,如何通过阅读器和标签之间的交互检测出丢失标签,使得每一个丢失标签T∈M被检测出的概率大于指定的检测概率α?在算法的设计过程中,我们的主要目标是在满足检测概率的前提下,最小化标签的能量消耗并尽量减少算法的执行时间.在下一节,我们将详述所提出的丢失标签检测算法并分析如何达到这两个目标.4算法描述4.1算法概述假设系统中存在L个RFID阅读器,记为={R1,R2,…,RL},这些阅读器覆盖了整个监控区域.我们的算法基于如下观察:如果一个标签为丢失标签,则该标签不会出现在任何阅读器的读取范围内.否则,如果一个标签为未丢失标签,该标签应该出现在至少一个阅读器的读取范围内.因此,我们可以通过检测一个标签在所有阅读器读取范围内的存在情况,来判断该标签是否丢失.如果该标签在至少一个阅读器范围内出现了,则我们认为该标签存在于系统中,不是丢失标签.否则,如果该标签在所有阅读器的读取范围内都没出现,则该标签必定为丢失标签.算法1给出了该算法的框架.为了实现这个算法,我们需要准确地判定一个标签是否在一个阅读器的读取范围内.通过收集阅读器读取范围内的所有标签的标识号,我们可以做到这一点.然而,如同我们前面所讨论的那样,标签的识别通常是一个耗能耗时的过程.我们提出一种基于虚拟布鲁姆过滤器的算法,在不收集标签标识号的情况下快速地判断一个标签是否在一个阅读器读取范围内.该算法的具体细节在下一小节给出.算法1.丢失标签检测算法.输入:W//系统中所有标签集合输出:M//丢失标签集合M=;FORT∈WENDFORRETURNM4.2基于虚拟布鲁姆过滤器的存在性测试算法本节我们提出一种基于虚拟布鲁姆过滤器的标签存在性测试算法.我们首先介绍布鲁姆过滤器的概念,然后讨论如何利用标签回复来构建虚拟布鲁姆过滤器,并基于此来检测一个标签是否存在于某个阅读器的读取范围内.4.2.1布鲁姆过滤器布鲁姆过滤器[10]是一种能够高效地表示集合从属关系的数据结构.具体来说,布鲁姆过滤器可以用一个二进制向量和k个Hash函数表示,向量中的比特可以置位为“0”或者“1”.初始时,向量中的所有比特都初始化为“0”,对应于一个空的集合.当向一个布鲁姆过滤器中插入一个对象时,利用该对象和k个Hash函数,将向量中该对象对应的k个位置均置为“1”.图3给出了一个使用3个Hash函数的布鲁姆过滤器的例子.在3个Hash函数的作用下,对象a分别对应着向量中的第1、4、7个比特,因此当将对象a插入到该布鲁姆过滤器后,第1、4、7个比特将会被置为“1”.假设集合S={a,b,c},将S中的对象全部插入到该布鲁姆过滤器后,向量中“0”和“1”的分布情况如图2所示.这个布鲁姆过滤器就表示了集合S.利用布鲁姆过滤器,可以在常数时间内测试一个对象是否存在于某个集合中.给定对象x,要测试x是否存在于集合S中,我们可以检查x对应的k个比特是否被置为“1”.如果x对应的所有k个比特都置为“1”,则认为该对象在集合S中.否则,认为该对象不在集合S中.比如,对象a对应的3个比特全部为“1”,则我们判定对象a属于对象S.对象d对应的3个比特不全为“1”,因此我们判定对象d不属于集合S.必须指出,对不属于集合S的对象,布鲁姆过滤器有可能会产生误判.比如,假设对象e对应着第1,2,4个比特,则布鲁姆过滤器会判断对象e属于集合S,而实际上集合S并不包含对象e.产生这种错误的概率称为假阳性概率(falsepositivePage6probability).我们将在4.4节讨论假阳性概率对算法的影响.4.2.2基于虚拟布鲁姆过滤器的存在性测试我们利用标签在一个帧中对阅读器多次回复来模拟布鲁姆过滤器的插入过程,构建一个“虚拟”的布鲁姆过滤器.利用该虚拟布鲁姆过滤器,来测试一个标签是否存在于某个阅读器的读取范围之内.具体步骤如下.(1)后台服务器首先根据所要求的检测概率和每个阅读器范围内的标签数目来计算所需的帧大小f和所需的Hash函数个数k(我们将在4.4节讨论如何计算这两个值).然后,对每个阅读器Ri,后台服务器产生k个随机数,并将这k个随机数连同帧大小f发送给阅读器Ri.然后,后台服务器计算一个可行的阅读器调度次序来调度各个阅读器依次工作.阅读器的调度将在4.3节给出.(2)阅读器Ri收到服务器发送来的帧长度f和k个随机数后,就向标签广播这些参数.标签利用收到的k个随机数,在帧中随机选择k个时隙对阅读器进行回复.由于我们只需要知道某个时隙是空还是非空,标签只需要向阅读器发送一个1比特的回复信息.阅读器扫描帧中各个时隙的状态,并在此基础上构建一个“虚拟”的布鲁姆过滤器如下.首先,阅读器产生一个长度为f的比特向量,并将其中所有比特初始化为“0”.然后,根据所收集到的时隙的不同状态来对向量中相应的比特进行置位:如果第i个时隙是非空时隙,则将向量中的第i个比特置为“1”;否则,将第i个比特置为“0”.根据4.2.1节可知,该向量实际上等同于一个表示该阅读器中所有标签的布鲁姆过滤器.由于该布鲁姆过滤器是根据标签的回复虚拟构建的,我们称之为“虚拟”布鲁姆过滤器,记为BF(Ri).阅读器将构建的虚拟布鲁姆过滤器发回给后台服务器进行存在性测试.(3)后台服务器利用阅读器发送回来的虚拟布鲁姆过滤器BF(Ri)来判断标签T是否在阅读器Ri的读取范围内.因为服务器知道Ri所用的k个随机数,它利用这k个随机数和标签T的标识号来检测T在BF(Ri)中对应的k个比特.如果这k个比特都为“1”,则认为T在Ri的读取范围内;否则,认为T不在Ri的读取范围内.4.3多阅读器调度在第2.2节我们介绍了阅读器之间可能存在着冲突.当系统中存在多个阅读器时,我们需要对阅读器进行调度来避免阅读器之间的冲突.已经有很多工作研究了在多阅读器RFID系统中如何对阅读器进行调度来提高RFID标签识别的吞吐量[20-22].这里我们借鉴已有工作,通过将阅读器之间的潜在冲突关系构建成一个冲突图,并通过在该冲突图上利用着色算法来寻找一个可行的阅读器调度.具体步骤如下:(1)构建阅读器之间的冲突图.基于阅读器集合,构建冲突图G=〈V,E〉,其中V中每个顶点vi对应阅读器Ri,而顶点〈vi,vj〉之间有边对应阅读器Ri和阅读器Rj之间存在着R-R冲突或者R-T冲突.两个阅读器之间是否存在着冲突可以通过它们之间的距离来判断,或者通过在RFID系统的监控范围内进行场景分析得到[21].(2)利用着色算法,为图G中的顶点进行着色.着色算法为图中每个顶点赋予一个颜色,使得任意相邻的两个顶点的颜色都不相同.利用着色算法的结果,我们让同一颜色的阅读器同时工作,而调度不同颜色的阅读器在不同时间工作以避免冲突.在这里,我们采用DSATUR算法,因为这个算法可以在节点数较多的情况下快速找到一个近似最优的解.DSATUR的具体介绍请参见文献[23].4.4算法性能分析在这一节我们讨论如何为阅读器Ri设置帧长度f和Hash函数个数k来满足所要求的检测概率.为了便于讨论,我们假设知道阅读器Ri读取范围内的标签数目.我们将在第5节利用仿真讨论标签数目估计精度对算法性能的影响.假设阅读器Ri读取范围内共有Ni个标签,而帧大小设为fi.则对BF(Ri)中的任意一个比特,该比特被置为“0”的概率为而该比特被置为“1”的概率为对一个不在Ri读取范围内的标签T来说,若该标签对应的k个比特在BF(Ri)中均置为“1”,则该标签会被误判为在Ri的读取范围内,其概率为而其被正确地判定为不在Ri读取范围内的概率为假设系统中共有L个阅读器,若一个丢失标签在每个阅读器中都被正确地判定为不在该阅读器范围内,则我们能够成功地检测出该丢失标签,概率为(为方便推导,这里我们假设对所有的阅读器Ri,其误判概率Piw都相同并简记为Pw)Page7可以看出,当L值固定时,PFP为Pw的减函数,其值在Pw取最小值时达到最大.根据文献[4],当Ni和fi给定时,存在最优的k值使得Pw值最小:此时Pw值为为了达到所需的检测概率,需要将式(3)代入式(8),我们可以得到即阅读器Ri的帧长度必须至少为Ni×log(1-α1/L),此时所需的Hash函数个数为可以看出,由式(9)所确定的f值和由式(10)所确定的k值即为相应的帧大小和随机数个数的最优值.这是由于若采用更小的f值则无法保证所需的检测概率.而若采用更大的f值,则为了满足所需的检测概率必须相应地增大k值,会增加标签的能耗(标签发送的数据量恰为k比特),同时也会增加算法的执行时间.因此在第5节的仿真中,我们利用式(9)和式(10)来确定每个阅读器所需的帧大小f和随机数个数k.4.5相关讨论在上一节的分析中我们假设每个阅读器读取范围的标签数目已知.而在实际环境中,一个阅读器范围内的标签数目是不能准确得到的.我们可以利用已有的标签数目估计算法如文献[19]来快速对标签数目进行估计.估计算法的精度会影响所提算法的性能:当标签数目估计值大于实际值时,丢失标签的检测概率会增加,但是算法的时间开销和通信开销也增加;当标签数目的估计值小于实际标值时,丢失标签的实际检测概率有可能达不到要求的检测概率α.在第5节中我们基于仿真讨论了标签数目估计误差对所提算法性能的影响.结果表明,当估计标签数目大于实际标签数目的90%时,算法的检测概率不受影响.标签的移动性也会对所提算法的检测概率造成影响.实际上,假设在算法执行过程中一个标签从一个阅读器检测范围内移动到另一个阅读器检测范围内,最坏的情况是当这两个阅读器工作时该标签都位于对应的阅读器范围内.这种情况其实可以归结于阅读器读取范围内的实际标签个数大于估计值,因此有可能造成检测概率下降.然而,当节点移动性较小时,对检测概率造成的影响并不很大.如果节点移动速率较大,我们可以通过增大每个阅读器范围内标签数目的估计值来容忍这种情况.这会稍稍增加检测时间,但是可以保证所需的检测概率.5仿真结果我们进行了仿真来测试所提出算法的性能.为了便于描述,我们将所提出的丢失标签检测算法称为BMD(Bloom-filterbasedMissingtagDetection).作为对比,我们实现了基于标签ID收集的算法(称为Collection)和目前最好的单阅读器丢失标签检测算法IIP[11],并将它们的性能与所提出的BMD算法进行比较.在计算不同算法的执行时间时,我们采用文献[6]中给出的设定.我们主要考查算法两方面的性能:执行时间和算法过程中标签发送/接收的总数据量,其中后者表示算法执行过程中标签的能量消耗.对于可能影响算法性能的参数,我们考虑标签的密度、所期望的检测概率以及RFID系统监测的范围.在仿真过程中,我们假设如果标签与阅读器之间的距离小于一个给定的读取半径r,则标签可以与阅读器通信.阅读器之间的冲突情况根据阅读器之间的距离进行确定.默认情况下,我们假设所有标签随机均匀分布在一个50m×50m的正方形区域内,阅读器的读取半径设为r=10m,每个阅读器范围内的平均标签个数为500个,阅读器采用规则的正方形部署模式.默认情况下,我们将检测概率α设为0.95,假设系统中有1%的标签丢失.对每组实验,我们重复100次并取其平均值作为结果.5.1标签数目估计误差的影响在第4.5节我们提到,每个阅读器读取范围内标签的数目估计误差对BMD算法的性能会产生影响.定义标签数目估计误差η如下:其中Ni为阅读器Ri读取范围内标签数目的估计值,而N为标签数目的真实值.图4给出了当η值在[-0.2,0.2]之间变化时BMD算法的实际检测概率变化情况(假设期望检测概率α=0.95).我们可以看出,当标签数目估计值显著小于标签数目真Page8实值时(η<-0.1)时,实际检测概率会小于期望检测概率.然而,当标签数目估计值接近于或者大于标签数目真实值时,实际检测概率总是大于期望检测概率的.目前常用的标签估计算法一般可以达到小于5%的误差,因此利用估计的方法来获取标签数目能够达到系统所需的检测概率.然而,标签数目估计值并不是越大越好,因为标签数目估计值变大会使算法执行时间增加.图4同时给出了当η变化时算法执行时间的变化情况.从式(9)可以推论出,算法的执行时间与标签数目的估计值成正比,当标签数目估计值增大时,算法执行时间也增大.图4清楚地显示了这一点.注意到Collection算法和IIP算法同样需要知道标签数目的准确估计,在以下的仿真中,我们假设已经知道每个阅读器覆盖范围内标签数目的真实值来比较各个算法的性能.5.2期望检测概率的影响图5中给出了当期望检测概率α从0.90增加到0.99时,各算法执行时间的变化情况.我们可以看出,当期望检测概率增加时,BMD算法的执行时间也相应增加.当α从0.90增加到0.99时,算法的执行时间增加了大约46%,从13.8s增加到19.8s.Collection算法和IIP算法的执行时间不随α值改变而变化.然而,即使当α=0.99时,BMD算法的执行时间仍显著低于另外两种算法.相比于Collection算法,BMD算法的执行时间平均减少了44%,最高减少幅度达52%.相比于IIP算法,BMD算法的执行时间平均减少了37%,最高达46%.BMD算法更大的优势体现在标签的低通信开销上.图6给出了3种算法中每个标签的平均通信开销(发送数据量和接收数据量之和).可以看出,虽然BMD算法的通信开销随着α值的增加而略有增加,但是总体而言要比另外两种算法低的多.BMD算法中每个标签的通信开销要比Collection算法低一个数量级以上,比IIP算法要低3个数量级以上.其原因如下.在BMD算法中,每个标签仅需要向阅读器发送k个比特(k值通常在10~20之间).而在Collection算法中,标签需要向阅读器发送自身ID(通常为96比特).由于ALOHA协议的效率问题,每个标签平均需要传输e(≈2.72)次才能够被正确识别,因此在Collection算法中每个标签的通信开销约在几百个比特.而在IIP算法中,由于阅读器需要向标签广播多个向量,而向量的长度由系统中标签的总数目决定,因此IIP算法的通信开销要比Collection算法和BMD算法大得多.5.3标签密度的影响图7中给出了当每个阅读器覆盖范围内的平均标签数目从500个增加到2000个时不同算法执行时间的变化情况.3种算法的执行时间均随着标签密度的增加而增加.BMD算法的性能最好,相比于Collection算法和IIP算法,其执行时间分别减少了45%和39%.IIP算法的执行时间略小于Collection算法.图8给出了当标签密度增加时3个算法中每个标签的平均通信开销的对比情况.我们可以看到,在Page9BMD算法和Collection算法中每个标签的通信开销保持不变.然而,对于IIP算法来说,其通信开销随着标签密度的增加而线性增加.这是由于在该算法中阅读器需要向标签广播多个向量,而向量的长度与系统中标签的总数目成正比.因此,当标签密度增加时,每个标签所需要接收的数据量随之增加.相反,对于BMD算法和Collection算法来说,通信开销与系统中的标签数目无关.从式(10)也可以看出,BMD算法的通信开销仅与阅读器个数L和期望检测概率α有关.5.4系统规模的影响当系统规模增加时,系统中阅读器数目增多,此时根据式(9)和式(10)可以看出,BMD算法的执行时间和通信开销都会变大(f和k均是L的增函数).图9给出了当系统规模增大时,3种算法执行时间的变化情况.我们可以看到,当系统规模增加时,BMD算法的执行时间略有增加:当系统监控区域从25r2增加到100r2时,算法执行时间从15.5s增加到19.2s,增幅约为24%.然而IIP算法的执行时间随着系统规模的扩大而线性增加.当系统规模从25r2增加到100r2时,IIP算法的执行时间从25.2s增加到96s,增加到原来的3.8倍,其性能甚至比Collection算法还差得多.原因正如前面所分析的,由于IIP算法中每轮需要广播多个向量,而向量的长度取决于系统中标签的总数,因此IIP算法无法利用阅读器之间的并行性来减少执行时间.相反,BMD算法和Collection算法均可以利用阅读器之间的并行性来有效减少执行时间.相比于Collection算法和IIP算法,BMD算法的执行时间分别减少了最高达45%和80%.同样,系统规模的增加也会影响BMD算法的通信开销.图10给出了当系统规模增加时3种算法中每个标签的平均通信开销对比.可以看出,BMD算法的通信开销仅仅是略为增加,但是维持在一个较低的水平上(从13.6增加到17.3).然而,IIP算法的通信开销与系统规模成线性增加(增加了3倍).其原因前面已经分析,在此不再赘述.Collection算法的通信开销不受系统规模的影响.BMD算法的通信开销要比Collection算法低一个数量级,比IIP算法低3个数量级.6结论在本文中,针对基于主动式标签构建的RFID系统,我们提出了一种基于虚拟布鲁姆过滤器的能量有效的快速丢失标签检测算法BMD.其核心思想Page10是让标签在一个帧内对阅读器进行多次回复来构建虚拟布鲁姆过滤器,并利用布鲁姆过滤器能够高效表示集合从属关系的特性来高效地判断标签是否丢失.相比与基于直接收集标签标识号的算法和当前最好的单阅读器丢失标签检测算法,BMD算法中标签的平均通信开销销降低了1到3个数量级,因此能极大地降低标签能耗,特别适用于利用内嵌电池供电的主动标签.同时,BMD算法的检测时间也显著低于这两种算法.我们提出的算法BMD是一个概率性的算法,并不能保证检测出所有的丢失标签.当丢失标签数目较少时,我们可以通过提高检测概率来在绝大多数情况下检测出所有丢失标签.在将来工作中,我们将进一步研究如何能够保证确定性地检测出所有丢失标签,并考虑有新标签加入时和标签移动性较高时如何改进算法的性能.
