Page1面向分面导航的层次概念格模型及挖掘算法何超1),2)程学旗1)郭嘉丰1)1)(中国科学院计算技术研究所北京100190)2)(中国科学院研究生院北京100190)摘要分面导航利用动态多维分类目录组织查询结果,从而有效减轻数据库资源定位过程中的信息过载.现有的分面导航限制用户每次增删一个查询关键字,无法满足对具有丰富语义的导航操作的需求.另一方面,高效的动态目录生成算法的缺乏阻碍了分面导航在大规模数据中的应用.该文提出了层次概念格,对分面导航中不同浏览状态之间的关系进行建模.基于该层次概念格模型,该文设计了若干新的导航操作以支持用户在不同浏览状态之间更灵活地跳转,从而更有效地进行知识发现.为获取该层次概念格以支持导航的灵活性和实时性,该文提出了层次概念格的高效挖掘和索引算法L-Miner.L-Miner以深度优先方式挖掘所有节点,每得到一个新节点,就更新已挖掘节点之间的边.通过对底层格节点的倒排索引,L-Minder可以高效地进行边更新.实验结果表明:L-Miner的速度远快于现有算法,而其构建的索引结构的存储代价更低.关键词分面导航;概念格;频繁闭项集挖掘;数据挖掘;探索式信息检索1引言互联网的快速发展使得人们可以在线访问大量数据库,如电子商务网站和数字图书馆.这些数据库存储了海量资源,且规模不断扩大.由于传统搜索引擎难以索引这些资源,人们称其为“暗网”(DeepWeb).据统计,暗网比浅层网络大若干量级[1].为增强可用性,暗网站点通常提供基于关键字的搜索.渐增式/探索式搜索是常见的用户搜索行为,即以少量关键字作为初始查询,然后通过扩展查询不断细化查询结果,直至目标资源出现.用户进行渐增式搜索的主要原因有两点:(1)用户通过探索查询结果来不断明确自己的查询意图;(2)利用查询结果中出现的关键字,用户可以更准确地表达查询意图.在渐增式搜索过程中,用户面临的主要挑战是大量的查询结果导致信息过载,从而难以有效扩展查询.分面导航通过查询结果分类来有效减轻暗网关键字搜索中的信息过载[2],并日益成为电子商务网站(如淘宝和Amazon)和数字图书馆(如ACMDigitalLibrary)的主要信息检索方式.分面(facet)指对资源进行分类的特定维度,表示为类别层次结构.分面导航同时从多个分面对查询结果进行分类.例如,伯克利大学的Flamenco项目[3]从“性别,出生地,国家,奖项,年份”五个分面对诺贝尔奖得主进行分类.与传统的单层次目录树相比,分面目录的分类语义更加规范和清晰,且易于扩展.分面导航通过交互式检索来进一步减轻信息过载.分面中类别是动态变化的,只有出现在查询结果中的类别才显示给用户(包括该类别对应查询结果中的资源个数).相应地,用户选择推荐的分面类别作为关键字进行检索或细化查询.例如,当用户在Flamenco中查询“经济学奖”,因为所有55位获此奖者均为男性,所以性别分面中只显示“男性(55)”.与静态目录相比,分面导航不仅降低了用户需要查看的类别数目,而且能有效避免查询结果为空.现有的分面导航存在以下不足.首先,用户无法得到当前查询结果的分类语义范围,也无法发现推荐的分面类别(及其组合)对应的细化结果之间可能存在的包含关系.这限制了用户对查询结果的进一步探索,同时制约了查询结果过滤的有效性.其次,用户每次仅能增删一个查询关键字,或对一个已有查询关键字进行泛化或细化,无法执行语义更丰富的跳转.再次,用户无法对多个历史查询进行有效的分析.针对上述问题,本文提出了面向分面导航的层次概念格模型,来实现具有丰富语义的分面导航操作.若将分面导航过程中查询及其结果作为浏览状态,层次概念格是对浏览状态空间的一种本体描述.具体而言,层次概念格是无环有向图,格中节点对应所有具有相同查询结果的浏览状态,节点之间的有向边表示它们对应的查询结果之间存在极小包含关系.因此,层次概念格是一张包含所有浏览状态的地图,分面导航就是通过动态分面目录来引导用户在不同浏览状态之间跳转.为获取该层次概念格以支持导航的灵活性和实时性,本文进一步提出了格挖掘算法L-Miner来生成并索引格.L-Miner采用基于深度优先的格增量挖掘框架.该框架通过自顶向下且深度优先方式遍历生成格中所有节点,并通过动态维护当前已生成节点的直接后继来同步生成边.L-Miner利用倒排表索引少量已生成节点,并结合格的性质,来高效地完成上述框架下的两个关键操作,冗余检测和边更新.当格生成后,该倒排索引还可以支持高效的格导航算法.基于大量公开测试数据集的实验结果表明,L-Miner的格挖掘速度远快于现有算法,而索引却小得多.本文在第2节给出关于分面导航、形式概念格和格挖掘算法方面的相关工作;在第3节中,我们提出面向分面导航的层次概念格模型,以及基于层次概念格的导航操作;在第4节中,我们提出一种层次概念格的挖掘算法L-Miner,并在第5节中对L-Miner的性能进行实验分析;最后在第6节中对全文进行总结,并给出后继研究计划.2相关工作2.1分面导航分类目录是帮助用户探索数据的有效方式.分面导航是一种新的基于分类目录浏览数据的方式.与传统方式相比,分面导航具有以下两个主要特点:(1)分类目录结构呈森林状,具有多维分类语义;(2)目录结构随查询结果动态变化,只保留出现在查询结果中的类别.传统的目录结果是树状的,其类别通常涉及数据的不同特征,例如,对于音乐数据,目录结构中可能同时出现关于歌手和年份的类别.分面目录基于属性特征对传统目录进行规范化分解,其结构是森Page3林状的,其中每棵树代表基于一个属性的分类目录,称为一个分面.例如,歌手分面和年份分面表示为两棵树.与传统分类目录相比,分面目录的分类语义更清晰,且易于维护.分面导航的另一个特点是目录结构随查询动态变化.在传统导航式信息检索中,分类目录是静态的,可能包含成千上万的类别,尽管出现在查询结果中的类别可能很少.这不仅加重了用户浏览目录的代价,而且用户点击某个类别进行查询结果过滤时,经常遇到空结果,从而降低了导航的有效性.目前,分面导航不仅被广泛应用于电子商务网站和数字图书馆,而且逐渐成为研究热点.目前的研究主要集中在两方面.一方面是推荐给用户更有针对性的动态目录.早期的动态目录显示所有对应非空细化结果的类别,却仍面临类别数目过多的问题.文献[4-5]在生成动态目录前会向用户提问,根据回答推荐类别.在文献[2,6-7]中,动态目录中不同类别对应的细化结果之间的重合度较小,该推荐策略可以极小化期望的用户代价,包括查看的类别数以及鼠标点击次数.文献[8]生成个性化的动态目录.文献[9-11]将分面导航和在线联机分析处理相结合.文献[12]自动给出对应当前搜索结果的最小长度类别集,从而提高浏览效率.另一方面是自动生成分面目录,并通过构建类别之间的层次关系来降低用户的浏览代价.文献[13-14]分别利用监督学习和无监督学习从文本数据中构建分面目录.文献[15]利用无监督学习自动构建分面目录来组织用户提供的关键字.其它的相关研究还包括,文献[16-17]利用分面导航帮助用户浏览半结构化数据;文献[18]提出一种能适应不同屏幕大小的分面导航方式.代表性的分面导航系统有Flamenco[3]、SIMILE①和Haystack②.现有的分面导航操作只允许用户每次增删一个查询关键字,无法满足用户对具有丰富语义的导航操作的需求.本文中,我们将设计若干新的导航操作以支持用户在不同浏览状态之间更灵活地跳转,从而更有效地进行知识发现.2.2形式概念格形式概念格(FormalConceptLattice)[19]是根据对象及其属性自动构建的一个本体.形式化的表达如下:给定三元组〈A,B,f〉,其中A是对象集,B是属性集,函数f:A×B→{0,1},其中f(a,b)=1当且仅当对象a具有属性b.对于对象集OA和属性集XB,(O,X)是一个概念当且仅当:①O是具有X中所有属性的所有对象构成的集合;且②YX,o∈O,o不具有Y中所有属性.此时O称为该概念的外延,X称为该概念的内涵.所有概念根据外延的集合包含关系构成格,即对任意多个概念(O1,X1),(O2,X2),…,(On,Xn),存在:①最小概念(Om,Xm),满足i∈[1,n],有OmOi;和②最大概念(OM,XM),满足j∈[1,n],有OMOj.传统概念格不考虑属性间存在层次关系.本文通过扩展传统的形式概念格,提出层次概念格模型对分面导航的用户浏览状态空间进行建模.基于层次概念格,我们可以高效地完成所提出的具有丰富语义的导航操作.2.3频繁闭项集挖掘频繁闭项集挖掘[20-31]是数据挖掘中的核心问题之一,是众多数据挖掘任务的基础.在此,我们可以利用频繁闭项集挖掘算法得到层次概念格中的所有概念(概念和频繁闭项集一一对应),然后通过两两比较概念来计算层次概念格的边.由于层次概念格中节点数目通常高达几十万,这种两步计算方式的代价太高.CHARM-L[31]是最近提出的频繁闭项集格挖掘算法.它采用单步方式计算格,每生成一个新节点,就更有已有节点之间的边.因此,节点和边同时生成.与两步方式比,单步方式的效率更高.CHARM-L通过倒排表索引已挖掘的频繁闭项集来高效地实现频繁闭项集格挖掘中的两个关键操作,冗余检测和边更新.我们提出的L-Miner算法只索引了部分频繁闭项集,但结合层次概念格的性质可以更高效地完成上述两个关键操作.因此,L-Miner以更小的存储代价实现了更快的格挖掘.3面向分面导航的层次概念格模型分面导航是基于分面目录对查询结果分类并引导用户探索查询结果的有效方式.本节利用层次概念格对用户浏览状态空间进行建模,并基于层次概念格提出具有丰富语义的导航操作,帮助用户在导航过程中进行知识发现.3.1用户浏览状态空间在传统分面导航过程中,给定分面目录和关系①②Page4数据库表,用户以目录中已有类别为关键字进行查询.分面导航系统将返回属于指定类别集的所有资源(即数据库表中的元组).此外,分面导航系统根据查询结果过滤分面目录,仅保留出现在查询结果中的类别,从而引导用户进一步细化查询.传统分类目录通常是一棵树,树中节点代表分类类别,其孩子节点代表对属于该节点的资源(元组)的细分.值得注意的是,祖先节点和后代节点不一定存在子类型关系.例如,关于音乐专辑的传统分类目录中,代表2010年的类别“2010”的孩子节点可能为代表歌手的类别“王菲”、“刘德华”等.分面目录是一个多维分类目录,通常表示为森林.森林中每棵树代表一个分类维度.同一棵树上的祖先节点和后代节点之间存在超类型关系.在上面的音乐专辑例子中,代表年份的所有类别在同一棵树中,构成年份分面,而代表歌手的所有类别在另一棵树中,构成歌手分面.通过这种多维分类结构,分面目录的分类语义更加清晰,且易于维护.我们将分面目录形式化定义为关于类别的偏序集,类别之间的偏序关系和它们在分面目录中的层次关系一一对应.换言之,分面目录是该类别偏序集对应的哈斯图①.定义1.令是所有类别构成的集合.<是上的偏序关系,u,v∈,若v是u的超类,则u<v.uv表示u<v或u=v.称偏序集(,)为分面目录.例如,图1(a)中关于论文的分面目录包含两个分面,分别代表论文主题“Topic”和论文作者“Author”两个分类维度.该分面目录表示为偏序集({Topic(a),Image(b),Web(c),AI(d),SemanticWeb(e),Author(f),Charles(g),Lily(h)},<),其类别之间的所有偏序关系为{b<a,c<a,d<a,e<a,e<c,e<d,g<f,h<f}.显然,不同分面上的任意两个类别u和v互相独立,即u<v且v<u,其中“”表示取非.给定类别集X,若其同时包含存在子类型关系的两个类别u,v(u<v),则X-{v}表示的分类语义和X一致.因此,我们记concise(X)={u:u∈X∧v∈X(v<u)},表示X的最简描述;记verbose(X)={u:u∈∧v∈X(vu)},表示X的最繁描述.定义2.X,Y,若concise(X)=concise(Y),则X与Y的分类语义相同.若X=concise(X),称X是不可约类别集.除分面目录外,分面导航还假定每个资源r(元组)所属类别集均已知(通常根据资源的属性值可得),表示为categories(r)={u:u∈∧r属于类别u}.显然,categories(r)是最繁描述,事实上,我们只需指定其最简描述concise(categories(r))即可.例如,在图1(b)中,论文#1的所属类别集categories(#1)={a,b,c,f,g,h},其最简描述为{b,c,g,h}.给定分面目录(,<)和资源所属类别集,我们将分面导航过程中用户的浏览状态定义为由查询及其结果构成的二元组.本文中,我们假定查询是不可约类别集.查询结果为同时属于每个查询关键字(类别)的所有资源.令为所有资源构成的集合,记查询Q的资源集合为resources(Q)={r:r∈∧Qcategories(r)}.定义3.用户的浏览状态表示二元组〈Q,resources(Q)〉,其中Q为查询.设〈Q1,S1)〉和〈Q2,S2)〉是浏览状态,若S1=S2,则称〈Q1,S1)〉和〈Q2,S2)〉等价.因为分面导航采用关键字匹配(类别匹配)的方式进行精确检索,所以不同查询对应的查询结果可能相同.例如,在图1中,查询{c,d}和{e}等价,因为它们的查询结果均为{2,4,5,6}.表1给出了查询结果包含至少两个资源的所有浏览状态的划分,记为[2].其中每一行为对应[2]中的一个等价类.①图中每个节点表示集合S中的一个元素,节点的位置按它b∧a≠b),则a排在b的下边;如果a<b,且不存在c∈S满Page5查询结果{1,2,3,4,5,6}{},{a},{c},{f},{a,f},{c,f}{1,2,3,4,5}{2,4,5,6}{e},{d},{c,d},{e,f},{d,f},{c,d,f}{1,3,5,6}{1,3,4,5}{b},{b,c},{b,h},{b,f},{b,c,h},{b,c,f}{2,4,5}{1,3,5}{g,h},{b,g},{a,g,h},{b,c,g},{b,g,h},{4,5}{b,e},{b,d},{b,c,d},{b,e,h},{b,d,h},{b,c,d,h}{5,6}3.2层次概念格模型在分面导航过程中,用户从某浏览状态出发,经过多步细化和泛化后,有可能又得到同样的查询结果,尽管其查询不同.在现有的分面导航中,这种“原地转圈”难以被察觉,影响数据探索效果和搜索效率.因此,我们希望描绘一张关于浏览状态的全局地图,防止用户“迷路”.由表1可知,当数据库的分面目录较大且资源数目较多时,呈现给用户的无论是所有可能的查询结果还是它们对应的所有查询,都会导致庞大臃肿的“地图”,难以计算和浏览.因此,我们希望提供一个压缩的、信息无损的、简洁的“地图”.定义4.令X和Y均为查询,若u∈Y,v∈X,满足vu,则称X蕴含Y,记作XY.若XY且X≠Y,则X<Y.不同查询之间可能存在分类语义蕴含关系.给定浏览状态等价类,我们根据蕴含关系得到其对应的所有查询之间的偏序集.该偏序集中的极大元素(称为极泛化查询)描述了对应查询结果的极简分类语义,而极小元素(称为极细化查询)描述了对应查询结果的极繁分类语义.定义5.令X是查询.若对任意查询Y(Y>X→resources(Y)resources(X)),则称X是极泛化的.若对任意查询Y(Y<X→resources(Y)resources(X)),则称X是极细化的.进一步,我们可以证明给定浏览状态等价类,尽管其极泛化查询可能有多个,但其极细化查询是唯一的.也就是说,只存在唯一的极繁分类语义描述.引理1.令X是极细化查询.对任意查询Y,若resources(X)resources(Y),则XY.证明.假设XY不成立u∈Y,必有:(1)v∈X,u与v相互独立;或(2)v∈X,u<v.对情况(1),resources(X)resources(X∪{u})=resources(X)∩resources({u})resources(X)∩resources(Y)=resources(X).因为resources(X)resources(Y),所以resources(X)=resources(X∪{u}).这与X是极细化类别集相矛盾,故(1)不成立.对情况(2),令C是X中所有大于u的类别构成的集合,则Z=X-C∪{u}是不可约类别集.易知resources(C)resources({u}).故resources(X)=resources((X-C)∪C)=resources(X-C)∩resources(C)resources(X-C)∩resources({u})=resources(Z),即resources(X)resources(Z)成立.因为u∈Y,故resources({u})resources(Y).又resources(X)resources(Y),故resources({u})resources(X).显然,resources(X-C)resources(X).故resources(Z)=resources(X-C∪{u})=resources(X-C)∩resources({u})resources(X)∩resources(X)=resources(X),即resources(Z)resources(X)成立.因此,resources(Z)=resources(X).因为Z<X,这与X是极细化查询相矛盾,故(2)不成立.综上所述,假设不成立,必有XY.证毕.定理1.查询结果和极细化查询一一对应.查询结果对应一个或多个极泛化查询.证明.给定任意查询结果S,令是由所有查询结果为S的查询构成的集合,即={X:X是查询∧resources(X)=S}.显然非空.根据定义,中的极大元素为极泛化查询,极小元素为极细化查询,二者均存在.令X和Y是中的极小元素,根据引理1,因为resources(X)=resources(Y),所以XY且YX.故X=Y.由此可知,中极小元素仅有一个.因此,查询结果和极细化查询一一对应,查询结果对应一个或多个极泛化查询.证毕.因此,浏览状态等价类和极细化查询一一对应.但是,如果仅呈现极细化查询,用户尚无法确定还有哪些查询对应同一查询结果.在此,我们证明浏览状态等价类之间的格结构可以帮助实现该信息的重构.引理2.令Q1和Q2分别是对应查询结果S1和S2的极细化查询.Q1<Q2当且仅当S1S2.证明.()因为Q1<Q2,根据定义,u∈Q2,v∈C1,有vur∈resources(Q1),令X=concise(categories(r)).根据定义,有X{v},所以X{u}.因此,r∈resources(Q2).故S1S2.根据定理1,因为Q1≠Q2,所以S1≠S2.因此,S1S2成立.()根据引理1,因为S1S2,所以Q1Q2.根据定理1,Q1≠Q2.因此,Q1<Q2成立.证毕.Page6定理2.令是查询结果包含至少δ个资源的所有极细化查询X1,X2,…,Xk∈∪concise()},Y,Z∈∪concise(),其分别为X1,X2,…,Xk的最小公共上界和最大公共下界.〈∪concise(),<〉是完全有界格.证明.根据引理2,的极细化查询是X1,X2,…,Xk的公共上界.令{Y1,Y2,…,Ym}为X1,X2,…,Xk的所有公共上界.令查询结果S=resources(∪i=1,…,mYi)的极细化查询为Y,令U=∪j=1,…,kresources(Xj),则S=∩i=1,…,mresources(Yi)∩i=1,…,mU=U.故Y∈{Y1,Y2,…,Ym}i∈[1,m],Sresources(Yi).根据引理2,有YYi.所以Y是X1,X2,…,Xk的最小公共上界.令S=resources(∪i=1,…,kXi).当|S|δ时,令Z是其极细化查询i∈[1,k],Sresources(Xi).根据引理2易知,Z是X1,X2,…,Xk的公共下界.令L是X1,X2,…,Xk的任意公共下界,即i∈[1,k],有LXi.故resources(L)resources(Xi).因此,resources(L)∩i=1,…,kresources(Xi)=S.由引理2,LZ.所以Z是X1,X2,…,Xk的最大公共下界.当|S|<δ时,易知concise()是X1,X2,…,Xk的最大公共下界.综上所述,Z∈∪concise(),Z为X1,X2,…,Xk的最大公共下界.因此,偏序集〈∪concise(),<〉是完全格.令极细化查询X满足resources(X)=,显然X∈.X和concise()分别是该格的最大上界和最小下界,故〈∪concise(),<〉是完全有界格.证毕.根据定理2,给定多个查询,存在最小的极细化查询,其查询结果同时包含每个给定查询的查询结果;若所有给定查询的查询结果的交集至少包含δ个资源,则存在最大的极细化查询,其查询结果同时被每个给定查询的查询结果包含.次概念格.定义6.我们称偏序集〈,<〉的哈斯图为层图2是对应表1的层次概念格.为便于理解,图中同时给出了每个极细化查询的查询结果.现有的分面导航可利用层次概念格高效实现.给定查询(初始查询或经过细化或泛化操作形成的新查询),首先定位该查询对应的格中节点(该节点唯一).然后,根据该节点的后继,可以知道哪些类别的细化结果非空及其细化结果的大小,从而生成对应当前浏览状态的动态分面目录.特别的,我们还能知道动态分面目录中所有类别的非空细化结果之间的包含/相等关系,从而进一步优化动态分面目录的结构.在3.3节中,我们将阐述基于层次概念格的新的具有丰富语义的导航操作.根据定理3,基于层次概念格的边可以确定每个极细化查询对应的所有极泛化查询.因为查询结果对应的所有查询均介于对应的极细化查询和某个极泛化查询之间,所以基于层次概念格的边可以确定每个查询结果对应的所有查询.定理3.令极细化查询X的所有前驱节点为P1,P2,…,Pk.对任意查询GX,G是resources(X)的极泛化查询当且仅当:(1)i∈[1,k],PiG不成立;且,(2)对任意查询Y>G,i∈[1,k],使得PiY.证明.令S=resources(X).()假设i∈[1,k],PiG成立.根据resources(Pi)resources(G),再根据格定义Sresources(Pi),故Sresources(G).因为G是S的极泛化查询,所以S=resources(G).上述结论互相矛盾,故假设不成立,条件(1)成立.对任意查询Y>G,根据极泛化查询的定义可知:resources(G)resources(Y).因为S=resources(G),所以Sresources(Y).根据格定义知,i∈[1,k],使得PiY.()因为GX,所以Sresources(G).根据条件(1),i∈[1,k],resources(Pi)resources(G)不成立.根据格定义知:S=resources(G),所以G是S的查询.根据引理2,对任意查询Y>G,resources(Y)resources(Pi)S.因此,G是S的极泛化查询.综上所述,层次概念格(即所有极细化查询及其格结构)是对所有浏览状态及其跳转关系的无损压缩.3.3基于层次概念格的分面导航操作及算法层次概念格完整并简洁地表达了查询结果间的Page7包含关系.相应地,用户的浏览过程就是在格中不同节点之间进行跳转.分面导航通过动态分面目录来引导用户在不同浏览状态之间有效地跳转.现有的分面导航仅支持基于单关键字的细化或泛化操作,即用户选择动态目录中某类别细化当前查询结果,或通过删除一个查询关键字泛化当前查询结果.这种导航操作方式单一,只具备基本的知识发现能力.基于层次概念格,本文设计了以下新的导航操作以支持用户在不同浏览状态之间更灵活地跳转,从而更有效地进行知识发现:(1)显示分类语义范围semantics(Q):给定查询Q,定位格中相应节点,显示其极细化查询和所有极泛化查询;(2)指定比例进行细化refine(X,δ)或泛化expand(X,δ):分别显示与当前节点X距离不超过δ的极远后代节点和极远祖先节点;(3)历史查询分析join(X1,X2,…,Xk)和meet(X1,X2,…,Xk):分别显示节点X1,X2,…,Xk的最近公共祖先和最近公共后代.定义7.节点X1和X2的距离为dist(X1,X2)=1-|S1∩S2|/|S1∪S2|,其中S1=resources(X1),S2=resources(X2).semantics操作帮助用户定位给定查询对应的节点,该节点(即极细化查询)给出了对应查询结果的分类语义下界;根据定理3,其分类语义的上界可通过该节点在层次概念格中的直接前驱节点得到.expand和refine操作按比例细化和泛化查询结果,使得用户更易控制细化和泛化的粒度,逐步逼近潜在查询目的.另一方面,在传统分面导航中需要多步操作才能达到的浏览状态,通过上述操作可能只需一步,从而提高了信息查找效率.join和meet操作可以用来分析多个历史查询之间的关系.meet操作帮助用户了解多个查询结果的交集的分类语义,而join操作分析它们同属什么类别.基于上述操作,用户的查询日志可以形式化地表示为格上的节点跳转轨迹,并可通过适当的可视化技术呈现.接下来,我们基于层次概念格给出上述导航算法的实现.3.3.1semantics操作算法任意查询(例如查询Q)对应层次概念格中唯一节点(例如节点X),该节点满足XQ且resources(X)=resources(Q).要定位查询Q对应的层次概念格中节点,较为直接的做法是,对层次概念格进行自顶向下或自底向上的洪泛式搜索.在搜索过程中,当前节点X满足要求,当且仅当XQ,且其任意前驱节点和Q相互独立.考虑到层次概念格节点规模可能很大(如包含几十万个节点),上述直接定位方法的效率较低,难以满足导航实时性的需求.因此,本文提出基于极小极细化查询的倒排索引来提高定位操作的效率.极小极细化查询对应层次概念格中最底层节点.图2中所有极小极细化查询为{{e,g},{b,e,h},{b,c,g,h}}.定义8.令〈,<〉是层次概念格且X∈,若Y∈(Y<X),则称X是极小极细化查询.表2层次概念格的倒排索引表(令节点{犲,犵},我们按如下方式构建层次概念格的倒排索引表.每个列表对应分面目录中一个类别.对每个极小极细化查询X,将X所在节点的标识符添加到verbose(X)中每个类别对应的列表中.表2给出了对应图2中层次概念格的倒排索引结构.算法1.locate(Q).输入:查询Q输出:若Q频繁,返回层次概念格中节点close(Q);否Setminnodes←{n:u∈verbose(Q)(节点n在u的索引ifminnodesisemptyreturnnull;令X为minnodes中任意节点;whilepreds(X)isnotemptyboolbUp←false;//是否继续向上访问foreachY∈preds(X)ifYQX←Y;bUp←true;break;ifnotbUpbreak;returnX;基于上述倒排索引,算法1可以快速定位对应Page8查询Q的格节点,从而得到其查询结果的最细分类语义描述.首先,找出对应查询结果被resources(Q)包含的所有极小极细化查询minnodes.当minnodes为空时,查询Q对应的资源数目小于阈值δ.否则,从minnodes中任意节点X出发沿格中边向上攀爬,每次从X的前驱节点集preds(X)中选取任意不小于Q的节点作为当前节点,直至不存在满足该条件的节点.为减少攀爬步骤,我们可以在每一步中选取对应查询结果最大的那个节点.根据定理3,当前节点的极泛化查询可通过该节点及其前驱节点的极细化查询得到.依次考察verbose(Q)的大小为|verbose(Q)|-1到1的每个子集G.如果concise(G)不大于等于任意Pi(i∈[1,k]),将其放入候选集;否则,G的任意子集都不再考察.最后,候选集中极大元素即为当前节点的极泛化查询.3.3.2expand和refine操作算法定义7给出的节点距离反映了其查询结果之间的重合度.易知该距离与Jaccard距离一致,均满足三角不等式,即任意给定节点X1,X2,X3,有|dist(X1,X2)-dist(X2,X3)|dist(X1,X3).因此,我们可以采用如下方式进行expand和refine操作.对于expand(X,δ)操作,从X出发以洪泛方式访问其祖先节点,直至所达节点的所有前驱节点与X的距离均超过δ.对于refine(X,δ)操作,从X出发以洪泛方式访问其后代节点,直至所达节点的所有后代节点与X的距离均超过δ.3.3.3join和meet操作算法join和meet是格特有的操作,分别返回给定多个节点X1,X2,…,Xk的最小公共上界和最大公共下界.如图3所示,假定已经得到节点Nub,满足i∈[1,k],有XiNub.令J是按下述方法得到的节点:1.令Nub为当前节点.2.判断是否存在当前节点的直接后继节点Z,i∈[1,k],有XiZ.如果不存在,则返回当前节点并结束算法;如果存在,则将当前节点置为Z,并返回步2.如图3所示,假定已经得到节点Nlb,满足i∈[1,k],有NlbXi.令M是按下述方法得到的节点:1.令Nlb为当前节点.2.判断是否存在当前节点的直接前驱节点Z,i∈[1,k],有ZXi.如果不存在,则返回当前节点并结束算法;如果存在,则将当前节点置为Z,并返回步2.易知,J和M分别是给定节点X1,X2,…,Xk的最小公共上界和最大公共下界,即为join和meet操作的返回结果.格的根节点是满足要求的Nub,Nlb可以通过扫描所有极小极细化查询得到.根据下述定理,meet操作还可以通过算法1间接实现.定理4.meet(X1,X2,…,Xk)=locate(∪i=1,…,kXi).证明.令Si=resources(Xi),i∈[1,k].令U=∪i=1,…,kXi,S=S1∩S2∩…∩Sk.易知S=resources(U).根据定理1,S对应的极细化查询Y是X1,X2,…,Xk的公共下界.假设Y不是X1,X2,…,Xk的最大公共下界,则存在查询结果S,SS且i∈[1,k],有SSi.因此,SS1∩S2∩…∩Sk=S.故假设不成立,Y是X1,X2,…,Xk的最大公共下界.因为resources(locate(∪i=1,…,kXi))=S,所以结论成立.4L-Miner:层次概念格挖掘算法当数据库较大时,在用户浏览过程中动态生成层次概念格的代价太高,如计算当前查询结果的极细化查询就需要扫描一遍数据库.为满足实时性,需要预先生成格.本文提出一种层次概念格挖掘算法L-Miner,它采用一棵类别集枚举树以自顶向下且深度优先方式生成格节点,同时进行边更新.4.1基于深度优先的格增量挖掘框架层次概念格的挖掘任务分为两部分,节点挖掘和边挖掘.我们采用基于深度优先的格增量挖掘框架.该框架通过深度优先遍历一棵类别集枚举树生成所有节点,该类别集枚举树中节点和格节点一一对应.每当生成一个新节点,就更新已有节点之间的边.因此,当所有节点都生成时,格中所有边也同时Page9得到.该框架下的两个关键操作,冗余检测和节点后继维护,将在4.2节和4.3节中分别叙述.4.1.1类别集枚举树类别集枚举树通过枚举类别组合来生成查询结果至少包含δ个资源的所有极细化查询.树节点和格节点一一对应,因此可将类别集枚举树看成是层次概念格的自顶向下的深度优先遍历树.每个树节点表示为三元组〈fci,supp,ref_seq〉,fci是极细化查询,supp是支持度,(等于|resources(fci)|),ref_seq是收缩对序列.每个收缩对表示为二元组〈ref_item,trans〉,其中trans=resources(fci∪{ref_item})且δ|trans|<resources(fci).在类别集枚举树中,根节点对应整个资源集.对每个树节点,依次访问其所有收缩对,对非冗余的收缩对生成该树节点的孩子节点.在此过程中,后代树节点是通过不断收缩祖先节点对应的资源集得到的.图4为对应图2中层次概念格的类别集枚举树.节点1~9的生成顺序是深度优先的,与其编号一致.根节点1对应整个资源集{1,2,3,4,5,6}.因为所有类别中只有a,c,f对应所有资源,而a是c的超类,所以1fci=concise({a,c,f})={c,f}.其余类别b,d,e,g,h的查询结果分别为{1,3,4,5},{2,4,5,6},{2,4,5,6},{1,3,5,6},{1,2,3,4,5},所包含的资源数均小于6,故均为根节点的收缩对.收缩对列表中类别b,d,g,h分别对应1的孩子2,5,8,9.由于类别e对应的细化结果和d的相同,所以是冗余的、不生成1的孩子.令当前节点为i,以其为根的子树按如下方式生成.依次对i的收缩对序列中每个收缩对Rj进行冗余检测,即是否存在已生成的树节点t(t<i)满足resources(tfci)=Rjtrans.若否,则生成i的新孩子节点k,其对应资源集为Rjtrans,然后对其深度优先遍历;若是,则跳过该收缩对并检测下一个收缩对.由于枚举树是深度优先生成的,故只有k所在的子树均已生成后才会考察其父节点i中排在Rj后的收缩对.对新生成的孩子节点k,其支持度等于|Rjtrans|,极细化查询为concise(ifci∪Rjref_item∪{Rmref_item:Rm是i的收缩对∧Rm排在Rj之后∧RjtransRmtrans}).k的收缩对序列为{〈Rmref_item,Rmtrans∩Rjtrans〉:Rm是i的收缩对∧Rm排在Rj之后∧δ|Rjtrans∩Rmtrans|<|Rjtrans|}的任意排列.新节点的初始化过程举例如下.1的第1个孩子2对应其第1个收缩对〈b,{1,3,4,5}〉,其trans和后面的收缩对的交分别为{4,5},{4,5},{1,3,5}和{1,3,4,5}.由此可见,d,e,g可将2细化为不小于阈值的更小的资源集,而h无法将其细化得更小.因此,2fci=concise(1fci∪{b}∪{h})={c,b,h}(图中以圆圈标识).同理,2的第1个收缩对对应其第1个孩子3.该收缩对与其后收缩对的交分别为{4,5}和{5}.故3fci=concise(2fci∪{d}∪{e})={b,h,e},且3的收缩对序列为空(因为δ=2).然后,考察2的第2个收缩对〈e,{4,5}〉,它的trans和2相同,故冗余,不生成新节点.不断执行上述过程直至遍历生成整棵枚举树.值得注意的是,在上述过程中:(1)收缩对序列的初始顺序可以任意;(2)令当前正在考察i的收缩对Rj,若其trans包含或等于其后某收缩对Rt的trans,则可以删除Rt(因为它必冗余).关于类别集枚举树的正确性,可参照频繁闭项集挖掘算法中的相关证明[31].4.1.2边更新L-Miner实时维护所有已生成节点之间基于偏序关系的哈斯图.每生成一个新节点,就更新此哈斯图的边.因为层次概念格就是所有节点之间基于偏序关系的哈斯图,所以当所有节点生成时,同时得到格中所有边.格中边不存在这种关系,具体而言:虽然树节点和格节点一一对应,但是树中边和(1)若节点Y是节点X在枚举树上的孩子,则Y不一定是X在格中的直接后继;(2)若节点Y是节点X在枚举树上的后代但非孩子,则Y一定不是X在格中的直接后继;(3)若节点Y是节点X在格中的直接后继,则Y可能在枚举树深度优先遍历生成过程中先于X生成.Page10在格中的所有后继节点均已生成.性质1.当节点所在子树均已生成时,该节点基于上述性质,我们设计如下边增量维护方法.首先,类别集枚举树的节点生成顺序和前序遍历一致,但输出顺序和后序遍历一致.其次,树节点输出时,除了输出其极细化查询和支持度外,同时输出该节点在格中到其直接后继的边.我们通过如下方法确定树节点输出时其在格中的直接后继.对枚举树中当前路径上每个节点,我们动态维护其在层次概念格中的直接后继列表,记为succs().根据性质1,当输出后,succs()不再发生变化,即为在最后得到的格中的所有直接后继.传统方法一般采用分阶段法挖掘格,先生成所有节点,然后确定边.由于节点数目通常较为庞大,在确定每个节点的后继节点时,需要比较大量的节点.我们使用的边增量计算方法可以减小需要比较的节点,从而提高边的计算效率.4.2冗余检测冗余检测是确定是否存在已生成的树节点,其查询结果与给定收缩对的资源集相同.冗余检测是类别集枚举树生成过程中的关键操作,节点生成效率很大程度上取决于冗余检测的效率.显然,扫描所有已生成的节点并进行比较的效率太低.在此,我们基于3.1节中提出的关于极小极细化查询的倒排索引来完成高效的冗余检测.性质2.令当前树节点为,中待检测的收缩对为〈u,S〉.〈u,S〉是冗余的当且仅当∈succs(),locate(fci∪{u})返回非空节点,且其支持度等于|S|.例如,对图4中节点8,其收缩对序列仅含一个收缩对R=〈h,{1,3,5}〉.当8新生成时,其后继节点为4和6.对R进行冗余检测时,只需查验4和6被h细化后能否得到{1,3,5}.因为h∈4fci,所以locate(4fci∪{h})返回节点4.又4supp=3,故该收缩对是冗余的.因此,冗余检测中的关键操作就是3.1节中讨论的定位操作,基于极小极细化查询的倒排索引可以高效地完成.4.3节点后继维护图5(a)显示了6输出时的格结构.与树结构相比,多了一条边〈5,3〉.图5(b)显示了7生成后已挖掘格结构的变化情况.除新节点7和其父节点5外,其余节点的后继不发生变化.边〈5,3〉被〈7,3〉取代;另外,多了一条新节点到其父节点的边〈5,7〉.图5(b)显示了8生成后已挖掘格结构的变化情况.除新增新节点到其父节点的边〈1,8〉外,还多了两条新节点到其初始后继节点的边〈8,4〉和〈8,6〉.图5结点生成后格结构的变化(当前路径上根据上述例子,易证新节点生成时,除新节点和其父节点的后继发生变化外,其余节点的后继保持不变.因此,我们在枚举树生成过程中同时生成所有节点到其后继节点的边,在格生成后根据后继关系很方便就得到前驱关系,由此完成格的挖掘.令是新生成的节点,对应其树上父节点的收缩对〈u,S〉.我们只需初始化的直接后继并更新的后继,其余节点的直接后继不发生变化.具体而言:(1)succs()←max{:∈succs()∧=locate(fci∪{u})∧非空},其中节点之间的偏序关系与其极细化查询之间的偏序关系一致;(2)succs()←succs()-succs()∪{}.因此,关键操作仍然是3.1节中讨论的定位操作,可高效地完成.5实验结果与分析本节通过实验分析我们提出的格挖掘算法L-Miner的运行速度和索引大小.运行环境为Lenovo启天M7000,CPU为双核2.93GHz,2GB内存,Ubuntu9.04操作系统.代码用C++编写.我们采用UCIKDDArchive①中的公开数据集①http://kdd.ics.uci.edu/Page11chess,connect,mushroom和pumsb,其中每条记录对应一个资源,每个项集对应一个类别.频繁项集挖掘算法中广泛采用这些数据集进行性能分析[20-31].表3列举了每个数据集的总资源个数(#Trans)、总类别个数(#Items)、每个资源对应的平均类别数(AL)和最多类别数(ML).mushroom数据集描述了不同种类蘑菇的特征,pumsb数据集是人口普查信息,它们代表了实际应用中可能遇到的分面数据库.因此,格挖掘算法在mushroom和pumsb数据集上的性能可以有效指导基于层次概念格的分面导航系统的构建.数据集#Trans#ItemsALMLchessconnect675571304343mushroom81241192323pumsb4904621137474尽管大量的频繁闭项集挖掘可用来计算格节5.2格挖掘速度L-Miner和CHARM-L的节点生成方式是一致的,即对同样的收缩对排序方式,所有节点的生成顺序相同.它们的主要区别在于冗余检测和边增量生成采用了不同的数据结构和算法.我们考察了3种收缩对排序方式:①表示按其细化类别的标识符大小排序;②表示按其细化结果的大小升序排序;③表示按其细化结果的大小降序排序.对于每点,但只有CHARM-L[31]同时高效地计算边.因此,对比算法选择CHARM-L.以下各图的min_sup指查询结果所包含的最少资源个数δ占总资源数的比例.5.1索引规模L-Miner用倒排表索引目前已生成的所有极小极细化查询,而CHARM-L用倒排表索引所有已生成的极细化查询.因此,二者的索引大小之比约等于格中极小节点数目除以所有节点数目.图6表明L-Miner的索引远小于CHARM-L的索引.例如,在chess数据集上,当min_sup为60%时,极小节点数为3323,而所有节点数为98393,故L-Miner的索引大小约占CHARM-L的索引大小的3.4%(≈3323/98393).在connect(min_sup=65%)、mushroom(min_sup=1%)和pumsb(min_sup=65%)数据集上,该比例分别为3.2%(≈1587/49705)、13.1%(≈6768/51640)和3.4%(≈18182/496070).个格,我们测试了L-Miner和CHARM-L在这3种序下的挖掘时间,结果如图7所示.可以看出:(1)L-Miner对序的变化不敏感,而CHARM-L在序②下的速度明显慢于其它序;(2)L-Miner在任意序下的速度均快于或接近于CHARM-L在特定序下达到的最快速度,且随着格的增加,前者远快于后者;(3)随着格大小增加(即min_sup减小),L-Miner的挖掘时间缓慢增长,而Page12图7表3中数据集在不同min_sup下的格挖掘速度图8考察每个收缩对时需访问的平均节点数CHARM-L在各种序下均快速增长.例如,在chess数据集上,当min_sup为60%时,L-Miner在不同收缩对排序方式下的平均速度约为CHAMR-L的4.4倍.在connect(min_sup=65%)、mushroom(min_sup=1%)和pumsb(min_sup=65%)数据集上,该速度比值分别为3.4倍、3.4倍和3.0倍.图8描述了序②下L-Miner和CHARM-L在考察每个收缩对时所需访问的平均节点数.在chess数据集上,随着格节点数从5084增加到98393,L-Miner所需访问的平均节点数从13缓慢增加至21,而CHAMR-L则从58快速增加到257.在数据集connect上,随着格节点数从8253增加到49705,L-Miner所需访问的平均节点数从14缓慢增加至19,而CHAMR-L则从159快速增加到659.在mushroom数据集上,随着格节点数从4885增加到51640,L-Miner所需访问的平均节点数从13缓慢增加至15,而CHAMR-L则从31快速增加到120.在pumsb数据集上,随着格节点数从8510增加到496070,L-Miner所需访问的平均节点数从9缓慢增加至26,而CHAMR-L则从47快速增加到752.因此,L-Miner随着格的增大具有良好的可扩展性.Page136结论及下一步研究本文提出了面向分面导航的层次概念格模型和挖掘算法.其主要贡献包括:(1)提出了描述所有浏览状态及其关系的本体———层次概念格,用来建模分面导航过程中用户在不同浏览状态之间的跳转;(2)提出了基于层次概念格的导航操作,以支持用户在不同浏览状态之间更灵活地跳转,从而更有效地进行知识发现;(3)提出了格挖掘算法L-Miner,并基于公开数据集进行了深入的性能分析;实验结果表明L-Miner的格挖掘速度远快于现有算法,而其构建的索引结构的存储代价更低.进一步的工作包括对基于层次概念格的分面导航原型系统实现,以及将该技术应用于个人信息管理、电子商务和数字图书馆.
