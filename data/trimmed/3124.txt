Page1基于输入端无冲突算法的面向输出排队的交换结构夏羽高志江曾华遷(西南交通大学信息科学与技术学院成都610031)摘要该文提出了一种全新的面向输出排队的交换结构,该结构将信元存储于输入端,而信元的调度请求面向输出端排队.利用输入端无冲突调度算法,可以使结构对存储器带宽的需求和输入排队交换机一致.该文设计的调度矩阵使算法复杂度和端口规模呈线性关系,且每一步只需要一次按位“与”操作.文章同时证明了结构要达到稳定的充分条件是使用2倍传输加速比.仿真实验表明,对于均匀流量,该结构时延性能和主流交换结构相似,且抖动性能远优于主流交换结构,而在2倍传输加速比时,其时延性能和OQ完全相同;对于非均匀流量,该结构吞吐率性能优于主流交换结构,且在使用1.14倍传输加速比时,其吞吐率性能和OQ相同.关键词交换机架构;吞吐率;稳定性;输入排队;面向输出排队1引言交换机/路由器已经成为影响网络性能的关键设备,对于未来单波长速率高达100Gbps以上的高速骨干通信子网,对交换结构和调度算法的挑战更为严峻.早期交换机使用的共享存储(SharedMem-ory,SM)和输出排队(Output-Queued,OQ)结构虽Page2然被证明能够提供最好的性能,但却不能用于现代高速网络环境,原因在于它们需要存储器速率分别为2NR(N次写入和N次读出)和(N+1)R(N次写入1次读出),其中N为交换结构的端口数,R为端口速率.目前的商用存储器发展远远落后于交换机对存储器的需求,存储器已经成为交换机性能的瓶颈,而OQ交换机需要交换矩阵(switchfabric)工作速率为线速率的N倍,这也使其难以满足大规模高速交换的需要.输入排队(Input-Queued,IQ)的交换结构只需要在每个时槽内对存储器读、写各一次,在同样的端口速率下,其对存储器速率的要求(2R)远远低于OQ交换机,且与交换规模无关,因此成为目前主流的交换结构.但是IQ交换机受“队头阻塞”(Head-of-LineBlocking,HoLblocking)的制约,对均匀流量也只能提供58%左右的吞吐率[1].采用虚拟输出队列(VirtualOutputQueue,VOQ)可以解决“队头阻塞”问题,但加剧了输出竞争,需要额外的匹配调度算法.基于VOQ的交换结构的仲裁配调度问题被抽象成图论中的二分图匹配(bipartitegraphmatching)问题,并有如下结论:(1)使用最大匹配(MaximizeSizeMatching,MSM)算法,其复杂度为O(N2.5),且不能达到100%吞吐率;(2)使用最大权值匹配(MaximizeWeightMatching,MWM)算法,如LQF(LongestQueueFirst)、OCF(OldestCellFirst)或LPF(LongestPortFirst),可以达到100%的吞吐率[2].但是MWM算法的复杂度为O(N3),这使得它难以在高速(high-speed)或大规模(large-scale)的交换机中使用.随后的文献提出了大量时间复杂度较低的极大匹配(maximalSizeMatching,mSM)算法,如著名的PIM[3]、iSLIP[4]和DRRM[5]等算法以及它们的大量改进算法都是对极大匹配算法的趋近.然而,这些启发式算法(heuristicalgo-rithms),最多也只能对均匀流量提供100%的吞吐率,而对非均匀流量不能保证100%的吞吐率.文献[6]提出的MQWS算法在保持和iSLIP算法相似复杂度的条件下,可以对非均匀流量提供很高的吞吐率,但还是不保证在任意许可流量下均达到100%吞吐率.因此如何设计高效、稳定且高性能的匹配调度算法便成为基于VOQ的交换机设计中的核心问题.另一种可以有效提高IQ交换结构的吞吐率,而不需要高复杂度调度算法的途径是使用加速比(speedup),输入端口接收一个信元的时间称为一个(外部)时槽(externaltimeslot),在加速比为s的条件下,一个外部时槽内有s个信元可以从输入端通过交换矩阵被发送到输出端(其中传输一个信元的时间称为一个传输时槽,有的文献也称其为内部时槽(internaltimeslot)),而一个时槽内,只有一个信元可以从输出端口离开,因此输出端需要缓存,从而形成输入输出结合排队的(CombinedInput&OutputQueued,CIOQ)交换结构.当加速比为2时,采用极大匹配算法(MaximalSizeMatching)的CIOQ结构可以提供100%的吞吐率.上述交换结构的后续研究文献中还提出过多种新型交换结构,如基于BufferedCrossbar的交换结构[7]、Clos的网络结构[8]和负载均衡的BvN(LoadBalancedBirkhoff-vonNewmen)交换结构[9].第1种结构需要使用交叉节点带缓存的crossbar,而后两者属于多级交换结构.BufferedCrossbar交换结构的规模受限于超大规模集成电路的工艺而性能受限于大往返时间(LongRound-TripTime,LongRTT)问题;Clos结构的内部冲突问题,需要额外的算法来解决,且其性能的好坏还要取决于其所使用的单级交换结构;负载均衡交换结构虽然无需调度算法但时延性能不佳,且存在分组失序问题,解决分组失序需要额外的算法,且会进一步降低时延性能甚至吞吐率.这些问题都阻碍了这些新结构在工业界的大规模使用,因此目前主流交换机的设计和生产主要还是使用或者基于crossbar单级交换结构.IQ交换结构调度算法复杂度高且可达性能受限,而OQ交换结构性能较好却依赖于高速存储器以及具有N倍加速比的交换矩阵.本文试图在交换性能、调度及实现复杂度之间找一个平衡点,提出了一种能够发挥两种典型存储排队方式的优势,同时调度与实现复杂度相对较低的面向输出排队(Out-put-OrientedQueued)的交换结构,它属于输入存储的单级crossbar交换结构.本文设计的输入端无冲突(InputConflict-Free,ICF)算法,可以保证在2倍传输加速比(无调度加速比)的条件下,即每块存储器只需要3R的带宽(输入缓存为一次写入和两次读取,输出缓存为两次写入一次读取),使OOQ交换结构对任意许可流量提供100%的吞吐率.配合本文设计的调度矩阵,每个分组到达时,只需要一次并行按位“与”(bitwiseand)操作即可完成调度.仿真实验表明,在许可流量下,不需要加速比,该交换结构即可对均匀流量提供100%的吞吐率,且时延和现有主流结构或算法相当,而由于OOQ结构能最大程度地保持信元先进先出的顺序,因此时延抖Page3动性能明显高于现有交换结构而和OQ相当;对非均匀流量,OOQ也可以提供很高的吞吐率,当使用1.14倍传输加速比而无需调度加速比,就可以对各种非均匀流量提供100%的吞吐率.本文第2节介绍面向输出排队的交换结构和输入端无冲突算法;第3节证明交换结构传输加速比为2是OOQ/ICF结构对任意许可流量提供100%吞吐率的充分条件;第4节探讨ICF调度矩阵的硬件实现;第5节通过仿真比较OOQ/ICF和其它主流交换结构和算法的性能;第6节将讨论OOQ/ICF交换结构为何能更好地支持SUPANET网络环境;第7节总结全文并展望下一步的工作.2面向输出排队的(OOQ)交换结构和输入端无冲突(ICF)算法2.1OOQ交换结构设一个交换机有N个输入端口和N个输出端口(记为N×N的交换机),通常交换机内部只处理定长分组,称为信元(cell),若输入端口接收的是变长分组,则将其切分(segment)为定长信元,而在图1面向输出排队的交换结构由于受到输入端口速率的制约,一个时槽内,只会有一个信元到达,因此对于输入端缓存只有一次写入.但是在同一个时刻,一个输入单元可能同时被多个输出单元“拉”,然而,一个输入单元只能同时响应一个输出单元的拉请求.因此需要额外的调度算法来解决这个冲突.2.2节将介绍的输入端不冲突(ICF)算法可以保证,在同一时刻,最多只有一个输出单元从一个输入端“拉”信元.2.2ICF算法和传统的使用FIFO队列(FirstInFirstOut输出端口再将属于同一个分组的信元重组(reas-semble).在传统的交换结构中,存储与排队同时进行.例如传统的IQ结构,信元存储在输入端,排队也在输入端,而OQ结构信元存储于输出端,而排队也在输出端.在我们的新交换结构中,如图1所示,实际的信元存储于输入端的缓存中,而排队则在调度模块中进行,且队列被组织成面向输出端的方式,因此我们将其称为面向输出排队(Output-OrientedQueued,OOQ)的交换结构.当一个信元从某输入端口到达,该输入单元在将信元存储于输入缓存的同时向调度组件发送一个排队请求.调度组件接收到输入单元发送的请求后,使用相应的调度算法,在对应的输出端请求队列中找一个合适的位置,将该请求入队.每个传输时槽开始时,输出单元取出队头请求,并配置交换矩阵从输入单元取得对应的信元并发送,此过程称为“拉”.在传统的匹配算法(如iSLIP)中,一个信元可能要请求多次才能匹配成功,而在OOQ结构中,一个信元一旦请求即可成功入队,从而避免了在输入单元和调度组件之间多次交换信息.队列,只能从队尾写入,从队头读出)的交换结构不同,OOQ/ICF使用RIFO队列(RandomInFirstOut队列,可以在队列中任意为空的位置写入,但只能从队头读出)作为OOQ交换结构的输出端请求队列.由于存储器可以随机访问(randomaccess),对于定长信元,只要给定入队位置,则RIFO的实现和FIFO的实现复杂度相同.在OOQ交换机中,一个输入单元可能收到多个拉请求,为了解决这一冲突,我们希望算法可以将请求安排到输出端请求队列中一个合适的位置,该Page4位置在输出时不会和其它输出单元发生“拉”冲突.为此,我们定义输入端无冲突位置.定义1.输入端无冲突(InputConflict-Free,ICF)位置:对于某个输入单元i发送到输出单元j的请求来说,输出端j的请求队列中的某一空闲位置,如果在其它输出端k≠j的请求队列中的同一位置上,没有来自输入单元i的请求,则该位置被称为是关于输入端i无冲突的位置.对于特定的请求来说,输入端无冲突位置也称为可用位置(availablelocation),如果将每个请求都入队到对应输出端请求队列中的可用位置,则在所有输出端请求队列中的同一列上,不会存在来自同一输入单元的请求.从而在任一时刻,不同的输出单元不会同时向同一个输入单元“拉”信元.因此每次输出时,输入缓存只需读取一次,最终需要的存储器速率仅为2R,和IQ交换机一致.在信元到达的时刻,对应的请求队列中可能存在多个可用位置,如果在其中随机地选择一个位置放置请求,则信元离开的顺序可能会与信元到达的顺序不同,即可能产生错序.为防止错序,我们始终将输入端发送的排队请求安排在首个可用位置(最接近队头的位置),对于从同一个输入端口进入而指向同一个输出端口的所有信元,先到达的信元的请求一定排在后到达信元的请求之前,而请求只能从队头取出,因此可以确保信元不会错序.对于一个信元,只要它的请求在OOQ/ICF中被入队,则其离开时间(排队时延)就已经确定.ICF的执行过程可以分为输入调度和输出调度两个独立的过程,其具体过程可分别描述如下.输入端.在每个时槽开始时1.对于每一个输入端口,如果该输入端有分组到达(各1.1.将该分组缓存于对应的输入端缓存中;1.2.向调度组件发送一个请求,该请求包含了对应2.对于每一个输入端发送的请求:2.1.调度组件在对应的输出端请求队列中查找首个2.2.将请求入队到首个可用位置;步2.1的查找过程是整个算法的核心,我们将在第4节中介绍专门设计的硬件(ICF调度矩阵)来实现快速查找.使用ICF调度矩阵,每次查找只需要做一次寄存器的按位“与”操作.输出端.在每个时槽开始时1.对于每一个输出端请求队列(各个输出端口之间并1.1.如果队首是空请求:1.1.1.移除队首,队列中所有元素向输出端方向1.2.如果队首不是空请求:1.2.1.取出队首请求(请求中包含输入端口号和1.2.2.配置交换矩阵;1.2.3.向对应输入端发送拉信号,拉信号中包含1.2.4.对应输入端口接收到拉信号后,将对应分由于输入调度过程已经解决了拉冲突,输出时已经不存在冲突,而仅仅只是取出请求,然后拉对应的分组,随后输出,该过程将非常简单.为了更好地理解ICF调度算法,在图2中,我们列举了ICF的调度过程的实例.如图2(a)所示,输入端口1有一个指向输出端口A的分组到达,则输入单元1发送一个请求给调度模块,对于该请求来说,位置4、5是输入端无冲突位置.虽然位置2未被任何请求占用,但是输出端B的请求队列中,位置2有一个来自输入单元1的请求,因此位置2是输入冲突位置,不能使用.根据选择首个可用位置的原则,该请求应该被放置在位置4.如图2(b)所示,输入端口1到达一个指向输出端口C的分组,则输入端口1向调度模块发送请求,对于该请求来说,位置3、5是输入端无冲突位置,因此选择首个可用位置3放置该请求.从同一列(图中的虚线框)上看,所有请求都来自不同的输入单元,所以不会产生“拉”冲突.每一个传输时槽开始时,所有输出端口都同时取出队头请求,而不管该队头请求是否为空,例如输出端口A的请求队列中的位置2为一个空请求,当该位置到达队头时还依然为空请求,则输出端口A将该空请求移除,输出端口A在该传输时槽内将处于空闲状态.Page53OOQ/ICF结构稳定性分析在IQ交换机的设计中,可以通过提高加速比来提高交换吞吐率.本节将证明2倍传输加速比足够让OOQ/ICF结构在任意许可流量下达到100%的吞吐率.3.1符号和定义对于一个N×N的基于VOQ的交换机,其调度问题可转化为图论中的二分图匹配问题.用随机过程Ai,j(n)∈{0,1}表示时槽n从输入端口i到达并指向输出端口j的信元数,称方阵犃(n)=[Ai,j(n)]N×N为到达过程矩阵.其均值E[Ai,j]=λi,j1称为从输入端口i到达并指向输出端口j的信元到达速率,而方阵Λ=[λi,j]N×N称为到达速率矩阵.定义2.许可流量(admissibletraffic).如果到达过程犃(n)满足如下条件:则称其为许可流量.用方阵犕=[mi,j]N×N表示匹配矩阵,其中mi,j=1表示输入端口i和输出端口j匹配,而mi,j=0表示输入端口i和输出端口j无匹配.该匹配矩阵其实就是crossbar的配置矩阵,因此犕是一个置换矩阵(permutationmatrix).用ti,j(n)表示在时槽n时,VOQi,j的队头信元的等待时间,则方阵犜(n)=[ti,j(n)]N×N称为在时槽n的(队头)等待时间矩阵.用di,j(n)表示在时槽n时,队列VOQi,j中的队头信元和其下一个信元的到达时间之差,则方阵犇(n)=[di,j(n)]N×N称为时槽n时的到达时间间隔矩阵.对于任意N阶方阵犡=[xi,j]N×N,可以定义其对应的向量形式犡=(x1,1,…,x1,N,…,xN,N).而对于两个向量犡=(x1,x2,…,xn)和犢=(y1,y2,…,yn),有犡犢T=∑n图3OOQ/ICF和GMWM/OCF逻辑关系(相同)示意3.2稳定性证明文献[10]证明了强稳定(stronglystable,简称稳定)的排队系统可以保证100%的吞吐率,并介绍了如何用Lyapunov方法来证明稳定性.文献[2]用该方法证明了MWM/OCF(MaximumWeightMatching/OldestCellFirst)算法对任意许可流量保证稳定.MWM算法属于线性规划算法,它从全局的角度来优化匹配,从而可以保证得到的最终权值最优.对于规划问题,另一种复杂度相对较低的算法是贪婪算法(greedyalgorithm),它只在每一步寻求最优解,但是最终结果不一定全局最优.贪婪极大匹配算法(GreedyMaximalWeightMatching/OldestCellFirst,GMWM/OCF)过程如下.1.将所有VOQ队头信元的等待时间写入矩阵犜(n),如果VOQ为空,则相应元素为空,矩阵犕(n)元素全置为0.2.如果矩阵犜(n)中所有的元素都为空,则结束并返回矩阵犕(n),否则继续步3.所有元素也置为空.然后返回步2.3.从矩阵犜(n)的所有元素中选择一个最大的ti,j(n).4.将矩阵犕(n)中对应的元素mi,j(n)设为1.5.将矩阵犜(n)中第i行的所有元素置为空,第j列的本小节我们先证明ICF算法调度的结果和GMWM/OCF调度的结果一致.随后再证明GM-WM/OCF算法达到稳定的充分条件是使用2倍加速比.定理1.ICF调度算法的调度结果和GMWM/OCF算法的调度结果一致.证明.如果所有请求都按其到达顺序被插入到队列中,那么很容易可以证明ICF和GMWM/OCF算法具有相同的调度结果.因此我们主要证明在请求插入队列时错序的情况下,两种算法仍然具有同样的调度结果.若有两个请求A和B,如果B比A晚到达,但是B却插入到了A的前面.如图3所示,这有两种可能情况.Page6(a)A和B在同一个请求队列l中,若请求A和B是从同一个输入端口到达的,则它们一定是按到达顺序插入队列的.因此我们只需证明A和B从不同的输入端口到达的情况,则此时在另外一个队列m中一定存在一个与A到达端口相同的请求C,C的到达时间一定早于A,否则,当A到达时B的位置还不存在冲突,因此A应该插入到B的位置上.而对于GMWM/OCF算法,由于A与C关于输入端口冲突,它也将选择C来匹配,而不是A,因为C的等待时间大于A.(b)A和B在不同队列中,假设B在队列l中,而A在队列m中.这时存在3种情况:(b1)A和B从同一个输入单元到达,则在队列m中B的位置上一定存在一个和A从不同端口到达的请求C,且C的到达时间一定早于A,否则当A到达时B的位置还没有被占用,则A将被插入到队列m中B的位置.同样对于GMWM/OCF算法,由于A与C关于输出端口冲突,它也将选择C而不是A来匹配,因为C具有更长的等待时间.(b2)和(b3)都是A和B从不同输入单元到达的情况,无论在哪一种情况中,A一定是被一个更早到达的信元C所阻挡,这和在GMWM/OCF中的情况是一致的.在所有情况下,ICF和GMWM/OCF都具有同样的调度结果,因此我们说ICF和GMWM/OCF在逻辑上相同.文献[11]中的定理4提供了一种比较不同调度算法稳定性的工具.我们将利用此工具比较GMWM/OCF算法和MWM/OCF算法的稳定性,从而最终证明GMWM/OCF算法稳定的充分(非必要)条件是使用两倍加速比.为此我们先证明如下引理.引理1.如果一个调度算法满足如下条件.犕i(n)犠Ti(n)1其中犠i(n)是第n个时槽,第i个内部时槽的权值向量,而Ki(n)0是同时被算法和MWM/OCF选中的各队列在队头信元离开之后的权值变化量之和,则一个采用算法的交换机稳定的充分条件是使用两倍加速比.证明.为简短起见,我们这里只基于GMWM/OCF算法证明.对于GMWM/OCF算法,权值变化就是队列中队头信元到达时间和次信元到达时间的差值,但如果队列中没有次信元,则队头信元离开后,队列的权值将变为0,此时权值变化即等于队头信元的等待时间.假设GMWM/OCF算法符合式(1),则可分解得到如下两个公式:犕GMWM1(n)犜T1(n)1犕GMWM2(n)犜T2(n)1根据MWM的定义,即犕MWM2(n)犜T2(n)=max犕{犕犜T2(n)},其中犕表示所有可能的N!种匹配;并且第1个内部时槽中可能有信元离开队列,从而到第2个内部时槽时权值可能减小,因此有犕MWM2(n)犜T2(n)犕MWM1(n)犜T2(n)同样对于GMWM算法,第一个内部时槽也会有信元离开,因此有则由式(3)~(5)可以得到犕GMWM2(n)犜T1(n)1最后合并式(2)和(6)可以得到应用文献[11]中的定理4和式(7)可以证明在两倍加速比下算法稳定.我们也可以从一般意义上来解释式(7):以两倍加速比运行算法(即一个时槽运行两次)得到的权值大于等于MWM算法得到的权值,因为MWM算法稳定,则算法必然也稳定.引理2.对于任意一个非空的VOQi,j,用wi,j表示在队头分组离开后该队列权值的变化量,那么一定有如下关系成立:其中ti,j表示在队头信元离开前的等待时间.证明.存在两种情况.(a)该队列中队头分组之后没有分组.在这种情况下,队头分组离开之后队列的权值将变为0,那么队列的权值变化量直接等于队头分组的等待时间ti,j.(b)如果队头分组之后有其它分组,为了不失一般性,我们假设当前时槽为n,队头分组的到达时Page7证明.根据引理1只需要证明GMWM/OCF间为k,而队头分组后的分组的到达时间为k+m,其中m是这两个分组的到达时间间隔.证明的关键是注意到m=wi,j以及ti,j=n-k.由于当前队头分组后面的分组已经存在,也就是说k+mn,因此可以得到ti,j=n-km=wi,j.综合两种情况,最终可以证明式(8).证毕.由于在引理1中,我们假设GMWM/OCF满足式(1),下面我们将证明其确实满足式(1),从而最终证明GMWM/OCF算法在两倍加速比条件下稳定.定理2.一个使用GMWM/OCF调度算法的交换机稳定的充分(非必要)条件是使用两倍加速比.算法在每个内部时槽满足如下条件:犕GMWM(n)犜T(n)>1其中K(n)是同时被算法和MWM算法选中的队列在队头信元离开之后的权值变化之和,即可证明其稳定性.分别让IMWM(1)(n)和IGMWM(1)(n)表示被MWM算法和GMWM/OCF算法选中的队列的集合.那么该集合之间只有如下两种关系.情况1.IMWM(1)(n)=IGMWM(1)(n),则表明MWM算法和GMWM/OCF算法选择了相同的队列,因此它们选中队列的权值之和也相等:犕GMWM(n)犜T(n)=犕MWM(n)犜T(n),因此GMWM/OCF算法稳定.示集合IGMWM(1)(n)中具有最大队头等待时间的队列,则又有两种情况:情况2.1.g(1)2W(g(1)与集合IMWM(1)(n)中都包含队列g(1)其中W(c)表示队列c的队头信元的等待时间,然后令情况2.IMWM(1)(n)≠IGMWM(1)(n),则令g(1)情况2.2.g(1)中最多可能包含两个在输入或者输出端口上与g(1)冲突的队列,设它们分别是c(1)于g(1)i,j(n)具有最大的队头等待时间,所以有2W(g(1)然后令IGMWM(2)(n)=IGMWM(1)(n)-{g(1)IMWM(2)(n)=IMWM(1)(n)-{c(1)则此时IMWM(2)(n)中不再含有与g(1)接下来再考虑IGWMW(2)(n)中队头等待时间最长的队列g(2)IGMWM(i)(n)和IMWM(i)(n),直到集合IGMWM(i)(n)为空为止.假设集合IGMWM(k)(n)为空,则集合IMWM(k)(n)只可能包含空队列.如果IMWM(k)(n)包含非空队列ci,j(n),则ci,j(n)一定与IGMWM(1)(n)中的任何队列都不冲突.而GMWM/OCF是极大匹配算法,因此这样的ci,j(n)是不存在的.注意式(10)表示集合IMWM(i)(n)和IGMWM(i)(n)包含相同队列的情况,而式(11)表示集合IGMWM(i)(n)与IMWM(i)(n)包含不同队列的情况.这两种情况之间互斥,且在每一步中,两者有一个成立.因此将式(10)与(11)合并可以得到犕GMWM(n)犜T(n)>1注意此时的V(n)是同时被GMWM/OCF算法和MWM/OCF算法选中的队列的队头等待时间之和.而由引理2可以推导出:犕GMWM(n)犜T(n)>1因此最终可以证明GMWM/OCF算法稳定的充分条件是使用两倍的加速比.由于ICF调度算法最终从逻辑上等效于GMWM/OCF算法,所以ICF算法稳定的充分条件也是使用两倍加速比.但是GMWM/OCF算法最多需要N次迭代才能得出一个极大匹配,且第i次迭代最多需要从(N-i)2个数中查找一个最大值.如果还要使用两倍加速比,则每个时槽需要运行算法两次.在高速交换机中,GMWM/OCF算法太过于复杂.而对于ICF算法,由于每个时槽最多有N个信元到达,因此每个时槽只需要运行算法一次,即可将所有请求调度完成,而对于输出过程,只需从队头取出请求即可.下一节介绍的调度矩阵可以快速地查找出请求的入队位置.4ICF调度矩阵的实现ICF调度器的工作方式不同于任何其它基于crossbar的调度器,传统的crossbar调度器在信元需要输出时执行调度,而ICF调度模块在信元到达时执行调度,且调度的结果即为crossbar的配置矩Page8阵.它们的区别在于:如果交换结构使用s倍加速比,则传统的crossbar调度器一个时槽必须执行s次,而ICF只需在每个时槽开始时执行一次,因为一个时槽内每个输入端口最多到达一个信元,而ICF调度矩阵一次可处理N个排队请求.下面介绍ICF调度模块的核心组件:ICF调度矩阵,该矩阵的主要功能是在接收到输入单元发送的请求后,在相应的输出端请求队列中快速查找到首个可用位置,然后将该请求入队.如图4(a)所示,位置查询单元(LocationSearcher,LS)维护相应的输出请求队列的占用和冲突状态.其中LSi,j用于为从输入单元i到达的请求在输出端j的请求队列中图4调度矩阵示意图LS的核心功能就是在对应输出端请求队列中找首个可用位置,在查找时,关键要排除两种位置:(1)队列中已经被占用的位置;(2)队列中没有被占用,但是和其它队列存在输入端冲突的位置.假设输出端请求队列最大队长为L,则我们在每个LS中使用两个容量为L位的寄存器分别表示队列中各个位置的占用情况和冲突情况,如图5(a)所示,这两个寄存器分别称为占用指示寄存器(OccupationIn-dicationRegister,OIR)和冲突指示寄存器(ConflictIndicationRegister,CIR),而占用寄存器中的各个位称为占用指示位(OccupationIndicator,OI),1表示该位置未被占用,而0则表示该位置被占用;类似地,冲突寄存器中的各个位称为冲突指示位(Con-flictIndicator,CI),为1表示该位置没有和其它队图5位置查询单元工作原理逻辑图查找首个可用位置,一个LS查找到相应位置后,会将该位置广播给同行同列的LS,以便它们及时更新占用和冲突的状态.图4(b)展示了一种理想情况,各个输入端口发送的信元是指向不同的输出端口,则各个LS可以同时调度.图4(c)显示了一种极端情况,各个输入端到达的信元都指向同一输出端口,由于各个LS独立工作,因此它们选择的位置可能存在冲突,因此每一步只能有一个LS进行查找位置,等完成后,将其结果广播给同行同列的LS更新它们的状态,然后下一个LS再执行查找,直到所有请求处理完成.列相同位置发生冲突,为0则表示发生冲突.图5(a)中位置0虽然未被占用,但是该位与其它队列冲突;位置1虽然未与其它队列冲突,但已经被占用;位置3既被占用也和其它队列中的相同位置冲突;位置2和位置4都未被占用和冲突,都属于可用位置.因此OIR和CIR按位与的结果中所有为1的位置都是可用位置.由于需要找到首个可用位置,如图5(b)所示,我们引入了优先级编码器,优先编码器可以处理优先级最高的输入,并编码输出.编码的另一个目的是减少结果的位宽,便于在各个LS之间广播数据.同行的LS接收到广播的结果之后将更新其CIR,而同列的LS接收到广播结果之后将更新其OIR.CIR和OIR更新过程相同,如图5(c)所示,一个LS接收到广播数据之后,先通过二进制Page9译码器将位置信息恢复,其中为1的位置是需要更新的位置,将其取反之后再与寄存器中原来的数据按位与,最后得到更新结果.对于调度矩阵,每个时槽最多只要做N次查找即可将所有请求都入队,属于线性时间复杂度,而每次查询只需一次寄存器的并行“与”操作,由于“与”和优先编码都属于组合逻辑,因此该过程只存在门时延.我们使用Verilog语言对一个4×4的OOQ交换机的调度矩阵的调度情况进行了验证,图6为运图64×4交换机调度矩阵硬件仿真波形图5仿真实验我们在为NS-3(NetworkSimulator3)建立的交换机仿真平台[12]上对OOQ/ICF和主流交换结构进行了仿真实验.所有仿真中我们都设置端口数为32(其它端口数情况有类似结果).每一个仿真都运行106个时槽,并从第103个时槽开始收集数据.平均时延为所有收集到的时延的平均值,而时延的变化为收集到的时延偏离均值的情况.吞吐率的统计方法为在数据采集时段内,所有离开交换机的分组数和所有到达交换机分组数的比值.限于篇幅,本文只列举两组主要的仿真结果.第1组仿真是对均匀分布流量下时延和抖动的仿真,由于在低负载下各算法性能比较接近,从而曲线不易区分,因此在图中,所有负载均从70%开始,以便可以区别各条曲线.s为传输加速比,Burst为突发流量长度.图7(a)为Bernoulli流量下的仿真结果,从中可见,ICF算法和GMWM/OCF算法性能完全一致,行过程中3个时槽的波形图,该调度矩阵共有16个位置查询单元,图中只显示了位置查询单元1,1的状态.时槽1为4个输入端口到达的信元分别指向不同输出端口的调度结果;时槽2为所有输入的信元都指向同一个输出端口的调度结果;时槽3是部分输入端口到达的信元指向同一个输出端口的调度结果.从图中可以看出,调度结果与预期的一致.该调度矩阵已经在Altera的FPGA上验证通过.这和分析是一致的.ICF算法和5-SLIP算法时延性能相似但略差于后者(但在实际中,iSLIP算法一般都只会实现3次迭代而不是5次).而使用1.2倍传输加速比的ICF算法性能相对5-SLIP有大幅度提高,值得注意的是,ICF算法提高传输加速比时,并不需要提高调度加速比,而这个特性对于其它算法并不成立.使用1.6倍传输加速比时,OOQ/ICF结构的时延性能将优于CICB-1/RR结构而和OQ非常接近,其中CICB-1/RR表示交叉点带一个缓存的BufferedCrossbar交换机,且输入端和输出端均使用轮询(Round-Robin)调度机制.使用2倍传输加速比时,OOQ/ICF时延性能和OQ完全一致.图7(b)所示为ON/OFF突发流量下的时延性能仿真,其中处于ON和OFF状态的时间均服从几何分布,处于ON状态时,每一个时槽都发送一个信元.处于ON状态的时间的均值称为突发长度,仿真中我们取10、32和100分别表示小突发、中等突发和大突发.同一突发内到达的信元都指向同一输出端口,而突发之间的指向在各个输出端口间均匀分布.从图中可见,在这3种突发长度下,各结构时延Page10性能之间的关系与Bernoulli流量下类似.但随着突发长度的增大,ICF、iSLIP和CICB-1/RR结构的时延性能越来越接近.当使用2倍传输加速比时,ICF算法将获得和OQ相同的时延性能.图7(c)所示为各种结构时延抖动的仿真.从图中可以看出在Bernoulli流量或者突发流量下,5-SLIP(SLIP最好迭代结果)都有较大的时延抖动.而随着突发长度的增大,CICB-1/RR结构的抖动逐渐图7均匀分布流量下时延和抖动的仿真结果第2组仿真主要考查在非均匀流量下各交换机的吞吐率.交换机仿真中常用的非均匀流量主要有非平衡流量(unbalancedtraffic)、非对称流量(asymmetrictraffic)和对角流量(diagonaltraffic)(包括强对角和弱对角).若设端口负载率为λ,而分别用λUi,j,λAi,j和λDi,j表示从输入端口i到输出端口j的数据流在非平衡流量、非对称流量和强对角流量(弱对角流量和非平衡流量类似)情况下的负载,则有如下表达式:λUi,j=λAi,j=akλ,j=(i+k)modN,ak=λDi,j=其中参数w∈[0,1]称为非平衡系数;参数f∈(1,+]称为非对称系数;参数d∈[0,0.5]称为对角系数(与取值[0.5,1]时对称).增大,最终和5-SLIP的抖动重合.而对于OOQ/ICF结构,其抖动始终和OQ结构相当,且当突发长度增大时,其时延抖动逐渐和OQ重合.这个特性主要是得益于ICF算法最大程度地保持了信元先进先出的顺序.对于目前多媒体和实时交互数据比重越来越大的网络环境,保持时延抖动稳定无疑有重要的实际意义.图8(a)显示了在非平衡流量下的吞吐率仿真结果,从中可以看出,在最坏情况下,iSLIP只能达到80%左右的吞吐率,而CICB-1/RR结构可以达到85%左右的吞吐率,而ICF算法在无加速比的情况下就可以达到98%以上的吞吐率,而仅需要1.02倍传输加速比,其吞吐率即可达到100%.图8(b)显示了在非对称流量下的吞吐率仿真结果,该结果表明在最坏情况下,ICF在无传输加速比时的吞吐率可以达到95%以上,远远高于iSLIP和CICB-1/RR.当使用1.08倍传输加速比时,ICF算法可达到100%吞吐率.图8(c)为在强对角流量下的吞吐率仿真结果,强对角流量是一种非常扭曲的许可输入流量.当对角系数d取值为0.5时,表示一个输入端口只会有指向两个相邻的输出端口的信元等概率地到达,这种情况对ICF算法是最不利的.此时,ICF算法的吞吐率只能达到88%左右,略高于CICB-1/RR在最坏情况下的吞吐率(87%).只有当加速比增加到1.14时,才能达到100%吞吐率.从仿真结果来看,ICF算法只要使用1.2倍传输加速比就可以在时延和吞吐率上均达到比较理想的效果,而不需要使用前文证明的2倍传输加速比,1.2倍传输加速比从实现的观点看也比较合理.Page11图8非均匀流量下吞吐率的仿真结果6OOQ/ICF交换机对EPFTS环境的支持“单层用户数据交换平台体系结构”(Single-layerUser-dataswitchingPlatformArchitecture,SUPA)是四川省西南交通大学网络通信技术重点实验室针对目前Internet面临的高速交换、服务质量保障、安全等方面的挑战而提出的下一代高速网络的体系结构框架[13].考虑到“未来骨干通信子网必然以光通信技术(别是DWDM)支撑,光通信技术的误码率已经降低到10-12”,OSI/RM设置独立的数据链路层完成检错后重传的必要性已经大大降低.加上许多物理层传输技术都引入了物理层帧的概念,而层帧间的不兼容又需要额外的“帧间适配开销”,因此将部分功能融合,并对网络层次进行简化,就是我们为骨干通信子网提出的单层用户数据交换平台体系结构.通过对现有的基于光纤的通信技术的分析,我们认为这些技术都不适应单物理层用户数据传输平台的需要.ITU的工作以光纤交换(fiberswitching)和波长交换(lambdaswitching)为主,缺少多粒度能够适应不同速率的应用数据流向下复用和交换的需要;在多波长环境中直接利用SDH技术实现单波长内的向下复用又存在成本较高和对计算机网络典型分组提供服务时需要切分与重组等不利因素;而学界对DWDM交换技术的研究,如:光突发数据交换(OpticalBurstSwitching,OBS),为了避免在电域内进行交换,采用全光域内数据传输方式,由于光域内缺少缓存和处理能力,难以解决好服务质量保障与信道利用率之间的严重矛盾[13].由此可见,需要提出新的交换技术来构建单(1)长帧.EPFTS帧长2024字节,以实现对最大“以太网MAC帧”的封装而不需要进行分割与重组;对于传统的64字节的信元交换时槽,EPF时槽可为交换节点提供更充足调度时间.(2)定长帧交换.变长分组在交换前需切分为定长信元进行交换,交换后再重组;而SUPANET的以EPF定长帧为基础交换,交换前后不需拆分和重组,不存在帧内信元错序问题;定长帧的存储管理简单,队列的实现也更加简单.物理层用户数据传输平台,这正是面向以太网的物理帧时槽交换技术(Ethernet-orientedPhysicalTimeslotSwitching,EPFTS)[14]提出的背景.我们的经验表明,SUPA及其EPFTS技术为OOQ/ICF的实现提供了有利的条件,而OOQ/ICF技术又反过来进一步支持了SUPA目标的实现.与现有的网络体系结构相比,SUPA对路由和交换平台的支持具有如下优势:(3)面向连接的用户传输与交换服务.SUPA通过运行服务质量协商协议(QoSNP)为一对用户间的数据流的传输建立基于服务质量的端到端的虚通路(virtualpath),因此,同一对用户间的数据流可保证无错序帧;Internet在网络层提供无连接的转发服务,每个IP报文都必须查找路径表后再进行转发,而基于IP的查找复杂度较高.此外,路径更新可能造成同一对用户间的报文流内报文错序或因形成环路而造成TTL超限被丢失;SUPANET与其它面向连接的交换技术,如ATM(AsynchronousTransferMode)和MPLS(Multi-ProtocolLabelSwitching)一样,仅需在建立连接阶段查找路径表,而连接一旦建立,就只需要通过每个帧所携带的路径信息,使用固定长度的路径标示查找出口信息,从Page12而简化查表操作,降低线卡功耗和发热量.(4)超前交换(stepforwardswitching)技术.充分利用建立连接过程中获得的下游节点的输出端口信息作为连接标识符,因而当帧到达输出端口时,不经查表即可以直接发送排队请求.而下一个节点的出口信息的查找过程可以在帧交换时并行查找,并在出口处再进行更新.综上所述,OOQ/ICF结构在SUPA以EPFTS技术为基础的平台上实现,可以充分利用SUPA和EPFTS的优势,并且可以为SUPA提供更好的服务质量保证.相对于目前以IP为基础的网络环境,我们认为OOQ/ICF在SUPA环境下实现具有不可比拟的优势.7总结与展望本文提出了一种面向输出端排队的交换结构(OOQ),该结构将实际的信元存储于输入单元,但是其请求在输出单元排队.输出单元在一个传输时槽开始时从请求队列中取出队头请求,然后从输入单元“拉”信元.此时存在多个输出单元“拉”同一个输入单元的冲突.本文随后提出了一种输入端不冲突(ICF)的算法来解决这一冲突,为了配合这一算法,我们设计了一种调度矩阵来快速选择出队列中的可用位置,并将请求放置到该位置.使用这种调度矩阵,ICF算法的复杂度和端口数呈线性关系.我们同时也证明了OOQ/ICF结构调度的结果等价于贪婪算法GMWM/OCF的调度结果,在此基础上进一步证明了ICF算法要达到100%吞吐率的充分条件是使用2倍的传输加速比.在研究过程中我们发现,ICF算法的思路和FPCF(ForwardingPlanningConflict-Free)[15]策略类似,但区别在于:(1)后者没有给出相应的理论分析并证明算法达到稳定性的条件;(2)FPCF给出的位置查找算法性能低,不实用,本文设计了一种实用的快速查找不冲突位置的调度矩阵;(3)也是最重要的区别,ICF算法排队是在输出端进行,而FPCF算法排队还是在输入端进行,从而输出端口不知道要到达该端口的具体信元数量.实验表明面向输出的排队机制对于拥塞控制和主动队列管理的实现都有很大优势.文章最后通过仿真发现,无论在Bernoulli还是突发的均匀流量下,ICF算法和5-SLIP算法的时延性能都比较接近,特别当突发长度较大时,ICF和其它结构或算法的时延趋于相同.同时,ICF算法的抖动性能都优于iSLIP算法和CICB-1/RR结构,且当突发增大时,ICF算法的抖动性能越来越接近OQ.这对于当前多媒体数据和实时数据传输非常有利.在非均匀流量下,仿真结果表明,只要使用1.14倍左右的加速比即可达到100%吞吐率.综合时延和吞吐率的仿真结果来看只要使用1.2倍的传输加速比,即可达到比较好的时延、抖动和吞吐率性能.由于本文中证明的2倍加速比不是必要条件,我们在下一步的工作中将试图找到比2更低的条件,使得结构达到100%的吞吐率;其次我们将着重研究基于OOQ/ICF结构的优先级策略、拥塞控制、准入控制以及主动队列管理策略.
