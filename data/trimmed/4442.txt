Page1基于RED的差异型丢包队列管理算法朱海婷丁伟(东南大学计算机科学与工程学院南京211189)(江苏省计算机网络技术重点实验室南京211189)摘要网络流量中UDP成分的逐渐增加可能导致网络存在拥塞缓解失效的隐患.通过引入TCP流量与非TCP流量的区分丢包互斥机制,使用Lotka-Volterra竞争模型证明在该机制下TCP与非TCP流量在网络中必然存在平衡点,作者提出基于TCP与非TCP差异型丢包的队列管理机制.该机制依据TCP模型推导出的TCP协议流量的丢包概率,利用当前缓存队列中的TCP和非TCP数据包的状态,对不同的传输层协议产生差异型的动态丢包概率以确保AQM的稳定性和传输层协议间的公平性.关键词拥塞控制;主动队列管理;Lotka-Volterra模型;区分丢包1引言拥塞控制对互联网的稳定运行具有十分重要的意义,其中拥塞控制算法的研究也一直是互联网领域的热点问题.一般而言,拥塞控制研究包括在网络边缘设备中使用的源算法和在网络中间节点上使用的链路算法两种.源算法的原理是根据反馈信息调整源点端系统的发送速率;链路算法是在网络中间节点上检测拥塞,对拥塞进行反馈并进行相应的响应操作,以缓解拥塞.拥塞控制算法需要针对其所在互联网本身的异构复杂性和拥塞控制分布性的特性,还需兼顾拥塞控制算法的性能要求,因此其算法设计有较高难度.Page2尽管研究者在拥塞控制方向已开展了大量的研究工作,但是到目前为止拥塞控制问题还没有得到完美的解决.目前主流的链路拥塞控制算法是主动队列管理(ActiveQueueManagement,AQM)[1-3],其中得到最广泛认可的随机早期检测算法RED(RandomEarlyDetection)[4].RED是IETF推荐的基于中间节点的拥塞避免机制,研究表明RED比DropTail具有更好的性能,其主要优点是可以降低数据包丢包和降低数据包的经过延迟,同时还可以避免“死锁”情况的发生[4].虽然已有厂商设备能够支持,但因为RED有2个主要的问题,使其至今还没有在互联网中得到广泛的实际使用.其一是其性能对算法的参数设置十分敏感[5],其二是在公平性方面有所欠缺[6].RED会产生不公平现象的主要原因是其平等地看待每个报文.这对报文数量少的小流不公平,目前主要的与公平性相关研究工作均从这个角度展开[7-9],通过惩罚大流来降低小流报文被丢弃的概率.本文的研究也从公平性出发,但考虑的角度是传输层协议.目前网络流量中TCP和UDP是使用率最高的2个传输层协议,根据CAIDA公布的数据①和我们在CERNET某省网边界的观测②表明二者合计可以占到总流量的98%以上.很多研究直接或间接地表明UDP流量会影响TCP传输的通畅程度③,这种影响均是由拥塞导致的,如果在链路拥塞控制算法中平等地看待这两种协议,对TCP来说是不公平的,因为TCP使用端点拥塞控制算法,而UDP不使用.关于TCP与UDP在实际流量中比例方面,文献[10]在对国内某运营商的实测数据进行分析的基础上认为从所有角度看UDP流量已经占用了全部网络资源的50%左右.根据我们在本地被管网络上的观测,从2005年到起逐步从5%增加至目前的40%左右,而CAIDA的数据和文献[11]认为国外主干上UDP的比例在5%~20%之间.文献[12]认为以PPS为代表的使用UDP的P2P视频软件是导致国内网络流量中UDP比例偏高的原因.基于以上的分析,本文提出了一种基于RED的改进AQM算法SF-RED,其核心思想是在拥塞发生时按不同的方案处理TCP和UDP报文,来达到总体更加公平的目的.算法在设计思路上借鉴了生物学中种群的竞争模型,通过将TCP与UDP作为争夺相同资源(带宽)的两种物种,对资源紧缺的情况下二者的竞争关系进行建模.在模型基础上,我们给出使用拥塞控制算法合理性的推理证明.与RED相比,SF-RED算法还通过引入拥塞状态标识,对一次拥塞作为一个过程进行控制和管理,使用动态的参数设置丢包率来缓解与RED类似的参数敏感性问题.2相关工作2.1基于RED的AQM算法RED[4]是最经典的AQM算法,也是本文算法工作的基础.基于RED进行改进的算法较多,具代表性的有GRED(GentleRED)④、SC-RED[13](Self-ConfiguringRED)、ARED(AdaptiveRED)⑤等,他们都在RED的稳定性方面进行了改进.在公平性方面,较早对RED做出改进的有FRED算法[7](FlowRED),算法使用各个流在当前队列缓存中所占比例作为丢包判定指标,需要维护单流信息,因而不具备良好的可扩展性.后来这方面的研究逐渐转移为无需流信息维护的公平AQM算法,其中基于RED的算法是RED-PD[14].RED-PD算法在RED算法基础上加入了对当前丢包的记录,利用丢包记录来判断是否存在过度竞争或者存在非响应的流.它利用两个参数作为判断依据:(1)最近N次丢包记录;(2)某个流在这N次记录中出现次数.若该次数达到预先设定阈值,则判定为过度竞争流,并对其进行惩罚性丢包.但RED-PD算法的参数设置对算法效果影响较大,对拥塞响应时间也较长,而且针对短流丢包率较高[15].2.2其他改善公平性的AQM算法除了在RED算法基础上进行公平性的修正外,还有其他一些在公平性上进行改进的拥塞控制算法.在不需单流信息的公平AQM算法中比较有影响力的包括BLACK[9]、CHOKe[8]、SFB[16]、SAC[17]①②③④⑤loydS,GummadiR,ShenkerS.AdaptiveRED:Analgo-Page3和DCN[18]等.BLACK[9]算法通过对缓存队列进行数据包抽样,推断各个数据流在缓存中的占比,从而找出其中的竞争流并进行惩罚处理.CHOKe[8]算法是一个不需要预先判定恶性竞争流,而通过概率方式能实现近似公平的AQM算法.CHOKe算法采用FIFO队列,当需要丢包时则从当前缓存队列中随机抽取一个数据包,若该数据包与刚到达的数据包属于同一个流,则同时丢弃这两个数据包;否则,对取出数据包放回队列中,同时对刚到达的数据包进行丢弃判定.CHOKe算法简单有效而且易于部署和实施,但当流数量增加时,其有算法效性也会下降.在CHOKe的基础上,Jiang等人[17]提出了SAC(SelfAdjustableCHOKe)算法,其中增加了参数动态调整方案,使得CHOKe方法能够适应更多变的网络状况.Yang等人[18]提出了AME-CHOKe,算法针对CHOKe中引入多次比较参数的动态设置方案.Eshete等人[19]提出gCHOKe算法,在CHOKe基础上通过增加对非响应流的惩罚粒度来保护适响应流[20].WARD[21]算法提出的一种“无状态”的近似公平AQM算法,它通过给队列不同的位置设置不同的权值,量化了各流的实际速率与理想(公平状态)速率的差异,借此判断是否需要丢包.SFB[16]是StochasticFairBLUE的简称,其算法在BLUE算法基础上利用多级哈希散列的BloomFilter,找出恶性竞争流.BLUE用数据包的丢失率以及链路带宽利用率而不是队长来衡量链路的状况.SFB算法对检测出的恶性竞争流仅仅设置一个速率上限.但由于在实际环境中可以影响该阀值的因素太多,尚没有合理的计算方案,尤其在流数目增加时,SFB算法的性能会下降[14].DCN[18](DifferentialCongestionNotification)算法,利用互联网中短流的数量占优,而长流的传输数据量占优的特点,算法仅对长流触发拥塞通知,保护短流.DCN算法仅需要维护少量长流信息,算法实际是使用了较小的代价获得相对合理的网络公平性,同时确保较低的丢包率和较好的链路利用率.但在实际网络中大量存在的扫描、DDoS攻击等无功甚至有害流量均为短流,因此这个算法不适合在高扫描和DDoS攻击的环境下使用.另外,借鉴其他思想的AQM算法也有推陈出新,如控制论思想的PI[1]算法、REM算法[5]、引入虚拟队列概念AVQ算法[2].但它们在实用方面还存在问题,需要进一步的研究.从另外一个视角看,网络中的带宽分配上异质流的公平性问题在上述算法中目前还没有针对性的解决方案.在拥塞控制基础工作的机理模型上,对TCP协议的传输流量模型等,目前已经有较为深入的研究[22-24],UDP协议或其他非响应的协议控制和数据流虽然相对简单,但相对应的理论模型目前还有待完善,以UDP为代表的非响应流对TCP流的影响机理及其网络模型的研究工作仍还有待深入.关于TCP和UDP协议流共存时,UDP流对TCP流的影响的机理目前还没有相关理论上的深入研究[25],仅Song等人[26]提出了基于性能测量基础上的高速网络传输层拥塞控制方案.3SF-RED队列管理算法3.1RED队列管理RED[4]的基本思想是通过ExponentialWeightedMovingAverage(EWMA)方法(具体表现为式(1)),其中wq为常数,q为瞬时队长)维护面向每个到达的数据包的平均队长测度qavg,并用该测度的值与固定阀值的关系确定丢包率(式(2)),具体丢包率与平均队列长度的关系如图1.p=RED采用等概率随机分布丢包,可以缓解因丢包同步而随之产生的TCP流的同步现象.RED算法可保持相对较低的平均队长,有利于吸收突发流.但是RED算法仍然存在两大问题:(1)参数的设置问题.即无法找到在任何负载变化条件下都合适的参数;(2)带宽的公平性问题.即在不同的时延、拥塞窗口、数据包的大小、目标速度以及不同的协议情况下难以权衡.Page43.2SF-RED算法思路从第2节的讨论可以看出,现有的改善公平性的算法的主要思路是面向流的,其核心思路都是在拥塞发生时,通过惩罚具有某种特征的流来获得“公平”.其中的部分算法需要维护所有的并发“流”信息,这对目前主干路由器来说还是非常困难的.从报文协议的角度来看RED的公平性问题,由于RED平等地对待所有报文,当拥塞发生时,如果丢弃的是TCP报文,端系统能很快感知并自动放缓发送速度,使得拥塞能够很快缓解,但如UDP报文等非TCP报文不具备这样的能力.当UDP比例过高时,TCP让出的带宽还会被UDP占用.本文基于这样的基本问题,提出了一个面向协议间公平性的SF-RED主动队列管理算法.该算法工作机理基于RED,但对TCP和非TCP流量采用区分丢包的控制方式.TCP流量的丢包控制方式源于TCP模型推导的控制方程,而非TCP流量的丢包则通过与TCP之间的损失等价控制方式达到公平的平衡点.3.3区分丢包模型3.3.1TCP流量的丢包计算首先讨论本算法中针对TCP流量的丢包方式.RED算法在Qmin<qavgQmax时丢包率取决于对应时刻计算的平均队列长度和Pmax的值,丢包率的变化是线性的,这与TCP流量的行为模式有一定的差异.本文中TCP流量的丢包算法是单独处理的,所以采用更符合TCP的流量行为的丢包模型.具体而言,是选择了TCP协议中特有的参数“窗口”作为拥塞控制中计算TCP流量的丢包率的依据.记由源端Si到目的端Di的TCP流窗口大小在t时刻为wi(t),记路由器R上的在t时刻数据包的丢弃概率为p(t).对窗口wi(t)中的每一个数据包,其被丢弃的概率都是p(t),当p(t)很小时,对于窗口wi(t)来说,其中没有数据包需要重传的概率为∏wi(t)(1-p(t))≈1-p(t)wi(t).因此,无数据包丢失k=1的情况窗口变化速率为1/tRTT乘上丢包,即1-p(t)wi(t)tRTT.窗口wi(t)中有数据包丢失的概率为1-∏wi(t)半,同样有数据包丢失情况下窗口的变化速率为-p(t)w2i(t)2tRTT式(3).k=1当链路发生拥塞时,控制算法希望尽快阻止流量继续上升.对于每个TCP流来说,则是需要保证窗口不会增大,使得单个TCP传输窗口不增加的条件为式(4).式(3)代入式(4)得到式(5).由于TCP中往返时延均视为正值,因此通过式(5)可以获得在窗口不增加情况下p(t)与wi(t)间的关系,见式(6).从拥塞控制的角度看整体TCP流量,TCP每个流可能具有不同的窗口大小,假设存在一个理想的窗口大小为w(t),使得t时间整体TCP流量在丢包率pt(t)下增长率为0,它们之间关系应该满足式(7).SF-RED算法中使用该式作为TCP流量的丢包率计算模型.该计算模型在丢包率较大时可能会出现较大的误差,因此后面在使用该计算模型时,窗口参数也是估算值,其大小浮动变化用于弥补可能存在的误差.3.3.2其他流量的丢包计算如上所述,丢包对TCP流量的影响超过对以UDP为主的非TCP流量的影响,因此在设计非TCP流量的丢包模型时,将主要基于这个影响因素进行,即应尽量将2者的损失比例控制在同一个数量级上.根据AIMD原则,在丢包率为pt(t)下,整体TCP窗口为w(t)下,TCP流量的丢包数期望值为dropt(t)=pt(t)×Ntcp,其中使用Ntcp表示TCP的整体流量,而这些被丢失的数据包会对以w(t)为平衡窗口大小的整体的TCP流量产生预期的流量损失大小可以估计为losst=dropt(t)w(t)/2,因此TCP流量的损失比例为losst/Ntcp=pt(t)w/2.若将同一时刻非TCP的损失比例控制在同一水平上,则有式(8)成立:其中c为常量,若要使得非TCP流量因为其本身不Page5能对丢包进行反馈而增加其惩罚程度,即满足条件po(t)pt(t),则常量c需要满足c2/w(t).因窗口的大小满足w(t)1,因此推荐c的取值范围为[2,3].将式(6)代入式(8),因为窗口w为正,得到式(9).po(t)=cw(t)SF-RED算法中使用该式作为非TCP流量的图2给出式(9)中c取值为1、2、3时,2种类型流量在不同窗口大小下的丢包率变化情况.根据式(6),当w>1时TCP的丢包率是w的单调递减函数,当w=1时,其最大值为2/3.非TCP的丢包率则随着窗口增加单调递减,当w=1时,其最大值为c/3.丢包率计算模型.3.4算法描述SF-RED算法使用4个含义与RED算法完全相同的参数,分别是队列长度最小门限Qmin、最大门限值Qmax、Pmax和qavg.算法的核心思路是当qavg>Qmin时,定义SF-RED算法定义进入拥塞状态,用布尔变量cong进行标记.在拥塞状态下,按3.3中的讨论,分2种方式对TCP流量与非TCP流量进行区分丢包策略以到达2者稳定共存的目的.维护;算法中使用的其他参数:(1)当前队列长度q:在报文的到达和离开时(2)平均TCP队列长度qt(3)当前TCP队列长度qt,队列中TCP的队列(4)TCP报文丢包数dropt和其他报文丢包数(EWMA方法);长度:维护方式与q相同;dropo:进入本次拥塞后2种类型报文的丢包记录;(5)TCP的丢包概率pt和非TCP丢包概率po.根据窗口参数w(t)和式(7)和式(9)实时计算出的丢包率;(6)窗口参数w(t),用固定增加值a和固定减少值b维护(a,b初始化值均为1),用于计算TCP的报文丢包率pt值.SF-RED算法的伪代码描述如下:初始化算法参数Qmin、Qmax、Pmax、a、b;FOR每一个到达报文P{更新队列状态变量q,qavg,qt,qtIFq>缓冲最大值,进入强制丢包流程;EXIT;IFqavg<Qmin,cong=0非拥塞状态,报文正常加入队列;EXIT;IFcong=0//进入拥塞状态初始化拥塞算法参数w,dropt,dropo;本次不丢包,cong=1;ELSE{//随机抽取队列中的一个对比报文PIF发生丢包}FOR每离开一个报文{更新队列队长q,qt;}算法中各参数的初值.最小阈值Qmin、最大阈值Qmax需要根据实际情况自行设置,Pmax默认值采用同RED的默认设置为0.1.算法中参数w的初始化使用式(7)中丢包率与窗口的关系进行变换获得.由于窗口大小为正值,所以w使用式(10)进行初始化.其中的p0与RED的初始丢包率计算方式相同,具体表达式为式(2).参数w的维护参考当前队列中两种报文的比例与当前两种报文的丢包数比例.设当前队列中的TCP报文比例为rtqueue>rtdropcw/2成立,则增大w;否则减小w.rt算法中使用了从队列中选择报文,在其与到达报文类型不一致时丢弃的方法.这一基本思路源于种群竞争Lotka-Volterra(L-V)模型,有关的分析将Page6在下一小节给出.4基于Lotka-Volterra模型的算法收敛性分析本节使用L-V模型对TCP流量和非TCP流量的竞争关系进行刻画.带宽作为有限资源可以认为是传输层协议TCP与非TCP的共享资源.因此,可以将TCP与非TCP流量作为对同种资源进行竞争的两个种群来看待,符合面向特定资源的种群竞争L-V模型的条件.4.1Lotka-Volterra模型Lotka-Volterra模型(Lotka-Volterra种间竞争模型)是20世纪40年代,Lotka(1925)和Volterra(1926)提出的种间竞争方程对现代生态学理论,它奠定了种间竞争关系的理论基础.Lotka-Volterra模型是对Logistic模型的延伸[27].适用于描述在两种物种争夺有限的同一种食物来源和生活空间时而进行的生存竞争的情况.模型中设定甲乙两个种群,当它们独自在一个自然环境中生存时,数量的演变遵从logistic规律.记x1(t)、x2(t)分别代表两个种群的数量.r1、r2表示它们的固有增长率,N1、N2是它们的最大容量.于是对于种群甲有x·N()1子1-x1(t)的对其增长的阻滞作用,x1(t)位数量的甲消耗的食物量(设食物总量为1).当两个种群在同一自然环境中生存时,考察乙消耗同一种有限资源时对甲的增长产生的影响,可以合理地在因子1-x1(t)种群乙的数量x2(相对于N2而言)成正比,得到种群甲的增长方程其中δ1的意义是,单位数量乙(相对于N2而言)消耗的食物量为单位数量甲(相对N1)消耗的食物量的δ1倍.增长方程是x·类似地,甲的存在也影响了乙的增长,种群乙的根据式(11)和(12),对于两个种群相互竞争的结局进行分析,通过计算可求出4个平衡点和在每个平衡点下的稳定性条件见表1[27].(P3N1(1-δ1)从结果看,一共有3个稳定的平衡点.到达平衡点P1和P2时会导致其中一个的物种消亡,到达平衡点P3表示两物种保持二者在一定比例上共存.4.2SF-RED算法的收敛性分析本节借用Lotka-Volterra模型分析使用SF-RED算法条件下网络中TCP流量与非TCP流量的竞争关系.将TCP流量看作物种甲,非TCP流量看物种乙.TCP与非TCP流量在网络环境中对带宽的竞争相互影响,稳定共存的局面,满足Lotka-Volterra模型条件,可以用式(11)和(12)描述.其中x1(t)、x2(t)分别代表TCP流量和非TCP流量.系数r1、r2表示TCP和非TCP流量的固有增长率,N1、N2是网络中间节点上TCP和非TCP流量各自的最大容量.于是在网络节点上流量增加对于单纯的全TCP和非TCP流量都假设符合式(11)的形式,其中因子1-xi(t)有限导致的对流量增长的阻滞作用,xi(t)为相对于Ni而言单位数量的某方消耗的带宽资源.δ1表示非TCP对TCP的抑制作用,δ2表示TCP对非TCP的抑制作用.根据表1,平衡点P1表示网络中TCP流量占据了所有带宽.平衡点P2表示非TCP占据了所有的带宽.平衡点P3表示TCP与非TCP二者共存,共同享有带宽,二者处于动态平衡状态.如果平衡点P3存在,即使网络发生拥塞(即网络资源消耗到达极限),TCP和非TCP流量可以在一定比例上稳定共存,所以可以认为这个平衡点是我们在网络资源紧缺时为保证传输协议间公平竞争需要实现的目标.在网络中流量之间的竞争能力强弱体现在Lotka-Volterra模型中竞争能力系数δ1和δ2,其值Page7是与协议自身的算法相关的,网络中间节点对流量的控制无法改变其本质属性.SF-RED通过借助基于类型的丢包方式来修正该模型下平衡点.由3.4节的算法描述可知,SF-RED在拥塞状态下的丢包策略是随机抽取当前队列中的一个数据包,如果类型与当前达到的数据包相同则对到达数据包进行丢弃判定;否则,丢弃抽取的数据包.这样的丢包策略使得一个新到的TCP数据包的丢弃不仅取决于当前队列的长度也与当前队列中的非TCP数据包数量有关.同样,非TCP数据包的丢弃也不仅取决于当前队列长度也与当前队列中的TCP数据包数量相关.这个判定方式的原理是强行干预生物种群模型中2种物种的竞争模型,使得2种数据包之间的竞争关系式(12)发生了改变.在SF-RED算法下,新到的TCP的丢包率会随着队列中非TCP包的数量的增加而减少,同样新到的非TCP的丢包率也会随着队列中TCP包的数量的增加而减少.因此,SF-RED下两种类型的数据包在争抢带宽上满足微分方程组(15).烄烅烆对上述方程组进行分析,发现无法求出x1(t)和x2(t)的解析表达式,但是可以根据方程组得出在t→时的平衡点.假设从初始条件出发,存在x1=x01,x2=x02满表2竞争模型平衡点(P3N1(1+δ1)对该方程组进行分析可知,在满足δ1>0,δ2>0情况下,平衡点P3的条件成立.此时,另外3个之前的平衡点都为不稳定点.上述分析表明SF-RED算法中的基于类型的丢包方式(15),在Lotka-Volterra模型下可以保证TCP与非TCP在队列管理中能够按照其自身的属性达到一个二者共存的平衡点P3.4.3SF-RED算法的复杂度分析本节对照RED与CHOKe来分析该算法的复杂度.RED的时间复杂度和空间复杂度均为O(1),足limt→x1(t)=x01,limt→x2(t)=x02.这样可以得到新的4个平衡点P1(N1,0),P2(0,N2),P3N1(1+δ1)1-δ1δ)2N2(1+δ2)因为仅当平衡点满足(x1,x20)才有实际意义,微分方程组(15)令其导数等于0,使用方程组(16)表示,利用将方程组(16)在平衡点进行Taylor展开,取一次项,得出近似线性方程后,系数矩阵为犃,形式见式(17).r11-2x1N1+δ1x2N(熿犃=燀熿=燀再根据det(犃-λ犐)=0求特征方程根,得到方程组(18)根据对方程组的特征根分析,求出的平衡点和稳定性条件见表2(p、q参照式(18)).这也是RED算法的优势.尽管CHOKe需要随机选出一个候选报文进行对比,其时间复杂度和空间复杂度也同样是O(1).上文提出的SF-RED算法,每到达一个报文进行的处理与RED和CHOKe基本相同,其区别为在确定丢包率的算法上存有一些不同的处理.因此算法的时间复杂度仍旧是O(1).空间复杂度上增加几个需要的变量,变量数目不随着规模的增加而增加,因此其复杂度仍旧为O(1).整体上看,SF-RED算法保持了RED与CHOKe算法的优点.Page8另外需要指出的是,在收敛性方面,RED并不能阻止队列不断增长,如果用控制理论建模,它不能收敛到较短的目标队列长度.SF-RED通过引入区分丢包的方式对不同的流量进行不同方式的处理.其中TCP的丢包方式根据TCP的吞吐量模型进行推导,丢包率推导条件就是队列长度维持在增长率为0的界限(即队列长度不再增加,式(4)).UDP的丢包方式根据当前的算法中参数进行动态的计算(与TCP丢包率有关(式(8)).SF-RED的控制模型,结合了TCP的吞吐特点和UDP非响应流的特点,增加了CHOKe的惩罚机制,通过计算合理的丢包率可以很好的抑制队列长度的增长速度.5基于RTT的综合TCP传输性能测度为了验证上述SF-RED算法的有效性,使用NS2仿真环境对不同的非TCP流量比例下的网络状况进行测试.5.1仿真环境实验在NS2中使用如图3所示的拓扑结构.仿真使用单瓶颈的哑铃拓扑.有N1个TCP链接和N2个UDP链接与路由器分别相连接,与路由器之间的链路默认使用丢尾(drop-tail)方式,链路上限为2Mbps,延迟为10ms.路由器R1和R2之间链路默认带宽限制30Mbps,延迟20ms,队长为20个数据包.实验在较高的网络负载下进行,在不同的非TCP流量比重下测试每个算法的表现.R1到R2的链路上使用RED,CHOKe和SF-RED算法.5.2TCP流与UDP流共存的仿真结果仿真通过改变TCP和UDP流的数量,即通过不同的N1和N2的设置,测试算法的有效性.SF-RED中采用参数a,b,c都固定设置为1.图4和图5表示在不同的流数比[N1,N2]组合情况下,3种算法在相同的网络配置下,TCP报文丢包率和UDP报文丢包率对比.由于CHOKe对于恶意流的鉴别不区分流量种类,因此对于TCP和UDP流的丢包率在3种算法中都偏高(图4),CHOKe的这一特点在流较少的情况下确实能防止少数流量恶意流量独占大量带宽.根据文献[28],对CHOKe的建模分析表明,CHOKe能保证最大的单流占用带宽不超过26%.然而,当流的数量增加到万级,CHOKe的优势反而会限制TCP为代表的传输协议.因为TCP数据窗口增大后,相同吞吐量的TCP与恒速的其他应用在CHOKe下会获得更大的丢包概率.因此,CHOKe并不适合在骨干路由器上的配置.从图5可知,Page9CHOKe的实际吞吐率是3种算法中最低的.比较SF-RED与RED的丢包率,SF-RED上UDP的丢包率略大于RED,表明SF-RED算法对仿真中UDP的惩罚力度稍强于RED.从TCP的丢包率看,在高UDP的环境下(即UDP超过50%),SF-RED对于TCP的丢包率明显小于RED(见图4(a)).从吞吐量上看,SF-RED与RED相比较,在混合流量下,SF-RED的TCP吞吐率较优.UDP的吞吐量与RED基本相等.综上所述,实验中SF-RED在非TCP流量较高的情况下可以较好的保护TCP流量,并且通过窗口参数w的调节和利用Lotka-Volterra模型保证了混合流量的并存性和收敛性,在不同的情况下进行区别的丢包方式保护了弹性流的合理带宽,可用带宽的充分利用使得网络具有良好的吞吐率.6总结本文提出了一个基于RED的差异型丢包队列管理算法SF-RED.通过TCP的吞吐量模型引入一个窗口参数,对流量的拥塞控制进行动态调节;控制方式上采用了不同类型报文的差异性丢包方式.从理论上证明了SF-RED算法控制方式存在异种流量共存的稳定平衡点.算法的时间和空间复杂度较低.仿真实验表明较RED和CHOKe相比,SF-RED在高UDP流量下可以合理保护TCP流量,并对恶意的UDP流量产生抑制,并且同时能有效利用带宽,具有良好的吞吐率.
