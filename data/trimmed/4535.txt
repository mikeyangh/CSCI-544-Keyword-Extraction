Page1一种基于模式的实体解析算法刘辉平金澈清周傲英(华东师范大学软件学院数据科学与工程研究院上海200062)摘要实体解析是数据融合和数据清洗的关键步骤,旨在从大量的数据集中找出描述相同实体的记录.当前主要有两种基本的解决思路,一种是穷尽式的实体解析,通过两两比较数据集中的所有记录,然后再合并相似的记录,从而找到描述某一个实体的若干记录集合.然而,该方法的计算复杂度比较高(O(n2),其中n表示数据集合的规模),难以处理大型数据集合.另一种思路是基于分块的实体解析,它调用特定的分块函数(如哈希函数、滑动窗口技术等)将集合中较为相似的记录划分到同一个块中,再仅对属于同一块中的记录进行两两比较.这种方法显著降低了运行时间,但会损失部分精度,因为某些描述同一实体的记录可能没有被分到同一个块中.文中提出了一种基于模式的实体解析算法,通过将相似的记录合并成记录集合并尝试生成对应的记录模式,然后进行模式之间的两两比较来产生一个边界值,以确定对应的记录集合是否需要进行进一步的精确比较,从而判断是否属于同一个实体.与第一种方法相比,该方法可有效地过滤部分不可能相似的记录,从而避免了针对所有数据记录进行两两比较,显著地降低了时间复杂度;与第二种方法相比,该方法并不损失任何精度.基于真实和模拟数据集合的实验结果验证了新方法的执行效率和有效性.关键词数据融合;数据清洗;实体解析;编辑距离;字符串相似度1引言对不同来源的数据进行融合时会导致数据冗余现象,这不仅影响了数据的质量,也对数据处理造成了障碍[1-3].如何解决此一问题是数据清洗中的重要研究课题.实体解析(EntityResolution)通过对数据集进行分析[1,4-6],从而发现描述同一现实世界中的实体的若干数据记录(Record).实体解析一般包含两种基本操作:匹配操作(Match)和合并操作(Merge)[7-10].匹配操作用于判断两条记录是否对应于同一个实体(Entity).给定一个相似度度量和阈值δ,若记录间的相似度大于δ,则记录匹配,记为≈,否则为不匹配,记为.合并操作则用于合并匹配的记录,使它们成为一个记录集合共同对应同一实体.图1以人名为例展示了实体解析的一个完整过程.它先对记录进行两两匹配(编辑距离小于4认为匹配),然后利用传递规则(若a≈b,b≈c,则将a,b,c合并)将匹配的记录进行合并生成两个记录集合.实体解析完成后,为了最终消除冗余数据达到数据清洗的目的,可以进行实体生成,为每个记录集合生成一个唯一的实体.图1中最后生成两个实体E1、E2.由图1n)2次匹配操作(n为记录条数),其计算复杂度为(O(n2).显然对于大的数据集,这种复杂度是不能容忍的.为了减少匹配操作的次数,Benjelloun等人[7]提出了R-Swoosh实体解析算法框架.只要匹配操作和合并操作满足ICAR特性(幂等性、交换性、结合性、可被代表性),该框架就能有效地降低匹配操作的次数,从而提高实体解析的效率.ICAR特性中最重要的一点是可被代表性[11],即若一条记录与某一记录集合中的任意一条记录匹配,则该条记录与该记录集合匹配,需要对它们进行合并.为了方便,本文将没有进行合并的记录也看做记录集合,因此对于任意一个记录集合R,它的基数(包含的记录个数)|R|1.如图1,利用可被代表性,如果第一次匹配之后r1≈r3,合并形成{r1、r3};第二次匹配之后r2≈r3,则r2≈{r1、r3},合并形成{r1、r2、r3},这样避免了后面r2与r1间的匹配.这种特性被广泛采用[2,8,12-13],因为它可以避免记录与记录集合中的其他记录进行不必要的匹配.但是如果记录集合间没有匹配的记录对,还是需要对集合中所有的记录对进行一一比较.如图2所示,记录集合R1和记录集合R2需要进行完整的|R1|×|R2|=3×2=6次匹配,才能确定R1、R2不匹配.事实上,由于大多数的记录之间都是不匹配的,所以这种不匹配的比较操作次数会占整个实体解析过程中匹配操作数的大部分.为了解决这个问题,本文提出了一种基于模式(Pattern)的实体解析算法.它用特定的模式来描述一个记录集合(见3.3节),并采用模式相似度算法(见3.2节)计算模式相似度作为对应记录集合间相似度的边界值,根据相似度边界值与阈值间的比较以确定是否需要对记录集合间的记录进行精确的两两匹配.图3描述了一个例子,记录集合R1和记录集合R2,其对应的记录模式分别为P1、P2.由于P1、P2不匹配,所以其相应的记录集合R1、R2也不匹配.通过这种方法,可以过滤掉那些显著地不可能相似的记录集合对,以避免对记录集合中的所有记录进行两两匹配,起到了很好的剪枝作用,从而在提升了算法运行效率的同时又不牺牲结果精度.此外,还可利用所生成的模式生成实体(见4.2节).总的来说,本文的贡献如下:(1)提出了一套基于模式的实体解析和实体生成的算法框架.该框架在不影响准确度上提高了实Page3体解析的效率.(2)基于编辑距离设计开发了模式生成和模式匹配的算法,使得模式间的相似度能够成为记录集合相似度的一个边界值,从而达到剪枝的目的.(3)在真实数据集和模拟数据集上进行了充分的实验,实验结果表明本文提出的基于模式的算法框架在实体解析和实体生成阶段跟现有的方法相比具有良好的效果.本文第2节介绍相关工作;第3节详述模式的相关概念和模式生成以及模式相似度计算算法;第4节介绍基于模式的实体解析框架和基于模式的实体生成算法;第5节通过实验来验证本文所提算法的有效性和高效性;第6节总结全文.2相关工作2.1实体解析为了发现数据集合中表示现实世界中同一实体的数据记录,实体解析问题被大量研究.从准确度和效率两方面考虑,实体解析可以大致分为两类:穷尽式实体解析(ExhaustiveER)和基于分块的实体解析(Blocking-basedER)[12].穷尽式的实体解析[7-8,13-14]需要遍历整个数据集来达到高准确度.所以穷尽式的实体解析结果一般也被当做标准答案来使用[12,15].为了减少穷尽式实体解析中的匹配次数,文献[8,13]通过选取记录集合中的一条记录作为记录集合的代表记录.通过代表记录间的匹配来决定其对应的记录集合间是否匹配.但是由于代表记录选取的随机性和不稳定性,会对实体解析的结果准确性造成影响.文献[7]提出R-Swoosh框架利用ICAR属性可以获得高精确度,但是对于不匹配的记录,还是需要进行完全的两两比较.本文通过基于模式的方法很好地解决了这个问题.另一方面,为了提高实体解析的效率,各种基于分块的实体解析算法被提出[2,9-10,16-17].文献[9]利用哈希函数将记录映射到不同的块中,然后对相同块中的记录进行匹配操作.文献[2,10]先将记录按某个属性进行排序,然后对排序的记录利用滑动窗口进行扫描,只有在同一窗口中的记录才进行两两匹配.文献[16,18]将记录属性变成若干个gram,然后将gram作为分块的依据.文献[17]先通过简单高效的距离度量将记录粗略地分到各个子集中,然后在每个子集里用精确的距离度量对记录进行两两匹配.上述分块算法都大大提高了实体解析的效率,但是由于匹配的记录可能没有被分到同一个块中,所以都在某种程度上降低了实体解析的准确度.本文提出的算法在提高实体解析效率的同时能够保证实体解析的准确度.2.2相似度计算实体解析的匹配操作需要利用相似度度量计算记录间的相似度从而判断它们是否属于同一个实体.常见的相似度(或者距离)度量有编辑距离、Jaccard相似度、余弦相似度、欧式距离等.其中编辑距离[19]是计算两条给定的字符串之间距离的经典度量,广泛应用于实体解析的记录匹配[2,4,10,20].其采用删除、插入和替换三种基本操作来把一条字符串转换为另一条字符串,用最少操作次数来表示该两条字符串之间的距离.距离越小表示字符串越相似.本文用d(s1,s2)来表示字符串s1和s2之间的编辑距离,显然d(s1,s2)max(|s1|,|s2|).编辑距离一般采用动态规划(DynamicProgramming)来计算,其递推公式如下:d[i,j]=min其中这里s[i]表示字符串s的第i个字符.而且d[i,j]=i+j当i×j=0.基于这种距离通过对它进行归一化可以得到字符串间的编辑距离相似度dsim(s1,s2).其计算方式如下:显然dsim(s1,s2)∈[0,1].本文采用编辑距离计算记录相似度且基于编辑距离设计模式的生成和相似度计算算法.3记录模式3.1记录模式的相关概念注意到每一个记录集合中的记录之间都是有一定相似性的,因为它们都是通过匹配之后合并到一起成为一个记录集合,对应于现实世界中的同一个实体.基于这种特性,可以发现和抽取记录集合中记录的共同特征,对它们相同的部分进行统一,不同的部分进行保留,从而形成一个特定的模式.那么对于Page4一个记录集合的处理就可以直接对该记录集合所对应的模式进行处理.下面对模式进行形式化定义.定义1.令Σ表示字母表,ε表示空字符.一个模式:P=P[1]P[2]…P[n].其中对于任意的i=1,…,n,元素P[i]={ci,1,…,ci,nini,有ci,j∈Σ∪{ε}).其中P[i]的长度|P[i]|=ni,模式P的长度|P|=n.由以上定义可知任一模式能够构成的字符串的i=1个数为∏的实例.例如模式P:h{e,a}llowor{l,ε}d,其实例集为{halloworld,helloword,halloword,helloworld}.定义2.给定记录集合R和模式P,P的实例集为Q.若ri∈R,都有ri∈Q.则称P为R的一个模式.根据上面的定义容易看出对于只包含一条记录的记录集合,其模式就是该条记录本身.但是对于包含多条记录的记录集合,情况就要复杂得多.例如记录集合R:{halloword,helloworld}的对应模式可以是P:h{e,a}llowor{l,ε}d.这时引入了两个不相关实例:helloword和halloworld.本文的3.3节将给出基于编辑距离的模式生成算法.现在可以用模式代替记录解决实体解析问题.同样我们需要利用模式相似度对模式进行匹配操作,若其相似度超过阈值,则模式匹配,需要对模式所对应的记录集合进行合并操作并更新对应新记录集合的模式.为了利用模式进行剪枝,我们定义模式间的相似度是其对应实例间相似度的最大值.本文的3.2节将给出基于编辑距离的模式相似度算法.实体解析中,对于任意两个记录集合,若它们不存在一对匹配记录,则显然该两个记录集合不可能匹配.同样对于模式而言,若模式的实例集中不存在一对匹配的实例,则模式之间也不可能匹配.基于此我们得到以下实体解析的剪枝规则(pruningrule):剪枝规则.对于两个记录集合R1和R2,它们对应的模式分别为P1和P2.则(1)若P1≈P2,则可能R1≈R2.(2)若P1P2,则R1R2.设P1、P2对应的实例集分别为Q1和Q2.对于(1),因为P1≈P2,故Q1、Q2间存在匹配的实例.由于R1Q1,R2Q2,所以若匹配的实例(记录)对存在于R1、R2,则可能有R1≈R2,否则R1R2.对于(2),由于P1P2,故Q1、Q2中不存在匹配的实例,由定义2知R1、R2中也不存在匹配的记录,故有R1R2.由以上剪枝规则可知,模式间的相似度可以看成记录集合间相似度的一个上界.对于剪枝规则中的(2)通过对模式进行一次匹配,如果P1P2,即实例间相似度的最大值小于阈值δ,则可判断记录集合的匹配情况为R1R2.因为R1、R2中不可能存在相似度高于阈值δ的记录对.此时不需要再对R1、R2中的记录进行两两匹配.可以大大节省实体解析的运行时间,极大提高实体解析的效率.而对于(1),通过P1≈P2,不能直接得到R1≈R2.因此为了不对结果的准确性造成影响,需要做进一步的验证.这种情况下浪费了一次模式匹配,但是模式匹配的复杂度相当于一次记录间的匹配,因此对实体解析的影响并不是很大.而且通常情况下,大部分记录都是不匹配的,因此(2)出现的情况远远高于(1)出现的情况,所以(2)对实体解析效率的提升远远大于(1)的消耗.正是由于(2)对实体解析中匹配操作的大量剪枝,使得整体上基于模式的实体解析在不影响结果准确性的同时能对实体解析的效率进行显著地提升.第5节的实验将进行非常好的说明和验证.3.2模式相似度现在可以将记录间的匹配操作转换成其对应的模式之间的匹配操作.通过模式间的匹配进而确定对应记录集合是否匹配.本文设计一种基于编辑距离的相似度算法来对模式进行相似度计算,使得模式间的相似度是其对应实例间相似度的最大值,从而利用剪枝规则.由于模式中的元素可能有多个字符而且还有空字符ε的存在,所以不能直接将字符串的编辑距离用于模式之间的距离.为了计算模式之间的距离,需要根据模式的特点对编辑距离进行改编.为了解决多字符和空字符的问题,本文采用如下设计原则:(1)对于多字符.如果两个模式元素中含有相同的字符(包括空字符),则该两个模式元素匹配.(2)对于空字符.如果不匹配,则包含空字符的模式元素这时取空字符,此时其不占字符长度,对编辑距离没有影响.通过这种处理方式可以找出两个模式中编辑距离最小的实例对.用这个最小距离作为模式的编辑距离.模式编辑距离犇(P1,P2)的递推公式如下:犇[i,j]=min其中Page5C(P1[i],P2[j])=这里P[i]表示模式P的第i个元素.且初始条件为犇[i,j]=min上述递推公式中我们采用了两个惩罚函数:A函数和C函数,来解决模式中的多字符和空字符问题.其中C函数对应设计原则(1),只要模式元素间含有相同字符,则认为匹配.这样若记录对应的字符串间编辑距离某一位置字符匹配,则对应的模式元素间该位置必定也会匹配.A函数对应设计原则(2),若模式元素中含空字符,则可以直接将其忽略,不影响整个编辑距离操作,保证编辑距离维持最小.最后两模式的编辑距离即为犇[|P1|,|P2|].特别地,对于两个只包含一条记录的记录集合,其模式的编辑距离等于记录的编辑距离.下面证明模式的编辑距离不大于对应记录集合的记录间的最小编辑距离.即证:定理1.给定两个记录集合R1和R2,它们对应的模式分别为P1和P2.则证明.对于初始情况i·j=0时,根据模式的定义和模式编辑距离的初始化规则,有ri∈R1,rj∈R2,犇[i,j]d[i,j].对于i·j≠0,由于A(P[i])1且C(P1[i],P2[j])c(s1[i],s2[j]).通过归纳推导,可以得到对于任意ri∈R1,rj∈R2,有D(P1,P2)d(ri,rj).对模式编辑距离归一化可以得到模式的编辑距离相似度,简称模式相似度Dsim(P1,P2):Dsim(P1,P2)=1-与字符串编辑距离相似度类似,模式相似度Dsim(P1,P2)∈[0,1].当两模式的实例集中存在相同的实例,则其模式编辑距离为0,此时模式相似度最大为1.反之当两模式的实例集完全不同时,其模式相似度最小可以为0.通过模式相似度,利用定理1,可以得到下面的结论.引理1.模式编辑距离相似度满足剪枝规则.证明.任设两个记录集合R1和R2,它们对应的模式分别为P1和P2.再设给定相似度阈值为δ∈[0,1],R1、R2中相似度最高的记录对为ri、rj.则有由定理1有再由模式的定义有这里的|ri|,|rj|分别表示ri,rj对应字符串的长度.所以得到因此故有(1)若P1≈P2,即Dsim(P1,P2)δ.此时dsim(ri,rj)与δ关系不确定,故可能有R1≈R2或R1R2.(2)若P1P2,即Dsim(P1,P2)<δ,有δ>Dsim(P1,P2)dsim(ri,rj).故rirj,所以R1R2.因此模式编辑距离相似度满足剪枝规则.证毕.由上述证明可知模式间的相似度是记录集合相似度的一个上界.事实上,可以继续对这个上界进行压缩,使得其变得更加紧凑,这样其剪枝效果也会变得更好.由模式的定义很容易有其中R为记录集合,P为R对应的模式,|r|为R中任一记录的字符串长度.因此根据引理1的证明可以得到其中r∈R1,r∈R2.不妨设则Dsim(P1,P2)Dsim(P1,P2)dsim(ri,rj).此时可以将记录集合相似度的上界从Dsim(P1,P2)缩小到Dsim(P1,P2).第5节的实验采用的是Dsim(P1,P2).3.3模式生成由上文可知,对于只包含一条记录的记录集合,其模式为其记录本身.而对于包含多条记录的记录集合,由于其是由多个记录集合合并而成,直接对记录集合的记录字符取并集生成模式并不是一种非常好的选择.如记录集合R:{halloword,helloworld},Page6直接取记录字符的并集生成的模式P:h{e,a}llowor{l,d}{d,ε},其可能的实例数为2×2×2=8.引入了6个不相关实例.显然更好的模式应该为P:h{e,a}llowor{l,ε}d,其可能的实例数为2×2=4,引入了2个不相关实例.相比于P,P在覆盖记录集合R的同时引入的不相关实例更少.基于此,本文并不直接对记录集合生成模式,而是利用其子记录集合进行模式的编辑距离匹配后生成的距离矩阵进行回溯来得到该记录集合的模式.这样通过距离矩阵考虑记录字符间的对应关系可以减少生成模式的可能实例数,尽可能少地引入不相关的实例.例如R1和R2对应的模式分别为P1和P2.若R1≈R2,此时需要对R1、R2进行合并操作.设合并后的新记录集合为R,则R的模式P为P1、P2的共同模式,也即模式的模式.通过模式的编辑距离生成的距离矩阵犇,从犇[|P1|,|P2|]出发根据最短距离进行回溯到犇[0,0],即可得到模式的模式.其具体的生成规则如下:P[k]=P1[i]∪ε,犇[i,j]=犇[i,j-1]+A(P2[j])烄P2[j]∪ε,犇[i,j]=犇[i-1,j]+A(P1[i])烅P1[i]∪P2[j],犇[i,j]=犇[i-1,j-1]+C(P1[i],P2[j烆特别地其中k为回溯中的某个位置,直到i=0,j=0时回溯完毕.这时P1、P2的模式P=…P[k]…P[0](k按回溯顺序倒序排列).特殊情况下,当生成规则中的3个条件同时满足时,C函数的优先级高于A函数.这样有助于相同字符的合并,从而减少引入不相关的实例.下面我们证明以上生成规则得到的模式P是新记录集合R的模式.证明.由生成规则可知,共有两种情况:(1)P1[i]和P2[j]对齐(匹配),则同时保留P1[i]和P2[j]作为该位置的模式元素.(2)P1[i]和P2[j]不对齐(不匹配),此时我们用空字符与P1[i]或P2[j]匹配,这样既没有引入脏字符又可以保留P1[i]或P2[j]的必要字符.故而新模式P能够有效保留P1、P2的必要单元.设P、P1、P2的实例集分别为Q、Q1、Q2,则(Q1∪Q2)Q.因为P1、P2分别为R1和R2的模式,所以有R1Q1,R2Q2,(R1∪R2)Q.又R=R1∪R2,故有RQ.所以P为R的模式.下面我们用一个例子来说明模式相似度的计算和模式生成的过程.设记录集合R1:{halloword},R2:{helloworld},显然其对应的模式分别为P1:halloword,P2:helloworld.根据模式相似度的计算算法,P1、P2模式编辑距离的距离矩阵如表1所示(为了方便,表中省略了单词间的空格).其中矩阵中的每个值犇[i,j]表示P1的前i个元素与P2的前j个元素间的编辑距离.由于此时的模式为记录本身,所以模式间的编辑距离等于其对应记录间的编辑距离.故P1、P2模式编辑距离为犇[9,10]=2.其模式相似度为1-2/10=0.8.假设阈值δ=0.7,则R1、R2匹配,此时需要将R1、R2合并,形成新的记录集合R:{halloword,helloworld}.与此同时,需要产生R对应的模式P.如表1,根据模式的生成规则,在模式距离矩阵犇的基础上从犇[9,10]开始回溯.由于犇[9,10]=犇[9,9]+A(P1[9])=犇[8,9]+C(P1[9],P2[10])=2,根据C函数优先原则,此时的P[k]={d}∪{d}={d}.因此下一位置从犇[8,9]开始回溯直到犇[0,0]结束,最后形成的模式P为h{e,a}llowor{l,ε}d.012345678910h10123456789a21123456789l32212345678l43321234567o54432123456w65543212345o76654321234r87765432123d988765432123.4模式的时空复杂度对于模式的相似度计算,其中计算A函数和C函数时由于需要对模式元素中的每个字符进行匹配,所以其计算复杂度为O(∑而其空间复杂度与字符串的编辑距离类似为O(|P1||P2|).而对于模式的生成,其可以直接利用模式相似度计算所生成的距离矩阵进行线性回溯,所以其时空复杂度均为O(|P|),其中P为生成的模式.Page74基于模式的实体解析框架通过第3节的介绍,本文完整地给出了记录所对应模式的生成和模式相似度的计算算法.并且证明了这两种算法的有效性.本节我们介绍基于上述模式算法的实体解析框架,该框架能够很好地利用模式的剪枝规则通过迭代式的计算在不影响准确率的情况下使得运行时间大大降低.4.1基本框架一个有效的实体解析框架能够利用匹配和合并两种基本操作产生出实体解析结果集,使得该结果集满足:(1)对源数据集的一个完整划分;(2)对于任意记录只能属于唯一记录集合;(3)结果集中不存在能够匹配的记录集合,使得每一个记录集合都对应一个不同的实体.基于模式我们设计了一个迭代式的实体解析算法IterER.其伪代码见算法1.算法1.IterER:产生实体解析的输出结果集.输入:记录集合I,阈值δ输出:满足条件的结果集I1.FOR记录rINIDO2.r.pattern←r;3.r.round←0;4.cRound←0;5.WHILETRUEDO6.T←;7.FOR记录rINIDO8.从I中移除r;9.matchingRecords←;10.FOR记录rINIDO11.IFr.roundcRoundORr.roundcRound12.计算r.pattern和r.pattern相似度e;13.IFeδANDr≈rTHEN14.产生r.pattern和r.pattern的模式p;15.r←合并r,r;16.r.pattern←p;17.r.round←cRound+1;18.添加r到matchingRecords;19.FOR记录rINmatchingRecordsDO20.从I中移除r;21.添加r到T;22.cRound←cRound+1;23.IFT的集合大小不变THEN24.BREAK;25.ELSEI←T;26.I←T;27.RETURNI;该算法的输入为需要进行实体解析的记录集合以及相似度的阈值δ,输出为满足上述条件的实体解析结果集.对于给定的记录集I,首先对其中的每个记录进行初始化,将每个记录看成包含一条记录的记录集合,其初始模式为其本身.为了叙述方便,下文将记录集合也看做记录.由于本文的算法是迭代式的,为了避免每一轮迭代中相同的记录对重复比较,我们为每一个记录添加了round属性,其初始值为0(1~3行).对于每一轮迭代,我们首先取I中的任一记录r与I中其他记录进行比较.为了避免重复比较,只有记录对中有一个记录的round值不小于当前的迭代轮数(cRound),该对记录才有可能进行匹配操作.因为round值小于当前的迭代轮数的记录对会在前几轮迭代中进行比较.对于一对记录,先计算它们的模式相似度,然后利用剪枝规则进行剪枝.若模式相似度超过阈值δ,才对它们进行精确的匹配操作,以判断该记录对是否匹配.若该记录对匹配,需要对它们进行合并操作生成一个新记录,然后通过模式生成算法更新新记录的模式.同时新纪录的round属性也要更新为当前迭代轮数加1,这样可以保证新纪录在下一轮迭代中能够和所有其他记录进行匹配.另外跟r相匹配的记录需要把它们保存在匹配集合中,当r跟I中所有其他的记录匹配完毕时,需要把匹配集合中的所有记录从I中删除.这样每一次匹配合并后I中的记录就会减少,保证该算法最后可以收敛终止,同时也可以保证每一个记录只属于一个集合,不会再跟其他的记录进行合并成新的记录.当r与I中所有其他记录进行匹配操作后,将r加入临时记录集和T.当I中的所有记录完成与r相同的操作之后,一轮迭代完成,而该轮迭代的结果也被保存在了临时记录集合T中(7~21行).一轮迭代后,首先要将当前迭代轮数自增1.如果临时记录集合的大小不变,则记录集合中已经不存在相似的记录对,此时迭代终止(22~25行).最后返回最新记录结果集I(26~27行).图4展示了该算法的运行过程.括号中的数字表示每个记录的round值.为了方便,这里规定如果两记录的编辑距离小于4则认为匹配.如图共有5条记录,第一轮迭代中r1、r3合并,r4、r5合并形成新的记录集合且Page8其round值加1,此时共有3个记录集合.第二轮迭代中r2与r1、r3合并形成新的记录集合且其round值相应加1,此时共有2个记录集合.最后一轮迭代图4IterER算法的运行过程假设输入数据集中不存在匹配的记录,则每两个记录之间都需要进行比较且不存在记录合并,此时本文的实体匹配算法与两两比较方法的复杂度一致,为O(n2).事实上,实际运行过程中进行的比较次数远远小于理论比较次数,第5节的实验可以很好地体现.4.2实体生成采用以上框架可以得到若干个记录集合,每个记录集合对应现实世界中的唯一实体.但是实际情况中往往需要生成最终的真实实体,使得其可以唯一表示该集合.这样一些冗余的记录就可以得到消除使得整个数据集得到清洗.一般生成实体的方法是从一个集合中找到一个代表记录[8,13],使得该记录可以代表整个集合唯一对应现实世界中的一个真实实体.但是这种代表记录的选取不但需要遍历整个集合,而且选取的记录随选取方法和数据集特征的变化而变化,稳定性较差.特别地,如果真实实体不存在于集合之中,那么这种方法就会变得无效.利用本文的记录模式,可以从另一个思路解决这个问题.通过上述的实体解析算法,可以得到若干记录集合和其所对应的模式.对于一个集合所对应的模式,可以在模式生成过程中记录每一个模式元素中字符的出现频数.利用这种带频数的记录模式,可以在每个模式元素中选取出现频数最大的字符作为该模式元素的值,最后可以生成一个出现概率最高的字符串作为该集合的代表,使其对应于一个真实实体.例如图4中记录集合{r1,r2,r3}对应的带频数的模式为{J:3}{o:2,.:1}{h:2,ε:1}{n:2,ε:1}{:3}{D:3}{o:2,ε:1}{e:2,ε:1},故其最可能的字符串为JohnDoe,与真实实体一致.显然利用记录模式生成实体可以直接扫描一遍模式快速得到最可能的记录,而不需要遍历集合中的所有记录从而提中,两记录集合的模式相似度小于阈值δ,直接判定两记录集合不匹配,此时结果集依然只有2个记录集合,迭代结束,输出最终结果.高实体生成的效率.其次模式根据概率生成实体具有一定的容错能力,可以过滤掉一些噪声记录.例如一些由于拼写、排版、习惯等原因造成的错误字符,其出现的频数必然要少于正常的字符,所以取频数最大的字符可以过滤那些错误字符.5实验结果与分析5.1实验设置本文实验采用真实数据和模拟数据来对算法性能进行评测.其中真实数据采用CiteSeer论文数据库,其包含近1400万条文献引用,470多万个真实实体.其文献属性包括作者、标题、日期、页码、卷号、出版社等.为了方便,实验采用标题属性作为一条文献记录.模拟数据采用DBGenerator①数据生成器在实体和记录比为120且满足均匀分布情况下所生成的虚拟个人信息数据,其生成的数据属性包括姓、名、中间名以及住址.本实验采用所有属性的串连作为一个记录.本文实验代码采用C#编写,运行在配置3.2GHzIntelCorei5-3470处理器,8GB内存的64位Windows8操作系统中.采用的匹配规则为:若记录集合间有一对记录相似则匹配.合并操作为取记录的并集.由于原始的两两比较方法极为耗时,为了进行性能对比,本文只与R-Swoosh做比较.R-Swoosh也是一种迭代的实体解析算法,每当有新记录生成时,都要将新记录与已经解析好的记录重新进行匹配,直到没有新记录产生为止.本文主要对实体解析的两个阶段进行评测:(1)实体解析的结果;(2)真实实体的生成.为了验证结果的有效性,本文采用准确率(Precision)和召①http://www.cs.utexas.edu/users/ml/riddle/data/dbgen.Page9回率(Recall),并用F1-Score作为评测标准[15].其计算公式如下:效率方面,通过算法执行的记录比较次数和运行时间来比较其性能.5.2实体解析结果利用真实数据集CiteSeer和模拟数据集DBGen,采用上述有效性评测标准,我们得到本文提出的算法IterER与R-Swoosh的性能比较.如图5、图6,分别表示记录条数为5000条时,两算法在CiteSeer和DBGen数据集上有效性随阈值的变化情况.其中IterER为本文提出的基于模式的实体解析算法.可以看到两算法的有效性(准确率、召回率、F1-Score)曲线完全重合,表现出一致的有效性.这也说明本文的算法并不影响结果的准确性.从实验图中可以看出随着阈值越来越低,不匹配的记录越来越容易被合并,使得召回率不断升高.同时负例的个数不断增加,使得准确率不断降低.可以看到CiteSeer和DBGen的阈值分别取0.5和0.6时F1-Score值最高;而当图5CiteSeer记录为5000条时,有效性随阈值的变化情况图6DBGen记录为5000条时,有效性随阈值的变化情况CiteSeer和DBGen的阈值分别取0.3和0.4时,其召回率几乎为1,而准确率变得非常低,使得整体上的F1-Score值最低.容易推测当阈值降到最低接近0时,F1-Score值会变得最低,而此时的实体解析效果也会变得最差.所以选定一个合适的阈值是影响算法有效性的关键.不同的数据集中,两算法的召回率、准确率和F1-Score最高都能达到0.95以上,进一步说明两算法在处理实体解析问题时都是非常有效的.同样的数据集下,两算法随阈值变化而变化的运行时间如图7、图8.可以看到在CiteSeer数据集中R-Swoosh的运行时间随着阈值的减小而降低.这是因为随着阈值的减小,记录的合并操作会增加,使得形成的记录集合数目减少,导致记录的比较次数降低,所以R-Swoosh在CiteSeer数据集下的运行时间会随阈值减小而降低.而对于本文提出的IterER算法,随着阈值的减少,运行时间会出现一个波动.这是由于随着阈值的降低,每轮迭代合并的记录增多,使得整体的记录集合数变少.而记录集合数目减少意味着每个集合中的记录个数的增加,所以其对应的模式会相应地变繁琐,导致模式间的相似度计算变得复杂.而且这时模式会引入较多的不相关实例,使得模式间相似度变高,形成的边界值变松,过滤效果变差,记录的比较次数增多(见图9、图7CiteSeer记录为5000条时,运行时间随阈值的变化情况图8DBGen记录为5000条时,运行时间随阈值的变化情况Page10图10).从而导致IterER算法的运行时间会随着阈值的减小有一个回升的过程.从图8可以看出,对于DBGen数据集,R-Swoosh的运行时间同样也会产生回升.这是由于DBGen中的实体个数(250个不同实体)比CiteSeer中的实体个数(108个不同实体)要多很多,而且DBGen的数据满足均匀分布,使得记录的比较次数变多(见图9、图10),所以R-Swoosh的运行时间也会有一个回升.但是不论阈值如何设置,从实验图中可以看到本文算法的运行时间始终比R-Swoosh要少得多,其时间性能提升可以达到2~10倍.这种巨大的性能提升源于本文提出的基于模式的实体解析算法可以过滤大量的不可能相似的记录从而节省大量的计算时间开销.图9CiteSeer记录为5000条时,比较次数随阈值的变化情况图10DBGen记录为5000条时,比较次数随阈值的变化情况为了解释IterER与R-Swoosh在运行时间上的巨大差异,我们在相同的数据集下统计了两算法在不同的阈值条件下记录比较次数的变化,如图9、图10.其中IterER-Pattern表示IterER算法中模式的比较次数,IterER-Record表示记录的比较次数.可以看出本文算法的比较次数远远少于R-Swoosh的比较次数,而记录比较次数的变化跟运行时间的变化成正相关的关系,因此两算法的运行时间差异是由于算法进行的记录比较次数的差异造成的.容易发现图9、图10的比较次数走势与图7、图8的运行时间走势是一致的.此外图9、图10显示在阈值较高的情况下,两算法的比较次数差异巨大.这是由于高阈值下只有非常相似的记录才会合并,此时其生成的模式比较干净简洁,形成的边界值较紧,所以可以过滤掉绝大部分的不必要的记录比较.更加说明基于模式过滤的有效性.在相同的数据集下,通过增加数据集的记录条数,扩大数据量,选取每个数据量下最优的阈值(这里选取使F1-Score值最高的阈值作为最优阈值),我们得到在不同的数据量下,两算法的有效性和运行时间的差异比较,如图11、图12.Page11从图11中可以看出在不同的数据集中,随着数据集的大小不断变化,IterER算法和R-Swoosh算法的有效性曲线(F1-Score)始终重合且保持在较高的水平.进一步说明两算法框架在解决ER问题上的重要意义.此外图12反映无论数据集的大小如何变化,IterER算法的运行时间始终远远小于R-Swoosh算法的运行时间,而且IterER的运行时间随数据集大小变化的增长速度远远小于R-Swoosh的增长速度.这是因为随着数据量的增长,记录对之间的比较出现爆发式增长,使得R-Swoosh的运行时间呈现类似指数级的增长,而本文基于模式的IterER算法可以避免那些明显不相似的记录对间的比较,减少大量的比较次数,抑制记录对比较随数据量增加而形成的爆发式增长,从而节省大量的时间开销.同时也说明IterER更加适合处理大数据量下的实体解析.通过上述实验表明,本文基于模式的ER算法框架可以在确保实体解析结果准确性的同时能够有效地提升实体解析的效率.5.3实体生成大部分实体解析研究工作都比较注重实体解析结果集的生成,而对最终的实体生成和表示关注较少.本节选取一个代表性的方法进行对比,即最短距离法.该方法从记录集合中选取一个记录做为该记录集合所对应的实体,其中该记录需满足其与记录集合中其他记录的编辑距离之和最短.利用上节中最优阈值所产生的结果集合进行实体生成,每个集合产生一个记录,对应一个现实世界中的真实实体.由于DBGen是模拟数据,真实实体无从可知,所以本节实验采用CiteSeer数据集.由于CiteSeer是论文数据库,我们通过谷歌搜索引擎对CiteSeer数据中真实对应的文献进行确认作为正确结果.通过与模式生成的记录和最短距离方法生成的记录进行比较,得到如图13的结果.图13显示了两种方法在不同数据集大小下的实体生成情况.Pattern表示本文中的用模式生成实体的方法,MinDis表示最短距离生成实体的方法.由于实体解析结果的误差,所以生成实体的个数(集合数)与真实实体的个数存在偏差,这也直接影响实体的生成的准确性,因为错误的集合必将导致错误的实体生成.由图中可以看出随着数据集大小的增大,实体的个数越来越多,准确性也越来越差.但是基于模式的实体生成算法的准确率要好于一般基于最小距离的准确性.由于噪声数据的干扰和数据本身的质量问题,使得一般的算法在容错方面的性能比基于模式的生成算法要弱,导致准确性要低.效率方面,模式经过一次遍历可以生成实体,而一般方法则需要遍历整个记录集合,使得基于模式的实体生成在时间复杂度上的优势更明显.6总结与展望实体解析是数据融合和数据清洗过程中的重要步骤,实体解析的结果影响着数据质量.特别是不同的数据源进行数据融合时需要进行实体解析找出对应同一实体的那些记录.然而为了保证实体解析的精确度,现存的算法需要进行大量的比较计算,消耗大量的时间开销.特别是在大数据环境下,这些计算是不能容忍的.为了解决这一问题,本文提出了一整套从记录到实体的基于模式的实体解析的算法框架,旨在在现有方法的基础上提高实体解析的效率,适应大数据量的要求.本文提出的实体解析算法框架利用记录模式可以有效地过滤掉一些不可能相似的记录,避免不必要的比较,从而大大地提高了实体解析的效率.与现有的框架相比该框架在显著提升运行效率的基础上能够保证其准确性.另外基于模式的实体生成由于具有良好的容错性,性能表现相比于一般算法也有优势.虽然实体解析在数据融合与数据清洗中扮演着重要的角色,但是当前关于实体解析特别是实体生成的研究工作还是相对比较缺乏.本文基于模式提出了一个比较初步的实体生成算法,但是其准确性依然有待提高.为了完整解决这一难题,一些新技术和新成果,如机器学习、人工智能、自然语言处理等需要被考虑和应用,使得最终产生的实体能够更加贴近真实实体.Page12
