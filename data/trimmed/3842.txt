Page1一个新的基于秘密共享的条件代理重加密方案蓝才会王彩芬(西北师范大学数学与信息科学学院兰州730070)摘要研究的动机来源于Weng等人的工作,他们的方案允许代理人把满足条件的授权人密文转换成受理人的密文,可应用于需要灵活代理的环境中.例如,授权人希望同事(受理人)在她休假期间帮忙处理紧急邮件.然而,他们的方案不能很好支持多个条件的“与”和“或”.文中,为了让代理人不能产生其它关键字的重加密钥,利用秘密共享机制,并根据集合(由关键字和随机数构成)产生两部分代理重加密钥.在重加密时,密文中与关键字有关的模块和一部分称为关键字的代理重加密钥作为一个子算法的输入;另一部分称为随机数代理重加密钥作为另一个子算法的输入.在此基础上,作者利用双线性对构造了一个新的条件代理重加密方案,方案能很好支持多个条件的情况,并在随机预言模型下证明了它的安全性是基于变性的判断双线性Diffie-Hellman问题.关键词条件代理重加密;秘密共享;双线性对;随机预言模型;选择密文安全1引言随着计算机网络带宽技术和计算机多媒体编码技术的进步,在因特网上进行数字内容交易变得十分便捷,并以惊人的速度发展.其中出现一些急待解决的问题,如加密电子邮件转发、分布式文件系统等应用需要把一个公钥下的密文转换成另一个公钥下的密文.代理重加密[1]是一个很好的解决办法.在代理重加密系统中,允许一个拥有一些额外信息的半可信代理者把授权者公钥下的密文变换成受理人公钥下的密文,但是代理者以及没有代理人合作的受理人都得不到任何明文信息.2009年Weng等人[2-3]提出了条件代理重加密方案.在他们的方案中,只有密文满足授权人设定的条件(关键字),代理人才能将授权人的密文转换成受理人可解密的密文,即授权人可以通过关键字限制受理人的权限.他们的方案可以应用于需要灵活代理的环境中,如两个云用户交换某一类型(用关键字标示)私有(加密)数据.云计算①中,程序和数据不再运行和存放在本地,而是托管到一个可通过Internet访问的、由个人计算机和服务器构成的集合.用传统的公平交换协议[4]来交易,需要把相关数据下载到本地解密后再交易,过程包括一次加密、两次解密以及两次数据传递.而用条件代理重加密只需要一次重加密和一次数据传递,具体如下:(1)交易双方(Alice,Bob)根据关键字产生各自的条件代理重加密钥,并把重加密钥发送给半可信云服务商.(2)云服务商随机选择消息,在Alice设定的关键字和公钥下加密,并用Alice的重加密钥执行重加密.最后返回Alice的凭证(包括重加密后的密文和关于消息、关键字、重加密后密文的签名).Bob的凭证用同样的方法产生.(3)双方把各自凭证给对方.并通过解密密文、验证签名来判断对方给云服务商的代理重加密密钥是否正确.(4)验证完后给云服务商是否正确的消息.(5)云服务商收到交易双方都返回“正确”的信息后,分别用一方的条件重加密钥重加密同一方满足条件的密文,并把结果返回给另一方.通过上面的步骤后,双方可以得到各自想要的数据.但是Weng等人[2-3]提出的方案不能应用于多条件的环境.可以肯定的是,在实际生活中,交换的数据也许是多个关键字按某种逻辑关系的组合,例如其中一个交易方想从另一个交易方那里得到网络通信中与网络层有关的安全协议的文档信息.为了使方案能有效支持多个条件的情况,本文首次采用秘密共享机制[5]构造条件代理重加密方案,方案的安全性是基于变性的判断双线性Diffie-Hellman问题,并且能够很好支持多个条件的“与”和“或”.1.1相关研究Blaze等人[1]首次提出代理重密码的概念,并构造了基于ElGamal的双向代理重加密方案.但是,直到2006年Ateniese等人[6]才对代理重加密进行了严格的定义,同时提出了基于对的选择明文安全的单向代理重加密方案,并用代理重加密设计了一个分布式存储系统.2007年ACMCCS会议上,Canetti和Hohenberger[7]提出了第一个能在标准模型下证明安全的双向代理重加密方案.后来,Libert和Vergnaud[8]在PKC会议上提出了一个基于对的单向的代理重加密方案,并在标准模型下证明了选择密文安全,可认为是Canetti-Hohenberger定义的自然扩展.2009年AsiaCCS09会议上,Weng等人[2]提出了条件代理重加密,在方案中授权人可以控制代理人的代理权限.同年,Weng等人[3]在ISO09会议上提出了一个更高效的条件代理重加密方案.他们的两个方案都是基于对运算的,且都是在随机预言模型下证明安全的,但不能很好支持多个条件.2010年,Shao等人在文献[9]中提出具有关键字搜索的代理重加密方案,方案中受理人的网关能够检测转换后的密文是否包含特定的关键字.1.2本文方案本文采用秘密共享机制来设计条件代理重加密方案,此方案能很好支持多个条件的“与”和“或”运算,并在随机预言模型下证明了它的安全性是基于变性的判断双线性Diffie-Hellman问题.为了满足多条件的代理重加密要求,需要对密钥共享技术进行适当改变.特别是在生成密钥片时不公开拉格朗日系数,也不提供对应多项式的值.而是用关键字W=(w1,w2,…,wt)和n-t+1个随机数ki(i=1,2,…,n-t+1)生成两部分代理重密①可参见WindowsAzurePlatform[EB/OL].2009.07.Page3钥片,其中一部分为关键字的代理重加密密钥而另一部分为随机数的代理重加密密钥rkkj=g这一部分可以合并.这里f为一n阶多项式,而lwlkj为拉格朗日系数.2预备知识2.1双线性对设G1和G2是两个p阶循环群,p为一大素数,两个群之间的双线性对e:G1×G1→G2是满足以下条件的映射:(1)双线性性.g1,g2∈G1,a,b∈Zp,满足1,gb2)=e(g1,g2)ab.(2)非退化性.g1,g2∈G1满足e(g1,g2)≠1G2.(3)可计算性.对g1,g2∈G1,存在高效的算法e(ga能计算出e(g1,g2).2.2复杂性假设设G1和G2是两个p阶循环群,p为一大素数,两个群之间的双线性对e:G1×G1→G2和G1的生成元g.定义1.变性的判定双线性对的Diffie-Hellman问题(mDBDHP).已知(g,ga,gb,gc)和另一个元素Q∈G2,判定是否Q=?e(g,g)ab/c成立.它等价于判定双线性对的Diffie-Hellma问题(DBDHP).2.3条件代理重加密括以下6个算法[2-3].定义2.一个单向的条件代理重加密算法包(1)SetUp(λ).给定安全参数λ,算法输出全局参数param.(2)KeyGen(i).为用户Ui产生公私钥对(pki,ski).(3)RkeyGen(ski,pkj,w).给定用户Ui的私钥ski、关键字w和用户Uj的公钥pkj,用户Ui计算出代理重加密钥rkiwj.(4)Encrypt(pki,m,w).输入pki、关键字w(5)ReEncrypt(CTi,rkiwj).给定密文CTi和代理重加密钥rkiwj,当w=w,输出基于公钥pkj的密文CTj,否则,输出⊥.(6)Decrypt(CT,sk).给定私钥sk和密文和消息m,输出与w有关的密文CTi.CT,输出消息m或者是一个错误符号⊥.对任意w、任意的(m,w)以及任意的(pki,ski)←KeyGen(i)、(pkj,skj)←KeyGen(j)和CTi←Encrypt(pki,m,w),一个正确的条件代理重加密必须满下面两个性质:(1)Pr[Decrypt(CTi,ski)=m]=1.(2)若w=w,有Pr[Decrypt(ReEncrypt(CTi,RkeyGen(ski,w,pkj)),skj)=m]=1,否则Pr[Decrypt(ReEncrypt(CTi,RkeyGen(ski,w,pkj)),skj)=⊥]1-neg(λ).代理重加密算法也包括了上述6个算法,只是输入的时候没有关键字.3条件代理重加密方案分析在Weng等人的方案[2]中,授权人的密文为(A=grH4(e(gx-1人用代理重加密钥rk=gxjx-1pki)x-1i转换成受理人的密文(B=e(B,rk),C=CH4(e(A,ck))).这里{g,g1,f,f1,H1,H2,H3,H4,H5}为全局参数;(gxi,gx-1(xi,x-1i)为私钥;r是一个随机数,且r=H1(m,r,w),w是消息m的关键字.显然,(B=gxir,C=H2(e(g,g)r)(m‖r))可以认为是另一个代理重加密中授权人的密文,因为可以通过代理钥rk转换成公钥(gxj,gx-1文(B=e(g,g)xjr,C=H2(e(g,g)r)(m‖r));而(A=gr看成是基于身份w的密文,私钥为ck.很容易看出他们的方案是通过基于身份(关键字)的加密机制限制代理权限.然而,采用这种方法构造的条件代理重加密不能很好支持多个条件的“与”和“或”的情况.假设W=(w1,w2,…,ws)是消息关键字,W=(w1,w2,…,wt)是授权人设定的关键字:(1)“与”.由于消息m的关键字W与授权人设定W不一定相同,我们不能构造代理重加密方案通过更新条件钥ck=H3(h(w1…wt),pki)x-1改密文C=CH4(e(gx-1pka))r);或更新条件钥ck={ck1,…,ckt}={H3(w1,pki)x-1a,…,H3(wm,pki)x-1Page4H4(e(gx-1H3(ws,pki))r).这里的h为一Hash函数.为了能达到条件限制,需要比较W和W,根据不同的情况分别加密,例如W是W的子集,用W加密,否则用W加密.这显然不符合实际情况.(2)“或”.修改条件钥ck={ck1,…,ckt}={H3(w1,pka)x-1H4(e(H3(w1,pki))r),…,CH4(e(gx-1pki))r)}.虽然修改后的方案满足正确性,但非常低效.同年,Weng等人[3]提出另一个更有效的条件代理重加密方案,在这个方案中代理人只需要一个代理钥.但是方案同样不能有效支持多个条件的情况,因为方案还是雇用了基于身份的加密机制思想来限制代理权限.4本文方案在秘密共享机制的基础上,我们将构造一个新的条件代理重加密方案,并给出正确性和安全性证明.在描述方案前,我们以多个关键字“与”简要概述构造的思路:设(Setup,KG,RG,E,Re,D)是一个代理重加密算法,其中rk为代理重加密钥.另外,设W=(w1,w2,…,ws)是消息关键字,W=(w1,w2,…,wt)是授权人设定的关键字.一般来说,在多个关键字需要比较的情况下,加密需要分别为每个关键字生成相关的消息,我们假设B=(B1,…,Bs).我们的想法是用秘密共享的思想对代理重加密钥rk按W进行密钥分片,利用B进行条件控制.然而,代理人知道关键字和密钥片可以恢复出rk,这样代理人可以产生其它关键字的重加密钥.为了防止这样情况,我们用关键字W和随机数将rk分成关键字代理密钥片(rkw密钥片rkAB,随机数不公开.方案中,可以提取出另一个代理重加密方案.若我们的方案和所提取的方案的系统参数、加密消息和加密消息时所选随机数一致,则满足φ(Bk1,C,rkwC,rkAB)=Re(A,C,rk),(A,C)为提取方案的授权人密文,(A,B,C)是我们方案的授权人密文,φ,φ为我们的方案中重加密算法的子算法.4.1方案描述SetUp(λ).系统参数由(λ,p,G1,G2,e,g,z,H1,H2)构成.其中G1,G2是阶为p的循环群,e:G1×G1→G2是两个群间的双线性对;g是G1的生成元,并定义z=e(g,g);H1:G2→G1和H2:G2×G2→{0,1}是两个抗碰撞的Hash函数.KeyGen(i).用户Ui选择多项式fi(x)=ai0+ai1x+…+ainxn,aij∈Z公钥pki=(gai0,gai2,…,gain)和保密私钥ski=(ai0,ai1,…,ain).RkeyGen(skA,pkB,W).给定私钥skA,公钥pkB和关键字W=(w1,w2,…,wt),这里考虑的是多个条件“与”的情况,并要求t<n.按如下步骤输出代理重加密钥rk:(1)选择n-t+1个随机数ki∈Zn-m+1),计算拉格朗日系数i=∏tlwj=1,j≠ilki=∏t(2)计算关键字的代理密钥片rkw1,2,…,t)和随机数代理密钥片rkAB=∏n-t+1Encrypt(pki,m,W).给定pkA,消息m及关键字W=(w1,w2,…,ws),按如下步骤输出密文CTA.(1)计算A=pkrA0=gaA0r,Bi=grf(H(wi))=[gaA0(gaA1)H1(wi)…(gaAn)H1(wi)n]r,i=1,…,s,C=zrm,D=H2(zr,C).随机数r∈Z(2)输出CTA=(A,B1,B2,…,Bs,C,D).ReEncrypt(CT,rk)).给定密文CTA和重加密i和rkAB,按如下步骤产生公钥pkB下的密文:(1)判断w1=wj1∩w2=wj2∩…∩wt=wjt.这里j1,…,jt分别为wi(i=1,…,m)在W=(w1,w2,…,ws)中的下标.(2)若满足,输出密文CTB=(A,C,D),其中A=e(Bj1,rkw1)…e(Bjt,rkwt)e(A,rkAB);否则输出错误符号⊥.事实上有A=e(g,g)∑t钥rkwPage5按如下两种方式解密:Decrypt(CTu,sku).给定密文CTu和私钥sku,(1)CTu为原始密文CTA=(A,B1,…,Bs,C,D):检查等式是否成立:Aa-11,…,s),D=H2(Z=e(A,g)a-1CZ-1,否则输出错误符号⊥.(2)CTu为转换后的密文CTB=(A,C,D):检查D=H2(T=Aa-1CT-1,否则输出错误符号⊥.加密钥和代理重加密算法,如下:当多个条件“或”的时候,仅仅需要改变代理重i=g在生成代理重加密密钥时,需要选择nt个随机数kij∈Z(kt1,…,ktn).利用上面的代理重加密密钥生成算法分别对wi,利用随机数Ki,产生重加密密钥rki=(rkw即在多个条件“或”时,重加密密钥为rk=(rk1,rk2,…,rkt).CTB=(e(Bi,rkwt},i∈{1,2,…,s}.同样可以应用于条件“与”和“或”混合的情况.4.2正确性为了表述方便,我们假设授权人设定的关键字为消息关键字的前t个,方案的正确性由下面两个等式保证:而代理重加密的算法改为:若w(1)m=C(2)m=C4.3性能分析假设用户选择了n阶多项式;授权人设定的关键字的个数为t;消息的关键字的个数为s.在和Weng等人[2-3]的方案作比较时(表1,表2),由于他们的方案不能有效支持条件的“与”逻辑,且Weng等人也没有具体给出多条件“或”的构造,所以我们在计算他们的代价时按级联的方式给出(这样构造方案可以保证正确,但不一定具有选择密文安全).另外,假设每一级联模块所选的随机数相同且相同部分只传输一次.例如:在方案[2]中,原始密文是一个四元组(A,B,C,D)且A,B与随机数有关,若把它扩展成s个关键字“或”的情形,原始密文为{A,B,(C1,D1),…,(Cs,Ds)},而不是{(A1,B1,C1,D1),…,(As,Bs,Cs,Ds)}.显然,计算代价包括计算A,B和(C1,D1),…,(Cs,Ds),传输带宽也只包括A,B和(C1,D1),…,(Cs,Ds).从上面的算法可知用户需要保存n个私钥,多条件“与”时需要生成t+1个代理重加密钥,多个条件“或”时需要2t个;原始密文包括了s+3个模块,传输的带宽为(s+2)logp数的输出长度;转换后的密文包括了3个模块,传输的带宽为2logp方案私钥文献[2]2t+1(s+2)logp文献[3]中方案112t(2s+1)logp本文方案n2t(s+2)logp由于用户密钥和代理重密钥的生成只需一次,所以我们只分析加密算法、重加密算法和解密算法的时间复杂性.为了简单,我们只考虑用时多的乘法运算、指数运算(包括逆运算)和对运算,并分别用Tmu,Tme和Tpar表示.在我们的方案中,加密算法的主要花费在计算Bi,Bi的计算包括H1(wi),…,H1(wi)n的计算(需要(n-1)Tmu)和gaA0(gaA1)H1(wi)…(gaAn)H1(wi)n的计算(需要nTmu和nTme),所以加密需要的总运算包括(2ns-s+1)次乘法运算和(sn+2)次指数运算;在重加密中计算A(需要2Tpar);原始密文解密计算f(H1(wi))-1(需要(2n-1)Tmu和Tme),所以总运算为(2ns-s+1)次乘法运算、(s+5)次指数运算和一次对运算;转换后的密文解密需要3Tme+Tmu.实际上,在多个条件“或”时,只需选择一个二阶多项式就可以保证安全.这样,本文方案在乘法和指数运算上的次数和Weng等人[2-3]方案相当,但是显著地降低了运算的次数.Page6方案加密重加密原始密文文献[2]文献[3]中方案1本方案(2ns-s+1)Tmu5安全性分析这一节,将在随机预言模型下证明本文方案是IND-CPRE-CCA安全[2].定理1.假设在(G1,G2)中,变性的判定双线对Diffie-Hellman问题(mDBDHP)是困难的,则方案在随机预言模型下是IND-CPRE-CCA安全.证明.区分者收到一个随机实例(g,ga,gb,gc,Q),他的目标是判断Q=e(g,g)ab/c是否成立.把攻击者作为子程序并扮演IND-CPRE-CCA游戏中的挑战者,假设攻击者以ε的优势赢得游戏.游戏一开始,将系统参数param=(g,e,Z=e(g,g),H1,H2)发送给.采用文献[2]中的方法:利用一个有偏量coin∈{0,1}产生不同的公钥并存放在列表k_list,若coin=0,公钥为gx0,…,gxn(表示用户已腐化,可以询问到私钥x0,…xn),反之,公钥为gcx0,…,gcxn(表示不能询问到私钥cx1,…,cxn),进一步,模拟出条件代理重加密钥并存放在列表rk_list.另外,还需要维护两个Hash列表H1_list和H2_list.这些列表初始化都为空.通过列表的信息回答的重加密和解密询问.询问结束后,利用随机实例中的信息生成一个密文返回给,并根据的回答判断.具体如下:Hash询问.任何时间可以询问H1,H2:H1(w)询问:假如列表H1_list存在(w,h1),则返回h1;否则,随机选择h1∈ZH1_list并返回h1;H2(H,C)询问:假如(H,c,h2)在列表H2_list中,则输出h2;否则随机选择h2∈{0,1},添加(H,c,h2)到H2_list,同时返回h2.阶段1.在这个阶段,攻击者可以要求回答IND-CPRE-CCA游戏中的一系列询问:公钥产生询问(i):首先定义一个随机数coin∈{0,1},满足Pr[coin=0]=δ.然后选择xij∈Zp(j=0,1,…,n),如果(coini=0),则公钥为pkij=gxij(j=0,1,…,n),否则为pkij=gcxij.最后增加(pki0,…,pkin,xi0,…,xin,coin)到列表k_list;私钥产生询问(i):从k_list查找(pki0,…,pkin,xi0,…,xin,coin),若(coini=1),则输出“failure”并终止;否则返回xij(j=0,1,…,n);代理重加密钥产生询问(pki,pkj,W):从列表k_list中取出(pki0,…,pkin,xi0,…,xin,coin)和(pkj0,…,pkjn,xj0,…,xjn,coinj).按以下情形计算代理重加密钥rk,其中W=(w1,w2,…,wt):(1)当(coini=0),它表示ski=(xi0,…,xin):首先从H1_list得到hs(s=1,2,…,t),然后选择随机p(d=0,1,…,n-t+1),返回代理重加密钥kd∈Zrk(包括关键字的代理密钥片rkws(s=1,2,…,t)和随机数密钥代理密钥片rkAB),并把(pki,pkj,W,rk)添加到rk_list.rkws=grkAB=∏n-t+1(2)当(coini=1∧coinj=1),它表示ski=(cxi0,…,cxin)和skj=(cxj0,…,cxjn):首先从H1_list得到hs(s=1,2,…,t),然后选择随机数p(t=0,1,…,n-t+1),返回rk并将(pki,kd∈Zpkj,W,rk)添加到rk_list.(3)当(coini=1∧coinj=0),它表示ski=(cxi0,…,cxin)和skj=(xj0…,xjn):输出“failure”并终止.解密询问(pki,CTi):从k_list获得(pki0,…,pkin,xi0,…,xin,coini).若coini=0,返回Decrypt(ski,CTi),否则,按如下两种情形处理:(1)CTi=(A,B1,B2,…,Bs,C,D)是原始密文:查找H1_list和H2_list,是否存在(wi,h1i)∈H1_list(i=1,2,…,s)和(H,C,h2)∈H2_list满足D=h2和A=B(xi0+xi1hi+…+xinhn存在返回m=C(2)CTi=(A,C,D)是转换后的密文:是否存在(H,C,h2)∈H2_list满足D=h2.存在返回m=Page7CH,否则,拒绝并终止.重加密询问(pki,pkj,CTi):首先从k_list获得coini和coinj.如果(coini=1∧coinj=0),输出“failure”并终止,否则,按如下步骤处理:(1)获得rk从rk_list或执行代理重加密钥产生询问(pki,pkj,W).(2)返回CTj=ReEncrypt(CTi,rk).挑战阶段:当结束阶段1,输出目标公钥pk和两个等长的明文m0,m1.首先从k_list获得(pk0,…,pkn,x0,…,xn,coin),若coin=0,输出“failure”并终止,否则返回密文CT.这里要求明文有相同关键字个数,并设Wd=(wd1,wd2,…,wds),d∈{0,1}.CT=(A=gbx0=pkb/cBi=gb(x0+x1hdi+…+xnhn其中hdi可以从H1_list获得.C=Qmd,D=H2(Q,C),显然,CT是具有关键字Wd=(wd1,wd2,…,wds)的消息md在公钥pk=(ga-1cx0,ga-1cx1,…,ga-1cxn)下的密文,且加密中的随机数r=abQ=e(g,g)r=e(g,g)ab/c,则CT是md合法密文;否则,就是其它消息的密文.这样,挑战者可以攻击者的回答来判断Q是否等于e(g,g)ab/c.阶段2.攻击者可以在IND-CPRE-CCA游戏[2]的限制下继续发起询问,挑战者像在阶段1一样回答攻击者的询问.猜测:最后输出一个猜测值d∈{0,1}.若d=d,输出1,否则输出0.进一步,我们假设qH1,qH2,qsk,qrk和qre分别表示H1、H2、私钥产生、代理重加密钥产生以及代理重加密的询问的次数,e表示自然对数的底数.用E1表示事件pk=(ga-1cx0,ga-1cx1,…,ga-1cxn)没有被私钥询问(coin=0),E2表示询问H2时没有返回D.显然,两个事件是独立的.在pk的私钥被询问的情况下,可以通过私钥解密;若询问H2时返回D,可以查询H2来解密,即E1,E2不成立时,可以准确输出d,且Pr[E1]=qsk“failure”的情况下:Pr[输出1]=Pr[d=d]=Pr[d=d|[~(E1∩E2)]Pr[~(E1∩E2)]+Pr[d=d|(E1∩E2)]Pr[E1∩E2]2+()ε1-qsk+qH2(=1的优势为Pr[输出1]-1我们可以得出在没有输出“failure”的情况下,并终止:另外,在下面几种情形下可能会输出“failure”(1)私钥产生询问当coin=1.(2)代理重加密钥产生询问(pki,pkj,w)当(3)在挑战阶段当coin=0.让qmax=max(qsk,qrk,qre),很容易看出在整个(coini=1∧coinj=0).游戏过程中没有输出的概率至少有根据文献[10]的结果,δqmax(1-δ)在δ=qmax1+qmax达到最大值.当qmax充分大时(1-(1-δ)δ)2qmax的值e2.因此没有输出“failure”至少有1接近1综上,可以知道的优势至少为6总结本文简要地分析了Weng等人[2]基于身份加密技术构造的条件代理重加密方案,因该方案不能很好支持多个条件的“与”和“或”运算,需要新的技术来设计多个条件的代理重加密方案.本文利用秘密共享机制,构造了一个新的条件代理重加密方案.方案在随机预言模型下证明了其安全性,并能够很好支持多个条件的情况.
