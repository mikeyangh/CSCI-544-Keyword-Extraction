Page1计算可靠且高效的群组密钥协商协议符号化分析方法张子剑1)祝烈煌1)王峰2)廖乐健1)1)(北京理工大学计算机学院北京100081)2)(海军装备研究院北京100161)摘要符号化分析方法将密码原语视为黑盒,且未研究其需要满足的具体安全属性,因而计算可靠性一直备受质疑.而且,这类方法在分析参与者数目较多的群组密钥协商协议时不具有高效性.针对上述两个问题,文中提出了一种计算可靠且高效的群组密钥协商协议符号化分析方法.该方法通过为符号化表达式设计一个Pattern函数,定义了模幂运算需要满足的具体安全属性,并基于此证明了符号化分析Burmester-Desmedt协议在通用可组合安全框架下是计算可靠的.进而通过数学归纳法,证明了Burmester-Desmedt协议的安全性与参与者数目无关,避免了参与者数目对符号化分析造成的影响,提高了符号化分析方法的效率.关键词计算可靠;高效;符号化分析;通用可组合;群组密钥协商1引言随着群组通信应用的发展以及用户数目的增长,针对群组通信的攻击层出不穷,群组密钥协商协议作为群组通信的基础首当其冲.为此,严格分析群组密钥协商协议的安全性变得十分必要.传统的密码协议分析方法主要包括可证安全[1-3]与符号化分析[4-6]两类.前者由于将协议的安全性归约到数学困难假设的难解性,所以分析结果是计算可靠的.但该方法的证明过程冗长且繁琐,难以实现自动化[7].相反地,后者假定密码原语均具有理想的安全属性,并将密码原语、敌手能力等抽象为一个符号化代数系统[8],因而容易实现自动化分析.但是,由于该方法没有考虑实现密码原语的实际算法应有的具体安全属性,因而与可证安全相比,分析结果的可靠性一直备受质疑[9-11].例如,针对对称加密方案,我们通常定义术语Enc(k,m)来表示用密钥k加密明文m,并通过建立规则Dec(k,Enc(k,m))=m表示只有具有密钥k,密文才能被解密还原出明文m.这两个抽象虽然简化了符号化分析的过程,但却没有清晰地阐明实际加密方案应满足的安全属性,比如是否限制所有密文的长度必须相同,是否需要加密算法具有不确定性等[12].而且,符号化方法分析协议安全性所需的时间随着协议参与者数目的增长而急剧增加[13],因而在分析参与者数目较多的群组密钥协商协议时效率较低.为此,我们考虑通过结合符号化分析方法与可证安全,实现一种计算可靠且高效的群组密钥协商协议分析方法.目前,国内外学者针对计算可靠的符号化分析方法已经进行了广泛的研究.针对被动敌手,Abadi和Rogaway[12]率先提出了一种计算可靠的符号化对称加密算法.Micciancio和Warinschi[14]指出Abadi和Rogaway的工作不是完备的,提出了一种无歧义(confusionfree)的加密算法,并证明了其完备性.Laud和Corin[10]针对可组合的密钥提出了一种可靠的对称加密算法.Herzog[11]提出了一种可靠的公钥加密算法.Gracia和vanRossum[15]提出了一种可靠的Hash函数.Kremer和Mazaré[16]提出了一种可靠的双线性映射,并分析了Joux等基于双线性映射的密码协议.Bresson等人[17]基于(P,Q)-DDH问题,分析了Burmester-Desmedt协议(简写为BD协议)的安全性[18].但是,该方法既未给出模幂指数间的模加减运算以及对应简化规则的符号化定义,也没有实现自动化分析.而且,由于没有结合通用可组合(universallycomposable)安全框架(简写为UC安全框架),因而其结果不具有可组合安全性.针对主动敌手,Micciancio和Warinschi[19]通过将可证安全下协议的执行过程映射到符号化分析下协议的执行过程,提出了一个可靠的加密算法.Galindo等人[20]利用上述映射分析了非延展的承诺算法.Backes和Unruh[21]提出了一个符号化可靠的零知识证明系统.Backes等人[22]提出了一个用于自动证明密码协议的理想密码学库Libideal,协议如果可以模拟Libideal即是安全的.Canetti等人[23-25]最近通过结合UC安全框架与spi演算,提出了通用可组合符号化分析(UniversallyComposableSymbolicAnlaysis,UCSA)方法,虽然该方法实现了计算可靠且高效的分析密码协议安全性,但他们只证明了基于加密、签名以及Diffie-Hellman的双方身份认证和密钥协商协议.Zhang和Zhu等人[13,26]通过扩展UCSA方法,分析了基于双线性对的群组密钥协商协议以及具有3个参与者的BD协议.但是他们没有考虑具有任意数目参与方的BD协议.本文为模幂运算设计了一个符号化模型,并证明该模型是计算可靠的.在此基础上,通过扩展Canetti的方案[24],以Burmester-Desmedt协议为例,证明符号化分析结果在UC安全框架下是计算可靠的.进而利用数学归纳法,证明符号化分析BD协议时参与者数目与协议的安全性无关.因此,面对参与者数目较多的BD协议时,我们只需符号化分析具有三个参与者的BD协议即可,而且分析结果具有计算可靠性.Katz和Yung[27]设计了一个编译器,将在被动环境(passivesetting)下安全的协议编译为在主动环境下(activesetting)外部攻击(outsiderattack)安全的协议.Katz和Shin[28]也设计了一个编译器,将在主动环境下外部攻击安全的协议编译为在主动环境下内部攻击(insiderattack)安全的协议.另外,UCSA方法保证了单会话安全的协议在多会话下也同样安全[24].因此,只需在被动环境下分析单会话BD协议的安全性,即可通过顺序调用上述两个编译器,构造出一个在内部攻击下多会话安全的群组密钥协商协议.本文第2节提出模幂运算的符号化模型;第3节定义符号化不可区分性与计算不可区分性,并证明该模型的计算可靠性;第4节证明符号化分析的Page3计算可靠性;第5节简化符号化分析BD协议时所需的参与者数目;第6节总结全文.2模幂运算的符号化模型本节设计模幂运算的符号化模型.具体包括:定义模幂运算的符号化表达式以及根据模幂运算满足的运算定律和具有的属性,定义表达式间的等价关系和派生规则.定义1.模幂运算的符号化表达式.设GZp为一个循环群,p为素数,q为阶,则模幂符号化表达式语法递归定义如下:Y表示模幂的指数.其中,0,1分别表示二进制的0与1,x表示由若干二进制的0与1组成且模为q的二进制位串,Y-1表示Y的逆,Y·Y表示两个指数相乘.M表示模幂运算值.其中,g表示循环群的生成元,MY表示M的Y次幂模p,M-1表示M的逆,M·M表示两个模幂值的乘积模p.N表示由若干模幂指数与模幂运算值组成的元组.其中,Y表示模幂的指数,M表示模幂运算值,N,N表示由模幂指数或模幂运算值组成的一个二元组.中的语法.例如,N:x1,x-12,gx3,gx1·x2,gx2·x-1gx2·x-1x,x-12属于类型Y-1,gx3,gx1·x2,gx2·x-1型MY,gx2·x-1环运算问题,即模幂运算值不会作为指数出现.4·gx3是一个有效的表达式,因为x1属于类型一个有效的符号化表达式指该表达式符合定义1另外,通过该语法,本文限定了不考虑模幂的循定义如下:定义2.等价关系.针对一个有效的符号化表达式N,等价关系被若N=Y1·Y2,则N=Y2·Y1;若N=(Y1·Y2)·Y3,则N=Y1·(Y2·Y3);若N=(Y1·Y2)-1,则N=Y-11·Y-12;若N=(Y-1)-1,则N=Y;若N=Y·Y-1,则N=1;若N=0·Y,则N=0;若N=1·Y,则N=Y;若N=(MY1)Y2,则N=MY1·Y2;若N=M1·M2,则N=M2·M1;若N=(M1·M2)·M3,则N=M1·(M2·M3);若N=(M1·M2)-1,则N=M-11·M-12;若N=(M-1)-1,则N=M;若N=M·M-1,则N=1;若N=0·M,则N=0;若N=1·M,则N=M.定义3.派生规则.针对两个有效的符号化表达式M与N,如果M中所有的子表达式均可由N中的子表达式通过等价关系以及如下公式递归计算得到,则称N可派生出M.简记为NM.具体公式如下:NN;N0;N1;若Ny,则Ny-1;若Ny1且Ny2,则Ny1·y2;若Nm且Ny,则Nmy;若Nm,则Nm-1;若Nm1且Nm2,则Nm1·m2;若Nn1且Nn2,则Nn1,n2;若Nn1,n2,则Nn1且Nn2,其中,y,y1,y2的类型是Y,m,m1,m2的类型是M,n1,n2的类型是N.如果M无法通过上述规则被派生出,那么我们称NM.例如,N:x1,gx2可以派生出M1:gx1·x2,但无法派生出M2:gx1·x3.虽然判断两个有效的模幂符号化表达式是否具有派生关系本质上是一个NP问题,但由于本文仅需符号化分析具有3个参与者的群组密钥协商协议,所以协议运行时产生的表达式数目较少,且指数组成较简单,因而时间复杂度可接受.3模幂符号化模型的计算可靠性本节通过设计一个Pattern算法,定义敌手可以派生出的符号化表达式,并通过设计一个映射算法,定义了如何将派生出的符号化表达式转换为二进制位串(bit-strings).基于上述两个算法,通过定义模幂运算的符号化不可区分性和计算不可区分性,本节最后证明了符号化不可区分性蕴含计算不可区分性.表达式.已知N时,Pattern(N)算法如下:算法1.令N与N是两个有效的模幂符号化1.遍历N,并按照如下公式递归替换其中的子表达式:Page4Pattern(N)=0,烄1,x,(Pattern(y))-1,若N=y-1Pattern(y1)·Pattern(y2),若N=y1·y2g,烅(Pattern(m))y,□,(Pattern(m))-1,若N=m-1Pattern(m1)·Pattern(m2),若N=m1·m2烆Pattern(n1),Pattern(n2),若N=n1,n2.遍历Pattern(N),对于每个子表达式,如果存在符号□,则将整个子表达式替换为□.3.返回Pattern(N).如果my无法从N中被派生出来,根据离散对数(DiscreteLogarithm,DL)问题以及确定性Diffie-Hellman(DecisionDiffie-Hellman,DDH)问题可知,敌手无法获取y.我们用符号□表示敌手得到的表达式与y无关.例如,给定两个有效的表达式N1,N2:已知N1,敌手可以从N2获取到的表达式为此算法隐含限定了模幂运算需要满足的具体安全属性,即根据模幂运算的结果,解决DL问题和DDH问题是困难的.算法2.令τ表示将符号化表达式映射为对应的二进制位串,η是安全参数,r表示由伪随机产生器G(η)随机生成的一个伪随机数,映射算法被递归定义如下:Mapping(N)=0,烄1,τ(x),(Mapping(y))-1,Mapping(y1)·Mapping(y2),若N=y1·y2τ(g),烅(Mapping(m))Mapping(y),若N=my(Mapping(m))-1,Mapping(m1)·Mapping(m2),若N=m1·m2Mapping(n1),Mapping(n2),若N=n1,n2τ(g)τ(r),烆定义4.符号化不可区分性.令N,N1与N2为有效的符号化表达式.已知N,若Pattern(N1)=Pattern(N2),则称已知N时,N1与N2符号化不可区分.定义5.计算不可区分性.令B1,B2为两个二进制位串,且随机选择其中一个作为敌手的输入时,如果敌手认为输入的是B1,它输出0.反之,输出1.那么,B1与B2计算不可区分(简写为B1B2),当且仅当在安全参数η的多项式时间内,任意敌手无法区分输入的是B1还是B2,令negl(η)表示安全参数η的可忽略函数[12],我们有|Pr[(B1)=1]-Pr[(B2)=1]|<negl(η).基于上述算法与定义,下面证明符号化不可区分性蕴含计算不可区分性.定理1.给定一有效表达式N,若Pattern(N1)=Pattern(N2),则Mapping(N1)Mapping(N2).证明.我们利用混合模型予以证明.构造混合模型的步骤如下:(1)遍历N1,并将集合{y|y的类型是x,作为模幂的指数在N1中出现,Ny}中的每个元素依次加入N中.分别计算每次加入前后表达式N1的Pattern值,并设集合中所有元素都加入到N后形成的表达式为N1.(2)遍历N2,并将集合{y|y的类型是x,作为模幂的指数在N2中出现,Ny}中的每个元素依次加入N中.分别计算每次加入前后表达式N2的Pattern值,并设集合中所有元素都加入到N后形成的表达式为N2.若基于算法2将这两步产生的Pattern值映射为二进制位串,由于Pattern(N1)=Pattern(N2),根据算法2和定义5,我们有Mapping(Pattern(N1))与Mapping(Pattern(N2))计算不可区分.另外,根据算法2和定义5可知,每相邻两行符号化表达式的Pattern值在通过算法2映射为二进制位串后,也是计算不可区分的.例如,若3个表达式为N:x1,x-12,gx-1N1:gx3,gx1x2,gx2x-1N2:gx3,gx1x2,gx-1则有Pattern(N1)=Pattern(N2)=(□,gx1x2,□,□,□).我们遍历N1,N2得到集合{x|x3,x4},将该集合中的元素逐步加入N中,并分别计算每次加入前Page5后N1,N2的Pattern值如下:N1:gx3gx1x2gx2x-11:gx3gx1x2gx2x-1N11:□gx1x2□□□N02:□gx1x2□□□N02:gx3gx1x2□gx2x-1N1N2:gx3gx1x2gx-1其中,N0N11,N12表示加入x3时的Pattern值,且N1=N1,N2=N2.由于Pattern(N1)=Pattern(N2),所以N02.又根据算法2和定义5知,由于□被替换为N0τ(g)τ(r),因而Mapping(N0任意相邻两行符号化表达式的区别只是集合{y|y的类型是x,作为模幂的指数在N1/N2中出现,Ny}中的一个元素被加入到N中.因此根据算法2和定义5可知,每两个相邻行表达式通过映射算法得到的位串,在不知道集合{x|x3,x4}时均计算不可区分.否则将与DL问题或DDH问题矛盾.因此,Mapping(N1)Mapping(N2).4符号化分析的计算可靠性本节回顾了BD协议的执行过程,并通过定义具有n个参与者的群组密钥协商符号化安全标准以及理想函数,证明了符号化分析的计算可靠性.定义6.BD协议[18]执行过程.令所有参与者pi(i∈Zn)逻辑上排列成一个模n的环,并在循环群GZp中进行运算.其中,p为素数,群的生成元为g∈Zp,q为阶.设每个参与者在协议执行前已经知道其他所有参与者的ID.协议的执行过程被定义为如下3轮:第1轮.每个参与者pi产生一个随机数xi(xi←RZq),并广播:gxi(modp);第2轮.每个参与者pi广播:第3轮.每个参与者pi计算:ski=(gxi-1)nxi(Xi)n-1(Xi+1)n-2…Xi+n-2(modp).我们将在被动环境下具有n个参与者的BD协议简写为n-BD-Passive.而且,令i,j∈Zn,每个参与者pi被初始化后会输出(Establish-Key,sid,pi,{pj}),在产生会话密钥后会输出(Key,sid,{pj},k).这里,Establish-Key与Key分别表示协议的开始与成功结束,sid表示会话ID,{pj}表示协议所有参与者ID的集合,k表示产生的会话密钥.定义7.符号化安全标准(SymbolicSecurityCriterion).令i,j∈Zn,具有n个参与者的群组密钥协商协议是符号化安全的群组密钥协商协议,如果满足(1)一致性:每个参与者在生成会话密钥后,所(2)私密性:若skprotocol有的会话密钥都相同;密钥,skprotocol则有定义8.群组密钥协商的理想函数(IdealFunctionalityofGroupKeyExchange).令i,j∈Zn,安全参数为k,理想敌手为S,群组参与者的数目为n,则群组密钥协商的理想函数n-GKE定义如图1所示.理想函数n-GKE1.初始化当收到参与者pi的消息(Establish-Key,sid,pi,{pj})后,n-GKE如果之前没有记录过元组(sid,pi,{pj}),记录(sid,pi,{pj}),并将该消息发送给理想敌手.2.密钥传输当收到理想敌手的消息(deliver,sid,pi,{pj}),n-GKE检查具有相同sid和{pj}的元组(sid,pi,{pj})个数是否达到n:如果达到,进一步检查是否记录过(Key,sid,{pj},k):如果没有,n-GKE选择r←Zq,计算k=gr(modp),记录[Key,sid,{pj},k],并将其输出给pi.如果存在,输出(Key,sid,{pj},k)给pi.定理2.如果n-BD-Passive是一个符号化安全的群组密钥协商协议,那么它一定安全地实现n-GKE.证明.我们通过反证法予以证明.即如果存在一个环境,可以区分它是在与n-BD-Passive和实际敌手交互,还是在与理想函数n-GKE和理想敌手交互,那么n-BD-Passive不是符号化安全的群组密钥协商协议.令i,j∈Zn,我们首先构造一个模拟器如下:(1)模拟出n个未激活的参与者pi.(2)当从n-GKE处收到消息(sid,pi,{pj})时,说明环境已通过n-GKE,激活了某个虚拟(dummy)参与者pi,因此激活对应的模拟参与者pi.(3)当收到环境发送给pi的消息时,将它传到对应的pi的接收通信带(incomingcommunica-tiontape)上.Page6(4)当收到pi发送给环境的消息时,将它发送给.(5)当pi产生一条输出[Key,sid,{pj},k]时,发送(deliver,pi,{pj})给理想函数n-GKE.这里,我们证明所有概率多项式时间的环境可以区分出是在与上述模拟进行交互还是在进行实际交互的概率可以忽略不计.由于在被动环境下,协议n-BD-Passive执行时参与方发出的每条消息均是模幂运算的结果.因此,若环境能以不可忽略的概率区分上述模拟与实际交互,则在进行实际交互时:(a)环境可以使至少一个参与者不被初始化.这使得与实际交互时得到的消息(Establish-Key,sid,pi,{pj})的个数少于从上述模拟中得到的,从而根据上述模拟的第(2)种情况进行区分.(b)环境可以判定会话密钥与收到的消息是否具有相关性.由于在与上述模拟交互时,会话密钥与收到的消息是相互独立的,因此可以根据上述模拟的第(3)(4)种情况进行区分.(c)环境使得至少一个参与者协商出的会话密钥与其他参与者的不一致.这使得在进行实际交互时得到的会话密钥不完全相同.从而可以根据上述模拟的第(5)种情况进行区分.(d)敌手猜对会话密钥的概率不可忽略.由于在执行上述模拟时敌手猜对会话密钥的概率可以忽略不计,从而可以根据上述模拟的第(5)种情况进行区分.针对(a),由于n-BD-Passive协议第1轮用到的xi是从Zq中通过随机选择得到的,所以敌手直接猜对它们的概率可以忽略不计.这使得敌手模拟某个参与者的概率可忽略不计,即第1种情况发生的概率可忽略不计.针对(b),如果敌手可以判断收到的消息与最终的会话密钥是否相互独立,那么敌手要么可以计算出第1轮中某些消息的指数,要么可以区分出会话密钥与群中随机产生的一个元素.因此,可通过该敌手解决DL问题或DDH问题.所以第2种情况发生的概率可以忽略不计.针对(c)和(d),根据定义1,我们可以为环境得到的所有消息(简写为mb),建立一个对应的模幂符号化表达式(简写为ms).如果环境根据mb,可以使得某个参与者协商出的密钥与其他参与者的不一致,或者猜对会话密钥的概率不可忽略,那么根据ms,符号化敌手要么找到一个有效的执行,使得定义7不被满足,要么计算可区分不蕴含符号化可区分.前者说明n-BD-Passive不是一个符号化安全的群组密钥协商协议,与前提矛盾.后者与定理1的逆否命题矛盾.5符号化分析协议的安全性本节符号化分析n-BD-Passive的安全性.定理3.若3-BD-Passive是一个符号化安全的群组密钥协商协议,则n-BD-Passive是一个符号化安全的群组密钥协商协议.说,我们需要证明如下两点:证明.我们通过数学归纳法进行证明.具体地(1)3-BD-Passive协议是一个符号化安全的群组密钥协商协议.(2)若k-BD-Passive协议是符号化安全的群组密钥协商协议,那么(k+1)-BD-Passive协议也是符号化安全的群组密钥协商协议.由于(1)是前提,所以本文只需证明(2).又因为协议是在被动环境下执行的,所以定义7中的一致性可以根据数论知识得到保证.下面证明(k+1)-BD-Passive协议满足定义7中的私密性.即证明若符号化敌手,根据(k+1)-BD-Passive协议的执行可以区分sk(k+1)-BD-Passive一个符号化敌手根据k-BD-Passive协议的执行,可以区分skk-BD-Passive我们令调用.由于敌手可以获取(k+1)-BD-Passive协议执行时所有参与者发出的消息,所以需要模拟这些消息给.具体的模拟过程如下:(1)令k个参与者{pi|i∈Zk}一起执行k-(a)第1轮的消息:{gxi|i∈Zk};(b)第2轮的消息:BD-Passive协议,并获取:(c)一个符号化输入skk,该输入可能是skk-BD-Passiverandom也可能是skk-BD-Passive(2)选择一个随机数xk(xk∈Zq),并计算gkxk,用以模拟第k+1个参与者pk.如下:(3)调用,并模拟(k+1)-BD-Passive执行(a)在第1轮,当激活pi(i∈Zk+1)时,计算并返回gkxi(i∈Zk+1);(b)在第2轮,当激活p0时,计算并返回X0:Page7t=∑k-1X0=(skk·gt)k·(gkx0)-kxk;i=1(c)在第2轮,当激活pi(i∈[1,k-2])时,计算并返回Xi=(gxixi+1-xixi-1)k2;Xk-1:(d)在第2轮,当激活pk-1时,计算并返回t=∑2(k-1)-1Xk-1=(gkxk-1)kxk·(skk·gt)-k;(e)在第2轮,当激活pk时,计算并返回Xk:(4)当请求skk+1时,计算skk+1:i=1s=ximodkxi+1(modk)-ximodkxi-1(modk),t=∑k-1skk+1=(skk)k2·∏k-1(5)返回的输出值.从的角度看,每一个xi(i∈Zk+1)都是随机数.并且如果skk是skk-BD-Passive反之,如果skk是独立于实际会话密钥的skk-BD-Passive的模拟除了消息X0,Xk-1以及skk+1外,其它与执行(k+1)-BD-Passive协议得到的消息都相同.这是因为gkxi(i∈Zk+1)可以由gxi(i∈Zk)与xk计算出,Xi(i∈[1,n-2])可以由gxixi+1-xixi-1计算得到,而Xk=(gxkx0-xkxk-1)k2可以由gx0,gxk,xk计算得到.此时虽然X0和Xk-1与实际值是相互独立的,但可以看到,skk+1仍然是独立于实际会话密钥的sk(k+1)-BD-Passiverandom.反之,输出1.成功的概率(k)为令敌手认为skk+1是sk(k+1)-BD-Passive(k)=Pr[(skk+1=sk(k+1)-BD-Passive设α为可以区分出X0与Xk-1是真实值还是随机值的概率.则成功的概率(k)为(k)=Pr[(skk=skk-BD-Passive=Pr[skk+1=sk(k+1)-BD-PassivePr[skk+1=sk(k+1)-BD-Passive(Pr[outputs1](1-α)+1α)=(k)+α(1-Pr[outputs1])/2(k).因此,若成功攻陷(k+1)-BD-Passive,则也可以成功攻陷k-BD-Passive.6结束语本文通过设计一个Pattern算法,定义了模幂运算需要满足的具体安全属性.进而证明了满足上述安全属性的模幂运算符号化模型满足符号化不可区分性蕴含计算不可区分性.基于该性质,证明了BD协议的符号化分析具有计算可靠性.最后通过数学归纳法,将符号化分析参与者数目较多的BD协议简化为分析具有3个参与者的BD协议,提高了符号化分析的效率.本文提出的方法具有一定的通用性.即针对其他密码原语,根据其计算可靠的符号化模型,通过简化协议参与者的数目,该方法亦可被用于分析其他群组密钥协商协议,如GDH协议等.
