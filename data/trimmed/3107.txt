Page1一种基于混合策略的彩色编码算法王建新杨志彪刘云龙陈建二(中南大学信息科学与工程学院长沙410083)摘要彩色编码是求解实际工程中难解问题的一种新兴而重要的技术.在应用该技术时,算法复杂度取决于彩色编码着色方案的规模,因此规模的大小将成为衡量彩色编码算法优劣的标准.彩色编码的研究在最近几年得到了许多有重要意义的结果.基于完全散列函数的PH算法产生的着色方案规模为O(6.1kn),是目前世界上最好的确定彩色编码结果;彩色编码算法PBCC是一种利用组合思想针对n2k的有效着色算法.文中以分治算法为基础,结合核心化技术,并利用PBCC算法求解子问题,提出了一种基于混合策略的彩色编码算法HABCC,并且证明了由HABCC算法产生的着色方案确实可以覆盖到所有子集,着色方案规模为|S(n,k)|2k·logkk-1·n.通过与PH算法的比较,说明了HABCC算法具有更小的着色方案规模,对彩色编码技术的实际应用具有重要的意义.关键词彩色编码;分治;核心化1引言随着信息产业和现代工业的快速发展,各领域中的信息海量增长,许多组合问题利用目前人类具有的计算资源无法在有效的时间内解决.在计算机复杂性理论中,这些计算难解问题大多属于NP难解问题.然而,大量的这些NP难解问题又是工程应用中不可避免而且必须解决的问题.子集选择(subsetselection)是组合学研究领域中的一类重要的问题,通常被描述成下面的形式:给定一个包含n个元素的全集U,找到满足某一特定条件R,包含k个元素的子集WU.所有此类问题都可以用穷举的方法在指数时间内得到可行解,即枚举所有的组合情况构成的集合,该穷举算法的时间复杂度为O((nk)).k-Path问题是一个典型的子集选择问题,给定一个图G和一个整数k,要求在图G中找到一个包含k个节点的简单路径.k-Path问题的难点在于对路径简单性的要求(即路径节点不重复),最早提出的算法时间复杂度为O(2kk!nO(1))[2,8].Alon等人通过对k-Path问题的深入研究,阐明了解决该问题的本质是在图G所有的n个节点中选择k个节点构成的子集.基于这一观察,于1995年首次提出了彩色编码技术,得到了一个时间复杂度为O(5.44knO(1))的随机算法[1],极大地降低了求解问题的时间复杂度.彩色编码的基本思想可以描述为:给定元素集合U和颜色集合C,其中|U|=n,|C|=k,将U中的每个元素都使用C中的一种颜色进行着色.假定原问题的目标解包含的k个元素正好被着为k种不同的颜色,原问题将获得额外的着色约束条件而简化.为了便于对彩色编码的理解,沿用文献[4]中的定义如下.定义1((n,k)着色).给定元素全集U={e1,e2,…,en}和颜色全集C={c1,c2,…,ck},将集合U中的所有元素使用C中的任意颜色进行着色hi=f(ei)(其中f(e)表示对元素e赋予一种颜色),得到一个n元组H=〈h1,h2,…,hn〉,且i,hi∈C,∪ni=1{hi}=C,即U中每个元素均可对应一种颜色,且颜色全集中每种颜色至少被使用过一次,则称该n元组为一个(n,k)着色.定义2(覆盖).给定一个(n,k)着色H=〈h1,h2,…,hn〉和一个子集W,其中W是从U={e1,e2,…,en}中任意选取k个元素所组成的子集,对任意i和j,若ei,ej∈W且i≠j,则hi≠hj,则称着色H覆盖子集W.定义3((n,k)着色方案).若(n,k)着色的集合满足:任取U的一个k元素子集W,至少存在一个可以覆盖W的(n,k)着色,则称该集合为(n,k)着色方案,记作S(n,k).方案包含着色的数目称为着色方案的规模,记作|S(n,k)|.值得注意的是,彩色编码技术本身并不直接解决目标问题,而是通过额外的限制条件有效地降低了目标问题的搜索空间.在求解某些问题时,需要枚举所有的元素组合情况,而利用彩色编码技术后,一种着色可以覆盖大量不同的组合情况,从而有效地减少了搜索空间.彩色编码已成功应用于求解k-Path[1,3]、k-Cycle[1]、Matching[13]、Packing[13]等NP难问题,并在生物蛋白质网络中的路径查找[9]和Motif查找[10-11,14]等问题上有着广泛的应用.基于彩色编码的算法时间复杂度依赖于着色方案的规模,根据算法所用的着色方式不同,彩色编码可以分为随机式着色和确定式着色.Alon等人提出彩色编码思想时,详细介绍了随机式着色算法.使用k种不同的颜色对图中的所有节点进行着色,在着色图中利用动态规划寻找正确着色(k个节点颜色各不相同)的问题实例.通过分析问题实例正确着色的概率,重复着色-求解过程足够次数,将有较大概率求得正确解,算法的时间复杂度为O(5.44knO(1)).Hüffner等人[13]利用1.3k种颜色着色,将随机算法复杂度改进到O(4.32k).最近,Chen等人利用分治思想,组合小规模的解来构成较大规模的解,提出了复杂度为O(4k)的随机算法[3].同样基于分治思想,Kneis等人也提出了划分着色的随机算法[5],复杂度为O(4k).虽然随机着色算法可以得到一定精度的结果,但在对结果精度有很高要求的情况下,这样的概率解是不能令人满意的.为了构造确定式着色,Alon等人在文献[1]中指出可以利用完全散列函数族将随机算法确定化.根据文献[6-7]中的理论,(n,k)完全散列函数族F可以在O(2O(k)nlogn)的时间复杂度内构造出来,且函数族F的大小为O(2O(k)logn).通过枚举F中的所有函数,得到大小为O(2O(k)logn)的确定式着色方案.经过分析,表示任一散列函数需要多于12kbits,枚举所有的散列函数至少需要212k>4000k,因此,Page3这种着色方案的构造算法即使在k较小时也不太实用.最近,Chen等人大幅改进了确定式着色方案的研究结果,提出了复杂度为O(6.1kn)的算法.在具体的构造过程中,采用了4层散列处理来避免冲突,即Zn→Z2k→Zk/4→Zcj(cj-1).该算法(记为PH(PerfectHashing))首先使用核心化方法将(n,k)着色问题在多项式时间内规约到(k2,k)着色问题,然后将k2元素散列到k/4个位置上,再利用另一组散列函数分别将每个位置的元素重新散列到cj(cj-1)个位置上来解决冲突,最后使用已有的(cj(cj-1),cj)着色方案构造总体着色方案.进一步,通过对cj大小的分类讨论,确定算法的复杂度为O(6.1kn).虽然算法得到了很好的理论复杂度,但在实际应用中的效果不尽理想.直接利用组合思想也可以得到确定式着色方案.最近,从组合算法角度对着色方案构造算法的研究得到了一个新的结果.文献[4]对彩色编码在n2k(非小参数)情况下的应用进行了深入研究,提出了一种基于划分的着色算法PBCC(Partition-BasedColor-Coding).在实际情况下的应用表明,PBCC比PH算法有更高的实用价值.但是n2k约束条件的限制,PBCC算法在很多情况下无法应用.本文从简单的分治策略出发,结合核心化技术,并充分利用现有的PBCC算法,提出了一种基于混合策略的着色算法(Hybrid-Architecture-BasedColor-Coding,HABCC).通过理论分析以及实际着色方案规模的比较,HABCC算法比现有算法具有更小规模的着色方案,并且易于构造,从而具有更好的实用性能,对彩色编码技术的应用具有重要的意义.2基于混合策略的着色算法为了便于接下来的讨论,定义着色以及着色方基于混合策略的着色算法将从简单的分治策略出发,结合核心化技术,并利用现有的PBCC算法处理子问题,下面几节将分别介绍以上算法技术.2.1分治着色算法案的变换操作如下.定义4(着色的连接).给定(n1,k1)着色H1=〈h1,h2,…,hn1〉及(n2,k2)着色H2=〈h1,h2,…,hn2〉,H1和H2的连接定义为〈h1,h2,…,hn1,h1,h2,…,hn2〉,记为H1H2.定义5(着色方案的和连接).给定着色方案S(n1,k1)及S(n2,k2),不妨设|S(n1,k1)||S(n2,k2)|,着色方案的和连接定义为S(n1,k1)S(n2,k2)={Hif(S(n2,k2))|Hi∈S(n1,k1)},其中函数f(S(n2,k2))返回着色方案S(n2,k2)中的任意一个着色.因此,着色方案规模|S(n1,k1)S(n2,k2)|=max(|S(n1,k1)|,|S(n2,k2)|).定义6(着色方案的积连接).给定着色方案S(n1,k1)及S(n2,k2),着色方案的积连接定义为S(n1,k1)S(n2,k2)={HiHj|Hi∈S(n1,k1),Hj∈S(n2,k2)}.即S(n1,k1)中的每个着色都将和S(n2,k2)中的每个着色进行连接.因此,着色方案规模|S(n1,k1)S(n2,k2)|=|S(n1,k1)|×|S(n2,k2)|.分治着色算法的基本思想是将元素分成两部分,分别进行着色.实际着色时,首先将元素全集U分成两个部分,记为U1,U2,其中U1∩U2=,U1∪U2=U,且|U1|=n1,|U2|=n2.为使构造出的着色方案确定式地覆盖所有选择情况,必须枚举颜色数在U1和U2中的所有分布情况.U中任一k元素的子集W,满足|U1∩W|=k1,|U2∩W|=k2,显然k1+k2=k.如果存在集合U1∩W的k1着色方案S(n1,k1)和U2∩W的k2着色方案S(n2,k2),那么S(n1,k1)S(n2,k2)将覆盖U的所有k元素子集.此外,当k1×k2=0时,有两种情况:k1=0,此时S(n1,k)可覆盖子集W;或k2=0,此时S(n2,k)可覆盖子集W.故S(n1,k)S(n2,k)即可覆盖WU1或WU2的所有情况.因此,取n1=n/2,n2=n/2,分治着色算法构造着色方案的公式如下:S(n,k)=S(n/2,k)S(n/2,k)∪显然,式(1)是一个递推式,在假设可以获得较小规模问题解的前提下,组合小规模问题的解可以获得大规模问题的解.公式中的第一部分是目标解全部存在于同一个部分中的特殊情况,此时,只需要将目标解分别在两部分中的着色方案进行和连接即可,连接后的着色方案规模等于较大的子着色方案规模.公式中的第二部分则将每种分布的两个部分着色方案进行积连接,加入总的着色方案.递归需要终止条件,根据式(1),给出3个简单情况下的处理,其中n表示元素个数,k表示颜色数目.(1)n<k时,(n,k)着色不存在,直接返回空集;Page4(2)当n=k时,每个元素对应一种颜色,返回着色方案{〈1,2,…,n〉}即可;(3)当k=1时,所有元素着同一种颜色,返回着色方案{〈1,1,…,1〉}.每次调用递归算法,元素个数n都将减半,在经过logn层递归调用后,此时n为1,直接返回着色方案.这样,可以在不产生着色方案的情况下,分析分治着色算法产生的着色方案规模.便于后面的分析,首先给出以下引理.引理1.对任意的正整数n2,logn/2=logn-1.证明.(1)当n2且n为偶数时,logn/2=logn-1=logn-1,显然成立.(2)当n2且n为奇数时,logn/2=log(n+1)-1=log(n+1)-1.假设log(n+1)-1=logn-1不成立,即log(n+1)≠logn,则此时必然有n=2k,其中k=1,2,3,…,这与n为奇数矛盾.因此,n为奇数时,log(n+1)-1=logn-1也成立.因此,对任意的正整数n2,logn/2=logn-1成立.定理1.对任意的正整数n和k且nk,分治着色算法产生的着色方案满足|S(n,k)|lognk-1.证明.(1)当k=1时,只需将n个元素着同一种颜色,返回该(n,1)着色构成的集合.此时,|S(n,1)|logn0=1,显然成立.|S(n,2)|=max(|S(n/2,2)|,|S(n/2,2)|+(2)当k=2时,由式(1)有假设|S(n,2)|logn成立,只需证明max(|S(n/2,2)|,|S(n/2,2)|)+1logn也成立.根据引理1有max(log(n/2),log(n/2))+1=log(n/2)+1=(logn-1)+1=logn.由上可知,|S(n,2)|logn成立.(3)假设ki-1时,|S(n,k)|lognk-1均成立,那么,当k=i时,|S(n,i)|=max(|S(n/2,i)|,|S(n/2,i)|)+因此,|S(n,i)|logni-1成立.(4)综上所述,对任意的正整数n和k且nk,分治着色算法产生的着色方案满足|S(n,k)|lognk-1.与Chen等人提出的复杂度为O(6.1kn)的着色方案构造算法相比,不需要n远大于k的限制,即k可以取不大于n的任意正整数.而且上述算法构造简单,易于实现,同时复杂度中没有忽略与n及k相关的多项式系数.当然随着问题规模n的增长,算法复杂度增长很快.下面一节介绍核心化技术,以削弱问题规模n对算法复杂度的影响.2.2核心化简单分治算法对问题规模n的增长过于敏感,从而局限了算法的应用范围.尽管目前基于完全散列函数的着色算法都不尽实用,它们的一个理论基础:小参数理论在降低参数n对复杂度的影响上仍然有很大的作用.应用完全散列函数可以得到的着色方案将满足|S(n,k)|2n|S(k2,k)|.这个结果表明,应用一次完全散列函数就可以从很大程度上降低元素全集规模n增长所带来的不利影响,算法可以专注于解决(k2,k)的着色问题.引理2[3].如果(k2,k)着色问题可以得到一个规模为r的着色方案,那么(n,k)着色问题可以得到一个规模不大于2nr的着色方案.文献[3]通过应用Fredman等人对完全散列函数的研究结果[6]证明了引理2的正确性,同时给出了着色方案的构造方法.设p是满足np<2n的素数,在集合Zp={a|0a<p,a∈Ν}上定义函数族假设S(k2,k)={H1,H2,…,Hr},那么其中Hi·φa是定义为Hi·φa(x)=Hi(φa(x))的函数.由引理2可知,对原问题应用一次核心化预处理,可以大幅降低问题规模n对算法复杂度的影响.应用核心化技术后,算法首先比较n与k2的大小.若n>k2,则由分治着色算法首先构造(k2,k)着色Page5方案,再利用散列函数,映射为(n,k)着色方案;若nk2,则直接利用分治着色算法构造(n,k)着色方案.结合引理2与定理1,得到以下结论.定理2.对任意的正整数n和k且nk,核心化分治着色算法产生的着色方案满足|S(n,k)|2k·logkk-1·n.证明.对任意的正整数n和k,|S(n,k)|表示核心化分治着色算法产生的着色方案规模.(1)当knk2时,由定理1有,|S(n,k)|lognk-12k-1·logkk-1.显然,|S(n,k)|2k·logkk-1·n成立.(2)当n>k2时,结合定理1及引理2,|S(n,k)||S(k2,k)|·2n2k-1·logkk-1·2n.因此,对任意的正整数n和k且nk,|S(n,k)|2k·logkk-1·n均成立.与PH算法相比,核心化分治着色算法产生的着色方案没有O(ck)形式的规模上界,但是PH算法产生的实际着色方案的规模为O(6.1k4logk-1k4logk-1n),O(6.1kn)并不能很好地反映k较小时的实际规模.而上界2k·logkk-1·n不仅没有忽略多项式的系数,甚至没有忽略任何的常系数,因而是相当准确的.2.3HABCC算法对所有的分治算法而言,加快分治的终止速度是改善分治算法性能的关键.简单的分治策略仅仅包含k=1,n=k等几个简单的终止条件,严重影响了分治算法的性能.然而,基于划分的着色算法PBCC[4]的出现从很大程度上改善了这一情况.PBCC算法通过枚举着色块的分布情况,得到了n2k情况下的优化着色方案,具体算法参见文献[4].通过对实际着色规模的分析,文献[4]还指出,在目前计算能力可及并满足n2k的情况下,PBCC算法可以得到比PH算法更小规模的着色方案.下面,我们在分治策略的基础上,结合核心化预处理,并利用PBCC算法处理n2k情况的子问题,提出一种基于混合策略的着色算法(HABCC).由于分治着色算法元素n递归下降的性质,任何(n,k)的着色问题都可以被递归到以下4种情况之一:(1)n<k:返回空集;(2)k=1:直接着色;(3)kn2k:PBCC算法处理;(4)n>2k:n减半,递归调用.算法HABCC中的递归子程序IDCC描述如图1所示.算法IDCC(n,k)Input:Anintegern=|U|,anintegerk=|C|Output:AcoloringschemeS(n,k)1.ifn<kthenreturn;2.ifk=1thenreturn{〈1,1,…1〉};3.ifn2kthenreturnPBCC(n,k);4.S(n,k)=;5.PartitionUinto2parts,|U1|=n1=[n/2],|U2|=n2=[n/2];6.S(n,k)←IDCC(n1,k)IDCC(n2,k);7.fori←1tok-1doS(n,k)←S(n,k)∪(IDCC(n1,i)IDCC(n2,k-i));end8.returnS(n,k);正如2.2节中的介绍,在n>k2情况下,核心化预处理可以大幅降低问题规模n对算法复杂度的影响.在算法HABCC中,若n>k2,则由分治着色算法首先构造(k2,k)着色方案,再利用散列函数,映射为(n,k)着色方案;若nk2,则直接利用分治着色算法构造(n,k)着色方案.算法HABCC的描述如图2所示.Input:Anintegern=|U|,anintegerk=|C|Output:AcoloringschemeS(n,k)1.S(n,k)=;2.ifn>k2then3.else4.returnS(n,k);3HABCC算法分析3.1HABCC算法的正确性分析盖全集U的所有k元素子集.定理3.HABCC算法产生的着色方案能够覆证明.当n>k2时,根据引理2及其相应的着色方案构造算法,只需证明IDCC算法能产生(k2,k)着色方案;当nk2时,需要证明IDCC算法能产生(n,k)着色方案.综上所述,只需证明nk2时,IDCC算法能产生(n,k)着色方案.这样,HABCC算法能构造(n,k)着色方案,从而覆盖全集U的所有k元素子集.在nk2情况下,IDCC算法分情况处理:(1)n<k:返回空集;(2)k=1:所有元素着相同颜色Page6并返回;(3)kn2k:PBCC算法处理,返回(n,k)着色方案;(4)2k<nk2:n减半,枚举k分布情况,递归调用.在情况(1)(2)下,显然IDCC算法可以返回(n,k)着色方案;情况(3)时,根据文献[4]中的理论,同样返回(n,k)着色方案;情况(4)时,依据简单的分治枚举策略,将问题递归到更小的规模.由于递归下降的性质,任何(n,k)的着色问题都可以递归到以上四种情况之一.在不超过2logk层递归调用后,此时n=1,k1,返回着色方案,递归结束.由分治枚举的性质知,在nk2的情况下,IDCC算法都返回(n,k)着色方案.因此,HABCC算法能构造(n,k)着色方案,从而覆盖全集U的所有k元素子集.证毕.3.2HABCC算法产生的着色方案规模分析为了便于与PH算法比较,首先回顾一下文献[3]中的相关内容,分析PH算法的着色方案规模.PH算法产生的着色方案规模依赖于C1~C5的参数组合,分析所需枚举的各个参数的数目,得到以下数据:O(k4);C1.枚举整数对(a,b),需要p2=O(n2)=C2.枚举整数序列C,需要5k/4-1O(1.8692k);C3.枚举r个整数对的序列L,其中rlogk-2,需要p2r=O(4logk-2k4logk-8);C4.枚举C与L间的映射关系,需要2k/2=O(1.4143k);C5.枚举满足条件的子着色方案,需要O(2.4142k).从以上数据可以看出,PH算法的理论复杂度①O(6.1kn)中的6.1k来自于所有的指数因子部分,而其余的部分都作为低阶因子被忽略.从算法理论的渐近上界表示角度考虑,这种做法是允许的.然而,从实际的角度分析,很多因子仍然是必须考虑的.就PH算法而言,综合所有的情况,着色方案规模应为O(6.1k4logk-1k4logk-1n).以n=10000,k=20为例,n=1E4,4logk-1=1E2,k4logk-1=1.55E21,与6.1k=5.09E15相比,显然k4logk-1是不能忽略的.图3展示了随着k值的增长各因子的增长趋势.尽管随着k值的增长,因子6.1k终将取得决定性作用,但从图3可以看出,在整个问题规模增大到无法现实求解之前,因子k4logk-1都仍然有着重大的作用,因而是无法忽略的.只有在同时充分考虑两者的影响时,k4logk-16.1kn才大致反映了PH算法着色方案规模的增长趋势.值得注意的是:在图3的比较中,我们没有考虑相同的核心化预处理过程所产生的影响.从图3可以看出,相同k值情况下,2k-1·logkk-1比6.1k4logk-1k4logk-1小数个数量级,大约仅为6.1k4logk-1k4logk-1的平方根.经过数值计算,只有当k>180时,2k-1·logkk-1才大于6.1k4logk-1k4logk-1,而此时规模已达到10210.因此,在现实可计算的范围内,HABCC算法产生的着色方案规模上界远小于PH算法.有了以上分析后,接下来比较分析HABCC与PH算法产生着色方案的实际规模.首先,根据式(1)以及文献[4]中的式(1),HABCC算法产生的着色方案规模可以在不产生实际着色方案的情况下计算得出.此外,根据文献[3]中的理论,PH算法产生的着色方案也可以通过枚举以下参数组合情况计算得出.具体步骤如下:1.依据C2,用一个长度为5k/4-1且包括正好k/4-1个0的二进制串B,其中第j段正好包含了cj个1,来表示C.按照规则∑k/4-12.依据C5,对符合上面条件的二进制串,计算T=∏j|Fcj|,其中|Fcj|已知②.3.将cj和(ai,bi)之间的映射关系表示为长度为∑jq/2i的二进制串A>1,其中包括正好j个0并且q表示cj>1的数目.因此,第j个01i-1的子串就可以代表cj和(ai,bi)之间的关系.①②Page74.依据C3,对剩余的A>1,计算R=∑A>1(p-1))i,其中p是不小于k2的最小素数,而i为A>1中最长子串01i-1的参数i.被4整除,则H=Q·p,即为着色方案的规模.5.对步1中的所有B计算R,并求和Q=∑B6.若k不能被4整除,计算k=k+4-k%4,根据步1~5计算Q,p是不小于k2的最小素数,则着色方案规模H=k()k·Q·p.这样,PH算法产生的着色方案实际规模也可以在不生成实际方案的情况下计算出来.图4展示了n=10000的情况①下,HABCC算法、PH算法的着色规模以及组合数(COMBIN)Ckn的比较.从图4可以看出,n=10000的情况下,HABCC与PH算法产生的着色方案规模都小于组合数,且随着k值的增长,在可计算的范围内,规模增长趋势也较缓.且由于核心化处理削弱了问题规模对复杂度的影响,因此,n值越大,HABCC与PH算法相对于组合算法的优势更明显.HABCC算法和PH算法采用了相同的核心化预处理,使得着色方案规模只与问题规模成线性关系,因此,HABCC和PH算法的比较与n值无关.从图4还可以看出,在相同k值情况下,HABCC算法产生的实际着色方案规模的数量级大约仅为PH算法的一半.另外,PHBOUND和HABCCBOUND分别表示PH以及HABCC算法产生的着色方案规模上界,从图4中可以看出,两种算法得到的规模上界与实际值都很接近,是很紧的界.一方面说明了定理1、2中关于着色方案规模上界的分析很成功,另一方面也显示了图3中关于两者规模上界的比较是很有意义的.同时发现,当k取5或13时,PH算法产生着色方案的实际规模超过了上界,这是由于理论分析时忽略了向上取整的影响,而实际构造时必须考虑.综上所述,HABCC算法提供了优化的着色方案,其规模不仅远小于组合数目,而且在现实可计算的范围内,比目前最优化的构造算法小数个数量级.4结论彩色编码是解决NP难问题的一种新兴而重要的技术,该技术,特别是其确定化技术,在最近几年的研究中得到了许多有重要意义的改进.目前最好的结果是Chen等人在文献[3]中提出的一种PH算法,其时间复杂度被证明为O(6.1kn).而另一方面,为了使彩色编码技术更加实用化,文献[4]提出了一种基于划分的着色算法,将彩色编码应用在n2k的情况下,弥补了彩色编码在非小参数化中应用的空白.本文以分治算法为基础,结合核心化技术,提出了混合策略构造着色方案的算法HABCC,该算法有机地融合了PH及PBCC算法的优点,同时避免了它们不足.经过理论及实际数据分析,该算法可以得到比现有最好算法更小的着色方案,且易于构造,从而大幅改进了彩色编码的实用性.
