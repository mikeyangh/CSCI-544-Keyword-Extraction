Page1分簇VLIW结构下利用数据依赖图优化调度的研究杨旭何虎孙义和(清华大学微电子研究所北京100084)摘要应用的需求促使如今的处理器必须尽可能高地利用程序中所存在的指令级并行度,然而,高指令级并行的硬件和指令调度技术会给寄存器资源带来极大的压力.要在单一寄存器堆的情况下,既维持高的指令级并行度,又保持高的运行时钟频率是一件非常困难的事情,这是因为,当指令级并行度足够高时,在单一寄存器堆情况下,寄存器堆访问端口数目的限制会使得对寄存器堆的访问时间成为制约性能提高的关键因素.为了在利用高的指令级并行度的同时维持高的运行时钟频率,可以将寄存器堆和功能单元划分到不同的簇中.每一个簇中的功能单元可以直接访问簇内的寄存器堆,而簇间的数据交互则需要占用专用的资源来进行.因此,分簇结构下的编译器不仅要通过调度实现最大程序的指令级并行度,还应该对指令的分簇进行细致的安排以限制簇间的数据交互.该文致力于通过对数据依赖图(DataDependenceGraph)分析和划分,从而在最小化簇间的数据交互的同时,平衡各簇的利用情况,提高能够获得的指令级并行度,从而优化分簇式VLIW结构的调度性能.实验结果证明,该文所提出的方法可以极大地减少簇间的数据交互量,提高所能获得的指令级并行度,从而对调度结果的性能加以改善.关键词分簇;VLIW结构;数据依赖图;指令调度;簇间数据交互1引言为了满足应用的需求,特别是多媒体处理应用的需求,当今的处理器结构需要不断地提升性能.大部分的处理器结构都选取了尽量利用程序中的指令级并行度的办法,来提高处理能力.这些指令级并行的结构,允许在单一周期内执行多个最低层次的诸如内存的读取、定点数加法以及浮点数乘法等机器操作.为了有效地利用并行硬件,编译器必须识别出程序中的并行性.而对于指令级并行结构,为了有效地利用硬件资源,编译器需要对原始的串行指令流进行处理,使得多于一个的低层次操作可以在硬件资源允许的情况下同时执行.这种对机器操作进行处理,以便有效地利用指令级并行结构中的硬件资源的行为就称之为指令调度[1].不幸的是,高指令级并行度的硬件资源和指令调度技术会使机器中的寄存器资源承受极大的压力.要在单一寄存器堆的情况下,既维持高的指令级并行度,又要保持高的时钟运行频率是非常困难的一件事情.这是因为,当指令级并行度足够高时,在单一寄存器堆情况下,寄存器堆访问端口数目的限制会使得对寄存器堆的访问时间成为制约性能提高的关键因素[2-3].面对这个问题,将寄存器和功能单元划分到不同的簇中是一种可行的解决办法[4-5].一个簇中的寄存器可以自由地被簇内的功能单元所访问,而簇与簇之间的数据交互则需要专门的簇间拷贝资源来完成[6].分簇可能会限制调度所能取得的指令级并行度.某条指令原本可能可以被调度到某个周期中,但是假如它所需要的数据不是存放在目前它可以被分配到的功能单元所能够访问的寄存器中,就需要添加额外的操作或者指令来将它所需要的数据移动到它可分配的功能单元所能够访问到的寄存器中,否则该指令就无法执行.所以,编译器的工作不单是要通过调度获取最大程度的并行度,还需要兼顾指令的分簇安排来限制簇间的数据交互量[1].因此,分簇式VLIW结构的编译器不仅需要决定每个操作的执行周期,还需要决定每个操作应该安置在哪个簇中的哪个功能单元上执行.要完成这个任务不是一件简单的事情,因为其中牵涉到两个互相矛盾的目标.为了获取最高的性能要求将操作尽可能均匀地分散到每个功能单元中,即平衡各个簇的利用情况;同时,编译器还必须最小化由于将指令分散到各簇中执行所带来的簇间的数据交互[1].本文中,我们提出了一种方法,利用对数据依赖图(DataDependenceGraph)的分析和划分来平衡簇的利用情况和最小化簇间数据交互,并以此来引导调度的进行,从而提高调度所能得到的指令级并行度.接下来,我们在第2节中对现有的一些针对分簇式结构的调度算法进行分析,找出存在的问题;第3节对利用数据依赖图来最小化簇间数据交互的方法进行详细的介绍;第4节说明如何利用数据依赖图来平衡簇;第5节给出调度算法的流程;在第6节中,给出以一款可扩展的分簇式VLIW结构为目标结构所得出的实验数据;最后是结论部分.2已有分簇式结构调度算法的回顾LC(Limited-Connectivity)调度算法[7]首先假设指令调度是在一个与被调度的分簇式结构具有同等资源的全互连结构下进行,然后再分配到不同簇中需要进行簇间数据交互的指令之间插入簇间拷贝指令,并对每个簇中的指令进行局部的代码压缩.由于在调度的时候完全不考虑指令的分簇情况,调度结构并不理想,相对于全互连结构性能下降量较大[2].BUG(Bottom-Up-Greedy)算法[8]采用递归调度的方法,首先从数据流图的叶子节点开始自底向上的遍历整个数据流图,并根据每个节点之前所分Page3配的操作数和目的数的位置来估算其倾向于被分配的功能单元的集合.当遍历到达根节点后,BUG算法又由顶至下的进行一次遍历,为每个节点分配合适的功能单元[6].然而,因为在进行簇分配时,BUG算法只关心如何使指令尽可能早地执行,具有明显的局部性,限制了调度的效果.PCC(Partial-Component-Clustering)算法通过将原始数据流图中的部分互连的节点组合成为“宏节点”来降低调度的复杂度[9].在簇分配的过程中,组成一个宏节点的所有节点被看作是一个节点,从而被分配到同一个簇中.虽然PCC算法可以通过宏节点来缩小解空间的大小,但在其循环提高过程中,无法准确地找出代价函数迅速下降的方向,因而若宏节点小则计算时间长,若宏节点大则影响调度效果.UAS(Unified-Assign-and-Schedule)算法[10]由两层循环组成.外层循环保证所有的指令最后都能被调度,内层循环将尽可能多的指令安排到当前周期中.UAS算法将簇间的互连总线看作一种资源,并引入多种优先权函数来指导调度和分簇地进行.但是,UAS算法在调度时仅考虑了前驱指令、完成时间以及关键路径等因素,没有考虑到其它未调度指令对当前指令的调度的影响,具有较强的局部性.CARS(CombinedClusterAssignment,RegisterAllocationandInstructionScheduling)算法[17]采用一种类似于列表调度算法的方式.它将整个调度过程分为3个阶段:在第1阶段中,会初始化和建立一些算法所需要的数据结构;主要的工作是在第2阶段中进行,指令分簇、寄存器分配以及指令调度同时得到结果;最后一个阶段会对第2阶段的结果进行一些优化.在第2阶段里,CARS在进行分簇和调度时,只考虑了在目前情况下,最优的簇选择方案,缺乏全局考虑.Intel的巴塞罗那研究中心提出了一种虚拟簇调度算法[16],利用虚拟簇和调度图的概念来引导分簇过程.这种算法将簇分配的决定推迟到调度阶段来进行,但又不采取分离的簇分配和指令调度方式.它引入调度图的概念,来描述所有可能的调度方式.引入虚拟簇的概念来确保在做出单独的簇分配和指令调度的决定的情况下,还可以使得簇分配推迟到调度过程中进行.但是这种方式过于复杂,算法执行时间消耗较多.综上所述,现有的这些针对分簇式系统的调度算法中存在着以下几个问题:性考虑;调度指令的影响;(1)指令调度和分簇时局部性较强,缺乏全局(2)无法在调度时考虑到未调度指令对当前待(3)缺乏对提高指令级并行度与减少簇间数据这也正是本文所提出的方法所要解决的问题,我们将在下面的章节中对此方法作出详细的描述.3利用数据依赖图来最小化交互这两者之间的统合.簇间数据交互一个指令除非是独立的指令,否则必然与其它指令之间存在着数据交互.在调度的过程中,当考虑一个待调度的指令时,与它相关的数据交互可能来自已调度的指令,也可能来自未调度的指令.只有将与这个待调度指令相关的所有数据交互的影响都考虑进来,才能作出最合适的调度安排.现有的调度算法都欠缺对未调度指令的影响的考虑,而通过数据依赖图,我们可以将这些未调度指令的影响也加以度量.在数据依赖图中,每一个节点代表了一个指令操作,而两个节点之间的连线则表示这两个节点之间存在着数据交互.数据依赖图是一个有向图,连线的起始节点代表数据的提供方,而终止节点则是数据的接收方.数据的接收方称为数据的提供方的后续节点,而数据的提供方称为数据的接收方的前驱节点.连线的起始节点和终止节点之间的执行时间之差称为该数据交互的时间跨度.当某条指令被调度时,可以将此时的数据依赖图划分为3个部分,即已调度的数据依赖图部分(简称为图S),未调度的且是当前待调度指令的直接或间接后续节点所组成的数据依赖图部分(简称为图C)以及剩下的未调度指令所组成的数据依赖图部分(简称为图R).需要注意的是,当前待调度的指令也是被划分到图C中的.图1中给出了一个对数据依赖图进行划分的例子,在这个例子里,指令5是当前待调度的指令,而指令0、1、2、3都是已调度的指令.因为图C中的指令都是当前待调度指令的直接或者间接后续指令,即是说当前待调度的指令的调度结果会对图C中的所有指令产生影响,因而如果单纯地只从最小化簇间数据交互的角度来看,可以假定图C中的指令都应该和当前待调度指令具Page4有相同的簇.而图R中的指令都未调度,而且也不会受到当前待调度指令调度结果的影响,所以可以暂不考虑.因此,在考虑当前待调度指令时,最小化调度结果中簇间数据交互的问题就转化为了最小化当前待调度指令的图S与图C之间簇间数据交互的问题.于是,通过对数据依赖图的划分,不仅考虑到了未调度指令对当前待调度指令所造成的影响,而且可以从一个较为全局的角度去指导指令的调度.为了进一步对图S与图C之间的数据交互进行分析,需要为每一个待调度的指令i引入一个引力矩阵犌狉狏狋狀i[Nc],这里Nc代表目标结构中簇的数目.引力矩阵的每一个分量代表了对应簇中由图S到图C的数据交互的量,需要注意的是,这里的量不单是指数量,还需要把数据交互的时间跨度考虑进来,因为不同时间跨度的数据交互对调度结果的影响也不同.从最小化簇间数据交互的出发点来看,待调度的指令都倾向于被调度到具有最大引力分量的簇中.Grvtni[p],它的计算方式如下式所示令待调度指令i的引力矩阵在簇p中的分量为式中e代表所有由图S到图C的数据交互,而Spane则代表数据交互e的时间跨度.式中δe,p当数据交互e的数据提供方调度于簇p时值为1,否则值为0.为了计算数据交互e的时间跨度Spane,需要为每一个指令引入一个参数,称之为指令的高度(Height),它所描述的是每条指令要达到叶子节点指令所要经过的距离的最大值.根据定义,数据依赖图中所有叶子节点指令的高度均为0.而其余指令的高度的计算方式如下式所示式中Hi和Hj分别表示指令i和指令j的高度,而Mi是所有指令i的直接后续指令的集合.式中Max()表示取所有指令j高度的最大值.图2中给出了指令高度计算的一个例子.对于待调度指令i,若有一条从图S中指令k到图C中指令j的数据交互e,则e的时间跨度Spane的计算方式如下式所示式中cyck表示指令k的调度周期,Hi和Hj分别表示指令i和指令j在数据依赖图中的高度,而q则表示当前调度周期.于是在当前调度周期下,若将待调度指令i调度引力矩阵中各分量中引力值最大的分量所对应的簇中,就可以最小化由于指令i的调度所带来的簇间数据交互.4利用数据依赖图来最大化指令级并行度最大化指令级并行度与最小化簇间数据交互是互相矛盾的.最大化指令级并行度要求将指令尽可能平均地压缩到所有簇中,以获得最短的执行时间,但这可能会带来大量的簇间数据交互,即插入大量的簇间拷贝指令,结果导致执行时间大大加长.而最小化簇间数据交互则倾向于将所有指令安排到一个簇中执行,这样会让执行时间拉得很长,所能得到的指令级并行度也将很低.所以在调度时,必须兼顾两者,将两者有机地结合在一起,才能通过折中得到最Page5好的性能.最大化指令级并行度要求把指令尽可能平均地安排到所有簇中,因此也可以等同为平衡各簇的利用率情况.要平衡各簇的利用率,首先要对各簇的利用率情况进行统计,这就需要对数据依赖图进行划分与分析.这里划分数据依赖图的方式与前一节相同,不同的是只需要对图S进行分析,因为只有图S中的指令是已经调度的.为了统计各簇的利用率情况,引入一个斥力矩阵犚狆犾q[Nc].这里Nc表示目标结构中的簇的数目,而q则代表当前调度周期.斥力矩阵的每一个分量表示对应簇的使用情况.令在当前调度周期为q时,斥力矩阵在簇p中的分量为Rplq[p],则它的计算方式如下式所示式中S代表图S中的所有指令组成的集合,θj,p在指令j调度于簇p中时值为1,否则值为0.于是通过对数据依赖图的划分和分析,就可以对当前调度周期下的各簇的利用率情况进行统计.如果单从平衡各簇的利用率(也即是最大化指令级并行度)的角度来看,应该将当前待调度指令分配到斥力矩阵中具有最小分量的对应簇中.5调度流程参数.在图3中我们给出了利用对数据依赖图的划分和分析而对调度进行引导的调度算法的总体流程图.下面介绍其中几个比较重要的环节.(1)调用ASAP和ALAP调度算法计算所需ASAP(AsSoonAsPossible)调度算法为每一条指令所分配的执行周期为该指令最早可执行的周期,而ALAP(AsLateAsPossible)调度算法为每一条指令所分配的执行周期则为该指令最迟可执行的周期.令指令i最早可执行的周期为CEi,其最迟可执行的周期为CLi,则定义指令的机动性Mi为这里一条指令的机动性表征了该指令的调度时间对整体调度执行时间的影响程度.显然,机动性为1的指令,即最早可执行时间和最迟可执行时间相等的指令的调度时间对整体调度执行时间的影响是最大的.(2)根据优先权顺序挑选待调度指令.在调度过程中,所有当前可调度的指令都被包含在一个可调度指令列表之中.为了保证对整体调度执行时间影响最大的指令优先被调度,必须规定一系列的挑选待调度指令的原则,根据这些原则来确定指令之间的优先顺序.在本文所提出的算法里,我们规定了4条挑选待调度指令的原则,下面根据这4条原则的优先级高低顺序分别加以阐述.节中已经给出,这里不再赘述.①机动性为1的指令优先调度.其原因在5.1②最迟可执行时间早的指令优先调度.ALAP调度算法根据数据依赖关系给出每条指令的最迟可执行时间,最迟可执行时间越早的指令说明需要使用它产生的数据的指令的执行时间越早,推迟它的执行将会影响后续指令的执行,从而导致整体调度执行时间延长.③指令高度高的指令优先调度.指令高度的定义在第3节中已经给出,指令高度越高的指令,说明它Page6距离叶子节点的距离越远,也就是说依赖于它的数据,在它之后要执行的指令数越多,因此应该优先调度.④指令规模大的指令优先调度.定义一条指令的规模(Scale)为数据依赖图中其直接或间接后续指令的数目.根据此定义,数据依赖图中的所有叶子节点的规模都为0.在图4中给出了一个例子说明指令规模的计算方法.方案.根据这4条原则,从可调度列表中挑选出指令进行调度,就可以保证对整体调度执行时间影响较大的指令能够优先得以调度.(3)计算引力矩阵和斥力矩阵,决定指令调度在根据优先权顺序挑选出待调度指令之后,就需要计算当前待调度指令的引力矩阵和当前调度周期的斥力矩阵.为了综合考虑引力矩阵与斥力矩阵对当前待调度指令的影响,这里引入一个合力矩阵犉[Nc],Nc代表目标结构中簇的数目.假设当前待调度指令为i,当前调度周期为q,那么引力矩阵和斥力矩阵在簇p中所产生的合力Fi,q[p]的计算方式如下式所示式中c代表目标结构中除簇p以外的所有簇.通过上式就可以在调度时同时考虑到最小化簇间数据交互和最大化指令级并行度,待调度的指令将会被调度到合力矩阵所有分量中具有最小值的分量所对应的簇中.(4)算法复杂度分析.令数据依赖图中的指令个数为|N|,数据依赖图中的边的数目为|E|.对于每一条指令,在计算引力矩阵时,最坏情况下的工作量为O(|E|),而在计算斥力矩阵时,最坏情况下的工作量为O(|N|).因此,算法最多在O(|N|(|N|+|E|))时间内完成.6实验结果为了验证本文所提出的通过对数据依赖图的划分和分析从而最小化簇间数据交互和最大化指令级并行度的方法的有效性,我们以一款可扩展的分簇VLIW结构[11]作为目标结构进行了实验.簇的数目被设置为2簇和4簇,而簇之间的互连则分别采取了总线互连方式与寄存器堆互连方式.每个簇中都有3种类型的功能单元,分别为AL单元、LS单元和MP单元.AL单元可以执行所有的算术操作,LS单元负责执行对内存的存取操作、跳转和数据移动操作以及一些算术操作,而MP单元则负责进行乘法操作[11].实验的输入来自于UTDSP[12]kernel部分的6个测试程序.为了更好地做出比较,这里还同时给出了列表调度和UAS调度的结果.6.1总线互连方式分簇结构的实验结果结构如图5所示,2簇处理器的结构与其类似.本实验所采用的总线互连方式的4簇处理器的如图5中所示,各簇的功能单元可以自由地访问簇内的寄存器堆中的数据,而簇间的数据交互必须经由总线通过专门的功能单元执行簇间数据拷贝指令来完成.在本结构中,使用每个簇的LS单元来执行簇间数据拷贝指令.图6中显示了在2簇总线互连式结构中调度后簇间数据交互量的比较,4簇总线互连式结构中的比较结果见图7.从图中可以看出,通过对数据依赖图的划分和分析,可以成功地引导指令调度最小化簇间数据交互.Page7图62簇总线互连式结构中簇间数据交互量的比较图74簇总线互连式结构中簇间数据交互量的比较在总线互连式分簇结构中,当有簇间数据交互发生时,需要插入簇间数据拷贝指令,通过总线进行数据的挪动,以保证指令的正常执行.因此相比于未调度之前的代码长度,总线互连式结构调度之后的代码长度将会增长.令调度之前的代码长度为NB,调度之后的代码长度为NA,则NB与NA之间的比较可以作为衡量代码长度增加量的一个标准,称其为代码长度增加率CAB,它的计算方式如下式所示代码长度增加率可以作为衡量调度算法效率的一个标准[13-14].显然,对于全互连结构,因为不需要插入簇间拷贝指令,其调度之后的代码长度应该与调度前相等,所以代码长度增加率应该为0.因此,代码长度增加率越小,说明调度算法得出的调度结果的效果越好.表1中给出了在2簇总线互连式结构中代码长度增加率CAB的比较结果,4簇总线互连式结构中的比较见表2.通过比较可见,由于数据依赖图引导的调度算法极大地减少了簇间数据交互,因此相比于列表调度算法与UAS调度算法能够得到一个更小的代码长度增加率.由于相比于全互连结构,总线互连式分簇结构的代码长度增加了,因此执行指令序列所需的时间也会相应的增加.表12簇总线互连式结构中代码长度增加率的比较测试程序名fft57.4041.30fir49.3525.32iir75.6834.89latnrm62.7332.27lmsfir52.7329.09mult46.9729.80平均值57.4832.11表24簇总线互连式结构中代码长度增加率的比较测试程序名fft87.8054.55fir82.4740.26iir93.1248.65latnrm93.1852.27lmsfir75.7646.67mult78.7936.36平均值85.1946.46图8中给出了2簇总线互连式结构下调度后周期数的比较,为了更好地作出比对,同时给出了全互连结构下调度后的周期数.图9中给出了4簇总线互连式结构下的比较结果.图82簇总线互连式结构中调度后执行周期数的比较图94簇总线互连式结构中调度后执行周期数的比较由于代码长度增加率较小,因此数据依赖图引导的调度算法的调度结果相比于全互连结构的调度结果在执行周期数的增加量上也较小.令调度后的执行周期数为L,则通过调度后执行周期数L与调度后代码长度NA的比较就可以得到调度后的指令级并行度,其计算方式如下式所示Page8显然,因为全互连结构的调度后代码长度短于总线互连方式分簇结构的代码长度,而且全互连结构的调度后执行周期数也少于总线互连式分簇结构,所以全互连结构的指令级并行度必然是最高的.表3和表4分别给出了2簇与4簇总线互连式结构下调度后指令级并行度的比较,表中ILP数值的单位为指令数/周期.测试程序名fft3.053.324.394.64fir2.913.063.563.85iir3.083.814.084.47latnrm2.843.424.314.40lmsfir2.803.043.313.75mult3.033.383.894.40平均值2.953.343.924.25测试程序名fft5.245.896.699.17fir4.685.846.357.33iir5.316.657.828.85latnrm4.835.788.468.80lmsfir5.095.636.217.50mult5.136.146.348.25平均值5.055.996.988.32从比较可以看出,通过对数据依赖图的划分和分析,可以引导指令调度最大化可取得的指令级并行度.令全互连结构的调度后执行周期数为LF,总线互连式分簇结构的调度后执行周期数为LC,则LF与LC的比值可以做为两种结构性能之间的一个比较,称为总线式分簇结构相对于全互连结构的性能比RCF,其计算方式如下式所示RCF可以作为衡量分簇式结构调度算法效果的一个标准[13-14].显然,RCF越大,说明分簇式结构调度后的性能相比于全互连结构的性能下降的比率越小,调度算法的效率越高.表5中显示了在2簇总线互连式结构中性能比比较的结果,4簇总线互连式结构的比较结构如表6中所示.表52簇总线式互连结构中调度后性能比的比较测试程序名fft41.7150.61fir50.6363.49iir39.2263.19latnrm39.6858.82lmsfir48.8962.86mult46.8859.21平均值44.5059.70表64簇总线式互连结构中调度后性能比的比较测试程序名fft30.4341.58fir35.0056.76iir31.0850.55latnrm28.4143.10lmsfir38.6051.16mult34.7854.55平均值33.0549.62通过对数据依赖图的划分和分析,可以使得调度结果中所能取得的指令级并行度最大化,因而其调度结果相对于全互连结构的性能比最大.6.2寄存器堆互连方式分簇结构的实验结果寄存器堆互连式分簇结构中簇间的互连是通过一个全局寄存器堆来实现的[15].在图10中给出了4簇寄存器堆互连结构的结构图,2簇寄存器堆互连结构的结构图与其类似.如图10所示,寄存器堆互连方式分簇结构中各簇内部的局部寄存器堆可以被本簇的功能单元自由访问,而全局寄存器堆则可以被任何簇中的功能单元所访问,因此全局寄存器可以作为簇间数据交互的渠道.与总线互连方式分簇结构不同的是,在处理簇间数据交互时,寄存器堆互连方式分簇结构不需要增加额外的簇间数据拷贝指令,当需要进行簇间数据交互时,只需把要交互的数据直接存放在全局寄Page9存器堆中,需要数据的功能单元可以直接从全局寄存器堆中读取该数据,因此由于簇间拷贝指令的插入所导致的调度执行时间的增加也就可以避免.但是,如同在总线互连方式分簇结构中,可以用于执行簇间数据拷贝指令的功能单元的数目会制约簇间数据交互,在寄存器堆互连方式分簇结构中,对全局寄存器堆的访问端口的数目也会制约簇间数据交互的实现.实验中所用到的结构里,每个簇访问全局寄存器的端口有两个读端口,一个写端口.当在一个周期里,某个簇中对全局寄存器的访问次数超过了端口数目时,就会发生全局寄存器访问冲突.全局寄存器访问冲突会导致某些指令的执行必须推迟,从而导致调度后整体执行时间的延长.因为实验中所用到的总线互连式分簇结构与寄存器堆互连式分簇结构中的资源的数目是相同的,因此调度后簇间数据交互的量是相同的,这里就不再重复给出.而由于在寄存器堆互连方式分簇结构中,簇间数据交互不需要通过额外的簇间拷贝指令来完成,因此调度后的代码长度也就不会增加.但由于全局寄存器访问冲突的存在,全局寄存器堆互连方式分簇结构调度后的执行周期相比于全互连结构还是会有所增加.图11和图12分别示出了在2簇和4簇寄存器堆互连方式结构中相比于全互连结构,调度后执行周期的增加情况.图112簇寄存器堆互连方式结构中调度后可以看出由于对数据依赖图的划分和分析,减少了调度结果中簇间数据交互量,从而减少了对全局寄存器堆的访问量,因此能够有助于减少全局寄存器访问冲突出现的次数,最终导致调度后整体执行周期数的减少.这里同样可以通过计算调度后代码长度与调度后执行周期数的比值得到调度后指令级并行度的数值.表7中给出了2簇寄存器堆互连方式结构中调度后指令级并行度的比较结果,4簇寄存器堆互连方式结构的比较结构如表8中所示.表72簇寄存器堆互连方式结构中调度结果中测试程序名fft3.033.674.644.64fir3.143.503.673.85iir2.623.994.474.47latnrm2.723.934.404.40lmsfir2.953.593.593.75mult3.253.964.134.40平均值2.953.774.154.25表84簇寄存器堆互连方式结构中调度结果中测试程序名fft4.876.118.199.17fir4.165.927.007.33iir4.526.077.688.85latnrm4.405.958.158.80lmsfir4.466.116.887.50mult4.607.337.928.25平均值4.506.257.648.32可以看出,由于在对数据依赖图进行划分和分析后,所引导出的调度结果具有较短的整体指令执行周期,因而能够获得最大化的指令级并行度.表9和表10中分别给出了在2簇和4簇寄存器堆互连方式结构中相比于全互连结构调度结果性能比RCF的比较结果.可见,数据依赖图所引导的调度算法能够得到更好的性能比.表92簇寄存器堆互连方式结构中调度后性能比的比较测试程序名fft65.3579.05100fir81.6390.91iir59.0989.22100latnrm61.7389.29100lmsfir78.5795.65mult73.7793.75平均值70.0289.65Page10表104簇寄存器堆互连方式结构中调度后性能比的比较测试程序名fft53.1666.67fir56.7680.77iir51.1168.66latnrm50.0067.57lmsfir59.4681.48mult55.8188.89平均值/%54.3875.677结论本文中提出了一种通过对数据依赖图的划分和分析,在最大化指令级并行度的同时最小化簇间数据交互量的方法.通过在总线互连方式分簇结构和寄存器堆互连方式分簇结构中的实验表明,利用该方法引导调度过程进行,将可以减少指令调度结果中的簇间数据交互,减少由于簇间数据交互所带来的代码膨胀量,并提高调度结果可获得的指令级并行度,从而缩短整体调度所需执行时间,提高与全互连结构调度结果相比的性能比.利用对数据依赖图的划分和分析,可以从更为全局的角度去把握调度的进行,并且可以将未调度指令对当前调度指令的影响涵盖进来,同时把最小化簇间数据交互和最大化指令级并行度两者结合在一起,从而提高调度结果的性能.本文所提出的方法在运行时其最坏情况算法复杂度为O(n2)量级,这里n代表指令个数.文献[9]中指出列表调度算法的最坏情况运算复杂度为O(n2logn)量级,因此本算法的运算复杂度与列表调度算法的复杂度相当.
