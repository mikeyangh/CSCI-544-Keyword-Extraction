Page1基于GCL语言的测试用例生成方法丁佐华1)JeffSanders2)江明月1)张娜1)蒲戈光3)1)(浙江理工大学智能计算与软件工程实验室杭州310018)2)(联合国大学国际软件技术研究所P.O.Box3058澳门)3)(华东师范大学软件学院上海200062)摘要提出一种基于GCL语言生成程序测试用例的形式化方法.程序的语义为测试用例的生成提供了基本框架,而由Hoare等人提供的规则保证了用例的正确性.作者的这种方法可被认为是一种严格的,自动生成测试用例的方法.这种方法的优点在于:所获得的测试用例都是可行的,在测试用例生成过程中可以避免状态爆炸问题,而且该方法可以延拓到任何目标语言.据此开发了一个基于Haskell语言的原型工具来支持作者的方法.关键词测试用例;Guarded-Command-Language;执行树;条件计算;软件测试1引言软件测试是一种检查软件系统实现正确性的可操作的方法.测试通常分为两个阶段:生成测试用例和运行测试用例.本文主要讨论生成测试用例.目前有很多种生成测试用例的方法和和技巧.例如,基于控制流图[1]、基于模型检测[2]、基于符号化执行[3]、基于可达图[4]、基于状态变迁系统[5]等.如果根据具体的应用程序产生测试用例,我们常常会碰到一些困难.如:在处理动态数据结构、数组及过程时常需要复杂的代数操作;对于己被选择的路径,不易找到使得这条路径被遍历的输入数据.因此当这类方法用于为大型、复杂的软件系统生成Page2测试用例时会显示出不足.通常的解决办法是:对具体的应用程序建立相应的高层模型,然后再根据高层模型生成测试用例.但这种方式也存在一些问题.比较常见的是以下两个问题:(1)所获得的测试用例可能是不可行(infeasible)的,即所生成的测试用例在测试过程中无法正常执行和完成[6-7].其原因在很大程度上是由于产生测试用例的高层模型缺少语义,例如基于有向图路径模型生成测试用例方法;(2)状态爆炸问题,即为了获得测试用例,遍历程序状态空间中所有的状态,而这些状态会随着程序中任务个数增长呈指数增长.如基于模型检查方法生成测试用例,模型检测工具为了找到违反相关属性的路径,将会穷尽搜索系统的状态空间[2].即便在忽略数据的情况下,系统的状态空间还是会随着任务个数的增长呈指数增长.本文提出一种新的生成测试用例的方法以试图避免上述问题.首先我们用一种符号语言来表示程序,该语言扩展了由Dijkstra[8]所提出的GCL(Guarded-Command-Language)语言,对应的规则(law)来自于Hoare[9].这种语言被认为是对实际程序的一种抽象.生成用例的过程大致描述如下:第1步:通过静态检查GCL,构造程序的执行树,然后对执行树中结点的条件进行处理(使得一个结点的条件为从根结点至这个结点上所有结点条件的聚合),并且去掉条件中值为假的布尔型的结点及其子树(条件为假的结点以及它的子树,不能生成测试用例),这样可以保证修改后得到的树中所有路径都是可行的.第2步:基于修改过的执行树生成测试序列集.本文中一个测试序列是由一条路径上的输入、输出结点组成.本文的方法有如下特点:(1)由于用例的生成过程是基于程序语义的,故所生成的测试用例都是可行的;(2)Hoare法则保证了用例的正确性,即用例符合程序执行的动态情况,是正确的测试用例;(3)对算法复杂度的分析表明这种方法不会导致状态爆炸问题;(4)通过写出一个前端,我们的方法可以延拓到任何目标语言.本文第2节通过定义语法规则,将过程式程序转换为GCL符号化表示形式,并给出程序执行所满足的规则;第3节描述程序生成测试用例集的方法:包括构造程序的可执行树、去除不可行路径、生成测试序列、获得最终的测试用例集等;第4节介绍我们开发的生成测试用例的模型工具;第5节是一个实验,对一个具体的应用程序生成测试用例;第6节讨论了相关工作;第7节对本文工作进行总结,并探讨下一步研究方向.2过程式程序(ProceduralProgram)在这一部分,我们将?用一种简单但表示性强的符号语言(即具有规则的语言)来描述过程反应式程序(ProceduralReactivePrograms).这种符号语言扩展了Dijkstra[8]所提出的GCL(Guarded-CommandLanguage)语言,语言的规则由Hoare[9]提供.2.1语法本文中所提到的程序指的是过程反应式程序,即在程序执行过程中会涉及到输入操作的程序.一个过程反应式程序最终执行状态为终止状态.为了用符号语言来描述过程反应式程序,定义以下语法.prog∷=skip(没有任何影响的活动)其中,e代表一个表达式,c表示一个条件,且前面5项称为原子程序(atomicprogram),p是5类原子程序中的一种.一个程序通常由以下部分组成:无操作活动skip,失败活动abort,赋值语句x··=e,输入语句?x,输出语句!e,顺序组合,由状态空间中断言的值决定的两个程序间的二元选择,由状态空间断言控制的循环.上述所有程序的状态空间用(X)来表示,并且声明x:x表示一个值为类型X的变量.通常,局部变量在本地程序块中被声明.程序的输入和输出,通常被隐含的表示为赋值给一个全局变量或者从一个全局变量中取一个值,但在本文中,必须显式的表示出程序的输入与输出,因为我们针对的是反应式的程序,程序的任何反应都需要被描述.我们将通过使用一组全局变量来达到这个目的,这一点将在后面阐述.为了简单起见,假定输入和输出的数据类型均为X.同时,为了避免这个假设造成对程序的约束,我们仅仅允许x的某些部分可以通过输入语句进行输入,并且如果输出的类型不是x的某一部分,需要将相应的类型转换为类型X(注:由于本文是基于对条件的演算来生成Page3测试用例,所以如果输入数据是多个类型,本文的算法同样适用.与单个类型不同处在于对多维输入域的划分.输出数据的类型可以与输入类型不同,但不会影响到测试用例的生成).假定在必要的时候可以复制变量,且不存在值-结果型参数(value-resultparameter).定义g(g:seqX)与h(h:seqX)为两个X类型的序列.则每一个输入?x被当作是一个值参数(valueparameter),它来自于序列g.每一个输出被当作是一个结果参数(resultparameter),它将被指派到序列h的头部.在任何情况下,无论序列g与h被操作多少次,我们假定g只被读取,而h只被写入.则从g中取出一个输入x,这个过程可通过式(1)中的多个赋值来实现.式(1)利用序列处理函数head与tail来描述取值的过程.通过式(1)可以看出检验g是否为空是很有必要的.可以通过使用一个输入守卫来检查g是否为空.类似的,将表达式e:X输出至h被定义为将e添加到序列h的头部,如式(2)所示.条件c与表示式e依照常用的方式定义,我们将在3.1节给出具体的说明.2.2运行规则序运行所满足的规则.为了说明测试用例的预期效果,我们定义了程序列化操作与skip和abort遵循的规则如下:P;(Q;R)=(P;Q);R对于非反应式的序列化程序,规则P;abort=abort成立.由于我们针对的是反应式的程序,若P中包含输出语句,则序列变量h将被改变,所以这条规则对于反应式程序不一定成立.二元选择遵守下列规则(b,c表示条件变量或条件表达式):PiftrueelseQ=PPifcelseQ=QifcelsePPifcelseP=P(PifbelseQ)ifcelseR=Pifb∧celse(QifcelseR)(10)Pifbelse(QifcelseR)=(PifbelseQ)ifcelse(PifbelseR)(11)顺序组合与赋值存在如下关系(e,f表示表达式):x··=x=skipx··=e=(x··=e)if(e)elseabort(13)/(e)代表定义e所需的条件,即e成立的条件/(x··=e);(x··=f)=x··=fe(x··=e)ifcelse(x··=f)=x··=(eifcelsef)(PifcelseQ);R=(P;R)ifcelse(Q;R)(16)x··=e;(PifcelseQ)=(x··=e);Pifceelse(x··=e);Q(17)与规则(14)相反的是,全局输入变量g的值并没有被局部变量的改变所影响,故输入的数据覆盖了原本的值:一个循环可通过普通递归的方式来定义为whilecdoP=μX·((P;X)ifcelseskip)从上式可以推导出:如果循环执行了至多一次,则上式等同于一个二元选择,即一个循环与它的一个单步执行之间是有区别的.如在程序n··=0;whilen<8do(n··=n+1)ifn4else(n··=n+2)ifeven(n)else(n··=n+1)中,n的奇偶性在单步执行中是不能被测试到的:故将式(18)简化为式(19)的代价是,测试不能覆盖所有的条件.由于这个原因,我们允许测试者将循环展开到任意的深度,以便满足需要.3生成测试用例为了基于程序生成测试用例,我们在程序的符号化表示的基础上,生成程序所对应的可执行树,然后基于程序的可执行树生成测试用例.生成测试用例的覆盖准则为:所有的条件至少被执行一次.3.1条件、表达式、域条件语句与表达式的定义与普通程序语言所规定的一样.条件语句一般出现在二元选择与循环中,表达式可位于赋值语句,输入输出语句中.条件语句的类型是布尔型(表示非操作,∧表示与操作,∨表示或操作),而表达式包含同种类型数据的算术操作.假定条件语句可以定义在任何地方,而表达式却Page4不一样.下面,我们引进一个表达式的域的概念.首先,我们用BB··=ff|tt(tt代表true,ff代表false)来表示布尔类型.定义1.条件.一个条件(或断言)指一个具有布尔类型返回值的函数.所有类型为X的条件的状态空间被定义为将X映射到BB的函数(X)=X→BB.例如,对于f,g:(X),f与g的与操作f∧g定义为(f∧g)(t)=f(t)∧g(t).类型为X的表达式的定义也与普通程序语言中的定义相同.我们使用ε(X)表示类型为X的表达式的种类,表达式的操作取决于类型X.例如,如果X是数值类型,则表达式包含常用的算术操作:加(二元)和自减1(一元);如果X是序列类型,则表达式包含序列操作:如,连接(二元),取序列头部(一元)操作等等.定义2.域.犇(e)表示表达式e的域,它是一个条件,它只对那些使e被良定义了的值才成立.比如说,如果表达式是自然数类型,式m-n当且仅当mn时才可以被定义;如果表达式是序列类型,式tailxs只有序列xs不空(xs≠[])时才可以被定义.因此,犇(e)的类型由e的操作元素a决定.犇(e):(Xa)犇(e)(t1,…,ta)=(e(t1,…,ta).对于一个复杂的表达式,要通过表达式的组成部分来评价这个表达式的域,完全取决于表达式的类型.例如,对于布尔类型,函数犇不是一个简单的映射.比如形如犇(b∨c)=犇(b)∨犇(c)的规则太弱,而形如犇(b∨c)=犇(b)∧犇(c)的规则太强,我们希望的是可以应用到布尔型的子表达式上的规则.因此,对于布尔型的表达式b,c,d及条件p,犇(b∧c)=犇(b)∧犇(c)犇(b∨c)=(b∧犇(b))∨(c∧犇(c))犇(bifcelsed)=犇(c)∧(犇(b)ifcelse犇(d))犇(c)=犇(c)犇(p)=tt例如,犇((x-3:NN)if(x>4)else(x-2:NN))=犇(x>4)∧(犇(x-3:NN)ifx>4else犇(x-2:NN))=tt∧((x>4∧x-30)∨(x4∧x-20))=(x>4)∨(2x4)=2x一个表达式的域最终取决于它的类型.由于这一点很重要,我们用来表示表达式成立的条件,并将表达式及其类型作为的下标.比如说,对于自然数类型NN,如果表达式n-1被定义,则n必须大于等于1,即NN(n-1)=n1.然而,若上述表达式的类型是整数Ζ,则ZZ(n-1)=true.3.2结点(Node)我们使用执行树(ExecutionTree)来表示每一个程序,每一棵执行树的形状与程序的语法相关,并且树中的结点所记录的信息包括当前语句与在循环及选择情况下所伴随的条件的结合,以及在赋值、输入、输出情况下这个伴随条件表达式的域,这些信息将用于测试.定义3.结点.一个结点由一个标记(label)和一个条件组成.标记(label)通常是对结点本身的一个说明,但是顺序组合的情况除外,因为顺序组合被禁止反复执行(同样的,循环whilecdoP被替代为它的第一次执行的情况).其中,in、out用来标识输入、输出结点,ass代表赋值结点,ch表示选择控制结点.条件包含两种,一种是表达式定义所需满足的条件,另一种是二元分支选择的控制谓词.故结点的定义可被描述为3.3执行树(ExecutionTree)我们将一个程序表示为一棵执行树,假定树中结点的类型为N=Nodes,则树含有以下几种类型.N∷=leafN|linkN(N)|forkN(N)(N)(1)仅含有一个叶子结点的树(leafN);(2)含有一个根结点,及根结点的子树(子树可能为(1)、(2)、(3)中的任一类型)的树(linkN(N));(3)含有一个分支控制结点,及其子树的树(forkN(N)(N)).为了表示的方便性,我们使用(X)来表示Node.不难发现,一棵树的形状取决于每一个非叶子结点是fork(二元)还是link(一元).为了将一个程序转换成相应的可执行树的,我们定义了相应的转换规则.首先对于原子程序,它们将被转换成树中相应Page5类型的结点,转换规则如式(20)所示.从式(20)可以看出,每一个原子程序都被转换成一个结点(即只包含一个结点的树),结点标识即为对应的语句类型,如skip,abort,ass等,而结点的条件即为表达式成立的条件.对于更普遍的情况:假定α是一个原子程序,P、Q分别是两段程序,且c是X上的一个条件,转换规则如式(21)所示.tr:(X)→(X)烄tr(α)=leafn(α)/一个原子程序被转换成一个叶子结点,即只含一个结点的树/tr(α;P)=linkn(α)tr(P)/linkn(α)为一个连接结点,tr(P)是此结点的烅子树/tr(PifcelseQ)=fork(ch,c)tr(P)tr(Q)/fork(ch,c)是一个分支控制结点,tr(P),tr(Q)为它的两棵子树/tr(whilecdoP)=linkn(pl)tr(Pifcelseskip)/循环的表示,pl为程序段P中最后一条语句烆一个程序的执行树是由程序语法(而不是基于/函数td的输出为一棵树,输出为修改后的树,C(n)表示结点n上的条件//含有一个根结点n,及其子结点(n)的树,经过修改,C(n)=C(n)∧C(n)//树的根结点为n,且n的子树的根结点为n,经修改后,C(n)=C(n)∧C(n)//树的根结点为n,且n的子树的根结点是一个分支控制结点(n),修改后,/树的根结点为分支控制结点(n),设其子树的根结点分别为n1,n2,则修改后,其中,/tdd的输入为一个结点和一棵树,输出为修改后的树/tdd((ch,c)(fork(m,d)T0T1))=td(fork(m,c∧d)T0T1(2)我们将进一步修改函数td,计算出每个结点的条件,并去除根结点带有条件ff的子树(注:程序语义)来定义的.故tr(skip;P)≠tr(P)(tr为程序转换为执行树的规则,见式(21)),因为tr(skip;P)中包含一条额外的边.3.4修改程序的可执行树基于一棵执行树生成测试用例时,是通过在输出结点处得到树中从输入到输出这条路径上所有域及条件的聚合(一个布尔表达式).在使用这种方法时,从未被执行的路径(比如,由于路径上条件的不一致,或者条件与路径上的某个域的不一致所导致的路径无法被执行)将被忽略.为了去掉执行树中从不被执行的路径,我们?用下述方法.(1)定义函数td.函数td的作用是修改一棵树以使得其具有如下属性:每一个结点包含的条件的强度高于或等于处于此结点上层的结点条件的强度.为了实现这个功能,td只是简单的将支路上的域和条件联合起来并顺着支路传递下去,对于支路上的fork结点,结点上的条件或条件的否定形式(适合于当前支路的一种)将被联合起来.故通过递归的定义可以匹配路径上的一连串的结点.这里通过使用另一个函数tdd来实现相互递归定义,这样可以避免不同情况的重复.如式(22)所示.基于一棵执行树生成测试用例,是基于输出结点处得到的从输入到输出这条路径上所有域及条件的聚Page6合:一个布尔型表达式.当结点上条件表达式值为真时,包含此结点从输入至输出的路径上所有条件的聚合才有可能为真,从而可以选择满足此聚合条件的测试用例.如果一个结点的条件为假,包含此结点的任意一条路径的条件聚合必定为假,即不能找到满足条件的测试用例.例如,结点中包含x<3x>4,我们找不到使得此条件为真的x,因此该条件所对应的测试用例集为空.在生成测试用例时,条件为假的结点以及它的子树,不能生成测试用例,故可以删去).过程描述为通过定义函数td,将一个程序转换成一棵树的经过上述处理后,最后获得的执行树中的所有路径都是可行的.3.5对循环的处理在不同的情况下,需要将循环展开到不同的深度.为了使测试者将循环展开到任意的深度,以便满足各种不同的需要,我们定义了函数trn.根据用户需要的循环展开深度,函数trn为程序生成执行树,它的输入是一个数n(循环的展开深度)和一个程序P,输出是程序的执行树(程序P中的所有循环都展开至n次).Trn的定义如式(25)所示.trn:N→(X)→(X)烄trn0(whilecdoP)=skiptrn(n+1)(whilecdoP)=(Pifcelseskip);烅烆trnnP=trP3.6测试用例既然我们己经为一个程序生成了一棵执行树,一个测试序列(测试用例)可以被定义为由执行树中一条路径上的输入和输出组成.一个输出可能依赖于它前面的某个输入,但是想要确定是哪一个是很困难的,因此在此输出前面的所有输入都将被记录下来.值得注意的是,输入与输出有可能是交叉的,甚至会出现在一个输入后面没有任何输出的情况(这是一种异常情况,但是我们不想对程序有更多的约束,特别是从式(19)的角度).每一个输出取决于从树根开始的一条唯一的路径,并且依赖于一组被定义好顺序的输入.就同在前面几部分所预期的一样,我们只考虑实际上可以执行的路径.换句话说,对于程序P,我们只考虑执行树t(P)中的路径.例:状态空间X=N,程序如下所示?x;(x··=x-3)ifodd(x)else(x··=x-2);!(x+1)上述程序有两个测试用例,每一个分别对应二元选择中的一条分支.在if对应的分支中,条件是odd(x)以及定义语句x··=x-3所需要的x3.而在else对应的分支中,条件是even(x),以及定义语句x··=x-2所需要的x2.测试用例包含从输出至输出路径上的所有输入、输出结点,如下所示:这里我们不关心测试用例生成的顺序,而只考虑这两个用例是用例集的两个成员.为了基于执行树生成测试用例,我们定义了一个函数testd,它将基于一棵执行树生成一个测试用例的集合(即路径的集合,在实现中是一个序列,并且序列的连接操作将替代合并操作).主要思想如下:的结点.即我们只考虑标记为in或者out,且条件不为假对于一棵叶子树(leaftree),如果它满足条件(26),则这个结点将被当作一个单独的序列返回,且测试集中只包含这一个序列;否则,测试集中只包含所返回的空序列.对于一棵没有分支的树(linktree),如果它满足条件(26),则从树根至输出结点这条路径上的所有结点所组成的序列将会被返回;否则,对除根结点外的子树的递归调用的集合将会被返回.对于一棵分叉树(forktree),如果它满足条件(26),由树中每一条路径上的结点所组成的序列都会被返回;否则,对其中所有子树的递归调用的集合将被返回.为了方便描述,使用map(n:)表示一个序列的集合,且每个序列都被加上前缀n.则有map(0:){[1,2],[],[0]}={[0,1,2],[0],[0,0]}这样,testd可以被描述为式(27).testd:(X)→PP(seqNode)烄testd(leafn)={[n]}ifcondition(26)else{[]}testd(linknT)=map(n:)(testdT)烅testd(forknT0T1)=(map(n:)(testdT0))∪(map(n:)(testdT1))ifcondition(26)else(testdT0)∪(testdT1烆Page7因为我们没有考虑测试序列生成的顺序,故函数的执行结果为一个测试序列的集合,且每一个测试序列中可能含有多个输入和输出.如果想要基于执行树所生成的测试用例集,进一步生成包含单输出的测试用例,对于这种情况,每一条包含多个输出的路径将生成多个单输出的测试用例,并且如果两种测试用例同时生成,将会提高效率.假设所有的输出都将被测试,并且有多种测试方法,那么可以进行一些选择.例如,可以基于优先权进行选择,设定优先权为覆盖所有的条件.所有上述的特殊情况,都可以从前面所给的定义中得到.测试用例生成过程的特点如下:首先,测试用例是由可行的执行路径(由条件不为假的输入、输出结点构成)产生;其次,在单条路径里没有分支,但是所有的执行路径覆盖了程序的所有分支结构;再次,原型工具最终输出的测试用例是用结点上的条件的聚合来表示的.3.7测试用例的正确性分析正确的测试用例,即满足程序语义的,能够反应程序的真实执行情况的测试用例.本文以Hoare规则为基础生成测试用例,故所生成测试用例都是正确的.Hoare规则在文中用在以下几个方面:(1)建立程序的符号化表示.基于Hoare规则获得程序的符号表示使得程序的语义信息被保留,所获得的GCL程序可以完整的描述源程序的执行特性.(2)构建程序的执行树.执行树的构建基于GCL程序的语法,因此执行树反映了程序的结构信息;同时,执行树的构建依照Hoare所提供的GCL运行规则,从而执行树中隐含了程序的执行语义.(3)结点的条件计算.结点条件的计算过程符合Hoare所提供的规则,经过处理后的结点条件,即为该结点所对应程序语句能被执行的条件.综上所述,本文方法所生成的测试用例,符合程序执行的动态情况,是正确的测试用例.3.8算法复杂度描述为对于一个程序,为其生成测试用例的过程可以假定程序中有n个条件(其中,n1个分支控制条件,n2个循环控制条件),s条语句,则可以通过以下方法来分析算法复杂度(时间复杂度).(1)函数tr对于函数tr,其算法复杂度只与执行树的结点个数有关系,故循环的嵌套或者展开深度不会影响tr的复杂度,同样,分支的嵌套也不会影响tr的复杂度.故函数tr的复杂度为O(n+s).(2)函数tdtd包含两部分工作:一是依据规则修改每个结点的条件;二是计算每个结点的条件,并去除树中根结点含有条件ff的子树(标记为不可执行).对于前者,时间复杂度为O(s+n).对于后者,由文献[10]可知,对于一个包含n个条件的集合,如果其中有k对条件不相容,则需要O(nlogn+k)的时间去找到这些不相容的条件.嵌套循环或分支对函数td的算法复杂度没有影响.函数td的复杂度为O(s+n)+O(nlogn+k).(3)函数testd利用td,我们对树中结点的条件进行演算,去掉条件为假的结点以及其子树,故在生成测试用例时所用到的执行树的规模已经减小,从而算法的复杂度也会降低.假定td所删去的结点数为x,其中分支条件结点为x1个,循环条件结点为x2个.因此在生成执行路径时,所使用的执行树中含有(n+s-x)个结点,其中分支条件结点为(n1-x1)个,循环条件结点为(n2-x2)个.在生成可执行的执行路径时,路径的数目与条件结点的个数以及位置有关系.对于(n1-x1)个分支条件结点,最多可生成2n1-x1条路径,复杂度为O(2n1-x1).对于(n2-x2)个循环条件结点,若把循环当作一个分支结构来处理,则最坏的复杂度为O(2n2-x2);若考虑循环的展开深度,假定每个循环的展开深度为y,则复杂度最大为O(2y(n2-x2)).综上所述,函数testd最大的时间复杂度为O(2n2-x1)+O(2y(n2-x2)).文献[1]中生成所有测试路径算法的时间为O(|E||UE|2),其中E是ddgraph中边的条数,|UE|是不受约束边的总数.如果程序中所有的条件都是分开的,并且n的值很大时,O(|UE|)接近于O(n).故文献[1]中的复杂度近似于O(n3).但文献[1]中没有考虑循环和分支嵌套的情况.若在同样的条件下与之相比,本文所提出的方法的算法复杂度要小得多.注:需要对上述的算法复杂度作几点说明:(1)尽Page8管从表达式看算法复杂度是指数增长的形式,但是我们可以根据软件需求和具体程序控制循环的展开深度;(2)实验结果说明此方法的效果良好;(3)如果进一步考虑循环不变量(loopinvariant)[11],则循环的深度对算法复杂度的影响不会很大.4原型工具我们用Haskell语言开发了一个模型工具.Haskell①是一个高层应用语言.它提供了很好的抽象机制、复杂的类型系统、高层计算语言及高层合作.我们对以上描述的算法经过简单的修改,然后结合输入输出的处理,就可以成为一个可以执行的Haskell程序.输入规则如下:(1)赋值语句用assign表示,如i=1表示为as-(2)输入用input表示,如c=getchar()表示为(3)分支语句用if表示,如if(cond)s1;elsesign“i”(Equ1).input“c”.s2;表示为ifconds1s2.(4)循环语句用while表示,如while(cond)s;表示为whileconds.模型工具的输入语言是GCL.如果我们选择C语言作为目标语言,那么我们需要把C语言描述的程序转换为由GCL语言描述的程序.这里我们不给出详细的转化细节,只给出几个注意点:注意点1.在控制条件中包含输入操作,即转换成我们的基于序列化程序的符号语言为注意点2.如果程序是反应式的,那么一个新的输入值可能是不可用的,故转换后的代码还要使用一个布尔型表达式g?来测试从g中获得的输入是否是有可用的.添加了对输入值的判断后的程序为显然,如果输入一直是可用的(g?一直为真),则上面两个程序是相符的(变量d是局部的).注意点3.C语言中另一种表示循环的方式是使用for循环,如下所示它可以被翻译成如下形式我们?用计算器程序中的一个函数getop[12]作为我们的实例来生成测试用例.函数getop的作用是为后面的计算器程序取得算子与操作数.函数等待输入数据,一旦接收到数据,便开始执行.由于getop函数具有丰富的控制结构,它适合于用来作为测试或者路径选择的实例,而且己经被作为实例来说明相似的问题[1].getop函数的C语言代码如图1所示.getop函数的C语言代码:1.getop(s,lim){/getnextoperatororoperand/2./wewillstartfromhere/3.inti(=0),c(=0);4.while((c=getchar())==’’‖c==’\t’‖c==’\n’);5.if(c!=’.’&&(c<’0’‖c>’9’))6.return(c);7.s[0]=c;8.for(i=1;(c=getchar())>=’0’&&c<=’9’;i++){9.if(i<lim)10.s[i]=c;11.}12.if(c==’.’)/collectfraction/{13.if(i<lim)14.s[i]=c;15.for(i++;c=getchar())>=’0’&&c<=’9’;i++){16.if(i<lim)17.s[i]=c;18.}19.}20.if(i<lim)/numberisOK/{21.ungetchar(c);22.s[i]=’\0’;23.return(NUMBER);24.}25.else{26.while(c!=’\n’&&c!=EOF)27.c=getchar();28.s[lim.1]=’\0’;29.return(TOOBIG);30.}31.}32.}①TheHaskellTeam.Haskell.http://www.haskell.orgPage9通过模型工具中的GCL翻译器把这段程序翻译成由GCL描述的程序.翻译过程如图2所示.根据输出结果,getop函数的GCL符号化表示如图3所示.getop函数的符号化表示:1.Prog=i,c··=…;2.While(cond1∧c?)doskip;3.(return··=c)ifcond2elseskip;4.s(0),i··=c,1;5.while(cond3∧c?)do6.(s[i],i··=c,i+1)ifcond4elseskip;7.Aifcond5elseskip;8.Bifcond6elseC;9.where10.A=(s[i]··=c)ifcondA1elseskip;11.whilecondA2∧c?do12.(s[i],i··=c,i+1)ifcondA3elseskip13.B=ungetchar(c);14.s[i]··=’\0’;15.return··=NUBMER16.C=whilecondC1do?c;17.s[lim]··=’\0’;18.return··=TOOBIG;19.andwhere20.cond1=(c=_)∨(c=\t)∨(c=\n)21.cond2=(c≠.)∧(c<0∨c>9)22.cond3=(c0)∧(c9)23.cond4=(i<lim)24.cond5=(c=.)25.cond6=(i<lim)26.condA1=(i<lim)27.condA2=(c0)∧(c9)28.condA3=(i<lim)29.condC1=(c≠\n)∧(c≠EOF)这样,该例子对于模型工具的输入可表示为s1=assign"i"(equ0)s2=input"c"s3=whilecond1ss1s4=ifcond2ss2ss3s5=assign"i"(equ1)s6=input"c"s7=whilecond3ss4s8=ifcond5ss5ss6s9=ifcond6ss7ss8program=[s1,s2,s3,s4,s5,s6,s7,s8,s9]program就是我们的程序,式中的ss1,ss2也是按照以上规则书写的程序语句.通过运行Haskell程序,我们得到如图4所示的输出.的输出,也即是getop函数的测试路径:图4中显示的是对program进行t操作后得到(t1)c∧cond11;c∧cond11∧cond12∧O(·).(t2)(c∧cond11)∧(lim∧cond21∧cond22∧cond31∧cond15);c∧cond11∧cond12;c∧cond13;c∧cond13∧cond14;c∧cond23;c∧cond23∧·.(t3)(c∧cond11)∧(lim∧cond21∧cond22cond31cond15);c∧cond11∧cond12;c∧cond13;c∧cond13∧cond14∧·.(t4)(c∧cond11)∧(lim∧cond21∧cond22∧cond31∧cond15);c∧cond11∧cond12;c∧cond13;c∧cond13∧cond14;c∧cond23;·.c∧cond24∧·.经分析,得到的路径能够覆盖所有的条件和语句,并且所获得的路径都是可行的.选取一些c和lim,我们得到如下测试用例(表1).Page105实验根据原型工具,我们可以把嵌入式C/C++(支持Queue,semaphore和Mailbox)映射到GCL表达式,并对此采用我们的算法生成测试用例.实验部分,我们针对IntegratedAccessAdvice(IAD)系统软件的一部分来生成测试用例.IAD是一个在DSL上运行数据和声音的嵌入式系统.被测部分称为PPPoverATM,其架构显示在图5中.ip/tcppktpppatm我们的原型工具首先把C程序翻译成GCL表达式,在此过程中我们注意到原型工具还不具备充分的规则去转换程序的所有部分,但是已足够去翻译与控制和数据相关的部分.然后对每个任务产生测试用例.原型工具运行在DELL1900上,具有内存4MB和速度2×1.60GHz.表3列出了对每个序列程序产生的测试用例以及所花的时间.被测程序ip-taskpkt-taskppp-task6相关工作目前,有不少生成测试用例的方法,下面是一些比较典型的工作.基于控制流图(ControlFlowGraph).Bertolino等人[1]提出一种算法及多种规则来选择路径,这样使得不可行的用例数大减少.但是,由于这种方法基于对程序控制流的分析,不能完全实现获取可执行路径的目标.此方法比较适合于序列化程序.Katayama等人[13]从程序源代码中推导出描述并行程序行为的事件交互图(EventInteractionGraph),但这种方法不能保证所获得的路径都是可行的.基于可达图(ReachabilityGraph).在文献[4]中,并行程序的执行行为是基于并发状态的.一旦并发状态图被创建,并发历史(即并发状态图中某条路径上的并发状态所组成的序列)为生成测试用例提供了指导.利用这种方法,被选择的路径都是可行的,但是这种方法存在状态爆炸问题.基于状态变迁系统(LabeledTransitionSystem).Tretmans和Belinfante[5]定义了一类特殊的带标记的变迁系统(LabeledTransitionSystem),称为Input-OutputTransitionSystem,来为用Promela所描述的系统生成测试用例.文中提出一种称为ioco的测试理论来生成测试用例,并描述了测试工具TorX.但是这种测试方法会导致状态爆炸问题.Muccini等人[14]用LTS来为系统结构上的行为建模,然后基于覆盖LTS模型的路径的集合获得合适的测试用例集合,最后,这些结构上的测试用例被细化为代码级的用例,从而用于执行.对于这种方法来说,要获得系统整体的结构模型是比较困难的.基于模型检测(ModelChecking).模型检测工具建立了一个有限状态变迁系统,并穷尽搜索状态空间以便找到违反属性的反例[2].基于模型检测进行测试的思想是将反例视为测试用例.模型检测中所使用的模型是反映系统行为的模型,它们可以从需求用例,系统的设计说明中获得,而且模型也可以基于程序代码进行创建[15].人们研究了大量基于模Page11型检测生成测试用例的方法.例如,文献[16]使用模型检测工具生成违反己知属性(针对SRC描述的需求)的测试用例.Hong等人[17]提出一种理论框架,采用时序逻辑来说明基于数据流的测试用例的覆盖率.基于符号执行(SymbolicExecution).符号执行是一种基于符号输入值生成代数表达式的程序分析方法.静态并发分析方法可能会丢失一部分数据的值,与之不同的是,符号执行将会保留与这些数据值有关的信息.这些信息可以用来检测不可行的执行路径,也可以用于生成测试数据[3].尽管符号执行的方法可以缓解测试用例不可行的问题,但是它也存在一些缺点,如处理动态数据结构,数组,过程比较困难;对于己被选择的路径,测试用例生成器不易找到使得这条路径被遍历的输入数据.文献[18]也指出符号执行方法需要复杂的代数操作,且处理数组和指针比较困难.在某些情况下,人们将符号执行与状态分析技术结合起来.例如,文献[19]将并发状态图与符号执行结合起来确定可能的同步模式.文献[20]通过使用根据符号执行而扩展的模型检测工具来研究程序的输入域.文献[21]描述了一个名为SimC的原型工具,SimC可以为C程序的单元测试自动生成测试用例.这种方法可以为包含指针及结构化操作的C程序生成测试数据,但如文中所说,对一些复杂的情况,如函数指针,复杂的输入等,暂时还不能处理.测试方法大体有下面一些工作:随机测试(RandomTesting).随机测试所使用的测试是在生成好的测试用例基础上选择[22].这种方法简单,没有太多的限制.有人认为这种方法测试的结果与有目的选取测试用例的测试结果差不多.但是,实际上随机测试用例集不能保证满足覆盖标准,而且,没有被测试覆盖的部分将导致测试效率降低.分解测试(PartitionTesting).分解测试的目标是覆盖所有的语句,控制流,数据流或临界的路径[23].在这一方面,到目前为止己有大量的研究工作.基于约束的测试(ConstraintBasedTesting).这种测试方法是由Millo与Offutt[24]提出来的.代数约束被用来描述特殊类型的故障.文献[25]提出了一种约束符号CSPE(ConstraintsonSucceedingandPrecedingEvents),并基于这种约束来为分布式程序生成测试序列.CSPE直接从程序抽象中获得,而测试序列将依据这些约束从程序抽象中选择.然而,利用这种方法所获得的测试序列个数很多,甚至是无限的.文献[26]提高了测试用例集的效率,因为他们的实验表明基于标准的策略所需的代价太高,并且需要花更多的工作来确定不可行的元素.适应性测试(AdaptiveSoftwareTesting).文献[27]提出一种可适应性软件测试.用可控制的马尔可夫链为软件系统建模.测试策略基于控制准则,理论及方法.选择测试用例的过程由反馈信息来指导,并且测试数据将用于指导选择下一次被执行的测试用例.组合测试.文献[28]针对组合测试,介绍了目前人们在组合测试用例生成领域所取得的研究成果,并对现有的组合测试用例生成方法进行了分类和总结.而且介绍了一些组合测试用例生成技术,并对该领域未来的研究方向进行了分析.同样,文献[29]中总结了近年来在组合测试方面的研究进展,包括组合测试准则研究,组合测试生成问题与其他NP完全问题的联系,和组合测试用例的数学构造方法等.此外,文献[30]提出一种形式化的基于TTCN的测试执行方法,利行标号变迁系统描述了解释执行的过程.这种方法为进行协议一致性测试活动提供了有力的支持.文献[31]通过考虑测试与需求间的相互关系,将满足需求的测试用例进行划分,根据划分结果成生一个测试用例,然后利用一些选择算法对所生成的测试用例进行进一步简化,通过这种方法可以获得满足所有测试需求的最小测试用例集.文献[32]分析和比较了面向路径的测试数据生成方法,将现有的一些方法进行分类,讨论了各种方法的特点和原理.文献[33]利用静态测试的方法,给出了内存汇漏的静态检测模型,并根据模型实现了一个自动测试工具.文献[34]提了指针映射代数的概念,全面反映了指针与内存之间的映射关系,以此为基础建立了动态内存故障模型.文献[35]提出基于相似度量的适应值函数构造方法,用于生成覆盖指定路径的测试用例.该方法在针对复杂路径的情况下具有一定的优势.7结束语我们提出了一种生成测试用例的形式化方法.由于用例的导出过程是基于形式化的语言,所以测试过程可以自动化.由于我们生成用例的过程实际上是对GCL表达式,借助于Hoare规则对条件分Page12解的过程,因此所生成的用例是正确的.算法的复杂度依赖于程序自身的特点,例如程序的输出个数,条件个数和内嵌的分支个数.这种方法的优点在于所获得的测试用例都是可行的,在测试用例生成过程中可以避免状态爆炸问题,且该方法可以延拓到任何目标语言.该方法理论上可以应用在任何规模的软件系统中,目前我们已能对小型软件系统生成测试用例.把大型软件系统的程序转化为本文中的高层描述语言需要较多的预处理,以及应用程序中特定语法结构到GCL的转化,这些都是今后研究中需要解决的问题.致谢审稿专家提出了很有价值的意见,在此表示感谢!
