Page1分布式大数据多函数依赖冲突检测李卫榜李战怀姜涛(西北工业大学计算机学院西安710072)摘要关系数据库数据质量的一个主要问题是存在数据不一致现象.为找出不一致数据,需要进行函数依赖冲突检测.集中式数据库中可以通过SQL技术检测不一致情况,而分布式环境下的函数依赖冲突检测更富有挑战性,特别是大数据背景下,这个问题尤为突出.分布式环境下的函数依赖冲突检测通常需要进行数据迁移,而且不同的数据迁移方法会对检测效率产生一定的影响.该文提出了一种基于等价类的分布式环境多个函数依赖冲突检测的方法,给出了冲突检测的响应时间代价模型.由于分布式环境函数依赖冲突检测问题的任务分配问题为NP-难问题,多项式时间内难以得到最优解,该文将不一致性检测响应时间最小化问题转化为整数规划问题,并给出了近似最优解.针对集群规模和函数依赖个数大小不同的情况,分别给出了不同的任务分配策略,并在检测过程中实现了动态负载均衡,有效提高了负载均衡度和检测效率.在真实和人工数据集上的实验表明,相对于集中式检测方法以及基于Hadoop的nave方法,该文提出的多函数依赖冲突检测方法检测效率有明显的提升,且在数据规模、节点个数和函数依赖个数等方面扩展性能良好.关键词函数依赖;冲突检测;不一致性;分布式数据;大数据1引言数据管理最重要的问题之一是数据质量问题[1],其中不一致性检测是数据质量的一个重要内容.对于完整性约束函数依赖来说,由于数据管理不规范等问题,违反函数依赖的情况十分普遍,而且在数据融合等场合,也经常会遇到违反函数依赖的情况.数据特别是重要数据对其质量有着极高的要求,违反函数依赖的数据如果不进行处理,可能会付出很大的代价.表1EMP的一个实例犇0IDENOENAMETITLESALPNO1E1M.SmithSyst.Anal.3500P1DatabaseDevelopManager362E1M.SmithElec.Eng.2600P23E2J.JonesProgrammer2500P24E2J.JonesAnalyst3300P3Instrumentation5E2J.DavisMech.Eng.2700P1DatabaseDevelopEngineer246E3F.LeeProgrammer2800P3InstrumentationProgrammer187E3F.LeeAnalyst3800P28E4F.LeeMech.Eng.2500P1DatabaseDevelopEngineer369E5B.CaseyAnalyst3300P1DatabaseDevelopManager2410E5D.CaseyProgrammer2800P3InstrumentationProgrammer12为了检测不一致性,在关系表EMP上定义了如下几个函数依赖(FunctionalDependency,FD)作为数据质量规则:φ1:ENO→ENAMEφ2:PNO→PNAMEφ3:TITLE→SALφ4:TITLE→RESPφ5:ENO,PNO→DUR这里φ1声明了工号唯一决定员工姓名,φ2声明了项目编号唯一决定项目名称,φ3表示头衔唯一确定薪水,φ4表示头衔唯一确定职责,φ5表示工号和项目编号联合确定持续时长.为找出表1中存在的不一致数据,需要找出其中违反函数依赖集合{φ1,φ2,φ3,φ4,φ5}的元组.D0中id为i的元组用ti表示,则在D0中有如下元组存在冲突:t3,t4,t5,t6,t7,t8,t9,t10.其中元组t3,t4和为提高数据质量,通常需要对数据进行不一致性检测.不一致性检测对于集中式数据来说较为容易,如函数依赖冲突检测可以使用一种基于SQL技术的检测方法[2].然而现实中的数据并不都是集中式分布的,可能被切分并分布在不同的机器上[3].例1.考虑如下一个关系表EMP(ID,ENO,ENAME,TITLE,SAL,PNO,PNAME,RESP,DUR),每一个员工元组包含了ID、工号、姓名、头衔、薪水、项目编号、项目名称、职责、持续时长等内容.这里ID是关系表EMP的主键,EMP的一个实例D0如表1所示.t5违反函数依赖φ1:元组t3,t4和t5工号相同,员工姓名不同.同理,元组t9和t10违反函数依赖φ1.元组t3和t6违反函数依赖φ3:元组t3和t6头衔相同,薪水不同.同理,元组t4和t7违反函数依赖φ3,元组t5和t8违反函数依赖φ3;元组t4,t7和t9违反函数依赖φ4.在集中式环境,数据分布在一个机器上,在进行函数依赖冲突检测时,可以使用已有的基于SQL的方法进行检测[1].在数据规模较大或者待检测函数依赖个数较多的情况下,传统的集中式函数依赖冲突检测方法还存在检测效率低下的问题.如果数据不是集中分布,而是分布在不同的节点,则传统的检测方法无法直接使用.一种nave的方法是将所有待检测数据迁移到一个节点,在该节点使用集中式方法进行检测.这种方法存在如下几个方面的问题:一是需要数据的迁移,在数据规模很Page3大的情况下,数据迁移耗时也比较可观;二是传统的方法每检测一个函数依赖,都需要将所有数据遍历一次,在函数依赖个数比较多的情况下,效率比较低下;三是所有的检测任务都在一个节点进行,负载严重的不均衡,效率较低.以表1中的数据实例D0为例,其数据被水平切分成3个部分,分别如表2、表3和表4所示,其中分片DH1、DH2和DH3分别分布在站点S1、S2和S3上.为检测违反函数依赖φ1的元组,需要进行数据迁移,数据迁移的原则是函数依赖左端属性值相同的元组迁移到同一个节点.迁移的方案有多种:(1)从站点S2迁移元组t7到S1,从站点S3迁移元组表2犇0的一个水平划分的片段犇犎1IDENOENAMETITLESALPNO1E1M.SmithSyst.Anal.3500P1DatabaseDevelopManager365E2J.DavisMech.Eng.2700P1DatabaseDevelopEngineer248E4F.LeeMech.Eng.2500P1DatabaseDevelopEngineer369E5B.CaseyAnalyst3300P1DatabaseDevelopManager24表3犇0的一个水平划分的片段犇犎2IDENOENAMETITLESALPNO2E1M.SmithElec.Eng.2600P23E2J.JonesProgrammer2500P27E3F.LeeAnalyst3800P2表4犇0的一个水平划分的片段犇犎3IDENOENAMETITLESALPNO4E2J.JonesAnalyst3300P3Instrumentation6E3F.LeeProgrammer2800P3InstrumentationProgrammer1810E5D.CaseyProgrammer2800P3InstrumentationProgrammer12本文的主要贡献如下:(1)提出了分布式环境下多个函数依赖不一致性检测响应时间代价模型.由于分布式环境不一致性检测最小化响应时间问题为NP-难问题,无法在多项式时间得到最优解,本文基于该模型给出了近似最优并行检测方法.(2)将等价类引入到函数依赖的冲突检测,给出了基于等价类的冲突检测的优化策略,有效提高检测效率.(3)为避免检测过程中负载不均衡的情况,在检测过程中动态均衡负载,为减少负载迁移量,将该问题划归为二次规划问题,并采用拉格朗日算子法得到最优解.(4)对本文提出的方法基于真实和人工数据集进行了对比实验验证.实验结果表明,本文提出的方法在数据扩展性、集群节点扩展性以及函数依赖规t3到S1,从站点S1迁移元组t9到S3;(2)从站点S1迁移元组t5到S2,从站点S3迁移元组t4到S2,从站点S1迁移元组t9到S3;(3)从站点S1迁移元组t5到S3,从站点S2迁移元组t7到S3,从站点S3迁移元组t10到S1;等等.从这个例子可以看出,与集中式环境不同,在分布式环境下,不一致数据冲突检测通常需要数据的迁移,因此集中式环境下的检测方法不适用于分布式环境下的不一致性检测.针对分布式环境大数据背景下多个函数依赖冲突检测的问题,本文提出了算法MultiFDsDetDS,基于Hadoop和Hama平台,实现分布式环境大数据多个函数依赖的并行冲突检测,有效提高检测的效率.模扩展性方面均表现良好.2相关工作函数依赖作为关系数据库中的一种完整性约束,反映了不同属性之间的一种制约关系,其概念最早由Armstrong提出[1].函数依赖冲突在现实世界中十分常见,特别是在Web数据抽取、数据融合等场合更为常见.当前针对分布式环境违反完整性约束进行检测的相关文献还比较少,Fan等人针对条件函数依赖(CFD)在分布式数据上的不一致性问题进行了研究[4],给出了几种不一致性检测算法,并利用条件函数依赖的结构特点减少数据迁移或响应时间.条件函数依赖是对传统函数依赖的一种扩展[5],对函数依赖的左部(LHS)加以条件限制,然后在一定条件的基础上使用传统的函数依赖.然而条件函Page4数依赖和传统的函数依赖有着很大的不同,没有条件函数依赖的模式表(patterntable),因此无法使用针对CFD的分布式数据不一致性检测方法检测传统函数依赖的冲突.Fan还提出一种分布式环境CFD不一致性增量检测方法,针对数据规模动态变化的情况,检测CFD的不一致性[6].文献[7-8]对分布式数据库中完整性约束的检测问题进行了相关的研究.文献[7]研究了在仅访问局部关系的情况下对基本关系更新时全局不一致性检测的问题.文献[9]中给出了完整性约束检测的本地条件,认为如果本地数据满足这些条件,则全局数据也同样满足,因此无需进行数据的迁移,这样可以有效减少通信代价.文献[10]对数据融合中数据冲突的解析展开了相关研究,主要针对的是集中式环境下的冲突问题.文献[11-12]对分布式数据源的异常检测问题进行了研究.文献[11]提出了一种针对包含混合属性数据集的快速分布式异常检测策略.这些方法主要针对的是异常检测,主要目标是从给定的数据源中找到异常情况.与之不同,函数依赖冲突检测主要是检测函数依赖约束的违反情况.文献[13-14]对函数依赖冲突的修复进行了相关研究.为了对存在违反函数依赖情况的不一致数据进行修复,通常采用对属性值进行修改的方法.与本文工作不同,这些文献主要关注的是函数依赖冲突的修复问题.文献[15-16]研究了函数依赖发现的问题,主要是研究给定一个模式,如何发现隐含的约束关系.3预备知识3.1函数依赖定义1.给定关系R,Attrs(R)为R上所有属性的集合,X,YAttrs(R).函数依赖(FunctionalDependency,FD)是定义在R上的一个约束,用X→Y表示.函数依赖X→Y成立当且仅当对ti,tj∈R,如果ti[X]=tj[X],则必然有ti[Y]=tj[Y].对于函数依赖X→Y,我们称X为其左部(LeftHandSide,LHS),相应的Y为其右部(RightHandSide,RHS).如果函数依赖的LHS与RHS交集为空,称该函数依赖为非平凡函数依赖.本文中仅考虑非平凡多个函数依赖的冲突检测问题.3.2等价类定义2.等价类(EquivalenceClass,EC).假定XAttr(R)为关系R上的一个属性集合,其中Attr(R)为关系R的所有属性集合,我们称元组t∈R在属性集合X上的等价类为[t]X={p∈R|对所有A∈X,有p[A]=t[A]},这里t[A]为元组t在属性A上的值.例2.以表1中EMP的一个实例D0为例,属性ENO在元组1和2上有着相同的属性值E1,因此元组1和2构成等价类{1,2},这里我们用元组的ID值代表元组.同理,元组3、4和5在ENO上有着相同的属性值E2,因此构成等价类{3,4,5}.定义3.局部等价类(LocalEquivalenceClass,LEC).假定XAttr(R)为关系R上的一个属性集合,其中Attr(R)为关系R的所有属性集合,关系R的实例D被横向切分为n块,D=D1∪…∪Dn,我们称元组t∈Di在属性集合X上的等价类为局部等价类,表示为[t]Xi={p∈Di|对所有A∈X,有p[A]=t[A]},这里t[A]为元组t在属性A上的值.定义4.划分(Partition).假定XAttr(R)为关系R上的一个属性集合,定义ΠX={[t]X|t∈R}为关系R在属性集合X上的一个划分.根据等价类和划分的定义可以看出,划分ΠX由关系R在属性集合X上不相交的等价类组成,每一个等价类内的元组在属性集合X上有着相同的属性值,不同的等价类在X上的属性值不同,而等价类的并集与关系R等价.例3.以表1中EMP的一个实例D0为例,关系EMP在属性ENO上的划分为{{1,2},{3,4,5},{6,7},{8},{9,10}},关系EMP在属性集合{ENO,ENAME}的划分为{{1,2},{3,4},{5},{6,7},{8},{9},{10}}.引理1.给定关系R,φ:X→Y为关系R上的函数依赖,ΠX为关系R在属性集合X上的一个划分,则有ΠX中所有等价类包含的元组个数之和等于关系R包含的总的元组个数,即Σ|[t]X|=|R|,其中[t]X∈ΠX.证明.假设Σ|[t]X|≠|R|,则有Σ|[t]X|>|R|或者Σ|[t]X|<|R|.根据定义2,[t]X中元组均为R中的元组,且不同等价类之间不存在交集,因此,Σ|[t]X||R|,故Σ|[t]X|>|R|不成立.又根据定义4,划分ΠX中包含了所有的等价类[t]X,而等价类又是在R的所有元组上进行定义的,因此所有等价类中元组个数之和不少于R中元组个数,因此有Page5Σ|[t]X||R|,故Σ|[t]X|<|R|不成立.综上,假设Σ|[t]X|≠|R|不成立,Σ|[t]X|=|R|成立.证毕.定义5.局部划分(LocalPartition).假定XAttr(R)为关系R上的一个属性集合,关系R的实例D被横向切分为n块,D=D1∪…∪Dn,定义ΠXi={[t]X|t∈Di,i∈[1,n]}为关系R在属性集合X上的一个局部划分.例4.以表2中EMP的一个实例DH1为例,关系EMP在属性RESP上的划分对于关系EMP来说是一个局部划分,为{{1,9},{5,8}}.定义6.剥离划分(StrippedPartition).假定XAttr(R)为关系R上的一个属性集合,定义ΠX={[t]X|t∈R,|[t]X|>1}为关系R在属性集合X上的一个剥离划分.例5.以表1中EMP的一个实例D0为例,根据定义4,关系EMP在属性集合{ENO,ENAME}的剥离划分为去除仅包含一个元组的等价类后的等价类集合,即为{{1,2},{3,4},{6,7}}.3.3函数依赖冲突函数依赖作为完整性约束的一种,其冲突意味着违反了完整性约束.函数依赖冲突在现实中十分常见,特别是在数据集成、数据融合以及Web数据抽取应用中.定义7.函数依赖冲突.给定关系R的一个实例D,函数依赖φ:A→B,对于D中的每一个元组t,如果存在一个元组t满足t(A)=t(A)且t(B)≠t(B),说明元组t和t违反了函数依赖φ.将D上违反φ的冲突表示为Viot(φ,D),因此有t∈Viot(φ,D).假定Σ为定义在D上的函数依赖的集合,则Viot(Σ,D)表示D上的所有违反Σ中函数依赖的冲突.用符号ViotΠ(φ,D)表示ΠAViot(φ,D),这里ΠAViot(φ,D)是Viot(φ,D)在属性A上的投影,R中其他属性值用空值null表示.与Viot(φ,D)相比,ViotΠ(φ,D)包含数据更少.前面提到,一个关系R的任一水平分片与R有着相同的模式,因此,如果函数依赖φ是定义在R的实例D上面的,则φ同样也是定义在D的各个分片上的.这里将D的任一水平切片Di上违反函数依赖φ的冲突定义为Viot(φ,Di).引理2.给定关系R,φ:X→Y为关系R上的函数依赖,[t]X为在属性集合X上的等价类,[t]X∪Y,[t]X∪Y为在属性集合X∪Y上的等价类,对任意两个元组ti和tj,如果满足ti,tj∈[t]X,ti∈[t]X∪Y,tj∈[t]X∪Y,且[t]X∪Y≠[t]X∪Y,则元组ti和tj为违反函数依赖φ的冲突元组.证明.由ti,tj∈[t]X,可知元组ti和tj属于X属性集合上的同一个等价类,根据等价类的定义2,可以得到ti[X]=tj[X].同理,由ti∈[t]X∪Y,tj∈[t]X∪Y,且[t]X∪Y≠[t]X∪Y,根据定义2,可以得到ti[X∪Y]≠tj[X∪Y],即元组ti和tj在属性集合X∪Y上的值不同.而元组ti和tj在属性集合X∪Y上的值包含了在属性集合X上的值,且由前面可知元组ti和tj在属性集合X上的值相同,ti[X∪Y]和tj[X∪Y]去掉相同的属性值ti[X]和tj[X],剩余部分为ti[Y]和tj[Y],这里必然有ti[Y]≠tj[Y],否则假定ti[Y]=tj[Y],而前面已知ti[X]=tj[X],则必然有ti[X∪Y]=ti[X]∪ti[Y]=tj[X∪Y],与已知矛盾,假设不成立,故ti[Y]≠tj[Y]成立.由定义7中函数依赖冲突的界定,可以得到元组ti和tj为违反函数依赖φ的冲突元组.例6.以表1中EMP的实例D0为例,对于函数依赖φ1:ENO→ENAME,ENO属性值为“E2”的等价类为{3,4,5},对应的基于属性集合{ENO,ENAME}的等价类为{3,4}和{5}.不难看出,元组t3,t4和t5属于等价类[t]ENO={3,4,5},而t3,t4∈[t]ENO∪ENAME={3,4},t5∈[t]ENO∪ENAME={5},根据引理2,元组t3,t4和t5为函数依赖φ1的冲突元组.3.4函数依赖冲突检测假定D为R的实例,D被切分为n份,每一个切分Di分布在不同的节点.函数依赖φ是定义在R上的一个函数依赖,φ的冲突检测问题是查找ViotΠ(φ,D).给定函数依赖φ,φ可以在本地检测当且仅当满足ViotΠ(φ,D)=∪i∈[1,n]ViotΠ(φ,Di).具有最小响应时间的函数依赖不一致性检测问题,其输入是一个函数依赖的集合Σ和水平切分的关系R的实例D,响应时间满足以下条件:(1)集合Σ中的函数依赖冲突在数据迁移U之后可以本地检测;(2)响应时间RT是最小的.然而找到一个最小响应时间的函数依赖检测算法是不现实的,在水平切分情况下,具有最小响应时间的函数依赖不一致性检测问题是一个NP-难问题[4].4分布式大数据多函数依赖冲突检测函数依赖冲突检测是不一致性检测的重要内容.在集中式环境下,函数依赖冲突检测主要取决于Page6数据规模和函数依赖的个数.在分布式大数据环境下,不仅需要进行数据的迁移,而且要考虑如何提高冲突检测的效率.根据文献[4],分布式环境下单个函数依赖的冲突检测问题已经是非平凡的,为NP-难问题,由此可见,分布式环境下多个函数依赖的冲突检测问题同样为NP-难问题.4.1方法CenDet方法CenDet在检测多个函数依赖冲突时,首先将分布式数据迁移到一个节点,然后利用集中式函数依赖冲突检测方法对多个函数依赖分别进行冲突检测,最终得到违反多个函数依赖的冲突元组.在具体的检测过程中,采用流水线方式,在完成一个函数依赖冲突检测后,进行下一个函数依赖的冲突检测,直到所有函数依赖冲突全部检测完毕为止.方法CenDet在进行多个函数依赖冲突检测的时候,响应时间会比较长:由于检测每一个函数依赖冲突的时候都需要扫描一遍全部数据,而这种扫描是十分耗时的,在大数据背景下,方法CenDet的检测效率较低,响应时间较长.由于所有检测任务均在一个节点进行,因此方法CenDet的负载严重的不均衡.函数依赖冲突检测耗时很大程度上取决于数据的规模,在数据规模特别大的情况下,对数据的每次扫描时间开销都很大,如果能够一次扫描全部数据而实现对多个函数依赖的冲突检测,则可以大大提高函数依赖的冲突检测效率.4.2方法MultiFDsDetDS方法MultiFDsDetDS进行分布式大数据多函数依赖冲突检测时,包括以下几个步骤:(1)数据预处理(生成局部等价类);(2)任务分配;(3)数据迁移;(4)合并得到全局等价类;(5)冲突检测.给定关系R的实例D,待检测函数依赖集合Σ={φ1,φ2,…,φm},假定D被水平切分为n份,分别为D1,…,Dn,不同的分片分布在不同的节点,对i∈[1,n],分片Di分布在节点Si上.为检测函数依赖集合Σ中函数依赖的冲突情况,在任一节点Si,i∈[1,n],方法MultiFDsDetDS首先进行数据的预处理,假定在节点Si数据预处理时间为PreDeal(Di).数据预处理后,在各个节点得到各个待检测函数依赖的局部等价类.完成数据预处理后,方法MultiFDsDetDS对函数依赖的冲突检测任务进行分配,对任一函数依赖φj,j∈[1,m],执行其冲突检测的节点为该函数依赖的执行节点.然后根据任务分配的结果进行数据迁移,将与每一个函数依赖相关的局部等价类数据迁移到该执行节点上.假定任一节点Si迁出的数据为Di-out,迁入的数据为ΔDi-in,则总的数据迁移量为ΔD=∑i∈[1,n]ΔDi-out=∑i∈[1,n]ΔDi-in.所有节点数据迁移完成后,算法根据任务分配情况在各个节点进行局部等价类的合并,进而得到全局等价类.假定节点Si局部等价类合并耗时为merge(ECi),ECi为分配给节点Si的待检测函数依赖的局部等价类集合.得到全局等价类后,根据冲突检测任务分配的结果,算法在各个节点并行进行函数依赖冲突检测,假定数据迁移及局部等价类合并后节点Si的待检测数据为Di,冲突检测耗时为check(Di).假定函数依赖集合Σ冲突检测总的响应时间代价模型为costRT(Σ),这里定义多函数依赖冲突检测响应时间代价模型如下:costRT(Σ)=maxi∈[1,n]PreDeal(Di)+1式中PreDeal(Di)为各节点数据预处理(生成局部等价类)耗时,n为节点个数,Σ为待检测函数依赖集合,bw为网络带宽,merge(ECi)为各节点局部等价类合并得到全局等价类的耗时,check(Di)为各节点函数依赖冲突检测耗时.依据多函数依赖冲突检测响应时间代价模型,方法MultiFDsDetDS检测多个函数依赖冲突的响应时间取决于四部分:各节点数据预处理耗时即生成局部等价类的耗时maxi∈[1,n]PreDeal(Di),数据迁移耗时1bw∑i∈[1,n]ΔDi-in,各节点合并局部等价类得到全局等价类的耗时maxi∈[1,n]merge(ECi),各节点执行函数依赖冲突检测的耗时maxi∈[1,n]check(Di).为减少分布式环境多函数依赖冲突检测的响应时间,有必要在以上各个阶段考虑对其响应时间进行优化.第1步是数据预处理,在各个节点生成局部等价类.假定待检测函数依赖集合为Σ,对Σ中每个函数依赖φi,i∈[1,n],分别基于属性集合LHS和(LHS+RHS)在各个节点的数据上并行计算局部等价类[t]LHS和[t]LHS∪RHS,得到形如〈key,value〉的键值对,其中key为元组在属性集合上的属性值组合,value为有着相同属性值组合的局部等价类.例7.以表1中EMP的一个实例DH1为例,Page7对函数依赖φ3:TITLE→SAL,LHS部分为属性集{TITLE},(LHS+RHS)部分属性集合为{TITLE,SAL}.在数据预处理阶段,在节点S1上基于属性集合{TITLE}得到键值对〈“Syst.Anal.”,{1}〉,〈“Mech.Eng.”,{5,8}〉,〈“Analyst”,{9}〉,基于属性集合{TITLE,SAL}得到键值对〈“Syst.Anal._3500”,{1}〉,〈“Mech.Eng._2700”,{5}〉,〈“Mech.Eng._2500”,{8}〉,〈“Analyst_3300”,{9}〉.同理,在节点S2及S3上进行数据的预处理.在各节点并行预处理得到各个函数依赖的局部等价类后,接下来对局部等价类数据进行迁移,使得相同函数依赖的所有局部等价类数据迁移到同一节点,如图1所示.算法1为数据预处理算法.算法1.PreDeal.输入:函数依赖集合Σ={φ1,…,φm},D=(D1,…,Dn)输出:[tX1]LHS,[tX1∪Y1]LHS∪RHS,…,[tXm]LHS,1.Map(kL,vL)ML←null,Map(kL∪R,vL∪R)ML∪R←2.FOREACHφj∈ΣDO3.Map(kL,vL)mL←null,Map(kL∪R,vL∪R)mL∪R←4.FOREACHt∈DiDO//生成局部键值对5.IF!mL.containsKey(t(Xj))6.vL.add(t(ID));7.mL.put(t(Xj),vL);8.ELSEIF!mL.get(t(Xi)).containsKey(t(ID))9.mL.get(t(Xj)).add(t(ID));10.IF!mL∪R.containsKey(t(Xj))11.vL∪R.add(t(ID));12.mL∪R.put(t(Xj),vL∪R);13.ELSEIF!mL∪R.get(t(Xj)).containsKey(t(ID))14.mL∪R.get(t(Xj)).add(t(ID));15.ENDFOR;16.IFML.containsKey(mL.getKey())//局部键值对合并17.ML.get(mL.getKey()).add(mL.getValue());18.ELSEML.put(mL.getKey(),mL.getValue());19.IFML∪R.containsKey(mL∪R.getKey())20.ML∪R.get(mL∪R.getKey()).add(mL∪R.getValue());21.ELSEML∪R.put(mL∪R.getKey(),mL∪R.getValue());22.[tXj]LHS←ML;23.[tXj∪Yj]LHS∪RHS←ML∪R;24.ENDFOR;25.RETURN[tX1]LHS,[tX1∪Y1]LHS∪RHS,…,[tXm]LHS,算法1的输入为待检测分布式数据(D1,…,Dn)及函数依赖集合Σ,输出为每个待检测函数依赖关于LHS和(LHS+RHS)的局部等价类.算法首先对每个待检测函数依赖的LHS和(LHS+RHS)按照元组分别生成局部键值对,然后对有着相同key值的局部键值对进行合并,最后得到待检测函数依赖的LHS和(LHS+RHS)局部等价类.例8.表1中EMP的实例D0被切分为DH1,DH2,DH3,对函数依赖φ3:TITLE→SAL,由例7中的局部等价类,根据图1中的合并规则,可以得到φ3基于属性集合{TITLE}的划分ΠTITLE={{1},{2},{3,6,10},{4,7,9},{5,8}}以及基于属性集合{TITLE,SAL}的划分ΠTITLE_SAL={{1},{2},{3},{6,10},{4,9},{7},{5},{8}}.本文中需要检测的函数依赖个数为m,节点个数为n,对每个i=1,2,…,m和每个j=1,2,…,n,第i个函数依赖在第j个节点上检测耗时为tcij,第i个函数依赖在第j个节点上局部等价类数据合并耗时为tmij,依据多函数依赖冲突检测响应时间代价模型costRT(Σ),要想减少总的响应时间,应当最小化数据迁移耗时1耗时maxi∈[1,n]merge(ECi)、函数依赖冲突检测耗时maxi∈[1,n]check(Di),也就是对待检测函数依赖进行任务分配后,数据迁移耗时、局部等价类合并耗时以及冲突检测耗时之和最小.这里定义xij为第j个节点上处理第i个函数依赖,则当第i个函数依赖分配Page8给第j个节点时,xij=1,否则xij=0.该问题可以转化为如下的整数规划问题.目标函数:mintm+tc+1约束条件:j∈[1,n],tc∑mj∈[1,n],ΔDj-in=∑m(|ΠXi_Yi|-|ΠjXi_Yi|)];∑n上述整数规划中,tm为所有节点局部等价类合并耗时,tc为所有节点函数依赖冲突检测耗时,tmij为第i个函数依赖在第j个节点上局部等价类合并耗时,tcij为第i个函数依赖在第j个节点上冲突检测耗时,|ΠXi|为第i个函数依赖LHS部分在全局数据上的划分,|ΠXi_Yi|为第i个函数依赖LHS∪RHS部分在全局数据上的划分,|ΠjXi|为第i个函数依赖LHS部分在第j个节点数据上的局部划分,|ΠjXi_Yi|为第i个函数依赖LHS∪RHS部分在第j个节点数据上的局部划分.上述函数依赖任务分配问题为多处理机任务分配问题,该问题为NP-完全问题[4],难以在多项式时间内得到问题的精确解,本文给出一种多函数依赖冲突检测任务分配的近似最优算法,如算法2所示.算法2.LoadAllocateByFD.输入:机器集合M={Mi},i∈[1,n],任务集合L=输出:L(1),L(2),…,L(n)1.FOREACHi∈[1,n]DO2.Li←{};3.ENDFOR;4.Desc(|ΠXj|);//依据L中等价类集合ΠX的势的大5.假定|ΠX1||ΠX2|…|ΠXm|;6.FOREACHj∈[1,m]DO7.IF分配给机器Mi的任务包含等价类个数最少8.L(i)←L(i)∪{ΠXj,ΠXj_Yj};9.ENDIF;10.ENDFOR.算法2的输入为处理机集合M以及待分配任务集合L,输出为任务分配结果.算法首先依据任务集合中等价类ΠX势的大小对L中任务降序排列,在得到降序排列结果后,开始进行任务分配.任务分配过程中,对当前要分配的任务,找出目前被分配的任务包含等价类个数最少的机器,将当前任务分配给该机器,直到所有任务都分配完成.算法将一个待检测函数依赖基于LHS的划分ΠXj及基于LHS∪RHS的划分ΠXj_Yj作为一个整体的任务进行分配,根据等价类集合ΠX的势(等价类集合ΠX中包含元素的个数)的大小将多个划分的集合进行降序排列,然后从排序后的任务集合中依次取出任务集合进行分配,每次分配时选择当前任务负载最小的节点进行分配,在函数依赖个数m超过节点个数n的情况下,使用贪心算法进行任务分配的时候,通常很难得到最优解,而算法LoadAllocateByFD可以得到近似最优解.引理3.给定关系R,φ:X→Y为关系R上的函数依赖,ΠX为在属性集合X上的划分,ΠXY为在属性集合X∪Y上的划分,则有|ΠX||ΠXY|.证明.假定|ΠX|>|ΠXY|,对每一个[t]X∈ΠX,如果[t]Y∈ΠY,使得[t]X=[t]Y,则据定义2,有[t]X=[t]Y=[t]XY,由定义4,有ΠX=ΠXY,因此|ΠX|=|ΠXY|,与假设矛盾.否则,对每一个[t]X∈ΠX,如果[t]Y∈ΠY,使得[t]X=[t]Y,则由定义2,有[t]X≠[t]XY,根据定义4,必然[t]Y,[t]Y∈ΠY,使得[t]X=[t]Y∪[t]Y.同理存在[t]XY,[t]XY∈ΠXY,使得[t]X=[t]XY∪[t]XY.又根据引理1,Σ|[t]X|=Σ|[t]XY|=|R|,所以ΠX中等价类个数少于ΠXY中等价类个数,即|ΠX|<|ΠXY|,与假设矛盾.综上,假设不成立,|ΠX||ΠXY|成立.证毕.由引理3,对于待检测函数依赖φ:X→Y,满足|ΠX||ΠXY|,即基于LHS属性集合的划分所包含的等价类个数不超过基于LHS∪RHS属性集合的划分所包含的等价类个数,因此在对φ进行冲突检测时,可以从|ΠX|中等价类出发,在|ΠXY|中寻找相应的冲突等价类.基于等价类的函数依赖冲突检测问题可以视为多叉树生成问题,该多叉树包含3层,第0层为包含所有元组的根节点,第1层为包含所有基于LHS属性集合的等价类的中间节点,第2层为包含所有基于LHS∪RHS属性集合的等价类的叶子节点.图2为函数依赖等价类生成树的一个示例.其中节点[t1]X为关系R在函数依赖φ:X→Y左端即属性集合{X}上的一个等价类,而等价类[t1-1]XY,[t1-2]XY,…,[t1-k]XY为节点[t1]X的子节点,同时也是等价类生成树的叶子节点.函数依赖等价类生成树有着如下的性质.Page9性质3.在函数依赖等价类生成树中,所有中间节点所包含元组的并集等于关系R中所有元组集合.性质4.在函数依赖等价类生成树中,对任一中间节点,如果其所包含的子节点个数大于1,则该中间节点包含冲突元组,且其不同子节点中所包含的元组互为冲突元组.根据上面的分析可以看出,基于等价类的函数依赖冲突检测本质上就是得到等价类生成树.而通常情况下,等价类生成树中会包含不存在冲突的中间节点和叶子节点,有必要对这些节点进行剪枝,通过剪去不存在冲突的中间节点和叶子节点,从而提高检测效率.性质1.在函数依赖等价类生成树中,任一中间节点所包含元组在函数依赖LHS上的属性值与所有其子节点在函数依赖LHS上的属性值相同.性质2.在函数依赖等价类生成树中,中间节点所包含元组的集合为其所有子节点所包含元组集合的并集.给定关系R,φ:X→Y为关系R上的函数依赖,[t]X为在属性集合X上的等价类,[t]X∪Y为在属性集合X∪Y上的等价类,如果满足[t]X=[t]X∪Y,则[t]X或[t]X∪Y中的元组关于函数依赖φ不存在冲突.对ti,tj∈[t]X,ti≠tj,由[t]X=[t]X∪Y可知ti,tj∈[t]X∪Y.根据定义2,由ti,tj∈[t]X∪Y可知ti[XY]=tj[XY],由ti,tj∈[t]X可知ti[X]=tj[X].由ti[XY]=tj[XY]和ti[X]=tj[X],将等式ti[XY]=tj[XY]左右两端去掉相同部分ti[X]和tj[X]可以得到ti[Y]=tj[Y],根据函数依赖冲突的定义7,元组ti,tj关于函数依赖φ不存在冲突.可以看出,如果函数依赖等价类生成树中中间节点仅包含一个子节点,则该中间节点对应的等价类中不包含冲突元组.剪枝策略1.给定关系R,φ:X→Y为关系R上的函数依赖,ΠX为关系R在属性集合X上的一个划分,在检测函数依赖φ的冲突时,首先去除ΠX中包含单个元素的等价类,得到ΠX的剥离划分ΠX,然后去除ΠXY中所包含的同时在ΠX和ΠXY中为单个元素的等价类,得到ΠXY=ΠXY\(ΠX\ΠX),基于ΠX和ΠXY进行冲突检测.剪枝策略2.对剪枝后得到的ΠX和ΠXY,去除其中包含的公共的等价类,得到ΠX=ΠX\(ΠX∩ΠXY)和ΠXY=ΠXY\(ΠX∩ΠXY),基于ΠX和ΠXY进行冲突2检测.经过剪枝策略1和2剪枝后,可以得到仅包含冲突元组的等价类,基于该等价类进行函数依赖冲突检测,可以有效减少冲突检测的比对空间,提高检测效率.例9.以表1中EMP的一个实例D0为例,对函数依赖φ1:ENO→ENAME,D0在属性集合{ENO}上的划分为ΠENO={{1,2},{3,4,5},{6,7},{8},{9,10}},在{ENO,ENAME}上的划分为ΠENO_ENAME={{1,2},{3,4},{5},{6,7},{8},{9},{10}}.图3是等价类ΠENO和ΠENO_ENAME生成树剪枝过程示意图.第1次剪枝,分别从ΠENO和ΠENO_ENAME中剪去了包含单个元组的等价类{8},得到如图3中间的等价类生成树.第2次剪枝,分别从ΠENO和ΠENO_ENAME中剪去了包含单个元组的等价类{1,2}和{6,7},得到如图3下部的等价类生成树.从图3不难看出,经过两次剪枝后得到的等价类生成树为一棵仅包含冲突元组的等价类生成树,也就是一棵冲突等价类生成树.Page10经过上述剪枝策略剪枝后得到包含冲突元组的等价类,为进一步确定图2中第1层每一个冲突等价类的子集合,也就是构造冲突等价类生成树,需要将剪枝后第1层中的任一节点与第2层中的叶子节点进行匹配,以确定是否为父子关系.nave的匹配方法是对第1层中的任一节点,取第2层中所有未匹配上的叶子节点进行匹配,这种匹配方法由于要与第2层中所有未匹配上的叶子节点进行匹配,因此效率不高.为提升匹配效率,首先对两次剪枝后得到的第1层的等价类集合ΠX=ΠX\(ΠX∩ΠXY)中的所有等价类根据其势的大小从小到大进行排序,得到一个升序的等价类集合ΠX↑.然后从等价类势最小的一端逐个选取等价类进行匹配,在匹配时,先对ΠXY=ΠXY\(ΠX∩ΠXY)中的等价类进行剪枝.给定关系R,φ:X→Y为关系R上的函数依赖,ΠX为在属性集合X上的划分,ΠXY为在属性集合X∪Y上的划分,[t]X为在属性集合X上的等价类,如果[t]X中存在冲突元组,则对[t]X∪Y∈ΠXY,如果[t]X∪Y[t]X,即[t]X∪Y为[t]X的子集合,则|[t]X|>|[t]X∪Y|.等价类集合ΠX↑中的所有等价类,其子集合的势均小于等价类自身的势,因此对ΠXY=ΠXY\(ΠX∩ΠXY)中的等价类进行剪枝时,对[t]X∈ΠX↑,如果[t]X∪Y∈ΠXY且|[t]X∪Y||[t]X|,则可以将[t]X∪Y从ΠXY中移除.例10.以图3中2次剪枝后得到的等价类为例,其中ΠENO={{3,4,5},{9,10}},ΠENO∪ENAME={{3,4},{5},{9},{10}}.首先对ΠENO中的等价类根据其势的大小从小到大排序,得到ΠENO↑={{9,10},{3,4,5}}.然后选取ΠENO↑中的第1个等价类{9,10},在从ΠENO∪ENAME中寻找等价类{9,10}的子集合时,存在冲突的等价类{9,10}的子集合的势必然小于{9,10}的势,即小于2.因此可以从ΠENO∪ENAME中移除势不小于2的等价类,这里满足移除条件的等价类为{3,4},因此可以将其移除,而不影响匹配的结果.表5对ΠENO中等价类排序前后最坏情况下的匹配及判断次数进行了比较.表5等价类排序前后最坏匹配及判断次数比较排序前{3,4,5}4排序后{3,4,5}2从表5可以看出,在最坏情况下,对ΠENO中等价类进行排序后总的匹配次数为5次,判断次数为12次,而不对ΠENO中等价类进行排序直接进行匹配和判断,则需要6次匹配和16次判断,相比较而言,对ΠENO中的等价类根据其势的大小从小到大排序可以明显减少匹配和判断的次数,提高检测效率.在多个函数依赖不一致性检测时,假定待检测函数依赖个数为m,待检测数据分布在n个节点,根据函数依赖个数及节点个数的大小情况不同采用不同的负载分配策略.(1)mn,即函数依赖个数大于等于节点个数,以函数依赖为最小单位进行检测任务的分配,可以保证所有节点均有负载;(2)m<n,即函数依赖个数小于节点个数,此种情况将函数依赖的冲突等价类依据节点个数进行分组,将不同的等价类分组分配到不同的节点进行处理,保证所有节点都有负载,而且使得各节点间的负载尽可能的均衡.对于函数依赖个数大于等于节点个数的情况,可以利用算法2中给出的任务分配策略进行任务分配,使得检测任务的分配尽可能的均衡.对于函数依赖个数小于节点个数的情况,以函数依赖为单位进行任务的分配会出现有些节点负载为空的情况,检测效率不高,本文给出一种函数依赖个数小于节点个数情况下多函数依赖冲突检测任务分配的近似最优算法,具体见算法3.算法3.LoadAllocateByEC.输入:机器集合M={Mi},i∈[1,n],函数依赖集合Σ=输出:FL(1),FL(2),…,FL(m)1.FOREACHi∈[1,m]DO2.FL(i)←{};3.ENDFOR;4.FOREACHi∈[1,m]DO5.FOREACHj∈[1,n]DO6.IF|FL(i)|<n/m&&i<m7.FL(i)←FL(i)∪Mj;8.M←M\Mj;9.ELSEIFi==m//最后剩余的节点分配给最后10.FL(i)←M;11.ENDFOR;12.ENDFOR.算法3的输入为处理机集合M以及待分配函数依赖集合Σ,输出为任务分配结果.为使得待检测Page11函数依赖所分配的执行节点个数尽可能的均衡,对前m-1个待检测FD,算法首先将执行节点个数根据待检测FD个数进行均分,每个待检测FD分配n/m个执行节点,其中m为待检测函数依赖总数,n为节点总数,最后得到的第m个待检测FD所分配的执行节点个数为前面m-1个待检测FD分配后剩余的节点个数.基于以上的分配策略,算法LoadAllocateByEC可以得到近似最优解.对于待检测的函数依赖,假定其检测任务需要分配到不同节点并行进行不一致性检测.在各个节点并行计算局部等价类[t]LHS和[t]LHS∪RHS得到形如〈key,value〉的键值对后,根据t[LHS]值对得到的键值对进行分组,分组基于散列函数进行,输入即散列函数的关键字为t[LHS]值,散列函数的输出由负载该函数依赖的节点个数确定.对于各节点数据预处理得到的键值对,根据散列函数值的分布情况将有着相同散列值的键值对散列到同一执行节点,不同执行节点上的键值对有着不同的散列值.这样可以实现有着相同散列值的键值对在同一个执行节点处理.键值对散列的示意图如图4所示.图4函数依赖局部等价类〈键,值〉对散列示意图图4中ti[X]为Di中元组在属性集合X上的属性值,[ti]X_L为Di中元组在属性值ti[X]上的局部等价类,〈tm_j[X],[tm_j]X_L〉为Dj中键值对集合根据哈希函数散列后散列值为m-1的键值对集合,所有散列值为m-1的键值对被分配到数据分块Pm上.这种散列策略使得有着相同ti[X]的键值对散列到相同的执行节点.根据引理2,只有ti[X]相同的等价类中元组才可能存在冲突,因此图4中的局部等价类分配策略使得所有存在潜在冲突的元组分配到相同的节点,保证了冲突检测的准确性.基于Hadoop平台进行数据处理时,由于数据的特点及分布情况不同,可能会出现默认的分区函数Partitioner()得到的数据分块大小差异较大的情况,这会导致在Reduce阶段负载分配的不均衡,一些Reducer节点负载过大,总耗时取决于耗时最长通常也是负载最大节点的耗时,因此处理效率不高.本文针对Hadoop内核进行修改,在Map阶段,根据partition函数将待检测数据划分成数量多于reducer个数的partition,采用改进的负载均衡贪心算法对得到的partition进行合并,合并后的数据分块数量与执行节点个数即Reducer个数相同,将合并后的数据分块分配到Reducer上,保证每个Reducer处理一个合并后的数据分块,具体算法如算法4所示.算法4.PartitionAllocate.输入:节点集合M={Mi},i∈[1,n],数据分块集合P=输出:A(1),A(2),…,A(n)1.FOREACHi∈[1,n]DO2.A(i)←{};3.ENDFOR;4.Desc(|Pj|);//依据P中数据分块的大小对数据5.假定|P1||P2|…|Pm|;6.FOREACHj∈[1,m]DO7.IFMi是达到最小值min|A(i)|的节点8.A(i)←A(i)∪Pj;9.ENDIF;10.ENDFOR.算法4的输入为节点集合M和待分配的数据分块集合P,输出为数据分块的分配结果,A(i)表示分配给节点Mi的数据分块集合.算法根据待分配数据分块集合中数据块大小对所有数据分块降序排列,然后对排序后的数据分块,找出当前分配的数据规模最小的节点,将当前数据分块分配给该节点,直到所有数据块都分配完成.假定对于函数依赖φ:X→Y,执行节点个数为k,根据算法4中的任务分配策略,每个执行节点可以得到部分冲突元组,所有k个执行节点所得到的关于φ的部分冲突元组的并集即为φ在全局数据上的冲突元组集合,具体如图5所示.根据函数依赖检测任务分配策略,如果函数依赖个数少于节点个数,对每一个待检测函数依赖,有着相同LHS属性值的键值对被散列到相同节点,而根据引理2,潜在冲突的元组其散列值相同,因此Page12图5各执行节点部分冲突元组得到全部冲突元组被散列到同一个节点.对函数依赖φ:X→Y,在各个执行节点,对散列到该节点的所有键值对,根据键中包含的LHS部分(这里为X)属性值是否相同,对所有键值对进行划分,将有着相同LHS属性值的键值对划分到同一个组,得到该LHS部分属性值的等价类.然后根据RHS部分属性值是否相同,将有着相同RHS部分属性值的键值对划分到同一个组,得到关于RHS部分属性值的等价类.根据引理2,对每一个基于LHS部分属性值的等价类,如果其对应的LHS∪RHS属性值等价类个数大于1,则说明其对应的不同LHS∪RHS属性值等价类之间违反函数依赖φ.例11.以表1中EMP的一个实例D0为例,对函数依赖φ1:ENO→ENAME,假定节点个数为2,分别为S1和S2,在散列后分配到节点S1上的在属性集合{ENO}的键值对合并后为〈“E1”,{1,2}〉,〈“E2”,{3,4,5}〉,在属性集合{ENO,ENAME}的键值对合并后为〈“E1_M.Smith”,{1,2}〉,〈“E2_J.Jones”,{3,4}〉,〈“E2_J.Davis”,{5}〉.键值对〈“E2_J.Jones”,{3,4}〉,〈“E2_J.Davis”,{5}〉的LHS属性值相同,RHS属性值不同,根据引理2,等价类{3,4}和{5}为冲突等价类.在节点S2,同理.对于不存在冲突元组,该等价类可以被剪枝掉.冲突等价类子树合并后可以构建出冲突等价类生成树,具体生成过程如图6所示.在函数依赖冲突检测过程中,由于不同节点任务分配情况以及存在冲突情况的不同,可能导致检测过程中负载不均衡情况的出现.为提高检测效率,本文考虑在检测过程中进行动态负载均衡.可以将动态负载均衡时节点间负载迁移情况用有向图G(V,E)的形式表示,V为图的顶点集合,每个顶点代表一个节点,E为有向边的集合,每条边代表节点间负载的迁移关系.假定节点个数为m个,节点Si的当前负载用li表示,当前所有节点的平均负载为l-=∑mli/m,则li-l-为节点Si需要迁移的负载量,i=1图6D0中函数依赖冲突等价类生成树生成过程该值>0,说明负载超出平均负载,反之说明负载低于平均负载.边eij的权重表示从节点Si到Sj的负载迁移量,用εij表示.对i∈[1,m]有∑{jeij∈E}εij=li-l-[2],可得如下线性方程组:由于负载总迁入量和总迁出量相同,在式(1)的m个等式中,如果其中任意m-1个成立,则剩余的那个等式必然成立.假定式(1)中线性方程组的系数矩阵为犃,则r(犃)m-1,根据线性方程组解的性质可知该线性方程组有无穷多解.为减少总的负载迁移量,有必要找出负载迁移量最小的解.假定狓为式(1)中等式左端关于εij的向量,犫为等式右端的列向量,则可将最小化负载迁移量问题归结为如下的二次规划问题[17]:其中:狓T为向量狓的转置,犃为|V|×|E|的矩阵,|V|为图G中顶点个数,|E|为边个数.犃|V|×|E|=Page13[aij]|V|×|E|,aij=上述优化问题为有等式约束的二次规划问题,可采用拉格朗日乘子法求解.可构造拉格朗日函数如下(狓,λ)=1令x(狓,λ)=0,得到狓-犃Tλ=0,即狓=犃Tλ.将x值代入式(2)中,得犃犃Tλ=犫.令犔=犃犃T,可得上述最小化负载迁移量问题转化为式(3)的线性方程组求解问题,求解式(3)得到任一顶点Si的拉格朗日乘子λi,则λi-λj为从节点Si到Sj的负载迁移量.分布式环境多函数依赖冲突检测方法Multi-FDsDetDS如算法5所示.算法5.MultiFDsDetDS.输入:函数依赖集合Σ={φ1,…,φm},D=(D1,…,输出:ViotΠ(φ1,D),ViotΠ(φ2,D),…,ViotΠ(φm,D)1.L←PreDeal(Σ,D);//数据预处理2.IFmn//函数依赖个数大于等于节点个数3.LoadAllocateByFD(M,L);4.FOREACHi∈[1,n]DO5.FOREACH{ΠXj,ΠXj_Yj}∈L(i)DO6.{ΠXj,ΠXj_Yj}←prune(ΠXj,ΠXj_Yj);7.ViotΠ(φj,D)←check(ΠXj,ΠXj_Yj);8.ENDFOR;9.ENDFOR;10.ELSE//函数依赖个数小于节点个数11.LoadAllocateByEC(M,Σ);12.FOREACHj∈[1,m]DO13.FOREACHSk∈L(j)DO14.散列{ΠXj,ΠXj_Yj}对应键值对到Sk;15.Dk←prune(Dk);16.ViotΠ(φj,D)←check(Dk);17.ENDFOR;18.ENDFOR;19.RETURNViotΠ(φ1,D),…,ViotΠ(φm,D).算法5的输入为待检测函数依赖集合Σ、分布式数据D以及处理机集合M,输出为违反函数依赖的元组集合.算法首先在各个节点对局部数据进行预处理,然后根据函数依赖个数与节点个数的大小情况分别处理.如果函数依赖个数大于等于节点个数,则调用LoadAllocateByFD()进行任务分配,然后在每个处理机上根据当前处理机任务分配的情况对待检测函数依赖的等价类生成树进行剪枝,剪枝后检测冲突元组,最终得到所有违反函数依赖的元组;否则调用LoadAllocateByEC()进行任务分配,然后对每个函数依赖,散列所有局部划分对应键值对到执行节点,在执行节点对散列后的键值对合并,进一步对等价类生成树剪枝,最后进行不一致性检测,得到违反函数依赖的元组集合.5实验结果与分析本文使用真实数据集和人工生成的数据集对本文提出的算法进行了实验验证,测试了算法基于节点规模、数据规模和待检测函数依赖规模的扩展性.5.1实验设置(1)实验环境本实验中使用了通过局域网连接构成的由10台服务器组成的集群,每一台服务器配置如下:CPU为英特尔Xeon2,16GB内存,Ubuntu10.4操作系统.算法由Java编写,运行于Hadoop及Hama并行平台.(2)实验数据实验过程中使用两种数据集,其中一个为BureauofTransportationStatistics提供的数据集①,是一个关于航班信息的真实数据集,简称“AOTS”,包含了64个属性,如FlightDate、Carrier、AirlineID、Flight-Num、OriginCityName、DestCityName、TailNum等.数据集包含了15亿条元组,大小为30GB.本文使用该数据集生成一个包含8000万条元组的数据库实例aots8,一个包含1.2亿条元组的数据库实例aots12.另外一种数据集是一个人工生成的文中前面提到的EMP表的数据集,简称“EMP”,包含了2亿条元组.利用数据集EMP生成一个包含8000万条元组的数据库实例emp8,一个包含1.2亿条元组的数据库实例emp12.(3)函数依赖对于真实数据集AOTS,找出一组反映真实约束关系的函数依赖,函数依赖个数为10个,每个包含了2~6个属性,为验证算法的效果,对部分数据人为加入了噪声.对于数据集EMP,定义了10个函数依赖,为了验证实验效果,在生成数据集时增加了部分噪声.①BureauofTransportationStatistics.http://apps.bts.gov/Page145.2实验结果与分析本文设计了3组实验分别对集中式函数依赖冲突检测方法CenDet、基于Hadoop的nave方法MultiFDsDetHadoop以及本文提出的多个函数依赖冲突检测方法MultiFDsDetDS进行验证.为验证方法的节点规模扩展性、数据规模扩展性以及函数依赖规模扩展性,对节点规模(|S|)、数据集规模(|D|)以及函数依赖规模(|Σ|)在不同情况下进行验证.首先评估以上3种检测方法基于节点的扩展性,对每一个数据集选取4个函数依赖进行检测.实验1.改变数据的分片个数.为验证算法节点规模的扩展性,在数据集规模不变的情况下逐渐增加集群节点规模,基于数据集aots8和emp8,对方法的响应时间进行测试.图7(a)和图7(b)反映了方法CenDet、MultiFDsDetHadoop和MultiFDsDetDS在不同节点个数下响应时间情况.不难看出,在数据规模固定的情况下,随着节点规模的增加,方法MultiFDsDetHadoop和MultiFDsDetDS响应时间逐渐减少.而集中式方法CetDet的响应时间则呈增加的趋势,原因是数据规模的增加导致数据迁移量增大,数据迁移耗时增加导致总的响应时间增大.而在同等条件下,方法MultiFDsDetDS的响应时间明显小于MultiFDsDetHadoop,说明与MultiFDsDetHadoop相比,方法MultiFDsDetDS的节点扩展性更好,检测效率更高.其次评估3种检测方法基于数据的扩展性,对每一个数据集选取4个函数依赖进行检测.实验2.改变数据的规模.为评价方法的数据规模扩展性,在保持节点规模(8个)固定的情况下对数据规模进行扩展,从2000万条元组开始,每次增加2000万条,直到12000万条,基于aots12和emp12数据集分别进行验证.图8(a)和图8(b)反映了方法CenDet、MultiFDsDetHadoop和MultiFDsDetDS在数据规模扩展时响应时间的变化.从实验结果不难看出,随着数据规模的扩大,各方法的响应时间呈增加趋势,而分布式方法MultiFDsDetHadoop和Page15MultiFDsDetDS比集中式方法CenDet的响应时间少很多,说明方法MultiFDsDetHadoop和MultiFDs-DetDS的检测效率明显高于集中式方法CenDet.而且从图8(a)和图8(b)可以看出,在不同数据集的情况下,随着数据规模的不断增大,分布式方法MultiFDsDetHadoop和MultiFDsDetDS与CetDet相比,在响应时间方面优势更为明显.而方法Multi-FDsDetDS与MultiFDsDetHadoop相比,在检测效率方面有着明显的提升,而且随着数据规模的增加,这种优势也更加突出,由此可见,本文提出的MultiFDs-DetDS方法在数据扩展性方面明显优于分布式方法MultiFDsDetHadoop和集中式方法CenDet.最后评估3种检测方法基于函数依赖个数的扩展性,集群的节点个数|S|为8.实验3.改变待检测函数依赖的个数.为评价方法在不同数据规模情况下的扩展性,本文在数据规模固定的情况下,增加待检测函数依赖个数|Σ|从1个到8个,分别基于数据集aots12和emp12,对方法的响应时间进行测试.图9(a)和图9(b)反映了方法CenDet、MultiFDsDetHadoop和MultiFDsDetDS在函数依赖规模扩展时的响应时间情况.从图9(a)和图9(b)不难看出,随着函数依赖规模的扩展,各方法的响应时间呈增加趋势.在函数依赖个数相同的情况下,分布式并行方法MultiFDsDetHadoop和MultiFDsDetDS比集中式方法CenDet的检测耗时少很多,说明方法MultiFDsDetHadoop和MultiFDs-DetDS在同等条件下的检测效率明显高于集中式方法CenDet.在不同数据集的情况下,随着函数依赖个数的不断增大,分布式方法MultiFDsDetHadoop和MultiFDsDetDS与CetDet相比,在响应时间方面优势更为明显.而方法MultiFDsDetDS与MultiFDs-DetHadoop相比,检测效率更高,而且随着函数依赖个数的增加,这种优势也更加明显.从本组实验可以看出,本文提出的MultiFDsDetDS方法在函数依赖规模扩展性方面明显优于分布式方法MultiFDsDetHadoop和集中式方法CenDet.前面对本文提出的方法在效率方面基于真实和人工数据集进行了验证.由于本文提出的方法在算法设计时保证所有可能存在相互冲突的元组都被重分布到同一个执行节点进行检测,而且本文基于等价类进行函数依赖冲突检测,论文前面部分通过关于等价类的相关证明以及函数依赖冲突等价类生成树的构建使得函数依赖存在不一致性的元组可以全部被检测出来,因此在实验部分没有必要也不再对本文提出的方法的正确性进行验证.6结论本文研究了分布式大数据背景下多个函数依赖冲突检测的问题.针对分布式环境多函数依赖冲突检测存在的问题,提出了一种基于等价类的分布式并行多函数依赖冲突检测算法.论文主要关注的是分布式大数据背景下多个函数依赖冲突检测的响应时间,给出了分布式大数据背景下多个函数依赖冲突检测的响应时间代价模型,分析了影响多个函数依赖冲突检测响应时间的因素.为提高分布式环境多个函数依赖冲突检测的并行度和检测效率,将检测任务分配问题划归为整数规划问题,并给出了多函数依赖冲突检测任务分配的近似最优算法.针对集群规模和待检测函数依赖个数的不同情况,给出两种检测任务分配策略.为避免检测过程中负载不均衡的情况,在检测过程中动态均衡负载,为减少负载迁移量,将该问题划归为二次规划问题,并采用拉Page16格朗日算子法得到最优解.基于真实数据集和人工数据集对论文提出的多函数依赖冲突检测算法进行了验证,实验结果表明算法在数据规模、节点个数以及函数依赖个数方面扩展性良好,而且在提高检测效率方面优势明显.本文主要研究的是水平切分的数据分布式环境下多函数依赖冲突检测问题,下一步考虑数据垂直切分的情况以及其他完整性约束在分布式环境下的不一致性检测问题.
