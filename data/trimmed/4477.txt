Page1一种面向内核接口的顺序依赖规则挖掘与违例检测方法刘虎球白家驹王蠫屏(清华大学计算机科学与技术系北京100084)摘要内核扩展函数以接口的形式提供给驱动,用于管理设备和申请相关的资源.这些接口中存在大量的顺序依赖规则,如自旋锁必须经过初始化才能加锁,然后才能解锁;驱动在加载时申请的内存,卸载时必须予以释放等.然而,驱动开发者常常不熟悉或疏忽内核接口的使用规则,导致驱动中存在大量的接口使用违例,影响驱动及系统的可靠运行.文中提出了一种面向内核接口的顺序依赖规则挖掘与违例检测方法(SD-Miner).该方法结合驱动源码的结构特征,对驱动代码使用的内核接口进行统计分析,挖掘并提取内核接口的顺序依赖规则,并利用提取的规则检测现有的驱动源码中的使用违例.SD-Miner对Linux3.10.10和2.6.38的驱动源码分别进行了规则挖掘和违例检测.对比检测结果发现,在2.6.38中检测出的错误中,有64处在3.10.10中得到了修正.SD-Miner检测和分析Linux3.10.10的3781款驱动的过程仅耗费5min,共计提取出了220个顺序依赖相关的接口使用规则,并检测到了756个使用违例,作者将其中50个提交给了开发者,累计有25个回复者对20个使用违例进行了确认.实验结果表明,SD-Miner能够有效地挖掘出内核接口的顺序依赖规则,并检测出使用违例,进而辅助开发人员对驱动进行修正来提高驱动可靠性.此外,规则的挖掘是基于驱动的结构信息和统计信息,不需要开发者在源码中提供额外的注释及标注.关键词内核扩展函数;规则挖掘;违例检测;顺序依赖规则1引言驱动的可靠性对操作系统的稳定运行具有重要意义.统计结果表明,驱动所引发的错误是内核的3~7倍[1],即使在成熟的商业操作系统XP中,也有85%的崩溃与驱动相关[2].由于驱动是由不同的组织和机构编写,这些错误在大多数情况是由于接口规则过于复杂,开发者对内核提供的接口缺乏足够的了解,常常忘记或者疏忽接口的使用规范和调用规则,从而造成大量的使用违例,使得大量错误隐藏在驱动源码中.如图1所示,Linux驱动8250(版本3.10.10,driver/tty/serial/8250/8250_dw.c)在加载时将调用函数dw8250_probe.该加载函数调用devm_ioremap、devm_kzalloc、clk_prepare_enable等接口函数,并且上述部分函数在调用时存在直接的调用顺序依赖关系.如devm_kzalloc必须在clk_prepare_enable之前被调用,否则将出现使用违例.同样,在驱动卸载时,需要调用配对的接口函数将加载时申请的资源进行释放.如调用pm_runtime_disable来关闭231253258263264287293294297299305307308310311314}staticintdw8250_remove(structplatform_devicepdev){serial8250_unregister_port(data->line);if(!IS_ERR(data->clk))staticintdw8250_probe(structplatform_devicepdev){xxx=devm_ioremap(&pdev->dev,regs->start…);if(!IS_ERR(data->clk))}在加载时通过pm_runtime_enable激活的设备,本文中将此类函数称为配对函数.另外,在卸载时执行的接口函数调用顺序与加载时调用的函数顺序同样存在关联,如加载时先执行pm_runtime_set_active,则在卸载时后执行其配对函数pm_runtime_put_noidle.值得一提的是,在图中,卸载时没有调用devm_kfree来释放在加载时通过devm_kzalloc申请的内存,因此存在使用违例,执行到此处时会引发内存泄漏.另一方面,驱动中存在大量的互斥或互补性操作[2],操作时需要遵守许多与使用顺序相关的接口使用规则,我们称之为顺序依赖规则.为便于描述,将互斥或互补操作使用符号P(Probe,加载)、R(Remove,卸载)表示,并称P/R为对偶操作.与之关联的顺序依赖规则主要涵盖以下3个方面:(1)P操作调用的接口函数需要遵守顺序依赖规则,如图1中的devm_kzalloc必须在clk_prepare_enable之前被调用;(2)R操作需要调用配对的接口函数来释放P操作中申请的资源等;(3)R操作中调用的配对的接口函数需要遵守P操作中逆向的顺序依赖规则.上述3类顺序依赖规则普遍存在于驱动中,如在P操作中,使用自旋锁需要遵守初始化spin_lock_init→spin_lock→spin_unlock的使用顺序,对设备的初始化一般遵循申请内存kmalloc→地址映射ioremap→设备激活pci_enable_device等顺序.而在P中调用一些接口函数后,在R操作中则需要调用这些接口的配对函数完成资源的回收操作,如kmalloc与kfree、ioremap与iounmap、pci_enable_device与pci_disable_device等.在R操作中使用的这些配对函数的序列同样存在顺序依赖,依然针对上述调用序列来说,在卸载时需要遵守的顺序依赖规则为:失效设备pci_disable_device→取消地址映Page3射iounmap→释放申请的内存kfree.然而,由于操作系统中缺乏上述顺序依赖规则相关的规范文档,加上开发者对文档的查阅热情较低,导致驱动开发者容易出现使用违例.因此对驱动源码进行检测并自动提取其中的使用规则,将有利于规范接口函数的使用.目前,直接针对驱动源码进行错误查找和分析的研究方法主要集中在检测代码中的类型、指针等错误[3],或者针对具体的单一的资源的使用规则进行违例检测[4];也有一些研究者使用数据挖掘的手段尝试提取大规模软件中的一些使用规范[5].但是目前的这些研究方法都局限在一种操作内部或者单个函数内的调用序列上,不能针对上述跨函数之间的顺序依赖规则进行解析.本文提出一种面向内核接口的顺序依赖规则挖掘与违例检测方法(SD-Miner).该方法结合驱动源码的结构特征对驱动代码使用的内核接口进行统计分析,利用统计信息挖掘并提取内核接口的顺序依赖规则,并利用提取的规则检测现有驱动源码中的使用违例,辅助提高驱动可靠性,并且不需要开发者提供额外的注释及标注.相比传统方法具备以下优势:(1)不需要用户定义具体的接口使用规则,根据统计信息进行挖掘并检测序列化规则;(2)跨函数直接进行接口的使用规范提取;(3)结合驱动的结构信息和统计信息,无需程序提供额外的标注.本文第2节主要介绍国内外关于驱动相关的规则检测和分析的研究现状;第3节阐述了SD-Miner的具体设计与实现过程;第4节对SD-Miner进行了评测;第5节对全文进行了简要总结.2相关工作尽管有许多提高驱动可靠性的方法,如FGFT[6]、SymDrive[7]等,但对驱动代码的使用规范检查,仍旧集中在传统的错误检测、驱动开发规范和自动合成等方面,如指针错误检测[8]、整型数据检测KINT[3]等.而在规则检测与挖掘方面,主要包括配对规则的挖掘[9]和API规则挖掘[10]等.下面将结合具体的研究方法进行简单阐述.LXFI[11]根据程序员的标注,将接口的使用规则内嵌在修改后的接口中,使得驱动模块在发生错误时不会扩散成安全漏洞,用以抵御特权攻击.KFUR[4]同样是通过修改原有的内核扩展函数,将需要遵守的规则内嵌到接口函数中,在执行接口函数之前自动执行规则检查.Dingo[12]针对文档的不规范和语义混淆问题,提出了一种基于协议状态自动机的设备描述协议Tingu,可以直接辅助开发人员开发设备驱动,但是该方法需要重写所有驱动.Termite[13]可以在上述基础上自动合成设备驱动,但生成的驱动代码量较大,效率较低.以上方法所使用的接口使用规范都需要开发人员定义并书写,并且仍基于锁等单一资源,规则也相对较为单一.所以部分研究者提出了使用挖掘的方法提取源码中的规则.Engler等人[9]通过分析提取调用的API,并根据调用的上下文反推与之关联的变量和函数等,如spin_unlock函数的调用前提是已经成功执行了spin_lock函数、指针在使用前需要初始化等.MAPO[14]则利用已有的代码根据当前输入的代码对所使用的API给出相应的提示,其中包括关联函数,如fopen与fclose等.以上规则虽然都与配对函数的挖掘相关,但是不能直接提取跨函数之间的接口函数使用时需要遵循的顺序依赖规则.PR-Miner[5]利用数据挖掘的方法,对一个函数内部可能调用的函数进行统计分析,提取潜在的最长的顺序调用序列,然后将提取的调用序列进行进一步分析并提取出使用规则,最后结合提取的规则对驱动源码进行违例检测.但该方法要求代码的统计与重复度较大,无法提取一些低频的顺序依赖相关的接口使用规则.CAR-Miner[15]利用Java和C++的异常机制,在异常处理时对已经申请的资源和与之关联的序列规则进行检测,进而发现其中的资源未被释放等问题.WN-Miner[16]提出了一种使用规则的挖掘方法,基于程序的控制流对异常路径中的一些使用规则进行检查,定位其中的使用异常.iComment[17]利用程序中的注释,利于自然语言学习的方法,结合机器学习和统计方法,从注释中提取规则,进而结合源码的上下文进行分析,发现程序中注释与源码的上下文不一致之处,并分析和报告给开发人员.aComment[18]在注释的基础上,结合了代码中的中断敏感函数,通过推导得到进入和离开函数时的中断开闭状态,进而发现源码与注释中关于中断开闭的约定与实际不一致的问题.还有部分方法[19-20]针对大规模软件,通过数据分析和挖掘的方法,提取其中的API使用规则或使用规范等,部分方法也利用提取的规范进行违例检测[21]和辅助进行程序开发[22].上述方法在提取使用规范的过程中,常常局限Page4于特定的一种规则或针对单一的资源,而基于统计的挖掘方法则要求重复的频度较高.实际上,驱动具有较好的结构信息[23].根据结构信息推导,在降低统计阈值的同时,还可以大大提高提取的规则的准确性.SD-Miner结合驱动的结构特征,利用统计方法对文中提及的三类接口调用顺序依赖规则进行提取和分析,在提升驱动可靠性的同时,无需程序员在源码中添加特殊的标注信息,也不再局限于特定的单一资源.3规则提取与违例检测SD-Miner结合驱动源码,利用统计方法对驱动中的顺序依赖规则进行提取.在本节中,3.1节简要介绍了SD-Miner的总体框架,3.2节简要介绍了SD-Miner所需的理论模型,并在3.3节中给出了SD-Miner的规则挖掘的实现原理,第3.4节给出了基于挖掘出的规则实施的违例检测,第3.5节对系统的误报与漏报的优化技术进行了分析.3.1总体框架为了完成顺序依赖规则的提取,SD-Miner首先需要定位驱动中的P、R操作,然后分别提取P、R操作中接口函数的调用序列,再结合函数的返回值和参数信息,分析调用序列的内部依赖关系和P、R操作中的配对函数.根据依赖关系来统计并提取出P操作中的顺序依赖规则,然后根据该顺序依赖规则对R操作中的逆向操作进行检查和分析,定位R操作中的使用违例,将违例进行误报和漏报过滤后以潜在的软件错误形式提交.为完成上述目标,SD-Miner需要执行图2中的主体执行流程,具体的细分步骤在下文中进行阐述.定位P、R操作集.SD-Miner面向驱动源码对顺序依赖规则进行挖掘和检测,检测驱动对象是否存在关联依赖的P、R操作.根据之前的定义,P、R操作针对驱动设备执行相反的功能,如加载与卸载、休眠与唤醒等.通过定位成对的P、R操作对应的函数,从而形成P、R操作集.提取调用序列.驱动执行P、R操作时需要大量调用内核提供给驱动模块使用的接口函数,本文提取的顺序依赖规则主要面向内核的接口函数.因此在该步骤中,主要根据P、R操作集提取其中的潜在调用序列.关联依赖关系挖掘.针对提取的调用序列,通过分析各个接口函数的参数和返回值提取序列内接口函数之间的参数、返回值依赖,为后续的结构推导和统计提供支持.根据提取的依赖关系对调用序列的顺序依赖进行初步标定.配对函数提取.对P、R操作使用的接口函数进行统计分离,结合驱动中的路径和结构推导的信息,将P、R操作间成对使用的接口函数进行统计,进而提取出配对函数.顺序依赖提取.对P操作中使用的函数调用序列进行分析,根据关联依赖关系提取调用序列之间接口函数的顺序依赖关系,并结合统计信息提取顺序依赖规则,便于后续的违例检测.违例检测.根据提取的顺序依赖规则,对驱动的源码再次进行检查,从而定位驱动在调用接口时违反顺序依赖的位置,通过一系列误报与漏报优化分析技术,分离出违例中真正的代码错误.3.2理论模型为了完成配对依赖规则的挖掘,并根据提取的规则进行违例检测,我们首先提出了一个理论模型对挖掘的过程进行分析.SD-Miner基于以下理论模型进行实现,为了清晰地对模型进行说明,首先对模型需要使用的符号集进行定义并介绍.P、R操作集.该集合存储了一系列成对的P、R操作.我们使用符号O来表示该操作的集合,其中Op和Or分别表示P操作集和R操作集.由于P、R是成对存在的,因此O的每一个元素即为Op和Or的元素对:假定共有N对P、R操作,则调用序列.在每个操作中均调用了一系列的接口函数,使用符号Cp和Cr分别表示P操作和R操作中使用的接口调用序列.对于第i对(Oi用序列表示为CiPage5由于每个序列中包含多个函数,因此使用Cir[j]分别表示调用序列中的第j个元素,被和Ci调用的函数的相关属性均被存储在Ci函数名称(FuncName)、返回值类型(RetType)、返回值名称(RetName)、参数类型(ParType)、参数名称(ParName)等,并引入操作GetValue对上述属性进行获取,如通过GetValue(Ci获得函数名称.如果函数的返回值类型为空,则GetValue(Ci决策函数.决策函数用于结合结构推导信息,辅助判定两个潜在的配对函数之间存在的配对可能性.该函数输入分别为Ci两者存在的配对可能性,使用符号Fd来表示.经过决策函数后,可以定位出一些潜在的配对函数,使用符号Pp表示.选择函数.选择函数是指根据决策函数的结果,结合统计信息,从潜在的配对函数中选择出可能性比较大的配对函数,使用符号Fs来表示.选择函数和决策函数参考了文献[24]已有的研究工作.配对函数.在P、R操作中调用的接口函数中存在大量的需要成对使用的函数,完成互补或相反的功能.使用符号Pf来表示配对函数的集合.同样Pf中的每一个元素包含一对具体的配对函数,分别表示为Pi要满足如下约束条件,即为描述方便,引入函数fp(Pi的配对函数,一般情况下:Pi个函数存在的配对函数多于一个时,fp(Pi回配对集合,并默认使用配对频数最高的配对函数.顺序依赖规则集.对P操作中的调用序列Ci进行统计分析,获得调用序列,结合关联依赖关系对调用序列进行挖掘分析,提取顺序相关的调用序列,使用符号Sr来表示,规则集中的第i个元素以Si表示.并且每个元素包含了一条P操作中的顺序依赖规则,每一条规则所包含的接口函数数目是不确定的,我们引入len函数用于描述一个序列的长度,如len(Si口函数的个数.到的违例在统计信息中的可信度,使用p(Pi可信度估计函数.可信度估计函数用于评估检测f[2])来表示.当函数PiPif[2]没有被R操作调用,可以用可信度估计函数Pi数估算到该违例可以被信任的可信度.为了便于后续描述,用符号Ft来表示统计的频数,其输入为两个函数,输出为两者共同出现频数.如Ft(Pi现的频数.而Pi方式进行统计,即由于一个函数可能存在多个配对函数,因此f[1]累计出现的配对频数可以表示为PiFt(Pip(Pi结合Ft,根据统计原理,将违例的可信度f[1]→Pip(Pi通过上述公式可以得出,当配对的频数越高,则发生违例时,该违例的可信度越大,但是存在局部统计信息与全局不对称的问题.即假定当一对配对函数本身出现的频数较小时,根据式(9)将同样可以得出可信度较大的结论.事实上这不是绝对的,因此将式(9)进行变换,综合考虑全局的配对可能性,假定配对频数最大值为Fmaxp(Pif[1]→PiFt(PiFt(Pi其中,λ1和λ2的值默认为0.5,通过式(10)综合权衡了配对函数自身发生违例的局部可信性,以及在配对函数自身在全局中出现的可能性.结合P操作中的顺序依赖规则与R操作中的配对依赖规则,得出R操作中的使用违例主要包括以下3种情况:使用规则;(1)P操作调用Pi(2)P操作中调用了Pi作中没有调用Pi(3)在R操作中调用了Pi操作顺序依赖的逆向使用规则.实践证明,以上3种情况在实际中都存在,分别对应SD-Miner的3类顺序依赖规则.其中,第1种仅仅与P操作相关,通过转换,和配对函数的统计Page6与检测存在较大相似性,将在后面章节进行详细介绍;第2种情况可以等同于配对函数规则的使用违例;而第3种情况中,违例可信的可信度应当综合考虑以下几个方面的因素:(1)P操作中被调用函数之间的顺序依赖可(2)P、R之间操作的配对可信度;(3)R操作中被调用函数自身需要配对使用的综合考虑以上因素,顺序依赖规则Sr的违例可可信度.以通过式(11)~(13)进行描述:(Pi1f[1],Pi1R操作将调用与P操作中对应的配对函数,并满足顺序依赖规则,该顺序依赖规则的应用场景表现为如下形式:j1<j2,Pi1Si如果在R中,Pi1信度;用,则在Cik1<k2,Pi1如果式(13)成立,则定位到了一处关于顺序依赖规则Si合.结合以上理论模型,下面将按照总体框架图2的主体流程对SD-Miner进行实现.3.3规则挖掘的实现原理本节将详细介绍上述一些关键模块的实现流程.3.3.1节将对接口参数和接口函数的模糊定位方法进行介绍,3.3.2节将介绍P操作内部的顺序关联规则的统计方法,而在3.3.3节中,将给出在对偶操作中使用到的配对依赖规则.3.3.1接口参数和接口函数的模糊定位本文针对的检测和处理对象主体是执行相反或互补功能的P、R操作,因此SD-Miner首先要求正确地定位到驱动中的P、R操作集Op和Or.驱动自身具有较好的结构性特征,根据总线要求,提供正确的交互接口.该交互接口中,包含有大量的满足SD-Miner要求的P、R操作.Kadav等人[25]指出,PCI驱动占据了Linux驱动的36%,USB驱动占据了35%,并且与驱动加载和初始化等配置相关的代码占据了每款驱动51%的代码,该部分代码正是SD-Miner的重点检测对象.PCI驱动和USB驱动都需要依赖总线挂载到系统中,总线对每款设备驱动都要求实现一个统一的接口,并在接口中规定了一些P操作和R操作.如图3所示,每款PCI设备驱动都需要实现一个pci_driver驱动结构,内部包含加载(probe)P函数指针、卸载(remove)R函数指针.12345678SD-Miner根据总线结构对驱动的结构进行分析和推导,定位到驱动中对应的P操作和R操作函数.SD-Miner根据pci_driver的结构特征,提取其中的probe和remove函数,将函数所在的文件和函数名称记录到Op和Or操作集中.USB驱动同样存在较好的结构特征,如图4所示,每个USB设备需要支持热插拔,因而需要实现动态的加载和卸载功能,对应usb_driver的probe和disconnect函数指针.当驱动对上述函数指针完成赋值时,所赋值的函数即作为SD-Miner检测的对象.12345678除了USB、PCI驱动,还有许多驱动存在共同的结构体,如platform_driver类驱动.通过分析驱动的源码,结合驱动的结构特征,以函数指针名中赋值关键字匹配并定位操作集.在SD-Miner中,通过指定执行相反或互斥功能的函数指针,如识别“probe”、“remove”和“disconnect”等关键字,并辅以函数指针的赋值特征和驱动的总线接口类型来定位驱动加载和卸载函数,并将成对的操作函数记录到P、R操作集.一对P、R操作会调用一系列的接口函数来完成指定的功能,如在P操作中,常见操作包括申请内存、创建设备文件、绑定端口、激活设备等.而在R操作中,常见操作包括:关闭设备、解除端口、移除设备文件、释放内存等.两者调用的接口函数互为对偶函数,由于接口函数较多,功能各异,加之文档缺失,Page7因此使用规则无法直接获得,SD-Miner尝试结合结构特征和统计信息提取接口函数中的使用规则.P操作和R操作的功能相反,因此在调用接口函数时,如果存在关联依赖,则在使用次序上要满足以下约束.约束1.在P操作中先执行的顺序依赖相关的接口函数,其对偶函数在R操作中反而后执行.由于P操作调用的接口序列并非全部存在顺序依赖,因此在R操作中,对偶函数的整个调用序列并不唯一,只有存在顺序依赖的接口函数在直接使用时需要满足约束1.3.3.2节将对P、R操作之间的配对函数挖掘进行介绍,而在第3.3.3节中将对函数内部的顺序规则的统计和提取方法予以介绍.3.3.2统计P/R操作之间的配对依赖规则大部分接口函数都是由内核开发者编写,因此接口函数的命名较为规范,结合函数的名字和参数可以对函数的功能进行识别.SD-Miner通过提取函数名字中的关键字段特征,对决策函数Fd和选择函数Fs予以具体实现.对配对的接口函数的识别关键在于定位出执行相反功能的潜在配对函数,参考一些已有的研究工作[24],结合本文的具体情况,将配对挖掘的方法可以直接予以使用.P操作和R操作中如果出现一对互斥关键字,且作用在同类对象上,该对函数将被加入到Pp中,并且,如果该对函数已经存在,则将其频数累加1次.同时,在不同的P、R操作之间,还可以通过结构推导选择出潜在的配对函数.如果P操作、R操作中分别仅调用了一个接口函数,则两个函数自成配对函数,即同样,当存在两个同类操作集之间的差值为一个函数,以CiC1tp=Ci结合式(14)和(15),对操作集之间任意个集合之间进行差值运算,运算结果满足式(15)函数的同样会被加入潜在的配对函数集中.通过上述步骤,潜在的配对函数被记录在Pp集中.然后遍历Cp和Cr,统计Pp中的潜在配对函数成对出现的频数,再利用Fs对Pp进行选择.3.3.3统计函数内部的函数使用顺序关联调用序列的顺序依赖关系主要体现在接口函数执行的逻辑次序.如设备激活之前,常常需要申请内存保存设备的状态等信息,因此存在顺序依赖.在P、R操作内部,都存在顺序依赖规则关联,由于R操作的顺序依赖规则与P操作中的顺序依赖关系存在关联性,因此SD-Miner将问题转换成了P操作内部的顺序依赖规则提取和P、R操作之间的配对函数提取.接口函数之间的逻辑次序关系存在多种情况,如图5所示,图中描述了常见的接口函数之间的依赖关系,图中a~g表示接口函数.图5(a)中描述了在P操作中,所有调用的接口函数存在线性依赖关系,即驱动必须使用完a才能使用b,以此类推.对于该类规则,根据约束1的要求,如果a~g存在与之配对的函数,并假定函数名称为Pa~Pg,即a与Pa是一对配对函数,以此类推,则在R操作中的调用顺序唯一,如图6(a).图5(b)中的P操作同样调用了函数a~g,但是函数之间的依赖关系分离在3条独立的规则之中,即P操作在执行时,只需分别保证每条独立规则的有序性,而规则之间没有先后关系,如函数a只需在函数b和函数c之前被调用,而与函数d、e、f、g的位置无关.同样,根据约束1的要求,在R操作中该顺序依赖体现在,R操作调用a~g的配对的接口函数Pa~Pg时只需遵守3条反向的依赖规则,如图6(b)所示.Page8在图5(c)中,P操作调用的函数序列之间的依赖关系较为复杂,称为依赖关系图.事实上,图5(a)和图5(b)是图5(c)中图状依赖的特例,因此SD-Miner在实现顺序依赖挖掘时,使用了图来存储序列内部的依赖关系.同样根据约束1的要求,R操作中调用的序列需要遵守图6(c)中的约束.通过对比图5(a)~(c)和图6(a)~(c)可以发现,图6中的子图分别是图5子图的反向图,并且R操作调用的序列只要满足图6中的拓扑排序,即为一个正确的调用序列.换言之,通过挖掘P操作中的顺序依赖规则,针对R操作,存在以下约束.约束2.若R操作中调用的接口函数序列是P操作的依赖关系图的反向图的一个拓扑排序序列,则该调用序列是合法的.至此,关键问题在于如何统计和提取出P操作中的顺序依赖规则.假定调用序列中两个函数a、b,并且a先于b被P操作调用,则a、b如果存在关联约束,主要存在以下4种关联:(1)函数a的返回值被b使用;(2)函数a、b的参数存在关联性;(3)函数a、b的返回值存在关联;(4)函数a、b的使用逻辑上存在先后.其中,第1~3种可以通过提取P操作中接口函数的返回值和参数,进而分析返回值和参数的关联关系,辅助以统计信息来实现.仍以图1为例,第258行调用devm_kzalloc申请内存空间并清零,将返回的内存空间起始地址存储在data指针变量中;第264行clk_prepare_enable函数使用到了data的成员变量,属于第1种关联,即devm_kzalloc函数必须先于clk_prepare_enable函数被调用.第287行调用了函数serial8250_register_8250_port,该函数的返回值使用到了data的成员变量,因此该函数与devm_kzalloc存在上述第3种关联,并且同样必须先调用devm_kzalloc函数.但是,尽管clk_prepare_enable函数与关联性serial8250_register_8250_port存在第2种关联,但是实际使用中并不要求严格的先后执行次序.1607…163216791724…1754而第4种关联并不能直接通过函数内部的调用关系予以直观推导,因此SD-Miner通过统计函数a、b之间的顺序依赖频数来提取顺序依赖规则.如图7所示,函数twl_probe调用了scsi_host_alloc、scsi_add_host、scsi_scan_host等函数,其中scsi_host_alloc和后两者存在返回值与参数之间的直接依赖关系.而scsi_add_host和scsi_scan_host之间属于第4种依赖,同时存在参数关联,SD-Miner统计两者的先后出现次序累计出现了39次,并且两者拥有相同的参数约束,scsi_host_alloc、scsi_add_host、scsi_scan_host三者构成了一条顺序依赖约束.SD-Miner首先定位一个P操作函数内部调用的所有接口函数,根据上述4类依赖,建立单个函数的关系依赖图,再结合统计信息,从所有的关系依赖图中提取频度较高的顺序依赖规则.然后根据P操作中的顺序依赖关系图来判定R操作的序列是否满足是P操作中顺序依赖关系图的反向图的一个拓扑排序序列.3.4违例检测与实现SD-Miner的主要任务之一是定位驱动中的使用违例,即寻找驱动中违反顺序依赖规则的用例.其中包括P操作中的顺序依赖规则的使用违例、P操作和R操作中配对依赖规则的使用违例、R操作中顺序依赖规则的使用违例.3.4.1P操作中顺序依赖规则使用违例通过统计分析,提取出了P操作内部的顺序依赖规则,即P操作内部需要遵守的接口函数调用顺序.如之前提到的scsi_host_alloc、scsi_add_host、scsi_scan_host三者构成了一条顺序依赖约束.当P操作调用scsi_host_alloc时,在后续流程中,一般需要调用scsi_add_host,进而调用scsi_scan_host,否则SD-Miner认定出现使用违例.如图8所示,sbp2_probe(3.10.10,driver/firewire/sbp2.c)函数调用了前两者完成host的申请和加载工作,却并没有执行scsi_scan_host函数,因此判定这是一个使用违例.值得一提的是,由于在命名上部分函数进行了私有实现,对原有的接口函数增加了前缀或后缀,对于该种情况SD-Miner参考参数等信息进行了模糊处理,进而减少误报.1133115011651205Page93.4.2P操作与R操作中配对依赖规则使用违例R操作依赖将P操作的配对函数对申请的资源进行释放,SD-Miner根据3.3.2中的挖掘的配对依赖规则并结合P操作调用的函数列表对R操作进行检查.对于一对配对函数如果在P中调用了其中的一个,而R操作中没有与其对应的的配对函数,则被视为使用违例.举例来说,P操作函数smtcfb_pci_probe(Linux3.10.10,drivers/staging/sm7xxfb/sm7xxfb.c)调用了pci_enable_device函数.但是在对应的R操作函数smtcfb_pci_remove中,并没有调用pci_disable_device函数,所以存在使用违例.对于这种配对函数相关的顺序依赖规则,SD-Miner通过对P操作中的接口函数来定位,进而检查在R操作中是否出现了相应的配对函数.为减少误报,当检查到相应的使用违例时,SD-Miner使用了一系列方法进行误报和漏报优化,具体在3.5节中进行介绍.3.4.3R操作中顺序依赖规则使用违例结合P操作的顺序依赖规则和P/R操作之间的配对依赖关系及约束2的要求,根据P操作的顺序依赖关系图构造反向图,然后参考配对依赖关系,对R操作中的顺序依赖规则进行检测,定位其中的使用违例.再结合拓扑排序算法理论对该检测算法按照算法1进行实现.算法1.R操作中违例检测算法SrCheck.输入:Gi表示关于Oi输出:V表示规则使用违例集1.Vertex=Gi->Vertex;2.Edge=Gi->Edge;3.FLAG=new(len(Vertex));4.FORvINVertex5.FLAG[v]=;6.FORcINCi7.IF(pair=Pf(c))≠8.FLAG[pair]=c;9.DFS-visit(pair,FLAG,Pf,Ci10.RETURNV;算法1按照R操作的调用顺序对每个接口函数进行检查,需要使用到改进的DFS-visit实现拓扑序列的验证,将验证pair在其子节点中是否存在配对依赖规则的使用违例和顺序依赖规则的使用违例,具体实现如过程1所示.过程1.子节点遍历检查.DFS-visit(pair,FLAG[],Pf,Ci/输入输出的参数含义与SrCheck中介绍的一致/1.FORvINpair.Vertex//访问pair的邻接点2.IFfp(v)∩Ci3./顺序依赖规则的使用违例,追加到V/4.ELSEIFfp(v)∩Ci5./配对依赖规则的使用违例,追加到V/6.DFS-visit(v,FLAG,Pf,Ci过程1对P、R操作之间的配对依赖规则和R操作需要遵守的顺序依赖规则进行使用违例的检测,并将检测结果记录在V中,特别指出的是,由于可能存在重复的违例,在追加时,出现完全重复的违例将被忽略.由于fp(v)返回的是v的配对集合,因此判定FLAG[fp(v)]是否为空时,实际上只需集合中的任意一个元素不为空即可.3.5误报与漏报优化任何静态方法都存在一定的误报和漏报,SD-Miner结合驱动自身的结构特征,采取了一系列方法,对检测到的违例进行优化,主要包括进入被调用私有接口函数进行确认、建立白黑名单机制、实现对接口函数的模糊匹配.部分驱动在实现P、R操作时并没有直接调用内核提供的接口函数,而是采用了私有接口或同类驱动的共同的私有接口.而这些私有接口的实现并没有内核接口规范,因此出现了较多P操作调用内核接口,而R操作使用私有接口的情况.针对该问题,SD-Miner在发现使用违例时将进入R操作中的私有接口函数内部进行搜索和确认.但为了减少搜索和确认的复杂性,仅搜索直接被R操作调用的私有接口函数.在内核提供的接口中也存在一些函数用于驱动获取内核的数据结构或获取设备状态等,如pr_info等.对这些接口函数的使用在理论上没有约束,为减少对规则提取的干扰,SD-Miner同样支持白黑名单机制,对一些无需配对的函数直接去除,不加入统计范畴,同时也不进行违例检测.针对一些统计频数较低,但又较为重要的配对函数,支持将其加入白名单进行强制检查.同时,SD-Miner对接口函数采用模糊匹配的方式,减少误报,如图8中提到的scsi_add_host函数.另外,在配对依赖规则的挖掘上同样支持对接口Page10函数进行模糊匹配,如alloc_etherdev与free_netdev函数,SD-Miner的决策函数会将etherdev等价于netdev进行处理.4实验分析本节将对SD-Miner的实验进行分析和介绍,对SD-Miner的规则挖掘能力和违例检测能力进行评测.本文采用的编程分析环境如表1.其中,第4.1小节将对工具的运算耗时和复杂性进行分析;第4.2小节中对从Linux中提取的顺序依赖相关的规则进行介绍;在第4.3小节中,SD-Miner对Linux的高低版本分别进行评测,通过评测结果来验证其真实违例的检测能力;本节的最后对当前较新的Linux版本进行检测和分析.指标参数Inteli3-3220,3.30GHz4GDDR31T,7200rps4.1计算复杂性与耗时分析SD-Miner需要对P、R操作集两两函数之间进行关联性挖掘和分析,针对P操作内部的每一个函数需要分析与其他函数之间的顺序依赖关系,以及分析与对应的R操作内部的每一个函数之间的配对依赖关系.假定共有N对P、R操作,每个操作平均调用了M个函数,据此对运算的复杂性进行估计,则规则分析需要的操作估计达到N×M×M次函数匹配.在违例检测时也需要再次扫描P、R操作中的每个函数,时间与挖掘分析时间基本相当,但是对于M个函数而言,假定序列规则的平均长度为L,则DFS-visit本身时间复杂度约为θ(ML),由于L为常数,因此分析的总操作次数规模在θ(N×M3).SD-Miner共计耗时2min对Linux3.10.10的驱动进行规则挖掘,并花费1min对规则进行优化和分析,结合优化后的结果,花费2min对驱动进行了违例检查,以上累计耗时5min.4.2Linux源码中规则挖掘分析SD-Miner利用本文中提到的挖掘方法,针对Linux3.10.10驱动程序中的3类顺序依赖相关的规则进行了提取.利用probe/remove、probe/disconnect等,累计对3781对P、R操作进行了分析,从驱动源码中共计提取出了171对配对依赖相关的规则,从P操作中提取了49条顺序依赖规则.部分重要的P操作中的顺序依赖规则如表2所示,以scsi_host_alloc、scsi_add_host、scsi_scan_host为例,三者之间分别构成顺序依赖关系.表中每个单元内的括号内表示统计的频数,而表中每行列出的是规则中的前3个函数,并且顺序依赖关系是“函数1→函数2→函数3”.规则函数1hostscsi_host_allocscsi_add_hostscsi_scan_hostusbusb_create_hcdhcd_to_ehciusb_add_hcdsoundsnd_card_createsnd_card_set_devsnd_card_register根据该顺序依赖规则,如果P操作中调用不完整或R操作中的配对函数的调用次序不满足此顺序依赖关系图的反向图的拓扑排序,则视为违例.在配对依赖规则方面,共计提取了49对顺序依赖规则,其中频数与配对函数的数目之间的关系如图9所示,其中频数高于50的顺序依赖规则共计3条.图9频数(横)与配对依赖规则的数目(纵)关系4.3不同版本潜在的修正的bug对比过以下方式对其进行测试和验证:为了验证SD-Miner的违例异常检测能力,通(1)以Linux2.6.38的源码作为分析对象,通过挖掘和分析提取相应的规则,进而定位其中的顺序依赖相关的使用违例;过同样的方式对系统的违例进行分析和检测;(2)以Linux3.10.10的源码作为分析对象,通(3)对比两者之间的检测结果,找出在2.6.38中出现而在3.10.10中被修正的使用违例.通过分析,共定位了64个在2.6.38中出现的违例,它们在3.10.10中已经被修正.其中部分重要的违例如表3所示,以P操作ax_probe函数(Linux2.6.38,drivers/net/ax88796.c)为例,在P操作中调用了request_mem_region函数,该函数存在配对使用的函数release_mem_region,但是在R操作中并未调用该函数对request_mem_region申请的内存资源进行释放,该种情况下可能造成内存泄露.该Page11问题在Linux3.10.10中已经被修复,并且在cgit的提交日志中,提到修复的原因为“ax88796:clean表3部分犘/犚操作中的配对相关的顺序依赖规则P操作函数关键函数R操作中配对函数drivers/net/ax88796.cdrivers/hid/hid-wacom.cdrivers/watchdog/omap_wdt.comap_wdt_probepm_runtime_enablepm_runtime_disableFixthemismatchofunmapIOmemorydrivers/staging/xgifb/XGI_main_26.cxgifb_probeioremap表3中给出了部分已经被修正的BUG,其中修正的日志中大都明确给出了错误的原因,和SD-Miner定位该类违例的初衷一致,该实验表明,SD-Miner能够准确定位到一些比较重要的BUG,下面将对新版本的驱动源码进行违例检测.4.4较新版本中存在的bugSD-Miner选取了当前较新的Linux内核3.10.10作为评测版本,通过静态分析,基于提取的49条P操作内部的顺序依赖规则,以及171个P、R操作之间配对依赖相关的顺序依赖规则,定位到了756个使用违例.按照驱动的类别进行分类,违例在各类驱动的分布如图10所示,从图中可以看出,4类驱动所含违例总数占总的23.3%,人工分析以太网(ethernet)相关的40处违例,内含不规范使用10处警告,发现漏报1处,误报1处.事实上,一些关键设备驱动中仍旧存在一些使用违例,如USB网络设备驱动中P操作usbnet_probe函数调用了pm_runtime_enable函数,但是在R操作中没有调用pm_runtime_disable函数执行相反的操作.在提取的违例检测结果中,将定位到的其中50个错误以潜在的BUG形式提交给了相关的开发人员,至今累计25个开发人员回复了我们的报告,其中20个错误被确认,部分被确认的BUG如表4所示.表4中给出了违例发生的关联函数和宿主函数.需要特别指出的是,SD-Miner与PF-Miner[24]upprobeandremovefunction”.表中的其他用例修复原因在修复日志中给与了介绍.iounmap等作者已有工作中重合的已确认BUG已被直接包含在确认的统计之中.路径I82975x_edac.ci82975x_init_onepci_enable_deviceR违例gpio-lynxpoint.clp_gpio_probepm_runtime_enableR违例ipmi_si_intf.cipmi_pci_probepci_enable_deviceR违例一般的静态工具都会存在漏报和误报等问题,主要原因包括:(1)部分接口函数的调用出现在判定分支中;(2)部分驱动结构性较差,通过私有的深层调用方式释放资源,而SD-Miner的分析深度不够时,会引起误报,但是该问题已经通过宽松的统计策略和严格的搜查策略来解决,即一旦发现违例,则进入深层次搜索,防止出现误报;(3)驱动部分接口本身设计不规范,接口之间存在包容关系,如设备加载时,会先调用input_allocate_device申请资源,然后调用input_register_device注册,然后卸载时直接调用input_unregister_device即可,因为其内部已经调用了input_free_device.SD-Miner通过关键字等优化方法,对检测到的违例进行了过滤,对观察到的一些违例进行了筛查,并增加一些规则到该工具中,结合3.5节中提到的误报和漏报优化技术,从而减少误报和漏报.目前通过人工分析现有的检测结果,其误报基本控制在15%左右.5结论与展望本文提出了一种面向内核接口的顺序依赖规则挖掘与违例检测方法(SD-Miner),结合驱动源码的结构特征,对驱动代码使用的内核接口进行统计分析,挖掘并提取内核接口的顺序依赖规则,并利用提取的规则检测现有驱动源码中的使用违例.SD-Miner对Linux3.10.10和2.6.38的驱动源码进行了规则挖掘与违例检测,对比实验结果发现,在2.6.38中存在64个被检测出的错误在3.10.10中Page12得到了修正.SD-Miner对Linux3.10.10的3781款驱动进行的检测和分析仅耗费5min,共计提取出了220个顺序依赖相关的接口使用规则,并检测到756个使用违例.实验结果表明,SD-Miner能够有效地挖掘出内核接口的顺序依赖规则,并检测出使用违例,进而辅助提高驱动可靠性.同时规则的挖掘是基于驱动的结构信息和统计信息,不需要开发者在源码中提供额外的注释及标注.论文的后续研究工作将结合动态分析技术,把静态定位到的违例,通过动态运行和错误注入技术进行确认,后续将考虑结合动态插装和检测技术,在提高驱动可靠性的同时,将检测的违例动态修复,如及时并自动释放申请的资源.这些功能将在SD-Miner的后续版本中进行补充和完善.致谢本文作者得到了实验室的老师和同学们的许多帮助和建议,在此表示感谢;同时也感谢审稿人对本文提出宝贵意见和建议;并对帮助我们确认和修正bug的开发者表示诚挚感谢!
