Page1对等点播系统中节点搜索机制研究张铁赢1)刘悦1)钟运琴1),2)程学旗1)1)(中国科学院计算技术研究所北京100190)2)(中国科学院研究生院北京100190)摘要对等点播系统(P2P-VoD)中的跳转操作需要高效的节点搜索,如何快速查找到“合适”的节点是个挑战.“合适”包含两方面因素:(1)内容匹配;(2)物理性能匹配.而传统的方法大部分只涉及对前者的研究.文中提出了一种层次化的搜索模型(简称Mediacoop),不仅可以让搜索到的节点在内容上满足要求,而且在物理性能上也能满足要求.具体而言,Mediacoop首先利用播放距离来索引全部节点,再利用延迟特征优选内容上已经符合要求的节点.在NS2模拟器上的实验表明,Mediacoop在用户体验和系统开销上均优于传统的方法.同时,在实际系统CoolFish中的部署和运行也验证了Mediacoop的实用性.关键词对等;视频点播;节点搜索;流媒体1引言随着互联网宽带接入的普及,对等视频点播服务(P2P-VoD)已经成为了最流行的互联网应用之一.点播的最大特点在于用户可以随意跳转,即从当“合适”的邻居节点包含两方面特征.一是内容匹配,即该节点拥有查找者所需内容,这一点也是最Page2基本的要求.二是质量匹配,即查该节点拥有较好的物理性能,例如高带宽和低延迟.质量匹配不仅仅是查询优化的问题,它对播放质量起到了至关重要的作用.Huang[1]、Pucha[2]以及Hefeeda等人[3]均指出,邻居节点的物理性能较差是导致无法及时获得数据的重要原因.衡量物理性能最重要的两个指标是带宽和延迟[4],本文中使用延迟作为衡量指标,因为带宽只能在建立连接后通过实际传输的数据测得[3-4],而我们的目标是建立连接前进行节点选择(即节点查找),所以带宽这一指标不适用于本文.详见第2节和第4节.通常,针对P2P-VoD的搜索方法只涉及内容搜索.典型的方法是使用分布式哈希表(DHT),把缓冲好的内容对应的信息发布到网络中等待查询(如文献[3,5]).但是,这种方法应用在视频服务中会造成大量的网络开销.因为每个节点缓冲的内容是随着观看进度发生变化的,节点需要不断地发布对应的信息,这就造成了巨大的网络开销.尽管文献[3]作者对节点物理性能方面进行了探索,但是他们提出的方法并不能应用在P2P-VoD中.文献[6-7]作者提出了非DHT的结构化搜索方法以避免大量的网络开销,但是他们都没有对节点的物理性能进行研究.在本文中,针对P2P-VoD的特征,我们提出了一个基于结构化的层次搜索模型(简称Mediacoop).本方法的一次查找能够同时满足内容匹配和质量匹配的双重要求.具体而言Mediacoop的查找过程被分为两个阶段:(1)使用播放距离来定位拥有所需内容的节点.对于给定影片,各节点的播放速度是相同的,这样,节点间的播放距离是不变的(除非节点进行跳转和暂停操作).因此,避免了传统方法的巨额网络开销;(2)把备选节点索引为一个树形覆盖网(overlay),该过程是以AS域间延迟及IP前缀为基础进行索引,其结果是能够找到与查询者延迟最小的节点子集,以完成节点质量匹配.我们在理论上证明了:以不低于传统DHT的查找效率O(logN),Mediacoop能够同时完成上述两阶段查找.我们在NS2模拟器上做了大量对比实验,结果表明Mediacoop在启动时间、跳转延迟、播放连贯度和网络开销上的优势十分明显.同时,在实际P2P-VoD系统CoolFish上实现了Mediacoop,其运行结果也验证了算法的实用性.本文第2节介绍相关工作;第3节描述Mediacoop的基本模型;第4节详细讨论Mediacoop的设计细节;第5节给出理论上和实验上的验证结果,并介绍实际系统的运行状况;第6节对全文进行总结.2相关工作P2P-VoD网络一般分为树形结构和网状结构两类.树形结构被较早提出,但是由于树形结构并不适用于动态性很强的P2P网络,目前主要的研究方向集中在网状结构.我们先简单介绍树形结构的已有方法.P2Cast[8]是一个典型的单播树系统,它使用补丁技术进行数据流分发.然而,在这种分发模型中,一个播放节点只有唯一的父亲节点提供数据,这对于异构网络来说是远远不够的.另外,在动态性很强的P2P环境下维护树形结构是很困难的.作为改进,P2VoD[9]把分发树组织为层次结构.当节点离开的时候会自动由上层节点替代,新加入系统的节点被分配到最低层.但是,P2VoD并没有提出适合点播的动态交互操作,例如跳转等.作为网络结构上的极大改进,网状结构是目前主要的研究方向.PROP作为网状结构的代表,以DHT作为基础提供P2P-VoD服务.在PROP中,只要节点获取到一个数据块,它便把该数据块的信息发布到网络中.当节点需要数据的时候,它先去查询DHT获得拥有所请求内容的节点,再向这些节点请求数据.这种方法带来一个严重的问题,在观看过程中,节点收到的内容随播放进度发生变化,这样,节点就要不断地发布新收到的内容信息.这种频繁的更新消息带来了巨大的网络开销.不仅如此,当缓冲区中陈旧数据被丢弃的时候,也要发布相应的删除信息.PROMISE[3]在节点的物理性能上进行了探索,基于网络带宽提出了一种节点选择方法.在播放过程中,它利用实际传输的媒体数据计算邻居节点可以提供的可用带宽,从而进行节点的优化筛选.但是,这种方法是在节点间建立网络连接后进行数据传输的时候进行的,也就是说是此时的资源节点(或称为邻居节点)已经存在,目标是进行节点“选择”而不是“查找”.因此,物理带宽这一指标并不适用于节点查找这种场景.和我们工作较为相关的主要是OBN[6]和RINDY[7].OBN减少了上述DHT方法带来的网络开销,它利用节点间缓冲区的重叠关系构建非DHT的结构化overlay.但是,节点物理性能的研究依然没有在OBN中得以实现.RINDY使用类似的方法Page3构建了一个多环的查找网络.查询者缩小环形范围直至找到候选节点集合,再使用Gossip协议定位拥有所需内容节点.但是,Gossip协议会带来较大的网络开销并且这种方法依然没有考虑节点物理性能上的优劣.3Mediacoop的系统模型本节主要讨论Mediacoop的基本思路,具体细节设计在第4节中介绍.Mediacoop的两大中心任务:(1)如何提供高效的内容查询;(2)如何找到网络延迟较低的节点.相应地,Mediacoop的搜索过程分为两个阶段,这两个阶段对应着两个不同的覆盖网,基本思想由3.1节和3.2节分别介绍.3.1播放点覆盖网(PlaypointOverlay)本节介绍第1阶段查询的基本思想.第1阶段的目标是内容匹配查询,我们把一部电影分为M个数据块,数据块按播放顺序编号为block1,block2,…,blockm,每一个数据块对应一个播图1播放示意图2播放点覆盖网由节点的路由表构建而成3.2前缀树覆盖网(Prefix-TreeOverlay)第1阶段查询的结果我们称之为种子节点,该种子节点满足内容匹配要求,在第2阶段中,我们的放点.这样,节点pi的播放点(PlayPoint)PPpi定义为节点pi当前正在播放的数据块编号blockj.拥有相同播放点的节点被归为同一个swarm(如图1(a)所示).对于给定影片,不同节点播放该影片的速度是一样的.因此,正常播放情况下,播放点间的距离是不发生变化的(除非节点进行跳转或暂停操作).在第1阶段,我们的想法是利用播放点距离把全部的swarm索引在一个环上(图1(b)).一个swarm只要建立好索引信息(即路由表),即使在播放过程中,不用更新索引也可以获知其它swarm当前的状态,如图2所示.每个节点的路由表存储了其它swarm播放点的信息(详见4.2节),路由表中的每条表项由播放点距离计算得出.请求者可以方便地查找到拥有目标播放点的节点,整个查找过程类似于著名的Chord网络[10],不同之处在于我们使用了播放点距离而不是Hash值.因此,播放点距离的不变性使得节点不需要更新索引信息也获知其它swarm的状态.这个特性使Mediacoop大大减少了网络开销.播放点距离的数学定义在4.2节中给出.目标是从种子节点出发,找到网络延迟最小的节点子集.实际上,第2阶段查询就是在种子节点所属的swarm中进行的,因为根据第1阶段的查找过程,最后定位的swarm就是种子节点所在的节点集合.因此,如何把swarm内部的节点索引起来是第2阶段的首要任务.因为查询目标是延迟最小,而延迟和AS域的IP前缀又有密切关系[11],我们的基本想法是用IP前缀把同一个swarm中的节点索引起来,如图3(b)所示的索引树.这样,由文献[11]的方法可以获得全局延迟表,根据该表便可得知延迟最小的IP前缀并作为查询目标,再根据图3(b)所示的索引树便可找到属于目标IP前缀的节点.具体细节将在第4节加以介绍.Page4图3层次查找的例子4Mediacoop的详细设计在本节中,首先介绍为何使用网络延迟作为物理性能的衡量标准,以及如何探测全网AS域间延迟;接下来将详细介绍层次化索引信息(双层路由表)的构建,并介绍如何使用路由表进行查询;最后讨论系统的维护代价和系统开销.4.1节点物理性能的获取作为交互性较强的应用,P2P系统对端到端的延迟是很敏感的[11].特别是在点播服务中,用户的交互性操作频繁发生(例如启动、跳转、暂停等),如果节点间延迟很大,会导致较长的反应时间.国际通信联盟G114号文件[12]建议,对于大多数交互性应用,以150ms作为物理链路上端到端延迟的上限.因此,在本文中,采用网络延迟作为衡量节点物理性能的指标,以150ms作为端到端延迟的上限.虽然端到端延迟可能随时间发生变化,但是十分精确的值对我们来说意义并不大.我们只需要记录节点间的平均延迟值,选取延迟较小的作为邻居节点.因此,我们最关心的是如何获得端到端延迟.实际上,互联网是由多个AS(AutonomousSystems)域组成,位于同一个AS内的节点距离较近,它们对外部AS表现出的网络延迟相似.不同AS间的路由方式由边际网关协议(BGP)指定.AS内部又分为更小的域(Cluster),由IP前缀分割开来.这样只需要获得域间延迟,选择与查询者延迟最小的域中节点作为邻居.我们使用文献[11]中的方法获得全覆盖网的域间延迟表,这样就可以从该表中获得延迟最小的域作为查询目标.该延迟探测方法的概括性介绍在下段中给出(更多细节可以参考文献[11]).图4描述了延迟探测的整个过程.首先,可以从边际网关协议公共信息提供处获取BGP路由表及其更新信息,例如从RouteViews(http://www.routeviews.org)和RIPERIS(http://www.ripe.net/projects/ris)均可获取.由这些路由表,可以构建整个覆盖网的组成图,其组成单位是以IP前缀分割的各个域(Cluster).我们以随机的方式从每个域中选取一个节点作为该域的“代表”.任意两个域之间的延迟是通过使用工具King[13]测量对应“代表”的延迟获得.最后得到两个表:(1)IP与对应的域的映射表(ICMT);(2)域与域之间的延迟表(CCDT).由ICMT,节点可以获知自己所属的域,再由CCDT获得与其所属的域延迟最小的目标域.表1给出了CoolFish网络CCDT的例子.接下来的核心任务就是如何把这些域组织起来提供高效搜索.表1CoolFish的CCDT(时间:2009.09.02,15:00)159.226.40.0202.127.200.31210.72.15.8在本文方法中,所有的域被组织成二叉树的结构,每个叶子节点代表一个域.这样,叶子节点的个数K和全部域的个数是相等的.每个叶子节点以其物理地址作为标识(即IP前缀),在表现形式上是其对应的前缀码.叶子节点1和叶子节点2的距离由他们前缀码的异或运算得出.在形式上,距离计算如下所示:DIPprefix(n1,n2)=Prefixn1Prefixn2(1)注意,第1阶段得到的目标swarm中的节点就Page5分散在这些叶子节点中,如果节点稀少会导致个别叶子节点为空(如图3(b)所示),这样的空叶子节点在实际操作中不会被索引起来.有些人可能会提出质疑,为什么我们使用树形结构来组织IP前缀呢?原因其实很简单:二叉树叶子节点的距离计算和IP前缀的距离计算是一致的,都是异或操作.4.2双层路由表的构建在Mediacoop中,一次查找由两阶段组成,分别在两个覆盖网中进行,相应的每个节点的路由表包含两个子表,分别是播放点路由表和IP前缀路由表.播放点路由表:播放点路由表存储了其它swarm播放点的信息.以节点p的播放点路由表为例,该表有logM(M是数据块的数量)行,第i行(0i<logM)保存着α个节点的播放点信息,该α个节点与p播放距离为2i~2i+1.播放距离(p1→p2)的定义如下:顺时针沿播放点覆盖网(即图1(b)所示的环)p1~p2的跳数.其数学的形式化定义表示为Dplaypoint(p1,p2)=((PPp2-PPp1)+M)modM式中,M是数据块的个数,PPpi是节点pi的播放点.图5(a)给出了播放点路由表的结构.每行记录了α=2个节点的信息(这里的α=2是我们的经验值.为了保证路由节点的可用性,建议每条路由表项中存储的节点个数大于1).IP前缀路由表:以节点p为例,其IP前缀路由表存储了和自己所在同一swarm中的其它节点信息.IP前缀路由表有logK(K是叶子节点的数量)行.第j行(0j<logK)保存着β个节点的IP前缀信息,该β节点与p的前缀码距离为2j~2j+1.该距离的计算方法如式(1)所示.图5(b)给出了IP前缀路由表的结构示意图.4.3查询过程内容匹配查询:即在播放点覆盖网中进行的第1阶段查询,图6给出了该查询算法的伪代码.查询过程为递归方式,描述如下:当节点A收到查询消息,它首先根据式(2)计算自己与目标数据块的距离D,然后该节点从自己的播放点路由表中选出与D最近的节点B并把该查询消息转发给B.该查询结束的条件为:(1)发现节点C的距离等于D,此时节点C作为种子节点被返回;(2)已没有更近的节点可以转发,此时当前节点作为种子节点被返回.图6内容匹配查询算法伪代码(NodeA收到内容质量匹配查询:即从第1阶段获得的种子节点出发,在IP前缀覆盖网中进行的第2阶段查询.查询目标是发起者p的CCTD中延迟最小的域,然后发起者p向种子节点发送查询消息.种子节点从自己的IP前缀路由表中找到距离目标最近的节点,并向其转发查询消息.转发节点递归的进行上述操作直到没有更近的节点进行转发(注意这里和上述结束条件不同,我们的目的是获得更多的节点).在查询过程中,任意符合要求(IP地址和目标IP前缀一致)的节点都将被返回.如果最后仍没有返回任何节点,那么发起者p会要求种子节点随机的返回在同Page6一swarm中的节点即可,因为这些节点虽然没有最低的延迟,但是在内容上都是满足要求的.图7给出了该查询算法的伪代码.图7质量匹配查询算法伪代码(NodeB收到质量一个查询实例:图3给出了从发起者p0开始的整个查询过程.如图3(a)所示,p0发起查询消息,目标是找到能够提供8号数据块的节点.p0首先计算自己和8号数据块的距离:Dplaypoint(p0,block8)=6,然后向最近的邻居p8发出“内容匹配”查询消息.以同样的方式,p8计算出自己和目标数据块的距离为D=1然后发现节点p13是属于目标swarm的.因此,p13作为种子节点被返回.接下来,p0从自己的域间延迟表中找到目标IP前缀210.77.并发起第2阶段查询.p0向种子节点p13发出IP前缀查询消息(如图3(b)),收到查询消息后,p13从自己的IP前缀路由表中发现p14最近并把消息转发给p14.以同样的方式,p14把查询消息转发给p15最后找到了位于210.77.内的目标节点.4.4节点加入及系统维护当节点p加入网络的时候,它首先联系一个业已存在的节点J.p以J的路由信息初始化自己路由表,然后节点p以自己为目标(播放点和IP前缀)进行一次完整的查询操作.完成查询之后,节点p获得了最近的节点网络中距离自己最近的节点Y,最后,p使用Y的路由表内容来刷新自己的路由表.注意,最后这次刷新的作用是:因为Y已经是距离p最近的节点,对于p来说就是如何获取比Y更远的节点信息,而Y的路由表刚好可以提供.在路由表刷新的过程中,p也把自己的信息插入到了其它节点的路由表中.当节点p进行跳转、暂停、停止等VCR操作的时候,p会通知邻居节点(路由表中的全部节点)自己新的播放点,同时邻居会更新相应的信息.在我们的方法中,域间延迟探测程序运行在单独探测服务器上,并间隔地更新ICMT和CCDT以提供最近的数据.有一点需要注意的是,CCDT记录的是平均延迟.当一个节点加入系统,它首先是向探测服务器请求ICMT和CCDT并以服务器的更新频率进行数据更新(在我们的系统中,更新频率是30min).5理论分析及实验5.1理论分析在本节中,我们分析Mediacoop的查询效率.因为该方法涉及到两阶段查询,可以建立如下分析模型:P(M,K)=PFirstStage(M)+PSecondStage(K),其中,P(M,K)是总的查询跳数,PFirstStage(M)和PSecondStage(K)分别是第1阶段和第2阶段的查询跳数,M是数据块的数量,K是域(即叶子节点)的数量.首先分析第1阶段的查询效率PFirstStage(M).Me-diacoop是一个结构化的搜索方法,其搜索过程类似传统的DHT方法,例如Chord.但是,我们使用的是播放点而非节点标识来建立索引.因此,本文方法的效率不是传统DHT方法的O(logN),而是播放点覆盖网对应的环上的播放点数量M.但是如果节点很少会导致数据块为空(即数据块不对应节点),比如当节点数少于数据块数量的时候,这种情况下K=N.因此查找效率应该取二者的最小值,即PFirstStage(M)=minO(logM),O(logN这里,N是网络中全部节点的数量.总的来说,对于流行的P2P系统,节点的数量是十分庞大的,而一部影片的数据块的数量确实相当有限的.举例来说,根据我们实际经验,对于时长为2h的电影,720个数据块就足矣了.也就是说,MN,因此我们有PFirstStage(M)=min{O(logM),O(logN)}=O(logM).在第2阶段,搜索过程实际上是在二叉树上的折半查找.因此,第2阶段的查找效率和折半查找的时间复杂度一致:这里,K是域的数量.第2阶段的搜索过程在一个较小的范围中进行的,即第1阶段的目标swarm.而Page7平均来看,全部节点是均匀分布在每个数据块中的,即每个swarm的节点个数n=N/M.这样,K小于或等于n,K取最大值n的条件是每个域正好只有一个节点.因此,Mediacoop总的搜索效率为P(M,K)=PFirstStage(M)+PSecondStage(K)O(logM)+O(logN/M)=O(logN),即也就是说,在不低于传统DHT一次查询的效率下,可以进行两阶段查询,既满足了内容上的要求,也在物理性能上得以提升.5.2评价指标及实验参数P2P-VoD的评价指标分为两个方面:一是用户体验,二是系统扩展性.前者主要指启动时间、跳转时间和播放连贯率[5,9];后者是服务器压力和网络开销[5,9].在本文中,我们不仅对以上几点均进行验证.还对搜索跳数进行了对比.我们把Mediacoop分为两个版本进行对比,第1个是单纯的内容搜索,不具备延迟探测(简称Mediacoop(no-DA)),即第2阶段没有搜索,取而代之的是使用Gossip协议定位节点;第2个版本是两阶段都有(简称为Mediacoop(DA)).为了和目前较为流行的方法进行对比,我们实现了具有代表性的基于DHT的P2P-VoD系统PROP[5].限于本文讨论的内容,我们没有实现PROP中的中心服务器功能.但我们与传统的“缓存转发”系统P2VoD[9]进行对比①.我们的对比试验是在NS2模拟器上进行的.电影时长设置为3600s,码率为500Kbps,一个数据块对应的播放时长为10s.使用拓扑结构生成器GT-ITM[14]生成了典型的transit-stub网络,其包含了860个路由器,之后随机选择100个stub节点作为域的分隔节点②.每个stub节点之间的延迟为10ms~60ms.同时生成8000个节点以均匀分布的方式依附于每个域上.整个实验分为12组进行,对应的节点数量从100~8000不等.节点的加入以指数递减的方式进行[15]:式中,λ0是初始加入速率,τ为扩散参数.相应地,设置节点平均加入时间间隔为5s,平均在线时间为1800s.下载带宽为1Mbps,上行带宽可以支持2个并行流.启动和跳转时的缓冲数据量为能够播放5s的数据.模拟试验程序运行在超级计算机Dawning4000A上,总共运行时间大于为4d.5.3实验结果(1)平均跳数.在本项指标中,因为验证的是搜索到目标所进行的跳数,是针对结构化搜索方法的,因此并不涉及P2VoD.图8给出了12组实验对应的平均跳数的实验数据.从结果可以看到,PROP体现了典型的基于DHT方法的“logN”法则,而Mediacoop两个版本的表现均强于PROP.虽然我们看到Mediacoop(no-DA)跳数少于Mediacoop(DA),那是因为前者没有第2阶段的搜索过程.(2)网络开销.网络开销主要是指控制信息的数量,因为P2VoD是树形结构,并非网状,因此在本项指标中也不考虑P2VoD.如图9所示,PROP在三者的比较中表现最差,因为它要不断地发布和删除内容信息,导致了大量的控制信息.Mediacoop(no-DA)的网络开销虽然强于PROP但是要比Mediacoop(DA)大得多,因为它在第2阶段使用了Gossip协议,也带来了大量的控制信息.相比之下,Mediacoop(DA)能够减少40%~70%的网络开销.①②Page8(3)服务器压力.在实验中,有一个具备1000Mbps上能力的内容服务器.如果一个节点没有及时收到其请求的数据,它就立即向内容服务器请求数据.图10显示了随着节点数量的变化,内容服务器压力的状况.对于Mediacoop(no-DA),它的压力要大于Mediacoop(DA),因为Mediacoop(no-DA)没有第2阶段搜索,得到的节点延迟较大,造成了请求数据不能及时到达.对于PROP随着数据缓冲区的不断更新,被抛弃的数据没有来得及更新,对这些数据的请求自然不能得到满足,造成了更大的服务器压力.而在P2VoD中,服务器压力是最大的并且是线性增长的.这是因为它是树形的组织结构,而上层节点的离开会造成它所有孩子节点缺失数据.(4)播放连贯率.图11显示了网络规模为4000个节点时,播放连贯率随时间的变化.Mediacoop的表现要远远好于RROP和P2VoD,其原因和服务器压力一节中的相同.除此之外,PROP这种基于DHT的方法必须要等到整个数据块都接收完成后才能发布信息,这样势必造成数据共享效率的低下.(5)启动和跳转时间.这两个指标涉及到两部分的性能表现:①查找速度;②请求数据的速度.实际上,前者就是第1项指标,搜索的平均跳数;而后者决定于搜索到的节点的质量.Mediacoop(DA)能够找到最近的节点,从而保证了请求的数据能够快速到达.图12和图13给出了实验结果.可以看到,对于5s的数据缓冲区,Mediacoop(DA)平均只需要大于3.5s的启动时间和2s的跳转时间.5.4真实系统上实现:CoolFish我们实现了一个真实的P2P-VoD系统CoolFish①,并且已初具规模.CoolFish的内容服务器位于中国科技网(CSTNet)内.从2008年10月到2010年6月,CoolFish的访问用户数已超过4000000,最近的日访问人数已经超过7000,在中国境内的用户分布超过28个省市.本文中提到的层次化搜索算法已经在CoolFish实现,系统用C++编写,总代码量超过80000行.表1显示了CoolFish系统的CCDT.我们下一步将在CoolFish系统中对Mediacoop进行更深入的实验比较.6结论及下一步研究节点搜索对于P2P-VoD系统是十分重要的,而最理想的搜索策略是既能满足内容匹配,又可以实现节点质量匹配.本文中提出的层次化搜索模型①http://www.cool-fish.orgPage9Mediacoop已经初步达到了上述目标.它使用了层次化的双结构模型,在内容查找阶段可以避免传统方法中大量的网络开销,同时又可以查找到具有最低网络延迟的节点集合.在理论分析上,证明了在小于O(logN)的情况下,就可以完成两个阶段的搜索过程.从实验结果可以看到,Mediacoop在用户体验以及系统扩展性上均好于其它方法.同时,我们的方法在真实系统CoolFish中的实现也体现了Media-coop的有效性.下一步,我们将在CoolFish系统中进行更深入的对比分析.
