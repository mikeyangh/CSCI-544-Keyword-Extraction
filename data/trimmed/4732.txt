Page1微函数依赖及其推理1)(哈尔滨工业大学计算机科学与技术学院哈尔滨150001)2)(哈尔滨工业大学软件学院哈尔滨150001)摘要起初,作为一个数据库模式设计的工具,函数依赖理论得到了很多的关注,而在数据修复中,该理论并不是十分有效.近年来,针对不一致数据的检测和修复问题,更多的约束被提出来,包括条件函数依赖、修复规则以及编辑规则等.然而,这些方法都只关注了属性整体之间的依赖关系,而实际应用中的数据通常有属性部分之间的依赖关系.例如,某单位员工的工号前两位决定了其所属的部门,而此类依赖信息就被已有方法忽略.该文首先提出了一类更一般化的约束———微函数依赖,微函数依赖引入提取函数,用来表示属性的部分信息.利用提取函数之间的依赖关系,能够检测出更多的不一致数据.理论方面,该文首先研究了微函数依赖的可满足性问题和蕴含问题,然后提供了一个正确且完备的推理系统.最后,通过实验证实了微函数依赖能够在可接受的时间开销内检测出更多的错误数据.关键词微函数依赖;提取函数;可满足性问题;蕴含问题;推理系统1引言相关资料表明,脏数据正在变得越来越普遍且不可避免,例如,在信息产业还没有特别发达的1998年就已经有1%~5%的商业数据存在错误,在有些企业中甚至达到了30%[1];国际著名科技咨询机构Gartner的调查显示,全球财富1000强企业中超过25%的企业信息系统中的数据不正确或不准确[2].这些脏数据通常带来很严重的后果[3],而且由于数据量庞大,数据问题种类繁多,要想解决数据质量问题带来的严重后果,也是一项消耗巨大的工作.美国公司每年花在处理脏数据上的资金就高达6千亿美元[4];目前数据质量工具的市场以每年17%的速度增长,远超IT行业平均增长率7%;一项近期统计显示,在大多数的数据仓库项目中,数据修复工作占开发时间和预算的30%~80%[5].近年来,数据库领域广泛研究了处理脏数据的问题.不一致性是脏数据的最重要方面之一.如果一个数据库违反了某些数据质量规则如函数依赖[6]、条件函数依赖[7-8]、扩展的条件函数依赖[9]、编辑规则[10]、修复规则[11]等,则称它是不一致的.起初,检测和修复脏数据的依据是传统的函数依赖(FDs)[6],而函数依赖主要用于数据库的模式设计,在处理不一致数据时,往往不够充分.实际上,在一个精心设计①的数据库中,所有的函数依赖都是主键约束,即约束前件都是候选键.同时,所有的主流数据库都支持SQL语句中的UNIQUE和KEY关键字,来避免插入和修改数据时违反函数依赖,如例1.例1.考虑数据库模式Employee(Eid,Name,Dept,Position,EntryDate,Salary)以及一个相应的实例r,如表1所示.带有下划线的属性Eid是主键,由主键定义知,Eid的值可以确定其他属性的值.另外,来自同一部门的员工不能重名,因此Name和Dept也构成了一个候选键.这两条约束可以形式化为两条函数依赖1:[Eid]→[Name,Dept,Position,EntryDate,Salary]和2:[Name,Dept]→[Eid,Position,EntryDate,Salary].由于底层数据库管理系统的约束检查机制,r中的所有元组在[Eid]以及在[Name,Dept]上的值都不相同(在[Eid]或[Name,Dept]上具有相同值的元组会被禁止插入数据库),因此上述两条约束也不会被违反.从例1可以看到,函数依赖能够阻止不一致数据进入数据库,但是对检测错误是不充分的.为此,Fan等人对函数依赖进行了扩展,把语义相关的值绑定到约束中去,即条件函数依赖(CFDs)[7-8].条件函数依赖的主要特点就是它可以只对表中部分满足一定条件的元组起作用,而函数依赖则对整个表中的所有元组起作用.在例1中,如果每个部门只能有一个管理者,就可以得到以下的条件函数依赖:φ1[position=Manager,Dept]→[Eid,Name,Entry-Date,Salary]表示当一个员工是管理者的时候,通过他所在的部门,能够知道他的员工号、姓名等信息.函数依赖对此是无法表示的.然而,根据IDEF1X①,如果数据库模式设计得很完善,Employee将会按照分类属性Position被分成表Staff(Eid,Name,Dept,EntryDate,Salary)和Manager(Eid,Name,Dept,EntryDate,Salary).这样,φ1函数依赖3:[Dept]→[Eid,Name,EntryDate,Salary].由前述内容可知,3不易被违反.另外,每个条件函数依赖在每个属性上至多绑定一个数值,导致它的表达能力有限.为了增加其表达能力,Fan等人又提出了内置谓词的条件函数依赖(CFDps)[12]以及扩展的条件函数依赖(eCFDs)[9].前者把条件函数依赖中的‘=’扩展到‘≠’,‘<’,‘’,‘>’和‘’,而后者是把条件函数依赖中的“单值条件”扩展到“有限集合条件”,即只有属性值在(或者不在)集合中时才满足条件.这两种扩展都很大程度上增加了条件函数依赖的表达能力.然而,CFDps主要针对数值型属性而eCFDs不能够处理“无穷集合”的情况.此外,其他研究工作提出来的约束包括编辑规则[10]、修复规则[11]、差分约束[13]和可比较约束[14]等.但是,所有这些约束都只关注了整个属性值之间的关系,忽略了这样一个事实:两个属性值的部分信息相等也能够确定一些相等关系.比如,两个电话号码的前几位相同,则它们可能来自同一地区.而在之前的工作中,完全相同的两个电话号码才被认为来自同一地区.在例1中,如果Eid的长度为2的前缀表示员工所在的部门,可以将其表示为[prefix(Eid,2)]→[Dept],本文中表1中的第一①DataModelingMethod(IDEF).http://www.idef.com/idef1x-data-modeling-method/Page3条和最后一条元组的Eid前缀相同,表示员工来自相同部门,但是他们的Dept属性又不相同,说明数据不一致,而之前的工作都没有检测出这类不一致.EidNameDeptPositionEntryDateSalary/%01M00001AliceR&DManager2007-09-0101S00002BobR&D02M00001CarolTestManager2009-08-2902S00010DavidTest03M00001EricO&MManager2012-08-2503S00002FrankO&M01S00003GaryO&M针对这些实际情况,本文的主要贡献包括:(1)提出微函数依赖(MDs)的概念,它是对FDs、CFDs、CFDps和eCFDs的进一步扩展,以在数据修复中发现更全面的不一致数据.这里之所以用“微函数依赖”而不用“部分函数依赖”的名称,是因为后者已经在关系数据库的函数依赖理论[6]中被占用,并且表示了完全不同的意思.通过引入提取函数,来提取属性中的部分信息,MDs能够检测出更多的不一致数据.这部分内容主要在第2节介绍;(2)研究了关于MDs的静态分析问题,包括两部分,分别是可满足性问题和蕴含问题.可满足性问题是指,给定一个微函数依赖集Σ(根据惯例,Σ在本文中表示依赖集,并非求和符号),判断是否存在一个满足Σ的非空实例.蕴含问题是指,给定一个微函数依赖集Σ和单条微函数依赖φ,判断“任一实例满足Σ”是否蕴含“该实例也满足φ”,即判断:满足Σ的实例是否也一定满足φ.这部分内容主要在第3节中介绍.(3)针对MDs,给出了若干推理规则,构成一个推理系统,并且证明了该推理系统的正确性和完备性.这部分内容主要在第4节介绍.(4)介绍了用微函数依赖检测数据错误的算法,首先给出基于SQL查询的方法,然后给出基于排序的方法,并在多条依赖的情况下对其进行优化.这部分内容在第5节进行介绍.(5)进行了充分的实验,实验结果表明MDs确实能够比之前方法检测出更多的错误数据.这部分内容主要在第6节介绍.最后,第7节介绍了相关工作,第8节对本文工作进行了总结.2微函数依赖R是一个关系模式,{A1,A2,…,An}是R上的属性集合,记作attr(R).对于attr(R)中的每个属性Ai,都有相应的域dom(Ai).R上的一个实例r是指一个有限的元组集合:rdom(A1)×…×dom(An).元组t和属性A构成一个元组-属性对,表示t在A上的值,称之为单元格,记作t[A].函数依赖是形如X→Y的规则,其中X,Y均为属性集合,其语义为R上的实例r应满足:对于r中的任意两条元组s,t,如果s[X]=t[X],则应该有s[Y]=t[Y].在下文中,将称“→”之前的部分(即X)为约束前件,之后的部分(即Y)为约束后件.条件函数依赖是在函数依赖的基础上,增加了常量条件,比如[A=a,B]→C表示,如果r中有两条元组在A属性上的值相等且都为a,在B属性上值也相等,那么这两条元组在C上也应相等,否则说r不满足该条约束.下面,将介绍提取函数的概念,并定义两种类型的微函数依赖:用户定义的微函数依赖和固有微函数依赖.2.1提取函数为了表示部分属性之间的关系,本文引入提取函数的概念.对attr(R)中的每个属性A,都有一个相应的提取函数集FA={f每个提取函数都可以看成是由属性A得到的新的属性,称之为A上的导出属性,其属性值由相应元组、函数语义以及属性A共同确定:元组t在f的值为f一,本文将f中的每个提取函数f都定义在A的域的子集上,即dom(f)dom(A).特别的,iA是dom(A)上的恒等函数,也就是iA=A,即对于所有的a∈dom(A),iA(a)=a.如果adom(f),f(a)上无定义,用空值来表示此语义:f(a)=null.不失一般性,对于两个不同的属性A和B,可以认为FA∩FB=.将R中涉及到的所有提取函数记为简便起见,在不引起歧义的前提下,可以省略上下标.对于一个提取函数f∈FA,其相应的属性A被记作Att(f).为了与主流数据库中函数的用法相一致,本文允许函数的参数为一个属性,或者具体的值.当函数参数是一个属性的时候,其输出是一个新Page4的属性,即导出属性;当函数参数是一个具体值的时候,函数输出也是一个具体值.例如SQL中有字符串函数reverse(str),表示把str中的所有字符反序.例如,在表1中所示的数据库上执行查询语句:Q1:SelectEid,Name,reverse(Name)FromEmployee;得到的结果如表2所示.Eid01M0000101S0000202M0000102S0001003M0000103S0000201S00003查询结果仍然是一个关系,reverse(Name)是其中一个属性,而每条元组在reverse(Name)属性上对应的值,等于Name属性上的值取反转操作得到.例如reverse(Name)在第1条元组上的值为reverse(Alice),即ecilA.实际上,每个提取函数f都从相应的属性中提取了一部分信息,它可以被看做一个新的导出属性.微函数依赖就是定义在这些导出属性上,从而表示部分属性之间的关系.2.2微函数依赖和函数依赖相比,微函数依赖的主要区别在于它定义在提取函数上,而不是直接定义在属性上.类似于函数依赖,一个微函数依赖φ具有如下的形式:其中fi∈只有恒等函数的微函数依赖.给定R上的关系实例r,如果对于r中的任意两条元组t1,t2都满足:(1)t1[f1,f2,…,fk]≠t2[f1,f2,…,fk];或(2)t1[f0]=t2[f0].则称r关于φ一致,或r满足φ,记作rφ;否则称r关于φ不一致,或r不满足φ,记作r/φ.对于微函数依赖集合Σ来说,如果对φ∈Σ,rφ都成立,则称r关于Σ一致,或r满足Σ,记作rΣ;否则称r关于Σ不一致,或r不满足Σ,记作r/Σ.根据语义的不同,微函数依赖被分为两类:用户定义的微函数依赖(UMDs)和固有微函数依赖(IMDs).前者是由用户定义的,可能会被违反,而后者是由提取函数的定义决定的,永远不会被违反.2.2.1用户定义的微函数依赖顾名思义,此类依赖是指用户希望数据库应该满足的微函数依赖.在例1中,Eid的前两位用来识别员工所在部门Dept,接下来两位表示入职日期EntryDate,第5位表示职位Position.这些规则可以分别用微函数依赖表示为[prefix(Eid,2)]→[Dept],[substr(Eid,3,2)]→[EntryDate]以及[charAt(Eid,5)]→[Position].prefix(str,len)函数返回str串的前len位,substr(str,begin,len)函数返回str串从begin位置开始且长度为len的子串,charAt(str,idx)函数返回str串第idx位的字符.这些约束都是由用户定义的,属于用户定义的微函数依赖,当数据产生错误时,它们有可能被违反.例1中第1条元组和最后一条元组的Eid前两位相同,应该属于同一部门,但两条元组的Dept属性值不相等,约束[prefix(Eid,2)]→[Dept]被违反.另外,函数依赖和条件函数依赖都可以用微函数依赖来表示.对于函数依赖,只需要把其中所有的属性用相应恒等函数代替即可,只是形式发生了变化,语义未变.例如[Name,Dept]→[Eid]可表示为[i1(Name),i2(Dept)]→[i3(Eid)],其中i1,i2,i3分别为相应属性上的恒等函数,简便起见,本文将省略这些恒等函数,例如[Name,Dept]→[Eid]就可以被看作一个合法的微函数依赖.为表示条件函数依赖,则需要利用空值,并认为“空值不等于任何值”.例如为了用微函数依赖表示规则[Position=Manager,Dept]→[Eid],引入提取函数isManager(str):isManager(str)=等价的微函数依赖就可以写成如果元组的Position属性不等于Manager,约束前件出现空值null,因为空值不等于任何值,所以该元组和其它元组在约束前件上都不会相等,从而不会违反该约束,使得该约束只在一部分元组上起作用,和对应的条件函数依赖是等价的.在例1中,上述的函数依赖和条件函数依赖都未被违反.而微函数依赖[prefix(Eid,2)]→[Dept]被违反,因为Alice,Bob和Gary的Eid属性前缀都是01,他们应该属于同一个部门,但是Gary却来自不同的部门O&M,由此可以看出,微函数依赖能够检测出一些已有方法忽略掉的错误数据.至于为什么不直接把Page5性fA,这样一来微函数依赖实际上就变成了普通的函数依赖,本文不这样做的原因有如下几点:首先,属性A和fA之间的映射关系由函数f的定义确定,如果简单的把f(A)看作新的属性,这个映射信息就会丢失;第二,引入新的函数依赖φ:A→f(A),并不能彻底地表达A和fA之间的紧密关系,因为f把A映射到一个确定的值上,而φ仅仅是说两条元组在属性A上相等也应该在fA上相等,而不知道应该等于何值,例如,单条元组可能不会违反φ,却有可能违反f的定义;最后,即使可以用条件函数依赖[A=a]→[fA=f(a)]表达相同的语义,但需要对dom(A)中的所有值分别给出条件函数依赖,这是不可行的,因为dom(A)可能很大,甚至是无穷的,这时需要用无穷多个条件函数依赖表达相同的语义,是不现实的.本小节中提到的规则都是用户定义的,被称为用户定义的微函数依赖(UMDs).从例子中可知,当数据出现错误时,这些约束可能被违反,根据违反情况,可以检测出数据中的不一致.2.2.2固有微函数依赖考虑单个属性A,定义在A上的提取函数保留了A的部分信息,例如字符串属性A的前两位子串保留在prefix(A,2)中.如果有多个提取函数定义在A上,这些函数保留的信息之间可能互不相交,或者会有重叠,甚至相互包含.这就导致了同一个属性上,不同提取函数之间的依赖关系.例如容易得到如下依赖关系:[i(A)]→[prefix(A,4)]以及[prefix(A,4)]→[prefix(A,2)].两条约束分别是说,整个属性的值能够确定该属性值的前缀,长度为4的前缀能确定长度为2的前缀.对于一个整数属性B,有[mod(B,2),mod(B,3)]→[mod(B,6)]等,该约束的含义是,如果整数能被2和3同时整除,则它也能够被6整除.另外,如果f1,f2∈FA,dom(f1)∩dom(f2)=,即对于任意元组t,t(f1)和t(f2)至少有一个为空值.为表示这类约束,为每个提取函数f引入两个域函数f定义如下:容易看出这两个域函数总是取不同的值,前面f1和f2的关系就可以表示为[f表示如果f1和f2有一个不为空值,那么另一个就一定是空值.本文用符号即={f容易看出,本小节的所有约束都是由函数的定义决定的,与数据无关,也就是说,不管数据的不一致程度有多高,这些约束都不会被违反.由于这些约束的固有特性,本文称之为固有微函数依赖(IMDs).和用户定义的微函数依赖不同,固有微函数依赖永远不会被违反,因此并不能够直接用来发现数据中的错误,其主要作用在于对微函数依赖的推理中,具体用法详见第3、4节.值得注意的是,一个提取函数可以定义成数学表达式、字符串表达式或甚至一段程序代码等,自动判断固有微函数依赖的工作变得几乎不可能实现.本文重点在于分析微函数依赖的性质,因此在后续章节中,若无特别说明,都假定已经知道了完备的固有微函数依赖集.为了加以区分,UMDs集合和IMDs集合被分别标记为ΣU和ΣI.3微函数依赖的静态分析微函数依赖的提出,是为了检测出更多的错误数据.为了更好的利用已有微函数依赖集Σ,有必要判断Σ自身是否存在不一致和冗余,即本节将讨论的可满足性分析以及蕴含性分析,统称为静态分析.本节重点研究了可满足性问题和蕴含性问题各自的复杂性.3.1微函数依赖的可满足性给定关系模式R上的ΣU以及完备的ΣI,微函数依赖的可满足问题是指,判断是否存在一个非空关系实例r,使得rΣU,记作MD-SAT问题.为便于分析,用Σd表示把ΣU中涉及到的所有提取函数f替换成相应的域函数f集.一个直观的结论就是ΣU的可满足性与其中的提取函数的定义域有关,而与具体函数值无关.引理1.ΣU可满足当且仅当Σd可满足.另外,Σd可满足当且仅当存在一个单元组关系实例r,使得rΣd.证明.首先证明ΣU可满足当且仅当Σd可满足:→:需证如果ΣU可满足,则Σd可满足.因ΣU可满足,一定存在一个关系r,使得rΣU.只要证明rΣd,就可以得出Σd可满足.考虑r中的任意两条元组t1和t2以及Σd中的任意一条约束φdPage6~1,fΣU中对应的约束为φUt1[f不等于任何值,所以两条元组在f的值均不为空.由2.2.2节中对域函数的定义,容易得出元组t1和t2在f1,f2,…,fl上的值也都不为空.所以有t1[f1,f2,…,fl]=t1[f1,f2,…,fl],且t2[f1,f2,…,fl]=t2[f1,f2,…,fl],又因为rΣU,容易得出t1[f0]=t1[f0],t2[f0]=t2[f0],即t1和t2在f0上不为空,进而t1和t2在f据2.2.2节的定义,域函数只有null和1两种取值,所以t1[f论:如果ΣU可满足,则Σd可满足.←:证如果Σd可满足,则ΣU可满足.因Σd可满足,一定存在一个关系r,使得rΣd.只要构造一个关系r,并证明rΣU,就可以得出ΣU可满足的结论.令r为r的一个单元素子集,即rr且|r|=1.不失一般性,可假设r={t}.考虑ΣU中任意一条约:[f1,f2,…,fl]→f0,如果t[f1,f2,…,fl]=束φUt[f1,f2,…,fl],则说明t在f1,f2,…,fl上均不为null,根据2.2.2节中对域函数的定义,进而得出t在f~~~ft[f1,ft[f0]=1,可知t[f0]不为null,因此t[f0]是一个非空的确定值,即有t[f0]=t[f0],得出rΣU,进而得出结论:如果Σd可满足,则ΣU可满足.1,f2,…,f~~然后证明Σd可满足当且仅当存在一个单元组关系r,使得rΣd.如果存在一个单元组关系r,使得rΣd,可以直接根据可满足性的定义得出结论:Σd可满足.如果Σd可满足,则一定存在关系r,使得rΣd,因此对于r中任意一条元组t和Σd中的任意一条约束φd~l]=t[ff造单元组关系r={t},直接得出rΣd,即存在一个单元组关系r,使得rΣd.综上可得,ΣU可满足当且仅当Σd可满足.另外,Σd可满足当且仅当存在一个单元组关系r,使得rΣd.接下来讨论,如果有一个完备的固有微函数依赖集ΣI,MD-SAT问题的复杂性.定理1.给定完备的ΣI,MD-SAT问题是NP-完全的.证明.首先,微函数依赖是对条件函数依赖的一般化,而条件函数依赖的可满足性问题已经被证明是NP-完全的,因此MD-SAT问题是NP-难的.然后证明MD-SAT属于NP,为此,给出一个不确定算法生成只有一个虚拟元组t的关系r,猜测t在每个域函数f满足Σd和ΣI,若满足,则输出“是”,否则输出“否”.上述工作在多项式时间内完成,并枚举了所有的可能情况,因此MD-SAT属于NP.综上可得,MD-SAT是NP-完全的.证毕.上述证明并没有直接猜测t的各属性上的值,因为属性域可能是无穷的,不满足不确定图灵机的要求.因此对域函数随机赋值,并根据来ΣI验证赋值是否合法.不难看出,如果的赋值就有2||种,可以在常数时间内枚举完全,直接可得到如下结论.定理2.如果问题是P问题.如果一个微函数依赖集合ΣU是不可满足的,有必要给出有效算法来找出ΣU的一个子集ΣU,并使|ΣU|最大化.本文将该问题称为“微函数依赖的最大可满足子集”问题,记为MAXMSAT问题.由于MD-SAT本身是NP-完全的,属于难解问题,因此MAXMSAT问题更加困难,因此需要考虑近似算法.只要找到一个保留近似因子的归约方法,从MAXMSAT归约到已有的可近似问题,就能够说明MAXMSAT是可近似的.本文将其归约到MAXGSAT问题,即一般化的极大可满足问题(MaximumGeneralizedSatisfiability),而对于该问题,已经有近似算法.MAXGSAT问题简单描述如下:给定一个布尔表达式的集合Φ={1,2,…,n},找出一个变量赋值,使得Φ中为真的表达式数量最大.归约过程包含两个多项式时间可计算的函数g和h,使得对任意一个微函数依赖集合ΣU,满足:(1)g(ΣU)是MAXGSAT问题的一个实例ΦΣ,即一个根据ΣU计算得到的一个布尔表达式集合,且(2)如果Φm是ΦΣ的一个可满足子集,则h(Φm)是ΣU的一个可满足子集,且(3)|OPTg(g(ΣU))||OPTm(ΣU)|,且(4)|h(Φm)||Φm|其中OPTg(g(ΣU))是MAXGSAT问题的最优解,OPTm(ΣU)是MAXMSAT问题的最优解,结合第(3)、(4)条中的不等式,很显然如果MAXGSAT有一个近似比为ε的算法,通过归约,也能够得到Page7MAXMSAT问题的近似比为ε的算法.首先考虑如何根据给定的ΣU,以及完备的固有函数依赖集ΣI,构造g(ΣU).对每一个导出函数f,引入一个布尔变量xf来表示f是否实例化为空值null.对ΣI中的每一个微函数依赖φ,则可以用一个析取式φ来表示φ是否被满足.如果f的左边,或者f入到φ中.如果f在“→”的右边,则将变量xf加入到φ中.例如,对于固有的微函数依赖f件之一,约束即被满足:(1)f1被实例化为空,或(2)f2被实例化为空,或(3)f3被实例化为非空,或(4)f4被实例化为非空.对应的布尔表达式φ就是:x-特别的,固有微函数依赖集ΣI是永远不会被违反的,用布尔表达式来表示ΣI是否被满足.对于每一个用户定义的微函数依赖φ∈ΣU,其构造方式和固有微函数依赖类似,不同之处在于要给整个布尔表达式和ψI作,例如有用户定义的微函数依赖f其对应的布尔表达式φ为(x-,这样,得到ψIh函数和g函数相反,是把布尔表达式映射为微函数依赖,对于一个布尔表达式集合ΦmΦΣ,h(Φm)定义为集合{φ|φ∈Φm}.很显然,函数g和h都能够在多项式时间内计算出.且通过归约过程可知,g(ΣU)是MAXGSAT问题的一个实例,条件(1)被满足.如果φ∈Φm被某个赋值满足,则在对应的微函数依赖中,要么“→”左边的提取函数不满足要求,要么“→”右边的提取函数满足要求,而且所有固有微函数依赖都被满足,从而使得存在一个元组满足该微函数依赖,条件(2)被满足.另外,从归约过程可以看出每一条用户定义的微函数依赖都对应一个不同的布尔表达式,二者是一一对应的,且布尔表达式被满足当且仅当对应的微函数依赖被满足,因此MAXGSAT和MAXMSAT问题的最优解大小是相等的,条件(3)被满足.同时由于二者的一一对应关系可知|h(Φm)|=|Φm|,条件(4)被满足.综上可知,上述归约过程是保留近似比的,因此对于MAXMSAT问题存在一个多项式时间的近似算法.3.2微函数依赖的蕴含性不同于可满足性分析,蕴含性分析的目的是为了消除冗余.给定R上微函数依赖集Σ=ΣU∪ΣI以及一条微函数依赖φ,其中ΣI是完备的固有函数依赖集,判断Σ是否蕴含φ.Σ蕴含φ当且仅当对于R上的任意实例r,如果rΣ,一定有rφ.记作Σφ.记微函数依赖的蕴含问题为IMP-MD问题.为了研究其复杂性类,首先给出如下引理.引理2.给定Σ和φ,存在一个实例r使得rΣ且r/φ,当且仅当存在一个不超过两条元组的实例r使得rΣ且r/φ.证明.从两个方向分别证明.←:显然,如果存在一个不超过两元组的实例r满足rΣ且r/φ,直接令r=r,立即得到rΣ且r/φ.→:假设存在一个实例r满足rΣ且r/φ,因为r/φ,由/符号的含义可知r中一定存在两条元组t1,t2共同违反φ,即{t1,t2}/φ.另外,因为rΣ,不难得出r的任意一个子集仍然满足Σ,所以{t1,t2}Σ.直接令r={t1,t2},此部分得证.证毕.因此,要判断Σφ是否成立,只需要考虑所有不超过两条元组的实例即可.定理3.IMP-MD问题是CoNP-完全的.证明.由于已知微函数依赖是对条件函数依赖的一般化,而且条件函数依赖的蕴含问题是CoNP-完全的,可直接得出IMP-MD问题是CoNP-难的.接下来证明IMP-MD问题属于CoNP,给出一个不确定算法生成有两条虚拟元组t1,t2的关系r,对每个提取函数f,算法猜测t1,t2在f取值的不同组合:(1)t1(f)=t2(f),或(2)t1(f)≠t2(f)且二者都不为空值,或(3)t1(f)≠null且t2(f)=null,或(4)t1(f)=null且t2(f)≠null,或(5)t1(f)=null且t2(f)=null.赋值结束后,算法分别判断r是否满足Σ和φ,如果在不确定算法的所有猜测路径上都有:(1)r/Σ,或(2)rφ.则输出“是”,否则输出“否”.上述过程在多项式时间内枚举了所有可能组合,所以IMP-MD属于CoNP.Page8综上可得,IMP-MD是CoNP-完全的.证毕.不难看出,如果合就有5||种,可以在常数时间内枚举完全,直接可得到如下结论.定理4.如果题是P问题.4微函数依赖的公理系统Armstrong公理是函数依赖中蕴含分析的基础工具.类似的,本文给出微函数依赖的推理系统,记,如表3所示.给定一个微函数依赖集Σ和一条为微函数依赖φ,如果能够从Σ根据为Σ├Iφ.规则名规则1.如果f∈F,则F→f.规则2.规则3.规则4.规则5.[f规则1和2分别对应Armstrong公理中的自反律和传递律.规则3是指约束后件是一个域函数,那么约束前件中的函数都能简化为域函数.规则4是指,在g空与非空的情况下,F都能够决定f,那么F可以和g对应的属性共同决定f.规则5是指,如果约束前件中有矛盾,那么它可以决定任意函数.接下来讨论定理5.微函数依赖的推理系统即若有Σ├φ,则有Σφ.证明.规则都是正确的,因此只需分别证明各条推理规则的正确性.规则1.对于r中任意两条元组s,t,如果s[F]=t[F],已知f∈F,一定有s[f]=t[f].得出r(F→f).规则2.对任一实例r,如果r{F→f1,…,F→fk,[f1,…,fk]→f},需证明r(F→f).对r中的任意两条元组s和t,如果s[F]=t[F],则有s[fi]=t[fi],i=1,2,…,k.即s[f1,f2,…,fk]=t[f1,f2,…,fk],从而可以得出s[f]=t[f].得证r(F→f).规则3.对于任意实例r([F,g]→f中任意元组t使得t[F,珟g]不含空值,一定有t[珟f]不为空值,否则t[F,g]=t[F,g]而t[fr([F,g]→f总是1.因此r中任意两条元组,若在[F,珟g]上相等,也必然在f过程类似.规则4.根据域函数的定义可知,f二者有且仅有一个等于1.对任意实例r.如果r{[F,珟g]→f,[F,珚g]→f}.对于r中任意两条元组t,s.如果t[F,Att(g)]=s[F,Att(g)],有t[珘g]=s[珘g]=1或t[珚g]=s[珚g]=1.如果是第1种情况,可由r满足[F,珘g]→f得出t[f]=s[f],否则,可由r满足[F,珔g]→f得出t[f]=s[f].得证r([F,Att(g)]→f).规则5.实例r中的任何两条元组s,t在[f上都不会相等,因为f依赖[f~,f综上,MDs的推理系统在证明完备性之前,先定义合法集的概念,如果一个域函数集合S满足:对于任意f∈仅有一个属于S,则称S是合法的,记所有合法集的集合为VC.给定一个函数集合W,VC在W上的投影记为表示已知W中的值全部取非空值时,剩余的所有域函数所构成的全部可能赋值.算法1.m-CLOSURE算法.输入:一个微函数依赖集Σ和一个函数集F.输出:F关于Σ的闭包Σ1.result··=F;2.REPEAT3.cf+··=∩4.cd+··=∩∩5.result··=result∪cf+∪cd+6.UNTILresult不再发生变化7.RETURNresult;过程1.closure过程.输入:一个微函数依赖集Σ和一个函数集F.输出:F关于Σ的单步闭包1.result··=F;2.IFresult包含冲突THEN3.result··=∪4.ELSE5.REPEAT6.IF(G→g)∈ΣANDg不是域函数THENPage97.IFGresultTHEN8.result··=result∪{g};9.ENDIF10.ELSEIF(G→g)∈ΣANDg是域函数THEN11.IF对G中的每个h都有珘h∈resultTHEN12.result··=result∪{g};13.ENDIF14.ENDIF15.UNTILresult不再发生变化16.ENDIF17.RETURNresult;定理6.微函数依赖的推理系统即若有Σφ,则有Σ├Iφ.证明.类似于函数依赖,首先给出一个算法m-CLOSURE,以Σ和F为输入,输出一个提取函数集,记为Σ数的集合(称为F的闭包).算法1的第3,4行是枚举域函数的所有可能取值,并把闭包集合求交.是为了模拟规则4,不断把符合规则4里的f添加到闭包里.注意这里枚举的数量是指数级的,虽然效率很低,但是该算法只是为了辅助证明,并不真是为了计算闭包而设计的.为证明完备性,先证明如果Σφ,那么f∈m(F),再证明如果f∈ΣΣ等于F→f.m(F)有s[g]≠t[g].对于每个微函数依赖对于第1步,等价于证明其逆反命题:如果fm(F),那么Σ/φ.考虑一个实例r={s,t},使得对Σ于所有的g∈ΣgΣG→g∈Σ,如果G∈Σ也会被加入到Σ函数依赖,即rΣ.同时,算法m-CLOSURE的初始化步骤保证了FΣm(F),得出r/φ进而Σ/φ.Σ对于第2步,首先证明对于所有的f∈closure(Σ,F),Σ├3,8和12行加入到closure(Σ,F)中.如果是在第1行加入,规则1可以保证Σ├行,规则5保证Σ├可保证Σ├保证Σ├接下来,证明对于所有的f∈Σ这里简单介绍大概证明思路.一个函数f只会在算法1的第1,3,4行进入Σ则1可以保证Σ├的使用规则4可以将被加入到result中的函数被推出,并最终保证Σ├的使用规则3和4将加入到result的域函数被推出,并最终保证Σ├5不一致数据检测数据清洗的第一步,就是快速有效的检测出数据中的不一致.本节简要介绍检测数据违反微函数依赖的技术.给定R上的一个关系实例r,一个微函数依赖集Σ,需要检测出r中违反Σ的所有元组.本节首先讨论如何利用SQL查询检测不一致元组,然后给出更有效的、基于排序的检测方法.5.1基于SQL查询的方法给定一个微函数依赖φ:[f1,f2,…,fl]→f0,可以通过SQL语句Q1选择出所有违反φ的元组:Q1:SELECTf1,f2,…,fl例如在Employee关系中,Eid的前两位决定员工所在部门,即prefix(Eid,2)→dept,查询语句就可以写成:Q2:SELECTprefix(Eid,2)asPrefix,Employee关系中第1、2、7条元组的两位前缀都相同,聚集到同一个组里,而且3条元组在dept属性上有2个不同值:R&D和O&M.这3条元组被检测出来.5.2基于排序的方法SQL语句检测不一致的方法简单易行,但其缺点是需要先将数据导入到数据库中.而且上述语句只能找到违反约束的元组,并不能够准确定位到是元组上的哪个属性值违反了约束.本文提出基于排序的方法,很容易地避免了这些问题.其大致思想是把所有的元组按照约束前件排序,在约束前件上相等的元组被聚集到了一起,然后检查这些在前件上相等的元组在约束后件上是否全都相等.利用排序的方法还有一个好处,就是在检测多Page10条约束的时候,在一定条件下可以进行约束之间共享排序操作的优化.假设有关系实例r={t1,t2,…,tn},用户定义的微函数依赖φ1f2,固有微函数依赖φI的依赖关系,只需要进行一次排序,就可以完成对φ1:f1→f1和φ2定理7.已知R上有固有函数依赖φf2,对于R上的任意一个实例r,存在对r中所有元组的一种排序,使得在f1和f2上值相等的元组都连续.证明.只需要构造一种排序,使得r满足在f1和f2上值相等的元组都相邻:以f2为第1关键字,f1为第2关键字,将所有元组从小到大排序.因为f2是第一排序关键字,因此在f2上相等的所有元组一定是连续的.另外,对于r中任意两条在f1上值相等的两条元组t1和t2,排序之后的元组如下所示:因为t1和t2在f1上的值相等,即a1=a2,由固有微函数依赖φI等,即b1=b2.又由于f2是第1排序关键字,所以对任意位于t1和t2之间的元组t来说,其在f2上的值也和t1和t2相等,即b=b1=b2,因此t1到t2之间的所有元组在f2上值相等.同时因为f1是第2排序关键字,所以t1到t2之间的所有元组在f1上是有序的.由a1=a2可知,a=a1=a2,即证明了在f1上值相等的所有元组,也都是连续的.元组在f1和f2有序之后,只需一遍顺序扫描,就能检测出违反φ1组:对于相邻元组t1和t2,如果它们在f1(或f2)上值相等,只需要判断它们在f1(或f2)上的值是否也相等,如果不等,则输出在f1(或f2)上值等于t1[f1](或t1[f2])的所有元组.6实验结果及分析本文在真实数据上进行试验,验证微函数依赖与函数依赖以及条件函数依赖相比在检测数据错误时的覆盖率以及性能.6.1实验环境和数据集实验环境:英特尔酷睿双核E7500@2.93GHz处理器,金士顿DDR32GB1333MHz内存,日立320GB7200转硬盘.采用MicrosoftWindows7操作系统,开发环境为MicrosoftVisualStudio2008.实验数据集采用一个扩展的Employee表(见表1),包括10万条元组,8个属性:Eid(员工编号),Name(员工姓名),Dept(所在部门),Position(职位),EntryDate(入职日期),Salary(薪水),Phone(电话号码)和City(所在城市).在Employee上,有10条微函数依赖φ0~φ9其中前3条是函数依赖,φ3所示.函数SubStr(str,idx,len)用来从str中的idx位置开始,提取长度为len的子串.AreaCode用来从电话号码中提取区号.LessThanOneYear(date)是判断日期date距今是否小于一年.所有的这些函数都能够在常数时间内计算出来.φ4~φ7不同位置的子串具有不同的含义.φ8的部分信息(区号)可以决定员工所在城市.φ9所有工作不满一年的员工只能获得相同的基本工资.为了进行错误检测,首先往Employee表中引入错误,并得到脏数据表errEmp.对每一个单元格,其值以概率ep(5%~10%)发生改变,这种改变可以是用表中已有值替换,也可以随机变化(字符串的插入删除或替换字符操作,数值的增加误差操作),两种方式各占一半的概率.:[Eid]→[Name,Dept,Position,EntryDate,Salary,Phone,City];:[Dept,City,Name]→[Eid,Position,EntryDate,Salary,Phone];:[Phone]→[City];:[IsManeger(Position),Dept,City]→[Eid,Name,Entry-Date,Salary,Phone];:[Substr(Eid,1,2)]→[City];:[Substr(Eid,3,2)]→[EntryDate];:[Substr(Eid,5,2)]→[Dept];:[Substr(Eid,7,1)]→[Position];:[AreaCode(Phone)]→[City];:[LessThanOneYear(EntryDate)]→[Salary];φ0φ1φ2φ3φ4φ5φ6φ7φ8φ96.2覆盖率errEmp中发生错误的单元格集合记作ERRORs.如果几个单元格共同违反了一个约束φ,称这几个单元格被约束φ检测出来,φ能够检测出来的所有单元格记为Detectedφ,则φ的覆盖率为Coverageφ=|Detectedφ∩ERRORs|/|ERRORs|.类似的,对于一个依赖集Σ:Page11CoverageΣ=经过10次独立的运行,得到函数依赖、条件函数依赖和微函数依赖各自覆盖率平均值,结果如图2、图3所示,可以看出微函数依赖可以检测出多得多的错误.注意在本文中,FDsCFDsMDs,意味着φ4~φ9到函数依赖和条件函数依赖覆盖率的曲线几乎是重合的,这是因为二者只相差一个φ3的元组很少.图3覆盖率随出错概率的变化,元组条数=5×1046.3性能为检测错误数据,本文采用基于排序的方法检测约束被违反的情况.对比了不同类型约束下的时间开销,并对比了优化前后的时间效率.给定一个微函数依赖φ,首先以φ的约束前件为排序键,并检查相邻的所有元组.不难得出此方法能够正确地检测出所有不一致数据,且复杂度为O(nlog(n)),其中n是元组条数.图4和图5描述了每检测一条约束所花的平均时间.可以看出微函数依赖比函数依赖的代价稍高,主要是因为计算提取函数的时候稍微耗时.注意到条件函数依赖的时间开销比较低,主要是因为唯一的条件函数依赖φ3匹配到很少的数据.图4检测一条约束平均时间随元组数的变化,错误率=5%图5检测一条约束平均时间随出错概率的变化,图6描述了每发现一个错误数据,所花的平均时间,从图中可以看出,微函数依赖在单个错误上的平均时间开销和条件函数依赖接近,远低于函数依赖.即微函数依赖均摊到每个错误上的时间成本是远远低于函数依赖和条件函数依赖的.图6发现一个错误的平均运行时间随元组数的变化,Page12在共享排序的实验中,约束φ0之间是可以进行排序共享的.图7和图8显示了φ8在微函数依赖的冲突检测中,共享排序的优化策略对时间开销的影响,可以看出优化效果还是十分明显的,大约节省20%的时间.图7优化技术对运行速度的影响:检测一条约束平均时间随元组数的变化,错误率=5%图8优化技术对运行速度的影响:检测一条约束平均时间随出错概率的变化,元组条数=50000从上述实验结果可以看到,在可接受的时间代价内,微函数依赖能够检测出比以前方法多得多的错误数据.而且本文提出的基于排序的方法在经过排序操作共享的优化之后,时间效率有很明显的提高.7相关工作为了解决数据的不一致问题,已有研究主要有两个方向,第一个方向是找出一个满足依赖的最小修复[15],此处“最小”的含义是,删除或插入最少的元组,或者更改最少的属性值,或者产生最小的修复代价.这些方法都被证明是难解问题.另一类方法是一致查询[16],其含义是:给定一个查询,找出该查询在所有极小修复上查询结果的交集.很显然,这种方法比前者的复杂性更高.为了解决传统函数依赖和条件函数依赖修复数据的难点,文献[10,17-18]主要研究了基于编辑规则和主数据的编辑距离的数据修复方法,这种规则假定主数据是完整而且正确的,如果一条元组与主数据中的某条元组在某些特定属性上的值满足一定的距离限制,那么它在另外某属性上也应该和主数据相同.基于主数据和编辑距离的方法不仅能够方便快速地发现数据错误,还能够直观地指导数据修复,避免了(条件)函数依赖方法中的修复难解问题.然而,这种方法的假定场景比较强,它需要存在一个完全可靠的高质量主数据,而在实际应用中,这样的条件是未必能够满足的.此外,同一研究组又提出了能够得到可靠修复的修复规则[11],并对其可满足性做了分析.修复规则在包含约束语义的同时,还包含了如何进行修复的信息,比如,关系模式(国家,首都)上的规则(“中国”,{“上海”,“香港”},“北京”)表示的语义是,如果国家名称为“中国”,首都名称为“上海”或者“香港”,那么这条记录是错误的,因为可以看出该记录是关于中国的,那么首都应该被修改成“北京”.修复依赖同基于主数据的编辑规则类似,也是把大量的可靠信息引入规则中,从而保障能够得到确定可靠的修复结果.除此之外,还有更多的约束类型被提出来:文献[13]提出了“差分依赖”,它描述:如果两个元组在某一个属性上值的距离足够近,那么在另外一个属性上,它们的值也足够接近,例如:约束[Date(7)]→[Price(<100)]表示7天之内物品的价格波动不能够超过100元.文章首先解决了几个理论问题:差分函数之间的包含关系、蕴含问题、闭包、正确且完备的推理系统、极小覆盖等.并证明了这类依赖的挖掘问题属于难解问题,给出启发式搜索算法以及有效的剪枝策略.为了研究数据空间中异构数据之间的数据依赖,文献[14]定义了一个一般化的约束形式:可比较约束.它制定了可比属性之间的约束.它包含了一个数据库领域的一个广泛约束类.包括函数依赖,度量函数依赖等.文章研究了约束的可满足性,证明它是难解问题,并给出贪心和随机算法计算最大可满足性子集.文献[19]针对异构数据源中由数据格式不一致引发的一致性错误,利用描述属性值相似性测度扩充了函数依赖,用来描述异构数据的一致性约束,发现和修复异构数据的一致性错误.文献[20]提出了空间语义完整性约束形式化定义,能Page13够对现实中的约束进行统一描述,是对传统函数依赖和包含依赖的扩展,更重要的是考虑了空间属性,对空间特征之间加上了拓扑关系.文章研究了该种约束的可满足性,证明该问题属于难解问题,也给出了非难解情况下的算法,来检查约束集的可满足性,对于难解情况,给出近似算法存在的条件.文献[21]在有时间戳的数据上提出了序列依赖语义规则,用来描述随时间变化数据的一致性约束,试图解决随时间变化数据的一致性错误的发现和修复问题.此外,对于实体也有一类一致性描述方法,即实体同一性或实体识别(又称记录匹配,元组匹配),它是信息质量方面研究最多的领域.针对存储在关系数据库中的信息,人们已提出了多个实体识别算法[22-30].这些工作大多偏重于如何提高信息中识别实体的效率,如分块技术[31]和滑动窗口技术[32].市场上的信息清洗商业系统也大多支持实体识别的功能.然而,实体识别方法仍然存在如下问题:(1)需要相关领域专家的人工参与,或依赖于概率式启发式规则或学习式的启发式规则,工作量大,自动化程度低;(2)现有的实体识别算法大多缺乏理论基础,很难与解决信息质量其他问题的技术融合;(3)现有实体识别技术多专注于存储在关系数据库中的信息,鲜有针对复杂结构信息的实体识别技术.为解决前两个问题,Fan等人[33-34]也提出了一个匹配约束理论,包括描述匹配规则的约束语言、推理机制、公理系统和匹配键的推导算法,有效地自动确定匹配键,并使信息匹配操作能够与基于约束的其他信息质量问题的处理方法有效地结合.人们已开发了自动发现匹配约束的算法[35].8结论及未来工作文章将已有的函数依赖和条件函数依赖进行了扩展,提出更一般化的微函数依赖.静态分析方面,证明了微函数依赖的可满足问题是NP-完全的,蕴含问题是CoNP-完全的.另外,给出了由五条推理规则构成的推理系统,并证明了该系统的正确性以及完备性.最后,文章通过实验验证了微函数依赖能够检测出更多的错误数据,而时间开销的增加在可接受的范围内.本文主要从理论上讨论了微函数依赖的性质.除此之外,还有如下几个方面需要进一步研究:(1)微函数依赖的挖掘问题,为了充分发挥其在数据修复中的作用,有必要给出足够的微函数依赖.仅仅靠用户手动给出是不现实的,应该针对不同类别的函数给出不同的挖掘方法;(2)本文假设固有函数依赖都由用户给出,假设条件略强,可以针对不同类别的函数,分别研究其固有函数依赖集是否能够自动生成,如果可以,是否存在有效算法等;(3)在本文基于排序的算法中,约束之间的排序共享是直接人工给出的,当约束个数很多时,不同的共享策略之下是否有不同的排序次数.如果排序次数受共享策略的影响,则需要研究如何找出最优的排序共享策略,使得排序次数最少,检测错误所花的时间最低;(4)提出微函数依赖的最终目的,是为了进行数据修复,本文实验中只给出了最直观的方法,面临日益严峻的大数据问题,如何快速有效地利用微函数依赖发现并修复数据库中的不一致,也是值得进一步研究的问题.
