Page1新的基于身份的多接收者匿名签密方案庞辽军1),2)崔静静2)李慧贤3)裴庆祺2)姜正涛4)王育民2)1)(西安电子科技大学生命科学技术学院西安710071)2)(西安电子科技大学计算机网络与信息安全教育部重点实验室西安710071)3)(西北工业大学计算机学院西安710072)4)(中国传媒大学计算机学院北京100024)摘要针对现有基于身份的多接收者签密方案存在的接收者身份泄露和解签密不公平等问题,文中提出一种具有公平性的基于身份的多接收者匿名签密方案.该方案运用拉格朗日插值多项式实现匿名性,不仅能解决现有方案不能保护接收者隐私的问题,而且具有解签密公平性,可防止发送者的欺骗行为.最后,对方案的正确性以及安全性进行了证明,并与其它方案进行了性能比较.分析发现,该方案是一个安全有效的多接收者签密方案,可以用于不安全和开放网络环境中的敏感消息广播.关键词匿名性;公平性;多接收者签密;基于身份的签密;拉格朗日插值1引言在网络广播服务中,消息发送者通常需要对外发布一些敏感消息,并希望只有其授权的用户才可以得到该消息,因此,需要对广播信息进行加密.另外,用户为了避免收到某些无聊的信息,他也希望可以对接收到的广播消息来源进行认证.由于以上需求,多接收者签密思想[1]被提出.随着网络广播技术的发展,在一些特殊情况下,发送者希望其授权用户只验证消息来自某个可靠群体中的一员,无需确切得到发送者真实身份,以保护自身隐私.基于这一需要,匿名的多接收者签密方案[2]被提出.在一个多接收者匿名签密方案中,签密者,即消息发送者,将自己的身份隐藏在一个身份集合中,并利用自己的私钥对一组信息进行签密,而每一个授权的解签密者,即消息接收者,可以利用自己的私钥对密文进行验证并解签密以获取明文信息.由于多接收者签密能够仅通过一次签密操作完成对多个接收者发送同一消息,比传统的一对一方式更有效、更实用,特别适合网络安全广播和安全组播等业务.目前,多接收者签密已成为信息安全领域的一个研究热点.基于Duan等人[1]提出的多接收者签密概念,具有签密者匿名性的签密方案被提出[2].随着人们对个人隐私的日益重视,不仅发送者渴望广播消息时不泄露自己的身份,接收者也希望自己收到某个消息的事实对他人保密.分析发现,现有大多数多接收者签密方案[2-7]的密文信息暴露接收者身份,因为在这些方案中,所有授权用户的身份信息及其关联顺序是密文的一部分.除了隐私问题外,现有方案的这种处理方式还会导致解密不公平,也就是说,当密文信息部分损坏后,可能会导致一部分授权用户能够正确解密,另一部分无法正确解密.鉴于以上考虑,针对现有多接收者匿名签密存在的接收者身份暴露和解密不公平等问题,本文提出一个新的多接收者签密方案,以解决接收者身份隐私和解密不公平问题.所提方案的密文中不再需要给出接收者的身份列表,从而能够保护接收者的隐私,同时,将每一个接收者所需的不同信息变换成一个公用的信息集以实现解密公平性.因此,除了保密性和发送者不可伪造性外,相对于现有方案,本文方案具有以下优点:(1)不仅发送者具有匿名性,接收者也具有匿名性,消息密文不再泄露任何接收者的身份信息,从而可以保护他们的隐私;(2)具有解密公平性,使得对所有授权接收者而言都有相同的机会获得解密结果,要么所有授权接收者均正确解密,要么均无法正确解密.本文第2节介绍相关工作;第3节介绍本论文方案用到的基本知识;第4节具体介绍我们的方案;第5节对本文方案进行分析与证明,并将其与现有方案进行对比分析;第6节总结全文.2相关工作签密概念最早是由Zheng[8]于1997年提出的,思想是让公钥加密和数字签名同时进行,使得签密后的消息同时具有机密性和可靠性,且相较于传统的签名-加密模式,具有更小的计算和传输代价.因此,签密得到人们的关注[7,9].2002年,第一个基于身份的签密方案被提出[9].这些方案的特点是一对一签密,即发送者通过一次签密只能向一个接收者传输密文信息.而当发送者需要向多个传输者传输同一消息时,上述签密方案需要对每一个接收者重复执行签密操作.当一则消息需要向多个接收者传送时,传统的加密方案由于要重复多次加密过程,效率和实时性较低,不能满足实际应用需求[10],因此,多接收者加密概念被提出.融合签密概念和多接收者加密思想,Duan等人[1]于2006年提出了第一个基于身份的多接收者签密方案,签密者对一则消息进行一次签密,每个接收者均可使用自己的私钥对接收到的消息的机密性和可靠性进行验证.然而,在该方案中,密文内容包括两部分,即密文正文和接收者信息.但实际上由于该方案密文中并没有包含接收者身份列表信息,接收者无法在密文中找到自己所需要的信息(经我们对文献[1]方案的分析,遗漏接收者身份列表信息问题可能属于作者笔误),故方案并不完善.2007年,文献[3]提出了一个更为高效的基于身份的多接收者签密算法,并在密文中补充了接收者身份列表.此后,又有其它类似的方案被提出[4-5].匿名签名的设计思想源自环签名,最初是由Rivest等人[11]于2001年提出的.匿名方案使得接收者无法得知消息的真实签密者,但可以验证消息的签密者是一个群体中的一员,既满足了签密者的匿名性,又保证了消息来源的可靠性.Huang等人[12]于2005年提出了第一个基于身份的匿名签密方案.2009年,文献[13]给出了一个新的高效的接收者匿名签密方案,文献[14]对其进行了改进.基于上述匿名设计思想,Lal等人在文献[2]中提出了第一个签密者匿名的多接收者签密方案,该方案中通Page3过把签密者的身份混在一个身份集合中来达到签密者匿名的目的.接收者可以验证消息的签密者是该集合中的某个人,从而相信消息来源,但不能确定究竟是谁签署了该消息.2010年,文献[15]给出一种签密者匿名的新方案.而该方案同样存在因密文中缺少接收者身份列表而导致解密不正确的不足.此外,现有多接收者匿名签密方案[2,15]只考虑了发送者匿名问题,而没有考虑接收者的匿名问题.通过上述分析,现有的多接收者签密方案[1-6,15],要么没有考虑匿名性,要么仅仅考虑了签密者即发送者的匿名性,而接收者的匿名性却没有被提及.事实上,以上方案的密文中都需要包括接收者身份列表(文献[1,15]中的方案由于作者笔误而遗漏),接收者需要通过列表中自己所在的序列号找到密文中自己需要的特定信息,继而对密文解密.这样必然存在如下缺陷:首先,暴露了接收者身份.此外,每个接收者所需要的特定信息只是整个签密密文中的特定部分,故存在解密不公平问题.如果密文在传送过程中出现错误,会导致部分接收者无法正确解密,而另一些接收者却可以对消息进行正确解密.更严重的是无法避免发送者有意欺骗某接收者的攻击.鉴于以上考虑,本文提出一种新的多接收者匿名签密方案,该方案可以同时满足接收者和签密者的匿名性.此方案包含一个身份集合用来混淆真实签密者的身份,但是不包含接收者身份列表信息,故没有直观地展示授权接收者的身份,不仅使攻击者无法得到接收者的信息,而且接收同一则消息的所有接收者都不能获得除自己以外的其它接收者的任何信息,从而解决了接收者的隐私问题.此外,由于签密消息被广播出去后,任何用户都可以接收到广播消息,而仅有发送者授权的接收者才可以正确解密.方案为用户提供了一个判断方法来确定自己是否具有解密权限,避免非授权用户不必要的解密操作.而且每个接收者所需要的密文消息均为一个相同集合,一旦集合中某个元素发生错误,所有接收者都无法正确解密密文,故满足公平性.3背景知识3.1安全假设基于以下难题和安全假设.的生成元,e:G1×G1→G2为一个双线性映射.设G1和G2为两个阶为q的循环群,且P为G1本文所设计的多接收者匿名签密方案的安全性(1)ComputationalDiffie-Hellman(CDH)问(2)DecisionalBilinearDiffie-Hellman(DBDH)题.已知〈P,aP,bP〉,其中a,b∈Z问题.已知〈P,aP,bP,cP,Z〉,其中a,b,c∈ZG2,判断Z=e(P,P)abc是否成立.定义1.CDH假设.定义一个概率多项式时间算法B,其输出为β∈{0,1},解决CDH问题的优势定义为AdvCDHq].如果对于任何多项式时间算法,优势AdvCDHZ是可忽略的,则称之为满足CDH假设.定义2.DBDH假设.定义一个概率多项式时间算法B,其输出为β∈{0,1},其解决DBDH问题的优势定义为AdvDBDHe(P,P)abc)=1]-Pr[B(P,aP,bP,cP,Z)=1],这里a,b,c∈Z算法,优势AdvDBDHDBDH假设.3.2基于身份的多接收者匿名签密方案(MIBAS)基于现有多接收者匿名签密模型[1-6,15],这里给出本文方案的算法模型,包括4个算法,分别为参数生成算法KeyGen,私钥提取算法Extract,匿名签密算法Anony-signcrypt和解签密算法De-signcrypt.本文方案就是基于该算法模型,结合所选取的困难问题和安全假设,对每个算法模块进行具体的设计和实现.KeyGen:私钥生成中心(PrivateKeyGenera-tor,PKG)运用该算法生成主密钥s0以及公开参数params,其中主密钥需秘密保存,公开参数对外公布.Extract:该算法用于提取用户私钥.输入用户的身份IDi,PKG的私钥s0以及系统公开参数params,输出相应的用户私钥di,即di=Extract(IDi,s0,params).其中IDi作为用户公钥对外公开,di为其私钥秘密保存.Anony-signcrypt:输入PKG的公开参数params,明文消息M,发送者选取一个身份集合L={ID1,ID2,…,IDm},其中包含发送者的身份信息IDS,即IDS∈L,以及接收者的身份信息集合L={ID1,ID2,…,IDn},并输入自己的私钥dS,运行该算法,输出消息M对应的不包含接收者身份信息集合L的密文C,即C=Anony-signcrypt(params,M,L,L,dS),满足LC.De-signcrypt:输入密文C,PKG的公开参数params,接收者的身份IDi(i∈{1,2,…,n})及其相应的私钥di,运行该算法,首先判断IDi是否是授权Page4的接收者.如果不是,则退出算法,否则,执行对密文C的解密过程.如果密文C是正确的签密消息,则输出相应的明文消息M,即M=De-signcrypt(C,params,L,di),否则输出⊥.3.3安全模型安全模型用来刻画安全方案所能达到的安全级别以及对所设计方案安全性进行分析和证明.本文将基于以下安全模型对本文所提方案的安全性给出随机预言模型下的安全证明.3.3.1消息保密性提起保密性,最广泛被接受的是选择密文攻击下(CCA)的密文不可区分性安全模型.最初是在文献[9]中被提出的,Duan等人[1]将其扩展到多接收者环境中,并称其为indistinguishabilityofcipher-textsunderselectivemulti-ID,chosenciphertextattack(IND-sMIBSC-CCA),后来Lal等人[2]又将其推广到匿名的签密环境中,并称其为indistin-guishableagainstchosenciphertextattacks(IND-sMIBAS-CCA2),描述如下.定义3.IND-sMIBAS-CCA2假设.假设A是一个攻击者(Attacker),定义Π是一个基于身份的多接收者匿名签密方案.考虑A与一个挑战者(Challenger)B进行以下互动:Setup:B运行该算法,生成主密钥s0以及系统参数params,将params给A,并秘密保存主密钥s0.A收到params以后,输出n个目标身份L={ID1,ID2,…,IDn}.Phase1:A向B进行如下询问.私钥提取询问:当B接收到关于身份ID(ID≠IDi,i=1,2,…,n)的私钥询问时,运行算法Extract得到dID=Extract(ID,s0,params),并返回给A.匿名签密询问:A给出一个身份信息集合L={ID1,ID2,…,IDm},一个目标明文M,n个接收者身份信息L={ID1,ID2,…,IDn}.B随机选择一个身份信息IDi∈L,计算其私钥di,并计算密文C=Anony-signcrypt(params,M,L,L,di),然后将C返回给A.解签密询问:A生成身份信息集合L={ID1,ID2,…,IDm},接收者的身份信息集合L={ID1,ID2,…,IDn}和一个密文C.B随机选择一个接收者IDj∈L,计算其私钥dj.如果C是有效的密文,解密出M=De-signcrypt(C,params,L,dj),并返回给A,否则输出⊥.Challenge:A选择一对等长的消息(M0,M1)和一个身份集合L={ID1,ID2,…,IDm},其中没有对IDi(i=1,2,…,m)进行过私钥提取询问.当B收到(M0,M1)后,随机选择β∈{0,1},计算目标密文C=Anony-signcrypt(params,Mβ,L,L,di),并将C返回给A,其中di为L中随机选择的身份IDi所对应的私钥.Phase2:A像Phase1中那样进行多次询问.注意私钥提取询问时不可以询问L中的身份信息,解密询问时不可以询问C,也不可以对仅在接收者信息部分与C不同的密文消息进行解密询问.Guess:最终,A输出其猜测β∈{0,1}.如果β=β,则A赢得这场游戏.如上所述的A被称为IND-sMIBSC-CCA2攻击者,其优势定义为AdvIND-sMIBSC-CCA2如果对于任意的IND-sMIBSC-CCA2攻击者A,在概率时间t内,它的猜测优势都小于ε,则我们说方案Π是(t,ε)-IND-sMIBSC-CCA2安全的.3.3.2不可伪造性签密方案需要具有不可伪造性,使得发送者不能否认对该消息签名的事实.Duan等人[1]所提出的安全模型被称为strongexistentialunforgeabilityunderselectivemulti-ID,chosenmessageattack(SUF-sMIBSC-CMA).Lal等人[2]将其推广到匿名环境下,并称其为existentiallyunforgeableagainstadaptivechosenmessageattack(EUF-MIBAS-CMA),描述如下.定义4.EUF-MIBAS-CMA假设.假设F是一个伪造者(Forger),定义Π是一个基于身份的多接收者匿名签密方案.考虑F与一个挑战者(Challenger)B进行以下互动:Setup:B运行该算法,生成主密钥s0以及系统参数params,将params给F,并秘密保存主密钥s0.Attack:F向B进行一系列询问,如定义3所述那样.Forgery:F最终输出一个新的密文消息C和n个接收者的身份信息L={ID1,ID2,…,IDn}.如果C是IDS对消息M对应于发送者身份集合L={ID1,ID2,…,IDm}的签名,且可以被任何L中的接收者正确解密,则C是有效密文,F赢得这场游戏.注意F不能对L和L中的身份进行私钥提取询问,且C不能由Anony-signcrypt算法产生.F的优势为其成功的概率.Page54方案描述本方案包含KeyGen,Extract,Anony-signcrypt和De-signcrypt4个算法:PKG通过KeyGen算法建立系统公开参数,并提供对其它非PKG成员的注册服务;非PKG成员(包括发送者和接收者)在进行签密和解签密之前需要向PKG进行注册,并通过Extract算法获取自己的私钥;经过注册的发送者可以使用Anony-signcrypt算法向一组授权接收者发送签密消息,同时不暴露发送者和接收者真实身份;授权的接收者使用De-signcrypt算法可以验证自己是否为授权接收者,并在自己为授权接收者的条件下正确地解密密文.具体描述如下.参数生成算法(KeyGen)PKG执行以下过程:1.设G1和G2分别是阶为q2k(k是一个长整数)的加法群和乘法群,P是G1的生成元.选择双线性映射e满足e:G1×G1→G2.2.定义4个单向Hash函数:H1:{0,1}→G1;H2:G2→{0,1}l0;H3:{0,1}l0×G1→Zq;H4:{0,1}→Zq,其中l0表示明文和密文的长度.H1,H2,H3,H4〉,并秘密保存主密钥s0.3.选择一个随机数s0∈Zq为主密钥,设置Ppub=s0P∈G1为系统的公钥.随机选择P0∈G1,并计算g=e(Ppub,P0).4.公开系统参数params=〈G1,G2,q,e,P,Ppub,P0,g,私钥提取算法(Extract)该算法由PKG执行.输入参数params,s0和身份ID∈{0,1},算法包括以下步骤:1.计算ID的公钥QID=H1(ID).2.设置ID的私钥dID=s0QID.签密算法(Anony-signcrypt)该算法由签密者即消息发送者执行.输入参数params,消息M.设IDS是真正的签密者,L={ID1,ID2,…,IDn}是签密者选择的n个接收者,IDS的签密过程如下:L,L∩L=.1.选择一个用户集L={ID1,ID2,…,IDm},且IDS∈Ri=uiP.2.随机选择整数ui∈Zq,i∈{1,2,…,m}\{S},并计算3.随机选择整数uS∈Zq,并计算α=∑m4.计算hi=H3(W,Ri),i∈{1,2,…,m}\{S}.令RS=gα和W=H2(σ)M.uSQS-∑mi=1,i≠SR2,…,Rm}.5.计算V=(uS+hS)·dS,其中hS=H3(W,Rs),dS是IDS的私钥.6.令xj=H4(IDj),yj=α(P0+Qj),j=1,2,…,n,得到n对数:(x1,y1),(x2,y2),…,(xn,yn),构造拉格朗日函数Fj(x)满足xj是Fj(x)=yj的根,其中Qj是IDj的公钥.7.对于j=1,2,…,n,计算fj(x)=∏1j≠jn其中aj,1,aj,2,…,aj,n∈Zq.8.对于j=1,2,…,n,计算Tj=∑n9.密文为C=〈U,V,W,T,R,L〉.解签密算法(De-signcrypt)该算法由解签密者即消息接收者执行.输入密文C=〈U,V,W,T,R,L〉,params,接收者身份IDj及其私钥dj,对C进行解密,具体算法如下:T2,…,Tn}.1,2,…,m.则签密者是集合L中的成员之一,否则退出.Verify:1.计算K=∑m2.判断等式e(V,P)=e(K,Ppub)是否成立.如果成立,Judge:1.判断等式V·Qj=K·dj是否成立.如果成立,IDj可Decrypt:1.计算δj=T1+xjT2+…+(xjxj=H4(IDj).以对消息进行解密,否则退出.2.计算σ=e(Ppub,δj)·e(U,dj)-1,M=H2(σ)W,M则为解密后所得到的消息明文.5分析与证明5.1正确性分析送者身份的验证过程(Verify)是正确的.e(V,P)=e((uS+hS)dS,P)=e(uSQS+hSQS,Ppub)定理1.Verify算法正确性.解密算法中对发证明.即e(V,P)=e(K,Ppub).者解密权限判断过程(Judge)是正确的.定理2.Judge算法正确性.解密算法的接收证明.对于每一个IDj,j∈{1,2,…,n},有Page6V·Qj=(uS+hS)dS·Qj=(uSQS+hSQS)·dj定理3.Decrypt算法正确性.解密算法的解证明.对于每一个IDj,j∈{1,2,…,n},计算即V·Qj=K·dj.密过程(Decrypt)是正确的.δj如下:δj=T1+xjT2+…+xj-1=(a1,1α(P0+Q1)+…+an,1α(P0+Qn))+(xja1,2α(P0+Q1)+…+xjan,2α(P0+Qn))+…+(xj-1ja1,jα(P0+Q1)+…+xj-1(xn-1ja1,nα(P0+Q1)+…+xn-1=(a1,1+a1,2xj+…+a1,nxn-1(a2,1+a2,2xj+…+a2,nxn-1(ai,1+ai,2xj+…+aj,nxn-1(an,1+an,2xj+…+an,nxn-1=α(P0+Qj)dj)-1,具体过程如下:σ=e(Ppub,δj)·e(U,dj)-1因此,我们可以得到σ=e(Ppub,δj)·e(U,=e(Ppub,α(P0+Qj))·e(αP,s0Qj)-1=e(Ppub,αP0)·e(Ppub,αQj)·e(s0P,αQj)-1=e(Ppub,P0)α·e(Ppub,αQj)·e(Ppub,αQj)-1=gα=σ所以,M=H2(σ)w.下面我们分别对方案的消息保密性和不可否认5.2安全性证明性给出随机预言模型下的安全证明.定理4.消息保密性.在安全模型中,如果存在一个IND-sMIBSC-CCA2敌手A能够在时间t内,以一个不可忽略的优势ε赢得定义3中的游戏(此处他最多能进行qe次私钥提取询问,qs次签密询问,qd次解签密询问和qH1,qH2,qH3,qH4次对Hash函数H1,H2,H3,H4的询问),则存在一个算法B能够在时间tt+4qdO(t1)内,以优势εε-nqd2k解决DBDH问题(其中t1是双线性对运算e的运算时间).证明.下面我们给出算法B如何利用A在时间t内以概率ε解决DBDH问题.首先,B得到一个DBDH问题实例〈P,aP,bP,cP,Z〉,其目标为判定Z=e(P,P)abc是否成立.B模Phase1:A向B进行如下询问.H1-query:向H1输入一个身份IDk,如果H1-list中存在(IDk,lk,Qk),则返回Qk.否则,进行以下步骤:1.如果IDk=IDj,j∈{1,2,…,n},随机选择一个整数lj∈Zq,计算Qj=ljP-P0.否则随机选择一个整数lk∈Zq,计算Qk=lkP.2.将(IDk,lk,Qk)存入H1-list,返回Qk.Hi-query,i∈{2,3,4}:为回答这些询问,B首先查找相应的列表Hi-list,i∈{2,3,4},如果询问目标已经存在,则返回相应的回答给A.否则,B随机选择一个恰当的元素作为询问结果返回给A,并将该询问和结果添加到相应的列表中.私钥提取询问:当B接收到关于身份IDk(此处IDk≠ID(IDk,lk,Qk),计算dk=lkPpub=clkP,并将dk返回给A.匿名签密询问:B收到匿名签密询问(M,L,L)(其中L={ID1,ID2,…,IDm},L={ID1,ID2,…,IDn})时,此处存在两种情况,描述如下:1.B随机选择IDS∈L.如果对于任意j∈{1,2,…,n}有IDS≠IDj,则B可以在H1-list中查找并计算出IDS的私钥dS=lSPpub=clSP.B以(M,dS,L,L)作为匿名签密算法的输入,计算出密文C,并将其返回给A.拟一个挑战者如定义3中所述那样进行每一步过程.此过程中A分别进行签密询问,解密询问以及对Hi,i=1,2,3,4的询问,其中对Hi的询问结果被存放在Hi-list中.Setup:B设定P0=bP和Ppub=cP,那么g=e(P0,Ppub)=e(bP,cP)=e(P,P)bc,将params=〈G1,G2,q,e,P,Ppub,P0,g,H1,H2,H3,H4〉作为系统参数给A.收到系统参数后,A输出n个目标身份L=(ID1,ID2,…,IDn).2.B随机选择IDS∈L.如果对于某个j∈{1,2,…,n}有IDS=IDj,则令QS=lSP-P0.随机选择u1,u2,…,uS,…,um∈Zq,并计算α=∑mi∈{1,2,…,m}\{S},分别计算Ri=uiP,得到hi=H3(M,Ri),并保存到H3-list.计算U=αP和xj=H0(IDj),yj=α(P0+Qj),j=1,2,…,对n构造拉格朗日插值函数Fj(x)满足xj是函数Fj(x)=yj的根.对于j=1,2,…,n,计算fj(x)=∏1j≠jnaj,1,aj,2,…,aj,n∈Zq,再计算Tj=∑n机选择hS∈Zq,设RS=uSP-hSQS-∑mV=uSPpub,将(W,RS,hS)保存到H3-list.最终,B输出密文Page7C,并将其返回给A.解签密询问:A输出一个密文C=〈U,V,W,T,R,L〉和一个接收者身份IDj,j∈{1,2,…,n},向B进行解签密询问.如果IDj∈L,则B不知道IDj的私钥,只能返回密文C无效.如果密文C本身是有效的,B拒绝C的概率不多于n/2k.如果IDjL,且B验证e(V,P)=e∑mH1-list得到IDj的私钥dj,再计算出δj.计算σ=e(Ppub,δj)·e(U,dj)-1,M=H2(σ)W,返回M给A.否则密文C无效,输出⊥.Challenge:A输出一对等长的消息(M0,M1)和一个身份集合L={ID1,ID2,…,IDm}.接收者身份集合L={ID1,ID2,…,IDn}是被攻击对象.B随机选择β∈{0,1},对消息Mβ进行签密.首先,B令U=aP,σ=Z,查找H1-list获得与IDi∈{1,2,…,n}相对应的l而得到T文C=〈U,V,W,T,R,L〉,并将C返回给A.Phase2:A像Phase1中一样进行多次询问,注意私钥提取询问时不可以询问L中的身份信息,解密询问时不可以询问C,也不可以对仅在接收者信息部分与C不同的密文消息进行解密询问.Guess:最终,A输出其猜测β∈{0,1},如果β=β,B输出DBDH问题的解,因为Z=e(Ppub,y=e(cP,l=e(cP,l=e(cP,l=e(P,P)abc分析:下面开始分析B的优势.对于qd次解密询问,B拒绝有效密文的概率不超过nqd2k.若A赢得IND-sMIBAS-CCA2游戏,则B的优势为ε=|Pr[B(aP,bP,cP,Z)=1]-Pr[B(aP,bP,cP,e(P,P)abc)=1]|ε+1tt+4qdO(t1)(其中t1是双线性对函数e的运算时间).定理5.不可伪造性.在安全模型中,如果存在一个EUF-MIBAS-CMA敌手F能够在时间t内,以一个不可忽略的优势ε赢得定义4中的游戏(此处他最多能进行qe次密钥提取询问,qs次签密询问和qH1,qH2,qH3,qH4次对Hash函数H1,H2,H3,H4的询问),则存在一个算法B能够在时间tt内,以优势εε-qs2k解决CDH问题.证明.下面我们给出算法B如何利用F在时间t内以概率ε解决CDH问题.首先,B得到一个CDH问题实例〈P,aP,bP〉,其目标为计算出abP.B模拟一个挑战者如定义4中所述那样进行每一步过程.Setup:B设定Ppub=bP,将params=〈G1,G2,q,e,P,Ppub,P0,g,H1,H2,H3,H4〉作为系统参数给F.收到系统参数后,F输出目标身份IDS.其中对H1,H2,H3和H4的询问如定理3中所述.i=1xi,ω=gα和RS=xSQS-∑mAttack:F向B进行如下询问.私钥提取询问:当B接收到关于身份ID(ID≠IDS)的私钥询问时,就在H1-list中寻找(ID,l,Q),计算私钥d=blP,并将其返回给F.匿名签密询问:对于一个关于(m,L,L,IDS)(其中IDS∈L={ID1,ID2,…,IDm},L={ID1,ID2,…,IDn})的签密询问,B随机选择xi∈Z{1,2,…,m},计算Ri=xiP,i∈{1,2,…,m}\{S},α=∑m计算U=αP和W=H2(ω)M.在H3-list中查找(W,RS),得到hS.如果不存在,就随机选择hS∈q,并将(W,RS,hS)保存在H3-list中,计算V=Z(xS+hS)dS=(xS+hS)lSbP.B在H4-list中查找IDj对应的结果xj,并计算yj=α(P0+Qj),j=1,2,…,n,由此得到Tj,j∈{1,2,…,n}.最终,B得到密文C,并将其返回给F.Forgery:F生成一个目标密文C=〈U,V,W,T,R,L〉,如果这个伪造是成功的,我们就有e(Z,P)=ePpub,∑mlSP=aP,则有V=(xS+hS)dS=(xS+hS)lSbP=(xS+hS)abP,这样就很容易提取出CDH问题的解abP=V(xS+hS)-1.下面我们考虑B成功的优势.由于签密询问中,B对签密询问回答失败的概率不大于qS2k,所以我们得到优势εε-qS2k,且tt.5.3性能比较与效率分析5.3.1性能比较与现有基于身份的多接收者签密方案进行比较,我们的方案性能更好,如表1所示(部分性能分析参见5.3.2小节).Page8表1本文方案与现有方案的性能比较Duan等人方法[1]基于身份的签密双线性对技术Lal等人方法[2]Yu等人方法[3]Sharmila等人方法[4]基于身份的签密插值多项式技术Elkamchouchi等人方法[5]基于身份的签密双线性对技术Qin等人方法[6]Zhang等人方法[15]基于身份的签密双线性对技术新方案对表1的解释如下:(1)接收者身份列表.这是现有方案都必须包含的信息,用于接收者查找自己所需要的密文信息.而本文方案无需包含接收者身份列表,从而提供了接收者匿名性.文献[1,15]中缺少此部分(经分析可能是作者笔误),会导致接收人无法从密文中查找自己所需要的信息,故无法对消息进行正确解密.并且当缺少身份列表时,又没有给出接收者权限验证过程,会导致非授权用户进行不必要的解密开销.(2)接收者匿名性.每一个接收者对于攻击者以及其它接收者来说都是匿名的.由于签密者将消息进行广播,所以任何用户都可以接收到密文消息.在许多现有文献中,如文献[1-6,15],密文需要包含一个标志信息(文献[1,15]本身也是需要的)才能使接收者在密文中找到自己需要的信息来对密文进行解密,而标志信息就是所有授权接收者的身份信息集合,故接收者的身份会直接暴露出来,从而不具备隐私性.但是在我们的方案中,加密过程中使用拉格朗日插值函数将所有授权接收者的身份信息IDi糅合在一起,并隐藏在集合T={T1,T2,…,Tn}中,每个接收者都得不到其它授权接收者的任何信息,从而具有接收者匿名性.(3)发送者匿名性.每一个接收者只能验证消息来源于一个群组中的一员,而无法确定发送者的真实身份.文献[1,3-6]的方案中,解密者会得到发送者的真实身份,而在一些特殊情况下,这将给发送者带来提出多接收者签密方案标准模型下具有安全性发送者和接收者双重匿名性;不利或负面影响,此时发送者需要匿名发布消息,以保全自己的名誉.文献[2,15]的方案以及本文方案将发送者的身份隐藏在一组身份L={ID1,ID2,…,IDm}中,这组身份均是接收者所信任的,故接收者既相信了消息来源的可靠,又无法得到真实的消息来源.(4)解密公平性.一旦消息在传输过程中出错或者被破坏,所有接收者都将得不到正确的消息明文.现有方案[1-6,15]中,每个接收者需要通过列表中自己所在的序列号找到消息密文中自己所需要的特定信息,才可以对消息进行解密,然而一旦传输过程中密文信息发生错误,会直接导致部分接收者无法对消息进行解密,而其他接收者却可以解密,故不具有公平性.在我们提出的方案中,密文为C=〈U,V,W,T,R,L〉,解密过程中所有出现的元素对于每个接收者而言都是必须的,故任何一个元素出错,所有接收者都无法正确解密,从而对所有授权的接收者而言解密过程是公平的.(5)提前判断性.接收到广播消息的用户可以在解密前验证自己是不是授权的接收者,避免不必要的解密开销.本方案中虽然没有直观地给出授权接收者的身份列表,但是每一个接收到签密消息的用户可以通过一步简单的判断方法来确定自己的解密权限.如果等式V·Qj=K·dj成立,则用户IDj是授权的接收者,否则无需对消息解签密.5.3.2效率分析这里主要从签密过程的计算成本和通信量两个方面来比较现有基于身份的多接收者签密方案和本Page9文所提出的方案,具体分析如下:(1)在本文方案中密文C=〈U,V,W,T,R,L〉的长度为(m+n+2)G1+M+mID.在文献[15]的方案中,密文信息缺少了接收者身份标志,如果添加上接收者身份标志,密文的真实长度应该为(m+n+2)G1+M+(m+n)ID,大于本文所提出的方案.文献[2]的方案中,密文长度同样大于本文提出的方案.文献[1,3-6]中,虽然密文长度较短,但是它们并没有实现发送者和接收者的匿名性这一功能.总之,与现有匿名方案[2,15]相比,本文提出的方案不仅密文较短,在传输过程中具有一定优势,而且功能更完善.表2本文方案与现有方案的签密效率比较Duan等人方法[1]Lal等人方法[2]Yu等人方法[3]Sharmila等人方法[4]0Elkamchouchi等人方法[5]2Qin等人方法[6]Zhang等人方法[15]新方案6结束语多接收者签密将公钥加密和签名同时进行,满足了广播服务中保密性以及不可伪造性的需要,以安全且认证的方式对多个授权用户广播消息.本文针对现有多接收者签密方案和匿名签密方案中的解签密者隐私泄露和解密不公平等问题,提出了一个基于身份的多接收者匿名签密方案,新方案满足接收者匿名性以及解密公平性.文章最后给出了随机预言模型下本文方案的IND-sMIBSC-CCA2和EUF-MIBSC-CMA安全性证明,以及性能比较与效率分析.结果表明本方案是一个安全有效的多接收者签密方案,可以用于不安全和开放网络环境中的敏感消息广播.
