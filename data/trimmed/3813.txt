Page1面向不确定感知数据的频繁项查询算法王爽1),2)王国仁2)1)(东北大学软件学院沈阳110819)2)(东北大学信息科学与工程学院沈阳110819)摘要随着计算机网络技术的快速发展,无线传感器网络产生了大量的感知数据流.同时,传感器自身的特点使得感知数据具有不确定的特征,因此需要对传感器网络中不确定感知数据流处理技术进行研究.在传感器网络中,频繁项查询在环境监控和关联规则挖掘等方面具有重要意义.文中首先提出了基本算法,用以连续维护传感器网络中的概率阈值频繁项查询结果.针对基本算法需要维护所有元素的问题,又提出了一种优化算法,算法在两方面进行了优化:(1)设计了一种通过预测元素概率上界的方法进行候选集的构造,仅维护必要信息从而提高查询效率;(2)设计了一种新的cp-list结构,可以压缩不同窗口候选集中的重复元素,降低存储开销.实验结果表明文中提出的算法可以减少连续维护传感器网络中频繁项查询的计算代价和存储空间.关键词无线传感器网络;不确定数据流;频繁项;概率阈值;过滤;物联网1引言随着通信技术、嵌入式计算技术和传感器技术的飞速发展和日益成熟,传感器网络己经成为数据采集与传输的重要手段之一,并且被广泛地应用到国防和国民经济各个领域,典型的应用有地震监测、农业监测、矿井环境监测以及战场态势感知等[1].这些应用通常都产生较大的实时流式感知数据,由于每个传感器节点只有少量的计算资源,难以处理如此巨大的实时数据流,因此在传感器网络中,普遍采用近期(滑动窗口内)数据进行相关信息获取.传感器网络,由于受到硬件设备、传感技术、网络传输延迟、无线传感器网络的通信质量和感知环境等因素的影响,会产生不精确的数据或缺失的数据[2].同时,数据的不确定性在网络通信和网内处理的过程中会得到进一步的传播和放大.因此,如何处理和分析无线传感器网络中的这种数据不确定性是一个非常重要的问题.在传感器网络中,频繁项查询在环境监测、关联规则挖掘等领域有非常重要的应用.例如在温度监测系统中,某温度值频繁出现就会被认为是异常情况从而报警.由于传感器自身的限制,检测的记录是不确定的,每一个监控记录都会附加一概率信息,表示该记录的可信程度.以表1中的R1为例,表示传感器S1在L处监控的温度值为v1,该信息的可信度为0.6.ID位置R1R2R3R4由于传感器网络产生的数据不确定,可能世界模型[3]被广泛地应用于不确定数据的建模.表1有4条传感器记录,共有24=16个可能世界实例,如表2所示.例如,可能世界实例PW1={R1}中,仅R1记录存在,R2,R3,R4均不存在,v1出现1次,v2出现0次,概率为0.6×(1-0.4)×(1-0.8)×(1-0.3)=0.0504.ID可能实例PW0PW1PW2PW3PW4PW5{R2,R3}{v1=1,v2=1}0.0896PW6{R1,R3}{v1=1,v2=1}0.2016PW7{R3,R4}{v1=1,v2=1}0.0576PW8{R1,R2}{v1=2,v2=0}0.0336PW9{R2,R4}{v1=2,v2=0}0.0096PW10{R1,R4}{v1=2,v2=0}0.0216PW11{R1,R2,R3}{v1=2,v2=1}0.1344PW12{R1,R2,R4}{v1=3,v2=0}0.0144PW13{R2,R3,R4}{v1=2,v2=1}0.0384PW14{R1,R3,R4}{v1=2,v2=1}0.0864PW15{R1,R2,R3,R4}{v1=3,v2=1}0.0864尽管在传统的确定数据库领域,频繁项查询得到了深入的研究,但是由于传感器网络产生了大量不确定流式感知数据,现有的算法都不能直接应用到传感器网络中.因此本文提出了一种适用于不确定感知数据的频繁项查询算法,旨在减少每次数据更新的计算代价和存储开销.主要工作包括:(1)提出了一种基本的不确定频繁项查询算法,该算法利用现有计算结果进行增量更新,提高查询效率;(2)提出了一种优化算法,在每个窗口中利用剪枝策略构造候选集合,同时利用提出的cp-list结构压缩不同窗口中的候选元素,减少检测数据的数量,提高查询效率,降低存储开销;(3)通过实验结果证明新算法的有效性和高效性.2相关工作在确定数据中,已有一些基于传感器网络的频繁项查询工作.Considine等人[4]提出了基于树结构的频繁项查询算法,并设计了一种sketch摘要结构,将大值域的数据集映射到小值域的目标数据集中,用目标数据集中的频繁项作为整个数据集的近似解.但是基于树结构的算法在网络数据丢失情况严重时,会带来巨大的传输开销,因此Manjhi等人[5]提出了综合使用树和多路径路由结构的Tributary-Delta算法,并利用抽样方法得到近似查询结果.Ren等人[6]提出了一种分布式查询算法D-FIMA,通过建立聚集树,用有限个计数单元进行协作计数来维护整个数据集中频繁项的方法,得到近似频繁项.Page3但是上述研究工作均基于确定数据流,没有考虑传感器数据的不确定性.近年来开展了不确定频繁项查询方面的工作,研究内容主要分为两类:基于期望的方式[7]和基于概率的方式[8].定义1[7].期望频繁项.对于一组传感器记录R,PW为R所有可能世界实例集合,满足不等式(1)的项v称为期望频繁项.Cv(ω)为项v在w实例空间中出现的次数,p(ω)为w实例空间的概率,esup为阈值.从定义1可以看出,计算期望需要列出所有可能实例(如表2所示),其复杂度为指数级.文献[7]指出期望exp(v)可以采用更简单的线性复杂度方法进行计算,如式(2)所示.虽然使用线性复杂度就可以计算期望值,但是期望并不能真正反映数据本身分布的差异,如表3所示数据库.通过计算,exp(a)=1/2+1/2=1,exp(b)=1.a,b两者期望相同,但是频次分布并不相同.项a频次分布如表4所示,项b频次分布如表5所示.次数012概率1/41/21/4针对上述问题,文献[8]提出了一种更复杂的概定义2[8].概率频繁项.满足不等式(3)的项率频繁项定义.称为概率频繁项.FP(v)=Pr{supv(R)minsup}>minprob(3)其中supv(R)为项v的频次分布,minsup为频次阈值,minprob为概率阈值,FP(v)为项v成为频繁项的概率,如果FP(v)大于minprob,则项v为频繁项.项v在确定数据库中,其出现频次为确定值.但在不确定数据库中,其出现频次为随机变量,用supv(R)表示.表4为项a出现频次的概率分布.由定义2可知,计算频繁概率FP(v)的核心工作是计算频次分布函数supv(R).supv(R)的计算可以采用基于动态规划的方法[8],计算公式如(4)所示.其中i,j=AvAvi,j表示在前i个记录中项v出现j次的概率,pi为Av第i个记录存在的概率.利用Av可以得到整个数据集R上项v的频次分布信息.在文献[8]的基础上,文献[9]提出了一种基于采样的近似聚集查询算法来处理不确定流式数据.除了不确定频繁项查询研究之外,在不确定频繁项集挖掘方面也存在一些研究工作.文献[10-11]分别基于Apriori和FP-Growth算法解决了期望频繁集项挖掘问题,文献[12-13]解决了概率频繁项集挖掘问题,但是上述文献均基于静态数据,没有考虑数据流环境.文献[14-16]解决了不确定数据流中频繁项集挖掘问题,但采用的是更简单的期望频繁项定义.根据上述分析可知,概率频繁项比期望频繁项更能反映频次的分布情况,因此本文采用更复杂的概率频繁项定义,针对传感器网络会产生大量实时数据流的特性,提出了一种精确的概率阈值频繁项查询算法,主要包括使用过滤策略构造候选集,对候选集压缩和候选集更新三方面内容,可以动态地更新结果并过滤掉大量不需要计算的元素.3问题定义由于传感器网络产生无限的数据流,从理论上讲它的数据量也是无限大的,所以,要在所有的数据都采集后再计算传感器网络中的频繁项是不实际的.因此,本文主要考虑最新采集的数据,也即是针对滑动窗口中的数据进行频繁项查询.本文讨论的滑动窗口是基于元组的滑动窗口(tuple-basedslid-ingwindow),但是也可以扩展到基于时间戳的滑动窗口(timestamp-basedslidingwindow).目前许多滑动窗口采用每次仅更新一个元组的方式,但是当数据更新量较大时,此种方式效率不高.因此本文采用批量更新的策略,即每次更新相同数目的记录,这些记录称为基本窗口.本文以基本窗口作为更新处理单位,模型如图1所示.Page4在图1中每个基本窗口包含3个监测记录,每个滑动窗口由3个基本窗口组成.其中DS[i]表示第i个滑动窗口.表6为本文使用符号的相关说明.符号RRivipiminsup支持度阈值minprob概率阈值supv(R)v在R中出现频次的概率分布numv(R)v在R中出现的次数(pi>0)expv(R)v在R中的期望支持度DS[i]B[i+j]第i个滑动窗口中的第j个基本窗口BWLWbWL定义3.不确定感知数据流.传感器网络连续不断地产生感知数据流DS={R1,R2,…,Rn,…},Ri为第i个不确定检测记录,形式为二元组〈vi,pi〉,vi表示检测的记录值,pi为概率.DS[i]窗口的有效记录为{Ri,Ri+1,…,Ri+WL-1}.流频繁项.定义4.(minsup,minprob)不确定感知数据Pr{supv(DS[i])minsup}>minprob(5)在当前窗口DS[i]中满足公式(5)的项v即为(minsup,minprob)不确定感知数据流频繁项.4基于流的概率阈值频繁项查询算法随着时间的变化,新数据不断地被传感设备采集,它们会进入到滑动窗口中,而一些旧数据将过期,不再参与频繁项运算,此时的查询结果将发生变化.求解新频繁项的最简单办法就是采用静态频繁项查询算法[8]重新计算,这样当进行连续查询时,上面的过程将重复地执行.显然,这样的策略是不可取的.因为在连续时刻的窗口之间有相当大的一部分数据是相同的,所以两个时刻的查询结果之间也会有很多数据是相同的,有效地利用现有结果进行增量更新从而避免重复计算是提高算法性能的关键问题之一.4.1增量查询算法由于本文以基本窗口作为更新处理单位,因此在计算频次分布函数时,也以基本窗口为单位进行计算.基于该思想,本节提出了一种增量的概率阈值频繁项查询算法bs-UFI,可以避免重复计算.对每个基本窗口计算其频次分布supv(B[i+j]),进行频繁项查询时,需要将当前滑动窗口中所有基本窗口的计算结果进行合并,计算总的频次分布supv(DS[i]),然后计算频繁概率FP(v),计算总的频次分布函数如式(6)所示.可以采用快速傅里叶变换的方法计算式(6),时间复杂度为O(Wbmlogm),m为基本窗口中项v出现的次数.当前窗口DS[i]数据过期时,无法在现有的supv(DS[i])计算结果上进行增量更新,必须重新计算.为了避免重新计算,每到达一个基本窗口,只计算并保存该基本窗口的频次分布supv(B[i+j]).仅当窗口滑动时,才使用式(6)合并Wb个频次分布函数.尽管在当前窗口中需要保存Wb个基本窗口的频次分布,但是其存储代价与保存总的频次分布函数相同,并未增加额外的存储空间,并且可以将计算的复杂度提升至与初始化阶段相同,均为O(Wbmlogm),具体算法如算法1所示.算法1.bs-UFI.输入:DS;minsup;minprob;BWL;Wb输出:Result1.Result=NULL;2.FOR每个新到达的基本窗口B[i+j]3.FORv∈B[i+j]4.计算supv(B[i+j])(j=0…Wb-1);5.//滑动窗口6.FOR每个项v7.计算supv(DS[i]),FP(v);8.IF(FP(v)>minprob)9.将〈v,FP(v)〉加入Result集合中;10.//数据过期处理11.FOR过期基本窗口中的每个项v12.删除supv(B[i+0]);13.//数据插入处理14.FOR新基本窗口的每个项v15.计算supv(B[new]).Page5对于每个到达的基本窗口,计算该窗口中所有项的频次分布(1~4行).当窗口滑动,合并所有基本窗口的频次分布函数,依据当前窗口的频次分布,计算概率频繁项并输出结果(5~9行).数据过期仅将当前窗口中最老基本窗口的频次分布删除即可(10~12行).插入数据时,计算新基本窗口的频次分布函数(13~15行).4.2基于压缩候选集的增量查询算法与静态数据不同,传感器产生的数据是不断更新的.当前的非频繁项随着滑动窗口的前移可能会变为频繁项,为了避免重复计算,在基本算法中保留了所有项的信息,显然这种方法会保留大量低频度的项从而浪费了大量的存储空间.针对该问题,本节对基本算法进行改进,提出了一种优化的查询算法,仅维护一些重要的项信息即候选集.在候选集中大量的元素被剪枝,因此大幅度地降低了存储耗费.算法共包括3部分内容:(1)候选集构造;(2)候选集压缩;(3)候选集更新.4.2.1候选集构造滑动窗口之间数据重复,在处理当前窗口时,可以预知哪些数据会参与到未来的滑动窗口中.如图1所示,当窗口滑动,B[1]窗口元素过期,现有DS[1]的结果不能直接用于计算新的DS[2]窗口结果,但是当计算DS[1]结果时,可以预知当前窗口中的部分数据会参与到未来的滑动窗口中,例如B[2],B[3]可以参与到DS[2]窗口中,而B[3]可以参与到DS[3]窗口中.基于不同窗口间的这部分重复数据可以对未来窗口中的查询结果进行预测,得到的预测结果称为pUFI(DS[i]).定义5.pUFI(DS[i]).DS[i]窗口的预测候选集.预测候选集(pUFI(DS[i]))构造的基本思想是在传感器节点设置一个过滤器,提前判断出那些不属于最终结果的项,并将它们过滤掉,仅维护必要的候选项集合.由分析可知,频次分布函数supv(R)满足泊松二项分布的定义,而泊松二项分布可以用更简单的泊松分布P(λ)近似替代,近似的频繁概率可以使用式(7)计算,其中Fp表示泊松分布的累积分布函数.FPv(DS[i])≈1-Fp(minsup-1,expv(DS[i]))从式(7)可以看出在泊松分布中,仅利用期望就可以得到近似概率值.由第2节可知,计算基本窗口的期望仅需要O(m)的时间复杂度,而计算频繁概率需要O(m2)的时间复杂度.因此利用期望剪枝掉部分项,避免进行复杂的概率计算会极大地提高查询效率.由pUFI(DS[i])的定义可知,对未来窗口候选集的构造依据的是当前窗口中与未来窗口中的重复数据,这部分仅仅是未来窗口的部分数据,因此无法计算未来窗口中项的精确期望值,但可以估算其上界.由于传感器产生的数据是随机的,没有任何分布信息,因此只能采用最简单的方法进行预测,即假设后续数据全部与v取值相同.利用该方法可以推测项v在未来DS[i]窗口的期望上界,如式(8)所示,其中j表示未来窗口DS[i]与当前窗口重复的基本窗口的个数.up_expv(DS[i])=BWL(Wb-j)+∑j由泊松分布性质可知式(8)随期望单调递增.因此可以通过项v的期望上界利用式(7)计算近似频繁概率的上界.由文献[13]可知使用泊松分布计算的近似概率与精确概率之间的误差为δ=min((expv(DS[i]))-1,1)∑DS[i]繁项的概率上界如式(9)所示.up_FPv(DS[i])=1-F(up_expj(v))+δ(9)若概率上界up_FPj(v)<minprob,则项v可以过滤掉.在图2中分别列出了图1所示3个窗口的候选集.假设DS[1]根据基本窗口B[1],B[2]和B[3]当中的数据按照上述剪枝策略得到候选元素2,3,则pUFI(DS[1])={2,3}.DS[2]根据基本窗口B[2]和B[3]当中的数据得到候选元素1,2,3,pUFI(DS[2])={1,2,3}.DS[3]根据基本窗口B[3]当中的数据得到候选元素1,2,3,4,pUFI(DS[3])={1,2,3,4}.根据剪枝规则,随着数据的不断到达,可以逐步精化元素的期望值,从而求得更精确的频繁概率上界,过滤掉更多的元素,而不用采用基于动态规划的方法进行概率计算,降低了算法的开销.实验结果表明,随着数据的到达,该方法可以过滤掉大量的Page6元素.由于不同窗口候选集独立,窗口滑动时可以容易地对候选集进行维护.首先,基于当前窗口的候选集,通过基本算法得到概率频繁项.当数据过期时,如图3所示,将最老窗口中的候选集删除.当有新数据插入时,分别更新每个窗口中的候选集,对DS[2],DS[3]窗口中的候选集进行更新,并对最新到达的窗口构建新的候选集DS[4].4.2.2候选集压缩从上述分析可以看出,对每个窗口独立维护候选集,可以很容易地得到查询结果,但是不同窗口的候选集存在大量的重复元素,如图2所示,项{1,2,3}同时出现在窗口DS[2],DS[3]中,如果将不同窗口中的相同数据压缩,只保留一个备份,会减少存储空间.因此,本文设计了一种带窗口标记的保存候选集元素的数据结构cp-list,如图4所示.如图4所示,将图2中不同窗口中的重复元素压缩,并且增加窗口标识,用来标注该元素隶属于哪个窗口.元素的排列顺序按照起始窗口的标识从小到大排列,具有相同起始窗口标识的元素按照期望上界(up_expv(DS[i]))的值从大到小排列.虽然通过使用窗口标记的方法可以减少存储空间,但是该方法需要保留所有窗口标记,算法需要对每个候选集中的项维护Wb个窗口标记,当Wb值较大时,维护窗口标记的代价也是不可忽视的.通过分析不同窗口中的预测候选集,发现了定理1.定理1.v∈pUFI(DS[i])∧v∈pUFI(DS[j]),则对于l∈[i,j],v∈pUFI(DS[l]),其中i<j,j=i+1,…,i+Wb-1.证明.v是DS[i]的候选元素,说明up_FPv(DS[i])>minprob,计算概率上界up_FPv(DS[i])采用的期望值为up_expv(DS[i]).因为i<j,即假设在未来窗口DS[l]中,项v全部出现且概率为1,所以up_expv(DS[i])up_expv(DS[l]).因为概率随期望单调递增,up_FPv(DS[i])up_FPv(DS[l]),所以up_FPv(DS[l])>minprob,v∈pUFI(DS[l]).如果项v是DS[i]窗口的候选元素,且v是DS[j]窗口的候选元素,则v一定是所有DS[i]和DS[j]之间所有连续窗口中的候选元素.因此仅记录起始窗口标记(Wstart)和其结束窗口标记(Wend)即可,如图5所示.通过使用压缩的cp-list存储结构,且仅记录起始和结束窗口标记,可以极大地减少存储空间,这对于数据流处理是非常重要的.4.2.3候选集更新采用压缩的cp-list存储结构可以减少存储空间,但是当窗口更新时,由于不同窗口的候选集都存放在同一个候选集列表中,则候选集的更新比独立存放的方法要复杂.下面从删除过期数据和插入新数据两方面描述候选集列表的维护算法.(1)删除过期数据.在没有使用压缩方法的算法中,元素过期仅删除当前最老窗口中的候选集即可.而采用压缩的cp-list结构,所有窗口的候选集压缩存放在一起,不能简单地删除.具体方法为先查询起始窗口标记,找到最老窗口中的候选元素,并将起始窗口标记加1.如果起始窗口标记大于结束窗口标记,则真正删除该元素.由于不同窗口中的候选元素都保存在如图5所示的cp-list中,因此如何快速的找到最老窗口的候选元素也是关键问题之一.本算法在构造cp-list时,按照起始窗口标记从小到大对元素进行排列,因此在查询时,仅需将cp-list中最前面的元素“删除”即可,直到遇到第一个次老窗口中的元素为止.如图5所示,从头开始对cp-list中的元素进行处理,首先处理元素2,得到起始窗口标记DS[1],因为DS[1]Page7是当前最老的窗口,将其起始标记加1,变为DS[2],继续处理下一个元素,当处理到元素1的时候,发现起始窗口为DS[2],则不需继续处理,因为已经将所有DS[1]窗口中的候选元素处理完毕.以图1所示滑动窗口为例,当B[1]基本窗口数据过期后,图5更新后的处理结果如图6所示.(2)插入新数据.首先对不同窗口中的候选集进行更新.随着新基本数据的到达,可以进一步精化每个未来窗口中元素的期望值,从而得到更准确的概率上界,进而得到更准确的候选集.因为元素按起始窗口标记从小到大排列,因此从头对元素依次处理,即可以更新每个窗口的候选集.对于新基本窗口的数据,同样按照4.2.1节的方法构造候选集,若新窗口的候选元素已经在cp-list中存在,则将该元素结束窗口标记加1;否则在cp-list末尾插入该元素,起始标记和结束标记均为该窗口的标号.以图1滑动窗口为例,当B[4]基本窗口到达时,DS[2]成为当前窗口,包括B[2],B[3]和B[4]基本窗口中的数据,可以进一步缩小候选元素的范围,假设更新后的候选集为{2,3},按照同样方法更新DS[3]候选集,假设结果为{2,3,4},利用B[4]当中的数据对DS[4]窗口进行预测,假设结果为{2,3,4,5},更新后的cp-list结构如图7所示.4.2.4优化算法(is-UFI)由于基本算法存在查询效率不高的问题,因此本节在基本算法bs-UFI的基础上提出了一种优化算法is-UFI,如算法2所示.该算法使用泊松分布过滤策略构造候选集,并使用cp-list压缩结构动态地维护候选集合.算法2.输入:DS;minsup;minprob;BWL;Wb输出:概率频繁项集合Result1.Result=NULL;2.FOR每个新到达的基本窗口B[i+j]3.FORv∈B[i+j]4.计算expv(j),up_expv(j),up_FPv(j);5.IFup_FPv(j)<minprob6.过滤掉项v;7.ELSE8.IFvcp-list9./按照v.start窗口标记升序排列,具有相10.将v加入cp-list;v.start=i+j;v.end=i+j;11.ELSE12.v.end=i+j;13.计算supv[j];14.//窗口滑动15.FOR每个没有被过滤掉的项v16.根据supv(DS[i])计算频繁概率FP(v);17.IFFP(v)>minprob18.将项v以〈v,FP(v)〉形式加入Result集合中;19.//数据过期处理20.FOR过期基本窗口的每个项v21.删除supv(B[i+0]);22.v.start++;23.IFv.start>v.end24.将项v从cp-list中删除;25.//数据插入处理26.创建新的预测候选集pUFI(B[new]);27.将pUFI(B[new])加入cp-list;28.按照式(4)计算supt(B[new]).对于每一个新到达的基本窗口B[i+j],计算该基本窗口中所有项的期望,并将该期望值与前面基本窗口的期望进行累加,得到真实的expv[j],期望上界up_expv(j)和概率上界up_FPv(j)(1~4行),若up_FPv(j)小于阈值,该项被过滤掉(5~6行).对于没有过滤掉的项v,如果该项不在cp-list中,按照起始窗口标记升序排列的方式将其加入到cp-list中,标记起始窗口和结束窗口(8~10行).如果该项在cp-list中,将项v结束窗口标记改为当前窗口标记值(11~12行).计算每个基本窗口的频次分布(13行).当窗口滑动时,根据supv(DS[i]),计算当前滑动窗口的频繁项(14~18行).数据过期Page8时,将起始窗口标记增1,如果起始窗口标记小于结束窗口标记,则删除该项(19~24行).当新数据到达,计算新的基本窗口的候选元素,并将该候选集加入cp-list中(25~27行),最后计算新基本窗口的频次分布函数(28行).时间复杂度.对于每一个候选元素需要计算期望及出现次数进行过滤条件的判断,因此需要扫描滑动窗口中的数据,时间复杂度为O(WL),对于没有过滤掉的元素,需要利用动态规划的方法计算概率,每一个基本窗口中计算概率的时间复杂度为O(m2)(m为项v在基本窗口中出现的次数).在整个滑动窗口计算概率的时间复杂度为O(Wbmlogm+Wbm2).因此,对于单个候选元素,总的时间复杂度为O(WL)+O(Wbmlogm+Wbm2).空间复杂度.对于每一个候选元素,需计算期望,空间复杂度为O(1).另外,记录supv(DS[i])的空间复杂度为O(numv(DS[i])),所以,对于单个元素总的空间复杂度为O(numv(DS[i])).5实验由于目前尚没有采用滑动窗口模型的概率频繁项查询算法,本文将单窗口下的UFI算法[8](PHH)应用到滑动窗口下,作为与本文提出的两个算法的比较基准.因此本文共对3个算法进行评测:单窗口频繁项查询算法(PHH)、滑动窗口频繁项查询基本算法(bs-UFI)和滑动窗口频繁项查询优化算法(is-UFI).实验环境.实验的硬件环境为Pentium3.0GHzCPU,4GB内存,操作系统为WindowsXP,并采用MicrosoftVC++6.0编程环境开发了模拟测试程序.数据集.实验采用两组数据集,一组是真实数据集accidents,来自FrequentItemsetMining(FIMI),另一组数据使用IBMDataGenerator发生器,分别生成10万个元组.由于这两个数据产生的都是频繁项集,本文对其简单修改,只保留其中一组属性的值,构造频繁项.对于第1组真实数据集,通过分析数据取值的分布情况,按照相应的分布为每个元组分配概率值.第2组数据采用平均分布.其它参数的缺省值是minsup为100,minprob为0.3,基本窗口的元组数为1000,滑动窗口的元组数为10000.剪枝能力分析.剪枝能力考查了优化算法is-UFI过滤元组的能力.因为在bs-UFI算法中,没有使用过滤策略,因此剪枝掉的元素数目为0,故没在图中对该算法进行表示.图8、图9表示了剪枝能力随minsup,minprob变化的情况.从图8、图9可以看出,随着minsup,minprob的逐渐增加,剪枝能力不断地增强,由于IBM数据相对稀疏,因此剪枝掉的元组数目较多.运行时间分析.图10显示参数W对时间的影响.W表示滑动窗口中元组的总个数,取值范围为5000~10000.(a)是真实数据集的结果,(b)是IBM数据的结果.如图10所示,随着数据量增加,算法运行时间也会增加.但是,静态的频繁项查询算法(PHH)时间增加明显,因为需要重复计算.而我们提出的算法bs-UFI与is-UFI增加相对平缓.is-UFI的算法性能要优于bs-UFI,因为is-UFI算法中仅使用期望就可以过滤掉部分元素,不需要再使用动态规划方法进行概率计算,因此节省了大量的时间.Page9图11显示参数minsup对时间的影响.参数minsup为频次阈值,取值范围为100~1000.如图11所示,is-UFI算法总是优于bs-UFI.因为,在窗口更新的过程中,会剪枝掉一些元组,且计算概率可以利用之前的结果,所以节省了时间.另外,随着minsup的增加,剪枝元组数目增多,时间递减,而没有使用剪枝策略的算法对所有的元素都要计算概率,因此时间不变.图12显示参数minprob对时间的影响.参数minprob为概率阈值,取值范围为0.1~0.8.如图12所示,我们的算法总是优于基本算法.原因与minsup相同.但是与minsup相比,随着minprob的增加算法时间下降平缓,说明minprob的过滤能力比minsup弱.图13显示基本窗口BWL对时间的影响.参数L为基本窗口的尺寸.L的取值从100~1000.如图13所示,随着L的增加,基本窗口的元组数目增加,因此计算基本窗口频次分布函数的代价增大.采用快速傅里叶算法计算总的分布函数时,需要合并的基本窗口数目减少,但是由于每个基本窗口的项数目增加,所以在合并时计算代价仍然增加.对于PHH算法,每次窗口滑动,都需要重新处理,所以时间代价不变.内存使用.图14~图16分析了不同参数对bs-UFI和is-UFI算法内存使用的影响.这里只采用了真实数据集进行测试.图14测试了滑动窗口尺寸对内存的影响.由于bs-UFI没有使用剪枝,需要对所有数据都进行概率计算,其空间与元素数目成线性增加.而使用了剪枝的is-UFI算法,有大量元素被剪枝,因此空间增加相对平缓.图15、图16测试了参数minsup,minprob对内存的影响.没有使用剪枝的算法每次处理元素数目不变,因此内存消耗不变.而使用剪枝的算法随minsup,minprob的增加,剪枝数目增多,内存消耗逐渐递减.Page10扩展性.最后测试了bs-UFI和is-UFI算法改变数据库尺寸对时间和空间性能的影响.这里只采用IBM数据集进行测试.图17表明随着数据数目的增加,两个算法的运行时间均呈现线性增加的趋势.但是,使用了剪枝的is-UFI算法较bs-UFI增加相对平缓.因为is-UFI算法使用了剪枝策略,有大量元素被剪枝,因此处理时间较少.相似地,从图18可以看出算法的空间性能随元组数目的增加同样呈现线性增加的趋势.6结论传感器网络产生大量的感知数据流,由于自身特性,使得数据带有不确定性.本文针对这种不确定数据流,提出了基于滑动窗口的概率阈值频繁项查询算法,为此,首先提出了增量查询算法bs-UFI,以避免重复计算,进而提出了基于泊松分布的剪枝策略,以有效地过滤掉大量不必计算的项,最后提出了cp-list数据结构,以压缩不同窗口之间的候选集,减小存储空间.实验证明算法在时间和空间均具有高效性.由于引入了不确定性,使得频繁项查询问题变得非常复杂,因此本文仅考虑了集中式的算法.但传感器网络实际是一个分布式的数据流系统,对于分布式情况下设计一种旨在减少网络通信量的不确定流频繁项查询算法还有待于进一步研究.另外,有些应用只需要查询近似频繁项,并不需要精确结果,因此如何在精度和查询代价之间进行折中,使之既能满足用户需求,又能提高查询效率,也是下一步工作的重点.
