Page1面向ASCRA的循环流水启动间距自动分析及优化郭振华吴艳霞张国印戴葵(哈尔滨工程大学计算机科学与技术学院哈尔滨150001)摘要在实现循环到流水硬件结构自动映射过程中,迭代间启动间距的自动分析技术是可重构编译器研究的难点.在现有细粒度可重构编译器中,主要采用人工输入制导语句的方法来控制循环并行流水硬件结构自动映射所需启动间距信息的生成,该方法只能采用固定启动间距方式对流水硬件结构进行控制,不能充分发挥并行流水硬件结构的性能,同时人工确定启动间距的方法降低了可重构计算应用的部署效率.针对细粒度可重构编译器的现状,文中提出了一种面向ASCRA的循环流水启动间距自动分析及优化方法.在细粒度可重构编译器中,建立多层循环流水迭代间启动间距分析模型,提出非固定启动间距控制策略,采用自动生成算法得到迭代间启动间距向量信息,并采用流水线调度技术对迭代间启动间距进行优化.实验结果表明,与现有HLS工具相比,文中方法不仅能够提高可重构计算应用在异构加速平台上的部署效率,同时能够有效改善循环应用在FPGA协处理器中流水执行时的性能,具有一定的可行性.关键词可重构编译;循环流水;自动映射;启动间距;异构加速1引言面向CPU-FPGA异构加速平台的可重构自动化编译工具已经成为了可重构计算领域研究的热点.相对于多核处理器的高功耗及并行度过低、ASIC芯片成本过于昂贵等缺点,基于片内CPU-FPGA架构的异构加速平台更加适应嵌入式系统中对性能、功耗、成本均比较苛刻的计算密集型应用,例如图像压缩、模式识别、数字信号处理等应用,兼顾了通用处理器的灵活性和专用芯片的高效性.计算密集型应用中85%左右的程序执行时间都集中在其中的循环部分[1],如何实现循环到高效并行流水硬件结构的自动映射是可重构编译器研究的难点.目前,在研究多层循环到并行流水硬件结构自动映射时,主要分为两个方向:(1)以CGRA[2]为代表的面向粗粒度可重构硬件平台的循环流水硬件结构映射,通过函数级程序特征分析,实现循环到固定流水硬件模板结构的映射,可以简化循环映射的复杂度,但是限制了循环程序对可重构平台的通用性;(2)以Xilinx提出的VivadoHLS(HighLevelSynthesis)[3]高层次综合工具为代表的细粒度可重构编译工具,通过循环程序特征分析,完成循环程序到异构加速平台的指令级映射,与粗粒度可重构编译器相比,指令级硬件映射具备更广泛的通用性和推广意义.本文主要致力于研究细粒度可重构编译器在实现多层循环到并行流水执行硬件结构自动映射时迭代间启动间距II(InitiationInterval)的自动分析及优化方法.目前,VivadoHLS[3]、ROCCC[4]、ImpulseC[5]等细粒度可重构编译器在实现多层循环到并行流水FPGA硬件结构的映射时均采用制导语句方式进行迭代间流水启动间距控制,即在计算密集型应用程序循环代码中人工插入类似#pragmaII=xx的制导语句指令方式,实现循环映射成为并行流水硬件结构时迭代间启动间距的生成控制.该方式只能针对循环中的每一维迭代空间生成固定值的迭代间启动间距,同时在使用可重构编译器进行可重构计算应用部署时,需要反复迭代综合仿真过程才能最终确定合适的迭代间流水启动间距值,极大地制约了可重构计算应用的部署效率,同时会影响细粒度可重构编译器在工业界的推广.为了解决以上问题,本文通过挖掘利用启动间距提升流水并行硬件结构性能的潜力,建立多层循环迭代间启动间距的分析模型,提出一种面向细粒度可重构编译器的循环流水迭代间启动间距自动分析及优化方法,并在基于LLVM开源编译框架下开发的细粒度可重构编译器ASCRA(Application-SpecificCompilerforReconfigurableArchitecture)[6]中进行了该方法的实现和验证,证明本文方法的有效性.本文贡献主要有以下3点:(1)建立循环流水迭代间启动间距自动分析模型,并设计实现了自动分析算法,减少细粒度可重构编译器实现循环流水映射时调试启动间距值的综合仿真迭代次数,可有效提高可重构编译器的自动化水平及可重构计算应用的部署效率.(2)提出循环流水执行时迭代间非固定启动间距NF_II(Non-FixedInitiationInterval)控制策略.与现有制导语句控制固定启动间距方式相比,能够有效减少流水冒泡延迟,提高硬件流水执行数据吞吐率.(3)基于指令调度优化技术提出了循环流水迭代间启动间距优化算法,能够降低循环迭代间启动间距值,进一步提高循环流水执行时的性能.本文第2节介绍相关研究工作;第3节介绍循环流水迭代间启动间距自动分析方法;第4节介绍循环流水迭代间启动间距优化算法;第5节给出实验结果和分析;第6节给出本文的结论.2相关工作目前,国内外已有多个可重构编译器课题组致力于研究在可重构平台中实现多层循环程序到流水并行硬件结构的自动映射,采用流水线技术提高循环程序硬件的性能.其中,GarpCC编译器[7]中采用RIMS(RausIterativeModuloScheduling)调度算法实现循环流水的控制映射,但是只对最内层循环进行流水控制;XPP[8]中采用流水向量化方法,但是不能处理循环体间RAW数据依赖关系引起的非最内层循环迭代间流水启动间距问题;VivadoHLS[3]、ROCCC[4]、ImpulseC[5]等细粒度可重构编译器均采用制导语句方式实现循环流水硬件自动化映射时的流水启动间距控制,仅能实现迭代间固定启动间距控制方式,并且没有实现自动分析方法和相关优化方法.为了提高细粒度可重构编译器实现多层循环流水映射的效率和性能,本文基于细粒度可重构编译器ASCRA对循环流水迭代间启动间距自动分析和Page3优化方法展开了一定的研究.多层循环在流水执行时,迭代间的启动间距由数据依赖关系决定,因此,完成启动间距信息的自动化分析需要精确数据依赖关系分析算法支持,本文在改进ISL数据流分析方法[9]得到的数据依赖关系结果的基础上设计出多层循环流水启动间距自动分析方法.本文提出了循环流水启动间距自动分析及优化方法,并在基于ARM-FPGA异构加速平台面向应用领域的细粒度可重构编译器ASCRA[6]上进行理论实现与验证.ASCRA基于开源编译框架LLVM[10]进行设计与实现,可以完成C-to-VHDL的自动映射,ASCRA系统架构图如图1所示.首先,将计算密集型应用程序编译成LLVM中间代码(Intermediate图1ASCRA架构图在细粒度可重构编译器中,通过循环流水启动间距自动分析及优化方法不仅可以得到更精准的循环性能评估结果,实现更高效的软硬件自动划分方法;同时在硬件代码自动映射过程中,能够提高可重构计算应用到可重构计算平台的部署效率,提高细粒度可重构编译器的效率和推广.3循环流水迭代间启动间距自动分析3.1问题提出在可重构混合计算系统中,由于FPGA的可定制性及硬件结构不确定性,导致无法直接利用通用计算机系统结构中所设计的软件流水技术实现多层循环迭代间变启动间距控制.现有细粒度可重构编译器在实现多层循环流水并行硬件结构映射时,主要采用制导语句的方法实现迭代间流水启动间距的生成,为了体现本文工作与现有可重构编译器对多层循环流水执行时关于启动间距映射方式的改进之处,本小节采用一个多层嵌套循环的实例描述问题所在.如图2(a)所示,显示了一个典型外层循环迭代Representation,IR)表示,采用一些前端优化技术进行IR优化;其次,对循环程序进行数据依赖关系分析、流水线划分、迭代间启动间距分析和优化,基于流水线划分结果和启动间距分析结果进行循环程序代价评估,评估将该循环程序映射到FPGA上执行时消耗的代价和获得的应用加速比;然后,基于循环程序代价评估结果进行软硬件划分,判断是否将其划分到协处理器FPGA硬件加速单元上执行;最后进行代码生成,结合并行编译优化技术和并行存储模型完成FPGA并行流水硬件加速单元VHDL代码的生成,同时生成软硬件接口驱动程序和将该循环程序封装成接口调用的C源程序,完成计算密集型应用程序在异构加速平台上的自动部署.间数据相关的嵌套循环,当N=5时循环体的迭代域及迭代空间中RAW数据依赖关系如图2(b)所示.细粒度可重构编译器在实现该嵌套循环到可重构混合计算平台流水并行硬件结构自动映射时,将最内层循环体映射成为一个处理单元(ProcessElement,PE),循环控制语句映射成为一个控制单元(ControlUnit,CU),实现对每次迭代启动和结束时间的控制,循环流水控制单元的自动映射需要可重构编译器能够采用自动分析算法获得每次迭代之间的启动间距信息.现有细粒度可重构编译器皆采用制导语句方式人工指定迭代间启动间距约束条件,例如,Xilinx提供的VivadoHLS在实现图2(a)图2嵌套循环及N=5时带依赖关系的迭代域Page4嵌套循环的流水并行硬件结构映射时,通过数次综合和仿真迭代,根据图2(b)迭代域中迭代体间RAW数据依赖关系可以得到如图3所示的循环运行时空图,由迭代点(3,0)与迭代点(4,0)之间的图3N=5,II=3时循环流水运行时空图通过分析图3所示时空图,可以发现图中虚线箭头所代表的RAW数据依赖关系所引起的迭代间启动间距可以进行优化,通过对其启动间距进行手动优化后可以得到如图4所示的循环流水运行时空图,外层循环迭代间启动间距由固定的II=3变成图4N=5时变启动间距循环流水运行时空图通过分析细粒度可重构编译器中采用制导语句生成固定启动间距和非固定启动间距两种循环迭代间流水控制策略,可以发现非固定启动间距控制策略能够更好地提高循环流水的性能.但是,按照制导语句方式在细粒度可重构编译器中实现非固定启动间距控制对于用户来说是非常困难的,针对每个多层循环应用程序都需要根据迭代间依赖关系手动分析得到非固定值的启动间距向量,这种工作量对于用户来说是不可接受的.另外,在细粒度可重构编译器中采用制导语句方式即手动分析出迭代间最佳启动间距的方法,会在很大程度上由于用户没有得到最佳的启动间距而无法提高循环程序映射生成更优的硬件结构,从而无法得到良好的加速效果.这就迫切需要在细粒度可重构编译器中设计并实现一种能够自动得到迭代间启动间距的方法.针对这一现状,本文首先建立循环流水启动间距分析模型,并设计实现了自动分析算法;其次,在细粒度可重构编译器中提出了针对循环流水硬件结构的迭代间非固定启动间距控制策略;最后,基于指令调度技术设计并实现了循环流水启动间距自动优化算法.上述工作不仅可以有效改善可重构编译器对可重构计算应用的部署效率,还能有效提高循环RAW依赖关系约束条件(如图3中实线箭头所示)选择索引变量i确定的循环体迭代间最佳启动间距#pragmaII=3,但是,通过这种制导语句的方式只能确定固定的启动间距大小.非固定的启动间距向量犐犐=(1,1,2,3).对多层循环外层循环迭代间采用非固定启动间距方式执行过程进行分析,可以得出,采用非固定启动间距策略能够提高循环程序硬件使用率13.7%,减少循环执行时钟周期19%.流水硬件结构的性能.3.2循环流水启动间距分析模型现有可重构编译器在进行多层循环流水硬件结构映射时,将循环体映射成为一个独立的硬件加速单元,通过重叠PE单元的执行来实现流水并行,两次相邻循环体执行之间的时间差称为启动间距,可重构编译器将启动间距信息映射成为循环调度控制单元.由于细粒度可重构编译器对于多层循环的形式具有一定的限制,因此本文只针对定义1中描述的计数类多层循环程序进行启动间距分析.定义1.计数类多层循环.索引变量向量犐=(I1,I2,I3,…,Im),其中m为多层循环的最大深度;Loop(r)表示索引变量为Ir的循环,其中1rm,循环体用stmt(犐r)表示,犐r=(I1,I2,I3,…,Ir),表示循环体由索引向量犐r控制,索引变量Ir=(pr,qr,θr),其中,pr和qr分别表示索引变量Ir的初值和终值,且是(I1,I2,…,Ir-1)的整值函数,θr表示循环变量Ir的增量且θr为常数.为了建立循环流水启动间距信息模型,需要将图5所描述的多层循环Loop抽象成如图6所示多个单层循环递归表示的形式.其中Loop(m)表示最内层循环.Page5在细粒度可重构编译器ASCRA中是对中间代码IR进行数据依赖关系分析,将图5所示的高级语言描述形式转换成LLVM能够进行分析的数据结构,通过LLVMPASS将多层循环描述成一种抽象语法树(AbstractSyntaxTree,AST),筛选符合定义1中所描述的限制条件的计数类多层循环,实现图5到图6循环表示形式的抽象表示.本文定义的AST数据结构采用定义2中描述的SCoPs(StaticControlParts)描述.定义2.SCoPs.SCoPs由context和一系列声明statement构成一个二元组〈Context,[Statement]〉.其中context是SCoP约束参数的集合;每个声明statement都是一个四元组〈Name,Domain,Schedule,[Access]〉,Statement的单位是多层循环Loop中循环体stmt(犐r),其中1rm,其中Name表示声明statement的名称,是声明的唯一标识符;Domain是声明的迭代域,表示一个statement在多层循环中的多维迭代空间域,限制了statement的迭代范围;Schedule是多维空间中迭代向量的整型映射,表示迭代空间中statement的迭代向量;[Access]是声明中对数组元素的访存操作集合,主要包括读、写、读写3种.本文提出的SCoPs数据结构基于LLVM开发的多面体模型分析程序开源软件Polly计,由于其能够准确地对不同深度循环体中数组元素访存操作进行描述,有利于对计数类多层循环迭代间的数据依赖关系进行精确分析.例如,图7中所示的多层循环可以用图8所示SCoPs表示,其中,循环Loop(i)中的循环体stmt(i)=Loop(j),所以Statement只描述了stmt(犐j)的声明,犐j=(i,j).Context={[N]};Statement={Name=stmt[i,j]:}利用得到的SCoPs数据结构可以进行循环体迭代间数据依赖关系分析,本文基于改进后的ISL数据流分析方法[9],可以得到写后读(ReadAfterWrite,RAW)、写后写(WriteAfterWrite,WAW)、读后写(WriteAfterRead,WAR)3种数据依赖关系.在可重构编译器中实现循环程序到并行流水硬件结构的自动映射时,WAW数据依赖关系表示对存储结构中的数组元素进行数据覆盖,后一次迭代执行时计算出来的结果是正确的数据,而循环程序流水执行时,循环体每一次迭代运行的时钟周期数是相同的,由于迭代间启动间距至少是一个时钟周期,所以对于存储结构中最终的写操作,都是后面所执行的迭代运算的结果,因此WAW数据依赖关系不影响程序流水执行时的最终计算结果.WAR数据依赖关系表示在程序执行时,对于存储单元中的数据先执行读操作,然后才能进行对应存储位置的写操作,为了避免下一次迭代执行时写操作比上一次迭代执行时的读操作提前,从而导致上一次迭代执行时读取错误的数据,在可重构编译器进行循环流水硬件结构的映射时,可以设计数据缓存结构,采用在每一次迭代运行之前将所有的数据元素提前预取的方法,来避免WAR对上一次迭代运算所需要的数据产生影响,不影响循环程序流水执行时迭代间启动间距的运算.而RAW操作表示循环程序执行时,下一次迭代所用到的数据必须是上一次迭代计算得到的结果数据,为了保证程序运行的正确性,除了采用相关的编译优化技术进行RAW数据依赖关系消除之外,在循环程序进行流水执行时,下一次Page6迭代进行只能等待上一次的迭代运算完成.因此RAW数据依赖关系是影响循环程序流水执行时迭代间启动间距的关键因素.因此本文只考虑RAW数据依赖关系的分析结果.在实现多层循环迭代间启动间距自动分析的基础上,本文充分利用带有流水线延迟信息的RAW数据依赖分析模型(DataDependenceAnalysisofRAW,RAW_DDA),如定义3所示,并结合流水线调度技术对迭代间启动间距进行优化.定义3.RAW_DDA模型.RAW_DDA=(statement,I,[Array],[NEXT]).其中statement表示多层循环程序中的一个循环体stmt(犐r)的声明;I表示循环体stmt(犐r)索引变量Ir,1rm;[Array]是与索引变量Ir相关的RAW数据依赖关系涉及到的数组集合,用Array(Ir)表示;[NEXT]表示statement声明中所有迭代间RAW数据依赖关系集合,用NEXT(Array(Ir))表示Array(Ir)中单个数组所引起的RAW数据依赖关系集合,其中NEXT是一个三元组(next,δ,Δ),其中δ表示迭代间RAW数据依赖关系的依赖距离,Δ表示依赖关系next在循环体stmt(犐r)中跨过的流水段延时.为了更好地理解定义3所示的RAW_DDA模型,下面通过一个循环程序例子进行详细阐述.如图9所示,表示包含数组元素A[i]和B[i]的循环体程序经过流水线划分后的数据流图结果,其中包含3个RAW数据依赖关系.在RAW_DDA模型中,statement表示该循环程序循环体的声明,I表示循环体索引变量i,[Array]是与索引变量i相关的RAW数据依赖关系涉及到的数组集合,则[Array]={A[i],B[i]}.关于数组A[i]包括2个RAW数据依赖关系next_A_1={A[i+2]→A[i+4]}和next_A_2={A[i]→A[i+4]},其中next_A_1的依赖距离δ=2,跨过的流水段延时Δ=7,在RAW_DDA模型中表示为NEXTnext_A_1={A[i+2]→A[i+4],δ=2,Δ=7},next_A_2的依赖距离δ=4,跨过的流水段延时Δ=7,在RAW_DDA模型中表示为NEXTnext_A_2={A[i]→A[i+4],δ=4,Δ=7},则在该循环程序中数组元素A[i]引起的RAW数据依赖关系集合NEXT(A[i])={NEXTnext_A_1={A[i+2]→A[i+4],δ=2,Δ=7},NEXTnext_A_2={A[i]→A[i+4],δ=4,Δ=7}};关于数组B[i]存在RAW数据依赖关系next_B_1={B[i]→B[i+2]},next_B_1的依赖距离δ=2,跨过的流水段延时Δ=4,在RAW_DDA模型中表示为NEXTnext_B_1={B[i]→B[i+2],δ=4,Δ=7},NEXT(B[i])={NEXTnext_B_1={B[i]→B[i+2],δ=4,Δ=7}}.在RAW_DDA模型中,使用[NEXT]表示循环程序中所有RAW数据依赖关系的集合,因此[NEXT]={NEXTnext_A_1,NEXTnext_A_2,NEXTnext_B_1}.图9具有RAW依赖关系的循环迭代体数据流基于数据依赖关系分析算法得到的RAW_DDA结果,本文对多层循环中每一个循环体stmt(犐r)进行迭代间启动间距分析,当循环体stmt(犐r)的索引变量Ir的边界pr或qr是变量时,会引起迭代间的启动间距不是一个固定值,本文提出采用向量来表示迭代间启动间距信息,建立非固定启动间距模型NF_II(None-FixedInitiationInterval),如定义4所述.定义4.NF_II模型.多层循环中循环体迭代间启动间距信息用二维向量犖犉_犐犐表示,犖犉_犐犐=(犐犐1,犐犐2,…,犐犐r,…,犐犐m),1rm.其中犐犐r表示循环体stmt(犐r)在索引变量Ir控制下流水启动时的延时向量,即循环体stmt(犐r)在迭代空间中迭代点(I1,I2,…,Ir,…,Im)与(I1,I2,…,Ir+θr,…,Im)之间的启动延时按照迭代顺序生成的迭代间启动间距向量.对于索引变量为Ir=(pr,qr,θr)的循环体stmt(犐r),各个迭代点之间启动间距延时按照迭代顺序生成,每次迭代之间的启动延时向量为犐犐r.例如,当犐r=(i,j),Ii=(0,4,1),Ij=(0,5,1)时,对应的循环程序如图10所示,初始化循环体stmt(0,0)的启动延时为1,假如stmt(0,0)与stmt(0,1)之间的启动延时为2,stmt(0,1)与stmt(0,2)之间的启动延时为1,stmt(0,2)与stmt(0,3)之间的启动延时为1,stmt(0,3)与stmt(0,4)之间的启动延时为2,则循环体stmt(i,j)在索引变量j控制下迭代间流水启动Page7间距向量犐犐j=(1,2,1,1,2);假如stmt(0,0)与stmt(1,0)之间的启动延时为1,stmt(1,0)与stmt(2,0)之间的启动延时为3,stmt(2,0)与stmt(3,0)之间的启动延时为1,stmt(3,0)与stmt(4,0)之间的启动延时为2,则循环体stmt(i,j)在索引变量i控制下迭代间流水启动间距向量犐犐i=(1,1,3,1,2);最终,该循环程序的迭代间启动间距信息可以表示为犖犉_犐犐=((1,1,3,1,2),(1,2,1,1,2)).NF_II模型能够表示计数类多层循环中循环体stmt(犐r)每次迭代流水执行启动时的精确时间,采用非固定启动间距的思想,实现细粒度可重构编译生成的多层循环流水硬件单元的时序控制,能够有效减少多层循环流水执行时的冒泡现象,提高多层循环流水执行的吞吐率.3.3启动间距自动分析算法根据RAW_DDA得到的RAW数据依赖关系分析结果进行多层循环的迭代间启动间距分析时,将多层循环按照图5所示递归表示成多个单层循环的形式,Loop(r)中循环体stmt(犐r)迭代之间启动间距是由与索引变量Ir相关的RAW数据依赖关系所决定的,其中1rm,Loop(r)的启动间距向量犐犐r与索引变量Ir存在一对一仿射关系,如式(1)所示,其中,k是正整数.犐犐r=(IIpr循环体stmt(犐r)中迭代点Ir=pr+k·θr与Ir=pr+(k+1)·θr之间的启动间距为IIpr+(k+1)·θr,启动间距IIIr数据依赖关系NEXT=(next,δ,Δ)与启动间距向量犐犐r中每个启动间距IIIr中delay表示依赖关系next在循环Loop(r)中循环体迭代之间的时钟延时.对于索引变量Ir所控制的循环体stmt(犐r)来说,当k=0时,表示该循环体第一次启动,因此,设置该循环体在索引变量Ir控制下的第一次迭代启动时间延时为1.当k>0时,如果存在RAW数据依赖关系NEXT=(next,δ,Δ),当依赖关系next在循环体stmt(犐r)中跨过的流水段延时Δ与索引变量Ir的增量θr之间的乘积小于该依赖关系next在循环体迭代之间的时钟延时,说明该RAW依赖关系不会影响下一次迭代启动延时,因此下一次迭代的启动间距设置为1;如果依赖关系next在循环体stmt(犐r)中跨过的流水段延时Δ与索引变量Ir的增量θr之间的乘积大于等于该依赖关系next在循环体迭代之间的时钟延时,则说明该依赖关系会影响迭代间启动间距演示,本文首先初始化该依赖关系经过的所有迭代启动延时为1,然后对最后一次迭代进行启动时间推迟,因此当k%delay≠0时,迭代间启动间距置为1,当k%delay=0时,进行启动时间推迟,经过对循环程序迭代间执行时间进行分析,得到式(2)中所示结果.本文所提出迭代间启动间距自动分析算法的前提是如何计算RAW数据依赖关系next在循环体两次迭代之间的时钟延时.烄IIIr=烅烆为了得到RAW数据依赖关系next在两次迭代之间的延时信息delay,本文提出式(3)~(5)所示的递归计算方法,在循环Loop(r)中,根据RAW依赖关系next的依赖距离δ可以获得具有依赖关系next的两次迭代之间的延时delay,如式(3)所示,其中T(Loop(r+1))表示在循环Loop(r)中索引变量为Ir时循环Loop(r+1)流水执行时的时钟周期.循环Loop(r)的两次迭代之间延时delay由最内层循环Loop(m)的循环体stmt(犐m)以递归形式计算得到,循环Loop(m)的迭代间启动间距向量为犐犐m,根据本文提出的非固定启动间距思想,在实现循环内部流水执行的同时,还可以实现循环层间流水执行.在进行循环流水迭代间启动间距分析时,首先根据式(5)对最内层循环Loop(m)的迭代间启动间距进行初始化,相邻两次迭代stmt(Im)之间的启动间距设置为1,则根据式(3)可以得到Loop(m)中RAW数据依赖关系NEXT=(next,δ,Δ)所经过的迭代间延时信息delay=δ,则可以根据式(2)计算出最内层循环每次迭代之间的启动间距向量犐犐Im.将最内层循环的迭代间流水启动时间确定好之后,可以根据式(4)计算得出r=m-1时的循环Loop(r)中内层循环Loop(m)流水执行时的运行时钟周期数T(Loop(r)),以循环Loop(m)作为循环Loop(m-1)的循环体,进而根据式(2)~(3)可以求Page8出循环Loop(m-1)中每次迭代之间的启动间距向量.如式(4)所示,在计算最内层循环Loop(m)的运行时间T(Loop(m))时,由于每次迭代启动时间为一个时钟周期,因此直接将最内层循环的每次迭代启动间距值进行求和.在得到最内层循环执行时间之后,结合内层循环迭代间启动间距信息,就可以利用式(4)递归计算出精确的不同深度循环的迭代运行时间.最后根据式(2)就可以得出多层循环中每一层循环每次迭代之间的启动间距信息,从而得出循环程序的NF_II模型.delay(stmt(犐r))=T(Loop(r))=)/θm)/θmk=0(qm-pm∑(qm-pm∑k=0烄烅烆根据如上所示多层循环中迭代间启动间距计算方法,本文在细粒度可重构编译器ASCRA中设计实现了多层循环中循环体流水执行时迭代间启动间距自动分析算法.多层循环深度流水执行时迭代间启动间距自动分析算法的伪代码描述如算法1所示.首先,对最内层循环Loop(m)的启动间距向量犐犐m进行分析.采用基于硬件延时的流水线划分算法[12]对循环体stmt(犐m)进行流水线划分;按照式(5)对最内层循环Loop(m)的迭代间启动间距向量犐犐m进行初始化,将最内层循环中迭代间启动间距设置为1;然后对stmt(犐m)的RAW_DDA模型中数据依赖关系集合[NEXT]进行筛选,当Δ×θmδ时,则该依赖关系next会对循环体下一次迭代执行产生推后影响,如果Δ×θm<δ,则说明该RAW数据依赖关系不会影响迭代间启动间距,因此将其从数据依赖关系集合[NEXT]中进行删除,对符合该条件的next依赖关系进行遍历,根据式(2)进行启动间距向量犐犐m的更新.对于RAW_DDA模型中RAW数据依赖关系集合[NEXT]中每一个依赖关系(next,δ,Δ),遍历Loop(m)中所有迭代体stmt(Im),根据式(3)可以得知delay=δ,因此,如果k%δ=0并且Δ×θrδ,说明该RAW依赖关系next会影响迭代间启动间距,如果该依赖关系next在索引变量Ir到索引变量Is的迭代之间,则首先假设当Ir<Is-θm时,迭代stmt(Ir)的启动间距均为1,根据式(2)可以将迭代stmt(Is)的启动推后执行,启动间距为IIt=Δ×θm-δ+2,这时可能之前的迭代启动会被其他的RAW依赖关系推后执行,因此,将之前的所有迭代启动时间进行求和,将根据式(2)计算得出的启动间距减去由其他RAW依赖关系引起的迭代推后执行时间,得到迭代stmt(Is)最终的启动间距延时时间IIIr=IIt+δ-sum.最后,将得出的迭代体stmt(Ir)的启动间距信息加入启动间距向量犐犐m中.在得到最内层循环Loop(m)的启动间距向量犐犐m之后,可以根据式(4)得出最内层循环的运行时间T(Loop(m)),从而可以对r<m的外层循环Loop(r)进行启动间距分析.首先,初始化启动间距向量犐犐r中每个迭代stmt(Ir)的启动时间间距为1.其次,根据算法1的步骤(1)中的方法对影响stmt(犐r)中迭代间启动间距的数据依赖关系集合[NEXT]进行筛选,将满足条件Δ×θm<delay的依赖关系删除.最后,根据Loop(m)的启动间距向量犐犐m和T(Loop(m)),结合式(2)~(4)对深度r=m-1的循环Loop(r)进行启动间距向量犐犐r的分析.最后,按照上述算法,依据索引变量对循环进行遍历,迭代求出每一层循环的迭代间启动间距向量犐犐r,构建整个循环的迭代间启动间距信息模型NF_II.算法1.多层循环NF_II模型自动分析算法.输入:RAW_DDA模型输出:犖犉_犐犐(1)计算最内层循环的启动间距向量犐犐m,依据式(5)初始化犐犐m;//筛选RAW依赖关系next;FOReachArrayINRAW_DDA.[Array]DOFOReach(next,δ,Δ)INArray.[NEXT]DOIFArray.[NEXT]=THENENDFOR//遍历RAW_DDA.[NEXT],更新犐犐m;FOReach(next,δ,Δ)INRAW_DDA.[NEXT]DOFORIr←pmtoqmDOPage9ENDFORENDFOR(2)根据最内层循环启动间距向量犐犐m和式(2)~(5)递归计算深度小于m的循环Loop(r)的启动间距向量犐犐r,构建NF_II模型;FORr←m-1to1DO初始化犐犐r,根据式(3)和(4)计算[NEXT]中next在循环体stmt(犐r)中相邻两次迭代之间的延时delay,删除[NEXT]中满足Δ×θm<delay条件的next;FOReach(next,δ,Δ)IN[NEXT]DO根据上文建立的多层循环迭代间启动间距信息模型,可以准确地评估出多层循环流水执行时的运行时钟周期,为细粒度可重构编译器中软硬件划分提供更加完善的划分依据信息,同时采用该NF_II自动分析算法获得的多层循环深度流水执行时迭代间非固定启动间距信息能够支持循环流水控制单元的生成.4循环流水迭代间启动间距优化在进行多层循环流水迭代间启动间距自动分析方法研究的同时,还在研究如何实现在非固定启动间距的基础上进一步对启动间距模型进行优化,因为最内层循环的执行时间对整个循环性能影响最大,因此本文从降低最内层循环循环体迭代间启动间距向量值方法入手,提出了一种采用流水线调度技术进行启动间距优化的方法.在循环Loop(m)中,对循环体stmt(犐m)采用基于硬件延时的流水线划分技术进行流水线划分,当存在导致下一次迭代推后执行的迭代间RAW依赖关系next时,启动间距大于1,则可以通过算法2中描述的方法进行最内层循环迭代间启动间距优化,主要思想是将依赖关系next中的Load指令操作按照ALAP调度算法进行流水段延后,对Store指令按照ASAP调度算法进行流水段数提前,提高RAW依赖关系中访存指令之间的时间间隔.经过实验表明,该方法对于一些循环程序应用能够有效减少最内层循环中循环体流水执行时迭代间启动间距,从而达到提高循环应用流水执行的性能.算法2.多层循环启动间距优化算法.输入:stmt(犐m)数据流图dfg和RAW_DDA模型输出:优化后的stmt和RAW_DDA模型(1)遍历RAW_DDA中的[NEXT],在dfg中找到RAW数据依赖关系NEXT对应的回边eij(vi→vj);QE←;//QE表示回边队列FOReachback-edgeeijINdfgDOIFvi.h>vj.hTHEN//vi.h表示节点vi的流水段数ENDFOR(2)对QE中回边eij进行遍历,对指令节点vi进行ASAP调度;WHILEQE≠DOeij←DEQUEUE(QE);min_h_i=0;IFmin_h_i>1THENENDWHILE(3)对QE中回边eij进行遍历,对指令节点vj进行ALAP调度;WHILEQE≠DOPage10eij←DEQUEUE(QE);min_h_i=0;FOReachedgedfg.ejm(vj→vm)DOENDFORIFmin_h_i>1THENENDIFENDWHILE(4)针对优化后的stmt,更新RAW_DDA模型中依赖关系NEXT中的Δ信息.WHILEQE≠DOeij←DEQUEUE(QE);NEXT←RAW_DDA.[NEXT];NEXT.Δ=vi.h-vj.h;ENDWHILE如图11所示,图(a)和(b)中的RAW数据依赖关系均为NEXTA={A[i+2]→A[i+4],δ=2},而迭代间流水段延时Δa=4,Δb=3,所得到的迭代间流水启动间距向量犐犐犪=(1,1,4,1,4,1,4,…),犐犐犫=(1,1,3,1,3,1,3,…).通过降低数组A产生的RAW数据依赖关系在循环体中所跨过的流水延时,降低了迭代间流水启动间距,有效地提高了循环程序的数据吞吐率.5实验结果与分析本文针对现有细粒度可重构编译器循环流水映射对于迭代间启动间距的制导语句控制方式进行分析,建立了循环流水启动间距信息模型,提出非固定启动间距控制策略,并设计实现自动分析算法,基于流水线调度技术进行了启动间距优化,最后在可重构编译器ASCRA中,基于Xilinx的Zynq-7000APSoCZC706开发板进行了功能实现与性能验证.在ASCRA中实现本文所提出的非固定启动间距控制方式到FPGA硬件电路的自动映射时,与现有可重构编译器类似,针对每一个循环程序模块,设计实现一个循环流水调度控制单元,并不需要额外的循环调度控制单元,与生成迭代间固定启动间距的现有可重构编译器不同的是,根据非固定启动间距信息模型生成的循环调度控制单元包含一个额外的存储器RAM和一个计数器,RAM用来存储本文方法自动分析得到的循环流水迭代间非固定启动间距信息,根据RAM中存储的启动间距值使用计数器推后每次迭代的启动使能信号,从而实现循环程序迭代间非固定启动间距的流水执行.虽然需要额外的RAM硬件资源和计数器所消耗的硬件资源,但是与该方法所提升的性能相比,消耗这个规模的FPGA资源还是可以接受的.对于循环程序来说,影响程序性能的关键是循环体中的数学运算和逻辑运算指令,一般影响循环流水执行的关键路径都是数学运算中类似乘法运算这样耗时的指令,循环调度控制单元虽然会增加RAM存储器的读写操作,但是该操作是可以采用数据预取的方式避免对性能的影响.与本文所提出的非固定启动间距控制方式对循环流水执行时的性能提升相比,改善循环调度控制单元所引起的性能降低可以忽略不考虑.本文在进行循环流水启动间距分析优化的时候,采用局部优化的思想对循环流水启动间距进行优化与改进,本小节主要采用理论证明和性能测试两种方式进行循环流水启动间距自动分析及优化方法的性能验证.现有细粒度可重构编译器采用制导语句方式生成迭代间固定启动间距,对于多层循环中不同深度的循环Loop(r)所对应的启动间距模型可以表示成1个一维向量,如式(6)所示,其中1rm.假设所有循环体stmt(犐r)的启动时间单位都是t,则在采用制导语句生成固定启动间距方式的流水硬件结构中,循环体相邻迭代之间等待时间II_Time如式(7)所示.而采用非固定启动间距控制方式生成的流水硬件结构中,相邻迭代之间的等待时间Page11NF_II_Time如式(8)所示.在细粒度可重构编译器中,制导语句控制生成的固定启动间距模型II中,手动设计的固定启动间距IIr最佳值为非固定启动间距向量犐犐r中的最大值,如式(9)所示,其中k是正整数.IIr=max(IIpr根据式(7)~(9),可证明得出采用非固定启动间距方式能够减少多层循环流水执行时循环体每次迭代启动等待时间,如式(10)所示.为了验证式(10)的正确性,本文在细粒度可重构编译器ASCRA中进行循环流水启动间距自动分析和优化方法的设计与实现,对多层循环分析得到的启动间距信息不仅可用于支持软硬件划分中硬件性能评估,同时可支持自动映射生成循环流水硬件结构的控制调度单元.该方法在提高可重构计算应用部署效率的基础上,还可以有效地提高部分循环的流水性能.下文从测试集PolyBench-3.2中选取了不同循环特征的测试程序进行实验和分析,对比本文提出的循环流水启动间距自动分析及优化方法与现有HLS工具采用的制导语句控制方式,测试循环程序在FPGA硬件中流水执行时消耗的时钟节拍数,并分析随着循环程序迭代空间的变大,本文方法对循环程序性能加速效果的变化.当循环中所有索引变量迭代次数均为常量值时,采用本文方法能够有效提高循环的性能.下面采用jacobi-1D、jacobi-2D、Seidel-2D这3个经典循环程序进行测试.其中,jacobi-1D是一个单层循环,索引变量Ii=(0,N,1),jacobi-2D和Seidel-2D是一个两层循环,循环索引变量向量均为犐r={(Ii,Ij)|Ii=(0,N,1),Ij=(0,N,1)},这3个测试程序的共同特征是不同深度循环的索引变量迭代次数均是常量.与采用制导语句控制方式的现有HLS工具相比,本文方法能够有效减少循环流水执行时的时钟节拍数.实验结果如表1所示,N表示循环索引变量迭代次数,表1中的测试程序不同深度循环的索引变量迭代次数均为N,clockcycles表示循环流水执行时消耗的时钟节拍数.根据表1中实验结果可以得知,随着迭代空间的增大,采用本文提出的循环流水启动间距自动分析及优化方法,能够有效提高具有常量迭代次数索引变量的循环程序的性能,并且能够保持稳定的性能加速比.与采用制导语句方式的现有HLS工具相比,采用循环流水启动间距自动分析及优化方法的可重构编译器ASCRA分别获得了20%、33.3%、42.86%的稳定加速比.测试集jacobi-1Djacobi-2DSeidel-2D当循环中的索引变量迭代次数是变量时,会产生不规则形状的迭代域空间,例如三角矩阵乘法TRMM的迭代域及迭代空间依赖关系,如图12所示,其特点是迭代域空间属于不规则形状.针对具备不规则迭代域空间特征的循环程序,本文选用PolyBench测试集中Triangular、TRMM、Trisolv循环程序分别进行测试.其中,Triangular是一个两层循环,循环索引变量向量犐r={(Ii,Ij)|Ii=(0,N,1),Ij=(0,N-i,1)};TRMM是一个三层循环,循环索引变量向量犐r={(Ii,Ij,Ik)|Ii=(0,N,1),Ij=(0,N,1),Ik=(0,i,1)};Trisolv是一个两层循环,循环索引变量向量犐r={(Ii,Ij)|Ii=(0,N,1),Ij=(0,i-1,1)}.这3个循环程序中均存在索引变量迭代次数与索引变量相关的特征,Page12采用本文提出的循环流水启动间距自动分析及优化方法,得到这3个循环程序随着迭代阈值N的变化,流水执行时消耗的时钟周期数结果,如图13、图14、图15所示.其中,横坐标表示循环索引变量的边界值N,随着N的增长,循环的迭代次数在增加,纵坐标“运行时间”表示循环程序在FPGA上流水执行时消耗的时钟节拍数,次纵坐标“优化时间”表示现有HLS工具与采用本文所提方法实现的ASCRA在循环程序流水执行时消耗的时钟节拍数之差HLS-ASCRA.根据图13、图14、图15结果可知,与采用制导语句控制方式的现有HLS工具相比,本文方法能够有效地减少循环程序流水执行时所消耗的时钟节拍数,提高程序的性能,并且本文方法使循环程序优化的时钟节拍数随着N增大而增长.对于上述3个循环程序,当迭代阈值N增大时,外层循环迭代间RAW数据依赖关系距离会小于内层循环一次迭代执行所消耗的时间,从而导致外层循环迭代间启动间距不受其RAW数据依赖关系影响,不需要对外层循环迭代间启动间距进行优化.因此,本文只对其内层循环启动间距进行优化,即分别对索引变量为Ij=(0,N-i,1)、Ik=(0,i,1)、Ij=(0,i-1,1)的循环进行启动间距优化,减少了内层循环流水执行所消耗的时钟节拍数,进而减少整个循环程序流水执行所消耗的时钟节拍数,提高整个循环程序的性能.综上所述,与现有HLS工具采用制导语句进行循环流水启动间距控制相比,本文所提出的循环流水启动间距自动分析和优化方法能够自动获得迭代间启动间距,能够有效提高可重构计算应用在异构加速平台上的部署效率;同时,本文提出了非固定启动间距控制策略与基于流水线调度技术的启动间距优化方法,针对特定循环能够有效提高循环在FPGA协处理器中流水执行时的性能,并对具有常量索引变量迭代次数特征的循环具有良好的加速比.6结束语本文在面向CPU-FPGA异构加速平台的细粒度可重构编译器ASCRA中提出了一种循环流水启动间距自动分析及优化方法,针对现有HLS工具中制导语句生成固定启动间距的缺陷,本文提出的方法建立了多层循环流水迭代间启动间距分析模型,并提出了非固定启动间距的控制策略,设计实现了自动分析启动间距的算法,最后通过流水线调度方式对多层循环中启动间距进行优化.实验结果表明,针对计数类多层循环应用程序,本文方法不仅实现了细粒度可重构编译器中实现循环程序流水硬件结构映射时启动间距分析的自动化,提高了可重构计算应用的部署效率,还能够有效降低循环程序在FPGA硬件上流水执行时因为启动间距产生的时钟等待延时,提高了循环程序流水执行的性能.本文会继续致力于在异构加速平台上循环流水自动映射方向的研究,下一步会结合参数化并行存储模板,进行循环流水硬件结构的研究,将本文提出的非固定启动间距控制策略在异构加速平台上进行实现和完善.致谢Xilinx大学合作计划对课题组提供了相应的开发平台,中国科学院计算技术研究所计算机体系结构国家重点实验室对本课题给予了支持,在此表示感谢!Page13
