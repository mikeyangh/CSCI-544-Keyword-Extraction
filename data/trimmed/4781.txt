Page1一种具有访问控制的云平台下外包数据流动态可验证方法孙奕1),2),3)陈性元2)杜学绘2),3)徐建2)1)(北京交通大学计算机与信息技术学院北京100044)2)(解放军信息工程大学郑州450004)3)(数学工程与先进计算国家重点实验室郑州450004)摘要针对云平台下外包数据流不可信、验证范围不可控等问题,该文提出一种具有访问控制的外包数据流动态可验证方法.该方法的核心思想是利用任意的Hash函数、双陷门Hash函数和CP-ABE(CipertextPolicy-AttributeBasedEncryption)算法构成一种具有访问控制的动态可认证数据结构(AC-MTAT).该可认证结构可以实现对外包数据流的实时增加、更新和细粒度动态验证.此外,该可认证数据结构不仅能够验证外包数据流的完整性,还能够验证数据流序列的正确性.由于在传统默克尔Hash树(MHT)中引入双陷门Hash函数,AC-MTAT的构建过程可以分为两个阶段:离线阶段和在线阶段.这样构建AC-MTAT所需的主要代价可以放在离线阶段完成,大大提高了AC-MTAT在线实时构建效率.该文首先给出AC-MTAT方案的形式化定义和具体构建算法;然后,对AC-MTAT方案的安全性进行证明,证明其满足正确性、可验证安全性和访问安全性;最后,分析了方案的实现效率,并通过实现一个AC-MTAT原型来评估算法的耗费时间,实验结果显示作者的方案对于外包数据流的验证是高效的和可行的,而且与现有方案相比,该方案在实时增长、高效更新、可控验证以及对数据流的适应性等方面更有优势.关键词可认证数据结构;安全外包数据流;访问控制;完整性;密文策略基于属性加密算法;云计算1引言随着云计算、大数据、移动网络的快速发展,一方面,许多应用(如Web访问分析、环境感知、实时监控和股票交易等)产生大量的数据流.另一方面,终端的计算能力和计算资源有限,无法实时处理或存储这些大规模数据.因此考虑到成本和代价,当大量的数据流产生时,用户(数据拥有者)通常会将这些数据流外包给云平台进行管理和维护,以便其他用户访问和使用.然而云平台的公开性和开放性使得云平台下的数据变得不可信,云平台很可能会向数据使用者提供伪造的数据结果.此外,对于外包数据流来说,随着终端应用数据的不断产生,数据拥有者不断向云平台上传数据,这样云平台下共享的数据一直处于持续增长和动态变化中.如何对远程不可信环境下,连续的、动态变化的外包数据流进行动态更新,实时验证和受控访问就成为解决云平台下数据流实时共享与安全交换的关键所在.外包数据流连续、实时、海量、非本地存储等特性使得现有验证方案应用在外包数据流时存在以下挑战:(1)验证者无法将全部数据流缓存后再进行验证;(2)传统的完整性验证方法无法高效地验证流序列的正确性;(3)验证者与证明者之间是非交互的;(4)更新数据时需要用户存储以往变更痕迹,否则无法验证数据更新版本的正确性;(5)验证范围不可控,不能实现对验证者身份的细粒度控制,使得被验证数据存在信息泄露等风险.基于以上分析,本文在对可认证数据结构研究的基础上,引入双陷门Hash函数[1-3]和CP-ABE算法[4]对典型的可认证数据结构———MerkleHashTree[5-6]进行改进,提出一种具有访问控制的可认证数据结构———AC-MTAT,并在此基础上实现了一种新颖的外包数据流动态可验证方法,为解决云平台下数据流实时共享与安全交换提供技术支撑.2相关工作可认证数据结构本质上是一种新型分布式计算模型[7].Tamassia[8]第1次正式描述了可认证数据结构模型,模型中包含1个客体的结构化集合S和3个参与者:源、响应者和用户.源持有S的原始版本.当在S上执行更新时,源产生结构化认证信息,其包含1个具有当前版本S时间戳的签名.响应者维持S的1个副本.响应者与源交互获得S的更新及相应的结构化认证信息.响应者也与用户交互回答用户对S的查询.此外,响应者返回符合的认证信息,该信息包含由源发布的最新结构化认证信息和应答的1个证据.用户在S上实施查询,但不能直接与源交互,只能与响应者交互.然而,用户相信源但不相信响应者,因此用户验证来自响应者与应答相关的认证信息.被源和响应者用来存储集合S的数据结构,以及由不同参与者执行的查询、更新和验证算法,形成可认证数据结构.目前实现可认证数据结构的实现方式主要有认证跳表[9]、索引Hash链表[10]、MHT(MerkleHashTree)和MACTree[11]等.其中MHT是最早的可认证数据结构.MHT是一个二进制Hash树,叶子结点是各个数据块的Hash值,中间结点是所有子结点Hash值连接后的Hash值.进行完整性检验时只需要对叶子到根结点的一条或若干条路径进行处理,就可以高效地证明一组数据(块)具有完整性,未Page3被损坏和篡改.MHT可以仅通过一个签名就能对树中的每个结点值进行认证,又允许中间结点通过计算Hash路径的对数来验证树中结点数量,可以实现对指数数量级数据的验证.这些优势使其成为一种被广为研究的用于验证远程不可信环境下数据完整性的技术.因此,本文在MHT的基础上,构建具有访问控制的云平台下外包数据流动态可验证方案.为了同时支持公开审计和全动态数据操作,Wang等人[16]引入MHT,通过对MHT树型结构的变换,改变现有验证证据的存储模型,来实现全动态数据操作,并利用BLS算法构建数据块的同态认证标签,实现公开审计.Hao等人[17]和Yang等人[18]也对可公开验证下的、可支持动态数据的完整性验证方案进行了讨论.为了进一步提高验证时目前与本文研究相关的工作主要涉及两个方面:数据持有性证明(ProvableDataPossession,PDP)和数据可检索证明(ProofofRetrievability,POR).PDP是Ateniese等人[12]于2007年首先提出的,可以实现对外包数据的高效验证,这是第一个不分块且支持公开验证的方案.POR是由Shacham等人[13]在2008年提出的,是对PDP的扩展,不仅能够验证远程数据是否被篡改,还可以利用纠删码技术保证数据的可恢复性.这两种验证模式的主要思想是利用短签名算法(BLS)或RSA签名算法构建同态线性验证标签(homomorphiclinearauthen-ticator),使得用户在不取回数据的情况下,对远程服务器(如云)中数据的完整性进行验证,可以分为确定性验证和概率性验证两类.为了在有效地验证数据完整性的情况下,同时能够支持数据的动态操作,在后续的研究方案中引入了可认证数据结构.Ateniese等人[14]提出了一种支持数据动态存储的SPDP方案.该方案可以支持数据的更新和删除,但不支持数据的添加.由于该方案是基于对称密钥的,所以不能支持公开的验证并且由于每次验证都需要消耗一个密钥,其能够提供的数据验证的次数有限.2009年,Erway等人[15]第1次提出了一种能够支持全动态操作的可证明的数据持有方案.该方案为了解决数据块更新后造成的索引信息的变更问题,在标签计算中删除了Ateniese所提出的PDP模型中的索引信息,利用基于等级的认证跳表构建数据块的标签信息.不足之处是执行效率不高.的查询效率,Li等人[19]将MHT概念融合到B+树结构中,提出一种MB-Tree树型结构对存储数据进行组织和管理,并通过树型结构的变化来体现对数据的动态操作.Zhu等人[20-21]采用索引Hash链表来支持动态数据的有效更新,并利用分离结构(fragmentstructure)的方法来减小可公开验证方案中所需的存储验证信息的开销.为了解决多用户下的云端共享数据问题,Tate等人[22]提出一种可以支持多用户的,支持动态数据更新的数据完整性验证方案.但该方案需要基于可信硬件(trustedhardware)来实现.为了支持对云平台下大数据的细粒度更新验证要求,Liu等人[23]提出一种具有标记的默克哈希树(RMHT)方案.该方案基于BLS算法为每一个分块数据计算同态线性验证标签.与之前需要均分数据块大小的方案不同,该方案中数据块大小可以是任意大小的,在MHT叶子结点中除了保存数据分块信息以外,增加了标记信息,该标记信息用于记录对每个数据分块再次细分后的数据块个数信息及位置信息,从而利用该标记实现对每个数据块中数据的细粒度更新,而无需更新整个数据块信息.Liu等人[24]、Feng等人[25]和Tan等人[26]也对现有的云平台下外包数据完整性验证技术进行了总结与展望,但均未涉及对外包数据流的完整性验证问题.综上所述,以上方案都针对静态文件的动态操作,不适用于对数据流的动态操作.这些方案的一个共同点是需要对文件进行分块,然后将这些数据块作为MHT的叶子结点来构建Hash认证树,不同方案中根据其所实现的功能不同,叶子结点存储的附加信息不同.在动态更新过程中,通过变换MHT树型结构(如更新某些结点、合并某些结点、分裂某些结点)来实现对数据的动态操作.以上构建方法,需要用户在构建MHT时,提前确定所有叶子结点的信息,才能生成MHT.然而,对于数据流来说,不可能将整个数据流缓存下来,分块后再构建MHT.因此,构建面向数据流的Hash认证树时,不可能提前确定所有叶子结点信息.以上方案不适用于对数据流的动态操作和实时验证.最近,Schroeder等人[27-28]从另一个角度对MHT进行改进,引入变色龙Hash函数[29]构造一个变色龙认证树(CAT),来实现对数据流的动态操作和实时验证,并基于CAT构造了一个可验证数据流方案(VDS).该方案优势是基于CAT无需提Page4前固定叶子结点,对于掌握陷门信息的用户,无需预先计算或重新计算其他叶子结点就能对新元素进行添加和认证,而且在数据流协议的设置阶段中数据可以是未知的.本文在CAT的基础上进行改进,构建一种具有访问控制的动态可认证数据结构(AC-MTAT).与CAT不同,在CAT中为了防止攻击,陷门碰撞只能使用一次,因此当更新数据时需要重新构建整棵树和验证公钥;本文采用双陷门Hash函数,可以计算多次碰撞,无需更新根结点的值和公钥,提高了数据的更新效率,而且通过分期偿还机制将认证树的构建分为离线阶段和在线阶段,大大提高数据增长时可认证数据结构的构建效率,从而提高对实时数据的处理效率.此外,本文提出的方案具有基于属性的细粒度授权验证功能,既不是基于对称密钥的认证,也不是对所有用户的公开验证,只有满足一定访问策略的用户才能验证.这样在云平台下面向多个用户、多个可认证数据结构时,可以实现基于属性的细粒度授权验证,从而能够较好的控制共享平台下数据的可验证范围,保护不同数据用户的隐私,同时在授权用户和验证范围更新时,降低密钥管理的复杂度.3具有访问控制的动态可认证数据结构本节提出一种具有访问控制的动态可认证数据结构,并给出其总体描述及形式化定义.3.1总体描述具有访问控制的动态可认证数据结构本质上是由任意的Hash函数、双陷门Hash函数和CP-ABE算法所组成的一种具有访问控制的双陷门Hash认证树,该认证树可以实现一种新颖的认证技术.与传统的MHT相比,AC-MTAT在Hash函数的图1AC-MTAT架构基础上,引入了双陷门Hash函数(利用双陷门Hash可以实现无密钥泄露的陷门Hash函数)和CP-ABE算法共同构成一棵二进制树.图1展示了一个AC-MTAT例子:我们用D表示树的深度,树的每一层的高度用h=0,…,D-1来表示,则树中叶子结点的高度为h=0,根结点的高度为h=D-1.每个非叶子结点最多有两个孩子结点,树的右结点是通过双陷门Hash函数计算的值,左结点由Hash函数计算的值;中间结点是两个孩子结点Hash值连接后的Hash值,根结点是CP-ABE对根值进行加密的值,记作γ,只有满足访问策略的用户才能获取根结点的值.AC-MTAT的主要构建思路如下:我们用H表示Hash函数,用MTH表示双陷门Hash函数.首先随机选择两个叶子结点的值l0和l1,来构建初始化认证树,如图2所示,计算H(l0‖l1)=N1,0作为结点N1,0的值,随机选择信息m和碰撞值r,利用双陷门Hash函数计算MTH(m,r)=N1,1作为结点N1,0的兄弟结点即N1,1的值.接着,计算H(N1,0‖N1,0)=N2,0作为其父结点的值,依次类推计算到D-1层.然后,利用双陷门Hash函数计算MTH(m,rρ)=ρ,并利用CP-ABE算法对ρ进行加密得到γ.随着数据的增长,可以实现对初始化认证树结点的动态增加,增加的结点分为两种情况,如果增加的是右结点的叶子结点,则只需要更新陷门碰撞值,如:增加叶子结点l2和l3,记l2‖l3=m,利用求碰撞值算法获得r,使得MTH(m,r)=MTH(m,r),更新N1,1的存储值为(m,r).如果增加的是左节点的叶子结点,则计算叶子结点的Hash值,如果兄弟结点不存在,随机选择信息对(mi,ri)计算陷门Hash值作为其兄弟节点,逐层向上计算,直至父节点为陷门Hash值,更新其上存储的碰撞值即可.按照以上的方法不断增加新的叶子结点,直至建满树为止.Page53.2形式化定义定义1(双陷门Hash函数族MTH)[2-3].一个双陷门Hash函数族由一个三元组(I,I,H)所组成:(1)I是一种概率多项式时间的密钥生成算法,输入1k,输出一对长久Hash/陷门密钥对(HK,TK),使得HK,TK的长度是k的多项式有关;(2)I是一种概率多项式时间的密钥生成算法,输入1k,输出一对一次性Hash/陷门密钥对(HK,TK),使得HK,TK的长度是k的多项式有关;(3)MTH是一个随机的Hash函数族.输入1k,一对Hash/陷门密钥对(HK,TK),一对(m,r)∈M×R和一个消息m≠m,运行求碰撞函数MTHColHK(TK,m,r,m)输出一个碰撞参数r和HK,使得MTHHK(m,r)=MTHHK(m,r).当HK≠HK时,HK与其关联的陷门密钥TK称为一次性密钥对.一个双陷门Hash函数应满足有效计算、陷门碰撞、抗碰撞、抗密钥泄露和语义安全等性质,详细证明过程参见文献[2-3].定义2[4].一个基于属性加密的方案由以下4个算法组成:ABE.setup,ABE.keygen,ABE.encrypt和ABE.decrypt.ABE.setup(1k):输入安全参数1k,输出一对主公/私钥对(pk,sk).ABE.keygen(sk,A):主私钥sk和属性A生成解密密钥dkA.ABE.encrypt(m,ω,pk):主公钥pk,消息m和访问控制策略ω,生成密文c.ABE.decrypt(c,dk,ω):如果A满足密文c绑定的策略ω,则输入公钥pk,解密密钥dkA和密文c,可以解密输出消息m.CP-ABE全安全性证明参见文献[4].定义3.一个具有访问控制的动态可认证数据结构是一种概率多项式时间(PPT)算法AC-MTAT=(MtatGen,IkeyGen,CertIssue,InitiRoot,Add_Leaf,Update_Leaf,MtatVrfy):(SK,VK)←MtatGen(1k,D):AC-MTAT密钥生成算法.算法输入安全参数1k和一个整数D,整数D表示树的深度.算法返回一个私钥SK和验证密钥VK,然后发布VK并保密SK.(skI,pkI)←IkeyGen(1k):IkeyGen生成算法.算法输入安全参数1k,返回公钥pkI和相应的私钥skI,然后发布pkI并保密sk.certA←CertIssue(skI,pkI,A):属性证书生成算法.算法输入一对密钥(skI,pkI)和一个属性集合A.算法输出访问证书certA.γ←InitiRoot(pkI,root,ω):验证树根生成算法.算法输入公钥pkI,认证树根结点root和一个访问控制结构ω.算法输出关于树根root和ω的公开验证信息γ.(SK,i,aProof)←Add_Leaf(SK,l):认证证据生成算法,算法输入私钥SK和一个叶子结点l∈L.算法输出私钥SK,叶子结点l在树中的索引i,以及认证证据aProof.(SK,nPath,aPath)←Update_Leaf(SK,VK,i,l):叶子结点更新算法.算法输入一对密钥(SK,VK),叶子结点l∈L及其索引i.算法更新位于ith处的叶子结点为l,更新从叶子结点l到根路径nPath上的所有结点,并更新叶子结点l认证路径aPath上的结点.{0,1}←MtatVrfy(VK,i,l,aProof,γ):验证算法.算法输入公钥VK,索引i,叶子结点l,认证证据aProof和验证根γ.如果l确实是位于树中ith的叶子结点,算法输出1否则输出0.4AC-MTAT方案的构建方法定义4.设H是一个抗碰撞Hash函数,槇TH是单向抗碰撞陷门Hash函数,MTH是一个单向的无密钥泄露的双陷门Hash函数,CP-ABE是一个基于密文策略的属性加密方案.则具有访问控制的动态可认证数据结构AC-MTAT由以下6个算法所组成:AC-MTAT=(MtatGen,IkeyGen,InitiRoot,Add_Leaf,Updata_Leaf,MtatVrfy).下面分别对这6种算法进行详细描述.4.1初始化参数MtatGen:MtatGen算法由以下密钥生成算法Page6组成.ThKeyGen(1k):陷门Hash密钥生成算法.输入安全参数1k,返回一对陷门密钥(tk,hk)←槇TH(1k),发布Hash密钥hk,保密陷门密钥tk.MthKeyGen(1k,D):双陷门Hash密钥生成算法,输入安全参数1k和表示树深度的整数D.返回长期陷门/Hash密钥对(mtk,mhk)←MKeyGen(1k)和一次性陷门/Hash密钥对(α,Y)←MKeGen(1k).为了便于描述,用(αt,Yt)表示当前一次性陷门/Hash密钥对,则(αt-1,Yt-1)表示上一次更新时的陷门/Hash密钥对,(αt+1,Yt+1)表示下一次更新时的陷门/Hash密钥对,当t=0时表示双陷门Hash函数的长久陷门/Hash密钥对.IkeyGen(1k):输入安全参数1k,IkeyGen算法运行ABE.setup算法生成一对密钥(skI,pkI)←ABE.setup(1k),发布pkI并保密skI.CertIssue(skI,pkI,A):对于任意一个属性集合A,CertIssue算法运行ABE.keygen算法生成解密密钥.然后设certA··=dkA是一个关于A的证书.InitiRoot(pkI,root,ω):InitiRoot算法使用Add_Leaf(SK,l)算法生成树根ρ,然后输入属性结构ω利用算法ABE.encrypt(ρ,ω,pkI)生成γ.因此仅有满足策略ω的用户可以利用属性证书解密γ,并通过MtatVrfy算法验证叶子结点.4.2构建认证树Add_Leaf(SK,l)路径生成算法在添加叶子结点时分为两个阶段.第1阶段:离线阶段,发生在数据流到达之前,第2阶段:在线阶段,发生在数据流到达之后.这里设c表示计数器,st表示状态表,h表示树的高度,并置c←0,st←(c,D,[(x,r,Yt)]).然后,选择随机数r,计算(lc,lc+1)←槇Th(lc,r).并设SK=(tk,mtk,st),VK=(hk,mhk,γ),发布VK,保密SK.第1阶段:离线阶段(1)Add_Leaf(off-line)算法随机选择叶子结点l和数值r←{0,1}k,计算l和r的陷门Hash函数,将陷门Hash值赋予叶子结点l0和l1,即(l0,l1)←槇TH(l,r),并计算叶子结点l0和l1的父节点n1,0的Hash值即n1,0=H(l0‖l1).随机选择(xh,1,rh,1)∈RM×R(forh=1,…,D-2),并计算陷门Hash值nh,1=MTHmhk(xh,1,rh,1),(forh=1,…,D-2),随机选择xρ和rρ,计算ρ=MTHmhk(xρ,rρ),这里mhk表示长期Hash密钥,其相应的长期陷门密钥是msk.计算nh,0=H(nh-1,0‖nh-1,1)(forh=2,…,D-2)和xρ←(nD-2,0‖nD-2,1).最后,计算rρ←MTHCol(αtxρ,rρ,xρ,αt+1(2)运行算法ABE.encrypt生成验证根γ←ABE.encrypt(ρ,w,pk).(3)生成算法MtatVrfy中用于验证叶子结点l的认证证据,计算叶子结点l的认证证据为aPath=((n1,1,…,nD-2,1),R,Y),并设R=(rρ,r).(4)设置计数器c←2和状态表st←(c,D,xρ,rρ,[x,r,Yi],l0,l1).算法返回私钥SK=(tk,mtk,st),索引序号为0和认证证据aProof.第2阶段:在线阶段Add_Leaf(on-line)算法从状态表中恢复计数器c的值.如果c0则运行Add_Leaf(on-line)算法,添加新的叶子结点及认证证据生成过程如下.算法1.Add_Leaf(on-line).forh=1toD-2doifc/2hiseventhennh,c/2h=H(nh-1,c/2h-1,nh-1,c/2h-1+1)elseendifendififc/2hisoddthenif(nh,c/2h)∈stthenelseendifc←c+2endforR.add(r)output(sp,c,(aPath,R,Y))Page74.3更新认证树Update_Leaf(SK,VK,i,l)叶子节点更新算法.(1)更新叶子结点,令l←l,并计算(li,li+1)←槇Th(li,ri).的算法如下.(2)更新从叶子结点l到根路径上的所有结点算法2.更新结点算法.forh=1toD-2doifi/2iseventhennh,i/2h=H(nh-1,i/2h-1‖nh-1,i/2h-1+1)xρ←nD-2,0‖nD-2,1rρ←MTHCol(αtst.add(xρ,rρ,Yt+1R.add(rρ)Y.add(Yt+1st.del(xρ,rρ,Ytendififi/2isoddthenxh,i/2h=(nh-1,i/2h-1‖nh-1,i/2h-1+1)rh,i/2h←MTHCol(αh,i/2ht,xh,i/2h,rh,i/2h,xh,i/2h,αh,i/2ht+1)R.add(rh,i/2h)Y.add(Yh,i/2ht+1)st.add(xh,i/2h,rh,i/2h,Yh,i/2ht+1)st.del(nh-1,i/2h-1,nh-1,i/2h-1+1,xh,i/2h,rh,i/2h,Yh,i/2ht)endifendfor4.4实时验证MtatVrfy(VK,i,l,aProof,γ)验证算法.(1)验证者计算ρ←ABE.decrypt(certA,pkI,γ).(2)验证算法计算(li,li+1)←槇Th(li,r),并按照以下算法,从h=2,…,D-2依次计算叶子结点nh,i/2h.Ifi/2h≡1mod2x←nh-1,i/2h-1‖nh-1,i/2h-1+1nh,i/2h←MTHY(x;rh,i/2h),withrh,i/2h∈RIfi/2h≡0mod2x←nh-1,i/2h-1-2‖nh-1,i/2h-1-1nh,i/2h←H(x)(3)验证者查询索引i并获得认证证据aProof=(aPath,R,Y),认证证据获得过程如下.forh=1toD-2doifi/2iseventhenforh=1toD-2aPath=aPath.add(nh,i/2h+1)R=R.add(Rh,i/2h+1)Y=Y.add(Rh,i/2h+1)endifaProof=(aPath,R,Y)endforoutput(aProof)(4)验证者通过ρ←MTHY(nD-2,0‖nD-2,1;rρ)(withrρ∈R)计算根结点ρ.如果ρ=ρ则叶子结点可以被认证,否则被拒绝.5AC-MTAT方案的安全性和效率分析5.1安全性证明5.1.1正确性分析定义5.如果对于任意一个可证安全的双陷门Hash函数和访问控制策略ω,IkeyGen生成算法生成密钥对(skI,vkI)←IkeyGen(1k),相对于任意的属性集合A,属性证书生成算法生成证书certA←CertIssue(skI,pkI,A),验证树根生成算法生成验证根γ←InitiRoot(pkI,root,ω),使得对于任意的l∈L和属性集合A,如果Aw,ρ←ABE.decrypt(certA,pkI,γ),ρ←MTHY(nD-2,0‖nD-2,1;rρ),可以输出{1}←MtatVrfy(VK,i,l,aProof,γ),则具有n个叶子结点的有效算法AC-MTAT=(MtatGen,IkeyGen,CertIssue,InitiRoot,Add_Leaf,Update_Leaf,MtatVrfy)是正确的.当客户端和服务器是可信的,方案的输出应该是ρ←MTHY(nD-2,0‖nD-2,1;rρ).具体地说,如果用户的属性集合A满足访问策略ω,则它可以通过查询的方式执行ρ←ABE.decrypt(certA,pkw)解密γ.然后,比较ρ和ρ,如果ρ=ρ,则叶子结点可以被认证,否则拒绝.因此方案的正确性依赖于单向的双陷门Hash函数和CP-ABE的全安全性.5.1.2可验证性分析AC-MTAT的安全性归约为未使用CP-ABE的双陷门Hash认证树(MTAT)的安全性和用于加密树根的CP-ABE算法的安全性.在AC-MTAT中,只有符合访问控制策略的用户才能够解析验证根γ,从中得到ρ后才能对结点数据进行验证.下面我们将AC-MTAT的可验证安全性与访问安全性分别Page8进行说明.在证明可验证安全性时,我们假设攻击者可以攻破CP-ABE的安全性,即攻击者可以通过ρ←Decrypt(γ,ω)获得ρ.因此,我们定义AC-MTAT是可验证安全的,如果AC-MTAT满足以下安全性质.(1)攻击者不能够改变MTAT的结构.(2)攻击者不能够改变树中叶子结点的序列.(3)攻击者不能替代任意一个叶子结点.(4)攻击者不能向MTAT中增加新叶子结点.攻击模型.下面通过定义一个挑战者和攻击者之间的交互式游戏GAC-MTAT以上属性,这里1k表示安全参数.本节定义的攻击模型建立在文献[27]定义的CAT安全模型的基础之上.挑战者生成一对密钥(SK,PK)并将公钥PK转发给攻击者.攻击者向挑战者随机发送z个叶子结点的值l1,…,lz(k),挑战者向攻击者返回叶子结点相应认证证据aProof1,…,aProofz(k).然后,攻击者通过输出一个位于树中某个特定位置的且尚未增加叶子结点处的叶子结点,来破坏MTAT的结构.更加形式化的描述如下:建立阶段:挑战者运行算法MtatGen(1k,D)计算出私钥SK和一个验证公钥VK.攻击者可以获得公钥VK.插入问询:这是一个随机过程,攻击者向挑战者发送一组叶子结点l∈L进行问询.挑战者随机选择一个数值r←{0,1}k并计算x←槇Th(l,r),然后运行算法(sk,i,aProof)←Add_Leaf(sk,l)并返回相应的(i,aProof)给攻击者.这里用Q··={(l1,1,aProof1),…,(lz(k),z(k),aProofz(k))}表示一串问询-应答序列对.另外将(l,r)记录到表T中.更新问询:这是一个随机过程.攻击者发送消息(i,ln)(1nz)向挑战者进行更新问询.攻击者随机选择数值r←{0,1}k,并计算x←槇Th(l,r),然后运行更新算法(sk,nPath,aProof)←Update_Leaf(sk,i,x)这里aProof=(aPath,R,Y),并向攻击者返回(i,aProof).这里用Q··={(l1,i,aProof1),…,(lz(k),i,aProofz(k))}表示一串问询-应答序列对.输出阶段:最后,如果攻击者能够输出下面任意一种类型的结果,则称攻击者赢得游戏.类型-1:攻击者输出xi,并且xi=xi,这里xi表示存储在MTAT中i处的初始值.类型-2:攻击者输出(l,i,aProof),1iz(k),(l,i,aProof)Q,并且MtatVrfy(vk,i,l,aProof)=1.类型-3:攻击者输出(l,i,aProof),z(k)in并且MtatVrfy(vk,i,l,aProof)=1.攻击者赢得上述游戏的概率定义为AdvAC-MTAT定义6.对于任意的z∈N,具有n个叶子结点的有效算法AC-MTAT=(MtatGen,IkeyGen,CertIssue,InitiRoot,Add_Leaf,Updata_Leaf,Mtat-Vrfy)是可验证安全的,若对任意的攻击者在多项式时间内赢得上述游戏的优势AdvAC-MTAT略的.定理1.如果H是抗碰撞Hash函数,槇TH是单向抗碰撞陷门Hash函数,MTH是一个满足定义1中安全属性的无密钥泄露的双陷门Hash函数,则AC-MTAT满足可验证性.证明.证明过程遵循文献[27]的证明过程.假设这里存在一个攻击者能够以不可忽略的概率赢得以上定义的游戏,则攻击者至少能够输出类型-1、类型-2或类型-3中的一种结果.类型-1:如果攻击者能够输出类型-1的结果,意味着这里存在一个关于叶子结点l的陷门碰撞,也就是说存在槇TH(li,ri)=xi=xi=槇TH(li,ri).然而这与假设槇TH是抗碰撞的相矛盾.当xi≠xi时,如果攻击者能够输出类型-2或类型-3的结果,意味着攻击着能够伪造位于i的叶子结点l的认证证据.下面,我们分别对这两种类型的伪造攻击进行详细讨论.类型-2:当攻击者输出类型-2的伪造,也就是说攻击者能够返回一个元组(l,i,aProof)且1iz.这意味者我们可以构建一个算法要么违背H的抗碰撞性,要么违背MTH的抗碰撞性.算法的操作过程如下.(1)建立阶段算法从{0,1}k中随机选择z个叶子结点l1,…,lz和z个字符串,并保存在表T中.算法运行算法(tk,hk)←THKeyGen(1k)生成一对陷门/Hash密钥并计算输出xi←槇Th(li;ri)(i=1,…,z).然后,算法随机选择一组哑结点ni←{0,1}len用于和z个叶子结点构造一棵深度为D=poly(k)的树并从底层叶子结点到顶部计算出树根值ρ.此外算法计算((l1,aProof1),…,(lz,aProofz))认证证据,设置公钥VK←(th,mhk,ρ)并基于公钥VK运行一个攻击者的黑盒模拟器.插入问询:每当攻击者希望将叶子结点l添加到树中时.攻击者随机选择一个新鲜值,计算并Page9i,aProof)←addLeaf(sk,x),并返回aProof=(aPath,i,r)给攻击者,并将(l,r)记录到表T中.(2)更新问询每当攻击者希望将位于ith的叶子结点l更新为l时.算法依照下面方式应答攻击者的(i,l)更新问询.首先算法运行求碰撞函数MTHCol,计算出MTH的一个碰撞值r←MTHCol(αt,l,r,l,αt+1),接着将位于ith的叶子结点l更新为l,r更新为r并保存一次性Hash密钥Yt+1.然后,算法运行认证证据生成算法(sk,i,aProof)←Add_Leaf(sk,l),更新叶子结点l的认证路径aPath上所有结点,并运行更新算法Update_Leaf(SK,VK,i,l),更新位于从叶子结点l到根路径nPath上结点信息.最后,算法返回认证证据aProof=(aPath,i,r,Yt+1)给攻击者.(3)输出阶段最后,算法返回(x,i,aProof),攻击者输出(l,i,aProof)Q(这里aProof=(aPath,R,Y),x←槇Th(l;r))后停止运行.由于攻击者运行在多项式时间内,所以算法是有效的.基于文献[27]的描述,这意味着存在一个Hash碰撞H(aPathi‖nPathi)=H(aPathi‖nPathi),或者一个陷门Hash碰撞MTH(aPathinPathi)=MTH(aPathi‖nPathi),这里nPath=(vD-2,i/2D-2).这与MTH或H是抗碰撞的相矛盾.V类型-3:当攻击者输出类型-3的伪造,也就是说攻击者能够返回一个元组(l,i,aProof)且z+1i2D.这意味着我们可以构建一个算法要么破坏MTH的抗一次碰撞性,要么破坏MTH的单向性.观察攻击者输出的响应认证路径,该路径上必然包含了一个这样的结点,该结点是lz结点的认证路径上的结点,且该结点必然是由双陷门Hash函数计算出的结点.而且更新问询并不能改变结点上原有的陷门Hash值.这样我们可以构建一个算法要么破坏MTH的单向性,要么破坏MTH的抗碰撞性或无密钥泄露性.下面描述如何构建算法的推导过程.(1)建立阶段算法运行一个黑盒模拟器并返回z个叶子结点l1,…,lz给攻击者.攻击者选择由双陷门Hash函数nHash结点.然后算法使用z个叶子结点和t个陷门Hash结点n1,…,npoly(k)的树并从底层叶子结点到顶部计算出树根值ρ.(2)插入问询每当攻击者希望将叶子结点l添加到树中时.算法从表T中恢复一对值(xi,ri),并计算陷门碰撞值r←MTHCol(mtk,l,r,l,Yt).算法返回aProof=(aPath,i,r)给攻击者.每当攻击者希望将位于ith的叶子结点l更新为l时.算法依照下面方式应答攻击者的(i,l)更新问询.首先算法运行求碰撞函数Col,计算出MTH的一个碰撞值r←MTHCol(αt,l,r,l,αt+1),接着将位于ith的叶子结点l更新为l,r更新为r并保存一次性Hash密钥Yt+1.然后,算法运行认证证据生成算法(sk,i,aProof)←Add_Leaf(sk,l),更新叶子结点l的认证路径aPath上所有结点,并运行更新算法更新位于从叶子结点l到根路径nPath上结点信息.最后,算法返回认证证据aProof=(aPath,i,r,Yt+1)给攻击者.(3)更新问询当攻击者向挑战者发送(i,l)希望更新ith处的叶子结点为l.算法从表T中恢复一组值(xi,ri,Yt)并计算无密钥泄露的双陷门Hash函数的一个碰撞值r←Col(Yt,l,r,l,Yt+1).然后,算法运行(sk,i,aProof)←Add_Leaf(sk,l),更新叶子结点l的认证路径aPath上所有结点,并将一次性Hash密钥Yt←Yt+1保存在表T中.最后将认证证据aProof=(aPath,i,r,Yt)返回给攻击者.(4)输出阶段最后攻击者输出(l,i,aProof)Q(这里aProof=(aPath,R,Y),x←槇Th(l;r)),z+1i2D且MtatVrfy(PK,i,l,aProof)=1后停止运行.我们观察攻击者的输出元组(l,i,aProof),这里aProof=(aPath,i,R,Y).设nPath=(v1,i/2,…,v的路径.因为z+1i2D,则结点n1,…,nnt中至少存在一个结点位于l的认证路径上.由于t是一个多项式,因此算法能够以不可以忽略的概率猜测出树中的索引序列.假设算法猜测的索引序列是正确的,则这里存在一个索引j使得nj=n意味着算法能够利用n对值(xPage10j,rj)=(xj,rj),则算法破坏了MTH的单向性,如r果(x撞性或无密钥泄露性.更进一步讲,假设攻击者能够以不可忽略的概率ε(k)赢得游戏,则算法能够以不可忽略的概率ε(k)/t获得成功.证毕.5.1.3访问安全性分析在AC-MTAT方案的证明中,仅满足访问策略的用户能够检测和验证数据流.在认证树的构造过程中,用户只有解密γ并获得证据后才能够验证外包数据流.我们假设从AC-MTAT获得的认证证据是正确的,则意味着当且仅当用户获得ρ后,才能够检测和验证外包数据流.因此通过在挑战者和攻击者之间建立一个交互式游戏GAccess以上过程.形式化描述过程如下:系统建立:挑战者运行算法IskeyGen(1k)生成私钥skI和一个验证密钥pkI.将pkI发送给攻击者,计算γ←Initialization(k,pkI,ρ,ω).查询阶段:这是一个随机过程,攻击者随机发送一系列询问ω1,ω2,…,ωq给挑战者,挑战者返回相应认证密钥certω1,…,certωq.挑战者计算ρi←Decrypt(certωi,γ)并将ρi返回给攻击者.将一组有序询问-应答对记作Ce··={(certω1,ρ1),…,(certωq,ρq)}.输出:最后攻击者输出一对(cert,ρ)和MTAT.Verify(auth,i,l,pk,ρ)=1后停止,则攻击者赢得游戏.我们定义攻击者赢得游戏的概率优势为A.定义7.如果对于任意的多项式时间攻击者advAccess赢得游戏的概率advAccess是访问安全的.定理2.如果AC-MTAT方案是可验证安全的并且CP-ABE方案是全安全的,则AC-MTAT满足访问安全性.证明.如果这里存在一个攻击者能够赢得A(1k),则这里要么存在一个攻击者能够以游戏GAccess不可忽略的概率破坏AC-MTAT的可验证安全性,要么存在一个攻击者能够以不可忽略的概率破坏CP-ABE的安全性.定理1证明了AC-MTAT满足可验证安全性.基于定理1的证明,如果CP-ABE是全安全的,则AC-MTAT满足访问安全性.这里存在一个攻击者以不可忽略的概率赢得游A则存在一个算法能够破坏CP-ABE的全戏GAccess安全性.系统建立:算法获得CP-ABE的公钥pkI.则算法通过运行Initialization(k,pkI,ρ,ω)和属性集合ω生成γ,这里ρ=DecryptABE(certA,γ),并发送(pkI,γ)给攻击者.查询阶段:当攻击者为属性Ai生成问询,这里Ai不满足ω,算法使用自己的随机预言机应答的问询.算法选择一个随机值t,并发送(t,ρ)给挑战者.收到应答C后,设置C为应答值.输出:最后,如果的输出是ρ和MTAT.Verify(aProof,i,l,pk,ρ)=1,则输出“1”,否则输出“0”.由于方案所基于的CP-ABE是全安全的,因此这里不存在一个攻击者能够以不可忽略的概率输出ρ.对于任意一个攻击者,我们可以得到Pr[GAccessA=1]negli(k),这里negli()表示可忽略的函数.5.2效率分析本方案的效率主要体现在Hash函数、双陷门Hash函数以及计算碰撞所需的时间和计算资源.基于属性的加密CP-ABE在方案中以黑盒形式出现,其效率取决于具体方案的使用,因此我们主要以Hash函数、无密钥泄露的双陷门Hash函数和计算碰撞的计算开销为衡量指标来分析本方案的效率,设Exp(H)表示计算Hash函数所需时间,Exp(MTH)表示计算无密钥泄露的双陷门Hash函数所需时间,Exp(Col)表示计算碰撞所需时间.我们的方案可以用任意一个双陷门Hash函数来初始化,但是为了便于分析比较,本方案采用一种基于离散对数假设安全的、无密钥泄露的双陷门Hash函数[2]对本方案进行实例化.与CAT中KR变色龙Hash函数一样,双陷门Hash函数同样支持Bellare等人[30]提出的批验证技术.首先从理论上分析算法在动态增加、更新和验证时的效率.具体分析如下:(1)数据流动态增加效率分析由于可以在相同根下对陷门Hash函数多次更新也是安全的,不存在密钥泄露的问题,由此,我们可以基于分期偿还机制在离线阶段构建一棵初始化认证树,初始化认证树构建的过程中,包含了构建认证树时最坏的情况,即向空树增加第1个结点时所需时间是最长的.因此,在在线阶段本方案的效率是高于CAT方案的.根据本方案的算法,当增加叶子结点时,分为两种情况.如果插入左叶子结点,所消耗时间不大于(D-3)Exp(H)+(D-2)Exp(MTH)+Page11Exp(Col);如果插入右叶子结点,所消耗时间不大于Exp(MTH)+Exp(Col).(2)数据流更新效率分析同理,对于叶子结点的更新也分为两种情况.如果更新左叶子结点,所消耗时间不大于(D-3)Exp(H)+Exp(Col);如果更新右叶子结点,所消耗时间为Exp(Col).CAT方案在数据更新时需要重新构建认证树和生成公钥,显然代价较高.(3)数据流验证效率分析验证过程中在不考虑访问控制的情况下,本方案与CAT方案的验证效率相同.在最坏情况下,验证者需要计算D次陷门Hash函数,即所消耗时间为D(Exp(MTH)).文献[2]中的无密钥泄露的陷门Hash函数同样支持Bellare等人[30]提出的批验证技术,从而大大降低计算的复杂度.接着,在以上分析的基础上,我们实现了AC-MTAT的一些主要算法来模拟AC-MTAT的工作过程.采用的硬件设备配置是IntelCorei5、内存4GB1600MHzDDR3RAM.代码采用JAVA1.6版本编写并基于Java安全数据包实现密码操作.我们通过实现双陷门Hash函数[2]和MD5Hash函数来实现认证树.如表1所示,我们进行了4组实验,每组实验分别对高度为10层、20层、40层和80层的认证树算法进行评估,每组实验的算法执行500次取平均值.第1组实验评估初始化认证树所耗费的平均时间,第2组实验分别评估在最好情况下和最坏情况下动态添加数据所需要的平均时间,第3组实验分别评估在最好情况下和最坏情况下实时更新数据所需要的平均时间,第4组实验分别评估在最好情况下和最坏情况下验证数据所需要的平均时间.评估结果如表1所示,说明我们的方案是有效的和可行的.建树层数(level)10307~137~2122~2620537~217~2931~32401018~387~4549~53801948~727~8682~83最后,我们对算法在处理大规模结点时的效率问题进一步分析和测试.分别测试了初始化认证算法、增加算法、更新算法和验证算法在不同建树层次下处理大规模数据的效率.如图3(a)所示,在系统初始化阶段,需要构建初始化认证树,其计算开销只与建树层次有关,随着建树层次的增加,初始化认证树的时间随之线性增加.在新结点加入时,图3(b)描述了不同建树层次下,新增结点数量对增加算法平均消耗时间的影响,实验数据表明随着建树层次的增加,增加算法的平均消耗时间略微增加,但是在同一层数下,增加结点的规模对增加算法的平均消耗时间影响较小,一直保持相对稳定,说明增加算法具有良好的稳定性.当更新结点时,图3(c)描述了建树层数与更新结点数量对更新算法平均消耗时间的影响,随着建树层次的增加,更新结点的平均时间增加量相当微小,表现出对建树层次良好的适应性.随着更新结点数的增加,更新时间几乎保持不变,表明更新算法在处理大规模数据更新时依然具有良好的性能.当对结点进行验证时,假设已通过属性证书获得验证根,图3(d)描述了建树层数与验证结点数量对验证算法平均消耗时间的影响,在验证过程中,建树层次决定了验证路径的长度,随着验证路径长度的增加,相应结点的验证时间也会随之线性增加.当认证树层数相同时,实验结果表明随着验证结点数量的增加,相应结点的平均验证时间也会线性增加,但增加的趋势越来越小,反应出验证算法在验证大规模数据时的优越性.5.3方案比较与现有典型方案相比,如表2所示,本方案在验证者的存储负荷、验证者的计算负荷、服务器的计算复杂度以及通信代价方面的复杂度均为O(logn).此外,在同一共享群中本方案可以实现基于属性的授权验证,既可避免私有验证带来的私钥泄露问题,又能防止公开验证带来的范围过大问题.通过引入双陷门Hash函数,实现了离线初始构建与在线实时更新相结合的动态可验证树,在未获得叶子节点时仍能构建初始可验证树,通过更新碰撞值无需重新计算全部节点信息即可完成可验证树的在线实时更新,在数据持续增长的同时叶子结点动态增加、验证路径动态生成、验证证据实时构建,实现了动态数据边读边写边验证.本方案支持对大批量数据流的高效动态更新.大批量数据流传输时必然会存在出错重传问题.现有方案中一旦出现被检验数据有错误的情形,则数据拥有者必须重传整个数据,而云计算服务提供商必须重新构建整棵验证树.本方案只需重传出错数据块并更新该数据块从叶子节点到根节点路径上的节点信息,动态更新的代价由O(2n-1)降低为O(logn-1).Page12图3平均消耗时间的比较表2方案的特性比较(狀代表叶子节点个数)方案CAT基于属性的授权验证××××√流√×××√实时验证√×××√离线预处理××××√动态更新的代价O(2n-1)O(2n-1)O(2n-1)O(2n-1)O(logn-1)验证者的存储负荷O(1)O(1)O(1)O(1)O(1)验证者的计算负荷O(logn)O(logn)O(logn)O(logn)O(logn)服务器的计算复杂度O(logn)O(logn)O(logn)O(n)O(logn)通信代价O(logn)O(logn)O(logn)O(logn)O(logn)6结束语本文构建了一种新颖的具有访问控制的外包数据流动态可验证方法,设计了离线初始构建与在线实时更新相结合的动态可验证树,分别利用Hash函数、双陷门Hash函数和CP-ABE算法构建可验证树的静态节点、动态节点与根节点,在未获得叶子节点时仍能构建初始可验证树,通过更新碰撞值无需重新计算全部节点信息即可完成可验证树的在线实时更新,在数据持续增长的同时叶子结点动态增加、验证路径动态生成、验证证据实时构建,实现了动态数据边读边写边验证,解决了云平台下外包数据流高效实时验证问题.
