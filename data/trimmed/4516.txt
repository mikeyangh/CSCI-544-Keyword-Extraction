Page1基于预测策略的动态多目标免疫优化算法刘若辰马亚娟张浪尚荣华(西安电子科技大学智能感知与图像理解教育部重点实验室西安710071)摘要为了有效解决动态多目标优化问题,文中提出了一种新的基于预测策略的动态多目标免疫优化算法.该算法首先采用相似性检测算子较好地检测到环境的变化.同时利用前几个时刻的最优非支配抗体解集建立新的预测模型来预测产生新时刻的初始抗体种群,进一步提高了算法对环境变化的反应能力.此外,通过引入基于两种不同的父代个体选择策略而改进的差分交叉算子来加快算法的收敛速度.文中采用几个典型的标准测试问题验证算法的有效性,实验结果表明,提出的相似性检测算子的预测模型可以提高算法的跟踪能力,而改进的差分交叉算子能够提高算法的收敛性能.关键词预测模型;差分进化;动态多目标优化;免疫优化算法1引言现实中的许多功能系统都是随时间或环境的变Page2开始关注动态多目标优化(DynamicMulti-objectiveOptimization,DMO)问题[5-7],但是到目前为止,相比较于动态单目标优化,关于解决DMO问题的有效的研究成果并不多.动态正交多目标进化的算法(DOMOEA)[8]采用一种正交设计方法,来提高在两个连续的环境变化中,进化种群对变化的适应能力.Goh和Tan[9]提出了一种新的协同进化的模式,即竞争与合作机制相结合,来处理静态多目标优化问题,同时该方法被扩展到处理动态多目标优化问题.该算法通过一种竞争与合作的相互迭代过程实现在特别时刻的优化需求下不同的子种群能够优化各个子目标,进而能有效处理静态和动态多目标优化问题.Wang等人[10]提出了一种新的动态多目标算法,在多目标问题的静态优化过程中,首先,将静态多目标优化问题转变成一个两目标优化问题,然后,设计了一种新的适用于环境变化的交叉和变异算子来提高算法优化多目标问题的能力.Koo等人[11]提出了一种应用于快速环境变化的动态多目标梯度算法(dMO-EGS),在该算法中,作者提出一种新的预测策略,这种预测策略不仅实现起来比较简单,而且能够使得产生的新时刻的解分布在Pareto最优解附近,进而改善了种群的收敛性.在动态多目标优化问题中,目标函数、约束条件函数和相关参数都可能会随着时间的变化而变化,真实Pareto前沿(ParetoFront,PF)和真实Pareto解集(ParetoSet,PS)的位置也会随着时间的变化而移动.因此动态多目标优化的目标是,在给定的计算代价内,能有效地追踪PF和PS的位置移动.这种动态特性要求,在下一次环境变化之前,算法要快速找到当前时刻的最优解集.如果将静态多目标优化算法直接用来解决动态多目标优化问题会有很多的局限性,例如,当环境变化时,静态多目标优化算法不能及时地对环境变化做出反应,不能适应新的环境,因而不能很好地追踪PF和PS的位置变化.动态多目标优化中有两个不同于静态多目标优化的关键问题,即如何检测环境变化以及如何应对环境变化.对于如何检测环境变化,目前常用的方法有两种,一种方法是直接利用上一时刻得到的Pareto最优解集来计算新时刻的目标函数值,如果目标函数值发生变化,则认为环境发生了改变;另一种做法类似文献[12]中的方法,从上一时刻的最优Pareto解集中选出一部分个体,计算它们在新时刻的目标函数值,如果目标函数值发生变化,则认为环境发生了改变.对于如何应对环境变化,主要在3个方面来应对:(1)在种群的历史信息保存方面;(2)在参数的自适应方面;(3)在种群的重新初始化方面.目前,第3个方面的研究,即在检测到环境变化时如何重新初始化种群,是研究的重点方向.当未检测到环境变化时,一般会直接利用上一时刻的Pareto最优解集作为新时刻的初始种群或者选择一部分Pareto最优解集进行高斯变异来作为新时刻的初始种群.而当检测到环境变化时,最简单最传统的方法是随机产生新时刻的种群,并重新开始静态多目标优化过程.Deb等人[13]对NSGA2进行了改进并将其应用于在线优化动态水热电力调动问题,该文中使用了两种初始化方法,一种是将前一时刻得到的最优解集的一部分重新随机初始化,另一种是对前一时刻Pareto最优解集的一部分进行高斯变异.这种基于历史Pareto最优解集来产生新时刻初始种群的方法,也称为基于记忆的方法.Wang等人[5]提出了几种基于记忆的动态多目标优化算法,实验结果表明基于记忆的策略对动态多目标优化问题是有效的.然而这种方法没有考虑环境变化的特点,如时间序列中一些特殊点或者是环境变化历史产生的PS位置之间的相互关系,因而算法对环境变化的反应能力是有限的.Hatzakis等人[14]提出了基于历史信息的前向预测方法,这种方法只用来预测新时刻的两个边界值点.而Zhou等人[12]用一种线性的预测模型来预测新时刻的全部初始解.本文中,我们利用历史最优Pareto解集,使用预测模型[12]来指导下一时刻种群的搜索.我们的方法和文献[12]的不同之处在于算法中用来检测环境是否发生变化的相似性检测(SimilarityDetection)算子.文献[12]是通过重新计算上一时刻的一些最优解在新时刻的函数值,来判断环境是否发生了改变,但是这种方法要求环境中没有噪声干扰,而本文使用这些函数值的统计平均信息来检测环境变化,能降低噪声的干扰.此外,当检测到环境变化时,在环境变化的初期,由于历史信息太少不能形成有效的预测模型,我们通过对前一时刻的Pareto最优解集进行高斯变异来得到新时刻的初始解.在环境变化的后期,由于历史信息丰富,可以根据历史最优PS解集的位置来有效地预测新时刻的最优PS位置,从而产生新时刻初始解的位置.实验结果表明,预测机制可以有效地提高算法对环境变化的反应能力以及收敛速度.Page3近年来,将免疫系统应用到动态优化问题上的方法逐渐引起了人们的关注,这是因为免疫系统有着对新威胁快速反应的自然特性以及免疫记忆在遇到抗原时有快速识别的能力.Shang等人[15]提出了一种基于非一致性变异算子的克隆选择算法(ICADMO)来处理DMO问题.非一致性变异算子将变异算子与进化代数相联系,在进化的早期,种群在一个较大范围内搜索以避免陷入局部最优,在进化的后期,进行局部搜索来帮助种群快速收敛.Zhang等人[16-17]提出了基于免疫系统的优化算法来解决决策空间或者目标空间的维数可能随时间改变的DMO问题,而且算法已经分别成功地应用于温室控制和信号仿真中.Zhang等人[18]提出了一种基于人工免疫系统的算法,来处理决策变量维数随时间变化的非线性约束多目标问题.在这个算法中,T模块利用历史信息来产生新环境的初始种群,B模块用来搜索一个给定的环境下的Pareto最优解,M模块用来临时存储非支配解来帮助产生下一个环境到来后的初始候选解.基于非支配邻域选择的静态多目标免疫优化算法(NNIA)[19],经过系统的比较和分析,发现对于静态多目标优化有很好的效果,本文将其改进,并扩展用于动态多目标优化问题.此外,我们加入了一个改进的差分交叉算子来提高算法的性能.不同于经典的差分进化算法,为了提高种群的多样性和收敛速度,避免算法陷入局部最优,在改进的差分交叉算子中,我们提出了两种选择父代抗体的策略来产生新的个体.实验结果表明,改进的差分交叉算子进一步提高了算法的收敛性能.2背景知识2.1动态多目标优化的定义本文中,我们处理如下的动态多目标优化问题[20]:s.t.x∈minF(x,t)=(f1(x,t),f2(x,t),…,fm(x,t))T烄烅烆其中,t=0,1,2,…表示时间,xRD表示决策空间,x=(x1,…,xl)∈RD表示决策变量.F:(X,t)→Rm组成了m个随着时间变化的实值目标函数fi(x,t),i=1,2,…,m,Rm代表目标空间.Farina等人[20]根据环境变化对最优PS位置和最优PF位置的影响,把DMO问题分为4种类型:第1类.随着环境变化,最优PS位置发生改变,最优PF位置不改变.第2类.随着环境变化,最优PS位置和最优PF位置都发生改变.第3类.随着环境变化,最优PS位置不改变,而最优PF位置发生改变.第4类.随着环境变化,最优PS位置和最优PF位置都不改变,但是优化的问题却在改变.虽然第4类情况在特定的情况下也会发生,但它通常被认为是平稳的或者静态的多目标优化问题,用一般的静态多目标优化算法就可以解决.在本文中,我们着重研究前3类常见问题.2.2预测模型当相似性检测算子检测到环境变化时,怎样利用种群的历史信息来预测新环境的最优PS的位置是所有预测模型的研究重心.本文中使用的预测模型[12]工作原理如下:假定当环境发生变化时,历史时刻记录的抗体Qt,…,Q1可以为预测(t+1)时刻的最优PS提供信息,则在某种意义上,(t+1)时刻的最优PS与历史时刻的抗体位置Qt,…,Q1存在函数关系:其中Qt+1表示(t+1)时刻的新的PS的位置.实际上,很多时间预测方法都可以用来估计函数F(·),假定x1,…,xt,xi∈Qi,i=1,…,t是一组可以表示最优PS移动动向的抗体,那么用来预测(t+1)时刻抗体初始位置的通用预测模型可以表示为式(3)表明,预测(t+1)时刻的一个新解xt+1时需要用到(t+1)时刻之前K个时刻的最优解(xt,xt-1,…,xt-K+1).其中当K=3时,预测模型的工作机制如图1所示.Page4一个启发式算法被用来识别储存抗体Q1,…,Qt之间的关系.对于t时刻的存储抗体Qt中的某个抗体xt,它在上个时刻,即(t-1)时刻的父代抗体xt-1可以被定义为存储抗体Qt-1中与其最相似的抗体,如果在种群中对于每一个抗体xt来说,其与上个时刻的最相似抗体xt-1构成时间序列后,可以采用一个简单的线性模型来预测下个时刻的抗体:然后对预测位置添加一个高斯噪声ε~N(0,犐δ),其中犐是单位矩阵,δ是标准差,那么通过之前构成的时间序列的均方误差就可以得到其中n表示决策向量的维数.2.3差分进化在连续区间的优化领域中,差分进化(DifferentialEvolution,DE)算法[21]是一种简单有效的进化算法.DE的主要过程是:首先在决策空间随机初始化种群X0=(X1,0,X2,0,…,XN,0),其中N为种群规模,然后利用种群间的个体差异对另外的个体进行扰动实现变异操作,接着进行交叉操作产生中间种群,当中间种群的个体适应度优于其对应的父代个体时,中间个体就被保留下来进入种群,否则,父代个体进入种群.设Xr1机选取的互不相同的3个个体,经差分变异后得变异个体Vi,t+1,即其中,F∈[0,2]是缩放因子.将变异个体的变量与种群中另外的父代个体变量按一定规则混合来产生新个体,该操作即为DE算法的交叉操作,设D是实变量的维数,则DE交叉操作可以表示为Uij,t+1=其中rand(j)是[0,1]之间的一个均匀分布随机数,jrand是随机产生一个[1,D]之间的自然数,CR∈[0,1]是变异概率.本文在提出的算法中引入改进的差分交叉算子来改进算法的性能.3基于预测策略的动态多目标免疫优化算法本文提出的算法的主要思想是:在新的时间环境刚到来之后,和处理动态多目标问题的一般策略不同,相似性检测被用来检测环境是否发生变化,然后利用提出的预测机制来产生新时刻的初始抗体,最后基于改进的差分交叉算子的NNIA算法来指导种群进化.下面分别详细介绍算法的各个步骤、具体流程以及改进的算子.3.1相似性检测和预测机制在动态优化过程中,种群需要及时知道环境是否发生了变化,以此来实施应对策略.相似性检测(SimilarityDetection)是用来判断环境是否发生改变的策略.环境检测通常有两种方法,其中一种方法是文献[12-13]中的方法:从父代种群中随机选择一部分解,并且对其进行评价,如果任何一个目标函数或者约束条件发生变化,就认为问题发生了变化.虽然这种方法简单、易于操作,但是它在函数评价时对环境中存在的噪声敏感,容易造成误判.因此,本文中,我们使用另一种更稳定的方法:基于种群统计信息的相似性检测算子[20],其表达式如下:ε(t)=其中,犚(t)=(r1,r2,…,rm)T是t时刻种群在各个目标函数取到的最大值向量,m为目标函数的个数,ri对应着在t时刻第i个目标函数在种群中取到的最大值;同样地,犝(t)=(u1,u2,…,um)T是t时刻种群在各个目标函数取到的最小值向量,ui对应着在t时刻第i个目标函数在种群中取到的最小值.Nδ是检测的目标种群的规模,当得到的相似值ε(t)大于给定的阈值δ,即ε(t)>δ时,我们认为系统中发生了显著的变化,利用时间序列中的历史时刻中最优PS的位置来预测新时刻最优PS的位置,然后在预测的新位置的周围生成新时刻的初始解.当检测到环境变化时,基于预测机制的重新初始化策略可以描述为如下.算法1.基于预测机制的重新初始化策略.输入:前两个时刻得到的非支配种群Qt-1(Gmax输出:t时刻的初始种群Qt(0)Page51.从Qt-1(Gmax计算出相似性检测算子ε(t)的值;2.当ε(t)的值大于阈值,即断定环境的变化是显著的时,如果t<3,转步3,否则,转步4;3.对非支配种群Qt-1(Gmax异,把变异后的Qt-1(Gmax和文献[5]中的算法对比,本文中设置变异个体比例为20%;4.用预测模型来预测新时刻最优PS的位置,然后在预测位置的周围产生新时刻的初始解.其中,Gmaxt开始环境变化时,由于储存的历史信息很少,不能有效地预测新时刻的最优PS位置,因此我们对前一时刻得到的最优PS进行高斯变异,作为新时刻的初始解.随着越来越多次的环境改变,历史信息存储越来越丰富,可以有效地预测新时刻的最优PS位置,则可利用预测模型来产生新时刻的初始种群.3.2基于预测模型的动态多目标免疫优化算法一般来说,任何的静态多目标优化算法加上动态环境处理技术都可以用来解决动态多目标优化问题.本文中,我们使用基于非支配邻域选择的静态多目标免疫优化算法(NNIA)作为算法的框架.改进的动态多目标优化算法(PSDMIO)的流程如下.算法2.PSDMIO算法流程.输入:非支配抗体群的最大规模nD,活性抗体群的规输出:每个时刻的Pareto最优解集1.随机初始化得到规模为nD的抗体种群P(0),评价P(0),得到非支配抗体种群B(0),按照拥挤距离排序,从中选择nA个构成活性抗体种群A(0),令t=0;2.若满足t=Tmax,输出每个环境状态下的最优PS:Q1,…,QT3.若t>0,基于预测机制得到初始种群Pt(0),进而得到非支配抗体种群Bt(0)和活性抗体种群At(0),令t时刻的进化代数g=0,转步4;否则,令t时刻的进化代数g=0,转步4;4.若g>Gmax群Bt(g+1)和活性抗体群At(g+1),转步8;5.对活性抗体群At(g)进行比例克隆得到克隆种群Ct(g);6.对克隆种群Ct(g)进行改进的差分交叉,然后进行多项式变异操作得到种群Ct(g);7.将Ct(g)和非支配抗体群Bt(g)合并,并从Ct(g)∪Bt(g)中找出非支配抗体群Bt(g+1)和活性抗体群At(g+1),令g=g+1,转步4;8.令t=t+1,转步2.在算法2中,我们可以认为在每一个环境状态下,即在每一个时刻t内,环境没有发生变化,此时的动态多目标优化问题可以看成是静态多目标优化问题.在免疫学中,克隆是通过无性繁殖来完成的,可以表述如下:其中,di(i=1,2,…,nA)是第i个活性抗体被克隆的个数,di=1表示抗体ai没有进行克隆增殖,ri表示活性抗体ai的拥挤距离归一化值.因式(10)采用的是ceil函数,克隆种群的规模有时会大于预先设定的值nc.然而,基于拥挤度的非支配抗体的删减策略可以保证非支配抗体种群规模不会大于nD,活性抗体种群的规模不会大于nA.作用在活性抗体种群的克隆操作算子C可以描述如下:C(a1,a2,…,anA{{a1,a1,…,a1烐烏以下介绍本文提出的算法中与NNIA不同的几个算子.3.3基于拥挤距离的非支配抗体删减机制在每个时刻的初始,相似性检测算子决定是否采用基于预测机制的重新初始化策略.在克隆算子之后,进行差分交叉算子和多项式变异操作,然后从合并种群Ct(g)∪Bt(g)中找出非支配抗体.当选出的非支配抗体的数目大于非支配种群规模的上限nD或者非支配抗体种群的规模nD大于活性抗体种群规模的最大值nA时,都是使用拥挤距离[22]来删减非支配抗体种群或者选择活性抗体的.在删减的过程中,我们采用动态删除的策略,即删除拥挤距离最小的前k个个体,如果非支配抗体的规模仍然大于标准的规模,重新计算抗体的拥挤距离,重复以上删除方法,直到非支配抗体的数目达到标准为止.3.4改进的差分交叉算子改进的差分交叉算子中,当选择父代抗体产生新抗体时,采用了一个混合选择机制,这个机制分为策略1和策略2.在每个新环境状态的进化初期,使用策略1,当进化代数达到预先设定值时,开始启用Page6策略2.两个选择策略中父代个体是从非支配种群和克隆种群中选出的,其中,非支配种群是由每代得到的非支配抗体组成的,然后对非支配种群进行删减,得到一定比例的、拥挤度相对较小的个体,即活性抗体,对活性抗体进行复制,得到克隆种群.Xr1是基本父代抗体,在两种选择策略中,都是随机从克隆种群中选择得到的,Xr2量的父代抗体.在选择策略1中,从非支配种群中随机选择Xr2中随机选择Xr2图2所示.选择过程表示如下:图2改进的差分交叉算子中用来产生新个体的父代个体的两种选择策略3.5算法复杂度分析算法复杂度是用来衡量算法实用性的重要标准之一.算法中决定了复杂度大小的参数有:最大环境改变次数,即允许的最大时间步数Tmax,t时刻当前的进化代数g和允许的最大迭代代数Gmaxt抗体群的最大规模nD,活性抗体群的规模nA,克隆种群的规模nc,每次动态删除的抗体数目k.由文献[22]中的分析可知,除去优化目标个数的影响,对于规模为n的种群,找出非支配抗体的计算复杂度为O(n2),对非支配抗体计算拥挤距离的PSDMIO算法一次迭代所需的最大复杂度如下:克隆算子的计算复杂度为O(nC),从Ct(g)∪Bt(g)找出支配抗体群Bt(g+1)的计算复杂度为O((nD+nC)2),抗体拥挤距离亲和度的计算复杂度为O(nDlog(nD)),更新非支配抗体群的最大的计算复杂度为O((nC/k)(nD+nC)log(nD+nC)).同时,从t=0时刻的初始化种群中找出非支配种群B(0)的计算复杂度为O(n2计算复杂度为O(n2O(n2(O(nC)+O(nDlog(nD))+O((nD+nC)2)+O((nC/k)(nD+nC)log(nD+nC)))Selection=其中,gen表示当前进化代数,gmax是t时刻允许的最大迭代代数.λ是控制选择压力因子,本文令λ=0.4.改进的差分算子有两个优势:(1)由于基本父代抗体Xr1群中的抗体都是拥挤度较小的非支配抗体,这就保证了最优解的分布性质量和算法的收敛速度;(2)因为在进化的初期,我们没有用克隆种群产生差分向量,这样可以保证种群的多样性,使算法避免陷入局部最优.在本文中,令k等于nc,根据算子O的计算规则,上式简化结果为上式表明,算法的计算复杂度主要集中在计算非支配抗体上.在后面的实验中,我们给出了算法具体的运行时间.4实验与结果4.1测试函数本文中,我们测试了4个不同的问题,DMOP1[20]属于第1类问题(真实PS位置随时间变化,真实PF位置不随时间变化),DMOP2[9]属于第3类问题(真实PS位置不随时间变化,真实PF位置随时间变化),DMOP3[9]属于第2类问题(真实PS位置和PF位置都随时间变化),DMOP4[20]属于第1类问题(真实PS位置随时间变化,真实PF位置不随时间变化).其中,前三个问题是两目标优化问题,最后一个问题是三目标优化问题.这4个测试函数的数学表达式如表1所示.4个问题随时间变化的真实PS位置和真实PF位置如图3所示.Page7测试问题DMOP1DMOP2DMOP3DMOP4表1DMO问题j,H=1.25+0.75·sin(πt/2nT),H=1.25+0.75·sin(πt/2nT(xj-G(t))2,G=sin(πt/2nT图34个动态多目标优化问题的真实PSs位置和PFs位置4.2评价指标在本文的实验研究中,我们用了反代距离IGD(InvertedGenerationDistance)[23]、两个解集的收敛比较指标CTS(CoverageofTwoSets)[6]和间距S(Spacing)[24]3个评价指标来反映算法的性能.反代距离.反代距离指征解集的收敛性.一般而言,代距离越小,表明该算法所得到的解集收敛性越好,越接近于真实的PF.令P表示真实的PF上均匀分布的点的集合,A是算法得到的近似的PF点的集合,则P到A的反代距离IGD可以表示为)其中d(A,v)是指P中某个个体到A中所有个体的欧式距离中的最小取值.若IGDt表示第t时刻的反代距离值,则所有时刻的平均反代距离可以表示成如下的形式:其中,Tmax是最大的时间步数.Page8收敛比较指标.收敛比较指标代表一个算法与另一个算法的性能比较情况.令A和B分别表示两种算法得到的近似Pareto最优解集,函数CTS(A,B)将(A,B)之间的收敛关系映射到[0,1]:CTS(A,B)其中,表示支配或者相等(也叫弱支配),CTS(A,B)=1表示B的所有决策向量都被A弱支配,即A解集优于B解集;CTS(A,B)=0表示B中没有决策向量被A弱支配,即B解集优于A解集.特别要注意收敛比较指标的比较方向,因为CTS(A,B)的值不一定等于1-CTS(B,A).若CTSt表示第t时刻算法的CTS指标值,则所有时刻的平均CTS指标可以表示成如下的形式:间距.间距指征解集的均匀性.一般而言,间距越小,表明该算法所得到的解集在目标空间越接近等间距分布.令A代表算法得到的近似的PF点,间距指标S定义为其中,di=min∑i,j=1,2,…,A),珚d是所有di的平均值,k表示目标函数的个数.若St表示第t时刻算法的间距指标,则所有时刻的平均的间距指标可以表示成如下的形式:图45个算法对于DMOP1在t=0,1,2,…,9时得到的非支配解集4.3PSDMIO与其他4个动态多目标算法的实验比较为了验证提出的PSDMIO算法的性能,我们将它与其他4个动态多目标优化算法进行比较.第1个对比算法是由文献[12]中提出,文中把静态多目标优化算法RE-MEDA[12]和3种动态环境预测机制结合起来处理动态多目标优化问题,并且通过实验证明了,混合重新初始化方法的性能最优.这种混合重新初始化方法为,当检测出环境变化后,新时刻的初始种群的50%个体是通过对上一时刻得到的Pareto最优解进行高斯变异得到的,剩余50%个体是通过预测模型得到的.混合重新初始化策略与RE-MEDA算法相结合的算法,称为PVRE-MEDA,即本节中的对比算法之一,其余3个对比算法分别为DNSGA2-A[13],DNSGA2-B[13]和ICADMO[15].对于这5个算法,为了保证它们在第0时刻的收敛性,我们设置第0个时刻的进化代数Gmax0=100,其余时刻Gmaxt=50,最大时间步数Tmax=30,PSDMIO,DNSGA2-A,DNSGA2-B和ICADMO的种群规模N都是100.RVRE-MEDA中,LPCA训练的最大步数T=50,聚类类别数Kc=5,交叉概率pc=1,变异概率pm=1/n,其中,n表示决策空间的维数;DNSGA2-A和DNSGA2-B中的交叉概率pc和变异概率pm与RVRE-MEDA设置相同;ICADMO中的克隆比例是3;PSDMIO的参数:nD=nc=100,nA=20,nT=10,差分算子中的参数设置为F=0.5,CR=0.1.Page9图55个算法对于DMOP2在t=11,13,15,…,29时得到的非支配解集图65个算法对于DMOP3在t=11,13,15,…,29时得到的非支配解集4.3.15个算法得到的非支配解集的分布情况图4~图7为5个算法在4个问题上得到的非支配解集.在图4~图6中,黑线代表真实的Pareto面,图7中,灰色的面代表真实的Pareto面.黑色的点表示算法得到的近似Pareto最优解.为了可视化,在图4~图7中,我们从算法得到的Pareto最优解中选择拥挤度最小的30个解来画图.DMOP1的真实Pareto面不随时间变化,在图3中,我们对每个时刻的目标函数值f1和f2进行了平移,即(f1+t/20,f2+t/20),t表示第t时刻.对于DMOP1问题,从图4可以看出,PSDMIO得到的非支配解集最接近真实的Pareto面,而且解的分布相对比较均匀.PVRE-MEDA在t=2,3,4时收敛性不好,之后的收敛性有所改善.DNSGA2-A和DNSGA2-B解的逼近程度相似,略次于PSDMIO.ICADMO得到的非支配解的分布效果最差,在前几个时刻,甚至找不到真实的Pareto面.对于DMOP2问题,此问题的真实PS是不随时间变化的,从图5可以看出,5个算法得到的非支配解与真实Pareto前沿的逼近程度基本差不多,但是PVRE-MEDA和DNSGA2-A在点(0,1)附近收敛的不好.对于DMOP3问题,从图6中可以看出,PSDMIO得到的非支配解的逼近程度最好,均匀性相对较好.PVRE-MEDA中,点(0,1)处收敛不好.DNSGA2-A和DNSGA2-B的性能略次于PSDMIO,ICADMO的性能最差,在大多数时刻不能及时的跟踪到ParetoPage10图75个算法对于DMOP4在t=14,19,24,29时得到的非支配解集前沿的移动.对于DMOP4问题,从图7我们可以看出,PSDMIO和ICADMO得到的非支配解的逼近程度差不多,比其他3个算法相对较好,PSDMIO解的均匀性相对较好.DNSGA2-A和DNSGA2-B得到的解的逼近性和均匀性都相当.ICADMO在此问题中收敛性表现最差,许多点偏离真实Pareto面较远.综合上面对4个问题所得到的非支配解集结果的分析,可以清楚地看出,PSDMIO在4个问题上解的质量是最好的,相比其他4个算法,解的均匀性也较好.PVRE-MEDA在DMOP1的前几个时刻收敛不好,对于DMOP2和DMOP3问题在点(0,1)处的收敛性不好,在DMOP4上的收敛性能最差.DNSGA2-A和DNSGA2-B的性能很接近,在DMOP1和DMOP3上解的质量优于PVRE-MEDA和ICADMO,在DMOP2上DNSGA2-B和ICADMO接近,比DNSGA2-A收敛性更好.ICADMO除了在DMOP2上优于PVRE-MEDA和DNSGA2-A,在DMOP4问题上优于PVRE-MEDA、DNSGA2-A和DNSGA2-B之外,在另外两个问题上的性能很差,所以该算法十分不稳定.4.3.25个算法的IGD跟踪情况和性能盒图[25]本小节中,为了将实验的图表示得更为清晰,我们对5个算法进行了编号,如表2所示.图8是5个算法在4个问题上的IGD跟踪曲线图.从图8可以看出,对于DMOP1问题,PSDMIO的IGD跟踪性能最好,PVRE-MEDA的跟踪性能仅次于PSDMIO,DNSGA2-A和DNSGA2-B的跟踪性能很相近且差于PVRE-MEDA,ICADMO的跟踪性能最差;在0<t<3时,进化初期历史信息不足,不能形成预测模型,但PSDMIO的跟踪性能还是最好的,随着进化的进行,历史信息逐渐积累,可以形成预测模型,PSDMIO的IGD跟踪优势变得越来越明显.对于DMOP2问题,在0<t<7时,PSDMIO的IGD跟踪曲线波动有点大,说明算法对环境变化敏感,虽然在进化的初期,其IGD值大于DNSGA2-A和DNSGA2-B的IGD值,但是PSDMIO有很快的收敛速度,在给定的迭代代数内,最终得到的IGD值依然是最好的;在t>7时,PSDMIO的性能最好.DNSGA2-A和DNSGA2-B的总体跟踪性能仅次于PSDMIO,PVRE-MEDA的IGD跟踪曲线成一个平稳的波动状态.ICADMO在进化初期表现不好,后期的IGD跟踪性能有所改善.对于DMOP3问题,所有算法的表现和在DMOP1问题上的表现相似,但是在绝大多数时刻,PSDMIO的跟踪性能都是最好的.ICADMO直到最后几个时刻才优于PVRE-MEDA,而且在前面时刻IGD指标值和其他算法差距很大.对于DMOP4问题,在整个进化过程中,PSDMIO的IGD跟踪性能一直是最好的,ICADMO的性能Page11图85个算法的IGD跟踪曲线次之,PVRE-MEDA跟踪性能最差.从IGD指标跟踪图的分析中,我们可以看到IGD值和前面的非支配解集的分布图基本是一致的,由此我们也可以看出PSDMIO的性能是最好的,也是稳定的.图9是5个算法的20次独立运行的IGD、CTS和珚S性能盒图比较.就IGD指标来说,PSDMIO在4个测试函数上的表现都是最好的,而且有明显的性能优势.PVRE-MEDA的性能在DMOP1、DMOP2和DMOP3上仅次于PSDMIO,在DMOP3上的表现最差;DNSGA2-A和DNSGA2-B这2个算法性能相当,且居于第三;ICADMO在DMOP1、DMOP2和DMOP3上的性能都是最差的,在DMOP3上的性能仅次于PSDMIO.就CTS指标来说,从图9可以看出,PSDMIO得到的非支配解集支配在所有问题上都支配其他的算法得到的非支配解集,也就是说,PSDMIO算法得到的Pareto最优解最逼近于真实的Pareto前沿.就珚S指标来说,PSDMIO算法对于4个测试函数得到的解集的均匀性是最好的.PVRE-MEDA对于DMOP1、DMOP2和DMOP3得到的解集的均匀性略次于PSDMIO,而对于DMOP4的解集的均匀性最差;DNSGA2-A和DNSGA2-B这2个算法的解集的均匀性位居第三;ICADMO对于前3个测试函数的解集的均匀性都是最差的,而对于DMOP4的解集的均匀性仅次于PSDMIO.总之,PSDMIO算法在IGD的跟踪上,除了DMOP2问题,在其他测试问题上,算法的性能都是最好的,对于DMOP2,算法在前几个时刻对环境的变化比较敏感,说明PSDMIO在处理真实PS不随时间变化而PF随时间变化的多目标问题时还需要改进,但进化一定代数之后解集的收敛性依然最好;此外,PSDMIO算法在IGD、CTS和珚S这3个指标上都展现了最好的性能.4.4PSDMIO算法里算子和参数的研究本节中,我们将讨论预测机制、改进的差分交叉算子两个机制对算法性能的影响.另外,也将讨论两个主要参数对PSDMIO算法性能的影响:相似性检测中,用于检测环境是否变化的ε(t)的阈值δ,以及每个时刻允许进化的最大代数Gmaxt.4.4.1预测机制和改进的差分交叉算子对算法性本小节的实验参数设置和第4.3节的设置一致.就预测机制来说,从图10和图11可以清楚地看到,对于DMOP1、DMOP3和DMOP4,预测机制使算法在动态环境中得到的解集对IGD跟踪能力Page12图95个算法的性能盒图,第1列为IGD盒图;第2列为CTS盒图;第3列为珚S盒图大大增强.而对于DMOP2,预测机制基本无效,这也许是因为DMOP2的真实PS位置是不随时间变化的,新环境来到后,继续在上一时刻的最优PS位置上进行搜索会加速新时刻下算法的收敛速度,而通过预测机制产生的新时刻的初始解分布在上一时刻最优PS位置的周围,不能在上个时刻进化的基础上继续进化,要耽误一些迭代次数,因而对DMOP2这一类测试函数,预测机制会使算法的跟踪性能和收敛速度有一定程度的减弱.就改进的差分交叉算子来说,从图10可以看到,在每个时刻中的最后一代,基于改进的差分交叉算子的算法得到的解集的IGD指标最小,算法的收敛性更好,从而可以证明,差分交叉算子加快了算法的收敛速度.我们从图11可以看出,在4个测试问题上,DE交叉算子的加入,均能使算法的覆盖率更好,算法得到的近似PS更逼近于真实值,进一步证明了改进的差分交叉算子可以提高算法的收敛速度.4.4.2检测环境变化的阈值δ本实验我们令环境检测的阈值δ的范围为[0.01,0.1],观察算法20次独立运行的IGD指标值和环境检测阈值δ之间的关系.从4.3节的实验,我们已经知道,PSDMIO对于DMOP1、DMOP2和DMOP3这3个测试函数的性能相似,因此本文只给出了DMOP1和DMOP2的IGD指标和环境检测阈值δ的关系曲线图,如图12所示.从图12我们可以看到,对于DMOP1问题,除Page13图10PSDMIO与在其框架下不使用预测策略或者改进的差分交叉算子的算法得到的IGD跟踪的比较(图中1表示PSDMIO,2表示不加预测策略的算法,3表示使用SBX而不使用DE的算法)图11PSDMIO与在其框架下不使用预测机制或者改进的差分交叉算子的算法CTS比较(图中1表示PSDMIO,2表示不加预测机制的算法,3表示使用SBX而不使用DE的算法)Page14图12IGD随检测环境阈值δ的变化曲线了当δ取值为0.07时,IGD的值相对较大外,算法性能相对较弱,而δ的取值从0.01到0.1变化时,IGD总体上有增大的趋势,但是变化比较缓慢.因此,对于DMOP1这类测试函数,我们建议δ的取值范围为[0.01,0.05].对于DMOP2函数,随着δ的增大,IGD有变小的趋势,从图12中可以看出,δ从0.05之后,IGD的值波动不是很大,因此对于DMOP2这类测试函数,我们建议δ的范围为[0.05,0.10].4.4.3每个时刻允许进化的最大代数Gmaxt本实验中,和4.3.2节中一样,1表示PSDMIO,2表示PVRE-MEDA,3表示DNSGA2-A,4表示DNSGA2-B,5表示ICADMO.只有Gmaxt余参数设置与4.3节一样.图13是算法独立运行20次得到的IGD指标值与Gmaxt是不同Gmaxt的时间.本文运行的平台是Matlab7.0.1,电脑配置:Intel(R)Core(TM)2CPU(2.33GHz,2GB,RAM).从图13可以看出,对于4个测试问题,在每个时刻下,允许迭代的最大代数GmaxtPSDMIO的性能始终都是最好的,而且随着Gmaxt值的增大,PSDMIO得到的IGD指标曲线平稳下降,即使Gmaxt化.PVRE-MEDA在DMOP1和DMOP3函数上的的变化曲线tPage15性能仅次于PSDMIO,但对于DMOP2和DMOP4函数,算法在Gmaxt>40时表现最差.DNSGA2-A和DNSGA2-B这2个算法在DMOP1和DMOP3上性能都居于第三,对于DMOP2函数,除Gmaxt=50外,Gmaxt10203040506070从表3可以看出,DNSGA2-A和DNSGA2-B耗时最长,PSDMIO和PVRE-MEDA,ICADMO在取值变化的情况下基本耗时相同,而且远小于GmaxtDNSGA2-A和DNSGA2-B.动态多目标优化问题的算法运行时间也是衡量算法性能的重要标准之一,PSDMIO算法能够在保证算法性能的前提下,在运行时间上也达到较好的水平.4.5PSDMIO的预测机制和其他预测机制的比较在这一部分中,我们对PSDMIO的预测机制进行了修改,换成了文献[26]的预测机制,相应的算法起名为PSDMIO-SBM,用以说明预测机制的特点,以及算法的可以改进之处.在PSDMIO-SBM中,除图14PSDMIO算法和PSDMIO-SBM算法的IGD跟踪比较其余性能都是仅次于PSDMIO,对于DMOP4问题,当Gmaxt<40时,算法的跟踪性能最差,之后的性能有一点改善.ICADMO在DMOP1和DMOP3问题上表现最差,在DMOP3问题上性能仅次于PSDMIO.下的算法运行时间狋DNSGA2-A了预测机制不同以外,其他算子都和PSDMIO的算子一样,然后我们将PSDMIO-SBM得到的结果和文中所提出的算法得到的结果进行了比较.从原理上看,SBM需要记录多个时刻的Pareto最优解,消耗了存储空间,但是选择的是具有代表性的子问题,均匀性得到了很好的保持.两个算法的IGD跟踪性能的比较如图14所示.从图14可以看出,两种预测机制各有优势和劣势,对于问题2和问题4,SBM的预测机制取得的结果更好一些,对于问题1和问题3,两种预测机制在不同的时刻各有优势,说明本文的算法在预测机制上是很有效的,在以后的工作中,可以进一步改进.Page165结论本文中,我们提出了一种新的动态多目标免疫优化算法(PSDMIO).算法中引入了两种算子,包括预测机制和改进的差分交叉算子.实验结果证明,预测机制可以提高算法对环境改变的适应能力和收敛速度,而改进的差分交叉算子又能进一步提高算法的收敛速度.从实验结果分析中可以看出,PSDMIO算法在处理传统的动态多目标优化问题上是有优势的.然而,我们也知道动态多目标优化问题的类型是多种多样的,场景变化也是十分复杂的,所以PSDMIO算法是依赖于目标问题的种类和属性的.当PSDMIO应用于前两种类型的动态多目标优化问题时,即真实PS随时间变化而PF不随时间变化的动态多目标优化问题,或者真实PS和PF都随时间变化的动态多目标优化问题时,PSDMIO算法的性能是很好的,尤其当动态多目标优化问题的真实PS随时间呈现线性变化趋势的时候,PSDMIO的优势明显,但是当处理第三种类型的动态多目标优化问题,即真实PS不随时间变化而PF随时间变化的动态多目标优化问题时,由于预测模型是失效的,PSDMIO算法的性能不是很理想,还有待改进.如何改进算法,将算法应用于更多的场景,是我们下一步研究的首要任务.此外,将提出的算法应用到其他的DMO问题以及实际问题中也是我们下一步工作的内容.
