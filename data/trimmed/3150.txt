Page1SPQ:数据流上面向可伸缩模式的查询方法李菲菲李红燕曲强苗高杉(北京大学信息科学技术学院北京100871)(北京大学机器感知与智能教育部重点实验室北京100871)摘要数据流的模式查询具有很高的领域价值,它不仅需要较高的抗噪能力和实时性,而且查询目标模式还具有可伸缩性,即由多个子模式复合而成,且某些子模式可重复、缺失或倒置.文中提出一种可伸缩模式的查询(SPQ)方法,允许用户定义目标模式并设置可伸缩条件.然后在查询处理中通过模式匹配生成模式流,进而完成满足可伸缩条件的目标模式查询.在真实数据集上进行的实验从查全率、查准率和处理效率上证明了SPQ方法是可行和灵活的.关键词数据流;查询;可伸缩模式;目标模式;查询重写;查询处理1引言数据流的应用愈发广泛和深入,为了在数据流上获取关注的信息,用户可以根据需求设置相应的Page2在实际应用中,用户根据需求设置不同的查询,并允许查询内部的某些部分重复或缺失.这给数据流上的查询处理方法带来了很多挑战.为了满足日益复杂的查询需求,数据流上的查询应该具备以下特点:(1)查询粒度较大,语义丰富.多数的传统数据库查询技术关注元组(tuples).在数据流领域一些查询也基于元组.这种由数据流上连续数据点组成的模式具有更丰富的语义,其变化可以体现用户关心的变化趋势.如金融数据流中的Zigzag模式;又如图1所示的医疗数据流监控中图2查询目标模式的可伸缩性表达丰富语义为了更加灵活地表达目标模式的可伸缩性,需要寻求一种即席查询(adhocquery)的方法.(3)抵抗无规律噪声的干扰.现实环境中往往会有噪声的干扰.如医疗监测中病人的动作会触动传感器产生干扰数据.又如图3所示民用用电量曲线,突然的跳闸也是无法预知建模的.在一定程度的噪声下,要求算法可以较好地执行,并返回满足需求的查询结果.(4)查询处理满足实时性要求.以心电监护仪为例,其工作频率是500Hz,每小时产生1800000条数据,一天的记录数将达到43GB/台.巨大的数据量使得只能对数据流进行单遍扫描,需要实时地进行查询处理.的心电图(Electrocardiograph,ECG):一个完整的ECG周期由P模式、QRS模式、T模式、U模式组成,反映了心脏跳动周期中的不同阶段.如P模式因心脏除极而产生,其变化决定了心房肥大的状况.(2)查询目标模式具有可伸缩性.在线的数据流往往会无法预知地重复和缺失某些部分.因此查询目标模式应具有可伸缩性,即是由多个子模式复合而成的复杂模式.此处的可伸缩性指在保持时序关系的前提下,允许内部某些子模式重复、缺失,抑或是波形倒置.以医疗数据流监测领域为例,如图2(a)所示,QRS模式和T模式周期性交替可能预示着肺部严重感染的产生.又如P模式缺失,T模式出现多次可能会导致急性肾功能衰竭(图2(b));心肌损害常由U模式多次出现预示(图2(c));若T模式出现波形倒置(shapeinversed),可能预示着有甲状腺功能减退性心脏病的危险(图2(d)).以上是数据流上的查询应具备的一些特点.本文的研究重点是为用户提供数据流上灵活、方便的模式查询处理机制,提出了数据流上可伸缩模式的Page3查询(SPQ)方法.SPQ方法允许用户根据查询需求定义目标模式并设置可伸缩条件.为了避免匹配二义性生成基模式覆盖,并对目标模式进行查询重写形成SPQ.进而通过模式匹配形成模式流.在模式流上的查询处理中,尽可能复用已处理结果来提高查询效率.本文第2节简述相关研究;第3节介绍整体架构;第4节详述可伸缩模式查询表示;第5节描述可伸缩模式查询处理;第6节通过实验来分析方法的性能;第7节总结全文并展望下一步的方向.2相关研究近年来有关数据流的研究受到了学术界和工业界很多关注.与本文相关的工作大致可分为以下两类.2.1可伸缩模式匹配一类与本文相关的研究是可伸缩模式匹配.从技术上讲,大致分为基于时序数据库的模式匹配、基于树的模式匹配和基于图的模式匹配这3类.第1种是基于时序数据库的可伸缩模式匹配方法.代表有Kahveci的多长度索引结构MR方法[1]和Kaghazian等人提出的RSPS方法[2].前者的方法提出MR索引结构存储不同处理长度的数据信息,将查询切分成对应于MR的多个子查询并分别执行.针对每个处理层面维护一个索引,空间复杂度较高,对数据库中的全部数据建立索引,时间复杂度为O(nt).将这种方法应用到数据流领域是不现实的.该方法中的可伸缩是查询长度可变,而非由某些部分重复或缺失导致的查询模式改变,故与本文中的可伸缩模式不同.RSPS方法支持使用SQL表达可伸缩模式,即部分增加或缺失的复杂模式,并受KMP算法启发计算shift(j)和next(j)来发现元素间的内在联系,减少对相同数据的多次扫描.RSPS虽然减少了扫描次数,但计算和存储转移信息消耗较大,为O(m2).由于数据流只是一遍流过,故该方法并不能很好地应用于数据流领域.第2种是基于树的可伸缩模式匹配方法.Mei和Madden提出的复合事件处理模型ZStream[3]是其代表.它将查询操作封装为事件操作符,支持可伸缩模式的查询,使用基于树的查询计划表示查询模式,利用代价模型评估最优计划.但ZStream以事件为粒度,其处理对象是由数据源直接产生的,不支持其内部细分,因此无法处理事件间的包含关系.对应到数据流的可伸缩模式处理,则无法解决SPQ中目标模式内部各子模式间的相似性包含问题.这是因为SPQ以基模式为粒度,比事件的粒度要细.基模式不是数据源直接产生的,是由用户划分、后台处理而得的.另外,ZStream的树结构存储也带来额外的维护代价.第3种是基于图的可伸缩模式匹配方法.NFA是很典型的方法.由于转移状态不确定,匹配不成功时会产生大量回溯,因此传统的NFA方法是离线的.为了提高效率,改进方法[4-7]逐步产生,其中一些还被应用于事件流领域,支持可伸缩模式查询.改进主要是减少回溯[4-6]和引入并行处理[7].Agrawal提出了NFAb的方法[5],引入singleton和栈进行可伸缩模式匹配.每次只处理一个执行过程称之为sin-gleton,此过程一直执行直至singleton匹配成功或失败,其间产生的其它匹配分支点均存入栈中.当匹配失败时,从栈中弹出最近的分支点作为新的sin-gleton进行匹配.此方法也是以直接产生于数据源的事件为粒度,未处理事件间的包含关系.另外当模式比较复杂时,其分支点会比较多,使得匹配次数增加.另一类方法是将NFA转换为多个较小的NFA或者对应的DFA后采用并行处理的方法.但是此方法会随着查询模式的复杂性增加而形成大量的NFA或DFA,其效率很大程度上取决于查询目标模式的复杂程度.2.2数据流管理系统(DSMS)中的查询处理很多查询处理技术被用来实现数据流管理系统(DataStreamManagementSystem,DSMS).比较著名的如STREAM系统[8]、TelegraphCQ[9]、Au-rora系统[10]、Cougar项目[11]、Hancock项目[12]等.DSMS大都着眼于在近似实时的前提下,完成对数据流的预定义查询.但其查询粒度是元组,不支持模式的整体查询.正如Papadimitriou等人所述,这些系统的共同缺陷在于仅着眼于在数据流上完成传统的查询,没有去寻找数据的特征,更无法完成数据流上的模式查询[13].3整体架构图4展示了可伸缩模式查询的整体框架.主要由查询表示和查询处理两阶段组成.在查询表示中,用户通过图形用户界面在原始数据流上选择并定义查询目标模式,设置相应的可伸缩条件;根据目标模式,通过基模式生成器生成基模式字典和基模式覆Page4盖;进而查询重写模块以基模式为粒度,将目标模式转为可伸缩模式.在查询处理中,基于基模式的匹配模块将不断到达的数据点与基模式并行比较,从而生成模式流;把可伸缩模式查询应用于模式流,通过图4可伸缩模式查询整体架构4可伸缩模式查询表示用户首先根据查询需求设定模式和相应的可伸缩条件,形成目标模式;为避免子模式间的相互包含关系导致的匹配二义性,引入基模式和基模式覆盖;进而基于基模式对目标模式进行查询重写,生成SPQ.4.1目标模式本文为用户提供一种即席查询的机制.允许他们结合领域知识和关注重点,选择富含语义的子模可伸缩模式查询执行器完成查询处理;将结果通过查询结果展示模块以标记数据流的方式返回给用户.式并设置相应的可伸缩条件,从而给定查询目标模式.这种方法提高了模式查询的灵活性,更好地考虑了用户的经验和需求.但是用户直接选择的模式可能会出现如图5所示的子模式间部分重叠的情况.Page5它会带来二义性,例如用户希望查询子模式i出现3次,且子模式j不出现的情况,那么将无法判断图5的重叠部分究竟是重复出现3次还是缺失.因此本文涉及的查询目标模式内部的各子模式间不允许重叠,即它们是不重叠模式,如定义2所示.定义1.数据流.令S代表数据流,其中Xi表示时间戳为ti时的数据值,1in,则S可以如下表示:S=X1,t()1,X2,t()2,…,Xi,t()i,…,Xn,t(){定义2.不重叠模式.令pi表示第i个子模式.不重叠模式具有如下特征:1im,1hm,i≠h,子模式pi和ph满足tiki<th1或thkh<ti1条件,其中pi=Xi1,ti()1,Xi2,ti()2,…,Xiki,tik()ph=Xh1,th()1,Xh2,th()2,…,Xhkh,thk()用户设定不重叠模式后,根据查询需求为其设置相应的可伸缩条件(见表1),进而形成目标模式,用以灵活地表达丰富的查询语义.定义3.目标模式.令tp表示目标模式,c表示可伸缩条件,则目标模式可以表示为tp=∪mi=1pi[ci],其中共m个不重叠模式,ci为pi对应的可伸缩条件.由定义3知用户选定连续的区段,继续在其上定义子区段作为不重叠模式,并设置相应可伸缩条件.可见目标模式是由若干个子模式复合而成的,它允许内部某些子模式重复、缺失或倒置,表达语义更复杂.类型符号表示重复[m]缺失-P倒置PTP模式波形倒置,180°反转;或A|B4.2基模式覆盖在用户定义的目标模式中,不重叠模式仅仅保证了物理上各模式间是没有重叠部分的,但并不能保证彼此之间逻辑上可以很好地区分,即并未消除模式间可能潜在的相互包含关系.不重叠模式间的潜在相似性包含关系如图6所示,(a)中相似于左边的模式整体又出现在右边目标模式中,(b)中两个模式都包含了相似的一个组成部分.随着数据流源源不断地到达,匹配可能会出现二义性.这主要是由于不重叠模式间存在着相似性包含关系,在匹配时它们都在误差阈值范围之内,导致多个匹配结果的出现,无法正确返回查询结果.因此本文提出的SPQ方法引入了基模式(basepattern)和基模式覆盖(basepatterncover)的概念,如定义4和5所示,用于保证不重叠模式彼此间不存在包含关系,在逻辑上是彼此可区分的.定义4.基模式.基模式除了具有不重叠模式的特征外,还有如下特征:bpi,bph∈Coverb()p,i≠h,bpi=Xi1,ti()1,…,Xij,ti()j,…,Xiki,tik()bph=Xh1,th()1,…,Xhj,th()j,…,Xhkh,thk()/th1thpthkh-tik(i-ti)1+1(假定thkh>tiki),对于subp=Xhp,th()p,…,Xhp+kh-1,thp+kh得similarity(subp,bpi)<ε,其中ε是相似度衡量误差阈值.由定义4可知基模式本质上仍是不重叠模式,但基模式彼此间可相互区分,不存在包含关系.定义5.基模式覆盖.存在时间戳从tw1到tw2跨度的目标模式,则对于r个基模式,基模式覆盖具有如下特征:由定义5可知,所有的基模式按目标模式中时序顺序首尾相连能够近似重构回目标模式起止时间戳所跨越的范围.生成基模式及其覆盖算法的主要思想是将不重叠模式两两比较.若存在包含关系,则将包含部分拆分出来.由于新拆分出来的子模式会影响当前所有模式的比较,本文对模式按大小进行排序,如算法1所示,每次判断相似性包含关系时,都用较小的探针模式(probepattern)去比较或拆分较大的目标模式Page6(targetpattern),以保证任意两个基模式间的可区分性;同时维护当前比较记录来提高效率.若两模式尚未比较则调用算法2来判断是否存在包含关系,若存在则拆分成可相互区分的基模式,其间优化新产生基模式的插入位置,用来减少比较次数和保证准确性.算法1.Basepatternsgeneration(基模式生成).输入:tp,errorboundEbp输出:Dictionary(bp),Cover(bp)中间变量:probeindexi,targetindexj,Set(bp);1.InitializeSet(bp)withtp,andorderSet(bp)inas-2.fori<Set(bp).sizedo//comparewithotherbp3.j=i+1;4.forj<Set(bp).sizedo5.ifbpiandbpjhavealreadybeencompared6.j++,movetonexttargetbpjofSet(bp);7.elsebpiandbpjhaven’tbeencompared8.i,j←Patternsplit(bpi,bpj,Set(bp),Ebp);9.ifidoesnotchangetheni++;10.generateDictionary(bp)andCover(bp)dueto算法2.Patternsplit(bpi,bpj,Set(bp),Ebp)输入:bpi,bpj,Set(bp),Ebp输出:Set(bp),probeindexi,targetindexj中间变量:insertIndex,compareResult;1.compareResult←SimilarityCompare(bpi,bpj,Ebp),2.ifcompareResultindicatesbpiisn’tsimilartobpj3.j++;//movetonextbp(basepattern)4.elsesplitbpjwithcompareResult,5.replacebpjbybpnewinascendingorder;6.recordalltheinsertindexes;7.insertIndex←findminimuminsertindex;8.ifinsertIndex>ithenj++;9.elseifinsertIndex<ithen//disturbrecord10.i=insertIndex,breaktostartanewpass;算法1调用算法2作为关键步骤,考虑目标基模式含k个点,探针基模式含h个点,则算法2的关键方法SimilarityCompare决定了其时间复杂度为O(h(k-h)).若共有m个不重叠模式,此处假设平均每次比较后进行一次拆分,增加一个新的模式.则算法1的时间复杂度为O(mh(m-1)(k-h)).实际应用中一般不会达到上述假设情况,通常拆分的次数并不太多,而且算法1和2对算法的优化也提高了效率.此处复杂度虽然不一定能满足线性要求,但是保证了生成基模式的准确性;并且此过程只是根据目标模式执行一次即可.所以为了后续查询处理的精度、生成准确的基模式字典,以一定时间换精确度是可以接受的.4.3基于基模式的查询重写产生基模式后,可以对表达查询需求的目标模式进行查询重写.这种重写是基于基模式粒度的,不但表达灵活,而且在后续查询中也可避免匹配二义性的问题.通过对目标模式进行基于基模式的查询重写,可以形成可伸缩模式查询(SPQ).定义6.令sp表示可伸缩模式,mc表示可伸缩条件,共r个基模式,则可伸缩模式表示如下:其中bpi为基模式,mci为其对应的可伸缩条件.可伸缩模式查询是对目标模式的查询重写.它基于基模式的粒度.SPQ同样允许内部的某些基模式重复、缺失或倒置,处理粒度相对更细一些.而这种查询重写首先要将可伸缩条件从目标模式中的不重叠模式映射到可伸缩模式中的基模式上.由同一个不重叠模式拆分出的基模式要共享相同的可伸缩条件,且这种查询重写的过程对用户是透明的.具体如算法3所示.例如目标模式为A[1-2]B[1](-C|C[1]),且C可以拆分为A和D,所以基模式为A、B、D,则SPQ可以表示为A[1-2]B[1](-A-D|A[1]D[1]).算法3.SPQgeneration(可伸缩模式查询生成).输入:Dictionary(bp),Cover(bp),tp;输出:scalablepatternsp;1.foreverybpinCover(bp)2.ifitcorrespondstopintp3.bp.constraints←p.constraints;4.updatespwithbpandscalableconstaints;若目标模式中有m个模式,通过算法1和2生成r个基模式,一般情况下r稍大于m.算法3要浏览一遍Cover(bp),则其时间复杂度为O(kr),其中k为常数.5可伸缩模式查询处理可伸缩模式查询处理可以根据已生成的基模式字典在数据流上自动执行.首先对依次到达的数据点并行判断连续点组成的轨迹是否满足任一基模式,从而完成基于基模式的匹配,形成模式流;进而对模式流中的基模式按时序顺序出现的情况进行计数,尽可能复用已处理的结果,实现基于模式流的查询.Page75.1基于基模式的匹配在数据流应用领域,数据点源源不断地到来,连续点的轨迹可以显示出这些点的大致走向与趋势.受此启发,每到达一个数据点,SPQ方法就将其与基模式字典中的所有基模式同步比较,即并行地判断点的轨迹与哪个基模式相似,可以匹配成功.在并行匹配过程中,随着数据点不断地到达,连续点的轨迹与基模式并行比较会形成多个分支,分支停止情况大致有以下3种关系:(1)与某一基模式的比较尚未结束,但是累积误差已经超过误差阈值,及时停止该分支比较;如图7(a)所示,其中EB为误差阈值.最开始与所有基模式的比较都在误差范围内,随着数据点不断地图7基于基模式的模式匹配与模式流生成在基于基模式的匹配中,匹配成功的点的轨迹就可以用与其相似的基模式来替换,使用与其对应的唯一标识符记录;若匹配不成功,则将该连续点的轨迹直接记录下来,并记作wi,其中可能包含噪声数据,它不会被任何基模式匹配,因此具有一定的抗噪声能力.如算法4所示生成相应的模式流,以提高后续查询的效率.此模式流由大量的基模式标识符以及一些未匹配点的轨迹组成,将这些点的轨迹完整地记录下来,并保存在wi中.如图7(b)所示,对应于当前数据流的模式流是w1ABDDBD,且w1中同时记录了此匹配不成功的连续点的轨迹信息.在查询不匹配时,在模式流上进行回溯的效率要高于在数以百计的数据点上进行回溯.流生成).算法4.Basepatternstreamgeneration(模式输入:S:adatastream,EB:errorthreshold,输出:bps:basepatternstream中间变量:errorArray[]:distanceerrorsforeachbp,1.initializetheinteriorvariables;到达,点的轨迹与基模式A相似度超过误差阈值,停止与A的比较,其它分支继续并行比较;(2)与某个基模式比较结束,且累积误差满足阈值要求,连续点的轨迹很快收敛到该基模式的波形,说明匹配成功,停止其它分支比较:如图7(a)所示,与基模式B的比较已完成,且误差未超过阈值,则认为当前比较的连续点的轨迹与基模式B匹配,对新到达的连续数据点重复执行上述过程;(3)全部基模式的匹配都未完成,但所有比较分支的误差均已超过误差阈值,此时认为该连续点的轨迹与任意基模式均不匹配或者可能是噪声数据.2.foreverynewarrivingdatapointdi;3.forj<Dictinary(bp).size;4.errorArray[j]+=isBelongToBP(di,bpj);5.iflen[j]<bpj.sizeanderrorArray[j]>EB6.stopcomparisonforbpj;7.elseiflen[j]==bpj.sizeand8.addbpjtobps;9.isRecognized←true;10.ifisRecognized==falsethen11.jointhesedatapointsafterthebpsaswi;在算法4中,将数据流的大小设定为|S|,计算当前点是否落在某基模式上的开销为O(1).算法4的主要操作为计算累积误差并判断分支是否停止的操作,而对于多个并行比较的分支,只参考处理时间最长的即可,因此其时间复杂度为O(|S|).5.2基于模式流的查询实现在模式流上,SPQ方法对按时序顺序排列的基Page8模式的出现情况进行计数.如4.3节中提到的可伸缩模式查询A[1-2]B[1](-A-D|A[1]D[1]),设置counter数组用来记录基模式A、B、A、D的匹配次数.进而根据其出现次数与SPQ的约束限制判断是否能够匹配上.若不匹配时,对第一个模式的出现次数进行判断,若其在SPQ第一个基模式的可伸缩条件的限制范围内,且与该模式相似,则可复用部分已处理结果;否则在以基模式和wi为粒度的模式流上继续后续匹配.可伸缩模式查询的整体处理如算法5所示:首先调用算法1Basepatternsgeneration生成基模式和基模式覆盖,进而调用算法3SPQgeneration对目标模式进行基于基模式的查询重写形成SPQ,完成可伸缩模式查询表示;随后在数据流上执行可伸缩模式查询处理,调用算法4Basepatternstreamgeneration将连续点的轨迹与所有基模式并行地比较,判断其是否与某一基模式相似,生成模式流,继而对按时序排列的基模式的出现情况进行计数,完成后续SPQ匹配.(数据流上的可伸缩模式查询).算法5.ScalablePatternQueryoverDataStream输入:S:adatastream,EB:errorthreshold,输出:MR:matchingresultwithgraphicalinformation中间变量:Dictionary(bp):thesetofallbasepatterns,//ScalablePatternQueryExpressionisfocusedbelow1.basepatternsgeneration(tp,Ebp),returnDictionary(bp)andCover(bp);2.SPQgenerationwithconstraintsmappingtoCover(bp);//ScalablePatternQueryEvaluationisfocusedbelow3.initializetheotherinteriorvariables;4.basepatternstreamgenerationtogeneratebps;5.foreverybpinbps,compareitwithinSPQ6.whenthetypeofthecurrentbpischange,calcu-7.ifitmeetsthetypeandcounteriswithintheSPQ8.locatepointertothefirstbpofthelatest9.elsebacktrackbpsatpointer;10.returnMR;对于模式查询而言,主要时间消耗在生成基模式及基模式覆盖上,开销为O(mh(m-1)(k-h)),正如4.2节中提到的,此过程只执行一次,以一定的时间换取了后续匹配的精度.在查询处理时,若共回溯Nbacktrack次,则时间复杂度为O(c|S|),其中c=1+(Nbacktrack/|S|).6实验结果与分析基于上述思想,本文实现了数据流上的可伸缩模式查询,设计了相关实验对比不同方法在查全率、查准率和处理效率上的区别.具体实验环境如下:OS是MicrosoftWindowsXPProfessionalEditionServicePack3,CPU为IntelCore2,内存1GHz,主频1.66GHz,内存1GB.算法开发环境是MyE-clipse7.0EnterpriseWorkbench,JDK1.5.0;算法开发语言是Java.在真实的医疗数据流和用电数据集上进行实验.(1)医疗数据流.从PortlandStateUniversity的BiomedicalSignalProcessingLaboratory下载了超过2千万个数据点的儿科重症监护数据,是对一位儿童6项生理体征进行连续6h的同步测量得到的,频率为500Hz.其中包括心电图数据(ECG)、动脉血压(ABP)、中心静脉血压(CVP)、颅内压(ICP)、呼吸机数据(RESP)和动脉血氧饱和度(PLETH).其中ECG的模式种类多且复杂,CVP和ABP的模式种类少而且变化简单.(2)民用用电量数据.数据来源于福建某电力公司,设立多个观察点,数据点超过12万个.每个数据都有相应的时间戳和对应数值.该数据集特点是包含较多噪声数据,如图3所示.根据第2节的相关研究,SPQ方法在查询表示上优于DSMS中基于元组的查询,表达灵活、语义丰富,而后者不支持对模式的查询处理.基于时序数据库的模式匹配方法,其往往对数据进行多遍扫描,很难满足数据流的实时处理要求.基于树的ZStream方法是以事件为粒度的,它是由数据源直接产生的,不支持在其内部细分,因此无法处理事件间的包含关系,在匹配中可能造成二义性.基于图的NFA传统方法是离线的,近些年基于NFA的方法逐步向在线处理方向发展.综上所述,本文选择一种典型的基于NFA的方法,即NFAb的方法与SPQ方法进行比较.实验主要从查全率、查准率和处理效率这3个指标来衡量.Page96.1查全率查全率表示为Rrecall=Nreal/Ndue,用于衡量算法查询出的结果个数是否达到预期目标.它是查询出的相关结果数与系统预期的相关结果数之比.其中Nreal为查询出的相关结果数,Ndue为预期的相关数目.Ndue采用人工标识的方式,由专业用户根据经验给定,从而形成统一的衡量标准.图8展示了SPQ和NFAb两种方法应用于医疗数据流查询时的查全率.对应于6个数据集的误差阈值分别为0.07、0.55、0.02、0.03、0.6、0.6.从图8中可以看出,当模式较为复杂时,在查全率方面SPQ方法优于NFAb方法.由于ECG数据点间隔密集、模式复杂、多样性较高,导致模式间的组合多,拆分出的基模式也就更多,从而使得基于基模式操作粒度的SPQ方法能较准确地发现符合要求的结果;而NFAb基于事件的粒度(对应于本文中不重叠模式的粒度),由于未拆分包含关系,在匹配中可能出现二义性的情况,实现时任意选择一个匹配结果以供后续处理.所以SPQ方法的查全率优于NFAb方法,最主要的原因是前者考虑了模式间相互包含的关系,并使用更细的基模式粒度进行查询.类似的,RESP、ICP、PLETH等数据集模式波形都相对较复杂,因此两种方法对比稍明显,而CVP、ABP模式多样性低,故两种方法对比相差不大,且其查全率相对于其它数据集要高些.6.2查准率查准率表示为Rprecision=Nreal/Nout,用于衡量查询结果的正确性.它是查询出的相关结果数与查询出的总数之比.其中Nout为查询出的总数,Nreal仍为查询出的相关结果数.查准率Rprecision和查全率Rrecall综合起来衡量查询结果的完备性.图9展示了SPQ和NFAb两种方法应用于医疗数据流查询的查准率.该实验的误差阈值取值与查全率实验相同.从图9中可以看出,当模式较为复杂时,SPQ方法在查准率上优于NFAb方法.主要原因与查全率实验相似,仍是因为SPQ方法考虑了模式间相互包含的关系,并使用更细的基模式粒度进行查询,从而保证了查询的精准度.但由图9可以看出,当模式较为复杂时,其查准率相对更高一些,比如ECG、RESP、PLETH等;而对于CVP等模式变化较少的数据集其查准率则相对低一些.这主要是因为某一误差阈值设定后,当模式较复杂时,相互之间差别也较大,累计误差随之增加,可以较好地区分查询结果,因此查询出的结果多为吻合度较高的;而模式简单、缺乏变化的,其累计误差增加缓慢,不容易超过误差阈值,所以查询结果中会存在一些并非预期的结果,它们因未超过误差阈值被认作匹配成功,进而被包含进来.因此对于查准率而言,SPQ方法在模式较为复杂的数据上效果更加明显.6.3处理效率处理效率表示为Eprocess用于衡量算法执行效率.此处以返回单个查询结果的响应时间(responsetime)为核心,计算所有响应时间的平均值来衡量查询算法的处理效率.如图10所示,SPQ方法在处理效率上优于NFAb方法,且模式越复杂优势越明显.这主要是因为SPQ是基于基模式粒度的,匹配过程中,在模式流上为SPQ中每个基模式的连续出现次数计数,以反映其重复或缺失的情况.当不匹配时,对第一个模式的出现次数进行判断,若其在SPQ第一个基模式可伸缩条件的限制范围内,且与该模式相似,则可复用部分已处理结果.而NFAb这种减少回溯的方法,当处理的模式较复杂时,每个singleton中可能会形成多个分支点,将其均存入栈中,当发生不匹配时逐个弹出分支点,按其位置依次匹配下一种查询的可Page10能性.当目标模式较复杂时,会花费较多的时间去尝试各种可能.由于ECG数据点间隔密集、模式复杂、多样性较高,形成的基模式较多,查询相对其它来说较复杂,因此返回单个查询结果的时间消耗也较长.6.4误差阈值设置图11显示了匹配误差阈值的设置对SPQ方法的影响,该实验在民用用电数据集上进行.由图11的结果显示可以看出,方法较好地适应了有噪声的环境.随着误差阈值的增大,查全率(图11菱形表示)会有较明显的增高,而到达某一值后,后续增长很平缓,这主要是因为阈值的增大在初期可以使得很多预期结果被查询出来,而随着阈值的增大,大多数的预期结果均被查询出来,所以此时再增长阈值,其查全率增长并不明显.而查准率(图11方块表示)则是会随着阈值的增大而逐步减小,到达某一值后减小趋势开始明显,如图中的0.08之后,这主要是因为随着阈值的增大,查询出的结果数增多,一些并不十分相似的也被包含进来,从而导致查准率的降低.因此为了得到全面的查询结果,SPQ方法应从查全率和查准率两方面综合考虑来设定阈值,如民用用电数据集用例中较合理的阈值为0.08左右.7总结与展望为了在数据流上支持以模式为粒度的查询,并允许目标模式具有一定的可伸缩性,本文提出了一种数据流上面向可伸缩模式的查询(SPQ)方法.SPQ方法提出了以基模式为粒度的查询重写机制,进而在数据流上通过基模式匹配形成了模式流.在模式流上的查询处理中,尽可能复用已处理结果来提高查询效率.在真实数据集上的实验结果证明SPQ方法在查全率、查准率和处理效率方面优于NFAb的方法,尤其当目标模式较为复杂时效果更加明显.丰富的语义;考虑查询结果的共享等.致谢感谢为本文的成稿提供有建设性意见的各位朋友,是你们的灵感启发和无私的帮助使得作者更加完善了本文的核心思想和整体方法.同时也要感谢匿名评委,他们对本文的评审意见和建议对本文的改进大有裨益!今后的工作主要是扩展更多约束条件以支持更
