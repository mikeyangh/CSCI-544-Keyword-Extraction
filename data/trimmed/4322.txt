Page1犔(犽)-index:一种支持标签路径的高效犽双拟结构索引李晓光1)宋宝燕1)于戈2)王大玲2)1)(辽宁大学信息学院沈阳110036)2)(东北大学信息科学与工程学院沈阳110004)摘要针对基于k双拟的结构索引创建和更新低效问题、查询结果重复验证问题以及标签路径不可获得性问题,提出了一种新的结构索引L(k)-index.L(k)-index通过引入标签路径,在创建时无须k次遍历原数据,并采取批量更新策略,大大提高索引创建和更新的效率,而在空间上仅有很小增加.对于长度大于k+1的路径查询,L(k)-index无须访问原数据进行验证,并支持批量节点的标签路径获得.通过大量实验表明,同A(k)-index相比,L(k)-index创建时间平均提高66.7%,查询处理时间效率平均提高68.9%,批量更新效率平均每节点提高58.8%,而空间仅增加22.5%.关键词k双拟结构索引;XML索引;标签路径;XML查询;XML检索1引言在XML数据库领域中,作为提高XML查询效率的重要技术之一,结构索引(structuralsummary)一直以来是研究人员所关注的研究方向.结构索引通过对路径压缩,建立一个远小于原XML数据的图结构,并通过遍历索引来提高查询中路径信息的处理效率.目前,典型结构索引有DataGuide[1]、1-index[2]、A(k)-index[3]、D(k)-index[4]等.1-index、A(k)-index和D(k)-index均为基于k双拟(k-bisimilarity)的结构索引,索引通过对局部路径信息合并,大大降低DataGuide索引节点冗余.当查询路径长度大于k时,基于k双拟的结构索引是非准确的,必须在原XML数据上进行验证.目前方法在索引构建时对索引节点分裂要求能够判断任意一对节点的父子关系,导致频繁遍历原数据.特别是对于大规模XML数据来说,其创建时间远远超过用户容忍程度.另外,随着XML数据信息获取技术的发展,特别是在XML检索和XML非完全结构查询中,要求结构索引在返回给定路径下的节点集合的同时,还需要返回节点的完全标签路径.然而迄今为止,基于k双拟的结构索引设计目的是提高路径查询效率,并不支持节点完全标签路径的获得.PE索引[5]是我们前期工作提出的一种基于树模型的结构索引,其设计目标是在支持路径查询的基础上,同时支持标签路径获得和节点k祖先的计算.但由于PE索引借鉴了StrongDataGuide和1-index的设计思想,导致大量冗余现象的存在.针对目前基于k双拟的结构索引创建和更新低效问题、查询结果重验证问题以及标签路径不可获得性问题,本文提出一种新的基于k双拟结构索引L(k)-index.主要贡献点有:(1)通过引入标签路径,使得L(k)-index在L(k-1)-index基础上直接获得,无须k次遍历原XML数据;(2)采用批量计算节点后继和批量更新策略,大大提高索引创建和更新效率;(3)当对于长度大于k+1的路径查询时,L(k)-index无须访问原数据进行验证,从而大幅提高查询处理效率.通过大量实验,同A(k)-index相比,L(k)-index的创建时间平均提高了66.7%.查询处理时间效率平均提高了68.9%,而空间仅增加了22.5%,批量更新效率平均每节点提高58.8%.本文第2节介绍典型的基于k双拟结构索引A(k)-index并详细分析其存在的不足;第3节给出L(k)-index的结构、性质以及查询处理方法;第4节给出L(k)-index创建方法和索引更新方法;第5节在标准数据集和实际数据集上测试L(k)-index的性能,并同A(k)-index进行实验比较;第6节给出相关工作;最后,第7节是全文总结.2基于犽双拟的结构索引目前典型的基于k双拟的结构索引有1-index,A(k)-index和D(k)-index.实际上,当k达到足够大时,A(k)-index等价于1-index,而D(k)-index考虑不同k值,但结构上仍类似于A(k)-index.这里我们以A(k)-index为例对基于k双拟的结构索引进行阐述并分析其存在问题.定义1.k双拟(≈k).给定XML文档节点u和v.(1)如果u和v的标签相同,则u≈0v.(2)如果u≈k-1v,且对所有u父节点u,存在v父节点v满足u≈k-1v,反之亦然,则u≈kv.A(k)-index为一个图,图中节点为索引节点,其代表符合k双拟关系的节点集合.在两个索引节点中的节点,如果存在任意两个节点为父子关系,则这两个索引节点存在一条边.A(k)-index存在以下问题:(1)当查询标签路径长度小于或等于k+1时,A(k)-index是准确的(precise)和安全的(safe),而当长度大于k+1时,是安全的但非准确的,也就是说,必须遍历原数据以验证结果;(2)A(k)-index的构建是从k=0开始,对每个索引节点中的节点,计算直接后继,并以此分裂其他索引节点,直至不存在分裂或达到k值,其时间复杂度为O((k+1)n),n为节点数.对于大规模文档,索引创建时间长;(3)由于对局部路径进行合并,无法通过遍历索引来获得节点的完全标签路径.为了确定节点的完全标签路径,则必须对每个节点在原数据中验证;(4)不支持索引增量更新.针对上述问题,本文提出一种新的基于k双拟结构索引L(k)-index,通过引入标签路径,索引在分裂时无须依次访问每个节点计算后继,而是在L(0)-index上直接得到,并提出一种批量更新策略.当对于长度大于k+1的路径查询时,L(k)-index索引无须验证即可得到准确和安全的结果.3基于犽双拟的结构索引犔(犽)-index3.1基本概念与定义这里将XML文档T的数据模型定义为有向无Page3环图G=(V,E,r,Σ,label,oid,value).V为T中节点集合,V=Vn∪Vl,Vn为非值节点集合,Vl为值节点集合.E为弧集合,其中对于节点引用关系(IDREF,XLink)称为引用弧,节点嵌套关系为父子弧.r为根节点.Σ为节点标签集合,oid为节点唯一标识.label为非值节点标签函数,即label:oid→Σ.value为值节点值函数,即value:oid→string.定义2.节点路径.图G中一条长度为n的节点路径为一个节点序列(u1,u2,…,un),其中对任意一对相邻的节点ui和ui+1满足〈ui,ui+1〉∈E.定义3.标签路径.给定一个节点路径(u1,u2,…,un),其标签路径为节点标签序列lp=(l1,l2,…,ln),其中li=label(ui),i=1~n,称lp为节点un的标签路径.如果u1=r,则称lp为节点un的完全标签路径.标签路径(ln-k,ln-k+1,…,ln)称为节点un的k标签路径.如果标签路径lp是节点路径np的标签路径,则称节点路径np匹配标签路径lp.对于节点u和标签路径lp,如果存在以u为终点的节点路径,且路径匹配lp,则称节点u匹配标签路径lp.3.2犔(犽)-index索引结构为了能够获得节点的完全标签路径,为每个索引节点分配唯一索引标识(indexnodeID,IID),并采用dewey编码[6]方式为索引中标签路径进行编码.定义L(k)-index为有向无环图I=(IV,IE,IID,EXT,ΣI,label_i).IV为索引节点集合,IE为弧集合,IID为索引节点标识符集合.label_i为获得索引节点标签的函数,即label_i:IID→ΣI,ΣI为索引节点标签集合.EXT为索引节点的扩展集合.给定索引节点A∈IV,其扩展集合extI(A)∈EXT中的索引元素e∈extI(A)为一个二元组(PID,Ne),其中PID为节点的完全标签路径编码集合.完全标签路径编码(pid)是由iid∈IID构成的序图2图1中XML文档的L(1)-index列,代表了节点的完全标签路径.pid类似于dewey编码,即如果节点u是节点v的祖先,则节点u的pid为节点v的pid的前缀.“|·|”代表取pid的长度,即序列中iid的个数.Ne为节点集合,Ne={u∈Vn|u,v∈Ne,u,v具有相同的PID},且对于任意一对节点u,v∈{u∈e.Ne|e∈extI(A)}来说,节点u和v满足k双拟.图2为图1中的XML文档的L(1)-index,其中圆圈中的字符为索引节点标签,i0~i17为索引节点的iid,括号代表索引节点的扩展集合中的元素,元素包含PID和该PID下的节点集合.以图2中的索引节点“H”(iid=i10)为例,其扩展集合包含了两个元素({i0.i1.i2.i6.i10,i0.i1.i4.i8.i15.i6.i10},{13})和({i0.i1.i2.i5.i10},{11}),其中第一个索引元素中满足该PID且符合1双拟关系的有{13}.PID集合中有两个pid,分别代表节点13的两条完全标签路径R.A.B.E.H和R.A.D.G.L.E.H,且|i0.i1.i2.i6.i10|=5,|i0.i1.i4.i8.i15.i6.i10|=7.第2个索引元素中满足该PID且符合1双拟关系的有{11}.PID集合中有一个pid,代表节点11的完全标签路径R.A.B.E.H.那么在“H”(iid=i10)索引节点中符合1双拟关系的有{11,13}.Page4性质1.对于节点u和v,设其pid分别为pidu和pidv,如果u是v的后继,则pidv是pidu的前缀且|pidu|=|pidv|+1.性质2.设索引节点A,对其任意一对元素e和e,则它们的k+1标签路径集合相同,即对于任意pid∈e.PID,pid=iid1.iid2…iidn,存在pid∈e.PID,pid=iid1.iid2…iidm,满足i1,i2,n-i1=m-i2=k且对连续的i1=i1~n和i2=i2~m,有label_i(iidi1)=label_i(iidi2),反之亦然.性质3.对任意元素e,其k+1标签路径集合中元素数量小于或等于e.PID的元素数量.根据pid以及k双拟的定义,我们容易证明性质1~性质3,由于空间所限,证明略.性质4.给定索引节点A和B,索引元素e∈ext(A)和e∈ext(B),则当满足如下条件时,e.Ne中节点为e.Ne中节点的后继:(1)对任意pid∈e.PID,存在pid∈e.PID,使得pid是pid的前缀且|pid|=|pid|+1.(2)不存在索引元素e∈ext(A),使得e满足条件(1)且e.PID集合元素个数大于e.PID.证明(必要性).首先,孩子的完全标签路径数量必然大于或等于父亲的完全标签路径数量.结合性质1可得,如果e.Ne中的节点为e.Ne中节点的后继,则条件(1)成立.根据性质2和性质3,同一索引节点中任意元素的k+1标签路径集合是相同的,但PID可不同,存在元素PID之间的包含关系.那么如果存在e,其PID与元素e的PID满足条件(1),则对于e的PID子集也必然满足条件(1),因此条件(2)成立.(充分性).采用反证法.根据L(k)-index定义可知,索引元素中节点的PID相同,那么其父亲节点的PID必然相同且属于同一个元素.如果条件(1)和(2)满足,设e.Ne中节点不是e.Ne中节点的后继,即存在u∈e.Ne为满足条件(1)和(2)的节点但其父亲ue.Ne,则u的PID必然与e.Ne其他节点PID相同,却不属于同一元素,与L(k)-index定义相悖.定理1.同A(k)-index相比,L(k)-index空间复杂度平均增加了O(m),m为索引结点平均完全标签路径数.证明.从L(k)-index的定义可以看出,同A(k)-index相比,每个索引节点仅仅增加了完全标签路径信息,索引节点数不变,因此L(k)-index的空间复杂度平均增加了O(m).3.3查询处理给定查询路径Q,在L(k)-index上获得符合Q的节点步骤如下:(1)如果Q长度不大于k+1,则遍历L(k)-index,查找所有符合Q的路径,并将路径终端的索引节点中的节点返回即可;(2)如果Q的长度大于k+1,则从Q终端开始截取部分长度为k+1标签路径Q,遍历L(k)-index,查找所有符合Q索引节点,对索引节点中每个元素,利用其PID验证是否符合Q.对于查询返回结构中同一元素中的节点集合,可以根据其PID逆向遍历索引所得到的路径为该集合中所有节点的完全标签路径集合.定理2.对于任意长度的路径查询,L(k)-index是安全的和准确的.证明.显然,对于第一种情况,根据k双拟关系定义,对于任意长度的路径查询,L(k)-index是安全的和准确的.对于第2种情况,首先Q的长度小于Q,则Q的查询结果是查询Q的子集,根据L(k)-index定义,pid代表了节点的完全标签路径,则经过验证,可以保证结果的准确.证毕.4犔(犽)-index创建与更新4.1索引创建同A(k)-index创建类似,L(k)-index创建基本思想是通过分裂k双拟索引节点来获得(k+1)双拟,但L(k)-index通过计算元素中节点集合的后继节点集合的方式,大大提高索引创建效率.定理3.给定L(k)-index索引节点A,则其后继节点集合Succ(A)={u|u∈e.Ne,e∈extI(B),索引节点B是A的后继且存在e∈extI(A),使得e和e满足性质4}.证明.根据定理2可知,由于基于k双拟的结构索引保持了原XML所有的路径信息,也就是说结构索引是安全的.那么对于索引节点A中的节点来说,其后继节点肯定存在于A的后继索引节点的扩展集合中.结合性质4,定理3得证.证毕.L(k)-index创建算法见算法1.为了满足性质4中的条件(2),这里索引节点中的元素已按照PID集合大小非递增排序.在步12~18的分裂过程中,为新产生的索引节点赋予新的iid,并且对新节点的扩展节点以及其所有后继节点的pid进行依次更新.根据定理3,只需更新分裂节点的后继节点即可.定理4.LK_Create算法时间复杂度为O(n+Page5km),其中n为XML节点数,m为完全标签路径数.证明.LK_Create算法中计算0-bisimiliarity为一次遍历,时间复杂度为O(n).在分裂索引节点时,需要分裂的节点数最多为完全标签路径数m且最多分裂k-1次,时间复杂度为O(km).综上所述,LK_Create算法的时间复杂度为O(n+km).算法1.索引创建算法LK_Create(G,k).输入:GraphGandk输出:L(k)-index1.initializeχas0-bisimiliaritypartitionsofG,thatis,topartitionthenodesofVnbylabel2.FOReachX∈χ,assignitwiththeuniqueiid3.FOReachnodeofX,computeitsPIDandmerge4.DO//i=15.FORindexnodesIandIinχnoincidentwitharc6.IFthereexistse∈Iande∈I,satisfyingthe7.γ=acopyofχ8.FOReachindexnodeXinχdo9.FOReachchildZofXdo10.FOReachelementeinZdo11.IFesatisfiesTheorem3,appendeintoSucc(X)12.FOReachYinγdo//split13.IFext(Y)∩Succ(X)≠nullTHEN14.A=ext(Y)∩Succ(X),B=ext(Y)-Succ(X)15.assigntheidentifierforBandupdatethePID16.FORthedescendantYofYinχandγdo17.IFthepidinYcontainsthepidinB,18.replaceYbyAandB19.IFtherewasnosplitTHENbreak20.χ=acopyofγ21.WHILE(i++<=k)22.RETURNχ4.2索引更新4.2.1合并与分裂如果不考虑节点的引用弧,此时节点更新不会对原图节点的标签路径产生影响.当插入新节点时,如果新节点与索引节点中的节点满足k双拟关系,则将新节点添加到该索引节点中.如果新节点与任意一个索引节点中的节点均不满足k双拟关系,则创建新的索引节点,并添加新节点到新索引节点中.当删除节点时,不失一般性,设被删除节点为叶子节点,则将节点从相应索引节点中删除即可.如果考虑到节点的引用弧,由于插入和删除后,原图其他节点的标签路径发生了变化,必须保证节点间依然满足k双拟关系.综上所述,无论节点是插入或是删除,对于原索引的更新操作可以归结为两个基本操作:索引节点合并和索引节点分裂.(1)合并算法根据k双拟的定义和性质,如果两个索引节点可以合并,则索引节点中的节点必须具有相同的k+1标签路径.索引节点合并算法如下.I2,k).算法2.索引节点合并IndexNodeMerge(I1,输入:IndexnodeI1,I2,andk输出:MergedindexnodeI11.constructingthelabelpathsetsP1andP2bythepid2.FOReachlabelpathp∈P1,3.IFthereexistsp∈P2,satisfyingpandphave4.appendtheelementsofI2intoI1andRETURNI1;5.ELSERETURNNULL;(2)分裂算法在一个索引L上,如果添加或删除一个引用关系〈u,v〉,由于节点v的标签路径增加或者减少,均会导致索引节点分裂.具体分裂算法见算法3.算法利用性质2作为判断分裂的结束条件之一.当一个节点不需要分裂时,显然其后继节点也无须分裂.算法3.索引节点分裂SplitIndex(L,〈u,v〉).输入:IndexLandthearc〈u,v〉输出:SplitindexL1.letdepthbetheglobalvariable2.letSbethesetofsplitindexnode3.IF++depth>kTHENreturn;4.searchtheelementseandecontaininguandv5.updatethePIDofvaccordingtothePIDofu;6.IFProperty2isn’tsatisfiedwithrespecttothePID7.createnewindexnodeI,andappendtheelement8.addthearcfromAtoI;deletethenodevine;9.addthearcfromItotheindexnodeofvand10.addtheIintoS;SplitIndex(L,〈u,v〉);11.RETURNS;定理5.给定一个L(k)-index,当添加或删除Page6一个引用关系〈u,v〉时,索引节点A中节点v与A中其他节点不满足k双拟关系,则自索引节点A起最大分裂深度为k.设需要分裂的索引节点B,则A与B构成的路径长度不大于k.证明.根据k双拟关系的定义,只要以节点为终点,长度为k的路径上节点标签路径不发生变化,则该节点的k双拟关系不变,因此当深度大于k时,索引节点中的节点双拟关系不变.证毕.定理6.算法SplitIndex的时间复杂度与k成正比,即O(k).证明.根据k双拟关系定义,只要以节点为终点,长度为k的路径上节点标签路径不发生变化,则该节点k双拟关系不变,因此当深度大于k时,索引节点中的节点双拟关系不变.4.2.2节点插入如果按照节点插入次序,依次对索引更新,则对于n个插入节点,索引更新的时间复杂度为O(cnm),c为定位节点、创建索引节点和索引合并的时间复杂度,m为原索引节点数.在批量更新时,n通常会非常大,其运行时间仍然很长.本文提出“对增量建索引,然后合并”的策略,可以将更新时间复杂度降低到O(n+kmm),m为增量索引节点数目,一般mn.主要思想为:首先忽略增量数据对原数据的引用,对增量数据创建索引,将原索引与增量索引合并.其次,在合并索引的基础上,对所有新添加的弧〈u,v〉,当v与索引节点中其他节点不再满足k双拟时,将节点v分裂,并对节点v的孙子节点判断是否需要分裂,直至孙子节点与v的层数相差大于k或不产生分裂为止(见定理5).最后,在分裂后的索引上,对所有索引节点进行一次合并.索引更新算法如算法4和算法5所示.算法4.索引增加IncrementIns(L,G).输入:indexLandupdategraphG输出:updatedindexL1.L←LK_Create(G,k);2.L←MergeIndex(L,L);3.FOReachnewarc〈u,v〉,whereu∈G,v∈G,do4.S=S∪SplitIndex(L,〈u,v〉);5.FOReachsplitindexnodeI∈S6.FOReachindexnodeI∈L.IV-S7.IF(IndexNodeMerge(I1,I2,k)!=NULL)break;8.RETURNL;算法5.索引合并MergeIndex(L1,L2).输入:IndexL1,L2输出:MergedindexL11.FOReachindexnodeIinL22.locatetheindexnodesXinL1withthesamelabelofI3.FOReachI∈X4.IF(IndexNodeMerge(I,I,k)!=NULL)5.updatethePIDoftheelementsandtheir6.break;7.RETURNL1定理7.MergeIndex算法的时间复杂度为O(kmm),m,m分别为原索引和增量索引中的索引节点数.证明.显然,IndexNodeMerge时间复杂度为O(k),则对于m个增量索引节点在m个原索引节点中判断合并的时间复杂度在最差情况下为O(mm),因此MergeIndex算法的时间复杂度为O(kmm).定理8.算法IncrementIns的时间复杂度为O(n+kmm),其中n为增量数据中节点个数,m、m分别为原索引和增量索引中的索引节点数.证明.算法IncrementIns中LK_Create的时间复杂度为O(n+(k-1)m)(定理4),MergeIndex的时间复杂度为O(kmm)(定理7),由于SplitIndex的时间复杂度为O(k)(定理6),则对于c1个新弧,步3~4的时间复杂度为O(c1k),由于IndexNode-Merge的时间复杂度为O(k),则对于c2个需要合并的节点,步5~7的时间复杂度为O(c2k),综上所述,算法IncrementIns的时间复杂度为O(n+(k-1)m+kmm+k(c1+c2)),又因k,c1和c2可看作常数,则算法IncrementIns的时间复杂度为O(n+kmm).4.2.3节点删除不失一般性,假设所删除节点为叶子节点,那么索引更新过程如下:定位删除节点所在索引节点,并删除该节点.删除后,如索引节点扩展集合为空,则删除索引节点.对删除节点的后继(引用弧)所在索引节点进行分裂,直至后继与删除节点层数相差k或无分裂产生为止.算法6.删除节点DeleteNode(L,u).输入:IndexLanddeletenodeu输出:updatedindexL1.locatetheindexnodeI,whichhastheelementeandu∈e.Ne2.deleteufrome.Ne;3.IFe.Ne==NULLTHEN4.deleteefromext(I);ifext(I)isnull,thendeletePage75.FOReachreferencearcfromutov6.SplitIndex(L,〈u,v〉);7.FOReachindexnodeI∈L.IV-S8.FOReachindexnodeI∈L.IV-I-S9.IF(IndexNodeMerge(I,I,k)!=NULL)10.S=S∪I;break;11.RETURNL;定理9.算法DeleteNode的时间复杂度为O(c2k),其中c2为需要合并的节点.证明.算法DeleteNode中SplitIndex的时间复杂度为O(k),IndexNodeMerge时间复杂度为O(k),则对于c2个合并节点,时间复杂度为O(c2k),综上所述,算法DeleteNode时间复杂度为O(c2k).5性能分析5.1实验环境与方法实验选取XMark和DBLP数据集作为测试数据,数据概况见表1.由于当查询路径长度不大于k+1时,A(k)-index不需要在原图上进行验证,因此L(k)-index和A(k)-index的执行效率相同,为了进行比较,本文选取的测试路径长度大于k+1.由于目前没有A(k)-index更新算法的研究,本文主图3索引创建时间比较要参考文献[2]和文献[7]的更新方法,实现一种A(k)-index更新算法(naiveIns).由于文献[2]和文献[7]只涉及子图添加和边添加更新,没有节点删除方法,因此本文没有进行节点删除下更新的比较实验.如果运行时间超过12h,则认为未完成.数据集数据量/KB节点数引用数X0.5M56885181338X1MX1.5M1601X2MX10M1044515128923360X30M3153945274969120X50M50995736070112682X70M708611018449156147DBLP2349705648116400956DBLP158211263965.2性能分析(1)索引创建时间比较由于在大数据集X30M,X50M,X70M和DBLP下,A(k)-index未完成,所以这里只给出了在X0.5M,X1M,X1.5M,X2M和X10M下k=0~3的比较结果,以及DBLP1下k=0~2的比较结果,如图3所示.可以看出,在X1M,X1.5M,X2M,X10M和DBLP1下,L(k)-index较A(k)-index平Page8均提高了66.7%,在X0.5M下二者相似,其原因在于X0.5M节点相对较少,A(k)-index判断父子关系的时间降低,而对于L(k)-index来说,由于需要更新后继节点的PID,因此导致二者时间近似.但随着节点的增加,A(k)-index判断父子关系的时间增加,而对于L(k)-index来说,需要更新的后继节点只与不同标签路径数量相关,与数据节点数量无关.L(k)-index大数据集创建时间如图4所示,在DBLP数据集上为634min,A(k)-index均超过12h.当引用节点数增加时,不同标签路径数也相应增加,如图5所示,L(k)-index创建时间依赖于索引标签路径数,其创建时间也相应增加,而A(k)-index主要依赖于节点数,因此其创建时间变化较小.图5不同引用节点比例下索引创建时间(X1M,k=3)(2)索引空间大小比较这里我们采用空间增加比率(SR)作为评价指标,即SR=(L(k)索引大小-A(k)索引大小)/A(k)索引大小.XMark数据集上L(k)-index与A(k)-index的空间大小比较如图6所示,可以看出,SR平均为22.5%,并且随着数据集节点的增加而减少.DBLP1数据上SR平均为27.6%.当引用节点增加时,不同的pid可能性增加,因此L(k)-index随引用节点增加其SR有增大趋势(如图7所示).如图8和图9所示,实际数据中入度大于1的节点比例非常小.本实验中XMark数据的深度h最大为17.因此索引节点中的元素个数要远远小于最坏上界2(h-1)d-1,平均标签路径数为2,尤其对于深层次的非叶子节点更是如此.(3)索引更新时间比较图10给出了在X0.5M数据集上,k=3,依次插入增量数据时,L(k)-index更新时间.这里比较了IncrementIns与naiveIns方法的更新时间,可以看出,由于采用了批量更新方法,并且无须从k=0开始重新构造索引,因此IncrementIns的更新时间随增量数据大小变化很小,而naiveIns的更新时间远远大于IncrementIns.图11给出了在X0.5M,Page9X1M,X1.5M,X2M和X10M,k=3下分别随机删除20个节点时,L(k)-index平均更新时间.Incre-mentIns每节点更新时间较naiveIns平均提高58.8%.(4)路径查询处理比较图12比较了在L(3)-index与A(3)-index下路径查询平均时间.可以看出,较A(3)-index,L(3)-index上的查询时间平均提高了68.9%.根据定理2可知,L(k)-index是安全和准确的,当查询路径长度大于k时,无须在原图上验证,只需通过pid即可以确定查询结果.因此在L(k)-index上路径查询的时间复杂度与PID的大小成正比,如果取最大PID集合,设大小为c,则其时间复杂度为O(c).而对于A(k)-index,当查询路径长度大于k时,必须在原图上验证,其时间复杂度为O(n),n为查询结果数量.6相关工作目前关于提高XML查询效率的研究主要有两方面,一是基于节点编码的技术,其主要思想是利用编码来判断节点的父子或祖孙关系,采用归并连接(Mergejoin)思想来提高效率[8-11].一是基于结构索引的技术,其主要思想是通过对路径压缩,建立一个远远小于原XML数据的图结构,通过遍历索引来提高查询中路径信息的处理效率.典型的结构索引有DataGuide[1]、1-index[2]、A(k)-index[3]、D(k)-index[4]、APEX[12]及M(k)-index[13]等等.DataGuide基本思想是基于将NFA转换为DFA的形式对相同路径进行约简,但DataGuide存在冗余现象.1-index、A(k)-index和D(k)-index均为基于k双拟的结构索引.通过对局部路径信息的合并,大大降低索引中节点冗余.它们构建方法类似,均是从k=0开始构建,并且需要多次访问原图获得节点的后继.而L(k)-index不需要访问原图,可以批量计算节点的后继.在索引更新上,文献[2,7]提出1-index的更新算法,文献[4]借鉴1-index更新算法和文献[7]的更新算法,提出D(k)-index更新算法.1-index和D(k)-index采取的更新策略类似,对新添加数据构建索引,然后需要从k=0开始重新构建索引.而本文更新方法在对增量数据创建索引后,由于L(k)-index包含完全标签路径信息,因此无须从k=0开始重新构建,而是通过合并和分裂操作完成更新.APEX引入了依赖于XML数据查询分布的信息,将经常出现的XML查询语句对应的标签节点预先保存在一个哈希结构中.M(k)-index索引结构与D(k)-index类似,尝试随查询语句动态调整的方式.当查询路径长度大于k时,基于k双拟的结构索引是非准确的,必须在原数据上进行验证.在XML检索和XML非完全结构查询中,除了提高XML查询效率,越来越多的应用要求获得节点的标签路径或k祖先.例如,在XSearch[14]、XRank[6]和XKeyword[15]中根据节点的标签路径来过滤结果,从而返回有意义的查询结果.在文献[16-17]中要求计算节点或标签路径的最小公共祖先(LCA).然而迄今为止,基于k双拟的结构索引设计目的是提高路径查询效率,并不支持节点标签路径获得和k祖先计算.PE索引[5]在支持路径查询的基础上,同时支持标签路径获得和节点k祖先计算,但PE索引存在大量冗余.文献[18]从XML查询角度出发设计了基于自动机的XML索引,而非本文XML数据相关索引,其主要用于移动环境的数据查询.文献[19]提出一种基于扩展Dewey编码的XML查询方法,其扩展Dewey编码可以获得节点标签,但未对XML数据构建结构索引.文献[20]提出基于Dewey编码的XML关键字倒排索引,主要用于XML检索.7结论本文着重研究了一种支持标签路径的基于k双Page10拟的结构索引的高效创建、更新方法以及查询处理方法.主要贡献有:(1)提出一种支持标签路径的基于k双拟的结构索引L(k)-index,它在保持k双拟结构索引优点的基础上,克服了查询结构重新验证的缺点,是一种准确的和安全的结构索引,查询处理时间效率平均提高了68.9%,而空间复杂度增加仅为22.5%.(2)提出一种高效的索引创建算法,仅需遍历原XML数据一次创建L(0)-index,而L(k)-index创建在L(0)-index的基础上直接获得,无须访问原数据,并采用批量计算后继方法,创建效率较传统方法提高了66.7%.(3)提出了L(k)-index更新方法,设计了基本的更新操作算法:合并和分裂.特别是当增量添加节点时,通过“对增量建索引,然后合并”策略,较传统方法提高了58.8%.
