Page1二值命题逻辑的无损求解唐益明1),2)刘晓平1)1)(合肥工业大学计算机与信息学院情感计算与先进智能机器安徽省重点实验室合肥230009)2)(合肥工业大学信息与通信工程博士后科研流动站合肥230009)摘要针对协同问题求解、协同设计等诸多领域中存在逻辑冲突的共性问题,从二值命题逻辑理论出发,研究面向冲突的无损求解(即初始解空间获取)问题.首先,提出简单合取式的扩充和Wh-析取范式等概念,在此基础上定义初始解空间,并通过提出的有效扩充概念得到初始解空间的简化表示———最简解空间,探讨了两类解空间的关系及各自的计算方法.其次,构造生成序列来辅助公式的析取化,从泛代数的角度定义了Wh-代数;提出了指数矩阵,并籍此给出了Wh-代数的等价表现形式,通过引入扩展指数矩阵构造出扩展Wh-代数.最后证明了扩展Wh-代数中的展开定理和逻辑简化定理,给出基于有效扩充的直接无损求解算法,并与提出的其他相关算法进行了对比,结果表明该算法较为理想.该研究对于协同问题求解等领域有着重要的推动作用.关键词协同计算;冲突;二值命题逻辑;无损求解1引言作为日常生活和工作中极其频繁的行为,讨论是人们传递信息、交流经验、产生思维碰撞,进而实现问题求解[1-2]的一种重要方式.尤其是对于较复杂的问题,常常需要通过协同讨论[3-4]的方式来解决.通常,针对问题求解的协同讨论并非是无领导无目标的聊天,而是一个在有限时间内由主持人指挥、其他参与者提出观点、相互启发的有秩序有目标的协同的过程,并期望在讨论结束后能够取得较优的问题求解方案.但是,这种基于讨论的协同问题求解的效率和质量往往并不理想.其原因主要在于:(1)在讨论过程中,很有可能在较长时间内陷入某个事实上并不理想的方案中,甚至把大量时间浪费在与核心问题关系并不密切的观点的讨论中;(2)有些好的想法,可能被忽略,或者一带而过,并没有深入下去(而这些想法可能恰恰正是解决问题的关键突破口);于较复杂的问题的理解和把握,更是远远不足;(3)人的思维的广度和深度都很有限,尤其对(4)不同人的观点存在冲突,即一些人的观点是对他人观点的否定;或者几个人的观点中存在彼此冲突的情形.这往往导致争论不休的状况,加剧了问题的复杂性,甚至导致迟迟找不到理想的方案.针对该问题,我们在文献[5]中构建了一种协同问题求解的形式化模型.具体而言,为了有效地表达协同讨论中思维转换的过程,提出参与者驱动的双向思维导图(PTMM)和解驱动的双向思维导图(STMM)的概念及生成方法,并构建了基于PTMM和STMM的菱形序列模型,并在协同讨论过程中以可视化的方式予以动态展示.该模型有效启发了人们的思维,提升了协同讨论的效率和质量.然而,该处理方式对于协同问题求解中的冲突问题尚未涉及.如果能够通过计算机辅助的方式,帮助人们进行冲突的分析、定位与消解,则对于协同问题求解有着本质性的推动作用.更一般的,不仅是在协同问题求解领域存在冲突的情形,在协同设计[6-10]、人工智能[11-12](如不相容问题研究)、创新[13-14]和决策[15-16]等领域,也均存在大量的冲突(或称矛盾)情形.文献[7]利用二值命题逻辑理论来表示概念设计的功能树模型,并指出概念设计的核心是功能模型的创新推理,而创新推理是指对概念设计中存在的冲突进行创新变换,得到创新解的过程,但文中未对矛盾式作任何的特殊处理.文献[8]进一步针对协同概念设计的任务划分问题,提出模块驱动的任务前驱图,以此进行协同任务模块间关系的表示,得到从创新推理(及其中的冲突)出发的协同任务划分算法.Lam等人[9]研究了协同新产品开发中的冲突处理问题,分析了其中起关键作用的成功要素,并提出了冲突管理的层次化模型.文献[10]针对多学科协同设计实现了一致性模型求解框架,其可以检测潜在冲突,得到所求的可行解空间.蔡文在文献[11]中强调了矛盾问题的广泛存在性,系统总结了专门研究矛盾问题的可拓学多年来的研究成果,并指出可拓学最重要的理论基石是可拓集合和可拓逻辑,而可拓逻辑又是从Fuzzy逻辑延伸出来的产物(注意到Fuzzy逻辑可视为二值命题逻辑的推广[12]),文中特别强调了人工智能中不相容(即矛盾)问题的相关研究.当前创新理论中,可拓学与TRIZ(发明问题解决理论)是两种最重要的方法,其核心思想均是通过对冲突的消解来实现创新[13-14],Huang[13]和Low等人[14]分别给出了其在商业匹配评价系统和绿色设计中的研究和应用.文献[15]对于决策中规则的冲突和冗余进行研究,利用二值命题逻辑的方式来表达规则,借助条件概率理论给出相应的冲突处理算法,从而能够预防或减少决策制定中的错误.文献[16]指出声明式策略语言XACML缺乏对规则冲突检测、冗余分析的支持;分析了XACML中的各种规则冲突类型,建立了策略索引结构,籍此给出相关冲突检测算法,并推导了多种合并算法下的规则冗余判定定理.可见这些领域中冲突的处理,大多采用逻辑推理的方法来研究,即或者采用二值命题逻辑,或者采用其他逻辑(往往可视为二值命题逻辑的推广或扩展).那么研究二值命题逻辑理论中的冲突问题,将对这些领域的发展有着深刻的推动作用.以下是一个协同问题求解的小例子.例1.香港的车辆靠左行驶,中国大陆的车辆靠右行驶,那么如何将这两个交通体系联接到一起?对于该问题,如果直接联接的话,很有可能发生撞车事故.显然这是个冲突问题,表面上看起来无解.但事实上,通过多方的协同探讨,可采取某些特殊的处理手段来消解冲突.比如已建成的深圳皇岗-落马洲大桥(用来连接大陆与香港),其桥面为双向六车道,设置成螺旋型引桥,成功地解决了该冲突问题.从例1可以看出:在这类问题中往往需要保留冲突(而不能直接将其抛弃),因为许多看似矛盾、无Page3解的问题,通过某种处理往往就变得有解了(这就是冲突的消除).冲突问题研究的核心是分析并消除冲突,因此要研究二值命题逻辑理论中的冲突问题,首先要对其中的冲突情形进行分析,即获得所有的冲突情形.在二值命题逻辑理论中,冲突最主要的体现形式就是矛盾式,但是其中的矛盾式被视作绝对的不可满足的公式来对待,那么在这类问题中就造成了冲突情形的损失.我们围绕矛盾式来考察一下二值命题逻辑理论中冲突的形式,可分为3种情形:第1种是公式本身是矛盾式(如创新所考察的冲突);第2种是几个公式之间存在冲突(包括公式集之间,如决策中规则冲突),如A和B冲突,那么这可转化为A∧B是矛盾式的研究;第3种情形(如概念设计中的冲突情形),对于任意公式A,不考虑其是否矛盾式,总可以从中得到两个部分,一部分是可满足的情形(即满足A的所有赋值[12]),另一部分是其蕴含的冲突情形(例1仅蕴含一种冲突情形,而更一般地,可以含有多种冲突情形).由于第3种情形包含前面两种情形,本文就针对第3种情形进行研究.为了方便,将其可满足情形和蕴含的冲突情形分别称为公式A的可行解和冲突解(两者统称为初始解).那么,冲突分析就转化为获取初始解空间的问题.由于前面出现的损失,所以这里希望获得无损失的、完整的初始解空间,因此又可称获取初始解空间的问题为无损求解问题.由于无损求解处于整个冲突处理过程的前端,是对最初源问题的处理,因此无损求解的质量对后期处理有着根本性的影响.如前文所述,当前虽然存在针对冲突问题进行处理的研究,但针对二值命题逻辑中的公式进行无损求解的研究尚未见到.这里对二值命题逻辑中的无损求解问题进行系统研究.以下首先从Wh-范式、扩充和有效扩充的角度给出初始解空间和最简解空间的定义和结构.其后提出扩展Wh-代数,籍此给出基于有效扩充的直接无损求解算法,并与相关算法进行了对比.2预备工作定义1[12].设S={p1,p2,…},作F(S)如下:(1)p1,p2,…∈F(S).(2)若A,B∈F(S),则A→B,A∈F(S).(3)F(S)中的元都可通过(1)和(2)得到.则F(S)是S生成的(,→)型自由代数.称S中的元为原子公式(或原子命题),称F(S)中的元为公式(或命题).又记A∨B=A→B,A∧B=(A∨B).定义2[12].设v:F(S)→{0,1}是映射,若满足(A,B∈F(S)):(1)v(A)=1-v(A);(2)v(A→B)=0当且仅当v(A)=1,v(B)=0,则称v为F(S)的赋值.F(S)的全体赋值之集记作Ω.若在{0,1}中规定a=1-a,并且a→b=0当且仅当a=1,b=0,则v为同态.不难得到a∨b=max{a,b},a∧b=min{a,b}.对于公式A∈F(S),若存在赋值v使得v(A)=1,则称赋值v满足A[12].由于在实际问题中考虑的原子公式数是有限的,即S是有限集,故以下针对有限原子公式集进行处理.注意到任意赋值均对应一个简单合取式(指原子公式或其否定的合取,如p1∧p2).例如赋值v符合:v(p1)=1,v(p2)=0,v(p3)=1(此时S={p1,p2,p3}),则令B=p1∧p2∧p3(只要令v(B)=1,就可得到这个赋值).因此,就“满足”概念而言,赋值可以用其对应的简单合取式代替,即将赋值对应的“满足”转化为简单合取式的“满足”,同时考虑到简单合取式较方便,因此以下采用简单合取式作为满足某公式的初始解.如A=(p1∧p2∧p3)∨(p1∧p2),则简单合取式B=p1∧p2∧p3满足A(因为此时B对应的所有赋值v均满足A).在二值命题逻辑理论中,可靠性和完备性定理成立,因此定理与重言式是一致的.设A,B∈F(S),用A≈B表示A与B逻辑等价,用A~B表示A与B可证等价,两者本质相同.逻辑等价与可证等价是同余关系,以[F]表示商代数F(S)/≈,以[A]记A所在的同余类.规定[A][B]当且仅当对每个v∈Ω,v(A)v(B),则是商代数上的偏序.称([F],)为Lindenbaum代数(可证其为Boole代数),其中全体重言式(即定理)的集合是([F],)的最大元1,全部矛盾式的集合是最小元0(在不致混淆时,也用0和1直接表示矛盾式、重言式).以A表示A为重言式,├B表示B为定理.令F(S)中简单合取式的集合为Scj(S),若一个简单合取式中同时包含某原子公式与其否定,则称其为矛盾合取式(如p1∧p1∧p2,令其全体构成Ccj(S)),反之称为一般合取式(构成Ncj(S)).二值命题逻辑公式是表达实际问题的一种重要方法.例如,针对协同概念设计领域,文献[7-8]利用二值命题逻辑来刻画与或非功能树模型.又比如协Page4区分;区分;同问题求解领域,对于问题Q,原子命题p1,p2表达Q的基本解(或其它基本的情形).那么,p1∨p2表示p1、p2都是该问题的解;p1∧p2表示p1与p2必须同时实现,才能构成该问题的解;p1表示p1的否定,是该问题的解;p1→p2表示如果p1,则p2.例2.这里给出协同问题求解的一个具体实例.在某校计算机学院的高层教授论坛中,针对哪些SCI期刊属于顶级期刊的议题,各位教授展开了激烈的讨论.对于协同讨论的过程进行汇总,提炼其中得到的解决方案,这里列出部分原子方案(即问题的原子解):[(p2∨p5)∧((p1∧p2)∨p6)].p1:顶级期刊取决于其影响因子;p2:期刊的级别应按照影响因子来排序;p3:顶级期刊以影响因子是否超过1.0来进行p4:顶级期刊以影响因子是否超过1.8来进行p5:应参照某著名高校制定的顶级期刊列表;p6:顶级期刊取决于该期刊的国际影响力.通过二值命题逻辑公式来表达其方案的结构,可得到如下公式:Q=[(p1∧p2∧(p3∨(p3∧p4)))∨(p2∧p5)]∨其中,以(p1∧p2∧(p3∨(p3∧p4)))为例,这部分公式表示:顶级期刊取决于其影响因子,并应根据影响因子来排序,同时可以采取1.0或者1.8的分界线.这里需要指出的是,这些观点是通过激烈的讨论来得到的.比如p4是先对p3进行否定,觉得1.0的分界线太低,并得到了1.8作为分界线的方案.而p6则认为“仅考虑影响因子”是不对的,应根据期刊的国际影响力来决定其档次.3二值命题逻辑中的初始解空间3.1初始解空间的定义首先给出AND/OR式的定义.分析这类公式:g1=p1∨p2,g2=(p1∨p2)∧(p3∨p4),g3=[(p1∨p2)∧(p1∨p4)]∨[(p1∨p3)∧p2].考察这类公式的两类连接词:析取与合取(这里暂不考虑否定).以g3为例,g3(即第3层)外围的连接词是析取,且第2层的公式A1,A2(通过对g3分解得到)外围的连接词都是合取,而第1层公式的连接词都是析取,则称g3为AND/OR式,如图1所示.其中,层数定义为:在分解过程中,如果第1次出现某一层,该层所有的公式都是简单析取式(或都是简单合取式),则称该层为第1层;而分解出第1层公式的公式,其层数为2,依次类推.总之,如果对于一个公式,其各层公式外围的连接词都是析取(或都是合取),而且对于各层,析取与合取依次交替,则称这类公式为AND/OR式.通过严格的形式化描述,可以得到定义3.定义3.F(S)中下列两类公式称为AND/OR式:(1)g1=px11∨…∨pxnn(g1的层数为1,其中xi∈{1,-1,0,2},p1i=pi,p-1i=pi,p2i表示pi、pi均出现,p0i表示pi不出现,pi∈S,i=1,…,n);g2m=g(1)∧g(2)∧…∧g(k2m)(g2m的层数为2m,k2m表示g2m中相合取的公式个数,g(1),…,g(k2m)中至少有一项的层数为2m-1);g2m+1=g(1)∨g(2)∨…∨g(k2m+1)(g2m+1的层数为2m+1,k2m+1表示g2m+1中相析取的公式个数,g(1),…,g(k2m+1)中至少有一项的层数为2m,注意这里的g(1)与上一段中的g(1)不是同一个公式,其余类似).(2)类似地,h1=px11∧…∧pxnn;h2m=h(1)∨h(2)∨…∨h(k2m);h2m+1=h(1)∧h(2)∧…∧h(k2m+1).其中外围为“∨”、“∧”的AND/OR式分别称为OR-AND式和AND-OR式.如g2m+1、h2m为OR-AND式,g2m、h2m+1为AND-OR式.为了方便,若公式A≈B,则称从A到B的映射op为一个操作.另外,分配律可分为opa(B1∨(B2∧B3))=(B1∨B2)∧(B1∨B3),opb((B1∨B2)∧(B1∨B3))=B1∨(B2∧B3),opc(B1∧(B2∨B3))=(B1∧B2)∨(B1∧B3)和opd((B1∧B2)∨(B1∧B3))=B1∧(B2∨B3)4种情况.以下从取得步骤的角度给出了Wh-范式的定义.定义4.按照二值命题逻辑理论,F(S)中任何一个公式Q都逻辑等价于一个析取范式[17],而求析取范式可通过3个步骤,这里将其适当调整为4个步骤:(1)将公式中的连接词化归为、∨和∧.(2)利用DeMorgan律将否定符号直接移到Page5各个原子公式之前,并利用对合律去除双重否定.(3)利用结合律,可以将其转化为AND/OR式(唯一的).(4)利用分配律opc和结合律将公式化为析取范式.称由此得到的析取范式为Wh-析取范式,简称为Wh-范式.为了方便,文中以下部分均假定公式中的连接词已经化归为、∨和∧.二值命题逻辑理论中,其转化为析取范式的第(1)、(2)步与这里相同,而第(3)步为:利用分配律opc(即利用∧对∨的分配律)、结合律将公式化为析取范式,但这里将其调整为(3)和(4)两个步骤.其中(3)是为了处理的方便,同时结合律是将(A∨B)∨C转化为A∨B∨C之类的处理,对问题本身不产生直接影响.(4)未作改变.但在二值命题逻辑理论中,也常同时采用其他定律(如幂等律、交换律、吸收律等).考虑到幂等律、交换律不对问题本质产生影响,因此在第(4)步中也可同时运用幂等律和交换律.例3.设Q=(((p1∨p2)→p3)∧p2)∧(p4∧p5).(1)将其转化为Wh-范式.执行定义4中的(1),得Q=(((p1∨p2)∨p3)∧p2)∧(p4∧p5);执行定义4中的(2),得Q=(((p1∧p2)∨p3)∧p2)∧(p4∨p5);执行定义4中的(3),得到AND/OR式Q=((p1∧p2)∨p3)∧p2∧(p4∨p5);执行定义4中的(4),得到其Wh-范式:Q=(p1∧p2∧p2∧p4)∨(p1∧p2∧p2∧p5)∨(p2∧p3∧p4)∨(p2∧p3∧p5).(2)二值命题逻辑理论中,主析取范式是一个重要的概念.为了便于理解,这里也把该式的主析取范式给出,以作对比.如下式所示,最后得到的主析取范式有8个析取项.Q=(((p1∨p2)→p3)∧p2)∧(p4∧p5)=(((p1∨p2)∨p3)∧p2)∧(p4∧p5)=(((p1∧p2)∨p3)∧p2)∧(p4∨p5)=(p1∧p2∧p2∧p4)∨(p1∧p2∧p2∧p5)∨(p2∧p3∧p4)∨(p2∧p3∧p5)=(p2∧p3∧p4)∨(p2∧p3∧p5)=(p1∧p2∧p3∧p4∧p5)∨(p1∧p2∧p3∧p4∧p5)∨(p1∧p2∧p3∧p4∧p5)∨(p1∧p2∧p3∧p4∧p5)∨(p1∧p2∧p3∧p4∧p5)∨(p1∧p2∧p3∧p4∧p5)∨(p1∧p2∧p3∧p4∧p5)∨(p1∧p2∧p3∧p4∧p5).由例3可以看出Wh-范式与主析取范式的几点不同:(1)两者都是由简单合取式析取而成,但是Wh-范式中保留矛盾合取式,而主析取范式仅保留一般合取式(把矛盾合取式都抛弃了);(2)主析取范式中的每个析取项(即一般合取式)中,所有的原子公式都必须出现且仅出现一次,但Wh-范式不必如此.例4.对于例2的逻辑公式,类似于例3,可得到其Wh-范式为:Q=[(p1∧p2∧(p3∨(p3∧p4)))∨(p2∧p5)]∨[(p2∨p5)∧((p1∧p2)∨p6)]=(p1∧p2∧(p3∨(p3∧p4)))∨(p2∧p5)∨((p2∨p5)∧((p1∧p2)∨p6))=(p1∧p2∧p3)∨(p1∧p2∧p3∧p4)∨(p2∧p5)∨(p1∧p2∧p2)∨(p1∧p2∧p5)∨(p2∧p6)∨(p5∧p6).以下用Q=f(p1,…,pn)表示Q为F(S)中由原子公式p1,…,pn和连接词表达的公式,而且在未作特殊说明时表示p1,…,pn在Q中均出现.为了方便,分别用Σ、Π表示多个∨、∧的复合.不难证明命题1.命题1.设Q=f(p1,…,pn),则Q的Wh-范式唯一(在幂等、交换的意义下).以下分析一下扩充的思想.比如对于一般合取式A=p1∧p2,B=p1∧p2∧p3,则所有满足B的赋值v(即v(B)=1),都满足A(因为此时必然有v(p1)=v(p2)=v(p3)=1,从而v(A)=1).那么,我们就称B为A的扩充(或A扩充出B).更进一步地,对于矛盾合取式A=p1∧p1∧p2,B=p1∧p1∧p2∧p3,B也称为A的扩充.对于析取范式A=A1∨A2,其中A1=p1∧p2∧p3,A2=p1∧p2∧p3,则显然A≈p1∧p2.那么,我们称公式集{A1,A2}扩充出p1∧p2.又假设A1=p1∧p2∧p3可扩充出p1∧p2∧p3∧p4,则{A1,A2}也扩充出p1∧p2∧p3∧p4.更进一步地,如果A=A1∨A2∨A3,其中A1=p1∧p2∧p3,A2=p1∧p2,A3=p1∧p3.注意到A2可扩充出A4=p1∧p2∧p3,则{A1,A4}可扩充出A5=p1∧p3,而且{A3,A5}可扩充出p1.那么称{A1,A2,A3}扩充出p1(从赋值的角度也容易得到A≈p1).由这种思想出发,可以得到扩充的具体定义(见定义5).定义5.(1)设S1={p1,…,pn},A=f(p1,…,pm)∈F(S1)为一个简单合取式,令SA为A中出现的原子公式的集合(以下同),S2=S1-SA,S3为Page6S2的任一子集,称B=f(p1,…,pm)∧∏pk∈S3在F(S1)中的扩充(其中xk∈{-1,0,1},也称A扩充出B),并称这样的扩充全体为A在S1中的扩充集,记为A(S1).(2)设S1为有限的原子公式集,UF(S1)为若干个简单合取式构成的集合,易知存在可数序列:U(1),U(2),…,其中,U(1)=U,U(i+1)由下列元素组成(i=1,2,…):①U(i)中的元素都属于U(i+1);②若U(i)中存在形如D1=D∧px11∧…∧pxmm,D2=D∧p-x11,…,Dm+1=D∧p-xmm的元素,其中m1,x1,…,xm∈{-1,1},D为简单合取式,且不含有p1,…,pm(D可以为1,这里视“1”为一个特殊的简单合取式,此时D1=px11∧…∧pxmm,D2=p-x11,…,Dm+1=p-xmm),则D属于U(i+1);③U(i+1)中不再含有其它元素.由于S1为有限集,则必存在唯一的正整数SN(U),使得对于任意正整数nSN(U)有U(n)=U(SN(U)),且对于任意满足1n<SN(U)的正整数n有U(n)真包含于U(SN(U)).又存在可数序列U(S1,1),U(S1,2),…,其中U(S1,1)=∪A∈U(SN(U))A(S1),且U(S1,j+1)=∪A∈V(SN(V))A(S1)(这里V=U(S1,j),j1).同理可知存在唯一正整数BN(U,S1),使得对于任意nBN(U,S1)有U(S1,n)=U(S1,BN(U,S1)),且对于任意满足1n<BN(U,S1)的正整数n有U(S1,n)真包含于U(S1,BN(U,S1)).称U(S1)=U(S1,BN(U,S1))为U在F(S1)中的扩充集.例5.设S1={p1,…,p4},A1=p1∧p2,则B1=p1∧p2∧p4是A1在S1中的扩充,即B1∈A1(S1),但B2=p1∧p2∧p2,B3=p1∧p2∧p5A1(S1).又如A2=p1∧p3∧p3,那么B4=p1∧p3∧p3∧p4∈A2(S1).又比如,设S1={p1,…,p8},且U={p1∧p1∧p2,p1∧p1∧p2,p3∧p4∧p5,p3∧p4,p3∧p5,p6∧p8,p7∧p8},则U(1)=U,且U(SN(U))=U(2)=U(1)∪{p1∧p1,p3}.以下命题2是显然的.利用二值命题逻辑理论中的演绎定理、三段论规则、完备性和可靠性定理[12],易证得引理1.命题2.设Q=f(p1,…,pn),U为其对应的任一析取范式中析取项集合,A∈U(SQ),则A→Q.引理1.设A,B,C∈F(S),A→B且B→A(SQ)∪A∈U(SN(U2))C,则A→C.命题3.设Q=f(p1,…,pn),Q1为其主析取范式,Q2为其Wh-范式,U1,U2分别为Q1,Q2中一般合取式(析取项)的集合,则U1(SQ)=U2(SQ).证明.若Q≈0,则U1(SQ),U2(SQ)为空集,故相等.下设Q不与0逻辑等价.任意一般合取式A∈U2(SQ),由命题2得A→Q,则必定存在U3={B1,…,Bm}U1(m1),其中Bi为主析取范式中某一项(i=1,…,m),满足B1∨…∨Bm≈A且A∈3,则A∈U(SN(U1U(SN(U3))U1(SQ).反之,任意一般合取式A∈U1,则必定存在B∈U2使得A→B,且A∈B(SQ).事实上,Q≈Q1≈Q2,则Q→Q2,由命题2和引理1知A→Q,且A→Q2.当v(A)=1时,由A是主析取范式中的一项,即A=px11∧…∧pxnn(xi∈{1,-1}),则v(A)=1必定唯一决定一个赋值,仍记作v,则v(Q2)=1,则Q2的析取项中至少存在一般合取式B∈U2满足v(B)=1,则A→B.设B=py11∧…∧pynn(yi∈{1,-1,0}),由A→B,可知或者yi=xi,或者yi=0(i=1,…,n),由定义5得A∈B(SQ),则U1∪A∈U2易得(U2(SQ,1))(SQ)=U2(SQ),则U1(SQ)U2(SQ).从而U1(SQ)=U2(SQ).命题4.设Q,Q1,Q2,U1,U2同命题3,则{A∈Ncj(SQ)|A→Q}=U2(SQ)=U1(SQ).证明.若Q≈0,则结论显然成立,下设Q不与0逻辑等价.由命题2得U2(SQ){A∈Ncj(SQ)|A→Q}.今设任意一般合取式A满足:A→Q,则必存在U3={B1,…,Bm}U1(m1),其中Bi为主析取范式中某一项(i=1,…,m),使B1∨…∨Bm≈A且A∈U(SN(U3)){A∈Ncj(SQ)|A→Q}U1(SQ)=U2(SQ).总之,{A∈Ncj(SQ)|A→Q}=U2(SQ)=U1(SQ).证毕.定义6.设公式Q=f(p1,…,pn)∈F(S),如果简单合取式A∈Scj(SQ),且满足以下条件之一:(1)A为一般合取式,且A→Q;(2)A为矛盾合取式,且A∈U(SQ),U为Q的Wh-范式中析取项(即简单合取式,下同)的集合,则称A为Q的初始解,其全体称为Q的初始解空间Solu(Q).其中矛盾合取式部分记为CSolu(Q),一般合取式部分记作GSolu(Q),则Solu(Q)=GSolu(Q)∪CSolu(Q),GSolu(Q)∩CSolu(Q)=.前文已然说明:简单合取式可作为Q的初始解.对于其解,分为两个部分,式(1)很自然,由A→Page7Q,则一般合取式A成立时,Q成立.对于式(2),由于冲突分析的基本思想是提取出原公式Q中自身蕴含的冲突,因此将Q中自身蕴含的冲突保留下来;但如果冲突不是Q中自身蕴含的,则不能“人为”制造冲突,故不作为Q的冲突解.因此定义6是合理的.另外,注意到矛盾合取式没有对应的赋值,这时用赋值就无法表达冲突,而矛盾合取式却可以表达原公式中存在的冲突,这就是用简单合取式(而不用赋值)作为初始解的根本原因.一种计算方式).Wh-范式中析取项的集合.3.2初始解空间的简化表示:最简解空间由命题2~4可得定理1(给出了初始解空间的定理1.Solu(Q)=U(SQ),其中U为Q的不难证明引理2.引理2.设Q∈F(S1),A∈Solu(Q),USolu(Q),则A(SQ)Solu(Q),U(SQ)Solu(Q).定理2.设Q∈F(S1),V为Q的Wh-范式中析取项集合,则存在唯一的最小集合MS-Solu(Q)使Solu(Q)=∪A∈MS-Solu(Q)A(SQ)(其中“最小”是由“集合包含”生成的偏序关系所诱导出的).证明.(1)首先构造出满足条件的一个集合.易知存在可数序列:V(1),V(2),…,其中V(1)=V,V(i+1)由以下元素组成(i=1,2,…):①V(i)中的元素都属于V(i+1);②若V(i)中存在2个形如A1=B1∧px11,A2=B2∧py11的元素,其中x1∈{-1,1},y1∈{-x1,0},B1与B2为简单合取式,均不含有p1,且满足B1∧B2B1(SQ)∩B2(SQ)(与定义5类似,B1,B2可以为1,如B1=1时,A1=px11),则B1∧B2属于V(i+1);③V(i+1)中不再含有其它元素.注意到SQ为有限集,则必存在唯一的正整数LN(V),使得对于任意正整数nLN(V)有V(n)=V(LN(V)),且对于任意满足1n<LN(V)的正整数n有V(n)真包含于V(LN(V)).记VMS(SQ)=V(LN(V)).从VMS(SQ)出发,可构造出一个集合V,其元素由且仅由下列元素组成:若对于VMS(SQ)中的元素A,存在与A相异的元素B∈VMS(SQ)使得A∈B(SQ),则A属于V.记MS-Solu(Q)=VMS(SQ)-V.(2)其次证明对(1)中构造的MS-Solu(Q),有Solu(Q)=∪A∈MS-Solu(Q)A(SQ).由(1)可得∪A∈MS-Solu(Q)A(SQ)=∪B∈VMS(SQ)B(SQ)=∪B∈V(LN(V))B(SQ),则只需证明Solu(Q)=∪B∈V(LN(V))B(SQ).①先证∪B∈V(LN(V))B(SQ)Solu(Q),由引理2,只需证V(LN(V))Solu(Q).对LN(V)归纳可证得该结论成立.②再证Solu(Q)∪B∈V(LN(V))B(SQ).注意到Solu(Q)=V(SQ,BN(V,SQ))=∪C∈V(SN(V1))V1=U(SQ,BN(V,SQ)-1).以下对BN(V,SQ)归纳证明Solu(Q)∪B∈V(LN(V))B(SQ).当BN(V,SQ)=1时,Solu(Q)=V(SQ,1)=∪A∈V(SN(V))A(SQ).只需证V(SN(V))V(LN(V)).对SN(V)归纳可证BN(V,SQ)=1时结论成立.假设BN(V,SQ)k2时结论成立.当BN(V,SQ)=k2+1时,Solu(Q)=V(SQ,k2+1)=∪C∈V(SN(V1))V(SQ,k2)∪B∈V(LN(V))B(SQ).先对SN(V1)归纳证明V(SN(V1))当SN(V1)=1时,V(SN(V1))设当SN(V1)k3时结论成立,则当SN(V1)=k3+1时,V(SN(V1))可知V(k3)5,在V(k3)C3∧p-x11,…,Dm+1=C3∧p-xmm(C3中不含有p1,…,pm,且x1,…,xm∈{-1,1},m1,C3为简单合取式,且可以为1,这里与前文证明中的px11,…,pxmm不同,不苛求其形式的不同).下证C3∈∪B∈V(LN(V))B(SQ).由V(k3)D1,…,Dm+1使D1∈D1(SQ),…,Dm+1∈Dm+1(SQ).若Dm+1不包含p-xmm,则C3∈Dm+1(SQ)∪B∈V(LN(V))B(SQ),已得证.因此无妨设Dm+1包含p-xmm,同理无妨设Dm包m-1,…,D2包含p-x11,D1包含px11,…,pxmm中的含p-xm-1一个或多个,无妨令D1包含px11∧px22,则D1,D2,…,Dm+1可表示为:D1=D1∧px11∧px22,D2=D2∧p-x11,…,Dm+1=Dm+1∧p-xmm,其中C3∈D1(SQ)∩…∩Dm+1(SQ),且D1,…,Dm+1不含有p1,…,pm.首先考察D1,D2.由C3∈D1(SQ)可知:若C3中含有若干对相矛盾的原子公式(指pi∧pi),则D1中有且仅有C3中这几对相矛盾的原子公式.同理D2也是如此.则不难得知D1∧D2D1(SQ)∩D2(SQ),那么D1,D2满足(1)的条件,则D2=D1∧D2∧px22∈V(LN(V)+1)=V(LN(V)).同理,再考察D2,D3,可得D3=D1∧D2∧D3∈V(LN(V)+1)=V(LN(V)),重复该过Page8程,最后得Dm+1=D1∧…∧Dm+1∈V(LN(V)+1)=V(LN(V)).而由C3∈D1(SQ)∩…∩Dm+1(SQ)得C3∈Dm+1(SQ)∪B∈V(LN(V))B(SQ).故SN(V1)=k3+1时结论成立,则V(SN(V1))则对A1∈V(SN(V1))A1∈A2(SQ),从而A1(SQ)A2(SQ)∪B∈V(LN(V))B(SQ),故得Solu(Q)=∪C∈V(SN(V1))则BN(V,SQ)=k2+1时结论成立.至此可得Solu(Q)∪B∈V(LN(V))B(SQ).综合①、②,可得Solu(Q)=∪B∈V(LN(V))B(SQ)=∪A∈MS-Solu(Q)A(SQ).(3)最后证明(1)中构造的MS-Solu(Q)是满足Solu(Q)=∪A∈MS-Solu(Q)A(SQ)的唯一的最小集合.设M2(Q)为满足Solu(Q)=∪A∈M2(Q)A(SQ)的任一集合,要证明MS-Solu(Q)最小,只须证MS-Solu(Q)M2(Q).反证法.假设存在A∈MS-Solu(Q)使AM2(Q),注意到∪A∈M2(Q)A(SQ)=∪A∈MS-Solu(Q)A(SQ),则必存在B∈M2(Q)使得A∈B(SQ).注意到B∈M2(Q)∪A∈MS-Solu(Q)A(SQ),则存在C∈MS-Solu(Q)使得B∈C(SQ).则有A∈C(SQ).这时,若A≠C,由MS-Solu(Q)的构造方式可知AMS-Solu(Q),出现矛盾.若A=C,由定义5易知A=B=C,则A∈M2(Q),仍然矛盾.因此MS-Solu(Q)最小.对于唯一性,假设存在另一个最小集合D,则D与MS-Solu(Q)必定相互包含,故D=MS-Solu(Q),则MS-Solu(Q)唯一.称定理2证明中的VMS(SQ)为V的有效扩充,也称Q的有效解空间,称MS-Solu(Q)为Q的最简解空间.在定理2的证明中提及:若V(i)中存在A1=B1∧px11,A2=B2∧py11,其中x1∈{-1,1},y1∈{-x1,0},B1与B2为简单合取式,均不含有p1,且满足B1∧B2B1(SQ)∩B2(SQ),则B1∧B2属于V(i+1).这里我们通过一个例子来说明其思想来源.设SQ={p1,…,p4},A1=B1∧px14=p1∧p2∧p4(其中B1=p1∧p2,x1=1),A2=B2∧py14=p3(其中B2=p3,y1=0).显然B1,B2均可以扩充出B1∧B2=p1∧p2∧p3,因此B1∧B2B1(SQ)∩B2(SQ).那么,注意到A1可扩充出A3=p1∧p2∧p3∧p4,而A2可扩充出A4=p1∧p2∧p3∧p4,那么{A3,A4}可扩充出p1∧p2∧p3=B1∧B2.由推论1.设Q,V同定理2,则Solu(Q)=此可见,{A1,A2}可以扩充出B1∧B2.∪A∈MS-Solu(Q)A(SQ)=∪B∈VMS(SQ)B(SQ).定理1通过U(SQ)来计算初始解空间,即利用定义5的计算过程,其计算量巨大.而定理2中给出的最简解空间可视为初始解空间的一种简化表示.从最简解空间出发,如果需判断简单合取式A是否为问题Q的初始解,只需验证“是否存在B∈MS-Solu(Q)使得A∈B(SQ)”即可,其实现简单易行;如果需要获取初始解空间,仅需对最简解空间中的各个元素扩充即得,计算量仍较小.同时定理2证明过程给出了先得到有效解空间,然后再求取最简解空间的计算过程,其计算量相比定义5大为缩减(这点在5.2节有专门说明).因此以下通过最简解空间来替代初始解空间进行研究,即将研究重点转化为最简解空间的获取问题.例6.对于例5中的U,设V=V(1)=U,不难得到V(2)=V(1)∪{p1∧p1,p3∧p5,p3∧p4,p6∧p7},且VMS(S1)=V(LN(V))=V(3)=V(2)∪{p3}.注意到p3可扩充出p3∧p5,p3∧p4(由定义5);且p6∧p8和p7∧p8可分别扩充出p6∧p7∧p8和p6∧p7∧p8,由扩充的定义,后两者恰好可扩充出p6∧p7.因此有效扩充与扩充在最后的结果上是一致的.另外,MS-Solu(Q)={p1∧p1,p3,p6∧p8,p7∧p8,p6∧p7}.例7.对于例2和例4中Wh-范式构成的析取项集合,即V={p1∧p2∧p3,p1∧p2∧p3∧p4,p2∧p5,p1∧p2∧p2,p1∧p2∧p5,p2∧p6,p5∧p6},设S1={p1,…,p6},类似可得VMS(S1)=V∪{p1∧p2∧p4,p1∧p3∧p5,p1∧p3∧p4∧p5,p1∧p5∧p6,p1∧p4∧p5,p1∧p2∧p4∧p5}.并且,易得MS-Solu(Q)={p1∧p2∧p3,p2∧p5,p1∧p2∧p2,p2∧p6,p1∧p2∧p4,p1∧p3∧p5,p5∧p6,p1∧p4∧p5}.4扩展Wh-代数由前文可知最简解空间获取的大体过程为:析取化(为了转化为析取表达式)、再依次获得有效解空间和最简解空间.本节和第5节就对最简解空间获取的过程进行细化和深入研究.4.1生成序列定理3.设Q∈F(S1),则存在唯一的序列A1=Q,A2,…,Ak∈F(SQ)(令I为该序列的下标集)使Page9(1)设i∈I,存在唯一的自然数序列i1,…,im∈(i,k],i1<i2<…<im,满足:①令Ii={i1,…,im},则∪i∈IIi=I-{1},且i≠j时,Ii∩Ij=.②以下有且仅有一个等式成立:○2.1Ai=Ai1∨…∨Aim(或者(Ai1∨…∨Aim),m2);○2.2Ai=Ai1∧…∧Aim(或(Ai1∧…∧Aim),m2);○2.3Ai=Ai1(m=1);○2.4Ai=pj(m=0,pj∈S1).记φ(Ai)为Ai所满足等式的右端公式.(2)令Q1=φ(A1),在Q1中把所有出现的Ai置换为φ(Ai)(包括置换某个Ai后出现的新的Aj,这里i,j∈I),记所得公式为Q2,则Q2=Q.证明.设Q∈F(S1),易知存在可数序列:I(0),I(1),…,其中I(0)=,I(1)={1},I(i+1)由下列元素组成(i=1,2,…):①I(i)中的元素都属于I(i+1).②令J(i+1)=I(i)-I(i-1),若J(i+1)不为空,无妨令J(i+1)={j1,…,jm}(让j1<j2<…<jm),依次对每个jt进行考察(t=1,…,m):○2.1如果Ajt=pj(pj∈S1),则令φ(Ajt)=pj,Ijt=;○2.2如果Ajt=Q1,且此时I(i+1)中有q个元素,则令Aq+1=Q1,φ(Ajt)=Aq+1,Ijt={q+1},且q+1属于I(i+1);○2.3如果Ajt=Q1∨…∨Qr或Q1∧…∧Qr,且此时I(i+1)中有q个元素,则令Aq+1=Q1,…,Aq+r=Qr,φ(Ajt)=Aq+1∨…∨Aq+r或φ(Ajt)=Aq+1∧…∧Aq+r,Ijt={q+1,…,q+r}(若外围有括号则保留,如Ajt=(Q1∨Q2)时,φ(Ajt)=(Aq+1∨Aq+2)),且q+1,…,q+r属于I(i+1).得(这里的唯一是指在交换的意义下):③I(i+1)中不再含有其它元素.此时显然存在唯一的正整数N,使得对于任意正整数nN有I(n)=I(N),且对于任意满足1n<N的正整数n有I(n)真包含于I(N).令k为I(N)的元素数,I=I(N),则以上过程中已完成对A1,…,Ak和φ(A1),…,φ(Ak)的构造.不难验证其符合条件(1)和(2),且A1,…,Ak必定唯一.事实上,对于公式Q以及其后出现的所有Ai,必定仅满足题设(1)中的②中4个等式之一,且等式右端由等式左端唯一确定,则在交换意义下A1,…,Ak必定唯一.证毕.在定理3中的证明过程中,给出了从Q唯一得到A1,…,Ak和φ(A1),…,φ(Ak)的生成过程,称其中得到的(φ(A1),…,φ(Ak))Seq(Q)为Q的生成序列.称Ai为序列变量(i=1,…,k).生成序列Seq(Q)给出了公式Q的一种等价刻画方式,从Seq(Q)出发,对照定义4中的(2)、(3),这里给出生成序列的一种相应的处理方法:对于(2),对于Seq(Q),令J={j|φ(Aj)=Am;j,m∈I},无妨令1=∧J(这里∧表示下确界),φ(A1)=A2.令φ(A1)=A2,并对每一个i∈I2,①若φ(Ai)=Ai1∨…∨Aim,则令φ(Ai)=Ai1∧…∧Aim;②若φ(Ai)=Ai1∧…∧Aim,则令φ(Ai)=Ai1∨…∨Aim;③若φ(Ai)=Ai1,则令φ(Ai)=Ai1;④若φ(Ai)=pi,则令φ(Ai)=pi.并且若φ(Ai)是其中①或②情形,则针对每个j∈Ii进行类似处理,如此循环,直至均为③或④的情况.得到Seq1(Q).对于Seq1(Q),重复这样的过程(即再得到新的J进行类似的处理),直至J=为止.对于(3),对于Seq(Q)中φ(A1),φ(A2),若满足φ(A1)=A2∨…∨Am,φ(A2)=Am+t+1∨…∨Am+t+k(或(Am+t+1∨…∨Am+t+k),t1,k1,其中Ai可换为pi,pi;若φ(A1),φ(A2)为合取时可类似处理),则令φ(A1)=Am+t+1∨…∨Am+t+k∨A3∨…∨Am,φ(A2)=0(“0”表示该序列变量不存在).如φ(A1)=A2∨A3,φ(A2)=(A4∨A5),则令φ(A1)=A4∨A5∨A3,φ(A2)=0;又如φ(A1)=A2∨A3,φ(A2)=p1,则令φ(A1)=p1∨A3,φ(A2)=0.并且,将为“0”的序列变量去除,并重新按自然序对剩下的序列变量编号.不难得到处理后的生成序列Seq(Q)CSeq(Q),不致混淆时仍称为Q的生成序列.称CSeq(Q)对应公式(见定理3中的(2))为Q的生成公式,记为Gen(Q)(这就是Q经过定义4中的(2)、(3)操作所得公式).例8.设Q=(p1∧(p1∧p3)∧(p2∧p5))∨(p4∨p5).令A1=Q,A2=(p1∧(p1∧p3)∧(p2∧p5)),A3=(p4∨p5),φ(A1)=A2∨A3,I1={2,3}.再依次处理A2和A3.对A2,令A4=(p1∧(p1∧p3)∧(p2∧p5)),φ(A2)=A4,I2={4}.对于A3,令A5=p4,A6=p5,φ(A3)=(A5∨A6),I2={5,6}.依次类推.最后可以得到Seq(Q)=(φ(A1),…,φ(A17))=(A2∨A3,A4,(A5∨A6),(A7∧A8∧A9),A10,p5,p1,A11,(A12∧A13),p4,(A14∧A15),A16,p5,p1,A17,p2,p3).经过定义4(2),可得(A2∨A3,A4,(A5∨A6),(A7∨A8∨A9),A10,p5,p1,A11,(A12∨A13),p4,(A14∧A15),A16,p5,p1,A17,p2,p3).经过定义4中的(3),得到(p1∨A8∨p2∨p5∨p4∨p5,0,0,0,0,0,0,(p1∧p3),Page100,0,0,0,0,0,0,0,0),其后删除为“0”的序列变量,再经重新编号,最终得到CSeq(Q)=(p1∨A2∨p2∨p5∨p4∨p5,(p1∧p3)).生成序列本质上来源于对公式的分解(从连接词的角度),对于本例,其分解过程如图2所示(其中给出了A1,A2,…,A9的生成过程).例9.对于例2的公式,类似于例8,可得其生成序列Seq(Q)=(φ(A1),…,φ(A25))=(A2∨A3,(A4∨A5),(A6∧A7),(A8∧A9∧A10),(A11∧A12),(A13∨A14),(A15∨A16),p1,p2,(A17∨A18),A19,p5,p2,p5,(A20∧A21),p6,p3,(A22∧A23),p2,p1,A24,A25,p4,p2,p3).经过定义4中的(2)、(3),可以得到(A4∨A5∨A3,0,(A6∧A7),(p1∧p2∧A10),(p2∧p5),(p2∨p5),(A15∨p6),0,0,(p3∨A18),0,0,0,0,(p1∧p2),0,0,(p3∧p4),0,0,0,0,0,0,0).按自然序重新编号可得到最后的生成序列为CSeq(Q)=(A2∨A3∨A4,(p1∧p2∧A5),(p2∧p5),(A6∧A7),(p3∨A8),(p2∨p5),(A9∨p6),(p3∧p4),(p1∧p2)).4.2Wh-代数与扩展Wh-代数本节从定义4中的(3)的结果出发,即针对AND/OR式进行研究.从定义3可知AND/OR式中所有的否定运算均加诸于原子公式.而析取范式也是一类特殊的AND/OR式.为了更好地诠释AND/OR式本质,这里从泛代数[18](主要是其中的T-代数理论)的观点来重新审视AND/OR式.以下命题5是显然的.命题5.设A为F(S1)中AND/OR式(S1={p1,…,pn}),S2={p1,…,pn,p1,…,pn},Fd(S2)为由S2生成的自由T-代数,其中T={∨,∧},则A∈Fd(S2).特别地,如果A为F(S1)中的析取范式,则A∈Fd(S2).设B为Fd(S2)中的析取范式,B=∑1imp(∑1im∏j∈FiGi分别为Ai中出现的pj和pk的下标集,记析取范式全体构成集合为FW(S2),则FW(S2)Fd(S2).命题5把AND/OR式纳入到T-代数Fd(S2)中,同时Wh-范式属于FW(S2)(注意到Wh-范式也是析取范式).由于我们需要将AND/OR式转化为Wh-范式,可以定义映射DF:Fd(S2)→FW(S2),DF(A)=B,B为AND/OR式A对应的Wh-范式.显然DF是满射,因此FW(S2)也是Wh-范式全体构成的集合.定义7.设B1,B2∈FW(S2),B1=∑1im1B2=∑1jm2B2=B1∨B2.则〈FW(S2),槇∨,槇∧〉可看作T-代数(其中T={槇∨,槇∧}),称为Wh-范式T-代数,简称为Wh-代数.此时可将B1,B2的∨,∧统一为槇∨,槇∧.不难发现:定义7中所定义的运算与定义4一致(即利用分配律opc).通过定义7,把Wh-范式及其相关的运算统一到一个代数系统(即Wh-代数)之中.仍分别用Σ,Π表示多个槇∨,槇∧的复合(通过运算对象不难区分是Fd(S2)还是FW(S2)中的运算,下同).不难证明引理3和命题6.这里命题6说明了映射DF的性质.引理3.∑i,j命题6.DF是从T-代数〈Fd(S2),∨,∧〉到其中A1i,A2j∈FW(S2)(1im,1jn).Wh-代数〈FW(S2),槇∨,槇∧〉的T-同态.以下我们给出析取范式的另一种表示方式.设A为FW(S2)中的简单合取式,则A可表示槇∧…槇∧pxnn的形式,其中xi∈{1,-1,0,2},i=成px111,…,n,p1pi在该表达式中不出现(例如当n=5,A=p1槇∧p1槇∧p2槇∧p3槇∧p4时,有A=p21槇∧p12槇∧p-13槇∧p14槇∧p05),则指数向量(x1,…,xn)与A一一对应.设B为FW(S2)中的析取范式,即B=A1槇∨…槇∨Am,其中Ai为简单合取式(与(xi1,…,xin)一一对应).这时B与矩阵的.因此可定义映射Matr:FW(S2)→Fm(S2)(其中Fm(S2)为所有析取范式对应的矩阵的集合),Page11犕=Matr(B),其中犕为B对应的矩阵,称为指数矩阵.记其逆射为RMatr=Matr-1.犕的各行犔1,…,,犔m构成了B的行向量组,记(犔1,…,犔m)T=故有犕=(犔1,…,犔m)T.有下列命题成立.命题7.犕=Matr∑1im犔m)T当且仅当犔i=Matr(Ai)(i=1,2,…,m).例10.对于例2和例4中得到的Wh-范式,从Wh-代数的视角来看,可得S1={p1,…,p6},B=(p1槇∧p2槇∧p3)槇∨(p1槇∧p2槇∧p3槇∧p4)槇∨(p2槇∧p5)槇∨(p1槇∧p2槇∧p2)槇∨(p1槇∧p2槇∧p5)槇∨(p2槇∧p6)槇∨(p5槇∧p6),那么Matr(B)=((1,1,1,0,0,0),(1,1,-1,1,0,0),(0,-1,0,0,1,0),(1,2,0,0,0,0),(1,-1,0,0,1,0),(0,1,0,0,0,1),(0,0,0,0,1,1))T.定义8.(1)设犔1=(a1,…,an),犔2=(b1,…,bn)(ai,bi∈{2,1,0,-1}),定义犔1∨犔2=(犔1,犔2)T;犔1∧犔2=犔,其中犔=(a1⊙b1,…,an⊙bn),二元运算⊙:{2,1,0,-1}2→{2,1,0,-1}定义为2⊙a=2,0⊙a=a,a⊙a=a,1⊙-1=2,a∈{2,1,0,-1}(注意这里的∧,∨与Fd(S2)中的∧,∨不同,下同).(2)设犕1=(犔11,…,犔1m1)T,犕2=(犔21,…,犔2m2)T∈Fm(S),定义犕1∨犕2=(犔11,…,犔1m1,犔21,…,犔2m2)T;犕1∧犕2=(犔11∧犔21,犔11∧犔22,…,犔11∧犔2m2,…,犔1m1∧犔21,犔1m1∧犔22,…,犔1m1∧犔2m2)T.例11.设犔1=(1,2,-1,0,0),犔2=(1,-1,1,2,-1),则可得犔1∨犔2=(犔1,犔2)T,犔1∧犔2=(1,2,2,2,-1).又比如犕1=(犔11,犔12)T=((1,2,-1,0,0),(1,0,2,1,-1))T且犕2=犔21=(1,-1,1,2,-1),则可得犕1∨犕2=(犔11,犔12,犔21)T,并且犕1∧犕2=(犔11∧犔21,犔12∧犔21)T=((1,2,2,2,-1),(1,-1,2,2,-1))T.不难证明定理4.定理4.Matr是从Wh-代数〈FW(S2),槇∨,槇∧〉到T-代数〈Fm(S2),∨,∧〉的T-同构.由于两T-代数同构,即都为Wh-代数的表现形式,因此可将〈Fm(S2),∨,∧〉也称为Wh-代数,并不再区分槇∧,槇∨与∧,∨.设Q∈F(S1),CSeq(Q)=(φ(A1),…,φ(Ak)).存在公式序列B0,…,Bt、集合序列P0,…,Pt和唯一的k级排列〈r1,…,rk〉.其中r1=1,B0=A1,P0={1},Bi是将在Bi-1中出现的所有Ari置换为φ(Ari)所得公式(这里Bt是其中不再出现任何序列变量的公式),设φ(Ari)中依次出现的序列变量为Aj1,…,Aji,则令rm+1=j1,…,rm+i=ji(m=∨Pi-1,∨指上确界),Pi=Pi-1∪{m+1,…,m+i}(i=1,…,k).〈r1,…,rk〉给出了从B0=A1开始依次置换的序列变量的下标序列.定义9.设Q∈F(S1),S1,S2同命题5,将生成序列CSeq(Q)中的序列变量Ai(i=r1,…,rk)依次作为扩展原子公式pn+1,…,pn+k,令S3=S2∪{pn+1,…,pn+k,pn+1,…,pn+k},类似指数矩阵,可定义映射Matr:FW(S3)→Fm(S3),犕[k]=Matr(B)∈Fm(S3),B为FW(S3)中的析取范式,称犕[k]为扩展指数矩阵(除了列数为(n+k)外,其余与指数矩阵没有区别,以下简称扩展指数矩阵为矩阵).〈Fm(S3),∨,∧〉构成新的T-代数,称为扩展Wh-代数.由于Wh-代数是扩展Wh-代数的子代数,为了方便,将这两者统称为扩展Wh-代数.5扩展Wh-代数中的无损求解5.1基于有效扩充的直接无损求解算法本节主要对如何实现定义4中的(4)以及最终的最简解空间获取(即无损求解)进行研究.以下主要在扩展Wh-代数中进行分析(即直接从CSeq(Q)和Gen(Q)出发,此时默认为公式已然经过定义4中的(2)、(3)的处理).首先在扩展Wh-代数中对指数矩阵的展开进行研究.设Q∈F(S1),犔,犕=(犔1,…,犔m)T分别为Fm(S2)中的行矩阵和矩阵,对照定义5不难写出扩充犔(SQ)和犕(SQ)的定义(令V={犔1,…,犔m},得到V(SQ),再将V(SQ)中的项析取得到犕(SQ),下同),对照定理2中的(1)的证明,类似可得有效扩充犕MS(SQ)以及最简矩阵犕1Lls(犕)的定义.设犕t-1=(bij)m×(n+k)=(犔1,…,犔m)T(t1)为经定义4中的(2)、(3)处理后的公式所对应的扩展指数矩阵,易知当j=n+1,…,n+k时,bij∈{1,0}.记H1t-1={i|bi,(n+t)=1,i∈{1,…,m}},H0t-1={i|bi,(n+t)=0,i∈{1,…,m}},显然有H1t-1∪H0t-1={1,…,m}.对于行矩阵犔1,…,犔m,分别记下标在H1t-1,H0t-1中的所有行矩阵析取所得矩阵为犕1t-1,犕0t-1.记犕1t-1各行中(n+t)列由1变为0所得矩阵为犕1~t-1.注意到pn+t=φ(Art)∈FW(S3)(这里rt来Page12自于3.2节得到的〈r1,…,rk〉),记pn+t对应矩阵为t=(bn+tij)mt×(n+k)=Matr(φ(犃rt)).犕[k]定理5(展开定理).设Q∈F(S1),Q1=Gen(Q),CSeq(Q)=(φ(A1),…,φ(Ak)),(1)存在唯一的析取范式序列C0,…,Ck∈FW(S3),其中C0=Ar1,Ct是将在Ct-1中出现的所有Art置换为φ(Art)得到的析取范式(t=1,…,k),则Ck为Q的Wh-范式.称Ct是Ct-1的rt-展开.(2)存在唯一的矩阵序列犕0,…,犕k∈Fm(S3),其中犕t=Matr(Ct)(t=0,…,k),则有犕t=犕0t-1∨(犕1~t-1∧犕[k]开,记为Ext(Q1).(3)设犕t-1,犕t∈Fm(S3),犕t=犕0t-1∨(犕1~t-1∧t),则RMatr(犕t)是RMatr(犕t-1)的rt-展开.犕[k]证明.(1)首先由定理3可知:如果仅仅是置换,得到的是原来的AND/OR式Q1.而由扩展Wh-代数的定义,运算∧来源于定义4中的(4)(即利用分配律opc),而∨不产生影响,即执行的过程等同于对AND/OR式利用分配律opc(伴随结合律)得到析取范式的过程(仅存在次序上的不同),那么对照定义4中的(4)的过程可知:得到的Ck就恰为Q1经过定义4中的(4)所得公式,即Ck为Q的Wh-范式.(2)令Bt-1=RMatr(犕t-1)=∑1i(m∏j∈Fip)k及Bt=RMatr(犕t),pn+t=RMatr(犕[k]Atl=∑1lm(∏k∈Gi∑1lmt{l|n+tFl,l∈{1,…,m}},H1={l|n+t∈Fl,l∈{1,…,m}}.则H1=H1t-1,H0=H0t-1.i∈H1,令Fi=(Fi-{n+t})∪{n+t}=F+i∪{n+t}.可得犕0t-1=[Matr∑i∈H(且犕1t-1=[Matr∑i∈H([Matr∑i∈H(首先考察Bt-1,可以得到Bt-1=∑1i(m∏j∈Fip)k=∑i∈H(∏k∈Gip)k=B0∨∑i∈H(∏k∈Gi知Bt-1的rt-展开(即将Bt-1中的pn+t置换为∑1lm(t∏j∈Ftlp)]}k=B0∨(B1~∧B[k]t∏j∈Ft∑i∈H(1∏j∈F+B0{[∨∑i∈H(∏j∈GtFm(S3)是T-同构的,则可得犕t=Matr(B0∨(B1~t))=Matr(B0)∨(Matr(B1~)∧Matr(B[k]∧B[k]=犕0t-1∨(犕1~t-1∧犕[k](3)由于Matr是T-同构的,因此(2)的推导过程可逆,类似可得结论成立.由于该类问题计算量较大,而且其中不可避免地会出现冗余的情况,而二值命题逻辑中的逻辑简化是缩减计算量的有效而常用的处理手段,因此这里提出相关逻辑简化概念.定义10.设A∈F(S1),经过有限次操作op(1),…,op(n),产生A(1),…,A(n)=B,称〈op(1),…,op(n)〉为一个操作序列.此时如果A≈B,且Num(B)Num(A)(其中Num(A)表示A中公式的总数,比如Num(A1∨(A1∧A2))=3,Num(p1∨p1)=2),则称B是A的Num-逻辑简化(简称为“逻辑简化”).基于定义10,以下给出指数矩阵中的相关简化概念.定义11.设指数矩阵犕=(bij)m×n=(犔1,…,犔m)T∈Fm(S2),令犝={犔1,…,犔m},存在序列U1,U2,…,Um+1,其中U1=,Ui+1由且仅由以下元素组成(i=1,2,…,m,Ui+1中至多只包含一个元素):若犔i=(bi1,…,bin)中存在bij=2;或者存在犔k=(bk1,…,bkn)∈U-∪1tiUt(k≠i)满足:对于任意j∈{1,2,…,n},bkj≠0时bij=bkj,则Li属于Ui+1.记U=U-∪1tm+1Ut,令犕2为U中元素析取所得的矩阵,且保持与犕中各行次序一致,称犕2为犕的M-逻辑简化矩阵,同时称从犕得到犕2的运算为M-逻辑简化运算.类似可得扩展指数矩阵的相关定义.例12.对于例10中的Matr(B),其M-逻辑简化矩阵为((1,1,1,0,0,0),(1,1,-1,1,0,0),(0,-1,0,0,1,0),(0,1,0,0,0,1),(0,0,0,0,1,1))T.定理6(逻辑简化定理).设Q,Q1,CSeq(Q)同定理5,Q2为Q的Wh-范式,则(1)对于析取范式序列C0,D0,C1,D1,…,Ck,Dk∈FW(S3),其中D0=C0=Ar1,Ct是Dt-1的rt-展Page13开,Dt是Ct的任一逻辑简化,t=1,…,k,则Dk为Q2的逻辑简化.(2)对于矩阵序列N0,犕0,N1,犕1,…,Nk,犕k∈Fm(S3),其中N0=犕0=Matr(Ar1),Nt=犕0t-1∨(犕1~t-1∧犕[k]1,…,k),则犕k为Matr(Q2)的M-逻辑简化.称犕k为Q1的逻辑展开,记为MExt(Q1).证明.(1)将定理5中的(1)的析取范式序列改写为C0,…,Ck.由于逻辑简化和展开均保持逻辑等价,而且展开与逻辑简化无关,则有Num(Dt)Num(Ct),Dt≈Ct(注意到逻辑简化显然具有传递性),t=1,…,k,因此Dk为Q2=Ck的逻辑简化.(2)注意到M-逻辑简化显然是逻辑简化,则RMatr(犕t)是RMatr(Nt)的逻辑简化.又由定理5中的(3)和Nt=犕0t-1∨(犕1~t-1∧t),可知RMatr(Nt)是RMatr(犕t-1)的rt-展开.犕[k]则由(1)可得,RMatr(犕k)为Q2的逻辑简化.由于在这个过程中对矩阵的简化均为M-逻辑简化,而展开对简化没有影响,则由RMatr是T-同构可知犕k为Matr(Q2)的M-逻辑简化.定理7(最简解空间获取定理).设Q,Q1,CSeq(Q)同定理5,(1)设犕1=Ext(Q1),Lls(犕1MS(SQ))=(犔11,…,犔1m1),则MS-Solu(Q)={RMatr(犔1i)|i=1,…,m1},且Solu(Q)=∪j∈{1,…,m1}RMatr(犔1i)(SQ).(2)设犕2=MExt(Q1),Lls(犕2MS(SQ))=(犔21,…,犔2m2),则{RMatr(犔2i)|i=1,…,m2}MS-Solu(Q),并且∪j∈{1,…,m2}RMatr(犔2i)(SQ)Solu(Q).证明.先证(1),由定理5,Ck为Q的Wh-范式,而犕1=Ext(Q1)=犕k=Matr(犆k).对照MS-Solu(Q)的构造过程,易知MS-Solu(Q)={RMatr(犔1i)|i=1,…,m1}.再由推论1,显然可得Solu(Q)=∪j∈{1,…,m1}RMatr(犔1i)(SQ).类似地,由定理5和定理6,注意到其中犕t是Nt的M-逻辑简化,即犕t是将Nt中某些行进行删除所得到的矩阵,而矩阵每行对应了初始解空间的一批解,不难得知(2)成立.称定理7中的(1)为基于有效扩充的直接无损求解算法(DirectLosslessSolvingbasedonEffec-tiveExtension,DLSEE),称定理7中的(2)为基于有效扩充的逻辑简化求解算法(SolvingwithLogicSimplifyingbasedonEffectiveExtension,SL-SEE).为了便于理解,这里用明晰的自然语言加以描述.两个算法中DLSEE算法是核心,但是为了便于说明情况,这里给出SLSEE算法的过程,而DL-SEE算法仅需将其中步4删除即得.算法1.SLSEE算法.1.得到公式Q的生成序列Seq(Q),执行定义4中的2.针对序列变量A1,得到相应的扩展原子公式pn+1对3.在当前矩阵中,按定理7展开对应列数为n+rt(t∈(2)、(3),得到CSeq(Q).应的行矩阵M0,令t=1.{1,…,k})的扩展原子公式.4.在每次展开后进行M-逻辑简化.5.若当前矩阵在扩展原子公式对应的k列中存在值为1的元素,则令t=t+1,转步3.否则,继续.6.对最后得到的扩展指数矩阵,去除扩展原子公式对应的列,得到指数矩阵犕1.回犕3与一般原子公式集SQ,结束.7.得到犕1的有效扩充犕2以及犕2的最简矩阵犕3,返例13.对于例2的情形,按定理7的两种方法对其进行求解.解.按照DLSEE算法进行说明.对照算法1,首先执行步1,得到Q的生成序列Seq(Q),并在此基础上得到CSeq(Q)(可对照例9).再执行步2,将序列变量转化为扩展原子公式,进行编号,得到p7~p15,针对A1(即p7),得到相应的扩展原子公式p7对应的行矩阵犕0.执行步3~5,如图3中的(1)~(9).其后,执行步6,对最后得到的扩展指数矩阵,去除扩展原子公式对应的列,得到犕1,如图3(10).最后执行步7,分别得到犕1的有效扩充犕2及犕2的最简矩阵犕13(可对照例7),如图3(11)、(12).DLSEE算法得到的最简矩阵犕13为(8行):RMatr(犕13)=(p1∧p2∧p3)∨(p2∧p5)∨(p1∧p2∧p2)∨(p2∧p6)∨(p1∧p2∧p4)∨(p1∧p3∧p5)∨(p5∧p6)∨(p1∧p4∧p5).对于SLSEE算法,过程类似,仅其中增加了逻辑简化的操作.具体而言,对于第(9)步(为了便于理解,这里从公式的角度来看,下同),以矩阵的第6行为例,其对应公式为p1∧p2∧p5,但由于第3行的存在(对应p2∧p5),则由M-逻辑简化的定义可知第6行被简化.并且,其矩阵的第4行为p1∧p2∧p2,由于其含有相矛盾的原子公式p2∧p2,由M-逻辑简化定义可知第4行被简化.类似可得到最简矩阵犕23为(7行):RMatr(犕23)=(p1∧p2∧p3)∨(p2∧p5)∨(p2∧p6)∨(p1∧p2∧p4)∨(p1∧p3∧p5)∨(p5∧p6)∨(p1∧p4∧p5).这里对犕13中得到的解决方案进行简单说明.比如p1∧p2∧p4表示顶级期刊应根据影响因子来排序,同时可采取1.8的分界线;又比如p2∧p5表示不应该按照影响因子来排序,而应参照某著名高校Page14图3DLSEE算法过程示意图制定的顶级期刊列表;又比如p1∧p3∧p5表示应参照某著名高校制定的顶级期刊列表,同时要求顶级期刊的影响因子超过1.0.特别需要探讨的是犕13中的冲突解p1∧p2∧p2,其基本意义为:既要按影响因子排序,又不应该按影响因子排序.这种冲突解往往孕育着带有创新性的解决方案.通过后期的一些冲突消解方法(这不在本文的讨论范围内,这里直接给出其结果),可以得出新的解决方案:既考虑影响因子,但又不完全考虑,即需要结合其他的因素.事实上,这次计算机学院协同讨论的结果就是从p1∧p2∧p2延伸得到的,其理想方案为:认定国内某权威机构制定的SCI期刊分区的第I、II区为顶级期刊(该SCI期刊分区综合考虑了影响因子、研究领域、领域影响力等多方面因素).然而,在通过SLSEE算法得到的M23中,该冲突解p1∧p2∧p2被过滤掉了,这显然是难以接受的.可见DLSEE算法比SLSEE算法较优.例14.设Q∈F(S1),其中Q={[(p1∨p3)∨(p2∧p3)]∨[((p1∨p2∨p3)∧((p3∨p4∨p5)∧(p4∨p5)∧(p4∨p5∨p5)))∧p5]}∧{(p6∨p7∨p8∨p8)∨[(p6∧(p8∨p9∨p10∨p11)∧p7∧p8)∨(p6∧p7∧p8)∨(p6∧p8∧p9)∨(p6∧p8∧p9∧p10∧p11)]}∧{p12∨[(p12∨p15)∨((p12∨p13∨p14)∧(p12∨p13∨p14∨p15))]},按定理7的两种方法对其进行求解.解.按照SLSEE算法进行说明.对照算法1,首先执行步1,得到Q的生成序列Seq(Q),并在此基础上得到CSeq(Q)=(A2∧A3∧A4,{A13∨A6∨A5},{A7∨A8∨A9∨A10∨A11},{p12∨A16∨A12},[A14∧A19∧p5],(p2∧p3),(p6∧p7∧p8∧p8),(p6∧A15∧p7∧p8),(p6∧p7∧p8),(p6∧p8∧p9),(p6∧p8∧p9∧p10∧p11),(A17∧A18),(p1∧p3),(p1∨p2∨p3),(p8∨p9∨p10∨p11),(p12∧p15),(p12∨p13∨p14),(p12∨p13∨p14∨p15),(A20∨A21∨A22),(p3∧p4∧p5),(p4∧p5),(p4∧p5∧p5)).再执行步2,将序列变量转化为扩展原子公式,进行编号,得到p16~p37,针对A1(即p16),得到相应的扩展原子公式p16对应的行矩阵犕0.执行步3~5,如图4中的(1)~(13).其后,执行步6,对最后得到的扩展指数矩阵,去除扩展原子公式对应的列,得到犕1,如图4中的步(14).最后执行步7,分别得到犕1的有效扩充犕2以及犕2的最简矩阵犕13,如图4中的步(15)、(16).以下介绍其中几个关键步骤.对于第(9)步逻辑简化,以简化前矩阵的第3、7行为例,其对应公式分别为p1∧p3∧p6∧p7∧Page15图4SLSEE算法过程示意图p8∧p12∧p13和p1∧p3∧p6∧p7∧p8∧p12∧p14,但由于第1行的存在(对应p1∧p3∧p6∧p7∧p8∧p12),则由M-逻辑简化的定义可知第3、7行被简化.对第(13)步逻辑简化,如其中第8行(对应p1∧p4∧p5∧p5∧p6∧p7∧p8∧p12∧p15),由于其含有相矛盾的原子公式p5∧p5,由M-逻辑简化定义可知第8行被简化.对于第(15)步有效扩充,以扩充前矩阵犕1的第6、7行(自上而下计数,省略号算1行)为例(分别对应p2∧p3∧p6∧p8∧p9∧p13和p2∧p3∧p6∧p8∧p9∧p10∧p11∧p13),对照有效扩充的定义可知其扩充出p2∧p3∧p6∧p8∧p10∧p11∧p13(见犕2第10行).对于第(16)步得到最简矩阵的操作,以犕2的第13行为例(对应p1∧p2∧p6∧p7∧p8∧p10∧p11∧p12),但由于存在第12行(对应p1∧p2∧p6∧p8∧p10∧p11∧p12),由得到最简矩阵的过程(对照定理2)可知第13行被简化(图4中,空心体均表示即将被删除的项,空心斜体表示新增项).SLSEE算法最后得到最简矩阵犕13(60行):RMatr(犕13)=Q11∧Q12∧Q13,其中Q11=(p1∧p3)∨(p2∧p3)∨(p1∧p2),Q12=(p6∧p7∧p8)∨(p6∧p8∧p9)∨(p7∧p8∧p9)∨(p6∧p8∧p10∧p11)∨(p7∧p8∧p10∧p11),Q13=p12∨p13∨p14∨p15.对于DLSEE算法,过程类似,仅其中没有逻辑简化的操作,得到最简矩阵犕23(144行):RMatr(犕23)=Q21∧Q22∧Q23,Q21=(p1∧p3)∨(p2∧p3)∨(p1∧p4∧p5∧p5)∨(p2∧p4∧p5∧p5)∨(p3∧p4∧p5∧p5)∨(p1∧p2),Q22=(p6∧p7∧p8∧p8)∨(p6∧p7∧p8)∨(p6∧p8∧p9)∨(p7∧p8∧p9)∨(p6∧p8∧p10∧p11)∨(p7∧p8∧p10∧p11),Q23=p12∨p13∨p14∨p15.对这两种方法在例14的结果进行对比,如表1.由于需要实现的是获取最简解空间,而DLSEE算法实现了最简解空间的获取,但SLSEE算法却使Page16得最简解空间受到了损失,因此DLSEE算法才是我们需要的算法.但是,DLSEE算法需要处理的数据量较大(体现为矩阵行数),从而在计算量方面较大;而SLSEE算法计算量明显较小.这说明了表1两种方法在例14中结果的分析对比与DLSEE得到的解的关系相关的评价指标DLSEE算法12320798005144相同60相同84相同较高无损失SLSEE算法2498.0512098.50360完全包含于60等于0完全包含于较低存在损失例14中的逻辑简化导致最简解空间出现损失(即导致初始解空间的损失).事实上这绝非偶然,从理论的角度不难得到这个事实(这里限于篇幅,不作展开).那么,逻辑简化作为二值命题逻辑理论的组成部分,其所导致的损失,本质上反映了二值命题逻辑理论在冲突问题研究上存在着不和谐因素.那么,对于逻辑简化如何保持初始解空间的无损(即无损简化)就需开展进一步研究.更深入地,对于无损简化问题的研究,其价值不仅在于简化本身,而且对于二值命题逻辑中如何严格而合理地开展冲突问题研究都有着深刻的推动作用.5.2算法复杂度分析以下定理8从扩充的角度给出了最简解空间获取的方法,称其为基于扩充的直接无损求解算法(DirectLosslessSolvingbasedonExtension,DLSE).类似于定理7可证得定理8.定理8.设Q,Q1,CSeq(Q)同定理5,犕3=Ext(Q1),Lls(犕3(SQ))=(犔31,…,犔3m3),则MS-Solu(Q)={RMatr(犔3i)|i=1,…,m3},且Solu(Q)=∪j∈{1,…,m3}RMatr(犔3i)(SQ).这里对于DLSEE和DLSE算法进行对比.易知最简解空间获取可分为生成序列处理(预处理)、展开、有效扩充(或扩充)与最简化3个阶段(前两个阶段对应析取化过程).DLSEE算法和DLSE算法均实现了最简解空间获取,但由于前者采用有效扩充,后者采用扩充,导致在第(3)阶段上复杂度差异极大.以下重点针对这一阶段在最坏情况下的复杂度进行对比(在前两个阶段,两算法的复杂度相同,且在各自的总复杂度中所占份额均不大).在空间复杂度方面,DLSEE算法在这个阶段的空间复杂度为O(n×m1),而DLSE算法为O(n×m2)(m1,m2分别为DLSEE、DLSE算法在这个阶段的指数矩阵的最大行数),但是从扩充的结果可知其数据量m2往往极大(最坏情况下接近于3n),此时有效扩充的结果m1远小于m2,所以DLSEE算法的空SLSEE算法并非没有价值,因为其提供了利用逻辑简化来缩减计算量的策略,但显然二值逻辑中的逻辑简化并不能直接沿用.因此如何合理利用逻辑简化来缩减无损求解的计算量,是需进一步研究的课题.犕3中无冲突解的数量间复杂度较小.在时间复杂度方面(以下简称为复杂度),对于DLSEE算法,设此时最大行数为m1行(为了方便,以下行数用m1处理,不影响复杂度分析,下同).先考察有效扩充,需对各行犔i(1im1)遍历一遍.而对每个犔i=(bi1,bi2,…,bin),若bij∈{-1,1}(1jn),则需分别对犔i+1,…,犔m1的第j个变量进行判断(分析其能否有效扩充出新的行,而判断和有效扩充的原子操作数不超过n),最坏情况下每个bij均属于{-1,1},则一次迭代的复杂度为O(n2m21)(考虑到有效扩充).设需迭代l次,则总复杂度为O(l×n2×m21)(其中l=LN(V)-1).再考察最简化,注意到原有行数为m1行,现需对各行犔i(1im1)遍历一遍,对于犔i,又需对犔1,…,犔i-1,犔i+1,…,犔m1进行判断其是否可被简化,则最简化的复杂度为O(n×m21).因此第(3)阶段的总复杂度为O(l×n2×m21+n×m21)=O(l×n2×m21).对于DLSE算法,设此时最大行数为m2.先考察扩充部分,分两个层次考虑.(1)考察V(SN(V)).设犕1=(犔1,…,犔m2)T,令犞={犔1,…,犔m2}.由定义5,计算V(SN(V))需分析D∧px11∧…∧pxtt,D2=D∧p-x11,…,Dt+1=D∧p-xtt的情形,因此需分别对t=2,3,…,m2进行分析.当t=2时,判断任两行能否扩充出新的行(包括执行扩充),原子操作数为n×C2m2.当t=3时,为n×C3m2.依此类推,直至t=m2时,为n×Cm2m2.故共需n×(C2m2+…+Cm2m2)n×2m2次(表示约等于,前者略小于后者,差距为n×(C0m2+C1m2)=n×(1+m2),但当m2较大时,该差距可忽略).考虑到需迭代(SN(V)-1)次,则计算V(SN(V))的原子操作数为(SN(V)-1)×n×2m2.由于往往出现多个不同的SN(V),可设l1=max{SN(V)-1}.至此可得计算V(SN(V))的复杂度为O(l1×n×2m2).(2)考察V(SQ)=V(SQ,BN(V,SQ)).先计算V(SQ,1)=∪A∈V(SN(V))A(SQ).对V(SN(V))的任一个犔i=(bi1,…,bin)进行扩充.最坏情形下,犔i中仅有一个Page17元素不为0,不失一般性,设bi1≠0.此时在犔i(SQ)中bi2,…,bin∈{-1,0,1},则犔i(SQ)中行数为3n-1,因此扩充的原子操作数为n×3n-1次.则对于V(SN(V))中所有元素进行扩充需m2×n×3n-1次.因此得到V(SQ,1)的复杂度为O(l1×n×2m2+m2×n×3n-1)(考虑到V(SN(V))的计算).设l2=BN(V,SQ)-1,则计算V(SQ)的复杂度为O(l2×l1×n×2m2+l2×m2×n×3n-1),这就是扩充部分的复杂度.再考察最简化部分,与DLSEE算法类似可得其复杂度为O(n×m22).综上可得:第(3)阶段总的复杂度为O(l2×l1×n×2m2+l2×m2×n×3n-1+n×m22),考虑到一般有2m2m22(只要m2≠1,3),故O(l2×l1×n×2m2+n×m22)=O(l2×l1×n×2m2+l2×m2×n×3n-1)=O(l2×n×(l1×2m2+m2×3n-1)).显然DLSEE算法第(3)阶段的时间复杂度远小于DLSE算法.相比而言,DLSEE算法是较理想的算法.5.3与相关研究的宏观对比前文已经提及,可拓学与TRIZ是当前主要研究创新的两大理论[11,13-14],其核心均是通过消除冲突来实现创新,从而与本文的工作有一定的相关性.可拓学是以我国学者蔡文研究员为首创立的,其以基元理论与可拓逻辑为支柱,探讨解决矛盾问题的规律和方法.可拓学通过可拓变换来进行矛盾转化,对于冲突问题研究作出了重要贡献.但是,冲突问题存在于各个领域,尤其是与经典逻辑、模糊逻辑等相关的领域,要想真正地使冲突问题研究有根本性的推动,就势必需要直接研究经典逻辑等领域中的冲突问题,因此可拓逻辑的冲突研究不能替代经典逻辑中的冲突研究.就可拓学与本文工作的关系而言,两者都是从逻辑的意义出发,以逻辑推理为工具来研究冲突,且冲突处理的大方向有一定的相似性.但可拓学主要是直接针对矛盾情形进行研究,没有与获取初始解空间直接相关的处理机制,从而与本文二值命题逻辑的无损求解仍有较大区别.TRIZ是前苏联科学家从250万件发明专利中提炼形成的理论体系,它通过具体的案例分析,凝聚成数十条核心的创新原理,以此启发人们的思维,衍生出创新的思路,具有很强的实用性.该理论将冲突分为物理冲突和技术冲突,其冲突处理的大方向与本文有相通之处,例如物理冲突从逻辑上来看相当于A∧A,而技术冲突相当于A∧B(这里人为约定A,B相冲突),且两种冲突之间可转化.但是,TRIZ往往只是提供了冲突问题处理的宏观框架和指导思想,在很多情况下还是依赖于专家的人为分析(事实上,主要通过以文字描述的数十条创新原理来辅助人们进行冲突消解);并且,TRIZ不具有逻辑根据,从而与本文的工作差异很大.在其他的冲突处理相关研究中,比如协同设计中的冲突检测与消解方法形式多样(针对设计冲突、资源冲突、过程冲突等多种类型的冲突);但是,总体而言,其处理的思想和方式,与本文(从二值命题逻辑理论出发的)基于严格逻辑基础的证明得到的无损求解理论体系还是有很大的区别.这种坚实的理论严谨性也是本文无损求解理论体系优越性的重要体现.6结论本文分析了协同问题求解、协同设计等当前诸多领域中存在的冲突情形,并针对二值命题逻辑中的无损求解问题进行研究.首先从Wh-析取范式和扩充的角度建立初始解空间理论,并给出最简解空间的简化表示;然后基于提出的生成序列和扩展Wh-代数概念,研究了扩展Wh-代数中的无损求解,给出了DLSEE算法,并通过与相关算法的对比说明了该算法的优越性.该研究对于协同问题求解等领域有着重要的促进作用.进一步地,如何界定无损简化的尺度;如何将无损简化合理地融入到冲突问题研究甚至二值命题逻辑理论体系中;如何将冲突处理与之前在文献[1]提出的菱形序列模型相融合;如果纳入到Fuzzy逻辑[19-20]的层面,整个冲突问题又如何处理?这些都将是下一步的工作重点.
