Page1一种面向同构集群系统的并行任务节能调度优化方法李新1)贾智平1)鞠雷1)赵衍恒1)宗子良2)1)(山东大学计算机科学与技术学院济南250101)2)(德克萨斯州立大学计算机科学系圣马科斯78666美国)摘要节能调度算法设计是高性能计算领域中的一个研究热点.复制调度算法能够减少后继任务等待延时,缩短任务总体调度时间,但是耗费了更多的能量.为此,作者提出一种启发式处理器合并优化方法PRO.该方法按照任务最早开始时间和最早结束时间查找处理器时间空隙,将轻负载处理器上的任务重新分配到其它处理器上,从而减少使用的处理器数目,降低系统总体能耗.实验结果表明,和已有的复制任务调度算法TDS、EAD和PEBD相比,优化后的调度算法在不增加调度时间的条件下,能够明显减少使用的处理器数和系统总体能耗,从而更好地实现性能和能耗之间的平衡.关键词绿色网络;集群;并行;同构;前驱约束;节能调度;绿色计算1引言随着高性能计算的发展,大型集群(机群)系统的能量消耗越来越多,绿色节能成为高性能计算必须考虑的重要因素之一[1].例如,2006年美国境内的服务器和数据中心的总能耗为614亿千瓦时,几乎等于580万美国家庭用电的总和①.如何降低现有计算机系统的能耗,设计能量有效利用的高效能集群系统,已经成为高性能计算亟需解决的问题之一[2].集群系统中节能调度问题是为系统中每一个并行任务分配处理器等资源,并指派占用这些资源的起止时间,在满足依赖关系的条件下,使得所有任务较早完成,并且能量消耗尽量少.节能调度与传统的并行任务调度相比,主要目标不是减少任务总体完成时间(调度长度),而是尽量减少使用资源数目和占用时间,提高资源利用率,达到整个集群系统性能和能耗之间的平衡.多处理器/机上并行任务最优调度问题已经证明是NP难的[3].国内外学者普遍采用启发式算法生成调度方案,减少任务总体完成时间,降低系统能耗.TDS(TaskDuplicationScheduling)调度[4]将所有任务按照依赖关系图的拓扑结构分成多条路径,每个路径上的任务分为一组,分配到一个处理器上执行.该方法通过在数据相关的任务分组上复制执行前驱任务减少处理器间的数据传输延迟,缩短所有任务的总体执行时间.然而,任务复制执行在提高性能的同时,带来了能耗增加问题.为此,Zong等人[5]在TDS的基础上,提出了两种非抢占式离线节能调度算法———EAD(Energy-AwareDuplication)调度和PEBD(Performance-EnergyBalancedDuplication)调度,分别通过设置任务能量阈值和能量/时间比阈值,减少低能效任务复制次数,从而降低系统的总体能量开销.本文在以上研究的基础上,设计了一种启发式处理器合并优化方法,简称PRO(ProcessorReduc-tionOptimizing).该方法通过合并任务数较少的任务分组,减少处理器使用数目,从而降低系统总能量开销.PRO方法与TDS、EAD和PEBD调度结合形成了3种优化的调度算法TDS-PRO、EAD-PRO和PEBD-PRO.实验结果表明,优化后的3种算法与优化之前的相应算法相比,任务总体执行时间略微减少或相等,而总体能量开销平均减少23.71%、21.28%和23.51%.与已有的研究工作相比,本文的创新之处在于:(1)在文献[5]的基础上,提出一种改进的集群系统能耗统计模型,考虑了任务复制情况下能耗统计.该模型将处理器、网卡和网络交换机作为系统能耗的主要构成,给出了详细的统计方法.(2)提出了一种处理器合并优化方法PRO.该方法与现有的任务复制执行策略相结合,能够得到优化的调度方案,减少使用的处理器数目,降低系统总能耗.(3)开发了一个并行任务调度模拟程序,实现了TDS、EAD、PEBD和本文提出的3个改进调度算法,并使用来自于真实应用的任务集对算法进行了测试和评估.本文第2节介绍相关工作;第3节给出节能调度问题的形式化描述,包括任务模型、处理器模型和能耗统计模型;第4节详细描述节能调度方法;第5节对算法的性能进行测试和分析;最后总结全文.2相关工作在集群上运行的并行程序需要大量的数据处理和数据交换,集群管理系统需要对这些并行程序分配资源和调度.分配和调度策略对整个系统性能具有重要的影响.总体而言,并行调度策略可以分为3种:基于优先级的调度、基于分组(聚类[6],cluster)的调度和基于复制的调度[5].首先,基于优先级的调度[7]为每个任务分配一个优先等级,根据等级将任务分配到处理器上执行.基于分组的调度算法[8]尽可能将有数据通信的任务划分到一个分组,然后按分组指派处理器,从而减小处理器间通信消耗.基于复制的调度TDS[4]利用处理器的空闲时间复制前驱任务,避免某些前驱任务的通信数据传输,从而减少传输延迟.复制策略往往和分组策略共同使用,在不同分组中复制关键路径上的前驱任务,减少数据传输延迟[5].在大多数情况下,基于复制的调度在性能(调度长度)上优于非复制的调度方法,尤其当任务之间传输数据量较多时.然而,由于任务被复制后在不同处理器上重复执行,这增加了系统的总能耗.为了解决这个问题,Zong等人[5]提出了两种能量敏感的复制调度算法(EAD和PEBD),减少任务复制次①http://www.energystar.gov/ia/partners/prod_develop-Page3数,实现性能提升和能耗节约的折中.本文提出的处理器任务合并方法是对TDS、EAD和PEBD算法的改进,通过减少处理器使用数目,进一步降低系统总能耗.另外,动态功率管理机制[9]也是一种有效的节能方法.该方法通过及时关闭或休眠某些不使用的部件,减少系统资源占用和能量消耗.文献[10]将反馈控制理论引入到异构集群系统中,提出一种基于处理器使用率的反馈控制算法,实现动态的负载平衡.动态电压/频率调整(DynamicVoltageandFre-quencyScaling,DVFS)技术[11-16]通过降低芯片内部电压或频率,减小处理器芯片的功率,从而减小集群系统的能量开销.在通信密集型应用中,网络通信的能耗在总能耗中占比重较大,因此动态电压/频率调整的好处可能会降低[5].Soteriou等人[9]研究了如何根据通信情况变化,动态打开或关闭网络连接.Gunaratne等人[17]提出了一种自适应连接速率方法,根据网络利用率动态调整网络连接状态,减少以太网能量开销.文献[18]表明,采用DVFS的互连技术能够明显减少能量开销.但是,他们的方法要求网络设备(网卡和交换机等)具有多个通信速率和功耗等级,并且能够动态切换.然而,大多数以太网设备在完全空闲和充分利用两种情况下,几乎消耗同样多的能量[17].3节能调度问题模型节能调度问题由任务模型、服务器模型和能耗统计模型三部分构成.表1中给出了本文使用的主要变量和参数.名称含义n任务数量m计算机节点数量ECT(vi)最早完成时间Nswitch交换机数量LAST(vi)最迟开始时间vi第i个任务LACT(vi)最迟完成时间ti任务i的执行时间FP(vi)关键前驱eij任务j依赖于任务iwijcij3.1任务模型本文中的任务集合由n个具有依赖关系的并行任务构成.任务调度不可抢占(non-preemptive).任务集合和依赖关系可以使用任务图来表示.定义.任务图G是一个有向无环图DAG(DirectedAcyclicGraph),G=(V,E),其中顶点集合V用于表示任务集合,V={vi|1in};有向边集合E={eij|1in,1jn}表示任务之间的数据流向或依赖关系.任务vi=(ti,Ωi),其中,ti表示任务执行时间,ΩiV表示任务i的前驱任务集合.任务图中,顶点内部的数字表示任务编号,顶点边上的数值表示任务执行时间.有向边eij上数值cij表示:如果任务i和j不在一台计算机上执行时,任务i的运算结果传输给任务j需要的网络耗时.如果两个任务在一台计算机上执行,网络传输耗时为0.例如,图1(a)给出了一个具有5个任务的集合.如果任务3和任务1不在一台计算机上执行,那么将耗用1个单位的时间才能将相关结果发送到任务3所在的处理器.3.2服务器模型假设服务器Π由m个同构计算机节点(下文简称节点)组成,每个节点具有一个单核处理器,Π={P1,P2,…,Pm}.m的个数根据应用需要动态确定.任务可以在任意节点上执行,而且执行时间相等.每个处理器都具有一个固定运行频率.假设PCbusy和PCidle分别表示处理器执行任务时和空闲时的功率.分配矩阵犡定义为犡={xij|1in,1jm},其中,xij=1表示任务i分配到处理器j上执行;xij=0表示任务i不在处理器j上执行.任务vi在处理器j上的一次执行称之为vi的一个作业wij,任务vi的所有作业表示为{wij|xij=1}.3.3能耗模型处理器是服务器机柜中最耗能的部分[5].而在局域网中,switch和hubs大约占整个网络设备总能耗的80%[19].因此,本文仅统计CPU、网卡和交换机三部分耗费的能量,作为系统能量消耗.Page43.3.1CPU能耗任务vi在节点上执行一次耗费的能量Evi等于:考虑到一个任务可能在不同处理器上重复执行,所有处理器处于运行状态所消耗的能量ECbusy可以用式(2)来计算.处理器处于空闲状态的能耗是空闲功率PCidle和空闲时间的乘积.式(3)表示集群中第j个处理器空闲时的能耗.i=1其中,∑nLmax表示调度长度(schedulelength),即最后一个任务的完成时间.Lmax=maxni=1maxm为任务作业wij的结束时间.任务执行时间之和最大的路径构成关键路径.关键路径决定调度长度.例如,图1(a)中路径1→4→5为关键路径.所有节点空闲时的总能耗ECidle为ECidle=PCidlem·Lmax-∑m因此,处理器总能耗EC可以表示为需要说明的是,这个能耗模型与DVFS技术是兼容的.支持DVFS的处理器可能有多个电压频率等级,调度算法可以选择合适的电压或频率作为处理器功率PCbest-fit.在这种情况下,可以使用PCbest-fit代替式(2)中的PCbusy,分段计算处理器运行状态的总能耗.3.3.2网卡能耗假设每个节点上只有一块网卡,PNbusy表示网卡忙碌(收发数据)时的功率,PNidle表示网卡空闲时的功率.第j个节点中网卡接收数据耗费的能量可以表示为ENj假设发送和接收同一批数据耗时相等,所有网卡忙碌(发送和接收)时间总能耗为ENbusy=2·PNbusy·∑n类似式(5),网卡总能耗EN等于EN=m·PNidle·Lmax+2(PNbusy-PNidle)·3.3.3交换机能耗本文中,集群互联是同构的,也就是说所有设备以相同的速率传递数据.文献[11,14]表明空闲和充分利用两种情况下,网络设备几乎消耗同样多的能量.例如,在Myrinet-2000网络中,交换机在不同的通信流量状态下消耗的能量几乎是相等的[20].因此,可以假设交换机忙碌时功率与空闲时功率一致,统一使用PS表示.所有节点连接到交换机两层级联网络.网络中交换机的台数Nswitch与每台交换机端口数Nport和处理器数m有关.当m(Nport)2时,交换机总能耗ES等于ES=Nswitch·Lmax·PS=m最后,可以得到服务器的总能耗开销E:在以上定义的基础上,调度问题可以描述为:给定一个具有前驱约束的并行任务集合和一个处理器节点集合,寻找一种调度方案使得在满足前驱约束的前提下,所有任务都能较快完成,并且服务器总能量开销最小.4节能调度方法本文提出的节能调度方法先计算各个任务的调度参数,再执行TDS、EAD或PEBD算法,对任务进行初步分配,然后更新作业开始执行时间和结束时间,最后执行处理器合并优化算法.4.1计算任务调度参数调度算法必须保证前驱任务先执行,后继任务后执行.为了满足这个条件,使用level的概念产生任务分配次序.一个任务的level被定义为从该任务开始执行到最后一个任务完成的时间.本文使用文献[4]中提出方法,自下而上计算任务的level.level(vi)=按level从小到大顺序排列任务,形成任务处理Page5序列Q.然后,计算任务的最早开始时间EST(EarliestStartTime)、最早完成时间ECT(EarliestComple-tionTime)、最晚允许开始时间LAST(LatestAl-lowableStartTime)和最晚允许完成时间LACT(LatestAllowableCompletionTime).没有前驱的任务的EST等于0,其它任务的EST可以根据式(13)递归计算出来.EST(vi)={0,如果vi的前驱为空,mineji∈E(maxeki∈E,vk≠vj任务vi的最早完成时间ECT等于:每个有前驱的任务都至少有一个关键前驱任务FP(FavoritePredecessor).FP(vi)定义如下:一个任务和它的关键前驱任务会被分配到同一个节点上执行,从而得到较短的调度长度.最后一个任务的最晚允许完成时间LACT等于它的最早完成时间.其它任务的LACT用自下而上的方法按照式(16)计算.LACT(vi)={ECT(vi),如果vi的后继为空,min(mineij∈E,vi≠FP(vj)(LAST(vj)-cijmineij∈E,vi=FP(vj)(LAST(vj))),否则(16)任务的最晚允许开始时间LAST定义为调度算法根据以上参数决定任务执行位置和是否复制.4.2任务调度算法任务复制执行能够减少后继任务的等待延迟,减少调度长度.有关学者先后提出了任务复制分配算法TDS和能量可感知的调度算法EAD、PEBD.4.2.1任务复制调度算法TDSTDS调度[4]通过复制关键路径上的前驱任务,避免前驱任务的数据通信延迟,从而使得关键路径上的任务尽早开始.在TDS算法中,任务分组过程从后继任务为空的任务(假设为vi)开始,通过以任务vi为根节点的逆向深度优先搜索,在DAG图中从下向上找到多条从任务vi到前驱为空任务的路径.一条路径上的任务被分到一个任务分组,在同一个处理器上执行.下一个任务分组从任务处理序列Q中第一个未分配的任务开始.如果前驱任务的复制,不能缩短调度长度,那么不复制该前驱任务.如果所有任务都被分配过了,那么算法终止.如图1(c)所示,通过在处理器P2上复制执行任务v1,后继任务v3和v5的开始执行时间可以提前,从而缩短调度长度.4.2.2能量可感知的调度算法EADTDS算法只是缩短了调度长度,而没有考虑能量消耗问题.任务复制执行会增加CPU忙碌时间,也会消耗更多能量.为此,EAD算法[5]在TDS算法中增加了对任务能耗的判断.EAD算法首先检查关键前驱任务的复制是否会使当前任务的开始时间提前.如果能提前,再将执行前驱任务的能耗与节省的网络传输能耗之差(ΔE)作为参数,如果该参数小于或等于所设定的EAD阈值,则复制任务;否则,不复制该任务.EAD算法仅复制增加的能耗不大于EAD阈值的任务,所以比TDS节省能耗.4.2.3性能-能耗平衡的调度算法PEBDPEBD算法[5]和EAD算法类似,将任务复制策略和能量优化策略结合在一起.不同之处在于,PEBD算法对性能和节能做出了平衡,将执行前驱任务的能耗与节省的网络传输能耗之差/缩短等待时间的比值(ΔE/Δt)作为参数.只有该参数小于或等于所设定的PEBD阈值时,才复制前驱任务.与EAD相比,PEBD算法不仅考虑复制执行增加的能耗,而且考虑复制执行缩短的时间.因此,PEBD算法更合理.EAD、PEBD阈值成为决定任务是否被复制的重要因素.第5.1小节对不同阈值的影响进行了测试和分析.4.3更新作业调度时间任务调度算法执行后,需要更新每个处理器上所有作业的调度时间,为执行处理器合并优化算法做准备.为此,调度时间更新函数从上向下广度优先遍历DAG图,依次对每一个任务进行处理,计算任务所有作业的开始时间和完成时间.如果任务vi是DAG图中根节点任务,则设定vi所有作业的开始时间为0.否则,一个作业wij的最早开始时间等于vi所有前驱任务的到达时间(完成时间+传输时间)和处理器j中wij前面邻接作业的完成时间的最大值.图2给出了调度时间更新函数,其中vk为任务vi的一个前驱任务,startTime保存作业最早开始时间的中间过程值.Page6算法1.UpdateTaskScheduleTime(vi).输入:任务vi输出:vi所有作业的EST和ECT1.forwij∈vi的作业集合2.ifvi是DAG图中没有前驱的任务then3.EST(wij)=04.elsethen5.startTime=-1//设置开始时间的下边界值6.forvk∈vi的前驱任务集合Ωi7.ifvk的作业wkj在处理器j上执行then8.preECT=ECT(wkj)9.elsethen//如果不在一个处理器上10.temp1=+//前驱任务完成时间的上界11.forPl∈vk的作业所在处理器集合12.ifECT(wkl)还没有获得then13.UpdateTaskScheduleTime(vk)//递归计算14.temp2=ECT(wkl)+cki15.iftemp2<=temp1then16.temp1=temp2//vk结果的最早到达时间17.preECT=temp118.ifpreECT>startTimethen19.startTime=preECT//前驱任务最晚到达时间20.ifwij不是处理器Pj上第1个作业then21.z=处理器Pj作业队列中排在wij前面的作业22.ifECT(z)还没有获得then23.UpdateTaskScheduleTime(z)24.ifECT(z)>startTimethen25.startTime=ECT(z)26.EST(wij)=startTime27.ECT(wij)=startTime+ti4.4处理器合并优化方法与TDS算法相比,EAD和PEBD算法避免了低能效的任务复制,减少了任务复制次数,节约了系统总能耗.但是这3种算法对于分配任务数较少的处理器都没有做合并处理.如果一个任务集DAG图的并行分支比较多,那么许多处理器上分配的任务数会很少,处理器利用率不高,造成处理器资源的浪费.为此,在上述任务调度算法的基础上,笔者提出一种处理器合并优化PRO方法,在维持依赖关系和作业调度时间的前提下,对作业的执行位置进行调整,把处理器上的任务作业尽可能集中到少量处理器上,提高CPU利用率,减少使用的处理器数目.PRO方法的主要思路是使用更新后的EST和ECT作为参数,将负载轻的处理器上的作业(假设为wij)合并到在[EST(wij),ECT(wij)]时间范围内空闲的其它处理器上,减少使用的处理器数目,从而降低系统总能耗.PRO方法与TDS、EAD、PEBD调度算法相结合,可以生成3种优化的调度算法TDS-PRO、EAD-PRO和PEBD-PRO.如图1(d)所示,TDS-PRO算法将任务v2合并到处理器P2上,释放了处理器P3,减少了处理器个数.PRO方法的具体过程如下:首先,将处理器按照分配任务数量由多到少排序.然后,尝试将任务数最少的处理器(假设为Pi)上的任务插入到任务数较多的处理器上.如果这些处理器上没有一个合适的时间空隙接纳该任务,那么停止Pi上剩余任务的合并,开始尝试合并下一个处理器Pi-1上的任务.如果除了接收合并任务的处理器和无法被合并的处理器之外,没有其它处理器,那么算法结束.如果某个处理器上的任务都移动到其它处理器上,那么该处理器节点就可以被释放,不再使用.图3给出了处理器合并算法的伪代码,其中|Pi|为处理器Pi上的作业数.算法2.ProcessorReductionOptimizing.输入:(1)初步调度分配方案;(2)更新后的任务调度时间参数输出:优化后的调度方案1.按照作业数量递减顺序生成处理器序列{P1,P2,…,Pm}2.fori←mto2//先优化作业少的处理器3.ifPi接收过插入作业then4.continue//接收过插入作业的处理器无法被合并5.fork←|Pi|to1//先处理队列尾部的作业6.w=Pi上第k个作业7.bTag=false8.forj←1toi-1//先从作业多的处理器上查找空隙9.ifTryMoveJob(w,Pj,Pi)then10.bTag=true11.break12.ifbTag=falsethen13.break//遇到无法插入的作业,停止优化Pi在图3中,作业优化检查函数(TryMoveJob)是一个重要的函数,该函数检查是否能将处理器Pi上的作业w插入到处理器Pj的空隙时间中.在进行尝试插入之前,首先判断w是否在其它处理器上有复制执行.如果有复制执行,则w已经没有执行的意义,将w直接从处理器Pi上删除,并且返回true.如果w没有复制执行,判断如果将w插入到处理器Pj,作业w的前驱是否会延迟w的开始时间.如果存在延迟,则返回false.因为延迟w的开始时间,可能会增加调度长度.否则,查找处理器Pj上是否有合适空隙(slot)容纳w.作业优化检查函数的伪代码如图4所示,其中STslot为待检查空隙的开始时间,ETslot为空隙的结束时间,判断作业w是否能够插入到[STslot,ETslot]空隙中.4.5时间复杂度分析定理1.给定一个受依赖关系约束的并行任务集,优化调度算法的时间复杂度为O(h2n2),n是任务数,h是DAG图的高度.Page7算法3.TryMoveJob(w,Pto,Pfrom).输入:(1)待插入的作业w;(2)待插入处理器Pto输出:如果能插入则返回true;否则,返回false1.ifw已经被其它节点执行then2.从处理器Pfrom上删除w3.returntrue4.forpreTask∈w的前驱任务集合5.ifPto上没有preTask的作业then6.ifPfrom上有preTask的作业then7.returnfalse//如果w被推迟执行,则不移动8.fori←0to|Pto|9.ifi=0then//待检查slot在作业队列开头10.STslot=0//slot开始时间11.ETslot=EST(Pto上第1个作业)12.elseifi=|Pto|then//slot在作业队列结尾13.STslot=ECT(Pto上最后一个作业)14.ETslot=Lmax//处理器调度长度15.else16.STslot=ECT(Pto上第i个作业)17.ETslot=EST(Pto上第i+1个作业)18.ifSTslotEST(w)andECT(w)ETslot)then19.从处理器Pfrom上删除w20.移动作业w到处理器Pto上21.returntrue22.elsereturnfalse证明.优化的节能调度算法执行了4.1~4.4节中4个阶段的操作.(1)在计算任务调度参数过程中,首先遍历DAG图中所有任务,计算任务的level,复杂度为O(e+n),其中e是DAG图中有向边数.将任务的level按非递增的顺序进行快速排序的时间复杂度为O(nlgn).然后,遍历任务计算EST、ECT、FP、LACT和LAST参数,复杂度为O(e+n).因此,第一阶段的时间复杂度为O(e+nlgn).(2)在任务调度算法中,根据复制策略将任务分配到一个或多个节点上执行.最坏的情况下,关键路径上所有任务都被复制执行,时间复杂度为O(hn).(3)更新作业调度时间函数采用广度优先顺序遍历所有任务,调用UpdateTaskScheduleTime函数.最坏情况下,UpdateTaskScheduleTime函数内部访问所有作业一次,函数时间复杂度为O(hn).因此,这一阶段的时间复杂度为O(hn(e+n)).(4)在处理器合并优化过程,先将处理器按作业数递减进行快速排序,复杂度为O(nlgn);然后将任务数少的处理器上的作业尝试插入到任务多的处理器上.最坏的情况下,TryMoveJob函数内部需要比较Pto处理器上所有空隙,其时间复杂度为O(hn);TryMoveJob函数最多被调用hn次.因此,此阶段的时间复杂度为O(h2n2).综合考虑以上分析,由于e<hn,节能调度算法的总时间复杂度为O(h2n2).5实验评估为了比较不同算法的性能,笔者开发了一个模拟调度程序.该程序可以模拟并行任务的分配和调度过程,并能通过DAG图和Gantt图形象化显示任务之间的依赖关系和各处理器上任务执行过程.模拟程序实现了本文提到的6个算法TDS、TDS-PRO、EAD、EAD-PRO、PEBD和PEBD-PRO,并统计调度长度、处理器使用个数和系统总能耗开销3个评价指标.不同算法的性能会受到应用程序规模的影响.在实验中,测试任务集选用两个真实的并行应用———机器人控制(Robot)和FPPPP应用①.Robot和FPPPP任务数分别为88和334,其它参数如表2所示.Robot任务集平均出度小,属于计算密集型;FPPPP任务集平均出度大,属于通信密集型[5],任务集任务数目平均执行时间/s平均出度Robot88FPPPP334依赖任务之间的数据传输时间通过通信-计算时间比CCR(Communication-ComputationRatio)和网络消息延迟系数K计算出来.数据传输时间=K×CCR×前驱任务执行时间.网络消息延迟系数K是以Myrinet②网络消息延迟时间为基准的比例系数.实验任务集合处理器型号网络EAD编号1Robot/FPPPPAMD85WEthernet0~20000~5000.12Robot4种处理器③Ethernet200800.13Robot/FPPPPAMD35WEthernet200/150080/1500.14RobotAMD35WEthernet200800.1~25RobotAMD35W4种网络④200800.1实验分为5组,分别对不同的算法阈值、处理器类型、任务集合、CCR参数和网络类型进行测试.表3列出了具体的实验参数.①②③④Page85.1实验1:不同算法阈值的影响EAD、PEBD阈值增大意味着任务复制执行可能性增加.本实验通过不同阈值对算法的影响进行分析比较,得到后续实验中使用的阈值.首先,测试EAD阈值(EAD-Th)变化对EAD和EAD-PRO算法的影响.从图5(a)可以看出,在Robot任务集上,当阈值增加到500时,两个算法的调度长度都略微减少,这说明此时,复制关键路径上前驱任务可以在一定范围内缩短调度长度.与EAD相比,EAD-PRO的调度长度较少.这说明通过路径合并,关键路径上有些任务等待时间减少,从而使得整体调度长度缩短.图5Robot任务集上EAD阈值对算法的影响从图5(b)、图6(b)可以看出,随着EAD阈值的增大,系统的总能耗增加.同时可以看到EAD-PRO的总能耗小于EAD的总能耗,这是因为EAD-PRO算法将负载轻的处理器上的任务合并到其它处理器上,减少了使用的处理器数目,从而减少了系统总能耗.图6(a)表明,FPPPP任务集的调度长度开始不变,在EAD阈值等于500时增加.这是因为关键任务被复制,复制的任务虽然缩短了其后继任务的开始时间,然而其复制之后推迟了关键路径上其它任务的开始,从而使的整个任务集的完成时间延长.在EAD阈值增加到1400时,更多的复制任务使得关键路径上的某些任务开始时间提前,从而缩短了调度长度.EAD和EAD-PRO的调度长度相等,这是因为EAD-PRO算法在选择任务合并到别的处理器上时,如果合并会延长其后继任务的开始时间,则放弃此任务的复制,所以合并后的执行时间不会晚于原来的执行时间.后面的实验也能明显体现出改进算法的这一优点.图6FPPPP任务集上EAD阈值对算法的影响综合图5和图6的数据,可以看出EAD阈值在不同任务集上影响不一样.在图5(b)中,当EAD阈值等于200时,总的能量开销处于平均水平,因此选择200作为Robot任务集上后续实验的EAD阈值.在图6(b)中,EAD阈值在1500附近,能量消耗处于平均水平,所以选择1500作为EAD算法在FPPPP任务集上的阈值.由图7(a)可以看出,当PEBD-Th由50逐渐增加到200时,Robot任务集的调度长度明显减少.这说明前驱任务复制可以使关键路径上任务的开始时间提前,从而缩短了调度长度.然而在图8(a)中,FPPPP任务集上调度长度减少不大.在图7(b)中,阈值由150~200变化时,PEBD算法能耗出现了略微减少,这是由于某些任务复制执行减少的网络传输能耗大于复制执行增加的能耗.图7(b)、图8(b)整体来看,随着阈值的增大,PEBD-PRO算法总体能耗逐渐增加.与PEBD相比,PEBD-PRO算法的节能效果显著,大约减少10%~40%.在后续实验中,PEBD阈值在Robot和FPPPP任务集上分别设为80和150,使得两个算法的总能量消耗都处于各自的平均水平.Page9图7Robot任务集上PEBD阈值对算法的影响图8FPPPP任务集上PEBD阈值对算法的影响5.2实验2:不同处理器功率的影响本实验采用表4中给出的4种不同处理器①运行功率和空闲功率对算法进行测试.实验采用Robot任务集.AMDAthlon4600+85W104AMDAthlon4600+65W75AMDAthlon4600+35W47IntelCore2DuoE6300由图9看出,TDS-PRO、EAD-PRO和PEBD-PRO算法的CPU总能耗均比相应的基准算法少.在4种处理器功率情况下,TDS-PRO相对于TDS算法分别节能15%、16.5%、18%和24%;EAD-PRO相对于EAD算法的节能为12%、13%、6%和7%;PEBD-PRO相对于PEBD算法节能28%、20%、17%和22%.5.3实验3:不同任务类型的影响实验3使用Robot和FPPPP两个任务集对算法进行测试,实验结果如图10所示.图10(a)显示了各算法的调度长度.PRO方法要求任务重新分配时不能延长后继任务的开始时间,所以新算法的调度长度等于或略小于原算法.如图10(b)所示,改进算法在FPPPP任务集上明显减少了处理器数目.TDS-PRO、EAD-PRO和PEBD-PRO算法在FPPPP任务集上节约处理器数分别为51%、52%和40%,而在Robot任务集上节约处理器数分别为27%、5.4%和24%.这说明,路径分支较多的任务集(如FPPPP)占用处理器较多,处理器平均利用率较低,任务合并的机会也就越多.由于任务数和平均出度不同,在不同任务规模下,系统的总能量开销存在着很大的差别.从图10(c)可以看出FPPPP任务集的能耗开销远大于Robot的开销.TDS-PRO、EAD-PRO、PEBD-PRO在FPPPP上的节能效率分别为33%、35%、27%,在Robot上的节能效率分别为14%、5%、13%.这验证了,PRO方法在分支多的通信密集型任务集上不仅能够更多的减少处理器数目,而且具有更好的节能效果.5.4实验4:不同通信-计算比(犆犆犚)的影响这组实验比较了不同CCR取值对算法的影响.实验中,CCR从0.1~2变化,间隔0.1.从图11(a)可以看出,当CCR从0.4到2逐渐变化时,各算法的调度长度不断增加,这是由于在任①http://www.xbitlabs.com/articles/cpu/display/amd-energy-Page10务执行时间不变的情况下,CCR增加引起网络延迟增大,调度长度也会增加.与此同时,传输能耗增大,总能耗也相应增加.CCR的变化影响到网络传输延迟,CCR在0~0.3范围内变化时,TDS、EAD、PEBD算法使用的CPU个数略微减少,而3个改进算法使用的CPU个数变化比较大.这说明CCR参数不仅影响处理器间的网络通信时间,而且影响改进算法的合并效果.当CCR在[0,1]范围内变化时,改进算法受CCR参数的影响比较大.由图11(c)可得,随着CCR的增加,各个算法的系统总能耗不断增加.改进算法的能耗比相应的基准算法的能耗略少.5.5实验5:不同网络的影响不同类型的网络具有不同的设备功率和网络延迟.与文献[5]类似,本实验中采用千兆以太网、Infiniband①、QsNet[21]和Myrinet4种不同类型网络,测试网络设备参数对算法性能的影响.表5给出了这4种类型网络的主要参数.网络类型交换机GBEthernet7552413Infiniband2510.624Myrinet55.29.332QsNet42128图12(a)表明,算法在Ethernet上执行时间最长,QsNet次之,Infiniband和QsNet的执行时间最小.这是由消息延迟系数引起的.延迟系数越大,网络延迟越大,执行时间越长.由图12(b)看出,3种改进算法在Infiniband、Myrinet和QsNet网络中占用处理器数目差不多,具有类似的性能.图12(c)表明改进算法在不同网络下,总能耗比相应基准算法要①http://www.mellanox.com/pdf/products/silicon/InfiniS-Page11小,节能效果明显.总体来看,改进算法在Ethernet上使用的处理器数目和总能耗开销相对较大.这是由于Ethernet的网络延迟系数较大造成的.在这4种网络上,改进算法都具有较好的节省资源效果.5.6实验小结根据以上5个实验结果和分析,我们可以看到PRO类优化算法与相应的基准算法相比,调度长度略微减少或相等,而使用处理器个数和总体能量开销明显减少.综合统计5个实验中所有结果,TDS-PRO、EAD-PRO和PEBD-PRO算法的能耗开销比优化前的算法平均减少23.71%、21.28%和23.51%.6结束语本文提出了一种考虑处理器、网卡和交换机的能耗统计模型,对集群服务器系统的能耗进行建模.在此基础上,对带前驱约束的并行任务调度问题进行了讨论,提出了一种减少处理器数目的调度优化方法.该方法能够找到合适的处理器空闲时间,将轻负载处理器上的任务合并到其它处理器上,减少处理器使用数目,从而降低系统总能耗.实验结果表明,在没有增加处理器调度长度的情况下,优化后的算法能够明显减少使用处理器数目和系统总能耗开销.
