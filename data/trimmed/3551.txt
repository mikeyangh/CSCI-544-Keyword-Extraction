Page1一种适用于具有相互依赖基本事件和重复事件的动态故障树独立模块识别方法张红林1)张春元1)刘东2)1)(国防科学技术大学计算机学院长沙410073)2)(装备指挥技术学院国防科技重点实验室北京101416)摘要为减小时间开销,动态故障树经常被模块化分解为独立的静态子树和独立的动态子树,然后分别使用二叉决策图和马尔卡夫模型求解;其中的一个关键问题便是识别具有相互依赖基本事件和重复事件的动态故障树中所有的独立模块和最小独立模块.文中提出了一个基于亲戚依赖关系的独立模块识别方法IIMKDR,该方法将故障树按照其事件之间的依赖关系转换为依赖树;基于面向对象思想,为依赖树及其节点构建对象;通过对各节点对象属性的分析,得出独立模块集并进而求出最小独立模块集.最后对IIMKDR方法进行了理论分析和实验验证,分析表明该方法适用于具有相互依赖基本事件和重复事件的动态故障树独立模块识别.与其它方法从多个角度所进行的实验对比显示,当故障树没有相互依赖基本事件和重复事件时,该方法的开销略高于其它方法;当故障树具有相互依赖基本事件和重复事件时,该方法能够正确识别其中所有的独立模块,而其它方法不具备这样的功能.关键词动态故障树;独立模块识别;相互依赖基本事件;重复事件;可靠性分析1引言故障树(FaultTree,FT)被广泛应用在系统可靠性分析中,为系统的失效行为提供了一个简单直观的描述方式.传统的静态故障树(StaticFaultTree,SFT)通过对各基本事件失效的布尔组合逻辑可得到系统的失效函数.静态故障树一般包括AND、OR、VOTE等布尔逻辑门,通常可以使用二值决策图(BinaryDecisionDiagram,BDD)方法求解.随着实践中对可靠性要求的提高以及一些可靠性设计技术的应用,出现了越来越多的动态系统,这些系统中各元件之间具有一定的动态顺序依赖关系.静态故障树无法对动态系统进行建模分析,文献[1]通过引入动态逻辑门将故障树扩展为动态故障树(DynamicFaultTree,DFT),从而使其具有对动态系统进行建模分析的能力.由于动态故障树中各事件之间具有时序依赖关系,因此无法使用数值组合逻辑进行求解,一般使用马尔卡夫模型进行求解[2].然而马尔卡夫模型具有固有的局限性,其所涉及到的系统状态数与系统基本事件数呈指数级关系,当系统的规模比较大时(实际应用的系统大都属于此类),为马尔卡夫模型建立状态转移矩阵将变成一个不可完成的任务,即所谓的状态空间爆炸问题.状态空间爆炸问题大大限制了马尔卡夫模型的应用.为解决状态空间爆炸问题,业界进行了许多研究.文献[3]给出了一种数值分析方法(DigitalNumericalAnalysis,DNA)来对动态故障树进行分析,该方法具有简单、直观、快速和准确的优点.针对现在许多系统包含大量冗余和备份部件,这些部件或模块可靠性特征完全相同,文献[4]提出了一种参数化故障树(ParametricFaultTree,PFT)模型,利用BDD方法的简单快捷特性,给出了一种参数化二叉决策图(ParametricBDD,PBDD)方法.文献[5]使用一个混合贝叶斯网络框架来分析求解动态故障树,该框架并不需要数值积分和模拟.文献[6]提出了一种对动态故障树优先与门进行定量分析的方法.文献[2]将马尔卡夫模型中的状态转移图分解为几个状态转移链,根据每个链的长度获得该链的概率公式.文献[7]把动态逻辑门转化为相应的动态贝叶斯网络,以计算节点失效概率和进行重要度分析.以上方法都需要识别出故障树中的独立模块、尤其是最小独立模块;模块化[8]是解决状态空间爆炸问题最根本的途径,其通过将整个故障树分解为多个独立模块,静态模块使用数值组合或BDD方法进行求解,动态模块使用马尔卡夫模型进行求解,最后再综合求出故障树顶层的可靠性参数,从而将求解时间开销从指数级降低为多项式级.另外,包括灵敏性分析在内的许多可靠性分析领域也依赖于故障树中独立模块的识别.故障树中独立模块的识别方法研究在可靠性分析领域具有极其重要的意义.静态故障树仅包含表征组合逻辑关系的静态逻辑门,文献[9]给出了一个识别静态故障树中独立模块的方法,它对故障树进行一次深度遍历,并为每个节点标注首次访问时间和末次访问时间,若某个节点的所有子节点的最先首次访问时间和最后末次访问时间分别大于该节点的首次访问时间和小于该节点的末次访问时间,则该节点及其子孙节点构成一个独立模块.使用深度遍历算法,其计算复杂度为O(N),其中N为故障树的节点个数.该方法的缺点有:只能应用于静态故障树,在遍历过程中,一旦发现动态逻辑门就会停止遍历;故障树中各基本事件相互独立,不含重复事件.文献[10]在文献[9]的基础上,提出了故障树中含有相互依赖基本事件的模块识别方法.它为每个事件建立依赖信息,并根据故障树的结构使依赖信息在各事件中传递,各事件的依赖信息结合访问时间确定故障树的独立模块.其缺点在于:若故障树含有重复事件或动态逻辑门,则该方法仍然无能为力.该方法本质上是属于构建独立模块,而不是识别独立模块,而如何构建仅仅通过一个实例说明,并未形成一个严谨的形式化算法.动态故障树不仅包含表征组合逻辑关系的静态逻辑门,还包含表征顺序依赖关系的动态逻辑门,另外动态故障树可能还含有重复事件,基本事件间可能还存在依赖关系,识别动态故障树中的独立模块因此变得非常困难.文献[11-12]在文献[9]的基础上,虽然提出了一个适用于动态故障树的独立模块识别算法,但其并未考虑动态故障树中包含相互依Page3赖基本事件和重复事件的情形,无法在这种情形下应用.本文在以上研究的基础上,提出了一个适用于动态故障树的基于亲戚依赖关系的独立模块识别方法(IdentificationofIndependentModulebasedonKinshipDependencyRelation,IIMKDR),其与以上研究不同之处在于:将动态故障树转化为依赖树,依赖树只包含事件之间的依赖信息,去除了故障树中各逻辑门的逻辑含义;改进深度优先遍历算法,使其适用于含有重复事件的情况;为每个节点加入祖先集属性和依赖集属性,当进行深度优先遍历时填充祖先集属性,将所有基本事件划分为不同的依赖类型,根据各基本事件的祖先集属性更新所有节点的依赖集属性.本方法抛弃了以前研究中以深度遍历访问顺序进行独立模块识别的思想,改以各节点的祖先集属性和依赖集属性进行识别,其与相互依赖基本事件、重复事件、动态逻辑门无关,适用于具有相互依赖基本事件和重复事件的动态故障树.为了便于说明,在不引起混淆的情况下,后文对于文献[9-11]所给出的方法与利用其方法得出的数据分别用其作者姓氏Dutuit、Sun和Huang标示.本文第2节介绍本文用到的基本概念;第3节简要概括IIMKDR方法的识别流程;第4~6节详细描述识别流程的各个步骤,分别是预处理、构建依赖树、识别等;第7节对IIMKDR方法进行详细的时间复杂性分析,并与其它方法在性能上进行理论分析和对比;第8节分别使用实际案例和仿真模拟对IIMKDR方法从多个角度进行验证,并将IIMK-DR方法和其它方法的实验结果进行对比分析;最后得出本文的结论.2基本概念动态故障树的构建是在静态故障树的基础上,通过引入多个动态逻辑门使得故障树具有了描述动态行为的能力.本节首先介绍各动态逻辑门,然后阐述本文所提出的相关概念.2.1动态逻辑门(1)PAND门优先与门(Priority-ANDGate,PAND)是AND门的拓展,它在AND门的基础上增加一个附加条件,这个条件规定了输入事件的发生次序.例如,对于具有一个输出事件和两个输入事件(A和B)的PAND门,当且仅当下列两个条件同时满足时,输出事件发生:①事件A和B都发生;②事件A先于事件B发生.PAND门的图形符号如图1(a)所示.如果A或B没有发生或者B在A之前发生,则输出事件不会发生.(2)WSP门温备门(Warm-SpareGate,WSP)具有一个初始输入和若干替补输入.初始输入是指在系统开始工作时就处于工作状态的部件,替补输入作为温储备,在工作部件失效前,替补处于温备状态,工作部件失效后,逐个依次替补.WSP门具有一个输出事件,仅当所有输入事件(初始输入和替补输入)发生后,输出事件才会发生.WSP门的图形符号如图1(b)所示.FDEP)由以下3种事件构成:本事件,也可以是故障树中其它门的输出;(3)FDEP门功能相关门(Functional-DependencyGate,①触发输入事件.触发输入事件可以是一个基②非相关输出事件.主要反映触发事件的状态;③若干相关基本事件.相关基本事件在功能上依赖于触发事件,当触发事件发生时,相关基本事件强制发生.FDEP门的图形符号如图1(c)所示.FDEP门的特征是:当触发事件发生时,直接产生输出,而所有相关事件随即成为不可达或无法使用.FDEP门的非相关输出事件并不对DFT中的其它结构产生影响,FDEP门主要通过约束相关基本事件的行为达到控制系统工作过程的目的.2.2其它相关概念(1)重复事件若某个事件同时是两个或两个以上逻辑门的输入事件,则该事件为重复事件.(2)依赖关系有两个事件a、b,若a的失效影响b的失效概率或b的失效影响a的失效概率,则称a和b具有依赖关系.基本事件间相互依赖的原因来自于基本事件间共因故障的存在.设p(a)和p(b)分别表示基本事Page4件a和b的失效概率,p(a|b)表示在b失效的条件下a的失效概率,则a和b相互依赖用数学公式可以表示为p(a|b)≠p(a)或p(b|a)≠p(b).(3)依赖类型共因故障可以抽象为依赖类型,若某个共因故障i影响事件a的失效概率,则称a依赖于依赖类型i.(4)节点称A为节点,当且仅当A具有以下属性:祖先集ancestor_set,父亲集parent_set,parent_setan-cestor_set,依赖类型集(简称依赖集)depend_set,遍历深度depth,标号ID.考虑到故障树中可能含有重复事件,给节点定义属性ancestor_set后,便可从一个节点直接找到该节点的所有祖先节点.属性depend_set为节点的依赖类型集合,依赖类型由基本事件之间的依赖关系给定.属性depth指的是构建依赖树时,该节点的遍历深度,使用该属性以便从独立模块集中找出最小独立模块集.属性ID指的是该节点的代号,实际上本文在算法实现中,将节点的深度优先遍历次序赋予属性ID.顶节点的父亲集属性为空;中间节点的父亲集属性不为空,同时还属于其它某个节点的父亲集;叶节点不属于任何其它节点的父亲集.,则称a和b具有亲戚依赖关系.a.ancestor_set,则称a和b具有直系血亲关系.(5)直系血亲关系两个节点a、b,若a∈b.ancestor_set或b∈(6)亲戚依赖关系两个节点a、b,若a.depend_set∩b.depend_set≠(7)依赖树依赖树具有与其对应故障树完全等价的依赖关系,含有一个顶节点、一个中间节点集合、一个叶节点集合.3识别流程IIMKDR方法包括依赖树构建算法、独立模块识别算法、最小独立模块识别算法等,这些算法会在后面详细阐述.IIMKDR方法的识别流程可以分为以下几个步骤:(1)故障树预处理负责对故障树进行一些预先处理,比如化简、变形等,以方便后续处理.(2)构建依赖树动态故障树含有不同类型的逻辑门,各逻辑门的逻辑意义互不相同;然而在识别独立模块时,关注的是各事件之间是否相互依赖,并不关心各事件之间的逻辑关系;因此可从动态故障树中抽取各事件之间的依赖关系,剔除各事件之间的逻辑关系,构建依赖树.依赖树完全保持了对应动态故障树的依赖信息,动态故障树的独立模块识别可转化为依赖树的独立模块识别.在构建依赖树时填充各节点依赖集属性之外的所有其它相关属性,包括祖先集属性、父亲集、遍历深度等.(3)独立模块识别叶节点的依赖集属性可从系统基本元件间的依赖关系获得,根据叶节点的依赖集属性、祖先集属性,填充其它各节点的依赖集属性.然后利用各节点的依赖集属性、祖先集属性,识别出独立模块集和最小独立模块集.4故障树预处理故障树结构的预处理旨在不改变其代表的逻辑函数情况下,将其形式简化,删减不必要的逻辑门和事件,以便后续处理.本文提出的预处理方法包括以下阶段:(1)收缩串接的同类型逻辑门可以收缩为一个逻辑门.这些逻辑门包括AND门、OR门、PAND门和SPARE门等,如图2所示.同类型串接的静态逻辑门都可以收缩为一个静态逻辑门,如图2(a)和图2(b)所示.这样的结论对于动态逻辑门则不一定成立,如图2(e)所示,PAND门要求输入的事件按照规定的顺序失效才会导致输出失效,假如事件a、b、c的失效顺序为b→a→c,则左边会导致输出失效,而右边则不会导致输出失效;对于图2(c)和图2(d)两种形式,收缩结论还是成立的.因此同类型串接的动态逻辑门是否能够进行收缩需要进行专门的分析.(2)结合故障树中符合图3和图4所示结构类型的(包括但并不限于),可以进行结合处理,以消除一个逻辑门,同时尽可能地消除重复事件,简化后续处理.需要注意的是,图4(b)并不能成立,理由同上文收缩阶段.(3)消去根据故障树所表达的静态或动态逻辑意义,消Page5图3故障树预处理结合阶段(仅含静态逻辑门)去一些冗余的逻辑门或事件,以简化处理.比如符合图5所示结构类型的(包括但并不限于),便可以进行消去处理.(4)宏事件始终成组以固定逻辑出现的基本事件可以看做是一个宏事件,在后续处理中,以此宏事件代替该组基本事件,减少事件数目.图4故障树预处理结合阶段(含动态逻辑门)(5)FDEP门FDEP决定了触发输入事件与其它输入事件之间的依赖关系,因其没有输出事件外联,此FDEP等效于多个OR门串接,如图6所示.在故障树中可分别以I1、I2代替I1、I2.Page65依赖树构建故障树刻画了事件之间的各种关系,包括静态组合逻辑关系和动态时序关系,但是当进行独立模块识别时,关注的仅仅是节点之间是否具有依赖关系.为了提高识别效率,有必要从故障树中提取节点之间的依赖关系构建依赖树,之后进行的独立模块识别都是建立在依赖树的基础上.基于面向对象思想为节点和依赖树构建对象,节点对象具有以下属性:祖先集ancestor_set,父亲集parent_set,依赖集depend_set,遍历深度depth,标号ID;依赖树对象具有以下属性:顶节点s,中间节点集MNS,叶节点集LNS.通过对故障树进行深度优先遍历来构建依赖树.算法1为依赖树构建算法DTC:前2行构建着色数组color;第4行的count变量表征各节点的遍历次序,此值将赋给相应节点的ID属性;依赖树节点构建算法CreateDTNode,如算法2所示,根据依赖树节点的对象大小,在内存中分配相应的空间,并将所有属性值设为空集或0,这些属性值在后续遍历时进行填充;在开始遍历前,依赖树的LNS和MNS属性为空,然后调用深度遍历算法DFS_VISIT.算法1.依赖树构建算法DTC.DTC(FT,DT)功能:从故障树构建依赖树对象输入:故障树FT(V,E),s为顶事件;输出:依赖树对象DT;1.foreacheventu∈V2.docolor[u]←WHITE;3.u←s;4.count←0;5.time←0;6.u0←CreateDTNode();7.DT.s←u0;8.DT.LNS←;DT.MNS←;9.DFS_VISIT(u,u0);10.returnDT.算法2.依赖树节点构建函数CreateDTNode.CreateDTNode()功能:构建依赖树节点输入:无输出:依赖树节点1.u0=newDTNode();2.u0.parent_set←;3.u0.ID←0;4.u0.depend_set←;5.u0.depth←0.算法3深度优先遍历函数DFS_VISIT为一个递归算法,对故障树从事件u开始遍历,并相应从依赖树中节点u0开始构建依赖树节点,填写各节点的有关属性值.在遍历过程中,通过对事件进行着色来表示事件的状态.开始时,每个事件均为白色,搜索中被发现时即置为灰色.每次调用DFS_VISIT(u,u0)时,事件u和节点u0分别成为故障树和依赖树中深度优先森林中一颗新树的根,事件u开始为白色,第2行置u为灰色,表示开始对事件u进行遍历;当事件u的邻接表adj为空时,表示该事件为故障树的基本事件,第7行将相应节点加入依赖树的叶节点集合;第9~25行检查和u相邻接的每个节点v,如果v为白色节点,表示该节点还未被访问,需构建相对应的依赖树节点v0,设置v0相关属性,并从节点v递归遍历;否则,仅需填充v0相关属性并从节点v递归遍历即可.传统的深度遍历算法没有第20~25行代码,为了支持含有重复事件的故障树,特加入这5行代码:即如果v并非白色,则表示该事件已被访问且v有两个或多个父事件,相应的依赖树节点v0也已被创建,但需将v0的属性parent_set和ancestor_set进行相应的更新,其子孙节点的相应属性也应进行相应的更新,故仍需递归遍历事件v.第18行为故障树事件和相应的依赖树节点映射表,第21行根据故障树事件获取依赖树节点对象.算法3.深度优先遍历算法DFS_VISIT.DFS_VISIT(u,u0)功能:对故障树进行遍历,并相应构建依赖树节点输入:故障树事件u,邻接矩阵adj,依赖树节点u0输出:从节点u0开始构建的各依赖树节点1.if(color[u]==WHITE)2.color[u]←GRAY;3.time←time+1;4.d[u]←time5.ifadj[u]==NULL6.then7.DT.LNS←DT.LNS∪{u0};8.else9.foreachv∈adj[u]10.doifcolor[v]=WHITEPage711.then12.v0←CreateDTNode();13.count←count+1;14.v0.parent_set←{u0}15.v0.ancestor_set←v0.ancestor_set∪16.v0.ID←count;17.v0.depth←u0.depth+1;18.FTMapDT(v,v0);19.DFS_VISIT(v,v0);20.else21.v0←MapToDTNode(v);22.v0.parent_set←v0.parent_set∪{u0}23.v0.ancestor_set←v0.ancestor_set∪24.time←time+2;25.DFS_VISIT(v,v0);26.if(color[u]==GRAY)27.color[u]←BLACK;28.time←time+1.图7为一个简单故障树示例,图8说明了函数DFS_VISIT在图7上的工作过程.执行完毕后,每个节点除去依赖集属性外其它属性(图8仅显示parent_set和ancestor_set属性)都已经得到填充,图8深度优先遍历函数DFS_VISIT在故障树上的工作过程.每个事件u旁有三元组向量(v1,v2,v3),其中v1表示对应故障树事件u的依赖树节点是否为叶节点,值T为是,值F为否;v2=parent_set[u0],表示对应故障树事件u的并且得到了依赖树的叶节点集合.各节点的依赖集属性在独立模块识别算法中进行填充.6独立模块识别随着故障树研究的深入,模块的定义也相应的发生变化.文献[13]将模块定义为至少两个基本事件的集合,这些基本事件向上可到达同一逻辑门,并且必须通过此门才能达到顶事件,故障树的所有其它基本事件向上均不能到达该逻辑门;Dutuit将模块定义为一个内部节点,其基本事件不会出现在故障树的任何其它地方.以上两个定义适用于基本事件相互独立的故障树.Page8无论模块如何定义,其基本思想是一脉相承的:将故障树分解成互不相关的部分分别进行处理,然后再对结果综合分析,从而降低故障树求解的代价.考虑到动态故障树所具有的动态依赖特性,本节给出一种更通用的独立模块定义和相应的独立模块识别算法,其中events(x)为以x和所有x的子孙事件所组成子树的基本事件集合.定义1.设u和v是故障树FT的两个事件,称u和v相互独立且记作u⊥v,当且仅当:u∈events(u),v∈events(v),则prob(uv)=prob(u)×prob(v),其中prob(x)为x的失效概率.定义2.设u为故障树FT的一个中间事件,称u为FT的一个独立模块当且仅当任给FT的一个事件v,必有下列一式成立:(1)events(u)events(v);(2)events(v)events(u);(3)u⊥v.定义3.设L是故障树FT的基本事件集,Li(i=1,2,…,n)是L的完全不相交子集,而且满足以下两个条件:(i)u,v∈Li,则prob(uv)≠prob(u)×(ii)u∈Li,v∈Lj且i≠j,则prob(uv)=prob(v);prob(u)×prob(v),则(1)称L1,L2,…,Ln是L的完全独立划分;(2)若u∈Li,则称u依赖于依赖类型i;(3)v是FT的一个事件,若u∈Li且u!⊥v,则称v依赖于依赖类型i;(4)v是FT的一个事件,={p1,p2,…,pm}是依赖类型集,若i∈都有v依赖于类型i,并且j都有v不依赖于依赖类型j,则称为v的完全依赖集.定理1.设u、v是故障树FT的任意两个事件,u_set和v_set分别是u和v的完全依赖集,且u_set∩v_set=,则u⊥v.证明.假设命题不成立,根据定义1,存在基本事件u0∈events(u)和v0∈events(v),且prob(u0v0)≠prob(u0)×prob(v0);根据定义3,u0和v0都依赖于同一个依赖类型,假设u0,v0∈Li;因为u0∈events(u)和v0∈events(v),所以u0!⊥u且v0!⊥v,根据定义3(3),u和v都依赖于依赖类型i;又因为u_set和v_set分别是u和v的完全依赖集,故而i∈u_set且i∈v_set,这与题设u_set∩v_set=矛盾.命题得证.故障树转变为与其依赖关系等价的依赖树后,故障树的每一个事件对应依赖树的一个相应节点.本节前面的定义和命题同样适用于依赖树,故障树的独立模块识别也转化为相应依赖树的独立模块识别.通过对依赖树各节点的相关属性进行分析,可识别出依赖树的独立模块,从而得到相应故障树的独立模块,以便进行其它可靠性分析.6.1独立模块识别算法经过预处理、构建依赖树后,依赖树各节点除去依赖集属性外其它属性都已填充,独立模块识别算法IIM(IdentificationofIndependentModule)根据依赖树各节点的祖先集属性和依赖集属性进行识别.其中心思想为:填充每个节点的依赖集属性,然后每个内部节点分别同与其非直系血亲的所有其它节点比对依赖集属性,若都不存在交集,则该内部节点即为独立模块,算法如算法4所示.算法4.独立模块识别算法IIM.IdentificationIndependentModule(DT,inputdep)功能:识别依赖树中的独立模块输入:依赖树DT(s,MNS,LNS),各叶节点的依赖集输出:独立模块集IM1.IM←;2.SetLeafSetDep(DT.LNS,inputdep);3.foreachu∈DT.LNS4.foreachv∈u.ancestor_set5.v.depend_set←v.depend_set∪u.depend_set;6.foreachu∈DT.MNS7.bIM=TRUE;8.foreachv∈DT.MNS∪DT.LNS/u.ancestor_set9.ifuv.ancestor_set10.ifu.depend_set∩v.depend_set≠11.bIM=FALSE;12.break;13.ifbIM==TRUE14.IM←IM∪{u};15.returnIM.IIM算法执行前,各节点的依赖集属性还未填充,因此第1行首先将独立模块集设为空,第2行将已知的故障树各基本事件依赖类型赋值给依赖树相应叶节点的依赖集属性.第3~5行根据每个叶节点的依赖集属性,更新该叶节点所有祖先的依赖集属性;这段代码执行完毕后,依赖树所有节点的依赖集属性完全确定.第6~15行将任一个内部节点的依赖集属性与它的所有非直系血亲节点的依赖集属性进行比较,如果没有交集,根据定理1,该节点为独Page9立模块.点所得的依赖集属性为完全依赖集.定理2.IIM算法3~5行执行完毕后,各节证明.(1)设v是依赖树的任一节点,若v∈DT.LNS,由于叶节点的依赖集属性是根据系统各基本元件间的共因故障类型设置的,每个叶节点的依赖集包括了所有该叶节点所依赖的依赖类型,并且所有该叶节点所依赖的依赖类型都包括在该叶节点的依赖集中,根据定义3(4),很明显v.depend_set是v的完全依赖集.v的依赖类型.于i.(2)若vDT.LNS,下面分两步进行证明:(2.1)本步证明v.depend_set的每个元素都是反证法,假设i∈v.depend_set且v并不依赖则u∈Li,由定义3(3)可知,u⊥v;①因为v.depend_set初始为空,由3~5行可知,依赖类型i必由某个基本事件u0主导加入,即u0∈Li使得v∈u0.ancestor_set,故而u0!⊥v.②①和②互相矛盾,本步得证.(2.2)本步证明v的所有依赖类型都在v.depend_set中.反证法.假设i使得v依赖于i而iv.depend_set.由3~4行知,events(v)∩Li=;否则假设u0∈events(v)∩Li,则v∈u0.ancestor_set,i∈u0.depend_set,于是i∈v.depend_set,与先前题设矛盾.所以events(v)∩Li=.因为v依赖于i,则u1∈events(v),u2∈Li且prob(u1u2)≠prob(u1)×prob(u2),由定义3可知,u1∈Li,于是u1∈Li∩events(v).③和④互相矛盾,本步得证.由(1)和(2)可得v.depend_set是v的完全依命题得证.定理3.IIM算法执行完毕后,所得的IM为完全独立模块集.证明.分两步进行,第1步证明IM中的所有模块都是独立模块,第2部证明依赖树的所有独立模块都在IM中.(1)本步证明IM中的所有模块都是独立模块.u∈IM,由第6行可知,u不是依赖树的顶节若v∈u.ancesor_set,则events(u)events(v);赖集.点或叶节点;任一节点v,若u∈v.ancesor_set,则events(v)events(u);若vu.ancesor_set且uv.ancesor_set,则由第10~14行可知,u.depend_set∩v.depend_set=,由定理1可得u⊥v;由定义2可知u是依赖树的一个独立模块.本步得证.(2)本步证明依赖树的所有独立模块都在IM中.反证法,假设依赖树存在独立模块u,但是uIM.由定义2可知,u既不是顶节点也不是叶节点;由第8~12行可知,存在一个节点v,且vu.ancestor_set和uv.ancestor_set,有u.depend_set∩v.depend_set≠,使得变量bIM=FALSE,以至于u未被加入IM中.这又与u是独立模块相矛盾.本步得证.由(1)和(2),命题得证.6.2最小独立模块识别算法识别出独立模块集IM后,还要从中识别出最小独立模块.最小动态独立模块是必须用Markov链求解的模块,识别出最小独立模块,能够显著缩减状态空间,降低求解开销.定义4.设u是依赖树DT的一个独立模块,称u是一个最小独立模块当且仅当:任给另外一个独立模块v,则uv.ancestor_set.最小独立模块识别算法IMIM(IdentificationofMinimumIndependentModule)如算法5所示,第1行首先将最小独立模块集MIM设为空集,第2行对IM集中各节点的遍历深度属性depth进行降序排序并赋值给IM0.排在IM0的首位模块必定为最小独立模块,第4~8行将首位模块u加入MIM的后面,并从IM0中去除u及u的祖先节点,如此反复,直至IM0为空,此时MIM即为最小独立模块集.算法5.最小独立模块识别算法IMIM.IdentificationMinimizeIM(IM)功能:识别最小独立模块输入:独立模块集IM输出:最小独立模块集MIM1.MIM←;2.IM0←SortIM(IM);3.whileIM0≠4.u←FirstNode(IM0);5.IM0←RemoveFirstNode(IM0);6.MIM←AddLast(MIM,u);7.AncestorSet←u.ancestor_set∩IM0;8.IM0←RemoveSet(IM0,AncestorSet);9.returnMIM.Page10定理4.IMIM算法执行完毕后,所得的MIM为完全最小独立模块集.证明.由第4~6行代码可知,MIMIM,故而MIM是独立模块集.下面分两步进行,第1步证明MIM的所有元素都是最小独立模块,第2步证明所有最小独立模块都是MIM中的元素.(1)反证法.假设u∈MIM,但u不是最小独立模块,也就意味着v∈IM,使得u∈v.ancestor_set.若v在第6行被加入MIM,因为v.depth>u.depth且IM0为IM的depth属性的降序排列,此时u必然还未被加入MIM.在第7行执行前,若u∈IM0,第7行执行后u∈AncestorSet,则第8行执行后uIM0,故而在后面的处理中u不可能被加入MIM,这与题设矛盾,本步得证.(2)反证法.假设存在u是最小独立模块,但uMIM.因为IM是完全独立模块集,故而u∈IM.由第4~8行可知,必存在一次循环,在此次循环中u∈AncestorSet,被从IM0中去除;假设在此次循环中被加入MIM的是v,则由第7行可知,u∈v.ancestor_set,而这又与u是最小独立模块相矛盾.本步得证.由(1)和(2),命题得证.7算法分析设故障树FT=(V,E),其中V为事件集,E为本节对IIMKDR方法的各算法进行时间复杂性理论分析,并将其与其它方法在性能上进行理论对比分析.7.1时间复杂性分析有向边集.算法1构建依赖树算法DTC中第1行的循环占用的时间为Θ(V).与传统深度优先遍历算法不同,需对依赖树中的重复节点及其子节点更新祖先集属性,对于故障树中任一事件v,过程DFS_VISIT可能被调用多次.下面详细分析之:(1)故障树中不含有重复事件.在这种情况下,每个事件至多仅有一个父事件.对于任一事件v,过程DFS_VISIT仅被调用一次.在DFS_VISIT(u,u0)的一次执行过程中,第12~19行被执行了|adj[u]|次,而第21~25行从不执行.∑v∈V|adj[v]|=Θ(E),执行DTC函数中第9行的总代价为Θ(E).因此DTC的时间开销为Θ(V+E).(2)故障树中含有重复事件.在这种情况下,有多个事件含有多个父事件,情况稍显复杂.假设故障树中含有i个重复事件,分别为m1,m2,…,mi.任给一个事件mj(1ji),则其父事件个数pnum[mj]=|mj.parent_set|.另外对每一个事件u,都对应一个发现时间和一个完成时间,其对应的时间戳分别为d[u]和f[u],事件u在时刻d[u]之前为白色,在时刻d[u]和f[u]之间为灰色,之后为黑色;同时也意味着以事件u开始的深度优先遍历共执行了(f[u]-d[u]+1)/2次DFS_VISIT算法,(f[u]-d[u]+1)/2也等于以u为根所组成的子树中的节点数.故而由于故障树中含有重复事件,DFS_VISIT中第20~25行被多执行了∑i(pnum[mj]-1)×(f[mj]-d[mj]+1)/2j=1次.设p为所有重复事件中父事件个数的最大值,q为所有以重复事件为根的子树中事件个数的最大值,则DFS_VISIT中第20~25行最多被执行了ipq次.因此,DTC的时间开销为Θ(V+E+ipq).算法4独立模块识别算法IIM的第3~5行时间开销小于Θ(V2),第6~14行执行代价也小于Θ(V2),于是IIM算法的时间复杂度最坏情况下为Θ(V2);算法5最小独立模块识别算法IMIM的第2行根据节点的深度属性进行降序排序,最优排序算法时间复杂度为Θ(|IM|log2|IM|),第4~8行最多执行了|IM|次.故而识别阶段时间复杂度最坏情况下为Θ(V2).综合构建依赖树算法DTC、独立模块识别算法IIM、最小独立模块识别算法IMIM等的时间复杂性分析,IIMKDR方法的时间复杂度最坏情况下为Θ(V2).7.2性能分析由于IIMKDR方法在构建依赖树阶段将故障树转化为依赖树,然后在依赖树的基础上进行处理,从而使其具有处理动态故障树的能力;由于算法3深度优先遍历函数DFS_VISIT增加了20~25行,从而使得IIMKDR方法能够对具有重复事件的故障树进行独立模块识别;又由于IIMKDR方法基于各节点的依赖集属性进行识别,从而可对具有互相依赖基本事件的故障树进行独立模块识别.因此,IIMKDR方法不仅可对传统故障树进行独立模块识别,还可对具有互相依赖基本事件和重复事件的动态故障树进行识别.Sun方法也使用了依赖属性的思想,也可对具有互相依赖基本事件的故障树进行独立模块识别;Page11其基于静态故障树进行分析,没有针对动态逻辑门进行专门的预处理,不适合处理动态故障树;其独立模块识别的核心算法仍是基于Dutuit方法,无法处理具有重复事件的故障树.Huang方法仅对动态故障树进行了一定的预处理,其独立模块识别的核心算法也是基于Dutuit方法,无法处理具有相互依赖基本事件和重复事件的故障树.由上节可知,IIMKDR方法的时间复杂度最坏情况下为Θ(V2).Dutuit方法的时间开销为Θ(V+E).Sun方法在其“模块化”步骤中完全采用Dutuit方法,但为了找出最小独立模块,又另加了“更新依赖信息”步骤和“为每个依赖信息重新模块化”步骤,时间总开销为Θ(V2).Huang方法识别核心算法完全同Dutuit方法一样,时间开销为Θ(V+E).8实验验证本节使用两种方法对IIMKDR方法进行验证,首先将IIMKDR应用于我们所设计的一个星载计算机系统,由于该系统是一个动态系统,而且其基本元件并不完全独立,故而Sun方法和Huang方法无法对其识别;然后采用模拟仿真方法对IIMKDR方法、Sun方法和Huang方法进行详细的求解开销、错误率的对比.8.1实际案例验证图9和图10分别为一个星载计算机的系统结构图和动态故障树,星载计算机系统包括4个模块:处理模块、电源模块、存储模块和总线模块.处理模块中含有3个处理单元A1、A2和A3,A3为A1和A2的冷备份,只要3个处理器全部失效就会导致系统失效.电源模块包括3个功能单元P1、P2和C,其中P1和P2为两个供电单元,C为切换控制单元,电源模块为3个处理单元供电,只要P1或P2有一个正常运作并且C正常运作,便能给3个处理单元正常供电.存储模块包括5个存储单元,若其中3个单元失效,则存储模块失效;存储单元M1和M2连接存储接口MIU0,M4和M5连接MIU1,M3即连接MIU0又连接MIU1.总线模块包括两个系统总线B1和B2,只要两条总线全部失效就会导致系统失效.另外假设基本元件A1和A2因为共因故障原因相互关联,设这两个元件依赖于依赖类型1;A3单独依赖于依赖类型2;P1和P2依赖于依赖类型3,C依赖于依赖类型4;M1、M3和M5依赖于依赖类型5,M2和M4依赖于依赖类型6;MIU0和MIU1依赖于依赖类型7;B1和B2依赖于依赖类型8.经过预处理,图10可转变为图11.图11中粗线边框的事件为宏事件,因为P1和P2经AND门的组合事件在故障树中仅出现一次,因此可将此两基本事件(包括与其相连的AND门)以宏事件P代替,同理也可得到宏事件bus.原故障树中含有FDEP门,根据预处理中关于FDEP门的处理,将其转换为OR门并外联之公共父事件.输入预处理后的星载计算机故障树,经过依赖树构建算法处理后,输出如图12所示的星载计算机依赖树;为了节省篇幅,仅显示PW、A、M、bus4个Page12节点的各属性、首次遍历发现时间、首次遍历结束事件,如表1所示.IDparent_setancestor_setdepthd[u]f[u]PW1SA4SM10Sbus24S经过独立模块识别算法IIM和最小独立模块识别算法IMIM处理后,星载计算机系统的独立模块集和最小独立模块集分别为IM={PW,A,M,bus},MIM={PW,A,M,bus},直观上很容易看出这是正确的答案.Sun方法和Huang方法,由于其应用局限性,无法求解本案例.8.2仿真验证独立模块识别的时间开销与许多因素都有关系,这些因素包括故障树结构、事件个数、重复事件位置及个数、依赖类型个数等.每次实验都可看做是个特例,无法说明某个方法的优劣.为了尽可能地与Sun方法、Huang方法进行对比,将它们都在Matlab平台上使用相同的编程风格和库函数实现.由于Sun方法仅应用于静态故障树,故而在本组实验中,剔除动态逻辑门在识别过程中的影响,求解的对象实际是静态故障树(也可看作IIMKDR方法中的依赖树),对比3种方法的核心算法在具有重复事件、具有相互依赖基本事件的故障树上的适用性、求解开销.静态故障树(亦可理解为依赖树)随机仿真生成过程如下:(1)若无指定总结点数,随机生成总结点数;(2)随机生成叶节点个数,叶节点个数要大于总结点数的一半;(3)随机生成依赖类型个数,依赖类型个数要小于叶节点个数;(4)随机生成最小独立模块,其个数要小于依赖类型个数,若依赖于同一个依赖类型的叶节点个数大于1,则这些叶节点属于且仅属于某个最小独立模块;(5)若依赖于某个依赖类型的叶节点只有一个,则该叶节点称为独立叶节点,以所有最小独立模块、独立叶节点为基本单位,随机生成上层节点(包括独立模块),直至根节点.由此仿真过程可知,当故障树随机生成完毕,故障树中含有的最小独立模块和独立模块皆是已知,将其与3种方法识别所得的结果进行比较,便可得到识别准确率.仿真程序使得故障树的生成尽可能具有随机性,但是真正的随机数是不存在的,生成的过程中也有一定的条件限制,因此生成的故障树还不能称为完全随机,某个或多个故障树可能会更加倾向于适用某种方法,从而对实验结果造成误差,我们采用生成求解很多次并取平均值的方法来尽量减小这种误差.为了对比的公平性,3个方法识别的对象都是同一个随机仿真生成的故障树,正如前面所述,该故障树实际上仅含依赖信息,因此3种方法针对逻辑结构所采取的预处理过程可以忽略,本节仅是比较3个方法核心算法的优劣.虽然Sun方法和Huang方法都比较复杂,但是其核心算法都还是比较直观简洁,而且核心算法在方法的正确性和效率上起着绝对主要的作用;所以尽管我们的实现不可避免会引入误差,但是我们仅是对比其核心算法,这些误差是可以容忍的.将实验分成以下3组,为了克服每次实验的偶然性,每个实验数据都是多次随机取平均值得到.其中遗漏率(NegativeErrorRate)是指本应识别而未能识别为独立模块的数目所占的比重,错加率(PositiveErrorRate)是指本非而被识别为独立模块的数目所占的比重,IMS(IndependentModuleSet)和MIMS(MinimalIndependentModuleSet)分别指独立模块集和最小独立模块集.实验1.仅含重复事件的故障树.每次故障树生成时,总事件个数设定为600,重复事件的个数及位置随机生成,重复10000次.当含有某重复事件数目的案例大于20次时,再求此重复事件数目下的时间开销、错加率和遗漏率等的平均值.实验结果如图13、图14和图15.含有重复事件的故障树中所有的独立模块都能被3种算法识别出来,故而3种算法的独立模块识别遗漏率都为零,为节省篇幅没有列入文中.由图13、图14和图15可知,IIMKDR方法对于含有重复事件的故障树,其独立模块和最小独立模块的Page13错加率和遗漏率都为零,也就是说该方法能够准确识别含有重复事件故障树的独立模块和最小独立模块.而Sun方法和Huang方法对于独立模块的识别虽然遗漏率为零,但仍有错加率;且对最小独立模块的识别既有错加率又有遗漏率,也就是说这两种方法不适用含有重复事件故障树的模块识别.实验2.仅含相互依赖基本事件的故障树.每次故障树生成时,总事件个数设定为600,依赖类型组合随机生成,重复10000次,仅保留每种依赖类型数目的案例数大于20的情况,并按照不同的依赖类型数目求识别时间、遗漏率、错加率等平均值.实验结果如图16、图17所示.图17Huang方法对含有相互依赖基本事件在IIMKDR方法的实现中,每个基本事件都归属于且仅归属于一个依赖类型,而平时所称的相互依赖基本事件是指多个基本事件归属于同一个依赖类型.图16和图17中所指的依赖类型数目等价于IIMKDR方法中所关联基本事件数大于1的依赖类型数目.在本次实验中,总结点数是一定的,当依赖类型数增加时,则IIMKDR实现中仅含一个基本节点的依赖类型数目会有相应减少的趋势,正如图16所示,在依赖类型数目处于区间(102~142)时,时间开销呈下降的态势.当然该种下降态势并非是绝对的,但是足以说明IIMKDR方法的时间开销与依赖类型数目之间并没有递增的关系.Huang方法并不区分相互依赖基本事件和一般事件,故而其时间开销基本保持不变.而当依赖类型增加时,Sun方法处理依赖信息及有关寻觅最小模块所花费的开销就会增加,从而导致其与依赖类型数目有递增的关系.对于仅含相互依赖基本事件的故障树,IIMKDR方法和Sun方法均能正确识别,而Huang方法则会产生独立模块识别错加率和最小独立模块识别错加率及遗漏率.也就是说只有IIMKDR方法和Sun方法可以对仅含相互依赖基本事件的故障树进行模块识别.Page14的故障树实验3.不含相互依赖基本事件和重复事件每次故障树生成时,总事件个数随机从100到300取值,每个实验数据都是重复70次的平均值.实验结果如图18所示.图183种算法对不含相互依赖基本事件和重复3种算法都能够正确识别不含相互依赖基本事件和重复事件故障树的独立模块和最小独立模块,由于错误率都是0,为节省篇幅就不列图了.由图18可看出,3种算法中,IIMKDR方法时间开销略高于Sun和Huang,Sun的时间开销又略高于Huang.实验4.既含重复事件又含相互依赖基本事件的故障树.因变量:识别时间、遗漏率、错加率;实验参数:节点个数:600;重复事件数:100;依赖类型数:100;实验方法:故障树生成时,总事件个数、重复事件个数、依赖类型数分别设置为600、100、100,重复事件的位置和相互依赖基本事件的位置皆随机生成,重复10000次,并求解时间开销、错加率和遗漏率等的平均值.实验结果如表2所示,其中IMSPE、IMSNE、MIMSPE和MIMSNE分别为独立模块错加率、独立模块遗漏率、最小独立模块错加率和最小独立模块遗漏率.表2既含重复事件又含相互依赖基本事件的IIMKDR11.9930000Sun10.8730.37100.3660.343Huang10.3630.68200.7130.707若一个故障树中既含重复事件又含相互依赖基本事件,则IIMKDR方法能够正确识别出独立模块和最小独立模块;Sun方法和Huang方法在独立模块的识别过程中,虽然其遗漏率为0,但是其错加率大于0,也就是说会将一些不是独立模块的节点识别为独立模块.由于Sun方法能够处理相互依赖的基本事件,故而其错加率要明显低于Huang方法.从表2也可看出,IIMKDR方法的识别时间要略高于Sun方法和Huang方法.9结论独立模块的识别在动态故障树研究中具有极其重要的意义,它是灵敏性分析、可靠性的定性和定量分析的基础.本文提出了一种基于亲戚依赖关系的独立模块识别方法IIMKDR,并将之与其它两种方法进行了对比,理论分析及实验结果均表明:它可以对具有相互依赖基本事件和重复事件的动态故障树进行处理,而其它两种方法都不具备这样的功能;对于不含相互依赖基本事件和重复事件的故障树,处理开销略高于Sun和Huang.下一步我们将把IIMKDR方法应用到动态故障树的重要度分析研究中,使其能显著降低问题求解的代价.
