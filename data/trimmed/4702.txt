Page1基于超扩展规则的知识编译方法1)(吉林大学计算机科学与技术学院长春130012)2)(吉林大学数学学院长春130012)3)(符号计算与知识工程教育部重点实验室(吉林大学)长春130012)摘要超扩展规则是对扩展规则的扩充,基于超扩展规则能够求得任意两个非互补且不相互蕴含的子句所能扩展出极大项集的交集与差集,并将所得结果以EPCCL理论的形式保存.该文首次提出了扩展反驳方法,是一种新型推理方法,并在该推理方法与知识编译之间建立了联系.基于超扩展规则的性质,该文还提出了两种知识编译算法:求并知识编译算法UKCHER和求差知识编译算法DKCHER,是两种新的知识编译算法.算法UKCHER是目前为止唯一一个可并行的EPCCL理论编译算法,算法DKCHER对于相变点附近的难解问题具有较高的编译效率和编译质量.实验结果表明:UKCHER算法的编译效率和编译质量均优于Lin等人提出的KCER算法;当子句数和变量数的比值较大时,DKCHER算法的编译效率和编译质量是最优的,相比于现有EPCCL理论编译算法,该算法具有较强的竞争力.关键词知识编译;扩展规则;超扩展规则;EPCCL理论;扩展反驳1引言可满足性问题(SAT问题)是NP完全问题的核心[1],相变现象在不同形式的SAT问题中是普遍存在的[2-3],相变点附近的命题可满足性判定通常需要巨大的时间开销.目前主要通过改善局部搜索或设计新型启发式等手段使得SAT求解得以高效实现[4-8].然而SAT求解始终需要指数级的时间,而且通过多次调用SAT求解器对一个知识库进行多次查询显然也是不合适的.同时许多约束问题仅判定可满足性是远远不够的,如将概率推理问题[9]、一致性概率规划问题[10]转换为命题公式集后,除了判定可满足性之外,还需解决该公式集的模型计数问题,即计算所有模型(可满足的真值指派)个数,模型计数问题也称为#SAT问题.#SAT问题是概率推理中的重要问题,它能在多项式时间内与贝叶斯推理进行相互转换,在扩展规则推理方法提出之前,绝大多数#SAT问题的求解算法都是基于#DPLL算法设计的[11].知识编译的主要目的是为了提高某些任务的计算效率,主要思想为将问题的求解分为两个基本阶段:离线编译和在线推理.知识编译方法能够使得命题推理和模型计数等问题得以高效解决,原因在于:在线推理通常能够在多项式时间内完成,而对编译结果进行多次查询能够补偿编译过程所消耗的时间.delVal[12]给出了可控制类的概念,可以作为目标编译语言的判断标准.Marquis[13]提出了一种基于本原蕴含式的知识编译方法,并研究了几种不同目标编译语言中存在的闭包[14-15].Darwiche[16-17]提出了一种将子句形式的命题公式编译为可分解否定范式(DNNF)的完备知识编译方法,并依据编译语言的简洁性及编译语言在多项式时间内所支持的查询类型两个基本关注点,对不同编译方法进行分析,给出了知识编译的发展图谱[18].Fargier等人[19]基于Krom、Horn和Affine等3种较有影响力的命题片段对Darwiche提出的知识编译发展图谱做了扩充,并设计了针对变种表示语言的知识编译图谱[20]和有序真值决策图的知识编译图谱[21].Koriche等人[22]研究了基于Affine决策树的模型计数方法,并弥补了知识编译图谱中Affine族的空缺.Lai等人[23]设计了带有蕴含文字的有序二元决策图,是一种新的知识编译语言.目前,国际上针对知识编译的研究多集中于对各种知识编译语言的比较,以及如何提高目标语言的查询能力.2003年,Lin等人[24]提出了扩展规则推理方法(ExtensionRule,ER),被著名人工智能专家Davis称为与归结方法“互补”的方法.与归结方法相反,扩展规则推理方法通过扩展出所有极大项组成的集合判定子句集的可满足性.Lin等人[24]基于扩展规则提出了一种新的命题逻辑理论证明方法IER.殷明浩等人[25]提出了CER算法,该算法基于容斥原理解决了ER算法在求解#SAT问题的空间复杂性问题.赖永等人[26]提出了一种命题扩展规则方法ER的高效实现和#ER算法,并结合#DPLL算法和#ER算法提出了#CDE算法,具有较高的命题推理效率和#SAT求解效率.许有军等人[27]提出了间接应用扩展规则的MCEHST算法,适应子句长度短,子句集规模大的问题.李莹等人[28]在ER算法的基础上提出了分别基于IMOM和IBOHM启发式策略的IMOMH_IER和IBOHMH_IER算法,提高了扩展规则推理算法的效率.此外,基于扩展规则还提出了一种新的定理证明技术NER[29].在扩展规则的基础上,Lin等人[30]提出了一种基于扩展规则的知识编译方法KCER,可以将子句集编译为EPCCL理论.此外,Yin等人[25,31]基于扩展规则和知识编译设计了求解模型计数问题的KCCER算法,该算法具有较高的效率.谷文祥等人[32]设计了MCN和MO两种启发式策略,提高了KCER算法的编译效率,并降低了编译后的子句集规模.刘大有等人[33]证明了EPCCL理论能够满足文献[18]所提出的所有查询标准,并基于扩展规则提出了一种新的EPCCL理论编译器C2E,该编译器具有较高的编译效率.基于EPCCL理论能够在线性时间内实现知识编译图谱中的全部查询操作.该理论是一种高效的目标编译语言,相对于现有知识编译语言具有较Page3强的竞争力,因此提高EPCCL编译器的编译效率及编译质量具有重要意义.本文基于自身提出的超扩展规则①[34],提出了扩展反驳的概念,利用超扩展规则能够实现输入子句集的扩展反驳过程,并在扩展反驳过程与基于知识编译之间建立了联系.由于现有知识编译算法存在一些缺陷,本文基于超扩展规则提出了两种知识编译算法:UKCHER算法和DKCHER算法,这两种算法具有不同的适用范围,且相比于现有EPCCL理论编译算法具有较大的优势.本文第2节介绍超扩展规则的基本概念和性质;第3节提出了扩展反驳方法;第4节阐述求并知识编译的基本原理并设计知识编译算法UKCHER;第5节阐明反向求差知识编译的基本原理并设计知识编译算法DKCHER;第6节为实验部分,对本文提出的两种知识编译算法与现有EPCCL理论知识编译算法进行了比较;最后为本文总结.2超扩展规则扩展规则能够对单个子句和单个原子进行扩展操作.在求解推理问题的过程中,直接对多个子句操作能够提高处理效率,并且尽可能多地利用潜在的问题结构.超扩展规则,是一种应用于两个子句之间的经典扩展规则的扩展形式.定义1(扩展规则,ExtensionRule)[24].给定一个子句C和一个变量集M,D={C∨a,C∨a},其中a∈M并且a和a都不在C中出现,将C到D的推导过程称为扩展规则,D中的子句称为C扩展得到的结果,并且C≡D.由定义1可以看出,扩展规则与归结规则是完全相反的规则,同时,定义1应用扩展规则后得到的子句集与原子句集等价,因此,扩展规则可以被看作是一条新的推理规则.应用扩展规则后,D中子句间存在互补文字对.应用扩展规则推理方法过程中,期望得到扩展结果中子句间最好存在更多的互补文字对,以利用扩展规则的推理特性:依赖扩展规则的推理方法适用于互补因子较高的子句集可满足性判定[15].扩展规则要求一个子句结合一个变量进行扩展,超扩展规则允许一个子句结合另一个子句进行扩展.为了表示方便,定义子句C的(原子)变量集合为V(C),子句C关于变量集M所能扩展出的极大项集合为J(C),子句集F的(原子)变量集合为V(F).本文所研究的子句集中不包含重言式,同时符号‘≡’表示式子两边语义等价.对于单个子句C,C≡J(C).定义2(超扩展规则,HyperExtensionRule).给定两个子句C和A,D={C∨A,C∨A},其中V(C)∩V(A)=,将C到D的推导过程称为超扩展规则,D中的元素为C应用超扩展规则的结果.本文为了表示更直观,在定义2中规定V(C)∩V(A)=,然而该条件并非必要条件.由定义2可以推出,如果A/C,且A和C不包含互补文字对,则利用A对C扩展所得到的结果为D={C∨A,C∨(V(A)-V(C))},其中C∨A为标准子句,即不包含相同的文字.定理1.超扩展规则中,子句C与其应用超扩展规则的扩展结果D是等价的.证明.可以通过真值表证明子句C及其扩展结果语义上是等价.与经典扩展规则不同,超扩展规则用子句A对子句C进行扩展,但这种扩展方法产生的C∨A为非子句形式(C∨A为标准子句形式),因此需要对C∨A以适当形式展开.假设A={b1,…,bn},则运用德摩根律,E={C∨A}={C∨(b1∨…∨bn)}={C∨b1,…,C∨bn}.上述展开过程是语义等价的,但由于每个bi(i=1,…,n)两两不同且均不在C中出现,所以E的互补因子较低,难以利用扩展规则的推理特性.为了保证扩展结果子句间的互补性,采用如下方法展开:称式(1)的展开过程为互补展开,则E={C∨A}={C∨b1,C∨b1∨b2,…,C∨b1∨…∨bn-1∨bn},进而D={C∨b1∨…∨bn,C∨b1,C∨b1∨b2,…,C∨b1∨…∨bn-1∨bn}.定理2.依赖式(1)的互补展开保证了超扩展规则的等价性,并且展开结果子句之间存在互补文字对.证明.假设A={b1,…,bn},由于C本身对扩展①本文涉及的“超扩展规则”概念是我们的前期工作,用于构Page4结果性质没有影响,只需要证明:(1)A=(b1∨…∨bn)与Z={{b1},{b1∨b2},…,{b1∨…∨bn-1∨bn}}等价;和(2){b1,b1∨b2,…,b1∨…∨bn-1∨bn}子句之间存在互补文字对.其中(2)显然成立.下面证明(1).证明.若A为真,则A中所有文字均被弄假,而Z中每个子句均包含A中一个文字的否定,因此Z为真.若A为假,假设Z为真,则Z中每个子句均为真.为使第1个子句b1为真,则b1必须被弄假;同样,为使第2个子句b1∨b2为真,而b1为假,则b2必须被弄假;依次传播到b1∨…∨bn-1∨bn,则bn必须被弄假.因此,若Z为真,则所有bi(i=1,…,n)均为假,进而A为假,A为真,与假设矛盾.因此,若A为假,则Z为假.综上,结论(1)得证,进而定理2成立.证毕.也可以采用式(2)的形式描述互补展开.CNFlinear(A∨(l∨B))={A∨l,{A∨B∨l}∪CNFlinear(A∨B),B>定义3(EPCCL理论)[30].子句集F是一个EPCCL理论,则F中任意两个子句间均含有互补文字对.超扩展规则能够利用一个子句扩展另一个子句,并且利用互补展开在保证可满足性的前提下保证了扩展之后的子句间存在互补文字对,这使得扩展过程能够高效进行并得到能够发挥扩展规则推理方法特性的理论.通过结合EPCCL理论,本文进一步挖掘了超扩展规则的其他特殊性质:性质1.对两个子句使用超扩展规则得到的结果是一个EPCCL理论,由于互补展开使得超扩展规则的展开结果中所有子句之间存在互补文字对,因此使用超扩展规则得到的结果是一个EPCCL理论.性质2.基于超扩展规则可以计算任意两个子句所能扩展出极大项的交集.对于两个子句C和A,如果A/C,且A和C不包含互补文字对,利用子句A扩展子句C可以得到结果D={C∨A,C∨(V(A)-V(C))},其中C∨A代表了J(C)∩J(A).性质3.基于超扩展规则能够利用EPCCL理论保存两个子句所能扩展极大项集合的差集.对于两个子句C和A,如果A/C,且A和C不包含互补文字对,利用子句A扩展子句C可以得到结果D={C∨A,C∨(V(A)-V(C))},其中{C∨(V(A)-V(C))}代表了J(C)-J(A).3扩展反驳过程归结反驳的基本含义为:若判断FC,只需判断对于子句集F∪{C}是否存在一个归结过程,该过程能够得到一个空子句.然而对于互补因子高的问题,归结反驳过程需要做大量归结,其求解效率较低.扩展规则能够用于求解互补因子较高的问题,然而利用扩展规则进行反驳需要定义新的反驳过程.引理1[24].给定子句集F及其原子集M(|M|=m),若F中所有子句均为M上的极大项,则F不可满足当且仅当|F|=2m.基于引理1,本文提出了扩展反驳过程的基本定理.定理3.给定子句集F,C是待查询的子句,F1是通过对F∪{C}等价变换得到的子句集,且F1中所有子句均为M=V(F)∪V(C)上的极大项(|M|=m),则FC当且仅当|F1|=2m.证明.若要FC判断是否成立,只需判断F∪{C}是否可满足.若F∪{C}不可满足,则FC成立,否则不成立.若|F1|=2m,由于F1是由F∪{C}等价变换所得,根据引理1,有F∪{C}是不可满足的,因此FC成立.若FC成立,则F∪{C}不可满足,由于F1与F∪{C}等价且F1中所有子句均为M上的极大项,因此必然有|F1|=2m.由定理3可以得到一个基于扩展规则FC的扩展反驳扩展:首先将子句C取否定之后加入F中,然后将F∪{C}所有子句利用扩展规则扩展为V(F∪{C})上的极大项,并将这些极大项保存在集合F1中,接着去掉F1中所有重复的极大项,最后通过判断F1的模来决策FC是否成立.上述过程是一个基本的扩展反驳过程,其终止条件为将F∪{C}扩展为由极大项组成的子句集.然而将F∪{C}中所有子句扩展为极大项形式进行计算是不现实的,因为这会导致指数级的时间复杂度和空间复杂度.Lin等人[20]基于容斥原理提出了ER算法解决了这一问题,然而ER算法并没有真正地对子句进行扩展,而仅仅通过容斥原理对子句集所能扩展出的极大项集的个数进行了计算.本文将利用超扩展规则对子句集扩展,并利用Page5EPCCL理论的特性定义扩展反驳过程的终止条件.推论1.给定子句集F及任意子句C,则FC当且仅当|J(F)∪J({C})|=2m,其中J(F)和J({C})均为V(F)∪V(C)上的极大项,且|V(F)∪V(C)|=m.由推论1可知,扩展反驳过程并不需要将所有子句扩展为极大项的形式.对扩展过程加以控制,如果得到某个中间结果使得计算子句集所能扩展出的极大项数变得易处理,则可以停止扩展过程,这种中间结果的最佳形式为EPCCL理论,因此,本文对扩展反驳过程做了改进.引理2[24].给定任意两个子句Ci和Cj,变量集M满足(V(Ci)∪V(Cj))M,Ci和Cj在M上所能扩展出的极大项集分别为J(Ci)和J(Cj),Ci与Cj互补当且仅当J(Ci)∩J(Cj)=.推论2.给定任意两个子句Ci和Cj,变量集M满足(V(Ci)∪V(Cj))M,Ci和Cj在M上所能扩展出的极大项集分别为J(Ci)和J(Cj),若Ci与Cj互补,则|J(Ci)∪J(Cj)|=|J(Ci)|+|J(Cj)|且J(Ci)-J(Cj)=J(Ci).由推论2可以得出:对于两个互补子句Ci和Cj,显然{Ci,Cj}就是一个与J(Ci)∪J(Cj)等价的EPCCL理论.推论3.给定子句集F和子句C,J(F)和J(C)均为V(F)∪V(C)上的极大项集.若J(C)∩J(F)=,则C与F中所有子句互补.证明.利用反证法,假设存在一个子句D∈F,且D与C非互补,则根据引理2有J(D)∩J(C)≠.又因为D∈F,则J(D)J(F),因此必然有J(C)∩J(F)≠,与条件不符,推论3成立.证毕.定理4.给定子句集F,C是待查询的子句,|V(F)∪V(C)|=m,F1={C1,…,Cn}是通过对F∪{C}等价变换得到的子句集,且F1中是一个EPCCL理论,则FC当且仅当∑1in证明.根据引理2有F1所能扩展出的极大项数为∑1in2m-|Ci|,则根据推论1,定理4显然成立.证毕.事实上,基于知识编译能够快速实现扩展反驳,将子句集F编译为等价的EPCCL理论之后,就能够在多项式时间内将F∪{C}等价变换为EPCCL理论,KCER算法[26]和C2E算法[28]是两种已有的EPCCL理论编译算法,然而二者都不能并行,且很多情况下编译过程需要较长时间.本文基于超扩展规则设计了求并知识编译算法UKCHER和求差知识编译算法DKCHER,其中算法UKCHER可以并行实现.4基于超扩展规则的求并知识编译定理5.给定任意两个子句Ci和Cj,变量集M满足(V(Ci)∪V(Cj))M,Ci和Cj在M上所能扩展出的极大项集分别为J(Ci)和J(Cj),若CiCj,则J(Ci)∪J(Cj)=J(Ci)且J(Cj)-J(Ci)=.证明.因为CiCj,则V(Ci)V(Cj),且Ci和Cj之间不存在互补文字,则有J(Cj)J(Ci)成立,因此J(Ci)∪J(Cj)=J(Ci)成立且J(Cj)-J(Ci)=成立.定理6.给定任意两个子句Ci和Cj,变量集M满足(V(Ci)∪V(Cj))M,Ci和Cj在M上所能扩展出的极大项集分别为J(Ci)和J(Cj),若Ci/Cj,Cj/Ci,且Ci和Cj之间不存在互补文字,则利用超扩展规则可以将J(Ci)∪J(Cj)等价表示为S1={Ci,Cj∨(V(Ci)-V(Cj))}或S2={Cj,Ci∨(V(Cj)-V(Ci))}或S3={Ci∨(V(Cj)-V(Ci)),Cj∨(V(Ci)-V(Cj)),Ci∨(V(Cj)-V(Ci))}或S4={Ci∨(V(Cj)-V(Ci)),Cj∨(V(Ci)-V(Cj)),Cj∨(V(Ci)-V(Cj))},其中,S1~S4均为EPCCL理论,且S3和S4为相同公式的不同抽象形式.证明.首先J(Ci)∪J(Cj)=J(Ci)∪(J(Cj)-J(Ci))=J(Cj)∪(J(Ci)-J(Cj))=(J(Ci)-J(Cj))∪(J(Cj)-J(Ci))∪(J(Cj)∩J(Ci)).因为Ci/Cj,且Ci和Cj之间不存在互补文字,根据超扩展规则,J(Cj)-J(Ci)≡Cj∨(V(Ci)-V(Cj)),则J(Ci)∪J(Cj)=J(Ci)∪(J(Cj)-J(Ci))≡{Ci,Cj∨(V(Ci)-V(Cj))}成立,即J(Ci)∪J(Cj)≡S1.同理J(Ci)-J(Cj)≡Ci∨(V(Cj)-V(Ci)),则J(Ci)∪J(Cj)=J(Cj)∪(J(Ci)-J(Cj))≡{Cj,Ci∨(V(Cj)-V(Ci))}成立,即J(Ci)∪J(Cj)≡S2.由于Ci∨(V(Cj)-V(Ci))≡Cj∨(V(Ci)-V(Cj))≡J(Cj)∩J(Ci),且Ci∨(V(Cj)-V(Ci))和Cj∨(V(Ci)-V(Cj))均为单个子句,则Ci∨(V(Cj)-V(Ci))=Cj∨(V(Ci)-V(Cj)).因此有{Ci∨(V(Cj)-V(Ci)),Cj∨(V(Ci)-V(Cj)),Ci∨(V(Cj)-V(Ci))}={Ci∨(V(Cj)-V(Ci)),Cj∨(V(Ci)-V(Cj)),Cj∨(V(Ci)-V(Cj))}≡J(Ci)∪J(Cj)成立,即J(Ci)∪J(Cj)≡S3=S4.Page6根据超扩展规则的性质3,Cj∨(V(Ci)-V(Cj))展开后为一个EPCCL理论,又因为J(Ci)∩(J(Cj)-J(Ci))=,因此根据推论3,Ci与Cj∨(V(Ci)-V(Cj))中所有子句均互补,因此S1={Ci,Cj∨(V(Ci)-V(Cj))}中所有子句均互补,S1是一个EPCCL理论,同理可证得S2={Cj,Ci∨(V(Cj)-V(Ci))}是一个EPCCL理论.显然(J(Ci)-J(Cj)),(J(Cj)-J(Ci))和(J(Cj)∩J(Ci))这3个集合中两两不相交,因此{Ci∨(V(Cj)-V(Ci)),Cj∨(V(Ci)-V(Cj)),Ci∨(V(Cj)-V(Ci))}中所有子句之间均互补,即S3为一个EPCCL理论,由于S3=S4,因此S4同样是一个EPCCL理论.综上,定理6成立.由于S3和S4的计算结果一样,对于非互补且不存在蕴含关系的两个子句,定理6实际上给出了求解两个子句所能扩展出极大项集并集的3种基本方法,且所得结果均为EPCCL理论.根据超扩展规则,显然|S1|=1+|V(Ci)-V(Cj)|,|S2|=1+|V(Cj)-V(Ci)|,|S3|=1+|V(Ci)-V(Cj)|+|V(Cj)-V(Ci)|.在计算EPCCL理论所能扩展出的极大项集时,计算过程所需时间与EPCCL理论的规模成正比,因此,使用S3的计算方式是不合适的.对于非互补且不存在蕴含关系的两个子句,在计算它们所能扩展出的极大项集的并集时,可以首先求解min{|V(Ci)-V(Cj)|,|V(Cj)-V(Ci)|},然后再决策使用S1和S2中哪种求解方法来使结果的规模最小.推论2、定理5和定理6给出了任意两个子句所能扩展出极大项集的并集的求解方法,然而,在将任意两个子句所能扩展出的极大项集的并集表示为EPCCL理论之后,需要对EPCCL理论和一个子句进行求并操作,即求解EPCCL理论所能扩展出的极大项集和任意子句所能扩展出的极大项集的并集.定理7.给定EPCCL理论E={C1,…,Ce}和子句C,则J(E)∪J(C)可以表示为E1={C}∪∪(J(Ci)-J(C))或E2=E∪(J(C)-J(C1)-…-J(Ce)).E1和E2为使用推论2、定理5和超扩展规则计算所得结果,则E1和E2均为EPCCL理论.证明.首先J(E)∪J(C)=J(C)∪(J(E)-J(C))=J(E)∪(J(C)-J(E))=(J(E)-J(C))∪(J(C)-J(E))∪(J(E)∩J(C)),其中,最后一项由于计算结果规模较大,因此定理7中不予考虑该种转换形式.(1)J(E)=∪(J(Ci)-J(C)),因此J(E)∪J(C)可以表示为E1={C}∪∪J(C)可以表示为E2=E∪(J(C)-J(C1)-…-J(Ce)).(2)E为EPCCL理论,则J(Ci)∩J(Cj)=(1i,je),进而(J(Ci)-J(C))∩(J(Cj)-J(C))=.又由于对于任意J(Ci)-J(C)使用推论2、定理5和超扩展规则所得结果为EPCCL理论,因此(J(Ci)-J(C))的计算结果为一个EPCCL理∪1ie论,显然C与∪空,因此根据推论3,{C}∪∪一个EPCCL理论.(3)利用数学归纳法可证得J(C)-J(C1)-…-J(Ce)为一个EPCCL理论.首先J(C)-J(C1)的计算结果是一个EPCCL理论,假设1i<e,且J(C)-J(C1)-…-J(Ci)是一个EPCCL理论,则依据(2)可以合理推断出(J(C)-J(C1)-…-J(Ci))-J(Ci+1)是一个EPCCL理论.因此J(C)-J(C1)-…-J(Ce)的计算结果为一个EPCCL理论.由于E是一个EPCCL理论,且J(E)∩(J(C)-J(C1)-…-J(Ce))=,因此E∪(J(C)-J(C1)-…-J(Ce))为一个EPCCL理论.综上,定理7成立.利用定理7中可以求得任意一个EPCCL理论E和一个子句C所能扩展出极大项集的并集,E1和E2是两种语义等价的结果.显然大多数情况下,E1的规模小于E2的规模,只有在E中存在一个子句CiC的时候,|E1|=|E2|+|V(C)-V(Ci)|,因此在扩展过程中,本文选择E1作为扩展策略.推论2、定理5以及定理6给出了任意两个子句所能扩展出极大项集的并集求解方法,定理7则给出了任意EPCCL理论与任意子句所能扩展出极大项集的并集的求解方法.基于上述思想,本文设计了基于超扩展规则的求并知识编译算法UKCHER,该算法描述如算法1.算法1.UKCHER.1.输入:子句集F={C1,…,Cn}2.初始化:令F1=,i=j=13.WHILEi|F|Page7(a)WHILEj|F1|i.IFCi与Cj互补THENskipii.ELSEIFCiCjTHENF1=F1-{Cj}iii.ELSECj={Cj∨(Ci-Cj)}iv.j++(b)F1={Ci}∪F1(c)j=1(d)i++4.RETURNF1根据定理6和定理7,UKCHER算法显然是正确的.算法结束后,F1是一个与F等价的EPCCL理论.KCER算法采用桶删除原理,而UKCHER算法采用增量式求解方式.因此,如果输入的子句集是不可满足的,则UKCHER算法能够尽早地判断出子句集的不可满足性,从而提高了知识编译的效率.例1.给定一个子句集F={C1:x1∨x2∨x3,C2:x2∨x3∨x5,C3:x3∨x4,C4:x1},图1给出了对F进行求并知识编译UKCHER算法的过程,显然F1自始至终都为一个EPCCL理论.由图1可以看出,基于超扩展规则的求并知识编译算法UKCHER是可以并行实现的.例1中,采用分治法的思想能够实现并行求解,因为J(F)=J(C1)∪J(C2)∪J(C3)∪J(C4),则J(F)=(J(C1)∪J(C2))∪(J(C3)∪J(C4)),即:可以分别求出J(C1)∪J(C2)和J(C3)∪J(C4),然后对二者进行合并,合并的过程同样可以利用UKCHER算法实现.5基于超扩展规则的求差知识编译显然,子句□在变量集M(|M|=2m)上所能扩展出的极大项集为M上所有的极大项,令J(H)表示子句集F所不能扩展出的极大项集,则J(H)=J(□)-J(F)且J(F)=J(□)-J(H).显然,如果利用超扩展规则能够求得J(H),且J(H)保存为一个EPCCL理论,那么就能够利用J(H)求得J(F),且所得结果仍然是一个EPCCL理论,就能利用这种求差的方式将任意子句集扩展为等价的EPCCL理论.由定理7可以得出推论4.推论4.给定EPCCL理论E={C1,…,Ce}和子句C,则J(E)-J(C)可以表示为E1=∪J(C)).E1为使用推论2、定理5和超扩展规则计算所得结果,则E1为EPCCL理论.参考定理7的证明过程,推论4显然成立.{□}是一个EPCCL理论,则根据推论2、定理5和超扩展规则以及推论4,能够实现任意子句集所不能扩展出极大项集的求解,并且求解结果以EPCCL理论的形式予以保存.对输入子句集所不能扩展出的极大项集,再次求解其所不能扩展出的极大项集,就能够得到与原公式等价的EPCCL理论.基于这种思想,本文设计了基于超扩展规则的求差知识编译算法DKCHER,该算法执行过程分为两个阶段:(1)求解原子句集所不能扩展出的极大项集;(2)通过原子句集所不能扩展出的极大项集求解与原子句集等价的EPCCL理论.该算法描述如算法2.算法2.DKCHER.1.输入:子句集F={C1,…,Cn}2.初始化:令F1=F2={□},i=j=13.WHILEi|F|&F1≠(a)WHILEj|F1|i.IFCi与Cj互补THENskipii.ELSEIFCiCjTHENF1=F1-{Cj}iii.ELSECj={Cj∨(Ci-Cj)}iv.j++(b)j=1(c)i++4.i=j=15.WHILEi|F1|(a)WHILEj|F2|i.IFCi与Cj互补THENskipii.ELSEIFCiCjTHENF2=F2-{Cj}Page8iii.ELSECj={Cj∨(Ci-Cj)}iv.j++(b)j=1(c)i++6.RETURNF2定理8.DKCHER算法是正确完备的,且输出结果是一个等价的EPCCL理论.证明.根据推论4,DKCHER算法中第3行循环中的(a)循环实现了F1与F中第i个子句Ci所能扩展出极大项集的差集,计算结果为一个EPCCL理论,由于初始F1={□},因此第3行循环之后,F1是F所不能扩展出的极大项集,且F1是一个EPCCL理论.同理第5行循环结束后F2表示了F1所不能扩展出的极大项集,则F2是一个与F等价的EPCCL理论.因此DKCHER算法是正确完备的.证毕.通常SAT问题的难解程度跟其解的个数具有直接关系,解的个数较少会使得搜索过程难以收敛,因此越难解的SAT问题,相应的解越少.将问题编图2基于超扩展规则的求差扩展树译为等价的EPCCL理论之后,编译结果所能扩展出的极大项数与弄假原子句集解的个数是相等的,因此直观上看,对于难解类SAT问题,直接将其编译为等价的EPCCL理论,其结果的规模将是非常庞大的.在编译难解类SAT问题时,DKCHER算法第1阶段所得结果为原子句集所不能扩展出的极大项集,该集合的模与原子句集的模型数是等价的,且该结果为一个EPCCL理论,因此第1阶段所得结果的规模将会是非常小的;第2阶段将求得第1阶段所得结果所不能扩展出的极大项集,并将结果保存为一个EPCCL理论,由于第1阶段所得结果的规模较小,以及互补展开的特性,编译结果中会存在较多短子句,这些短子句甚至短于原子句集中任意子句,因此第2阶段所得结果的规模将远远小于直接编译所得结果的规模.例2.给定一个子句集F={C1:x1∨x2∨x3,C2:x2∨x3∨x5,C3:x3∨x4,C4:x1},图2给出了对F进行求差知识编译DKCHER算法的过Page9程,显然F1和F2自始至终都为EPCCL理论.例2中,利用DKCHER算法对子句集F进行知识编译,首先得到F所不能扩展出的极大项集F1,再求解F1所不能扩展出的极大项集,保存在F2中.例1和例2处理的是相同的实例,在这个实例下DKCHER算法和UKCHER算法所得规模相同.然而实际情况下,它们对于相同实例知识编译所得结果的规模并非完全相同,如例3所示,编译结果可能不同.例3.给定一个子句集F={C1:x1∨x2∨x3,C2:x2∨x3∨x4∨x5,C3:x3∨x4,C4:x1∨x2},则基于UKCHER算法对F知识编译所得结果为F1≡基于DKCHER算法对F知识编译所得结果为显然,|F1|>|F2|.6实验部分本文提出了知识编译算法:UKCHER算法和DKCHER算法.Lin等人[30]于2004年提出的KCER算法和赖永等人[33]于2013年提出的C2E算法均能够将任意子句集编译为等价的EPCCL理论,其中,C2E算法是目前为止效率最高的EPCCL理论编译器.目前已有的知识编译算法较多,如c2d、Dsharpsdd-linux等,然而这些算法的编译结果有别于EPCCL理论,是其他形式的语言,自然在求解特性和查询支持等方面均有所不同.本文首先在随机问题和国际上通用的标准测试样例上对比测试了UKCHER、DKCHER、KCER和C2E这4种知识编译算法的编译效率和编译质量,并遵照相关论文的比较方法利用编译结果中子句数量衡量编译质量.本文实验平台如下:CPU为IntelCore2DuoCPUE8400@3.00GHz2.99GHz;内存为4GB;操作系统为ubuntukylin-14.04.1-desktop-amd64.6.1对于随机子句长度的子句集的测试我们用随机产生器生成了子句长度不固定的测试样例,随机产生器的结果为包含3个参数〈m,n,k〉的子句集,其中:m为变量个数,n为子句个数,k为每个子句的最大长度.本文提出的知识编译算法和现有的EPCCL理论编译算法均不支持大规模的实例,表1~表3中分别给出了〈20,n,10〉、〈25,n,10〉和〈30,n,10〉这3种变量数固定、子句数不同的随机测试样例的编译结果,实验结果为50次实验的平均值,size表示子句个数,time表示运行时间(单位为s).下表类似,恕不赘述.实验结果表明:当变量数固定时,DKCHER算法随着子句数的增加而减少;当初始子句集规模较小时,UKCHER算法、C2E算法和KCER算法随着子句数的增加而增加;当子句集规模大于某一临界值时,它们的编译规模会维持不变,甚至减少;由于样例随机生成,因此可能会存在轻微的波动.从规模上看,表1中,当子句数小于90时,C2E算法的编译规模会随着子句数的增加而增加,而当子句数大于等于90时,C2E算法的编译规模会稳定在2100左右,同样的现象出现在KCER算法中,不过整体来看KCER算法的编译规模大于C2E算法的编译规模.表1中,在子句数小于50时,DKCHER算法的编译规模大于C2E算法的编译规模,然而随着子句数的增加,当子句数大于等于50时,DKCHER算法的编译规模远远小于C2E和KCER的编译规模,甚至当子句数为100时,C2E算法编译规模是DKCHER算法编译规模的128倍,KCER算法编译规模是DKCHER算法编译规模的254倍,由此可知求差知识编译算法DKCHER对于变量数固定子句数规模较大的子句集能够取得很好的编译效果.UKCHER算法的编译规模始终大于C2E算法的编译规模,而与KCER算法的编译规模接近,略小于后者.从表2和表3可以得到和表1相同的结论.从编译效率来看,表1中,当子句数小于等于50时,UKCHER算法的效率是最高的,KCER算法次之,C2E算法居于第3位,DKCHER算法的效率最差,主要原因在于:DKCHER算法分为两个阶段执行,当子句数较小时,第1阶段所得EPCCL理论规模过大,导致了第2阶段的编译效率较低,影响了整体执行效率.当子句数大于50时,DKCHER算法Page10的编译效率最高,同时随着子句数增加UKCHER算法和KCER算法所需编译时间也随之大幅度增长,二者的编译效率均低于C2E算法.表2和表3中,由于变量数增加,UKCHER算法和KCER算法的编译效率始终低于C2E算法,同时表3中,DKCHER算法的编译效率始终低于C2E算法的表1随机实例〈20,狀,10〉的实验结果实例〈20,30,10〉〈20,40,10〉〈20,50,10〉〈20,60,10〉〈20,70,10〉〈20,80,10〉〈20,90,10〉〈20,100,10〉实例〈25,40,10〉〈25,50,10〉〈25,60,10〉〈25,70,10〉〈25,80,10〉〈25,90,10〉〈25,100,10〉〈25,110,10〉实例〈30,50,10〉〈30,60,10〉〈30,70,10〉〈30,80,10〉〈30,90,10〉〈30,100,10〉〈30,110,10〉〈30,120,10〉time/s0.0190.0350.0500.0660.0800.0910.1010.103表2随机实例〈25,狀,10〉的实验结果time/s0.1370.3000.4120.4470.6010.8130.7800.818表3随机实例〈30,狀,10〉的实验结果time/s1.3762.1592.8433.2383.3643.5752.9883.749表4~表6中分别给出了〈m,40,10〉、〈m,60,10〉和〈m,80,10〉这3种变量数固定、子句数不同的测试样例的编译结果,实验结果为50次实验的平均值.实验结果表明:当子句数固定,变量数改变时,4种知识编译算法的编译规模均随着变量数的增加而增加,同时编译过程所需时间也随着变量数的增加而增加;当子句数固定时,变量数较小时,DKCHER算法的编译效率和编译质量是最高的,进一步验证了表1~表3所得的结论;变量数较大时,C2E算法编译效率.总体来看,对于随机长度的SAT问题,DKCHER算法适用于变量数较小,子句数较大的子句集;UKCHER算法和KCER算法不适用于变量数较多的子句集,而C2E算法在变量数较多的情况下,能够最大地发挥其优势.的效率能够达到最高,编译质量在小部分情况下能够达到最优(如表4中的〈28,40,10〉实例).因此在对随机子句长度的子句集进行知识编译时,应该根据其子句数与变量数的比值来决定使用哪种知识编译算法.虽然UKCHER算法的编译质量和编译规模往往不占优势,然而它却是4种知识编译算法中唯一一个可以并行实现的知识编译算法,若子句集规模过于庞大,需要并行处理,UKCHER算法将会是首选.Page11实例〈14,40,10〉〈16,40,10〉〈18,40,10〉〈20,40,10〉〈22,40,10〉〈24,40,10〉〈26,40,10〉〈28,40,10〉实例〈14,60,10〉〈16,60,10〉〈18,60,10〉〈20,60,10〉〈22,60,10〉〈24,60,10〉〈26,60,10〉〈28,60,10〉实例〈14,80,10〉〈16,80,10〉〈18,80,10〉〈20,80,10〉〈22,80,10〉〈24,80,10〉〈26,80,10〉〈28,80,10〉表4随机实例〈犿,40,10〉的实验结果time/s0.0110.0140.0230.0370.0620.1180.1950.358表5随机实例〈犿,60,10〉的实验结果time/s0.0150.0170.0340.0640.1150.2620.5431.199表6随机实例〈犿,80,10〉的实验结果time/s0.0120.0170.0400.0900.2160.4040.7191.8946.2对于标准3-SAT子句集的测试为了更全面地展示本文提出的知识编译算法的特性,本文还随机生成了变量数固定,子句数改变的标准3-SAT子句集,表7~表9分别给出了〈20,n〉、〈25,n〉和〈30,n〉这3种不同3-SAT子句集实例的样例进行测试,测试结果为50次实验的平均值.实验结果表明:当变量数固定时,随着子句数的增加,DKCHER算法编译所得规模逐渐减小;对于3-SAT问题,DKCHER算法的编译质量明显高于其他3种算法,其编译效率在子句数较小时,低于C2E算法,随着子句数的增加,DKCHER算法的编译效率将优于C2E算法的编译效率.表7中,子句集规模较小时,UKCHER算法和KCER算法的编译质量相同,但是前者的编译效率明显高于后者,随着子句数的增加,UKCHER算法的编译质量渐渐优于KCER算法的编译质量.上述现象产生的原因在于:虽然UKCHER算法的执行过程与KCER算法不同,然而二者基本原理相同,不同之处在于UKCHER算法对于不可满足的子句集的编译过程能够较早判断出不可满足,因此对于任意可满足子句集,二者编译结果相同,随着子句数的增加,会有更多的不可满足性子句集,因此UKCHER算法的编译质量整体会渐渐优于KCER算法的编译质量.表8进一步验证了表7所得到的结论.表9中由于变量数过大,UKCHER算法和KCER算法会经常内存溢出,因此对于表9中的很多实例,UKCHER和KCER是无法解决的,显然二者不适用于变量数较多的3-SAT问题.表7~表9给出了变量数固定,子句集变化的3-SAT实例,从中可以部分看出DKCHER算法对相变区间内难解问题的知识编译具有较高的质量,为了进一步验证DKCHER算法在处理相变区间内难解问题的优秀特性,本文按照子句数/变量数≈4.3的比例生成了若干实例.Page12表7随机3-SAT实例〈20,狀〉的实验结果time/s0.1050.1530.2050.2510.2640.3370.3370.343表8随机3-SAT实例〈25,狀〉的实验结果time/s0.8591.1821.5381.9332.3942.7152.5712.804表9随机3-SAT实例〈30,狀〉的实验结果time/s6.1606.114实例〈20,46〉〈20,56〉〈20,66〉〈20,76〉〈20,86〉〈20,96〉〈20,106〉〈20,116〉实例〈25,57〉〈25,67〉〈25,77〉〈25,87〉〈25,97〉〈25,107〉〈25,117〉〈25,127〉实例〈30,69〉〈30,79〉〈30,89〉〈30,99〉〈30,109〉〈30,119〉〈30,129〉〈30,139〉由于相变现象对于较大规模的子句集比较明显,而UKCHER算法和KCER算法在处理大规模子句集时容易内存溢出,同时C2E是目前为止效率和质量最高的EPCCL理论编译器,因此这一部分实验,我们仅比较了DKCHER算法和C2E算法.为了说明知识编译质量对在线推理时间的影响,本文还比较了基于二者的编译结果实现在线推理(可满足性判定)的效率,实验结果为50次实验的平均值,如表10所示.实验结果表明:C2E算法的编译结果规模和编译所需时间均随着变量数的增加而增加.DKCHER算法的编译质量明显高于C2E算法.例如当变量数达到35时,C2E的编译结果规模是DKCHER算法编译结果规模的3530倍,直接导致了基于DKCHER算法的在线推理时间远远小于基于C2E算法的在线推理时间.变量数不大于32时,DKCHER算法编译效率与C2E算法的编译效率接近,但是明显次于后者.然而当变量数大于32时,DKCHER算编——————实例〈26,111〉1570.273<0.001286540.3590.002〈27,116〉1410.408<0.001434250.4830.004〈28,120〉1110.716<0.001548930.5800.005〈29,124〉2020.994<0.001893400.9370.007〈30,128〉971.306<0.0011196531.2560.010〈31,133〉2202.076<0.0011476851.7700.015〈32,137〉2052.905<0.0012216602.5760.023〈33,141〉1323.929<0.0013427245.1790.033〈34,146〉1625.178<0.0014477508.4250.043〈35,150〉1707.213<0.00160014522.0760.067uf20-01780.022<0.001uf20-021000.016<0.001uf20-03200.013<0.001blockworld-anomalypigeon-hole-6par8-1-c640.034<0.001Page13译所需时间的增长率明显小于C2E算法编译所需时间的增长率,因此随着变量数的增加,DKCHER算法的编译效率远远优于C2E算法的编译效率.就在线推理的效率而言,由于DKCHER算法的编译质量非常高,因此基于DKCHER算法的在线推理所需时间始终小于0.001s,而由于C2E算法的编译质量不高,因此基于C2E算法的在线推理所需时间取决于C2E编译结果的规模,其时间随着变量数的增加而增加.由此可以合理的推断出,对于相变点附近的难解SAT问题,使用DKCHER算法进行知识编译,在线推理的效率是最高的.C2E算法编译所需时间之所以会随着变量数的增加而大幅度增加,原因在于:它自身第2阶段的REDUCE操作用于归约第1阶段所得到的EPCCL理论,而REDUCE操作的执行效率非常低,直接导致了当编译结果的规模逐渐增加时,C2E算法整体的编译效率近似指数级下降.表10中,同样对国际上通用benchmarks进行了测试,由于这些benchmarks大多数在相变点附近,因此可以看到不管是从编译效率还是编译质量,DKCHER算法均明显优于C2E算法,因此对于难解类SAT问题的知识编译应该选择DKCHER算法.6.3与其他目标语言编译器的比较不同的目标编译语言所能支持的查询种类是不同的.例如,EPCCL理论能够支持全部8种查询操作[33],而d-DNNF仅能支持6种[18].所以比较具有不同查询功能的不同类型编译器,编译质量和编译效率仅能够反映目标编译语言的适用范围.c2d(最新版本更新于2005年①)是国际上比较通用的d-DNNF编译器,文献[36]通过实验验证了c2d的编译效率和编译质量均是最优的.Dsharp是改进的d-DNNF编译器,然而,该算法并不能正确的执行[22,37],因此本文将c2d作为对比算法之一.SDD是一种新的知识编译语言[38],其对应的编译器sdd-linux(最新版本更新于2014年②)是现今有代表性的高效编译器,因此本文同样sdd-linux将作为对比算法之一.本文随机生成了一些30个变量的〈n,k〉实例,n表示子句数,k表示每个子句的长度,通过控制k来生成不同互补因子率的实例(k越大,互补因子率越高).由于DKCHER算法更适用于相变区间点附近的子句集编译,具有较好的效果,因此本小节仅列举了UKCHER、c2d和sdd-linux算法的比较结果,时间上限设定为100s.实验结果如表11所示,表中数据为50次实验的平均值.实例〈50,5〉7827795.8711739320.39120827143.047〈50,7〉1926381.097720450.23010122712.268〈50,10〉76150.038319390.109219451.840〈70,7〉6414844.6163056550.442〈70,10〉226310.135917280.1627036817.813〈70,13〉11650.011323430.072162861.762表11中,随着互补因子率的提高,3种算法的编译效率和编译质量均有所提高.然而,对于子句数50的实例,当k为5或7时,c2d算法的编译质量和编译效率均优于UKCHER,sdd-linux的编译质量优于UKCHER;当k为10时,UKCHER算法的编译效率和编译质量均优于c2d算法和sdd-linux算法.sdd-linux的编译效率始终是最差的.对于子句数为70的实例,具有同样的现象:当子句长度为7时,sdd-linux超时.产生这一现象的原因在于:EPCCL理论建立在互补结构和扩展规则的基础上,因此当输入子句集互补因子率较高时,UKCHER算法具有较高的编译质量和编译效率,如〈50,10〉和〈70,13〉实例;而c2d和sdd-linux建立在归结方法的基础上,因此当互补因子率较高时,其编译效率和编译质量会弱于UKCHER算法.由于UKCHER算法等同于一种扩展反驳方法,因此本实验更进一步验证了:基于扩展规则的推理方法或知识编译方法对于互补因子率较高的问题具有较好的适用性.7结语本文提出了扩展反驳,是一种新的定理证明方法,并将其与知识编译建立了联系.超扩展规则是一种新的推理规则,为了使EPCCL理论具有更广的应用范围,本文提出了两种知识编译算法:求并知识编译算法UKCHER和求差知识编译算法DKCHER,是两种新的知识编译算法,通过分析算法UKCHER的执行过程,证明了该算法是可以并行化的,是目前为止唯一一个能够并行知识编译的EPCCL理论编①②Page14译算法.实验结果表明:算法DKCHER对于相变点附近的难解问题具有非常优秀的编译效率和编译质量,且对于子句数和变量数的比值较大的子句集同样能够取得最优的编译效率和编译质量,而UKCHER算法对于互补因子率较高的子句集的编译质量和编译效率是较优的.UKCHER算法和DKCHER算法可用于并行知识编译和难解类SAT问题知识编译,为高效推理提供了可能.未来,我们将进一步研究SAT问题的潜在结构,并利用超扩展规则的性质对特殊问题结构的SAT问题进行快速知识编译,并通过加入启发式策略进一步提高UKCHER算法和DKCHER算法的编译效率.
