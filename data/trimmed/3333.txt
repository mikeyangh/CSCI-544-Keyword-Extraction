Page1基于AIPlanning的ParlayX电信业务设计蒋志华1)饶东宁2)姜云飞3)江洪4)1)(暨南大学计算机科学系广州510632)2)(广东工业大学计算机学院广州510090)3)(中山大学信息科技学院软件研究所广州510275)4)(中国电信股份有限公司广东研究院家庭客户部广州510630)摘要ParlayX是一组电信网络服务(WS)应用程序接口(APIs),智能规划可作为一种WS组合(WSC)方法,所以理论上可基于智能规划设计使用ParlayXAPIs的电信业务.但WSC有容错和对动作变化推理的要求,电信业务有多种触发方式和异步响应等特性,智能规划要有确定状态等ParlayX不满足的条件.结合典型ParlayX电信业务模型,基于AIPlanning的ParlayX电信业务设计(APBPTSD)方法被提出.APBPTSD用标准后处理动作(SPCA)处理容错,用等待事件动作(WFEA)处理异步响应,用本地动作(LA)处理动作变化推理并对多种触发进行业务分拆.在已有业务上实验表明APBPTSD可有效指导ParlayX电信业务设计.关键词人工智能;智能规划;网络服务组合;ParlayX1引言ParlayX[1]是一组电信WSAPIs.为实现第三方业务开发,下一代网络(NGN)业务是开放式的架构[2].开放式的架构需要开放式业务平台API支持,Parlay[3]是这些开放式业务平台API中最有影响力的一组.出于目前只有20%的ParlayAPIs常用,并且希望能减轻开发者对电信知识了解的目的,Parlay组织试图简化ParlayAPI.于是,Parlay组织对ParlayAPI进行组合和WS[4]封装以提高可用性和易用性,就得到了ParlayX.作为一种WSC[5]方法,理论上智能规划[6]可用于设计使用ParlayX的电信业务.WSC通过协调组织多个WS来提供对新任务的支持,智能规划是其中一种理论方法.鉴于ParlayX是基于WS形式封装的,理论上可以对它们像一般的网络服务一样进行组合,其结果是电信NGN业务或者电信NGN业务中的一部分.下面的例子展示了电信业务及其理论上用智能规划进行设计的过程.例1.餐饮查询业务.用户向SP(ServicePro-viders)发送短信要求查询附近的餐饮服务介绍.整个流程可以描述为(1)应用服务器(AS)首先调用ParlayX网关(2)然后AS等待ParlayX网关的响应以获知(3)最后AS调用ParlayX网关的sendSMSWS.理论上如果有getLocationWS和sendSMSWS的符合规划定义语言(PDDL)[7]要求的动作模型描述等文件,就可以通过调用规划器(比如FFPS规划器[8])得到规划解,它对应一个(子)业务设计.利用智能规划进行业务设计可以指导业务开发,但实际应用中有很多问题.在开放式的电信业务环境下,业务开发指导就更重要,它可以减轻对开发者深入了解电信知识的要求,也可以帮助运营商规范业务提供者(SP)开发的第三方程序.这里前者正是Parlay组织封装ParlayX的目的之一,而后者在实践中非常重要.实际应用中问题主要包括3个方面:WSC有容错和对动作变化推理的要求,电信业务有多种触发方式和异步响应特性,智能规划要有确定状态等ParlayX不满足的条件.WSC需要容错[6]和对变化进行推理[9],这都是经典规划(基于PDDL[7])无法处理的.由于网络固的getLocationWS;对方位置;有特性,WS需要容错[10],所以WSC也需要容错[6].但经典规划中要求动作的效果是确定性的,体现在PDDL中动作执行的结果就只有一种.另一方面,WSC中往往需要对调用WS的返回结果进行推理以获取对当前状态的知识.比如例1中如果在第2步中对方位置为地理信息,此时需要从对方地理信息推理出消息内容.仅仅使用WS的动作模型无法体现这样的推理(查询并替换)过程.电信业务有多种触发方式和异步响应等特性,这都是一般WSC问题没有的.一般WSC问题[5]是由一个唯一的场景触发,但是电信业务往往触发方式不唯一.比如对例1的触发,有可能是手机用户发送消息要求查询,也有可能是用户通过因特网发起查询但是要求消息发送到手机.这样对于同一个餐饮查询业务,其初始状态和涉及到的参数都不一样.另一方面,电信业务具有异步响应特性.一般地,当AS调用一个ParlayXWS时它总可以马上得到一个响应,但是这个响应仅仅说明ParlayX网关在处理AS的某个请求.真正的调用结果,比如例1中短消息最终发送成功与否,往往是通过由ParlayX网关发给AS的状态通知体现的.上述两点都使得WSC技术难以直接应用于ParlayXWS组合.智能规划要有确定状态,这是ParlayX不满足的.由于经典规划基于状态集,所以要求状态集是确定的.但是调用一个ParlayXWS可能产生新的状态,或者整个系统处在一个不确定的状态.比如调用sendSms服务之后,AS得到ParlayX网关的状态通知之前,AS就不能确定当前状态.鉴于减轻开发者负担,规范业务开发的重要性,本文提出业务设计方法APBPTSD.APBPTSD对ParlayXWS建模为规划动作模型,然后形成领域描述和动作描述,最后使用规划器求解.作为对前面提出的三方面问题的解决方案,APBPTSD:针对WSC需要容错的要求,用SPCA(standardpost-callactions)建模标准例外处理;针对WSC对变化进行推理等要求,用LA(localactions)建模本地动作;针对电信业务的多种触发方式,分拆业务;针对电信业务的异步响应和智能规划确定状态集的要求,加入WFEA(wait-for-eventactions).APBPTSD是电信运营和智能规划研究的桥梁.其在电信运营上的意义为:从开发者的角度APBPTSD能够减轻负担,从运营商的角度APB-PTSD能够规范业务开发.在例1中对于软件开发者来说,Presence在ParlayX规范中是一整个部分Page3(Part14),难以理解.有了APBPTSD的指导,开发者不需要了解概念,调用相应WS就行.从运营商的角度,SP有意无意的错误会带来用户投诉影响品牌价值.APBPTSD能够避免SP无意错误,并能在事故出现后通过比对指出SP的错误.其在智能规划研究中的意义为:为规划应用找到突破口,应用中的问题可以指导规划研究方向.目前智能规划的应用还很少,作为一个结合点APBPTSD可以推动这种应用,体现智能规划领域的研究价值.进而,在应用中暴露出来的问题可以反过来指导智能规划研究方向,以使智能规划更易应用,形成良性循环.本文第2节介绍本文研究背景;第3节介绍本文用到的术语;第4节给出APBPTSD整体方案和具体建模过程;第5节介绍分支和循环的处理;第6节是实验和分析;最后是结语及对未来工作的展望.附录中给出文中涉及到的ParlayXWS动作描述.2研究背景本节从基于ParlayX的电信业务开发、智能规划及其在WSC中的应用等方面,来介绍本文的研究背景.2.1基于ParlayX的电信业务开发ParlayX[1]是NGN上WS[4]封装的API.下一代网络(NGN)是多种新的网络通信技术的总和,包括新一代的传送网、新一代的交换网、新一代的互联网、新一代的业务网等等.NGN的网络构架决定其网络环境更开放[2],新的增值业务种类丰富提供方式灵活,更依赖业务提供商(SP)提供.为了让SP能够进行业务开发,需要使用第三方业务开发技术.NGN中一般使用API,特别是3GPP和Parlay组织提出的Parlay[3].但是Parlay仍然庞杂,目前只有20%的ParlayAPIs常用[11].因此Parlay组织为了降低开发难度在Parlay基础上推出ParlayX,并使用WS进行封装,具体来说就是使用WSDL(WebServicesDescriptionLanguage)[4]描述服务.ParlayX位于现有网络之上,ParlayX网关可以直接与业务能力连接,也可以通过Parlay网关与业务能力连接.现有网络的业务能力可以通过ParlayX网关与应用服务器进行交互,其中ParlayX网关到网元之间采用现有网络协议,这样就可以直接提供第三方业务或综合业务.也可以让ParlayX网关与Parlay网关相连,它们之间的接口为ParlayAPI,这样可以调用Parlay网关实现服务.这里的ParlayX应用可以由SP提供,也可以由运营商提供,它们所在的服务器称为应用服务器(AS).ParlayX规范中提供的主要能力包括第三方呼叫(thirdpartycall)、呼叫通知(callnotification)、短消息(shortmessaging)、多媒体消息(multimediamessaging)、支付(payment)、帐户管理(accountmanagement)、终端状态(terminalstatus)、终端位置(terminallocation)、呼叫控制(callhandling)、音频呼叫(audiocall)、多媒体会议(multimediacon-ference)、地址列表管理(addresslistmanagement)、呈现(presence)、消息广播(messagebroadcast)、地理编码(geocoding)、应用驱动Qos(application-drivenqualityofservice)、设备能力设置(deviceca-pabilitiesandconfiguration)、多媒体流控制(multi-mediastreamingcontrol)、多媒体多播管理(multi-mediamulticastsessionmanagement).但实际使用中电信厂商往往有增减.这是首先因为目前只有呈现、短消息、多媒体短消息、第三方呼叫、呼叫通知等WS常用.ParlayX规范中的其它能力以及陆续补充的等都很少被使用.其次实际操作中为减轻网关压力不能让SP应用程序频繁查询状态,所以要让网关在得知用户状态改变的时候通知SP应用程序.国内应用最广泛的华为平台采用了callbackWS的方式,其它厂商也采用了类似技术.的调用参数,我们给出例1的业务流程.考虑到上述因素以及实际开发中需要设置WS例2.例1业务流程用UML序列图.其描述见图1.目前涉及ParlayX的研究主要包括两个方面:能力扩展和业务开发.由于早期ParlayX标准有很多能力未涵盖,国内外研究人员希望扩展ParlayX能力[12-14]以满足更多业务的需求.另一部分工作讨论了ParlayX的业务开发,比如彩铃[11]、消息智能转发业务[15]、餐饮服务[16]、多方多媒体会议[17].据Page4我们所知,目前还没有关于使用自动化方法指导开发的研究.2.2智能规划及其在WSC中的应用智能规划是人工智能的一个分支.规划就是根据要实现的目标选择适当动作制定出能够实现目标的行动策略.规划中研究带有不确定的动作效果的子分支就是NDP[18].在不确定规划的发展过程当中还出现了很多类似的方法,比如容错规划[6]为了进行规划,在规划问题中状态一定要映射到命题集上,动作一定要用规划领域描述语言(PDDL)描述,推理一定要使用派生规则形式[19].规划的研究成果得到AI领域的认可,在1995、2003、2008年AI杂志都出了智能规划专刊,规划社区还组织了专门的国际规划与调度会议(ICAPS)和国际规划比赛(IPC).WSC是通过协调和组织多个WS来提供对新任务的支持.WSC产生于不能只用一个现有的WS来完成、但是可以通过多个现有WS的组合来完成的实际任务.比如已有帐号申请、购物车管理、网络支付等基本的WS,而希望完成一个网络购物流程.目前对于WSC问题业界和学术界有各自的解决办法:业界为工程师手动编写WSC解决方案提出了Web服务业务流程语言(WSBPEL)[20];而学术界则用智能规划[6]、基于任务依赖信息的技术[21]等方法来实现对自动WSC的指导.基于规划的WSC[6,22-23]一直倍受关注.这种方法将WS视为动作[22],对WS的描述就是一个用PDDL编写的动作模型.它的优点是得到了WS的动作模型描述后可以自动化地产生WSC解决方案,同时这些动作模型是基于领域而不是基于问题的,即可以一次编写多次使用.这一思想被不断地发展并被应用在语义Web上[23].考虑到WSC需要容错[6],近年来国内外[6,24]学者都开始将不确定规划器用于WSC.由于使用智能规划进行WSC需要WS的动作模型,近年来我们也做了一些在WS动作模型学习[25-26]方面的努力.如果有足够多的WSBPEL描述的基于ParlayX业务,前期工作[26]可以自动获取ParlayXWS的动作模型.但即便能够处理容错[6,24],至今仍然没有将规划或者WSC用于ParlayXWS上的研究.这是因为首先规划仍然不能处理对变化的推理[10];其次,目前的WSC技术(包括使用智能规划的WSC)并未考虑电信业务有多种触发方式和异步响应等特性;另外,智能规划需要确定的状态集,这一要求在电信业务具有异步响应特性的情况下显得过于苛刻.3术语定义要用到智能规划的形式化定义[6-8,18-19,22-26].是一个四元组Σ=〈L,S,A,X〉,其中,本文将电信ParlayXWS建模为智能规划,需定义1(经典规划领域).一个经典规划领域L是有限的谓词符号集;S是状态集合,S2L;A是动作集合,A={a|a=〈pre(a),add(a),del(a)〉}.pre(a)是动作a的前提集合,add(a)是动作a的增加效果集合,del(a)是动作a的删除效果集合;X是转换函数,X(s,a)=(s-del(a))∪定义2(不确定规划领域).一个不确定规划L是有限的谓词符号集;S2L是状态集合;A={a|a=〈pre(a),add(a),del(a)〉}是动作集合,其中pre(a)是前提集合,add(a)和del(a)分别是增加效果和删除效果集合;add(a),当a在s中是可应用的.领域是一个四元组Σ=〈L,S,A,X〉,其中,X:S×A→2S是状态转换函数.可见动作模型包括前提集合、增加效果集和删除效果集.不确定规划领域就是X非单射的情况.定义3(可应用动作).动作a在状态s中是可应用的(applicable),当且仅当pre(a)s.定义4(合法状态转换).一个状态转换〈s,a,s〉是合法的,当且仅当s∈S,s∈S,a∈A,且a在s是可应用的.定义5(静态系统假定).规划系统的状态变化由且仅由动作的执行而改变,不存在影响系统状态的外部事件.这称为静态系统假定.一个规划系统中的状态转换必须是合法的,另一方面目前的规划系统大多满足静态系统假定.定义6(经典规划问题).一个经典规划问题是一个三元组Π=〈Σ,I,G〉,其中,Σ=〈L,S,A,X〉是经典规划领域描述;I是初始状态;G是目标状态.不确定规划问题就是领域描述为不确定规划的规划问题.定义7(不确定规划问题).一个不确定规划Page5问题是一个三元组Π=〈Σ,I,G〉,其中,Σ=〈L,S,A,X〉是不确定规划领域描述;I是初始状态集合;G是目标状态.定义8(经典规划解).规划问题Π=〈Σ,I,G〉的解是一个动作序列〈a1,a2,…,an〉,该动作序列通过一系列的状态变换〈s0,s1,s2,…,sn〉将初始状态I转化为目标状态G:s0=I;pre(ai)si-1,si=X(si-1,ai),1in;snG.定义9(不确定规划解).不确定规划问题的规划解是策略π,π是由状态-动作序对构成的集合:π={〈s,a〉|s∈S,a∈A,a在s中是可应用的}.通过策略π,可以使得规划问题从初始状态转换到目标状态.不确定规划问题的规划解是由状态-动作序对构成的策略,通过它可以使得规划问题从初始状态转换到目标状态.这些策略可分为弱规划解、强规划解和强循环解,它们分别是目标在最乐观情况下可达、目标在任意情况下可达和目标最终可达.定义10(执行结构).设π是规划领域Σ=〈P,S,A,T〉里的一个策略.那么从初始状态集IS所导出的π的执行结构为K=〈Q,T〉,其中QS和TS×S是满足以下条件的最小集合:(1)若s∈I,那么s∈Q,并且(2)若s∈Q且存在某〈s,a〉∈π且s∈R(s,a),那么s∈Q且〈s,s〉∈T.(3)状态s∈Q是K的一个终止状态当且仅当不存在s∈Q使得〈s,s〉∈T.执行结构K就是一个有向图,其中的节点集Q是系统在(以I为初始状态集)执行规划π时所可能到达的所有状态的集合,而T则表示了相应的所有可能的状态转换.K的各个终止状态代表规划执行的终止,一般用TERMINALSTATESOF(K)来表示执行结构K的终止状态集.定义11(弱规划解、强循环规划解、强规划解).设Σ=〈L,S,A,X〉是不确定规划领域,Π=〈Σ,I,G〉是Σ的一个规划问题,而π是Σ的一个策略.令K=〈Q,T〉是π从I所导出的执行结构.(1)π是Π的一个弱解当且仅当:(s∈I)(s∈G∩TERMINALSTATESOF(K))s是s可达的;(2)π是Π的一个强循环解当且仅当:(s∈Q)(s∈TERMINALSTATESOF(K))s是s可达的,并且TERMINALSTATESOF(K)G;(3)π是Π的一个强解当且仅当:K是无环的,并且TERMINALSTATESOF(K)G.容错规划就是动作效果包括一个主要可能效果和一个次要可能效果组成的求强规划解或强循环规划解的NDP问题.容错规划还不能算规划社区的通用术语,这里不做定义.4APBPTSD建模APBPTSD方法对ParlayXWS建模为规划动作模型,然后形成领域描述和问题描述,最后使用规划器求解.其中的关键技术就是建模,本节将对建模中的关键技术进行阐述.4.1容错本节将ParlayXWS的动作效果为一个标准动作模型和一个SPCA动作模型,这实际上处理了容错.WS使用WSDL描述[4],WSDL是一种基于XML的语法将WS描述为能够进行消息交换的服务访问点的集合的语言.WSDL中用Types定义数据类型,用Message定义通信消息的数据结构,用Operation定义操作,用Binding定义端口的具体协议和数据格式的绑定,用Port定义访问点.其中Operation包括input,output以及多个fault部分,这里fault就是WSDL层面容错的语法形式.在实际应用中WSDL结合SOAP(SimpleObjectAccessProtocol)[27]才是真正被HTTP封装的协议包.尽管SOAP会进一步对WSDL进行封装并可以增加容错处理,但ParlayX标准并未包括SOAP部分的处理.以前的工作认为WS的输出就是动作效果[6,22-23],但未考虑fault部分处理.下面是ParlayX的WS定义以及业务例外处理.例3.ParlayX[1]标准中的sendSms操作的WSDL[4]定义.定义如下:〈wsdl:operationname="sendSms"〉〈wsdl:inputmessage="parlayx_sms_send:SendSms_sendSmsRe-〈wsdl:outputmessage="parlayx_sms_send:SendSms_sendSmsRe-〈wsdl:faultname="ServiceException"message="parlayx_common_faults:ServiceException"/〉Page6〈/wsdl:operation〉.〈wsdl:faultname="PolicyException"message="parlayx_common_faults:PolicyException"/〉在业务中需要做如下处理:try{sendSmsparam=newsendSms();….}catch(PolicyExceptione){……}catch(ServiceExceptione){……}catch(Exceptione){……}.从例3可见:错误和例外优先级高于输出,需要先处理;错误处理完后WS的调用结果是output.与经典规划的动作效果的主要区别是ParlayXWS具有正常输出和错误两种;与NDP[18]的弱规划解区别在于ParlayXWS中错误需要先被处理,并且程序中不适合枚举状态动作对(策略);与容错规划[6]的区别在于首先ParlayXWS可能有多种错误和例外而容错规划一般只支持一种错误;其次电信业务是NDP角度的弱规划解而容错规划是强规划解或者强循环规划解.这里对每个ParlayXWS提出一个postWS动作,用于处理容错.这样体现了错误的高优先级也能够保证流程的顺序处理,建模了具有优先级的弱规划解也解决了状态列举不符合开发者逻辑的困难,还能够采用最通用的规划方式进行求解.因此可以称为标准后处理动作(SPCA).例4.ParlayX[1]标准中sendSms的postWS操作PDDL定义.定义如下:(:types……exception-object……)//e.g.sendSms-exception(:predicates(exception?x-exception)……)(:actionsendSms:parameters(……?x-exception?wsName-exception):precondition(and(……forall?x(not(exception?x)))):effect(and((exception?wsName)……)))(:actionpostWS:parameters(?x-exception):precondition(and(exception?x)):effect(and(not(exception?x)))).参数设置、查询处理等本地动作需要体现在业整个过程是:首先增加一个exception类型和string类型,exception表示各种要处理的例外和错误;然后增加一个例外是否需要处理的谓词excep-tion,其参数是需要处理例外的WS;在执行过程中sendSms操作中传入wsName参数以说明可能出现例外的WS(正常情况下就是sendSms);最后postWS根据某个WS需要被处理的前提来处理例外并重置相应命题.这里任意一个WS被调用的前提是所有例外已经被处理,使用了全称量词.4.2本地动作建模务流程中,就需要建模为本地动作(LA).4.2.1参数设置动作可以统一使用一个本地动作set来处理参数设置.在每个动作的前提参数中要求上述变量被设置,在动作的效果中将相关变量改为未设置即可.同时,ParlayXWS复杂的参数需要扁平化处理.ParlayXWS的参数结构往往在语义上是树形结构具有层级关系,这样的层级关系不利于开发人员检查相关变量的设置情况.因此,需要将复杂参数扁平化,即在WS动作模型中枚举最底层所有相关变量.例5.ParlayX[1]标准中sendSms的中send-SmsRequest和sendSmsResponse参数的定义.定义如下:〈wsdl:messagename="SendSms_sendSmsRequest"〉〈wsdl:partname="parameters"element="parlayx_sms_send_local_xsd:sendSms"/〉〈/wsdl:message〉〈wsdl:messagename="SendSms_sendSmsResponse"〉〈wsdl:partname="result"element="parlayx_sms_send_local_xsd:sendSmsRe-〈/wsdl:message〉.进一步地,它们又被定义为〈xsd:elementname="sendSms"type="parlayx_sms_send_local_xsd:sendSms"/〉〈xsd:complexTypename="sendSms"〉〈xsd:sequence〉〈xsd:elementname="addresses"type="xsd:anyURI"minOccurs="1"maxOccurs="unbounded"/〉〈xsd:elementname="senderName"type="xsd:string"minOccurs="0"maxOccurs="1"/〉〈xsd:elementname="charging"type="parlayx_common_xsd:ChargingInformation"minOccurs="0"maxOccurs="1"/〉〈xsd:elementname="message"type="xsd:string"/〉〈xsd:elementname="receiptRequest"type="parlayx_common_xsd:SimpleReference"Page7minOccurs="0"maxOccurs="1"/〉〈/xsd:sequence〉〈/xsd:complexType〉〈xsd:elementname="sendSmsResponse"type="parlayx_sms_send_local_xsd:sendSmsResponse"/〉〈xsd:complexTypename="sendSmsResponse"〉〈xsd:sequence〉〈xsd:elementname="result"type="xsd:string"/〉〈/xsd:sequence〉〈/xsd:complexType〉.其中的charging和receiptRequest又进一步定义为〈xsd:complexTypename="ChargingInformation"〉〈xsd:sequence〉〈xsd:elementname="description"type="xsd:string"/〉〈xsd:elementname="currency"type="xsd:string"minOccurs="0"maxOccurs="1"/〉〈xsd:elementname="amount"type="xsd:decimal"minOccurs="0"maxOccurs="1"/〉〈xsd:elementname="code"type="xsd:string"minOccurs="0"maxOccurs="1"/〉〈/xsd:sequence〉〈/xsd:complexType〉〈xsd:complexTypename="SimpleReference"〉〈xsd:sequence〉〈xsd:elementname="endpoint"type="xsd:anyURI"/〉〈xsd:elementname="interfaceName"type="xsd:string"/〉〈xsd:elementname="correlator"type="xsd:string"/〉〈/xsd:sequence〉〈/xsd:complexType〉.上述结构中sendSmsRequest可表示为图2.图2sendSmsWS中sendSmsRequest参数的树形结构上述树形参数需要扁平化为同一层级的变量,并用本地动作描述设置动作:(:types……exceptionstring-object……)(:predicates(exception?x-exception)(set?x-string)……)(:actionset:parameters(?x-string):precondition(and():effect(and(set?x)))(:actionsendSms:parameters(?addresses-string?senderName-string?message-string?chargingDescription-string?chargingCurrency-string?chargingAmount-string?chargingCode-string?receiptRequestEndpint-string?receiptRequestInterfaceName-string?receiptRequestCorrelator—string?x-exception?wsName-exception):precondition(and(……(set?addresses)(set?senderName)(set?message)(set?chargingDescription)(set?chargingCurrency)(set?chargingAmount)(set?chargingCode)(set?receiptRequestEndpint)(set?receiptRequestInterfaceName)(set?receiptRequestCorrelator)(forall?x(not(exception?x)))):effect(and((exception?wsName)……))).这里首先增加了一个谓词来判定变量是否已经被设置并用string表示需要处理的变量,然后增加了一个设置变量的动作,最后在动作模型中要求参数中的变量都被设置.4.2.2标准化调用参数为了简化表示,进一步将扁平化的参数中固定部分提取出来作为标准调用参数.例5中的调用参数很复杂,但是实际上它们中的大部分却总是同时被设置.这种简化有三方面的好处:便于开发人员理解,简化业务逻辑描述,便于规划器求解.例6简化了例5.例6.使用标准化调用参数简化sendSmsWS:(:actionsendSms:parameters(?p-standardParameterForSendSms?o-sendSmsObject……):precondition(and(set?p)(forall(?x-exception)(not(exception?x)))(prepared?o)):effect(……))).这里将例5中复杂的参数分为两部分:标准化Page8standardParameterForSendSms:?addresses-string?senderName-string?chargingDescription-string?chargingCurrency-string?chargingAmount-string?chargingCode-string?receiptRequestEndpint-string?receiptRequestInterfaceName-string?receiptRequestCorrelator-string.从软件开发流程的角度讲,上述动作模型将调用WS之前的规范化操作形式化了.这里set动作并不要求所有例外已经被处理是为了给系统足够的灵活性.参数扁平化目前是手工进行的,考虑到XML文本的结构关系和树形模式的层级关系,这个工作肯定可以自动化.我们准备在大多数ParlayXWS建模之后,总结规律并提出自动化参数扁平化工具.4.2.3本地推理动作每个业务的本地推理动作都不同,但可从中提取公共组件推理动作.比如在餐饮查询业务中的推理动作,形式化地看就是从getLocation的对象得到sendSms的对象,这样的行为可以用一个位置相关短消息推理动作来实现.例7.使用位置短消息推理实现本地推理的描述如下:(:actionlocationSmsMessageReasoning:parameters(?location-getLocationObject:precondition(and(getLocation?location)(forall(?x-exception)(not(exception?x)))):effect(and(prepared?message))).这里就是在无例外的前提下从位置信息推理发动作PDDL描述.调用参数部分(standardParameterForSendSms)以及操作对象部分(sendSmsObject).这种方法在简化问题的同时进一步将电信领域知识与业务数据分离了,符合ParlayX和电信业务开发方法演进的趋势.其中对sendSms的标准参数可以进一步说明为给用户的短消息内容.4.3处理异步响应和不确定状态谓词表示.异步响应可以用WFEA处理,不确定状态采用WFEA就是一个代表等待回调的动作,对应在业务中的监听和开发流程中的等待.异步响应最简单的处理方式就是将等待的过程合并到调用动作中.但是这种处理方法有两个问题:不符合开发人员习惯,扩展性差.因此,仿照操作系统中等待事件的方法,这里采用等待事件动作(WFEA).WFEA很好地模拟了开发流程中的操作;同时由于能够容忍网络服务的并行调用,它也有很好的扩展性.对于不确定状态,还需要增加特殊谓词让它“确定化”.规划系统不允许不确定的状态,但异步响应总有调用状态未知的时候.用一个标志事物是否已知的命题,就可以在考虑动作可应用与否的时候规避不合法的状态.进一步由于例外的存在,并且已经被表示为exception了.若WS的例外定义完善,则在处理过exception之后知道就代表成功.我们研究范围内的ParlayXWS恰好都满足这种非例外即成功的习惯,包括呈现、短信发送、彩信发送、呼叫建立等等,例8列举sendSms的相关内容.例8.ParlayX规范定义的sendSms非例外定义如下:即成功.Outputmessage:sendSmsResponsePartnameParttypeOptionalDescriptionresultxsd:stringNoItidentifiesaspecificReferencedfaultsServiceExceptionfromES202504[2]:SVC0001-Serviceerror.SVC0002-Invalidinputvalue.SVC0004-Novalidaddresses.SVC0006-Invalidgroup.SVC0280-Messagetoolong.SVC0283-DeliveryReceiptNotificationnotsupported.PolicyExceptionfromES202504-1[2]:POL0001-Policyerror.POL0006-Groupsnotallowed.POL0007-Nestedgroupsnotallowed.POL0008-Chargingnotallowed.如下.根据上述原则,可以设计WFEA的动作模型例9.PDDL定义的WFEA.定义如下:(define(domainparlayX)(:requirements:typing:adl)(:typesexceptionresultparametersactionObject-objectsendSmsExceptiongetLocationException-exceptionsendSmsResultgetLocationResult-result……)(:predicates……Page9(known?x-result)……)(:actionwait_callback:parameters(?r-result):precondition(and(forall(?e-exception)(not(exception?e)))(not(known?r))):effect(and(known?r)))).上述过程首先增加了一个result类型,用来标志WS调用是否已知成功.增加了result类型之后,增加一个谓词known表示某个result是否已知.一个WS调用的自然结果就是其result是非known的,而WFEA就是以一个result非known为条件以该result被known为结果的动作.4.4多种触发方式业务拆分多种触发方式的业务被认为是多个业务.电信业务从不同角色的角度会有不同的颗粒度:从用户的角度讲多种触发方式的业务是同一个业务,因为它们提供同一种服务;从开发者的角度来讲,它们是不同的业务,因为它们有着不同的业务流程;运营商将多种触发方式的业务统一作为一个业务处理,更多的是出于品牌推广、增强运营商对上游客户和下游厂商的议价能力以及竞争策略等方面的考虑.由于APBPTSD的设计目的是指导ParlayX电信业务设计,其最终对象是开发者,所以这里认为多种触发方式的业务就是多个业务.从计算机科学形式化研究的角度看,多种触发方式的业务实际上是在不同的初始状态出发的搜索问题.不同的触发方式其触发时的环境显然是不同的,那么它们应该是对应着不同的初始状态.从不同初始状态开始的搜索问题即便采用相同的搜索策略,也可能会得到不同的路径.这样一来,多种触发方式的业务内部对不同触发方式采用不同的业务逻辑就很自然了.所以从理论上说使用形式化方法研究就要求将多种触发方式的业务拆分成多个业务.最后,讨论上述方法的复杂性.由于WS本身差异较大,因此对其动作建模的复杂性难以进行严格论证(例如相关工作的文献[24]也没有提供复杂性的严格证明),因此下面对APBPTSD方法的建模复杂性进行简单讨论.该方法所产生的动作类别包括领域动作、SPCA动作、LA动作和WFEA动作等.首先,将ParlayXWS建模为一个领域动作模型和一个SPCA动作模型,后者用来处理容错.然后,使用本地动作set来处理参数设置,使用本地动作locationSmsMessageReasoning从位置信息推理发给用户的短消息内容.这样使得参数设置、查询处理等本地动作体现在业务流程中.接着,用WFEA动作来处理异步响应,WFEA是等待回调的动作,对应在业务中的监听和开发流程中的等待.最后,业务的多种触发方式对应不同的初始状态.因此,方法所产生的动作数目是非常有限的.此外,规划问题本身是NPC的[33],求解WS对应的规划问题的具体时间依赖于所使用的底层规划系统.4.5生成领域文件和问题文件在上述建模之后得到的动作模型需要整合为一个领域文件,然后根据业务要求生成问题文件以提交规划器求解.作为一个最简单的例子,满足餐饮查询业务使用要求的领域文件和问题文件分别在附录A和附录B中.上述生成方法是半自动的.领域文件中类型、谓词、动作都可以根据动作模型自动生成,问题文件中常量和初始状态可以根据建模规则自动生成或手工撰写,但是问题文件中的目标目前还不能自动生成,规划领域也没有自动生成的先例.实验证明上述模型在目前是可行的,但是目前尚无足够多的样本也没有理论证明其合理性.在下一步工作中,积累了足够多的ParlayXWS模型之后,我们会改进上述模型或者论证其合理性.5分支与循环经典规划器不是为处理分支与循环设计的,但2008年开始越来越多的研究[28-29]试图使用经典规划器(特别是FF[30])来处理分支和循环.本文也仿照这些最新研究进展,采用后处理来满足电信业务中的分支、循环的需求.经典规划器的领域中动作效果是确定的,状态也是确定的,不存在分支和循环.经典规划器的解是有序动作序列,也不能支持分支和循环.因此人们很久之前就提出了不确定规划[18],其领域描述、规划解(策略)都能处理分支、循环的情况.但是,经过多年的研究,不确定规划的求解效率一直没有得到太大的提高.从2004年的IPC-4开始,国际规划大赛引入了不确定规划竞赛,更准确地说是从概率规划大赛开始的.经过3界比赛(2004年的IPC-4,2006年的IPC-5,2008年的IPC-6),人们发现与其求解不确定规划器很多时候不如直接用经典规划器求解,再通过预处理和后处理合成带有分支和循环的解.例如,2008年Yoon等人[28]通过实验证明采用Page10FF[30]并加以预处理和后处理的FF-Replan系统比IPC-5上的概率规划器更有效.同年,Kuter等人[29]提出了通用的算法框架利用经典规划器处理不确定规划问题,其中调用经典规划器之前和之后的步骤也可以视为预处理和后处理.带有分支的业务可被认为是多个业务.从开发者的角度来讲,它们是不同的业务,因为它们有着不同的业务流程.由于APBPTSD的设计目的是指导ParlayX电信业务设计,其最终对象是开发者,所以这里认为带有分支的业务就是多个业务.在进行业务设计之后,在本文目前的研究中这类情况还不多见所以采用手动合成,未来可以采用Yoon等人[28]或Kuter等人[29]的方法进行合并.在目前本文的研究范围内还没有真正的循环业务,这是因为电信业务往往要求一个等待时长之类的限制,比如呼叫转移不能超过2次,彩铃放音不超过90s等.对于少数带有循环的业务目前我们的处理方法是增加计数器展开为顺序流程,未来可以采用Yoon等人[28]或Kuter等人[29]的方法处理.6实验与分析测试环境为CPU(CeleronProcessor1303.015MHz)+RAM(256M)+FreeBSD6.2,gccversion4.3.0.在测试中采用的是我们自主源码规划器FFPS[6],但在开放源码规划器FF-v2.3[30]中也可获得同样结果,后者可在其主页[31]上下载.6.1餐饮查询业务的解在上述建模之后得到的动作模型需要整合为一个领域文件,然后根据业务要求生成问题文件以提交规划器求解.例10.使用FF/FFPS对附录A与附录B中描过程如下:述的餐饮查询业务自动求解结果.ff:foundlegalplanasfollowsstep0.SETSTANDARD_PARAMETERS_FOR_SENDSMS1.SETSTANDARD_PARAMETERS_FOR_GETLOCATION2.GETLOCATIONSTANDARD_PARAMETERS_FOR_GETLOCATIONLOCATIONGETLOCATION_EXCEP-TION3.HANDLE_EXCEPTIONGETLOCATION_EXCEPTION4.LOCATIONSMSMESSAGEREASONINGLOCATIONMESSAGE5.SENDSMSSTANDARD_PARAMETERS_FOR_SENDSMSMESSAGESENDSMS_EXCEPTIONSENDSMS_RESULT6.HANDLE_EXCEPTIONSENDSMS_EXCEPTION7.WAIT_CALLBACKSENDSMS_RESULTtimespent:0.00secondsinstantiating10easy,0hardactiontemplates0.00secondsreachabilityanalysis,yielding15factsand0.00secondscreatingfinalrepresentationwith15relevant10actions0.00secondsbuildingconnectivitygraph0.15secondssearching,evaluating37states,toamax0.15secondstotaltimedepthof3上述步骤的解释为facts0.为sendSms设置标准参数;1.为getLocation设置标准参数;2.用getLocation的标准参数(并准备处理getLocation的例外)调用getLocationWS;3.处理getLocation的例外;4.使用本地推理,根据location信息推理message内容;5.用sendSms标准参数和message内容(并准备处理6.处理sendSms的例外;7.等待callback回调以得知sendSms的结果.sendSms例外和结果)调用sendSmsWS;可见上述描述比例2中的图1有了更强的指导性,这个规划解可与例6中的标准化参数模式共同作为业务的详细设计.6.2其它业务上的实验APBPTSD的实验还在彩铃[11]、消息转发业务[15]、餐饮服务[16]、多方多媒体会议[17]以及中国电信的点击拨号(CTD)、会议电话、短信群发等业务上进行了测试.由于篇幅和版权问题表1仅对测试中的部分结果进行说明,具体业务描述在附录C中.业务名ParlayXWS模型个数本地推理动作个数彩铃消息转发业务餐饮服务多方多媒体会议点击拨号(CTD)会议电话短信群发注:上标“”表示属于多个业务,需要进行拆分.表中数字为总数.6.3实验分析在表1中可以看出:常用的ParlayXWS并不多,本地推理也不多.实际上结合例3、例5和例10可以发现电信业务设计中最大量的工作在于程序化的要求上,比如例5中繁杂的标准参数设计以及不同WS之间或者WS和本地动作的参数匹配上.在这种情况下,APBPTSD可以大大简化设计工作,自动生成详细设计.Page117结语规划应用是智能规划研究领域中的热点问题.从应用的角度,在智能业务开发的过程中需要样例,电信运营商需要规范,这都要求一个独立完整但不一定非常详尽的业务原型.从学术研究的角度,为某个领域的特定类的问题生成通用规划也是规划研究的趋势,在2009年的ICAPS国际会议上就举办了专门的Workshop讨论通用规划[32](GeneralizedPlanning).与以往网络服务组合理论研究中的规划应用不同,本文是最早的结合实际电信业务的规划应用.为了解决WSC容错和对变化推理、电信业务有多种触发方式和异步响应以及智能规划要有确定状态等实际要求,本文提出了基于AIPlanning的ParlayX电信业务设计(APBPTSD)方法.APBPTSD用标准后处理动作(SPCA)处理容错,用等待事件动作(WFEA)处理异步响应,用本地动作(LA)处理动作变化推理.本文的主要创新点在于结合ParlayXWS的实际情况解决了WSC应用和规划应用中的问题.首先,电信业务中的容错是有优先级概念的,本文首次提出增加动作处理优先概念.其二,电信异步响应特性阻碍了WSC方法的应用,本文首次提出采用等待动作建模.其三,本文考虑了实际指导开发的需要,首次提出增加本地动作,这是WSC研究中一般不予考虑的.最后,区别于以前对电信业务的研究[11-17],本文的方法注重于自动化流程构造,也不需要除电信(ParlayX[1])规范和开源的经典规划器(FF[30])外的其它如语义网[21]等工具.其中最后一点也是本文研究易于理解,被运营商、SP、程序开发人员广泛接受的基础.此外,要特别说明的是,关于本文所用建模方法的正确性和合理性分析.建模方法的正确性实际上可以通过对比实验结果与实际业务代码来验证.本文用于实际测试的例子数量有限,但就目前ParlayX业务来讲其覆盖面较广、代表性较强.可通过和业务代码对比来验证建模方法正确.本文在附录中提供了能够验证部分业务正确性的领域描述,但出于中国电信研究院版权方面的考虑不可能将全部领域描述都公开.对于WSC问题建模正确性的问题确实有部分文章给了一些证明,但多利用OWL-S等描述来做为其原型,而实际上电信行业仅承认其自有的自动机模型.自动机模型到人为模型之间的对应关系,是建模语言的操作语义,需要ParlayX的操作语义.由于目前ParlayX规范尚待完善,这种证明还无法进行.本文迈出了智能规划在电信业务中应用的第一步,然而在提出的方法中还有一些不足需要在未来的工作中克服.首先,在积累更多ParlayXWS模型后,我们计划改进模型或者论证其合理性.其次,目前的半自动或手动的方法大部分可以自动化,比如参数扁平化,WS动作模型设计[26]、分支循环的预处理和后处理[28-29]等等.其三,由于建模方法是语义无关的,原则上存在自动化方法实现从ParlayX协议到PDDL模型的转换,可以在改进模型的同时尝试生成自动化工具.最后,规划研究中刚刚被关注的通用规划[32]的进展可能对本文的研究有帮助,本文的研究方法也可能可以进一步推广到更多的领域,形成一种通用规划的方法.致谢本文在撰写过程中得到了中国电信研发中心原增值业务室同事的大力支持,在此向他们对本文的指导以及多年来对第二作者的帮助表示感谢!
