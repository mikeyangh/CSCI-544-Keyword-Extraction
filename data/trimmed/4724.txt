Page1数据流上动态轮廓查询处理技术的研究白梅信俊昌王国仁王习特(东北大学信息科学与工程学院沈阳110004)摘要轮廓查询(Skyline)是一种典型的多目标优化问题.动态轮廓查询(DynamicSkyline)是轮廓查询的一个重要变种,其目标是对于一个给定的查询点q,返回在各维度上最接近q的所有点.对比轮廓查询,动态轮廓查询根据查询点q的位置变动,可以更加灵活地返回查询结果.文中关注数据流上动态轮廓查询处理,此问题在多目标决策方面具有非常重要的应用.为有效地解决该问题,首先提出了一种组合式索引结构来管理数据流上的点,该索引结构包括两个部分:对整体数据使用分层次划分结构进行维护;对子划分内部数据采用倒排索引结构进行维护.该组合式索引结构具有更新快、过滤性能高、适合任意数据分布等优点,可以提高动态轮廓的查询处理效率.然后,基于该组合式索引结构,提出了基础的数据流上动态轮廓查询算法(BasicDynamicSkylineQueryoverDataStream,BDS2).通过维护少量的数据,BDS2可以快速地计算出数据流上的动态轮廓集合.然而BDS2在处理个别更新时,会有较大的时间延迟,为了更稳定地计算数据流上的动态轮廓,避免更新某些点时计算量急剧增加,进一步提出了改进的数据流上动态轮廓查询算法(ImprovedDynamicSkylineQueryoverDataStream,IDS2).最后,通过一系列的实验验证了文中所提出算法的有效性.关键词数据流;动态轮廓;组合式索引;分层次划分;倒排索引1引言轮廓查询[1-2]作为多目标决策(Multi-CriteriaDecision-Making,MCDM)手段,可以通过偏好函数帮助用户从大量信息中提取有用信息,在许多实际应用中都发挥着非常重要的作用.轮廓集合是指所有不被“支配”的点的集合.具体地,给定两个点p1和p2,p1支配p2指的是:在所有维度上,p1都不比p2差;至少在一个维度上,p1要比p2好.通常情况下,值越小被认为越“好”.如图1所示,一共有15条股票信息记录{s1,s2,…,s15}.每一条股票信息包括2个维度信息:股票收益率和成交量.每一维的值都被映射到[0,1]的区间内,并以“小”值为优.例如图中s4在每一维都比s5小,那么说明s4的收益率和成交量比s5要好,则s4支配s5.图中的轮廓集合就是{s3,s4},其他股票记录都可以被s3或s4支配.目前,轮廓查询已取得了大量研究成果,但是对各个维度值的“好坏”定义却有一定的局限.针对这一问题,文献[3]提出了动态轮廓的概念.对比轮廓查询,动态轮廓查询具有多样性及灵活性等特征.通过给出一个关注点q时,动态轮廓查询[4-5]可以返回在各个维度上与q最接近的点,即所有潜在的兴趣点.在不同的应用场景中,可以通过调整q点的位置,从而取得不同的查询结果.因此,动态轮廓查询的应用更为广泛和灵活.动态轮廓集合是所有不被“关于q动态支配”的点的集合.具体地,给定2个点p1和p2,p1关于q动态支配p2(记作p1qp2)指的是:在所有的维度上,p1距离q都不比p2距离q远;至少在一个维度上,p1距离q比p2距离q近.如图1所示,s2关于q动态支配s6.图中q的动态轮廓集合是{s1,s2}.本文主要关注的是数据流上动态轮廓查询处理,它在现实生活中是一个非常有意义的问题.例如,股票交易市场每天可以产生大量的数据,而人们在分析的时候,通常只关注最近的股票信息.针对这一数据特征,人们可以采用滑动窗口模型来管理这些流数据.当已知某只股票q具有良好的投资价值时(风险低,回报好),通过进行关于q的动态轮廓查询,找到所有与q相似的股票.对这些股票进行分析,可以确定什么样的股票能有良好的投资价值,并帮助人们进行股票投资.由此可见,数据流上的动态轮廓查询具有很好的实际应用价值.数据流上的动态轮廓查询在各种环境监测上同样具有非常重要的应用价值,包括草原环境监测、森林环境监测、海洋环境监测等等.例如森林火灾监控方面,传感器每次传入大量的数据点,但是人们只关注最新一轮的数据点情况,因此可以采用滑动窗口模型来管理这些流数据.根据以往的经验,可以得知点q(温度=100,湿度=30%rh)所处的环境下容易发生火灾,以q为查询点进行数据流上的动态轮廓查询,就可以得到所有潜在的火灾发生点,从而达到森林防火监控的目的.根据上述描述可知,数据流上动态轮廓查询具有非常重要的应用价值.然而,关于数据流上的动态轮廓查询只有很少的研究工作[6],且存在一定的局限性.因此,本文针对数据流上动态轮廓查询提出了Page3一种更加高效和全面的解决方案.在文献[6]中,张丽等人介绍了滑动窗口上基于网格的动态轮廓查询算法GBDS,具有一定的局限性.首先,由于GBDS采用网格结构来管理滑动窗口中的数据.只有当数据呈均匀分布时,网格才具有较高的效率.然而在实际生活中,流数据可以呈现多种不同分布,如环境检测数据多呈现出聚类分布,股票数据多呈现相关、反相关分布[1]等,因此,网格索引可能无法高效的管理这些流数据.当网格粒度过大时,会造成某些网格内存储大量的数据元组,从而影响计算效率.当网格粒度过细时,会生成大量的空白网格,浪费大量的存储空间.针对这一问题,本文提出了一种全新的组合索引结构,以适合不同分布的流数据.其次,为了便于剪枝,GBDS算法在计算过程中维护了一个影响区域(如图1中的阴影区域),落在影响区域中的点不会被任何现有动态轮廓点动态支配.这种影响区域在2维数据空间上非常容易维护,但是在3维及3维以上的数据空间中,该影响区域的维护相当于进行集合的并集运算[3].假设有|RS|个动态轮廓点时,根据集合并集运算法则,影响区域的维护代价是O(2|RS|).针对该问题,本文给每个数据点设计了一种结构,可以高效地维护数据流上动态轮廓.本文设计了一种数据流上的组合式索引结构,并结合数据流上动态轮廓的特性,首先提出了一种基础的数据流上动态轮廓查询算法BDS2(BasicDynamicSkylineQueryoverDataStream,BDS2).之后,在BDS2算法的基础上,通过维护简单的数据结构,提出了改进的数据流上动态轮廓查询算法IDS2(ImprovedDynamicSkylineQueryoverDataStream,IDS2).归结起来,本文的主要贡献如下:(1)提出了一种组合式索引结构,包括两个部分:分层次划分结构和倒排索引结构.分层次划分结构把整体数据分割成多个子划分块,并保留了子划分块之间的层次关系,具有3大优势:①保留了子划分块的层次关系和位置结构,可以快速地进行空间剪枝;②在任何数据分布下,都保证了每个叶子划分内的数据量是大体均衡的,避免了存储空间的浪费,并且高效地管理了整体数据;③分层次划分结构不会随着维度增加而呈指数级增加,对维度不再敏感.倒排索引结构用来管理每个叶子划分内的数据,从而加快元组间的关系判定,快速地计算出最终结果.无论是分层次划分结构还是倒排索引,都能够在数据流上进行快速地更新,因此,本文所提出的组合式索引结构具有3大优点,包括更新快、过滤性能高以及适合任何数据分布.(2)基于组合式的索引结构,首先提出了基础的数据流上动态轮廓查询算法BDS2,通过空间过滤和倒排索引过滤,快速地完成了动态轮廓的初始化和更新.然而,BDS2在数据流上处理某些更新时,会引起处理时间的急剧增加.为了更加稳定地计算数据流上的动态轮廓,本文提出了改进算法IDS2,并给出了IDS2算法的初始化和更新处理方法.IDS2通过对每个数据元组维护简单的数据结构,可以保证在数据流上持续稳定地计算出动态轮廓结果.(3)设计了详细的性能评价实验,实验结果表明本文所提出的算法BDS2和IDS2都可以有效地处理数据流上的动态轮廓查询,而IDS2在稳定性上要远好于BDS2.本文第2节回顾相关工作;第3节介绍数据流上动态轮廓查询的相关定义;第4节详细描述本文所提出的组合索引结构,基于该索引结构,提出算法BDS2和IDS2;第5节对算法BDS2和IDS2进行复杂度分析;第6节给出实验结果与分析;第7节对全文进行总结.2相关工作自Borzsonyi等人[1]在2001年将轮廓查询的概念引入到数据库领域之后,多种轮廓查询算法及其变体查询算法[5-10]被相继提出.接下来,给出轮廓查询的相关工作以及动态轮廓查询的相关工作.2.1轮廓查询算法BNL和D&C算法最早在文献[1]中提出,BNL通过扫描全体数据和维护一个候选集集合来计算轮廓集合.D&C算法首先把整体数据分割成多个子集,然后合并计算每个子集的子轮廓集合,从而得到最终的轮廓集合.SFS算法[11]首先按单调函数把整体数据进行排序,然后再计算轮廓集合.之后,许多学者致力于通过索引结构来提高轮廓查询的效率.Bitmap成一个m位矢量,通过矢量间的计算求出最后的轮廓集合.但是Bitmap算法不适用于动态数据库.NN[13]算法利用近邻点过滤来求得最后的轮廓集合.BBS算法[3]利用R-tree索引结构管理整体数据,只需要访问R-tree中包含结果点的节点.ZBtree[14]通过利用Z-order索引来进行过滤,从而完成轮廓查询的计算.此外,还出现了很多针对特定数据环境的轮廓Page4查询算法,如P2P网络[2]、分布式环境[15]和不确定数据环境[16]等.在数据流环境下,轮廓查询已取得了很多成果.Lin等人[7]首次提出了数据流上的轮廓查询算法.该算法利用R-tree索引来管理滑动窗口上的数据,并采用区间树(intervaltree)来维护数据流上的轮廓集合.之后,Tao等人[8]提出了在数据流上轮廓查询的高效算法,通过过滤掉滑动窗口上的冗余元组来提高空间、时间效率.Morse等人[17]提出在数据流上持续维护轮廓集合的算法Look-Out.Lu等人[18]提出双层次数据流上的轮廓查询算法.该种双层次数据流设定是一种非典型的数据流环境.以上在滑动窗口上的轮廓查询都采用R-tree索引来管理,但是R-tree的更新操作相对较慢,尤其是维度较多的情况下,在滑动窗口上对R-tree的维护将耗费大量时间.Li等人[19]提出用分层次网格来管理滑动窗口上的数据.但是关于子网格的粒度选取没有合适的介绍,且网格索引结构对维度十分敏感,会随着维度增加呈指数级增加.例如当任意中间网格需要划分时,至少会划分成2d个子网格.同时,单纯的分层次网格结构并不能很好地解决数据流上轮廓查询问题,因为子网格内的数据需要逐一处理.针对上述情况,本文设计了一种针对维度不敏感,且更新容易,能适用各种数据分布的组合索引结构.Lee等人[20]提出了数据流上的多轮廓查询方法,在数据流上维护了各个子空间上的轮廓集合.目前还出现了各种轮廓变体查询,如子空间轮廓[21]、Top-k轮廓查询[22]、ρ-支配轮廓[23]、动态轮廓和反轮廓[6].2.2动态轮廓查询Papadias等人[3]提出的BBS算法,采用R-tree索引结构快速地计算动态轮廓.根据R-tree中节点与查询点q的距离进行过滤,从而得到最终的动态轮廓集合.然后,他们提出了一种新方法来计算动态轮廓,根据查询点q所在的位置,把所有的数据点都映射到q的同一个象限后,进行传统的轮廓查询,就可以得到最终动态轮廓结果.Chen等人[24]提出了一种在度量空间内的动态轮廓查询算法.给定m个查询点,每个数据点到各个查询点的距离是一维的轮廓属性.这样每个数据点都可以映射成一个m位矢量,对这些矢量进行轮廓查询就是度量空间上的动态轮廓集合.Chai等人[25-26]利用动态属性,提出了一种动态轮廓查询的变型,称为T-skyline.该变型查询通过指定偏好强度,从而控制了轮廓结果.这种查询本质上与动态轮廓类似,对每个属性维度加入了权重来共同考虑.以上的研究都是基于静态关系数据库的,并不适用于数据流环境,与本文的研究内容不同.与本文研究最相关的文献是由Zhang等人[6]提出的在滑动窗口上进行动态轮廓查询算法GBDS.他们采用网格索引来管理滑动窗口中的数据,利用网格和数据点间的动态支配关系进行过滤,并维护一个影响区域.当滑动窗口上的数据发生变化时,通过维护查询点的影响区域,来维护最终的动态轮廓集合.但是,GBDS采用的网格索引结构,适合数据均匀分布时使用.当数据分布不均匀时,网格索引的表现并不是很好.针对每一个动态轮廓查询点,GBDS都需要维护一个影响区域,在3维及3维以上的数据环境下,假设当前动态轮廓集合中的元组数目为|R|,影响区域的维护代价为O(2|R|).为了解决上述问题,本文提出了两种全新的算法来解决滑动窗口上的动态轮廓查询问题.通过采用组合式索引结构,BDS2和IDS2不局限于均匀分布的数据,在所有分布下都能取得好的结果.同时,对于每一个动态轮廓查询,BDS2和IDS2都只需要增量维护一个子集,避免整体数据的重扫描.IDS2通过维护简单的数据结构,能够更加稳定地计算滑动窗口上的动态轮廓.3问题描述本文关注的是数据流上的动态轮廓查询问题,采用滑动窗口来管理数据流上的数据.滑动窗口包括基于时间(time-based)和基于计数(count-based)的滑动窗口,两种滑动窗口上的算法可以相互转换,本文关注的是基于计数的滑动窗口.为了描述方便,表1中给出了本文的符号定义.符号p1,p2p1[i]p.labelp1qp2DSKY(q,DN)Page5给定d维数据集合D,每个数据点可以表示成p=〈p[1],p[2],…,p[d]〉,且每个维度上的值都以小值为优.通过映射函数,可以把每个数据在各维度上的值都转化到[0,1]范围内.本文关注的是在范围[0,1]内的数据的集合.定义1(动态支配).给出d维数据集合D和查询点q,p1,p2∈D,p1关于q动态支配p2(记作p1qp2)需要满足以下两个条件:(1)i∈{1,2,…,d},|p1[i]-q[i]||p2[i]-q[i]|;(2)j∈{1,2,…,d},|p1[j]-q[j]|<|p2[j]-q[j]|.所有不被其他点关于q动态支配的点的集合组成了q的动态轮廓集合,记作DSKY(q,D)={pi|pi,pj∈Dpjqpi}.根据动态轮廓的定义,可以得知q的动态轮廓查询可以返回与q在所有维度上最接近的点的集合.在滑动窗口中,数据遵循“先进先出”的原则.对于进入滑动窗口的数据元组p,用p.label来表示p到达滑动窗口的次序标签.当滑动窗口大小是N时,元组p在滑动窗口的存活周期是[p.label,p.label+N].滑动窗口中只存储最新到达的N的数据,记窗口中维护的数据集合为DN.每当一个新的数据元组pnew插入到滑动窗口中,都会有一个对应的数据元组pold失效,从而保证滑动窗口中永远只保留最新的N个元组.在滑动窗口上进行动态轮廓查询,就是持续监测DN的动态轮廓集合.如图2中所示,滑动窗口大小为23,当数据元组p1~p23在滑动窗口时,q的动态轮廓点是{p1,p2}.随着滑动窗口的滑动,p1和p2失效,p24和p25加入到滑动窗口中,这时q的动态轮廓集合是{p7,p8,p19,p23,p25}.4数据流动态轮廓查询处理本节中,首先介绍了本文提出的组合式索引结构;然后,介绍了数据流上动态轮廓查询的基本性质,包括如何在数据流上进行剪枝以及如何利用索引结构进行动态支配关系判定;接着,给出了算法BDS2的初始化和更新方法;最后,介绍了算法IDS2的初始化和更新方法.其中,算法BDS2通过维护滑动窗口中少量的元组来持续的计算当前滑动窗口中的动态轮廓集合.然而,BDS2在处理滑动窗口上的个别更新时,会使得算法响应时间突然增加,引起较大的延迟.为了更加稳定地在数据流上计算动态轮廓,在BDS2算法的基础上,通过对每个数据元组维护一个简单的结构,进一步提出了算法IDS2.4.1组合式索引结构为了使本文算法适用于各种数据分布,本文采用组合式索引结构来进行管理.组合式索引结构包括两部分:分层次划分结构和倒排索引.分层次划分结构能够保证在各种数据分布下都有良好的表现,使得每个子划分中存储的数据个数都是可控的.同时,能够避免某些空白子划分的存在,避免了存储空间的浪费.这种分层次划分结构,可以通过中间层次划分的动态支配关系判定,完成数据的批量过滤.对于子划分的数据,采用倒排索引进行管理,从而加速元组间动态支配关系的判定,快速地得到最终结果.(1)分层次划分结构分层次划分是一种树状的空间索引结构.每一个划分r可以表示为(r.min,r.max,r.num),其中r.num表示的是划分r中存储的数据元组个数;r.max、r.min分别是划分r上界点和下界点.下界点r.min取的是划分r在各个维度的最小值(具体表示为r.min=〈r.min[1],r.min[2],…,r.min[d]〉),而r.max取的是划分r在各个维度的最大值.分层次划分中的划分可以分为2类:中间划分和叶子划分.叶子划分存储的是落在它范围内的所有数据元组.而中间划分存储的都是划分.给定一个数据元组p,对于所有维度i,如果p[i]∈(r.min[i],r.max[i]],那么数据元组p就落在划分r中.分层次划分采用参数C(被称为子划分约束)对划分进行约束,从而使这种分层次划分能够适合多种数据分布,即数据分布不均匀时,依然可以保证每Page6个子划分中的数据元组个数相近.子划分约束C限制了每个叶子划分内最多可以存储C个数据元组.一旦某个叶子划分内的元组个数超过C个,那么,该叶子划分标记为中间划分,同时进行分裂,直到它分裂后的孩子节点满足子划分约束,否则的话,继续分裂.下面介绍具体的分裂规则:给定一个d维的数据划分r=(r.min,r.max,r.num),当r.num>C时,首先,选择某一个维度di,使得整个数据按di维进行均分后,保证得到的两个孩子划分的数据个数的差值最小.所谓的按di维进行均分,指的是把r分裂成r1和r2后满足:(1)对于任意不等于di的维度dj,r1.min[dj]=r1.min[dj]=r.min[dj],r1.max[dj]=r1.max[dj]=r.max[dj];(2)对于维度di,r1.min[di]=r.min[di],r1.max[di]=r2.min[di]=(r.min[di]+r.max[di])/2,r2.max[di]=r.max[di].如果划分后的r1或r2仍然不满足子划分约束C,即r1或r2中的数据点个数多于C个,从剩余的维度中再选择一个维度进行均分.以此类推,当所有的维度都均分完毕后,还无法满足子划分约束C,开始新一轮的划分.当某个划分不满足子划分约束C时,需要进一步划分,被称为中间划分.满足子划分约束C的划分,即划分中的数据点个数小于或等于C个,该划分称为叶子划分.对比网格划分,分层次划分不会随着维度增加而呈指数级增长.分层次划分的算法描述如算法1所示.算法1.分层次划分算法描述.输入:整体数据集合D,数据集合的数据点个数Num,输出:分层次划分结果1.初始化根划分root=(〈0,…,0〉,〈1,…,1〉,Num);2.把root加入到堆H中;3.While(H不为空)4.取H的首划分元素r;5.If(r满足叶子划分)6.7.Else8.Mindif=r.num;Mindim=;9.10.11.12.13.14.15.EndFor16.从candidim中移除Mindim;17.If(candidim为空集)18.19.EndIf20.按维度Mindim对r进行均分,并把分裂后的21.EndIf22.EndWhile根据算法1和均分方法可知,所有的叶子划分之间没有任何重叠,所以给定任意数据点p,它只可能落在唯一的叶子划分中.具体地,图3是图2的分层次划分结构(p1到p23是数据集合).设定子划分约束C=10,整体的根划分是root=(〈0,0〉,〈1,1〉,23).首先,如果按维度1进行对root均分时,左边有15个数据点,右边有8个数据点,差值为7.如果按维度2均分时,差值同样是7.随机选择维度1作为第一层次的划分,得到划分r0=(〈0,0〉,〈0.5,1〉,15)和r1=(〈0.5,0〉,〈1,1〉,8).由于r0.num=15,不满足子划分约束C,所以r0是中间划分,需要进一步划分.只剩下维度2可供选择,按维度2对划分r0进行均分后,可以得到r0,0=(〈0,0〉,〈0.5,0.5〉,11)和r0,1=(〈0,0〉,〈0.5,0.5〉,11).由于r0,0.num=11不满足子划分约束,需要进一步划分.由于维度1和维度2都划分完毕,重置候选维度为{1,2}.以维度1均分r0,0时,左右两边的数据点个数分别是5和6,差值为1.当选择维度2均分r0,0时,差值是3,所以选择维度1均分r0,0,可以得到r0,0,0=(〈0,0〉,〈0.25,0.5〉,5)和r0,0,1=(〈0.25,0〉,〈0.5,0.5〉,6).经过3次划分后,得到的r1、r0,1、r0,0,0和r0,0,1都满足子划分约束C,是叶子划分.(2)倒排索引结构对于叶子划分内的数据元组,采用倒排索引结构来管理.具体的,针对每一个维度,都对叶子划分内的数据进行排序.同时把查询点q也加入到每个叶子划分内的倒排索引结构中.如图4所示,在叶子划分r0,1中,把数据元组p3,p4,p7,p23和查询点qPage7进行排序.按维度1排序,得到p3,p4,p23,p7,q.按维度2排序后,可以得到结果p23,q,p3,p7,p4.综上所述,组合索引结构的组织结构如下:①中间划分r=(r.id,r.min,r.max,r.num,r.isleaf,r.childrenlist).其中r.id是该划分的唯一标识;r.min是该划分对应的矩形区间的下界点;r.max是该划分对应的矩形区间的上界点;r.num是落在该划分对应区间内的所有元组的个数;r.isleaf用来标识该划分是不是叶子划分;r.childrenlist存储了该中间划分的所有孩子划分的指针.如图3所示,r0,0.min=〈0,0〉,r0,0.max=〈0.5,0.5〉,r0,0.num=11,r0,0.isleaf=false,r0,0.childrenlist={r0,0,0,r0,0,1}.②叶子划分r=(r.id,r.min,r.max,r.num,r.isleaf,r.tuplelist[d]).其中r.id,r.min,r.max,r.num,r.isleaf与中间划分表示的含义相同.r.tuplelist[d]存储了d个维度上落在该叶子划分中所有数据元组的倒排链表.如图4所示,r0,1.min=〈0,0.5〉,r0,0.max=〈0.5,1〉,r0,0.num=4,r0,0.isleaf=true,r0,0.tuplelist[0]={〈0.25,p3〉,〈0.3,p4〉,〈0.4,p23〉,〈0.45,p7〉},r0,0.tuplelist[1]={〈0.6,p23〉,〈0.7,p3〉,〈0.8,p7〉,〈0.95,p4〉}.组合索引结构的更新包括两部分:删除数据元组和插入数据元组.下面给出组合索引结构更新的伪代码描述.算法2.组合索引结构的更新.输入:组合索引根划分root;待失效元组pold;待插入元输出:更新后的索引结构//处理失效元组pold1.从root.childrenlist中找到pold所属的划分r,并把r2.While(H不为空)3.取H中的划分r;4.If(划分r是叶子划分)5.6.ElseIf(划分r是中间划分)7.8.9.10.11.EndIf12.EndIf13.EndWhile//处理插入元组pnew14.按上述2~10行的方法定位pnew所属的叶子划分r;15.If(r.num==C)16.把pnew插入到r中后,按算法1中9~20行中的17.EndIf根据算法2的描述可知,当有数据点从索引中删除时,偶尔需要进行叶子划分的合并,合并的代价为O(C×d).当有数据点插入到索引时,有时会引起叶子划分变成中间划分并分裂,这里的分裂代价仍然是O(C×d).如图5中所示,当元组p22插入到数据流中时,子划分约束C=10,叶子划分r0,0中存储的元组个数由10变成11,不再满足子划分约束,所以r0,0需要分裂.根据r0,0原有的倒排索引结构,如果按维度1分裂,差值为0.按维度2均分,差值为2,所以选择按维度1进行均分.通过一次遍历,就可以完成r0,0,0和r0,0,1的分裂.Page8可以发现,关于子划分约束C的取值,是需要进行权衡的.当C值过大时,会造成划分层次过低,中间划分减少,对更新元组的定位会比较快.但是,在叶子划分中的处理的耗时会变长.同时可以被过滤掉的中间划分也相应减少.反之,当C值过小时,会造成划分层次过多,定位到对应的叶子划分耗时会较多.而在叶子划分内部的处理时间相对较快.之后,我们在实验部分进行了关于参数C的验证,在不同的分布中,通过实验取得合适的参数C.4.2数据流上动态轮廓的基本性质在介绍本文的具体算法之前,首先给出一些数据流上动态轮廓的基本性质,包括数据流上的元组剪枝以及动态支配关系的快速判定,用于加速数据流上动态轮廓查询处理.4.2.1数据流上的剪枝策略下面,我们给出数据流上动态轮廓查询的剪枝.定理1.给出数据流上两个元组p1,p2和查询点q,p1到达数据流比p2晚(p1.label>p2.label),且p1关于q动态支配p2,则p2在它的存活时间内,不可能成为q的动态轮廓.证明.由于p1到达数据流时间比p2晚,则p2失效时,p1不会失效.由于p1关于q动态支配p2,所以p1失效前,p2不可能成为q的动态轮廓.定理1得证.根据定理1可知,对于每一个查询点q,被后到达的元组动态支配的元组都可以直接删除,只需要维护少量的数据就可以了.所有不满足定理1的数据元组都需要被保留在滑动窗口中.给定查询点q,可以把数据流上的所有元组分成3个集合:(1)结果集合.DN中关于q的所有动态轮廓点的集合,用符号RS表示,|RS|表示RS中的元组数目.(2)候选集合.只被比自己先到的点动态支配的点的集合,用符号CS表示,|CS|表示了CS中的元组数目.(3)删除集合.被后到达的点动态支配的点的集合,即满足定理1条件的数据元组.对于查询点q,只需要维护结果集合RS和候选集合CS中的点.定理2.随机数据流中,即数据流上的元组呈均匀分布时,数据流中需要维护的元组个数(结果集合加候选集合)是O(lndN/d!).证明.把数据流上的标签属性作为一个轮廓计算维度,结果集合加候选集合中的元组相当于d+1维上的动态轮廓集合.根据文献[5]中的定理2可知,随机数据流上需要维护的元组个数是O(lndN/d!),定理2得证.利用定理1可以完成数据流上元组的剪枝,对于每个查询点q,只需要维护少量的数据就可以完成数据流上的动态轮廓查询.下面介绍如何利用4.1节中介绍的索引结构进行空间批量过滤和动态支配关系的快速判定.4.2.2动态支配关系的快速判定动态支配关系的判定主要包含2个步骤:首先利用分层次划分来判定数据点与中间划分之间的动态支配关系,从而进行空间上的批量过滤;然后在倒排索引内快速判定元组与元组之间的动态支配关系.(1)元组与划分间的动态支配关系给定一个划分r=(r.min,r.max,r.num)和查询点q,在进行动态支配关系判定前,首先给出两个基本定义.定义2(划分最近距离点).给定一个划分r(r.min,r.max,r.num)和查询点q,r在各个维度上的最接近q的点被称为最近距离点,用符号r.near表示.r.near[i]=烄烅烆定义3(划分最远距离点).给定一个划分r(r.min,r.max,r.num)和查询点q,r在各个维度上的与q的距离最远的点被称为最远距离点,用r.far表示.r.far[i]=烄r.max[i],q[i]∈0,烅r.min[i],q[i]∈烆如图2中所示,给定q〈0.55,0.65〉和r0,0,1(〈0,0〉,〈0.5,0.5〉,6),根据定义2和3可知,r0,0,1.near=〈0.5,0.5〉,r0,0,1.far=〈0.25,0〉.下面的定理给出了如何利用划分和查询点的最近距离点和最远距离点来判定划分和数据点之间的动态支配关系.定理3.给定划分r与查询点q,如果元组p可以关于q动态支配r.near,称p完全动态支配r,那么p可以动态支配r内所有的点.如果p可以关于q动态支配r.far,称p部分动态支配r,那么pPage9可能会动态支配r内某些点.证明.r.near是r内在各维上距离q最近的点,所以r.near可以关于q动态支配r内的任意其他点.由于动态支配具有传递性,元组p可以关于q动态支配r.near,则p可以动态支配r内所有的点.同样的,r.far是r内在各维上距离q最远的点.如果元组p可以关于q动态支配r.near,那么p可能会动态支配r内某些点,至少可以动态支配r.far.如图6(a)所示,给定一个划分r,r是r在其他象限的映射,如果元组p落在阴影1中,表示p可以完全动态支配划分r,q可以动态支配r内的所有数据点.如果元组p落在阴影外面,表示p不可能动态支配r内的任意数据点.推论1.给定划分r与查询点q,如果r.far可以动态支配p,称r完全动态支配p,那么落在r内的任意元组都可以动态支配p.如果r.near可以动态支配p,称r部分动态支配p,那么落在r内的元组都不可能动态支配p.证明.由定理3可以很容易的得到该推论.如图6(b)所示,如果元组p落在阴影1中,r完全动态支配元组p,r内所有数据点都可以动态支配p.如果元组p落在阴影2中,表示r内可能存在可以动态支配p的元组.如果元组p落在阴影外面,表示r内的任意元组都不可能动态支配p.(2)元组与元组间的动态支配关系当某个叶子划分r和元组p之间的动态支配关系不能通过定理3和推论1进行判断时,需要进一步拆分叶子划分r,利用倒排索引来判断元组p与叶子划分r内元组之间的动态支配关系,具体方法如下:给定查询点q和数据点p,首先根据p和q的坐标计算出p与q在各个维度上的距离,然后把这些距离值作为限定值,在叶子划分r的d个维度上利用倒排索引结构进行扫描.如果某一个元组p被扫描d次,那么p可以动态支配p;如果元组p被扫描1次到d-1次,那么p与p不能互相动态支配.当某元组p完全没有被扫描到,那么p可以动态支配p.通过倒排索引的采用,依据上述方法,可以完成对叶子划分内的所有数据点的批量处理.如图7中所示,给出查询点q〈0.55,0.65〉和元组p24〈0.7,0.75〉,r1(〈0.5,0〉,〈1,1〉,8)与p24的动态支配关系不能通过定理3和4判定,需要进一步分解r1.p24与q在两个维度上的距离是0.15和0.1,那么在扫描倒排索引时,第1维上与q距离不大于0.15的元组是p1、p2、p8;类似地,第2维上扫描得到的元组是p2、p14.p2被扫描到2次,所以p2可以动态支配p24;p8、p14与p24之间没有动态支配关系,p24可以动态支配r1中的所有其他数据点.根据定理1可知,当p24插入到数据流中后,划分r1的更新将只保留所有被扫描到的元组,删除除p1、p2、p8、p14以外的所有其他元组,并插入p24.4.3基本的数据流上动态轮廓算法BDS2当某一个查询点q被首次提交时,需要进行初始化计算,快速地找到当前滑动窗口中动态轮廓集合;而后,当每次窗口滑动时,需要动态维护数据流上的动态轮廓.4.3.1BDS2的初始化根据定理1可知,在初始化的过程中,不但需要找到当前滑动窗口结果集RS,同时还要保留候选集中的所有点.为了进行划分间的空间过滤,对每个划分r,保留一个最大标签值r.maxlabel用来存储该划分中最晚到达元组的标签.如图2中所示,当元组p1~p23在滑动窗口中时,滑动窗口中的数据的索引可见图3和图4,r0,0,0.maxlabel=22、r0,0,1.maxlabel=21、r0,1.maxlabel=23、r1.maxlabel=16.在BDS2的初始化中,需要维护一个堆H,需要Page10注意的是,堆H中既可以存储划分也可以存储元组,且堆中的每个元素e(划分或元组)都按照函数值f(e,q)由小到大进行排序.f(e,q)=将元素按函数值f(e,q)由小到大进行排序后,根据动态支配的定义,可知排在后面的元素永远不可能完全动态支配排在前面的元素.BDS2初始化过程如下:(1)由分层次划分的根节点开始遍历查找,把根节点的所有孩子划分加入到堆H中并按函数值f(e,q)排序;(2)取堆中首元素e进行处理:①当e是划分时,若被当前结果集中或候选集中的某个元组p完全动态支配,且p.label>e.maxlabel,则删除e(满足定理1和定理3);否则,把e的孩子(孩子划分或元组)加入到堆H中并排序;②当e是元组时,若e不被结果集中任意元组动态支配,把e加入到结果集中;若e被当前结果集中或候选集中的某个元组p动态支配,且p.label>e.label,则删除e(满足定理1);否则,把e加入到候选集中.需要注意的是,由于元素都是按函数值f(e,q)由小到大的顺序进行扫描,所以后扫描元素永远不可能动态支配先扫描元素.算法3.BDS2初始化描述.输入:滑动窗口数据集DN,查询点q输出:当前滑动窗口结果集RS,候选集CS1.初始化H=;//可用来存储划分或元组元素2.把划分根节点的孩子划分加入到堆H中,并按照3.While(H不为空)4.取H的首元素e;5.If(e是划分元素)6.If(e被RS或CS中某个元组p完全动态支配,7.continue;8.ElseIf(e是叶子划分)9.把e中满足定理1的元组全部删除,剩余的10.Else11.把e的孩子划分按顺序插入到H中;12.EndIf13.EndIf14.If(e是元组元素)15.If(e不被RS中元组动态支配);16.把e插入到RS中;continue;17.ElseIf(e被RS或CS中某个元组p动态支配,18.continue;19.Else20.把e插入到CS中;21.EndIf22.EndIf23.EndWhile例1(BDS2初始化).如图2所示,把分层次划分根节点的孩子划分加入后,H={r1,r0}.首先处理r1,把r1中不满足定理1的元组加入到堆H中,得到H={r0,p2,p8,p14,p1,p15,p16}.接着处理r0,得到H={r0,1,p2,r0,0,p8,p14,p1,p15,p16}.依此处理后,最终得到结果集RS={p2,p1},候选集CS={p7,p8,p19,p23}.4.3.2BDS2的更新维护在数据流上动态轮廓维护主要包括两个操作:(1)处理失效元组pold;(2)处理插入元组pnew.通过简单的观测,可以很轻易地得到以下结论.数据流上的待失效元组pold如果没有提前被删除,那么pold只可能属于结果集合.插入数据流的新元组pnew只能属于结果集合或者候选结合.(1)失效元组pold的处理:如果pold属于结果集合,则需要更新结果集,同时将只被pold动态支配的点加入到结果集合中;(2)新插入元组pnew的处理:①根据定理1,把所有被pnew动态支配的数据点删除;如4.2.2小节所介绍的,首先从根节点开始处理,在处理某个划分r时,如果r是中间划分,当r被pnew完全动态支配时,在索引中删除整个r;当r被pnew部分动态支配时,把r的孩子划分加入待处理集合;当r不能被pnew部分动态支配时,跳过不处理r.如果r是叶子划分,利用图7中所介绍的方法,快速地删除r中所有被pnew动态支配的数据点.②如果pnew不被现有结果集合中的点动态支配,把pnew加入到结果集合中;反之,把pnew加入到候选集合中.根据上面两个部分的处理,就可以完成数据流上的动态轮廓的维护.算法4描述了更新维护过程的具体细节.算法4.BDS2更新维护的描述.输入:滑动窗口大小N,查询点q,新插入元组pnew,待Page11输出:更新后滑动窗口结果集RS,候选集CS1.While(有新元组pnew插入到数据流中)2.If(滑动窗口已满)3.删除待失效元组pold;4.If(pold属于结果集合)5.把数据流中只被pold动态支配的点加入到结6.EndIf7.EndIf8.把所有被pnew动态支配的元组删除;9.If(pnew被现有结果集中的元组动态支配)10.把pnew加入到候选集CS中;11.Else12.把pnew加入到结果集RS中;13.EndIf14.EndWhile根据算法4中的第5行可知,当失效元组pold属于结果集时,需要找到所有只被pold动态支配的元组.这里需要检测每一个候选集中的元组,判断其是否被候选集合和结果集中的其他元组动态支配.如果不能,证明该元组只能被pold动态支配.这里的计算代价是O(|CS|×(|CS|+|RS|)×d).在算法第8行中,需要删除所有被pnew动态支配的元组,这里可以采用4.2.2小节中介绍的算法,从分层次划分索引的根节点开始遍历,利用定理3和倒排索引结构进行剪枝计算,从而快速地完成删除过程.根据算法BDS2的更新描述可知,大部分情况下的更新操作都是在短时间内完成.但当失效点pold属于结果集合RS时,算法4的第5行被调用,导致计算时间会急剧增加,计算时的不稳定性使得BDS2不能很好地满足数据流环境.为了更加稳定地计算数据流上的动态轮廓问题,通过设计合理的数据结构,提出了更加稳定的算法IDS2.4.4改进的数据流上动态轮廓算法IDS2为有效避免在处理某些失效元组时开销过大的问题,保证数据流上动态轮廓处理的稳定性,我们给出了改进算法IDS2.在BDS2基础上,对于每个候选元组p,都需要找到能最晚动态支配p的元组p,并把p加入到p的最晚支配集合中(记作p.dDom()).所谓p最晚动态支配p,指的是在可以动态支配p的所有元组中,p是其中最晚到达的元组.如图2所示,当元组p1~p21在滑动窗口时,p21可以被p2,p5,p6,p7,p8,p14,p19动态支配,其中p19是最晚到达的,则称p19最晚动态支配p21,当p21进入到滑动窗口时,需要把p21加入到p19.dDom().根据最晚动态支配的概念,可以得到以下定理.定理4.当失效元组pold属于结果集合时,只被pold动态支配的候选元组一定在pold.dDom().证明.假设候选元组p不属于pold.dDom(),且p只被pold动态支配,由于p是候选元组,一定存在元组p可以动态支配p,且p.label<p.label.又因为p不属于pold.dDom(),所以pold.label<p.label,所以p不是只被pold动态支配.假设不成立,定理4得证.下面介绍给定一个元组p时,如何求出最晚动态支配p的元组.算法5.计算最晚动态支配p的元组LastDom(p).输入:元组p,当前滑动窗口中的集合DN输出:最晚动态支配p的元组1.初始化H=;//可用来存储网格或元组元素2.对于分层次划分根节点的每个孩子划分r,如果r3.H中每个元素e按e.maxlabel(或者e.label)从大到4.While(H不为空)5.取出H的首元素e;6.If(e是划分)7.If(e可以完全动态支配p)8.返回序号为e.maxlabel的元组;9.ElseIf(e可以部分动态支配p)10.If(e是中间划分)11.遍历e的每个孩子划分r,如果r可以部12.ElseIf(e是叶子划分)13.利用倒排索引结构找到可以动态支配p14.EndIf15.EndIf16.ElseIf(e是元组)17.返回e;18.EndIf19.EndWhile20.返回空值;通过算法5的计算,可以找到能够最晚动态支配p的元组,如果返回的是空值,表示没有元组可以动态支配p.例2(最晚动态支配).在图2中,当元组p1~Page12p22在滑动窗口,p23插入时,需要找到能够最晚支配p23的元组.算法BDS2初始化(算法3)后,即删除所有满足定理1的元组后,查询点q需要维护的结构如图8中所示.查找p23的最晚动态支配元组时,首先从根节点开始查找,能部分动态支配p23的划分有r0、r1,得到H={r0,r1}.处理r0时,把r0中可以动态支配p23的孩子划分加入到H中,得到H={r1,r0,1}.进一步处理r1,发现能动态支配p23的元组是p2,得到H={r0,1,p2}.处理r0,1时,可以确定r0,1中不存在能够动态支配p23的数据点,所以最终确定p2是最晚动态支配p23的元组.通过使用算法5,IDS2避免了BDS2算法计算时间不稳定的缺点,进一步提高了算法的性能.该算法的初始化和更新过程描述如下.4.4.1IDS2初始化相比于BDS2,在IDS2的初始化阶段,对于候选集合中的每一个元组p,需要额外计算能够最晚动态支配p的元组p,并将p加入到p.dDom()中.具体过程如算法6所示.算法6.IDS2初始化描述.输入:滑动窗口数据集DN,查询点q输出:当前滑动窗口结果集RS,候选集CS,以及每个1.用算法3计算滑动窗口中的结果集RS和候选集CS;2.For(CS中的每一个元组p)3.p=LastDom(p);4.把p加入到p.dDom();5.EndFor例3(IDS2初始化).在例1中已介绍过,当p1~p23在滑动窗口中时,结果集RS={p2,p1},候选集CS={p7,p8,p19,p23}.对候选集中每个元组,用算法5计算它们的最晚动态支配元组,可得到p2.dDom={p7,p8,p19,p23}.当p2失效时,如果p7,p8,p19,p23没有被加入到删除集合中,那么它们将成为结果元组.4.4.2IDS2的更新维护同算法BDS2类似,IDS2的更新维护同样包括两部分:(1)处理失效元组pold;(2)处理插入元组pnew.具体如下:(1)失效元组pold的处理:把pold.dDom()集合中的元组加入到结果集合中,然后删除pold.(2)插入元组pnew的处理:删除当前候选集合和结果集合中被pnew动态支配的元组;找到最晚动态支配pnew的点p,把pnew加入p.dDom().根据上面的描述,给出算法IDS2的伪代码描述.算法7.IDS2算法的更新维护.输入:滑动窗口大小N,查询点q,新插入元组pnew,待输出:当前滑动窗口的结果集合RS1.While(有新元组pnew插入到数据流中)2.If(滑动窗口已满)3.删除待失效元组pold;4.If(pold属于结果集合)5.把pold.dDom()中的元组加入到RS中;6.EndIf7.EndIf8.把所有被pnew动态支配的元组加入到删除集合;9.p=LastDom(pnew);10.If(p点不存在)11.把pnew加入到结果集中;12.Else13.把pnew加入到p.dDom()中;14.返回现有结果集RS;15.EndWhile根据上面关于算法IDS2的描述,第8行需要判断新插入点pnew和整体维护集合的动态支配关系.第9行利用算法5找到能够最晚动态支配pnew的点.5算法分析下面对本文所提出的算法的计算代价进行了分析,给出了两种算法的时间和空间复杂度.5.1时间复杂度分析(1)初始化过程初始化阶段,算法BDS2需要找到当前滑动窗口上的结果集合RS和候选集合CS.假设元组均匀分布,分层次划分为O(logN)层,算法BDS2初始化过程的计算代价不超过O(logN×(|RS|+|CS|)×d).Page13根据对算法5的分析可知,计算每个元组的最晚动态支配元组的代价不超过O((|RS|+|CS|)×d),算法IDS2初始化的计算代价O((logN+|CS|)×(|RS|+|CS|)×d).(2)更新维护过程当滑动窗口中的元组发生更新时,本文所提出的组合索引结构的更新包括2部分:①从根划分开始,定位更新元组所属的叶子划分.而分层次划分的最深层次一定不超过|CS|/C,所以查找的时间复杂度为O(|CS|×d/C),其中|CS|指的是滑动窗口中剩余的数据个数;②根据定位的叶子划分,判定是否需要合并或分裂,若发生合并或者分裂,那么合并或分裂的时间复杂度为O(C×d).所以组合式索引的最坏更新代价为O(|CS|×d/C+C×d).其中根据定理2可知,|CS|=O(lndN/d!),为了使O(|CS|×d/C+C×d)取最小,我们设C=(lndN/d!以,本文提出的索引结构可以快速地完成在数据流上的更新,它的代价是O((lndN/d!处理失效元组时,如果pold不属于结果集合,算法BDS2和IDS2只需要O(1)次操作;反之,如果pold属于结果集合,算法BDS2要比IDS2复杂得多.BDS2中找到只被pold动态支配的元组的计算代价为O(|CS|×(|RS|+|CS|)×d).在IDS2算法中,处理失效元组pold时,只需要把pold.dDom()中的元组加入到结果集合中,由于pold.dDom()中的元组数目都是常数,所以IDS2算法处理旧元组失效的时间复杂度为O(1).整理后可知,处理失效元组时,算法BDS2的计算代价为O(|CS|×(|RS|+|CS|)×d),而算法IDS2的计算代价为O(1).处理插入新数据pnew时,首先需要删除所有被pnew动态支配的点,最坏情况下,需要遍历q保留的所有数据点,计算代价为O((|RS|+|CS|)×d).接下来算法BDS2只需要判定pnew是否被现有的轮廓集合动态支配,计算代价为O(|RS|×d),所以BDS2处理新元组的时间复杂度为O((|RS|+|CS|)×d).而IDS2需要找到pnew的最晚支配点,最坏情况下,依然是遍历q的保留数据,所以IDS2插入新元组的时间复杂度为O((|RS|+|CS|)×d).根据以上分析,更新维护过程中,算法BDS2的时间复杂度为O(|CS|×(|RS|+|CS|)×d),而IDS2的时间复杂度为O((|RS|+|CS|)×d).5.2空间复杂度分析对于查询点q,BDS2算法需要维护的数据元组个数为|RS|+|CS|,每个元组需要维护d维属性值.同时,算法BDS2还需要对候选集合和结果集合中的元组维护它的组合索引结构,包括分层次划分和倒排索引结构.分层次划分一共需要维护O(logN)个划分,每个划分需要维护2d+2个属性值(包括上下界点、最大标签,子划分内元组个数).倒排索引中需要维护的元组数目仍为|RS|+|CS|.所以,对于每个查询点q,算法BDS2的空间复杂度为O((logN+|RS|+|CS|)×d).对于每个候选元组p,算法IDS2需要计算它的最晚动态支配元组p,并把p插入到p.dDom().由于每个候选元组只存在一个最晚支配点,所有的p.dDom()集合加在一起就是整个候选集大小,所以IDS2算法只需要多维护|CS|个数据元组,IDS2的空间复杂度也为O((logN+|RS|+|CS|)×d).6实验分析6.1实验设置在本小节中,使用VisualC++语言实现了数据流上动态轮廓算法BDS2和IDS2.实验环境为Inteli7-2600CPU@3.4GHz;8MBDDR3内存;1TB硬盘和Windows7操作系统.在本小节中,将本文算法BDS2、IDS2和GDBS[6]以及R-tree算法进行了验证比较.GDBS算法的大体过程已在2.2小节中介绍.其中,R-tree算法是为了专门测试本文提出的混合式索引的效果,所以采用了R-tree索引结构和IDS2的处理框架.本文分别用真实数据和合成数据验证算法性能.真实数据采用的是股票数据①(共包含2×106条股票记录,每条股票记录包含4个属性:交易量、股票涨幅价格、年内最高价和年内最低价).在初始化阶段,滑动窗口大小设为106.实验中随机生成了100个查询点进行了动态轮廓查询,并记录了100次查询的平均处理时间和结果集合大小的平均值.在更新阶段,对每个查询点进行了1000次更新操作,然后记录了每个查询点更新1次的平均时间,以及结果集大小的平均值.真实数据的实验结果如表2中所示.如表2中所示,在初始化阶段,算法IDS2的处理时间略高于BDS2,因为在初始化阶段,IDS2需要计算出候选集合中所有数据点的最晚支配点.由实验可以看出,IDS2计算最晚支配点的速度是非常快①http://finance.yahoo.com/Page14初始化更新的.GBDS算法和R-tree算法的处理时间要远远高于本文提出的算法BDS2和IDS2.因为R-tree索引结构的建立要比本文的组合式索引结构慢.在更新阶段,算法IDS2的平均处理时间要略少于BDS2,因为IDS2算法在处理失效元组时,避免了扫描过程.同时BDS2和IDS2要明显快于算法R-tree和GBDS,因为GBDS算法在处理4维数据时,维护影响区间是非常耗时的.R-tree索引结构的维护时间也远超过组合式索引结构的维护时间.合成数据是由轮廓查询标准测试数据生成器[3]生成的,包括独立、相关和反相关数据集.在相同数据参数下,相关数据分布下获得的轮廓查询的测试效率是最好的.而反相关数据分布下获得的轮廓查询测试效率则是最差的.本文采用的真实数据-股票数据本身并不满足任何分布,但是它的测试效率是处于相关分布和反相关分布之间.图9中分别给出了独立、相关、反相关数据集在2维时的分布情况.(1)独立数据[3]:数据是随机分布的.(2)相关数据[3]:经过点〈0,0,…,0〉,〈1,1,…,1〉可以确定一条直线line,垂直于line的平面有无数多个.首先,按正态分布从这些平面中选取一个平面,新生成的数据点将在这个平面内.通过正态分布来选择平面,可以保证大多数点集中在中间的平面上,而少数点分布在接近〈0,0,…,0〉的〈1,1,…,1〉平面内.接着,在平面内部,每个维度的属性值以平面中心按正态分布来选择.从而可以保证大多数的数据点都接近直线line.在相关分布数据集中,如果元组p在某一维上数值偏“好”(本文里,值越小被认为越好)的话,其他维度上的数值也“较好”.如图9(b)中所示,经过点〈0,0〉和〈1,1〉可以确定一条对角线line,生成的数据点大多数集中在对角线line附近.(3)反相关数据[3]:经过点〈0,0,…,0〉,〈1,1,…,1〉可以确定一条直线line,垂直于line的平面有无数多个,其中最中间的平面记为plant.反相关数据用一个非常小的标准差来选取这些平面,这样选中的平面主要集中在plant附近的,几乎不会集中在两边的平面.接着,在选定的平面内,以均匀分布来生成数据点.生成的数据点都集中在平面plant附近.在反相关分布中,当元组p在某一维上数值偏“好”时,p在其他几维或1维上的数值会“较差”.如图9(c)中所示,2维空间上,经过点〈0,0〉和〈1,1〉确定一条对角线line.生成数据点都集中在经过点〈0,1〉和〈1,0〉的线附近.在独立数据集中,每个元组的数值大小与到达顺序无关;在相关数据集中,元组的数值大小与到达时间呈相关分布,即元组的数值越“差”,到达时间越早;在反相关数据集中,元组的数值大小与到达时间成反相关分布,即元组的数值越“差”,到达时间越晚.反相关数据集是为了测试算法在最坏情况下的性能表现,同时在生活中,这种反相关数据集合的存在是非常普遍的,例如文献[3]中所列举的酒店各维属性分布就满足反相关分布.在实验中,关于子划分约束C的取值,本文给出了以下设定.根据前文的分析,可知关于子划分约束C的取值是一个权衡.C的设定会影响分层次划分的层次和叶子划分的大小.在定位任意元组时,要先找到该元组所属的叶子划分,这里需要消耗的时间为O(|CS|×d/C),而后在叶子划分中进行计算,需要的时间复杂度为O(C×d).根据定理2可知,|CS|=O(lndN/d!),为了使O(|CS|×d/C+C×d)取最小,我们设C=(lndN/d!单元unit,并测试了在不同分布中,C取不同值对算法的影响.合成数据的主要参数变化范围及默认值如表3所示.需要注意的是,滑动窗口的大小就是实验中参Page15与计算的数据的个数.滑动窗口大小(数据集大小)数据维度子划分约束C(unit)滑动窗口流速6.2初始化过程实验评估本小节测试了数据流上动态轮廓查询的初始化部分的性能.当滑动窗口中的数据已满时,随机生成图10窗口大小对初始化过程的影响一个查询点后,记录该查询初始化时的查询时间、结果元组数目和候选元组数目.为了更加稳定地测试算法性能,本文随机生成了1000个查询点,记录的是1000次查询的平均值.图10给出了3种分布下,滑动窗口大小对算法初始化过程的影响.由图10(a)、(c)、(e)可以看出,随着滑动窗口大小的增加,所有算法的处理时间随之线性增加.算法IDS2和BDS2的处理性能明显优于算法GBDS,因为GBDS采用网格索引结构,每次扫描一个网格后需要向23个方向扩展.当数据分布Page16不均匀时,网格索引会导致算法GBDS性能的下降.同时,影响区域的维护是十分耗时的.算法IDS2和BDS2的处理性能也优于算法R-tree,这是由于对比R-tree索引结构,本文所提出的混合式索引结构无论是建立还是维护都要更加方便、快捷.算法IDS2的处理时间与BDS2相比,没有明显区别.因为算法IDS2需要额外计算每个候选点的最晚支配点,但是这部分的耗时是非常少的.由于查询点都是随机分布的,所以3种分布下的处理时间相差并不多.图10(b)、(d)、(f)记录了初始化后,所有查询点平图11维度变化对初始化过程的影响均的结果集大小以及候选集大小.|RS|代表了结果集中元组数目,|CS|代表了候选集中元组数目.随着滑动窗口大小的增加,|RS|和|CS|也随之线性增加.由图中可以看出,滑动窗口大小(数据集大小)为107时,|RS|和|CS|大小相加仅为1000多,即只需要维护1000多个数据点,就可以完成滑动窗口中动态轮廓计算.可以看出,本文提出的算法具有非常高的效率,同时通过层次划分的采用,可以进行批量空间过滤,大大加快了计算速度.图11描述了不同维度对算法初始化阶段性能Page17的影响.随着维度的增加,所有算法的处理时间都是指数级增加的.这主要是因为随着维度的增加,结果集和候选集中的元组数目都是指数级增加的,并且支配计算的时间消耗也会随之增加.由图中可以发现,对于反相关数据,算法所需要的处理时间最长.相关数据中,算法所需的处理时间较短.无论何种分布,算法IDS2和BDS2的处理性能都明显优于算法R-tree和GBDS,因为对于高于3维的数据,GBDS中影响区间的维护是十分复杂的.同时,随着维度的图12子划分约束对初始化过程的影响本小节通过大量的实验验证了在初始化阶段,各种参数变化对算法性能的影响.由实验结果可以看出,无论参数如何变化,本文所提出的算法IDS2和BDS2要明显优于之前的算法GBDS.同时,通过与算法R-tree的对比,可以发现本文提出的组合式索引结构在建立的时候要远快于R-tree索引结构.在初始化过程中,由于IDS2需要额外计算每个候选点的最晚支配点,所以IDS2的处理时间要略高于BDS2,但是这种变化是非常不明显的,因为候选集合不大且最晚支配点的计算是十分快速的.增加,R-tree索引建立的时间明显变长.图12测试了子划分约束C对算法初始化阶段的影响.随着子划分约束C的变化,算法IDS2和BDS2的处理时间基本上不发生变化,因为本文在数据流上处理数据,所有的数据都是存储在内存中的,所以在子划分约束C发生微量的变化时,算法的性能并不受影响.算法IDS2和BDS2可以很快地完成初始化计算.IDS2比BDS2略耗时一些,因为IDS2需要额外计算每个候选点的最晚支配点.6.3更新维护过程实验评估本小节主要验证各个算法在更新维护阶段中的性能表现.具体测试方法如下:对于一个给定的查询点,在完成算法初始化之后,连续记录了1000次更新中平均每次更新操作的耗时、每次更新后结果集和候选集的大小.为提高测量精度,实验中共随机生成了100个查询点,所记录的测量值为100次实验的平均值.图13给出了在3种分布下,滑动窗口大小对算法更新过程中的性能影响.随着滑动窗口大小的增Page18加,所有算法的处理时间也随之线性增加.同时,随着滑动窗口的增大,更新过程中|RS|和|CS|都随之线性增加.由图中可以看出,无论何种分布,本文所提出的IDS2和BDS2在更新时都明显优于算法GBDS.因为本文所提出的算法在更新维护结构时更加简单,而GBDS算法维护的影响区间是非常复杂和耗时的.同时,IDS2和BDS2在更新时都快于算图13窗口大小对更新过程的影响法R-tree,这是由于组合索引结构的维护比R-tree索引要更加快捷.更新过程中,IDS2和BDS2的处理时间相差不大.当失效点属于结果集时,算法BDS2需要较多的时间来处理失效点.所以平均来看,算法IDS2比BDS2的处理效率略高.3种分布中,反相关数据处理最慢,相关数据处理最快.Page19图14给出了在3种分布下,维度变化对算法更新的性能影响.随着维度的增加,所有算法的处理时间都是指数级增加的.因为随着维度的增大,更新过程中|RS|和|CS|都呈指数级增加的,计算维护的代价也是指数级增加的.由图中可以看出,无论维度如何变化,IDS2和BDS2在更新时都明显优于GBDS.因为随着维度的增加,GBDS中影响区域的图14维度大小对更新过程的影响维护开销是十分庞大的.同时,随着维度的增加,IDS2较R-tree算法的优势在不断变强,证明本文提出的组合式索引结构比R-tree结构更加适合在多维上进行维护.更新过程中,IDS2比BDS2的处理效率略高.3种分布中,反相关数据处理最慢,相关数据处理最快.Page20图15给出了在3种分布下,子划分约束C对算法更新过程中的性能影响.随着子划分约束C的变化,IDS2和BDS2的处理时间发生微量变化.IDS2的性能略优于BDS2.在随机数据分布中,当C值为1.1unit时,算法的处理时间最短.在反相关分布中,当C值为1.3unit时,算法的处理时间最短.而在相关分布中,当C值为1unit时,算法的处理时间最短.这是图15子划分约束对更新过程的影响当数据流的流速发生变化时,即一次插入或删除多个元组时,需要对同时插入的元组进行批量处理.对于同时插入的数据元组,只需要处理其中的动态轮廓点,其余元组在插入的时候就可以加入删除集合,不需要处理.由图16可以看出,随着流速的加快,甚至每次插入和删除1000个元组时,本文算法的处理时间仍然在1秒之内.所以说,本文提出的算法可以适应于数据流环境.其中,算法IDS2略好于BDS2,但是非常不明显.同时,在相关数据环境下,算法处理最快,反相关环境下,算法处理最慢.通过对算法IDS2和BDS2的时间复杂度分析可知,当待失效数据点pold属于结果集合时,算法BDS2的处理时间要远大于IDS2.如果待失效数据点已经由于在不同分布中,滑动窗口中的|CS|取值是有差别的.在反相关数据分布中,|CS|取值最大,约为1.3倍的估计值,所以C值为1.3unit时,算法效率达到最优.而在相关分布中,|CS|取值和估计值相近,所以在C值为1unit时,算法效率达到最优.但是,无论何种分布下,算法的处理时间都相差不大,所以我们在3种分布下,默认的C取值都为1unit.提前删除了,算法IDS2和BDS2在此次更新中的处理时间是相当的.在上述的实验中,我们记录的是连续1000次更新的平均处理时间,由于1000次连续更新中,待失效数据点pold属于结果集合的次数并不是很多,所以就平均处理时间来看,两种算法的性能差别不大.下面,为了凸显算法IDS2和BDS2的区别,我们记录了每次更新处理的时间.通过记录单次更新处理的时间,能够更好地反映算法的稳定性.因此,我们选取一个固定的查询点〈0.1,0.1,0.1,0.1〉,进行了3000次连续更新操作,并记录了每次更新的处理时间.其中滑动窗口大小设为107,维度设为4,其他参数均为默认值.图17给出了在3种分布下,算法IDS2和BDS2Page21图16数据流流速对更新过程的影响在更新过程中的性能表现.由图中可以看出,无论何种分布下,IDS2比BDS2的性能表现要稳定很多.如图17(b)中所示,当滑动窗口连续流入1000个元组的时候,需要进行1000次的删除插入操作,我们记录了每次更新操作需要的响应时间,平均的响应时间约为50ms.其中,有很多次的更新操作,算法BDS2的响应时间要大于100ms,远超过平均响应时间.而算法IDS2的响应时间最多不超过80ms.由此可知,处理相同的数据集合时,两种算法的平均响应时间基本相同,但是IDS2响应时间的波动要远小于BDS2的波动.所以说,IDS2比BDS2稳定的多.在相关数据分布中,失效点成为动态轮廓的概率较小,所以算法BDS2在相关数据中的表现最好,IDS2与BDS2的性能相差不是很大.在反相关数据分布下,失效点成为动态轮廓的概率明显增大,所以在算法BDS2中,频繁出现单次更新操作耗时明显高于均值的情况,相比之下,IDS2非常稳定.通过上述大量的实验,验证了本文所提算法BDS2和IDS2的正确性以及高效性,无论参数如何变化,本文所提出的算法都明显优于现有算法,可以满足人们的日常需求.7总结本文对数据流上的动态轮廓查询问题进行了深入的研究.首先,提出了一种组合式索引结构来管理数据流上的点.该索引包括两个部分:分层次划分结构;子划分内的数据元组采用倒排索引结构来管理.通过分层次划分结构,可以实现数据集的空间过滤,同时使得本文所设计的索引结构可以适用于所有的数据分布中;利用倒排索引结构,可以快速地完成元组间动态支配关系的判定,并且可以对子划分内的数据进行批量处理.然后,在该组合索引结构的基础上,提出了基本动态轮廓查询算法BDS2.但是,当失效元组属于动态轮廓集合时,BDS2需要重新计算整个候选集,会导致BDS2在处理某次更新操作时,引起较大的延迟.为了在数据流上更加稳定地计算动态轮廓,本文提出了改进的动态轮廓查询算法IDS2,通过设计合理的数据结构,有效避免了数据流上动态轮廓查询算法时的延迟,保证了数据流查询算法的稳定性.最后,通过大量的对比实验,验证了本文所提算法的有效性和高效性.Page22图17更新时各算法性能表现
