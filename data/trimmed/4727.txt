Page1基于外存后缀树的top-犽局部比对算法王斌朱睿杨晓春王国仁于戈(东北大学信息科学与工程学院沈阳110004)摘要局部比对是一种衡量字符串间相似程度的技术,它在生物信息学领域具有十分重要的作用.介于此,许多学者已对其进行了深入的研究.然而,随着数据规模的扩大,常规的内存算法已不适用于支持大规模文本数据的局部比对.为解决上述问题,该文研究了基于外存后缀树的top-k局部比对算法.它从根本上消除了内存空间对算法的束缚.为了提高算法的性能,该文首先将经典内存算法中的过滤策略引入该文.通过适当的修改,这些策略可以基于外存后缀树有效地降低计算开销.其次,该文提出一种巧妙的算法支持top-k局部比对查询.该算法通过引入启发式策略有效规避了TA算法的固有问题.具体地,它一方面可以提高算法的过滤能力,另一方面可以降低候选对象的维护代价.再次,该文对外存后缀树和磁盘的工作原理进行了研究.基于此,该文提出一种槽的结构支持查询.该结构既可以实现磁盘的顺序访问,又可以降低磁盘的访问次数.因此,它可以有效提高算法的查询效率.最后,大量的实验验证了该文所提出算法的有效性.关键词局部比对;top-k;外存后缀树;叉子区域1引言局部比对是在两条文本串之间寻找近似子串的过程.它在生物信息学领域具有重要应用[1-2].具体来说,它有助于研究人员分析不同基因片段的功能,确定它们在遗传学上的意义[3-4].和常规文本数据相比,基因数据的规模较大.常规PC机的内存往往无法容纳这些数据[5-8],更无法容纳以这些字符串为基础构建的索引①.因此,在对基因数据执行局部比对时,传统的内存算法往往无法在单机环境下使用.针对内存不足等问题,分布式算法[9]和外存算法是两种流行的解决方案.对于前者而言,由于它对硬件的要求较高且不易维护,当实时性不是算法的第一考虑要素时②,它未必适用.相反,由于外存算法对硬件的要求较低且易于维护,它适合在生物序列比对技术中使用.因此,研究局部比对的外存算法具有十分重要的现实意义.计算机的外存访问主要由两部分组成:磁道寻址和数据读写.由于外存的机械特性,前者的代价远远大于后者.换句话说,磁盘访问的高昂代价主要由磁道寻址引起.显然,如果外存算法能对磁盘执行顺序读取,它的访问代价就会急剧下降.研究结果表明,当磁盘执行顺序访问时,它的读取效率甚至高于内存的随机读取效率[9].由此可见,外存算法的研究焦点大多集中在:(1)减少磁盘访问次数;(2)尽可能地执行顺序访问.如果上述两点能够满足,外存算法不仅可以消除数据规模对算法的约束,而且可以打破I/O操作带来的瓶颈.现如今,许多问题的外存算法都已被深入研究.在文本管理领域,外存后缀树作为一种高效索引结构,十分适用于管理大规模文本数据.其主要原因是后缀树是可分解的.这样一来,算法可以自适应加载不同子树.因此,基于外存后缀树实现字符串间的局部比对是一种可行的方法.本文基于外存后缀树研究字符串间的top-k局部比对问题.给定原串T,查询串P和评价字符串间相似度的打分函数F,该问题要求返回T,P之间相似程度最高且彼此之间不存在支配关系的k对子串.为了达到此目的,当查询串P到来时,查询算法依次从磁盘中读取后缀树先遍历找到参与局部比对的子串、计算比对结果,维护候选集中分值最高且不被支配的对子串.当遍历完成时,算法将候选集作为查询结果输出.为了提高算法的效率,本文需要面对以下挑战:(1)找到适用于外存环境的过滤策略.近年来,基于内存的局部比对算法已被深入研究.然而,它们的过滤策略都是在内存环境下实现的.开发适用于外存环境的过滤算法是第1个需要客服的难点.(2)选取合适的阈值.和基于阈值的局部比对算法相比,基于top-k的局部比对算法无法提供过滤能力强的阈值,这会导致算法的运算速度降低.因此,本文面临的第2个挑战是找到过滤能力强且保证不丢解的阈值从而提高算法性能.(3)减少I/O代价.由文献[10-12]可知,由于局部比对算法需要频繁对原串T执行随机访问,它会导致算法多次访问磁盘.因此,本文面临的第3个挑战是找到迎合磁盘工作原理的算法从而降低I/O代价.为克服上述挑战,本文贡献如下:(1)高效的过滤策略.本文首先针对外存后缀树的特点进行分析.基于此,本文结合文献[8]中的过滤策略(例如:长度过滤、支配关系过滤等)加速局部比对计算.实验表明,这些过滤策略不仅降低了局部比对计算次数而且适合在外存环境下使用.(2)高效的候选集维护算法.本文首先利用启发式策略找到合适的阈值.该阈值保证在不丢解的前提下提供较强的过滤能力,从而降低候选集的维护次数.当候选集需要被维护时,本文近一步利用散列表维护候选对象间的支配关系.它可以在常数时间内找到并移除候选集中的非候选对象.(3)高效的外存算法.一方面,本文根据外存后缀树的工作原理挑选访问频率高的子串常驻内存.另一方面,本文提出一种批处理算法实现磁盘的顺序读取.显然,上述两种策略一方面降低了磁盘的访问次数,另一方面减少了随机寻址次数.它们均可以有效降低I/O代价.本文第2节概述背景知识;第3节介绍基于外存后缀树的top-k局部比对算法;第4节进行有效性实验分析;第5节对全文进行总结.①②③Page32准备工作在介绍问题定义之前,表1首先定义一组符号.符号T[i](或P[i])T[i,j]P[i,j]ALC(t,p)|ALC(t,p)|ALC(is,js,ie,je)基于T[is,ie],P[js,je]得到的局部比对s(a→b)2.1背景知识2.1.1相似度评价函数给定字符串r和s,F(r,s,间相似程度的打分函数.其中,需的操作集合;通常情况下,匹配(简称sa),替换(简称sb),插入和删除.给定字符串r和s,如果r[i]=s[i],则称两者在位置i上匹配.在一系列匹配或替换操作之后,本文将第1个插入或删除操作称为Gap开启(简称sg).在Gap开启位置及其之后的连续插入或者删除操作称为Gap扩展(简称ss).图1解释了字符串间相似度的计算方法.其中,实线表示匹配操作;虚线表示替换操作;其余部分表示Gap开启或Gap扩展开启.图1共有10次匹配、4次替换、2次Gap开启和4次Gap扩展开启.假设图2字符串T=“AGCCAGAT”的后缀树匹配操作对应的分值为1,其余操作对应的分值都为-1,r和s的相似度为10×1+4×(-1)+2×(-1)+4×(-1)=0.2.1.2外存后缀树给定字符串T,它的后缀树所有后缀的树状结构[11-12].图2(a)为字符串T=“AGCCAGAT”对应的后缀树符为起点的后缀Ssur,它都可以从根节点到某叶子节点组成的边上得到.例如:字符串T包含两个以G为起始点的后缀串,它们分别是“GCCAGAT”和“GAT”.为了降低后缀树的空间代价,Manber等人[13-19]提出一种压缩算法.它用字符串的概要信息对原串进行管理.以节点2和7之间的边为例,在图2(a)中,这条边上存储的字符串s=“AGAT”.为了对它进行压缩,在图2(b)中,存储算法将边上的内容变为A[4,7].它的含义为s的首字符为A,它在原串中的起始和终止位置分别为4和7.由于后缀树的规模较大,许多学者对外存后缀树进行了研究.主流算法通常把原串T的一部分加载到内存,而另一部分存放在磁盘上.给定原串T和它对应的后缀树在内存中,访问算法直接从内存读取子串.否则,算法需要从磁盘读取原串的相应内容.为方便叙述,本文用存;||表示a,b两节点边上对应的字符串.图2(b)所示,假设||=4、s(5→11)时,因为它索引的子串不在内存中,所以这Page4会引发一次磁盘操作.相似地,当算法完成遍历后,磁盘操作次数为11.由上述观察可知,当T无法完全装载到内存时,遍历后缀树会频繁引发磁盘操作.其根本原因是后缀树相邻边上保存的子串在原串T中的位置往往较远.2.2问题定义在讨论了背景知识后,本文介绍关于局部比对的相关概念.定义1(局部比对计算).给定字符串r∈T和s∈P,局部比对计算(简称:ALC(LocalAlignmentCalculation))是利用评价函数F(r,s,者相似程度的过程.定义2(最优局部比对计算).给定串r∈T和s∈P之间的最优局部比对是使函数值F达到最大的局部比对操作序列.为了方便描述,给定原串T和查询串P,本文用ALC(t,p)表示子串t∈T,p∈P之间的最优局部比对;|ALC(t,p)|表示最优比对结果对应的分值.定义3(局部比对的支配关系).给定子串p1,p2∈P,t1,t2∈T,如果它们满足:(1)t1[|t1|-1],t2[|t2|-1]在T中的位置相同;(2)p1[|p1|-1],p2[|p2|-1]在P中的位置相同;(3)|ALC(t1,p1)||ALC(t2,p2)|,本文称ALC(t1,p1)支配ALC(t2,p2)(记作:ALC(t2,p2)ALC(t1,p1)).问题定义1(基于阈值的ALC)(简称T-ALC).给定原串T、查询串P以及分数阈值H,基于分数阈值的ALC返回T,P子串之间局部比对分值不小于H且彼此之间不存在支配关系的子串对.问题定义2(基于top-k的ALC)(简称K-ALC).给定原串T、查询串P以及正整数k,基于top-k的ALC返回T,P子串之间局部比对分数值最高且彼此之间不存在支配关系的k对子串.2.3相关工作局部比对是一种衡量字符串间子串相似程度的方法[20-26].和全局比对相比,局部比对具有更重要的实际意义,因此它也受到学者的更多关注.Smith-Waterman算法[2]是基于分数阈值的局部比对算法.该算法的最大贡献是将局部比对问题转换为动态规划问题.具体地,给定原串T和查询串P,该算法分别计算T和P中任意两个子串间的最优局部比对结果.由文献[2]可知,因为任意两个子串的最优局部比对结果依赖于它们子串间的最优局部比对结果,所以该问题的最优解依赖于更小规模子问题的最优解.因此,该问题可以使用动态规划算法进行解决.它的时间复杂度为显然,当文本数据的规模较大时,Smith-Waterman算法的运行效率有待提高.OASIS(OnlineandAccurateSearchtechniqueforInferringlocal-alignmentsonSequences)算法是Meek等人[27]于2003年提出的.与Smith-Waterman算法相比,它做出以下改进:(1)它为原串T建立后缀树从而避免了重复计算问题;(2)为每个搜索节点维护一个长度为了比对计算.它的缺点是只适合在查询串较短时使用.GPU算法是由Salavert等人[27]提出的.它通过使用BWT(Burrows-WheelerTransform)索引反向搜索原串中出现的子串.该方法可以模拟基于后缀树的局部比对计算过程.ALAE(AcceleratingLocalAlignmentwithExactlyAffineGap)是Yang等人[8]提出的.它是以GPU算法为基础进行研究的.与之不同的是,该算法提出了多种过滤和复用策略以减少不必要的计算开销.3算法描述本节讨论了基于外存后缀树的局部比对算法.首先,本文在3.1节提出了研究框架ESF(ExtendSuffixFramework).接下来,本文在3.2节提出算法ESLA(ExtendSuffixLocalAlignment)解决基于外存后缀树的T-ALC(基于阈值的ALC)问题.以此为基础,本文在3.3节近一步研究了top-k局部比对算法.最后,本文在3.4节提出了一系列外存优化算法降低I/O开销.3.1基于外存后缀树的算法框架本节提出框架ESF(ExtendSuffixFramework)支持基于外存后缀树的局部比对计算.本文使用后缀树作为文本索引的原因如下:(1)基于公共前缀的索引方式.后缀树可以将原串中不同的后缀按照其公共前缀进行索引.基于该性质,算法在执行ALC时,不同子串的公共前缀只需计算一次.因此,它可以减少冗余的计算量;(2)自适应于内存空间.虽然后缀树是一种全文索引结构,但是它可以被划分成许多子树.基于这个性质,ESF可以根据内存容量自适应地选择某些子树读入内存.因此,后缀树适于在外存环境下支持字符串间的ALC操作.如图3所示,ESF主要由两部分组成.第1部分Page5是关于原串T和后缀树ESF分别将后缀树子串放入内存(图中的黑色部分).当查询串P到来时,ESF根据查询类型和操作类型分别调用ESLA算法,ESLAk(基于top-k的ESLA)算法和ESBR(ExtendSuffixBatchRead)算法.ESLA算法可以在外存后缀树上解决T-ALC问题.给定原串T、查询串P、后缀树子树s,ESLA在遍历过程中根据行ALC操作并返回满足查询条件的结果.需要强调的是:ESLA克服了如下挑战提高计算效率:(1)引入ALAE中的多种局部过滤策略,并使它们与后缀树有机结合;(2)引入ALAE中提出的叉子区域.以此为基础,ESLA基于叉子区域的支配关系①进一步加强了算法的过滤能力.以ESLA算法为基础,本文近一步提出ESLAk算法解决K-ALC问题.为了克服TA(ThresholdAlgorithm)算法的固有问题和衍生问题②,本文引入启发式算法寻找合适的阈值.基于该阈值,ESLAk算法可以快速地过滤中间结果.此外,ESLAk提出一种巧妙的数据结构维护候选对象.它的好处是可以高效维护候选结果间的支配关系,从而降低维护代价.最后,ESF提出算法ESBR(ExtendSuffixBatchRead)优化外存操作.它是基于以下研究动机提出的:(1)后缀树相邻边上保存的子串不满足局部性原理.在很多情况下,它们在原串中的位置相距很远;(2)后缀树边上只保存子串的概要信息且ESF只能在内存中保留T的一个子串,ESF需要多次访问磁盘加载目标子串.由于该操作代价较高,算法必须谨慎选择读入内存的原串从而避免频繁的I/O操作.为了达到这个目标,算法根据后缀树的性质提出以下两个优化策略:(1)选择原串中访问频率较高的子串常驻内存.由大量观察可知:给定原串T和其对应的后缀树前半部分.因此,ESBR尽可能将T的前部常驻内存;(2)基于批处理的磁盘操作.本文提出了一种延迟读取策略.该策略的核心思想是缓存涉及I/O操作的子串.当此类子串的数目到达上限时,算法根据这些子串在磁盘中的位置规划出最优的搜索顺序.由前文可知,磁盘的顺序读写有着较高的效率.本文的延迟读取策略恰好迎合了这一特性.此外,由于排序后子串在原串中位置往往相近并且ESBR是以块③为单位读取数据,这些子串经常会出现在同一块中.因此,这种批处理方法可以近一步地降低I/O访问次数.3.2计算局部比对的过滤策略在外存环境下执行T-ALC时,一种简单的方法是使用Smith-Waterman算法.它可以通过矩阵运算得到局部比对结果.然而,该算法的时间代价较大.为了提升效率,本文提出了ESLA(ExtendSuffixLocalAlignment)算法加速计算.一方面,该算法借助外存后缀树实现了ALAE算法中的几种局部过滤策略.另一方面,ESLA根据局部比对结果间的支配关系近一步加强了算法的过滤能力.3.2.1基于阈值的局部过滤策略使用外存后缀树执行ALC操作时,ESLA的整体思路是从外存中依次读取后缀子树,遍历这些子树,得到子树边上对应的子串,执行ALC操作.对于任意后缀而言,因为它都可以通过一次深度优先遍历获得,所以提高ESLA性能的一个有效途径是缩短它在后缀树上的遍历范围.本文首先通过引入ALAE中的几种局部过滤策略降低遍历代价.它们包括长度过滤、前缀过滤和分数过滤.本文首先讨论长度过滤.引理1.给定查询串P、原串T、子串t∈T和分数阈值H,如果t是比对结果,它的长度需要满足不等式H/samax{m,n+(H-sa×m+sg)/ss}.其中|t|为t的长度.证明.对于|t|的下限,因为分数阈值为H,即使t中所有字符均与P中对应字符匹配,|t|也不能小于H/sa.对于|t|的上限,它的含义是ALC中有m个连续的匹配操作,其余的为Gap操作.为了满足分数阈值H的要求,Gap操作的次数需要控①②③Page6制在(H-sa×m+sg)/ss以内.因此,|t|不能大于max{m,m+(H-sa×m+sg)/ss}.根据引理1,长度过滤可以减少一些不必要的局部比对计算.以此为基础,本文提出定理1.它帮助我们缩小深度优先遍历的范围.为了方便说明,给定根节点r、非叶子节点ein,本文用|s(r→ein)|表示s(r→ein)上维护的子串长度之和;用e表示s(r→ein)上子串在原串中索引位置的终点值;用Lmin表示长度过滤的下限值.定理1.给定后缀树ein满足不等式:Lmin|T|-e+|s(r→ein)|,则它的子孙在深度优先遍历时可以被剪枝.证明.给定原串T和它对应的后缀树上索引的子串是它在T中出现最早的位置.给定ein的父节点pin和它们之间的边s(pin→ein),如果s(pin→ein)上存储子串的终止位置为e,则从ein到其任意子孙对应边上索引的子串长度不会超过|T|-e.根据长度过滤,用来比对的T的子串长度必须不小于Lmin,假设从根节点与某内节点之间边上的子串长度为|s(r→ein)|,则仍然需要Lmin-|s(r→ein)|个字符才符合要求,也就是说如果内节点不满足关系|T|-eLmin-|s(r→ein)|,继续访问其子孙节点是没有意义的.利用定理1,本文可以在后缀树上实现长度过滤.除此之外,本文使用分数过滤加速比对计算.具体地,给定子串t∈T,p∈P,如果ALC(t[0,i],p[0,j])0,计算|ALC(t,p)|0是无效的[8].由于这种过滤策略不依赖于后缀树,本文不再叙述它的使用方法.接下来,本文讨论前缀过滤.给定子串t∈T和p∈P,前缀过滤的核心思想是根据t和p的前q个字符进行过滤.具体地,如果T[0,q-1]≠P[0,q-1],则ALC(t,p)可以提前结束.其中,q=min{|sb|,|sg+ss|}/sa+1;sa表示匹配操作;sb表示替换操作.为了实现前缀过滤,本文为查询串P建立了q长子串的倒排索引中子串的q长前缀在P中的起始位置.显然,ESLA从这些位置开始计算就可以得到比对结果.综上所述,上述3种局部过滤策略易于在后缀树上实现.通过引入这些过滤策略,ESLA可以有效降低计算代价.接下来,本文介绍基于支配关系的过滤技术.3.2.2基于支配关系的全局过滤策略由问题定义2.1可知,局部比对问题不仅要求比对结果的分值不小于阈值H,而且要求比对结果之间不存在支配关系.本节首先引入叉子区域的概念.其次,本文基于叉子区域提出基于支配关系的过滤算法.叉子区域是根据前缀过滤和分数过滤形成的.给定局部比对ALC(t,p),如果它不被过滤,它一定满足以下条件:(1)t,p之间的公共前缀长度大于q-1;(2)ALC(t,p)0.如图4所示,局部比对的计算区域在形状上可以看成是一个叉子[8].在这里,EMR代表准确匹配区域;NGR代表不存在Gap操作的区域.X表示一条子串.近一步,根据叉子区域,算法可以找到比对结果间的支配关系.为了便于描述,本文用叉子表示两子串间的局部比对计算区域.ALC(is,js,ie,je)表示基于T[is,ie]、P[js,je]得到的最优局部比对结果.定义4(叉子区域间的支配关系).给定子串T[is,ie]∈T,P[is,ie]∈P和它们形成的叉子区域A,如果ALC(is,js,ie,je)>0且T[ix,ix+q-1]=P[jy,jy+q-1],则AxA,其中ix∈[is,ie];jy∈[js,je];Ax表示起始点为ix,jy的叉子区域.根据定义4可知,如果叉子区域Ax的起始位置包含于叉子区域A,则AxA.实例1.图5演示了两个叉子区域的支配关系.图中X和Y分别表示T[is,ie]和P[js,je].T[is,ie]和P[js,je]的局部比对计算区域是叉子区域A,它的起始位置有q个匹配操作.在叉子区域A的位置(ix,jy)处,虽然T[ix,ix+q-1]=P[jy,jy+q-1],ESLA可以在(ix,jy)处开辟新的叉子Ax,但Ax中参与局部比对的子串是A中参与局部比对的子串后缀.假设基于A和Ax得到的最终叉子区域分别为A(is,js,ie,je)和Ax(ix,jx,ie,je),因为A(is,js,ie,je)=A(is,js,ix,jx)+Ax(ix,jx,ie,je)且A(is,js,ix,jx)>0,所以Ax(ix,jx,ie,je)<A(is,js,ie,je).由此可知,计算Ax是没有意义的.根据如上描述,如果ESLA在开启一个叉子区Page7域前判定它是否被支配,ESLA可以减少很多不必要的计算.由上文可知,判断一个叉子区域是否被支配的先决条件是判断其是否包括在另一个已计算的叉子区域中.为了达到这个目的,ESLA需要维护结果间的支配信息.它的难点是随着结果数量的逐渐增多,ESLA需要维护的叉子个数也会增多.一个简单的策略是缓存所有的“q匹配操作”.它指的是在计算某个叉子区域的过程中,一旦碰到连续q个匹配操作,ESLA就将匹配的起始位置记录下来.当开始计算新的叉子区域时,ESLA查询起始位置信息是否被包括.如果是,此次ALC可以被过滤.然而,该策略存在的问题是需要保存许多历史记录.为了解决上述问题,本文首先提出q-prefix的概念.随后,本文基于q-prefix的字典序提高计算效率.具体地,给定q-prefixq1和q2,如果q1的字典序小于q2的字典序,ESLA优先计算与q1相呼应的叉子区域.定义5(q-prefix).给定叉子区域A和它们对应的子串T[is,ie]∈T,P[is,ie]∈P,本文将T[is,ie]中前q个匹配操作称为q-prefix.具体地,在计算某个局部比对的过程中,当遇见连续q个匹配操作时(不包括起始位置的q-prefix),ESLA比较该子串和其他q-prefix的字典序.如果该子串具有更大的字典序,ESLA则储存该位置信息.基于这种方法,本文可以判定哪些叉子区域已被计算(或未被计算).图6是一个ALC中遇到连续q次匹配操作的示意图.根据图中的分数策略,q=4.图中的q-prefix是字符串“ACGT”,在局部比对过程中,ESLA遇到了其他q-prefix“CAGT”和“AAAA”.因为C的字典序大于A,所以“CAGT”的字典序大于“ACGT”;ESLA可以判定以“CAGT”开始的叉子区域未被计算.因此,ESLA将其对应在原串T和查询串P中的出现位置保存起来.相反,因为“AAAA”的字典序小于“ACGT”,这意味着以“AAAA”开始的局部比对已被计算;再记录其出现位置是没有意义的.因此,“AAAA”不被保存.需要强调的是,出于空间效率考虑,ESLA不保存q-prefix的位置信息.因此,该策略可能会导致一些冗余计算.当开始计算一个新的叉子区域时,ESLA首先检查起始位置是否已经被保存.如果是,ESLA可以判定该叉子区域已被计算.进而,ESLA可以推断该区域已被支配.在这种情况下,ESLA过滤该叉子区域.需要强调的是,那些保留的被支配的叉子区域的起始位置是按照其q-prefix进行组织的.给定一个新的q-prefixqnew,上述策略的好处是当开始计算以qnew为起始的叉子区域时,ESLA可以释放字典序小于qnew的被支配叉子区域的起始位置,从而提升算法的存储空间利用率.除此之外,本文在3.3节提出了一种巧妙的数据结构维护候选对象之间的支配关系.这种算法也适于在本节使用.最后本文对ESLA算法的时间复杂度进行分析.这里,设数据构建在外存的索引大小为I,内存块大小为Is,一次遍历外部索引的最坏代价是每个块在内存中的计算代价可以借助文献[8]中定理4的分析结果,算法在内存中的计算代价是Page8(k/k2-1+k1σ2/σ-k2)|P||T|logk2.其中,k1=(1-1/s)(σ-1/σ-2)(s/2∏(s-11/(s-1)s-1)1/s,s=1+|sb|/|sa|,σ是字符集的个数.从而,本文可以得出ESLA在整个数据集上时间复杂度等于3.3基于top-犽的局部比对算法在讨论了基于阈值的局部比对问题之后(T-ALC),本节根据上节的研究结果讨论基于top-k的局部比对问题(K-ALC).由问题定义可知,它返回分值最高且彼此间不存在支配关系的k个结果.为了解决该问题,本文提出ESLAk(基于top-k的ESLA算法)算法.该算法以ESLA中的过滤策略为基础,结合TA算法维护候选集合.给定原串T、查询串P和候选集来,ESLAk在访问T的过程中将满足查询条件的比对结果r插入r①;(2)r不被条件,ESLAk将r插入地,在插入之后,如果||=k+1,ESLAk丢弃min(对于第一个插入条件,ESLAk面临的挑战是“小阈值”问题.具体地,由于初始化状态下算法只能将min(低,它会带来以下影响:(1)前文讨论的过滤算法很难被使用;(2)在算法运行初期,很多分值较小的比对结果也会加入候选集.在大多数情况下,它们都会被后加入的比对结果代替.显然,存储这样的对象是没有意义的.总体来说,“小阈值”问题会消耗不必要的计算资源.因此,提高ESLAk性能的关键是找到合适的阈值H代替min(本文使用启发式算法初始化H.由前文可知,在评价函数F(P,T,配操作对ALC贡献正分数,也就是说只有通过匹配操作才能够提高ALC的分值.根据上述观察,本文首先找到k个不相交且具有最长前缀的子串对.接下来,本文基于这k个子串对执行比对计算.近一步,本文用这些子串对间的比对结果初始化然,此时的min(应地,第1个问题可以被解决.在初始化滤策略加快局部比对.然而,ESLAk需要面临第2个挑战:它需要额外判断新得到的比对结果是否被中元素支配.其根本原因是在T中的各个位置,ESLAk无法像ESLA一样在扫描的过程中维护结果间的支配关系.为了解决这个问题,ESLAk使用桶结构希表表的存储示例图.图7的下半部分为哈希表每项元素e包含两部分内容.第1部分是关键字,它存储某一局部比对结果的结束位置.第2部分是二元组〈pt,F(e)〉.其中,pt指向e在F(e)表示e的局部比对分值.图7的上半部分刻画了桶的.其中,具有相同分值的局部比对结果会被存储在同一个桶中.ESLAk基于的局部比对结果r到来时,ESLAk访问的目标插入位置Ir执行如下操作.(1)Ir=.这说明r既不支配中元素支配.在这种情况下,ESLAk将r插入Ir.与此同时,ESLAk更新阈值H.和(2)Ir≠且Ir中存在分值小于F(r)的元素.这说明r支配首先通过Ir.pt定位r支配的元素rd.其次,ESLAk用r替换rd.(3)Ir≠且Ir中不存在分值小于F(r)的元素.这说明r被Ir中的元素支配.在这种情况下,ESLAk直接丢弃r.综上所述,ESLAk通过两方面的优化提高了计算效率.第一,ESLAk使用启发式策略找到k个分①min(Page9值较大的比对结果.通过这种方法,ESLAk可以有效解决“小阈值”问题.第二,算法使用桶维护候选对象.借助它们,ESLAk可以快速识别新的比对结果是否被候选集中的元素支配.3.4外存访问优化策略前文研究的焦点是在内存环境下优化基于后缀树的过滤算法.然而,后缀树只索引子串的概要信息并且ESF只将T的部分子串保存在内存,当待访问的子串不在内存中时,算法需要从外存中读取数据.此外,因为后缀树边之间存储的子串在T中不是连续的,所以磁盘读取操作将会频繁发生.显然,这会导致算法的性能降低.基于上述观察,本节提出ESLA算法优化外存的访问.为了达到这个目的,本文从以下两个方面入手:(1)对T中各部分子串被访问的频率进行研究.基于研究结果,本文挑选一部分访问频率高的子串常驻内存;(2)找到一种可以迎合磁盘工作特性的访问算法.该方法可以通过实现磁盘的顺序访问提高磁盘的读取效率.显然,上述两种方法可以有效降低外存访问代价.3.4.1后缀树访问特性的分析给定原串T和它对应的后缀树的边分为两种:(1)内边;(2)叶边.其中,内边表示中间节点之间的边;叶边表示中间节点和叶子节点之间的边.通过观察各类边上索引的子串特征,本文得到如下关于字符串T和其对应后缀树的特性:特性1.大多数情况下,内边上索引的子串出现在T的前部;特性2.大多数情况下,内节点间边上索引的字符串长度较短.第1个特性是根据后缀树的构造过程得到的.具体地,后缀树边上索引的内容为T中的最早出现的字符串[22].这种表示方法使得内边上索引的字符串大多出现在原串T的前半部分.例如,给定长为2MB老鼠基因和以此为基础构建的后缀树,超过86%内边上索引的子串出现在原串的前部.因此,选择原串的前部常驻内存可以降低磁盘的访问频率.第2个特性是根据后缀树的工作原理得到的.因为后缀树根据子串的公共前缀索引T的各子串,所以后缀树上的大多数内边包含的子串长度较短.原因如下:如定理2所示,给定随机生成的字符串R和它的两个后缀r1,r2,因为r1,r2之间存在长公共前缀的概率较小,对于大部分子串而言,它们的公共前缀都是较短的.定理2.给定随机生成的字符串R和它的两个后缀r1,r2,Pr(r1[0,d]=r2[0,d])=1/|Σ|d.证明.给定任意r1[i]和r2[i],Pr(r1[i]=r2[i]等于1/|Σ|.因为Pr(r1[i]=r2[i])与Pr(r1[j]=r2[j](i≠j)可以看成独立事件,所以Pr(r1[0,d]=r2[0,d]=1/|Σ|d.3.4.2外存操作优化技术由前文可知,当对后缀树进行遍历时,如果边上索引的子串不包含在内存中,ESLA需要从磁盘中读出相应的部分.显然,外存访问策略对于ESF的整体性能有很大的影响.本文提出算法ESBR.它根据上节提到的两种性质优化ESF.根据特性1,ESF尽可能将原串的前部留在内中.除此之外,本文提出了一种批处理算法降存低I/O代价.首先本文给出溢出的概念.定义6(溢出).给定后缀树和它索引的子串t,如果t不完全包含在将这种情况称为溢出.回顾2.2节对后缀树的描述,因为后缀树相邻边之间索引的子串不具有局部性,所以相邻的后缀在原串中的位置可能相距很远.因此,在遍历后缀树时,溢出事件会频繁发生.显然,算法会因此消耗大量的磁盘寻址代价.基于上述观察,本文提出一种批处理算法解决频繁溢出带来的问题.其中,特性2保证了该算法的可行性.具体地,当溢出发生时,ESLA将当前进行的ALC中间结果存入缓冲区并推迟外存读取时间.由文献[7-8]可知,因为需要保存的中间结果主要是动态规划矩阵的一行,所以保留这些中间结果需要花费较大的存储空间.接下来,本文使用上节提到的特性2降低存储代价.根据上节描述,大多数内节点索引的字符串长度相对较小.如果溢出事件发生在内边,计算过的动态规划矩阵的行数往往较少.在这种情况下,ESLA如果访问到发生溢出的内边便停止访问,需要保存的字符串长度也会相应变小.显然,同保存完整的中间结果相比,该策略可以有效节省存储空间.显然,特性2可以帮助ESF花费相对较少的空间存储中间结果.然而,如果溢出发生在叶边,ESF需要采用相似的操作策略.和内边相比,叶边发生溢出的频率更高且需要保存的中间结果也越多.因此,这些中间结果需要更为合理的管理算法.根据上述讨论,本文将内存Page10d.其中,1]).与了方便对这些零散的字符串进行管理,ESBR提出了一种槽(shot)结构管理这些数据.定义7(槽).给定散列表{e0,e1,…,en},任意元素ei对应于一个元组〈keyi,si〉.其中,keyi为键值,si为一个数组.通常,它被其称为槽.具体地,ESBR以槽为单位与磁盘中的数据进行交换,交换的规模等于槽的大小.为决定哪些槽需要交换,ESBR为每一个槽赋予一个优先级.当需要进行数据交换时,ESBR访问优先级低的槽并将它存储的内容替换为新读入的数据.为了给所有槽设置合理的优先级,本文为所有槽附加了字段at(accessingtime).它记录了槽内数据被访问的次数.相应地,本文将槽的优先级设置为,其中c代表了一个常数.它的作用是将访问不频cat繁的数据从槽中置换出去.与槽结构相对应,算法使用小顶堆d的子串.具体地,读入起始位置.当ESBR需要读取磁盘的数据时,它首先的堆顶h弹出.其次,算法根据h读取溢出子串将并替换优先级最低槽中的数据.根据上文描述,使用小顶堆维护数据的读入顺序具有以下好处:(1)实现顺序访问.因为素是基于溢出子串的起始位置维护的,ESBR可以基于盘的工作特性,避免了过多的磁道寻址;(2)降低磁盘读写次数.给定于它们对应的溢出子串位置相对接近,如果基于h1读出的子串包含h2对应的子串,ESBR可以避免针对h2的磁盘访问.图8演示了ESBR的工作过程.假设单个槽的容量为1MB、中间结果IMRi需要的字符串起始位置为1500MB,由于当前的槽中不包括所需的字符串,ESBR需要从外存中读入T[1500MB,1501MB].然后,ESBR在槽中寻找插入位置.如图所示,因为槽3的优先级最低(=0.3),ESBR将T[1500MB,1501MB]替换到该槽中.最后,ESBR更新该槽的优先级.为了便于理解,算法1给出了ESBR的基本流程.它用最小堆中间结果是在执行ALC时因溢出产生的.当||大于阈值θ时,ESBR集中对新具有最低优先级的槽.当算法1.计算中间结果.输入:存储有中间结果集合的最小堆Hmin1.while最小堆Hmin非空do2.从最小堆Hmin中弹出堆顶元素IMRi;3.ifIMRi需要的字符串并没有包含在当前的槽4.执行外存读取操作读取IMRi需要的字符串X;5.更新具有最低优先级的槽;6.endif7.使用X来继续进行IMRi的局部比对运算,若有8.endwhile4实验本节描述了局部比对外存算法的相关实验.本实验使用真实数据集作为测试集.第1个数据集是人类基因序列①(GRCh37).它包含24条染色体,染色体长度的变化范围为[48MB,249MB].它们的总长度为2.98GB,本文将它作为原串.本文使用的第2个数据集是老鼠基因数据②(MGSCv37chr1).它的长度为198000000bp.因为老鼠的基因与人类基因有相似之处,所以本文将其作为查询串.为了测试不同查询串对算法的影响,本文从基因数据中随机选取不同的起始位置s,并以此为起点生成不同长度|P|的查询串.其中,|P|的长度变化范围为[10KB,2MB].4.1算法的总体运行效率本实验测试了局部比对外存算法的总体运行效率.本实验使用约2.98GB的人类基因序列(GRCh37)作为原串T,并在其基础上建立外存后①②Page11缀树.查询串是从鼠基因数据上抽取得来的.本实验分别选取了10KB,100KB,500KB,1MB和2MB长的子串作为查询串.表2说明了实验的硬件环境和软件环境.类别硬件环境操作系统编程环境本节首先测试了|T|不变时,查询串长度对算法性能的影响.本组实验分别统计了内存计算时间Tm,外存操作时间Te和总时间T+.由表3所示,随着|P|的增长,Tm和Te都会增加.具体地,因为|P|的增加会导致I/O次数的增加,所以Te随着|P|的增加而增加;因为局部比对算法的时间复杂度与|P|呈线性关系,所以Tm也随着|P|的增加而增加.此外,对于Tm而言,因为ESLA还需维护因溢出而图9支配关系过滤技术内存和外存的影响4.3top-犽算法的运行效率本节对top-k算法的整体运行效率进行了测试.其中,参数k分别设置为2000,4000,6000和8000;原串T的长度分别为100MB,200MB和300MB.图10演示了不同的参数值k下,在不同长度的原串上寻找top-k局部比对的运行时间.在固定的原串长度下,算法的运行时间基本和查询串的长度呈线性关系,而不同的原串长度对于算法的影响较大.容易看出不同的参数k对算法的运行时间影响不大,原因是根据启发式策略得到的较大的分数.因而在给定不同的参数k的情况下,算法的运算代价基本相同,运行时间也基本保持不变.根据之前的描述可知维护局部比对结果是十分重要的,此处分别测试了在原串T的长度为200MB和300MB时为了获取top-10000和top-20000局保留的中间结果,所以Tm的增长速度更快一些.例如,当|P|增加到2MB时,ELSA需要花费大约2700ms.表3当变化查询序列长度时的算法运行时间(s)内存计算89.532209.090441.453748.4751282.568外存操作1060.8141097.0161171.8091248.1551425.605总和1150.3461306.1061613.2621996.6302708.1734.2基于支配关系的过滤技术对算法的影响本节测试了基于叉子区域支配关系的过滤能力.其中,图9(a)和图9(b)分别说明了基于支配关系的过滤算法对内存计算和外存操作的影响.如图9(a)所示,与不使用基于支配关系的过滤算法相比(None对应的曲线),基于支配关系的过滤算法能节省大约15%的内存计算时间.然而,如图9(b)所示,该技术对于外存操作的影响较小.它只节省了大约5%的操作时间.其深入原因是这种过滤算法只能避免有限的外存操作.部比对结果,维护计算过程中发现的局部比对结果所需要的时间,实验结果如图11所示.图11中参数k对运算时间影响不大,在图11(a)和图11(b)中两者的时间差距都不超过5s,造成这一结果的原因在于哈希表的容量较大,无论是top-10000还是top-20000对于哈希表的性能影响都不大.比较图11(a)和图11(b)的结果可以发现,图11(b)中用于维护局部比对结果的时间要比图11(a)中的时间要长大约10余秒的时间,这是由于在原串长度较长时,新计算的局部比对结果支配已计算的局部比对结果的情况出现得更加频繁,因而用于更新局部比对结果的时间较长.4.4外存操作优化技术的影响本节测试了外存优化策略对算法的影响.算法的外存操作可以分为以下两种:(1)读取外存后缀Page12图10top-k查询时间图11维护局部比对结果的时间树.由于后缀树索引的大小是固定的,所以这部分的时间是固定不变的;(2)读取没有保存在内存中的原串.这部分时间主要由外存操作频率决定.由前文可知,算法共维护两类子串:(1)常驻内存的子串实验首先测试了常驻子串长度对算法的影响.如图所示,常驻内存的子串长度对算法性能有着较大的影响.当常驻内存子串的长度为2GB时,算法的性能明显高于子串的长度为1.6GB时算法的性能.其主要原因是当常驻内存的子串较长时,I/O次数也会随之减少.然而,当内存总量一定时,常驻内存的子串过长时也会降低算法的性能.如图12所示,当常驻内存的字符串大小为2.4GB图12常驻内存的字符串的大小对算法运行时间的影响时,算法的总体性能低于|c|=2GB时的情形.造成这一结果的原因为:虽然串在内存中,但是由于Page13子串较少,磁盘寻址次数也会增多.因此,当大时反而会影响算法的性能.总之,对算法的性能有着较大的影响.由于原串和查询串中字符的分布都是未知的,本文无法给出一个理论上的拐点.相反,本文可从大量实验出发找到相对最优的|c|.最后,本节测试了外存交换策略对算法的影响.其中,本文对比了以下3种置换策略.它们分别是:(1)MU算法(优先置换使用次数最多的字符串);(2)LU算法(优先置换使用次数最少的字符串);(3)FIFO算法(先进先出的置换策略).如图13所示,3种置换策略对应的曲线十分接近,其中MU策略要略微占优,这从侧面反映出字符串被再次使用的概率较低的结论是正确的.5总结与展望本文对top-k局部比对问题进行了研究.和以往文献相比,本文研究的问题更为复杂.首先,它需要考虑“小阈值”带来的问题.其次,它需要突破磁盘I/O引发的瓶颈.为了解决上述问题,本文首先将一些成熟的过滤策略与本文的研究环境有机结合.其次,本文引入一种启发式算法解决“小阈值”问题.最后,本文根据磁盘和后缀树的工作特性提出了一系列外存优化策略.通过大量的实验验证了本文所提出算法的有效性.然而,虽然本文提出的算法具有较高的运行效率,但是还有一些不足需要解决:(1)寻找top-k局部比对问题的算法没有充分利用高分数阈值,未来需要研究如何利用高分数阈值来过滤不必要的计算,进一步提升算法的运行效率.(2)使用外存后缀树来解决局部比对问题对于硬盘空间的要求太大,在硬盘上读入后缀树需要花费大量的时间,将来将研究是否有其他占据空间小并且兼顾运行效率的索引结构来代替后缀树的使用.
