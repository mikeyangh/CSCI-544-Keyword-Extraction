Page1语义协同时态XML索引研究与实现叶小平汤庸张智博陈钊滢林衍崇(华南师范大学计算机学院广州510631)摘要该文研究一种以语义为基本要素并实现“语义”、“时间”和“结构”处理协同联动的时态XML索引技术SCTindex.首先,以时态结点为数据处理逻辑单元,在时态结点集合上建立基于线序划分的时态数据结构,这种结构具有相应的“拟序关系”数学基础,便于推广,能够实现“一次一集合”的查询方式,具有较高的时间查询效率;其次,以结点语义标签为数据处理技术单元,建立语义标签归并集合,在语义层面配置基于线序划分的时间索引机制,体现了XML本体要素———“语义”与时态数据基本内涵———“时间”约束间的整合联动;另外,引入带有足够结构信息和能够实现“更新友好”的结点编码方案GDFC,建立了相应时态数据的结构连接算法,实现了“结构”与“语义”协同处理.论文主要贡献是基于计算机协同处理理念,较精细地分析时态XML数据的“语义”、“结构”和“时间”等查询要素的本体特征和内在关联,提出了具有较高查询效率的线序划分结构,同时将其配置在语义层面,实现了不同于常规的以“结构摘要”为主轴部署查询的索引模式.论文进行基本实验仿真,通过与现有相关工作进行比较评估,表明SCTindex的可行性、有效性和优越性.关键词时态XML;基于语义协同;拟序数据结构;时态结点编码;时态索引SCTindex1引言按照通常划分,互联网应用经历了Web1.0和Web2.0两个发展阶段[1].Web1.0主要是用户通过网络获取信息;Web2.0主要是用户通过网络实现交互,由此,互联网应用进入大数据(bigdata)时代[2].Web2.0时代提出的大数据应用需求使得常规数据管理朝着网络化方向快速扩展,XML逐步成为网络信息交互整合的规范与标准语言,XML数据管理也成为新世纪数据库技术的前沿领域[3].在大数据管理过程中需要处理数据的生命周期、状态特征和增量式学习等基本问题,从而使得研究和使用数据的时间维意义日显突出,“显式”描述处理XML数据的“时态”日益引起人们关注.实际应用是数据库技术发展的强大驱动.从数据库发展历史来看,时态数据管理和一般数据库技术发展可以说是同步发展相向而行[4].在Web2.0推进下的大数据环境中,以时态XML为代表新型时态数据管理已成为时态数据库新的主要研究方向之一.XML独特的半结构化性质和复杂多样的查询方式,使得数据索引在查询过程中发挥重要作用,也成为XML数据管理重点与难点[5].索引本质依赖于所采用数据模型.现有XML时态建模主要有:(1)基于查询语言建模,包括基于常规XPath建模如1999年Dyreson等人[6]、2008年Wang等人[7]提出基于事务时间访问模型,2000年Amagasa等人[8]提出的基于有效时间数据模型,2004年Wang等人[9]提出的双时态数据模型;还有对XPath和XQuery进行时态扩展,如2003年Gao等人[10]提出了支持有效时间的τXQuery,2004年Alberto等人[11]提出TXPath.(2)基于XML本体建模,即从XML半结构化自身特征进行时态建模,其中主要是2006年Chen等人[12]提出的图模型,2008年Rizzolo等人[13]提出的有效时间模型、2011年Baazizi等人[14]提出的版本管理模型,2009年AliKhadija等人[15]提出的双时态模型系列.上述“(2)”建模基本点是根据元素或属性取值有无参照而选用树或图结构,大多情况是是时态建模与索引研究同步.这些工作从技术角度分为三类:(1)基于结点间路径,如2004年Alberto等人[11]提出的连续路径索引,2008年Flavio等人[13]提出的结构摘要路径索引,另外还有基于非时态索引树扩展的各类工作[16-21];(2)基于结点自身编码,如2007年[22]及2009年[23]Ye等人和2011年Baazizi等人[14]分别提出的基于编码的索引方法;(3)基于结构和编码融合,如2012年Ye等人[24]提出的时态XML索引.时态XML带有“语义”、“时间”和“结构”信息,相应查询是一个对各种因素进行精细分析和整合配置的协同过程.这里需考虑初始模块选择和多模块协同两个因素.XML结点有效时间是结点语义的生命周期;结构反映了结点间语义关联,是对结点不同语义层次的描述.从本体来看,XML的本体核心元素是“语义”,技术实现关键是“结构”;从数据查询过程考虑,由“语义”到“时间”再到“结构”,技术处理复杂度顺次递增.与关系数据查询中先进行简洁一元运算(选择和投影)再完成复杂二元运算(连接)类似,对于时态XML先做“语义”过滤再进行“时态”和“结构”处理具有技术处理的有效性与合理性,而相应理论分析与试验结果表明会明显提高查询效率.此外,时态XML结点“语义”、“时间”和“结构”信息具有内在关联,这些交错复杂的关联使得在确定了“语义”作为初始操作模块后,不能简单地“一个接着一个”进行相应模块操作,而需进行必要协同配置,否则查询效果甚至差于遍历.论文提出一种基于语义协同的时态XML索引SCTindex,它以结点“语义”处理为索引构建基点,Page3将“时间”处理配置在“语义”层面,通过拟序关系处理时间查询;同时建立了基于“更新友好”结点编码GDFC以处理结构查询.论文工作主要比较参照文献为文献[13]及文献[24](文献[24]性能优于文献[13]),不同于两者围绕“结构”组织索引,将“时间”处理安排在“结构路径”层面,论文以“语义”为主轴部署查询,将“时间”过滤定位于“语义”层面.索引构建“基点”不同导致索引实现“技术”差异.(1)由于一个“语义标签”可对应多个“路径摘要”,由SCTindex“一次”进行的“时间”处理的结点文献[13]及文献[24]通常需进行多次处理;(2)由于路径摘要本身限制,完成一次“查询”,文献[13]及文献[24]需多次“交替”执行“结构”、“时间”和“语义”操作,而SCTindex则只需一次性“顺序”执行即可;(3)由于文献[13]及文献[24]首先进行的是“结构”处理,在其后“时间”和“语义”筛选过程中需维护已确定的复杂的路径信息,SCTindex以“语义”处理为初始,其后只需维护相对简洁的“标签”信息;(4)在算法实现上如“时态查询”算法中SCTindex需进行“双向扫描”而文献[24]需多趟扫描;再如快照结点装配,SCTindex只需将GDFC扩充就可直接定位,而文献[24]却需进行遍历匹配等.由于上述原因,论文仿真表明SCTindex查询性能优于文献[13]及文献[24],具有所期望的可行性与有效性.论文工作可从对XML查询方式延伸和对其他新型时态数据协同查询两方面进行扩展.针对XML有“结构”、“快照”和“值”查询等基本方式,论文主要基于“结构”查询,但由于“快照查询”不涉及语义,值查询不涉及结构,业可纳入论文研究范畴.对于后者,论文主要贡献实际上是研究数据“时间”与数据“本体”特征处理间的整合协同,这在XML中是“时间”和“结构”与“语义标签”整合,而在时态对象中是“时间”和“继承”、“引用”与“重载”协同;在移动对象数据中是“时间”与“轨迹线”配置.因此,论文为上述新型时态工作负载中各因素协调提供原理借鉴和技术参照.本文第2节研究时态XML索引SCTindex构建;第3节讨论基于SCTindex查询算法;第4节是相应仿真评估.2时态索引SCTindex作为一种数据结构,时态XML结点信息需要进行3个方面界定:(1)语义信息:即语义标签,语义标签间关联表现为标签路径;(2)结构信息:即结点之间父/子关系以及衍生的祖先/子孙关系,其表现形式是结构路径;(3)时间信息:即时间标签,通常为时间期间(period).XML意义在于通过标签描述数据语义,“语义”是XML基本特征,但语义不是孤立存在而是体现在相互间语义关联.类似关系数据以平面表描述语义关联,XML以有根分层图刻画语义联系,这主要通过“标签路径”实现.与关系模式对应的是Schema,它规定了标签路径的构建,并从数据模式角度将语义关联表现为“结点路径”,不同结点路径可对应相同标签路径.客观实体发展变化,数据也具有相应时间信息,如数据语义和相互关联的生命周期(有效时间)和更新状态(事务时间)等.在时态XML当中,语义信息的组织依赖于数据结构的设计,而结点时间信息又受到其结构制约.例如,父结点时间期间需包含子结点时间期间,右兄弟结点时间期间始点不能小于左兄弟结点时间始点等.时态XML自身“本体”架构将会导致在“语义”、“结构”和“时间”模块的协同考量:在原理设计时以哪个为技术处理基点;在操作实现过程中是“相继处理”还是“有机融合”;如是前者,如何选定合适次序,如是后者,怎样实现配置协调.作为一种复杂数据结构,应用中需进行结点编码以供“整合”使用.对时态XML而言,反映结点关联和时间约束是编码基本考量.如下定义的广义深度优先遍历编码具有更新友好(updatefriendly)及祖先结点编码小于其子孙结点等特征.定义1.广义深度优先遍历编码GDFC.设T0是有根分层时态XML图,为T0结点n0配置三元组:GDFC(n0)=〈GDFc(n0),RUS(n0),LevelNo(n0)〉.其中GDFc(n0)为(广义)深度优先遍历(DFT)编码,按遍历顺序递增;RUS(n0)是与n0更新频率有关的预留空间量;LevelNo(n0)为n0嵌套深度.GDFc满足条件:(1)GDFc(n0)<GDFc(n1)∧LevelNo(n1)=LevelNo(n0)+1,n0是n1父结点;(2)GDFc(n0)+RUS(n0)GDFc(n1)+RUS(n0)∧LevelNo(n1)=LevelNo(n0)+1,n0是n1父结点;(3)RUS(n0)RUS(n1)+RUS(n2)+…+RUS(np),n1,n2,…,np是n0所有子结点;Page4(4)GDFc(nl)+RUS(nl)GDFc(nr)∧LevelNo(nl)=LevelNo(nr),nr是nl右兄弟结点.图1时态XML文档及相应GDFc2.1时态结点拟序结构时态数据结点(TemporalDataNode,Tdn)定义为常规XML结点D与有效时间期间VT构成的二元组Tdn=〈D,VT〉,VT=[VTs,VTe),VTs和VTe分别表示VT始点、终点(VTsVTe).若VTs=VTe,VT为时刻(instant).Tdn有效时间记为VT(Tdn).定义2.拟序关系.设E是时态结点集,定义E上关系:Tdn1,Tdn2∈E,Tdn1Tdn2VT(Tdn1)VT(Tdn2),并称“”是E上满足自反性和传递性的时态拟序(temporalquasi-order).设Γ是E上时间期间集合.u∈Γ,u=[VTs,VTe),在VTs-VTe平面,称P(u)=(VTs,VTe)为u对应的(二维)时间点(2-dimensiontimepoint).设P0=(min{VTs(P)},max{VTe(P)}),P∈Γ.将Γ中所有时间期间按始点升序排序;当始点相等时,再按照终点降序排序,得深度优先遍历(DFT)序列.始于P0的Γ的DFT序列记为S(Γ).定义3.线序划分.设Γ是具拟序“”时态拟序集.Γ中一个全序分枝称为Γ的一个线序分枝(LinearOrderBranch,LOB).设Σ是Γ上LOB集,若LOBi,LOBj∈Σ,i≠j,LOBi∩LOBj=,且∪LOB=Γ,则称Σ是Γ上一个线序划分(Linear例1.设有时态XML数据及结点对应的GDFc编码如图1所示(未标注的时间期间为[0,now)).OrderPartition,LOP),记为LOP(Γ).算法1.下优先算法-LOP构建算法.设S(Γ)是Γ由u0开始的DFT序列.1.由S(Γ)首元素u0始至ui0∈S(Γ),这里,VTs(ui0)=VTs(u0)∧(VTs(ui0+1)≠VTs(u0)).2.由ui0~ui1:这里,VTe(ui1)=VTe(ui0)∧(VTe(ui1)=min{VTs(uj)},uj∈S(Γ)∧(uk∈S(Γ),VTs(uk)=VTs(uj)∧VTe(uk)<VTe(uj)).3.由ui1继续步1和步2至um∈S(Γ),这里,/um∈S(Γ)且(VTs(um)∧VTe(um)<VTe(um)),S(Γ)中由u0~um的子序列即是一个LOB1.4.由S(Γ)\LOB1中首元素始,继续上述步1~3,可得LOB2,…,如此得LOP(Γ).设VTs(Γ)=max{VTs(u)|u∈Γ},VTe(Γ)=max{VTe(u)|u∈Γ},则算法1时间复杂度为O((VTs(Γ)×VTe(Γ))/2).例2.设有DFT序列实例S(Γ)如图2所示.对于S(Γ)=〈[1,8),[1,7),[1,5),[3,5),[3,4),[2,9),[2,8),[2,7),[2,6),[4,6),[4,5)〉,算法1实现如图3所示,得LOP=(LOB1,LOB2):LOB1=〈[1,8),[1,7),[1,5),[3,5),[3,4)〉,LOB2=〈[2,9),[2,8),[2,7),[2,6),[4,6),[4,5)〉.2.2时态XML索引SCTindex基于语义协同时态XML索引(Semantics-BasedCooperativeTemporalXMLIndex,SCTindex)为三元组SCTindex(T0)=〈SNodes(T0),SLop(T0),Page5LNodes(T0)〉.(1)SNodes(T0)是语义结点列表,每个语义结点由时态XML中具相同语义标签数据表2时态XML的犛犖狅犱犲狊(犜0)和犛犔狅狆(犜0)SIDSlabelS1countryS2provinceS3name2,13,24,57,79,90,112,123,134,167,178,212,234{〈[0,now]79,112,[0,15]57,167,178〉,〈[5,now]2,13,{〈[0,now]78,[0,15]166〉,〈[5,now]12,[15,now]122〉}S4cityS5leaderS6infoS7TelS8add3SCTindex查询算法SCTindex在设计上表明了以“语义标签”模块为基点,在技术上体现了以“语义处理”为入口.相对结点组成且按照GDFc升序排列,实际是时态XML结点的“语义划分”.SNodes(T0)中元素按照相应Schema图深度优先遍历排序;(2)SLop(T0)是所有LOP(SNode)集,其中LOP(SNode)是SNode中各结点时间期间集合上线序划分;(3)LNodes(T0)是所有Li〈T0〉组成集合,其中Li〈T0〉是时态XML各层中数据结点按GDFc升序排列列表.例3.例1中时态XML对应Schema如图4所示.LNodes(T0)如表1所示,SNodes(T0)和SLop(T0)如表2所示,时间期间中下标表示以该期间为时间标签结点的GDFc.LevelNo0102030413,23,57,67,79,89,123,133,177,200,212,2220524,34,68,90,100,134,144,178,188,201,202,223,22406{〈[0,now]199,[0,15]56,177〉,〈[15,now]23,133,[20,now]89〉}{〈[0,20]200,[0,15]67,188〉,〈[15,now]34,144,[20,now]100,222〉}{〈[0,20]202,[0,15]68〉,〈[15,now]35,[20,now]102,224〉}{〈[0,20]201,[0,15]189〉,〈[15,now]145,[20,now]101,223〉}于常用“结构摘要”和“时态归并”,语义归并结点较少,可过滤掉大量不满足查询要求的结点.SCTindex在语义层面上配置时间查询也实现了“语义”与“时间”信息的一种协同处理机制.语义查询与时间过滤后得到两个数据结点集合,需要以其中一个为Page6“基准”而与另一个中的结点进行结构“配置”,这是时态XML处理的特色,也是技术实现难点之一,需要对多种因素进行协调与协同.基于SCTindex实现查询Q=A[VT(A)]//B[VT(B)]而得到结果集{A0[VT(A0)]//B0[VT(B0)]}的过程分为如下3个步骤:(1)通过SNodes进行语义查询:得到结点列表〈A0〉和〈B0〉,其中A=A0∧B=B0;(2)由SLop对〈A0〉和〈B0〉做时间查询,结果列表仍记为〈A0〉和〈B0〉,其中VT(A0)VT(A)∧VT(B0)VT(B),〈A0〉和〈B0〉结点按GDFc排序;(3)当时态XML为树,以〈A0〉为基准,顺次取定〈A0〉中结点A0与〈B0〉每个结点B0进行结构配置即测试A0和B0是否成立A0//B0;如是图,以〈A0〉和〈B0〉中元素个数较少一个为基准进行相应操作.上述结构连接按照“树”或“图”分别配置主要是由于“树”中一个子孙结点只能确定唯一祖先结点而一个祖先结点可有多个子孙结点.以〈A0〉为基准,取定B0k是A0i子孙结点后,对于B0(k+1)可直接进行结构测试,直至第一个不是A0i子孙结点的B0p,从而减少搜索次数;若以〈B0〉为基准,〈B0〉结点需和〈A0〉每个结点进行结构测试.在“图”中子孙和祖先结点是多对多关联,上述差异不复存在,选取规模较小的为基准比较合适.3.1基于TXPath查询TXPath查询是形如Q=A[VT(A)]//B[VT(B)]的查询,需同时查询“语义”、“时间”和“结构”信息.语义查询通过SNodes获得满足A[VT(A)]语义要求的结点集〈A0[VT(A0)]〉,再按下述算法2对〈A0[VT(A0)]〉进行时态过滤.算法2.基于LOP时态查询算法.设〈A0[VT(A0)]〉是满足A[VT(A)]语义约束结点列表,LOP(A)={LOB(A)}是基于语义标签A的线序划分.取A0i∈〈A[VT(A0)]〉:不是查询结果,转步2;1.通过A0i对LOP(A)中LOBk(A)逐条进行时态测试:1.1若VT(A0)max(LOBk(A)),则整个LOBk(A)都1.2若VT(A0)min(LOBk(A)),则整个LOBk(A)都是查询结果,转步2;1.3对于其它情形,需将VT(A0)与LOBk(A)中时间期间进行二分查找,若(VTk0∈LOBk(A)∧VTk1∈LOBk(A)),VT(A0)VTk0∧VT(A0)VTk1,其中VTk1是VTk0直接后继,则VTk0及其所有前驱都是查询结果,转步2.设需处理的语义结点线序划分满足时态约束2.以LOP(A)\LOBk(A)为新测试集合,转步1.LOB或LOB片段为k个,各LOB或片段包含元素个数最大为n,则算法时间复杂度为k×O(logn).定理1.结构查询定理.设GDFc(A0i)为〈A[VT(A0)]〉中不超过给定GDFc(B0k)的最大编码,C0是A0i同层结点且满足GDFc(A0i)GDFc(C0)的最小编码.(1)当GDFc(A0i)<GDFc(Bj0)<GDFc(C0)∧LevelNo(A0i)<LevelNo(Bj0)时,A0i是Bj0祖先结点,即A0i[VT(A0i)]//Bj0[VT(B0k)];(2)当GDFc(A0i)<GDFc(Bj0)<GDFc(C0)∧LevelNo(A0i)LevelNo(Bj0)时,A0i非Bj0祖先结点;(3)当GDFc(A0i)<GDFc(C0)<GDFc(B0k)时,A0i非B0k祖先结点.证明.注意B0k∈〈B[VT(B0)]〉,设B0k祖先结点为Aj0,由DFT,GDFc(Aj0)<GDFc(B0k).在“(1)”条件下,若A0i不是B0k祖先结点,则题设中C0或是B0k祖先结点Aj0或在Aj0“左上方”,此时GDFc(A0i)<GDFc(C0)<GDFc(Aj0)<GDFc(B0k),与“(1)”题设矛盾.在“(2)”条件LevelNo(A0i)LevelNo(Bj0)下,显然A0i不是Bj0祖先结点,这种情况出现在Bj0在A0i的“右上方”情形.在“(3)”条件下,若A0i是B0k祖先结点,按照DFT,在A0i所处层上,不能再有结点C0的GDFc位于A0i与B0k编码之间,与“(3)”题设矛盾.算法3.基于祖先结点结构查询算法.设查询A[VT(A)]//B[VT(B)]的满足语义和时间约束的结点列表为〈A0[VT(A0)]〉和〈B0[VT(B0)]〉.1.取定A0i∈〈A0[VT(A0)]〉,在〈B0[VT(B0)]〉中通过二分查找得所有编码大于GDFc(A0i)结点中编码最小者,设为B0k.2.由定理1判定B0k是否为A0i的子孙结点:2.1若是,输出A0i[VT(A0i)]//B0k[VT(B0k)],转入步3;2.2若否,则A0i在〈B[VT(B0)]〉中无其他子孙结点,舍弃A0i,转步4.3.在〈B[VT(B0)]〉中找到所有编码大于B0k结点中编码最小者(此时即为B0k的直接后继B0(k+1)),并将B0k=B0(k+1),转步2.4.取A0j〈A[VT(A0)]〉\{A0i},仍以〈B[VT(B0)]〉作为A0j被测试列表,转步1.在算法3中步2.1跳转语句改为“转入步4”,步4改为“B0j〈B0[VT(B0)]〉\{B0i},〈A0[VT(A0)]〉仍为被测试列表”即得基于子孙结点结构查询算法.对于双亲/孩子关系结构连接,只需在算法3Page7中步2.1增加条件LevelNo(A0i[VT(A0i)])=LevelNo(B0k[VT(B0k)])-1即可.设〈A0[VT(A0)]〉含k个结点;〈B0[VT(B0)]〉中包含n1个结点,则步1复杂度为O(logn1);设LNodes(T0)中结点对应的LNodes(T0)[i]元素个数最大为n2,则步2复杂度为O(logn2);设n=max{n1,n2},算法3时间复杂度为k×O(logn).例4.在如例1所示实例中,设查询A[VT(A)]//B[VT(B)]:city[5,10)//leader[16,18).由语义和时态查询,得到〈A0[VT(A0)]〉=〈12,78〉,〈B0[VT(B0)]〉=〈23,133〉.由结构查询,得到12//23为查询结果.这里,使用结点的GPFc表示相应结点.3.2快照查询快照查询可看作时态XML有向图在时刻T0的子图,即依据T0对XML“切片”,查询中只有时间约束而不显现“语义”和“结构”约束,但需将“切片”得到的结点按照原时态数据模式重新组织成一个或多个子图,实际仍需结构信息.为完成时态查询结果的装配,可将GDFC扩充,为每个结点提供其双亲信息,此时,每个结点赋予一个四元组编码E-GDFC=〈GDFc,RUS,LevelNo,ParentNo〉,其中ParentNo为结点双亲结点的GDFc.对时态XML进行T0快照查询,首先利用SLop,依次对每一个语义结点LOP做时间查询得相应结点;为快速还原快照子图结构,需为每个满足时间约束的结点ni构建一个List:Lci用来记录ni所有子结点信息.并对所有List引入一个哈希结构HashN-L进行统一管理.每当查询到满足时态约束结点n时,就将n加入到其父结点np的List:Lcnp中,重复以上过程直到所有满足时态约束结点配置完成.算法4.快照查询算法.设S0和S1分别是XML所有结点GDFc编码集合与其在DOM中结点集合,H是S0到S1的Hash映射.1.将时刻T0看做[T0,T0),通过SLop依次对所有语义摘要按算法2的思想做时间过滤,得E={GDFc(A)|[T0,T0)VT(A)}.2.将E任一结点ni依次加入为其父结点np配置链表List:Lcnp,记录哈希关系HashN-L(np,List:Lcnp).时刻T0可以看做始、终点相等的时间期间,如考虑不等的一般情形,可得基于“切块”时间快照.例5.设有查询:“从时刻0至今给定城市(city)中在时间期间[23,now)内任职的负责人(leader)电话号码(Tel)”,相应TXPath语句为//city[0,now)//leader[23,now)//Tel.查询过程需维护查询结果集和辅助结果集,分别设为Aset,Bset.查询首先将TXPath语句中第一条语义查询city得到的结果〈12,78,122,166〉放入Aset,对Aset进行时间([0,now))过滤结果〈78〉;再将其后子查询leader[23,now)结果〈23,56,89,133,177,199〉放入Bset;将Aset与Bset分别作为〈A0[VT(A0)]〉和〈B0[VT(B0)]〉结构连接得到结果〈89〉放入Aset;继续语义查询Tel,将结果集〈35,68,102,202,224〉放入Bset;最后将Aset与Bset做结构连接得结果〈102〉.通过SCTindex,最终得到E=〈102〉;通过映射表F,得到GDFc=102对应ID=17的数据结点,时态XML文档片段(子图):〈TelID=“17”VT=“[20,now)”〉T3〈/Tel〉.4比较与仿真仿真环境为Inter(R)Core(TM)2DuoCPUP8600,主频为2.40GHz;主存为4GB;操作系统为Windows7,开发环境为Eclipse3.7.仿真比较对象为TempIndex[13]和TempSum-Index[24],两者都是“基于结构摘要索引”.由于TempSumIndex性能优于TempIndex,论文只与TempSumIndex比较.仿真数据集采用“基于结构摘要索引”[13,24]中使用的反映NBA球队球员历史变化情况的时态XML数据集,该数据描述各球队球员转队、个人得分以及助攻次数等随时间变化情形,较好体现时态XML数据特性.仿真结点数以50000为间隔,由50000变化到550000.VT=[VTs,VTe]端点取整数以简化操作.时态XML数据的内部结点平均时间跨度为500单位,叶结点为200单位.仿真依照XPath思想,采用绝对路径查询(//A)和相对路径查询(A//B)两种方式.按照结点时态约束将查询分为如下3种类型,其中A或B表示语句的语义与结构约束的结合,[VT]表示时态约束.类型1.无时间约束.Q11(//A);Q12(A//B).此时Q11,Q12形式上不涉及时态约束,但查询结果是时态结点(结点、有效时间期间).类型2.含时间约束.Q21(//A[VT]);Q22(A//B[VT]);Q23(A[VT]//B);Q24(A[VT]//B[VT]).类型3.快照查询.关于时间点VT0=[VT0,VT0)查询.分为带“显式”语义Q31(A[VT0]//B[VT0])和不带有语义Q32([VT0])两种情形.两者共同特点都是查询时态XML在VT0历史状态.仿真对上述3类中每种查询随机构造100条查Page8询语句,查询耗时为该100条语句查询耗时的平均值.仿实验实现的技术路线如图5所示.4.1索引构建时间开销索引构建时间开销如图6所示,SCTindex时间开销小于TempSumIndex.同时,SCTindex时间开销基本呈线性变化,具较理想的时间复杂度.SCTindex与TempSumIndex查询性能比较如图7~图14所示.4.2类型1查询对Q11(//A)而言,SCTindex直接得语义查询结果,TempSumIndex则需查找所有满足语义限制的多条路径.其查询性能如图7所示.Q12与Q11类似,只需再进行结构连接,但Q12需探索至更深,结构连接操作较多.由图8可知,SCTindex优于TempSumIndex,这是由于前者先行查找“语义”而缩小搜索范围,继而由GDFC实现更为有效的结构连接.4.3类型2查询Q21是Q11带时态的扩展,性能比较如图9所示.Q21语义处理与Q11相同.SCTindex对同一标签结点集建立LOP,TempSumIndex则对一个标签结点维护多条路径信息,对每个路径结构结点集分别建立LOP,缩小了LOP规模,增加了时间开销.示,SCTindex拥有较好的查询性能.Q22可看做是Q12中时态约束变形,如图10所Page9Q23时态约束位于祖先结点.语义过滤后,时态查询将需参与连接祖先结点数减少,性能比较如图11所示.Q24是Q21时态约束的又一变形,特点是祖先和子孙结点都带时态约束,性能比较如图12所示.4.4类型3查询具相同时间约束,查询性能比较如图13所示.Q31是带有语义标签的快照查询.Q31中A和BQ32可看作某种意义下的小枝(twig)查询,相应查询性能测试如图14所示.Q32要求查询在VT0时刻有效的结点所组成时态XML子图.5结语论文研究基于语义协同理念的时态XML数据索引机制SCTindex.论文主要工作是研究XML数据“语义”、“时间”和“结构”等信息模块本体意义和技术处理特征,不同于以“结构摘要”组织索引的常规方式,将索引SCTindex构建在语义归并层面,为各模块的有效联动与协同配置提供了基本框架.论文与现有的相关索引TempIndex[13]和TempSum-Index[24]进行比较评估,仿真结果表明SCTindex具有较为优越的查询性能.本文工作还可以扩展到XML的一般“快照”查询和“值”查询,也为其它新型时态数据中“时间”与“本体”语义协同处理提供原理借鉴和技术参考,如对时态对象数据中的“时间”与“继承、参照和重载”整合,移动对象数据中“时间”与“轨迹线”协调等.SCTindex动态管理是索引技术重要部分,论文中GDFC就是基于数据更新友好编码,但限于篇幅,SCTindex的增量式更新将另文讨论.
