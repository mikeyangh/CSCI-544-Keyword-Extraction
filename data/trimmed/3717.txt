Page1一种新型的层次化动态社区并行计算方法林旺群邓镭丁兆云吴泉源贾焰周斌(国防科学技术大学计算机学院长沙410073)摘要文中提出了一种可并行分解的层次化动态社区发现算法D-SNCD(DynamicSocialNetworkCommunityDiscovery).D-SNCD算法充分利用复杂动态社会网络变化的局部性,对算法生成的层次化社区树HOT(Hierar-chicalcOmmunityTree)的分枝进行选择性更新.与传统的对动态社会网络直接采用快照方式进行社区发现相比,D-SNCD算法在效率上取得了明显的提高.由于D-SNCD是对已有的静态社区并行计算方法P-SNCD(ParallelSocialNetworkCommunityDiscovery)的进一步扩展,因而D-SNCD保持着P-SNCD算法的高扩展性和高分辨率等优点.另外,D-SNCD算法对用户参数输入要求简单.严格的数学证明和充分的实验数据保证了整个算法的正确性和有效性.关键词社区发现;层次化社区结构;动态社会网络;并行计算;动态更新1引言随着各类新型“社会网络应用”的迅速普及,社Page2区之下.如Yahoo社区下面可以分为“健康社区”、“情感社区”、“娱乐社区”等.而在这些高层次的社区之下又可以进一步分为更加具体的社区结构,如“健康社区”之下又可以分为“运动养生社区”、“食物养生社区”等等.甚至在这些社区之下,根据用户的交互行为,还可以进一步分为更加具体的用户交互社区.另外一个真实的层次性化区结构的例子就是酶蛋白质的交互网络.在酶蛋白质交互网络中,不同化学分子结合形成了具有不同功能结构的蛋白质,而不同蛋白质的结合又进一步形成了不同的功能组织.挖掘隐藏在不同网络中层次化社区结构对进一步了解网络的特性和行为有着重要的意义.然而,真实社会网络中的过大的数据规模(如现在流行的视频网站Youtube和社交网站Facebook所形成的社会网络节点规模都在109以上)使得现有的大多数社区发现算法无法有效地分析真实网络中的社区结构.因此,一种有能有效地发现真实社会网络中的层次化动态社区结构,并且算法计算性能能够根据数据规模进行动态扩展的并行算法具有重要的意义.2相关工作目前在社会网络社区发现方面已有大量的研究成果,总体来讲,可以将它们大致归纳成以下几类:(1)基于目标函数优化的社区发现方法基于目标函数优化的社区发现方法将社会网络社区划分问题转化为优化问题,采用最优化定义的目标函数来挖掘社会网络的社区[1].例如:谱方法[2-3]将网络聚类问题转化为二次型优化问题,通过计算特殊矩阵的特征向量来优化预定义的“截”函数;KL(Kernighan-Lin)算法[4]、Fast-GN算法[5]以及GA(Guimera-Amaral)算法[6]将社区发现流程分为3个基本部分:目标函数的提出、候选解的搜索策略和最优解的搜索策略,并从不同角度采用局部搜索优化方法来挖掘潜在的网络社区.淦文燕等人[7]从数据场思想出发,提出了一种基于拓扑势的社区发现算法,将每个社区视为拓扑势场的局部高势区,通过寻找被低势区域所分割的连通高势区域实现网络的社区划分.何东晓等人[8]提出了一种基于聚类融合的遗传算法用于复杂网络社区挖掘.该算法将聚类融合引入到交叉算子中,利用父个体的聚类信息辅以网络拓扑结构的局部信息产生新个体,避免了传统交叉算子单纯交换字符块而忽略了聚类内容所带来的问题.沈华伟等人[9]采用信息论的思想,提出了一种基于信息瓶颈的社区发现方法.该方法通过寻找网络的最优压缩表示来发现网络的社区结构,最优压缩表示尽可能多地保留原始网络拓扑特征.林旺群等人[10]提出了一种新型的社区“内聚性”评价方法.为了优化新型的“内聚性”目标函数,针对静态社会网络提出了一种并行计算方法.(2)基于启发式的社区发现方法基于启发式方法的社区发现方法通过引入基本假设将社会网络社区发现问题转化为预定义启发式规则的设计问题[1].例如,GN算法[1]以社区之间的边界数应大于社区内部连接的边界数这一基本假设作为启发式规则,通过重复删除具有最大边界数的边方式来划分社区.Tyler等人[11]将统计方法引入基本的GN算法,提出一种近似GN算法.该算法采用用蒙特卡洛方法估算出部分连接的近似边界数,从而有效地提高了算法的计算效率.Flake等人[12]认为网络中的最大流量由网络“瓶颈”的容量决定,而在具有社区结构的网络中,网络“瓶颈”由社区之间的连接构成.基于这一思想,Flake等人提出的MFC算法能够有效挖掘社会网络中的潜在社区结构.Wu等人[13]提出了快速启发式算法WH.该算法将复杂网络建模为电路系统,网络连接看成是具有电阻的线路,不同位置的网络节点具有不同的电位势.Palla等人[14]提出了能够识别重叠网络簇结构的CPM算法.CPM算法的启发式信息为:网络社区由多个相邻的k-团(k-clique)组成,相邻的两个k团至少共享k-1个节点,每个k-团唯一地属于某个社区,但属于不同社区的k-团可能会共享某些节点.Yang等人[15]提出了基于马尔可夫随机游走模型的启发式复合网络聚类算法FEC.该算法所采用的基本假设是:从任意给定的社区出发,网络中的随①http://www.oslom.org/Page3机游走过程达到起始社区内节点的期望概率将大于达到起始社区外节点的期望概率.通过计算在给定时刻随机游走过程到达所有节点的期望转移概率分布,进而根据该分布的局部一致性原理判别出各个不同的社区结构.Zhang等人[16]基于相似度动力学(propinquitydynamics)特性,经过聚合网络拓扑结构和相似度(propinquity),基于BSP模型实现了针对大规模数据集的高效社区发现算法.(3)其它社区发现方法除了以上两类主要方法以外,还存在其它社会网络社区发现方法.例如,基于相似度的层次聚类方法.在这类方法中,节点间的相似度根据网络拓扑结构定义,如基于结构全等的相关系数(correlationcoefficient)[17]、基于随机游走的相似度[18]和节点聚类中心度(clusteringcentrality)[19]等.另外最新社区的发现研究成果还包括基于图的生成树分析的方法[20]、基于张量分解的方法[21]、基于粒子和密度演化聚集的方法[22]、基于贝叶斯推理的方法[23]等.虽然上述方法各有优势,并且在某些数据集上表现出了优异的准确性和计算性能.但是大多数算法的一个共同缺点在于算法性能不能随数据规模进行动态扩展,因而对某些真实网络中的大规模数据集不能有效地进行分析和处理.3问题描述在现实社会网络中,多重图(Multi-graph)①,即社会网络的不同节点对之间可能存在多条平行边结构的带权图,能够很好地表示绝大多数社会关系.比如在一个科研论文合作撰写的社会网络中,每一个节点代表一位作者,而两个节点之间的一条边代表了一次论文合作撰写记录,边的权重代表两作者间的合作紧密程度.在该社会网络中,可以观察到以下现象:(1)同一篇科研论文可能有多位合作作者且其相互合作的紧密程度可能不同;(2)相同的两个作者之间可能存在多次合作记录.对于这两种现象,多重图的相同节点对之间具有独立权值的多条平行边恰好能够很好地表示这种论文合著关系.同样多重图也能很好地表示蛋白质相互作用、Web社区交互等复杂网络形态.因此可以将社会网络建模成多重图Gsn=(V,E,W),其中V表示社会网络Gsn中所有实体集合,E表示社会网络Gsn中实体之间的关系集合,W表示社会网络Gsn中所有实体关系权重集合.另外根据社会网络中社区的基本条件[10],对于社区的一个直观感觉就是成员关系越紧密的社区,社区内部应该以较少的点包含较多的边.由层次化的社区结构所形成的树状图我们可以知道,不同社区将出现在不同的分枝之下.这使得不同分枝的社区计算互不影响,因而对不同分枝的社区可以挖掘出其并行结构进行并行计算,从而有效地提高算法性能.本文在前续工作[10]的基础上,进一步提出一种基于多重图的层次化动态社区并行计算算法.定义1.社会网络多重图Gsn=(V,E,W)是指社会网络Gsn中的任意两个节点v1,v2∈V之间可以存在多条边的图.其中,V表示所有节点集合;E表示节点之间的所有边集合;W表示所有边的权重集合.由定义1可知,社会网络多重图是多重图(Multi-graph)概念在在社会网络中的一个具体应用.为了论述的方便,在本文的余下章节中,统一将“社会网络多重图”简称为“多重图”.定义2.社会网络形成的多重图Gsn=(V,E,W)的一个子图L具有密度(内聚性)l(l∈Z+),当且仅当下式成立:其中,E(L/P)表示图L的所有边E的集合,V(L/P)表示在上述P划分下形成的图L的所有新节点集合V[10,20].为了进一步说明社区密度定义,图2给出了一个子图密度l=2的一个例子.图2不同密度的子图(其中图(b)~(d)同为①http://en.wikipedia.org/wiki/MultigraphPage4如图2所示,图(b)是图(a)的一个子图.假设DV=|E(L/P)|/(|V(L/P)|-1),则对子图(b)的所有划分及其对应的DV值(DensityValue)如表1所列.由表1可知,在图(b)的所有划分中,{{A,B,表1图2(b)在不同划分下对应的犇犞值|P|=2{{A,B,C},{D}}3{{A,B,D},{C}}7{{A,C,D},{B}}9{{B,C,D},{A}}5|P|=3{{A,B},{C},{D}}5{{A,C},{B},{D}}4.5{{A,D},{B},{C}}6{{B,C}{A},{D}}4|P|=4{{A},{B},{C},{D}}4定义3.子图L是社会网络形成的多重图Gsn=(V,E,W)中的一个l级别社区当且仅当L是Gsn中具有密度l的最大子图[10,20].在图2中,通过穷举图(a)中所有密度l=2和l=4的子图并结合定义3可知,图(b)是图(a)的一个2级别社区,图(c)是图(a)的一个4级别社区.本文提出的社会网络动态社区发现算法就是要对给定的动态社会网络形成的多重图Gsn=(V,E,W)和正整数h,找出Gsn中所有的h级别社区.4基于多重图并行分解静态社区发现算法在具体阐述层次化动态社区发现并行算法之前,先在本节简单介绍我们的前续工作,即基于多重图并行分解的静态社区发现算法P-SNCD[10].定义4.层次化社区树HOT[10](HierachialcOmmunityTree).HOT是这样的一棵树,HOT中的第l层节点集合Ll中的任意一个节点Ll社会网络形成的多重图Gsn=(V,E,W)节点集合V的一个子集Vli和权值集合WlEli),如果:Wl(1)Ll示Gsn的一个l级别社区;(2)LlC},{D}}对应的DV值最小为DVmin=3.因此,根据式(1)可知,图(b)的密度l=2.同样,枚举子图(c)的所有划分并计算其DV值可以得到图(c)的密度l=4.如果满足式(1)则为Gsn的一个l级别社区,否则不是Gsn的l级别社区.图4给出了P-SNCD算法运行的并行关系层次示意图.其中每个箭头代表一个处理器,相互平行的一组箭头代表执行并行计算任务的处理器.箭头组之前的竖线代表处理器组并行工作时的输入,这个输入也是前一阶段的输出.整个算法分3个并行计算层次.第1层次并行处理HOT所有最底层叶子节点(对应图4中(a));第2层次包括并行计算生成树和并行处理不饱和边集合Eus两部分(对应图4中(b)和(c)).第3层次对以不饱和边e0为“种子边”与生成树集合T中的每棵生成树形成的环路的边集合Cn采用并行计算(对应图4中(d)).这种层次化并行结构充分地挖掘了算法潜在的并行性,最大限度提高了算法的效率.然而随着并行层次的递增,多处理器之间在层次衔接位置的通信开销(假设采用BSP并行计算模型[26])和同步开销也随着上升.在每个层次的并行计算开始时,可以根据实际采用的并行计算模型通过消息传递(如BSP并行计算模型)或多处理器互斥访问该层次的共享变量的方式(如PRAM-CREW并行计算模型)分发任务,这样不但自动完成了不同处理器之间的任务调度,而且还使得算法本身能够根据实际运行环境中处理器数量自动调整并行计算的层次.这是因为第1层次的并行任务粒度大于第2层次的并行任务粒度,第2层次的并行任务粒度大于第3层次的并行任务粒度.随着并行任务粒度的下降,每个处理器获得的并行计算量将减少,同时算法的并行度进一步增大,这将必然导致算法的通信开销和同步开销的上升.然而,算法运行时层次间的时序关系也是从第1层次到第2层次再到第3层次,算法本身的这种层次间的执行时序关系决定了算法在处理器分配上总是先满足第1层次的并行,然后是第2层次,接着是第3Page5层次.这种层次间的执行顺序除了能够最大限度地提高算法运行速度外,还使得在处理器数目不足的图4算法P-SNCD层次化并行结构示意图关于P-SNCD算法的进一步详细描述,请参考文献[10].5基于多重图层次化动态社区并行计算方法针对静态社会网络,算法P-SNCD给出了一种高效并行计算不同级别社区的方法[10].然而在大多数情况下,复杂系统中的社会网络拓扑结构是不断变化的.面对动态变化的社会网络,如果仅对网络拓扑结构进行快照并采用静态社会网络计算社区的方法对不同的快照进行处理,那么该社区划分方法必然是低效的.这是因为该社区计算方法没有考虑快照之间的内在联系,即动态社会网络拓扑结构变化对社区而言通常具有局部特性,也就是说一段时间内社会网络的动态变化只对部分社区的结构产生影响,而不会使得其它社区结构产生变化(相关证明见定理1~定理4).本小节在算法P-SNCD的基础上提出了一种针对演化的动态社会网络社区发现算法D-SNCD(DynamicSocialNetworkCommunityDiscovery).在详细介绍D-SNCD算法之前,先针对导致静态社会网络Gsn发生动态变化的4种行为,即“增加边”、“删除边”、“增加节点”、“删除节点”给出定理1~定理4.定理1.如果社会网络Gsn=(V,E,W)中的任意两个节点vx,vy之间的边为exy,权值为wexy(如果边exy不存在的话,可视边exy对应的权值wexy=0),那么计算在Gsn基础上在节点vx,vy之间新增加一条权重为α(α1)的边eα所形成的社会网络Gsn=Gsn+eα所对应的层次化社区树HOT,只需要在Gsn对应的HOT的基础上进行如下操作:(1)沿着HOT的root节点向最底层节点方向寻找这样的节点Ll情况下,可以优先进行高层次的并行计算,从而有效降低算法的通信和同步开销.q都有exy∈E(ClLl+11pnl,1qnl+1,1lh).(2)如果步骤(1)找到满足条件的Llq,z=l+1;否则令T=T1i,z=1.将不饱和T=Tl+1边exy(对应权值wexy=wexy+α)及生成森林集合T作为算法P-SNCD的输入,从其步骤(6~8)开始执行生成新的z级别社区Czs(0<snz)以及由Czs派生出来的所有后续高级别社区.将上述社区生成过程中形成的以Lzs(对应的社区为Czs)为根节点的子树添加到HOT的Ll节点之下.(3)若在P-SNCD步骤(6~13)参与Czs合并的Czt(0<tnz∩t≠s)在HOT中所对应的节点为Lzt,则删除HOT中以Lzt为根节点的子树.证明.在社会网络Gsn中,任意两个节点vx,vy(vx,vy∈V)之间新增一条权重为α的边eα等价于将这条边所连接的两个节点之间原来的边exy(如果vx,vy之间原来没有边,可以视wexy=0)的权值增加α,即wexy=wexy+α.下面将就exy是否出现在某个l级别的社区Cll层的第j个节点Lljnl)中,那么只有可能是以下两种情况:(a)在Gsn中,we=0,即vx,vy两个节点之间原来是没有边连接的;(b)在Gsn中,wexy=1∩exy∈T1i,1,即连接vx,vy的边exy的权值为1且exy出现在生成森林集合T1i(0<in1)的第一棵生成树(森林)T1i,1中.无论是(a)还是(b),增加边exy的权值都将使得exy成为一条不饱和边,从而需要将exy(对应权值wexy=wexy+α)及T=T1i作为算法P-SNCD的输入并且从其步骤(6~8)开始执行生成新的第1级别社区C1s(0<sn1)以及由C1s派生出来的所有后续高级别社区.在生成社区C1s的过程中,由其步骤(6~13)可(1)如果exy没有出现在任何ClPage6(2)如果exy出现在某个Cl知,需要删除所有参与C1s合并的C1t(0<tn1∩t≠s)以及由C1t生成的所有后续高级别社区.由于第1级社区集合C1中的任意两个社区之间不存在交集,所以在1级别社中,对社区C1s的操作将不会影响除C1t外的其它社区.的执行过程可知,任意一条不饱和边e0∈Eus的饱和度Sa(e0)随着HOT深度递增而非递减并且最终达到e0的最大饱和度we0,所以首先沿着层次化社区树HOT的root节点向最底层节点方向寻找,必然存在这样的节点Llnl,0<lh)使得exy∈E(ClLl+1q=Llqnl+1)为Ll任意孩子节点.由于在Ll中,exy已经是这些社区中的一条边,所以增加exy的权值不会影响这些社区的结构.下面对exy是否是p中的饱和边分两种情况进行分析.(a)Sa(exy)=Clwexy,即exy是Cl加边exy的权值将使得exy重新成为不饱和边.又因为exy∈Cl的结构产生影响.此时,只需在第l+1级别社区中重新计算以exy作为“种子边”的新社区.(b)Sa(exy)≠wexy,即exy是Cl所以此时一定有exy∈Tl+1立,其中Tl+1生成树(森林).增加边exy的权值将使得exy成为第l+1级别的一条不饱和边.无论是(a)还是(b),这时只需要以生成森林集合T=Tl+1(对应权值wexy=wexy+α)作为算法P-SNCD的输入并且从其步骤(6~8)开始执行,生成新的l+1级社区Cl+1u(0<unl+1)以及由Cl+1u派生出来的所有后续高级别社区,同时需要删除在其步骤(6~13)与Cl+1u合并的所有相关l+1级社区Cl+1v(0<vnl+1∩v≠u)以及由这些社区派生出来的高级别社区.由于在第l+1级社区集合Cl+1中,任意两个社区之间不存在交集,所以对社区Cl+1u的操作将不会影响除被Cl+1v外的其它l+1级社区.证毕.定理2.如果社会网络Gsn=(V,E,W)中的任意两个节点vx,vy之间的边为exy,权值为wexy(如果边exy不存在的话,可视边exy对应的权值wexy=0),那么计算在Gsn基础上删除vx,vy之间一条权重为β(1βwexy)的边eβ所形成的社会网络Gsn=Gsn-eβ所对应的层次化社区树HOT,只需要在Gsn对应的HOT的基础上进行如下操作:(1)当wexy=β时,如果对于i∈{1,…,n1}都有exyE(C1i),则无需执行额外操作就有HOT=HOT;否则(即i∈{1,…,n1}使得exy∈E(C1i))假设C1i-exy所包含的不饱和边集合为Ei,对应的生成森林集合为T1Eus=Ei,生成森林集合T=T1的输入,从其步骤(6~8)开始执行生成新的第一级别社区C1棵分别以L1为root节点的子树加入HOT的root节点之下,删除HOT中以L1i为root的子树.(2)当wexy>β时,沿着HOT的root节点向最底层节点方向寻找这样的节点Llr(对应的社区为Clr,1lh,1rnl),使得exy∈E(Clr)∩Sa(exy)=wexy-β并且对于Ll+1s(1snl+1)有exy∈Cl+1s∩Sa(exy)=wexy-β+1,其中Ll+1s为Llr在层次化社区树HOT的l+1层的某孩子节点.假设Cl+1s-exy所包含的不饱和边集合为Es,Cl+1s对应的生成森林集合为Tl+1s,那么以不饱和边集合Eus=Es,生成森林集合T=Tl+1s作为算法P-SNCD的输入,从其步骤(6~8)开始执行生成新的第l+1级别社区1,…,Cl+1Cl+1y棵分别以Ll+11,…,C1C1点之下,并删除HOT中以Ll+1s为root的子树.证明.在社会网络Gsn中,在任意两个节点vx,vy(vx,vy∈V)之间删除一条权重为β的边eβ等价于将这条边所连接的两个节点之间原来的边exy的权值减少β,即wexy=wexy-β0.下面将就wexy=wexy-β分两种情况讨论:(1)如果wexy=0,即原来连接vx,vy两个节点的exy的权值wexy=β.在这种情况下将exy的权值减少β相当于直接删除exy,这使得vx,vy在Gsn中不再成为直接邻居.下面分两种情况进行讨论.(a)当i∈{1,…,n1}使得exy∈E(C1i)时,即exy出现在第1级别的第i个社区中.因为删除边exy将影响C1i这个社区及其由C1i派生出来的后续社区的结构,因此需要重新生成C1i及其后续派生社区.假设C1i所包含的不饱和边集合为Ei,对应的生成树集合为T1C1i-exy所包含的不饱和边集合为Ei,对应的生成树集合为T1成立.以不饱和边集合Eus=Ei,生成森林集合T=Page71作为算法P-SNCD的输入,从其步骤(6~8)开T1始执行.假设在步骤(6~13)的输出为C1(0x|Ei|).因为EiEi∩T11∪C12∪…∪C1xC1i,进一步C1C1第1级别社区.此时生成Gsn=Gsn-eβ所对应HOT只需将x棵分别以L1树加入到Gsn所对应HOT的root节点之下,并删除HOT中以L1i为root的子树.(b)当对于i∈{1,…,n1}都有exyE(C1i)时,即exy没有出现在任何第1级别社区中.在这种情况下,即exy也不会出现所有后续高级别社区中,因此删除exy不会使得Gsn的任何级别社区结构产发生变化.(2)如果wexy>0,即原来连接vx,vy两个节点的边exy的权值wexy>β.在这种情况下,沿着层次化社区树HOT寻找这样的节点Llr(1rnl)使得exy∈E(Clr)∩Sa(exy)=wexy-β并且对于Ll+1s(1snl+1)有exy∈Cl+1s∩Sa(exy)=wexy-β+1,其中Ll+1s为Llr在层次化社区树HOT的l+1层的某孩子节点.由于任意一条不饱和边e0∈Eus的饱和度Sa(e0)随着HOT深度递增而非递减并且最终达到we0,所以上述Llr和Ll+1s必定存在.因为在Llr及Llr的祖先节点所对应的社区中,exy已经是这些社区中的一条边且exy在这些社区中对应的饱和度Sa(exy)wexy-β,所以exy的权值减少β不会影响这些祖先节点所对应社区的结构.又因为社区Cl+1s及其后续包含边exy的派生社区在exy的权值减少β后将不再包含边exy,所以Cl+1s及其派生社区需要重新计算.假设Cl+1s所包含的不饱和边集合为Es,对应的生成树集合为Tl+1s,Cl+1s-exy所包含的不饱和边集合为Es,对应的生成树集合为Tl+1s=Tl+1s,那么显然有EsEs成立.以不饱和边集合Eus=Es,生成森林集合T=Tl+1s作为算法P-SNCD的输入并从其步骤(6~8)开始执行.假设在步骤(6~13)的输出为Cl+11,…,Cl+1Tl+1s,所以必有Cl+11∪Cl+12∪…∪Cl+1立,进一步Cl+11,…,Cl+1此时类似于(1)(a)生成Gsn=Gsn-eβ所对应HOT,只需将y棵分别以Ll+1点的子树加入到Gsn所对应HOT的Llr节点之下,并删除HOT中以Ll+1s为root的子树.证毕.定理3.假设社会网络Gsn=(V,E,W)所对应的层次化社区树为HOT,在Gsn的基础上增加节点va以及与va相连的n(0n|E|)条边集合{e1a,…,ena}后所形成的社会网络Gsn=Gsn+va+{e1a,…,ena}所对应的层次化社区树为HOT,那么构造HOT只需要在HOT的基础上进行如下操作:(1)如果n=0时,HOT=HOT;否则转入(2).(2)假设Gsn中e1a,…,ena分别与第1级别社区集1,…,C11,…,C1x)为root节点的子树,将构造出社会任何新的边.显然有HOT=HOT.合C1中的x(0<xn)个社区C1相连接,Gsn所对应的生成森林T1i=1C1i+∪n∪xEi.以不饱和边集合Eus=Ei,生成森林集合T=T1作为算法P-SNCD的输入,从其步骤(6~8)开始执行.将新生成的社区C1生社区按照层次结构构成y棵树形成的森林加入到HOT的root节点之下以替换HOT中x棵分别以L1root节点的子树.1,…,L1x(对应的社区分别为C1证明.分n=0和n>0两种情况进行证明.(1)当n=0时,即增加节点va到Gsn没有引入(2)当n>0时,即增加节点va到Gsn引入新的边集合{e1a,…,ena}.假设新引入的边e1a,…,ena分别与第1级别社区集合C1中的x(xn)个社区C1C1x中的节点相连接.一方面,对于C∈(C1-i=1C1i),因为C中不存在节点v使得v与va相连∪x且已经是最大扩展,所以添加边集合{e1a,…,ena}中的任何边都无法使得C进一步扩展.另一方面,对于C∈{C1节点v∈C和va的边,那么对于Gsn的生成森林T1添加节点va便得到了Gsn=Gsn+va+{e1a,…,ena}所对应的生成森林T1如果ea的权值wea2,那么以ea为“种子边”形成的社区与C共享节点v,所以增加节点va将可能导致社区C进一步地扩展.假设∪x含的所有不饱和边集合为Ei,以不饱和边集合Eus=Ei,生成森林集合T1入,从其步骤(6~8)开始执行.假设在步骤(6~13)的输出为C1证明C∈(C1-∪x1,…,C1C11,…,C1C1区C1树形成的森林加入到HOT的root节点之下,以替换HOT中x棵分别以L1为C1Page8网络Gsn所对应的新的层次化社区树HOT.证毕.定理4.假设社会网络Gsn=(V,E,W)所对应的层次化社区树为HOT,对于vd∈V以及与vd相连接的边集合{e1基础上删除节点vd以及与其相连接的边集合{e1d,…,emd}后所形成的社会网络Gsn=Gsn-vd-{e1d,…,emd}所对应的层次化社区树为HOT,那么构造HOT只需要HOT的基础上进行如下操作:(1)如果m=0时,HOT=HOT;否则转入(2).(2)在HOT的第1层节点所对应的社区上搜索节点vd,如果对于i∈{1,…,n1}都有vdV(C1i),那么有HOT=HOT成立;否则(即i∈{1,…,n1}使得vd∈V(C1i))转入(3).(3)假设删除与C1i相对应的生成树(森林)T1i中的节点vd及其与vd相连接的边后所形成的生成森林为T1i=T1i-vd-{e1包含的不饱和边集合为Ei.以不饱和边集合Eus=Ei,生成森林集合T=T1i作为算法P-SNCD的输入,从其步骤(6~8)开始执行.将新生成的社区C1…,C1y(y|Ei|)及其派生社区按照层次结构构成y棵树形成的森林加入到HOT的root节点之下,删除HOT中以L1i(对应社区C1i)为root的子树.证明.对于vd∈V,在删除节点vd的同时也删除了与该节点相连接的所有边集合.假设与节点vd相连接的m(0m|E|)条边形成的集合为{e1d,…,emd}.由算法P-SNCD生成社区的过程可知,社区生成过程是由低级别到高级别的过程,高级别社区所包含的节点集合是派生出这个社区的上一级社区所包含节点集合的子集.因此,如果vd出现在某个社区Cl必定存在某个1级别社区C1i(1in1),使得vd∈V(C1i)成立.下面对是否存在这样的一个1级别社区C1i使得vd∈V(C1i)分两种情况讨论.(1)当被删除的节点vd不在任何第1级别社区中出现(m=0时属于这种情况),即对于i∈{1,…,n1}都有vdV(C1i)成立,那么显然删除节点vd不会对任何社区产生影响.(2)当被删除的节点vd落在某个第1级别社区中,即i∈{1,…,n1}使得vd∈V(C1i)成立.由定义2和定义3可知,任何相同的节点不会出现在同一级别的两个不同社区中,因此在所有第1级别社区中,除社区C1i外的其它社区不会包含任意e∈{e1emd}.进一步,删除节点vd不会对社区C1i及其派生社区外的任何其它社区结构产生影响.假设删除生成树(森林)T1i中的节点vd及其与vd相连接的边后所形成的生成森林为T1包含的不饱和边集合为Ei,C1i-{e1的不饱和边集合为Ei,那么必定有T1成立.以不饱和边集合Eus=Ei,生成森林集合T1作为算法P-SNCD的输入,从其步骤(6~8)开始执行将生成y(0y|Ei|)个第1级别社区C1以及这些社区所派生的高级别社区.因为T1T1i∩EiEi,所以必定有C1立.进一步,C1何1级别社区存在交集.因此,将新生成的社区1,…,C1C1形成的森林加入到HOT的root节点之下并删除以L1i为root节点的子树,将构造出社会网络Gsn所对应的新的层次化社区树HOT.假设动态社会网络Gsn在t0时刻为Gsn=(V,E,W),在t1=t0+Δt时刻为Gsn=(V,E,W),那么与t0时刻相比,Gsn在t1时刻新添加的节点集合Va=V-V,被删除的节点集合Vd=V-V.如果用EVa表示在Gsn中与节点集合Va中任意节点有连接的边集合,用EVd表示在Gsn中与节点集合Vd中任意节点有连接的边集合,那么与t0时刻相比,Gsn在t1时刻新增加的边集合(不算增加节点集合Va而增加的边)Ea=E-E-EVa,被删除的边集合(不算删除节点集合Vd而删除的边)Ed=E-E-EVd.算法1给出了动态社会网络社区发现算法D-SNCD的形式化描述.算法D-SNCD运行时首先根据t0时刻的Gsn和t1时刻的Gsn计算出新增的节点集合Va,新增的边集合Ea,删除的节点集合Vd,删除的边集合Ed(对应步骤1).步骤2~7对结构可能发生变化的社区进行标识,对于不同标识的社区采用不同的计算方法.由于定理1~定理4保证了节点和边的变化对层次化社区树HOT结构影响的局部性,通过算法D-SNCD步骤8~26,只对受节点和边的变化而使得结构受影响的第1级别社区及其后续派生社区重新计算,保证了算法本身的高效性.由于整个算法执行过程不需重复计算与上一时刻相比社区结构不受影响的社区,因而D-SNCD算法可以看成对算法P-SNCD生成的HOT的一种高效更新算法.算法1.动态社会网络社区发现算法D-SNCD.Input:(a)SocialnetworkGsn=(V,E,W)attimet0Page9Output:Thecommunitysetwiththelevelbelowhin1.Va←V-V;Vd←V-V;Ea←E-E-EVa;Ed←2.foreachva∈Va,vd∈Vd,ea∈Ea,ed∈Ed3.foreachC∈C1whereC1isthe1stlevelcommunityE-E-EVd;4.ife∈EVa∩v∈Cmakeseconnectingvaandv5.elseifvd∈C{C.tag←C.tag∪“Del-vertex”}6.elseifed∈C{C.tag←C.tag∪“Del-edge”}7.elseifeaconnectstwovertexsofC{C.tag←8.LetC1a1,…,C1ambethecommunitieswith1a1,a2,…,amn1andi∈{a1,a2,…,am}C1C1i.tag.contains(“Add-vertex”);LetEusbetheun-saturatededgesetofC1a1,…,C1am;LetEabethesubsetofEawitheachea∈EaconnectstwovertexsofC1i(i∈{a1,a2,…,am});9.T←T110.CallP-SNCDfromsetp(6~8)withTandEusas11.LetC1b1,…,C1bnbethecommunitieswith1b1,12.T←T113.CallP-SNCDfromsetp(6~8)withTandEusas14.LetC1c1,…,C1cpbethecommunitieswith1c1,15.T←T116.CallP-SNCDfromsetp(6~8)withTandEusas17.LetC1d1,…,C1dqbethecommunitieswith1d1,18.T←T119.CallP-SNCDfromsetp(6~8)withTandEusas20.LetEabethesubsetofEawitheachea∈Eacon-21.T←T122.CallP-SNCDfromsetp(6~8)withTandEusas23.Let{C124.Deletenodeswhichcorrespondtothecommunityof25.Addnodeswhichcorrespondtothecommunityof26.CallP-SNCDfromstep(6~8)withCr∈{C1算法时间复杂度分析算法D-SNCD是对算法P-SNCD生成的层次化社区树HOT的一种动态更新算法.在更新过程中对于与ti时刻相比社区结构不会发生变化的社区,D-SNCD算法在ti+1时刻的计算任务上对HOT进行剪枝.同时,在ti+1时刻对于HOT中需要重新计算的社区,D-SNCD算法通过调用P-SNCD算法的方法进行.显然D-SNCD的算法具有与P-SNCD算法相同的时间复杂度.假设由社会网络形成的多重图Gsn的边规模为|E|=m,节点规模为|V|=n,那么当Gsn为稀疏图且处理器规模为O(hn2)或Gsn为稠密图且处理器规模为O(hmn)时,算法D-SNCD的计算复杂度为O(logn).6实验结果针对BSP并行计算模型,本文实现了D-SNCD算法,并通过“DBLP”和“新浪微博”两个实际数据集对算法的效果和性能进行验证.在整个测试过程中设置参数h=,目的是让程序计算完所有级别的社区后自动退出,以获取给定数据集中所有级别的社区集合.实验平台为由百兆以太网互联的PC机群,共包含32台PC(双核处理器2.8GHz,内存2GB).操作系统为32位WindowsXP专业版,并行环境为MPICH2-1.1.1.6.1案例学习DBLP论文合著关系网络①是由德国特里尔(Trier)大学建立的一个计算机类期刊和会议论文集的数据库系统,为用户提供权威的论文数据和方①http://www.informatik.uni-trier.de/~ley/db/Page10便的查询服务.本文下载并解析该站点提供的在2010年7月份之前被40个与数据库系统、数据挖掘、数据流等领域相关的国际会议(包括sigmod、vldb、kdd、ckde等)所收录的论文49231篇,其中合著作者50396位.由上述合著作者之间形成的社会关系网络下面统称为合著关系网络.为了对合著关系网络不同合著作者之间的权重进行合理赋值,本文将合著关系网络中作者之间的最终权值关系形成过程看作投票过程.每一篇合著表2不同策略下的权重赋值方案StrategyA1-B-A2A1-B-A3A1-B-A4A2-B-A3A2-B-A4A3-B-A4A1-B-OAStrategy13Strategy23Strategy34Strategy44在表2中,Ai-B-Aj(1i<j4)对应的列为α(α>Z+)表示对于DBLP数据集中任意一篇合著文章,如果文章的第j作者存在的话,第i作者与第j作者之间的关系权重值增加α;否者第i作者与第j作者之间的关系权重值维持不变(增加0).同样,A1-B-OA对应的列为β(β∈Z+)表示在合著作者个数大于等于5的情况下,第1作者与第5及其以后的合著作者之间的关系权重值增加β,否则第1作者与第5及其以后的合著作者之间的关系权重维持不变.由此可见,每一篇合著作者数大于1的文章都将使得这些合著作者之间的关系权重值增加.对于那些经常在一起合著论文的作者,通过采取表2中的关系权重赋值策略将会使得这些合著作者之间累计较高的关系权重.图5给出了采用D-SNCD算法分别在4种不同权重赋值策略下不同级别社区数量与社区大小的分布曲线.从图5(a)~(d)不同策略下不同级别的社区数量与社区大小的分布曲线可以看出,采用D-SNCD算法得到的社区摆脱了传统的采用“模块度”定义存在内在的分辨率限制[24-25].如果不考虑社区规模最大的那个点(下面统称为OuterPoint),在4种不同的权重赋值策略下,不同级别的社区大小与社区数量成明显的幂律分布,其中第1级别社区的Strategy1(图5(a))和第10级别社区的Strategy2(图5(c))表现得最为明显,幂指数分别为2.87和2.15.另外在4种不同策略下,其它不同级别的社区数量和社区大小也表现出这种相同的分布特性(因篇幅有限,未在这里一一给出).在每种策略下,不同级别的社区都包含一个作者数目比较大的社区(对应图5的论文相当于一轮投票,在任意一轮投票中,如果第i合著作者与论文的第1作者署名排序中靠得越近,则论文第i作者和第1作者之间的关系权重将获得较高的投票.另外,通过对合著关系网络进行统计发现,论文的合著作者数小于等于4的论文数占论文总数的88.5%.基于以上考虑,为了挖掘合著关系网络的社区及社区分布特性,表2分别给出了4种对合著关系网络中合著作者之间的关系权重赋值策略.0101OuterPoint),而且这个最大社区所包含的作者数随着社区级别的上升而不断减少.比如在4种不同策略下第1级别,第5级别,第10级别,第20级别的最大社区平均所包含的作者个数分别为16104、4065、487、148.出现这种现象的原因有两个:首先,算法运行过程就是寻找包含指定数量的生成树(这里的生成树数量就是社区的级别)的最大子图过程,这使得算法在开始时将一些没有直接合作关系但是有间接合作关系的作者划分到同一个社区中,并且随着社区级别的上升,算法最终倾向于将具有直接合作且合作关系紧密的作者划分到同一个社区中;其次,在处理DBLP数据集时由于没有进行重名处理,这使得原本独立的多个社区因为存在同名作者而被合并成一个,并且随着计算的进行这种现象出现“叠加效应”,最后形成个别规模极大的社区.另外,通过对图5(a)~(d)所示的不同级别社区中的合著作者进行统计分析发现,绝大部分社区中的合作作者数不超过6位.在图5所示的4种不同权重赋值下第20级别社区中,作者数量不超过6位的社区数占该级别社区总数的95.2%,并且这个比值随着社区级别的上升而略有增加.只有少数的社区拥有10位以上的作者,平均约占整个社区数目的1.8%,并且这个比值随着社区级别的上升而略有下降.这表明大多数作者都是以较小团队形式进行研究,并且团队成员之间合作较为紧密,而大团队“集体作战”的情况较少且大团队合作成员之间与小团队合作成员相比合作紧密程度较低.随着社区级别的上升,属于同一社区的作者之间将拥有更加紧密的合作关系.表3给出了在Strategy2和Strategy3Page11权重赋值方案下第50级别的所有社区(在Strategy2方案下的社区数量为10个,在Strategy3方案下的图5在不同级别社区中的社区数量与社区大小分布表3不同策略下的第50级别社区及其社区成员PhilipS.Yu,Ming-SyanChen,Kun-LungWu,CharuC.Aggarwal,BugraGedik;YufeiTao,DimitrisPapadias;NikosMamoulis,ManLungYiu;WeiWang,JiongYang;VivekR.Narasayya,SurajitChaudhuri;RamakrishnanSrikant,RakeshAgrawal;Hans-PeterKriegel,PeerKrger;LeiChen,XiangLian;AmrElAbbadi,DivyakantAgrawal;ShojiHirano,ShusakuTsumoto;WeiWang,JiongYang;XiangLian,LeiChen;Wen-SyanLi,K.SelukCandan;ShusakuTsumoto,ShojiHirano;JimMelton,AndrewEisenberg;图6给出了在不同策略下,合著关系网络的不同级别社区所包含的社区数量分布曲线.由图可以看出,在4种不同的策略中,采取Strategy4所生成的社区级别跨度最大,其最高级别社区为86;而采取Strategy1所生成的社区级别跨度最下,其最高级别社区为67.这是因为在相同作者数目的合著网络中,采用Strategy4关系权重赋值方案使得这个合著网络中作者之间的关系表现得更加紧密(拥有权值更大的边),从而在生成的社区上表现出某些作者将同时出现在更高级别的社区中.另外,通过图6社区数量为13个)以及每个社区中的成员名单,其中同级别的相邻社区用不同颜色进行区分.还可以看出在这个合著关系网络中,相同级别的社区数量随着社区级别的上升而递减并且大概在第5级别左右出现急剧下降,整个社区级别与社区数量关系曲线表现出明显的“长尾现象”,这种特性也同时出现在很多其它类似的复杂系统中[27].另外从图6还可以看出,在4种不同权值赋值策略下所形成的曲线图前端都有一个先递增然后递减的“拐点”,这个拐点大多出现在第2级别和第4级别之间.目前对于这种现象我们还不能给出很好的解释,造成这种现象的一个可能原因是在合著关系网络Page12中,一方面同一作者在不同论文中的署名的采用不同写法(国外作者名字很多时候会有名称的全拼写法和简写写法两种方式,如RodneyC.Wolff可能简写为RodneyWolff)将本属于同一社区的作者进行了“分割”,从而使得社区数量出现短暂的上升,另一方面如前面所述,随着算法的继续运行,极少数同名作者造成的“叠加效应”合并了一些原本独立的社区.图6不同策略下的不同级别社区包含的社区数量分布6.2算法性能新浪微博①是目前国内比较流行的一个社交网络平台.采用本课题组开发的“YHPODS银河博思网络舆情管理平台”对新浪微博进行解析.从2010.5.1~2010.5.3,历时3天,共采集ID(帐号)80多万个,“关注关系“和“粉丝关系”380多万条.在该社交网络中,对于任意的两个博主A和博主B,假设博主A关注博主B,那么博主A和博主B之间的增加一条权值为1的边.如果博主A在关注博主B的同时,博主B也关注博主A(即博主A和博主B互为粉丝关系),那么博主A和博主B之间的权值在原来的基础上增加权值w2(本文取w2=5).为了测试D-SNCD算法性能,利用“YHPODS银河博思网络舆情管理平台”[10]对新浪微博关系网络Gs0每天进行一次快照(实际上就是控制网页爬虫重新爬取原来的新浪微博关系网络,为了保证快照的及时性,我们在工作主机数量和线程数量两个方面增加了爬虫的并行性.),时间从2010.5.4~2010.5.9历时6天.由于在t0时刻的新浪微博关系网络中的部分好友关系或者粉丝关系随着时间的推移有可能发生变化,因而通过上述过程得到在t1,t2,t3,t4,t5,t66个时刻与原来(t0时刻)的新浪微博关系网络相关的不同时期的新浪微博关系网络Gs1,Gs2,Gs3,Gs4,Gs5,Gs6.图7给出了分别对Gs0,Gs1,Gs2,Gs3,Gs4,Gs5,Gs6采用P-SNCD算法和D-SNCD算法,以及对Gs0,Gs2,Gs4,Gs6采用D-SNCD算法在16台计算机上并行处理时间关系曲线.由图7可以看出在处理Gs0时,P-SNCD算法和D-SNCD算法运行时间一样,这是因为D-SNCD算法在处理每一个快照时都要以已经处理过的最近快照为参考,对于t0时刻的新浪微博关系网络Gs0,D-SNCD算法需要直接调用P-SNCD算法进行计算,以获得Gs0对应的层次化社区树HOT相关信息.另外,在时间间隔为1天(interval=1day)的情况下,采用D-SNCD算法对连续6天的新浪微博关系网络(Gs0~Gs6)进行计算比直接使用P-SNCD算法在运算时间上减少60.9%,而在时间间隔为2天(interval=2days)的情况下,采用D-SNCD算法计算6天内的新浪微博关系网络(Gs0,Gs2,Gs4,Gs6)比直接使用P-SNCD算法在运算时间上减少44.1%,这充分说明了采用D-SNCD算法对HOT进行动态更新的有效性.对于新浪微博关系网络采用D-SNCD算法运行时间随着间隔天数的拉长而增加的原因是:随着间隔时间的增加,在ti(1i6)时刻的新浪微博关系网络Gsi发生动态变化的节点集合和边集合将逐渐布满了ti-1时刻Gs(i-1)对应的HOT的第1级别社区的各个社区,因而HOT中需要更新的分支也随之增加.随着间隔时间的不断拉长,对于连续时间间隔的新浪微博关系网络,采用D-SNCD算法的运行时间最终趋向与直接采用P-SNCD算法的运算时间.另外在计算相同的数据集时,分别采用P-SNCD算法和D-SNCD算法得到的结果完全一致,这进一步表明了D-SNCD算法的正确性.图7P-SNCD算法和D-SNCD算法性能比较7结束语社区发现是社会网络研究领域的一个重要研①http://t.sina.com.cn/Page13究方向.针对现有的社区发现方法存在的弊端,本文在层次静态社区并行分解算法的基础上进一步提出了一种新型的层次化社区发现方法D-SNCD.D-SNCD算法是对P-SNCD算法生成的HOT分支进行选择性的更新算法,能够并行高效地处理大规模动态社会网络.严格的数学证明与充分的实验数据保证了算法的正确性和有效性.
