Page1一种QoS最优的语义Web服务自动组合方法邓水光1)黄龙涛1)吴斌1)尹健伟1)李革新2)1)(浙江大学计算机科学与技术学院杭州310012)2)(温州大学智能信息系统集成研究所浙江温州325025)摘要针对海量的信息提供类(InformationProviding)语义Web服务的自动组合问题,提出了一种将正向搜索与逆向搜索相结合并追求QoS最优的快速组合方法.该方法首先根据用户的请求对服务库中的服务进行层次划分,去除无关服务并得到具有并行调用结构的组合服务原型即规划图;之后,利用得到的参数的服务源信息,计算每个服务的最优组合QoS;最后,以用户请求的输出参数为起点进行逆向搜索,以最优组合QoS为约束条件构造所有可能的最优解.以WS-Challenge2009提供的竞赛集进行实验,结果表明该方法不仅能够找到组合服务的最优QoS,而且可以获得大量结构不同但QoS均为最优的解,从而为组合服务的执行提供更多的选择.关键词Web服务自动组合;QoS;正向搜索;逆向搜索;规划图1引言近年来,Web服务作为一种随时可被用户访问的互联网资源,可以方便地满足用户需求.即使在单Page2义化,语义信息为服务的功能描述提供了统一规范;(3)服务的QoS(QualityofService)受到关注,QoS成为用户在使用服务时考虑的重要指标;(4)云计算环境下服务执行环境更为复杂多变,原本可用的服务在某些特定环境下可能变得无法使用,因而带有更多执行方案的组合服务将显得更加可靠.在此背景之下,如何快速地从海量服务中得到尽可能多的既能满足用户需求又具有最优QoS的组合服务将是云计算趋势下Web服务自动组合问题的研究重点.Web服务自动组合问题作为服务科学中的一个研究热点,吸引了国内外众多研究者对其展开深入研究.较为成功的自动组合方法基本上都是在各类AI规划技术之上实现的.AI规划方法取得成功的主要原因在于服务自动组合和AI规划在问题本质上的一致性.自动组合问题可以等价地转化为各类AI规划问题(如情景演算[1-2]、状态空间[3-6]、问题归约[7-9]、自动定理证明[10-12]、约束满足[13-14]以及规划图问题[15-22]等),因而利用现有的AI规划系统或是规划算法来解决Web服务自动组合问题是一种有效的求解手段.普通的AI规划方法(规划图方法除外)可以对各类服务进行建模(包括信息提供类服务(InformationProvidingServices)和状态改变类服务(WorldAlteringServices)),并利用启发式信息[3-4]对组合过程进行指导以提高效率.尽管如此,在海量服务集中,由于搜索空间的快速膨胀,普通AI规划方法也无法在理想时间内给出问题的解,效率提升仍是目前普通AI规划方法亟需解决的主要难题.因此,目前普通AI规划方法适用于解决服务建模需求复杂但服务规模不大(千量级服务)的Web服务自动组合问题.基于并行分层思想的规划图方法通常只对信息提供类服务进行建模而不考虑服务对世界状态的改变.尽管建模能力有限,但由于信息提供类服务仍是目前互联网中Web服务的主要类别①,这类方法有着广阔的应用范围.这类方法在正向搜索时可以利用信息提供类服务允许并行执行的特点使若干服务可以在一次搜索扩展中被同时考察,从而可以大大缩减搜索的宽度和深度,进而可以在毫秒级时间内从海量服务中(万级服务)找到符合用户需求的组合服务原型,这是该类方法取得成功的主要原因.随后,该类方法通过逆向裁剪去除组合服务原型中对生成目标无关的节点,最终得到完整有效的组合服务.因此,基于并行分层思想的双向搜索方法适用于解决海量信息提供类Web服务的快速组合问题.QoS最优的Web服务自动组合问题在传统服务自动组合问题的基础上对解增加了QoS最优的限制.针对该问题并以信息提供类Web服务为主要考察对象,本文基于规划图思想提出了一种新的QoS最优的双向三阶段语义Web服务自动组合方法.该方法在保证问题求解的准确率(找到的组合服务QoS要求是最优的)的前提下进一步提高解的完全率(找到的最优组合服务在实际存在的所有QoS最优组合服务中所占的比例).该方法分为三个阶段:正向分层阶段、最优组合QoS计算阶段和逆向全解构造阶段.正向分层阶段根据用户的请求对服务库中的服务进行层次划分,去除无关服务并得到具有并行调用结构的组合服务原型.最优组合QoS计算阶段利用正向分层阶段得到的参数的服务源信息,计算每个服务的最优组合QoS.最后的逆向全解构造阶段以服务的最优组合QoS为约束条件逐步构造出满足用户需求且QoS最优但结构不同的所有组合服务.以国际知名的Web服务竞赛WS-Challenge②提供的最近一次竞赛集(2009)作为实验数据集并以冠军系统的结果数据作为比较对象,本文所提方法不仅在最优组合QoS值的计算方面与冠军系统的结果一致③,且可获得比其更多结构不同但QoS均为最优的解.本文第2节讨论相关工作;第3节对问题的关键概念给出清晰定义;第4节介绍各阶段的主要工作过程;第5节给出实验过程并分析结果;最后是本文的总结和展望.2相关工作近年来,基于QoS的Web服务组合优化研究已经成为面向服务软件工程中的一个重要课题,并且已经从局部最优发展到全局最优,产生了许多相关的创新成果[23-31].文献[3]在启发式函数的设计中考虑了服务QoS的影响,但是由于和QoS相关的计算分量小于1,使得QoS对启发式函数的最终值影响不大,因而求得的解往往也不是QoS全局最优的.文献[6]采用现有的AI规划器来求解QoS最优的服务自动组合问题,但其对组合QoS的计算只考虑了简单的求和方法,由于不同的QoS类别对应着不同的组合QoS计算方法,所以该方法的局限性较大.文献[24]提出了Web服务组合的全局QoS优①②③Page3化问题,并称这个问题是一个NP-hard问题.这篇文章提出了通过局部选取方法实现全局QoS优化.首先利用混合整数规划方法查找满足全局QoS约束的最优分解,然后通过局部选择法找到满足局部约束的具体服务,但是该方法并没有给出应对大规模数据集的性能表现.对于处理大规模数据集,文献[25]提出了一种局部启发式优化方法,通过给每一个任务分配质量约束过滤备选服务,然后从过滤后的备选服务中枚举出所有组合可能找到QoS最优解.该方法可以有效地减少搜索空间、提高组合效率,但是该方法只能找出近似QoS最优服务组合.类似地,文献[26]也提出了一种删减备选服务的方法,该文利用skyline技术筛除掉备选服务集合中不可能出现在最优结果的备选服务,从而减少需要考虑的服务组合情况,但是该方法要求用户提出对每一个任务的具体QoS约束,一旦用户没有显式地提出QoS需求,该方法将不适用.相对于上述方法,本文对于处理大规模服务组合QoS全局优化问题时,同样采用了过滤无用服务的思想来减少搜索空间,但是本文提出的过滤方法并不需要用户提出QoS约束,而是根据服务的可组合性进行功能性过滤.同时为了保证得到全局QoS最优解,本文是在所有有效服务的源服务都已经确定之后计算服务组合的QoS值,以避免局部最优替代全局最优的可能性.在现有的Web服务组合QoS全局最优方法中,基于并行分层思想的规划图方法是本文考察的主要方法.不同于传统的规划图方法,文献[15]没有采用逆向搜索来去除原型中的冗余服务,而是在正向搜索时采用4种去冗余策略来解决非语义的Web服务自动组合问题.该方法旨在能在较短时间内找到一个解,但是无法保证解中不包含冗余服务.文献[16]虽然也是只解决非语义层上的Web服务自动组合问题,但它采用了一种逆向的启发式贪心搜索算法来保证结果中无冗余服务.文献[17]对文献[15]进行了语义上的扩展,但它仍没有解决冗余服务的问题.文献[18]重点讨论了Web服务自动组合问题中的语义匹配问题,它通过概念相似度和预定义的阈值来确定参数间的匹配关系,然而对于阈值选取问题没有给出深入的讨论,因而很难具有实际的应用价值.文献[19]在语义问题上通过概念间的父子类关系来确定参数的匹配关系并对组合服务进行了QoS的考察,但是对组合服务的QoS计算方法只是采用了简单的求和方法.文献[32]提出了基于A算法的启发式搜索方法,解决了考虑服务QoS的自动服务组合问题.文献[33]利用了功能聚类的方法实现了QoS自动服务组合,该方法对功能相似的服务聚类,通过评估不同簇的QoS得出最终的QoS最优服务组合,但该方法无法处理结果过于复杂的服务组合.QSynth[20-21]是旨在解决QoS最优的海量语义服务快速组合问题,并获得WS-Challenge2009竞赛第一名.该系统在正向搜索过程中除了对服务进行并行分层外还对每个有效服务在组合服务中的最优QoS值进行了计算,并对算法的可停机性和最优值的正确性给出了简单证明.它的逆向搜索过程则是根据记录的每个参数的最优源快速生成一个QoS最优的组合服务.实际上,正向搜索结束时得到服务的最优组合QoS值往往不是真正的最优值,因为后层的服务可能可以提供更优的组合QoS值,QSynth解决该问题的方法是使用一个重计算队列用来保存由于某个参数的最优QoS发生更新而需要重新计算其组合QoS值后继服务,并在正向搜索结束后依次对重计算队列中的每个服务进行组合QoS的重计算.在QSynth的基础上,作者又在文献[34]提出了支持可持续性查询的自动服务组合方法.与已有的研究工作相比,本文有如下三方面的创新:(1)本文将QoS值的计算过程放在正向搜索结束之后.因为随正向搜索得到的最优组合QoS值由于对后层服务的依赖关系缺乏感知很有可能不是最优的,而在正向搜索结束之后,有效服务的所有源服务都已经确定,从而可以确保得到全局最优的QoS值.(2)本文提出了采用多轮次更新的方法求得所有服务的全局最优组合QoS值(而非采用重计算队列),同时对该方法的正确性和可停机性进行了严格的理论证明.(3)本文提出的逆向搜索方法能够得到结构不同但组合QoS最优的全部组合服务结果.目前大多数自动服务组合方法只是返回QoS全局最优的一个组合服务,返回全局QoS最优的全部组合服务能够有效应对云计算环境下服务执行环境复杂多变所带来的挑战.3问题定义本节将从语义、服务及QoS等方面对QoS最优的服务自动组合问题给出形式定义.Page4定义1(本体库).本体库OT是一个二元组(1)C为本体概念的集合;(2)T为本体概念间的直接继承关系的集合.若概念c1直接继承自c2,则表示为c1→c2,若概念c1直接或间接继承自c2,则表示为c1c2.本体概念即为服务输入输出参数的语义.本体库可表示为一棵以本体概念为节点、以概念间的直接继承关系为边的树.本文规定子类本体对象可以赋值给父类对象,反之不行.定义2(语义包含).给定两个参数集S和T,对于T中的每一个元素t,如果满足条件:e∈S((et)∨(e=t)),则称S语义包含T,记为ST.3.2服务与组合服务定义3(服务).服务可以表示为一个四元组w=(n,I,O,QoS),其中:(1)n代表服务的名称;(2)I代表服务的输入参数(或本体)的集合;(3)O代表服务的输出参数(或本体)的集合;(4)QoS代表服务的一类QoS属性.通常情况下,一个Web服务可以包含若干操作,但为了简化表述,本文中的服务即代表Web服务的一个操作.服务的输入输出参数对应确定的本体,因此本文不特别区分参数和本体.此外,本文考虑的服务类别主要是信息提供类服务,其特点是服务的输入信息在服务返回之后仍然有效,服务只是在输入信息的基础上提供更多的信息而不会更改输入信息或使输入信息失效.该类服务不仅是目前互联网上存在的Web服务的主要类别(如天气、位置等各种查询服务、翻译服务和各类单位转换服务等),而且也是各类竞赛主要的考察对象.关于服务的QoS的说明请参见后文.3.1语义(C,T),其中:记w的单步执行为S0S1,其中:定义4(服务的单步执行).给定一个服务w,(1)S0w.I,S1w.O;(2)S0,S1是参数的集合.定义5(服务的并行执行).给定一个服务w,记w的并行执行为L0≡>L1≡>…≡>Ln,其中:(1)Lk(0kn)为参数的集合并代表并行执行的层次,且满足条件(L0=w.I)∧(Lnw.O);(2)Lk≡>Lk+1(0kn-1)是w并行执行过程的一个步骤,代表若干子服务单步执行的并行调用,若记这些子服务的集合为LWk,须满足以下条件:w∈LWk((Lkw.I)∧(Lk+1=Lk∪(∪w∈LWk足LWp∩LWq=.(3)p,q(0pn-1∧0qn-1∧p≠q),满服务的单步执行和并行执行均是动态的概念,单步执行代表内部逻辑不可见的服务执行,而并行执行代表内部逻辑可见的服务执行.并行执行的过程是分层进行的(即代表AI规划中的规划图),同一层中的服务可以并行调用(信息提供类服务不改变已有信息状态),服务的输入完全语义包含于当前参数层且服务的输出将被添加到下一参数层中.并行执行的各层服务不存在交集,因而服务的并行执行必不包含环路,可以用一个DAG图(有向无环图)来表示(DAG图可以方便地转换到其它表示形式,如WS-BPEL等),DAG图的节点代表子服务,边代表参数之间的传递关系,即起点服务的某一输出参数可以用作终点服务的某一输入参数.定义6(组合服务).给定一个服务库W,对于确定的服务w(可以不属于W),如果存在w的一个并行执行e,满足条件:w∈e.LWk(w∈W),则称e对应的DAG图为W中能够满足w的一个组合服务并记该组合服务cw=(N,E),其中:(1)N为DAG图的节点集,start和end为N中两个虚拟服务节点,start节点输入为空且输出等于w.I,end节点输出为空且输入等于w.O;(2)E为DAG图的边集,代表服务间参数的可传递关系.3.3服务QoS、组合服务QoS与服务的组合QoS定义7(服务的QoS).服务的QoS是指服务的非功能属性,如平均响应时间、吞吐量、执行花费及服务可信度等等.有关QoS更多分类可参考文献[35].通常情况下,服务组合时考察的QoS属性都是同一类可量化QoS属性[3,6,20-22,36-37],本文也主要考察同类别的QoS属性,对于各类QoS属性混合的情况,可能的解决方案是对各类QoS加权求和.定义8(组合服务的QoS与服务的组合QoS).给定一个组合服务cw,可以通过一定的计算法则(式(1))得到cw的整体QoS,称该QoS为组合服务的QoS.在计算组合服务cw的QoS的过程中得到的每个子服务w的QoS值称为服务w相对于组合Page5服务cw的组合QoS值,简称w的组合QoS值,记为OverallQoScw(w)或Qcw(w).其计算公式为Qcw(w)=F2(F1w∈pre(Qcw(w)),w.QoS)(1)其中,pre为w在cw中的前续服务节点集合,F1,F2∈{∑,∏,MIN,MAX},F取值与QoS类别相关,具体参见表1.特别地,Qcw(start)=0,Qcw(end)即为组合服务cw的QoS值.3.4QoS最优的服务自动组合定义9(服务的最优QoS).QoS属性从最优性角度可以分为两类:正类和负类.对于正类QoS,其值越大越好(如吞吐量和可信度);而对于负类QoS,其值越小越好(如响应时间和花费).定义10(服务的最优组合QoS).给定服务w,相对于功能相同(输入输出相同)的组合服务集CW,w的所有组合QoS中的最优值称为服务w的在组合服务集CW中的最优组合QoS,简称服务w的最优组合QoS,记为bestOverallQoS(w)或B(w).定义11(组合服务的最优QoS).给定功能相同的组合服务集CW,称CW中所有组合服务的QoS的最优值为组合服务的最优QoS.结合定义8和定义10可知,组合服务的最优QoS等价于组合服务中end节点的最优组合QoS即B(end).定义12(QoS最优的服务自动组合问题).已知服务库W和用户请求r(视为一个特殊服务,只包含输入输出参数,但没有QoS属性),求W中满足r的所有组合服务中QoS最优的组合服务.3.5问题举例为了方便对基本概念的理解,图1描述了一个组合问题场景.本体库中共有7个本体,分别用字母O、A、B、C、D、J和K表示,其中A、B、C、D、K直接继承自O,J直接继承自B.服务库中共有5个服务w1、w2、w3、w4和w5.以w1为例,其输入参数为A,输出参数为B,这里考察的QoS为平均响应时间,值为100.用户请求r的输入为A,输出为D.QoS最优的服务自动组合问题即需要找到不仅能满足用户请求且QoS最优的组合服务.针对该示例,虽然服务库中没有能满足该请求的单个服务,但是有两个组合服务能满足该请求,其DAG图如图2所示.图中标明了每个服务的QoS值,start和end为两个虚拟服务节点,其QoS值均为0.对于平均响应时间来说,F1取MAX,F2取∑,因而组合服务a的QoS的计算过程为Qa(w1)=MAX(Qa(start))+w1.QoSQa(w5)=MAX(Qa(start))+w5.QoSQa(wa)=MAX(Qa(w1),Qa(w5))+wa.QoSQa(end)=MAX(Qa(wa))+end.QoS同理可以计算得到Qb(end)=21,因为平均响应时间为负类QoS属性,所以图1的问题场景中QoS最优的组合服务为b,其最优值B(end)=21.4组合过程与算法本文所提方法的总体结构及流程如图3所示,下面就每个阶段分别展开论述.Page64.1正向分层该阶段根据用户的请求将全体服务进行调用层次的划分后得到一个以层次排序的有效服务列表,从而过滤对组合任务无贡献的服务,本文在算法描述中所使用的符号说明见表2.算法符号==等于关系运算Map.putA(x,y)往映射表Map内关键字x对应的项中添加Map.put(x,y)重置映射表Map内关键字x对应的项为yMap.get(x)取出映射表Map内关键字x对应的项break强制跳出循环体continue进入循环的下一次迭代[x,y,z]=[a,b,c]集体赋值,x=a,y=b,z=c局部变量(包括输入参数)该算法以服务集W、本体库OT和用户请求r作为输入,输出有效服务列表activeSvs和参数源表paramSrcMap.其中,参数源表是一个由参数映射到服务集的Hash表,代表每个参数的来源(即所有能输出该参数或其子类的服务).初始时构造代表用户请求中的输入参数的虚拟服务节点start和代表请求中的输出参数的虚拟节点end,并将请求中的输入参数放入表示当前已经搜索得到的参数集cParams中.最初服务集中的所有服务均被标识为未考察,对于每个未考察的服务,分层算法检测它的所有输入参数是否被当前参数集cParams语义包含,如果被包含则将该服务加入列表activeSvs中并添加输出参数的源记录,但如果不被包含则保留它的未考察状态以便在下一轮重新对其进行检测.每轮结束时,总是将该轮添加的activeSvs中的服务的输出加入cParams中.如果一轮结束时,cParams中包含用户请求的所有输出参数,或者没有新的服务被添加到activeSvs中或已经没有未考察的服务,则算法终止.算法1.正向分层算法(forwardSearch).输入:W(服务集),OT(本体库),r(用户请求)输出:activeSvs(有效服务列表),paramSrcMap(参数//根据用户请求r构建两个虚拟服务start和end1.start.I=;start.O=r.I;end.I=r.O;end.O=;//初始化当前参数表cParams和参数源表paramSrcMap2.cParams=start.O;3.foreverypincParams{4.paramSrcMap.putA(p,start);5.}//并行分层6.activeSvs=;7.unCheckedSvs=W∪{end};8.while(unCheckedSvs!=){9.addedParams=;stillUnChecked=;10.foreverysinunCheckedSvs{11.if(cParamss.I){12.activeSvs=activeSvs∪{s};13.foreveryoutins.O{14.paramSrcMap.putA(out,s);15.}16.}else{17.stillUnchecked=stillUnChecked∪{s};18.}19.if(unCheckedSvs.size()==stillUnChecked.size())20.cParams=cParams∪addedParams;21.if(cParamsr.O)break;22.}23.unCheckedSvs=stillUnChecked;24.}25.return[activeSvs,paramSrcMap];4.2服务的最优组合QoS计算在3.5节中,我们得到组合服务的最优QoS的方法是先求得所有的组合服务,然后计算所有组合Page7服务的QoS并根据QoS最优值的正负选取最优值.然而在海量服务库中,针对同一用户请求通常存在大量的组合服务,此时要想计算所有组合服务的QoS就显得极为不现实.事实上,组合服务的最优QoS等价于组合服务中end节点的最优组合QoS即B(end).为计算end的最优组合QoS,我们引入表示服务的最优组合QoS之间依赖关系的计算定理.定理1(服务的最优组合QoS计算定理).已知服务库W中每个参数c对应的源服务,记为SourceSv(c),给定一个服务w,其最优组合QoS值B(w)一定满足递归关系式B(w)=F2(F1i∈w.I(Gsv∈SourceSv(i)(B(sv))),w.QoS)其中F1,F2∈∑,∏,MIN,的计算法则,与QoS的具体类别相关;G∈{MIN,MAX},与QoS最优值的正负性相关,正性QoS取MAX,负性QoS取MIN(该定理的证明参见附录).从定理1可以看出,服务的最优组合QoS的计算方法与QoS的属性类别相关,表3给出了4种不同的计算法则和典型QoS类别的代表.F1F2G典型QoS类别代表∏∏MAX可信度(reputation)MIN∑MAX吞吐量(throughput)∑∑MINMAX∑MIN响应时间(responsetime)以正向分层算法得到的有效服务列表为序,结合定理1,我们可以计算得到每个有效服务的最优组合QoS值.然而严格按照定理1的计算法则有时将无法计算出最优组合QoS值,例如在计算某一服务的最优组合QoS值时,它的某个参数源对应的某个服务源的最优组合QoS值可能是未知的或者只是个临时值.这种情况下,我们暂时忽略未知的最优组合QoS值或者采用临时最优组合QoS值继续进行计算,最后计算得到服务的一个临时最优组合QoS值(称为不完全最优组合QoS值),并把当前计算的服务放入不完全服务队列.在完成一轮的最优组合QoS的计算后,我们再回头对不完全服务队列中的每个服务进行重新的计算,直到不完全服务队列为空或者不完全服务队列中服务的不完全最优QoS值都不再改变,具体算法如算法2所示.算法2.计算最优组合QoS(calBestOver-allQoS).输入:activeSvs,paramSrcMap输出:bestOverallQoSMap(最优组合QoS映射表)1.bestOverallQoSMap.put(start,0);unCompleteSvs=;2.foreverysinactiveSvs{3.unCompleteSvs=unCompleteSvs∪{s};4.}5.firstSvs=unCompleteSvs;6.while(firstSvs!=){7.update=false;secSvs=;8.foreverysinfirstSvs{9.[unCompleteSvs,bestOverallQoSMap,update]=10.if(s∈unCompleteSvs)11.secSvs=secSvs∪{s};12.}13.if(firstSvs.size()==secSvs.size()14.firstSvs=secSvs;15.}16.returnbestOverallQoSMap;算法以正向搜索得到的有效服务列表activeSvs和参数源表paramSrcMap作为输入,将所有有效服务到其最优组合QoS的映射表作为输出.初始化时,将start的最优组合QoS值设为零,并将除start服务外的所有有效服务都放入不完全服务队列unCompleteSvs中.接着不断地对不完全服务队列进行轮次处理,每轮处理过程中都将依次遍历不完全队列中的每个服务并重新计算其最优组合QoS值,对于计算后仍属于不完全最优组合QoS的服务,需要重新将其放入不完全服务队列使其可以在下一轮次再次被计算.如果一轮计算结束后,不完全队列大小不变且每个服务的计算值都不被更新,则强制退出循环操作.对于每个服务的最优QoS值的计算是由算法calBest〈F,G〉实现的,calBest算法体现了定理1中定义的计算法则,具体实现依赖于F1、F2和G的取值(实现参见后文),且一定具备以下性质(证明略).性质1.当G取MAX时,calBest算法对服务最优组合QoS值的更新具有递增性,即最优组合QoS值在计算后将保持不变或变大,从而不断趋近真实值;当G取MIN时,calBest算法对服务组合QoS值的更新具有递减性.Page8算法2的可停机性和正确性证明详见附录.算法2.calBest〈G=MIN,F1=MAX,F2=∑〉.输入:S(待计算的服务),unCompleteSvs(不完全服务输出:unCompleteSvs,bestOverallQoSMap,updateFlag1.vMax=0;vMaxFlag=false;2.foreveryinParamins.I{3.vMin=;vMinFlag=false;srcSvs=4.foreverysrcinsrcSvs{5.srcMin=bestOverallQoSMap.get(src);6.if(srcMin==null)7.vMinFlag=true;8.else{9.if(srcMin<vMin)10.vMin=srcMin;11.if(src∈unCompleteSvs)12.vMinFlag=true;13.}14.}15.if(vMin>vMax){16.vMax=vMin;vMaxFlag=vMinFlag;17.}18.}19.newQoS=vMax+s.QoS;20.if(newQos<oldQoS){21.updateFlag=true;22.}23.if(vMaxFlag==false)24.unCompleteSvs=unCompleteSvs-{s};25.return[unCompleteSvs,bestOverallQoSMap,4.3逆向全解构造该阶段使用之前得到的最优组合QoS映射表,从end节点开始逆向构造组合QoS最优的所有组合服务.由于篇幅限制,这里不对算法展开详细分析(算法实现参见下文算法3和算法3),只简述其要点:(1)构造过程是从end节点向start节点反向递归进行的,每次扩展一个节点的前续节点;(2)在前续节点的选取过程中,以最优组合QoS映射表中记录的最优组合QoS为阈值,只扩展满足阈值限制的前续节点;(3)扩展过程中要考虑节点被重复选取的可能,对于重复的情况,要取最低阈值作为最新的阈值.算法3.逆向全解构造算法(backwardSearch).输入:bestOverallQoSMap(最佳组合QoS映射表)输出:compositeSvs(组合QoS最佳的所有组合服务)1.compositeSvs=;2.open={end};3.closed=;4.thresholds.put(end,bestOverallQoSMap.get(end));5.cDAG=;6.compositeSvs=oneByOne(open,closed,thresholds,cDAG,compositeSvs,bestOverallQoSMap);7.returncompositeSvs;算法3.递归解构造算法(oneByOne).输入:open(待扩展的无源节点),closed(已扩展的有输出:compositeSvs(本次调用结束后找到的解)1.if(open==){2.compositeSvs=compositeSvs∪cDAG;3.}else{4.cSv=open.removeHead();cT=thresholds.get(cSv);5.sources=getSrcsUnderThreshold〈G,F〉(cSv,cT,6.foreverysourceinsources{7.cycleFlag=false;adjustFlag=false;8.foreverysvinsource{9.if(svnextOpensvnextClosed){10.nextDAGaddEdge(sv,cSv);11.if(sv!=start){12.nextOpen=nextOpen∪{sv};13.}14.}15.if(sv∈nextOpen){16.nextDAG.addEdge(sv,cSv);17.if(newT<oldT)18.nextThresholds.put(sv,newT);19.}20.if(sv∈nextClosed){21.cycleFlag=hasPath(nextDAG,cSv,sv);22.if(cycleFlag==true)break;23.nextDAG.addEdge(sv,cSv);Page924.if(adjustFlag==false)break;25.}26.}27.if(cycleFlag==true‖adjustFlag==false)28.compositeSvs=oneByOne(nextOpen,next-29.}30.}31.returncompositeSvs;以上算法中包含的算法getSrcsUnderThreshold计算当前服务cSv的前续节点中满足阈值限制的所有源,具体实现如算法3所示;算法adjust用来调整有源节点的已有阈值.算法3.getSrcsUnderThreshold.输入:cSv(当前服务),cT(cSv的组合QoS阈值),输出:srcsUnderThreshold(满足阈值限制的所有源)1.srcsUnderThreshold=;2.sources=;3.//满足cSv各个输入参数的服务集合之间求笛卡尔4.foreveryinParamincSv.I{5.svrs=getAllSemanticCompatibleSrcSvs(inParam);6.}7.foreverysourceinsources{8.if(G==MIN){9.if(F1(allservicesinsource)<cT)10.srcsUnderThreshold=srcsUnderThreshold∪11.}12.else{13.if(F1(allservicesinsource)>cT)14.srcsUnderThreshold=srcsUnderThreshold∪15.}16.}17.returnsrcsUnderThreshold;在该部分本文将集中对各阶段算法的时间复杂4.4算法时间复杂度分析度进行分析讨论.阶段1的正向分层算法产生了一个符合用户请求的规划图,进而得到了一个有效服务列表.假设整个服务库中的服务个数为N,由于在规划图的生成过程中,每个服务通过考察后只需被处理一次而且每次处理所执行的计算基本上在常数时间内完成,因此该阶段的时间复杂度为O(N).有关正向分层算法的时间复杂度更为详细的讨论可以参见文献[15].阶段2通过轮次计算得到组合服务的最优QoS值,假设有效服务列表中的服务个数为N(这里不是服务库中服务的个数),那么每轮计算至多有N个服务需要被更新.另外,在最坏的情况下,对每个服务的更新操作需要依赖于其它所有服务,因而每个服务的更新操作时间复杂度为O(N),也可得每轮计算的时间复杂度为O(N×N).通常每个服务需要被更新若干轮次后才能达到稳定值,假设所有服务中最大的更新轮次为M,那阶段2的时间复杂度就为O(N×N×M).最后,在一般的逆向解构造过程中,假设有效服务的个数为N,且每个服务前续服务集的平均个数为c,则在最坏情况下,其时间复杂度为(O(cN)).然而,在阶段3中以组合服务的最优QoS作为阈值,去除了可能产生的非QoS最优解,这将大大减少搜索空间,提高搜索效率.5算法实验5.1实验过程本文基于Java语言实现了所有算法,除了在XML的解析模块中采用了SAX相关的软件包外没有采用任何其它第三方软件包,整个实验系统如图4所示.测试集选用的是WS-Challenge2009提供的竞赛集,该竞赛集包含服务规模不同(500~15000个)、本体规模也不同(1000~25000个)的5个测试集,并且每个测试集对应一个层次不同(4~30层)的用户请求.在每个测试集中,都存在4种类型的文件:WSDL文件描述了服务的输入输出参数;OWL文件描述了参数的本体及其关系;WSLA文件描述了服务的QoS;Challenge文件描述了用户的请求.每次实验过程中,我们首先选取一个测试集作为实验Page10系统的输入,然后启动组合规划器进行结果搜索,组合规划器将会对输入文件进行解析生成本体树、服务库和用户请求等内部对象并根据这些对象进行组合搜索,最终系统停止时将得到QoS最优的所有组合服务.此外,实验的硬件环境是ThinkPadX200(2.26GHz×2,3GRAM).为验证所提算法的正确性和有效性,本文分别对各阶段的正确性指标和执行时间进行了记录.对于阶段1,主要考察其层次划分后得到的有效服务的个数;对于阶段2,主要考察组合服务最优QoS的计算值和更新计算的轮次,这里我们以响应时间为QoS的考察类别;对于阶段3,主要考察搜索得到的最优组合QoS的个数.别外,每个测试集重复实验10次,取平均值作为实验结果记录.5.2实验结果与分析5.2.1阶段1的结果与分析阶段1的主要任务是从服务库中找出所有的有效服务,因而实验中我们主要记录了每个测试集中总服务的个数以及有效服务的个数.同时,我们也记录了该阶段所需要的运行时间以便进行时间性能的分析.阶段1的实验结果如图5和图6所示.从以上实验结果可以看出:(1)阶段1可以过滤掉大部分与用户请求无关的服务,最高可达98.44%.特别地,对于超大规模的服务集(如测试集5),进行过滤之后有效服务的个数也通常在几百个左右,这是对算法性能的极大提高;(2)阶段1的运行时间与服务库中服务的个数大体呈现线性关系,这就验证了之前在算法性能分析时得出阶段1时间复杂度为O(N)的结论.5.2.2阶段2的结果与分析阶段2的主要任务是计算组合服务的最优QoS,因而我们记录实验中得到的最优QoS、迭代计算的轮次和本阶段的执行时间.实验中得到的最优QoS可以与WS-Challenge竞赛中其它系统得出的结论作对比,计算的轮次和执行时间可用来作时间复杂度的分析.该阶段的实验结果如表4和图7所示.测试集最优组合QoS迭代次数执行时间/ms0102030405从实验结果可以看出:(1)本阶段都能在极短的时间内完成,原因在于经过阶段1的过滤之后,有效服务的个数只有几百个,这就大大减少了计算复杂度;(2)本阶段计算得到的最优QoS与WS-Challenge竞赛冠军系统所得的结果完全相同(参见后文实验对比部分);(3)该阶段的运行时间与M×N×N的关系基本呈线性(M代表计算轮次,N代表有效服务个数),这也验证了我们在算法性能分析时得到的该阶段时间复杂度为O(M×N×N)的结论.5.2.3阶段3的结果与分析阶段3的主要任务是搜索QoS最优的所有组合服务.最终所得到的组合服务的个数与阈值的设置密切相关,因而我们分别将搜索阈值设为最优组合QoS值和该值的2倍,并记录下不同阈值下的执行时间,从而可以分析阈值对算法性能带来的影响,实验结果如表5所示.Page11测试集QoS最优的组合01202428403049320510013从实验结果可以看出:(1)测试集2、4和5含有大量的QoS最优但结构不同的组合服务;(2)解的个数越多,搜索所花费的执行时间越长,如测试集2、4和5,这是因为解的个数是由有效服务的个数及有效服务的平均前续服务集的个数决定的,在有效服务个数基本相同的前提下,解的个数越多说明平均前续服务集个数越多,那么搜索的宽度越大,这就表6实验对比竞赛集QSynth运行时间/ms实验系统运行时间/msQSynth最优QoS值实验系统最优QoS值QSynth解的个数实验系统解的个数01<30002<30003<30004<30005<300从对比结果中可以看出:(1)实验系统运行时间(这里仅取阶段1和阶段2的运行时间之和,因为这两个阶段完成的任务与冠军系统完成任务相同,即找出QoS最优的一个解)在测试集规模较大时性能稍低于QSynth,这里因为实验系统的目标不仅仅是找出一个QoS最优的解,而是找出QoS最优的所有解,这就需要花费更多的时间在最优源的生成和记录上,从而为第3阶段的搜索做准备;(2)实验系统所得的组合服务的最优QoS值与实际的最优值完全相同,这就说明实验系统最优值计算方法是可取的,也验证了我们对该计算方法在理论上的证明是正确的,而QSynth虽然也能找到最优值,但所提方法未能在理论上给出严格证明;(3)实验系统最终所能找到的解的个数远大于QSynth所能找到的解的个数,这是由WS-Challenge最竞赛的主题(QoS最优的服务自动组合)决定的,显然求解最优的所有解要比求解最优的一个解要困难得多,但拥有更多的最优解将大大提升自动组合系统在云计算环境中的适应性和可用性.6总结与展望本文针对信息提供类语义服务的自动组合问使得执行时间变长,因此针对测试集2和5执行时间较长是由测试集的内部性质决定的,而不是算法性能降低所造成的;(3)针对万级测试集(如测试集4、5),该阶段算法能在毫秒级执行时间内找到所有解,因而算法性能较高;(4)随着阈值的扩大,执行时间大幅上升,这说明阈值限制在算法性能的提升方面起到了关键作用.5.3系统对比目前已有的大多组合系统都很难进行系统执行环境的重建以及实验结果的重新采集,而且不同系统往往采用不同的测试集进行系统实验,这就增加了进行系统对比的难度.本文所提方法是在WS-Challenge竞赛集的基础上进行的,因而可以与竟赛中的冠军系统QSynth进行对比,对比结果如表6所示.题,主要有4个目标:(1)海量.即能够应对万级左右的服务自动组合;(2)最优.即得到的组合服务的QoS是最优的;(3)更多.即能够得到更多结构不同的组合服务;(4)快速.即能够在毫秒级执行时间内得到满足条件的服务结果.其主要贡献有:(1)提出了一种新的最优组合QoS计算方法,对该方法的正确性和可停机性进行了严格的理论证明,并通过实验证实了该方法的可行性;(2)提出了基于最优组合QoS值的全解构造方法,进一步提高了完全率.对于完全率的提高,除了在引言中给出的应对云计算环境下服务执行环境复杂多变的挑战外,其意义还有以下两点:①基于不同的组合结构,可以进行更深层次的逻辑分析,为用户推荐可能的组合服务;②可以作为查找QoS最优的Top-K个组合服务的问题的前提基础.海量服务的自动组合是近年来的一个研究热点,本文提出的方法是解决这一问题的有效尝试.我们相信该方法在具体实现上还存在诸多可优化和提高的地方,例如可以进一步考虑复杂约束条件和多QoS属性下的自动组合,扩大方法的应用范围.致谢在此,我们向对本文的工作给予支持和建议的所有同志表示感谢!Page12
