Page1一种面向测试需求部分覆盖的测试用例集约简技术顾庆1)唐宝2)陈道蓄1)1)(南京大学软件新技术国家重点实验室南京210093)2)(西门子IT解决方案与服务集团南京211100)摘要软件系统开发中频繁面对局部更新和部分缺陷修改,此时需要选择性回归测试;为降低其测试工作量需要解决部分覆盖用例集约简问题.文中基于选择性回归测试形式化定义多目标用例集约简,并设计HATS算法解决该问题.HATS算法遵循启发式贪婪搜索框架,定义权重因子α平衡两方面目标:其一是减少用例集规模;其二是避免对无关需求的覆盖.实验结果表明:同现有约简技术和算法相比较,通过适当设置因子α,HATS算法能够降低用例集规模、减少对无关需求的覆盖、同时缓解对缺陷检测能力的影响.文中的创新贡献在两方面:其一根据选择性回归测试定义多目标用例集约简问题;其二是设计HATS算法以更少的测试用例数量维持缺陷检测效果.关键词软件测试;测试用例约简;回归测试;测试需求集;部分覆盖1引言在软件系统发生变更后或发布新版本前通常需要对软件程序进行回归测试,以确保已有功能或模块没有受到当前变更的负面影响.目前软件系统通常采用迭代式开发,软件升级换代成为惯例,且升级换代的速度不断加快.这使得回归测试成本不断提升.如何在保证检错能力的前提下有效降低回归测试工作量是需要解决的问题.在软件系统迭代开发过程中,测试用例不断被设计、修改和执行,构成回归测试的备选用例集合.在回归测试中,软件程序被视为测试需求的集合.例如从结构角度可以把程序中的语句视为测试需求,回归测试要求达到和备选用例集相同的语句覆盖率.在通常情况下,对给定的测试需求覆盖要求,备选用例集会存在较大的冗余[1].测试用例集约简技术用于从备选用例集中选择较少数量的测试用例构成约简集,同时达到测试需求覆盖.目前研究者提出多种用例集约简技术,这些技术大致可归为3类:启发式贪婪搜索[1-3]、元启发概率优化[4]以及二进制整数线性规划[5-6].根据软件系统的更新程度和范围,回归测试可以有两种形式:选择性回归测试和全面回归测试.前者在软件更新范围有限或缺陷尚未全部修正时执行;而后者通常在新版本发布或更新范围较大且全部缺陷修正后执行.相较于后者,选择性回归测试的执行频度更高,更需要控制测试成本.在选择性回归测试中,测试需求集合可分割为两部分:关注需求集和无关需求集.其中关注需求集需要被回归测试用例覆盖;而无关需求集正相反,需要在选择测试用例时避免覆盖以减少测试执行和分析的工作量.现有的测试用例集约简技术尚未考虑这一问题.本文针对选择性回归测试中测试需求集部分覆盖要求,提出多目标部分覆盖测试用例集约简问题.给出解决该问题的一个启发式贪婪搜索算法———HATS(HeuristicsearchAlgorithmwithThreeStrategies).基于开源软件系统设计的实验结果表明:同全覆盖测试用例集约简技术相比,HATS算法能够进一步较大程度地减少回归测试用例数量,降低对无关测试需求集的覆盖比率,同时基本保证针对关注需求集的缺陷检测能力.2测试用例集约简2.1基本概念描述测试用例集约简问题需要以下基本概念.定义1.备选测试用例集.备选测试用例集T(T={t1,t2,…,tm})是针对目标软件系统设计完成的一组测试用例集合.集合中的用例已执行并构成回归测试的备选用例集.定义2.测试需求集.测试需求集R(R={r1,r2,…,rn})是测试目标软件系统要求覆盖的测试需求集合.测试需求反应软件系统的基本覆盖单元.如从结构角度一个测试需求可以是一条语句或一个函数(过程或方法);从功能角度一个测试需求可以是一个功能项或一个被测特征.定义3.测试覆盖矩阵.测试覆盖矩阵Δ(R,T)是一个|R|×|T|二进制矩阵,定义用例集T到需求集R的覆盖关系.矩阵元素由式(1)定义:为简便起见,我们用δij表示δ(ri,tj),在不引起歧义情况下Δ(R,T)简化表示为Δ.定义4.测试用例的覆盖需求集.测试用例tj的覆盖需求集R(tj)(R(tj)R)是一个测试需求集合,其中包含用例tj覆盖的需求集R中所有测试需求.定义5.测试需求的执行用例集.测试需求ri的执行用例集T(ri)(T(ri)T)是一个测试用例集合,其中包含覆盖(执行)需求ri的用例集T中所有测试用例.定义6.需求集R的代表用例集.需求集R的代表用例集γ(R)(γ(R)T)是一个测试用例集合,其所包含测试用例的覆盖需求集的并集等于(包含)R,即Ut∈γ(R)R(t)R.本文中用例tj的覆盖需求集R(tj)简化表示为Rj,对应覆盖矩阵Δ的第j列;需求ri的执行用例集T(ri)简化为Ti,对应矩阵Δ的第i行;不引起歧义的情况下γ(R)简化为γ.根据上述定义,一个全覆盖测试用例集约简问题可以形式化描述如下:给定备选用例集T和测试需求集R,给定需求覆盖矩阵Δ(R,T),令tj∈T.Rj≠且ri∈R.Ti≠.要求寻找最优代表用例集γ(γT),使得γ所包含的测试用例数量最少.该问题等价于最小覆盖集问题,是一个NP完全问题[7].2.2测试用例集约简技术研究者已经提出多种解决全覆盖测试用例集约简问题的近似算法.这些算法大致可归为3个类别:启发式贪婪搜索、元启发概率优化以及二进制整数线性规划.启发式贪婪搜索技术一般一次选择一个(或多Page3个)局部最佳(如覆盖最大数量的测试需求)的测试用例,排除已经覆盖的测试需求,循环直至所有需求都被覆盖.这类算法中典型的有Harrold等人提出的HGS算法[1]以及Chen等人提出的GRE[2-3]算法.元启发概率优化技术从一个初始的代表用例集(如备选集T)出发,应用全局概率优化算法推算最优的代表用例集.这类算法中典型的是Mansour等人[4]提出的模拟退火算法和混合遗传算法.二进制整数线性规划BIP(BinaryIntegerlinearProgramming)技术[5-6]将用例集约简目标形式化描述为一个成本函数.优化目标是成本值最小,约束条件是所有测试需求都被覆盖.Black等人[5]应用BIP技术解决一个多目标测试用例集约简问题:最小化选择的测试用例数量,同时保留最多数量的曾检测出缺陷的测试用例.解决BIP本身也是一个NP完全问题[8].研究者对不同约简技术的性能做了比较[2,9].其结果是不同类别算法得到的约简集规模基本相当,没有哪个算法能够在所有情况下优于其它算法.其他研究者[10-13]提出针对不同需求类型的特定的约简算法,并同HGS算法等做了比较,也得到类似的结论.3测试需求集部分覆盖3.1问题定义面对局部范围的软件改动或部分缺陷的修正,选择性回归测试是理想选择.在选择性回归测试下,测试需求集被分割为关注需求集和无关需求集.有如下定义.定义7.关注需求集.关注需求集CR(CRR)包含本次选择性回归测试中必须覆盖的测试需求,同最近的软件改动和修正相关.定义8.无关需求集.无关需求集包含本次选择性回归测试不需要覆盖的测试需求,同最近的软件改动和修正无关.无关需求集可标记为R-CR.其中“-”操作的定义是:给定集合A和B,A-B={x|x∈A∧xB}.根据上述定义,针对测试需求集部分覆盖问题可以形式化定义一个多目标测试用例集约简问题,表述如下:给定备选用例集T、测试需求集R和关注需求集CR,给定需求覆盖矩阵Δ,令tj∈T.Rj≠且ri∈R.Ti≠.要求寻找关注需求集的最优代表用例集γC,满足目标1.γC中测试用例数量最少,即min(|γC|);目标2.无关需求的覆盖数量最少,即mini,j(|{ri|ri∈R-CR∧(tj∈γC.δij==1)}|).3.2问题阐述Chen等人在介绍其TestTube工具[14]时提出类似关注需求集的概念,他们的设计是在修正软件缺陷时确定同该缺陷相关的测试覆盖单元集合(即本文的关注需求集),然后根据确定的需求集寻找合适的测试用例.他们没有考虑测试用例集约简问题.在测试需求集部分覆盖问题中,测试需求集分割为关注需求集和无关需求集.选择测试用例时要求覆盖关注需求集,同时要求避免覆盖无关需求集.这个约简策略基于以下三方面考虑:其一选择测试用例时只要求覆盖部分测试需求,约简集规模相对于全覆盖可以进一步减少,从而降低回归测试工作量和成本.其二避免覆盖无关的测试需求可以有效减少测试分析的工作量,因为没有涉及无关的测试需求和代码;另一方面一些状态为“挂起”的缺陷没有立刻修复,避免覆盖相关需求可以减少额外的用于“关闭”这些缺陷的代码.其三选择性回归测试增加了软件系统的可测试性,尤其是在软件开发的前期,部分组件尚未完成;如果能够避免覆盖和这些组件相关的测试需求,则只需补充简单的测试“桩”就可以实施已完成组件的回归测试.上述思想在西门子公司内部软件开发项目测试中已得到了验证.4HATS算法4.1启发式贪婪搜索框架多目标测试用例集约简问题仍然是一个NP完全问题.解决该问题可采用如下的启发式贪婪搜索框架:1.采用一种策略从当前备选用例集T中选择最合适的一个或多个测试用例;2.将所选用例从T中移出并置入输出(约简)集;3.从关注需求集CR中移除已覆盖的测试需求;4.重复上述步骤直至CR为空集.步1中可采用以下3种策略之一:贪婪策略、必针对多目标测试用例集约简,一个简单的贪婪选策略和替代策略.4.2贪婪策略策略可以描述如下.策略1.选择当前最“合适”的测试用例tj(tj∈T∧tjγC),覆盖“尽可能”多的关注测试需求,同时覆盖“尽可能”少的无关测试需求.Page4这里的折中问题是覆盖较多关注需求的测试用例通常也会覆盖较多的无关需求.这引出以下两个指标定义不同方面的覆盖情况.定义9.贡献指标.令当前尚未覆盖的关注需求集合为cur_CR,测试用例tj的贡献指标(标记为j)定义为tj所覆盖的关注需求占cur_CR的比例.用式(2)表示:定义10.损益指标.给定无关需求集R-CR,测试用例tj的损益指标(标记为υj)定义为tj未覆盖的无关需求占R-CR的比例.用式(3)表示:贡献指标反映给定测试用例对关注需求的覆盖情况,而损益指标反映该测试用例对无关需求的避免情况.一个理想的测试用例应该同时具有较高的贡献指标和损益指标,但通常难以兼得.为反映两个指标的权衡,我们定义权重因子α(0α1),通过加权平均定义以下指标.定义11.效用指标.给定权重因子α,测试用例tj的效用指标(标记为ωj)定义为其贡献指标j和损益指标υj的加权平均.用式(4)表示:通过对α的不同设定可调整对不同目标的偏重.基于效用指标,贪婪策略可描述如下.策略2.对当前备选集中所有测试用例,计算其效用指标.从中选择具有最大效用指标的测试用例tj.4.3必选策略和替代策略为描述这两个策略,我们有以下定义.定义12.必选测试用例.给定当前的备选用例集T,测试用例tj是测试需求ri的必选测试用例(标记为essi)当且仅当tj是T中唯一覆盖ri的测试用例.定义13.替代集.给定当前的关注需求集cur_CR和初始关注集CR,测试用例tj存在替代集(标记为SUPj)当且仅当对任意tk∈SUPj,其覆盖需求集满足Rj∩cur_CRRk∩cur_CR并且Rj∩(R-CR)Rk∩(R-CR).给定关注需求ri,其必选测试用例essi(如果存在)是当前唯一覆盖ri的测试用例,据此可以描述必选策略如下:(1)对当前尚未覆盖的一个关注需求,若其存给定备选测试用例tj,若tj存在替代集,表示存在必选测试用例,则该用例被选择.在备选测试用例tk,tk覆盖的关注需求包含tj覆盖的关注需求,而tk覆盖的无关需求又被tj覆盖的无关需求所包含.这说明tk可以替代tj,据此描述替代策略如下:(2)对当前一个备选测试用例,若其存在替代集,则该测试用例可以从备选用例集中删除.上述策略同GRE算法中的用例筛选策略类似,但可用于多目标测试用例集约简技术中.针对必选策略和替代策略不难证明有以下定理.定理1.在启发式贪婪搜索框架下,给定尚未覆盖的测试需求ri(即ri∈cur_CR),若ri存在必选测试用例essi,则essi必被选入约简集γC.证明.因为essi是当前备选集中唯一覆盖关注需求ri的用例;而关注集中的所有需求必须被约简集γC中的某个测试用例覆盖;所以有essi∈γC.定理得证.引理1.在启发式贪婪搜索框架下,给定当前尚未覆盖的关注需求集cur_CR,若备选集中测试用例tj存在替代集,则不选择tj而是选择其替代用例(如tk)进入约简集γC将使得新约简集相对于部分覆盖约简目标等同或更优.证明.tj已被选入γC,分两种情况:(1)如果tj和tk同时被选入γC,那么tj属于冗余,直接删除tj会减少|γC|,从而使新的γC相对于目标1更优;(2)如果tk没有被选入γC,那么将tj替换为tk仍然满足对CR中所有需求的覆盖,同时对无关需求的覆盖程度相等或更小,因此新的γC相对于目标2等同或更优.引理得证.定理2.如果采用启发式贪婪搜索框架,仅使用必选策略和替代策略就可以得到约简集γC,那么所得到的γC相对于部分覆盖约简目标最优.证明.反证法.假设存在γC比γC更优,那么有|γC||γC|.按启发式搜索框架,可将γC中的测试用例按选择顺序排序.不失一般性,令γC={t1,t2,…,t|γC|},其中测试用例tj或者是唯一一个覆盖某关注需求的用例;或者经过替代策略筛选后成为某关注需求的必选用例.将γC中用例tj同γC中用例tj匹配,匹配原则是:或者tj≡tj,或者tj覆盖tj唯一覆盖的需求,直至γC为空.匹配后寻找第一个不相同的测试用例.存在3种情况:(1)第一个用例不相同,即t1≠t1.此时t1必然是t1的替代用例;根据引理1,用t1替代t1所得约简集仍然最优;(2)第j(j>1)个用例不相同,即tj≠tj.在选定Page5{t1,…,tj-1}后,尚未覆盖的关注需求集构成cur_CR,其中的关注需求不可能为{t1,…,tj-1}所能够替代的测试用例覆盖.因此tj依然是(或成为)tj的替代用例;根据引理1,用tj替代tj所得约简集仍然最优;(3)第j个用例不能匹配.表明存在tk(tk∈γC∧k<j)覆盖了tj唯一覆盖的关注需求.这说明tk相对于tk覆盖了更多的关注需求,tk不能成为tk的替代用例,从而也不能成为相应需求的必选用例.这同γC的构成原则矛盾.由于第(3)种情况不能成立,按第(1)和(2)两种情况得出γC至少和γC相对于部分覆盖约简目标等同,这同假设矛盾.定理得证.实际的约简过程可能无法达到理想状态,即在约简过程中存在必选策略无法应用的情况.此时需要使用贪婪策略选择当前效用指标最高的测试用例,所得到的约简集不再是最优.4.4算法描述HATS算法遵循启发式贪婪搜索框架,应用必选策略、替代策略和贪婪策略完成部分覆盖测试用例集约简.算法描述如图1所示.算法HATS输入:R:测试需求集T:备选测试用例集CR:关注测试需求集Δ:|R|×|T|二进制覆盖矩阵α:权重因子输出:γC:约简集变量:cur_CR:当前尚未覆盖的关注需求集cur_T:当前备选测试用例集cur_Select:本次选择的测试用例集Rj:用例tj的覆盖需求集begin/初始化/γC=;cur_CR=CR;cur_T=T;while(cur_CR≠)/替代策略/foreach(tj∈cur_T)基于cur_T计算SUPj;if(SUPj≠)cur_T=cur_T-{tj};endifendforcur_Select=;/必选策略/foreach(ri∈cur_CR)查找essi;if(essi≠null)cur_Select=cur_Select∪{essi};endifendforif(cur_Select==)/贪婪策略/foreach(tj∈cur_T)计算其效用值ωj;cur_Select={具有max(ωj)的第1个tj};endif/后续处理/foreach(tj∈cur_Select)cur_CR=cur_CR-Rj;endforcur_T=cur_T-cur_Select;γC=γC∪cur_Select;endwhile在每一次外层循环(while循环)中,首先应用替代策略筛除当前备选集(cur_T)中可以被替代的测试用例.然后针对当前关注需求集(cur_CR)中的每一个(未覆盖)测试需求ri,检查其是否存在essi,即是否可以应用必选策略;所选择的必选测试用例构成cur_Select.如果必选策略不能应用,则应用贪婪策略选择具有最高效用值(ωj)的测试用例tj构成cur_Select.最后将cur_Select从cur_T中移出并入约简集γC,从cur_CR中删除已经覆盖的关注需求.重复外层循环直至cur_CR为空.考虑算法的性能,根据必选策略和贪婪策略,每次循环至少选择备选集T中一个测试用例,该用例至少覆盖并移除关注需求集CR中的一个需求.初始情况下有|T|个备选用例和|CR|个关注需求,因此外层循环的次数最多为min(|T|,|CR|).循环体包括4个部分:替代策略部分复杂度为O(|R|×|T|2).必选策略部分、贪婪策略部分以及后续处理部分的复杂度均为O(|R|×|T|).累计这4个部分的时间复杂度得出外层循环体的时间复杂度为O(|R|×|T|2).按以上分析,令备选集T的用例数量为m,需求集R的需求数量为n,HATS算法的时间复杂度应为O(min(m,n)(nm2)).这个复杂度虽然达到了n4或m4量级,和HGS及GRE算法相当.但HATS算法的实际性能不至于此.我们在实践中应用HATS算法约简104级别的需求集和102级别的用例集,所需执行时间不超过10s.这个时间相对于长达数小时至数天的回归测试时段可以忽略.5实例分析本文的创新性贡献包括两个方面:一是提出部分覆盖用例集约简概念,形式化定义多目标用例集约简问题,在选择性回归测试中进一步减少测试工作量和成本;二是提出HATS算法解决该问题,在减少约简集规模的同时避免对无关需求的覆盖.为验证本文所提概念和技术的有效性,我们设计实验解答以下问题.分覆盖约简技术能否进一步减少约简集的规模?问题1.同全覆盖用例集约简技术相比较,部问题2.对于部分覆盖用例集约简,HATS算法能否在减少约简集规模的同时有效降低对无关需求集的覆盖比率?问题3.对于部分覆盖用例集约简,约简技术Page6对关注需求集的缺陷检测率负面影响程度如何?HATS算法能否降低对缺陷检测率的负面影响?对部分覆盖用例集约简问题的两个目标影响如何?5.1实验设计问题4.HATS算法中权重因子α的不同设置为回答上述问题,我们选择了3个中等规模的表13个实验对象的信息标识N03NanoXMLv3N05NanoXMLv5J08JTopasr0.815我们定义语句块为测试需求.Java语句块是一串没有跳转的语句或表达式集合,视为测试覆盖的基本单元.这3个程序的初始用例集都未能达到100%语句块覆盖率,这在业界软件系统测试中是一个普遍现象.即使对一个相对简单的软件程序,达到100%语句(块)覆盖率也需要较大的成本[15].未覆盖的测试需求在实验中被忽略.在每一个设计的实验中,我们选择一个类中所包含的测试需求(语句块)作为该实验的关注需求集.这种设计对应的设想是这个类最近被更新或修复了缺陷,是本次选择性回归测试关注的对象.该设计可以容易地扩展到多个类被同时修改的情况.N03有4个类包含人工植入的缺陷,N06有6个类包含植入缺陷,据此我们设定10个对应实验;对于J08我们选择8个具有高语句块覆盖率的类并设定8个对应实验.表2列举了这18个实验的相关信息.其中CRcovered表示关注需求集中被初始用例集覆盖的关注需求集合.实验标识N03N05N03-1StdXMLBuilder3632N03-2StdXMLParser10886N03-3XMLElement206118N03-4XMLException2711N05-1ContentReader3424N05-2NonValidator9862N05-3StdXMLParser11995N05-4StdXMLReader10454N05-5XMLEntityResolver1917N05-6XMLUtilJ08-1J08-2StandardTokenizer3332J08-3TokenizerProperty6652J08-4StandardTokenizerProperties234181J08-5PatternMatcher2822J08-6SequenceStore8375J08-7TokenizerException1513J08-8CharArraySource1616J08开源Java软件程序.第1、2个为NanoXML的不同版本(下载于http://sir.unl.edu),我们选择NanoXML第3和第5版作为实验对象.第3个是JTopas(下载于Sourceforge),我们选择其最新版本和相应的用例集作为实验对象.表1列举了这3个Java程序的相关信息.2142314785.2约简集规模首先需要考虑的问题是部分覆盖用例集约简是否能够进一步减少约简集的规模以及HATS算法在这方面的性能如何.我们采用Matlab(http://www.mathworks.com/)分别实现了HGS[1]算法、GRE[2]算法、BIP[6]算法和本文提出的HATS算法,其中HGS、GRE和BIP算法可以采用需求集R和初始(备选)用例集T为输入(分别标记为HGST、GRET和BIPT),以代表全覆盖用例集约简;也可采用关注需求集CR和备选集T为输入(标记为HGSS、GRES和BIPS),以代表单目标部分覆盖用例集约简.HATS算法通过对权重因子α的不同设置运行多个实例,如HATS0.5表示该实例中因子α设置为0.5.图2用箱形图(box-plot)描述了不同算法实例在18个实验中运行得到的约简集规模分布.为便于在不同程序间比较,初始用例集规模被归一化为100,算法执行得到的约简集规模表示为相应初始集规模的百分比值.根据图2不难看出,同全覆盖用例集约简相比,部分覆盖用例集约简技术能够进一步较大幅度减少约简集γC的规模.在一些实验中的降低幅度很可Page7观,如在N05-1和J08-2中,部分覆盖约简所得到的最小γC只包含1个测试用例,其原因是相应的关注需求集CR在需求集R中所占的比例较小.在所有18个实验中,HGS、GRE和BIP算法得到的约简集规模|γC|基本相同,不管输入是需求集R还是关注需求集CR皆如此;唯一的差异出现在J08-4,在以CR为输入时,HGSS得到的约简集比其它两个算法多1个用例.算法HATS中HATS1得到的|γC|和其它3个全覆盖约简算法以CR为输入时得到的值相同,唯一的区别出现在N05-6,此时HATS1多选了1个用例.在部分覆盖约简算法和实例中,HATS0得到的|γC|总是最大,但仍然远小于全覆盖约简算法的结果.HATS0.5得到的|γC|同HATS1相差不大,在所有的实验中最多不超过1个测试用例.5.3无关需求集的覆盖率第2个考虑的问题是同单目标部分覆盖约简技术相比,HATS算法能否进一步降低对无关需求集的覆盖率.我们以关注需求集CR为输入运行HGS、GRE和BIP算法,并通过α的不同设置运行HATS的多个实例.在各实验中我们测量算法所得约简集对无关需求集的覆盖百分比值(标记为Cov|R-CR|),其中初始用例集未覆盖的无关需求被忽略.图3用箱形图描述了各个算法在18个实验中所得约简集的Cov|R-CR|分布.可以看出,部分覆盖约简技术可以减少对无关需求的覆盖.各个算法的Cov|R-CR|均值大约在60%上下,这意味着在平均情况下约有40%的无关需求可以避免,从而减少回归测试执行和分析的工作量.图3不同算法所得约简集对无关需求的覆盖百分比值各算法得到的Cov|R-CR|偏差范围普遍较大.以CR为输入的3个全覆盖约简算法虽然得到的约简集规模相当,但由于选定的测试用例各不相同,其Cov|R-CR|有一定差异.其中BIPS所得偏差范围相对较小,但在多个实验中BIPS得到最差的Cov|R-CR|值.对于HATS算法,HATS1得到的Cov|R-CR|值和3个算法相当,但具有最小的偏差范围.HATS0虽然以避免对无关需求的覆盖为唯一目标,但由于选择了较多的测试用例,所得的Cov|R-CR|值常常较差.在绝大多数实验中,HATS0.5(平衡考虑减少约简集规模和避免无关需求覆盖)得到了最小的Cov|R-CR|值;两个例外是N05-4和N08-4,其最小值都来自HATS1.综上所述,在部分覆盖约简技术中,只要权重因子α的设置适当,HATS算法能够进一步减少对无关需求的覆盖比率.5.4缺陷检测能力第3个考虑的问题是部分覆盖约简技术对关注需求集相关缺陷检测能力的负面影响以及HATS算法能否缓解负面影响.在18个实验中,我们首先测量初始用例集能够达到的针对关注需求集的缺陷检测率.然后分别运行HGS、GRE、BIP和HATS算法,前3个算法包括全覆盖实例和部分覆盖实例,HATS算法包括α的不同设置.所得约简集的缺陷检测能力反映为相对初始集缺陷检测率的百分比值(标记为ΨCR).如此处理的原因一方面是由于初始用例集未达到100%语句(块)覆盖率,从而也不能达到100%缺陷检测率;另一方面是便于在不同实验不同关注需求集之间的比较.我们采用抗变异值(mutationscore)反映对关注需求集CR的缺陷检测率.抗变异值指用例集能够检测出变异(mutant)的百分比.由于实验对象程序由Java编写,因此可采用Jumble工具(http://jumble.sourceforge.net/)来测量用例集针对给定Java类(关注需求集)的抗变异值.图4用箱形图描述了18个实验中各个算法所得约简集针对关注需图4不同算法所得约简集针对关注需求集的缺陷检测能力Page8求集CR的抗变异值相对初始用例集抗变异值的百分比值ΨCR.由于约简技术减少了测试用例数量,必然会降低针对CR的缺陷检测能力.在我们的实验中,全覆盖用例集约简技术对缺陷检测能力的影响不大;其中HGST在多数情况下表现最好,只在4个实验中ΨCR低于100%,但都在95%以上;而BIPT则表现出较大的偏差范围.采用部分覆盖约简,由于测试用例数量进一步减少,所得到的ΨCR明显降低;其中实验N05-1、N05-5和N08-3中降低幅度达到40%.此时HGSS和GRES的结果好于BIPS,但3个算法中没有哪个算法能在所有实验中保持优势.对于HATS算法,HATS1的ΨCR值同HGSS和GRES基本相同.HATS0.5虽然在约简集规模和无关需求覆盖方面表现较好,但在缺陷检测能力方面较差,所得到的ΨCR值在所有实验中和HATS1相同或优势很小(5%).HATS0在所有部分覆盖约简算法和实例中的缺陷检测能力最好,一方面在除J08-8之外的所有实验中得到了最大的ΨCR值;另一方面其偏差范围在这些算法中也最小;值得提出的是在图5HATS算法中权重因子α对约简集规模和无关需求覆盖率的影响趋势考查Cov|R-CR|,Cov|R-CR|随α增大变化比较复杂.在大多数实验中Cov|R-CR|随α的趋势线呈现盆形,即开始阶段Cov|R-CR|随α增大而下降;中间阶段达到最小值,此时多数实验中Cov|R-CR|在较大的α取值范围内保持不变或变化很小;部分实验中Cov|R-CR|存在多个最小值阶段;过了盆底阶段后,Cov|R-CR|随α增大缓慢增大;当α从0.95乃至0.99变为1时,Cov|R-CR|通常突然增大,例外情况存在于N05-4和N08-4,当α变为1时Cov|R-CR|反而下降.在N03-3和N03-4中,Cov|R-CR|没有变化,其原因是在α从0到1增大的过程中,所得约简集γC的组成没有变化.N05-3和N05-6中,其ΨCR值甚至超过了3个全覆盖约简算法.综上所述,HATS算法能够在一定程度上缓解部分覆盖用例集约简对缺陷检测能力的负面影响.5.5权重因子α第4个考虑的问题是HATS算法中权重因子α对部分覆盖约简问题的两个目标影响如何,包括约简集规模和无关需求覆盖比率.同前述相同,这两个指标分别反映为约简集规模|γC|占初始用例集规模|T|百分比值及约简集γC覆盖无关需求占无关需求总数|R-CR|的百分比值Cov|R-CR|.图5用箱形图描述了|γC|百分比值和Cov|R-CR|随α取值的变化趋势.其中α取0到1,间隔为0.05;各点的期望值用虚线连接.考查|γC|百分比值,不难发现|γC|随α增大而单调下降.当α取值小于0.15时,|γC|取值相对较高;此时当α增大时,|γC|下降较快;在大多数实验中当α等于0.55时,|γC|已达到最小值;当α再增大,|γC|基本不变或变化很小.在部分实验中,如N03-3和J08-7,|γC|保持不变,与α取值无关.5.6讨论根据实验结果数据,同全覆盖用例集约简相比,部分覆盖约简技术能够进一步降低约简集的规模.通过设置合适的权重因子α,HATS算法能够在同时减少对无关需求的覆盖.这可以较大程度降低选择性回归测试的成本和工作量,且后者在软件系统开发过程中需要频繁应用,从而能够降低软件开发成本.由于部分覆盖约简进一步减少了测试用例数量,缺陷检测能力受到负面影响.按照实验数据,HATS0能够有效缓解这一影响,在部分实验中针对关注需求集的缺陷检测能力甚至超过了全覆盖约简.但也存在部分实验,同初始用例集相比,HATS0Page9所能达到的缺陷检测能力仍有较大差距.这说明非关注需求也需要区别对待,如何识别重要的非关注需求将是我们下一步的工作之一.我们以3个中等规模的开源Java软件系统为实验对象,测试需求定义为Java的语句块.可以考虑的扩展是添加C/C++等不同语言编写的软件系统为分析对象,将测试需求定义为其它类型覆盖单元如分支或谓词组合等,以增加实验结果的代表性.另一个需要考虑的问题是实验软件系统的初始(备选)用例集未能达到100%需求覆盖率,有必要补充新的测试用例;尽管在实践软件项目开发中由于时间和成本的限制,100%测试需求覆盖是难以达成的目标.6结论选择性回归测试主要用于软件系统局部更新和部分缺陷修正,在当今软件系统开发中需要频繁应用,如何有效完成部分需求覆盖用例集约简从而控制其成本是一个需要考虑的问题.针对该问题的测试需求集被分成两部分:关注需求集和无关需求集.据此本文定义(部分覆盖)多目标测试用例集约简问题:一方面在覆盖关注集的要求下尽量减少约简集规模;另一方面避免对无关集的覆盖,从而减少测试执行和分析的工作量.本文提出HATS算法解决多目标用例集约简问题.HATS算法遵循启发式贪婪搜索框架,应用3个策略:必选策略、替代策略和贪婪策略,以选择当前最合适的测试用例.定义权重因子α平衡两方面目标:减少约简集规模同时避免无关需求的覆盖.实验数据表明,同现有约简算法相比较,HATS算法能够较大幅度减少约简集规模,降低对无关需求的覆盖比率,同时缓解对缺陷检测能力的负面影响.下一步工作包含两个方面:一方面考虑关注集和无关集的分割准则,提高部分覆盖约简技术针对关注集的缺陷检测能力.另一方面推动HATS算法的实践应用,通过更多的软件系统实例验证其有效性,包括面向不同的编程语言、定义新的测试需求类型、提升备选用例集对测试需求的覆盖率等.
