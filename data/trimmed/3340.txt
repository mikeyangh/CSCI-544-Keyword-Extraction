Page1基于模型诊断的抽象分层过程王楠1),2)欧阳丹彤1)孙善武3)1)(吉林大学计算机科学与技术学院符号计算与知识工程教育部重点实验室长春130012)2)(吉林财经大学信息学院长春130117)3)(吉林财经大学网络实验中心长春130117)摘要分层诊断是降低基于模型诊断计算复杂性的一个重要方法,在分层诊断中很重要的一步是构造系统的抽象分层模型,以往的分层方法都是建立在某一种特定抽象模型基础上,没有将抽象的一般理论与基于模型诊断中的分层过程相联系,并且对自动生成系统的分层表示方法也没有形式化的分析.KRA(KnowledgeReformulationandAbstraction)模型从构造化的角度定义了表示抽象的一般框架,文中在KRA模型框架下建立系统模型,给出了抽象算子在系统的基本框架Rg上进行的非独立的运算过程,使得不会在抽象过程中生成重复的部件类型,不仅降低了存储空间,还增加了在进一步的抽象运算中算子重用的概率,提高了整个抽象运算的效率.同时描述了基于模型诊断中的抽象分层过程,提出了动态和静态构造算子库两种方法,并对其优缺点进行分析,给出了一个应用抽象算子集合自动生成待诊断系统分层表示的一般算法.关键词基于模型的诊断;分层诊断;KRA模型;算子库;自动分层1引言基于模型诊断的一个主要障碍是当待诊断系统中部件数目很大时,要考察的候选诊断数目也非常大.因此,学者们提出了很多方法提高获得真正诊断的效率,比如通过增加依赖于应用领域的约束控制诊断空间[1].有些学者提出了分层诊断的方法解决基于模型诊断的计算复杂性问题,Mozetic[2]定义了3个抽象/细化算子来表示层次之间的关系,并给出了限制完备性成立的条件,Chittaro和Ranon[3]在Mozetic工作的基础上提出了基于结构抽象的分层诊断方法,扩展了Mozetic的算法.Saitta等人[4]在Saitta和Zucker[5-6]提出的KRA模型框架下形式化了基于模型诊断中的抽象过程,描述了如何在KRA模型中实现基于模型诊断中的部件聚合.图1一个运行实例这里包括4种类型的部件,泵(pump)、管(pipe)、阀(valve)和三通(three-waynode),其中三通分为两种类型:一个输入两个输出(2wayOut)和一个输出两个输入(2wayIn).每个部件都有端口(port),在这里我们可以把端口看成一种虚拟的部件类型,它分为输入端口和输出端口.在系统中部件与部件之间通过内部端口相连,部件与外部环境之间通过外部端口相连.设Fp表示端口p的流量值,已知泵PM1产生的正常流量为Fk.图1中PM1为泵,P1~P6为管,V1和V2为阀,TW1和TW2表示三通,t1~t13,t2~t12为各部件的端口.图2列举了图1系统中各部件的可能的行为模式.本文基于Saitta等人的工作,除了对KRA模型各层的抽象算子进行功能定义之外,还给出了抽象算子在系统的基本框架Rg上进行的非独立的运算过程,使得不会在抽象过程中生成重复的部件类型,不仅降低了存储空间,还增加了在进一步的抽象运算中算子重用的概率,提高了整个抽象运算的效率.同时我们描述了基于模型诊断中的抽象分层过程,提出了动态和静态构造算子库两种方法,并分析了其优缺点,给出一个应用抽象算子集合自动生成待诊断系统分层表示的算法.2一个运行实例我们引用文献[3]中的水力系统的例子详细说明本文的方法,如图1所示.OK(pump)UF(pump)OF(pump)LK(pump)OK(pipe)LK(pipe)OK(valve)SO(valve)SC(valve)OK(three-way)type(2wayOut)Fin=Fout1+Fout2泵(pump)部件有4种行为模式,当其处于正常模式OK时,其输入流量等于输出流量并且都等于Page3泵的正常流量Fk.当泵处于故障模式UF(UnderFlow)时,表示泵的流量低于正常流量,同样地,故障模式OF(OverFlow)表示泵的流量高于正常流量.当泵处于故障模式LK(LeaK)时,表示泵有泄漏,因此其输入流量高于输出流量.管(pipe)部件有两种行为模式,当处于正常模式OK时,其输入流量等于输出流量.当处于故障模式LK时,其输入流量大于输出流量.阀门(valve)部件有3种行为模式,当其处于正常模式OK时,根据阀当前的状态分为开放正常状态和关闭正常状态,前者为输入输出流量相等且大于0,后者为输入输出流量相等且等于0.当处于故障模式SO(StuckOpen)时,输入和输出流量相等且一直大于0.当处于故障模式SC(StuckClosed)时,输入和输出流量相等且一直等于0.假设三通只有一种正常行为模式OK,根据三通的类型分两种情况,当三通类型为2wayOut(2个输出1个输入)时,输入流量等于两个输出流量加和,当三通类型为2wayIn(2个输入1个输出)时,输出流量等于两个输入流量加和.3表示抽象的KRA模型抽象的目的是隐藏细节,从而找到更简单的描述.在人工智能领域内,很多学者已经研究了抽象理论,比如问题求解[7]、规划[8]、基于模型的诊断等.很多抽象理论试图得到关于抽象的一个一般定义,这些理论有语法的[9],也有语义的[10].继Korf[11]之后,Saitta和Zucker提出的表示框架R统一了以往的表示方法.我们简要地描述KRA模型框架,更详细的内容见文献[12].该框架从4个层次描述一个待表示的物理世界W:感知(P)、结构(S)、语言(L)和理论(T),即R=(P,S,L,T).下面引用文献[4]中的表示方法描述框架R中的各部分,并做适当的更改.一个感知P是一个五元组,即P=(OBJ,ATT,FUNC,REL,OBS),OBJ表示W中的对象类型,ATT表示对象的属性的类型,FUNC确定了一个函数集,REL是对象类型间的关系集合,表示如下:OBJ={TYPEi|1iN};ATT={Aj:TYPEj→Λj|1jM};FUNC={fk:TYPEik×TYPEjk×…→Ck|REL={rhTYPEih×TYPEjh|1hR}.由于OBS涉及到特定的表示系统,因此没有一般性的定义.结构S以数据库的形式记忆一个系统的感知,故文献[4]中将其称为数据库D.S由一些表构成,存储了被感知系统的外延上的表示.语言L从内涵上描述S的内容,从而完成推理.而理论T则包含一般性的和域特殊的知识,理论T的内容则用语言L描述.考虑两个表示框架Rg=(Pg,Sg,Lg,Tg)和Ra=(Pa,Sa,La,Ta),称Rg为一个基本框架.一旦给定Pg,就可以通过为适当的变量集(对象,属性,函数中的对偶,关系中的元组)分配值得到任意特定的系统.所有这些变量的一个值的分配称为一个配置γg,令Γg为所有可能的基本配置集合.同样地,令Γa为所有可能的抽象配置集合.使用以上表示,可以定义抽象如下.定义1.给定两个表示框架Rg和Ra,如果存在一个映射Γg→Γa,该映射将Γg的一个子集与Γa的一个单个元素关联,则称Ra比Rg更抽象.从定义1中可以看出抽象是相对而非绝对的概念,是定义在表示框架之间而不是单一的对象之间.实际上,在KRA模型框架下,抽象是通过对基本配置应用抽象算子集而得到的,抽象算子有些是域独立的,有些是域特殊的,我们将在第4节介绍各种算子的定义及其应用过程.为了说明表示抽象的KRA模型框架,我们以图1中给出的水力系统为例进行描述.令Rg=(Pg,Sg,Lg,Tg)是该系统的基本表示框架,基本感知Pg可以指定如下:OBJg=COMPg∪{PORT};COMPg={PUMP,PIPE,VALVE,THREE-WAY};ATTg={ObjType:OBJg→{pipe,pump,valve,FUNCg={Bpump:PUMP→{ok,uf,of,lk},RELg={port-ofPORT×COMPg,集合OBSg包含了系统中的实际对象以及它们的拓扑和传感器给出的测量.Page4OBSg={(PM1,P1,…,P6,V1,V2,TW1,TW2,t1,…,t13,t2,…,t12),(ObjType(PM1)=pump,ObjType(P1)=pipe,…,ObjType(P6)=pipe,ObjType(V1)=valve,…,ObjType(TW1)=three-way,…,ObjType(t1)=port,…),(Direction(TW1)=2wayOut,…,Direction(t1)=in,…),(Observable(t1)=yes,…),(State(V1)=open,State(V2)=closed),(port-of(t1,PM1),…),(connected(t2,t2),…)}.基本感知中的所有值存储在结构Sg中,结构Sg中包含以下表:TableObj=(obj,objtype,direct,obser,state),描述实际系统中的对象及属性.TablePortOf=(port,comp),表示端口及其所在的部件.TableConnected=(port,port),描述哪些端口互相连接.TableObj中有一些值置成NA(NotApplicable),表示该属性对于对应的部件没有意义.下面给出这3个表的部分值.objobjtypedirectobserstatePM1pumpNANANAV1valveNANAopenTW1three-way2wayOutNANAt2portoutnoNA…逻辑语言Lg定义如下,Lg=(Pg,Fg,Cg),这里Pg是一个谓词的集合,P={comp(x),port(x),observable(x),state(x),in(x),out(x),port-of(x,y),connected(x,y),ok(x),so(x),…,pump(x,y1,y2),valve(x,state,y1,y2),…}.F是一个函数集合,F={Bpump,Bpipe,Bvalve,Bthree-way,ΔFlowValue}.C是一个常量集合,C={PM1,V1,…}∪ΛBpump∪…∪{open,closed,+,-,0}.语言Lg中的谓词集合的语义由结构中的表提供.函数集合F中Bpump等函数的函数值为对应部件的行与图2等价的PM的行为模式描述如下:为模式,ΔFlowValue有两个参数,类型为port型或数值型,当第1个参数大于(/小于/等于)第2个参数时,函数值为+(/-/0).理论Tg包含系统中各部件的结构描述和行为描述,比如对于部件pump的结构描述如下:pump(PM,t1,t2)comp(PM)∧port(t1)∧port-of(t1,PM)∧in(t1)∧port(t2)∧port-of(t2,PM)∧out(t2).pump(PM,t1,t2)∧ok(PM)→ΔFlowValue(t1,t2)=0∧ΔFlowValue(t1,Fk)=0;pump(PM,t1,t2)∧uf(PM)→ΔFlowValue(t1,t2)=0∧ΔFlowValue(t1,Fk)=+;pump(PM,t1,t2)∧of(PM)→ΔFlowValue(t1,t2)=0∧ΔFlowValue(t1,Fk)=-;pump(PM,t1,t2)∧lk(PM)→ΔFlowValue(t1,t2)=+.4抽象算子引入抽象算子的目的是为了从系统的最基本层开始,应用抽象算子自动生成更抽象的系统表示.这一部分我们以图1给出的实际系统为例,在KRA模型中的各层定义了一一对应的抽象算子集合.与文献[4]不同的是,我们除了对KRA模型各层的抽象算子进行功能定义之外,同时还给出了一个非独立的运算过程,即首先在系统的基本框架内的各层应用抽象算子,然后利用一阶逻辑推理将在理论层应用抽象算子得到的新生成的超部件的行为模式与最基本系统的所有基本部件的行为模式比较,如果发现该超部件的行为模式与某种类型的基本部件一致,则修改感知层和结构层的运算结果,保留新生成的超部件名等实例化信息,而将其类型等类化信息用与其行为模式一致的基本部件的相应信息更新;如果没有找到与该超部件行为一致的基本部件,则运算终止.这样的运算过程使得不会在抽象过程中生成重复的部件类型,不仅降低了存储空间,同时增加了进一步的抽象运算中算子重用的概率,提高了整个抽象运算的效率.下面我们首先在KRA模型框架内定义相应的抽象算子,这里引用了文献[4]中的部分定义,同时做了一些修改,然后我们给出应用抽象算子生成超部件的过程.抽象算子首先在感知层定义,感知层中的算子集合用于将系统(基本系统或抽象系统)中的部件聚合,其算子数目与具体的系统有关,我们将在第5部Page5分说明如何确定一个具体系统在感知层的抽象算子集合,这里以图3所示的图1中系统的一个子部分为例描述感知层抽象算子的定义及运算.图3中左图为实际系统的子部分,右图为应用抽象算子后得到的抽象部件.我们定义算子ωPipeValve实现串联连接的pipe类型部件与valve类型部件向超部件PV1的聚合,该算子带有两个参数,分别为pipe型和valve型.后面我们会看到这种聚合的结果仍然是pipe类型部件,RELa={port-ofPORT×COMPa,connectedPORT×PORT};OBSa={(PM1,犘1,…,P6,犘犞1,犞1,V2,TW1,TW2,t1,…,狋5,t6,…,t13,t2,…,狋5,…,t12),犗犫狊犲狉狏犪犫犾犲(狋5)=狀狅,犗犫狊犲狉狏犪犫犾犲(狋5)=狀狅,Observable(t4)=yes,Observable(t6)=yes),这里注意,由于聚合pipe型部件P1和valve型部件V1时虽然生成了新的部件类型,但是系统中可能仍然存在其它pipe型和valve型部件,所以在COMPa集合中保留了这两种部件类型.OBSa中删除线部分表示了抽象运算过程.在结构层,我们定义与感知层算子ωPipeValve对应的抽象算子σPipeValve,该算子作用于存储系统基本感知的表上.在表TableObjg中,删除任何含有P1或V1以及t5或t5的行,并在表中为对象PV1添加新行,生成表TableObja.objobjtypedirectobserstatePM1pumpNANANA犘1狆犻狆犲NANANA犞1狏犪犾狏犲NANA狅狆犲狀犘犞1狊狆狏NANANA狋5狆狅狉狋狅狌狋狀狅NA狋5狆狅狉狋犻狀狀狅NA…在表TablePortOfg和表TableConnectedg中,将含有部件P1或V1以及两部件连接端口t5或t5的所有行删除,同时将P1和V1的外部端口t4和t6与部件PV1即ωPipeValve(pipep,valvev)生成了一个pipe型部件.将ωPipeValve(P1,V1)作用于系统的基本感知Pg=(OBJg,ATTg,FUNCg,RELg,OBSg)得到更抽象的感知Pa=(OBJa,ATTa,FUNCa,RELa,OBSa)如下:OBJa=COMPa∪{PORT};COMPa={PUMP,PIPE,VALVE,ATTa=(ATTg-{ObjTypeg})∪FUNCa=FUNCg∪{BSPV:SPV→CSPV}.注意,在感知层无法直接得到生成的超部件的行为模式常量集合,需要在理论层的推理指导下获得.相连,得到表TablePortOfa和表TableConnecteda.这里只以表TableObja为例说明抽象算子σPipeValve(P1,V1)的作用结果.在语言层,我们定义抽象算子λPipeValve,该算子作用于逻辑语言Lg=(Pg,Fg,Cg),得到更抽象的语言La=(Pa,Fa,Ca),其中:在谓词集合Pa中,由于系统对象类型除了增加了SPV型的部件之外,其余没有发生变化,故只需要在集合Pa中添加关于部件SPV的相应谓词.函数集合Fa中添加关于SPV型部件的行为函数.常量集合Ca中添加SPV型部件的行为模式值以及新生成的超部件名.具体如下:Pa=Pg∪{SPV(x),BSpv1(x),BSpv2(x),…};Fa=Fg∪{BSPV};Ca=Cg∪{PV1}∪ΛBSPV.注意,新生成的超部件的行为模式谓词及行为模式常量,在语言层算子的作用下无法直接得到,是在理论层的逻辑推理指导下获得.在理论层,需要将描述pipe型部件和valve型部件的结构和行为的公式合并(但是保留两种类型部件的结构和行为描述公式),从而得到超部件Page6SPV型部件的结构描述和行为.pipe型部件和valve型部件的结构描述如下:pipe(P,t1,t2)valve(V,state,t1,t2)comp(P)∧port(t1)∧port-of(t1,P)∧in(t1)∧port(t2)∧port-of(t2,P)∧out(t2);comp(V)∧port(t1)∧port-of(t1,V)∧in(t1)∧port(t2)∧port-of(t2,V)∧out(t2)∧根据结构层中的表中描述的信息进行推理得到超部件类型SPV的结构描述如下:SPV(PV,t1,t2)如下:comp(PV)∧port(t1)∧port-of(t1,PV)∧in(t1)∧port(t2)∧port-of(t2,PV)∧out(t2).同理,pipe型部件和valve型部件的行为描述①pipe(P,t1,t2)∧ok(P)→ΔFlowValue(t1,t2)=0;②pipe(P,t1,t2)∧lk(P)→ΔFlowValue(t1,t2)=+;③valve(V,state,t1,t2)∧state(V)=open∧ok(V)→ΔFlowValue(t1,t2)=0∧ΔFlowValue(t1,0)=+;④valve(V,state,t1,t2)∧state(V)=close∧ok(V)→ΔFlowValue(t1,t2)=0∧ΔFlowValue(t1,0)=0;⑤valve(V,state,t1,t2)∧so(V)→ΔFlowValue(t1,t2)=0∧ΔFlowValue(t1,0)=+;⑥valve(V,state,t1,t2)∧sc(V)→ΔFlowValue(t1,t2)=0∧ΔFlowValue(t1,0)=0.将两种类型部件的行为模式做笛卡尔积共得到8种可能的行为模式(①③,①④,①⑤,①⑥,②③,②④,②⑤,②⑥),经过逻辑推理,可以合并其中的①③、①④、①⑤和①⑥,②③、②④、②⑤和②⑥得到新的超部件的共2种行为描述如下:SPV(PV,t1,t2)∧BSpv1(PV)→ΔFlowValue(t1,t2)=0;SPV(PV,t1,t2)∧BSpv2(PV)→ΔFlowValue(t1,t2)=+.在系统的KRA模型基本框架内应用抽象算子是一个反复的过程,正像我们前面在框架内各层定义抽象算子时提到的,有些内容在算子顺序应用过程中只能暂时以变量的形式存在,比如在感知层定义FUNCa时,无法直接得到新生成的超部件的行为模式常量集合,需要利用理论层的逻辑推理结果指导,再如在语言层生成谓词集合时,超部件的具体行为谓词也必须由理论层的逻辑推理结果指导得出.下面我们看一下前面聚合pipe类型部件和valve类型部件时在理论层推出的逻辑结果对其它各层的指导:通过理论层的推理,我们得到SPV类型的超部件具有两种行为模式BSpv1和BSpv2,则我们修改感知层的函数集合为FUNCa=FUNCg∪{BSPV:SPV→{BSpv1,BSpv2}},修改语言层的谓词集合为Pa=Pg∪{SPV(x),BSpv1(x),BSpv2(x)}.特别地,部件聚合有可能生成与某个基本部件结构描述和行为模式都相同的超部件,这种情况下可以将该超部件看成与该基本部件相同的部件,无需将其类型、结构以及行为模式进行重复存储.比如前面由部件P1和部件V1串联聚合而成的超部件PV1,我们将在理论层得到的该超部件的结构描述和行为模式与系统中的各基本部件比较,发现它的结构描述和行为模式与pipe型部件完全相同,则我们就可以在各层中将新添加的关于超部件的量做适当的删除,相当于在系统中将P1和V1删除,用一个pipe型部件PV1代替.经过以上分析,我们得到了新的更抽象的系统如图3中右图所示,其KRA模型表示Ra=(Pa,Sa,La,Ta)如下:在感知层,Pa=(OBJa,ATTa,FUNCa,RELa,OBSa),其中,OBJa=COMPa∪{PORT};COMPa={PUMP,PIPE,VALVE,THREE-WAY};ATTa={ObjType:OBJa→{pipe,pump,valve,FUNCa={Bpump:PUMP→{ok,uf,of,lk},RELa={port-ofPORT×COMPg,OBSa={(PM1,P2,…,P6,犘犞1,V2,TW1,TW2,(ObjType(PM1)=pump,ObjType(P2)=pipe,…,ObjType(P6)=pipe,ObjType(V2)=valve,ObjType(TW1)=three-way,…,ObjType(t1)=port,…,犗犫犼犜狔狆犲(犘犞1)=狆犻狆犲,…),(Direction(TW1)=2wayOut,…,Page7Direction(t1)=in,…,Direction(t4)=in,Direction(t6)=out),(Observable(t1)=yes,…,Observable(t4)=yes,Observable(t6)=yes),(port-of(t1,PM1),…,port-of(t4,PV1),port-of(t6,PV1)),(connected(t2,t2),…)}.在结构层,我们以表TableObja为例说明该结果,其它表内容与使用抽象算子σPipeValve(P1,V1)的作用结果相同.objobjtypedirectobserstatePM1pumpNANANA犘犞1狆犻狆犲NANANATW1three-way2wayOutNANAt2portoutnoNA…在语言层,得到逻辑语言La定义如下,La=(Pa,Fa,Ca),其中,Pa=Pg,Fa=Fg,Ca={PM1,P2,…,V2,PV1,…}∪ΛBpump∪…∪{open,closed,+,-,0}.由于没有增加新的部件类型,所以Ra的理论层知识与Rg相同.至此,我们可以得到作用于整个系统框架Rg上的抽象运算过程,如图4所示.5基于模型诊断中的抽象分层过程我们通过在KRA模型框架中的各层定义具体系统的算子库实现系统的自动分层,算子库可以采用两种方式定义:静态方式和动态方式.静态方式是指根据给定系统的基本框架Rg预先构造所有可能的抽象算子,在这里设基本部件类型的个数为m,抽象运算可以看成将m个部件两两串(/并)联聚合,则得到抽象算子个数为O(m2).静态构造算子库是一个相对的方法,它只是在抽象运算开始时预先定义了初始时可能的算子,但是如果在抽象运算过程中生成了某种基本系统中没有的部件类型,则还需要动态地定义新的算子添加到算子库中,另外,实际系统中还可能存在多个部件相联的情况,比如图1中TW1和P1,P3相联,这种情况也需要动态构造相应的算子.动态方式是指初始时根据系统的基本构成找到相连(串联或并联)的部件集,只定义这些部件集对应的聚合抽象算子,在抽象运算开始后,再不断地完善算子库.显然地,静态构造算子库的方法预先生成了基于基本部件的大部分可能用到的抽象算子,因此在系统的抽象分层过程中降低了动态定义新算子的概率,提高了整个分层过程对抽象算子的重用率,而动态方法只需要构造部分抽象算子,减少了预定义时间和空间,但是有可能在分层过程中过多地生成新算子,使得分层过程的效率降低.在组成部件相同的情况下,对于结构连接简单的系统可以使用动态生成算子库的方法对系统进行抽象分层,而对于结构连接复杂的系统则可以使用静态生成算子库的方法提高抽象过程中算子的重用率,从而提高分层过程的效率.图5中的算法HirechicalProcess利用动态生成抽象算子库的方法输出待诊断系统的分层表示.ProcedureHirechicalProcess输入:系统的KRA模型框架Rg=(Pg,Sg,Lg,Tg)输出:系统的分层表示H1.搜索Sg,找到系统中所有串联和并联的部件元组〈ci1,ci2,…,si1i2…〉,1i1,i2…n,从中删除部件类型和连接方式相同的元组;//ck(1kn)为部件名,si1i2…为部件的连接状态,si1i2…=2.根据1中找到的部件元组集,采用动态方法:s表示ci1,ci2…串联,si1i2…=p表示ci1,ci2…并联在感知层构造算子库Ω={ωti1ti2…|1i1,i2…n};在结构层构造算子库Σ={σti1ti2…|1i1,i2…n};在语言层构造算子库Λ={λti1ti2…|1i1,i2…n};tij表示部件cij的类型//注意,构造各层算子库的过程并不是独立完成,而是嵌入3.循环,直到系统中只有一个部件3.1.在系统中选择串(并)联的部件ci1,ci2,…,在Ω中选择可将ci1,ci2,…聚合的算子ω作用于系统Rg的感知层Pg,得到更抽象的感知Pa;3.2.在Σ中选择算子与ω对应的抽象算子σ,作用于系统Rg的结构层Sg,得到更抽象的结构Sa;3.3.在Λ中选择对应的抽象算子λ,作用于系统Rg的语言层Lg,得到更抽象的语言La;3.4.在理论层Tg中结合Pa,Sa,La层的抽象结果,利用推理规则得到由部件ci1,ci2,…聚合而成的超部件c的结构描述和行为模式,得到Ta;3.5.将步3.4中得到的结果与最基本部件的结构描述和行为模式比较,若得到的超部件与某个基本部件结构描述和行为模式一致,则重新修改第3.1、3.2、3.3、3.4步得到的结果;3.6.检查c与其它部件的连接情况(串联/并联),采用动态方法生成c对应的算子,并添加到步2中的3个算子库中;3.7.输出本次抽象运算得到的更抽象的系统Ra=(Pa,Sa,La,Ta);Page8算法HirechicalProcess是非常一般的,我们可以看到,在分层过程中需要考虑几个问题:(1)新算子的定义.除了进行抽象算子的预定义之外,当对系统的某一层次进行抽象运算时,若生成了新类型的超部件,还需要动态在算子库中定义新的算子,可以考虑利用机器学习中的相关理论定义新算子,使得算子的动态构造实现完全的自动化,从而实现系统的自动分层.(2)系统分层不唯一.由于在步3.1中选择下一步聚合的部件不唯一,使得算法生成的系统的分层表示不唯一,为了保证得到一个有辨识能力的抽象模型应该进一步考虑如何选择部件进行聚合.①保留系统的可用观测.我们看到,部件在聚合过程中可能会隐藏系统的可用观测,使得在诊断过程中对真假诊断的辨识力下降,即非可确定诊断问题(undiagnosabilityproblem)[13].如果某一分层上没有任何可用观测保留,则该层是完全非可确定诊断的.Mozetic在文献[2]中将诊断过程开始于至少具有一个可用观测的抽象层,从而避免了这种完全非可确定诊断问题.Chittaro在文献[3]中提出了结构树,并且利用Rearrange过程重新组织了Mozetic的系统分层表示,保留系统可用观测的同时生成了更为抽象的系统分层表示,降低了诊断搜索空间,提高了诊断的效率.因此,在选择聚合部件时,应尽可能保留系统的可用观测.具体在算法HirechicalProcess的步3.1中,可以进行以下操作(以两个部件聚合为例):查找系统中的部件ci和cj,判断二者的连接方式,若为串联,则检查部件ci和cj的互连端口是否包含观测信息,不包含即利用相应的抽象算子进行聚合操作;若为并联,则检查ci和cj各自的输入输出端口是否包含观测信息,不包含即利用相应的抽象算子进行聚合操作.显然,这个检查过程是线性复杂的,因此不影响整个算法的执行效率.这里需要说明的是,为了简化讨论,我们只考虑了部件连接的两种方式:并联和串联,有些系统中的部件之间还存在着更为复杂的连接方式,比如星型-网状结构[14],可以通过转换操作将其转换成拓扑上与之等价的并联和串联结构,详见文献[14].②尽量生成与基本部件类型相同的超部件.在选择部件聚合时,应该尽量避免生成与基本部件类型不同的超部件,因为一旦生成了不同类型的超部件,就需要占用空间存储该部件对应的类信息,同时也增大了定义新算子的难度.我们可以通过两种方法选择聚合部件:一是在动态定义抽象算子库时,除了定义抽象算子的作用过程外,增加对抽象算子作用结果的比较操作,即对生成与基本类型相同的超部件类型的抽象算子进行标记,在算法Hi-rechicalProcess的步3.1中将聚合部件的选择与抽象算子的选择结合起来,尽量选择能够生成与基本部件类型相同超部件的部件进行聚合.这种方法在算法HirechicalProcess的步3.1聚合部件之前,需要检查部件类型与算子库中的带标记算子的作用对象类型是否匹配,如果匹配,说明部件聚合后的超部件类型为基本部件类型,因此进行聚合操作.假设系统中包含n个部件,在最坏的情况下(假设系统中的n个部件两两相连,这是一种极端情况,实际的系统一般不会达到),动态生成的算子库中的算子个数为n(n-1)2个,若全部为标记算子,则在部件聚合前最多需要进行n(n-1)杂性简记为O(n2).这种方法的好处是当聚合部件类型与算子库中的带标记算子的作用对象类型匹配成功时,则在步3.4中无需重复生成超部件的行为模式,提高了部件的聚合效率.二是可以在算法HirechicalProcess的步3.5中检查新生成的超部件类型,若与任意基本部件类型都不相同,我们可以放弃前面进行的抽象运算,回到步3.1中重新选择聚合部件.当每次选择的聚合部件聚合后恰好都生成与某个基本部件类型相同的超部件时,这种方法获得最好的效率,即每次在算法HirechicalProcess的步3.5中最多进行n次比较(n为基本部件个数).而若每次选择的聚合部件聚合后都生成非基本部件类型的超部件,则会导致算法HirechicalProcess陷入无限循环之中,因此可以在此加入一个阈值,限制循环选择聚合部件的次数.③应用抽象算子的过程中一个关键点是如何得到超部件的行为模式甚至是行为模型,这决定了抽象后的模型质量,也影响着分层抽象过程的效率和正确性.假设我们要将部件c1,c2,…,ck聚合成超部件c,ci包含Mi种行为模式,1ik,则显然地,超部件c最多具有N=∏k可以看出,超部件c的这N中行为模式中有些是不可区分的,对于这样的行为模式进行合并,最终得到Page9超部件c的小于等于N种行为模式,既降低了存储空间,又有利于后面超部件与基本部件的比较.可以通过以下方法在算法HirechicalProcess的步3.4中生成超部件的行为模式:逐个考察k个聚合部件c1,c2,…,ck行为模式的笛卡尔积BMi(一阶逻辑公式),1iN,根据结构层中存储的各部件之间的连接关系以及生成的超部件的结构,在BMi中将含有被隐藏的端口的文字删除,推出只含有超部件端口的行为公式作为超部件的行为模式保存,并动态合并不可区分的(完全相同或存在子集和超集关系的行为模式)行为模式.1.BMc={};//存储超部件c的行为模式2.在结构数据库中查找部件c1,c2,…,ck的连接端口、超部件端口以及端口之间的连接关系;3.考察部件c1,c2,…,ck行为模式的笛卡尔积BMi,1iN3.1.BMi=删除BMi中含有部件c1,c2,…,ck的连接端口的文字并根据端口之间的关系保留超部件端口文字及一阶逻辑关系;3.2.将BMi与BMc中的行为模式依次比较,若BMc中存在与BMi不可区分的行为模式,则保留两者中子集的行为模式并转步3;否则BMc=BMc∪{BMi};i=1可以看出,以上生成超部件行为模式的算法在最坏情况下(超部件的所有可能的N种行为模式均不相同)的时间复杂性为Tworst=N(N-1)∏kMi,假如每个聚合部件都有n种行为模式,则Tworst=nk(nk-1)部件的所有可能的N种行为模式均相同)的时间复杂性为Tbest=∏k行为模式,则Tbest=O(nk).故超部件的行为模式可以在多项式时间内生成.图7是图1所示的系统的部分结构,我们举例说明按照图6所示的算法将PUMP型部件PM1和PIPE型部件P5聚合生成超部件PMP的行为模型的过程.PM1的行为模式可以描述如下:①pump(PM1,t1,t2)∧ok(PM1)→ΔFlowValue(t1,②pump(PM1,t1,t2)∧uf(PM1)→ΔFlowValue(t1,t2)=0∧ΔFlowValue(t1,Fk)=0;t2)=0∧ΔFlowValue(t1,Fk)=+;(t1,t2)=0∧ΔFlowValue(t1,Fk)=-;t2)=+.③pump(PM1,t1,t2)∧of(PM1)→ΔFlowValue④pump(PM1,t1,t2)∧lk(PM1)→ΔFlowValue(t1,P5的行为模式可以描述如下:⑤pipe(P5,t2,t3)∧ok(P5)→ΔFlowValue(t2,t3)=0;⑥pipe(P5,t2,t3)∧lk(P5)→ΔFlowValue(t2,t3)=+.在结构数据库中可以得到PM1和P5的端口及端口之间的连接关系为portof(t1,PM1),portof(t2,PM1),portof(t2,P5),portof(t3,P5),connected(t2,t2),得到的超部件PMP的端口为portof(t1,PMP),portof(t3,PMP).依次考察PMP所有可能的行为模式,并动态更新集合BMc.①⑤:pmp(PMP,t1,t3)∧BMpmp1(PMP)→ΔFlowValue(t1,t2)=0∧ΔFlowValue(t1,Fk)=0∧ΔFlowValue(t2,t3)=0,根据portof(t2,PM1),portof(t2,P5),connected(t2,t2),得到pmp(PMP,t1,t3)∧BMpmp1(PMP)→ΔFlowValue(t1,t3)=0∧ΔFlowValue(t1,Fk)=0,即得到PMP的第一个行为模式BMpmp1:ΔFlowValue(t1,t3)=0∧ΔFlowValue(t1,Fk)=0.BMc初始时为空,即不存在与该行为模式不可区分的行为模式,故更新BMc={BMpmp1}.同理,对于②⑤,③⑤,④⑤情况做同样处理,得到BMc={BMpmp1,BMpmp2,BMpmp3,BMpmp4},其中BMpmp2:ΔFlowValue(t1,t3)=0∧ΔFlowValue(t1,Fk)=+,BMpmp3:ΔFlowValue(t1,t3)=0∧ΔFlowValue(t1,Fk)=-,BMpmp4:ΔFlowValue(t1,t3)=+.对于①⑥,pmp(PMP,t1,t3)∧BMpmp5(PMP)→ΔFlowValue(t1,t3)=+∧ΔFlowValue(t1,Fk)=0,得到PMP的行为模式BMpmp5:ΔFlowValue(t1,t3)=+∧ΔFlowValue(t1,Fk)=0,经过检查,BMpmp5为BMc集合中的行为模式BMpmp4的超集,故BMpmp5不予以保存,BMc保持不变.同理对于②⑥,③⑥,④⑥情况与①⑥相同,最后得到BMc={BMpmp1,BMpmp2,BMpmp3,BMpmp4},即得到超部件PMP的4种行为模式.算法HirechicalProcess的正确性显然.从该算法中我们看到,初始时生成了系统最基本层相互连Page10接的部件对应的可能的抽象算子,只要系统部件数目大于1,则循环必然得到执行.而每执行循环一次,都有多于一个部件聚合成一个超部件,并且对于生成了不同于基本部件类型的超部件或生成了不同于上几层系统的连接方式的情况,算法都向算子库中定义了新算子.因此,随着循环次数的增加,系统的部件数目必然逐次减少,同时,亦能保证算子库始终对系统的整个分层是完备的.所以我们可以说算法HirechicalProcess必然生成系统的抽象分层表示,并且终止于只含有一个超部件的系统.所示的系统进行抽象分层.下面我们利用算法HirechicalProcess对图1首先找到系统中相连的部件元组集合如下:ωPipeValve=(P1,V1)=PV1,ωPipeValve(P3,V2)=PV2,定义新算子ω2Pipeω2Pipe(PV1,P2)=PVP1,ω2Pipe(PV2,P4)=PVP2ω2PipeThree-way(TW1,PVP1,PVP2)=TWP1,定义新算子ω2Three-wayω2Three-way(TWP1,TW2)=TWTWω2Pipe(P5,TWTW)=PTW1,ω2Pipe(PTW1,P6)=PTP图8不同的部件聚合顺序得到的不同的系统分层过程(a)〈PM1,P5,s〉,〈P5,TW1,s〉,〈P1,V1,s〉,〈V1,P2,s〉,〈P3,V2,s〉,〈V2,P4,s〉,〈TW1,P1,P3,s〉,〈TW2,P2,P4,s〉,〈TW2,P6,s〉.在部件元组集合中删除部件类型和连接方式相同的元组得到互不相同的4个元组:〈PM1,P5,s〉,〈P5,TW1,s〉,〈V1,P2,s〉,〈TW1,P1,P3,s〉,故初始时动态生成的3个算子库为Ω={ωPumpPipe,ωPipeThree-way,ωPipeValve,ω2PipeThree-way};Σ={σPumpPipe,σPipeThree-way,σPipeValve,σ2PipeThree-way};Λ={λPumpPipe,λPipeThree-way,λPipeValve,λ2PipeThree-way}.图8和图9中以感知层算子的运算为例,给出了按照部件的不同聚合顺序得到的系统的不同抽象分层表示.Page11ω2PipeThree-way(TW1,P1,P3)=TP2,定义新算子ω2valveeThree-wayωPipeValve(P2,V1)=PV1,ωPipeValve(P4,V2)=PV2ωPipeThree-way(TW2,P6)=TWP2ω2PipeThree-way(TWP2,PV1,PV2)=PVTW2,定义新算子ω2Three-wayω2Three-way(TW1,PVTW2)=TWTW,ω2PipeP5,TWTW)=PWPW1ωPumpPipe(PM1,PWPW1)=PMP1图9不同的部件聚合顺序得到的不同的系统分层过程(b)6结语本文在Saitta和Zucker提出的KRA模型框架下建立系统模型,给出了抽象算子在系统的基本框架Rg上进行的非独立的运算过程,使得不会在抽象过程中生成重复的部件类型,不仅降低了存储空间,还增加了在进一步的抽象运算中算子重用的概率,提高了整个抽象运算的效率.同时形式化地描述了基于模型诊断中的抽象分层过程,提出了动态和静态构造算子库两种方法.KRA模型是对静态物理世界的框架描述,在下一步的工作中,我们会继续扩展该框架,对动态物理世界建模过程的形式化描述以及复杂性进行深入的研究.
