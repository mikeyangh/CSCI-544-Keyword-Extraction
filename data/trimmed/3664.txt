Page1网树求解有向无环图中具有长度约束的简单路径和最长路径问题李艳1)孙乐2)朱怀忠2)武优西2)1)(河北工业大学经济管理学院天津300401)2)(河北工业大学计算机科学与软件学院天津300401)摘要具有长度约束的简单路径(SimplePathswithLengthConstraint,SPLC)问题是指求解图中任意两点间路径长度为m的简单路径数,是k-path问题的一种特殊情况.该文基于网树数据结构提出了在有向无环图中求解SPLC问题的算法(NettreeforSPLCinDirectedAcyclicGraphs,NSPLCDAG).网树是一种多树根多双亲的数据结构.NSPLCDAG算法将该问题转化为一棵网树后,利用树根路径数这一性质对其进行求解.对NSPLCDAG算法进行改造,可以求解有向无环图中最长路径问题并形成网树求解最长路径算法(NettreefortheLongestPathinDAGs,NLPDAG),NLPDAG算法可找到所有最长路径,对NLPDAG算法做进一步改进形成改进的NLPDAG算法,改进的NLPDAG算法可在线性时间复杂度内给出有向无环图中的一条最长路径.实验结果验证了NSPLCDAG和改进的NLPDAG算法的正确性与有效性.关键词有向无环网络;简单路径;长度约束;最长路径;网树1引言图是一种比线性表和树更为复杂的数据结构.在线性表中,结点间为单前驱单后继的线性关系;在树结构中,结点间为单前驱多后继的非线性关系;而在图结构中,结点间则为多前驱多后继的非线性关系.图中任意两个结点之间都可能相关,因此图已经被广泛应用于诸如语言学、逻辑学、物理、化学、电气工程和计算机科学等学科中.在图论中,最长路径(thelongestpath)问题[1]是指在给定的图中找出一条最长的简单路径.在无向图中求解最长路径问题是著名的NP难问题,现有的研究主要基于近似算法[2]、参数化算法[3].另外一类研究是针对特殊图进行求解,并给出多项式时间复杂度的求解算法,如Mertzios和Corneil①采用一种深度优先搜索策略对伴相似图(cocomparabilitygraphs)中最长路径问题进行了求解;Uehara和Valiente[4]在二部置换图(bipartitepermutationgraphs)中对最长路径问题建立了线性时间复杂度的求解算法,其求解的二部置换图既是一个置换图也是一个二部图;Ioannidou等人[5]在区间图(intervalgraphs)中运用动态规划思想,对最长路径问题给出了时间复杂度为O(n4)的求解算法;Edmonds和Chakraborty[6]在有向无环图(DirectedAcyclicGraphs,DAGs)所有边的长度非负的情况下,对最长路径的方差和期望的边界进行了计算.k-path问题是指在给定的图中找出一条长度为k的简单路径,是最长路径问题的一种特殊情况.Chen等人[7]基于分治思想对一般图中的k-path问题进行了研究,提高了该问题的计算速度.k-path问题在诸多领域具有非常重要的应用.Scott等人[8]在生物学约束下,采用彩色编码技术,在酵母蛋白质相互作用网络中查找蛋白质传导路径,其求解方法是将蛋白质作为结点,蛋白质之间的相互作用关系作为边,以此构成的生物蛋白质作用网络,权值最大的k-path代表信号传导路径;Desaulniers等人[9]利用推广k-path的不均衡性(generalizedk-pathine-qualities)对k个车辆的路由选择问题进行了研究.与k-path问题相近的是求解图中指定两点间路径长度为k的最大不相交路径问题,Itai等人[10]给出该问题的判定问题是一个NP-Complete问题的证明.求解两点间路径长度为k的所有简单路径数是具有长度约束的简单路径(SimplePathswithLengthConstraint,SPLC)问题.本文在有向无环图中求解该问题形成了SPLCinDAGs.SPLCinDAGs可在具有周期间隙约束的序列模式挖掘和具有间隙约束的模式匹配等方面得到应用.Zhang等人[11]提出了具有周期间隙约束的序列模式挖掘问题,并将该模式挖掘方法应用在DNA序列挖掘中;Tanbeer等人[12]将具有周期间隙约束的序列模式挖掘方法应用于购买模式的挖掘.尽管Zhang等人采用了空间变换的方法进行序列模式挖掘,但是此方法的基础是具有间隙约束的模式匹配问题[13].文献[14]研究了具有间隙约束和一次性条件的模式匹配问题的求解方法,给出了将具有间隙约束的模式匹配问题转换为有向无环图的算法,这使得具有间隙约束的模式匹配问题与SPLCinDAGs问题建立了实质性联系.为了解决SPLCinDAGs问题,本文利用网树数据结构(简称网树,Nettree)[13,15]进行求解.网树是一种多前驱多后继的非线性数据结构,是对树结构的拓展.网树不仅具有树结构的所有概念,如根结点、叶子结点、双亲、孩子、路径、层等,而且除根结点外,网树中任意结点可以有多个双亲结点.本文提出了网树求解有向无环图中具有长度约束的简单路径算法(NettreeforSimplePathswithLengthCon-straintinDAGs,NSPLCDAG),NSPLCDAG算法将该问题转化为一棵网树,然后利用网树的树根路径数这一特殊性质对该问题进行求解.NSPLCDAG算法的时间复杂度和空间复杂度分别为O(m×n×t)和O(n+|E|),这里m,t,n和|E|分别表示两点间的路径长度约束、顶点最大出度以及顶点数和边数.对NSPLCDAG算法做进一步改造,可以形成求解最长路径问题的算法(NettreefortheLongestPathinDAGs,NLPDAG).对NLPDAG算法做进一步改进形成改进的NLPDAG算法,该算法使得网树退化为一棵树,并使算法的时间复杂度和空间复杂度分别为O(|E|)和O(n+|E|),这里n和|E|分别表示图的顶点数和边数.本文第2节对SPLCinDAGs问题进行定义;第3节介绍网树的概念和性质;第4节提出NSPL-CDAG算法,同时分析该算法的时间复杂度和空间复杂度,并通过示例来说明算法的工作原理;第5节提出NLPDAG算法和改进的NLPDAG算法并给出求解示例;第6节给出实验结果及分析;第7节得①MertziosG,CorneilD.AsimplepolynomialalgorithmforPage3出本文结论.2问题的定义定义1.图G=(V,E),其中V称为顶点集,E称为边集.从顶点v到顶点v的路径是一个有序顶点序列S={v=v0,v1,…,vm=v},其中顶点序列应满足〈vj-1,vj〉∈E(1jm).路径长度是路径中有向边的数目.如果序列S中任何两个顶点不重复出现,则称此路径为简单路径.定义2.具有长度约束的简单路径SPLC问题是指给定图G=(V,E)中任意两点u,v∈V和正整数m,求解从u到v路径长度为m的简单路径数.SPLCinDAGs是指在给定的有向无环图中求解SPLC问题.定义3.邻接矩阵是表示顶点之间相邻关系的矩阵,图G采用邻接矩阵存储.二维数组元素g[i][j]=1(1i,jn,n=|V|)表示顶点i到顶点j之间存在一条有向边,否则表示顶点i到顶点j之间无边.顶点vi的出度(用OD(vi)表示)是第i行的元素之和,计算公式如下:顶点vi的入度(用ID(vi)表示)是第i列的元素之和,计算公式如下:例1.如图1所示的有向无环图,其顶点个数n=9,求从顶点1至顶点7路径长度约束m=4的简单路径数.从图1可以看出,顶点1至顶点7路径长度约束为4的路径数为10,即{1,2,4,3,7}、{1,2,3,6,7}、{1,4,3,6,7}、{1,2,5,8,7}、{1,4,5,8,7}、{1,4,9,8,7}、{1,5,9,8,7}、{1,2,4,9,7}、{1,2,5,9,7}和{1,4,5,9,7}.SPLCinDAGs问题的求解难度在于,顶点u和v之间的路径数呈现指数形式,因此不能采用穷举法列出所有可能的路径并判定路径长度是否满足约束条件来进行求解,本文采用网树这一数据结构进行求解.3网树的定义及性质本节给出了网树的定义和性质.定义4.网树数据结构是结点的集合,这个集合可以为空集,或可由若干不同的根结点r1,r2,…,rm和0或多个非空子网树T1,T2,…,Tn构成,这些子网树的树根至少存在一条边与网树的根结点ri相连接,这里1m,1n且1in.图2给出了一棵一般意义的网树.网树具有如下5个性质[13,15]:(1)网树是树结构的拓展,它具有很多与树相似的概念,如根结点、叶子结点、层、双亲、孩子等;(2)一棵网树可以有n个根结点,其中n1;(3)除了根结点之外,网树的其它结点可以有(4)从一个结点到达网树的一个根结点的路径(5)同一结点可以在网树的不同层上多次出现.定义5.由于同一结点可以在网树的不同层多个双亲结点;不唯一;上多次出现,这里用ni定义6.从结点ni根路径数(thenumberofrootpaths),用Nr(ni表示.树根路径数具有如下2个性质:(1)根结点ni1的树根路径数为1,即Nr(ni1)=1;(2)结点ni树根路径数之和,即Page4这里nik亲数.j-1是结点ni图3给出了一棵网树.在这棵网树中一些结点在不同层中多次出现.如结点3既出现在第2层又出现在第3层,本文采用n32和n33来分别描述第2层和第3层的结点3.结点n11和n21是网树的两个根结点;n63,n53和n33是网树的3个叶子结点.结点n63有两个双亲结点,分别是n22和n32.结点n32的树根路径数Nr(n32)=2是因为结点n32有两个双亲结点n11和n21且Nr(n11)=Nr(n21)=1;同理可知,Nr(n22)=1;Nr(n63)=Nr(n22)+Nr(n32)=3.网树的另一特征是从一个结点到达网树的一个根结点的路径可能不唯一.如叶子结点n63访问根结点n11有两条不同的路径,分别为{n63,n32,n11}和{n63,n22,n11}.4NSPLCDAG算法描述及复杂度分析4.1算法描述采用NSPLCDAG算法求解图G中u,v两点间长度为m的简单路径数问题的基本思想为:将有向无环图G转化为一棵m+1层网树,然后利用网树的树根路径数这一性质进行求解.在转化过程中,图G的顶点编号i即为网树结点名称i,网树采用从树根层至m+1层逐层创建的方式.将图G转化为一棵网树及求解的流程如下:首先,将顶点u作为网树的根结点nu1,该结点为网树的第1层且其树根路径数Nr(nu1)=1.其次,依据网树第j-1层结点创建网树第j层结点.具体方法是:取网树的第j-1层结点ni果g[i][l]=1(1ln)且在第j层未创建结点nl则在网树的第j层创建结点nlj间建立父子关系,并使得nlnlj-1的树根路径数一致;若g[i][l]=1(1ln)且ni在第j层已创建结点nl建立父子关系,并使nlj-1的树根路径数.ni最后,该网树第m层中与顶点v相连接的结点的树根路径数之和即为问题的解.NSPLCDAG算法的描述如下:算法1.NSPLCDAG算法.输入:有向无环图的顶点数n,有向无环图的邻接矩阵,输出:路径数pathnum1.读取存储图的二维数组g[i][j](1i,jn);2.依据顶点u初始化网树的根结点;3.FOR(j=2;j<=m;j++)4.FOR(a=0;a<网树第j-1层结点数;a++)5.i=网树第j-1层第a+1个结点的名称;6.FOR(b=0;b<OD(Vi);b++)7.l=顶点i的第b+1个弧的弧尾顶点;8.IF(nl9.创建nl10.ELSE11.Nr(nl12.ENDIF13.ENDFOR14.ENDFOR15.ENDFOR16.FOR(d=0;d<网树第m层结点数;d++)17.IF(g[d][v]==1)pathnum+=Nr(ndm);18.ENDFOR19.RETURNpathnum;4.2NSPLCDAG算法复杂度分析NSPLCDAG算法的空间复杂度是O(m×n×t+n2)且可进一步优化为O(n+|E|),这里m,t,n和|E|分别表示两点间的路径长度约束、顶点最大出度、顶点数和边数.NSPLCDAG算法占用的空间是由网树和图G的邻接矩阵两部分组成的.第1部分网树的开销为O(m×n×t),这是因为网树的深度是m,网树中每层最多有n个结点,且每个结点最多有t个孩子.对NSPLCDAG算法可以做进一步改进,使网树的空间开销为O(n),其改进方法如下:由于NSPLCDAG算法仅依据网树中上一层结点信息来创建下一层结点,因此在存储网树的过程中仅保留一层网树结点即可.此外,在解决SPLCinDAGs问题时,可以不必存储网树的父子关系,而仅计算当前结点的树根路径数,这样网树的开销可以缩减为O(n).第2部分存储图G邻接矩阵的开销为O(n2),也可以将图G存储为三元组形式,其开销为O(|E|),因此NSPLCDAG算法优化后的空间复杂度为O(n+|E|).NSPLCDAG算法的时间复杂度为O(m×n×t).Page5这是因为算法的第3行循环次数为O(m),第4行的最坏循环次数为O(n),第6行的最坏循环次数为O(t),算法的第5,7,9和11行均在O(1)时间内即可完成,算法的第16~18行的最坏时间复杂度为O(n).综上,NSPLCDAG算法的时间复杂度为O(m×n×t).4.3NSPLCDAG算法运行实例以例1为例来说明NSPLCDAG算法的工作原理.根据NSPLCDAG算法的思想,将例1中的有向无环图转化为一棵5层网树,所建立网树如图4所示.在图4中箭头方向代表网树的创建方向,白色圆圈内数字代表网树结点名称,灰色圆圈内数字代表该结点的树根路径数.网树的创建和问题的求解过程如下:图4求解图1中从顶点1至顶点7路径长度约束为4的网树将顶点1作为网树的根结点n11,树根路径数Nr(n11)=1.将满足g[1][l]=1(1ln)条件的所有顶点创建为网树第2层结点nl2,因此网树的第2层结点分别是n22,n32,n42和n52,且这些结点的树根路径数均为1.之后,对结点n22创建孩子结点,创建依据为g[2][l]=1(1ln),这样可以创建第3层的结点n33,n43,n53和n63,且这些结点的树根路径数均为1.依据g[3][l]=1(1ln)对结点n32创建孩子结点,易知结点n32有两个孩子结点,分别为n63和n73,此时n63的树根路径数为2.以此类推可以建立网树第3层和第4层全部结点.由于路径长度约束为4,因此根据第4层结点与顶点7的连接情况,即g[l][7]=1(1ln)来建立父子关系,并求得问题的解为1+2+4+3=10.5网树求解最长路径问题求解最长路径问题是图论中经典问题之一,其是指在给定的图G中找到路径长度最长的一条简单路径.将NSPLCDAG算法中根据顶点u创建网树的根结点变为依据图G中所有入度为0的顶点来创建网树的根结点,同时将创建网树深度为指定的长度约束变为网树不再有新的结点产生,即可对最长路径问题进行求解,形成网树求解最长路径问题的算法(NettreefortheLongestPathinDAGs,NLPDAG).NLPDAG算法从网树最深的一个叶子结点回溯至网树根结点以产生一条最长路径,故NLPDAG算法需要对NSPLCDAG算法的第2~3行和第16~19行进行修改,其余各行均保持不变,具体修改如下:算法2.NLPDAG算法.输入:有向无环图的邻接矩阵输出:最长路径pathNLPDAG算法的第2~3行:2.依据图G中所有入度为0的顶点来创建网树的根结点;3.FOR(j=2;第j-1层结点个数>0;j++)NLPDAG算法的第16~19行:16.K=j-2;17.path[K]=第j-1层的第1个结点名;18.由path[K]回溯至根结点形成最长路径path;19.RETURNpath;由于NLPDAG算法必须由最深层叶子结点回溯至网树根结点,因此NLPDAG算法不能在求解过程中删除任何网树结点且必须存储网树结点的父子关系,由NSPLCDAG算法的空间复杂度和时间复杂度分析可知,NLPDAG算法的时间复杂度和空间复杂度分别为O(K×n×t)和O(K×n×t+|E|),这里K,t,n和|E|分别表示图中最长路径长度、顶点最大出度、顶点数和边数.由于NLPDAG算法是由NSPLCDAG算法改进而来,因此NLPDAG算法不但可以找到一条最长路径,同时根据所建立的网树可以描述所有最长路径.以图1为例来说明最长路径是如何获得的.由于图1中入度为0的顶点只有顶点1,因此以顶点1为网树的根结点来创建网树,网树的前4层与图4一致,依据第4层结点创建第5层结点n65,n75,n85和n95,依据第5层结点创建第6层结点n76和n86,依据第6层结点仅能够创建第7层结点n77,由于顶点7的出度为0,因此第8层结点个数为0,循环结束,所创建的网树如图5所示,故图1的最长路径长度为6,且最长路径的最终顶点为7.结点n77的第1个双亲结点为n86;以此类推,回溯至第1层,就可以得到Page6一条最长路径:{1,2,4,5,9,8,7}.从图5可以看出,从顶点1至顶点7最长的路径只有一条,但在实际问题中,通常最长路径并不唯一.如果仅需在有向无环图中找到一条最长路径,而无需计算最长路径的路径数,则可以对NLPDAG算法进行改进.NLPDAG算法在有向无环图中求解最长路径时,对很多冗余信息进行了计算,这是因为NLPDAG算法将顶点i所指向的所有顶点均作为网树中结点i的孩子结点.在求解最长路径时,应仅选择满足删除有向边〈i,j〉后,顶点j的入度为0的点作为网树中顶点i的孩子结点,从而形成改进的NLPDAG算法.由于此时不存在一个结点具有多个双亲的情况,因此网树也就退化为一棵树或一个森林(我们可以将树看成是网树的特例).具体算法如下:结点;算法3.改进的NLPDAG算法.输入:有向无环图的邻接矩阵输出:最长路径path1.读取存储图的二维数组g[i][j](1i,jn);2.依据图G中入度为0的所有顶点来创建网树的根3.依次从已创建的网树中取一个未处理的结点i,所有4.IF(id(vj)==0)为结点i创建孩子结点j;5.重复步3和4直至不再有新的结点产生;6.最长路径长度=网树的最大深度-1,由该叶子结有向边〈i,j〉的顶点j的入度自减;点回溯至根结点以获得最长路径path;7.RETURNpath;由于改进的NLPDAG算法对有向无环图中所有有向边仅处理一次,而每次处理均在O(1)内完成,因此改进的NLPDAG算法时间复杂度为O(|E|).易知,有向无环图若以三元组形式存储,改进的NLPDAG算法空间复杂度为O(n+|E|).按照改进的NLPDAG算法对图1进行求解,生成的网树如图6所示.图6改进NLPDAG算法求解最长路径的网树6实验结果及分析6.1实验结果文献[16]采用了链式队列数据结构对有向无环图中从u到v两点间全部简单路径问题进行了研究,并以产品族零部件关系网络为例,对实际有向无环网络中的应用加以说明,该算法的空间复杂度和时间复杂度均为O(n3).由于该算法是用来求解两点间全部简单路径,因此亦可用于求解本文的SPLCinDAGs,该算法的时间复杂度与空间复杂度均保持不变.而本文NSPLCDAG算法亦可用于求解文献[16]的问题,求解的方法是以最长路径K为SPLCinDAGs的长度约束,所创建的网树则可以表示文献[16]中问题的解,显然NSPLCDAG算法的时间复杂度和空间复杂度也没有发生任何变化.图5的网树可描述文献[16]中问题在图1上的解.因此本文的NSPLCDAG算法在求解相同问题时,算法的时间复杂度和空间复杂度均优于文献[16]的算法.两种算法的时间复杂度和空间复杂度对比如表1所示.文献[16]算法O(n3)NSPLCDAG算法O(m×n×t)O(n+|E|)Page7对最长路径问题本文给出了NLPDAG算法和改进的NLPDAG算法,这两种算法的时间复杂度和空间复杂度对比如表2所示.NLPDAG算法O(K×n×t)O(K×n×t+|E|)改进的NLPDAG算法O(|E|)O(n+|E|)为了获得较大规模的有向无环图,我们采用文献[14]中的算法,将具有间隙约束的模式匹配问题转化为有向无环图.本文采用了文献[15]中使用的前4种模式串P1,P2,P3和P4来分别生成DAG1至DAG4,并且忽略了文献[15]中的全局约束.序列串采用美国国家生物计算信息中心公布的猪流感H1N1病毒的一种候选DNA序列(A/Managua/2093.01/2009(H1N1))①中的第一个片段的前510个字符.在增加源点和汇点后,使得DAG1到DAG4的大小均为512.为了避免序列串对问题求解的影响,DAG5到DAG8则采用文献[15]中的P2模式,而序列串则采用前述DNA序列的第1个~第4个序列片段的全部字符,在增加源点和汇点后,使得DAG5,DAG6,DAG7和DAG8的大小分别为2288,2301,2171和1722.表3给出了生成本文8个有向无环图的模式串.3]t[0,3]a序号P1a[0,3]t[0,3]a[0,3]t[0,3]a[0,3]t[0,3]a[0,3]t[0,3]a[0,P2g[1,5]t[0,6]a[2,7]g[3,9]t[2,5]a[4,9]g[1,8]t[2,9]aP3g[1,9]t[1,9]a[1,9]g[1,9]t[1,9]a[1,9]g[1,9]t[1,9]aP4g[1,5]t[0,6]a[2,7]g[3,9]t[2,5]a[4,9]g[1,8]t[2,9]a[1,9]g[1,9]t[1,9]g[1,9]t实验运行的软硬件环境为:IntelCore2DuoCPUT7100处理器、主频1.80GHz、内存1GB、WindowsXP操作系统.由于算法的运行速度较快,运行时间较短,为此本文全部实验均采用运行100次获得总的运行时间,然后单次运行时间为总时间除以100的方法以便较为准确地获得算法在各个实例上的运行时间.为了测试有向无环图的大小对于算法运行时间的影响,对DAG1,DAG2,DAG3和DAG4分别在256、320、384和448个结点的子图以及原图中路径长度约束分别为12,10,12和12的条件下进行了测试,并与文献[16]算法的运行时间进行了对比,结果见表4.表4不同大小有向无环图的算法运行时间对比图名称路径长度DAG1DAG2DAG3DAG4为了对比算法在不同路径长度约束下解的大小和运行时间的长短,对DAG1和DAG2在长度约束分别为16,17,18,19,20和21以及DAG3和DAG4在长度约束分别为18,24,30,36,42和48的情况下进行了测试,结果见表5.图名称路径长度DAG1DAG2DAG3DAG4表6给出了采用NLPDAG算法和改进的NLPDAG算法求得的DAG1至DAG8的最长路径长度、最长路径及求解时间.①A/Managua/2093.01/2009(H1N1)可在http://www.Page8图名称NLPDAG算法所求的最长路径表6最长路径及求解时间DAG320{1,320,322,325,328,330,332,333,337,339,342,343,344,345,346,350,353,354,357,361,DAG1512}①DAG273{1,131,135,137,142,146,149,154,159,169,179,…,470,475,484,488,493,498,508,512}②75{1,131,135,137,142,146,149,151,153,157,160,164,169,179,189,191,193,198,200,206,214,216,221,231,239,248,250,256,260,267,269,271,273,277,283,288,290,294,296,299,303,307,313,321,327,330,340,342,349,359,366,369,372,382,386,392,397,402,408,412,414,416,418,420,426,435,440,450,460,470,475,484,488,493,498,512}③78{1,131,135,137,142,146,149,151,153,157,160,164,169,179,189,190,193,198,200,206,214,216,221,231,239,248,250,256,260,267,269,271,273,274,283,288,289,294,296,299,303,307,313,321,327,330,340,342,349,359,366,369,372,374,377,383,385,386,392,397,402,408,412,414,416,418,419,426,435,440,450,460,470,475,484,488,493,498,512}DAG4DAG5DAG6DAG7DAG8①“{}”前面的数字代表最长路径长度;“{}”内的数字串代表求解出的最长路径.②由于DAG2以及DAG5~DAG8的最长路径长度较大,限于篇幅,我们仅给出了最长路径的开始和结束的部分值,中间的绝大部分采用“…”进行了省略.③由于DAG3和DAG4的最长路径的解仅在370附近至385附近有所差异,其他部分较为相似,因此本文对这两个实例给出了完整的最长路径.④由于DAG5~DAG8图相对较大,NLPDAG算法因消耗空间过大,在这些实例上未能给出运行结果.6.2实验结果分析(1)本文所提出的NSPLCDAG算法的效率要大大优于文献[16]所提出的算法.通过表4的全部20个实例可以看出,文献[16]算法的运行时间均显著长于本文算法.如在DAG3中,当路径长度约束m为12,顶点数为512时,文献[16]算法的运行时间为2526.1ms,而NSPLCDAG算法的运行时间为4.69ms.这些实验充分地说明了本文所提出的NSPLCDAG算法的效率要大大优于文献[16]算法.(2)文献[16]算法的求解时间与顶点数的大小和解的大小相关,特别是与解的大小相关,解越大,求解时间增加越显著.在表4的DAG1中,当路径长度约束m为12,顶点数分别为384、448和512时,问题解的大小均为386,算法运行时间分别为12.50ms、17.19ms和26.09ms,这说明了文献[16]算法的运行时间与顶最长路径长度及最长路径点数的大小相关.而在DAG2,DAG3和DAG4中,当解显著增加时,问题的求解时间也显著增大.如在DAG3中,当路径长度约束m为12,顶点数分别为384、448和512时,问题解的大小分别为89704、99198和135193,其运行时间分别为1308.28ms、1647.97ms和2526.1ms,这些实例充分地说明了当解显著增加时,文献[16]算法的求解时间也显著增大.产生上述现象的原因是,文献[16]的算法是从汇点出发,对每条简单路径进行逐一回溯,通过枚举所有可能的解来获得所有的简单路径,因而文献[16]算法的求解时间与解的大小相关.(3)NSPLCDAG算法的求解时间与图的大小和长度约束大小相关,更为重要的是当问题的解显著增大时,求解时间并不显著增加.通过表4可以看出,NSPLCDAG算法的求解时间与图的尺寸未呈现绝对线性变化,但是当图的尺寸增大时,运行时间也相应增加,因此NSPLCDAGPage9算法的求解时间与图的大小呈正相关.表5也呈现出同样的特点,虽然运行时间与路径长度m未呈现绝对线性变化,但是随着路径长度约束m的增大,运行时间也相应增加,因此NSPLCDAG算法的求解时间与长度约束呈正相关.此外,通过表4和5还可以看出,当问题的解快速增大时,问题的求解时间并未显著增加,这一特点在表5中体现尤为明显.如在DAG4中,当路径长度约束由18变为48时,问题的解增大了近5×109倍,然而问题的求解时间增加不到一倍,这充分地说明了当问题的解显著增大时,求解时间并不显著增加.当路径长度约束为18时,DAG3解的大小小于DAG4解的大小,但是在DAG3中的运行时间却略长于DAG4,这说明问题的求解速度与解的大小无关.NSPLCDAG算法是一个高效求解算法是因为其采用网树结构,该结构将同一层结点名称相同的结点合并为一个网树结点,有效地避免了组合爆炸现象的发生,大大地提高了问题的求解速度.(4)表5中部分实例的解为0的分析与说明.在表5的DAG1中,当长度约束为17,19和21时,问题的解均为0,造成这一现象的原因有两种:①通过表6可以看出,DAG1的最长路径长度为20,因此长度约束在大于最大路径长度时,问题的解为0,所以DAG1中长度约束为21时,问题的解为0;②本文的全部有向无环图均采用文献[15]的算法转化而来,对于DAG1来说,指向汇点的所有有向边均由模式串P1的最后一个字符‘a’来生成.模式串P1中‘a’与‘t’交替出现,因此当路径长度约束为偶数时,问题的解均不为0;而为奇数时,如为17和19时,问题的解均为0.在DAG2,DAG3和DAG4中存在同样的现象,由于模式串P2,P3和P4中‘a’,‘t’和‘g’三者交替出现,由模式串P2可知,DAG2在长度约束为3的倍数+1时,结果均不为0,而在其它情况下均为0.由模式串P3和P4可知,DAG3和DAG4在长度约束为3的倍数时,结果均不为0,而其他情况均为0.表5的DAG2,DAG3和DAG4在不同长度约束下的求解结果验证了当路径长度约束小于最长路径长度时,两点间的简单路径数也可能为0.(5)改进的NLPDAG算法适用于求解大规模有向无环图的最长路径问题.通过表6可以看出,在求解DAG1至DAG4的4个大小为512的有向无环图的最长路径时,最长路径长度达到78,由于NLPDAG算法占用空间较大,因此在求解这4个实例时,运行时间接近2s;而改进的NLPDAG算法运行时间小于10ms.而在DAG5至DAG8的大小达到2000数量级且最长路径长度达到300数量级时,NLPDAG算法因占用空间过大,未能给出运行结果;而改进的NLPDAG算法的求解时间小于100ms.这充分地说明了改进的NLPDAG算法具有较快的求解速度,适用于求解大规模有向无环图的最长路径问题.(6)有向无环图中最长路径不唯一.在表5的DAG1中路径长度约束为20(即为该图最长路径长度)时,SPLCinDAGs问题的解为360,这说明在DAG1中,从顶点1到顶点512共有360条不同的最长简单路径.此外,表6中NLPDAG算法和改进的NLPDAG算法在DAG1至DAG4中给出相同的最长路径长度,相互验证了算法的正确性,并在DAG2,DAG3和DAG4中给出了不同的最长路径,充分地说明了有向无环图中最长路径不唯一.(7)对其它现象的分析与说明.对于表4的DAG1,当其尺寸发生变化时,问题的解可能并不发生变化,即DAG1在384和448个结点的子图以及原图上问题的解均为386,这说明在DAG1中从顶点1至顶点512在路径长度约束为12的情况下,没有经过顶点384~511的路径.由于NSPLCDAG算法采用了动态分配内存的方式,因此运行时间会有一定的扰动,故算法在表4的DAG3中顶点数为256和320时,取得了相同的运行时间1.56ms;另外在表5的DAG4中,长度约束为12和18时,运行时间都为4.53ms;在表5的DAG1中,在长度约束为18时,算法运行时间比长度约束为19,20和21的运行时间都长;在表5的DAG2中,在长度约束为16时,算法运行时间比长度约束为17和18的运行时间都长,这说明算法在某些实例上运行时间会有一定的扰动.7结论本文研究了求解SPLCinDAGs问题的NSPLCDAG算法,该算法将此问题转化为一棵网树,并利用网树的树根路径数性质对该问题进行求解.网树的多前驱多后继性有效地避免了组合爆炸现象的发生,大大地提高了问题的求解速度,使得NSPLCDAG算法的时间复杂度和空间复杂度分别为O(m×n×t)和O(n+|E|),这里m,t,n和|E|分别表示两点间的路径长度约束、顶点最大出度以及顶点数和边数.本文通过对NSPLCDAG算法进行适当修改,形成了有向无环图中求解最长路径问题Page10的NLPDAG算法,在对NLPDAG算法进行改进后,形成了改进的NLPDAG算法.改进的NLPDAG算法的时间复杂度和空间复杂度分别为O(|E|)和O(n+|E|),这里n和|E|分别表示图的顶点数和边数.对比性实验验证了NSPLCDAG算法和改进的NLPDAG算法的正确性和有效性.致谢匿名审稿人对本文提出了宝贵修改意见,在此表示感谢!
