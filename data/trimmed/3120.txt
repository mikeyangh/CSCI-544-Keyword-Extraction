Page1可信计算平台信任链安全性分析徐明迪张焕国赵恒李峻林严飞(武汉数字工程研究所武汉430074)(武汉大学计算机学院武汉430072)(空天信息安全与可信计算教育部重点实验室武汉430072)摘要可信计算规范是指导可信计算产品研制的依据,可信计算规范本身的安全性需要得到验证.信任链是可信计算平台中保障系统安全可靠的主要技术手段,它是可信计算平台整个系统安全的中心问题.针对可信计算平台信任链规范的信息流安全问题,文中通过安全进程代数对信任链系统接口进行形式化建模,用可复合的不可演绎模型刻画信任链实体间的交互关系,把规范定义的信任链行为特性抽象为多级安全输入输出集,在讨论高级和低级输入输出依赖关系的基础之上,对信任链复合系统进行信息流分析,并给出结论和证明.关键词信任链;安全进程代数;可复合的不可演绎模型1引言目前,可信计算的相关研究已成为当前国内外信息安全方面的研究热点和趋势之一.一方面,可信计算在计算机系统上有着具体的实现和应用,如Vista操作系统的BitLocker通过信任链机制保护加密分区和卷主密钥,为了实现对虚拟机的动态度量,AMD和Intel生产的CPU增加了支持动态可信度量根的指令.另一方面,可信计算产品的安全测评也是业界所关注的问题,可信计算组织TCG(TrustedComputingGroup)针对可信平台模块Page2TPM(TrustedPlatformModule)的设计安全,给出了相应的保护轮廓,并通过了国际通用标准认证CC(CommonCriteria).Atmel公司的TPM产品AT97SC3201通过了认证实验室CygnaCom的EAL3认证.Infineon公司已经开始对生产的TPM进行最严格的硬件安全评估流程审核,计划要达到EAL4硬件安全水平.从其保护轮廓的文档描述来看,其主要讨论的是TBB与平台的唯一关联性问题,对于其它安全性目标并未涉及[1].可信计算产品的设计依据源于规范说明,因此可信计算产品的安全程度和规范说明有着直接联系.一般来说,规范通常是采用自然语言或者非形式化语言的一种描述,很难直接从规范中发现其潜在的安全缺陷或漏洞.目前,TCG尚未对其规范和产品的安全性进行全面的分析和验证.从公开的文献来看,TCG技术规范中仅对直接匿名认证DAA(DirectAnonymousAttestation)等协议进行了较为严格的安全性分析.信任链的交互模型建立过程是将信任链由可信计算规范进行粗粒度抽取的过程.在这方面,国内外已经有了少量工作,Abadi和Wobber在文献[2]中使用授权逻辑对下一代安全计算基NGSCB的基本框架和API函数进行了形式化描述,Chen等人用谓词逻辑分析了可信启动过程存在的信任链传递所带来的信任损失问题,并提出一种集中式度量的改进启动模型[3],但该文所提出的模型无法应用于信任链的测试研究工作.Gürgens等人使用模型检查器对TPM的若干协议进行了分析,发现了授权协议和远程证明协议中存在的问题[4].Millen等人开发了一个符号模型检查器来描述可信启动过程中TPM内部组件、BIOS和平台其它组件之间的信任关系[5],但该文主要围绕PCR的度量问题对信任启动过程进行建模,并未讨论信任链的具体交互问题.Lin使用Otter和Alloy分析TPM中API调用序列的安全性[6].文献[7-8]通过安全进程代数SPA(SecurityProcessAlgebra)和时序逻辑对信任链中的静态度量根SRTM(StaticRootofTrustedMeasurement)和动态度量根DRTM(DynamicRootofTrustedMeasurement)进行了形式化建模和证明,但是该文对于SRTM的一些前提假设,如平台配置寄存器PCR(PlatformConfigurationRegister)的写操作问题、内存写保护问题,在现有系统中过于理想.同时,信任链由系统中的多个组件构成,它建立于原有计算机硬件系统基础之上,但不是以整体形式存在于系统中,而是各组件与原有系统存在时间、空间上的交错状态[9],这种空间上的离散型,时间上的并行性使得信任链的建模变得困难.另一方面,信任链和系统之间通过相互作用形成一个复杂的系统整体结构,TPM、RTM和System都有各自的输入、输出和安全策略,从信息流的角度来看,复合系统中不应出现直接或间接的信息泄露.安全性质的可复合性很重要,一方面分解与结合是构造复杂系统的有效方法;另一方面,复杂的计算机系统是开放的,系统配置可以随时间变化,因此,复合安全性质对于定义安全系统是非常必要的[10].本文从可复合的不可演绎模型出发,对可信计算信任链规范进行形式化建模,描述信任链传递过程中的实体交互关系,通过SPA描述信任链系统的信息流性质,刻画信任链实体动作,抽象出高低安全级进程的输入和输出,最后用CoPS工具对安全属性进行验证,找出规范中存在的安全缺陷.2研究背景2.1基于语言的安全模型现有的基于语言的安全模型大致上都是扩展无干扰安全的思想,在不同层次上刻划不同安全等级的访问主体之间的无干扰关系[11],如Focardi等人扩展了Milner的CCS建立了安全进程代数[12],将系统中的名赋予“高”、“低”两种安全级别,对无干扰模型进行重新定义及分类,分析不同安全属性的强度.Ryan和Schneider使用CSP得出多个无干扰安全属性的定义,并提出一个建立统一无干扰定义属性的构想.Volpano等人将系统的可靠性视为某种无干扰属性,通过证明标准程序语义建立系统的可靠性,使得所有类型定义良好的程序都具有无干扰安全属性[13].2.2安全进程代数2.2.1SPA的基本语法安全性质是信息流性质[10].直接或间接的信息泄露都被看作系统中的信息流动,都可以使用信息流分析的技术找到系统中潜在的各种安全问题,对于信息流安全而言,安全属性刻画了一个安全的多级系统应该满足的属性,信息流分析的技术源于基本无干扰(NI)模型[14],后来又相继出现了不可推断(N-INF)模型[15]、输入不可演绎(NDI)模型[16-17].但这些安全属性都是不可复合的.后来又有学者提出Page3了策略不可演绎(NDS)模型和可复合的不可演绎(NDC)模型[12].进程代数作为描述互作用系统的一般框架,适合于研究安全信息流性质.在进程代数框架内研究信息流性质,不仅可以对其进行概括和比较,而且还可以利用进程代数中的某些结果更抽象更深刻地理解安全性及其结合性质[10].本文使用的安全进程代数语言SPA,是CCS的简单扩展.SPA的基本语法符号包括:(1)进程动作集Act.它由3部分组成:无穷名集I,I的伴名集O,一个称为哑名的元素τ.其中,I={a,b,…}表示输入动作集;O={珔a,珔b,…}表示输出动作集;=I∪O表示可见动作集合,τ表示不可见动作.更进一步,为了描述多级安全系统中不同安全级之间的信息流关系,SPA将可见动作集划分为两个安全级:高安全级动作ActH和低安全级动作ActL,并且ActH=ActHI∪ActHO,ActL=ActLI∪ActLO,ActH∪ActL=,ActH∩ActL=,Act=ActH∪ActL∪τ,通常用μ表示进程动作集.(2)进程变量集χ,并以X,Y,Z等表示进程变量;进程常量集,并以A,B等表示进程变量.(3)算子符号·,+,|,‖,\,/,分别表示前缀算子、选择算子、并行算子、复合算子、限制算子和隐藏算子.定义1.无穷名集I与伴名集O之间的二元关系·-:→为a∈Ia-∈O,a-∈Oa==a∈I.根据定义1,对于集合L,L的伴名集珚L,有珚L={μ-:μ∈L},为了表示方便,以后我们用f表示E1+E2→μE2E2→μE2E1|E2→μE1|E2,μLE→μE图1SPA的结构化操作语义二元关系·-,对于μ∈Act有f(μ-)=f(μ),如果μ=τ,那么f(τ)=τ.进程项集合是如下语法构造的集合:E∷=0|μ.E|E+E|E|E|E\L|E\IL|E/L|E[f]|χ,其中L.符号0用于表示不做任何动作的空进程;μ.E表示做完动作μ后的系统行为E;E1+E2表示选择E1或者E2;E1|E2表示系统E1和E2之间进行交织并发,并且对互补的输入/输出动作进行同步,将其作为一个内部动作τ;E\L执行属于E但不属于L∪珚L集合的动作;E\IL执行属于E但不属于L∩I集合的动作;E/L将E中所有属于L的动作转换为内部动作τ;如果E可以执行动作μ,那么E[f]执行f(μ);常量χ的定义为χ=defE,也就是χ具有E的所有功能[12].SPA除了对CCS中的动作集L进行高低安全等级划分以外,还引入了两种算子:限制算子和隐藏算子.限制算子E\L执行属于集合{E-L∪珚L}的动作,带输入限制的算子E\IL执行属于集合{E-L∩I}的动作;隐藏算子E/L把在集合{E∪L}中的动作转换为不可见动作τ.用(E)表示进程E所有的动作执行迹,那么高安全级进程和低安全级进程分别被定义为H=def{E∈|(E)ActH∪{τ}}和L=def{E∈|(E)ActL∪{τ}}.2.2.2SPA的操作语义SPA的操作语义模型是标记变迁系统模型(,Act,→),其中二元关系→×Act×的结构化操作语义[18],如图1所示.E/L→τE/LPage4除了图1中对常用操作算子的描述以外,文献[12]还提出了使用并行算子和限制算子来实现复合算子的功能.复合算子要求两个系统E和F通过并行方式构成一个新的复合系统,并同步E,F之间的互补动作.定义2.系统E和F的复合系统为2.2.3SPA的迹语义和互模拟语义察动作所组成的一个有限序列.迹是LTS理论中的重要概念,它是系统中可观定义3.E∈,E的迹T(E)={μ∈EμE}.其中μ=α1…αn∈E1,E2,…,En∈Eα1E1α2…αnEn,其中En=E.EαE表示E(→τ)E1→αE2(→τ)E.(→τ)表示内部动作序列.当EμE成立,我们认为系统从状态E到达状态E,从观察的角度来看,系统从状态E到状态E所执行的动作轨迹是α1,α2,…,αn.定义4.E,F∈,E和F迹等价当且仅当T(E)=T(F),记为E≈TF.为了能比较迁移系统的中间状态,文献[19]提出了互模拟等价的概念.互模拟刻画了两个系统之间的单步模拟思想,也就是说,当进程E执行一个动作到达E后,进程F也必须能够通过执行同样的动作到达F,进而模拟E所完成的单步过程,进程E和F继续重复进行接下来的单步过程.定义5.二元关系R×是弱互模拟,如果(E,F)∈R,μ∈Act(1)无论何时E→μE,都存在F∈使得Fμ^F和(E,F)∈R成立.(2)无论何时F→μF,都存在E∈使得Eμ^E和(E,F)∈R成立.两个进程项E,F∈的观察等价记为E≈BF,如果存在着一个包含(E,F)的弱互模拟二元关系R.3信任链规范安全性分析3.1可复合的不可演绎安全性质复合安全性质是构成复合系统安全理论的基础,可复合安全性是McCullough在分析复合系统安全性时引入的一个概念[20].可复合性是安全性质的重要特性,所谓一种安全性质Φ是可复合的,是指两个或多个满足性质Φ的进程,通过复合算子构成的复合进程P时,这个复合进程P仍满足Φ.在对不可演绎模型进行形式化描述之前,我们先给出相关的符号说明:αi∈ActH∩Ij:i=kγ,γ(j).T:系统的执行序列.V:系统执行序列t,t∈T后的值.f:T→V:从执行序列T到值V的信息函数,表示系统当前视图,或者是一组值或变量.Image(f):所有执行序列的视图集合,即t∈T,f(t)∈Image(f).定义6.令γ,γ∈()是两个迹,γ是γ的一个子序列(用γγ表示)当且仅当γ和γ满足关系:γ=α1…αn,γ=αkγ,γ(1)…αkγ,γ(m),其中mn,kγ,γ:[1,m]→[1,n]是一个单调递增函数,αi∈γ表示αi出现在序列γ中.定义7.视图函数low,highinput,lowinput,input分别被定义为(1)low:那么有γ=low(γ),γγ,如果αi∈γ,αi∈(2)highinput:那么有γ=highinput(γ),γγ,如果αi∈γ,(3)lowinput:那么有γ=lowinput(γ),γγ,如果αi∈γ,(4)input:那么有γ=input(γ),γγ,如果αi∈γ,αi∈Ij:i=kγ,γ(j).low得到动作序列中的所有低安全级动作,highinput得到动作序列中的高安全级输入动作,lowinput得到动作序列中的低安全级输入动作,input得到动作序列中的所有输入动作.定义8.令f1和f2是两个信息函数且w∈Image(f2).对于视图w而言,信息从f1流向f2当且仅当v∈Image(f1),t∈T,f1(t)=vf2(t)≠w.定义8假定了f1和f2分别对应着高安全级进程和低安全级进程,如果存在从f1和f2的信息流,那么对于系统中的任意迹t来说,即使曾有w∈Image(f2),但由于低安全级进程f2的当前视图已经被高安全级进程f1所影响,因此导致了f2(t)≠w.定义8的另外一层含义是:如果信息从f1流向了ActLj:i=kγ,γ(j).αi∈ActL∩Ij:i=kγ,γ(j).Page5f2,说明了f1的输入影响了f2的输出,那么就认为f2能够演绎出f1的输入.那么在什么情况下f2不能演绎出f1的输入呢?我们给出如下定义.定义9.给定T,f1和f2,信息没有从f1流向f2当且仅当联合函数(f1,f2)与视图积Image(f1)×Image(f2)之间满足映成关系(ontofunction).这里的映成关系指(f1,f2)与Image(f1)×Image(f2)满足一一映射.换句话说,如果对于每一个γ∈ActL,都存在着迹t∈T(E)使得γ=low(t),并且对于每一个γ∈(ActH∩I),也都存在着迹t∈T(E)使得γ=highinput(t),那么一定存在着一条迹t,其低安全级视图是γ,高安全级视图是γ.输入不可演绎模型源自Sutherland提出的信息流安全理论[16].根据输入不可演绎模型,所谓不存在信息流,意味着从进程行为的低级观察中,不能演绎地推导出关于进程高级行为的任何性质,或者说进程E具有不可演绎性质,如果进程的任何低级可观察行为low都不能推导出高级输入highinput的任何信息.前面我们对输入不可演绎模型进行了定义,下面我们用SPA给出可复合的不可演绎性质的定义.定义10.安全性质Φ是可复合的,如果P,定义11.令HActH,E∈,那么E具有可复合的不可演绎性质当且仅当Π∈Hlowviews(E)=lowviews((E|Π)\H),这里的lowviews()函数是low()函数的幂集:lowviews(E)=def{γ∈ActL|γ∈T(E)}.3.2信任链规范说明我们在文献[9]中提出了可信计算PC规范说明模型,将可信计算平台抽象为TPM、RTM和System3个实体间的交互模型,该模型描述了信任链建立过程中的实体交互关系.QΦP‖QΦ.a_SYSTEM_ACPI.smiUpdateLogEvent.CRTM+a_RTM_ACPI.smiUpdateLogEvent.CRTM从安全进程代数的角度考虑,为了能够分析信任链建立过程的信息流安全,我们需要进一步对实体的交互关系进行细化,定义出实体间的输入和输出,从安全的角度对这些输入输出进行等级划分,验证信任链系统所符合的安全属性.可信计算PC规范给出了静态可信度量根(SRTM)的实现流程和方法,图2刻画了SRTM运行期间3个进程间的输入和输出.其中System包括了OptionROMs、IPL和GRUB.System通过RTM所提供的BIOS服务接口对TPM进行访问请求;RTM包含了3种访问TPM的方式:应用层驱动、TPM-MA驱动和TPM-MP驱动,RTM会自动把来自System的应用层驱动请求转换为TPM-MP驱动方式发送给TPM,TPM-MA驱动通过BBB(BIOSBootBlock)通道与TPM进行通信,TPM-MP驱动通过SMM(SystemManagementMode)通道与TPM进行通信.图2给出了这些输入输出接口的函数,可以看出,TPM-MA驱动不对外提供任何服务,仅完成CRTM阶段的完整性度量,而TPM-MP驱动则更多地处理来自内部或外部的访问请求.下面我们用SPA语法对这3个进程实体做进一步说明.首先,为了精确刻画文献[9]中对TPM、RTM和System3个实体间的交互关系,我们需要细化信任链规范说明中3个实体交互时的输入输出.定义12.令SRTM表示信任链规范说明,则SRTM(System|RTM|TPM)\Sy,其中限制集合Sy用于实体间的动作同步.SRTM主要包含了迭代(extend)PCR、度量(read)内存代码、建立(log)度量日志和执行(call)被度量代码等操作,这里,我们把read、extend、call和log动作分别定义为读(r)、写(w)、执行(e)和追加(a)操作,并将图2中的接口函数进行归纳,那么可以得到如下描述:Page6System中的动作a_System_ACPI和tcg_PassThroughToTPM分别表示创建度量日志请求和应用层访问TPM请求;RTM中的动作ma_HashAllExtendTPM和mp_TPMTransmit表示BIOS层访问TPM请求;对于前面System和RTM的输出动作,TPM对应的有3个同步动作:ma_HashAllExtendTPM.w_PCR.TPM、mp_TPMTransmit.w_PCR.TPM和tcg_PassThroughToTPM.w_PCR.TPM.其余同步动作用于保证代码和数据的完整性,防范TOCT-TOU攻击[21].图2可信计算平台规范说明输入输出接口3.3安全性分析我们在文献[9]中刻画出了信任链交互模型,其中RTM与TPM组成TBB,RTM与TPM之间通过位于高端内存的两个驱动程序进行通信,其动作对于System来说是不可见的.我们再对RTM做进一步细化,RTM被划分为CRTM和POSTBIOS,CRTM与POSTBIOS在RTM内部进行复合,其内部动作对于TPM和System来说也是不可见的.并且我们认为RTM和TPM是绝对可信的,所有的动作都属于高安全级动作.另一方面,RTM与TPM组成的TBB需要再次与System进行复合,由于Page7System中的所有组件的安全级别都要比TBB低,因此System中的所有动作都属于低安全级动作,这里我们考虑的问题是:System能够观察出TBB中的高安全级动作或者输出策略吗?在分析该问题之前,我们先给出相关的符号定义.i:系统E的外部输入序列;inEoutEcm:系统E的指令输入序列;m:系统E的指令输出序列.c-dn:系统E的数据输入序列;珚dn:系统E的数据输出序列.sy:系统E的同步输入序列;y:系统E的同步输出序列.s-rk:系统E的结果输入序列;k:系统E的结果输出序列.r-这里的外部输入和外部输出序列是指系统通过吸收外部激励动作或事件而产生的外部输出动作或事件.对于信任链复合模型而言,System以触发相关动作与TBB进行通信而完成某种功能,如IPL通过RTM来访问TPM,进而完成对GRUB的完整性度量和完整性存储.因此IPL的输入事件对于RTM来说就是一种外部激励输入,经过内部对该输入动作的处理,RTM完成与TPM之间的内部同步并将结果作为外部输出返还给IPL.下面我们对CRTM与TPM的复合、POST-BIOS与TPM的复合、System与TBB的复合分别进行讨论.3.3.1CRTM与TPM的复合在信任链建立初期,CRTM需要通过TPM-MA驱动对POSTBIOS进行完整性度量和完整性存储,为了方便表示,这里我们用inCRTM别表示完整性度量输入和输出,inCRTM表示完整性存储输入和输出,它们都是CRTM对外所呈现的视图;c0,c-图4CRTM与TPM的LTS系统3.3.2POSTBIOS与TPM的复合当CRTM对POSTBIOS度量完毕后,POST-BIOS需要对System的第一个启动组件进行完整性度量和完整性存储.这里的符号描述和SPA描述数据序列;sy,s-号,对于实际的信任链系统而言同步信号通常是硬件总线;符号r0,r-整性度量结果和完整性存储结果.我们在前面已经说明了CRTM和TPM中的所有动作都属于高安全级动作,因此当CRTM与TPM进行复合之后,需要同步的高安全级动作统统都转换为内部动作τ,该动作和高安全级动作对于低安全级视图是不可见的.CRTM与TPM的复合模型如图3所示.用SPA进行描述的CRTM与TPM复合系统的SPA表示如下所示:经过复合算子操作后的系统如图4所示,为了图形显示方便,我们只选取了并发系统中的一条分支,可以看出,该分支中含有3个内部动作τ和两个高安全级动作inCRTM与上一小节基本相同,不再赘述.3.3.3System与TBB的复合从上面两小节可以知道,CRTM、POSTBIOS和TPM所组成的TBB中所有的输入输出动Page8作都是高安全级动作.那么对于动作序列inCRTM0.τ.τ.τ.outCRTM说,由于inCRTM安全级输入/输出对高安全级动作的依赖,因此复合系统CRTM_TPM、POST_TPM都满足NDI和NDS安全属性.那么满足NDI和NDS安全性质的TBB与System复合之后是否仍然满足NDI和NDS安全图5System与TBB的复合这里我们将同步动作集Sy仅包含信号同步动作{sy,s-y},系统System与TBB进行交互的动作集包括0,珚dSystem{c-System完整性度量结果序列和完整性存储结果序列.TBB的输入输出集分别为{inPOSTBIOSoutPOSTBIOS1},复合系统的SPA描述如下所示.System_TBB=def(System‖TBB)\Sy;System=definSystemTBB=defsy.inPOSTBIOSSy={sy,s-图6System与TBB的部分LTS系统属性呢?我们先给出System与TBB的复合模型,如图5所示.该模型和上面两个复合模型的不同之处在于,由于System中的所有动作都是低安全级动作,因此,当System与TBB进行复合的时候,完成完整性度量和完整性存储任务的指令输入输出序列、数据输入输出序列和结果输入输出序列,不能简单地将它们视为同步操作而化简为内部动作,因此这里需要对这些序列进行安全视图上的区分.0.TBB\Sy时,可以选择动作outPOSTBIOS0,由于动作outSystemActH={sy,inPOSTBIOS若考虑所有的动作集合那么最终的LTS系统将异常庞大,根据上述描述,我们只考虑动作集合{inSystem0,outSystem们对变迁系统的片段进行分析,如图6所示.可以看出,当系统System_TBB处于状态outSystemoutPOSTBIOSoutSystem达状态outSystem动作r4或者inPOSTBIOS全级输入,也就是低安全级输出依赖高安全级输入,因此复合系统System_TBB不再符合NDI安全属性,对于实际的信任链系统而言,我们将在3.5节详细说明System中的哪些动作依赖于TBB中的动作.Page93.4进一步的分析通过3.3节对信任链复合模型的分析得知,System与TBB的复合系统System_TBB既然不满足NDI安全属性,同样也就不满足NDS属性.那么究竟System_TBB要满足什么样的条件才能达到这一要求呢?定义11对进程E的可复合不可演绎性质定义采用的是NDC模型,并采用视图对其进行定义.接下来我们将使用迹语义和互模拟语义对NDC进行了定义,通过语义表示上的差别对NDC进行安全属性上的提升.我们先给出迹语义下可复合的不可演绎NDC安全属性的定义.定义13.E∈,E满足NDC性质,如果Π∈H,E/ActH≈T((E|Π)\H)/ActH.Focardi在文献[12]中认为NDC安全属性和NDS安全属性是等价的,并用互模拟语义对NDC安全属性进行了定义.因为对于存在死锁的系统而言,基于迹语义的安全属性不能检测死锁的发生,譬如高安全级进程拒绝进行同步而导致的死锁,那么低安全级进程可以通过有效的尝试去探测高安全级进程的行为,即输入和输出.因此,我们需要借助CCS中的弱互模拟语义[19]解决该问题,基于互模拟语义的NDC安全属性表示如下.定义14.E∈,E满足BNDC性质,如果Π∈H,E∈BNDCE/ActH≈B(E|Π)\ActH.接下来,我们将使用定义14所定义的BNDC性质刻画信任链中TPM、RTM和System之间的关系,并论证在何种情况下这三者组成的复合系统才能满足BNDC安全属性,即复合系统中不存在非法信息流.命题1.令TBB(RTM|TPM)\Sy,其中Sy(f(ActRTMH),那么TBB∈BNDC.ActRTM证明.根据TBB的定义可知,RTM和TPM中的所有动作都是高安全级动作,又根据定义1,有f(ActRTMSy(f(ActRTM可以化简为SyActTPMTPM)\Sy把RTM和TPM的所有接口动作都转化为内部动作τ,令余下的所有高安全级动作集合为ActRTM_TPMH.令E=TBB,显然E,E,μ∈H,E→μE,E→hE,其中μ属于集合H,那么E\ActRTM_TPMActRTM_TPMActRTM_TPM消去动作集合ActRTM_TPMActH≈BE\ActH成立.综上所述,命题成立.命题2.令SRTM(TPM|RTM|System)\Sy,其中Sy(f(ActRTM_TPM(f(ActSystem证明.设SRTM→μSRTM,SRTM→hH∪ActSystem又ActH=ActRTM,TPMSRTM,那么有μActRTM,TPMActRTM,TPMActH,因此有SRTM\Sy=(SRTM\Sy)\ActH,只需证明SRTM\Sy≈BSRTM\Sy.若hSy,则SRTM=SRTM,命题显然成立.若hSy,根据定义3有T(SRTM)=T(SRTM),根据定义5,显然有SRTM≈BSRTM,而(SRTM\Sy)SRTM,(SRTM\Sy)SRTM,因此SRTM\Sy≈BSRTM\Sy.综上所述,命题成立.命题1和命题2说明了如果复合系统的ActH集合中的元素对偶和Sy集合的所有元素存在着双射关系,也就是一一映射,那么E一定满足BNDC安全性质,这意味着从低级观察中得不到任何高级活动的信息,这与Sutherland提出的映成函数的观点是等价的.3.5实例分析下面我们以信任链接口安全模型为依据,以TCG的可信PC信任链规范为对象,刻画信任链实体动作,抽象出高低安全级进程的输入和输出,用CoPS工具对安全属性进行验证,找出规范中存在的安全缺陷.3.5.1接口安全等级划分在信任链运行期间,RTM和TPM通过接口进行了复合,一方面,我们需要发现这种复合是否能够保护高级输入输出,另一方面,RTM和TPM所组成的TBB子系统与System又进行了复合,我们需要进一步发现该复合能否满足不可演绎安全性.为了能验证这些安全属性,我们给出了限制集合Sy和高安全级别动作集合acth,如下所示.Sy={ma_HashAllExtendTPM,mp_TPMTransmit,a_RTM_ACPI,e_POSTBIOS,r_OptionRoms,e_OptionRoms,e_IPL},acth={ma_HashAllExtendTPM,ma_HashAllExtendTPM,mp_TPMTransmit,mp_TPMTransmit,W_PCR,tcg_PassThroughToTPM,smiUpdateLogEvent,a_System_ACPI,r_POSTBIOS,r_OptionRoms,a_RTM_ACPI,a_RTM_ACPI,e_POSTBIOS,Page10e_POSTBIOS,e_OptionRoms,e_OptionRoms,r_IPL,e_IPL}.Sy集合用于同步RTM与TPM之间的输入输出,可以看出集合drv={ma_HashAllExtendTPM,也出现在acth中,这是因为drv中的动作是运行在SMM模式下,此时CPU是运行在最高特权级上,因此将集合drv中的所有元素都视为高安全级动作,tcg_PassThroughToTPM动作是TPM响应应用层请求的输入动作,该动作和w_PCR都应视为高安全级动作,a_RTM_ACPI动作用于创建度量日志,其后续动作是smiUpdateLogEvent,这两个动作的运行环境也同样是在SMM模式下.除此以外,高安全级别动作集合acth中还包括了r_POSTBIOS,e_POSTBIOS,r_OptionRoms,e_OptionRoms,r_IPL,e_IPL.附录表1对每个动作的含义给出了描述.3.5.2接口安全测试为了验证可信计算PC规范说明的SRTM是图7CoPS验证修改前的信任链规范说明图8CoPS验证修改后的信任链规范说明否满足BNDC,我们使用CoPS对其进行验证,CoPS是Pivato等人开发的用于自动化验证多级安全属性的工具,用于验证系统是否满足P_BNDC、PP_BNDC或SBNDC等安全性质[22].将以上用SPA描述的System、RTM和TPM的接口函数转化为CoPS后,得到的验证结果如图7所示.在验证过程中我们发现,根据上述划分的SRTM并不满足BNDC安全性质,这是因为在Sys-tem中存在着低安全级动作对高安全级动作的依赖,因此低安全级的System就可以通过隐式的方法获得TBB中的高级输入或者输出;我们可以通过消除这些依赖使得修改后的信任链规范说明满足BNDC安全属性,例如,我们将高安全级输出动作w_PCR作为同步动作,那么也就意味着该动作对于TPM之外的实体而言是不可见的,因此就消除了低安全级动作与w_PCR之间的关联关系,这样的系统将满足定义14中所描述的BNDC性质,如图8所示,同时也证实了命题2的正确性.表1给出了SRTM中所存在的低安全级动作对高安全级动作的依赖.Page11命题1和命题2所提出的信任链复合系统是理想情况下的安全系统,实际情况下的规范说明和系统实现很难全部满足这些安全属性,譬如,低级输出tcg_PassThroughToTPM影响着高级输出w_PCR,这说明低级进程可以间接地对PCR进行任意迭代;低级输出a_System_ACPI影响着高级输出smiUpdateLogEvent,这表明低级进程能通过高级进程对度量日志进行追加操作,而这些进程动作都是远程证明协议的一部分,可见它们将直接影响其安全性,关于这一点我们将在以后进行讨论.4结论信任链是由不同安全属性的子系统组成的复合系统,复合后的高级子系统安全性质应该保持.其中的每一个子系统都满足一定的安全性质,这些子系统组合而成的系统是否仍然满足给定的安全性质?另一方面,在信任链建立阶段,各个子系统之间的访问是否存在违反规范约束的行为或操作,进而破坏信任传递,甚至获取机密信息?针对上述问题,本文将信任链抽象为多个实体的进程交互模型,通过接口细化的方式对进程间的高低安全级动作进行描述,并以信任链规范为实例,通过抽取规范中的高低等级输入输出,找出它们之间的关联规则,把对信任链安全属性的验证转换为对表示进程的代数项的语法检查上,我们认为高级进程的动作元素对偶与限制集合满足双射关系是信任链满足复合安全性质的充分条件.结合实际规范说明,我们用CoPS对提出的安全模型进行了安全验证,发现其中潜在的安全缺陷及其可能造成的影响.
