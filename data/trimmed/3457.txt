Page1网络服务行为的进程代数验证方法研究及其应用陈福1),2)杨家海2)杨扬3)王元卓4)贾美英3)1)(北京外国语大学计算机科学与技术系北京100089)2)(清华大学信息科学与技术国家实验室北京100084)3)(北京科技大学计算机科学与技术系北京100083)4)(中国科学院计算技术研究所网络重点实验室北京100083)摘要通过形式化建模分析了系统特点,确认系统行为,从而尽可能避免系统的冲突等情况.文中提出了一种使用进程代数描述网络服务组件的行为建模方法,包括强模拟、强互模拟、时效性、触发器、服务环境等网络服务交互行为描述方法,然后给出了P2P节点的节点发现、防火墙穿越等行为的描述,提出了适用于托管的RCMMS网络自管理协议,并使用代数的方法描述协议行为,确认其合理性,从而验证文中所提出的方法.关键词进程代数;π演算;服务行为;交互系统演算1引言近年来,随着物联网、云计算、三网合一等快速Page2构(SOA)、基础设施即服务(IaaS)、平台即服务(PaaS)、软件即服务(SaaS)等研究受到高度重视.这种以服务及其组合为基础的系统具有并发、异构、交互的特点.目前缺乏普适的、广为接受的针对服务及其合成活动抽象本质的、形式化的表述和验证方法.它对以交互为基础的网络通信或管理协议的行为分析、验证和确认具有重要意义.基于此,本文提出了一种网络协议行为建模和分析方法,使用强模拟、强互模拟、时效性、触发器、组件情境等描述网络协议交互行为,给出了P2P节点的节点发现、防火墙穿越等交互行为描述,并完善MMS协议提出了RCMMS适应于托管的自管理协议,然后使用进程代数给出其协议行为的交互过程验证,从而验证本文所提出的方法.2组件行为演算2.1组件行为语义描述网络服务组件、协议及交互性系统,需要严谨的行为定义、描述和分析,确认相应的系统行为是否符合设计要求是一个重要的问题.特别是交互行为可能传递节点、链接或通信信道,从而使得系统结构动态变化,这种交互式组件的交互、协同、组合过程具有明显的异构性、交互性、并发、并行等特点.如何根据协议或网络组件行为的逻辑规则,对交互行为进行严谨的刻画、演绎和行为推理,使组件行为功能明确、可信,从而增强系统的可信性和可管理性,为用户提供平台独立、透明、稳定、可信的系统,是网络协议和交互式系统设计的核心问题之一.代数的方法可用于描述交互式组件、网络协议行为,分析行为可能存在的混或、竞争等形成的不确定性,具有严谨确认交互式组件行为是否符合设计要求的能力.同时由于代数演算的推理功能、行为等价相关概念,使得协议组件的取代、替换和重组能力大为增强.特别是基于互联网的组件,进行必要的行为推理和预测是非常重要的.协议组件之间的交互行为对性能具有重要影响.可见使用代数的方法刻画协议组件行为在组合、发现、确认、替代等方面具有重要作用.而使用代数的方法形式化描述计算过程也是经典的做法.形式语义学以数学为工具,运用符号和公式对计算模型、过程和计算机程序进行严谨的描述、解释和推理,使语义形式化,籍此研究协议行为分析、计算模型、程序设计语言语义表述问题.形式语义学一般分为操作语义学[1]、指称语义学[2]、公理语义学[3]和代数语义学[4]四类.本文应用并发系统的代数语义的形式化表述能力,并结合网络协议涉及的节点、链接和运行环境高度的动态性和交互性,尤其关注具有描述移动、并发和交互功能的代数语义研究.“并行”是利用多个处理机或其它功能部件同时工作以提高系统性能或可靠性,冯·诺伊曼在20世纪40年代提出细胞自动机可认为是并行计算思想的开端.并发概念由PetriCarlAdam[5]于1962年首先严格定义并建立了模型.MilnerRobin把可以按任意次序在系统内发生的两个事件定义为并发事件.由于并发系统本身具有的高度动态、并发、不确定、交互性和异构性,分析和研究这些特点是保证系统的健壮性、可靠性的重要基础.对具有这种特点的系统结构、行为进行严谨的数学描述,可以准确地分析系统的安全性、活性、可生存性、可管理性,对系统性能评价亦有重要意义.进程代数[6-7]是一种较为常用的刻画并发系统的数学工具.进程是系统的行为,代数是使用代数的或公理的方法研究行为.进程代数是使用代数公理研究并发、分布式、交互系统的理论[8].Baeten定义了可称为进程代数的条件:至少包含选择、顺序、并发三个算子,并满足交互性、选择合成、幂等性、右分配性、顺序合成结合性、并行合成交互性、并行合成结合性这7条规则[7].MilnerRobin从1973~1980年一直从事并发理论研究,并于1980年提出了CCS(CalculusofCommunicatingSystems)[4].CCS的提出标志着具有完善的同余集合和语义模型的进程代数的建立.随后由ParkDavid[9]提出的互模拟公理极大提高了进程代数的理论完整性,并成为进程代数中的重要概念.HoareTony[10-11]提出的CSP(CommunicationSequentialProcess)去掉了全局变量,使用消息传递的通信模式.由于MilnerRobin等均使用进程演算(processcalculus),进程代数(processalgebra)一词的提出和明确定义最早见于1982年Bergstra和Klop[12]的进程行为的不动点描述.随后Bergstra、Keller定义了通信功能从而建立了ACP(AlgebraofCommunicatingProcess)[13-14].其它代表性工作包括ISO的LOTOS(LanguageofTemporalOrderingSpecifications)[15-16]、ATP(AlgebraicTheoryofProcesses)[17]等.使用代数演算把系统的事件或进程与时间、触发概率等信息相关联起来,从而可对并发系统定量描述或评价[18].进程代数在我国也得到了充分的重视,林惠民院士设计并实现了进程代数验证工具PAM/VPAM,并Page3与英国Hennessy教授合作提出,独立发展了“符号互模拟”理论,解决了传统并发计算模型对大量实际应用不能有效模拟的问题[19-20],在国内外产生了广泛的影响.任何进程语言都需要定义其操作语义,对系统组件的行为效果进行描述,从而使得其所描述的语义明确、避免二义性.Plotkin提出了一种称为结构化操作语义(StructuralOperationalSemantics,SOC)的语义描述方法,它把复合成分的操作语义归结为其各个组成部分的操作语义,并定义了形如p→αp的进程变迁,表示进程P执行动作α而演化为进程p[21].并发系统的行为涉及进程的状态、组件的活动和触发活动达到某种状态的事件,对三者之间关系进行描述主要有标号变迁系统[22]、事件结构[23-24]描述等,其中事件结构描述事件之间的关系,而标号变迁系统则侧重于描述状态之间的关系.λ演算作为顺序、函数式、读写程序的计算模型,CSP、CCS作为静态并发、并行的计算模型,π演算[25-27]、环境(Ambient)演算[28]、Seal[29]演算等作为移动通信、动态并发、并行计算模型,从这个发展可知计算行为的数学描述从顺序、并行、并发到移动、交互逐步演进,而移动、并发计算行为的基础是并行计算行为,并行计算的形式语义学及形式化方法的研究是理论计算机研究中的重大问题之一.其中Milner等提出的描述移动通信系统、刻画进程的互模拟等价关系的π演算,得到了广泛关注.为描述组件的行为和结构,建立组件及其交互行为的描述表达式极为重要,这也是本文的重点内容.由于π演算能够描述结构不断变化的、移动的、并发的、交互的系统,同时π演算具有成熟的互模拟、等价性等理论,因此本文提出的组件交互行为建模理论主要基于π演算.名:组件之间链接的名称.发送/接受动作:设a为组件的一个动作,则a-表示动作的发送行为,a则直接表示接受行为.组件结构同余:如果两个组件行为表达式P、Q是结构同余的,则可以用名替换的形式{b→/a→}由P转化为Q或相反,记为P≡Q.组件私有通信信道:组件P、Q通过通信通道α进行通信,并要求任何其它组件不能通过α与组件P、Q通信,记为(vα)(P|Q).但通道α本身则可通过组件P或Q传送给其它组件,这样其它组件就可以使用通道α,从而具有描述组件动态演变的能力.程或线程.并发:记为P|Q,其中P、Q表示并发执行的进输入前缀c(x).P:表示在开始组件P之前完成通过通信通道c接受的消息,使用名x接收传送过来的名.这种模型用于模拟等待一个网络通信事件.输出前缀c-〈y〉.P:描述了在组件P发生前使用通道c将名y发送出去.这种情况或通过网络发送一个消息或是一个转向语句.复制!P:创建一个新的组件P的拷贝.这主要用于模拟复制过程.建新名(vx)P:在组件P中建立常量x,为通信通道.不确定选择P+Q:不确定选择执行组件P、Q.[x=y].P:如果名x与y相等则执行组件P.T.P:执行一个内部动作T后执行组件P.[x≠y].P:如果名x与y不相等则执行组件P.空进程0:已经执行完毕或停止.综上,组件基本表达式为S∷=c(x).P|c-〈y〉.P|(vx)P|0|P|P|!P.2.2组件交互行为的强模拟、强互模拟(1)组件行为强模拟设(Q,T)为一个LTS,R为Q上二元关系.满足下列条件称R为(Q,T)的强模拟:两个组件p、q满足pRq,如果p→αp,则存在q∈Q,q→αq,且pRq,则我们就认为q模拟了p.(2)组件的强互模拟关系R是序偶(x,y)对的集合,关系R的逆R-1为序偶(y,x)对的集合.基于组件集合Q的二元关系R,如果R及其逆均为强模拟,则称R为在标号变迁系统LTS(Q,T)的互模拟关系,且组件p与q是强模拟或强等价,记为p~q.(3)关联组件的强互模拟两个服务系统P、Q,设(C,T)为一个LTS,R为Q上二元关系.若任意两个组件p、q满足p~q条件,我们称服务系统P、Q在关系R上强模拟.2.3组件结构替代分析组件可能受环境或自身影响而导致某个节点组件失败,而不仅仅和节点本身有关,但可能很快又恢复组件功能,具有很高失效概率且又有很高失效后恢复概率的特性.同时,不同的节点可能会提供相同或相似的组件,因此可以通过上述观察等价性得到功能相似或相同的组件,从而获得可靠的虚拟组件性能.Page4(1)顺序可替代行为S1?S2.适应的条件是当系统的性能和资源条件要求不能同时运行相同或相似组件获得高可靠组件的情况.组件S1?S2的观察等价行为等同于S1,当S1失效时通过组件S2获得组件.j=1(2)多元顺序可替代行为C?∑n∑nSj是观察行为与Si相同或相似的组件集合,当Si失效时从∑n(3)并发竞争替代行为S1|S2.允许两个组件S1、S2同时并发执行,组件S1|S2的观察行为与最先完成的组件行为相同.(4)多元并发竞争替代行为|∑n时执行取得最先执行成功的组件.2.4组件的过程控制与组件环境描述时控组件TimeServ(t,S):执行组件S直到组件执行时间超过可容忍时间t而终止组件S.组件选择执行:根据输入名确认执行某个组件,x(v).([v=y1]P1+[v=y1]P2…),其中yi各不相同.组件触发器Exec(x)=defx(y).y-:通过链接x得到链接y,然后激活链接y.该式常称为触发式,下列两种情况等价:(1)直接执行进程P;(2)进程P加前缀z,然后通过触发式传送z.如(z)(x-z|z.P)与进程P等价.组件环境C:因为组件的内部交互、内部结构对组件的使用者隐藏,组件的等价性需使用观察等价性来描述.而观察等价性是基于组件执行环境,因此这里给出组件环境上下文的定义.这里[]表示“空”的含义,即等待具体的组件填入.C∷=[]|α.C|(vx)C|C|P|P|C|C?C|!check(sigl).Peer;send(msg).Peer;forward(x).RouerPeer;push(msg).RouerPeer;check(sigl).Peer;send(msg).Peer;forward(x).RouerPeer;push(msg).RouerPeer;3P2P行为能力描述网络组件行为分析和建模是验证、确认、分析和管理网络组件的重要工具.下面给出使用代数的方法来描述P2P组件的行为.分别通过P2P发现行为、穿越防火墙行为、节点消息路由行为、P2P缓存等给出代数语义描述.3.1Peer节点发现P2P节点通过聚合节点发现其它各个节点.同peer表示发出请求节点,x表示标识自身信息的唯一标识;RenderPeer表示聚合节点,cachse表示P2P的缓存信息.下面给出组件行为定义:发出请求:ask(x).Peer;接受请求:ask(x).RenderPeer;响应返回:resps(info).RenderPeer;接受响应:resps(info).Peer;缓存信息:(vcachse)Peer;发现组件行为描述,包括节点的发送、聚合节点接收、聚合节点响应及其之间的交互行为:ask(x).Peer→askPeer;ask(x).RenderPeer→askRenderPeer(cache/x);resps(info).RenderPeerresp→sRenderPeer(cache/info);resps(info).Peerrep→sPeer;ask(info).RenderPeer→askRenderPeer;ask(x).Peer→askPeer(x/info).3.2P2P穿越防火墙行为分析P2P节点之间如果被防火墙隔离,相互之间通信的机制可按如下行为进行:外部Peer将消息发送给防火墙外部的路由Peer,外部的路由Peer等待防火墙内部的节点定期主动发出连接路由Peer,然后将相应信息发给内部的Peer.其过程描述如下(其中Peer1、RendPeer分别是防火墙内部通信的两个节点,Peer为通信节点、RendPeer为转发节点,Peer为防火墙外部转发节点):Page5send(msg).Peer1|send(msg).RouerPeer1→sendPeer1|RouerPeer1(msg);forward(msg).RouerPeer1|forward(x).RouerPeer2forward(x→)RouerPeer1|RouerPeer2(x/msg);push(msg).RouerPeer2|push(msg).Peer2p→ushRouerPeer2|Peer2(msg);!check(sigl).Peer2;check(sigl).Peer2;send(msg).Peer1|send(msg).RouerPeer→sendPeer1|RouerPeer(msg);push(msg).RouerPeer|push(msg).Peer2p→ushRouerPeer|Peer2(msg).4网络自管理协议验证4.1协议提出网络的自管理是异地远程网络管理的基础,自管理本身也是一个非常复杂的问题.自管理(源生管理)是网络正常运行和提供组件理想的实现手段.如交换机、路由器等网络接入点的自我管理,包括自配置、自优化、自治愈等,是从根本上提高网络可生存性的重要保证.自管理是网络服务的热备份、迁移、配置和性能分析等网络管理远程实现的基础和前提.而且,这种网络自管理能力本身的可生存性要高于网元数据路由的生存能力.因此,健壮的网络管理通信能力就成为了一个核心工作.利用现有的网络设施和通信协议建立网络管理通信是目前的主要实现手段.这种叠加在现有数据路由交换通道之上的管理信息传输,不可避免地受到现有网络数据通信路由协议本身的安全、可靠性和可管理性的局限而受到限制,只能以一种被动的方式实现网络的配置和管理.网络数据路由的目的是数据的内容安全、高效的转发和传输,管理通信的目标是确保数据通信目标的实现,将性质和目的完全不同的数据路由通道和管理通信路由通道不加区分地进行转发与传输是网络管理的一个重大瓶颈.在不明显增加设备负载的前提下,将数据通信和管理通信分别路由处理,是提高网络管理能力的重要实现手段.本质上这是网络管理和网络通信共享相同物理基础设施基础上的逻辑分离,为从根本上提高网络管理能力提供了重要保证.这种专用于配置和管理的管理路由通道逻辑上独立于数据路由,具有简单、安全、健壮的特征.共享物理网络设施,建立逻辑上独立的管理路由通信通道,从异地远程管理网络,国际上提出了各种解决方案.得到了国际上本领域专家学者的充分重视.Maltz等人[30]提出的元管理服务层MetaManage-mentServiceLayer(MMSL)是其中的一个代表.MMSL通过ComponentManager(CM)和Manage-mentAuthority(MA)分别实现被管网元管理端口输出和管理操作中心.该协议能够很好地解决网络的管理通信路由与数据路由的区别.但该协议存在一个重要的缺点.虽然提及了MA失效及多个MA并存的情况.但存在一下问题:(1)没有MA中密钥和加密源路由的处理,一旦MA失效只能重新洪泛、重新生成各个节点的源路由;(2)一个MA失效,各个CM都要再更新安全源路由,原来所有缓存均失效;(3)需要重新生成MA与CM之间的公钥/私钥对.这些都需要一定的时间,从而影响了网络管理.这类似于计算机系统出了问题必须重新启动计算机一样.本文在MMS基础上提出了RingChainMetaManagementService(RCMMS),能够在不中断管理的前提下,恢复MA的管理能力,原公钥/私钥不变、源路由不变、生成树不变,从而极大提高了效率.下面给出其逻辑含义并使用进程代数证明其逻辑的正确性.4.2RCMMS协议如图1所示,MA作为管理节点其重要性不言而喻.为了保护正在启用的MA节点的信息,使用了链式洋葱路由.这种路由独立于数据路由,采用自身管理路由,具体实现方法和MMS一致,当MA集合中建立起后,采用任意一点作为发出加密路由原点向另外间隔特定长度的节点发出安全源路由.而这种出发原点节点根据一定步长逐步改变,从而确保了整个链式结构信息一致,而各个节点又无法得到全局MA拓扑,从而当正在启用的节点失效后能够采用任意其它节点取代,原来的生成树及其中各个节点的缓存路由仍然有效.这样就可以极大地提高整个系统的速度、安全和稳定性.MA发出pathexplorer洪泛消息对CM进行发现,为了及时发现路由失效,需要定期地发起pathexplorer洪泛消息.这种消息带有唯一的标识符.当CM从其一接口接收到MA的pathexplorer洪泛消息后将自身ID追加在pathexplorer洪泛消Page6息,然后向其自身其它接口发出,同时将该MA到CM的路径缓存用以从CM到MA逆向通信.由于pathexplorer洪泛消息本身带有序号,这样就可以避免重复泛洪.其行为描述为洪泛路由:flood(ID).MA;flood(ID).CM;启动行为:boot(ID).MA;boot(ID).CM;时延路由更新洪泛:Timer(timerflood).flood(pathexploer).MA;拓扑更新洪泛:topology.flood(ID).MA;缓存路由:cache(path).CM;链路回声:send(mgmtIP).CM;send(mgmtIP).MA;私有通信通道:new(comm)(comm.comm.MA|comm.comm.CM);更新行为:update(ID).MA;update(ID).CM;install(ID).MA;install(ID).MA;链路状态通信行为:send(ID,Link).CM;send(ID,Link).CM;失效更新路由:TopologyUpdate(flood).flood().CM;追加路由:append(selfID).CM;变更路由:change(state).Advertise(LSA).CM:创建管理网元代理:create(mm0,IP).MA;create(mm0,IP).CM;CM与MA之间通信:request(x).CM,request(x).MA;MA转发通信:forward(x).CM,forward(x).MA;MA的安全源路由:encrypt(PathNodes).MA;CM转发路由:encrypt(PathNodes).forward.(PathNodes).CM.4.3RCMMS协议逻辑推理4.3.1MA集合节点链式洋葱路由首次运行时,当前采用的MA节点将MA的最MA节点发出洪泛或时延发出洪泛:小生成树及各个节点的公钥信息加密.然后当前节点MA将最小生成树、各个CM节点的公钥加密发送.发送的终点是与当前采用的MA节点相隔一定的节点.经过一定的时间间隔后该终点作为启动继续采用各个的方式进行环形路由.当前采用的MA一旦受到攻击,离他最近的节点就自然成为当前节点,从而避免了相应节点的重新洪泛.采用洋葱路由可使得各个节点对除相邻节点外的所有节点并不感知,因此极大地保护了该环路节点.具体过程描述如下:receive(ID).uncover(privekey).receive(ID).MA|receive(ID).uncover(ID)receive(ID+x).MA;TimerServer.receive(ID).MA|receive(ID).MA.4.3.2MA集合节点链式洋葱路由flood(ID).MA|TimerServer(timerflood).flood(pathexploer).MA|topology.flood(ID).MA;CM节点接受洪泛、追加ID、缓存路径、转发洪泛,给出链路状态信息:flood(ID).append(selfID).send(ID,SLA).flood(ID).CM|change(state).Advertise(LSA).CM通过上述步骤后,一个MA可以获得上述各个CM返回的信息,从而得到网元链接的图状结构,根据Minimumspanningtree、Dijkstra等算法可以获得以当前MA为原点到各个顶点的最短路径.当两个CM需要通信时,CM通过向MA发送转发请求实现:new(request,forward)(requet(x).CM1|request(x).forward.MA|forward(x).CM).MA构造加密源路由:由于MA知道所有的CM密钥,因此可构建各个CM的安全源路由,ConstructOnionEncryptedRoute.MA;当CM发现某个邻接链路不通就会向MA发送链路状态通告LSA,这是通过路由备份实现的,如最优路径、次优路径等.4.3.3MA集合中MA1替代MA0根据RCMMS协议要求,只要MA集合中的元素具有强模拟能力就可以.这样就可以确保当前MA根受到攻击后能够自动的替代.根据强模拟的定义,设关联关系R满足R={(MA00,MA10),(MA00,MA12),(MA01,MA11),(MA02,MA11)},其关系如图2所示.证明两个组件MA0、MA1是强互模拟的.其中MA0表示正在使用的MA根,而MA1则是另一具有相似功能的MA.如图2所示.Page7证明.(1)因为(P0,Q0)∈R且MA00→aMA01,则存在MA10→aMQ11,且(MA01,MA11)∈R;MA00→aMA02,则存在MA10→aMA11,且(MA02,MA11)∈R;(2)因为(MA00,MA12)∈R且MA00→aMA01,则存在MA12→aMA11,且(MA01,MA11)∈R;MA00→aMA02,则存在MA12→aMA11,且(MA02,MA11)∈R;(3)因为(MA01,MA11)∈R且MA01→aMA02,则存在MA11→aMA11,且(MA02,MA11)∈R;(4)因为(Ma02,MA11)∈R且:MA02→aMA02,则存在MA11→aMA11,且(MA12,MA11)∈R;因此MA1强模拟MA0,因此完全可用MA1取代MA0.4.3.4MA集合中MA1互替代MA0如果管理组件MA集合中存在如下关联关系R,满足R={(MA00,MA10),(MA00,MA12),(MA01,MA11),(MA02,MA11)},R-1={(MA10,MA00),(MA10,MA02),(MA11,MA01),(MA12,MA01)},其中{MA00,MA01,MA02}∈P,{MA10,MA11,MA12}∈MA1,MA0、MA1是可以互相取代的,这可以根据强等价性证明.证明.(1)服务系统MA1强模拟MA0.因为(MA00,MA10)∈R且:MA00→aMA01,则存在MA10→aMA11,且(MA01,MA11)∈R;MA00→aMA02,则存在MA10→aMA11,且(MA02,MA11)∈R;因为(MA00,MA12)∈R且MA00→aMA01,则存在MA12→aMA11,且(MA001,MA11)∈R;MA00→aMA02,则存在MA12→aMA11,且(MA002,MA11)∈R;因为(MA01,MA11)∈R且:MA01→aMA02,则存在MA11→aMA11,且(MA002,MA11)∈R;因为(MA02,MA11)∈R且:MA02→aMA02,则存在MA11→aMA11,且(MA002,MA11)∈R;因此服务系统MA1强模拟MA0.(2)服务系统MA0强模拟MA1.因为(MA10,MA00)∈R-1且:MA10→aMA11,则存在MA00→aMA01,且(MA11,MA01)∈R-1;因为(MA12,MA00)∈R-1且MA12→aMA11,则存在MA00→aMA01,且(MA11,MA01)∈R-1;因为(MA11,MA01)∈R-1且:MA11→bMA12,则存在MA01→bMA00,且(MA12,MA00)∈R-1;因为(MA11,MA02)∈R-1且:MA11→aMA11,则存在MA02→aMA02,且(MA11,MA02)∈R-1;因此可知,MA00、MA1基于关系R强互模拟,可以相互替代.5结论通过代数演算可以充分理解计算模型、网络协议和交互行为过程,通过等价、互模拟等方法可对多网络协议行为过程进行严谨的描述和推理.目前以网络服务组件为基础的协议交互行为的数学描述研究急需加强.因此基于现有研究工作基础,加强对网络服务组件的交互行为、计算行为的行为演算研究非常必要.这对网络协议行为分析、交互过程行为定义和确认具有重要意义.Page8
