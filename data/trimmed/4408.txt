Page1MapReduce集群中最大收益问题的研究王习特申德荣于戈白梅聂铁铮寇月(东北大学信息科学与工程学院沈阳110004)摘要MapReduce是目前最为流行的用于大数据分析的并行系统之一.许多企业已经搭建了自己的MapReduce集群,为广大用户提供计算服务.用户可以向集群提交具有完成时限要求的MapReduce作业,若作业被按时完成,则企业可以获得一定的收益.针对这种应用场景,该文首次提出了MapReduce集群中的最大收益问题.为有效地解决该问题,首先提出了一种基于序列的任务调度策略(简称为SEQ策略),并证明了在处理具有完成时限约束的作业时SEQ策略存在优势.基于SEQ策略,该文提出了最大收益的调度算法(SchedulingAlgorithmforMaximumBenefit,简称AMB算法),该算法可以快速地确定可接收作业,并给出有效的执行方案,以达到最大化收益的目的.另外,针对在实际应用中的某些异常情况(如节点宕机),该文也设计了有效的超时处理策略,进一步增加了算法的实用性.最后,通过大量的实验验证了该文所提出算法的有效性.关键词大数据;MapReduce集群;完成时限;最大收益问题1引言如今,随着信息技术的不断发展,数据呈现出爆炸式的增长趋势,而对于海量数据的分析与处理也成为了一个热点课题[1].MapReduce[2]作为一款流行的并行计算框架,已被公认为是用于分析和处理海量数据的最有效途径之一.该框架提供了一套简洁高效的API,用户只需要编写相应的Map和Reduce函数,就可以轻松的处理TB甚至PB级别的海量数据,而不用关心具体的处理细节(如数据分布、容错处理等).目前许多大型IT公司都已经组建了自己的MapReduce集群,为广大互联网用户提供方便快捷的云计算服务.用户只需要支付一定的费用,就可以在这些集群上运行自定义的MapReduce作业.在这个过程中,IT公司与用户之间经常以服务层协议[3-4](ServiceLevelAgreement,SLA)的方式来规定服务的具体细节.常见的付费方式主要包括如下2类:一种是按租用量付费,即所支付的费用与用户所申请的集群规模和使用时间成正比;另一种是按完成效果付费(或称按完成时限付费),即用户在提交作业的同时也给出完成时间的要求,服务提供者只有按时完成该作业,才能获得相应的报酬.如情感分析、垃圾邮件检测等常见的MapReduce应用,都需要相应的完成时间保证,是典型的按完成时限付费的应用实例.本文所提出的最大收益问题主要针对有完成时限约束的MapReduce作业.具体地,每个用户提交的作业可以抽象为如下4部分:(1)对作业内容的具体描述,即用户自定义的Map和Reduce函数;(2)完成时限,即用户对作业最终完成时间的要求;(3)收益,如果作业被接收并且按时完成企业可以得到的经济收益;(4)赔偿,如果作业被接收但未按时完成需要赔付给用户的费用.对于这些服务提供商而言,在一段时间内可能有大量的用户申请运行作业.考虑到有限的集群规模和计算能力,服务提供者需要选择性地接收合适的作业,并使用有效的调度算法保证所有接收的作业能够按时完成,以达到最大化经济收益的目的.针对上述情况,本文首次提出了MapReduce集群中的最大收益问题.为有效解决该问题,需要从大量申请中快速找到可接收的作业集合,并根据MapReduce作业的执行特点,给出合理的调度方案,具体的难点如下:(1)快速选择合理的可接收的作业集:明显地,对于N个作业申请,可以有2N种接收作业集.服务提供者需要快速地从中确定一个合理的接收作业集.一方面,他们希望接收尽量多的且具有较高收益的作业,以最大化总收益.另一方面,如果接收的作业过多超过了系统的计算能力,会导致许多作业无法按时完成,反而会降低总收益.因此,如何选择合理的可接收作业集是难点之一.(2)合理的调度算法:当确定了可接收作业集合之后,一旦出现某个接收的作业无法按时完成,就会带来收益损失,因此合理的调度算法是非常必要的.但是由于MapReduce作业自身的执行特点①,导致无法对Reduce任务进行很好的预先安排.因此,如何设计一个合理的调度算法是难点之二.(3)良好的超时处理策略:由于异常情况(网络阻塞、节点宕机等)在大规模集群中是无法避免的.因此即便采用优秀的调度算法,也无法完全避免作业超时.此时,系统必须合理的放弃个别作业以保证其他作业不会受到影响.因此,如何设计一个良好的超时处理策略是难点之三.为有效解决MapReduce集群中的最大收益问题,本文设计了作业收益的评价标准,并以最大化收益为目标设计了相关的算法.具体地,本文的贡献点总结如下:(1)本文首次提出了在MapReduce环境下的最大收益问题,给出了收益的评价标准.(2)提出了一种基于序列的任务调度策略(简称SEQ策略),并证明了SEQ策略在处理具有完成时限约束的作业时具有明显的优势.(3)基于SEQ策略,本文提出了以最大化收益为目的的AMB算法.对于静态的申请作业集合,AMB算法可以快速地选择可接收的作业集合,并给出合理的调度方案,保证接收的作业按时完成;当有新作业提交时(即针对动态的作业集合),AMB算法采用增量的方法进行快速地接收判定,并及时地更新调度方案.(4)在实际生产中,异常情况(如节点宕机等)无法完全避免,某些被接收的作业可能无法按时完成.针对此种情况,本文设计一种超时处理策略,可以有效地提高算法的实用性.①对于任意一个MapReduce作业,系统都会将其切分成多个Page3(5)最后,本文通过大量实验验证了所提出算法的有效性.本文第2节概述MapReduce的背景知识和相关工作;第3节陈述MapReduce中的最大收益问题;第4节详细描述本文提出的相关算法;第5节给出实验结果与分析;第6节对全文进行总结.2背景知识本小节首先对MapReduce框架进行了概述,然后总结了MapReduce环境中的相关工作.2.1MapReduce概述MapReduce是一款由Google公司提出的并行计算框架,主要适用于大规模数据的分析与处理.该框架依托于一个底层的分布式文件系统[5](DFS)存储输入输出文件.典型地,数据文件会被切分成多个等大的分片,分布式地存储在DFS当中.该框架采用主从(master-slave)架构,主节点主要负责集群管理和任务调度,对于任何一个MapReduce作业,主节点都会将其分割成多个Map和Reduce任务,并将它们分给空闲的从节点进行处理.每个从节点上都具有一定数目的Map(Reduce)任务槽,用于处理主节点所指派的Map(Reduce)任务.图1描述了一个MapReduce作业执行的大体流程.当一个作业j被提交时,系统的主节点会将其切分成m个Map任务和r个Reduce任务.通常m是j的输入文件所包含的分片数目,而r由用户指定或为默认值.在Map阶段,首先,一个分片中的数据会被分配给一个特定的Map任务槽(如M1),并被解析成一系列(k1,v1)格式的键-值对(key-valuepair).然后,每个Map任务槽调用用户提交的Map函数,输入一系列(k2,v2)格式的键-值对作为中间结果.中间结果会被划分成r个块,并被发送给相应的Reduce任务槽.划分函数保证具有相同键(key)的键-值对被划分到同一个块中.在Reduce阶段,首先,每个Reduce任务槽(如R1)将收到的块合并到一起,形成一系列(k2,list(v2))格式的键-值对.接下来调用用户提交的Reduce函数,输出最终结果.最终结果将被写回到DFS当中.2.2相关工作目前已经出现许多适用于MapReduce的任务调度算法[6-9],如FIFO调度器①、Capacity调度器②、Fair调度器③等等.也出现许多针对特定应用场景的调度算法:Sandholm和Lai等人[10]提出的一种调度算法,允许用户根据作业的重要程度,动态调整所申请的计算资源量.Zaharia等人[11]提出了LATE调度算法,主要适用于异构的集群环境.Kwon等人[12]针对MapReduce处理过程中出现的数据倾斜问题,提出了Skewtune算法.此外,还出现了一些针对具有完成时限要求作业的调度算法.Polo等人[13]提出了PD调度算法,该算法可以估计作业的完成时间,如果一个作业无法按时完成,则将计算资源优先地分配给这个作业.但该算法并没有设计接收判定模块,会接收用户提交的所有作业,明显无法应用于本文提出的应用场景.DC调度算法[14]和MinEDF-WC算法[15-16]则设计了接收判定模块,若算法认为提交的作业无法按时完成,则会驳回该作业.具体地,DC调度算法根据作业的大小,尝试分配固定个数Map任务槽给该作业,并假设每个作业在Reduce阶段都可以使用全部的Reduce任务槽.而MinEDF-WC算法则根据作业的大小,尝试分配固定数目的Map和Reduce任务槽给该作业,并使每个作业所获得的任务槽总数最小.可见,DC和MinEDF-WC算法所采用的估计模型都是静态的.但在MapReduce集群中,为达到高度的可用性,普遍采用动态的任务分配方式.因此这种静态估计模型会导致系统可用性大大降低,同时也无法充分利用系统的计算资源.另外,这些算法只考虑到了作业的完成时限要求,但并未进一步考虑收益问题,因此与本文的设计目标也不相同.MapReduce下的最大收益问题是本文首次提出的,与现有研究存在很大不同.已有算法不能很好地解决最大收益问题,因此设计一种可以有效解决①②③Page4该问题的算法是十分有意义的.3问题描述本文主要针对MapReduce环境下的最大收益问题,其他的性能指标,如吞吐量等,并不是本文的重点讨论问题.另外,本文提出的AMB算法的具体任务分配方法遵循了MapReduce的动态分配原则,因此并不会影响MapReduce的其他特性,如容错处理、负载均衡等.本文主要考虑常见的同构MapReduce集群,即认为每个从节点的处理能力大致相同.在一个具有M个Map任务槽和R个Reduce任务槽的MapReduce集群中,对于任意一个用户提交的作业j,如下参数为已知:(1)j具有的Map任务个数:j.Nm;(2)j具有的Reduce任务个数:j.Nr(为达到较高处理效率,j.Nm(j.Nr)常为M(R)的整数倍);(3)j的完成时限要求:j.deadline;(4)当作业j被接收并在j.deadline之前完成时,企业可以获得的收益:j.benefit.此外,企业可为所有作业设定统一的赔付比α,如果j被接收但未能按时完成,则需要赔付给用户的费用为j.benefit·α.不失一般性地,若企业不提供赔付服务,则可将赔付比α设为0.设计目标:在一段时间内有大量用户向服务提供商(即集群的拥有者)提出作业申请,这些作业形成了申请候选集J={j1,j2,…,j|J|}.首先,服务提供商需要从J中选择可接收作业集A={j1,j2,…,j|A|},并根据合适的调度算法尝试去完成A中的所有作业.最终,对于A中的任意作业ji,若ji在ji.deadline之前完成,那么称ji是有效的,提供商可以获得收益ji.benefit,否则,称ji是无效的,提供商需要赔付ji.benefit·α.那么,可获得的总收益可以表示为P=∑j∈A,j是有效的j.benefit-∑j∈A,j是无效的j.benefit·αMapReduce下的最大收益问题,即设计有效的算法以最大化总收益P.4算法描述本小节首先提出了一种基于序列的任务调度策略,接下来根据这种策略提出了AMB算法,最后给出了超时处理的方法.4.1基于序列的任务调度策略对于任意作业j,首先需要估计如下2个基本参数:(1)j的平均每个Map任务的处理时间:j.Tm;(2)j的平均每个Reduce任务的处理时间:j.Tr(这些参数可以通过简单的抽样得出,文献[11,13]中均采用了类似的方法,具体细节详见本文附录A).若集群中的全部任务槽都用于处理该作业,那么可以估计j的Map阶段的耗时为TCm(j)=j.Nm/M×j.Tm,Reduce阶段的耗时为TCr(j)=j.Nr/R×j.Tr.TCm(j)和TCr(j)是本文调度策略中主要使用的参数.定义1.序列.对于一个作业集合JS(所包含的作业个数记作|JS|),序列S是JS中所有作业的一种排列,它规定了JS中的所有作业的Map阶段的完成顺序.具体地,若记j的Map阶段的完成时间为COTm(j),对于给定的序列S={j1,j2,…,j|JS|},那么ji∈S(0<i<|JS|),S规定COTm(ji)<COTm(ji+1).基于一个给定的序列S,本文提出了一种全新的任务调度策略(SEQ策略),具体过程如下.(1)Map部分,当一个空闲的Map任务槽请求任务时,主节点选择一个属于序列S中首作业的Map任务分配给该任务槽.当首作业的Map任务全部分配完毕之后,将该作业从序列首部移除.例如在图2中,给定序列S={j1,j2,j4,j3},当Map任务槽请求任务时,SEQ策略选择首作业的Map任务分配给该槽.(2)Reduce部分,将集合JS中的作业按照完成时限由小到大的顺序进行排列,得到一个有序队列Ld={j1,j2,…,j|JS|}.当一个空闲的Reduce任务槽请求任务时,主节点顺序查找Ld中的作业,找到第一个已经完成了Map阶段的作业,并选择一个属于该作业的Reduce任务分配给空闲的任务槽.例如在图2中,Ld={j1,j2,j3,j4},若在时间点330时有Reduce任务槽请求任务,此时作业j1,j2完成了Map阶段,j1的完成时限较小,所以选择一个属于j1的Reduce任务分配给该槽.根据上述的作业执行策略,对于一个给定的序列Page5S,可以计算出任意作业j的Map阶段的完成时间:COTm(j)以及Reduce阶段的完成时间:COTr(j).具体方法如下.(1)给定序列S={j1,j2,…,j|JS|},ji∈S,其Map阶段的完成时间为COTm(ji)=COTm(ji-1)+TCm(j)=∑k∈[1,i]TCm(jk).例如在图2中,给定序列S={j1,j2,j4,j3},作业j2的Map阶段完成时间为COTm(j2)=COTm(j1)+TCm(j2)=140+190=330.(2)对于作业集合JS,按照作业完成时限由小到大排序,可以容易地得到队列Ld={j1,j2,…,j|JS|}.那么对于Ld中的第一个作业j1,根据给定的序列S,可以计算得出其Map阶段的完成时间COTm(j1),那么其Reduce阶段的完成时间:COTr(j1)=COTm(j1)+TCr(j1).我们将时间段[COTm(j1),COTr(j1)]标记为“占用”.那么对于Ld中的第i个作业ji,我们首先计算得出COTm(ji),接下来从时间点COTm(ji)开始,找到一系列未被“占用”的时间段,使其总长度为TCr(ji),标记这些时间段为“占用”,最后一个时间段的结束时间即作业ji的Reduce阶段完成时间COTr(ji).例如在图2中,给定S={j1,j2,j4,j3},Ld={j1,j2,j3,j4},作业j1的Map阶段完成时间COTm(j1)=140,Reduce完成时间COTr(j1)=140+220=360,时间段[140,360]被j1占用.j2的Map完成时间COTm(j2)=330,但时间段[330,360]被j1占用,因此j2占用的时间段为[360,480].j2的Reduce阶段完成时间COTr(j2)=480.基于上述的作业执行策略以及完成时间计算方法,下面给出有效序列的定义.定义2.有效序列.给定作业集合JS,对于一个序列S,若使用SEQ策略可以使得j∈JS,COTr(j)j.deadline,那么称S为一个有效序列.下面,我们说明本文提出的SEQ策略在处理具有完成时间约束作业时的优势.定理1.Map最优性.对于作业集合JS,给定序列S(即给定了作业Map阶段的完成顺序),那么SEQ策略可以保证ji∈JS,ji在满足S约束的前提下,可以在最短时间内完成它的Map阶段.证明.给定序列S={j1,j2,…,j|JS|}和S中的第i个作业ji,S规定ji的Map阶段必须在所有jk(1k<i)的Map阶段结束之后才能完成,即ji的Map阶段的最早完成时间为∑k∈[1,i]TCm(jk).同时,若采用SEQ策略进行任务分配,ji的Map阶段完成时间COTm(ji)亦为该值.对于任意ji(i∈[1,|JS|]),上述结论均成立,定理得证.证毕.定理2.Reduce最优性.对于作业集合JS,给定序列S,如果使用SEQ策略进行任务分配会出现作业超时,那么无论何种调度策略都无法保证JS中所有作业都按时完成,S一定不是有效序列.证明.定理1已经证明了SEQ策略在Map阶段的最优性,因此这里只需要考虑Reduce阶段.假设当使用SEQ策略时,作业j是超时作业,此时有2种情况:(1)若COTm(j)+TCr(j)>j.deadline,即作业j在Map阶段完成之后就马上运行他的Reduce任务,也无法按时完成.那么显然无论使用何种调度策略,都无法使j按时完成.(2)若COTm(j)+TCr(j)j.deadline,而j的Reduce完成时间COTr(j)>j.deadline.那么根据SEQ策略,在时间段[COTm(j),COTr(j)]内,必有部分时间被一些完成时间时限小于j.deadline的作业的Reduce任务占用.我们从这些作业当中,选择Map阶段完成时间最小的作业,记为j.在时间段[COTm(j),COTr(j)]内运行Reduce任务的所有作业中,判断是否仍然存在完成时间时限小于j.deadline的作业,若存在,则重复上述过程,直到我们找到最终作业jf,使得在时间段[COTm(jf),COTr(j)]内运行Reduce任务的所有作业的完成时限都不小于jf.deadline.显然地,在时间段[COTm(jf),COTr(j)]内,不存在空闲的时间段.那么如果使用其他调度策略,可以使j按时完成,则一定会有其他作业变得超时.根据上述2个定理,在给定序列S时,本文提出的SEQ策略是最优的,也就是说如果使用SEQ策略会出现作业超时,那么任何策略都无法保证所有作业都按时完成.4.2AMB算法具体地,AMB算法由2个部分构成:首先,针对一般情况,即申请候选集为静态时,算法利用一种新型的评分策略确定接收优先级,并采用了有效的剪枝策略以快速地确定可以接收的作业集合,并找到相应的有效序列;此外,在实际应用中,作业集合往往是动态更新的,即允许在运行过程中有新的作业提交.针对这种情况,AMB算法采用一种增量的方法实现快速地接收判定,并在必要时更新有效序列.下面就这2部分进行详细的阐述.Page64.2.1静态部分对于具有大量作业的申请集合J={j1,j2,…,j|J|},我们需要根据SEQ策略快速地确定可接收作业集合A={j1,j2,…,j|A|},并确定适合集合A的有效序列,以达到最大收益的目的.但是,对于申请集合J,就存在2|J|种不同的接收作业集合.对于任何一种接收集合A={j1,j2,…,j|A|},仍然存在|A|!种不同的序列.为快速找到可接收集合和对应的有效序列,本文提出了AMB算法,具体步骤如下.为提高接收判定的效率,本文首先对申请集合J中的作业进行合理排序,以确定接收的优先次序.通过分析MapReduce作业的特点,排序主要考虑如下2个方面:(1)直观地,由于集群的总计算能力有限,为实现收益最大,应考虑优先接收“收益比”大的作业.其中j∈J,j的系统耗时可以量化为STC(j)=TCm(j)·M/(M+R)+TCr(j)·R/(M+R),则j的收益比:Br(j)=j.benefit/STC(j),即运行j时每秒可以获得的收益.例如在表1中,作业j1的收益比:Br(j1)=300/(150·30/50+170·20/50)≈1.90.(2)另外,考虑到MapReduce集群的特点,如果某个作业j过长,那么当运行j的Map(Reduce)任务时,大部分Reduce(Map)任务槽可能由于得不到任务而被闲置,导致系统资源的浪费,进而影响其他作业的正常接收.因此,应考虑对过长作业引入收益惩罚机制.例如在表1中,作业j5的收益比很高,但相比于其他作业,它的TCm(j5)和TCr(j5)过长,若接收j5,会影响其他作业的接收,使总体收益变低,因此需要对j5加入收益惩罚.表1排序得分举例(Map槽数犕=30,Reduce槽数犚=20)作业TCm(j)/sTCr(j)/s完成时间/s收益收益比排序得分j11501705003001.901.90j21601406503402.242.24j31901809804002.152.15j41402004003802.322.32j5400500100013603.091.91j61901206003502.162.16综合考虑上述2方面因素,本文提出了一种以最大化收益为目标的排序得分函数,得分较高的作业将被优先接收.其中Ad(j)为j的调整系数,STC(j)·Ad(j)为j的调整时间.具体地,记集合J中所有作业Map阶段耗时之和Total_TCm=∑j∈JTCm(j).对于作业j,记录J中除j以外其他作业的Map阶段平均耗时TCm(j)=(Total_TCm-TCm(j))/(|J|-1).给定一个惩罚阈值β(β>1),若TCm(j)>TCm(j)·β,那么认为j的Map阶段过长;同理,若TCr(j)>TCr(j)·β,那么认为j的Reduce阶段过长,则调整系数Ad(j)为Ad(j)=下面,我们通过一个例子来具体说明文中排序得分和调整系数的含义.例1.如图3中所示,j5是表1中的作业.j5的系统耗时为STC(j5)=400×3/5+500×2/5=440,则j5的收益比为Br(j5)=1360/440≈3.09.假设在理想情况下,j5可以与其他作业共享系统资源,系统资源可以充分利用,此时j5的排序得分等于收益比.但在实际情况下,根据表1中的其他作业的运行时长可以看出,j5的Map和Reduce阶段的耗时都远超过其他作业.在j5的Map任务运行期间,其他作业的Reduce任务很快地执行完毕,在剩余的时间里,许多Reduce任务槽由于无法获得任务而长期处于空闲状态,导致了计算资源的浪费,而实际上这种资源浪费是由j5引起的.同理,当j5的Reduce任务运行期间,也会有大量闲置的Map任务槽.具体地,j5的Map和Reduce阶段与同其他作业共享的时间长度的期望值分别是TCm(j5)=166和TCr(j5)=162,因此我们可以将j5占用的系统时间调整为STC(j)·Ad(j)=440×[(400-166)/400×3/5+(500-162)/500×2/5+1]≈713,即j5的调整时间为713,则排序得分为Score(j5)=1360/Page7713≈1.91.为方便描述,假设申请集合J={j1,j2,…,j|J|}中的作业已经按照式(2)的得分降序排列完毕,ji∈J,Score(ji)Score(ji+1).接下来,一种基本的接收判定方法是,首先初始化接收集合A为空;然后,逐个审查J中的作业,对于ji∈J,依据SEQ策略,判定是否存在对于A∪{ji}的有效序列.若存在,将ji加入到A中,否则,放弃作业ji.但实际上,对于任意A∪{ji},都存在(|A|+1)!种序列.下面,我们就介绍2种剪枝策略以快速地找到有效序列.定理3.给定作业集合A的一个有效序列S={j1,j2,…,jn},对于一个新作业jnew,有n+1个位置可供jnew插入(第i个位置介于ji-1与ji之间).如果TCm(jnew)+COTm(ji)+TCr(ji)>ji.deadline,那么jnew无法插入到位置[1,i]中.证明.明显地,jnew插入到[1,i]中的任何位置,ji都将超时.定理4.给定作业集合A的一个有效序列S={j1,j2,…,jn},对于一个新作业jnew,若COTm(ji)+TCm(jnew)+TCr(jnew)>jnew.deadline,那么jnew无法插入到位置[i+1,n+1]中.证明.假设jnew可以插入到[i+1,n+1]中的某个位置,根据SEQ策略,jnew的最早完成时间COTm(ji)+TCm(jnew)+TCr(jnew)>jnew.deadline.因此,jnew必然超时.利用上述定理,本文提出的AMB算法(静态部分)可以快速地得到可接收的作业集合以及相应的有效序列,以达到最大收益.算法1给出了算法的具体过程.算法1.AMB算法(静态部分).输入:用户提交的作业申请集合J={j1,j2,…,j|J|}输出:接收作业集合A以及相应的有效序列图4AMB算法-静态部分1.根据式(2)计算J中各作业的排序得分;2.将J中作业按照得分降序排序;3.J中首作业j1加入A,{j1}加入有效序列集合φ1;4.FOREACHji∈J(i>1)DO初始化有效序列集合φi为空;5.FOREACHS∈φi-1DO6.根据定理3判断ji可插入的最小位置a;7.根据定理4判断ji可插入的最大位置b;8.IFabTHEN9.FOREACHp∈[a,b]DO10.将ji插入S的p位置,得到新序列S;11.根据SEQ策略计算S中各作业完成时间;12.IFS是有效序列THEN13.将S插入有效序列集合φi中;14.ENDIF15.ENDFOR16.ENDIF17.ENDFOR18.IFφi不为空THEN19.将ji加入A中;20.ELSE21.放弃接收ji,φi=φi-1;22.ENDIF23.ENDFOR24.返回集合A和φ|J|中的任一有效序列;例2(AMB算法-静态部分).继续表1中给出了的例子,根据得分排序得到的有序作业集合J={j4,j2,j6,j3,j5,j1}.接下来如图4所示,在AMB算法中,首先将j4加入到接收集合A中.下面考虑j2,由于TCm(j2)+COTm(j4)+TCr(j4)=160+140+200=500>j4.deadline,根据定理3,j2无法插入到j4之前.因此,只需要判断{j4,j2}是否为有效序列.根据SEQ策略中作业完成时间的计算方法,得知{j4,j2}为有效序列.接下来考虑j6,此时对于A的有效序列{j4,j2},COTm(j2)+TCm(j6)+TCr(j6)=300+190+120=610>j6.deadline,根据定理4,j6无法插入到j2之后.同时,根据定理3,j6无法插入到j4之前.因此,只需要判断{j4,j6,j2}是否为有效序列.经进一步计算,得知{j4,j6,j2}确实为有效序列.重复上述过程直至判断完毕J中的所有作业.最终,通过AMB算法,我们得到了接收作业集合A以Page8及A的有效序列{j4,j2,j6,j3}.其总收益为1470.4.2.2动态部分在实际应用中,申请作业集合往往是动态更新的,即允许在运行过程中提交新的作业申请.在这种动态的情况下,对于每个新提交的作业,系统首先需要根据目前的剩余计算资源,判断该作业是否可以被接收;此外,若成功接收新的作业,那么还需要及时地生成新的有效序列.在本文的AMB算法中,主要采用了一种简单的增量方法来有效地解决上述问题.具体处理过程描述如下.设在运行过程中的某一时间点t,系统检测到若干个新的作业申请,记作集合J.首先,对J中的作业按照排序得分(见式(2))进行降序排序.明显地,得分较高的作业具有较高的接收优先级(具体原图5AMB算法-动态部分4.3超时处理本文的AMB算法主要针对同构集群设计,绝大部分情况下可以保证估计值j.Tm、j.Tr贴近真实值.但在实际应用中,某些异常情况(如网络阻塞、节点宕机等)是无法完全避免的,会导致某些被接收的作业无法按时完成.在这种情况下,必须对运行中的作业进行合理的调整,才能够保证总体收益最大化.下面,我们给出一个作业超时的具体实例.例4.继续表1中所示的例子,经过AMB算法计算,我们已经得到了接收作业集合以及相应的有效序列{j4,j2,j6,j3}(具体细节如图4所示).但在系统执行j4的Map任务时,出现部分节点宕机.在重启宕机节点之后,重新估计j4的完成时间,发现j4的Map阶段在时间点170才能完成.按照原有效序列计算各作业的完成时间,结果如图6所示.此时,作业j2无法按时完成.当预计某些已被接收的作业无法按时完成时,就需要及时地放弃某些作业,以保证整体收益.一种最为基本的策略就是放弃正在运行的作业.因为按因已在静态部分阐述).接下来,依次遍历J中的作业,对于任意作业j,j∈J,可以根据定理3、4计算出j可插入原有效序列S中的位置.若存在有效位置,则接收j并生成新的有效序列.否则,放弃j.例3(AMB算法-动态部分).继续表1中给出的例子,原有效序列已计算完毕,S={j4,j2,j6,j3},图5(b)为原有效序列.接下来,假设在时间点t=300s时,系统接收到2个新的作业请求j7、j8,具体参数详见图5(a).那么,首先计算j7、j8的排序得分,Score(j7)=2.13,Score(j8)=1.92,则优先考虑j7.接下来,根据定理3、4,发现j7可以插入到j6、j3之间,因此接收j7,并将有效序列更新为S={j4,j2,j6,j7,j3}.类似地,判断j8,发现j8无法插入到S当中,因此拒绝j8.图5(c)描述了更新后的最终结果.照原有效序列,所有未执行作业的参数均未发生变化,而某个作业无法按时完成的根源只是因为当前运行的作业无法按照原计划完成.例如在图6中,j2无法按时完成只是因为j4的Map阶段完成时间变长.而放弃j4就可以确保其他作业都按时完成.算法2.超时处理算法.输入:接收作业集合A,原有效序列S,正在运行的作输出:需要放弃的作业集合C1.将A中的作业按照收益由小到大排序;2.IFjrunning是收益最小的作业THEN3.C={jrunning};4.ELSE5.FOREACHji∈A且ji.benefit<jrunning.benefitDO6.IF在S中移除ji,S变为有效序列THENPage97.C={ji},BREAK;8.ELSEIFji.benefit+∑j∈CTHEN9.将ji加入C中;10.IF在S中移除C中的所有作业,S变为有效11.BREAK;12.ENDIF13.ELSE14.C={jrunning};15.ENDIF16.ENDFOR17.ENDIF但根据式(1),为保证总收益P最大,应在保证剩余作业都能够按时完成的前提下,放弃收益最低的作业.基于这种思想,本文提出了一种新型的超时处理算法.算法2给出了该算法的具体过程.例5.在图6所示的例子中,按照作业收益进行排序,收益低于j4的作业有j2、j6.首先尝试j2,发现放弃j2,序列{j4,j6,j3}变为有效序列.则超时处理完成.5实验分析在本小节中,我们首先基于Hadoop系统实现了AMB算法(详见附录B),并分别使用静态作业集和动态作业集测试了算法的性能.实验中所使用的MapReduce集群包括1个主节点和40个子节点.每个子节点上配置2个Map任务槽和2个Reduce任务槽,文件系统分片大小为64MB.全部41个节点的配置均为IntelCorei321003.1GHzCPU,8GB内存,500GB硬盘,操作系统为RedHatLinux6.1.5.1静态作业集的实验结果与分析在本节实验中,所使用的作业主要包括如下3种常见的MapReduce作业:词频统计、倒排索引和分布式Grep.输入的文件为维基百科提供的数据转储文件(主要内容是条目、模板、图片描述及基本的元页面等信息,链接:http://download.wikipedia.com/enwiki/).对于一个申请作业集J,我们主要考量如下3个主要参数对算法性能的影响:(1)J的规模N,即J包含的作业个数;(2)J中作业的平均大小L:我们用作业输入文件的分片数目来度量一个作业的大小,通常情况下,较大的作业需要更多的计算资源.在实验中,对于给定的L,限定j∈J,j的大小在区间[0.5L,1.5L]内;(3)J中作业的平均完成时限D:限定j∈J,j.deadline为区间[0.5D,1.5D]内的一个随机值.此外j∈J,j的收益j.benefit为[300,700]内的一个随机值,赔付比α=0.3,惩罚阈值β=2.表2给出了主要参数的默认值和变化范围.参数平均作业大小默认值150变化范围100~20020~40800~1600本文以总收益P(见式(1))为首要性能指标.此外,本文还使用接收率和完成率以更全面地衡量算法的性能,具体地:(1)接收率=接收作业集规模/申请作业集规模.(2)完成率=按时完成的作业数目/接收作业集规模.本文使用DC和MinEDF-WC作为对比算法.注意这2种算法仅针对具有完成时限约束的作业而设计,因此在确定接收作业集时,无法考虑收益.此外,在考量总收益时,我们引入了理想值的概念,即在最理想的状态下,假设系统的计算资源可以被收益比高的作业全部占用,且不必考虑赔偿时,企业可获得的最大收益.具体地,对于申请作业集合J,找到具有最大完成时限的作业j,记Max_time=j.deadline.接下来,将J中的作业按照收益比降序排序,得到有序集合J={j1,j2,…,j|J|}.确定k值,使得前k个作业的总系统耗时TCk=∑kMax_time,同时使前k+1个作业的总耗时TCk+1=∑k+1STC(ji)>Max_time,则总收益的理想值为Ideal=∑ki=1可以看出,Ideal值是总收益的上限,在绝大多数情况下是无法达到的.例如在表1中,将作业按照收益比进行排序得到有序集合J={j5,j4,j2,j6,j3,j1},根据上述公式计算,Max_time=1000,k=4,TCk=440+164+152+162=918.也就是在理想状态下,系统可以接收的完整作业为j5,j4,j2,j6,还可以接收一部分j3,那么理想值Ideal=1360+380+340+350+400·(1000-918)/186≈2606.5.1.1作业大小的影响如图7所示,本文首先测试了不同作业大小对算法性能的影响.在图7(a)中,我们测试作业大小对收益的影响,其中Ideal为式(4)所示的理想值.可以看出,DC和MinEDF-WC算法可以提供的收Page10益较低.相比之下,AMB算法可以带来非常高的收益,仅仅略低于理想值.随着作业逐渐增大,3种算法的收益都会有所降低.在图7(b)中,测试了作业大小对接收率的影响.在3种算法中,基于SEQ调度策略的AMB算法可以充分利用计算资源,提供了最高的接收率.而DC和MinEDF-WC算法使用较为简单的调度策略,无法充分发挥系统的计算能力,导致它们接收的作业数量较少.此外,由于完成时限不变,系统在固定时间段内的计算能力一定.因此,随着作业增大,3种算法接收的作业数目都有所减少.在图7(c)中,测试了作业大小对完成率的影响.容易看出,在3种算法中,完成率对作业大小的变化不敏感,并没有发生明显变化.其中,AMB算法使用SEQ策略进行任务调度,可以保证几乎全部被接收的作业都能够按时完成,超时处理算法几乎不会被调用.MinEDF-WC算法也可以保持较高的完成率,而DC算法在Reduce任务调度策略上存在图7作业大小的影响图8申请作业集规模的影响图9完成时限的影响不足,导致一些作业进入Reduce阶段后被抛弃,因此利用率最低.另外,综合考虑图7(b)和(c)的结果,我们可以发现AMB算法在接收率与完成率方面都占有绝对的优势,这也是该算法可以保持较高总收益的主要原因.5.1.2申请作业集规模的影响在图8中,我们对申请作业集规模的影响进行了测试.如图8(a)所示,对于不同的申请集规模,总收益并没有明显变化.在图8(b)中,随着申请集规模的增大,3种算法的接收率都有所下降.这主要是由于完成时限没有变化,系统在一定时间段内所能接收的作业数目也不会变化,而申请总数增加,因此接收率降低.在图8(c)中,测试了申请集规模对完成率的影响,与图7(c)类似,完成率对申请作业集规模也不敏感,并未发生明显变化.5.1.3完成时限的影响图9测试了完成时限对算法性能的影响.如图9Page11(a)所示,随着完成时限的增加,系统能够接收更多的作业,所以3种算法提供的收益都随之增加.类似地,在图9(b)中,随着完成时限的增加,3种算法的接受率也随之增加.图9(c)出现了与图7(c)和图8(c)相似的结果,本文不作赘述.5.2动态作业集的实验结果与分析为了更贴近真实应用场景,本部分采用了动态的申请作业集合.具体地,实验中共生成了60个作业申请,其中作业的平均大小(分片数目)为150,每个作业的完成时限设定为提交时间点之后的400s~600s内的随机值,收益为[300,700]内的一个随机值,其他参数设定与5.1小节相同.在实验中,平均每隔图10监听结果(动态作业集)通过上述大量实验验证,我们进一步证明了本文提出的SEQ策略和AMB算法的有效性.6总结本文首次提出了MapReduce集群中的最大收益问题,并给出了作业收益的评价标准.通过分析MapReduce作业的特点,本文提出了一种新型的任务调度策略,SEQ策略,并证明了该策略在处理具有完成时限约束的作业时有良好性质.基于SEQ策略,本文了提出以最大化收益为目标的AMB算法,该算法可以快速地确定可接收作业集合并给出有效的作业执行方案,以保证所有接收的作业都可以按时完成,可以最大化收益.此外,针对实际应用中无法避免的某些异常情况(如节点宕机等),本文设计了有效的超时处理策略.最后,通过大量实验验证了本文提出算法的有效性和实用性.
