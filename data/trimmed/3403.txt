Page1一种基于耦合度量的类间集成测试序的确定方法姜淑娟张艳梅李海洋王庆坛(中国矿业大学计算机科学与技术学院江苏徐州221116)摘要类间测试顺序的确定是类集成测试中难以解决的一个关键问题.类的测试序列不同,构造相应的测试桩需要花费的代价也会不同.每一个测试桩复杂度度量的准确性决定最终打破环路所需构造测试桩的总体复杂度.对于类间测试顺序问题,文章提出一种基于耦合度量的类间集成测试序的确定方法.采用类间耦合度量与基于图的启发式算法相结合的方法,其中,前者用于度量每一个测试桩的复杂度,后者用于在保证测试桩总体复杂度尽可能小的条件下来打破环路.首先提出一种在度量中使用的耦合权重的计算方法,对测试桩的复杂度进行新的耦合度量;然后给出一种有效打破环路的基于图的启发式算法;最后实现了类间测试序列自动生成工具———TOGOS.实验结果表明:文中的方法较现有的方法总体复杂度有明显的降低,从而节约了测试成本.关键词集成测试;测试序列;测试桩复杂度;耦合度量;启发式算法1引言面向对象程序不像面向过程程序那样有明显的层次化模块结构,对象之间的联系通过消息传递的方式,一条消息会引起连锁反应进而形成一条方法调用链,体现调用关系的静态结构是一个错综复杂的网状结构.因此,从哪里开始测试以及如何定义一个集成测试顺序是需要进一步研究的问题.面向过程的基于功能分解的集成测试方法不能满足面向对象程序的集成测试的要求,需要研究满足面向对象程序特点的集成测试方法.在面向对象软件中,类集成测试顺序问题是指为那些集成测试的类簇确定它们的测试顺序.确定类簇的测试顺序时,对于在类间关系不构成环路的情况下,可以通过逆向拓扑排序来确定它们的测试顺序;在类间关系构成环路的情况下,则必须首先打破环路才能确定它们的测试顺序.打破环路是指临时删除一条或多条关联边进而将该类簇构成的有环图变成无环图的过程.确定类集成测试顺序是在实际的测试中必须要面临的问题,例如单元测试顺序可能受制于那些与其它项目共享的可利用资源,类集成测试顺序对软件开发和单元测试顺序存在一定的影响.针对类集成测试顺序的问题,很多学者提出了不同的解决方法,总体可以归为两种:第一种是基于遗传算法的方法,即首先确定一个表示类测试顺序的种群,然后通过选择、交叉和变异对这一种群进行处理,并得到满足一定条件的测试顺序.第二种是基于图论的方法、类簇以及它们之间的关系可以抽象为类图,一个类图是一个有向图,表示为G(V,E),其中V表示类节点集合,E表示为类之间关系的边集,其中标签I、Cp、Ag、As和Us分别表示继承、组合、聚集、关联和使用关系.类集成测试顺序问题就是对图中表示类的各节点进行排序,通过分析有向图的结构来确定满足条件的测试顺序.类集成测试序列的不同,很大程度上影响着构造相应的测试桩需要花费的测试代价的大小.测试桩复杂度是用来衡量构造一个测试桩的难易程度,测试桩的总体复杂度则是用来衡量为一个测试序列总体需要构造的相应测试桩的难易程度[1].类集成测试顺序问题中,测试代价的衡量方法主要有两类,一是最小化集成测试过程当中需要建立的测试桩的数量[2-6];二是最小化测试桩的总体复杂度[1,7-8].后者的精确度更高,因为不同的测试桩各自复杂度不同.因此,测试桩的数量越少并不能表示一个测试序列需要花费的总体代价越低.总体来说,为了实现测试桩的复杂度(SCplx)(即构成环路的各边权值)的精确度量,减少测试成本,我们需要最小化桩的总体复杂度来找到一个最佳的测试顺序.因此,需要解决两个关键问题:测试桩的复杂度的计算方法以及打破环路的有效算法.针对于第一个问题,即在度量测试桩的复杂度时,给出一种新的计算方法,即在进行耦合度量时,根据类间耦合程度分别对属性耦合和方法耦合赋予权值;对于第二个问题,首先找出类图中的强联通组件(SCCs),然后采用基于图论的启发式算法打破环路,弥补目前断开继承、组合和聚集等强联系关系增加测试桩的复杂度的缺陷,使最终所构造的测试桩的总体复杂度最小.2估算测试桩复杂度的耦合度量方法通过最小化测试桩的总体复杂度来找到一个最佳的测试顺序,首先要解决的第一个问题是测试桩的复杂度的计算方法,只有在精确评价测试桩的复杂度的基础上才能准确地判断打破环路时所要删除的边集,进而找到最佳的测试顺序.Briand[8]在计算复杂度时,对于所使用的耦合度量方法中的属性耦合和方法耦合分配的是相同的权值,因此,考虑的是一种特殊的情况;而Abduraz-ik等人[1]将耦合分为9种类型,不仅对边的权重进行定量的耦合度量,同时也对节点权重进行了度量,综合考虑边和节点的权重,进一步精确度量结果,但是这样增加了算法的复杂度,提高了测试成本.因此,在度量测试桩的复杂度时,对于耦合度量方法中的属性耦合和方法耦合赋予权值,本文给出了一种新的计算方法.2.1相关概念测试桩复杂度是用来衡量构造一个测试桩的难易程度,测试桩的总体复杂度则是用来衡量为一个测试序列需要构造的总体测试桩的难易程度.在集成测试过程中,我们常常遇到这样的情况:当需要对某一个类A进行测试时,类A所依赖的另一个类B并没有经过测试.如果很难在短时间内构建类B,必定会影响到对类A的集成测试.此时我们需要模拟的对象来替代类B,我们称该模拟的对象为测试桩.下面给出具体的定义.定义1.测试桩.如果类C1的一个组件使用Page3一个或多个类C2的服务组件,称为C1依赖C2.增量集成过程中,当C1集成时,但C2尚未被集成,我们不得不模拟C2的服务组件,这个模拟组件通常被称为一个测试桩.一个测试桩并不是真正的对象,但是能够为待测对象提供感兴趣的数据或状态,这样,待测对象便能够顺利使用依赖对象,或者模拟事件.定义2.代价函数.计算强连通分量中构成环路的每条边的源类创建的测试桩复杂度的度量函数.由于测试桩模拟的是待测对象所依赖的类,需要像所用到的真实类那样为待测对象提供感兴趣的数据或状态,因此构造一个测试桩的代价是相当大的.所以应该尽量避免构造过于复杂类的测试桩.创建每个测试桩花费一定的代价,用测试桩的总体复杂度衡量创建所有的测试桩花费的总代价.特别地,当在系统中组件之间的依赖关系不产生环路时不需要创建测试桩.当创建每一个测试桩花费的代价相同,最小化测试桩的复杂度等价于最小化测试桩的数量.2.2耦合度量方法我们的目标是确定一个测试顺序,使它满足最小化测试桩的总体复杂度.通过删除满足该条件的边集来打破类图中的环路,进而通过逆向拓扑排序找到一个最佳的集成测试顺序.Briand等人[8]的耦合度量方法虽然不允许删除继承关系、组合关系和聚集关系这3类强联系关系,减少了构建测试桩的复杂度,但是他们为属性和方法分配相同的权值,这是一种特殊的情况,存在着局限性;Abdurazik等人[1]为属性和方法重新分配了权值,但是他们的度量方法中不仅考虑边的权重,而且增加了节点权重,增加了算法的复杂度,提高了测试成本,因此,为了实现测试桩的复杂度的精确度量,减少测试成本,我们提出一种新的耦合度量方法.耦合是指两个类相互依赖的一个量度,根据面向对象语言中类间的5种关系,对应5种耦合类型:继承耦合、组合耦合、聚集耦合、关联耦合、使用耦合.对于每一种耦合类型,类间耦合信息大都包含4部分[1]:(1)被访问的属性的个数;(2)被调用的不同方法的个数(包括构造函数);(3)返回类型的个数;(4)传递的参数的个数.我们依据这4个参数来衡量服务类和客户类之间的依赖关系.为简单起见,用符号“·”将耦合度量的4个参数集成到一个表达式,用它来表达两个类Ci和Ci之间的耦合度量.式(1)用于表示两个类Ci和Cj之间的耦合度量(CM).其中,Ci和Cj代表耦合的两个类,V代表类Ci直接使用的类Cj的公有变量的个数,M代表类Ci调用的类Cj中方法的个数,R代表在M中出现的不同返回类型个数,P代表在M中出现的不同参数个数.2.3估算测试桩复杂度为犆狆犾狓().我们可以将其标准化形式为式(2).对于一个复杂度犆狆犾狓(),其标准化估算方法记其中,犆狆犾狓(i,j)表示测试桩复杂度信息矩阵,其中行和列分别表示每个类以及类i对类j的依赖,犆狆犾狓min=Min{犆狆犾狓(i,j),i,j=1,2,…},犆狆犾狓max=Max{犆狆犾狓(i,j),i,j=1,2,…}.如式(1)所示,在计算测试桩的复杂度时,耦合度量方法中使用4个耦合方法V()、M()、R()和P(),其中V()代表调用的变量的个数,M()代表调用的方法的个数,R()代表返回类型的个数,P()代表传递的参数的个数,即一个测试桩的复杂度的估算方法如下[8]:SCplx(i,j)=(WV×V(i,j)2+WM×M(i,j)2+WR×R(i,j)2+WP×P(i,j)2)1/2(3)其中,WV,WM,WR和WP表示权重,并且WV+WM+WR+WP=1.V(i,j),M(i,j)分别根据式(4),(5)进行计算,R(i,j)和P(i,j)分别根据式(6)和(7)进行计算.其中式(4)~(7)的形式如下所示.其中,V(i,j)、M(i,j)、R(i,j)和P(i,j)的值通过开源工具SOOT①统计获得.Vmax、Vmin,Mmax、Mmin,Rmax、Rmin和Pmax、Pmin分别表示统计数据构成的属性耦合矩阵、方法耦合矩阵、返回值耦合矩阵、参数耦合矩阵中的最大最小值.对于式(3)中的权重WV、WM、WR和WP,我们①SOOT.AJavabytecodeoptimizationframework.http://Page4给出一种计算方法:对于给定的测试顺序o,打破d条依赖边,则该测试序的总体测试桩的复杂度的计算公式如下:3类间测试顺序的确定算法对于面向对象软件集成测试顺序问题,我们利用Tarjan等人的算法[9]识别出类图中由类以及它们之间的依赖关系形成的强连通分量,通过删除那些至少能够构成一个强连通分量的依赖边,利用基于图的启发式算法打破环路.3.1打破环路的启发式算法确定类间测试序的主要问题就是打破环路.Briand等人[8]解决打破环路问题时,采用的是遗传算法,不仅要精心设置参数,而且算法需要被执行多次,而Abdurazik等人[1]综合考虑边的权重、节点权重以及环路的个数来选择边进行删除进而打破环路,增加了算法的复杂度,提高了测试成本.因此,本文针对该问题给出了一种新的打破环图1SCC中以8为根节点的环路查找树然后对查找树进行前序遍历,进而找出所有的环路,最后得到SCC中的环路个数、各个环路的路径、SCC中各边涉及的环路个数.本文所采用的环路消除算法如算法1所示.算法1.EliminateloopsforSCCi.输入:SCCi输出:环路路径路的方法,把有向边的权重以及使用相应有向边的环路数目作为打破环路的主要依据,其中把测试桩的复杂度作为有向边的权重.针对确定使用有向边的环路数目的问题,我们提出了一种“查找树”的方法来查找SCCs中所有的环路.首先分别将SCCs中包含的每一个子强连通分量SCCi中所有边以树的形式组织在一起,规则是将由类编号从小到大表示的各个类依次作为根节点,SCCi中包含的边作为分支进行构造,每选择一个不同的根节点时构造一棵不同的查找树,构造一棵查找树时在一条路径中避免重复的节点,最后以与根节点相同的节点作为叶子节点,直到SCCi中的边不能满足树中叶子节点与根节点相同为止;然后对这些查找树进行前序遍历,去掉重复的路径,最后得到SCCi中的环路数目及所有环路及路径、SCCi中各边涉及的环路的数目.例如,以在第5节中实例分析将要使用的ATM系统为例,该实例是Abdurazik等人在文献[1]以及Briand等人在文献[8]中所使用的ATM系统.该系统包含一个强连通分量SCC{8,9,…,15},该SCC包含的所有的边如表4第2列(由于篇幅所限,在这不单独列出)所示.构造查找树时首先选择SCC{8,9,…,15}中类节点编号最小的8作为根节点进行构造,同理依次选择9,10,11,…,15分别作为根节点进行构造.以8作为根节点为例所构造的查找树如图1所示.Begin1.findallSCCsinclassgraph;2.for(eachscci(Vscci;Escci)∈SCCs)do3.searchloops(…);//找出所有的环路4.for(eachassociationoruseedgee∈Escci)do5.findthenumberofloopsthatuseedgee;Page56.viewtheSCplxasedgeweightsinSCCs;7.calculateloop-weightratio;8.endfor9.while(totalLoop!=0)do10.removetheedgewithhighestloop-weightratio;11.totalLoop=totalLoop-numberofloopsbroken;12.modifythenumberofloopsforremainingedge;//修改使用剩余的边集中的边e的环路的数目13.recalculatetheloop-weightratioforremainingedge;14.ifassociationoruseedgeewiththesameloop-15.thenremovetheewithmoreloops;16.ifthenumberofbrokenloopssame;17.thenremoveanyedge;18.endif19.endif20.endwhile21.endforEnd我们的启发式算法的基本思想是首先生成类图中所有的SCCs(行1),然后针对每一个子SCCi,打破其中的环路(行2~20).在打破环路的过程中首先删除环路-权重比最高的关联边或使用边(行2~10)(Briand等人[8]、Kung等人[10]、Kraft等人[11]都认为给不同类型的边创建测试桩的难易程度的高低和代价Cost(C)均存在如下关系:C(关联边)=C(使用边)<C(聚集边)C(继承边).因此,称继承关系和聚集关系为强联系关系,使用关系与关联关系均为弱联系关系.为了减少测试代价,本文消除环路时避免删除强联系边),当有多条环路-权重比相同的关联边或使用边,则删除使得打破环路个数多的那条关联边或使用边(行14~15),如使得打破的环路个数相同,删除其中的任意一条边(行16~17).3.2确定类间测试顺序的算法我们的目标是确定一个测试顺序,使它满足测试桩的总体复杂度最小.在类间关系构成环路的情况下,需要根据耦合度量的测试桩复杂度,再结合环路消除算法来打破环路,进一步确定类测试顺序.而类测试顺序由类的测试依赖性决定[12].测试依赖性表示一个类依赖于其它类的程度.为了确定类测试顺序,本文从类测试依赖性入手,提出两个测试依赖性定理作为确定类测试顺序的依据.定理1.当类A是类B的一个子类,或者类A是类B的一个聚合类,或者类A是类B的一个关联类,则在集成测试时,类A依赖于类B,类A在类B之后进行测试.证明.类A继承于类B时,类A会继承类B的部分属性,从而类A依赖于类B.若类B中被类A继承的成员发生变化,或被类A继承的成员有直接或间接影响的成员发生变化时,将会影响类A的行为.当类A是类B的一个聚合类,由于聚合是整体和个体的关系,即若干个类B聚合成一个类A,则类B的改变必然会影响类A,因此类A依赖于类B.当类A是类B的一个关联类,则类A能够访问类B的数据成员,或者类A传递一个消息到类B.因此,如果类B的数据成员发生变化,或者当类B接收类A发送的消息,并且类B的成员函数发生变化,则类B对消息的响应会有变化,返回给类A的结果也会发生变化.因此,类A依赖于类B.因此,类A在类B之后进行测试.得出定理1的结论.定理2.假设3个类A、B、C,当A是B的一个子类,B是C的一个服务类,即C关联于B(或者依赖于B)或者C是B的一个聚合类,并且当C不是A的聚合类时,则在集成测试时,C依赖于B,在不考虑多态性的情况下,C在B之后测试,A,C的顺序任意,即B,C,A或者B,A,C.证明.A是B的一个子类,B是C的一个服务类,由测试依赖性定理1得出,A在B之后测试,C在B之后测试.对于A、C的测试依赖性关系有如下情况:(1)若C关联于B(或者依赖于B).如果C需要访问B中的某个数据成员,而A继承B的该数据成员.由于我们没有考虑多态性,C不会访问A中的数据成员,则C不依赖于A.如果C需要访问B中的某个数据成员,而A没有继承B的该数据成员.尽管A继承B,但C不会访问A中的数据成员,则C不依赖于A.但由于从A到C之间没有任何依赖关系,因此,A也不依赖于C.Page6(2)若C是B的一个聚合类,由于A是B的子类,而C是B的聚合类,当C不是A的聚合类时,C不依赖于A,A也不依赖于C.由上述分析得出,则在集成测试时,C依赖于B,在不考虑多态性的情况下,C在B之后测试,由于从A到C之间没有任何依赖关系,则A,C的顺序任意,即B,C,A或者B,A,C.得出定理2的结论.确定类测试顺序的算法如算法2所示.算法2.ClassIntegrationTestOrder.输入:classcluster输出:classintegrationtestorderBegin1.Gen_classgraphprecedencetable();2.SearchSCCs;//找出所有的SCCs3.vieweachSCCiasonenode,maketheclassgraph4.foreachacyclicgraphdo//简化后的无环图5.FindReverse();//找到它的逆向拓扑排序6.foreachSCCi∈SCCsdo7.EliminateloopsforSCCi;8.GetAllNodeReverse(SCCi);9.endfor10.endfor11.outputclassintegrationtestorder;End在该算法中,首先产生类图的优先级表(行1),并找出所有的SCCs(行2),然后把每一个子SCCi看成一个节点,使得整个类图成为无环图(行3),对于简化后的无环图,找到它的逆向拓扑排序(行4~5);接下来对于每一个子SCCi,根据算法1消除SCCi的环路,得到SCCi中所有节点的逆向拓扑排序(行6~8);最后,对无环图进行逆向拓扑排序进而得到所有类集成测试序列(行11).3.3类间测试顺序生成工具我们根据上述类间测试顺序确定算法设计并实现了一个工具———TOGOS(TestOrderGeneratorforObject-OrientedSystem),其系统结构如图2所示.该工具的输入信息是一个描述面向对象系统中类间关系的三元组列表,其中的三元组列表可以由面向对象系统的UML设计文档中的类图获得.1)环路生成模块.如图2中虚线框所示.按照3.1节中环路查找方法该模块可以生成所有环路.2)环路消除模块.根据输入的关系三元组描述信息所表示的类图,采用Tarjan等人[9]的算法,依次找出该类图中的SCCi,按照3.1节中的算法1,通过断开一条或多条关联边(或者使用边),将每一个子SCCi的环路断开,直到类图中所有的环路消除为止,以得到新的无环类图.3)测试顺序生成模块:按照3.2节中的算法2,对无环图进行逆向拓扑排序输出类集成测试序列.TOGOS能够自动生成一个面向对象系统中的类集成测试序列,可减少测试的工作量.4实验在这一节中,我们通过一组基准程序来进行实验,以验证本文方法的有效性.4.1实验描述和过程在实验中,我们采用了3个系统:(1)自动取款机(ATM)模拟系统;(2)ANT系统;(3)DNS系统.其中,ATM系统在许多软件测试研究中被作为一个基准程序来使用,它包含了21个类(忽略了与硬件设备相连的类),67条依赖边和大量的依赖环路,Page7其中,8个类构成一个包含30个环路的SCC[1,8].ANT系统———jakarta项目V1.4版本的一部分(http://jakarta.apache.org).实验分析其中构成大量环路的25个类,其中,这25个类之间存在83条依赖边,构成654个依赖环路[8].DNS系统(http://www.xbill.org/dnsjava/)可以提供网络域名服务,包含61个类、276条依赖边,其中,10个类构成16个环路[8].这3个系统的类图及其它详细信息可以参照Briand等人的文献[8].SOOT[9]是一个能准确分析Java字节码的开源工具,可以提供基本的程序分析功能,例如,类间调用分析.为了统计公式(1)中4个参数的值,我们首先通过SOOT得到类间调用图,再对该调用图进行遍历,分析类间的调用关系,进一步得到目标数据.4.1.1ATM系统为了说明TOGOS工具的工作原理,我们给出类编号811表2犛犆犆{8,9,10,11,12,13,14,15}各边的犆犕值890.7.1.3100.7.4.40.2.1.1110.2.1.30.1.0.00.2.1.0120.4.3.110.4.3.110.2.2.00.0.0.0130.4.3.60.4.3.140.2.2.00.0.0.0140.3.2.60.3.3.120.2.2.00.0.0.0150.2.1.60.3.3.100.2.2.00.0.0.0然后,TOGOS工具中环路生成模块可以自动生成SCC{8,9,10,11,12,13,14,15}中所包含的30个环路,如表3所示.表3犛犆犆{8,9,10,11,12,13,14,15}中的环路序号18→9→81610→14→11→1028→10→81710→15→11→10310→11→10188→10→11→9→8410→12→10198→10→12→9→8510→13→10208→10→13→9→8610→14→10218→10→14→9→8710→15→10228→10→15→9→888→10→9→8238→10→12→11→898→10→11→8248→10→13→11→8108→10→12→8258→10→14→11→8118→10→13→8268→10→15→11→8128→10→14→8278→10→12→11→9→8138→10→15→8288→10→13→11→9→81410→12→11→10298→10→14→11→9→81510→13→11→10308→10→15→11→9→8表4给出的是分别采用Briand等人[8]、Abdurazik等人[1]以及本文方法对SCC{8,9,10,11,12,13,14,15}中各边的源类创建的测试桩复杂实验的具体过程.首先以ATM系统为例进行分析,表1是ATM系统中包含的所有类.类编号1ReceiptPrinter12WithdrawalTransaction2Display3Keyboard4CardReader5OperatorPanel16GUILayout6EnvelopeAcceptor17QuestionDialog7CashDispenser18ATMMain8ATM9Bank10Session11Transaction首先,以式(1)的形式所表示的ATM系统中强连通分量SCC{8,9,10,11,12,13,14,15}的各条边所对应的CM值如表2所示.每个CM中的4个耦合度量参数值是利用SOOT统计获得的.度的度量结果,即采用耦合度量的方法得到的测试桩复杂度.其中,第1列为构成SCC的各个类的编号;第2列为通过TOGOS工具统计的SCC中各边;第3列为统计的SCC中各边涉及的环路个数;第4、5两列分别为采用Briand等人[8]、Abdurazik等人[1]构造的测试桩复杂度;最后一列是采用本文方法,使用表2中的值,通过式(3)~(7)计算的删除SCC各边时为各边的源类构造的测试桩复杂度.其中,式(3)的WV、WM、WR和WP的值由式(8)~(11)进行计算.接下来是环路消除模块所完成的工作:把测试桩的复杂度作为边的权值,根据算法2对表4中各边进行环路-权重比的简单计算,边8→10的环路-权重比最高,首先删除该边,可以打破20个环路,剩余10个环路.然后,再重新计算表4中剩余各边的环路-权重比,经过计算,11→10环路-权重比最高,删除,可以打破5个环路,剩余5个环路.同理,以下依次打破的边为8→9,10→12,10→13,10→14和10→15,至此,所有的环路都被打破,类图成为无环图.Page8表4犛犆犆{8,9,10,11,12,13,14,15}中各边的权值序号边涉及的18→910.711.000.1428→10200.531.220.3239→8111.001.170.89410→811.001.660.81510→910.741.130.23610→1135.000.72710→1260.231.130.23810→1360.231.130.23910→1460.261.130.231010→1560.211.130.231111→850.741.170.291211→950.711.000.141311→1050.531.130.231412→810.811.600.961512→910.812.590.961612→1010.532.010.281712→1135.001813→810.811.500.591913→910.812.621.282013→1010.532.010.282113→1135.002214→810.771.390.532314→910.772.581.082414→1010.532.010.282514→1135.002615→810.741.290.572715→910.772.580.862815→1010.532.010.282915→1135.00最后将本文方法与文献[1,8]中已有的两种方法进行了比较.ATM系统度量结果的比较如表5所示.其中,第1列为3种不同的方法;第2列为分别采用这3种不同的方法删除的边的个数;第3列为被删除的各条边;第4列为被删除的各条边的复杂度;第5列为打破环路需要构造的测试桩的总体复杂度OCplx;第6列为3种不同的算法需要执行的次数.其中,采用Briand遗传算法中删除边所在的列为趋于稳定状态时所删除的7条边.类编号2410161718192021222324表7犛犆犆{2,4,10,16,17,18,19,20,21,22,23,24}中各边的犆犕值240.3.0.610160.5.0.60.7.0.717181920212223240.3.0.10方法删除边Briand等人的方法[8]7Abdurazik等人的方法[1]7本文方法74.1.2ANT系统对于ANT系统,我们采用同样的方法进行实验.该系统的类图可以参见文献[8],其中所包含的类如表6所示.首先,以式(1)的形式所表示的ANT系统中强连通分量SCC{2,4,10,16,17,18,19,20,21,22,23,24}的各条边所对应的CM值如表7所示.类编号1AntClassLoader2BuildEvent3BuildException4BuildListener5BuildLogger6DefaultLogger7DemuxOutputStream20Target8DirectoryScanner21Task9FileScanner10IntrospectionHelper23TaskContainer11Launcher12Location13Main0.4.0.30.5.3.00.6.0.00.1.1.00.1.0.00.2.0.00.2.0.10.0.2.00.3.2.2Page9表8给出的是采用本文方法对SCC{8,9,10,11,12,13,14,15}中各边的源类创建的测试桩复杂表8犛犆犆{2,4,10,16,17,18,19,20,21,22,23,24}中各边的权值序号边V&M&R&P12345678910使用TOGOS工具打破环路的过程如表9所示.其中,第1列和第2列分别表示被处理的SCCi的序号以及SCCi本身;第3列为SCCi中包含的环路的个数;第4列为处理SCCi时所删除的边.最21222324252627282930后,由于Abdurazik[1]没有对ANT进行分析,这里仅对采用本文方法与文献[8]中的方法的度量结果进行了比较.ANT系统度量结果的比较如表10所示.表9打破环路的过程表10ANT系统的度量结果被删除的边17→16,21→16,21→19,21→20,20→16,20→18,20→19,20→24,4→2,16→2,16→22,19→1819→18,20→18,20→24,19→16,17→16,21→16,20→16,2→16,21→20,16→22序号12345678910Briand等人的方法被删除的边的个数方法[8]本文方法4.1.3DNS系统对于DNS系统,所采用的方法与前两个实例的方法相同,这里我们不对过程进行重复描述.并且对采用本文方法与文献[8]中的方法的度量结果进行了比较.如表11所示.边的个数被删除的边总体复杂度方法被删除的Briand方法[8]621→8,21→11,32→48,等人的方法633→52,21→11,33→38,本文4.2实验结果和分析由表5可以发现,本文方法与采用Briand等度的耦合度量结果,即各边权重.18→2419→1619→1820→1620→1820→1920→2421→1621→1921→20人[8]的遗传算法和Abdurazik等人[1]的基于图的算法产生不同的结果:他们的方法中删除了7条边[1,8],总体测试桩复杂度为2.70,而本文同样也删除了7条边,但总体测试桩复杂度为1.61,那么构造的总体测试桩的复杂度降低了(2.70-1.61)/2.70=40.4%.最后,通过TOGOS工具自动生成ATM系统的类测试顺序,如表12所示.其中,第1列为主测试顺序号,第2列为被测试的类,第3列为被测类所依赖的类,即在被测类之前进行测试的类.对于主测试顺序号相同的类,它们之间没有依赖关系,其测试顺序可以是任意的.因此,表12中的测试顺序并不是唯一的测试顺序.Page10主测试顺序号被测类16,16,20,212348598,1,16,20,2,3,4,17,5,6,7,2167108,1,16,20,2,3,4,17,5,6,7,9,21,118Abdurazik等人在文献[1]中仅对ATM系统进行了分析,而对于ANT系统未作任何分析.因此,对于ANT系统,本文方法仅与Briand等人[8]的主测试顺序号被测类19,10,13,15,17,27,表13DNS系统类测试顺序234567遗传算法进行比较.同理,由表10可以发现,本文方法与Briand等人[8]的遗传算法产生不同的结果:他们的方法中删除了12条边[8],总体测试桩复杂度为3.59,而本文删除了10条边,总体测试桩复杂度为3.28,那么构造的总体测试桩的复杂度降低了(3.59-3.28)/3.59=8.6%.通过TOGOS工具自动生成ANT系统的类测试顺序:(9,12,15,17),3,(8,19),21,23,20,2,4,(5,16),(1,6,7,10,22,25),(11,14,24),18,13.即共13个主测试序.其中,括号中的类表示它们的主测试顺序号相同.对于DNS系统,由表11可以发现,本文方法与Briand等人[8]的遗传算法产生不同的结果:他们的方法中删除了6条边,总体测试桩复杂度为1.47,而本文也删除了6条边,但总体测试桩复杂度为1.36,那么构造的总体测试桩的复杂度降低了(1.47-1.36)/1.47=7.5%.TOGOS工具自动生成DNS系统的类测试顺序如表13所示.被测类所依赖的类21,5,28,49,46,478,21,5,28,49,10,36,44,468,21,5,28,49,17,32,10,36,44,468,21,5,28,49,17,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,13,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,31,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,32,10,36,44,468,21,5,28,49,25,32,10,36,44,468,21,5,28,49,25,32,10,36,44,4610,21,5,28,49,25,8,32,36,44,468,21,5,28,49,25,32,10,36,44,468,21,5,28,49,25,32,10,36,44,4613,21,5,28,49,25,8,32,10,36,44,468,21,5,28,49,31,32,10,36,44,46,588,21,5,28,49,46,56,32,10,36,448,21,5,28,49,46,56,32,10,36,44Page11主测试顺序号被测类89101112接下来需要对生成的类测试顺序的有效性进行验证.本文以ATM系统为例,其测试序的正确性验证如下.证明.根据测试依赖性定理1可知,类6,16,20,21不依赖于任何其它类,则它们最先进行测试;类11是12,13,14,15的父类,则类11先于类12,13,14,15的测试,而类12,13,14,15之间没有依赖关系,则它们的测试顺序是任意的;而类11依赖于类8,9,10,20,21,而11→10依赖在打破环路时已被删除,则8,9,20,21先于类11的测试;类8是类1~7的聚集类,则类1~7先于类8的测试;同理,类7和9是类20的聚集类,类10是类11的聚集类,类11是类20的聚集类,类18和19是类8和9的聚集类,则类20先于类7,9和11测试,类11先于类10的测试,类8和9先于类18和19的测试;其它剩余的那些弱联系关系的类测试顺序的正确性验证方法同上.本文的耦合度量方法以及启发式算法是有效的;同时,从实验结果可以看出,与采用Briand等人[8]和Abdurazik等人[1]的方法相比,求解质量有所提高.原因如下:首先,与Abdurazik等人[1]的方法相同,本文实验中计算WV、WM、WR和WP的值时,一个类Ci直接使用的类Cj的公有变量的个数均为0,体现了类的封装性.然而,计算时所使用的式(1)中的M、R、P的值则与Abdurazik等人[1]的不同,我们的方法是直接使用类Ci调用的类Cj中方法的个数,在被调方法中出现的不同返回类型个数以及在被调方法中出现的不同参数个数,因为它们可以直接反映两个相互作用的类之间的耦合度.而Abdurazik等人[1]首先在软件实现过程中将其分为9种不同的耦合类型,然后对于每一种耦合类型,定义相应的耦合度量来衡量服务类和客户类之间的依赖关系,此外,他们同时对边的权重和节点权重进行被测类所依赖的类定量的耦合度量,增加了算法的复杂度.计算式(4)中V(i,j)的值时,我们所使用的V、Vmax和Vmin的值可以在文献[8]中查找.其次,在Briand等人[8]的方法中,耦合度量方法中的属性耦合和方法耦合分配的是相同的权值,考虑的是一种特殊的情况,此外,他们忽略了返回值和传递的参数对耦合度量的影响,具有一定的局限性.我们在克服现有方法存在的问题并结合他们优势的基础上给出了本文方法.对测试桩的复杂度进行度量时,我们给出了一种新的方法,在打破环路时,弥补了断开继承、组合和聚集等强联系关系导致的测试桩复杂度提高的缺陷,采用基于图论的启发式算法,只需运行一次,便能够确定类间测试顺序,并满足花费总体测试桩复杂度最小.同时,类间测试序列自动生成工具TOGOS的开发,实现了自动化测试,减少了测试的工作量,提高了测试效率.5相关研究在面向对象程序的测试中,Kung等人[10]最早提出了解决类测试顺序问题的方法,并证明如果对象关系图中没有环,则可以通过逆向拓扑排序得到类间测试顺序.如果类图中有环,则首先识别其中的强联通分量,然后删除部分关联边使之成为无环图,这一过程意味着需要开发测试桩,而开发测试桩是一项成本很高的工作[11].减少开发测试桩成本的方法主要有两类:一类是最小化所需测试桩的数目,例如:Tai等人[5]提出的测试顺序分配策略导致构造大量多余的测试桩;LeTraon等人[6]采用了一种基于测试依赖图模型的方法进行集成测试,测试依赖图是由类和方法之间的测试依赖关系构成的,他们的策略最优化了桩的数目,但可能打破继承和聚集关系;Briand等人[2]在不打破继承、聚集等强联系关Page12系的前提下,给出基于图论的测试顺序策略,通过最小化测试桩的数目找到一个最佳测试顺序,减少了所需测试桩数目.另一类是最小化总体测试桩的复杂度,例如:Briand等人[8]和Abdurazik[1]等人以及文献[7]分别使用了不同的耦合度量方法估算测试桩的复杂度,其中,文献[7]使用的是耦合度量和随机交互算法解决类测试顺序问题,他们允许断开继承和聚集等强关联关系;Briand等人[8]的方法虽然避免断开继承和聚集等强关联关系,但是在计算测试桩的复杂度时,对于耦合度量方法中的属性耦合和方法耦合分配的是相同的权值,因此,考虑的是一种特殊的情况;而Abdurazik等人[1]首先对边的权重和节点权重进行定量的耦合度量,进一步精确了度量结果,然后采用基于图论的方法,根据边的权重、节点权重以及环路的个数这3个因素来打破环路,但是增加了算法的复杂度,提高了测试成本.因为不同的测试桩各自复杂度不同,因此,测试桩的数量越少并不能表示一个测试序列需要花费的总体代价越低.因此,我们采用的是最小化总体测试桩的复杂度的方法.总体来看,解决类集成测试顺序问题时,对于测试桩的复杂度的度量方法,现有的方法一部分是采用断开继承和聚集关系的方法所导致测试桩复杂度的增加[6-7],而另一部分由于考虑因素过多使度量方法过于繁琐[1];对于打破环路的方法,采用GA方法必须执行很多次,使过程复杂化,基于图论的方法一部分是采用断开继承和聚集关系[6-7]的方法,一部分是由于在测试桩复杂度的度量阶段的不精确性导致最终打破环路所需构造测试桩的总体复杂度的提高.因此,我们对测试桩的复杂度进行度量时,给出一种简单普遍的方法,在打破环路时,弥补了断开继承、组合和聚集等强联系关系导致的测试桩复杂度提高的缺陷,采用基于图论的启发式算法,只需运行一次,便能够确定类间测试顺序,并满足测试桩的总体复杂度最小.6结束语类间测试序的研究是类簇级测试的一个难点.本文通过实验证明,当把测试桩的复杂度作为权值,我们的耦合度量方法以及启发式算法与Briand的和Abdurazik的耦合度量方法相比,更加精确地度量测试桩复杂性,性能较优,降低了测试桩的总体复杂度,遗传算法需要多次运行,而我们的方法只需运行一次,从而降低了测试代价.在此基础上开发的TOGOS工具,能够自动生成一个面向对象系统中的类集成测试序列,提高了测试顺序生成的速度,减少了测试的工作量.可以发现,本文中我们没有考虑抽象类的特点,实际上,抽象类的特性,将会影响类间的依赖性,进而将影响类间测试顺序.这是我们下一步要解决的问题之一.此外,现有的类间分析只限于静态依赖分析,而类间的动态依赖关系比较普遍,增加打破动态依赖边的复杂度,但是这样会带来新的问题:动态依赖关系是由于静态依赖关系而在执行阶段存在的关系,当打破静态依赖关系时,一些动态依赖关系会随之消失,对于没有消失的动态依赖关系,在何种情况下删除这些动态依赖关系来打破环路,如何为动态依赖关系构造测试桩以及动态依赖边权重的计算方法是我们下一步要解决的主要问题.致谢在此,我们向对本文给予建议的同行表示感谢.同时,对审稿人提出的有益建议表示感谢!
