Page1一种基于Sketch的Top-犽紧密中心性快速搜索算法1)(北京大学信息科学技术学院高可信软件技术重点实验室北京100871)2)(昆士兰大学信息技术和电子工程学院昆士兰澳大利亚4072)摘要在大数据的时代背景下,由于网络数据(networkdata)能有效简洁地描述社交网络、电子商务、医疗记录、在线教育等多种应用中各类复杂关系,越来越受到工业界和学术界的关注.在社交网络分析任务中,一个基本操作是从网络中发现重要程度前k大的节点.紧密中心性(closenesscentrality)是一种常见的节点重要性刻画指标,它用节点在网络中心的程度来反映节点的重要性.用紧密中心性衡量节点重要性进行节点搜索的问题称为top-k紧密中心性搜索问题.然而,传统的精确算法由于其多项式级别的复杂度无法高效地扩展到大规模的网络数据上.近来,研究人员提出了近似算法,通过牺牲结果精度来获得性能提升.通过分析发现,目前存在的近似算法虽然性能得到了有效提升,但是结果精度牺牲过大.为了解决这个问题,该文设计了一种新颖的近似算法,叫做基于Sketch的紧密中心性搜索算法.此近似算法应用了一个全新的计算方式,利用Sketch估计同一距离的邻居数目,然后得到近似的最短距离之和,最终得到各个节点的紧密中心性的估计值.此算法的时间复杂度为O(mtDmax),其中t是常数,Dmax是网络直径,m是网络边数.根据实际社交网络的小世界现象的特性,此近似算法基本是个线性算法.最后,相比于目前存在的精确算法和近似算法,该文通过全面的实验验证了基于Sketch的紧密中心性搜索算法在时间性能和结果精度等两方面的优势.关键词紧密中心性;图算法;近似算法;图分析;社交网络1引言近年来,随着万维网、Web2.0、移动网络、社交媒体以及电子商务等技术的迅速发展,大规模的网络数据已经无处不在.截至2014年2月,Facebook拥有全球12亿用户,其中仅好友关系已多达2016亿条①.同时,根据CNNIC的统计②表明,截至2013年12月,国内社交网站用户规模达2.78亿.与此同时,社交网络分析(SocialNetworkAnalysis,SNA)作为一种应用性极强的社会学研究方法,越来越受大家关注.因为SNA不仅能给公司和企业带来巨大的正效益,而且能协助政府、公安机关进行有效的公共安全监控和预警,比如利用多种类型的社会关系挖掘网络中的犯罪团伙并进行预警.社交网络分析任务中一个重要的研究问题是快速有效地发现网络中的重要节点[1-6].例如,在微博上发现有影响力的用户[1,7],并确定信息传播过程中的关键点[2]及在现实的生活社区中发现流行的商店[8]等.在网络分析任务中,一个网络节点的重要性通过中心性(Centrality)进行测量.经过研究人员多年的研究,目前已经提出了多种中心性的定义[9],包括基于信息流的PageRank、HITS、中介(Betweenness)中心性、紧密(Closeness)中心性、基于度(Degree)的中心性等.每一种中心性都从不同角度刻画了一个节点在网络中的重要程度,适用于不同的应用场景.本文重点研究的是基于紧密中心性(ClosenessCentrality)的中心性测度.紧密中心性可以描述为一个节点到网络中各个节点的平均最短路距离的倒数.它是一个基于节点的单源最短路距离分布的衡量指标,形象地描述了节点在网络中所处位置的重要程度.紧密中心性越大的节点到其他节点的平均最短路径距离越小,处于网络的越中央;能更迅速地将信息传递给其他节点,同时也能更快速地接收其他节点的信息.在实际的社交网络中,如新浪微博、人人网、豆瓣等,一个紧密中心性大的用户的状态、日志等更新相对于其他用户的内容能更迅速地传播到用户所在的社区.关于紧密中心性的一个重要的网络分析任务称为top-k紧密中心性节点搜索问题.该问题的核心是找到一个网络中紧密中心性前k大的几个节点.解决问题的关键步骤就是快速计算网络中每个节点的紧密中心性.然而,在大数据时代背景下,上述分析任务面临的网络规模不断膨胀[10-12].尽管紧密中心性能有效地刻画网络节点的重要性,但是经典的计算方法已经无法高效地处理大规模的网络数据.朴素的算法需要穷举网络中任意点对的最短距离才能计算网络中所有节点的紧密中心性,这必然引入O(n2)的空间复杂度和O(n2m)的时间复杂度.如果处理一张含有百万(106)节点的网络数据就需要1太(1012)左右的空间和时间开销.最近,Olsen等人[13]通过优化计算顺序,估算节点紧密中心性的上界值并利用该值过滤不合法的顶点的方式,减少冗余计算,最终提出了一种高效的精确算法.相对于朴素算法,Olsen等人设计的精确算法性获得了很大的性能提升.但是在处理大规模网络数据时,此精确算法仍然表现出性能低下,主要是因为平均情况下它的计算复杂度仍然与网络节点数目成多项式的关系.考虑到实际应用中,用户关注的是那些紧密中①②Page3性大的节点,并非具体的紧密中心性的数值.针对top-k紧密中心性这个分析任务,不少研究人员开始重点研究近似算法,通过快速估算节点的紧密中心性,提升算法性能.Eppstein和Wang选取一定数目的节点作为种子,利用各个节点到种子节点的最短路径估计节点的紧密中心性.虽然此随机算法能高效地处理大规模的网络,但是结果的精度不是非常理想.综合考虑,本文主要研究在处理大规模网络的背景下的紧密中心性节点搜索问题,即在给定网络G和阈值k的条件下,返回紧密中心性最大的前k个节点(详细定义见2.2节).通过上述分析可知,目前的精确算法在大规模网络下性能表现差,而近似算法则表现出结果精度不理想.本文作者重新分析了紧密中心性的计算结构,提出了一种基于Sketch的紧密中心性快速搜索近似算法.此算法在处理大规模网络数据时,既能获得高效的性能,同时具有很高的结果精度.在设计算法的过程中,笔者首先重新分析了紧密中心性的计算结构,提出了基于统计最短路分布的紧密中心性计算方法;然后,利用FM-Sketch数据结构对最短路分布进行估计,把多项式的算法空间和时间复杂度降到了线性的复杂度,从而保证算法性能.另外,笔者还讨论了算法的结果精度与利用FM-Sketch对最短路分布估计的精度的关系,并提出了启发式规则进一步优化精度.最后,通过全面的实验对比,笔者发现基于Sketch的算法性能比精确算法提升了2个数量级,比目前存在的近似算法快2~3倍左右;在精度方面,不同的(真实和模拟)网络数据上,新的近似算法比现存的近似算法高10%~60%.在本文第2节,笔者详细介绍紧密中心性、top-k紧密中心性节点搜索问题、FM-Sketch等基本概念,同时分别介绍现阶段效果最好的一种精确算法和近似算法;在第3节,笔者详细介绍基于Sketch的紧密中心性快速搜索近似算法;在第4节中通过全面的实验对比说明新方法的优势;在第5节中,笔者将详细讨论关于节点中心性计算的相关工作;最后,在第6节笔者对本文进行总结.2Top-犽紧密中心性搜索的基本概念本节正式介绍紧密中心性的概念和基于紧密中心性的节点搜索问题的定义.其次,笔者分别介绍一种关于紧密中心性搜索问题现阶段性能最好的精确算法和近似算法.最后,笔者还简单介绍FM-Sketch的核心思想和功能.2.1紧密中心性定义本文用G(V,E)表示一张网络,其中V是网络G的顶点集合,E是网络G的边集合.在社交网络上的节点中心性分析任务中,网络G是一张无权网络,即边和节点不带权值.网络中的节点用小写字母v,u表示.网络中节点数和边数分别记为n和m.另外,d(u,v)表示网络上两节点u,v之间的最短路距离;c(v)表示顶点v的紧密中心性.表1总结了本文将要频繁使用的符号.符号G(V,E)n,mu,vc(v)s(v)d(u,v)DmaxNd(v)Nd(v)NVd(u)FMd(v)|FMd(v)|之前,笔者已经简单说明紧密中心性与节点的平均最短距离之间的关系.下面定义1给出了紧密中心性的形式化定义.定义1(紧密中心性).在一个网络G中,节点v的紧密中心性c(v)是它到其他节点的平均最短路距离的倒数,形式化表示为其中,n表示网络中节点数目;d(v,v)表示节点v和v之间的最短路距离.利用定义1计算节点的紧密中心性,需要图G是连通图的假设,否则会出现d(v,v)=的情况.由于现实世界中的网络存在多个连通块,使得定义1无法有效计算节点在全网络中的紧密中心性.这里笔者引入一种更加全面通用的紧密中心性计算方式.在任意给定的一个网络G中,节点v的紧密中心性表示为其中,|Vv|表示包含节点v的连通块中顶点数Page4目.式(2)可以理解为每个节点先计算其在连通块内的紧密中心性系数|Vv|-1n-1个节点的紧密中心性在全局满足偏序关系,具有可比性.2.2Top-犽紧密中心性搜索问题定义本文研究如何在一张大规模网络中快速找到紧密中心性前k大的节点,简称为top-k紧密中心性节点搜索问题.下面是此问题的具体定义.定义2(top-k紧密中心性节点搜索).给定参数k,在网络G(V,E)上寻找k个节点,使得这k个节点的紧密中心性在网络G中是前k大.考虑到问题的通用性,本文在解决top-k紧密中心性搜索问题时,利用式(2)计算节点的紧密中心性.2.3紧密中心性搜索的精确算法Δ-pfs精确算法是指通过准确计算节点的紧密中心性的方式,求得精确的前k大节点.目前最新且性能最好的精确算法是Olsen等人[13]在2014年的数据库国际会议ICDE上提出的Δ-pfs算法.经典的精确算法需要利用单源最短路算法给每一个节点计算准确的紧密中心性,然后根据紧密中心性取值排序,得到前k大的节点.然而,经典算法中存在大量的冗余计算,即不同节点在计算单源最短路时,存在重复计算的最短路.为了减少冗余计算,合理利用已经计算得到的最短路,Olsen等人提出了Δ-pfs算法.Δ-pfs算法优化的核心思想是在计算某一个顶点的紧密中心性时重复利用其他顶点计算紧密中心性的中间结果.图1具体展示了一个冗余计算共享的例子.图1(a)展示了在一张包含6个顶点和7条边的有向图上计算顶点b的紧密中心性的过程.其中,d(b,f)=d(b,g)=1,d(b,b)=0,d(b,h)=2,于是c(b)=(Vb-1)2(n-1)∑v∈Vb在图1基础上,计算顶点a的紧密中心性,朴素的做法需要全部遍历图中的7条边,计算顶点a与其他节点对之间的最短距离之和.Olsen等人重新设计算法,通过利用先前的搜索避免重复计算,有效提升算法性能.首先,在计算顶点b的紧密中心性时,根据计算的点对之间的最短距离d(b,v),把每个顶点v标号为d(b,v),然后把其他顶点a能达到顶点标记为d(b,v)-w(a,b),其中w(a,b)为边(a,b)的权重,最后在计算过程中,新标号与旧标号一致就可以跳过重复计算.通过计算顶点b的紧密中心性,顶点b,f,g,h的标号如图1(a)中的表格所示.现在,当计算顶点a的紧密中心性时,如图1(b)所示,首先顶点a的标号为d(a,a)-w(a,b)=-1,然后根据顶点a的出边,搜索到顶点b,计算得到顶点b的新标号为d(a,b)-w(a,b)=0,与其旧标号一致,说明从顶点b出发的顶点都被计算过,且标号不用更新,因此可以跳过对顶点b的继续搜索,避免了不必要的计算.而当从a出发计算顶点g时(图1(c)),顶点g的新标号为d(a,g)-w(a,b)=0与其旧标号1不同,因此继续扩展顶点g,计算可得顶点f的新旧标号一致,停止扩展.而顶点e则由于没有旧标号(图1(d)),同样需要进一步的扩展更新.根据标号变化,可以相对快速地计算得到新的顶点的最短路距离之和,用变量s维护该值.当计算顶点b以后,s的值为4.在计算顶点a时,由于起点的标号变为-1,这样从b出发的可达的顶点的最短距离每个增加1,因此s增加4×1.由于顶点g的标号从1变为0,这样s减少1以及顶点e是新引入的s增加d(a,e)=1,最终得到最新的s为8.于是c(a)=(Va-1)2(n-1)∑v∈VaPage5为了有效降低计算的冗余度,作者进一步利用代价模型构建一张代价网络.在此网络上,利用最小生成树算法选择合适的初始节点集合,并按一定的顺序进行单源最短路的计算,使得后续的节点计算能像之前分析的一样有效利用已经处理过的节点的中间结果,减少冗余计算.其次,Δ-pfs算法根据已知的计算结果,为每个节点估计紧密中心性的上界,利用估计的上界,及时过滤那些不可能属于前k大的节点避免无意义的计算.通过上述优化,相对于传统算法,Δ-pfs算法性能得到了有效的提升.然而,Δ-pfs算法的平均时间和空间复杂度很难讨论清楚,实际优化性能随着数据的不同而波动很大.最坏情况下它的时间和空间复杂度上仍然是多项式的,无法高效处理现实世界中的大规模网络数据.2.4紧密中心性搜索的近似算法RAND为了能在大规模网络上高效计算紧密中心性搜索问题,研究人员通过设计近似算法对紧密中心性进行估计,进而获得近似的top-k紧密中心性节点.早在2004年,Eppstein提出了一种快速估计节点紧密中心性的随机算法,记为RAND-算法[14].精确算法中一个节点的紧密中心性由节点到所有其余节点的最短路之和决定;而RAND-算法的思想是利用随机抽样的方法选出s个(可重复的)节点作为种子,然后一个节点的紧密中心性由节点到这s个节点的最短距离之和进行估计.这样就把计算n次单源最短路降到了计算s次单源最短路.RAND-算法的基本步骤如下:(1)令s为算法迭代轮数;(2)在第i轮迭代中,从给定网络G中随机选择节点vi,并计算以vi为源点的单源最短路;(3)网络G中节点u的紧密中心性按如下公式进行估计:作者证明当RAND-算法抽样O时,节点的平均最短路误差控制在εD,其中D是网络的直径.这样RAND-算法是一个(1+ε)近似的算法.然而在实际应用中,为了得到精度不错的结果,s往往会比较大;或者当s较小的时候,RAND-算法的结果精度较低.2.5FM-Sketch介绍接下来,笔者介绍后续在设计本文算法时需要用到的一个数据结构FM-Sketch[15].它是一种高效且通用的估计大规模集合基数(cardinality)的方法.此方法基于元素哈希值的比特位(bit)分布特性,能仅利用几百字节的空间通过扫描一遍集合快速估计集合内不同元素的个数.FM-Sketch的计算过程是:对于集合中的每一个元素x,通过一个哈希函数h将其映射到一个固定长度(t位)的二进制数h(x);然后利用生成的h(x)构造如下一个t位二进制的bitmap.首先把bitmap每一位都置为0;然后计算集合中每个元素的h(x)中最低位1的位置,并把bitmap中相应位置设为1;这里,多个元素的h(x)对一个bitmap的操作的结果等价于每个h(x)对应的bitmap的逻辑运算“或”的结果.最后,当集合中所有元素处理完以后,计算bitmap中最低位0的位置,记为r,原集合中不同元素的数目估计值为1.3×2r,其中常数1.3是一个基于统计的魔法数字,用于修正估计结果.在实际运用中,为了提高精度,通常使用多个哈希函数,并取所有r的平均值进行估计.FM-Sketch的原理和相关证明可以参考文献[15].下面再通过一个具体例子说明如何进行估计.假设集合中有4个元素x1,x2,x3和x4,通过3个哈希函数h1(x),h2(x)和h3(x),生成3个bitmapB1,B2,B3.每一个哈希函数都将任意一个元素映射到一个t=4位的二进制.其中表2展示了h1(x)的计算结果;表3列出了3个哈希函数作用下生成的3个bitmap.以h1(x)为例,得到对应的bitmapB1的二进制值为(1011)2,这样r1=2.同理可得,r2=2,r3=1.于是,r=为1.3×21.67=4.14.h1(x1)1010除了利用多个哈希函数求平均提高估算精度的方法以外,通过对同一个哈希函数的哈希值进行分组处理,然后根据不同分组的估算结果进行综合得Page6到最终的估算结果.作者讨论了在t固定的条件下,随着组数m的增大,FM-Sketch的估算精度会提高.这里具体的估算方法如下:假设n个不同元素在同一个哈希函数下计算的哈希值,被划分成m组FM-Sketch,那么n的估算公式如下:其中r是指m组bitmap中最低位0的位置的平均值.3基于Sketch的紧密中心性搜索算法本节详细介绍基于Sketch的top-k紧密中心性搜索算法.首先,笔者给出了一种基于计数的紧密中心性计算方式,并结合此新的计算方式,设计了全新的紧密中心性搜索算法;然后,利用FM-Sketch数据结构进行优化,使得算法能够快速估计各个节点的紧密中心性.最后,笔者讨论了近似算法结果精度,利用启发式规则进一步优化算法精度.3.1基于计数的紧密中心性计算根据式(2)可知,紧密中心性的计算核心是统计一个节点u到其他节点的最短路距离之和,记为s(u).如果知道一个节点u的所有最短路按其距离长度的分布,那么节点u的所有最短路距离之和可以表示为s(u)=∑v∈V其中,Dmax表示网络G上任意点对中最长的最短路距离,即为网络G的直径;Nd(u)表示与节点u最短路距离为d的节点数目.根据式(3),紧密中心性的计算转化为一定长度的最短路径数目的统计.用NVd(u)表示与节点u最短路距离不超过d的节点的集合,即NVd(u)={v|d(u,v)d}.于是,Nd(u)=|NVd(u)|-|NVd-1(u)|.结合社交网络应用中重要节点发现的特征,本文考虑的网络不涉及节点和边的权值,即所有边的长度均视为1,于是NVd(u)满足如下递推性质.性质1.节点u在距离d以内可达的节点集合是该节点的所有邻居节点在距离d-1以内可达的节点集合的并集,即利用式(2)、(3)和性质1,可以在网络G(V,E)上搜索top-k紧密中心性节点.基本思想是通过逐个扫描网络G上的连通块,针对每一个连通块CCv,利用计数的方式计算每个连通块内节点的最短路距离之和.最终,利用性质1,能够在Dmax次循环求得连通块内所有节点的最短路之和.算法1详细展示了上述过程.对于给定的网络G=(V,E),算法枚举遍历网络中的顶点v(第1行),如果该顶点v没有被访问过,即其不属于任何被处理过的连通块中,算法1利用BFS搜索策略找到顶点v所在的连通块CCv,并把连通块内的所有节点标记为已访问;否则跳过顶点v继续处理下一个顶点(第1~4行).对于找到的CCv,首先利用抽样算法估算CCv的直径Dmax(第5行),然后Dmax次迭代利用式(2)、(3)计算连通块内每个顶点的最短距离之和(第9~17行).最后,根据顶点紧密中心性的计算公式计算相应节点的紧密中心性,并更新结果集合(第18行).算法1.基于计数的top-k紧密中心性搜索算法.输入:网络G=(V,E),k输出:紧密中心性top-k的节点编号1.ansSet←;2.forv∈Vdo3.ifv没有被访问过then4.计算节点v所在的连通块CCv,并把连通块内的5.Dmax←CCv的直径;6.forw∈CCvdo7.N0(w)←{w};8.endfor9.ford←1toDmaxdo10.forw∈CCvdo11.Nd(w)←;12.foru∈Neighbor(w)do13.14.endfor15.16.endfor17.endfor18.forw∈CCvdo19.计算c(w),即c(w)←20.根据top-k限制,利用c(w)更新ansSet;21.endfor22.endif23.endfor24.returnansSet;Page7接下来,通过一个具体例子详细介绍基于计数的紧密中心性计算过程.给定网络G如图2所示和表4不同迭代轮次各顶点的邻居节点集合d0123图21个包含有6个顶点和7条边的无向无权图结合算法1,可知基于计数的紧密中心性计算一共包含3轮迭代.在初始化阶段(第0轮迭代),每个顶点的邻居集合即为它本身,如表4第1行所示.随着迭代的进行,每个顶点的集合通过其邻居顶点的上一轮迭代的邻居集合合并得到最新的集合元素.以顶点a为例,在第2轮结束后,它的最短路距离不超过2的邻居集合,NV2(a)=NV1(a)∪NV1(e)∪NV1(b)直到3轮迭代结束,由于本样例是个连通图,因此每个顶点的最短路距离不超过3的邻居集合都是{d,c,b,f,a,e}.复杂度分析.算法1中,每个节点需要计算关于一定距离内可达节点的集合运算(代码第13行),因此每个节点需要维护上述邻居集合NVd(u),如表4所示.令该集合的平均空间大小为Mcost,于是算法1的空间复杂度为O(nMcost).同样,时间复杂度为O(mDmaxTcost),其中Tcost是指计算一次邻居集合并的平均时间代价.现实世界中的社交网络往往一般具有小世界现象,一个节点与其他所有节点的平均最短距离比较小,接近于常数[16],即Dmax相对于网络规模可视为常数.因此算法1的时间和空间代价基本由邻居集合的运算和大小决定.然而,在计算过程中,随着d的增大,当d接近Dmax时,邻居集合NVd(u)基本接近全图顶点,使得此精确算法仍然是关于网络规模n或m的多项式算法,很难扩展到大规模的网k=2.网络G的直径Dmax=3,只有一个连通块.表4列出了不同迭代轮次内每个顶点的邻居集合.NVd(d){d,c,b,f}{d,c,b,f,a,e}络图上.3.2基于Sketch的近似算法基于计数的紧密中心性计算的瓶颈在于维护NVd(u)和计算相应的集合并.即使利用位图(bitmap)为每个节点u维护精确的NVd(u),只能降常数级别的复杂度,算法总体上仍然需要多项式级别的空间和时间复杂度.笔者利用Sketch的方法,为每个节点维护一个近似的NVd(u),从而估算节点的紧密中心性.此法称为基于Sketch的紧密中心性搜索算法.首先,维护NVd(u)的过程可以抽象为“从节点u开始向外扩展d步,生成一组节点的访问序列,NVd(u)则为此序列中互不相同的节点的集合”.集合内元素的数目用|NVd(u)|表示.换而言之,维护NVd(u)的过程就是随着节点往外扩展,算法需要动态维护集合NVd(u)中不同元素的个数.在2.5节中介绍的FM-Sketch恰好是一个用于估计此问题的很好的数据结构.这里笔者引入FM-Sketch对|NVd(u)|进行估计.根据之前关于FM-Sketch的介绍,可以知道FM-Sketch具有如下几点性质:(1)FM-Sketch的值与其加入元素的顺序无关;(2)FM-Sketch是统计一个集合内不同元素的个数,能自动过滤掉重复元素;(3)集合并运算可以简单地转化为基于FM-Sketch的逻辑“或”运算.例如,估计两个独立的集合A和B的并集C中包含的不同元素的个数可以通过A和B的FM-Sketch的“或”运算得到,即FM(C)=FM(A)|FM(B).(4)具有包含关系的两个集合的差集大小同样可以通过相应FM-Sketch的差值得到.例如,给定集合A和B,且BA,那么|A-B|=|FM(A)|-|FM(B)|.结合FM-Sketch的上述特性,top-k紧密中心性搜索的算法1的近似版本如算法2所示.此近似算法的空间复杂度为O(tn),其中t是维护FM-Page8Sketch所需的位数;时间复杂度为O(mtDmax).从上面我们可以发现,近似算法由于引入了FM-Sketch数据结构,虽然牺牲了一定的结果精度,但是算法的空间复杂度变为线性,时间复杂度仅与网络的边数和直径相关.由于实际网络一般比较稀疏和具有小世界现象,此近似算法时间复杂度基本是关于网络中边的数目的线性时间复杂度.算法2.基于Sketch的top-k紧密中心性搜索算法.输入:网络G=(V,E),k输出:紧密中心性top-k的节点编号1.ansSet←;2.forv∈Vdo3.ifv没有被访问过then4.计算节点v所在的连通块CCv,并把连通块内的5.Dmax←CCv的直径;6.forw∈CCvdo7.8.endfor9.ford←1toDmaxdo10.forw∈CCvdo11.FMd(w)←012.foru∈Neighbor(w)do13.14.endfor15.16.endfor17.endfor18.forw∈CCvdo19.计算c(w),即c(w)←20.根据top-k限制,利用c(w)更新ansSet;21.endfor22.endif23.endfor24.returnansSet;3.3近似算法精度讨论及优化接下来笔者讨论算法结果精度与FM-Sketch精度的关系.直观的感觉是如果FM-Sketch的估计结果越精确,那么算法2产生的结果精度也就越高.定理1给出了详细的理论分析.定理1.如果一个连通网络的直径为D,那么算法2得到的每一个节点的最短路距离和s(u)的方差δs为其中,δFMd的节点数目的方差.证明.根据算法2中第10行代码可知s(u)=∑由于FM-Sketch的方差仅与其使用的哈希函数相关,不同距离的FM-Sketch估计相互独立.于是可以得到根据定理1,为了提高算法2的精度,原则是提升节点数目估计的精度.这里我们介绍一种启发式规则,能有效提升算法精度.在一定的内存开销下,即t固定,当估计的集合大小与对应的FM-Sketch能表示的最大数目接近时,估计精度越高.然而,在d比较小的时候,如d为1或2,由于访问的节点数目过小,FM的估计精度很低.考虑到d较小的时候,节点数目不多,直接精确计算节点数目的代价也很小.这样笔者为算法2引入了如下启发式规则.启发式规则.当d=1,2时,算法2精确计算节点数目;当d>2时,算法2利用FM-Sketch估计相应节点数目.从后续的实验可以看出,此启发式规则在处理的网络数据直径比较小的时候,能有效提升算法的精度.4实验与算法比较分析本节通过实验测试,验证基于Sketch的紧密中心性节点搜索算法在大规模网络数据上的处理性能.4.1实验环境本文实验运行在一台Linux服务器上,此服务器装有2个Xeon(R)E5530@2.40GHz的CPU,96GB内存以及4个2TB硬盘.实验中涉及的网络数据由两类组成:一是由开源软件NetworkX①生成的模拟网络数据;二是斯坦福大学的SNAP网站②下载得到的真实网络数据.其中,生成模拟网络①②Page9数据的模型是Holme-Kim生长模型[17].此模型生成的图用GHK(n,c)表示,n是顶点数目,c代表为表5网络元数据信息网络类型模拟图真实图精确算法,Δ-pfs算法;效果最好的近似算法,RAND算法,其中ε=0.1;本文设计的Sketch算法;以及加入启发式规则优化的Sketch算法,记为Sketch2hop算法.另外,Sketch算法中使用的FM-Sketch的相关参数如下:bitmap的比特位数设置为24,即t=24,这样基本能统计约224个不同元素的结合;使用一个哈希函数;哈希值被分成128组,即m=128.上述算法的性能主要从两方面进行比较:第一是算法运行时间;第二是算法的结果精度.时间性能是算法重复运行10次的平均时间,精确到0.01s.结果精度用准确率(precision)表示.一组top-k结果的准确率按如下公式计算:precision@k=4.2FM-Sketch精度与算法精度关系由定理1可知,本文算法的精度与FM-Sketch的精度有着紧密的联系,即FM-Sketch的估计精度越高,本文的Sketch算法的精度也越高.笔者通过下面这组实验验证了上述观点.表6Sketch,Sketch2hop,RAND和Δ-pfs这4种算法在不同数据集上的时间性能SketchSketch2hopRANDΔ-pfsSketchSketch2hopRANDΔ-pfs每个新生成的顶点加入的边数.表5列出了实验所使用的网络的具体信息.由2.5节分析可知,FM-Sketch的精度可以通过增大分组数m得到.图3展示了在真实图loc-gowalla和com-youtube以及模拟图GHK(10k,20)和GHK(50k,20)上m从8变到1024过程中,Sketch算法结果精度的变化.从图上可以明显看出,Sketch算法的精度随着分组数的变大(即FM-Sketch的估计精度提高)而变大.例如,在真实数据图com-youtube上,当m=16时,Sketch算法精度是64.08%,当m增大到1024时,Sketch算法的结果精度约为94.08%.这里需要注意的一点是,在模拟图GHK(10k,20)上,当m=32时,Sketch算法精度略差于m=16时的精度,这是由于本文只用一个哈希函数以及数据特征的特殊性造成的.4.3算法时间性能比较本节实验详细比较了4种算法的时间性能.从实验结果可以看出,不管在真实图还是在模拟图上,Sketch算法时间性能最好,比精确算法Δ-pfs快2个数量级,比RAND算法快2~3倍左右.这个性能差距在大规模的网络数据上表现尤为明显.表6列出了各个算法在不同类型图上的性能.GHK(40k,20)Page10图3Sketch算法精度(MAP@50)与FM-Sketch分组数(m)的变化关系例如,在com-youtube数据上,求解top-50的紧密中心性搜索问题,Δ-pfs耗时12208s;而Sketch算法仅需要44s.RAND算法耗时接近Sketch算法的两倍,83s.在LiveJournal网络上,精确算法在48h内仍然无法求得结果,Sketch算法大约10min左右返回结果.Sketch算法的优秀的性能得益于其基于FM-Sketch的快速统计.另外,从结果可以发现,Sketch2hop算法时间性能虽然略差于Sketch算法,但是其时间性能仍优于RAND和Δ-pfs算法的时间性能.这说明启发式规则对算法时间性能的影响不大,可以接受.4.4算法结果精度比较本节实验对比了3种近似算法的结果精度,准确的结果由Δ-pfs算法生成.由于Livejournal的精确结果无法在一定的时间内得到,本文没有比较该图上的结果精度.实验过程中,每个算法分别计算了top-1至top-50的精度.图4展示了loc-gowalla,com-youtube,GHK(10k,20)和GHK(50k,20)这4个数据集上精度随k的变化的情况.从图上可以发现,基于Sketch的算法的精度在真实图和模拟图上均比RAND算法高,不过在不同类型图上提升效果不同.在直径较大的真实社交网络中,Sketch算法的精度能比RAND高40%~60%;而在直径较小的图上优势略有下降,精度提升基本在3%~8%.另外,启发式规则在直径较小的网络上优化效果明显,Sketch2hop算法的精度比Sketch算法高10%左右;而在直径较大的网络上优化效果不明显.从定理1可知,直径越大,误差越大,使得启发式规则的优化效果从整体上看就不明显.其他数据集上的精度结果在不同的k值上的变化与上述4个数据集的情况类似,本文不一一展示结果.表7列出了各个数据集上top-1至top-50的平均精度,即MAP@50指标.从表中同样可以发现Sketch系列算法的精度比RAND算法高.其中Sketch2hop算法在模拟图上精度可以达到100%,即精确结果.这是因为模拟图直径很小,从表5可知,直径均是3,这样结合启发式规则,精确统计二跳以内邻居数目,从性能角度分析,Sketch2hop算法与精确算法几乎等价.Page11图4不同网络数据上的精度与k的关系表7Sketch,Sketch2hop和RAND算法在不同数据集上的MAP@50/%GHK(30k,20)86.08100.0089.30email-Enron86.7589.8814.16SketchSketch2hopRANDSketchSketch2hopRAND5相关工作接下来首先回顾下网络中各类中心性的度量,然后介绍与紧密中心性计算相关的工作.5.1多种中心性度量本节介绍各类中心性的度量方式.首先,基于度(degree)定义的中心性Cdeg是最流行且最直接的一种定义.此中心性即为相应节点的度数,一个节点关联的边越多就越重要[9,18].进一步,基于度的中心性可以解释为统计了节点周围路径长度为1的路径数目.在此基础上,一个直接的泛化就是利用节点周围长度为K的路径数目表示节点的重要性,称为K-Path中心性.从路径长度定义类型的不同角度出发,K-Path中心性也产生了很多变种:基于距离的K-Path中心性,边独立的K-Path中心性和节点独立的K-Path中心性[19].另外,以通路(walk)的概念为基础,也产生了多种相应的中心性概念.其中,Katz中心性[20]用节点出发的通路数目表示,形式化表示为犲T其中犲i是一个第i个位置为1,其他位置为0的列向量.β是一个大于0的惩罚系数,为了反映路径越长,其对中心性的贡献越小.在Katz中心性基础上,产生了Bonacich中心性,其形式化为犲T允许β取负值.Katz中心性和Bonacich中心性都是Page12Hubbell中心性的特殊形式.Hubbell中心性可以表示为犲Ti∑上述基于度的中心性定义中,除了度中心性可以在多项式时间复杂度内进行计算以外,其他的中心性均具有较高的时间复杂度,无法进行高效计算.为了从网络的全局信息衡量一个点的重要性,提出了基于信息流的节点中心性定义.其中,PageRank[18],HIT[21]等用来衡量一个网页节点在整个网络中的重要性的指标就是经典的基于信息流的中心性定义.与紧密中心性类似,同样基于最短路定义的一个中心性叫中介中心性(betweennesscentrality)[9,22-23],它的具体定义如下:其中,δst是指节点s和t之间最短路的数目,而δst(u)是指节点s和t之间经过节点u的最短路的数目.由定义可知,中介中心性反映了一个点在信息传播过程中的重要性.另外,通过上述公式可以发现,中介中心性的计算相对紧密中心性更为复杂,即使计算一个点的中介中心性,都需要先计算全局点对间的最短路.关于中介中心性计算方法的研究可以参考文献[22-23].本文重点研究了基于紧密中心性的top-k节点搜索问题.一种标准做法是结合阈值和一定的估算上界值,维护一个前k大的节点集合.当上界值比阈值小的时候,当前的前k大节点集合即为最终结果集合.多数精确算法,利用上述框架进行剪枝,提升算法性能.5.2关于紧密中心性搜索的精确算法接下来,笔者介绍除Δ-pfs算法外的关于紧密中心性搜索的精确算法.一种简单直接的精确算法是利用全局最短路径算法(All-PairsShortestPath)计算网络上任意节点对之间的最短路径距离,然后对计算结果进行排序,取排名前k的节点即可得到结果.利用Floyd-Warshall算法[24]计算全局点对之间的最短路,算法的时间复杂度为O(n3)和空间复杂度为O(n2).一种优化策略是利用单源最短路Dijkstra算法[25]和Fibonacci堆[26]计算每一个节点的单源最短路径,从而得到节点的紧密中心性.优化后的精确算法的时间复杂度是O(nm+n2logn),适合于稀疏的网络.另外,还有研究工作通过构建索引快速查找一个点对之间的最短路[27];然后,通过实验发现,基于索引的方法比直接利用Dijkstra算法计算最短路性能差[27],这是因为紧密中心性的计算需要不断重复访问或计算点对之间的最短路.然而,目前存在的精确算法,包括Δ-pfs算法,在时间和空间复杂度上仍然是多项式的,无法高效处理现实世界中的大规模网络数据.而本文的工作主要针对新的近似算法的设计和优化.5.3关于紧密中心性搜索的近似算法为了能在大规模网络上高效计算紧密中心性搜索问题,不少相关工作通过设计近似算法对紧密中心性进行估计,然后,基于估计的紧密中心性,获得近似的top-k紧密中心性节点.除了在2.4节提到的RAND算法之外,Brandes和Pich[28]在RAND算法基础之上,从如何选择s个种子节点的角度深入讨论了此算法并设计了4种拓展,分别为MaxMin,MaxSum,MinSum和Mixed.MaxMin策略每次选择离之前选中节点越远的点作为下一个种子节点.MaxSum策略每次选择与之前选中节点距离之和最大的点作为下一个种子节点.Mixed策略,为了避免上述两种策略过度估算距离,利用round-robin方式混合循环使用RAND,MaxMin,MaxSum策略选择下一个种子节点.另外,Kang等人[29]对紧密中心性进行了重新定义,提出了effectivecloseness的概念并利用MapReduce并行计算框架进行求解.其中,effectivecloseness是指利用近似的平均距离估算的相应的紧密中心性.与上述算法不同的是本文提出的近似算法重新考虑了紧密中心性的计算结构,通过以计数的方式进行求解.5.4关于紧密中心性搜索的混合算法框架在处理大规模网络数据时,精确算法无法保证性能,而近似算法虽然高效,但得到的结果却是近似的.为了解决这个矛盾,Okamoto等人[30]提出了综合利用精确算法和近似算法的混合计算框架.在处理top-k紧密中心性搜索问题时,此框架首先利用近似算法选出k(k<kn)个候选节点,然后对每一个候选节点利用精确算法计算相应的准确的紧密中心性,最终选出前k个节点作为结果.Okamoto在RAND算法基础上通过设置阈值δ选择k个节点,然后把与k号节点的估计紧密中心性之差小于δ的节点全部纳入候选节点,从而很大概率地保证Page13最终结果的正确性.然而,在实际应用中,由于RAND算法的精度问题,计算得到候选节点数目过多,甚至能包含整个网络的节点,导致Okamoto的混合算法框架性能也不理想.本文提出的基于Sketch的紧密中心性搜索算法可以替代RAND算法应用到混合框架内部.从RAND算法和基于Sketch的算法实验比较中可以看出,Sketch算法不仅性能优于RAND算法,同时结果精度也高.6总结社交网络发展的规模越来越大,基于社交网络的分析已经成为各类实际应用不可或缺的分析手段.本文重点研究了基于紧密中心性的网络上重要节点发现的算法.为了能够很好地处理大规模网络数据,笔者设计了基于Sketch的近似搜索算法,并通过详细的实验验证,基于Sketch的近似搜索算法相对于其他精确算法和近似算法在性能和和精度两方面的优势.在本文工作基础上,笔者将利用并行计算进一步提升算法性能,设计并行的top-k紧密中心性搜索框架,另外,考虑到实际中社交网络频繁发生变化,后续也将此算法拓展到处理动态变化的网络.
