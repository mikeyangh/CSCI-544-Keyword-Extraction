Page1面向SaaS应用基于键值对模式的多租户索引研究孔兰菊李庆忠史玉良王学(山东大学计算机学院济南250101)摘要面向SaaS应用的多租户数据库为满足租户的数据隔离和按需定制的需求,需要提供支持隔离和易于定制的数据存储机制及索引机制.基于键值对存储方式,提出元数据驱动的映射表索引模型,该模型根据租户定制需求,为租户业务数据形成各自的索引元数据,通过元数据驱动实现了索引数据的隔离及定制效果;给出索引的维护策略,根据租户数据访问请求进行索引切片,以逐渐细化的索引切片作为数据访问的基本单位,快速返回租户结果集.实验结果表明,该方案在数据访问分布均衡的情况下,使索引维护及数据访问具有较好的总体性能.关键词多租户;索引;键值对;SaaS;结构化数据1引言在面向SaaS[1-2]的应用中,多租户数据库需要提供租户之间的数据隔离及按需定制功能,同时,还要在性能上让用户有比较好的体验.这对数据的存Page2了稀疏表模式下的数据透视表索引以及云数据管理基于HBase存储的多维索引等.稀疏表方式在支持租户定制方面受DBMS的限制,而HBase存储主要面向非结构化数据处理.本文的研究背景为CRM、HR等系统,以结构化数据为主.综合国内外研究成果,本文采取了键值对模式的存储方式,该存储方式能完美地支持租户定制及数据隔离,并且非常适合于描述结构化数据,面对成千上万的租户,如何实现索引的定制及索引数据的隔离存储都成了需要解决的问题.在现阶段,面向SaaS应用的多租户数据管理已经成为国内外研究的热点.文献[1-2]针对数据安全性、数据可扩展性等方面提出并分析了一些设计模式;文献[3]提出了SaaS应用的体系架构,然后提出了基于SaaS模式的企业公共服务平台的3个紧密相连的模型———多用户数据模型、元数据管理模型和安全服务模型;文献[4]探讨了数据仓库应用在云数据中改进索引模式以减少无效处理时间,提高命中率;文献[5]探讨了多租户数据层如何支持多租户服务计算;文献[6]提出了折叠表方式,并对各种数据管理方式得出了较详细的性能数据文献;文献[7]采用了预定义字段机制支持扩展,在查询方面提出了元数据驱动、外部搜索引擎、次优搜索机制等理念;文献[8]提出了如何使用XML来支持数据定制及驱动ECA模型;文献[9]更是在2009年的SIGMOD上讨论了目前主要的集中多租户数据管理方式,包括稀疏表、扩展表、XML、键值对等.该文献经过全面地论证和分析后认为,理想的多租户数据库尚未出现,还有很多的问题需要研究,本文主要探讨了索引方面的关键技术.传统的索引方式,在多租户数据库模式下,可以按照objectID、columnNAME及value建立复合索引,针对key_search这种模式,可以迅速定位到某些属性,并且重组成一个元组;对于key_search的范围查询,通过key定位到某个元组,它需要大量的连接才能反回结果集,存在性能问题;对于复合索引里边的次关键字的查询,如果想快速查询,就必须再次创建复合索引,但存储空间巨大,否则查询性能严重不足.Column_store[10-13]是面向数据仓库的,基本上是以读为主的应用.数据仓库有着特殊的背景,它由维度和事实构成,维度通常数量有限,维度的组合虽然多,但是最终形成的方体为稀疏型的.在这种前提下,monetDB数据库中提出了cracking[14-15]的策略,在查询的时候,建立查询列的副本,并按照avl树的思想基于每次查询动态调整元组顺序,这是查询驱动的思想.对于以事务处理为主的多租户应用,每次更新都要及时地反应出来,这种查询驱动的方式存在着明显的缺陷.本文更多地关注了数据库更新时的索引维护策略.Hbase[16]是一个类似Bigtable的分布式数据库,大部分特性和Bigtable一样,是一个稀疏的、长期存储的、多维度的、排序的映射表.这张表的索引是行关键字、列关键字和时间戳.每个值是一个不解释的字符数组,数据都是字符串,不支持数据类型.同一个关系里面的每一行数据都可以有截然不同的属性,为动态定制属性提供了一种手段.Hbase存在的问题有两点,首先Hbase不是多租户的,没有提供隔离机制;其次,Hbase面向的是非结构化数据,每个值是一个不解释的字符数组,擅长于关键字搜索,它不可能提供基于某个属性组的索引,而结构化数据事务处理需要确切的解释每个属性的含义并对其进行维护.本文更多地讨论了结构化数据的索引机制.稀疏表方式建立了数据透视表作为索引,比较有代表性的Salesforce就采取了这种方式.这种索引方式解决了索引列数据对象同质的问题,但是他并没有深入探讨透视表与稀疏表的数据同步问题,也无法解决透视表数量暴涨的问题.本文基于键值对存储模式,分析了现有索引的局限性,结合稀疏表模式下数据透视表的思想,引入了数据映射表索引机制及切片策略,提出了一种用于多租户数据库的面向结构化数据的映射表索引结构及索引维护策略.该索引结构能有效地支持多租户定制及隔离特征,并能提供较好的访问性能.本文第2节给出键值对传统索引机制在SaaS应用的问题分析,介绍基于键值对模式的多租户映射表索引模型;第3节讨论索引更新策略;第4节给出上述算法的实验验证;第5节给出相关工作;第6节给出本文的结论与展望.2基于键值对模式的多租户索引模型2.1键值对模式介绍在SaaS模式下,数据库不但要提供极高的性能,还要支持租户隔离而且富于扩展性.多租户数据库要根据环境的不同,比如不同的租户、不同的工作流程、不同的服务水平协议等提供易变性.结合国内Page3外研究现状,本文选择了键值对存储方式来存储业务数据.键值对方式能提供较好的易变性,在键值对方式下,每个属性都存储在一个长而窄的关系里(如图1).租户根据自己业务的需要,自由定制所需数据项,租户的定制信息被保存在元数据(Metadata)里.租户定制的数据项经过逻辑层与存储层模式映射后,被统一保存在数据关系里(DataTable).对应于租户数据可以建立传统的索引(Index),如B+树,以方便数据存取.如表1所示,租户从逻辑层看到的仍然是传统关系模式的表格,但是在实际的键值对存储模式里,基于元数据信息,该关系通过模式映射机制被透明地转换到DataTable(表2)中.RowIDABCD1234TenantIDTableIDRowIDColumnIDValue001R1A5001R1B2001R1C张三001R1D2008001R2A1001R2B3…002R1B15…在键值对存储下,可以为业务数据建立全局索引,如(TenantID,TableID,ColumnID,Value).当存取单个属性时,根据索引能直接进行操作.当用户试图根据属性a访问b时,数据库中就没有合适的索引可以使用,只能进行顺序扫描.在键值对存储模式下,即便建立多租户模式下常用的数据透视表索引,也必须要进行多个分支的查找,才能同时存取属性a和b.在键值对存储下,也可以为每个租户建立数据分区以支持数据隔离,同时按分区建立局部索引实现索引数据隔离.分区机制能有效地支持隔离,但并没有提供对多租户特征的支持,每增加一个租户都要显式地执行分区表定义及索引定义,受数据库模式动态改变及分区表数目上限的限制,无法满足多租户数据管理的需求.根据以上分析可以看出,直接把传统索引应用于键值对模式的多租户数据库面临着许多问题,概括起来主要有以下几个方面:(1)传统索引是在关系的某个属性组上建立的索引,该索引键值所包含的数据对象应该是同一类型的数据,这不符合基于元数据的键值对存储模式的特点.键值对存储模式利用元数据存储租户的数据模式信息,而所有的业务数据都被存在一个纵向生长的关系里,它的数据类型是通用的数据类型,互相之间实质上拥有不同的数据类型,不具有可比性.同时,由于关系里只有一个通用属性,也将无法自然地支持多个属性的联合索引.(2)现存索引缺乏对多租户标识的直接支持,而此标识是数据对象是否显示的决定因子.虽然可以通过把多租户标识直接包含到索引的键值里去,但这种大重复量的标识信息势必会增大索引的空间需求,并且也无法自然地支持租户之间索引隔离存储的需求.综上所述,目前索引只能用于多租户数据库中按键值存取某个元组的情况,无法直接支持租户隔离、租户模式不同、租户按照范围进行存取的情况.本文提出了键值对模式下的多租户索引模型.2.2基于键值对模式的多租户索引模型本文对键值对模式的多租户数据库进行了扩展,增加了基于元数据的映射表索引机制(如图2虚线框内),索引模型包含索引元数据和索引数据,索引元数据保存在MappingColumn及MappingSet中,索引数据保存在MappingIndex及Mapping-Pending中.索引元数据根据定制可纵向生长,不会受限于租户属性的数目;索引数据由元数据驱动,同Page4样可纵向生长,不会受限于租户业务数据量的影响.本文映射表索引存储于系统缓存(Cache)中,并没有图2扩展后的多租户数据库模型下边给出本模型相关的定义:定义1.Metadata.表示元数据,用于保存各租户的数据模式,本模型中用关系表Tables、Columns、MappingColumn、MappingSet存储.元数据为模式映射提供支持,本文基于元数据把用户请求透明地转换为键值对模式下的操作.Tables存储关系定义,Columns存储关系的属性定义,MappingColumn存储所有的索引列及其渐进式的索引更新过程,MappingSet存储与索引列相关的映射定义.本方案中以顺序存储的切片点列表(Pivots)来表示索引更新过程,用CurrentPivot表示某个映射当前的切片点,在本模型中一般是数据访问请求的参数.Metadata={Tables,Columns,MappingColumn,MappingSet},Tables=(TenantID,TableID,Tablename),Columns=(TenantID,TableID,ColumnID,ColumnName,DataType,Length,Nullable),(TenantID,TableID,Column1,Pivots),Column1,Column2,CurrentPivot),MappingColumn=MappingSet=(TenantID,MappingID,TableID,Pivots={Value|Value∈ΠColumn1(σTenantID=直接实现于关系数据库的底层.currentTenant∧TableID=currentTable(R))}.定义2.DataTable.表示数据表,以键值对方式存储租户业务数据,本模型中用关系表DataTable来存储.DataTable=(TenantID,TableID,ColumnName,Value).定义3.MappingIndex.表示映射表索引,用来存储索引列A与B的关系,本模型中该索引存储在缓存中.MappingIndex=(TenantID,MappingID,Column1,Column2).映射表索引在缓存中的实际存储如下:MappingIndex(A,B)={node}node=(P0,(K1,V1,P1),…,(Km,Vm,Pm))0<i<m+1,(Ki,Vi)∈ΠA,B(σTenantID=currentTenant∧pi=node.在第一次执行映射表索引更新时,需要花费时间和资源来为此做准备,为减少准备时间,本文采取了渐进式更新映射表的方式,为了记录每次更新所产生的索引切片(参见定义6),本模型通过MappingColumn记录某一属性的切片列表,并通过MappingSet里的CurrentPivot记录了某一映Page5定义4.MappingPending.表示索引缓冲区,用来缓存待插入的索引列A与B的关系,等该数据需要被访问的时候,合并到MappingIndex中.MappingPending=(TenantID,MappingID,Column1,Column2).为提高更新速度,索引缓冲区只有追加操作,不考虑有序性.定义5.MappingSet(A).表示MappingSet的关于属性A的一个子集,表示的是当前租户当前应用建立在A上的索引,描述了索引列A和其他列的两两关系.MappingSet(A)={MappingIndex(A,X)|X∈ΠcolumnName(σTenantID=currentTenant∧TableID=currentTable(columns))}.MappingSet(A)的缓存需求取决于所属Table的列的数目,即|MappingSet(A)|=count(column),这将是一个很大的代价.出于上述考虑,本文的MappingColumn(A)在租户定制索引的时候建立,但是具体包含的MappingSet(A,X)则根据具体的查询驱动建立,这样对于一些不经常用的数据就不会过早地占用资源.射的最新切片点.定义6.Slice.切片,是MappingIndex的一个子集,表示的是当前租户当前应用根据租户请求进行分片后形成的映射集合.3基于键值对模式的多租户索引维护策略租户定制索引时,系统把索引结构映射到索引元数据中.基于索引元数据的映射,索引数据共享地存储在一个索引表中,首先屏蔽了多租户索引模式的差异,其次有效地解决了传统数据透视表数目过多导致性能下降的问题,最后能解决索引数据中标识性信息(如TableID,ColumnID)重复存储的问题,节约了索引数据存储空间.访问数据时,根据访问参数对索引数据进行切片,同一个切片内部的数据含义一致,解决了传统索引中索引难以理解及按租户标识进行过滤的问题.关键过程1.CreateTable.用于在多租户数据库中创建表,本模型中把命令转化为针对元数据的操作.insertintotables(TenantID,TableID,Tablename)insertintocolumns(TenantID,TableID,ColumnName,DataType,Length,Null)关键过程2.CreateIndex.表示在多租户数据库中创建映射表索引,需要根据租户对table的元数据描述,来创建各自的索引.createindexidxontablex(A)→createMappingColumn(A);→insertintoMappingColumn((TenantID,TableID,循环插入产生多个MappingID:insertintoMappingSet(TenantID,MappingID,对于表2中的数据,假设租户001定制A为索引列,租户002定制B为索引列,则当前模型中实际存储中应该只有MappingColumn插入了索引信息,MappingSet和MappingIndex都会到真正使用的时候才会插入信息.如表3所示.TenantIDTableIDColumnIDPivots0010023.1映射表索引维护策略在事务性的SaaS应用中,业务数据持久化操作频繁,如果没有好的索引更新策略,在实时性要求较高的业务管理系统里是不可行的,本文提出了按需更新映射表索引的策略.业务数据更新时,只需要更新映射表索引缓冲区;业务数据查询时,首先根据元数据进行切片对齐,然后检查索引缓冲区是否有缓存数据需要合并,再按照索引进行查询,并返回结果.基于第3节的形式化定义,本文设计了如下的索引按需更新算法及相应的查询算法.算法1.数据更新算法.输入:insertintoR(A,B,C)Values(v1,v2,v3)输出:null1.获取当前TenantID;2.更新数据库中的业务数据;3.根据TenantID和ColumnID获取MappingColumn中对应的索引列;for每一个索引列(ColumnID)查找MappingIndex及其MappingPending;对MappingPending追加上对应column1、Page6next该算法只对已经创建映射表索引的关系进行处理,如果插入时尚未建立索引,则会在首次查询的时候生成索引数据.2.1若无,认为无索引,返回createMappingSet(A,B)算法2.数据查询算法.输入:selectBfromRwherev1<A<v2输出:符合条件的B的集合1.获取当前TenantID;2.根据TenantID获取MappingColumn(A)3.ifMappingSet(A,B)=null,then4.检查MappingIndex(A,B),根据MappingColumn(A)5.检查MappingPending(A,B),若有,则调用算法3;6.检查MappingColumn(A),看是否存在v1,v2的切if不存在v1thenendifif不存在v2thenendif7.返回位于v1,v2之间的B的值.该算法以切片为数据访问的基本单位,能直接定位到要访问的1~2个切片,在进行一定次数的切片后,能有效地提高访问性能.算法3.索引合并算法.输入:MappingIndex(A,B),MappingPending(A,B)输出:合并以后的MappingIndex(A,B)1.遍历MappingIndex的所有slice,2.若属于,直接将该项插入到该slice第一个位置,结束;3.若不属于,再判断前面的slice,3.2映射表索引算法分析4.删除缓冲区里的MappingPending(A,B)本文提出的算法是正确而完备的.证明如下:中有记录;会进入索引中;(1)对于任意索引列x,必然在MappingCoulmn(2)数据库更新时更新的数据在被查询时一定若更新时就已经存在映射(x,y),则所更新数据会保存到索引缓冲区中,当(x,y)被访问时,算法2会合并索引缓冲区到MappingIndex中.若还不存在映射(x,y),则当x,y被查询的时候,算法2会根据DataTable创建x,y的映射关系,并根据MappingColumn里的切片列表补齐切片工作,从而存在于MappingIndex中.(3)在查询时,由于各映射表在查询之前都进行了切片对齐工作,如要返回多个属性,直接根据切片进行选择以后的连串即为结果;(4)在查询时,如果要根据多个条件进行查询,可以在连串中依次进行过滤,而不需要进行其它分支的查找.综上所述,本算法是正确而完备的.3.3映射表索引算法执行结果对于表3中建立的索引,一种可能的查询序列为A>2,A>6索引切片序列为2、6,结果如表4所示,MappingColumn中的pivots也变为2、6,此时的缓存中,可以很方便地返回AB的值,而无需进行多分支查找.在访问到AC的数据时,会按需建立AC的映射关系,适应了多租户数据模式差异及工作流程差异的需求.TenantIDTableIDColumnIDPivots001002TenantIDTableIDMappingIDColumn1Column2CurrentPivot001RM01AB6TenantIDMappingIDColumn1Column2001M01001M01001M01001M01TenantIDMappingIDColumn1Column2001M01001M01001M01001M01Page74实验结果与分析本文建立了采用键值对共享模式存储的原型系统来验证映射表索引机制.本文中基于关系数据库,封装了一层元数据驱动的数据引擎,实现SQL重写和映射表索引的维护工作.本文的实验环境如下:数据库服务器:HP服务器,CPU为4×2.26,应用服务器:联想,CPU为2×2.26,内存为客户机:联想,CPU为2×2.26,内存为2GB,内存为4GB,硬盘为500GB.8GB,硬盘为500GB.硬盘为100GB.为了更好地对比商业数据库和实验室系统的区别,本文基于ORACLE和MYSQL分别做了实验.数据库版本ORACLE10.2.1.1(图1~图6),MYSQL5.1.47(图7).视图层每个关系模式具有50个属性,且指定其第一个属性为索引属性.录,DataTable上有主码索引.DataTable中每个租户平均拥有90000条记本文从以下几个方面作了实验验证:(1)固定并发租户数目,比较无映射表方式、映射表索引方式的修改、修改后查询的性能.(a)由100个租户共同发起insert和delete,每个租户发起100次修改,参数均匀变换,以保证能均匀地访问各切片.例句如下:insertintoR(A,B,C)Values(4.5,30);insertintoR(A,B,C)Values(1800.200,1500);insertintoR(A,B,C)Values(2500.100,500).实验效果(图3)表明按需更新和即时更新比普通更新的情况要稍微差一些,但按需更新比即时更新要好,这是符合实验情况的,并且也是可以接受的.即时更新索引方式和按需更新索引方式,除了更新数据还要更新映射表,在原有代价基础上,增加了映射表索引的维护代价,分别是100ms和50ms左右.而在普通更新的方式下,无需维护映射表索引,也就没有额外的维护代价,因此维护代价仅包含插入数据的时间及建立主码的时间,一般是25ms左右.相应在图4中,能清晰地看出其查询代价一般在80ms左右.在应用中的读操作通常远远大于写操作,因此本文认为在此耗费的代价是可以接受的.(b)由100个租户共同发起查询,每个租户发起100次查询,查询参数在业务数据的最小值和最大值之间均匀变换,比较更新后对查询的影响.实验效果(图4)表明在查询时按需更新索引方式和即时更新索引方式都要优于普通索引方式,按需方式与即时方式差别不是很大.普通查询则因为无法实现隔离的问题,查询代价远高于本文所提出的算法.按需方式间断出现的几个较高代价是因为索引合并.索引缓冲区中的数据在被访问的时候,要合并到索引切片中,这需要一些额外代价,即时更新方式是在维护数据的时候同步进行的(参见图3).从实验方案及效果来分析,这正好体现了索引缓冲的优势,它把每次更新操作转化成批量操作,降低了维护代价.根据以上实验,可以看出使用映射表索引方式可以提供较好的性能,为了更好地判定租户数目对本维护策略的影响,本文模拟了并发租户数量变化的情况.(2)固定按需更新映射表方式,比较不同数量的租户并发执行的性能.由不同数量的租户并行各种业务,每个租户发起100次查询和修改,查询参数在业务数据的最小值和最大值之间均匀变换,更新参数任意均匀变化.查询和更新交替执行.图5和图6分别为ORACLE和MYSQL的实Page8验效果,总体趋势一致,在性能上稍有差异,此差异是由于访问参数随机分布造成的,与数据库及数据引擎没有关系.实验效果表明:(1)本方案和基于的数据库没有关系,具有较好的迁移性.这是因为本方案并没有直接在数据库中建立映射表,而是建立在缓存中,不依赖于数据库本身的能力.(2)多租户数据库所支持的租户数量只受服务器缓存的限制,在缓存允许范围内,租户性能不受并发租户数量影响限制;在超过单机缓存负荷以后,需要寻求集群或者云等新的存储方式.综上所述,本方案所提出的模型,实验效果理想,较好的解决了SaaS应用索引的隔离及定制问题.5总结与展望本文基于键值对模式的多租户数据库存储机制,在ORACLE数据库中引入了映射表来充当索引以及元组重构的基础,同时提出了映射表的维护策略来降低映射表的维护代价,能有效地提高访问性能.本文根据租户信息创建共享模式的映射表索引,然后根据各自的数据访问请求,由数据引擎筛选索引切片,渐进式地对索引进行更新,获取较高的性能.本文论证了该索引方式的正确性、完备性、存储需求、维护代价及可获取的性能的提高,并以实验证明了本文思想的正确性.在实验中,本文从租户角度、查询次数、数据量等多方面对比了各种方案的查询及维护代价,可以看出本方案具有较好的使用效果.映射表索引还有尚未解决的问题,比如随租户、索引个数、属性数目增长的空间需求,对于索引查准率和查全率更严格的论证,数据引擎和关系数据库的中间交互环节的进一步优化,还有很多的研究工作要做.在今后的研究中,将做以下几个方面的工作:(1)进一步论证映射表索引的查准率和查全率;(2)研究通过索引进行关系重构的问题;(3)研究关系中属性较多时候的索引引用技术以进一步提高索引性能.
