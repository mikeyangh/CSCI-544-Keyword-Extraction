Page1基于串空间的可信计算协议分析1)(中国科学院软件研究所可信计算与信息保障实验室北京100190)冯伟1),2)冯登国1)2)(中国科学院大学北京100190)摘要可信计算技术能为终端、网络以及云计算平台等环境提供安全支撑,其本身的安全机制或者协议应该得到严格的形式化证明.该文基于串空间模型对其远程证明协议进行了分析.首先,扩展了串空间的消息代数和攻击者串,使其能表达可信计算相关的密码学操作,并对衍生的定理进行了证明;并且提出了4个新的认证测试准则,能对协议中的加密、签名、身份生成和哈希等组件进行推理.其次,基于扩展的串空间模型对远程证明协议的安全属性(隐私性、机密性和认证性)进行了抽象和分析.最后,给出了对发现攻击的消息流程,并基于ARM开发板对其中的布谷鸟攻击进行了实现,验证了串空间的分析结果.关键词可信计算;远程证明;串空间;认证测试;形式化验证1引言随着信息化技术的发展,网络变成了人们生活Page2据的分发与共享(如ftp资源);云计算环境通过网络能为用户提供各种安全服务,如云存储和云租用平台等.这些安全操作通常涉及对敏感数据的处理,如用户的支付账号和密码,公司的机密文档和云隐私数据等.但是,由于网络环境的开放性和复杂性,使得其容易变成攻击者的目标:通过远程注入恶意软件,攻击者可以在网上交易时截获用户的支付账号和密码;恶意的终端可能连接公司内部网络,获取机密信息;客户存储在云中的数据可能面临机密性和完整性等威胁.如果在安全操作执行之前,网络中的各个实体能相互验证平台身份和平台软件配置等信息,能有效防止攻击的发生.可信计算技术提出的可信平台模块TPM(TrustedPlatformModule)[1]和远程证明协议①,能为网络实体提供基于硬件的可信证据,保证只有拥有合法身份并运行着预期软件的实体才能通过验证.因此,远程证明协议可以用于构建安全支付、可信网络接入[2]和可信云服务[3]等安全系统,防止机密信息和数据的泄露.安全支付中,远程证明协议可以向金融机构证明用户终端的软件配置,防止恶意软件截获支付信息;可信网络接入[2]系统通过远程证明协议验证接入的终端设备,只允许合法的终端连接网络,可以有效保护内部网络资源;在可信云服务[3]系统中,客户在上传数据之前,先使用远程证明协议验证云节点的身份和完整性状态,可以保证数据只存储在可信的云节点中.由此可见,远程证明协议的应用很广泛,并对很多系统的安全性起关键作用.但是,目前远程证明协议并没有得到严格的形式化证明.如果协议本身存在安全隐患,将会严重威胁依赖该协议的安全系统.Coker在文献[4]中指出了远程证明协议在灵活性方面的不足,提出了5条认证准则,并依此设计了一个灵活的认证体系;在文献[5]中进一步基于提出的认证体系设计了一个新的远程证明协议,称为CAVES协议.文献[6]对CAVES协议进行了形式化分析,基于串空间CPSA自动化工具[7-8]证明了协议的安全性.但是,CAVES协议及其分析存在如下几个问题:(1)没有考虑远程证明协议的平台身份密钥建立过程以及可信平台证书的关联性,遗漏了对隐私性的分析;(2)没有将安全芯片TPM独立成一个角色进行分析,容易忽视针对TPM本身的攻击;(3)CPSA工具无法对远程证明协议依赖的一些TPM命令进行分析,如TPM_Makeidentity身份密钥生成、TPM_Extend完整性扩展和TPM_Quote引证等操作.针对上述问题,本文对安全芯片和证明者进行了区分,总结了一个完整的远程证明协议,包含平台身份密钥建立和平台证明两个过程;并对串空间理论和认证测试方法进行了扩展,使得其能描述安全芯片及其命令.本文的具体贡献如下:(1)根据可信计算规范,本文对远程证明协议进行了完整的总结,通过消息流的形式给出了协议交互流程,方便对协议进行分析;并根据对TPM命令接口[1]的理解,用密码原语对协议中的TPM命令进行了抽象描述.(2)对串空间的消息代数和攻击者能力进行了扩展,证明了扩展模型范式引理的正确性,并基于扩展模型给出了远程证明协议的串空间定义;提出了4个认证测试准则,能对远程证明协议中的加密、签名、身份生成和哈希等组件进行推理分析.(3)根据串空间扩展模型对远程证明协议的安全属性进行了定义,并基于认证测试准则逐一分析了这些安全属性;通过分析发现了一些攻击,并针对攻击提出了改进方法;最后基于扩展模型给出了对改进方法的正确性说明.(4)对发现的攻击进行了详细的描述,并基于ARM开发板对其中的布谷鸟攻击进行了实现,从实验上验证了串空间的分析结果.本文第2节给出可信计算和串空间方面的背景知识以及相关研究成果;第3节对远程证明协议进行总结,抽象协议交互流程,并提炼安全目标;第4节针对远程证明协议,给出扩展的串空间理论和新的认证测试方法,使得串空间模型能描述安全芯片的密码学操作;第5节基于扩展的串空间模型对远程证明协议进行分析;第6节详细描述发现的攻击,并给出攻击实验.2背景和相关工作2.1可信计算可信计算技术[9]通过在计算平台引入硬件安全芯片来保证计算机甚至网络环境的可信.这种可信是指计算机平台拥有合法的身份,并按照预期的软件配置执行.国际上,安全芯片以满足TCG(TrustedComputingGroup)规范的可信平台模块TPM[1]为①TCGspecificationarchitectureoverview,revision1.4,Page3主,目前该规范已经升级到TPM2.0①.国内安全芯片以满足国家密码管理局规范的可信密码模块TCM②(TrustedCryptographyModule)为主,其采用我国自主知识产权的密码算法(如SM2、SM3、SMS4等),并使用兼容我国公钥基础设施的双证书体系.远程证明协议是可信计算的核心技术之一,其主要作用是允许计算机平台创建关于其身份和完整性状态的报告,该报告基于安全芯片生成,能被远程方所信赖.平台身份由安全芯片保护的密钥提供,而完整性状态指对所有可执行程序或者软件进行密码操作后的度量值.远程证明协议又称为完整性报告(IntegrityReporting)协议,TCG规则中流程主要侧重平台完整性的报告,而忽视了平台身份密钥AIK(AttestationIdentityKey)的生成.不过,文献[10]的图2和文献[11]的图5分别给出了平台身份密钥AIK的创建流程和具体TPM命令调用情况.本文依据这些文献,对远程证明协议的完整流程和密码细节进行了总结.可信计算的形式化分析是一种重要技术.一般形式化方法由于缺少对TPM相关命令的描述而难以用于分析可信计算的协议.文献[5-6]使用串空间CPSA分析工具对远程证明协议进行了研究,设计并证明了一个新的CAVES协议.不过该研究缺少对平台身份密钥建立的分析,也没有对安全芯片单独进行建模;因此,其分析结果不能全面阐述远程证明协议的安全性.本文通过扩展CPSA工具依赖的串空间理论和认证测试准则,对可信计算远程证明协议进行了全面的分析.文献[12]提出了一个形式化基础和框架,能对可信平台进行模型检测分析,发现了可信平台的一些逻辑缺陷.Chen等人[13]为TPM2.0设计并实现了新的数字签名方法,并在SDH假设和随机预言机模型下证明了TPM签名原语的安全性.Kremer和Kunnemann[14]提出了新的形式化分析工具,能处理协议中的非单调全局状态,适合对TPM的API和PCR寄存器进行分析.文献[15]首次提出了可以处理Diffie-Hellman幂运算、双线性映射和AC-运算符的符号分析算法,并基于tamarin进行了实现,该方法有助于分析可信计算的直接匿名认证协议.2.2串空间串空间模型建立在Dolev-Yao基础[16]之上,该模型假定密码系统本身是完好的,攻击者无法进行密码分析,不过攻击者可以完全控制网络,甚至能使用自己的身份参与到协议会话中.串空间的发展大致经历了3个阶段:串空间理论[17]、认证测试方法[18-20]和自动化分析工具CPSA[7-8].串空间理论是纯手工推理,对于一个简单协议(如NS协议)的分析,其推理和证明过程都比较复杂,容易出错;认证测试方法提炼出了一些高级测试准则,能直接针对协议的消息组件推理认证属性,并且对所有协议是通用的,简化了手工推理的复杂性,降低了分析的难度;CPSA工具进一步基于认证测试方法给出了对协议的自动推理,能以图的方式输出协议所有可能的执行流程,安全属性需要根据所有输出的图进行分析判断,因此,CPSA实际上是一个半自动化工具,不过其避开了复杂的串空间理论,分析者容易上手,而且也提高了协议分析的效率.串空间通过图的方式,能比较直观的描述协议的执行或者攻击流程,已经被成功用于分析CAVES认证协议[5-6]、TLS安全通道[21-23]和IKE密钥交换[24]等.文献[21]中Kamil为了分析TLS协议对串空间进行了扩展,其扩展方法为本文的扩展研究提供了参考思路.由于串空间的消息代数、攻击者串和认证测试方法描述能力有限,在分析一些复杂协议时可能遇到障碍,文献[21]和本文的方法提供了一种通用的扩展思路,能增强串空间的描述能力,使其能用于对更多协议进行形式化分析.Guttman[25]对串空间模型进行了扩展,使得其能分析公平交换协议.Ramsdell[26]在CPSA工具的基础上提出了形状分析语句,能够提取一阶逻辑中的语句来描绘CPSA的运行,并通过逻辑推理的方式来确定协议的安全目标.串空间的协议主体维护的本地状态在各个协议会话中是独立的,在处理跨会话的状态时会遇到困难,于是Ramsdell等人[27]提出了一种混合分析方法,使用定理证明来推理基于状态的计算,并使用CPSA来处理消息传递部分.基于该混合分析方法,Ramsdell对使用TPMAPI访问PCR寄存器的情况进行了建模分析.Guttman在文献[28]中基于串空间理论提出了新的标号转换系统分析方法.3可信计算远程证明协议简介完整的远程证明协议RA(RemoteAttestation)①library_specification②Page4分为两个阶段:平台身份密钥建立[10-11]和平台证明过程[1,5].前者基于PrivacyCA[10]产生一个平台身份密钥,在认证平台身份的同时保护用户的隐私;后者基于平台身份密钥向远程方证明平台的软件状态.本节首先对这两个阶段进行总结,最后给出协议的安全目标.3.1平台身份密钥建立安全芯片TPM[1]使用背书密钥EK(Endorse-mentKey)作为其唯一标识,其私钥长期保存在TPM芯片内部(不会泄露),公钥由芯片厂商签名生成EK证书.由于EK可以唯一标识一个TPM及其所在的硬件平台,通常无法作为平台身份使用;否则,会泄露平台隐私.因此,TCG使用安全芯片生成的身份密钥AIK代替EK作为平台身份.为了证明AIK属于一个合法的TPM芯片,同时不泄露具体是哪个TPM,TCG规定采用可信第3方Privacy-CA来认证AIK并生成AIK证书.通过AIK证书,只有PrivacyCA能确定TPM所在的硬件平台,而其他验证者无法追踪到该平台,因此平台隐私得到保护.平台身份密钥AIK的建立过程见消息1~6.具体包含3个主要的角色:安全芯片TPM/TCM(T),用户进程(U)和可信第3方PrivacyCA(PCA):消息1.U→T:L,PCA消息2.T→U:AIK,I消息3.U→PCA:Cert_EK,AIK,L,PCA,I消息4.PCA→U:{Cert_AIK}EK消息5.U→T:{Cert_AIK}EK消息6.T→U:Cert_AIK消息1和2:用户选取1个身份标签L和指定可信第3方PCA,通过调用TPM_MakeIdentity命令[24],由TPM芯片生成1个新鲜的AIK密钥对,将私钥AIK-1加密保存在TPM内部,而将公钥AIK和TPM生成的身份内容I返回给用户.注意,L只是1个标签,由用户自由选取,可以用于查找AIK证书,而无法作为安全芯片或者用户的唯一标识名称使用.我们使用如下函数来表示身份内容I的生成:该函数通过安全芯片T的AIK-1对AIK,L和PCA进行签名,表示这些数据与该安全芯片T关联(这里SK(T)=AIK-1).消息3和4:用户进程将公钥AIK以及签名的身份内容I,连同EK证书一起发送给可信第3方PCA.PCA验证EK证书的有效性后,用其私钥SK(PCA)对AIK公钥进行签名生成AIK证书.PCA使用EK加密保护AIK证书,将加密包返回给用户.规范中,PCA会生成一个临时对称密钥K来加密保护AIK证书,而使用EK加密K,从安全角度而言,与直接使用EK加密AIK证书一样.为了方便分析,本文省去K,采取简化的形式.我们使用[p,PK(p),v]SK(v)来表示一个证书,p是证书拥有者,PK(p)是p的公钥,v是签发者,SK(v)是v的私钥.因此,EK证书和AIK证书可以分别表示如下(MF表示生产安全芯片T的厂商):如果攻击者拥有相应的私钥,也可以产生伪造的证书,因此具体分析时,采用如下形式来描述证书:基于一些假设(如v可信且k=SK(v)是安全密钥),需要证明kp=PK(p).消息5和6:用户进程将EK生成的加密包发送给安全芯片T,并通过TPM_ActivateIdentity命令来激活T内部的新身份密钥AIK,同时使用T内部的EK私钥解密获得相应的AIK证书.3.2平台证明过程平台证明过程主要是向远程方证明本地平台的身份和完整性状态.身份由AIK表示,完整性状态由安全芯片的平台配置寄存器PCR(PlatformCon-figurationRegister)保证.通过TPM_Quote命令[1],AIK可以对PCR进行签名,签名的结果可以作为远程方依赖的证据.平台证明过程包含3个主要角色:安全芯片TPM/TCM(T),用户进程Attester(U)和远程验证者Verifier(V).具体协议流程如下:消息7.V→U:NV消息8.U→T:NV消息9.T→U:Q消息10.U→V:Q,ML,Cert_AIK首先,远程验证方V产生一个新鲜的随机挑战值NV,向本地证明者U请求可信证据(消息7).U将随机值转发给安全芯片T(消息8).然后T使用TPM_Quote命令对PCR值和NV进行签名,并将签名结果Q返回给用户进程U(消息9).最后U将Q、AIK证书和度量日志ML一起发送给V(消息10).V通过验证这些值,可以确定U所在平台的可信状态:AIK确定平台是否拥有合法的安全芯片;度量日志ML确定平台是否运行预期的软件;Q关Page5联AIK和ML,并保证ML的完整性.度量日志ML记录了用户计算平台的所有可执行程序及其度量值(程序二进制代码的哈希值).PCR是这些度量值的一个哈希聚集值,采用哈希链(HashChain)的方式生成,即m是一个新的度量值,PCR_Old是旧的PCR值,而PCR_New是扩展(通过TPM_Extend命令)m后的新PCR值.PCR的主要目的是保证ML的完整性.我们采用如下两个函数来表示Q的生成:HashChain是度量日志ML的一个完整性标识,拥有密码哈希函数的属性,为了简化,具体分析时将HashChain作为一个哈希函数处理.Q是一个基于T内部AIK私钥的数字签名.3.3安全目标根据远程证明协议的相关工作[4-5,10]以及其在安全系统(安全支付、可信网络接入和可信云服务等)中的应用,本文总结了如下5个安全目标:(1)隐私性.平台证明过程中,验证者可以确定一个合法的TPM芯片,但是无法确定具体是哪个TPM芯片.简单的说,Cert_EK只能提供给可信第3方PrivacyCA,而其他方需要的身份认证性由Cert_AIK提供;Cert_EK会泄露具体的TPM芯片,而Cert_AIK不会.(2)PrivacyCA认证性.作为可信第3方的PrivacyCA能够验证具体TPM芯片的身份合法性(基于Cert_EK),只有确定其合法后才会给其签发AIK证书(Cert_AIK).(3)Verifier认证性.平台证明过程中,验证者Verifier能确定一个合法的证明者平台(包含安全芯片T以及用户进程U),能同时验证平台的完整性状态.(4)ML的机密性.度量日志ML记录了证明者平台的所有软件配置,通常会包含该平台的一些敏感信息,不能泄露.(5)用户的认证性.用户能确保其与一个合法的验证者Verifier交互,而不是在与一些恶意方交互,防止平台的可信数据被恶意攻击者获取.4串空间扩展模型本节主要给出串空间理论[17]以及我们为了描述远程证明协议所作的一些扩展.同时,对扩展模型中衍生的一些定理和准则进行了证明.4.1串空间基础4.1.1消息代数设A是协议执行中所有消息的集合,A中的元素称为消息项(term).原始串空间理论[17]定义了两类原子消息项:一类是明文消息项(如参与者标识、随机数等),构成集合M;另一类是密钥消息项(如对称密钥、加密密钥等),构成集合K.为了描述远程证明协议的安全芯片,我们增加了一个集合X,表示所有安全芯片的集合.原始串空间[17]在消息集A上定义了两个二元运算(加密运算encr与级联运算join)、一个一元运算(密钥求逆inv).可信计算安全芯片对密钥有严格的分类,如EK只能用于加密,而AIK只能用于签名.因此,我们将K划分为3个不相交子集:加密密钥Kenc、签名密钥Ksig和对称密钥Ksym.为了描述普通签名消息,增加了一个二元运算sig.为了描述身份消息,增加了一个二元运算mid.为了描述PCR值,增加一个hash运算.扩展的消息集合和运算定义如下.定义1.消息集合A中的原子消息项是M,K和X中的元素(其中M,K和X两两互斥);复合消息项由如下运算生成:加密encr:Kenc×A→A;签名sig:Ksig×A→A;级联join:A×A→A;身份生成mid:X×A→A;哈希hash:H×A→A(其中H是所有哈希函数的集合).根据习惯,记encr(k,m)为{m}k,记sig(k,m)为[m]k,记join(a,b)为a‖b,记mid(T,m)为[m]T,记hash(h,m)为h(m).密钥的逆由inv:K→K进行定义,记inv(k)=k-1.如果k∈Ksym,则k=k-1.对于主体名称a∈M,PK(a)和SK(a)分别表示主体a的公钥和私钥.如果一个非对称加密密钥k∈K由安全芯片T∈X生成,则私钥记为k=SKenc(T),公钥记为k-1=PKenc(T).同理T中有非对称签名密钥SKsig(T)和验证密钥PKsig(T).SKenc(T)和SKsig(T)处于安全芯片T的硬件保护,永不泄露,统一记为SK(T).注意,一般主体a并不区分签名密钥和加密密钥,而安全芯片T对密钥类型有严格的限制.本文针对远程证明协议的变量约定如下:T∈X;U,V,PCA,MF,L,ML,NV∈M;AIK,AIK-1∈Ksig;EK,EK-1∈Kenc.如果AIK和EK属于某个安全芯片T,则AIK=PKsig(T),AIK-1=SKsig(T),Page6EK=PKenc(T),EK-1=SKenc(T).消息项之间存在子项关系(),定义如下.定义2.子项关系递归定义如下:aa;若ab,则a{b}k,a[b]k,a[b]T;若ab或者ac,则ab‖c.这里a,b,c∈A,k∈K,T∈X.如果ab且a≠b,则称a为b的真子项.注意,子项关系的意义为:给定一些密钥和安全芯片的知识集合,消息项m的子项可以很容易从m中提取出来.显然,h(a)中的a以及{b}k,[b]k,[b]T中的k和T并不属于子项,这是由完美密码系统(Dolev-Yao假设)的安全性质决定的,如哈希是不可逆的,密文不会泄露密钥信息等.定义3.如果ab,且a不是一个级联项(g‖h的形式),那么称a为b的一个组件,b由a与任意的消息项级联而成.因此,组件可以是一个原子项,加密项,哈希项,签名项或者身份项.组件可以将一个非级联形式的消息项与协议的某个执行主体进行关联.如只有拥有签名私钥的主体才能产生某个签名项,只有拥有加密私钥的主体才能解密某个加密项等.组件是串空间认证测试方法[18-20]提出的一个非常重要的概念.4.1.2串、串空间和丛协议参与者可以发送消息项,也可以接受消息项.在串空间中,使用正号表示发送,负号表示接受.串(strand)是指协议参与者发送和接受消息项的一个序列.串空间(strandspace)是所有串的集合.定义4.〈σ,a〉是一个带符号项,其中σ∈{+,-},a∈A.一个带符号项记为+a或者-a.(±A)是所有带符号项的有限序列集合,其一个典型的元素可以记为〈〈σ1,a1〉,…,〈σn,an〉〉.A上的一个串空间是一个集合Σ,该集合具有一个轨迹映射tr:Σ→(±A).对一个固定的串空间Σ,满足如下性质:(1)节点(node)n是〈s,i〉,其中s∈Σ,i是一个整数,满足1ilength(tr(s)).节点的集合为N,每个节点n=〈s,i〉属于唯一一个串s.(2)如果节点n=〈s,i〉∈N,那么index(n)=i,strand(n)=s,term(n)=(tr(s))i,即串s中的第i个带符号消息项.(3)如果n1,n2∈N,则n1→n2表示term(n1)=+a,term(n2)=-a,即n1发送一个消息a到n2,给出了串的因果关系.(4)如果n1,n2∈N,则n1n2表示n1和n2出现在同一个串中,且index(n2)=index(n1)+1,即n2是n1的直接后继,n1是n2的直接前驱.n1+n2表示n1是n2的前驱(不一定是直接前驱),可以经过一个或者多个边到达n2.(5)一个无符号项t发生在n∈N中,当且仅当tterm(n),即t是节点n的消息项的子项.(6)设I是无符号项的集合,节点n1∈N是I的入口点,当且仅当对于某个t∈I,term(n1)=+t并且对于任意n2+n1,term(n2)I.(7)一个无符号项t源于一个节点n,当且仅当n是集合I={t0|tt0}的入口点.(8)一个无符号项t唯一源于一个节点集合SN,当且仅当存在唯一的节点n∈S满足t源于n.通常一个唯一源于节点的消息项可以表示一个随机数nonce或者会话密钥.(9)一个无符号项t非源于一个节点集合SN,当且仅当不存在节点n∈S满足t源于n.通常长期安全密钥都是非源于的.(10)如果消息项t是term(n)的一个组件,并且对于每个n0+n,t不是term(n0)的组件,那么称t是节点n的一个新组件.基于串和串空间的概念,下面给出远程证明协议正规参与者串的定义.基于第2节的描述,协议主要有4个参与者角色T,U,V和PCA,同时增加1个厂商角色MF来生成EK证书.记EK证书为cert(EK)=[T‖EK‖MF]SK(MF),AIK证书为cert(AIK)=[L‖AIK‖PCA]SK(PCA),安全芯片T生成的身份为I=[AIK‖L‖PCA]T,安全芯片生成的Quote签名为Q=[h(ML)‖NV]inv(AIK).注意,这里I和Q的表示不一致,因为I的生成需要安全芯片内部EK的参与,只能由安全芯片T进行;而Q的签名可能由软件生成(基于伪造的密钥),不一定在T内部进行.定义5.设TPM[T,U,V,PCA,MF,L,AIK,EK,ML,NV]是安全芯片串的集合,其轨迹(trace)为〈-L‖PCA,+AIK‖I,-{cert(AIK)}EK,+cert(AIK),-NV,+Q〉.定义6.设User[T,U,V,PCA,MF,L,AIK,EK,ML,NV]是用户进程串的集合,其轨迹(trace)为〈+L‖PCA,-AIK‖I,+L‖PCA‖AIK‖I‖cert(EK),-{cert(AIK)}EK,+{cert(AIK)}EK,-cert(AIK),-NV,+NV,-Q,+ML‖cert(AIK)‖Q〉.定义7.设Verifier[T,U,V,PCA,L,AIK,ML,NV]是远程验证者串的集合,其轨迹为〈+NV,-ML‖cert(AIK)‖Q〉.定义8.设PrivacyCA[T,PCA,MF,L,AIK,Page7EK]是隐私证书权威串的集合,其轨迹为〈-L‖PCA‖AIK‖I‖cert(EK),+{cert(AIK)}EK〉.定义9.设Manufacturer[MF,T,EK]是安全芯片厂商串的集合,其轨迹为〈+cert(EK)〉.为了简化分析过程,假定在远程证明协议之前,厂商颁发的EK证书已经被用户进程和PrivacyCA得到.同时,使用星号()作为串参数的通配符,如TPM[T,U,V,PCA,MF,L,AIK,,,NV]表示EK和ML可以取任意值.结点集合N和边n1→n2及n1n2的集合构成一个有向图〈N,(→∪)〉.一个丛(bundle)通常定义为〈N,(→∪)〉的一个子图,丛表示协议的一个可能执行,其边解释了节点之间消息项的因果关系.下面根据原始串空间的描述给出关于丛的定义和定理,定理的正确性可以参考Thayer[17].定义10.1个丛C=〈NC,(→C∪C)〉是〈N,(→∪)〉的子图,其中→C→,C.丛C满足下列性质:(1)C是一个非空的有限无环图;(2)如果n1∈NC,且term(n1)是负号,则存在唯一的n2满足n2→n1是C中一条边;(3)如果n1∈NC,n2n1,则n2Cn1.例如,图1给出了可信计算远程证明协议正常执行一次的丛.定义11.1个节点n∈NC,那么称该节点在丛C=〈NC,(→C∪C)〉中,记为n∈C.对于1个串s,满足〈s,i〉∈C的最大正整数i称为串s在C的丛高(C-height).定义12.如果C是一个丛,定义关系C=(→C∪C),其表示节点之间的因果关系.定理1.对于一个丛C,关系C是一个偏序关系,即满足自反、反对称和传递性质.丛C中节点的每个非空子集都存在C-最小元.4.1.3攻击者能力串空间基于Dolev-Yao模型[16],攻击者能力由其初始知识(初始密钥集合KP以及其他初始原子消息集合MP),和攻击者能执行的动作(称为攻击者串)来决定.本文对串空间的消息代数进行了扩展,对攻击者能力也进行了相应的扩展.主要增加了与签名、身份生成和哈希相关的攻击者串,即定义13的SI,VE,MI和H串.定义13.攻击者串的轨迹可以是如下的形式之一:(1)M.散发明文消息:〈+m〉,m∈MP.(2)K.散发密钥:〈+k〉,k∈KP.(3)C.级联消息:〈-g,-m,+g‖m〉.(4)S.拆分消息:〈-g‖m,+g,+m〉.(5)E.加密消息:〈-k,-m,+{m}k〉,k∈Kenc.(6)D.解密消息:〈-k-1,-{m}k,+m〉,k∈Kenc.(7)SI.签名消息:〈-k,-m,+[m]k〉,k∈Ksig.(8)VE.验证消息:〈-k-1,-[m]k,+m〉,(9)MI.身份生成:〈-T,-m,+[m]T〉,T∈X.(10)H.哈希:〈-m,+h(m)〉,h∈H.我们假定只有安全芯片才能生成平台身份信息,不过,任何攻击者只要能控制一个安全芯片,其也能生成平台身份信息,因此增加了攻击者MI串.读取安全芯片PCR值不需要任何授权,Quote签名只要拥有私钥就可以进行,因此增加了SI串描述攻击者伪造签名或者证书的能力.只要能获取平台度量日志ML,攻击者也能生成其完整性标识h(ML),因此增加了攻击者H串.如果1个节点位于攻击者串,则称其为攻击者节点;否则,称为正规节点.通常一个渗透的串空间既包含正规串(所有合法参与者的串),也包含这里定义的攻击者串.4.2范式引理攻击者行为可以通过攻击者串的任意组合来实现.不过,这会导致很多冗余的丛,使得协议的分析变得复杂.在认证测试方法中,Guttman等人[18-19]提出了丛等价和范式引理来限制攻击者串的组合顺序,可以在不消弱攻击者能力的情况下,删除攻击者的一些冗余行为.由于我们对攻击者串进行了扩展,k∈Ksig.Page8引入了新的冗余情况,本节主要给出冗余消除方法以及证明扩展后的范式引理依然成立.定义14.串空间Σ中的两个丛C1和C2等价,当且仅当它们拥有相同的正规节点.定义15.丛中包含4种类型的冗余:E-D冗余和C-S冗余(参考认证测试[18-19]);SI-VE冗余和MI-VE冗余(如图2所示).定理2.每个丛C1都存在一个没有任何冗余的等价丛C2.证明.关于E-D冗余和C-S冗余的消除方法见参考文献[19].而关于SI-VE冗余和MI-VE冗余的消除如图3所示.通过删除冗余中的攻击者串VE,并增加相应的边(虚线箭头表示),删除冗余后,正规节点没有变化,而且新生成的图满足丛的定义(定义10).因此,根据定义14,删除冗余生成的丛与原始丛等价.攻击者的行为在认证测试中通过一条路径(path)来描述.一条攻击者路径中,除了首尾节点,所有其他节点都是攻击者节点.为了限制攻击者路径的形式,使用构造边(constructiveedge)和析构边(destructiveedge)的概念来对攻击者串进行分类.由于引入了新的攻击者串,我们对构造边和析构边进行了重新定义.定义16.如果一个+边是E,C,SI,MI或者H串的一部分,称其为构造边;如果其是D,S或者VE串的一部分,称其为析构边.如果1个攻击者节点是K或者M节点,称该节点为初始节点(initial).定义17.如果对于丛C中的每条攻击者路径,每个析构边都领先于(precede)每个构造边,则称该丛是正常丛(normalbundle).定理3.攻击者范式引理.每个丛C1都存在1个等价的正常丛C2.证明.没有SI,MI,VE和H串的范式引理在文献[19]中已经得到证明.我们主要考虑扩展的攻击者串的影响.由于哈希函数的不可逆特性,H串的输出无法传给一个析构边.而对于SI串,其输出只能传给D串或者VE串,但是由于Ksig和Kenc是不相交的,D串无法处理签名的形式,故SI串的输出只能传给VE串.MI串中,SKsig(T)是签名密钥,故其输出也只能传给VE串.而对于VE串,其只接受签名类型的密钥和消息,故其输入无法由E,C和H串提供.因此,新增加的攻击者串除了4个冗余外,没有引入新的构造边立即领先于析构边的情形.而根据定理2,4个冗余消除后可产生等价丛.证毕.4.3认证测试方法本节介绍的技术可以用于证明协议的机密性和认证性.首先定义安全消息,然后提出4个认证测试准则.由于对串空间模型进行了扩展,本节的定义和准则与原始串空间不同.4.3.1安全消息在扩展的串空间模型中,1个密钥是安全的应该至少满足如下3点:首先,该密钥不能在攻击者的初始知识集合中;其次,协议消息交互时只会出现在加密的形式或者哈希的形式中;最后,如果其存储在安全芯片中,且不会在安全芯片外部使用,那么该密钥是安全的.下面采用递归的方式定义安全密钥.定义18.安全密钥.设S0是满足如下条件的密钥k的集合:(1)kKP∪MP或者k∈{SK(T)|T∈X};(2)不存在正号正规节点n∈Σ和消息项t,满足t是n的一个新组件且kt.设Si+1是满足如下条件密钥k的集合:(1)kKP∪MP或者k∈{SK(T)|T∈X};(2)对于每个正号正规节点n∈Σ及其新组件t,k在t中的发生只能是在加密({…k…}k0,k0-1∈Si)或者哈希(h(…k…))的保护形式中.设S=∪iSi,如果k∈S,那么k在串空间Σ中是安全密钥.定义19.首先安全密钥是安全消息;其次如果消息m在串空间Σ中只发生在安全密钥加密保护的消息项或者哈希项h(m)中,则m也为安全消息.定理4.设C0是一个丛,r是一个原子项,且满足r是一个安全密钥或者安全消息,那么对于所有的等价丛C1,不存在满足term(n)=r的节点n.定理4的证明在文献[21]中已经给出,只需要增加一点,即如果安全密钥或者安全消息r长期存Page9储在安全芯片T中,则显然消息项中不会出现r.通常协议的机密性可以通过证明相关密钥在Si中来获得,对于大部分协议,i=0或者1;或者通过证明相关消息是安全消息(如后面度量日志ML的机密性分析).4.3.2认证测试认证测试是基于串空间理论提炼出来的高级推理准则,该准则使得安全协议的认证性分析变得简单.认证测试[18-20]阐述了丛中推理正规节点和正规串的条件,主要包含传出测试(outgoingtest)和传入测试(incomingtest).安全协议通常通过挑战/响应的方式来获得认证性,认证测试是基于该事实建立的.本节给出并证明扩展的串空间模型的认证测试方法.加密测试.设n0和n1(n0+n1)是丛C的两个节点,a唯一源于节点n0,且a在n0处只发生在其组件t0={h}k,k-1∈Kenc∩S中,同时a在n1处只发生在其一个新组件t1中.那么,一定存在一个正号正规节点m1满足t1源于m1;而且存在一个节点m0满足aterm(m0),且n0Cm0+m1Cn1.该加密测试与传出测试一致,证明过程已经在文献[9]中给出.该测试主要说明只有拥有安全私钥的正规串才能解密a,并生成a的一个新组件.签名测试.设n是丛C的一个负号节点,t=[h]kterm(n)是n的一个新组件且满足k∈Ksig∩S.那么,一定存在一个正规节点mCn满足t源于m.证明.设集合D={n0∈C|tterm(n0)}.显然D是一个非空集合,因为n∈D,由定理1可知,D存在C-最小元,记为m.下面采用反证法,假设m是一个攻击者节点,由tterm(m)可以推出m只能是SI串上的正号节点,其密钥边为k,这显然与k∈S矛盾.因此,m只能是一个正规节点.而且m是D的最小元,由定义4可知t源于m.证毕.身份测试.设n是丛C的一个负号节点,g=[h]Tterm(n)是n的一个新组件且满足T∈X,SKsig(T)∈Ksig∩S.那么,一定存在一个正规节点mCn满足g源于m.证明.身份测试类似签名测试,其证明过程与签名测试类似.不过身份测试主要用来确认一个合法安全芯片T的存在.哈希测试.设n是丛C的一个节点,t=h(g)∈term(n)是其一个新组件,且g是安全消息.则一定存在1个正规节点mCn满足t源于m.证明.设集合D={n0∈C|tterm(n0)}.显然D是一个非空集合,因为n∈D,由定理1可知,D存在C-最小元,记为m.如果m是一个攻击者节点,则只可能发生在H串中,而m是安全消息,攻击者无法生成h(m),否则违背了哈希函数的抗碰撞攻击特性.因此,m只能是一个正规节点.证毕.4.3.3机密性和认证性分析一个正规串表示协议执行中一个合法参与者的本地视图,即该参与者发送和接受消息的所有行为.串空间分析的思路是从一个合法参与者的角度出发,推断其他参与者串和可能的攻击者行为.认证性是推断其他合法参与者已经执行的行为.推断过程依赖4个方面的元素[19]:该合法参与者对应的正规串、协议的规范描述(即所有定义的正规串)、攻击者能力和一些源假设(如唯一源于的随机数和非源于的安全密钥等).丛中定义的因果关系可以用来推理其他串的轨迹.一个典型的认证性定义如下.定义20.认证性.对于所有的丛C和串s0,如果s0在C中的丛高为i,并且一些源假设成立,那么丛C中存在一个丛高为j的正规串s1.机密性是推断攻击者不可能执行的行为(如无法获取某个值),一个典型的机密性定义如下.定义21.机密性.对于所有的丛C和所有正规串s,如果s丛高为i,并且一些源假设成立,那么不存在任何节点n∈C使得term(n)=t.认证性是丛等价下的不变量,因为其只断言一些正规串的存在.如果机密性在所有C的等价丛中成立,那么t值的机密性就成立.根据定理4,t值的机密性主要依赖于证明t∈Si.5远程证明协议分析本节的分析在远程证明RA串空间中进行.RA串空间包含定义5到定义9给出的正规串以及定义13给出的攻击者串.首先给出可信计算远程证明协议安全目标的形式化定义(基于定义20和21);其次,分析远程证明协议依赖的公钥基础设施的正确性;最后,分别从证明者(本地平台的安全芯片与用户进程)和验证者的角度对远程证明协议进行分析.5.1安全属性本节基于扩展的串空间模型对3.3节描述的远程证明协议安全目标进行了形式化定义,如下所示(目标1~目标5):目标1(隐私性).设C是RA串空间Σ中的一个Page10丛,且su∈User[T,U,,PCA,MF,L,AIK,EK,,]是一个正规用户进程串,满足SK(PCA)KP.那么:(1)丛中不存在节点n满足term(n)=EK‖AIK;(2)如果丛中存在节点m满足term(m)={…EK…}k,则k=PK(PCA).目标2(PrivacyCA认证性).设C是RA串空间Σ中的一个丛,sp∈PrivacyCA[T,PCA,MF,L,AIK,EK]是一个丛高至少为1的正规隐私证书权威串,且AIK-1∈{SKsig(T)|T∈X}.那么必定存在唯一的丛高至少为2的正规安全芯片串st∈TPM[T,,,PCA,MF,L,AIK,EK,,].目标3(Verifier认证性).设C是RA串空间Σ中的一个丛,且sv∈Verifier[T,U,V,PCA,L,AIK,ML,NV]是一个丛高至少为2的远程验证者串,NV唯一源于〈sv,1〉且SK(PCA)KP,AIK-1∈{SKsig(T)|T∈X}.那么必定存在唯一的丛高至少为6的正规安全芯片串st∈TPM[T,U,V,PCA,,L,AIK,,ML,NV]和一个丛高至少为10的正规用户进程串su∈User[T,U,V,PCA,,L,AIK,,ML,NV].目标4(ML的机密性).设C是RA串空间Σ中的一个丛,且su∈User[T,U,V,PCA,MF,L,AIK,EK,ML,NV]是一个正规用户进程串,满足SK(V)KP.那么,丛中不存在节点n满足term(n)=ML.目标5(用户的认证性).设C是RA串空间Σ中的一个丛,且su∈User[T,U,V,PCA,MF,L,AIK,EK,ML,NV]是一个丛高大于0的正规用户进程串,满足SK(V)KP.那么,丛中必定存在丛高大于0的正规远程验证者串sv∈Verifier[T,U,V,PCA,L,AIK,ML,NV].下面将分别针对这些目标,对可信计算远程证明协议进行分析.5.2证书分析基于PKI证书,可以建立协议参与主体与其公钥的关联性.EK证书可以将EK公钥与一个唯一的安全芯片T进行关联,在扩展的串空间模型中,可以使用如下定理来描述一个EK证书:定理5.设C是Σ中的一个丛.对于每个节点n∈C和每个EK证书[a‖pk‖b]skterm(n),a∈X,b∈M,那么或者pk=PKenc(a),sk=SK(b)或者sk∈KP成立.证明.一个EK证书[a‖pk‖b]sk可以源于如下两个串:(1)一个正规厂商串Manufacturer[b,a,pk].正规厂商串表示一个合法的厂商角色,其私钥不会泄露,即sk=SK(b)KP,同时厂商可以担保pk和a的关联性,即pk=PKenc(a).(2)一个攻击者SI串.SI串需要攻击者拥有相应的签名私钥,即sk∈KP.AIK证书可以保证AIK公钥来自一个合法的安全芯片,但无法关联具体的安全芯片.通过如下定理来描述一个AIK证书:定理6.设C是Σ中的一个丛.对于每个节点n∈C和每个AIK证书[a‖pk‖b]skterm(n),a,b∈M,那么或者存在一个t∈X满足pk=PKsig(t),sk=SK(b)或者sk∈KP成立.证明.一个AIK证书[a‖pk‖b]sk可以源于如下两个串:(1)一个正规PrivacyCA串PrivacyCA[,b,,a,pk,].Privacy作为一个可信方,可以担保pk来自一个合法的安全芯片,即存在一个t∈X满足pk=PKsig(t).(2)一个攻击者SI串.SI串需要攻击者拥有相应的签名私钥,即sk∈KP.下面从PrivacyCA的角度分析其认证性,即目标2描述的安全属性.目标2分析(PrivacyCA认证性).设节点n=〈sp,1〉.由AIK-1∈{SKsig(T)|T∈X},可知存在安全芯片T0满足AIK-1=SKsig(T0),I=[AIK‖L‖PCA]T0.显然I是节点n的一个新组件,根据“身份测试”准则,一定存在一个正规节点mCn满足I源于m.正规节点m一定位于定义5到定义9规定的正规串中,显然m是某个正规安全芯片串的第2个节点,即存在丛高至少为2的串st∈TPM[T0,,,PCA,MF0,L,AIK,EK0,,].由于AIK由安全芯片唯一生成,即AIK唯一源于安全芯片串,故串st是唯一的.另外,cert(EK)=[T‖EK‖MF]SK(MF)n,安全芯片厂商MF是可信方,故SK(MF)KP.由定理5可知,EK=PKenc(T),PrivacyCA可以确定EK是厂商MF为安全芯片T签发的身份.但是,我们无法确定T=T0是否成立,这样可能会出现攻击者使用其他芯片的EK证书来欺骗PrivacyCA.改进方法:使用I=[EK‖AIK‖L‖PCA]T作为安全芯片生成的身份信息,将EK和AIK进行捆绑认证.改进方法证明:通过I可以确定丛高至少为2的串st∈TPM[T0,,,PCA,MF0,L,AIK,EK,Page11,]的存在(根据身份测试准则),即EK=EK0;而通过cert(EK),可以进一步确定T=T0和MF=MF0,这样目标2成立.5.3从证明者的角度分析从证明者的角度,其主要关心隐私性、ML的机密性和用户的认证性.下面依次分析这3个属性.目标1分析(隐私性).根据定理4,我们只需要证明EK∈Si或者AIK∈Si在串空间Σ中成立,就可以证明丛C不存在满足term(n)=EK‖AIK的节点n.首先,EK是公钥,不满足EK∈S0;其次EK[T‖EK‖MF]SK(MF)发生在节点〈su,3〉中,没有加密或者哈希的保护形式,不符合Si的递归定义(定义18).同理AIK∈Si也不成立.因此,隐私性并不成立.改进方法:在节点〈su,3〉中发送cert(EK)时,改进方法证明.只要K∈S,或者SK(V)∈S成立,根据定义19和定理4,可以确定对于C的所有等价丛C1,ML只出现在安全密钥的加密形式中,不存在满足term(n)=ML的节点n.这样ML的机密性成立.目标5分析(用户的认证性).协议中用户进程串su接收到的唯一与V相关的组件为NV,该组件无法使用任何认证测试准则,即无法确认一个正规远程验证者串sv的存在.改进方法:基于“加密测试”或者“签名测试”准使用公钥PK(PCA)来加密保护cert(EK).改进方法证明.首先丛中不存在节点n满足term(n)=EK;其次,EK只出现在消息{cert(EK)}PK(PCA)中,由于SK(PCA)∈S0,根据定义18,故EK∈S1.这样隐私性才成立.即便EK证书本身是公开的,但攻击者无法将其与一个特定的AIK关联,也就无法破坏隐私性.目标4分析(ML的机密性).根据定义18和定理4,类似隐私性的分析,很容易确定ML的机密性不成立.如果在丛C中增加一个攻击者s串〈-Q‖ML‖cert(AIK),+Q,+ML,+cert(AIK)〉,并增加一个攻击者c串〈-Q,-ML,-cert(AIK),+Q‖ML‖cert(AIK)〉,且没有影响到任何正规节点,显然得到丛C的等价正常丛(定义14和定义17),这样term(〈s,3〉)=ML,破坏了ML的机密性.改进方法:在用户进程U和远程验证者V之间协商一个会话密钥K来加密传送ML,或者直接使用V的公钥来加密传送ML.则,可以设计一个满足用户认证性的消息交互流程.将如图4所示的加密测试或者签名测试加入远程证明协议流程中,可以达到U认证V的目的.需要假设NU唯一的源于U且SK(V)KP.改进方法证明.基于图4(a),测试组件为{Nu}PK(V),使用“加密测试”准则,可以确定(v,1)的存在;基于图4(b),测试组件为[Nu,V]SK(V),使用“签名测试”准则,也可以确定节点(v,1)的存在.另外基于NU的唯一性,可以确定V串的唯一性.完毕.5.4从验证者的角度分析验证者主要关心其认证性,下面对其进行分析.目标3分析(Verifier认证性).设节点n=〈sv,2〉,根据定义7,节点n存在3个新组件:Q,cert(AIK)和h(ML).前两个组件可以使用“签名测试”进行分析,最后一个组件可以使用“哈希测试”进行分析.由AIK-1∈{SKsig(T)|T∈X},即存在某个安全芯片T0满足AIK-1=SKsig(T0),由定义18知AIK-1∈S0.对于新组件Q=[h(ML)‖NV]inv(AIK)term(n),根据“签名测试”,一定存在一个正规节点mCn满足Q源于m,显然m是某个安全芯片串的第6个节点,即存在丛高至少为6的串st∈TPM[T0,U0,V,PCA0,,L0,AIK,,ML,NV].由于AIK唯一的源于安全芯片T0,故串st是唯一的.对于新组件cert(AIK)=[L‖AIK‖PCA]SK(PCA),由于SK(PCA)KP,根据“签名测试”可以知道该组件源于PrivacyCA串,同时根据定理6,存在一个安全芯片T1∈X满足AIK=PKsig(T1).由于AIK∈st,可以确定T1=T0.同时根据cert(AIK)组件,可以确定L=L0,PCA=PCA0.对于新组件h(ML),由于ML的机密性不成立(见目标4分析),“哈希测试”无法保证其来自于一个正规串,攻击者H串可以根据ML伪造h(ML).目前可以确定串st∈TPM[T0,U0,V,PCA,,L,AIK,,ML,NV],但是无法确定T=T0和U=U0是否成立,而且也无法确定正规用户进程串su∈User[T,U,V,PCA,,L,AIK,,ML,NV]的存在.这样可能导致两类攻击的存在:(1)一个没有安全芯片的攻击者平台可以利用可信平台的安全芯Page12片T来欺骗验证者V(攻击丛如图5所示);(2)如果攻击者平台也拥有一个安全芯片T1,攻击者根据ML度量日志先扩展T1的PCR后生成h(ML),这样可以代替其他任意平台完成远程证明(称为布谷鸟攻击[29],其攻击丛如图6所示).改进方法:为了预防攻击(1),可以向远程验证者证明T和U的绑定关系,保证只有U才能使用T,通常可信芯片通过授权会话协议来建立这种关系.而为了避免攻击(2),我们需要向远程方V证明具体的安全芯片T(如使用EK证书),但是这样会破坏隐私性,文献[29]中的解决方法是直接在T和V之间建立安全通道,需要在可信芯片T上增加一个特殊安全接口,但从厂商角度而言这种方法比较不切实际.因此,目前还没有有效的方法在保护隐私性的同时防止布谷鸟攻击.改进方法说明:针对攻击(1)的改进方法依赖可信计算的授权会话协议,其分析需要先证明授权会话协议的安全性,是我们下一步的工作目标.针对攻击(2)的改进方法需要在T和V之间直接建立安全通道.如果是密码安全通道,可以采用串空间先分析该通道的安全性;如果是硬件安全通道,则需要对串空间进行进一步扩展.如何建立安全通道以及证明安全通道的安全性在本文的分析范围之外.完毕.6攻击6.1攻击描述本节根据对每个安全属性的分析结果,给出对应攻击的简单描述.这些攻击可以破坏对应的安全属性.在下面消息交互过程中,以角色P表示攻击者.构建一个可信平台,平台身份密钥建立过程(消息1~6)可以执行多次,生成多个AIK;平台证明过程(消息7~10)可以基于不同AIK,与不同的验证者建立可信关系.攻击1(破坏隐私性).攻击者只要截获消息3和消息10就可以破坏隐私性.对于每个平台的AIK建立过程,攻击者截获消息3,并存储(Cert_EK,AIK)的二元组;当一个平台在消息10进行平台证明时,攻击者截获Cert_AIK,可以查询存储的二元组找到对应的Cert_EK,进而确定具体的安全芯片T.而且,基于存储的(Cert_EK,AIK)二元组,攻击者可以将同一个平台的所有AIK进行关联,进一步破坏其隐私性.文献[5]中协议只分析平台证明过程,忽略了平台密钥建立过程,因此遗漏了该攻击.攻击2(破坏PrivacyCA认证性).攻击者截获消息3的Cert_EK,并随机生成一个AIK可以欺骗PrivacyCA,如对消息3进行修改:消息2.3.a.U→P(PCA):Cert_EK,AIK,L,PCA,I消息2.3.b.P(U)→PCA:Cert_EK,AIKP,LP,PCA,IP消息2.4.PCA→U:{Cert_AIKP}EK该攻击主要是理论上存在风险,实际中就算PrivacyCA生成Cert_AIKP,攻击者也无法解密,因为其没有EK私钥.不过该攻击在实际中可以用于对PrivacyCA进行DoS攻击,让其不断生成AIK证书,消耗其资源.攻击3(欺骗攻击,破坏Verifier认证性).一个没有安全芯片T的攻击者平台利用一个可信平台的消息流来欺骗验证者V,从而获得V的验证,攻击流如下:信息3.7.a.P(V)→U:NP消息3.10.a.U→P(V):ML,Cert_AIKPage13消息3.7.b.V→P(U):NV消息3.8.P(U)→T:NV消息3.9.T→P(U):Q消息3.10.b.P(U)→V:Q,ML,Cert_AIK该攻击过程中,攻击者首先冒充V与一个合法的U交互,获取其完整性度量日志ML和AIK证书Cert_AIK(消息3.7.a~3.10.a);然后,当远程验证者V向攻击者平台请求验证数据时,攻击者冒充U从安全芯片T获得签名数据Q(消息3.7.b~3.9);最后,攻击者组合消息骗取V的验证(消息3.10.b).攻击4(布谷鸟攻击,破坏Verifier认证性).攻击者购买一个TPM芯片,能代替其他任何恶意平台完成远程证明过程,假设攻击者的安全芯片为TP,攻击流程如下:PCA,IP消息4.1.P→TP:LP,PCA消息4.2.TP→P:AIKP,IP消息4.3.P→PCA:Cert_EKP,AIKP,LP,消息4.4.PCA→P:{Cert_AIKP}EK消息4.5.P→TP:{Cert_AIKP}EK消息4.6.TP→P:Cert_AIKP消息4.7.a.P(V)→U:NP消息4.10.a.U→P(V):ML消息4.7.b.V→P(UP):NV消息4.8.P(UP)→TP:NV消息4.9.TP→P(UP):QP消息4.10.b.P(UP)→V:QP,ML,Cert_AIKP该攻击过程中,攻击者首先使用安全芯片TP向PrivacyCA申请一个合法的身份Cert_AIKP(消息4.1~4.6);然后,攻击者冒充V向一个合法的用户平台U发起挑战,获取其合法度量日志ML(消息4.7.a~4.10.a);基于ML,攻击者可以在TP平台上通过TPM_Extend命令扩展出预期的PCR值;最后,当攻击者控制的任意恶意平台UP想要获取V的验证时,可以使用TP所在的攻击者平台代替UP完成平台证明过程(消息4.7.b~4.10.b).因为Cert_AIKP是合法的身份,QP是对合法完整性状态PCR值的签名,因此可以通过V的验证.该攻击体现了TPM安全芯片本身也是一把双刃剑,能被攻击者利用.文献[5]中由于没有区分安全芯片T和用户进程U两个角色,因此没有发现此攻击.由于该攻击与CMU学者[29]发现的布谷鸟攻击一致,因此采用这种攻击称谓.攻击5(破坏ML的机密性).由于远程证明协议设计时只考虑了认证性,使用了基于AIK的签名,而没有考虑机密性,并且ML是明文传送的,任何攻击者都可以获得ML,则ML的机密性缺失可能被攻击用来破坏其他安全属性,如攻击4中攻击者使用获取的ML伪造合法的完整性状态,破坏了Verifier的认证性.攻击6(破坏用户的认证性).远程证明协议本身是一个单向认证协议,即只有验证者V来检查证明者平台的身份和完整性状态,而证明者平台并没有获得远程验证者V的任何认证信息.因此,任意攻击者都可以随意地向证明者平台发起认证挑战,平台会不断调用TPM_Quote命令进行应答.一方面消耗TPM的计算资源,进行DoS攻击;另一方面,截取可信平台的数据,进行其他攻击(如攻击3和攻击4中都有利用这一点,攻击者P冒充V与U交互).6.2攻击实验本节对以上攻击中的布谷鸟攻击(攻击4)进行了模拟实现.在文献[30]中,我们提出的可信平台模块TEEM,通过修改安全芯片的驱动,使得计算平台的可信功能通过USB发送给TEEM完成.TEEM(相当于TP)可以作为代替平台上原有TPM/TCM使用的布谷鸟攻击实例.攻击者获得TEEM后,将TEEM的PCR和ML固定为V信任的值,通过USB连接任何计算平台,即可代替该平台完成证明,并获得V的信任.具体攻击实现如图7所示,包含如下两个过程:(1)模拟一个安全芯片基于ARM开发板,我们模拟了一个安全芯片,称为TEEM.TEEM[30]使用ARMTrustZone安全扩展技术提供隔离执行环境,使用开源的软件TPMEmulator①提供可信功能(包括密钥管理,身份生成,引证,签名等).TPM安全芯片一般通过LPC总线固定在主板上,而TEEM通过USB线与计算机①http://tpm-emulator.berlios.dePage14(如证明者U所在平台)连接,TEEM位于ARM嵌入式环境,通过Linuxgadget驱动将ARM开发板模拟为一个USB外设,证明者平台的USB驱动可以识别该外设.具体实现时,ARM端内核配置gadgetserial驱动,计算机主机安装CDC/ACM①驱动可识别TEEM所在的ARM开发板.通过USB线连接TEEM所在的ARM开发板和证明者主机平台,主机上所有通过该USB驱动请求的数据都会转发给TEEM进行处理,因此,TEEM所在的ARM开发板可以作为一个模拟的安全芯片使用.(2)使用模拟安全芯片实施布谷鸟攻击根据可信计算标准规范[1],可信应用通过可信软件栈调用可信计算的功能;而可信软件栈通过可信设备驱动库TPMTDDL(TrustedDeviceDriverLibrary)将可信计算功能的命令请求交给TPM驱动,进而交给TPM安全芯片处理(如图7所示).类似地,我们实现了USBTDDL设备驱动库,该库通过USB驱动直接与TEEM通信.USBTDDL主要包含3个基本接口:TDDL_Open()、TDDL_Close()、TDDL_TransmitData().这3个接口通过访问USB驱动完成.图8通过可信软件栈libtpm访问TEEM的响应结果在主机平台上通过使用USBTDDL库替换TPMTDDL库,并通过USB线连接TEEM.这样可信软件栈的所有可信功能请求将会交给模拟安全芯片TEEM处理,而不是实际的TPM安全芯片.图8显示了在Windows平台上替换TDDL库后通过可信软件栈libtpm②访问TPM的功能时的响应结果,不过其显示出来的TPM信息实际上是来自ARM开发板的TEEM模拟芯片.通过篡改证明者平台TDDL库和设备驱动,当用户进程与PCA建立平台身份密钥,以及和远程验证者V进行平台证明时,实际都是使用TEEM模拟的可信功能.可信计算命令在TEEM中的执行性能(包含主机与TEEM之间USB通信的时间)在文献[30]中也进行了详细的评估.通过在Windows平台上的实验,对于基于TEEM的远程证明协议,身份生成命令TPM_MakeIdentity需要3.593s,AIK证书激活命令TPM_ActivateIdentity需要421ms,引证命令TPM_Quote需要359ms,一个PCR扩展需要62.5ms,读取PCR值也需要62.5ms.显然,该攻击需要TEEM拥有一个合法的EK证书.只要攻击者控制一个安全芯片,其就拥有一个有效的EK证书.另外,随着可信芯片的发展,支持USB接口的便携式可信芯片是一个趋势.这样,只要攻击者拥有一个合法的便携式可信芯片,其可以在任何主机上完成远程证明协议来进行布谷鸟攻击.因此,在发展可信安全芯片时,需要提出相应的机制来防止攻击的发生,本文基于串空间的分析方法可以提供参考.7结束语本文对串空间模型进行了扩展,使得其能分析可信计算远程证明协议,并证明了扩展后范式引理的正确性.通过扩展的模型对远程证明协议及其安全属性进行了形式化定义.同时,本文提出了4个认证测试准则,并使用这些准则对远程证明协议进行了分析.经过分析发现,期望的安全属性只有部分成立,不成立的部分容易导致攻击(如布谷鸟攻击等).针对攻击,本文提出了相应的改进方法.同时为了验证串空间的分析结果,本文基于ARM开发板对发现的布谷鸟攻击进行了模拟实现.本文的工作弥补了可信计算理论研究的不足,为其在实际中的使用提供信心保障.本文的串空间扩展方法针对可信安全芯片进行,同样也适合分析拥有类似功能的密码硬件.下一步工作主要包含4个方面:基于本文提出的改进方法,设计并分析新的远程证明协议,促进可信计算的发展;进一步分析可信计算的授权会话协议(如TPM2.0中新的授权协议等),明确安全芯片和计算平台的绑定认证性;扩展开源CPSA[8]工具实现对本文方法的自动化验证.
