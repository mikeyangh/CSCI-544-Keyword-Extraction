Page1Walsh函数在组合测试中的应用王蓁蓁1)周毓明2),3)康达周2),3)王子元2),3)李言辉2),3)徐宝文2),3)2)(南京大学软件新技术国家重点实验室南京210093)1)(金陵科技学院软件工程学院南京211169)3)(南京大学计算机科学与技术系南京210093)摘要实际软件系统非常复杂,有很多因素会影响系统的正常运行.组合测试可以对这些因素及其相互作用所引发的软件缺陷进行检测.该文在组合测试基本模型的基础上,引入Walsh函数,建立了组合测试Walsh函数模型.模型给出基于Walsh的测试用例模式的定义以及理论缺陷函数和实际缺陷函数的定义;引入Walsh模式变换概念,并利用Walsh函数的离散形式有效地计算测试用例模式的平均缺陷率.最后基于模式平均缺陷率的大小,补充附加测试用例进行重新测试,从而迅速将故障原因锁定在很小的范围内,为软件的调试和测试工作提供更方便、更有价值的线索和参考.关键词软件测试;组合测试;软件调试;Walsh函数;测试用例模式1引言大多数软件系统都很复杂,有很多因素都可能会影响软件系统的正常运行,这些因素可能是待测系统的配置参数、内部事件、用户输入参数以及外部事件参数等.除了单个因素之外,这些因素之间的相互作用也可能会对系统的运行造成影响.组合测试作为一种科学有效的软件测试方法,可以使用较少的测试用例有效地检测软件系统中各个因素以及它们之间的相互作用对系统产生的影响.一直以来人们关于组合测试的研究主要集中在测试用例的设计方法[1-18],这些方法致力于生成规模更小的测试用例集.例如Kobayashi和Tsuchiya等人[3]提出了一种生成两两组合测试数据的代数方法.Cohen等人[4-6]将模拟退火算法应用于多重维数组合测试用例的生成,该方法综合考虑了运算效率和运算结果之间的关系,根据时间和效率上不同的要求来生成尽可能优的结果.Shiba和Tsuchiya等人[7]研究了遗传算法和蚁群算法在组合测试数据自动生成中的应用.Colbourn和Cohen等人[8]提出了一种两两组合测试数据生成的确定性密度算法.Colbourn和Sherwood等人[9-10]研究了两种组合覆盖表的生成方法,分别应用于具有不同参数取值的两两组合覆盖表和高维组合覆盖表的生成.但是当应用组合测试方法对待测系统进行测试,并发现故障时,如何根据测试结果来确定导致故障发生的原因呢?实际上,组合测试中的测试用例是待测系统的因素(或配置)组合,而测试集中的测试用例相似样板可以抽象为“模式”.利用测试用例模式本身的特点,选择相应的附加测试用例进行软件故障定位,可以提高软件测试的效率并降低成本.Walsh函数是美国数学家Walsh引入的一个函数系.在数字信号处理中,它可提供类似Fourier变换的表示方法,许多结果便于计算机上实现,在某些方面,优越于Fourier分析.现在Walsh函数已经广泛应用在信号处理,模式识别以及遗传算法等领域.受到这些应用的启发,我们考虑将Walsh函数引入组合测试领域.由于组合测试中的测试用例是待测系统的因素(或配置)组合,那么测试用例的模式则是一些测试用例的相似样板,一个模式能说明系统的缺陷主要受到该模式上哪些配置的影响.而Walsh函数在处理模式特性上有独特的长处,如通过Walsh变换可得出模式的某些特性值,这在遗传算法中表现为模式的平均适应度值.同样,设想在组合测试领域里,也应该可以通过Walsh函数变换表现出模式发现软件故障的平均缺陷率.因此本文将Walsh函数工具引入组合测试,建立Walsh模式分析模型.该模型给出测试用例模式以及缺陷函数等概念,将模式和测试用例集紧密地联系在一起.利用该模型,可通过Walsh函数演化逼近模式的缺陷函数,并且利用Walsh函数的离散形式能有效地计算出发现系统的所有模式引起软件故障的概率.实际应用中可根据测试用例集测试的结果,只计算发现故障的测试用例的所有父模式的缺陷概率,再根据概率的大小,选择附加测试用例,从而将故障原因锁定在很小的范围内.该模型可以为软件的调试工作以及理论分析提供非常方便有效的参考.2基本方法对一个待测系统SUT(SoftwareUnderTest)进行组合测试.假设待测系统SUT包含n个参数c1,c2,…,cn,分别从T1,T2,…,Tn中取值,其中Ti表示参数ci可取的有限离散点集.令符号ai表示第i个参数ci可取值的个数,即Ti中元素的个数:ai=|Ti|.称n元组(v1,v2,…,vn)(v1∈T1,v2∈T2,…,vn∈Tn)为SUT的一个测试用例,并称一个由多个这样的n元组所构成的集合为SUT的一个测试用例集,令Ts为根据实际要求设计的一组测试用例集.在实际中导致系统发生故障的原因有很多,其中部分是由于某些参数的相互作用而导致的,在测试时则表现在测试用例中的某些特定取值模式会产生故障.因而可以假设系统SUT的故障只由某些取值模式引起.对于上述待测系统SUT,将其中k(1kn)个因素的取值确定后,可得到一个n元组schema=(-,…,-,vi,1,-,…,-,vi,2,-,…,-,vi,k,-,…,-)(vi,1∈Ti,1,vi,2∈Ti,2,…,vi,k∈Ti,k),其中符号“-”表示相应位置上因素的取值待定.称schema为SUT的一个k-模式,简称为模式.显然,当k=n时,k-模式schema恰好成为SUT的一条测试用例.假设schema1=(v1,v2,…,vn)和schema2=(v1,v2,…,vn)分别为SUT的k1-模式和k2-模式,如果有k1k2,且对于1in,(vi=“-”)∨(vi=vi)均为真,则称schema1是schema2的父模式,而schema2是schema1的子模式,并记作schema2Page3schema1.假设应用测试用例集Ts(其个数为m)对SUT进行测试,发现有l个测试用例(记为集合Ts1)在执行中发现某个故障,而其他m-l个测试用例(记为集合Ts2)不发生该故障.接下来的工作就是分析故障的原因,对它进行定位.主要方法基于以下思想:首先找出l个测试用例引发某故障的所有可能的模式集合,即∪t∈Ts1Mt,这里Mt表示用例t的父模式集合.并要求这些模式不出现在另外m-l个没有该故障的测试用例的模式中,用式子表示为∪t∈Ts1Mt-∪t∈Ts2Mt,则这些模式可能是引起故障的因素[13].其次,再从发生某个故障的l个测试用例中找到某些共同的取值模式组成的集合,用式子表示为∩t∈Ts1Mt,并且这些共同的取值模式只在这l个测试用例中出现,而在另外m-l个没有该故障的测试用例中不出现,即为∩t∈Ts1Mt-∪t∈Ts2Mt,则这些共同的取值模式都是有可能引起系统SUT出现故障的原因[13].通常这两个集合元素还是比较多,要进一步约简.为发生某故障的每个测试用例设计附加用例,附加用例的设计方法是取原来测试用例的父模式,再将其父模式上不确定位取任意不同于原测试用例相应位置上的参数值来代替.比如说某测试用例为(ν1,ν2,…,νn),附加n个测试用例为(,ν2,…,νn),(ν1,,…,νn),…,(ν1,ν2,…,),其中“”号代表相应于原测试用例对应位置的不同取值.这样就得到一组新的测试用例集,可记为CTs,用这组新的测试用例集对待测系统进行测试,测试结果同原测试集一样分为发生某故障的测试用例集合(不妨记为CTs1)和不发生该故障的测试用例集合(记为CTs2).同前面所叙方法一样,找出l个测试用例出现该故障的所有可能取值模式,并保证这些模式不出现在m-l个测试用例中,也不出现在CTs2里的测试用例中,即得到模式集合∪t∈Ts1Mt-∪t∈Ts2Mt-∪t∈CTs2Mt.同样再从l个测试用例中找到某些共同的取值模式组成的集合,且这些取值模式只出现在这l个测试用例中,不出现在m-l个测试用例中,并且也不出现在CTs2集合所包含的测试用例中,用式子表示为∩t∈Ts1Mt-∪t∈Ts2Mt-∪t∈CTs2Mt.这样两个集合里的元素已经大大减少,通过分析可以准确地将引发软件故障的原因诊断出来.由于实际情况中,待测系统的参数因素多,虽然导致系统出错的测试用例的数量可能比较少(这种测试用例对软件测试来说是高质量的测试用例),但是其父模式的数量比较多.如果要考虑系统故障可能是测试用例中所有参数的取值组合,其父模式的数量则成指数增加.因此要建立一个模型能够有效地计算模式导致系统故障的概率(可以称之为模式缺陷率),再根据概率的大小选择相应地附加测试用例,则可以有效地帮助我们迅速定位系统的故障所在.因为测试用例模式的概念非常类似于遗传算法中的“模式”分析(其采用Walsh函数离散形式有效地计算平均适应度),因此本文将Walsh函数引入组合测试,有效地计算测试用例的模式平均缺陷率.3Walsh函数模型构建及方法不失一般性,本文只考虑二水平多因素系统,即该系统每个参数有两个取值,则这样的系统称为二水平多因素系统.如果在组合测试中发现多水平因素,可以将模型进行推广,所提方法和原理同样适用.由于待测系统中每一个Ti中元素个数ai为2(二水平),不妨认为这两个元素为0或1.可用二进制数m=(bn-1bn-2…b0)表示待测系统SUT的一个测试用例(ν1,ν2,…,νn),即(bn-1bn-2…b0)=(ν1,ν2,…,νn),则二进制组(bn-1bn-2…b0)为待测系统SUT的一个测试用例.这样一个可能包含未确定位的二进制数即为模式.若一个测试用例m,与模式H的确定位相对应的位上的值与该模式H的确定位值相同,则称此用例m属于H,或者称H包含用例m,记为m∈H.模式H是一些测试用例的相似样板,它说明系统的缺陷主要受到H的确定位上的配置的影响,而未确定位的任意配置并不是系统缺陷的原因.由于待测系统有n个参数,则共有2n个测试用例.设N=2n,把[0,1)区间分成N个子区间,每个子区间形式如k二进制数m=(bn-1bn-2…b0)记为某子区间号,或者说它是相应的测试用例(ν1,ν2,…,νn)的子区间号,有时也把它对应于某子区间的左端点(约定右连续).用子区间号表示测试用例好处在于它可以和某一个Walsh函数上[0,1)区间号进行一一对应,从而可以进行离散W变换及其逆变换.Walsh函数的数学形式为Page4其中m=(bn-1bn-2…b0)为一个二进制数,(j,t)是[0,1]区间上的R函数(参看文献[19]第5~8页),并且wal(m,t+1)=wal(m,t).R函数形如一个正弦波,其最简单的R函数是(0,t),它在[0,1/2)区间上取值为1,在区间[1/2,1)上取值为-1.任意的R函数(j,t)可由(n,t)=(0,2nt)推广得知,例如(1,t)=(0,2t),它是这样的波形函数:在区间[0,1/4)上取值为1,[1/4,1/2)上为-1,[1/2,3/4)为1,[3/4,1)为-1.理论上,每一个测试用例都要对软件进行测试.为了进行Walsh离散W变换,可以定义测试用例发现软件缺陷的函数,这个函数的定义域为测试用例集,值域为0或1,称之为缺陷函数f(test):f(testi)=1,实施testi进行测试,发现缺陷其中testi表示测试用例集中某一个测试用例.由于测试用例的个数为N=2n,当因数个数n增加时,N呈指数增长.因此实施完整N个测试是不可能的,而且也没有必要.沿用第2节记号,设一个待测系统SUT在应用测试用例集TS(|TS|=m,mN)进行测试时,有l个测试用例(组成子集合TS1)在测试中发现某个故障,而其他m-l个测试用例(组成子集合TS2)未发现故障.经验上可以认为平均每个测试用例发现l/m(个)缺陷.未测试用例组成的集合(该集合共有N-m个用例),用TS3表示,并规定每个测试用例的缺陷值为l/m.现在,可以用下述经验缺陷函数f(test)代替理论缺陷函数f(test),经验缺陷函数简写为f(t).现在定义了T上的缺陷函数f(t),又由于测试用例已经和[0,1)区间上N个子区间一一对应,这样{f(i)},i=0,1,2,…,N-1即为一个序列,它可以看成是[0,1)区间上离散点上的函数.根据Walsh函数上的离散变换定义,它的离散W变换为F(j)=wj,j=0,1,…,N-1,即其逆变换为f(t)=1这样便构建了Walsh函数模型,它实质上是一个四元组(T,W,f,F),其中T是n个二水平因素的系统里所有测试用例的集合.测试用例是一个n位二进制数,记作(bn-1bn-2…b1b0),抽象为[0,1)区间等分N=2n个子区间的区号或者是子区间左端点的集合.W是T上的Walsh函数系.f是定义在T上的函数,它可以是视问题需要选择的任意一般函数,这里规定f是测试用例集T上的缺陷函数.F是f的W变换.下面的讨论都在此模型WMOD=(T,W,f,F)上进行.对于Walsh函数模型WMOD=(T,W,f,F),可以计算任意模式中测试用例发现软件故障的概率,称之为模式平均缺陷率.模式,称f(H)=1称H的缺陷率.定义1.模式平均缺陷率.设H为任意一个由定义可知,0f(H)1.进而定义2.模式Walsh变换.设H是任一模式,注意到1式无关.称S(H,j)=1Walsh函数的变换值,简称为H的Walsh变换或H的W变换.从定义可以看出,S(H,j)只和模式以及wal(j,·)(即第j个Walsh函数)有关.它是WMOD=(T,W,f,F)中关于(T,W)上的固定结构.对于不同的f及其W变换F,都可以应用同一个S(H,j)(H为T上模式,j为Walsh函数编号)结构进行分析.本文是讨论缺陷函数,于是根据定义1和定义2,模式平均缺陷率可以表示为任意模式的平均缺陷率.由此可见,只要有S(H,j)变换值,就可以得到定义3.设H为任一模式,其所有子模式为H1,H2,…,Hr,将每一个子模式的确定位都置于1,Page5未确定位都置于0,这样得到r个二进制数h(1),h(2),…,h(r),令它们的逆序为〈h(1)〉,〈h(2)〉,…,〈h(r)〉,则称〈h(j)〉(j=1,2,…,r)为H子模式Hj的序号,所有序号组成的集合记为J(H).{-1,0,1}.S(H,j)的值与模式H的子模式有关,值域为定理1.设H为任一模式,其W变换为S(H,j),j=1,2,…,N-1,J(H)为其模式序号集合,则S(H,j)的值域为{-1,0,1},当且仅当jJ(H)时,S(H,j)=0.i=0证明.S(H,j)=1∑t∈Hwal(j,t),由W变换对称性(见文献[19]第50页)可得∑t∈H得到∑t∈H∏n-1H,j=(jn-1jn-2…j1j0),〈j〉=(j0j1…jn-2jn-1).如果j∈J(H),那么j为H某一子模式H的序号,设H对应的序号为〈h〉,其中h是将H模式中未确定位置于0,确定位置于1所得,h的逆序便为序号〈h〉.注意现在j=〈h〉,将它代入上面和式,便得∑t∈H∏n-1|H|∑t∈H∏n-11参数时才为1,所以乘积项只与H的确定位有关,显然它为1或-1.又由于HH,对t∈H,推出t∈H.t在H的确定位上的值是固定的,故在上式求和符号下每一乘积项都等于常数+1或常数-1,所以S(H,j)=+1或-1.如果jJ(H),则对任意H的子模式HH,j≠〈H〉.令j=(jn-1jn-2…j1j0),则H中至少有一个未确定位,不妨设l位,j的相应n-1-l位上的值jn-1-l等于1.否则当j中相应H的未确定位的值都等于0时,则不论其他位上的值如何,j即为H的某一序号〈H〉.于是在表达式S(H,j)=1每一个乘积项中都有如此因子(-1)tljn-1-l.由于H中的用例,在未确定位上取值是成双出现的,现在jn-1-l=1,所以整个乘积项在成双的用例上取相反符号,所以整个和式等于0.这就证明了该定理.证毕.由此,f(H)表达式(6)可写为注意,当用模式讨论软件系统其他性质时,只要适当定义测试用例集上的函数f(就像这里定义f为缺陷函数那样),都可以用式(6)讨论该性质在模式上的平均值,并进行其他分析.定理2.H是任一模式,j∈J(H),设j=〈H1〉,H1H.如果H1确定位上参数值为1的个数为偶数,则S(H,j)=1,否则为-1.证明.当j∈J(H),且j=〈H1〉时,因为H1H,由定理1以及模式阶的性质(参看文献[20]第51~52页),可得S(H,j)=S(H1,j).设H1的阶为k,且确定位是i1,i2,…,ik位,则S(H1,j)=1对t∈H1,t在H1确定位的值与H1确定位上的值相等,所以上面和式里乘积是常数,它取值±1,全视ti1,ti2,…,tik里包含1的个数的奇偶性而定.证毕.于是WMOD上结构S(H,j)已经构造出来了,即H是任一模式,则S(H,j)=根据以上定理,可以看出,WMOD确实将测试用例的各种模式紧密地联系在一起了,从模式中也可看出各个参数的相互作用.对于系统的任意输入模式,如果想知道该模式的平均缺陷率,则根据定义1和定义2,只需要知道S(H,j)的值,而S(H,j)恰恰和该模式的所有子模式有关,故在WMOD模型下,系统的父模式和子模式以及参数的确定位之间的关系一目了然.4实例分析及多水平因素推广假设要测试一个交换机的打通电话功能,这个测试模型有4个参数,分别为呼叫种类(Calltype),资费方式(Billing),接入方式(Access)和状态(Status),仍然考虑二水平因素,即每个参数有两种不同的状态选择,分别用0和1来表示,如表1所示.假设实际中采取了一组测试用例为{(0000),Page6(0110),(0111),(1010),(1011),(1100),(1101),(1110),(1111)},例如(0000)代表测试用例为(Local,Caller,Loop,Success),其他类似.这组测试用例组成集合Ts.当运用Ts对交换机进行测试时,发生某个故障的测试用例为(1100)和(1101),这两个测试用例组成集合Ts1,其余7个测试用例组成集合Ts2,它们没有发现该故障.呼叫种类资费方式接入方式状态0Local1Longdistance1Collect1Isdn1Busy根据上一节的讨论,认为平均每个测试用例发现2/9(个)缺陷,于是测试用例的缺陷函数为根据式(3),f(t)的W变换如下:9,w1=w2=-43,w5=w6=-20于是就可以构建该系统的Walsh函数模型WMOD=(T,W,f,F),其中,T是测试用例集;W是Walsh函数系,这里待测系统因素为4,故W函数系包含wal(0,t),wal(1,t),…,wal(15,t)等16个前Walsh函数;f就是根据测试结果所得出的测试用例缺陷函数,F是其上的W变换.现在我们的目的就是计算发生故障的测试用例的所有模式的平均缺陷率,然后根据平均缺陷率的大小再选择出附加测试用例,对系统进行测试,最后诊断出该系统故障的原因.w0=32w4=8w8=w9=w10=w11=w12=w13=w14=w15=-2对任意一个模式H,其平均缺陷率为f(H)=N∑N-11wjS(H,j).根据定理1和定理2,S(H,j)和j=0H的子模式上的确定位上取1的奇偶数有关.比如,要计算模式(110)的缺陷率,那么S(H,0)=S(H,3)=S(H,4)=S(H,8)=1,S(H,1)=S(H,2)=S(H,5)=S(H,6)=-1,其余为0,则根据式(6),模式(110)的缺陷概率为f(110)=1由此,可以将发生故障的测试用例的所有模式找出来,并计算它们的平均缺陷率,再按照概率的大小选择附加测试用例.例如,对于该例来说,发现故障的用例为(1100)和(1101),首先找出其拥有较高缺陷率的所有父模式.所谓较高缺陷率其实可以设定一个阈值,这里采用阈值为0.5,因为显而易见缺陷率在50%以上的模式极有可能导致系统发生故障,因此应该要慎重对待;另外,由Walsh函数在遗传算法里的模式定理强调了高适应度的模式的重要性[20-22],故这里我们选取的阈值是0.5.结果有以下这些模式,它们的缺陷率都高于0.5.f(110)=0.930,f(100)=0.611,f(100)=0.611,f(10)=0.611,f(10)=0.611,f(101)=0.611,f(101)=0.611,f(11)=0.563,f(110)=0.560.找出这些模式后,按照它们概率从大到小选择附加测试用例.例如首先选择测试模式(110),将该模式的不确定位用不同于原测试用例相应位置的参数取值代入即为新的测试用例,不过这里用1代入则为原Ts集合中另一个发现故障的用例(1101),故转而考虑模式(100),将不同于原测试用例相应位置的参数取值即0代入,得到新的测试用例(1000),它没有出现在原Ts集合中,故选择(1000)作为新的补充测试用例.依次类推,这样就得到一组新的补充测试用例集{(1000),(0100),(1001),(0101)}.这样设计附加用例的好处在于不用将原先出错测试用例的每一个位置都用不同于原来的值代入,按照文献[13]的思想,需要再补充设计8个附加的测试用例,而这里根据模式概率的大小,只需要补充4个测试用例,大大减少了附加测试用例的个数,且由模式缺陷概率保证最终能找到软件出错的真正模式.用这组测试用例再对系统进行测试,根据结果就可以取定导致故障的原因.(1)如果这4个测试用例的运行都没有发生原先的故障,则说明上面导致那些缺陷率高的模式的真正起因就是原来发现故障的两个测试用例,即(1101)和(1100),因为附加用例是用不同于相应位置的参数值代入而得到的,现在附加用例没有发现故障,因此最后的结论就是模式(1100)(即(Longdistance,Collect,Loop,Success))和模式(1101)(即(Longdistance,Collect,Loop,Busy))是导致故障的因素;(2)如果这4个测Page7试用例某一个发现了故障,例如是(1000),它和原发现故障的用例共同父模式为(100),因此导致故障的因素是模式(100)(即(Longdistance,,Loop,Success))以及模式(1101)(即(Longdistance,Collect,Loop,Busy));(3)如果这4个用例都发生了故障,则说明该系统极有问题,质量太低,则需要进行重新广泛的分析和检查.类似地,可以讨论其他各种情况.由此可看出,在组合测试的基础上,并辅之以一些必要的相关测试用例,可以对导致系统故障的因素进行有效的定位.另外本文为了将Walsh函数引入到组合测试,考虑的都是二水平因素.但是实际系统是复杂的,参数的数量可能不止两个.可以推广该Walsh模型,推广方法如下.如果考虑一般多因素系统,有S个因素参数c1,c2,…,cs,每个参数ci取值集Ti里元素个数ai未必等于2.令M=a1×a2×…×aS.对任意Ti中ai个元素按任意次序排序,不妨认为这ai个元素就是1,2,…,ai等ai个自然数,次序为自然序.然后对M个测试用例集T={(ν1,ν2,…,νS)|νi∈Ti,i=1,2,…,S}按字典序(从小到大)排序,这样便得到一个有序集T.寻找自然数n,使得令2n=N.设N-M个元素为虚拟测试用例,记之为Δ1,Δ2,…,ΔN-M.把N-M个虚拟用例随机插入进已经排好次序的T集中,插不进前M个次序统统作为最后元素(按任意次序排列于后),从而得到新的测试用例集T,它是T的扩充.让T中N个从小到大测试用例与[0,1)区间等分的N个子区间的左端点对应,于是便得到一般多因素系统,测试用例(包括虚拟用例)的理论表示,重新记为T={testii=0,1,…,N-1}.软件在某种意义上是一个形式系统,它在运行时往往由于事前无法预料的原因而产生故障.现在M<N,它提供了N-M个“机会”去检验这些无法预料的原因,也就是说可以根据历史经验对Δ1,Δ2,…,ΔN-M等虚拟用例赋予意义,并估计这些事件发生的概率P1,P2,…,PN-M,或者按统计学上“同等无知”原则,赋给每个虚拟用例发生软件故障概率为P1=P2=…=PN-M=1TS,TS1,TS2符号如前,|TS|=m,|TS1|=l,|TS2|=m-l.在前面定义的T上定义缺陷函数f(test)为f(test)=这样就得到一般多因素系统的Walsh函数模型WMOD=(T,W,f,F).再利用前面定理,可得出一般多因素系统任意模式的缺陷概率.5相关工作组合测试的目的在于对软件中各个因素之间的相互作用进行测试.不同的组合覆盖标准决定了测试用例集对于因素间交互作用的不同覆盖能力,也决定了其不同的错误检测能力.但是目前,对组合测试的结果进行调试和错误定位分析的研究还很少[23].2002年Zeller和Hildebrandt[24]提出了Deltadebugging方法对待测系统中出现的故障进行调试以简化与孤立导致故障的环境或输入.Yilmaz等人[25]在2006年用分类树方法来定位错误交互,一般来说系统的错误交互很难被精确地定位.2008年Colbourn和McClary[26]提出了(d,t)错误定位表及错误侦测表的概念,利用这些表来对组合的交互错误进行定位.2009年Martinez等人[27]提出了一般的错误定位表,在此模型下提出了自适应算法来定位错误交互.但是Martinez等人提出的模型只是处理了二维组合覆盖,即在软件故障是由二维错误交互引发的假设下,给出错误交互定位的自适应算法,对于一般的情况并没有给出相应的解决方法.2011年,Zhang等人[28]提出了自适应测试生成方法,该方法类似于Deltadebugging运用失败测试作为种子测试去定位故障组合.2012年,Shakya等人[29]利用扩充测试和特征选择来提升分类树的效果,以此来定位错误交互.我国学者对基于组合测试的软件故障诊断方法也进行了相应的研究.早在2006年,徐宝文等人[13]提出了一种基于组合测试的软件故障调试方法,该方法基于组合测试的结果,补充一些附加测试用例进行重新测试,然后对其结果作进一步的分析和验证,从而可把引发软件故障的错误交互锁定在很小的范围,但他们的方法基于一定的假设.周吴杰等Page8人[23]改进了Martinez等人的用高维覆盖表来构造错误定位表的方法,解决了Martinez等人提出的问题之一,即怎样在组合测试中定位至多t维的交互错误,但对于Martinez等人留下的另一个开问题,即一般待测系统的错误定位仍然没有解决.本课题组基于上述研究,尤其是在徐宝文等[30]学者所提的软件故障调试方法的基础上,充分考虑组合测试中各种因素的之间的相互作用.因为组合测试成功应用的关键在于对待测软件的内部特征,如因素间交互的力度等信息有所了解,并在此基础上利用这些信息设计测试用例.所有我们采用模式概念抽象出因素间交互关系的特殊性.一方面,利用Walsh函数工具及其Walsh变换得出测试用例模式引发故障的概率,则减少需要补充的测试用例.另一方面,Walsh模式模型也在一定程度上验证了文献[13]中基本假设的成立情况.本文也给出了从二水平因素推广到多因素系统的办法,部分解决了Martinez等人留下的“一般待测系统的错误定位仍然没有解决”的这样一个开问题.6结论与展望在应用组合设计产生的测试用例集对软件系统进行测试之后,如果发现故障,那么说明测试工作是成功的,但是还需要通过对实验结果的分析和处理,初步确定故障原因,并探求可能更优实验方案,来对故障原因进行进一步的分析、处理和验证.本文在建立Walsh函数模型的前提下,提出了一种根据测试结果和附加测试用例的测试结果进行故障原因定位的方法.基于本文的模型,该方法可以解决故障原因的诊断问题.现今软件界已经积累了大量软件测试经验,将这些经验上升为理论,无论是对计算机科学,或是对软件测试实践都是有重大作用的.本文就是基于上述想法,为软件组合测试以及与之相关的故障定位方法寻找适当的理论以及方法.本文利用Walsh函数工具通过实例分析证明了基于Walsh函数的模型WMOD充当软件测试理论以及辅助方法是可行的.基于Walsh函数的模型WMOD作为软件测试的理论基础,可以推导出测试方法上的新突破,例如,可以把WMOD看成五元组(T,W,S,f,F),其中T,W,S都是固定结构而f可以由用户定义,能否考虑T上不同的函数f及其W变换F,从而研究其他测试问题.把上述模型进一步深化,从中找出更深刻的结果,例如类似于遗传算法,也让组合测试的用例进行演化,从而寻找更能揭示软件故障的用例,这也许是另一种组合测试用例生成方法.由于组合测试模式分析暗合于遗传算法里积木块原理,这种做法也许是可行的.另外研究用Walsh函数表达的模式和极小错误模式的深刻联系,即如果能直接利用Walsh函数工具找出导致软件错误的极小故障模式,就很有可能更精确地定位故障诱因,进而为故障定位提供有益的线索.总之,以上都是今后研究的主要方向.致谢审稿人对本文提出了有价值的修改意见,在此表示衷心感谢!
