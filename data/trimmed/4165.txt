Page1基于三角形自适应细分的有效光照烘焙方法李杨1),2)周果1),2)李淳秡1)邱显杰1)王兆其1)1)(中国科学院计算技术研究所虚拟现实实验室北京100190)2)(中国科学院大学北京100049)摘要传统的纹理烘焙技术虽然能产生高质量的视觉效果,但需要占用大量的存储空间,进而影响实时绘制的性能.针对这一问题,文中提出一种基于自适应三角形细分的有效光照烘焙方法,在保证绘制效果的前提下,可以保持低存储和高帧率.作者首先提出一种适合三角形的自适应细分模式,通过GPU四叉树编码表示子三角形级别的细分;其次,利用光照图纹理和GPU可编程着色器快速决定三角形的自适应细分模式;第三,针对细分模式的性质,通过缝合操作,有效地消除不同细分模式下相邻三角形之间可能出现的裂缝;最后通过最小二乘意义的全局优化,计算顶点颜色.另外,算法还可以通过用户定义的参数灵活地控制细分粒度和绘制效果.实验结果证明,与传统的基于光照图的实时渲染方法相比,文中算法通过使用细分后的模型顶点颜色代替光照图,不仅可以节省80%以上的存储空间,还可以保持高帧率,并达到近似的绘制效果.关键词光照图;自适应细分;光照烘焙;纹理烘焙1引言全局光照效果,在计算机图形学应用领域发挥着重要的作用.然而,对于日趋复杂的场景,其计算往往非常困难而且很难达到实时性.较为普遍的解决方法是预计算光照信息并存储到顶点属性或者纹理里[1].这类算法包括辐射体、预计算的辐射度传递、环境遮挡、软阴影算法等.应用最广的光照烘焙技术是顶点烘焙和纹理烘焙.顶点烘焙将光照信息存储在模型顶点属性里.该方法仅需要少量的存储,并通过硬件光栅化和插值操作来恢复光照信息.不过,它不太适合于面积大的图元,因为当前的图形硬件插值操作不支持复杂的插值函数,不能很好地重构光照信息.对于包含高频信号的区域可能会产生光照不连续的走样问题.纹理烘焙,通常称为光照图技术,在纹理上保存光照数据.由于纹理里面包含了大量的像素采样,这种技术可以达到高质量的视觉效果.不过对于复杂的场景,光照图和纹理坐标需要较大的存储,从而制约了其实时性能和可用性.对于一些产品设计或者场景预览等应用领域,比如室内设计展示,往往需要很多高分辨率的光照图来体现效果.这些纹理占用了大部分的存储空间,而且会严重影响系统实时性能.一个折中的解决方法是使用顶点烘焙方法,不过我们发现,对于许多模型来说,这一方法并不能很好地展示光照效果.由于建模和烘焙往往由不同的人完成,为了达到好的效果,烘焙时可能会需要对模型进行手工的细分.对于效果要求高的应用,往往需要大量的手工劳动.另外,由于光照贴图一般仅仅保存光照信息,对于大部分的纹理区域一般只分布低频的光照信息,在这些区域采用标准的顶点颜色线性插值就已足够.针对以上问题,本文提出了一种基于自适应三角形细分的光照烘焙方法.其主要解决的问题是,如何自动细分每个三角形,才能保证细分后的子三角形顶点颜色插值后得到的信息和初始的光照图信息最接近.实验证明,该算法不仅速度快、全自动,而且可以用于任何基于纹理烘焙的场景渲染,如环境遮挡烘焙下的室内外场景、面积光源影响下的软阴影场景、间接光照的场景等.算法可以达到近似纹理烘焙的效果,同时保持高帧率和低存储消耗.2相关工作过去的几十年里,许多研究者致力于光照信息的预计算领域,例如,辐射体[2]、预计算的辐射度传递[3]、环境遮挡域[4]、预计算的光照传递矩阵[5]等.许多商业软件,如3dsMax、Blender、Beast、Maya,都提供了强大的建模和烘焙工具,可以将光照信息预计算并保存在顶点属性或者纹理里.不过,随着技术的复杂化,烘焙的结果数据日益庞大,如32位浮点纹理或者HDR纹理.在实时渲染时,这些数据会被导入内存并送往显存,严重影响了实时性能,对硬件也有较高的要求,一般仅仅适于PC上的应用,而不适合配置较低的移动设备.为了解决存储开销大的问题,一些研究者开始了纹理压缩算法的研究,特别是针对光照图纹理的压缩.Hu等人[6]提出一种将球面调和的光照图进行压缩的算法,并将其应用在名为Halo3的游戏里.他们首先对光照图纹理进行数值分析,然后对于低频的区域,重新参数化并分配更少的纹理图素.Rasmusson等人[7]提出一种基于参数化平滑轮廓函数的光照图纹理压缩算法,专门针对高频信息比较少的光照图进行压缩.这类方法虽然能减少光照图的存储量,但仍然需要实时的纹理解码和访问,也会产生一定的性能影响.为了更好地利用纹理存储,还有一类方法通过在顶点上存储约简的数据来代替纹理,从而减少实时绘制时的存储.MeshColors[8]在模型的顶点上存储三角形内部的多个颜色采样值.这种虚拟细分的方法不需要纹理方法中的参数化,而且还能避免纹理方法中边界不连续的走样问题.不过,它需要通过片元着色器(fragmentshader)实现mip-map信号重构算法.而在纹理方法中这是伴随着硬件插值和光栅化之后,由硬件实现的.因此这种方法会严重影响实时的性能,只能用于比较小的场景里.最小二乘顶点烘焙(LeastSquaresVertexBaking)[9]通过在顶点位置计算最小二乘意义的最优颜色解,从而达到最大的近似原始光照图信号的目的.为了避免颜色梯度不连续,文献[9]还提出一个修正项来最小化错误率,从而保持最优解.这种方法比其它的顶点烘焙方法产生更精确的顶点颜色,适合低频光照场景以及充分细分后的场景.我们已经实现了这个方法,发现它不太适合于大三角形,即使里面仅包含低频信息,见图13.最近,一些研究者开始尝试使用混合方法来解决这个问题.Schfer等人[10]混合基于顶点和基于纹理的存储方式.他们在高频的区域,使用纹理的方法,低频的区域使用最小二乘意义的优化顶点颜色插值,通过这种方式恢复原始的光照图信号.最后,他们融合两种存储方式,避免在接缝处的Page3不连续.为了进一步约简纹理数据存储,同样是Schfer等人[11]在顶点处存储多分辨率的属性值,然后通过硬件细分操作(Tesselation)实现近似纹理方法的效果.不过由于他们在数据结构上使用了不连续的内存布局(顶点、边、面上的数据单独存储),在实时绘制时,属性的查询制约了性能.与上述方法类似,本文算法同样在顶点属性存储光照信息.不同的是,本文仅存储颜色,细分规则仅依赖初始的光照图纹理,而且实验表明,本文算法可以达到近似纹理烘焙的效果.模型细分算法一直以来都是一个比较热门的研究领域.关于各种细分方法,可以参考文献[12-13],这里,我们只是列出一些相关的算法.Krivanek等人[14]提出一种算法,可以在辐射度(Radiosity)预计算时,通过考虑相邻面片的辐射度变化,在变化快的区域进一步细分.这种方法可以加快辐射度算法的预计算,不需要像传统的均匀细分的方法一样消耗大量的时间.Coombe等人[15]提出一种硬件加速的逐步求精辐射度实现方法.他们考虑辐射度梯度的变化量,在纹理空间细分面片.不过,这种方法仅能细分4边形场景.后来Wallner[16]改进了算法,可以支持任意的三角形场景的细分.Bosch等人[17]提出一种基于自适应细分的交互性日光光照系统.它提供了一种自适应的模型细分方法.不过其细分算法依赖于迭代的可见性计算,耗时严重,限制了其性能.所有的上述细分方法,都是依赖于具体的渲染技术,比如辐射度、PRT(预计算的辐射度传递)等.Boubekeur等人[18]提出了一种运行在GPU顶点着色器中的自适应细分网格的方法,预先为每个顶点计算出一个额外的深度标签(tag),然后在顶点着色器中根据标签选择合适的自适应细分模式对粗糙的多边形网格进行细分.这些模式预存在一个最大分割深度下生成的矩阵中,缓存在GPU的显存里.图1自适应三角形细分算法流程图(首先输入数据为模型三角面和预计算的光照图,之后是纹理空间的采样分类和逐三角形细分模式决策方法,最后在3-D物体空间对模型进行细分和缝合,并且计算优化的顶点颜色)Dyken等人[19]提出一种基于细分模板的网格自适应细分方法,虽然仍然是采用预定义细分模式到GPU显存里,但是它简化了模式的数目,并且通过自适应模板边界匹配的方法解决不同模式之间的连接问题.王旭等人[20]提出一种在GPU上实现地形渲染的自适应算法,首先在GPU里计算逐三角形的细分模式,之后在绘制时通过访问GPU缓存,选择适当的细分模式对三角形进行细分.上述这些方法虽然能自适应的生成不同三角形的细分模式,但是在每个三角形内部往往都是使用均匀细分模式.本文算法采用类似文献[20]中一分四的细分模式,不同的是,本文通过结合MeshColors[8]中提到的性质,提出一种新的细分模式和GPU四叉树编码方式,可以实现子三角形级别的自适应细分.文献[20]通过使用多张纹理保存Mip-Map多分辨率的四叉树编码信息,不同的是本文仅使用一张纹理,这种编码方式不仅可以节省纹理个数还可以通过片元逻辑操作,快速地实现GPU发射(Scatter)操作.3算法综述这里简述算法流程.需要指出的是,本文算法的输入都是光照图纹理,它由其它建模软件,如3dsMax、Maya、或者Beast,预先烘焙好.另外,一般预计算的光照图主要包括低频的光照信息,如环境光照、间接光照、软阴影、环境遮挡等,高频信息非常少.因此我们假定光照图中以低频信号为主.我们的算法主要包括基于信号的高频提取、三角形细分模式决策以及三角形细分缝合与顶点优化颜色计算3个步骤,见图1.首先利用光照图,创建一张标记纹理(MarkTexture,MT),标记出高频的区域.其次,我们利用顶点和片元着色器,快速计算每个三角形的细分模式,并以四叉树编码的方式压Page4缩存储到一张纹理中(SLT).接着,我们回读SLT到CPU里,利用细分模式的性质进行三角形快速细分和缝合操作.最后,利用光照图纹理,对每个子三角形顶点做全局最小二乘优化的颜色计算.我们将会在下面几个小节讨论算法的细节,同时描述基于硬件的实现方法.4三角形细分模式本文算法主要关注自适应的三角形细分,因此针对三角形的细分模式是算法的关键点.迄今为止,有许多细分模式相关的研究工作.我们的三角形细分模式决策步骤和真正的细分是两个独立的阶段,分别在GPU和CPU中完成,这会牵扯到GPU往CPU的数据回读.另外我们希望细分模式应具有良好的性质,可以保存多分辨率的模式并实现子三角形级别的细分粒度.本文算法使用类似文献[20]中14的细分模式,与之不同的是,本文结合MeshColors[8]中的模式性质,提出一种新的细分模式,称为2-幂次MeshColors细分模式.这种模式不仅可以表示多分辨率下各种复杂的模式,而且仅需要很少的数据存储,下面详细介绍一下这种细分模式及其性质.2-幂次MeshColors结构类似MeshColors结构,2-幂次结构仍然使用均匀分布的三角形采样点作为细分后的子三角形顶点,见图2.不同的是,MeshColors结构仅使用一个参数R作为三角形的分辨率,虽然对每个三角形可以有不同的R,但是对一个三角形内部,它始终保持均匀细分,因此无法控制子三角形级别的细分.2-幂次结构改进了MeshColors结构,定义M为2-幂次结构的最大层级,它与R的关系为图22-幂次细分结构(不同分辨率M下的完全细分模式.顶点采样(大三角形顶点)、边采样(浅色点)、面采样(中间色点))我们的细分规则为一分为四,即对每个子三角形Ti,如果需要细分,则在其边的中点插入采样点,从而得到3个新的采样点和4个新的子三角形.给定一个三角形的2-幂次最大细分级别M,我们可以计算每个顶点、边、面内的最大采样数:由于所有的采样点都是均匀分布的,我们使用重心坐标来表示这些采样点,类似MeshColors结构,我们仍然使用两个索引i和j来唯一表示一个三角形内的采样点:其中0i2M且0j2M-i.这样,给定一个三角形的3个顶点(有序),我们就可以唯一确定当前层次M下的所有可能的采样点集.所有可能的细分模式都是由这些采样点所组成的三角形构成,如图3所示.图32-幂次结构采样分布(M为2时的所有找最近的子三角形顶点采样给定三角形表面点p,需要快速找到当前级别M下所处的子三角形的3个顶点.MeshColors中提到,很难使用一个统一的公式来求解这个问题,因此我们将所有细分的三角形分为2类:上三角和下三角,见图4.正如MeshColors中提到的,首先需要计算2个值:其中P是表面点p的重心坐标.如果ω=0,p点刚好落在子三角形的顶点上,Page5其重心坐标为B;如果ωi+ωj+ωk=1,p所处的子三角形为上三角,顶点重心坐标为Pi+1,j、Pi,j+1、Pi,j,如图4(b);如果ωi+ωj+ωk=2,p所处的子三角形为下三角,顶点重心坐标为Pi,j+1、Pi+1,j、Pi+1,j+1,如图4(a).找所有细分子三角形顶点采样给定一个细分层次M,需要求出当前三角形所有子三角形的顶点重心坐标及顺序,我们使用如下的公式求解:子三角形(上三角):其中0i2M,0j2M-i.子三角形(下三角):其中32M,0i2M-2,1j2M-1-i.5三角形细分模式决策算法5.1细分模式决策与其它的三角形细分方法相比,本文算法使用一种间接细分策略,即我们没有直接在物体空间对三角形进行细分.我们首先在2-D纹理空间,使用图像处理的方法找到需要细分的三角形并决定其细分模式,之后才真正细分.整个细分模式决策包括3个子阶段:(1)基于信号的光照图采样分类;(2)逐像素的细分模式决策;(3)逐三角形细分模式决策.5.1.1基于信号的光照图采样分类要快速地决定每个三角形的细分模式,有两个问题需要解决:(1)决定一个三角形是否需要细分;(2)决定三角形要细分到什么程度.我们需要约束细分规则,防止细分过度.对于第1个问题,最简单的解决方法就是对模型进行密集采样,然后遍历每个采样,判断该采样的颜色值和周围颜色值的差别,从而判断所属三角形是否需要细分[10].不过采样的数量、位置直接影响到最终的细分结果,而且由于物体本身形状拓扑复杂性,采样相对比较困难.本文算法使用光照图纹理作为采样集,其中每个像素对应的物体空间点作为采样点.通过控制光照图纹理的大小Res,可以控制采样点的个数,从而影响整体细分效果.另外,为了进一步提高效率,本文首先在GPU里对初始光照图纹理进行分析,找出其高频的像素,记录到输出标记纹理(MT)中.算法首先使用FBO(帧缓存对象),在2-D纹理空间绘制每个三角形,顶点位置通过其纹理坐标与纹理大小Res的乘积来计算.图形硬件光栅化自动把每个三角形离散成片元,作为一个采样点.在片元处理器里,我们访问该片元对应的光照图纹理中的颜色,同时访问其邻域颜色.通过采用类似Vedel等人[21]的方法,将颜色梯度大于一个阙值的片元,标记为高频片元.我们定义这个阙值为Hfvalue,并且可以通过调节它来控制细分的深度以及最终的效果.这一步可以通过GPU快速的完成,大大减少下一步细分决策所需要的计算量.由于光照图纹理本身存在大量的无效像素(不对应任何物体表面点的像素),这步结束时得到的标记纹理可能会产生不正确的情况,见图5.不过我们能够通过三角形保守光栅化和使用一个标记位来标记无效的像素.图5纹理空间的高频采样搜索(正确的高频区域(中间白色框内)、错误的区域(灰色)和输入的三角形)5.1.2逐像素的细分模式决策上一步结束时,我们得到一张标记纹理(MT),其像素保存了每个采样的标记值.一共分为3类像素:无效采样、有效低频采样和有效高频采样.通过使用MT和片元着色器,我们可以解决上一节提到的两个问题.与上一步类似,算法依然使用FBO,在2-D纹理空间绘制每个三角形,同时绑定MT作为输入纹理以方便查询.在片元着色器里,我们逐像素地判断所属三角形的细分模式,进而输出结果.由于算法的细分规则是1/4细分,即每次细分一个子三角形都会产生4个小三角形,我们使用四叉树编码来保存细分模式,下面详细描述四叉树编码的定义和逐像素构造过程.给定一个待细分的三角形(或子三角形)Ti,只可能有两种形式:上三角和下三角.一旦确定要细Page6分,按照本文的细分规则,将被细分为4个子三角形.为了编码方便,我们为每个细分的子三角形定义一个位置符号Tpos,且1Tpos4,见图6.图6上三角(左图)和下三角(右图)(数字代表Tpos)我们使用完全四叉树编码来保存每个三角形的细分模式.四叉树每个节点代表一个可细分的子三角形.四叉树的第1层根节点代表M=1的三角形模式,往下第M层共有4M-1个节点.每个节点保存一个数据值,代表当前节点所对应的三角形是否需要细分(0:不需要细分;1:需要细分).对M层上的某一个节点n(1n4M-1),如果需要细分,则其M+1层对应的子节点为4n-3、4n-2、4n-1、4n,且其分别对应的Tpos为1、2、3、4,见图7.图7三角形细分模式与对应的四叉树(上面一行代表不同最大细分层次下的一种三角形细分模式;下面一行代表其对应的四叉树表示,我们的四叉树都是完全四叉树,为了显示目的,这里隐藏了许多为0的节点)有了四叉树编码方式,下一步我们需要考虑如何在GPU里使用它.由于片元着色器输出是像素,因此我们选择RGBA32格式纹理作为FBO的输出.另外为了描述简单,我们假定最大细分层次M=4,这样我们使用一张纹理就足够了.后面的实验证明,对于大部分的模型,M=4的细分级别已经可以满足需求.给定一个RGBA32格式的片元,我们定义编码表示如图8所示.其中每个字段占用的位数和代表的含义如表1所示.字段名所占位数RG1G2G3G4B和A上面介绍了四叉树编码方式,下面描述如何逐像素的构造各自的四叉树模式.算法伪代码如算法1所示.算法1.逐像素的细分模式决策.1.对当前片元p计算对应的纹理坐标TCc2.读取MT纹理获得当前片元对应的标记Mc3.根据Mc对当前片元分类:4.情况1:Mc是无效像素,输出无效像素,中止;5.情况2:Mc是有效像素6.迭代:找到p在当前层次M下最近的子三角形Tnear7.计算p在Tnear里面的重心插值颜色Ci8.从MT中获取p的颜色Cp9.情况1:Ci-Cc>Hfvalue10.情况2:Ci-CcHfvalue(1)在纹理空间绘制每一个三角形,同时给三角形绑定3个uniform变量,存储三角形3个顶点的坐标v1、v2、v3(纹理空间).在片元着色器里,给定一个片元,我们把它看做表面的一个采样点p,使用式(6)~(7),在光照图纹理空间找M=0层次下最近的子三角形Tnear3个顶点重心坐标索引p1、p2、p3.(2)访问光照图纹理,获取p点对应的颜色值Cp.(3)根据重心坐标p1、p2、p3和原三角形顶点v1、v2、v3,计算子三角形Tnear顶点的纹理坐标,访问光照图,获取p1、p2、p3对应的颜色值Cp1、Cp2、Cp3.(4)计算p点在Tnear中相对与p1、p2、p3的重心坐标,并根据Cp1、Cp2、Cp3,计算p的重心插值颜色Ci.(5)通过比较Ci与Cp,判断是否需要继续迭代进行下一层次的计算.如上述所示,对于层次为M的子三角形Tnear,如果是高频采样,就需要对其进行细分,并执行下一层判断,同时要修改此时三角形对应的四叉树编码,根据M我们可以定位要修改的位置在哪个字段(见Page7表1),下面还需要确定具体要修改哪一位,这就需要判断Tnear在其上一级父三角形Tparent下的位置Tpos,我们使用如下公式来计算(见图9):(1)I(Tnear,1)=I(Tparent,1)×2且(2)I(Tnear,2)=I(Tparent,2)×2且(3)I(Tnear,3)=I(Tparent,3)×2且(4)其它情况,图9给定子三角形Tnear(△ABC),判断其在上级图10逐三角形细分模式决策(其中,(a)为绘制覆盖LT的大量顶点,深色点组成的三角形索引为1,浅色点组成的首先绘制大量的顶点,其数量为Res×Res,如5.1.1节所示,Res为光照图的大小同时也是LT纹理的大小.通过设置好每个顶点的位置,保证这些顶点刚好覆盖LT大小的一个矩形区域.为加速性能,我们使用VBO(顶点缓存对象)来存储顶点.输出是一张1-D纹理,其大小对应三角形的个数.每个像素保存该索引下三角形的细分模式.在顶点着色器里,计算出每个顶点对应LT纹理中的纹理坐标,从中读取三角形细分模式和三角形索引,通过索引计算该三角形正确的输出位置,从其中I(Ti,x)表示三角形Ti中的第x个顶点的重心坐标i分量,J(Ti,x)是j分量.根据式(10)~(13),可以快速计算出每个需要细分的子三角形在四叉树编码里的位置,从而修改标志位.算法1结束后,就得到了当前片元作为采样所决定的三角形的细分模式,刚好对应于一棵单支四叉树,最后通过四叉树编码输出为片元颜色.5.1.3逐三角形细分模式决策上一步结束时,得到了一张逐像素细分模式纹理(LT),下面需要计算每个三角形的细分模式,即将每个三角形所属所有的片元对应的细分模式合并,其实质是对多个单支四叉树的合并操作,可以通过发射法(Scatter)或吸收法(Gather)来实现.当前的片元着色器无法实现随机写操作,不符合发射法要求;如果用吸收法,需要多个Pass的渲染,由于每个三角形所包含的采样个数不同,效率较低,因此也不适合吸收法.本文算法使用顶点着色器来实现单支四叉树的合并操作,流程见图10.而修改顶点的位置gl_Position.同时将细分模式通过varying变量传递给片元着色器.片元着色器仅需要输出顶点对应的三角形细分模式.最后通过硬件逻辑位或(GL_OR)可以保证不同的细分模式编码合并在一起,即不同的单支四叉树合并为一个四叉树.这样就得到了每个三角形正确的细分模式.5.2问题分析5.1节3步之后,得到的是一张1-D三角形细分模式纹理(SLT),里面存储每个三角形的细分模式,下面需要讨论其中的几个问题:Page8第1个问题,在5.1.3节中,要从LT里读取细分模式和三角形索引,索引应该是从1开始,最大到三角形的个数.不过会有一些像素读取到的索引值为0.这是因为光照图本身会存在大量的无效像素,这些像素会影响之后的步骤,从而出现不属于任何三角形的像素,即索引为0.为了处理这类像素,有两个方法:(1)在顶点着色器里,将这类像素通过设置gl_Position,使其投影到视口之外,从而不会产生片元;(2)重新设置输出纹理的大小为三角形的个数+1,多余的一个像素用来保存这些无效像素点.本文算法使用第2种方法,因为它还可以辅助统计无效像素的个数.第2个问题,在输出纹理SLT里会出现空洞,即部分位置没有三角形索引信息.理论上讲,每个三角形都有一定的面积,其在光照图纹理里应该都占有一定数量的像素,因此在SLT里面都应该能找到对应的位置信息.不过由于输入的光照图一般经过展UV操作和烘焙之后生成,这两个阶段的误差会造成部分三角形在光照图纹理中的投影非常小,甚至不到一个像素,因此产生上述问题.不过,通过实验可以发现,这些特殊三角形在物体空间往往也是面积很小或者狭长的形状,我们直接为这些三角形设置M=0的细分模式,并且发现这样并不会影响算法效率和效果.第3个问题,SLT作为1-D纹理,其大小也受到当前图形硬件的限制.MeshColors[8]中提到,目前1-D纹理的最大尺寸为4096,即我们只能处理不超过4096个三角形的模型.这个问题可以通过多pass渲染或者使用2-D或3-D纹理的方法解决.我们实现了这两种方法,发现后者的效率要更高,另外实验中使用的模型三角形数一般都不超过百万个,因此一张2-D纹理可以满足要求.另外由于算法依赖硬件片元逻辑位或操作,当前的图形硬件还不支持RGBA32浮点格式纹理的片元逻辑操作,因此这一步我们使用的是RGBAUI32整数纹理.6三角形细分及缝合目前为止,我们已经得到了每个三角形的细分模式,下一步需要进行三角形的细分.如果只是简单的按四叉树编码细分,会产生T-vertices孤立点[19],见图11(a)浅色点.为了消除孤立点,还需要对三角形进行适当的缝合操作.许多文献(如文献[19])使用塌陷方法来处理孤立点,这种方法虽然可以解决一定的问题,但是不适合我们的细分模式,另外可能会带来实时渲染时的光照不连续.我们提出一种针对2-幂次细分模式的缝合方法.图11三角形细分与缝合操作((a)△ABC内部非均匀细分,与其周围三角形也有着不同的细分模式,产生T-vertices孤立点(浅色);(b)上图:△ABC采样点生成,内采样(中间色)和邻接额外采样(深色);下图:△ABC子三角形遍历及内部额外采样点生成(浅色);(c)基于采样点的子三角形缝合操作;(d)△ABC不存在额外采样点,正常细分)给定初始三角形△ABC,首先从SLT中读取其细分模式.根据细分模式中的四叉树编码,我们不直接细分三角形,而是先遍历其所有的子三角形,同时建立如下数据结构:原三角形:△:index,Adj1,Adj2,Adj3index为三角形索引号,Adj1,Adj2,Adj3是三角形三条边的邻接三角形索引.采样点集S:S={s1,…,sn}s:i,jS为所有子三角形的顶点采样重心坐标集合(保存i和j索引形式).边集E:E={e1,…,en}ex:si,sj,sxE为所有子三角形的边构成的集合,ex为采样si与sj构成的边,不分先后顺序,sx为ex上除端点外的其它采样,即T-vertices孤立点(见图11(a)浅色点).子三角形集合T:T={T1,…,Tn}Tx:si,sj,sk,ei,ej,ekT为所有子三角形的集合,子三角形Tx保存3个顶点在S中的索引si、sj、sk和三条边在E中的索引ei、ej、ek.Page9遍历完所有的子三角形,首先生成三角形内部采样点集S,如图11(b)中中间色点.之后,对△ABC,的3条边,找其邻接三角形中对应边上的采样点,插入到S中,可能会形成一些边界上的孤立点,如图11(b)中深色点.接着遍历边集E,对每一条边e,在S中找该边上的T-vertices孤立采样点集Sx,如图11(b)中浅色点.这里给定一个采样点重心坐标si,需要判断它是否在边e上,我们采用如下方法计算.将三角形的边分为3类(见图12):平行线:i1=i2右斜线:j1=j2左斜线:其它情况其中,i1、j1和i2、j2是边的顶点重心坐标索引.给定一个采样si,其重心坐标索引为ix、jy,针对不同类型的边,可以通过下面公式判断其是否在边上:采样在平行线上:ix=i1=i2且jy∈(min(j1,j2),max(j1,j2))采样在右斜线上:jx=j1=j2且ix∈(min(i1,i2),max(i1,i2))采样在左斜线上:(ix-i1)×(j2-jy)=(i2-ix)×(jy-j1)且((i2-ix)/(ix-i1))>0图12三角形边e分类(空心点为端点,黑色点为边上采样点)到此为止,我们已经计算出△ABC在其细分模式下所有子三角形以及其每条边上的T-vertices孤立点.下一步我们可以对存在孤立点的子三角形进行缝合,具体方法如图11(c)所示.算法首先遍历子三角形集合T,对每一个子三角形Ti,如果其边上不存在T-vertices,就找下一个子三角形;否则首先找到Ti中T-vertices最多的边e,然后找其最靠近中心的采样点s,连接s于Ti对角顶点,构造新的边enew,插入E,它将子三角形Ti,分成两个新的三角形T1和T2.将T1和T2插入T,同时删除Ti.继续遍历,直到T都遍历完为止.经过上述细分和缝合操作,我们实现三角形的自适应细分模式同时又保证三角形之间的连续性和避免T-vertices孤立点.7顶点颜色优化计算细分后的三角形,其顶点颜色可以通过对光照图进行简单点采样、局部过滤平均采样、或者采用最小二乘优化的方法计算.正如文献[10]中提到的,使用最小二乘最优化计算得到的顶点颜色,经过插值后效果最好.这种方法可以避免细分过度,同时可以达到近似纹理烘焙的效果.和文献[9-10]类似,我们也是用最小二乘优化方法.不同的是,我们不需要像文献[10]中在物体空间做泊松采样.我们使用光照图纹理作为采样集.给定采样集:其中P是光照图纹理中的采样集,pi是其中的一个像素采样,n是P中的有效像素采样数.我们可以使用参数Res来控制n的大小.假定I(p)是p点的颜色,f(p)是p在所属三角形内的重心插值颜色,则最小二乘错误率E可以表示成:为了计算E的最小值,对其两边求导可以推出如下形式的线性方程:其中,其中,S△是三角形的面积和公式,Tij是包含顶点i和j的三角形集合,Fi是包含顶点i的三角形集合,Hi是Fi对应光照图中的采样集合,bary(p,i)是相对顶点i的重心坐标分量.我们使用UMFPack开源数学库求解方程(18).最后可以计算出最小二乘意义上的顶点优化颜色.8实验结果和分析本文算法的实现平台为Core4X26003.4GHzCPU,4.0GBRAM,NVidiaGeforce550GTXGPU.编程语言为C++和Opengl.GPU着色语言使用GLSL.为了高质量的视觉效果,所有的实验均采用8倍MSAA(多重采样反走样)技术.Page10我们的目标之一是权衡效率与效果,相对纹理烘焙可以节省大量的实时存储.我们使用3个场景来验证算法效率和效果:简单的平面场景,见图13;精细的人头模型,见图14;复杂的室内场景,见图15.我们实现了点采样顶点颜色方法,最小二乘顶点颜色计算方法和纹理贴图的方法,并且与本文算法做了效果与效率的对比.理论上讲,点采样顶点颜色的方法(类似顶点烘焙)需要最少的存储并占用最少的顶点.其缺点就是受当前硬件只支持线性插值的限制,效果并不好,如图13和图15.最小二乘顶点计算方法通过全局最优最小二乘计算,对于大部分足够细分的模型,可以产生不错的视觉效果,但是不太适合包含大三角形的模型,如图13.本文算法结合自适应细分技术,经过快速的后处理工作,不仅可以达到较高的实时帧率,还可以近似纹理烘焙的效果,见图15.图14中,我们使用一个包含5.8K顶点,11.5K三角形的精细人头模型来验证算法.从图中可看出,最小二乘方法也可以达到近似的效果,不过在耳朵和嘴巴处的细节表现不如本文的算法.上述3个实验表明,本文算法更适合于粗糙模型和细节的显示.表2记录了实验的量化数据对比.其中顶点包括了纹理边界复制过的顶点(拥有不同纹理坐标的同样的顶点).本文的光照图均使用3dsMax和Maya渲染,渲染器使用Vray和Mentalray光线跟踪渲染器.纹理格式为RGBA8.纹理分辨率Res使用标准的1024大小.从表2中可以看出,算法最耗时的步骤主要是CPU中细分缝合和优化顶点颜色计算,但都控制在1s以内.通过自适应的增加少量的三角形,算法可以节省80%以上的存储,并可以提高1%~9%以上的帧率.本文算法其中一个优点就是可以通过Hfvalue灵活地控制细分度以及最终的效果.我们使用一个3K三角形的粗糙模型来验证.Hfvalue设置越小,我们可以获得越精确的实时效果,图16演示了不同参数控制下的细分效果.最后一个对比实验,本文算法与逐三角形的均匀细分的方法做了对比(类似文献[18]与文献[20]中的细分规则),见图17.这些自适应方法虽然可以控制不同三角形的多分辨率,但是对三角形内部,往往采取均匀细分方法,这样会产生大量的三角形.本文算法可以控制子三角形级别的自适应细分,对三角形内部也支持非均匀细分.图17可以看出,在设定同样最大细分层次下,本文算法不仅可以保持绘制效果,而且可以减少接近15%的三角形数.Page11表2环境遮挡烘焙后的测试场景(Tps:点采样顶点颜色计算;Tls:最小二乘顶点颜色计算;Tours:本文算法;Ttex:纹理方法.步1~步3表示本文算法GPU中的3个步骤.细分与求解包括三角形细分缝合以及优化顶点颜色计算时间.Final/rate记录了实时绘制时的帧率及相对纹理方法的帧率增加倍率(黑体百分数).最后1列是本文算法与纹理方法在存储量上的对比和减少存储的百分比(黑体百分数))步1步2步3细分与场景平面25/15432/282137013700.004ms0.002ms0.84ms0.82ms1355/2%13305.23K/人头5.8K/房间9.8K/图17本文子三角形级别的细分算法与三角形级别均匀细分算法的对比(三角形细分最大层次设定为M=4,左列:三角形级别均匀细分效果与线框图(共20528个三角形);右列:本文子三角形级别细分效果与线框图(生成17032个三角形)Tours为了验证算法的适用性,我们测试了其它3个不同类型光照贴图的场景:环境遮挡烘焙下的室外城堡、面积光源影响下的斯坦福Bunny模型软阴影效果场景、间接光照下的CornelBox场景,见图18.本文算法适用于许多基于光照贴图的场景的实时渲染.图18本文算法处理不同方式的烘焙贴图后的效果Page129总结及未来工作本文提出一种基于光照图纹理的自适应三角形细分算法,可以在节省存储的同时,满足实时渲染的需求.通过快速的后处理工作,我们可以通过对模型做最小化的修改,保证其细分后可以达到纹理烘焙级别的视觉效果.顶点烘焙在大三角形之上的走样可以完全避免,另外通过自适应的细分模式,可以控制子三角形级别的细分,比起传统的均匀细分来说,还可以减少细分后的三角形数量.最后,通过一个控制参数Hfvalue还可以灵活地控制细分效果.算法实现简单、鲁棒,而且适合于当前的图形硬件.目前该算法可改进方向主要有2个:(1)由于算法在GPU计算逐三角形的细分模式时,采用完全四叉树编码保存细分模式,并使用RGBA32UI格式纹理作为输出,一张128位的纹理最多只能保存M=4层次的细分模式(R组件要保存三角形索引),虽然这可以满足大部分需求,但对于一些具有高频信息的超大三角形,层次4的细分还不足以很好地恢复光照信息,如果使用多张纹理保存模式,又会影响GPU步骤的效率;(2)算法使用细分后的三角形的顶点颜色来逼近光照图信号,对于大规模的场景,还是会产生大量的细分三角形,CPU到GPU的数据传输以及光栅化本身可能会成为实时绘制的瓶颈.因此,解决这两个问题将是我们下一步的工作重点,我们现在也在考虑结合类似文献[18]中预存模式的方法来改进.最后,我们希望该方法可以应用于光照烘焙、产品设计与展示、建模辅助、家居设计等实时预览系统.在此基础上,我们计划开发一种场景可视化和实时预览工具,作为设计和建模的辅助工作.致谢非常感谢匿名审稿专家的宝贵意见!
