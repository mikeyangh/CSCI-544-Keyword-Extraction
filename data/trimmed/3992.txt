Page1过程间循环路径剖析方法王璐璐李必信(东南大学计算机科学与工程学院南京211189)(东南大学计算机网络和信息集成教育部重点实验室南京210096)摘要该文在过程内剖析技术的基础上提出了一种新的过程间路径剖析方法PIP,能够精确地编码过程间路径和方法级执行序列.为了有效地处理方法间多态等复杂调用,文中提出了一种新的剖析模型PCCG(PolymorphicClusterCallGraph),能够精确描述多态信息,并且支持以“方法集簇”的方式对多个被调用方法统一处理,简化调用结构,减少剖析耗费.基于PCCG模型,PIP方法能够精确地进行过程间路径剖析,并可采用多种方法集簇策略来优化剖析效率.理论分析和实验结果表明,PIP方法具有较高的精确性和循环处理能力,且各种集簇策略能够适应不同的应用情况,有效地提升效率.关键词路径剖析;过程间路径;多态;动态分析;软件测试1引言路径剖析是动态软件分析中的一个重要领域,Page2式使得目标程序在执行的同时可以进行编码的计算,在执行完毕后统计各个路径编码的出现频率,进而通过解码得出最终的路径剖析结果.故路径剖析主要可以分为两个阶段:静态的路径编码和插装实现,以及执行时对路径频率进行统计.路径编码的精确性和完备性决定了剖析结果是否精确和完整.1996年Ball和Larus提出了首个路径剖析技术EPP(EfficientPathProfiling)[1],该方法可以精确、高效地剖析过程内所有无环路径.此后,路径剖析领域相继出现了多种方法,或致力于提升循环处理能力,或致力于扩展剖析的应用场景,这些结果已广泛应用于编译优化、调试、测试和程序理解等多个领域[2-7].但是其中大部分方法将剖析的目标限定为过程内路径,即不涉及方法调用的路径.由于方法调用广泛存在于程序执行之中,过程内的剖析结果在很多应用领域不能够提供充分的信息.在过程间路径剖析方面,研究人员在过程内剖析算法的基础之上进行扩展,纳入对方法调用的编码,使得不同的过程间路径对应于不同的编码,以获取其剖析结果.IPP(Inter-ProceduralProfiling)方法在EPP方法的基础之上做了改进,在单个过程内部使用EPP探针进行插装,而每个过程的调用边界处使用额外的运算方法将过程内无环路径编码与过程间调用边的编码相整合,以完成过程间剖析[8].但是IPP方法具有两个主要的缺陷:首先,由于EPP方法本身不剖析循环路径,所以IPP方法难以处理循环;其次,在整合编码的过程之中,IPP需要对所有可剖析的静态路径进行枚举以完成紧凑编码,故其应对复杂流图时耗费过大.Tallam等人在其提出的过程内有环路径的近似剖析方法ExPP(ExtendedPathProfiling)的基础之上,将之扩展为过程间剖析方法[9].该方法的主要缺陷在于:由于ExPP方法本身是非精确的,且在循环处理上有限制,所以其扩展后的剖析方法也在精确度和路径循环上有限制.总之,现有的过程间剖析方法或者能够精确剖析无环路径,或者能够近似剖析带有少量循环执行的路径.基于此,为了满足过程间有环路径的精确剖析,本文基于PAP方法[10](ProfilingAllPaths,一种过程内循环路径的精确剖析方法)提出了PIP(ProfilingInter-proceduralPaths)方法,用于剖析包含任意有限次循环体执行和任意有限次方法调用的路径.本文的主要贡献有3个方面:首先,基于方法调用图模型提出了一种新的过程间控制流图模型PCCG(PolymorphicClusterCallGraph),能够描述方法调用中的多态信息,并支持采用集簇的方式同时处理多个被调用方法,以改善效率.其次,基于PCCG模型将PAP方法扩展为PIP方法,以精确剖析过程间有环路径,并提出集簇策略以优化剖析性能.最后,使用基准测试程序对PIP方法和相关方法进行了实验比较,验证其有效性,并使用随机生成的PCCG图对如何选择最优集簇策略的问题进行了探索.本文第2节介绍相关背景知识和技术;第3节讨论PIP的实现细节;第4节给出实验评估及结果;第5节对全文内容进行总结.2研究背景本章节内容安排如下:2.1节介绍研究动机;2.2节回顾相关背景技术,包括EPP方法和IPP方法;2.3节介绍PAP方法及其在过程内剖析方面应对编码溢出时所采用的断点机制.2.1研究动机经过几十年的发展,软件的应用日益广泛,软件的复杂度也日益提升.从程序结构的角度来看,过程间调用已是软件中几乎必不可少的要素之一.路径剖析是收集软件中执行路径频率的方法,其结果是软件分析、理解和改进的基础,剖析价值与所针对的路径息息相关.传统的过程内剖析方法只能针对单过程程序进行,在软件复杂化的今天应用效果有限;已有的过程间剖析技术尚不成熟,或者不能处理程序中广泛存在的循环和复杂调用,或者不能给出完全精确的结果.本文以过程间路径剖析为目标,旨在提升剖析的应用价值,包括可剖析路径的广泛性和剖析的精确度.主要面对的问题如下:复杂调用;(1)如何处理过程间调用,特别是递归、多态等(2)如何处理过程间路径中的循环;(3)如何在剖析的过程中保持精确.2.2研究现状为了收集执行路径的频率,现有技术普遍采用插装的方式实现路径编码的计算和频率统计.以Page3EPP方法为例,其使用一个整型变量r进行编码,在执行过程中对r进行累加操作,每条路径的编码即为该路径中所有边的权值之和.相应插装的编码计算语句形式为“r··=r+i”,其中i为无环控制流图中边的权值,由Ball-Larus权值分配算法得出,可以保证无环图中所有路径的唯一编码,如图1(a)所示,图中“Nx”表示经过节点x的静态路径总数,据此可以计算每条边的权值.这样插装完毕之后,在目标程序执行的同时可以计算相应的路径编码.针对图2(a)中的控制流图,EPP插装结果如图2(b)所示,变量i对执行的路径编码进行计算,每条路径编码的出现频率统计在数组count之中,其中数组下标对应路径编码,数组中存储的值即为路径执行频率.针对有循环的程序,EPP不对执行了循环的路径进行编码,如图2(e)所示.图2EPP和PAP插装结果(插装代码用下划线标识)EPP是一种过程内剖析方法,IPP[8]将之拓展至过程间剖析场景之中.其思想在于按照过程间调用关系,将各个过程内部的控制流结构图进行衔接,得到全局控制流图SuperGraph,并使用类似EPP的算法在SuperGraph上进行各个节点和边的权值计算,进而插装相应的探针.如图3(a)所示,方法method1中的节点A调用了method2,所以节点A到method2入口节点C的调用边可以视为节点C的入边,使用EPP算法时,需要将节点A的权值(未考虑调用关系时计算的权值)累加到节点C的权值之中;同样,method2的出口节点D对节点A的后继节点B的返回边可以视为B的入边,需要将节点D的权值累加入节点B的权值之中.节点的权值计算完毕之后,即可得相应的边(包括调用边和返回边)的权值.由于IPP未能改进EPP处理循环的能力,故其不能剖析带有回边的过程间路径,当回边执行时,IPP即终止该次执行,不将相应路径纳入频率统计之中.如图3(b)所示,IPP定义了一个全局出口节点Global-Exit,并将所有的循环回边修改为指向该节点,实际执行之中不会执行任何的回边.2.3PAP方法PAP方法的目的在于增强过程内剖析方面对循环处理的能力[10].与EPP等方法不同,PAP插装的语句形式为“r··=rn+i”(简记为n(i)).PAP方法对于控制流图中入度大于1的节点的所有入边进行权值分配,分配的n即为该节点的入度,i为从0开始的连续整数.如图1(b)所示,对于节点d的3条入边依次分配3(0),3(1)和3(2),当程序执行相应的入边时,将路径编码乘以3后再分别加上0,1或2.这种编码方式可以对过程内的任一静态路径分配一个唯一的编码,保证剖析结果的精确性.PAP插装过程与EPP类似,区别在于编码的计算方式,如图2(c)所示.使用乘加结合的编码方式可以处理包含循环任意有限次执行的路径,如图2(f)所示,可以保证每条静态路径具有不同的编码,进而保证剖析结果的完整和精确性.在另一方面,由于PAP方法不限制循环执行次数,在实际执行过程中可能会发生编码过大,变量溢Page4出的情况.针对这一问题,文献[10]提出了断点机制,当溢出发生时,将未溢出的编码和相应位置记录到编码栈之中,并重置相应变量取值,继续编码.相应的,在解码过程中,每个断点记录了所执行路径的一个片段,将各个断点对应的路径片段依次衔接,即可获得编码所对应的路径.同时,PAP方法剖析过程中的编码存储耗费和解码耗费与相异断点数目相关(即断点的重复性可以提升剖析效率).3过程间路径剖析本章节内容安排如下:首先,由于PAP方法可以处理过程内的路径编码,为了叙述的简便,3.1节介绍如何等价地忽略过程内部结构,以简化过程间剖析.然后,3.2节将PAP方法扩展到过程间剖析之中,并使之能够处理多态调用.每条过程间静态路径被编码为不同的整数,而当某一条路径被执行时,其编码随着执行进行计算,当该路径执行完毕后,计算所得出的一个或多个整数即为其唯一的编码.最后,3.3节提出一种过程间剖析的控制流模型PCCG(PolymorphicClusterCallGraph)以描述多态调用的情况,据此3.4节提出过程间路径剖析方法PIP以及使用方法集簇的方式来优化剖析效率.3.1忽略过程内部结构在不包含多态调用的情况下,(添加返回边后的)过程间控制流图和过程内控制流图没有本质的区别.类似于IPP方法中将各个过程内部结构组合以获取全局控制流图的方式,所有过程的CFG,无论有环或无环,可以按照过程之间的调用关系组合为全局控制流图,这样每一条过程间路径可以精确地反映在全局控制流图之上.这样组合后的全局控制流图的结构和单个过程的CFG相类似,可以应用PAP方法保证任意两条不同静态路径具有相异的编码.对于包含多态调用的情况,每个过程内部结构可以独立应用PAP探针进行编码计算,这样将PAP方法扩展到过程间剖析的工作即可仅着眼于方法调用的编码和插装.因此,在PAP精确剖析过程内路径的情况下,可以专注于过程间控制流的剖析.3.2拆分调用边以处理多态在包含多态关系的过程间控制流图上,每条可能发生多态调用关系的方法调用边都可以等价地拆分为多条普通(无多态)调用边,其中每条普通调用边表示该多态调用边在执行过程中的一种可能调用关系.经过这样的边替换后,有多态关系的控制流图可以等价地转化为无多态关系的控制流图.如图4所示,B类继承了A类,并且覆盖①了A类中的方法m,那么当C类中的方法f显式地调用A类中的方法m时,由于面向对象软件中的动态绑定机制,在实际执行过程中如果该方法调用的当前对象类型为B,那么调用的方法即为Bm.为了处理这样的多态调用,我们可以按照动态绑定类型集合对该调用边进行拆分,以保证拆分后的每条边都具有唯一的、确定的调用目标方法.在图4中,由于变量a的该多态调用边可以拆分为两条边,一条指向Am,另一条指向Bm,相应的源代码也需要进行修改,按照变量a的各种可能类型依次进行判断.要注意的是,进行判断时,各种类型有顺序要求:子类型需要在父类型之前判断.因此,完成多态调用边的拆分还需要对继承树上的各个类型进行逆拓扑排序.使用如上的拆分方式可以精确处理多态调用带来的剖析问题.但是却具有如下的缺点:首先,调用的边的拆分需要对应到源代码的修改之中,这对于多态关系比较复杂的情况可能会带来较高的耗费;其次,该拆分增加了调用边,将控制流图的结构变得更复杂,很可能会导致剖析需要更多的探针来实现.为了应对拆分调用边所带来的以上问题,后文中我们设计了将多个过程进行集簇的方式来处理多态问题.3.3剖析模型PCCG图为了描述多态调用信息,我们提出了一种新的方法调用模型———PCCG图,该图是一个有向图,由①Overwrite,指子类重定义了父类中的同名方法.用于多态Page5以下4个集合组成:包含一个或多个方法;由一个方法指向一个方法簇;包含在一个且仅一个方法簇中;(1)方法簇集合CS(ClusterSet),每个方法簇(2)方法集合PS(ProcedureSet),每个方法都(3)调用边集合CE(CallEdges),每条调用边(4)返回边集合RE(ReturnEdges),每条返回边从被调用方法指向调用者所在的方法簇.图5给出了一个PCCG的示例.图5(a)表示了一个具有5个方法的调用图,其中有两个(显式)调用关系,分别从A指向C,从B指向D;其中包含3个覆盖关系(虚线所示):B覆盖A,D覆盖C,E覆盖D.在这些信息(方法集合、调用关系、覆盖关系)的基础之上,我们可以按照如下步骤计算相应的PCCG图:(1)在调用图上添加潜在的调用边(即拆分多态调用边).图5(a)中在前述信息基础上增加了3条调用边:AD、AE和BE.(2)在拆分多态边的基础上,按照不同的集簇图6PIP关键步骤在PAP方法中,组成路径的边的形式是从CFG节点指向节点;而在PIP方法中,方法调用边、返回边是从一个方法节点指向一个方法簇.PIP使标准对方法进行集簇,然后删除冗余的调用边,如图5(b)所示.图5(b)中将方法A和B划归一簇,将C、D和E划归另一簇,在此集簇关系下,调用边被重约简为2条.(3)在PCCG上添加返回边,如图5(c)所示.如果一个方法A调用了某个方法簇C,那么C中的每个方法都有一条返回边指向A所在的簇,即返回边也是从方法指向方法簇.以上步骤将多态方法调用信息转化为PCCG的过程中是安全的,即所有的调用可能性均包含在转化后的PCCG图中;但是该过程不是精确的,因为在集簇的过程中可能添加了某些调用可能性,如原本方法B不可能调用方法C,但是在PCCG图上无法得出这一信息.因此,PCCG模型是多态方法调用关系的安全非精确模型.由于过程间路径剖析所获取的信息仅针对实际发生的执行,所以PCCG的非精确性并不会导致剖析结果的非精确性,使用PCCG作为剖析模型是合理可行的.3.4过程间路径剖析PIP方法主要的实施步骤如下(图6所示):(1)PIP方法的输入包括过程间控制流图、过程调用关系以及方法的集簇策略,在此输入的基础上,将过程间控制流图建模为PCCG图;(2)在PCCG模型上产生需要插装的探针,对入度大于1的每个被调用簇的n条入边,依次分配探针n(0),n(1),…,n(n-1),并根据探针对待剖析程序源码进行插装;(3)运行插装后的程序源码,并收集执行路径的编码及频率信息,将之解码为剖析结果.用方法簇作为路径中的部分节点却不会降低其路径的描述信息,这是由于后一种形式的路径可以精确地反应出前种路径.Page6因此,在PIP解码路径的时候,方法到方法簇的调用边和返回边可以等价地转化为方法到方法的边,不会导致路径描述由细粒度变为粗粒度,造成任何路径信息的损失.4实验分析本章节对PIP方法的应用效果分两个方面进行测试.首先,在基准测试程序上对PIP方法和IPP方法进行比较,以检验PIP的有效性;其次,由于PIP方法需要应用集簇策略,我们随机生成多种结构类型的PCCG图,对多个策略进行模拟,以期检验出最佳策略,指导实际情况中的应用.4.1检验PIP有效性从前文的理论分析可知,PIP方法可以精确地剖析过程间路径,尤其是带有循环(包括回边和递归调用)的路径.而IPP方法不剖析带有回边的路径,ExPP方法仅剖析带有一次回边执行的路径且给出的是近似剖析结果,且欠缺具体的实现细节.这里我们将PIP方法与IPP方法进行比较.4.1.1度量标准一种剖析方法主要有3个方面的度量标准:效率、完整性和精确性.效率指的是剖析的时间耗费,可以用插装后的程序执行时间来进行衡量;完整性指的是是否能够收集所有执行路径的频率;精确性我们遍历JDK[11]的所有包(package),按照如(1)包的入口方法为static类型,便于构建测试(2)以入口方法及其可达方法构建的调用图必须包含较多的调用边,以更好地对PIP和IPP方法的过程间剖析能力进行检验;(3)入口方法的参数必须易于构建.这样便于计算出其输入域,进而构建较为全面的测试用例进行完整的测试.准则1和2可以自动化实现,准则3需要人工干预.我们首先求解JDK中满足准则1和2的包,然后从中按照准则3进一步选取出最终使用的基准测试程序.JDK中满足准则1和2的包共有14个,如表1所列.最终我们按照准则3选择其中的5个作为测试用程序.表1JDK入口方法及调用边信息GIFImageWriter:computeRegionsGIFImageWriter:createColorTableImageUtil:getUnpackedBinaryDataPaletteBuilder:createIndexColorModel入口方法ImageUtil:getTileSizeImageUtil:setPackedBinaryDataImageUtil:setUnpackedBinaryDataImageUtil:getPackedBinaryDataImageUtil:createColorModelImageUtil:getBandSizePaletteBuilder:createIndexedImageJFIFMarkerSegment:writeICCAdobeMarkerSegment:writeAdobeSegmentJFIFMarkerSegment:writeDefaultJFIFcom.sun.imageio.plugins.gifcom.sun.imageio.plugins.commoncom.sun.imageio.plugins.jpeg4.1.3使用的集簇策略法单独作为一个簇;本实验中我们设计了3个集簇策略:(1)策略SC(Single-procedureCluster),每个方(2)策略IC(InheritanceCluster),如果两个方(3)策略AC(All-procedureCluster),所有方法法之间存在覆盖关系,那么将其划归一簇;包含在一个簇中.指的是收集的路径频率是否精准可信.对于IPP方法来说,由于其在回边处终止,得出的剖析结果不包括所有路径,具有不完整性,而PIP的剖析结果是完整的;对于PIP和IPP,两种方法均是完全精确的.因此,实验的度量标准包括执行时间和IPP方法的不完整性.4.1.2基准测试程序下的准则选取合适的测试程序:用例;图7举例说明了策略AC:图7(b)是图7(a)中方法调用图按照策略AC集簇后的结果,所有方法在同一簇之后,每个调用者方法均只有一条调用边指向唯一的簇,调用边数目减小到极致.4.1.4实验结果首先我们得出PIP方法和IPP方法插装后5个基准程序的执行时间,如图8所示.图中Original系列指的是未插装之前的程序执行时间,IPP系列指Page7的是使用IPP方法插装后的执行时间,PIP(SC)系列指的是以集簇策略SC进行PIP插装的执行时间,其余策略同样.从图8中的结果可以看出,总计5个程序上,有两个程序(computeRegions和getBandSize)PIP方法的时间耗费多于IPP方法,有两个(getTileSize和getUnpackedBinaryData)PIP方法耗费小于IPP,有一个(writeAdobeSegment)PIP和IPP插装均未带来明显的耗费增加.图9展示了IPP方法不能剖析的路径(即循环路径)占总执行路径的百分比,其中在getTileSize和getUnpackedBinaryData上IPP的不完整度分别达到了24.90%和88.06%,而在其它3个程序上未观察到循环路径的执行.相比之下,PIP方法能够精确剖析循环路径,剖析结果更为完整.4.1.5分析与讨论从实验结果可以看出,PIP和IPP方法的应用效果可以按照待剖析程序的类型分为3类:(1)类似于程序writeAdobeSegment,其中的执行非常简单,PIP和IPP方法的插装均不会导致明显的执行时间耗费增加.但是由于PIP方法能够处理有环路径,其剖析能力强于IPP,故在此类程序上应该使用PIP方法进行剖析.(2)类似于程序computeRegions和getBand-Size,其中的程序执行并不会设计循环,由于IPP的时间耗费小于PIP,故应该使用IPP方法进行剖析.(3)类似于程序getUnpackedBinaryData和getTileSize,其中存在大量涉及回边的执行,IPP方法会产生较高的不完整性,为了获取准确的剖析结果,应该使用PIP方法进行剖析.此外,在集簇策略方面,3/5的程序上策略AC的时间耗费小于IC和SC,仅在程序writeAdobe-Segment和getUnpackedBinaryData上耗费略高于SC(约高0.45%和2.3%);所有程序上平均AC较IC耗费降低约11.8%,较SC耗费降低约22.0%.因此在本实验中,使用策略AC进行集簇的效果最好.4.2检验PIP集簇策略4.1小节的实验在基准测试程序上检验了PIP方法的有效性.而在应用PIP方法时,需要给定方法的集簇策略,且不同的集簇策略带来不同的剖析效率(对剖析结果没有影响).因此,我们需要找出较优的集簇策略以达到较好的应用效果.本小节的实验使用随机生成的方法调用图,对多种集簇策略的效果进行模拟和比较.我们按照如下的步骤生成随机的方法调用图:(1)随机生成多个节点,每个节点代表一个方法,并从中选择其一作为程序的入口方法.(2)在各个节点中,我们按照两个参数RP(RatioofcallsbetweeneachpairofProcedures)和PR(ratioofPolymorphicRelations)来随机在节点之间生成调用边.其中RP参数的含义为每对节点之间存在调用边的概率,计算方式为图中调用边总数除以节点总数的平方;PR参数的含义为每对方法之间存在覆盖关系的概率,计算方式为覆盖边总数除以节点总数的平方.连通性,即入口节点需要可达图中每个节点.4.2.1度量标准由于是在抽象层次的PCCG图上进行的实验,不适用于执行时间等度量标准,需要从抽象层次的特性中寻找合适的、具有实际指导意义的度量标准.由于PAP方法的效率与执行中产生的非重复断点的数目有关,非重复断点的数目越小,执行效率越高[10].由于PIP方法使用类似PAP方法的探针,故这里我们沿用此结论,并以非重复断点数目作为(3)为方法调用图添加必要的调用边以保证其Page8衡量各个集簇策略的效率的标准.在PCCG图上,根据集簇关系、路径以及探针插装情况,就可以计算路径编码,进而计算出剖析所需要的独特断点(即非重复断点)的数目.4.2.2集簇策略在4.1小节中所构建的3个集簇策略SC、IC和AC之外,我们增加一类更具一般性的集簇策略:s(n).该策略的含义为:在PCCG图上,如果两个节点同时被n个方法调用,那么这两个节点需要归于一簇.显然,s(0)等同于AC,因为任意两个节点,无论其是否被同样的方法调用,均会被归于一簇;s()(表示正无穷大)等同于SC,因为任意两个节点均不会归于一类之中.使用策略s(i+1)集簇的结果中,每个簇不小于使用策略s(i)的结果.在特定的情况,可能存在s(i)和s(j)(i≠j)集簇结果相同的情况.在本小节的实验中,我们测试集簇策略SC、s(2)、s(3)、s(4)、s(5)、IC和AC的应用效果.4.2.3实验结果我们使用包含100个方法的调用图.为了在生成PCCG图时选择更贴近实际的RP和PR参数取值,我们对JDK中的所有包进行统计,计算出其中的RP和PR实际取值,如图10所示.从图10中可以看出,参数RP的取值主要集中图111条路径的实验结果于0~10%,而PR的取值主要集中于0~40%,所以我们以RP=1%,2%,…,10%,PR=0,10%,20%,30%,40%作为参数取值,并以二者取值的两两组合生成PCCG图.基于随机生成的PCCG图和图上的路径(每条路径不少于1000次方法调用),我们计算出1、100和2000条独立路径下各个集簇策略的效果,如图11~图13所示.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaPage9图12100条路径的实验结果图132000条路径的实验结果4.2.4分析与讨论从实验结果中可以观察到如下几点:(1)当执行的路径很少时,如图11所示,PIP方法的耗费对PCCG的具体结构有着较高的依赖(实验结果的随机性较大),没有一个集簇策略能够在所有情况下表现最好.但是从平均程度看,较小的簇会Page10带来较高的效率,而策略SC相较其他策略而言效率较高.这种结果是由两方面的原因导致的:一方面,当路径较少时,各个断点重复的概率不大;另一方面,总断点数目在很大程度上决定于路径的编码大小,而较小的簇会导致探针的权值较小,进而导致非重复断点的数目较小.失,而可以明显观察到:(2)随着路径数目的增多,上述随机性逐渐消①SC在剖析较多路径时效果较差,而且它与其它集簇策略的差距随着路径数目的增多而增大(例如图12中路径数目为100,当PR=0时,SC的耗费是AC的10.8倍;而在图13中路径数目为2000时,该差距增加到38.8倍);②AC在大部分情况下效果最好,因为使用AC集簇图中的边很少,产生重复断点的概率更高;③当PR较大时,IC在部分情况下的效果要好于AC,例如图12中,PR=0.3的情况下,10个实例中IC效果好于AC的有两个,PR=0.4时有3个,且IC在PR=0.4时IC的平均效果也高于AC;在图13中,PR=0.3时有两个实例IC比AC效果更好,PR=0.4时有4个.(3)在s(n)中,仅有s(2)在部分情况下效果较好,而s(3)~s(5)普遍效果较差,且在路径较多时效果不如s(2).4.3实验结论从以上实验结果中,我们可以得出如下结论:(1)在PIP与IPP的比较方面,PIP适用于较短的执行或者带有回边的执行;而IPP方法适用于较长的无环执行.(2)在PIP集簇策略的选择方面,当待剖析的路径较多时,应选择AC或s(2)作为集簇策略,以获得较大的簇并使得执行中的断点能够大量重复;反之,当路径数目较少时,应选择SC作为集簇策略,以压缩路径编码和总断点数目;当方法调用图中具有复杂的覆盖关系时,也可以考虑使用IC策略.4.4威胁分析我们的实验主要有3种内部威胁和2种外部威胁.内部威胁:(1)实验人员偏好.我们基于Java和Eclipse平台实现了PIP方法,可以自动地进行插装和输出实验结果,避免剖析过程中的人工干预,以避免实验者的个人偏好对实验结果产生影响.(2)选择偏好.在4.1节的实验中,在基准测试程序的选择上,首先自动地从JDK程序中选出14个待用程序,然后人工地按照既定的准则从中再选出5个作为最终选择结果;在4.2节的实验中,所有的调用图和路径均是自动生成,故最大程度上避免了实验的选择偏好.(3)实验精度.实验所用的Eclipse平台具有较高的可靠性,PIP方法和IPP方法的实现也进行了正确性检验.外部威胁:(1)实验结论可靠性.5个基准测试程序覆盖了3种应用情况,随机PCCG图也包括了较多的RP和PR参数取值可能,实验结论是在覆盖较多情况的实验结果上做出的,应具有较高可靠性.(2)实验对象的代表性.基准测试程序可能尚缺少反应其他程序的能力,而随机PCCG图可能与实际程序中的调用结构有所区别.在将来需要对PIP方法进行更广泛的实验评估.5总结自1996年EPP方法诞生以来,已出现了约十种剖析方法,适应各种应用场景.与本文PIP方法相关的技术线索可以整理如下:(1)EPP能够精确剖析过程内的无环路径,既(2)IPP在EPP的基础上增加了处理过程调用的能力,保持了剖析的精确性但是依然不能处理循环路径;不能处理循环路径,亦不包含过程调用;(3)ExPP一方面扩展了EPP处理循环的能力,但是不能维持精确性,属于近似剖析;另一方面可以处理过程间调用,但是缺乏具体方案;精确性,但是未能处理过程间调用;(4)PAP扩展了EPP处理循环的能力,保持了(5)PIP方法利用了PAP的循环处理能力,增加了对过程间调用的处理,并保持了剖析结果的精确.总之,在过程间剖析中,已有的方法或不能剖析有回边的路径,或不能给出准确的剖析结果,且均未考虑多态调用对剖析所带来的影响.由于回边、递归调用和多态在面向对象软件中是普遍存在的,一个完整的剖析解决方案不可或缺要对其进行处理.本文关注于过程间路径的剖析,主要包含如下工作:(1)在PAP方法的基础上说明和证明了过程间路径剖析可以忽略过程内部结构,从而专注于过程间方法调用和返回;(2)提出了一种描述有多态调用关系的方法调用图PCCG模型,并提出以PCCG图为基础进行路Page11径剖析,可以通过基于多态信息的方法集簇提高效率;(3)在PAP和PCCG的基础上提出了PIP方法,精确的剖析过程间带有循环的路径.此外,在应用PIP方法时需要使用合适的集簇策略,以达到较好的效果.通过设计多种集簇策略,并基于实验结果,我们给出了在实际应用中,依据调用关系和待剖析路径的特性对集簇策略进行设计和选取的准则.在未来工作中,还需要在以下几个方面做进一步研究:文中设计并评估了7种集簇策略,却并不能保证其中包含最优策略,对于更好的集簇策略有待进一步寻找;需要在更广泛的应用中对PIP的效果和各种集簇策略的优缺点做进一步的验证;实际应用中可能出现的异常处理、进程终止等意外的执行情况,如何进行此类控制流的剖析也有待进一步的分析.
