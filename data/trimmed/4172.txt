Page1马尔可夫决策过程的限界模型检测周从华邢支虎刘志锋王昌达(江苏大学计算机科学与通信工程学院江苏镇江212013)摘要限界模型检测避免了符号模型检测反应式系统中构建二叉图时出现的空间快速增长,已经被证明是缓解状态空间爆炸问题的有力技术.文中遵循限界模型检测的思想,对马尔可夫决策过程提出一种限界模型检测技术,从而避免构建多端二叉图时空间的快速增长.具有非确定选择刻画能力是马尔可夫决策过程最大的特性,针对该特性首先定义概率计算树逻辑的限界语义,并证明其正确性;然后基于不同界下所计算概率度量序列的演化趋势,设计了限界检测过程终止的判断准则;最后将限界模型检测过程转换为线性方程组的求解问题.实验结果说明限界模型检测技术在证据较短的情况下,所需内存空间少于无界模型检测算法.关键词模型检测;限界模型检测;概率计算树逻辑;马尔可夫决策过程;状态空间爆炸1引言化验证技术,其最大特点是验证过程完全自动化.传统模型检测技术主要验证系统行为的绝对正确性,如两个进程不能同时访问临界区.然而很多随机系统关注的是某事件发生的概率,如Adhoc网关注的模型检测[1-2]是目前应用非常广泛的一种形式Page2是不可靠信道上消息丢失的概率.传统模型检测中常用的时态逻辑,如计算树逻辑CTL和线性时态逻辑LTL,无法刻画概率度量.为此研究人员提出了概率计算树逻辑PCTL[3]等逻辑系统及相应的概率模型检测方法[4-5],其主要思想是在计算树和线性时态逻辑中引入概率度量算子,同时设计不同概率度量算子的检测方法.在概率模型检测中,马尔可夫决策过程MDP[4-5]是一种非常重要的随机系统模型.与传统模型检测一样,状态空间爆炸问题[6-7]是模型检测MDP实用化的主要瓶颈.一种克服该问题的自然的方法是将传统模型检测中的缓解空间爆炸的技术扩展应用到概率模型检测上.这些方法包括基于二叉决策图的状态空间压缩技术[8-9]、通过剥离与验证属性无关因素而合并状态空间的抽象技术[10]、对进程间交互次序进行等价类划分的偏序归约[11]与对称归约[12]技术、基于模块分析的组合推理[13]等.近年来研究人员从反驳证明的角度提出了一种全新的系统规模约简技术———限界模型检测[14-19],其主要特性是无需遍历全局空间,只需在验证属性必需的局部空间上即可完成验证过程.这种特性决定了将限界检测技术应用于模型检测MDP中,必能有效缓解存储空间溢出问题,本文的研究动机也源于此.限界模型检测起源于Biere在1999年提出的基于命题公式可满足性判定的线性时态逻辑LTL的自动化验证过程.反驳证明是限界模型检测进行验证的主要原理,即通过逐步增加路径的长度来搜索使待证明性质失效的反例或者成立的证据.2002年Penczek等人[20]提出了计算树逻辑CTL的限界模型检测方法.2003年,Penczek等人[21]面向多智体系统提出了时态认知逻辑ACTLK的限界模型检测方法.Lomuscio等人[22]提出了实时认知逻辑TECTLK的限界模型检测算法.非概率逻辑系统的限界检测主要利用命题逻辑对反例或者证据的存在性进行编码,使得存在反例或者证据当且仅当对应的命题公式是可满足的.反例和证据的结构特征决定了命题逻辑有足够的能力对它们进行完全编码.而概率算子的反例和证据,其结构特征是状态转换关系满足一定的概率分布,命题逻辑对概率分布缺乏表达力.因此概率算子的特性决定了将限界检测技术扩展到MDP上,必会出现很多新的有价值的语义,并证明限界语义是对无界语义的逼近;(2)设计了一套利用线性方程组刻画不同算子的限界语义的算法,使得线性方程组的解即为该算子对应的概率度量,从而PCTL限界语义的可满足性检测可通过判断线性方程组的解是否满足相应的概率度量约束即可;(3)以实例说明在限制路径长度下计算的概率度量可能永远无法达到精确值,因此非概率逻辑限界检测中以设置完全界为检测终止性的准则已经失效,本文依据不同界下所计算概率度量序列的演化趋势,设计了新的限界检测过程终止的判断准则.理论问题,这些新问题使得对概率算子的限界检测进行系统的研究成为必要.MDP是一种重要且常用的随机系统模型,本文结合MDP的特性,系统研究了MDP上概率计算树逻辑PCTL的限界检测问题,具体工作包括3个方面:(1)在MDP上配置PCTL中不同算子的限界实验结果表明:(1)限界模型检测得到的是一个非严格递增的概率度量序列,且与真实的概率度量误差越来越小;(2)MDP上PCTL的限界模型检测通过逐渐增加路径的长度来搜索属性为真的证据,因此对于具有较短的属性为真的证据的MDP,能够快速地完成验证过程,并且在存储空间的需求上低于PCTL的无界模型检测算法.文献[23]系统研究了离散时间马尔可夫链DTMC上的PCTL限界检测问题,包括DTMC上PCTL的限界语义、限界检测算法以及检测终止判定准则.文献[24]面向多智体系统研究了概率实时认知逻辑PTCTLK的限界检测.上述两篇论文的研究发现在概率算子的限界检测中路径长度作为检测过程终止的判别条件已经失效,必须设计新的判断准则.此外两篇论文均设计了基于线性方程组求解的限界模型检测算法,从而可以借助于数值计算工具完成检测过程.MDP与DTMC最大不同在于MDP能够刻画非确定性选择,从而可以进行任务调度与优化分析.本文的工作是由于文献[23]的延生,重点解决非确定性选择给PCTL的限界语义以及检测算法带来的新的理论问题.表1详细比较了本文与文献[23-24]的工作.Page3表1相关研究工作的比较率转换关系概率计算树逻辑PCTL限界检测:配置限界语义,设计限界检测算法,设计终止检测过程的规则率转换关系概率实时认知逻辑PTCTLK限界检测:配置限界语义,设计限界检测算法,设计终止检测过程的规则论文研究对象对象特性文献[23]离散时间马文献[24]概率实时解本文马尔可夫决本文第2节介绍与MDP、PCTL相关的基本概念;第3节探讨MDP限界模型检测的3个关键问题,包括PCTL限界语义的配置、限界语义可满足性的检测算法、终止检测过程的标准;第4节通过自稳定协议说明限界模型检测过程;第5节展示实验结果,并得出一些结论;第6节为提高概率度量计算的精度,探讨终止性判断准则的修正;第7节总结全文并展望未来的工作.2马尔可夫决策过程与概率计算树逻辑PCTL的语法和语义涉及概率度量的计算问题,因此首先回顾概率论的基本内容.样本空间是由随机试验中所有可能发生的结果构成的集合,记为Ω.Ω的幂集2Ω的子集Π称为σ代数,当且仅当满足下面3个条件:Ω∈Π;如果E∈Π,则Ω\E∈Π;如果E1,E2,…∈Π,则∪i1Ei∈Π.由样本空间Ω、Ω上的σ代数Π以及函数Prob:Π→[0,1]构成的三元组PS=(Ω,Π,Prob)称为概率空间,满足Prob(Ω)=1,且对Π中互不相交的序列E1,E2,…,Prob(∪称Π中任何元素是可度量的.如图1所示,MDP是马尔可夫链的变种,其主要特点是允许概率和非确定性选择.令Dist(S)表示集合S上概率分布的集合,即满足∑s∈Sμ(s)=1的检测算法,设计终止检测过程的规则函数μ:S→[0,1]的集合.MDP的形式化定义如下.定义1.MDPM=(S,sin,Act,Steps,Ap,L)是一个六元组,这里S是有限状态集;sin∈S是初始状态;Act是动作集;Steps:S→2Act×Dist(S)是转换概率函数,且满足对任意的(a,μ)∈Steps(s),∑s∈Sμ(s)=1;Ap是有限的原子命题集;L:S→2Ap是标记函数.定义2(路径).设M为MDP,M中的路径π是具有下述形式的无穷序列:s0这里对任意的i0,si∈S,(ai+1,μi+1)∈Steps(si),μi+1(si+1)>0.对于路径π,引入记号π(i)表示第i个状态.对于有穷路径πfin,last(πfin)表示πfin上的最后一个状态,|πfin|表示路径的长度,即状态转换发生的次数.Pathfin,Path分别表示M中有穷和无穷路径集合,Pathfins,Paths分别表示从s出发的有穷和无穷路径集.定义3.令M为MDP,映射Adv:Pathfin→{Steps(last(πfin))|πfin∈Pathfin}称为M上的一个调度.例如对于图1中的MDPM1,存在这样的两个调度Adv1:Adv1(s0)=(a,μa),Adv1(s0(b,μb),Adv1(s0Adv2:Adv1(s0)=(a,μa),Adv1(s0(b,μb),Adv1(s0引入记号AdvM表示M上所有调度的集合,记号PathAdvs表示从s出发和Adv对应的路径集.对于MDPM、状态s和调度Adv,令Ω=PathAdvs为M中从s出发和Adv对应的路径集.Π是σ代数,定义为Π={C(ρ)|ρ是Ω中某条路径的前缀},这里C(ρ)=Page4{π∈Ω|ρ是π的有限前缀}.Π上的概率度量ProbAdvs定义为ProbAdvs(C(s(a1,μ1→)s2sn))=∏2inμi-1(si).这样我们从MDPM、状态s和调度Adv演绎出了一个概率空间.定义4(概率计算树逻辑PCTL).PCTL由状态公式和路径公式构成.给定原子命题集Ap,PCTL状态公式递归定义如下:····=true|a|∧|∨||P∝p(ψ),这里a∈Ap,∝∈{,<,,>},p∈[0,1],ψ是一条路径公式.PCTL路径公式递归定义如下:ψ····=X|F|G|U|R,这里是状态公式.MDP上PCTL的满足性关系定义如下.定义5(概率计算树逻辑PCTL的满足性关系).令a∈Ap为原子命题,M=(S,sin,Act,Steps,Ap,L)是MDP,s∈S,1,2是PCTL状态公式,ψ是PCTL路径公式.对于状态公式满足性关系定义为sa当且仅当a∈L(s);s1当且仅当s|≠1;s1∧2当且仅当s1且s2;s1∨2当且仅当s1或者s2;sP∝p(ψ)当且仅当对所有的Adv∈AdvM,Pr(s,ψ,Adv)∝p,这里Pr(s,ψ,Adv)=ProbAdvs({π∈PathAdvs|πψ}).对于M中的路径π,满足性关系定义为πX1当且仅当π(1)1;πF1当且仅当存在自然数i使得π(i)1;πG1当且仅当对任意的自然数i,π(i)1;π1U2当且仅当存在自然数j使得π(j)2,且对任意小于j的自然数i,π(i)1;π1R2当且仅当对任意的自然数j,π(j)2,或者存在自然数k使得π(k)1,且对任意不大于k的自然数i,π(i)2.3PCTL的限界模型检测3.1PCTL的等价性限界语义的定义必须确保限界语义可满足时,属性在局部和全局空间中同时成立.PCTL中不涉及概率度量的算子,即X,F,G,U,R,其限界语义等同于在LTL限界检测中的限界语义.在限界检测过程中满足约束条件的路径会随着界的增长而增加,即概率度量会逐渐增加,这使得限界检测可直接应用于算子Pp和P>p,而不适用于算子Pp和P<p类型的算子.因此为了实现对整个PCTL公式的限界检测,本小节探讨能否在保持PCTL表达力的情况下,将概率约束限制为p或者>p的形式.定义6(PCTL公式的等价).令,φ为任意的PCTL状态公式,如果对任一MDPM,s∈S,s当且仅当sφ,则称、φ是等价的,记为≡φ.依据定义5描述的PCTL的无界语义,可直接得出如下等价关系:Pp(X)≡P1-p(X);P<p(X)≡P>1-p(X);Pp(F)≡P1-p(G);P<p(F)≡P>1-p(G);Pp(G)≡P1-p(F);P<p(G)≡P>1-p(F);Pp(Uφ)≡P1-p((Uφ))≡P1-p(Rφ);P<p(Uφ)≡P>1-p((Uφ))≡P>1-p(Rφ);Pp(Rφ)≡P1-p((Rφ))≡P1-p(Uφ);P<p(Rφ)≡P>1-p((Rφ))≡P>1-p(Uφ).上面的等价关系说明可将(<)p的概率约束转换为(>)p的约束.现在考察sPp(ψ),即s|≠Pp(ψ),这意味着存在一个调度Adv∈AdvM使得Pr(s,ψ,Adv)>p.为了尽可能地保持PCTL表达力,在PCTL中引入公式P∝p(ψ)当且仅当存在一个Adv∈AdvM使得sPPr(s,ψ,Adv)∝p.限界模型检测的基本原理是通过限制路径长度从而在有限空间中逐步搜索可用于反驳的证据或者反例,因此限界检测不适用于算子<p(ψ)和PP的子集PCTL检测.形式化地讲,原子命题集Ap上的PCTL态公式定义如下:∷=true|a|a|∧|∨|P∝p(ψ)|P[0,1],ψ是一条路径公式.PCTL下:ψ∷=X|F|G|U|R,这里是状态公式.是由上述状态公式和路径公式组成的逻辑PCTL系统.3.2PCTL的限界语义Act,Steps,Ap,L)为MDP,a∈Ap为原子命题,s∈S,k为自然数(称为界),ψ是PCTL2是PCTL定义为在保证PCTL表达力的前提下,现在定义PCTL定义7(PCTLaL(s);ska当且仅当a∈L(s);ska当且仅当sk1∧2当且仅当sk1且sk2;Page5sk1∨2当且仅当sk1或者sk2;skP∝p(ψ)当且仅当对所有的Adv∈AdvM,Pr(s,ψ,Adv,k)∝p,这里Pr(s,ψ,Adv,k)=ProbAdvs({π∈PathAdvs|πkψ});得Pr(s,ψ,Adv,k)∝p.skP对于M中的路径π,满足性关系k定义为πkX1当且仅当k1且π(1)k1;πkF1当且仅当存在自然数ik使得π(i)k1;πkG1当且仅当对任意的自然数ik,π(i)k1,且对任意的自然数j>k,存在自然数hk使得π(j)=π(h);πk1U2当且仅当存在自然数jk使得π(j)k2,且对任意的小于j的自然数i,π(i)k1;πk1R2当且仅当:(1)对任意的自然数ik,π(i)k2,且对任意的自然数j>k,存在自然数hk满足π(j)=π(h);或者(2)存在自然数mk满足π(m)k1,且对任意的自然数i,如果im,则π(i)k2.现在考察定义7中ProbAdvs({π∈PathAdvs|πkψ})的可度量性.对于算子X,{π∈PathAdvs|πkX1}是所有C(s0s1k1.对于算子F,{π∈PathAdvs|πkF1}是所有C(s0s0=s,sik1.对于U算子,{π∈PathAdvs|πk1∪2}是所有C(s0其中ik,s0=s,s0k1,…,si-1k1,sik2.由σ代数的定义可知,可度量集合的并仍是可度量的,因此对于X、F、U算子,ProbAdvs({π∈PathAdvs|πkψ})是可度量的.可度量性说明可以直接利用ProbAdvs(C(s(a1,μ1→)s2ProbAdvs({π∈PathAdvs|πkψ})的值.现在考察G算子.对于X、F、U算子,ProbAdvs({π∈PathAdvs|πkψ})是可度量的,本质在于如果有穷路径满足ψ,则以该有穷路径为前缀的所有路径都满足ψ,因此只需计算有穷路径发生的概率即可得ProbAdvs的值.而对于G算子,有穷路径不能反映以该路径为前缀的无穷路径的情况,因此ProbAdvs({π∈PathAdvs|πkG1})难以直接度量.在3.4节的限界检测算法部分我们将采用下近似的方法逼近ProbAdvs({π∈PathAdvs|πkG1}).R算子可以分解应的满足性关系,直接可得sa.应的满足性关系,直接可得s|≠a.可知s1,s2,即s1∧2.为了判断一个状态是否满足P∝p(),P为G与U算子考虑,这里不再赘述.理论上必须计算出任一调度Adv下ProbAdvs({π∈PathAdvs|πkψ})的值,然后再计算出最大值和最小值,并通过与p比较得出公式的真假.实际上在3.4节的限界检测算法部分,我们设计了一种递归的方式可直接计算出最大值和最小值,从而避免了计算任意调度下ProbAdvs的值.定理1.令M=(S,sin,Act,Steps,Ap,L)为MDP,s∈S,a∈Ap为原子命题,k为自然数,是状态公式.如果sk,则s.PCTL证明.证明过程通过对的长度实施归纳来完成.情况1.=a.ska说明a∈L(s),依据定义5中描述的相情况2.=a.ska说明aL(s),依据定义5中描述的相情况3.=1∧2.sk1∧2说明sk1,sk2.由归纳假设情况4.=1∨2.sk1∨2说明sk1或者sk2.由归纳假情况5.=Pp(ψ).skPp(ψ)说明对任意的调度Adv∈AdvM,Pr(s,ψ,Adv,k)p,即ProbAdvs({π∈PathAdvs|πkψ})p.X、F、U3个时态算子的限界语义与LTL限界检测技术中的定义一致,因此有πkψ蕴含πψ,从而ProbAdvs({π∈PathAdvs|πψ})ProbAdvs({π∈PathAdvs|πkψ})p,即sPp(ψ).对于G算子,由πkG1的定义可知对任意的自然数ik,π(i)k1,对任意的自然数j>k,必存在自然数hk使得π(j)=π(h).1是状态公式,因此π(h)k1蕴含了π(j)k1.因此对任意的自然数l0,π(l)k1.由归纳假设可知π(l)1,因此ProbAdvs({π∈PathAdvs|πG})ProbAdvs({π∈PathAdvs|πkG})p,即sPp(ψ).对于算子R,1R2≡G2∨(2U(1∧2)),因此算子R的证明可以归结为算子G和U的证明.设可知s1或者s2,即s1∨2.情况6.=P>p(ψ).证明类似于情况5.情况7.=PPage6skP得Pr(s,ψ,Adv,k)p,即ProbAdvs({π∈PathAdvs|πkψ})p.对于时态算子X、F、G、U,其限界语义与文献[14]中的定义一致,因此有πkψ蕴含πψ,从而ProbAdvs({π∈PathAdvs|πψ})ProbAdvs({π∈PathAdvs|πkψ})p,即sPp(ψ).对于G算子,由πkG1的定义可知对任意的自然数ik,π(i)k1,对任意的自然数j>k,必存在自然数hk使得π(j)=π(h).1是状态公式,因此π(h)k1蕴含了π(j)k1.因此对任意的自然数l0,π(l)k1.由归纳假设可知π(l)1,因此ProbAdvs({π∈PathAdvs|πG})ProbAdvs({π∈PathAdvs|πkG})p,即sPp(ψ).对于算子R,1R2≡G2∨(2U(1∧2)),因此算子R的证明可以归结为算子G和U的证明.情况8.=P证明类似于情况7.定理1保证了限界语义定义的正确性,进而使得我们可以通过逐步增加路径长度的方式,得到精确概率度量的下近似.3.3限界模型检测过程终止的判断定理1表明限界语义是对无界语义的逼近,即如果存在自然数k使得sk,则断言s.现在的问题是当s|≠k时,在增加k的值继续搜索还是停止搜索两者之间需要作出正确的选择.如果继续搜索,不可能对界k无限增加下去,必须设计一套终止约束条件;如果停止搜索可能造成s|≠的假象.因此必须设计一个准则来决定s|≠k时的下一步选择.定义8.称自然数CT是完全界当且仅当如果s,则一定存在自然数kCT使得sk.CTL和LTL的限界模型检测因为不涉及极限运算,所以完全界一定存在,从而在知道CT的情况下,当s|≠k时如果k超过完全界,则停止搜索,并返回信息:s|≠,否则继续增加k的值进行搜索.但是对于限界模型检测,完全界则不一定存在.PCTL考察图1所示的MDPM1.对于状态s,引入原子命题as表示当前状态为s.考察属性P=1(Fas3).通过计算发现,对任意的调度Adv,Pr(s0,Fas3,Adv)=ProbAdvs0{π∈Pathss0|πFas3}=ProbAdvs0{π=s0,s1,(s2,s1)r,s3,…|r0}=415·45+1P=1(Fas3).令k为界,则Pr(s0,Fas3,Adv,k)=ProbAdvs0{π∈Pathss0|πkFas3}=ProbAdvs{0π=s0,s1,(s2,s1)r,s3,…|rk5+…+()115·4比较Pr(s0,Fas3,Adv)和Pr(s0,Fas3,Adv,k),可以发现对于任意的有限界k,Pr(s0,Fas3,Adv,k)<Pr(s0,Fas3,Adv).换句话,对于属性P=1(Fas3),尽管s0P=1(Fas3),但不存在一个有限的自然数k,使得s0kP=1(Fas3).现在探讨完全界存在的条件.引理1.令M=(S,sin,Act,Steps,Ap,L)是MDP,是PCTL式.则对于任意的自然数k,属性在k步空间中成立,在k+1步空间中也成立,即sk→sk+1,πkψ→πk+1ψ.通过对PCTL引理1的证明,故这里不给出其证明过程.定理2.令M=(S,sin,Act,Steps,Ap,L)为MDP,ψ是PCTLAdv)|Adv∈AdvM}.则对于公式Pr(ψ)(r<p),一定存在完全界CT使得sinPr(ψ)时sinCTPr(ψ).证明.由引理1可知,Pr(sin,ψ,Adv,k)随着k的增加而不断增加,且limk→Pr(sin,ψ,Adv,k)=Pr(sin,ψ,Adv).令ξ=p-r,由极限的定义可知存在自然数kξ,当k>kξ时|Pr(sin,ψ,Adv,k)-Pr(sin,ψ,Adv)|<ξ.此时取CT=kξ+1,则|Pr(sin,ψ,Adv,CT)-Pr(sin,ψ,Adv)|<ξ,即Pr(sinCTψ)>p-ξ,从而sinCTPr(ψ).定理2说明在何种条件下MDP上的完全界是存在的.但是这种存在性条件依赖于事先计算Pr(sin,ψ,Adv),因此不具有实用性.不存在完全界使得我们无法以设置路径长度的上限来决定检测过程何时终止,因此需要提出新的判别标准.我们拟通过刻画不同界下所计算概率度量序列的演化趋势来执行判断.回顾一下,判断s是否满足P∝p(ψ)关键在于对所有Adv∈AdvM,Pr(s,ψ,Adv)∝p.如果对所有的Adv∈AdvM,Pr(s,ψ,Adv)的某个下近似满足∝p,则Pr(s,ψ,Adv)∝p.因此我们计算min{Pr(sin,ψ,Adv)|Adv∈AdvM}的下近似min{Pr(sin,ψ,Adv,Page7k)|Adv∈AdvM}(k0).同理,对于Pmax{Pr(sin,ψ,Adv)|Adv∈AdvM}的下近似max{Pr(sin,ψ,Adv,k)|Adv∈AdvM}(k0).我们以P∝p(ψ)为例说明PCTL止性判断准则.判断准则1.PCTL判断.输入:MDPM=(S,sin,Act,Steps,Ap,L),PCTL输出:min{Pr(sin,ψ,Adv)|Adv∈AdvM}的下近似值1.令k=1,计算min{Pr(sin,ψ,Adv,0)|Adv∈AdvM},2.Whilemin{Pr(sin,ψ,Adv,k)|Adv∈AdvM}-min{Pr(sin,ψ,Adv,k-1)|Adv∈AdvM}ξ∧kmdo{令k=k+1,计算min{Pr(sin,ψ,Adv,k)|Adv∈AdvM};}3.输出min{Pr(sin,ψ,Adv,k)|Adv∈AdvM}.引理1告诉我们,min{Pr(sin,ψ,Adv,0)|Adv∈AdvM},min{Pr(sin,ψ,Adv,1)|Adv∈AdvM},…是一个递增的数列,且1为其上界,因此该序列必收敛.收敛性保证了判断准则1在不预先设置计算步长m的情况下的终止性.上述过程存在这样一个问题,即如何计算min{Pr(sin,ψ,Adv,k)|Adv∈AdvM},在3.4小节我们将探讨min{Pr(sin,ψ,Adv,k)|Adv∈AdvM}的计算问题.3.4限界模型检测算法算法的主要思想是设计一套线性方程组刻画不同算子的限界语义的算法,使得线性方程组的解即为该算子对应的概率度量,从而PCTL限界语义的可满足性检测可通过判断线性方程组的解是否满足相应的概率度量约束即可.min{Pr(s,ψ,Adv,k)|Adv∈AdvM}来完成验证过程.对于公式=Pmax{Pr(s,ψ,Adv,k)|Adv∈AdvM}来完成验证过程.设pminPr(ψ),对任意的0l<p,sP>l(ψ).令k0为限界模型检测的界,S,k={s∈S|sk}.对公式,引入记号y(s,,k)∈{0,1}来表示PCTLsk是否成立:y(s,,k)=1表示sk;y(s,,k)=0表示s|≠k.y(s,,k)定义如下:是原子命题:如果∈L(s),则y(s,,k)=1,否则y(s,,k)=0.是原子命题:如果∈L(s),则y(s,,k)=1,否则y(s,,k)=0.对于公式P∝p(ψ),我们主要通过计算pmin否则y(s,,k)=0.否则y(s,,k)=0.决定了转换方法不同,下面分别讨论.=1∨2:y(s,,k)=y(s,1,k)∨y(s,2,k).=1∧2:y(s,,k)=y(s,1,k)∧y(s,2,k).=P∝p(ψ):如果pmin=P对于pmin情况1.ψ为原子命题.如果ψ∈L(s),则pmin情况2.ψ=Xδ.当k=0时,由于当前状态s没有后继状态,因s,0(ψ)=0;当k1时,首先需要对每一个调度Adv计算s,k(ψ)=min(a,μ)∈Steps(s)∑s∈Spmin情况3.ψ=Fδ.当k=0时,pmin当k1时,pmin态s满足δ和不满足δ.在满足的情形下pmins,k(ψ)由s的后继状态决定,因此否则pminpmin此pminPr(s,ψ,Adv,k),然后取其中的最小值,因此此如果y(s,δ,0)=1,则pmin情况4.ψ=Gδ.当k=0,y(s,δ,0)=0时,s不满足δ,因此s,0(ψ)=0;pmin当k=0,y(s,δ,0)=1时,由于G算子要求考察无穷长的路径,因此如果存在(a,μ)∈Steps(s)使得μ(s)<1,则pmin当k1时,采用一种下近似的计算方法,即如果在一个循环中存在概率小于1的状态转换,则包含此循环的路径的概率度量为0,因此s,k(ψ)=pmin(ak+1,μk+1)∈Steps(sk)∑kmin(a1,μ1)∈Steps(s0),…,μ1(s1)·…·y(si,δ,k)·μi(si)·y(si+1,δ,k)·μi+1(si+1)·…·y(sk,δ,k)·μk(sk)·μk+1(si),这里记号μj(sj)表示对μj(sj)取整(i+1jk+1).情况5.ψ=φUγ.当k=0时,pminPage8当k1时,分成两种情况,(1)s满足γ,此时因此如果y(s,γ,0)=1,则pmins,0(ψ)=0;pmins,k(ψ)=1;(2)s满足φ,不满足γ,此时pmins,k(ψ)=y(s,φ,k)·min(a,μ)∈Steps(s)∑s∈Sμ(s)pminpmin情况6.ψ=φRγ.依据R算子的语义可以分解成两种情形讨论,其一类似于U算子,其二类似于G算子,具体计算过程如下:当k=0时,y(s,γ,0)=0,则pmin当k=0时,如果y(s,φ,0)=y(s,γ,0)=1,则s,0(ψ)=1;pmin当k=0,y(s,γ,0)=1,y(s,φ,0)=0时,如果存在(a,μ)∈Steps(s)使得μ(s)<1,则pmins,0(ψ)=1;则pmin当k1时,因为=φRγ≡Gγ∨(γU(γ∧φ)),故分成两部分s,k(ψ)=pmin(ak+1,μk+1)∈Steps(sk)∑kmin(a1,μ1)∈Steps(s0),…,(1-y(sk,φ,k))·y(s0,γ,k)·y(s1,γ,k)·μ1(s1)·…·y(si,γ,k)·μi(si)·y(si+1,γ,k)·μi+1(si+1)·…·y(sk,δ,k)·μk(sk)·μk+1(si)+pmin这里加入因子(1-y(sj,φ,k))(0jk)的主要目的是避免重复计算{π|πkGγ∧πkγU(γ∧φ)}的概率度量.此pmaxs,0(ψ)=0;Pr(s,ψ,Adv,k),然后取其中的最大值,因此对于公式=P情况1.ψ为原子命题.如果ψ∈L(s),则pmax情况2.ψ=Xδ.当k=0时,由于当前状态s没有后继状态,因当k1时,首先需要对每一个调度Adv计算s,k(ψ)=max(a,μ)∈Steps(s)∑s∈Spmax情况3.ψ=Fδ.当k=0时,pmaxs,0(ψ)完全依赖于s是否满足δ,因此如果y(s,δ,0)=1,则pmaxs,0(ψ)=1,否则pmaxs,0(ψ)=0;当k1时,pmax状态s满足δ和不满足δ.在满足的情形下之s,k(ψ)=1,否则pmaxpmax因此s,k(ψ)=y(s,δ,k)+pmax(1-y(s,δ,k))max(a,μ)∈Steps(s)∑s∈Sμ(s)pmax情况4.ψ=Gδ.当k=0,y(s,δ,0)=0时,s不满足δ,因此pmaxs,0(ψ)=0;当k=0,y(s,δ,0)=1时,由于G算子要求考察无穷长的路径,因此如果存在(a,μ)∈Steps(s)使得μ(s)=1,则pmaxs,0(ψ)=1,否则pmaxs,0(ψ)=0;当k1时,采用一种下近似的计算方法,即如果在一个循环中存在概率小于1的状态转换,则包含此循环的路径的概率度量为0,因此s,k(ψ)=pmax(ak+1,μk+1)∈Steps(sk)∑kmax(a1,μ1)∈Steps(s0),…,μ1(s1)·…·y(si,δ,k)·μi(si)·y(si+1,δ,k)·μi+1(si+1)·…·y(sk,δ,k)·μk(sk)·μk+1(si),这里记号μj(sj)表示对μj(sj)取整(i+1jk+1).当k=0时,y(s,γ,0)=0,则pmaxs,0(ψ)=0;当k=0时,如果y(s,φ,0)=y(s,γ,0)=1,则pmaxs,0(ψ)=1;当k=0,y(s,γ,0)=1,y(s,φ,0)=0时,如果存在(a,μ)∈Steps(s)使得μ(s)=1,则pmaxs,0(ψ)=1,否s,0(ψ)=0;则pmin当k1时,因为=φRγ≡Gγ∨(γU(γ∧φ)),故分成两部分s,k(ψ)=pmax(ak+1,μk+1)∈Steps(sk)∑kmax(a1,μ1)∈Steps(s0),…,(1-y(sk,φ,k))·y(s0,γ,k)·y(s1,γ,k)·μ1(s1)·…·y(si,γ,k)·μi(si)·y(si+1,γ,k)·μi+1(si+1)·…·情况5.ψ=φUγ.当k=0时,pmaxs,0(ψ)完全依赖于s是否满足γ,因此如果y(s,γ,0)=1,则pmaxs,0(ψ)=1,否则pmaxs,0(ψ)=0;当k1时,分成两种情况,(1)s满足γ,此时s,k(ψ)=1;(2)s满足φ,不满足γ,此时pmaxs,k(ψ)=y(s,φ,k)·max(a,μ)∈Steps(s)∑s∈Sμ(s)pmaxpmax情况6.ψ=φRγ.依据R算子的语义可以分解成两种情形讨论,其一类似于U算子,其二类似于G算子,具体计算过程如下:Page9y(sk,δ,k)·μk(sk)·μk+1(si)+pmin公式长度等元素相互之间的依赖关系.现在分析线性方程组的阶与MDP的大小、界、定义9.0步可达:称s是从自身出发0步可达的;1步可达:如果存在(a,μ)∈Steps(s)使得μ(s1)>0,则称s1是从s出发1步可达的;l步可达:如果sl-1是从s出发l-1步可达的,且存在(a,μ)∈Steps(sl-1)使得μ(sl)>0,则称sl是从s出发l步可达.对PCTL的数目.设M=(S,sin,Act,Steps,Ap,L)为MDP,是被分析的公式,k为界,所有从初始状态i步可达的状态数目记为Ni,线性方程组中变元的数量记为V.在不同状态下,对的每一个子公式转换算法建立了其与每一个不大于k的界的组合.此外每个的子公式φ与变元y(s,φ,k)建立了一一对应关系.上述分析过程表明V(N0+…+Nk)×||×k×2.直接法和迭代法是求解线性方程组的两类主要方法,直接法的特点是准确性和可靠性高,迭代法的特点是适用于高阶的方程组.而对于MDP,转换算法演绎出的是上三角方程组.因此可忽略方程组阶的影响,仍然选择直接法来求解方程.变元求解的次序可采用文献[23]中定义的语法树来确定,即先求解原子命题对应的变元,然后由里向外以此求解各子公式对应的变元.4实例研究在分布式系统中当进程或者用户进入非法状态时,我们总希望其能尽快回归到合法状态.为此Israeli和Jalfon提出自稳定协议[25],从而保证当系统进入非法状态时,在没有外部力量的帮助下能够在有限步内自动回到合法状态,这里我们将合法状态称为稳定状态.假设系统由N个独立的进程P1,P2,…,PN组成,进程之间的运行是异步的.稳定状态指的是只有一个进程享有特权,这里享有特权是指该进程拥有一个token.每个进程Pi使用一个布尔变量qi说明该进程是否拥有一个token.当进程拥有token时称该进程是活的.只有活的进程才能被调度.进程被调度以后,该进程随机的将token移给到它左边的或者右边的进程.如果进程拥有的token数超过一个,将被合并为一个.现在探讨如何利用马尔可夫决策过程模拟该协议.具体决策过程M=(S,sin,Act,Steps,Ap,L)定义如下:S=BN,这里B={q1,q2,…,qN},即每个状态表示为一个布尔向量狊=(q1,q2,…,qN),其中第i个元素表示进程Pi是否拥有token;sin={1,…,1}是初始状态,即每个进程均拥有一个token;Act={1,2,…,N}是动作集,这里i表示进程Pi被调度;Steps:S→2Act×Dist(S),对任意的状态狊∈S,(i,μ)∈Steps(狊)当且仅当qi=1,任意的狊∈S满足μ(s)=1烄2,ifqi1=1,qi=0,andqj=qjforallj≠i,i11烅2,ifqi⊙1=1,qi=0,andqj=qjforallj≠i,i⊙10,烆其它这里i1=i+1(modN),i⊙1=N,ifi=1Ap={q1,q2,…,qN,stable};L:S→2Ap,这里qi∈L(狊)当且仅当qi=1,stable∈L(狊)当且仅当1iN使得qi=1且1jN(j≠i→qj=0).我们验证这样的属性:令L表示一步可达状态中稳定状态从其可达的概率不低于0.5的所有状态,则L从初始状态可达的概率也不低于0.5.该属性利用PCTL逻辑描述为P1当界为2时,s0是否满足P1此需要计算概率度量pminmin{Pr(s0,XP1界为2时自稳定协议对应的马尔可夫决策过程展开图如图2所示.具体的计算过程如下,主要是按照语法树由上向下逐层推进,直到界为0或者原子命题为止.(1)pmin2(Fstable),1)+1P112y(s2,P112y(s3,P1Page10图2界为2时自稳定协议对应的MDP展开图P11})=min{y(s1,P12(Fstable),1)+y(s3,P1(2)pminstable,0)){×min1s3,0(Fstable)+112pmin(3)如果pmin(4)pmin1)=1;否则y(s1,P1stable,0)){×min1s3,0(Fstable)+112pmin(5)如果pmin(6)pmin1)=1;否则y(s2,P1stable,0)){×min1s6,0(Fstable)+112pmin(7)如果pmin1)=1;否则y(s3,P1(8)y(s1,stable,0)=y(s2,stable,0)=y(s3,stable,0)=0;y(s4,stable,0)=y(s5,stable,0)=y(s6,stable,0)=1.(9)pmins4,0(Fstable)=pmin对于上述方程组,变元求解的顺序为(1)y(s1,stable,0),y(s2,stable,0),y(s3,stable,0),y(s4,stable,0),y(s5,stable,0),y(s6,stable,0).0;pmin(2)pmins6,0(Fstable),pminpmin(3)pmin(4)y(s1,P11),y(s3,P1(5)pmin最终得出pmin2(XP1P15实验结果为了考察限界检测技术在实际应用中约简状态空间的效果,利用限界模型检测算法验证了3个实例:(1)第4部分的自稳定协议;(2)Lehmann和Robin提出的解决哲学家就餐问题的策略;(3)带冲突避免的载波监听多路访问协议CSMA/CA.表2、表3和表4分别给出了线性方程组变元数目随着进程数(主体数)、界的变化而变化的情况.表中的变元数目是依据3.4节中描述的变元数目与马尔可夫决策过程的状态展开空间、公式长度以及界之间的关系估算出的上界.表中的几个属性说明如下:P1达状态到达稳定状态的概率不低于0.5,则事件E成立的概率不低于0.5.hungry→P1后最终吃到晚餐的概率不低于0.5;P3哲学家想吃晚餐最终都能吃到晚餐的概率不低于0.8,则事件E成立的概率不低于0.75;P1(TrueU(s1=12∧s2=12)):数据成功发送的概率为1.Page11表2自稳定协议的限界模型检测与无界模型检测比较self-stabilisingprotocolP1self-stabilisingprotocolP1self-stabilisingprotocolP1self-stabilisingprotocolP1self-stabilisingprotocolP1self-stabilisingprotocolP1self-stabilisingprotocolP1self-stabilisingprotocolP1self-stabilisingprotocolP1self-stabilisingprotocolP1表3哲学家就餐问题的限界模型检测与无界模型检测比较Randomizeddiningphilosophershungry→P1Randomizeddiningphilosophershungry→P1Randomizeddiningphilosophershungry→P1Randomizeddiningphilosophershungry→P1Randomizeddiningphilosophershungry→P1RandomizeddiningphilosophersP3RandomizeddiningphilosophersP3RandomizeddiningphilosophersP3RandomizeddiningphilosophersP3RandomizeddiningphilosophersP3表4CSMA/CA协议的限界模型检测与无界模型检测比较协议CSMA/CAP1(TrueU(s1=12∧s2=12))53CSMA/CAP1(TrueU(s1=12∧s2=12))53CSMA/CAP1(TrueU(s1=12∧s2=12))53CSMA/CAP1(TrueU(s1=12∧s2=12))53CSMA/CAP1(TrueU(s1=12∧s2=12))53CSMA/CAP1(TrueU(s1=12∧s2=12))53CSMA/CAP1(TrueU(s1=12∧s2=12))53CSMA/CAP1(TrueU(s1=12∧s2=12))54CSMA/CAP1(TrueU(s1=12∧s2=12))54CSMA/CAP1(TrueU(s1=12∧s2=12))54CSMA/CAP1(TrueU(s1=12∧s2=12))54CSMA/CAP1(TrueU(s1=12∧s2=12))54CSMA/CAP1(TrueU(s1=12∧s2=12))54CSMA/CAP1(TrueU(s1=12∧s2=12))54全局检测算法与限界检测算法状态空间可以显式表示也可以隐式表示,如符号化技术.因此我们避开状态空间表示的具体数据结构,从所需遍历的状态空间规模的角度比较限界检测与全局检测算法对主体个数界变元初始状态全局状态转换关系33<9401956304843<2020194404012053<37241930684942063<61961917424584852473<95801904342067259808空间的需求.为此表2~表4同时给出了利用模型检测工具PRISM[24]计算出的在全局状态空间下每个实例的初始状态数目,状态的数目以及转换关系的数目.Page12具有以下几个方面的特点:从表2~表4可以看出马尔可夫限界模型检测(1)该技术是一种前向搜索技术,不需要访问(2)在证据较短的情况下,所需内存空间少于(3)与基于MTBDD的方法不一样,该技术不所有的空间,且可以快速发现属性成立的证据.基于MTBDD的符号化模型检测技术.需要对变量进行排序.6终止标准的修正理论上,sksk+1,因此随着界的增长概率度量会逐渐递增.我们首先以自稳定协议和图3图3MDPM3终止判断准则1的核心是相连两次概率度量的差控制在预先设置的范围内时计算过程结束.对于数值序列x0,x1,…,当对任意的自然数i,|xi+2-xi+1|<|xi+1-xi|时准则1是有效的.但是对于表4中的两个概率度量序列都无效.对自稳定协议,当界为1时检测过程终止,此时概率度量为0;对于M3,当界为3时终止,此时概率度量为1/3.对上述两个实例,按照准则1得到的近似概率度量与真实的概率度量误差较大,因此必须对终止标准进行修正,从而使终止准则适用于图4中的曲线.所示的马尔可夫决策过程M3为例,研究随着界的增长概率度量增长的规律.在M3中验证的属性为9(Fr),这里r∈L(s2)∩L(s5)∩L(s8),rL(s0)P5∪L(s1)∪L(s3)∪L(s4)∪L(s6)∪L(s7)∪L(s8).图4中实线给出了在主体为3的情况下,概率度量s0,k(XP1pmin率度量pmin别代表了概率度量增长的典型规律.令pi表示界为i时得到的概率度量.第1种规律是p0,p1,…是从某点开始的严格递增序列,即存在j0使得对任意的ij,pi<pi+1,第2种规律是p0,p1,…为非严格递增序列,即对任意的j0,存在ij使得pi=pi+1.j=k-n+1修正方案1.比较界连续的多次概率度量之和.设n,k为自然数,在第k步如果∑kmin{Pr(sin,ψ,Adv,j)|Adv∈AdvM}-∑k-nj=k-2n+1则检测过程终止.具体过程如判断准则2所示.判断准则2.PCTL断(以修正方案1为终止标准).输入:MDPM=(S,sin,Act,Steps,Ap,L),PCTL输出:min{Pr(sin,ψ,Adv)|Adv∈AdvM}的近似值1.计算min{Pr(sin,ψ,Adv,0)|Adv∈AdvM},2.令k=2n-13.While∑kmin{Pr(sin,ψ,Adv,j)|Adv∈AdvM}ξ∧kmdo{令k=k+1,计算min{Pr(sin,ψ,Adv,k)|Adv∈AdvM};}4.输出min{Pr(sin,ψ,Adv,k)|Adv∈AdvM}.∑k-nj=k-2n+1Page13在判断准则2中取n=2可避免两个测试用例中的收敛问题.限界检测计算的概率度量序列是非严格递增的,因此n的值越大得出的度量越逼近真实值.这种方案的主要缺点在于需要预先设定n的值,而且n的最佳取值无法确定.修正方案2.比较概率度量和的比值.设k为自然数,在第k步如果∑kmin{Pr(sin,ψ,Adv,j)|Adv∈AdvM}∑k-nj=k-2n+1则检测过程终止.具体过程如判断准则3所示.判断准则3.PCTL案2为终止标准).输入:MDPM=(S,sin,Act,Steps,Ap,L),PCTLj=k-n+1输出:min{Pr(sin,ψ,Adv)|Adv∈AdvM}的近似值1.计算min{Pr(sin,ψ,Adv,0)|Adv∈AdvM},2.令k=2n-13.While∑k{令k=k+1,计算min{Pr(sin,ψ,Adv,k)|Adv∈AdvM};}4.输出min{Pr(sin,ψ,Adv,k)|Adv∈AdvM}.判断准则3亦避免了两个测试用例中的收敛问题,但是n的取值问题与判断准则2一样.7结论为了克服模型检测MDP中的状态空间爆炸问题,本文提出了在MDP上PCTL的限界检测技术.在具有马尔可夫性的随机系统模型中,MDP的主要特性在于具有非确定选择描述能力,在具体工作上本文结合该特性分别研究了概率计算树逻辑的限界语义、基于概率度量序列演化规律的检测过程终止判断准则、基于线性方程组求解的限界检测算法.进一步通过实验,说明了限界模型检测在属性为真的证据比较短的情况下,能快速验证属性,而且需求的空间比无界模型检测技术少.未来的主要工作是实现限界模型检测算法的符号化执行过程,同时挖掘MDP的结构,待验证的属性等因素与终止标准的关系,为设置一个完备的终止标准奠定基础.
