Page1高阶差分视角下的积分攻击董乐1),2),3)吴文玲1),2)吴双1)邹剑1),2),3)1)(中国科学院信息工程研究所北京100093)2)(中国科学院软件研究所北京100190)3)(中国科学院研究生院北京100149)摘要积分攻击和高阶差分攻击是分组密码的两种重要分析技术.尽管两者的理论基础并不相同,但是它们的攻击过程却十分相似.该文从高阶差分分析的视角来解释AES和Rijndael-256的积分区分器,证明高阶差分分析对此类算法同样有很强的分析能力.此外,改进了Rijndael-256的3轮区分器的数据复杂度.最后,给出了SPON-GENT杂凑函数中间置换的14轮零和区分器.关键词积分攻击;高阶差分攻击;AES;Rijndael-256;SPONGENT1引言自20世纪末,积分攻击[1-2]一直是分组密码的一种重要分析手段.它最早的分析对象是一个名为Square[3]的分组密码算法,所以开始被称为Square攻击,后来在对AES[1](AdvancedEncryptionStandard)的分析中扮演重要角色.2002年,Knudsen等人[2]将这一类分析方法命名为积分攻击,意为一个与差分攻击相对应的分析方法.这种分析方法,尤其适用于基于一些双射模块构造的算法.高阶差分攻击源于1994年Lai[4]提出的离散函数的高阶微分的概念.1995年,Knudsen系统地提出了高阶差分的概念,并将其应用于Feistel类密码[5].虽然这两种分析方法的理论基础不同,但是它们都是利用一组选择明文来构造区分器,使得在区分器的末端得到的密文的异或和为零(或者在某些比特为零),我们称为平衡状态或者局部平衡状态.更具体地说,都Page2是首先找到一些字节或者比特,习惯地称为活跃字节或者活跃比特,取遍这些字节或者比特的所有能取的值,同时其它比特的值取定不变,来构造一个明文结构,使得这些明文所有对应的密文的异或和,或者某些比特的异或和为零.积分攻击是对AES算法的最好的分析方法之一,并且对AES类算法的积分攻击是此攻击最具代表性的工作之一.依靠对若干个明文字节的值的遍历(其它字节取定值),在3轮和4轮核心积分区分器的基础上,对AES和Rijndael-256分别可以构造4轮和6轮的积分区分器[1,6].另一方面,如果想对算法低轮数的版本进行分析,可以以比特为单位选择活跃单元.2008年,Z’aba等人[7]提出了比特积分的思想,首次将积分攻击用于分析PRESENT这种基于比特设计的分组密码.2011年,Wei等人选择明文中5个字节的最低位比特作为活跃比特,以25的数据复杂度构造了Rijndael-256的3轮积分区分器[8].但是,对于此类区分器此数据复杂度是否最小还不明朗.本文通过对AES类算法的积分攻击的分析,给出AES积分攻击中的经典的3轮区分器和Rijndael-256的积分攻击中经典的4轮区分器的高阶差分解释,并且确定了通过对活跃字节位置的适当选取,可以得到Rijndael-256的4轮,最后状态为全平衡的高阶差分区分器.此外,我们对Rijndael-256的3轮低数据复杂度的积分区分器,给出了高阶差分解释,并且利用代数次数的增加规律进一步改进了数据复杂度.最后,我们还对基于比特设计的杂凑函数SPONGENT[9]其中一个版本的置换,进行了分析.通过对其代数次数增加情况的计算,给出了这一置换的14轮零和区分器.本文第2节介绍积分攻击与差分攻击等相关工作;第3节对本文涉及的算法AES、Rijndael-256和SPONGENT进行简要的介绍;第4节给出后面章节所用到的两个定理;我们在第5节用高阶差分解释AES和Rijndael-256的积分区分器;第6节解释并改进Rijndael-256的比特级积分区分器;第7节利用高阶差分构造SPONGENT内部置换的零和区分器;第8节总结并给出下一步的研究方向.2相关工作2.1积分攻击积分攻击[1-2,6]源于对AES的前身Square分组密码算法的一种攻击.攻击过程中,一些明文字节被选定为常数,记为C,其它字节,一般称为活跃字节,取遍所有的256个值,这些字节记为A.如果在若干轮之后得到一个平衡状态,即异或和为零的状态,则我们说构造了一个积分区分器.最后利用猜测密钥进行部分解密来恢复密钥.2.2高阶差分攻击高阶差分攻击的理论基础为密码函数的高阶微分的定义及性质.1994年,Lai[4]给出了密码函数微分的定义.定义1.设P为一个Fn的a∈Fn而P在点a1,a2,…,ai处的i阶微分定义为Da1,a2,…,aiP(x)=Dai(Dai-1(…Da1P(x)))一个函数的一阶微分的代数次数有性质deg(DaP(x))degP(x)-1.所以,对于任意的(degP+1)维的子空间V,或者是任意的(degP+1)个点a1,a2,…,adegP+1,置换P的(degP+1)阶微分为零.高阶差分攻击就是利用这些性质,首先计算所攻击函数的代数次数的上界d,然后选择d+1个比特作为活跃比特,取定其它比特的值,遍历这些活跃比特的所有值,则可以在函数输出端得到平衡状态,即构造了一个高阶差分区分器.2009年,Aumasson等人利用高阶差分的思想,构造了杂凑函数KEC-CAK、Luffa和Hamsi的“零和区分器”.这种区分器从中间起始向两边构造高阶差分路径,最后在两端得到平衡状态.本文中积分攻击和高阶差分攻击中的平衡状态指的都是“异或和为零”的状态;活跃字节和活跃比特都是指攻击的时候需要遍历的字节和比特.3算法简述3.1AES和Rijndael-256算法简述AES分组密码算法是美国于2001年颁布的高级加密标准,分组长度为128比特,密钥长度分别为128、192和256比特,对应这3种长度的密钥,加密过程分别有10、12和14轮.AES的状态基于字节可以写成一个4×4的矩阵Page3其中下标对应该字节所在的行和列的位置.下文我i,k来表示第j轮的输入状态中第i+1行第们用a(j)k+1列的字节,此外,我们用b(j)输出状态中第i+1行第k+1列的字节.AES的轮函数有4个运算:(1)字节代换(SubBytes):状态中的每一个字节通过同一个8×8的S盒层,图中简记为SB.(2)行移位(ShiftRows):第i行以字节为单位,向左循环移动i-1个位置,图中简记为SR.(3)列混淆(MixColumns):状态的每一列乘上一个MDS(MaximumDistanceSeparable)矩阵,图中简记为MC.(4)轮密钥加(AddRoundKey):中间状态和轮子密钥进行异或,图中简记为AK.此外,在第1轮加密之前,有一个轮密钥加层;最后一轮没有列混淆层.Rijndael-256[10]是AES的前身Rijndael分组密码算法的一个版本,它的分组长度为256比特,密钥长度也是256比特,轮数为14轮.基于字节其状态可以记为一个4×8的矩阵a0,0a0,1a0,2a0,3a0,4a0,5a0,6a0,7烄a1,0a1,1a1,2a1,3a1,4a1,5a1,6a1,7a2,0a2,1a2,2a2,3a2,4a2,5a2,6a2,7a3,0a3,1a3,2a3,3a3,4a3,5a3,6a3,烆Rijndael-256的轮函数与AES类似,需要说明的是,行移位运算为,以字节为单位,第1、2、3、4行分别向左循环移动0、1、3、4个位置.下文表示中间状态的时候,我们用矩形表示代替矩阵表示,字节的表示方法不变.本文没有涉及AES和Rijndael-256的密钥生成算法,详细描述请参考文献[1,10].3.2SPONGENT-88/80/8算法简述SPONGENT是在CHES2011会议上提出的一个新的轻量级杂凑函数.它采用了海绵结构,其中中间置换又应用了PRESENT[11]类型的置换.海绵结构是一种由固定置换构建杂凑函数的新选择,它分为“吸收”和“榨取”两个部分.吸收部分每次将r比特消息块异或在状态前r比特上,然后进入一个大小为b比特固定置换,直到处理完所有的消息.接着便进入榨取部分,每次在将状态的前r比特输出之后,再进入同样的固定置换,直到输出比特的长度达到摘要的长度n.SPONGENT使用一种类似轻量级分组密码PRESENT的函数作为中间置换,此置换应用于b比特的中间状态.轮函数包含3个运算:(1)S盒层(sBoxLayer):每4个比特进入同样的4×4的S盒.(2)比特置换层(pLayer):相当于PRESENT的比特置换的逆向扩展,它将状态的第j比特移动到第Pb(j)比特,其中Pb(j)=j×b/4mod(b-1),j∈{0,…,b-2}(3)轮常数加层(lCounter):状态的某些比特异或上轮常数.SPONGENT-88/80/8是SPONGENT杂凑函数的一个版本,它每次吸收或者榨取的比特数为8,置换的大小为80+8=88比特,置换所含轮数为45,摘要长度也是88比特.有关此算法的更多信息请参考文献[9].4基础知识为了更好地将积分攻击和高阶差分攻击联系起来,本节我们讨论一些常见函数的代数次数具备的性质.我们记n元布尔函数f(x)为Fn函数,其中x为n元自变量x=(x1,x2,…,xn).使得f(x)=1的x的个数称为f(x)的汉明重量,记为WH(f).特别地,如果WH(f)=2n-1,我们称f(x)为平衡布尔函数.布尔函数有多种表示方式,其中常用的一种为多项式表示.我们常常将变元升幂并且下标按字典序写出的多项式表达式f(x)=a0+a1x1+a2x2+…+anxn+a12x1x2+…+称为f(x)的代数正规型.布尔函数f(x)的代数次数定义为其代数正规型中具有非零系数的乘积项中的最大次数,而一个乘积项的次数定义为此项所含的变元的个数.不影响理解的情况下,代数次数有时简称为次数.我们称Fn布尔函数,其中x=(x1,x2,…,xn)∈Fn(f1(x),f2(x),…,fm(x))=(y1,y2,…,ym)∈Fm向量布尔函数的每一个分量fi(x)都是一个布尔函数.若向量布尔函数像集中的每一个元素的原像个数都相同,则称其为平衡向量布尔函数.首先我们给出一个已知的结论.数,若它的汉明重量WH(f)为偶数,则其代数正规型无最高次项.特别地,平衡布尔函数没有最高次项.引理1[12].设f(x)为FnPage4证明.易知f(x)代数正规型的最高次项系数a12…n=∑x∈Fn这里求和为实数求和,则a12…n=0当且仅当WH(f)为偶数,即最高次项不出现.引理1的详细说明请参看文献[12].我们将此结果扩展至向量布尔函数的情况.定理1.设F为Fn数,其中nm,则F的每个分量fi(x)的代数次数至多为n-1.证明.由F为平衡向量布尔函数知,F的像2中的每一个元素均有2n-m个原像.考虑其中集Fm任一个分量fi(x),Fm1,所以使得fi(x)=1的x的个数为2n-m×2m-1=2n-1,即fi(x)为平衡布尔函数.由引理1,其次数至多为n-1.利用定理1我们可以对一些向量布尔函数进行分析.有时从一个函数的局部入手,反推至整个函数,可以得到更好的结果.我们考虑F为Fn向量布尔函数.对其n元自变量x=(x1,x2,…,xn)中的某n-t个变元取常值,剩下的t个变元仍为变量,新的t元自变量记为珟x.并考察其像(f1(珟x),f2(珟x),…,fm(珟x))中的t个分量,则每个分量都变成一个t元布尔函数,将它们仍按照原来的顺序写成向量的形式(f1(珟x),f2(珟x),…,ft(珟x)),便构成了一个Ft部向量布尔函数,记为F.我们从其局部的向量布尔函数F入手进行分析,再进行变量扩充,可以得到下面的结果.果对于选定的n-t个变元取任意常值,并考察其像的特定的t个分量,所得的Ft函数F均是平衡的,则定理2.设F为Fn(1)其每个分量的代数次数至多是t-1.(2)将其它任意s-t个常值比特重新取为变量,将其扩充为一个Fs每个分量的代数次数至多为s-1.证明.F为平衡向量布尔函数,由定理1可知其每个分量的代数次数至多为t-1.若其扩充的函数F中某个分量的代数次数达到s,即其代数正规型中最高次s次项的系数为1,将重新取为变量的s-t个比特全部取1,则可得一个新的对于选定的n-t个变元取常值,并考察其像的特定的t个分量的Ft数,并且此函数有一个分量存在最高次s次项,则其不是平衡的,与已知矛盾.故扩充函数每个分量的代数次数至多为s-1.一般的分组密码和杂凑函数都是基于置换构造,并且都是相似置换的迭代组成.但是,对于局部进行分析,并非都是置换,所以关键之处在于找到局部到局部的置换,或者是平衡函数.根据这个定理2,如果我们可以证明状态的局部(例如一个字节)到后面某状态的局部是一个平衡函数或者是双射的话,那么令“始状态”的这个局部的所有比特为变量,状态的其它比特为常数,“末状态”的这个局部的代数次数,一定小于“始状态”的这个局部的比特数.5用高阶差分解释已有的积分区分器本节我们利用代数次数的变化规律解释一些经典的积分区分器,分别对AES的3轮积分区分器、Rijndael-256的4轮积分区分器给出高阶差分解释.5.1解释AES的3轮积分区分器Daemen和Rijmen在提交他们设计的AES候选算法时,给出了所提交算法的Square攻击过程,此攻击也可看做是AES的积分攻击.AES的3轮积分区分器如图1所示.在明文状态取遍一个字节的256个值,其它字节取常数,到第3轮结尾得到一个平衡状态,路径的推导细节请参看文献[10].而我们也可以从高阶差分的角度,利用对代数次数的分析,得到这个“0-和”路径,如图2所示,方框中数字代表此字节中所有比特的代数次数上界,空白方框代表每个比特代数次数均为零的字节.Page5现在我们给出AES的3轮积分区分器的高阶差分路径:(1)起始状态.取a(1)x1,x2,…,x8,其它字节任取为常数.起始状态中此字节的每个比特代数次数为1,其它常数比特的代数次数为0.(2)第1轮.经过第1轮S盒以后,b(1)特代数次数为7,其它仍为0.经过行移位不变.经过列混淆后第1列的32个比特的代数次数都变为7.加上轮密钥后保持不变.(3)第2轮.a(1)0,0,b(2)节b(2)0,0处引入任何一个非零差分,则其可以扩散到第1a(1)轮输出状态第1列的每个字节,所以,b(2)必然不为零,即a(1)取值,逆向计算都有一个a(1)0,0也是一个满射,所以为双射,即置换.由定理1到b(2)可知,第2轮S盒层输出状态第1列的每一个字节,所含比特的代数次数上界仍为7.经过后面的3个线性运算,可得第2轮输出状态的每一个比特的代数次数也都不高于7.(4)第3轮.同样,我们可以用相似的证明过程证明a(1)0,0到第3轮的S盒层输出状态的每一个字节也都是置换.则此状态的每个比特的代数次数都不超过7.由此推得,第3轮结束时每个比特的代数次数都至多为7.这样,取定起始状态中a(1)0,0所有值,会在第3轮结尾得到平衡状态.a(1)5.2解释Rijndael-256的4轮积分区分器在2008年的非密会上,Galice和Minier给出了Rijndael-256的4轮积分区分器[6],如图3所示,图4Rijndael-256的4轮单字节起始代数次数增加情况利用此区分器,最多可以攻击9轮的Rijndael-256算法.Rijndael-256的4轮积分区分器应用3阶积分,即在起始状态选择3个字节,取遍这3个字节的所有224个值,其它字节任取为定值.可以推得第4轮的输出状态的第3列和第7列共8个字节是平衡的.路径的推导细节请参看文献[6].同样,我们可以用高阶差分的视角来解释这条路径.我们首先对单字节8个比特变量代数次数增加情况进行分析,然后利用单字节代数次数的增加性质,推导出3个字节24个比特作为变量,在4轮结束时,状态中所有字节的代数次数的上界.图4为选择字节a(1)情况.方框中数字代表此字节中所有比特的代数次Page6数上界,空白方框代表每个比特代数次数均为零的字节.差分路径:首先我们给出单字节8个比特变量的4轮高阶(1)起始状态.取a(1)(3)第3轮.类似地,我们可以推知a(1)字节任取为常数.起始状态中此字节的每个比特代数次数为1,其它常数比特的代数次数为0.(2)第1轮和第2轮.前两轮的分析和AES类0,0的8个比特变量在第2轮结束时,使得状态似.a(1)的第1、5、6、8列比特的代数次数上界为7,而其它字节的所有比特均为常值.轮S盒层的输出状态的第1、5、6、8列的每个字节都是置换.由定理1,这些字节所有比特的代数次数都不超过7.我们注意到,在第3轮的列混淆层输入中,第3列和第7列都只有一个字节含有变量,所以a(1)到第3轮输出状态的第3列和第7列中每个字节都是置换,这个性质可以延伸到第4轮的S盒层之后.(4)第4轮.由上面第3轮的推导可以得出,a(1)到第4轮中S盒层输出状态的第3列和第7列的每个字节都是置换,所以这8个字节的所有比特的代数次数都不超过7,而其余的字节所含比特没有此性质,但是由于只有8个变量,所以其余字节所含比特的代数次数上界为8.由图4我们可以看到,从一个活跃字节出发,无法得出第4轮输出状态的某些图5Rijndael-256的4轮区分器的最后3个运算根据上述结论,我们可以同时选择4个字节,使得第4轮输出状态全部比特的代数次数都达不到最大的32.这样我们可以以232的复杂度得到4轮的“完全”平衡状态,而不是只有两列平衡.事实上,我们选择a(1)即可.6用高阶差分改进积分区分器2011年,Wei等人利用比特级积分改进了Rijndael-256基于字节的积分区分器[8],将其3轮积分区分器的数据复杂度从28降至25.此区分器首先选择a(1)比特,取定其它比特的值,遍历这5个比特的所有0,0,a(1)字节平衡,但是我们得到第4轮的S盒层之后,有两列所含比特的代数次数都没有达到最大的8次.由上面给出的单字节4轮高阶差分路径,如果我们选起始状态中a(1)个3.25轮的区分器.利用此性质我们来构造3个字节24个比特变量的4轮高阶差分路径:(1)与上述单字节路径类似,如果在起始状态中选择a(1)轮S盒层之后得到第4列和第8列,或者第2列和第6列所有比特的代数次数达不到最大的8次.(2)如果我们同时选择这3个字节所含的24个比特为变量,对于图4所示的单字节起始路径来说,相当于将a(1)变量.由定理2可得,第4轮中S盒层输出状态的第3列和第7列,所有比特的代数次数都不会超过23.分别由a(1)用相似的过程得到此状态的第2、4、6、8列所有比特的代数次数也至多为23.(3)容易知道,经过第4轮的行移位、列混淆和轮密钥加运算,可得第4轮的输出状态的第3列和第7列的所有比特的代数次数都不超过23.如图5所示.的值,并遍历这3个字节的所有值,会在第4轮结尾得到平衡状态.这样,取定起始状态中a(1)1,0,a(1)32个值,则可以在3轮之后得到一个全平衡状态.6.1解释Rijndael-256的3轮比特积分区分器我们可以在高阶差分的视角下,利用代数次数的增加情况来解释这条路径.如图6所示,设字节0,0,a(1)a(1)x3,x4,x5,它们在区分器中是要遍历的活跃比特,所以在研究代数次数的时候以变量形式出现.图中数字代表该字节所有比特代数次数上界,下标代表该字节所有比特的代数正规型中至多包含的变量.例如1145表示该字节的所有比特的代数次数至多为1,并且代数正规型中至多可能出现x1,x4,x5,换句话说,一定不会出现x2,x3.此外,为了记法的方便,我们采用带负号的下标,例如1-5表示,代数正规型中一定不会出现x5.Page7图6Rijndael-256的3轮5阶高阶差分路径我们下面给出Rijndael-256的3轮比特起始区分器的代数次数增加情况说明:(1)第1轮.起始状态中含有变量的字节都只有一个变量,这样第1轮的S盒实际上可以看作是一个线性运算,也就是说,在第1轮S盒的输出状态中,这5个字节的所有比特的代数次数至多是1.经过后面的几个线性扩散运算,在第1轮的末端,有5列都含有变量,但是显然代数次数仍然至多为1,并且含变量的字节仍然只含有一个变量.(2)第2轮.由上面的分析,第2轮的输入状态中含有变量的字节都只有一个变量参与运算,这样其输出状态中的代数次数仍然至多为1.经过后面的线性扩散运算,会使得状态的每个比特都可能含有变量,代数次数的上界仍然为1,但是,有些比特的代数正规型中,可能会含有多个变量,例如第1列中的某些比特可能会同时含有x1,x4,x5.图7Rijndael-256的3轮3阶高阶差分路径(1)起始状态.我们在a(1)我们下面给出Rijndael-256的3轮3阶高阶差分路径的说明:中分别任取一个比特作为活跃比特,记为x1,x2,x3,其它比特取为定值.(2)第1轮.起始状态中含有变量的字节都只这样,在其它比特取定值,a(1)(3)第3轮.我们知道,含有多个变量的字节,经过S盒层之后,代数次数一定不可能大于其所含变量的个数.而第3轮的输入中,每个字节至多可能含有4个变量,这样在第3轮的S盒层的输出状态中,所有比特的代数次数不可能大于4,而后面都是线性运算,所以,在第3轮的末端,状态中所有比特的代数次数都不会超过4次.0,1的最低位比特取遍所有32个值,可以在3轮之a(1)后得到平衡状态.6.2改进Rijndael-256的3轮比特积分区分器我们利用代数次数的增加,解释了Rijndael-256的3轮比特积分区分器.但是事实上,此区分器并没有将数据复杂度降低到最小,如果利用代数次数进行分析,可以找到涉及更少明文的“零和”区分器.图7为Rijndael-256的3轮3阶高阶差分区分器,图中符号代表的意义与图6相同.有一个变量,所以在第1轮S盒的输出状态中,这3个字节的所有比特的代数次数至多是1.经过后面的几个线性扩散运算,在第1轮的末端有3列含变量,而且代数次数仍然至多为1,含变量的字节仍然只含有一个变量.(3)第2轮.第2轮的输入状态中含有变量的Page8字节同样只有一个变量,这样其输出状态中相关比特的代数次数仍然至多为1.经过后面的线性扩散运算,除第2列外,状态的每个比特都可能含有变量,其中第1列和第3列比特至多含有一个变量,其余5列至多含有两个变量,代数次数的上界仍然为1.(4)第3轮.由上一轮的分析,我们得到所有的字节所含的变量数都不大于2,这样在第3轮的S图8Rijndael-256的3轮2阶高阶差分路径我们在a(1)作为活跃比特,记为x1,x2,其它比特取为定值.则可以在第1轮后得到代数次数至多为1,且每个字节至多含一个变量的两列,其它列为常数.同样,第2轮之后每个比特的代数次数都不超过1,并且我们得到两个常数列,此外有第1、4、6、7列中每个字节只含有1个变量,只有第5列和第8列中字节可能含有两个变量.这样在第3轮的S盒层之后除第5列和第8列外的所有比特的代数次数都不超过1.再经过行移位、列混淆和轮常数加运算,我们发现第3列和第6列中所有比特代数次数都不超过1.这样,在其它比特取定值,选定的两个比特取遍所有4个值,可以在3轮之后得到局部平衡状态.7构造SPONGENT的零和区分器2009年,Aumasson等人利用高阶差分的思想,提出了“零和区分器”的概念.本节我们利用SPON-GENT函数代数次数的增加情况,对其最轻量级版本SPONGENT-88/80/8的内部置换构造零和区分器.SPONGENT的内部置换采用的是PRESENT类的置换类型,对于高阶差分分析来说,其S盒层不但提供代数次数的增加,而且提供各个比特变量的混淆.但是,由于其轮函数中比特置换层的对称性,加上其4比特S盒中有一个比特的代数次数没有达盒层的输出状态中,所有比特的代数次数不可能大于2,而后面都是线性运算,所以,在第3轮的末端,状态中所有比特的代数次数都不会超过2次.这样,在其它比特取定值,选定的3个比特取遍所有8个值,可以在3轮之后得到平衡状态.如果我们放弃最后状态所有比特都要平衡的要求,我们还可以以更少的明文个数得到3轮部分平衡的高阶差分区分器,如图8所示.SPONGENT采用的4×4的S盒可以记为到最高的3次,导致其轮函数迭代对应的代数次数增加比期望的要慢.我们便由其S盒中每个比特的代数次数出发,来研究轮函数的代数次数增加情况,进而构造零和区分器.S[16]={E,D,B,0,2,1,4,F,7,A,8,5,9,C,3,6}.如果将其4比特输入,由高位向低位依次记为a1,a2,a3,a4,4比特输出由高位向低位依次记为b1,b2,b3,b4,则其代数正规型可以写为b1=a1a2a4+a1a3a4+a1a3+a1a4+a3a4+a1+a2+1,b2=a1a2a3+a1a4+a2+a3+1,b3=a1a2a3+a1a2+a1a3+a1a4+a2a3+a4+1,b4=a2a3+a1+a3+a4.这样,即使S盒的4个输入比特都取为变量,其输出的4个比特中也会有一个为2次,其它的为3次.此外,我们还将用到此S盒的逆的代数正规型.将S盒的逆的4比特输入,由高位向低位依次记为a1,a2,a3,a4,4比特输出由高位向低位依次记为b1,b2,b3,b4,则其代数正规型可以写为b1=a2a3+a2a4+a3a4+a1,b2=a2a3a4+a1a3+a2a3+a3a4+a2+a3+a4,b3=a2a3a4+a1a2+a2a3+a2a4+a3+a4+1,b4=a1a2a4+a1a3a4+a2a4+a1+a2+a3+1.其输出的4个比特中也会有一个为2次,其它的为3次.我们根据此S盒代数次数的性质,加上比特置Page9换层的对称性,给出SPONGENT-88/80/8函数置换的14轮零和区分器.SPONGENT-88/80/8的置换函数状态大小为88比特,采用4×4的S盒,所以每轮含有22个并行的S盒作为S盒层,我们从左至右记为第1,2,…,22个S盒.S盒层的输出通过一个比特置换层交换比特的位置.而轮常数加运算因为不会给代数次数上界带来影响,在我们的分析中将其忽略.我们所给的14轮零和区分器包含两个部分,8轮的正向部分,我们记为第7~14轮;6轮的逆向部分,我们记为第1~6轮.而起始的中间状态,为第6轮的输出状态,选择了21个S盒的84个比特作为活跃比特.7.1区分器的第9~14轮高阶差分路径首先我们给出正向部分中第9~14轮的高阶差分路径.(1)起始状态.第9轮的输入状态有4个S盒作为活跃S盒,即包含16个活跃比特,这4个活跃S盒分别为第1,8,15,19个S盒.由于轮函数中的S盒是一个置换,所以第9轮S盒层中上述4个S盒输出的16个比特仍然是活跃且独立的.我们从第9轮S盒层的输出状态出发,将活跃的16个比特记为变量x1,x2,…,x16,其它比特为常数,计算第9~14轮的每个比特的代数次数的上界.(2)第9轮.16个活跃比特通过比特置换层后,位置发生了变化,使得第10轮的S盒输入中,至多有一个变量进入同一个S盒,还有6个S盒没有变量进入.表1的第2行,给出了第9轮输出状态中每个比特的代数次数的上界,同一个小括号中的数字,代表要进入下一轮同一个S盒的4个比特的代数次数的上界.(3)第10轮.我们知道,一个变量比特进入S盒之后,S盒的所有输出比特都可能和这个变量相关,则它们的代数次数都可能会从0变为1.所以,16个变量通过第10轮的S盒层后,会使得输出状态中,与它们相关的64个比特的代数次数上界变为1.但是仍然有22-16=6个S盒中没有变量参与运算,即S盒层输出比特中有24个,代数次数仍为0.经过比特置换交换位置,此轮输出状态的所有比特代数次数上界见表1第3行.(4)第11轮.从第11轮开始,代数次数的计算开始利用S盒的代数正规型,我们由S盒4个输入比特的代数次数,来估计可能产生的最高次项的次数.以第11轮的第1个S盒为例,由第10轮的输出我们知道,此S盒的4个输入比特代数次数上界为(1,1,0,1),又其输出的第1个比特含有3次项a1a2a4,由输入比特的代数次数上界知道a1,a2,a4都可能含有变量,所以这一比特的代数次数上界为3.此S盒的第2个输出比特中含有3次项a1a2a3,而a3代数次数为0,即为常值不含变量,所以此3次项的代数次数至多为2,则这个比特的代数次数上界为2.同样可以推知,第3个和第4个输出比特的代数次数上界分别为2和1.利用这一方法,可以推得第11轮S盒层输出的所有比特代数次数的上界,再由比特换位运算得出第11轮输出状态的所有比特代数次数上界,见表1第4行.轮数9111210(1,0,0,0),(0,0,0,1),(0,0,0,0),(0,0,1,0),(0,0,1,0),(0,0,1,0),(0,0,0,0),(0,1,0,0),(0,0,0,0),(1,0,0,0),(1,0,0,0),(1,0,0,0),(0,0,0,1),(0,0,0,0),(0,0,1,0),(0,0,1,0),(0,0,1,0),(0,0,0,0),(0,1,0,0),(0,0,0,0),(1,0,0,0),(1,0,0,0)(1,1,0,1),(1,1,0,1),(0,1,1,1),(1,0,1,1),(1,0,1,0),(1,1,1,1),(0,1,1,1),(0,1,0,1),(1,1,1,0),(1,1,1,0),(1,0,1,1),(1,1,0,1),(1,1,0,1),(0,1,1,1),(1,0,1,1),(1,0,1,0),(1,1,1,1),(0,1,1,1),(0,1,0,1),(1,1,1,0),(1,1,1,0),(1,0,1,1)(3,3,2,3),(2,3,2,2),(2,2,3,3),(3,2,3,2),(3,2,2,2),(2,3,2,2),(2,2,2,3),(2,1,3,3),(2,2,2,2),(2,2,3,2),(1,3,3,2),(2,2,2,2),(2,3,2,1),(3,3,2,2),(2,2,2,2),(3,2,1,3),(3,2,1,1),(2,1,1,2),(2,1,2,2),(1,1,1,2),(1,1,2,2),(1,2,2,1)(9,7,8,8),(7,7,7,8),(6,7,6,6),(6,8,6,8),(6,5,6,4),(5,4,8,7),(7,8,7,7),(6,6,6,7),(7,6,7,8),(6,6,6,4),(5,3,4,5),(8,7,7,8),(7,7,6,6),(6,7,7,6),(7,8,6,6),(6,4,5,3),(4,5,5,5),(5,5,4,5),(4,4,4,5),(6,4,5,5),(4,3,3,2),(3,2,3,4)(16,16,16,16),(16,16,16,16),(16,16,14,16),(16,16,16,14),(14,15,13,16),(9,10,16,16),(16,16,16,16),(16,16,16,16),(12,16,16,16),(16,15,14,14),(12,15,10,8),(16,16,16,16),(16,16,16,16),(16,16,12,16),(16,16,16,15),(14,14,12,15),(10,8,15,14),(13,14,11,12),(15,12,13,12),(7,14,13,14),(14,9,10,9),(8,9,6,5)(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,16),(16,16,16,15)(5)第12轮和第13轮.按照同样的方法,我们可以向后再推两轮,在第13轮的输出状态中,得到所有比特的代数次数上界,值得注意的是进入第14轮的最后一个S盒的4个比特的代数次数上界为(8,9,6,5).(6)第14轮.由于共有16个变量参与运算,故1314Page10所有比特的代数次数至多为16.但是,我们发现此轮的最后一个S盒的最后一个比特的代数次数至多为15.这是因为,最后一个比特的4个项a2a3、a1、a3、a4的代数次数上界分别为15、8、6、5,所以此比特代数次数不超过15.这样,在第9轮的S盒层输出状态中,选定的16个活跃比特取遍所有216个值,其它比特取定值,可以在第14轮之后使得状态的最后一个比特平衡.7.2区分器的第1~4轮高阶差分路径下面我们给出逆向部分第1~4轮的高阶差分路径,我们按照代数次数增加的顺序,将第4轮的输出状态定为起始状态,逆向至第1轮进行代数次数上界的计算.(1)起始状态.第4轮的输出状态的前16个比特作为活跃比特.我们从此状态出发,将活跃的16个比特记为变量x1,x2,…,x16,其它比特为常数,计算第4~1轮的每个比特的代数次数的上界.(2)第4轮.由于第4轮的输出状态中前16个比特为变量,逆向计算先通过比特置换运算,16个变量进入16个逆S盒,分别为它们的最高位比特,最后的6个S盒没有变量进入.在逆S盒的输出状态(正向看为第4轮的输入状态)中前16个有变量进入的逆S盒的所有64个比特位置都有可能含有变量,但是由于每个逆S盒只有一个变量进入,所以此状态中前64个比特的代数次数上界为1;由于后6个逆S盒没有变量进入,所以此状态中后24个比特的代数次数为0.见表2第2行.(3)第3轮.第4轮的输入状态逆向计算通过比特置换层后,使得第3轮逆S盒层的输入状态中,前20个S盒的输入代数次数模式都是(1,1,1,0),即前3个输入比特的代数次数上界都是1,最后一个比特的代数次数上界为0.它们的输出比特的代数次数上界需要根据S盒的逆的代数正规型来计算.首先计算逆S盒的第1个输出比特,根据代数正规型,此比特的最高次项为2次,并且里面有一项为a2a3,而其输入中a2,a3两个比特的代数次数都可能为1,所以第1个输出比特的代数次数上界为2.第2个和第3个输出比特中都只有3次项a2a3a4,而我们知道a4的代数次数为0,所以这两个比特的代数次数上界也为2.同样,第4个比特的两个3次项中都含有a4,则它的代数次数上界也为2.所以,逆S盒的输入代数次数模式(1,1,1,0)的输出代数次数模式为(2,2,2,2).而第3轮逆S盒层的输入状态中,后2个S盒的输入代数次数模式为(1,1,0,0),可以计算它的输出代数次数模式为(1,1,2,2).见表2第3行.(4)第2轮和第1轮.按照同样的方法,我们可以向前再推两轮,在第1轮的输入状态中,得到所有88个比特的代数次数上界,其中的40个比特的代数次数不能达到最大的16.轮数3214(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(1,1,1,1),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0)(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(2,2,2,2),(1,1,2,2),(1,1,2,2)(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,6,6,6),(4,5,5,5),(4,5,5,5),(4,6,6,6),(4,6,6,6),(4,5,5,5),(4,5,5,5),(4,6,6,6),(4,6,6,6)(12,16,16,16),(12,16,16,16),(10,14,14,16),(12,16,16,16),(12,16,16,16),(12,16,16,16),(10,14,14,16),(12,16,16,16),(11,15,15,15),(12,16,16,16),(10,14,14,16),(12,16,16,16),(11,15,15,15),(11,16,16,16),(9,13,13,15),(12,16,16,16),(12,16,16,16),(12,16,16,16),(9,13,13,15),(12,16,16,16),(12,16,16,16),(12,16,16,16)这样,在第4轮的输出状态中,选定的16个活跃比特取遍所有216个值,其它比特取定值,可以在第1轮的输入处得到平衡状态.7.3区分器的第5~8轮高阶差分路径本小节我们将上两个小节的高阶差分路径进行组合,构造一个14轮高阶差分路径,从而得到一个14轮的零和区分器.我们知道在积分攻击中,对于一条积分路径来说,如果可以找到一个状态,在经过一轮计算以后,得到的活跃且独立的字节,包含原积分路径起始状态中的所有活跃字节,则可以将这一轮加在原积分路径的前面,这样就构造了一个比原来多一轮的积分路径.如果原积分路径最后得到平衡状态,则新的多一轮的路径也可以得到平衡状态.我们在此也利用这一技术,进行两条子高阶差分路径的组合.如图9所示,从第9轮的S盒层逆向计算可以得出,若使得第9轮的第1、8、15、19个S盒的16个比特活跃且独立,需要第8轮的S盒层的第1、2、3、4、7、8、9、10、13、14、15、16个S盒的输出比特活跃且独立,而使得第8轮的这些S盒活跃且独立,需要第7轮的前面20个S盒的输出比特活跃且独立;另Page11外一个方向,若使得第5轮的第1、2、3、4个S盒的16个输入比特活跃且独立,需要第6轮的S盒层的第1、6、7、12、17、18个S盒的输出比特活跃且独立,而使得第6轮的这些S盒活跃且独立,需要第7轮的第1、2、3、5、6、7、8、9、10、12、13、14、16、17、18、图9SPONGENT零和区分器的4~9轮这样,我们用了284的数据复杂度,得到了SPONGENT-88/80/8中间置换的14轮零和区分器.此区分器从第7轮的输入出发,选择前21个S盒的84个输入比特作为活跃比特,分别进行正向和逆向的攻击,可以在第1轮的输入处得到284个整个14轮置换的输入值,使得它们的异或和为零,并且它们对应的输出的异或和也为零.8结束语本文在高阶差分的视角下解释了具有代表性的AES和Rijndael-256的积分攻击.并且改进了Rijndael-256的3轮积分区分器的数据复杂度.此19、20、21个S盒的输出比特活跃且独立.综合这两个方向,取它们的并才能满足所有的条件.所以,若要使得正向和逆向的起始状态中活跃S盒的个数达到前面的要求,必须选择第7轮的输入状态的前21个S盒的84个比特活跃.外,还利用代数次数的增加性质,对一个新的轻量级杂凑函数SPONGENT的内部置换,构造了14轮的零和区分器.下一步的研究方向是从积分攻击和高阶差分分析的理论基础出发,进一步更深层次地发现这两种攻击的联系.此外,进一步改进SPONGENT置换的零和区分器,并尝试用于此函数的其它版本中去.
