Page1BIOP:自动构造增强型ROP攻击邢骁陈平丁文彪茅兵谢立(南京大学软件新技术国家重点实验室南京210093)(南京大学计算机科学与技术系南京210093)摘要针对传统的代码注入和代码复用等攻击技术的缺陷,返回导向编程(Return-OrientedProgramming,ROP)提出了复用以ret指令结尾的短指令序列,实现图灵完备编程的思想.ROP攻击可以绕开现有的针对代码注入的防御,且相比于传统代码复用技术,构造功能更为强大.但ROP攻击使用的ret指令结尾的指令序列具有明显的特征,这些特征导致ROP攻击容易被检测到.现有的ROP改进技术使用jmp指令结尾的短指令序列构造攻击,虽然消除了以ret指令结尾的特征,但同时引入了新的特征,且并不具有实用性.文中提出了一种分支指令导向(BranchInstruction-OrientedProgramming,BIOP)攻击技术,使用jmp指令或call指令结尾的短指令序列构造攻击.相比于以前的工作,BIOP不引入新的特征,能有效避免现有的防御技术.同时我们分析并解决了构造攻击时寄存器的副作用,提出控制指令序列概念解决构造时内存冲突,实现自动化构造BIOP攻击.作者设计了一个自动化构造BIOP工具,构造了大量实际的BIOPshellcode,实验结果表明BIOP攻击可以绕过现有的ROP防御技术.关键词返回导向编程;指令序列;寄存器副作用;自动化;信息安全;网络安全1引言传统的攻击方法通常使用代码注入和代码复用技术.现在流行操作系统中普遍部署的数据执行保护技术(如Linux系统中PAX补丁①和Windows系统中的DEP②),可以对代码注入技术实施有效的防御.传统代码复用技术如return-to-libc攻击技术[1],依赖于库中的函数功能,攻击能力受到严重限制.且现有的防御方法如Libsafe③,通过替换特定的库函数有效的防御该攻击.返回导向编程(Return-OrientedProgramming,ROP)技术是由Shacham[2]在2007年提出的代码复用技术,它复用现有的库和可执行代码中以ret结尾的指令序列(gadget),通过将地址和数据压入栈,使程序从一个指令序列跳到另一个指令序列,实现任意的恶意行为.与传统的攻击方法相比,ROP无需引入恶意代码,可以有效绕开数据执行保护技术,同时ROP更细粒度复用短指令序列,增加了攻击构造能力和检测难度,被认为是一种更强大的攻击技术④.但由于ROP使用以ret结尾的指令序列构造攻击,这种明显的特征使ROP攻击容易被检测到,常用的检测方法有:(1)正常的程序中,call指令和ret指令存在一一对应关系,而ROP使用单独的以ret结尾指令序列,call指令和ret指令不匹配.利用这种特性,文献[3-4]分别从硬件和软件角度对ROP攻击进行检测;(2)ROP攻击常常频繁复用多个ret结尾的短指令序列,文献[5-6]利用这个特性,检测是否存在多个连续的ret指令序列,以检测ROP攻击;(3)消除系统中库函数或可执行代码中的ret指令,使ROP攻击无法找到可用ret指令序列.文献[7]提供一种消除ret指令的编译器,该编译器编译的内核可以有效防止ROProotkit.为了弥补ROP的这些缺陷,攻击者们对ROP技术进行一定程度的改进,如文献[8]中使用含pop-jmp这种类似ret功能的指令序列代替原有的以ret结尾的指令序列,文献[9]中试图寻找以jmp结尾的指令序列构造攻击,这类技术被称作跳转导向编程(Jump-OrientedProgramming,JOP)技术.这两种方法虽然都可以绕过现有ROP防御,但仍然存在缺陷:(1)这两种构造方法仍具有明显特征,通过对ROP检测技术简单的修改即可以检测到这类攻击.如文献[8]中使用pop-jmp固定指令,可以通过检测这种pop-jmp的频率或语义分析即可以检测此类攻击,文献[9]中使用调度指令序列(调度指令序列)分发控制流,每次实现功能的指令序列执行完毕以后,都会跳回调度指令序列,继而转到下一个指令序列执行.这种控制流特征在正常程序中并不会出现,根据这种特征,动态检测很容易发现此类攻击;(2)由于使用固定类型的指令(pop-jmp、调度指令序列),这两种方法构造攻击的能力有限.它们都没有考虑构造时寄存器的副作用,只能手工构造特定的攻击.寄存器副作用指不同指令序列在使用同一个寄存器时会存在冲突,如文献[8]中使用gadget1(popeax;…),gadget2(…;jmpeax)进行构造时,gadget1会给eax寄存器赋值,而这个值会在gadget2中使用.如果这两个gadget中间存在一个指令序列对eax的值进行改动,将会影响gadget1和gadget2之间的协作,攻击者需要寻找其他gadget来代替其中的某几个指令序列;同样,文献[9]中使用addebp,edi;jmp[ebp-0x39]作为调度指令序列,实现功能的指令序列中则无法对ebp和edi进行改动.寄存器副作用限制了这两类攻击的构造能力,使这两类方法都无法大规模自动化的构造攻击.我们会在第3节详细的分析寄存器副作用问题及其解决方法.为了解决ROP及JOP技术的缺陷,构造隐蔽性更强、能力更为强大的攻击,我们试图解决以下问题:(1)消除攻击代码的特征.我们期望用于构造攻击的指令序列不受限于特定的指令形式,如ROP使用以ret结尾的指令序列,JOP中pop-jmp、调度指令序列等,且程序控制流和正常程序类似.使检测此类攻击变的更为困难.(2)从可执行程序或库中抽取出可用指令序列,利用这些指令序列自动的构造多种功能的攻击.现有的JOP技术都无法自动化构造,从而造成这类①②③④Page3攻击并不实用.为此,我们提出了一种自动化构造分支指令导向编程(BranchInstruction-OrientedProgramming,BIOP)技术,它使用间接转移指令(间接跳转指令indirectjump、间接调用指令indirectcall)结尾的指令序列代替ROP中以ret结尾的指令序列.相比于ROP以及现有的ROP改进技术,这种新型代码复用技术不引入新的特征,攻击控制流与正常程序控制流类似,使检测更加困难.同时我们分析了构造BIOP时遇到的问题,如寄存器副作用,内存冲突等.我们提供了一种自动化构造BIOP的方法,指定构造规则以消除寄存器副作用,并引入控制指令序列以解决构造时内存冲突问题,使BIOP攻击具有实用性.本文的贡献如下:(1)提出了一种新型的BIOP代码复用攻击,它打破了ROP攻击需要以ret结尾的局限,不引入新的特征,使现有ROP防御技术失效.(2)分析了BIOP攻击的可行性和完备性,并抽取libc-2.3.5.so库和libgcj.so.5.0.0库中的可用指令序列.我们发现寄存器副作用是限制构造攻击的重要因素,提出自动构造shellcode的一般方法和规则,以有效的避免寄存器副作用.同时我们提出控制指令序列,使用控制指令序列可以解决内存冲突、简化构造方法、优化构造代码.(3)设计实现构造攻击的自动化工具,并使用该工具构造大量的BIOPshellcode.实验证明我们的工具具有很强的实用性.本文第2节详细介绍BIOP攻击并分析攻击的可行性,同时给出BIOP指令序列搜索算法;第3节介绍构造BIOP攻击的条件和自动化构造BIOPshellcode工具的原理;第4节给出使用工具构造shellcode的结果和构造的shellcode避开检测的能力;第5节介绍相关工作;第6节总结全文.2BIOP概述2.1BIOP基本组成单元在这里,我们将jmp指令和call指令统称为转移指令,BIOP的基本组成单元由以转移指令结尾的指令序列构成.由于我们通过转移指令来控制程序的执行,而直接寻址指令跳转的偏移是固定的,所以这里我们只考虑两种情况:分别以indirectcall指令和indirectjmp指令作为BIOP指令序列的结尾.如图1所示,图1(a)描述了传统ROP攻击,它执行一系列以ret结尾的短指令序列,这些指令序列中ret指令并没有调用指令与其相匹配.现有的ROP防御技术通过检测这类特征可以有效的阻止ROP攻击.如果将构造ROP攻击的以ret结尾的指令序列更换为以jmp或call结尾的指令序列,则可以有效绕过现有的ROP防御技术.注意,简单的使用jmp或call来代替ret可能会产生问题,如使用pop-jmp来代替ret,虽然可以消除ret的特征,但是pop-jmp的特征同样明显,防御者只需要对ROP防御技术进行简单的修改就可以有效防御此类攻击.为此,我们提出BIOP攻击,它的基本组成单元是以jmp指令和call指令结尾的指令序列,如图1(b)所示.BIOP通过jmp指令和call指令来传递控制流,消除ROP中使用孤立ret指令的缺陷.同时,BIOP中包含一类联合指令序列,这类指令序列是由一个含call指令的指令序列和一个含ret指令的指令序列构成,call指令用来调用ROPgadget,然后由ROP指令序列中的ret指令返回.这样,在BIOP中,每一个ret指令都有一个call指令与之对应.由图1可以看出,传统的ROP攻击中ret指令作用是将控制流传递给下一个指令序列,所以ROP中由栈来控制程序的执行流程.在BIOP中,控制流的传递由间接转移指令完成,控制流的传递依赖于间接转移指令中的寄存器的值.所以BIOP的构造不依赖于栈的控制而依赖于寄存器,每次控制流从一个指令序列传递到另一个指令序列时必须先将jmp指令后的寄存器赋值,这导致指令序列之间具有一定的约束关系.同时我们发现新型的BIOP攻击与库中现有的程序控制流类似,不会产生明显的特征.2.2构造BIOP可行性本节我们研究普通的库和可执行代码中构造BIOP的可行性.x86结构中,indirectcall指令和Page4indirectjmp指令的第1个比特都是0xff,对于indirectcall指令,第2个比特是在0x10到0x1f,0x50到0x5f,0x90到0x9f和0xd0到0xd7的区间内,而indirectjmp指令的第2个比特是在0x20到0x2f,0x60到0x6f,0xa0到0xaf和0xe0到0xe7的区间内.我们对两个常用的库libc-2.3.5.so(C库)和libgcj.so.5.0.0(java运行动态链接库)进行分析,统计ret指令、indirectcall指令和indirectjmp指令的个数.统计结果如图2和表1所示.图2给出libc-2.3.5.so和libgcj.so.5.0.0中0xff之后字节分布,表1给出了库中指令数目的统计.由表1可看出,在大小为1489572字节的libc-2.3.5.so库和大小为41090990字节的libgcj.so.5.0.0库中,indirectjmp指令分别有3723个和20462个,indirectcall指令分别有3243个和31940个,数目少于ret指令,但仍可以提供足够的gadget.0xc3(ret指令)57900.39582990.140xffcall32430.22319400.08库大小1489572100410909901002.3BIOP指令序列快速搜索算法为了快速有效找到可用指令序列,我们提出BIOP指令序列快速搜索算法,如算法1所示.对于输入的一段二进制代码,算法构建一个指令序列树集合,集合中每个树根节点为指令序列尾部的jmp或call指令,代码中每条指令是它上一条指令的父节点,当某条指令前面二进制代码序列可以被解释成多条不同指令时,这条指令将会有多个不同的孩子节点,每个节点存放这些不同的指令.算法1.BIOP指令序列搜索.该算法描述如下:首先创建一个集合G,用于放置指令序列树,树的根节点为非条件转移指令序列.然后,pos指针指向二进制代码的第一个byte,并由此位置依次向后搜索,当pos指针指向的byte序列可以被解释成一条非条件转移指令时,将这个指令序列放入集合G中,调用BuildTree()函数构建非条件转移指令树.构建的方法是从pos指针指向的位置开始,依次向前搜索1到max_insn_len个比特,这里max_insn_len是指所在机器结构(如x86系统)中最大指令的比特数.如果从pos-1位置到pos-step位置的二进制序列可以被解释成一个合法指令insn,则调用Viable()函数判断它是否是转移指令,因为转移指令可以改变控制流,BIOP只能由指令序列最后的非条件转移指令控制程序执行,不允许insn为转移指令.注意,这里将call指令排除在分支指令外,因为call指令可以构成联合指令序列.如果insn不是call之外的间接转移指令,那么将insn作为parent_insn(即pos所指向的非条件转移指令)的一个孩子节点,然后递归调用BuildTreePage5来构建insn的孩子节点.算法生成的指令序列中,相邻两条指令的后一条指令在树中是前一条指令的父亲节点.例如指令序列005858ffe1,可得到如图3(a)一个子树.通过这个子树,可得到图3(b)4个BIOP指令序列.所以,使用该算法得到的树集合,从树的某个节点到根节点的指令序列就是一个BIOP指令序列.2.4BIOPgadget实例本节我们研究在libc-2.3.5.so和libgcj.so.5.0.0两个库中找到的BIOP指令序列,并且依据它们可以实现的功能对其分类.通过实例可看出,库中存在的指令序列可以实现大部分的x86操作,如数据传送、算术运算、逻辑运算、分支语句和系统调用等等.2.4.1数据传送数据传送指令的功能是将数据或地址传送到寄存器或存储器单元中,如pop%edx指令,可以使用如下两个指令序列实现:上述两个指令序列运行如图4所示,首先栈内设好传递给esi寄存器的值和递给edx寄存器的值0xdeadbeef,传递给esi寄存器的值是内存空间某个地址.当程序执行gadget(1)时,pop%esi将栈顶值传递给esi,此时esi指向的内存中存放gadget(2)地址,当执行jmp0x0(%esi)时,程序跳转到gadget(2),执行pop%edx,将0xdeadbeef传递给edx寄存器.-0x7d(%esi)中存放着下一个要跳转的指令序列地址,执行完gadget(2),程序自动跳转到下一个设定的指令序列.数据传送指令中的标志传送指令用于传送标志器寄存器eflag中的标志位,以便设置、修改和保存eflag寄存器中的标志.如libgcj.so.5.0.0中的gadget(3):2.4.2算术运算和逻辑运算对于算术运算和逻辑运算,先使用数据传送指令序列将操作数传入寄存器或内存中,然后使用对应的指令序列完成算术运算和逻辑运算.例如libgcj.so.5.0.0中的gadget(4):2.4.3分支语句在BIOP中我们使用类似jmp(reg1,reg2,1)或call(reg1,reg2,1)的指令序列实现分支指令.reg1中放置地址偏移,它的值随着标志寄存器不同而不同,reg2放置基地址.如libgcj.so.5.0.0中的gadget(5):图5是一个简单的条件跳转实例,它可以实现jz指令或jnz指令,用到指令序列序列如下:Page6我们假设数据传输指令序列已经设置好eax、edx、ebp和esi的值,同时将ebp的值设置为0xffffffbf.程序运行时,首先将标志寄存器的值入栈,然后传递给寄存器edx,将edx的值与ebp的值进行或操作,并将结果保存在edx中.当保存在edx中的标志寄存器值的zf位为0时,得到的值为0xffffffbf,jmp(%edx,%esi,1)相当于执行jmp-0x41(%esi).当zf位为1时,得到的值为0xffffffff,相当于执行jmp-0x1(%esi).这样就根据zf位的不同而跳转到不同的地方.注意,使用这种方法实现jc或jnc等与cf标志位相关的指令时,会出现jmp-0x2(%esi)和jmp-0x1(%esi)地址重叠的情况,针对这种情况,我们使用左移位指令序列或者乘法运算指令序列去放大地址之间的距离.2.4.4系统调用在BIOP中我们一般使用联合指令序列实现系统调用功能,如gadget(6):ff5654call0x54(%esi)首先使用数据传送指令序列设置esi和ebp寄存器的值,0x54(%esi)内存放的是lcall%gs:0x10(,0)的地址,-0x18(%ebp)中存放下一个指令序列地址.然后用数据传送指令序列将需要传递的参数传递给对应的寄存器,执行这个指令序列就可以实现系统调用功能.2.5BIOP构造形式图6描述了BIOP的构造形式,BIOP由多个以call或jmp结尾的指令序列串联起来构成,每个指令序列在执行完毕以后都会跳转到下一个指令序列开头,多个指令序列内部的指令的组合可以实现特定的语义.首先,我们看到这类指令序列并不存在特殊的指令类型,如文献[8]中必须使用pop指令为以后的jmp指令中寄存器赋值从而确定跳转地址的情况.在这里,给jmp指令中寄存器赋值的指令可以有多种类型,如mov、add等.其次,区别于文献[9]中使用调度指令序列管理分发控制流,BIOP攻击的控制流与普通程序的控制流类似,每个指令序列执行完毕后,都会经过call或jmp指令将控制流传递给下一个指令序列.而在普通程序中,使用call指令或jmp指令跳转到其他指令序列这种情况也普遍存在.所以BIOP攻击的程序更类似于正常程序,不易被检测到.3自动构造BIOP攻击本节将对自动BIOP构造时出现的问题进行探讨,并给出解决方法.同时在本节我们会介绍自动化构造工具的基本原理.3.1BIOP寄存器副作用对攻击构造的影响在构造BIOP攻击时,会出现多个指令序列使用到同一个寄存器,导致寄存器在赋值和使用时出现数据不一致的问题.这类问题同样在传统的ROP和ROP改进工作中出现,传统的方法是人工分析构造的指令序列序列是否可行,导致ROP和JOP不具有实用性.为此,我们在本节深入探讨造成这种原因的主要因素.我们把构造中寄存器使用时冲突,称之为寄存器副作用.导致寄存器副作用的原因有Page73种,(1)用某个寄存器传递控制流和将该寄存器用作其他用途时产生的冲突;(2)两个指令序列用同一个寄存器传递控制流跳时产生的冲突;(3)指令序列本身某些指令会改变已设寄存器的值.我们以文献[9]的调度指令序列为例,在程序中的每个功能指令序列都会跳转到调度指令序列,然后由这个调度指令序列决定下一个要使用的功能指令序列.如下是某个理想的调度指令序列:83c204add$0x4,%edx对于第1种原因,有多种可能的情况.如在这个指令序列中,需要使用edx寄存器确定指令序列要跳转的地址.如果程序中需要用到edx作为参数的系统调用,那么我们需要一个数值传递指令序列将参数传递给edx寄存器,此处如果仍然使用调度指令序列,就会产生错误.这在很大程度上限制了构造的能力.对于第2种原因,例如在程序中使用了如下gadget(8).由于都是用edx寄存器实现指令序列的跳转,所以调度指令序列和gadget(8)不能在一起使用.8b6110mov0x10(%ecx),%esp同样,我们也用如下的gadget(9)来解释第3种原因.当使用这个指令序列对al进行与操作时,cdq指令会改变edx值,导致调度指令序列不能继续使用.所以使用类似调度指令序列会严重影响JOP构造的能力.同样,这种寄存器副作用也存在于BIOP程序中.3.2消除寄存器副作用由于BIOP程序中存在的寄存器副作用,导致BIOP的构造具有一定的困难和挑战,为了解决这个问题,我们在本节给出两个构造攻击的规则以消除寄存器副作用和一个指令序列排列算法以实现自动化选择和排列指令序列.的赋值.规则1.每个寄存器在使用之前必须有对应我们根据对某个寄存器的操作将指令序列分为如对于gadget(9)是赋值指令序列,而紧随其后是需要用eax值为0x1的系统调用指令序列,由于任何数和0xe8进行与操作的结果不为0x1,这种情况违反了规则2.通过满足规则2确保每次指令序列所用到的寄存器的值都是符合预期的.为了实现BIOP构造的自动化,我们提供了一个指令序列排列算法(算法2)来解决这个问题.如图8所示.赋值指令序列和应用指令序列两类,赋值指令序列将某个数据传入该寄存器,应用指令序列则使用该寄存器完成特定操作.如3.4.3节中实现jz或jnz功能的指令序列组,对于edx寄存器来说,gadget(2)是赋值指令序列,gadget(4)相对于gadget(5)是赋值指令序列,相对于gadget(2)是应用指令序列,gadget(5)是应用指令序列.规则2.使用寄存器前,最近给该寄存器赋值的指令序列的赋值结果,必须是使用该寄存器时所需要的值.算法2.gadget排列算法.LoadGadgetsSelectionAlgorithmLr:LoadregistersingadgetLi:LimitedregistersingadgetR:ThecandidateregistersneedtobesetT:GadgetssetwhichcontainstheselectedG:Allloadgadgetsgetformlibinput:R,G;output:TwhileR!=NULLdoTheruleofselectgadgetinGasfollows:fromMAXto1,registersofgadget.Lr∩RdoIfgadget.Li∩R==NULLdoRemoveregistersinbothLrandRPutgadgetinTendifendfromendwhile在算法2中,我们对搜索到的每一个具有Load功能的指令序列定义赋值寄存器集合Lr和受限的寄存器集合Li.以gadget(2)为例,gadget(2).Lr为{edx},gadget(2).Li为{esi}.注意,如果在指令序列中某个受限寄存器之前已经有给这个寄存器赋值的指令,则不把这个寄存器加入Li中.如在gadget(1)中的Lr为esi,Li为.我们对所有的指令序列按赋值寄存器与待赋值寄存器集合并集元素个数从多到少进行搜索,找出gadget.Li与集合R并集为空的指令序列,将赋值的寄存器从集合R中移除,并将指令序列放入集合Page8T,当R中不再存在寄存器时,T中存放的是实现赋值功能的指令序列.这个算法保证在每次将某个寄存器从R中移除时,都已经给这个寄存器赋值,在此之后的赋值指令序列都不会改变这个寄存器.3.3BIOP的图灵完备性Shacham[2]认为ROP“从直觉上”看是图灵完备的,通过一些技巧可以实现任意功能.实际上ROP、JOP与BIOP的能力受限于系统中的函数库或者可执行代码,如果某个功能在库或可执行代码中找不到对应的gadget,同时也无法使用其他技巧来实现时,可能这个操作就无法用ROP或BIOP来实现.通过上述讨论我们知道BIOP的构造存在一些限制,如系统调用指令序列,我们并没有找到syscall-jmp这类指令序列,所以我们只有通过联合指令序列实现这类功能.但是如果某个系统调用需要用到多个寄图7控制gadget原理在构造ROP与BIOP时,还存在一类地址冲突问题,例如gadget(10)和gadget(11),由于jmp的跳转地址均存放在-0x77(%esi)地址空间中,所以在连续使用这两个指令序列时会出现地址冲突问题,如果使用以call指令结尾的指令序列,call指令运行时会将指令地址入栈,从而占用当前栈的空间,存器传递参数,那么使用联合指令序列来实现系统调用也不是一个理想选择.当然,这是一个开放性问题,是否有其他技巧可以实现类似功能,我们在此并不讨论.3.4控制gadget本节我们提出一种特殊的控制指令序列,用于解决BIOP构造中可能出现的地址冲突问题和内存安排问题.这类指令序列对于寄存器是一种自省控制方式,它可以在指令序列内部同时实现对寄存器的赋值和使用该寄存器控制将要跳转的地址,理想状态下并不影响其他的寄存器.图7是控制指令序列的原理图.在图7中,gadget(1)是libgcj.so.5.0.0库中一个典型的控制指令序列,它利用栈对esi进行赋值同时使用esi控制指令序列的跳转,且它很少影响其他寄存器.使此指令序列之后的指令无法从这个栈内取值.ROP中通过栈控制程序执行,并不存在这类问题,但是BIOP中,由于BIOP指令序列的数量有限,这类问题便显得尤为突出.通过在gadget(10)和gadget(11)之间插入控制gadget(1),改变esi寄存器的值,从而解决地址冲突.Page9在BIOP中,同时还存在内存空间安排问题,例如gadget(11)和系统调用gadget(6),他们都是用esi寄存器控制程序跳转,如果连续使用这两个指令序列,那么在esi-0x76到esi+0x53这段内存中的某些空间将会被闲置.通过使用联合gadget(1),改变esi的值,可以使闲置空间缩短为esi+0x1到esi+0x53.3.5BIOP构造自动化工具造BIOP攻击的工具,原理如图8所示.通过上述分析,我们设计实现了一个自动化构我们的工具主要由指令序列收集器(①)、指令序列排列器(②)和内存优化器(③)3部分组成.指令序列收集器通过算法1(BIOPgadgetSearchingAlgorithm)从库或可执行文件中收集可用的指令序列.指令序列排列器通过对shellcode的分析,找出对应功能的指令序列,并通过算法2(LoadGadgetsSelectionAlgorithm)实现各个功能中寄存器的赋值.内存优化器使用控制指令序列解决指令序列排列器生成的指令序列中的内存冲突和空间安排问题,并生成所最终的BIOPshellcode.4实验与评估4.1BIOPshellcode实例本节给出一个使用自动化工具构造的shell-code实例,功能是通过执行execve系统调用运行一个shell.这个shellcode具体实现如下:在执行系统调用之前,将系统调用号0xb传递给eax寄存器,执行程序的路径“/bin//sh”地址传递给ebx寄存器,参数向量传递给ecx寄存器(参数向量指向两个指针的队列,一个是指向“/bin//sh”字符串,另一个是空指针),环境向量(空指针)传递给edx寄存器.具体实现方法如图9所示,图中左侧给出BIOP的内存安排和内存地址的后12位.右侧虚线代表了指令序列的执行循序.通过一次缓冲区溢出,将返回值地址用gadget(12)所在的地址改写,程序在返回时跳转到我们设定的指令序列,然后循环3次使用gadget(12)和gadget(13).对于gadget(13),把edi和ebx指向的内存设定好相应的值,相加后会将结果放入ebx指向的内存中.这在构造攻击中可以解决0比特的问题,因为在缓冲区溢出中,不允许有0x0的存在.如给eax赋值为0xb,首先使用gadget(12)将edi设置为0xeeeeeee0,ebx指向的空间设置为0x1111112b,这个空间以后将会给eax赋值,所以在执行gadget(13)之后,ebx指向空间结果为0xb.同样在shellcode中,第2次和第3次使用是将相应的内存空间赋值为0x0.使用gadget(12)和gadget(14)给eax、ebx、ecx、edx、esi、edi、ebp7个寄存器赋好相应的值,在这里给eax赋值的内存恰好是在通过gadget(13)设置的,在运行gadget(14)后,eax的值是系统调用号0xb.最后执行系统调用完成execve启动一个shell.在内存中,我们没有用到的闲置内存,全部用字符”A”填充.BIOPshellcode二进制代码如图10所示.Page10图9BIOPshellcode构造图10BIOPshellcode实例Page114.2BIOPshellcode我们从网站①中选取了22个shellcode进行构造,使用常见的libc-2.3.5.so库和libgcj.so.5.0.0表2BIOPshellcode12345678setreuid(getuid(),getuid()),execve(“/bin/sh”,0,0)91011121314ejectcd-rom(follows/dev/cdromsymlink)+exit()15anti-debugtrick(INT3htrap)+execve/bin/sh16171819202122在我们构造的shellcode中,有的涉及了复杂的shellcode的设计.包括使用多个系统调用、条件跳转和loop指令等.如setreuid(getuid(),getuid()),execve(“/bin/sh”,0,0),需要涉及3个系统调用,dup2(0,0)、dup2(0,1)、dup2(0,2),Ho’Detector使用条件跳转指令,RadicallySelfModifyingCode使用loop指令等.由表2可以看出,随着shellcode复杂性的增加,构造BIOPshellcode的复杂度也在增大.shellcode的长度越大,构造的BIOPshellcode的gadget数目和大小也越大,一般BIOPshellcode都在100比特之上.4.3BIOP攻击效力我们同时测试BIOP对现有的ROP/JOP防御技术的效力.如表3所示,我们选取3种典型的ROP防御方法进行测试,分别是:(1)DROP[5],检测运行时以ret结尾的短指令序列是否频繁出现;(2)ROPdefender[6],检测运行时call指令与ret指令是否一一对应;(3)Return-lessCompiler[7],使用消除ret指令的编译器.为了方便比较,我们也测试了传统的ROP攻击、Tyler提出的JOP攻击对这3种防御技术的效力.从表3可以看出,传统的ROP技术使用以ret结尾的gadget片段,这种明显的特征可以被这3种技术检测到.Tyler的JOP技术[9]库,实验环境是2.6.15版本内核的Fedora5系统.22个shellcode中包括数据传输、算术运算、系统调用和条件转移等基本语句.实验结果如表2所示.shellcode大小(bytes)消除了ret指令带来的负面影响,可以有效绕过DROP和Return-lessCompiler的防御方法,但是它所使用的call指令并没有相应的ret指令,基于这种特征的ROPdefender技术仍然可以检测到这类攻击.BIOP技术避免使用连续的ret指令,同时使call指令与ret指令一一对应,从而可以有效的绕开所有这3种防御技术.ROPshellcode有效有效Tyler’sJOP失效有效BIOP失效失效5相关工作ROP技术是一种全新的代码复用攻击方法,它被认为是未来主流攻击方法之一.ROP攻击技术和防御技术近几年发展迅速,我们在此章介绍ROP的发展背景和相关工作,使读者对ROP的发展有更清楚的了解.①milw0rm:http://www.milw0rm.com/shellcode/linux/Page125.1Return-to-libc攻击为了解决向WX或DEP保护的内存页注入恶意代码失效的问题,攻击者尝试复用系统已经存在的函数级代码,return-to-libc[1]是一种典型的代码复用攻击,它通过劫持控制流,跳转到C语言函数库libc,复用libc中已有的函数,可以有效的绕开WX和DEP技术.然而,renturn-to-libc攻击存在以下缺陷:(1)只能顺序调用函数,不能实现图灵完备的行为,如分支操作、循环操作等;(2)依赖于系统中存在的库函数,移除或修改libc中的特定函数将严重限制攻击能力.5.2Return-OrientedProgramming由于return-to-libc攻击具有一定局限性,Shacham[2]于2007年提出一种新型的代码复用技术———返回导向编程攻击,将复用的代码粒度从return-to-libc的函数级别缩小到指令序列,每个指令序列都是一个以ret指令结尾的指令序列,通过在栈内设置下一个要跳转的指令序列地址,攻击者可以将多个指令序列串联起来以实现恶意语义.Schacham认为libc中的指令序列集合是图灵完备的,可以构造任意功能的攻击.然而,ROP使用以ret指令结尾的指令序列构造攻击,与正常程序相比,ROP具有以下特征:(1)ret指令并没有相应的call指令与其对应;(2)频繁使用以ret指令结尾的短指令序列,这在正常程序流中非常少见.5.3Return-OrientedProgramming防御技术针对ROP的特点,防御技术主要可以分为以下3类:(1)ROP中ret指令并没有相应的call指令与其匹配,Francillon等人[3]使用一个嵌入式的微处理器保护call/ret栈不被任意数据改写,ROPdefender[5]使用影子内存来检测对返回值地址的修改;(2)ROP指令序列一般只有两三个指令长度,每个指令序列都以ret指令结尾,Chen等人[6]和Davi等人[4]针对ROP的这种特性进行检测,当系统频繁的执行含ret指令的短指令序列时,则认为系统受到ROP攻击;(3)消除库中ret指令可以有效消除ROP攻击的构造基础.如Li等人[7]设计了一种编译器可以在程序编译时候消除ret指令.5.4ROP技术演化为了克服ROP的缺陷,攻击者试图改进ROP攻击.Checkoway等人[8,10]提出使用含pop-jmp指令序列替换原来以ret指令结尾的指令序列.但这种方法使用类似ret功能的pop-jmp指令(如popebx,…,jmp[ebx]).虽然这种改进可以使现有ROP防御技术失效,但是没有从本质上解决ROP技术的缺陷.因为虽然避免使用ret指令,但是引入的pop-jmp指令同样具有明显的特征,通过对栈的保护或对ROP动态检测技术进行修改可以很容易检测此类攻击.Bletsch等人[9]提出Jump-OrientedProgram-ming(JOP)消除对ret指令的依赖,但这种技术存在缺陷.首先他们使用含call指令的指令序列,但并没有相应ret指令与其匹配,使用栈保护技术可以防御这类攻击[3,8];其次,JOP的构造具有寄存器依赖性,在某个指令序列中使用寄存器会影响到其他指令序列对该寄存器的使用,Bletsch等人并没有对这个问题进行讨论,而且他们提出的调度指令序列加剧了这种依赖性,使JOP功能受到限制.事实上,我们发现,在Bletsch等人使用了addebp,edi;jmp[ebp-0x39]这个调度指令序列以后,将无法在以后的gadget中更改ebp和edi这两个寄存器值,导致JOP的构造能力受到严重限制.我们在第4节中讨论了这个问题,同时我们也提出如何消除寄存器依赖性,可以构造能力更强大的攻击.再者,调度指令序列的使用使程序流与正常程序流相比,具有明显的特征,通过动态检测很容易发现此类攻击.最后,调度指令序列是一种理想的指令序列,现实的libc库中很难找到,从而使JOP的攻击取决于现有的库中是否可以找到有效的调度指令序列.如上所述,已有的ROP及ROP改进技术都存在明显特征,易被检测,不利于实际的应用.本文提出的BIOP技术消除了原有的ROP及ROP改进技术的特征,隐蔽性更强.同时我们考虑了寄存器对构造攻击能力的影响,并分析解决了构造时寄存器副作用问题,为我们自动化构造攻击奠定理论基础.我们设计了一个自动化构造BIOP的工具,使用我们的工具可以大规模有效的构造BIOPshellcode.6结束语本文提出了一类新型ROP攻击技术BIOP,它通过复用现有库和可执行文件中含jmp指令和call指令的指令序列,从而有效绕开现有的ROP防御技术.它不仅消除了ROP中ret和call非一一对应的缺陷,且不依赖于对栈的控制.我们提出了一个指令序列快速搜索算法,并且分析了利用这些指令序列自动构造攻击时的难点和挑战,针对这些难点和挑战我们提出解决方法.同时我们设计了一个自动化构造工具.通过自动化工具,我们能方便构造各种语义的shellcode.实验结果表明,BIOP具有与ROPPage13相同的能力,并可以有效避开当前的ROP检测技术.我们相信基于BIOP的攻击将会成为系统安全的新威胁.
