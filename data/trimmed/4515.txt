Page1求解三维装箱问题的启发式正交二叉树搜索算法1)(中国科学院自动化研究所复杂系统管理与控制国家重点实验室北京100190)2)(中国科学院云计算产业技术创新与育成中心广东东莞523808)摘要文中提出了一种求解三维装箱问题的启发式二叉树搜索算法,首先将所有箱子组合成多个优条,每个优条中的箱子沿容器高度方向排成一列;接着开始构建二叉树,其根节点表示空的装箱方案,每个树节点沿长度方向增加一排优条形成左子树节点,沿宽度方向增加一排优条形成右子树节点,二叉树必须扩展到所有叶子节点都无法再放入任何剩余的箱子为止,所有叶子节点中填充率最高的装箱方案即为最终结果.该算法满足三维装箱的3个著名的约束条件.在多样性最强的测试算例中,该文方法相对于现有最优秀装箱算法装箱率有显著提高.关键词三维装箱;启发式算法;二叉树1引言三维装箱问题是物流领域和木材加工领域的经Page2在研究如何将若干个货物装填到一个或多个大的容器中,在Dyckhoff和Finke[1]和Wscher等人[2]的关于切割和布局问题的综述中有详细的论述.三维装箱问题按照装载的货物形状分类,可分为规则形状(通常为长方体)货物装箱和不规则形状货物装箱;按照货物种类分类,可以分为单一种类货物装箱和多种类货物装箱;按照目标函数分类可以分为容器装载问题、箱柜装载问题和背包装载问题.这3种都属于三维装箱问题的子问题,它们之间的区别由表1列出.问题容器数量容器装载单个决策变量箱柜装载决策变量常量背包装载单个下面分别介绍以上3种类型的三维装箱问题.(1)容器装载问题(three-DimensionalContainer-PackingProblems,3D-CPP).所有箱子要装入一个不限尺寸的容器中,目标是要找一个装填方案,使得容器体积最小.该问题更一般的形式是容器的长和宽不变,找一个装填使容器高最小,Bischoff等人[3]比较了该问题的不同算法.陆一平等人[4]给出了三维矩形块布局的序列三元组编码方法;Bortfeldt等人[5]设计了容器装载问题的启发式算法,解决如何在容器宽高不变的前提下,使容器长度尽可能短的问题.(2)箱柜装载问题(three-DimensionalbinPackingProblem,3D-BPP).给定一些不同类型的方型箱子和一些规格统一的方型容器,问题是要把所有箱子装入最少数量的容器中.Faroe等人[6]提出了该问题的一种启发式算法.(3)背包装载问题(three-DimensionalKnapsackLoadingProblems,3D-KLP,又称为three-Dimen-sionalContainerLoadingProblems,3D-CLP).每个箱子有一定的价值,背包装载是选择箱子的一部分装入容器中,使得装入容器中的箱子总价值最大.如果把箱子的体积作为价值,则目标转化为使容器浪费的体积最小.当箱子的长、宽分别与容器的长、宽相等时,问题等价于经典的一维背包问题.三维装箱问题是典型的NP难题,不存在多项式时间复杂度的最优求解算法.用传统的精确算法求解这类问题,会发生“组合爆炸”的现象,只适合解决箱子种类数量很小的装箱问题,对于实际应用中规模比较大的数据,很难求得它的最优解.启发式求解方法依然是解决3D-KLP(3D-CLP)的首选.因此很多学者提出了针对该问题的启发式算法.Pisinger[7]将这些算法分为砌墙算法、建堆算法、立方体排列算法和切割算法四大类.George等人[8]首次对该问题提出了砌墙算法,该算法把容器分成层,层再分成条,最终转化为一维背包问题;Bischoff等人[3]比较了14种基于层的方法;Bischoff等人[9]提出了按层布局的贪婪算法,针对层和条的选择策略;Pisinger[7]提出了基于砌墙策略的树搜索算法;Gehring等人[10]将箱子生成“塔”,利用遗传算法将“塔”优化组合;Bortfeldt等人[11]针对箱子种类数较少的情况提出了一种禁忌搜索算法;Bortfeldt等人[12]基于层的概念,提出了一种解决三维装箱问题的混合遗传算法;[13]设计了一种基于同类块(Block)的算法,基Eley本思想是先将同类的箱子组合成长方体块再装箱;Bortfeldt等人[14]进一步拓展“块”的概念,并使用并行禁忌搜索寻找最优的装载方案;Moura等人[15]基于“剩余空间”的概念提出了一个贪心随机自适应搜索算法(GRASP);Parreno等人[16]进一步发展和改进了该算法,装箱率有较大提高;Parreno等人[17]基于最大空间的概念,提出了一个可变邻域搜索算法;Bortfeldt等人[5]设计了一种三维条装载的启发式算法;Fanslau等人[18]拓展了“块”的概念,“块”可以包含多种尺寸的箱子,也可以包含同种箱子的多个摆放方向,称之为“复合块”,并设计了一个有效的启发式树状搜索算法;此外Ngoi等人[19]、Morabito等人[20]、Sixt等人[21]、Gehring等人[10,22]、Lim等人[23]、Juraitis等人[24]也报告了其他一些针对三维装箱问题的启发式算法.国内学者对三维装箱问题的研究,取得了很好的结果,何大勇等人[25]设计了求解复杂集装箱装载问题的遗传算法;张德富等人[26]提出了一个混合模拟退火算法;Huang等人[27]提出了一个有效的拟人型穴度算法;值得一提的是张德富等人[28]设计的求解三维装箱问题的多层启发式搜索算法,是目前为止有公开文献报导的解决装箱问题的最优秀算法;还有其他一些学者也取得了不错的研究成果[26-31].实际装箱过程中,通常会遇到以下3类约束[18]:(C1)方向性约束(OrientationConstraint).在很多场合下,箱子的装载有方向性约束.并不是箱子的所有边都可以竖直放置,方向性约束定义箱子的长度边、宽度边、高度边是否可以竖直放置,箱子至少有一个边可以竖直放置.Page3(C2)稳定性约束(SupportConstraint).在一些场合如集装箱货运,要求箱子必须满足稳定性约束.每个被装载的箱子必须得到容器底部或者其他已经装载箱子的支撑.稳定性约束包括完全支撑约束和部分支撑约束,完全支撑约束要求被装载箱子的底部必须跟容器底部或其他箱子顶部完全接触,部分支撑约束允许箱子底部可以允许部分悬空.(C3)完全切割约束(GuillotineCuttingCon-straint).如在木材切割的应用中,很多切料机只能做完全切割,即每一刀必须从一边切到另一边,把木材完全分割成两半;还有在依靠叉车装卸货的集装箱装卸应用中,要求叉车每次只从集装箱的底部叉装货物,就可以实现所有货物的装卸,从而大大提高装卸速度.这就要求最终的箱子装填块(又叫装填方案)可以通过多个竖直的平面分割成多个竖层,每一个竖层可以通过多个水平的平面分割为最终的箱子,每次的竖直平面分割(和水平平面分割)必须可以将对应的子装填块完全分割成两个独立的子块.所有的竖直平面和水平平面必须不能与对应装填块中的箱子相交.目前的算法很多只能满足C1和C2约束,并且在箱子种类较多时,装箱率不高,还有提高的余地.本文提出了一种三维装箱问题的启发式树搜索算法,能够同时满足C1、C2和C3约束,并且当箱子种类数量较多时,本文方法相对于现有最优秀装箱算法装箱率有显著提高.本文算法简称为启发式正交二叉树搜索算法(HeuristicOrthogonalBinaryTreeSearchAlgorithm,HOBTS).2问题介绍首先介绍一下3D-KLP(3D-CLP)问题的形式化定义:给定一个长方型容器C和一个长方型箱子的集合B={b1,b2,…,bn},容器C长lC、宽wC、高hC,每个箱子bi有长li、宽wi和高hi,每个箱子的体积为vi=liwihi.令0-1标志zhi、zli、zwi表示箱子是否允许正放、仰放、侧放(0表示不允许,1表示允许),令图1为容器尺寸及坐标系示意图;图2为箱子的尺寸和摆放方向示意图.设F为B的一个子集,定义F中所有箱子体积之和为VF,即问题的目标是选择B的一个子集使得VF最大,并且满足以下条件:(1)对任何箱子bi∈F,在容器C中对应一个装填位置;(2)所有F中的箱子必须全部包含在C中;(3)F中任何两个箱子在容器中放置后都不重叠;(4)F中箱子bi的方向必须满足方向标志zhi、zli、zwi要求.定义子集F对应的填充率为FRF=VF/(lCwChC).带有完全支撑约束的三维装箱问题,要求所有箱子的底部都完全和容器底部或者其他箱子的顶部完全接触,并且装入容器的箱子体积之和尽可能大.3三维装箱算法在介绍本文算法之前,先进行如下定义:优条gs:针对长方型容器C和长方型箱子的集合B,从B中选择一个子集Q,Q中的箱子在满足方向标志zhi、zli、zwi要求的前提下,沿z轴竖直地摞起一列,形成竖条s,竖条s在z轴方向尺寸不大于容器高度hC,分别定义l_s、w_s为竖条s中箱子在x轴方向最大尺寸和y轴方向最大尺寸.定义竖条sj填充率:优条即为B中fr_sj值最大的子集Q形成的竖条,以gs表示优条,令优条集合GS:多个优条构成的集合,设GS中包含n个优条,则有优层gl:针对长方型容器C和优条集合GS=Page4{gs1,gs2,…,gsm},从GS中选择一个子集T,T中的优条沿x轴或y轴方向排成一行(排列过程中优条可以绕z轴旋转90°),形成竖层l,其中沿y轴方向排列时,沿y轴方向的尺寸不大于给定尺寸w_left(该值对应于生成优层前集装箱内部剩余空间的宽度);沿x轴方向排列时,沿x轴方向的尺寸不大于给定尺寸l_left(该值对应于生成优层前集装箱内部剩余空间的长度).定义l_l为沿y轴方向排列时T中优条在x轴方向占用最大尺寸.定义w_l为沿x轴方向排列时T中优条在y轴方向占用最大尺寸.以定义层lj填充率:fr_lj=设lj为优条沿x轴方向排放时,GS中fr_lj值最大的子集Tj形成的竖层,设lk为优条沿y轴方向排放时,GS中fr_lk值最大的子集Tk形成的竖层,则有令其中dir含义如下dir=优层集合GL:多个优层构成的集合,设GL中包含m个优层,则有本算法先将所有箱子组合成多个沿容器z方向摆放的优条,将三维装箱问题降维为以优条为装填对象的二维装箱问题,然后构造二叉树,如图3所示,树上的每个节点对应一个填充方案,根节点对应空的填充方案,在每个节点对应的填充方案基础上沿x方向摆放一排优条,形成新的填充方案作为其左子树节点对应的填充方案,在每个节点的填充方案基础上沿y方向摆放一排优条,形成新的填充方案作为其右子树节点对应的填充方案,叶子节点对应的是无法再填充剩余箱子的填充方案,最后以填充率最高的叶子节点的装箱方案最为最终装箱方案.三维装箱算法的实现流程如算法1所示.首先生成空的优层集合GL,定义最优的优层集合BEST_GL,为其赋初始值GL;接着定义x方向剩余尺寸x_left,初始值为lC,y方向剩余尺寸y_left,初始值为wC;再生成空的优条记录集合GS_REC和空的优层记录集合GL_REC;接下来调用剩余空间填充算法LoadLeftSpace(input)(详见算法2)完成装箱过程,优层集合BEST_GL就是最终的装箱结果.本文总共包含7个算法(其中算法3包含两个部分,分别以算法3(a)和算法3(b)表示),算法之间的调用关系如图4所示,对于图中任意两个算法m和n,如果算法n的框被包含在算法m的框中,则表示算法m直接调用算法n.算法1.启发式正交二叉树搜索算法.HeuristicOrthogonalBinaryTreeSearch(C,B,fr_gate)Page5剩余空间填充算法的流程如算法2所示,该算法为递归算法.①判断箱子是否装完或者容器是否已经容不下新的箱子,如果是,计算结束,如果否转到步②;②调用优条集合生成算法Make_GS1(input)(见算法3(a))和Make_GS2(input)(见算法3(b))将所有箱子组合成优条集合X_GS;③如果X_GS为空集则计算结束,否则转到④;④调用优层生成算法MakeGoodLayer(input)(详见算法4)生成x方向最优层x_gl;⑤生成空优层集合X_GL,将GL中所有优层和x_gl拷贝给X_GL;⑥判断X_GL中所有箱子体积和是否大于BEST_GL中所有箱子体积和,如果是,则将X_GL值赋给BEST_GL;⑦从X_GS中去除x_gl中包含的所有优条,创建空的箱子集合X_B,将X_GS中包含的所有箱子拷贝至X_B;⑧递归调用算法2;接下来在y方向上重复步②至步⑧,这里不再一一赘述.算法2.剩余空间填充算法.LoadLeftSpace(GL,B,x_left,y_left,fr_gate,GS_REC,if(B≠并且存在bi∈B可放入容器C剩余空间)if(n=1)if(n=2)if(X_GS≠并且Y_GS≠)//以下为x轴方向排列优条//以下为y轴方向排列优条优条集合GS的生成流程分为两种,分别如算法3(a)和算法3(b)所示,算法3(a)和算法3(b)的区别在于:算法3(a)利用箱子的三维尺寸中的两个尺寸作为优条的长度和宽度上限,而算法3(b)只利用箱子的三维尺寸中的一个尺寸同时作为优条的长度和宽度上限,计算结果证明同时调用算法3(a)和算法3(b)比只调用其中一个的填充率高.在算法3(a)中:①首先生成空的优条集合GS;②然后用所有箱子允许与xy面平行的所有面的尺寸轮廓为边界约束生成普通条,普通条生成流程MakeStrip(input)如算法5所示,一旦找到填充率大于fr_gate的普通条,就将该普通条作为优条,如果找不到,就选填充率最高的普通条作为优条;③并从箱子集合中删除优条中包含的箱子,将优条加入到优条集合;④判断箱子集合中是否还有箱子能装入容器剩余空间,如果是,返回到步②执行,如果否,算法结束.算法3(b)和算法3(a)类似,不再赘述.算法3(a)优条集合的生成流程1.Generate_GS1(B,C,x_left,y_left,GS_REC,fr_gate)生成空的优条集合GSwhile(B≠并且存在bi∈B可放入容器C剩余空间)返回GSPage6算法3(b)优条集合的生成流程2.Generate_GS2(B,C,x_left,y_left,GS_REC,fr_gate)生成空的优条集合GSwhile(B≠并且存在bi∈B可放入容器C剩余空间)foreachboxb∈B返回GS优层gl的生成流程如算法4所示.依次用优条集合GS中每一个优条的长度和宽度为即将生成的优层厚度,用length为背包容量,以优条集合GS为待装入背包的货物,调用算法MakeLayer(input)(见算法6)运算得到一个优层.比较所有这些优层的层填充率fr_l,以层填充率fr_l最高的优层为运算结果.算法4.优层的生成流程.MakeGoodLayer(GS,length,GL_REC)定义临时变量best_gl表示最好的优层foreachgs∈GSgl1gl2if(gl1或gl2的层填充率大于best_gl的层填充率)返回best_gl普通条生成流程如算法5所示.以集合B中所有箱子为货物,以容器高度为背包容量,以每个箱子允许在z轴方向的最小尺寸为货物重量,以箱子体积为价值,通过动态规划方法解背包问题,得到优条.在每一次求解背包问题后,都记录本次背包问题的背包容量、优条底面约束尺寸、全部货物列表、选中装入背包的货物列表.在生成新的优条时,首先判断有无近似记录可供参考,如果有,则直接根据记录生成优条,从而避免重复运算相同背包问题,大大减少装箱计算时间.查找近似背包问题记录判断流程参见算法7.定义优条背包生成记录如下:Knapsack_Rec=(length,size1,size2,其中length表示背包容量,size1表示优条第1个底面尺寸,size2表示优条第2个底面尺寸,ALL表示全部货物列表,SELECTED表示选中装入背包的货物列表.算法5.普通条生成流程.MakeStrip(B,height,max_l,max_w,GS_REC)定义size1··=Max(max_l,max_w)定义size2··=Min(max_l,max_w)创建空的箱子列表B_NEWforeachboxb∈B定义普通条stripstrip··=Exist_Knapsack_Rec(GS_REC,height,max_l,if(strip=)strip··=(以B_NEW为货物列表,以height为背包容返回strip普通层生成流程如算法6所示.以集合GS中所有优条为货物,以length为背包容量,以每个优条允许在与优层厚度thick垂直方向的最小尺寸为货物重量,以优条中箱子体积和为优条价值,通过动态规划方法解背包问题,得到普通层.在每一次求解Page7背包问题后,都记录本次背包问题的背包容量、层厚度、全部货物列表、选中装入背包的货物列表,在进行其他单一层生成时,首先判断有无近似记录可供参考,如果有,则直接根据记录生成优层,从而避免重复运算相同背包问题,大大减少装箱计算时间.查找近似背包记录的判断可以参考算法7,不再赘述.算法6.单一层生成流程.MakeLayer(GS,length,thick,GL_REC)创建空的优条列表GS_NEWforeachboxgs∈GSif(size1thick)elseif(size2thick)if(g_wei>0)//说明优条gs可以放进优层中定义普通层layerlayer··=Exist_Knapsack_Rec(GL_REC,length,if(layer=)layer··=(以GS_NEW为货物列表,以length为被返回layer查找近似背包问题记录判断流程如算法7所示.轮流访问优条记录集合中每一个优条生成记录,如果记录中优条高度和底面轮廓和给定值相同,并且:①给定箱子集是该记录对应的全部箱子集合的子集;②该记录对应选中的箱子集合是给定箱子集的子集,则认为该记录为近似背包记录,直接返回该记录选中的箱子集即可.算法7.查找近似背包记录流程.Exist_Knapsack_Rec(GS_REC,length,max_l,max_w,foreachKnapsack_Reckr∈GS_RECif(kr.length=length,并且max(kr.size1,kr.size2)=返回4计算实验本文的二叉搜索树算法(HOBTS)用C#语言实现,实验程序运行在IntelCore2Q8300@2.50GHz处理器上,运行环境为Windows7专业版,算法的计算时间主要消耗在形成优条和优层的背包运算上,由于采用了根据近似装箱记录来复制优条,从而大大减少背包运算调用次数,大大减少了装箱计算时间.为了提高装箱率,我们以0.005为间距,从0.9~1设置fr_gate值,每个装箱实例调用算法1总共21次,从中选择填充率最高的装箱方案作为最终方案.本文的算例数据来源于文献[9],本算法在箱子种类强多样性环境中优势突出,包括BR1-BR15一共1500个三维装箱实例,他们可以从OR-Library网站①下载.这些实例共分为15种类型,每类100个实例.每类问题中箱子类型数相同,BR1~BR15中箱子的类型数分别为3、5、8、10、12、15、20、30、40、50、60、70、80、90、100,多样性由弱到强,能够很好地测试算法在不同多样性装箱问题中的性能.许多研究者全部或部分测试了文献[9]中的1500个实例其中组合启发式算法(CH)[25]、顺序和并行执行的禁忌搜索算法(PTSA)[14]、MFB算法[23]、随机启发式算法[24]、H_B算法[32]、启发式算法(SPBBL-CC4)[5]致力于研究弱异构装箱问题,仅测试BR1~BR7.H_BR算法[9]、GA_GB算法[10]、禁忌搜索算法TS_BG[11]、贪心随机自适应搜索算法(GRASP)[15]、maximal-space算法[16]、可变邻域搜索算法(VNS)[17]、混合模拟退火算法(HSA)[26]、整数拆分树搜索算法(CLTRS)[18]、FDA算法[31]以及最新的多层启发式搜索算法(MLHS)[28]测试了BR1~BR15全部实例.A2算法[27]测试了BR8~BR15.4.1实例计算结果分析上述比较算法全部满足C1约束,部分满足C2约束,算法的计算结果直接来自于相应文献.由于本文算法的优势主要体现在箱子种类数较多的情况下,因此本文仅测试了BR8~BR15.表2和表3分别列出了算法的fr_gate取值详细信息和填充率详细信息.①ORLibrary.http://people.brunel.ac.uk/~mastjjb/jeb/Page8casecase1case2case3case4case5case6case7case8case9case10case11case12case13case14case15case16case17case18case19case20case21case22case23case24case25case26case27case28case29case30case31case32case33case34case35case36case37case38case39case40case41case42case43case44case45case46case47case48case49case50case51case52case53case54case55case56case57case58case59case60case61表2HOBTS算法的犳狉_犵犪狋犲取值数据BR1110.94#0.9150.955#0.970.9350.950.95#0.9450.950.960.930.920.9150.950.950.93#0.9450.930.9350.960.980.960.9450.9450.945#0.910.950.9550.950.9350.960.970.950.9550.9550.9650.9650.9750.965#0.9450.965#0.960.95fr_gate0.940.9250.970.945#0.9050.9250.950.960.9450.96510.940.9650.950.9250.96#0.915#0.9450.9050.945#0.920.960.960.9450.955#10.951#0.9510.960.970.9650.97#10.950.960.9550.950.975#0.950.940.95510.9450.940.970.9550.9450.97110.9510.9450.94#0.9550.9550.97511Page9casecase62case63case64case65case66case67case68case69case70case71case72case73case74case75case76case77case78case79case80case81case82case83case84case85case86case87case88case89case90case91case92case93case94case95case96case97case98case99case100BR1110.950.9650.9650.930.975#0.9750.955#0.90.9650.93#0.9650.940.9450.950.970.9650.9150.9350.9450.9550.965#0.940.950.980.940.960.970.9550.960.9450.940.97注:指通过调用算法3(a)得到最优值;#指通过调用算法3(b)得到最优解.表3HOBTS算法的填充率数据casecase1case2case3case4case5case6case7case8case9case10case11case12case13case14case15case16case17BR110.897970.911070.896150.905330.898980.902820.897430.899850.905700.901400.906180.898080.902360.898940.907780.901030.90790fr_gate10.95#0.960.960.950.98110.9610.9650.970.93#0.9550.9650.930.95#0.930.9610.9450.93#0.92510.9711110.9550.9650.970.960.9550.960.9650.97#0.961填充率0.902580.900900.892900.888790.895940.902340.892900.898020.908630.902650.915710.893390.895940.896520.910860.897840.90157Page10casecase18case19case20case21case22case23case24case25case26case27case28case29case30case31case32case33case34case35case36case37case38case39case40case41case42case43case44case45case46case47case48case49case50case51case52case53case54case55case56case57case58case59case60case61case62case63case64case65case66case67case68case69case70case71case72case73case74case75case76case77case78BR110.897680.901590.907920.891700.907670.893910.903670.905350.888200.907260.905460.898310.908040.901800.905120.903770.902390.903450.904770.907640.895170.907610.903660.906660.911760.913660.908470.894330.897050.882840.910950.892970.898020.905570.904680.895020.902570.905340.911370.895800.907100.897270.909530.904280.901530.894300.900910.916060.896900.899050.905110.894240.898210.914660.905940.900970.900270.917150.900710.897650.90625填充率0.895840.907000.906020.894400.899340.900930.898800.904480.888250.903320.891770.894170.917770.891620.908840.904400.899990.901090.903320.911410.903760.897360.900570.903760.908530.903830.904850.897980.904050.896510.910720.905140.898400.909300.898990.903430.897050.909090.897740.902560.902320.904770.912010.913870.899560.900610.885630.906670.907310.898600.909110.903390.908160.911330.903600.909240.903560.900200.911550.897940.89399Page11casecase79case80case81case82case83case84case85case86case87case88case89case90case91case92case93case94case95case96case97case98case99case100BR110.897970.906270.887580.899520.909970.906130.914280.900370.909840.903740.912760.900290.893960.908430.911930.915460.896620.894120.900980.907290.887390.90779表4列出了前述算法与本文算法HOBTS的计算结果,表中所有的数据表示每个算法针对一类实例所得到的平均填充率(%).HOBTS算法的计算结果是在同时满足C1、C2和C3约束的条件下得出的.从表4可以看出,在同时满足C1、C2和C3约束的前提下,在箱子种类数在90种以上时,填充率超过了目前已知的所有算法.其中箱子种类数为90时,超过目前最好的MLHS算法0.27%.当箱子种类数为表4各种算法对BR8~BR15的填充率比较算法H_BR[9]GA_GB[10]TS_BG[11]GRASP[15]maximal-space[16]HSA[26]A2[27]VNS[17]CLTRS[18]FDA[31]MLHS[28]HOBTSBR1076.5385.5384.7388.7389.8789.0687.9091.9293.0990.8692.2493.9591.8390.59表5给出了本文算法对BR8~BR15的计算时间,对BR8~BR15,HOBTS算法的平均运行时间是175.49s,而CLTRS和MLHS算法在考虑C1和C2约束(比本文算法少了C3约束),BR1~BR15的平均计算时间分别为197.33s和320s,由于BR1~填充率0.899020.903800.885090.884230.900160.892510.906180.900790.915960.890740.910120.898750.897710.910750.907400.911180.890470.892530.894120.903390.891570.90111100时,比目前最好的MLHS算法提高了0.84%.当箱子种类数为60时,超过CLTRS算法0.17%;当箱子种类数为70时,超过CLTRS算法0.63%;当箱子种类数为80时,超过CLTRS算法0.87%;当箱子种类数为90时,超过CLTRS算法1.35%;当箱子种类数为100时,超过CLTRS算法1.81%.从HOBTS算法对于BR8~BR15的装箱率趋势来看,箱子种类数越多,越能体现HOBTS算法的优势.BR1175.0884.8283.5587.8789.3688.1887.8891.4692.8190.1191.9193.6191.2390.28BR7箱子种类数少,计算时间比BR8~BR15平均要少,所以CLTRS和MLHS算法对于BR8~BR15的平均运算时间比BR1~BR15的还要多,因此本文算法在计算时间上有优势的.Page12算例BR8BR9BR10BR11平均值4.2算法的复杂性分析以最极端情况下的装箱实例为例说明算法的复杂性.在最极端情况下,任意两个箱子的尺寸都不相同,每个箱子的长宽高都不相同,且可以正放,侧放和仰放.在分析之前先作如表6定义(之前的符号定义在接下来的部分中被自动忽略).变量名称b_nb_lwhc_lwc_htree_layer_ntree_node_ngl_ngl_com_nHOBTS_Tfr_gate_ngl_tdp_gl_tdp_gs_tdp_u则有gl_n≈c_lw/b_lwh和tree_layer_n=gl_n+1.所以tree_layer_n≈c_lw/b_lwh+1.又对于二叉树,有tree_node_n≈2tree_layer_n-1,所以tree_node_n≈2c_lw/b_lwh+1-1,由于二叉树上除了根节点外,每一个节点生成一个新优层,所以gl_com_n=tree_node_n-1,所以而算法的时间主要花费在生成优层上.易得每生成一个优层前,平均剩余箱子数为b_n/2,又每生成一个优层,需要生成一组优条,又每个优条平均包含c_h/b_lwh个箱子,所以这组优条平均包含b_n×b_条生成优层,平均需要求解背包运算次数即为优条数目的两倍(以每个优条的长和宽为厚度生成优层):每个动态规划方法求解优层背包问题的计算时间:dp_gl_t=对于特定优层,每生成一个优条前,平均剩余箱子数为优层平均剩余箱子数的一半,即b_n/4,则可以得到为了从箱子生成优条而调用的背包运算次数为其中算法3(a)调用b_n×3/4次,算法3(b)调用b_n×2/4次.每个动态规划方法求解优条背包问题的计算时间:依据式(14)~(17)可得依据式(13)和(18),HOBTS总共求解一维背包问题耗费时间:HOBTS_T≈fr_gate_n×gl_com_n×gl_t所以本文算法的时间复杂度表示为我们只在张德富等人[30]的文献中找到对算法的时间复杂度的分析,该文算法的时间复杂度为O(b_n3),说明了本文算法的时间复杂度是有竞争力的.算法运行过程中,始终只保留一个最优装箱方案,算法2是递归算法,其嵌套深度约等于c_lw/b_lwh,该值通常为个位数,算法运行过程中占用的存储空间不大,现今的普通计算机内存完全可以胜任.以上分析没有考虑算法7对整个算法的加速作用,实际计算过程中,调用算法7比不调用算法7快数倍以上.4.3算法的收敛性分析HOBTS算法的流程主要表现为算法2的递归调用,每一次递归调用之后,容器中增加一个优层,容器中箱子的体积和增加,容器填充率向填充上限(100%)靠近,递归调用次数严格小于容器长宽的较大值与所有箱子尺寸最小值的比值.在算法的实现函数中,优层数量作为自变量是离散的并且有限的,填充率作为函数值是递增的并且有上限,所以本文Page13算法是收敛的.4.4算法的可行性和稳定性BR8~BR15的运行结果说明了本文算法是可行的,式(19)可以看出本文算法的计算时间与箱子数目的平方成线性关系,与fr_gate_n成线性关系,与容器长宽尺寸对箱子平均尺寸的比值成指数关系.当箱子平均尺寸变化不大时,算法是比较稳定的.当箱子平均尺寸剧烈变小时,计算时间剧烈增加,因此还需要进一步提高算法的稳定性来应对箱子尺寸变小的情况.5结束语三维装箱问题是经典且实用的问题,在众多学者的耕耘下,填充率不断接近极限最优,要提高越来越困难.本文提出了三维装箱问题的启发式二叉树搜索算法,首先将所有箱子组合成多个优条,通过沿容器长度边和宽度边增加一层优条来得到每个节点的左右子节点.二叉树一直扩展,直至所有叶子节点都摆不下任意剩余的箱子为止.最后从所有叶子节点中选择填充率最高的装填方案作为最终的计算结果.HOBTS算法首次可以同时满足C1、C2和C3三大约束.在箱子种类数小于90时,平均填充率略低于MLHS算法,在箱子种类数小于60时,平均填充率略低于CLTRS算法,但是在箱子种类数超过90时,HOBTS算法最优,通过增加fr_gate值的密集度,填充率还可以提升.另外HOBTS算法也存在需要改进的地方,当箱子种类数较少时,HOBTS算法的装箱率相对于现有算法不具有优势;另外二叉树搜索深度取决于摆放的优层数,当箱子体积相对于容器容积越小时,优层数就越多,二叉树搜索深度就越深,计算时间就越长.
