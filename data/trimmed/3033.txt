Page1从规划解中学习一阶派生谓词规则饶东宁1),2)蒋志华3)姜云飞2)刘强2)1)(广东工业大学计算机学院广州510090)2)(中山大学信息科技学院软件研究所广州510275)3)(暨南大学计算机科学系广州510632)摘要派生谓词是描述动作非直接效果的主要方式.但是由人类专家设计的派生谓词规则(即领域理论)不能保证总是正确或者完备的,因此有时很难解释一个观察到的规划解为什么是有效的.结合归纳学习与分析学习的优点,文中提出一种称为FODRL(First-OrderDerivedRulesLearning)的算法,在不完美的初始领域理论的引导下从观察到的规划解中学习一阶派生谓词规则.FODRL基于归纳学习算法FOIL(First-OrderInductiveLearning),最主要的改进是可以使用派生谓词的激活集来扩大搜索步,从而提高学习到的规则的精确度.学习过程分为两个步骤:先从规划解中提取训练例,然后学习能够最好拟合训练例和初始领域理论的一阶规则集.在PSR和PROME-LA两个派生规划领域进行实验,结果表明,在大部分情况下FODRL比FOIL(甚至包括其变型算法FOCL)学习到的规则的精确度都要高.关键词人工智能;智能规划;派生谓词规则;归纳学习;激活集1引言规划是关于动作的推理.在这个过程中,首先要预期各种动作的效果,然后制定满足某些目标的动作执行策略.一般地,在对规划领域建模的时候,动作模型越简洁,越有利于规划问题的求解和执行得到的规划解.根据动作发生的对象,动作的效果可以分为两类:直接效果和非直接效果.每次执行一个动作,动作的直接效果通过动作模型在当前状态下发生,而动作的非直接效果通过推理规则在改变后的状态下进行推导.这样的推理规则独立于任何动作模型,使得规划领域的描述变得清晰和简洁.为了建立表示动作非直接效果的推理规则,在规划领域描述中,谓词分为两类:基本谓词和派生谓词[1].二者的差别是,基本谓词可以出现在领域动作的效果中,而派生谓词不能,它们在当前状态下的真值是由封闭世界假设中其它谓词的真值通过领域规则推导出来.派生谓词不能作为动作的直接效果,但是可以出现在动作的前提(称为派生前提)和目标状态(称为派生目标)中.有了派生谓词,动作模型只需要描述动作的最直接效果,而事物之间千丝万缕的因果联系可以用派生谓词规则来表示,很好地解决了规划领域描述的框架问题[2]和动作衍生问题[3].一般地,某个领域的派生谓词规则是由熟悉该领域的人类专家所设定的.这些规则集合称为领域理论.然而,由于领域的复杂性,在大多数情况下这些规则很难保证是正确而且完备的.例如,由于信息不足某些规则的条件被遗漏了,或者由于错误的理解某些规则包含不必要的条件.如果预先给定的领域规则是错误的,可能会导致错误的规划解或者原问题无解.如果给定的规则是不完备的,可能无法解释一个Agent观察到的规划解为什么是有效的.比如,动作的某个派生前提为什么在当前状态下是成立的,再比如,一个期待的目标在最终状态如何通过规则推导出来?因此,从实际观察到的规划解中学习派生谓词的规则,一方面可以验证初始的领域理论是否是完美的,另一方面可以挖掘领域中隐含的因果联系以完善领域理论.这是一个有趣而且有前景的研究课题.规划和学习的结合已经成为人工智能研究领域的一大热点.在最近几年的国际会议IJCAI、AAAI、ICML、ICAPS以及权威期刊AI、JAIR上已有不少文章讨论将学习技术应用到规划研究领域中,例如学习动作模型[4-6]、学习控制知识[7-8]、学习启发式函数[9]、学习动作策略[10]等.动作模型的学习是从规划解中寻找状态之间、动作之间的各种关联,以提取动作的前提和效果.控制知识的学习是从动作序列中提取一般规律,用于引导规划解的搜索过程.启发式函数的学习是调整各种启发项的权值,用以加速启发式搜索过程.动作策略的学习从规划解中寻找针对某领域的状态-动作规则,使得应用这些规则无需搜索就可找到规划解.在最新的进展上,在今年即将举行的国际规划竞赛IPC2008上,将首次增加一个learningtrack,以测试规划系统的学习性能和规范各种学习问题描述.虽然已经有不少方法用于学习领域规则,例如遗传算法、决策树学习、FOIL或者EBL等,但是至今还没有研究工作学习规划领域的派生谓词规则.由于一个规划领域可能包含多个派生谓词,因此派生谓词规则学习属于多谓词学习[11-12],并且学习的是一阶规则,是比较复杂的学习任务.本文从规划解中学习派生谓词规则分为两个步骤:首先,在假定动作模型已知的前提下,从规划解中提取学习问题所需要的训练例.规划解不能直接作为学习问题的训练例,但是可以将规划解应用于初始状态产生的〈状态-事实〉序对来作为规则学习的训练例;其次,结合归纳学习和分析学习的优点,使用初始领域理论来推导派生谓词的激活集,这些激活集可以作为构造规则前件的候选式,使得归纳学习算法在假设空间中一次移动多步,极大地改变搜索的方向.本文提出的方法在两个派生规划领域PSR和PROMELA进行实验,从而验证方法的可行性和有效性.本文第2节介绍本文的研究背景,包括各种学习规则的方法和派生规划问题的综述;第3节从训练例的构造和初始领域理论等方面来具体地描述要Page3处理的学习问题;第4节给出学习的主算法FO-DRL以及如何根据初始领域理论建立规则图和在规则图上计算用于扩展搜索步的派生谓词的激活集;第5节是实验和分析部分;最后一节是结语以及对未来工作的展望.2研究背景本节从机器学习领域的各种学习规则的方法以及智能规划领域的派生规划问题描述等方面,来介绍本文的研究背景.2.1学习规则集合基本的规则学习方法分为归纳学习和分析学习.纯粹的归纳学习方法通过在训练样例中寻找经验化的规律来形成一般假设,如决策树归纳(Deci-sionTree)、遗传算法(GeneticAlgorithm)、序列覆盖算法(SequentialCoveringAlgorithm)和FOIL(First-OrderInductiveLearning)[13]等.纯粹的分析方法使用先验知识演绎推导一般假设,如基于解释的学习EBL[14].在EBL中,先验知识用于分析观察到的学习样例怎样满足目标概念,然后这个解释被用于区分训练样例中相关的特征.EBL已被成功地用于在各种规划和调度任务中学习控制知识,如规划系统PRODIGY和SOAR等.为了获得有先验知识时更高的泛化精度和依赖训练数据克服先验知识的不足,应该将归纳和分析两种机制结合起来,如KBANN、EBNN、FOCL[15]等算法.FOCL基于归纳系统FOIL,在修正假设时使用领域理论来扩展可用的文字集合,在单个搜索步中一次加入多个文字,极大地改变搜索方向.本文的方法与FOCL相似,区别在于:(1)FOCL所接受的初始领域理论不允许包含递归的规则,而本文的FO-DRL算法允许递归规则;(2)FOCL学习的是某个概念的分类规则,而本文学习的是派生谓词规则,表示动作的各种效果之间的因果联系;(3)FOCL的非操作型文字(即不出现在训练例中的谓词)的作用仅仅是使得领域理论具有层次结构,而规划领域中的派生谓词可以作为动作的前提和规划问题的目标.以上的规则学习方法都是单谓词学习,一次只学习一个概念,采用了强假设:要学习的概念之间是彼此独立的.因此,学习概念的顺序可能会影响学习的结果.多谓词学习同时学习几个概念,在学习过程中要不断检测学习到的规则是否满足谓词之间的依赖关系,因此比单谓词学习要复杂得多.多谓词学习一般显式地表示谓词之间的依赖关系,使用依赖层次来引导学习过程,如MPL[11]和RTL[12]等算法.本文的学习主算法采用了多谓词学习方法的主体框架.相关工作还包括:Zettlemoyer等提出的一种算法在有噪音的随机环境下学习动作的效果模型[16],将预先定义的操作子应用到各个文字上来迭代地产生新的谓词,并且在学习到的动作模型上测试其有用性.但是,他们的工作是学习动作模型中的派生效果而非派生谓词的规则.2.2派生规划问题简单地说,包含派生谓词的规划问题称为派生规划问题.派生谓词规则实质上是PDDL公理.Mc-Dermott最早将“公理”一词引入到规划问题描述语言PDDL中,称为PDDL公理[17].之后,Thiebaux等给出了PDDL公理的精确语义,并且证明在限定规划长度和领域描述是多项式级的条件下,公理是规划描述语言的基本要素,不可能用其它的语言要素来完全替换[1].设B是基本谓词符号集合,D是派生谓词符号集合,B∩D=.R是派生谓词规则(或简称为规则)集合,R中的规则具有如下形式:(:derived(d?狓)(f?狓)),其中d∈D,f是由集合B∪D中的谓词符号所构建的一阶公式,f中的自由变量与d中的相同,均为狓.直观地,规则(:derived(d?狓)(f?狓))意味着当(f?狓)在某个状态为真的时候,应该推导出具有相同参数的(d?狓)在该状态下也为真.在本文中,派生规则集合R称为领域理论.规则中一阶公式f的否定范式NNF①如果使用了某个谓词的否定形式,则该谓词应该首先被定义.因此,规则集的层次结构定义如下.定义1.规则集R是分层的,当且仅当存在着派生谓词集合D的一个划分{Di,1in},对于任意di∈Di及每个规则(:derived(di?狓)(f?狓))∈R,满足下列条件:(1)如果dj∈Dj出现在NNF(f?狓)中,那么ji;(2)如果dj∈Dj在NNF(f?狓)中是以否定的形式出现的,那么j<i.例1.在用PDDL2.2语言[18]描述的PSR领域(处理供电系统的重新配置问题)的DerivedADL版本②(附录A)中,D1={unsafe,upstream},D2=①②Page4{affected,fed}.定义2.D上的任何一种层次结构{Di,1in}自然导致了R上的层次结构{Ri,1in}:Ri={(:derived(di?狓)(f?狓))∈R|di∈Di}.不管选用哪一种层次结构,从最低层开始以任意顺序应用规则直到到达一个固定点,然后前进到下一层,以任意顺序应用规则直到到达一个固定点,直至最后一层.这样的推理顺序将导致相同的最终固定点[19],而这个最终的固定点即为规则集的逻辑结论集合.在下列定义中,狓表示变量向量,狋表示基原子向量.对任意b∈B,(b狋)称为基本事实.对任意d∈D,(d狋)称为派生事实.设状态s是由基本事实组成的集合.在状态s中,应用规则r=(:derived(d?狓)(f?狓))将推导出派生事实集合r(s),即规则r在s中的逻辑结论.定义3.r(s)={(d狋)|s(f狋),狋是基向量}.其中,是逻辑蕴涵符号.定义4.对一个分层的规则集R,设{Ri,1in}是任意的一种分层结构.对于每个状态s,有(1)R0(s)=;(2)Ri(s)=∩{DF|∪r∈RiDF},1in;则R(s)=Rn(s)在定义4中,Ri(s)是包含Ri-1(s)及第i层规则的逻辑结论的最小派生事实集合.如果一个由基本谓词和派生谓词组成的公式f在状态s中成立,有以下定义:定义5.sRf当且仅当s∪R(s)f.为了方便规划问题描述,将状态s进行扩充.定义6.函数-D将状态s映射为在规则集R下的扩充状态:根据规则集的语义,按照任何一种层次结构在s上应用规则集R都产生相同的-D(s).在派生规划问题描述中,动作模型可以如下定义:定义7.动作a是三元组〈pre(a),add(a),del(a)〉,pre(a)是动作a的前提集合,add(a)是动作a的增加效果集合,del(a)是动作a的删除效果集合.派生谓词集合D中的符号不出现在add(a)和del(a)中.对任意b∈B,如果b出现在pre(a),则b称为a的基本前提.对任意d∈D,如果d出现在pre(a),则d称为a的派生前提.一个动作在某个状态中是可应用的,当且仅当该动作的所有前提在该状态中〈B,D,R,S,A,X〉:(:derived(d?狓)(f?狓))}.是成立的.定义8.动作a在状态s中是可应用的,当且仅当sRpre(a).如果动作模型中不包含任何变量,则该动作称为原子动作.在确定性的派生规划问题中,原子动作应用于当前状态将产生唯一的后继状态.定义9.在状态s下应用原子动作a的函数apply定义如下:s=apply(a,s)=(s\del(a))∪add(a),s称为后继状态.下面,给出派生规划领域的形式化定义.定义10.派生规划领域是一个六元组Σ=·B是基本谓词符号集合;·D是派生谓词符号集合,且B∩D=;·R是派生谓词规则集合,R={r|r=·S是状态集合;·A是动作集合,A={a|a=〈pre(a),add(a),del(a)〉};·X是转换函数,X(s,a)=-D(apply(a,s)),当原子动作a在s中是可应用的;例2.PSR问题的领域描述见附录A,要处理的是在某些线路出故障的情况下,供电系统要调整相应的设备开关来给需要供电的线路恢复供电.基本谓词集合B={ext,breaker,closed,faulty,con},派生谓词集合D={upstream,unsafe,affected,fed},带有条件效果的动作集合A={wait,open,close}.规则集合R中共有4条派生谓词规则,规则条件中的一阶公式允许逻辑运算(and,or,not)、存在量词(exist)及全称量词(forall)等.谓词集合中各个谓词符号的含义如下:(ext?l?x?s):线路?l连接设备?x的某一(breaker?x):设备?x是一个电源;(closed?x):设备?x是闭合的;(faulty?l):线路?l有故障;(con?x?sx?y?sy):设备?x的?sx边与设备(upstream?x?sx?y?sy):从设备?x的?sx边(unsafe?x?sx):设备?x的?sx边是不安全的;(affected?x):设备?x受到故障线路的影响;(fed?l):线路?l需要供电.定义11.一个派生规划问题是一个三元组Σ=?y的?sy边相连;有电流流向设备?y的?sy边;边?s;Page5〈Σ,I,G〉,其中,Σ是规划领域描述;I是初始状态;G是目标状态.定义12.派生规划问题Π=〈Σ,I,G〉的解是一个原子动作序列〈a1,a2,…,an〉,该动作序列通过一系列的状态变换〈s0,s1,s2,…,sn〉将初始状态I转化为目标状态G:(1)s0=I;(2)si-1Rpre(ai),si=X(si-1,ai),1in;(3)Gsn.3学习问题描述初始的领域理论可能是不正确的,或者不完备的.不管是哪一种情况,均称为不完美的领域理论.不完美的领域理论可能会导致原问题得到错误的规划解或者无解.初始领域理论可以由专家根据经验提供,也可以通过更抽象的背景知识来构建[20].不完美的领域理论可能包含以下四种错误:(1)多余规则;(2)缺少规则;(3)多余的规则条件;(4)缺少的规则条件.多余规则是指领域理论中定义派生谓词的某个规则整个是错误的.缺少规则是指领域理论缺少某个派生谓词的规则,因而领域理论是不完备的.多余的规则条件是指某个规则的条件部分包含错误的谓词.缺少的规则条件是指某个规则的条件部分缺少某个必要的谓词.一般地,多余的规则或者规则中缺少必要的条件,会使得领域理论过于一般,而缺少规则或者规则中包含多余的条件,会使得领域理论过于特殊.但是不管包含何种错误的初始理论,都要求每个谓词所有参数的类型信息是已知的.第5节的实验部分具体分析了各类领域理论错误对于学习到的规则的精确度的影响.例3.构造PSR领域的包含四类错误(已用粗体表示)的初始领域理论,如表1所示.其中,side1和side2是理论常量,可以出现在规则中.各个谓词符号的含义见例2.与附录A中完美的领域理论相比,表1中的规则包含如下错误:规则r1的条件部分包含了多余的谓词break,规则r2的条件部分为空,即缺少关于派生谓词unsafe的规则,规则r4是关于派生谓词fed错误的规则,规则r5的条件部分缺少必要的谓词closed.此外,规则r3没有错误,是完全正确的.表1构造PSR领域的包含四类错误的初始领域理论描述r1:(:derived(upstream?x-DEVICE?sx-SIDE?y-DEVICE?sy-SIDE)(and(closed?x)r2:(:derived(unsafe?x-DEVICE?sx-SIDE))缺少规则r3:(:derived(affected?x-DEVICE)r4:(:derived(fed?l-LINE)(faulty?l))多余规则r5:(:derived(fed?l-LINE)(exists(?x-DEVICE)规划解可以由在实验环境中活动的Agent观察得到.但是一个规划解只包含动作序列,派生谓词只在其中充当动作前提,因此规划解不能直接作为学习问题的训练例.对于一个状态s而言,派生事实(d狋)只存在成立或不成立两种情况.如果(d狋)在s中成立,则说明sR(d狋),该状态可以作为学习规则的正例;反之,则为反例.因此,在动作模型完全已知的情况下,可以把规划解应用于初始状态,从而得到状态转化序列,这些状态可以作为学习规则的训练例.定义13.设训练例为序对〈s,d〉,其中s是状态,d是派生事实.如果有sRd,则称〈s,d〉为关于d的正例,反之,则称〈s,d〉为关于d的反例.下面给出从规划解中产生训练例的GTE(Gen-eratingTrainingExamples)算法.该算法产生学习所需要的正例集合Tp和反例集合TN.在该算法中,|P|表示规划解的长度,即所包含的动作个数.由于PDDL动作中允许否定前提,因此派生前提如果是以肯定形式出现的,则产生一个正例,如果是以否定形式出现的,则产生一个反例.si是在状态si-1下应Page6用动作ai产生的后继状态(Apply函数见定义9).对于每个派生目标,在最终状态下是成立的,因而产生一个正例.为了增加训练例的个数且简化学习过程,对于所有非最终状态,均认为目标不成立.对每个规划解分别应用GTE算法,再将所有正例集合合并在一起,所有反例集合合并在一起,则可以得到最终的训练集合.算法.算法1.GTE(GeneratingTrainingExamples)输入:派生规划问题〈Σ,I,G〉,规划解P输出:正例集合Tp,反例集合TNBegin1.Tp←,TN←;2.s0←I;3.Fori=1to|P|do4.对于动作ai的每个派生前提d5.如果d是ai的肯定前提,则6.Tp←Tp∪{〈si-1,d〉};7.否则8.TN←TN∪{〈si-1,d〉};9.si=Apply(ai,si-1);10.对于每个派生目标g∈G11.Fori=0to|P|-1do12.TN←TN∪{〈sj,g〉};13.Tp←Tp∪{〈s|P|,g〉};End.例4.设一个PSR规划问题的解为动作序列〈WAIT,OPEN(SD8),CLOSE(CB2)〉,对应的状态序列为〈s0,s1,s2,s3〉,其中,s0是初始状态,s3是目标状态.应用GTE算法,产生了如表2所示的训练集合.〈s0,(affectedcb1)〉〈s0,(affectedcb2)〉〈s3,(fedl5)〉〈s3,(fedl6)〉从规划解中产生训练例之后,本文的学习任务为:已知:·一个训练样例集合T,可能包含错误;·一个领域理论R,可能包含错误;·假设空间H;求解:一个最好地拟合训练样例和领域理论的假设h.在上述学习任务中,每个假设h是类似Horn子句的子句集合,区别在于:文字中不允许包含函数符号,因而比Horn子句更受限制;子句体中允许出现负文字,因而比Horn子句更有表征力.每个子句是一个一阶的派生谓词规则,子句头是单个派生谓词d∈D,子句体是由B∪D中的谓词构成的文字集合.要求学习到的假设最好地拟合训练样例和领域理论,是指使假设在数据和领域理论上的错误率的某种综合度量最小化.定义h关于训练集T的错误率errorT(h)为T中被h误分类的样例所占的比例,同样地,定义h关于领域理论R的错误率errorR(h)为h与R在分类一个随机实例时不一致的概率.希望输出的假设是使得上述错误率的某种综合度量最小化,如argminh∈H(kT×errorT(h)+kR×errorR(h)),KT和KR分别表示拟合数据和拟合理论两者的相对重要程度.如果初始领域理论的精确度较差,却有大量可靠数据,则可以选择较大的KT值.如果理论的精确度较高,数据样本很小并且存在大量噪声,则可以选择较大的KR值.4学习算法在定义了上述学习任务之后,下面先来看看学习规则的整个过程(如图1所示).首先使用GTE算法从规划解和规划问题描述中产生学习问题所需的训练例集合.其次,规划问题描述中包含初始的领域理论,可以用来建立规则图,规则图描述了谓词之间的依赖关系.学习算法FODRL基于基本归纳系统FOIL,在假设空间寻找拟合训练例的最佳假设.通过ASS(ActivationSetSearching)算法得到派生谓词的激活集,用来扩大FOIL的搜索步,使得一次可以考虑多个候选文字.简单地说,派生谓词的激活集指的是在领域理论下能够推导出该派生谓词的基本事实或谓词集合.引入激活集的原因在于,GTE算法所产生的训练例中的状态只包含基本谓词的实例,因此当规则前件的候选文字是派生谓词时,派生谓词的规则尚未知道,只有将派生谓词转换为对应的基本谓词集合(即激活集)才能判断新构造的规则对训练例的拟合程度.最后输出的是针对规划领域的一阶派生谓词规则集合.Page7图1学习派生谓词规则的过程根据图1所描述的规则学习过程,下面分别处理如下问题:(1)建立学习规则的主算法;(2)从初始领域理论建立规则图;(3)在规则图上计算派生谓词的激活集.4.1学习算法FODRL学习派生谓词规则的主算法称为FODRL(First-OrderDerivedRulesLearning),基于RTL的多谓词学习框架和FOIL的归纳学习算法.FO-DRL算法描述如下.算法2.FODRL(First-OrderDerivedRulesLearning)算法.输入:要学习的谓词集合Learned_predicates,谓词集输出:规则集Learned_rulesBegin1.Learned_predicates中的谓词形成队列;2.Learned_rules←{};3.当队列不空4.取队列中的第一个谓词Target_predicate5.Pos←Examples中Target_predicate的正例;6.Neg←Examples中Target_predicate的反例;7.NewRule←没有前件的谓词Target_predicate的8.NewRuleNeg←Neg;9.当NewRuleNeg不空,增加新候选前件以特化10.基于谓词集Predicates对NewRule生成候选11.如果NewLiteral是派生谓词,则12.Candidates←基于规则图通过ASS算法求Ne-13.否则,Candidates←NewLiteral;14.Best_candidate←argmaxFodrl_Gain(L,Ne-15.把Best_Candidate加入到NewRule的前件;16.NewRuleNeg←NewRuleNeg中满足NewRule17.Learned_rules←Learned_rules+NewRule;18.NewRule加入到规则图中;19.Pos←Pos-{被NewRule覆盖的Pos成员};20.如果Pos非空,则Target_predicate加入队列末尾21.Examples←Examples-{被NewRule覆盖的Ex-22.返回Learned_rules;End.FODRL由两层循环来进行控制.外层循环与RTL类似,将要学习的谓词排成队列,每次选取排在最前面的谓词Target_predicate来学习规则.如果学习到的规则仍有未覆盖的正例,则将Target_predicate放在队列的末尾留待以后再学习.交叉学习不同谓词的规则,可以利用谓词之间的依赖关系来构建规则的前件,是一种多谓词学习过程.FODRL的内层循环与FOIL类似,每次学习一个覆盖部分正例而避开所有反例的规则.内层循环执行一般到特殊的爬山搜索,开始于最一般的前件,然后增加文字以使规则特化直到避开所有的反例.然而,与FOIL算法不同的是,FODRL算法在生成候选式Candidates时使用了初始领域理论来扩大搜索步(步11~12).FODRL生成两类候选式:单个文字,被单独加到规则前件中;文字集合,被整个加到规则前件中.单个文字为谓词集Predicates中出现的任意基本谓词或其否定,但是要求至少包含当前规则中一个已有的变量.如果候选新文字是派生谓词,则需在领域理论下推导其激活集(文字集合)来代替FODRL通过在训练数据上测量规则的性能,每一步从候选式中选择最有希望的文字或者文字集合.FODRL使用评估函数Fodrl_gain以估计新候选式的效用,它基于加入候选式之后的正例和反例的约束数目.设R为加入候选式L到规则R后生成的规则,则Fodrl_Gain(L,R)=tlog2p1其中,p0为规则R的正例约束数目,n0为规则R的反例约束数目,p1为规则R的正例约束数目,n1为规则R的反例约束数目,t是在加入文字L到R后仍旧能覆盖的规则R的正例约束数目.根据信息论的理论,Fodrl_gain(L,R)的意义为:为了编码RPage8的所有正例约束的分类所需的全部位数由于L带来的减少.特别地,如果L为文字集合,要对L中的文字进行修剪,移去对于信息增益无用的文字.4.2构造规则图为了从初始领域理论推导出谓词之间的依赖关系,需要基于初始领域理论建立规则图.规则图是与或图,由两类结点组成:与结点(谓词结点)和或结点(规则结点),与结点是由基本谓词标记的叶子结点或者由派生谓词标记的内部结点,而或结点是由一阶规则标记的内部结点.对于一个规则结点来说,它的入边(只有一条)来自于由该规则所推导的派生谓词,而它的出边(若干条)则指向该规则的所有触发条件(由基本谓词或派生谓词组成).如果规则图中的结点是用谓词来标记的,这样的规则图称为一阶规则图.由于PDDL语言允许派生谓词规则的条件部分包含逻辑运算和量词,而规则图中的规则条件是文字的合取,因此在建立规则图之前要对初始领域理论进行一些转换.由于规则条件是文字的合取,因此逻辑与运算和非运算不需要处理,而对于逻辑或运算,则将规则进行拆分,每个或条件对应一个新的规则.全称量词是隐式的,不需要处理,而存在量词是显式的,可以直接去掉而保留量词所约束的变量.例5.对于表1中关于谓词fed的规则r5,经过上述调整方法,拆分成如下4条只包含文字合取的规则:图2基于初始领域理论构造的规则图(fed?l);r5_1:(breaker?x)∧(ext?l?xside1)→r5_2:(breaker?x)∧(ext?l?xside2)→(fed?l);r5_3:(ext?l?xside1)∧(breaker?y)∧(up-stream?y?sy?xside2)→(fed?l);r5_4:(ext?l?xside2)∧(breaker?y)∧(up-stream?y?sy?xside1)→(fed?l).根据派生谓词集合上的层次关系,高层的谓词定义依赖于低层的谓词定义.为了反映这些依赖关系,规则图中必须通过变量替换将各种规则衔接起来.例如,例5中规则r5_4的条件部分包含派生谓词(upstream?y?sy?xside1),而表1的初始领域理论中只包含(upstream?x?sx?y?sy)的规则,可以通过替换{?x/?y,?sx/?sy,?y/?x,?sy/side1}来进一步扩展规则图.如果初始理论包含的规则是递归的,这样的变量替换过程会导致规则图的无限增长.因此,需要限制规则图扩展的最大层次L.例6.由表1的初始领域理论可以得到如图2所示的规则图子图(L=2).方框表示由基本谓词或者派生谓词标记的与结点,椭圆表示由规则编号标记的或结点.(fed?l)是该子图的根结点,层次为0.推导出(fed?l)的规则条件中的各个谓词层次为1,例如(upstream?y?sy?xside1)的层次为1.以此类推,推导出(upstream?y?sy?xside1)的规则条件中的各个谓词层次为2,例如(upstream?y?sy?wside1)的层次为2.Page94.3计算激活集激活集的定义来自于自然演绎推理,由Gerevi-ni等[21]引入到规划系统LPG-td来求解派生规划问题.激活集描述的是在领域理论下能够推导出派生谓词的一组条件集合.然而,由Gerevini等定义的激活集存在着两种局限:(1)激活集的计算与当前状态相关,一旦状态发生变化,需重新计算激活集;(2)激活集仅限于命题集合.我们早期的研究工作定义了与状态无关的激活集,并且提出了一种高效的算法来计算激活集[22],以及在完美的领域理论下学习与激活集对应的命题规则等[23].一个命题激活集可以定义如下[22].定义14.设d是派生事实,d的一个命题激活集F是满足FRd的由基本事实组成的最小集合.由以上定义可知,对于一个派生事实,其激活集是一个由基本事实组成的命题集合,该集合可以通过领域理论推导出该派生事实.这样的集合要求是最小化的,即不包含任何与推导无关的其它命题.例如,通过变量代换{?l/l5,?x/cb2},根据规则r5_2,有{(breakercb2),(closedcb2),(extl5cb2side2)}R(fedl5),则F={(breakercb2),(closedcb2),(extl5cb2side2)}是派生事实(fedl5)的一个命题激活集.为了在一阶规则的学习过程中用激活集来扩展搜索步,这里将命题激活集的定义扩展为一阶激活集.定义15.设d是派生谓词,d的一阶激活集F是满足FRd的由基本谓词组成的最小集合.由定义15可知,一阶激活集是可以通过领域理论推导出某个派生谓词的基本谓词组成的集合.同样地,这样的集合也要求是最小的,即不包含任何与推导无关的其它谓词.把一阶激活集中的变量全部用常量来进行替换,可以得到对应派生事实的命题激活集.一阶激活集可以在一阶规则图上进行查找,而命题激活集需要将规则图用具体问题所包含的对象进行实例化才能进行查找.相对于实例化空间,层次受限的一阶规则图的搜索空间显然要小得多.在不正确或者不完备的领域理论下,可能会产生不正确的一阶激活集.这些激活集仍然可以用于扩展学习过程的搜索步,因为扩展的搜索步是一种多步探测,它的去留仅仅取决于对训练数据的拟合程度.因此,下面给出在可能包含错误的规则图上计算一阶激活集的ASS算法.一个派生谓词可能有多个不同的激活集,这些激活集构成了激活集集合Σ.给定一个派生谓词和基于初始领域理论建立的规则图,该算法返回派生谓词的激活集集合Σ.ASS算法描述如下.算法3.ASS(ActivationSetSearching)算法.ProcedureAnd-Search(n,A,PathNodes,Open)输入:规则图R上的与结点n,构造中的激活集A,从输出:A中的元素,逻辑值false或空集Begin1.如果n∈PathNodes,则返回false;2.否则,如果n是一个基本谓词,则返回n;3.如果n没有任何后继规则结点,则返回false;4.对于n在规则图R中的任何一个后继规则结点,调用5.Or-Search(n,A,PathNodes∪{n},Open);6.返回空集.End.ProcedureOr-Search(n,A,PathNodes,Open)输入:规则图R上的或结点n,构造中的激活集A,从副效果:更新激活集集合ΣBegin1.Open←Open∪{n|n是n在规则图R上的后继谓词2.对于Open表中所有元素t3.Open←Open\{t};4.n←And-Search(t,A,PathNodes,Open);5.如果n=false则返回;6.否则A←A∪{n};7.Σ←Σ∪{A}.End.在规则图上计算某个派生谓词的激活集,是两个过程的交替搜索:与搜索过程和或搜索过程.在与搜索过程中,如果当前与结点是一个基本谓词,则放到正在构造的激活集A中.如果是一个派生谓词,则对它的每一个规则结点(或结点)调用或搜索过程.在或搜索过程中,对于规则结点的每一个触发条件(与结点)进行与搜索过程.为了避免无限循环,用PathNodes表来记录已经搜索过的派生谓词结点,若待扩展的结点是已经访问过的(与PathNodes表上某个谓词的名字和参数均相同),则停止对该结点的扩展.由于规则图的层次是受限的,因此规则图的规模是有限的,在遍历规则图中的所有结点之后,上述的搜索算法最终会停止.Page10例7.基于图2的规则图,应用ASS算法计算出fed(?l)的一阶激活集集合Σfed(?l)如下:F1={(faulty?l)}烄F2={(breaker?x),(ext?l?xside1)}F3={(breaker?x),(ext?l?xside2)}F4={(breaker?y),(ext?l?xside2),F5={(breaker?y),(ext?l?xside2),烅F6={(breaker?y),(ext?l?xside1),F7={(breaker?y),(ext?l?xside1),烆下面举例说明激活集对搜索步的扩展.例8.学习派生谓词fed(?l)的规则,该谓词在训练集中有2个正例和6个反例(见表2).用[n+,n-]来表示一个新规则所约束的正例和反例数目.从最一般前件的规则开始,可选的候选式有如图3派生谓词的激活集扩展归纳学习的搜索步由于规则①覆盖正例〈s3,(fedl6)〉,规则②覆盖正例〈s3,(fedl5)〉,且这两个规则均不覆盖任何下文字(候选文字必须至少包含已有规则中的一个旧变量)及例7中的7个激活集:(faulty?l);not(faulty?l);(ext?l?x?s);not(ext?l?x?s).各个候选式的正例和反例约束数目如图3所示.由图3可以看出,由fed(?l)的激活集F4扩展的搜索步(错误文字(break?y)已被修剪)带来最大的信息增益,因此搜索方向沿着该搜索步进行,直至找出只覆盖正例的规则.同样地,由fed(?l)的激活集F3扩展的搜索步带来的信息增益次之,当仍有正例未被学习到的规则覆盖时,搜索方向沿着该搜索步进行,直至找出只覆盖正例的规则.最后,学习到的派生谓词规则如下:①(breaker?y)∧(closed?y)∧(con?yside2?xside1)∧(ext?l?xside2)∧(ext?l?wside1)∧(not(closed?w))→fed(?l);②(breaker?x)∧(close?x)∧(ext?l?xside2)∧(ext?l?yside1)∧(con?yside2?wside1)∧(not(closed?w))→fed(?l).反例,因此关于谓词fed(?l)的学习过程结束.但是可以看到,学习到的规则前件只包含基本谓词,使得Page11规则过于冗长.因此,更进一步的工作可以根据初始领域理论所包含的谓词依赖关系,引入中间派生谓词对学习到的规则集进行调整,使其包含可能的层次结构.5实验与分析为了验证学习算法FODRL的有效性,基于开放源码的FOIL6.4系统①(C语言编写),我们实现了一个同样称为FODRL的学习程序.该学习程序的输入是规划领域描述(DOMAIN.PDDL)、一组规划问题(PROBLEMS.PDDL)和对应的规划解(PLANS.txt),输出是学习到的规则集(RULES.txt).本文的实验工作包括以下两个方面:(1)初始领域理论对于学习到的规则的精确度的影响;(2)四类领域理论错误分别对规则精确度的影响.测试数据来自于国际规划大赛IPC’04上的两个包含派生谓词的竞赛领域②:PSR(处理供电系统的重新配置问题)和PROMELA(处理通信协议的错误检测问题).5.1初始领域理论对规则精确度的影响为了考察初始领域理论对学习到的规则的精确度的影响,我们将FODRL与FOIL、FOCL进行比较.FOIL是不能处理初始领域理论的纯归纳学习系统,而FODRL和FOCL都是能够接受初始领域理论的分析与归纳结合的学习系统,但是FOCL不能处理递归规则.由于两个测试领域都包含递归规则,因此这里FOCL只能作为纯归纳系统来学习规则.FODRL(FODRL1.0版本)和FOIL(FOIL6.4版本)的实验环境均为CPU(PentiumProcessor1.33GHz)+RAM(384MB)+FreeBSD6.2+gcc4.3.0,FOCL(FOCL-1-2-3版本③)的实验环境为CPU(Intelceleron2.6GHz)+RAM(1GB)+Win-dow2000+GNUCommonLisp-2.6.1.要说明的是,FODRL系统要将GTE算法产生的〈状态-派生事实〉序对形式的训练例转化为FOIL系统的关系元组形式的训练例.转化方法是:每个谓词(即关系)增加一个状态参数,每个谓词的实例(即在某个状态下成立的命题)增加一个状态标签.这样可以把在不同状态下成立的相同的谓词实例转化为关系元组形式的训练例.学习过程采用k次交叉-验证法,即训练样例分为k个子集,k-1个子集用于学习规则,1个子集用于验证规则的精确度,总共进行k次.规则的精确度定义为在验证集上规则能够正确分类的训练例比例.具体地说,当一个正例被规则覆盖或者一个反例不被规则覆盖,均称为规则能够正确分类的情况.当一个反例被规则覆盖或者一个正例不被规则覆盖,则称为规则错误分类的情况.对于表2所示的训练集,FODRL(包含表1的初始领域理论)、FOIL及FOCL学习到的规则集如表3所示.在表3中,要说明的是,FOIL没有输出派生谓词affected的规则,是因为所有候选式产生的规则在训练集上的精确度过低④而使得学习过程终止.另外,没有学习到affected的规则,但是af-fected又作为fed的条件出现,这是明显的不完备的领域理论.在FODRL学习到的规则中,{breaker(A,C),ext(A,B,C,D)}是谓词fed的一阶激活集所产生的候选式,可以看到初始领域理论对规则的学习过程的引导作用.如果初始领域理论的精确度不差的话,由它引导学习到的规则更具有一般性.最后,FOCL学习到关于谓词fed的规则实际上包含错误,因为?0和?3是不同的状态变量.另外,FOCL的两个异常现象是:(1)会存储学习到的针对某个领域的最佳规则,如果在新的训练集上学不到更好的规则,则会输出保存的最佳规则;(2)另外,对于本文的学习问题,即使增加的是非递归的初始领域理论,也学不到规则.可能是本文学习问题的初始领域理论导致FOCL的搜索空间迅猛增大而超出其限制,更准确的原因有待于进一步的代码分析.表3FODRL、FOIL、FOCL3个系统学习到的规则集系统FODRLaffected(A,B)closed(A,B).FOILfed(A,B)not(affected(A,C)),ext(A,B,C,D).FOCLfed(A,B)breaker(A,C),ext(A,B,C,D),closed(A,C).为了比较在不同的训练集上学习到的规则的精确度,我们选取PSR-Middle-ADLDerived版本下的5个规划问题(P01.PDDL~P05.PDDL)及其规划解(LPG-td规划系统在IPC’04比赛中得到的规划①②③④Page12解)来分别构造训练例.学习过程采用3次交叉-验证法.3个系统学习到的规则精确度见图4.图4FODRL、FOIL、FOCL学习到的规则精确度在图4中,可以看到3个系统在不同的训练集上学习到的规则的精确度均有所差异.FODRL学习到的规则的精确度最高,平均值在0.6~0.7之间.大部分规则条件中都包含激活集文字,较好地拟合了初始领域理论.将每组学习到的规则在要学习的谓词的所有训练例上进行验证,选择精确度最高的一组规则作为PSR领域的最后学习到的领域理论.FOCL学习到的规则的精确度次之,平均值在0.5~0.6之间,但是很多规则中都包含上述所说的错误(状态参数不同),因而在语义上很难解释.FOIL学习到的规则的精确度最低,平均值在0.3~0.45之间.在大部分测试组中都学不到派生谓词affected的规则,因此整体规则精确度降低了.此外,由于FODRL和FOCL均接受初始领域理论,为了实验比较的全面性,我们在一个简单的包含非递归初始规则的实验领域上比较这两个混合学习算法的性能.该实验领域是学习谓词member的定义规则.目标谓词member(A,B)表示元素A是表B的成员,可用的背景谓词是component(C,D,E),表示表C是由表头元素D和表尾E组成的.为方便操作,训练例随机产生,训练集由相同数目的谓词的正例和反例组成,其中member的1/4的训练例做为验证集.构造2个不完美的初始领域理论如下:(1)member(A,B)components(B,A,C).(2)member(A,B)components(B,C,D).这两个初始规则集均不包含递归规则.其中,第1个规则集是正确的,但是不完备的.例如,它不能解释member(2,[1,2])是正例.第2个规则集既不正确也不完备.例如,它把member(3,[1,2])错误地解释为正例.在这两个不完美的初始领域理论下,对不同的训练集规模,FODRL和FOCL两个系统分别学习的效果见图5.图5FOCL和FODRL在非递归的初始领域从图5的上/下图可以看到:首先,随着训练例的增多,两个系统的学习精度均逐步提高.在训练集规模达到120时,两个系统的学习精度都达到了95%.其次,在学习目标谓词member的规则时,尽管预先定义了不同的初始领域理论,两个系统的学习性能大致相同,学习精度的差别不超过10%.这表明FOCL和FODRL在简单的包含非递归初始规则的领域上的学习性能是相当的,这来自于它们均采用FOIL的基本学习算法以及对非递归规则进行替换的简单处理方法.5.2领域理论错误对规则精确度的影响下面考察在给定训练集的情况下,分别包含四类错误的初始领域理论对FODRL学习规则的影响.从已发布的竞赛问题描述中构造不完美的领域理论,即产生各类错误.“多余规则”类错误(简记为+rule)的产生可以从谓词集中任意选取多个关联文字的合取来构成某个派生谓词的规则前件.直接去掉某个原有规则可以产生“缺少规则”类错误(简记为-rule).从谓词集中选取某个不在规则条件中的谓词加入到规则条件中产生“多余的规则条件”类错误(简记为+literal).从规则中直接删除某个原有的规则条件产生“缺少的规则条件”类错误(简记为-literal).如前,FODRL的实验环境为CPU(PentiumProcessor1.33GHz)+RAM(384M)+FreeBSD6.2+gcc4.3.0.分别选取PSR-Middle-ADL-Derived领域的一个规划问题(P01.PDDL)和PROMELA-Optical-ADLDerived领域的一个规划Page13问题(P01_OPT2.PDDL)及各自对应的规划解来产生训练集.学习过程采用训练-验证法,2/3的训练例用于学习规则,1/3的训练例用于验证规则的精确度.在构造领域错误时,对给定的某类错误的数目,分别生成3组测试数据,每组测试数据是随机构成的包含该类错误数目的初始领域理论.例如,在生成包含2个-literal类错误时,通过3次随机删除规则条件部分的两个文字而得到3组测试数据.3组测试数据上学习到的规则精确度的平均值作为包含该类错误数目的平均规则精确度.FODRL的学习结果见图6.因为完整的PSR和PROMELA领域描述都包含4条派生谓词规则,因此-rule类错误的最大错误数为4.从图6中可以看到,在两个领域,-literal类错误对规则精确度的影响最小,是最容易容忍的领域错误,+rule类错误其次.这是因为缺少的规则条件可以通过归纳学习过程来进行补足,多余的规则不会带来较大的信息增益,也容易被候选式选择函数所抛弃.相比较而言,在PSR领域,+literal类错误是最不能容忍的错误,这类错误极大地降低了规则精确度.这是因为在派生谓词的激活集用于候选式的时候,要对其中的每个文字进行剪枝(如果去除该文字能带来更大的信息增益则该文字应该被剪枝),但某些无用的文字并不减少信息增益而被保留.当这些文字不能拟合验证集时,则降低了规则精确度.在PROMELA领域,-rule类错误是最不能容忍的错误,这是因为要学习规则的派生谓词只有1个(PSR领域是2个),中间谓词相对较多且谓词之间依赖关系比较复杂,因而减少其中的初始规则对于学习到的规则的精确度影响较大.6结语学习和规划结合是智能规划研究领域中的热点问题.与以往学习动作模型、学习控制知识等研究工作不同,本文是最早的学习派生谓词规则的研究工作.为了自动获取派生规划问题的领域理论,本文提出了从规划解中学习一阶派生谓词规则的FODRL算法.学习过程分为两个步骤:首先根据派生谓词的语义从规划解中提取学习过程所需要的训练例,然后在初始领域理论的引导下学习能够最好拟合训练例的一阶规则集合.本文的主要创新点在于结合分析学习和归纳学习各自的优点来学习派生谓词规则.首先,规划解不能够直接作为学习问题的训练例,需要结合动作模型和规划问题描述来从规划解中提取谓词的训练例集合.其次,提出了一阶规则图和一阶激活集的概念,并且给出在层次受限的一阶规则图上计算派生谓词的一阶激活集的算法.激活集用于扩展搜索步,使得一次可以试探多个文字.接着,实现了学习系统FODRL,实验结果表明,在初始领域理论的引导下FODRL学习到的规则精确度比纯归纳学习系统FOIL及组合学习系统FOCL的更高.最后,讨论了各类领域理论错误对学习到的规则精确度的影响.本文迈出了学习派生谓词规则的第一步,然而在提出的方法中还有一些不足需要在未来的工作中克服.首先,学习到的规则前件中只包含基本谓词,需要制定相关的策略调整规则结构,使其包含中间派生谓词且增加层次结构.其次,在现实的规划执行的环境中存在着各种不稳定的因素,因此学习概率性的规则是很有意义的.
