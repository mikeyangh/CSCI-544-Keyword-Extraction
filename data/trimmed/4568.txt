Page1基于懒符号执行的软件脆弱性路径求解算法秦晓军周林陈左宁甘水滔(江南计算技术研究所江苏无锡214083)摘要为了解决软件测试中路径爆炸、新路径发现率低以及静态分析中虚报率高等问题,提出了动静态分析结合的脆弱性挖掘框架,并针对循环爆炸问题设计了基于懒符号执行的路径求解算法,该路径求解算法应用最短路径、条件约束集概率和可达路径数量3种静态信息制导符号执行,提高了路径选择的准确率,能较快地逼近脆弱点,并利用懒符号执行技术自动识别循环结构,通过推迟变量实例化等方法,有效地缓解了循环结构的路径组合爆炸问题,最终生成到达脆弱点集的数据包.对coreutils6.10命令包的实验结果表明,与现有的方法KLEE、Otter和SAGE相比,该文提出的方法可以有效地对具有较多分支的程序进行分析,当测试程序越大其优势越明显.关键词软件脆弱性;静态分析;懒符号执行;条件约束集概率1引言动态分析方法和静态分析方法是目前软件脆弱Page2弱点的路径,误报率很高.另一方面,静态分析方法不具备脆弱点的自动验证能力,大部分情况下需要依赖于人工分析确认并构造触发数据,不但费时费力,而且并不能保证准确率.动态分析方法的基本思路是利用测试用例动态执行程序中的每个分支,通过收集路径信息挖掘程序脆弱性,具有较高的准确率,目前主要分为模糊测试和污点分析/符号执行两种思路.动态分析方法的主要障碍在于测试效率不高,虽然研究人员对之进行了各种改进[1-4],但动态分析方法始终面临如何提高执行路径覆盖率和解决路径爆炸等问题,所需时间复杂度和空间复杂度往往与被检测的程序代码量呈指数增长的关系,对于较大规模的软件显得力不从心.动态测试和静态分析在很大程度上具有互补性.对前者而言,只有能覆盖脆弱性所在语句的测试输入才是有意义的,如能获取程序中潜在脆弱点的类型和位置,就能在不损害脆弱性发现能力的前提下,通过避免生成和执行无效的输入来降低测试开销.而静态分析方法虽然误报率高,但能提取程序中潜在脆弱语句的位置和类型信息,如果能有效地利用静态分析的结果来指导动态测试,将带来两个方面的优势:一方面,静态分析过程能提供目标脆弱点集和附加的信息,提高动态测试的针对性和有效性,另一方面,动态测试能更准确地验证脆弱点是否真正存在并有效定位,弥补静态测试方法虚报率过高的缺陷.针对上述现状,本文设计了一种动静态分析结合的脆弱性挖掘框架,先通过静态分析获取疑似脆弱点集,再计算能到达疑似脆弱点集的可达数据包,如果有解,则确认了该脆弱点的可触发性,同时自动生成了可触发该脆弱点的输入数据,如图1所示.基于该框架,本文提出了基于脆弱点集制导的可达数据包计算模型VTsolver,该模型结合动态符号执行和静态分析的优点,实现计算脆弱点可达数据包的自动化.VTsolver模型包含了本文提出的懒符号执行、约束条件集概率指导等方法,能够有效地缓解路径爆炸、虚报率过高等问题.其基本思想是:先通过静态分析获取疑似脆弱点集,并计算提取路径概率、路径长度和可达路径数量等指导性参数,然后利用可达数据包计算技术获得能到达脆弱点的数据包,在可达数据包计算过程中,之前提取的路径概率、路径长度和可达路径数量等信息用于反馈指导路径搜索.对符号执行过程中的循环组合爆炸问题,VTsolver模型提出的懒符号执行的思想予以有效缓解.VTsolver模型在进行动态符号执行的同时搜集执行路径对应的路径约束条件,当确定到达脆弱点后,通过求取对应执行路径的路径条件,可以得到该执行路径上的脆弱点数据包.本文第2节介绍目前国内外在脆弱点可达数据包计算技术方面的相关工作;第3节详细描述基于懒符号执行的路径求解算法;第4节通过实验将基于懒符号执行的路径求解算法与目前比较主流的符号执行工具KLEE,Otter,SAGE进行了性能比较;第5节对全文进行总结.2相关工作基于制导的脆弱点可达数据包计算技术是最近几年才发展起来的软件脆弱性分析技术.早期研究人员在模糊测试中引入制导思想,用来排除无用路径,解决覆盖率问题[1,5-6].符号执行技术取得进步之后,制导检测思想应用到符号执行中用于计算能够到达脆弱点的数据包,以提高路径搜索的准确性.2011年崔展齐等人[7]提出了一种目标制导的混合执行测试方法,利用目标脆弱点的可达性静态信息来指导符号执行.同年Ma等人[8]提出了3种脆弱点可达数据包计算算法:最短距离符号执行(Shortest-DistanceSymbolicExecution,SDSE),调用链后向符号执行(Call-Chain-BackwardSymbolicExecution,CCBSE)和混合调用链后向符号执行(MixedCall-Chain-BackwardSymbolicExecution,Mix-CCBSE).SDSE、CCBSE和Mix-CCBSE这3种算法在路径选择策略时利用的都是最短路径优先思想,其中,SDSE算法是利用当前节点和脆弱点之间的最短路径,CCBSE利用的是当前节点和程序执行入口点之间的最短路径,Mix-CCBSE利用的是两个当前节点Page3(初始的两个当前节点分别是程序入口和目标脆弱点)之间的最短路径.上述算法的主要问题在于,如果利用最短路径选择策略导向的后续搜索中约束集不可解或路径不可达,则符号执行引擎将浪费大量时间在无效的路径上.2012年Chen等人[9]利用动态符号执行得到的控制流图信息,采用带有限状态机的扩展程序行为模型(ExtendedProgramBehaviormodelwithFinite-StateMachinecontrolledparameters,EPBFSM)指导模糊测试的执行路径.同年Pak[10]做了类似工作,但其对非线性约束不能很好处理,不能准确产生非线性约束中符号变量的范围值,另外由于要处理模糊测试和符号执行的衔接,因此效率不高,内存消耗较大.目前的符号执行方法还存在一个共同的问题,即遇到多重循环代码时,会遭遇严重的路径组合爆炸,并有很大可能漏报循环内的越界脆弱性,当前循环难题已作为符号执行研究中亟待解决的挑战性问题被提出,本文提出的懒符号执行方法较好地缓解了该问题.3VTsolver模型目标制导的符号执行方法主要解决的问题是:在给定脆弱点位置的条件下,如何找到一条可达路径触发给定脆弱点并得到相应的测试数据包.程序的执行可以用状态进行描述,脆弱点的可达性可以通过检查当前状态是否满足特定的性质来进行判断.利用符号执行引擎,目标制导的符号执行技术能较好地解决脆弱点可达数据包的计算问题.符号执行引擎是VTsolver模型中的一个完备执行系统,只要是它能执行的路径都等价于数据包可达.符号执行引擎同时使用具体参数和符号参数驱动程序运行,符号参数可以对基本数据类型,字符串等进行抽象.当符号执行引擎执行时遇到符号化的条件语句时,将调用可满足性模理论(SatisfiabilityModuloTheories,SMT)求解器STP(SimpleTheoremProver)对搜集到的约束集进行求解,判断分支是否可达,以及有多少分支是可达的,如果有多条路径可达,则需要把这些状态保留下来,用于路径的遍历.VTsolver模型应用最短路径、条件约束集概率和可达路径数量3种关键静态信息制导符号执行,提高了路径选择的准确性,能较快的到达脆弱点,并得到相应的数据包.特别地,针对目前循环体符号执行时间开销过大的问题,VTsolver提出了一种懒符号执行方法,在“必要时”才对循环体进行符号执行,极大减少了无效的符号执行运算开销.懒符号执行方法主要包含基于懒符号执行的前向路径求解算法(FrontwardtracesolvealgorithmbasedonLazySymbolicExecution,FLSE),基于懒符号执行的后向路径求解算法(BackwardtracesolvealgorithmbasedonLazySymbolicExecution,BLSE),基于懒符号执行的混合路径求解算法(HybridtracesolvealgorithmbasedonLazySymbolicExecution,HLSE).3.1基本定义定义1(节点距离).过程间控制流图(Inter-proceduralControlFlowGraph,ICFG)中从当前结点到脆弱点路径内的边数目,称为当前结点和脆弱点之间的距离.定义2(节点可达性).对于ICFG中任意两节点n1与nk,满足可达条件当且仅当:对于i,0<i<k,ni∈D-Pred(ni+1),存在一条路径path=〈n1,n2,…,nk〉,其中D-Pred(ni+1)表示节点ni+1的直接前驱集合.定义3(条件约束集概率).条件约束集概率定义为条件约束集的解集数量与解集空间基数的比率.3.2模型框架VTsolver模型的基本流程如图2所示.Page4不管是高级语言还是二进制语言,都会隐含各种类型和内存访问等信息,有些情况下存在二义性,如C语言中指针与数组的定义,形式上可能完全相同,但具有不同的内存访问模式.二义性的存在使代码不够直观,不便于自动化分析,需要转换成中间语言,并且转换后的中间语言不能丢失源语言中的类型等重要信息.本文使用CIL中间语言,CIL是一种源到源(可逆)的中间语言,比较适合源代码分析.第1步.先将程序代码转换成中间语言代码CIL表示形式,转换前疑似脆弱点集在程序代码中已经被标记;第2步.在转换后的CIL中间语言表示的基础上提取条件约束集概率、路径长度和路径数量等静态信息;图3VTsolver模型的功能模块划分前端的脆弱点集标记模块将脆弱点集在程序中标记出来作为后端静态分析和懒符号执行等模块的基本输入.CIL中间语言转换模块将目标源代码转换为CIL中间语言,后端执行均基于CIL中间语言进行,这样不仅提高了模型的扩展能力,并且能够实现对多种程序设计语言的支持.CIL左值表达式通过〈内存地址,对象类型〉二元属性组来进行表示,而高级语言中只用〈内存地址〉表示左值表达式,导致同一个语句会产生二义性,CIL中间语言可以消除这种二义性.VTsolver模型后端的路径调度模块主要综合3种决策因素对路径进行决策,并把下一条要执行的路径信息传递给懒符号执行模块.懒符号执行模块是VTsolver模型的核心模块之一,主要包括3个功能:(1)循环结构判断.对需要进行懒符号执行的语句或过程进行判断,由于循环结构尤其是多层循环是影响符号执行效率的重要因素[11],为了简化其第3步.初始化懒符号执行调度器,并输入条件约束集概率,路径长度和路径数量3种调度因素,调度器开始工作并根据调度策略选择分支路径供懒符号执行引擎执行;第4步.懒符号执行引擎执行路径并搜集路径对应的约束条件;第5步.利用符号约束求解器求解约束条件得到可达数据包.VTsolver的功能模块划分如图3所示,整个模型可以分为前端和后端两个部分,前端主要由脆弱点集标记模块和CIL中间语言转换模块组成.后端主要由路径调度(路径策略选择)模块、懒符号执行模块(LazySymbolicExecution,LSE)、静态分析模块和STP符号约束条件求解模块组成.中的判断规则,懒符号执行只对涉及符号实例化的循环结构进行处理;(2)符号执行.对确定的语句进行符号执行,其中包括实例化的具体程序执行和符号化的程序模拟执行;(3)路径约束条件管理.通过将新收集的符号约束加入到已有的符号约束集,将得到与输入相关的新变量以及关系表达式,同时将懒符号执行中自主选择的新路径反馈给路径调度模块.FLSE算法、BLSE算法和HLSE算法在以上所描述的功能模块基础上进行实现,其不同之处体现在符号执行的方向和策略上,FLSE算法是从程序的执行入口点开始搜索脆弱点,最后搜索到整条执行路径.BLSE算法是从脆弱点位置开始搜索直到达程序执行入口,逆向得到整条执行路径,HLSE算法是从程序入口点和脆弱点同时开始并行搜索,最后把前段和后段相连得到整条执行路径.由于懒符号执行算法和条件约束集概率计算是Page5FLSE算法、BLSE算法和HLSE算法的重要子算法,下面先介绍懒符号执行算法和条件约束集概率计算,然后再介绍FLSE算法、BLSE算法和HLSE算法.3.3懒符号执行算法懒符号执行算法的基本思想是当符号执行引擎遇到循环分支或多重循环分支时,将循环变量符号化,推迟符号变量的实例化,即:先对循环体进行符号执行,再根据分支条件与循环变量、符号变量的关系回溯执行循环结构,否则按原有序列执行.将循环计数变量符号化,而不是按照通常的做法实例化循环计数变量并执行循环结构体,这种处理方法能够避免大量循环分支路径的产生,另一方面,通过对循环结构体的考察能更加精确地求解出循环计数变量的可解范围,从而指导符号执行的路径选择,使得执行更加有效.在进行懒符号执行之前,相关静态信息已经计算完成,比如可达性信息,因此在描述算法时不再赘述静态分析方面的行为.懒符号执行过程如算法1和算法2.算法1.懒符号执行算法LazySymbolicExecute.输入:l:表示第l行语句输出:δ:新路径条件约束集1.while~branch(l)do//判定是否是分支2.m←m∪m(v,e)/其中v,e为l中的变量,v为3.l←next(l)//读下一条语句4.endwhile5.if~isloop(l)then//判断是否是循环语句6.c←m(cond(l))7.ifSAT(δ∧c)then/SAT为约束求解判定器/8./如有解则符号执行语句l,否则符号执LazySymbolicExecute(target(l),δ∧c,m)9.elseifSAT(δ∧~c)then10.LazySymbolicExecute(next(l),δ∧~c,m)11.ENDIF12.ELSE13.//是循环语句,调用懒符号执行引擎函数LazySymbolicEngine(l,δ,m)14.LazySymbolicExecute(next(l),δ∧~c,m)15.ENDIF算法2.循环体执行算法LazySymbolicEngine.输入:l:表示第l行语句输出:δ:新路径条件约束集1.symbolic(i)//将循环变量i符号化2.ifisloop_end(l)then//判断是否循环结构结束3.RETURNδ//返回更新后的约束集4.ELSE5.LazySymbolicExecute(target(l),δ∧c,m)6.ENDIFl表示第l行语句,δ表示路径条件约束集合,m表示关于符号变量的映射集合,branch(l)判断l是否是分支语句,对顺序执行语句l:v=e,next(l)表示下一条执行语句,m(v,e)表示新发现的映射关系.对分支语句l,target(l)表示跳转的目标语句,isloop(l)判断l是否是循环语句,cond(l)表示语句l中的约束条件,c为临时变量,保存cond(l)的值,LazySymbolicEngine对循环结构进行懒符号执行.isloop_end(l)表示判断语句l是否为循环体结束.算法1中第1~4行判断当前执行的语句是否为分支语句并更新符号变量映射,第5~12行判断分支语句是否为循环语句,如果是循环语句,则进行懒符号执行;否则搜集约束条件,并利用SAT求解器来判断路径是否可行,第13行表示搜集关于循环变量的可解约束条件.第14行执行循环结构.算法2表示对循环结构体进行符号执行.第1行对循环变量i进行符号化,第2行判断是否是循环结构体结束,如果是循环结构体结束,则返回包含关于i的约束集δ,第5行搜集结构体约束信息.懒符号执行可以有效解决执行循环的盲目性问题.例如考察以下一段代码:1.symbolic(m);//变量m符号化2.symbolic(n);//变量n符号化3.for(i=0;i<MAXLOOPNUM1;i++)4.{5.for(j=0;j<MAXLOOPNUM2;j++)6.{7.statementm(m,i,j);//变量m的赋值依赖i,j8.statementn(n,i,j);//变量n的赋值依赖i,j9.…10.if(condition(m,n))//条件分支11.g(m,n);12.…13.}14.}Page6第1、2行代码标记变量m、n为符号变量,第7、8行代码说明m、n的值由i、j决定,对符号变量m、n赋值实例化后,调用函数g(m,n).如函数g(m,n)可到达脆弱点,一般的符号执行算法将i,j实例化并进入到循环结构体进行执行,当遇到第10行时,如果不满足条件则返回继续尝试新的循环值.懒符号执行算法则先符号执行g(m,n),确定可到达脆弱点的m、n的约束条件,然后根据第7、8行列出m、n和i、j的函数关系确定i、j的约束条件.这样避免了对i、j的进行盲目的符号执行,极大地提高了符号执行的效率.动态符号执行在一定程度上解决了缺乏测试用例集的问题,但由于该方法从程序本身出发,未将目标脆弱性的先验知识作为指导,导致生成和执行了大量无效(不能覆盖脆弱性语句)的测试输入,浪费了时间和计算资源.另外,符号执行在执行多重循环程序时,会遭遇严重的路径组合爆炸问题,懒符号执行通过推迟循环符号变量的实例化,先对循环结构内的语句进行符号执行,反推可到达脆弱点的条件,然后根据可达性条件有选择地进行符号执行,较好地克服了这个问题.3.4约束条件集概率在进行符号执行时,除收集约束条件,还需要收集约束条件集概率,约束条件集概率描述的是约束条件集可解的概率有多大,约束条件集和执行路径是一一对应的,因此将其作为路径选择的一个因素可以使得所选择的路径更加合理.本文通过算法probSymCalculate(l,ψ,m,p)来求取约束条件集概率,其中l表示代码所在行数,ψ表示当前收集到的条件约束集,m表示关于符号变量的映射集合,p表示ψ约束集概率.算法probSymCalculate(l,ψ,m,p)的具体描述见算法3.算法3.约束条件集概率求解算法probSym-Calculate(l,ψ,m,p).输入:l:表示第l行语句输出:p:约束条件集概率1.while~branch(l)do2.m←m(v,e)3.l←next(l)//读下一条语句4.endwhile5.c←m(cond(l))6.ψ←relation(ψ,c)7.pc←prob(ψ∧c)/prob(ψ)8.probSymCalculate(target(l),ψ∧c,m,ppc)9.probSymCalculate(next(l),ψ∧~c,m,p(1-pc))relation(ψ,c)表示抽取ψ中与c相关的条件约束ψ,设ψ中与c独立的条件约束为珔独立,c与珔句,需要提取约束条件,并更新约束集ψ,约束集ψ∧c的概率可以通过条件概率来进行计算:Prob(ψ∧c)=Prob(ψ)Prob(c|ψ)因为ψ=ψ∧珔因为Prob(ψ∧珔约束集ψ∧~c的概率可以通过条件概率来进行计算:Prob(ψ∧~c)本文使用LattE①对约束概率进行求解,LattE接受“=”和“”表达式,“”和“>”表达式可以通过乘以-1转换为“<”和“”表达式,“<”可以通过减去一个常数来转换成“”表达式,不直接支持“≠”表达式.约束条件集概率通过对单个约束条件概率的计算获得,求取单个约束条件概率的算法见算法4.算法4.单个约束条件概率求解算法.probConditons(ψψ1∧ψ2∧…∧ψn).输入:ψi:约束条件输出:p:新路径条件约束集1.ConSet←{ψ1,ψ2,…,ψn};2.Vars←{var|con∈ConSet∧var∈con};3.neqConSet←{con|con∈ConSet∧con≠relation};①UCDavis,Mathematics.Latteintegrale.http://www.Page74.lgeConSet←Conset-neqConSet;5.unSet←{lgeConSet∧var=6.num←num∧(∧lgeConSet)-num∨(∨unConSet);7.p←pnum∏var∈Vars为了让LattE支持“≠”表达式,首先将约束条件集ConSet分解为两个集合,一个是不含“≠”的表达式集合lgeConSet,另一个是含“≠”的表达式集合neqConSet.unSet集合为满足lgeConSet条件约束,但是不满足neqConSet条件约束的约束集.考虑到unSet集合中元素之间的相关性问题,根据容斥原理,约束条件集解的数量num∨(∨unSet)计算公式如下:num∨(∨unSet)=∑其中unSet表示unSet的幂集,#θ表示集合θ的元素数量,num∧(∧θi∈θθi)表示∧θi∈θθi解的数量.3.5基于懒符号执行的路径求解算法3.5.1基于懒符号执行的前向路径求解算法SDSE,Klee等系统利用优先执行最短路径策略来进行脆弱点位置的前向搜索,执行的策略只以当前信息即最短路径作为唯一决策因素,没有考虑约束集概率和后续路径数量等关键因素,决策因素过于简单,因此当最短路径对应的约束集无解时,算法必须回溯到上一个分支节点,否则浪费太多时间在无解的路径上.基于懒符号执行的前向路径求解算法(FLSE)是一种综合考虑了最短路径、约束概率和可达路径数量3种关键因素对下一条执行路径进行选择,并对选择路径进行懒符号执行的目标制导脆弱点可达数据包计算法.FLSE算法在决策出下一条执行分支后,会先判断下一条执行分支是否是循环分支,如果不是循环分支则进行正常的符号执行,如果是循环分支则提取循环条件,将循环控制变量符号化,对循环结构体进行符号执行,对循环结构体进行切片和数据流分析,变量的依赖关系,活性分析,循环分支之间的独立性等性质,得到关于循环控制变量的约束信息.FLSE算法描述如算法5.算法5.FLSE算法FLSESymbolicExecute.输入:vulset:脆弱点集输出:vulcase:到达脆弱点集的数据包1.initial(tasklist,vulset,main)2.probSymCalculate(l,ψ,m,p)3.while(tasklist!=NULL)4.l=select(tasklist)5.LazySymbolicExecute(l,δ,m)6.endwhile其中initial(tasklist,vulset,main)表示对符号执行引擎进行初始化,将初始的执行状态添加到tasklist中,probSymCalculate(l,ψ,m,p)计算约束条件集概率,select(tasklist)选取一个任务状态l,LazySym-bolicExecute(l,δ,m)对l进行懒符号执行.FLSE算法一方面通过提前确定和求解多个执行分支,减少了不必要的回溯,不需要在一个过程内反复的修正约束条件集,解决了符号变量受父节点控制时所带来的过程内约束条件集无法修正的问题.FLSE算法通过提前求解若干节点,利用后续节点的分支信息,有效地提高了符号执行的效率.另一方面,一次符号执行跨越多个节点,得到更多关于循环符号变量的信息,减少了循环分支数量,从而减少了影子内存的数量,有效地缓解了符号执行的状态数量爆炸问题.3.5.2基于懒符号执行的后向路径求解算法CCBSE算法与SDSE算法类似,利用优先执行最短路径策略来进行脆弱点位置的后向搜索,执行的策略也只以当前信息即最短路径作为唯一决策因素,没有考虑约束集的求解概率和前续路径数量等关键因素,决策因素过于简单.而且CCBSE算法每步只执行一个分支,没有充分利用后续分支进行综合决策.基于懒符号执行的后向路径求解算法(BLSE)从脆弱点所在函数开始,通过一次多步逆向追溯的方法搜索整个执行路径,BLSE对下一条执行路径进行选择时综合考虑了最短路径、约束集概率和可达路径数量3种关键因素,有效地提高了路径搜索效率.其算法描述如算法6.算法6.BLSE算法BLSESymbolicExecute.输入:vulset:脆弱点集输出:vulcase:到达脆弱点集的数据包1.initial(tasklist,vulset,vulfun)2.probSymCalculate(l,ψ,m,p)3.while(tasklist!=NULL)do4.l=select(tasklist)5.LazySymbolicExecute(l,δ,m)6.next_l=CFGBackForward(l)7.add(tasklist,next_l)8.endwhile其中initial(tasklist,vulset,vulfun)表示对符号执Page8行引擎进行初始化,这里与FLSE算法有所不同,FLSE算法是从程序入口点开始进行符号执行的,BLSE算法是从目标脆弱点开始的,vulfun是脆弱点所在函数.probSymCalculate(l,ψ,m,p)计算约束条件集概率,select(tasklist)选取一个任务状态l,LazySymbolicExecute(l,δ,m)对l进行懒符号执行,CFGBackForward(l)选取下次要的执行路径,并通过add(tasklist,next_l)加入到任务列表tasklist中.BLSE算法有两个关键的步骤:(1)在过程间控制流图中找到调用当前函数的调用函数集,并跟设定的策略选择一个较好的调用函数作为下一个符号执行函数;(2)在选定好的调用函数中使用FLSE算法,找到一条较好路径到达目标函数.第一个关键步骤中从调用函数集中选取一个较好的调用函数优先执行,其选取策略包含两个决策因素:调用函数与被测程序入口之间的距离和调用函数与被测程序入口之间路径的数量.如图4所示,BLSE算法先确定脆弱点所在函数vulfun,并利用FLSE算法,找到一条从vulfun函数入口到脆弱点的执行路径(p1,p2,…,pk),并搜集相应的路径约束条件s1,然后在vulfun的直接前驱集D-Pred(vulfun)中,利用决策函数decision(Pathlen,Pathnum)求出直接前驱集D-Pred(vulfun)中各元素的权重值,并优先执行权重最大的直接前驱结点,其中Pathlen表示直接前驱结点到被测函数执行入口之间的距离,Pathnum表示直接前驱结点到被测函数执行入口之间的路径数量.节点距离Pathlen和路径数量Pathnum是预先可以计算的,因此直接前驱权重值decision(Pathlen,Pathnum)也是可以预先计算的,从而不会因为直接前驱权重值decision(Pathlen,Pathnum)的计算而影响整个算法的执行效率,这里没有考虑约束条件概率因素,主要是因为在后向执行路径搜索时,约束条件概率的求取比较复杂,而且效果也不一定好.在决策出下一条执行分支callvulfun2后,利用BLSE算法搜索callvulfun2函数内从callvulfun2函数入口到调用vulfun函数之间的执行路径(pk+1,pk+2,…,pk2),并搜集相应的条件约束s2,同时并不会直接对所得到的条件约束进行求解,而是预先考察下个分支中的分支和分支条件情况,分析下个分支函数入口与调用callvulfun2语句之间的可达性条件,将其加入到约束集中,并进行综合求解,如果调用callvulfun2语句总是可达的,则不需要加入约束集中,简化条件约束求解,提高求解效率.3.5.3基于懒符号执行的混合路径求解算法FLSE算法和BLSE算法都有本身不可避免的不足,FLSE算法适用于前后搜集的路径约束条件信息,基于懒符号执行的混合路径求解算法(HLSE)结合了FLSE算法和BLSE算法的优点,同时从程序入口和脆弱点两个节点同时出发进行条件路径搜索,这样在进行路径选择时,得到的信息更多,选择出来的分支也更加合理.具体算法描述如算法7.算法7.HLSE算法HLSESymbolicExecute.输入:vulset:脆弱点集输出:vulcase:到达脆弱点集的数据包1.initial(ftasklist,vulset,main)2.initial(btasklist,vulset,vulfun)3.probSymCalculate(l,ψ,m,p)4.FLSESymbolicExecute(ftasklist)5.BLSESymbolicExecute(btasklist)其中,ftasklist和btasklist分别为FLSE和BLSE的状态集,initial(ftasklist,vulset,main)表示对ftasklist进行初始化,对main参数和全局变量的符号化,生成初始状态.initial(btasklist,vulset,vulfun)表示对btasklist进行初始化,对脆弱点调用函数的参数和全局变量进行符号化并产生初始状态.probSymCalculate(l,ψ,m,p)计算约束条件集概率,FLSESymbolicExecute(ftasklist)和BLSE-SymbolicExecute(btasklist)分别进行前向懒符号执行和后向懒符号执行.Page94实验与分析本实验的测试对象为以上的3个例子和BUSYBOX1.11.2,测试结果如表1所示.表13种懒符号执行算法与KLEE[12],SAGE[13],测试包killsetuidgid8.47258.5116.1826.743892.1221.63trodchown24.29105.21112.80255.71596.12114.10ls均值164.48233.9855.19116.631438.5361.93以对od命令包的测试为例分析,FLSE,BLSE算法的测试效率最高,HLSE算法的测试效率一般,因为这个程序较为简单,程序分支较少,因此在前向约束条件和后向约束条件联合求解上消耗的时间就显的较为突出.KLEE算法的测试效率较好,KLEE使用的是Round-RobinRP(RadomPath)算法来计算路径末端与脆弱点之前的距离,同时兼顾了覆盖率和路径执行的准确率.Otter采用最短路径的路径选择策略,测试效率较好.SAGE注重提高覆盖率,覆盖每个执行分支,通过块覆盖(blockcoverage)进行启发式选择状态执行,因此把太多的时间浪费在不能到达脆弱点的程序分支上.以对ls命令包的测试为例分析,HLSE测试效率最高,FLSE,BLSE,KLEE,Otter的效率次之,SAGE的效率最差,因为ls程序中无效的分支太多,因此SAGE浪费在这些分支上的时间显得特别表2懒符号执行对coreutil6.10软件包测试的生成结果序号123456789表2中列出了9个命令包的测试结果,有3个指针误用脆弱点,3个栈溢出脆弱点,两个整数溢出突出.从对BUSYBOX中ls,chown,tr,od,kill和setuidgid共6个命令的测试结果数据可以看出,SAGE的性能表现是相对最差的,FLSE在对其中5个命令的测试过程中表现优异,BLSE在对其中4个命令的测试性能较好,但两个算法在对ls命令的测试中出现性能突变,表现不够稳定,HLSE的综合效率是最高的,并且随着被测试代码规模的增大,HLSE算法的优势越来越明显.测试性能比较见图5.图5中纵坐标表示对程序进行测试花费的时间,单位为秒,横坐标表示被测程序的代码规模,单位为行数.从图5中可以看出SAGE在对setuidgid程序包进行测试时效果非常差,因为setuidgid中循环比其它测试数据包多,且不能达到脆弱点的无用路径也较多,SAGE为了提高覆盖率,在遍历这些路径时浪费了太多的时间.最后,VTsolver在针对软件coreutil6.10的脆弱点测试中,快速的生成了9个漏洞可达数据包,其中包括2个(序号2和序号7)未公开漏洞,详细情况见表2."-Z""\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x00""\x32\x20\x20\x20\x20\x20\x20\x20\x20\x20\x00"脆弱点和一个竞争条件脆弱点,其中dir和ls命令的脆弱点已经收录在CVE中.Page105总结脆弱点可达数据包计算是指在进行程序分析时,对于给定的代码脆弱点位置,找到一条可达路径触发给定脆弱点和得到相应可达数据包.程序的执行可以用状态进行描述,脆弱点的可达性可以通过检查当前状态是否满足特定的性质来进行判断.脆弱点可达数据包计算技术应用很广泛,比如一个静态分析的脆弱性测试工具找到了一些脆弱点,但是并不能确定是不是真正的错误,于是需要测试数据包来验证这些脆弱点.在进行软件开发的时候可能会遇到一些断言(assert)报告,但是没有相应的测试数据包,如果开发者对代码不熟悉或者代码量比较大,要找到触发断言的原因是非常困难的,因此需要测试数据包帮助开发者定位错误.符号执行技术非常适合解决脆弱点可达数据包计算问题,符号执行引擎是一个完备的执行系统,只要是它能执行的路径都是可达的.符号执行引擎调用程序运行,同时使用具体参数和符号参数.符号参数可以对基本数据类型,字符串等进行抽象.当符号执行引擎执行时遇到符号化的条件语句时,将调用SMT求解器STP对符号执行引擎搜集到的约束集进行求解,判断分支是否可达,有多少分支是可达的,如果有多条路径可达,则需要把这些状态保留下来,用于路径的遍历.本文提出了基于懒符号执行的前向路径求解算法(FLSE),基于懒符号执行的后向路径求解算法(BLSE)和基于懒符号执行的混合路径求解算法(HLSE),有效地提高了符号执行引擎的执行效率.FLSE算法综合考虑了最短路径、约束概率、可达路径数量3种关键因素,对下一条执行路径进行选择,有效地提高了路径搜索效率.另外FLSE算法在决策出下一条执行分支后,并不会直接对所得到的条件约束进行求解,而是预先考察下个分支中的分支和分支条件情况,如果满足设定的提前策略,能够确定再下个执行分支,则把这个分支对应的条件加入当前约束条件集,同样可以对后面的执行分支实施提前策略,直到遇到不能满足提前策略的结点.BLSE算法从脆弱点所在函数开始,通过一次多步逆向追溯的方法搜索整个执行路径,BLSE综合考虑了最短路径、约束概率、可达路径数量3种关键因素,对下一条执行路径进行选择,以提高路径搜索效率.BLSE算法有两个关键的步骤:(1)在过程间控制流图中找到调用当前函数的调用函数集,并跟设定的策略选择一个较好的调用函数作为下一个符号执行函数;(2)在选定好的调用函数中使用FLSE算法,找到一条较好路径到达目标函数.HLSE算法结合了FLSE算法和BLSE算法的优点,同时从程序入口和脆弱点两个节点同时出发进行条件路径搜索,这样在进行路径选择时,得到的信息更多,选择出来的分支也更加科学.
