Page1云环境中支持隐私保护的可计算加密方法黄汝维1),2)桂小林1)余思1)庄威1)1)(西安交通大学电子与信息工程学院西安710049)2)(广西大学计算机与电子信息学院南宁530004)摘要随着云计算的深入发展,隐私安全成为了云安全的一个关键问题.加密是一种常用的保护敏感数据的方法,但是它不支持有效的数据操作.为了提供云计算环境中的隐私保护,设计了一个基于矩阵和向量运算的可计算加密方案CESVMC.通过运用向量和矩阵的各种运算,CESVMC实现了对数据的加密,并支持对加密字符串的模糊检索和对加密数值数据的加、减、乘、除四种算术运算.安全分析和性能评估证明CESVMC是IND-CCA安全的,并能有效地实现对加密数据的计算.关键词云计算;向量和矩阵;字符串模糊检索;算术运算;可计算加密1引言云计算作为一种新型的网络计算模式,以一种相比传统IT更经济的方式向用户提供按需的IT服务(计算、存储和应用等).由于云计算的发展理念但在已经实现的云计算服务中,隐私安全问题一直令人担忧,并已经成为阻碍云计算发展和推广的主要因素之一.用户的隐私数据包括可用来识别Page2或定位个人的信息(例如电话号码、地址和信用卡号等)、敏感的信息(例如个人的健康状况、财务信息、公司的重要文件等).云计算的隐私安全问题源于云计算的数据外包和服务租赁的特点.用户数据存储到云环境中,人们失去了对数据的直接控制力,可能会导致个人隐私数据的泄露和滥用.而近年来发生的Google、MediaMax和Salesforce.com等云服务商泄露或丢失用户数据的事实证实了人们的担心[1].加密是一种常用的保护用户隐私数据的方法,但目前的大多数加密方案都不支持对密文的运算,如对加密的文件进行模糊检索、对加密的公司财务信息进行统计分析等,因而严重妨碍了云服务商为用户提供更进一步的数据管理和运算服务,从而削弱了云计算的优势.针对上述问题,本文提出了一个基于矩阵和向量运算的可计算加密方案CESVMC(ComputableEncryptionSchemebasedonVectorandMatrixCalculations).CESVMC将云数据分为字符串和数值数据两大类,支持加密字符串的模糊检索和加密数值数据的加、减、乘、除四种基本算术运算,并保证了数据存储、运算过程中的隐私安全性.本文第2节回顾相关研究的进展情况;第3节建立支持隐私保护的云计算模型并定义可计算加密技术;第4节具体介绍CESVMC的设计与实现;第5节和第6节分别就CESVMC的安全性和性能进行评估;第7节做出总结.2相关工作可计算加密技术是一种加密方法,它通过加密保证数据安全,同时加密后的数据能够支持某些计算.目前已有的可计算加密技术可分为两类:支持检索的加密技术和支持运算的加密技术.(1)支持检索的加密技术.Liu等人[2]提出了一种基于对称加密的密文检索方法;Bonech等人[3-5]提出了基于非对称加密的密文检索方法;Bellovin等人[1,6-7]提出了基于BloomFilter的密文检索方法.但这些方法只支持精确的字符串匹配,即两字符串是否相等.然而,在许多实际的情况下,错别字和格式不一致是不可避免的,因此,Li等人[8]设计了一个支持加密字符串模糊检索的方案,它使用编辑距离来量化字符串的相似度,并为每个字符串附加一个基于通配符的模糊字符串组,用多个精确匹配来实现模糊检索.该方法的不足是它不能对满足检索条件的字符串进行相似度排序,而且计算、存储/通信负载很大.对于一个长度为l的字符串,为了能处理d位的错别字和格式不一致,需要进行O(ld)次Hash运算并产生O(ld×160)位的存储/通信负载.Wang等人[9]提出一个基于保序加密技术OPSE[10]的分级字符串检索方案,能够根据某一指标对检索的关键字分级,并按用户的要求返回前N个符合要求的结果.该方案要求数据拥有者在外包文件前对每个文件进行全文扫描,计算出每个关键字在该文件中的出现频率,这对于数据拥有者来说是一件非常麻烦的事情.Hacgümü等人[11]提出了基于同态加密技术的密文聚集查询方案,但是要求数据拥有者自己建立一个加密的索引表.(2)支持运算的加密方法.Agrawal等人[12]提出一个基于桶划分和分布概率映射思想的保序对称加密算法OPES,支持对加密数值数据的各种比较操作.Boldyreva等人[10]提出一个基于折半查找和超几何概率分布的保序对称加密算法OPSE,支持对加密数据的各种比较操作,但是由于在计算超几何概率时需要进行多次组合运算,其计算负载较大.以上两种保序加密算法都是确定性的加密方案,这使得它们不具有语义安全性.Wong等人[13]设计了一个基于向量标量积的对称加密方案,该方案支持对加密数据库进行KNN(k-nearestneighbor)计算.除此之外,目前已有一些同态加密算法,例如unpadded_RSA、ElGamal、Goldwasser-Micali、Benaloh和Paillier等,但它们只支持加法同态和乘法同态运算中的一种.Gentry[14-15]首次设计出了一种基于理想格的全同态加密方案,该方案能同时支持加法和乘法同态.之后,Smart等人[16-17]对Gentry的工作进行了改进.但是目前已有的全同态方案都太复杂且计算量太大,还不适合应用到云计算的环境中.根据以上分析,我们发现:(1)目前还没有一种加密方案能够同时支持字符串的检索和数值数据(包括整数和浮点数)的算术运算;(2)目前对加密字符串的模糊检索还没有一个实际可行的方案;(3)目前还没有一种支持密文运算的方案能轻松地同时解决整数和浮点数的加、减、乘、除法运算;(4)已有的一些方案往往要求数据拥有者在数据外包前做大量的准备工作,这会使用户的使用体验大打折扣.针对以上问题,我们设计了一个支持隐私保护的可计算加密方案CESVMC(ComputableEncryptionSchemebasedonVectorandMatrixCalculations).CESVMC基于向量和矩阵运算,支持对加密字符串的模糊检索和对加密数值数据的加、减、乘、除法运算.Page33问题描述3.1支持隐私保护的云计算模型如图1所示,支持隐私保护的云计算模型反映了数据拥有者(Owner)、用户(User)和服务提供者(ServiceProvider,SP)之间的交互,具体过程如下:(1)Owner用加密算法E对敏感数据di(i∈[1,n],n1)加密得到E(di),然后存储到SP的服务器上;图1支持隐私保护的云计算模型在这个过程中,由于Owner和User分别对敏感的外包数据和计算参数进行了加密处理,使得Owner和User的隐私得到了很好的保护.但同时也带来了一个新的问题:SP如何对加密的数据进行计算呢?如果这个问题不能得到有效的解决,Owner和User就不能利用云计算中的计算资源对敏感数据进行处理,从而削弱了云计算的优势.因此,本文提出的可计算加密方案是解决这一矛盾的关键技术.3.2可计算加密方案的定义Σ=(Gen,Enc,Dec,Cal)由以下4个算法组成:K←Gen(U,d),d为安全参数;(2)加密算法Enc可能为概率算法,D和V分别为该算法的定义域和值域,对于数据m∈D,c←Enc(K,m)且c∈V;(3)解密算法Dec为确定算法,对于密文c,m∪{⊥}←Dec(c,K),⊥表示无解;(4)密文计算算法Cal可能为概率算法,对于密文集合{c1,c2,…,ct},其中ci∈V,Cal(Dec(c1,定义1(可计算加密方案).可计算加密方案(1)密钥生成算法Gen为用户U产生密钥K,(2)User获得Owner的授权后,对敏感计算参数(para)加密得到E(para),并将E(para)和计算要求(type)提交给SP;(3)SP验证User的权限,然后根据User的计算要求,对其权限范围的E(di)和计算参数E(para)进行计算,得到计算结果E(result),并将E(result)返回给User.(4)User对E(result)进行解密,得到结果的明文result.K),Dec(c2,K),…,Dec(ct,K),op)←Dec(Cal(c1,c2,…,ct,op)),op为计算类型(例如模糊匹配、算术运算等),Cal是与Cal对应的对明文数据运算的算法.定义2(正确性).可计算加密方案Σ=(Gen,Enc,Dec,Cal)是正确的:(1)m∈D,Dec(Enc(m,K))=m;(2){m1,m2,…,mt},其中mi∈D,Cal(m1,m2,…,mt,op)=Dec(Cal(Enc(m1,K),Enc(m2,K),…,Enc(mt,K),op)).定义3(安全性).可计算的加密方案Σ=(Gen,Enc,Dec,Cal)是安全的:(1)Σ在提供外包数据的加密Oracle和解密Oracle的情况下是IND-CCA安全的;(2)Σ保证SP在进行Cal运算的过程中不能推断出原始明文、中间或最终结果的任何信息.4可计算的加密方案CESVMC4.1CESVMC定义本节将构造一个基于向量和矩阵运算的可计算Page4加密方案CESVMC.CESVMC在确保Owner和User数据安全的前提下,支持加密字符串的模糊检索和加密数值数据的加、减、乘、除法运算.下面对CESVMC进行定义.定义4(CESVMC).CESVMC=(Gen,Enc,Dec,Cal)由以下4个算法组成:(1)密钥生成算法Gen:{M,W,S}←Gen(n,k),其中n、k分别表示计算元素个数和随机元素个数,且n,k∈N;一个向量犘由计算元素和随机元素组成,假设d表示犘的维数,则有d=n+k;Gen生成的密钥由3部分组成,一个d×d可逆矩阵犕,一个随机数数组W={w1,w2,…,wk-3,wk-2}(k4,wi∈R且i∈[1,k-2])和一个分裂串S={0,1}d组成,分裂串只用于字符串中.(2)加密算法Enc:假设D和V分别为Enc的定义域和值域,对于数据m∈D,犘←Enc(m,犕,W,S,U/O),其中犘为m对应的d维密文向量且犘∈V,U/O表示是数据使用者或数据拥有者,用户身份不同时,加密算法略有不同.(3)解密算法Dec:m←Dec(犘,犕,S,op),其中op是计算类型,当op=“original”时,表示对原始数据的密文进行解密;当op=“add”时,表示对加法运算的结果进行解密;当op=“sub”时,表示对减法运算的结果进行解密;当op=“mul”时,表示对乘法运算的结果进行解密;当op=“div”时,表示对除法运算的结果进行解密.(4)密文计算算法Cal:P←Cal(P1,P2,…,Pt,op),根据计算类型op的不同,对P1,P2,…,Pt(Pi∈V且i∈[1,t],t∈N)进行不同的运算,主要有模糊检索、加法、减法、乘法和除法等运算,P是计算结果的密文且P∈V.4.2算法描述CESVMC将云数据分为字符串和数值数据两类,支持加密字符串的模糊检索和加密数值数据的加、减、乘、除法运算.4.2.1字符串为了更好地设计模糊检索机制,首先观察人们的查询习惯.CESVMC的字符串模糊检索目前主要是针对英文数据,但其原理也可以应用到中文数据的模糊检索中.根据英文单词的构成方式,人们经常认为“cloudy”与“clout”相比,“cloudy”的意思与“cloud”更为相近,因为“cloudy”以“cloud”为前缀,称之为前缀匹配;另外,对于大多数人来说,检索一个单词在一个句子或词组中的情况比该单词是构成另一个单词的一部分更有意义,例如单词“alone”在“bealone”中和它在单词“abalone”中,检索前者比后者更有意义,称之为关键字匹配.因此,对一个字符串进行加密即是要构造它的前缀匹配密文和关键字匹配密文.但在检索的时候,对前缀匹配密文和关键字匹配密文都可以采用前缀匹配的方法进行,从而实现模糊检索.在进行模糊检索时将按照以下规则返回有序的检索结果:(1)与检索参数一样的字符串构成了最匹配的结果集;(2)以检索参数开始的字符串构成了第2匹配的结果集;(3)假设检索参数的字符数为m,前m-1个字符与检索参数一致,但第m个字符与检索参数不一样的字符串构成了第3匹配的结果集,以此类推;(4)在同一个结果集中,字符串与检索参数的第一个不同字符ASCII码值的差越小,它们就越相似.4.2.1.1字符串转换为向量假设有一个字符串np,Owner首先生成np的子串.其基本思想是按照空格将字符串分割,例如,字符串“cloudcomputing”对应的子串分别为“cloud”和“computing”.然后,Owner对np及其子串执行以下操作:假设计算元素组ce由n个元素组成,算法允许的字符串最大长度为len=(n-1)×6,即每6个字符构成一个元素;np的长度为len,则可形成前len/6个元素,后面的(n-len/6)个元素都为0.对于第i个元素,将其中每个字符转换为对应的ASCII码减去23,从而确保了每一个字符都用一个两位数来表示;接着将每个字符的对应两位数连接起来,形成数字vi,再计算vi=vi×10m,其中m=12×(n-i-1).通过以上运算,Owner将字符串np转换为一个(n-1)维的向量狆=(v1,v2,…,vn-1).当len>len时,np可以转换为len/len个(n-1)维向量.由于每个(n-1)维向量的后续操作都是一样的,因此,本文就假设np只转换成了一个(n-1)维向量.当User准备发出检索请求时,也是用同样的方法来转换检索参数.4.2.1.2外包字符串的加、解密假设外包字符串npi对应的(n-1)维向量为狆i.Owner创建一个d维向量狆i=(pi,-0.5×‖pi‖2,r1,w2,…,rk-3,wk-2,-(∑k/2-1其中‖pi‖2是狆i的标量积,rj是随机数且rj∈R.也就是说,计算元素组ce=(狆i,-0.5×‖pi‖2),随机元素组为re=(r1,w2,…,rk-3,wk-2,-(∑k/2-1w2×j-1),1).然后Owner根据分裂串S将pi分割成Page5两个d维子向量狆i1和狆i2:假设S[z]表示分裂串S的第z(z∈N且z∈[1,d])位,如果S[z]为‘0’,则狆i的第z个元素pi[z]分裂为x1和x2,使得pi[z]=x1+x2,分别作为pi1[z]和pi2[z];如果S[z]为‘1’,则pi的第z个元素pi[z]不用分裂,pi1[z]=pi2[z]=pi[z];加密向量狆i1和狆i2得到犘i1=犕×狆i1和犘i2=犕×狆i2,并将犘i=(犘i1,犘i2)存储到SP处.对加密的外包字符串犘i解密是加密算法的逆过程,所以不再详述.4.2.1.3检索参数的加密当User想检索字符串nq时,他首先选择一个随机数r(r>0且r∈R)并根据以上字符串转换方法生成对应的(n-1)维向量狇,然后将狇扩充为一个d维向量狇=r×(狇,1,w1,r2,…,wk-3,rk-2,1,-(∑k/2-1也就是说,计算元素组为ce=(狇,1),随机元素组为re=(w1,r2,…,wk-3,rk-2,1,-(∑k/2-1w2×j)).然后User根据分裂串S将狇分割成两个d维子向量狇1和狇2:如果S[z]为‘1’,则狇的第z个元素q[z]分裂为x1和x2,使得q[z]=x1+x2,分别作为q1[z]和q2[z];如果S[z]为‘0’,则狇的第z个元素q[z]不用分裂,q1[z]=q2[z]=q[z];加密狇1和狇2得到犙1=狇1×(犕-1)和犙2=狇2×(犕-1),并将犙=(犙1,犙2)提交给SP.4.2.1.4加密字符串的检索的Pi进行如下运算:Q×Pi=((q1,q2)×M-1)×(M×(pi1,pi2))=(q1,q2)×M-1×M×(pi1,pi2)=(q1,q2)×(pi1,pi2)=q1×pi1+q2×pi2=r×(q,1,w1,r2,…,wk-3,rk-2,1,当SP接到检索请求时,将对User权限范围内j=1=r×(pi×q-0.5‖pi‖2+∑2k=r×(pi×q-0.5‖pi‖2)然后SP比较结果的值,其值越大,nq与npi越相似.其原因如下:假设犘1和犘2是两个外包字符串np1和np2对应的加密向量,犙是检索参数nq的加密向量:犙×犘1-犙×犘2=r×(p1×q-0.5×‖p1‖2-=r×(p1×q-0.5×‖p1‖2-p2×q+0.5×‖p2‖2-0.5×‖q‖2+0.5×‖q‖2)=-0.5×r×(‖p1‖2-2p1q+‖q‖2)+0.5×r×(‖p2‖2-2p2q+‖q‖2)=0.5×r×[d2(p2,q)-d2(p1,q)](2)其中,d(狆,狇)表示向量狆和狇的欧几里得距离.由式(2)得因为d(pi,q)0且r∈R+所以犙×犘1-犙×犘2=0.5×r×(d2(狆2,狇)-d2(狆1,狇))>0d(狆2,狇)>d(狆1,狇)(3)所以SP可以通过对Pi和Q的标量积进行从大到小的排序从而得到一个按相似度由高到低排列的序列,从而实现了模糊检索.4.2.2数值数据对数值数据的操作可以简单地分为4种基本算术运算:加法、减法、乘法和除法.为了实现加/减法和乘/除法,计算元素组ce由加法因子addF和乘法因子mulF组成,其中addF由da(da∈N且da>3)个元素组成,mulF由dm(dm∈N且dm2)个元素组成.也就是说,ce=(addF,mulF)且n=da+dm.4.2.2.1数值数据的转换和加、解密转换一个数值数据np为d维向量的过程可以分为以下4步:首先,选择(da-1)个随机数{ar1,ar2,…,arda-1}(ari∈R且i∈[1,da-1]),并计算arda=np-∑da-1(ar1,ar2,…,arda)T;再生成da个随机数{cr1,cr2,…,crda}(cri∈R且i∈[1,da]),使狆变为狆=(ar1+cr1,ar2+cr2,…,arda+crda)T.然后,随机选择(dm-1)个随机数{mr1,mr2,…,mrdm-1}(mri∈R且mri的倒数都是有限小数,i∈[1,dm-1]),计算mrdm=np∏dm-1(da+dm)维的向量狆=(ar1+cr1,ar2+cr2,…,arda+crda,mr1,mr2,…,mrdm)T.第3步,Owner通过加入随机元素组re扩充狆从而构成了一个(da+dm+k)维的向量狆=(ar1+cr1,ar2+cr2,…,arda+crda,mr1,mr2,…,mrdm,r1,…,rk-1,-∑dacri)T,其中k∈N且k2,rj是随机数且rj∈Ri=1Page6(j∈[1,k-1]).最后,Owner加密狆形成了外包向量犘=犕×狆,并存储到SP的服务器上.对加密的外包数值数据犘解密是加密算法的逆过程,所以不再详述.User将检索参数转换为向量的步骤与Owner的步骤一样.只是在进行加/减法运算时,User可以设置mulF=(0,0,…烐烏烑0的转换过程是一样的,因此两个数值数据的运算,无论它们同时为外包数据,或者一个是外包数据一个是检索参数,或者两个都是检索参数,处理的方法都是一样.所以,我们假设两个数值数据np和nq对应的加密向量为犘和犙.接下来,我们将阐述如何实现各种算术运算.4.2.2.2加法犘+犙=犕×狆+犕×狇SP直接对犘和犙执行加法运算:=犕×[(arp1+crp1,arp2+crp2,…,arpda+crpda,mrp1,mrp2,…,mrpdm,rp1,…,rp(k-1),-∑da(arq1+crq1,arq2+crq2,…,arqda+crqda,mrq1,mrq2,…,mrqdm,rq1,…,rq(k-1),-∑da=犕×((arp1+arq1+crp1+crq1),…,(arpda+arqda+crpda+crqda),(mrp1+mrq1),…,(mrpdm+mrqdm),(rp1+rq1),…,(rp(k-1)+rq(k-1)),(-∑da然后,SP将计算结果返回给User.User对结果解密:犕-1×(犘+犙)=犕-1×犕×((arp1+arq1+crp1+crq1),…,(arpda+arqda+crpda+crqda),=((arp1+arq1+crp1+crq1),…,(arpda+通过式(5),User得到一个d维向量,于是它i=1通过公式(∑da(-∑da后一个元素相加从而得到最后的结果.该方案支持在不解密的情况下进行多次加法操作.4.2.2.3减法SP直接对犘和犙执行减法运算:犘-犙=犕×狆-犕×狇=犕×[(arp1+crp1,arp2+crp2,…,arpda+=犕×((arp1-arq1+crp1-crq1),…,然后,SP将计算结果返回给User.User对结果进行解密:犕-1×(犘-犙)=犕-1×犕×((arp1-arq1+crp1-=((arp1-arq1+crp1-crq1),…,(arpda-通过式(7),User得到一个d维向量,于是它i=1通过公式(∑da(-∑da后一个元素相加从而得到最后的结果.该方案支持在不解密的情况下进行多次减法操作.4.2.2.4乘法首先,我们介绍实现乘法计算的原理.假设有两个数值数据np和nq,它们对应的6维向量分别为Page7x1+y1,np=a1×b1,nq=x2+y2和nq=a2×b2,c1、狏1=(x1+c1,y1+c2,a1,b1,r1,-c1-c2)和狏2=c2、c3、c4、r1和r2是随机实数.我们观察以下运算结果:(x2+c3,y2+c4,a2,b2,r2,-c3-c4),其中np=狏1×(狏2)T=x1+c1y1+c2a1b1r1-c1-c)2T×x2+c3y2+c4a2b2r2-c3-cx1x2+x1c3+c1x2+c1c3x1y2+x1c4+c1y2+c1c4x1a2+c1a2x1b2+c1b2x1r2+c1r2-x1c3-x1c4-c1c3-c1c4烄y1x2+y1c3+c2x2+c2c3y1y2+y1c4+c2y2+c2c4y1a2+c2a2y1b2+c2b2y1r2+c2r2-y1c3-y1c4-c2c3-c2c4a1y2+a1c4a1a2a1b2a1r2b1y2+b1c4b1a2b1b2b1r2r1y2+r1c4r1a2r1b2r1r2烆-c1x2-c1c3-c2x2-c2c3-c1y2-c1c4-c2y2-c2c4-c1a2-c2a2-c1b2-c2b2-c1r2-c2r2c1c3+c1c4+c2c3+c2c根据式(8)可得到:np×nq=(a1×b1)×(a2×b2)=(a1×a2)×(b1×b2)设matrix表示狏1×(狏2)T的结果,我们可以通过公式∏4以上分析,SP可以对犘和犙进行如下操作:犘×(犙)T=犕×狆×(犕×狇)T=犕×狆×(狇)T×犕T式(10)的结果是一个d×d矩阵.SP将结果返回给User.User对结果进行解密:犕-1×犘×(犙)T×(犕T)-1=犕-1×犕×(arp1+crp1,arp2+crp2,…,arpda+crpda,mrp1,mrp2,…,mrpdm,rp1,…,rp(k-1),-∑dacrq1,arq2+crq2,…,arqda+crqda,mrq1,mrq2,…,mrqdm,rq1,…,rq(k-1),-∑da犕T×(犕T)-1=(arp1+crp1,arp2+crp2,…,arpda+crpda,mrp1,mrp2,…,mrpdm,rp1,…,rp(k-1),-∑da(arq1+crq1,arq2+crq2,…,arqda+crqda,mrq1,mrq2,…,mrqdm,rq1,…,rq(k-1),-∑da式(11)的计算结果也是一个d×d矩阵,用matrix表示.接下来,User通过公式∏da+dm来计算最终结果.本方案在不解密的情况下只支持一次乘法运算.(4.2.2.5除法同样,我们先介绍实现除法操作的原理.假设有两个数值数据np和nq,它们对应的6维向量分别是狏1=(x1+c1,y1+c2,a1,b1,r1,-c1-c2)和狏2=(x2+c3,y2+c4,a2,b2,r2,-c3-c4),其中np=x1+y1,np=a1×b1,nq=x2+y2和nq=a2×b2,c1、c2、r1和r2是随机实数.根据式(8),我们得到以下结果:∏4(x1+y1)2×(a2×b2)=np2×nq(12)∏4(a1×b1)×(x2+y2)2=np×nq2(13)所以np/nq可以通过如下公式得到:np/nq=i=3(∑2∏4烄i=3(∑2∏4烆根据式(12)~(14),我们给出除法操作的方案.SP首先按照式(10)对犘和犙进行运算,然后将结果返回给User.User根据式(11)对结果进行解密得到矩阵matrix.为了得到最后的结果,User还需要按照以下步骤进行处理:1)∏da+dm2)∏da+dm3)dm-1npdm×nq式(17)的结果就是最后的结果.本方案在不解密的情况下只支持一次除法运算.Page84.3CESVMC的正确性(1)m∈犕,证明Dec(Enc(m,k))=m.证明.CESVMC基于向量和矩阵运算,密钥犕是一个d×d的可逆矩阵,因此,将明文数据m转换为对应的d维向量狆,则有Dec(Enc(m,k))=犕-1×(犕×狆)=狆,因此狆是可恢复的,即m是可以恢复的.所以m∈D,Dec(Enc(m,k))=m.证毕.(2){m1,m2,…,mt},其中mi∈D,证明Cal(m1,m2,…,mt,op)=Dec(Cal(Enc(m1,K),Enc(m2,K),…,Enc(mt,K),op)).证明.由矩阵和向量运算的性质易见,在进行加、减、乘和除法运算时,满足Cal(m1,m2,…,mt,op)=Dec(Cal(Enc(m1,K),Enc(m2,K),…,Enc(mt,K),op)).因此,本证明重点分析字符串模糊检索的正确性.根据第4.2.1.1节,将两个外包字符串np1和np2分别转换为两个(n-1)维的向量狆1=(v11,v12,…,v1(n-1))和狆2=(v21,v22,…,v2(n-1)),检索参数nq对应的(n-1)维向量为狇=(v1,v2,…,vn-1),则有犙×犘1-犙×犘2=r×(狆1×狇-0.5×‖狆1‖2-=r×(狆1×狇-0.5×‖狆1‖2-狆2×狇+0.5×‖狆2‖2-0.5×‖狇‖2+0.5×‖狇‖2)=-0.5×r×((‖狆1‖2-2狆1狇+‖狇‖2)-(‖狆2‖2-2狆2狇+‖狇‖2))=-0.5×r×(∑n-1=-0.5×r×∑n-1对于每个字符串的第i段子串,由于向量元素vi是由该段的组成字符的ASCII码转换而来,因此越相近的字符之间的差值越小,从而保证了该段上的vi值之差的大小反映了第i段子串的相似程度.对于不同段,根据前缀匹配原则,越前面的段对整个差值的影响也越大,因此,前后两段的关系为vi+1=vi×1012(每段由6个字符组成,每个字符用2位数的ASCII值表示),从而实现了前缀匹配.证毕.5CESVMC的安全性tance-recoverable).定理1.CESVMC是距离不可恢复的(dis-证明.如果CESVMC是距离可恢复的,那么必然存在一个函数f,使得对于m1,m2∈D,f(Enc(m1,M),Enc(m2,犕))=d(m1,m2).选择两个不同的密钥犕1,犕2和x1,x2∈D,CESVMC满足(1)a1=Enc(m1,犕1)=Enc(x1,犕2);(2)a2=Enc(m2,犕1)=Enc(x2,犕2);(3)d(m1,m2)≠d(x1,x2).则由于f(a1,a2)=f(Enc(m1,M1),Enc(m2,M1))=d(m1,m2),f(a1,a2)=f(Enc(x1,M2),Enc(x2,M2))=d(x1,x2);所以d(m1,m2)=d(x1,x2).以上结论与条件(3)冲突,因此函数f是不存在的.所以CESVMC是距离不可恢复的.证毕.定义5(方程不可解).假设犘为d维向量集合,犕为d×d矩阵集合,方程f(Pi,Mj)=Pk是不可解的,如果已知Pi∈犘和Mj∈犕,在方程f(Pi,Mj)=Pk(Pk∈犘,i,j,k∈N)中,方程等号两边的未知元素个数分别为s1和s2,且保持s1>s2.定理2.从字符串加密与检索的角度,(1)当适应性选择密文攻击者只获得外包数据的加密和解密Oracle的情况下,CESVMC是IND-CCA安全的;(2)当适应性选择密文攻击者获得了检索参数的加密Oracle后,CESVMC是不安全的.证明.(1)当一个适应性选择密文攻击者A只获得外包数据的加密和解密Oracle的情况下,CESVMC是IND-CCA安全的.1)A可以通过CESVMC的外包数据加密和解密Oracle获得t(t∈N)对明/密文对,假设CES-VMC使用d(d∈N,d=n+k,n表示计算元素个数,k表示随机元素个数)维向量和d×d矩阵,根据4.2.1节可知,由于分裂串S的存在,当A在不知道S的具体值的时候,使得分裂后的两个方程组的元素对于A来说都变成了未知数,因此方程等号两边的未知数个数的关系为d×d+t×2×d>t×2×dd×d>0.所以,CESVMC的矩阵方程组是不可解的;当A对分裂串进行穷举法攻击时,其破解函数的时间复杂度为O(2d).根据文献[18],当系统的复杂度按指数形式增长,那么系统为实际有效安全的.2)A发起以下攻击:(1)A选择一些明/密文向CESVMC进行加/解密询问,E将加/解密的结果返回给A;(2)A选择两个数据m0,m1发给CESVMC,CESVMC随机加密其中一条消息mb(b∈{0,1}),并将产生的密文c返回给A;(3)A继续选择一些明/密文向CESVMC进行加/解密询问,唯一的限制就是不能要求解密c,CESVMC将加/解密的结果返回给A,这时A一共得到t组明/密文对Page9{(m1,P1),(m2,P2),…,(mt,Pt)};(4)A输出b作为对b的猜测.根据4.2.1.2和4.2.1.3节可知,对于外包字符串np和检索参数nq,它们对应的密文分别是犘和犙(未分裂):犘=犕×(狆i,-0.5×‖狆i‖2,r1,w2,…,rk-3,犙=r×(狇,1,w1,r2,…,wk-3,rk-2,1,wk-2,-(∑k/2-1-(∑k/2-1其中r和ri都是随机实数,它们在每个字符串中的取值都是随机的.根据矩阵和向量运算的规则,如式(21)所示,犕×(狏)T=a11a12结果向量的每个元素是由作为操作数的矩阵和向量的多个元素共同决定的,并且都受随机数r的影响,这就保证了同一字符串在相同的密钥下加密多次会产生不同的值.再根据定理1可知,CESVMC是距离不可恢复的.由于CESVMC的值域为实数域R,设|R|表示R中的元素个数,所以A的优势概率为因此,A的优势概率是可忽略的,CESVMC是IND-CCA安全的.(2)当适应性选择密文攻击者获得了检索参数的加密Oracle后,CESVMC是不安全的.假设数据库中有t个数据{np1,np2,…,npt}对应的密文{犘1,犘2,…,犘t},攻击者A可以通过以下步骤展开攻击:①A首先选取一个极小的检索参数nq0,例如由一个空格组成的字符串,通过检索参数加密Oracle后得到对应的密文Q0.根据4.2.1.4节可知,A可做如下运算:Q0×犘i-Q0×犘j=d2(狆j,狇0)-d2(狆i,狇0)>0|npi-nq0|<|npj-nq0|从而对{np1,np2,…,npt}进行排序,相似度由大到小排序的结果为{np1,np2,…,npt}.由于nq0足够小,所以{np1,np2,…,npt}反映了数据{np1,np2,…,npt}的大小关系;②A重复步①k次,选择的k个检索参数{nq1,nq2,…,nqk}满足nqi<nqj(i∈[0,k-1],j∈[1,k],i<j),可以猜测出密文犘对应的明文值,原理如下:因为dis=犙×犘=狆×狇-0.5×‖p‖2,dis的值随着nq逐渐靠近np逐渐变小;当nq=np时,dis最小;当nq逐渐远离np变大时,dis的值又逐渐变大;又因为k个检索参数{nq1,nq2,…,nqk}满足nqi<nqj所以A可以通过逐渐逼近的方法获得密文np对应的明文.故当A获得检索参数加密Oracle情况下,CESVMC是不安全的.定理3.从数值数据的加解密和算术运算的角度,当加法因子的个数da>3时,CESVMC是IND-CCA安全的.证明.(1)一个适应性选择密文攻击者A使用CESVMC的外包数据加密和解密Oracle获得了t(t∈N)对明密文对,假设CESVMC使用d(d∈N,d=n+k,n表示计算元素个数,k表示随机元素个数)维向量和d×d矩阵,根据4.2.2节可知,方程等号两边的未知数个数的关系为d×d+t×(da+(n-2)+k-1)×d>t×d(d+da-3)>dda>3.所以,当da>3,CESVMC的矩阵方程组是不可解的.(2)A发起以下攻击:①A选择一些明/密文向CESVMC进行加/解密询问,CESVMC将加/解密的结果返回给A;②A选择两个数据m0,m1发给CESVMC,CESVMC随机加密其中一条消息mb(b∈{0,1}),并将产生的密文c返回给A;③A继续选择一些明/密文向CESVMC进行加/解密询问,唯一的限制就是不能要求解密c,CESVMC将加/解密的结果返回给A,这时A一共得到t组明/密文对{(m1,犘1),(m2,犘2),…,(mt,犘t)};④A输出b作为对b的猜测.根据4.2.2.1节,对于数值数据np,其对应的密文为犘=犕×(ar1+cr1,ar2+cr2,…,arda+crda,mr1,mr2,…,mrdm,r1,…,rk-1,-∑da其中除arda、mrdm和-∑da们在每个数值数据中的取值都是随机的.根据矩阵和向量运算的规则,如式(21)所示,结果向量的每个元素是由作为操作数的矩阵和向量的多个元素共同决定的,并且都受随机数的影响,这就保证了同一数值在相同的密钥下加密多次会产生不同的值.由于CESVMC的值域为实数域R,设|R|表示R中的元Page10素个数,所以A的优势概率为因此,当da>3时,A的优势概率是可忽略的.(3)在进行算术运算时,根据4.2.2.2节至4.2.2.5节易见,运算过程并没有破坏密文数据的不确定性,在没有密钥的情况下,A的优势概率如(2).综合(1),(2)和(3)可知,当加法因子的个数da>3时,CESVMC是IND-CCA安全的.证毕.6CESVMC的性能本节将通过对CESVMC和已有的方案进行比图2CESVMC(d=10)与OPES(b1=6,b2=4)的性能对比根据图2(a),当len500时,CESVMC的数据加密时间比OPES少,当len>500后,CESVMC的加密时间比OPES多,且随着len增加,二者的差距缓慢变大;CESVMC的解密时间和检索参数加密时间始终比OPES小,且随着len的增加,差距显著增加.根据图2(b)和2(c),CESVMC的检索时间和存储/通信负载明显比OPES大.本节所说的检索时间都是指进行一次比较操作所花的时间,而真正的检索时间应与数据库中的记录数有关.实验2评估了CESVMC在向量维度d取不同值的情况下对长度len=200的字符串加解密和检索的性能,结果如图3所示.根据图3(a)和3(b),CESVMC的加解密时间、检索时间和存储/通信负载随着d的增加而增加,其中加解密时间受d的影响最大.其原因是,加解密的计算复杂度为O(d2),检索的复杂度为O(d),存储/通信复杂度为O(d).较,从而评估CESVMC的性能.对比方案包括基于OPES[12]的加密字符串模糊检索方案,支持乘法同态的unpadded_RSA和支持加法同态的Paillier.性能指标包括加解密性能、计算(检索和算术运算)性能以及存储/通信负载等.实验部署在由本研究小组自行研发的青云实验平台3.0上.该平台是一个基于Web的面向校园的云计算环境,以KVM和Ha-doop的HDFS为底层支撑技术,并部署在由10台服务器构成的集群上.6.1字符串实验1对不同长度(len)的字符串进行了加解密、检索操作,其中CESVMC的向量维度d=10,OPES的输入分布桶数和输出分布桶数分别为b1=6和b2=4,结果如图2所示.6.2数值数据实验3比较了CESVMC与unpadded_RSA、Paillier在加解密、计算以及存储/通信负载三方面Page11的性能,其中,unpadded_RSA和Paillier均采用两个7位素数作为密钥,结果如表1所示.其中“SP”表示服务提供者,“加法_SP”表示由服务提供者承表1CESVMC对数值数据加解密和计算性能unpadded_RSA两个7位素数Paillier两个7位素数CESVMC向量根据表1,(1)当d10时,CESVMC的加解密时间小于Paillier,大于unpadded_RSA;CESVMC的存储/通信负载始终大于Paillier和unpadded_RSA;加解密的计算复杂度为O(d2),存储/通信复杂度为O(d).(2)CESVMC的加减法运算的时间几乎一样,当d100时,CESVMC的加减法运算时间远小于Paillier,但是由于CESVMC在进行加减法运算时的计算复杂度为O(d),所以,当d达到一定值的时候会超过Paillier;(3)CESVMC的加减法运算结果的解密时间几乎一样,当d<80时,其值小于Paillier;加减法运算结果的解密复杂度为O(d2).(4)CESVMC的乘除法运算的时间几乎一样,且远大于unpadded_RSA,其计算复杂度为O(d2).(5)CESVMC的乘除法运算结果的解密时间也几乎是一样的,且均大于unpadded_RSA,其计算复杂度为O(d3).总的说来,CESVMC具有以下特点:(1)加解密性能很好;(2)加减法效率很高,但字符串模糊检索和乘除法运算的时间相对较长;(3)加减法运算结果的解密时间适中,但乘除法运算结果的解密时间较长;(4)存储/通信负载较大;(5)各性能指标的值随着维度的增加而增加.7结束语针对云计算中的隐私保护问题,本文提出了支持隐私保护的云计算模型,并设计了一种支持隐私保护的可计算加密方案CESVMC.CESVMC支持加密字符串的模糊检索和加密数值数据的加、减、乘、除四种算术运算.通过安全分析证明:对于字符串,当攻击者只获得外包数据的加密和解密Oracle担的加法操作的计算时间;“U”表示用户,“加法_U”表示用户对服务提供者返回的加法运算结果进行解密的计算时间,其它表示与此类似.指标/ms的情况下,CESVMC是IND-CCA安全的;对于数值数据,当加法因子的个数大于3时,CESVMC是IND-CCA安全的.同时,性能评估证实CESVMC具有很好的加解密性能,能高效地实现加减法运算,但字符串模糊检索和乘除法运算的计算时间稍长,存储/通信负载较大,各性能指标的值随着维度的增加而增加.下一步,我们将改进方案中乘除法运算的性能,使之支持多次乘/除法运算,同时减少存储/通信负载,并进一步研究数值数据排序问题.我们也计划研究新的加密技术来实现安全的密文计算.
