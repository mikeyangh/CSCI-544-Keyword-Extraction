Page1面向微博系统的实时个性化推荐高明1)金澈清1)钱卫宁1)王晓玲1),2)周傲英1),2)1)(华东师范大学软件学院上海市高可信计算重点实验室上海200062)2)(复旦大学上海市智能信息处理重点实验室上海200433)摘要社交网络服务需要响应用户实时、连续、个性化的服务需求.然而,目前多数社交网络服务并未充分考虑用户的个性化服务需求.由于社交网络中海量的数据更新使得提供实时个性化服务成为一项相对艰巨的任务.文中基于LDA主题模型推断微博的主题分布和用户的兴趣取向,提出了微博系统上用户感兴趣微博的实时推荐方法,以响应用户实时、连续和个性化的服务请求,在真实数据集上的实验结果验证了文中提出的方法的有效性和高效性.关键词实时推荐;个性化推荐;LDA;社交网络;微博1引言近几年来,社会网络服务(SocialNetworkServices,SNS)已经发展成为互联网新兴媒体中一类重要的服务,例如Facebook①、Foursquare②、Twitter③、YouTube④、新浪微博⑤以及优酷⑥等,这些社会网络服务对各行各业均产生了重大的影响.社交网络服务需要为海量的用户群体实时提供符合各自需求的服务.它们不但要响应海量用户的实时服务请求,而且还要响应用户的个性化服务请求.因此,海量性、实时性和个性化成为社交网络服务显著区别于传统互联网服务的重要特点,这三大特点也致使传统互联网技术在处理社交网络服务时面临着“捉襟见肘”的窘境.就个性化而言,除了YouTube的个性化视频推荐和Facebook的图搜索(graphsearch)等少数几例外,大多数社交网络服务针对不同用户返回相同的结果.社交网络服务的三大特点在微博平台上得到了很好的体现,这也使得微博成为一种非常典型的社交网络服务.针对微博平台,部分互联网公司已经开发了实时社交网络服务,包括Twitter、TOPSY⑦和OneRiot⑧.而在学术界,Busch等人[1]介绍了Twitter搜索引擎EarlyBird,Chen等人[2]研究了Twitter的实时搜索引擎,我们也设计了一个微博平台上的实时搜索引擎[3].但是,现有工作并未充分考虑用户的个性化服务需求,这正是本文的出发点.本文运用主题模型LDA(LatentDirichletAllocation)推断微博的主题分布和用户的兴趣取向,从而实时、连续地向用户推荐他们感兴趣的微博.此项工作面临两大挑战:(1)海量数据的快速更新;(2)个性化服务请求的实时和准确响应.本文的主要贡献可归纳为(1)运用流数据模型对海量的微博发布或者更新进行建模,利用数据流上基于滑动窗口模型的实时top-k查询来响应实时微博推荐.(2)基于微博的主题分布、用户的兴趣取向以及用户最关注的话题,提出了用户感兴趣微博的实时推荐方法.(3)利用真实数据集验证新方法的有效性和高效性.本文第2节回顾与社交网络服务相关的技术;第3节介绍新方法的整体设计框架;第4节阐述如何推断微博的主题分布和用户的兴趣取向;第5节介绍如何向用户实时推荐他们感兴趣的微博;第6节利用真实数据集验证新方法的有效性和高效性;最后在第7节中总结全文.2相关工作2.1社交网络服务近年来,社交网络服务的发展非常迅猛,不少网络运营商均提供实时搜索服务,这些服务响应用户的关键字查询,返回社交网络上实时更新的结果.例如,Earlybird(Twitter的实时搜索服务)根据每条微博的发布时间和受欢迎程度对查询结果排序[1];TOPSY根据用户的影响力对查询结果排序;OneRiot根据微博的发布时间、用户的影响力以及微博的主题对查询结果排序;Bing⑨提供两种排序方法,一是根据微博的发布时间返回新近的微博,二是根据用户的影响力、微博的转发次数来度量查询结果的重要程度.Chen等人[2]研究了Twitter上的实时检索问题,其根据微博可能出现在结果中的概率对微博进行分组,在尽量保证查询质量的情况下优化实时搜索引擎的索引,以提供实时搜索服务.我们先前的文章[3]提出了微博上的实时搜索引擎,但这些工作都没有充分考虑用户的个性化服务需求,而这是本文关注的重点之一.2.2个性化推荐个性化搜索服务[4-7]主要分为查询扩展和结果再处理两类.Xu和Croft[4]提出了一个查询扩展的方法,该方法有效地响应用户个性化的信息检索请求;Leroy等人[5]基于用户提交的关键字查询结果来扩展关键字,从而提高用户的查询体验.主题相关的PageRank方法基于用户的兴趣扩展了PageRank算法[8],从而实现个性化排序;文献[6-7,9-10]根据用户的点击历史自动探索用户的兴趣爱好,以响应用户个性化的搜索需求;Chen等人[11]综合微博的主题分布因子、用户在社交网络中的影响力特征、微①②③④⑤⑥⑦⑧⑨Page3博的内容特征以及微博的受欢迎程度特征为用户提供个性化搜索结果.除此之外,Chirita等人[12]通过用户手动输入的偏好实现个性化检索;Das等人[13]提出了协作过滤的方法为用户推荐Google新闻,该方法通过整合Minhash聚类技术、概率潜在语义索引(PLSI)技术和用户访问历史实现Google新闻的个性化推荐.近来,许多学者意识到一段文本可能同时涉及多个潜在主题,而每个主题通常涉及到一系列特定的词汇,因此多个基于文本的概率生成模型被提出用于揭示文本的潜在主题[14-17],其中LDA作为一种非监督的文本主题概率生成模型而被广泛研究[15].但这些工作并没有充分考虑用户的实时查询需求,这是本文关注的另一个重点.实时个性化推荐服务逐渐得到服务提供商们的重视.YouTube旨在向用户提供可自定义的、简洁的视频观看体验,YouTube通过用户观看历史向用户推荐他们可能感兴趣的视频.Facebook推出了图搜索(GraphSearch),用户可以搜索其他用户公开的所有内容.之所以叫做“图搜索”,主要是因为Facebook将用户相关的内容、数据、好友关系定性为社交图(SocialGraph),用户利用图搜索可以浏览照片、用户页面、地点以及用户兴趣等.Facebook还表示,未来用户可以自己过滤搜索结果.一方面,用户可以查找特定朋友感兴趣的音乐、餐馆或其他对象;另一方面,根据特定的对象或者主题,用户可以查找可能感兴趣的朋友①.传统信息检索服务仅考虑了用户提交的关键词和文本间的相关性,而在各类社交网站中,海量用户间形成一个庞大的社交网络,每个用户都有不同的兴趣爱好以及社交群体.因此,在海量、实时以及不确定数据上响应用户的个性化服务请求凸显了传统的信息检索服务在社交网络服务中的不适应性.3整体框架图1展示了微博系统上向用户实时推荐他们感兴趣的微博的框架.首先,基于每条微博的内容推断该条微博的主题分布,根据用户发布的微博进一步推断用户的兴趣取向.其次,根据用户不同的偏好对微博建立不同的网格索引,利用滑动窗口上的连续top-k查询技术将新近发生的热点事件维护在全局top-k列表中,从这些热点事件中向用户推荐与他们兴趣较吻合的微博.3.1数据预处理为了提供实时和个性化推荐,在数据预处理阶段需要收集或更新:(1)用户在社交网络中的影响力特征;(2)每条微博的受欢迎程度特征;(3)微博的主题分布;(4)用户的兴趣取向.在社交网络中,用户的影响力因素包括所发微博数、粉丝数、关注数以及参与的讨论组数,微博的影响力因素包括发布时间、被回复次数、被转发次数和该微博包含的信息量[18].表1展示了3位用户在社交网络中的影响力特征,由于Ross比John具有更多的粉丝和关注用户,因此Ross在社交网络中具有更大的影响力;表2展示了3条微博的受欢迎程度特征,微博3750被回复次数、被转发次数和信息量均比其他微博多,因此该微博比其他两条微博更受欢迎.用户名微博数粉丝数关注数组数RossMathews18591217363062664BradWood21461790394122JohnNocella718611405微博发布时间被回复次数被转发次数信息量3748t13749t23750t3此外,本阶段还要推断新发布微博的主题分布,以及更新和记录用户的兴趣取向.实践中运用LDA主题模型推断微博的主题分布,推断过程中所用到的变量以及变量的含义如表3所示,具体细节将在第4节中阐述.①https://www.facebook.com/about/graphsearchPage4变量T主题个数W单词个数α用户兴趣取向先验分布的参数φjwi单词wi属于第j个主题的概率zwi单词wi的主题Zt,in(t)微博t中单词的个数n(j,t)微博t中属于第j个主题的单词数量3.2用户感兴趣微博推荐考虑到微博系统需要响应海量用户发布的新微博以及转发、回复其他用户的微博,本文运用流数据模型对微博的发布和更新进行建模.由于用户通常仅对新近发布或更新的微博感兴趣,而随着时间的推移,较早发布的微博越来越不被用户关注.因此,我们利用流数据上的滑动窗口模型对微博的更新和过期进行建模,使得滑动窗口中总是维护新近发布或者更新的微博.如图1所示,微博系统上用户感兴趣微博的实时推荐由3部分组成:(1)当前滑动窗口上微博的索引;(2)全局top-k微博列表的更新;(3)用户个性化微博的推荐.为了快速响应实时微博的推荐,根据用户的不同偏好对滑动窗口中的微博建立网格索引.对特定偏好的用户,根据索引中微博的m个特征维护一个全局top-k微博列表,它表示新近最热门的k条微博.随着时间的推移,全局top-k列表中的微博需要及时更新以响应微博的实时推荐.在每个时刻,根据全局top-k列表中微博的主题分布和用户的兴趣取向,从全局top-k列表中选择用户最可能感兴趣的k条微博推荐给用户(k<k).4推断微博的主题分布和用户的兴趣取向每条微博通常涉及一个或多个主题,微博的这个特征正好和LDA主题模型匹配,因此本文采用LDA主题模型来推断微博的主题分布.此外,一个用户所发布的微博很好地反映了该用户所关心的主题.因此,通过该用户发布的微博的主题分布可以推断他的兴趣取向.4.1主题分布和兴趣取向令C表示预先设定的T个主题集合,标记为C={C1,C2,…,CT}.给定一条微博t,其主题分布定义如下:定义1.主题分布.令主题集合C={C1,C2,…,CT},t为一条微博,则p(Ci|t)表示该微博t属于主题Ci的后验概率,由这T个后验概率组成的向量(p(C1|t),p(C2|t),…,p(CT|t))被称为微博t的主题分布.易知,p(Ci|t)的数值越大,表明微博t属于主题Ci的可能性越高.假设某用户发布了d条微博,标记为{t1,t2,…,td}.由于每条微博对应一个主题分布,该用户的兴趣取向可以定义如下.定义2.兴趣取向.令{t1,t2,…,td}表示某用户发布的微博集合,则该用户的兴趣取向可用一个T维向量(v1,v2,…,vT)描述,其中vi=1当用户尚未发布任何微博时,该用户的兴趣取向为0向量.兴趣取向中分量vi越大表明用户对主题Ci越感兴趣.以下介绍如何推断微博的主题分布.4.2推断微博的主题分布给定训练数据集,完成LDA模型学习后,已知每个单词在T个主题上的分布φ以及训练数据集中每条微博的主题分布.对于不包含在训练数据集中的微博,可以通过φ推断该微博中各单词所属主题,进而推断该微博的主题分布.假设微博t由n个单词组成,记为{w1,w2,…,wn},令随机变量zwi表示单词wi的主题.在给定其他参数的情形下,对微博t中单词wi,zwi=j(单词wi属于第j个主题)的概率计算如下:P(zwi=j|Zt,i,t,φ,α)∝P(zwi=j,Zt,i,t|φ,α)其中式(1)中所有的变量及其含义如表3中所示.基于式(1),单词wi的主题分布记为Vwi=(v1,v2,…,vT),其中分量vj标准化式(1)中的概率,即单词wi的主题从分布Vwi=(v1,v2,…,vT)中抽样得到.最终,微博t属于第j个主题的概率θt,j可以估计为最后,微博t的主题分布表示为θ^t=(θ^t,1,θ^t,2,…,θ^t,T).在推断微博主题分布的过程中,每次迭代复杂度是O(1).令r表示迭代次数(通常可设为100),则Page5微博主题分布推断的复杂度为O(r).在式(1)中,只wi独立于微博t,它用于衡量用户在微博系统上有φj阶段性的用词规律.随着时间推移,用词规律和用户兴趣会发生变化,因而需要周期地(比如每月一次)构建LDA训练数据集以更新φj以离线完成),进而更新微博的主题分布和用户的兴趣取向.5实时个性化的微博推荐微博用户往往关注新近发生的热点事件,考虑到用户的不同兴趣,所推荐的微博不仅要与新近的热点事件相关,而且还要与用户的兴趣吻合.本文选择新近发布的微博,并根据其特征对它们受欢迎的程度进行排序,最后在top-k受欢迎的微博中选择用户可能感兴趣的微博.5.1用户偏好和top-犽打分函数的性质不同用户对新近发生的热点事件的界定可能不同,有的可能关注大家都关注的事件(例如被转发或回复次数较多的事件)、有的可能仅关注新近发生的事件.不难看出,热点事件的界定和用户的偏好相关,而不同用户的偏好可能不同.文献[19]探讨了不同用户偏好的提取方法.事实上,构建一个精准而有效的用户偏好模型并非易事,我们将此项工作列为本文的后续工作.本文运用完全替代型效用函数来表示用户对微博的偏好程度[20],令微博t有m个特征,标记为(x1,x2,…,xm),用户偏好对应的效用函图2微博的更新区域以及微博的更新和过期在图2(a)中,假设(ret,rep)是微博t在2维特征空间中的点,它表明t被转发了ret次、被回复了rep次.易知,微博t的打分是所有落在矩形区域R内的微博的最高分数,因此将微博t的分数记为maxscore(R).另外,微博tk的分数是所有落在空白数可以表示为score(t)=f(x1,x2,…,xm)=∑m一般来说,被转发或者被回复次数越多的微博越受欢迎.因此,效用函数f应具有单调性,即ai均为非负数.假设两条微博t1和t2满足t1.xit2.xi以及t1.xj=t2.xj(j≠i),那么效用函数f一定满足f(t1.x1,t1.x2,…,t1.xm)f(t2.x1,t2.x2,…,t2.xm).在本文中,我们假设用户的偏好已经被归为h类,同类用户的效用函数相同.因此,系统中共有h个不同的效用函数.对具有特定偏好的用户,可利用其偏好所对应的效用函数作为top-k打分函数,选择他们认为最热门的k条微博.如图2(a)所示,效用函数(打分函数)为f(x1,x2)=x1+x2,其中x1、x2分别表示被转发和被回复次数.因此,每条微博表示为2-维空间中的一个点,用户的偏好由微博的被转发和被回复次数决定.如果所有微博的特征落在由点(0,0)、(0,rep)、(ret,0)和(ret,rep)围成的矩形内.图中由微博tk诱导的直线把整个空间分成三部分,落在左下角部分的微博的打分低于tk的分数,落在直线上的微博的打分等于tk的分数,而落在右上角阴影部分的微博的打分大于tk的分数.当tk为第k条打分最高的微博时,如果一条微博被更新到阴影区域内,将导致top-k列表的更新,反之则不必更新.因此,我们称右上角的阴影部分为top-k列表的更新区域.区域内微博分数的上界,我们称该空白区域为微博tk的统治区域.由于在微博系统上,用户仅关心新近发生的热点事件.因此,我们必须更新top-k微博列表,否则推荐的微博所讨论的事件因为用户可能已经知晓而Page6被用户所忽视.而滑动窗口模型的运用意味着每时每刻微博会更新(包括特征更新的微博或者新发布的微博)或者过期,这就需要在滑动窗口上动态维护全局top-k列表.如图2(b)所示,0时刻表示当前时间,每条线段表示相应微博的生命周期,左端点表示微博到达的时间,而右端点表示微博的过期时间.例如,t5在1时刻到达,而在4时刻过期.在0时刻有4条未过期微博,根据用户的效用函数降序排列为t1,t2,t3,t4.假设我们维护top-2的微博,那么此时的top-2列表为t1、t2.在1时刻,微博t4过期而微博t5到达,但是t5不如t1,t2受欢迎,且t4不在top-2列表中,因此top-2列表不必更新.而在2时刻,微博t6到达,微博t2过期,此时有4条微博未过期,它们的顺序是t1,t5,t3,t6,因此top-2列表更新为t1,t5.基于以上观测,我们的首要任务是为特定偏好的用户维护新近最热门的k条微博,该问题可以用流数据上基于滑动窗口模型的实时top-k查询来建模.而连续不断的实时top-k查询需要两个模块:(1)初始化全局top-k列表;(2)更新全局top-k列表.5.2初始化全局top-犽列表Mouratidis等人[21]提出的流数据上基于滑动窗口模型的top-k查询算法,简记为CT(ContinuousTop-kAlgorithm)算法,由于其高效率而被广泛应用.基于该算法,我们提出了维护新近最热门的k条微博的方法.图3展示了滑动窗口中微博的索引方法.假设每个格子在第i维上的长度为δi,那么格子ci,j将索引特征在[i·δ1,(i+1)·δ1]×[j·δ2,(j+1)·δ2]范围内的所有微博,其中i,j=0,1,2,….假设一条微博在特征空间中表示为(x1,x2),那么它将被索引在格子ci,j中,其中i=x1/δ1,j=x2/δ2.因为微博的被转发次数或者被回复次数服从长尾分布[22],所以大部分微博是很少被转发或者回复的.在图3的网格索引中,它们被索引在网格左下角的少数格子中.即,不被关注的微博被索引在左下角的少数格子中.为了决定格子的访问次序,格子ci,j中索引微博的最高分数记为maxscore(ci,j).访问网格索引的简单方法(记为Nave方法)是按照maxscore(c)降序排列所有的格子,再逐一扫描这些格子.当扫描一个格子时,计算该格子中每条微博的分数,从而更新全局top-k列表.若top-k列表中微博的最低分数高于格子c的maxscore(c),则算法终止.然而,每个格子中微博的更新,可能导致maxscore(c)的变化,重新对所有格子进行排序是必要的.此外,当格子c位于左下角时,由于这些格子中的微博被转发或回复的次数较少,不会成为用户所关注的热门微博.当新的微博被索引到这些格子或其中的微博过期,Nave方法需要更新这些格子中的maxscore(c)值,但这些更新操作是不必要的.因此,该方法成本太高.为解决Nave方法的不足,在没有预先对maxscore(c)进行排序的情况下,我们需要确定网格索引的访问方式.图4(a)中格子c5,5左下角的微博t对应着该格子中分数最小的微博;由于微博t1、t2和t的分数相同,根据微博统治区域的定义,微博t的分数大于左下角部分所有灰色格子中索引的微博的分数;因此,比微博t分数高的微博一定在格子c4,5、c5,4和c5,5中.易知,格子c5,5右上角对应的微博分数最高,因此格子c5,5应该被首先扫描,然后扩展到c4,5和c5,4,而这两个格子的扫描顺序由maxscore(c4,5)和maxscore(c5,4)决定,分数较大的先被访问.特别需要指出的是,因为被转发或回复的次数较少,左下角的格子中索引了大量用户不感兴趣的微博.为节省开销,无需更新这些格子的最高分数.通过预先设定一个阈值M,当0i,jM,格子ci,j中的maxscore(ci,j)不必更新,即左下方格子的最高分数不必更新.不同效用函数对应特征空间中不同的直线,它们决定了不同top-k列表的更新区域以及微博的统治区域.如图4(b),当打分函数为f(x1,x2)=Page73x1+4x2时,图中的直线同样将整个空间分成3部分,其中空白区域落在了tk的统治区域,而落在直线右上角区域的微博的分数高于tk的分数.当tk为top-k列表中分数第k高的微博时,易知直线f(x1,x2)=3x1+4x2定义了该top-k列表的更新区域,只有当微博被更新到与该更新区域相交的格子{c5,5,c4,5,c5,4,c3,5,c4,4,c5,3,c4,3,c5,2,c3,4}中时,才可能导致top-k列表的更新.而图5中微博t1和图4(b)中微博tk在索引中的位置相同,若t1为top-k列表中分数第k高的微博时,由于不同的效用函数从而导致和更新区域相交的格子变成了{c5,5,c4,5,c5,4,c3,5,c4,4,c5,3,c4,3,c5,2,c3,4,c2,5}.初始化全局top-k列表L如算法1所述,其中f.top_score记录了全局top-k列表中k条微博的最低分数.第3行把最右上角的格子加入到最大栈H中(最大栈中的key是格子c的maxscore(c)),第5行每次访问最大栈中第一个格子ci,j,如果top-k列表中f.top_score小于maxscore(ci,j),在第7行中计算该格子中所有微博的分数,如果微博t的分数大于f.top_score,则将微博t加入到top-k列表中.格子ci,j中的每条微博都被访问后,第8行和第9行分别将格子ci-1,j和ci,j-1加入到最大栈H中.需要特别声明的是,如果top-k列表中微博个数小于k,那么f.top_score的值为0;当top-k列表中正好有k条微博时,f.top_score更新为这k条微博的最低分数.反之,如果f.top_score大于maxscore(c),算法终止.算法1.初始化全局top-k列表算法.输入:参数k,效用函数f输出:列表L1.将列表L初始化为空;f.top_score为0;2.将最大栈H初始化为空;3.令c是最右上角的格子,格子c被压入栈H中;4.REPEAT:H不为空且第一个格子ci,j的5.弹出H中的第一个格子ci,j;6.FOREACH格子ci,j中的微博t7.IFscore(t)>f.top_scoreTHEN8.IFci-1,j不在H中THEN将其加入H中;9.IFci,j-1不在H中THEN将其加入H中;10.RETURNL假设k=2,图5是一个初始化top-k列表的例子.将f.top_score初始化为0,L初始化为空.从最右上角的格子c5,5开始扫描,由于该格子为空,接着扫描c5,4和c4,5.类似的,当扫描完格子c5,3,格子c5,2和c4,3被加入到最大栈中,根据每个格子的最高分数,易知此时最大栈中的第一个位置是c3,4.计算c3,4中所有微博的分数,并将微博t1加入L中.因为top-k列表中只包含微博t1,因此f.top_score不会被更新.根据格子的maxscore(),随后扫描格子c5,2,并将微博t2加入L中,并将f.top_score更新为score(t2).直到没有格子满足maxscore()>f.top_score时,算法1终止.5.3更新全局top-犽列表在初始化阶段之后,随着时间的推移,全局top-k列表中的微博也会被更新或者过期.全局top-k列表的更新如算法2中所示,令Supd和Sdel分别表示更新和过期的微博集合,对于每条更新的微博t,如果t不是落在左下角的格子ci,j中(即i,j>M),则更新maxscore(ci,j)(第5行);如果该微博的分数大于f.top_score,则将该微博更新到全局top-k列表中(第6行);对于每条过期的微博t,将微博t从相应的格子c中删除,如果i,j>M,则更新maxscore(ci,j)(第7~9行).如果全局top-k列表中有任何一条微博过期,调用算法1重新计算全局top-k列表(第10行).算法2.全局top-k列表的更新算法.输入:全局top-k列表L输出:更新之后的top-k列表L以及全局top-k列表中1.REPEAT:2.Supd为需要更新的微博集合;Sdel为过期的微博3.FOREACH在Supd中的微博t4.IF(i,j>M)THEN5.将t插入到相应的格子ci,j中,6.IFt的分数大于L中的f.top_score7.FOREACH在Sdel中的微博t;8.将t从相应的格子ci,j中删除;Page89.IF(i,j>M)THEN10.如果L和Sdel有公共的微博,则调用算法1;11.将全局top-k列表中更新的微博加入S;12.RETURNL和S假设k=2.图6(a)是4条微博在索引中有效期的例子,而图6(b)展示了4条微博在索引中的位置.在0时刻,微博t1,t2构成了全局top-2列表.在1时刻,微博t3和t4到达,而微博t2过期,则Supd={t3,t4}以及Sdel={t2}.先将t3和t4分别索引在c4,2和c4,4中,并更新maxscore(c4,2)和maxscore(c4,4).然后将t2从c3,4中删除,并重新调用算法1计算全局top-k列表.因此,在1时刻,top-2微博列表为t4,t1.5.4推荐用户感兴趣的微博算法3描述了如何从新近最热门的k条微博中选择用户可能感兴趣的k条微博,输入为全局top-k列表L、全局top-k列表中的更新微博集合S以及用户u当前感兴趣的微博列表L(u).当L(u)为空时,第1行计算用户u的兴趣取向和L中每条微博的主题分布间的相似度,将相似度最高的k条微博返回给用户u.如果L(u)不为空时,exp记做L(u)中过期的微博.第5行计算用户u的兴趣取向和S中每条微博的主题分布间的相似度,用S中相似度大的微博去替换L(u)去掉过期微博后相似度小的微博,形成的新列表记为L(u).如果全局top-k列表中没有更新的微博,第6行计算用户u的兴趣取向和L中去掉过期微博后每条微博的主题分布间的相似度,将相似度最高的k条微博返回给用户u.算法3.推荐用户感兴趣的k条微博算法.输入:全局top-k列表L,输出:更新u感兴趣的k条微博列表L(u)1.IFL(u)为空THEN2.ELSE3.exp记为L(u)中过期的微博;4.IFS不为空5.将L\exp中与u的兴趣取向相似度小于S中6.ELSE将L\exp中与u的兴趣取向相似度最高7.RETURNL(u)用户兴趣取向和微博主题分布间的相似度由向量的内积来度量,其几何意义可视化在图7中.假设有两个隐含的主题:主题1和主题2.而向量犢表示用户的兴趣取向,t1和t2分别表示两条微博的主题分布.比较用户兴趣取向和微博主题分布的夹角A1和A2可知,微博t1和该用户的兴趣爱好更接近.图7用户兴趣取向和微博主题分布间相似度的可视化5.5算法复杂度分析假设微博均匀分布在网格索引中(由于大多数微博是很少被转发或回复的[22],所以越靠近左下角的网格索引的微博越多.因此,按照均匀分布假设计算出来的复杂度可能会偏高),滑动窗口的长度为l,每次更新N条微博,每维的格子数为γ,特征个数为d,效用函数个数为h,用户数量为U,则网格索引中格子数为γd,网格中未过期微博为N·l,top-k列表的更新区域在网格中所占的比例为k此,与更新区域相交的格子数D=k格子中平均索引了N·l的微博数量为DN·l除操作的复杂度为O(DlogD).更新top-k列表中每条微博的复杂度为O(logk),那么维护整个top-k列表的复杂度为O(klogk).因此,初始化top-k列表Page9的复杂度为Tcom_k=O(DlogD+klogk).注意到每次有N条微博更新,也有N条微博过期.因此,网格中每条微博过期或者更新的概率为NN·l=1或者删除,那么更新区域中需要检查DN博是否为top-k结果.易知,平均有k博需要插入到top-k列表中.注意到,top-k列表中至少有一条微博过期的概率为pexp=1-1-1()l博是否为top-k结果的复杂度为Ok()l,更新top-k列表的复杂度为Ok的复杂度为O(pexp·Tcom_k).那么,维护、更新全局top-k列表的时间复杂度为(ON+(hkpexp·Tcom_))k.因此,更新网格索引的复杂度为O(N),检查更新微初始化用户个性化top-k列表的复杂度为Tcom_k=O(klogk),而每次平均有ktop-k列表中,因此更新用户个性化top-k列表的复杂度为Ok列表的复杂度为O(pexp·klogk).那么,推荐和更新用户个性化top-k列表的时间复杂度为((OUkl2logk+pexp·Tcom_6实验分析实验代码用Java语言实现,实验环境由一台Windows7旗舰版操作系统、双核5.6GHz英特尔处理器、4GB内存的PC组建.6.1实验环境和相关参数实验数据是Twitter上从2006年10月到2009年11月的部分数据[23],共有465K用户以及他们在这三年中发布的所有微博,约2500万条,这些数据被保存在PostgreSQL数据库系统中,表4总结了实验参数设置以及各参数的含义.为了评价用户感兴趣微博实时推荐方法的有效性,我们邀请了5位志愿者标注数据.他们首先选择偏好(由于我们采用完全替代型效用函数对用户偏好进行建模,因此边际替代率就决定了效用函数的用户个性化列表长度5用户感兴趣微博列表的长度特征数滑动窗口长度格子数量top-k列表长度100全局top-k列表的长度用户偏好数用户数量微博数量边际替代率形式,不同用户偏好对应的效用函数如表5所示,其中变量a表示两个数值特征间的边际替代率[20],变量x1到x7分别为标准化后的被转发次数、被回复次数、信息量、微博数、粉丝量、关注量以及组数,它们表示了微博的受欢迎特征或者用户在社交网络中的影响力特征),再对我们算法推荐的微博进行标注.对特定的效用函数,每位志愿者标注5次推荐结果,每条推荐的微博被标注成相关或者不相关.用户偏好被转发较多的微博ax1+x2,a>1被回复较多的微博ax1+x2,a<1影响力较大的微博∑7为验证本文中实时个性化推荐方法的效率和有效性,我们设计了一个基准方法.该基准方法在计算全局top-k列表阶段实现了Nave方法,而在推荐微博阶段不考虑用户兴趣直接返回全局top-k列表中前k条微博给用户,我们分别用Nave和CT来表示基准方法和本文提出的实时个性化推荐方法.同时,本文采用以下度量对这两个方法进行比较:(1)时间开销,衡量用户感兴趣微博推荐方法的时间开销;(2)平均准确率的均值,衡量用户个性化微博推荐的平均准确率的均值;(3)平均正确率@K,衡量用户个性化微博推荐在第K个位置上的平均正确率;(4)T-检验(T-test),从统计学角度衡量个性化推荐方法的有效性.6.2实时个性化推荐方法的效率在考察用户感兴趣微博推荐方法的效率时,我们连续运行微博推荐方法一个小时,滑动窗口每秒滑动一次,记录每次响应系统更新的时间开销,最后平均3600次更新的时间开销来度量Nave和CT方法的效率.图8通过变动格子个数和特征个数展示NavePage10和CT方法以毫秒度量的时间开销.图8(a)中横轴表示格子个数的变化,纵轴表示时间开销.从图中可以看出,随着格子数量不断增加,CT方法的时间开销在不断减少.原因在于格子越多会导致每个格子中索引的微博数量越少,从而缩短从索引右上角区域的格子中找出全局top-k列表的开销.而Nave方法不仅每次都要更新左下角格子中的最高分数,还需要对所有格子中最大分数进行排序,需要消耗更多的时间.图8(b)中横轴表示微博特征的个数,纵轴表示时间开销.不难发现,随着微博特征的增加,待访问格子的数量也会增加,导致CT方法的时间开销在不断增加.实验结果表明,CT方法可在1s内完成,具有较高的执行效率.图9实时个性化推荐方法的时间开销图9通过变动其他参数展示了Nave和CT方法的时间开销.图9(a)中横轴表示了用户数量的变化,纵轴是以毫秒度量的时间开销.不难看出,随着用户数量的增加,待推荐微博列表不断增加,从而导致推荐方法的时间开销增加.图9(b)中横轴表示每秒更新微博的数量,纵轴是以毫秒度量的时间开销.容易发现,随着更新微博数量的不断增加,全局top-k列表中微博更新频率也在增加,从而导致推荐方法的时间开销不断增加.由于多数微博都被索引在左下角的少数格子中,Nave方法的效率要比CT方法差很多.图9(c)中横轴表示了全局top-k列表长度的变化,纵轴是以毫秒度量的时间开销.不难发现,随着全局top-k列表长度的不断增长,算法需要扫描更多的格子,从而导致推荐方法的时间开销在不断增加.图9(d)中横轴表示用户top-k个性化微博列表的长度,纵轴是以毫秒度量的时间开销.容易发现,随着用户top-k列表长度的不断增加,得益于算法只维护很少的热门微博,推荐方法的时间开销几乎是不变的.图9(e)通过变动滑动窗口的长度展示了用户感兴趣微博推荐方法的时间开销,其中横轴表示了滑动窗口长度的变化,纵轴是以毫秒度量的时间开销.不难发现,当滑动窗口的长度变长时,在网格索引中,每格中索引的微博数量不断增加,从而导致计算和更新用户个性化top-k列表的开销增加.与CT算法相比,Nave方法需要更多时间更新左下角格子中的最高分数.图9(f)通过变化用户效用函数的个数展示了推荐方法的时间开销,其中横轴表示用Page11户效用函数个数的变化,纵轴是以毫秒度量的时间开销.该图展示了随着用户效用函数个数的增加,维护最热门微博列表的个数也在增加,从而导致推荐方法时间开销的增加.6.3实时个性化推荐方法的有效性图10表明了CT方法的有效性.图10(a)和图10(b)的横轴表示效用函数中边际替代率的变化,纵轴是推荐结果的平均准确率的均值,其中图10(a)展示了第1组效用函数边际替代率变化时10个推荐结果的平均准确率的均值的变化情况(2位志愿者选择第1组偏好,对每个效用函数,每位志愿者标注了5次个性化推荐结果),而图10(b)表明了第2组效用函数边际替代率变化时5个推荐结果的平均准确率的均值的变化情况.从图中不难发现,随着边际替代率的变化(运用不同的效用函数图10实时个性化推荐方法的有效性7小结社交网络服务不仅需要处理海量、实时的流数据,而且还要响应用户多样化的服务请求,例如YouTube的个性化视频推荐和Facebook的图搜索.然而大多数社交网络服务并未充分考虑用户多样化的个性需求,导致服务质量受限.微博是一类典型的社交网络服务,它体现了当前社交网络服务的海量性、实时性和个性化等特点.因此,在微博系统上提供个性化服务是一个非常有挑战的任务,这正是本文研究的出发点.我们用流数据模型对微博系统上微博的更新和过期进行建模,运用流数据上基于滑动窗口模型的实时top-k查询来响应微博系统上实时热点微博的推荐.为了响应用户个性化的服务请求,我们基于LDA主题模型推断微博的主题分布和用户的兴趣取向,在实时热点微博中选择用户最可能感兴趣的微博推荐给用户,从而实现了微博平台上微博的实时个性化推荐.最后,我们利用真实数据验证实时个性化推荐方法的有效性和高效性.对用户偏好进行建模),全局top-k列表中的微博可能不一样,从而导致最终推荐结果的不同.但根据平均准确率的均值,CT方法的有效性比Nave方法好很多.图10(c)的横轴是位置K的变化,纵轴是25次推荐结果中相应位置的平均正确率.此部分综合3组用户的不同偏好,考察本文提出的推荐方法的平均正确率,其中第1组和第2组的边际替代率分别取3和0.4(因为在图10(a)和图10(b)中当边际替代率分别取3和0.4时平均准确率的均值最高).容易发现,随着位置K的变化,本文提出的方法平均正确率达到0.6以上;此外,CT方法比直接返回全局top-k列表中k条微博的正确率要高很多;同时,在置信水平为0.05的情况下,T-test检验的结果表明CT方法的有效性显著优于Nave方法.
