Page1UWSN中基于随机游走模型的可靠路由算法研究1)(东北大学信息科学与工程学院沈阳110819)2)(沈阳理工大学信息科学与工程学院沈阳110159)摘要UWSN(UnderwaterWirelessSensorNetworks)相较于传统的无线传感器网络采用了声信号进行数据传输,由于高传输延迟的引入,冲突类数据丢失现象凸显,网络可靠通信面临全新的挑战.为了在这样的环境中实现低消耗、高可靠网络通信这一目的,文中设计了一种最小化冲突概率路由算法MCR(MinimumConflictprobabilityRouting).该算法融合了网络节点的度值和节点工作负载,形成了一种全新的路由策略DBM(DegreeandBuffbasedMetric).在该路由策略基础上,采用图论中的随机游走模型对源节点与sink节点之间的路径进行选择.MCR算法的核心思想是选择两点之间冲突概率最低的路径完成数据传输,虽然该算法不能从Mac层解决冲突类丢包问题,但是从基于NS-2的仿真实验结果来看,在UWSN环境下,MCR算法相较于传统路由算法有效地减少了路径中的冲突类丢包概率,提升了端到端链路可靠性、具有较高较稳定的网络吞吐量.关键词水下无线传感器网络;数据冲突;路由策略;路由算法;物联网1引言地球71%的表面被海洋所覆盖,这些未被探索的区域内蕴含着丰富的资源和未知的可能性,与陆地的探索进度相比,对于海洋环境的了解,人类仍停留在一个初级阶段.随着沉船探索等一系列水下探索行为的开展,人们对海洋等深水环境的关注程度也与日俱增.但是深水环境中充满着不确定性和危险,很多区域是人类无法涉足的,例如马里亚纳海沟最深的地方有10000多米,一些特制的探测仪都会被高水压破坏,并且单个探测仪器探测区域受限、探测成本很高.在这样的一个形势下,人们开始考虑将无线传感器网络应用在该深水环境下,形成一种水下无线传感器网络UWSN(UnderwaterWirelessSensorNetworks)[1-5].水下环境与陆地环境之间存在很大的差别,例如电磁波无法传输、节点易受水流影响而发生位移等,这些物理特性使得传统无线传感器网络无法直接应用于水下环境.在传输媒介上UWSN采用声频信号取代原来的电磁波,使得节点之间能够通过无线的方式进行远距离通信,解决了电磁波的局限性,但是传输媒介的改变导致了水下无线传感器网络很多关键技术需要重新设计.声音传播的速度与电磁波相比少了5个数量级,两节点之间的信号传输延迟上升到了秒级,这不但使得传统的一些路由算法变得低效,也使得传统无线网络中类似隐藏终端的冲突丢包问题变得凸显[6].水下无线传感器面临的这些问题对研究者而言是一个全新的挑战,本文的主要工作是针对UWSN中冲突类丢包现象提出一种高效、高可靠的路由算法,提高UWSN的网络传输性能.传统WSN(WirelessSensorNetworks)中,路由算法往往会先建立好源节点到目的节点的路径,当源节点有数据需要发送时,它仅仅按照路径的设定将数据包发送给下一跳节点,下一跳节点也会按照路径继续将数据向后传输,通过这种方式,数据包最终会被传送至目的节点.这种路由协议的主要任务是建立路由,一旦路由建立成功,则每个节点按照路由的标定进行传输即可,AODV就是一个经典算法,通过REQ探测包建立源节点与目的节点间跳数最少的路径,这种路由协议中的路径建立需要正向路径和反向路径的闭环通信成功才能完成,在UWSN中,丢包现象严重,闭环通信成功的几率很低,成功建立一次路由需要大量探测包和时延.此外,即使成功建立了一条路由,该路由的性能和寿命都不确定.在UWSN中直接应用传统的路由算法将会导致低效的性能,这在后文中的实验中将会进一步描述.UWSN环境恶劣,需要快捷有效的方法才能获得较高的路由性能.常用的算法往往是基于位置信息的定向扩散,当源节点有数据要发送时,中继节点即时地通过路由计算方法计算出最优的下一跳,并将数据发送给这个下一跳.对于这样的协议,不需要花费大量的能量、时间去建立或者维护路由信息.这类协议中的最关键问题是如何设计算法实时地找到最优的下一跳.一些路由协议采用广播技术和地理位置信息来计算下一跳,这样的路由协议比较适用于移动性较强的网络中,但是在路径的QoS服务性能方面欠缺考虑,并且对于大规模网络往往是通过局部算法进行计算,最终可能导致数据无法到达目的节点,降低了其实用性[7].针对上述问题,本文提出了一种MCR路由算法.UWSN中丢包原因主要有硬件类、冲突类和信号衰减类.硬件类丢包是指由于设备故障造成数据包丢失,冲突类丢包是指信号由于互相干扰造成数据丢失,信号衰减类丢包是指节点由于移动或障碍物阻隔等原因造成信号强度较弱产生丢包[8].本文主要针对UWSN中冲突类丢包进行了研究,基于网络拓扑结构和网络节点工作状态设计了一种路由策略DBM(DegreeandBuffbasedMetric),在此基础上,采用随机游走思想完成UWSN中源节点与目的节点之间的路由建立,降低数据冲突概率,提升网络性能.2相关工作在近几年内,一些针对UWSN的路由算法产生了,大部分协议主要是基于位置信息的[9-12].文献[10]提出了一种H2-DAB,该协议将UWSN从水下至水面分成若干个层,每一层都会有一个sink节点,然后通过两个阶段的工作来完成数据的路由.第1阶段,sink节点通过发送Hello包为每个悬浮节点分配一个动态的ID,每个节点收到Hello包后会更新信息并且继续进行广播.因此,最终每个节点都会获得一个ID,ID的数值和层是相关的,越是深处的节点对应的ID的数值越大.第2阶段,数据包通过这些ID进行传输,数据包总是被发送到较小的ID节点,最终数据包就像物体浮出水面一样会被传送到水面.通过这种协议能够简单地进行数据采集,Page3但是该协议对水下网络拓扑布局有着非常严格的分层要求,并且分配ID也会花费较多的时间和带宽消耗.此外,节点的频繁漂移使得ID的更新要非常及时才能确保可靠通信.为了提升该协议的可靠性,文献[11]基于H2-DAB提出了一种2H-ACK模型.VBF[12]是一种经典的基于泛洪和位置信息的路由算法,每个节点都知道自身的位置坐标,一次数据发送过程内,在源节点的邻居节点中,距离目的节点距离向量最短的节点将会被选为源节点的下一跳.在VBF算法中,数据包可能无法传输到水面上的sink节点,这是因为当网络较为稀疏时,可能会出现一种情况:计算出的源节点下一跳节点,无法继续与后续节点通信.为了提升VBF的可靠性,文献[9]提出了一种HH-VBF协议,该协议为每一个节点都使用了距离向量,和之前的静态源节点至目的节点距离向量相比,具有更高的动态性和可靠性,但是HH-VBF仍属于局部最优求解方式,并不能完全解决VBF存在的问题.针对上述问题,本文提出了MCR(MinimumClashprobabilityRouting)算法.图1显示了一种经典路由算法AODV的流程示意图[13].图1(a)中1号节点是源节点,7号节点是目的节点,1号节点没有1→7的有效路由.当1号节点要给7号节点发送数据时,1号节点会首先通过泛洪方式广播REQ探测包,数据包格式如图1(b),REQ数据包每次被转发时将会更新Path与Hops两个字段.例如当1号节点发出的REQ1到达4号节点的时候,Path字段被更新为1→4,Hops字段被更新为1,这两个字段更新完毕后就会产生一个新的REQ4数据包,4号节点判断自己是否为该REQ的目的节点,若不是,则4号节点会继续广播该新的REQ4.当REQ4到达7号节点时,Path字段被更新为1→4→7,Hops字段被更新为2,与此同时7号节点判断出自己就是目的节点,则7号节点不再广播REQ,而是等待一段时间T,然后开始整理收集到的REQ数据包,并选择Hops最小的路径作为最终路径,若存在多条,则随机选择一条.例如对于图1(a),7号节点最终会获取代表3条路径的REQ:1→4→7,1→5→6→7与1→2→3→6→7,对应的Hops分别为2、3、4,7号节点最终会选择1→4→7作为最终通信路径.为了告知1号节点这条路径的成功建立,7号节点将会按照REQ的逆向路径发送Feedback数据包,与REQ不同,Feedback数据包不是广播而是根据REQ中记录的路径逆向定点传输,与REQ类似,Feedback数据包每被转发一次将会更新Path字段,这样1号节点收到7号节点的Feedback数据包后,就可以从Path字段中提取出建立的路径1→4→7.类似AODV传输协议在传统无线传感器网络中应用较多,其优点在于建立的路径可靠有效,并且可以通过Hops字段选择最短路径,提高通信效率,节约能量.即使网络节点发生变化,也可以通过定期发送REQ更新路由信息的方式解决该问题.与传统的无线传感器网络应用环境不同,UWSN的通信无法通过电磁波进行传递,因为电磁波在水介质中损耗很大.目前在UWSN通信中应用较多的通信方式是声通信,声通信具有如下两个特点[14]:(1)声传播的速度与电磁波传播速度差距较大.(2)声传播的带宽较窄,通信速率较低.UWSN的应用环境较为复杂,各类丢包现象凸显.若在这样的环境中应用类似AODV的传输协议,则会出现不同的结果.在采用声通信的UWSN中,1号节点通过泛洪方式发送REQ继而等待目的节点反馈回来的Feedback对应的过程将会非常“漫长”,大幅度降低了网络端到端吞吐量[15];由于UWSNPage4信号传播速率的降低,网络同步、CSMA/CA等机制无法体现出以电磁波为介质时的性能,网络冲图2隐藏终端问题图2中,1、2、3号节点为4号节点的邻居节点,且1、2、3号节点彼此均不连通,此时当1号节点给4号节点发送数据时,2、3号节点探测到信道仍为空闲,也同时向4号节点发送数据,从而信号在4号节点处冲突,造成数据丢失.目前解决隐藏终端的方法有两种:一种是接收节点在接收的同时发送忙音来通知邻居节点,即BTMA(BusyToneMultipleAccess)系列;另一种方法是发送节点在数据发送前与接收节点进行一次短控制消息握手交换,以短消息的方式通知邻居节点它即将进行接收,即RTS/CTS方式.这种方式是目前解决这个问题的主要趋势,如已经提出来的CSMA/CA、MACA、MACAW等.还有将两种方法结合起来使用的多址协议,如DBTMA.但是上述思路在UWSN中却并不适用,因为UWSN中信号传输时间不可忽略[16],即使4号节点及时发出了忙音,但是2、3号节点可能在忙音到达之前发出了数据[17-18].此外,在高传输延迟的UWSN中很难实现时钟同步,基于时钟同步的隐藏终端解决方法也难以取得较好的收益.为此本文从路由协议设计角度,设计了MCR路由算法,优化端到端的路径选择,降低端到端路径中冲突类丢包发生的几率,提高网络性能.3MCR协议的提出本节主要分为两部分,3.1节主要介绍了DBM路由策略及其相关结论;3.2节在DBM基础之上采突可能性急剧增加,例如隐藏终端冲突现象如图2所示.用随机游走算法形成了MCR路由协议.3.1DBM路由策略本文主要关注的是数据在传输中冲突类数据包丢失问题.UWSN和其他类型的无线通信节点一样,每个节点均具有一个接收缓存RxBuff和发送缓存TxBuff.当节点接收到一个数据包后,该数据包首先会存入RxBuff中,然后按照协议格式解析该数据包,获得信息;当节点想发送一个数据包时,该数据包会被放置在TxBuff中,等待硬件控制信号来进行数据发送.为了简化描述本文将这两个缓存统一标记为B号,length代表缓存的大小,在后文中length可以取两个值:max和actual,其中Bmax存的最大值,该值通常是预先设定的,Bactual节点缓存的实际利用值,表示节点在工作中被占用的缓存空间长度.对于两点之间路径上的信号冲突概率计算有一种方法如下:节点i与j之间有m个中间节点,当节点i向节点j发送数据时,统计这m个中间节点的所有邻居节点数量之和Mum,认为Mum越大的路径对应的冲突概率也越大.但是若两条路径的Mum值相同(例如均为10),其中一条路径的中间节点个数为3,中间节点对应的邻居节点数依次为3、3、4;另一条路径的中间节点个数为2,中间节点对应的邻居节点数依次为5、5,最终的两条路径的冲突概率存在着很大差别,因此上述方法存在局限性.本文将端到端之间链路的冲突概率转变为路径Page5上两点之间冲突概率的乘积.假设路径中有n个中间节点,每个中间节点i的度值为di,节点i成功转发数据的概率为1/di,端到端的成功交付概率的计算方法如下:式中Sn表示由n个节点形成的路径内,在冲突干扰情况下成功进行数据交互的概率.从式(1)可以看出,当转发节点的度值趋于无穷大时,成功转发的概率为0;当转发节点的度值为1时,成功交互概率为1.式(1)属于拓扑层面的概率估计,在实际应用中式(1)存在一个问题,某个节点的度值较大,但是该节点的邻居节点并没有数据要发送,即每个邻居节点均不抢占信道,也就不会与该节点发生冲突,此时若以式(1)进行计算,则计算结果和实际情况将会出现较大差别.针对上述问题,本文将邻居节点的工作状态引入到了式(1)中.UWSN中难以实现时钟同步,基于时隙分配的节点工作机制难以执行,本文研究认为UWSN中的节点均采用自由竞争的方式抢占信道,即当某个节点发现发送缓存中有数据需要发送,则通过自由竞争的方式进行数据发送,若没有数据需要发送,则进入节能休眠状态.缓存占用率能够标示节点竞争信道的频度,频度影响着冲突概率,因此本文引入了缓存占用比率的概率进行修正.图3描述了一条通信路径1→2→3,这条路径存在两个转发过程:1→2与2→3.为了简化分析,本文做出如下两点假设:(1)冲突发生在转发过程中的接收端(本文主要针对隐藏终端类冲突问题),例如本文称转发过程1→2中的转发节点为2号节点,该转发过程的成功率称为2号节点转发成功率.(2)1号节点向2号节点转发数据后将不会成为2号节点的干扰源,2号节点的干扰源是指除了转发过程中源节点外的其他邻居节点(因为通常1号节点转发数据后需要收到2号节点的应答才会继续发送数据,之间有良好的协调).依据上述两点假设,可认为干扰源a、b并不会对这条路径进行干扰,在转发过程1→2中,成功概率等于1减去2号节点干扰源干扰的概率,并且2号节点的干扰源不包括转发源节点1号节点,以此类推可以得出节点i的转发成功率Si的计算方法:式(2)中di是节点i的度值,取值范围为1到无穷大之间的正整数,l表示节点i的邻居节点逻辑编号.依据假设1可知,节点i是指一条路径中除源节点外的其他节点,例如图3中的2、3号节点.当di为1时,即两点通信,依据假设2可知转发成功率为1.即使转发节点i的度值为无穷大,若干扰节点中缓存占用比率均为0,则i节点转发数据成功率仍为1,缓存占用率与度值共同决定了i节点转发成功率.DBM路由策略定义:在一条路径l中,有n个节点,则该路径的DBM值计算方法如下:式(3)中,除源节点外还有n-1个转发节点.通过式(2)、(3)可以看出,当两个相邻的节点i、j进行i→j数据转发的时候,可以总结得出如下几点结论:(1)当节点j的邻居节点数目趋于无穷大时,若每个邻居节点的缓存占用率均为1,则转发过程i→j成功的概率也将趋于0.(2)当节点j的邻居节点数量趋于无穷大时,但是每个邻居节点的待发数据量均为0时,此时转发过程i→j的成功概率为1.(3)无论节点j的邻居节点数量多少,邻居节点中的待发数据量是多少,转发过程i→j均是有成功概率的,可以趋于0但是不会等于0.(4)当节点j有m个邻居节点,且每个邻居节点的缓存均为满负荷状态时(即程i→j成功的概率为1/m.由式(2)、(3)可知,DBM受缓存占用率影响,而缓存占用率会随着时间的推移而改变,因此通过DBM策略选择的路由可能并不是当前网络最优的路由.降低该可能性的方法主要有如下两种:(1)和AODV协议中周期发送REQ探测包维护路由的时效性一样,本文可以周期地通过单跳hello包更新各个节点对应邻居节点的缓存占用Page6率,使得DBM值具有较高的时效性,从而降低上述现象发生的可能性.相应地,网络带宽消耗也会增加,因此需要结合具体网络设定恰当的更新周期.(2)规范网络布局和节点的数据采集流程.UWSN主要功能是周期采集数据,若能够对节点布局和数据采集进行规范化,则在任何时刻网络中各个节点的缓存占用率均可以通过数学推导形成占用率与时间的函数,从而降低上述现象发生的可能性.但相应地计算复杂度和布设成本将会随着网络规模的增加而增加.3.2MCR协议上文介绍了DBM路由策略的概念及其计算方法,本节主要介绍如何将该策略应用于路由算法中.图4描述了UWSN的一种网络布局,UWSN网络中存在一个sink节点和若干普通节点,sink节点通常具有较高的性能,通常被放置在水面上,主要负责收集UWSN中的普通节点采集到的数据并通过GPRS等服务将这些数据转发至Internet.普通节点打开电源后开始进行数据采集,采集到的数据会存入自身缓存中,等待竞争信道向sink节点发送数据.对于网络中的一个普通节点,当其工作时并不知道通过哪条路由才可以将数据传送到sink节点,此时需要进行路由建立.UWSN环境中冲突干扰频繁,图5邻居信息表ToNi的结构示意图为了防止广播风暴的发生,可以设置REQ的生命周期为Lhops,REQ每被转发一次L就会减1,当L值为0时,REQ不再被发送,且广播中通过ID标志解决循环广播问题,即当REQ被节点i发到节点j,则节点j广播后i将不会接收.例如在图4在这样的不稳定环境下,若想获得一条性能较高的路由,通常有如下两种思路:(1)通过周期广播足够数量的探测包对路由质量进行评估.(2)基于网络相关参数的计算进行路由质量评估.UWSN中的传感器节点对数据的采集通常是规律性的行为,即缓存中数据的增长速率是相对稳定的;尽管网络会出现变化,但总体来看拓扑结构仍是相对稳定的.因此,上文的DBM计算结果也会相对稳定.DBM策略带宽消耗主要集中在基于一跳hello包的邻居信息采集上,在后续的路径建立过程中源节点只需要发起一次路由建立请求REQ广播就可以完成路由建立,避免了类似AODV协议中的Feedback数据包导致的带宽消耗(在UWSN中,REQ与Feedback反馈包均成功被交付的几率很低,因此AODV协议在UWSN中将会导致大量带宽消耗).综上,采用DBM对路由质量进行评估相比于传统路由协议能够在减小一部分带宽消耗的基础上获得较为稳定的评估结果,具有较高的实用性,为此本文选择了方法2.图4中,当7号节点有数据需要发送给sink节点时,7号节点发起一次路由建立请求REQ广播,REQ数据报文格式和图1(b)基本一致,但是在hops字段后增加了邻居信息表ToNi字段,邻居信息表如图5所示,该表属于链表结构,记录了接收到REQ节点的邻居节点ID和邻居节点对应的缓存占用率,该表的建立主要通过周期发送hello包,hello包只有一跳的寿命,通过hello包除了能获得ToNi同时也能及时发现邻居的变化,发送周期并不需要太频繁.当网络中某个节点接收到REQ后,会将自己的邻居信息表添加到REQ中的ToNi字段中,然后将更新后的REQ继续向前传递,ToNi字段对应的链表内容也会逐渐增加.中,由7号节点发起一次REQ,将L设置为3,则这次REQ广播涉及到的节点ID分别为1、2、3、4、5、6、7.依照这种REQ机制,最终sink节点会得到一个全面的ToNi字段,并进行路由选择计算.为了简化描述计算过程,本文假设图4中所有节点的缓存Page7占用率均为50%,L=3,7号节点向sink节点发送的REQ数据包将会涉及到1~7号节点,各节点度值和缓存占用率见表1.由3.1节介绍可知,当节点i向节点j发送数据时,节点j是该过程的转发节点,式(2)中,只考虑了节点j的转发成功率,并没有考虑节点i与节点j的连通关系,当节点i与j不连通时,无论节点j转发成功率多大,则i→j过程的转发成功率均为0.为此,对式(2)进行了修正,设i→j转发过程的成功率为Spj,则该成功率的计算方法如下:其中Si的定义见式(2).式(4)的核心思想是节点j的度值和邻居节点的缓存占用率一旦确定,则节点j转发数据的成功率也将确定,无论是哪个源节点与j通信,转发成功率均相同,但是若某个节点与j不相连,则j转发该节点数据的成功率为0,通过邻居信息表内容可以容易地判断出两节点是否相连.通过式(4)可以计算出网络中任意两点间的转发成功率,并形成一个M×M的矩阵犔量),结合随机游走理论模型,可以计算出从源节点出发到达网络中任意节点(包含sink节点)的成功概率,计算方法如下:~f其中,犛s出发经历f(f0)步随机游走后,到达网络中其他节点的成功概率.依据上文给出的转发成功概率定义可知当f=0时,犛除了源节点对应的位置为1,其他均为0.为了更直观理解MCR协议原理,本文给出了随机游走算法在路径搜索中的具体操作细节:(1)结合网络拓扑中各节点度值与各节点邻居节点的缓存占用率,形成一个M×M的矩阵犔(2)依据数据源节点的ID号,形成一个初始矩~0阵犛s.(3)依据网络规模或者经验值,设计好随机游走的步数f.(4)基于式(6),可以得到f步随机游走之后,源节点到达网络中各个节点的成功概率,概率值将会被存储在矩阵犛以图4为例,设7号节点为数据源节点,该节点将会产生数据,并要将数据传至sink节点.设REQ的生命周期为3hops,节点相关参数见表1,节点4为sink节点,也就是REQ的目的节点,则7号节点与sink节点间各条路径转发成功率的计算流程如下:~~17=犔犛ID1234567烄node1\1×node21×node31×烅node4001×node50001×node6001×烆node7000001S0烄S07→107→20S07→30S0烅S07→407→50S07→60S0烆7→7式(7)中,nodei行代表节点i的成功转发概率,1~7代表节点序号,例如节点1转发节点2或3的成功概率均为7/12.S0时到达各个节点i的成功率.因此7号节点通过1跳(即1步随机游走)到达各个节点的成功概率计算结果见式(7),不难看出7号节点在1跳到达4号节点的成功率S17号节点将会存在成功传输给sink节点的概率,因此为了简化描述,本文直接计算3跳后7号节点成功交付数据给网络中其他节点的概率矩阵,计算结果如下:Page8~2犛7=犔~×~3犛~7=犔×S2烄S27→6→107→6→20S27→6→3S2烅7→6→40S27→6→5S27→6→6\S2烆7→7→7式(8)中类似S3为路径标记Pm(Pathmark),代表3跳后,7号节点到达1号节点的路径有两条,分别为7→6→3→1(成功概率为35/144)和7→6→5→1(成功概率为0,因为5和1不相连).Pm对应的路径若满足如下条件之一的时候,则该路径对应的成功转发率标记为无意义———“\”:(1)路径存在闭环,则该链路记为“\”(例如式(7)中的S17→7和式(8)中的S2(2)若干个“\”的和等于“\”.(3)“\”+X(非0且非“\”)=X.(4)“\”+0=“\”.“\”标记也能有效预防算法复杂度随着REQ生命周期L值的增加而无限增加的情况.通常L值不应该被设置为较大的值,一方面会增加计算复杂度,另一方面也会造成多跳路径的不可靠性增加.在上例中,可以看出当f=0、1、2时,节点7与sink节点之间的路径转发成功率均为0,这是因为在2跳之内,节点7与sink节点无法建立连接.当f=3时,Pm为S3(7→6→3→4)(7→6→5→4),其中路径7→6→3→4的转发成功率为5/18,7→6→5→4的转发成功率为6/18.简单比较可以看出路径7→6→5→4的转发成功率较优,则sink节点将会沿着4→5→6→7发送Feedback数据包通知7号节点选择7→6→5→4路径进行数据发送,至此,整个路由选择计算流程就结束了.综上所述,可以形成一种路由建立算法MCR.算法MCR.ProcedureMCR(Source,Destination){1.get_ToNi();//初始化网络,获取网络中各个节点2.Init_REQ(L,f,fmax);//初始化REQ数据包,设3.Form_matrix_犔4.FORf=0tof{犛5.IF(犛6.Send_Feedback(Destination,Source);//目的节7.END}3.3MCR算法的科学意义与理论分析水下无线传感器网络中信号传输延迟较高、节点移动性较强,类似AODV的全局最短路由算法并不具有较高的性能.AODV需要通过大量端到端的探测包来发现路由、维护路由,但是实际上,在高信号延迟、高移动性的环境中这类算法会一直疲于路由发现与维护,减少有效数据的传输量,在后文的实验环节中,该现象非常凸显(每一次路由发现或者维护,都需要进行全路径探测,有效数据传输所占总时间比例很少).MCR算法的本质可以认为是一种概率路由,避免了UWSN环境导致有效数据一直无法传输的现象,从而增加了网络吞吐量.MCR能在路径断开后会重新建立路由,但是与类似AODV算法不同之处在于,MCR发起一次REQ就可以完成路径的建立,而AODV需要多次REQ、Feedback闭环成功才能完成路径的建立(为了确保路径的可靠).从后文中的实验数据来看,大Page9量的探测包存在于网络中反而会增加冲突概率,降低可靠性,MCR在可靠性上具有较高的提升.在步骤4与5中,有两种方法可以建立路由,第1种是sink节点收到一个REQ立即建立一条路径;第2种是sink节点收集到所有REQ后通过随机游走算法建立路径.这两种方法有一个很大的区别,例如在图4中,5号节点给4号节点发送REQ失败了,但是5号节点将自身的邻居信息表通过3号节点传送给了4号节点,则最终的犔留了5号节点的信息,在路由计算结束后,若7→6→5→4对应的转发成功率较高,则该路径不会因为一次偶然的REQ丢失而被忽略,这就是MCR路由算法的一个优势,增加了路由的鲁棒性.4实验分析为了对MCR协议性能进行评估,本节进行了图6节点布局图信道类型衰减模型网络接口类型Mac层协议Interfacequeuetype(ifq)Linklayertype天线类型Maxpacketinifq节点数量(nn)路由协议一系列仿真实验,实验平台为NS-2仿真平台.为了更加直观地描述MCR协议性能,本文引入了典型的源驱动式AODV协议、表驱动式DSDV协议[19]以及UWSN中较为成熟的位置信息驱动VBF算法与其进行性能对比.4.1实验环境在基于NS-2的仿真实验中[20-21],20个节点被均匀放置在600m×450m的矩形区域内,拓扑形状如图6所示,任意相邻两节点间距离均为150m,仿真相关参数详细设置如表2所示.为了使得仿真环境与UWSN的环境接近,进行了一些如下设置:(1)带宽被设置为低速率,带宽值为256kbps;(2)将数据包缓存数量最大值设置成较小值,增加冲突类丢包概率,取值为50;(3)Mac层两节点间的丢包率与距离关系如表2所示,为了模拟UWSN链路的不可靠特性,将节点距离设置为150m;(4)关闭RTS/CTS功能,增加隐藏终端发生可能性.图6中,节点0代表数据源节点,采用的Agent为TCP,节点19代表sink节点,采用的Agent为Page10TCP/sink.仿真时间为1500s,节点0向节点19发送恒定速率cbr数据流,cbr数据包长度为64byte,无发送间隔,发送速率为16kb.图6中的虚线箭头,描述了MCR、DSDV、AODV在仿真过程中的某一时刻建立的路由.4.2性能评价参数本文主要从端到端数据丢失率droprate、端到端数据延迟、端到端数据延迟抖动、网络吞吐量等4个参数对路由协议性能进行评估.具体参数定义如下:(1)端到端数据丢失率.在仿真过程中的各个时间点上记录节点0发出的数据包总数T0,记录节点19接收到的数据包总数R0,则有droprate=T0/R0.(2)端到端数据延迟.设数据包Pi(i为数据包序列号)为节点0成功发送至节点19的数据包,记录每一个Pi在节点0产生的时刻t_start,记录节点19收到来自节点0的Pi数据包对应时刻t_end,则有序列号为i的数据延迟为t_end-t_start.(3)端到端数据延迟抖动[22].设recvTime(j)代表节点19收到序列号为j的数据包时刻,recvTime(i)为节点19收到序列号为i的数据包时刻,i和j是节点19收到的相邻数据包序号,则有数据延迟计算公式如下:Jitter=(4)网络吞吐量.记录节点19在经历t秒时,收到的有效数据总比特数目sum(t),则有吞吐量为sum(t)/t.4.3实验结果分析(1)端到端数据丢失率分析在仿真实验中,REQ数据包的寿命均被设置为5跳,图7给出了3种路由算法对应的丢包率.图7中横坐标表示仿真记录的时间点,横坐标空缺表示在仿真过程中该时刻点没有对应任何行为.从图7中可以看出AODV和DSDV相似的丢包率没有明显的规律,这是因为AODV和DSDV均考虑最短路径,因此在丢包率上没有必然的趋势,这和路径选择的偶然性有关.MCR的丢包率一直较低,这是因为MCR算法基于节点缓存和度值考虑了路径转发成功率,会选择干扰源较少的路径,在对AODV和DSDV的trace文件分析中发现,数据丢失主要有两个原因:①数据冲突,占39.3%;②路径损坏,占51.7%.而在MCR的trace中,数据冲突占18.4%,路径损坏占45.2%.可以看出MCR丢包率的降低主要受益于冲突类丢包的减少.VBF算法的核心思想是在源节点通信范围内寻找与目的节点位置最为接近的节点作为下一跳,并以此类推直到数据被交付至目的节点.在图6规则布局网络中VBF算法与MCR算法相似,具有较低的丢包率,并且算法简单实用,但是VBF算法属于局部最优算法,在不规则的网络拓扑中很容易出现数据在中继过程进入“死胡同”的现象,无法找到下一跳,此时数据将会丢失.在图7中还可以看出,在0~150s之间,AODV和DSDV的丢包率均为1,数据在150s后才开始正式传输.通过trace文件分析发现,在前150s内AODV和DSDV一直处于频繁路径建立阶段,经历了很久的REQ广播,建立了一条链路,结果很快就发现该链路被损坏,又需要重新建立.VBF算法在一开始需要通过广播收集各个节点的位置信息,每个节点需要知道自己通信范围内各个邻居节点的位置信息,这个过程需要消耗一部分时间,从图7中可以看出,大概消耗了100s左右.而MCR算法并不完全依赖REQ和Feedback构成的环路,通过随机游走的方法,即使有一些REQ或Feedback在传输过程中丢失了,也不会造成路径丢失(见本文3.3节),因此,更能快速全面地完成有效路由的建立.(2)端到端数据延迟分析图8中横坐标是某个数据包产生的时刻,纵坐标代表该时刻产生的数据端到端延迟大小.横坐标的空缺代表着在仿真实验中该时刻点上节点0没有能够成功将数据传输给节点19.通过图8可以看出在成功发送的数据样本中,MCR的端到端延迟较高,而AODV、DSDV、VBF的端到端延迟较为相似,这主要是因为AODV、DSDV、VBF均偏好选择Page11跳数最少的路径,在数据传输过程中跳数是影响端到端延迟的一个重要因素,因此AODV、DSDV、VBF对应的延迟较低;而MCR没有考虑跳数问题,在路径选择过程中可能会选择一条跳数较大的路径,从而增加了延迟.图8还显示了AODV、DSDV、VBF对应的横坐标相比于MCR空缺很大,这表明在仿真过程中AODV、DSDV、VBF的实际成功数据交付只是出现在几个短暂的时间区间上,空缺的地方代表网络一直在建立路径或者是传输失败.产生这个现象的主要原因是AODV、DSDV、VBF偏好追求最短路径而没有考虑路径传输的可靠性和干扰源,从而导致不论在路径建立阶段还是数据传输阶段频繁出现数据包丢失.此外,图8与图7是可以对应上的,例如在图7和图8的1200s附近,图7的DSDV算法丢包率之所以能够急剧下降,是因为图8中DSDV算法在1200s附近成功交付了大量数据.(3)端到端数据延迟抖动分析节点19接收到数据包的序号排序可能与节点0发送的数据包序号排序不同,例如节点0发送序号为{1,2,3},而节点19接收到的序号可能为{3,2,1}.根据端到端延迟抖动的定义可知,jitter值可能出现正值也可能出现负值.jitter值可以反映网络的稳定性,若jitter值较大,则可以认为链路在某个地方出现拥堵,网络不稳定.图9中的jitter数据有很多看起来很接近于零,但是实际上并不为0,因为NS-2仿真实验中,数据包的时间间隔非常短,基本是在毫秒级,因此计算出的jitter值看起来才会很小.图9的横坐标是成功交付数据包的序号,在NS-2仿真中,AODV与MCR协议的数据包序号与有效数据绑定,即路由层的ARQ、relpy等数据不会导致序号增加,而DSDV、VBF与AODV、MCR不同,路由层的message会使序号增加,因此图9中的DSDV数据包序号要比AODV序号大很多,实际上两者传输的有效数据量很接近.纵轴是成功接收到的某序号数据包对应的延迟抖动值.由于MCR选择的路径可靠性较高,路由建立和维护时间开销低,因此大部分仿真时间均被用来进行有效数据传输,所以有效传输的数据包数量较大;而AODV与DSDV需要消耗大量时间去建立、维护路由,而且频繁发生数据丢失,导致有效传输的数据量很小;VBF属于源驱动算法,每个节点没有维护路由表,每当一个节点接收到数据包后,总是会计算其邻居节点与目的节点的距离,并选择最为接近的作为下一跳,这导致在数据通信过程中消耗一些时间,导致有效数据传输的时间变少.从图9中还可以看出在成功传输的数据样本中,AODV和MCR对应的延迟抖动较为相似,而DSDV、VBF对应的延迟抖动较小.这是因为DSDV属于表驱动路由协议,在一次路径确定和下一次路径更新之间,不再会有路由搜索行为,数据将会严格按照确定的路由进行传输,即使多次发送失败也不会随意改变路径;VBF算法在整个通信过程中几乎没有多余的探测包消耗,在规则拓扑网络中出现数据交付失败的概率也很低,避免了数据重传的现象,因此延迟抖动较小,但在不规则网络中,很可能会因为数据回传造成大量数据拥塞,导致较高延迟抖动;而AODV和MCR属于源驱动路由协议,一旦发现路径不可用则立刻会发起REQ广播进行路径寻找、建立,从而为网络注入了大量探测包,使得网络的正常数据传输变得不稳定.(4)网络吞吐量分析吞吐量是衡量一个网络性能的重要参数,吞吐Page12量的大小、吞吐量的稳定性,对网络应用具有重要的指导价值.图10的横坐标是仿真过程中记录的时间点,纵坐标是各个时间点上统计的节点19与节点0之间的端到端网络吞吐量,单位是kbps.从图10中可以看出AODV协议在200s附近时有一个吞吐量峰值,这和图7相对应,AODV协议在200s附近的一段时间内,成功交付率很高,此时的吞吐量也随之上涨,随着仿真时间的推移,AODV的交付率逐渐降低,并且网络上大量时间消耗在路径探索和维护上,有效数据传输量越来越少,从而导致AODV网络吞吐量急剧下降.DSDV吞吐量一直处于极低的状态,虽然在1200s时的交付率较高,但是由于仿真时间基数已经很大,因此最终吞吐量结果仍然很低.VBF吞吐量一直较低,这主要是因为VBF每次传输数据时总是会消耗一部分时间来计算各个节点与目的节点的距离.相比于AODV、DSDV、VBF,MCR具有较稳定的吞吐量,这主要取决于两方面:(1)MCR协议降低了冲突类数据丢包概率,提高了端到端数据包交付率;(2)MCR在整个仿真时间内,在路径建立、维护方面只消耗了较少的一部分时间(不需要等待REQ和Feedback构成环路就可以计算出有效路径),大部分的时间均被用来传输有效数据.因此MCR在吞吐量性能方面优越于AODV、DSDV、VBF.5结论本文针对水下无线传感器网络的物理特性,设计了一种最小化冲突概率的路由算法MCR,该算法综合考虑网络中节点的度值和通信负载,融合随机游走思想,为数据的传输选择了一条冲突概率较低的路径.基于NS-2仿真平台分别对AODV、DSDV、VBF和MCR路由算法进行了实验评估,并得出以下几点结论:(1)在UWSN中,冲突类丢包在丢包总数内占据很大比例,MCR算法能够有效避免冲突类丢包,相比于其他两种具有更低的丢包率;(2)由于MCR算法没有选择跳数最少的路径,因此在端到端延迟性能上不如DSDV、AODV与VBF;(3)AODV、MCR相比于VBF、DSDV协议会不定期的进行路径探索和维护,因此在延迟抖动性能上AODV、MCR不如DSDV、规则拓扑下的VBF;(4)相比于AODV、VBF、DSDV,MCR具有更高和更稳定的网络吞吐量,这主要是因为MCR的丢包率较低,并且大部分仿真时间MCR均处于有效数据传输阶段,而AODV与DSDV大部分仿真时间花费在路径探索和维护上,并且丢包现象严重,VBF没有维护路由表,导致每次数据转发时均需要消耗一些时间来计算最优下一跳;(5)MCR采用随机游走思想进行路由计算,相比于AODV和DSDV,MCR协议无需等待REQ和Feedback构成回路(在链路较差的环境中,很难构成回路)就可以完成路径建立,路由建立速度更快;(6)MCR算法并不会因一次REQ或者Feedback的丢失而导致一条路径被忽略,具有更鲁棒的路径发现性能.UWSN与传统WSN不同,由于通信环境的改变,冲突类丢包现象剧增,MCR针对该现象进行了路由策略和路由搜索算法的设计,在丢包率、吞吐量等方面获得了收益,但是在延迟和延迟抖动方面仍存在不足.实验仿真环境主要是面向UWSN构建的,在其他环境下性能对比结果如何,是本文下一步的工作.此外,UWSN中,除了冲突类丢包,还有链路质量不稳定导致的丢包,如何全面地考虑各种丢包因素,进一步提高MCR协议的性能也是本文的下一步主要工作.致谢感谢辽宁省面向先进装备制造业的嵌入式技术重点实验室对本论文的实验平台支持.感谢辽宁省教育厅对本论文的项目经费支持!
