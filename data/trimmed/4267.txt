Page1一种适合于超大规模特征集的匹配方法杨天龙张宏莉(哈尔滨工业大学计算机网络与信息安全技术研究中心哈尔滨150001)摘要串匹配技术是入侵检测系统中的关键技术,随着特征数量的增加,现有的自动机类匹配算法都会面对内存占用过大的问题.当特征超过一定数目后,自动机可能根本无法构造.文中提出了一种针对超大规模特征匹配(SLSPM)环境的匹配算法SLSPM.SLSPM算法借助一个块式匹配自动机和若干个普通自动机完成匹配工作,而且能够支持至少上万规模的特征集.与普通匹配自动机先读入状态再判断读入符号的方式不同,SLSPM首先使用散列函数判断当前文本块是否可以被过滤掉.如果文本块无法被过滤且为合法文本块时,再检查当前状态是否是一个能够识别当前文本块的状态.仅在当前状态吻合的情况下再读入下一个文本块进行后续匹配.理论证明显示SLSPM算法具有近似O(n)的复杂度.由于SLSPM算法未能保存全部的跳转信息,其匹配速度相对于高级Aho-Corasick算法未有大幅提升.算法的优势在于,该算法在软件环境下能够维持与AC算法相同的匹配性能,而且能够将特征加载规模至少提升至上万以适应超大规模特征集匹配环境.关键词网络安全;超大规模特征匹配;串匹配;混合自动机;算法;信息安全1引言字符串匹配可以被理解为从给定符号序列中找出一个具有某种属性的模式,最简单的例子是从给定字符序列中找出一个给定的字符串.字符串匹配是计算机科学中最古老、研究最广泛的问题之一,并且,字符串匹配的应用随处可见[1],比如生物领域和计算机科学中.本文专注的是计算机科学中的串匹配问题,更确切地说是应用于入侵检测系统(IDS)中的串匹配技术.IDS中常用的串匹配技术包括AC[2]、AC_BM[3]或者WM[4],虽然这些算法在IDS系统中得到了很好的应用,但是当处理的特征集的规模十分巨大,并且特征之间缺少共用前缀时,自动机类型匹配方法对内存的需求就会急剧上升,甚至会出现由于系统内存无法满足算法对内存的需要导致自动机无法加载(主要是AC类的自动机)的现象.当特征集规模过于巨大时,即便内存能够得到满足,但是由于自动机本身占用的内存量较大也会导致在线匹配性能的下降.为了解决AC类自动机在大规模级别特征集环境下性能差的问题,研究者们提出了许多降低自动机内存占用量过大的方法,比如公用路径分析[5]、位并行自动机[6]或者字节并行自动机[7].公用路径分析方法[5]通过寻找特征间共用的特征子串减少自动机中的状态数目;位并行[6]和字节并行[7]通过调整匹配过程输入的匹配信息的比特数目或者字节数目间接地减少自动机中的状态数目.它们的核心思路都是通过降低自动机中节点的数目来降低自动机的整体内存.由于公用路径方法对特征集的结构要求比较高,当告警集中缺少共用特征子串时该方法无法有效抑制自动机对内存的需求.为了使算法更加适用于通用化的特征集合,本文将采用字节并行作为文中匹配方法的核心手段.另外本文中将大规模特征集匹配问题称为超大规模匹配(SuperLargeScalePatternsMatching,SLSPM),而且所处理的特征集的规模至少1万.针对SLSPM,本文提出了一种类似于Aho-Corasick的自动机,相关的算法被简称为SLSPM算法.该方法在构造匹配自动机前会对特征的跳转信息进行预先处理并形成一份格式化的特征分析文件,随后通过再次读取特征分析文件构造一个内存上更加紧凑的匹配自动机.文中的方法在通常情况下可以O(n)的复杂度处理SLSPM问题,其中n代表文本的长度.通常自动机匹配都要为状态构造“状态———读入符号”的映射关系(即goto函数),这样的关系有助于通过自动机状态验证读入符号的情况.而本文中为了加快匹配速度,借助了散列技术,为了适应文中先散列后匹配的方式,本文在构造状态跳转信息时对“状态———读入符号”的关系进行了翻转,即采用“自动机某状态识别的某一符号———识别该符号的状态集合”的映射关系.为了降低匹配自动机占用的内存,本文在同一个匹配系统中采用了块式自动机和普通自动机相结合的混合自动机形式.本文第2节对自动机压缩方法做归纳;第3节介绍一些相关的定义;第4节对算法的基本思路和相关算法进行说明;第5节对算法的实际应用进行测试;第6节对本文中的SLSPM算法存在的问题进行讨论;第7节对全文做总结.2相关研究串匹配的研究已近半个世纪[8],匹配的速度也随着硬件技术的进步和算法的改进得到了提升.然而特征集合中特征数量的增长直接限制了自动机的匹配速度.为了降低匹配自动机对内存的占用,学者们进行了大量的研究.这些压缩匹配自动机的方法可以大致分为两类.第1类,通过分析特征的结构或者统计特性压缩自动机的状态数.比如文献[9]中,把自动机中的失败变迁单独提取出来得到失败变迁图,即失败变迁树(FTT).通过对状态进行编码,每个状态复制给所有子孙状态的实际变迁可以被聚合到该状态自身的变迁中.状态的编码分为2步:FTT的边编码和状态编码.边编码从上到下对FTT各层进行编码.对每一层,首先统计上一层单个状态的出度.状态编码后,FTT上任意一棵子树中所有状态都可以用一个包含通配比特符号“”的Page3编码匹配.文献[10]中,提出一种统计优化型AC算法变体(AX),其对模式数量、模式长度和字符集大小均不敏感.AX算法中主要包含3种压缩:(1)删除压缩.不为每一个无效事件各存储一份失败迁移,而是为整个无效事件集合仅存储一份在节点结构中.事件迁移表中仅存储有效事件及其对应的成功迁移指针.(2)路径压缩.按数组方式存储长链中连续的节点但不存储节点指针,用标识位及相对偏移定位后续节点,取代指针定位,省去绝大多数节点指针;(3)事件定位.引入3个阈值0θαθβθγσ,当θθα时,采用顺序查找;当θαθθβ时,采用二分查找;当θβθθγ时,采用分页位图定位;当θ>θγ时,不进行压缩.文献[5]中通过寻找特征间共用的特征子串减少自动机中的状态数目.第2类,按照一定的度量直接将自动机划分为若干个独立的自动机.这类压缩自动机方法中,通过调整匹配过程输入的匹配信息的基本单位间接地减少自动机中的状态数目.比如文献[11]中的位拆分状态机,将一个完整的状态机按位拆分成为多个子状态机,每个子状态机独立进行工作,只负责检测字符中的一位或几位,当所有子状态机都输出匹配信号时才确定匹配.一个完整的规则检测模块由4个位状态机组成,在检测过程中保持恒定速度.又如Dharmapurikar等人[7]和Hua等人[12]分别采用一次扫描固定步长和变步长的多个字符,提高字符串匹配的吞吐量,并减少其存储空间需求;Tan等人[13]提出了比特拆分的Aho-Corasick算法,Piyachon等人[6]提出了多字节比特拆分的Aho-Corasick算法,Lu等人提出了多字符并行处理的Aho-Corasick算法等,这些并行字符串匹配算法不仅提高了Aho-Corasick算法的吞吐量,而且最小化了匹配自动机的存储空间.通过改变一次读入多字符或者多比特的方法在FPGA中已经有了较多的应用.而且通过硬件环境,这些方法都可以获得较高的匹配速度,比如文献[6]中位并行和字节并行的Bit-ByteAho-Corasick算法在IntelIXP28XX环境中,能够获得5Gb/s的匹配吞吐量,文献[7]中在F=250MHz,片内存储器大小是376Kbits,片外存储器频率是250MHz的FPGA中可以获得10Gbps的吞吐率.3相关定义一棵有根树是一个由单向边连接的节点的集合.每条单向边的源节点称为父节点,目标节点称为子节点.有一个特殊的节点没有父节点,该结点称为根节点.树中除根节点之外的每个节点,都有且仅有一个父节点.没有子节点的节点称为叶节点.如果定义了字符串集合组成的特征集合,那么精确串匹配的作用就是从文本中找出所有特征出现的位置.解决这个问题的最经典的算法是由Aho和Corasick设计的AC[2]算法.该算法借助有限状态自动机,对文本仅扫描一次就能够完成对文本的特征匹配.标准的Aho-Corasick自动机是一个由特征集合中所有特征构成的未经压缩的trie树,我们不妨将这棵树的根节点记作R.对于这棵trie树中的任一个节点v,L(v)被定义为从R到达节点v的路径.L(v)代表了特征集合中一个或多个特征的前缀.如果L(v)是一个完整的特征,AC自动机会在节点v中加入表示终结状态的信息,表示在该节点可以识别一个特征.描述AC自动机的trie树的跳转信息是通过goto函数存储的.通常AC自动机中的每个状态都有一个失效函数,当AC自动机中的状态读入字符后无法跳转到下一个状态时会通过失效函数(尽量)跳转到一个在树的深度上尽量远离R的状态节点,这样可以避免自动机指针的回溯而降低匹配速度.本文中我们仅仅保留AC自动机中的goto函数和终结状态信息,失效函数被省略的原因在文中第四部分有详细的说明.本文中使用P定义特征集;Σ定义为特征集的字符集,和ASCII一致;strlen(x)定义为字符串x的长度.需要特别指出的是,本文中特征集中最短特征长度为4.为了使得描述更加简洁,我们将本文中使用的自动机定义为块自动机或者块式trie自动机.块自动机识别的符号为一个长度为16的字符串.本文中将这种按照固定长度识别的符号称为特征块,将识别特征块的状态称为块状态.为了与块式自动机中的块状态相区别,本文中将经典AC自动机称为普通自动机或者字符自动机,普通自动机中识别单一字符的状态称为字符状态.在不引起歧义的时候本文中部分段落会直接用“状态”表示字符状态,或者直接用“状态”表示“块状态”、“字符状态”都适用的情况.关于将特征最短长度以及特征块长度分别设定为4和16的原因请参考本文5.1节中的说明.本文将识别的符号记为c0c1…c14c15,相应的块字符集被定义为块自动机中状态节点能识别的符号集合,简记作Σblock.对于Aho-Corasick自动机,其字符集大小为|Σ|=256,而块自动机的理论字符集大小为|Σblock|=|Σ|16=25616.本文的算法中PPage4被分成两个集合PL={p|strlen(p)16}和PS={p|strlen(p)<16}.显然PL∩PS=,PL∪PS=P.在本文中我们分别将来自于PL和PS的特征称为长特征和短特征.p∈PL,令strlen(p)=16k+t,k1,0t15,c16jc16j+1…c16j+14c16j+15称为p的特征块,c16kc16k+1…c16k+t-2c16k+t-1称为特征p的尾串.4混合自动机算法的设计与分析为了降低匹配自动机对内存的消耗,本文中,将匹配自动机拆分为一个单一的块式trie自动机和若干个普通trie自动机.长特征的特征块被编码到块trie自动机中,长特征的尾串和短特征被编码到普通trie自动机中.如前所述,一个长度为strlen(p0)=16k+t(p0)的长特征p0,会被分割成若干个不重叠的特征块.和普通trie构造一样,各个特征块被逐一加入到块式自动机中.当最后一个特征块c16(k-1)c16(k-1)+1…c16(k-1)+14c16(k-1)+15被加入块式trie自动机后,自动机会跳到一个已有的(或者新建的)块状态.我们不妨把它称作statex.由于特征p0有一个长度为t(p0)的尾串tail0=c16(k-1)c16(k-1)+1…c16(k-1)+t(p0)-2c16(k-1)+t(p0)-1,本文会在块状态statex后附加一个普通的trie自动机trie(statex),尾串tail0中的各字符会以AVL的形式加入块trie(statex)中.类似于普通trie自动机,如果特征集P中存在长度为strlen(p0)=16k+t(p0),尾串为tail0=c16(k-1)c16(k-1)+1…c16(k-1)+t(p0)-2c16(k-1)+t(p0)-1的长特征p0,且p0和p0共享长度为16k的前缀,那么特征p0和p0会共享块自动机中从根节点到节点statex图1SLSPM自动机中的块状态和字符状态的路径中的所有块状态节点,二者的尾串tail0和tail0也将共享trie(statex).图1是构造SLSPM自动机的一个例子.由于篇幅原因,原始自动机中没有标出相应的失效函数跳转信息,并且没有对自动机中的状态进行编号.假定普通的trie自动机在匹配文本t0t1…tn-2tn-1的过程中,读入字符tx后,0x<n-1,会跳转到一个状态states.当处理下一个字符tx+1时,匹配算法会在当前状态states能够接收的字符集合里搜索tx+1,并根据tx+1的存在与否确定如何进行下一步匹配.本文将这个搜索过程称作确认检查.从理论上我们知道,IDS软件中最广泛使用的AC算法的性能仅在采用完全存储方式[1]下才能够获得线性处理速度(O(n)),之所以能够获得这种线性速度是由于在进行确认检查时可以直接查寻当前状态对应的跳转表,其处理时间为O(1),和当前状态能识别的字符的集合的大小无关.如果采用压缩存储方式,在进行确认检查时势必要将当前状态读入的符号与该状态能识别的所有符号进行逐一比对(n|Σ|),或者使用树型结构对该状态识别的符号集合进行扫描但是仍然需要O(nlog|Σ|)的处理时间.过程1.BlockGoto(len16str,state).输入:长度为16的子串len16str,块状态state输出:块自动机的目标块状态state1.index←hash_compute(len16str)2.在hash_table[index]中确定(len16str,state)的跳转3.IF没有跳转信息THEN4.Goto(len16str,state)←max_state5.max_state++6.ELSEPage57.RETURN目标块状态state8.ENDIF过程2.TailGoto(tailstr,state).输入:长度小于16的子串tailstr,块自动机中的一个输出:尾部自动机的深度strlen(tailstr)1.FOReachi∈[1,len]DO2.ch←tailstr[i]3.添加ch到trie树中4.ENDFOR5.在trie树中为tailstr添加识别信息过程3.JumpStep(len4str).输入:长度为4的子串len4str输出:jumpstep1.FOReachi∈[0,2]DO2.ch0←len4str[i]3.ch1←len4str[i+1]4.j←2-i5.IFj<jump[ch0][ch1].stepTHEN6.jump[ch0][ch1].step←j7.ENDIF8.ENDFOR失效函数在普通AC算法中起到了避免回溯的作用.回溯是指当自动机指针所指的当前文本中的字符无法被当前状态识别时,将自动机指针移动到最近一次从0状态开始比较的字符位置的后一个字符的位置.失效函数的存在加速了AC算法的匹配速度.使用了失效函数的匹配算法其最快匹配时间为O(n+nocc).如果想达到O(n)的匹配时间,需要使用当前状态的失效状态的所有跳转对当前状态无法识别的字符补充跳转信息.形式化的描述:令θ为状态0的失效函数,对于状态0,如果δ(0,σ)=θ,置δ(0,σ)=0;对于非0状态Current,如果δ(Current,σ)=θ,置δ(Current,σ)=δ(failure(Current),σ).这种根据失效函数对无法跳转字符再次填充的方法被称为高级的AC算法[1].如果我们采用高级AC算法的方式完全填充块式匹配自动机中的块状态的跳转信息我们不难得出如下推断:(1)完全填充会使得构造过程过于复杂,且完全填充后的块式自动机的内存占用量理论上将是计算机系统无法容忍的;(2)仅将当前块状态的失效状态增加至当前块状态对提升块式自动机匹配速度的作用会相当有限.由于这个推断我们在本文中提出的混合自动机中未加入失效函数.4.1跳转信息中的映射关系对于块式自动机,存储块状态接受的符号集合时会存在如下问题:(1)每个块状态在理论上都有|Σblock|=25616个输入符号可以被匹配,由于这个理论符号跳转表需要巨大的存储空间,我们仅能为块状态存储必要的跳转信息(压缩的存储方法);(2)即便采用了压缩的方式存储块状态识别的信息,仍然可能存在某些块状态会识别多个特征块.以上两点都会降低块式自动机的匹配效率.在块自动机环境下,某块状态识别的特征块的数目记为Ns-b,某一特定特征块能够被多少个块状态所识别记作Nb-s.由于匹配长度为16,Nb-s相对于Ns-b会比较小;在同一个块状态识别的的特征块集合中搜索某一个特征块,会比在共享同一个特征块的块状态集合中搜索一个块状态会消耗更多的处理时间.由此本文在进行匹配时,首先将文本块和特征块进行比较,如果文本块能够和某一特征块相匹配再将当前块状态和接受当前特征块的所有块状态进行比较.具体地,特征块和块状态的对应关系如下:Map(src_state,symbol_list)=dst_state(1)Map(symbol,src_state_list)=dst_state(2)式(1)中src_state代表块trie中的某个块状态,symbol_list代表该块状态识别的符号(特征块)集合.式(2)中symbol代表块trie中任何一个块状态识别的某个符号,所有能够识别符号symbol的块状态就构成了式(2)中的src_state_list.进行文本匹配时,首先对当前文本块进行散列计算,检查相应的散列值对应的散列表入口处是否含有该表项的特征块集合,如果确实存在,再将当前文本块和集合中的每个特征块逐一比较.仅在存在和文本块相同的特征块的情况下,才将当前块状态和特征块对应的块状态集合中的各个块状态做进一步比对.算法1.BC_Machine(pat_set).输入:特征集pat_set输出:输出blocktrie和tailtries1.FORi∈[0,255]DO2.FORj∈[0,255]DO3.jump[i][j].step←34.jump[i][j].type←05.ENDFOR6.ENDFOR7.FOReachpat∈pat_setDO8.pos←pat9.len←strlen(pat)10.state←011.IFlen16THENPage612.jump[pos[2]][pos[3]].type|=0x0213.ELSE14.jump[pos[2]][pos[3]].type|=0x0115.ENDIF16.JumpStep(pos)17.WHILElen>0DO18.IFlen16THEN19.state←BlockGoto(pos,state)20.len←len-1621.pos←pos+1622.IFlen==0THEN23.设置成功匹配信息24.ENDIF25.ELSE26.TailGoto(pos,state)27.len←028.ENDIF29.ENDWHILE30.ENDFOR本文除了通过利用散列方法来降低匹配时间,还利用了类似WM算法中的SHIFT表对文本块进行过滤.本文假设记录SHIFT表的最短文本串长度为m=4,B=2.4.2利用犛犎犐犉犜表降低匹配时间对于SLSPM自动机中的块状态,可以将其后续特征块(特征尾串)的确认验证分为4类:(1)进行尾串验证;(2)进行特征块验证;(3)同时进行特征块验证和尾串验证;(4)不需要任何类型验证.如果能够根据文本预先判断,确定确认验证的类型就可以降低不必要的处理时间.为此,我们修改了SHIFT表的数据结构,在记录文本移动信息的同时,记录相应文本块的确认验证类型.为了描述方便,本文将这个确认验证类型记为B-characters-type:charsB.由于只有4种验证类型,charsB只需要占用SHIFT表项的2个比特位.4.3SLSPM混合自动机的构造构造SLSPM混合自动机的过程主要完成两个任务:构造字符跳跃信息表,包括长度为B=2的双字符跳跃信息和针对这两个字符的B-characters-type信息;构造自动机状态跳转信息,包括块式状态跳转和字符状态跳转.块式自动机和普通自动机的构造方法在本文前部已经有所介绍,这里不再赘述.同样,标准SHIFT表的构造和WM算法的SHIFT表一致,也不再做额外说明.这小节仅对如何对特征块进行散列和构造B-characters-type:charsB的方法进行说明.length).过程4.CharacterMatch(shortstr,state_b,输入:长度小于16的子串shortstr,块自动机的一个状输出:匹配是否成功的信息(匹配的特征号码id)1.automaton←块状态state_b后的字符自动机的根节点2.在automaton中对shortstr进行匹配过程5.BlockMatch(len16str,state).输入:长度为16的子串len16str,块状态state输出:匹配是否成功的信息(匹配的特征号码id)1.ht_index←hash_compute(len16str)2.IFhash_table[ht_index]中可以找到跳转信息3.len16str_list←hash_table[ht_index].str_list4.FOReachlen16str_goto∈len16str_listDO5.IFlen16str_goto.str==len16strTHEN6.FOReachgoto_info∈len16str_goto.goto_list7.IFgoto_info.src_state==stateTHEN8.IF匹配到特征THEN9.10.ENDIF11.RETURNgoto_info.dst_state12.ENDIF13.ENDFOR14.ENDIF15.ENDFOR16.ELSE17.RETURN018.ENDIF本文中,我们对特征集P的所有特征块做统一的散列,且散列计算的对象仅为特征块本身.在具体构造块自动机之前,匹配系统会预先将所有特征块进行散列计算,设当前正在处理的特征块为Current-Symbolblock,其散列值为h=hash(CurrentSymbolblock),算法会将代表特征块CurrentSymbolblock的序号加入当前散列表项HASH_TABLE[h]后的特征块集合中.在构造块自动机时,设当前块状态为CurrentStateblock,读入的特征块为CurrentSymbolblock.如果在HASH_TABLE[h]对应的特征块集合中不存在对应于(CurrentSymbolblock,CurrentStateblock)的跳转信息,算法会为HASH_TABLE[h]中CurrentSymbolblock添加相应的跳转信息.构造跳跃类型时,对于长特征,算法取出每个特征块CurrentSymbolblock中长度为m的前缀prefix,和该前缀prefix中最Page7后B个字符串prefix[2]prefix[3],然后设置SHIFT[prefix[2]][prefix[3]]|=10;对于短特征,同样提取当前特征长度为m的前缀,取出其最后B个字符串prefix[2]prefix[3],设置SHIFT[prefix[2]][prefix[3]]|=01.算法2.Match(text,len).输入:待匹配的文本text,文本text的长度len输出:匹配是否成功的信息(匹配的特征号码id)1.len←strlen(text)2.pos←text3.state←04.WHILElen16DO5.IFSHIFT[pos[2]][pos[3]].step==0THEN6.依据SHIFT[pos[2]][pos[3]].type确定调用7.IF匹配到特征THEN8.RETURN被匹配到的特征的id9.ENDIF10.pos←pos+111.len←len-112.ELSE13.pos←pos+SHIFT[pos[2]][pos[3]].step14.len←len-SHIFT[pos[2]][pos[3]].step15.ENDIF16.ENDWHILE17.WHILElen4DO18.IF[pos[2]][pos[3]].step==0THEN19.CharacterMatch(pos,len,state)20.IF匹配到特征THEN21.RETURN被匹配到的特征的id22.ENDIF23.pos←pos+124.len←len-125.ELSE26.pos←pos+SHIFT[pos[2]][pos[3]].step27.len←len-SHIFT[pos[2]][pos[3]].step28.ENDIF29.ENDWHILE4.4用SLSPM混合自动机匹配文本匹配文本时,算法根据当前文本串中剩余文本的长度决定采用哪种匹配方式,相应的匹配过程称为BlockMatch和CharacterMatch.当剩余文本长度不小于16时,BlockMatch过程依据SHIFT[txt[2]txt[3]]中预先存储的信息来决定文本的具体匹配方式.仅当SHIFT[txt[2]txt[3]].step为0时算法才会按照B-characters-type:SHIFT[txt[2]txt[3]].type指定的类型选择相应类型的自动机进行匹配.4.5算法时间复杂度分析假定待匹配文本为text,其长度为strlen(text)=16k+q,k1,4q<16.由于匹配自动机中不含有失效函数,每次匹配探测失败后匹配指针会移动到上次文本指针字符位置(ptr)的下一个位置(ptr+1).因此对于文本text,其最大探测次数为16(k-1)+q.以下讨论均指单一一次探测0i<16(k-1)+q内的情况.由于单一一次探测中字符指针的移动都是以16为一个单位,文本的长度可以假设为l=16b+d,其中b1,4d<16.为了理解一次探测中的复杂度,需要对如下问题进行说明:(1)在每次确认验证过程之前需要对文本块进行散列计算,仅当散列表对应表项入口处含有可供比较的特征块时才会进行后续验证动作,因此验证过程发生的频率实际上依赖于文本经散列后在相应散列表入口处能够找到非空特征块集合的概率,我们将这个概率设定为p1,且此过程记作hashProcess1;(2)仅当获得了一个合法的特征块的前提下,才会进行字符自动机的确认验证过程,该过程记作VerifyChar1;(3)仅在当前文本块经过确认验证是一个合法的特征块,且当前块状态和当前特征块对应块状态中的某个状态一致时,才会将指针后移16个字符的单位,并进行下一个文本块的散列计算,这个新的散列过程记作hashProcess2,发生事件hashProcess2的概率设为p2.由于实际网络包中能够成功匹配特征的概率会相当小,且散列函数会过滤掉绝大部分的待验证文本,我们可以假设过程hashProcess1中获得合法散列表项的概率p1会非常小.由此我们可以进一步假设新文本块散列计算过程hashProcess2发生的概率(或者说是文本块验证的概率)p2会更小.由于几乎不会发生事件hashProcess2,那么针对事件hashProcess2的字符自动机验证确认过程也就几乎不会发生.由此我们可以得知通常平均情况下,对于长度为l=16b+d的文本的文本比较次数为16g+15log2|Σ|.其中,g代表一个散列表项中含有的特征块的个数,15log2|Σ|代表采用二元树对当前文本块中前15个字符进行字符自动机验证匹配的字符比较次数.综上所述,BlockMatch中的16(k-1)+q次探测中,共进行了Time(A)=Σ16(k-1)+q15log2|Σ|)=(n-16)(16g+15log2|Σ|)次字符比较.如果散列函数选取得当,那么g将很小,可以近似得到Time(A)≈O(n).当剩余文本长度小于16时,CharacterMatch过程最多处理文本text的最后q个字符.类似于Page8BlockMatch过程中存在16(k-1)+q次探测,CharacterMatch过程最多存在q-3次探测.对于最后q个字符,任意一次起始于第i个字符位置的探测过程,0i<q-3,字符比较次数最多为q-i.Time(B)=Σq-4log2|Σ|/2.由以上两部分分析可知SLSPM匹配算法的总处理时间为Time(A)+Time(B)=(n-16)(16+15log2|Σ|)+(q-3)(q+2)log2|Σ|/2.需要指出的是,当n16,可以将Time(B)忽略不计,整体处理时间可以近似为O(n).由于文中采用了WM中的SHIFT表,因此SLSPM匹配算法具有O(n/(m-B+1))最优的复杂度.4.6算法空间复杂度分析为了使得说明普通trie自动机算法和SLSPM算法对内存需求的区别更加简便,我们假设:(1)特征集中的特征的长度都是16的倍数;(2)为了不失一般性,假设特征集中存在u个特征patterni,1iu,这u个特征具有一个长度为16r的公共前缀prefix_16r,r1,且这u个特征的长度满足strlen(patterni)16(r+1),经过自动机构造这u个特征的前缀prefix_16r在块式自动机和普通自动机中分别到达状态NodeB和NodeC.显然对于特征patterni,无论是NodeB还是NodeC,这些特征的后续子串对内存的需求由以下几个因素决定:(1)状态的表示方法,即数据结构对内存的需求量;(2)NodeB和NodeC后新状态的数目.为了使说明简便,本文仅考虑这u个特征在prefix_16r之后的u个特征块对内存的影响,并将这u个特征块记作pattern_blocki[16r,16r+1,…,16r+15].对于普通自动机每个状态仅需要一个32bit的整形数据保存后续状态即可;块式自动机中除了要保存后续块状态之外,还需要一个额外的32bit整型数据保存跳转到相应目标块状态的特征块的序号,因此一共需要64bit数据.最理想的情况下,特征patterni的特征块pattern_blocki[16r,16r+1,…,16r+15]的首字符各不相同,那么块自动机中NodeB其后将产生u个新的块状态,普通自动机中NodeC后将产生16×u个字符状态.显然,patterni的特征块pattern_blocki[16r,16r+1,…,16r+15]块式自动机和普通自动机的内存比值为(u×64)/[(16×u)×32]=1/8,此时块式自动机能够比普通自动机节省7/8的内存.一般情况下,u个特征块pattern_blocki[16r,16r+1,…,16r+15]具有长度为h的前缀时,0h16.普通自动机中NodeC后会产生h+u×(16-h)个新的块状态,块式自动机中NodeB后会产生u个新状态.此时块式自动机和普通自动机针对这些新状态的内存需求量比值为(64×u)/{32×[h+u×(16-h)]}=(2×u)/[h+u×(16-h)].图2用了一个例子说明了同一组特征子串在普通自动机和块式自动机中产生的状态数的对比情况.图3对两种自动机在不同的h和u取值情况下内存的比值进行了测试.图2同一组特征子串在不同类型trie自动机中的节点数目图3同一组特征子串,不同u和h情况下,SLSPM5实验本文的实验运行于一台配备了PentiumIntel(R)Core(TM)2Duo双核处理器,主频2.0GHz,物理内存2GB,一、二级缓存分别为32×2KiB和2048KiB的计算机上.实验主机操作系统为Fedora16x8664Linux,其内核为3.1.0.核心匹配代码用C编写(文本读写代码采用C++),编译环境为gcc编译器4.6.2,编译时开启了-O3选项.Page95.1大特征集环境下的性能测试这部分实验的特征数据为若干组URL特征,匹配的文本为具有3千万条URL的网络数据.当特征集规模较小时我们将SLSPM算法和AC算法进行了对比.为了获得匹配的速度,我们在匹配代码的前后添加了clock_gettime函数,该函数能够以纳秒级的精读计算程序的处理时间.当采用大型特征集测试时并未采用对比测试方法,其主要原因在于:以往的研究并没有关于长特征的超大规模特征集的测试,而且当特征集规模较大时,AC算法由于对内存需求过大,无法完成自动机构造,不具备对比测试的基本条件.为了确保算法具有较好的性能,本文中对特征长度另做如下限定:特征集中最短的特征长度满足m4.做如上限定是由于以下原因:(1)本文中的块式特征匹配算法中借用了WM[4]算法中的SHIFT表以便提高算法的文本过滤速度;(2)当m<3时,会降低指针移动距离;(3)当所有特征长度小于3时完全可以直接构造单一的字符自动机对文本匹配,这种情况下的自动机占用的内存并不会很大,使用本文中提出的块式匹配算法也就失去了意义.5.1.1内存和匹配速度的测试结果图4(a)中显示了不同匹配算法对内存的需求量.针对SLSPM算法的内存需求量测试包括了如下内容:(1)块式自动机中所有块状态(即逆向状态转移表信息)的数据结构占用的内存;(2)算法中为过滤无用文本子串所需要的64KB位移表占用的内存;(3)所有特征尾串字符自动机占用的内存;(4)所有短特征构成的字符自动机占用的内存.图中测试结果并未包括散列表占用的内存(32MB).实验中采用了不同的特征长度4、8、16、32和64,结果显示本文的SLSPM算法随着特征规模的增加内存增加的速度明显慢于AC算法.由于AC算法内存需求量较大,在本文实验中特征规模达到28800条时就已经无法完成自动机的加载过程了(系统此时无法正常响应用户的其它应用请求),而SLSPM算法仍然保持较小的内存用量.图5SLSPM算法的规模极限测试图4SLSPM算法和AC算法的对比实验结果由图4(b)的结果可以看到,与AC算法相比SLSPM算法的匹配速度略有优势,当采用长度为16的匹配粒度进行匹配时,速度平均可以提升30%左右.这主要归功于块式匹配可以提升单位匹配动作内的匹配粒度,此外采用散列算法对无用文本块进行过滤,降低了将文本块和特征块进行比较的次数从而减少了匹配性能降低的可能性.由图4(b)的结果可以发现:SLSPM算法的缺点在于,随着特征规模的增加,其匹配速度也会降低.这主要是由于当特征集规模增大后,文本块经过散列计算后产生碰撞的概率有可能增大,从而导致需要对首层特征块进行验证的概率增加.碰撞率增大和验证次数加大共同导致了整体匹配时间增大的结果.本文也对SLSPM算法的规模极限进行了测试,测试结果记录于图5中.实验结果显示:本文中的实验环境下的混合自动机最多可以承载450万条特征.Page105.1.2分块长度对匹配速度的影响增加块的长度可以降低块式自动机中状态的数目(主要是块状态的数目),从而尽量降低算法对内存的需求.但是一味地增加块的长度未必会带来好的匹配性能.从图4(a)和图4(b)中的结果可以看出,将块的长度限定在16会得到比较理想的处理速度.这主要是由于匹配过程中会发生匹配回溯的现象,即匹配失败时,会重新将文本指针移动至之前的文本位置进行扫描.如果扫描的单位块长度过长,匹配失败的概率就会增加;如果扫描的单位块长度过短,匹配方式会更加接近于字符匹配,达不到利用块匹配方式将指针向前移动的目的.由实验结果和以上分析可知:16是最理想的分块长度.5.2与状态编码自动机的对比实验为了减少网络入侵检测系统的硬件实现方案表1SLSPM和状态编码方式的状态数目比较特征集中的特征产生的方式特征总量snort17599747967338843408393469188497843524761552107文献[9]通过对自动机状态重新进行编号,使得多个状态能够用一个通配编号来表示,这样自动机中具有相同输入和下一状态的多条变迁就能被聚合为一条,大大减少了需要存储的变迁数目.该算法以状态编码加以通配符的形式取代了普通AC自动机中的失效跳转函数.即,普通AC自动机中通过失效跳转来处理无法继续向前匹配的字符,而文献[9]的算法是通过通配符的形式追溯上级失效状态能够识别的字符集合中是否含有当前正在处理的输入符号.本质上,两者都是使用失效链处理无法继续匹配的字符.二者的内存占用量的区别表现为:文献[9]中算法通过状态编码隐藏了失效状态(当前状态指向的失效状态),其代价是增大了状态占用的比特位.从匹配效率上看,在读入一个无法匹配的字符后,带有失效函数的AC自动机会沿着失效链逐一检查每个失效状态的匹配集合中是否能够匹配当前字符;文献[9]则是通过逐一扩大当前状态的编码中的通配符(比如状态001111000111111读入无法匹配的字符时可能会经过如下变迁过程,001111000,001111,00,)来判断字符是否有可能被中自动机占用的存储容量,文献[9]中提出了一种自动机状态的编码方法.本文也将SLSPM算法和这种能够大量节省内存的自动机处理方法做了对比测试.测试结果列于表1.这部分实验的特征集主要来源于snort入侵检测系统的两个特征数目最多的规则集合与随机生成的特征集.实验中所采用的snort中的两个特征集分别为deleted.2945.rules和browser-plugins.2945.rules.本文中直接提取出规则文件中的所有包含于content:""或者content:!""之内的字符串作为特征字符串.经过去重处理,我们可以分别从deleted.2945.rules和browser-plugins.2945.rules两个特征集中提取出2457和1697条特征.对于随机生成的每个特征数据集中的所有特征也是互不重复的.状态数目匹配.在硬件的支持下,这种自动机依然会保证自动机恒定的处理速率.文献[9]中可能存在的问题在于,随着特征量的增大,状态编码需要的位数也有可能会增大.因此在特大规模特征集的应用环境下,这种算法可能会存在问题.从表1的实验结果中我们可以看出采用块式自动机和字符自动机相结合的自动机的状态总量要少于状态编码方式.当对状态编码形成的所有状态进行统一编码时(即,将所有状态有序地进行编码时)会出现大量的非法状态.假设按照文献[9]中上一层单个状态发出的最大边数为5时,需要使用3比特表示失效链上的编码,仅有001、010、011、100和101共5个编号是有效的(合法编码),另外2个编号110和111属于非法的编码.对非法编码的存储方式无疑会影响系统的匹配性能:(1)如果系统同时保留合法编码和非法编码,那全部状态的编码就可以落在一个完整的编码空间中,如此依据文[9]中的通配编码方式访问上层跳转信息就是常量访问时间.但是这种方式会比完整AC自动机(高级AC自动机)占用更大的内存.(2)如果系统仅保留合法编码,系统仅占用和状态机的状态数目相当的内存单Page11元,但是需要更有效的方式访问FTT中的上层节点获取失效跳转信息,以达到恒定的处理速率.由于这种不确定性本文没有对状态编码匹配算法和SLSPM算法进行速度对比实验.6讨论相比其它优化方法,作为压缩自动机内存的一种手段,块式压缩直观、简单、有效.但是本文中的SLSPM也存在一些问题:(1)正如上文对SLSPM算法的分析可知,该算法更适用于各特征在相应分段中的字符分布更加随机,即缺乏共同前缀时才具有更加优越的内存压缩特性;(2)为了适应块式信息处理,SLSPM算法中使用了散列函数对无需进行匹配的文本进行过滤.如果散列函数的处理速度不高会严重影响文本扫描的处理性能;散列函数的特性,如雪崩效应,也会影响到算法对文本的过滤能力;文本自身的统计特性也有可能影响散列函数的过滤能力;(3)随着特征块数目的增加,长度为B的字符块在文本块中的出现位置有可能会更加随机,由此会导致SHIFT表的移动能力降低.同时随着特征规模的增加B-characters-type信息的类别也有可能增加,由此也会增加算法的处理时间.7结论本文中提出了一种适用于超大规模特征集的串匹配算法SLSPM.和传统AC自动机相比,该算法的匹配自动机由一个块式自动机和若干普通自动机构成.为了适应先散列后匹配的结构,本文采用了“自动机某状态识别的某一符号———识别该符号的状态集合”的映射关系来构造块式自动机跳转信息.算法的近似平均处理时间为O(n),最优复杂度为O(n/(m-B+1)).本文中SLSPM算法的优势在于它能够适应于SLSPM(超大规模特征匹配)环境.但是由于未使用失效状态的目标状态对自动机当前状态的跳转信息进行扩展降低了SLSPM算法的性能,在后续的研究中可以考虑对散列算法和指针移动算法进行优化,以提高该算法的处理速度.
