Page1乐观策略下并行离散事件仿真动态负载划分优化算法张颖星姚益平(国防科学技术大学计算机学院长沙410073)摘要动态负载划分是提高并行离散事件仿真运行性能的有效途径之一.现有研究往往孤立地考虑计算负载平衡和通信负载优化,使得复杂应用背景下整体性能低下.论文综合考虑仿真模型计算负载和交互模式,提出了一个基于带权重无向图有限容量k划分问题的并行离散事件仿真负载划分模型,并配合一套通用的仿真运行性能度量方法,提出了一个基于顶点交换的启发式局部搜索近似划分算法,实现了在计算负载平衡的前提下系统通信负载最优化,其近似解与全局最优解比值不小于(1-1/|N|)(1-ε).实验证明了该动态负载划分算法的有效性和实用性.关键词负载划分;局部搜索算法;并行离散事件仿真;乐观同步策略1引言负载划分(partitioning)和时间同步(synchro-nization)是决定并行离散事件仿真(PDES)性能的最重要的两个因素[1].由于早期仿真应用规模有限,运行状态相对稳定,动态划分对性能的提升并不明显,此外,由于很多仿真平台对迁移机制支持不足,动态划分的额外开销较大,使得对并行离散事件仿真负载划分的研究长期局限于基于模型行为预测的Page2静态负载划分[2-4].然而,随着仿真模型越来越复杂,特别是一些研究者提出将并行离散事件仿真支撑技术与Agent建模技术相结合以支持复杂系统的研究[5-6],系统负载往往具有显著的动态性,传统的静态划分技术已难以保证仿真的整体运行效率;同时大量支持高效迁移机制的并行离散事件仿真平台的出现也为动态负载划分提供了底层支持[7-9],因此,动态负载划分近年来越来越受到并行离散事件仿真研究者的关注.动态负载划分的关键问题是仿真运行性能度量和负载迁移策略.早期的动态负载划分算法主要考虑计算负载平衡因素以减少各计算节点间本地仿真时间推进的差异,但随着高性价比的集群系统已逐渐成为大规模并行离散事件仿真的主流硬件平台,通信负载对性能的影响越来越显著,如何在计算负载平衡的前提下根据模型交互模式优化通信负载已成为目前动态负载划分研究的热点.本文综合考虑仿真模型计算和通信负载,将并行离散事件仿真的动态负载划分归结为一个带权重无向图的有限容量k划分问题,首先通过模型计算负载和节点计算能力确定各个划分集合的容量,然后采用基于顶点交换启发式的局部搜索近似划分算法,根据模型交互模式对负载划分进行优化,使得在计算负载平衡的前提下通信负载最优化.本文第2节介绍并行离散事件仿真领域近期动态负载划分的相关研究;第3节给出动态负载划分的形式化描述;第4节详述本文的负载划分优化算法;第5节给出测试方法和实验结果;最后总结全文.2相关研究早期的并行离散事件动态划分算法往往只考虑计算负载平衡.Reiher和Jefferson[10]提出的方法是以处理器利用率来评估仿真运行状态,周期性查找过载和欠载的计算节点,若两者间计算负载差距大于规定的阈值,则通过迁移进行负载平衡;Glazer和Tropper[11]提出的算法思想与前者类似,但进一步提出simuationadvancerate的概念来评估运行状态,同时采用heuristicbinpackingalgorithm进行负载划分,获得了更好的效果;Carothers和Fujimoto[12]也提出一种基于平台信息的动态划分算法,获得了不错的性能提升.这些算法的主要问题在于没有考虑仿真模型通信负载,在仿真模型计算负载较为稳定而交互关系动态性较强的仿真应用中加速效果较差;同时,部分算法对仿真运行性能评估需要底层操作系统或特定仿真平台的支持,限制了其应用范围.Wilson和Shen在文献[13]中提出一种分段动态划分算法,首先由一个中央节点收集系统运行信息并确定各计算节点的迁移量,然后各节点根据不同的策略来决定具体迁移哪个逻辑进程,而通信负载优化策略是其中的一个选项.该算法引入了通信负载优化的思想,但由于在不同策略中分别孤立地考虑计算负载平衡或通信负载优化,使得在复杂应用背景下两者相互影响,产生大量额外开销,整体性能下降.Slavik等人[14]提出的动态划分算法也存在类似的问题,该算法提出了通过带权重的无向图对通信负载进行优化的思想,但没有考虑计算负载平衡的影响,同时该算法提出的仿真运行性能度量方法也难以应用于实际系统.Low在文献[15]中提出了一个综合考虑计算负载平衡和交互模式优化的模型,获得了不错的效果,但该算法主要针对BSP-TW乐观同步协议,限制了其应用范围.Peschlow等人在文献[16]中提出一种柔性的动态负载划分算法,该算法综合考虑了计算负载平衡和通信负载优化问题,设计了一套通用的并行离散事件仿真运行性能度量方法,但由于采用的迁移算法无法保证收敛,在部分情况下会产生迁移振荡.综上所述,尽管近年来对基于模型间交互模式的动态负载划分技术研究发展较快,但目前还没有一个完善的适用于多种乐观同步协议且综合考虑负载平衡和通信模式的并行离散事件仿真动态负载划分算法.3问题模型我们的问题模型描述是基于通用的并行离散事件仿真“消息-事件”范型:系统由一组逻辑进程LogicProcess(LP)组成,LP之间通过相互调度事件进行交互,每个LP通过处理一系列事件来推进仿真时间,在仿真过程中事件的处理会改变LP的内部状态,同时输出新的事件[1].LP是负载划分的基本单位,可以自由地分配到各个计算节点上运行.每个计算节点通过一个节点控制器(hostcontrol-ler)来管理在该节点上运行的LP,共用一个事件调度队列,按事件时戳的非递减顺序执行,以保证全局因果序约束(globalcausalityconstraint).负载划分的基本任务即将LP合理地分配到各个计算节点上以获得最高的系统运行效率,为达到该目的需要综合考虑系统计算负载平衡和通信负载Page3优化两方面的因素:计算负载平衡的主要任务是保证LP划分集的事件处理计算负载与对应计算节点计算容量相匹配,以减少由各计算节点局部仿真时间(LVT)推进的差异而引起的同步等待和回滚开销[1];通信负载优化的主要任务是根据LP事件调度依赖关系将交互频繁的LP分配到同一计算节点上,以减少由远程事件调度而引起的回滚开销[14,16].基于上述“消息-事件”范型,并行离散时间仿真负载划分模型形式化描述如下:设L表示逻辑进程集合,E表示逻辑进程间事件调度关系,首先以仿真系统中所有LP为顶点,构造一个全连通的无向图G(L,E).定义边权重w:L×L→R表示单位仿真时间内任意两个LP间相互调度事件数;边权重w(l1,l2)=0表示l1和l2之间没有交互.定义点权重c:L→R表示一个逻辑进程的计算负载.设N表示硬件平台计算节点的集合,U:N→R表示计算节点的计算容量,则负载划分问题可以表示为:从无向图中选出一个边集合SE,使得G(L,E-S)分成|N|个互不联通的子图(记为{G1,G2,…,G|N|}),且存在一个映射δ:Gn→N满足δ(Gn)∈N:∑l∈Gnc(l)U(δ(Gn));负载划分优化问题即找到满足Min∑e∈Sc(e)的边集合S,对应映射δ:Gn→N即负载划分结果.该问题是一个NP问题[17],本文假设系统中逻辑进程计算负载符合泊松分布,则我们首先根据各个计算节点的容量和各个LP的计算负载,在满足系统计算负载均衡的条件下确定划分集合容量,然后给出一个基于顶点交换的启发式局部搜索近似划分算法,其近似解与全局最优解的比值不超过(1-1/|N|)(1-ε).4动态划分算法根据上述基本问题模型描述,我们的算法主要包含以下几个部分:(1)初始化仿真系统,根据系统基本信息将LP划分到各个计算节点上;(2)通过各计算节点上的仿真控制器对运行信息进行采样;(3)设置一个独立的控制节点周期性收集系统的运行信息,从计算负载和通信负载两方面评估系统运行状态,在必要的情况下发出迁移指令,调整各计算节点上LP分布.基本算法框架如下.Initialpartitioning;whileGVT<SimEndTimedo{Collectperformanceinformationfromhost;CalculatecomputationworkloadimbalanceWB;CalculatecommunicationworkloadimbalanceCB;if(WB>MaxLoadDiff)callbalance_computation()else{if(MoveIndicatorisnotempty)StartLPmovements;SetTheNextMeasurementTime;}4.1初始化负载划分初始化工作的主要目标是通过静态负载平衡的方法获得一个可行的LP初始分布,该分布是后续动态划分算法的基础:一个良好的初始分布能有效减少动态迁移所带来的开销.由于仿真系统的事件调度依赖关系在运行前一般难以完全确定,所以负载划分的初始化工作主要考虑LP计算负载与计算节点容量的匹配.计算节点的计算容量可以通过参考处理器时钟频率、内存大小等因素直接设置权重得到,也可以通过运行测试程序来获得更精确的初始计算容量参数Icap(i):N→R;得到所有计算节点基本参数后,计算dIcap(i)=Icap(i)初始计算容量,其中∑i∈N根据LP的计算负载设置不同的初始权重ILoad(l):L→R,默认权重为1,然后同样计算dILoad(l)=ILoad(l)ILoad(l)规范表示某个LP计算负载,其中∑l∈L∑l∈LdILoad(l)=1.最后根据dIcap(i)和dILoad(l)进行初始负载划分:InitialPatitioningInput:theLPcollectionL;thenodecollectionN;theLPworkloaddILoad(l);thecapacityofnodedIcap(i);Output:InitialPartition(i):N→L,LLfor(i∈N){letPartitionSet(i)betheLPcollectionwhichdistributedtonodeiletSumLoad(i)=∑l∈PartitionSet(i)While(SumLoad(i)<dIcap(i)){findl∈LsatisfiedSumLoad(i)+dILoad(l)<=Page4if(exitsuchLPl){PartitionSet(i)··=PartitionSet(i)∪lSumLoad(i)=SumLoad(i)+dILoad(l)RemovelfromL}elsebreak;}}if(L≠)assigntherestLPtotheNequallyInitialPartition(i)=PartitionSet(i)4.2运行信息采样与评估跟踪系统运行信息并对系统状态进行评估是动态划分算法的基础,为了准确地了解整体系统的运行状态,需要对以下3个因素进行采样和评估:计算节点的计算容量cap(i)、LP计算负载LPload(l)和LP的通信负载LPcomm(l).计算容量表示计算节点在运行仿真时能提供的处理能力,容量越大的计算节点能在单位时间内进行的计算越多.计算节点的基本容量由该节点的处理器、内存等硬件配置决定,但在仿真运行过程中,节点的计算容量会因为背景负载而改变,因此需要在运行时对节点计算容量进行采样和评估.计算节点在采样时段内处理并提交的事件总数是衡量节点计算容量的一个重要指标[10-11],但在乐观策略下回滚会导致部分实际处理了的事件无法被统计,此外,在一些受限乐观同步算法中(如BTB、BSP),计算节点也会由于全局同步而产生空转等待,因此,单纯对处理并提交事件总数进行采用和评估无法准确地反映节点计算容量,需要考虑回滚和空转因素的影响.与文献[16,19]的思想类似,我们设处理事件总数NodeEvent(i):N→R表示在采样时段内提交事件和回滚事件之和,实际处理时间NodeWorkTime(i):N→walltime表示采样区间时长减去空转等待时间,则定义节点i的动态计算容量为并行离散事件仿真中,单个LP的计算负载是通过处理该LP上的事件而产生的,因此计算在采样时段内该LP上处理的事件数是衡量计算负载的重要指标.考虑到采样时段内该LP上处理的事件数实际会受节点计算能力的影响,分布到计算能力强的节点上的LP可能处理更多的事件,所以对LP计算负载的评估必须去除节点计算能力的影响.我们采用计算LP推进单位虚拟时钟所产生的事件数来表示LP的计算负载,设LPEvent(l):L→R表示在采样时段内逻辑进程l上处理的事件数,LVTAdvance:N→virtualtime表示在采样时段内逻辑进程l所在计算节点推进的局部仿真时钟,则定义逻辑进程l的计算负载为在乐观策略下,LPEvent(l)和LVTAdvance的采样都会受到回滚的影响,为解决该问题,我们借鉴了Schlagenhaft等在文献[20]中提出的方法,对采样时段内的l上处理的所有事件记数,并在计算虚拟时钟推进时对回滚部分进行补偿.单个LP的通信负载表示该LP调度其他LP上事件的情况,对LP通信负载的评估同样要去除节点计算能力的影响,设LPCommEvent(l1,l2):L×L→R表示逻辑进程l1在采样时段内调度逻辑进程上l2的事件数,LVTAdvance:N→virtualtime表示在采样时段内逻辑进程l1所在计算节点推进的局部仿真时钟,则定义逻辑进程l1的对逻辑进程l2的通信负载为LPcomm(l1,l2)=LPCommEvent(l1,l2)仿真平台中各节点上仿真控制器负责该节点上LP的事件调度处理和消息转发,因此,以上运行信息可方便地由各个计算节点上仿真控制器进行采样.获取相关数据后,动态负载平衡算法则对整体运行状况进行评估.计算dcap(i)=cap(i)的计算容量,其中∑i∈NLPLoad(l)LPLoad(l)规范表示某个LP计算负载,其中∑l∈L∑l∈LdLPLoad(l)=1;设PartitionSet(i):N→L表示划分到节点i上的LP集合,计算NodeLoad(i)=∑l∈PartitionSet(i)dLPLoad(l)表示计算节点i上的计算负载,则计算负载均衡评估函数WB可以表示为WB=MAX(|NodeLoad(i)-dcap(i)|),i∈N,如果WB>MaxLoadDiff则表示当前LP分布产生计算负载不平衡,需要进行计算负载平衡.当l1∈PartitionSet(i)∧l2∈PartitionSet(i)时表示l1,l2分布在同一计算节点上时,LPcomm(l1,l2)表示本地事件调度通信负载;否则,LPcomm(l1,l2)Page5表示远程事件调度通信负载.计算NodeLocalComm(i)=PartitionSet(j)j=i+1表示节点i上LP本地通信负载之和,则可得到系统本地通信负载之和Wl=∑N计算NodeComm(i,j)=∑l1∈PartitionSet(i)∧l2∈表示计算节点i和j间的LP通信负载总量,则进一步可以得到系统远程通信负载之和Wr=∑Ni=1∑N可以表示为CB=Wr则当前LP分布产生通信负载不平衡,需要进行通信负载平衡.4.3计算负载平衡算法计算负载平衡的基本目标是计算节点容量与分布到该节点上的LP计算负载的匹配以减少由各计算节点局部仿真时间(LVT)推进的差异而引起的额外开销,一个计算负载平衡的LP划分是进行后续通信负载优化算法的基础.算法的基本思想是在计算负载出现不平衡时,首先找到系统中计算负载最重的节点和计算负载最轻的节点:设Pmax表示计算负载最重的节点,则Pmax满足条件:i∈N,NodeLoad(Pmax)-dcap(Pmax)设Pmin表示计算负载最轻的节点,则Pmini∈N,NodeLoad(Pmin)-dcap(Pmin)将Pmax上的部分LP迁移到Pmin上,更新节点负载信息后重新评估计算负载是否平衡;如仍然存在计算负载不平衡,则重复上述步骤直到计算负载平衡;最后将整体迁移的最终结果存入迁移列表.则优先选择计算负载较大的LP,具体算法如下:在选择迁移的LP时,为减少LP的迁移数量,满足条件:balance_computationInput:LPcollectionwhichdistributedtonodeitheLPworkloaddLPLoad(l)thecapacityofnodedcap(i)Output:migratingLPcollectionMoveIndicatorwhile(WB>MaxLoadDiff)do{letPmaxbethenodewiththemaxcomputationletPminbethenodewiththemincomputationSumMoveLoad=0;if(TempMoveLPSet∩MoveIndicator≠)STOP;}4.4通信负载优化算法在完成计算负载平衡迁移后,我们得到一个原始的LP划分,如该划分产生通信负载不平衡,则根据系统事件调度依赖关系对负载划分进行优化,减少由远程事件调度而引起的回滚和空转开销.根据第3节所述的基本问题模型,构造一个全连通的无向图G(L,E);采用4.2节所述的运行信息采样信息为无向图中边赋权重w:L×L→R:l1,l2∈L:w(l1,l2)=LPcomm(l1,l2)+LPcomm(l2,l1),记该赋权图为Gw(L,E);则通信负载优化的目标即找到Gw(L,E)的一个图划分,在保证各子图顶点个数符合计算负载平衡迁移结果的前提下,使得各子图间的边权重和最小.设Cw=∑w(l1,l2)表示图Gw(L,E)中所有边权重的总和,对任意一次通信负载优化,该值是一个常量.构造新的赋权图Gw(L,E),其中对边赋权重珡w:L×L→R:l1,l2∈L:珡w(l1,l2)=Cw-w(l1,l2),则上述通信负载优化问题等价于找Gw(L,E)的一个图划分,在保证各子图顶点个数符合计算负载平衡迁移结果的前提下,使得各子图间的边权重和最Page6设珡w(l1,Ni)=∑l2∈Ni逻辑进程l1对节点Ni上所有逻辑进程的边权重和,|Ni|表示分布到节点i上LP的个数,则具体通信负载平衡算法如下:大.该问题可基于Gaur等人在文献[21]中提出的图最大k划分算法获得近似解.balance_communicationInput:LPcollectionwhichdistributedtonodeiPartitionSet(i)edgeweight珡w(l1,l2)ofinteractiongraphGw(L,E)Accuracyε>0Output:migratingLPcollectionMoveIndicatorleti=0;While(True){letWir=∑珡w(l1,l2)whilel1,l2don’tassigntothesamenodeqi=Wirεdo{seti=i+1;Wir=Wnew}性质1.算法收敛且最终分布与全局最优解比值不小于1-1则系统LP最终分布满足证明.根据通信负载平衡算法迁移判断条件,l1∈Ni,l2∈Nk|Ni|珡w(l1,Ni)+|Nk|珡w(l2,Nk)(|Ni|珡w(l1,Nk)+|Nk|珡w(l2,Ni))(1)则对所有l1∈Ni和l2∈Nk将上述不等式相加可以得到|Nk||Ni|∑l1∈Ni|Nk||Ni|∑l1∈Ni设2珡w(Ni)=∑l1∈Ni则不等式(2)可变化为对系统中所有节点进行求和计算可以得到(|N|-1)∑N∑Ni=1∑N设Wl=∑N权重和,Wr=∑N子图间边权重和,则可得到k=1,k≠i设W和q表示算法中外层循环运行Wir和qi的最终值,可得WrW/2,则Wr=∑N即Wr|N|()-1ε+1根据不等式(3)可以得到(|N|-1)WlWr(|N|-1)ε+1则WlWlε(|N|-1)+1全局最优解表示图Gw(L,E)划分后子图间边权重和的最大值,设为Woptr,则Page7WoptrWr+WlWr+ε(|N|-1)+1所以WrWoptl性质2.算法具有多项式时间复杂度,且时间复杂度不超过O(n4ε-1logn).证明.设n=|L|,因为对边权重进行了取整缩放珡w(l,N)=|珡w(l,N)/q|q,所以内层while循环执行时间复杂度是O(n(1+ε)/ε)=O(n/ε).为证明外层while循环时间复杂性,需要首先引入Radzik等人在文献[22]中证明的定理.引理.设犱=(d1,…,dn)表示一个向量,狔1,…,狔n表示一组{0,1}n向量,如果对所有i=1,…,p-1,都满足0dyi+11/2dyi,则p=O(nlogn).由于每次外层循环Wi+1r1作是所有边权重与{0,1}n向量的内积,其中远程调度边对应1,本地调度边对应0,所以根据引理外层while循环时间复杂性不会超过O(nlogn).又因为每次搜索符合条件的点不超过O(n(n-1)/2)=O(n2),所以算法的时间复杂性不超过O(n4ε-1logn).5实验分析5.1实验环境本文实验基于并行离散事件仿真领域经典的PHOLD测试模型[23],同时修改其事件调度方式以表示更复杂的模型交互模式:实验仿真系统由一系列实体构成,每个实体映射到相应LP上,负责处理相关事件,每个事件随机做若干次加法以表示不同计算负载;当某个实体处理事件时,该实体随机调度其他实体上的事件,设被处理事件的逻辑时戳为t,则随机选取区间[t+1,t+dmax]中任意时刻作为新调度事件的时戳;同时,仿真系统中所有实体分成若干不相交的子集,某个实体调度同组实体上事件的概率为Pgroup,调度不同组实体上事件的概率为1-Pgroup.实际测试过程中,实体总数设为1000个,每个实体初始事件数为2,dmax=10,Pgroup=0.8,整个仿真运行的逻辑时间为20000.实验仿真软件平台为国防科学技术大学计算机学院研制的YH-SUPE并行仿真开发及运行支撑环境[24].实验硬件环境配置为8计算节点的集群系统,每个计算节点CPU主频3.0GHz,主存1GB,操作系统为红帽Linux.5.2实验结果实验主要关注两个方面的:整体仿真性能加速比和LP迁移收敛情况,主要对比测试对象为德国波恩大学Peschlow于2007年发表的DynPart算法[16].基于以上改进的PHOLD测试模型,本次实验中我们采用3种交互配置,分别将所有实体分为50组、25组和1组.由图1测试结果可以看到DynPart算法在模型交互模式没有明显特征的情况下(group1)其迁移较为盲目,一直保持较高的额外的开销;而在交互模式特征较为明显的情况下(25组,50组)算法迁移情况收敛较快.本文ALSPart算法则一直保持较低的迁移开销.图2~图4分别显示了在时间弯曲(TimeWarp)、呼吸时间桶(BreathingTimeBucket)和呼吸时间弯曲(BreathingTimeWarp)3种乐观同步协议下仿真运行时间;图5~图7分别显示了相应同步协议下仿真回滚次数.由测试结果可以看到采用本文ALSPart算法平均减少38.11%的回滚次数,而且整体性能较为稳定,通过优化通信负载对3种交互配置分别可以降低13.64%、49.63%和51.05%的回滚次数,同时对3种不同的同步协议则分别可以减少44.09%、29.65%和40.59%的回滚次数;而DynPart算法性能对交互配置较为敏感,特别是在交互配置1组的情况下会由于不适当的划分而产生大量额外的回滚,同时DynPart在呼吸时间桶同步协议下整体性能较差,此外,在实际测试中,DynPart的整体性能非常依赖对其运行参数的配置,不适合的参数配置将导致其性能进一步下降.DynPart的优势在于在模型交互模式特征较为明显的情况下(25组,50组)其性能较好.需要说明的是本次实验中动态负载划分算法对运行时间的加速比Page8图4呼吸时间弯曲同步协议下仿真运行时间图7呼吸时间弯曲同步协议下时间回滚次数没有对回滚次数的加速比明显,这主要是由于本次PHOLD测试程序中每个事件的计算负载较轻,使得回滚的开销不大,因此整体运行时间差别不明显;而在实际应用中回滚将极大地影响仿真运行性能.6结论负载划分是决定并行离散事件仿真性能的重要因素,如何度量和根据模型交互模式优化通信负载是目前动态负载划分研究的热点.本文将并行离散事件仿真负载划分归结为一个带权重无向图有限容量k划分问题,提出了一个多项式时间复杂度的基于顶点交换的启发式局部搜索近似划分算法,旨在使计算负载平衡的前提下通信负载最优化.理论证明该算法近似解与全局最优解比值不小于(1-1/|N|)(1-ε),时间复杂度不超过O(n4ε-1logn).测试结果表明该算法平均减少38.11%的回滚开销,能有效地提高大规模并行离散事件仿真的运行性能.在下一步工作中,我们将结合multiwaycut问题模型对现有的划分模型进行扩展,引入对特定LP节点的优化处理,以解决现有算法在特殊计算负载分布下效率较低的问题,进一步提升仿真运行性能.
