Page1PartitionSim:一个面向众核结构的并行模拟器焦帅1),2)徐卫志1),2)唐士斌1),2)范东睿1)孙凝晖1)1)(中国科学院计算技术研究所系统结构重点实验室北京100190)2)(中国科学院研究生院北京100049)摘要该文提出了一个面向众核处理器的并行模拟器:PartitionSim.PartitionSim采用了一种新颖的方法———时序分割来加速众核结构模拟.时序分割的提出基于这样的观察:在众核结构中,有些模块之间频繁交互而有的模块之间没有交互.有鉴于此,该方法将目标结构分割成两部分:交互部分和非交互部分.当模拟交互部分时,主机线程严格同步,维持时序精确.当模拟非交互部分时,主机线程通过异步运行,提高模拟速度,并且产生较小的时序损失.文中所述工作在一个16核的SMP机器上用PartitionSim模拟了千核规模的Godson-T众核结构.实验结果显示,PartitionSim展示出良好的加速比,达到最高25MIPS的模拟速度,时序损失平均值为0.92%.关键词并行模拟;众核;Godson-T;时序分割1引言随着“众核时代”的到来,一些众核处理器[1-2]已经出现.在单芯片上集成上千核已经可以实现[3],并将在不远的未来商用化.模拟这样的并行结构是个巨大的挑战.目前,大多数模拟器都是串行的.串行模拟器用一个主机线程来模拟整个目标系统.当目标系统的核数增加时,分配给单个核的模拟性能就会下降.目前已经有许多方法被用来加速模拟.这些方法包括并行模拟[4-6]、直接执行[6]、FPGA加速[7]等等.在这些加速技术中,并行模拟因为能够利用目标结构天然的并行特征,能在低成本SMP计算机上实现,成为了最有吸引力的加速技术.且有代表性的并行模拟工作是基于离散事件驱动的模拟器PDES[8].PDES模拟器分为传统PDES和现代PDES.传统的PDES模拟器注重精确性.它们或者保守地提供有限的同步放松(quanta[9]与lookahead[10]),或者激进地放松同步但又引入额外的开销来应对时序错误.现代PDES模拟器(例如SlackSim[5]和Graphite[6])倾向于提高模拟速度,为此不得不激进地放松同步并牺牲精确性.注意到传统PDES和现代PDES都展现出相同的同步行为:模拟目标结构所有模块时,要么都放松同步模拟,要么都严格同步模拟.然而通过仔细观察众核结构的通信特征,我们发现:有些模块间通信频繁,而有的模块则很少通信.这个观察在基于软件管理Cache一致性的众核结构(IntelSCC[2]、Rigel[3]和Godson-T[11-12])中尤为明显.在传统的带有硬件Cache一致性的众核结构中,一致性协议要求频繁的Cache间通信.准确地模拟这些通信需要在每个Cache访问事件上做同步.在软件管理Cache一致性的情况下,Cache只被本地的小核访问.Cache间没有通信.模拟这样的Cache不需要同步.一旦Cache可以被异步模拟,那么整个小核(流水线+Cache)就可以被异步模拟.有鉴于此,本文的基本思想如下:当模拟一个软件Cache一致的众核结构时,放松对小核的同步模拟可以提高模拟速度并且损失很小的准确度.基于这个想法,本文提出了新的模拟方法:时序分割.时序分割是把目标时序模块分为两部分:非交互部分和交互部分.非交互部分被异步模拟,交互部分被严格地同步模拟.在本文中,我们把所提出的众核结构分为Core(非交互)部分和NOC(交互)部分.要保证时序分割方法能够工作,有两个问题需要解决:(1)虽然Core与Core之间没有时序通信,但是Core与NOC之间还有通信,必须去掉这些通信,才能让Core完全、自由地被异步模拟.(2)异步模拟Core仍然会导致时序损失,如何减少这些时序损失.为了解决上述问题,我们提出了两个方法:时序假设和时序重建.时序假设使用建模估计的方法来假设NOC到Core之间的时序通信.基于这些假设的时序,Core就可以脱离NOC异步模拟.然而,由于Core基于假设的NOC-to-Core时序运行,那么产生的Core-to-NOC时序通信便不是准确的.时序重建用来尽量准确地恢复Core-to-NOC的时序通信.图1展示了本文的基本思想.图1时序分割示意图(目标时序模块被分为Core和NOC;时序假设(timingassuming)去除Core对NOC的时序依赖;时序重建(timingrebuilding)恢复Core-to-NOC的时序通信)采用时序分割技术,我们构建了一个并行模拟器PartitionSim,来模拟Godson-T众核架构.PartitionSim使用POSIXthread(Pthread)实现,运行在SMPlinux上.通过运行移植的SPLASH-2应用程序,我们评估了PartitionSim在模拟千核Godson-T架构时的性能.结果显示,PartitionSim具有良好的加速比,速度可达25MIPS,平均时序损失为0.92%.本文第2节描述PartitionSim的系统结构;第3节讨论时序分割的核心思想;第4节讨论实验结果;第5节描述相关工作;然后第6节给出结论和未来工作.Page32PartitionSim体系结构PartitionSim是一个面向众核结构的应用程序级并行模拟器.图2展示了一个多线程应用程序如何被映射到一个众核处理器中,并由一个四核的SMP宿主机模拟.如图2所示,目标众核处理器是典型的tile设计,包括两种tile:Coretile和MC(MemoryController内存控制器)tile.这些tile被一个片上mesh网络连接起来.每个Coretile包含一个小核,一个共享L2$和一个router.每个MCtile包含一个router和一个内存控制器.MCtile放置在mesh网络两侧.内存控制器的带宽可以配置以便模拟不同的片外带宽.PartitionSim采用模块化设计,它包含一个功能模块和多个时序模块.功能模块和小核的时序模块合起来称为Coremodel,其它的时序模块:router、L2$和MC合起来称为NOCmodel.这些模块均来自Godson-T众核模拟器GAS[13],其正确性和准确性都是被Godson-T原型芯片[12]验证过的.如图2所示,在PartitionSim里一共有两种线程:AP(Async-Parallel)线程和SP(Sync-Parallel)线程.AP线程模拟Coremodel,SP线程模拟NOCmodel.图3展示了PartitionSim的详细实现.AP线程之间异步运行,SP线程之间每个时钟周期都需要同步.注意,当目标程序中有同步时,AP线程也要同步以保证正确性.AP线程输出trace给SP线程.SP线程借助这些trace来完成NOC部分的时序模拟.每个trace单元包含一个时间戳、事件类型和相关的地址或者数据.在目前的设计中,AP线程把trace写入文件,然后由SP线程读出来.这样的内存—磁盘—内存的方式简化了模拟器的设计,同时又能方便评估AP线程和SP线程的时间开销.另外,以文件形式存在的trace可以节省后续重复模拟的时间,这在模拟不同参数的片上网络时尤其有效,因为Core部分不需要重复模拟,只需要直接读入trace文件.相应地,整个模拟时间也被分为AP时间和SP时间.AP时间又被分为APS(APSequential)时间和APP(APParallel)时间.APS时间指模拟器模拟目标程序串行阶段的时间.目标程序串行阶段是目标程序只有一个活动线程的阶段.APP时间是指模拟器模拟目标程序并行阶段的时间.SP时间被划分成SPW(SPWorkload)和SPB(SPBarrier)时间.SPW是指SP线程的负载开销(Workload)时间,SPB是指SP线程的同步(Barrier)开销时间.APS部分被单个线程模拟,模拟时间不会因为宿主机的核数变化而变化.APP部分由多AP线程异步并行模拟,是并行加速比的主要贡献者.对于SPW和SPB,当主机核数增大时,SPW时间因为并行模拟而减少,SPB时间因为同步开销增大而增加.Page43时序分割这一节讨论时序分割的关键:时序假设和时序重建.下面,我们将以Cache-Miss-Refill事件为例来解释时序假设和时序重建的工作原理.一个Cache-Miss-Refill事件包含一个Cache-Miss(Cache失命中)事件和对应的Cache-Refill(Cache回填)事件.当一个Core时序模块发出一个Cache-Miss事件时,它会粗略计算相应的Cache-Miss-Refill延迟,包括片上网络延迟、L2$处理时间和可能的片外延迟.在PartitionSim中,我们采用简单的算法来估计这些延迟:片上网络的延迟通过一个片上网络拥塞模型来计算;L2$的miss/hit信息和可能的片外延迟由简单的估计模型来预测.在下文中,我们用AL(AssumedLatency)和RL(RealLatency)指代假设和真实的Cache-Miss-Refill延迟.Core计算出AL后,会根据AL来继续模拟Coremodel,直到Core完全被阻塞或者Cache-Refill事件发生.在这个过程中所模拟的目标时序被称为重叠时序(Overlappingcycles).重叠时序可以很容易地从现代流水线处理器架构中观察到.例如,当一个访存请求在Cache中发生miss并等待回填时,流水线可以继续执行流水线上的指令.此时,核外时序和核内时序就会有重叠.图4(a)描述了重叠时序的一个简单示意.接下来,为了方便讨论,我们会用MO(MaximumOverlappingcycles)来表示一个小核在无限大回填时间情况下发生的重叠时序.NOC模块接收Core模块发来的Cache-Miss事件,重建它的时间戳,然后模拟它的NOC时序.重建时序需要Core时序模块和NOC时序模块的协作.Core维持一个本地时钟,本地时钟不包含重叠时序.NOC记录所有NOC延迟的总和,把它加到事件的时间戳上来重建其事件戳.图4(b)描述了一个时序重建的例子:Core在本地时钟的第3拍发出了一个Cache-Miss事件;NOC模拟这个事件的Cache-Miss-Refill延迟(时间戳为10)并且记录下来为下次时序重建准备;于此同时Core继续模拟重叠时序,注意此时Core的本地时钟被关闭并且不记录重叠时序.当重叠时序耗尽时,Core重新打开本地时钟继续模拟.在本地时钟第8拍,Core发出第2个Cache-Miss事件(时间戳为8).NOC模块重建其时间戳为18(18=8+10),然后再用它去模拟NOC延迟.当MO<AL并且MO<RL时,也就是说,不管是在假设的时序下,还是在真实时序下,一个Core都会在Cache-Miss后,Cache-Refill前阻塞.此时,AL和RL的差别并不影响时序重建的结果,因为两种情况下的重叠时序是相同的.实时上,现代众核结构多采用简单的顺序小核和通用的互联网络.在这种情况下,核外访存的延迟(NOC延迟)往往要大于小核可以运行的重叠时序.在这种情况下,本文提出的时序重建工作就能准确地恢复Core-to-NOC的通信时序.在某些情况下,Core在阻塞前连发两个Cache-Miss(例如,指令Cache-Miss和数据Cache-Miss).在这些情况下,Core会假设相应的Cache-Refill事件是串行发生,并且间隔足够的时间.虽然这个假设是不准确的,但这种时序损失是有限的,因为这种情况是小概率事件.在现代处理器中,L1$的命中率经常超过95%,指令和数据Cache-Miss的概率更小.4实验这节介绍相关实验和结果.4.1节描述了主机和目标结构配置.4.2和4.3节讨论PartitionSim的模拟速度和精确度.4.4节对PartitionSim和传统PDES、Graphite进行比较.4.1实验环境本实验的宿主机是一个16核的Intel(R)Xeon(R)E7420CPUs,主频2.13GHz,内存大小128GBDRAM.操作系统是RedHatSMPLinux,kernel版本是2.6.18.模拟目标结构是4种千核Godson-T架构,分别命名为T1024,T2048,T4096和T8192.4种结构的配置都列在表1中.以T1024为例,1024个Page5Coretile和64个MCtile连接在一个34×32的片上网络上.关于Godson-T和它的软件管理Cache一致性的实现可以参照文献[10,14].对于目标程序,我们模拟了SPLASH-2里3个具有代表性的程序(lu,radix和fft)和一个矩阵乘算法matrix.表2列举了这些测试程序的负载参数.目标程序T1024T2048T4096T8192注:时钟频率:1GHz;L1(D/I)Cache:Private,32KB(percoretile),32Bytelinesize,4-wayassociative,LRUreplacement;L2Cache:shared,128KB(perL2$tile),64Bytelinesize,8-wayassociative,LRUreplacement;OFF芯片延迟:150cycles.目标应用指令数/109并行时钟周期/109表3实验结果radix_1024radix_2048radix_4096radix_8192fft_1024fft_2048fft_4096lu_1024lu_2048lu_4096lu_8192matrix_1024matrix_2048matrix_4096matrix_8192从图5可以看出:一个程序APP比例越大,获得的加速比越大.如图6显示,目标程序的APP比例大小排序是:lup01>matrix_p01>radix_p01>fft_p01.图5中显示的加速比也正好符合这个顺目标函数matrix1024×1024fftradixlu1024×1024(8×8block)1K,2K,4K,8K4.2模拟速度表3列举了实验结果,包括指令数目、并行时钟周期和不同数目主机线程加速下的运行时间.每个程序都在不同的架构上运行.例如,fft_1024即指fft创建了1024个线程,运行在T1024上.运行结果对应的MIPS(MillionInstructionsPerSecond)值(指令数目/运行时间)显示在图5上.模拟时间比例分布显示在图6上.11880695254770287318212482911939613032191708359481846689974459208472947361921634977194347325162319418300141091257144952298532140016401146496476644020285432043415634275961478076504778275754764265451395074214205114893534412617513742709027682013323655111264441362610173494124571310766128425940282413768281497178093408146867916751992547681915898序.这是因为APP部分是完全异步模拟的,是并行模拟最受益的部分.注意,fft_展示出最坏的加速比,这是因为它的APP比例最小,并且APS比例最大,因为APS部分是串行模拟的,并不能从并行模拟中获益.尽管同步代价(SPB的时间比例)随着主机核数增加而增加,但是加速比却没有显著降低.这是因为SPB的比例相比其它部分小(图6).出现这个现象是因为:在千核情况下,每个主机线程要模拟上百个目标小核,庞大的工作量完全淹没了同步开销的效果.4.3模拟精度图7展示了4个目标应用的模拟精确度.精确度是通过与串行模拟的时序结果比较得来的(串行Page6图6radix_(a),fft_(b),lu_(c),andmatrix_(d)的模拟时间分布模拟的时序结果作为我们的“黄金”标准).如图6所示,时序错误(Error)都小于1.4%.因为大多数Cache-Miss-Refill事件都符合MO<AL并且MO<RL.为了证明这样的解释,我们从fft_1024,lu_1024,radix_1024,andmatrix_1024中分别采样了1M时钟周期.在这些时间里,对每个事件记录3个参数:AL、RL和MO.把所有目标小核的所有事件的这3个参数加起来形成了图8的结果.从图中可以看出,MO<AL<RL.这符合MO<AL并且MO<RL.一个有趣的现象是,fft_虽然有最大的串行部分(APS),但却表现出最大的时序错误.仔细分析这个程序,我们发现,fft_相比于其它程序,有更多时序违例的可能.这是因为fft的程序特征:数据局部性差,片上通信频繁,长延迟指令最多.fft_1024的第一级Cache的命中率为94.3%,这要低于radix_1024(98.9%),lu_1024(99.9%)和matrix(99.9%).频繁的Cache-Miss事件会增大并发Cache-Miss的可能.另外,在fft里,除法指令的比例约为3%,在Godson-T小核中,一个单精度除法指令最多耗费11个时钟周期,一个双精度除法指令最多耗费17个时钟周期.这些长延迟指令容易导致超过AL和RL的重叠时序.这两种情况导致fft的时序重建效果相对较差,从而产生相对大的时序错误.4.4模拟比较这一节列出了相关的比较实验.第1个实验是比较PartitionSim和传统PDES方法,其中传统PDES方法以按拍同步的方式并行模拟.如图9所示,PartitionSim无论是在绝对速度(MIPS)还是在加速比上都比传统PDES方案要好.这是因为传统PDES方法需要每个主机线程在每拍都要遍历所有相关目标模块(Core、Router和L2$),导致很差的Cache利用率.这一点可以从比较两种方法的串行模拟看出来.如图9所示,串行模拟时,PartitionSim要明显快于PDES:radix_1024快76%,lu_1024快60%,matrix_1024快80%,lu_1024快200%.第2个实验是比较PartitionSim与Graphite.Page7图84个程序中采样的1M时钟周期中的AL(上面),RL(中间)和MO(下面)图9PartitionSim(.par)和传统PDES(.PDES)模拟速度比较图10显示了两个模拟器在fft,radix,和lu上的加速比.PartitionSim的加速比是通过计算_1024,_2048,_4096和_8192的平均值得来的.Graphite的加速比来自于文献[9].注意Graphite的16核模拟是在两个机器上实现的.比较结果显示,Parti-tionSim在单机情况下(1到8核)比Graphite的加速比稍好.对于精确度,虽然PartitionSim的精确度依赖于目标程序的特征,但其展现的平均时序错误仅为0.93%,这要比Graphite低,Graphite的时序错误在Lax情况下是7.5%,在laxP2P情况下是1.28%,在lax-barrier情况下是1.31%.PartitionSim的高精确度来自它的时序重建算法和对交互部分(NOC)的按拍同步模拟.这种同步方式比Graphite的lax,laxP2P,lax-Barrier的都要严格.图10PartitionSim(.par)和Graphite(.gra)的加速比比较5相关工作模拟是开发新型计算结构的关键技术.目前有很多模拟器,但大多数是串行的.串行模拟器运行在Page8单个主机线程上,当目标结构上的核数越来越多时,分配给单个核的模拟能力就会下降.目前的加速模拟技术包括:并行模拟[4-6]、直接执行[6]、FPGA加速[7]等等.在这一节,我们对与本文密切相关的工作进行讨论,包括:传统PDES(并行离散事件驱动的模拟器)模拟器、SlackSim、Graphite和COTSon.在传统的PDES模拟器里,主线程要经常同步以维持系统的正确性和准确性.放松同步是加速PDES的主要方式.基本上有两种放松方式:保守的和激进的.保守方法非常小心地避免时序违例,并保证事件被完全顺序模拟.这方面的放松方法包括文献[14]的时间桶同步方式、WWTII[9]的基于quantum的同步方式和文献[10]的提前量(lookahead)方式.时间桶(timebucket)同步方式把模拟过程分成T周期的间隔,并行的线程每隔T个时钟周期同步一次.T被定义为目标模块的最小交互延迟.基于quantum的同步方式与时间桶的方式很相似.“quantum”也就是时间桶里的时钟周期间隔T.唯一的不同是quantum是动态计算而来的.在提前量方法中,接收事件的Core会得到一个提前量L,然后对这个小核就可以安全地模拟L个时钟周期而不需要同步.激进的放松方法允许时序违例发生,但是一旦它检测到时序违例,就会发生回滚.代表性模拟器包括GTW[4].最著名的激进方法是TimeWarp[14]操作系统中采用的技术.这种技术周期性地设置检查点,一旦发现时序违例就回滚到最近的检查点,然后以此为起点重起安全模拟.虽然激进的PDES方案提供更多的放松,但是代价昂贵.首先,必须有额外的时间和空间开销来保存检查点.第二,额外的时间和空间来传递和保存额外的消息和事件(如GTW中的anti-messages).第三,回滚和重新执行都会耗费存储和计算资源.另外,如果放松的尺度过大,时序违例和回滚就更容易发生,会降低模拟效率.与传统PDES模拟器不同的是,现代PDES模拟器更加侧重速度.典型的模拟器有SlackSim和Graphite.在SlackSim里有两种主机线程:Core线程和Manager线程.Core线程和Manager线程互相通信,构建一个时钟窗口.当所有thread的本地时钟落在这个窗口里时,就可以自由运行.当时钟差距超过这个窗口时,同步就会发生.这种方法相比于传统PDES能产生更大的放松量.但是,一个大的时钟窗口又会产生更多的时钟错误和违例.Graphite采用了多级分布式模拟,从而提供更好的扩展性.然而,跨机通信的高延迟不适合严格的同步方案.所以Graphite不得不采用近似估计和建模的方法来构建“全局时钟”来提高精确度.时序重建的概念首先由COTSon[15]提出,COTSon是一个支持功能-时序分割的模拟器.在COTSon里,时序重建被用来重建自旋锁(spin-lock)的时序.PartitionSim是一个支持时序-时序分割的模拟器.在PartitionSim里,时序重建主要用来恢复被假设的时序通信.另外,COTSon的功能部分采用AMD的SimNow!.SimNow!是个串行模拟器,它限制了COTSon的扩展性.6结论和下一步工作这篇文章介绍了PartitionSim,一个面向未来众核结构的模拟器,并提出了一个新颖的并行模拟方法来提高模拟速度并产生较小的时序损失.实验显示,PartitionSim在模拟上千核的Godson-T众核结构时有良好的加速比、可观的速度和较小的时序损失.与传统PDES和现代PDES(Graphite)的比较显示,PartitionSim具有明显的速度和精度优势.本文的工作集中在对Godson-T这样的软件管理的Cache一致性众核结构上,下一步我们将研究用时序分割的方法去模拟更通用的众核结构,如采用硬件Cache一致性的众核结构.
