Page1基于环境敏感分析的恶意代码脱壳方法王志贾春福鲁凯(南开大学信息技术科学学院天津300071)摘要加壳技术是软件的常用保护手段,但也常被恶意代码用于躲避杀毒软件的检测.通用脱壳工具根据加壳恶意代码运行时的行为特征或统计特征进行脱壳,需要建立监控环境,因此易受环境敏感技术的干扰.文中提出了一种基于环境敏感分析的恶意代码脱壳方法,利用动静结合的分析技术检测并清除恶意代码的环境敏感性.首先,利用中间语言对恶意代码的执行轨迹进行形式化表示;然后,分析执行轨迹中环境敏感数据的来源和传播过程,提取脱壳行为的环境约束;最后,求解环境约束条件,根据求解结果对恶意代码进行二进制代码插装,清除其环境敏感性.基于此方法,作者实现了一个通用的恶意代码脱壳工具:MalUnpack,并对321个最新的恶意代码样本进行了对比实验.实验结果表明MalUnpack能有效对抗恶意代码的环境敏感技术,其脱壳率达到了89.1%,显著高于现有基于动态监控的通用脱壳工具的35.5%和基于特征的定向脱壳工具的28.0%.关键词恶意代码分析;脱壳技术;环境敏感分析;污点分析;符号执行1引言加壳是一种重要的软件保护技术,它可以对软件的二进制代码进行加密或压缩,并在执行过程中动态解密或解压缩这些代码,增加软件逆向分析的难度.脱壳技术则是恢复被隐藏的代码,降低软件的分析难度.近年来,越来越多的恶意代码为了躲避杀毒软件的检测使用了加壳技术.据统计,2008年超过80%的恶意代码使用了加壳技术[1],而且,加壳方法的数量也以每个月10~15种的速度递增[2].针对上述情况,为了检测加壳的恶意代码,出现了许多脱壳工具,其中主要包括基于特征匹配的定向脱壳工具和基于动态监控的通用脱壳工具两类.定向脱壳工具的工作方式是,先提取各种壳的特征,然后为每种加壳方法设计解壳算法.定向脱壳工具脱壳速度快而且准确,杀毒软件通常使用定向脱壳方法,例如ClamAV①.但是,定向脱壳工具需要维护大量用于模式匹配的特征,例如,查壳工具PEiD②包含有600多种特征.定向脱壳工具不能处理未知的加壳方法,缺乏通用性.通用脱壳工具利用加壳技术所固有的动态特征进行脱壳.被加壳程序的执行过程先是在内存中恢复被加密或压缩的代码,然后将CPU控制权转交给这些新生成的代码使其执行.因此,“先写后执行(written-then-executed)”是所有加壳程序在执行过程中的基本行为特征.此外,程序在解密或解压缩前后的信息熵、常用指令对(bigram)等统计属性的变化也可以用于启发式的脱壳策略.该技术不依赖于各种加壳方法的静态特征,也不需要单独编写解壳算法,具有很好的通用性,例如,PolyUnpack[3]、Renovo[4]、OmniUnpack[5]、OllyBonE③、Eureka[6]、Justin[1]等.通用脱壳工具需要一个可控的执行环境去主动地或被动地监控加壳程序的执行过程,以实现对被加壳程序动态行为特征的识别.然而,可控环境和监控策略会增加程序的运行开销,易于被环境敏感技术识别和干扰.2008年,微软公司的Ferrie[7]指出,反调试和反虚拟机等技术可以用于识别通用脱壳工具的监控环境.这些检测方法可以使恶意代码变得对环境敏感,也就是能在脱壳之前判断当前的执行环境是否“危险”,如果发现自己运行在被调试或者被虚拟执行等危险环境中,就立即停止执行或者延迟执行.2009年,Liu等人[8]提出了利用执行某段代码的CPU时钟周期异常来间接检测监控环境的存在,并构造出能够对通用脱壳工具产生DoS攻击的代码.通用脱壳工具的监控环境是固定不变的,不能根据恶意代码的环境敏感性进行动态调整,导致其分析的准确性易受环境敏感技术的干扰.构造同真实环境一致且不增加额外运行开销的监控环境很难.本文在不修改监控环境的基础上,提出了一种基于环境敏感分析的恶意代码脱壳方法,利用恶意代码的行为与执行环境间的依赖关系,识别并去除恶意代码的环境敏感性,使通用脱壳工具能够更有效地提取被加壳技术保护的恶意代码.该方法的工作步骤如下:首先,在可控环境中动态记录恶意代码的执行轨迹(executiontrace),并用中间语言[9](intermedi-atelanguage)对执行轨迹进行形式化描述.然后,在中间表示基础上,引入高级语言分析中用到的污点分析和符号执行[10]技术,提取恶意代码的环境敏感变量和基于敏感变量的路径约束,并利用约束求解工具[11]推理恶意代码的路径空间与执行环境间的依赖关系.最后,利用二进制代码插装技术动态修改恶意代码内部的环境敏感数据,去除恶意代码对可控环境的敏感性,实现通用脱壳工具对其动态脱壳.本文提出的基于环境敏感分析的恶意代码脱壳方法,已经在自主研制的MalUnpack系统中实现.在本文的实验部分,用MalUnpack对321个最新加壳恶意软件进行了分析,并与定向脱壳工具和通用脱壳工具的分析结果进行了对比.实验结果表明,本文的方法能够识别并去除大部分恶意代码的环境敏感性,脱壳率显著高于无环境敏感分析的通用脱壳工具和定向脱壳工具.本文第2节介绍恶意代码执行轨迹的中间表示;第3节全面阐述基于环境敏感分析的恶意代码脱壳方法;第4节给出系统实现和实验结果,并对实验结果进行分析和对比;第5节介绍相关的研究工作;最后,在第6节给出本文的结论.2执行轨迹中间表示执行轨迹包括恶意代码执行过程的详尽信息,①②③Page3例如,指令序列、CPU状态、寄存器与内存值等.从执行轨迹中提取恶意代码与执行环境的依赖关系要用到流敏感的污点分析技术和路径敏感的符号执行技术.但是这些分析技术是面向高级语言的.通常恶意软件是不开源的,只有二进制代码样本.二进制代码缺少高级语言的类型和结构信息,指令种类繁多,而且大部分指令会隐式地影响CPU状态寄存器.因此,需要一种简化的没有副作用的语言对二进制代码执行轨迹进行重新描述.本文引入了一种简单的静态单赋值(StaticSin-gleAssignment,SSA)中间语言UnpackIL,如图1所示.本节对UnpackIL中间语言的语法结构、上下文环境和操作语义进行了详细阐述,并以木马Wowsteal.AX执行轨迹的中间表示为例进行说明.program····=stmtstmts····=var··=exp|mem_write(exp,exp)expe····=mem_read(exp)|expbexpb····=typicalbinaryoperatorsu····=typicalunaryoperatorsvaluev····=signed|unsigned_1bit|8bit|16bit|32bit2.1语法结构在UnpackIL中,程序由一系列语句(state-ment)组成,其中包括4类基本语句:赋值语句(assignments)、断言语句(assertions)、跳转语句(jumps)和条件跳转语句(conditionaljumps).b用于表示二元操作,例如加、减、与、或等.u用于表示一元操作,例如逻辑非等.getinput(src)表示从源src中获得的输入.源src的定义将在下一节的污点传播分析部分进行详细说明.在UnpackIL中内存值或寄存器值分为有符号和无符号整数量两种,所占用的存储空间有1bit、8bit、16bit和32bit4种.UnpackIL目前不支持浮点数的表示.UnpackIL与二进制代码相比有如下3个优点:(1)指令的操作语义明确,没有隐式副作用,对CPU状态字的影响被显示地表现出来;(2)指令的种类少,比x86指令集精简,操作语义简单;(3)采用静态单赋值形式(staticsingleassignmentsform),变量的定义和引用关系明确.2.2执行中的上下文环境指令的上下文环境用一个4元组表示,EC=(Σ,Δ,pc,s),如表1所示.其中,Σ是程序的语句集合,通过索引值可以定位每一条语句;Δ是程序的变量集合(包括变量、寄存器和内存),可以通过变量名读写对应的值(例如,Δ[x]表示读取变量x在当前上下文环境Δ中的值,Δ[x←10]表示将当前上下文环境中变量x的值设为10);pc是程序指针,它指向当前正在执行的语句;s是下一条将要执行的语句.2.3操作语义(operationalsemantics)下面是UnpackIL操作语义的描述格式:操作语义是说明语句和表达式是如何执行的,其中:stmt是当前要执行的语句;EC是当前的上下文环境;EC是语句stmt执行后的上下文环境;stmt是下一条待执行语句,computation是语句stmt在EC上下文环境中的计算过程.表2列出了UnpackIL表达式和语句的操作语义.其中,Δ|e→v表示在上下文环境Δ中计算表达式e的值并将结果赋值给变量v;Δ=Δ[x←v]表示将变量v的值赋给变量x并更新上下文环境Δ成为Δ.操作符InputMem_ReadUnary_OpBinary_OpΔ|e1→v1,Δ|e2→v2,v=v1bv2AssignΔ|e→v1,Δ=Δ[var←v1],s=Σ[pc+1]GotoTrue_BranchΔ|e==1,Δ|e1→v1,s=Σ[v1]False_BranchΔ|e==0,Δ|e2→v2,s=Σ[v2]Mem_WriteΔ|e1→v1,Δ|e2→v2,Δ=Δ[v2←v1],s=Σ[pc+1]AssertPage4图2是木马Wowsteal.AX执行轨迹中环境敏感部分的中间表示.其中Wowsteal.AX首先使用rdtsc指令获取CPU当前的时钟周期.rdtsc指令有隐式地修改CPU寄存器edx和eax的副作用,在中间表示中该隐式副作用被显示地表示成两段赋值语句.然后Wowsteal.AX利用条件跳转指令jbe判断运行环境是否可疑.在该段执行轨迹中jbe发现CPU时钟周期大于阈值,在中间表示中用True_Branch的语义进行描述.1:rdtscAssign(EAX_0:unsigned_32bit,Input(rdtsc,(0xbcf0aac0,T)))Assign(EDX_0:unsigned_32bit,Input(rdtsc,(0x00000076,T)))2:movesi,eax(t)Assign(ESI_0:unsigned_32bit,EAX_0:unsigned_32bit)3:movedi,esi(t)Assign(EDI_0:unsigned_32bit,ESI_0:unsigned_32bit)4:addesi,64hAssign(ESI_1:unsigned_32bit,Binary_Op(+,ESI_0:5:subedi,5hAssign(EDI_1:unsigned_32bit,Binary_Op(-,EDI_0:6:rdtscAssign(EAX_1:unsigned_32bit,Input(rdtsc,(0xbd20dbc8,T)));Assign(EDX_1:unsigned_32bit,Input(rdtsc,(0x00000076,T)));7:cmpesi,eaxAssign(VAR_0:signed_32bit,Binary_Op(-,ESI_1:unsigned_8:jbe0x00401007True_Branch(Binary_Op(,Path_Constraints,Binary_Op(<=,32bit,ESI_1:unsigned_32bit))VAR_0:signed_32bit,(0,T))==TRUE)),Goto(1));图2木马Wowsteal.AX执行轨迹的中间表示unsigned_32bit,(0x64,F)))unsigned_32bit,(0x5,F)))3基于环境敏感分析恶意代码脱壳方法图3给出了基于环境敏感分析的脱壳模型.该模型包括三个部分:首先,定位执行轨迹中环境敏感数据的来源,并利用污点传播分析提取环境敏感数据的扩散过程;然后,通过符号执行提取基于环境敏感数据的路径约束,并判断未覆盖分支的可行性和计算该分支的触发环境;最后,使用二进制代码插装修改恶意代码中的环境敏感数据,去除恶意代码的环境敏感性.3.1环境敏感数据的污点传播分析环境敏感数据的污点传播分析(taintpropaga-tionanalysis)包括两个部分:(1)定位环境敏感数据的来源;(2)对存储环境敏感数据的变量打污点标签,并分析其传播过程.恶意代码动态获取执行环境信息的途径有两种:一种是直接获取,例如,调用系统API函数或者检测特定系统内存等,如表3所示;另一种是间接获取,例如,利用特殊的CPU指令(rdtsc、sidt等),或调用系统API函数,如表4所示.我们把这些检测当前执行环境的方法称作环境敏感数据的来源;存储这些环境敏感数据的变量称作环境敏感变量.KiUserExceptionDispatcher()PEB->NtGlobalFlagNtQueryInformationProcess()Eprocess->NoDebugInherit为了记录环境敏感数据的传播过程,我们对UnpackIL进行了扩展:用二元组表示一个变量〈v,t〉,其中v是变量的值,t是一个布尔值,有T和F两种状态,T状态表示该数据为污点数据,F状态表示数据不是污点数据;在上下文环境中增加了一个变量Δt,用以表示打污点标签的变量集合,如图4所示.表5是中间语言的污点传播规则.规则Rinput()表示如果数据来自于环境敏感源则打污点标签.规则Runary_op(v)表示一元运算不改变数据的污点状Page5态.规则Rbinary_op(v1,v2)表示二元运算的污点状态同两个操作数的污点状态或的结果一致.我们这里仅考虑了数据流中的污点传播,控制流中的污点传播没有涉及,因为环境敏感数据在程序中不用于控制流的间接寻址.表5污点传播分析的中间语言操作语义扩展图5是木马Wowsteal.AX中环境敏感数据的污点传播过程,污点数据被t标记.rdtsc指令是其环境敏感数据的来源,MalUnpack根据Rinput(taint_src)规则将rdtsc的返回值edx和eax打污点标签.movesi,eax(t)指令将寄存器eax的值赋给寄存器esi,根据污点传播规则Rbinary_op(v1,v2),寄存器esi也被标记为污点.图5木马Wowsteal.AX中环境敏感数据的污点传播3.2环境敏感变量对路径选择的影响分析污点传播分析可以记录环境敏感数据的传播过程,但无法表示环境敏感数据对路径选择的影响,为此,本文引入路径敏感的符号执行技术.符号执行是正常执行的扩展,它用符号表示任意的输入值,基于输入值的路径分支条件用布尔表达式表示.从一条路径中收集到的所有布尔表达式的合取范式称作该路径的约束条件(pathconstraints).不同路径的约束条件是不同的,对约束条件的求解可判断路径的可行性并推理该路径的输入集合.本文采用混合执行(concolicexecution)方式,只对污点源的输入用符号表示,其它不相关的变量直接使用执行轨迹中的具体数值,降低约束求解的复杂度.本节对UnpackIL进行了扩展,如表6所示.在执行环境中加入了路径约束变量Π,它是一个布尔表达式的合取范式.环境敏感变量使用符号表示,扩展了与环境敏感变量相关的断言和分支语句的操作语义,使其支持对路径约束的收集.操作符InputAssertΔ|e==1,Π=Π∧e,s=Σ[pc+1]True_BranchΔ|e==1,Π=Π∧(e==1),Δ|e1→v1,s=Σ[v1]False_BranchΔ|e==0,Π=Π∧(e==0),Δ|e2→v2,s=Σ[v2]图6是符号执行收集的木马Wowsteal.AX环境敏感部分的路径约束,采用了约束求解工具STP的语法格式.ASSERT(0bin1=(LETConstraint_0=0bin1IN(LETR_EAX_0=INPUT_0IN(LETR_ESI_0=R_EAX_0IN(LETR_EDI_0=R_ESI_0IN(LETR_ESI_1=BVPLUS(32,R_ESI_0,0hex00000064)IN(LETR_EDI_1=BVSUB(32,R_EDI_0,0hex00000005)IN(LETR_EAX_1=INPUT_1IN(LETTEMP_0=IF(BVLE(R_ESI_1,R_EAX_1))THEN0bin1ELSE0bin0ENDIFIN(LETConstarint_1=(Constraint_0TEMP_0)IN(LETConstraint_1)))))))))));3.3启发式路径选择策略如果当前环境没有检测到恶意代码的脱壳行为,则需要分析该执行轨迹上的环境约束,确定并清除恶意代码的环境敏感性.执行轨迹中跟环境有关的路径分支很多,我们根据环境敏感恶意代码的行为特征,提出了一种启发式路径选择算法,用于在路径空间中尽快找到脱壳路径.算法1描述了如何从执行轨迹中定位脱壳路径,其中使用了两个启发式策略:基于环境相关死循环的启发式路径选择策略;基于代码覆盖和路径前缀的启发式路径选择策略.环境相关的死循环是指在规定的监控时间内没有正常退出的循环,且其循环退出条件与环境敏感Page6变量相关.基于环境相关死循环的启发式路径选择策略针对的是在发现可疑执行环境后延迟执行脱壳过程甚至DoS攻击当前环境的恶意代码.还有一些恶意代码发现可疑执行环境后会立即停止执行.为此,我们提出基于代码覆盖和路径前缀的启发式路径选择策略.在监控环境中被执行过的代码称为已覆盖代码,未被执行过的代码称为未覆盖代码,选择含有未覆盖代码的路径有利于提高通用脱壳工具的代码覆盖率.离路径结束点越近的分支路径与已分析路径的相同路径前缀越长.由于环境敏感代码可能通过立即终止执行来躲避监控,因此,相同路径前缀越长的环境相关分支含有脱壳过程的可能性越大.算法1.MalUnpack路径分支选择算法.输入:Set:set_b//基于环境变量的路径分支集合输出:(variable,value)//需要修改的变量和变量取值//1.基于环境相关死循环的启发式路径选择策略1.if(executiontimesout){2.Branchloop_b=find_endless_loop(set_b);3.for(eachbranchbinset_b){4.if(b!=loop_b){5.loop_c=loop_candmap_c{b};6.}7.else{8.loop_c=loop_cand(!map_c{b});//条件取反9.break;10.}11.}12.(variable,value)=solving(loop_c);13.loop_b->analyzed=1;//标记分支已经分析过14.return(variable,value);15.}//2.基于代码覆盖和路径前缀的启发式路径选择策略16.else{17.do{//定位路径前缀最长且入口点代码未被分析的路径分支18.Branchlast_b=find_last_branch(set_b);19.remove(set_b,last_b);20.}while(!is_uncovered_block(last_b->21.for(eachbranchbinset_b){//计算分支条件22.if(b!=last_b){23.last_c=last_candmap_c{b};24.}25.else{26.last_c=last_cand(!map_c{b});//条件取反27.break;28.}29.}30.(variable,value)=solving(last_c);31.last_b->analyzed=1;//标记分支已分析32.return(variable,value);33.}启发式的路径选择策略可以帮助我们尽快定位脱壳路径,但是不能保证找到的路径一定是脱壳路径.因此,我们还需要多路径的探索,最坏情况是遍历与环境相关的路径空间.3.4清除恶意代码环境敏感性根据路径选择算法提供的数据,环境敏感性清除模块利用直接修改二进制恶意代码中环境敏感变量的值,实现阻止其与环境的交互.算法2描述了清除恶意代码环境敏感性的算法.该算法的输入为启发式路径选择算法得到的环境敏感变量名和变量值,恶意代码二进制可执行文件和恶意代码执行轨迹的中间表示,输出为修改后的恶意代码二进制可执行文件.第1、2行逐行遍历执行轨迹中间表示中的指令,寻找使用了var的指令.UnpackIL是静态单赋值语言,易于变量的搜索.然后根据执行轨迹与恶意代码二进制文件的对应关系,定位指令inst在文件中的存储位置,利用反汇编工具计算变量var在指令inst中的偏移,进而得到变量var在文件中的具体位置(第3~5行).第7行用具体值val直接替换inst中的环境敏感变量var,清除恶意代码的环境敏感性.算法2.恶意代码环境敏感性清除算法.输入:(Variable,Value):(var,val)输出:File:mal//清除环境敏感性的恶意代码1.for(eachInstructioninstintrace){//遍历指令2.if(search(inst,var)){3.Addressaddr_inst=locate_inst(mal,inst);4.intoffset=disasm(addr_inst,var);5.Addressaddr_var=addr_inst+offset;6.replace(mal,addr_var,val);7.}8.}4系统实现与实验分析4.1系统实现基于上述系统模型和分析方法,我们实现了一Page7套基于环境敏感分析的脱壳工具MalUnpack,其中包括3个部分:可控执行环境、通用脱壳模块和环境敏感分析模块.可控执行环境采用的是全系统模拟的方式,利用开源的QEMU①虚拟机实现.QEMU逐条解释CPU指令,通过回调函数,我们可以记录系统中的每一条指令和其上下文环境.通用脱壳模块的实现采用类似于OmniUnpack和PaXPAGEEXEC②的内存访问异常截获技术,通过设置内存页面的属性,使“先写后执行”操作产生内存访问异常.然后,利用系统驱动截获该异常,并从产生异常的软件页中提取脱壳后的代码.环境敏感分析模块是MalUnpack系统的重点.该模块的实现分为3步:首先,定位环境敏感数据和打污点标签,通过QEMU回调函数实现.然后,用UnpackIL中语言表示恶意代码执行轨迹,利用污点分析和符号执行得到执行轨迹的路径约束,该分析过程使用Perl脚本实现.最后,根据启发式路径选择算法和环境敏感性清除算法,实现恶意代码环境敏感性的清除,该部分我们使用Perl脚本实现,其中约束求解部分使用STP工具.4.2实验分析文设计了两组实验:为了分析MalUnpack系统的有效性和效率,本(1)对最新的加壳恶意代码样本分别使用基于特征的定向脱壳技术、基于动态监控的通用动态脱壳技术和本文的基于环境敏感分析的脱壳技术进行对比实验,并对样本的环境敏感性进行统计分析.(2)对样本分析过程中的环境敏感变量传播、环境敏感路径约束的收集和推理等过程进行测试.实验的测试环境为IntelQ94002.66GHz×4CPU,4GBRAM,Linux2.6.28,Ubuntu9.04操作系统,QEMU虚拟机运行的是WindowsXPSP3操作系统.本文共对321个最新流行的加壳恶意代码样本进行了脱壳实验,Fortinet公司反病毒实验室(天津)为本次实验提供了211个样本,另外110个样本是自主研发的MalSAS互联网恶意代码搜索系统在2011年1月1日到2月31日发现的恶意代码样本,样本的分布见表11.实验1.恶意代码脱壳实验和环境敏感性检测.本次实验中,我们使用的静态分析工具为PEiD,它是一款著名的静态查壳工具,含有600多种特征,并有大量的脱壳插件.基于脱壳行为特征的动态脱壳工具我们选择的是基于Ollydbg的OllyBonE工具.OllyBonE使用的脱壳机制与PaXPAGEEXEC和OmniUnpack相同,都是基于内存页面访问异常截获的方法,但PaXPAGEEXEC只适用于Linux系统,而Omni-Unpack由于不公开而无法使用.MalUnpack与PEiD、OllyBonE对样本的脱壳结果如表7所示.PEiD识别出90个样本的加壳信息,占总数的28.0%;OllyBonE监控到114个样本具有脱壳行为,占总数的35.5%;MalUnpack检测到286个样本的脱壳行为,占总数的89.1%.其中有些样本是含有恶意代码的动态链接库或驱动程序,无法在QEMU虚拟机中独立执行,导致基于动态分析的OllyBonE和MalUnpack产生漏报.样本数量查壳和脱壳工具的检测结果Trojan1124839Backdoor1671259Worm633Clicker971Dropper532Downloader221710总数32190114MalUnpack共检测到270个样本使用了环境敏感技术,其中很多样本使用了多种环境敏感技术,如图7所示,检测到115个样本使用了两种环境敏感技术,8个样本使用了3种环境敏感技术,有两个样本使用了4种环境敏感技术.图8给出了各种环①②Page8境敏感技术的使用频率,其中GetTickCount()函数使用得最多,共有217个样本使用,另外有121个样本使用了IsDebuggerPresent()函数检测执行环境,其它环境敏感技术使用得比较少.实验2.环境敏感分析的效率和开销.实验中,利用QEMU虚拟机共得到了286个样本的详细执行轨迹,每条执行轨迹中都记录了几百万到几千万条指令,包含了该样本所属进程被虚拟执行的所有指令.记录这些执行轨迹的文本文件的体积超过了330GB,占用了大量的硬盘空间.虽然执行轨迹中记录了大量的指令信息,但是,其中与环境相关的指令数量很少,我们称这些指令为污点指令,其数量分布情况如图9所示.污点指令数量少于10条的有一个样本,大部分样本的污点指令数在10~1000之间.污点指令数量超过1000条的样本只有26个,这些样本在执行过程中都陷入了与环境相关的死循环.环境敏感的路径分支信息来源于污点指令中的条件跳转指令.在本实验中,与环境相关的条件跳转指令的数量分布很有特点,如图10所示.大部分样本中环境相关的条件跳转指令的数量小于50.含有50~200个环境相关条件跳转指令的样本很少,只有3个.另外,还有一些样本的环境相关的条件跳转指令数量超过了200条.QEMU虚拟机中动态分析的时间上限设置为5min,样本的执行时间超过5min后会被强行终止.这些含有大量环境相关条件跳转指令的样本在动态分析过程中都超过了时间上限,陷入了环境相关的死循环.基于环境相关死循环的启发式路径选择策略根据污点指令的循环结构定位该死循环的退出分支点,并用约束求解工具计算满足该退出条件的环境敏感变量的值,然后根据恶意代码环境敏感性清除算法对恶意代码进行修改.在重新运行修改后的恶意代码时,通用脱壳模块监控到了样本的脱壳行为.大部分样本的环境相关条件跳转指令不多,利用基于代码覆盖和路径前缀的启发式路径选择策略在有限次的多路径尝试下,通用脱壳模块都监控到了样本的脱壳行为.4.3讨论由上面的实验结果可知,MalUnpack能够有效地识别并去除加壳恶意代码的环境敏感性,脱壳效果优于使用模式匹配的定向脱壳方法和执行环境固定的通用脱壳方法.但需要指出的是,MalUnpack还存在一些影响分析结果的因素.一方面,准确定位环境敏感数据的来源需要先验知识,即需要先确定环境敏感技术可能使用到的系统函数、系统内存或者CPU指令等.如果加壳技术使用了新的环境敏感方法,则本文的方法可能引起漏报.解决这个问题需要扩大环境敏感源的范围,例如,将环境敏感源扩大到对系统内存区域的所有读操作.另一方面,环境敏感分析利用的是执行轨迹中发现的路径选择与执行环境的依赖关系.当前恶意代码样本中的环境依赖关系比较简单,全部可以用布尔逻辑运算和线性数值运算表示,而且用于检测执行环境的指令数量Page9相对于整个程序来说很少.如果恶意代码加强了对路径信息的保护,增加了环境检测代码的复杂度,则可能引起分析准确性的下降.解决该问题可以采用路径切割等分析方法加强对恶意代码路径信息的分析和推理能力.5相关研究工作当前基于特征匹配的定向脱壳工具由于通用性差,逐渐被更加通用的基于动态监控的脱壳工具所取代.动态脱壳工具需要一个可控的执行环境,在该环境中执行加壳的恶意代码,实时地根据恶意代码的行为特征或统计特征定位并提取被加壳代码.PolyUnpack[3]通过对比恶意软件静态反汇编代码和实际执行代码的差异来识别和提取动态生成的解壳后代码.Renovo[4]、OllyBonE①、OmniUnpack[5]、Pandora[12]、Paradyn②、Saffron[13]和Azure[14]等脱壳方法利用脱壳过程“先写后执行(written-then-executed)”的固有特征来识别解壳后的代码.Eureka[6]通过监控系统调用NtTerminateProcess()、NtCre-ateProcess()和常用指令对的出现频率来识别恶意代码的脱壳行为.监控环境暴露了脱壳工具的存在,环境敏感技术[7-8,15-16]可以检测到构建监控环境所用到的虚拟机、调试器和模拟器等工具.恶意代码已经逐渐使用环境敏感技术来躲避基于动态监控的脱壳工具的分析.Brumley等人[17]提出了针对恶意软件中条件触发行为(trigger-basedmaliciousbehavier)的分析方法,通过监控恶意代码所调用的系统函数,利用污点分析和混合执行推理恶意行为的触发条件.Cho等人[18]利用有穷状态机模型分析僵尸代码与网络输入间的依赖关系,推理出僵尸网络的命令和控制协议.现有恶意代码条件触发行为的分析方法针对的是系统调用的返回值,但是环境敏感加壳技术的环境敏感源不仅包括系统调用,还包括系统内存、CPU指令等.此外,实现恶意代码脱壳,除了推理恶意代码与执行环境的依赖关系,还需要清除其环境敏感性,诱导其在动态执行过程中暴漏脱壳行为.6结论本文提出了一种基于环境敏感分析的恶意代码脱壳方法,利用恶意代码执行轨迹中泄露的与环境相关的路径信息,有效地推理并清除恶意代码的环境敏感性,引导恶意代码执行其脱壳过程.本文提出的脱壳方法已经在MalUnpack原型系统中实现,并与定向脱壳工具和监控环境固定的通用脱壳工具对最新的加壳恶意代码进行了对比实验,实验结果表明该方法能有效地抵抗环境敏感技术的干扰,脱壳效果明显优于传统脱壳工具.本文提出的恶意代码环境敏感性检测和清除方法为受环境敏感技术困扰的动态分析方法提供了新的思路.下一步的工作中将进一步研究恶意代码的行为同执行环境间的依赖关系,增强动态分析恶意代码的准确性和全面性.致谢感谢Fortinet反病毒实验室主任张杰在本文实验过程中所给予的帮助!
