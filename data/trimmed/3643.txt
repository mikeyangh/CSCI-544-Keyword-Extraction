Page1开销敏感的多处理器最优节能实时调度算法张冬松1)吴飞2)陈芳园1)吴彤3)郭得科4)金士尧1)1)(国防科学技术大学计算机学院并行与分布处理国家重点实验室长沙410073)2)(上海工程技术大学电子电气工程学院上海201620)3)(国防科学技术大学国家安全与军事战略研究中心长沙410073)4)(国防科学技术大学信息与管理学院信息系统工程国家重点实验室长沙410073)摘要嵌入式多处理器系统的能耗问题变得日益重要,如何减少能耗同时满足实时约束成为多处理器系统节能实时调度中的一个重要问题.目前绝大多数研究基于关键速度降低处理器的频率以减少动态能耗,采用关闭处理器的方法减少静态能耗.虽然这种方法可以实现节能,但是不能保证最小化能耗.而现有最优的节能实时调度未考虑处理器状态切换的时间和能量开销,因此在切换开销不可忽视的实际平台中不再是最优的.文中针对具有独立动态电压频率调节和动态功耗管理功能的多处理器系统,考虑处理器切换开销,提出一种基于帧任务模型的最优节能实时调度算法.该算法根据关键速度来判断系统负载情况,确定具有最低能耗值的活跃处理器个数,然后根据状态切换开销来确定最优调度序列.该算法允许实时任务在处理器之间任意迁移,计算复杂度小,易于实现.数学分析证明了该算法的最优性.关键词实时系统;多处理器;节能调度;动态电压频率调节;动态功耗管理;绿色计算1引言随着芯片制造商正在推出多核芯片和片上多处理器系统,多处理器平台变得更加普遍,受到了智能嵌入式实时系统领域越来越多的关注.处理器的高性能会带来高能耗.能耗管理已经成为嵌入式实时系统中一个亟待解决的问题,尤其对于电池供电的嵌入式系统非常重要.电容切换活动产生的动态功耗和泄露电流产生的静态功耗是CMOS处理器能耗的两个主要来源[1].动态电压频率调节(DynamicVoltageFrequencyScaling,DVFS)技术和动态功耗管理(DynamicPowerManagement,DPM)技术已经被应用于现代处理器系统中,DVFS可以在运行时降低供应电压和执行频率以减少处理器的动态功耗,而DPM可以在运行时关闭处理器以减少处理器的静态功耗.由于动态功耗通常是速度(或称频率)的凸函数和递增函数,所以一般来说速度越低,动态能耗越少.但是,较低的执行速度会延长实时任务的执行时间,又因泄露电流的影响而导致更多的静态能耗.因此,节能实时调度研究需要兼顾动态能耗和静态能耗,在满足实时约束的条件下最小化能耗[2].早期的多处理器节能实时调度技术研究表明:在只考虑动态功耗的条件下,为了最小化能耗,最优的任务分配必须使得任务集的总负载在多个处理器上均匀分配[3].典型的方法是基于多种装箱问题启发式方法如FFD(First-FitDecreasing)、NFD(Next-FitDecreasing)、BFD(Best-FitDecreasing)和WFD(Worst-FitDecreasing),先将任务分配到指定的处理器上,然后利用单处理器平台中提出的各种节能实时调度算法来独立调节每个处理器的电压和频率.这样便可以将复杂的多处理器节能实时调度问题转化为多个简单的单处理器节能实时调度问题.但是,Aydin等人[3]已经证明若将任务分配到固定数目的处理器上使其既具有最优的负载均衡又保证任务集可调度性是一个NP-hard问题.还有一些研究者基于全局调度法提出最优的节能实时调度算法.Chen等人[4-5]针对基于帧的任务模型,提出一种最优的节能实时调度算法LTF-M.Funaoka等人[6]则针对周期任务模型,提出了一种最优的节能实时调度算法.但是,随着纳米制造工艺的不断进步,CMOS电路中静态功耗相比动态功耗,在总功耗中所占比重越来越大[1].为了减少因泄露电流所产生的静态能耗,处理器可以利用DPM技术进入睡眠状态(又称关闭)以及从睡眠状态返回活跃状态(又称唤醒).一些研究者针对不可忽视的静态功耗提出了多处理器节能实时调度算法.这些研究成果[5,7-9]通过将处理器转入睡眠状态来减少静态功耗.Xu等人[7]根据工作负载确定活跃处理器的个数,提出节能实时调度算法.deLangen等人[8]则针对具有离散速度的系统提出启发式节能实时调度算法.Chen等[5]针对处理器速度独立调节和统一调节的两种不同处理器模型,基于帧的任务模型提出具有不同近似比的静态节能调度算法,同时他们的成果还进一步扩展到周期任务模型[9].以上所提出的绝大多数调度算法均假设处理器具有活跃状态和睡眠状态,基于关键速度来设定活跃状态时的执行速度,基于状态切换开销来设定何时将处理器转入睡眠状态.这里关键速度是指具有最小能耗的可用执行速度,并且乐观地假设在执行任务之后将处理器转入睡眠状态.但是,处理器关闭和唤醒需要一定的时间和能耗开销.例如,在70纳米技术中Transmeta处理器具有483微焦的能耗开销和至少2ms的时间开销[1].如果状态转换的能耗Page3开销大于能耗节余,那么显然把处理器转入睡眠状态可能不会节能[10].目前,多处理器系统中节能实时调度研究已经开始关注具有切换开销的实际平台.文献[10]通过说明关键速度的非最优性以及负载均衡的非最优性,针对基于帧的任务模型和周期任务模型,提出了一种多项式时间的近似度为1.21的节能实时调度算法.该算法显著地优于原有未考虑开销情况下近似度为1.667的近似算法[9].但是,现有的研究成果[4-5,7-10]主要存在三个方面的问题:(1)大多数节能实时调度算法基于划分调度法或非最优的全局调度法,无法保证实时任务集的最优可调度性.(2)现有节能算法常采取降频的方法来减少动态功耗,采用关闭处理器的方法来进一步减少静态功耗,虽然这种方法可以实现节能,但是不能保证最小化能耗.(3)现有最优的节能实时调度算法假设没有处理器状态切换的时间和能耗开销,因此在切换开销不可忽视的实际平台中不一定最优.本文针对具有独立DVFS的多处理器系统,在考虑处理器状态切换开销情况下,提出一种基于帧任务模型的最优节能实时调度算法(LargestUtili-zationtaskFirstbasedonSwitchingOverhead,LUF-SO).该算法在调度过程中允许实时任务在任意处理器之间迁移,可以在离线调度中确定所有任务的执行过程和执行速度.同时,LUF-SO算法与LTF-M算法的主要区别在于:LUF-SO算法将根据关键速度来判断系统的低负载情况,一旦确定系统处于低负载情况,首先确定具有最低能耗值的活跃处理器个数,然后根据状态切换时间和能量开销来确定最优调度序列;而LTF-M算法在系统处于低负载情况不再保持最优性.LUF-SO算法实现简单且复杂度小.系统的理论分析证明了该算法的最优性.本文第2节介绍系统模型,并给出问题定义;第3节结合实际切换开销,对现有算法LTF-M的非最优性进行分析;LTF-SO算法的详细描述以及最优性分析和证明在第4节中给出;第5节示例说明算法的最优节能效果,并与LTF-M算法进行比较;第6节对全文作简要总结.2系统模型与问题定义本节提出本文所用的处理器模型、任务模型以及能耗模型,并基于模型给出问题定义.2.1处理器模型假设多处理器系统由m个同构处理器构成,m为常数,处理器命名为cpu1,cpu2,…,cpum.处理器cpuk以速度s运行时的功耗Pk(s)为Pk(s)=Pdepk(s)+Pind关和与速度无关的功耗[11].Pdepk(s)主要由门电路电容充放电引起的动态功耗和短路瞬态电流产生的短路功耗构成.根据文献[11-13]可知,与速度相关的功耗Pdepk(s)可表示为Pdepk(s)=αs3.与速度无关的功耗Pindk=β[20],其中β是一个常量.因此,功耗函数可为Pind表示为这种功耗模型适用于多种DVFS处理器,例如IntelXscale处理器[11].显然,P(s)是严格凸函数和递增函数.假设同构多处理器可以在最低处理器速度smin和最高处理器速度smax之间连续调节.处理器以速度s执行一个时钟周期的能耗为P(s)/s=α·s2+β/s.P(s)/s是凸函数[13],且使得P(s)/s具有最小值的速度即是关键速度s.这里关键速度定义为处理器执行一个时钟周期所用能耗最小时的速度[1,9-10].例如,当Pdepk(s)=αsγ+λs时,关键速度s等于maxminγPind显然,s满足如下性质[10-11]:处理器有两种状态:睡眠状态和活跃状态.当处理器处于睡眠状态时,DPM技术可以关闭处理器时钟,将处理器电压降低到非常低的水平,以至于处理器功耗可以忽略不计,近似为0[10,13].执行任务的处理器则处于活跃状态.由于睡眠状态中处理器上下文等信息不被保存,所以返回活跃状态需要一定的时间和能量开销①.本文将Esw和tsw分别定义为处理器在睡眠状态和活跃状态之间的切换能量和时间开销.当处理器在活跃状态中空闲时,最小能耗处理器将以极低速度执行空操作指令.设空闲时功耗为Pidle,且不小于处理器在最低速度时的功耗P(smin),即PidleP(smin).而break-even时间(即tθ)是基于空闲时功耗所计算的最小空闲周期.当处理器的空闲时间大于break-even时间时,将处理器转入睡眠状态①AdvancedConfigurationandPowerInterface,2011.http:Page4是节能的.break-even时间长度依赖于空闲时功耗和切换开销,所以不妨设tθ=Esw/Pidle时间开销tsw不大于tθ2.2任务模型本文考虑流媒体应用中常见的基于帧任务集T={τ1,τ2,…,τn}.所有基于帧的实时任务具有相同的到达时间(又称释放时间)和周期,帧大小为周期D.每个周期任务具有无穷序列的任务实例,又称为作业.任务τj的每个作业都按照相同周期到达(或称释放到)就绪队列.τj的截止期等于周期,其在最高处理器速度smax下的最坏情况执行时钟数或执行时间Cj是预先已知的.τj的利用率为uj=Cj/D,任务集的总利用率为U=∑τj∈T考虑CjD这种情况,在该情况下任务τj可以以速度smax在任务截止期D之前完成.假设在时间间隔中执行的CPU时钟数与处理器速度成线性正比关系.任务τj在t时间单元内以速度s运行所需要的CPU时钟数可以近似表示为s和t的乘积.2.3能耗模型当处理器在活跃状态与睡眠状态之间的切换能耗开销Esw不为0时,将任务集T中所有任务分配到m个处理器上的最优节能实时调度一定满足下列两个性质.引理1.第k个处理器上所分配的任务集Tk中每个任务τi都具有相同的处理器速度.证明.如果定义处理器速度分配列表σ为处理器速度sj和对应的执行时间长度tj所构成数对(sj,tj)的有序集合,那么根据功耗函数P(s)是凸函数性质可得如下不等式[4]:∑(sj,tj)∈σ命题得证.引理2.第k个处理器上所分配的任务集Tk具有最低能耗的节能实时调度一定满足:当U=CiD且Us时,以U为速度值来执行Tk中所有∑τi∈Tk任务;当U<s时,最优执行速度值只能从关键速度s或U中选择.证明.当U=∑τi∈Tk数的凸函数性质直接可知U是最优执行速度值.当U<s时,不妨假设以U为速度值来执行任务集Tk中所有任务时的能耗为E(U)=P(U)·D,而处理器以s为速度值执行时的空闲时间为tidle=D-UD/s.下面采用反证法,根据引理1假设此时任务集Tk中最优节能调度的执行速度值为s,且满足s≠s,s≠U.(1)如果s<U,则所有任务的执行时间为UD/s>D,显然此时不是最优节能实时调度.(2)如果s>s,则所有任务的执行时间为UDUDs<D,存在空闲时间tidle=D-UDtθ时,以s为速度的处理器能耗为E(s)=P(s)·UDPidle·tidle,而以s为速度来执行时的能耗为E(s)=P(s)·UD围中属于单调递增函数,所以P(s)·UDUDs,进而E(s)>E(s).当tidle>tθ时,以s为速度的处理器能耗为E(s)=P(s)·UDtidletθ,则以s为速度来执行时的能耗为E(s)=P(s)·UDtidle<tidle,则能耗E(s)=P(s)·UD根据P(s)/s函数在s>s范围中属于单调递增函数,可得E(s)>E(s).(3)如果U<s<s,则所有任务的执行时间为s<(s<UDUDUDstidle<tidle.当tidle>tθ时,tidle>tθ,以s为速度的处理器能耗为E(s)=P(s)·UD/s+Esw,而以s为速度执行时的能耗为E(s)=P(s)·UD/s+Esw.因为P(s)/s函数在s<s范围中属于单调递减函数,所以E(s)>E(s).当tidletθ时,以s为速度的处理器能耗为E(s)=P(s)·UD/s+Pidle·(D-UD/s).因为PidleP(smin)P(0),且功耗函数P(s)属于凸函数性质,所以E(s)P(s)·UD/s+P(0)·(D-UD/s)>P(s·U/s+0·(1-U/s))·D=E(U).综上可知,与假设相矛盾.命题得证.证毕.由引理2易得下面推论.推论1.当U=∑τi∈TkPage5理器以关键速度执行完成任务集Tk中所有任务,且空闲时执行空操作,此时能耗值一定不小于以U值为执行速度且没有空闲时间时的能耗值.证明.如果U=∑τi∈Tk以关键速度执行,而空闲时执行空操作,即不会将处理器转入睡眠状态.此时能耗为P(s)·UD/s+Pidle·(D-UD/s).而处理器以U值为执行速度且没有空闲时间时的能耗值为P(U)D.因为P(s)是凸函数,且PidleP(0),所以U/s·P(s)+(1-U/s)·PidleU/s·P(s)+(1-U/s)·P(0)P(U/s·s+(1-U/s)·0)=P(U),则(P(s)-Pidle)·UD/s+Pidle·DP(U)·D.证毕.不妨令(Tk)为第k个处理器上在公共截止期D内完成Tk中所有任务的最小能耗.因为切换开销Esw不为0,所以如果某个处理器为空闲时,最优调度不一定会将处理器转入睡眠状态.根据引理2,如果∑τi∈Tk续分情况进行判断,如果处理器在截止期D之前完全运行时的能耗小于以关键速度运行时的能耗,那么(Tk)=P∑τi∈Tk运行时的能耗小于完全运行时的能耗,那么根据推论1可知,处理器必然会转入睡眠状态,(Tk)=P(s)·∑τi∈Tk时,第k个处理器在公共截止期D内完成Tk中所有任务的能耗为Ek(U),即Ek(U)←CiDs,那么(Tk)=P∑τi∈Tk图1给出Ek(U)函数的示例.显然该函数为分段函数,不属于凸函数,但是其仍部分满足凸函数性质,所以针对该函数的分析需要分情况考虑.2.4问题定义任务集的节能实时调度是指集合中所有任务的执行映射到系统中的处理器上,并且为任务的对应时间间隔分配处理器速度.如果在时间间隔内分配的所有处理器速度都是有效的,且没有任务丢失截止期D,那么这样一个节能实时调度是可行的.一次调度Sch的能耗表示为∑m中能耗的定义).如果一个调度是可行的,且能耗是所有可行的调度中最小能耗,那么它就是最优节能实时调度.本文所考虑的问题定义如下:给定基于帧的实时任务集T,可以在m个同构多处理器上运行.每个处理器具有相同的功耗函数P(s)=α·s3+β,α0,β0.假设每个处理器的执行速度可以在smin=0和smax之间连续调节.所有任务具有相同的释放时间和截止期D.假设实时任务集T是可调度的,每个任务τj的最坏情况执行时间Cj都不超过其截止期D,任务τj的实际执行按照最坏情况执行.处理器在睡眠状态和活跃状态之间的切换能量开销为Esw,时间开销为tswEsw/Pidle.本文的目标是在允许任务迁移条件下,将T中所有任务分配到m个处理器上执行,得到最优的节能实时调度序列.由于按照最坏情况执行的每个任务在运行时不会改变其速度,所以处理器在活跃状态时没有速度切换开销.又因为任务迁移的次数不会超过处理器个数,所以开销敏感的多处理器最优节能实时调度问题的迁移代价可以忽略不计.3LTF-M最优算法的非最优性限制本节以IntelXscale处理器的功耗函数为例,对最优节能实时调度算法LTF-M进行实际分析.这里功耗函数被近似建模为P(s)=1.52·s3+0.08W[10-12].不妨假设smin为0,smax为1GHz.根据2.1节可知,以smax为标准进行归一化,关键速度s约为0.297GHz,在关键速度s上的功耗P(s)=0.12W.假设切换开销Esw为0.8mJ,处理器的空闲功耗为0.08W,则break-even时间tθ为10ms.已知基于帧的实时任务集T={τ1,τ2,τ3,τ4}在双处理器系统中执行,所有任务具有相同周期D=30ms.每个任务在最高速度smax下的最坏情况执行时钟数分别为C1=0.012s,C2=0.012s,C3=0.006s,C4=Page60.006s.如果以关键速度s来执行这些任务,每个任务的执行时间分别为12ms,12ms,6ms,6ms.当不考虑泄漏功耗所引起的静态能耗时,Chen等人[4-5]已经证明LTF-M算法针对同构多处理器系统,在保证基于帧实时任务集可调度性的条件下产生最低的能耗值.当静态能耗不可忽视时,为了平衡动态能耗和静态能耗,如果将关键速度看作任务执行的最低速度,LTF-M算法可以直接扩展为LTF-M-CRITICAL算法.但是,当考虑处理器的状态切换开销时,LTF-M算法及其LTF-M-CRITI-CAL扩展算法不再具有最优性.以任务集T为例,图2给出了示例说明.这里,x轴表示时间,y轴表示处理器执行速度,每个任务框的面积定义为执行该任务所占用的CPU时钟数.图2(a)表示任务集T在LRE-TL算法下的调度序列,可以保证T中所有任务在截止期D之前的可调度性.已知每个任务在周期D=30ms中的利用率分别为u1=0.4s,u2=0.4s,u3=0.2s,u4=0.2s,平均利用率为u-=∑τi∈T任务的利用率均小于平均利用率,所以LTF-M算法为每个任务分配执行速度u-GHz.同时为保证所有任务的可调度性,指定任务τ2从20ms到30ms时间段内在第1个处理器上执行,从0ms到10ms时间段内在第2个处理器上执行.LTF-M算法能够使得所有处理器以完全利用整个时间段(0,30]ms的速度u-GHz执行任务,没有空闲时间存在,此时处理器总能耗El2=(0.04·0.63+0.08)·60=5.3184mJ.LTF-M算法为每个任务分配的执行速度u-均小于关键速度,因此LTF-M-CRITICAL算法将以关键速度s来执行所有任务,总的执行时间为∑τi∈TCi/s=36ms.图2(b)显示了LTF-M-CRITI-CAL算法的调度序列.从图2(b)中可知,第2个处理器将从6ms开始进入睡眠状态,直到30ms时刻.由于睡眠时间超过break-even时间,切换能耗开销小于空闲能耗,所以第2个处理器在时间段(6,30]ms内的能耗为Esw.此时处理器总能耗E2=0.12·36+0.8=5.12mJ.由以上分析可知,在考虑静态能耗条件下,LRE-TL算法不再保证其最优性,而其扩展算法LTF-M-CRITICAL有可能进一步降低能耗.在关键速度上执行可能会比在更低的速度级别上执行更节能的主要原因在于,它乐观地假设在任务执行之后将处理器转入睡眠状态.同时这两种算法均假设系统负载在所有处理器上均衡分布具有最优性.但是如果离线关闭某些处理器以减少活跃处理器的个数,可能会极大减少能耗.例如,假设只有一个处理器处于活跃状态,而另一个处理器处于关闭状态,则可以得到一个最优节能实时调度序列,即所有任务以∑τi∈TCi/D=1.2sGHz速度在一个处理器上执行,没有空闲时间,如图2(c)所示.此时能耗E1=(0.04·1.23+0.08)·30=4.4736mJ.综上可述,LTF-M算法及其扩展算法在考虑开销的实际环境中不是最优的,主要原因是在开销敏感的低负载情况下,基于关键速度以及负载均衡的节能调度不具有最优性[10].Page74LUF-SO算法由于开销问题越来越不容忽视,基于对LTF-M最优算法的非最优性分析,本文得到在实际环境中最优算法应该具备的三个条件:(1)系统的负载情况的确定;(2)具有最低能耗值的活跃处理器个数;(3)开销敏感的处理器状态切换.本文将基于以上分析,针对基于帧的实时任务模型,提出考虑实际切换开销情况下的多处理器最优节能实时调度算法LUF-SO,如算法1所示.算法1.LUF-SO算法.输入:T,D,m,s输出:具有最低能耗值的最优调度序列1.按照任务利用率ui的非递增顺序排列所有任务2.U←∑τi∈T3.IFU>morτi∈Tsuchthatui>1THEN4.return不存在可行的调度;5.i←1andM←m;6.WHILEi|T|DO7.IFui<sandU/M<sTHEN8.m←U/s;9.BREAK;10.ELSEIFui>U/MTHEN11.τi.speed←ui;12.U←U-ui,i←i+1,andM←M-1;13.ELSE14.τi.speed←U/Mandi←i+1;15.IFm0THEN16.m←Check_Switching_Overhead(T,U,D,i,m,s);17.IFM>mTHEN18.M←m-(M-m);19.ELSE20.M←m;21.i←1andt←0;22.WHILEi|T|DO23.IFτi.speed=uiTHEN24.调度任务τi以ui·smax为速度值在0到D时间间25.M←M-1;26.ELSEift+ui·D27.调度任务τi以τi.speed·smax为速度值在t到D28.M←M-1;29.ELSE30.调度任务τi以τi.speed·smax为速度值在t到31.i←i+1andt←t+ui·D32.return所有任务的调度序列.4.1基本思想本文提出的算法LUF-SO采用最大任务利用率优先策略,离线确定任务的调度过程和执行速度.最大任务利用率优先策略是指所有任务按照利用率的非递增顺序来排列.以任务集T为例,令U=∑τi∈Tui.LUF-SO算法的基本思想如下:(1)当uis时,如果uiU/M,那么LUF-SO算法将剩余未分配的任务τj∈T\{τ1,…,τi}统一分配平均速度τj.speed=U/M(第13行到第14行);否则,LUF-SO算法将为任务τi分配速度τi.speed=ui(第10行到第12行),且将可用处理器的个数减1.(2)当ui<s时,如果U/Ms,则易知ui<U/M,故LUF-SO算法将为剩余未分配速度的任务统一分配平均速度U/M(第13行到第14行);否则,这反映剩余未分配速度的任务的执行速度可能会小于关键速度,需要计算最优调度可能具有的处理器数m=U/s(第7行到第9行).同时调用Check_Switching_Overhead算法(第15行到第16行),不仅可以获得在考虑切换开销情况下最优的处理器数m,而且将为所有剩余未分配速度的任务指定了对应的执行速度.如果调用之后得到的m小于可用的处理器个数M,则说明某些处理器可以被直接关闭,从而减少可用处理器个数(第17行到第18行),否则所有处理器全部打开,可用处理器个数M等于处理器个数m(第19行到第20行).(3)由于任务集T中所有任务都已分配了相关的执行速度,所以下面可以直接按照任务利用率非递增顺序将所有任务指派到对应的处理器上调度执行:如果某个任务τi的速度τi.speed等于其利用率ui,那么该任务将单独在一个处理器上从0到D时间间隔内调度执行,同时可用处理器个数减1(第23行到第25行);否则,因为ui<τi.speed,所以t+ui·Dτi.speed-D<t.如果任务τi被调度执行在两个处理器上(第26行到第28行),τi将以速度τi.speed·smax在t到D时间间隔内执行在第M个处理器上,在0Page8到t+ui·Dτi.speed-D时间间隔内执行在第M-1个处理器上;此外,如果任务τi被调度执行在一个处理器上(第29行到第30行),τi将以速度τi.speed·smax,从t到t+ui·D器上.为得到具有最低能耗值的解,Check_Switching_Overhead算法针对所有未分配速度的后续任务子集T=T\{τ1,…,τi}只分析下列3种情况,如算法2所示.算法2.Check_Switching_Overhead.输入:T,U,D,i,m,s输出:能够满足所有未分配速度任务T=T\{τ1,…,τi}1.M←m+1,U←U,j←i,El2.WHILEj|T|DO3.IFuj>U/MTHEN4.τj.speed←ujandEl5.U←U-uj,j←j+1,andM←M-1;6.ELSE7.τj.speed←U/Mandj←j+1;8.El9.tidle←(m+1)·D-U·D/s;10.IFtidle>tθTHEN11.E12.ELSE13.E14.IFm≠0THEN15.El16.Emin←min{El17.IFEmin=El18.j∈[i,|T|],τj.speed←U/m;19.IFEmin=E20.j∈[i,|T|],τj.speed←s,andm←m+1;21.IFEmin=El22.m←m+1;23.return处理器个数m;情况1.T中所有任务在m+1个处理器上以完全利用整个周期时间的速度运行,没有空闲时间存在.Check_Switching_Overhead算法采取与LTF算法相同的方法分配所有任务的执行速度(第2行到第7行).此时能耗值为El情况2.T中所有任务在m+1个处理器上以关键速度s运行,存在空闲时间tidle=(m+1)·D-U·D/s(第9行).Check_Switching_Overhead算法根据tidle与tθ大小关系判断是否进入睡眠状态,从而得到对应情况下不同的能耗值E第13行).情况3.T中所有任务在m个处理器上以完全利用整个周期时间的速度运行,没有空闲时间存在.如果m≠0,那么Check_Switching_Overhead算法可以得到在m个处理器上最低的能耗值El(第14行到第15行).基于上述3种情况的能耗值,Check_Switching_Overhead算法确定最低能耗值min{Elm+1,ElE度,得到最优处理器数m(第16行到23行).4.2复杂度分析设任务集T中任务总数为n,处理器数为m,每个任务状态数量为w,每个处理器状态数量为v.时间复杂度:在算法2的第2步和第7步之间的循环以及算法2的第18步和第20步中,为TT中所有未分配速度的任务指定执行速度的时间复杂度均为O(n).由于算法2中计算各种情况下能耗值和最优处理器个数的时间复杂度均为常量,所以算法2的时间复杂度为O(n).算法1中第1步针对任务集T的排序操作需要时间复杂度为O(n·logn).从算法1的第2步到第5步,每步计算的时间复杂度为常量,记作O(1).而在算法1的第6步和第14步之间的循环中,为每个任务分配执行速度的时间复杂度为O(n).算法1中第15步到18步调用算法2的计算步骤的时间复杂度为O(n).此外,在算法1的第20步和第29步之间的循环中,将所有任务分配到指定的处理器上调度执行的时间复杂度为O(n).综上,算法1的时间复杂度为O(n·logn)+O(n)=O(n·logn).空间复杂度:如果采用顺序表存储,任务集T所占用的空间为O(n·w),处理器状态所占用的空间为O(m·v).4.3最优性分析当uis或者U/Ms时,根据功耗函数的凸函数性质以及LTF-M算法的证明过程,显然可知LUF-SO算法得到的节能调度是最优的.因此,为了证明LUF-SO算法在ui<s且U/M<s的情况下也具有最优性,下面来证明算法1的Check_Switc-hing_Overhead可分析得到的3种情况,其能耗值也Page9是最低的.接下来,本文将根据活跃处理器个数的不同,分情况说明最优节能调度只能在m或m+1个处理器上产生.4.3.1m个处理器(m>0)对于TT中所有任务在m=∑τi∈T理器上执行时,因为T中所有任务的利用率ui<s,又因为U=∑τi∈TU/m>ui.为了满足T中所有任务的截止期,可以选择按照U/m为速度来执行,此时任务在m个处理器上运行没有产生空闲时间,能耗为引理3.TT中所有任务按照任务利用率的非递增顺序排列,所有任务具有相同的截止期D,如果令U=∑τi∈T∑τi∈Tuis到的能耗El证明.针对多处理器,由于具有最低能耗的速度分配方法必然保证单个处理器在运行时只有唯一的执行速度[4],所以不妨假设m个处理器{P1,P2,…,Pm}具有的执行速度列表为{s1,s2,…,sm},而每个处理器对应的运行时间列表为{t1,t2,…,tm}.其中sj∈{s1,s2,…,sm},0sjsmax.因为∑mm·D,所以空闲时间tidle=m·D-∑mPidle·tθ.如果tidle>tθ,那么可以将处理器从活跃状态转入睡眠状态;否则,处理器仍处于空闲状态.能耗Em表示如下:Em←因为∑m凸函数性质以及不等式(1)可知,∑m(P(sj)·tj)P∑mj=1j=1t(PU·D∑m因为∑mms,所以UD∑m为U的凸函数性质可知,当ss时,P(s)/s是s的严格单调递增函数.当∑mtj可以取最小值PU∑m∑m(sj·tj)=U·D,∑mj=1D.显然,可得Em>El因为以U/m为速度在m个处理器上运行没有产生空闲时间,所以如果所有处理器以低于U/m的速度执行时,必然会导致某个任务丢失截止期.因此U/m是所有m个处理器完全执行时唯一速度.定理1.TT中所有任务按照任务利用率的非递增顺序排列,所有任务具有相同的截止期D,不妨令m=∑τi∈Tm-1.如果T中所有任务在m-λ个处理器上可调度执行,那么在m-λ个处理器上执行所得到的最低能耗min{Em-λ}均不小于在m个处理器均以U/m为速度来执行所得到的能耗El证明.由题设可知U/sm,则U/ms.因为1λm-1,所以U/(m-λ)>U/ms.(1)如果m-U<λm-1,则1m-λ<U,进而U>m-λ,此时任务负载大于处理器处理能力,不存在满足可调度性的任务调度.(2)如果λ∈Z+,1λm-U,则根据引理3可知T中所有任务在m-λ个处理器均以U/(m-λ)为速度在截止期D之前执行,没有空闲时间,此时所得到的能耗是最低的,即Em-λ=m-λ←PUElP(U/(m-λ))·U·DU/(m-λ).而El又根据P(s)/s的凸函数性质可知,当ss时,Page10P(s)/s是执行速度s的严格单调递增函数.因此,Elm-λEl4.3.2m+1个处理器(m0)假设TT中所有任务根据LTF-M算法为m+1个处理器所分配的执行速度为{sl1,sl2,…,m+1},由于此时所有m+1个处理器以完全利用sl整个周期D时间的速度运行,不存在空闲时间,所以能耗为假设{s,s,…,s}为TT中所有任务按照关键速度s调度执行时m+1个处理器的执行速度,存在空闲时间为tidle←(m+1)·D-U·D/s,且Esw=Pidle·tθ.如果tidle>tθ,那么可以将处理器从活跃状态转入睡眠状态;否则处理器仍处于空闲状态.因为T中所有任务的利用率ui<s且U/sm,所以可以将m+1个处理器上可能出现的空闲时间集中到一个处理器上,使得状态转换次数减少到最少,只有一次.因此能耗形式化如下:m+1←P(s)·U·D/s+Pidle·tθ,tidle>tθE考虑一般情况,针对m+1个处理器,由于具有最低能耗的速度分配方法必然保证单个处理器的执行速度是唯一的,所以不妨假设m+1个处理器{P1,P2,…,Pm+1}具有的执行速度列表为{s1,s2,…,sm+1},而每个处理器对应的运行时间列表为{t1,t2,…,tm+1}.其中sj∈{s1,s2,…,sm+1},0sjsmax,{s1,s2,…,sm+1}≠{sl1,sl2,…,sl{s1,s2,…,sm+1}≠{s,s,…,s},存在空闲时间为tidle←(m+1)·D-∑m+1tidle>tθ,那么可以将处理器从活跃状态转入睡眠状态;否则处理器仍处于空闲状态.能耗形式化如下:Em+1←接下来,本节需要证明当TT中所有任务在m+1个处理器上执行时,在满足所有任务截止期条件下,最低能耗值为min{El得到El在,而得到E时间.m+1的方法会使得处理器上没有空闲时间存引理4.TT中所有任务按照任务利用率的非递增顺序排列,所有任务具有相同的截止期D,假设在m+1个处理器上执行时具有的执行速度列表为{s1,s2,…,sm+1},对应的运行时间列表为{t1,t2,…,tm+1}.如果任意第j个处理器的速度s<sjsmax,或者对于任意第j个处理器的速度0<sj<sl所有任务的能耗不可能是在保证可调度性条件下的最低能耗.证明.(1)假设任意处理器执行速度列表{s1,s2,…,sm+1}中第j个处理器的速度s<sjsmax.如果在不改变第j个处理器上任务负载Cj(即任务执行时钟数)的条件下,将sj的速度降低为s,而保持其它剩余处理器的执行速度不变,则新的所有执行速度列表为{s1,s2,…,sj-1,s,sj+1,…,sm+1}.显然,由于改变前后能耗的唯一不同在于第j个处理器上的能耗,所以下面仅仅比较第j个处理器执行速度改变前后的能耗值.Ej←P(sj)·tj+Pidle·(D-tj)=P(sj)/sj·Cj+Pidle·(D-tj);执行速度为s的能耗值为EPidle·(D-tsj>s,所以tj<tD,所以D-tj>D-t变后处理器的空闲时间大于break-even时间,可以由活跃状态进入睡眠状态,那么执行速度改变前也一定可以由活跃状态进入睡眠状态.又根据功耗函数P(s)的凸函数性质以及P(s)/s在ss时属于递增函数性质,可知P(sj)/sj>P(s)/s,进而可得j.因此可知对于存在处理器执行速度大于sEj>E的任意处理器执行速度列表,总可以将其转换为能耗值更低且处理器执行速度不超过s的另一个处理器执行速度列表.(2)假设任意处理器执行速度列表{s1,s2,…,sm+1}中任意第j个处理器的速度0<sj<sltjD.已知sj·tj=Cj=s·t因为{sl1,sl2,…,sl器以完全利用整个周期时间的速度运行,没有空闲时间存在,所以∑m+1U,所以∑m+1处理器按照{s1,s2,…,sm+1}的执行速度不能完成Page11T中所有任务的负载,必然存在某些任务丢失截止期.定理2.TT中所有任务按照任务利用率的非递增顺序排列,所有任务具有相同的截止期D,假设在m+1个处理器上执行时具有的执行速度列表为{s1,s2,…,sm+1},对应的运行时间列表为{t1,t2,…,tm+1}.那么在满足T中所有任务截止期的条件下,所有任务在m+1个处理器上执行的最小能耗值为min{El证明.由引理4可知在分析具有最小能耗值的节能调度时,可以排除某个处理器执行速度大于s的情况以及全部处理器执行速度均小于sl况.因此,这里仅仅考虑sj∈{s1,s2,…,sm+1},sjs,{s1,s2,…,sm+1}≠{sl1,sl2,…,sl{s1,s2,…,sm+1}≠{s,s,…,s}.下面根据tidle与tθ的大小关系分两种情况讨论:(1)如果所有m+1个处理器以关键速度s调度执行时出现的空闲时间tidletθ,则处理器不会由活跃状态转入睡眠状态.(p(slm+1←(P(s)-Pidle)·U·D当处理器执行速度列表为{sl1,sl2,…,sl处理器没有空闲时间时,根据式(3)可知El∑m+1j=1m+1处理器的执行速度均为s时,因为tidle=(m+1)·D-U·D/stθ,根据式(4)可知EP(s)·U·D于ED.当处理器执行速度列表为{s1,s2,…,sm+1}时,sj∈{s1,s2,…,sm+1},{s1,s2,…,sm+1}≠{s,s,…,s}且sjs.因为∑m+1∑m+1(sj·tj)=U·D<∑m+1知tidle=(m+1)·D-∑m+1s=tidle.因此,由式(5)可得Em+1←∑m+1Pidle·(m+1)·D-∑m+1∑m+1((P(sj)-Pidle)·tj)+Pidle·(m+1)·D.功耗函数P(s)是凸函数和严格单调递增函数,j=1j=1而Pidle是常量,因此P(s)-Pidle仍然属于凸函数和严格单调递增函数.令G(s)=P(s)-Pidle.根据本文的处理器模型可知,P(s)=Pdep(s)+Pind,而Pidle为处理器中没有指令执行且时钟关闭时的功耗,且PidlePind.此时G(s)=P(s)-Pidle=Pdep(s)+Pind-Pidle.因为∑m+1数性质以及式(1)可知,j=1由于tj∈{t1,t2,…,tm+1},0tjD,则∑m+1tj∑m+11).又因为Us]max.不妨假设f(s)=G(s)则一阶导数f(s)=(Pdep(s))·s+(Pidle-Pind)时,当Pidle=Pind时,f(0)=0;当Pidle>Pind时,f(s)>0.由此可知,f(s)是速度s的严格单调递增函数.当UD∑m+1取最小值,同时tj∈{t1,t2,…,tm+1},tj=D.再由引理2可知,{sl1,sl2,…,sl处理器以完全利用整个周期时间的速度运行,没有空闲时间存在的唯一有效执行速度列表,所以式(6)左侧∑m+1min{Elj=1显然,可得Em+1>El(2)如果所有m+1个处理器以关键速度s调度执行时出现的空闲时间tidle>tθ,则可能存在某些处理器由活跃状态转入睡眠状态.当处理器执行速度列表为{sl1,sl2,…,sl处理器没有空闲时间时,根据式(3)可知ElPage12j=1j)·D.当所有m+1处理器的执行速度均为∑m+1p(sls时,因为tidle=(m+1)·D-U·D式(4)可知E器执行速度列表为{s1,s2,…,sm+1}时,因为{s1,s2,…,sm+1}≠{s,s,…,s}且∑m+1D,所以∑m+1∑m+1tj,可知tidle=(m+1)·D-∑m+1D-U·Ds=tidle.因此,由式(5)可得j=1Em+1←下面根据tidle与tθ的关系,分两种情况来讨论:(2.1)tidle>tθ.此时Em+1←∑m+1tidle<tidle,所以E又因为∑m+1∑m+1j=1的凸函数性质以及式(1)可知,j=1由于tj∈{t1,t2,…,tm+1},0tjD,则∑m+1tj∑m+1又因为U根据P(s)minP(s){}s.当∑m+1m+1<s,所以UD∑m+1s的凸函数性质可知,当s=s时,P(s)∑m+1tj可以取最小值UD·P(s)/s.因为sj∈{s1,j=1s2,…,sm+1},0sjs以及{s1,s2,…,sm+1}≠{s,s,…,s},所以∑m+1min{El显然,可得Em+1>Ej=1(2.2)tidletθ.此时tidle=(m+1)·D-∑m+1(P(sj)·tj)+Pidle·(m+1)·D-∑m+1∑m+1Em+1←∑m+1tidle<tidle,所以E(P(s)-Pidle)·UD/s+Pidle(m+1)D.而El∑m+1p(slj=1D+Pidle·(m+1)·D.由于tidle=(m+1)·D-U·D/s,tidle>tθ,同理,采用与(1)中类似的证明过程可得Em+1>Elm+1}.E综上命题得证.定理3.TT中所有任务按照任务利用率的非递增顺序排列,所有任务具有相同的截止期D.不妨令m=∑τi∈Tm>m,λ∈Z+,1<λm-m.如果T中所有任务在m+λ个处理器上可调度执行,那么在m+λ个处理器上执行所得到的最小能耗均不小于在m+1个处理器所得到的最小能耗min{El证明.由题设可知U/s<m+1,则Us.因为1λm-m,所以U对于λ∈Z+,1<λm-m,根据定理2可知,T中所有任务在m+λ个处理器上可调度执行所得的最小能耗为min{El(1)如果min{Elλ个处理器以完全利用整个周期时间的速度执行,没有空闲时间时的执行速度列表为{sl1,λ,sl2,λ,…,m+1,λ}.根据式(3)可知ElslPage13j=1sj,λ=U,根据功耗函数P(s)的凸函数性质以为∑m+λ及式(1)可知,∑m+λ(m+λ)=P(U/(m+λ))函数性质可知,当s<s时,P(s)/s是s的严格单调递减函数,可得P(U/(m+λ))因为El(m+1)D=Elm+1min{ElEl(2)如果min{El所有任务的执行速度均为s,m+λ个处理器上存在空闲时间.因为1<λm-m,所以tidle,λ=(m+λ)·D-UD可知,如果tidle,λtθ,则tidle,1<tθ,EPidletidle,λ,Em+1.如果tidle,λ>tθ,则EEPidle·tθ.因为tidle,1<tidle,λ,如果tidle,1<tθ,则Em+1;如果tidle,1tθ,则EEEm+λEmin{Elm+1,E综上可得min{El证明.由引理3可知,Check_Switching_m+1}.E定理4.Check_Switching_Overhead算法可以得到具有最低能耗值的最优处理器数,同时LUF-SO算法可以得到最优的节能调度.Overhead算法确定的能耗值Em是m=∑τi∈T个处理器上能耗最低值;由定理2可知,Check_Switching_Overhead算法确定的能耗值min{Elm+1}是m+1个处理器上能耗最低值;再根据定E理1和定理3可知,Check_Switching_Overhead算法确定的能耗值Emin←min{El所有m>m个处理器上的最低能耗值,由此得到具有最低能耗值Emin的处理器数即是最优的.已知T中所有任务按照任务利用率的非递增顺序排列,当单个任务的利用率uis时,或者当剩余未分配速度的任务集TT中在M个处理器上的平均利用率U配速度的任务的处理过程与LTF-M算法相同.因此,直接根据功耗函数P(s)的凸函数性质以及LTF-M算法的最优性证明过程,可知此时LUF-SO算法在ss得到的节能实时调度是最优的.当ui<s且U/M<s时,LUF-SO算法调用Check_Switc-hing_Overhead算法可以获得最低的能耗值,同时保证TT中所有任务的可调度性.综上,LUF-SO算法可以得到最优的节能调度.5示例本节通过举例说明LUF-SO算法的最优性.以IntelXscale处理器的功耗函数为例,每个处理器的功耗函数可以被近似建模为P(s)=1.52·s3+0.08W[10-12].假设处理器速度以smax为标准归一化为[0,1]GHz(smin为0GHz,smax为1GHz)之间任意值.根据2.1节可知,关键速度s约为0.297GHz,在关键速度s上的功耗P(s)=0.12W.假设切换开销Esw为0.8mJ,处理器的空闲功耗Pidle=0.08W,则break-even时间tθ为10ms.给定一个基于帧的实时任务集T={τ1,τ2,τ3,τ4,τ5,τ6}在多处理器系统中调度执行,处理器个数m=4,所有任务具有相同周期D=30ms.不妨假设所有任务已经按照利用率的非递增顺序排列,每个任务的最坏情况执行时钟数和利用率如表1所示.任务集根据LUF-SO算法可知,首先需要为利用率最大的任务τ1分配执行速度τ1.speed.此时由于U=∑τi∈Tui=3s,M=m,所以U/M=0.75s<s.而u1=1.2s>s,且u1>U/M,因此τ1.speed=u1,U=U-u1=1.8s,M=m-1=3.然后为后续任务τ2分配执行速度,此时U/M=0.6s<s且u2=0.6s<s,由LUF-SO算法可得m=U/s=1,从而调用Check_Switching_Overhead算法.针对所Page14有未分配速度的后续任务子集T={τ2,τ3,τ4,τ5,τ6},Check_Switching_Overhead算法获得具有最低能耗值的最优处理器数m以及后续任务子集中所有任务相应的执行速度.根据定理4可知,Check_Switching_Overhead算法中具有最低能耗值的解只需要分析下列3种情况:情况1.TT中所有任务在m+1个处理器上以完全利用整个周期时间的速度运行,没有空闲时间存在.由于u2<U/(m+1)=0.9s,所以τj∈T,任务τj的执行速度为τj.speed=0.9sGHz.因为此时Check_Switching_Overhead算法采取与LTF算法的相同方法分配所有任务的执行速度,所以对应的调度序列如图3(a)所示.根据式(3)可知能耗值El0.08)·60=6.5496mJ.情况2.TT中所有任务在m+1个处理器上以关键速度s运行,存在空闲时间tidle=(m+1)·D-U·D/s.此时Check_Switching_Overhead算法分配TT中所有任务的执行速度为sGHz,对应的调度序列如图3(b)所示.由于tidle=2×30-1.8×30=6ms,tθ=10ms,所以tidle<tθ.根据式(4)可知能耗值E2=P(s)UD/s+Pidletidle=0.12·1.8·30+0.08·6=6.96mJ.情况3.TT中所有任务在m个处理器上以完全利用整个周期时间的速度运行,没有空闲时间存在.因为m≠0,所以根据引理3可知为得到在m个处理器上最低的能耗值,Check_Switching_Overhead算法分配TT中所有任务的执行速度为U/m=1.8sGHz,对应的调度序列如图3(c)所示.根据式(2)可知能耗值El1=P(1.8s)·m·D=(0.04·1.83+0.08)·30=9.3984mJ.当得到以上3种情况的能耗值后,Check_Switching_Overhead算法确定的最低能耗值min{El2,E2,El1}=El2,最后返回最优处理器数m=2.当分配完T中所有任务的执行速度之后,LUF-SO算法将所有任务指定到相应的M=3个处理器上调度执行,如图4(a)所示.而如果采用LTF-M算法调度相同任务集T,则LTF-M算法会将T中所有任务指定到m=4个处理器上执行,如图4(b)所示.图4中每个方框表示一个任务,方框中数值表示该任务的利用率.每个圆表示一个处理器,圆中数值表示处理器的执行速度.如果某个处理器没有被分配执行速度,则标记为“关闭”.从图4(a)可知,任Page15务τ1在处理器cpu3上以1.2sGHz为速度从时刻0ms到时刻30ms执行,TT中所有任务分别在处理器cpu2和cpu1以0.9sGHz为速度从时刻0ms到时刻30ms执行,因此LUF-SO算法得到的总能耗值为ELUF-SO=P(1.2s)D+El2=11.0232mJ.而从图4(b)可知,除了任务τ1在处理器cpu4上以1.2sGHz为速度从时刻0ms到时刻30ms执行以外,TT中所有任务分别在其它3个处理器上以0.6sGHz为速度从时刻0ms到时刻30ms执行,因此LTF-M算法得到的总能耗值为ELTF-M=P(1.2s)·D+P(0.6s)·3·D=12.4512mJ.相比LTF-M算法,LUF-SO最优算法能够节余能耗约11%.6结束语本文针对具有独立DVFS的多处理器系统,在考虑处理器状态切换开销情况下,提出一种基于帧任务模型的最优节能实时调度算法LUF-SO.LUF-SO算法允许实时任务在处理器之间的任意迁移,可以离线确定任务集的执行过程和执行速度.同时,该算法根据关键速度来判断系统的低负载情况,一旦确定系统处于低负载情况,首先确定具有最低能耗值的活跃处理器个数,然后根据状态切换时间和能量开销来确定最优调度序列.LUF-SO算法实现简单且复杂度小.本文经过系统的理论分析证明了该算法的最优性.
