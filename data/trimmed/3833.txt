Page1针对组相联缓存的无效缓存路访问混合过滤机制研究范灵俊1),2)徐远超1),5)施巍松3)范东睿1)娄杰4)1)(中国科学院计算技术研究所计算机体系结构国家重点实验室北京100190)2)(中国科学院大学北京100049)3)(韦恩州立大学计算机科学系底特律美国48202)4)(英特尔公司北京100190)5)(首都师范大学信息工程学院北京100048)摘要近年来,功耗成为处理器设计领域的关键问题之一.传统应对功耗的方法如DVFS(DynamicVoltageFrequencyScaling)目前遭遇了收益递减律.随着多核/众核处理器的普及化,片上缓存占有了越来越多的CPU芯片面积和功耗.针对降低功耗的问题,文中提出了通过过滤不必要的缓存路访问来降低缓存动态功耗的方法.该方法包括采用无效访问过滤器(InvalidFilter)来消除对含无效数据块的缓存路的访问;采用指令数据访问过滤器(I/DFilter)来消除对与访问类型(指令或数据)不匹配的数据块所在的缓存路的访问;以及采用tag低位过滤器(Tag-2Filter)来消除对tag低位不匹配的数据块所在的缓存路的访问.文中提出将以上3种方法合并,称为Invalid+I/D+Tag-2Filter,以期取得更好的效果.通过分析和实验验证了3种方法的有效性和互补性.同时,实验也表明,与Invalid+I/DFilter相比,Invalid+I/D+Tag-2Filter在64KB4路组相联缓存上可以取得19.6%~47.8%(平均34.3%)的效果提升,在128KB8路组相联缓存上可以取得19.6%~55.2%(平均39.2%)的效果提升;与Invalid+Tag-2Filter相比,Invalid+I/D+Tag-2Filter在64KB4路组相联缓存上可以取得16.1%~27.7%(平均16.6%)的效果提升,在128KB8路组相联缓存上可以取得6.9%~44.4%(平均25.0%)的效果提升.关键词组相联缓存;动态功耗;无效访问过滤器;访问类型过滤器;tag低位过滤器1引言近年来,功耗是处理器设计领域被关注的热点问题之一.DVFS(DynamicVoltageandFrequencyScaling)技术是最常被采用的节省CPU功耗的技术,但通过DVFS降低功耗目前正遭遇收益递减律[1].此外,文献[2]的研究也表明,随着多核处理器核数的不断上升,将带来芯片的功耗受限,很快会遇到darksilicon问题.即所有处理器核都工作起来将导致芯片的功耗不可忍受.因此,需要找到一种新的有效并且通用的降低CPU功耗的方法.得益于程序访存的局部性,从1980年代开始,缓存在填补处理器速度和内存速度之间的鸿沟中扮演了重要的角色,并带来了处理器性能的不断提升.因为大多数应用程序都表现出了良好的数据访问的空间/时间局部性,对于一个特定的处理器结构,越大的缓存往往预示着更好的程序性能.在现代处理器设计中,采用多种多样的缓存结构和缓存层次,来应对“存储墙[3]”问题.组相联缓存是最基本的结构之一,由于其能很好地降低冲突失效,从而得到了最为广泛的应用.此外,在多核/众核处理器领域,集成更多的处理器核必然需要更多的片上缓存来供数,以保证可以带来不断的性能提高.因此,片上缓存占用了越来越多的芯片面积[4-5].然而,更大的缓存也带来了更多的功耗,有的甚至达到了处理器总功耗的40%~50%[6].一直以来,降低缓存的功耗引起了国内外研究者的高度关注[7-17].然而,大部分研究工作都有其不足,它们或者需要软件的支持,或者带来了性能损失,或者引入了太多的硬件开销,并且提高了硬件设计复杂度,而不容易具体实现.本文中,为了降低CPU的动态功耗,提出了不必要缓存路访问的混合过滤方法,包括无效访问过滤器(InvalidFilter)、指令数据访问类型匹配过滤器(Instruction/DataFilter,I/DFilter)和Tag低位匹配过滤器(Tag-2Filter).它们都基于组相联缓存结构,混合后的方法可以在指令数据共享的缓存中得到应用.针对每次访问,InvalidFilter可以提前检查含有无效数据块的缓存路,I/DFilter可以提前检查与本次指令或数据访问类型不匹配的缓存路,Tag-2Filter可以提前检查Tag最低2位不匹配的缓存路.符合以上3种情况,被以上过滤器提前检测出的缓存路,在接下来的操作中将不被使能(disabled).以上方法由于消除了Cache结构中不必要的活跃行为(activities),从而将有效降低CPU的动态功耗.实验表明,对于不同的应用程序,采用Invalid+I/DFilter,在64KB-4way组相联Cache结构上可以消除36.65%~65.88%的无效路访问,在128KB-8way组相联Cache结构上消除无效路访问达到了46.49%~82.94%;而采用Invalid+Tag-2Filter,在64KB-4way组相联Cache结构上59.65%~69.32%的无效路访问可以被消除,上述结果在Page3128KB-8way组相联Cache结构上测试时也提高到了67.86%~84.66%.此外,我们提出的合并方法(Invalid+I/D+Tag-2Filter)的实验效果比以上两者(Invalid+I/DFilter,Invalid+Tag-2Filter)都好,在第4节做详细介绍.同时,采用CACTI6.0模拟器进行的测试表明,实际应用程序运行在以上64KB-4way和128KB-8wayCache结构上也获得了同等的能耗降低.本文第2节讨论相关工作;第3节介绍本文方法和无效缓存路访问过滤机制的逻辑结构以及带有无效缓存路访问过滤机制的缓存访问流程;第4节分析和验证方法的互补性,并给出具体的实验结果;第5节对全文进行总结.2相关工作作为处理器设计领域的研究热点之一,降低缓存的功耗近年来得到了学术界持续的关注[7-17].以下,将讨论和比较一些常见的通过减少缓存中不必要行为来降低缓存功耗的方法.分段访问缓存(PhasedCaches)[7],如图1所示,先访问tag,再访问数据.访问数据时,只访问命中的那一路.此方法的缺点是,每一次缓存访问都多了一拍,增加了访存延迟.以4路组相联缓存为例,命中的情况下,每次访问的动态功耗为4T+1D(4路tag访问和1路data访问).如图2所示,路预测缓存(Way-predictionCache)[8]提前预测可能匹配的一路,然后只访问这一路.每次访问的动态功耗为1T+1D,即1路tag访问和1路data访问.但是,当预测错误时,访问要再发生一次.文献[9]提出了采用指令/数据过滤器来减少缓存中缓存路的访问操作从而降低功耗的方法.采用指令/数据过滤器,每次访问的功耗为hT+hD,其中h是与本次访问类型(指令或数据)符合的缓存块数量.此方法单独作用效果有限,因此,本文提出的混合过滤器将此方法作为其中的一部分.在文献[10]中,Keramidas等利用cachedecay来降低组相联缓存的动态功耗,称作Way-selectionCache.如图3所示.Cachedecay技术最初由文献[11]提出,用来降低静态功耗.方法是,当一个缓存块里的数据不再被用到时,将其所在的缓存路关掉(poweroff).此缓存结构,或者利用decaybits,或者利用decaybloomfilters来追踪和判断一个缓存块是处于live状态,还是处于dead状态,然后当访问发生时,只访问处于live状态的缓存块.然而,用decaybits的方法会带来低的准确度,用decaybloomfilters会引入过多的硬件开销.在Way-selectionPage4Cache中,每次访问的动态功耗为yT+yD,其中,y是所访问的缓存组中live的缓存块数量.Zhang等人在文献[12]中提出了Way-haltingCache,一种4路组相联缓存,将每一路tag位的最低4位存在一个全相联的缓存中,称为halttag阵列.Halttag阵列提前比较最低4位来预先检查哪些路是不会被匹配的,在随后的访问中,这些路被屏蔽掉,进而节省了访问时产生的功耗.在Way-haltingCache中,每次访问的动态功耗是zT+zD,其中z取决于可能匹配的缓存路的数量.表1中,将现有的一些低功耗缓存结构进行总结和对比.对于本文提出的采用Invalid+I/D+Tag-2Filter方法的Way-filteringCache,每次访问的动态功耗为xT+xD,其中x为数据有效、访问类型匹配并且tag低2位匹配的缓存块数量.缓存结构访问对象每次访问Way-predictionpredictedline1T+1DmorewrongWay-selectionlivelinesyT+yDmorewrongPhasedCachehitline4T+1DlittleonemoreWay-haltingmaymatchI/DFilteringI/DmatchlineshT+hDlittleonemoreWay-filtering3本文方法得益于程序访存的局部性原理,片上缓存在现代处理器性能的提高中扮演了重要的角色.组相联缓存结构由于可以有效减少冲突缺失从而得到了最为广泛的使用.在对组相联缓存的每一次访问中,虽然访问一个缓存组中的所有缓存块,但最多只有一路缓存块是命中的.所以,如果我们能够事先消除不必要的缓存路访问,则由读操作产生的动态功耗必将被有效降低.缓存的功耗来源有两部分组成:一是电路状态稳定时的静态功耗;另一是电路的翻转带来的动态功耗.读操作和写操作是缓存结构中两种最基本的操作,文献[18]指出,在程序访存序列中,读操作的数量大概是写操作的两倍.此外,每次写操作发生时,也伴随有一次读操作,以检查要写的数据块是否在缓存中命中.由此可见,读操作在动态功耗的产生中占有了很大的比例.3.1不必要的缓存路访问对组相联缓存的每次访问产生的能耗(Ecache)可以由文献[8]给出的公式进行预估.如式(1)和式(2)所示.其中,Edecode表示驱动地址总线和解析访存地址的能耗;Ememory表示访问tag阵列和data阵列的能耗;EI/O表示当替换发生时驱动外部I/O管脚的能耗;Ntag和Ndata表示访问tag阵列和data阵列的个数;Etag和Edata表示访问单个tag阵列和data阵列的能耗.鉴于Ememory是整个能耗Ecache的主要来源,本文方法主要是通过减少Ntag和Ndata来降低Ememory.在传统的组相联缓存中,访存地址通常包含tag段、index段和offset段.当读操作发生时,在访存地址生成以后,index段被用来索引到相应的缓存组,进而读出此缓存组中的所有tag和数据,然后将读出的tag和tag段进行比较,看是否命中.如果命中,并且缓存块中的数据有效,offset段用来选择需要的数据写回.否则,发出缺失消息,并等待数据的回填.因为程序访存的空间局部性,组相联缓存同一个缓存组中,tag比对导致不匹配发生的情况大多是由tag低位不匹配造成的.所以,我们可以提前检查tag最低两位的匹配情况,进而在进一步的访问中过滤掉对最低两位不匹配缓存路的访问.同时,每次对某个缓存组的访问,并非任何时候每个要访问的缓存组含有的数据块都是有效的,比如,当某个缓存组中的块没有被填满,或者某数据块被无效消息无效掉时.在这种情况下,我们可以先通过检查要访问缓存组的Valid/Invalid标志位,然后在进一步的操作中,消除对含无效数据块的缓存路的访问.此外,在被指令和数据共享的缓存中,一个缓存组可能存有数据块,也可能存有指令块.而每次访问,要么访问数据,要么访问指令.所以,可以对每个数据块设置一个标志位(I/Dbit),来指示里面存放的是指令还是数据,然后访问前检查此标志位,从而在进一步的操作中,消除对访问类型不匹配的数据块的访问.Page5以上过滤方法都对缓存的命中率没有产生影响,但是由于在缓存访问前放置了一个过滤器(Filter),所以从硬件实现的角度,需要多一拍的延迟来检测不符合进一步访问条件的缓存块.因此,建议此过滤方法最好运用在延迟非敏感的缓存结构中,如UnifiedL2Cache或共享LLC(Last-Level-Cache).3.2硬件结构下面介绍以上3种不必要缓存路访问过滤机制的逻辑结构,用于检查无效数据块的InvalidFilter,用于检查指令/数据访问类型不匹配数据块的I/DFilter以及用于检查tag最低2位不匹配数据块的Tag-2Filter,它们可以基于传统的组相联缓存而实现.图4以4路组相联缓存为例,对InvalidFilter的结构进行了描述.由于传统的组相联缓存中,已存在Valid/Invalid标志位,图中为ValidBitsTable.因此,我们只需将标志位的检查逻辑从读出数据和tag之后,移到读出数据和tag之前,并将此逻辑的输出与各个缓存路使能信号的生成逻辑合并即可.无效标志位所在的缓存路将不被使能.图5对I/DFilter的结构进行了描述,也以4路组相联缓存为例.为了区分指令块和数据块,我们为每个缓存块添加了一位标志位,置为1表示数据块,为0表示指令块.如图5所示,还需要在访问缓存的请求消息中设置一位来指示访问类型(数据或指令),从数据缓存发出置为1,从指令缓存发出置为0.数据块的标志位在发生回填时根据miss类型设置.Tag-2Filter的结构由图6给出,我们将所有tag的最低2位单独存储,在图6中称为tag最低两位表.在访问缓存组前,首先检查相应的tag最低两位表,并将结果输出与各个缓存路的使能信号产生逻辑合并.以缓存块大小为32byte为例,加上tag位,每个缓存块的大小将超过256bit,所以使每个缓存块多2bit的tag最低两位表的硬件开销不到百分之一,可忽略不计.3.3访问流程图7描述了引入3种访问过滤器的缓存访问流程图.访存地址生成后,根据地址首先查找Valid表、I/D表以及Tag-2表,检查要访问的缓存组中数据无效的缓存块、I/D位不符合的缓存块以及tag最低两位不匹配的缓存块,查询操作同时进行.根据检查结果,在进一步的缓存访问时,将不满足访问条Page6件(Invalid,I/D位不匹配,tag低两位不匹配)的缓存块所在的缓存路不使能(disable),只读出Valid并且I/D位和tag低两位都与各自表中对应项相匹配的缓存块,然后通过进一步的tag比对,根据是否命中选择数据写回,或发出缺失消息.如果检查时,所有缓存路的数据都不满足进一步访问的条件,则直接发出缺失消息,等待数据回填.由此可见,对于访问即将发生缺失时,最理想的情况是,通过预先检查,直接判断最后的结果,而对tag和data阵列根本不再发生访问.另外,值得注意的是,由于以上3种方法可以并行工作,具有互补性,所以,将以上方法混合使用后可以达到更好的过滤和节能效果,第4节我们将通过具体的实验对此进行验证.4实验结果本节我们通过实验来评估混合过滤方法(Invalid+I/D+Tag-2Filter)的效果.首先,我们分析并通过初步实验验证3种方法之间的互补性.紧接着,我们将实际程序的访存Trace在实现了混合过滤器的缓存上进行测试,以得到能够通过混合过滤器而消除的无效缓存路访问占整个访问的比率.然后,我们采用CACTI6.0[19]来评估采用过滤方法后被减少的动态功耗.同时,我们还将混合过滤器与只采用Invalid+I/DFilter的方法和只采用Invalid+Tag-2的方法取得的效果进行对比.4.1方法互补性分析本文提出的3种不必要缓存路访问过滤方法(I/DFilter,InvalidFilter,Tag-2Filter)分别是从程序数据类型(instruction/data)、程序数据状态(Valid/Invalid)以及访存空间局部性原理导致的访存地址差异(tag低位不同)3个方面进行考虑,其中I/DFilter区分了同一缓存组中的指令缓存块和数据缓存块;InvalidFilter区分了同一缓存组中的有效缓存块和无效缓存块(如空缓存块);Tag-2Filter区分了tag低位地址差异的缓存块.3种方法互相补充.当然,3种方法混合作用,也会有重叠的部分.这里,我们以InvalidFilter和Tag-2Filter为例,通过初步的实验验证方法的有效性和互补性.我们知道,在程序运行初期或程序数据量较小而局部性又很好(即缓存未被数据填满)的时候,缓存中存在一定数量的空置缓存块(无效缓存块),如图8所示,InvalidFilter此时可以发挥作用.而当缓存块被数据逐渐填满时,各个缓存组中的缓存块由于空间局部性大多只是tag低几位的不同,Tag-2Filter此时可以发挥作用.为了验证这一点,我们将两个常用算法矩阵乘和矩阵转置在实现了InvalidFilter和Tag-2Filter的缓存行为分析器上进行测试,并逐渐增大测试的数据规模,从而模拟和测试了上述过程.缓存的大小设置为32KB,4-way组相联.设RIA为不必要缓存块的访问率,TBR(i)为i路不必要缓存块的访问次数,其中i从0~N,N是缓存的最大相联度,TR为缓存块的总访问次数,则根据式(3)计算访问不必要数据块的比例.RIA=∑n测试结果如表2和表3所示.统计结果都表明,InvalidFilter和Tag-2Filter各自发挥了作用,在矩阵乘程序中,InvalidFilter最高可过滤68.46%的缓存路访问,Tag-2Filter最高可过滤63%的缓存路访问;在矩阵转置程序中,InvalidFilter最高可过Page7滤68.6%的缓存路访问,Tag-2Filter最高可过滤69%的缓存路访问.并且,随着数据规模的增大(即缓存逐渐被填满),两种方法的作用此消彼长,而总体效果分别保持在61.65%~74.74%和71.58%~77.9%.因此可以说,两者具有很好的互补性.表2矩阵乘程序在32KB-4way带有InvalidFilter和MatrixDataAmount32×3268.4648×4832.7464×6496×96128×1280.15表3矩阵转置程序在32KB-4way带有InvalidFilter和MatrixDataAmount48×3268.6064×4849.9064×6433.60128×6414.58256×1284.65需要注意的是,为简单起见,我们这里只模拟了空置缓存块,而未被使用的空置缓存块只是缓存块无效的其中一种状态,在实际程序运行中,缓存块的无效状态还包括被Invalid消息无效掉的,如来自DMA(DirectMemoryAccess)控制器的Invalid消息或处理器核的Invalid消息等.下一节,我们将通过实际应用程序对3种方法的有效性做进一步的测试,并且将不同方法进行组合,通过对比,进一步验证方法之间的互补性.4.2可被消除的缓存路访问比率本节,我们将通过实验来测试通过3种过滤器可被消除的缓存路访问比率.实验用了2个应用程序(spice,tex)和6个从SPECCPU2000测试程序集中随机挑选的测试程序,其中3个来自SPECCPU2000Integer(gcc、mcf和eon),另外3个来自SPECCPU2000floating-point(mesa、ammp和art),被用来验证通过各种过滤器可以消除缓存路访问比率.其中,每个测试Benchmark的访存Trace都超过百万条.针对3种不同的组合过滤器(Invalid+I/DFilter,Invalid+Tag-2Filter,Invalid+I/D+Tag-2Filter),我们分别在64KB-4way和128KB-8way组相联缓存上进行了测试,这些缓存可以被指令和数据存储共享.实验结果分别如图9和图10所示.为了集中于我们所关注的问题,缓存块大小固定为32Byte,替换策略采用随机替换.不必要缓存路访问比率统计计算方法如4.1节中式(3)所示.图964KB-4way缓存上可被消除的路访问比率图10128KB-8way缓存上可被消除的路访问比率图9的结果显示,在64KB-4way带有Invalid+I/DFilter的缓存结构上,能够被消除的缓存路访问比率分别为gcc47.63%,mcf52.73%,eon49.60%,art52.41%,mesa62.50%,ammp36.65%,spice50.49%,tex65.88%;在64KB-4way带有Invalid+Tag-2Filter的缓存结构上,能够被消除的缓存路访问比率分别为gcc59.65%,mcf60.07%,eon65.53%,art61.64%,mesa66.38%,ammp60.25%,spice66.67%,tex69.32%;在64KB-4way带有Invalid+I/D+Tag-2Filter的缓存结构上,能够被消除的缓存路访问比率分别为gcc71.42%,mcf73.58%,eon68.24%,art73.19%,mesa71.08%,ammp68.50%,spice74.16%,tex72.97%.以上结果还表明,与Invalid+I/DFilter相比,Invalid+I/D+Tag-2Filter可以获得平均19.41%的效果提高;与Invalid+Tag-2Filter相比,Invalid+I/D+Tag-2Filter可以获得平均7.95%的效果提高.图10的结果显示,在128KB-8way带有Invalid+I/DFilter的缓存结构上,能够被消除的缓存路访问Page8比率分别为gcc59.41%,mcf61.95%,eon74.54%,art63.12%,mesa80.39%,ammp46.49%,spice72.81%,tex82.94%;在128KB-8way带有Invalid+Tag-2Filter的缓存结构上,能够被消除的缓存路访问比率分别为gcc67.86%,mcf68.52%,eon82.52%,art71.29%,mesa82.80%,ammp71.09%,spice82.10%,tex84.66%;在128KB-8way带有Invalid+I/D+Tag-2Filter的缓存结构上,能够被消除的缓存路访问比率分别为gcc82.46%,mcf83.23%,eon84.07%,art83.42%,mesa85.31%,ammp78.91%,spice86.78%,tex86.48%.以上结果还表明,与Invalid+I/DFilter相比,Invalid+I/D+Tag-2Filter可以获得平均16.13%的效果提高;与Invalid+Tag-2Filter相比,Invalid+I/D+Tag-2Filter可以获得平均7.48%的效果提高.4.3能耗节省评估及对比由于大量不必要的缓存路访问可以通过本文过滤方法预先消除,由此产生的动态能耗也必将大大降低.接下来,我们采用CACTI6.0来评估和比较通过不同过滤器所能节省的能耗.实验中只考虑由于缓存的访问而产生的动态能耗.实验结果表明,采用混合过滤机制,Invalid+I/D+Tag-2Filter的效果比Invalid+I/DFilter和Invalid+Tag-2Filter的效果都好,实验结果的比较如图11和图12所示.图11的结果表明,在64KB-4way缓存上,与采用Invalid+I/DFilter相比,Invalid+I/D+Tag-2Filter能得到的能耗降低效果提升为gcc39.0%,mcf35.3%,eon36.6%,art34.7%,mesa20.1%,ammp47.8%,spice41.5%,tex19.6%,平均提高34.3%;与采用Invalid+Tag-2Filter相比,Invalid+I/D+Tag-2Filter能得到的能耗降低效果提升为gcc22.5%,mcf27.7%,eon6.2%,art23.2%,mesa11.5%,ammp17.7%,spice16.2%,tex8.0%,平均提高16.6%.图12的结果表明,在128KB-8way缓存上,与采用Invalid+I/DFilter相比,Invalid+I/D+Tag-2Filter能得到的能耗降低效果提升为gcc48.3%,mcf45.7%,eon36.6%,art44.7%,mesa19.0%,ammp55.2%,spice44.1%,tex19.6%,平均提高39.2%;与采用Invalid+Tag-2Filter相比,Invalid+I/D+Tag-2Filter能得到的能耗降低效果提升为gcc44.4%,mcf43.3%,eon7.0%,art40.0%,mesa12.4%,ammp24.7%,spice20.0%,tex8.0%,平均提高25.0%.5结束语一直以来,降低高速缓存的功耗,作为处理器领域的研究热点之一,无论在单核处理器还是在多核处理器中,都得到了国内外同行的广泛关注.本文提出了在组相联缓存中采用过滤机制通过消除不必要缓存路访问来降低CPU动态功耗的方法.对于每次访问,利用InvalidFilter可以预先检查无效数据块,I/DFilter可以提前查出指令/数据访问类型不匹配的数据块,Tag-2Filter可以提前查出tag最低2位不匹配数据块,被查出的数据块所在的缓存路的访问在随后得到消除.实验表明,以上方法可以有效降低缓存的能耗,并且当3种方法混合使用时,效果最好.本文方法也可以在多核/众核处理器的共享LLC(Last-Level-Cache)中得以应用,这将是我们下一步的工作.致谢在此,我们向中国科学院计算技术研究所的张轮凯和唐士斌表示感谢,感谢他们在本文方法讨论中给予的建议;向美国韦恩州立大学的王世楠表示感谢,感谢他在本文的实验中参与的分析和讨论;向中国科学院计算技术研究所的王达博士和宋风龙博士表示感谢,感谢他们在本文撰写过程中给予的帮助!Page9
