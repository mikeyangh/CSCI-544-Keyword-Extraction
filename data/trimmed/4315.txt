Page1Tableau算法的优化及模型规约技术刘大有赖永王生生(吉林大学计算机科学与技术学院长春130012)(吉林大学符号计算与知识工程教育部重点实验室长春130012)摘要为了近一步提高模态逻辑推理机的效率,提出了两种Tableau算法优化技术———冲突技术和矛盾学习技术,并结合这两种技术实现了针对模态逻辑S4的推理机S4P.在此基础上,为了从Tableau算法生成的模型图中构造一个规模较小的模型,又提出通用模型的概念,然后给出通用模型的规约技术并证明该技术对于任意依赖于公理D、T、B、4和5中部分或全部公理的正规模态逻辑的正确性.最后,使用逻辑工作台测试用例对S4P的效率进行测试,实验结果表明S4P的效率优于RACER和FaCT++;同时,对S4P生成的测试用例中非有效公式的否定对应的通用模型进行规约,实验结果表明通过模型规约能明显地缩减模型的规模.关键词模态逻辑;Tableau算法;优化;模型规约1引言在过去二十年多年中,模态逻辑已被广泛应用Page2中,Tableau方法[1]是使用最广的方法之一.到目前为止,研究人员提出了多种优化技术[6-8]大大提高了Tableau算法的求解效率,著名的推理机例如RAC-ER[6]和FaCT++[7-8]等都是在这些优化技术的基础上实现的①.在国内,刘全和孙吉贵等人[9-10]对Tableau方法中推理规则进行了改进,提高了推理效率;常亮和史忠植等人[11]提出了一种动态描述逻辑的Tableau判定算法.模态逻辑根据其依赖公理的不同而分为K、KT、KD、S4和S5等多种不同逻辑,其中,S4是使用最广的逻辑之一,尤其在时空推理领域应用广泛[3-4,12].迄今为止,特别针对S4的模态推理机尚未见报道,因此在多数实验和应用中通常使用兼容S4的推理机,例如,RACER、FaCT++等.尽管目前兼容S4的推理机已表现出很高的推理效率[13-14],且随着新优化技术的使用其效率也在逐步提高[15],但从技术角度来说,设计特别针对S4的推理机仍有很大的效率提升空间.在本文中,为了进一步提高Tableau算法的求解效率,提出了两种新优化技术———冲突技术和矛盾学习技术,并结合二者开发了针对S4的推理机S4P.我们在逻辑工作台测试用例[12-13]上对S4P的效率进行了测试,实验结果表明S4P的效率优于RACER和FaCT++.在实际应用中,在判定出任意可满足的模态公式的可满足性后,有时还需给出满足该公式的模型,然后利用此模型进行查询或生成拓扑[3-4,16].由于模型的规模直接影响其使用效率,因此对模型进行简化具有重要意义.例如,对最小模型(leastmodel)进行简化能提高查询效率[16],对满足描述拓扑关系的S4公式的模型进行简化能缩减生成的拓扑的规模[3-4].本文对模型的概念进行泛化,定义了通用模型,并给出了通用模型的规约技术.由于Tableau算法生成的任意模型图(modelgraph)[1]都对应一个通用模型,因此通过对通用模型的规约可从模型图中提取出一个规模较小的模型.本文证明了通用模型的规约技术对于所有依赖于公理D、T、B、4和5的任意组合的正规模态逻辑的正确性.最后,本文对由S4P生成的测试用例中非有效公式的否定(即可满足的公式)对应的通用模型进行了规约,实验结果表明了规约规则的有效性.本文第2节给出关于模态逻辑和Tableau算法的预备知识;第3节介绍S4P中使用的预处理技术;第4节给出S4P中使用的优化技术;第5节介绍如何从Tableau算法生成的模型图中构造一个规模较小的模型;第6节给出实验结果并进行分析;最后我们对本文进行总结.2预备知识2.1模态逻辑模态公式(本文简称为公式)是通过使用如下规则得到的有限序列:任意原子命题(简称为命题)是公式,⊥是公式,如果和φ是公式,则、∧φ、∨φ、→φ、□、◇是公式.本文约定p和q表示命题,、φ和ζ表示公式,表示所有原子的集合,X和Y表示公式集.Kripke框架(简称为框架)是一个二元组=〈W,R〉,其中W是一个非空状态集,R是W上的二元关系.本文将(w,v)∈R记为wRv,并称w是v的前驱,v是w的后继.Kripke模型(简称为模型)是一个二元组=〈,V〉,其中是一个框架,V是一个将命题集合中命题p赋值为W的一个子集V(P)的函数,形式化地记为V:2W,即V(p)为模型中p为真的状态集合.对于给定的模型=〈,V〉,称基于框架,的规模表示为的状态数.模型=〈W,R,V〉中状态w满足公式按如下方式进行递归定义:◇且wRv;v都有,v.如果不对模型进行限制,则得到一种正规模态逻辑(normalmodallogic),按照标准的希尔伯特式公理化表示称为正规模态逻辑K(本文中提到的模态逻辑都默认为正规模态逻辑),其他模态逻辑可通过向K中增加一些公理(axiom)得到.常见的公理如表1所示.模态逻辑S4是在K的基础上增加T公理和4公理得到,任意公式在S4下可满足当且①严格地说FaCT++(http://code.google.com/p/factplus-Page3仅当存在自反传递的模型=〈W,R,V〉和状态w∈W使得,w.公理(□→□φ)无(K)□(→φ)→(D)□→◇连续性(serial):wv(wRv)(T)□→自反性(reflexive):w(wRw)(B)→□◇对称性(symmetric):wv(wRv→vRw)(4)□→□□传递性(transitive):wvu(wRv∧(5)◇→□◇欧几里得性(Euclidean):wvu(wRv∧2.2Tableau算法Tableau规则ρ由分子和有限多个分母1,…,k组成,表示为如下形式:任意规则ρ可应用于某个公式集X,当且仅当X是ρ的分子的实例化.一个Tableau演算由有限多个Tableau规则组成.例如,模态逻辑S4的Tableau演算S4由如下7个Tableau-规则组成:X∪{,φ},(⊥){,}(∧)X∪{∧φ}X∪{}|X∪{φ},()X∪{}(∨)X∪{∨φ}X∪{□,},(S4){□1,…,□n,◇φ}(T)X∪{□}公式对应的Tableau是一棵通过如下方式得到的节点为公式集的有限树:首先,树仅包含一个标记为{}的根节点,若=⊥,则称根节点为终止节点,否则称根节点为非终止节点;然后,按照如下步骤扩展树直到所有叶节点都为终止节点:(1)选择一个标记为X的非终止叶节点和能在X上应用的规则ρ;(2)为ρ的每个分母创建一个节点作为原叶节点的子节点,并将这些子节点标记为对应的分母实例化后所得到的公式集;(3)对于得到的新叶节点,如果其上标记的公式集为{⊥}或该节点标记的公式已出现在其祖先节点上,则称该叶节点为终止节点,否则称其为非终止节点.若Tableau的一个分支的所有终止节点都为{⊥},则称该分支是封闭(closed),否则称其非封闭;若Tableau的所有分支都封闭,则称该Tableau封闭,否则称其非封闭.对于Tableau演算L,公式是L-一致的当且仅当不存在封闭的L-Tableau与之对应,否则称为L-不一致.公式是S4-一致的当且仅当其在S4下可满足,且任意公式对应的非封闭Tableau都对应一个模型图,可从该模型图中构造一个满足的模型[1].3预处理技术本节介绍我们开发的S4推理机S4P中使用的预处理技术.由第6节的实验结果可知,RACER和FaCT++没有使用或者没有完全使用本节所提到的预处理技术,同样的问题存在于文献[13]中分析的其他推理机中.首先,假设需要判定可满足性的公式为0,S4P中采用如下步骤对其进行预处理:(negationnormalform)1:(1)按如下方式递归地将0转化为否定范式nnf(⊥)··=⊥,nnf(⊥)··=⊥,nnf(p)··=p,nnf(p)··=p,nnf(∧φ)··=nnf()∧nnf(φ),nnf(∨φ)··=nnf()∨nnf(φ),nnf(→φ)··=nnf(∨φ),nnf(□)··=□nnf(),nnf(◇)··=◇nnf(),nnf((∧φ))··=nnf(∨φ),nnf((∨φ))··=nnf(∧φ),nnf((→φ))··=nnf(∧φ),nnf(□)··=nnf(◇),nnf(◇)··=nnf(□),nnf()··=nnf().否定范式φ的规模size(φ)递归定义如下:size(⊥)··=1,size(⊥)··=1,size(p)··=1,size(p)··=1,size(∨φ)··=size()+size(φ)+1,size(∧φ)··=size()+size(φ)+1,size(□)··=size()+1,size(◇)··=size()+1.(2)执行完步骤(1)后我们循坏执行以下3个步骤直到公式不能再化简为止:(2.1)因为在S4下有□φ≡□□φ,◇φ≡◇◇φ,□◇φ≡□◇□◇φ和◇□φ≡◇□◇□φ成立,因此S4P将任意出现在2中的形如“≡”右边的子公式都转化为左边的形式从而得到公式2.Page4(2.2)将所有在2中仅以“p”的形式出现的命题用⊥替换,仅以“p”形式出现的命题用⊥替换.替换后得到的公式称为3.(2.3)将3中所有φ∧⊥替换为⊥,φ∧⊥替换为φ,φ∨⊥替换为φ,φ∨⊥替换为⊥,□⊥替换为⊥,□⊥替换为⊥,◇⊥替换为⊥,◇⊥替换为⊥①,直到公式中不出现⊥或整个公式被替换为⊥或⊥为止.显然,⊥为不可满足的,⊥为可满足的.如果3被替换为⊥或⊥,说明仅仅需要通过预处理即可判定出0的可满足性.4优化技术本节介绍S4P中使用的优化技术.4.1小节为S4P从其他基于Tableau算法的非经典逻辑推理机中借鉴的优化技术[6-8],4.2小节为S4P中新引入的优化技术.本节所提到的否定范式都默认不出现⊥,因为通过第3节的预处理后得到的公式,如果仍需要进一步判定可满足性说明其中必然不出现⊥.4.1已有的优化技术(1)编码技术给定否定范式,对其中出现的每个子公式进行编码,因此当需要判定两个公式是否相同时,只需判断它们的编码是否相同.编码方法如下:=φ∧ζ:对φ和ζ进行编码,如果φ和ζ的编码相同,则直接返回φ的编码,否则如果存在∈X使得=φ∧ζ或=ζ∧φ,直接返回的编码;否则,对和nnf()赋值不同于X中所有公式的编码,并将二者加入到X中;=φ∨ζ:与=φ∧ζ的情形对偶;=□φ(或=◇φ):对φ进行编码,如果存在∈X使得=□φ(或=◇φ),直接返回的编码;否则,对和nnf()赋值不同于X中所有公式的编码,并将二者加入到X中;=p(或=p):如果p∈X,直接返回p(或p)的编码;否则,对p和p赋值不同于X中所有公式的编码,并将二者加入到X中.最后得到的X称为的子公式集,记为Sub().显然,在S4P判定的可满足性的过程中,所有使用Tableau规则生成的公式必然属于Sub().(2)语义分支技术标准的Tableau算法使用语法分支搜索(对应∨-规则),其不能预防不同分支上产生相同的不可满足析取项[7],导致推理效率不高.与RACER和FaCT++相同,S4P采用语义分支搜索,即(3)二元约束传播技术在S4P中,每次使用∨-规则之前,首先使用二元约束传播(BooleanConstraintPropagation,BCP)技术进行约束传播以减少不必要的∨-规则使用.在4.2节中,我们将会看到当引入冲突概念后更能发挥BCP的作用.BCP描述为如下的推理规则:4.2新引入的优化技术(1)冲突技术首先,我们给出两个否定范式互相冲突的概念以及互相冲突的两个性质.定义1.原子p与其否定p冲突;对于给定否定范式、φ和ζ,φ∧φ与ζ冲突当且仅当与ζ冲突或φ与ζ冲突;φ∨φ与ζ冲突当且仅当与ζ冲突且φ与ζ;□与公式ζ冲突,若ζ=◇φ,则当且仅当与φ冲突,否则若ζ=□φ,则当且仅当与ζ冲突或□与φ冲突,否则当且仅当与ζ冲突.根据上述定义,读者可验证□◇□p∨q与□◇p∧q冲突.命题1.所有否定范式都与nnf()冲突.证明.用归纳法很容易证明,在此不赘述.定理1.给定否定范式和φ,若二者相互冲突,则任意包含和φ的公式集必然S4-不一致.证明.首先使用归纳法证明存在一个封闭的Tableau与{,φ}对应:当size()+size(φ)=2时,若和φ冲突,则必然存在命题p使得{,φ}={p,p},显然有则存在一个封闭的Tableau与{,φ}对应.况进行讨论:假设对于任意和φ,若size()+size(φ)n,当size()+size(φ)=n+1时,分如下5种情=∧:根据定义,不妨设与φ冲突,根据归纳假设,存在一个封闭的Tableau与{,φ}对应,因为有①模态逻辑S4保证了这些替换的正确性.Page5将{,φ}对应的封闭的Tableau连接到上述Tableau的后面即可得到一个与{,φ}对应的封闭Tableau(下述4种情况中也将进行同样的操作,省略).因此,结论成立;=∨:根据定义,和都与φ冲突,因为有根据归纳假设,结论成立;=□,φ=◇φ:根据定义有,与φ冲突,因为有因此,结论成立.为有=□,φ=□φ:根据定义有,与φ冲突,因{□,□φ}因此,结论成立.义有,与φ冲突,因为有=□,φ不能表示为□φ和◇φ形式:根据定因此结论成立.归纳完毕.对于任意包含和φ的公式集X都能使用θ规则得到公式集{,φ},也即存在一个封闭的Tableau与X对应,因此X是S4-不一致的.定理1保证了任意公式集中若出现了互相冲突的公式,我们能够提前判定其在S4下为不可满足,因此能够节省求解时间.在BCP过程中,如果发现公式集中出现否定范式和φ∨ζ,且与φ相互冲突,则在公式集上使用如下规则:同时,命题1保证了我们无需再使用4.1节中所述的BCP-规则.另外,如果发现公式集中出现否定范式和nnf(φ)∨ζ,且和φ相互冲突,则在公式集上使用如下规则:显然,BCP-规则和-规则的使用,能减少∨-规则的使用次数,故能提高求解效率.每次需要判断两个公式是否相互冲突时临时进行计算是不可取的,在S4P中首先为待证明的公式的子公式集Sub()计算一个冲突关系矩阵用来保存其中元素之间的相互冲突关系(显然,这一过程能在多项式时间内完成),当需要知道两个公式是否相互冲突时,仅需查找对应的矩阵入口即可.(2)矛盾学习技术对于Tableau中对◇使用S4-规则所得到的节点,如果其标记的公式集非S4-一致,则说明{◇}∪{□φ|□φ∈X}非S4-一致,其中,X为该节点的父亲节点标记的公式集.为了确保同样的矛盾不在◇第一次出现的节点的后继节点中再次出现,S4P为Tableau中的所有节点增加一个公式集簇,称为矛盾原因集,并将公式∨□φ∈Xnnf(□φ)加入到公式◇第一次出现的节点的后继节点的矛盾原因集中,然后确保每个节点的矛盾原因集中任意公式都至少有一个析取项在该节点标记的公式集中不存在与之冲突的公式,不能满足此要求的节点直接标记为S4-不一致.对于∨-规则作用的节点,首先继承其父节点中所有矛盾原因,然后每次从子节点返回时都会回收新的矛盾原因,并在返回时传给自己的父节点.每个封闭的S4-规则节点都能学习到一个新的矛盾原因.图1是一个矛盾学习的简单例子.Page65模型提取技术本节我们分两小节进行叙述,其中在5.2节中将用到5.1节中的结论.首先,我们将给出模型规约的定义,并给出规约的正确性证明.其次,我们将讨论如何从模型图中提取一个规模尽可能小的模型,为此我们将提出通用模型的概念并给出通用模型的规约技术及其正确性证明.5.1模型规约定义2.对于模型=〈W,R,V〉中的两个状态w和v,如果满足如下条件,则称二者是可规约的:(1)w和v满足相同的命题,即{p∈|w∈V(p)}={p∈|v∈V(p)};(2)若wRw或wRv,令W1={w,v},否则令W1=;若vRw或vRv,令W2={w,v},否则令W2=;我们有W1∪{u|wRu}=W2∪{u|vRu}.对w和v进行规约后得到模型=〈W,R,V〉,其中,W=W\{v},R={(u,u)|uRu}∪{(u,w)|uRv},对于任意命题p有V(p)=V(p)\{v}.例1.给定模型=〈,V〉,其中如图2(左)所示,且对于任意命题p有V(p)=.w和v可规约,对二者规约后的模型为=〈,V〉,其中,如图2(中)所示,且对于任意命题p有V(p)=.继续对中u和w进行规约得到的模型为=〈,V〉,其中如图2(右)所示且对于任意命题p有V(p)=.最后,中u与u是不可规约的.型.下面说明模型规约的正确性.由例1可知,对模型进行规约后能明显简化模引理1.对于给定的模型=〈W,R,V〉,若其满足表1中连续、自反、对称、传递、欧几里得中任意属性,经过规约后的模型仍然满足该属性.证明.假设规约模型=〈W,R,V〉中的状态w和v后得到模型为=〈W,R,V〉.连续.给定u∈W,因为R是连续的,于是存在u使得uRu,若u=w,有(w,u)∈{(w,u)|wRu}R;若u≠w且u=w,有(u,w)∈{(u,w)|uRw或uRv}R;否则有(u,u)∈{(u,u)|uRu,u≠w,u≠w}R.自反.给定u∈W,若u=w,因为R是自反的,有(w,w)∈{(w,u)|wRu}R;否则u≠w,有(u,u)∈{(u,u)|uRu,u≠w,u≠w}R.对称.给定u,u∈W且uRu,若u≠w且u≠w,有(u,u)∈{(u,u)|uRu,u≠w,w≠v},即uRu,因为R是对称的,于是uRu,因此(u,u)∈{(u,u)|uRu,u≠w,w≠v}R;若u=w且u≠w,有(w,u)∈{(w,u)|wRu},即wRu,因为R是对称的,于是uRw,因此(u,w)∈{(u,w)|uRw或uRv}R;若u≠w且u=w,有uRw或uRv,若uRv,可规约的条件(2)保证了必然有uRw,于是有wRu,因此(w,u)∈{(w,u)|wRu}R;若u=u=w,则(w,w)∈{(u,w)|uRw或uRv}或(w,w)∈{(w,u)|wRu},于是wRw或wRv,(w,w)∈{(u,w)|uRw或uRv}R.传递.给定u,u,u∈W,且uRu和uRu,若u=u或u=u,显然成立;若u=u=w且u≠w,类似于对称性的证明;若u≠w,u=w且u≠w,于是(u,w)∈{(u,w)|uRw或uRv}且(u,w)∈{(w,u)|wRu},即uRw且wRu,因为R是传递的,于是uRu,即(u,u)∈{(u,u)|uRu,u≠w,w≠v}R;若u≠w,u≠w,且u≠w,于是(u,w)∈{(u,u)|uRu,u≠w,w≠v}且(w,u)∈{(u,u)|uRu,u≠w,w≠v},即uRw且wRu,因为R是传递的,于是(u,u)∈{(u,u)|uRu,u≠w,w≠v}R.欧几里得.给定u,u,u∈W,且uRu和uRu,若u=u,显然成立;若u=u=w且u≠w,类似于对称性的证明;若u=w,u≠w且u≠w,有(w,u)∈{(w,u)|wRu}且(w,u)∈{(w,u)|wRu},于是wRu且wRu,由于R是欧几里得式的,有uRu,因此(u,u)∈{(u,u)|uRu,u≠w,w≠v}R;若u≠w,u=u=w,于是uRw或uRv,由于R是欧几里得式的,有wRw或vRv,若vRv,可规约的条件(2)保证了必然有wRv或wRw,即wRw或vRv等价于wRw或wRv,因此(w,w)∈{(u,w)|uRw或uRv}R;若u≠w,u=u≠w,类似于对称性的证明;若u≠w,u≠w且u=w,有uRu,及uRw或uRv,由于R是欧几里得式的,有uRw或uRv,因此(u,w)∈{(u,w)|uRw或uRv}R;若u≠w,u≠w且u≠w,于是uRu且uRu,因为R是欧几里得式的,于是(u,u)∈{(u,u)|uRu,u≠w,w≠v}R.定义3[17].给定模型=〈W,R,V〉和=Page7〈W,R,V〉,满足下述条件的非空的二元关系ZW×W称为和的互模拟(bisimulation):(1)若wZw,则w和w满足相同的命题,即{p∈|w∈V(p)}={p∈|w∈V(p)};(2)若wZw且wRv,则中存在v使得vZv且wRv;(3)若wZw且wRv,则中存在v使得vZv且wRv.引理2[17].若模型和之间存在互模拟Z,则对于任意wZw和任意公式都有,,w当且仅当,w.引理3.对于给定模型及其上可规约的两个状态w和v,假设对w和v规约后得到的模型为,则二元关系Z={(u,u)|u≠w,u≠v}∪{(w,w),(v,w)}是和之间的互模拟.证明.定义3中条件(1)显然能被满足.条件(2).假设wZw且wRv,证明中存在v使得vZv且wRv.若v=w或v=v,令v=w即可满足要求;否则,令v=v能够满足要求.条件(3).假设wZw且wRv,证明中存在v使得vZv且wRv.若w=w且v=w因此有wRw或wRv成立,显然满足要求;若w=w且v≠w,令v=v即可满足要求;若w≠w,根据Z的定义必然有w=v且w=w,若v=w,因此有wRw或wRv成立,根据可规约的条件(2),必然有vRw或vRv成立,满足要求,否则v≠w,于是有wRv,根据可规约的条件(2),必然有vRv,满足要求.由引理1~3可知,有如下结论成立.定理2.对于任意依赖于表1中公理组合的模态逻辑L以及满足L的限制条件的模型,经过若干次规约后得到的模型仍然满足L的限制,同时对于任意模态公式,若中存在状态w使得,w,则中必然存在状态w使得,w.5.2模型提取根据文献[1]的思想,Tableau算法会为可满足的公式建立一个模型图.这一小节介绍如何从模型图中得到一个规模尽可能小的模型.为了更好地形式化,首先给出通用模型的概念.定义4.通用模型是一个三元组=〈W,R,V+,V-〉,其中〈W,R〉是一个框架,V+和V-都是将命题集合中命题p映射为W的一个子集V+(p)和V-(p)的函数,V+(p)为通用模型中使得p为真的状态集合,V-(p)为通用模型中使得p为假的状态集合,形式化表示为V+:2W,V-:2W,且对于任意命题p∈都满足V+(p)∩V-(p)=.给定命题p和状态w,若wV+(p)∪V-(p),w没有约束命题p,否则若w∈V+(p),则称w正约束命题p,若w∈V-(p),则称w负约束命题p.对于模型=〈W,R,V〉,若对于任意命题p都有V+(p)V(p)和V-(p)∩V(p)=,则称基于.显然,通用模型可作为框架和模型的统一表示,对于给定=〈W,R,V+,V-〉,如果对于任意命题p都有V+(p)∪V-(p),则可视为模型,如果对于任意命题p都有V+(p)=V-(p)=,则可视为框架.下面给出通用模型满足公式的定义.定义5.通用模型中状态w满足公式(记为,w)当且仅当对于任意基于的模型有,w.根据文献[1]的思想,实际上Tableau算法建立的模型图都对应一个通用模型(将模型图作为框架,然后对每个状态上标记的命题施加正约束,对命题的否定施加负约束),同时,中与模型图中第一个被建立的节点对应的状态满足公式.例如,给定=□◇(p∧q)∧□◇(p∧q)∧□◇(p∧q),Tableau演算S4为其建立的模型图对应的通用模型=〈W,R,V+,V-〉如图3(a)所示,其中R为图中关系的自反传递闭包,节点标记的正文字为该节点附加的正约束,节点标记的负文字为节点附加的负约束.显然,w0.一个直观的从通用模型中提取模型的方法是将任一基于该通用模型的模型作为初始模型(也即对通用模型中所有未约束命题进行约束),然后对进行规约得到规模更小的模型.但是,初始模型的不同将导致最后规约得到的模型的不同.下面以为例进行说明.例2.我们使用两种不同方案从图3(a)所示的通用模型中提取模型.第1种方案①是对未约束p或q的状态都附加负约束,最后得到的模型为=〈W,R,V〉,V(p)=V+(p),V(q)=V+(q).对进行规约后得到的模型=〈W,R,V〉如图3(b)所示,其中R为图中关系的自反传递闭包,V(p)={w1,w4},V(q)={w1,w7}.第2种方案是对未约束p或q的状态都附加正约束,则得到的模型为=〈W,R,V〉,V(p)=V+(p)∪{w0},V(q)=V+(q)∪{w0},对进行规约,得到的模型=〈W,R,V〉如图3(b)所示,其中R为图中①实际上这也是文献[1,6]从模型图上构建模型的思想,但是Page8关系的自反传递闭包,V(p)={w1,w4},V(q)={w1,w7}.显然比少了一个状态,事实上,在所有满足的自反传递模型规模最小.由例2可知,给定满足的通用模型,若中状态w未约束命题p,对其附加约束的不同将直接影响到最后生成的模型的规模.由于事先无法预知附加哪种约束更有利于生成规模更小的模型,因此一次性将通用模型转化为模型再进行规约不是明智的做法,我们采取的方法是直接对通用模型进行规约直到不能规约为止,再将最后得到的通用模型附加约束转化成模型.下面给出通用模型中规约的定义.定义6.对于通用模型=〈W,R,V+,V-〉中的两个状态w和v,如果满足如下的条件,则称二者是可规约的:(1)w和v对任意相同命题未施加不同约束,即{p∈|w∈V+(p),v∈V-(p)}={p∈|w∈V-(p),v∈V+(p)}=.(2)若wRw或wRv,令W1={w,v},否则令W1=;若vRw或vRv,令W2={w,v},否则令W2=;我们有W1∪{u|wRu}=W2∪{u|vRu}.对w和v进行规约后得到的模型=〈W,R,V+,V-〉,其中,W=W\{v},R={(u,u)|uRu}∪{(u,w)|uRv},对于任意命题p,若v∈V+(p),则V+(p)=(V+(p)\{v})∪{w},否则,V+(p)=V+(p);若v∈V-(p),则V-(p)=(V-(p)\{v})∪{w},否则,V-(p)=V-(p).命题2.通用模型中的两个状态可规约当且仅当任意基于其的模型中对应状态可规约.证明.由定义1和定义3可知结论显然成立.下面说明通用模型规约的正确性.定理3.任意依赖于表1中公理组合的模态逻辑L,以及满足L的限制条件的通用模型,经过若干次规约后的通用模型仍然满足L的限制,同时对于任意公式,若中存在状态w使得,w,则中必然存在状态w使得,w.证明.任意基于的模型,必然存在一个基于的模型使得对使用从到相同的规约顺序能够得到,因为,w,有,w,根据定理2,同时必然存在某个状态w使得,w,因为的任意性且从到的规约顺序与从到的规约顺序相同,有,w.证毕.对于同一个状态,可能存在多个能与之进行规约的其他状态.为了选择合适的状态进行规约,我们给出算法GReduce(如算法1所示)引导规约过程.对GReduce算法说明如下:算法第2行保证了每次选择进行规约的两个状态中至少有一个状态w满足不存在其他可规约的状态v使得v上施加的正约束和负约束都是w施加的正约束和负约束的子集;第4~8行的作用是为能与w进行规约的每个状态v都计算一个启发值h(v),然后在第9行选择一个启发值最小的状态与w进行规约,这种做法保证了若存在某个状态v使得12,必然有h(v)=0,因此最后被选中与w进行规约的状态v①必然满足{p∈|w∈V+(p)}{p∈|v∈V+(p)}和{p∈|w∈V-(p)}{p∈|v∈V-(p)},也即对w和v进行规约得到的通用模型就相当于直接从原通用模型中抹去了v同时没有对w施加更多的约束,直观看来这是一个好的选择.显然,对于状态有限且每个状态上施加的约束有限的通用模型,GReduce能在多项式时间内终止.读者可以验证,对图3(a)中的通用模型使用GReduce算法后能将其规约至最简.算法1.GReduce().//对通用模型=〈W,R,V+,V-〉进行规约1.whilethereexiststwostatesincanbereduceddo2.Letwbeastatesuchthattheredoesnotexist①因为可能存在多个启发值相同的状态,因而v和v不一定Page93.W··={v|v∈W,visreduciblewithw}4.foreachv∈Wdo5.1··={p|w∈V+(p)orw∈V-(p)}6.2··={p|v∈V+(p)orv∈V-(p)}7.h(v)··=|2\1|×|1\2|8.end-for9.Letvbethestatesuchthath(v)istheleastvalue10.Reducewandv11.end-while由命题2可知,一个通用模型中的两个状态如果不可规约,则任意基于其的模型中对应的状态都是不可规约的.对于任意公式,假设Tableau算法得到的模型图对应的通用模型为,对调用GReduce算法进行规约后得到的通用模型假设为,由于中不存在可规约的状态,因此任意基于的模型中的也不存在可规约的状态.由定义3和定理3可知,任取一个基于的模型必然存在某个状态w使得,w,同时无需再对进行规约.到此时为止,我们完成了模型的提取任务.6实验结果在这一节中,我们给出S4P的实验结果,并与RACER和FaCT++进行了比较.实验的硬件设施如下:CPUP4-2.8GHz,内存480MB.开发环境为MicrosoftVisualC++6.0.S4P和RACER在表2S4P与RACER和FaCT++的比较结果测试用例s4_45_ps4_45_ns4_branch_p17--<0.01210.031988.35213.98s4_branch_n65536655356553542.661548.861382.23632.26s4_grz_ps4_grz_ns4_ipc_ps4_ipc_ns4_md_ps4_md_ns4_path_p364--<0.01210.05894.192113.62s4_path_ns4_ph_p42371--3.04717.05872.36634.16s4_ph_ns4_s5_ps4_s5_n21303714216.68217.692091.241780.61s4_t4p_ps4_t4p_n实验结果表明,对于除s4_branch_n外的其他测试用例,通过模型规约都能明显缩减模型的规模;对于s4_45_p、s4_branch_p、s4_branch_n、s4_ipc_p、WindowsXP下运行,FaCT++在Ubuntu8.04下运行.测试用例为逻辑工作台(LogicWorkBench,LWB)测试集中9类S4公式,每类公式中都分为有效的(valid)和非有效的(invalid)两组,每组包含21个从简单到复杂的公式.我们调用推理机判定公式的否定的可满足性,若公式的否定可满足,则原公式非有效,否则原公式有效.标准的测试方法是让推理机按照公式的求解难度递增顺序对公式逐个进行求解,到100s为止,测试推理机能求解出多少公式的可满足性.在我们的实验中,为了分析S4P对于具体公式产生的Tableau的规模和进行BCP的时间以及模型规约的效果,采用了如下不同的测试方案:按照公式的求解难度递增顺序对公式进行排序,对每个公式限定100s的测试时间,最后给出100s内能求解出的最难公式的编号;对于非有效的公式,其否定是可满足的,我们对满足其否定的模型进行规约.实验数据如表2所示.其中,max为100s内能求解的最难公式的编号,total为该公式的总的求解时间,Tableau为S4P求解对应公式时建立的Tableau的规模,BCP为进行二元约束传播需要的时间,model为与模型图对应的模型的规模,model为规约后的模型的规模.所有的测试时间都精确到0.01s.在表中,若Tableau为0,说明对应公式经过第3节的预处理后已被替换成了⊥或⊥,显然,此时对应的total仅为预处理的时间.s4_md_p、s4_md_n、s4_path_p、s4_path_n、s4_ph_n、s4_t4p_p和s4_t4p_n,S4P的求解效率明显优于RACER,对于s4_ph_p,S4P的求解效率低于Page10RACER;对于s4_branch_p、s4_branch_n、s4_ipc_p、s4_ipc_n、s4_md_p、s4_md_n、s4_path_p、s4_path_n、s4_ph_p、s4_ph_n、s4_s5_p和s4_s5_n,S4P的求解效率明显优于FaCT++;对于s4_ipc_n和s4_path_n,S4P仅需要通过预处理即可判定出对应公式的可满足性,而RACER求解s4_path_n比较困难,FaCT++求解s4_ipc_n比较困难,说明RACER和FaCT++中未使用或者未完全使用S4P中的预处理技术;S4P求解效率相对偏低的公式包括s4_branch_n、s4_md_p、s4_ph_p、s4_ph_n、s4_s5_n,除问题s4_md_p外①,S4P在求解其他4类公式时所生成的Tableau的规模非常大,同时进行二元约束传播的时间占总求解时间中的比例非常大.为了减小S4P求解问题时产生的Tableau的规模,设计启发式函数引导搜索是非常必要的,我们在设计S4P也曾尝试其他推理机中使用的启发式函数,但是效果不明显,这依然是我们将来工作的重点.为了减少二元约束传播的时间,在S4P中已经使用了著名的SAT求解器zChaff中使用的twowatchedliterals技术[18],同时,我们将继续关注SAT求解领域中提出的最新BCP技术.最后,本文利用文献[19]中已有的实验结果对S4P和最新模态推理机InKreSAT以及基于Tableau算法的混合逻辑推理机Spartacus进行了间接对比.文献[19]中实验平台的CPU为Pentium4-2.8GHz,内存为1GB,其使用的测试用例也为LWB测试集中18组S4公式,在测试过程中其为每类公式中单一公式设定最大求解时间60s.由文献[19]中实验结果可知,InKreSAT和Spartacus在规定的时间内能完整求解可满足性的公式的组数分别为10组和13组,而由表2中实验结果可知若将单一问题的最大求解时间同样设定为60s,S4P能在一个具有相同CPU但更小内存的系统上完整求解出15组问题的可满足性,优于InKreSAT和Spartacus.7结语本文提出了两种Tableau算法优化技术———冲突技术和矛盾学习技术,然后结合这两种新技术和三种已在其他推理机中使用的技术实现了模态逻辑S4的推理机S4P.本文在逻辑工作台测试用例上对S4P的效率进行了测试,并与著名的描述逻辑推理机RACER和FaCT++进行了比较,实验结果表明,S4P的推理效率优于二者.最后,本文给出了从Tableau算法生成的模型图中构造一个规模较小的模型的方法,并给出了该方法对于所有依赖于公理D、T、B、4、5的模态逻辑(即K、KT、KD、K4、K5、KB、KDB、B、KD4、K45、KD5、KD45、S4、KB4和S5)的正确性证明.本文对测试用例中非有效公式的否定对应的模型进行规约.实验结果表明,本文提出的规约方法能明显缩减模型的规模.本文未来工作将从如下两点上继续提高S4P的推理效率:设计一个优秀的启发式函数引导搜索;进一步降低BCP时间.致谢感谢DmitryTsarkov,他告诉了我们使用FaCT++判定模态公式可满足性的方法!
