Page1基于时间多栈下推网络的实时系统验证1)(桂林电子科技大学广西可信软件重点实验室广西桂林541004)2)(中国科学院信息工程研究所北京100093)摘要多栈下推网络(MPDN)是利用多个栈来描述并发递归程序线程之间交互的一种下推系统模型.为了描述基于线程之间交互的实时并发递归程序,首先将描述连续时间的时钟引入到MPDN,提出了时间多栈下推网络(TMPDN),并给出了语法及其操作语义;其次利用基于时间关键点的时钟等价优化技术,缩减等价域状态空间;然后通过静态转换方法,获得所有的可达域状态格局,将连续时间的TMPDN模型转换成离散的MPDN模型.在此基础上,基于on-the-fly技术,采用动态转换方法,仅关心栈顶域状态转换,进一步缩减转换后的状态空间.同时证明了状态qF在TMPDN可达当且仅当其转换状态qF在MPDN可达,并给出了模型转换算法;最后可采用现有模型检验工具验证转换后的MPDN.关键词MPDN;TMPDN;并发递归程序;时钟等价;可达性1引言随着多核处理器技术日益发展,并发软件已渗透到国民经济和国防建设的各个领域,然而在某些安全攸关的领域,诸如交通控制和航空航天等领域,软件上的微小错误可能导致重大事故,甚至危及人身安全.如何提高软件系统的可靠性和安全性已成为当前紧迫问题.对于一些安全攸关的实时系统来说,其安全性要求更高,需充分验证软件系统的某些关键性质,这种背景下,对其形式化分析验证显得尤为重要.目前,诸多学者已致力于实时系统分析与验证的研究,为了描述不同类型的实时系统,提出了时间自动机、时间下推自动机、时间递归状态自动机、嵌套时间自动机等理论模型.具体而言,1994年Alur和Dill[1]在自动机的基础上,引入描述连续时间的时钟,提出了时间自动机,并采用时钟等价技术实现模型检验时间自动机[2].为了解决含有递归的实时系统建模,Abdulla等人[3]提出时间下推自动机,并通过时间离散化,将其转换为下推自动机后进行分析,并在文献[4-5]中加入权值,求解最小时间开销的可达性问题;2013年[6]将时间下推自动机的研究对象扩展到无限迁移的实时系统上,同时证明了该情况下的实时系统可达性分析为EXPTIME完全问题;2014年Cai和Ogawa[7]给出了一个时间下推自动机的实例;Trivedi和Wojtczak[8]和Benerecetti等人[9]提出了时间递归状态自动机,通过相互调用来实现递归描述,调用过程中,时钟通过值或者引用的方式传递;2013年Li等人[10]提出了嵌套时间自动机(NeTAs),其整体是一个下推自动机,栈的每一层为时间自动机,利用嵌套的思想来解决实时系统中的递归问题.上述模型能描述实时系统的并发及递归问题,但是无法描述实时并发系统中线程间交互的情况.另外,Atig等人[11-12]给出的序列多栈下推自动机(OMPA),其在栈上增加了线性序列描述线程间交互,并证明了OMPA的可达性为2ETIME完全问题;Torre等人[13-14]给出基于上下文限界的多栈下推系统(SMPDS),并分析及论证了系统可达性为PSPACE完全问题.这一类模型能描述并发递归程序的线程间交互,但不能描述实时性.时间下推自动机相当于在时间自动机上增加了栈,能够有效地解决时间自动机难于描述递归的情况,其缺点是无法很好的描述线程间的交互.为了能对实时并发系统中的递归机制及线程间交互进行建模,本文结合时间下推自动机与多栈下推网络的优点,类似于在时间下推自动机中增加了栈的数目,通过栈之间交互来模拟并发程序运行时线程间操作,提出时间多栈下推网络(TMPDN),并利用多栈下推系统理论来验证实时并发递归程序中的可达性.形式化验证实时系统将可能产生状态空间爆炸问题,从而给验证带来极大困难.当前验证实时系统的主要思想:将实时系统的连续模型转换为不含时间约束的离散模型.离散模型的状态用等价域描述,域等价的基本思想都是把状态位置和时钟区间结合,形成一个新的状态,主要方法是域图(RegionGraph)和带图(ZoneGraph)[15].由于带图生成的符号状态图具有不稳定性,产生的符号状态迁移序列存在不确定性,故本文将采用域图方法.通过基于时钟关键点的时钟域优化等价技术,将TMPDN转换为对并发程序研究较为成熟的MPDN模型.通常时钟域等价使用实数取整、小数部分大小比较来划分时间域.为了获得更少的时钟域,本文采用时钟关键点技术,对时钟域划分进行优化,从而缩减转换后的模型状态空间.为了进一步缩减转换后的MPDN状态空间,在静态转换的基础上,采用on-the-fly技术,给出了仅关心栈顶及其下一层的动态转换方法,状态空间仅于栈顶及其下一层的项集相关,而与整个项集无关,从而大幅度缩减转换后的状态空间.本文第2节介绍相关基础知识;第3节提出TMPDN模型;第4节从静态和动态两个角度分析TMPDN转换为MPDN的转换过程;第5节证明TMPDN与转换后的MPDN可达性等价;第6节给出TMPDN转换为MPDN的具体算法;第7节为TMPDN的上下文限界验证;第8节给出一个具体实例分析;第9节为全文总结.Page32基础知识MPDN模型是一种描述并发递归程序的下推系统,利用栈之间的操作来模拟程序中线程间的交互.MPDN是一个五元组M=(n,Q,q0,Γ,Δ),其中n∈瓔表示系统栈的数量,Q表示有限状态集,q0∈Q表示初始状态,Γ表示有限栈内字符集,Δ=ΔintΔpushi∪Δpopi(Q×Q)描述第i个栈的内部转换,Δpushn,Δinti(Q×Γ×Q)表示第i个栈的压栈和出栈.为Δpop了描述方便,文中用[n]表示1到n的集合.MPDN格局C=〈Work[n],q,{ωi}i∈[n]〉,其中Work[n][n]为[n]的子集,表示当前工作栈集,q∈Q表示状态,ωi∈(Γ)表示第i个栈的栈内字符集,C0=〈Work[n],q0,{ωi}i∈[n]〉表示MPDN的初始格局.第i个栈的格局转换描述〈Work[n],q,{ωi}i∈[n]〉→作δ包括空操作nop、压栈操作push(γ)和出栈操作pop(γ),格局转换成立当且仅当满足以下条件:(1)Δ=Δint[n],表示内部转换,描述状态迁移而栈内字符未发生改变.(2)Δ=Δpushωi=γ.ωi,ωj=ωj,j∈[n\i],表示当前栈i压栈时,其栈内字符新增栈符γ,其他栈的栈内字符未变化.(3)Δ=Δpopγ.ωi,ωj=ωj,j∈[n\i],表示当前栈i出栈时,其栈内字符删除了栈符γ,其他栈的栈内字符未变化.一个上下文定义为在单一线程中的计算或变迁序列.栈i的一个上下文可表示成∏=C0t1C1t2…tmCm,其中t1…tm∈Δi.计算从一个线程切换至另一个线程,定义为上下文切换.用∏i和∏j分别表示栈i,j上的上下文,两者发生上下文切换用∏i·∏j表示.当上下文切换限制为k时,称之为上下文k限界.3时间多栈下推网络(TMPDN)为了描述实时系统中并发递归机制以及线程之间的交互,在MPDN的基础上引入了时钟,提出了TMPDN模型.时钟是在正实数范围内取值的变量.定义1.给定时钟集T以及时钟t1,t2∈T,则在T上的时钟约束定义为σ·σ∧σ,其中c∈瓗,∈{<,}.时钟解释v:T→瓗+,表示时钟t∈T在当前的取值.假设实数c∈瓗,v(t)+c表示解释后的时钟值加c,在没有歧义的情况下,用v+c表示.定义2.TMPDN是一个六元组MT=(n,Q,q0,Γ,T,Δ),其中n表示系统中栈的个数;Q表示有限状态集;q0表示初始状态;Γ表示有限栈符集;T=TG∪TL表示有限时钟集,其中TG表示全局时钟,用于标识实时并发系统中全局变量或事务的时间,TL表示栈内局部时钟,用于标识系统中局部变量或子事务的时间;迁移关系Δ2[n]×Q×TG×(Γ×TL)×2[n]×Q×TG×(Γ×TL)为描述系统格局的迁移.TMPDN的格局C=〈Work[n],q,{wi}i∈[n],v〉,其中q∈Q,Work[n][n]为[n]子集,表示当前工作栈集,wi为栈i的字,表示栈i的内容,描述为wi∈(Γ×瓗+),v表示时钟当前取值.TMPDN作为实时并发程序的模型,能描述多个栈同时产生迁移,迁移关系Δ分为栈内迁移Δin、栈间切换Δinter和并发执行Δ‖.为了表述方便,首先讨论一个栈i内迁移的执行,用形式〈{i},q,{wi}i∈[n],v〉opin为栈内迁移的动作集,包括空操作nop、时间约束判断t∈I?、时钟重置t←I、时间流逝Time←c、压栈操作push(a,I)和出栈操作pop(a,I),其中I表示时钟取值范围,t∈T,故栈内迁移关系Δin可表示为Δnop∪Δ?,Δ=,Δ├,Δpush,Δpop分别表示上述操作的迁移.下Δ文根据不同的栈内迁移动作opin给出其执行含义.(1)Δin=Δnop:opin=nop,wi=wi,v=v,表示格局内元素未发生变化.(2)Δin=ΔI,表示当t的时钟值在I范围内时,执行该操作,格局内元素未发生变化.(3)Δin=Δ=:opin=t←I,wi=wi,v=v[t←c],c∈I,表示给时钟t指定I范围内的任意值c,其他格局内元素未发生变化.(4)Δin=Δ├:opin=Time←c,wi=w+cwi=〈a1,v1〉〈a2,v2〉…〈an,vn〉,那么w+cv1+c〉〈a2,v2+c〉…〈an,vn+c〉,v=v+c,表示格局内所有时钟增加c,格局内非时钟内容未发生变化.(5)Δin=Δpush:opin=push(a,I),wi=w·Page4c∈I,v=v,表示将变量a压入栈顶,并设定相应时钟为c,其时钟值为I范围内的任意值.(6)Δin=Δpop:opin=pop(a,I),wi=w·c∈I,v=v.表示将栈顶内时钟值为I范围的变量a弹出.其次描述栈间切换Δinter.假设栈间切换操作opinter=ij表示栈i切换到栈j,表示形式为〈{i},q,{wi}i∈[n],v〉q,q∈Q;v=v;wi,wj分别表示栈i,j的字,i,j∈[n]且i≠j.上下文切换时,将栈j从等待栈切换到工作栈,同时将栈i从工作栈切换到等待栈,则切换后的工作栈Work[n]=Work[n]\{i}∪{j}.最后描述并发操作Δ‖.假设op=opin∪opinter为栈迁移动作集,并发执行用形式〈Work[n],q,图1TMPDN中栈内操作下的格局迁移(1)并发操作.从格局C0到格局C1,将ci压入栈i,且时钟赋值为2.7∈[26),同时将cj压入栈j,且时钟赋值为2.7∈[26).(2)时钟重置.从格局C1到格局C2,时钟t1的时钟值重置为7.5∈[610).(3)时间流逝.从格局C2到格局C3,栈内所有全局时钟、全局变量相关联的时钟、局部变量相关联的时钟,其时钟值都增加3.8个时间单位.(4)出栈操作.从格局C3到格局C4,在出栈操作前,检查cj值是否属于区间[610),由于cj=6.5满足条件,则执行出栈操作.4TMPDN的模型转换分析因TMPDN的时钟取值为正实数域,故在求解可达状态格局时,可能会出现状态空间爆炸问题,从而使可达性分析变得异常困难.为了分析TMPDN{wi}i∈[n],v〉{wi}i∈[n],v〉表示,Work[n]为当前工作栈集,如果不发生栈间切换,则Work[n]=Work[n],如果发生栈间切换ij,则Work[n]=Work[n]\{i}∪{j}.其他类似一个栈的情况.为了进一步理解栈的迁移关系,通过实例描述入栈、出栈、时间重置、时间流逝和并发的动作,如图1所示.假定有n个栈,全局时钟t1,全局变量g,其相关联时钟为tg,{a1,b1,ai,bi,ci,aj,bj,cj}Γ,其中i,j∈[n],时钟区间分别表示为[vi:vj],[vi:vj),[vi:),其中[vi:vj]表示vi到vj区间内(包含vj)的所有时钟值,[vi:vj)表示vi到vj区间内(不包含vj)的所有时钟值,[vi:)表示vi到无限大的所有时钟值.的可达性,本文利用时钟等价技术将无限状态格局抽象转换为有限状态格局,也就是说将TMPDNMT=(n,Q,q0,Γ,T,Δ)转换为MPDNMM=(nM,QM,qM4.1域0,ΓM,ΔM).把TMPDN转换为MPDN,最主要的问题是把TMPDN中的栈符以及描述栈符的时钟抽象为MPDN的栈符集.为了描述转换后的栈符集,需把TMPDN的时钟和栈符转换为域,转换后的域用符号R表示.域R是由时钟关键点和项集组成,首先定义时钟关键点及时钟等价,然后定义项集.为了把描述连续时间的TMPDN转换为离散的MPDN,采用离散的时钟区间描述连续时间.Alur和Dill[1]在1994年提出时钟等价技术,采用连续正整数作为时钟区间划分.因实时系统动作迁移及事件通常在关键的时间点触发,时钟关键点是非连续正整数,与原时钟等价技术相比,甚至减少一、Page5两个数量级,并在多个时钟的情况下,划分的等价区域将减少几个数量级.基于此,本文给出了优化的时钟等价技术,依据时钟关键点作为时钟区间划分的界限,减少时钟区间划分区域,从而达到缩减等价后的状态空间.时钟关键点为系统动作迁移及其他事件的时间触发点,用ki表示MT时钟上的关键点,kmax表示时钟关键点上限阈值,k>kmax表示所有大于kmax的值,时钟关键点集合可描述为key={0,k1,…,ki,…,kmax,k}.为了描述时钟等价,实数时钟值t=t+re(t)分成两个部分,关键点部分t:实数时钟值向下取最近关键点的值;剩余部分re(t):re(t)=t-t.给定时钟集T,假设有任意两个时钟ti,tj∈T,并且存在关键点key={0,k1,…,ki,…,kmax,k}.当满足如下规则的时钟值,为等价时钟:(1)v(ti)>kmax当且仅当ti=k,即ti的时钟值大于关键点上限阈值时,ti取无穷大k.(2)kiv(ti)<ki+1当且仅当ti=ki,即ti的时钟值小于关键点ki+1且大于等于ki时,ti取关键点ki.(3)假定ti=ki,tj=kj,v(ti)-ki<v(tj)-kj当且仅当re(ti)<re(tj),即ti取关键点ki,tj取关键点kj,当ti的时钟值与关键点ki的差值小于tj的时钟值与关键点kj的差值时,记为re(ti)<re(tj).假设时钟集T,有任意两个时钟ti,tj∈T和key={0,k1,k2,…,k},在(0<ti<k1,k1<tj<k2)区域内,基于时钟关键点的时钟域等价规则,在ti=0,tj=k1,且re(ti)<re(tj)这区间内的时钟值为等价时钟,如图2所示的阴影部分.下面描述域R的另一部分———项集.普通项集Y包含:(1)时钟T,T用来描述MT的全局时钟;(2)栈字符Γ,Γ用来描述MT的栈顶字符;(3)基础时钟字符├,用来描述栈的基础时钟,是栈内域中其他项的时间参照点,初始值为0;故普通项集Y描述为Y=T∪Γ∪{├}.标识项集Y·表示普通项Y的时|a∈Γ},├间流逝,在普通项上添加上标阴影·的方式表示,描述为Y·=T·{a·要用于动态转换,当时间流逝时,非栈顶域中的时钟无法随时间流逝进行更新,故在栈顶域中增加├记录时间的流逝,当栈顶域进行出栈操作时,对栈顶下一层域中的时钟进行同步更新.TMPDN模型转换为MPDN可采用两种方法:静态转换和动态转换.使用静态转换时,项集Z为普通项集Y,即Z·为普通项集Y和标识项集Y·的并集,即Z·Y·.假定栈i,栈深度为d,域Ri=Ri1…Rij…Rid∈(2Z×key)+,其中i∈[n],j∈[d],Rij=〈zj,kj〉,zj∈Z,kj∈key,从而可得域R={Ri}i∈[n].域Ri存在,当且仅当域Ri中包含以下3类:(1){|〈Γ,key〉∩Ri|=1}∧{|〈Γ1},表示域Ri与普通栈符和标识栈符的交集非空,换而言之,域Ri中一定存在普通栈符和标识栈符;(2){|〈├,key〉∩Ri|=1}∧{|〈├1},表示域Ri与├和├Ri中一定存在├和├(3){|〈T,key〉∩Ri|=1}∧{|〈T·,key〉∩Ri|=1},表示域Ri与时钟字符和时钟标识符的交集非空,换而言之,域Ri中一定存在时钟字符和时钟标识符.4.2TMPDN转换为MPDN为了描述TMPDN模型转换为MPDN,通过上节给出的时钟等价优化技术,把MT栈符及记录栈符的时钟等价为域,表示MM的栈符.TMPDN与MPDN的转换分为静态转换和动态转换两种,其中静态转换是把TMPDN模型整体抽象转换为MPDN模型,获得所有可达的域状态格局,在每个抽象状态格局中,栈的每一层都需抽象域描述,故构造过程,其状态空间及时间耗费都较为庞大;而动态转换采用on-the-fly技术,无需整体计算抽象MPDN模型,而是依据TMPDN模型的状态迁移过程,动态计算与其等价的MPDN域状态,并且只关注栈顶层及其下一层,不关心整个栈内容,因此降低了转换状态空间规模及时间耗费.由于动态转换仅对栈顶域操作,故需增加基础时钟字符和标识项,在非栈顶域成为栈顶域时对时钟值正确更新,跟静态转换相比,增加了额外更新操作.MM的栈间切换Δinter与MT类似.MT的并发操作Δ‖转换时,工作栈集Work[n]内的每个栈,调用栈内迁移转换.Page64.2.1静态转换假定模型TMPDNMT=([n],Q,q0,Γ,T,Δ),通过静态转换获得的模型MPDNMM=([n]M,QM,0,ΓM,ΔM),具体转换如下:qM(1)栈个数[n]M的转换.[n]M=[n],即MM的栈数量与MT的栈数量相等.(2)状态QM的转换.QM=Q,即MT的状态集与MM的状态集相同.(3)初始状态qM状态与MT的初始状态相同.(4)栈字符ΓM的转换.ΓM=2Z×key,其中Z为普通项集Y,即Z·(5)迁移关系Δ到ΔM的转换规则.图3MT的格局静态转换为MM的格局(1)Δ=Δnop时,op=nop,如果〈{i},q,{wi}i∈[n],p〈{i},q,{wi}i∈[n],v〉∈Δ,那么在MM中有no→v〉〈{i},q,{Ri}i∈[n]〉对应,即两者nop操作相同.(2)Δ=ΔΔM?与Δ{Ri}i∈[n]〉示MM域R中任意子域,迁移关系ΔM?表示在{Ri}上进行判断操作.(3)Δ=Δ=时,op=t←I,在MM中有迁移关系ΔM=与Δ=相对应,此时MM的格局迁移为〈{i},q,{Ri}i∈[n]〉ΔM=表示在对{Ri}进行t←v(t)赋值操作,v(t)∈I为MT赋值时钟值,v(t)为赋值时钟值在时间域等价后的关键点,t∈Z为项内字符,t←v(t)表示将关键点v(t)赋值给字符t.(4)Δ=Δ├时,op=Time←c,在MM中有迁移关系ΔM├与Δ├相对应,此时MM的格局迁移为〈{i},q,{Ri}i∈[n]〉MT的格局迁移为〈{i},q,{wi}i∈[n],v〉〈{i},q,{wi}i∈[n],v〉∈Δ,wi∈(Γ×瓗+)称为栈i的字,设di为栈i的栈深度,用wij表示栈i内第j层的子字,j∈[di],wij|Γ表示wij投影在Γ的栈字符,v(wij|Γ)表示投影与栈字符Γ相关联的时钟值,v(wij|Γ)表示投影与栈字符Γ相关联的时钟值在时钟域等价后的关键点,TG为全局时钟,v(TG)表示全局时钟的时钟值在时钟域等价后的关键点,则可得wij在MM中等价项Rij=((wij|Γ)×v(wij|Γ))∪(TG×v(TG))∈ΓM,栈i内容Ri=Ri1…Rij…,其中i∈[n],j∈[di].从而可知对应于MM的格Ridi局迁移为〈{i},q,{Ri}i∈[n]〉→其中q,q∈QM,δ为迁移动作.如图3所示.表示在对{Ri}中所有字符的时钟值增加c后取关键点,对任意i∈[n],Rij=((wij|Γ)×v(wij|Γ)+c)∪(TG×v(TG)+c),Ri=Ri1…Rij…Rid,v(wij|Γ)+c表示投影出的栈字符Γ的时钟值增加c,v(TG)+c表示全局时钟的时钟值增加c.(5)Δ=Δpop时,op=pop(a,I),在MM中有迁移关系ΔMpop与Δpop相对应,此时MM的格局迁移为〈{i},q,{Ri}i∈[n]〉关系ΔMpop表示关键点等于v(a)的字符a∈Γ出栈,Rij=((((wij|Γ)-a)×v((wij|Γ)-a))∪(TG×v(TG))),Ri=Ri1…Rij…Rid,((wij|Γ)-a)表示在投影出的栈字符Γ内删除字符a.(6)Δ=Δpush时,op=push(a,I),在MM中有迁移关系ΔMpush与Δpush相对应,此时MM的格局迁移为〈{i},q,{Ri}i∈[n]〉移关系ΔMpop表示关键点等于v(a)的字符a∈(Γ∪T)入栈,Rij=((((wij|Γ)+a)×v((wij|Γ)+a))∪(TG×v(TG)))∨(((wij|Γ)×v(wij|Γ))∪((TG+a)×v(TG+a))),Ri=Ri1…Rij…Rid,((wij|Γ)+a)Page7表示在投影出的栈字符Γ内增加字符a,(TG+a)表示在全局时钟内增加字符a的时钟.(7)Δ=Δinter时,在MM中有迁移关系ΔMinter与Δinter相对应,此时MM的格局迁移为〈{i},q,Ri}i∈[n]〉分别为栈i,j的域,i,j∈[n]且i≠j.上下文切换时,将栈j从等待栈切换到工作栈,同时将栈i从工作栈切换到等待栈.(8)Δ=Δ‖时,在MM中有迁移关系ΔM‖与Δ‖相对应,此时MM的格局迁移为〈Work[n],q,{Ri}i∈[n]〉Work[n]内的每个栈,调用相应的栈内迁移转换,转换后格局为〈Work[n],q,{Rj}j∈[n]〉.4.2.2动态转换假定模型TMPDNMT=([n],Q,q0,Γ,T,Δ),使用动态转换获得的模型MPDNMM=([n]M,QM,0,ΓM,ΔM),具体转换如下:qM(1)栈个数[n]M、状态QM、初始状态qM分别等同于静态转换.(2)栈字符ΓM的转换:ΓM=2Z×key,其中Z·Y∪Y·,增加了标识项以及基础时钟字符,key为时钟关键点集.(3)迁移关系Δ到ΔM的转换规则.MT的格局迁移为〈{i},q,{wi}i∈[n],v〉图4MT的格局动态转换为MM的格局(1)Δ=Δnop时,op=nop,在MM中有ΔMnop与Δnop对应,ΔMnop=Δnop为空操作.(2)Δ=Δ相对应,此时MM的格局迁移为〈{i},q,Ri〉pop(Rid→〈{i},q,{wi}i∈[n],v〉∈Δ,wi∈(Γ×瓗+)为栈i的字,设di为栈i的栈深度,用wij表示栈i内第j层的子字,widiwij投影在Γ的栈字符,v(wij|Γ)表示投影与栈字符Γ相关联的时钟值,v(wij|Γ)表示投影与栈字符Γ相关联的时钟值在时钟等价后的关键点,TG为全局时钟,v(TG)表示全局时钟的时钟值在时钟域等价后的关键点.由以上设定,则可得RidiRidi=((widi|Γ)×v(widi|Γ))∪((wi(di-1)|Γ)·×v(wi(di-1)|Γ))∪(TGdi×v(TGdi(├度,(wi(di-1)|Γ)·表示对wi(di-1)投影在Γ的栈字符的标识字符,TGdi示域Ridi时间流逝字符,v(├逝的时钟值在时钟域等价后的关键点,栈i内容Ri=Ri1…Rij…Rididi×v(├·知对应于MM的格局迁移为〈q,{Ri}i∈[n]〉→{Ri}i∈[n]〉,其中q,q∈QM,δ为迁移动作,为了描述方便,格局迁移时的中间状态用qtmp()表示,如qtmp(Ridi入栈时分别用pop(),push()表示,如pop(Ridipush(Ridi所示.〈{i},q,Ri〉,格局迁移解释为:首先将栈顶域Ridi栈,转入状态qtmp(Ridi断后,再将Ridi中栈内字符并未改变.(3)Δ=Δ=时,op=t←I,在MM中有迁移关系ΔM=与Δ=相对应,此时MM的格局迁移为〈{i},Page8→q,Ri〉push(Rid→系ΔM=表示对{Ri1}进行t←v(t)赋值操作,v(t)∈I为MT赋值时钟值,v(t)为赋值时钟值在时钟域等价后的关键点,t为Ridi者全局时钟,t←v(t)表示将关键点v(t)赋值给字符t.Ridiv(t)].对任意i∈[n],Ridi=(((widi|Γ)×v(t))∪(TGdi×v(TGdi(((widi|Γ)×v(widi|Γ))∪(TGdi×v(t))∪(├di×0)∪(├域Ridi时钟或者全局时钟t,赋予I中任意一个值对应的关键点v(t),之后再将Ridi状态q.出栈,转入状态qtmp(Ridi(4)Δ=Δ├时,op=Time←c,在MM中有迁移关系ΔM├与Δ├相对应,此时MM的格局迁移为〈{i},[t←v(t+c)],t为Ridiq,Ri〉push(Rid→系ΔM├表示在对{Ri}中所有字符的时钟值增加c后取关键点,RidiRidi对任意i∈[n],Ridi=((widi|Γ)×v(widi|Γ)+c)∪(TGdi×v(TGdic).格局迁移解释:首先栈顶域Ridiqtmp(Ridi增加时钟值c后取关键点,再将Ridi栈,最后获得状态q.(5)Δ=Δpop时,op=pop(a,I),在MM中有迁移关系ΔMpop与Δpop相对应,此时MM的格局迁移为〈{i},q,Ri〉pop(Ri(dRi(di-1))〉Ri(di-1)+(Ridi+Ri(di-1)))〉,其中(Ridi+Ri(di-1))为Ridi点等于v(a)的字符a∈Γ出栈,(Ridi+Ri(di-1))=((widi|Γ-a)×v(widi|Γ-a))∪(TGdi×v(TGdi(wi(di-1)|Γ×(v(wi(di-1)|Γ)+v(├(v(w·v(├i(di-1)|Γ)+v(├)))∪(├×0),其中((widi|Γ)-a)表示投影出·di栈i的栈顶子字widi符.当MM栈顶域的项内字符出栈时,其下一层域的项内字符的时钟需考虑相对时间流逝情况.格局迁移解释为:首先栈顶域Ridi将下一层域Ri(di-1)出栈,转入状态qtmp(Ridi最后将Ridi转入状态q.组合域构造规则:栈顶域Ridi栈时,需将RidiRi(di-1)).①将Ridia、全局时钟TGdiv(TGdi②将Ri(di-1)中所有非全局时钟(普通栈内字符wi(di-1)|Γ、普通栈内字符的标识字符w·础时钟流逝字符├组合域中,其关键点需在原来的时钟值上增加时间流逝,时间流逝为栈顶域Ridi到组合域时,其关键点分别为(v(wi(di-1)|Γ)+v(├v(├·)),(v(w·di·)),0.di为进一步描述组合域构造规则,通过一个实例来说明,如图5所示,图5(a)中R2的普通项栈内字符、基础时钟字符以及全局时钟〈├,0〉、〈x,2〉、〈y,5〉、·,5〉、〈x·,ω〉在〈c,6〉出栈后保持不变,R1中的非〈y全局栈字符〈a·,5〉、〈b·,3〉、〈├增加时间流逝(R2中〈├〈a·,ω〉、〈b,ω〉、〈├如图5(b)中的R1.(6)Δ=Δpush时,op=push(a,I),MM中有迁移关系ΔMpush与Δpush相对应,此时MM的格局迁移为idi|Γ×v(widi|Γ))∪(TGdi×v(TGdi〈{i},q,Ri〉push(Rid〈{i},q,(Ri+Ridi于v(a)的字符a∈Γ入栈,Ridi=(a×v(a))∪(w·v(TGdi示新入栈的字符及其关键点,w·表示将栈顶域Ridi符,其关键点不变化,T·域Ridi化,├·×0表示将栈顶域RidiPage9图5Δpop格局迁移转换实例为标识字符,其关键点为零.格局迁移解释为:首先将栈顶域Ridi字符a的域Ridi用实例进一步说明ΔMpush迁移操作,如图6所示,域R1为〈b,4〉入栈前的栈顶域,R1中的普通项包含基础时钟〈├,0〉、全局时间〈x,1〉、栈内字符〈a,2〉,在〈b,4〉入栈后,R1中的普通项被·标识成标识项·,0〉、〈x·,1〉、〈a·,2〉,同时保留〈├,0〉、〈x,1〉,〈├最终结果为新的栈顶域R2.(7)Δ=Δinter时,转换过程与静态算法类似.(8)Δ=Δ‖时,转换过程与静态算法类似,但是工作栈集Work[n]内的每个栈,调用的栈内迁移转换为栈内动态转换.5可达性等价的正确性给出TMPDNMT=([n],Q,q0,Γ,T,Δ),根据转换规则,可构造出MPDNMM=([n]M,QM,qMΓM,ΔM),并参考文献[16],证明状态qF在TMPDN可达当且仅当其转换状态qM表明其转换的正确性.定义3.给定MT,假设MT的初始格局C0=〈q0,{wi}i∈[n],v0〉,其中q0∈Q表示初始状态,wi为栈i的字,表示栈i的初始内容,描述为wi∈(Γ×瓗+),v0表示初始时钟值.目标格局CF=〈qF,{wj}j∈[n],vF〉,如果存在格局迁移关系C0→CF,其中→表示经过一步或者多步迁移关系,那么称状态qF在迁移系统中可达.设R=R0…Rn是MM域集合,域R0,R1∈R,Δ为域R上的迁移关系集,并且Δ是满足自反性、非对称性、传递性的偏序关系,那么如果R0经过Δ迁移到R1,并且Δ是严格偏序关系,则R0,R1的关系记为R0R1,如果R0经过Δ迁移到R1,并且Δ是非严格偏序关系,则R0,R1的关系记为R0R1.对于域R,如果RiRi+1,0in,则称R为相关域,如果RiRi+1,0in,则称R为弱相关域.如果R为(弱)相关域,则称MM的格局C=〈q,R〉为(弱)相关格局.设R=R0…Rn为弱相关域,域R=R0…Rn为相关域,如果Rn=Rn、Ri∈R++经时间流逝之后生成的域集,称为Ri的时间迁移域)、且RiRi+1,0in,则称域R是域R的强相关域.设MM的相关格局C=〈q,R〉,且域R是R域的强相关域,则称C=〈q,R〉为C的强相关格局.定理1.对于TMPDN任意一个格局CT,通过时钟域等价转化,在MPDN都存在与之对应的格局CM.证明.设MM的一个格局CM=〈qM,RM〉,MT的一个格局CT=〈qT,{wi}i∈[n],v〉,S={wi}i∈[n]∪v为MT此刻字和时钟集合,S经过时间域转换成R,wi=〈a1,v1〉〈a2,v2〉…〈an,vn〉,R=R0…Rn,下面表达式成立.Page10(1)qM=qT;(2)((wij|Γ)×v(wij|Γ))∈Riffwij∈S;(3)(TG×v(TG))∈Riffv∈S.当前仅当CTSCM,即对于MT任意一个格局CT,通过时间域等价技术转化后,在MM都存在与之对应的格局CM.定理2.如果目标状态qF在MM可达,那么存在一个正则可达格局CM(qF为格局CM的状态),且可达格局CM为弱相关格局,则可得如下结论:至少存在一个与CM对应的强相关格局CM=〈q,R〉.证明.假设MM中存在一个可达目标状态qF,显然在MM存在一个可达格局CM=〈qF,R〉.再证明MM中所有可达格局都是弱相关,假设MM存在一个弱相关域R=R0R1…Rn,域R经过迁移得到域R=R0R1…Rn,因Rn-1Rn,Rn∈R++此时称R为弱相关域,因此由R构成的MM中所有可达格局都为弱相关.最后证明至少存在一个与CM对应的强相关格局CM=〈q,R〉,假设存在域R=R0R1…Rn,满足Rn=Rn,Ri∈R++Ri+1,那么称R是R的强相关域,因此R构成的强相关格局CM=〈q,R〉一定存在.为了证明可达性的等价,引入如下两个定律[16].定律1.对于属于MM的任意一个正则可达格局CM,都有与之对应的强相关格局CM=〈q,R〉,此时在MT中一定存在S,且必定存在与S对应的格局CT,满足上述条件后则存在CTSCM且Cinit→CF.定律2.对于属于MT的任意一个格局CT,在MM中必定存在与之对应的格局CM,此时CM至少存在一个强相关格局CM=〈q,R〉,并且存在域R的转换集合S,满足上述条件后则存在CTSCM并且CMinit→CM定理3.状态qF在MT可达当且仅当qF的转换状态qF在MM可达.证明.先证后向蕴涵关系:状态qF在MT可达其转换状态qF在MM可达.由定理2和定律1可知,如果MM中存在一个正则格局CM,则必定存在一个强相关格局CM和转成域R的转换集合S,那么MT中必定存在与CM对应的格局CT,则存在CTSCM并且Cinit→CF,即状态qF(qF为格局CT的状态)在MT可达.再证前向蕴涵关系:状态qF在MT可达其转换状态qF在MM可达.如果目标状态qF在MT是可达,由定理1可知在MM中必定存在与CT对应的格局CM(qF为格局CM的状态),因此至少存在一个强相关格局CM=〈q,R〉.由定律2可知,对于MT中的格局CT,必定存在一个强相关格局CM和转成域R的转换集合S,从而必定存在与CM对应的格局CM,满足上述条件则存在CTSCM并且CM为格局CT的状态)在MM可达.因此,状态qF在MT可达当且仅当其转换状态qF在MM可达.6可达性等价算法基于时钟等价、静态转换和动态转换思想,提出了针对于时间多栈下推网络TMPDNMT=([n],Q,q0,Γ,T,Δ),转换为对应的多栈下推网络MPDNMM=([n]M,QM,qM是连续的TMPDN迁移系统,输出是离散的MPDN迁移系统.迁移系统MT的初始格局为C0=〈{i},q0,{wi}i∈[n],v0〉,其中q0表示初始状态,{wi}i∈[n]表示栈i的初始内容为空,v0表示初始时钟值,其值初始为0.转换算法分为静态算法和动态算法,根据各自的转换规则逐步进行,首先初始化工作线程列表以及域内项,再依据转换类型相应的执行静态算法、动态算法以及栈间操作和并发迁移算法.算法1中的第1,2行为整体算法的初始化,首先初始化工作线程列表worklist,将格局〈{i},q0,{wi}i∈[n],v0〉保存至worklist中,然后初始化域R,初始域Rinit由全局时钟、栈底标识符bottom以及基础时钟字符组成,最后将迁移迁移关系〈q0,push(Rinit),q0〉放入迁移关系集ΔM中.第3行为枚举静态算法与动态算法,第4,5行为静态算法判断执行部分,第6,7行为动态算法判断执行部分,第8至10行为算法结束条件.算法1.时间多栈下推网络转化为多栈下推网络.输入:时间多栈下推网络MT=(n,Q,q0,Γ,T,Δ)输出:对应的多栈下推网络MM=(nM,QM,qM1.初始化工作线程列表worklist←(q0,{wi}i∈[n],v0),其2.MOVE(q0,push(Rinit),q0)INTOΔM//其中q0为MM的初始控制状态位,并且把迁移关3.ENUMAlgType{Algstatic,Algdynamic}Atype;//枚举算法类型Page114.IF(Atype==Algstatic)//判定选择的算法类型,并执行该算法5.Algstat();6.ELSE(Atype==Algdynamic)7.Algdyna();8.FORALLΔΔ//设Δ为迁移关系集合Δ里的任意一个迁移关系,9.WHILEΔ≠DO10.REMOVEΔFROMΔ静态转换和动态转换算法分别如算法2和算法3所示,两者依据MT中不同的迁移关系Δ在MM中作出相应的转换,将MM中相应的迁移关系压入到迁移关系集ΔM中.静态转换时分为栈内迁移转换、栈间操作以及并发迁移转换3类,其中栈内迁移转换是两个模型中栈层间的一一对应转换,如算法2中的第2至17行,栈间操作为上下文切换操作,如算法2中的第20至21行,等同于MT中切换操作,并发迁移转换为工作栈集Work[n]内同时调用栈内迁移转换,如算法2中的第22至24行,动态转换同样分栈内迁移转换、栈间操作以及并发迁移转换3类,其中栈内迁移转换只对MM模型栈顶及其下一层栈的栈内字符分析讨论,如算法3中的第2至17行,在转换过程中需增加中间状态qtmp(),如状态〈qtmp(Ridi换与静态算法类似.算法2.静态算法.输入:MT的迁移关系输出:MM的静态迁移关系1.Algstat(){2.Alginstat(){//栈内迁移转换3.SWITCH(Δ){4.CASEΔ=Δnop://空操作,对应MM状态和域5.6.CASEΔ=Δ7.8.CASEΔ=Δ=://时间重置操作,对{Ri}进行t←9.10.CASEΔ=Δ├://时间流逝操作,在对{Ri}中11.12.CASEΔ=Δpop://出栈操作,关键点等于13.14.CASEΔ=Δpush://入栈操作,关键点等于15.16.}17.}18.Algstatconcur(){19.SWITCH(Δ){20.CASEΔ=Δinter://栈间操作,从i号工作栈切21.22.CASEΔ=Δ‖://并发迁移,迁移关系ΔM‖与23.24.25.}26.}27.}算法3.动态算法.输入:MT的迁移关系输出:MM的动态迁移关系1.Algdyna(){2.Algindyna(){//栈内迁移转换3.SWITCH(Δ){4.CASEΔ=Δnop://空操作,对应MM状态和域5.6.CASEΔ=Δ7.8.CASEΔ=Δ=:/重置操作,对{Ri}进行t←v(t)Page129.10.CASEΔ=Δ├:/时间流逝操作,在对{Ri}中11.12.CASEΔ=Δpop//出栈操作,关键点等于v(a)13.14.CASEΔ=Δpush//入栈操作,关键点等于v(a)15.16.}17.}18.Algdynaconcur(){19.SWITCH(Δ){20.CASEΔ=Δinter://栈间操作,从i号工作栈切21.22.CASEΔ=Δ‖://并发迁移,迁移关系ΔM‖与Δ‖23.24.25.}26.}27.}上述算法是可终止的.设计静态转换算法时,首先根据静态转换规则,将算法分为栈内迁移转换Alginstat()和并发转换Algstatconcur()两部分,其中算法Alginstat()依据不同的迁移规则调用相应的执行操作,算法Algstatconcur()包含了栈间操作和并发迁移,在运行并发迁移算法时需调用算法Alginstat().静态转换算法的时间复杂度与栈深度、栈数量、算法转换时的系统状态集、格局迁移关系集以及时钟集等元素有关,在最坏情况下,算法时间复杂度与项元素集合以及关键点集合的笛卡尔积大小呈指数关系,具体可表示为O(([n]×d)|Q||Δ||MT|2Z×key),其中[n]×d是时间多栈下推系统中栈的数目与栈深度的乘积,|Q|是时间多栈下推系统状态集的大小,|Δ|是格局迁移关系的个数,|MT|是时间多栈下推系统的大小,Z×key为项元素集合与关键点集合的笛卡尔积.然而在实际检验过程中,由于一般情况下转换后存在不可达等价状态,以及因某些时刻栈并不包含所有项元素集合,存在合并状态,故其时间复杂度小于O(([n]×d)|Q||Δ||MT|2Z×key).动态算法设计思路与静态算法类似,但其转换时只对栈顶操作,与栈深度无关.因动态转换只关心栈顶层及其下一层域状态空间,故等价区域空间比静态转换算法缩减很多.假设栈顶项元素最大集合为Max(Ztop),理论上最坏情况下其时间复杂度为O([n]|Q||Δ||MT|2(Max(Ztop7TMPDN的上下文限界验证对并发程序形式化验证时,若每个线程建模成一个有限状态系统,整个程序的状态空间将呈指数增长,其可达性判定为PSPACE-hard.若建模成下推系统时,其可达性问题也不可判定,但将线程间的上下文切换限定在有限次数内,使得完备性、精确性、覆盖率、以及效率达到一个很好的平衡.上下文限界使递归并发程序的可达性成为可判定,并且程序中的大部分并发错误,如数据竞争和原子性违背,大部分出现在前期的上下文切换[14].利用TMPDN对实时并发递归程序建模,再将TMPDN转换为MPDN后,实时并发递归程序的上下文切换限界可达性问题可以转换为MPDN的限界可达性问题,之后可利用限界模型检验工具如JMOPED,CHESS[17],ESBMC[18]等,对转换后的Page13MPDN进行验证分析.为了验证与分析基于MPDN的并发模型,主要集中在对栈的限定上[19-20],通过栈限定使可达性为可判定,诸如上下文限界技术[21],在牺牲少许完备性的情况下,能很好分析栈之间的交互情况.2012年Abdulla等人[22]给出了更多上下文定义,提出了阶段限界方法,并用实验论证了方法的优越性.2014年Qian等人[23]提出了将进程的消息队列约束为良序的思想,使得递归队列并发程序的可达性成为可判定问题.在使用TMPDN描述并发程序时,将程序分为进程P(process)、过程F(procedure)及语句(state-ment)3个部分.其中进程P=〈G,F1…Fm〉由全局变量集G和过程Fi组成,进程有一个入口主过程main,过程F由参数序列、局部变量集以及语句序列组成,语句包含空语句(nos)、假设(assume)、断言(assert)、原子语句(atomic)等语句.并发程序CC=〈S,P1…Pn〉由共享变量集S(sharedvariables)和进程序列组成.每个进程Pi定义一个计数器pci,将过程F看成一个独立的单元,并把F中的每条语句放入到程序执行序列中,并为每条语句增加判断条件以便监视语句是否执行,判断条件包含进程计数器pci是否正确和局部布尔变量Yn的取值,如果pci正确而Yn返回失败标识false,则表明该语句未执行,如果除当前进程计数器外,其他计数器都返回错误,则表明其他进程未被执行.由以上设定可以模拟及监视程序上下文切换操作,并利于TMPDN对实时递归并发程序的建模.8实例分析本节给出了一个具体实例分析,通过文中所提出的静态和动态转换方法,将TMPDN模型转换为MDPN模型.TMPDN模型如图1所示,即时间多栈下推系统MT=(n,Q,q0,Γ,T,Δ),其中全局变量为g,时钟为t1,栈字符集合Γ={a1,b1,ai,bi,ci,aj,bj,cj}.依据优化的时钟等价技术,可获得时钟关键点集合key={0,2,6,10,}.8.1静态转换由于静态转换的状态空间庞大,下文将通过简化状态格局迁移的描述,来表达静态转换的清晰思路.为了简化描述过程,对时间流逝进行单独分析,而在其他格局迁移分析时暂不考虑时间流逝的情况,并且也没有具体描述时钟剩余部分re()的大小关系.图7(a)描述入栈操作Δpush和时间重置Δ=的静态转换,其中格局R0对应图1所示模型的格局C0,格局R0包含栈1…i,j…n共n个栈,其中栈内的全局变量g、时钟t1以及栈字符a1,b1,ai,bi,aj,bj对应的时钟关键点分别为0,,2,2,6,2,,6.在MPDN中与TMPDN的迁移关系Δpush相对的格局迁移关系ΔMpush为push(〈ci,2〉)‖push(〈cj,2〉),R0经过ΔMpush迁移至格局R1,在R1中增加了项元素〈ci,2〉和〈cj,2〉.TMPDN的迁移关系Δ=:t1←[6:10)表示时钟t1的时钟值重置为7.5∈[6:10),与之对应MPDN的迁移关系ΔM=为t1←6表示将t1赋值为6,因为7.5在关键点[6,10)之间,所以在对t1赋值时向下取关键点6,此时t1与g取关键点剩余部分关系由re(t1)>re(g)转换为re(t1)<re(g),其他不一一描述.图7(b)描述TMPDN时间流逝Δ├的静态转换,随着时间的流逝,R2进入R21,即时钟值为大于关键点的区域,例如〈ci,>2〉表示ci时钟值大于时间关键点2,小于下一个时间关键点6;进入此状态后,随时间流逝循环,直到bj时钟值到达新时间关键点10,进入R22;继续随时间流逝,进入R23,bj时钟值大于时间关键点10,变为;随时间流逝循环,直到a1时钟值到达时间关键点6,进入R24;依次类推,经过时间流逝3.8后达到状态R3,此刻t1,g,a1,b1,ai,bi,ci,aj,bj,cj的关键点分别为,2,6,6,,2,6,,,6.图7(c)描述TMPDN出栈操作Δpop的静态转换,在MPDN中与之对应迁移关系ΔMpop为pop(〈cj,6〉),将项元素〈cj,6〉出栈,此时R3经过ΔMpop迁移至格局R4.8.2动态转换动态转换的操作对象为TMPDN中栈顶及其下一层的栈内元素,同一栈内项元素按照对应时钟关键点剩余部分的大小关系依次存储.初始域R1与TMPDN中初始格局C0相对应,其中R1含有基础时钟字符项〈├,0〉、标识基础时钟字符项〈├项(标识全局变量〈g内字符ai,aj的标识项〈a·所示.(1)描述TMPDN入栈操作Δpush的动态转换.执行MPDN中与TMPDN对应的入栈迁移关系ΔMpush:push(〈ci,2〉)‖push(〈cj,2〉),获得的新域R2,首先将R1中的普通项〈├,0〉、〈bi,2〉、〈bj,6〉、Page14图7TMPDN静态转换后的MPDN〈g,0〉、〈t1,〉进行标识,然后将普通项标识后的标识项〈├基础时钟项、全局变量和全局时钟的普通项〈├,0〉、〈g,0〉、〈t1,〉保存至新域R2中,最后将新入栈项〈ci,2〉、〈cj,2〉保存至新域R2.具体如图9所示.(2)描述TMPDN中时钟重置操作Δ=的动态转换.依照关键点转换规则,在MPDN中将t1赋值为6,对t1赋值时只将栈顶域R2中t1的普通项赋值为6,如图10中R2的项〈t1,6〉所示.(3)描述TMPDN中时间流逝Δ├的动态转换.在时间流逝转换时,MPDN栈内项在不同时间内可能处于不同关键点区域内,但此处只考虑满足迁移条件时栈内项所处的关键点区域,中间过程在此处不进行展开讨论,迁移转换时,基础时钟项〈├,0〉保持不变,其标识项〈├模型中的时间流逝,在实例中其关键点区域为[2:6].在运行ΔM├迁移后,之前栈顶域内的项〈├〈b·〈ci,2〉、〈cj,2〉,更新为项〈├〈g,2〉、〈g图11所示.i,2〉、〈b·(4)描述TMPDN中出栈操作Δpop的动态转换.利用组合域技术,将栈顶域R2及下一层域R1更新为域R3,如文中组合域所述,首先将栈顶域R2中的非出栈的普通项〈├,0〉、〈g,2〉、〈t1,〉、〈ci,6〉以及栈顶下一层域R1中的非全局时钟字符项〈├Page15图8MPDN初始域R1图9MPDN入栈迁移ΔMpush图10MPDN时钟重置ΔM=图11MPDN时间流逝ΔM├图12MPDN出栈迁移ΔMpop〈bi,2〉、〈a·之后组合域中所有项需考虑时间流逝的情况,而时间流逝的时钟值可参考栈顶域R2中项〈├基础时钟项〈├,0〉增加的关键点.最后转换后的结果如图12所示.9总结对实时并发系统形式化分析与验证一直是学界的研究难点.之前诸多学者广泛采用时间自动机理论来分析实时并发程序,但这种方式对递归程序建模非常繁琐.后来研究者提出了时间下推自动机理论,降低了分析实时递归程序的复杂度,但是该模型很难描述实时并发程序中的线程间交互.本文将时间下推自动机模型进行了扩展,提出了时间多栈下推网络来形式化验证实时系统中的并发递归机制及线程间交互,为实时并发系统的分析验证提供了一种新的思路.针对下推系统分析并发程序存在效率和完备性难以兼顾的问题,本文采用动态转换方法,可较好的对实时并发递归程序的线程间交互进行分析验证.下一步工作,将开发验证工具,实现TMPDN到MPDN的自动转换,从模型建立到验证分析自动化.
