Page1标准模型下网关口令认证密钥交换协议的通用框架魏福山1)张振峰2)马传贵1)1)(信息工程大学信息工程学院信息研究系郑州450002)2)(中国科学院软件研究所信息安全国家重点实验室北京100190)摘要网关口令认证密钥交换协议允许用户和网关在服务器的协助下建立起一个共享的会话密钥.网关口令协议适用于无线通信环境,如GSM和3GPP等.已有的网关口令认证密钥交换协议大多缺乏严格的安全证明,或者是在随机预言模型下证明安全的.该文采用模块化的设计方法提出了在标准模型下构造网关口令协议的通用框架.通用框架可以实现双向认证并且能够抵抗不可检测在线字典攻击,因此具有更强的安全性.利用DDH假设、二次剩余假设和N次剩余假设对通用框架进行实例化可以得到不同的标准模型下可证明安全的网关口令协议.关键词口令认证;网关;平滑投射Hash函数;标准模型1引言1.1口令认证密钥交换协议使用一个低熵、人脑可记忆的口令来建立一个安全的会话密钥.PAKE协议广泛地应用于用户认证和安全通信等实际应用场合,如网上银行和远程用户登录.最早的PAKE协议是由Bellovin和Merritt[1]口令认证密钥交换(PAKE)协议允许通信方仅提出的EKE协议.EKE协议具有广泛的影响力,是Page2后续很多口令协议研究的基础[2-5].但是上述口令协议只有启发式的安全讨论,缺乏严格的证明.PAKE协议的安全模型是近期才提出的,之后研究者设计了在随机预言模型或者理想加密模型下可证明安全的PAKE协议[6-7].到目前为止,在标准模型下设计PAKE协议的方法还不多.Katz等人[8]提出了第一个标准模型下可证明安全的PAKE协议,即著名的KOY协议.KOY协议是在共同参考串(CommonReferenceString)模型下设计的,需要假设所有的参与者可以访问由一个可信第三方选择的公开参数.尽管共同参考串模型比仅用口令来设计协议的假设要强,但是对于实际应用中的PAKE协议来说不算一个缺陷,因为在具体应用中可以将公共参数嵌入到用户芯片中.KOY协议后来被Gennaro和Lindell进行了概括,他们给出了标准模型下PAKE协议的一个GL通用框架[9],KOY协议可以看作GL通用框架的一个特例.几乎所有标准模型下可证明安全的PAKE协议都可以看作是对KOY/GL框架的扩展[10-12].唯一的例外是由Jiang等人[13]利用DDH假设设计的标准模型下安全的PAKE协议.最近,Groce等人对Jiang等人的协议进行了概括和提升,设计了一个效率很高的标准模型下PAKE协议的通用框架[14].1.2相关工作在很多实际应用中,服务提供商是由两个实体组成的.一个是与用户直接进行会话的网关,另外一个是用于验证用户身份的后端服务器.为了刻画这种实际的应用场景,Abdalla等人[15]提出了网关口令认证密钥交换(GPAKE)协议的概念.GPAKE协议使得用户和网关在服务器的协助下建立起一个安全的会话密钥.用户和服务器共享一个口令用于认证,但是会话密钥是在用户和网关之间建立的.除了会话密钥的语义安全性之外,GPAKE协议的安全需求还包括针对服务器的密钥私密性和针对恶意网关的口令保护.密钥私密性是指会话密钥对于一个知道所有用户口令的、诚实而好奇的服务器来说是不可区分的;口令保护是指恶意网关通过执行协议不能从服务器端得到用户口令的任何信息.Byun等人[16]后来发现Abdalla等人的GPAKE协议不能抵抗不可检测在线字典攻击.一个恶意的网关可以反复对用户的口令进行猜测并且在服务器端得到验证,直到猜测出正确的口令为止.他们还通过对用户发送的密钥材料进行MAC认证的方法提出了一个改进的协议.但是在2008年,Shim[17]指出Byun等人的改进协议实际上依然不能抵抗不可检测在线字典攻击,Shim通过采用对称加密算法来掩盖口令信息的方法给出了一个改进的S-GPAKE协议.在2010年,Yoon等人[18]指出S-GPAKE协议效率较低并存在设计中的错误.他们提出了一个被称为最优的O-GPAKE协议,但该协议缺乏严格的安全证明.最近,Abdalla等人[19]在最早的GPAKE协议的基础上设计了一个匿名的GPAKE协议,他们提出了一个允许对用户进行腐化的更强的安全模型.但是由于匿名性的原因,该协议依然不能抵抗不可检测在线字典攻击.1.3我们的工作本文提出了第一个标准模型下可证明安全的GPAKE协议的通用框架.我们采用了可以实现平滑投射Hash函数的CPA安全的公钥加密算法以及CCA安全的带标签(Labeled)的公钥加密算法.我们的通用框架具有以下三个方面的优势:首先,通用框架是在标准模型下证明安全的,即不需要随机预言或者理想加密的假设;其次,通用框架可以实现双向认证并且可以抵抗不可检测在线字典攻击.Abdalla等人[15,19]认为他们的协议可以通过用户向服务器增加认证消息的方法来抵抗不可检测在线字典攻击.但是,用户发送给服务器的认证消息应该包含一个仅由用户和服务器知道的秘密值,并且不能泄露用户口令的任何信息给网关.在Abdalla等人[15,19]的协议中很难找到满足上述需求的秘密值.尽管文献[17-18]中的协议被声称可以抵抗不可检测在线字典攻击,但是这些协议缺乏严格的安全证明并且效率较低;最后,我们的通用框架采用了一般的密码学组件,如公钥加密体制和平滑投射Hash函数簇等.我们可以采用DDH假设、二次剩余假设和N次剩余假设对通用框架进行有效的实例化从而得到不同的GPAKE协议.特别的,如果我们采用CPA安全的ElGamal加密算法和CCA安全的Cramer-Shoup加密算法对通用框架进行实例化,将得到一个标准模型下高效的GPAKE协议.与同类的协议相比,我们的协议在相同的效率下具有更高的安全性.第2节回顾GPAKE协议的安全模型;第3节介绍通用框架用到的一些基础构件;第4节介绍GPAKE协议的通用框架并且给出框架的安全性证明;第5节采用CPA安全的ElGamal加密算法和CCA安全的Cramer-Shoup加密算法对通用框架进Page3行实例化,并进一步进行效率比较;第6节对全文进行总结.2安全模型本节简单介绍由Abdalla等人在2005年提出的GPAKE协议的安全模型,对于安全模型的详细介绍参见文献[15].2.1安全模型协议参与方.GPAKE协议的参与者由用户C∈、网关G∈以及服务器S∈组成.用表示所有参与者组成的集合,即集合=∪∪.用U∈表示GPAKE协议中的任意一个参与者.通信模型.在GPAKE协议中,通常假设用户和网关之间的通信是不安全的,通信被敌手完全控制,敌手可以对用户和网关之间传递的消息进行窃听、删除、修改和延迟发送等操作.但是网关和服务器之间的信道是认证的私人信道,即敌手无法窃听网关和服务器之间发送的消息,也不能对网关和服务器之间发送的消息进行修改.另外,用户无法和服务器直接进行通信,用户和服务器之间的消息必须经过网关进行传递.长期密钥.每个用户C∈都拥有一个与服务器共享的用于认证的口令pwC.每个服务器S∈都持有一个口令列表pwS=〈pwC〉C∈S,其中每条记录对应一个在服务器S处进行注册的用户C的口令pwC.pwC和pwS分别称为用户C和服务器S的长期密钥.敌手能力.敌手的攻击能力通过预言询问来刻画.在协议执行的过程中,敌手可以针对某个参与者产生多个并行的会话实例.用Ui来表示用户U的第i次会话实例.敌手可以进行的预言询问有以下几种:(1)Execute(Ci,Gj)询问.此询问模拟敌手进行的被动攻击.其中敌手对用户实例Ci和网关实例Gj之间进行的一次协议执行过程进行窃听.对此询问的回答是将本次协议执行过程中用户和网关之间传输的所有消息返回给敌手;(2)Send(Ui,m)询问.此询问模拟敌手进行的主动攻击.其中敌手伪造一个消息m并且将消息m发送给用户实例或者网关实例Ui.敌手将得到实例Ui在接收到消息m后根据协议描述返回的消息;(3)Test(Ui)询问.此询问不刻画敌手的攻击能力,只是用来衡量参与者实例Ui的会话密钥的语义安全性.如果实例Ui的会话密钥没有定义,那么返回一个未定义的符号⊥.否则,如果b=1就将真实的会话密钥返回给敌手,如果b=0则返回一个与会话密钥等长的随机数,其中b是在攻击游戏开始运行之前选择的随机比特;(4)TestPair(Ci,Gj)询问.此询问不刻画敌手的攻击能力,而是用来定义会话密钥对于服务器的密钥私密性.如果用户实例Ci和网关实例Gj之间没有建立共享的会话密钥,那么返回一个未定义的符号⊥.否则,如果b=1就将真实的会话密钥返回给敌手,如果b=0,则返回一个与会话密钥等长的随机数,其中b是在攻击游戏开始运行之前选择的随机比特.2.2安全定义本小节给出安全模型中的安全性定义.如果一个实例生成会话密钥并且完成协议运行,则称该实例接受.我们通过会话标识和伙伴标识来定义伙伴.一般定义会话标识为协议执行结束后所有消息的级联.一个实例Ui实例Uj定义1(伙伴).用户实例Ci和网关实例Gj被称为伙伴,如果:(1)Ci和Gj都接受;(2)Ci和Gj有相同的会话标识;(3)Ci的伙伴标识为Gj,反之亦然;(4)除了Ci和Gj外,不存在其它接受实例的伙伴标识为Ci或Gj.敌手只能对新鲜的实例进行Test询问,否则敌手可以轻易赢得攻击游戏.新鲜性定义就是为了防止敌手可以通过平凡的方式赢得攻击游戏.定义2(新鲜性).一个用户实例Ci或者网关实例Gj是新鲜的,如果该实例接受协议运行并且生成了会话密钥.在Abdalla等人的安全模型中有3个安全目标,包括语义安全性、密钥私密性和口令保护.其中会话密钥的语义安全性保证了一个外部敌手不能够区分真实的会话密钥和与会话密钥等长的随机数;针对服务器的密钥私密性要求用户和网关之间建立的会话密钥对于诚实而好奇的服务器是不可区分的;针对网关的口令保护是指恶意网关通过协议运行不能得到用户口令的任何信息.下面我们分别给出这三个安全目标的严格定义.考虑一个对GPAKE协议进行攻击的敌手,给敌手提供Execute,Send询问以及对新鲜会话进行多次Test询问的能力.敌手的目标是猜测Test询问中所使用的随机比特b.我们用Succ来表示敌Page4手成功猜测到b这一事件.定义3(语义安全).当口令是从字典空间中随机选择的时候,定义敌手攻破GPAKE协议的语义安全的优势为Advake-ror定义GPAKE协议的语义安全的优势函数为上式中的最大值遍历所有计算时间至多为t,消耗的资源(询问不同预言的次数)至多为R的敌手.如果一个GPAKE协议语义安全的优势函数,(t,R)至多比kn/大一个可忽略的量,Advake-ror那么称GPAKE协议是语义安全的,其中n是敌手进行主动攻击的次数,表示字典空间的规模,k是一个常数.一般k=1是最优的结果,因为每次敌手进行主动攻击至少可以排除一个错误的口令.考虑一个对GPAKE协议进行攻击的敌手,给敌手提供所有用户的口令,Execute询问以及对伙伴会话进行TestPair询问的能力.敌手的目标是猜测TestPair询问中所使用的随机比特b.我们用Succ来表示敌手成功猜测到b这一事件.定义4(密钥私密性).当口令是从字典空间中随机选择的时候,定义敌手攻破GPAKE协议的密钥私密性的优势为Advake-kp定义GPAKE协议的密钥私密性的优势函数为上式中的最大值遍历所有计算时间至多为t,消耗的资源(询问不同预言的次数)至多为R的敌手.称一个GPAKE协议实现了密钥私密性,如果其密钥私密性安全的优势函数Advake-kp相对于安全参数的一个可忽略函数.考虑一个恶意的网关猜测用户的口令,然后通过与服务器执行协议来验证口令是否正确.如果一个错误的猜测没有被服务器检测到,则认为恶意的网关成功.我们用Advake-uoda网关成功的优势.定义5(口令保护).称一个GPAKE协议实现了对恶意网关的口令保护,如果恶意的网关成功的优势Advake-uoda略的量,其中n是敌手进行主动攻击的次数,表示字典空间的规模,k是一个常数.3密码学组件本节介绍在通用框架设计和证明中需要用到的密码学组件.首先给出带标签的公钥加密体制的定义,然后介绍平滑投射Hash函数的概念.3.1带标签的公钥加密体制带标签的加密体制(LabeledEncryption)最初是由ISO18033-2标准正式提出的[20],与通常的加密体制的定义不同的地方在于,在带标签的加密体制中,加密算法和解密算法都有一个额外的被称为标签的参数,并且解密算法只有在输入的标签跟加密时的标签相同时才能正确解密.一个带标签的公钥加密体制LPKE=(LKG,Enc,Dec)一般由以下3个算法组成:参数生成算法LKG:输入安全参数n,通过参数生成算法LKG(1n)产生带标签的公钥加密体制的公私钥对(pk,sk);加密算法Enc:输入为消息m,标签l,加密时的公钥pk以及随机输入r,通过加密算法c=Encl产生对应的密文c;解密算法Dec:输入为密文c,标签l以及解密的私钥sk,通过解密算法m=Declsk(c)恢复出明文m.下面给出带标签的公钥加密体制的不可区分CCA安全性的定义.定义带标签的公钥加密体制不可区分CCA安全的攻击游戏与定义一般公钥加密体制不可区分CCA安全的攻击游戏类似.攻击游戏开始,首先对敌手进行第1阶段的解密培训,此时敌手可以选择密文/标签对(c,l)要求解密预言机进行解密服务.在挑战密文生成阶段,当敌手进行挑战密文询问的时候,除了要输入两个等长的消息(m0,m1)外,还需要提供一个标签l作为额外的输入.当敌手接收到挑战密文C的时候,需要判断挑战密文C是由消息m0和标签l加密产生,还是由消息m1和标签l加密产生的.此时敌手可以继续进行第2阶段的解密培训,敌手除了密文/标签对(c,l)外,可以对任意的密文/标签对进行解密询问.最终,敌手输出其对挑战密文的猜测.敌手的优势函数的定义与普通的公钥加密体制中敌手的优势定义相同.如果敌手的优势是关于安全参数的可忽略的函数,那么我们说带标签的公钥加密体制是不可区分CCA安全的,简称为CCA安全.对于带标签的公钥加密体制的详细定义可参见文献[20-21].3.2平滑投射Hash函数簇平滑投射Hash函数簇可以看作是有两类密钥的Hash函数,其中一类密钥称为全局密钥,可以用来计算平滑投射函数整个定义域上所有输入的对应输出,还有一类密钥称为投射密钥,由全局密钥通过投射函数计算得到,投射密钥只能计算平滑投射函Page5数定义域的一个子集对应的函数值.平滑投射Hash函数之所以被广泛应用于口令协议的设计当中,主要原因是对于投射密钥能够计算的那个特定子集上面的输出,可以通过全局密钥和投射密钥两种不同的方式来计算出相同的函数值,这样使得协议执行的双方在实现认证的同时还能产生共同的秘密值作为会话密钥.而对于特定子集之外的函数值,仅仅知道投射密钥不会泄露该函数值的任何信息.实际上,投射密钥和特定子集之外的函数值是统计独立的.现在给出基于CPA安全的公钥加密体制构造的平滑投射Hash函数簇的严格定义以及相应的性质.给定一个CPA安全的公钥加密体制(Gen,Enc,Dec)和一个消息空间(对应于通用框架中的口令空间).设(pk,sk)是由密钥生成函数Gen(1n)在输入安全参数n时产生的,我们用Ω表示对于公钥pk的有效的密文集合.定义集合X={(ω,m)|ω∈Ω;m∈},集合Lm={(ω,m)|Decsk(ω)=m}X以及集合L=∪m∈个消息m∈使得(ω,m)∈L.一个平滑投射Hash函数是由一个有效的采样算法来定义的.在给定公钥pk的情况下,输出以下的函数组(K,={Hk:X→(0,1)n}k∈K,S,α:K×Ω→S)满足:(1)存在有效的算法可以对密钥空间K进行均匀采样k∈K;对于给定的全局密钥k∈K和定义域中的元素x∈X,存在有效的算法计算平滑投射函数的输出Hk(x);给定任意的全局密钥k∈K和密文空间中的任意元素ω∈Ω,存在有效的算法计算投射密钥α(k,ω).(2)对于x=(ω,m)∈L,函数值Hk(x)完全由α(k,ω)确定.即存在一个有效的算法H在输入s=α(k,ω)和x-=(ω,m,r)满足H(s,x-)=Hk(x),其中r是对消息m进行加密时的随机输入,即ω=Encpk(m;r).(3)对于任意的x=(ω,m)∈X\L,下面的两个分布{k←K;s=α(k,ω),v←{0,1}n:(s,v)}以及{k←K;s=α(k,ω):(s,Hk(x))}是统计不可区分的.上面定义中的第2条性质被称为平滑投射Hash函数的正确性,第3条性质一般被称为平滑性.对于平滑投射Hash函数的详细定义可参见文献[14].4网关口令协议的通用框架本节给出网关口令协议的通用框架,并对其安全性进行证明.4.1通用框架描述GPAKE协议的通用框架是在共同参考串模型下设计的.在共同参考串模型中,假设所有的用户都可以获取从一个预先给定的分布中选择的公共参数.在我们的构造中用到了一个CPA安全的公钥加密体制Σ=(Gen,Enc,Dec)和一个CCA安全的带标签的公钥加密体制Σ=(Gen,Enc,Dec),并且要求可以通过CPA安全的加密体制Σ定义平滑投射Hash函数簇(K,={Hk:X→(0,1)n}k∈K,S,α:K×Ω→S).设安全参数为n,设Gq是一个阶为大素数q的循环群,g为Gq的一个生成元.我们设计的GPAKE协议的通用框架中所使用的共同参考串的公共参数包括两个加密体制对应的公钥pk,pk以及对群Gq的描述(Gq,g,q).需要说明的是,在共同参考串模型中,任何人都不知道加密体制的公钥pk,pk对应的私钥sk,sk.GPAKE协议的通用框架的参与者由用户、网关和服务器组成.假设用户和服务器之间共享一个从口令字典空间中选择的口令pw,并且网关和服务器之间存在认证通道.GPAKE协议的通用框架的描述在图1中给出,具体的执行步骤如下:1.用户C选择一个随机数x∈Zq并计算X=gx.然后用户从{0,1}n中选择一个随机数r,计算利用CPA安全的加密体制Σ对口令pw进行加密的密文ω=Encpk(pw;r),最后发送消息(C,X,ω)给网关G.的合法性,然后将消息(G,s,ω,Y)发送给用户.5.用户C接收到消息(G,s,ω,Y)后,首先通过投射密钥s,口令pw以及在第一轮生成密文ω时的随机输入r来计算平滑投射Hash函数的值,即用户计算rτ1τ2=H(s,ω,pw,r),然后验证ω是否等于Enclabel如果验证通过,那么用户接受协议并且计算会话密钥K=Yx=gxy;否则,用户终止协议运行.最后,用户发送2.网关G接收到消息(C,X,ω)后,随机选择y∈Zq并且计算Y=gy,然后将Y连同接收到的消息一起发送给服务器S.3.服务器S接收到网关发送的消息(C,X,Y,ω)后,首先随机选择全局密钥k∈K,并计算投射密钥s=α(k,ω).然后服务器利用口令pw和全局密钥k计算平滑投射Hash函数的值Hk(ω,pw),并且将结果分为三个随机比特串rτ1τ2,其中τ1和τ2的长度至少为n,并且r有足够的长度作为CCA加密体制Σ的随机输入.服务器定义标签label=CGSωsXY并且用带标签的加密体制计算对口令pw加密的密文ω=Enclabel后,服务器发送消息(s,ω,τ1)给网关.4.网关接收到消息(s,ω,τ1)后,储存τ1用来验证用户Page6(C,τ1,τ2)给网关.6.网关接收到消息(C,τ1,τ2)后,首先验证τ1是否等于τ1.如果验证通过,则说明用户是合法的,那么网关接受协议运行并生成会话密钥K=Xy=gxy;否则,网关拒绝协议运行并终止.最后,网关发送消息(C,τ2)给服务器.服务器通过图1GPAKE协议的通用框架4.2安全性证明本小节给出对GPAKE协议的通用框架的安全性证明,证明主要基于DDH假设、框架中所使用的公钥加密体制Σ的CPA安全性以及公钥加密体制Σ的CCA安全性.下面给出DDH假设的定义.DDH假设.假设Gq为阶为素数q的循环群,g为Gq的一个生成元.假设ddh是一个概率多项式时间的敌手,模拟者首先随机选择u,v,w∈Zq,并且计算U=gu,V=gv和W=gw,然后随机选择一个比特b∈{0,1},如果b=1,那么将(gu,gv,guv)给敌手,否则将(gu,gv,gw)给敌手.敌手需要猜测随机比特b的值,如果敌手猜测正确就认为敌手成功,记此事件为Succ.定义敌手的优势为Adv(ddh)=2·Pr[Succ]-1.如果对于任意的概率多项式敌手,上述优势都是可忽略的,那么称循环群Gq中DDH假设成立.定理1(语义安全).假设是一个运行时间为t,并且进行了qsend次Send询问的概率多项式敌手.如果DDH假设在群Gq中成立、公钥加密体制Σ是CPA安全的并且公钥加密体制Σ是CCA安全的,那么敌手破坏GPAKE协议通用框架语义安全的优势至多为消息(C,τ2)来检测恶意网关进行的在线字典攻击.具体地,服务器验证τ2是否等于τ2.如果验证通过,说明接入认证请求确实是一个诚实的用户发送的;否则,接入请求很可能来自一个恶意网关对用户的在线仿冒攻击,服务器将采取进一步的措施以保护用户口令.其中neg(n)表示关于安全参数n的一个可忽略函数.证明.我们定义一系列混合实验.从每一个实验开始,我们首先用随机数替代被动攻击中的会话密钥,然后修改主动攻击中的会话,使得敌手猜测口令错误的主动会话都会被拒绝接受.到最后一个实验,所有的会话密钥完全随机并且与用户的口令完全独立,因此敌手无法区分真实的会话密钥和与会话密钥等长的随机数,也无法获得任何关于用户口令的任何信息.我们总共定义了11个混合实验,我们用P0,P1,…,P10来表示这些混合实验,用事件Success表示敌手正确猜测出了在Test询问中所使用的随机数b,并且用Adv(,Pi)表示敌手在第i个混合实验中的优势.实验P0.此实验模拟在标准模型下的真实协议运行.在实验中敌手可以多次访问Execute、Send和Test询问.根据定义有实验P1.在这个实验中,我们修改对Execute询问的模拟.对于敌手进行的Execute(Ci,Gj)询问,我们计算ω=Encpk(pw0;r),其中pw0是不在口Page7令空间中的虚假口令.相应的,在用户端计算r,τ1和τ2的时候,直接将这几个值取为由服务器计算的r,τ1和τ2的值.其余的模拟与上一个实验完全相同.显然,这个实验将被动会话中用户端对口令加密的密文替换为对一个虚假口令加密的密文.实验P1和实验P0的差别至多是敌手攻破公钥加密体制Σ的CPA安全性的优势.给定一个可以区分实验P1和实验P0的敌手,我们现在来构造一个可以攻击公钥加密体制Σ的CPA安全性的概率多项式敌手.给定公钥pk,敌手选择其余的公开参数并为所有的用户选择口令,然后为敌手模拟整个实验.对于Execute(Ci,Gj)询问,敌手用口令pw和虚假口令pw0作为两条消息进行挑战密文的询问.当敌手接收到挑战密文ω,就将挑战密文添加到用户发送给网关的第一条消息中,其余的模拟跟实验P1中完全相同.在实验结束时,如果敌手认为他在实验P0中,那么敌手就判定挑战密文ω是对口令pw的加密;反之挑战密文则是对虚假口令pw0的加密.敌手攻击公钥加密体制Σ的CPA安全性的优势与敌手区分实验P1和实验P0的概率完全相同,由公钥加密体制Σ的CPA安全性,我们有Adv(,P1)-Adv(,P0)neg(n).实验P2.在这个实验中,我们继续修改对Execute询问的模拟.服务器在接收到用户C发送的消息(C,X,Y,ω)后,随机选择k∈K并计算s=α(k,ω),但是服务器随机选择适当长度的比特串作为r、τ1和τ2的值.相应地,根据模拟规则将用户端的r、τ1和τ2的值直接取为由服务器选择的r、τ1和τ2的值.其余的模拟和上一个实验相同.由平滑投射Hash函数的平滑性易知实验P2和实验P1的差别至多是关于安全参数n的一个可忽略函数.注意到我们在计算ω的时候用的是虚假口令pw0,因此(ω,pw0)L,根据平滑性可知,即使敌手知道投射密钥s,平滑投射Hash函数的输出Hk(ω,pw0)与其值域中的均匀分布仍然是统计不可区分的.因此,我们有Adv(,P2)-Adv(,P1)neg(n).实验P3.在这个实验中,我们继续修改对Execute询问的模拟.当服务器计算密文ω的时候,我们令ω=Enclabel入r是根据实验P2的模拟规则随机选择的.同时,我们取消用户端对ω的验证,要求用户直接接受协议运行并产生会话密钥.实验P3和实验P2的差别至多是敌手攻破公钥加密体制Σ的CCA安全性的优势.实际上,我们这里用到的只是公钥加密体制Σ的CPA安全性.通过跟实验P1类似的分析可以知道:实验P4.在这个实验中,我们最后一次修改对Execute询问的模拟.当我们计算Execute询问的会话密钥的时候,直接从Gq中随机选择一个元素K,而不是通过K=Xy或者K=Yx的方式计算.实验P5和实验P4中敌手优势的差距跟攻破DDH假设的优势相同.现在我们给出上面结论的证明.给定一个DDH实例(U,V,W),我们为了模拟对Execute(Ci,Gj)询问的回答,首先随机选择a1,a2,b1,b2∈Z在模拟Execute(Ci,Gj)询问的时候我们令X=Ua1ga2以及Y=Vb1gb2,其余的模拟都跟实验P3完全相同.最后,我们定义会话密钥为K=Wa1b1·Ua1b2·Va2b1·ga2b2.显然,如果(U,V,W)是一个Diffie-Hellman三元组,那么模拟的规则与实验P3完全相同;如果(U,V,W)是一个随机的三元组,那么模拟的规则与实验P4一致.如果存在敌手可以区分实验P4和实验P3,那么我们可以以相同的优势攻破DDH假设,因此我们有注意在实验P4中,对于Execute询问产生的会话密钥以及协议的消息跟口令完全无关,因此敌手不可能通过Execute询问得到口令的任何信息,同时由于会话密钥是随机选择的,敌手在猜测由Execute询问产生的会话密钥的时候也不会有任何优势.实验P5.从这个实验开始,我们修改对Send询问的模拟.为了符号上的方便,我们令Send0(Ci,Gj)表示要求用户实例Ci开始执行协议的初始激活消息;令Send1(Gj,CXω)表示用户发送给网关实例Gj的第一条消息;令Send2(Ci,GsωY)表示协议中网关接收到消息CXω后发送给用户实例Ci的消息;令Send3(Gj,Cτ1τ2)表示用户发给网关实例Gj的最后一条消息.另外如果一条消息是由诚实的参与者生成的,那么我们说该消息是由实例生成的;否则,我们称消息是由敌手产生的.在实验P5开始,当我们在产生CRS参数中公钥加密体制Σ和Σ的公钥pk,pk的时候,我们记录其对应的私钥sk,sk.Page8当敌手产生的消息GsωY并进行Send2(Ci,GsωY)询问时,假设CXω是对于Send0(Ci,Gj)询问的回答,我们首先检查sω是否是由某一个实例产生的,如果不是则利用私钥sk和标签label=CGSωsXY对敌手发送的密文ω进行解密,看解密得到的消息是否等于pw.如果不相等,那么拒绝协议,并且停止用户实例Ci的运行;如果相等,那么我们停止协议运行并且宣布敌手成功.实验P5和实验P4唯一的区别在于当敌手伪造的消息GsωY中的密文ω可以被解密为pw的情况,在这种情况下我们认为敌手攻破了协议的语义安全性,所以敌手的攻击优势增大.因此,我们有实验P6.在这个实验中,我们修改对Send0和Send2询问的模拟.对于敌手发送的Send0(Ci,Gj)询问,我们现在计算ω=Encpk(pw0;r),其中pw0是不在口令空间中的虚假口令.为了保证敌手视图的一致性,对于一个Send2(Ci,GsωY)询问,如果确实存在一个网关实例Gj跟Send1(Gj,CXω)询问匹配,也就是说GsωY是由网关实例Gj在接收到消息CXω后产生的,那么我们要求用户实例Ci在不对消息GsωY进行验证的情况下就接受,并且将rτ1τ2定义为网关实例Gj在接收到CXω后计算出的rτ1τ2.敌手区分实验P6和实验P5的优势和攻破公钥加密体制Σ的CPA安全性的优势相同.从实验P1进行的类似分析可知:Adv(,P6)-Adv(,P5)neg(n).实验P7.在这个实验中,我们修改对Send1询问的模拟进行一个简单的改动.对于敌手产生的Send1(Gj,CXω)询问,注意到从实验P5开始我们就记录了私钥sk,sk,因此可以用公钥加密体制Σ对应于公钥pk的私钥sk对ω进行解密,如果解密的明文是pw,那么我们停止模拟并且宣布敌手成功;如果不是,那么按照上一个实验的模拟规则进行.除此之外,所有的模拟和实验P6完全一致.显然,在这个实验里面,我们只是增加敌手成功的方式,因此有实验P8.在这个实验中,我们继续修改对Send1询问的模拟.对于敌手产生的Send1(Gj,CXω)询问,我们用公钥加密体制Σ对应于公钥pk的私钥sk对ω进行解密,如果解密的明文是pw,那么我们停止模拟并且宣布敌手成功;如果解密后的明文不是pw,那么我们随机选择适当长度的比特串作为r、τ1和τ2的值.特别的,如果敌手继续发送了Send3(Gj,Cτ1τ2)询问,有τ1=τ1并且τ2=τ2,那么网关实例Gj接受协议运行并且生成会话密钥K.实验P8和实验P7的差别至多是关于安全参数n的一个可忽略函数.注意到敌手计算ω的时候对口令猜测错误,根据平滑性可知,即使敌手知道投射密钥s,平滑投射Hash函数的输出与其值域中的均匀分布仍然是统计不可区分的.因此,我们有实验P9.在这个实验中,我们最后一次修改对Send1询问的模拟.对于敌手发送的Send1(Gj,CXω)询问,当计算密文ω的时候,我们令ω=pk(pw0;r),其中所使用的随机输入r是根据Enclabel实验P8的模拟规则随机选择的.敌手在实验P9和实验P8中的优势之差至多为敌手攻破公钥加密体制Π的CCA安全性的优势.如果存在敌手可以区分实验P9和实验P8,那么我们可以构造一个概率多项式敌手攻击公钥加密体制Π的CCA安全性.给定公钥pk,敌手按照实验P8中的模拟规则选择所有的口令和安全参数,并为敌手模拟整个实验运行.注意,这里敌手不知道公钥加密体制Π的公钥pk对应的私钥sk,但是知道公钥加密体制Π的公钥pk对应的私钥sk.与实验P8中的模拟规则不同的地方在于,当接收到敌手发送的Send1(Gj,CXω)询问,当计算密文ω的时候,敌手令label=CGSωsXY,并产生一个虚假的口令pw0,然后将口令pw和虚假的口令pw0作为挑战的消息连同label一起发送给加密体制的预言机.当敌手收到加密预言机返回的挑战密文ω后,就把ω加入到返回给敌手的消息中.为了使模拟完美,敌手需要判断敌手是否通过询问Send1或者Send2已经成功.敌手对于Send1询问的判断很容易,因为敌手知道私钥sk.但是对于Send2询问需要借助于公钥加密体制Σ中的解密预言机来判断敌手是否成功.容易验证敌手不需要向解密预言机询问标签/密文对(label,ω)的解密服务,因此敌手可以完美模拟整个实验.在实验的最后,如果敌手认为其处在实验P8中,那么敌手就判定挑战密文ω是对口令pw的加密;反之,如果敌手认为其处在实验P9中,那么敌手就判定挑战密文ω是对虚假口令pw0的加密.这样敌手可以攻破公钥加密体制Σ的CCA安全性,因此我们有Page9实验P10.在最后的实验中,我们考虑敌手通过Send询问进行的被动攻击,也就是说敌手虽然进行了Send询问,但是只是诚实传递消息,没有对消息进行任何改动.对于这样的会话,模拟的规则和实验P5中模拟Execute询问产生的被动会话相同.跟实验P4中的分析类似,我们有Adv(,P10)-Adv(,P9)neg(n).现在我们考虑敌手在实验P10中成功的几种可能的方式:情况1.对于敌手产生的消息进行的询问Send1(Gj,CXω),敌手伪造的密文ω可以解密得到正确的口令pw.情况2.对于敌手产生的消息进行的询问Send2(Ci,GsωY),敌手伪造的密文ω可以解密得到正确的口令pw.情况3.对于敌手进行的询问Send3(Gj,Cτ1τ2),有τ1=τ1以及τ2=τ2,但是τ1和τ2不是由与网关实例Gj匹配的用户实例产生的.机比特b.情况4.敌手成功猜测到Test询问中使用的随情况3发生的概率是可忽略的,因为τ1和τ2是随机选择的并且与敌手的视图完全独立.我们用事件PwdGuess表示情况1或者情况2发生.由于敌手的视图与所有的口令都是独立的,直到情况1或者情况2发生,因此我们有如果事件PwdGuess不发生,那么敌手只能通过情况4成功.但是所有的会话密钥都是随机选择的,并且与敌手的视图完全独立,因此敌手通过情况4成功的概率是1Pr[Success]Pr[Success∧PwdGuess]+Pr[PwdGuess]+Pr[SuccessPwdGuess]·(1-Pr[PwdGuess])=12+112+1综上,定理1得证.定理2(密钥私密性).假设是一个运行时间为t,并且进行了qExecute次Execute询问的概率多项式敌手.如果DDH假设在群Gq中成立,那么敌手破坏GPAKE协议通用框架的密钥私密性的优势至多为证明.假设kp是运行时间至多为t,进行了qExecute次Execute询问和qTest次TestPair询问的概率多项式敌手.下面我们通过调用kp来构造一个可以解决DDH问题的敌手DDH.设DDH实例(U,V,W)是给DDH的输入.DDH首先根据协议中口令空间的分布为所有的用户选择口令,另外选择框架中所有的CRS公共参数.DDH随机选择一个随机比特b用于模拟TestPair询问.然后DDH将所有的口令告诉敌手kp并且开始模拟协议的运行.为了模拟Execute(Ci,Gj)询问,DDH首先随机选择a1,a2,b1,b2∈ZX=Ua1ga2,然后在模拟网关的时候令Y=Vb1gb2.DDH根据协议的描述正常模拟协议剩余的步骤直到计算Diffie-Hellman密钥K为止,DDH设置Diffie-Hellman密钥K=Wa1b1·Ua1b2·Wa2b1·ga2b2.为了模拟TestPair(Ci,Gj)询问,DDH首先检查敌手kp是否进行过相同的询问.如果是,则返回与上次相同的回答;否则,DDH检查Ci和Gj是否是伙伴,如果不是,则返回错误的符号⊥.在Ci和Gj是伙伴的情况下,如果随机比特b=0,那么DDH返回真实的会话密钥K给敌手kp,如果随机比特b=1,那么DDH返回一个Gq中的随机元素给敌手kp.下面我们分析DDH攻破DDH假设的成功概率,首先如果DDH实例(U,V,W)是一个Diffie-Hellman三元组,那么上面对协议的模拟是完美的,因此DDH输出1的概率为1果DDH实例(U,V,W)是一个随机的三元组,那么无论b为0或者1,返回给敌手kp的都是与其视图独立的随机数,因此不会泄露关于b的任何信息,此时DDH输出1的概率为1综上,定理2得证.定理3(口令保护).假设是一个运行时间为t,并且进行了qSend次Send询问的概率多项式敌手,那么敌手对GPAKE协议通用框架进行不可检测在线字典攻击成功的优势至多为证明.考虑一个恶意网关冒充诚实用户并Page10且发送消息(C,X,ω,Y)给服务器.根据协议描述,此时服务器应该随机选择k∈K并计算投射密钥s=α(k,ω),然后计算平滑投射Hash函数的值Hk(ω,pw),并且将结果分为三个随机比特串rτ1τ2.服务器定义标签label=CGSωsXY并且用带标签的加密体制Σ计算对口令pw加密的密文ω=pk(pw;r),最后服务器发送消息(s,ω,τ1)给Enclabel恶意网关.恶意网关需要返回消息τ2满足τ2=τ2,否则服务器将会检测到恶意网关的在线口令猜测攻击.如果恶意网关在产生密文ω的时候正确猜测到了口令,那么可以正确计算出τ2的值.反之,如果口令猜测错误,根据平滑投射函数的平滑性可知,即使敌手知道投射密钥s,平滑投射Hash函数的输出与其值域中的均匀分布仍然是统计不可区分的.因此恶意网关能够正确返回τ2的概率是2-n.因此,恶意网关对H-GPAKE协议进行不可检测在线字典攻击成功的概率至多为5性能分析在本节,我们首先用具体的公钥加密体制对通用框架进行实例化,然后与其它的网关口令协议进行效率与安全性方面的比较.如果令ElGamal加密算法为框架中的CPA安全的加密体制,Cramer-Shoup加密算法为框架中的CCA安全的加密体制,那么我们得到标准模型下安全高效的网关口令协议[22].在计算代价方面,由于模指数运算和公钥加密是计算代价最高的运算,因此我们只考虑模指数运算(用e表示)和CCA公钥加密运算(用E表示),而忽略其余的运算(如Hash函数运算、模乘、对称加密和MAC等).在通信代价方面,我们从传输的消息所占用的通信带宽和通信轮数两个方面来比较.为了比较通信带宽,我们假设参与者的身份可以用32比特的字符串表示,循环群Gq中的点可以由160比特的字符串表示,假设对称加密算法、Hash函数和MAC的输出都是160比特.由于文献[16-18]中的协议假设用户和服务器之间需要执行安全的两方PAKE协议,因此我们用文献[6]中安全高效的两方PAKE协议对这些协议进行实例化.计算效率和通信效率的比较结果见表1.在安全性方面,我们主要从是否可以抵抗不可检测在线字典攻击、是否实现双向认证、安全性证明的模型以及安全性证明所基于的困难性假设四个方面进行衡量.我们用UODA表示不可检测在线字典攻击,用MA表示双向认证,用PCDDH表示基于口令的选择基判定性DDH假设[19],用ROM表示随机预言模型,Standard表示标准模型.安全性比较的结果见表2.比较的协议计算复杂度ACFP协议[15]2e2e2e12164AIP协议[19]4e3e3e22084BLL协议[16]4e2e4e22408Shim协议[17]4e2e4e19208YY协议[18]4e2e4e27529我们的协议4e+1E2e2e+1E33606表2标准模型下的网关口令协议的安全性比较比较的协议UODAMA安全性证明困难性假设ACFP协议[15]NNROMDDH,PCDDHAIP协议[19]NNROMDDH,PCDDHBLL协议[16]NNUnprovenShim协议[17]YNUnprovenYY协议[18]YYUnproven我们的协议YYStandardDDH在计算代价方面,注意形如gxhy这样的运算可以通过一个模指数的运算代价求得.从表1可见,对于网关的计算量,我们的协议和其余的GPAKE协议相同.但是在我们的协议中,用户需要8个模指数运算(其中4个是Cramer-Shoup加密算法的代价),服务器需要计算6个模指数运算(其中4个是Cramer-Shoup加密算法的代价),因此我们的协议计算复杂度高于其它的协议.在通信带宽方面,我们的协议仍然是效率最低的.但是注意到,大部分的计算代价和通信带宽都来自协议中用到的CCA安全的公钥加密体制,仅CCA加密体制就占到了8个指数运算和1280比特的传输带宽.然而目前在设计标准模型下可证明安全的PAKE协议时,CCA安全的公钥加密体制几乎是必不可少的.事实上,标准模型下可证明安全的协议计算复杂度和通信复杂度一般是随机预言模型下的同类协议的3倍左右.考虑到我们的协议是标准模型下可证明安全的,因此这样的计算代价和通信代价是可以接受的,并且具有相当的优势.在协议的通信轮数方面,我们的协议需要6轮交互,效率只比ACFP协议和AIP协议低.注意到ACFP协议和AIP协议都不能抵抗不可检测在线字典攻击,为了使其能够抵抗该攻击,至少需Page11要增加两轮通信(用户给网关发送对服务器的验证信息,再由网关转发给服务器).在安全性方面,我们的协议可以抵抗不可检测在线字典攻击并且实现了双向认证,其余的协议都没有能够达到相同的安全强度.虽然文献[18]中的协议也声称具有同样的安全性,但是缺乏严格的证明,其安全性无法令人信服.我们的协议是唯一的一个在标准模型下可证明安全的GPAKE协议,并且安全性证明基于标准的DDH假设.6总结本文在共同参考串模型下基于平滑投射Hash函数簇设计了网关口令认证密钥交换协议一个高效的通用框架,并且在标准模型中证明了其安全性.通用框架采用了模块化的设计思路,可以利用不同的密码学组件进行具体的实例化;在安全性方面,通用框架可以实现双向认证并且能够抵抗不可检测在线字典攻击,还采用了模块化的安全证明思路;利用DDH假设、二次剩余假设和N次剩余假设对通用框架进行实例化可以得到不同的标准模型下高效的网关口令协议.
