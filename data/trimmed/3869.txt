Page1一种访问控制策略非一致性冲突消解方法李瑞轩1)鲁剑锋2)李添翼1)辜希武1)唐卓3)1)(华中科技大学计算机科学与技术学院武汉430074)2)(浙江师范大学数理与信息工程学院浙江金华321004)3)(湖南大学信息科学与工程学院长沙410082)摘要针对静态职责分离策略与可用策略并存时由于其互斥的需求可能引发策略非一致性冲突问题,提出了一套基于优先级的冲突消解方法.在综合考虑策略自身严格性以及对整个策略集合的影响力等因素下,提出了一种策略优先级计算方法.定义了策略的自身可满足频率和加权冲突面积这两个概念,分别表示策略的自身严格性和该策略对整个策略集合的影响力.在此基础上,根据不同的策略目标,给出了两种基于优先级的策略消解算法:最小代价方法和字典编辑优选方法.实验结果表明,在静态职责分离和可用策略的数量规模不大的情况下,基于优先级的冲突消解方法可以有效地解决策略非一致性冲突问题.关键词访问控制;静态职责分离;可用策略;非一致性冲突;加权冲突面积;自身可满足频率1引言访问控制策略是网络安全防范和保护的主要策略,其任务是保证网络资源不被非法使用和非法访问[1].当访问控制系统中存在多个访问控制策略,而访问控制中的主体、客体、权限又隶属于不同的访问控制策略时,有可能因此引发访问控制策略冲突[2].访问控制策略冲突会导致不一致的系统行为,从而造成访问控制系统执行效率和准确性低下,甚至出现访问控制漏洞等安全问题.访问控制策略冲突包含多种类型,其中策略非一致性(policyinconsistency)冲突源起于设计出的安全(security)策略与效用(utility)策略存在不兼容的情形.安全与效用策略在访问控制系统中十分重要,用以确保在访问控制系统中安全并成功地执行某个特定任务.安全策略过去习惯于被用以描述安全原则,以确保非法访问的用户无法访问[3].从这种基于安全原则的特征来看,安全策略已经被广泛认为是限制访问的一个工具.然而,访问控制另外一个同等重要的方面是效用策略,它能够在访问控制系统环境中启用访问[4-5].在很多情形下,一个访问控制系统中同时包含安全与效用策略是十分必要的,然而这些策略由于互斥的需求可能会导致相互间发生冲突.因此,在安全策略与效用策略并存的情况下,研究一套有效的方法来消解可能存在的策略非一致性冲突问题就显得十分重要.本文为安全与效用策略的非一致性冲突提供一种消解方法.该方法既可以帮助策略管理员在安全与效用策略并存时制定出合理的访问控制策略,同时也为将来在策略非一致性解决方案方面进一步优化研究打下一定的基础.对比传统的策略冲突消解方法,本文所提出的策略非一致性冲突消解方法的主要贡献如下:(1)形式化定义了安全与效用策略并存时所引发的策略非一致性冲突问题.(2)提出了一套计算策略优先级的方法.策略优先级的计算涉及两个概念:加权冲突面积和自身可满足频率.加权冲突面积体现了策略在整个策略集合中对其余策略一致性的影响;自身可满足频率则体现出策略自身的严格程度.(3)给出了最小代价法[6]和字典编辑优选法[7]的两种策略消解方法.最小代价法表示在策略消解过程中消耗的时间代价最小.字典编辑优选法则尽可能使结果集中策略数目最大化,策略集的安全与效用损失最小化.本文第2节介绍策略冲突相关的研究工作;第3节中对静态职责分离策略、可用策略、策略的一致性等概念进行了阐述,说明非一致性冲突消解的必要性;第4节提出基于优先级的策略非一致性冲突消解方法,阐述如何通过计算加权冲突面积和自身可满足频率来得到策略优先级,并在此基础上,给出两种策略消解方法;第5节为实验部分,按照提出的消解方法对发生非一致性冲突的策略集进行冲突消解和性能评估;最后对全文进行总结,并指出下一步研究计划.2相关工作策略冲突研究源起于对策略管理框架的研究.伦敦帝国大学的Policy小组在策略研究过程中提出了一套策略管理框架,其小组成员Lupu博士在研究过程中提出了策略冲突问题.文献[2]将策略冲突简单地分类为模态冲突和元策略冲突,并提出了相应的冲突检测方法与消解原则.何在朗等人[8]在分析了策略冲突成因的基础上,提出了一套较为系统的冲突细分标准.他们将冲突分类为模态冲突和应用相关的冲突.根据冲突策略间主客体的关联关系,将应用相关的冲突细分为主体关联冲突、客体关联冲突、主客体关联冲突和主客体自关联冲突.姚键等人[9]提出了一种基于有向图模型的冲突检测机制,解决了冲突检测中形式化证明过于复杂的问题.他们将主体作为节点,主体域中权限的传递关系作为有向边,建立了主体域有向无环图模型.同时以客体为节点,客体域之间从属关系作为有向边,从而形成客体域有向无环图模型.通过建立有向无环图模型,将冲突检测问题转化为图中求取连通节点的问题,使检测问题得以简化.在策略冲突消解方法中,大部分研究使用了设定策略执行优先权的方法.然而使用单一的冲突消解方法,可能因为使用不同的方法,得到不同的消解结果,最终导致消解结果的不一致性.李祥军等人[10]提出了为消解方法设定优先级的办法来解决该问题.以上研究内容都是着眼于安全策略的冲突问题.然而系统中并不能单纯地强调安全策略,为保证系统任务的完成,效用策略在一个访问控制系统中也必不可少.当安全策略与效用策略并存时,可能引发策略非一致性冲突.关于策略非一致性冲突问题Page3的研究,主要分为冲突检测与冲突消解两个方面.关于冲突消解的研究,传统的消解方法主要有自主消解法、随机消解法和遍历子基法等,然而它们存在着一定的局限性.下面对传统消解方法的局限性进行简单分析.首先设有策略集合POL={pol1,pol2,…,poln},集合的基数为n.假设策略集POL存在非一致性冲突,必须采取某种措施才能够消解冲突,目前主要有两种冲突消解方法:(1)通过删除部分策略,使得剩下的策略不发生冲突;(2)通过修改某些策略从而消解冲突.本文主要采用第一种冲突消解方法,假设删除前k个策略(pol1~polk)能使得剩下的策略子集POL={polk+1,polk+2,…,poln}保持一致性.评价策略子集POL是否是最优的解,需要考虑到以下指标:保留下来的策略数量最大化,同时使得整体安全与效用损失最小化.(1)自主消解法[11].由策略制定者评估策略集合中策略的重要程度,然后删除那些相对次要的策略,再通过一致性检测来验证其删除方案的正确性.在该方法中,如何评估一个策略的重要程度,取决于策略制定者的主观判断,并无统一的衡量标准.能否正确地评估策略的重要程度,并且有效地删除相应的策略,这又取决于策略制定者的专业素质.简言之,该方法过于依赖策略制定者.当策略规模较小时,该方法较为可行.然而当策略规模较大时,效率低下,而且人为出错可能性较高.(2)随机消解法[12].每次随机地删除一个策略,若依然发生非一致性冲突,继续随机删除策略.由假设可知,若∩ki=1poliSet(deleted)为真时,可以得到一致性集合,其中Set(deleted)表示被删除的策略集合.该方法过于随意,其可靠性较低.最好的情形下,前k个策略在第k次随机删除中恰好被删除,这种情形的概率为k!(n-k)!/n!.因为通常情况下n远远大于k,所以该概率极小.同时,该方法并未考虑到安全和效用的损失.在最坏的情形下,将得到只有一个策略元素的策略子集.该算法的时间消耗主要集中在一致性检测上.(3)遍历子基法[13].通过遍历的方式,删除策略全集中的每一个子集.第一轮,遍历删除基数为1的策略子集;若依然发生非一致性冲突,遍历删除基数为2的策略子集;直至遍历删除基数为k的策略子集.该方法必然可以得到一个最优的策略子集.但是,该方法的时间复杂度极高,其总的时间消耗为∑kCin×time(checki),其中time(checki)表示第i次i=1删除后的检测时间消耗.3访问控制策略非一致性冲突问题静态职责分离(StaticSeparation-of-Duty,SSoD)策略[14]是一种典型的安全策略,其目标是为了防止多用户间勾结从而获取较多权限.可用(Availability,AB)策略[13]作为一种典型的效用策略[15],其目标是使多个用户为完成某一任务而共同获取某一特定权限集合.由于这两种策略之间互斥的需求,导致策略间可能存在着非一致性冲突.一个安全与效用策略并存的策略集合是否存在非一致性冲突,则涉及到策略集合的一致性检测问题.以下是上述描述中所涉及的相关概念定义.定义1.静态职责分离策略.它是指一个SSoD策略中确保有至少k个源于用户集合U中的用户才能共同拥有完成某项任务所必须的权限集合P中的所有权限.形式化定义如下:(1)P={p1,p2,…,pm}和U={u1,u2,…,un}分别表示权限集合和用户集合,pi(1im)表示第i个权限,uj(1in)表示第j个用户;(2)犕[1…m,1…n]是一个布尔矩阵,表示用户与权限的指派关系.其中单元格M[i,j](1im,1jn)表明用户uj是否拥有pi这一权限.当M[i,j]=1,表明权限pi已经指派给了用户uj;反之,当M[i,j]=0,则无对应的指派关系;(3)Pauth(uj)={pi|pi∈P,Mi,[]j=1}表示所有已经指派给用户uj的权限集合;(4)(P,U,k)∈SSoD,UU:|U|<k∪u∈UPauth(u)P,其中m,n,k是整数,并且2kmin(m,n),min(m,n)返回m和n中较小的一个数值,我们将SSoD策略简写为ssod〈P,U,k〉.如果在一个访问控制系统状态ε中,{u1,u2,…,un}中不存在任何k-1个用户能够共同拥有{p1,p2,…,pm}中的所有权限,则认为ε满足SSoD策略e=ssod〈{p1,p2,…,pm},{u1,u2,…,un},k〉的安全性需求,记作safee(ε).定义2.可用策略.可用策略确保在用户集合U中存在基数为t的用户子集U中的用户共同拥有完成某项任务所必须的权限集合P中的所有权限.形式化定义如下:(1)P={p1,p2,…,pm}和U={u1,u2,…,un}Page4分别表示权限集合和用户集合,pi(1im)表示第i个权限,uj(1in)表示第j个用户;(2)犕[1…m,1…n]是一个布尔矩阵,表示用户权限指派关系.其中单元格M[i,j](1im,1in)表明用户uj是否拥有pi这一权限.当M[i,j]=1,表明权限pi已经指派给了用户uj;反之,当M[i,j]=0,则无对应的指派关系;(3)Pauth(uj)={pi|pi∈P,Mi,[]j=1}表示所有已经指派给用户uj的权限集合;(4)(((P,U,t)∈AB)∧(UU))(|U|t∪u∈UPauth(u)P),其中m,n,t都是整数,有1tmin(m,n),我们将可用策略简写为ab〈P,U,t〉.如果在一个访问控制系统状态ε中,{u1,u2,…,un}中存在t个用户能够共同拥有{p1,p2,…,pm}中的所有权限,则认为ε满足AB策略f=ab〈{p1,p2,…,pm},{u1,u2,…,un},t〉的效用性需求,记作satf(ε).SSoD策略防止少数用户拥有过多的权限,从基于安全原则的特征来看,SSoD策略可以看成是限制访问的一个工具.而AB策略的目标是为了保证系统任务得以完成,从基于效用原则的特征来看,AB策略可看成是启用访问的一个工具.如果没有基于效用原则的AB策略,一个空的访问控制状态便可满足任何SSoD策略的安全需求.同样,如果没有基于安全原则的SSoD策略,AB策略也能够被轻易满足.例如给系统中所有用户均授予所有权限,这就使得系统中任何用户都能够独立完成该任务.因此,在访问控制系统中AB策略可看作是对SSoD策略的天然补充.它们中的任何一种都不足以既包含安全需求又包含效用需求.然而当SSoD与AB策略并存时,安全与效用原则可能无法同时被满足.由于SSoD策略与AB策略相互间互斥的需求,可能会引发策略非一致性冲突问题.定义3.给定一个SSoD策略集合E和一个AB策略集合F,判定是否存在一个访问控制状态ε使得safeE(ε)∧satF(ε)为真,该问题被称为一致性检测问题(ConsistencyCheckingProblem,CCP).(1)safeE(ε)=∩e∈Esafe(ε),satF(ε)=∩f∈Fsatf(ε);(2)在访问控制状态ε下,safee(ε)为真表示e的安全性得到满足;satf(ε)为真表示f的效用性得到满足.令Q=E∪F,如果Q是非一致的,表示不存在一个可以令safeE(ε)∧satF(ε)为真的访问控制状态ε,也即Q中存在非一致性冲突.文献[13]研究了SSoD与AB策略并存所引发的策略一致性检测问题的计算复杂度,提出了该问题的计算复杂度在几种特殊情形下的评判标准,并证实了该问题在通常情况下以及几种子情形下是不可解问题(NP难度),并处于多项式谱(NPNP)中.CCP是不可解问题,意味着在最坏情形下解决该问题将要耗费巨大的时间开销.然而,在现实应用中会碰到很多实例依然可以找到有效的方法来解决.例如在SSoD与AB策略数量规模不大的情况下,依然存在有效的解决方法.本文的目标是针对发生了非一致性冲突的策略集合,且在该策略集合规模不是很大的情形下,探讨一种有效的策略冲突消解方法,使得策略非一致性冲突可以在合理时间范围内被有效地消解.4访问控制策略非一致性冲突消解方法4.1消解方法流程结构文献[13]提出了一种对SSoD策略与AB策略进行一致性检测的有效机制.其步骤主要包括:静态化简、前期处理、归约为SAT问题等.然而在实际应用中,仅仅完成对策略的一致性检测工作是远远不够的,如何在策略非一致性冲突发生的情形下进行冲突消解是一个迫在眉睫的问题.本文在该一致性检测方法的基础上提出了一种非一致性冲突消解方法,旨在当非一致性冲突发生时,能有效地调整策略集合,消解冲突,确保策略集合的一致性.本文的冲突消解方法主要包含如下步骤:(1)静态化简.在静态化简过程中,主要是排除不会破坏策略集合整体一致性的策略,减少需要检测的策略数目.给定一个策略集合Q={e1,e2,…,em,f1,f2,…,fn},其中ei=ssod〈Pi,Ui,ki〉(1im),fj=ab〈Pj,Uj,tj〉(1jn).满足以下情形的策略将不会影响到Q的一致性,故而无须考虑:②fj∈Q(Uj-S≠),其中S=∪m为Uj是AB策略fj存在的私有用户,则将fj排除出考虑范围.③根据文献[13],对于任意两个SSoD策略ei①ei∈Q(Pi-R≠),其中R=∪n为Pi是SSoD策略ei的私有权限,则将ei排除出考虑范围.Page5(3)归约为SAT问题.按照一定的转化规则,将CCP规约为SAT问题,调用成熟的SAT求解器Sat4J①,进一步提高计算效率.(4)消解前预处理.当发生了非一致性冲突之后,本文使用基于优先级的冲突消解方法.预处理过程中,首先需将“静态化简”阶段排除的非严格性策略重新加入到待检测策略集合当中,然后再针对整个策略集进行优先级计算.和ej,当且仅当(UiUj)∧(kikj+|Pi-Pj|)时,认为SSoD策略ei比ej严格,记作eiej,则可将ej排除出考虑范围.而对于任意两个AB策略fi和fj,当且仅当(P1P2)∧(U1U2)∧(t1t2),认为AB策略fi比fj严格,记作fifj,则同样可将fj排除出考虑范围.(2)前期处理.给定访问控制状态ε,若该状态存在很明显的特征,可以很容易地发现该状态不满足策略.例如,给定一个访问控制状态ε,一个可用策略集合F,对于每一个fi∈F,其中fi=ab〈Pi,Ui,ti〉,如果Pauth(u)Pi,那么我们可以得知状态ε不满足∪u∈Uifi.此阶段只是进行了简单的一致性判断,若发现存在非一致性冲突,则无需考虑该状态ε.(5)生成优先级队列.在对策略的优先级求解过程中,涉及到加权冲突面积(WeightedConflictArea,WCA)和自身可满足频率(Self-SatisfiedFrequency,SSF)两个概念.其中加权冲突面积旨在评估某一策略与其余策略之间的影响关系,而自身可满足频率则反映了策略本身的严格程度.①统计WCA.在权限用户指派矩阵犕[m,n]中,单元格M[i,j](1im,1in)代表着权限pi与用户uj之间的指派关系.根据策略所占用单元格的数量来评估该策略与其余策略之间发生冲突的可能性.给这些单元格分配相应的权重,通过统计单元格数目来表示WCA.②计算SSF.SSF是指策略在其权限集合和用户集合所形成的访问控制矩阵中,遍历所有的访问控制状态,其中能使该策略得到满足的状态数目与该矩阵中所有状态数目的比值.③生成优先级队列.按照如下公式计算优先级:优先级=加权冲突面积×(1-自身可满足频率).然后将策略按照优先级从大到小顺序依次进入队列,形成优先级队列.(6)选择策略调整方案.针对不同的策略目标,选择不同的解决方案.基于优先级的冲突消解方法,一般有最小代价法、字典编辑优选法等.针对不同的应用背景,每一种方法都存在自身优缺点.策略调整者可以根据自身的策略需求选择合适的消解方法,最后达成其策略目标.其中上述步(1)~(3)主要是完成了策略一致性检测工作,步(4)~(6)则是完成对策略非一致性冲突的消解工作.图1给出了具体的流程图示.4.2优先级排序方法一旦发生了非一致性冲突,为了确保策略集合的一致性,需要对策略进行调整.本文给每个策略赋予相应的优先级,并生成一个优先级队列.在优先级的计算过程中,主要考虑两方面的因素.一方面是单个策略对整个策略集合中其它策略的影响程度,另一方面则在于该策略自身的严格程度.如果该策略与其它策略发生冲突的概率较大,则其优先级设置较高;若该策略其自身严格性较高,则其优先级也较高,反之优先级则较低.文中以WCA来衡量策略与其余策略发生非一致性冲突的可能性.若某策略的加权冲突面积较大,则该策略与其余策略发生冲突①DanielLB.SAT4J:AsatisfiabilitylibraryforJava.URLPage6的可能性较高,对其余策略的影响力也较大,反之亦然.文中还给定SSF来衡量策略自身的严格程度.若某策略的SSF较低,则该策略的自身严格性较高,反之亦然.4.2.1计算加权冲突面积在表1的访问控制状态矩阵犕[1…8,1…8]中,表格中的列值表示权限,行值则表示用户.令pol1=〈{p1,p2,p3},{u1,u2,u3},2〉,pol2=〈{p2,p3,p4},{u3,u4,u5},3〉,pol3=〈{p3,p4,p5},{u2,u3,u4},2〉,pol4=〈{p6,p7,p8},{u5,u6,u7,u8},3〉.在状态矩阵中分别用不同的色度标注不同的策略,其中单元格中的数值表示占据该单元格的策略数目.Uu1111u211211u312321u4u5u6u7u8在一个访问控制状态矩阵中,每个策略将占据多个单元格;同时,一个单元格可能被多个策略所共用.如表1中访问控制状态矩阵犕[1…8,1…8]所示,pol2占据了9个单元格;与此同时,M[3,3]被pol1、pol2、pol3三者共用.当访问控制状态发生改变时,具体到一个单元格的状态发生改变时,势必影响到占用该单元格的每一个策略.某个策略与之相关的所有单元格被共用的频度越高,则在一定程度上反映该策略与其它策略发生冲突的可能性更大.例如,给定策略pol1和pol2,按照下面给出的策略的冲突面积计算方法,假设CW(pol1)>CW(pol2),分以下3种情形进行讨论:(1)pol1包含pol2中的所有用户和权限;(2)pol1与pol2的用户与权限的笛卡尔积没有交集;(3)pol1包含pol2中的部分用户和权限.对于情形(1),显然pol2与其它策略发生冲突,则pol1也必定会与其它策略发生冲突;对于情形(2),通常无法直接进行判断,但在很多种情形下可以间接说明pol1比pol2更容易与其它策略发生冲突.例如,与pol2相交的策略同时相交于pol1,则在相交策略数量较多的情形下,发生冲突的可能性更大.对于情形(3),将pol1与pol2各自的私有用户与权限取出,组成两个新的策略pol1和pol2,则问题又转入情形(2).每一个单元格,因为被共用的情况不同,其发生冲突的概率也不一致.从表1可知,单元格M[1,4]的赋值为真或假对策略集合无影响,因为它并不被任何策略所占用.但是单元格M[3,3]或者M[1,1]赋值情况发生改变时,必然会影响到策略集合的一致性情况.同时M[3,3]的改变带来的影响又要大于M[1,1]所带来的影响,即不同单元格存在着影响力权重的差异.本文通过统计的方式为每个单元格赋予了权重值,从而评估出每一个策略与其它策略发生冲突的可能性.将一个策略所占据的所有单元格权值相加,即得到了加权冲突面积.下面给出计算加权冲突面积的具体步骤.给出一个策略集合Q={e1,e2,…,em,fm+1,fm+2,…,fm+n},其中ei=ssod〈Pi,Ui,ki〉(1im),fj=ab〈Pj,Uj,tj〉(m+1jm+n).下面给出计算SSoD策略和AB策略的冲突面积权重方法.首先给出针对SSoD策略的权值统计矩阵犠SSoD[x,y]的统计方法,如下所述:(1)首先令P=∪m+n|U|,给矩阵犠SSoD[x,y]和犠AB[x,y]都赋初值为0,其中犠SSoD[x,y]是针对SSoD策略的权值统计矩阵,而犠AB[x,y]是针对AB策略的权值统计矩阵;(2)遍历策略集合{e1,e2,…,em},对于每一个SSoD策略ei=ssod〈Pi,Ui,ki〉,对于每一个(pa,ub)∈Pi×Ui,则对应的权值统计矩阵中犠SSoD[a,b]++;(3)遍历策略集合{fm+1,fm+2,…,fm+n},对于每一个AB策略fj=ab〈Pj,Uj,tj〉,对于每一个(pa,ub)∈Pj×Uj,则对应的权值统计矩阵中犠AB[a,b]++;(4)令权值统计矩阵犠[x,y]=犠SSoD[x,y]×(犠AB[a,b])T;(5)遍历策略集合{e1,e2,…,em,fm+1,fm+2,…,fm+n},令CW(poli)=0.对于每一个(pa,ub)∈Pj×Uj,令CW(poli)=CW(poli)+犠[x,y],其中CW(poli)表示SSoD或AB策略poli的冲突面积权重.4.2.2策略的自身可满足频率定义4.策略poli〈Pi,Ui,parami〉的自身可满足频率(Self-SatisfiedFrequency,SSF).它是指在策略本身所形成的一个小的|Pi|×|Ui|的状态矩阵中,策略可以满足的状态数目与所有状态数目的比率.其中总的状态数目为2|Pi|×|Ui|.Page7显然,若需要计算出策略poli自身可满足频率,必须先遍历其本身形成的一个|Pi|×|Ui|的状态矩阵,统计能使得poli可以满足的状态.基于不同的目标,SSoD与AB策略的检测方式并不完全一致,但是SSoD策略的检测可以转化为AB策略的检测.令ei=ssod〈Pi,Ui,ki〉,fj=ab〈Pj,Uj,tj〉.给定一个状态ε,safeei(ε)为真意味着在Ui中不存在少于ki个用户能够覆盖Pi中的所有权限,而satfj(ε)为真意味着在Uj中存在不多于tj个用户能够共同拥有Pj中的所有权限.明显,SSoD策略是AB策略的天然补充.如果Pi=Pj,Ui=Uj且ki=tj+1,当safeei(ε)为真,即意味着不存在少于ki个用户能够共同拥有Pi中的所有权限,而对应的satfj(ε)为假.反之,如果satfj(ε)为真,则safeei(ε)为假.因此,我们可以将SSoD策略检测问题看作是AB策略检测问题的补问题.在统计poli可满足状态数目的过程中,需要遍历|Pi|×|Ui|大小的状态矩阵,这是一个时间代价极高的过程.在每一个状态下,检测状态是否能满足poli策略,同样是一个时间复杂度极高的CCP问题.若通过遍历状态,逐一检测策略在状态下的满足情况的方法将是一个时间复杂度极高的问题.所幸的是,计算优先级的过程中不需要得到一个绝对精确的统计值.在研究过程中,我们发现策略自身可满足的状态数目与权限数目、用户数目、限制参数之间存在着一定的函数关系.本文通过在Matlab中求取拟合曲线的方式得到了相应的函数关系.上文已经论述了SSoD策略的检测可以转化为AB策略的检测,对应的函数曲线拟合将基于AB策略的检测结果.令fj=ab〈Pj,Uj,tj〉的自身可满足频率为SatCount(fj),其中权限数目m=|Pj|,用户数目n=|Uj|,参数t=tj.不失一般性,可以发现SatCount(fj)=fun(m,n,t),fun(m,n,t)表示一个三元函数.通过曲线拟合,发现存在如下规律:(1)当n,t固定时,fun(m,n,t)可拟合为一个关于m的指数函数.当n=3、t=2时,将m当作自变量,自身可满足个数当作因变量.通过统计的方法可以得到SatCount的相关数据,如表2中所示.首先根据AB策略的权限数量m,用户数量n,可计算出其对应的访问控制矩阵为m行n列,而对应的访问控制状态数量为2m×n,采用直接验证法,即遍历所有2m×n个访问控制状态,计算出能够否满足该策略的所有访问控制状态数量.例如表2中第1行,当m=3,n=3,t=2时,其对应的访问控制状态数量为64个,通过验证最后得到49个状态可满足该策略.将数据输入Matlab中,不难看出,点的分布极为符合指数分布.因而,本文使用了指数函数作为拟合函数,并得到如图2所示的结果.从上述结果可以发现,SSE(和方差)和RMSE(均方差)都远远小于SatCount中的最大值;同时,R-square(拟合系数)和Adjusted-R-square(调整后的拟合系数)都是1.以上的结果数据表明拟合实验极其成功.故可得出结论:当用户个数n和限制参数t固定时,策略的自身可满足个数SatCount可视为一个关于权限个数m的指数函数.mntSatCount23456789(2)当m,t固定时,fun(m,n,t)拟合为一个关于n的指数函数.当m=2、t=2时,将n当做自变量,SatCount当做因变量.通过统计的方法得到了SatCount的相关数据,具体如表3所示.该数据集在坐标轴上也符合指数分布.本文对其数据集合在Matlab上进行了拟合,得到如图3的结果.mntSatCount2222222Page8从拟合结果可以看出该拟合实验也非常成功.在经过多组实验数据进行拟合以后的结果表明指数函数的拟合是成功的.故可得出结论:当权限个数m和限制参数t固定时,策略的自身可满足个数SatCount可视为一个关于用户个数n的指数函数.图4m和n为自变量时的拟合结果表5显示了当t=3和t=4时对应的拟合结果.通过上述拟合结果,可以计算出对应的策略自身可满足个数值SatCount(fj).计算出SatCount(fj)后,自身可满足频率psat(fj)=SatCount(fj)/2|Pi|×|Ui|.根表5狋′为定值时的拟合结果求解公式t3fit=@(q,M)q(1)×exp(q(2)×M(:,1)+q(3)×M(:,2));q=nlinfit([x,y],z,f,[111])q=3.1931E-0050.76172.87564fit=@(q,A)q(1)×exp(q(2)×A(:,1)+q(3)×A(:,2));q=nlinfit([x,y],z,f,[111])q=3.8771E-0052.97032.6092大.而对于AB策略fj=ab〈Pj,Uj,tj〉,随着tj值的4.2.3计算策略的优先级减少,fj的自身可满足频率也随之降低.加权冲突面策略的加权冲突面积衡量的是该策略与其它策积只考虑到策略的用户集U和权限集P,并未考虑略发生非一致性冲突的可能性,而策略的自身可满到策略的参数param,而param在一定程度上正好足性衡量的是策略自身的严格程度,对于SSoD策反映的是策略的自身可满足性.因此,计算策略的优略ei=ssod〈Pi,Ui,ki〉,随着ki值的增长,ei的自身可满足频率降低,与其它策略发生冲突的可能性增先级需要综合考虑加权冲突面积和自身可满足性.为(3)当t固定时,fun(m,n,t)拟合为一个关于m,n的二元指数函数.经过上述的拟合实验可以发现fun(m,n,t)对于m,n的偏导函数都是指数函数.根据函数关系可以推断,当t固定时,fun(m,n,t)是m和n的二元指数函数.通过统计的方法得到了对应SatCount的相关数据值,如表4所示.当t=2时,使用二元的指数函数作为模型,得到了如图4所示的实验结果(采用非线性回归函数nlinfit对3个变量x,y,z进行曲线拟合).mntSatCountmntSatCountmntSatCount2229352294015321497723249362247947542667755242225422815522575104252961432226956291903308326239694424764962272932227452880741632971893323374621524956164291412253423315522243652734608021据之前的转化规律,可有SSoD策略ei=ssod〈Pi,Ui,ki〉的自身可满足性个数SafeCount(ei)=2|Pi|×|Ui|-SatCount(fi),其中fi=ab〈Pi,Ui,ki-1〉.自身可满足频率psafe(ei)=SafeCount(ei)/2|Pi|×|Ui|.Page9了计算方便,本文给出了一个简单的优先级计算公式:优先级=加权冲突面积×(1-自身可满足频率).具体而言,针对SSoD策略ei,prior(ei)=CW(ei)×(1-psafe(ei));针对AB策略fj,prior(fj)=CW(fj)×(1-psat(fj)),其中CW表示加权冲突面积,psafe(ei)、psat(fj)分别表示SSoD策略和AB策略的自身可满足频率.按照prior(pol)的大小排序,每次将优先级最大的策略依次入队,可得到一个优先级队列.其队头为优先级最高的策略,队尾为优先级最低的策略.4.3基于优先级的冲突消解方法优先级在基于知识的系统研究中十分重要,策略之间非一致性冲突的消解可以借助于优先级方法得到一个更佳的解决方案.令已有的优先级队列为Queuepol={pol1,pol2,…,poln},其中有prior(poli)prior(poli+1),1in-1.在基于知识的系统中,策略的调整总是依赖已经获取的知识体系.针对不同的策略目标,策略制定者可以选择不同的冲突消解方法.本文给出了基于最小代价法和字典编辑优选法的策略冲突消解方法.前者着重于整个冲突消解的时间消耗最小化,后者则着重于策略删除数目的极小化,并在最大程度上降低策略集合的安全与效用损失.4.3.1最小代价方法依次删除优先级队列中的队头(即优先级最高的策略),使得余下的策略数目最大化,同时保证余下的策略不发生非一致性冲突.该算法的描述如算法1所示.算法1.最小代价方法(在最小的时间代价中完成消解工作).输入:具有优先级的策略队列Queuepol//pol表示策略,其中优先级队列中优先级从大到小排列输出:一致性集合Setcp//Setcp表示一致性的策略集合while(notqueueEmpty(Queuepol))doifnotcons(Queuepol)thenendifendwhilewhile(notqueueEmpty(Queuepol))dopol=outQueue(Queuepol);put(pol,Setcp);//put()将策略pol放入结果集set中endwhilereturnSetcp从算法1中不难看出,该算法的时间复杂度主要取决于策略一致性检测的计算开销.在文献[13]中,已经论证了CCP在最坏的情形下是NPNP问题.最好的情形下,CCP的时间复杂度为P级别.在最好情形下,算法1的时间复杂度最低,也同为P级别.在最坏的情形下,算法1的时间复杂度则是一个NPNP级别.为了最大程度上减少冲突发生的可能性,算法1每次删除优先级最高的策略.一个策略的优先级越高,则其对其它策略的影响力越大,同时其本身不易被满足.非一致性冲突的发生往往是因为策略集合中存在着这样的策略.一旦这些策略被删除,则剩余的策略则可以保持一致性.算法1中,每删除一个策略之后,就对余下策略进行一致性检测,其时间代价主要消耗在对一致性的检测上.相对其它传统算法而言,算法1减少了迭代的次数,故而,该算法的计算开销将大大降低.不足之处在于,此类消解方式未考虑到策略中安全和效用的损失程度,因而该算法适用于对实时性需求较高的大型访问控制系统.4.3.2字典编辑优选方法将优先级队列按照优先级从低到高重新排序,每次从队列中选取一个策略,形成具有一致性的策略集子集.若前x个策略形成了一致性策略子集,第x+1个策略与策略子集发生了非一致性冲突,舍弃第x+1个策略.继续从队列中选择第x+2策略,直至遍历完整个优先级队列为止.该算法的描述如算法2所示.算法2.字典编辑优选方法(在考虑时间代价的同时兼顾安全与效用的损失).输入:具有优先级的策略队列Queuepol输出:一致性集合Setcp//Setcp表示一致性策略集合Initialize;//导入堆栈中,使得优先级顺序逆转while(notqueueEmpty(Queuepol))dopol=outQueue(Queuepol);push(pol,Stackpol);//将策略pol推入栈Stackpol中endwhile//初始化,将一个策略出栈,置入结果集Setcp中pol=pop(Stackpol);//出栈put(pol,Setcp);//将策略推入结果集中while(notempty(Stackpol))dopol=getTop(Stackpol);//取栈顶元素ifcons(pol,Setcp)then//cons()表示pol加入Setcp中是否一致,一致时//返回truepol=pop(Stackpol);//出栈put(pol,Setcp);//进入结果集endifendwhilereturnSetcpPage10在算法2中,其时间复杂度依然取决于对策略集合的一致性检测,故而其时间复杂度也是NP级别.相对于算法1而言,因为该算法需遍历完整的策略队列,故而迭代次数更高.若某个状态ε使得策略集合POL={pol1,pol2,…,poln}保持一致性,则必有ε可以使得任一POL的子集保持一致性.在算法1中,假若删除了Queuepol中前k条策略,最终得到了一致性策略集合Set1={polk+1,polk+2,…,poln}.在算法2中,首先经过了优先级反转,然后将poln,poln-1,…,polk+1依次加入待检测集合中.因此,在前n-k-1次检测中,其检测结果必然表现出一致性.此时算法2并未结束,它继续把polk,polk-1,…,pol1等策略加入待检测集合中,最终得到一致性策略集合Set2.经上述分析可以发现,有Set1Set2.故可知算法2的结果集策略数目不少于算法1结果集中的策略数目.设有策略pol∈(Set2-Set1),若pol是SSoD策略,则在算法2中的安全损失较算法1中更优.同理若pol是AB策略,算法2的效用损失较算法1也更优.该算法比较适合对安全与效用需求较严格的中小型规模的访问控制系统.具体的安全损失与效用损失的量化方法可参照文献[16],安全损失与效用损失的量化主要是通过对比策略之间的严格性来实现.在通常情形下,安全与效用不具备直接可比性,给定一定数量的候选被删除策略集合,通过评估删除每一个集合所造成的安全损失Loss_S以及效用损失Loss_U.于是便可以得到二元组(Loss_S,Loss_U)的集合,每一个这样的二元组对应相应的解决方案,进而可实现对不同解决方案之间的优化比较.本文采用文献[16]所给出的计算策略来度量安全性和效用损失:Loss_S(e)=rank(e)令Q={e1,e2,e3,e4,e5,e6,e7,e8,e9,f1,f2,f3,f4,f5,f6,f7,f8}e1=ssod〈{order,note,examine,invoice,invoicecheck},{Alice,Bob,Carl,Doris,Eric},4〉e2=ssod〈{order,note,invoice,invoicecheck,pay,review},{Alice,Bob,Carl,Doris,Eric},2〉e3=ssod〈{order,note,examine,invoice},{Alice,Bob,Doris,Eric},3〉e4=ssod〈{note,examine,invoice,invoicecheck,review},{Alice,Bob,Eric,Fox,George,Haley},5〉e5=ssod〈{order,examine,invoice,pay},{Alice,Bob,Carl,Doris},2〉e6=ssod〈{order,note,invoicecheck},{Alice,Bob,Carl,Doris,Eric},2〉e7=ssod〈{note,examine,invoice},{Bob,Carl,Eric},3〉e8=ssod〈{note,examine,invoice,invoicecheck},{Alice,Bob,Carl,Doris},4〉e9=ssod〈{note,invoice,invoicecheck},{Bob,Carl,Eric},3〉f1=ab〈{order,note,examine,invoice,invoicecheck},{Alice,Bob,Doris,Eric},3〉f2=ab〈{order,note,invoicecheck},{Alice,Bob,Carl,Doris,Eric,Fox},3〉f3=ab〈{order,note,examine,invoice,invoicecheck,consignment,commoditycheck},{Alice,Bob,Doris,Fox,Ivan,Jack},6〉f4=ab〈{order,examine,invoice,invoicecheck},{Alice,Bob,Carl,Doris,Eric},3〉f5=ab〈{examine,invoice,invoicecheck},{Bob,Carl,Eric},2〉f6=ab〈{order,note,examine,invoice,invoicecheck},{Alice,Carl,Doris},2〉f7=ab〈{note,examine,invoice},{Bob,Carl,Doris,Eric},3〉f8=ab〈{note,examine,invoice,invoicecheck},{Alice,Bob,Carl,Eric},1〉图5访问控制策略全集其中,rank(e)表示SSoD策略e在SSoD策略集合E中的优先级;同理,rank(f)表示AB策略f在AB策略集合F中的优先级.5仿真实验及性能分析为了对本文所提出的策略非一致性冲突消解算法的时间消耗、安全效用的损失等多方面性能进行验证,我们选择了在英特尔CeleronG530@2.40GHz双核处理器、内存为DDR22GB667MHz、运行WindowsXPProfessional系统的PC机上进行仿真实验.该实验模拟了一个商品订购系统中出现策略冲突后对该策略集合进行冲突消解的过程,并对实验结果进行了相应的性能分析.5.1商品订购实例本文在Clark和Wilson[17]所提出的订购和支付商品的任务的基础上设计了一个商品购买的任务,该任务中共有10个步骤:①订购商品记录;②记录商品的订购信息;③查看商品订购信息;④开具发票并记录商品订购信息;⑤验证发票真伪;⑥根据发票向商家付款;⑦向订购者发货;⑧验证商品真伪;⑨对商品进行评论;⑩推荐已订购的商品.基于上述任务,假定该任务中的每一个步骤对应着一个权限,则可以将权限设置为order,note,examine,in-voice,invoicecheck,pay,consignment,commodity-check,review,recommend.假定有10个用户来完成整个任务,这10个用户分别是Alice,Bob,Carl,Doris,Eric,Fox,George,Haley,Ivan,Jack.为了保证任务得以有效地完成,同时又能有较高的安全性,策略制定者制定了一套访问控制策略.图5中即是所制定的策略集合,该集合共有9个SSoD策略,8个AB策略.例如其中的SSoD策略Page11e1=ssod〈{order,note,examine,invoice,invoice-check},{Alice,Bob,Carl,Doris,Eric},4〉,表示在Alice、Bob、Carl、Doris、Eric这5个用户中须至少4个用户才能共同拥有order、note、examine、invoice、invoicecheck这几个权限,即不存在3个用户共同拥有这些权限.AB策略f1=ab〈{order,note,ex-amine,invoice,invoicecheck},{Alice,Bob,Doris,Eric},3〉则表示在Alice、Bob、Doris、Eric这4个用户中须有至少3个用户共同拥有order、note、exam-ine、invoice、invoicecheck这些权限.5.1.1一致性检测一致性检测主要分为3个步骤:静态化简、前期处理和归约为SAT问题.其中在静态化简过程中,需要进行两个方面的化简:(1)排除存在私有权限的SSoD策略和拥有私有用户的AB策略.e2和e4都拥有私有权限review;f3拥有私有用户Jack;f2拥有私有用户Fox.由于这些策略不影响策略集合的一致性,故而将它们排除.(2)排除严格性较低的策略.由严格性判断条件可知,存在着严格性关系e1e3,e1e6,即e1比e3和e6严格.当e1存在时,e3和e6的存在不影响策略集合的一致性,将其从待检测策略集中排除.若一旦发生非一致性冲突,在冲突消解的过程中需要重新将e3和e6加入待检测的策略集合中.在此约定,Qi表示第i次策略调整后得到的待检测策略集.令Q1={e1,e5,e7,e8,e9,f1,f4,f5,f6,f7,f8}.在经过静态化简以后,策略集Q1中的策略数目明显减少了.紧接着,进行前期处理和SAT问题归约化等检测工作.因为本文的重点在于策略非一致性冲突的消解工作,故不对检测工作多做介绍.具体的检测方法可参考文献[13].5.1.2非一致性冲突消解代价为1884s.经过检测,Q1中策略出现非一致性冲突,时间(1)消解前预处理.将因为策略间严格性约束关系而被排除的SSoD策略e3,e6重新加入待检测策略集,有Q2={e1,e3,e5,e6,e7,e8,e9,f1,f4,f5,f6,f7,f8}.(2)生成优先级队列.由表6中的数据信息可有优先级队列Q3={e1,f8,e8,e3,f6,e7,e9,e6,f1,f5,f7,f4}.策略e1f8e8e3f6e7Prior790.556528.130497.858408.322287.946261.834策略e9e6f1f5f7f4Prior259.121255.876205.056142.83594.10690.651(3)选择策略调整方式.小代价方法,另一种是字典编辑优选方法.在文中给出了两种策略调整的方式:一种是最①最小代价方法.(a)删除e1,得到Q4={f8,e8,e3,f6,e7,e9,e6,f1,f5,f7,f4}.发生非一致性冲突,时间代价为1209s.(b)删除f8,得到Q5={e8,e3,f6,e7,e9,e6,f1,f5,f7,f4}.发生非一致性冲突,时间代价为1427s.(c)删除e8,得到Q6={e3,f6,e7,e9,e6,f1,f5,f7,f4}.可得到一致性状态,详见表7,时间代价为135s.UAlice0010Bob1001Carl0110Doris1100Eric1100(d)将不影响策略集合一致性的策略e2,e4,f2,f3加入最终的集合.可以得到Q7={e3,f6,e7,e9,e6,f1,f5,f7,f4,e2,e4,f3,f2},Q7是最终得到的保持一致性的结果集.②字典编辑优选方法.将优先级队列反转后,形成优先级从小到大的队列Q={f4,f7,f5,f1,e6,e9,e7,f6,e3,e8,f8,e1},从Q中选择策略,形成一致性的策略子集.(a)选取策略子集,有Q1={f4,f7};(b)选择f5,得到Q2={f4,f7,f5};(c)选择f1,得到Q3={f4,f7,f5,f1};(d)选择e6,得到Q4={f4,f7,f5,f1,e6};(e)选择e9,得到Q5={f4,f7,f5,f1,e6,e9};(f)选择e7,得到Q6={f4,f7,f5,f1,e6,(g)选择f6,得到Q7={f4,f7,f5,f1,e6,e9,e7,f6};(h)选择e3,得到Q8={f4,f7,f5,f1,e6,e9,e7,f6,e3}.表8是步(a)~(h)中得到的一致性状态,其中Qi表示步骤中对应得到的策略集合,其后则是对应的每一次检测所消耗的时间,以s为单位.e9,e7};Page12Q1152sQ2178sQ3182sQ4106s1000001000010000100010000Q5121sQ696sQ7125sQ8165s1000000010010000100001000(i)选择e8,得到Q9={f4,f7,f5,f1,e6,e9,e7,f6,e3,e8}.发生非一致性冲突,时间代价为1275s.(j)删除e8,继续选择f8,得到Q10={f4,f7,f5,f1,e6,e9,e7,f6,e3,f8}.可得到Q10的一致性状态,该状态与Q6的一致性状态一致,详见表9,时间代价为115s.UAlice0010Bob1001Carl0110Doris1100Eric1100(k)继续选择e1,得到Q11={f4,f7,f5,f1,e6,e9,e7,f6,e3,f8,e1}.发生非一致性冲突,时间代价为1864s.(l)删除e1,将不影响一致性的策略e2,e4,f3,f2重新加入最终集合,得到保持一致性的结果集为Q12={f4,f7,f5,f1,e6,e9,e7,f6,e3,f8,e2,e4,f3,f2}.5.2性能评估本文提供了一套策略优先级的评估方法,并以此提出了两种基于优先级的策略冲突消解算法,一种是最小代价方法,另一种是字典编辑优选方法.这两种基于知识的冲突消解算法可以使策略制定者能够快速、有效地消解冲突.表10和表11显示了两种方法的部分性能结果.如表10所示,选择最小代价方法进行冲突消解时,需要3次消解过程,总的时间开销为2761s.每次消解工作则对应着一次一致性检测,需要检测的策略个数逐步减少,合计有30个策略.表11中是字典编辑优选方法的部分性能结果,其中需要进行12次消解,时间代价为4379s,是前者的1.58倍.每一次检测中的策略个数逐步递增,合计有76个策略,是前者的2.53倍.由前文的推导可知,策略的优先级与其安全性或效用性存在着正相关关系.如4.3.2节所述,本文将不具体讨论安全性和效用性的量化问题.为了有效地对比两种消解方法的区别,此处简单地用优先级来代表策略的安全性或是效用性.从表格中可以发现,虽然后者的时间消耗上较多,然而其安全与效用损失却相对较少,约为前者的72.99%.删除策略策略个数时间/sLost-e1-f8-e8Total增加策略策略个数时间/sLost+f4+f7+f5+f1+e6+e9+e7+f6+e3+e8+f8+e1Total6结束语本文针对静态职责分离(SSoD)策略和可用(AB)策略共存时因互斥需求可能引发策略非一致性冲突问题,提出了一套冲突消解方法.该方法由3个步骤组成:首先,进行冲突消解前预处理,将检测阶段排除的某些非严格的策略重新加入策略集合中.然后,生成优先级队列,优先级的生成主要源于加权冲突面积(WCA)和自身可满足性频率(SSF).最后,给出了两种冲突消解算法:最小代价方法和字典编辑优选方法.最小代价方法的优势在于时间开销较小,适用于对实时性需求较高的大型访问控制系统.字典编辑优先方法的优势在于策略集整体的安全和效用损失较小,适用于对安全与效用需求较严格的中小型访问控制系统.在冲突消解过程中,涉及到安全与效用的损失问题,本文并未对其进行深入的量化工作.将安全性和效用性进行量化,可以帮助策略制定者制定有效Page13的策略目标,对非一致性冲突的消解提供有效的指导.此外,在自身可满足频率的计算过程中,只讨论了策略自身可满足状态数目SatCount(pol)与权限数m、用户数n两个参数之间的函数关系.对于SatCount(pol)和限制参数t之间,本文未能给定一个确切的函数关系.在下一步研究工作中,我们将涉及策略安全与效用的量化问题以及SatCount(pol)与(m,n,t)的三元函数关系等方面.
