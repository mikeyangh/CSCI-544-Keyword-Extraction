Page1基于Prüfer序列的RDF数据索引与查询刘翔宇1)吴刚2),3)2)(医学影像计算教育部重点实验室(东北大学)沈阳110819)1)(东南大学计算机科学与工程学院南京210096)3)(东北大学信息科学与工程学院沈阳110819)摘要语义Web作为数据之网不断汇集并组织Web信息,相关应用因此面临着对语义Web所含大规模RDF数据高效访问的挑战.建立有效的索引机制是提升RDF数据管理和查询性能的一种解决之道.序列式索引既能够支持存储空间压缩又便于采用成熟的序列匹配技术进行数据处理,具有较好的查询处理性能.文中扩展Prüfer序列以支持RDF数据上的索引和查询,实现了名为Prig的原型系统.实验比较并分析了该系统与对比系统在LUBM和SP2Bench两个测试基准上的实验结果,指出扩展的Prüfer索引在大规模RDF数据上有着比对比系统更好的查询处理性能.关键词RDF;Prüfer序列;索引;查询1引言学界和工业界在内的研究人员的关注.语义Web中的数据是以RDF(ResourceDescriptionFramework)①数据的形式进行表示的.RDF提供了灵活的数据模型以用于表达数据之间的关系.基于这种模型的语义Web[1]作为下一代Web正越来越受到包括Page2数据提供了人和机器均易于理解的语义.本质上RDF数据是一个巨大的有向图.在这个图中,每个现实世界中可以标识的实体都是一个结点,两个实体之间的相互关系可以看作是连接这两个实体的带标记的有向边.RDF数据模型在提供这种灵活而强大的能力的同时也带来了数据存储和处理复杂度提高的问题.如何高效地存储和查询大规模的RDF数据一直是语义Web数据管理中的难题.建立有效的索引机制是提升RDF数据管理和查询性能的一种方法.序列式索引既能够支持存储空间压缩又便于采用成熟的序列匹配技术进行处理,具有较好的查询处理性能.考虑到Prüfer序列化①方法能够有效图1Prig整体架构本文将首先介绍RDF数据模型、SPARQL查询语言②与Prüfer序列化方法,之后介绍RDF数据管理和序列化相关的工作,第4节详细论述实现数据和查询序列化的方法;第5节论述相应的匹配规则;第6节给出实验结果并加以分析;最后对本文工作总结.2RDF数据模型与SPARQL查询语言2.1RDF数据模型RDF的基本构成是以三元组〈subject,predicate,object〉形式存在的对资源的陈述(statement).每一个三元组包括一个主语(subject)、一个谓语(predicate)和一个宾语(object).三元组的集合称为RDF图.RDF图可以通过带有标签的结点和带有标签的边表示,其中每一个三元组对应为图上的一个“结点-边-结点”的子图,陈述了由谓语表示的在主语和宾语所指的事物之间的关系[3].一个RDF图的结点就是它包含的所有三元组的主语和宾语,而边的方向总是指向宾语.通常可以把RDF图看作一个有向标记图.如图2所示.地支持树形结构数据的索引和查询处理[2],但尚不能支持图数据的索引和查询处理,本文提出了一种扩展Prüfer序列化的方法,设计并实现了名为Prig(PrüfersequencesforIndexingGraph)的原型系统以支持对RDF图数据的相应处理.与索引和查询树形结构数据类似,Prig系统将RDF数据解析成RDF图,然后利用扩展的Prüfer序列化方法生成RDF图序列,并进行索引;RDF查询语句被转换为查询子图,同样生成扩展的Prüfer序列;通过匹配查询子图序列与原RDF图序列以及后处理操作,即可得到查询结果.系统架构如图1所示.RDF图的含义就是其所有三元组陈述的合取.例如如下三元组集合表示的RDF图的含义是:XXX是一名教授,他在University1工作,他是Department1的成员,Department1是University1的一个下属机构.〈XXX,rdf:type,Professor〉,〈XXX,worksFor,University1〉,〈XXX,memberOf,Department1〉,〈Department1,subOrgnizationOf,University1〉.2.2SPARQL查询语言SPARQL(SimpleProtocolandRDFQueryLanguage)是目前W3C(WorldWideWebConsor-tium)针对RDF查询语言的推荐标准,它定义了RDF查询语言的语法和语义.例如,“查询工作于University1并且是Department1成员的教授”,可①②Page3以构造如下SPARQL语句:SELECT?xWhere{?xrdf:typeProfessor.以上SPARQL查询可用图3直观表示.三元组模式的集合,称为基本图模式(basicgraphpattern).三元组模式类似于RDF三元组,不同之处在于主语、谓语和宾语可以是变量.一个基本图模式匹配RDF数据图的一个子图,其条件是子图中的RDF术语(统一资源标识符、字面量、空白结点)可以被变量置换,置换结果和原基本图模式等价.2.3Prüfer序列化方法Prüfer序列化是一种通过每次删除树上的一个结点来构造一个序列的方法.构造序列的一般方法是对树进行后根顺序遍历,删除叶节点的同时记录删除结点的双亲结点,从而生成相应序列.Prüfer序列中的每个元素与树上的每个结点一一对应.如图4所示的树对应的Prüfer序列是:(B,3)(B,3)(A,7)(B,6)(B,6)(A,7).扩展的Prüfer序列[2]的方法被应用于XML数据的索引语查询,其生成方式与标准的Prüfer序列生成方式类似,只是在序列化之前,先为树中的每个叶子结点添加一个空节点作为子节点,然后生成Prüfer序列.这样能够将叶子结点也纳入序列中.在实现中,序列通常被分为两部分,一部分为标签序列LPS(LabelPrüferSequence),另一部分为数字序列NPS(NumberPrüferSequence).上图中,结点旁标记的字母A,B,C为标签名称,1,2,3,4,…是用来唯一标识结点的标记.LPS就是记录结点的这些信息的序列,NPS则记录了相应的数字标记信息.对于大多数查询而言,只需提供待查的标签名称,要求系统返回相应的数据,通过LPS可以确定可能的候选结果,进而利用NPS剔除错误结果,返回正确结果.对于上图的例子,采用扩展的Prüfer序列化方法生成的LPS和NPS如下:LPS:C,B,A,B,A,A,B,B,B,A;NPS:1,3,2,3,7,4,6,5,6;7.3相关工作3.1RDF数据管理目前RDF数据的存储和查询工具主要有Sesame[4]、Jena[5]、3Store[6]以及RDFStore[7]等.Sesame是一个独立于存储的支持SPARQL查询的系统,采用图匹配的方法,支持语义Web上的数据查询.3Store在数据存储的层面上采用了MySQL数据库,主要关注于交互式的查询性能和数据导入时间.在Jena中,数据的存储可以采用多种的后台数据库,但大多数情况下采用简单的关系数据库:对Statement、URI和Literal分别建立数据表.这些工具作为目前RDF数据管理的主要工具,为语义Web的发展奠定了基础,但是也存在一些问题:(1)RDF数据不能直接在关系数据库中存储和查询.通常需要使用中间层转换工具将SPARQL查询转换为SQL查询,这样大大地降低了系统的性能.(2)一些工具,例如Jena采用将RDF数据中的元素分类存储的办法,这虽然避免了使用中间层处理,但是带来了大量连接操作,导致系统性能下降.后续的改进方案中,Jena在其存储中使用更加详细的表模式,这样又带来了存储开销增加的问题.在本文所提出的Prig系统中将使用Sesame作为性能比较的基准.选择Sesame对比的主要原因是考虑到Sesame采用的处理方法代表了传统的RDF数据处理方式:基于Triplestore,使用大量的三元组选择/连接操作完成SPARQL查询,可能会导致系统性能较低,而Prig则针对这一问题进行了另一种方式的探索.3.2Prüfer序列在文档匹配中的应用采用Prüfer序列化方法进行文档匹配的研究工作主要集中于对树形结构的XML文档的匹配.ViST[8]是一种将XML文档以及twig查询编码为一个序列的方法.该序列是一个二维结构:{(a1,p1),(a2,p2)……},其中ai是结点元素,pi是到ai的路径信息,通过路径的信息实现对XML数据的查询匹配.在最坏情况下,存储空间复杂度为O(n2),且查询结果集中存在错误结果.PRIX[2]通过将树形结构的XML文档生成LPS(LabelPrüferSequence)和NPS(NumberPrüferSequence),利用Page4序列中元素之间的一致性和间距等特性进行查询和结果集过滤,返回最终结果.基于PRIX,Prasad等人[9]提出了一种变化的Prüfer序列化方法,生成相应序列,并对原有的树形XML文档进行分层,进一步优化查询效率,一次性返回正确的结果集.Prüfer序列还应用于本体匹配领域,将本体语义信息采用Prüfer序列化方法表示,进而进行相应的匹配[10].现有的方法不能直接应用于图数据的处理,当然也无法直接用于处理RDF图数据.这主要是由于以下问题决定的:(1)对于图中的边含有标记信息的情况下匹配难以处理.(2)匹配算法对于RDF图的特点缺少具有针对性的解决策略,造成匹配算法运行时间开销的增加.在对RDF图进行的查询中,经常有一些查询包含了对结点的约束信息,这些查询如果用一般的图模式匹配方法会造成较大的开销,进而影响系统的性能.在Prig中,根据RDF图的特点改进Prüfer序列方法生成并匹配序列,可以有效降低系统开销,提高系统性能.有关图的管理和挖掘的相关知识,可以参见文献[11].4RDF图和查询子图的序列化4.1问题定义在Prig系统中,RDF图和查询子图被分别转换为Prüfer序列,然后通过采用序列匹配为方法完成图的查询匹配.为此我们给出如下定义.定义1.全图Prüfer序列.RDF图G经过Prüfer序列化方法生成的Prüfer序列称为全图Prüfer序列,记为SG.|SG|表示序列的长度,即序列中元素的数量.用SGi表示序列中第i个元素,其中1i|SG|.在本文中如果不特别指明,将全图Prüfer序列简称为全图序列.定义2.查询子图Prüfer序列.由查询子图经过Prüfer序列化方法生成的Prüfer序列称为查询子图Prüfer序列,记为SQ.|SQ|表示序列的长度,即序列中元素的数量.用SQi表示序列中第i个元素,其中1i|SQ|.在本文中如果不特别指明,将查询子图Prüfer序列简称为查询序列.定义3.基于Prüfer序列匹配的查询.依次从SQ中自左至右选取元素SQi,根据匹配规则从SG中选取相应元素,完成整个序列匹配的过程.对于SQi(1i<|SQ|),若存在SGj与之匹配,则SQi+1其候选结点自SGj之后继续开始查找.定义4.查询结果Prüfer序列.由满足查询条件的SG中的结点构成的序列称为结果Prüfer序列,记为SA.|SA|表示序列的长度,即序列中元素的数量.用SAi表示序列中第i个元素,其中1i|SA|.在本文中如不特别指明,将查询结果Prüfer序列简称为结果序列.SA中的所有元素均由SG中的元素组成并保持了其在SG中的相对位置,因此SA是SG的子序列.除以上定义外,我们还做如下规定:若没有指明具体使用哪一种序列,则将直接使用S表示以上任意一种Prüfer序列,序列中的元素相应记为Si.对于以上序列中元素所对应的图上结点的入度和出度分别记为di()和do(),例如查询序列中元素i对应结点的入度可以记为di(SQi).序列对应图的出边集合用Eo()表示,例如全图序列SGi对应图的出边集合记为Eo(SGi).4.2RDF图转化为Prüfer序列将RDF图转化为Prüfer序列主要面临以下几方面的问题.首先,在树形结构中生成Prüfer序列要求结点上有全局标签(label)信息,用于标识结点所属的类别,多个节点可以具有相同的全局标签.RDF图中这种类别信息则是通过三元组来表示的.RDF图中结点上的标签则唯一标识结点的标记,但无法表示结点所属的类别.为了能够利用Prüfer序列方法,需要相应将三元组表示的信息转化为结点上的全局标签信息.其次,Prüfer序列起初应用于树形结构.对于图的一个结点允许有多个双亲结点,其结构较之于树形结构更为复杂.因此,在序列化过程中,记录结点的双亲结点也存在一些问题.例如,在图5中,结点course1存在graduatestudent1和profes-sor2等4个双亲结点,与此同时,graduatestudent1又是professor2的双亲结点,这种层次上的混乱在树中是不会出现的.针对树形结构构造的Prüfer序列所具有的一系列性质,很大程度上是由于单一的双亲结点对孩子结点在序列中的位置进行了分割[2].图中多双亲关系的存在,弱化了这些性质,使得后续在剔除错误候选结果时很难利用这些性质.此外,RDF图的边具有标签信息.传统Prüfer标记方法中并未考虑树形结构中结点之间边的标签信息.展Prüfer序列化方法来解决以上问题.Prig提出了一种针对图(特别是RDF图)的扩Page5针对缺少全局标签的情况,Prig中采取的方法是将RDF图中所有的以rdf:type为谓语的三元组中宾语的URI作为主语结点的全局标签.本文称之为“一般化处理”.为了便于描述,首先将图5中的rdf:type信息(例如:GraduateStudent)、实体信息(例如:graduate1)以及边信息(例如:takesCourse)等分别规定其简写形式并赋予其id.具体如表1~3所示.如无特别指明,本文以后提到的全局标签和边标签将均用简称表述.在RDF中,rdf:type用来说明某个实体是某个类的一个实例.以图5为例,graduateStudent1,professor1以及course1的rdf:type分别为Graduate-Student,Professor和Course;经过一般化处理将结点的rdf:type信息作为结点的标签.然而RDF图中并非所有结点都有类信息.对于这部分结点,在查询处理中不得不匹配任何待查询的标签.Prig将此类结点的标签统一设为ANY_LABEL.经过一般化处理的RDF图如图6所示.对于结点可能存在多个双亲结点的问题,则采用合并双亲结点的方法进行处理:记录每个待删除结点,将其所有双亲结点的集合视为一个合并后的结点,并记录在删除结点之后.为了便于描述,称合并后的双亲结点为一个bag.以图6为例,为了能够记RDF图中的所有结点的信息,扩展的Prüfer序列化方法在1之前添加一个空节点,采用深度优先拓扑排序的方式删除相应结点记录双亲结点,生成Prüfer序列如表5中NPS栏所示.为了支持边具有标签信息这一情况,Prig采用在删除结点记录双亲结点的同时记录边上标签的方法.这部分信息也记录在bag中.例如,对于图6而言,删除结点1时,记录为1(sB:2tc:3sB:5tc:4).通过以上方法可以将Prüfer序列化方法扩展应用于RDF图的序列化.其中,在本文中序列元素的定义不包含所记录的双亲结点信息和边标签信息,即不包含记录在序列中括号内的相关信息.因此,由定义1或2可知,序列的长度等于RDF全图或查询子图中结点的数量.同时,序列中的元素与图中的结点之间具有一一对应关系,在本文中不特殊说明的情况下可以替换.下面给出RDF图转化为Prüfer序列的一般步骤.算法1.将RDF图转化为Prüfer序列的算法.输入:一个RDF图G=V×E,其中V是顶点的集合,输出:Prüfer序列PSRDF_to_PrüferSequence(G)1.PS←空序列2.WHILEn∈V使得n.label=NULL3.IFn具有类型tTHENn.label←t4.ELSEn.label←ANY_LABEL5.WHILEn∈V使得n.id=NULL6.n.id←hash(n)7.对G进行深度优先拓扑排序,NS←顶点序列8.FOREACHnINNS9.SS←//后继者集合10.FOREACH(e,s)使得顶点-边-顶点(n,e,s)∈G11.将(e,s)加入SS12.将(n,SS)追加到PS最后Page613.将n从G中删除14.RETURNPS算法第1~4行将RDF图抽象为普通图.这个过程中,将RDF图中的结点的类型信息作为全局的标签(label),使RDF图抽象为一个Prüfer序列化方法可用Prüfer序列化方法处理的一般图,对于没有类型信息的结点,将其标签信息设为ANY_LABEL.这一过程同时减少了图中的边和结点的数量.对于上一步中得到的一般化图,采用扩展的Prüfer序列化方法构造RDF的Prüfer序列.这个过程采用图的深度优先拓扑排序(即基于图的深度优先遍历算法的拓扑排序,参见文献[12])方法完成,其主要原因是由于删除结点并记录其后继结点的操作,本质上与图的拓扑排序是一致的;而且为了能够充分保留并利用图上结点之间的关系来过滤候选集:算法5~7行,对于RDF图中的每一个结点,根据其结点标记信息(URI值或Literal值)进行Hash操作,对每个结点赋以相应的数值;并将这个值作为相应结点的Id(全局唯一);算法8~13行,对于上一步中处理过的图进行深度优先拓扑排序,依次记录删除结点以及该结点的后继结点和边信息.算法同时生成两个序列,一个是基于全局标签的LPS(LabelPrüferSequence),另一个是基于结点Id的NPS(NumberPrüferSequence).在LPS中,每个元素都是结点的全局标签,每个bag都是相应的边信息和标签信息.在NPS中,每个元素为结点的Id,bag中记录了相应的边信息和Id信息.图7中按照相应规则生成的Prüfer序列如表4所示.1(9:211:311:49:5)G(sB:Ptc:Ctc:CsB:P)2(10:310:7)7456(11:3)8(11:3)34.3对RDF图的Prüfer序列建立索引NPS分别建立索引.为了实现查询子图的快速匹配,需要对LPS和首先对于LPS和NPS,分别为其中的每个元素分配一个名为LEFTPOS的值.这个值记录从序列的左侧起始,该元素在序列中的位置(此处所讲的元素不包括bag元素,对于bag元素,其LEFTPOS值定义为与其相邻的左侧的元素的LEFTPOS值).对于图7的Prüfer序列与其对应的LEFTPOS如表5所示.1(9:211:311:49:5)G(sB:Ptc:Ctc:CsB:P)12(10:310:7)B(t:Ct:C)7456(11:3)8(11:3)3第2步,对NPS建立B+树索引.NPS序列作为一棵B+树存储.索引的键为NPS中元素的LEFTPOS,其值包含NPS中元素的数字Id信息.第3步,对LPS建立索引,LPS的索引同样采用B+树结构实现,与NPS索引不同的是LPS索引是针对每一种全局标签分别建立一棵B+树.以图6为例,需要分别对标签G,P,C和U建立相应的B+树.B+树的键为相应结点的LEFTPOS值,值由以下信息组成:定义5.PARENT_LEFTPOS.此处PARENT是指在Prüfer序列中位置在当前元素左侧且对应结点有边指向当前元素对应结点的所有元素LEFTPOS值中最大者.以图6的Prüfer序列为例,NPS中Id为3的元素LEFTPOS值为8.有边指向Id=3对应结点的Id为1,2,6,8.根据定义,标签为B的Id=8的元素的LEFTPOS=7,是这4个结点中LEFTPOS值最大者.为此,我们认为Id=8的元素为Id=3的元素的PARENT.并将其LEFTPOS值作为Id=3的元素的PARENT_LEFTPOS值.如果一个结点入度为0,则其对应元素无PARENT,其PARENT_LEFTPOS值为0.定义6.MAX_CHILD_LEFTPOS.对于一个Prüfer序列中的元素,其MAX_CHILD_LEFTPOS定义为其对应结点有边指向的所有后继结点对应元素中LEFTPOS值最大者.Page7对于图6中,G(sB:Ptc:Ctc:CsB:P)而言,其所指向的结点中LEFTPOS值最大的结点是Id=3的结点,因此G的MAX_CHILD_LEFTPOS值为Id=3的元素的LEFTPOS值,即8.定义7.MINI_CHILD_LEFTP.类似于MAX_CHILD_LEFTPOS定义,不同的是选取结点对应元素LEFTPOS最小值者.定义8.MAX_SIBLING_LEFTPOS.对于一个三元组〈S,P,O〉,我们定义S是O的直接前驱.RDF图中,如果一个结点与其它结点有共同的直接前驱,则这个结点与其它结点存在SIBLING关系.从存在此关系的结点中选择对应序列元素具有最大LEFTPOS者作为该结点MAX_SIBLING_LEFTPOS.LPS在Prig的整体设计中具有非常重要的作用.在LPS的索引结构中,以结点的LEFTPOS作为key,以其指向的后继结点的PARENT_LEFTPOS等信息作为value,因此根据以上构建的情况,不难得出其空间复杂度为O(m+n),其中n为图中结点的数量,m是图中边的数量.4.4对于查询子图的处理为了实现基于Prüfer序列匹配的查询,对于查询子图同样需要转化为Prüfer序列.其基本处理流程与RDF图序列化的处理方法一致,但是由于查询子图自身的特性,需要解决以下两个问题:(1)查询子图与RDF全图的同构问题[11];(2)查询子图标签信息的获取.根据Prüfer序列的序列化方法,图7中的查询4.4.1对于同构问题子图可以生成以下LPS:我们可以直观看出图7是图6的子图,然而图7的LPS却不是图6的LPS.这是由于查询子图拓扑顺序与RDF图拓扑顺序不一致造成的.用户构造查询的任意性以及变量的存在,都会导致查询子图和原RDF图拓扑顺序的不一致,进而导致Prüfer序列之间不存在子序列关系.对于这种情况,考虑到查询子图通常较小,往往只有几个结点,因此可以通过枚举所有拓扑顺序的方法进行解决.将子图所有拓扑顺序对应生成的Prüfer序列分别与原RDF图的序列进行匹配即可.4.4.2查询子图标签信息的获取对如下SPARQL查询:如果查询中不存在任何全局标签信息,那么将无法生成LPS序列.RDF数据是一种含有丰富语义的数据,采用〈S,P,O〉的结构,其中S与O间的关系是通过P定义的.因此通过P可以部分地获取S与O的信息.例如一组三元组:〈a,rdf:type,GraduateStu-dent〉,〈c,rdf:type,Course〉,〈a,takeCourse,c〉表达的信息为a是毕业生,c是课程,a选修c这门课程.若得知a选修c,则可以猜测a的标签信息可能是毕业生,而c的标签信息可能是课程.基于这样一种事实,在RDF图的构造过程中建立一个由边到标签信息的索引.对于每种边,记录其连接的术语的标签信息,并且记录标签位于边的相对位置.以图6为例:sB连接的标签有(G,P),t连接的标签有(P,C),tc连接的标签有(U,C)和(G,C).对于查询中的两个三元组模式〈?x,sB,?y〉和〈?x,tc,?z〉,通过查找边到标签的索引中sB和tc,并在第一个相对位置上做连接操作可以得到?x的标签为G.依次类推,可以得到?y的标签为P,?z的标签是C.通过以上处理可将查询子图转化为相应的Prüfer序列.5Prig查询处理在将RDF图和查询子图分别生成相应的Prüfer序列的基础上,Prig的查询处理是通过在RDF图的Prüfer序列中找到查询子图Prüfer序列的匹配来实现的.与针对树形结构的Prix方法类似,可以采用ViST[8]的思想,利用B+树实现一个Trie结构,即查询子图Prüfer序列中当前元素在全图序列中对应的位置是由查询子图序列中前一个元素的信息以及当前的匹配规则共同决定的.本节将详细讲述查询匹配处理算法以及匹配规则.算法流程如下所示.算法2.查询子图Prüfer序列与全图序列的输入:i:当前元素在查询序列中的位置匹配.输出:是否匹配成功Query(i,SQ,info)1.LPS_Index←SQ[i]的全局标签所对应的B+树索引2.relation←cal_relation(SQ[i-1],SQ[i])3.lb←cal_left_bound(relation,info)4.rb←cal_right_bound(relation,info)5.flag←FALSEPage86.FORj=lbTOrbDO7.current_info=get_next(LPS_index,j)8.IFgeneral_match(current_info)THEN9.IFrela_match(relation,info,current_info)10.IFQuery(i+1,SQ,current_info)THEN11.store(SQ[i],current_info)12.flag←TRUE13.RETURNflagQuery算法第1~5行进行初始化.首先获取查询序列中SQi处的全局标签所对应的LPS索引B+树.然后通过cal_relation()确定SQi与SQi-1的关系.第3行和第4行根据前一步中得出的关系以及满足SQi-1条件的匹配元素信息info(如MAX_CHILD_LEFTPOS等)共同确定LPS_Index上的搜索范围(lb和rb).算法第6行开始,在搜索范围内,通过get_next()依次获得索引上搜索范围内的各元素.此后,算法第8行首先通过函数general_match()进行一般性匹配过滤;对于通过过滤的结果,算法第9行再根据relation、info和current_info进行关系过滤rela_match().对于满足关系过滤条件的结果,则递归调用Query函数对SQi+1匹配.若SQi+1匹配成功,则认为SQi在当前的匹配是正确的,存储当前匹配作为部分结果,并将匹配成功标志赋值为真.算法初始调用时,i初始值为1,SQ为查询序列,info初始值为NULL.RDF全图与查询子图各自的扩展Prüfer序列以及序列之间存在着诸多性质.Prig根据这些性质设计了能够有效过滤错误匹配结点的匹配规则,包括一般性过滤规则和关系过滤规则.5.1一般性过滤规则在不考虑序列中相继元素对应结点间的拓扑结构关系的情况下,序列中元素存在如下可用于过滤的一般性性质.定理1.查询结果序列中元素SAi的LEFTPOS值单调递增,其中1i|SA|.证明.采用反证法.假设查询序列中存在两个元素SAi与SAj(1i<jn),满足关系SAi.LEFTPOSSAj.LEFTPOS.由定义3以及LEFTPOS的定义易知:RDF图序列中不存在两个LEFTPOS相等的相异元素,且如果有如下关系:SAi.LEFTPOS>SAj.LEFTPOS,则i>j;这与假设相矛盾,因此假设不成立.例1.以查询子图序列?x(sB:?ytc:?z)?y(t:?z)?z为例,?x,?y和?z三者的LEFTPOS值是依次递增的.因此在查询匹配过程中,若已知?x匹配元素的LEFTPOS值,则在查找?y时,只需从大于LEFTPOS值处开始查找.此时可以过滤索引结构中所有匹配?y标签且小于?x的LEFTPOS值的元素.定理2.如果SGj是SQi的候选匹配元素,那么其对应结点的入度满足di(SGj)di(SQi).证明.采用反证法.假设SGj是SQi的候选匹配元素,且di(SGj)<di(SQi),则SQi对应结点至少有一条出边是SGj所没有的,这与假设中候选元素条件相矛盾,因此假设错误.例2.以图6产生的Prüfer序列为例,假设存在查询序列?x(sB:?ytc:?z)?y(t:?z)?z.对于LEFTPOS=4的元素,其标签是C,符合查询子图中?z的基本要求,但查询子图中?z的入度是2,LEFTPOS值为3和4的两个元素其入度仅为1,因此可以将其过滤.定理3.如果SGj是SQi的候选匹配元素,那么其对应结点的出度满足do(SGj)do(SQi),且出边集合满足Eo(SGj)Eo(SOi).证明.证明同性质2.例3.以图6为例,假设有查询子图的Prüfer序列:?y(t:?z),查询变量?y的标签为P,在全图的Prüfer序列中LEFTPOS值为5的结点其标签也为P,但是其边集为空,即查询子图中?y的边集不是该结点边集的子集.因此可将其过滤.以上是一般化的过滤规则,接下来的部分介绍一些关系过滤规则.5.2关系过滤规则除上述一般性性质外,查序子图Prüfer序列中相继元素对应结点间的拓扑结构关系也存在一定性质.查询匹配过程依据4种关系:无关系、父子关系、兄弟关系、共同祖先关系,进行相应的过滤.定义9.无关系.设序列S中相邻两元素Si和Si+1(1i<|S|),如果满足di(Si+1)=0,则称此相邻元素对应结点间无关系,记为N_R(Si,Si+1).无关系过滤规则.对于查询序列SQ中相邻元素对应结点SQi和SQi+1(1i<|SQ|),如果满足关系N_R(SQi,SQi+1),则对于SQi+1只需要按照一般过滤规则过滤候选结点.例4.图8Prüfer序列为?x?y,因为?y的入度为0,则称?x与?y无关系.?y只需按一般规则选取候选匹配结点.定义10.父子关系.设序列S中相邻两元Page9图8查询子图序列中相邻元素对应结点间无关系素Si和Si+1(1i<|S|),如果相应结点间满足Si.LEFTPOS=Si+1.PARENT_LEFTPOS,则称Si对应结点是Si+1的双亲结点,Si+1对应结点是Si的孩子结点,这种关系称为父子关系,记为P_R(Si,Si+1).父子关系过滤规则.对于查询序列SQ中相邻元素对应结点SQi和SQi+1(1i<|SQ|),如果满足关系P_R(SQi,SQi+1),则在SQi+1其标签所属LPS索引上的查找范围为SQi.MINI_CHILD_LEFTPOS和SQi.MAX_CHILD_LEFTPOS之间,在此范围内同时不满足以下条件的SGj都将被过滤掉(其中SAi为查询结果序列的第i个元素):(1)P_R(SAi,SGj);(2)SAi.LEFTPOS<SGj.PARENT_LEFTPOS.例5.图9的Prüfer序列为?x(?y),?y,根据PARENT_LEFTPOS定义,若?y.PARENT_LEFT-POS=?x.LEFTPOS,则?y是?x的孩子.因此在标签C索引中,可将查找范围定为?x.MINI_CHILD_LEFTPOS到?x.MAX_CHILD_LEFTPOS之间.在此范围内首先按照一般规则过滤候选结点,这样可以有效减小搜索空间.然后,将?y的候选结点与?x的候选结点做父子关系判断,如果满足父子关系则纳入候选结果集中(对应本规则中的条件1).但对于以上匹配可能会漏掉一类正确的候选结果.如图10所示,生成的Prüfer序列可能为G(tc:c)P(t:B)C,此时虽然C的双亲之一是G,但其PARENT_LEFTPOS却是P的LEFTPOS值,为此我们采取如下策略(对应本规则中的条件2)涵盖这一情况:若?y的候选结点的PARENT_LEFTPOS大于?x的候选结点的LEFTPOS值,则亦将其纳入候选结果集中.其余的结果都将被过滤掉.定义11.兄弟关系.设序列S中相邻两元素Si和Si+1(1i<|S|),如果相应结点间满足Si.PARENT_LEFTPOS=Si+1.PARENT_LEFTPOS,则称Si和Si+1为兄弟关系,记为S_R(Si,Si+1).兄弟关系过滤规则.对于查询序列SQ中相邻元素对应结点SQi和SQi+1(1i<|SQ|),如果满足关系S_R(SQi,SQi+1),则在SQi+1其标签所属LPS索引上的查找范围应该在:(SAi.LEFTPOS,SAi.MAX_SIBLING_LEFTPOS],在此范围内同时不满足以下条件的SGj都将被过滤掉(其中SAi为查询结果序列的第i个元素):(1)S_R(SAi,SGj).(2)SAi.PARENT_LEFTPOS<SGj.PARENT_LEFTPOS.例6.如图11对于?y和?z,若不满足无关系和父子关系,则进行兄弟关系的判断.判断为兄弟关系的条件是?y.PARENT_LEFTPOS=?z.PARENT_LEFTPOS.如果满足该关系,则对于?z,根据LEFTPOS的单调递增性质,在标签C索引中只需搜索LEFTPOS值介于?y.LEFTPOS和?y.MAX_SIBLING_LEFTPOS之间的结点,这有效缩小了搜索空间.将?y的候选结果与之前?x的候选结果做兄弟关系判断,如果满足兄弟关系,则将其纳入候选结果集中(对应本规则中的条件1).同样,对于以上匹配可能会漏掉一类正确的候选结果.如图12所示:其生成的Prüfer序列可能为G(sB:Ptc:C)PU(tc:C)C.此时P与C虽然有共同的双亲G,但是C的PARENT_LEFTPOS与P的PARENT_LEFTPOS不同.对此我们采取如下策略(对应本规则中的条件2)涵盖这一情况:若?y的候选结点的PARENT_LEFTPOS小于?z候选结点的PARENT_LEFTPOS,则亦将其纳入候选结果集中,其余的结果都将被过滤掉.Page10定义12.共同祖先关系.设序列S中相邻两元素Si和Si+1(1i<|S|),如果相应结点间不存在无关系、父子关系和兄弟关系,且满足Si.PARENT_LEFTPOS<Si+1.PARENT_LEFTPOS,则称二者具有共同祖先关系,记为C_R(Si,Si+1).共同祖先关系过滤规则.对于查询序列SQ中相邻元素对应结点SQi和SQi+1(1i<|SQ|),如果满足C_R(SQi,SQi+1),则在SQi+1其标签所属LPS索引上查找范围是索引中所有满足如下关系的元素:SGj.LEFTPOS>SAi.LEFTPOS,在此范围内的SGj都可作为候选SAi+1,否则予以过滤.例7.如图13中所示的查询子图的Prüfer序列为?x(sB:?y,tc:?u)?y(t:z)?z?u时,则序列中?u与其左侧相邻元素对应结点既非兄弟关系,也非父子关系,而是与?z为共同祖先关系,其判断条件?z.PARENT_LEFTPOS>?u.PARENT_LEFTPOS.此时,我们可以按照共同祖先关系过滤规则进行候选结点的选取和过滤.图14Sesame与Prig在LUBM数据集的查询测试实验结果首先,Prig与Sesame的查询处理方法不同.Sesame以主要通过垂直表(verticaltable)的形式组织三元组,三元组中的主语、谓语、宾语分别对应元组中的一项.通过调整主语、谓语、宾语上建立索引的顺序可以提高三元组访问的性能.面对复杂查询Sesame要在垂直表上进行自连接操作.而Prig则在获取查询中变量的候选结点过程中,使用一般性过滤和关系过滤等多种过滤规则缩小候选集合,从而提高查询的处理效率.在数据规模较小的情况下,Prig过滤过程所需的时间开销相对于缩小候选结5.3最终结果过滤最后,对于生成的候选结果集采用传统的图匹配算法进行相应的剔除工作,去除错误的结果,返回正确的结果集.6实验结果实验所使用的硬件为Intel(R)Pentium(R)4CPU2.80GHz,内存DDR2GB,磁盘320GB,转速7200rpm.软件环境中操作系统为LinuxCentOSRelease5.6,采用C++作为编程语言,开发环境为NetBeansIDE6.9.1.系统采用Raptor①作为RDF数据解析工具,使用BerkeleyDB②作为后台数据存储工具.实验中以采用Native存储方式的Sesame2.2.4作为对比系统,分别采用LUBM基准数据集和SP2Bench基准数据集进行了对比实验.对于LUBM数据集中14个标准查询分别在LUBM(10),LUBM(100),LUBM(1000)上进行了测试,实验结果如图14所示.测试结果显示在绝大多数情况下Prig在该数据集上的查询响应时间低于Sesame,尤其是在数据规模较大(LUBM(1000))的情况下.但当数据规模较小时(LUBM(10),LUBM(100)),Prig在Q3,Q4,Q5,Q6,Q9,Q10,Q12,Q13等查询中表现出性能稍落后于Sesame.其主要由以下两方面原因造成:果集所带来的性能提高要更突出,因此表现出Prig的查询响应时间高于Sesame.随着数据规模的增大,Prig缩小候选结果集所带来的查询性能改善随之显现.而此时,Sesame则由于缺少有效的过滤方法,面临大量的连接操作.另一方面,以查询Q4为例,由于存在图同构问题,查询子图生成的Prüfer序列并不唯一.在Prig①②Page11系统中采取枚举所有可能的查询子序列的方法,并依次进行序列匹配查询,进而可能造成查询响应时间超过Sesame的现象.但由于Prig所具有的过滤功能,使得查询性能在数据规模增大的情况下优于Sesame.总体而言,随着LUBM数据规模不断增大,Prig相对于Sesame有着更好的查询性能.如图15所示,我们统计了在LUBM(10),LUBM(100)以及LUBM(1000)3个数据集下,Sesame和Prig两个系统分别执行14个查询的时间总和.结果显示,相较于Sesame,Prig分别依次提高了28.9%、43.3%和58.9%.因此在数据规模增长的趋势下,Prig有着较好的可伸缩性.图16简单图模式下Sesame与Prig在SP2Bench数据集查询性能比较在SP2Bench数据集中Prig的整体性能同比仍优于Sesame.但也存在与LUBM数据集中类似的情况,如图17所示,在数据规模较小的情况下,SP2Bench(2.5M)和SP2Bench(10M)时Q2,Q4,Q7,Q11相对于Sesame在查询性能上存在着一定的差距,但这一问题随着数据规模的增长得到改善.总体而言,Prig在SP2Bench数据集上仍然有着比较好的伸缩性,性能依次提高了1.19%,3.89%,5.21%.图17Sesame与Prig在SP2Bench的查询时间总和比较对比图15与图17,Prig在SP2Bench数据集中所表现出的性能相较于其在LUBM数据集中所体现的性能有所下降,主要有以下两方面原因:(1)SP2Bench数据集中RDF图结构要比LUBM数据集的更复杂,因此在序列中搜索和过滤候选结图15Sesame与Prig在LUBM数据集的查询时间总和比较与此同时,我们使用SP2Bench数据集,对测试基准中7个标准查询的简单查询部分①分别在SP2Bench(2.5M),SP2Bench(10M),SP2Bench(40M)上进行了相关的测试,其测试结果如图16所示.点的开销更大,造成了相对较高的时间开销.(2)SP2Bench测试基准中查询子图所对应的Prüfer序列大多不唯一.Prig不得不枚举所有可能的序列,然后依次进行查询.这也造成了很大的时间开销.通过以上在LUBM和SP2Bench测试基准上的实验结果显示Prig在整体上优于Sesame,并且在数据规模增长的趋势下,有着较好的可伸缩性.这表明Prig所采用的扩展Prüfer序列化方法以及提出的若干过滤规则对RDF数据的索引和查询具有较好效果.7结束语本文首次将Prüfer序列化方法引入RDF图的查询和处理工作中.扩展了Prüfer从一般树形结构查询匹配到图结构查询匹配的转变,提出了若干有效的过滤规则来提高查询处理性能.实现了基于这一方法的Prig系统.在两个测试基准上的实验结果表明Prig能够提升RDF数据索引和管理性能.①由于目前Prig原型系统仅支持简单查询,因此选取了查询Page12
