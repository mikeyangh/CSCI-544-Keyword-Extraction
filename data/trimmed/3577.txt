Page1EasiCache:一种基于缓存机制的低开销传感器网络代码更新方法邱杰凡1),2)李栋1)石海龙1),2)杜文振1),2)崔莉1)1)(中国科学院计算技术研究所北京100190)2)(中国科学院研究生院北京100049)摘要随着应用环境越来越复杂多变,传感器网络需要具备远程代码更新的能力,对节点进行灵活地配置和升级以适应环境变化.然而过高的代码更新开销一直困扰着远程代码更新在传感器网络中的大规模应用.代码更新开销主要包括存储代码引起的重组开销和节点通信产生的传输开销.在工程实践中,作者发现重组开销甚至有可能超过传输开销成为主要的更新开销.为此作者提出了一种基于代码缓存机制的低开销远程代码更新方法———EasiCache.该方法通过代码缓存机制在低功耗RAM上动态保存并执行需要频繁更新的代码,尽量避免对高功耗闪存flash进行读写操作,从而有效降低了重组开销.此外,该方法通过函数级代码差异对比,降低了传输代码量,同时保存了代码缓存机制所需的程序结构信息,进一步降低了重组开销.实验结果验证了该方法在降低代码更新开销方面的有效性.关键词传感器网络;远程代码更新;代码缓存机制;函数级代码差异对比;物联网1引言在一个大规模无人值守的传感器网络中,受节点自身资源的限制和周围环境变化的影响,开发者很难在开发阶段全面考虑节点在部署后可能遇到的各种突发情况,因此需要通过远程代码更新对节点进行灵活地配置和升级.以我们在故宫中部署的文物监测传感器网络为例[1].传感器节点一旦被部署到展柜中,展柜即被封闭,只有在换展时才能被取出,如图1(a)所示.其中一些传感器节点受到人流密度及展柜布置的影响,频繁发送数据,导致电池能量迅速耗尽.利用远程代码更新,可以根据节点所处环境的不同,动态地调整节点上的休眠机制和数据保存机制,从而有效地延长节点的生命周期.我们在太湖部署的蓝藻监测打捞感-执系统(Cyber-PhysicalSystems)[2]也存在类似问题.感-执节点受波浪及天气影响较大.特别是阴雨天气,经常发生数据被阻塞的情况,如图1(b)所示.利用远程代码更新可以在降雨之前更新路由策略,防止数据阻塞情况的发生.另一方面,受季节变化的影响,蓝藻爆发的程度不尽相同,通过远程代码更新动态调整蓝藻打捞的调度策略可以提高打捞效率.此外诸如普度大学的球场监测系统eStadium[3]、香港科技大学的森林监测系统GreenOrbs[4]等传感器网络,也都采用了不同的远程代码更新方法处理节点在部署以后遇到的各种突发情况.随着物联网的发展,作为感知前端的传感器网络会越来越多地担负起局部数据处理工作.在物与物能够智能交流的场景中,传感器节点需要作为信息装置融入到各种物体中,交互执行各种智能算法并产生有效的智能判断[5].这不仅要求节点具有数据采集和发送功能,更需要节点能够根据外部需求变化,主动调整自身功能,动态实现各种算法.因此远程代码更新势必成为物联网中不可或缺的技术.较高更新开销一直困扰着远程代码更新的大规模应用.更新开销主要包括两方面:一方面是节点之间发送和接收更新代码时产生的传输开销;另一方面是节点上重建和存储代码时产生的重组开销.目前大多数远程代码更新方法对如何降低传输开销进行了深入的研究,而对如何降低重组开销则关注较少.以增量式代码更新方法为例,该类方法通过只传输新旧程序的差异代码,可以有效地降低传输开销[3,6-9].该类方法在代码重组时,通常要对外部flash(由节点板载的扩展flash组成,如TelosB[10]节点默认的扩展flash为STM25P)和嵌入式芯片的内部flash进行读写操作.如表1所示,较高的flash读写功耗导致这类方法的重组开销超过传输开销.以我们在故宫中部署的传感器网络为例,在采用增量式代码更新方法后,我们将传感器节点上的程序从2.2版升级至2.3版需要传输1560字节更新代码,通过一个电流检测放大电路测量节点上存储器读写操作的电流、电压和时间,并计算开销.在这个过程中,传输能量开销为19.4mJ,而重组开销竟达到35.7mJ,其中读写flash产生的开销占到重组开销的98.2%以上.表1TelosB节点存储器读写1000Bytes数据的平均开销读操作平均开销/μJ写操作平均开销/μJ读外部flash1015写外部flash2458读内部flash785写内部flash1850读RAM<50写RAM126注:写flash操作之前需要进行擦除操作,因此写flash开销包含擦除flash的开销.从表1可知,使用低功耗RAM代替高功耗flash存储代码可以有效降低重组开销.但是由于RAM空间有限,一般不可能将所有需要更新的代码都放入RAM中,只能将一部分需要频繁更新的代码放入,然而如何确定需要频繁更新的代码目前尚未有相关研究.当前可供参考的做法是由开发者在编程阶段指定放入RAM中的代码.这种做法仍然是以简单的传感器节点作为应用对象,没有考虑在物联网中节点可能由于外界应用需求的变化而频繁地调整自身功能,从而改变最初程序中各部分代码更新的频度:一部分保存在内部flash中原本不需要更新的代码开始进行频繁更新,引起大量的读写flash操作;而一部分保存在RAM中原本需要频繁更新的代码则很长时间不进行更新,却占据Page3着有限的RAM空间.针对这个问题,我们设计了一种基于代码缓存的低开销远程代码更新方法,EasiCache.该方法在RAM上模拟出一块代码缓存区域保存需要频繁更新的代码.这种代码缓存同传统意义上的高速缓存(Cache)相似,同样基于代码的局部性原理:通常外部物理世界的需求是渐变的,因此我们假设对代码的修改具有局部性.即对完成某个功能的若干个函数(function)在一段时间内需要根据外界需求的变化连续地进行更新;不同之处在于,代码缓存机制并不是以提高程序的执行效率为目的,而是利用flash与RAM阶梯式的读写功耗差异,动态地使用低功耗的RAM保存并执行需要频繁更新的代码,避免对高功耗的flash进行读写操作,从而有效降低重组开销.另一方面,EasiCache作为一种增量式代码更新方法,采用了函数级代码差异对比技术.该技术用于计算新旧程序间差异代码,通过传输这些差异代码可以有效降低代码更新过程中的传输开销;同时,该技术可以保留代码缓存机制所需的程序结构信息.利用这些信息我们设计了重组操作,可以减少代码重建次数,进一步降低重组开销.本文的贡献主要集中在以下几个方面:(1)为了降低重组开销,提出一种代码缓存机制,可以有效避免对高功耗flash的读写操作,并且设计了相应的替换算法.(2)为了降低传输开销,提出了一种与代码缓存机制相匹配的函数级代码差异对比技术.它在减少更新代码传输量的同时,可以保留程序结构信息.利用这些信息,我们定义了3种重组操作,进一步降低了重组开销.(3)为了验证EasiCache的有效性,我们设计了单次更新实验和连续更新实验,以验证EasiCache在降低更新开销方面的有效性.本文第2节简要介绍研究背景;第3节给出EasiCache的组成结构与执行流程;第4节介绍EasiCache的实现;第5节设计实验更新场景并分析实验结果;第6节介绍相关工作;最后在第7节给出结论和未来的工作.2研究背景我们的研究以TinyOS及nesC语言为基础,并以TelosB节点[10]作为硬件实现平台.nesC语言是一种扩展的C语言,专门针对传感器网络特点进行了优化.以nesC语言编写的程序能够被nesC编译器编译,并最终生成嵌入式芯片可执行的文件.以采用嵌入式芯片MSP430的TelosB节点为例,图2显示了使用nesC语言编写的.nc文件如何生成MSP430可执行的.ihex文件.由于.nc文件仅仅包含了开发者的应用程序,如果直接比较新旧程序的.nc文件并不能反映TinyOS系统模块的变化..nc文件对应生成的C语言文件app.c是TinyOS镜像(image)文件,它包含了整个TinyOS操作系统以及上层应用程序,但是由于很难确定单条C语言代码可能生成的指令类型以及指令条数,通常无法计算代码的修改地址.在EasiCache中,将保存有程序结构信息的汇编文件(.s)作为生成差异代码的比较对象.而最终生成的.ihex文件将作为传输对象,它可以被嵌入式芯片直接执行.当前大多数传感器节点的嵌入式芯片都采用了flash+RAM的存储结构.以TelosB节点为例,MSP430的内部flash与RAM统一编址,表2显示了一种典型的MSP430存储地址空间①.内部flash(48KB)RAM(10KB)(informationmemory)(bootmemory)RAM(对映RAM)①MSP430F15x,MSP430F16x,MSP430F161xMixedSignallit/ds/symlink/msp430f1611.pdfPage4默认情况下,.ihex文件中的代码段(.text段)被放入0x4000到0xFFFF的内部flash中,全局变量段(包括.data段和.bss段)被放入0x1100到0x38FF的RAM中.如果代码段大小超出内部flash容量,则需要将代码放入外部flash中.3EasiCache概述图3给出了EasiCache的组成结构,它主要由在计算机端执行的生成更新脚本(deltascript)以及节点上运行的代码缓存机制两部分组成.生成更新脚本主要在计算机端实现,包括计算函数级的差异代码以及定义3种重组操作.通过传输包含差异代码及重组操作的更新脚本,EasiCache实现了增量式代码更新.待更新节点将更新脚本下载到RAM中的函数组装区(functionassembler),并根据更新脚本中的重组操作,将差异代码与旧函数代码进行组合后生成新函数的代码.随后使用替换算法判断当前新生成的函数是否需要保存在代码缓存中.如果需要,则将替换出的若干函数回写至内部flash;否则,新函数直接写入内部flash.最后节点发送携带有当前新函数奇偶校验码的应答消息,请求继续更新函数.如果没有函数再需要更新,则整个程序的代码更新过程结束,节点开始执行新程序.4EasiCache的设计与实现本节主要由4.1节介绍的生成更新脚本和4.2节介绍的代码缓存机制两部分组成.前者主要解决传输开销过高的问题,后者主要解决重组开销过高图4EasiCache执行流程图的问题.4.1更新脚本的生成在计算差异代码之前,首先确定哪些函数需要更新.EasiCache采用二级比较机制,即通过比对新旧代码的奇偶校验码和MD4码的方式确定需要更新的函数.首先对旧程序中的所有函数分别生成奇偶校验码以及MD4码,并对旧程序本身再生成一次奇偶校验码和MD4码.由于生成MD4码的计算开销较大,当获得新程序的代码后,并不立即生成新程序的MD4码,而是首先生成新程序的奇偶校验码.对新旧程序的奇偶校验码进行比较,如果不同,直接开始比较新旧程序中的各个函数;否则计算新程序的MD4码,继续与旧程序的MD4码进行比较.新旧函数的比较与新旧程序的比较类似.首先将新程序中每个函数的奇偶校验码与旧程序中对应EasiCache中的代码缓存机制运行在节点上,由代码缓存初始化、函数的二次调用、空闲空间管理以及替换算法4部分组成.代码缓存初始化使开发者有机会在编程阶段预先将代码以函数为单位放入代码缓存中.函数的二次调用保证了函数在重新定位后仍能够被正确地调用.空闲空间管理则是为了提高存储空间利用率,通过空闲空间列表重新释放代码重复占用的存储空间.替换算法主要考虑当代码缓存耗尽时,采用何种策略选择回写到内部flash中的函数.节点部署之前,开发者通常可以预见部分需要频繁更新的代码.通过代码缓存初始化将这部分代码预先保存在代码缓存中.图4给出了在节点部署之后,对节点进行代码更新的执行流程.首先在计算机端确定需要更新的差异函数,计算新旧函数间的差异代码并生成相应的重组操作.随后计算机通过串口将包含函数差异代码与重组操作的函数更新脚本(deltascript)后发往网关节点.网关节点收到更新脚本之后,以无线多跳(multi-hop)方式将更新脚本发往待更新节点.Page5函数的奇偶校验码进行比较,如果不同,则确定需要更新的函数;然后对所有奇偶校验码相同的函数分别生成MD4码,继续比较.在确定需要更新的函数之后,可以直接计算新旧函数之间的差异代码.我们使用Python语言编写计算差异代码的程序.输入为新旧程序的汇编文件(app.s);输出为汇编语言组成的差异代码文件(Diff.s).差异代码文件(Diff.s)中包括:以函数为单位的新旧程序的差异代码,差异代码距离函数第一条指令的指令偏移数以及需要进行的重组操作.Diff.s文件内容如图5所示.main:call#__nesc_atomic_start/4_Rep///中的数字表示相对于函数第一条指令的指令偏移数.由于每一条汇编指令对应的机器指令长度是一定的,所以在得到指令偏移数之后,可以计算得到差异代码相对于函数起始地址的偏移量.Del、Ins和Rep分别表示3重组操作:删除操作、插入操作和替换操作.替换操作不会改变函数的大小,可以直接写入新代码覆盖旧代码.插入操作或删除操作会改变旧函数的大小.由于保存了程序的结构信息,当一个函数的更新仅仅涉及替换操作或删除操作时,可以通过写入无条件跳转指令(JMP)或者空指令(NULL)来实现删除操作,并通过直接覆盖原始代码实现替换操作,避免函数的代码重建,有效降低重组开销.如果对函数的更新包含了插入操作,则需要对这个函数进行重建.如图2所示,Diff.s文件中的差异代码经过链接器(MSP430-ld)链接和嵌入式代码格式转换器(MSP430-objcopy)最终生成嵌入式芯片可执行的代码(.ihex文件).这些可执行的代码、重组操作以及修改地址组成了代码更新所需的更新脚本.另外,需要特别指出的是由于上述生成更新脚本的过程全部由计算机完成,不会消耗传感器节点的能量,也不会给传感器网络增添额外的开销.4.2代码缓存机制由于读写RAM与flash的功耗差异巨大,EasiCache通过代码缓存机制将需要频繁进行更新的代码保存在RAM中,减少对flash的读写操作.4.2.1代码缓存初始化开发者可以在编程阶段将特定函数放入特殊段,并通过链接器(MSP430-ld)设置特殊段的起始地址①.由于MSP430的RAM与flash统一编址,通过设定特殊段的地址,可以将程序的部分函数保存在RAM中并执行.使用属性(attribute)对需要放入特殊段的函数进行标记.图6中显示了两个被标记的函数,它们被指定存放在代码缓存区域(.cache段)中,而不是默认的.text段.另外如果开发者可以预见到若干全局变量未来可能需要频繁修改,也可以使用相同的方法,将这些全局变量分别放入.dataram段(初始化全局变量段)或者.bssram段(未初始化全局变量段),再通过设定这两个特殊段的地址将它们放入RAM中.__attribute__(section(".Cache"))staticBoot__booted(void)__attribute__(section(".Cache"))staticTimer0__fired(void)由于RAM中默认存放了.bss段和.data段,为了避免.bssram段、.dataram段、代码缓存区域(.cache段)、函数组装区域(FunctionAssembler)以及管理列表区域(ManagementList)与RAM默认存放的段发生地址冲突,需要进行两次编译.在第一次编译时,设定所有区域和段位于相距较远的地址上.由于代码缓存区域、函数组装区域以及管理列表区域的大小是我们预先设定的,在进行一次编译后,只需要计算.bas段、.data段、.bssram段以及.dataram段的大小,确定所有段和区域的最终地址后,再进行一次编译.经过代码缓存初始化后,内部flash、外部flash和RAM的分配情况如图7所示.RAM中地址自低到高依次存放了.data段、.bss段、.dataram段、.bssram段、函数组装区域、管理列表区域、代码缓存区域(.cache段)以及系统堆栈.4.2.2函数的二次调用执行删除或者插入操作之后会导致函数代码量发生变化.特别是执行插入操作后,可能会增加函数的代码量.由于函数是连续存放的,如果将代码量增加后的新函数仍保存到旧函数地址上,势必会覆盖与它相邻的函数,严重时会导致整个程序崩溃,所以必须将新函数转存到其它地址上.转存之后,这个函数的入口地址(entryaddress)发生改变,①GNUBinutils:loaderandlinker[Online].Available:http:Page6意味着对这个函数进行调用的所有指令都需要进行更新,而更新这些指令可能会引起较大的更新开销.为此需要使用函数的二次调用解决这个问题:调图7代码存储示意图及函数二次调用示意图.函数二次调用:保存在代码缓存中的函数Boot_booted地址为0x1230.当保存在内部flash上的某条指令要调用Boot_booted函数时,需要先跳转到指令数据混合列表中的调用指令(位于0x112C的地址上),其中包含了Boot_booted的真实地址.再由这条调用指令调用保存在缓存区域中的Boot_booted函数.如图8所示,指令数据混合列表由函数信息数据以及对函数的调用指令组成.嵌入式芯片存储资源的稀缺性(例如MSP430的存储空间小于64KB)要求我们必须尽量复用存储空间.函数调用指令包含了函数当前的存储地址,因此将它与函数的信息数据进行空间复用.函数的信息数据包含了函数编号、函数代码量以及更新次数.更新次数指示当前函数已被更新的次数,同时通过正负数区分当前函数是否已被保存在代码缓存中(正数表示当前函数保存在内部flash中,负数表示保存在代码缓存中).函数编号3166-1call0x1560ret48263call0x4a18ret12626-2call0x5160ret指令数据混合列表保存在管理列表区域中.列表中每条函数调用指令的位置是固定的,如图7中,在指令数据混合列表中调用Boot_booted函数的指令地址固定为0x112C.当某个函数的入口地址发生了变化,只需要修改指令数据混合列表中调用这个函数的指令,而不再需要修改其他对这个函数的调用指令.函数的二次调用实际上是一种对函数地址用函数时,并不是直接对函数进行调用,而是先跳转到指令数据混合列表(InstrumentandDateList),由指令数据混合列表中的函数调用指令调用真正的函数,调用过程如图7所示.的集中式管理,只需要修改指令数据混合列表中的一条调用指令,就可以完成对所有调用指令的修改.函数的二次调用相当于在调用函数时增加一条跳转指令.在实验部分的第5.3节,我们将分析增加一次跳转对程序执行效率产生的影响.4.2.3空闲空间的管理函数代码量在更新后有可能增加,这时需要将更新后的函数放入新的地址.如果直接将新函数放入代码缓存或者内部flash的末尾空间,会造成嵌入式芯片上的存储资源被迅速耗尽.为了节约有限的存储资源,当新函数被放入代码缓存或者回写到内部flash中时,可以将原函数所占用的空间重新释放,保存其它新函数.我们设计了缓存空闲空间列表(FreeCacheList)和Flash空闲空间列表(FreeFlashList)管理空闲空间,并将这两个列表保存在管理列表区域.如图9所示,缓存空闲空间列表和Flash空闲空间列表分别记录了代码缓存和内部flash中空闲空间的起始地址及大小.当新函数需要重新选择地址保存时,可以通过空闲空间列表查找合适的存储空间.转存之后,需要修改空闲空间列表对应的项,并将对应的原始函数的起始地址和函数大小记录到空闲空间列表,释放对应原函数的存储空间.Page7缓存空闲空间起始地址0x150080x1542140x168A86(a)缓存空闲空间列表图9空闲空间列表(列表的最后一项记录了4.2.4代码缓存的替换节点接收到函数更新脚本后,根据指令数据混合列表中函数更新次数的正负,确定旧程序中相应的函数是否已经被保存到代码缓存中.如果代码缓存已经保存了这个需要更新的函数,称之为命中.将需要更新的旧函数代码与差异代码一起放入函数组装区域进行组合,重建新函数.代码缓存区域的容量通常在节点部署之前确定.其确定原则是不能够影响RAM中.bss段、.data段以及系统堆栈正常使用.如果代码缓存即将被耗尽,而重建函数的代码量超出了代码缓存的剩余容量,则需要将保存在缓存中的部分函数回写到内部flash中,腾出空间存放新函数,这个过程称为替换.传统缓存代码替换算法通常关注保存在缓存中的代码是否被执行.如:最近最少使用(LeastRecentlyUsed,LRU)算法以代码被执行的次数作为是否替换的主要因素.在EasiCache中,缓存代码的替换以函数为单位进行,如果仅仅以函数被更新次数为替换的主要因素,有可能出现这样一种情况:函数Fm每次升级都需要更新,命中率较高,但函数Fm代码变化较小;而函数Fn被更新次数较少,命中率较低,但发生更新时代码变化较大.这时有可能将函数Fn替换出去,一旦对函数Fn进行更新,仍然需要对flash进行大量的读写操作.为此我们设计了最近最少变化算法(LeastRecentlyChanged,LRC)将函数变化次数以及函数变化的程度同时考虑.算法中的相关参数见表3.参数名Pold/Pnew更新前的旧程序/更新后的新程序.F(old,i)/F(new,i)旧程序/新程序中的函数Fi.CRFi函数Fi的变化率.Ck在第k次升级时,函数已被更新的次数.Rf(k,i)函数Fi的替换因子.决定在第k次升级时是a比例因子,调节函数变化次数和函数变化程首先定义反映函数Fi变化情况的变化率CRFi:CRFi=SizeofChag(F(old,i),F(new,i))函数SizeofChag(x,y)计算x更新到y发生改变的代码总量.变化率CRFi越大说明函数Fi的变化程度越高,相对于其它函数对整体程序的更新贡献越大.在第k次升级时,最近最少变化(LRC)算法将函数被更新的次数和函数变化的程度统一考虑,并计算函数在第k次升级时的替换因子:如果需要更新的函数Fi没有保存在代码缓存中,且它的替换因子Rf(k,i)大于已经保存在代码缓存中的若干个函数的Rf(k,j),则需要计算替换出这若干个函数后腾出的缓存空间是否足够保存函数Fi.如果可以,则将这若干个函数回写入内部flash中,并将函数Fi保存在缓存中.反之如果仍然没有足够的缓存空间,则将函数Fi写入内部flash中.LRC算法的核心思想是对不经常发生变化或者变化较小的函数进行替换,而尽量将经常变化或者变化较大的函数保存在代码缓存中.同时为了能够适应不同更新,可以通过合理设置比例因子a,调节函数被更新次数与函数变化程度对替换因子的影响.4.2.5代码缓存的安全性由于代码缓存使用易挥发性的RAM保存代码,当节点断电重启时可能导致RAM中的关键代码丢失,严重时会使程序崩溃,因此需要通过备份代码来消除潜在的程序安全隐患.如图7所示,我们将RAM中代码缓存和管理列表的内容备份到内部flash中,将内部flash中.text段的内容备份到外部flash中.当节点重启之后首先将外部flash中的.text段内容读入内部flash,然后将内部flash中代码缓存和管理列表的内容读入RAM中,完成程序恢复.为了尽量避免对flash的读写操作,并不是每一次升级都进行代码备份.只有当程序需要进行重大升级时,才进行代码备份,并记录备份程序的版本号.当节点完成程序恢复后,如果发现当前程序的版本号过低,可以要求计算机端重新发送最新程序的更新脚本,并更新至最新的程序.Page85实验结果与分析我们设计的实验包括单次更新和连续更新两种.单次更新实验测试EasiCache的传输开销以及对程序的某个特定部分进行更新的重组开销.连续更新实验测试代码缓存机制的有效性.在现有代码更新方法中,由于不存在代码缓存机制,因此通常只进行单次更新实验.而我们为了更好地验证代码缓存机制的有效性,把实验重点放在对连续更新场景的测试上.最后我们通过实验分析EasiCache对程序执行效率的影响.5.1单次更新实验LED的闪烁频率.我们在单次更新时,设计了6种场景,包括:更新1.修改程序Blink中的全局变量,改变更新2.修改程序Blink中的单条指令,关闭一个LED.更新3.在程序Blink中删除函数Blink_Boot_booted中的连续两行代码,同时删除函数Blink_Timer0_fired中的一行代码.更新4.在程序Blink的函数BlinkC_Timer0_fired中插入两行代码.更新5.在程序Blink中插入一个控制LED闪烁模式的函数Control_LED_Pattern.更新6.将程序Blink更新为程序CntToLed.程序CntToLed通过3个LED显示计数变量counter最后3位的值.在单次更新实验中,我们将EasiCache与当前的远程代码更新方法Deluge[11]、Elon[12]以及Hermes[7]进行比较.其中Deluge是TinyOS标准远程代码更新方法.Elon通过设定TinyOS的组件(component)为可替换(replaceable),在编程阶段将可能频繁更新的代码保存在RAM中并执行.Hermes基于比特级差异对比技术,有效降低了传输代码量.实验结果显示EasiCache在大多数情况下优势明显.表4显示了在更新1~6中Deluge、Elon以及EasiCache需要传输的代码量.观察发现Deluge的传输开销十分巨大.这是由于在使用Deluge进行更新时要传输整个TinyOS镜像(image)以及代码更新协议.以更新1为例,当使用Deluge进行代码更新时,传输的Blink镜像本身仅占总传输代码量的11.5%,而真正要更新的代码只占总传输代码量的0.043%.Elon和EasiCache都可以单独对变量进行修改[12],因此两种方法在更新1中的传输开销很低.在更新2~4中和更新6中,Elon没有采用代码差异比较,当新旧程序中的若干个函数不同时,需要传输整个函数.而EasiCache通过函数级代码差异对比只需要传输差异代码,因此传输代码量明显少于Elon.在更新5中,整个函数被插入旧程序中.新旧程序的差异是整个函数,因此EasiCache与Elon传输代码量相同.表4各种更新场景下代码更新所需传输的代码量方法Deluge231102311023114231162329625008Elon858624286156EasiCache814162086132表5显示了在更新1~6中,Hermes、Elon以及EasiCache的重组开销.3种更新方法都可以独立对存储在RAM中的全局变量进行写改,在更新1中重组开销基本相同.Hermes在更新代码时,会首先将更新脚本存入外部flash,然后将重建后的新程序回写到嵌入式芯片的内部flash.这样做导致重组效率低,重组开销大.由于Elon采用了直接把保存在RAM上的函数进行整体替换的策略,重组开销主要来自于向RAM写入函数代码,因此重组开销较小.EasiCache通过删除操作和替换操作可以在不重建代码的情况下直接对函数完成更新,因此在更新2和更新3中重组开销明显少于Elon.在更新4和更新6中,EasiCache执行插入操作,需要重建函数代码,因此重组开销与Elon相差不大.而在更新5中由于代码差异主要是整个函数,函数级差异对比对降低重组开销效果不明显,重组开销与Elon基本相同.表5各种更新场景下代码更新所需的重组开销方法Hermes0.0358027.18157.28144.68256.712490.5Elon0.03940.257.734.86.4796.8EasiCache0.0210.140.3636.26.9288.5在单次更新的场景中,开发者通过缓存初始化可以将需要更新的函数在编程阶段预先保存在RAM中.如果设置合理,可以完全避免对flash的读写操作,因此重组开销较低.然而在一个连续更新的场景中,开发者不可能完全预测所有需要更新的函数,由此可能导致对内部flash进行大量读写操Page9作,增加重组开销,因此需要使用代码缓存机制动态保存更新频繁的函数.5.2连续更新实验为了验证代码缓存机制的有效性,我们设计了一个连续更新的场景,即当节点的代码完成更新之后,立即再一次更新节点上的程序.如图10所示,我们选取4个TinyOS的例子程序:RadioCnt、RadCntToLeds、BaseStation和BaseStation15.4以及我们在故宫传感器网络节点上的程序:EasiRouter2.2图10连续更新流程图按照图10所示的Order(A,B,C,D,E,F,A,G,H,C,I)顺序对节点上的程序进行更新.我们定义缓存的命中率为命中函数的代码量与缓存容量之比.默认设定缓存容量为3KB,比例因子α=0.5.图11给出了在这个连续更新过程中,采用最近最少使用(LRU)替换算法和最近最少变化(LRC)替换算法的代码缓存命中率.图11采用最近最少使用(LRU)算法和最近最少变化节点上保存的起始程序是RadioCnt.由于程序RadioCnt与程序RadCntToLeds较为相似,更新A缓存命中率达到了较高的95.2%.这也说明通过代码缓存初始化合理地安排缓存中的代码,可以有效提高缓存命中率.在更新A之前没有替换行为的发生,所以两种替换算法的命中率相同.在更新A之后,缓存已经无法容纳所有需要更新的函数,部分函数需要被替换出并回写到内部flash中.程序RadCntToLeds与程序BaseStation相似度较低,导致更新B的命中率明显下降.程序BaseStation与程序BaseStation15.4较为相似,差和EasiRouter2.3作为实验更新程序.程序RadioCnt与程序RadCntToLeds类似,后者加入了通过LED显示计数变量counter最后三位的功能.程序BaseStation15.4与程序BaseStation都具有监测无线信道数据并向串口转发的功能,后者增加了接收串口数据以及通过无线信道发送数据的功能.程序EasiRouter2.3最为复杂,加入了实用的路由机制.程序EasiRouter2.3是程序EasiRouter2.2的升级版本,不同之处在于前者拥有更完善的休眠重启机制.异在于增加了串口和射频发送数据的功能,因此更新C的命中率相较于B有所回升,但仍然偏低.从更新B和更新C可以看出,LRC算法的命中率明显高于LRU算法的命中率,这是由于LRC算法能够将那些变化比较大且更新频繁的函数尽量保存在代码缓存中,而LRU算法只将函数被更新次数作为唯一的考虑因素.在更新D中,程序BaseStation与程序EasiRouter2.2差异较大,需要更新的函数较多,命中率下降到80%以下.在更新D中,LRU算法的命中率高于LRC算法.这是由于LRC算法在上一次更新中(更新C)替换出了若干更新比较频繁但是变化程度较小的函数(约占缓存总量的8.1%),而在更新D中这些函数成为了被更新的对象,导致LRC算法的命中率降到了73.14%.这种情况同样发生在更新H和更新I中.在更新E~G和更新C中,LRC算法的命中率普遍较高.特别是在更新G中,LRU算法的命中率下降到了72.39%,而LRC算法的命中率仍然保持在85%以上.总体而言,LRC算法的平均命中率较高,达到了87.5%;LRU算法的平均命中率为82.2%.表6列出了使用LRC算法(α=0.5/α=0.95)和LRU算法对上述6个程序分别进行20次、30次、45次、60次、100次以及150次连续随机更新的平均命中率(每次测试均重复50遍,取平均值).当α=0.5时,除了在连续更新20次时,LRC算法的平均命中率略低之外;在大多数情况下,LRC算法的平均命中率均高于LRU算法.当α=0.95时,LRC算法的命中率已与LRU算法的命中率相差不大.由式(2)可知,当α趋近于1时表示函数更新次数Page10Ck将在越来越大的程度上决定替换因子Rf(k,i),当α=1时,LRC替换算法与LRU替换算法等价.算法LRC(α=0.5)84.4185.6085.2588.7984.1886.54LRC(α=0.95)83.3481.2280.2380.1578.1481.37LRU84.7182.5280.4480.5279.4481.23表7和表8列出了EasiCache、Hermes[7]和TinyModule-Link[13]3种更新方法按照Order更新过程中对flash进行读写操作的情况.Hermes的重组过程包括将更新脚本写入外部flash,与保存在外部flash的原始程序进行组合后产生新程序,最后将新程序的代码整体从外部flash读出并写入内部flash.实际上新程序的代码量决定了Hermes的重表7完成更新需要从flash读取的代码量Hermes读外部flash131481588416826181921925012026181921588419250TinyModule-Link读外部flash14281392198628142518890441025225014EasiCache读外部flash---------表8完成更新需要写入flash的代码量Hermes写外部flash15624614201029461596926452826404872TinyModule-Link写外部flash14281392198628141890890441025225014EasiCache写外部flash---------EasiCache为了进一步降低重组开销,使用低功耗RAM动态保存并执行部分需要频繁更新的函数,可以有效减少对内部flash的读写操作.同时由于EasiCache使用RAM保存更新脚本,避免了对外部flash进行读写的操作,因此表7和表8中未列出EasiCache对外部flash进行读写操作的代码量.Hermes不需要对内部flash进行读操作,故也未列出.在更新B和更新F中,由于EasiCache的代码缓存中保存了所有需要更新的函数,因此不再需要向内部flash读取这些函数的原始代码,对内部flash的读取量降为0.而在其他更新中EasiCache读取内部flash的代码量也远远小于TinyModule-Link.另外,EasiCache可以在RAM上直接执行函数代码,不再像TinyModule-Link需要将所有更新组开销,导致即使新程序相较于原始程序变化较小,也有可能引起较大的编程开销.如在更新F中,程序EasiRouter2.3相较于程序RadioCnt功能十分完善,从更新脚本的尺寸上反映了对程序EasiRouter2.3进行较小的修改就可以完成更新,但是将新程序RadioCnt从外部flash搬移到内部flash仍然使更新F的重组开销维持在一个较高的水平.另一种更新方法TinyModule-Link充分考虑了这种代码搬移造成的高开销问题,提出将代码组合过程放入低功耗的RAM中进行,外部flash仅存放更新脚本[13].更新时需要将更新脚本读出与保存在内部flash中的原始代码进行组合.同时由于TinyModule-Link也是以函数为单位进行更新,所以更新时仅需从内部flash中读取需要更新的函数代码.的函数代码回写到内部flash中,因此写入内部flash的代码量也明显少于TinyModule-Link.在表9中列出了Hermes及TinyModule-Link与EasiCache的重组开销之比.可以看出EasiCache的重组开销明显小于另外两种更新方法.例如在更新F中,Hermes和TinyModule-Link的重组开销分别达到了EasiCache的763.3倍和91.03倍.这也表明在EasiCache中,程序更新代码量成为影响重组开销的主要因素.当更新代码量增大时,EasiCache的重组开销也随之增加.例如在更新I中,新生成函数的代码量远远超出了代码缓存能够容纳的极限,只能向内部flash回写大量代码,这两种更新方法与EasiCache的重组开销之比下降到6.7和3.29.Page11表9Hermes及TinyModule-Link与EasiCache的重组开销之比Hermes:EasiCache35.3312.3734.9213.2020.96763.610.218.846.70TinyModule-Link:EasiCache8.644.668.335.245.6191.034.872.943.295.3EasiCache对执行效率的影响对函数进行二次调用处理后,每次函数调用多进行一次跳转,增加了程序的复杂度,会对程序执行效率产生影响.以TelosB节点采用的MSP430F1611为例.增加一次函数跳转意味着每次函数调用要多执行一次调用指令(CALL)和一次返回指令(RET).图12给出了6个更新程序在采用函数的二次调用后,执行效率受到的影响.受影响最大的是程序BaseStation15.4和程序BaseStation,执行效率分别下降了9.5%和12.3%.由于这两个程序的大量工作是串口通信和射频通信,在多数时间里需要对与底层量硬件相关的函数进行调用,函数的切换较为频繁,而且这部分函数的代码量较少,执行时间较短,因此CALL指令和RET指令所消耗的时钟周期占程序执行总的时钟周期比重较大.当增加一次函数跳转后,执行效率受到的影响也相对较大.我们在故宫传感器网络节点上运行的程序需要经常进入休眠状态并重启,对与底层硬件相关的函数调用也较多,相对于另外两个没有休眠机制的程序RadioCnt和程序RadCntToLeds执行效率受影响较大.图12函数的二次调用对程序执行效率的影响为了提高程序执行效率,我们可以不对与底层硬件相关的函数进行函数二次调用.但这样的后果是如果这部分函数被更新,则可能导致对调用这部分函数的指令进行大量修改,增加了代码更新开销.6相关工作Deluge[11]是较早的代码更新方法.该方法在代码无线分发阶段需要传输更新协议和整个TinyOS镜像.当被更新节点收到新代码时直接写入外部flash.当更新代码接收完毕后,通过Bootloader将代码读入内部程序flash,进行硬件重启完成更新,因此更新开销大.针对Deluge的不足,文献[14-17]提出了不同的解决方案.Elon[12]以TinyOS为基础,将代码以组件(component)为单位放入RAM中执行,提高了更新效率,但它在更新时以组件作为传输和重组的基本单位,包含了大量无关代码.Kim等人[13]提出的TinyModule-Link主要考虑了由于读写外部flash引起的重组开销,将新程序代码重建全部放入RAM中进行,但是在完成重建后,仍然需要将所有被更新的函数回写到内部flash中.增量式代码更新方法通过传输差异代码降低传输开销.其中Hermes[7]采用Rsync算法计算字节级差异,但是由于它必须对外部flash进行读写,增加了重组开销.Koshy和Pandey[6]试图通过给每个函数末尾添加溢出空间(slopregion)来存放插入的代码,尽量避免代码重建.但是溢出空间会导致大量无效的存储碎片,而且插入的代码量受到溢出空间大小的限制.除了专门的远程代码更新方法之外,SOS[18]、Contiki[19]等操作系统使用了动态链接方法实现代码更新,但是这些操作系统在更新代码时需要传输符号表和重定位表,增加了传输开销,并且也无法对操作系统内核模块进行代码更新.Mate[20]和ASVM[21]在节点上实现了虚拟机技术,可以在传输少量代码的情况下,完成代码更新.然而虚拟机代码是一种紧凑型代码(compactcode),与本地码(nativecode)相比执行效率过低,并且表达能力有限.7结束语目前大多数传感器网络代码更新研究仍然集中Page12在如何有效降低传输开销上,而对如何有效地降低重组开销的研究则较少.然而通过在故宫中布署传感器网络[1]的工程实践,我们发现有时重组开销能够超过传输开销成为代码更新的主要开销.本文介绍了一种基于代码缓存机制的低开销远程代码更新方法EasiCache.该方法通过代码缓存机制将部分代码动态地保存在RAM中,尽量避免对flash元件的读写,从而有效降低了代码更新的重组开销.同时在EasiCache中,针对代码更新中传输开销较高的问题,提出了与代码缓存机制相适应的函数级代码差异对比技术.通过单次更新实验和连续更新实验,我们验证了EasiCache在降低更新开销方面的优势.在未来的工作中,我们将进一步研究与代码缓存机制相适应的替换算法,提高在动态变化场景中的缓存命中率.
