Page1无线传感器网络中top-犽连接查询处理莫尚丰1),2),3)陈丁洁1),2)陈红1),2)李英龙1),2),3)李翠平1),2)1)(教育部数据工程与知识工程重点实验室(中国人民大学)北京100872)2)(中国人民大学信息学院北京100872)3)(湖南科技大学湖南湘潭411201)摘要无线传感器网络是物联网核心组成部分之一,数据查询处理是无线传感器网络中很重要的一个研究领域.连接查询能在不同的位置监视相似的网络环境,top-k连接查询能进一步得出组合得分最大(或最小)的k个相似网络环境.top-k连接查询根据得分函数计算匹配结果的组合得分,并报告组合得分结果最大(或最小)的k个匹配节点对.文中提出了基本top-k连接算法BTJQ.该算法首先按照得分属性值从大到小对所有元组排序,然后依次取出元组,产生连接结果.对每个连接结果按照得分函数计算组合得分,如果满足停止条件,则停止取元组,并输出连接结果.在BTJQ基础上,作者提出了集中式top-k连接算法CTJQ和优化的集中式top-k连接算法OCTJQ.针对特定应用场景,作者进一步提出了分布式top-k连接算法DTJQ.最后,在真实数据集上验证了各算法.实验结果表明,文中算法好于经典连接算法SENS-Join.关键词无线传感器网络;top-k查询;连接查询;物联网1引言物联网(InternetofThings,IoTs)以感知为目的,旨在实现任何时刻、任何地点、任意物体之间的互联,实现无所不在的网络和无所不在的计算.传感器技术、RFID技术、纳米技术、智能终端等都是物联网的重要支撑技术.物联网广泛应用于安防、电力、交通、医疗等许多领域.物联网体系结构包括应用层、通信网络层(包括2G、3G、4G等移动通信网络及互联网)和感知层.其中,感知层主要由各类同构或异构无线传感器网络(WirelessSensorNetworks,WSNs)组成,这些传感器网络负责各类物理目标感知、监控以及数据传输,它们是物联网实现物与物、人与物等互联的基础,也是物联网核心组成部分之一.随着微电子技术、嵌入式计算技术和无线通信技术的发展,低功耗、廉价的传感器节点也能集成信息收集、数据处理和无线通信等多种功能[1].无线传感器网络是由大量部署在监视区域的传感器节点以自组织、多跳方式组成的网络,主要用于收集并处理监视对象的信息.传感器节点一般用电池供电,部署在环境恶劣的监视区域中,通常不方便或不可能去更换电池或节点.因此在传感器网络中,查询处理的目标是:在获得必要信息的前提下,尽可能节约节点能量消耗,从而延长网络生命周期.相对于节点计算,节点之间的通信将消耗更多的能量.例如:在MICA2节点上执行一条指令需要消耗大约0.84nJ能量,但发送一个数据包大约需要消耗0.685mJ能量[2].因此,节约节点能量消耗的关键是减少数据包发送量.无线传感器网络可以被看作一种新型分布式数据库系统,用户向无线传感器网络发送查询消息,传感器网络返回监视区域中满足查询要求的信息.由于传感器节点通信、计算和存储资源有限,因此,传统数据库查询算法并不适用于无线传感器网络.数据查询处理是无线传感器网络中很重要的一个研究领域.目前,已提出了很多能量有效的查询处理算法,如聚集查询、KNN查询、top-k查询、skyline查询、连接(join)查询等.在这些查询技术中,连接查询是一种重要的查询方法,该查询能够将不同节点或位置的数据关联起来.典型的连接查询应用是在不同位置监视相似的网络环境.在实际应用中,还有另一类更复杂的查询需求.在无线传感器网络中,每个节点感知多种属性数据.用户希望连续地从连接属性值近似相等的节点对中获取得分函数值最大的k个节点对.例如:在森林环境监测中,找出温度、湿度、光照等环境条件近似相同,动物数量总和最多的两个区域,供动物学家分析这两个区域植被覆盖、地形地貌等的相同与不同,以全面研究动物数量和环境的关联关系.又如,在城市交通流量监测系统中,城市规划专家希望找到车流量近似相等、人流量总和最大的两个监测地点,分析这两个监测地点车/人相互影响关系的相同与不同.再如,用户希望连续地从相对湿度(RelativeHumidity,RH)采样值近似相等(差值τ小于等于1%)的节点对中获取温度(Temperature,Temp)采样值之和最大的3个节点对.假设一个采样周期是10min,该查询可以如下表示:SELECTA.,B.FROMSensorsA,SensorsBWHERE|A.RH-B.RH|1%ORDERBY(A.Temp+B.Temp)STOPAFTER3;SAMPLINGPERIOD10minutes该实例中,连接属性是相对湿度,得分属性是温度,得分函数是f=(A.Temp+B.Temp).这类查询的特点是:假设每个传感器节点能感知多种属性数据,用户希望连续地从连接属性值近似相等的节点对中获取得分函数值最大的k个节点对.我们称这类查询为top-k连接查询,它可以如下表示:SELECTA.,B.FROMSensorsA,SensorsBWHERE|A.join-B.join|τORDERBYf(A.score;B.score)STOPAFTERk;SAMPLINGPERIODpminutes针对如上所述top-k连接查询,一个简单方法是在每一轮数据采集过程中,每个节点发送相关属性值给基站(Thesink或Thebasestation).基站首先找出符合连接条件的匹配节点对,然后按照得分函数计算各匹配节点对的组合得分并排序,最后获Page3得top-k连接结果.在这个过程中,大部分节点都不属于最终top-k连接结果.而让每个节点发送数据给基站,无疑会浪费很多能量.本文关注无线传感器网络中top-k连接查询处理技术,针对不同的场景给出了不同的top-k连接查询处理方案.本文的主要贡献如下:(1)提出了基本top-k连接算法BTJQ(BasicTop-kJoinQueries).该算法首先按照得分属性值score从大到小对所有元组排序,然后依次取出元组,产生连接结果.对每个连接结果按照得分函数计算组合得分,如果top-k个匹配元组对中最小组合得分大于或等于门限得分值,则停止取元组,并输出连接结果.(2)提出了集中式top-k连接算法CTJQ(Cen-tralizedTop-kJoinQueries).根据基本top-k连接算法BTJQ,把每一轮时间T分成M个时间片.各节点根据得分属性值大小,安排在不同的时间片发送数据给基站.我们还提出了优化的集中式top-k连接算法OCTJQ(OptimizedCentralizedTop-kJoinQueries).(3)提出了分布式top-k连接算法DTJQ(Dis-tributedTop-kJoinQueries).该算法把整个网络分成L个格,每个格有一个中心节点.由中心节点计算连接结果,并发送给基站.(4)在真实数据集上验证了算法BTJQ,CTJQ,OCTJQ和DTJQ.实验结果表明,这些算法好于经典连接算法SENS-Join[13].本文第2节简单介绍相关工作;第3节讨论无线传感器网络设置;第4节详细介绍top-k连接算法;第5节给出各算法的实验验证及分析;最后对全文进行总结.2相关工作在无线传感器网络中,目前已有一些top-k查询算法[3-8]和连接查询算法[9-14].但尚未见到本文所关注的top-k连接查询算法.(1)top-k查询算法.文献[3]提出了一个POT算法,该算法把传感器节点分成很多偏序树(PartialOrderedTrees,POT),基站维护了一个全局排序表(GlobalRankinglist,GR).如果top-k结果空间相关,POT算法性能很好.但如果top-k结果没有空间相关性,FILA[4]算法优于POT算法.FILA[4]协议中,在每一轮查询,如果节点采样数据没有超出过滤器窗口,该节点将不发送数据给基站.如果基站接收到某个节点的采样值进入了其它节点的过滤器窗口,基站将发送广播消息,并获取所需数据.因此,该协议中数据发送是离散的.在PRIM[5]和PRIM-c[6]协议中,设置了N个部分TDMA帧收集top-k节点数据.不同采样值在不同帧中传送,采样值越高的节点数据在越靠前帧中发送给基站.该方法以牺牲时间换取节约系统能量.在XP[7]协议中,作者以自底向上方式和空间聚簇方式构建了一颗路由树,在该路由树基础上进行交叉剪枝(CrossPruning,XP).CRTQ[8]针对top-k查询特点提出了一种新路由算法,该算法是适合top-k查询的基于分簇路由.(2)连接查询算法.REED[9]和NEJA[10]算法处理的是外部连接问题,让网络中产生的元组和存放在基站的外部表进行连接匹配.PEJA[11]算法解决了不同区域连接查询问题.PEJA算法由3个阶段组成,包括初始阶段、递增连接处理阶段和清除阶段.TPSJ[12]算法解决了窗口自连接问题,目的是探测感兴趣的事件.SENS-Join[13]处理了通用连接问题.有可能符合匹配条件的节点将发送连接属性值给基站,基站根据收集到的连接属性值计算连接结果,属于最终连接结果的节点将被通知发送完整的元组信息给基站.INJECT[14]算法处理了两个区域连接问题.INJECT提出了baseJoin、coverJoin、sideJoin、partitionJoin、synopsisJoin、fullsynopsis-Join等多种连接实现方案,并根据不同的应用场景选择不同的连接实现方案.(3)在传统数据库查询算法中,有一些top-k连接查询算法.因无线传感器网络和数据库体系结构不同,这些top-k连接查询算法[15-16]不能直接应用于无线传感器网络.HRJN[15]是一种经典的top-k连接查询算法.该算法在连接操作过程中递归地获取top-k结果.在传统数据库的多个表中,从每个表获取前面数量不等的元组.然后计算这些已获元组的门限值.如果top-k连接结果中第k个结果得分值大于或等于门限值,则算法结束.PBRJ[16]发现HRJN没有尽可能早地停止读取表中输入元组.因此,PBRJ提出了更严格的边界条件,在保证能获取top-k连接查询结果的前提下尽早地停止读取表中输入元组.(4)TJA算法.TJA[17]算法是查找满足用户定义函数的k个最高排名结果,例如:查找过去3个月内k个最高平均温度的时间段.因此,TJA算法解Page4决的问题和我们算法解决的问题不相同.TJA算法分为3个部分.(1)求下界阶段(LowerBoundPhase).每个节点将本地k个得分最高对象发给基站,中间节点合并孩子和自己本地top-k对象,在基站上形成一个过滤对象集τ.(2)分层加入阶段(HierarchicalJoinPhase).每个节点将大于过滤对象集τ的对象发给基站.(3)清理阶段(Clean-UpPhase).对第2阶段中不完整对象补齐.3系统设置N个传感器节点被随机部署在监视区域中,这些节点以自组织方式构成网络,并周期性地采集数据,每一个采样周期称为一轮.每一轮中,基站将获得top-k连接查询结果.si代表第i个传感器节点,相应的节点集S={s1,s2,…,sn},|S|=N.每个节点si都有最大通信半径R.我们做如下假设:(1)所有传感器节点是同构的,都有相同的计算、存储和通信能力.部署后节点静止不动,同时每个节点有自己唯一的ID号.(2)网络中只有一个基站,该基站能被重新充电,因此,不考虑基站能量消耗问题.(3)通信链路对称.如果节点si能和节点sj通信,反过来,节点sj也能和节点si通信.(4)传感器节点能量有限,并且不能补充能量.4Top-犽连接算法本节将提出4种top-k连接算法,包括基本top-k连接算法BTJQ、集中式top-k连接算法CTJQ、优化的集中式top-k连接算法OCTJQ和分布式top-k连接算法DTJQ.4.1基本top-犽连接算法BTJQ参考传统数据库中top-k连接算法HRJN[15],我们提出了适合于传感器网络的基本top-k连接算法BTJQ(BasicTop-kJoinQueries).HRJN算法涉及多个表之间元组的连接,而BTJQ只涉及一个表内元组的连接.在每一轮中,每个节点将进行一次数据采集,采集的属性值封装在一条元组T中,然后将该元组发送给基站.T=(id,join,score).每条元组由节点id号、连接属性值join、得分属性值score等组成.基站获得所有节点元组后,按照得分属性值score从大到小对所有元组排序.T1是排序后第一条元组,T1.score是最大得分属性值.Ti表示排序后第i条元组.基本top-k连接算法BTJQ涉及的参数有:连接条件|Ti.join-Tj.join|τ,单调组合得分函数f,k个连接结果.该算法报告组合得分最高的k个连接结果.得分门限(threshold)值为TScore.基本top-k连接算法BTJQ如算法1所示.算法1.BTJQ算法.输入:基站所获的全部元组输出:top-k连接结果1.按照得分属性值score从大到小对所有元组排序.2.依次取出一条元组Ti.3.if(i>1)4.TScore=f(T1.score;Ti.score).5.end-if6.产生新连接结果J.7.根据得分函数f计算组合得分J.score.8.Lk是目前所获组合得分最大的k个连接结果表,9.if(scorekTScore)10.break.11.end-if12.报告Lk中连接结果.BTJQ算法描述如下:A.首先按照得分属性值score从大到小对所有元组排序,然后依次取出一条元组Ti.若i>1,计算得分门限值TScore,TScore=f(T1.score;Ti.score).(1)根据连接条件,对新取出的元组Ti和所有已取出元组进行判断,产生相应的连接结果.(2)对于每个新产生的连接结果J,根据得分函数f计算组合得分J.score.(3)Lk是目前所获组合得分最大的k个连接结果表,scorek是Lk中最小组合得分.如果scorekTScore,则停止继续执行该算法.B.报告Lk中连接结果.定理1.TScore是目前未取出元组和其它任何元组连接结果的组合得分上界.证明.假如一条元组Tj还没有取出,j>i.TScore一定大于或等于Tj和其它任何元组To连接结果的组合得分f(Tj.score;To.score).因为TScore=f(T1.score;Ti.score);T1.scoreTo.score;Ti.scoreTj.score.同时组合得分函数f是单调的,所以TScoref(Tj.score;To.score).证毕.实例:假设基站一共收到7个节点的元组,各元组按照得分排序后如图1所示.假设连接条件是两元组连接属性值相等,即Ti.join=Tj.join;组合得Page5分函数是两节点得分属性值之和,即fij=Ti.score+Tj.score;基站要求获得top-2连接结果.根据基本top-k连接算法BTJQ,依次取出表中各条元组,当取到第3条元组T3时,计算TScore=T1.score+T3.score=10+8=18.此时,T1.join=T3.join=1,满足连接条件,计算组合得分f13=T1.score+T3.score=10+8=18,然后把该连接结果加入到结果表L2中.此时表L2中只有一个连接结果,不满足结束条件,继续往下取元组.当取到第5条元组T5时,计算TScore=T1.score+T5.score=10+6=16.此时,T2.join=T5.join=3,满足连接条件,计算组合得分f25=T2.score+T5.score=9+6=15,然后将该连接结果加入到结果表L2中.此时表L2中有2个连接结果,最小组合得分score2=f25=15.因为score2<TScore,因此该算法继续执行,取第6条元组,此时,TScore=T1.score+T6.score=10+5=15.第6条元组并不能和其它元组匹配,L2中依然只有2个连接结果,但score2TScore,此时停止继续执行该算法,并报告L2中top-2连接结果.4.2集中式top-犽连接算法CTJQ在基本top-k连接算法BTJQ中,基站需要收集所有节点的元组,将产生大量能量消耗,若部分节点发送数据给基站,基站也能获得正确的top-k连接结果,将节约很多能量.据此,我们提出了集中式top-k连接查询算法CTJQ(CentralizedTop-kJoinQueries).CTJQ算法如算法2所示.首先,基站根据搜集到的历史数据,获得各节点元组中得分属性值Ti.score的分布,并据此分布把得分属性分割成M个子范围,[Sm.LowerBound,Sm.UpperBound)(1mM),使每个子范围内元组数近似相等.然后,基站把这M个子范围边界值广播给网内所有节点.设每一轮时间长度为T,把每一轮时间T分成M个时间片TS(TimeSlice),时间片M数目和得分属性值划分子范围个数M相同,每个时间片TS=T/M.各节点根据得分属性值大小,安排在不同的时间片发送数据给基站.得分属性值越大,就安排在越靠前的时间片内发送数据给基站.在每一个时间片TS内,当基站收集到数据后,将按照基本top-k连接算法BTJQ判断是否满足停止条件.如果满足,基站将广播停止消息给所有节点,通知其停止发送数据.否则,继续进行下一个时间片内数据传输.算法2.CTJQ算法.输入:基站所获的部分元组输出:top-k连接结果1.for每个TSmdo2.for每个普通节点sjdo3.if(Tj.score∈[Sm.LowerBound,Sm.Upper-4.发送元组Tj给基站.5.end-if6.end-for7.基站调用BTJQ算法.8.if满足停止条件9.基站广播停止消息给所有节点.10.end-if11.if普通节点sj收到停止消息,退出.end-if12.end-forCTJQ算法的得分门限值TScore计算方法和BTJQ算法稍有不同.TScore=f(T1.score;Ti.score).CTJQ算法中,Ti.score是当前时间片对应的子范围下边界.例如,如图2所示,基站根据搜集到的历史数据,把得分属性分割成6个子范围,即得分[9,10)为第1个子范围;得分[7,9)为第2个子范围;…;依此类推.每个子范围内元组数近似相等.相应地,每一轮时间T分成6个时间片.如果节点的得分属性值Ti.score∈[9,10),该元组将会在时间片|0-t|内发送给基站.当基站在时间片|0-t|内收集完数据后,将按照基本top-k连接算法BTJQ判断是否满足停止条件.此时,得分门限值TScore中Ti.score=9,即第1个子范围下边界.如果不满足停止条件,继续等待接收数据.如果节点的得分属性值Ti.score∈[7,9),该元组将会在时间片|t-2t|内发送给基站.当基站在时间片|t-2t|内收集完新数据后,将按照基本top-k连接算法BTJQ判断是否满足停止条件.此时,得分门限值TScore中Ti.score=7,即第2个子范围下边界.如果满足停止条件,基站将广播停止消息给所有节点,通知其停止发送数据.这样,得分属性值Ti.score∈[0,7)的元组将不会传送给基站.Page64.3优化的集中式top-犽连接算法OCTJQ在一些特殊情况下,少量节点的得分属性值会非常高,例如在如前所述森林环境监测实例中,如果遇到下雨等恶劣天气时,动物可能大量聚集在某个区域避雨,造成某个区域动物数量异常多;非洲大草原上,大量动物长途迁徙,也会造成局部区域动物数量非常多;若传感器节点读数异常,会造成某个节点得分属性值非常高.这时,CTJQ算法会出现不能满足停止条件而需要取出全部元组的问题.如图3所示,节点1的得分属性值T1.score=100,其余节点的得分属性值都少于10.设组合得分函数是两节点得分属性值之和,即fij=Ti.score+Tj.score.在集中式top-k连接查询算法CTJQ中,得分门限值TScore=T1.score+Ti.score>100.而若i>2,j>2,组合得分函数fij将小于20,并且也小于TScore.这样fij将很难满足停止条件,而需要取出全部元组,导致消耗很多能量.针对如上所述少数节点得分属性值非常高,而大部分节点得分属性值都属于正常分布的情形,我们提出了优化的集中式top-k连接算法OCTJQ(OptimizedCentralizedTop-kJoinQueries).OCTJQ算法如算法3所示.算法3.OCTJQ算法.输入:基站所获的部分元组输出:top-k连接结果1.for每个普通节点sjdo2.if(Tj.score>=MaxThresholdScore)3.发送元组Tj给基站.4.end-if5.end-for6.基站广播Tj.join给所有节点.7.for每个普通节点skdo8.ifTk.join和Tj.join满足连接条件9.发送元组Tk给基站.10.end-if11.end-for12.Lk是目前所获组合得分最大的k个连接结果表,13.if(scorekf(MaxThresholdScore;min(NDS)))退出14.else调用CTJQ算法.15.end-ifOCTJQ算法描述如下:参数MaxThresholdScore表示最大门限得分属性值,该值是查询区域中比正常分布值大得多的得分属性值.该值应满足如下式(1)条件:f(MaxThresholdScore;min(NDS))NDS(NormalDistributionofScorevalues)表示正常分布的所有得分属性值.min(NDS)表示正常分布得分属性值中最小值;max(NDS)表示正常分布得分属性值中最大值.max(NDS)和min(NDS)通常根据历史经验数据获得.在OCTJQ算法中,首先,各节点判断得分属性值Tj.score是否大于等于MaxThresholdScore;如果得分属性值大于等于MaxThresholdScore,该元组将会被传输给基站.基站接收到高得分属性值元组后,提取出元组的连接属性值Tj.join,并向网络中所有节点广播该值.节点sk收到该消息后,将其感知的连接属性值Tk.join与基站广播的连接属性值Tj.join进行比较,若满足连接条件,则向基站发送元组Tk.基站收集到元组后,产生相应连接结果,并加入Lk连接结果表.scorek是Lk中最小组合得分.如果scorekf(MaxThresholdScore;min(NDS)),此时,基站能获得正确的top-k连接结果,并停止执行该算法.否则,继续执行集中式top-k连接查询算法CTJQ,以获得最终top-k连接结果.对于图3所示各节点的元组分布,我们设MaxThresholdScore=100.首先,节点1的得分属性值大于等于MaxThresholdScore,该元组将会被传输给基站,基站提取出节点1元组连接属性值T1.join(T1.join=1),并广播该连接属性值T1.join给整个网络.节点3和7收到广播消息后,发现连接Page7属性值T3.join,T7.join和T1.join满足连接条件,因此将元组T3和T7发送给基站.基站收到元组T3和T7后,产生相应连接结果,并加入Lk连接结果表.然后判断是否满足停止条件,若不满足,继续执行集中式top-k连接查询算法CTJQ,以获得最终top-k连接结果.4.4分布式top-犽连接算法DTJQ如果查询区域为网络中一个子区域,该子区域离基站很远(如图4所示),集中式top-k连接算法图4DTJQ算法实例在图4和图5所示实例中,假设连接条件是两元组连接属性值相等,即Ti.join=Tj.join;组合得分函数是两节点得分属性值之和,即fij=Ti.score+Tj.score;基站要求获得top-2连接结果.分布式top-k连接算法DTJQ基本思想如下:假设某节点能获得查询区域内最大得分属性值GMaxScore和其它部分元组.根据基本top-k连接算法BTJQ,Lk是目前根据部分元组获得的组合得分最大的k个连接结果表,scorek是Lk中最小组合得分.组合得分函数f是单调的.如果某元组Ti得分属性值Ti.score和最大得分属性值GMaxScore的组合得分满足f(GMaxScore;Ti.score)scorek,则该元组Ti不属于最终top-k连接结果.如图5所示,GMaxScore=10.Lk={18,15};scorek=15.CTJQ可能导致离基站近的节点中继数据包数量很大,消耗能量过多,节点过早死亡.如果在查询区域中心选择一个节点收集数据并计算top-k连接结果,该节点需要很大的存储空间.由于查询区域中心节点也是普通节点,存储空间有限,因此该方案不可行.为此我们提出了一种分布式top-k连接算法DTJQ(DistributedTop-kJoinQueries),以便在查询区域为网络中子区域,该子区域离基站很远的场合下获得top-k连接查询结果.f(GMaxScore;Ti.score)=(GMaxScore+Ti.score)scorek.即Ti.scorescorek-GMaxScore=15-10=5.这样,元组(6,7,5)和(7,1,4)将不属于最终top-k连接结果.因此,分布式top-k连接算法DTJQ可以利用已获的局部top-k连接结果抑制不属于最终top-k连接结果的元组.DTJQ中涉及的重要符号描述如表1所示.DTJQ算法如算法4所示.符号CNi第i格中心节点g中心节点CNi第g个子范围表L_SubCNiNLCNik中心节点CNi新产生的top-k连接结果PLCNgCNikLCNik中心节点CNi目前所获的top-k连接结果表算法4.DTJQ算法.输入:各中心节点所获的部分元组输出:top-k连接结果1.for每个TSmdo2.for每个普通节点sjdo3.if(sj.score∈[Sm.LowerBound,Sm.UpperBound))4.选取最近的CNi并发送元组给CNi.Page85.end-if6.end-for7.for每个CNido8.接收元组并加入到L_SubCNi9.按照score从大到小对L_SubCNi10.计算LCNik并识别被抑制元组.11.for每个L_SubCNi12.发送正常值数据包给CNg.13.end-for14.接收其它中心节点发送给CNi的正常值数据包.15.发送边界值数据包给CN(i+1).16.接收边界值数据包.17.计算LCNik并识别被抑制元组.18.if满足停止条件19.发送停止消息包给其它中心节点.20.end-if21.if收到其它中心节点CNg(i≠g)发送的停止消22.计算LCNik.23.end-if24.if满足停止条件或收到停止消息包25.发送匹配元组给基站并退出.26.end-if27.end-for28.end-forDTJQ详细描述如下:和集中式top-k连接算法CTJQ一样,基站根据搜集到的历史数据,把得分属性分割成M个子范围,[Sm.LowerBound,Sm.UpperBound)(1mM),使每个子范围内元组数近似相等.然后,基站向网络内所有节点广播M个子范围边界值.设每一轮时间长度为T,每一轮时间T分成M个时间片TS(TimeSlice),时间片M数目和得分属性值划分子范围数目M相同,每个时间片TS=T/M.普通节点得分属性值越大,越安排在靠前时间片内发送数据给最近的中心节点.4.4.1网络预划分基站综合考虑查询区域大小和普通节点存储空间及计算能力,把整个查询区域分成L格,每个格由基站计算出格中心节点位置并选择离中心节点位置最近的普通节点成为中心节点CN(CentralNode).基站根据搜集到的历史数据,将获得各节点元组中连接属性值Ti.join的分布,并据此分布把连接属性分割成L个子范围[LowerBound,UpperBound),子范围数目和查询区域中划分格数目相等,并使每个子范围内元组数近似相等.每个中心节点CNi处理一个子范围[CNi.LowerBound,CNi.UpperBound)内元组的连接结果.然后,基站向查询区域内所有节点下发中心节点CNi.ID及其位置信息(CNi.x,CNi.y)、中心节点处理连接结果的子范围[CNi.LowerBound,CNi.UpperBound).如图4所示,查询区域被划分成4个格,中心节点CN1~CN4分别处理子范围[0,10),[10,20),[20,30),[30,40)内元组连接结果.例如[CN1.LowerBound,CN1.UpperBound)=[0,10).4.4.2本地数据存储在每一轮第m(1mM)个时间片TSm内,普通节点sj判断得分属性值sj.score是否属于[Sm.LowerBound,Sm.UpperBound)范围.如果属于该范围,普通节点sj选取离自己最近的中心节点CNi作为目标节点D,并采用基于地理路由协议,如GPSR[18],把采集的属性值封装在元组T中,并传输给目标节点D.此时,采用(T,D)消息格式,T代表元组,T=(sj.id,join,score);D代表目的地中心节点CNi的位置信息,D=(CNi.x,CNi.y).各中心节点收到本格内各普通节点发送的元组Tj后,按照连接属性值Tj.join属于哪个子范围,把该元组归入到相应的子范围表L_SubCNi中.子范围表L_SubCNi组.如图4所示,每个中心节点有4个子范围表,L_SubCNi1,L_SubCNi2,L_SubCNi3,L_SubCNi4;分别对应4个子范围:[0,10),[10,20),[20,30),[30,40).如果中心节点CN1有一条元组Tj.join=1,Tj.join∈[0,10),该元组Tj将归入到子范围表L_SubCN11中.各中心节点CNi对每个本地子范围表L_SubCNi中元组按照得分属性值(score)从大到小排序.4.4.3中心节点计算top-k连接结果(1)本地局部top-k连接结果计算.在当前时间片TSm内,各中心节点CNi计算连接属性值(join)落入自己子范围[CNi.Lower-Bound,CNi.UpperBound)内新产生的top-k连接结果NLCNik,将其归并到LCNik中,并识别被抑制元组(算法4第10行).LCNik=(LCNik∪NLCNik)top-k.如图4,中心节点CN1在当前时间片TS1内计算自己子范围[0,10)内的局部top-2连接结果,获得top-1和top-2组合得分分别是18和15.NLCNik=NLCN12={18,15}.(2)正常值数据包构建、发送和接收.中心节点CNi把子范围表L_SubCNi的元组封装成正常值数据包发送到中心节点CNg.Page9如图4,中心节点CN1需要把子范围表L_SubCN12,L_SubCN13和L_SubCN14中需要发送的元组分别封装成数据包发送给相应的中心节点CN2,CN3和CN4.消息包格式如图6左边所示.LMaxScore表示中心节点CNi的局部最大得分值,LMaxScore只在第1个时间片TS1且第1个数据包内传输给其它中心节点CNg(i≠g);tuple表示需要发送给其它中心节点CNg的元组;LTopk表示中心节点CNi能封装进一个数据包的局部top-k连接结果个数;LTop1Score到LTopkScore表示各个局部top-k组合得分.图6右边所示为中心节点CN1第一个消息包.假设中心节点CN1的局部最大得分值是11;中心节点CN1有2个局部top-k结果,其组合得分分别是18和15;tuple表示中心节点CN1需要发送给其它中心节点的元组.局部top-k连接结果以“捎带”传输方式进行传输.“捎带”传输方式是指:如果正常传输的数据不能完全填充一个数据包,该数据包剩余的空间可以传输局部top-k连接结果.之所以使用“捎带”传输方式,是因为每次把完整的局部top-k连接结果传输给其它中心节点,将耗费很多能量和带宽,而这些局部top-k连接结果不一定属于最终的全局top-k连接结果.该阶段结束时,中心节点CNi将收到其它中心节点CNg(i≠g)发送的属于中心节点CNi处理子范围[CNi.LowerBound,CNi.UpperBound)内的数据包.如图4所示,中心节点CN1将收到中心节点CN2,CN3和CN4发送的属于中心节点CN1处理子范围[0,10)内的数据包.(3)边界值数据包构建、发送和接收.在连接条件中,|Ti.join-Tj.join|τ.这样,属于子范围表L_SubCNii中的元组也可能和子范围表(i+1)中的元组满足连接条件.如图4,如果连接L_SubCN(i+1)条件为|Ti.join-Tj.join|1,而中心节点CN2某元组Ti的连接属性值Ti.join=19.5,该元组属于子范围表L_SubCN22;中心节点CN3某元组Tj的连接属性值Tj.join=20.1,该元组属于子范围表L_SubCN33.|Ti.join-Tj.join|=|19.5-20.1|=0.61.因此,这2条元组满足连接条件.要保证结果正确,中心节点CNi需要把子范围表L_SubCNii中连接属性值∈[CNi.UpperBound-τ,CNi.Upper-Bound)的元组封装成数据包发送给中心节点CN(i+1)(算法4第15行).如果中心节点CNi有两条元组的连接属性值都属于[CNi.UpperBound-τ,CNi.UpperBound),那么这两条元组的连接结果只在中心节点CNi中统计,不在中心节点CN(i+1)中统计,避免重复计算.如图4,中心节点CN2需要把子范围表L_SubCN22中连接属性值∈[20-τ,20)的元组发送给中心节点CN3.如果Ti.join=19.9;Tj.join=19.8,这两条元组都会被送往中心节点CN3,但连接结果只在中心节点CN2中统计,不在中心节点CN3中统计,避免重复计算.(4)局部top-k连接结果合并和过滤.中心节点CNi收齐其它中心节点CNg发送的正常值数据包和边界值数据包后,解析数据包,并保存对应数据.这样,每个中心节点CNi都将收到其它中心节点CNg的局部最大得分值,就能得出整个查询区域内全局的最大得分值GMaxScore.如图4所示,设GMaxScore=11.中心节点CNi将自己新产生的top-k连接结果NLCNik和其它中心节点“捎带”传输的部分top-k组合得分PLCNgCNik归并到LCNik中,然后对LCNik按照组合得分排序,并取top-k最大组合得分连接结果,即LCNik=(LCNik∪NLCNik∪PLCN1CNik∪…∪PLCNgCNik)top-k.scoreCNik是LCNik中最小组合得分,即第k个组合得分值.如图4所示中心节点CN2,设NLCNik=NLCN22={16};PLCNgCNik=PLCN1CN22={18,15}.LCN22=(LCN22∪NLCN22∪PLCN1CN22∪PLCN3CN22∪PLCN4CN22)top-2={16,18,15}top-2={18,16}.scoreCN22是16.如果某元组Ti的得分属性值Ti.score和最大得分属性值GMaxScore的组合得分f(GMaxScore;Ti.score)scoreCNik,则该元组Ti将不属于最终top-k连接结果.如图4所示中心节点CN2,f(GMaxScore;Ti.score)=(GMaxScore+Ti.score)scoreCNik.即Ti.scorescoreCNik-GMaxScore=16-11=5.在下一个时间片TSm+1内,得分属性值(score)小于等于5的元组都不属于最终top-k结果,都不用发送给其它中心节点,都能被抑制掉.所以,中心节点CN2的元组(7,1,4)能被抑制.(5)算法终止条件.中心节点CNi根据目前所获得的top-k连接Page10结果LCNik,按照基本top-k连接算法BTJQ判断是否满足停止条件.如果满足,中心节点CNi发送停止(terminate)消息给其它中心节点CNg(i≠g).中心节点CNi把TerminateFlag标志位和LCNik中没有发送给中心节点CNg的属于CNi产生的最大的能封装进一个消息包的top-k连接结果封装成一个停止消息包发送给中心节点CNg.中心节点CNg接收到停止消息包后,解析消息包并重新计算top-k连接结果LCNgk.如果中心节点CNi发送或接收了停止消息包,CNi把自己子范围[CNi.LowerBound,CNi.Upper-Bound)内计算获得的、属于LCNik的匹配元组发送给基站,然后退出.否则,继续进行下一个时间片内数据传输.优化方法:分布式top-k连接算法DTJQ中,中心节点CNi需要把边界值数据包传送给中心节点CNi+1.在基站让每个中心节点对应一个子范围时,可以让相邻子范围的中心节点也相邻,以减少数据传输距离.定理2.每个中心节点只获得部分top-k连接结果LCNik,但基站能获得正确的全部top-k连接结果.证明.中心节点CNi的top-k连接结果LCNik包括自己子范围[CNi.LowerBound,CNi.Upper-Bound)内产生的全部top-k连接结果,还包括其它中心节点发送给CNi的部分top-k连接结果.scoreCNik是LCNik中最小组合得分.Lk表示基站所获的查询区域内top-k连接结果,scorek是Lk中最小组合得分.Lk=(LCN1k∪…∪LCNLk)top-k.因此,scoreCNikscorek.根据基本top-k连接算法BTJQ,若scoreCNikTScore,满足停止条件,中心节点CNi发送停止消息给其它中心节点,并发送top-k连接结果给基站.此时,必然scorekTScore,也满足停止条件.因此,基站能获得正确的全部top-k连接结果.证毕.5实验为了分析和验证各算法的性能,我们在omnetpp-4.1平台上实现了本文提出的各个算法,并和SENS-Join[13]进行了比较.我们的实验使用了真实数据集LUCE①.该数据集包含各节点的位置信息,因节点分布不均匀,破坏了网络连通性,我们修改了个别节点的位置.该数据集还包含多个属性,如环境温度(AmbientTemperature)、相对湿度(RelativeHumidity)、土壤水分(SoilMoisture)等等.我们取环境温度(AmbientTemperature)属性作为得分属性值,相对湿度(RelativeHumidity)属性作为连接属性值.在该数据集中,取88个有效节点构成网络,并从该数据集中为每个节点获取连续1000条记录.我们定义一个采样周期为一轮,这意味着每个节点采集1000轮数据.消息包大小为30Bytes,连接属性值和得分属性值分别占4Bytes,节点ID占2Bytes.如前所述,相对于节点计算,节点之间通信将消耗更多的能量.因此,我们使用网络通信代价作为衡量网络性能的指标,该指标包括平均发包数和网络生命周期.平均发包数为平均每轮每个节点发包数.网络生命周期是指从网络开始运行到有传感器节点失效时的轮数.从网络可用性角度看,网络生命周期是比平均能量消耗更有用的指标.节点发包数越多,消耗能量越多,越容易提前死亡,网络生命周期越短.所以,我们以最大发包数衡量网络生命周期,最大发包数是指网络内所有节点中平均每轮发包数最大的那个节点发包数.在我们的方案中,网络层基于TAG[19]路由,假设通信链路没有错误,MAC层是理想的.基站通信范围通常远大于普通节点的通信范围,因此,假设基站通信范围能覆盖监测区域.除非特别说明,实验中使用如下默认参数:得分函数f=(A.Temp+B.Temp);连接条件|A.RH-B.RH|1%;需要获取top-3连接结果;每一轮时间T分成10(M=10)个时间片;基站位于网络区域中心.实验测试,并分析了各算法的性能.5.1实验场景1各算法性能分析场景(Scenario)1中88个节点根据数据集LUCE中位置信息构成网络,基站位于网络区域的中心.图7中,DTJQ-3表示网络中均匀地选择3个中心节点的DTJQ算法.因为数据集中没有超出最大门限得分属性值MaxThresholdScore的数据,所以CTJQ和OCTJQ性能一样.如图7(a)和(b)所示,在默认参数情况下,随着时间片M数目增大,CTJQ、OCTJQ和DTJQ-3算我们将所有算法在3个不同应用场景下进行了①http://sensorscope.epfl.ch/index.php/Environmental_DataPage11法最大和平均发包数都变小.这是因为时间片M数目越大,越能在较前时间片内满足停止条件,从而发包数越少.但是当M增大到一定值时,最大和平均发包数基本稳定.这是因为当时间片M数目图7实验场景1各算法性能比较如图7(c)和(d)所示,当连接条件是要求两元组连接属性值完全相等时,τ=0,即|A.RH-B.RH|0,将导致满足连接条件元组数目非常少.此时,在SENS-Join算法中,第1次收集的连接属性值中满足连接条件的节点数目非常少,导致第2次收集得分属性值数据时,只有少量节点需要发送数据.而CTJQ、OCTJQ和DTJQ-3算法中,因为满足连接条件的元组数目非常少,在前面数个时间片内发送的数据不能满足停止条件,一般需要等全部M个时间片内数据收齐后,才满足停止条件,导致自己没有数据发送但需要中继其它节点数据的中继节点数非常多,额外发送了大量数据包.所以当连接条件是要求两元组连接属性值完全相等时,即τ=0,CTJQ、OCTJQ和DTJQ-3算法不如SENS-Join算法.但是随着相对湿度差τ越来越大,连接条件越来越宽松,满足连接条件的元组越来越多,CTJQ、OCTJQ和DTJQ-3算法越来越能让前面数个时间片内发送的数据满足停止条件,从而最大和平均发包数越来越少.而SENS-Join算法中,随着相对湿度差τ越来越大,连接条件越来越宽松,第1次收集的连接属性值中满足连接条件的节点数增多,导致第2次收集得分属性值数据时,有大量节点需要发送数据,从而最大和平均发包数增多.如图7(e)和(f)所示,随着top-k增加,用户所很大时,每个时间片内需要发送数据的节点数减少,但自己无数据发送而需要中继转发其它节点数据的节点增多,导致最大和平均发包数趋于平缓.需连接结果也越多,若要求CTJQ、OCTJQ和DTJQ-3算法满足停止条件,需要时间片数也越大,导致最大和平均发包数增多.但是,一般情况下,CTJQ、OCTJQ和DTJQ-3算法明显好于SENS-Join算法.总之,在4个对比算法中,随着各参数变化,一般CTJQ和OCTJQ算法最大和平均发包数最少,DTJQ-3算法次之,SENS-Join算法最大和平均发包数最多.5.2实验场景2各算法性能分析场景(Scenario)2中88个节点根据数据集LUCE中位置信息构成网络,基站位于网络区域的中心.假设最大门限得分属性值MaxThresholdScore=100(该值满足选择门限得分属性值MaxThresholdScore式(1)条件),并且在真实数据集LUCE中设定有1%节点的环境温度(得分属性)值大于等于MaxThresholdScore.如图8(a)和(b)所示,在默认参数情况下,随着时间片M变化,OCTJQ算法中最大和平均发包数都比SENS-Join、CTJQ和DTJQ-3算法少.如图8(c)和(d)所示,在默认参数情况下,随着连接条件相对湿度差τ增大,开始时,OCTJQ算法中最大和平均发包数都比CTJQ算法少.随着相对湿度差τ变得很大,OCTJQ算法中最大和平均发包数反而可Page12能比CTJQ算法多.这是因为相对湿度差τ变得很大时,意味着连接条件变得很宽松,满足连接条件的节点数也很多.而OCTJQ算法中,基站收到大于等于最大得分属性值MaxThresholdScore的元组后,将其对应连接属性值下发给网络,因连接条件变得很宽松,匹配元组数非常多,导致需要上报的节点数图8实验场景2各算法性能比较5.3实验场景3各算法性能分析场景(Scenario)3如图9所示,88个节点根据数据集LUCE中的位置信息构成一个子网络,由4个子网络等比例无缝拼接成一个大网络.基站位于大网络左上方起始点位置,即location(x,y)=(0,0).只有右下方子网络4采集数据,基站要求获得子网络4内top-k的连接结果.子网络1,2和3虽然不采集数据,但能中继传输子网络4中节点的数据给基站.DTJQ-3表示网络中均匀地选择3个中心节点的DTJQ算法.因为数据集中没有超出最大门限得分属性值MaxThresholdScore的数据,所以CTJQ和OCTJQ性能一样.也很多.所以,在这种情况下,有大量节点上报,OCTJQ算法反而可能不如CTJQ算法.如图8(e)和(f)所示,在默认参数情况下,随着top-k变化,OCTJQ算法中最大和平均发包数都比SENS-Join、CTJQ和DTJQ-3算法少.如图10(a)和(b)所示.在默认参数情况下,随着时间片M的变化,DTJQ-3算法中最大和平均发包数都比SENS-Join、CTJQ和OCTJQ算法少.如图10(c)和(d)所示,在默认参数情况下,开始时,连接条件相对湿度差τ很小,DTJQ-3算法中最大和平均发包数都比SENS-Join、CTJQ和OCTJQ算法少.即使当相对湿度差τ=0时,DTJQ-3算法中最大和平均发包数也比SENS-Join少,这是因为DTJQ-3算法计算top-k连接结果是在查询区域内进行,即使连接条件很紧,符合连接结果的匹配元组对很少,DTJQ-3算法各中心节点之间交换元组数也有限,不会出现大量元组交换.随着相对湿度差τ变大,DTJQ-3算法中最大和平均发包数趋于平缓.当相对湿度差τ变得很大时,意味着连接条件变得很宽松,满足连接条件的节点数也变得很多,这时CTJQ算法能在靠前时间片内获得正确的连接结果.所以,DTJQ-3算法最大发包数可能多于CTJQ算法,而平均发包数DTJQ-3算法依然少于CTJQ算法.如图10(e)和(f)所示.随着top-k变化,DTJQ-3算法最大和平均发包数都比SENS-Join、CTJQ和OCTJQ算法少.Page13图10实验场景3各算法性能比较总之,在默认参数情况下,DTJQ-3算法平均发包数比CTJQ算法少35%左右.实验结果表明,分布式top-k连接算法DTJQ更适用于查询区域为网络中子区域,该子区域离基站很远的场合.在连接条件很紧的情况下,分布式top-k连接算法DTJQ性能更好.6总结在无线传感器网络中,为了找到组合得分最大(或最小)的k个相似网络环境,我们提出了基本top-k连接算法BTJQ、集中式top-k连接算法CTJQ、优化的集中式top-k连接算法OCTJQ和分布式top-k连接算法DTJQ.这些算法的目标是减少数据包发送量,减少节点能量消耗,延长网络生命周期.实验结果表明,本文所提算法好于经典连接算法SENS-Join.下一步,我们计划在复合连接条件下实现top-k连接,并进一步减少数据包发送量.
