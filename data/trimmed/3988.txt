Page1基于多尺度描述方法的移动用户界面生成框架杜一1),2)田丰1)马翠霞1)戴国忠1)王宏安1)1)(中国科学院软件研究所人机交互技术与智能信息处理实验室北京100190)2)(中国科学院大学信息科学与工程学院北京100190)摘要用户界面自动生成技术随着移动设备及用户界面的多样化而变得越来越重要.当前用户界面生成技术的主要问题是缺少对界面进行良好描述的界面描述语言,或者生成的界面依然遵循传统的图形用户界面的规范.针对上述问题,文中首先提出一种多尺度的界面描述方法,该方法能够在不同的层次上对界面进行模块化的描述;然后以该描述方法为基础,提出一种基于该方法的移动界面生成框架;在框架中,该文尝试对当前移动设备的界面进行控件级别的分析,并详细介绍了框架中涉及的关键算法.该方法能够提高需求分析人员、界面设计人员及界面开发人员的工作效率,降低因不同领域知识导致的额外的沟通成本.关键词用户界面描述语言;用户界面生成;移动计算;用户界面开发;模型驱动的开发;移动互联网1引言用户界面是指人与计算设备进行信息交换的媒介,主要包括软件界面和硬件界面[1].研究表明,在交互式应用程序中,有48%的代码与用户界面直接相关;在软件开发过程中,50%的时间消耗在了与用户界面有关的工作中[1-3].随着移动设备的普遍应用及快速发展,使得移动设备的用户界面开发越来越重要.相比传统的个人电脑,移动设备的用户界面主要有几个方面的不同:第一,移动设备的种类多种多样,移动设备的尺寸也各不相同.这使得开发者在设计与开发相关的用户界面时必须考虑各种不同的设备的类型、尺寸等设备特征.第二,移动操作系统种类繁多,同一移动操作系统的分支多种多样.不同的移动操作系统上的界面表现各不相同.在开发时必须充分考虑不同的目标操作系统.第三,移动用户界面由于其交互方式从传统的键盘控制发展到触控、笔控、动作控制等多种交互方式,其组成界面的各个部分相比传统的用户界面,也发生了变化,如菜单(Menu)在移动设备上的使用逐渐减少,而且形态也与之前有所不同.随着用户界面特别是移动设备界面的不断发展,不仅用户界面的开发越来越复杂,其分工也越来越细致.当前与界面开发相关的角色包括需求分析人员、界面设计人员、界面开发人员等等.移动设备界面的复杂性,使得界面相关的工作人员的工作量迅速增加;并且,各个角色的专业技能各不相同,其使用的对界面进行描述的工具也各有差异,这导致了各个角色之间的沟通成本的提高.使用基于模型的界面开发方法,通过对界面模型的定义,并利用相关的自动化方法生成用户界面,是解决这种问题的有效方法.基于该方法的研究,当前主要是通过设计用户界面描述语言作为对应的模型,并以此为基础设计出相应的界面生成工具.通过对大量的界面描述语言及界面生成工具进行分析,我们发现当前的方法主要有以下的不足:首先,界面生成工具所依赖的界面描述语言的描述能力不够,在一定程度上阻碍了界面生成工具的发展.需要对界面进行层次化及模块化的描述,并以此为基础,不断地对界面生成工具进行优化.通过界面的自动生成,一方面,能够降低界面设计人员与开发人员为不同尺寸、不同操作系统设计与开发用户界面的工作量,提高界面开发的效率;另一方面,通过相对统一的界面描述语言及对应的工具,能够减少界面开发过程中各个角色之间沟通的成本.其次,由于交互设备的不断变化,对移动设备用户界面的生成有了迫切的需求,虽然有相应的生成工具能够生成移动设备的用户界面,如UNI-FORM[4]、Huddle[5]等等.但是生成的界面全部遵循基于WIMP(Window,Icon,Menu,Pointing)范式的OpenLook界面规范.这种界面描述规范,最初由SunMicrosystems与AT&T公司提出,主要面向基于WIMP界面范式的图形用户界面,对组成图形用户界面的各个部分都进行了描述,并在相当长的一段时间内指导了用户界面的开发,以致基于界面描述语言的界面生成工具大都是以OpenLook规范的界面作为目标界面.但是当前的各种移动操作系统及交互技术的发展,使得用户界面特别是移动设备上的用户界面发生了很大的变化,OpenLook已经不适用于对移动设备用户界面的描述.因此,需要对当前移动设备的用户界面进行分析,并针对其特点对生成工具进行优化.针对上述问题,本文首先提出一种能够从不同的抽象层次上对界面进行多尺度描述的用户界面描述语言,该描述语言使用了层次化、模块化的描述方法,可以提高界面描述的可复用性,并用来辅助界面的自动生成.在此基础上,进一步提出了一种基于该描述语言的界面生成框架.在对界面生成框架进行介绍的过程中,我们尝试在控件级别对当前的移动用户界面进行分析,找出移动用户界面与传统用户界面在控件选择上的不同;并详细介绍了界面生成框架中的主要部分———布局引擎的数据结构和关键算法的实现.最后,我们给出利用该框架及布局算法的几个应用实例.2相关工作2.1基于XML的用户界面描述语言用户描述语言是一种对用户界面进行描述的通用方法,它通过使用规范化的描述,诸如XML、状态转换图、图表等方式,对用户界面进行描述.利用基于模型的界面开发方法[6-7],将界面描述语言作为界面模型的主要部分,来辅助用户界面的开发,并实现用户界面的自动生成.由于XML规范的自描述性、灵活性等特点,使得基于XML的界面描述语言的应用越来越广泛.XAML①是微软推出的一种界面描述语言,它①http://msdn.microsoft.com/en-us/library/ms752059.aspxPage3能够支持对界面各个组成部分的详细描述,并且能够通过对自定义控件描述的支持,来扩展界面的描述能力.XUL①是由Mozilla支持的一种基于XML的界面描述语言,它能够对基于Web的用户界面进行描述,与DHTML很类似.这两款界面描述语言都得到了广泛的应用,最大的好处是描述语言均由特定公司提出,有完善的商业支持.但是这种方式存在一定的问题:首先,由于有固定厂商的支持,描述语言有相当大的局限性,大多数此类描述语言只能生成特定语言(如C#)的界面,对其它语言几乎没有支持.其次,对界面的描述均为对界面具体组成的描述,这使得通过一套界面描述生成多个平台、不同设备上的用户界面成为问题.而这个问题的解决,由于设备的多样化而变得越来越迫切.PUCSpecificationLanguage[4-5,8-9]是专门为描述各种电器控制设备的界面而设计的描述语言,它能够以图形用户界面和语音界面两种方式描述多达30多款电器设备.该语言从功能和内容两个方面对基于电器设备的用户界面进行描述,并提出了“组树”(GroupTree)的概念来辅助设计界面.除此之外,PUC还针对电器设备界面的特性,提出了“智能模板”(SmartTemplates)来解决电器控制设备界面的特殊展示方式的问题,如播放器的通用界面展示.并通过UNIFORM与HUDDLE两款界面生成工具,解决电器设备界面的一致性问题.UIML[10-11](UserInterfaceMarkupLanguage)是一种扩展性很强的界面描述语言,它使用树状结构对用户界面进行描述,通过在元语言之外的各种词汇表描述的界面元素、属性和事件来增强自身的描述能力,并且能够与很多通用的标准同时工作,如HTML、VoiceXML等.其显著特点是可以在语言中指定界面事件对应的逻辑.通过将用户界面的描述和与外部UI引擎的交互规则分别描述,将用户界面进行了一定程度的抽象,并且将与平台相关的部分允许开发者通过扩展的方式来实现.这种方式,一方面降低了UIML本身的复杂度,使得基于UIML进行界面描述只需要使用最多50个标签就能完成.另一方面,使得在使用UIML对界面进行描述时,可以忽略具体的目标代码所用的平台,在一定程度上,使得UIML可以一次描述而应用在不同的平台上.XIML[12]定义了多种模型,如任务模型、对话模型、用户模型、展示模型等,并通过关系和属性使得各个独立的模型相互联系.UsiXML(UserInterfaceeXtensibleMarkupLanguage)[13],与XIML类似,它将界面描述分成领域模型、抽象界面模型、具体界面模型、任务模型、转换模型、上下文模型、资源模型等.在该语言中,对具体界面模型中的界面组件的描述非常丰富,但对领域模型、上下文模型的定义相对简单.MARIA[14]以TERESA[15]语言为基础,也使用CTT任务模型、抽象界面描述及具体界面描述,增加了对面向服务的架构的支持,通过提供一个与WSDL(WebServiceDescriptionLanguage)的映射,允许设计者在设计界面时在界面中增加已经存在于网络的各种服务.较好的设计工具支持以及CCT任务模型的理论支持,使得MARIA与TERESA两种语言有一定的影响力.此类界面描述语言目标能够支持对界面的灵活的描述,但是它们也存在一些不足.首先,大多数界面描述语言对移动设备的界面描述能力不足.在这些描述语言中,只有PUCLanguage明确指出支持对移动设备上的用户界面的描述,但一方面,其遵循的依然是OpenLook的GUI界面规范,并不完全适合当前的移动用户界面;另一方面,该描述面向特定领域的设备,如电器设备的界面,其中很多内容不适合当前流行的智能手机、平板电脑的界面.其次,虽然在很多描述语言中,使用了层次化及模块化的界面描述方法,但在各种界面生成工具及生成算法的实现上,并没有充分利用层次化及模块化的描述,使得在界面的自动生成方面与依赖XAML等描述语言的界面生成没有明显的区别.2.2用户界面生成以用户界面描述为基础,通过工具来辅助用户界面的自动生成,可以给设计者或开发者提供建议,降低界面开发人员的开发难度,并且好的工具还能够提高界面开发人员与界面设计人员之间的沟通效率.用户界面生成可以从生成方式及生成内容两个不同的维度进行划分.从用户界面的生成方式分,当前的用户界面生成分为半自动及自动生成.其中,自动生成是指通过工具生成的目标代码可直接运行,或者直接生成可执行程序.XAML、AUIML、UIML、MARIA、TERESA、PUC等描述语言的工具即属于自动生成.其中XAML、AUIML等工具生成的用户界面不包含内部逻辑,需要编码实现.而PUC、TUIML等描述语言时因在设计时指定了内部逻辑,因此生成的代码可以直接与具体的功能相①https://developer.mozilla.org/en/XULPage4关联,这种方式适用于面向某些特定领域的用户界面的设计,并不具有通用性.半自动生成则允许在使用工具生成时,对生成的代码或可执行程序进行配置,如指定目标平台或者生成描述中的部分界面,UsiXML则属于典型的半自动生成代码机制.从用户界面的生成内容分,用户界面生成分为生成代码和直接编译两种.其中,生成代码的方式,最终生成某种高级语言的代码,如Java、C等,而生成的代码需要进行再次编译,最后生成可以运行的用户界面.生成代码的方式多见于实现多平台和多目标代码的界面描述语言中.直接编译的方式,因最终只生成某一特定平台上的用户界面,因此其生成工具在生成时将代码与运行平台直接进行关联,生成可执行程序.这种方式多见于商业的用户界面描述语言(如XAML、XUL等)或者为某一特定目标平台设计的界面描述语言(如TUIML等).本文提出的生成框架,在生成方式上,结合了半自动生成及自动生成的方式,在生成前的配置阶段,可以允许界面开发中的各种角色对诸如目标设备类型、布局类型、控件选择等各个级别的界面特征的一种或几种属性进行设定,根据不同的设定,生成对应的用户界面推荐;在此过程中,允许使用者使用自动的方式,完全由算法对界面进行生成.通过两种生成方式的结合,可以最大限度地满足不同水平、不同使用习惯的用户的需求.在生成内容上,选择了直接生成代码的方式,这样可以通过各种不同的生成器,实现不同的目标平台上代码的生成.3多尺度界面描述方法多尺度描述方法是指能够从不同的抽象层次上对用户界面进行描述,除了能够在用户界面的整体布局、控件位置等细节上的描述,还要能够在如功能描述、数据描述等抽象层次上对界面进行不同粒度的描述.对于界面设计与生成工具而言,一方面,通过使用多尺度的方法对界面的不同粒度进行描述,可以对界面进行验证,从而增加了界面设计的安全性;另一方面,通过对粗粒度界面描述的分析,可以实现用户界面的推荐及自动生成,降低了开发的复杂度,提高了界面开发的效率.借鉴当前较为成功的界面描述语言,并充分考虑到界面的自动生成以及对多设备的支持,我们设计了一种新的界面描述语言.该界面描述语言除了要具有多尺度的描述能力外,主要目标还包括以下几个方面:第一,应该使用模块化的描述方式对用户界面进行描述.通过这种描述方式,一方面增加了描述语言本身的可读性,降低了直接对描述语言进行编辑开发的界面开发人员的认知困难,提高了开发效率;另一方面,模块化的方式可以支持对组成界面的各个模块进行复用,而对模块的复用能力取决于描述语言本身对模块化的划分粒度.第二,应具有良好的可扩展性.交互设备的发展日新月异,基于不同的交互设备的用户界面的发展变化很快.因此界面描述语言必须有很好的扩展性,对新的用户界面形式有很好的支持.基于提出的设计原则,我们给出了一种用户界面描述语言———E-UIDL(ExtensibleUserInterfaceDescriptionLanguage).图1至图4是E-UIDL的部分XMLSchema描述.在这些图中,我们规定,每个矩形框表示一个节点元素,矩形框跟随的加号和减号分别表示该元素是否展开,矩形框下方的数字代表节点允许出现的次数.另外,我们分别使用内容为“S”、“C”、“A”的矩形框表示XMLSchema描述时的”Sequence”、“Choice”及“All”这3种模式.图1展示E-UIDL的主体结构,它包含一个根节点,根节点包括整个界面描述文件的基本参数,如该界面文件标识符、名称、版本信息等等.如图1所示,它由多个子模块组成,这些子模块包括抽象功能界面描述模块(AFUI)、具体用户界面描述模块(CUI)、抽象数据描述模块(ADATAMODEL)、具体数据描述模块(CDATAMODEL)、UM2模块、映射模块(MAPPING)及资源模块(RESOURCE)等.EUIDL与每个子模块都是一对多的关系,即EUIDL可以包括零个或多个子模块的实体,如一个界面描述文件可能包括多个上下文模块、数据模块等等.另外,我们使用UIDLHEADER来表示所有子模块的公用的数据结构,在结构上,它是所有子模块Page5的父类,包括子模块标识符、名称以及对子模块的描述等.其中,标识符是必须选项,通过使用标识符来保证子模块的唯一性,既可以在子模块重用时通过标识符来实现外部链接,也降低了同一个描述文件中子模块之间的耦合程度,使得子模块之间相互独立.模块之间的关联方式通过独立的映射模块来实现.AFUI[16-17]是抽象用户界面描述模块,它从一个抽象的层次对界面进行描述.该模块不与特定的界面范式有关,特定的界面范式包括对组成用户界图2AFUI与ADATAMODEL模块的XMLSchemaCUI是具体用户界面描述模块.与抽象用户界面描述模块对应,具体用户界面描述模块是对用户界面的具体描述.该模块与特定的界面范式有关,描述了基于特定范式的用户界面的各个组成部分.它与抽象用户界面描述模块是一种映射关系,一种抽象用户界面描述模块可以有多种具体用户界面描述模块的具体实现.使用抽象用户界面描述模块与具体用户界面描述模块两种模块来对界面进行描述,既可以保障了用户界面在一定的抽象层次的可复用性,也可以使两种界面模块相互验证,保证界面的正确性.当前能够描述的CUI元素的集合在图3中呈现,各个CUI元素之间相对独立,便于添加新的CUI元素的支持.E-UIDL包含了对数据的定义,这里所讲的数据既包括界面本身的输入输出数据,也包括界面描述语言在描述界面时用到的数据.其定义数据模块的方式也是以一种分层的方式实现.ADATAMODEL是抽象数据模块,它是在一个抽象的层次上对数据进行的定义,它不包括数据的具体内容.在该层模块中,可以对数据的类型及结构进行定义,这样可以允许在数据内容未知的情况下根据抽象用户界面描述模块或具体用户界面描述模块快速生成界面.CDATAMODEL是具体数据描述模块.它可以面的各个部分的具体描述,如图形用户界面中的按钮的形状、位置或者实物用户界面的实物类型等等;并且该模块除了一个默认的实现外,允许对抽象层次自行定义.通过这种方式,一方面可以与任务树等各种任务建模方法很好的结合,另一方面可以辅助实现设备无关及多尺度的用户界面描述.如图2所示,在描述抽象用户界面时,我们使用了功能组模型的概念,它由Group、AtomGroup、Input、Output以及Control几个部分组成.对数据进行详细具体的描述.当前版本可以描述的数据类型包括单一的值,如二进制数值、布尔型数值、整数、浮点数,以及链表、表格等.在每种数据类型的定义中,包括了数据本身的属性以及获取数据的方式.具体数据模块与抽象数据模块也可以实现Page6图4CDATAMODEL模块的XMLSchema相互验证,来保证界面所使用的数据的准确性.UM2模块是对用户行为进行描述的模块,图5用户界面生成框架结构图(1)界面描述.基于E-UIDL,可以通过不同模块之间的组合,对界面进行不同抽象层次上的描述,既可以通过抽象界面模块与抽象数据模块、抽象界面模块与具体数据模块的组合,或者抽象界面模块、抽象数据模块对界面进行相对抽象的描述,并且可以以这种描述为基础,利用界面生成器来生成原型界面;也可以通过具体界面模块与具体数据模块、具体界面模块与抽象数据模块的组合,对界面进行相对具体的描述,这种界面描述能够具体地描述控件级别的展示,可以不需经过界面自动生成而直接生成依赖于目标语言的用户界面代码.当前主流的界面生成工具均基于这种生成方法.(2)界面生成.主要包括两个模块,分别是界面生成器及代码生成器.其中,界面生成器的主要目的是利用对界面的抽象描述,生成统一的可以被代码UM2是我们提出的一种用户模型,该模型基于活动理论,通过分析用户日常使用交互设备的场景,将用户、上下文环境、对象及行为等统一纳入活动的研究框架,并建立用户模型.对于UM2的介绍不作为本文的重点,文献[18]对其进行了详细的阐述.通过在E-UIDL中对用户模型的支持,可以辅助自适应用户界面的描述以及生成.4界面生成框架4.1概述基于多尺度界面描述方法的界面生成框架如图5.该框架主要由3个部分组成,分别是界面描述、界面生成及界面二次开发.化的具体描述.该模块是实现界面自动生成的核心部分,它包括控件选择器、布局引擎以及界面规整器3个部分.它们利用对界面的描述的不同模块的内容,并且前一部分的输出作为后一部分的输入.在整个界面生成器的工作过程中,需要随时访问约束库来获取系统预定义的约束,通过该约束库及E-UIDL描述,来实现3个部分的功能.对约束库进行定义时,参考EBNF的规则,如使用大括号代表0或多次出现,中括号代表0或1次出现,但不对数值类型等进行详细的定义,而在描述中进行说明.ConstraintBase={SystemConstraint};SystemConstraint={ID,ControlSelectorGallary约束库(ConstraintBase)存储不同类型的约束,包括控件选择约束(ControlSelectorGallary)、单一Page7控件约束(ControlConstraint)、分屏约束(Division-Constraint)、智能布局模板(LayoutSmartTemplete)共4种,每种约束都通过一个唯一标识符类区别.控件选择约束主要用于控件选择器,它是功能组类型、数据类型、目标尺寸、目标设备及控件类型构成的多元组.功能组类型及数据类型都与E-UIDL中抽象界面模块及抽象数据模块、具体数据模块中的特定属性相对应,如“Input”、“AtomGroup”等.在约束库中,默认定义一系列的控件选择约束,控件选择器工作时,通过E-UIDL的具体描述来进行控件类型的匹配.其主要部分描述如下,其中功能组类型(FunctionType)、数据类型(DataType)、目标操作系统(TargetOs)以及控件类型对应E-UIDL中抽象界面模块、具体界面模块、抽象数据模块、具体数据模块中相关的定义.Width、Height两个符号为整数类型.ControlSelectorGallary={[FunctionType,][DataType,]FunctionType=‘Group’|‘AtomGroup’|‘Input’|DataType=AData|CData;AData=SimpleString;CData=CBinary|CBool|CEnum|CInt|CFloatTargetSize=Width,Height;TargetOs=‘Android2’|‘Android4’|‘IOS’|‘WindowsPC’|ControlType=‘IOSLabel’|‘AndroidStatic’|单一控件约束用来定义各种控件自身的一些呈现时的约束,它由控件类型及尺寸约束两部分组成,该类型约束用于分屏策略的确定以及具体的布局算法中.其主要部分描述如下,其中控件类型的定义与前述ControlType描述相同.ControlConstraint={ControlType,SizeConstraint};SizeConstraint=[MinWidth],[MinHeight],分屏约束定义是预先定义的分屏策略,它由功能组类型、权重类型、分屏数目、分屏细节4个部分组成,其中功能组类型与权重类型与抽象界面模块两个属性对应.该约束主要用于辅助全自动布局时的分屏策略的指定.其结构的描述如下,其中权重类P(CS)=P(FT)×w(FT)+P(DT)×w(DT)+P(TS)×w(TS)+P(TO)×w(TO)型(WeightType)中的定义与E-UIDL中抽象界面模块的参数对应,StartX、StartY、Width、Height这4个符号均为整数类型.DivisionConstraint={[FunctionType,][WeightType,]WeightType=‘SingleCenter’|‘DoubleCenter’|‘Fair’DivisionDetail=DivisionIndex,RectangleConstraint;RectangleConstraint=StartX,StartY,Width,Height;智能布局模板是预先定义的模板类型的约束,它主要描述了某个布局的各种属性,包括抽象界面模块的权重类型、各个组成部分的位置信息以及接受的控件的类型.智能布局模板主要用于通过全局或局部范围内的布局约束来辅助界面的整体布局,如“single_center”模板是一种单中心类型的布局模板,适用于以单一输入作为主体功能的界面,如绘图、笔记等软件的编辑界面等;“ipad_common”模板,适用于ipad经典的布局方式,即整个界面分为两个主要部分:功能导航及功能浏览.智能布局模板的描述如下,其中权重类型(ControlType)、控件类型(ControlType)及矩形约束(RectangleConstraint)与前述公式组中的定义相同.LayoutSmartTemplete={TempleteDetail{,TempleteDetail}};TempleteDetail={WeighType,RectangleConstraint,ControlType{,ControlType}};控件选择器是利用界面描述中界面模块及数据模块的定义,并对照移动界面中控件的特性,确定某一具体的功能或功能组所使用的控件类型.在该过程中,控件选择器通过访问约束库中预定义的控件选择约束,计算出所有的控件选择及对应的概率.例如,在表1中,界面描述使用了抽象界面模块及具体数据模块,那么经过控件选择器后,“Label”会被作为候选,成为界面布局器的输入;如果界面仅使用了具体数据模块作为数据模型的描述,如表2中的描述,那么通过控件选择器后,“Switch”、“CheckBox”、“RadioButton”将会被作为候选,成为界面布局器的输入.在控件选择时,对应的选择概率计算公式如下,其中,P(CS)代表控件在当前条件下被选择的概率,P(CGS)代表某一个界面的控件组合在当前条件下被选择的概率.使用的数据来自约束库中的各种控件选择约束,w为预定义的各种控件选择约束的权值.Page8表1使用CDATA与AFUI模块描述的用户界面片段…〈atomgroupdatatype=""hasOrder="true"id="g_psw"desc="g_psw"weight="0"name="text"orderIndex="1"weightType="notDefined"〉…〈inputid="ag_pswin"name="ag_pswin"desc=""〈/atomgroup〉…〈cdataid="cdata"desc="cdata"name="cdata"〉〈cstringid="data_pswin"isfixed="false"orderIndex="1"/〉desc="data_pswin"value=""name="data_pswin"source="file"〉〈/cstring〉〈/cdata〉…表2仅使用CDATA模块描述的用户界面片段…〈cdataid="cdata"desc="cdata"name="cdata"〉〈cbinaryid="isAutoLog"isfixed="true"desc="isAutoLog"value="isAutoLog"name="isAutoLog"source="file"/〉〈/cdata〉…布局引擎是在确定了控件的候选之后,对界面进行布局.该部分以控件选择器的控件选择结果作为输入,并且利用了界面的E-UIDL描述及约束库中的相关的约束,这包括:①界面描述语言的抽象界面(如果存在)描述的各功能组的排序规则以及权重规则.这些规则在抽象界面的描述中,以Group或AtomGroup的属性存在,该规则可以作为约束库的部分输入.②各个控件在不同移动操作系统上的尺寸、对齐等约束.这些约束主要从各个移动平台提供的界面指导准则中获得,并以ControlConstraint的形式存储在约束库中.如在Android平台上,按钮(Button)的最小尺寸为7mm,最优尺寸为9mm,以dp为单位,为48dp.③总体的布局约束.这主要指应用程序的总体约束,如总的排版规则、目标用户类型等,这些信息除了从界面描述获得外,还从目标设备的软硬件条件获取部分信息.将以上规则作为约束,并使用增加了约束的布局算法对界面进行布局,形成初步的界面形态.在下面的章节中,我们会介绍一种融合了自底向上与自顶向下方法的自动布局算法,该算法能够充分利用各种规则,实现对界面的布局.在形成了初步的界面形态后,我们利用一些规整化的规则[19],对界面进行进一步的优化,这些优化主要集中在对布局的微调,该部分作为界面生成部分的输出,为代码生成器提供输入.代码生成器部分,利用界面生成器生成的界面,或者利用具体界面模块与具体数据模块、具体界面模块与抽象数据模块的组合描述,生成特定语言的界面.(3)界面二次开发.界面设计人员可以根据生成的界面,对界面进行进一步的设计,并形成最终的用户界面,这样大大简化了界面设计人员设计界面及开发人员开发的工作,一定程度上屏蔽了不同目标语言的差异;另外,该部分也可以为前期的需求分析人员提供直观的展示.4.2移动用户界面特征传统的基于PC的图形用户界面使用的是桌面隐喻,遵循WIMP范式,组成界面的主要部分包括窗口、图标、菜单,通过点击来完成界面的操作.经典的图形用户界面的样子是这样的.当前移动设备的界面并没有一个公认的理论上的界面范式,但基于iOS及Android的界面都是使用“屏”的概念,即应用的界面是由各个相对独立的屏组成,每个屏根据需求包括状态栏、工具栏、导航栏等在屏幕边缘的栏目,以及由各种控件组成的屏的主体.微软提出了MetroUI的概念,目标是尝试将PC界面与移动设备的界面进行统一,强调以内容为中心,且力求界面简洁.其定义了一些界面设计的准则,也是一个积极的尝试.我们从控件层对当前流行的两个主流的移动操作系统的界面控件(移动控件)进行分析,并与基于PC的图形用户界面的默认控件(PC控件)进行比较.对于PC控件,我们主要参考了JDK等一些开发工具箱的一些默认实现.主要比较了3种平台上默认提供的控件的类型,以及其接受的数据类型.其中,控件的类型与数据的类型使用与E-UIDL中同样的描述方法,数据类型包括简单数据类型与复杂数据类型两个主要的数据类型.我们发现,由于移动设备本身及使用环境的特点,移动控件呈现了一些与PC控件不同的特点:(1)移动控件提供了更多的默认的控件实现.相比PC控件,两种移动操作系统提供的默认控件相对较多.而且同一种类型的控件,移动环境下的控件提供了更多的默认实现.分析其原因,对界面开发者而言,基于PC的界面有相当大的自由度用来开发自定义控件,而这在移动环境下是不被推荐的.例如,PC控件中并没有对日期选择控件进行默认实现,而移动控件中则有其详细的默认实现;再如,对于从几种既定选项中选择一项的功能,在移动环境下有Spinner与Picker两种选择,而在PC控件的Page9默认实现中,只有ComboBox一种推荐的默认实现.(2)同一功能的控件,在界面中的呈现形态有所差别.比如,对于二选一的功能,即接收的数据类型为布尔型的数据时,PC控件与移动控件有不同的呈现形态.在移动界面中,更多的推荐使用一种“Switch”的控件;而在PC控件中,使用CheckBox或RadioButton较为常见.虽然已经在PC上有模拟移动控件的“Switch”,但其在PC上使用的效果并不如传统的CheckBox或RadioButton好.(3)即使同为移动环境,不同操作系统提供的部分控件也有差别.这不仅体现在各种控件的呈现形态上,也体现在各个不同的移动操作系统下的控件的尺寸约束上.4.3界面生成框架数据结构及关键算法我们将布局引擎的输入抽象成一个改进的有向无环图(E-DAG),并包含根节点和明显的层次结构.其中,E-DAG的节点由抽象界面模块的每个元素组成;E-DAG的边,则包括两种不同的类型,第1种是抽象界面模块各个元素之间的父子关系,这种关系形成了一个以RootGroupNode为根的树,第2种是抽象界面模块中GroupNode与AtomGroup-Node的顺序规则,这种规则在界面描述中以元素属性的形式存在.除了包括节点的类型属性以外,对于每个GroupNode类型的节点,还包括同样以元素属性形式存在的权重规则,而对于叶节点,还包括界面描述语言中提到的各项属性.4.3.1分屏决策及控件分配算法由于各种交互设备特别是移动设备的尺寸的限制,存在在一个屏幕中不能展示全部功能控件的问题.当前,解决这个问题,主要由交互设计师及界面设计师通过手工方式进行界面的布局及设计,而没有自动化的工具来辅助这一过程.我们提出一种分屏决策及控件分配的算法,该算法融合了手工指定及自动生成两种方式,既允许通过手工指定的方式决定界面的分屏决策及控件分配方式,也支持自动及半自动的方式生成决策.该算法以界面的E-UIDL描述以及通过控件选择器计算的结果作为输入,算法使用递归的方法求解分屏策略,其伪代码描述如下.FunctionDivisionDecision(C):isDivided=true;numOfDivision=1;if(!isDivided)Outputthedivisionresult;return;P(D)=CalculateP(CG);CalculatetheoverallprobabilityP;if(P>s)isDivided=false;continue;elsenumOfDivided=numOfDivision+DividedC()-1;foreachDCiinresultofDividedC()DivisionDecision(DCi);在代码描述中,CalculateP()为计算某一个特定的控件组合是否需要分屏布局的概率,计算时使用约束库中的控件约束,结合界面E-UIDL的数据模块的描述得出.DividedC()为对单一界面进行分屏操作,该方法使用约束库中的智能布局模板,结合E-UIDL的抽象界面模块中的相关属性如Weight-Type、Weight得出.在计算出一个控件组合的概率P(D)后,需要计算总体的分屏概率P,使用如下公式:4.3.2单屏布局算法在完成了分屏决策以后,需要结合定义的数据结构,对分屏后的界面进行布局.我们介绍一种布局算法,该布局算法结合了自底向上与自顶向下的方法.核心算法的伪代码如下.首先,通过自底向上的方法,计算上层节点的最小尺寸及最优尺寸等约束,并将计算出的GroupNode的最小尺寸及最优尺寸两种约束添加为节点的约束,依次更新父节点的尺寸约束直至RootGroupNode.其中,最小尺寸的自底向上的计算与更新,与文献[20]所述方法相同.然后,用自顶向下的方法利用权重、顺序、尺寸等约束,根据层级的先后顺序,依次对各个层布局.对于同一层的节点,则形成了很多相互独立的有向无环图,该有向无环图的布局方法,可以利用诸如Force-Directed、LayeredDrawing等传统图布局方法布局.布局时主要利用顺序、权重规则、尺寸等约束,并在当前层布局结束后,依次将约束向子节点更新.整个算法是一个不断迭代寻找最优解的过程.当迭代次数超过预设的阈值,或者再次优化后已经不能满足各项约束时,算法终止,并返回当前布局后的图.Page10FunctionLayout(EDAGraphg,Rectanglec)ForeachLeafNodeingUpdateallminconstraintsfrombottomup;ForeachNodeingUpdateallmaxconstraints;DoPushRootNodetostack;WhilestackisnotemptyPopnodenfromstack;Layoutthesub-graphofnForeachGroupNoden2ofn’soutnodePushn2tostack;WhileenableoptimizeofallLeafNode&&unreachthethreadhold;5应用实例利用本文提出的界面生成框架,给出3个应用实例.这些实例对应的界面都使用E-UIDL进行不同尺度的描述.对于传统的界面开发过程来说,每一个实例的开发,都需要充分考虑在需求分析过程中获取的需求内容的完备程度,以及具体的目标设备的类型,通过这些界面设计时依赖的这些前期的约束,为每种不同类型的约束都生成目标界面.这样界面设计师需要设计多次(需求完备程度种类×目标设备种类)界面,并且界面使用设计工具进行描述,需要界面开发人员使用目标开发语言重新开发界面.而通过模块化、多尺度的界面描述,我们可以仅对界面进行一次模块化的描述,并指定其目标设备,通过符合我们提出的界面生成框架的步骤,自动生图6利用框架自动生成的用户界面截图图7一种移动设备上邮件客户端界面自动生成效果成符合要求的用户界面,将生成的界面提供给界面设计人员,界面设计人员在进行进一步的修改后,即生成目标界面.生成的界面使用目标开发语言进行描述,进一步缩小了界面设计人员与界面开发人员之间沟通的成本,一定程度上,也减少了界面开发人员的工作量.图6给出3个实例,NameInput是一个仅允许进行用户输入的实例,Login是一个传统的登录界面,这两个实例的界面描述均使用了抽象界面模块与抽象数据模块组合、抽象界面模块与具体数据模块组合两种不同的描述方法,并且两个实例分别有不同的目标设备(QVGA与HVGA).Form是一个经典的表单界面,主要功能是填写并提交表单.该实例使用了抽象界面模块与具体数据模块组合的界面描述,并且其目标设备是WVGA尺寸的屏幕.3个实例的目标平台均为Android,版本号为2.3.3.图6是生成的部分界面的截图.其中图6(e)至图6(h)是经典的表单输入界面,这里介绍了两种不同的界面,两种界面的差别主要在具体数据模块的定义上,在具体生成界面阶段,我们使用了类似SmartTemplete[9]的方式,来解决目标语言在同一个控件接收不同数据时的不同呈现问题.图7介绍了一种移动设备上邮件客户端界面自动生成效果.其中,图7(a)至图7(c),图7(d)至图7(f)分别是两种不同的设备上下文环境下生成的界面,从图中可以看到该描述下的分屏策略以及布局结果.Page116总结本文针对当前移动用户界面自动生成遇到的问题,首先提出了一种多尺度的界面描述方法,该方法实现了对界面进行不同层次的描述,并使用了模块化的描述方法.以该描述方法为基础,提出一种基于该方法的移动界面生成框架,详细介绍了框架中界面生成部分的关键算法.最后,通过实例对框架进行了初步验证.这种方法能够提高需求分析人员、界面设计人员及界面开发人员的效率,降低因不同领域知识导致的额外沟通成本.本文所述界面生成框架及对应的布局引擎,需要依赖于提出的界面描述方法.该界面描述方法除了能够通过对界面进行多尺度的描述,来实现如本文所述的界面自动生成算法外,还能够对其它多种Post-WIMP范式的界面,尤其是笔式用户界面进行描述;对此项特性的支持,我们将通过单独的文章介绍.另外,我们正在尝试将通过混合自动机来描述连续交互及多通道交互的方法[21-22]融入到当前的界面描述方法中.除此之外,本文所述的方法还有以下方面需要改进:首先,在本文中我们对移动界面进行了分析,主要关注在移动界面中与传统图形用户界面在控件一级的比较,并没有将它作为工作的重点.但移动用户界面与传统图形用户界面的区别不仅体现在控件的类型及控件接收的数据上,还包括屏的布局以及更深层次的界面隐喻等.对当前移动界面进行深入分析,找到其中的各种规律,对于下一步的界面生成工作,有着重要的意义.其次,本文提到的数据结构及对应的布局引擎有着较强的适应性,正如文中所述,在算法中,子图(Sub-graph)布局算法可以使用各种经典的图布局算法来完成.本文选择了一种较为简单的实现,在今后的工作中,我们会尝试将Force-Directed、LayeredDrawing等传统图布局算法用在子图的布局中,并分析各种子图布局算法对整个界面布局的影响.
