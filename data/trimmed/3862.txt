Page1缩减轮数PRESENT算法的Biclique分析龚征1),2)刘树生1)温雅敏3)唐韶华4)1)(华南师范大学计算机学院广州510631)2)(中国科学院信息工程研究所信息安全国家重点实验室北京100093)3)(广东商学院数学与计算科学学院广州510320)4)(华南理工大学计算机科学与工程学院广州510641)摘要轻量级分组密码算法PRESENT由于其出色的硬件实现性能和简洁的轮函数设计,一经提出便引起了工业界与学术界的广泛关注.文中作者基于Biclique分析方法,首次提出针对21轮PRESENT-80算法的Biclique密钥恢复攻击方法.该攻击方法需要278.9的计算复杂度和264的数据复杂度.此外,针对PRESENT-80的Biclique攻击也可推广到相同轮数的PRESENT-128和DM-PRESENT压缩函数的安全性分析.与其它已公开密码学安全性分析结果相比,作者提出的Biclique攻击在内存复杂度上具有一定的优势.关键词物联网;轻量级分组密码;PRESENT;Biclique分析1引言物联网是继因特网出现之后信息技术领域的又一重大技术进展,它能帮助我们将信息转变为洞察力,提高决策的质量,优化工业控制过程和生产管理,减少物流过程中的损耗,必将对经济发展和社会生活产生深远影响.但从典型物联网硬件平台,如无Page2线传感器网络(WirelessSensorNetwork,WSN)和射频识别标签(RadioFrequencyIdentification,RFID)的计算、存储和能量上来看,直接采用现有广泛应用的对称密码学算法(如AES、SHA等)仍然受到非常大的限制.从典型WSN硬件来看,处理器一般为8~16位,存储一般也只有64~1628KB,而RFID上的硬件水平更加低于WSN.某些低端RFID只支持被动式访问,在硬件资源上有着更加严格的限制.由于WSN和RFID基于无线网络传输信息,攻击者更加容易获得、干扰甚至破坏信息传输.因此,许多WSN和RFID典型应用仍然需要信息安全技术加以保障,例如基于RFID的访问控制、产品防伪或电子护照应用,其数据保密性、认证性和不可伪造性的需求不言而喻.现有数据表明一个典型RFID标签具有1000到10000个标准门电路,其中仅有200到2000个门电路可用于信息安全[1-2].由于上述条件限制,采用轻量级分组密码算法作为基础成为了物联网信息安全保障的现实选择.作为国际分组密码算法标准的AES系列,目前已公开的最优化的AES-128硬件实现仍然需要2400个门电路[3],对于受限资源环境而言还是偏高.在国际上,目前已提出不少面向受限环境的轻量级分组密码算法.如PRESENT[4]、MESH[5-6]、LBlock[7]和KLEIN[8]等.在公开发表的轻量级分组密码算法中,PRESENT算法[4]由于其出色的硬件实现性能和简洁的轮函数设计,一经提出便引起了工业界与学术界的广泛关注.表1公开文献中PRESENT-80算法的密码学安全性分析结果攻击方式轮数计算Differential16264264232[9]Saturation16220236232[10]Differential-algebraic16264.58262216[11]Linear26272264232[12]MultipleDifferential18279264232[13]Differential-algebraic15273.79259262[14]Structure18276264242[15]Biclique21278.926428本文在安全性分析方面,PRESENT由于提出时间较早,得到了业界更多的关注.表1按时间先后顺序列举了对于PRESENT抗差分、抗线性以及抗弱密钥攻击等各种密码学分析结果[9-15].在2008年,Wang[9]发表了对16轮PRESENT的差分攻击,计算复杂度为264,同时需要264个选择明文和264的内存访问.随后在CT-RSA2009年会上,Collard和Standaert[10]发表了对16轮PRESENT的积分攻击(Saturationattack),计算复杂度和数据复杂度分别为220和236.在FSE2009年会上,Albrecht和Cid[11]结合代数攻击和差分攻击提出了对16轮PRESENT的攻击,计算复杂度和数据复杂度分别为264.58和262.在2010年,Cho[12]提出了对26轮PRESENT的线性攻击,计算复杂度和数据复杂度分别为272和264,该攻击是目前已公开发表文献中轮数最高的PRESENT算法密码学分析结果.在FSE2011年会上,Blondeau和Gerard[13]发表了基于多重差分链的18轮PRESENT密码学分析,计算复杂度和数据复杂度分别为279和264.在ACISP2011年会上,Wang等人[14]再次研究代数攻击和差分攻击的结合,提出了对15轮PRESENT的攻击,计算复杂度和数据复杂度分别为273.79和259.在FSE2012年会上,Wang等人[15]基于Structure攻击方式同样给出了18轮PRESENT-80的密码学分析结果.在国内中文文献[16-18]中也给出了针对PRESENT-80的密码学分析结果,但分析的轮数均没有超过8轮.在本文中,我们基于Biclique分析方法,首次提出了针对PRESENT算法的Biclique密钥恢复攻击方法.为了构造该攻击方法,我们首先在第18轮到21轮的PRESENT-80算法上建立了两条独立的相关密钥差分链,并通过这两条密钥差分链构造了维度为8的Biclique.随后在第1轮到18轮PRESENT-80算法上,我们构建了一条在第10轮的8个比特位上的中间相遇路径.最后基于上述Biclique构造和中间相遇路径,我们实现了针对21轮PRES-ENT-80算法的密钥恢复攻击,并将攻击也推广至21轮的PRESENT-128算法.虽然基于Biclique攻击PRESENT-80的计算复杂度278.9比较高,而且与Cho提出的26轮Linear攻击[12]相比在轮数上并不占优,但与已公开密码学安全性分析结果相比,我们提出的Biclique攻击在内存复杂度上具有一定的优势.此外,我们也基于上述8维Biclique构造,给出了针对21轮DM-PRESENT压缩函数的Pseudo原像攻击.本文组织结构如下:在第2节中,我们将简要介绍PRESENT算法的基本知识;在第3节将给出Biclique分析方法的基本原理和复杂度计算公式;在第4节中,我们将详细说明基于Biclique分析方法恢复21轮PRESENT-80密钥的方法;在第5节中,我们简要说明根据PRESENT-80攻击所构造的Page3Biclique来推出针对21轮DM-PRESENT压缩函数的Pseudo原像攻击步骤;在第6节中给出本文结论.附录A中说明了21轮PRESENT-128算法的Biclique密钥恢复攻击方法.2PRESENT算法简介PRESENT算法支持80bit和128bit密钥长度,分组长度为64bit.PRESENT算法在面向硬件的轻量化上得到了很好的效果,其综合研究成果已被JournalofCryptology录用[4].算法的设计思想图1PRESENT轮函数结构PRESENT算法的密钥扩展函数采用了循环移位寄存器与S盒置换运算相结合的方法,综合考虑了性能与安全性的平衡.以PRESENT-80算法密钥K=k79k78…k0,其扩展算法步骤如下:k18k17…k19;1.首先将密钥K循环左移61bit,即k79k78…k0=2.随后用PRESENT的4bitS盒,将经过上一步循环左移操作之后的密钥K的最高位4bit输入进行置换,即k79k78k77k76=S[k79k78k77k76];面向bit的异或操作.3.将5bit轮计数器(总共31轮)与k19k18k17k16k15进行完成上述操作后,取密钥K的高64位,即k79k78…k16作为轮密钥与加解密算法中间值相异或.PRESENT-128算法的轮函数与PRESENT-80完全一致,密钥扩展算法也只是将秘钥长度由80bit增加为128bit,具体细节可参考Bogdanov等人在文献[4]一文中所给出的详细描述.3Biclique密码学分析方法目前广泛使用的迭代式分组密码的设计思路是从一些基本运算(如异或、加法、乘法、循环移位等)出发,构造简单的非线性轮函数,然后通过轮函数的来源于Serpent加密算法,但出于性能上的考虑,在扩散性上有所弱化.PRESENT分组密码采用bitslicing的方式来实现轮扩散运算,算法的轮函数结构如图1所示.每轮输入64bit在通过16个4bitS盒之后,直接通过硬件连线的方式将每个4bit分组都扩散出去.同时PRESENT的密钥扩展函数也是基于bit-shifting的方式来实现,并没有采用Rijndael所使用的最大距离码来实现算法扩散性的最优化,在抗密码学分析上存在一定风险.例如在输入差分不为0的情况下,5轮PRESENT轮函数最低仅有10个S盒输出也不为0,远低于理想扩散性能.迭代,与密钥扩展函数生成的轮密钥相结合,形成具有良好密码学性质的密码算法.由于差分、线性分析等传统密码学分析方法已被广泛应用,轮函数的设计一般都充分考虑了非线性和扩散性.但在密钥扩展函数的设计上,往往采用简单的循环移位和轮常量异或的方式来产生轮密钥,以达到提升性能和降低实现代价的目的.基于中间相遇攻击技术(Meet-In-The-MiddleAttack),Bogdanov等人[19]在亚密会2011中首次提出Biclique分析方法.Biclique方法能巧妙地利用密钥扩展函数部分扩散性的弱点,成为了第一种能在单密钥环境下以低于穷举复杂度方式攻击AES全系列加密算法的密码学分析方法.由于轻量级分组密码算法大都采用快速密钥扩展函数,扩散性往往较弱,最近研究成果表明IDEA[20]、HIGHT[21]、Piccolo[22]和LBlock[23]等算法在Biclique攻击下也无法达到理想安全性.上述针对不同分组密码算法的Biclique密钥恢复攻击的思路都是通过分析密钥扩展算法在非线性和扩散性上的弱点,通过自动化搜索的方法找出两条相互独立的、覆盖尽可能多轮数的相关密钥差分链,从而构造出最大轮数的Biclique,从而获得比穷搜索更低的攻击复杂度.由于大部分Hash算法都基于分组密码Page4来构造,将密钥扩展算法换为Hash算法中的消息扩展算法也可以为中间相遇攻击提供优势.在文献[24]中,Khovratovich等人基于上述思路将Biclique分析方法拓展到对Hash算法的分析,首次给出了针对72轮Skein-512的第二原像攻击以及针对45轮SHA-256和50轮SHA-512的原像攻击.3.1Biclique攻击步骤Biclique分析方法巧妙地通过构造完全二分图的方式,来降低Meet-In-The-Middle攻击方法中的计算复杂度.假定分组密码算法E:{0,1}n×{0,1}k→{0,1}n(分组长度为nbit,密钥长度为kbit)可以表示为3个独立部分,即E=EFEBEC,攻击者A基于Biclique的密钥恢复攻击步骤如下所述:1.A选择密钥空间的一部分作为Biclique构造的密钥组合,定义为2d×2d的矩阵犓[i,j],其中i,j∈{0,1,2,…,2d-1}.出于简化的考虑,在本文之后的描述中,如果犓[i,j]用于Biclique构造中表示为密钥空间的一部分组合,如果用于中间相遇攻击时,则表示为相对应的完整轮密钥;2.通过上述划分,整个密钥空间将分为2k-2d个子空间.对于每个子空间犓[i,j],A相应地选择2d个密文Ci和2d个中间状态Sj满足条件i,j:Sj→犓[i,j]3.通过解密预言机,A从2d个Ci中解密出所对应的2d个明文Pi;4.A检查在密钥子空间K中是否存在特定密钥犓[i,j],满足条件i,j:Pi→犓[i,]钥即为可能的实际密钥Ks.如果现有子空间均不满足条件,则返回步骤2,重新检查下一个密钥子空间.图2简化描述了上述Biclique攻击步骤.由于攻击需要用到解密预言机,所以Biclique攻击属于选择密文攻击,而传统差分攻击仅需要选择明文,在安全模型的假设上Biclique攻击比差分攻击更强一些.3.2Biclique攻击复杂度根据3.1小节的攻击步骤描述,可分析得出Biclique攻击的计算复杂度.假定分组密码算法E的密钥长度为k,分组长度为n,Biclique攻击的维度为d,根据生日悖论和中间相遇攻击原理,整个攻击过程最多需重复2k-2d次,总的复杂度CFull计算如等式(1)所示:其中:CBiclique表示构造一个Biclique所需要的计算复杂度.在文献[19]中,构造Biclique的方式有基于Rebound和基于独立相关密钥差分链两种.两种构造方法都可以根据具体算法的轮函数和密钥扩展函数的特性,通过差分链迭代扩展的方式来降低攻击所需计算复杂度;CMITM表示中间相遇攻击所需要的计算复杂度,对于整个攻击复杂度CFull是否低于穷搜索整个密钥空间起到决定性作用.根据Biclique构造方式的不同,CMITM的计算方法也有所差别,但基本上都可归结于计算i,j:Pi→犓[i,]定分组密码算法E=EFEBEC的总轮数为r,其中EF、EB和EC的轮数分别为rF、rB和rC.由于中间相遇攻击是在除去Biclique构造所覆盖的轮数之后进行,所以CMITM的复杂度需要通过相应的换算,从而转换为一次分组加密或解密运算的复杂度.在Bogdanov等人[19]对AES的攻击中,中间相遇攻击的复杂度是通过统计攻击所经过的S盒的总数与AES完整算法总的S盒运算数量加以对比得出.在本文中,针对PRESENT的中间相遇攻击复杂度也将用此方式加以估算;CFalse表示中间相遇攻击成功,但检查返回密钥并不是实际使用的密钥Ks所需复杂度.由于Biclique的维度为d,如果中间相遇攻击所对应的中间值为tbit,那么出现中间相遇攻击成功,但返回密钥错误的可能性为22d-t.因为错误的密钥无法得出现有明密文对的一一对应关系,该检测工作只需一次完整加密或解密运算即可.如果检测出返回密钥错误,攻击者将继续执行Biclique分析.从上述分析可知,CFalse对整个攻击的复杂度影响为22d-t.从上述分析可知,Biclique攻击复杂度关键在于能否在被攻击的算法中快速地建立大维度、多轮数的Biclique结构,从而将整个攻击的复杂度降低到略高于2k-2d的水平.由于现有分组密码的设计基本都充分考虑了轮函数的快速扩散性,在实际分析中建立大维度的Biclique结构并不是一项简单的工作.Page54缩减轮数PRESENT算法的Biclique分析在本节中,我们将利用独立相关密钥差分链的方式,对缩减到21轮的PRESENT-80算法构造出基于Biclique的密钥恢复攻击.该攻击方法能以278.9的计算复杂度和264数据复杂度、成功概率约为1的条件下完成密钥的破解工作.4.1PRESENT算法相关密钥差分链构造在针对AES的Biclique攻击中,Bogdanov等人[19]通过两条相互独立的相关密钥差分链来构造8维的Biclique.由于PRESENT采用4bitS盒,我们也将算法的密钥与中间值部分采取4bit分组的方式进行截断差分分析.采用4bit分组之后,PRESENT-80表2针对PRESENT-80的4轮相互独立的密钥相关差分链轮数1800000000000000000xx00000000000000000190xxx0000000000000000000000000000000020000000xxx00000000000x000x000x000x0002100000000000xxx000000xxxxxxxxxxxxxxxx由于PRESENT的密钥扩展函数只截取高64位作为轮密钥,上述两条密钥差分链充分利用了扩展函数的循环左移性质.从表2所给出的差分链的非零差分位置可以看出,差分链j和Δi无论在密钥差分还是中间值差分上都是相互独立的.同时差分链满足j→KBoomerang攻击的方式[25]来构造28×28对不同的输入输出组合,其构造方式如下:(1)攻击者任意选择三元组(S0,C0,犓[0,0]),满足条件S0→犓[0,0](2)由差分链j和S0通过公式Sj=S0j,j∈{0,1,…,28-1}构造出28个可能的输入值;(3)由差分链Δi和C0通过公式Ci=C0Δi,i∈{0,1,…,28-1}构造出28个可能的输出值;(4)综合上述步骤的输出结果,通过等式S0犓[0,0]ΔKj→算法的密钥空间缩减为20个分组(表示为K=kb19kb18…kb0),中间值缩减为16个分组(表示为S=Sb15Sb14…Sb0).根据PRESENT算法的特点对组合可能性加以缩小,把PRESENT密钥调度算法第18轮的密钥寄存器作为相关密钥差分链的输入密钥,我们搜索出可用于构造Biclique攻击的两条相互独立的相关密钥差分链.为了便于描述,我们用0和x分别表示该分组差分值为0和非0时的情况.表2给出了对应于PRESENT-80算法第18轮至第21轮的相关密钥差分链的具体形式.其中差分链j从第18轮密钥差分K分组)开始,至21轮中间值输出差分完全扩散结束;而差分链Δi由第18轮密钥差分Δki的61~65、70~72比特位开始,至21轮中间值输出差分归零结束.Biclique三元组(Sj,Ci,犓[i,j],i,j∈{0,1,…,28-1}).由于PRESENT-80在21轮后的扩散使得前后向差分链不再具有独立性,无法用于构造Biclique,通过自动化搜索算法,我们仅能从上述过程中成功构造出第18轮至21轮、维度为8的Biclique.在随后的小节中我们将利用中间相遇攻击把上述构造转化为21轮PRESENT-80的密钥恢复攻击.4.221轮PRESENT-80算法的Biclique攻击根据上一小节所构造的维度为8的Biclique,我们还需要建立从PRESENT算法第1轮到18轮的中间相遇攻击路径,才能根据3.1小节所给出的步骤,完成针对21轮PRESENT的Biclique密钥恢复攻击.基于PRESENT-80轮函数的特点,我们选择从第1轮到第10轮的前向计算和第17轮到第10轮的后向计算,两条计算路径将在第10轮的低4位比特值进行中间相遇情况分析.该前、后向计算的具体路径分别由表3和表4描述.Page6表3针对PRESENT-80第1轮至第10轮的前向计算轮数10000000000000000xxx0000000000000000020xx000000000000000000000000000000000300000xxx000000000000x000x000x000x00040000000000xxx0000000xxxxxxxxxxxxxxxx5000000000000000xxx00xxxxxxxxxxxxxxxx6xx000000000000000000xxxxxxxxxxxxxxxx70000xxx0000000000000xxxxxxxxxxxxxxxx8000000000xxx00000000xxxxxxxxxxxxxxxx900000000000000xxx000000000000000xxxx10000xxxx000000000000000000000000x000x表4针对PRESENT-80的第10轮至17轮的后向计算轮数10000xxxx000000000000000000000000x000x1100000000xxxx0000000000xx00xx00xx00xx120000000000000x0xx000xxxxxxxxxxxxxxxx13x00000000000000000xxxxxxxxxxxxxxxxxx1400xxxx00000000000000xxxxxxxxxxxxxxxx150000000xxxx000000000xxxx000xxxxxxxxx16000000000000x0xx000000000000x0xx00001700000000000000000xxx0000000000000000在前向计算过程中,我们基于密钥差分ΔKi,由EF构造出第1轮输入差分为0,而第10轮输出差分仅有8bit为非零值的理想中间相遇路径.虽然路径的构造需要密钥差分ΔKi,但该差分值仅用于构造Biclique时所选定的犓[i,j],在实际攻击中仍然只需要在单密钥环境下进行.因此,后向计算过程选定密钥差分K遇路径.该路径的计算过程是由Biclique的输入值Sj由EB逆向求出.如果某一次前、后向计算在第10轮的8bit满足中间相遇条件,则返回犓[0,0]ΔKij作为可能正确的密钥选择,检查其是否满足明密K文对应关系.如果通过正确性检验,则攻击者成功通过上述Biclique攻击方法恢复出算法实际使用的密钥.4.3攻击复杂度分析在Biclique攻击的中间相遇步骤当中,攻击者如果对每一轮中间值的输入、输出全部重新计算,那么其复杂度CMITM将会抵消掉Biclique构造所带来的优势.在完整AES的分析当中,Bogdanov等人提出了部分重计算的思想来降低中间相遇步骤所需要的计算复杂度[19].其主要思想是在分组密码算法中,仅有非线性运算会给中间值的非零部分造成不确定性的影响,而在中间相遇步骤中,攻击者仅仅需要重新计算中间值的非零部分,就可以判断是否满足中间相遇条件.为了转换部分重计算与一轮完整加解密运算的复杂度,Bogdanov等人建议用重计算所需的S盒数量与一轮完整加密运算所需的S盒运算数量的比值来估算复杂度CMITM.在表3和表4中,我们给出了每一轮所需要重新计算的PRESENT的S盒数量,该数量是由中间值和密钥差分所得出的非零值异或得出的.根据表3和表4中所给出的重计算分组数,由4.2小节所给出的针对21轮PRESENT-80算法中间相遇攻击所需的计算复杂度如下:CMITM=2d×17由于在第10轮中间相遇为两个4bit分组,由式(1)可得出整个21轮PRESENT-80的Bilcique攻击计算复杂度如下:CFull=2k-2d×[CBiclique+CMITM+CFalse]=280-2×8×(2×28×4≈278.9.由于Biclique攻击都需要解密预言机对每一个密文解密后才能进行中间相遇攻击,因而整个攻击所需的数据复杂度为全部明密文空间,即264的明密文对开销.内存开销最大值为每次构造Biclique所需的28密钥子空间.因为把整个密钥空间分成了280-16的子空间,密钥的划分具有完整性,上述Biclique攻击的成功概率是1.上述攻击可推广至PRESENT-128,攻击所基于的相关密钥差分链和中间相遇攻击路径参看附录.Page75缩减轮数DM-PRESENT压缩函数的Pseudo原像攻击在文献[24]中,Khovratovich等人将Biclique分析方法引入到基于Davies-Meyer结构的压缩函数的密码学分析中.在Davies-Meyer结构(以下简称为DM结构)下,通过采用基于分组密码加密的方式,压缩函数F将中间值CV和消息M做如下处理:假定HV是攻击者需要找出原像的Hash值.由于DM构造将消息M作为分组密码E的密钥,攻击者通过选择符合两组具有和独立相关密钥差分链相同性质的消息值,从而获得与Biclique密钥恢复攻击所类似的中间相遇攻击路径,最终推导出低于穷搜索计算复杂度的Pseudo原像攻击.上述攻击方式如图3所示.在CHES2008年会上,Bogdanov等人基于PRESENT加密算法和Davies-Meyer结构提出了DM-PRESENT轻量级Hash函数,并与其它相关Hash函数在典型RFID平台上进行了硬件性能对比[2].由于在第4节中我们已经针对21轮的PRESENT-80算法构造了4轮8维的Biclique,根据4.1小节中针对PRESENT-80的独立相关密钥差分链的构造步骤,我们可以将上述Biclique构造转换为针对21轮DM-PRESENT压缩函数的Pseudo原像攻击。假定攻击者所需要搜索原像的Hash值为HV,DM-PRESENT所选择的固定初始值为IV,具体攻击步骤如下所示:1.由于DM结构将CV值前向反馈与加密算法E的输出进行异或,攻击者可通过HV与CV直接异或的方式获得E的加密输出结果.攻击者任意选择三元组(S0,CV0,犕[0,0]),满足条件S0→犕[0,0]2.由差分链j和S0通过公式Sj=S0j,j∈{0,1,…,28-1}构造出28个可能的输入值;HVΔi,i∈{0,1,…,28-1}构造出28个可能的输出值;3.由差分链Δi和CV0HV通过公式CVi=CV04.综合上述步骤的输出结果,通过等式S0j→犕[0,0]ΔMEC(Sj,CViHV,犕[i,j],i,j∈{0,1,…,28-1});5.由于在DM结构中,消息M直接作为密钥输入进行运算,基于上述8维Biclique,攻击者能以2n-2d·(CBiclique+CMITM)的计算复杂度从给定Hash值HV与CV实现中间相遇攻击,从而获得对应的犕[i,j]作为Pseudo原像结果输出.从上述步骤可得出,攻击总共需要的计算复杂度为262.9,存储复杂度为整个明文空间264,内存复杂度为Biclique的存储开销28.6结论PRESENT算法通过极度简化扩散层的设计思路,极大地提高了算法硬件速度,同时也最大限度地降低了硬件实现上的开销.由于其出色的设计,针对其进行的各种密码学安全性分析也得到了密码学界的广泛关注.在本文中,我们利用PRESENT密钥扩展函数的特性,搜索出两条独立相关密钥差分链,并由此构造出维度为8的Biclique用于缩减至21轮PRESENT-80算法的密钥恢复攻击.同时该Biclique也可用于21轮的DM-PRESENT压缩函数的Pseudo原像攻击.从本文的分析可以看出PRESENT的密钥扩展函数的安全性虽然有所不足,但由于算法总轮数比较大,构造足够长度或维度的Biclique进行密钥恢复攻击仍然是困难的.本文所提供的独立相关密钥差分链和中间相遇攻击也可用于其它针对PRESENT算法的密码学安全性分析,例如针对PRESENT的Boomerang攻击,以及基于PRESENT的Hash函数的原像和碰撞攻击等.在未来的工作中,我们将进一步搜索具有更好性质的独立相关密钥差分链和中间相遇攻击路径,从而能攻击更多轮数的PRESENT算法.致谢感谢匿名审稿人对本文修改所提出的宝贵意见!
