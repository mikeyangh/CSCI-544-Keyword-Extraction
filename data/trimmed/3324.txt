Page1Pi+演算及其对Petri网的表达郝克刚1)郭小群1)李向宁2)1)(西北大学信息科学与技术学院西安710069)2)(西安电子科技大学电子装备结构实验室西安710071)摘要为了研究Pi演算模型的表达能力,作者用它来表达Petri网系统,证明了Petri网的某些子类,如自由选择网等,可以直接用Pi演算表达.然而对于一般的Petri网,表达却遇到了困难.文中提出了一种对Pi演算的扩展,称为Pi+演算,在原有Pi演算的通信机制中增加了多原语同步通信机制.证明了所有一般Petri网系统均可以用Pi+演算表达.关键词Petri网;Pi演算;π演算;表达能力;业务过程管理1引言众所周知,Petri网[1-3]和Pi演算(π-calculus)[4-5]是两个很好的描写并行系统的形式化模型.随着面向服务的计算(SOC,SOA)和业务流程管理(BPM)技术的发展和广泛应用以及对软件可信性要求的提高,不少学者用它们作为服务组合和业务流程技术的理论基础[6-11].但是究竟哪个模型更合适、更好,存在着很大的争论[12-13].比较多的学者认为这两个本文用对Petri网系统的表达来研究Pi演算模型的表达能力.首先严格定义了“表达”,并证明了Petri网的某些子类,如自由选择网等,可以直接用Pi演算表达.vanderAalstWil曾向力主使用Pi演算的学者提出了7个挑战[13],其中第4个挑战就是具体给出了一个例子,问它是否能用Pi演算方便地Page2表达.显然,挑战并不成功,因为这个例子属自由选择网系统,根据本文的证明,可以很容易地用Pi演算将其直接表达出来.本文提出了另一个例子,是一个非自由选择网系统,用它解释了一般的Petri网系统在Pi演算中表达的困难.接着提出了一种对Pi演算的扩展,称为Pi+演算,在原有Pi演算的通信机制中增加了多原语同步通信机制.本文对Pi+演算的进程表达式形成规则、结构等价规则、归约规则以及强表达等给了严格的定义,并且证明了一般Petri网系统能在Pi+演算中强表达.指出Pi+演算的不同表示还能描述Petri网系统更加细致的动态语义.2Petri网的某些子类可以用Pi演算直接表达首先对“表达”给以严格的定义.设有Petri网系统N=(P,T,F,m0),用M={m|m:P→}表示其所有标识组成的集合,其中={0,1,2,…}是自然数集合.为讨论方便,在本节中假定Petri网中位置的容量不受限制,弧的权值均等于1.定义1(表达).我们说Petri网系统N能被Pi演算表达,是指在Pi演算的表达式集合E中能定义一个关于归约封闭的子集SEE,称为状态表达式集合,并且能定义一个SE的结构等价类SE≡到M上的映射φ:SE≡→M,使得下述两个条件成立(注:能定义一个SE的结构等价类SE≡到M上的映射φ:SE≡→M,也可以等同地说成是定义一个SE到M上的映射φ:SE→M,使得如果s结构等价于s∈SE,即s≡s,则φ(s)=φ(s)):(1)如果在Pi演算中有状态表达式s,s∈SE,使得s→s,则或者φ(s)=φ(s),或者令φ(s)=m,φ(s)=m,在Petri网系统N中有转移t使得m[t〉m.(2)对于Pi演算中任何状态表达式s∈SE,令φ(s)=m,如果有t∈P·使m[t〉m成立,则在Pi演算中有状态表达式序列s=s1,…,sk∈SE,使演算的归约式s1→…→sk-1→sk成立,且φ(s1)=…=φ(sk-1)=m,φ(sk)=m.定义2(Pi演算状态表达式).我们在Pi演算中为Petri网系统N中每个位置和每个转移分别定义一系列带状态的位置表达式和带状态的转移表达式.对每个位置取一个带状态的位置表达式,对每个转移取一个带状态的转移表达式,然后把这些表达式用并行算子“|”连起来所构成的表达式称为状态表达式.SE定义为所有状态表达式的集合的结构等价关系闭包,显然它是Pi演算的表达式集合E的子集:SEE,而且从下述具体定义可知SE关于归约是封闭的.具体说,我们为N中每个位置Pi定义分别带状态0,1,2,…的位置表达式如下:也就是说,位置表达式的状态等于表达式中含有的以g-成立(k=0,1,2,…):显然,根据Pi演算的归约规则,有下述归约式我们为N中每个转移t定义带状态的转移表达式如下.假定·t={Pi1,Pi2,…,Pis},t·={Pj1,Pj2,…,Pjr},T=defgi1·…·gis·f-(t,{})=T=gi1·…·gis·f-(t,{gi1})=gi2·…·gis·f-(t,{gj1,gi2})=gj3·…·gjs·f-…(t,{gi1,…,gis-1})=gis·f-(t,{f-(t,{f-…(t,{f-从上述定义可知,转移表达式的状态是个集合,显然,根据Pi演算的归约规则,有下述归约式它可以是空集,也可以含有若干gi或若干f-转移表达式以gj为前缀,则转移表达式的状态是已经执行过的gj的集合.如果转移表达式以f-缀,则状态是尚未执行的f-成立:(t,{})g-g-is→-1(t,{gi1,…,gis-1})g-fj→1(t,{f-我们把从(t,{gi1,…,gis-1})=gis·f-Page3jr·T到(t,{f-f-即转移表达式中的最后一个gis的归约,称为t的激发归约.在上述定义和后面的论述中,用到进程名的定义以及递归定义(如T,可以在表达式中出现).虽然这些机制没有在Pi演算的原本定义中出现,但是已经证明,它们完全可以运用Pi演算的重复算子等表达[5].注意文中引入的(P,k),(t,h)只是为了论证而引入的代表某类表达式的记号,并不是新定义的带参数的进程名,归约时它们并不在表达式中出现.定义3(映射φ).SE到M上的映射φ定义如下.假设Petri网系统N中有m个位置和n个转移,是任意状态表达式,按照定义2,s可以表达为s=(P1,k1)|…|(Pm,km)|(t1,h1)|…|(tn,hn),其中ki是相应位置表达式的状态(i=1,2,…,m),是非负整数;hj是相应转移表达式的状态(j=1,2,…,n),是个集合.m=φ(s)定义为m(Pi)=ki+∑n其中C(gi,hj),C(f-现的次数(0或1).假设有一个标识m,我们可以构造一个状态表达式s=(P1,m(P1))|…|(Pm,m(P1))|(t1,{})|…|(tn,{}),即所有的位置表达式的状态就等于标识m中相应位置的token数,而所有的转移表达式的状态都是空集,我们称它为标准状态表达式.显然有φ(s)=m,可见φ是SE到M上的映射(也称满射).另外从Pi演算的结构等价规则不难验证此映射φ满足条件:如果s≡s∈SE,则φ(s)=φ(s).例如,设有Petri网系统如图1.m=(1,1,0),m=(0,0,1),m[t〉m,(Pi,0)=!fi·g-(Pi,1)=!fi·g-T=defg1·g2·f-(t,{})=T=g1·g2·f-(t,{g1})=g2·f-态表达式,(t,{f-s1=(P1,1)|(P2,1)|(P3,0)|(t,{}),是标准状态表达式,s2=(P1,0)|(P2,1)|(P3,0)|(t,{g1}),s3=(P1,0)|(P2,0)|(P3,0)|(t,{f-s4=(P1,0)|(P2,0)|(P3,1)|(t,{}),是标准状s1→s2→s3→s4,φ(s1)=φ(s2)=m,s2→s3是t的激发归约,φ(s3)=φ(s4)=m.引理1(映射φ满足条件1).如果在Pi演算中有状态表达式s,s∈SE,使得s→s,令φ(s)=m,φ(s)=m,则或者m=m,或者在Petri网系统N中有转移t使得m[t〉m.证明.假定在Pi演算中有状态表达式s,s∈SE,使得归约式s→s成立,且令φ(s)=m,φ(s)=m.由上面的定义和分析可知,s到s的归约只能是某转移表达式的前缀f同某位置表达式的前缀f-的通信,或者是某位置表达式的前缀g-同某转移表达式的前缀g的通信.如果是前者.假定此转移表达式是(t,{f-js+1,…,f-f-态中出现,位置表达式是(Pjs,k).归约后转移表达式成为(t,{f-置表达式是(Pjs,k+1),其状态加1.所以按照φ的定义:m(Pjs)=kjs+∑n归约后第1项加1,第2项不变和第3项减1,归约前后m(Pjs)的总值保持不变,于是有φ(s)=φ(s).如果是后一种情况.假定此时转移表达式具有形式:(t,{g1,…,gi-1})=gi·…·gs·f-jr·T,其中1is.当i=1时状态为空集,即它是f-(t,{}).我们来考察它的第一个前缀gi,肯定与它对应的位置表达式的状态ki>0:对于i≠s的情况,归约后对应的位置表达式的状态ki减1,而gi却在转移表达式的状态中新增出现,具有形式:(t,{g1,…,gi})=gi+1·…·gs·f-所以按照φ的定义,归约后m(Pi)的第1项减Page41,第2项加1和第3项不变,m(Pi)的总值保持不变,于是有φ(s)=φ(s).类型的子类定义如下:对于i=s的情况,转移表达式具有形式:(t,{g1,…,gs-1})=gs·f-归约后对应的位置表达式的状态ks减1,而且g1,…,gs-1都不在转移表达式的状态中出现,具有形式:(t,{f-也就是说,在φ(s)=m中对于所有的Pi∈·t,按φ(s)的定义m(Pi)减1,而对于所有的Pj∈t·,按φ(s)的定义m(Pj)加1.根据Petri网的定义φ(s)=m正是t激发后的标识,也就是m[t〉m.定义4(Petri网的若干子类).Petri网的若干(1)一个Petri网N=(P,T,F)称为是S网(也称状态机网statemachine),如果对于所有的t∈T,有|·t|=|t·|=1成立.(2)一个Petri网N=(P,T,F)称为是无同步网,如果对于所有的t∈T,有|·t|=1成立.显然,S网是无同步网.(3)一个Petri网N=(P,T,F)称为是T网,如果对于所有的p∈P,有|·p|1而且|p·|1成立.(4)一个Petri网N=(P,T,F)称为是无竞争网,如果对于所有的p∈P,有|p·|1成立.显然,T网是无竞争网.(5)一个Petri网N=(P,T,F)称为是自由选择网(freechoicenet),如果对于所有不同的p1,p2∈P,当p·无同步网和无竞争网都是自由选择网.自由选择网允许有竞争和同步,但是不允许连在一起出现.自由选择网还有多种形式的等价定义.例如:①一个Petri网N=(P,T,F)称为是自由选择网,如果对于所有的t∈T,当|·t|>1时,对于所有的p∈·t,有|p·|=1成立.②一个Petri网N=(P,T,F)称为是自由选择网,如果对于所有的p∈P,|p·|1∨对于所有的t∈p·,有|·t|=1成立.也就是说在自由选择网中,每个弧或者是从某位置唯一引出的弧,或者是唯一引入某转移的弧.1∩p·引理2.对于自由选择网,映射φ满足条件2.证明.即要证明限制在自由选择网的条件下,对于Pi演算中任何状态表达式s∈SE,如果有t∈P·且φ(s)[t〉,则在Pi演算中有状态表达式序列s=s1,…,sk∈SE,使s1→…→sk-1→sk,φ(s)=φ(s1)=…=φ(sk-1)和φ(s)[t〉φ(sk)成立.在自由选择网的条件下,仅有两种情况(如图2):|p·|1,或者对于所有的t∈p·有|·t|=1.第1种情况,如果有|p·|1.因为有t∈P·且φ(s)[t〉,则|p·|=1,即p·={t}.由于|·t|1,设p∈·t={p1,p2,…,ps},s1.根据自由选择网的特性有|p·s={t}.我们来考察s中与转移t相应的状态表p·达式.如果它的状态含有若干f-,不失一般可以假定它是于是从s出发经过它同与位置pj1,…,pjr相应的状态表达式的通信,最后归约为(t,{}),而且在归约中φ(s)保持不变.所以我们说,s本身或经过若干次的保持φ(s)不变的归约,可以使其中与转移t相应的状态表达式的状态或者为空集,或者只含有若干g.不失一般性,可以假定它是下式中之一.(t,{})=g1·…·gs·f-(t,{g1})=g2·…·gs·f-(t,{g1,g2})=g3·…·gs·f-…(t,{g1,…,gs-1})=gs·f-或者假定它具有形式:(t,{g1,…,gi-1})=gi·…·gs·f-状态为空集,即它是(t,{}).我们来考察它的第一个前缀gi,与它对应的位置是pi.假设此时φ(s)=m,由于m[t〉,有m(pi)1.根据φ的定义m(pi)由三项的和组成,即m(Pi)=ki+∑n由于gi{g1,…,gi-1},即gi不在(t,{g1,…,Page5j=1gi-1})的状态中出现以及p·外的任何转移表达式的状态中出现(注:对于非自由选择网这个论断不一定成立),所以可知上式第2项∑nC(gi,hj)=0.如果有某tj,在其状态中含有f-然可以进行保持φ(s)不变的归约使C(f-于是如果需要可以进行若干次保持φ(s)不变的归约使第3项∑n相应的位置表达式的状态ki=0,则可以进行若干次保持φ(s)不变的归约使ki1.当与Pi相应的位置表达式的状态ki1时,按照定义位置表达式中就有形如g-式可以同与转移t相应的状态表达式进行归约.归约后转移表达式的第一个前缀成为gi+1.同理可以依次归约,直至表达式的第一个前缀成为gs,而且这些归约都保持φ(s)不变.但是接下来的对于前缀gs的归约则是激发归约,归约后的状态表达式s正好满足φ(s)[t〉φ(s).第2种情况,假定p·={t=t1,t2,…,ts},则|·t|=|·t1|=…=|·ts|=1.我们知道与这些转移ti相应的状态表达式的状态或者为空集,或者只含有若干g,或者只含有若干f-.对于只含有若干f-的情况,我们已经在前面证明过状态表达式s可以经过若干次的保持φ(s)不变的归约,使其中与转移t相应的状态表达式的状态成为空集.又由于|·ti|=1,ti相应的状态表达式的前缀中最多只能有一个g,所以状态只能是空集(注:对于非自由选择网这个论断不一定成立),因而转移ti相应的状态表达式只能具有形式我们考虑位置p对应的状态表达式.假设此时φ(s)=m,由于m[t〉,有m(p)1.根据φ的定义,m(P)=k+∑n由于转移t相应的状态表达式的状态是空集,因而第2项∑n如果需要可以进行若干次保持φ(s)不变的归约使第3项∑n行若干次保持φ(s)不变的归约使k1,于是位置表达式中就有形如g-相应的状态表达式进行激发归约,从而归约后的状态表达式s满足φ(s)[t〉φ(s).j=1定理1.自由选择网系统可以用Pi演算表达.证明.设有一任意自由选择网系统N=(P,T,F,m0).按照定义2,在Pi演算中定义关于归约封闭的状态表达式集合SEE.再按照定义3定义一个SE到M上的映射φ:SE→M.由引理1可知φ满足条件1.再根据引理2,对于自由选择网,映射φ满足条件2.从而根据定义1可知N可在Pi演算中表达.由于S网是无同步网的子类,T网是无竞争网的子类,而无同步网和无竞争网都是自由选择网的子类,所以由定理1可以推出下述定理.定理2.S网、无同步网、T网和无竞争网系统都可以用Pi演算表达.在以上讨论中都限定Petri网中弧的权值等于1.当弧的权值允许大于1时,有下述定理,证明从略.定理3.当允许弧的权值大于1时,T网和无竞争网系统可以用Pi演算表达.3用Pi演算直接表达Petri网子类的应用例子vanderAalstWil向力主使用Pi演算的学者提出了7个挑战[13],其中第4个挑战就是问对于图3具体给出的例子,是否能方便地用Pi演算表达.根据Petri网的定义,图3是一个T网系统,因此由定理2可知,它能方便地直接用Pi演算表达.与图中的每一位置Pi对应的位置状态表达式可以表示为这里fi,gi是Pi演算中的通信通道名,分别表示相应位置的输入边和输出边.与图中的转移a,…,h对应的转移状态表达式分别表达如下:Page6于是整个Petri网系统可以表达为进程表达式(P1,1)|(P2,0)|…|(P11,0)|(A,{})|…|(H,{}).按照上述定义根据Pi演算归约规则不难看出,Petri网中转移的每一次激发,从前趋位置中取token,向后连位置中送token,都可以看作是Pi演算中相对于转移的进程同相对于前趋位置以及后连位置的进程间的若干次通信归约.显然,Aalst的挑战用图3作为例子并不成功.因为这个例子是个T网系统(属于自由选择网系统),根据上面所述的定理,用Pi演算可以很容易地将其直接表达出来.要想选个很难用Pi演算表达的例子至少必须是个非自由选择网系统.例如下节图4所示的例子,就很难用Pi演算表达.不过后面将证明,只要将Pi演算加以扩充就能表达.4用Pi演算表达一般的Petri网时遇到的困难下面我们来解释,为什么对于一般的Petri网,不能用上述方法在Pi演算中表达.例如这样一个实际例子:有两个不同的任务,可以分别由两个单位单独处理完成,也可以由第三单位将其合起来同时处理完成.此例可以表达为一个Petri网系统(非自由选择网),如图4,其中m0(P1)=1,m0(P2)=1,m0(P3)=m0(P4)=m0(P5)=0.相应的Pi演算进程P可表示如下:P=(P1,1)|(P2,1)|(P3,0)|(P4,0)|(P5,0)|(P1,1)=!f1·g-(P2,1)=!f2·g-(P3,0)=!f3·g-(P4,0)=!f4·g-(P5,0)=!f5·g-如果此时(P2,1)中的g-(T1,{})=T1=defg1·f-(T2,{})=T2=defg1·g2·f-(T3,{})=T3=defg2·f-知m0=(11000).设m1=(01100),s1=(P1,1)|(P2,1)|(P3,0)|(P4,0)|(P5,0)|(T1,{})|(T2,{})|(T3,{}).根据φ的定义和Pi演算的归约规则,显然有可能(P1,1)中的g-(T1,{})中的g1通信:s1→s2→s3,而且φ(s1)=m0,φ(s2)=φ(s3)=m1,m0[T1〉m1,其中s2=(P1,0)|(P2,1)|(P3,0)|(P4,0)|(P5,0)|(T1,{f-(T2,{})|(T3,{}),s3=(P1,0)|(P2,1)|(P3,1)|(P4,0)|(P5,0)|(T1,{})|(T2,{})|(T3,{}).信,有归约:s3→s4,而且φ(s3)=φ(s4)=m1.其中s4=(P1,0)|(P2,0)|(P3,1)|(P4,0)|(P5,0)|(T1,{})|(T2,{g1})|(T3,{}),显然此时m1[T3〉,但是s4已经再无法归约,出现了阻塞,违背了表达的条件2.直观地讲,问题出在Pi演算的通信是一个一个串行执行的,而不是一次性同步执行.上例中T2不是一次性地从P1与P2同时取出token,而是一个一个地去取.T2与P2进行通信时,T1已经与P1进行了通信,从而T2已无法再与P1进行通信,而且T3也已无法与P2进行通信出现了阻塞.为了表达一般的Petri网系统(包括位置的容量受限制,弧的权值大于1的情形),本文在原有Pi演算的通信机制中增加了多原语同步通信机制,提出了一种对Pi演算的扩展,称为Pi+演算.并且证明了用Pi+演算的归约可以较准确地表达一般Petri网系统的动态行为,而且能更加细致地描述它丰富的动态语义.5Pi+演算Pi+演算是在传统的Pi演算的基础上,增加多原语同步通信机制(multi-primitivesynchronizedcommunicationmechanism).语法作如下改动.定义5(Pi+演算进程表达式).Pi+演算的进程表达式语法(用巴科斯范式BNF表达):我们称x-〈y〉为发送原语(sendprimitive),x(z)为接收原语(receiveprimitive),x是通道名,y是沿通道发送的数据,z是接收变量.在π的语法表Page7达式中,π的并置ππ称为同步组合,在结构等价的意义上它满足结合率和交换率,所以实际上π是一个由若干个发送原语和接收原语组成的同步通信原语组合.在传统的Pi演算中,π仅仅是一个发送原语或接收原语.π的归约仅相当于一对通信原语执行的一次通信.而在我们增加了多原语同步通信机制的Pi+演算中,π是由一系列发送原语和接收原语组成的同步通信原语组合.Pi+演算中π的归约相当于多个进程的前缀π中所含有的多个通信原语成对地同步执行.另外,对x-〈y〉和x(z),在Pi演算中规定,如果参数为空(不带参数的通信),可以省略写为x-和x.在Pi+演算中也做同样规定.结构等价规则和Pi演算基本相同,在其中增加:定义6(Pi+演算结构等价规则).Pi+演算的(1)π1π2≡π2π1;(2)(π1π2)π3≡π1(π2π3);(3)如果π1≡π2,则π1·P≡π2·P.定义7(Pi+演算前缀集合完全匹配).设是由若干个前缀π组成的集合={π1,π2,…,πn},我们考虑其中所有π含的发送原语和接收原语,如果满足下述条件则称是完全匹配的(fullycomple-mentary).(1)对何任通道x,中以x为通道的发送原语的个数和以x为通道的接收原语的个数相同;(2)中所有通道名相同的发送和接收原语或者都带参数,或者都不带参数;(3)中所有通道名相同的带参数的发送原语,(4)在的任何πi中,如果πi中带参数的接收原语有多个,则其接收变量不得相同.定义8(Pi+演算归约规则).Pi+演算归约规则以Pi演算的归约规则为基础,把Pi演算中的R-react:替换成归约规则(π).设={π1,…,πs}是完全匹配的,则(x(y)·P+Mx-〈z〉·Q+N)→P[z/y]Q其发送的数据必须相同;(π1·P1+M1|…|πs·Ps+Ms)→P1|…|Ps.其中Pi(i=1,2,…,s)定义如下:如果πi中的接收原语全不带参数,则Pi=Pi;否则,设πi中带参数的接收原语有x1(y1),…,xk(yk),的所有π中所有沿通道xj(j=1,2,…,k)的发送原语发送的数据分别是zj,则Pi是由Pi将其中y1,y2,…,yk的自由出现分别替换为z1,z2,…,zk而得到的,表示为Pi=Pi[z1/y1,z2/y2,…,zk/yk].由于是完全匹配的,上述完全匹配的定义3、4保证了这里的替换不会出现混乱.例如:x-〈y〉w(u)·P+Q|x(z)珡w〈v〉·R→P[v/u]|R[y/z],x-〈y〉x-〈y〉·P|x(z)·Q|x(z)·R→P|Q[y/z]|R[y/z].但是,下面的例子由于不满足完全匹配的条件,从而不能归约x-〈y〉x-〈y〉·P|x(z)·Q(以x为通道的发送原语的个数是2,同接收原语的个数1不同);x-〈y〉·P|x·Q(发送原语带参数,接收原语不带参数);x-〈y〉x-〈v〉·P|x(z)·Q|x(z)·R(发送原语发送的数据不同);x-〈y〉珡w〈v〉·P|x(z)w(z)·Q(在第2个进程中接收原语接收变量相同).这里要说明的是,原Pi演算中归约规则R-react是这里Pi+演算中归约规则(π)的特例(s=2,π1,π2都只含一个通信原语),所以,把R-react换成归约规则(π),实际上是对原Pi演算中归约的扩展.也就是说,原Pi演算中的归约关系也是Pi+演算中归约关系.6用Pi+演算表达一般的Petri网假设有一个具有边的权重和位置容量限制的Petri网(P/T网)系统其中P={P1,…,Pm}(位置集),于零的自然数集合,T={T1,…,Tn}(转移集),满足P∩T=∧,F(P×T)∪(T×P)(边集),W:F→K:P→m0:P→(初始标识),={0,1,2,…}是自然数集合.为了后面论述方便,我们用F和W定义扩展的权重映射A:(P×T)∪(T×P)→,如果e∈F,则A(e)=W(e),否则A(e)=0.定义9(强表达).我们说Petri网系统N能在Pi+演算中强表达,是指在Pi+演算的表达式集合E中能定义一个关于归约封闭的子集SEE,称为状态表达式集合,并且能定义一个SE的结构等价类SE≡到所有标识组成的集合M上的一一映射ψ:SE≡M,使得下述两个条件成立,(1)如果在Pi+演算中有状态表达式s,s∈SE,使得s→s,则在Petri网系统N中有由转移组成的Page8多重集Tb,使得m[Tb〉m,其中m=ψ(s),m=ψ(s).(2)对于Pi+演算中任何状态表达式s∈SE,令ψ(s)=m,如果在Petri网系统N中有转移的多重集Tb,使得m[Tb〉m,则在Pi+演算中有状态表达式s∈SE,使s→s,ψ(s)=m成立.注.多重集(Multset,也称袋子Bag)是集合概念的一种扩展,允许其中元素重复出现并标记重复的次数(重数).多重集通常用和式Tb=b1T1+…+bmTm来表示,其中bj是重数.Petri网系统的执行中,在不互斥可激发的条件下允许一个转移的多重集的所有成员一步同时激发.定义10(Pi+演算状态表达式).我们为Petri网系统N中每个位置在Pi+演算中定义一系列带状态的位置表达式,为每个转移定义一个转移表达式.我们对每个位置取一个带状态的位置表达式(Pi,ui),同所有的转移表达式Tj用并行算子“|”连起来,把所构成的表达式P=(P1,u1)|…|(Pm,um)|T1|…|Tn称为状态表达式.SE定义为所有状态表达式的集合的结构等价关系闭包,显然它是Pi+演算的表达式集合E的子集:SEE,而且从下述具体定义可知SE关于归约是封闭的.具体说,我们为N中每个位置Pi,分别针对K(Pi)=∝和K(Pi)=k两种情况,定义带状态0,1,2,…的位置表达式如下:如果K(Pi)=∝,则可以看出,位置表达式的状态等于表达式中含有的i为第一前缀的子表达式的个数.显然,根据Pi以g-演算的归约规则,有下述归约式成立(r=0,1,2,…):如果K(Pi)=k,则令Qi=deffi·Ri,Ri=defg-ifi·Ri,带状态0,1,2,…,k的位置表达式定义为g-(Pi,0)=|kQi,即(Pi,0)=Qi|…|Qi(共k个Qi并行),(Pi,1)=|k-1Qi|Ri,(Pi,2)=|k-2Qi|Ri|Ri,…,(Pi,r)=|k-rQi|rRi,…,(Pi,k)=|kRi.可以看出,表达式的状态等于表达式中含有Ri的个数,即以g-位置容量为K(Pi)=k的情况下,如果表达式中含有r个Ri,则表达式中含有k-r个Qi,以fi为第一前缀的子表达式.根据Pi演算的归约规则,在ru和r-u+vk的条件下,有下述归约式成立:为了定义与转移Tj(j=1,2,…,n)对应的表达式,我们令uij=A(Pi,Tj),vji=A(Tj,Pi)(i=1,2,…,m,j=1,2,…,n).与转移Tj对应的转移表达式定义如下注.xu表示u个相同的原语x构成的同步通信原语组合,若u=0,则x不在组合中出现.从Tj的结构可以看出,在机构等价的意义下Tj在归约中保持不变,即Tj在上述表达式中使用了进程的标志符(表达式名)和递归(表达式中出现表达式名).正如Milner在他的著作中指出的,我们没有必要在基本的Pi演算中引入进程标志符和递归,因为它们可以从Pi演算中导出[5].对于Pi+演算也同样.定义11(映射ψ).SE的结构等价类SE≡到M上的一一映射ψ:SE≡M,定义如下.假设Petri网系统N中有m个位置和n个转移,s是任意状态表达式,按照定义10,s可以表达为s=(P1,u1)|…|(Pm,um)|T1|…|Tn,其中ui是相应位置表达式的状态.m=ψ(s)定义为m(Pi)=ui(i=1,2,…,m).反之,对N中任意标识m可以令与其对应的状态表达式中的ui=m(Pi)(i=1,2,…,m).显然,如果s结构等价于s,则有ψ(s)=ψ(s).ψ是SE的结构等价类SE≡到M上的一一映射.引理3(映射ψ满足强表达条件1).如果在Pi+演算中有状态表达式s,s∈SE,使得s→s,则在Petri网系统N中有转移的多重集Tb,使得m[Tb〉m,其中m=ψ(s),m=ψ(s).证明.按照Pi+演算的归约规则和SE的定义,如果有归约s→s必然是应用了归约规则(π).设完全匹配的={π1,π2,…,πs}是归约中应用的s子表达式的前缀集合.按照SE的定义,这些π1,…,πs均来自某些转移表达式和与其相应转移的前驱位置对应的位置表达式的子表达式.从转移表达式的定义可知,转移表达式具有形式Tj=!τj,其中τj=1…gumjgu1j结构等价的表达式Page9中的子表达式τj的通信.假定Tj参与通信的子表达式的个数等于bj,即在中有bj个τj的前缀.我们要证的是对于转移的多重集有ψ(s)[Tb>ψ(s).由于是完全匹配的,中发送i的个数和接收原语gi的个数相同,发送原语原语g-i的个数和接收原语fi的个数相同从而可知,对于f-任何位置表达式Pi,设它在s中的状态值是ri,它在s中的状态值是ri,有如果K(Pi)=k,还有按照Petri网系统的激发规则可见,Tb在标识ψ(s)中是不互斥可激发的,而且激发的结果标识是ψ(s),即ψ(s)[Tb>ψ(s).引理4(映射ψ满足强表达条件2).对于Pi+演算中任何状态表达式s∈SE,令ψ(s)=m,如果在Petri网系统N中有转移的多重集Tb,使得m[Tb〉m,则在Pi+演算中有状态表达式s∈SE,使s→s,ψ(s)=m成立.证明.设在Petri网系统N中有转移的多重集Tb,使得m[Tb〉m,Tb=b1T1+…+bmTm.按照Petri网系统的激发规则,在ψ(s)=m中Tb是不冲突可激发的.对于任何位置Pi,若m(Pi)=ri则有如果K(Pi)=k,还有根据定义11关于映射ψ的定义,转移表达式具有形式Tj=!τj,其中τj=gu1j在s中位置表达式Pi的状态值是ri,具有形式(Pi,r)=!fi·g-下,具有形式其中Qi=deffi·Ri,Ri=defg-以选择前缀组合={π1,…,πs}如下.首先按照Tb选择所有结构等价的转移表达式Tj≡!τj|τj|…|τj中bi个子表达式的前缀,然后按照τj=gu1j1…gumj别匹配的等量的g-和f在位置表达式前缀中的出现.由于ri∑mi与其匹配,并且在K(Pi)=∝时,在结构等价的位g-置表达式Pi中有任意多个fi与其匹配,即使在K(Pi)=k时由于在ri个Ri中有g-缀,加之位置表达式Pi中也有足够多个g-状态可知这样选择的前缀组合={π1,…,πs}是完全匹配的.在按归约s→s后,s中所有的位置表达式Pi的状态而根据Petri网系统的激发规则,这正是Tb激发后m=ψ(s)中所有位置Pi的token数,于是证明了m[Tb〉m.定理4.任何具有边的权重和允许位置容量限制的一般Petri网系统能在Pi+演算中强表达.证明.设有一任意的具有边的权重和允许位置容量限制的Petri网系统N=(P,T,F,W,K,m0).按照定义10,在Pi+演算的表达式集合E中定义一个状态表达式子集合SEE,它关于归约是封闭的.再按照定义11定义一个SE的结构等价类SE≡到所有标识组成的集合M上的一一映射ψ:SE≡M.根据引理3~4,可知ψ满足条件1和条件2.从而根据定义9可知N能在Pi+演算中强表达.前面我们对Petri网中转移这样表示:显然,采用这种表示,如果在转移多重集Tb中某转移满足能够激发若干次的条件,就可在一步中并行执行.如果我们限制同一转移不得多于k(k∈个进程并行执行,就可表示为Tj=|kSj,Sj=gu1j如果我们限制同一转移在一步中只能执行一次,就可表示为转移在满足激发条件后,激发执行一次.执行后如果仍满足激发条件,转移再执行激发,但是必须在前次执行之后.因而,即使某转移满足能够激发若干次的条件,也必须一个个串行地顺序执行,而不能并行执行.从以上分析可知用Pi+演算可以更加细致地描Page10述和研究Petri网的丰富的动态语义.7结束语本文用对Petri网系统的表达来研究Pi演算模型的表达能力.证明了Petri网的某些子类,如自由选择网等,可以直接用Pi演算表达.然而对于一般的Petri网,却很难用Pi演算直接表达.于是提出了一种对Pi演算的扩展,称为Pi+演算,将原有Pi演算的单原语通信机制扩充成多原语同步通信机制.证明了用Pi+演算可以较强地表达一般Petri网系统,而且还能更加细致地描述它丰富的动态语义.本文的重点是比较Pi演算和Petri网系统的表达能力,从理论上说明Pi演算和Petri网表达能力之间的关系.这种关系可以用图5来示意.之所以一般的Petri网不能用原有的Pi演算直接表达,是由于Petri网的转移可以有多个输入边,从而允许多个流程的同步.可是原有的Pi演算一次只允许一个发送进程和一个接受进程进行通信,所以只允许两个进程的同步.这可以说是原有的Pi演算的不足,也正是我们引入Pi+演算,扩充成多原语同步通信机制的原由.本文指出某些Petri网系统很难用Pi演算表达,只要将Pi演算加以扩充就能表达一般的Petri网.这是否意味着Petri网模型的表达能力比Pi演算更强呢?事实上并非如此.虽然某些Petri网系统很难用Pi演算表达,但起码Petri网的某些子集可以直接用Pi演算模型表达,而且只要将Pi演算稍微加以自然地扩充,就能表达所有的一般Petri网系统.反过来,用Petri网模型来表达Pi演算则比较难.我们还不知道Pi演算的怎样的子集可以直接用Petri网模型表达.起码接收语句将接收的值代入到后继进程、通道名的传送和重复算子的使用等,都很难用Petri网模型直接表达.至于对Petri网模型做怎样的扩展就能表达一般的Pi演算,现在还实在想不出个眉目来.所以总体比较,Pi演算的表达能力看来还是比Petri网模型更强些.Petri网模型在简单、直观、有严格的分析方法等方面有其优势.但是由于Pi演算中通道名可以作为名字传送,因而能够表达结构松散的动态耦合系统,如Mobile系统为保证通信的逻辑双方不变,而通信中介的物理实体可以在移动中改变;在E-mail系统中mail地址可以传送,可以根据接收到的mail地址进行通信;面向服务的结构中可以查询服务提供方的URL,然后按照选择的URL进行绑定和链接,这都属于动态耦合.然而,Petri网模型中由于位置和转移的连接是固定的,较适合于表达结构固定的耦合系统,很难表达松散的动态耦合系统.由于本文证明了Pi+演算可以表达一般的Petri网,所以对于Petri网的那些向后兼容的扩展(back-wards-compatible,即扩展后仍可用Petri网表达的)如着色网等,肯定也可以用Pi+演算表达.至于Petri网的那些非向后兼容的扩展,Pi+演算就不一定有足够的表达能力.例如我们曾证明[14],对于带抑止弧的Petri网,如果抑止位置容量有穷,则可以用Pi+演算表达;如果抑止位置容量无穷,则需将Pi+演算再加以扩展,使其增加优先原语功能才能表达.今后我们将继续开展用Pi+演算对各种Petri网的扩展表达的研究工作.此外,为了探讨Pi+演算的表达能力,我们还研究了用它对图灵机模型的表达方法[15].需要说明一点,本文证明了如果把Pi演算扩展成Pi+演算,就能表达一般的Petri网.但是,对论断“Pi演算不能表达一般的Petri网”并没有严格证明,只能算是我们的一个直觉判断.要严格证明一个否定的论题往往相当困难,我们只是论证了不能用我们提出的用以表达自由选择网的方法在Pi演算中表达一般的Petri网.本文只是从理论上比较了Pi演算和Petri网系统的表达能力,提出了一种比Pi演算表达能力更强的扩展:Pi+演算,至于Pi+演算在其它领域和实际中的应用,还有待进一步的研究和探讨.
