Page1集合和字符串的相似度查询林学民1),2)王炜2)1)(华东师范大学软件学院上海200062)2)(澳大利亚新南威尔士大学计算机科学与工程系悉尼2052)摘要相似度查询是计算机学科中一个重要的问题,它的应用遍及多个领域,例如数据库、数据集成、互联网、数据挖掘以及生物信息学等.该文主要讨论在集合和字符串上的相似度查询.学术界从2000年来在这个领域内取得了大量的进展.作者总结了主要工作,并给出了作者的分析和归类.最后,该文提出了一些未来工作的方向.关键词相似度查询;相似度连接;前缀过滤;jaccard;编辑距离1引言给定一组在数据库中的对象R,一个查询对象Q,一个相似度函数和相似度阈值t,Q的相似度查找(SimilaritySearch)会返回R中和Q相似度至少是t的对象.如果将另一组对象S中每一个对象作为Q进行相似度查询,其结果是R和S中相似度至少是t的对,这个操作叫作相似度连接(SimilarityJoin).我们将这两类查询统称为相似度查询(Simi-larityQueries).相似度查询在计算机科学的多个领域内有广泛的应用.例如,在记录用户兴趣的数据库中,每个用户关联了一组他或她感兴趣的网址.通过使用Jaccard相似度①,我们可以找出兴趣十分类似的用户[1].在某些应用中,我们更自然地可以使用距离函数.为了找到相似度高的对象组,我们可以限定距离不超过某个阈值.例如,为了集成多个客户数据的列表,我们可以把客户信息间编辑距离不超过某个阈值的客户对返回,由专人或者自动判别工具来判断它们是否是同一个客户[2].其它的典型的应用还包括:(1)在一个记录了众多不同类型的地标的空间Page2数据库中,我们可以找出例如在地铁站附近(直线或者行走距离)500m内的意大利餐馆.(2)在数据集成应用中,我们可以使用连接字段的值大致匹配的条件连接(SoftJoin)多个异构的数据集[3-4].类似的应用还包括基于字典的命名实体识别(Dictionary-basedNamedEntityRecogni-tion,DNER),例如在网页中自动标注产品名称.我们可以使用Jaccard相似度函数进行近似匹配(例如将“canoneos5ddigitalslrcamera”匹配到“canoneos5ddigitalcamera”[5]).(3)在生物信息学中,我们需要近似的蛋白质或基因序列的匹配,以支持同源查找(HomologySearch)[6]和下一代基因测序(Next-generationSe-quencing)[7]等任务.在本文中,我们主要关注基于集合和字符串的相似度连接(即,数据和查询对象都是集合和字符串).对于这个问题,主要的数据库领域内的工作是从1997年开始[2,8-9]①,并取得了许多重要的进展.本文将对其中主要的工作进行分门别类的介绍和分析,并给出了我们认为未来的有希望的工作方向.本文第2节介绍问题的定义和相关的背景知识;第3节介绍集合上的相似度查询的技术和工作;第4节介绍字符串上的相似度查询的技术和工作;第5节介绍相关工作;第6节介绍我们对未来工作方向的展望;最后第7节进行总结.2问题定义和背景知识给定两组对象R和S,并定义在两个对象之间的相似度函数sim及其阈值t,相似度连接的定义是返回所有R和S的对象中其相似度至少是t的那些对,即{(r,s)|sim(r,s)t,r∈R,s∈S}.为了表述方便,在本文中,我们仅考虑相似度自连接,即{(r1,r2)|sim(r1,r2)t,r1∈R,r2∈R}.在某些应用中,我们可以用距离函数代替以上定义中的相似度函数,并将判断条件“sim(r1,r2)t”改为“dist(r1,r2)t”.2.1相似度函数阈值条件间的关系和转换2.1.1基于集合的相似度函数给定两个集合A和B,许多常见的基于集合的相似度函数的约束条件大多可以转化为等价的基于集合交的大小,即|A∩B|的约束条件.例如,Jaccard的定义是两个集合的交的大小除以两个集合并的大小,而集合并的大小是两个集合各自大小减去它们交的大小.B|(t/(1+t))×(|A|+|B|).定理1.Jaccard(A,B)t的充要条件是|A∩推论1.Jaccard(A,B)t的必要条件是|A∩B|t×|A|.证明.如果Jaccard(A,B)t则|B|t×|A|,带入不等式右边,即可得到以上结论.证毕.由于以上这些约束条件完全等价,我们可以集中优化基于集合相交大小的约束,而不需要为每一个相似度函数做优化.2.1.2基于字符串的相似度函数编辑距离是常见的衡量字符串相似度的函数之一.两条字符串A和B之间的编辑距离(记作ed(A,B))是使用插入、删除、替换操作将一条字符串改为另一条的所需的最少步数.字符串的编辑距离可以使用动态规划(dynamicprogramming)来计算,其时间复杂度为O(n×m)(n和m分别为两条字符串的长度)②.由于编辑距离的计算已经比较费时,在相似度查询中,如果我们还需要比较每一对字符串的话,其运行效率会非常低下.在实际的应用中,绝大多数的字符串对不满足阈值的限制.所以,我们可以通过使用一些过滤条件来剔除绝对不可能满足某个编辑距离的约束的字符串③.常见的过滤方法是将编辑距离的约束转换成特征(signature)集合间交的约束[2].常见的特征提取的方法是基于q-gram,即提取该字符串S中所有的长度为q的子串(称作grams(S)).grams(S)有|S|-q+1个q-gram④.定理2.ed(A,B)t的必要条件是|grams(A)∩grams(B)|max(|A|,|B|)-q+1-t×q.证明.可以证明在最坏情况下,每个编辑(插入、删除或者替换)操作一定可以破坏q个q-gram.并且注意到字符串X生成|X|-q+1个q-gram.通过考虑从A~B和B~A的编辑操作,以上定理可证.①②③④fy).例如它在空间数据库中被广泛应用.Page3文献[2]还考虑了q-gram的位置:只有两个相同的q-gram在各自字符串中的位置相差不超过阈值t,我们才将它们算作匹配的q-gram.所以,以上定理的条件还可以增强为matching_grams(A,B)max(|A|,|B|)-q+1-t×q.满足以上条件的字符串构成了候选集.我们仅需对候选集中的字符串进行编辑距离的验证,从而能比每条字符串都验证更加高效.这对于在关系数据库上支持基于编辑距离的查询意义尤其重大,因为以上的过滤条件都可以通过SQL来完成,仅仅最后的验证需要用户自定义函数(UDF)来实现.3集合的相似度查询3.1前缀过滤(PrefixFiltering)根据以上相似度函数阈值条件间的转换,我们知道我们需要处理两个集合的交的大小大于等于一个阈值t的情况.给定一个集合Q,如何才能找到和Q相交大于等于t的集合呢?传统的做法是:先找到一组候选集C,即满足Q和C中任意元素Ci的交大于等于1;然后在候选集中进行校验(Verification),即计算Q和Ci的交的大小并和阈值t进行比较.第一步可以使用倒排索引(InvertedIndex)快速地获得候选集,即C={I(w)|w∈Q},I(w)是元素w对应的倒排列表(InvertedListorPostingsList).该方法在实际数据集上的主要缺点是当Q中有一个元素出现的频率较高时,候选集会变得很大;恰恰在实际数据集上,元素的出现通常会遵循Zipf定律,所以有相当高的概率,Q中会有一个高频的元素.最早意识到该问题并提出解决方案的是文献[14].该论文提出了仅使用Q中最少出现的|Q|-t+1个元素的倒排列表来获得候选集.之后,文献[15]将这个想法进一步推广到数据,即所有数据集合|S|也只要索引其|S|-t+1个元素.为了达到这一点,其附加的要求是所有集合的元素要按照同一个全局的顺序排序,并且我们仅考虑前|S|-t+1个元素.为了方便起见,我们把按照某种全局顺序排列过的集合的前L个元素叫做这个集合的L-前缀.我们可以定义以下的前缀过滤定理.定义1(前缀过滤).两个集合A和B的交的大小大于等于t的必要条件是集合A的(|A|-t+1)-前缀和集合B的(|B|-t+1)-前缀的交大于等于1.前缀过滤应用到相似度自连接时,可以通过对需要连接的关系进行排序,从而得到更紧的过滤条件[16].这是因为我们可以限制每个查询的集合Q仅和比它小的集合进行比较.以Jaccard为例,我们可以对Q取(|S|-t×|S|+1)-前缀,而对数据集中的每个集合S取它们的(|S|-2t×|S|/(1+t)+1)-前缀.其它的对前缀过滤的改进包括:(1)有权重的情况.以上的前缀过滤规则可以扩展到元素有权重的情况[15].(2)延长前缀的长度.在标准的前缀上在加入k个元素,与此同时要求候选集中的对象在延长的前缀中有k+1个相同的元素.这个方法可以有效地降低最终候选集的大小,但是因为前缀的增长,会要求读取更多的倒排列表,并必须考虑更多的对象是否会进入候选集.其实际效果如何,很有可能非常依赖于数据集及程序的实现.(3)对倒排索引中无效的部分的处理[17].当一个集合(A)的前缀中的元素被索引后,它将一直留在索引里,并且以后任何一个前缀中包含该元素的字符串(B)都会把该记录(A)加入它的候选集,即使A和B的长度已经不符合大小过滤的条件.因为在相似度连接时,我们用来做为查询集合的大小是递增的,根据当前查询集合的大小,我们可以动态地将倒排列表的前端那些不符合大小过滤条件的项删除.(4)全局顺序的选择.影响候选集的大小的一个重要因素是出现在查询前缀中的元素的频度.为了减少候选集的大小,一种通用的启发式方法(heu-ristic)是选择将所有元素按照它们的IDF(InverseDocumentFrequency)降序排列[14-15].这样会导致全局最不常见的元素出现在前缀中,从而帮助减少候选集的大小.(5)在数据库系统中实现和应用前缀过滤.文献[16]考虑了在关系数据库上支持相似度查询的多种方法.(6)对倒排索引的改进.在海量数据的情况下,对数据集建立的索引也会很大.文献[18]考虑了不索引某些元素和将多个元素对应的倒排列表融合的方法,从而可以有效地减少索引的大小,使得我们更有可能在内存中装下索引.文献[19]则考虑了索引远远大于内存、必须读取硬盘的情况下,内存中和硬盘上索引的物理组织和对应的查询处理的问题.在文献中还存在几种不同的基于倒排索引来计算与查询集合交大于等于一个阈值的对象.我们将查询集合Q中每个元素对应的倒排列表Li来标识,Page4每个Li包含了一组有序的数据集合的ID.我们可以简单的把这些Li归并起来,同时保持对每个ID出现次数的计数,并返回计数值不小于阈值的ID(即文献[20]中的ScanCount算法).文献[21]研究了是否可以不需要将每个Li都读取完就可以完成计算的问题,并给出了基于Fagin的NRA算法的改进算法.文献[20]提出了另外几种优化的归并算法,包括考虑了通过利用相交的阈值和在倒排列表上的跳跃(Skipping)的方法达到仅仅读取一部分倒排列表的目的的MergeSkip算法以及将MergeSkip和前缀过滤的变种最优混合而得到的DivideSkip算法.3.2其它过滤的方法3.2.1大小过滤[2,15].如果两个集合比较相似,它们的大小也应该比较接近.对于仅仅是集合交的约束条件,大小过滤无法使用,因为即使两个集合很不相同,只要它们足够大,它们的交的大小也有可能会大于等于t.而大部分应用会避免以上情况的出现,从而选择使用某些方法归一化,例如除以集合的并的大小(Jaccard)或者两个集合大小的均值(Dice).以Jaccard为例,大小过滤条件为t×|A||B||A|/t;对于编辑距离,其条件为|A|-t|B||A|+t.3.2.2使用位置信息[22]我们注意到前缀过滤实质上是将集合变成了一个有序的序列.我们通过使用元素在该序列中的位置信息①,就可以进一步增强前缀过滤的效果,以进一步减少候选集的大小.给定一个元素e,一个有序的元素序列A可以被分成左部和右部(分别记作Al(e)和Ar(e))并且保证Al(e)中所有元素严格(在全局顺序中)小于e,Ar(e)中所有元素大于等于e.显然|A∩B|=|Al(e)∩Bl(e)|+|Ar(e)∩Br(e)|.而|Ar(e)∩Br(e)|min(|Ar(e)|,|Br(e)|).如果我们将e在A和B中的位置记作pos(A,e)和pos(B,e),我们可以得到以下的基于位置的过滤方法.定理3(位置过滤).两个集合A和B的交的大小大于等于t的必要条件是对于任意元素e,|Al(e)∩Bl(e)|+1+min(|A|-pos(A,e),|B|-pos(B,e))t.推论2.两个集合A和B的交的大小大于等于t的必要条件是对于它们(|A|-t+1)-前缀和(|B|-t+1)-前缀中最小的相交的元素efirst,1+min(|A|-pos(A,efirst),|B|-pos(B,efirst))t.证明.因为efirst是前缀中最小的相交的元素,所以|Al(efirst)∩Bl(efirst)|=0.然后从前缀过滤条件和位置过滤条件可推得.3.2.2后缀过滤[22]在阈值较高的情况下,前缀过滤十分快捷,这主要是因为只有集合的一小部分被索引和读取.例如:对Jaccard而言,索引和读取部分几乎是字符串长度的(1-t)倍.这同时意味我们考虑候选集时没有考虑字符串的(相当长的)后缀中可能出现的不匹配的元素.后缀过滤就是通过进一步利用后缀中元素的位置信息,来进一步过滤前缀过滤不能排除的候选对.其基本思想是选取一个有序集合的中位元素e,然后获得两个集合的关于e的左部和右部.可以证明对于符合Jaccard约束的两个集合的左部和右部的大小的差异也必定小于等于和t有关的一个函数的值.我们可以选择用递归的方式多次使用后缀过滤,以达到更好的过滤效果.4字符串的相似度查询4.1基于集合的字符串的相似度查询在这种查询中,我们将字符串先转化成集合,然后使用度量集合相似度的函数进行查询.这类方法的优点(同时也是缺点)是不考虑字符之间的顺序.以抄袭检测为例,这类方法可以有效地找出更换段落或者句子顺序的抄袭.受篇幅所限,我们仅考虑Jaccard相似度的情况.其它相似度函数的情况可以同理推出.我们首先需要将字符串转化为集合.常见的方法有每个元素是一个token,或者是一个q-gram.然后,两条字符串的相似度可以用它们对应的集合的Jaccard来衡量.所以我们之前讨论的对集合的相似度查询的处理方法可以直接使用.4.2基于字符串的相似度查询在这种查询中,我们考虑基于字符串的相似度,即我们考虑字符间的顺序.以抄袭检测为例,这类方法可以有效地找出仅有少量改动的大段抄袭.下面我们将已有的方法分类进行介绍.4.2.1基于q-gram的方法文献[2]给出了将字符串上的基于编辑距离的相似度连接转化成对应q-gram集合上的基于交的相似度连接.我们可以使用以下的优化:先使用前缀过滤(前缀的长度为t×q+1),在得到的候选集上再判别是否有足够多的共同的(也成为匹配的)q-gram①位置从1开始.另外,请注意这里讨论的位置不是该元素在Page5(也称作数量过滤(CountFiltering)),最后,在剩下的候选集中,对每条字符串计算其与查询字符串的编辑距离[1].由于将编辑距离的约束转化为基于不匹配的q-gram的过滤,已有的方法都是基于匹配的q-gram,那么,不匹配的q-gram是否可以被利用起来呢?文献[23]提出了两种基于不匹配的q-gram的过滤.第1种是通过考察在(t×q+1)-前缀中的q-gram的位置来进一步减少前缀的长度.我们假定取L-前缀(L<t×q+1).我们可以考察最少要多少个编辑操作才能将这L个元素全部破坏.很明显,如果这L个元素互相没有重叠,那答案就是l.可以证明如果有重叠的话,通过排序后的一个线性的贪心算法就可以等到答案.如果该结果大于编辑距离的阈值t,我们就可以只使用这L个元素作为前缀.通过两分查找,我们能够找到最小的L-前缀满足至少需要t+1个编辑操作才能将它们都破坏掉;我们把这样的前缀叫做最短前缀,它的取值范围在[t+1,t×q+1]之间.第2种利用不匹配的q-gram的过滤方法是基于以下的观察:如果有一系列相邻的不匹配的q-gram,那么这一区间内很有可能有较多的编辑操作.我们可以通过对区间内子串建立字符集大小的向量,并测试对应向量的1距离是否大于2t.4.2.2基于变长的子串的方法文献[24]提出了Winnowing的特征值提取的方法,相比以前的类似的方法(例如:文献[25-26]),这个新方法具有“局部”的特性,粗略地说,即特征的提取只决定于其周围局部范围内子串的内容.对于用户给定的长度参数L,通过调整参数,Winnowing可以保证检测到两条字符串中有所有长度大于等于L的相同的子串(因为它们会产生相同的特征值).利用这个特性,通过使用将字符串分治的方法,我们可以用Winnowing来支持编辑距离的相似度查询①.另一种产生变长的子串的方法是VGRAM[28-29].传统的q-gram方法的一个问题在于它要求索引所有长度为q的子串;由于子串的频率往往是不均匀分布的,这样会导致某些子串对应的倒排列表很长,从而导致算法需要付出不少的读取倒排列表的时间,并且候选集会较大.VGRAM方法放宽了对gram长度的限制,它会选取长度在qmin,qmax之间的“优质”的vgram,粗略来说,即对应的倒排列表较短的vgram.文献[28]提出了几种选取优质的vgram的方法,文献[29]则提出了使用动态编程的方法计算出两条相似的字符串需要共享的vgram个数的一个较紧的下界.还有一种方法是vchunk[27].其基本思想是将字符串分割成不重叠的子串(称作vchunk).并非所有的分割方法都可以考虑.这是因为在编辑过程中因为插入和删除,可能会出现非常相似的字符串分割后的vchunk没有相同的情况②.文献[27]提出了根据尾部受限模式字典(Tail-restrictedDictionary)分割的办法,可以保证每个编辑操作只会影响至多2个vchunk.在使用了前缀过滤,不匹配的vchunk的过滤和其它针对vchunk的过滤优化之后,我们只需要索引和读取l-前缀即可(l∈[t+1,2t+1]).4.2.3基于枚举的方法[30]一种最简单的支持编辑距离的方法是枚举所有和查询字符串的编辑距离小于等于t的所有字符串.我们仅需要对数据库中的字符串建立Hash索引.这个方法的最大问题是我们需要枚举O(|Q|t|∑|t)次.FastSS[31]提出t-删除邻居集(t-DeletionNeigh-borhood)的概念:即所有删除不超过t个字符所得到的字符串的集合.两个字符串的编辑距离不超过t的必要条件是它们的t-删除邻居集有共同的元素.这个方法的查询运行时间为O(|Q|t),即和字符集大小无关.FastSS在字符串短和t极小时是十分快捷的(尤其是t=1时,是线性的).但是随着t的增加,其时间和空间复杂度都以指数级上升.文献[32]通过适当的分治的方法,将数据库中的字符串和查询字符串都分片,并保证所有分片中至少有一份的编辑距离不能超过1.由于查询字符串和数据字符串长度可能不一样,查询字符串的每个分片还需要先在一定范围内作移动和伸缩,然后再生成1-删除邻居集.使用t-删除邻居集的主要原因是为了避免考虑所有可能的替换操作.让我们先考虑一个极其简单的特殊情况,即:(1)我们不允许插入和删除操作(即所有字符串长度都是l);(2)字符集的大小是2(即0和1).这时问题其实变成了在二值向量集合上的基于Hamming距离的相似度连接,每个编辑操作就是将某一位置的值取反,阈值仍然为t.这时,我们仍然需要枚举C(|Q|,t)=O(|Q|t)个被编辑过的位置的组合.很明显,如果我们可以减小l的话就可以降低代价.我们可以将向量划分成k段(k>t),至少有k-t段没有被编辑过.我们可以枚举所有C(k,t)个①②Page6编辑过的段,在每种情况下,使用没有被编辑过的段的位置和内容作为查询条件找到数据库中匹配的字符串,这些字符串的并构成了候选集.在候选集上进行校验就可以获得最后的结果.这种方法产生的候选集依赖于参数k:k越小,枚举的情况就越少,但是对应的精确匹配的条件就越松.文献[33]讨论了在海量64位二值向量上为了支持t=3的基于Ham-ming距离的查询的几种参数设定的方法.这个思路也被应用在文献[7]中.由于文献[7]处理的问题是在一条很长的字符串上做基于编辑距离的近似子串匹配,以上方法实质上是索引了C(k-1,t)种不同形状的带间隔的子序列.以上方法还有另一种变种.我们可以再多使用一层划分.根据抽屉原理,如果我们先将向量划分成n1段,则至少存在一段,在这段上的编辑操作至多是t1=t/n1.然后,我们在每一段上再使用划分+枚举的方法[33].这就是PartEnum算法[34].该算法的优点在于由于t1的向下取整运算,阈值实际上被降低了.该算法需要手工调节两个划分的参数,在实际中,仅当t较小时,通过手工调参能够取得比较优秀的结果.最后,我们给出从基于编辑距离的连接转换成基于海明距离的连接的方法.我们将所有数据字符串转成它们对应的q-gram的集合.如果在同一条字符串中有多个相同的q-gram(例如ab),我们把它们出现的顺序作为它们的下标(例如ab1,ab2等),从而认为它们是不同的元素[15].把每个出现过的(带下标的)q-gram作为一个维度,那么每个q-gram集合就可以转化成一个二值向量.定理4.两个字符串的编辑距离不超过阈值t的必要条件是它们对应的q-gram集合对应的二值向量的Hamming距离不超过q×t[34].最近,文献[7]提出了位操作来快速判断两条二进制的字符串的编辑距离是否小于等于1.为了支持编辑距离小于等于t的情况,文献[7]枚举所有不同的t个编辑操作的排列(permutation);在依次对一条二进制字符串使用某个编辑操作的排列时,一旦中间结果和另一条字符串相等①,则可以判断它们的编辑距离小于等于t.4.2.4一个统一的基于特征的方法[30]以上所有方法都可以归结到以下的算法框架中:我们(1)为数据字符串生成λt个特征值(并把它们加入索引);(2)为查询字符串生成Λt个特征值;(3)候选集是那些和查询字符串共享至少LBt个特征值的数据字符串.我们可以用Υ(λt,Λt,LBt)来描述一个方法.例如,传统的基于q-gram的方法[2]使用的特征值是q-gram,可以记作Υ(|S|-q+1,|Q|-q+1,max(|S|,|Q|)-q+1-q×t).而使用了前缀过滤后的基于q-gram的方法[23],可以记作Υ(q×t+1,q×t+1,1).文献[30]中给出了对更多方法的刻画.这个框架简洁地刻画出不同方法的空间和时间的复杂度,并且这些复杂度随阈值t的变化趋势.另外,如果我们把完全相同的匹配查询看作是基于编辑距离相似度查询的一个特例,即t=0,那么,基于Hash表的查询方法可以看作使用整个字符串作为一个特征值,可以记作Υ(1,1,1).一个自然的问题就是数据或者查询字符串最少要生成多少个特征值.文献[30]证明了最少需要t+1个特征值,并给出了两个算法,分别在数据和查询字符串使用t+1的特征值.其主要思想是在一条字符串上提取所有的q-chunk(不足时补特殊字符),即相邻的,不相交的长度为q的子串,而在另一条字符串上取所有的q-gram.可以证明每个编辑操作最多破坏一个q-chunk.结合前缀过滤,我们可以获得Υ(t+1,|Q|-((|Q|-t)/q-t)+1,1)的IndexChunk算法或者Υ(|S|-((|S|-t)/q-t)+1,t+1,1)的IndexGram算法.这两个算法不仅在绝大多数情况下比已有的方法更快,而且展现的不同的时间和空间的特性.例如:IndexGram算法仅仅需要读取t+1条倒排列表,所以其查询速度非常快,但这也要求所有的q-gram需要被索引,导致索引的大小会较大.4.2.5基于Trie[35-36]和树[37]的方法Trie是一种有效的存储多条字符串的数据结构,它支持快速的查找,并且通过在字符串之间共享前缀来节省空间.因为前缀共享,Trie可以很好地支持基于编辑距离的查询:当计算查询字符串和两条共享长度为L的前缀的字符串的编辑距离时,它们的编辑距离矩阵的前L列是相同的[38].文献[36]利用Trie来支持增量相似度查询,文献[35]利用Trie来进行相似度连接.由于以上的特性,Trie适合用于数据集的字符串较短的情况.Bed-Tree是一个基于B+树的管理外存中字符串集并支持多种基于(归一化)编辑距离的查询(范围查询,top-k查询,和连接)[37].其关键步骤是选取一种将字符串排列的顺序,使得给定任何一段连续的字符串区间,都可以快速地得到这个区间内字符①可以使用异或操作(XOR)快速地判断.Page7串和查询字符串的编辑距离的下界.5相关工作更多的相关工作的介绍可以参见近期的辅导报告和综述[39-45].5.1早期的相似度查询的相关工作早期的相似度连接的工作主要集中在对象为欧几里得空间(EuclideanSpace)中的点,而且使用的是2的距离函数,这个问题通常被称作空间连接(SpatialJoin).在低维空间的工作主要有循环、平面扫描(PlaneSweeping)、空间填充曲线(SpaceFill-ingCurve)、基于一颗或两颗R-tree以及分治的方法.具体的介绍和比较可以参见近期的一个综述[46].最近,文献[47]考虑了利用GPU的高并行性和计算速度来实现快速的空间连接.当空间中的维数较高时,空间连接是一个很难的问题.一方面是因为维度灾难(CurseofDimensionality),另一方面是因为高维空间中没有性能优异的索引.现有的方法主要基于空间的划分.例如,文献[48-50].还有一些工作是在度量空间(MetricSpace)中进行相似度连接.例如,使用度量空间的索引[51-52]或者使用分治的策略[53].在集合和字符串上的常见的相似度和距离函数往往不能有效地映射到欧几里德空间或者度量空间上,因此它们的相似度查询需要新的方法.早期的工作主要考虑简单的二值的相似度函数,例如相交不为空以及包含.文献[8]考虑RR.aS.bS提出了使用对集合的特征值进行过滤的Hash连接算法.文献[54]提出了另一种基于Hash和复制的连接算法.文献[55]提出了使用倒排索引来支持相交不为空,或者包含约束的连接.5.2近似的相似度查询的方法在文献中,有大量为相似度查询提供近似解的方法.其中最有代表性的是位置敏感Hash(LocalitySensitiveHash,LSH)[56].给定一个相似度函数,这类方法为每个对象(集合或者字符串)生成为一组特征值,我们仅需对有相通特征值的对象进行验证.通过调节将几个LSH的特征值拼接在一起作为索引和查询的基本单位,可以达到加快查询速度的目的;通过调节将以上步骤重复的次数,可以保证最后达到一个用户制定的召回率的阈值[16,57].hash[58]及其改进b-bitmin-hashing[59].(1)对Jaccard来说,基本的LSH方法是min-(2)对Cosine来说①,基本的LSH方法是sim-hash[33].(3)对Hamming来说,基本的LSH方法是对其它相似度或距离函数有效的LSH函数可randomprojection.以参见文献[60].5.3其它的问题定义实体识别(NamedEntityRecognition,NER)是另一个重要的应用:有一组字符串组成的字典,每个字符串是一个实体的名字.对于每一个输入的文件,我们需要找到所有近似匹配字典中某个实体的子串.实体识别往往是其它步骤和应用(例如文本检索和文本数据挖掘)的基础.文献[5,61]考虑了Jac-card约束下的实体识别,文献[32,62]考虑了编辑距离约束下的实体识别.文献[7]考虑的问题可以看作字典中仅有一项长度固定的实体的情况.Top-k相似度查询[63].在某些应用中,我们可能无法预先设定相似度函数的阈值.除了盲目地尝试不同的阈值以外,我们可以使用top-k相似度查询,即返回最相似的k对结果.文献[63]支持基于Jaccard的top-k查询,它使用了事件驱动的模型,动态地调整相似度的阈值,并且提出了防止重复校验的候选结果、简短倒排索引以及更紧的上界估计的技术.文献[37]提出的Bed-tree可以有效地支持基于编辑距离的top-k查询.Map-Reduce上的相似度查询[64-66].以上的快速的相似度查询算法因为假设所有索引和数据都在内存中,当数据量增长到很大的数量级时,这会使得它们不能在单机上运行.鉴于基于Map-Reduce的分布式计算在其它海量数据计算中的成功,我们可以使用Map-Reduce的框架来支持大数据量的相似度查询.早期的工作[66]关注的是计算所有对象对之间的相似度(即没有阈值的限制).文献[64-65]都研究了有阈值的情况,并将单机版的一些过滤条件延伸到Map-Reduce框架上.6未来的工作随着数据(尤其是互联网上和社会网路上的数据)的快速增长,越来越多的应用会涉及到集合和字符串的相似度查询.我们下面列出在这个领域内3个重要的未来工作的方向.6.1相似度查询的理论基础一方面,绝大多数现有的方法是基于一种或者①精确的说是arccos.Page8多种启发性的方法.我们对这些方法的代价、适用情况以及相互之间的关系还不甚了解.例如,前缀过滤在大量的、来自于不同领域的数据集上都取得了很好的效果.但是,如果许多低频的元素的出现频率仍然较高,或者相似度阈值过小或距离阈值过大时,它的过滤效果会迅速下降.如果没有一个理论上的分析,我们就无法预测何时这种过滤有效,也会阻碍我们寻找在前缀过滤失效的情况下,仍然有效的过滤方法①.现在,已经有不少工作集中在估计各种相似度查询的结果的大小或选择度(Selectivity)的问题上,包括文献[67-71].6.2相似度查询的方法的创新和改进过去的研究工作将对于集合和字符串的相似度连接的效率提高了几个数量级.另外,不同的方法往往在某些参数范围内有良好的表现(可以参见文献[30]的试验结果).与此同时,数据量的增长和应用对时间及空间的不断严苛的要求都会促使我们继续寻找新的方法或者对已有方法进行改进.例如,文献[30]提出了使用不对称的特征值以降低索引大小或者查询时间的方法.我们可以研究这种思路是否可以进一步完善、调整,或应用到不同的相似度查询中.文献[35-36]使用Trie来存储字符串和共享中间计算结果,或者利用它来有效地支持增量式的查询.但是Trie本身有一些弱点,例如:其占用空间较大,对较长的或没有许多前缀共享的字符串集合效果就比较差.所以我们可以探究是否可以通过分块或者改进的Trie来进一步提高现有的方法的效率和适用范围.6.3支持新的相似度查询和应用一方面,大多数现有的工作集中在常见的比较简单的相似度和距离函数上.在不同的引用中,我们可能会面临更多的更复杂的函数.最近的一些工作已经开始研究新的函数,例如将编辑距离和Jaccard结合[72]、EarthMover’sDistance[73]、BregmanDi-vergence[74]等.另一方面,对于集合和字符串的相似度连接的工作中提出的许多方法和技巧,可以应用到其它问题和领域内.例如:文献[75]使用相似度连接来对数据聚类;将基于编辑距离的近似字符串匹配和空间数据结合以支持多种新的查询[76];在有噪音的字符串上的近似查询[77];将近似字符串匹配和在数据库上的关键字检索结合[78]等.7结束语相似度查询是一个基本问题,在多个不同的计算机领域都有应用.自2000年以来,学术界在对集合和字符串的相似度查询的问题上作了很多研究,并取得了许多进展.本文对该领域内的主要的有代表性的工作作了一个总结和整理,并且对未来的工作作了展望.
