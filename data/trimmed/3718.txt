Page1基于不完备数据聚类的缺失数据填补方法武森1)冯小东1)单志广2)1)(北京科技大学东凌经济管理学院管理科学与工程系北京100083)2)(国家信息中心信息化研究部北京100045)摘要缺失数据的处理是数据挖掘领域进行数据预处理的一个重要问题.传统的缺失数据填补方法大部分是基于概率分布等一些统计假设,对于大数据集的数据挖掘不一定是最适合的方法.受不完备数据分析(ROUSTIDA)未采用传统的概率统计学方法启发,提出基于不完备数据聚类的缺失数据填补方法(MIBOI),针对分类变量不完备数据集定义约束容差集合差异度,直接计算不完备数据对象集合内所有对象的总体相异程度,以不完备数据聚类的结果为基础进行缺失数据的填补.采用UCI机器学习基准数据集进行实验表明,MIBOI对缺失数据的填补是有效可行的.关键词数据填补;不完备数据;聚类;约束容差集合差异度1引言作为机器学习领域基准数据库的UCI数据集中超过40%的数据库都含有缺失数据[1].这可能是由于数据获取限制,数据理解有误或数据漏读[2]等多方在实际数据分析中,经常遇到数据缺失问题.面原因造成的,使得在数据挖掘中面临的数据集往Page2往是不完整的.对这种有缺失数据的数据集,在此称为不完备的数据集.实际上,缺失数据是知识工程领域一个重要的热议问题[3].在数据挖掘中缺失数据经常处理不当,与缺失数据相关的有价值的知识往往被忽略了[4].本文针对缺失数据问题展开研究,提出基于不完备数据聚类的缺失数据填补方法MI-BOI(MissingdataImputationapproachBasedOnIncompletedataclustering).该方法通过定义约束容差集合差异度,从集合的角度判断不完备数据对象的总体相异程度,进而以不完备数据聚类的结果为基础实现缺失数据的填补.采用UCI机器学习数据集中4个常用的分类变量基准数据集进行实验,结果表明:MIBOI效率很高,且缺失数据填补的质量也比较高.本文第2节总结缺失数据填补的相关工作;第3节定义基于不完备数据聚类进行缺失数据填补的基本概念;第4节提出并证明进行缺失数据填补的相关定理;第5节给出算法步骤;第6节用实验证明算法的有效性;第7节进行全文总结.2相关工作对于存在缺失数据的不完备系统,多采用如下几种方法进行处理:(1)丢弃具有缺失数据的记录;(2)进行缺失数据的填补;(3)采用模型对缺失数据进行预测;(4)直接针对不完备数据进行分析.这些方法之间并不是相互排斥的,不同的方法之间在具体的实现算法上可能存在着紧密的联系.丢弃具有缺失数据的记录[5-6]是应用中最简单的一种缺失数据处理方法.数据分析工作是在已经没有缺失数据的部分数据上完成的.这种方法在实际应用时也有不同的形式,例如在临床医学研究[7]中,具体又分为完全个体分析(completecaseanaly-sis)和可用个体分析(availablecaseanalysis).完全个体分析是将那些有缺失值的记录全部排除,只分析有完整数据的受试者,受试者如果有缺失值就要被排除在分析之外,会造成分析采用的实际样本量大大减少;可用个体分析是根据能够观察到的数据进行分析,只删掉那些需要用于分析的属性存在缺失数据的受试者,与完全个体分析相比可以更好地利用所有可用的信息,样本量会随着用于分析的属性不同而变化.总体而言,丢弃具有缺失数据的记录不能充分利用数据资源,而且可能会严重影响到数据的客观性和所研究问题结论的正确性.对缺失数据进行填补,是为了在填补后的数据上完成具体问题的数据分析.简单而又常见的填补方法是全局常量填补法(globalconstant)和属性均值填补法(attributemean)[6].文献[8]研究指出:在大多数情况下,这些方法同丢弃具有缺失数据的记录一样会生成有偏的结果,但有一些更复杂的填补方法,例如多重填补(multipleimputation),对缺失数据的处理更有效.多重填补不同于每一个缺失项填补一个值的单一填补(singleimputation),其通过填补多个值以对填补的不确定性做出评价.热平台填补(hotdeckimputation)[5]和冷平台填补(colddeckimputation)[5]都是典型的单一填补方法.热平台填补是将缺失值填补为与它最相似的一个对象的值.相似判定最常见的是使用相关系数矩阵来确定与缺失值所在属性最相关的属性,然后将所有对象按最相关属性值大小进行排序,将缺失值填补为排在它前面的对象值.与均值填补法相比,热平台填补后,变量的标准差与填补前比较接近,但这种方法使用不便,比较耗时.冷平台填补与热平台填补类似,不同之处在于填补值来自于其它数据源而不能是当前数据源.这些单一填补方法系统地低估了方差,而多重填补[9-10]是对单一填补的改进,它采用一系列可能的值来填补每一个缺失值,然后用标准的统计分析过程对多次填补后产生的若干个数据集进行分析,并将分析结果进行综合得到总体参数的估计值.多重填补反映了因缺失数据而导致的不确定性,统计推断更加有效.采用模型对缺失数据进行预测的方法首先对输入的数据定义一个模型,然后基于该模型对未知参数进行极大似然(maximumlikelihood)估计.期望值最大化(expectationmaximization)算法[5]是缺失数据分析中用于极大似然估计的很常用的迭代算法.期望值最大化算法在某些情况下,当数据缺失比例很大时收敛可能很慢,各种改进算法或替代算法[11-12]相继提出.直接针对不完备数据进行分析的方法,既不删除具有缺失数据的记录,也不进行缺失数据的填补.这种处理方法比较多地用在机器学习领域的分类问题研究中.这种不完备数据分析方法的一个重要特征是以提高分类性能为目标,旨在提高分类结果的精确性.例如,近年来直接扩充粗糙集[13-15]或决策树[16]模型来进行不完备信息系统研究取得了许多成果,这些成果主要是针对具有决策属性的决策表问题展开的,其实质是分类问题.Page3由于许多数据分析算法或具体应用问题要求输入的数据必须是完备的,所以直接针对不完备数据进行分析的方法就受到了限制.而其它方法大部分都是概率统计学方法,往往基于概率分布等一些统计假设,由于在数据挖掘领域数据集通常非常巨大,对这些分布假设的判定比较困难,因此这些传统的统计技术对数据挖掘应用中的缺失数据处理不一定是最适合的方法[17].另外,许多缺失数据填补方法都是针对连续变量提出的.尽管分类数据缺失无处不在,但是并没有处理分类变量缺失数据可用的原则性方法.当分类变量数目很大时,当前的缺失分类数据填补统计方法由于稳健性及实施困难等原因在应用中就受到了限制[10].ROUSTIDA不完备数据分析[17-18]未采用传统的概率统计学方法,而是在对粗糙集理论进行研究的基础上提出的.它是针对分类变量缺失数据进行填补质量和效率都比较好的一种方法.其基本思想是:缺失数据的填补应使填补后的数据集中具有缺失数据的对象与其它相似对象的属性值尽可能保持一致,亦即属性值之间的差异尽可能小.由于粗糙集理论中的差异矩阵反映了对象间的属性值差异,所以ROUSTIDA通过扩充差异矩阵来适合不完备数据集,进而实现缺失数据的填补.受ROUSTIDA不完备数据分析方法启发,本文提出的MIBOI不完备数据填补方法也未采用传统的概率统计学方法,而是基于不完备数据聚类提出的.通过针对分类变量不完备数据集定义约束容差集合差异度,从集合的角度判断不完备数据对象的总体相异程度,进而以不完备数据聚类的结果为基础进行缺失数据的填补.3基本概念3.1不完备信息系统定义1(不完备信息系统).不完备信息系统定义为犐=(U,A,V,f),其中,对象集合U={x1,x2,…,xn};对象属性集合A={a1,a2,…,am};V是属性值的集合,V=∪V(ak),V(ak)是属性ak的值域;f是U×A→V的映射函数,它为每个对象的每个属性赋予一个属性值,第i个对象的第k个属性值ak(xi)∈V(ak),i∈{1,2,…,n},k∈{1,2,…,m},ak(xi)=“”表示属性值缺失.3.2容差属性定义2(容差属性).给定不完备信息系统犐=(U,A,V,f),对于非空对象集合XU,定义为集合X的容差属性集合,称ak∈T(X)为容差属性.从上述定义可知,对于非空对象集合X,其容差属性集合由满足下述条件的所有属性构成:X中的任意两个对象在该属性的值没有明确不同的情况,即X中的任意两个对象在该属性的值相同或至少一个对象在该属性的值缺失.如果X的容差属性集合T(X)≠,对于容差属性ak∈T(X),记ak(X)=为容差属性ak的容差值.相应地,记V(X)={(k,ak(X))ak∈T(X)}(3)为容差属性集合T(X)对应的(属性序号,容差值)二元组集合,简称为容差属性二元组集合.3.3约束容差属性定义3(约束容差属性).给定不完备信息系统犐=(U,A,V,f),对于非空对象集合XU,V(X)为集合X的容差属性二元组集合,定义S(X)=为集合X的约束容差属性二元组集合,称ak为约束容差属性.从上述定义可知,对于非空对象集合X,其约束容差属性集合中的属性都是容差属性,且受到这些容差属性中至少有一个属性的容差值不为“”的约束.约束容差属性集合比容差属性集合更加严格.如果X的约束容差属性二元组集合S(X)=,则包括如下两种情况:(1)X中没有容差属性.(2)X中有容差属性,但所有容差值都为“”.3.4约束容差集合差异度定义4(约束容差集合差异度).给定不完备信息系统犐=(U,A,V,f),对于非空集合XU,|X|为X的基数,m为属性数目,如果X的约束容差属性二元组集合S(X)≠,则定义Page4D(X)=m-S(X)且为集合X的约束容差集合差异度.约束容差集合差异度D(X)反映了存在缺失数据的情况下集合X内各对象间的总体差异程度.D(X)越小,表明X集合内各对象间总体差异程度越小,各对象间越相似;D(X)越大,表明X集合内各对象间总体差异程度越大,各对象间越不相似.如果X的约束容差属性集合S(X)=,则约束容差集合差异度为未定义,这体现在如下两种情况:(1)X中没有容差属性,即对于任意属性在X中都存在至少两个对象在该属性的值明确不同,则X内各对象间的总体差异程度很大,不再进行定义.(2)X中有容差属性,但所有容差值都为“”,此时对X内所有对象没有一个属性取值明确相同,更重要的是所有容差值都为“”对缺失数据的填补没有意义,所以不再进行定义.3.5约束容差集合精简定义5(约束容差集合精简).给定不完备信息系统犐=(U,A,V,f),对于非空集合XU,|X|为X的基数,X的约束容差属性二元组集合S(X)≠,D(X)为约束容差集合差异度,则定义向量为集合X的约束容差集合精简.根据上述定义,约束容差集合精简是一个向量,其包含3个分量:|X|,S(X)和D(X).根据式(5)在计算约束容差集合差异度D(X)时需要用到m,|X|和|S(X)|.由于属性数目m为已知常数,|X|和S(X)是包含在约束容差集合精简中的前两个分量,所以D(X)可以根据已知常数m及前两个分量|X|和S(X)直接计算得到.这样,约束容差集合精简犚(X)=(|X|,S(X),D(X))不仅包含了约束容差集合差异度D(X),表明了存在缺失数据的情况下集合X内各对象间的总体差异程度,同时也通过前两个分量|X|和S(X)概括了计算约束容差集合差异度所需的全部对象信息.本文提出的MIBOI方法在计算过程中只保留约束容差集合精简,而不保留所有对象的信息,从而在处理大数据集时数据处理量大规模减少.约束容差集合精简是针对集合提出的,不受集合中包含对象数目的限制.如果X中只包含一个对象,不妨记X={x},则约束容差集合精简R(X)包含了对象x的全部相关信息,如式(7)所示犚(X)=犚({x})=(1,{(1,a1(x)),(2,a2(x)),…,(m,am(x))},0)3.6约束容差交运算定义6(约束容差交运算).给定不完备信息系统犐=(U,A,V,f),非空集合XU的约束容差属性二元组集合记为S(X),对于X1U和X2U且X1∩X2=,如果S(X1)≠且S(X2)≠,对于(k,ak(X1))∈S(X1)和(k,ak(X2))∈S(X2)且ak(X1)=ak(X2)∨ak(X1)=“”∨ak(X2)=“”,记max(ak(X1),ak(X2))=ak(X1),ak(X1)≠“”∧ak(X2)=“”烄ak(X2),ak(X1)=“”∧ak(X2)≠“”ak(X1)或ak(X2),ak(X1)=ak(X2)∧烅烆则定义S(X1)∩TS(X2)={(k,max(ak(X1),ak(X2)))(k,ak(X1))∈S(X1)∧(k,ak(X2))∈S(X2)∧(ak(X1)=ak(X2)∨ak(X1)=“”∨ak(X2)=“”)}为约束容差属性二元组集合S(X1)和S(X2)的容差交运算,并进一步定义为约束容差属性二元组集合S(X1)和S(X2)的约束容差交运算.从上述定义可知,对于非空约束容差属性二元组集合S(X1)和S(X2),其容差交运算的结果由S(X1)和S(X2)中容差值不是明确不同的所有属性组成,即由S(X1)和S(X2)中容差值相同或至少一个为“”的所有属性组成.而约束容差交运算与容差交运算相比,增加了运算结果中至少有一个属性的容差值不为“”的约束,比容差交运算更加严格.Page54相关定理4.1约束容差交运算定理命题1(约束容差交运算定理).给定不完备信息系统犐=(U,A,V,f),非空集合XU的约束容差属性二元组集合为S(X),对于X1U和X2U且X1∩X2=,如果S(X1)≠且S(X2)≠,则证明.因为S(X1)≠且S(X2)≠,则根据式(4)有S(X1)=V(X1)且S(X2)=V(X2),再根据容差属性二元组集合相关定义式(1)~(3)及容差交运算相关定义式(8),(9)可得V(X1∪X2)={(k,ak(X1∪X2))xi∈X1∪X2,xj∈X1∪X2ak(xi)=ak(xj)∨ak(xi)=“”∨ak(xj)=“”}={(k,max(ak(X1),ak(X2)))(k,ak(X1))∈V(X1)∧(k,ak(X2))∈V(X2)∧(ak(X1)=ak(X2)∨ak(X1)=“”∨ak(X2)=“”)}={(k,max(ak(X1),ak(X2)))(k,ak(X1))∈S(X1)∧(k,ak(X2))∈S(X2)∧(ak(X1)=ak(X2)∨ak(X1)=“”∨ak(X2)=“”)}=S(X1)∩TS(X2).进一步根据约束容差属性二元组集合定义式(4)及约束容差交运算定义式(10)可得4.2约束容差集合精简计算定理命题2(约束容差集合精简计算定理).给定不完备信息系统犐=(U,A,V,f),非空集合XU的约束容差集合精简为犚(X)=(|X|,S(X),D(X)),对于X1U和X2U,X1∩X2=,S(X1)≠且S(X2)≠,如果S(X1)∩CS(X2)≠,则犚(X1∪X2)=(X1∪X2,S(X1∪X2),D(X1∪X2)),其中,X1∪X2=X1+X2烄S(X1∪X2)=S(X1)∩CS(X2)D(X1∪X2)=烅m-S(X1)∩CS(X2)烆证明.|Y1∪Y2|=|Y1|+|Y2|.(1)因为Y1X和Y2X且Y1∩Y2=,所以(2)根据命题1有S(X1∪X2)=S(X1)∩CS(X2).(3)D(X1∪X2)根据该定理,MIBOI算法在将两个不相交的对象集合归入一类时,可以直接精确地进行约束容差集合精简的计算.因此,约束容差集合精简在处理不完备数据集时不仅可以大规模降低数据处理量,同时可以保证约束容差集合差异度计算的精确性.4.3约束容差集合精简不变定理命题3(约束容差集合精简不变定理).给定不完备信息系统犐=(U,A,V,f),非空集合XU的约束容差集合精简为犚(X)=(|X|,S(X),D(X)),S(X)≠,对于(k,ak(X))∈S(X),xi∈X,令ak(xei)=ak(xi),ak(X)=“”∨ak(xi)≠“”缺失数据填补后的约束容差集合精简为则有证明.(1)因为式(13)进行的属性值变换不影响对象的数目,所以|Xe|=|X|.(2)对于式(13)的第1种情况,ak(xie)=ak(xi),属性值不变,所以S(Xe)不变.对于式(13)的第2种情况是在约束容差属性取值不为“”(ak(X)≠“”),即容差值为明确值时,将各对象在该属性为“”的值(ak(xi)=“”,即缺失值)用容差值替换,即ak(xie)=ak(X).根据容差值定义式(2),替换后的Xe中所有对象在该属性的取值都为原来的容差值ak(X),容差值不变,所以S(Xe)不变.综合两种情况,S(Xe)=S(X).(3)根据式(5)在计算约束容差集合差异度D(Xe)时需要用到m,|Xe|和|S(Xe)|.由于属性数目m为已知常数,|Xe|=|X|,S(Xe)=S(X),所以D(Xe)=D(X).综上所述,犚(Xe)=犚(X).Page6该定理是基于不完备数据聚类进行缺失数据填补的重要基础.根据该定理,对于约束容差属性,将缺失值用明确的容差值替换后,约束容差集合精简不变,约束容差集合差异度不变,所以缺失数据的填补能较好地保持原有不完备数据的聚类特征.5算法描述MIBOI算法基于不完备数据聚类对缺失数据进行填补.在聚类过程中,从采用第一个对象创建第一个类开始,通过一次扫描不完备数据对象完成全部新类的创建及对象到类的归并.对于已创建的类,仅保留约束容差集合精简,不保留全部对象的信息.是否创建新类取决于预先指定的约束容差集合差异度上限u.对于每一个被扫描到的对象,寻找使得并入后约束容差集合差异度最小的已创建类.如果该最小约束容差集合差异度不大于上限u,则并入该类;否则创建新类.在聚类完成后逐一对各个类进行缺失数据的填补.对于每个约束容差属性,如果其容差值不为“”,即容差值为明确值而不是空值时,将该类中各对象在该属性为“”的值(即缺失值)用该容差值替换,实现缺失数据的填补.由于不一定所有的属性都是约束容差属性,且约束容差属性的容差值也可能是空值,而MIBOI算法只对容差值不为空的约束容差属性进行缺失数据填补,所以算法不能保证缺失数据填补后的信息系统是完备的.MIBOI算法步骤如下所述.1.对不完备信息系统犐=(U,A,V,f),根据约束容差集合精简定义式(6),(7)得到由第一个对象创建的类X1={x1}的约束容差集合精简犚(X1)=(1,S(X1),0),类似地得到犚({x2})=(1,S({x2}),0);2.根据约束容差交运算式(8)~(10)计算S(X1)∩CS({x2}),如果S(X1)∩CS({x2})=,创建新类X2={x2},类的数目c=2,转入步4;3.根据约束容差集合精简计算定理,应用式(12)计算X1和{x2}合并后的约束容差集合精简犚(X1∪{x2})=(2,S(X1∪{x2}),D(X1∪{x2})),如果约束容差集合差异度D(X1∪{x2})u,将x2并入已创建类X1中,X1={x1,x2},类的数目c=1;否则,创建新类X2={x2},类的数目c=2;4.i=3;5.如果i>n,转到步8;否则,对于每一个已创建类Xt,t=1,2,…,c,根据约束容差交运算式(8)~(10)计算S(Xt)∩CS({xi}),如果S(Xt)∩CS({xi})=对t=1,2,…,c都成立,则创建新类Xc+1={xi},类的数目c=c+1,转入步7;6.对于t=1,2,…,c且S(Xt)∩CS({xi})≠,根据约束容差集合精简计算定理,应用式(12)计算Xt和{xi}合并后的约束容差集合精简犚(Xt∪{xi})=(|Xt|+1,S(Xt∪{xi}),D(Xt∪{xi})),寻找τ使得Xτ和{xi}合并后的约束容差集合差异度最小,即D(Xτ∪{xi})=min(t=1,2,…,c)∧S(Xt)∩CS({xi})≠D(Xt∪{xi}),如果约束容差集合差异度D(Xτ∪{xi})u,将xi并入已创建类Xτ中,Xτ=Xτ∪{xi},类的数目不变;否则,创建新类Xc+1={xi},类的数目c=c+1;7.i=i+1,转到步5;8.t=1;9.如果t>c,转到步11;否则,对于类Xt,如果S(Xt)≠,根据约束容差集合精简不变定理,应用式(13)的第2种情况对缺失数据进行填补,即对于(k,ak(Xt))∈S(Xt),xi∈Xt,如果ak(Xt)≠“”且ak(xi)=“”,则将ak(xi)的值填补为ak(Xt);10.t=t+1,转到步9;11.结束.从上述步骤可知MIBOI算法具有如下特点:(1)基于不完备数据的聚类结果对缺失数据进行填补.根据约束容差集合精简不变定理,在缺失数据填补后,各个类的约束容差集合精简保持不变.约束容差集合精简包含3个分量:集合的基数,约束容差属性二元组集合和约束容差集合差异度,这种不变性使缺失数据的填补能较好地保持原有不完备数据的聚类特征;(2)完成不完备数据聚类仅需扫描数据一次,在聚类过程中只需保留已创建各类的约束容差集合精简,而不必存储全部对象的所有信息,对数据进行了高度压缩,数据处理量显著降低,并且约束容差集合精简计算定理保证了在合并两个不相交的对象集合时约束容差集合精简可以直接进行精确的计算,保证了约束容差集合差异度计算的精确性,因此这种数据压缩不会降低不完备数据聚类的质量,从而保证了缺失数据填补的质量;(3)算法的主要计算时间在于不完备数据的聚类.由于在此过程中不必计算两两对象间的距离,扫描到的对象只需与已创建的各个类进行并入后约束容差集合精简的计算以确定扫描到的对象是并入已创建的某个类中还是创建一个新类,算法的计算时间复杂度为O(cmcn),其中c为类的数目,mc为平均约束容差属性数目,n为对象数目.在实际的数据挖掘应用中c和mc一般远小于n.6实验结果为了检验MIBOI算法进行缺失数据填补的效率和效果,从UCI机器学习数据集中选择4个常用的分类变量的基准数据集针对MIBOI算法和经典Page7的ROUSTIDA算法及属性均值填补算法进行对比实验.实验硬件环境为:Intel(R)Core(TM)2DuoCPUE7400@2.80GHz处理器,2.00GB内存;软件环境为:WindowsXP操作系统,MicrosoftVisualC++2008ExpressEdition编程语言.6.1数据集采用UCI数据集中著名的SmallSoybean、Zoo、SPECTHeart(train)、ImageSegmentation数据集进行MIBOI算法的有效性检验.SmallSoy-bean数据集中包含47个对象,共分为4类,每类对应一种大豆作物病害,描述对象的属性共有35个,各属性的取值都可以作为分类变量.Zoo数据集中包含101个对象,共分为7类,每类对应一种动物类型,描述对象的属性共有16个,其中15个为二态属性,值域为{0,1},还有1个为数值属性,描述动物腿的数目,值域为{0,2,4,5,6,8},可以视为分类变量.SPECTHeart(train)数据集中包含80个对象,共分为2类,将病人分为正常和不正常,描述对象的属性共有22个,都是对心脏单质子发射计算机层析成像(SingleProtonEmissionComputedTomography,SPECT)图像诊断数据处理后得到的二态属性,值域为{0,1}.ImageSegmentation数据集一共包含2310个对象,19个属性,共分为7类,描述7种户外图像的像素属性.本文从每个类中随机抽取了50个对象,共350个对象,值域为{0,1}二态属性的数据作为实验对象.为了充分检验MIBOI算法进行缺失数据填补的有效性,将完备的SmallSoybean、Zoo、SPECTHeart(train)、ImageSegmentation数据集分别从5%的缺失比率开始随机将数据置为“”,并按5%利用式(16)计算单独利用MIBOI和ROUSTI-DA针对不同数据集在不同缺失比率下的补齐率,结果如表2和图1所示.MIBOI的补齐率明显高于ROUSTIDA.表2补齐率随数据缺失比率的变化缺失比率/%585.323.2984.6357.8779.1329.1395.6577.541087.134.2186.2262.1182.7432.2296.9073.331586.897.6885.2865.1278.6336.2796.6672.692085.6314.4186.1265.0279.2840.8796.8368.822584.3026.0187.6265.5279.2045.2496.8966.393083.8327.7787.3856.2879.2848.6196.8562.033583.0952.8286.6850.2879.4950.9497.0852.804082.3560.9487.4737.9781.8649.8297.5742.414580.7672.1587.8028.5080.4147.1197.3530.505080.7973.6488.1220.3181.0141.5397.3519.845579.4574.9087.9713.9381.9533.7297.4511.386078.6968.4288.348.1582.2526.2397.557.286577.9059.9088.535.9283.0219.5697.614.967076.8554.4189.224.6783.0915.2597.564.18的缺失比率递增,直至缺失比率达到70%.针对每一个数据集的每一种数据缺失比率,分别采用MI-BOI算法、经典的ROUSTIDA算法、属性均值填补法(MEANS,用数值属性均值或分类属性众数来替代缺失数据)及其结合方法进行缺失数据的填补.每次实验中,对象随机排序,缺失数据随机生成,对100次随机实验结果进行对比.从补齐率、填补正确率、填补后聚类正确率、时间效率和参数分析5个方面评价缺失数据填补算法的性能.1SmallSoybean473542Zoo3SPECTHeart(train)802224ImageSegmentation3501976.2算法补齐率分析对不完备信息系统犐=(U,A,V,f),应用算法进行缺失数据填补,记对象个数为N,数据总量为M,缺失数据的比率为α,实验运行次数为n,时间消耗总计为T,正确填补数据总量为C,错误填补数据总量为F.补齐率CR(CompleteRate)为平均每次运行填补数据量占缺失数据总量的比率.平均每次运行填补数据量为平均每次运行正确填补数据量和平均每次运行错误填补数据量之和补齐率/%Page8图1补齐率随数据缺失比率的变化6.3算法填补正确率分析算法填补正确率(AccuracyRate)为平均每次运行正确填补数据量与缺失数据总量的比率,计算公式如下:对于采用MIBOI和ROUSTIDA两种算法得到的不完备信息系统,继续采用均值填补法进行填补,形成完备信息系统,再利用式(17)计算填补正确率.分别采用均值填补(MEANS)、先ROUSTIDA再均值填补(RA+MS)、先MIBOI再均值填补(MI+MS)及先ROUSTIDA再MIBOI和均值填补表3填补正确率随数据缺失比率的变化缺失比率/%RA+MI+MS574.0274.5186.0286.2465.3880.6385.7586.1577.9578.4187.3690.0968.8990.7998.2998.291075.2475.3085.7785.4868.2083.5485.8585.8078.1878.1881.4582.6871.6791.5197.1697.461575.2875.5386.1686.2368.2683.1884.5084.6577.0575.2379.0679.2665.3488.2095.6696.332073.9575.5983.8184.0269.3884.1583.4384.6877.4476.3679.5979.8967.4289.2995.7296.302573.8076.7983.4583.7668.5681.5182.2782.6876.1477.2377.8178.5567.1787.0593.6094.353073.5777.0082.6883.1868.8678.6881.1381.5875.5376.5977.5977.6867.4683.5793.7594.393573.1578.8780.7882.4267.8875.5879.5680.5675.5275.4276.7276.9867.4682.2292.7393.384073.4879.0480.1481.8468.8573.4878.2178.4775.1176.5177.6378.1768.2677.3991.4592.074573.7679.6479.0880.8768.3670.8476.9776.7975.0076.0176.4076.6567.5673.1691.3391.785073.4977.3877.0278.8867.5668.6875.0975.1875.0776.5778.1578.6168.3270.8090.1890.495572.5877.5875.9278.7667.7768.7372.9272.6775.8377.0978.5079.1267.4268.6988.2688.386073.0775.6175.0077.4267.4667.5971.1770.6475.5976.9577.1077.6467.6167.9086.6686.756573.3973.9373.7474.7167.6667.6769.3169.1373.6574.5174.8375.1168.0868.1584.4984.507073.2373.8772.3973.2467.4367.3167.4867.2973.1573.9475.1875.3367.5367.5482.7482.74(RA+MI+MS)共4种方法得到完备信息系统进行填补正确率比较.利用式(17)计算4种方法针对不同数据集在不同缺失比率下的填补正确率,结果如表3和图2所示.总体上看,4种方法填补正确率的高低顺序依次为:RA+MI+MS>MI+MS>RA+MS>MS.可以看出:为了得到完备信息系统,采用MI+MS方法在填补正确率指标上一般优于RA+MS方法及直接采用MEANS方法.而采用RA+MI+MS方法一般更优于MI+MS方法.SPECTHeart(train)MEANSRA+Page9图2填补正确率随数据缺失比率的变化6.4填补后聚类正确率分析补的质量,聚类正确率公式为利用填补后的聚类正确率从另一个角度分析填其中,N表示对象的总个数,bi表示正确聚类到第i类的对象数,k表示聚类个数.同上一小节,本节对MEANS、RA+MS、MI+MS及RA+MI+MS共4种方法进行填补后形成的完备信息系统,运用经典K-Modes[19]聚类算法比较分析其聚类正确率.表4填补后聚类正确率随数据缺失比率的变化缺失比率/%RA+MI+MS576.7276.8178.8178.7776.1478.0277.5278.3361.6062.6162.3062.3572.4977.2677.2777.571074.8174.8977.0677.7973.7176.2576.7078.0261.5562.9863.2563.3569.7774.8975.0976.091572.0972.8575.3675.0273.7676.0575.8876.9160.4561.6962.7564.3568.8671.0672.8672.362069.0669.9176.4975.3470.4974.5275.3275.7258.4559.6561.8563.0567.3469.0969.6370.742567.3270.7076.3875.8966.5673.8874.6575.3956.8557.7960.7561.9565.5767.8069.2670.343063.5769.5374.8976.7262.9570.7372.9374.3854.5055.4360.0060.5063.1164.8668.8369.093560.1571.1572.9475.6658.7268.0472.4572.3452.7553.6059.2559.8561.7363.1568.9570.484056.8567.7969.7772.7957.3762.8271.2370.2651.3252.1458.4558.8558.7161.2667.3468.214555.6470.2868.8771.8354.5157.3569.5069.8250.2550.9857.8458.4257.0958.2665.4666.665051.4766.2863.9868.9453.3653.7568.0667.4349.8550.3757.8158.2555.2156.4665.8766.795548.7461.1960.1766.6851.1251.4962.4061.6747.2547.5757.3557.2552.4353.6765.0665.426047.1357.3457.6064.1950.2850.5060.2259.5846.5146.6355.5655.5551.3751.6765.1565.376545.6047.7453.2356.2850.4750.4757.1556.0646.9547.0553.7054.0049.1850.2662.4862.507044.7045.9446.6450.2848.9448.9251.5951.4046.5546.6053.5053.6048.1248.3060.8261.22利用式(18)计算4种方法针对不同数据集在不同缺失比率下的填补后的聚类正确率,结果如表4和图3所示.总体上看,4种方法填补后聚类正确率的高低顺序依次为RA+MI+MS>MI+MS>RA+MS>MS.其中,在缺失比率较低(小于20%)的情况下,4种方法的聚类效果差距不明显.但随着缺失比率的增加,RA+MI+MS和MI+MS对于MEANS和RA+MS的优势增大,这种趋势针对后3个数据集的结果更明显.SPECTHeart(train)MEANSRA+Page10图3填补后聚类正确率随数据缺失比率的变化算法时间效率指标选用平均时间(Average6.5算法时间效率分析Time,AT):平均时间为平均每次运行时间消耗.上两节选择的4种方法的基础是ROUSTIDA、MIBOI和MEANS这3种算法.由于MEANS算法只是根据某个属性纵向计算众数填补,无复杂的数据迭代过程,因此处理时间与MIBOI和ROUSTI-DA相比很小,故不予考虑.通过ROUSTIDA和MIBOI两种算法的效率可以扩展计算上述4种方法的效率.缺失比率/%表5平均时间随数据缺失比率的变化50.01311310.01295560.01622540.09276720.01923290.07352260.06193210.5218761100.01177710.01763700.01666840.12084860.01716040.08435870.06169650.6440620150.00874030.02193600.01750310.14572460.01735480.08930620.06250650.7856314200.00931930.02430080.01673710.14565940.01618000.09245950.06597660.9251275250.00945500.03154060.01566880.15219540.01560490.11314940.06656311.0993335300.00932290.03658580.01648090.15337350.01574330.10232120.06322631.1785693350.00840110.04353610.01643760.15863610.01523950.12187580.06392401.2753069400.00878560.04628900.01559780.15891870.01693340.14145990.06556221.3288523450.00788380.04745450.01549160.16289870.01598570.14462860.05973931.3836006500.00806440.04876820.01525550.14498840.01676920.14432560.06279801.3164211550.00720380.05174910.01531240.14273520.01407060.14641810.06147511.1922182600.00645980.05488140.01330160.13429130.01453470.13306750.05951100.9574924650.00637970.05081050.01276990.14361600.01340010.12482970.05511500.8367161700.00597960.05373720.01287700.14579400.01334800.14157620.05242820.6286149利用式(19)计算MIBOI和ROUSTIDA针对不同数据集在不同缺失比率下的平均时间,结果如表5和图4所示.除了针对SmallSoybean数据集在缺失比率为5%的情况下,MIBOI的平均时间略高于ROUSTIDA以外,MIBOI的平均时间都明显低于ROUSTIDA.而针对SmallSoybean数据集在缺失比率为5%的情况下,MIBOI的平均时间略高于ROUSTIDA的原因,是在此情况下MIBOI的平均每次运行填补数据量远高于ROUSTIDA.因此,MIBOI的时间效率明显优越于ROUSTIDA,进而有MI+MS的时间效率优于RA+MS,RA+MI+MS时间效率与RA+MS差别不明显.平均时间/sPage11图4平均时间随数据缺失比率的变化6.6算法参数分析MIBOI算法有一个需要预先指定的参数,即约束容差集合差异度上限u.每次随机实验中,MIBOI算法的约束容差集合差异度上限u皆取使得缺失数据填补绝对正确率达到最高的最佳值.针对不同数据集在不同缺失比率下100次随机实验,u最佳值的平均值、标准差和标准差系数结果如表6、图5所示.从针对SmallSoybean、Zoo、表6狌最佳值的平均值和标准差系数随数据缺失比率的变化缺失比率/%50.11700.014912.740.08540.032037.470.20740.049824.01100.11510.015113.120.08450.025730.410.17480.036620.94150.11410.014812.970.07830.022028.100.16200.043026.54200.11130.017215.450.07660.023530.680.14820.030720.72250.11200.017715.800.07130.024233.940.12150.029424.20300.10830.020518.930.06970.020929.990.12390.026721.55350.10800.024222.410.06540.022233.950.10600.031729.91400.10130.021421.130.05280.022141.860.09380.029931.88450.10000.026326.300.05630.023040.850.08410.024228.78500.09890.026526.790.04630.024051.840.07420.028838.81550.09880.030630.970.03920.022056.120.06340.026742.11600.09580.031232.570.03800.022759.740.05140.027152.72650.09460.031433.190.02600.022486.150.03930.026667.68700.09240.029131.490.02270.020992.070.02840.022880.28SPECTHeart(train)这3个数据集(由于ImageSegmentation数据集同一个类内差异很小的对象较多,实验结果显示u最佳取值均为0,故本部分不讨论该数据集)的实验结果看:对于每100次随机实验,参数u最佳值的平均值都随着数据缺失比率的增加而降低.标准差随着数据缺失比率的增加没有统一的规律,3个数据集的标准差系数随着缺失比率的增加而增加.ZooPage12图5u最佳值的平均值和标准差系数随数据缺失比率的变化7结束语在数据挖掘实际应用中面临的往往是不完备数据集,对缺失数据的处理已成为数据预处理中一项非常重要的工作.针对分类变量缺失数据处理问题,本文未采用传统的概率统计学方法,而是基于不完备数据聚类提出一种缺失数据填补的新方法MI-BOI.该方法通过定义约束容差集合差异度,从集合的角度判断不完备数据对象的总体相异程度,进而根据不完备数据聚类的结果实现缺失数据的填补.为了检验所提出的MIBOI方法的有效性,采用UCI机器学习数据集中4个常用的基准数据集进行实验,分别从算法补齐率、填补正确率、填补后聚类正确率和时间效率4个方面将MIBOI与同样未采用传统概率统计学方法的经典不完备数据分析方法ROUSTIDA及采用统计学方法的MEANS方法之间的结合方法进行对比分析.结果表明,MIBOI从算法补齐率和时间效率两个方面总体优于经典ROUSTIDA方法,MIBOI与MEANS结合的MI+MS在填补正确率和填补后聚类正确率两方面优于ROUSTIDA与MEANS结合的RA+MS及MEANS单独填补方法,而先ROUSTIDA再MIBOI和均值填补(RA+MI+MS)具有最好的结果,并且在时间效率上没有明显的劣势.进一步的研究工作:MIBOI方法有一个需要预先指定的参数,即约束容差集合差异度上限u,缺失数据填补的结果受该参数u的影响.每次随机实验中,u都是经过尝试选取使得正确率达到最高的最佳值.总体而言,u最佳值的平均值随着数据缺失比率的增加而降低,标准差系数随着缺失比率的增加而增加.在实际应用中u最佳值的预先指定还是有一定困难的.如何高效合理地确定参数u或彻底地消除参数u的影响是需要继续研究的一个内容.
