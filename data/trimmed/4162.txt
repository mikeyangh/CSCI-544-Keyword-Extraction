Page1基于动态描述逻辑的语义Web服务组合常亮1),2)刘进1)古天龙2)史忠植3)1)(武汉大学软件工程国家重点实验室武汉430072)2)(桂林电子科技大学广西可信软件重点实验室广西桂林541004)3)(中国科学院计算技术研究所智能信息处理重点实验室北京100190)摘要应用合适的形式系统对语义Web服务建模是实现语义Web服务自动组合的前提;形式系统的表达能力和计算性能决定了语义Web服务组合的准确度和求解效率.动态描述逻辑DDL(X)将动态逻辑、描述逻辑以及构建在描述逻辑之上的动作理论有机地结合,为语义Web服务的建模提供了新的工具.提出了一种基于DDL(X)的语义Web服务自动组合方法.首先,在将OWL-S表示的语义Web服务建模为动作的基础上,将语义Web服务组合问题建模为基于DDL(X)的规划问题,其中规划问题的规划解可以由DDL(X)中的任一动作构成,从而可以支持OWL-S中不含有Split和Split+Join的各种Web服务组合方案.针对建模后得到的任一规划问题,给出了用来判断是否存在规划解的判定算法,证明了算法的可终止性、可靠性和完备性.最后,当规划解存在时,可以根据判定过程将其解析出来.文中的方法充分发挥了DDL(X)在表达能力和计算性能等方面的优势,为语义Web服务自动组合提供了一套有效的理论工具.关键词语义Web服务;服务组合;动态描述逻辑;动作理论;规划问题1引言Web服务基于Web技术进行服务发布、查找和访问,是实现面向服务计算的一种重要途径.Web服务的巨大潜力在于能够根据用户的不同需求对万维网上大量的服务进行灵活组合,然后再以服务的形式向用户提供满足需求的功能.随着万维网上Web服务数量的急剧增长,如何实现Web服务的自动组合成为了一个重要的研究课题.语义Web服务[1]将语义Web的思想和技术与Web服务结合起来,在Web服务描述中加入足够的语义信息,使Web服务成为计算机可以理解的实体,为Web服务的自动组合提供了必要的基础.目前已经形成了OWL-S、WSMO、SAWSDL等比较成熟的语义Web服务描述语言,从不同角度将语义信息引入到Web服务描述中.为了实现语义Web服务的自动组合,给定用某种语言描述的语义Web服务和用户需求之后,首先需要借助某种形式系统对Web服务组合问题进行建模,然后再通过智能规划、程序综合等各种途径生成满足要求的Web服务组合方案.形式系统的表达能力和计算性能决定了语义Web服务组合的准确度和求解效率.动态描述逻辑DDL(X)[2-3]是将动态逻辑、描述逻辑以及构建在描述逻辑之上的动作理论有机结合之后得到的逻辑系统.其既可以借助描述逻辑的刻画能力对静态领域知识进行刻画,又可以将这些知识作为领域背景,对原子动作和具有顺序、选择、循环等控制结构的复杂动作进行描述.针对动态描述逻辑中刻画的动作,文献[4]研究了动作的可实现性、可执行性、投影等问题,将这些问题都转化为动态描述逻辑中公式的可满足性问题,然后为公式的可满足性问题给出了判定算法并分析了算法的复杂度上限.文献[5]研究了如何将OWL-S刻画的语义Web服务建模为动态描述逻辑中的动作,然后借助动态描述逻辑的推理机制对语义Web服务的可执行性和执行后产生的效果等进行推理.该文也对语义Web服务组合问题进行了初步研究,但其考察的Web服务组合方案仅仅是由动作组成的顺序序列,不支持选择、循环等重要的控制结构.本文进一步将动态描述逻辑DDL(X)应用于语义Web服务组合.首先,本文将语义Web服务组合问题建模为基于DDL(X)的规划问题,其中规划问题的规划解可以由DDL(X)中的任一动作构成,从而使得相应的Web服务组合方案可以含有选择、循环等控制结构.接下来,针对建模后得到的任一规划问题,本文给出一个用来判断是否存在规划解的判定算法,当规划解存在时,可以借助判定过程将规划解解析出来.本文的方法充分发挥了DDL(X)在表达能力和计算性能等方面具有的优势,为语义Web服务的自动组合提供了一种有效的途径.2动态描述逻辑犇犇犔(犡)动态描述逻辑DDL(X)[2-4]是将动态逻辑、描述逻辑以及构建在描述逻辑之上的动作理论有机结合后得到的逻辑系统,其中的X对应于描述逻辑家族中ALC等具有不同表达能力的描述逻辑.在基本符号方面,令NR、NC、NI分别是描述逻辑X中的角色名集合、概念名集合和个体名集合.在此基础上,DDL(X)还引入了原子动作名集合NA.DDL(X)的基本成员包括角色、概念、公式和动作.其中,关于角色和概念的产生式规则与描述逻辑X中相同[4],这里不再详述.φ,ψ····=C(p)|R(p,q)|〈π〉φ|[π]φ|φ|φ∨ψ|φ∧ψ,其中,p,q∈NI,C为概念,R为角色,π为动作.DDL(X)中的公式由如下产生式生成:DDL(X)中的动作由如下产生式生成:其中,α∈NA,φ为公式.Page3在角色和概念的基础上,可以构造出角色包含公理、概念定义式、RBox、TBox以及ABox.具体的语法形式与描述逻辑X中相同[4].给定某个TBox,将出现在中概念定义式左边的各个概念名称为被定义的概念名,将不含有被定义的概念名的ABox断言称为原始文字.在此基础上,DDL(X)中引入了形如α≡(P,E)的原子动作定义式,其中:为了本文表述简便,下面引入几组符号.对于任一ABox断言ψ,用ψ表示与ψ逻辑等价的ABox断言,即如果ψ分别为C(p)、R(p,q)、作执行前必须满足的前提条件;(1)α∈NA,表示被定义的原子动作名;(2)P是由ABox断言组成的有限集合,表示动(3)E是由原始文字组成的有限集合,表示执行该动作之后将会产生的影响.对于由原子动作定义式组成的有限集合c,如果其中每个原子动作名最多被定义一次,则称c为ActBox.从语义上看,DDL(X)的解释结构是一个四元组M=(W,T,Δ,I),其中,W是由状态组成的非空有限集;函数T将每个原子动作名αi∈NA映射为W上的二元关系T(αi);Δ是由个体组成的非空集合;函数I为每个状态w∈W赋予描述逻辑X上的一个语义解释I(w)=(Δ,·I(w)).给定任一解释结构M=(W,T,Δ,I)之后,可以对DDL(X)中的角色、概念、公式和动作进行语义解释.其中,将每个动作π解释为W上的一个二元关系T(π);相对于任一状态w∈W,将每个角色R解释为Δ上的一个二元关系RI(w),将每个概念C解释为Δ的一个子集CI(w);此外,对任一公式φ在M中的w状态下是否成立进行解释,用(M,w)φ表示.在此基础上,进一步对RBox、TBox、ActBox和ABox的语义进行定义,分别用M、M、M,满足TBox、M相对于和满足ActBoxc以及M在状态w上满足ABox.详细的语义定义请参阅文献[4].DDL(X)中最基本的推理问题是公式可满足性问题.称公式φ相对于RBox、TBox和ActBoxc是可满足的,当且仅当存在某个解释结构M和其中的某个状态w使得M、M、Mc和(M,w)φ.文献[3-4]中已给出了相应的Tableau判定算法.C(p)或R(p,q),则ψ相应地为C(p)、R(p,q)、C(p)和R(p,q).在此基础上,对于任一ABox,用表示将中所有断言合取后得到的公式.对于任一被定义的原子动作名α∈NA,用Pα、Eα分别表示其前提条件集合和产生的影响的集合.对于任意两个原子动作α、β,如果Pα=Pβ并且Eα=Eβ,则称α和β具有相同的定义式.3对语义Web服务组合问题的建模给定用OWL-S语言描述的语义Web服务,文献[5]研究了如何从输入、输出、前提条件、结果等方面将每个原子服务建模为动态描述逻辑中的原子动作以及如何从数据流和控制流等方面将每个组合服务建模为动态描述逻辑中的复杂动作.在本文中,我们考察如何将原子服务组合起来,得到满足用户需求的服务组合方案.为了陈述简洁,我们对问题进行以下简化.首先,假设每个原子服务已经基于文献[5]的途径建模为动态描述逻辑DDL(X)中的原子动作,并且令ActBoxc是由这些原子动作组成的集合.其次,假设用户的需求主要体现在输入、输出、前提条件和结果4个方面;同样借助文献[5]的方法,我们假设已经将输入和前提条件建模为ABox,将输出和结果建模为ABox.最后,令RBox和TBox已经对c、和中涉及的角色和概念进行了刻画,构成了静态的领域知识.在此基础上,我们可以将语义Web服务组合问题建模为基于动态描述逻辑的规划问题.对规划问题定义如下.定义1.基于动态描述逻辑的规划问题是一个五元组=(,,c,,),其中:(1)、分别为RBox和TBox,用来对静态领域知识进行刻画;(2)c为ActBox,对原子动作进行刻画;(3)为ABox,对初始状态进行刻画;(4)为ABox,对目标状态进行刻画;(5)ABox相对于和是一致的,ABox相相应地,对规划问题的规划解定义如下.定义2.动作π是规划问题=(,,c,,)的一个规划解当且仅当满足以下3个条件:(1)出现在π中的每个原子动作都是在c中被对于和也是一致的.Page4定义的;刻画的状态下是可执行的;(2)相对于、和c来说,动作π在由ABox(3)相对于、和c来说,在刻画的状态下执行了π之后一定会使得公式Conj()成立.该定义中的最后两个条件在动作理论中也分别称为动作的可执行性问题和动作的投影问题.文献[4-5]中已经基于动态描述逻辑的解释结构对这两个问题进行了严格的定义,并将它们转换为公式可满足性问题来解决.在上面的定义中,我们允许规划解由动态描述逻辑中的任一动作组成,而不像大部分文献一样仅仅将规划解限制为由原子动作组成的有限序列[6].这样处理扩大了所能处理的规划问题的范围,并且与OWL-S中对Web服务组合方案的处理方式一致,可以支持OWL-S中不含有Split和Split+Join结构的各种Web服务组合方案.下面通过一个简单例子来说明.假设某个Web服务系统可以让用户通过信用卡在线购买图书.应用DDL(X)对其进行建模后,可以得到关于领域知识的RBoxshop和TBoxshop以及关于原子Web服务的ActBoxcshop.其中,在shop中含有如下角色包含公理:在shop中含有如下概念定义式:customer≡personholds.creditCard.在cshop中含有如下原子动作定义式:buyBook(a,b)≡({customer(a),cd(b),instore(b)},order(b)≡({book(b),instore(b)},{instore(b)}).上述两个原子动作定义式的直观含义为:Web服务buyBook(a,b)可以被执行的前提条件是a是一名顾客并且b是存在于库存中的图书,执行后产生的效果是b被a购买了且b不在库存中;Web服务order(b)可以被执行的前提条件是库存中没有图书b并且b之前没有被任何人买走,执行后产生的效果是b在库存中.在shop、shop和cshop中还含有其它定义式[4],限于篇幅这里不再列出.接下来,假设对用户的输入以及所满足的前提条件建模后得到ABoxshop={book(b),person(a),creditCard(v),has(a,v)};同时,对用户希望的输出和结果建模后得到ABoxshop={has(a,b)}.在此基础上,对Web服务组合问题建模后得到规划问题=(shop,shop,cshop,shop,shop).根据定义2,如下动作将是该规划问题的一个规划解:buyBook(a,b)∪(order(b);buyBook(a,b)),代表了满足用户需求的一个Web服务组合方案:要么直接执行Web服务buyBook(a,b),要么先执行Web服务order(b)然后再执行buyBook(a,b).在该例子中,如果我们将规划解限制为由原子动作组成的有限序列,则无法构造出满足要求的Web服务组合方案,因为无论是单独的原子动作buyBook(a,b)还是由order(b)和buyBook(a,b)组成的动作序列,在shop刻画的状态下都是不可执行的.但实际上,从Web服务提供方的角度看,如果在当前状态下instore(b)成立,则buyBook(a,b)是可执行的;如果instore(b)不成立,则可以先执行order(b)然后再执行buyBook(a,b);无论在什么情况下,用户所要求的输出和结果总是可以达到的.在本文中,通过允许规划解由动态描述逻辑中的任一动作构造而成,可以很好地解决上述问题.但与之对应,这种处理能力的增强为规划问题的求解带来了挑战,其中主要的挑战体现在如何对规划解中存在的选择结构和迭代结构进行处理.本文将在下一节解决这个问题.4对语义Web服务组合问题的求解令=(,,c,,)是对语义Web服务组合问题建模后得到的规划问题.本节给出一个判定算法,用来判断该规划问题是否存在规划解.本文的判定算法主要基于如下观察:如果动作π是规划问题的一个规划解,则必然存在某个形如γ1∪…∪γn的动作,其中:(1)n为正整数;(2)每个动作γi(1in)是由出现在π中的原子动作以及由这些原子动作所确定的测试动作一起形成的顺序动作;(3)γ1∪…∪γn也是规划问题的一个规划解.如果该性质成立,则判定算法只需要对π中所有原子动作能够组成的各种形式进行考察,看能否构造出动作γ1∪…∪γn,进而判断是否存在规划解.为了对上述性质进行严格的刻画和证明,下面先依次引入3个函数Regress(α,i)、Reduce(π)和Reduceplan(π,).定义3.对于任一ABoxi和任一原子动作Page5α,如果α是在某个ActBoxci中定义的并且公式〈α〉Conj(i)相对于、和ci来说是可满足的,则函数Regress(α,i)返回如下ABox:Regress(α,i)··={R(p,q)|R(p,q)∈i且R(p,q)ε}∪{R(p,q)|R(p,q)∈i且R(p,q)ε}∪{CRegress(ε,)(p)|C(p)∈i且C(p)ε}∪{CRegress(ε,)(p)|C(p)∈i且C(p)ε},其中ε=(Eα)DDL(ALCHOIQ@)的Tableau判定算法中递归构造的概念,具有如下性质:对于任一解释结构M=(W,T,Δ,I)和任意两个状态w,w∈W:如果(w,w)∈T(α),则必然有(CRegress(ε,))I(w)=CI(w).容易证明,函数Regress(α,i)具有如下性质.引理1.对于任一解释结构M=(W,T,Δ,I)和任意两个状态w,w∈W:如果M、M、M,Regress(α,i)当且仅当(M,w)i.基于该性质,为了判断在执行了原子动作α之后能否使得i中的ABox断言成立,我们只需要求出Regress(α,i)并判断其中的ABox断言在当前状态下是否成立.定义4.对于任一动作π,如果公式〈π〉true相对于、和c是可满足的,则函数Reduce(π)根据π的结构递归定义如下:β1,1∪…∪β1,m;β2,1∪…∪β2,k;(1)如果π是一个原子动作α,则返回α;(2)如果π是一个测试动作φ?,则引入一个新的原子动作名β和一个原子动作定义式β≡({φ},{}),添加记录β=Reduce(φ?),返回β;(3)如果π是一个顺序动作π1;π2并且π1和π2都是原子动作,则依次进行以下操作:①构建一个ABoxPre··=Pπ1∪Regress(π1,Pπ2);②令ε1=(Eπ1)Eff··=(ε1\ε2)∪ε2;定义式β≡(Pre,Eff);③引入一个新的原子动作名β和一个原子动作④添加记录β=Reduce(π1;π2),返回β;(4)如果π是一个顺序动作π1;π2并且π1和π2①调用函数Reduce(π1),令其返回的动作为②调用函数Reduce(π2),令其返回的动作为不全是原子动作,则依次进行以下操作:始化为空集;下操作:③将上面得到的两个动作以笛卡尔积方式组合后形成选择动作(β1,1;β2,1∪β1,1;β2,2∪…∪β1,1;β2,k)∪(β1,2;β2,1∪β1,2;β2,2∪…∪β1,2;β2,k)∪…∪(β1,m;β2,1∪β1,m;β2,2∪…∪β1,m;β2,k),令其为γ;④调用函数Reduce(γ)并令β是其返回的动作,返回β;(5)如果π是一个选择动作π1∪π2,则依次进行以下操作:①构建一个关于原子动作的集合Sact并将其初②如果公式〈π1〉true相对于、和c来说是可满足的,则调用函数Reduce(π1)并且令β1,1∪…∪β1,m是该过程返回的动作;对于每个原子动作β1,i(1im),如果Sact中不存在与β1,i具有相同定义式的原子动作,则将β1,i加入集合Sact;③如果公式〈π2〉true相对于、和c来说是可满足的,则调用函数Reduce(π2)并且令β2,1∪…∪β2,k是该过程返回的动作;对于每个原子动作β2,i(1ik),如果Sact中不存在与β2,i具有相同定义式的原子动作,则将β2,i加入集合Sact;④将Sact中各个原子动作通过构造符∪连接起来,返回所得到的动作;(6)如果π是一个迭代动作π1,则依次进行以①构建关于原子动作的队列Qact和集合Sact,并②引入一个新的原子动作名β0和原子动作定义式β0≡({true},),添加记录β0=Reduce(true?),并且将β0分别加入队列Qact和集合Sact;③如果公式〈π1〉true相对于、和c来说是可满足的,则依次执行以下操作:(a)调用函数Reduce(π1)并且令β1∪…∪βm是该过程返回的动作;(b)从Qact中取出一个动作并令其为α;(c)对于每个原子动作βi(1im)分别进行以下操作:调用函数Reduce(α;βi)并且令γi是该过程返回的动作,如果Sact中每个原子动作的定义式都与γi的定义式不相同,则将γi分别加入Qact和Sact;(d)如果队列Qact非空,则跳转到步(b);④将Sact中各个原子动作通过构造符∪连接起来,返回所得到的动作.从上述定义容易看出,函数Reduce(π)将把动作π转化为形如β1∪…∪βn的动作,使得其中的每个βi(1in)要么是出现在π中的原子动作要么是新定义的原子动作.其中,为了追踪每个新定义的原子动且将两者都初始化为空集;Page6作的生成过程,在递归过程中每次生成一个新的原子动作βi时都添加了相应的记录βi=Reduce(βi),用来表明βi是根据动作βi构造出来的.通过对π的结构进行归纳,容易证明上面定义的函数Reduce(π)是可终止的,并且具有如下性质.引理2.令β是函数Reduce(π)返回的动作,令α1,…,αl是出现在π中的所有原子动作,令Π为公式(Conj(Pα1)→〈α1〉true)∧…∧(Conj(Pαl)→〈al〉true),令c是由出现在π和β中的所有原子动作的定义式组成的ActBox.对于满足M、M和M,必然有回的动作;③调用过程Reduce(γi)并且令βi是该过程返④构造集合Stest··=Regress(βi,);⑤令ψi,1,…,ψi,ki是集合Stest中含有的所有ABox断言,构造一个顺序动作ψi,1?;…;ψi,ki?;γi并且将其加入集合Sact中;(4)令γ1,…,γn是集合Sact中含有的所有动作,(1)T(π)T(β);(2)对于任意两个状态w,w∈W:如果(w,w)∈T(β)且(M,w)[(α1∪…∪αn)]Π,则(w,w)∈T(π).定义5.对于任一动作π,如果其是规划问题的一个规划解,则函数Reduceplan(π,)操作如下:(1)调用函数Reduce(π)并令其返回的动作为β1∪…∪βm;令c是由各个原子动作βi(1im)的定义式组成的集合;(2)构建一个初始值为空集的集合Sact;(3)对于每个原子动作βi(1im),如果公式Conj()∧〈βi〉Conj()相对于、和c来说是可满足的,则依次进行以下操作:①调用过程Revert(βi)并且令βi,1;…;βi,hi是其返回的动作;其中,过程Revert(βi)递归操作如下:(a)如果βi是出现在π中的原子动作,则返回βi;(b)否则,在调用Reduce(π)的过程中必然存在某个记录βi=Reduce(π),其中的π要么是一个测试动作φ?,要么是由两个原子动作组成的顺序动作π1;π2,在前一种情况下返回测试动作φ?,在后一种情况下返回顺序动作Revert(π1);Revert(π2);②如果βi,1;…;βi,hi全部由测试动作组成,则令γi为测试动作true?,否则令γi是从βi,1;…;βi,hi中删除所有测试动作以及与这些测试动作相关联的构造符“;”之后得到的动作;构造一个选择动作γ1∪…∪γn并将其返回.从上述定义容易看出,函数Reduceplan(π,)把规划问题的规划解π转化为形如γ1∪…∪γn的动作,并且该动作具有如下特点:(1)n为正整数;(2)每个动作γi(1in)形如γi,1;…;γi,mi,其中mi1,并且存在某个整数ki(0kimi)使得:每个动作γi,j(1jki)都是一个测试动作,每个动作γi,j(ki+1jmi)都是一个出现在π中的原子动作,此外,令βi是过程Reduce(γi,ki+1;…;γi,mi)返回的动作(当ki=mi时令βi为测试动作true?),则集合{φ?|φ∈Regress(βi,)}与集合{γi,j|1jki}相等;(3)对于每个动作γi(1in),公式Conj()∧〈γi〉Conj()相对于、和c来说是可满足的.此外,函数Reduceplan(π,)还具有如下性质.引理3.函数Reduceplan(π,)是可终止的;并且,令其返回的动作为γ1∪…∪γn,则γ1∪…∪γn是规划问题的一个规划解.根据对规划解的定义容易证明上述性质.限于篇幅这里不再详细叙述.基于以上3个函数和相应的3个引理,可以得到如下性质.定理1.规划问题=(,,c,,)有规划解当且仅当可以构造出某个形如γ1∪…∪γn的动作,其中:(1)n为正整数;(2)每个动作γi(1in)形如γi,1;…;γi,mi,其中mi1,并且存在某个整数ki(0kimi)使得:①每个动作γi,j(1jki)都是一个测试动作;②每个动作γi,j(ki+1jmi)都是一个在c中定义的原子动作;③令βi是过程Reduce(γi,ki+1;…;γi,mi)返回的动作(当ki=mi时令βi为测试动作true?),则集合{φ?|φ∈Regress(βi,)}与集合{γi,j|1jki}相等;(3)对于每个动作γi(1in),令γi是过程Reduce(γi)返回的动作,令ci是由出现在γi中的所有原子动作的定义式组成的ActBox;则必然有①公式Conj()∧〈γi〉Conj()相对于、和ci是可满足的;②公式Conj()→[γi]Conj()的否定式相对于、和ci来说是不可满足的;③公式Conj()→(Conj(Pγ1)∨…∨Conj(Pγn))Page7的否定式相对于、和ci来说是不可满足的.证明.令α1,…,αl是c中定义的所有原子动作,用Π代表公式(Conj(Pα1)→〈α1〉true)∧…∧(Conj(Pαl)→〈al〉true).下面从两个方面对定理进行证明.()假设存在某个动作γ1∪…∪γn满足定理中的要求,下面根据定义2从3个方面证明该动作是一个规划解.然都是在c中被定义的.首先,出现在γ1∪…∪γn中的所有原子动作显其次,对于任一解释结构M=(W,T,Δ,I)和任一状态w∈W:如果M、M、M,(M,w)Conj()以及(M,w)[(α1∪…∪αn)]Π,则根据定理1中条件(3)的第③项,结合引理2,必然存在某个状态w∈W使得(w,w)∈T(γ1∪…∪γn).因此公式[(α1∪…∪αn)]Π→(Conj()→〈γ1∪…∪γn〉true)的否定式相对于、和c是不可满足的,即动作γ1∪…∪γn在刻画的状态下是可执行的.最后,对于任一解释结构M=(W,T,Δ,I)和任意两个状态w,w∈W:如果M、M、M,T(γ1∪…∪γn),则根据定理1中条件(3)的第②项,结合引理2,可以得出(M,w)Conj().因此,公式Conj()→[γ1∪…∪γn]Conj()的否定式相对于、和c是不可满足的,即在刻画的状态下执行了动作γ1∪…∪γn之后一定使得公式Conj()成立.()假设规划问题存在规划解π.令γ1∪…∪γn是过程Reduceplan(π,)返回的动作.根据对过程Reduceplan(π,)的定义,其返回的动作γ1∪…∪γn显然满足定理1中的前两项要求;并且,对于每个动作γi(1in),公式Conj()∧〈γi〉Conj()相对于、和c是可满足的.根据引理3,γ1∪…∪γn是的一个规划解,即公式Conj()→[γ1∪…∪γn]Conj()的否定式和公式[(α1∪…∪αn)]Π→(Conj()→〈γ1∪…∪γn〉true)的否定式都是相对于、和c不可满足的.结合引理2,可以证明每个γi(1in)都满足定理1中的条件(3).在上述性质的基础上,下面给出规划问题的判定算法.直观来说,该算法将考察由出现在π中的原子动作形成的各种顺序动作,看能否构造出满足定理1中各项要求的动作γ1∪…∪γn.算法1.对规划解存在性的判定.输入:任一规划问题=(,,c,,)输出:TRUE或者FALSE步骤:令α1,…,αl是c中定义的所有原子动作;通过以下步骤判断是否存在规划解.1.构建关于原子动作的队列Q、集合SQ和集合Sok,并且将三者都初始化为空集;构建一个ABoxc并且令c··=c;构建一个公式Fpre并且令Fpre··=Conj().2.如果Fpre∧Conj()相对于、和c是不可满足的,则依次进行以下操作:式β≡({true},{}),增加记录β=Reduce(true?);(1)引入一个新的原子动作名β和一个原子动作定义(2)Sok··=Sok∪{β};(3)返回“TRUE”,算法结束.3.对于c中定义的每个原子动作αi(1il),如果公式Conj()∧〈αi〉true相对于、和c是可满足的,并且SQ中不存在与αi具有相同定义式的动作,则将αi分别加入队列Q和集合SQ.4.从Q中取出一个动作并令其为γ.5.如果公式Conj()∧〈γ〉Conj()相对于、和c是可满足的,并且Regress(γ,)=,则依次进行以下操作:(1)Sok··=Sok∪{γ},Fpre··=Fpre∧Conj(Pγ);(2)如果公式Fpre相对于、和c是不可满足的,则返回“TRUE”,算法结束.6.如果公式Conj()∧〈γ〉Conj()相对于、和c是可满足的,但Regress(γ,)≠,则依次进行以下操作:(1)令φ1,…,φj是包含在Regress(γ,)中的所有ABox断言;引入一个新的原子动作名β和一个原子动作定义式β≡(Pγ∪{φ1,…,φj},Eγ);(2)将β的定义式加入集合c并且增加记录β=Reduce(φ1?;…;φj?;γ);(3)Sok··=Sok∪{β},Fpre··=Fpre∧Conj(Pβ);(4)如果公式Fpre相对于、和c是不可满足的,则返回“TRUE”,算法结束.7.对于c中定义的每个原子动作αi(1il),如果公式Conj()∧〈γ〉Conj(Pαi)相对于、和c是可满足的,则依次进行以下操作:(1)调用过程Reduce(γ;αi)并且令γi是该过程返回的动作;添加记录γi=Reduce(γ;αi);(2)如果SQ中不存在与γi具有相同定义式的动作,则将γi分别加入队列Q和集合SQ,并且将γi的定义式加入集合c;“FALSE”,算法结束.8.如果队列Q非空,则跳转到步3,否则返回下面考察算法1的可终止性、可靠性和完备性.定理2.对于任一规划问题=(,,c,,Page8),算法1是可终止的.证明.令α1,…,αl是c中定义的所有原子动作.令r是集合中角色包含公理的个数;令e、t分别是集合Eα1∪…∪Eαl和集合Pα1∪…∪Pαl∪中ABox断言的个数.令Eff、Preini、Preall是下面构建的3个ABox:Eff··=(Eα1)Preini··=Pα1∪…∪Pαl∪,Preall··=Preini∪{CRegress(ε,)(p)|C(p)∈Preini且εEff}∪{CRegress(ε,)(p)|C(p)∈Preini且εEff}.显然,集合Eff的元素个数最多为2×e×(r+1),Preall的元素个数最多为t×22×e×(r+1).对于算法1中加入队列Q的每个原子动作γ,必然有PγPreall和EγEff;并且,加入Q的任意两个原子动作都具有不同的定义式.因此,算法1执行过程中加入Q的动作最多为22×e×(r+1)+m个,其中m··=t×22×e×(r+1).所以,步4与步8之间的循环次数是有限的.故算法1是可终止的.证毕.定理3.如果算法1返回“TRUE”,则规划问题=(,,c,,)必然存在规划解.证明.令β1,…,βn是算法1返回“TRUE”时包含在集合Sok中的所有原子动作.则根据算法1,有Fpre=Conj()∧Conj(Pβ1)∧…∧Conj(Pβn),并且Fpre相对于、和c是不可满足的.针对每个原子动作βi(1in)调用过程Revertplan(βi),其中对Revertplan(βi)递归定义如下:(1)如果βi是c中定义的原子动作,则返回βi;(2)否则,在算法1的执行过程中必然存在某个记录βi=Reduce(π),其中的π要么形如φ1?;…;φj?;γ,要么形如γ;αi;如果是前一种情况则返回顺序动作φ1?;…;φj?;Revertplan(γ),如果是后一种情况则返回顺序动作Revertplan(γ);αi.令γi是过程Revertplan(βi)返回的动作.根据算法1以及上面对Revertplan(βi)的定义,γi必然形如γi,1;…;γi,mi,其中mi1,并且存在某个非负整数ki使得:①每个动作γi,j(1jki)都是一个测试动作;②每个动作γi,j(ki+1jmi)都是一个在c中定义的原子动作;③令βi是过程Reduce(γi,ki+1;…;γi,mi)返回的动作(当ki=mi时令βi为测试动作true?),则有{γi,j|1jki}={φ?|φ∈Regress(βi,)}.将经过上述操作得到的每个动作γi(1in)连接起来后得到选择动作γ1∪…∪γn.容易验证,γ1∪…∪γn满足定理1中的3项要求,是规划问题的一个规划解.定理4.如果规划问题=(,,c,,)存在规划解,则算法1必然会返回“TRUE”.证明.由于存在规划解,必然存在某个动作γ1∪…∪γn满足定理1中的3项性质.基于这些性质容易论证算法1将会返回“TRUE”.证毕.5相关工作在不考虑语义Web技术的情况下,被工业界广为接受的是采用BPEL4WS语言对Web服务组合方案进行描述.由于BPEL4WS是一种基于工作流的描述语言,其刻画的Web服务组合方案可以比较直观地建模为有限状态自动机、Petri网、pi-演算等形式化模型.相应地,可以通过模型检测、可达性分析等技术生成Web服务组合方案或者对已有的Web服务组合方案进行分析验证[7-9].引入语义Web技术之后,基于工作流的方法同样可以被扩展后用来解决语义Web服务组合问题.文献[10]对语义Web服务的输入参数和输出参数进行考察,将每个参数所引用的语义概念(即描述逻辑中的概念)当作一个命题,从而将每个原子Web服务建模为一组命题Horn子句;与此同时,将用户提供的输入参数和所期望的输出参数分别建模为命题Horn子句中的事实和目标,从而将服务组合问题转换为关于Horn子句的逻辑推理问题.在此基础上,该文应用Petri网对Horn子句集进行建模,进而借助T-不变量技术对Web服务组合问题进行求解.在基于工作流的方法中,一个共同特点是将每个状态刻画为在当前状态下成立的命题公式的集合;对于由基于描述逻辑的本体提供的语义信息,这类方法只能把描述逻辑中的每个概念当作一个原子命题,把概念之间存在的包含关系建模为原子命题之间的蕴涵关系(例如文献[10]用Horn字句规则来刻画各个语义概念之间存在的等价关系).显然,这种处理方式具有较高的求解效率.但存在的局限是不能充分利用本体中各种各样的语义关联,限制了语义Web技术所能发挥出的功能;此外,需要事先从本体中提取出各语义概念之间存在的所有包含关系,而这些包含关系在服务组合过程中不一定全部用到.程序综合等软件工程的方法也被研究者应用于语义Web服务组合.文献[11]将OWL-S(之前称为DAML-S)刻画的语义Web服务建模为由命题线性Page9逻辑LL表示的公理,将用户需求建模为由LL表示的定理,然后将Web服务组合问题转换为线性逻辑LL中的定理证明问题,其中在建模过程中主要考虑了语义Web服务的输入参数和输出参数:将每个参数所引用的语义概念当作线性逻辑LL的一个原子命题,并且把概念之间存在的包含关系建模为原子命题之间的蕴涵关系.该方法与基于工作流的方法具有同样的局限:不能充分利用本体中各种各样的语义关联,并且需要事先推理出各个语义概念之间存在的所有包含关系.针对这些局限,该文在研究展望中提出利用一阶线性逻辑对语义Web服务进行建模,但目前还没有相关论文发表.动作理论和智能规划等人工智能的方法为语义Web服务组合提供了合适的理论和方法.文献[12]应用情景演算对OWL-S/DAML-S刻画的原子Web服务进行建模,其中将Web服务的输入和前提条件建模为情景演算中的动作前提条件公理,将Web服务的输出和执行Web服务后产生的效果建模为情景演算中的后继状态公理.在该工作的基础上,文献[13]进一步应用扩展的Golog语言对OWL-S/DAML-S中不含有控制结构Split和Split+Join的组合Web服务进行刻画,从而将Web服务组合问题转化为支持Golog语言的规划问题.文献[14]将原子Web服务建模为规划系统SHOP2中的操作,将不含有控制结构Split和Split+Join的组合Web服务建模为SHOP2中的方法,从而借助SHOP2实现语义Web服务组合.文献[15]应用事件演算对OWL-S刻画的Web服务进行建模,将Web服务组合问题转化为基于事件演算的规划问题,然后借助相应的反绎定理证明器进行问题求解.动作理论为语义Web服务提供了合适的逻辑基础,但总的来说,上述工作仍然存在两个局限.首先,SHOP2等规划工具在规划求解过程中采用了闭世界假设,不能体现出描述逻辑中采用开世界假设时带来的优势;其次,情景演算、事件演算等动作理论建立在一阶谓词逻辑或高阶逻辑的基础上,具有很强的表达能力;但与此同时,由于一阶谓词逻辑的不可判定性,最终可能导致服务组合算法无法终止.文献[16]提出了建立在描述逻辑之上的动作理论;随后,文献[17-18]将该动作理论应用于对语义Web服务的建模和推理以及在此基础上的语义Web服务组合.该动作理论采用描述逻辑中的非循环TBox对静态领域知识进行刻画;采用描述逻辑中的ABox对世界状态、执行动作之前必须满足的条件、动作执行过程中的不确定成分以及执行动作之后产生的影响等进行刻画;最后将原子动作以序列的形式组织起来构成复杂动作.该动作理论在表达能力上比情景演算要弱一些,但相应地具有了可判定性这个优点;此外,该动作理论可以将关于动作的各种推理问题转换为描述逻辑中ABox一致性问题,从而可以在采用开世界假设的情况下进行推理.但是,从语义Web服务组合的角度来看,该动作理论只允许各个原子Web服务以序列的形式组织起来,不支持选择、循环等必要的控制结构.本文采用的是基于动作理论和智能规划的方法.首先,与文献[10]等基于工作流的方法以及文献[11]等基于程序综合的方法相比,本文方法的特点在于用求解效率换取表达能力.本文方法完全发挥了描述逻辑的表达能力,可以充分利用本体中各种各样的语义关联,不需要事先将语义概念之间的包含关系识别出来并转换为命题逻辑公式.其次,与文献[12-15]等基于情景演算或者事件演算的工作相比,本文方法则是用表达能力换取求解效率.本文采用的动态描述逻辑在表达能力上比情景演算弱一些,但相应地具有了可判定的优点,并且在推理过程中采用了开世界假设.接下来,与文献[16-18]等的工作相比,本文采用的动态描述逻辑在表达能力上完全兼容了这些工作中采用的动作理论[4],并在其基础上增加了动态逻辑中关于动作的各种控制结构;从Web服务组合的角度看,本文考察的服务组合方案可以由动态描述逻辑中的各种动作构造符构成,因而支持除Split和Split+Join之外的所有Web服务控制结构[5].文献[6]也将动态描述逻辑应用于Web服务自动组合,但其中考察的服务组合方案只能由原子Web服务以序列的形式构成,因而存在与文献[16-18]等相似的局限.最后一项需要考察的工作是文献[19].该文对语义Web服务的输入参数和输出参数进行考察,将每个参数所引用的语义概念当作一个命题,从而将每个原子Web服务建模为由命题动态逻辑刻画的原子动作;在此基础上,借助命题动态逻辑与描述逻辑之间存在的对应关系[20],将刻画原子动作的命题动态逻辑公式转换为描述逻辑中的概念包含公理,进而将Web服务组合问题转换为描述逻辑中的概念可满足性问题.该方法的主要优点在于充分利用了本体中各种各样的语义关联,并且仍然具有较高的求解效率;文献[10-11]等方法不需要事先从本体中提取出语义概念之间的所有包含关系.然而,该方Page10法实质上采用了基于命题动态逻辑的动作理论,因而在对语义Web服务建模时不能从个体、谓词等粒度进行考察,进而不能对原子Web服务的前提条件以及执行Web服务后产生的效果等进行处理.与该方法相比,本文采用了基于动态描述逻辑的动作理论,可以对语义Web服务进行粒度更细的并且更全面的刻画,进而可以生成更加符合要求的Web服务组合方案;当然,这种刻画能力的获得是以牺牲求解效率为代价的.总的来说,针对语义Web服务组合问题,首先需要应用某种形式系统对其进行建模,然后借助与形式系统相应的工具进行求解.包括本文方法在内,已有的各种方法之间的区别主要体现为形式系统的表达能力以及相应工具的求解效率的不同.实际上,表达能力与求解效率之间是一对矛盾关系;除了寻求两者之间良好的折中点之外,一个现实的途径是提供具有不同表达能力(相应地具有不同的求解效率)的多套工具,让使用者按需选用.本文和上述文献中提出的方法一起为使用者提供了多套可供选择的工具.6结论本文将语义Web服务组合问题建模为基于动态描述逻辑的规划问题.该规划问题的规划解可以由动态描述逻辑中的任一动作构成,因而可以支持OWL-S中不含有控制结构Split和Split+Join[5]的所有Web服务组合形式.针对规划问题,本文给出了一个用来判断是否存在规划解的判定算法.该算法主要基于如下性质:规划问题的每个规划解都可以转化为由有限个顺序动作组成的选择动作,并且其中的每个顺序动作都由规划域中的原子动作以及由这些原子动作所确定的测试动作组成.本文借助3个依次引入的操作证明了上述性质,并在其基础上给出了判定算法.该算法是可终止、可靠和完备的,并且当规划解存在时可以根据判定过程将规划解解析出来.本文的Web服务组合方法建立在动态描述逻辑的基础上,其适用范围相应地受到动态描述逻辑的影响.目前的动态描述逻辑存在两个局限:TBox由概念定义式组成,不允许出现一般概念包含公理;未引入动作并行算子,从而尚未支持OWL-S中的Split和Split+Join等控制结构.在下一步的工作中,我们将针对这两个局限对动态描述逻辑进行扩展,进一步增强其表达能力.语义Web服务的最终目标是实现Web服务的功能自动化,包括Web服务的自动发现、自动组合、自动调度执行以及执行过程中的自动监控管理等.本文仅仅研究了自动组合问题.如何构建一个统一的形式化框架,并在其基础上全面实现Web服务的功能自动化,是我们最终希望解决的问题.致谢感谢审稿专家提出的宝贵意见!
