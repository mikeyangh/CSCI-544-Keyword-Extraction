Page1HV-Recovery:一种闪存数据库的高效恢复方法卢泽萍孟小峰周大(中国人民大学信息学院北京100872)摘要和磁盘相比,闪存作为一种新型的存储设备,具有读写速度快、抗震、省电、体积小等优点.因此,当前的研究普遍认为闪存将取代磁盘成为新一代的数据库二级存储设备.但是,由于闪存具有和磁盘不同的一些固有的读取特性,将当前基于磁盘设计的数据库直接移植到闪存上时,并不能充分发挥闪存设备的优越性.在数据库的恢复过程中,由于闪存的异地更新和重写之前先擦除的特性将带来大量高代价的小的随机写,直接使用传统的恢复方法在闪存数据库中就更难以充分利用闪存的优越性.因此,文中提出了一种对闪存中天然存在的数据的历史版本来进行管理和利用的恢复方法HV-recovery,来改进undo恢复的性能.通过和开源数据库OracleBerkeleyDB的比较,实验结果表明HV-recovery是原有的恢复算法性能的2~8倍,充分说明了其优越性.关键词闪存;闪存数据库;固态硬盘;恢复;日志1引言海量的数据对数据库系统性能的要求也越来越高.而作为当前比较主流的二级存储介质,磁盘因为其内部的机械移动已经成为IO性能的瓶颈,越来越随着信息技术的飞速发展,数据呈爆炸性增长,不能满足实际应用系统对数据存取带宽的需求.在Page2过去的20年里,CPU处理速度增加了570倍,而磁盘的访问速度却只增加了20倍[1].可见,CPU和主要二级存储器磁盘之间的带宽鸿沟已经成为了制约计算机系统处理能力提高的主要瓶颈.值得庆幸的是,闪存作为一种新型的固态存储设备,由于其读写速度快、消耗电量低、抗震、小巧轻便等优点,已经受到越来越多的关注.随着容量的不断增大和单位价格的不断下降,许多研究者纷纷预测闪存将逐渐取代磁盘成为新的主流二级存储设备.图灵奖得主GrayJim在2005年就曾预测说“就像磁盘取代磁带一样,闪存将会取代磁盘”[1].即使对现有的数据库不做任何改进,直接移植到闪存上,其性能也能提高大约10倍[2].但是,由于闪存其固有的特性,若将现有的面向磁盘的传统数据库直接运行在闪存存储器上,还不能充分发挥闪存的优越性.因此,当前迫切需要将传统的数据库进行改进,让其更好地适应闪存本身的特点,以进一步提高闪存数据库的性能[3-4].数据库开发和应用的实践表明,数据库恢复技术作为数据库系统中不可缺少的组成部分,对整个系统的性能影响是非常大的[5-7].在恢复过程中,为了对事务已经更改的数据项进行还原,通常需要对数据库中的一些已经赋予新值的数据进行重写.而这种大量的小随机重写操作,对闪存的代价是非常巨大的,不但浪费空间,而且非常耗时.因此,迫切需要一种高效且稳定性强的闪存数据库的恢复技术.本文针对闪存存储器中天然存在的历史版本数据,提出了一种充分利用这些数据的历史版本从而进行恢复的一种新型的恢复方法HV-recovery.总的来说,本文所做的主要贡献如下:(1)本文研究了闪存数据库中的恢复问题,并提出了新的适用于闪存的恢复方法.(2)提供简单有效的恢复操作.有效地减少在恢复过程中容易出现的冗余写操作,从而大幅度减少恢复时间.(3)优化日志结构.减少过多的日志冗余,从而提供高效的日志文件.(4)提高空间利用率.减少大量垃圾数据的存在,从而提高存储设备中的空间利用率.本文第2节介绍闪存特殊的物理特性给恢复带来的挑战以及相关工作;第3节详细介绍本文设计的HV-recovery的基本原理;第4节提出怎样针对HV-recovery中的设计进行进一步的性能优化;第5节用分析及实验结果证明设计的优越性;最后第6节进行总结.2问题定义及相关工作闪存和磁盘读写特性的不同使得将现有的传统的数据库移植到闪存上时会出现一些问题.下面将具体介绍在恢复中出现问题的原因和现有的一些改进方案及它们所存在的问题.2.1闪存存储器的物理特性没有机械延迟.我们知道,在磁盘中,访问数据的时间主要用于移动磁头以及等待磁盘旋转.而闪存没有像磁头一样的机械部件,其随机访问模式和顺序访问模式的开销是相当的.这样,就可以把数据离散地分布,这并不会使访问的开销增加.重写之前先擦除.众所周知,在磁盘中,如果需要更新数据,这些数据的新版本可以直接原地覆盖在旧版本所占有的地址上,这就是所谓的原地更新.可是在闪存中,在数据的旧版本没有被擦除前,是不能在原地写入新的版本的.也就是说,如果修改一个数据,就需要对整个块(通常为64K或128K)上的数据进行擦除,这是非常巨大的代价.因此,在闪存中往往会采取异地更新的方式,即把数据的新版本写入另外的空闲空间中,而不直接在原地覆盖.读写速度不一致.在闪存中,不同的访问操作的速度差别很大.一般来说,读的速度很快,写的速度略慢,擦除的速度最慢.因此,在设计新的基于闪存的数据结构中,应当尽量减少写操作和擦除操作,可以适当增加读操作,以整体上提高系统性能.有限的擦除次数.虽然闪存中的块是可以进行反复擦除的,但每个块的擦除次数是有限的,一般为10000~100000次.因此,就必须尽量减少写入的次数,以间接减少擦除的次数,来延长闪存的使用寿命.2.2问题定义在面向磁盘的数据库系统中,基于日志的恢复技术被广泛采用.不同的协议之下,日志记录的设计、日志/数据缓冲区的管理、检查点机制、记录日志和恢复的过程都很不一样.以最为常见的undo日志为例,当事务T需要将数据库元素X的取值v改变时,undo日志就会将形如〈T,X,v〉的日志记录记到磁盘上,当需要对事务T进行恢复,则需要在外存中重新写入X的值v.若将这个过程移到闪存上,举例来说,如果数据库中存在一个如表1(a)所示的数据表,当需要将数据表中的A值由v1修改为v2时,就要写入一条新的记录,如表1(b)所示得最后1行.而如果需要将APage3值进行恢复的时候,就要再写入一条其实早已存在于内存中的记录,如表1(c)所示.这就可以看出,最后1条记录和第1条记录是相同的.也就是说,这其实是存在冗余的.因此,闪存中通常存在着大量的数据的历史版本,而显式的恢复过程又不断地写入已经存在的数据项.这既浪费空间又浪费时间.表1undo日志在闪存数据库中存在的问题同时,我们已经知道,闪存通常采取异地更新,但是因为闪存每次写的单位为页,即使是有所改进的闪存,其一页也通常只能写4次.也就是说,不管一次要写入的数据量多大,至少需要占用闪存中四分之一个页的大小,而通常来说,一个需要恢复的数据项可能并没有这么大.这样,就更带来了额外的空间浪费.同时,这些额外的写操作会有较高的时间代价,并且因为一些额外的空间浪费,就会带来一些本不必要的擦除操作,其时间代价更为巨大.因此,在恢复中所进行这种大量的小的随机重写对闪存的代价也是非常可怕的,这就需要设计新的恢复方法.2.3相关工作随着技术的不断发展,闪存的优势越来越明显,有越来越多的研究关注于如何在基于闪存的数据库中提供更高的性能,其中较有影响力的工作包括IPL[8]、FlashLogging[9]、TransactionalFlash[10]和PORCE[11]等.IPL彻底改变了闪存数据库中的存储结构,它将闪存上每个块中的页分为两个部分:数据页和日志页.当对一个块中的数据页进行修改时,为了避免闪存的原地更新带来的巨大代价,IPL只是将修改以日志的形式保存在其数据所在块的日志页中.并且在日志区域满时,进行日志记录与数据的合并,来减少存储空间.这种存储方式因为将对数据库的改变通过日志方式保存,可以间接的对数据库提供恢复.但是,这需要对现有的数据库进行较大的修改,并不能方便地移植于不同的数据库中.FlashLogging提出了一种使用多个性价比高且更适合于日志的访问和存储模式的USB设备,来取代SSD记录日志.因为USB的存储容量一般来说相对较小,FlashLogging设计了一种轮转式的阵列组织方式来有效地管理这些分散存放在USB设备中的日志记录,并提供恢复.这种方法需要大量的USB设备阵列,并且会需要对多个USB设备进行读写,这是非常耗时的,而且随着SSD价格的不断下降,USB设备的价格优势也在渐渐消失,因此,这并不是一个方便的系统搭建模式.另外,在闪存中,若使用FTL层来屏蔽Flash的物理特性,则需要维护一个物理地址和逻辑地址的映射表,而将闪存作为嵌入式系统的存储设备时,则因为常常会出现断电的情况,就容易丢失这个映射表.因此,PORCE提供了一种在断电之后如何提供物理地址和逻辑地址映射的恢复方法.而针对基于闪存的文件系统,SAC2006[12]和TOS2006[13]提出了一种如何利用闪存的特性,来提供对基于闪存的文件系统的快速载入和崩溃之后的恢复的方法.然而,这些方法是针对于文件系统,而不是我们讨论的数据库系统,虽然设计思路上可以有较好的参考,但其性能并不能直接地与我们的设计相互比较.3HV-recovery通过之前的分析,可以发现,在闪存存储设备中,在恢复时,完全没有必要用显式的回滚操作来重新写入数据元素在事务更新前的内容.考虑到在闪存中数据项新旧版本的同时存在,可以利用旧版本来加快回滚和恢复的过程,而不需要发起更为昂贵的写操作来多次写入一个已经存在的数据项内容.本文的设计就是考虑最大限度地利用数据项之前的历史版本来进行恢复.图1是HV-recovery的一个整体的体系结构图.在数据库的正常运行阶段,随着事务对数据文Page4件的不断更改,日志管理器同时将形如(Tid,X,P(X))的日志记录存放在日志文件中,当数据库发生崩溃或是要对事务进行回滚时,恢复管理器就根据得到的需要进行恢复的事务的ID读取日志文件,获得相关的日志记录,并根据这些日志记录进行恢复.以下将详细介绍其中各部分的具体实现.3.1更新日志在对日志记录进行管理时,HV-recovery使用了一个版本列表version_list来保存日志记录,其结构如表2所示.作为日志记录,其中存储的是被修改的各数据库元素的历史版本的地址信息、引起该数据库元素更改的事务的标识以及该数据项的旧值.TidT1T2T4T4T4T6T2T1T1commitNULLNULL…当需要数据库系统对数据项进行更新时,在将新的数据版本写入新地址的同时,日志管理器会将这个数据项的旧值、旧地址以及该事务标识存入到version_list中.并将其作为日志记录保存在永久性存储器中.同时,HV-recovery的日志记录类似于undo日志,必须遵守两条规则.规则A.如果事务改变了数据库元素,则日志记录必须在数据库元素的新值写到二级存储器前写出.规则B.如果事务提交,则其事务提交日志记录操作必须在事务改变的所有数据库元素已写到二级存储器之后再执行,但应尽快.这样,在恢复中,只要对于在日志记录中显示为未提交的事务,对在日志记录中所保存的该事务所做的所有修改进行还原,就可以保证数据库对于事务所要求的ACID特性.另外,在HV-recovery中,若同一个事务对某一个它已更新过的数据项又有新的更新,就增加一条新的日志记录,保存新的更新操作.如表2的第1条记录和第8条记录所示.而如果是不同事务对同一数据项进行修改,在满足数据库对于并发设计的要求的前提下,对日志记录部分来说,也是产生一条新的日志记录在version_list中.如表2中,第2条记录和第7条记录所示,T2修改了A之后又修改了数据项Y,那日志管理器就将这两次修改作为两条不同的日志记录来存储.若数据库插入一个新的数据库元素,则与更改日志记录类似,产生一条新的日志记录,只是该日志记录的旧值和旧地址项被设置为空,以识别为插入操作.如表2中第3条记录所示.若数据库删除一个数据项,在写入原有的日志记录的同时,再增加一条日志记录,使用相同的事务标识和数据项,但是将其旧版本地址设置为一个定义了的删除标识.如表2中第4条记录和第5条记录所示,T4删除了一个数据库元素B,则为T4和B增加两条新的日志记录,并把后一条日志记录的历史版本的值设置为delete标识,旧值设为空.3.2事务提交日志在HV-recovery中,每当有事务提交,就在日志记录文件,也就是version_list中对该事务添加一个新的提交记录.具体来说,就是HV-recovery为每个事务设置了一个commit元素,当某个事务提交时,就为该事务增加一条日志记录,在这个日志记录中,将该事务的commit元素的地址置为空.如表2中第9条记录所示,当T1事务提交,日志管理器就对T1事务设置commit元素,并将该日志记录的旧版本地址字段设为空.注意,因为本文的日志记录必须满足规则B,也就是说,当事务提交日志记录到达二级存储器的时候,该事务所改变的所有数据库元素已经写到二级存储器上了.因此,此时数据库已经提交了该事务的所有更新操作.相反,如果事务提交日志记录未到达二级存储器,则在恢复时,不管这个事务的修改在数据库中完成了多少,这个事务所做的所有操作都将被还原,从而保证事务的原子性.另外,日志文件中存在的已经提交的日志记录会增加日志文件的长度,同时,会使得对日志文件的访问变成随机模式.但是,正如之前所介绍的,因为闪存设备的随机读和连续读的访问时间的差异不明Page5显,所以这些日志记录的存在对于其它事务的恢复效率的影响是非常微小的,几乎可以不必考虑.不过,这种日志记录长久保存是以大量的闪存存储空间为代价的,考虑到当前闪存存储设备的价格还不是很低廉,这会使得应用系统的成本价格提高,所以在第4节中,本文会提供一个进一步改进的方案.3.3恢复过程当系统发生崩溃或者事务需要进行回滚时,由于HV-recovery对日志记录和数据更新的提交顺序满足规则A和规则B,所以,只需要对在日志记录中体现为尚未提交的事务进行恢复.首先,像其它恢复方式一样,先读入在数据库的二级永久性存储器中需要恢复事务的日志记录.对于同一个事务修改的同一个数据项的所有记录,选择所有记录中的第一条记录.因为日志记录是顺序添加的.而一个事务对某一数据项不断地更改,就不断地在后面添加新的日志记录,这就保证了其第一次保存的历史版本的地址恰好就是在该事务修改之前的数据项的值.然后根据这些日志记录,恢复管理器读出需要恢复的各数据项的历史版本的地址,从纸质中取出其所存的数据,判断是否与日志记录中存的旧值相同,若相同,将已写入新更新数据内容的地址标识为无效,将原地址标识为有效,并将原地址赋给上层索引结构,从而完成恢复;若不同,则只有重新写入.4HV-recovery方法的改进为了进一步提高HV-recovery的性能表现,在本节中,针对HV-recovery中还存在的一些问题提供了一些改进的方法.4.1设立检查点为了减少数据文件和日志文件对存储空间的浪费,本文采取了一种周期性设立检查点的措施,来有效地提高空间利用率.4.1.1对于日志文件的操作首先,可以看出,HV-recovery中的日志记录的更新是非常频繁的,随着事务的不断进行,需要不断地向日志文件中添加新的日志记录,而随着事务的不断提交,又使得大量的日志记录变为无效.而在一般情况下,事务的回滚率通常不会太大,也就是说,其实在日志文件中存在着大量无效的日志记录,而这些日志记录的存在,增加了日志文件的长度,也占用了过多的闪存存储空间.因此,在检查点中采取一种最简单的转移操作,将日志文件中尚有效的日志记录进行转移并进行整合.也就是说,在设立的检查点中,先找到一个干净的块,然后逐条检查每条日志记录是否有效,在日志记录中选出尚有效的记录,写入到新的空闲块,当对某一旧日志块上的所有日志记录都检查过一遍后,就对该旧块进行擦除.通过之前的介绍,可以看出,实际需要转移的日志记录相对于大量的已经提交的事务的日志记录而言,其数量是相当小的,这样其转移的代价也是可以接受的.4.1.2对于数据文件的操作由于我们在闪存中采取异地更新,因此,为了显式地使用历史版本的数据,在实现时,在存储设备看来,我们将更新操作改为了插入,而删除操作只是记录了日志,并没有将历史数据删除,或标识为无效,这样虽然防止了我们将需要的历史版本的数据进行回收,但同时造成了系统中有过多的历史数据,存储空间大量浪费.因此,在检查点时,我们会在对日志记录进行扫描的同时,将无效的日志记录中显示为应该被删除或替代掉的数据标识为无效,以便让垃圾回收机制对空间进行回收管理,提高空间利用率.4.1.3检查点时间间隔设置检查点的间隔时间的确定,是与闪存中日志文件的大小以及闪存的总存储空间有关的.间隔时间太短会因为过多的擦除操作而浪费时间,并缩短闪存的寿命,而间隔时间过长又会浪费存储空间.因此,可以根据闪存的总存储空间设计固定的可接受的日志文件的大小.当到达某个阈值的时候就设立检查点开始进行转移操作.同时,类似于undo日志的检查点,不但可以设立静态的检查点,也可以设置动态的检查点.在检查点的开始阶段保存正在活跃的事务的ID,这样,就可以不必等到所有事务都提交完毕后,再设立检查点,对日志文件进行转移.并且也可以在数据库负载量较小的时候进行检查点的日志记录转移操作,从而进一步减少系统负担.4.2混合式存储系统另外,也可以看出,HV-recovery中对日志记录的主要操作就是一些小的追加写操作和一些擦除操作.而由之前对闪存的硬件特性的介绍可以得知,这些操作对于闪存而言是非常昂贵的.因此,可以看出,日志记录其本身的特点是不适用于闪存的.而一般来说,基于闪存的数据库是指将大量的对其操作较多的数据文件保存在闪存中,以利用其Page6优越的读写速度来提供更好的数据库性能.而当前的数据库一般都支持将日志文件和数据文件分开存储,因此,可以考虑在存储时使用混合式系统,如图2所示.将数据记录存放在闪存上,同时将并不是非常适用于闪存的日志记录存放在磁盘中.通过这样的设计,就可以在不增加系统恢复算法复杂度的同时,节约大量的日志记录所占用的闪存空间,为数据库系统服务.降低了数据库系统搭建的成本的同时,从整体上并没有影响数据库系统的性能表现.5实验结果及分析本章通过对HV-recovery在闪存上和磁盘上的实际对比实验,从恢复时的写操作数、恢复时间等方面来证明HV-recovery的优越性.5.1实验环境本文设计了两个实验平台,其中一个的存储设备配置了SSD,是80GB的IntelSSDSA2MH080G1GC,另一个配置的是磁盘,是250GB7200rpmST3250310AS,其中有8MB的缓存.除此之外,两个实验平台具有相同的配置,SSD和磁盘都是通过SATA接口接入.CPU是Intel(R)Core(TM)2DuoCPUE8300@2.83GHz,物理内存为2GB,操作系统是WindowsXPProfessional2002ServicePark2.5.2与相关工作的对比与分析之前的介绍中提到,IPL主要是给出一种新型的存储模式,以提供性能较高的对数据库的操作.它所提出的恢复技术主要是针对这种新的存储方式的一种扩展,因此,IPL不能像HV-recovery一样,方便地扩展到现有的大量数据库中.同时,IPL的存储方式是针对原始的闪存存储器的,而不是现在被简单广泛地应用在SSD上,因此,IPL具有相当大的局限性.同时,因为IPL的论文中并没有给出针对其恢复性能的实验结果,并且,其设计思想的实现必须在原始的闪存存储器上,而论文中也没有对其实现细节进行详细的阐述,这就对我们重现其工作带来了较大的困难,难以提供定量的对比结果.另外,FlashLogging给出在TPCC执行过程中突然崩溃需要扫描日志记录的时间,大约是基于磁盘的2/3左右,而HV-recovery的恢复时间是基于磁盘的1/8左右(在5.4中会详细阐述).当然,两种设计的实验环境和对比细节不完全相同,把实验结果直接进行比较不是很具有说服力.但是,由于FlashLogging要求搭建USB阵列,我们在短时间内较难重现,因此,我们在本文中难以给出直接的量化比较.但是,从单纯的恢复时间的比较,我们至少可以相信,HV-recovery的性能表现并不会比FlashLogging的表现差.5.3恢复时的写操作数TPC提供了一系列系统性能的压力测试标准,其中的TPCC通过规定数据库原始数据生成以及查询负载的相关指导标准来模拟了OLTP的处理场景,是数据库系统事务处理性能的标准测试集.TPCC规定了在OLTP中典型的5种事务,包括New-Order、Payment、Order-Status、Delivery以及Stock-Level,在下面的分析计算中,对这些事务类型分别简称为T1、T2、T3、T4、T5.并且,TPCC模拟实际情况,设定了这5种事务各自所占的比例,分别为45%、43%、4%、4%、4%,不妨将这些值用P1、P2、P3、P4、P5表示.TPCC还根据实际情形为每一种事务定义了一系列的插入、删除和更新操作,不妨把每种事务需要进行的操作数记为N1、N2、N3、N4、N5,如表3所示.New-OrderT1P1=45N1PaymentT2P2=43N2Order-StatusT3P3=4DeliveryT4P4=4Stock-LevelT5P5=4TPCC模拟了大量用户同时对系统进行并发访问的模式,此处设存在的用户并发数为Nuser.同时,容易理解,在任一时刻,正在并发执行的事务都完成了其中的一部分,也就是说,每个事务都有一个自己Page7的完成率,它是一个从0~100%之间的一个随机数,记为C.因此,可以知道,对一次有Nuser个并发的TPCC测试而言,任一时刻系统发生崩溃,其需要恢复的数据量Nrecovery为其中保证对每一种事务的相互比例满足TPCC的要求,也就是说,T1T2T3T4T5=P1P2P3P4P5.通过之前的介绍可以看出,在恢复过程中,对于每一个需要进行恢复的数据项,HV-recovery都可以比传统的恢复方式减少一次写操作,也就是说,HV-recovery只需要2Nrecovery个写操作和Nrecovery个读操作就可以完成恢复,而传统的恢复方式至少需要3Nrecovery个写操作.实验结果如图3(a)、(b)所示,可以发现,随着并发用户数的不断增加,与传统的undo日志相比,在数据库恢复阶段,HV-recovery可以大量地减少写操作.一般而言,在并发用户数从100增加到10000时,HV-recovery可以减少大约有400~37000次写操作.在减少写操作的同时,也节约了大量的闪存空间,提高了闪存的空间利用率.同时,因为写操作的时间代价比较大,从理论上分析,HV-recovery可以在恢复时节省大量的时间.因此,我们将HV-recovery实现到现有的数据库中,用实验结果来验证其可以节省大量的恢复时间.5.4在BerkeleyDB中实现HV-recovery为了方便地将HV-recovery在现有的数据库中进行实现,本文选择的是开源的OracleBerkeleyDB数据库,编程语言为C语言,编译环境是MicrosoftVisualStudio2005,硬件环境如5.1节所述.在实验中,在开始后不断地对数据库中的内容进行各种操作,然后,再显式地对事务回滚,即进行恢复操作,并记录恢复所耗费的时间,其结果如图4所示.由实验结果可以看出,HV-recovery相比于传统的基于磁盘的数据库有明显的优越性.能够大幅度的减少恢复时间.并且随着数据量的不断增加,这种优越性也越来越明显.在较小的数据量时,如图4(a)所示,使用传统数据库恢复技术所用的恢复时间平均是使用HV-recovery进行恢复的2~3倍,而数据量不断增大时,HV-recovery的优势也成倍增加.如图4(b)所示,最好情况下,基于磁盘上的传统数据库的恢复时间是HV-recovery恢复时间的8.3倍,充分体现了HV-recovery的优越性.而且,与将传统的数据库直接移到SSD上的情况相比,HV-recovery也体现了较大的优势.一般而言,在SSD上,HV-recovery要比BerkeleyDB中传统的undo日志的方法要提高20%,而随着数据量的增大,这种优势也体现的更为明显,如图4(b)所示,某些情况下,HV-recovery要比BerkeleyDB中Page8传统的undo日志的方法要提高38%,能很好地体现HV-recovery的优越性.6结论闪存即将取代磁盘成为下一代主流的二级存储器,但由于其特有的物理特性,目前基于磁盘设计的恢复技术不能充分地利用闪存的优越性.为此,本文提出了一种新颖的具有较高性能的恢复方式HV-recovery.HV-recovery对闪存中天然存在的数据的历史版本使用version_list结构加以管理和利用,提供高效的恢复.通过周期性设立检查点,减小无效日志记录的长度,节约闪存空间.引入混合式存储系统,将日志记录单独存放在磁盘上,以便对闪存数据库的恢复性能进一步提高.同时也保证了算法具有在数据库正常运行时有较小的开支、算法有比较强的可靠性、系统失败后恢复速度快和日志文件的空间需求较小等优势.通过针对TPCC的分析及和开源数据库OracleBerkeleyDB的对比实验看出,HV-recovery比传统数据库的恢复时的写操作数可以减少接近一半,其恢复时间与传统数据库相比,能缩短到原来的大约1/8,与在SSD上的传统数据库相比,也可以缩短40%,充分显示了本算法的优越性.
