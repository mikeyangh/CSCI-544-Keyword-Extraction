Page1基于RSA的网关口令认证密钥交换协议魏福山马传贵程庆丰(解放军信息工程大学信息工程学院信息研究系郑州450002)摘要网关口令认证密钥交换协议是一个三方协议,使得用户和网关在服务器的协助下建立起一个安全的会话密钥,从而实现用户和网关之间的安全通信.已有的网关口令认证密钥交换协议都是基于Diffie-Hellman密钥交换设计的.利用张木想所设计的PEKEP协议,提出了基于RSA体制的可证明安全的网关口令认证密钥交换协议.在随机预言模型下,基于RSA假设证明了协议的安全性.该协议可以抵抗e次剩余攻击和不可检测在线字典攻击.关键词RSA;口令认证;网关;随机预言模型;e次剩余攻击1引言1.1口令认证密钥交换协议口令认证密钥交换协议(简称PAKE协议)允许用户通过一个低熵、人脑可记忆的口令安全地建立一个共享的会话密钥,从而实现在不安全的公开网络上的安全通信.由于口令的低熵性,口令协议容易遭受字典攻击[1].1992年,Bellovin和Merritt提Page21997年,Lucks提出了基于RSA体制的公开密钥交换协议(OKE)[10].后来MacKenzie等学者发现该协议不能抵抗e次剩余攻击的一种变型[11],并且对OKE协议进行了改进,提出了第一个安全的基于RSA的口令协议SNAPI.由于SNAPI协议要求RSA的加密指数是一个比模数还要大的素数,因此不够实用.2004年,张木想对SNAPI协议进行了改进,提出了PEKEP和CEKEP协议[12],允许用户选取一般的素数做为加密指数.但为了抵抗e次剩余攻击,PEKEP协议需要服务器进行多次RSA加密,因此效率不高.2007年,Park等学者利用数论技巧提出了可以抵抗e次剩余攻击的高效的RSA-EPAKE协议[13].但是在2008年,Youn等学者指出RSA-EPAKE协议不能抵抗一种分离攻击[14].尽管该攻击可以通过限制敌手失败猜测的次数来避免,但敌手通过一次攻击就可以获得口令的很多信息,因此分离攻击对RSA-EPAKE协议依然具有很大的威胁.1.2相关工作在实际应用中,服务器实际上是由两个独立的实体组成的:一个是前端与用户直接交互的网关,另外一个是后端验证用户身份的服务器.为了刻画这种实际的情况,Abdalla等学者在2005年提出了网关口令认证密钥交换(GPAKE)协议的概念[4].GPAKE协议使得用户和网关在服务器的协助下建立一个认证的会话密钥.服务器和用户之间共享一个用于认证的口令,但是会话密钥是在网关和用户之间建立的.用户将加密过的消息发送给网关,网关直接将消息转发给服务器,由服务器来判断用户是否合法.Abdalla等学者除了考虑会话密钥的语义安全性外,还额外考虑了两个安全目标:针对服务器的密钥私密性和针对网关的口令保护.针对服务器的密钥私密性要求一个诚实而好奇的服务器在知道所有用户口令的条件下依旧不能将会话密钥和一个随机数区分开,而针对网关的口令保护要求网关通过执行协议不能获得用户口令的任何信息.2006年,Byun等学者发现Abdalla所设计的GPAKE协议不能抵抗一种不可检测在线字典攻击[8].一个恶意的网关可以重复对用户的口令进行在线的猜测,而服务器检测不到这种恶意的攻击.他们提出了一个改进的协议,要求用户和服务器在执行GPAKE协议之前运行一次两方的PAKE协议,建立一个用于消息认证的共享密钥,并且要求用户发送给服务器的消息增加消息认证码(MAC).但是在2008年,Shim发现Byun等人改进的协议实际上依旧不能抵抗该攻击,并且采用对称加密的方式来隐藏口令的信息,提出了新的S-HPAKE协议[15].2010年,Yoon等学者指出S-HPAKE实际上存在设计上的错误并且效率较低[16].另外,Abdalla等学者在2008年通过对原始的GPAKE协议进行改进提出了一个匿名的GPAKE协议[6].他们还提出了一个更强的安全模型,将3个安全目标用一个安全游戏来刻画,该模型还允许对参与者进行腐化.他们在新的安全模型下证明了匿名的GPAKE协议的安全性.由于要实现匿名性,因此该协议依然不能抵抗不可检测字典攻击.1.3我们的工作在本文中,我们考虑如何基于RSA体制设计高效的GPAKE协议.综合效率和安全性进行考虑,最好的出发点可能是利用张木想的PEKEP协议[12]来设计基于RSA体制的GPAKE协议.虽然Park等学者的RSA-EPAKE[13]比PEKEP协议效率更高,但是不能抵抗分离攻击[14],安全性不足.在我们的协议中,服务器和用户依旧共享一个口令,用户和网关分别选取自己的RSA参数(包括模数和公私钥).但是需要说明的是,用户和网关的RSA公私钥完全是由自己选取的,不需要CA中心颁发公钥证书,因此避免了在线的证书验证.我们的协议可以抵抗e次剩余攻击,并且基于RSA假设在随机预言模型下可证明安全.为了实现GPAKE协议的3个安全目标,在我们的协议中,认证和会话密钥采用不同的随机数.通过这种方式,用户和服务器之间的认证不会泄露口令的信息给网关,而服务器也不会得到用户和网关之间建立的会话密钥的任何信息.另外,我们的协议可以利用RSA的门限体制来实现门限的GPAKE协议.需要指出的是我们的协议不需要任何的公开参数,用户和服务器只需要共享一个口令,不需要建立其它的公共参数,比如一个大素数p和模p的循环群的一个生成元g.在参与者没有足够的资源产生或者验证公共参数的一些性质(比如素性检测)的环境下,我们的协议非常具有吸引力.在第2节我们回顾GPAKE协议的安全模型和通信模型;在第3节介绍我们的协议并且利用RSA假设在随机预言模型下证明协议的安全性;在第4节我们对全文进行总结.Page32安全模型2.1概述网关口令认证密钥交换(GPAKE)协议允许一个用户和网关在服务器的帮助下建立一个认证的会话密钥,认证通过低熵的口令来实现,并且口令是用户和服务器共享的,网关不知道口令的信息.一般假设用户和网关之间的通信信道是不安全的并且由敌手控制,而网关和服务器之间的通信则存在安全通道.GPAKE协议的主要安全目标是为用户和网关建立一个安全的会话密钥,并且不泄漏用户口令的任何信息给网关.为此定义了3个安全目标来分别来刻画用户、服务器和网关的不诚实行为:会话密钥的语义安全性,通过“Real-Or-Random”(ROR)攻击游戏来模型化[5];密钥私密性[5],要求在服务器协助下为用户和网关建立的会话密钥对服务器来说仍然是不可区分的;口令保护[4],指网关不能从服务器那里得到用户口令的任何信息.协议的参与者.GPAKE协议的参与者包括用户C∈、网关G∈和服务器S∈.我们用集合表示所有参与者的集合,即=∪∪,用U表示中的一个任意的参与者.长期密钥.每个用户C∈持有口令pwC∈,其中是口令空间.每个服务器S∈持有一个口令列表pwS=〈pwC〉C∈,每个用户的口令都是列表中的一条记录.pwC和pwS分别被称为用户和服务器的长期密钥.2.2安全模型敌手的攻击能力通过预言询问来模型化.在协议的执行过程中,敌手可以产生同一个参与者的多个并发运行的实例.用Ui表示用户U的第i个实例.敌手可以进行的预言询问有:Execute(Ci,Gj).这个询问模型化被动攻击,敌手被动地窃听用户和网关之间的协议运行.对这个询问的回答是一次协议的诚实执行过程中用户和网关之间交换的所有消息.Send(Ui,m).这个询问模型化对用户或者网关实例Ui的主动攻击,敌手首先截获一条消息,对消息进行篡改、产生一条新的消息或者简单的将消息进行转发.对这个询问的回答是参与者实例Ui接受到消息m返回的消息.在ROR模型中,除了上述的预言询问外,敌手还可以进行Test询问.假设b是在攻击游戏进行之前随机选择的一个比特,ROR模型中的Test询问如下定义:Test(Ui).这个询问不模型化敌手实际的攻击能力,只是为了度量实例Ui所持有的会话密钥的语义安全性.如果实例Ui的会话密钥没有定义,那么返回一个未定义的标记⊥.如果实例Ui会话密钥已经生成,b=1则返回给敌手真实的会话密钥,b=0则返回给敌手一个与密钥等长的随机比特串.其中b是攻击游戏进行前所选择的随机比特.在ROR模型中,Test询问用于刻画敌手区分会话密钥和随机值的能力.敌手可以对多个实例进行Test询问,所有的Test询问的回答都由随机选择的比特b来决定.即所有Test询问的回答或者都是真实的会话密钥,或者都是随机选择的比特串.需要注意的是,在返回随机值的情况下,如果敌手对同一个会话中的两个实例进行Test询问,返回的随机值也是相同的.敌手在ROR模型下的目标是猜测Test询问中使用的随机比特b的值,如果敌手猜测正确则称敌手成功.2.3安全定义匹配会话.我们通过会话标识和伙伴标识来定义匹配会话.一般定义会话标识为协议执行结束后所有消息的级联.两个实例如果拥有相同的非空会话标识则称为是匹配会话.具体地,一个用户实例Ci和一个网关实例Gj被称为匹配会话,如果以下条件满足:(1)Ci和Gj都接受;(2)Ci和Gj拥有相同的会话标识;(3)Ci的伙伴标识是Gj,反之亦然;(4)除了Ci和Gj外,没有接受的实例的伙伴标识是Ci或Gj.新鲜性.新鲜性用来刻画一个敌手不能平凡获得的会话密钥.敌手只能对新鲜的会话密钥进行Test询问.在协议的执行中,一个用户实例或者网关实例如果接受了,则称该实例是新鲜的.会话密钥的语义安全性.考虑协议的运行,其中敌手可以进行所有的预言询问.敌手的目标是猜测Test询问中所使用的随机比特b的值.用Succ表示敌手正确猜测b这一事件.在ROR模型下,敌手破坏认证密钥交换协议的会话密钥的语义安全性的优势定义为Advake-rorPr[Succ]-1.相应的,定义协议的优势函数为Advake-ror值是从所有运行时间复杂度为t,使用资源为R(如预言询问的次数)的敌手优势中选取.一个GPAKE协议称为是语义安全的,如果对任意的概率多项,(t,R)=max{Advake-rorPage4式敌手,的优势Advake-ror个可忽略的量,其中n是敌手主动攻击的次数,||是口令空间的规模,k是一个常数.一般k=1是最好的结果,因为一个敌手通过简单的在线字典攻击每次也可以排除一个口令.密钥私密性.密钥私密性的概念最早在文献[5]中提出,是指两个参与者在服务器的协助下生成的会话密钥只有两个参与者知道,服务器不知道该会话密钥的任何信息,主要思想是为了降低对服务器的信任.考虑一个获得服务器中储存的所有秘密信息的敌手,如果依旧不能区分真实的会话密钥和随机数,那么则称协议满足密钥私密性.但是由于知道所有用户的口令,因此要求不能进行主动攻击.在文献[5]中,Abdalla定义了一种新的预言询问TestPair来刻画密钥私密性,TestPair的输入为两个参与者的实例,输出为两个参与者实例共享的会话密钥或者一个随机值.考虑协议的运行,其中敌手拥有服务器储存的所有秘密信息,并且可以进行Execute和TestPair询问.用Succ表示敌手正确区分会话密钥这一事件,类似地我们可以定义敌手破坏密钥私密性的优势Advake-kpPr[Succ]-1和协议的优势函数Advake-kp口令保护.GPAKE协议要求网关不能得到服务器中储存的用户口令的任何信息.如果一个恶意的网关与服务器进行q次交互,那么要求恶意网关区分口令和随机值的概率至多为kn/||.k=1是最好的结果,因为一个恶意网关通过简单的在线字典攻击每次也可以排除一个口令.但是上述的安全要求并没有排除恶意网关进行不可检测在线字典攻击的可能性.一个恶意的网关仍然可以反复对用户的口令进行在线字典攻击,而服务器无法察觉.为了抵抗恶意网关的不可检测在线字典攻击,我们考虑一个恶意的网关,首先对用户的口令进行猜测,然后通过与服务器执行协议来验证其猜测是否正确.如果猜测正确,或者猜测错误,但是服务器无法检测到,那么我们称敌手成功.用Advake-uoda来表示敌手成功的概率.我们称GPAKE协议能够抵抗不可检测在线字典攻击,如果Advake-uoda只比kn/||大一个可忽略的量.3基于RSA的GPAKE协议3.1协议描述我们所设计的基于RSA的GPAKE协议是利用张木想所设计的两方PAKE协议PEKEP构造的[12].定义杂凑函数H1,H2,H3:{0,1}→{0,1}k和H:{0,1}→Zn,其中k是安全参数,比如k=160.我们假设H1,H2,H3和H是相互独立的函数.协议的参与者有用户、网关和服务器,具体的描述见图1.在初始化阶段,用户和服务器共享一个从口令空间均匀选择的低熵口令pw.用户产生RSA密钥n,e和d,其中n是两个同等规模的大素数的乘积,e是一个与(n)互素的奇素数,d是一个满足ed≡1mod(n)整数,其中()是欧拉函数.定义加密函数E(x)=xemodn,其中x∈Zn.相应地,定义解密函数D(x)=xdmodn,其中x∈Zn.对于一个正整数m,定义Em(x)=E(Em-1(x))=xemmodn,类似的可以定义Dm(x)=D(Dm-1(x))=xdmmodn.网关也产生RSA密钥n,e和d,其中n是两个同等规模的大素数的乘积,e是与(n)互素的正整数,d是一个满足ed≡1mod(n)整数.注意我们只要求用户的加密密钥e是奇素数,这是为了抵抗基于RSA的PAKE协议中的e次剩余攻击,由于网关的加密密钥与口令无关,因此对网关的加密密钥e没有这个要求.我们假设网关和服务器之间存在认证的安全通道.协议的步骤如下:1.用户C选择一个随机数r1∈{0,1}k,并且将其加密公钥(n,e)以及r1发送给网关G.网关接受到消息后,将消息连同自己的加密公钥(n,e)转发给服务器S.2.服务器接收到网关的消息后,首先检查e是否是一个奇素数以及n是否是奇数,另外还需要验证n是否足够大,比如n>21023.如果验证不通过,则服务器拒绝;验证通过,则服务器首先计算一个整数m=logne,选择两个随机数a∈Zn和r2∈{0,1}k.然后服务器计算α=H(pw,r1,r2,C,G,n,e,n,e)并且检查是否有gcd(α,n)=1,如果gcd(α,n)≠1则拒绝接受,否则服务器计算z=Em(αE(a)).最后服务器发送(r2,z)给网关,网关发送(n,e,r2,z)给用户.3.接收到网关发送的消息后,用户检查n是否是足够大的奇数.如果不是则拒绝;否则用户随机选择b1∈Zn.然后用户计算α=H(pw,r1,r2,C,G,n,e,n,e)并且验证是否有gcd(α,n)=1,如果gcd(α,n)≠1则拒绝接受,否则用户解密z得到a=D(α-1Dm(z)),对b1用网关的公钥进行加密得到c1=bee,r1,r2,z,c1)并且发送(c1,μ)给网关.网关接受到消息后,随机选择b2∈Zn,利用用户的公钥加密后得到c2=be2modn,发送(c1,c2,μ)给服务器.4.服务器接收到(c1,c2,μ)后,首先检查μ是否有效.如果无效则拒绝,否则计算η=H2(a,C,G,n,e,n,e,r1,r2,z,c1,c2),并且发送η给网关.Page55.网关接受到η后,首先利用自己的私钥解密c1得到1modn,计算会话密钥sk=H3(b1,b2,ID)并且接受会b1=cd话,其中ID是用户和网关之间交互的所有消息的级联.最后网关发送(η,c2)给用户.6.用户接收到(η,c2)后首先检查η是否有效.如果无效则拒绝,否则利用其私钥解密c2得到b2=cd2modn.最后用户计算会话密钥sk=H3(b1,b2,ID)并接受.在基于RSA的口令认证密钥交换协议里,需要考虑协议是否能抵抗e次剩余攻击[3].在我们的协议中,为了抵抗e次剩余攻击,我们采用文献[12]的方法,要求服务器使用用户的公钥(n,e)进行m+1次RSA加密,其中m=logne.在计算效率方面,服务器需要进行m+1次RSA加密,因此计算负担较大.但是注意到由于用户自己产生其公钥(n,e),因此知道(n),为了对z解密得到a,只需要进行两次RSA解密,另外为了生成会话密钥还需要分别执行一次RSA加密和解密,因此用户共需要进行一次RSA加密和三次RSA解密.网关需要执行一次RSA加密和解密.从计算效率来说,我们的协议在用户端和网关端的计算效率较高.由于GPAKE协议适用于无线环境,而在无线环境中,终端的计算能力较低,服务器计算能力较强,因此我们的协议符合实际的需求.另外从通信效率来考虑,用户和网关需要进行四轮交互,这是目前基于RSA的口令协议所能达到的最少轮数.3.2安全性分析在本节,我们利用第2节介绍的安全模型来证明我们协议的安全性.在我们的证明中,主要用到RSA困难性假设.下面首先介绍RSA假设[13].RSA假设.设l是安全参数,设GE为RSA密钥生成函数,即运行GE有(e,d,n)←GE(1l),其中n是两个相同规模的大素数的乘积,gcd(e,(n))=1并且有ed=1mod(n).对于任意运行时间至多为t的概率多项式时间算法,概率Advrsacmodn:(e,d,n)←GE(1l),c∈R{0,1}l,x←(c,e,n)]是可忽略的.下面,我们用Advrsa(t)来表示max{Advrsa间为t的概率多项式时间算法中选取.语义安全性.定理1表明在RSA假设下,我们的协议满足会话密钥的语义安全性.在证明中我们假设口令空间是均匀分布的,并且规模要远小于2k,其中k为安全参数.定理1的证明参见附录1.定理1.设是一个运行时间为t,询问了QSend次Send询问的敌手.那么敌手破坏协议的语义安全性的优势至多为Advake-ror2QSend其中QExecute表示敌手询问Execute的次数,Qoh表示随机预言的询问次数.密钥私密性.定理2表明在RSA假设下,我们的协议实现了针对服务器的密钥私密性的目标.需要说明的是,在证明密钥私密性的时候,由于假设敌手是诚实且好奇的,我们不允许敌手询问Send预言.定理2的证明与附录1中引理1的证明类似,唯一的区别在于敌手知道所有用户的口令,但是由于我们在认证和会话密钥的产生中采用不同的随机数,因此知道口令不会对区分会话密钥有任何帮助.为了区分会话密钥和随机数,敌手仍然需要破解RSA问题.为了简便起见,我们略去对定理2的证明.定理2.设是一个运行时间为t,询问了QExecute次Execute询问的敌手.那么敌手破坏协议的密钥私密性的优势至多为Advake-kpPage6QExecuteAdvrsa(O(t)).口令保护.针对网关的口令保护可以直接利用PEKEP协议[12]的证明得到.容易看出,如果我们把n,e,c1和c2视为随机数,则网关和服务器的交互实际上就是一次PEKEP协议的执行.由PEKEP协议的证明可知,恶意网关每次和服务器进行交互至多排除掉一个口令.q次交互后,恶意网关的优势至多是q||加上一个可忽略的量,并且由下面的定理可知一次失败的猜测将被服务器检测到.恶意网关不能再反复猜测口令并且在服务器端进行验证,因此我们的协议可以抵抗不可检测在线字典攻击.定理3.设是一个运行时间为t,询问了QSend次Send询问的恶意网关.那么恶意网关对协议进行不可检测在线字典攻击的优势至多为4总结本文研究如何利用RSA体制设计高效的GPAKE协议.利用张木想设计的PEKEP协议,我们设计了一个基于RSA的GPAKE协议.我们的协议可以抵抗e次剩余攻击,并且基于RSA假设在随机预言模型下证明了协议的安全性.另外我们的协议还可以抵抗不可检测在线字典攻击,而已有的GPAKE协议都不能抵抗此攻击,因此我们的协议具有更强的安全性.
