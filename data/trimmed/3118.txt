Page1带权无向图中反馈顶点集的固定参数枚举算法王建新江国红陈建二(中南大学信息科学与工程学院长沙410083)摘要反馈顶点集(FVS)问题是一个经典的NP-完全问题,在很多领域有重要的应用.人们对该问题进行了大量的研究,但目前还没有有效的算法枚举带权无向图的反馈顶点集.文中通过对带权无向图中反馈顶点集问题的结构的深入分析,给出了一个有效的基于分支搜索技术的固定参数枚举算法.算法将反馈顶点集问题转化为反馈边集问题,通过枚举z个权值最大的森林来枚举z个权值最小的含k条边的反馈边集,从而得到z个权值最小的含k个顶点的反馈顶点集,算法时间复杂度为O(5kn2(logn+k)+3kz(n2logn+z)).关键词反馈顶点集;无向图;带权;参数;固定参数枚举1引言图G的一个反馈顶点集(FeedbackVertexSet,FVS)是一个由G中一些顶点构成的集合,从图GPage2带权图为找顶点数最少的FVS)问题是一个经典的NP-完全问题[1].FVS问题在电路测试、操作系统的解死锁、分析工艺流程和生物计算等领域都有应用[2].FVS问题最初在组合电路设计中被阐述.在组合电路中,为了避免紊乱情况的发生,在电路中的每条环路上放置一个寄存器.需要放置寄存器的节点数越少,总延迟就越短,寻求延迟最短的放置寄存器方案就等价于在对应的电路图中找含定点数最少的FVS问题.另外,FVS问题在生物信息计算领域基因组装问题中有着重要的应用.由于FVS问题是NP难的,除非NP=P,否则FVS问题是不可能有多项式时间算法的,因此人们首先从近似算法的角度展开了对FVS问题的研究.Bar-Yehuda等提出了对不带权FVS近似度为4和对带权FVS近似度为min(2Δ2,4logn)的多项式时间可解的近似算法,其中Δ为图G中顶点的最大度数[3].在此基础上,Bafna等提出了对不带权FVS近似度为2的近似算法[4]和带权FVS近似度为2-2/(2Δ-2)的基于“局部近似”的近似算法[5].由于近似算法的结果不够精确,往往不能满足需求,人们开展了FVS的精确算法的研究.对不带权FVS,Razgon等用分枝-剪枝策略(Branch-Prune)提出了时间复杂度为O(1.8899n)的精确算法[6],其中n是图G中顶点的数目.在此基础上,Fomin等利用加权分支技术提出了时间复杂度为O(1.7548n)的精确算法[7].在实际应用中,n的数目往往比较大,这些算法无法应用于实际.但人们发现在很多实际应用中,FVS的大小k(FVS中所含顶点的个数)比较小,于是人们将FVS问题参数化.不带权FVS问题的参数化定义[8]如下.定义1.给定含有n个顶点的图G和非负整数k,能否在图G中找到一个不大于k的FVS.人们对不带权FVS的参数化问题进行了大量的研究.Downey与Fellows[8]、Bodlaender[9]最早证明了不带权无向图中FVS问题是FPT(Fixed-ParameterTractable,即在时间f(k)nO(1)内可解,其中f(k)是仅关于k的一个函数[8])的.对于不带权无向图中FVS问题:文献[10]给出了时间复杂度为O((2k+1)kn2)的确定性算法;Raman等对短圈(长度短的圈)上的点进行分支,给出了时间复杂度为O(max{12k,(4logk)k}nω)(nω是求两个n×n矩阵的乘积的时间)的算法[11];文献[12]应用极值图理论得到时间复杂度为O((2logk+2loglogk+18)kn2)的算法;基于结论:当图中顶点度数至少为3且存在一个大小不超过n1-ε/3的FVS,那么图中最短圈的长度最大为6/ε(ε1/2),文献[13]利用分支技术提出了时间复杂度为O((12logk/loglogk+6)knω)的确定性算法;文献[14]和文献[15]利用迭代压缩技术,通过对FVS问题的结构进行分析,分别提出了时间复杂度为O((37.7)kn2)和O((10.567)kn3)的确定性算法;Chen等利用分支搜索和迭代压缩技术,通过分析问题分支后的隐含特性,提出了时间复杂度为O(5kkn2)的确定性算法[16],这是目前无向图中FVS问题的FPT算法的最好结果.对于有向图,文献[17]证明了不带权有向图的FVS问题是FPT的,通过将有向图FVS问题转化为受限制的Multicut问题提出一个时间复杂度为O(4kk!nO(1))的FPT算法.Chen等在文献[16]中给出了带权FVS问题的参数化定义,具体如下.定义2.给定含有n个顶点的带权图G和整数k,能否在图G中找到一个权值最小的不大于k的FVS.Becker等对带权无向图中FVS问题提出了时间复杂度为O(6kkn2)且概率为1-(1-1/6k)c6k的随机算法[18].对带权无向图中FVS问题,Chen等首次证明了该问题是FPT的,并提出了一个时间复杂度为O(5kkn2)的确定性FPT算法[16].带权有向图中FVS问题是否存在FPT算法仍然是一个开放性研究课题.在实际应用中,我们经常遇到枚举与计数两类问题,在参数计算领域人们提出了参数化的枚举和计数问题[19-20].文献[20]给出了一个时间复杂度为O(2kk2+kn)的算法枚举所有大小为k的点覆盖,其中k等于最小点覆盖的大小.很多实际应用并不需要找问题所有的解,而只需要一定数目的最优解.固定参数枚举算法的研究已经引起参数计算研究领域学者的关注.文献[21]首次给出了固定参数可枚举的概念,即对于一个NP问题,若存在一个算法能够在f(k)nO(1)zO(1)的时间内(其中f(k)是关于k的一个函数)找出该问题的z个大小为k的最优解,则称该问题是固定参数可枚举的.文献[21]给出了VertexCover、Path以及平面图中DomnatingSet的固定参数枚举算法,所用技术分别为分支搜索、彩色编码和树分解.枚举多个最优的FVS在实际应用中很有意义,尤其是在操作系统的解死锁的应用中.下面给出无向图中FVS的固定参数枚举问题的定义.定义3(FVS的固定参数枚举).给定一个带权无向图G和两个非负整数k,z,要求找出图G中Page3z个权值最小的k-FVS,即假设所有的k-FVS按权值非降序排列,取排在前面的z个k-FVS,其中k-FVS为含有k个点的FVS.目前还没有FVS的固定参数枚举算法,本文对带权无向图的FVS问题提出一种有效的基于分支搜索技术的固定参数枚举算法.本文首先求出给定图G的一个k-FVS-F,然后穷举F的所有子集F1,由F1构造图G的一种结构划分,对结构划分利用分支搜索技术得到一系列元组,各元组为分支搜索树上各叶子节点所表示的状态结构.再对元组表示的状态结构进行分析,将FVS问题转化为反馈边集(FeedbackEdgeSet,FES,由G中一些边构成的集合,从图G中删除FES中的边将使得图G不含圈)问题,最后通过枚举z个权值最大森林来枚举z个权值最小的FES.整个算法的时间复杂度为O(5kn2(logn+k)+3kz(n2logn+z)).本文第2节给出相关定义和引理;第3节给出FVS的固定参数枚举子过程;第4节给出FVS的固定参数枚举算法;第5节是本文的结论.2相关定义和引理G=(V,E)为一个含有n个顶点的图,V是G的顶点集,E是边集.设WV,设G[W]=(W,EW)为由顶点子集W导出的图G的子图,其中边集合EW={(u,v)|u,v∈W且(u,v)∈E}.设v是图G中一个顶点,G\v表示从图G中删除v点以及以v为端点的边之后得到的新图,V\v表示从顶点集V中删除v.为了更好地描述FVS的固定参数枚举算法,首先给出以下定义.定义4(IF-划分)[16].给定一个图G=(V,E),称三元组(V0,V1,V2)是图G的独立集-森林划分(Independent-ForestPartition,简称IF-划分),其中(V0,V1,V2)满足如下条件:(1)V0∪V1∪V2=V,并且V0,V1和V2互不相交;(2)G[V1]和G[V2]都是森林;(3)V0是独立集,V0中的每个点在图G中都是2度点,且其邻居都在V2中.定义5(IF-划分FVS).给定图G、图G的IF-划分(V0,V1,V2)和非负整数k,IF-划分FVSF是图G的FVS,并且满足FV0∪V1,|F|k.定义6.给定一个图G和图G的IF-划分(V0,V1,V2),IF-划分(V0,V1,V2)的压缩图是一个新图H=(VH,EH),其中VH中每个点对应图G[V2]中的一个连通块,EH中每条边(u,v)对应V0中的一个点w,且w的两个邻居分别在点u和v对应的G[V2]的连通块中.IF-划分(V0,V1,V2)的压缩图H可由以下方法得出:首先将G[V2]中的每个连通块压缩为一个点作为压缩图H的顶点.对于V0中任意一个点w,若w的两个邻居分别在图H的顶点u和v对应的G[V2]的连通块中,则在图H的顶点u和v之间连接一条边.因为V0中的点都是2度点,所以V0中的点和H中的边一一对应.图H中的连通块和图G[V0∪V2]中的连通块也一一对应.如果图G是顶点带权图,给H中每条边赋予一个权值,边的权值等于边所对应的V0中点的权值,这样图H是一个边带权的图.设τ(k,V0,V1,V2)=k-(|V0|-#c(V2)+1),φ(k,V0,V1,V2)=k-(|V0|-#c(V2)+#c(V0∪V2)),其中#c(V2)和#c(V0∪V2)分别是图G[V2]和图G[V0∪V2]中连通块的数目.设IF-划分(V0,V1,V2)的压缩图为H,由压缩图定义可知,压缩图H的任意一个不大于k的FES中的边所对应的V0中的点集合都是图G[V0∪V2]的FVS.设H的最大生成树或最大生成森林为T(由压缩图的每个连通块的生成树构成的森林为生成森林),不在T中的边集为H的权值最小的FES,也是所含边数最少的FES,FES中边对应的V0中点的集合就是图G[V0∪V2]的权值最小的含顶点数最少的FVS.由于H中有#c(V2)个点,H的连通块数等于G[V0∪V2]中的连通块数#c(V0∪V2),则T中含有#c(V2)-#c(V0∪V2)条边,那么H的FES至少含|V0|-#c(V2)+#c(V0∪V2)条边,即至少要删除|V0|-#c(V2)+#c(V0∪V2)个V0中的点才能使得图G[V0∪V2]不含圈,同样说明图G的IF-划分FVS中至少包含|V0|-#c(V2)+#c(V0∪V2)个V0中的点,则IF-划分FVS中最多包含φ(k,V0,V1,V2)个V1中的点.可见,τ(k,V0,V1,V2)和φ(k,V0,V1,V2)是IF-划分FVS中包含V1中点数目的上界.令C(G)表示图G是否含有圈,若图G含有圈,则C(G)=1,否则C(G)=0.结合以上分析,得出以下引理.引理1.给定图G的一个IF-划分(V0,V1,V2)和参数k.如果(V1=andφ(k,V0,V1,V2)>0)orV2=or(φ(k,V0,V1,V2)=0andC(G[V1∪V2])=0),则求图G中IF-划分(V0,V1,V2)FVS问题可以转化为求IF-划分的压缩图H中不大于kPage4的FES问题;如果(φ(k,V0,V1,V2)=0andC(G[V1∪V2])=1)orφ(k,V0,V1,V2)<0,则找不到图G中IF-划分(V0,V1,V2)FVS.证明.如果V1=,则G=G[V0∪V2],则求G的IF-划分FVS问题转化为求IF-划分的压缩图H的FES问题.压缩图H的任意一个不大于k的FES中的边所对应的V0中的点集合都是IF-划分FVS.如果V2=,V0也必然等于,那么图G=G[V1],其压缩图为空图,V1的任意一个子集都是图G的FVS.当φ(k,V0,V1,V2)=0时,图G的IF-划分FVS中的k个点必须属于V0.此时,如果C(G[V1∪V2])=0,且V1和V2不为空集,则把V1中的点移到V2后构成的元组(V0,,V2∪V1)是一个有效的IF-划分,基于此划分同样求得原划分的FVS.如果C(G[V1∪V2])=1,则找不到IF-划分FVS.如果φ(k,V0,V1,V2)<0,要删除多于k个点使得图G[V0∪V2]不含圈,那么图G不存在IF-划分FVS.由此证明了此引理.下面给出文献[16]中关于FVS问题的重要引理.引理2[16].给定含n个点的图G,可以在O(5kkn2)时间内找到一个不大于k的FVS或者证明图G不存在不大于k的FVS.3FVS的固定参数枚举子过程带权无向图的固定参数枚举过程简述如下:首犆狅狀狊狋狉狌犮狋犌狉狅狌狆(犌,犞0,犞1,犞2,犽,犉,犃,犛)输入:图G=(V,E)和图G的一个IF-划分(V0,V1,V2),整数k,F=A=S=输出:一个集合R,R收集了一系列元组r=(G,V0,V1,V2,F,A,S),其中,A是算法中产生的度数不大于1的点的集合,F是必须放1.R=;2.if(V1=andφ(k,V0,V1,V2)>0)or(V2=)or(φ(k,V0,V1,V2)=0andC(G[V1∪V2])=0),将元组r=(G,V0,V1,V2,F,3.if(φ(k,V0,V1,V2)<0)or(φ(k,V0,V1,V2)=0andC(G[V1∪V2])=1),返回R;4.ifV1中存在点w在图G中的度数不大于1,则返回犆狅狀狊狋狉狌犮狋犌狉狅狌狆(G\w,V0,V1\w,V2,k,F,A∪{w},S);5.elseifV1中存在点w有2个邻居在V2中,且在图G中的度数为2,则返回犆狅狀狊狋狉狌犮狋犌狉狅狌狆(G,V0∪{w},V1\w,V2,k,F,A,S);6.elseifV1中存在点w至少有2个邻居在V2中而且在图G中的度数大于26.1.{ifw至少有2个V2中的邻居在图G[V2]的同一块中,则返回犆狅狀狊狋狉狌犮狋犌狉狅狌狆(G\w,V0,V1\w,V2,k-1,F∪{w},A,S);6.2.else犆狅狀狊狋狉狌犮狋犌狉狅狌狆(G\w,V0,V1\w,V2,k-1,F∪{w},A,S)∪犆狅狀狊狋狉狌犮狋犌狉狅狌狆(G,V0,V1\w,V2∪{w},k,F,A,S);}7.else从图G[V1]中选择任意一棵树中的最深的叶子节点w1,w是w1的父亲节点,w的孩子节点为w1,…,wt7.1.{ifw有一个邻居在V2中或者w有多个孩子,则返回犆狅狀狊狋狉狌犮狋犌狉狅狌狆(G\w,V0,V1\w,V2,k-1,F∪{w},A,S)∪7.2.else将V1中点w1着成红色,且从图G中压缩w,并将w放入S中包含w1的集合Sw1,设压缩w后的图为Gc,返回图1元组构造算法先在图中找一个大小为k的FVS-F,接着找出图G中所有基于F的IF-划分.然后对每个IF-划分,枚举z个权值最小的k-FVS.最后从所有求得的k-FVS中选取z个权值最小的k-FVS,即为问题的解.IF-划分FVS的枚举过程为:首先利用分支搜索技术得到一组表示分支搜索树中叶子节点状态的元组,然后枚举各元组对应的z个权值最小k-FVS.本节主要介绍枚举IF-划分FVS中两个主要步骤:元组构造和基于元组的局部枚举.3.1元组构造元组构造过程是为了求得满足(V1=andφ(k,V0,V1,V2)>0)orV2=or(φ(k,V0,V1,V2)=0andC(G[V1∪V2])=0)的IF-划分(V0,V1,V2),k表示对当前的IF-划分所要找的FVS大小.用元组r=(G,V0,V1,V2,F,A,S)表示找到满足条件时图的状态,其中G是元组对应的图,A是元组构造算法中产生的度数不大于1的点集合,F为必须放入FVS的点集合,S中的元素是顶点集,每个顶点集中的点是待处理的点,且同一个集合中的所有点在原图中构成一条路径.对一个IF-划分(V0,V1,V2),元组构造算法ConstructGroup(G,V0,V1,V2,k,F,A,S)依次考虑V1中满足不同条件的点,然后对各类点进行相应操作,得到一组元组,且元组中划分(V0,V1,V2)满足V1=且φ(k,V0,V1,V2)>0或V2=或φ(k,V0,V1,V2)=0且图G[V1∪V2]不含圈,算法见图1.以下分析元组构造算法的各个步骤.Page5(1)当(V1=andφ(k,V0,V1,V2)>0)orV2=or(φ(k,V0,V1,V2)=0andC(G[V1∪V2])=0)成立时,由引理1,可以将FVS问题转化为FES问题,此时把元组r=(G,V0,V1,V2,F,A,S)放入集合R.(2)如果φ(k,V0,V1,V2)<0或(φ(k,V0,V1,V2)=0且C(G[V1∪V2])=1),由引理1,在图中找不到IF-划分(V0,V1,V2)的k-FVS.因此当算法步2条件满足,结束递归分支.(3)如果V1中存在一个点w在图G中的度数不大于1,则w不在图G的任何圈中.由于需要枚举k-FVS,可能将w作为冗余点加入小于k的FVS使得FVS中含k个点,于是将w保存于A.(4)如果V1中存在一个点w在图G中是2度点,且它的两个邻居都在V2中,根据IF-划分的定义,将w从V1移入V0后同样构成有效的IF-划分.(5)如果V1中存在一个点w至少有两个邻居在V2中,且w在图G中的度数大于2,若w在V2中的2个邻居属于G[V2]的同一棵树,则图G[V2∪{w}]中含有圈,需将w加入FVS,即将w加入F且将w从G中删除,k减1;若w在V2中的邻居属于G[V2]的不同树,则对w进行分支:分支1,w属于FVS,即将w加入F且将w从G中删除,k减1;分支2,w不属于FVS,即将w从V1移入V2.(6)如果V1中的点在图G中的度数均大于1,且每个点最多有一个邻居在V2中时,设T为G[V1]中一棵树,任意设一个点作为T的根节点,则总能找到T中最深的(与根节点距离最远)叶子节点,设此叶子节点为w1,其父亲节点为w,且w1,…,wt均为w的孩子.容易分析出w1,…,wt度数均为2且只有一个邻居在V2中.下面分两种情况讨论.情况1.若w有一个邻居或者多个孩子在V2中,则对w进行分支:分支1,w属于FVS,即将w加入F且将w从G中删除,k减1.分支2,w不属于FVS,由于w1,…,wt在图中的度数均为2,且均有1个邻居在V2中,如果将w移入V2,则w1,…,wt有2个邻居在V2中,故将w移到V2中的同时将w1,…,wt移入V0.情况2.若w没有邻居在V2且只有一个孩子,由于w的度数大于1,故w不可能是根节点,则w的度数为2,w1和w是两个相邻的2度点.对w点进行压缩(设w是w的父亲节点,压缩w点是从图G中删除w并连接w1和w)并将w放入包含w1的集合Sw1,可见Sw1中的点在压缩前均为2度点,且Sw1中所有点在原图中构成一条路径.如果Sw1已经在S中,则更新S中的Sw1,如果Sw1不在S中,则新建一个包含w1和w的集合Sw1,并将Sw1加入S,算法中统一用S∪{Sw1}表示.为了将w1和其它点区分开,将V1中点w1着成红色.w1移到其它集合后颜色状态保持不变,则V2中不可能有红点(如果w1的父亲节点w不被压缩,则w有邻居在V2中或者w1的父亲节点有多个孩子,根据前面的步骤,w1的父亲节点或者属于F,或者属于V2.如果将w1的父亲节点放入F,则w1的度数变为1,将w1放入A0中;如果将w1的父亲节点放入V2,则w1的两个邻居都在V2中,将w1放入V0).引理3.算法ConstructGroup(G,V0,V1,V2,k,F,A,S)返回一个元组集合R,且对图G中IF-划分(V0,V1,V2)的任意一个k-FVS,在元组集合R中一定存在一个元组r与该k-FVS相对应.证明.设F1是图G中IF-划分(V0,V1,V2)的一个k-FVS,则F1是V0∪V1的子集.如果元组r=(G,V0,V1,V2,F,A,S)满足FF1且F1与R中的V2的交集为空集,那么称F1与元组r对应.元组构造算法的递归过程对应一棵分支搜索树,且算法只在步6.2和步7.1产生两个分支,假设v是步6.2或步7.1步所考虑的点,对v点进行分支后,v或者属于F,或者属于V2,可见在这两个分支下的叶子节点代表的元组是对立的.如果F1包含v,则与F1对应的元组r在v属于F的分支中,如果F1不含v,则r在v属于V2的分支中.因此,要找到F1所对应的元组r,可从上往下在分支搜索树中搜索,当只有一个节点只有一个分支时直接考虑此节点的孩子节点(根据前面的算法分析,对点v只有一个分支且分支中将v加到F,则v也一定属于F1,否则F1不是IF-划分(V0,V1,V2)的k-FVS);当点v有两个分支时,如果v属于F1,则在v属于F的分支中找,否则在v属于V2的分支找,最后总能找到F1所唯一对应的叶子节点.分支搜索树中一个叶子节点对应一个元组,由元组构造算法可知,对于不属于R的元组,不存在与其对应的IF-划分FVS,而F1是IF-划分的k-FVS,因此F1和R中唯一一个元组对应.下面分析算法产生元组的数目和时间复杂度.引理4.算法ConstructGroup(G,V0,V1,V2,k,F,A,S)在O(2τ(k,V0,V1,V2)n2)时间内返回元组集合R,且R中最多包含2τ(k,V0,V1,V2)个元组,其中τ(k,V0,V1,V2)=k-(|V0|-#c(V2)+1),#c(V2)是Page6G[V2]中连通块的数目.证明.R中元组的个数不大于算法对应的分支搜索树中叶子节点的数目.用T(k,V0,V1,V2)表示分支搜索树中叶子节点的数目.下面用归纳法证明T(k,V0,V1,V2)max{1,2τ(k,V0,V1,V2)}.如果τ(k,V0,V1,V2)<0,则φ(k,V0,V1,V2)<0,根据算法ConstructGroup步3可知此时T(k,V0,V1,V2)=1max{1,2τ(k,V0,V1,V2)}.对于其它情况,假设某节点的孩子节点的子树中叶子节点数目T(k,V0,V1,V2)2τ(k,V0,V1,V2),只要证明该节点的子树中叶子节点数目T(k,V0,V1,V2)2τ(k,V0,V1,V2)就可以证明该引理.在算法ConstructGroup的步2返回一个元组,可知此时T(k,V0,V1,V2)=1max{1,2τ(k,V0,V1,V2)}.算法步4删除G中一个点w,k、V0和V2不变,则T(k,V0,V1,V2)=T(k,V0,V1\w,V2).由于τ(k,V0,V1\w,V2)=τ(k,V0,V1,V2),故可得T(k,V0,V1,V2)=T(k,V0,V1\w,V2)2τ(k,V0,V1,V2).算法步5把w从V1移到V0,则T(k,V0,V1,V2)=T(k,V0∪{w},V1\w,V2).由于τ(k,V0∪{w},V1\w,V2)=τ(k,V0,V1,V2)-1,故T(k,V0,V1,V2)=T(k,V0∪{w},V1\w,V2)2τ(k,V0∪{w},V1\w,V2)<2τ(k,V0,V1,V2).步6.1V0和V2不变,k减1,T(k,V0,V1,V2)=T(k-1,V0,V1\w,V2).由于τ(k-1,V0,V1\w,V2)=τ(k,V0,V1,V2)-1,故T(k,V0,V1,V2)=T(k-1,V0,V1\w,V2)2τ(k-1,V0,V1\w,V2)<2τ(k,V0,V1,V2).步6.2对w进行分支,T(k,V0,V1,V2)=T(k-1,V0,V1\w,V2)+T(k,V0,V1\w,V2∪{w}).分支1和步6.1相同,即τ(k-1,V0,V1\w,V2)=τ(k,V0,V1,V2)-1.步6.2中,w在V2中的邻居分别在G[V2]的不同树中,故将w加入V2中至少连接G[V2]中的两个连通块,连通块的数目至少减1,因此#c(V2∪{w})#c(V2)-1,于是有τ(k,V0,V1\w,V2∪{w})=k-(|V0|-#c(V2∪{w})+1)τ(k,V0,V1,V2)-1.故T(k,V0,V1,V2)=T(k-1,V0,V1\w,V2)+V1=V1\{w,w1,…,wt,},V2=V2∪{w},则下面考虑步7.1.设V0=V0∪{w1,…,wt},T(k,V0,V1,V2)=T(k-1,V0,V1\w,V2)+步7.1的分支1和步6.1相同,因此T(k-1,V0,V1\w,V2)2τ(k-1,V0,V1\w,V2)<2τ(k,V0,V1,V2)步7.1的分支2中,|V0|=|V0|+t,若w有一个邻居在V2中,则t1,若w没有邻居在V2中,且w有多个孩子,则t2,参照对步5和步6.2分支2的分析,同样可以得出τ(k,V0,V1,V2)τ(k,V0,V1,V2)-1.故T(k,V0,V1,V2)2τ(k,V0,V1,V2)2τ(k,V0,V1,V2)-1(3)由不等式(1)、(2)和(3)可得步7.2删除V1中一个点w,k、V0和V2不变,则T(k,V0,V1,V2)=T(k,V0,V1\w,V2)2τ(k,V0,V1,V2).综上所述,元组构造算法的递归过程对应的分支搜索树中叶子节点个数T(k,V0,V1,V2)2τ(k,V0,V1,V2),即R中的元组个数最多为2τ(k,V0,V1,V2).分支搜索树中由根节点到叶子节点的路径上,除步1~3外,每执行一步,V1中的顶点数至少减1,则元组构造算法中各步的执行次数不超过n.步1时间复杂度为O(1),容易分析出其它各步的时间复杂度均为O(n).分支搜索树中由根节点到叶子节点的路径不超过2τ(k,V0,V1,V2)条(路径条数等于叶子节点数),因此元组构造算法的运行时间为O(2τ(k,V0,V1,V2)n2).3.2基于元组的局部枚举设G表示原图,k为要找的图G中FVS的大小,r=(G,V0,V1,V2,F,A,S)是对图G经元组构造算法得出的一个元组,简称为图G的元组.F中的点必须放入FVS,S中的元素为顶点集,设S中所有顶点集的并集为VS,那么A,V0,V1,VS中的点均可能是FVS中的点.设k1=k-|F|,图G[V-F]中基于元组r的k1-FVS只包含A∪V0∪V1∪VS中点.图G[V-F]中基于元组r的k1-FVS加上F中的点就可以构成图G的基于元组r的k-FVS.基于元组的局部枚举主要过程是对图G[V-F]中基于元组r的z个权值最小的k1-FVS进行枚举.本文首先将FVS问题转化为FES问题,然后通过枚举z个权值最大的森林来枚举z个权值最小的k1-FES,从而找到z个权值最小的k1-FVS.3.2.1将FVS问题转化为FES问题由引理1,如果(V1=andφ(k,V0,V1,V2)>0)orV2=or(φ(k,V0,V1,V2)=0andC(G[V1∪V2])=0)成立,可将FVS转化为FES问题.由于IF-划分k-FVS最多有φ(k,V0,V1,V2)个点属于Page7V1,如果φ(k1,V0,V1,V2)=0,则k-FVS都是V0中的点,将V1中的点移入V2.如果V2=,由IF-划分的定义,V0=,那么G=G[V1],由于G[V1]是森林,这样V1中点不在任何圈中,可把V1中的点全部移入A.根据以上分析,给定一个元组构造算法得出的元组,要将FVS转化为FES问题,需将G[V2]中连通块转化为点,然后将A∪V0∪VS中的点全部转化为边,具体转化方法如下.(1)对一个元组r=(G,V0,V1,V2,F,A,S),如果φ(k1,V0,V1,V2)=0,令V0=V0,V1=,V2=V1∪V2,A=;如果V2=,则令V0=V0,V2=V2,V1=,A=A∪V1.然后令元组r=(G,V0,V1,V2,F,A,S).(2)对元组r中的IF-划分(V0,V1,V2)构造压缩图H.(3)对V0中的红点w(此处及后文提到的红点均为元组构造算法中产生的红点),S中的元素Sw={w,w1,…,wl-1}是包含w的集合,在图G[V0∪V2∪Sw]中存在一条由Sw中所有点构成的路径P={(w,w1),(w1,w2),…,(wl-2,wl-1)}.因为压缩图H中每条边都是由V0中点转化而成的,即H中每条边对应V0中一个点,可以找到图H中与w对应的边(u,v).删除图H中边(u,v),然后在图H中添加l-1个点u1,…,ul-1以及添加边(u,u1),(u1,u2),…,(ul-2,ul-1),(ul-1,v),这l条边的权值分别等于P中点w,w1,…,wl-1的权值.这样H中边(u,u1)对应P中点w;边(ui,ui+1)对应P中点wi,对1il;边(ul-1,v)对应P中的点wl-1,即H中路径PH={(u,u1),(u1,u2),…,(ul-2,ul-1),(ul-1,v)}与图G[V0∪V2∪Sw]中路经P对应.(4)对V0中每个红点执行步3后,得到图Hr.(5)对A中每个红点w,Sw是包含w的集合,将Sw中的点并到A中,设得到的A={w1,w2,…,w|A|}.然后在Hr中加2|A|个新点u1,v1,…,u|A|,v|A|以及|A|条边(u1,v1),…,(u|A|,v|A|),这|A|条边的权值分别等于A中点w1,w2,…,w|A|的权值.这样Hr中新添加的|A|条边与A中点一一对应.由Hr的构造方法可知Hr中边与A∪V0∪VS中点一一对应.设A中有d个红点,且包含A中各红点的集合的并集为VS,每添加一条孤立边到Hr将增加两个点;每将一条边扩展为一条长为l的路径增加l-1个点,l等于包含某红点集合的大小,而且需扩展的路径条数为|S|-d.因此图Hr中边的数目|E|=|A∪V0∪VS|n,点的数目|V|=#c(V2)+(|VS-VS|-(|S|-d))+2|A∪VS|2n,其中n为图G[V-F]中顶点数.引理5.给定图G=(V,E)、整数k和图G的一个元组r,设k1=k-|F|,枚举图G[V-F]的基于此元组的z个权值最小的k1-FVS可转化为枚举图Hr中z个权值最小的k1-FES,其中Hr是由元组r转化得到的.证明.设元组r=(G,V0,V1,V2,F,A,S),S中包含A中各红点的集合的并集为VS.A中的点是在元组算法中产生的度数不大于1的点,这些点不在任何圈中,因此可以把A∪VS中的点都当作0度点处理.在图G[V-F]中删除以A∪VS中的点为端点的边,得到的新图为G0,则G0比图G[V0∪V2∪(VS-VS)]多|A∪VS|个孤立点,显然求图G[V-F]基于元组r的FVS等价于求图G0中不含V2中的点的FVS.如果A=且V0中不含红点,图G的压缩图为H,那么G0=G[V0∪V2]=G,Hr=H,根据引理1,求图G0中所有基于元组r的k-FVS可转化为求图Hr中所有k-FES问题.如果A不为空,根据图Hr的构造方法,在图G0中,每个A∪VS中的点在图Hr中对应一条边.如果V0中含红点,对V0中的红点w1,由元组构造算法步7.2可知,包含w1的集合Sw1中的点在压缩前都是2度点,那么在G0也是2度点,并且Sw1中的点在图G0中构成一条路径P,根据图Hr的构造方法,路径P对应于Hr中一条路径PH.每个V0中的非红点对应Hr中一条边.因此,对于A不为空且V0中含红点,A不为空且V0中不含红点以及A为空且V0中含红点这3种情况,都满足Hr的边与A∪V0∪VS中的点一一对应,Hr的连通块与G0的连通块一一对应.因此,求图G0中所有基于元组r的k-FVS可转化为求图Hr中所有k-FES问题.综上所述,枚举图G[V-F]基于元组r的z个权值最小的k1-FVS可以转化为枚举元组r转化的图Hr中z个权值最小的k1-FES.证毕.3.2.2枚举z个权值最大的森林根据引理5,枚举z个权值最小的k1-FVS可转化为枚举图Hr=(Vr,Er)的z个权值最小的k1-FES,而枚举z个权值最小的k1-FES可通过找Hr的z个权值最大的、含|E|-k1条边的森林来实现.对于每个森林,不在森林中的边集合就是Hr的k1-FES,z个权值最大的且含|E|-k1条边的森林对应Page8表示为以下形式z个权值最小的k1-FES.枚举图Hr的z个权值最大、含t条边的森林的算法思想为:假设图中所有含t条边的森林包含于一个森林集合P,首先找出P中权值最大的森林,然后用此森林将P划分为互不相交的子集,接着求取各子集中权值最大的森林,比较得出其中权值最大的森林为P中权值第2大的森林,再用权值第2大的森林对包含它的子集做进一步划分.依此下去,直到找出权值第z大的森林.由此可见,枚举森林的核心过程为找一个森林集合中权值最大的森林和对森林集合P的划分,下面对这两个过程进行介绍.(1)找一个森林集合中权值最大的森林设P是图Hr中含t条边的森林集合,如果PP={T|(i1,j1)∈T,…,(ir,jr)∈T,XP={(i1,j1),…,(ir,jr)},YP={(m1,p1),…,(mh,ph)},设T(Xp,Yp)为包含XP中边但不包含YP中边、含t条边的森林,那么P为所有T(Xp,Yp)的集合.容易看出二元组(XP,YP)能唯一确定一个森林集合P,把集合P中森林T(Xp,Yp)也称为基于(XP,YP)的森林.引理6.给定一个图Hr(Vr,Er)和二元组(X,Y),在O(|Er|log|Vr|)时间内能够找出权值最大的T(X,Y),T(X,Y)为包含X中边但不包含Y中边且含t条边的森林.证明.求一个权值最大的T(X,Y)的算法可参照求解最小生成树算法[22]来实现,即首先将X中的边放入T,然后从图Hr中删除X和Y中的边,接着根据权值由大到小的顺序依次对Hr的剩余边进行考虑,如果一条边加到当前找到的森林T中后不构成圈,则将此边加到T中并从图中删除,否则从图中直接删除此边,再考虑下一条边,直到T中含有t条边.根据Kruskal算法的分析,容易得出求一个权值最大的T(X,Y)的时间复杂度为O(|Er|log|Vr|).如果森林集合P由二元组(XP,YP)确定,那么可通过引理6求取集合P中权值最大的含t条边的森林.(2)对森林集合P进行划分设森林集合P由二元组(XP,YP)确定,P中权值最大的森林为T(P),T(P)中不属于XP的边为e1,e2,…,eh.用T(P)将集合P划分成互不相交的子集等价于将二元组(XP,YP)进行划分,划分(XP,YP)的步骤为:对整数i,1ih,将e1,e2,…,ei-1加到XP,并将ei加到YP构成新的二元组(Xi,Yi),即Xi=XP∪{e1,…,ei-1},Yi=YP∪{ei}.所构成的h个二元组为以下形式:(X1,Y1)=(XP,Y1=YP∪{e1}),(X2,Y2)=(XP∪{e1},Y2=YP∪{e2}),…,(Xh,Yh)=(XP∪{e1,…,eh-1},Yh=YP∪{eh}).很明显,基于(XP,YP)的森林除去T(P)后等于基于各二元组(X1,Y1),…,(Xh,Yh)的森林的并集.根据以上分析,Hr中所有含t条边的森林集合P由二元组(X=,Y=)确定,枚举森林算法设计如下:首先找出图Hr中基于(X,Y)的权值最大的森林T1,为图Hr中权值最大的森林.然后用T1将(X,Y)划分为互不相交的二元组,将所有二元组放入L,再找出基于L中各二元组的权值最大的森林,从中选出权值最大的一个为T2,T2为权值第2大的森林,用T2将T2所对应的二元组进行划分,依此下去直到找出第z大的森林.具体算法过程见图2.犈狀狌犿犲狉犪狋犲-犉狅狉犲狊狋(犎r,狕,狋)输入:图Hr,整数z,t输出:z个权值最大的含t条边的森林1.二元组集合L={(X=,Y=)};2.UT=;//UT保存找到的含t条边的森林3.for(i=1;iz;i++)4.{在图Hr上分别找出与序列L中各元组对应的权值最大的含t条边的森林,设其中权值最大的含t条边的森林为T,T对应的二元组为(X1,Y1);5.Ti=T,将Ti放入UT;6.用Ti对(X1,Y1)进行划分,并将新产生的二元组插入L,7.返回UT;引理7.给定图Hr(Vr,Er),算法Enumerate-Forest(Hr,z,t)可以在O(zt|Er|log|Vr|+z2)时间内找出z个权值最大的、含t条边的森林.证明.算法Enumerate-Forest(Hr,z,t)中每执行完一次步3的循环将生成一个森林.第1次循环:根据引理6找出Hr中权值最大的含t条边的森林T1,T1={(i1,j1),…,(it,jt)},并用T1生成一组二元组,其中:(X1,Y1)=(,{e1}),(X2,Y2)=({e1},{e2}),…,(Xt,Yt)=({e1,…,et-1},{et}).将二元组(X1,Y1),…,(Xt,Yt)放入L.第i次循环:设第i-1次循环后L={(X1,Y1),…,(Xh,Yh)},首先找出基于各二元组的权值最大的含t条边的森林T(P1),…,T(Ph),并选出其中权值最大的森林赋给Ti,则Ti为Hr中权值第i大、含t条边的森林.设Ti是基于(Xk,Yk)的森林,用Ti将(Xk,Yk)进行划分,将所有二元组加到LPage9中,并从L中删除(Xk,Yk).将算法进行到第z次循环,能找到z个权值最大含t条边的森林.根据划分二元组的方法,每次循环新产生的二元组数目最多为t个.划分一个二元组的时间复杂度为O(t),根据引理6,基于二元组找一个权值最大含t条边的森林的时间复杂度为O(|Er|log|Vr|).如果每次都将新划分的二元组分为一组,那么L中的元组在第i次循环中就有i-1个分组,选出各组内二元组对应的权值最大含t条边的森林,然后组间进行比较,进而选出与L中二元组对应的权值最大含t条边的森林.这样,第i次循环所需时间为O(t|Er|log|Vr|+t+i),那么,整个算法即枚举z个权值最大含t条边的森林算法的时间复杂度为O(zt|Er|log|Vr|+z2).证毕.3.2.3基于元组的局部枚举算法前面已经介绍了将FVS问题转化为FES问题和枚举z个权值最大的森林的过程,则枚举图G中基于元组r=(G,V0,V1,V2,F,A,S)的z个权值最小的k-FVS的算法设计如下:首先将图G[V-F]的FVS问题转化为求元组r对应图的FES问题,即构造元组r的转化图Hr;设k1=k-|F|,然后枚举图Hr的z个权值最大的含有|Er|-k1条边的森林,找到z个森林对应的图Hr的z个FES,由各FES找到对应的图G[V-F]的FVS,图G[V-F]的z个FVS分别加上F中点构成图G基于元组r的z个权值最小的k-FVS.具体算法见图3.犔狅犮犪犾犈狀狌犿犲狉犪狋犻狅狀(犌,狉,狕,犽)输入:图G,一个元组r=(G,V0,V1,V2,F,A,S),整数z和k输出:图G中基于元组r的z个权值最小的k-FVS1.k1=k-|F|;2.U=;//U保存找到的k-FVS3.构造元组r的图Hr(Vr,Er);4.UT=犈狀狌犿犲狉犪狋犲-犉狅狉犲狊狋(Hr,z,|Er|-k1);5.forUT中每个含|Er|-k1条边森林T6.{Hr中不属于T中的边所构成的集合为Hr的一个FESFe,找到与Fe中边所对应的V0∪VS∪A中的点加入F,7.返回U;引理8.给定图G、参数k和元组r=(G,V0,V1,V2,F,A,S),算法LocalEnumeration可以在时间O(z(n2logn+z))内枚举出图G中基于元组的z个权值最小的k-FVS.证明.算法LocalEnumeration首先将图G[V-F]的FVS问题转化为求元组对应的图Hr(V,E)的FES问题;设k1=k-|F|,然后利用算法Enumerate-Forest枚举图Hr的z个权值最大的含有|Er|-k1条边的森林,对某个森林T,图Hr中不在T中的边就构成了Hr的一个FES-Fe,找到与Fe对应的V0∪VS∪A中的点,再把这些点加入F,此时F就是图G中一个k-FVS.完成对图Hr的z个权值最大的含有|Er|-k1条边的森林的处理后,就得到了图G中基于元组r的z个权值最小的k-FVS.根据Hr的构造方法,Hr中的边数目|Er|n,顶点数目|Vr|2n,其中n为图G[V-F]中顶点数.由引理7可知,枚举z个权值最大的含|E|-k1条边的森林的时间复杂度为O(z(|Er|-k1)|Er|log|Vr|+z2)=O(z(n-k1)nlogn+z2)=O(z(n2logn+z)).算法步1、步2和步7的时间复杂度为O(1),步3构造图Hr以及步5的时间复杂度为O(zn).因此,枚举图G中基于给定元组r的z个权值最小的k-FVS的时间复杂度为O(z(n2logn+z)).证毕.4FVS的固定参数枚举算法在第3节已经描述了FVS的固定参数枚举问题的两个主要过程:元组构造和基于元组的局部枚举算法.本节将介绍FVS的固定参数枚举算法并分析其时间复杂度.算法首先构造一组IF-划分,然后调用元组构造算法和基于元组的局部枚举算法枚举各IF-划分的z个权值最小的k-FVS,并保留其中z个权值最小的k-FVS,算法具体过程如图4所示.犈狀狌犿犲狉犪狋犻狅狀-犉犞犛(犌,犽,狕)输入:G=(V,E),k,z输出:图G的z个权值最小的k-FVS1.利用文献[16]中的算法求G一个大小为k的FVSF;2.Y=;//Y保存G的z个权值最小k-FVS;3.for(j=0;jk;j++)4.{forF的每个j大小的子集F1,如果G[F-F1]是森林,则5.{G0=G[V-F1],V0=,V1=V-F,V2=F-F1,6.R=犆狅狀狊狋狉狌犮狋犌狉狅狌狆(G0,V0,V1,V2,k,F,A,S);7.ifz|R|,则z1=1;8.elsez1=z/|R槡|;9.forR中的每个元组r10.U1=U1∪取犔狅犮犪犾犈狀狌犿犲狉犪狋犻狅狀(G0,r,z1,k);11.保留U1中z个权值最小的k-FVS,设所对应的z1个12.forR中的每个元组r13.U2=U2∪犔狅犮犪犾犈狀狌犿犲狉犪狋犻狅狀(G0,r,z,k);14.将U1∪U2中z个权值最小的k-FVS放入U;15.将U中z个k-都加上F1中点构成k-FVS,放入Y;}}16.输出Y中z个权值最小且互不相同的k-FVS;算法步4~步15为枚举一个IF-划分的z个权Page10值最小FVS,根据图4中算法,得到以下引理.引理9.给定图G和图G的一个IF-划分(V0,V1,V2),能够在O(2τ(k,V0,V1,V2)n2logn+1.414τ(k,V0,V1,V2)z(n2logn+z))时间内枚举IF-划分(V0,V1,V2)的z个权值最小k-FVS.证明.R是IF-划分(V0,V1,V2)经元组构造算法得到的元组集合,设N是R中元组数目.由引理3,一个k-FVS只对应一个元组,设集合Y为图G的z个权值最小k-FVS的集合,下面分两种情况讨论.如果z槡N,设z1=1,通过基于元组的局部枚举算法,分别构造R中各元组对应的1个权值最小的k-FVS并放于集合U1,那么U1中有N个k-FVS,根据引理8,此过程的时间复杂度为O(N(n2logn+1).对任意一个元组r,如果基于r的k-FVS都不在U1中,那么基于r的k-FVS不可能属于Y,则从元组集合R中删除该元组.因此,R中剩余的元组个数N1=z.对R中剩下的元组,通过基于元组的局部枚举算法,分别求基于各元组的z个权值最小的k-FVS并放入集合U2,则U2中有N1z=z2个k-FVS,根据引理8,此过程的时间复杂度为O(N1z(n2logn+z))=O(槡Nz(n2logn+z)).U1∪U2=U2中z个权值最小的k-FVS为IF-划分的z个权值最小的k-FVS.因此,在z槡N的情况下,枚举IF-划分(V0,V1,V2)的z个权值最小的k-FVS的时间复杂度为O(Nn2logn+槡Nz(n2logn+z)).如果z>槡N,设z1=z/槡N,通过基于元组的局部枚举算法,分别对N个元组构造与其对应的z1个权值最小的k-FVS放入U1,那么U1中有Nz1个k-FVS,根据引理8,此过程的时间复杂度为O(Nz1(n2logn+z1))=O(槡Nz(n2logn+z1)).对任意一个元组r,若与之对应的z1个权值最小的k-FVS不全在U1中,则基于元组r但不属于U1的k-FVS不可能属于Y,从元组集合R中删除该元组.这样R中剩下的元组为对应的z1个权值最小的k-FVS都属于U2的元组.根据引理3,一个k-FVS只对应一个元组,所以,R中剩下的元组数N1不超过槡N.对这N1个元组,分别找各元组对应的z个权值最小k-FVS并保存于U2,则U2中有N1z个k-FVS,根据引理8,此过程的时间复杂度为O(N1z(n2logn+z))=O(槡Nz(n2logn+z)).U1∪U2中z个权值最小的k-FVS为IF-划分的z个权值最小的k-FVS.因此,当z>槡N时,枚举IF-划分(V0,V1,V2)的z个权值最小的k-FVS的时间复杂度为O(槡Nz(n2logn+z)).综上所述,给定一个IF-划分(V0,V1,V2),找图G关于IF-划分(V0,V1,V2)的z个权值最小的k-FVS的时间复杂度为O(Nn2logn+槡Nz(n2logn+z)).由引理4,R中元组个数不超过2τ(k,V0,V1,V2),那么N2τ(k,V0,V1,V2),槡N1.414τ(k,V0,V1,V2),由此证明此引理.定理1.给定图G=(V,E),枚举图G中z个权值最小的k-FVS的时间复杂度为O(5kn2(logn+k)+3kz(n2logn+z)).证明.给定图G=(V,E),用文献[16]中求取不带权图的FVS的算法,可得一个大小为k的FVSF.图G的每个k-FVS可看作由F的大小为j的子集F1和V-F的一个大小为k-j的子集F2构成,其中0jk,即找图G的k-FVS问题可以转化为找图G0=G[V-F1]的不含F-F1中点的(k-j)-FVS,图G0的每个(k-j)-FVS加上F1都是图G的k-FVS.明显可知图G[F-F1]和图G[V-F]都是森林且都是图G0的子图,图G0的(k-j)-FVS不含F-F1中的点,若设V0=,V1=V-F,V2=F-F1,则(V0,V1,V2)是图G0有效的IF-划分.对所有整数j,0jk,穷举F中所有大小为j且满足图G[F-F1]是森林的子集F1,用F1能形成一组IF-划分.枚举各IF-划分对应的图G的z个权值最小的k-FVS,然后取其中z个权值最小的k-FVS,即为图G的z个权值最小的k-FVS.由引理9,对一个IF-划分(V0,V1,V2)的z个权值最小的k-j大小FVS可以在以下时间内完成:O(2τ(k-j,V0,V1,V2)n2logn+1.414τ(k-j,V0,V1,V2)z(n2logn+z))=O(2(k-j)-(0-#c(F-F1)+1)n2logn+=O(4k-jn2logn+2k-jz(n2logn+z)),其中,#c(F-F1)|F-F1|=k-j.那么对所有整数j,0jk,穷举F的所有大小为j的子集F1并生成IF-划分,然后再枚举各IF-划分的z个权值最小、大小为k-j的FVS,可以在以下时间内完成:Page11∑kj=0=O(5kn2logn+3kz(n2logn+z)).IF-划分的总个数不超过2k个,那么总共枚举出了2kz个k-FVS,从中取z个权值最小的时间为O(2kz).根据引理2,求取图G的一个k-FVS的时间复杂度为O(5kkn2).因此,对带权图G,枚举z个权值最小的k-FVS的时间复杂度为O(5kn2(logn+k)+3kz(n2logn+z)).5结论本文讨论了枚举带权无向图中z个权值最小的k-FVS的问题,提出了一个FVS的固定参数枚举算法,其时间复杂度为O(5kn2(logn+k)+3kz(n2logn+z)).算法基于分支搜索技术,将FVS问题转化为FES问题,通过枚举转化图Hr的z个权值最大的森林来枚举z个权值最小的FES,从而枚举出z个权值最小的k-FVS.如果将算法中枚举图Hr的z个权值最大的森林的过程改为枚举图Hr的z个权值最大的生成森林(枚举生成森林的算法见文献[23-24]),那么各生成森林对应图Hr的一个极小FES(删除FES中任何点将不再是图Hr的FES),通过极小FES找到的FVS将是大小不超过k的FVS,这样,改变后的算法可用于枚举z个权值最小且大小不超过k的FVS.在本文的算法中,将分支过程中产生的0度点和1度点都转化为图Hr的边,然后在图Hr中枚举森林时一块考虑了这些点,但是当参数k恰好等于图G中含顶点数最少的FVS的大小时,这些0度点和1度点不可能在图G的k-FVS中;当要枚举z个权值最小且大小不超过k的FVS时,这些0度点和1度点也不可能在所要枚举的FVS中,因此,当参数k恰好等于图中含顶点数最少的FVS的大小以及当要枚举z个权值最小且大小不超过k的FVS时,无需将0度点和1度点都转化为Hr的边,这样Hr的规模将减小很多,枚举的时间也将减小.当参数k接近于图中含顶点数最少的FVS的大小d时,也可不将0度点和1度点转化为图Hr的边,可参照文献[21]中枚举k-VertexCover时处理0度点和1度点的方法对这些点单独处理,但是这样对每个整数j,djk,需枚举图Hr的z个权值最小的j-FES,即枚举的森林个数将相对增多.FVS问题是经典的NP-完全问题,有很多重要应用,人们对此问题进行了大量的研究.在参数计算理论领域,对无向图中参数化FVS问题有一系列FPT算法,而且对无向图FVS的核心化也进行了研究[25-27],最近得出O(k2)的核[27].目前已经证明不带权有向图FVS是FPT的,但是有向图有无多项式的核以及带权有向图的FVS有无FPT算法仍然是开放性课题,有待于进一步研究.
