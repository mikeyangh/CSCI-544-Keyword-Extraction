Page1/ 在线/ -/ 离线/ 数据流/ 上/ 复杂/ 事件/ 检测/ 彭商/ 濂/ 1/ )/ 李战怀/ 1/ )/ 陈群/ 1/ )/ 李强/ 2/ )/ 1/ )/ (/ 西北工业大学/ 计算机/ 学院/ 西安/ 710129/ )/ 2/ )/ (/ 西北工业大学/ 软件/ 与/ 微电子/ 学院/ 西安/ 710072/ )/ 摘要/ 随着/ 数据/ 采集/ 和/ 处理/ 技术/ 的/ 发展/ ,/ 在/ 物/ 联网/ 对象/ 跟踪/ 、/ 网络/ 监控/ 、/ 金融/ 预测/ 、/ 电信/ 消费/ 模式/ 等/ 领域/ 中/ 进行/ 事件/ 检测/ 显得/ 越发/ 重要/ ./ 事件/ 检测/ 在/ 一次/ 扫描/ 数据流/ 的/ 假设/ 下/ 完成/ ,/ 数据流/ 在/ 被/ 处理/ 完后/ 丢弃/ ./ 事实上/ ,/ 很多/ 应用/ 场景/ 中/ ,/ 历史/ 数据流/ 因/ 含有/ 丰富/ 的/ 信息/ 而/ 不能/ 简单/ 丢弃/ ,/ 且/ 一些/ 事件/ 检测/ 查询/ 需要/ 同时/ 在/ 实时/ 和/ 历史/ 数据流/ 上/ 进行/ ./ 鉴于/ 已有/ 复杂/ 事件/ 检测/ 很少/ 考虑/ 同时/ 在/ 实时/ -/ 历史/ 数据流/ 上/ 进行/ 模式匹配/ ,/ 作者/ 研究/ 了/ 在线/ -/ 离线/ 数据流/ 上/ 复杂/ 事件/ 检测/ 的/ 关键问题/ ./ 主要/ 工作/ 如下/ :/ (/ 1/ )/ 针对/ 滑动/ 窗口/ 内/ 产生/ 的/ 大量/ 模式匹配/ 中间/ 结果/ ,/ 提出/ 利用/ 时态/ 关系/ 和/ 时空/ 关系/ 管理/ 中间/ 结果/ 的/ 方法/ TPM/ 和/ STPM/ ./ STPM/ 以/ 中间/ 结果/ 的/ 时态/ 和/ 状态/ 信息/ 为/ 权值/ 对/ 中间/ 结果/ 进行/ 管理/ ,/ 将/ 最近/ 的/ 、/ 最有/ 可能/ 更新/ 状态/ 的/ 中间/ 结果/ 置于/ 内存/ ,/ 极大/ 地/ 减少/ 了/ 中间/ 结果/ 的/ 读取/ 操作/ 代价/ ./ (/ 2/ )/ 给出/ 了/ 基于/ 选择/ 度/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 优化/ 算法/ ;/ (/ 3/ )/ 给出/ 了/ 算法/ 的/ 复杂性/ 分析/ 和/ 代价/ 模型/ ;/ (/ 4/ )/ 在/ 基于/ 时空/ 关系/ 的/ 中间/ 结果/ 管理/ 模型/ 下/ ,/ 在/ 一个/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 原型/ 系统/ 中/ 进行/ 实验/ ,/ 对/ 多个/ 参数/ (/ 子/ 窗口/ 大小/ ,/ 选择/ 度/ ,/ 匹配/ 率/ ,/ 命中率/ )/ 进行/ 了/ 算法/ 对比/ 分析/ ./ 实验/ 结果/ 充分/ 验证/ 了/ 所/ 提出/ 的/ 算法/ 的/ 可行性/ 和/ 高效性/ ./ 关键词/ 物/ 联网/ ;/ 复杂/ 事件/ 检测/ ;/ 数据流/ ;/ 非/ 确定/ 有限/ 状态/ 自动机/ ;/ RFID/ ;/ 无线/ 传感器/ 网络/ 1/ 引言/ 随着/ 逐渐/ 增多/ 的/ 应用领域/ (/ 如/ 金融业/ 、/ 网络/ 监控/ 、/ 基于/ RFID/ 的/ 供应链/ 管理/ 、/ 医疗/ 监控/ 、/ 物/ 联网/ 应用/ 等/ )/ 需要/ 处理/ 大量/ 分布/ 、/ 高速/ 的/ 数据流/ ,/ 复杂/ 事件/ 检测/ (/ ComplexEventProcessing/ ,/ CEP/ )/ 变得/ 越发/ 重要/ [/ 1/ -/ 2/ ]/ ./ 用户/ 通过/ 复杂/ 事件/ 定义语言/ 描述/ 需要/ 检测/ 的/ 模式/ (/ 复杂/ 事件/ )/ ,/ 复杂/ 事件/ 检测/ 引擎/ 将/ 用户/ 定义/ 的/ 模式/ 解析/ 为/ 自动机/ 或树/ 模型/ ,/ 然后/ 在/ 事件/ 流/ 上/ 进行/ 事件/ 检测/ ./ 在/ 当前/ 的/ 复杂/ 事件处理/ 系统/ 中/ ,/ 一般/ 假设/ 事件/ 流以/ 一次/ 扫描/ 的/ 方式/ 被/ 扫描/ ,/ 且/ 处理/ 完后/ 就/ 被/ 抛弃/ ,/ 无需/ 进行/ 归档/ ./ 事实上/ ,/ 一次/ 扫描/ 数据流/ 并/ 没有/ 充分/ 发掘/ 数据流/ 的/ 价值/ ,/ 用户/ 将/ 查询/ 定义/ 在/ 数据流/ 上/ 也/ 只能/ 描述/ 一部分/ 现实/ 世界/ 的/ 查询/ 需求/ ./ 正如/ 下面/ 列举/ 的/ 实例/ 显示/ ,/ 数据流/ 上/ 的/ 复杂/ 事件/ 查询/ 不但/ 需要/ 处理/ 实时/ 数据流/ ,/ 同时/ 也/ 需要/ 访问/ 历史/ 数据流/ ./ 示例/ 1/ :/ 汽车/ 行驶/ 时间/ 实时/ 计算/ (/ 如/ 超速/ 监控/ )/ ./ 高速公路/ 上/ ,/ 汽车/ 上/ 安装/ 有/ 主动/ RFID/ 电子标签/ 用于/ 身份/ 识别/ 和/ 跟踪/ ;/ 高速公路/ 收费/ 点/ 或/ 沿路/ 的/ 监控点/ 都/ 安装/ 了/ RFID/ 阅读器/ ./ 当/ 汽车/ 经过/ 高速公路/ 收费/ 点时/ (/ 或/ 途中/ 的/ 监控点/ 时/ )/ ,/ 这些/ 阅读器/ 可以/ 跟踪/ 单辆/ 汽车/ ,/ 并/ 记录/ 其/ 速度/ 信息/ ./ 为了/ 计算/ 当前/ 点/ 和/ 上/ 一个点/ 的/ 行驶/ 时间/ ,/ 需要/ 从/ 实时/ 数据流/ 上/ 取出/ 事件/ 记录/ ,/ 然后/ 查询/ 历史/ 数据流/ 寻找/ 上/ 一个点/ 的/ 时间/ 信息/ ,/ 判断/ 是否/ 超速行驶/ ./ 该/ 查询/ 如图/ 1/ 所示/ ,/ 是/ 用/ 文献/ [/ 3/ ]/ 中/ 的/ 基于/ SQL/ 的/ 查询语言/ 描述/ 的/ ./ 示例/ 2/ :/ 股票/ 趋势/ 预测/ ./ 股票/ 的/ 趋势/ 预测/ 信息/ 可以/ 辅助/ 投资者/ 进行/ 股票/ 的/ 买进/ 或/ 抛出/ ./ 投资者/ 可以/ 在/ 股票/ 流/ 上/ 定义/ 如下/ 的/ 复杂/ 事件/ 查询/ :/ 当/ 在/ 一支/ 股票/ 的/ 实时/ 数据流/ 上/ 检测/ 到/ 一个/ 下降/ 模式/ (/ “/ \/ ”/ )/ 时/ ,/ 在/ 历史/ 股票/ 流/ 上/ 检测/ 一个/ 勾/ 模式/ (/ “/ √/ ”/ )/ ,/ 该/ 查询/ 如图/ 2/ 所示/ ,/ 也/ 用/ 文献/ [/ 3/ ]/ 中/ 查询语言/ 描述/ ./ 这些/ 示例/ 表明/ ,/ 复杂/ 事件/ 检测/ 需要/ 同时/ 集成/ 在/ 图/ 1/ 基于/ RFID/ 的/ 高速公路/ 行驶/ 时间/ 监控/ 事件/ 查询/ 线/ 数据流/ 与/ 离线/ 数据流/ 的/ 处理/ ./ 在线/ -/ 离线/ 复杂/ 事件处理/ 在/ 实际/ 应用/ 中需/ 面对/ 下列/ 挑战/ :/ (/ 1/ )/ 海量/ 高速/ 的/ 流/ 数据/ ./ 应用/ 场景/ 很/ 容易/ 产生/ GB/ 级/ 到/ TB/ 级/ 的/ 流/ 数据/ (/ 如/ 在/ 基于/ RFID/ 的/ 电子/ 超市/ )/ ,/ 如何/ 有效/ 地/ 存储/ 这些/ 数据/ 是/ 在线/ -/ 离线/ 复杂/ 事件处理/ 的/ 重要/ 问题/ ;/ (/ 2/ )/ 复杂/ 事件/ 中间/ 结果/ 管理/ ./ 在/ 很多/ 复杂/ 事件/ 检测/ 应用/ 中/ ,/ 用户/ 定义/ 一个/ 很大/ 的/ 时间/ 窗口/ W/ ./ 随着/ 复杂/ 事件/ 检测/ 的/ 推进/ ,/ 在/ W/ 中/ 的/ 复杂/ 事件/ 的/ 中间/ 结果/ 数量/ 将/ 变得/ 非常/ 巨大/ ./ 同时/ 在/ 历史/ 数据流/ 上/ 复杂/ 事件/ 检测/ 的/ 中间/ 结果/ 也/ 将/ 随之/ 增大/ ./ 在/ 复杂/ 事件处理/ 节点/ 内存/ 资源/ 有限/ 的/ 情况/ 下/ ,/ 如何/ 对/ 这些/ 生命周期/ 在/ W/ 内/ 的/ 中间/ 结果/ 进行/ 有效/ 的/ 管理/ 对/ 复杂/ 事件/ 检测/ 的/ 响应/ 时间/ 具有/ 重要/ 影响/ ./ (/ 3/ )/ 数据流/ 中/ 事件/ 分布/ 的/ 不同/ 使得/ 事件/ 检测/ 在/ 实时/ 数据流/ 和/ 历史/ 数据流/ 上/ 的/ 实例/ 数目/ 也/ 不同/ ,/ 导致/ 历史/ 流/ 的/ 访问/ 请求/ 次数/ 的/ 不同/ 和/ 历史/ 流/ 上/ 模式/ 的/ 重复/ 计算/ ,/ 利用/ 数据流/ 中/ 事件/ 类型/ 的/ 选择/ 度/ 和/ 不同/ 实例/ 的/ 历史/ 流/ 访问/ 区间/ 交叉/ 等/ 特性/ 对/ 在线/ -/ 离线/ 事件/ 检测/ 顺序/ 的/ 进行/ 调度/ 可以/ 有效/ 减少/ 复杂/ 事件/ 的/ 响应/ 时间/ ./ 当前/ 的/ 复杂/ 事件/ 检测/ 主要/ 针对/ 实时/ 数据流/ ,/ 很少/ 考虑/ 再次/ 访问/ 历史/ 流/ ./ 与/ 本文/ 工作/ 最为/ 接近/ 的/ 是/ Moirae/ [/ 4/ ]/ 和/ Dejavu/ [/ 5/ -/ 6/ ]/ ./ Moirae/ 是/ 一个/ 集成/ 了/ 流/ 数据处理/ 和/ 数据库/ 技术/ 的/ 数据流/ 处理/ 引擎/ (/ StreamProcessingEngine/ ,/ SPE/ )/ ./ Moirae/ 支持/ 4/ 类/ 查询/ :/ 事/ Page3/ 件/ 查询/ 、/ 标准/ 混合/ 查询/ 、/ 上下文/ 查询/ 、/ 上下文/ 混合/ 查询/ ./ Moirae/ 设计/ 的/ 假设/ 是/ :/ 查询/ 整个/ 历史/ 日志/ (/ 数据/ )/ 太慢/ 以至于/ 不能/ 满足/ 应用/ 的/ 响应/ 要求/ ,/ 所以/ 返回/ 最/ 相关/ 的/ 近似/ 查询/ 结果/ 是/ 合理/ 的/ ./ 基于/ 该/ 假设/ ,/ Moirae/ 提出/ 了/ 历史/ 流/ 分区/ 存储/ 、/ 最近/ 访问/ 的/ 事件/ 物化/ 、/ 查询/ 执行/ 分解/ 和/ 历史/ 查询/ 调度/ 等/ 设计/ 方法/ ./ 可以/ 看出/ ,/ 这些/ 方法/ 都/ 不是/ 全新/ 的/ ,/ 且/ 已经/ 应用/ 到/ 数据库/ 的/ 相关/ 领域/ ./ 由于/ 复杂/ 事件/ 检测/ 要求/ 的/ 是/ 准确/ 的/ 查询/ ,/ 所以/ Moirae/ 的/ 设计/ 不能/ 直接/ 用于/ CEP/ ./ Dejavu/ 是/ 一个/ 集成/ 了/ 在/ 实时/ -/ 历史/ 上/ 进行/ 复杂/ 事件/ 检测/ 的/ SPE/ ./ Dejavu/ 通过/ 扩展/ SQL/ 语言/ 以便/ 支持/ 复杂/ 事件/ 的/ 定义/ (/ 如/ 增加/ 模式匹配/ 字句/ MATCH/ _/ RECOG/ -/ NIZE/ [/ 3/ ]/ )/ ,/ 使该/ 事件处理/ 引擎/ 可以/ 定义/ 复杂/ 事件/ 查询/ ,/ 同时/ 通过/ 扩展/ MySQL/ 的/ 读写/ 数据/ API/ ,/ 使得/ 该/ 引擎/ 支持/ 快速/ 的/ 数据流/ 归档/ ./ 在/ Dejavu/ 中/ ,/ 为/ 避免/ 历史/ 数据流/ 的/ 重复/ 计算/ ,/ 使用/ 了/ 结果/ 缓存/ 的/ 数据结构/ 将/ 历史/ 流上/ 的/ 模式/ 缓存/ ,/ 以便/ 为/ 实时/ 流/ 上/ 后续/ 的/ 复杂/ 事件/ 检测/ 共享/ 使用/ ./ 此外/ ,/ 通过/ 利用/ 实时/ 数据流/ 和/ 历史/ 数据流/ 的/ 选择/ 度/ 不同/ 来/ 调整/ 这/ 两个/ 流/ 的/ 连接/ 顺序/ 以/ 优化/ 事件/ 检测/ 查询/ 的/ 执行/ ./ 在/ Dejavu/ 中/ ,/ 作者/ 主要/ 考虑/ 股票/ 流/ 上/ 连续/ 模式/ 的/ 在线/ 离线/ 复杂/ 事件/ 检测/ ./ 由于/ 离散/ 模式/ 的/ 子/ 事件/ 可能/ 分布/ 在/ 数据流/ 的/ 任意/ 位置/ ,/ 中间/ 结果/ 缓存/ 及/ 相应/ 的/ 优化/ 算法/ 都/ 需要/ 重新考虑/ ./ 作者/ 研究/ 了/ 基于/ 离散/ 模式/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ ,/ 文献/ [/ 7/ ]/ 是/ 作者/ 的/ 初步/ 工作/ ,/ 提出/ 了/ 基于/ 离散/ 模式/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 的/ 系统结构/ 和/ 基本/ 处理/ 方法/ ./ 本文/ 在/ 文献/ [/ 7/ ]/ 工作/ 的/ 基础/ 上/ ,/ 增加/ 了/ 下列/ 研究/ 内容/ :/ (/ 1/ )/ 针对/ 大/ 滑动/ 窗口/ 内/ 产生/ 的/ 大量/ 模式匹配/ 中间/ 结果/ ,/ 在/ 系统结构/ 中/ 增加/ 了/ 中间/ 结果/ 管理/ 的/ 模块/ ,/ 提出/ 利用/ 时态/ 关系/ 和/ 时空/ 关系/ 管理/ 中间/ 结果/ 的/ 方法/ TPM/ 和/ STPM/ ./ STPM/ 以/ 中间/ 结果/ 的/ 时态/ 和/ 状态/ 信息/ 为/ 权值/ 对/ 中间/ 结果/ 进行/ 管理/ ,/ 将/ 最近/ 的/ 最/ 有/ 可能/ 更新/ 状态/ 的/ 中间/ 结果/ 置于/ 内存/ ,/ 极大/ 地/ 减少/ 了/ 中间/ 结果/ 的/ 读取/ 操作/ 代价/ ./ (/ 2/ )/ 增加/ 了/ 基于/ 选择/ 度/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 优化/ 算法/ ;/ (/ 3/ )/ 给出/ 了/ 算法/ 的/ 复杂性/ 分析/ 和/ 代价/ 模型/ ;/ (/ 4/ )/ 在/ 基于/ 时空/ 关系/ 的/ 中间/ 结果/ 管理/ 模型/ 下/ ,/ 重新/ 进行/ 了/ 实验设计/ ,/ 进行/ 了/ 相关/ 算法/ 的/ 对比/ 分析/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 3/ 节/ 介绍/ 事件/ 模型/ 、/ 问题/ 定义/ 和/ 在线/ -/ 离线/ 事件/ 检测/ 架构/ ;/ 第/ 4/ 节/ 介绍/ 在线/ -/ 离线/ CEP/ 检测/ 算法/ 及其/ 优化/ ;/ 第/ 5/ 节/ 描述/ 中间/ 结果/ 管理策略/ ;/ 第/ 6/ 节为/ 实验/ 结果/ 分析/ ;/ 第/ 7/ 节/ 总结/ 全文/ 和/ 下/ 一步/ 工作/ 展望/ ./ 2/ 相关/ 工作/ 复杂/ 事件/ 检测/ 是/ 一种/ 从/ 简单/ 事件/ 集合/ 中/ 关联/ 出/ 更/ 具有/ 语义/ 的/ 复杂/ 事件/ 的/ 数据分析/ 技术/ ,/ 最早/ 在/ 基于/ trigger/ 和/ ECA/ 规则/ 的/ 主动/ 数据库/ [/ 8/ -/ 9/ ]/ 中/ 应用/ ,/ 随后/ 在/ 基于/ 关键字/ 或/ 简单/ 谓词/ 的/ Publish/ // Subscribe/ 系统/ 中/ 应用/ [/ 10/ ]/ ./ 随着/ 流/ 数据处理系统/ 的/ 推广/ ,/ 结合/ 窗口/ 概念/ 的/ 复杂/ 事件/ 检测/ 也/ 被/ 集成/ 到/ 数据流/ 管理系统/ (/ DataStreamManagementSystems/ ,/ DSMS/ )/ 中/ ./ 典型/ 的/ 系统/ 有/ Aurora/ [/ 11/ ]/ 、/ TelegraphCQ/ [/ 12/ ]/ 和/ HiFi/ [/ 13/ ]/ 等/ ./ 这些/ 系统/ 主要/ 针对/ 与/ 数据流/ 的/ 连接/ (/ join/ )/ 、/ 聚集/ (/ aggregation/ )/ 和/ 一些/ 统计/ (/ statistics/ )/ 操作/ ,/ 不适/ 用于/ 定义/ 复杂/ 事件/ 检测/ 的/ 查询/ ./ SASE/ [/ 1/ ,/ 14/ -/ 15/ ]/ 、/ ZStream/ [/ 16/ ]/ 和/ Cayuga/ [/ 2/ ]/ 是/ 流/ 数据/ 上/ 复杂/ 事件/ 检测/ 的/ 3/ 个/ 比较/ 著名/ 的/ 原型/ 系统/ ./ 它们/ 各自/ 有/ 事件/ 定义语言/ (/ 基于/ 类/ SQL/ 或/ 声明/ 型/ 定义语言/ )/ 和/ 查询/ 模型/ (/ 如/ 自动机/ 模型/ 、/ 树/ 模型/ )/ 及/ 相应/ 的/ 优化/ 策略/ ,/ 但/ 缺少/ 集成/ 历史/ 流/ 访问/ 的/ 复杂/ 事件/ 定义/ 和/ 检测/ 的/ 支持/ ./ Page4/ 文献/ [/ 8/ ,/ 17/ ]/ 研究/ 了/ 在/ 传统/ 数据库/ 上/ 进行/ 模式匹配/ 的/ 相关/ 问题/ [/ 3/ ]/ ,/ 包括/ 模式定义/ 语言/ 、/ 算子/ 语义/ 和/ 查询/ 模型/ ./ 这些/ 工作/ 缺乏/ 对流/ 数据/ 上/ 事件/ 检测/ 的/ 考虑/ ,/ 也/ 不适/ 用于/ 流/ 数据/ 上/ 更为/ 复杂/ 的/ 事件/ 查询/ ./ Moirae/ [/ 4/ ]/ 和/ Dejavu/ [/ 5/ -/ 6/ ]/ 是/ 两个/ 与/ 本文/ 工作/ 最为/ 接近/ 的/ 实时/ -/ 历史/ 数据流/ 查询/ 系统/ ./ Moirae/ 主要/ 研究/ 在/ 不/ 可能/ 遍历/ 整个/ 历史/ 流/ 情况/ 下/ 如何/ 为/ 查询/ 返回/ 最/ 相似/ 的/ 结果/ 的/ 问题/ ,/ 精确/ 的/ 查询/ 结果/ 可以/ 通过/ 逐步求精/ 的/ 方式/ 获得/ ./ Moirae/ 通过/ 将/ 已有/ 数据流/ 、/ 数据库/ 和/ 存储/ 等/ 方面/ 的/ 技术/ 集成/ 到/ 一个/ 框架/ 中/ ,/ 支持/ 多种类型/ 的/ 查询/ ./ 本文/ 工作/ 与/ Moirae/ 的/ 不同之处/ 在于/ ,/ 本文/ 考虑/ 的/ 复杂/ 事件/ 查询/ 要求/ 精确/ 结果/ 且/ 复杂/ 事件/ 有/ 可能/ 分布/ 在/ 较/ 长/ 的/ 时间/ 区间/ 内/ ,/ 考虑/ 如何/ 快速/ 、/ 完整/ 检测/ 数据流/ 上/ 的/ 复杂/ 事件/ ,/ 同时/ 考虑/ 在/ 复杂/ 事件/ 中间/ 结果/ 较/ 多/ 而/ 引起/ 系统/ 负载/ 较大/ 时/ 如何/ 降载/ 的/ 问题/ ./ Dejavu/ 是/ 一个/ 集成/ 实时/ -/ 历史/ 数据流/ 处理/ 的/ 复杂/ 事件/ 系统/ ./ Dejavu/ 通过/ 声明/ 性/ 的/ 模式匹配/ 语言/ 定义/ 复杂/ 事件/ ./ 在/ Dejavu/ 中/ ,/ 数据/ 的/ 存储/ 架构/ 基于/ 开源/ 的/ 数据库系统/ MySQL/ ./ 通过/ 在/ 系统/ 中/ 集成/ MySQL/ 的/ 可/ 插入式/ API/ ,/ Dejavu/ 引入/ DStream/ 和/ DArchive/ 这/ 两类/ 存储/ 结构/ ,/ 并/ 在/ DStream/ 和/ DAr/ -/ chive/ 之间/ 设计/ 了/ 一个/ 最近/ 处理/ 过/ 的/ 事件/ 缓冲区/ (/ RecentBuffer/ )/ 来/ 平衡/ 实时/ 流/ 和/ 历史/ 流/ 归档/ 操作/ ,/ 同时/ 为/ 历史/ 流上/ 的/ 复杂/ 事件/ 检测/ 提供/ 数据源/ ./ 在/ Dejavu/ 中/ 使用/ 了/ 结果/ 缓存/ (/ ResultsCache/ )/ 数据结构/ 存储/ 在/ 历史/ 流/ 上/ 寻找/ 到/ 的/ 模式/ ,/ 以便/ 为/ 后续/ 的/ 模式匹配/ 使用/ ./ Dejavu/ 所/ 处理/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 主要/ 针对/ 连续/ 模式/ (/ 如/ 在/ 股票/ 数据流/ 上/ 寻找/ “/ 勾/ ”/ )/ ,/ 而/ Dejavu/ 中/ 的/ 离散/ 模式/ 主要/ 是/ 实时处理/ ./ 此外/ ,/ Dejavu/ 中/ 的/ 中间/ 结果/ 缓存/ 基于/ 如下/ 的/ 观察/ :/ 历史/ 流/ 上/ 检测/ 到/ 的/ 一个/ 实例/ 可能/ 被/ 实时/ 流上/ 的/ 多个/ 实例/ 访问/ ,/ 所以/ 把/ 已经/ 加载/ 的/ 历史/ 流上/ 的/ 所有/ 模式/ 检测/ 出来/ 并/ 缓存/ 有利于/ 减少/ 重复/ 计算/ 和/ 数据/ 加载/ ./ 但/ 我们/ 观察/ 到/ ,/ 连续/ 模式/ 其实/ 是/ 更为/ 一般/ 的/ 模式/ —/ —/ —/ 离散/ 模式/ 的/ 特例/ ,/ 离散/ 模式/ 并/ 不/ 严格要求/ 子/ 事件/ 的/ 顺序/ ,/ 即/ 离散/ 模式/ 的/ 中间/ 结果/ (/ 子/ 事件/ )/ 可能/ 分散/ 在/ 实时/ 流/ 和/ 历史/ 流/ 的/ 任何/ 可能/ 位置/ ,/ 所以/ 将/ 历史/ 流上/ 的/ 所有/ 中间/ 结果/ 计算出来/ 缓存/ 在/ 内存/ 对/ 离散/ 模式/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 是/ 不/ 适用/ 的/ ./ Chandrasekaran/ [/ 18/ ]/ 等/ 研究/ 了/ 在/ DSMS/ 中/ 集成/ 历史/ 数据流/ 查询/ 的/ 问题/ ,/ 主要/ 工作/ 包括/ 存储管理/ 器降/ 载/ 及/ 查询/ 结果/ 精度/ 之间/ 的/ 折中/ 、/ 索引/ 插入/ 和/ 归档/ 查询/ 降载/ 及/ 各种/ 查询/ 在/ 实时/ 流/ 和/ 历史/ 数据流/ 上/ 的/ 无缝/ 执行/ [/ 19/ ]/ ./ 研究/ 通过/ 位/ 图/ 索引/ 对/ 历史/ 数据流/ 进行/ 存储/ 和/ 更新/ ./ 他们/ 的/ 工作/ 主要/ 针对/ 实时/ -/ 历史/ 数据流/ 上/ 的/ 聚集/ 、/ 统计/ 操作/ ,/ 不适/ 用于/ 复杂/ 事件/ 检测/ ./ 复杂/ 事件处理/ 的/ 相关/ 工作/ 包括/ 中间件/ [/ 20/ -/ 25/ ]/ 、/ RFID/ 数据流/ 上/ 的/ 复杂/ 事件/ 检测/ [/ 1/ ,/ 7/ ,/ 14/ ,/ 26/ -/ 27/ ]/ 、/ 乱序/ 数据流/ 上/ 的/ 复杂/ 事件/ 检测/ [/ 28/ -/ 31/ ]/ 、/ 嵌入/ 序列/ 复杂/ 事件/ 检测/ [/ 32/ ]/ 、/ 基于/ 不/ 确定/ 模型/ 的/ 事件/ 检测/ 等/ [/ 33/ ]/ ./ 其中/ 文献/ [/ 1/ ,/ 14/ ,/ 26/ ]/ 研究/ 在/ 实时/ 数据流/ 进行/ 复杂/ 事件/ 检测/ ,/ 没有/ 考虑/ 实时/ -/ 历史/ 数据流/ 集成/ 的/ 复杂/ 事件/ 检测/ ./ 文献/ [/ 7/ ]/ 是/ 作者/ 对/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 的/ 前期/ 基础/ 研究/ 工作/ ,/ 但/ 没有/ 更为/ 高效/ 的/ 中间/ 结果/ 管理/ 方案/ 和/ 复杂/ 事件/ 检测/ 优化/ 算法/ ./ 3/ 事件/ 模型/ 与/ 问题/ 定义/ 3.1/ 事件/ 模型/ 定义/ 1/ ./ 原始/ 事件/ ./ 原始/ 事件/ 是/ 指/ 不能/ 再/ 分解成/ 子/ 事件/ 的/ 事件/ ./ 原始/ 事件/ 是/ 由/ 一些/ 属性/ 组成/ 的/ 元组/ (/ tuple/ )/ ,/ 记为/ e/ (/ TID/ ,/ state/ ,/ Timestamp/ ,/ 〈/ attri/ -/ List/ 〉/ )/ ,/ 其中/ state/ 为/ 事件/ 类型/ 标识/ ,/ TID/ 为/ 对象/ 标识/ ,/ Timestamp/ 为/ 事件/ 发生/ 的/ 时间/ 戳/ ,/ 〈/ attriList/ 〉/ 为/ 事件/ 的/ 其它/ 属性/ 列表/ ./ 本文/ 中/ ,/ 事件/ 类型/ 用/ 大写字母/ E/ 表示/ ,/ E/ 对应/ 的/ 实例/ 用/ 小写/ e/ 表示/ ./ 原始/ 事件/ 语义/ 简单/ ,/ 实际/ 应用/ 中/ 需要/ 将/ 原始/ 事件/ 转换/ 为/ 语义/ 更为/ 丰富/ 的/ 复杂/ 事件/ ./ 定义/ 2/ ./ 复杂/ 事件/ ./ 将/ 原始/ 事件/ // 复杂/ 事件/ 通过/ 事件/ 算子/ ,/ 如/ SEQ/ (/ 序列/ )/ 、/ AND/ (/ 与/ )/ 、/ OR/ (/ 或/ )/ 、/ NOT/ (/ 非/ )/ 等/ ,/ 组合成/ 的/ 事件/ 称为/ 复杂/ 事件/ ./ 定义/ 3/ ./ 连续/ 模式/ ./ 对于/ 一个/ 模式/ P/ ,/ 如果/ 构成/ 该/ 模式/ 的/ 子/ 事件/ 要求/ 连续/ 地/ 出现/ 在/ 数据流/ 中/ ,/ 称/ 模式/ P/ 为/ 连续/ 模式/ ./ 定义/ 4/ ./ 离散/ 模式/ ./ 对于/ 一个/ 模式/ P/ ,/ 如果/ 构成/ 该/ 模式/ 的/ 子/ 事件/ 可以/ 出现/ 在/ 数据流/ 中/ 任何/ 位置/ ,/ 则/ 称/ 模式/ P/ 为/ 离散/ 模式/ ./ 可见/ ,/ 离散/ 模式/ 是/ 一种/ 更为/ 通用/ 的/ 模式/ ,/ 包含/ 了/ 连续/ 模式/ ./ 定义/ 5/ ./ 在线/ -/ 离线/ 数据流/ 上/ 事件/ 检测/ ./ 如果/ 复杂/ 事件/ 检测/ 由/ 在/ 实时/ 流上/ 的/ 模式/ 和/ 离线/ 流/ (/ 历史/ 流/ )/ 上/ 的/ 模式/ 组成/ ,/ 则/ 称为/ 在线/ -/ 离线/ 数据流/ 上/ 事件/ 检测/ ./ 3.2/ 复杂/ 事件/ 定义语言/ 复杂/ 事件/ 通过/ 事件/ 定义语言/ 描述/ ,/ 目前/ 常用/ 的/ 事件/ 定义语言/ 包括/ 类/ SQL/ 型/ 语言/ [/ 3/ ]/ 和/ 声明/ 型/ 语言/ [/ 1/ ]/ ./ 本文/ 对/ 文献/ [/ 3/ ]/ 的/ 基于/ SQL/ 的/ 复杂/ 事件/ 定义语言/ 进行/ 了/ 适当/ 的/ 扩充/ 以便/ 定义/ 在线/ -/ 离线/ 复杂/ 事件/ 查询/ ,/ 事件/ 定义语言/ 的/ 结构/ 如下/ :/ Page5SELECT/ 〈/ selectedfieldslist/ 〉/ FROM/ 〈/ streamsortables/ 〉/ MATCHRECOGNIZE/ (/ [/ PARTITIONBY/ ]/ [/ ORDERBY/ 〈/ fieldname/ 〉/ ]/ [/ MEASURES/ 〈/ measurelist/ 〉/ ]/ [/ ONE/ // AllROWPERMATCH/ ]/ [/ AFTERMATCHSKIPTONEXTROW/ // PASTLASTROW/ // …/ ]/ PATTERN/ (/ patterndescription/ )/ DEFINE/ 〈/ eventsconstraintslist/ 〉/ [/ WINDOW/ 〈/ windowspecification/ 〉/ ]/ )/ 其中/ MATCH/ _/ RECOGNIZE/ 子句/ 表示/ 模式匹配/ 的/ 入口/ ;/ PARTITIONBY/ 将/ 事件/ 流/ 按/ 某/ 属性/ 进行/ 分区/ ;/ ORDERBY/ 将/ 事件/ 流/ 按/ 一定/ 属性/ 排序/ ;/ MEA/ -/ SURES/ 子句/ 将/ 事件/ 的/ 一些/ 属性/ 重新命名/ ;/ ONE/ // ALLROWPERMATCH/ 和/ AFTERMATCHSKIPTONEXT/ 是/ 模式匹配/ 的/ 事件/ 选取/ 策略/ ;/ PATTERN/ 字句/ 中/ 定义/ 要/ 检测/ 的/ 模式/ ;/ DEFINE/ 描述/ 复杂/ 事件/ 的/ 约束条件/ ;/ WINDOW/ 子句/ 定义/ 了/ 复杂/ 事件/ 的/ 有效/ 时间/ 区间/ ./ 如图/ 3/ 所示/ ,/ (/ a/ )/ 表示/ 的/ 是/ Query2/ 定义/ 的/ 检测/ 在线/ -/ 离线/ 股票/ 流上/ 的/ 连续/ 模式/ ,/ (/ b/ )/ 中/ 描述/ 的/ 是/ 基于/ RFID/ 的/ 供应链/ 监控/ 中/ 数据流/ 上/ 的/ 离散/ 模式/ ./ 3.3/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 架构/ 在线/ -/ 离线/ 数据流/ 上/ 复杂/ 事件/ 检测/ 系统结构/ 如图/ 4/ 所示/ ./ 事件/ 流通/ 过/ 网络接口/ 进入/ 事件/ 流/ 路由器/ ,/ 事件/ 流/ 路由器/ 可以/ 过滤/ 一些/ 不/ 相关/ 的/ 数据流/ ./ 数据流/ 以/ 追加/ 的/ 方式/ 存储/ 于时/ 实流/ 缓冲区/ 中/ ,/ 该/ 缓冲区/ 的/ 数据/ 一方面/ 可以/ 为/ 实时/ 流上/ 的/ 复杂/ 事件/ 检测/ 提供/ 源/ 数据/ ,/ 一方面/ 也/ 可以/ 为/ 历史/ 流上/ 的/ 复杂/ 事件/ 检测/ 提供/ 源/ 数据/ ,/ 且/ 数据流/ 的/ 归档/ 可以/ 通过/ 该/ 缓冲区/ 批量/ 完成/ ./ 数据流/ 原始数据/ 存储/ 在/ 关系数据库/ 或/ 文件系统/ 中/ ,/ 并/ 可以/ 按/ 事件/ 的/ ID/ 或/ 时间/ 区间/ 进行/ 反复/ 读取/ ./ 历史/ 数据流/ 的/ 并发/ 读写/ 通过/ 信号量/ 来/ 控制/ ./ 在/ 事件/ 检测/ 过程/ 中/ ,/ 没有/ 达到/ 完全/ 匹配/ 且/ 没有/ 超出/ 滑动/ 窗口/ 的/ 部分/ 模式匹配/ 在/ 系统/ 负载/ 较大/ 的/ 时候/ 被/ 归档/ 到/ 部分/ 匹配/ 数据库/ 中/ ./ 数据流/ 处理/ 引擎/ 接收/ 用户/ 定义/ 的/ 复杂/ 事件/ 查询/ ,/ 并/ 将/ 事件/ 查询/ 解析/ 为/ 数据流/ 处理器/ 里/ 对应/ 的/ 查询/ 执行/ 模型/ (/ 如/ 自动机/ 、/ 树/ 或/ Petri/ 网/ )/ ,/ 数据流/ 处理器/ 分别/ 从/ 实时/ 流/ 、/ 历史/ 流/ (/ 通过/ 归档/ 事件/ 抽取/ 器/ )/ 和/ 部分/ 模式匹配/ 数据库/ (/ 通过/ 部分/ 匹配/ 抽取/ 器/ )/ 读取/ 相应/ 的/ 数据/ 进行/ 在线/ -/ 离线/ 复杂/ 事件/ 模式匹配/ ./ 归档/ 事件/ 抽取/ 器中/ 分别/ 以/ 事件/ 的/ ID/ (/ Hash/ 索引/ )/ 和/ 事件/ 归档/ 的/ 时间/ (/ B/ +/ 树/ 索引/ )/ 建立/ 二维/ 的/ 索引/ 结构/ ,/ 支持/ 单个/ 历史/ 事件/ 和/ 某个/ 时间/ 区间/ 上/ 的/ 历史/ 事件/ 的/ 访问/ ./ 部分/ 匹配/ 抽取/ 器中以/ 中间/ 结构/ 的/ ID/ 构建/ Hash/ 索引/ ,/ 以/ 支持/ 快速/ 的/ 中间/ 结果/ 的/ 读取/ 、/ 更新/ 及/ 删除/ 操作/ ./ 4/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 在线/ -/ 离线/ 流/ 上/ 复杂/ 事件/ 检测/ 需要/ 在/ 实时/ 数据流/ 和/ 历史/ 数据流/ 上/ 进行/ ,/ 由于/ 实时/ 流/ 和/ 历史/ 流/ 处理/ 模式/ 的/ 不同/ 而/ 导致/ 复杂/ 事件/ 检测/ 响应/ 时间/ 的/ 不同/ ./ 本节/ 介绍/ 两种/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 算法/ 并/ 分析/ 它们/ 的/ 代价/ 模型/ ,/ 代价/ 模型/ 的/ 相关/ 标识/ 如表/ 1/ 所示/ ./ Page6/ 标记/ WLInstRAPLPAPMCostLCostANInstLNInstACostWDBCostWPMCostRDBCostPL/ / / PANP4/ ./ 1/ 主动/ 在线/ -/ 离线/ 事件/ 检测/ 算法/ 在线/ -/ 离线/ 数据流/ 上/ 复杂/ 事件/ 检测/ 的/ 一种/ 算法/ 为/ 主动/ 算法/ (/ ActiveLive/ -/ ArchivedEventDetectionAlgorithm/ ,/ ALAA/ )/ ./ ALAA/ 的/ 算法/ 描述/ 如/ 算法/ 1/ 所示/ ./ 算法/ 1/ ./ 主动/ 在线/ -/ 离线/ 事件/ 检测/ 算法/ ./ 输入/ :/ PL/ ,/ PA/ ,/ WL/ ,/ RA/ 输出/ :/ 检测/ 到/ 的/ 复杂/ 事件/ CECoBegin1/ ./ 初始化/ 实例/ 链表/ PML/ 、/ PML/ 、/ InstL/ 和/ InstA/ 为/ Null/ ;/ 2/ ./ 对于/ 实时/ 流/ 上/ 滑动/ 窗口/ WL/ 内/ 的/ 事件/ 3/ ./ 进行/ 复杂/ 事件/ PL/ 的/ 检测/ ;/ 4/ ./ 将/ 达到/ 最大/ 状态/ 的/ PL/ 实例/ 放入/ InstL/ 中/ ;/ 5/ ./ 将/ 未/ 达到/ 最大/ 状态/ 的/ PL/ 实例/ 放入/ 中间/ 结果/ 集合/ 6/ ./ 计算/ 最大/ 的/ 历史/ 流/ 访问/ 区间/ Rmax/ ;/ 7/ ./ 对于/ Rmax/ 内/ 的/ 事件/ 8/ ./ 进行/ 复杂/ 事件/ PA/ 的/ 检测/ ;/ 9/ ./ 将/ 达到/ 最大/ 状态/ 的/ PA/ 实例/ 放入/ InstA/ 中/ ;/ 10/ ./ 将/ 未/ 达到/ 最大/ 状态/ 的/ PA/ 实例/ 放入/ 中间/ 结果/ 集/ 11/ ./ 将/ InstL/ 中/ 的/ 实例/ 与/ InstA/ 中/ 的/ 实例/ 在/ EventID/ 属/ 12/ ./ CE/ =/ InstL/ / / EventID/ ∧/ RAi/ ∧/ PInstA/ ;/ 13/ ./ 归档/ 历史/ 流/ 数据/ ,/ 处理/ 下/ 一个/ 滑动/ 窗口/ WL/ ;/ CoEndALAA/ 算法/ 对于/ 实时/ 数据流/ 上/ PL/ 和/ 历史/ 数据流/ 上/ PA/ 的/ 检测/ 是/ 并行/ 进行/ 的/ ,/ 并/ 通过/ 消息/ 进行/ 通信/ ./ 当/ 实时/ 流/ 上/ 检测/ 完/ 一个/ 滑动/ 窗口/ WL/ 长度/ 的/ PL/ 后/ ,/ SP/ E通/ 知/ 复杂/ 事件/ 连接器/ 将/ InstL/ 中/ 的/ 实例/ 和/ 已/ 检测/ 出/ 的/ InstA/ 实例/ 进行/ 事件/ 标识/ (/ EventID/ )/ 或/ 其它/ 属性/ (/ 如/ RAi/ ,/ P/ )/ 的/ 连接/ 操作/ ,/ 生成/ 最后/ 可以/ 输出/ 的/ 复杂/ 事件/ ./ ALAA/ 算法/ 示意/ 如图/ 5/ 所示/ ./ ALAA/ 算法/ 的/ 代价/ 模型/ ./ ALAA/ 算法/ 的/ 代价/ 模型/ 主要/ 由/ 下面/ 几/ 部分/ 组成/ :/ (/ 1/ )/ 在/ 实时/ 流/ 上/ 进行/ PL/ 事件/ 检测/ 的/ 代价/ ;/ (/ 2/ )/ 在/ 历史/ 流/ 上/ 进行/ PA/ 事件/ 检测/ 的/ 代价/ ,/ 这部分/ 代价/ 包括/ 将/ 实时/ 数据流/ 归档/ 的/ 代价/ 和/ 将/ 数据流/ 从/ 外存/ 读取/ 到/ 内存/ 的/ 代价/ ;/ (/ 3/ )/ 将/ InstA/ 实例/ 和/ InstA/ 实例/ 进行/ 连接/ 操作/ 的/ 代价/ :/ CostALAA/ =/ |/ WL/ |/ ×/ CostL/ +/ |/ Rmax/ |/ ×/ CostRDB/ +/ |/ Rmax/ |/ ×/ CostA/ +/ CostPL/ / / PA/ ×/ NInstL/ ×/ NInstA/ (/ 1/ )/ 从/ 代价/ 模型/ 可以/ 看出/ ,/ 实时/ 流/ 滑动/ 窗口/ WL/ 的/ 长度/ 和/ 数据流/ 的/ 流速/ 决定/ 了/ 复杂/ 事件/ 的/ 数目/ ,/ 数据流/ 流速/ 越大/ ,/ 窗口/ 长度/ 越长/ ,/ 则/ 实时/ 流/ 上/ 复杂/ 事件/ 检测/ 所/ 需要/ 的/ 计算资源/ 就/ 更/ 多/ ,/ 计算/ 代价/ 也/ 增大/ ./ 此外/ ,/ 由于/ 实时/ 数据流/ 是/ 缓冲/ 在/ 一个/ 缓冲区/ 结构/ 中/ ,/ 该/ 缓冲区/ 在/ 为/ 复杂/ 事件/ 检测/ 提供/ 数据源/ ,/ 同时/ 已经/ 处理/ 的/ 数据流/ 也/ 将/ 以/ 批量/ 方式/ 插入/ 数据库/ ,/ 所以/ 缓冲区/ 的/ 大小/ 决定/ 了/ 批量/ 插入/ 的/ 规模/ ,/ 这里/ 需注意/ 的/ 是/ :/ 缓冲区/ 越大/ ,/ 给/ SPE/ 所能/ 分配/ 的/ 存储资源/ 就/ 越/ 小/ ,/ 同时/ ,/ 批量/ 插入/ 数据库/ 的/ 代价/ CostWDB/ 也/ 将/ 增加/ ./ 最后/ ,/ 实时/ 和/ 历史/ 流上/ 的/ 复杂/ 事件/ 实例/ 连接/ 操作/ 代价/ CostPL/ / / PA/ 为/ 在/ 所有/ 已/ 检测/ 出来/ 的/ InstA/ 和/ InstL/ 上/ 进行/ 连接/ 操作/ 的/ 代价/ ./ ALAA/ 算法/ 的/ 不足/ 在于/ 它/ 需要/ 检测/ 历史/ 流中/ 所有/ 存在/ 的/ PA/ 模式/ 实例/ ,/ 无论/ 该/ 实例/ 是否/ 参加/ 后续/ 的/ 模式匹配/ ./ 可以/ 看出/ ,/ ALAA/ 算法/ 是/ 一种/ 直接/ 但/ 比较/ 盲目/ 的/ 算法/ ,/ 它/ 没有/ 利用/ 到/ 数据流/ 中/ 各个/ 事件/ 类型/ 的/ 选择/ 度/ 特性/ 来/ 减少/ 复杂/ 事件/ 检测/ 的/ 计算/ 代价/ ./ 因此/ ,/ 我们/ 介绍/ 另外/ 一种/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 算法/ ./ 4.2/ 被动/ 在线/ -/ 离线/ 事件/ 检测/ 算法/ 在线/ -/ 离线/ 数据流/ 上/ 复杂/ 事件/ 检测/ 的/ 另外/ 一种/ 算法/ 为/ 被动/ 算法/ (/ LazyLive/ -/ ArchivedEventDetec/ -/ tionAlgorithm/ ,/ LLAA/ )/ ./ 与/ 主动/ 算法/ 不同/ ,/ 被动/ 算法/ 只有/ 在/ 其中/ 一个/ 数据流/ 上/ 检测/ 出/ 达到/ 最大/ 状态/ 的/ 实例/ 后/ 才/ 触发/ 另外/ 一个/ 数据流/ 上/ 的/ 复杂/ 事件/ 检测/ ./ LLAA/ 算法/ 的/ 执行/ 是/ 一个/ 顺序/ 交替/ 的/ 过程/ ,/ 如/ 算法/ 2/ 所示/ ./ 算法/ 2/ ./ 被动/ 在线/ -/ 离线/ 事件/ 检测/ 算法/ ./ 输入/ :/ PL/ ,/ PA/ ,/ WL/ ,/ RA/ 输出/ :/ 检测/ 到/ 的/ 复杂/ 事件/ CE1/ ./ 对于/ 实时/ 流/ WL/ 内/ 的/ 每个/ 事件/ eiPage72/ ./ 检测/ 是否/ 存在/ 对应/ 的/ PL/ 实例/ InstLi3/ ./ 如/ 存在/ ,/ 但/ 将/ ei/ 的/ 状态/ 更新/ 至/ InstLi/ 后/ 没/ 达到/ 4/ ./ 如/ 存在/ ,/ 且/ 将/ ei/ 的/ 状态/ 更新/ 至/ InstLi/ 后/ 达到/ 最/ 5/ ./ 计算/ InstLi/ 的/ 历史/ 流/ 访问/ 区间/ RAi/ ;/ 6/ ./ 将/ RAi/ 对应/ 的/ 数据流/ 读取/ 到/ 内存/ ,/ 检测/ 历史/ 流/ 7/ ./ 在/ 事件/ ID/ 属性/ 上/ 对/ 实例/ InstLi/ 和/ InstAj/ 进/ 8/ ./ 输出/ CEi/ ;/ 9/ ./ 处理/ WL/ 中/ 的/ 下/ 一/ 事件/ e/ ./ LLAA/ 算法/ 的/ 执行/ 示意图/ 如图/ 6/ 所示/ ./ 算法/ 的/ 执行/ 可以/ 从/ 实时/ 流/ 或/ 历史/ 流上/ 的/ 事件/ 检测/ 的/ 任意/ 一边/ 开始/ ./ 算法/ 2/ 中/ 是从/ 实时/ 流/ 开始/ ./ 当/ 实时/ 流/ 上/ 检测/ 到/ 一个/ PL/ 实例/ 后/ ,/ 就/ 触发/ 一次/ 归档/ 流上/ 的/ PA/ 的/ 复杂/ 事件/ 检测/ ./ 为了/ 减少/ 数据流/ 的/ 重复/ 扫描/ 和/ 计算/ ,/ LLAA/ 算法/ 一次/ 把/ RAi/ 对应/ 的/ 历史/ 流/ 加载/ 进/ 内存/ 并/ 将/ RAi/ 上/ 的/ 所有/ 的/ PA/ 实例/ 都/ 检测/ 出来/ ,/ 此/ 操作/ 是/ 基于/ 对/ 实际/ 应用/ 场景/ 中/ 的/ 观察/ :/ 相似/ 的/ 模式/ 总有/ 聚集/ 出现/ 的/ 现象/ ,/ 如/ 在/ 一个/ 传送带/ 上/ ,/ 监控/ 物品/ 经过/ 某/ 几个/ 点/ 的/ 路径/ 总是/ 聚集/ 在/ 数据流/ 的/ 一个/ 事件/ 区间/ 上/ 出现/ ./ 当/ RAi/ 上/ 的/ 所有/ 的/ PA/ 实例/ 都/ 检测/ 出来/ 后/ ,/ 将/ 实时/ 流上/ 的/ InstLi/ 实例/ 与/ 它们/ 进行/ 一些/ 约束/ 关系/ (/ 如/ EventIDi/ ,/ RA/ 等/ )/ 的/ 连接/ 操作/ ,/ 生成/ 可/ 输出/ 的/ 复杂/ 事件/ ,/ 然后/ 进行/ 下/ 一个/ 实时/ 流/ 事件/ 的/ 处理/ ./ LLAA/ 算法/ 的/ 代价/ 模型/ ./ LLAA/ 算法/ 的/ 代价/ 模型/ 包括/ 如下/ 几/ 部分/ :/ (/ 1/ )/ 处理/ 实时/ 流/ WL/ 中/ 的/ 每个/ 事件/ 的/ 代价/ ;/ (/ 2/ )/ 读取/ InstLi/ 对应/ 的/ 历史/ 流/ 到/ 内存/ 的/ 代价/ ;/ (/ 3/ )/ 在/ InstLi/ 对应/ 的/ 历史/ 流/ 上/ 进行/ PA/ 检测/ 的/ 代价/ ;/ (/ 4/ )/ InstL/ 与/ InstA/ 进行/ 连接/ 操作/ 的/ 代价/ :/ CostLLAA/ =/ WL/ ×/ CostL/ +/ NInstL/ ×/ CostRDB/ +/ ∑/ NInstL/ 在/ 该/ 代价/ 模型/ 中/ ,/ NInstL/ ×/ CostRDB/ 为/ 所有/ 达到/ 最大/ 状态/ 的/ 实时/ 流上/ 的/ 实例/ 触发/ 的/ 历史/ 流/ 访问/ 的/ 代价/ ,/ ∑/ NInstLRAi/ 上/ 的/ 复杂/ 事件/ 的/ 代价/ ,/ CostPL/ / / PA/ ×/ NP/ 为/ 实时/ 流/ i/ =/ 1/ 和/ 归档/ 流/ 上/ 达到/ 最大/ 状态/ 的/ 实例/ 连接/ 操作/ 的/ 代价/ ./ LLAA/ 算法/ 的/ 复杂度/ 为/ O/ (/ |/ WL/ |/ ×/ |/ RA/ |/ )/ ./ LLAA/ 算法/ 是/ 一种/ 基于/ 实时/ 流上/ 单/ 实例/ 驱动/ 的/ 算法/ ,/ 即/ 只有/ 实时/ (/ 历史/ )/ 数据流/ 上/ 存在/ 一个/ 最大/ 状态/ 的/ 实例/ 时/ ,/ 才/ 触发/ 另外/ 一个/ 数据流/ 上/ 的/ 复杂/ 事件/ 检测/ ./ 实际上/ ,/ 基于/ 单个/ 实例/ 的/ LLAA/ 事件/ 检测/ 的/ 方法/ 没有/ 利用/ 到/ 实时/ 流/ 上/ 临近/ 的/ 实例/ 访问/ 历史/ 流/ 区间/ 重叠/ ,/ 导致/ 多次/ 外存/ 数据/ 的/ 请求/ 和/ 重复/ 的/ 计算/ ,/ 因此/ 在/ 下节/ 我们/ 介绍/ 如何/ 利用/ 数据流/ 的/ 选择/ 度/ 和/ 模式/ 的/ 聚集/ 特点/ 优化/ LLAA/ 算法/ ./ 需要/ 注意/ 的/ 是/ ,/ 本文/ 提出/ 的/ LLAA/ 算法/ 和/ 文献/ [/ 6/ ]/ 中/ 的/ LazyPatternProcessing/ 都/ 是/ 基于/ 触发式/ 的/ 查询处理/ 方法/ ,/ 即先/ 在/ 实时/ 流/ 上/ 循环/ 处理/ ,/ 待/ 检测/ 到/ 一个/ 实时/ 流/ 的/ 实例/ 后/ ,/ 再作/ 历史/ 流/ 的/ 处理/ ./ 在/ 文献/ [/ 6/ ]/ 中/ ,/ 由于/ 针对/ 的/ 是/ 连续/ 模式/ 的/ 查询/ ,/ 第一次/ 历史/ 流/ 访问/ 后/ 的/ 所有/ 实例/ 按/ 时间/ 顺序存储/ ,/ 并/ 在/ 新/ 的/ 实时/ 流/ 实例/ 被/ 检测/ 到/ 时/ 删除/ 不/ 可能/ 存在/ 匹配/ 的/ 历史/ 流上/ 的/ 实例/ ./ 由于/ 本文/ 处理/ 的/ 是/ 离散/ 模式/ ,/ 触发/ 历史/ 流/ 访问/ 的/ 实例/ 可能/ 存在/ 于/ 实时/ 流/ 的/ 任何/ 位置/ ,/ 因此/ 需要/ 缓存/ 很多/ 实时/ 流/ 的/ 实例/ ,/ 且/ 每个/ 实时/ 流/ 实例/ 访问/ 历史/ 流/ 的/ 时机/ 不/ 一样/ ,/ 因此/ 历史/ 流/ 上/ 计算出来/ 的/ 实例/ 也/ 不能/ 简单/ 的/ 删除/ ./ 所以/ ,/ 本文/ 的/ LLAA/ 虽/ 在结构上/ 和/ 文献/ [/ 6/ ]/ 相似/ ,/ 但/ 因为/ 处理/ 的/ 问题/ 的/ 差异/ ,/ 所/ 需要/ 的/ 存储/ 和/ 计算/ 代价/ 是/ 不/ 一样/ 的/ ./ 另外/ ,/ 本文/ 使用/ B/ +/ 树结构/ 存储/ 原始/ 事件/ 和/ 中间/ 结果/ ,/ 可以/ 更为/ 快捷/ 地/ 进行/ 状态/ 更新/ 、/ 批量/ 数据库/ 插入/ 、/ 批量/ 过期/ 事件/ 的/ 删除/ 等/ 操作/ ./ 4.3/ 优化/ LLAA/ 算法/ P/ 选择/ 度/ SelP/ 定义/ 为/ 定义/ 6/ ./ 选择/ 度/ ./ 给定/ 一个/ 模式/ P/ ,/ 事件/ 流/ S/ ,/ 即/ 数据流/ 上/ 匹配/ 模式/ P/ 的/ 实例/ 的/ 数目/ 占/ 事件/ 流/ 大小/ 的/ 比例/ ./ 可见/ SelP/ 越大/ ,/ 则/ 表明/ 事件/ 流/ S/ 中/ 匹配/ P/ 的/ 实例/ 数目/ 越/ 多/ ;/ SelP/ 越小/ ,/ S/ 中/ 匹配/ P/ 的/ 实例/ 数目/ 越小/ ./ SelP/ 常来/ 确定/ 最佳/ 的/ 查询/ 执行/ 计划/ (/ 如/ 连接/ 操作/ 中/ ,/ 用/ 较/ 小S/ elP/ 的/ 对象/ 集合/ 连接/ 较/ 大S/ elP/ 集合/ 可/ 大大减少/ 连接/ 操作/ 的/ 代价/ )/ ./ (/ 1/ )/ 基于/ SelP/ 的/ LLAA/ 算法/ 优化/ 在/ LLAA/ 算法/ 中/ ,/ SelP/ 可以/ 用来/ 选择/ 实时/ 流/ 和/ 历史/ 流/ 的/ 连接/ 顺序/ ,/ 如/ SelPL/ </ SelPA/ ,/ 则/ InstL/ / / InstA/ 可以/ 减少/ 历史/ 流/ 的/ 加载/ 和/ 重复/ 计算/ ;/ 如果/ SelPA/ </ SelPL/ ,/ InstA/ / / InstL/ 可以/ 减少/ 实时/ 流/ 上/ 不会/ 产生/ 最终/ 输出/ 的/ 模式匹配/ 的/ 计算/ ./ 由于/ 历史/ 流/ 存储/ 在/ 静态/ 的/ 文件/ 或/ 数据库/ 上/ ,/ 其/ 选择/ 度/ 可以/ 通过/ 数据库/ 管理/ Page8/ 系统/ 的/ 工具/ 得到/ ;/ 对于/ 实时/ 流/ ,/ 选择/ 度/ 可以/ 通过/ 应用/ 场景/ 的/ 先验/ 知识/ 或/ 进行/ 统计/ 抽样/ 等/ 技术/ 计算/ ./ 基于/ 选择/ 度/ 的/ 实时/ 流/ -/ 历史/ 流/ 连接/ 顺序/ 选择/ 如图/ 7/ 所示/ ./ 图/ 7/ 中/ ,/ 实时/ 流/ 的/ 滑动/ 窗口/ WL/ 中有/ 3/ 个/ PL/ 实例/ ,/ 而/ WL/ 对应/ 的/ 历史/ 流/ 访问/ 区间/ RA/ 中有/ 6/ 个/ PA/ 实例/ ,/ SelPL/ </ SelPA/ ,/ 所以/ 在/ 当前/ 滑动/ 窗口/ 中/ 选择/ 实时/ 流/ 连接/ 历史/ 流以/ 减少/ 历史/ 流/ 的/ 加载/ 与/ 计算/ ./ 图/ 7LLAA/ 算法/ 数据流/ 连接/ 顺序/ 选择/ 示意图/ (/ 2/ )/ 基于/ 子/ 窗口/ 的/ LLAA/ 算法/ 优化/ 虽然/ 通过/ 选择/ 度/ 可以/ 减少/ 部分/ 历史/ 流/ 的/ 加载/ 与/ 计算/ ,/ 但/ 当/ WL/ 存在/ 多个/ PL/ 实例/ ,/ 且/ 每个/ 实例/ 都/ 对应/ 自己/ 的/ 归档/ 流/ 访问/ 请求/ ,/ 如果/ 采用/ 检测/ 到/ 一个/ PL/ 实例/ 触发/ 一次/ 历史/ 流/ 的/ 访问/ 与/ 计算/ ,/ 将会/ 导致/ 多次/ 数据流/ 的/ 请求/ ,/ 且/ 没有/ 利用/ 到/ 临近/ PL/ 实例/ 访问/ 的/ 历史/ 流/ 具有/ 交叉/ 的/ 性质/ ./ 如图/ 8/ 所示/ ,/ 实时/ 流/ 上/ 存在/ 7/ 个/ PL/ 实例/ PL1/ ~/ PL7/ ,/ 如果/ 按照/ 算法/ 2/ 的/ 复杂/ 事件/ 检测/ 方法/ ,/ 需要/ 进行/ 7/ 次/ 历史/ 流/ 访问/ ,/ 虽然/ 可以/ 通过/ 结果/ 缓存/ 共享/ 一次/ 加载/ 的/ 历史/ 流/ 计算结果/ ,/ 但是/ 两个/ 历史/ 流未/ 交叉/ 的/ 部分/ 还/ 需要/ 加载/ 和/ 计算/ ./ 如图/ 8/ 中/ 的/ 历史/ 流/ 访问/ 区间/ RA2/ -/ RA3/ ,/ RA4/ -/ RA5/ -/ RA6/ ,/ 它们/ 之间/ 都/ 存在/ 交叉/ ,/ 此时/ 如果/ 将/ RA2/ -/ RA3/ ,/ RA4/ -/ RA5/ -/ RA6/ 分别/ 作为/ 一个/ 处理单元/ 进行/ 加载/ 和/ 计算/ ,/ 可以/ 减少/ 数据库/ 的/ 访问/ 请求/ 操作/ 和/ 重复/ 计算/ ./ 图/ 8/ 基于/ 子/ 窗口/ 的/ LLAA/ 算法/ 执行/ 示意图/ 因此/ ,/ 我们/ 利用/ 实例/ 间/ 的/ 聚集/ 特性/ 将/ 滑动/ 窗口/ 划分/ 为/ 多个/ 子/ 窗口/ ,/ 以子/ 窗口/ 为/ 单位/ 进行/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ ./ 如何/ 选择/ 合适/ 大小/ 的/ 子/ 窗口/ 与/ 复杂/ 事件/ 输出/ 的/ 延迟/ 直接/ 相关/ :/ 如果/ 子/ 窗口/ 选择/ 较/ 小/ ,/ 则/ 可能/ 导致/ 多次/ 的/ 历史/ 流/ 访问/ 请求/ 和/ 计算/ ,/ 增加/ 响应/ 时间/ ;/ 如果/ 子/ 窗口/ 选择/ 较大/ ,/ 则/ 可能/ 导致/ 较长/ 的/ 复杂/ 事件/ 输出/ 的/ 延迟/ ./ 引理/ 1/ ./ 给定/ 一个/ 在线/ -/ 离线/ 复杂/ 事件/ 查询/ ,/ 一个/ 用户/ 定义/ 的/ 容忍/ 延迟时间/ TL/ ,/ 对于/ 滑动/ 窗口/ |/ min/ {/ Ik/ / estart/ / time/ }/ -/ Ii/ +/ j/ / eend/ / time/ |/ / TLW/ 内/ 达到/ 最大/ 状态/ 的/ 复杂/ 事件/ 实例/ 序列/ I1/ ,/ I2/ ,/ …/ ,/ In/ ,/ 实例/ Ii/ ,/ Ii/ +/ 1/ ,/ …/ ,/ Ii/ +/ j/ 被/ 划分/ 到/ 第/ i/ 个子/ 窗口/ WSubi/ 当且/ 仅/ 当且/ |/ min/ {/ Ik/ / estart/ / time/ }/ -/ Ii/ +/ j/ +/ 1/ / eend/ / time/ |/ / TL/ ./ 其中/ ,/ i/ / k/ / (/ i/ +/ j/ )/ ,/ Ii/ / estart/ / time/ 表示/ 第/ i/ 个/ 达到/ 最大/ 状态/ 的/ 实例/ 的/ 最后/ 一个/ 子/ 事件/ 的/ 时间/ 戳/ ,/ Ii/ / eend/ / time/ 表示/ 第/ i/ 个/ 达到/ 最大/ 状态/ 的/ 实例/ 的/ 最后/ 一个/ 子/ 事件/ 的/ 时间/ 戳/ ./ 引理/ 1/ 表明/ WSubi/ 的/ 长度/ 为/ 该/ 窗口/ 中/ 具有/ 最大/ eend/ / time/ 的/ 实例/ 与/ 具有/ 最小/ estart/ / time/ 的/ 实例/ 的/ 时间差/ ./ 基于/ 子/ 窗口/ 的/ LLAA/ 如/ 算法/ 3/ 所示/ ./ 算法/ 3/ ./ 基于/ 子/ 窗口/ 的/ LLAA/ 算法/ (/ SLLAA/ )/ 输入/ :/ PL/ ,/ PA/ ,/ WL/ ,/ RA/ ,/ TL/ 输出/ :/ 检测/ 到/ 的/ 复杂/ 事件/ CE1/ ./ 对/ WL/ 中/ 的/ 事件/ 进行/ 复杂/ 事件/ PL/ 的/ 检测/ ;/ 2/ ./ 根据/ 引理/ 1/ 计算/ 子/ 窗口/ WSub/ 的/ 大小/ ;/ 3/ ./ 计算/ WSub/ 中/ 实例/ 访问/ 历史/ 流/ 的/ 最大/ 区间/ RAi/ =/ 4/ ./ 对于/ RAi/ 内/ 的/ 事件/ 5/ ./ 进行/ 复杂/ 事件/ PA/ 的/ 检测/ ;/ 6/ ./ 将/ 达到/ 最大/ 状态/ 的/ PA/ 实例/ 放入/ InstAj/ 中/ ,/ 7/ ./ 如果/ RAi/ 中/ 的/ 事件/ 已/ 处理/ 完/ 8/ ./ 将/ InstLi/ 中/ 的/ 实例/ 与/ InstAj/ 中/ 的/ 实例/ 在/ 9/ ./ 输出/ 满足/ 约束/ 的/ 复杂/ 事件/ CE/ ;/ 10/ ./ 处理/ 滑动/ 窗口/ WL/ 内/ 的/ 其它/ 事件/ ;/ 11/ ./ 如/ 当前/ WL/ 一/ 处理/ 完/ ,/ 删除/ 失效/ 的/ 事件/ 和/ 中间/ 在/ 算法/ 3/ 中/ ,/ 滑动/ 窗口/ WL/ 按/ 实例/ 聚集/ 被/ 划分/ 为/ 若干/ 小/ 的/ 子/ 窗口/ WSub/ ,/ 离线/ 复杂/ 事件/ 检测/ 以子/ 窗口/ 为/ 单位/ 进行/ ,/ 子/ 窗口/ 的/ 大小/ 决定/ 历史/ 流/ 的/ 访问/ 和/ 计算/ 频率/ :/ 如果/ |/ WSub/ |/ =/ 1/ ,/ 复杂/ 事件/ 检测/ 就/ 等价/ 于/ LLAA/ 算法/ ;/ 如果/ 子/ 窗口/ 过大/ ,/ 如/ |/ WSub/ |/ =/ |/ WL/ |/ ,/ 即将/ 整个/ 窗口/ 的/ 实时/ 流/ 处理/ 完后/ 再/ 进行/ 历史/ 流/ 的/ 处理/ ,/ 则/ 复杂/ 事件/ 检测/ 的/ 平均/ 响应/ 时间/ 将/ 增加/ ./ SLLAA/ 算法/ 的/ 代价/ 模型/ 如下/ :/ CostLLAA/ =/ |/ WL/ |/ ×/ CostL/ +/ n/ ×/ CostRDB/ +/ Page9i/ =/ 1/ 其中/ n/ ×/ CostRDB/ 为/ 以/ n/ 个/ WSub/ 单位/ 读取/ 数据库/ 的/ 代价/ ,/ ∑/ n/ 匹配/ 的/ 代价/ ./ SLLAA/ 的/ 算法/ 复杂度/ 为/ O/ (/ |/ WL/ |/ )/ maxi/ ∈/ [/ 1/ ,/ n/ ]/ {/ |/ RAi/ |/ }/ )/ ,/ 可以/ 看到/ ,/ 只要/ 选择/ 了/ 合适/ 的/ n/ ,/ SLLAA/ 算法/ 的/ 代价/ 比/ LLAA/ 的/ 要/ 小/ 很多/ ./ 以/ 实时/ 流/ 上/ 达到/ 最大/ 状态/ 的/ 实例/ 集合/ 为/ 单位/ 进行/ 历史/ 流/ 访问/ 时/ ,/ 为了/ 确保/ 事件/ 检测/ 的/ 完整性/ (/ 防止/ 复杂/ 事件/ 的/ 漏检/ )/ 和/ 一致性/ ,/ 需要/ 将/ 实时/ 流/ 和/ 历史/ 流上/ 未/ 达到/ 最大/ 状态/ ,/ 但/ 生命周期/ 还/ 在/ 滑动/ 窗口/ WL/ 内/ 的/ 部分/ 匹配/ 结果/ 缓存/ 起来/ ,/ 以便/ 后续/ 的/ 事件/ 检测/ 进行/ 相应/ 的/ 状态/ 更新/ ./ 5/ 中间/ 结果/ 管理/ 随着/ 数据流/ 的/ 流速/ 的/ 变化/ 和/ 复杂/ 事件/ 检测/ 的/ 推进/ ,/ 复杂/ 事件/ 检测/ 将/ 产生/ 大量/ 未/ 到达/ 最大/ 状态/ 的/ 部分/ 模式匹配/ 结果/ (/ partialpatternmatchresults/ 简称/ 中间/ 结果/ ,/ PM/ )/ ./ 例如/ 在/ 一个/ 基于/ RFID/ 的/ 实时/ 物品/ 监控/ 场景/ 中/ ,/ 用户/ 定义/ 一个/ 检测/ 10h/ 内/ 经过/ RFID/ 阅读器/ A/ ,/ B/ ,/ C/ 和/ D/ 的/ 物品/ ,/ 该/ 复杂/ 事件/ 可以/ 描述/ 为/ 一个/ 序列/ (/ SEQ/ )/ 模式/ P/ =/ SEQ/ (/ A/ ;/ B/ ;/ C/ ;/ D/ )/ [/ 10h/ ]/ ,/ 假设/ 滑动/ 窗口/ 为/ tumbling/ 类型/ (/ 处理/ 完一/ 整个/ 窗口/ 后/ 向前/ 滑动/ )/ ,/ 模式匹配/ 缓冲区/ 大小/ 是/ 固定/ 的/ ./ 则/ 在/ 缓冲区/ 中/ 存在/ 着/ 的/ 中间/ 结果/ 集/ PM/ =/ {/ A/ ,/ SEQ/ (/ A/ ;/ B/ )/ ,/ SEQ/ (/ A/ ;/ B/ ;/ C/ )/ }/ 的/ 实例/ ,/ 这些/ 实例/ 随着/ 复杂/ 事件/ 的/ 推进/ 可能/ 溢出/ 缓冲区/ ,/ 为了/ 保证/ 复杂/ 事件/ 检测/ 的/ 完整性/ 和/ 一致性/ ,/ 需要/ 对/ 这些/ 没有/ 超出/ 滑动/ 窗口/ 区间/ 的/ 中间/ 结果/ 进行/ 归档/ ,/ 并/ 在/ 复杂/ 事件/ 检测/ 过程/ 中/ 不断更新/ 它们/ 的/ 状态/ ./ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 同样/ 存在/ 中间/ 结果/ 管理/ 的/ 问题/ ,/ 我们/ 主要/ 针对/ 实时/ 流/ 介绍/ 相关/ 管理/ 算法/ ,/ 历史/ 流/ 的/ 中间/ 结果/ 管理/ 类似/ ./ 5.1/ 基于/ 时态/ 的/ 中间/ 结果/ 管理/ 基于/ 时态/ 的/ 中间/ 结果/ 管理/ (/ TemporalPartialMatchManagement/ ,/ TPM/ )/ 方法/ 如图/ 9/ 所示/ ./ 中间/ 结果/ 按/ 产生/ 的/ 时间/ 顺序/ 被/ 放入/ 中间/ 结果/ 缓冲区/ ,/ 缓冲区/ 中/ 存储/ 的/ 是/ 中间/ 结果/ 的/ 全部/ 信息/ (/ 例如/ 事件/ 标识符/ TID/ 、/ 事件/ 的/ 状态/ State/ 、/ 中间/ 结果/ 产生/ 的/ 时间/ TS/ 和/ 最后/ 更新/ 的/ 时间/ TE/ )/ ,/ 通过/ 一个/ B/ +/ 树/ 数据结构/ 来/ 辅助/ 中间/ 结果/ 的/ 状态/ 更新/ 操作/ 和/ 插入/ ,/ 其中/ B/ +/ 树/ 的/ 键值/ 为/ (/ TID/ ,/ State/ )/ ,/ 树/ 的/ 叶/ 节点/ 指向/ 对应/ 的/ 中间/ 结果/ 实体/ ,/ 其/ 记录/ 一直/ 存储/ 在/ 内存/ 中/ ,/ 直至/ 对应/ 的/ 中间/ 结果/ 输出/ 复杂/ 事件/ 或/ 该/ 中间/ 结果/ 无效/ 才/ 被/ 删除/ ./ 中间/ 结果/ 缓冲区/ 有/ 一个/ 归档/ 的/ 界限/ ,/ 当/ 达到/ 这个/ 界限/ 时/ 就/ 通过/ PMR/ 将/ 对应/ 区间/ 上/ 的/ 中间/ 结果/ 写入/ 到/ 外存/ 文件系统/ ./ 当/ 数据流/ 中/ 的/ 事件/ 触发/ 中间/ 结果/ 状态/ 更新/ 时/ ,/ 如该/ 中间/ 结果/ 不/ 在/ 缓冲区/ ,/ 则/ 通过/ PMR/ 将/ 其/ 读入/ ,/ 并/ 进行/ 状态/ 更新/ 操作/ ./ TPM/ 是/ 一种/ 利用/ 中间/ 的/ 时态/ 关系/ 管理/ 中间/ 结果/ 的/ 方法/ ,/ 可以/ 看到/ ,/ 当/ 数据流/ 的/ 流速/ 增加/ 时/ ,/ TPM/ 会/ 频繁/ 地/ 将/ 产生/ 的/ 中间/ 结果/ 归档/ 到/ 外存/ ,/ 而/ 当/ 实时/ 流中/ 的/ 事件/ 触发/ 中间/ 结果/ 状态/ 更新/ 时/ ,/ 由于/ 其/ 对应/ 的/ 中间/ 结果/ 有/ 可能/ 不/ 在/ 内存/ 中/ ,/ TPM/ 需要/ 到/ 中间/ 结果/ 存储/ 区/ (/ PMS/ )/ 中/ 去/ 读取/ ,/ 这/ 就/ 导致/ 了/ 中间/ 结果/ 频繁/ 的/ 被/ 读写操作/ ./ TPM/ 这种/ 中间/ 结果/ 管理/ 方法/ 适用/ 于/ 中间/ 结果/ 更新/ 少/ 的/ 应用/ ,/ 批量/ 的/ 中间/ 结果/ 归档/ 很/ 高效/ ./ 如图/ 3/ (/ a/ )/ 中/ 的/ 股票/ 流/ 上/ 连续/ 模式/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ ,/ 历史/ 流上/ 的/ “/ √/ ”/ 模式/ 被/ 检测/ 出来/ 后/ 就/ 不/ 需要/ 进行/ 更新/ ,/ 而/ 实时/ 流上/ 的/ “/ \/ ”/ 模式/ 只/ 与/ 后续/ 的/ 股票/ 事件/ 关联/ ,/ 不/ 需要/ 去/ 访问/ 历史/ 的/ 中间/ 结果/ ./ 但/ 对于/ 图/ 3/ (/ b/ )/ 中/ 的/ 离散/ 模式/ ,/ TPM/ 就/ 不/ 适用/ 了/ ./ 因为/ 离散/ 模式/ 的/ 子/ 事件/ 分布/ 在/ 数据流/ 的/ 任意/ 时间/ 点/ ,/ 在/ 未/ 达到/ 复杂/ 事件/ 的/ 输出/ 状态/ 且/ 滑动/ 窗口/ 未/ 滑动/ 没有/ 滑动/ 前/ ,/ 中间/ 结果/ 还/ 处于/ 在/ 其/ 生命周期/ 中/ ,/ 数据流/ 上/ 新/ 的/ 事件/ 随时/ 都/ 可能/ 触发/ 中间/ 结果/ 的/ 状态/ 更新/ 操作/ ,/ 所以/ TPM/ 只/ 利用/ 时态/ 关系/ 管理/ 中间/ 结果/ 是/ 不够/ 的/ ,/ 还/ 需要/ 考虑/ 中间/ 结果/ 的/ 空间信息/ ./ 5.2/ 基于/ 时空/ 关系/ 的/ 中间/ 结果/ 管理/ 针对/ TPM/ 管理/ 中间/ 结果/ 的/ 不足/ ,/ 提出/ 基于/ 时空/ 关系/ 的/ 中间/ 结果/ 管理/ (/ SpatialTemporalPartialMatchManagement/ ,/ STPM/ )/ 方法/ ,/ 如图/ 10/ 所示/ ./ STPM/ 方法/ 中/ ,/ 中间/ 结果/ 的/ 时态/ 关系/ 以/ 优先级/ 的/ 方式/ 体现/ ,/ 优先级/ 定义/ 如下/ ./ 定义/ 7/ ./ 中间/ 结果/ 优先级/ ./ 假设/ 给定/ 一个/ 模式/ P/ =/ SEQ/ (/ E1/ ,/ …/ ,/ Ei/ ,/ E/ (/ i/ +/ 1/ )/ ,/ …/ ,/ En/ )/ ,/ 事件/ 类型/ Ei/ 和/ E/ (/ i/ +/ 1/ )/ 的/ 事件/ 发生/ 的/ 时间/ 间隔/ 最大值/ 为/ Δ/ ti/ ,/ p/ (/ E/ (/ i/ +/ 1/ )/ |/ Ei/ )/ 为/ Ei/ 类型/ 事件/ 发生/ 后/ E/ (/ i/ +/ 1/ )/ 类型/ 事件/ 发生/ 的/ 条/ Page10/ 件/ 概率/ ./ 对于/ 数据流/ 上/ 的/ 一个/ Ei/ 类型/ (/ i/ </ n/ )/ 的/ 事件/ e/ ,/ 它/ 产生/ 的/ 中间/ 结果/ PMe/ 的/ 优先级/ WPMe/ 定义/ 为/ 即/ 中间/ 结果/ 优先级/ 定义/ 为/ 简单/ 事件/ 当前/ 的/ 时间/ 与/ 下个/ 类型/ 事件/ 可能/ 发生/ 的/ 时间/ 间隔/ 之/ 和/ ./ WPMe/ 体现/ 了/ 中间/ 结果/ 的/ 时空/ 信息/ ./ 基于/ WPMe/ 的/ 中间/ 结果/ 管理/ 如/ 过程/ 1/ 所示/ ./ 过程/ 1/ ./ STPM/ ./ 1/ ./ 对于/ 一个/ 事件/ e2/ ./ 如/ 在/ PMB/ 存在/ 它/ 的/ PMe/ 实体/ 3/ ./ tmpState/ =/ PMe/ / State/ ;/ 4/ ./ PMe/ / State/ =/ PMe/ / State/ ∪/ e/ / State/ ;/ 5/ ./ 如果/ tmpState/ ≠/ PMe/ / State/ ;/ 6/ ./ // // 在/ TreeWPM/ 插入/ 一条/ 记录/ 7/ ./ WPMe/ =/ e/ / t/ +/ Δ/ ti/ ×/ p/ (/ E/ (/ i/ +/ 1/ )/ |/ Ei/ )/ ;/ 8/ ./ TreeWPM/ / Insert/ (/ WPMe/ ,/ e/ / TID/ ,/ e/ / State/ )/ 9/ ./ 如果/ PMB/ 达到/ 归档/ 上限/ Δ/ R10/ ./ PMR/ / Write/ (/ Δ/ R/ ,/ TreeWPM/ ,/ PMB/ )/ ;/ 11/ ./ 如/ 在/ PMB/ 不/ 存在/ 它/ 的/ PMe/ 实体/ ,/ 但/ 存在/ 其/ Hash12/ ./ PMR/ / Write/ (/ e/ / TID/ ,/ PMS/ )/ PMR/ / Write/ (/ e/ / TID/ ,/ 13/ ./ 处理/ 下/ 一个/ 事件/ ./ 当/ 事件/ e/ 进入/ 复杂/ 事件处理/ 引擎/ 后/ ,/ 首先/ 查询/ PMB/ 中/ 是否/ 存在/ 它/ 的/ PMe/ 实体/ ./ 如/ 存在/ ,/ 则/ 需要/ 将/ e/ 的/ 状态/ 更新/ 到/ PMe/ 上/ ,/ 如/ PMe/ 的/ 状态/ 未/ 更新/ (/ 说明/ 该/ 事件/ 已/ 出现/ 过/ ,/ 如/ RFID/ 数据流/ 中/ 的/ 重复/ 读/ 事件/ )/ ,/ 则/ 不/ 需/ 更新/ 优先级/ 树/ TreeWPM/ ,/ 否则/ 根据/ 式/ (/ 5/ )/ 计算/ PMe/ 的/ WPMe/ ,/ 并/ 在/ TreeWPM/ 插入/ 一个/ 新/ 的/ 记录/ ./ 需要/ 注意/ 的/ 是/ ,/ 同一/ TID/ 的/ 事件/ 在/ TreeWPM/ 上/ 可能/ 对应/ 多条/ 记录/ ,/ 权值/ 越/ 小/ 的/ 记录/ 越/ 靠近/ 树/ 的/ 左边/ ,/ 在/ 归档/ 过程/ 中/ 可以/ 通过/ 与/ 中间/ 结果/ 的/ 状态/ 比较/ 将/ 不是/ 最新/ 状态/ 的/ TreeWPM/ 记录/ 删除/ ,/ 减少/ TreeWPM/ 的/ 操作/ ./ 中间/ 结果/ 的/ 归档/ 是/ 通过/ 一个/ 计数器/ Δ/ R/ ,/ 当/ 中间/ 结果/ 中/ 的/ 记录/ 达到/ Δ/ R/ 时/ 就/ 进行/ 一次/ 归档/ 操作/ :/ 在/ TreeWPM/ 上/ 按/ 优先级/ 从小到大/ 取/ Δ/ R/ 长/ 的/ 中间/ 结果/ 进行/ 归档/ ./ 归档/ 时要/ 比较/ TreeWPM/ 上/ 记录/ 的/ 状态/ 和/ 中间/ 结果/ 的/ 最新/ 状态/ ,/ 将/ 不是/ 最新/ 状态/ 的/ TreeWPM/ 上/ 的/ 记录/ 删除/ ,/ 将/ 是/ 最新/ 状态/ 的/ 记录/ 归档/ 到/ PMS/ ./ 对于/ 实体/ 不/ 在/ 内存/ 的/ 中间/ 结果/ ,/ 需要/ 通过/ PMR/ / Write/ (/ e/ / TID/ ,/ PMS/ )/ 将/ 其/ 读入/ ,/ 更新/ 其/ 状态/ 和/ TreeWPM/ ./ 可以/ 看到/ ,/ STPM/ 是/ 一种/ 启发式/ 方法/ ,/ 它/ 始终/ 将/ 时态/ 信息/ 和/ 状态/ 信息/ 最新/ 的/ 中间/ 结果/ 保留/ 在/ 中间/ 结果/ 缓冲区/ ,/ 以便/ 为/ 复杂/ 事件/ 检测/ 提供/ 更/ 高/ 的/ 命中率/ ,/ 减少/ 复杂/ 事件/ 的/ 输出/ 的/ 响应/ 时间/ ./ STPM/ 的/ 不足/ 在于/ 进行/ 中间/ 结果/ 归档/ 时/ ,/ 基于/ Hash/ 的/ 方法/ 无法/ 按/ 中间/ 结果/ 时间/ 属性/ 直接/ 进行/ 批量/ 插入/ 操作/ ,/ 但/ 可以/ 通过/ 对/ 将/ 归档/ 的/ 中间/ 结果/ 排序/ 来/ 完成/ ,/ 所以/ STPM/ 稍作/ 调整/ 后/ 也/ 适用/ 于/ 连续/ 模式/ 的/ 中间/ 结果/ 管理/ ./ 此外/ ,/ STPM/ 的/ TreeWPM/ 虽然/ 可能/ 存储/ 了/ 多个/ TID/ 相同/ 的/ 记录/ ,/ 但/ 随着/ 复杂/ 事件/ 检测/ 的/ 推进/ ,/ 这些/ 记录/ 会/ 被/ 不断/ 地/ 删除/ 掉/ ,/ 所以/ STPM/ 耗费/ 的/ 空间/ 代价/ 与/ TPM/ 只有/ 微弱/ 的/ 差异/ ./ 6/ 实验/ 结果/ 与/ 分析/ 为了/ 测试/ 文中/ 提出/ 的/ 方法/ ,/ 我们/ 设计/ 了/ 一个/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 原型/ 系统/ ./ 该/ 复杂/ 事件/ 检测/ 原型/ 系统/ 用/ C++/ 实现/ ,/ 编译/ 环境/ 为/ VisualStudio2008/ ,/ 使用/ 的/ 数据库/ 是/ 开源/ 数据库/ MySQLServer5/ ./ 2/ ,/ 系统配置/ :/ CPU/ 为/ Pentium/ (/ R/ )/ E5200DualCore2/ ./ 52GHz/ ,/ 内存/ 为/ 2GBRAM/ ,/ 操作系统/ 为/ WindowsXP/ ./ 由于/ 本文/ 主要/ 考虑/ 离散/ 模式/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ ,/ 为了/ 测试/ 本文/ 算法/ ,/ 我们/ 设计/ 了/ 一个/ 数据/ 模拟器/ ,/ 模拟/ 类似/ 图/ 3/ (/ b/ )/ 所示/ 离散/ 模式/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ ./ 实验/ 分析/ 使用/ 的/ 主要参数/ 如表/ 2/ 所示/ ,/ 其中/ 一些/ 参数/ 为/ 数据/ 生成器/ 的/ 参数/ ./ 历史/ 数据流/ 被/ 加载/ 到/ SPE/ 的/ 一个/ 缓冲区/ ,/ 当/ 缓冲区/ 内/ 不能/ 存储/ 所/ 请求/ 的/ 历史/ 流/ 时/ ,/ 通过/ 按/ 时间/ 顺序/ 批量/ 加载/ ./ p/ (/ B/ |/ A/ ,/ Δ/ t/ )/ A/ 类型/ 事件/ 在/ Δ/ t/ 出现/ 在/ B/ 的/ 概率/ RBuffer/ |/ WSub/ |/ Page11/ 复杂/ 事件/ 定义/ 被/ 解析/ 为/ 自动机/ 模型/ 进行/ 检测/ ./ 实验/ 的/ 性能指标/ 为/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 的/ CPU/ 耗费/ (/ 处理/ 完/ 实时/ 流/ 的/ 时间/ )/ 和/ 未/ 命中/ 次数/ (/ missedhittimes/ )/ ./ 实验/ 1/ ./ ALAA/ 与/ LLAA/ 的/ CPU/ 性能/ 比较/ ./ 图/ 11/ 是/ 两种/ 不同/ 的/ 在线/ -/ 离线/ 执行/ 算法/ 的/ 性能/ 比较/ ./ 由于/ ALAA/ 算法/ 在/ 实时/ 流/ 和/ 历史/ 流/ 整个/ 数据/ 集上/ 运行/ ,/ 而/ LLAA/ 算法/ 只/ 在/ 其/ 需要/ 的/ 历史/ 流/ 上/ 运行/ ,/ 所以/ 为了/ 性能/ 比较/ 的/ 公平/ ,/ 我们/ 限定/ 了/ 实时/ 流/ 和/ 历史/ 流/ 的/ 大小/ ,/ 并用/ 均匀分布/ 生成/ 数据流/ ,/ 匹配/ 率设/ 为/ 0.5/ ,/ Δ/ R/ 为/ 固定值/ ./ 从图/ 11/ 可以/ 看到/ ,/ ALAA/ 的/ CPU/ 耗费/ 始终/ 比/ LLAA/ 高/ ,/ 其/ 主要/ 原因/ 是/ ALAA/ 是/ 一种/ 盲目/ 的/ 在线/ -/ 离线/ 检测/ 算法/ ,/ 它/ 要/ 加载/ 整个/ 历史/ 流/ 并/ 检测/ 其上/ 的/ PA/ ,/ 而/ LLAA/ 是/ 一种/ 触发式/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 方法/ ,/ 只有/ 在/ 存在/ 达到/ 最大/ 状态/ 的/ PL/ 时才/ 触发/ 一次/ 归档/ 流/ 的/ 访问/ 和/ 计算/ ./ 由于/ ALAA/ 比/ LLAA/ 算法/ 性能/ 相差/ 较大/ ,/ 所以/ 后续/ 实验/ 的/ 性能/ 测试/ 我们/ 主要/ 关注/ LLAA/ ./ LLAA/ 算法/ 的/ CPU/ 比较/ ./ 实验/ 2/ ./ 基本/ 的/ LLAA/ 算法/ 与/ 基于/ 选择性/ 的/ 基于/ 选择性/ 的/ LLAA/ 算法/ (/ OptimizedLLAA/ ,/ OLLAA/ )/ 性能/ 主要/ 测试/ 不同/ 选择性/ 的/ 时候/ ,/ 在线/ -/ 离线/ 事件/ 检测/ 选择/ 的/ 数据流/ 顺序/ 的/ 变化/ 对/ CPU/ 耗费/ 的/ 影响/ ./ 该组/ 实验/ 在/ 大小/ 为/ 1/ ~/ 5/ 万/ 的/ 数据/ 集上/ 进行/ ,/ 该组/ 实验/ 我们/ 固定/ 了/ 实时/ 流/ 的/ 选择/ 度/ ,/ 调整/ 历史/ 流/ 的/ 选择/ 度/ ,/ 基本/ 的/ LLAA/ 算法/ 用/ 实时/ 流/ 去/ 连接/ 历史/ 流/ ,/ 而/ OLLAA/ 算法/ 则/ 是/ 历史/ 流/ 连接/ 实时/ 流/ ./ 从图/ 12/ 可以/ 看出/ ,/ OLLAA/ 在/ CPU/ 耗费/ 上/ 更少/ ,/ 其/ 原因/ 是/ 使用/ 基于/ 选择/ 度/ 的/ 复杂/ 事件/ 检测/ 减少/ 了/ 不必要/ 的/ PL/ 实例/ 和/ PA/ 实例/ 的/ 计算/ 和/ 连接/ 操作/ ./ 但/ 随着/ 历史/ 流/ 的/ 选择/ 度/ 逐渐/ 增大/ ,/ LLAA/ 与/ OLLAA/ 的/ 算法/ 性能/ 差异/ 变小/ ,/ 主要/ 原因/ 是因为/ 两个/ 数据/ 集/ 的/ 可/ 选择/ 度/ 接近/ 时/ ,/ 连接/ 操作/ 的/ 次数/ 与/ 连接/ 操作/ 的/ 顺序/ 关系/ 不是/ 很大/ ./ 在/ 实际/ 处理/ 中/ ,/ 历史/ 流/ 的/ 选择/ 度/ 可以/ 通过/ 数据库/ 的/ 统计/ 工具/ 获得/ ,/ 而/ 实时/ 数据流/ 的/ 选择/ 度则/ 可以/ 通过/ 一些/ 抽样/ 技术/ 获得/ ./ 图/ 12/ 调整/ 历史/ 流/ 的/ 选择/ 度/ LLAA/ 与/ OLLAA/ 的/ CPU/ 性能/ 比较/ ./ 实验/ 3/ ./ 基本/ 的/ LLAA/ 算法/ 与/ SLLAA/ 算法/ 该组/ 实验/ 测试/ 基本/ 的/ LLAA/ 算法/ 和/ SLLAA/ 算法/ 的/ CPU/ 性能/ 比较/ ./ SLLAA/ 的/ 子/ 窗口/ 的/ 选取/ 值/ 分别/ 为/ 500/ ,/ 1000/ ,/ 1500/ ,/ 2000/ ,/ 2500/ 和/ 3000/ ./ 为了/ 说明/ 子/ 窗口/ 效果/ ,/ 我们/ 将/ 数据流/ 的/ 复杂/ 事件/ 的/ MRatio/ 设置/ 为/ 1/ ./ 从图/ 13/ 可以/ 看出/ ,/ SLLAA/ 算法/ 比/ LLAA/ 算法/ 的/ CPU/ 耗费/ 都/ 要/ 少/ ,/ 主要/ 原因/ 是/ SLLAA/ 算法/ 通过/ 批量/ 的/ 历史/ 流/ 加载/ 和/ 计算/ ,/ 减少/ 了/ 对/ 历史/ 流/ 的/ 请求/ 次数/ (/ 读写操作/ )/ 和/ 具有/ 交叉/ 历史/ 流/ 访问/ 区间/ 的/ 重复/ 计算/ ,/ 从而/ 使得/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 的/ 平均/ 响应/ 时间/ 减少/ ./ 图/ 13/ 还/ 表明/ ,/ 子/ 窗口/ 的/ 选取/ 并/ 不是/ Page12/ 越大/ 或/ 越/ 小/ ,/ SLLAA/ 的/ 性能/ 就/ 越/ 好/ ./ 相反/ 的/ 是/ ,/ 子/ 窗口/ 的/ 取值/ 在/ 一个/ 取值/ 区间/ 的/ 中间/ 部分/ (/ 如本/ 实验/ 的/ [/ 500/ ,/ 3000/ ]/ )/ 时/ ,/ SLLAA/ 可/ 达到/ CPU/ 性能/ 最优/ ./ 该组/ 实验/ 可以/ 为/ 用户/ 设定/ 合适/ 的/ 容忍/ 时间/ 上限/ 提供/ 很/ 好/ 的/ 推荐/ :/ 用户/ 可以/ 根据/ 系统/ 的/ 历史/ 处理/ 信息/ ,/ 如/ 窗口/ 大小/ 、/ 数据流/ 的/ 分布/ 、/ 模式/ 特点/ 、/ 子/ 窗口/ 的/ 取值/ 区域/ 等/ ,/ 结合/ 系统/ 当前/ 的/ 特点/ ,/ 设定/ 比较/ 合适/ 的/ 响应/ 时间/ ,/ 达到/ 系统资源/ 的/ 合理/ 利用/ ./ 实验/ 4/ ./ 调整/ LLAA/ 的/ RBuffer/ 性能/ 比较/ 在/ 前面/ 的/ 章节/ 介绍/ 过/ ,/ RBuffer/ 是/ 一个/ 数据/ 缓冲区/ ,/ 可以/ 缓冲/ 实时/ 的/ 数据量/ ,/ 为/ 实时/ 复杂/ 事件/ 检测/ 提供/ 数据源/ ,/ 同时/ 也/ 为/ 历史/ 流上/ 的/ 复杂/ 事件/ 检测/ 提供/ 数据源/ ./ RBuffer/ 不能/ 太小/ ,/ 因为/ 当/ 数据流/ 高速/ 进入/ 事件处理/ 引擎/ 时/ ,/ RBuffer/ 由于/ 可能/ 存储/ 不了/ 数据流/ 而/ 频繁/ 地/ 将/ Buffer/ 中/ 的/ 数据/ 归档/ 到/ 外存/ ,/ 同时/ 历史/ 流上/ 的/ 归档/ 操作/ 也/ 会/ 因为/ RBuffer/ 没有/ 其/ 需要/ 的/ 数据/ 而/ 频繁/ 地/ 访问/ 外存/ ,/ 这/ 就/ 导致系统/ 的/ 高/ 负载/ ./ 由于/ 内存/ 是/ 一个/ 公共资源/ ,/ 当/ RBuffer/ 的/ 空间/ 增大/ 时/ ,/ 系统/ 分配/ 给/ 模式匹配/ 的/ 空间/ 自然/ 减少/ ,/ 而/ 模式匹配/ 要/ 存储/ 原始/ 事件/ 的/ 所有/ 信息/ ,/ 因此/ ,/ 如果/ RBuffer/ 过于/ 大/ ,/ 则/ 系统/ 的/ 性能/ 会/ 下降/ ./ 图/ 14/ 表明/ ,/ 较/ 小/ 的/ RBuffer/ 导致/ 较/ 多/ 的/ 数据库/ 读写操作/ ,/ 而/ 较大/ 的/ RBuffer/ 则/ 可以/ 减少/ 数据库/ 的/ 读写操作/ ,/ 但/ RBuffer/ 不能/ 无限大/ ./ 图/ 14LLAA/ 运行/ 于/ 不同/ 的/ RBuffer/ 和/ 数据/ 集时/ 的/ 实验/ 5/ ./ TPM/ 与/ STPM/ 的/ CPU/ 性能/ 比较/ ./ LLAA/ 在/ STPM/ 与/ TPM/ 两种/ 中间/ 结果/ 管理/ 方法/ 上/ 的/ 性能/ 测试/ 如图/ 15/ 所示/ ,/ 为了/ 能/ 明显/ 看到/ 中间/ 结果/ 管理/ 的/ 效果/ ,/ 实验/ 中/ 设置/ |/ WSub/ |/ =/ 5000/ ,/ RBuffer/ =/ 50000/ ./ 从图/ 15/ 可/ 看出/ ,/ STPM/ 的/ CPU/ 性能/ 明显/ 优于/ TPM/ ,/ 其/ 主要/ 原因/ 在/ 上节/ 也/ 介绍/ 过/ ,/ 是/ 由于/ TPM/ 没有/ 利用/ 到/ 中间/ 结果/ 的/ 空间信息/ ,/ 盲目/ 地/ 将/ 中间/ 结果/ 归档/ ,/ 导致/ 事件/ 检测/ 过程/ 的/ 中间/ 结果/ 命中率/ 急剧下降/ ,/ 命中率/ 下降/ 意味着/ 需要/ 多次/ 的/ 数据库/ 读取/ 操作/ ,/ 数据库/ 的/ 频繁/ 操作/ 是/ 非常/ 耗时/ 的/ ./ 而/ TPM/ 利用/ 中间/ 结果/ 的/ 时空/ 关系/ (/ 虽然/ 空间/ 关系/ 时态/ 化/ 了/ )/ ,/ 将/ 最/ 有/ 可能/ 更新/ 状态/ 的/ 中间/ 结果/ 放/ 于/ 内存/ ,/ 提高/ 了/ 复杂/ 事件/ 的/ 命中率/ ,/ 减少/ 了/ 复杂/ 事件/ 输出/ 的/ 时间/ ./ STPM/ 的/ CPU/ 性能/ 和/ Miss/ 次数/ 比较/ 实验/ 6/ ./ 调整/ LLAA/ 的/ MRatio/ 时/ TPM/ 与/ 我们/ 调整/ 数据/ 集/ 的/ 大小/ 和/ 匹配/ 率/ MRatio/ ,/ 测试/ 了/ STPM/ 和/ TPM/ 的/ CPU/ 性能/ 和/ 处理/ 完/ 相同/ 数据/ 集后/ 的/ Miss/ 次数/ 统计/ ./ STPM/ 和/ TPM/ 的/ CPU/ 性能/ 比较/ 如图/ 16/ 所示/ ,/ 可以/ 看出/ ,/ 在/ 数据/ 集/ 和/ MRatio/ 变化/ 时/ ,/ STPM/ 的/ CPU/ 耗费/ 稳定/ 且/ 都/ 远/ 小于/ TPM/ ,/ 进一步/ 说明/ 了/ 中间/ 结果/ 管理/ 需要/ 更/ 多/ 的/ 查询/ 的/ 特性/ 才能/ 使/ 复杂/ 事件/ 检测/ 响应/ 时间/ 更/ 短/ ./ STPM/ 和/ TPM/ 的/ CPU/ 性能/ 差异/ 其实/ 来自/ 于/ 模式匹配/ 时/ 中间/ 结果/ 的/ Miss/ 次数/ 的/ 差异/ ,/ 如图/ 17/ 所示/ ./ 可以/ 看到/ ,/ 随着/ MRatio/ 的/ 变大/ ,/ TPM/ 搜寻/ 中间/ 结果/ 缓冲区/ 的/ 失效/ 次数/ 逐步/ 减小/ ,/ 而/ STPM/ 的/ 中间/ 结果/ 缓冲区/ 搜索/ 失效/ 次数/ 保持/ 在/ 一个/ 很/ 低且/ 稳定/ 的/ 区域/ (/ 10/ ~/ 20/ 次/ 左右/ )/ ,/ 即/ STPM/ 能/ 在/ 缓冲区/ 内/ 保存/ 更/ Page13/ 图/ 17STPM/ 与/ TPM/ 的/ 中间/ 结果/ Miss/ 次数/ 比较/ 为/ 活跃/ 的/ 中间/ 结果/ ,/ 大大减少/ 了/ 归档/ 中间/ 结果/ 的/ 访问/ 代价/ ./ 7/ 结论/ 本文/ 研究/ 了/ 在线/ -/ 离线/ (/ 历史/ )/ 数据流/ 上/ 的/ 复杂/ 事件/ 检测/ 问题/ ./ 通过/ 使用/ 最近/ 处理/ 过/ 的/ 事件/ 缓冲区/ 缓存/ 最近/ 处理/ 过/ 的/ 实时/ 数据流/ ,/ 可以/ 减少/ 历史/ 流/ 的/ 请求/ 代价/ ./ 提出/ 了/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 算法/ ALAA/ 和/ LLAA/ ,/ 并/ 通过/ 数据流/ 的/ 事件/ 分布/ 特性/ 提出/ 了/ LLAA/ 的/ 优化/ 算法/ ./ 针对/ 复杂/ 事件处理/ 大/ 窗口/ 和/ 高/ 流速/ 时/ 产生/ 的/ 大量/ 中间/ 结果/ ,/ 提出/ 了/ 基于/ 时态/ 和/ 时空/ 关系/ 的/ 中间/ 结果/ 管理/ 方法/ STPM/ 和/ TPM/ ./ 通过/ 利用/ 中间/ 结果/ 的/ 时态/ 和/ 空间/ 状态/ 信息/ ,/ STPM/ 减少/ 了/ 状态/ 需要/ 更新/ 的/ 中间/ 结果/ 被/ 交换/ 到/ 外存/ 的/ 可能性/ ,/ 提高/ 了/ 复杂/ 事件/ 检测/ 的/ 中间/ 结果/ 命中率/ ,/ 减少/ 了/ 复杂/ 事件/ 检测/ 的/ 响应/ 时间/ ./ 本文/ 目前/ 研究/ 的/ 是/ 离散/ 模式/ 的/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ ,/ 系统/ 中/ 只有/ 一个/ 事件/ 查询/ ./ 实际/ 应用/ 中/ ,/ 可能/ 存在/ 多个/ 用户/ 同时/ 在/ 实时/ 流/ 和/ 历史/ 流/ 上/ 查询/ ,/ 每个/ 查询/ 由于/ 其/ 语义/ (/ 模式/ ,/ 窗口/ 等/ )/ 的/ 不同/ 而/ 对应/ 不同/ 的/ 查询/ 执行/ 模型/ (/ 不同/ 的/ 自动机/ 或/ Tree/ )/ ,/ 如何/ 在/ 一次/ 扫描/ 数据流/ 的/ 时候/ 或/ 一次/ 扫描/ 多个/ 查询/ 对应/ 的/ 自动机/ 的/ 情况/ 下/ 进行/ 查询/ 调度/ ,/ 是/ 多个/ 查询/ 优化/ 的/ 重要/ 问题/ ./ 此外/ ,/ 当/ 系统/ 中/ 存在/ 多个/ 在线/ -/ 离线/ 复杂/ 事件/ 查询/ 时/ ,/ 由于/ 每个/ 查询/ 对应/ 不同/ 的/ 时间/ 窗口/ 约束/ 和/ 历史/ 流/ 访问/ 请求/ 区间/ ,/ 如何/ 利用/ 这些/ 查询/ 的/ 共同/ 特点/ 和/ 数据/ 的/ 特点/ 进行/ 查询/ 优化/ ,/ 如何/ 在/ 系统资源/ 有限/ 的/ 情况/ 下/ ,/ 对/ 各种/ 状态/ 的/ 中间/ 结果/ 进行/ 高效/ 管理/ ,/ 给/ 系统/ 降载/ ,/ 都/ 是/ 需要/ 重点/ 考虑/ 的/ 问题/ ./ 此外/ ,/ 由于/ 复杂/ 事件/ 检测/ 的/ 应用/ 场景/ 一般/ 为/ 分布式/ 环境/ ,/ 数据/ 在/ 汇集/ 到/ 中心/ 节点/ 时/ ,/ 由于/ 网络/ 延迟/ 或/ 其它/ 不/ 确定/ 因素/ ,/ 在/ 数据流/ 中/ 可能/ 存在/ 数据/ 乱序/ 的/ 情况/ ,/ 如何/ 在/ 保证/ 在线/ -/ 离线/ 复杂/ 事件/ 检测/ 完整性/ 和/ 一致性/ 的/ 前提/ 下去/ 除/ 乱序/ 数据/ 的/ 影响/ ,/ 也/ 是/ 需要/ 考虑/ 的/ 问题/ ./ 

