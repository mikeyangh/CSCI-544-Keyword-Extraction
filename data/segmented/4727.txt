Page1/ 基于/ 外存/ 后缀/ 树/ 的/ top/ -/ 犽/ 局部/ 比/ 对/ 算法/ 王斌/ 朱睿/ 杨晓春/ 王国/ 仁于/ 戈/ (/ 东北大学/ 信息科学/ 与/ 工程学院/ 沈阳/ 110004/ )/ 摘要/ 局部/ 比/ 对/ 是/ 一种/ 衡量/ 字符串/ 间/ 相似/ 程度/ 的/ 技术/ ,/ 它/ 在/ 生物/ 信息学/ 领域/ 具有/ 十分/ 重要/ 的/ 作用/ ./ 介于/ 此/ ,/ 许多/ 学者/ 已/ 对/ 其/ 进行/ 了/ 深入/ 的/ 研究/ ./ 然而/ ,/ 随着/ 数据/ 规模/ 的/ 扩大/ ,/ 常规/ 的/ 内存/ 算法/ 已/ 不适/ 用于/ 支持/ 大规模/ 文本/ 数据/ 的/ 局部/ 比/ 对/ ./ 为/ 解决/ 上述/ 问题/ ,/ 该文/ 研究/ 了/ 基于/ 外存/ 后缀/ 树/ 的/ top/ -/ k/ 局部/ 比/ 对/ 算法/ ./ 它/ 从根本上/ 消除/ 了/ 内存空间/ 对/ 算法/ 的/ 束缚/ ./ 为了/ 提高/ 算法/ 的/ 性能/ ,/ 该文/ 首先/ 将/ 经典/ 内存/ 算法/ 中/ 的/ 过滤/ 策略/ 引入/ 该文/ ./ 通过/ 适当/ 的/ 修改/ ,/ 这些/ 策略/ 可以/ 基于/ 外存/ 后缀/ 树/ 有效/ 地/ 降低/ 计算/ 开销/ ./ 其次/ ,/ 该文/ 提出/ 一种/ 巧妙/ 的/ 算法/ 支持/ top/ -/ k/ 局部/ 比/ 对/ 查询/ ./ 该/ 算法/ 通过/ 引入/ 启发式/ 策略/ 有效/ 规避/ 了/ TA/ 算法/ 的/ 固有/ 问题/ ./ 具体/ 地/ ,/ 它/ 一方面/ 可以/ 提高/ 算法/ 的/ 过滤/ 能力/ ,/ 另一方面/ 可以/ 降低/ 候选/ 对象/ 的/ 维护/ 代价/ ./ 再次/ ,/ 该文/ 对外/ 存/ 后缀/ 树/ 和/ 磁盘/ 的/ 工作/ 原理/ 进行/ 了/ 研究/ ./ 基于/ 此/ ,/ 该文/ 提出/ 一种/ 槽/ 的/ 结构/ 支持/ 查询/ ./ 该/ 结构/ 既/ 可以/ 实现/ 磁盘/ 的/ 顺序/ 访问/ ,/ 又/ 可以/ 降低/ 磁盘/ 的/ 访问/ 次数/ ./ 因此/ ,/ 它/ 可以/ 有效/ 提高/ 算法/ 的/ 查询/ 效率/ ./ 最后/ ,/ 大量/ 的/ 实验/ 验证/ 了/ 该文/ 所/ 提出/ 算法/ 的/ 有效性/ ./ 关键词/ 局部/ 比/ 对/ ;/ top/ -/ k/ ;/ 外存/ 后缀/ 树/ ;/ 叉子/ 区域/ 1/ 引言/ 局部/ 比/ 对/ 是/ 在/ 两条/ 文本/ 串/ 之间/ 寻找/ 近似/ 子串/ 的/ 过程/ ./ 它/ 在/ 生物/ 信息学/ 领域/ 具有/ 重要/ 应用/ [/ 1/ -/ 2/ ]/ ./ 具体来说/ ,/ 它/ 有助于/ 研究/ 人员/ 分析/ 不同/ 基因/ 片段/ 的/ 功能/ ,/ 确定/ 它们/ 在/ 遗传学/ 上/ 的/ 意义/ [/ 3/ -/ 4/ ]/ ./ 和/ 常规/ 文本/ 数据/ 相比/ ,/ 基因/ 数据/ 的/ 规模/ 较大/ ./ 常规/ PC机/ 的/ 内存/ 往往/ 无法/ 容纳/ 这些/ 数据/ [/ 5/ -/ 8/ ]/ ,/ 更/ 无法/ 容纳/ 以/ 这些/ 字符串/ 为/ 基础/ 构建/ 的/ 索引/ ①/ ./ 因此/ ,/ 在/ 对/ 基因/ 数据/ 执行/ 局部/ 比/ 对/ 时/ ,/ 传统/ 的/ 内存/ 算法/ 往往/ 无法/ 在/ 单机/ 环境/ 下/ 使用/ ./ 针对/ 内存不足/ 等/ 问题/ ,/ 分布式/ 算法/ [/ 9/ ]/ 和/ 外存/ 算法/ 是/ 两种/ 流行/ 的/ 解决方案/ ./ 对于/ 前者/ 而言/ ,/ 由于/ 它/ 对/ 硬件/ 的/ 要求/ 较/ 高且/ 不易/ 维护/ ,/ 当/ 实时性/ 不是/ 算法/ 的/ 第一/ 考虑/ 要素/ 时/ ②/ ,/ 它/ 未必/ 适用/ ./ 相反/ ,/ 由于/ 外存/ 算法/ 对/ 硬件/ 的/ 要求/ 较/ 低且/ 易于/ 维护/ ,/ 它/ 适合/ 在/ 生物/ 序列/ 比/ 对/ 技术/ 中/ 使用/ ./ 因此/ ,/ 研究/ 局部/ 比/ 对/ 的/ 外存/ 算法/ 具有/ 十分/ 重要/ 的/ 现实意义/ ./ 计算机/ 的/ 外存/ 访问/ 主要/ 由/ 两/ 部分/ 组成/ :/ 磁道/ 寻址/ 和/ 数据/ 读写/ ./ 由于/ 外存/ 的/ 机械/ 特性/ ,/ 前者/ 的/ 代价/ 远远/ 大于/ 后者/ ./ 换句话说/ ,/ 磁盘/ 访问/ 的/ 高昂/ 代价/ 主要/ 由/ 磁道/ 寻址/ 引起/ ./ 显然/ ,/ 如果/ 外存/ 算法/ 能/ 对/ 磁盘/ 执行/ 顺序/ 读取/ ,/ 它/ 的/ 访问/ 代价/ 就/ 会/ 急剧下降/ ./ 研究/ 结果表明/ ,/ 当/ 磁盘/ 执行/ 顺序/ 访问/ 时/ ,/ 它/ 的/ 读取/ 效率/ 甚至/ 高于/ 内存/ 的/ 随机/ 读取/ 效率/ [/ 9/ ]/ ./ 由此可见/ ,/ 外存/ 算法/ 的/ 研究/ 焦点/ 大多/ 集中/ 在/ :/ (/ 1/ )/ 减少/ 磁盘/ 访问/ 次数/ ;/ (/ 2/ )/ 尽可能/ 地/ 执行/ 顺序/ 访问/ ./ 如果/ 上述/ 两点/ 能够/ 满足/ ,/ 外存/ 算法/ 不仅/ 可以/ 消除/ 数据/ 规模/ 对/ 算法/ 的/ 约束/ ,/ 而且/ 可以/ 打破/ I/ // O/ 操作/ 带来/ 的/ 瓶颈/ ./ 现如今/ ,/ 许多/ 问题/ 的/ 外存/ 算法/ 都/ 已/ 被/ 深入研究/ ./ 在/ 文本/ 管理/ 领域/ ,/ 外存/ 后缀/ 树/ 作为/ 一种/ 高效/ 索引/ 结构/ ,/ 十分/ 适用/ 于/ 管理/ 大规模/ 文本/ 数据/ ./ 其/ 主要/ 原因/ 是/ 后缀/ 树是/ 可分解/ 的/ ./ 这样一来/ ,/ 算法/ 可以/ 自/ 适应/ 加载/ 不同/ 子树/ ./ 因此/ ,/ 基于/ 外存/ 后缀/ 树/ 实现/ 字符串/ 间/ 的/ 局部/ 比/ 对/ 是/ 一种/ 可行/ 的/ 方法/ ./ 本文/ 基于/ 外存/ 后缀/ 树/ 研究/ 字符串/ 间/ 的/ top/ -/ k/ 局部/ 比/ 对/ 问题/ ./ 给定/ 原串/ T/ ,/ 查询/ 串/ P/ 和/ 评价/ 字符串/ 间/ 相似/ 度/ 的/ 打分/ 函数/ F/ ,/ 该/ 问题/ 要求/ 返回/ T/ ,/ P/ 之间/ 相似/ 程度/ 最高/ 且/ 彼此之间/ 不/ 存在/ 支配/ 关系/ 的/ k/ 对/ 子串/ ./ 为了/ 达到/ 此/ 目的/ ,/ 当/ 查询/ 串/ P/ 到来/ 时/ ,/ 查询/ 算法/ 依次/ 从/ 磁盘/ 中/ 读取/ 后缀/ 树先/ 遍历/ 找到/ 参与/ 局部/ 比/ 对/ 的/ 子串/ 、/ 计算/ 比/ 对/ 结果/ ,/ 维护/ 候选/ 集中/ 分值/ 最高/ 且/ 不/ 被/ 支配/ 的/ 对/ 子串/ ./ 当/ 遍历/ 完成/ 时/ ,/ 算法/ 将/ 候选/ 集/ 作为/ 查询/ 结果/ 输出/ ./ 为了/ 提高/ 算法/ 的/ 效率/ ,/ 本文/ 需要/ 面对/ 以下/ 挑战/ :/ (/ 1/ )/ 找到/ 适用/ 于/ 外存/ 环境/ 的/ 过滤/ 策略/ ./ 近年来/ ,/ 基于/ 内存/ 的/ 局部/ 比/ 对/ 算法/ 已/ 被/ 深入研究/ ./ 然而/ ,/ 它们/ 的/ 过滤/ 策略/ 都/ 是/ 在/ 内存/ 环境/ 下/ 实现/ 的/ ./ 开发/ 适用/ 于/ 外存/ 环境/ 的/ 过滤/ 算法/ 是/ 第/ 1/ 个/ 需要/ 客服/ 的/ 难点/ ./ (/ 2/ )/ 选取/ 合适/ 的/ 阈值/ ./ 和/ 基于/ 阈值/ 的/ 局部/ 比/ 对/ 算法/ 相比/ ,/ 基于/ top/ -/ k/ 的/ 局部/ 比/ 对/ 算法/ 无法/ 提供/ 过滤/ 能力/ 强/ 的/ 阈值/ ,/ 这会/ 导致/ 算法/ 的/ 运算/ 速度/ 降低/ ./ 因此/ ,/ 本文/ 面临/ 的/ 第/ 2/ 个/ 挑战/ 是/ 找到/ 过滤/ 能力/ 强且/ 保证/ 不/ 丢解/ 的/ 阈值/ 从而/ 提高/ 算法/ 性能/ ./ (/ 3/ )/ 减少/ I/ // O/ 代价/ ./ 由/ 文献/ [/ 10/ -/ 12/ ]/ 可知/ ,/ 由于/ 局部/ 比/ 对/ 算法/ 需要/ 频繁/ 对/ 原串/ T/ 执行/ 随机/ 访问/ ,/ 它会/ 导致/ 算法/ 多次/ 访问/ 磁盘/ ./ 因此/ ,/ 本文/ 面临/ 的/ 第/ 3/ 个/ 挑战/ 是/ 找到/ 迎合/ 磁盘/ 工作/ 原理/ 的/ 算法/ 从而/ 降低/ I/ // O/ 代价/ ./ 为/ 克服/ 上述/ 挑战/ ,/ 本文/ 贡献/ 如下/ :/ (/ 1/ )/ 高效/ 的/ 过滤/ 策略/ ./ 本文/ 首先/ 针对/ 外存/ 后缀/ 树/ 的/ 特点/ 进行/ 分析/ ./ 基于/ 此/ ,/ 本文/ 结合/ 文献/ [/ 8/ ]/ 中/ 的/ 过滤/ 策略/ (/ 例如/ :/ 长度/ 过滤/ 、/ 支配/ 关系/ 过滤/ 等/ )/ 加速/ 局部/ 比/ 对/ 计算/ ./ 实验/ 表明/ ,/ 这些/ 过滤/ 策略/ 不仅/ 降低/ 了/ 局部/ 比/ 对/ 计算/ 次数/ 而且/ 适合/ 在/ 外存/ 环境/ 下/ 使用/ ./ (/ 2/ )/ 高效/ 的/ 候选/ 集/ 维护/ 算法/ ./ 本文/ 首先/ 利用/ 启发式/ 策略/ 找到/ 合适/ 的/ 阈值/ ./ 该/ 阈值/ 保证/ 在/ 不/ 丢解/ 的/ 前提/ 下/ 提供/ 较强/ 的/ 过滤/ 能力/ ,/ 从而/ 降低/ 候选/ 集/ 的/ 维护/ 次数/ ./ 当/ 候选/ 集/ 需要/ 被/ 维护/ 时/ ,/ 本文/ 近/ 一步/ 利用/ 散/ 列表/ 维护/ 候选/ 对象/ 间/ 的/ 支配/ 关系/ ./ 它/ 可以/ 在/ 常数/ 时间/ 内/ 找到/ 并/ 移除/ 候选/ 集中/ 的/ 非/ 候选/ 对象/ ./ (/ 3/ )/ 高效/ 的/ 外存/ 算法/ ./ 一方面/ ,/ 本文/ 根据/ 外存/ 后缀/ 树/ 的/ 工作/ 原理/ 挑选/ 访问/ 频率/ 高/ 的/ 子串/ 常驻/ 内存/ ./ 另一方面/ ,/ 本文/ 提出/ 一种/ 批处理/ 算法/ 实现/ 磁盘/ 的/ 顺序/ 读取/ ./ 显然/ ,/ 上述/ 两种/ 策略/ 一方面/ 降低/ 了/ 磁盘/ 的/ 访问/ 次数/ ,/ 另一方面/ 减少/ 了/ 随机/ 寻址/ 次数/ ./ 它们/ 均/ 可以/ 有效/ 降低/ I/ // O/ 代价/ ./ 本文/ 第/ 2/ 节/ 概述/ 背景/ 知识/ ;/ 第/ 3/ 节/ 介绍/ 基于/ 外存/ 后缀/ 树/ 的/ top/ -/ k/ 局部/ 比/ 对/ 算法/ ;/ 第/ 4/ 节/ 进行/ 有效性/ 实验/ 分析/ ;/ 第/ 5/ 节对/ 全文/ 进行/ 总结/ ./ ①/ ②/ ③/ Page32/ 准备/ 工作/ 在/ 介绍/ 问题/ 定义/ 之前/ ,/ 表/ 1/ 首先/ 定义/ 一组/ 符号/ ./ 符号/ T/ [/ i/ ]/ (/ 或/ P/ [/ i/ ]/ )/ T/ [/ i/ ,/ j/ ]/ P/ [/ i/ ,/ j/ ]/ ALC/ (/ t/ ,/ p/ )/ |/ ALC/ (/ t/ ,/ p/ )/ |/ ALC/ (/ is/ ,/ js/ ,/ ie/ ,/ je/ )/ 基于/ T/ [/ is/ ,/ ie/ ]/ ,/ P/ [/ js/ ,/ je/ ]/ 得到/ 的/ 局部/ 比/ 对/ s/ (/ a/ →/ b/ )/ 2.1/ 背景/ 知识/ 2.1/ ./ 1/ 相似/ 度/ 评价/ 函数/ 给定/ 字符串/ r/ 和/ s/ ,/ F/ (/ r/ ,/ s/ ,/ 间/ 相似/ 程度/ 的/ 打分/ 函数/ ./ 其中/ ,/ 需/ 的/ 操作/ 集合/ ;/ 通常/ 情况/ 下/ ,/ 匹配/ (/ 简称/ sa/ )/ ,/ 替换/ (/ 简称/ sb/ )/ ,/ 插入/ 和/ 删除/ ./ 给定/ 字符串/ r/ 和/ s/ ,/ 如果/ r/ [/ i/ ]/ =/ s/ [/ i/ ]/ ,/ 则/ 称/ 两者/ 在/ 位置/ i/ 上/ 匹配/ ./ 在/ 一系列/ 匹配/ 或/ 替换/ 操作/ 之后/ ,/ 本文/ 将/ 第/ 1/ 个/ 插入/ 或/ 删除/ 操作/ 称为/ Gap/ 开启/ (/ 简称/ sg/ )/ ./ 在/ Gap/ 开启/ 位置/ 及其/ 之后/ 的/ 连续/ 插入/ 或者/ 删除/ 操作/ 称为/ Gap/ 扩展/ (/ 简称/ ss/ )/ ./ 图/ 1/ 解释/ 了/ 字符串/ 间/ 相似/ 度/ 的/ 计算方法/ ./ 其中/ ,/ 实线/ 表示/ 匹配/ 操作/ ;/ 虚线/ 表示/ 替换/ 操作/ ;/ 其余部分/ 表示/ Gap/ 开启/ 或/ Gap/ 扩展/ 开启/ ./ 图/ 1/ 共有/ 10/ 次/ 匹配/ 、/ 4/ 次/ 替换/ 、/ 2/ 次/ Gap/ 开启/ 和/ 4/ 次/ Gap/ 扩展/ 开启/ ./ 假设/ 图/ 2/ 字符串/ T/ =/ “/ AGCCAGAT/ ”/ 的/ 后缀/ 树/ 匹配/ 操作/ 对应/ 的/ 分值/ 为/ 1/ ,/ 其余/ 操作/ 对应/ 的/ 分值/ 都/ 为/ -/ 1/ ,/ r/ 和/ s/ 的/ 相似/ 度为/ 10/ ×/ 1/ +/ 4/ ×/ (/ -/ 1/ )/ +/ 2/ ×/ (/ -/ 1/ )/ +/ 4/ ×/ (/ -/ 1/ )/ =/ 0.2/ ./ 1.2/ 外存/ 后缀/ 树/ 给定/ 字符串/ T/ ,/ 它/ 的/ 后缀/ 树/ 所有/ 后缀/ 的/ 树状/ 结构/ [/ 11/ -/ 12/ ]/ ./ 图/ 2/ (/ a/ )/ 为/ 字符串/ T/ =/ “/ AGCCAGAT/ ”/ 对应/ 的/ 后缀/ 树符/ 为/ 起点/ 的/ 后缀/ Ssur/ ,/ 它/ 都/ 可以/ 从根/ 节点/ 到/ 某/ 叶子/ 节点/ 组成/ 的/ 边上/ 得到/ ./ 例如/ :/ 字符串/ T/ 包含/ 两个/ 以/ G/ 为/ 起始/ 点/ 的/ 后缀/ 串/ ,/ 它们/ 分别/ 是/ “/ GCCAGAT/ ”/ 和/ “/ GAT/ ”/ ./ 为了/ 降低/ 后缀/ 树/ 的/ 空间/ 代价/ ,/ Manber/ 等/ 人/ [/ 13/ -/ 19/ ]/ 提出/ 一种/ 压缩算法/ ./ 它用/ 字符串/ 的/ 概要/ 信息/ 对/ 原串/ 进行/ 管理/ ./ 以/ 节点/ 2/ 和/ 7/ 之间/ 的/ 边/ 为例/ ,/ 在/ 图/ 2/ (/ a/ )/ 中/ ,/ 这/ 条/ 边上/ 存储/ 的/ 字符串/ s/ =/ “/ AGAT/ ”/ ./ 为了/ 对/ 它/ 进行/ 压缩/ ,/ 在/ 图/ 2/ (/ b/ )/ 中/ ,/ 存储/ 算法/ 将/ 边上/ 的/ 内容/ 变为/ A/ [/ 4/ ,/ 7/ ]/ ./ 它/ 的/ 含义/ 为/ s/ 的/ 首/ 字符/ 为/ A/ ,/ 它/ 在/ 原串/ 中/ 的/ 起始/ 和/ 终止/ 位置/ 分别/ 为/ 4/ 和/ 7/ ./ 由于/ 后缀/ 树/ 的/ 规模/ 较大/ ,/ 许多/ 学者/ 对外/ 存/ 后缀/ 树/ 进行/ 了/ 研究/ ./ 主流/ 算法/ 通常/ 把/ 原串/ T/ 的/ 一部分/ 加载/ 到/ 内存/ ,/ 而/ 另/ 一部分/ 存放/ 在/ 磁盘/ 上/ ./ 给定/ 原串/ T/ 和/ 它/ 对应/ 的/ 后缀/ 树/ 在/ 内存/ 中/ ,/ 访问/ 算法/ 直接/ 从/ 内存/ 读取/ 子串/ ./ 否则/ ,/ 算法/ 需要/ 从/ 磁盘/ 读取/ 原串/ 的/ 相应/ 内容/ ./ 为/ 方便/ 叙述/ ,/ 本文/ 用存/ ;/ |/ / |/ 表示/ a/ ,/ b/ 两/ 节点/ 边上/ 对应/ 的/ 字符串/ ./ 图/ 2/ (/ b/ )/ 所示/ ,/ 假设/ |/ / |/ =/ 4/ 、/ s/ (/ 5/ →/ 11/ )/ 时/ ,/ 因为/ 它/ 索引/ 的/ 子串/ 不/ 在/ 内存/ 中/ ,/ 所以/ 这/ Page4/ 会/ 引发/ 一次/ 磁盘操作/ ./ 相似/ 地/ ,/ 当/ 算法/ 完成/ 遍历/ 后/ ,/ 磁盘操作/ 次数/ 为/ 11/ ./ 由/ 上述/ 观察/ 可知/ ,/ 当/ T/ 无法/ 完全/ 装载/ 到/ 内存/ 时/ ,/ 遍历/ 后缀/ 树会/ 频繁/ 引发/ 磁盘操作/ ./ 其/ 根本原因/ 是/ 后缀/ 树/ 相邻/ 边上/ 保存/ 的/ 子串/ 在/ 原串/ T/ 中/ 的/ 位置/ 往往/ 较远/ ./ 2.2/ 问题/ 定义/ 在/ 讨论/ 了/ 背景/ 知识/ 后/ ,/ 本文/ 介绍/ 关于/ 局部/ 比/ 对/ 的/ 相关/ 概念/ ./ 定义/ 1/ (/ 局部/ 比/ 对/ 计算/ )/ ./ 给定/ 字符串/ r/ ∈/ T/ 和/ s/ ∈/ P/ ,/ 局部/ 比/ 对/ 计算/ (/ 简称/ :/ ALC/ (/ LocalAlignmentCalculation/ )/ )/ 是/ 利用/ 评价/ 函数/ F/ (/ r/ ,/ s/ ,/ 者/ 相似/ 程度/ 的/ 过程/ ./ 定义/ 2/ (/ 最优/ 局部/ 比/ 对/ 计算/ )/ ./ 给定/ 串/ r/ ∈/ T/ 和/ s/ ∈/ P/ 之间/ 的/ 最优/ 局部/ 比/ 对/ 是/ 使/ 函数/ 值/ F/ 达到/ 最大/ 的/ 局部/ 比/ 对/ 操作/ 序列/ ./ 为了/ 方便/ 描述/ ,/ 给定/ 原串/ T/ 和/ 查询/ 串/ P/ ,/ 本文/ 用/ ALC/ (/ t/ ,/ p/ )/ 表示/ 子串/ t/ ∈/ T/ ,/ p/ ∈/ P/ 之间/ 的/ 最优/ 局部/ 比/ 对/ ;/ |/ ALC/ (/ t/ ,/ p/ )/ |/ 表示/ 最优/ 比/ 对/ 结果/ 对应/ 的/ 分值/ ./ 定义/ 3/ (/ 局部/ 比/ 对/ 的/ 支配/ 关系/ )/ ./ 给定/ 子串/ p1/ ,/ p2/ ∈/ P/ ,/ t1/ ,/ t2/ ∈/ T/ ,/ 如果/ 它们/ 满足/ :/ (/ 1/ )/ t1/ [/ |/ t1/ |/ -/ 1/ ]/ ,/ t2/ [/ |/ t2/ |/ -/ 1/ ]/ 在/ T/ 中/ 的/ 位置/ 相同/ ;/ (/ 2/ )/ p1/ [/ |/ p1/ |/ -/ 1/ ]/ ,/ p2/ [/ |/ p2/ |/ -/ 1/ ]/ 在/ P/ 中/ 的/ 位置/ 相同/ ;/ (/ 3/ )/ |/ ALC/ (/ t1/ ,/ p1/ )/ |/ / |/ ALC/ (/ t2/ ,/ p2/ )/ |/ ,/ 本文/ 称/ ALC/ (/ t1/ ,/ p1/ )/ 支配/ ALC/ (/ t2/ ,/ p2/ )/ (/ 记/ 作/ :/ ALC/ (/ t2/ ,/ p2/ )/ / ALC/ (/ t1/ ,/ p1/ )/ )/ ./ 问题/ 定义/ 1/ (/ 基于/ 阈值/ 的/ ALC/ )/ (/ 简称/ T/ -/ ALC/ )/ ./ 给定/ 原串/ T/ 、/ 查询/ 串/ P/ 以及/ 分数/ 阈值/ H/ ,/ 基于/ 分数/ 阈值/ 的/ ALC/ 返回/ T/ ,/ P/ 子串/ 之间/ 局部/ 比/ 对/ 分值/ 不/ 小于/ H/ 且/ 彼此之间/ 不/ 存在/ 支配/ 关系/ 的/ 子串/ 对/ ./ 问题/ 定义/ 2/ (/ 基于/ top/ -/ k/ 的/ ALC/ )/ (/ 简称/ K/ -/ ALC/ )/ ./ 给定/ 原串/ T/ 、/ 查询/ 串/ P/ 以及/ 正整数/ k/ ,/ 基于/ top/ -/ k/ 的/ ALC/ 返回/ T/ ,/ P/ 子串/ 之间/ 局部/ 比对分/ 数值/ 最高/ 且/ 彼此之间/ 不/ 存在/ 支配/ 关系/ 的/ k/ 对/ 子串/ ./ 2.3/ 相关/ 工作/ 局部/ 比/ 对/ 是/ 一种/ 衡量/ 字符串/ 间/ 子串/ 相似/ 程度/ 的/ 方法/ [/ 20/ -/ 26/ ]/ ./ 和/ 全局/ 比/ 对/ 相比/ ,/ 局部/ 比/ 对/ 具有/ 更/ 重要/ 的/ 实际意义/ ,/ 因此/ 它/ 也/ 受到/ 学者/ 的/ 更/ 多/ 关注/ ./ Smith/ -/ Waterman/ 算法/ [/ 2/ ]/ 是/ 基于/ 分数/ 阈值/ 的/ 局部/ 比/ 对/ 算法/ ./ 该/ 算法/ 的/ 最大/ 贡献/ 是/ 将/ 局部/ 比/ 对/ 问题/ 转换/ 为/ 动态/ 规划/ 问题/ ./ 具体/ 地/ ,/ 给定/ 原串/ T/ 和/ 查询/ 串/ P/ ,/ 该/ 算法/ 分别/ 计算/ T/ 和/ P/ 中/ 任意/ 两个/ 子串/ 间/ 的/ 最优/ 局部/ 比/ 对/ 结果/ ./ 由/ 文献/ [/ 2/ ]/ 可知/ ,/ 因为/ 任意/ 两个/ 子串/ 的/ 最优/ 局部/ 比/ 对/ 结果/ 依赖于/ 它们/ 子串/ 间/ 的/ 最优/ 局部/ 比/ 对/ 结果/ ,/ 所以/ 该/ 问题/ 的/ 最优/ 解/ 依赖于/ 更/ 小规模/ 子/ 问题/ 的/ 最优/ 解/ ./ 因此/ ,/ 该/ 问题/ 可以/ 使用/ 动态/ 规划/ 算法/ 进行/ 解决/ ./ 它/ 的/ 时间/ 复杂度/ 为/ 显然/ ,/ 当/ 文本/ 数据/ 的/ 规模/ 较大/ 时/ ,/ Smith/ -/ Waterman/ 算法/ 的/ 运行/ 效率/ 有待/ 提高/ ./ OASIS/ (/ OnlineandAccurateSearchtechniqueforInferringlocal/ -/ alignmentsonSequences/ )/ 算法/ 是/ Meek/ 等/ 人/ [/ 27/ ]/ 于/ 2003/ 年/ 提出/ 的/ ./ 与/ Smith/ -/ Waterman/ 算法/ 相比/ ,/ 它/ 做出/ 以下/ 改进/ :/ (/ 1/ )/ 它/ 为/ 原串/ T/ 建立/ 后缀/ 树/ 从而/ 避免/ 了/ 重复/ 计算/ 问题/ ;/ (/ 2/ )/ 为/ 每个/ 搜索/ 节点/ 维护/ 一个/ 长度/ 为了/ 比/ 对/ 计算/ ./ 它/ 的/ 缺点/ 是/ 只/ 适合/ 在/ 查询/ 串较/ 短时/ 使用/ ./ GPU/ 算法/ 是/ 由/ Salavert/ 等/ 人/ [/ 27/ ]/ 提出/ 的/ ./ 它/ 通过/ 使用/ BWT/ (/ Burrows/ -/ WheelerTransform/ )/ 索引/ 反向/ 搜索/ 原串/ 中/ 出现/ 的/ 子串/ ./ 该/ 方法/ 可以/ 模拟/ 基于/ 后缀/ 树/ 的/ 局部/ 比/ 对/ 计算/ 过程/ ./ ALAE/ (/ AcceleratingLocalAlignmentwithExactlyAffineGap/ )/ 是/ Yang/ 等/ 人/ [/ 8/ ]/ 提出/ 的/ ./ 它/ 是/ 以/ GPU/ 算法/ 为/ 基础/ 进行/ 研究/ 的/ ./ 与/ 之/ 不同/ 的/ 是/ ,/ 该/ 算法/ 提出/ 了/ 多种/ 过滤/ 和/ 复用/ 策略/ 以/ 减少/ 不必要/ 的/ 计算/ 开销/ ./ 3/ 算法/ 描述/ 本/ 节/ 讨论/ 了/ 基于/ 外存/ 后缀/ 树/ 的/ 局部/ 比/ 对/ 算法/ ./ 首先/ ,/ 本文/ 在/ 3.1/ 节/ 提出/ 了/ 研究/ 框架/ ESF/ (/ ExtendSuffixFramework/ )/ ./ 接下来/ ,/ 本文/ 在/ 3.2/ 节/ 提出/ 算法/ ESLA/ (/ ExtendSuffixLocalAlignment/ )/ 解决/ 基于/ 外存/ 后缀/ 树/ 的/ T/ -/ ALC/ (/ 基于/ 阈值/ 的/ ALC/ )/ 问题/ ./ 以此/ 为/ 基础/ ,/ 本文/ 在/ 3.3/ 节近/ 一步/ 研究/ 了/ top/ -/ k/ 局部/ 比/ 对/ 算法/ ./ 最后/ ,/ 本文/ 在/ 3.4/ 节/ 提出/ 了/ 一系列/ 外存/ 优化/ 算法/ 降低/ I/ // O/ 开销/ ./ 3.1/ 基于/ 外存/ 后缀/ 树/ 的/ 算法/ 框架/ 本/ 节/ 提出/ 框架/ ESF/ (/ ExtendSuffixFramework/ )/ 支持/ 基于/ 外存/ 后缀/ 树/ 的/ 局部/ 比/ 对/ 计算/ ./ 本文/ 使用/ 后缀/ 树/ 作为/ 文本/ 索引/ 的/ 原因/ 如下/ :/ (/ 1/ )/ 基于/ 公共/ 前缀/ 的/ 索引/ 方式/ ./ 后缀/ 树/ 可以/ 将/ 原串/ 中/ 不同/ 的/ 后缀/ 按照/ 其/ 公共/ 前缀/ 进行/ 索引/ ./ 基于/ 该/ 性质/ ,/ 算法/ 在/ 执行/ ALC/ 时/ ,/ 不同/ 子串/ 的/ 公共/ 前缀/ 只/ 需/ 计算/ 一次/ ./ 因此/ ,/ 它/ 可以/ 减少/ 冗余/ 的/ 计算/ 量/ ;/ (/ 2/ )/ 自/ 适应/ 于/ 内存空间/ ./ 虽然/ 后缀/ 树是/ 一种/ 全文索引/ 结构/ ,/ 但是/ 它/ 可以/ 被/ 划分/ 成/ 许多/ 子树/ ./ 基于/ 这个/ 性质/ ,/ ESF/ 可以/ 根据/ 内存容量/ 自/ 适应/ 地/ 选择/ 某些/ 子树/ 读入/ 内存/ ./ 因此/ ,/ 后缀/ 树/ 适于/ 在/ 外存/ 环境/ 下/ 支持/ 字符串/ 间/ 的/ ALC/ 操作/ ./ 如图/ 3/ 所示/ ,/ ESF/ 主要/ 由/ 两/ 部分/ 组成/ ./ 第/ 1/ 部分/ Page5/ 是/ 关于/ 原串/ T/ 和/ 后缀/ 树/ ESF/ 分别/ 将/ 后缀/ 树/ 子串/ 放入/ 内存/ (/ 图中/ 的/ 黑色/ 部分/ )/ ./ 当/ 查询/ 串/ P/ 到来/ 时/ ,/ ESF/ 根据/ 查询/ 类型/ 和/ 操作/ 类型/ 分别/ 调用/ ESLA/ 算法/ ,/ ESLAk/ (/ 基于/ top/ -/ k/ 的/ ESLA/ )/ 算法/ 和/ ESBR/ (/ ExtendSuffixBatchRead/ )/ 算法/ ./ ESLA/ 算法/ 可以/ 在/ 外存/ 后缀/ 树上/ 解决/ T/ -/ ALC/ 问题/ ./ 给定/ 原串/ T/ 、/ 查询/ 串/ P/ 、/ 后缀/ 树子/ 树/ / s/ ,/ ESLA/ 在/ 遍历/ 过程/ 中/ 根据/ 行/ ALC/ 操作/ 并/ 返回/ 满足/ 查询/ 条件/ 的/ 结果/ ./ 需要/ 强调/ 的/ 是/ :/ ESLA/ 克服/ 了/ 如下/ 挑战/ 提高/ 计算/ 效率/ :/ (/ 1/ )/ 引入/ ALAE/ 中/ 的/ 多种/ 局部/ 过滤/ 策略/ ,/ 并/ 使/ 它们/ 与/ 后缀/ 树/ 有机/ 结合/ ;/ (/ 2/ )/ 引入/ ALAE/ 中/ 提出/ 的/ 叉子/ 区域/ ./ 以此/ 为/ 基础/ ,/ ESLA/ 基于/ 叉子/ 区域/ 的/ 支配/ 关系/ ①/ 进一步/ 加强/ 了/ 算法/ 的/ 过滤/ 能力/ ./ 以/ ESLA/ 算法/ 为/ 基础/ ,/ 本文/ 近/ 一步/ 提出/ ESLAk/ 算法/ 解决/ K/ -/ ALC/ 问题/ ./ 为了/ 克服/ TA/ (/ ThresholdAlgorithm/ )/ 算法/ 的/ 固有/ 问题/ 和/ 衍生/ 问题/ ②/ ,/ 本文/ 引入/ 启发式/ 算法/ 寻找/ 合适/ 的/ 阈值/ ./ 基于/ 该/ 阈值/ ,/ ESLAk/ 算法/ 可以/ 快速/ 地/ 过滤/ 中间/ 结果/ ./ 此外/ ,/ ESLAk/ 提出/ 一种/ 巧妙/ 的/ 数据结构/ 维护/ 候选/ 对象/ ./ 它/ 的/ 好处/ 是/ 可以/ 高效/ 维护/ 候选/ 结果/ 间/ 的/ 支配/ 关系/ ,/ 从而/ 降低/ 维护/ 代价/ ./ 最后/ ,/ ESF/ 提出/ 算法/ ESBR/ (/ ExtendSuffixBatchRead/ )/ 优化/ 外存/ 操作/ ./ 它/ 是/ 基于/ 以下/ 研究/ 动机/ 提出/ 的/ :/ (/ 1/ )/ 后缀/ 树/ 相邻/ 边上/ 保存/ 的/ 子串/ 不/ 满足/ 局部性/ 原理/ ./ 在/ 很多/ 情况/ 下/ ,/ 它们/ 在/ 原串/ 中/ 的/ 位置/ 相距/ 很/ 远/ ;/ (/ 2/ )/ 后缀/ 树/ 边上/ 只/ 保存/ 子串/ 的/ 概要/ 信息/ 且/ ESF/ 只能/ 在/ 内存/ 中/ 保留/ T/ 的/ 一个/ 子串/ ,/ ESF/ 需要/ 多次/ 访问/ 磁盘/ 加载/ 目标/ 子串/ ./ 由于/ 该/ 操作/ 代价/ 较/ 高/ ,/ 算法/ 必须/ 谨慎/ 选择/ 读入/ 内存/ 的/ 原串/ 从而/ 避免/ 频繁/ 的/ I/ // O/ 操作/ ./ 为了/ 达到/ 这个/ 目标/ ,/ 算法/ 根据/ 后缀/ 树/ 的/ 性质/ 提出/ 以下/ 两个/ 优化/ 策略/ :/ (/ 1/ )/ 选择/ 原串/ 中/ 访问/ 频率/ 较/ 高/ 的/ 子串/ 常驻/ 内存/ ./ 由/ 大量/ 观察/ 可知/ :/ 给定/ 原串/ T/ 和/ 其/ 对应/ 的/ 后缀/ 树/ 前半部/ 分/ ./ 因此/ ,/ ESBR/ 尽可能/ 将/ T/ 的/ 前部/ 常驻/ 内存/ ;/ (/ 2/ )/ 基于/ 批处理/ 的/ 磁盘操作/ ./ 本文/ 提出/ 了/ 一种/ 延迟/ 读取/ 策略/ ./ 该/ 策略/ 的/ 核心思想/ 是/ 缓存/ 涉及/ I/ // O/ 操作/ 的/ 子串/ ./ 当/ 此类/ 子串/ 的/ 数目/ 到达/ 上限/ 时/ ,/ 算法/ 根据/ 这些/ 子串/ 在/ 磁盘/ 中/ 的/ 位置/ 规划/ 出/ 最优/ 的/ 搜索/ 顺序/ ./ 由/ 前文/ 可知/ ,/ 磁盘/ 的/ 顺序/ 读写/ 有着/ 较/ 高/ 的/ 效率/ ./ 本文/ 的/ 延迟/ 读取/ 策略/ 恰好/ 迎合/ 了/ 这/ 一/ 特性/ ./ 此外/ ,/ 由于/ 排序/ 后/ 子串/ 在/ 原串/ 中/ 位置/ 往往/ 相近/ 并且/ ESBR/ 是/ 以块/ ③/ 为/ 单位/ 读取数据/ ,/ 这些/ 子串/ 经常/ 会/ 出现/ 在/ 同/ 一块/ 中/ ./ 因此/ ,/ 这种/ 批处理/ 方法/ 可以/ 近/ 一步/ 地/ 降低/ I/ // O/ 访问/ 次数/ ./ 3.2/ 计算/ 局部/ 比/ 对/ 的/ 过滤/ 策略/ 在/ 外存/ 环境/ 下/ 执行/ T/ -/ ALC/ 时/ ,/ 一种/ 简单/ 的/ 方法/ 是/ 使用/ Smith/ -/ Waterman/ 算法/ ./ 它/ 可以/ 通过/ 矩阵/ 运算/ 得到/ 局部/ 比/ 对/ 结果/ ./ 然而/ ,/ 该/ 算法/ 的/ 时间/ 代价/ 较大/ ./ 为了/ 提升/ 效率/ ,/ 本文/ 提出/ 了/ ESLA/ (/ ExtendSuffixLocalAlignment/ )/ 算法/ 加速/ 计算/ ./ 一方面/ ,/ 该/ 算法/ 借助/ 外存/ 后缀/ 树/ 实现/ 了/ ALAE/ 算法/ 中/ 的/ 几种/ 局部/ 过滤/ 策略/ ./ 另一方面/ ,/ ESLA/ 根据/ 局部/ 比/ 对/ 结果/ 间/ 的/ 支配/ 关系/ 近/ 一步/ 加强/ 了/ 算法/ 的/ 过滤/ 能力/ ./ 3.2/ ./ 1/ 基于/ 阈值/ 的/ 局部/ 过滤/ 策略/ 使用/ 外存/ 后缀/ 树/ 执行/ ALC/ 操作/ 时/ ,/ ESLA/ 的/ 整体/ 思路/ 是从/ 外存/ 中/ 依次/ 读取/ 后缀/ 子树/ ,/ 遍历/ 这些/ 子树/ ,/ 得到/ 子树/ 边上/ 对应/ 的/ 子串/ ,/ 执行/ ALC/ 操作/ ./ 对于/ 任意/ 后缀/ 而言/ ,/ 因为/ 它/ 都/ 可以/ 通过/ 一次/ 深度/ 优先/ 遍历/ 获得/ ,/ 所以/ 提高/ ESLA/ 性能/ 的/ 一个/ 有效途径/ 是/ 缩短/ 它/ 在/ 后缀/ 树上/ 的/ 遍历/ 范围/ ./ 本文/ 首先/ 通过/ 引入/ ALAE/ 中/ 的/ 几种/ 局部/ 过滤/ 策略/ 降低/ 遍历/ 代价/ ./ 它们/ 包括/ 长度/ 过滤/ 、/ 前缀/ 过滤/ 和/ 分数/ 过滤/ ./ 本文/ 首先/ 讨论/ 长度/ 过滤/ ./ 引理/ 1/ ./ 给定/ 查询/ 串/ P/ 、/ 原串/ T/ 、/ 子串/ t/ ∈/ T/ 和/ 分数/ 阈值/ H/ ,/ 如果/ t/ 是/ 比/ 对/ 结果/ ,/ 它/ 的/ 长度/ 需要/ 满足/ 不等式/ H/ // sa/ / max/ {/ m/ ,/ n/ +/ (/ H/ -/ sa/ ×/ m/ +/ sg/ )/ // ss/ }/ ./ 其中/ |/ t/ |/ 为/ t/ 的/ 长度/ ./ 证明/ ./ 对于/ |/ t/ |/ 的/ 下限/ ,/ 因为/ 分数/ 阈值/ 为/ H/ ,/ 即使/ t/ 中/ 所有/ 字符/ 均/ 与/ P/ 中/ 对应/ 字符/ 匹配/ ,/ |/ t/ |/ 也/ 不能/ 小于/ H/ // sa/ ./ 对于/ |/ t/ |/ 的/ 上限/ ,/ 它/ 的/ 含义/ 是/ ALC/ 中有/ m/ 个/ 连续/ 的/ 匹配/ 操作/ ,/ 其余/ 的/ 为/ Gap/ 操作/ ./ 为了/ 满足/ 分数/ 阈值/ H/ 的/ 要求/ ,/ Gap/ 操作/ 的/ 次数/ 需要/ 控/ ①/ ②/ ③/ Page6/ 制在/ (/ H/ -/ sa/ ×/ m/ +/ sg/ )/ // ss/ 以内/ ./ 因此/ ,/ |/ t/ |/ 不能/ 大于/ max/ {/ m/ ,/ m/ +/ (/ H/ -/ sa/ ×/ m/ +/ sg/ )/ // ss/ }/ ./ 根据/ 引理/ 1/ ,/ 长度/ 过滤/ 可以/ 减少/ 一些/ 不必要/ 的/ 局部/ 比/ 对/ 计算/ ./ 以此/ 为/ 基础/ ,/ 本文/ 提出/ 定理/ 1/ ./ 它/ 帮助/ 我们/ 缩小/ 深度/ 优先/ 遍历/ 的/ 范围/ ./ 为了/ 方便/ 说明/ ,/ 给定/ 根/ 节点/ r/ 、/ 非/ 叶子/ 节点/ ein/ ,/ 本文/ 用/ |/ s/ (/ r/ →/ ein/ )/ |/ 表示/ s/ (/ r/ →/ ein/ )/ 上/ 维护/ 的/ 子串/ 长度/ 之/ 和/ ;/ 用/ e/ 表示/ s/ (/ r/ →/ ein/ )/ 上/ 子串/ 在/ 原串/ 中/ 索引/ 位置/ 的/ 终点/ 值/ ;/ 用/ Lmin/ 表示/ 长度/ 过滤/ 的/ 下/ 限值/ ./ 定理/ 1/ ./ 给定/ 后缀/ 树/ ein/ 满足/ 不等式/ :/ Lmin/ / |/ T/ |/ -/ e/ +/ |/ s/ (/ r/ →/ ein/ )/ |/ ,/ 则/ 它/ 的/ 子孙/ 在/ 深度/ 优先/ 遍/ 历时/ 可以/ 被/ 剪枝/ ./ 证明/ ./ 给定/ 原串/ T/ 和/ 它/ 对应/ 的/ 后缀/ 树上/ 索引/ 的/ 子串/ 是/ 它/ 在/ T/ 中/ 出现/ 最早/ 的/ 位置/ ./ 给定/ ein/ 的/ 父/ 节点/ pin/ 和/ 它们/ 之间/ 的/ 边/ s/ (/ pin/ →/ ein/ )/ ,/ 如果/ s/ (/ pin/ →/ ein/ )/ 上/ 存储/ 子串/ 的/ 终止/ 位置/ 为/ e/ ,/ 则/ 从/ ein/ 到/ 其/ 任意/ 子孙/ 对应/ 边上/ 索引/ 的/ 子串/ 长度/ 不会/ 超过/ |/ T/ |/ -/ e/ ./ 根据/ 长度/ 过滤/ ,/ 用来/ 比/ 对/ 的/ T/ 的/ 子串/ 长度/ 必须/ 不/ 小于/ Lmin/ ,/ 假设/ 从根/ 节点/ 与/ 某内/ 节点/ 之间/ 边上/ 的/ 子串/ 长度/ 为/ |/ s/ (/ r/ →/ ein/ )/ |/ ,/ 则/ 仍然/ 需要/ Lmin/ -/ |/ s/ (/ r/ →/ ein/ )/ |/ 个字符/ 才/ 符合要求/ ,/ 也就是说/ 如果/ 内/ 节点/ 不/ 满足/ 关系/ |/ T/ |/ -/ e/ / Lmin/ -/ |/ s/ (/ r/ →/ ein/ )/ |/ ,/ 继续/ 访问/ 其/ 子孙/ 节点/ 是/ 没有/ 意义/ 的/ ./ 利用/ 定理/ 1/ ,/ 本文/ 可以/ 在/ 后缀/ 树上/ 实现/ 长度/ 过滤/ ./ 除此之外/ ,/ 本文/ 使用/ 分数/ 过滤/ 加速/ 比/ 对/ 计算/ ./ 具体/ 地/ ,/ 给定/ 子串/ t/ ∈/ T/ ,/ p/ ∈/ P/ ,/ 如果/ ALC/ (/ t/ [/ 0/ ,/ i/ ]/ ,/ p/ [/ 0/ ,/ j/ ]/ )/ / 0/ ,/ 计算/ |/ ALC/ (/ t/ ,/ p/ )/ |/ / 0/ 是/ 无效/ 的/ [/ 8/ ]/ ./ 由于/ 这种/ 过滤/ 策略/ 不/ 依赖于/ 后缀/ 树/ ,/ 本文/ 不再/ 叙述/ 它/ 的/ 使用/ 方法/ ./ 接下来/ ,/ 本文/ 讨论/ 前缀/ 过滤/ ./ 给定/ 子串/ t/ ∈/ T/ 和/ p/ ∈/ P/ ,/ 前缀/ 过滤/ 的/ 核心思想/ 是/ 根据/ t/ 和/ p/ 的/ 前/ q/ 个字符/ 进行/ 过滤/ ./ 具体/ 地/ ,/ 如果/ T/ [/ 0/ ,/ q/ -/ 1/ ]/ ≠/ P/ [/ 0/ ,/ q/ -/ 1/ ]/ ,/ 则/ ALC/ (/ t/ ,/ p/ )/ 可以/ 提前结束/ ./ 其中/ ,/ q/ =/ min/ {/ |/ sb/ |/ ,/ |/ sg/ +/ ss/ |/ }/ // sa/ +/ 1/ ;/ sa/ 表示/ 匹配/ 操作/ ;/ sb/ 表示/ 替换/ 操作/ ./ 为了/ 实现/ 前缀/ 过滤/ ,/ 本文/ 为/ 查询/ 串/ P/ 建立/ 了/ q/ 长/ 子串/ 的/ 倒排/ 索引/ 中/ 子串/ 的/ q/ 长/ 前缀/ 在/ P/ 中/ 的/ 起始/ 位置/ ./ 显然/ ,/ ESLA/ 从/ 这些/ 位置/ 开始/ 计算/ 就/ 可以/ 得到/ 比/ 对/ 结果/ ./ 综上所述/ ,/ 上述/ 3/ 种/ 局部/ 过滤/ 策略/ 易于/ 在/ 后缀/ 树上/ 实现/ ./ 通过/ 引入/ 这些/ 过滤/ 策略/ ,/ ESLA/ 可以/ 有效/ 降低/ 计算/ 代价/ ./ 接下来/ ,/ 本文/ 介绍/ 基于/ 支配/ 关系/ 的/ 过滤/ 技术/ ./ 3.2/ ./ 2/ 基于/ 支配/ 关系/ 的/ 全局/ 过滤/ 策略/ 由/ 问题/ 定义/ 2.1/ 可知/ ,/ 局部/ 比/ 对/ 问题/ 不仅/ 要求/ 比/ 对/ 结果/ 的/ 分值/ 不/ 小于/ 阈值/ H/ ,/ 而且/ 要求/ 比/ 对/ 结果/ 之间/ 不/ 存在/ 支配/ 关系/ ./ 本节/ 首先/ 引入/ 叉子/ 区域/ 的/ 概念/ ./ 其次/ ,/ 本文/ 基于/ 叉子/ 区域/ 提出/ 基于/ 支配/ 关系/ 的/ 过滤/ 算法/ ./ 叉子/ 区域/ 是/ 根据/ 前缀/ 过滤/ 和/ 分数/ 过滤/ 形成/ 的/ ./ 给定/ 局部/ 比/ 对/ ALC/ (/ t/ ,/ p/ )/ ,/ 如果/ 它/ 不/ 被/ 过滤/ ,/ 它/ 一定/ 满足/ 以下/ 条件/ :/ (/ 1/ )/ t/ ,/ p/ 之间/ 的/ 公共/ 前缀/ 长度/ 大于/ q/ -/ 1/ ;/ (/ 2/ )/ ALC/ (/ t/ ,/ p/ )/ / 0/ ./ 如图/ 4/ 所示/ ,/ 局部/ 比/ 对/ 的/ 计算/ 区域/ 在/ 形状/ 上/ 可以/ 看成/ 是/ 一个/ 叉子/ [/ 8/ ]/ ./ 在/ 这里/ ,/ EMR/ 代表/ 准确/ 匹配/ 区域/ ;/ NGR/ 代表/ 不/ 存在/ Gap/ 操作/ 的/ 区域/ ./ X/ 表示/ 一条/ 子串/ ./ 近/ 一步/ ,/ 根据/ 叉子/ 区域/ ,/ 算法/ 可以/ 找到/ 比/ 对/ 结果/ 间/ 的/ 支配/ 关系/ ./ 为了/ 便于/ 描述/ ,/ 本文/ 用/ 叉子/ 表示/ 两/ 子串/ 间/ 的/ 局部/ 比/ 对/ 计算/ 区域/ ./ ALC/ (/ is/ ,/ js/ ,/ ie/ ,/ je/ )/ 表示/ 基于/ T/ [/ is/ ,/ ie/ ]/ 、/ P/ [/ js/ ,/ je/ ]/ 得到/ 的/ 最优/ 局部/ 比/ 对/ 结果/ ./ 定义/ 4/ (/ 叉子/ 区域间/ 的/ 支配/ 关系/ )/ ./ 给定/ 子串/ T/ [/ is/ ,/ ie/ ]/ ∈/ T/ ,/ P/ [/ is/ ,/ ie/ ]/ ∈/ P/ 和/ 它们/ 形成/ 的/ 叉子/ 区域/ A/ ,/ 如果/ ALC/ (/ is/ ,/ js/ ,/ ie/ ,/ je/ )/ >/ 0/ 且/ T/ [/ ix/ ,/ ix/ +/ q/ -/ 1/ ]/ =/ P/ [/ jy/ ,/ jy/ +/ q/ -/ 1/ ]/ ,/ 则/ Ax/ / A/ ,/ 其中/ ix/ ∈/ [/ is/ ,/ ie/ ]/ ;/ jy/ ∈/ [/ js/ ,/ je/ ]/ ;/ Ax/ 表示/ 起始/ 点为/ ix/ ,/ jy/ 的/ 叉子/ 区域/ ./ 根据/ 定义/ 4/ 可知/ ,/ 如果/ 叉子/ 区域/ Ax/ 的/ 起始/ 位置/ 包含/ 于/ 叉子/ 区域/ A/ ,/ 则/ Ax/ / A/ ./ 实例/ 1/ ./ 图/ 5/ 演示/ 了/ 两个/ 叉子/ 区域/ 的/ 支配/ 关系/ ./ 图中/ X/ 和/ Y/ 分别/ 表示/ T/ [/ is/ ,/ ie/ ]/ 和/ P/ [/ js/ ,/ je/ ]/ ./ T/ [/ is/ ,/ ie/ ]/ 和/ P/ [/ js/ ,/ je/ ]/ 的/ 局部/ 比/ 对/ 计算/ 区域/ 是/ 叉子/ 区域/ A/ ,/ 它/ 的/ 起始/ 位置/ 有/ q/ 个/ 匹配/ 操作/ ./ 在/ 叉子/ 区域/ A/ 的/ 位置/ (/ ix/ ,/ jy/ )/ 处/ ,/ 虽然/ T/ [/ ix/ ,/ ix/ +/ q/ -/ 1/ ]/ =/ P/ [/ jy/ ,/ jy/ +/ q/ -/ 1/ ]/ ,/ ESLA/ 可以/ 在/ (/ ix/ ,/ jy/ )/ 处/ 开辟/ 新/ 的/ 叉子/ Ax/ ,/ 但/ Ax/ 中/ 参与/ 局部/ 比/ 对/ 的/ 子串/ 是/ A/ 中/ 参与/ 局部/ 比/ 对/ 的/ 子串/ 后缀/ ./ 假设/ 基于/ A/ 和/ Ax/ 得到/ 的/ 最终/ 叉子/ 区域/ 分别/ 为/ A/ (/ is/ ,/ js/ ,/ ie/ ,/ je/ )/ 和/ Ax/ (/ ix/ ,/ jx/ ,/ ie/ ,/ je/ )/ ,/ 因为/ A/ (/ is/ ,/ js/ ,/ ie/ ,/ je/ )/ =/ A/ (/ is/ ,/ js/ ,/ ix/ ,/ jx/ )/ +/ Ax/ (/ ix/ ,/ jx/ ,/ ie/ ,/ je/ )/ 且/ A/ (/ is/ ,/ js/ ,/ ix/ ,/ jx/ )/ >/ 0/ ,/ 所以/ Ax/ (/ ix/ ,/ jx/ ,/ ie/ ,/ je/ )/ </ A/ (/ is/ ,/ js/ ,/ ie/ ,/ je/ )/ ./ 由此可知/ ,/ 计算/ Ax/ 是/ 没有/ 意义/ 的/ ./ 根据/ 如/ 上/ 描述/ ,/ 如果/ ESLA/ 在/ 开启/ 一个/ 叉子/ 区/ Page7/ 域前/ 判定/ 它/ 是否/ 被/ 支配/ ,/ ESLA/ 可以/ 减少/ 很多/ 不必要/ 的/ 计算/ ./ 由/ 上文/ 可知/ ,/ 判断/ 一个/ 叉子/ 区域/ 是否/ 被/ 支配/ 的/ 先决条件/ 是/ 判断/ 其/ 是否/ 包括/ 在/ 另/ 一个/ 已/ 计算/ 的/ 叉子/ 区域/ 中/ ./ 为了/ 达到/ 这个/ 目的/ ,/ ESLA/ 需要/ 维护/ 结果/ 间/ 的/ 支配/ 信息/ ./ 它/ 的/ 难点/ 是/ 随着/ 结果/ 数量/ 的/ 逐渐/ 增多/ ,/ ESLA/ 需要/ 维护/ 的/ 叉子/ 个数/ 也/ 会/ 增多/ ./ 一个/ 简单/ 的/ 策略/ 是/ 缓存/ 所有/ 的/ “/ q/ 匹配/ 操作/ ”/ ./ 它/ 指/ 的/ 是/ 在/ 计算/ 某个/ 叉子/ 区域/ 的/ 过程/ 中/ ,/ 一旦/ 碰到/ 连续/ q/ 个/ 匹配/ 操作/ ,/ ESLA/ 就/ 将/ 匹配/ 的/ 起始/ 位置/ 记录下来/ ./ 当/ 开始/ 计算/ 新/ 的/ 叉子/ 区域/ 时/ ,/ ESLA/ 查询/ 起始/ 位置/ 信息/ 是否/ 被/ 包括/ ./ 如果/ 是/ ,/ 此次/ ALC/ 可以/ 被/ 过滤/ ./ 然而/ ,/ 该/ 策略/ 存在/ 的/ 问题/ 是/ 需要/ 保存/ 许多/ 历史记录/ ./ 为了/ 解决/ 上述/ 问题/ ,/ 本文/ 首先/ 提出/ q/ -/ prefix/ 的/ 概念/ ./ 随后/ ,/ 本文/ 基于/ q/ -/ prefix/ 的/ 字典/ 序/ 提高/ 计算/ 效率/ ./ 具体/ 地/ ,/ 给定/ q/ -/ prefixq1/ 和/ q2/ ,/ 如果/ q1/ 的/ 字典/ 序/ 小于/ q2/ 的/ 字典/ 序/ ,/ ESLA/ 优先/ 计算/ 与/ q1/ 相/ 呼应/ 的/ 叉子/ 区域/ ./ 定义/ 5/ (/ q/ -/ prefix/ )/ ./ 给定/ 叉子/ 区域/ A/ 和/ 它们/ 对应/ 的/ 子串/ T/ [/ is/ ,/ ie/ ]/ ∈/ T/ ,/ P/ [/ is/ ,/ ie/ ]/ ∈/ P/ ,/ 本文/ 将/ T/ [/ is/ ,/ ie/ ]/ 中前/ q/ 个/ 匹配/ 操作/ 称为/ q/ -/ prefix/ ./ 具体/ 地/ ,/ 在/ 计算/ 某个/ 局部/ 比/ 对/ 的/ 过程/ 中/ ,/ 当/ 遇见/ 连续/ q/ 个/ 匹配/ 操作/ 时/ (/ 不/ 包括/ 起始/ 位置/ 的/ q/ -/ prefix/ )/ ,/ ESLA/ 比较/ 该/ 子串/ 和/ 其他/ q/ -/ prefix/ 的/ 字典/ 序/ ./ 如果/ 该/ 子串/ 具有/ 更大/ 的/ 字典/ 序/ ,/ ESLA/ 则/ 储存/ 该/ 位置/ 信息/ ./ 基于/ 这种/ 方法/ ,/ 本文/ 可以/ 判定/ 哪些/ 叉子/ 区域/ 已/ 被/ 计算/ (/ 或/ 未/ 被/ 计算/ )/ ./ 图/ 6/ 是/ 一个/ ALC/ 中/ 遇到/ 连续/ q/ 次/ 匹配/ 操作/ 的/ 示意图/ ./ 根据/ 图中/ 的/ 分数/ 策略/ ,/ q/ =/ 4/ ./ 图中/ 的/ q/ -/ prefix/ 是/ 字符串/ “/ ACGT/ ”/ ,/ 在/ 局部/ 比/ 对/ 过程/ 中/ ,/ ESLA/ 遇到/ 了/ 其他/ q/ -/ prefix/ “/ CAGT/ ”/ 和/ “/ AAAA/ ”/ ./ 因为/ C/ 的/ 字典/ 序/ 大于/ A/ ,/ 所以/ “/ CAGT/ ”/ 的/ 字典/ 序/ 大于/ “/ ACGT/ ”/ ;/ ESLA/ 可以/ 判定/ 以/ “/ CAGT/ ”/ 开始/ 的/ 叉子/ 区域/ 未/ 被/ 计算/ ./ 因此/ ,/ ESLA/ 将/ 其/ 对应/ 在/ 原串/ T/ 和/ 查询/ 串/ P/ 中/ 的/ 出现/ 位置/ 保存起来/ ./ 相反/ ,/ 因为/ “/ AAAA/ ”/ 的/ 字典/ 序/ 小于/ “/ ACGT/ ”/ ,/ 这/ 意味着/ 以/ “/ AAAA/ ”/ 开始/ 的/ 局部/ 比/ 对/ 已/ 被/ 计算/ ;/ 再/ 记录/ 其/ 出现/ 位置/ 是/ 没有/ 意义/ 的/ ./ 因此/ ,/ “/ AAAA/ ”/ 不/ 被/ 保存/ ./ 需要/ 强调/ 的/ 是/ ,/ 出于/ 空间/ 效率/ 考虑/ ,/ ESLA/ 不/ 保存/ q/ -/ prefix/ 的/ 位置/ 信息/ ./ 因此/ ,/ 该/ 策略/ 可能/ 会/ 导致/ 一些/ 冗余/ 计算/ ./ 当/ 开始/ 计算/ 一个/ 新/ 的/ 叉子/ 区域/ 时/ ,/ ESLA/ 首先/ 检查/ 起始/ 位置/ 是否/ 已经/ 被/ 保存/ ./ 如果/ 是/ ,/ ESLA/ 可以/ 判定/ 该/ 叉子/ 区域/ 已/ 被/ 计算/ ./ 进而/ ,/ ESLA/ 可以/ 推断/ 该/ 区域/ 已/ 被/ 支配/ ./ 在/ 这种/ 情况/ 下/ ,/ ESLA/ 过滤/ 该/ 叉子/ 区域/ ./ 需要/ 强调/ 的/ 是/ ,/ 那些/ 保留/ 的/ 被/ 支配/ 的/ 叉子/ 区域/ 的/ 起始/ 位置/ 是/ 按照/ 其/ q/ -/ prefix/ 进行/ 组织/ 的/ ./ 给定/ 一个/ 新/ 的/ q/ -/ prefixqnew/ ,/ 上述/ 策略/ 的/ 好处/ 是/ 当/ 开始/ 计算/ 以/ qnew/ 为/ 起始/ 的/ 叉子/ 区域/ 时/ ,/ ESLA/ 可以/ 释放/ 字典/ 序/ 小于/ qnew/ 的/ 被/ 支配/ 叉子/ 区域/ 的/ 起始/ 位置/ ,/ 从而/ 提升/ 算法/ 的/ 存储空间/ 利用率/ ./ 除此之外/ ,/ 本文/ 在/ 3.3/ 节/ 提出/ 了/ 一种/ 巧妙/ 的/ 数据结构/ 维护/ 候选/ 对象/ 之间/ 的/ 支配/ 关系/ ./ 这种/ 算法/ 也/ 适于/ 在/ 本节/ 使用/ ./ 最后/ 本文/ 对/ ESLA/ 算法/ 的/ 时间/ 复杂度/ 进行/ 分析/ ./ 这里/ ,/ 设/ 数据/ 构建/ 在/ 外存/ 的/ 索引/ 大小/ 为/ I/ ,/ 内存/ 块/ 大小/ 为/ Is/ ,/ 一次/ 遍历/ 外部/ 索引/ 的/ 最坏/ 代价/ 是/ 每个/ 块/ 在/ 内存/ 中/ 的/ 计算/ 代价/ 可以/ 借助/ 文献/ [/ 8/ ]/ 中/ 定理/ 4/ 的/ 分析/ 结果/ ,/ 算法/ 在/ 内存/ 中/ 的/ 计算/ 代价/ 是/ Page8/ (/ k/ // k2/ -/ 1/ +/ k1/ σ/ 2/ // σ/ -/ k2/ )/ |/ P/ |/ |/ T/ |/ logk2/ ./ 其中/ ,/ k1/ =/ (/ 1/ -/ 1/ // s/ )/ (/ σ/ -/ 1/ // σ/ -/ 2/ )/ (/ s/ // 2/ ∏/ (/ s/ -/ 11/ // (/ s/ -/ 1/ )/ s/ -/ 1/ )/ 1/ // s/ ,/ s/ =/ 1/ +/ |/ sb/ |/ // |/ sa/ |/ ,/ σ/ 是/ 字符集/ 的/ 个数/ ./ 从而/ ,/ 本文/ 可以/ 得出/ ESLA/ 在/ 整个/ 数据/ 集上/ 时间/ 复杂度/ 等于/ 3.3/ 基于/ top/ -/ 犽/ 的/ 局部/ 比/ 对/ 算法/ / 在/ 讨论/ 了/ 基于/ 阈值/ 的/ 局部/ 比/ 对/ 问题/ 之后/ (/ T/ -/ ALC/ )/ ,/ 本/ 节/ 根据/ 上节/ 的/ 研究/ 结果/ 讨论/ 基于/ top/ -/ k/ 的/ 局部/ 比/ 对/ 问题/ (/ K/ -/ ALC/ )/ ./ 由/ 问题/ 定义/ 可知/ ,/ 它/ 返回/ 分值/ 最高/ 且/ 彼此间/ 不/ 存在/ 支配/ 关系/ 的/ k/ 个/ 结果/ ./ 为了/ 解决/ 该/ 问题/ ,/ 本文/ 提出/ ESLAk/ (/ 基于/ top/ -/ k/ 的/ ESLA/ 算法/ )/ 算法/ ./ 该/ 算法/ 以/ ESLA/ 中/ 的/ 过滤/ 策略/ 为/ 基础/ ,/ 结合/ TA/ 算法/ 维护/ 候选/ 集合/ ./ 给定/ 原串/ T/ 、/ 查询/ 串/ P/ 和/ 候选/ 集/ / 来/ ,/ ESLAk/ 在/ 访问/ T/ 的/ 过程中将/ 满足/ 查询/ 条件/ 的/ 比/ 对/ 结果/ r/ 插入/ r/ ①/ ;/ (/ 2/ )/ r/ 不/ 被/ 条件/ ,/ ESLAk/ 将/ r/ 插入/ 地/ ,/ 在/ 插入/ 之后/ ,/ 如果/ |/ / |/ =/ k/ +/ 1/ ,/ ESLAk/ 丢弃/ min/ (/ 对于/ 第一个/ 插入/ 条件/ ,/ ESLAk/ 面临/ 的/ 挑战/ 是/ “/ 小/ 阈值/ ”/ 问题/ ./ 具体/ 地/ ,/ 由于/ 初始化/ 状态/ 下/ 算法/ 只能/ 将/ min/ (/ 低/ ,/ 它会/ 带来/ 以下/ 影响/ :/ (/ 1/ )/ 前/ 文/ 讨论/ 的/ 过滤/ 算法/ 很难/ 被/ 使用/ ;/ (/ 2/ )/ 在/ 算法/ 运行/ 初期/ ,/ 很多/ 分值/ 较/ 小/ 的/ 比/ 对/ 结果/ 也/ 会/ 加入/ 候选/ 集/ ./ 在/ 大多数/ 情况/ 下/ ,/ 它们/ 都/ 会/ 被/ 后/ 加入/ 的/ 比/ 对/ 结果/ 代替/ ./ 显然/ ,/ 存储/ 这样/ 的/ 对象/ 是/ 没有/ 意义/ 的/ ./ 总体/ 来说/ ,/ “/ 小/ 阈值/ ”/ 问题/ 会/ 消耗/ 不必要/ 的/ 计算资源/ ./ 因此/ ,/ 提高/ ESLAk/ 性能/ 的/ 关键/ 是/ 找到/ 合适/ 的/ 阈值/ H/ 代替/ min/ (/ 本文/ 使用/ 启发式/ 算法/ 初始化/ H/ ./ 由/ 前文/ 可知/ ,/ 在/ 评价/ 函数/ F/ (/ P/ ,/ T/ ,/ 配/ 操作/ 对/ ALC/ 贡献/ 正/ 分数/ ,/ 也就是说/ 只有/ 通过/ 匹配/ 操作/ 才/ 能够/ 提高/ ALC/ 的/ 分值/ ./ 根据上述/ 观察/ ,/ 本文/ 首先/ 找到/ k/ 个/ 不/ 相交/ 且/ 具有/ 最长/ 前缀/ 的/ 子串/ 对/ ./ 接下来/ ,/ 本文/ 基于/ 这/ k/ 个/ 子串/ 对/ 执行/ 比/ 对/ 计算/ ./ 近/ 一步/ ,/ 本文/ 用/ 这些/ 子串/ 对间/ 的/ 比/ 对/ 结果/ 初始化/ 然/ ,/ 此时/ 的/ min/ (/ 应地/ ,/ 第/ 1/ 个/ 问题/ 可以/ 被/ 解决/ ./ 在/ 初始化/ 滤/ 策略/ 加快/ 局部/ 比/ 对/ ./ 然而/ ,/ ESLAk/ 需要/ 面临/ 第/ 2/ 个/ 挑战/ :/ 它/ 需要/ 额外/ 判断/ 新/ 得到/ 的/ 比/ 对/ 结果/ 是否/ 被/ 中/ 元素/ 支配/ ./ 其/ 根本原因/ 是/ / 在/ T/ 中/ 的/ 各个/ 位置/ ,/ ESLAk/ 无法/ 像/ ESLA/ 一样/ 在/ 扫描/ 的/ 过程/ 中/ 维护/ 结果/ 间/ 的/ 支配/ 关系/ ./ 为了/ 解决/ 这个/ 问题/ ,/ ESLAk/ 使用/ 桶/ 结构/ 希表/ / 表/ 的/ 存储/ 示例/ 图/ ./ 图/ 7/ 的/ 下/ 半部/ 分为/ 哈希/ 表/ 每项/ 元素/ e/ 包含/ 两/ 部分/ 内容/ ./ 第/ 1/ 部分/ 是/ 关键字/ ,/ 它/ 存储/ 某一/ 局部/ 比/ 对/ 结果/ 的/ 结束/ 位置/ ./ 第/ 2/ 部分/ 是/ 二元/ 组/ 〈/ pt/ ,/ F/ (/ e/ )/ 〉/ ./ 其中/ ,/ pt/ 指向/ e/ 在/ F/ (/ e/ )/ 表示/ e/ 的/ 局部/ 比/ 对/ 分值/ ./ 图/ 7/ 的/ 上半/ 部分/ 刻画/ 了/ 桶/ / 的/ ./ 其中/ ,/ 具有/ 相同/ 分值/ 的/ 局部/ 比/ 对/ 结果/ 会/ 被/ 存储/ 在/ 同一个/ 桶/ 中/ ./ ESLAk/ 基于/ 的/ 局部/ 比/ 对/ 结果/ r/ 到来/ 时/ ,/ ESLAk/ 访问/ 的/ 目标/ 插入/ 位置/ Ir/ 执行/ 如下/ 操作/ ./ (/ 1/ )/ Ir/ =/ / ./ 这/ 说明/ r/ 既/ 不/ 支配/ 中/ 元素/ 支配/ ./ 在/ 这种/ 情况/ 下/ ,/ ESLAk/ 将/ r/ 插入/ Ir/ / ./ 与此同时/ ,/ ESLAk/ 更新/ 阈值/ H/ ./ / 和/ (/ 2/ )/ Ir/ ≠/ / 且/ Ir/ 中/ 存在/ 分值/ 小于/ F/ (/ r/ )/ 的/ 元素/ ./ 这/ 说明/ r/ 支配/ 首先/ 通过/ Ir/ ./ pt/ 定位/ r/ 支配/ 的/ 元素/ rd/ ./ 其次/ ,/ ESLAk/ 用/ r/ 替换/ rd/ ./ (/ 3/ )/ Ir/ ≠/ / 且/ Ir/ 中/ 不/ 存在/ 分值/ 小于/ F/ (/ r/ )/ 的/ 元素/ ./ 这/ 说明/ r/ 被/ Ir/ 中/ 的/ 元素/ 支配/ ./ 在/ 这种/ 情况/ 下/ ,/ ESLAk/ 直接/ 丢弃/ r/ ./ 综上所述/ ,/ ESLAk/ 通过/ 两/ 方面/ 的/ 优化/ 提高/ 了/ 计算/ 效率/ ./ 第一/ ,/ ESLAk/ 使用/ 启发式/ 策略/ 找到/ k/ 个分/ ①/ min/ (/ Page9/ 值/ 较大/ 的/ 比/ 对/ 结果/ ./ 通过/ 这种/ 方法/ ,/ ESLAk/ 可以/ 有效/ 解决/ “/ 小/ 阈值/ ”/ 问题/ ./ 第二/ ,/ 算法/ 使用/ 桶/ 维护/ 候选/ 对象/ ./ 借助/ 它们/ ,/ ESLAk/ 可以/ 快速/ 识别/ / 新/ 的/ 比/ 对/ 结果/ 是否/ 被/ 候选/ 集中/ 的/ 元素/ 支配/ ./ 3.4/ 外存/ 访问/ 优化/ 策略/ 前/ 文/ 研究/ 的/ 焦点/ 是/ 在/ 内存/ 环境/ 下/ 优化/ 基于/ 后缀/ 树/ 的/ 过滤/ 算法/ ./ 然而/ ,/ 后缀/ 树/ 只/ 索引/ 子串/ 的/ 概要/ 信息/ 并且/ ESF/ 只/ 将/ T/ 的/ 部分/ 子串/ 保存/ 在/ 内存/ ,/ 当待/ 访问/ 的/ 子串/ 不/ 在/ 内存/ 中/ 时/ ,/ 算法/ 需要/ 从/ 外存/ 中/ 读取数据/ ./ 此外/ ,/ 因为/ 后缀/ 树边/ 之间/ 存储/ 的/ 子串/ 在/ T/ 中/ 不是/ 连续/ 的/ ,/ 所以/ 磁盘/ 读取/ 操作/ 将会/ 频繁/ 发生/ ./ 显然/ ,/ 这会/ 导致/ 算法/ 的/ 性能/ 降低/ ./ 基于/ 上述/ 观察/ ,/ 本/ 节/ 提出/ ESLA/ 算法/ 优化/ 外存/ 的/ 访问/ ./ 为了/ 达到/ 这个/ 目的/ ,/ 本文/ 从/ 以下/ 两个/ 方面/ 入手/ :/ (/ 1/ )/ 对/ T/ 中/ 各/ 部分/ 子串/ 被/ 访问/ 的/ 频率/ 进行/ 研究/ ./ 基于/ 研究/ 结果/ ,/ 本文/ 挑选/ 一部分/ 访问/ 频率/ 高/ 的/ 子串/ 常驻/ 内存/ ;/ (/ 2/ )/ 找到/ 一种/ 可以/ 迎合/ 磁盘/ 工作/ 特性/ 的/ 访问/ 算法/ ./ 该/ 方法/ 可以/ 通过/ 实现/ 磁盘/ 的/ 顺序/ 访问/ 提高/ 磁盘/ 的/ 读取/ 效率/ ./ 显然/ ,/ 上述/ 两种/ 方法/ 可以/ 有效/ 降低/ 外存/ 访问/ 代价/ ./ 3.4/ ./ 1/ 后缀/ 树/ 访问/ 特性/ 的/ 分析/ 给定/ 原串/ T/ 和/ 它/ 对应/ 的/ 后缀/ 树/ 的/ 边/ 分为/ 两种/ :/ (/ 1/ )/ 内/ 边/ ;/ (/ 2/ )/ 叶边/ ./ 其中/ ,/ 内/ 边/ 表示/ 中间/ 节点/ 之间/ 的/ 边/ ;/ 叶边/ 表示/ 中间/ 节点/ 和/ 叶子/ 节点/ 之间/ 的/ 边/ ./ 通过观察/ 各类/ 边上/ 索引/ 的/ 子串/ 特征/ ,/ 本文/ 得到/ 如下/ 关于/ 字符串/ T/ 和/ 其/ 对应/ 后缀/ 树/ 的/ 特性/ :/ 特性/ 1/ ./ 大多数/ 情况/ 下/ ,/ 内/ 边上/ 索引/ 的/ 子串/ 出现/ 在/ T/ 的/ 前部/ ;/ 特性/ 2/ ./ 大多数/ 情况/ 下/ ,/ 内/ 节点/ 间/ 边上/ 索引/ 的/ 字符串/ 长度/ 较/ 短/ ./ 第/ 1/ 个/ 特性/ 是/ 根据/ 后缀/ 树/ 的/ 构造/ 过程/ 得到/ 的/ ./ 具体/ 地/ ,/ 后缀/ 树/ 边上/ 索引/ 的/ 内容/ 为/ T/ 中/ 的/ 最早/ 出现/ 的/ 字符串/ [/ 22/ ]/ ./ 这种/ 表示/ 方法/ 使得/ 内/ 边上/ 索引/ 的/ 字符串/ 大多/ 出现/ 在/ 原串/ T/ 的/ 前半部/ 分/ ./ 例如/ ,/ 给定/ 长为/ 2MB/ 老鼠/ 基因/ 和/ 以此/ 为/ 基础/ 构建/ 的/ 后缀/ 树/ ,/ 超过/ 86/ %/ 内/ 边上/ 索引/ 的/ 子串/ 出现/ 在/ 原串/ 的/ 前部/ ./ 因此/ ,/ 选择/ 原串/ 的/ 前部/ 常驻/ 内存/ 可以/ 降低/ 磁盘/ 的/ 访问/ 频率/ ./ 第/ 2/ 个/ 特性/ 是/ 根据/ 后缀/ 树/ 的/ 工作/ 原理/ 得到/ 的/ ./ 因为/ 后缀/ 树/ 根据/ 子串/ 的/ 公共/ 前缀/ 索引/ T/ 的/ 各/ 子串/ ,/ 所以/ 后缀/ 树上/ 的/ 大多数/ 内/ 边/ 包含/ 的/ 子串/ 长度/ 较/ 短/ ./ 原因/ 如下/ :/ 如/ 定理/ 2/ 所示/ ,/ 给定/ 随机/ 生成/ 的/ 字符串/ R/ 和/ 它/ 的/ 两个/ 后缀/ r1/ ,/ r2/ ,/ 因为/ r1/ ,/ r2/ 之间/ 存在/ 长/ 公共/ 前缀/ 的/ 概率/ 较/ 小/ ,/ 对于/ 大部分/ 子串/ 而言/ ,/ 它们/ 的/ 公共/ 前缀/ 都/ 是/ 较/ 短/ 的/ ./ 定理/ 2/ ./ 给定/ 随机/ 生成/ 的/ 字符串/ R/ 和/ 它/ 的/ 两个/ 后缀/ r1/ ,/ r2/ ,/ Pr/ (/ r1/ [/ 0/ ,/ d/ ]/ =/ r2/ [/ 0/ ,/ d/ ]/ )/ =/ 1/ // |/ Σ/ |/ d/ ./ 证明/ ./ 给定/ 任意/ r1/ [/ i/ ]/ 和/ r2/ [/ i/ ]/ ,/ Pr/ (/ r1/ [/ i/ ]/ =/ r2/ [/ i/ ]/ 等于/ 1/ // |/ Σ/ |/ ./ 因为/ Pr/ (/ r1/ [/ i/ ]/ =/ r2/ [/ i/ ]/ )/ 与/ Pr/ (/ r1/ [/ j/ ]/ =/ r2/ [/ j/ ]/ (/ i/ ≠/ j/ )/ 可以/ 看成/ 独立/ 事件/ ,/ 所以/ Pr/ (/ r1/ [/ 0/ ,/ d/ ]/ =/ r2/ [/ 0/ ,/ d/ ]/ =/ 1/ // |/ Σ/ |/ d/ ./ 3.4/ ./ 2/ 外存/ 操作/ 优化/ 技术/ 由/ 前文/ 可知/ ,/ 当对/ 后缀/ 树/ 进行/ 遍/ 历时/ ,/ 如果/ 边上/ 索引/ 的/ 子串/ 不/ 包含/ 在/ 内存/ 中/ ,/ ESLA/ 需要/ 从/ 磁盘/ 中/ 读出/ 相应/ 的/ 部分/ ./ 显然/ ,/ 外存/ 访问/ 策略/ 对于/ ESF/ 的/ 整体/ 性能/ 有/ 很大/ 的/ 影响/ ./ 本文/ 提出/ 算法/ ESBR/ ./ 它/ 根据/ 上/ 节/ 提到/ 的/ 两种/ 性质/ 优化/ ESF/ ./ 根据/ 特性/ 1/ ,/ ESF/ 尽可能/ 将/ 原串/ 的/ 前部/ 留在/ 内中/ ./ 除此之外/ ,/ 本文/ 提出/ 了/ 一种/ 批处理/ 算法/ 降/ / 存低/ I/ // O/ 代价/ ./ 首先/ 本文/ 给出/ 溢出/ 的/ 概念/ ./ 定义/ 6/ (/ 溢出/ )/ ./ 给定/ 后缀/ 树/ 和/ 它/ 索引/ 的/ 子串/ t/ ,/ 如果/ t/ 不/ 完全/ 包含/ 在/ 将/ 这种/ 情况/ 称为/ 溢出/ ./ 回顾/ 2.2/ 节对/ 后缀/ 树/ 的/ 描述/ ,/ 因为/ 后缀/ 树/ 相邻/ 边/ 之间/ 索引/ 的/ 子串/ 不/ 具有/ 局部性/ ,/ 所以/ 相邻/ 的/ 后缀/ 在/ 原串/ 中/ 的/ 位置/ 可能/ 相距/ 很远/ ./ 因此/ ,/ 在/ 遍历/ 后缀/ 树时/ ,/ 溢出/ 事件/ 会/ 频繁/ 发生/ ./ 显然/ ,/ 算法/ 会/ 因此/ 消耗/ 大量/ 的/ 磁盘/ 寻址/ 代价/ ./ 基于/ 上述/ 观察/ ,/ 本文/ 提出/ 一种/ 批处理/ 算法/ 解决/ 频繁/ 溢出/ 带来/ 的/ 问题/ ./ 其中/ ,/ 特性/ 2/ 保证/ 了/ 该/ 算法/ 的/ 可行性/ ./ 具体/ 地/ ,/ 当/ 溢出/ 发生/ 时/ ,/ ESLA/ 将/ 当前/ 进行/ 的/ ALC/ 中间/ 结果/ 存入/ 缓冲区/ 并/ 推迟/ 外存/ 读取/ 时间/ ./ 由/ 文献/ [/ 7/ -/ 8/ ]/ 可知/ ,/ 因为/ 需要/ 保存/ 的/ 中间/ 结果/ 主要/ 是/ 动态/ 规划/ 矩阵/ 的/ 一行/ ,/ 所以/ 保留/ 这些/ 中间/ 结果/ 需要/ 花费/ 较大/ 的/ 存储空间/ ./ 接下来/ ,/ 本文/ 使用/ 上/ 节/ 提到/ 的/ 特性/ 2/ 降低/ 存储/ 代价/ ./ 根据/ 上/ 节/ 描述/ ,/ 大多数/ 内/ 节点/ 索引/ 的/ 字符串/ 长度/ 相对/ 较/ 小/ ./ 如果/ 溢出/ 事件/ 发生/ 在内/ 边/ ,/ 计算/ 过/ 的/ 动态/ 规划/ 矩阵/ 的/ 行数/ 往往/ 较少/ ./ 在/ 这种/ 情况/ 下/ ,/ ESLA/ 如果/ 访问/ 到/ 发生/ 溢出/ 的/ 内边/ 便/ 停止/ 访问/ ,/ 需要/ 保存/ 的/ 字符串/ 长度/ 也/ 会/ 相应/ 变小/ ./ 显然/ ,/ 同/ 保存/ 完整/ 的/ 中间/ 结果/ 相比/ ,/ 该/ 策略/ 可以/ 有效/ 节省/ 存储空间/ ./ 显然/ ,/ 特性/ 2/ 可以/ 帮助/ ESF/ 花费/ 相对/ 较少/ 的/ 空间/ 存储/ 中间/ 结果/ ./ 然而/ ,/ 如果/ 溢出/ 发生/ 在/ 叶边/ ,/ ESF/ 需要/ 采用/ 相似/ 的/ 操作/ 策略/ ./ 和/ 内边/ 相比/ ,/ 叶边/ 发生/ 溢出/ 的/ 频率/ 更高且/ 需要/ 保存/ 的/ 中间/ 结果/ 也/ 越/ 多/ ./ 因此/ ,/ 这些/ 中间/ 结果/ 需要/ 更为/ 合理/ 的/ 管理/ 算法/ ./ 根据上述/ 讨论/ ,/ 本文/ 将/ 内存/ Page10/ / d/ ./ 其中/ ,/ 1/ ]/ )/ ./ 与/ 了/ 方便/ 对/ 这些/ 零散/ 的/ 字符串/ 进行/ 管理/ ,/ ESBR/ 提出/ 了/ 一种/ 槽/ (/ shot/ )/ 结构/ 管理/ 这些/ 数据/ ./ 定义/ 7/ (/ 槽/ )/ ./ 给定/ 散/ 列表/ {/ e0/ ,/ e1/ ,/ …/ ,/ en/ }/ ,/ 任意/ 元素/ ei/ 对应/ 于/ 一个/ 元组/ 〈/ keyi/ ,/ si/ 〉/ ./ 其中/ ,/ keyi/ 为/ 键值/ ,/ si/ 为/ 一个/ 数组/ ./ 通常/ ,/ 它/ 被/ 其/ 称为/ 槽/ ./ 具体/ 地/ ,/ ESBR/ 以槽/ 为/ 单位/ 与/ 磁盘/ 中/ 的/ 数据/ 进行/ 交换/ ,/ 交换/ 的/ 规模/ 等于/ 槽/ 的/ 大小/ ./ 为/ 决定/ 哪些/ 槽/ 需要/ 交换/ ,/ ESBR/ 为/ 每/ 一个/ 槽/ 赋予/ 一个/ 优先级/ ./ 当/ 需要/ 进行/ 数据交换/ 时/ ,/ ESBR/ 访问/ 优先级/ 低/ 的/ 槽/ 并/ 将/ 它/ 存储/ 的/ 内容/ 替换/ 为/ 新/ 读入/ 的/ 数据/ ./ 为了/ 给/ 所有/ 槽/ 设置/ 合理/ 的/ 优先级/ ,/ 本文/ 为/ 所有/ 槽/ 附加/ 了/ 字/ 段/ at/ (/ accessingtime/ )/ ./ 它/ 记录/ 了/ 槽内/ 数据/ 被/ 访问/ 的/ 次数/ ./ 相应/ 地/ ,/ 本文/ 将/ 槽/ 的/ 优先级/ 设置/ 为/ ,/ 其中/ c/ 代表/ 了/ 一个/ 常数/ ./ 它/ 的/ 作用/ 是/ 将/ 访问/ 不频/ cat/ 繁/ 的/ 数据/ 从/ 槽/ 中/ 置换/ 出去/ ./ 与/ 槽/ 结构/ 相对/ 应/ ,/ 算法/ 使用/ 小顶/ 堆/ / d/ 的/ 子串/ ./ 具体/ 地/ ,/ 读入/ 起始/ 位置/ ./ 当/ ESBR/ 需要/ 读取/ 磁盘/ 的/ 数据/ 时/ ,/ 它/ 首先/ 的/ 堆/ 顶/ h/ 弹出/ ./ 其次/ ,/ 算法/ 根据/ h/ 读取/ 溢出/ 子串/ 将/ / 并/ 替换/ 优先级/ 最低/ 槽/ 中/ 的/ 数据/ ./ 根据/ 上文/ 描述/ ,/ 使用/ 小顶/ 堆/ 维护/ 数据/ 的/ 读入/ 顺序/ 具有/ 以下/ 好处/ :/ (/ 1/ )/ 实现/ 顺序/ 访问/ ./ 因为/ 素是/ 基于/ 溢出/ 子串/ 的/ 起始/ 位置/ 维护/ 的/ ,/ ESBR/ 可以/ 基于/ / 盘/ 的/ 工作/ 特性/ ,/ 避免/ 了/ 过/ 多/ 的/ 磁道/ 寻址/ ;/ (/ 2/ )/ 降低/ 磁盘/ 读写/ 次数/ ./ 给/ 定于/ 它们/ 对应/ 的/ 溢出/ 子串/ 位置/ 相对/ 接近/ ,/ 如果/ 基于/ h1/ 读出/ 的/ 子串/ 包含/ h2/ 对应/ 的/ 子串/ ,/ ESBR/ 可以/ 避免/ 针对/ h2/ 的/ 磁盘/ 访问/ ./ 图/ 8/ 演示/ 了/ ESBR/ 的/ 工作/ 过程/ ./ 假设/ 单个/ 槽/ 的/ 容量/ 为/ 1MB/ 、/ 中间/ 结果/ IMRi/ 需要/ 的/ 字符串/ 起始/ 位置/ 为/ 1500MB/ ,/ 由于/ 当前/ 的/ 槽/ 中/ 不/ 包括/ 所/ 需/ 的/ 字符串/ ,/ ESBR/ 需要/ 从/ 外存/ 中/ 读入/ T/ [/ 1500MB/ ,/ 1501MB/ ]/ ./ 然后/ ,/ ESBR/ 在/ 槽/ 中/ 寻找/ 插入/ 位置/ ./ 如图所示/ ,/ 因为/ 槽/ 3/ 的/ 优先级/ 最低/ (/ =/ 0.3/ )/ ,/ ESBR/ 将/ T/ [/ 1500MB/ ,/ 1501MB/ ]/ 替换/ 到/ 该/ 槽/ 中/ ./ 最后/ ,/ ESBR/ 更新/ 该/ 槽/ 的/ 优先级/ ./ 为了/ 便于/ 理解/ ,/ 算法/ 1/ 给出/ 了/ ESBR/ 的/ 基本/ 流程/ ./ 它用/ 最小/ 堆/ 中间/ 结果/ 是/ 在/ 执行/ ALC/ 时因/ 溢出/ 产生/ 的/ ./ 当/ |/ / |/ 大于/ 阈值/ θ/ 时/ ,/ ESBR/ 集中/ 对/ 新/ 具有/ 最/ 低优先级/ 的/ 槽/ ./ 当/ 算法/ 1/ ./ 计算/ 中间/ 结果/ ./ 输入/ :/ 存储/ 有/ 中间/ 结果/ 集合/ 的/ 最小/ 堆/ Hmin1/ ./ while/ 最小/ 堆/ Hmin/ 非空/ do2/ ./ 从/ 最小/ 堆/ Hmin/ 中弹/ 出堆/ 顶/ 元素/ IMRi/ ;/ 3/ ./ ifIMRi/ 需要/ 的/ 字符串/ 并/ 没有/ 包含/ 在/ 当前/ 的/ 槽/ 4/ ./ 执行/ 外存/ 读取/ 操作/ 读取/ IMRi/ 需要/ 的/ 字符串/ X/ ;/ 5/ ./ 更新/ 具有/ 最/ 低优先级/ 的/ 槽/ ;/ 6/ ./ endif7/ ./ 使用/ X/ 来/ 继续/ 进行/ IMRi/ 的/ 局部/ 比/ 对/ 运算/ ,/ 若有/ 8/ ./ endwhile4/ 实验/ 本/ 节/ 描述/ 了/ 局部/ 比/ 对外/ 存/ 算法/ 的/ 相关/ 实验/ ./ 本/ 实验/ 使用/ 真实/ 数据/ 集/ 作为/ 测试/ 集/ ./ 第/ 1/ 个/ 数据/ 集是/ 人类基因/ 序列/ ①/ (/ GRCh37/ )/ ./ 它/ 包含/ 24/ 条/ 染色体/ ,/ 染色体/ 长度/ 的/ 变化/ 范围/ 为/ [/ 48MB/ ,/ 249MB/ ]/ ./ 它们/ 的/ 总长度/ 为/ 2.98/ GB/ ,/ 本文/ 将/ 它/ 作为/ 原串/ ./ 本文/ 使用/ 的/ 第/ 2/ 个/ 数据/ 集是/ 老鼠/ 基因/ 数据/ ②/ (/ MGSCv37chr1/ )/ ./ 它/ 的/ 长度/ 为/ 198000000bp/ ./ 因为/ 老鼠/ 的/ 基因/ 与/ 人类基因/ 有/ 相似之处/ ,/ 所以/ 本文/ 将/ 其/ 作为/ 查询/ 串/ ./ 为了/ 测试/ 不同/ 查询/ 串/ 对/ 算法/ 的/ 影响/ ,/ 本文/ 从/ 基因/ 数据/ 中/ 随机/ 选取/ 不同/ 的/ 起始/ 位置/ s/ ,/ 并/ 以此/ 为/ 起点/ 生成/ 不同/ 长度/ |/ P/ |/ 的/ 查询/ 串/ ./ 其中/ ,/ |/ P/ |/ 的/ 长度/ 变化/ 范围/ 为/ [/ 10KB/ ,/ 2MB/ ]/ ./ 4.1/ 算法/ 的/ 总体/ 运行/ 效率/ 本/ 实验/ 测试/ 了/ 局部/ 比/ 对外/ 存/ 算法/ 的/ 总体/ 运行/ 效率/ ./ 本/ 实验/ 使用/ 约/ 2.98/ GB/ 的/ 人类基因/ 序列/ (/ GRCh37/ )/ 作为/ 原串/ T/ ,/ 并/ 在/ 其/ 基础/ 上/ 建立/ 外存/ 后/ ①/ ②/ Page11/ 缀/ 树/ ./ 查询/ 串/ 是从/ 鼠/ 基因/ 数据/ 上/ 抽取/ 得来/ 的/ ./ 本/ 实验/ 分别/ 选取/ 了/ 10KB/ ,/ 100KB/ ,/ 500KB/ ,/ 1MB/ 和/ 2MB/ 长/ 的/ 子串/ 作为/ 查询/ 串/ ./ 表/ 2/ 说明/ 了/ 实验/ 的/ 硬件/ 环境/ 和/ 软件/ 环境/ ./ 类别/ 硬件/ 环境/ 操作系统/ 编程/ 环境/ 本/ 节/ 首先/ 测试/ 了/ |/ T/ |/ 不变/ 时/ ,/ 查询/ 串/ 长度/ 对/ 算法/ 性能/ 的/ 影响/ ./ 本组/ 实验/ 分别/ 统计/ 了/ 内存/ 计算/ 时间/ Tm/ ,/ 外存/ 操作/ 时间/ Te/ 和/ 总/ 时间/ T/ +./ 由表/ 3/ 所示/ ,/ 随着/ |/ P/ |/ 的/ 增长/ ,/ Tm/ 和/ Te/ 都/ 会/ 增加/ ./ 具体/ 地/ ,/ 因为/ |/ P/ |/ 的/ 增加/ 会/ 导致/ I/ // O/ 次数/ 的/ 增加/ ,/ 所以/ Te/ 随着/ |/ P/ |/ 的/ 增加/ 而/ 增加/ ;/ 因为/ 局部/ 比/ 对/ 算法/ 的/ 时间/ 复杂度/ 与/ |/ P/ |/ 呈/ 线性关系/ ,/ 所以/ Tm/ 也/ 随着/ |/ P/ |/ 的/ 增加/ 而/ 增加/ ./ 此外/ ,/ 对于/ Tm/ 而言/ ,/ 因为/ ESLA/ 还/ 需/ 维护/ 因/ 溢出/ 而图/ 9/ 支配/ 关系/ 过滤/ 技术/ 内存/ 和/ 外存/ 的/ 影响/ 4.3/ top/ -/ 犽/ 算法/ 的/ 运行/ 效率/ 本节/ 对/ top/ -/ k/ 算法/ 的/ 整体/ 运行/ 效率/ 进行/ 了/ 测试/ ./ 其中/ ,/ 参数/ k/ 分别/ 设置/ 为/ 2000/ ,/ 4000/ ,/ 6000/ 和/ 8000/ ;/ 原串/ T/ 的/ 长度/ 分别/ 为/ 100MB/ ,/ 200MB/ 和/ 300MB/ ./ 图/ 10/ 演示/ 了/ 不同/ 的/ 参数值/ k/ 下/ ,/ 在/ 不同/ 长度/ 的/ 原串/ 上/ 寻找/ top/ -/ k/ 局部/ 比/ 对/ 的/ 运行/ 时间/ ./ 在/ 固定/ 的/ 原串/ 长度/ 下/ ,/ 算法/ 的/ 运行/ 时间/ 基本/ 和/ 查询/ 串/ 的/ 长度/ 呈/ 线性关系/ ,/ 而/ 不同/ 的/ 原串/ 长度/ 对于/ 算法/ 的/ 影响/ 较大/ ./ 容易/ 看出/ 不同/ 的/ 参数/ k/ 对/ 算法/ 的/ 运行/ 时间/ 影响/ 不/ 大/ ,/ 原因/ 是/ 根据/ 启发式/ 策略/ 得到/ 的/ 较大/ 的/ 分数/ ./ 因而/ 在/ 给定/ 不同/ 的/ 参数/ k/ 的/ 情况/ 下/ ,/ 算法/ 的/ 运算/ 代价/ 基本相同/ ,/ 运行/ 时间/ 也/ 基本/ 保持/ 不变/ ./ 根据/ 之前/ 的/ 描述/ 可知/ 维护/ 局部/ 比/ 对/ 结果/ 是/ 十分/ 重要/ 的/ ,/ 此处/ 分别/ 测试/ 了/ 在/ 原串/ T/ 的/ 长度/ 为/ 200MB/ 和/ 300MB/ 时/ 为了/ 获取/ top/ -/ 10000/ 和/ top/ -/ 20000/ 局/ 保留/ 的/ 中间/ 结果/ ,/ 所以/ Tm/ 的/ 增长速度/ 更/ 快/ 一些/ ./ 例如/ ,/ 当/ |/ P/ |/ 增加/ 到/ 2MB/ 时/ ,/ ELSA/ 需要/ 花费/ 大约/ 2700ms/ ./ 表/ 3/ 当/ 变化/ 查询/ 序列/ 长度/ 时/ 的/ 算法/ 运行/ 时间/ (/ s/ )/ 内存/ 计算/ 89.532209/ ./ 090441.453748/ ./ 4751282.568/ 外存/ 操作/ 1060.8141097/ ./ 0161171.8091248/ ./ 1551425.605/ 总和/ 1150.3461306/ ./ 1061613.2621996/ ./ 6302708.1734/ ./ 2/ 基于/ 支配/ 关系/ 的/ 过滤/ 技术/ 对/ 算法/ 的/ 影响/ 本/ 节/ 测试/ 了/ 基于/ 叉子/ 区域/ 支配/ 关系/ 的/ 过滤/ 能力/ ./ 其中/ ,/ 图/ 9/ (/ a/ )/ 和/ 图/ 9/ (/ b/ )/ 分别/ 说明/ 了/ 基于/ 支配/ 关系/ 的/ 过滤/ 算法/ 对/ 内存/ 计算/ 和/ 外存/ 操作/ 的/ 影响/ ./ 如图/ 9/ (/ a/ )/ 所示/ ,/ 与/ 不/ 使用/ 基于/ 支配/ 关系/ 的/ 过滤/ 算法/ 相比/ (/ None/ 对应/ 的/ 曲线/ )/ ,/ 基于/ 支配/ 关系/ 的/ 过滤/ 算法/ 能/ 节省/ 大约/ 15/ %/ 的/ 内存/ 计算/ 时间/ ./ 然而/ ,/ 如图/ 9/ (/ b/ )/ 所示/ ,/ 该/ 技术/ 对于/ 外存/ 操作/ 的/ 影响/ 较/ 小/ ./ 它/ 只/ 节省/ 了/ 大约/ 5/ %/ 的/ 操作/ 时间/ ./ 其/ 深入/ 原因/ 是/ 这种/ 过滤/ 算法/ 只能/ 避免/ 有限/ 的/ 外存/ 操作/ ./ 部比/ 对/ 结果/ ,/ 维护/ 计算/ 过程/ 中/ 发现/ 的/ 局部/ 比/ 对/ 结果/ 所/ 需要/ 的/ 时间/ ,/ 实验/ 结果/ 如图/ 11/ 所示/ ./ 图/ 11/ 中/ 参数/ k/ 对/ 运算/ 时间/ 影响/ 不/ 大/ ,/ 在/ 图/ 11/ (/ a/ )/ 和/ 图/ 11/ (/ b/ )/ 中/ 两者/ 的/ 时间/ 差距/ 都/ 不/ 超过/ 5s/ ,/ 造成/ 这一/ 结果/ 的/ 原因/ 在于/ 哈希/ 表/ 的/ 容量/ 较大/ ,/ 无论是/ top/ -/ 10000/ 还是/ top/ -/ 20000/ 对于/ 哈希/ 表/ 的/ 性能/ 影响/ 都/ 不大/ ./ 比较/ 图/ 11/ (/ a/ )/ 和/ 图/ 11/ (/ b/ )/ 的/ 结果/ 可以/ 发现/ ,/ 图/ 11/ (/ b/ )/ 中/ 用于/ 维护/ 局部/ 比/ 对/ 结果/ 的/ 时间/ 要/ 比图/ 11/ (/ a/ )/ 中/ 的/ 时间/ 要长/ 大约/ 10/ 余秒/ 的/ 时间/ ,/ 这是/ 由于/ 在/ 原串/ 长度/ 较长/ 时/ ,/ 新/ 计算/ 的/ 局部/ 比/ 对/ 结果/ 支配/ 已/ 计算/ 的/ 局部/ 比/ 对/ 结果/ 的/ 情况/ 出现/ 得/ 更加/ 频繁/ ,/ 因而/ 用于/ 更新/ 局部/ 比/ 对/ 结果/ 的/ 时间/ 较长/ ./ 4.4/ 外存/ 操作/ 优化/ 技术/ 的/ 影响/ 本/ 节/ 测试/ 了/ 外存/ 优化/ 策略/ 对/ 算法/ 的/ 影响/ ./ 算法/ 的/ 外存/ 操作/ 可以/ 分为/ 以下/ 两种/ :/ (/ 1/ )/ 读取/ 外存/ 后缀/ Page12/ 图/ 10top/ -/ k/ 查询/ 时间/ 图/ 11/ 维护/ 局部/ 比/ 对/ 结果/ 的/ 时间/ 树/ ./ 由于/ 后缀/ 树/ 索引/ 的/ 大小/ 是/ 固定/ 的/ ,/ 所以/ 这部分/ 的/ 时间/ 是/ 固定/ 不变/ 的/ ;/ (/ 2/ )/ 读取/ 没有/ 保存/ 在/ 内存/ 中/ 的/ 原串/ ./ 这部分/ 时间/ 主要/ 由/ 外存/ 操作/ 频率/ 决定/ ./ 由/ 前文/ 可知/ ,/ 算法/ 共/ 维护/ 两类/ 子串/ :/ (/ 1/ )/ 常驻/ 内存/ 的/ 子串/ 实验/ 首先/ 测试/ 了/ 常驻/ 子串/ 长度/ 对/ 算法/ 的/ 影响/ ./ 如图所示/ ,/ 常驻/ 内存/ 的/ 子串/ 长度/ 对/ 算法/ 性能/ 有着/ 较大/ 的/ 影响/ ./ 当/ 常驻/ 内存/ 子串/ 的/ 长度/ 为/ 2GB/ 时/ ,/ 算法/ 的/ 性能/ 明显/ 高于/ 子串/ 的/ 长度/ 为/ 1.6/ GB/ 时/ 算法/ 的/ 性能/ ./ 其/ 主要/ 原因/ 是/ 当/ 常驻/ 内存/ 的/ 子串/ 较长/ 时/ ,/ I/ // O/ 次数/ 也/ 会/ 随之/ 减少/ ./ 然而/ ,/ 当/ 内存/ 总量/ 一定/ 时/ ,/ 常驻/ 内存/ 的/ 子串/ 过长/ 时/ 也/ 会/ 降低/ 算法/ 的/ 性能/ ./ 如图/ 12/ 所示/ ,/ 当/ 常驻/ 内存/ 的/ 字符串/ 大小/ 为/ 2.4/ GB/ 图/ 12/ 常驻/ 内存/ 的/ 字符串/ 的/ 大小/ 对/ 算法/ 运行/ 时间/ 的/ 影响/ 时/ ,/ 算法/ 的/ 总体/ 性能/ 低于/ |/ / c/ |/ =/ 2GB/ 时/ 的/ 情形/ ./ 造成/ 这一/ 结果/ 的/ 原因/ 为/ :/ 虽然/ 串/ 在/ 内存/ 中/ ,/ 但是/ 由于/ Page13/ 子串/ 较/ 少/ ,/ 磁盘/ 寻址/ 次数/ 也/ 会/ 增多/ ./ 因此/ ,/ 当大时/ 反而/ 会/ 影响/ 算法/ 的/ 性能/ ./ 总之/ ,/ 对/ 算法/ 的/ 性能/ 有着/ 较大/ 的/ 影响/ ./ 由于/ 原串/ 和/ 查询/ 串中/ 字符/ 的/ 分布/ 都/ 是/ 未知/ 的/ ,/ 本文/ 无法/ 给出/ 一个/ 理论/ 上/ 的/ 拐点/ ./ 相反/ ,/ 本文/ 可/ 从/ 大量/ 实验/ 出发/ 找到/ 相对/ 最优/ 的/ |/ / c/ |/ ./ 最后/ ,/ 本/ 节/ 测试/ 了/ 外存/ 交换/ 策略/ 对/ 算法/ 的/ 影响/ ./ 其中/ ,/ 本文/ 对比/ 了/ 以下/ 3/ 种/ 置换/ 策略/ ./ 它们/ 分别/ 是/ :/ (/ 1/ )/ MU/ 算法/ (/ 优先/ 置换/ 使用/ 次数/ 最多/ 的/ 字符串/ )/ ;/ (/ 2/ )/ LU/ 算法/ (/ 优先/ 置换/ 使用/ 次数/ 最少/ 的/ 字符串/ )/ ;/ (/ 3/ )/ FIFO/ 算法/ (/ 先进先出/ 的/ 置换/ 策略/ )/ ./ 如图/ 13/ 所示/ ,/ 3/ 种/ 置换/ 策略/ 对应/ 的/ 曲线/ 十分/ 接近/ ,/ 其中/ MU/ 策略/ 要/ 略微/ 占优/ ,/ 这/ 从/ 侧面/ 反映/ 出/ 字符串/ 被/ 再次/ 使用/ 的/ 概率/ 较/ 低/ 的/ 结论/ 是/ 正确/ 的/ ./ 5/ 总结/ 与/ 展望/ 本文/ 对/ top/ -/ k/ 局部/ 比/ 对/ 问题/ 进行/ 了/ 研究/ ./ 和/ 以往/ 文献/ 相比/ ,/ 本文/ 研究/ 的/ 问题/ 更为/ 复杂/ ./ 首先/ ,/ 它/ 需要/ 考虑/ “/ 小/ 阈值/ ”/ 带来/ 的/ 问题/ ./ 其次/ ,/ 它/ 需要/ 突破/ 磁盘/ I/ // O/ 引发/ 的/ 瓶颈/ ./ 为了/ 解决/ 上述/ 问题/ ,/ 本文/ 首先/ 将/ 一些/ 成熟/ 的/ 过滤/ 策略/ 与/ 本文/ 的/ 研究/ 环境/ 有机/ 结合/ ./ 其次/ ,/ 本文/ 引入/ 一种/ 启发式/ 算法/ 解决/ “/ 小/ 阈值/ ”/ 问题/ ./ 最后/ ,/ 本文/ 根据/ 磁盘/ 和/ 后缀/ 树/ 的/ 工作/ 特性/ 提出/ 了/ 一系列/ 外存/ 优化/ 策略/ ./ 通过/ 大量/ 的/ 实验/ 验证/ 了/ 本文/ 所/ 提出/ 算法/ 的/ 有效性/ ./ 然而/ ,/ 虽然/ 本文/ 提出/ 的/ 算法/ 具有/ 较/ 高/ 的/ 运行/ 效率/ ,/ 但是/ 还有/ 一些/ 不足/ 需要/ 解决/ :/ (/ 1/ )/ 寻找/ top/ -/ k/ 局部/ 比/ 对/ 问题/ 的/ 算法/ 没有/ 充分利用/ 高/ 分数/ 阈值/ ,/ 未来/ 需要/ 研究/ 如何/ 利用/ 高/ 分数/ 阈值/ 来/ 过滤/ 不必要/ 的/ 计算/ ,/ 进一步/ 提升/ 算法/ 的/ 运行/ 效率/ ./ (/ 2/ )/ 使用/ 外存/ 后缀/ 树来/ 解决/ 局部/ 比/ 对/ 问题/ 对于/ 硬盘空间/ 的/ 要求/ 太/ 大/ ,/ 在/ 硬盘/ 上/ 读入/ 后缀/ 树/ 需要/ 花费/ 大量/ 的/ 时间/ ,/ 将来/ 将/ 研究/ 是否/ 有/ 其他/ 占据/ 空间/ 小/ 并且/ 兼顾/ 运行/ 效率/ 的/ 索引/ 结构/ 来/ 代替/ 后缀/ 树/ 的/ 使用/ ./ 

