Page1/ 并发/ 缺陷/ 暴露/ 、/ 检测/ 与/ 规避/ 研究/ 综述/ 苏小红禹振王/ 甜甜/ 马培军/ (/ 哈尔滨工业大学/ 计算机科学/ 与/ 技术/ 学院/ 哈尔滨/ 150001/ )/ 摘要/ 当今/ 普遍/ 流行/ 的/ 多/ 核/ 架构/ 使得/ 硬/ 并发/ 成为/ 现实/ ./ 为了/ 从/ 硬件/ 的/ 并发/ 能力/ 获益/ ,/ 并发程序/ 设计/ 正/ 越来越/ 流行/ ./ 然而/ 由于/ 内在/ 的/ 并发/ 性/ 和/ 不确定性/ ,/ 并发程序/ 易于/ 遭遇/ 并发/ 缺陷/ ,/ 并且/ 它们/ 难以/ 检测/ 、/ 调试/ 和/ 修复/ ./ 文中/ 指出/ 软件开发/ 正/ 从/ 顺序/ 模式/ 转向/ 并发/ 模式/ 的/ 趋势/ ,/ 揭示/ 并发程序/ 和/ 并发/ 缺陷/ 各自/ 的/ 三大/ 特点/ ,/ 剖析/ 并发/ 缺陷/ 面临/ 的/ 三大/ 挑战/ ,/ 然后/ 将/ 并发/ 缺陷/ 分为/ 死锁/ 、/ 数据/ 竞争/ 、/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ 4/ 类/ ,/ 并/ 讨论/ 4/ 类/ 并发/ 缺陷/ 的/ 相互/ 关系/ ,/ 接着/ 就/ 如何/ 尽快/ 暴露/ 、/ 及时/ 检测/ 和/ 高效/ 规避/ 各类/ 并发/ 缺陷/ 对/ 已有/ 研究/ 作出/ 分析/ 、/ 比较/ 和/ 归纳/ ,/ 最后/ 从/ 智能/ 快速/ 的/ 缺陷/ 暴露/ 、/ 通用/ 准确/ 的/ 缺陷/ 检测/ 、/ 确定性/ 重/ 放/ 支持/ 、/ 软硬件/ 协同/ 设计/ 和/ 新/ 的/ 并发/ 编程/ 模型/ 等/ 5/ 个/ 方面/ 展望/ 了/ 未来/ 的/ 研究/ 重点/ ./ 关键词/ 并发/ 缺陷/ ;/ 死锁/ ;/ 数据/ 竞争/ ;/ 原子/ 性/ 违背/ ;/ 顺序/ 违背/ ;/ 程序/ 分析/ ;/ 软件测试/ 1/ 引言/ 过去/ 的/ 几十年/ 间/ ,/ 软件/ 一直/ 从/ 处理器/ (/ CPU/ )/ 性能/ Page2/ 度/ 十倍/ 于/ 前/ )/ ./ 大多数/ 情况/ 下/ ,/ 软件/ 受益/ 于/ CPU/ 和/ 内存/ 、/ 硬盘/ 等/ 外围设备/ 的/ 持续/ 不断/ 升级/ ,/ 其不作/ 任何/ 改变/ 就/ 能/ 免费/ 获得/ 性能/ 提升/ ./ 但是/ 这种/ 免费/ 午餐/ 已经/ 结束/ ./ 由于/ 受制于/ 一些/ 物理学/ 问题/ ,/ 如/ 功耗/ 、/ 发热/ 及/ 电子/ 泄露/ ,/ CPU/ 时钟/ 频率/ 的/ 提升/ 越来越/ 难/ ,/ 几乎/ 已达/ 极限/ ./ 图/ 1/ 反映/ 了/ Intel/ 处理器/ 的/ 时钟/ 频率/ 与/ 晶体管/ 规模/ 关系/ 的/ 演化/ 历史/ ./ 大约/ 在/ 2003/ 年/ 左右/ ,/ 一直/ 快速/ 攀升/ 的/ 时钟/ 频率/ 突然/ 陷入/ 了/ 停滞/ ./ 即使/ 大幅/ 增加/ 晶体管/ 数量/ ,/ 也/ 无济于事/ :/ 时钟/ 频率/ 仍旧/ 不能/ 提升/ ,/ 甚至/ 会/ 有所/ 下降/ ./ 最终/ Intel/ 的/ 单核/ CPU/ 时钟/ 频率/ 止步/ 于/ 3.8/ GHz/ ./ 因此/ 软件/ 在/ 保持/ 单/ 执行/ 流/ 的/ 体系结构/ 下/ ,/ 将/ 再也不能/ 从/ CPU/ 性能/ 提升/ 中/ 获益/ ./ Intel/ 于/ 2006/ 年/ 6/ 月/ 发布/ 革命性/ 的/ “/ 酷睿/ ”/ 双核/ // 多核/ 架构/ 处理器/ [/ 1/ ]/ ,/ 从此/ 个人电脑/ 领域/ 进入/ 硬/ 并发/ 时代/ ./ 在/ 当今/ 多核/ 时代/ ,/ 为/ 提高/ 运行/ 速度/ ,/ 软件/ 必须/ 转向/ 并发/ 模式/ ./ 然而/ 相对/ 于/ 传统/ 的/ 结构化程序/ 设计/ 而言/ ,/ 并发程序/ 设计/ 更加/ 困难/ 且/ 容易/ 出错/ ./ 1.1/ 并发程序/ 的/ 特点/ 由于/ 内在/ 的/ 并发/ 性/ ,/ 并发程序/ 的/ 执行/ 具有/ 不确定性/ 且/ 执行/ 交错/ 空间/ 庞大/ ./ 与/ 顺序程序/ 相比/ ,/ 并发程序/ 的/ 特点/ 主要/ 体现/ 在/ 以下/ 几个/ 方面/ :/ (/ 1/ )/ 执行/ 交错/ 空间/ 庞大/ ./ 并发程序/ 的/ 复杂度/ 随/ 并发/ 执行/ 流/ 数目/ 及其/ 长度/ 增长/ 而/ 指数/ 级/ 增长/ [/ 3/ ]/ ./ 例如/ 一个/ 具有/ 5/ 个/ 线程/ 、/ 每个/ 线程/ 执行/ 5/ 个/ 动作/ 的/ 并发程序/ ,/ 其/ 所有/ 可能/ 执行/ 路径/ 数为/ 25/ !/ // (/ 5/ !/ )/ 5/ (/ 大于/ 100/ 亿/ )/ ./ (/ 2/ )/ 开发/ 需要/ 并发/ 的/ 思维/ 模式/ ./ 并发程序/ 要求/ 程序员/ 按照/ 并发/ // 并行/ 的/ 思维/ 模式/ 思考/ 和/ 处理/ 问题/ ,/ 而/ 人类/ 习惯/ 和/ 擅长于/ 串行/ 的/ 思维/ 模式/ ./ 对于/ 若干/ 有序/ 操作/ 序列/ 的/ 简单/ 排列组合/ ,/ 即使/ 最/ 聪明/ 和/ 最/ 有/ 经验/ 的/ 程序员/ 也/ 可能/ 遗漏掉/ 某些/ 执行/ 交错/ ./ (/ 3/ )/ 运行/ 不确定性/ ./ 并发程序/ 内在/ 的/ 并发/ 性/ 造成/ 其/ 运行/ 具有/ 不确定性/ ./ 并发程序/ 中/ 的/ 数个/ 独立/ 执行/ 流/ 受到/ 调度/ 器/ 的/ 随机/ 调度/ ,/ 即使/ 给定/ 同一/ 输入/ ,/ 其/ 前后/ 两次/ 运行/ 的/ 执行/ 交错/ 和/ 执行/ 结果/ 可能/ 完全/ 不同/ ./ 1.2/ 并发/ 缺陷/ 的/ 特点/ 由于/ 并发/ 思维/ 模式/ 与/ 人类/ 思维习惯/ 相悖/ ,/ 并发/ 缺陷/ 常常/ 被/ 程序员/ 无意识/ 地/ 引入/ 到/ 并发程序/ 中/ ./ 相对/ 于/ 传统/ 的/ 程序/ 缺陷/ ,/ 并发/ 缺陷/ 具有/ 以下/ 特点/ :/ (/ 1/ )/ 难以/ 检测/ ./ 并发/ 缺陷/ 仅/ 在/ 罕见/ 的/ 、/ 特定/ 的/ 执行/ 交错/ 下才/ 暴露/ 出来/ ,/ 而/ 并发程序/ 执行/ 交错/ 空间/ 庞大/ ,/ 传统/ 的/ 压力/ 测试/ 即使/ 运行/ 数天/ 甚至/ 数月/ 也/ 不能/ 触发/ 某些/ 并发/ 缺陷/ [/ 3/ -/ 6/ ]/ ,/ 更/ 无法/ 检测/ 到/ 它们/ ./ (/ 2/ )/ 难以/ 调试/ ./ 并发/ 缺陷/ 从/ 产生/ 到/ 暴露/ 需要/ 一定/ 的/ 传播/ 过程/ ,/ 具有/ 延时/ 性/ [/ 7/ ]/ ./ 另外/ 并发程序/ 的/ 运行/ 不确定性/ 使得/ 传统/ 的/ 通过/ 迭代/ 运行/ 以/ 定位/ 缺陷/ 原因/ 的/ 调试/ 方式/ 不再/ 适用/ ,/ 加剧/ 了/ 并发/ 缺陷/ 的/ 调试/ 难度/ ./ (/ 3/ )/ 难以/ 修复/ ./ 并发/ 缺陷/ 即使/ 被/ 检测/ 到/ ,/ 也/ 难以/ 修复/ [/ 8/ -/ 9/ ]/ :/ 补丁/ 代码/ 往往/ 不是/ 修复/ 了/ 缺陷/ ,/ 而/ 只是/ 降低/ 了/ 其/ 发生/ 的/ 概率/ ;/ 并且/ 补丁/ 代码/ 常常/ 会/ 导致/ 新/ 的/ 并发/ 缺陷/ ./ 在/ 传统/ 的/ 测试方法/ 下/ ,/ 许多/ 并发/ 缺陷/ 没有/ 被/ 检测/ 出来/ ,/ 而/ 继续/ 潜伏/ 在/ 软件/ 中/ ,/ 直至/ 在/ 生产性/ 运行/ 中/ 暴露/ 出来/ ,/ 造成/ 重大事故/ 和/ 财产损失/ ./ 例如/ 由于/ 数据/ 竞争/ 缺陷/ ,/ 纳斯达克/ OMX/ 系统/ 发生/ 故障/ ,/ 延迟/ 为/ 脸谱/ 公司/ IPO/ 提供/ 服务/ 达/ 30/ 分钟/ ,/ 造成/ 1300/ 万美元/ 损失/ ①/ ./ 1.3/ 关键技术/ 挑战/ 并发程序/ 执行/ 交错/ 空间/ 庞大/ 且/ 运行/ 具有/ 不确定性/ ,/ 而/ 并发/ 缺陷/ 又/ 仅/ 在/ 罕见/ 的/ 执行/ 交错/ 下才/ 发生/ ,/ 传统/ 以/ 测试用例/ 生/ 成为/ 中心/ 的/ 测试/ 技术/ 不能/ 有效/ 暴露/ 和/ 检测/ 并发/ 缺陷/ ,/ 更/ 不能/ 规避/ 并发/ 缺陷/ ./ 并发/ 缺陷/ 的/ 动态/ 测试/ 和/ 静态/ 分析/ 主要/ 面临/ 三大/ 挑战/ :/ (/ 1/ )/ 尽快/ 暴露/ ./ 并发程序/ 的/ 执行/ 交错/ 空间/ 庞大/ ,/ 而/ 其中/ 只有/ 极少数/ 的/ 执行/ 交错/ 能够/ 触发/ 并发/ 缺陷/ ./ 传统/ 测试/ 技术/ 即使/ 能够/ 生成/ 触发/ 并发/ 缺陷/ 的/ 测试用例/ ,/ 也/ 不能/ 保证/ 并发/ 缺陷/ 在/ 测试用例/ 的/ 每次/ 执行/ 中/ 都/ 暴露/ ./ 因此/ 在/ 并发程序/ 运行/ 能够/ 触发/ 并发/ 缺陷/ 的/ 测试用例/ 时/ ,/ 并发/ 缺陷/ 测试/ 技术/ 应/ 设法/ 控制/ 或者/ 影响/ 并发程序/ 的/ 执行/ ,/ 以/ 测试/ 尽可能/ 多/ 的/ 执行/ 交错/ 或/ 尽快/ 测试/ 那些/ 包含/ 并发/ 缺陷/ 的/ 执行/ 交错/ ./ (/ 2/ )/ 准确/ 、/ 及时/ 检测/ ./ 对/ 并发/ 缺陷/ 检测/ 报告/ 进行/ ①/ Nasdaq/ ’/ sFacebookglitchcamefromraceconditions/ ./ http/ :/ // // Page3/ 确认/ 通常/ 费时费力/ ,/ 并/ 需要/ 丰富/ 的/ 并发/ 调试/ 经验/ ,/ 因此/ 检测/ 方法/ 应当/ 只/ 报告/ 真正/ 的/ 并发/ 缺陷/ ./ 在/ 保证/ 误报率/ 为/ 零/ 的/ 情况/ 下/ ,/ 检测/ 方法/ 可以/ 有/ 一定/ 的/ 漏报/ 率/ ,/ 因为/ 并发/ 缺陷/ 的/ 发生/ 概率/ 极低/ ./ 实际/ 中/ ,/ 对/ 并发/ 缺陷/ 的/ 检测/ 以/ 动态/ 检测/ 为主/ ./ 动态/ 检测/ 时/ ,/ 由于/ 并发/ 缺陷/ 从/ 产生/ 到/ 暴露/ 可能/ 经历/ 成百上千/ 条/ 指令/ 和/ 多次/ 上下文/ 切换/ ,/ 检测/ 方法/ 应/ 能/ 及时/ 监测/ 到/ 并发/ 缺陷/ 的/ 产生/ 并/ 检测/ 出其/ 构成/ 要素/ ./ (/ 3/ )/ 高效/ 规避/ ./ 并发/ 缺陷/ 难以/ 修复/ 而/ 又/ 仅/ 在/ 罕见/ 的/ 执行/ 交错/ 下才/ 暴露/ 出来/ ,/ 但/ 只要/ 合理/ 调度/ 程序执行/ ,/ 使/ 其/ 避开/ 那些/ 包含/ 并发/ 缺陷/ 的/ 执行/ 交错/ ,/ 则/ 即使/ 程序/ 中/ 存在/ 并发/ 缺陷/ ,/ 也/ 不会/ 对/ 程序/ 的/ 正确性/ 造成/ 影响/ ./ 对/ 并发/ 缺陷/ 的/ 规避/ 方法/ 有/ 两种/ :/ 静态/ 源码/ 分析/ 和/ 动态/ 执行/ 控制/ ./ 静态/ 规避/ 方法/ 容易/ 添加/ 过多/ 的/ 同步/ 设施/ ,/ 可能/ 降低/ 并发/ 执行/ 的/ 并发/ 度/ ;/ 动态/ 规避/ 方法/ 全程/ 监视/ 并/ 控制/ 并发程序/ 的/ 执行/ ,/ 可能/ 降低/ 并发/ 执行/ 的/ 执行/ 效率/ ./ 近年来/ ,/ 众多/ 学者/ 在/ 构建/ 并发程序/ 软件/ 支撑/ 环境/ (/ 如/ 并发/ 库/ 、/ 支持/ 并发/ 的/ 程序设计/ 语言/ 等/ )/ 、/ 并发/ 缺陷/ 暴露/ 、/ 检测/ 与/ 调试/ 工具/ 、/ 并发/ 缺陷/ 预防/ 、/ 规避/ 与/ 重演/ 等/ 方面/ 做/ 了/ 大量/ 工作/ ./ 在/ 参阅/ 以往/ 研究/ 工作/ 的/ 基础/ 上/ ,/ 本文/ 第/ 2/ 节将/ 并发/ 缺陷/ 分成/ 4/ 类/ ,/ 并/ 逐类/ 给出/ 定义/ 和/ 示例/ ;/ 第/ 3/ 节/ 总结/ 和/ 评价/ 各类/ 并发/ 缺陷/ 的/ 暴露/ 技术/ ;/ 第/ 4/ 、/ 5/ 、/ 6/ 节/ 分别/ 就/ 如何/ 及时/ 检测/ 和/ 在线/ 规避/ 死锁/ 、/ 数据/ 竞争/ 和/ 原子/ 性/ 违背/ ,/ 对/ 已有/ 研究/ 作出/ 分析/ 、/ 比较/ 和/ 归纳/ ./ 由于/ 顺序/ 违背/ 这种/ 缺陷/ 模式/ 被/ 提出/ 图/ 2SQLite/ -/ 3.3/ ./ 3/ 中/ 的/ 死锁/ 缺陷/ Bug/ #/ 1672/ 在/ C/ // C++/ 和/ Java/ 中/ ,/ 死锁/ 一般/ 由/ 同步/ 设施/ 如/ 互斥/ 锁/ 、/ 读写/ 锁/ 、/ 条件/ 变量/ 和/ 信号量/ 造成/ [/ 10/ ]/ ./ 互斥/ 锁/ 和/ 读写/ 锁常/ 导致/ 有环/ 死锁/ ,/ 而/ 条件/ 变量/ 和/ 信号量/ 则/ 能够/ 导致/ 无环/ 死锁/ [/ 11/ ]/ ./ 消除/ 有环/ 死锁/ 的/ 措施/ 是/ 定义/ 全局/ 的/ 锁/ 占用/ 顺序/ 并/ 使/ 所有/ 线程/ 都/ 按照/ 该/ 顺序/ 来/ 请求/ 锁/ ;/ 消除/ 无环/ 死锁/ 的/ 必要措施/ 是/ 保证/ 对/ 条件/ 变量/ 和/ 信号量/ 发出/ 的/ 信号/ 没有/ 丢失/ ./ 2.2/ 数据/ 竞争/ 定义/ 2/ ./ 数据/ 竞争/ ./ 对/ 某/ 一/ 共享内存/ 单元/ ,/ 存在/ 和/ 认可/ 的/ 时间/ 较/ 短/ ,/ 只有/ 少量/ 研究/ ,/ 故/ 不/ 单列/ 一节/ 讨论/ 它/ ,/ 只/ 在/ 讨论/ 其他/ 种类/ 并发/ 缺陷/ 的/ 检测/ 和/ 规避/ 技术/ 时/ 捎带/ 提及/ ;/ 第/ 7/ 节/ 从/ 5/ 个/ 方面/ 展望未来/ 的/ 研究/ 重点/ ;/ 第/ 8/ 节/ 总结/ 全文/ ./ 2/ 并发/ 缺陷/ 分类/ 及其/ 相互之间/ 的/ 关系/ 本文/ 考虑/ 共享内存/ 并发/ 系统/ 中/ 的/ 常见/ 并发/ 缺陷/ ,/ 先/ 将/ 其/ 分为/ 死锁/ 、/ 数据/ 竞争/ 、/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ 四大/ 类/ (/ 本文/ 不/ 讨论/ 活锁/ )/ ,/ 然后/ 讨论/ 它们/ 之间/ 的/ 相互/ 关系/ ./ 当然/ 并发/ 缺陷/ 包括/ 但/ 不/ 限于/ 这/ 4/ 种/ 模式/ ,/ 新/ 的/ 缺陷/ 模式/ 总是/ 随着/ 人们/ 对/ 并发/ 缺陷/ 的/ 深入/ 认识/ 而/ 被/ 提取/ 出来/ ./ 例如/ ,/ Lu/ 等/ 人/ [/ 8/ ]/ 在/ 2008/ 年/ 提出/ 的/ 顺序/ 违背/ 这种/ 新/ 的/ 并发/ 缺陷/ 模式/ ,/ 并且/ 被/ 广泛/ 认可/ ./ 2.1/ 死锁/ 定义/ 1/ ./ 死锁/ ./ 某/ 线程/ 集合/ 中/ 的/ 每/ 一个/ 线程/ 都/ 在/ 等待/ 另/ 一个/ 线程/ 占有/ 的/ 互斥性/ 资源/ ,/ 由此/ 造成/ 的/ 循环/ 等待/ 即/ 为/ 死锁/ ./ 图/ 2/ 中/ 的/ 代码/ 片段/ 展示/ 了/ 开源/ 数据库/ SQLite/ -/ 3.3/ ./ 3/ 中/ 的/ 一个/ 死锁/ 缺陷/ ①/ ./ 假设/ 线程/ T1/ 先/ 执行/ 并/ 在/ L1/ 处/ 获得/ 锁/ mutex1/ ,/ 然后/ 调度/ 器/ 暂停/ T1/ 并/ 调度/ 线程/ T2/ 执行/ ./ T2/ 被/ 调度/ 执行/ 前/ 已/ 获得/ 锁/ mutex2/ ,/ 它/ 在/ L3/ 处/ 请求/ 锁/ mutex1/ 时/ 将/ 被/ 阻塞/ ,/ 因为/ mutex1/ 正/ 被/ T1/ 占据/ ./ 当/ T1/ 执行/ 时/ ,/ 它/ 将/ 在/ L2/ 处/ 请求/ 锁/ mutex2/ 时/ 被/ 阻塞/ ,/ 因为/ mutex2/ 正/ 被/ T2/ 占据/ ./ 这/ 就/ 构成/ 了/ 死锁/ ./ 来自/ 不同/ 线程/ 的/ 两个/ 并发/ 访问/ ,/ 且/ 至少/ 一个/ 为/ 写访问/ ./ 定义/ 2/ 中/ 的/ 并发/ 意指/ 这/ 两个/ 访问/ 之间/ 没有/ happens/ -/ before/ 关系/ [/ 5/ ,/ 12/ ]/ ,/ 存在/ “/ 同时/ ”/ 发生/ 的/ 可能/ ./ 消除/ 数据/ 竞争/ 的/ 措施/ 有/ 两种/ :/ 为/ 共享内存/ 单元/ 加上/ 一致性/ 锁/ 保护/ ,/ 或者/ 利用/ 条件/ 变量/ 等/ 同步/ 设施/ 使/ 两个/ 访问/ 之间/ 形成/ 一个/ 固定/ 的/ 执行/ 次序/ ./ 两种/ 措施/ 的/ 区别/ 是/ ,/ 构成/ 数据/ 竞争/ 的/ 两个/ 访问/ 在/ 前者/ 中/ 可以/ 两/ ①/ SQLitebug/ #/ 1672/ ./ http/ :/ // // www/ ./ sqlite/ ./ org/ // src/ // info/ // a6c30be/ -/ Page4/ 种/ 次序/ 执行/ ,/ 而/ 在/ 后者/ 中/ 只能/ 以/ 一种/ 次序/ 执行/ ./ 图/ 3/ 中/ 的/ 线程/ T1/ 和/ T2/ 可能/ 同时/ 分别/ 执行/ L1/ 和/ L2/ ,/ 受/ 调度/ 器/ 调度/ 的/ 影响/ ,/ 共享/ 变量/ shared/ [/ 0/ ]/ 值/ 要么/ 增加/ 2/ 要么/ 增加/ 1/ ./ 比如/ 当/ 线程/ T1/ 先/ 读取/ shared/ [/ 0/ ]/ 的/ 值/ ,/ 执行/ L1/ ,/ 然后/ T2/ 读取/ shared/ [/ 0/ ]/ 的/ 值/ ,/ 执行/ L2/ 时/ ,/ shared/ [/ 0/ ]/ 值/ 正确/ 地自增/ 2/ ;/ 而/ 如果/ 线程/ T1/ 和/ T2/ 先/ 读取/ shared/ [/ 0/ ]/ 的/ 值/ ,/ 然后/ 分别/ 执行/ L1/ 和/ L2/ ,/ 则/ shared/ [/ 0/ ]/ 值/ 错误/ 地自增/ 1/ ,/ T1/ 或者/ T2/ 对/ shared/ [/ 0/ ]/ 的/ 一个/ 更新/ 丢失/ ./ 然而/ 由于/ 没有/ 同步/ 机制/ 保护/ ,/ 这/ 两种/ 情况/ 在/ 一次/ 运行/ 中/ 都/ 有/ 可能/ 发生/ ,/ 相互之间/ 构成/ “/ 竞争/ ”/ 关系/ ./ 数据/ 竞争/ 常/ 被/ 分为/ 3/ 类/ [/ 13/ -/ 14/ ]/ :/ 貌然/ 数据/ 竞争/ (/ apparentdataraces/ )/ 、/ 可行/ 数据/ 竞争/ (/ feasibledataraces/ )/ 和/ 实际/ 数据/ 竞争/ (/ actualdataraces/ )/ ./ 貌然/ 数据/ 竞争/ 指在/ 不/ 考虑/ 同步/ 设施/ 的/ 语义/ 的/ 情况/ 下/ ,/ 被/ 检测/ 出来/ 的/ 数据/ 竞争/ ./ 可行/ 数据/ 竞争/ 指在/ 考虑/ 同步/ 设施/ 的/ 语义/ 的/ 情况/ 下/ ,/ 有/ 可能/ 被/ 检测/ 出来/ 的/ 数据/ 竞争/ ./ 实际/ 数据/ 竞争/ 指在/ 某次/ 实际/ 运行/ 中/ 被/ 检测/ 出来/ 的/ 数据/ 竞争/ ./ 图/ 4/ 中/ ,/ 存在/ 两个/ 貌然/ 数据/ 竞争/ 和/ 一个/ 可行/ 数据/ 竞争/ ./ 两个/ 貌然/ 数据/ 竞争/ ,/ 一个/ 在/ result/ 上/ ,/ 一个/ 在/ done/ 上/ ./ 然而/ 在/ 考虑/ 程序/ 语义/ 后/ ,/ 发现/ done/ 被/ 用作/ 同步/ 设施/ :/ T2/ 只有/ 当/ done/ 为/ TRUE/ 时才/ 访问/ result/ ./ 图/ 6/ 可/ 序列化/ 与非/ 可/ 序列化/ 的/ 执行/ 交错/ [/ 6/ ,/ 16/ -/ 18/ ]/ 因此/ result/ 上/ 的/ 数据/ 竞争/ 不/ 可能/ 发生/ ,/ 只有/ done/ 上/ 的/ 数据/ 竞争/ 是/ 可行/ 的/ ,/ 即可/ 行/ 数据/ 竞争/ 其才/ 可/ 发生/ ./ 2.3/ 原子/ 性/ 违背/ 定义/ 3/ ./ 原子/ 性/ 违背/ ./ 对/ 某/ 一为/ 保证/ 正确性/ 必须/ 原子/ 性/ 执行/ 的/ 指令/ 序列/ ,/ 存在/ 一个/ 执行/ 交错/ ,/ 其/ 执行/ 效果/ 不/ 与/ 任何/ 该/ 指令/ 序列/ 原子/ 性/ 执行/ 时/ 的/ 执行/ 交错/ 的/ 执行/ 效果/ 相同/ ./ 图/ 5/ 展示/ 了/ 开源/ Web/ 服务器/ ApacheHttpd/ 中/ 的/ 一个/ 原子/ 性/ 违背/ 缺陷/ ./ 线程/ T1/ 中/ ,/ L1/ 首先/ 检查/ 缓冲区/ buf/ 是否/ 有/ 足够/ 容量/ ,/ 如果/ 是/ 的话/ ,/ L2/ 从/ log/ 向/ buf/ 中/ 拷贝/ len/ 个/ 字节/ 数据/ ./ 程序员/ 假设/ L1/ 和/ L2/ 应/ 原子/ 性/ 执行/ ,/ 但/ 没有/ 使用/ 同步/ 设施/ 加以/ 实施/ ./ T1/ 在/ 执行/ L1/ 和/ L2/ 的/ 中间/ ,/ 可能/ 被/ 来自/ T2/ 的/ L3/ 打断/ ,/ 造成/ 缓冲区/ 溢出/ ./ 消除/ 原子/ 性/ 违背/ 的/ 措施/ 一般/ 是/ 为/ 相互之间/ 应/ 原子/ 性/ 执行/ 的/ 区域/ 加上/ 共同/ 的/ 锁/ 保护/ ./ 图/ 5ApacheHttpd/ 中/ 的/ 原子/ 性/ 违背/ 缺陷/ [/ 6/ ,/ 15/ ]/ 原子/ 性/ 违背/ 分为/ 单/ 变量/ 原子/ 性/ 违背/ 和/ 多/ 变量/ 原子/ 性/ 违背/ 两类/ ./ 对于/ 单个/ 共享/ 变量/ ,/ 如图/ 6/ 中/ 的/ x/ ,/ 3/ 个/ 读写/ 该/ 共享/ 变量/ 的/ 访问/ (/ 两个/ 来自/ 同一/ 线程/ ,/ 第/ Page53/ 个/ 来自/ 另/ 一线/ 程/ )/ 共有/ 8/ 种/ 执行/ 交错/ (/ (/ a/ )/ ~/ (/ h/ )/ )/ ,/ 其中/ 4/ 种/ (/ (/ a/ )/ ~/ (/ d/ )/ )/ 存在/ 等价/ 的/ 原子/ 执行/ 交错/ ,/ 分别/ 为/ (/ i/ )/ ~/ (/ l/ )/ ,/ 另外/ 4/ 种/ (/ (/ e/ )/ ~/ (/ h/ )/ )/ 是/ 不可/ 序列化/ 的/ ./ 例如/ ,/ 如果/ 两个/ 本地/ 读/ 操作/ 被/ 一个/ 远程/ 写/ 操作/ 交错/ (/ 图/ 6/ (/ e/ )/ )/ ,/ 则/ 两个/ 本地/ 读/ 操作/ 将/ 读取/ 到/ 不同/ 的/ 值/ ,/ 这是/ 一个/ 不可/ 序列化/ 的/ 执行/ 交错/ ./ 图/ 5/ 给出/ 了/ 该类/ 原子/ 性/ 违背/ 的/ 一个/ 例子/ ./ 2.4/ 顺序/ 违背/ 定义/ 4/ ./ 顺序/ 违背/ ./ 某一/ 指令/ (/ 组/ )/ 没有/ 按照/ 预期/ ,/ 总是/ 在/ 另/ 一/ 指令/ (/ 组/ )/ 之前/ 或者/ 之后/ 执行/ ./ 图/ 7/ 展示/ 了/ 开源/ Web/ 浏览器/ Mozilla/ 中/ 的/ 一个/ 顺序/ 违背/ 缺陷/ ./ 线程/ T1/ 调用/ PR/ _/ CreateThread/ (/ )/ 创建/ 一个/ 以/ mMain/ 为/ 入口/ 函数/ 的/ 子/ 线程/ ,/ 并/ 将/ 该/ 线程/ 的/ 句柄/ 存储/ 在/ mThread/ 中/ ./ 然而/ 由于/ PR/ _/ Create/ -/ Thread/ (/ )/ 不是/ 原子/ 性/ 地/ 执行/ ,/ 线程/ T2/ 可能/ 在/ PR/ _/ CreateThread/ (/ )/ 还/ 没/ 返回/ 时/ 就/ 对/ mThread/ 解/ 引用/ ,/ 从而/ 造成/ 空/ 指针/ 解/ 引用/ 或者/ 读取/ 错误/ 的/ 值/ ./ 此例/ 中/ ,/ 程序员/ 的/ 意图/ 是/ T2/ 对/ mThread/ 的/ 解/ 引用/ 应/ 发生/ 在/ T1/ 对/ PR/ _/ CreateThread/ (/ )/ 的/ 调用/ 返回/ 之后/ ,/ 但此/ 意图/ 并/ 没有/ 得到/ 实施/ 和/ 保证/ ./ 消除/ 顺序/ 违背/ 的/ 措施/ 一般/ 是/ 使用/ 条件/ 变量/ 在/ 指令/ (/ 组/ )/ 之间/ 形成/ 固定/ 的/ 执行/ 次序/ ./ 2.54/ 类/ 并发/ 缺陷/ 的/ 相互/ 关系/ 通过/ 深入分析/ ,/ 我们/ 发现/ 4/ 类/ 并发/ 缺陷/ 的/ 关系/ 如图/ 8/ 所示/ ./ 从图/ 8/ 可/ 看出/ :/ (/ 1/ )/ 并发/ 缺陷/ 包括/ 但/ 并/ 不/ 限于/ 死锁/ 、/ 数据/ 竞争/ 、/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ 这/ 4/ 种/ 缺陷/ 模式/ ;/ (/ 2/ )/ 死锁/ 与/ 其他/ 3/ 类/ 并发/ 缺陷/ 不/ 相关/ ;/ (/ 3/ )/ 数据/ 竞争/ 在/ 所有/ 并发/ 缺陷/ 中所/ 占/ 比例/ 较大/ ,/ 且/ 大部分/ 情况/ 下/ 是/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ 的/ 本质/ 原因/ ;/ (/ 4/ )/ 数据/ 竞争/ 常常/ 导致/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ ,/ 但/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ 并/ 不/ 完全/ 由/ 数据/ 竞争/ 造成/ ./ 在/ 图/ 5/ 所示/ 的/ 原子/ 性/ 违背/ 中/ ,/ L1/ 和/ L3/ 以及/ L2/ 和/ L3/ 之间/ 构成/ 数据/ 竞争/ ;/ 在/ 图/ 7/ 所示/ 的/ 顺序/ 违背/ 中/ ,/ 两线/ 程对/ mThread/ 的/ 写/ 操作/ 构成/ 数据/ 竞争/ ./ 对于/ 上述/ 两例/ 中/ 的/ 共享/ 变量/ buf/ _/ index/ 和/ mThread/ ,/ 如果/ 线程/ 在/ 每次/ 访问/ 前/ 都/ 持有/ 一致性/ 锁/ ,/ 并/ 在/ 访问/ 完后/ 立即/ 释放/ 该锁/ ,/ 则/ 数据/ 竞争/ 被/ 消除/ ,/ 而/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ 仍然/ 存在/ ;/ (/ 5/ )/ 数据/ 竞争/ 、/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ 互不/ 相同/ ./ 顺序/ 违背/ 与/ 数据/ 竞争/ 的/ 区别/ 在于/ :/ 顺序/ 违背/ 的/ 相关/ 指令/ (/ 组/ )/ 在/ 任何/ 执行/ 交错/ 中/ 只/ 允许/ 存在/ 一种/ 固定/ 的/ 顺序/ 关系/ ,/ 而/ 数据/ 竞争/ 的/ 相关/ 指令/ 在/ 执行/ 时/ 只/ 需要/ 具有/ 有序/ 关系/ 即可/ ./ 原子/ 性/ 违背/ 与/ 顺序/ 违背/ 的/ 区别/ 在于/ (/ 针对/ 单/ 共享/ 变量/ )/ :/ 原子/ 性/ 违背/ 涉及/ 3/ 个/ 操作/ ,/ 而/ 顺序/ 违背/ 只/ 涉及/ 两个/ 操作/ ;/ 另外/ 原子/ 性/ 违背/ 一定/ 由/ 至少/ 两个/ 顺序/ 违背/ 构成/ ,/ 但/ 顺序/ 违背/ 可/ 独立/ 存在/ ,/ 不/ 一定/ 是/ 原子/ 性/ 违背/ 的/ 构成/ 部分/ ./ 原子/ 性/ 违背/ 与/ 数据/ 竞争/ 的/ 区别/ 类似/ 于/ 其/ 与/ 顺序/ 违背/ 的/ 区别/ ./ 3/ 并发/ 缺陷/ 暴露/ 技术/ 并发/ 缺陷/ 只有/ 首先/ 出现/ ,/ 才能/ 被/ 观察/ 、/ 检测/ 和/ 验证/ ./ 某些/ 研究/ [/ 10/ ,/ 19/ -/ 20/ ]/ 能/ 通过/ 分析程序/ 的/ 一次/ 运行/ 而/ 预测/ “/ 潜在/ 的/ ”/ 并发/ 缺陷/ ,/ 并/ 设法/ 使/ 这些/ 缺陷/ 在/ 第/ 2/ 次/ 运行/ 中/ 暴露/ 出来/ ./ 通过观察/ 缺陷/ 能否/ 暴露/ ,/ 这些/ 研究/ 检验/ 预测/ 的/ 缺陷/ 是否是/ 真正/ 的/ 缺陷/ ./ 并发/ 缺陷/ 暴露/ 技术/ 考虑/ 并发/ 缺陷/ 的/ 共同/ 特点/ ,/ 能/ 暴露/ 各类/ 并发/ 缺陷/ ./ 传统/ 内控/ 测试/ 中/ 并发/ 缺陷/ 的/ 暴露/ 概率/ 很/ 低/ ,/ 这/ 主要/ 是/ 由于/ :/ 并发程序/ 的/ 执行/ 交错/ 空间/ 庞大/ ;/ 并发/ 缺陷/ 只/ 隐藏/ 于/ 某些/ 罕见/ 的/ 、/ 特殊/ 的/ 执行/ 交错/ ;/ 测试/ 技术/ 缺乏/ 对/ 底层/ 调度/ 器/ 的/ 控制/ ,/ 并发程序/ 常常/ 在/ 多次/ 不同/ 执行/ 中/ 按照/ 同一/ 执行/ 交错/ 执行/ ./ 针对/ 这些/ 问题/ ,/ 学者/ 们/ 提出/ 了/ 各种各样/ 的/ 尽快/ 暴露/ 并发/ 缺陷/ 的/ 方案/ ,/ 本文/ 将/ 其/ 总结/ 为/ 3/ 类/ ./ 3.1/ 随机/ 延时/ 扰动/ 该/ 技术/ [/ 4/ ,/ 6/ ,/ 16/ -/ 17/ ]/ 在/ 并发程序/ 进行/ 共享内存/ 访问/ 和/ 同步控制/ 时/ ,/ 插入/ 随机/ 延时/ ./ 对于/ 死锁/ ,/ 随机/ 延时/ 扰动/ 在线/ 程/ 成功/ 获取/ 锁后/ 插入/ 延时/ ,/ 从而/ 本/ 线程/ 挂/ 起/ 而/ 其他/ 线程/ 得到/ 执行/ 机会/ ,/ 增大/ 了/ 其他/ 线程/ 获取/ 锁/ 的/ 概率/ ./ 对于/ 原子/ 性/ 违背/ ,/ 该/ 技术/ 在/ 两个/ 本地/ 操作/ 之间/ 插入/ 延时/ ,/ 从而/ 增大/ 远程/ 操作/ 交错/ 在/ 两个/ 本地/ 操作/ 之间/ 的/ 概率/ ./ 对于/ 数据/ 竞争/ 和/ 顺序/ 违背/ ,/ 在/ 预知/ Page6/ 正确/ 执行/ 次序/ 的/ 前提/ 下/ ,/ 该/ 技术/ 将/ 试图/ 执行/ 错误/ 的/ 执行/ 次序/ ,/ 从而/ 使/ 两者/ 的/ 暴露/ 概率/ 接近/ 于/ 1/ (/ 限时/ 等待/ )/ ,/ 否则/ ,/ 两者/ 暴露/ 概率/ 接近/ 于/ 0.5/ ./ 3.2/ 线程/ 调度/ // 切换/ 该/ 技术/ [/ 3/ -/ 4/ ,/ 21/ -/ 22/ ]/ 对/ 底层/ 调度/ 器/ 施加/ 直接/ 或者/ 间接/ 影响/ ,/ 当/ 线程/ 进行/ 共享内存/ 访问/ 或者/ 同步控制/ 前后/ ,/ 挂/ 起/ 该/ 线程/ ,/ 调度/ 另/ 一线/ 程/ 执行/ ./ 比如/ ConTest/ [/ 4/ ]/ 在线/ 程/ 访问共享/ 变量/ 后/ ,/ 调用/ yield/ (/ )/ 强制/ 挂/ 起本/ 线程/ 同时/ 调度/ 优先级/ 同级/ 的/ 其他/ 线程/ ,/ 或者/ 调用/ priority/ (/ )/ 改变/ 本/ 线程/ 的/ 优先级/ ,/ 从而/ 间接/ 控制/ 调度/ 器/ 调度/ 执行/ 其他/ 线程/ ./ CHESS/ [/ 21/ ]/ 通过/ 覆盖/ 200/ 多个/ 操纵/ 线程/ 和/ 同步/ 设施/ 的/ Win32API/ ,/ 完全/ 、/ 彻底/ 地/ 控制/ 调度/ 器/ 的/ 线程/ 调度/ 和/ 异步/ 事件/ 的/ 发送/ 与/ 接收/ ;/ 在/ 此基础/ 上/ ,/ CHESS/ 又/ 使用/ 执行/ 枚举/ 技术/ ,/ 使得/ 并发程序/ 的/ 每次/ 运行/ 都/ 按照/ 不同/ 的/ 执行/ 交错/ 执行/ ,/ 从而/ 能/ 极大地提高/ 有限/ 测试用例/ 的/ 执行/ 交错/ 覆盖率/ ./ 3.3/ Fuzzing/ 技术/ 该/ 技术/ [/ 5/ -/ 7/ ,/ 23/ -/ 25/ ]/ 首先/ 使用/ 并发/ 缺陷/ 检测/ 技术/ 检测/ 出/ 可能/ 的/ 并发/ 缺陷/ ,/ 然后/ 根据/ 被/ 检测/ 出/ 的/ 并发/ 缺陷/ 的/ 信息/ ,/ 控制线/ 程/ 调度/ 和/ 执行/ ,/ 设法/ 使/ 程序/ 按照/ 能够/ 暴露/ 并发/ 缺陷/ 的/ 执行/ 交错/ 执行/ ./ 例如/ RaceFuzzer/ [/ 5/ ]/ 使用/ hybrid/ 技术/ [/ 12/ ]/ 检测/ 出/ 可能/ 构成/ 数据/ 竞争/ 的/ 一个/ 访问/ 对/ {/ s1/ ,/ s2/ }/ ,/ 当/ 某个/ 线程/ 如/ T1/ 将要/ 访问/ s1/ 时/ ,/ RaceFuzzer/ 暂停/ T1/ 执行/ ,/ 让/ 其/ 等待/ 直到/ 另外/ 一个/ 线程/ 如/ T2/ 将要/ 执行/ s2/ ,/ 这时/ 它/ 从/ T1/ 和/ T2/ 中/ 随机/ 选择/ 一个/ ,/ 令其/ 执行/ 下/ 一条/ 语句/ ,/ 如图/ 9/ 所示/ ./ RaceFuzzer/ 的/ 数据/ 竞争/ 暴露/ 概率/ 为/ 0.5/ ./ CTrigger/ [/ 6/ ]/ 使用/ pcr/ ①/ 技术/ 检测/ 出/ 可能/ 构成/ 原子/ 性/ 违背/ 的/ 3/ 个表/ 1/ 死锁/ 检测/ 研究/ 分类/ 与/ 对比/ 定理/ 证明/ 与/ 模型/ 检验/ [/ 27/ -/ 29/ ]/ 动态分析/ 定理/ 证明/ 与/ 模型/ 检验/ [/ 27/ -/ 29/ ]/ 试图/ 验证/ 一个/ 程序/ 是/ 免于/ 死锁/ 的/ ./ 如果/ 程序/ 中/ 存在/ 死锁/ ,/ 则/ 该/ 方法/ 将/ 检测/ 并/ 报告/ 一条/ 从/ 初始状态/ 到/ 死锁/ 状态/ 的/ 路径/ ./ 定理/ 证明/ 与/ 模型/ 检验/ 不能/ 直接/ 对/ 程序/ 源码/ 进行/ 分析/ ,/ 需要/ 人工/ 构建/ 用于/ 证明/ 与/ 检验/ 的/ 模型/ ./ 但/ 如何/ 保证/ 抽象/ 模型/ 与/ 程序/ 源码/ 在/ 语义上/ 的/ 等价/ 性是/ 一个/ 悬而/ 未解/ 的/ 问题/ ./ 而且/ 现实/ 世界/ 中/ 的/ 并发程序/ 通常/ 十分复杂/ ,/ 很难/ 构建/ 模型/ 以供/ 证明/ 和/ 检验/ ./ 访问/ {/ p/ ,/ c/ ,/ r/ }/ ,/ 然后/ 使用/ 随机/ 延时/ 扰动/ 来/ 增大/ 原子/ 性/ 违背/ 的/ 暴露/ 概率/ ./ ConLock/ [/ 25/ ]/ 使用/ magliclock/ 技术/ [/ 25/ -/ 26/ ]/ 检测/ 可能/ 导致/ 死锁/ 的/ 约束条件/ ,/ 然后/ 控制线/ 程/ 调度/ 使得/ 约束条件/ 满足/ 以/ 观察/ 死锁/ 能否/ 被/ 暴露/ ./ 随机/ 延时/ 扰动/ 技术/ 通过/ 插入/ 延时/ 的/ 方式/ 间接/ 影响/ 线程/ 的/ 调度/ ;/ 而/ 线程/ 调度/ // 切换/ 技术/ 则/ 直接/ 控制线/ 程/ 的/ 调度/ ./ 这/ 两种/ 技术/ 在/ 对/ 线程/ 调度/ 施加影响/ 时/ 都/ 比较/ 盲目/ ,/ 没有/ 具体/ 的/ 目标/ ./ 而/ Fuzzing/ 技术/ 虽能/ 有意识/ 地/ 调度/ 线程/ 以/ 观察/ 某些/ 并发/ 缺陷/ 能否/ 暴露/ ,/ 但/ 它/ 依赖于/ 其他/ 工具/ 的/ 检测/ 结果/ ./ 4/ 死锁/ 检测/ 与/ 规避/ 在/ 操作系统/ 和/ 数据库/ 领域/ ,/ 无论/ 在/ 进程/ 层面/ 还是/ 事务/ 层面/ ,/ 死锁/ 的/ 预防/ 、/ 检测/ 、/ 规避/ 和/ 解除/ 已/ 得到/ 充分/ 完善/ 的/ 研究/ ,/ 这里/ 不予/ 涉及/ ./ 本节/ 讨论/ 进程/ 内部/ 线程/ 层面/ 上/ 的/ 死锁/ 检测/ 与/ 规避/ ./ 4.1/ 死锁/ 检测/ 表/ 1/ 将/ 近年来/ 死锁/ 检测/ 方面/ 的/ 研究/ 分为/ 定理/ 证明/ 与/ 模型/ 检验/ 、/ 数据流/ 分析/ 和/ 动态分析/ 3/ 类/ ,/ 并/ 从/ 人工干预/ 度/ 、/ 扩展性/ 、/ 误检率/ 、/ 漏检/ 率/ 和/ 执行/ 开销/ 5/ 个/ 维度/ 对/ 这/ 3/ 类/ 研究/ 进行/ 对比/ ./ 为/ 降低/ 定理/ 证明/ 与/ 模型/ 检验/ 的/ 人工干预/ 度/ 并/ 提高/ 其/ 可扩展性/ ,/ 数据流/ 分析/ 技术/ [/ 30/ -/ 32/ ]/ 直接/ 分析程序/ 源码/ ,/ 组合/ 使用/ 调用/ 图/ 分析/ 、/ 指向/ 分析/ 和/ 逃逸/ 分析/ 等/ 静态/ 分析/ 技术/ ,/ 计算/ 静态/ 锁/ 占用/ 约束/ 或者/ 锁/ 占用/ 顺序/ 图/ [/ 19/ ,/ 33/ ]/ ,/ 使用/ 约束/ 求解/ 和/ 环/ 检测/ 算法/ 在/ 其/ 上/ 检测/ ①/ pcr/ 代表/ 对/ 某/ 一/ 共享/ 变量/ 的/ 3/ 个/ 访问/ ,/ 其中/ p/ ,/ c/ 来自/ 同/ 一线/ Page7/ 环/ ,/ 将/ 环/ 作为/ 可能/ 的/ 死锁/ 报告/ 出来/ ./ 数据流/ 分析/ 缺乏/ 精确/ 的/ 运行/ 时/ 信息/ ,/ 一般/ 对/ 变量值/ 作/ 保守/ 估计/ ,/ 因此/ 其误/ 检率/ 高/ 而/ 漏检/ 率低/ ./ 动态分析/ [/ 10/ ,/ 23/ ,/ 26/ ,/ 33/ -/ 43/ ]/ 是/ 进行/ 死锁/ 检测/ 的/ 主流/ 方法/ ,/ 一般/ 分为/ 在线/ [/ 34/ -/ 40/ ]/ 和/ 离线/ [/ 10/ ,/ 23/ ,/ 26/ ,/ 33/ ,/ 41/ -/ 43/ ]/ 两类/ ./ 在线/ 方法/ 监视/ 程序/ 的/ 运行/ ,/ 实时/ 获取/ 感兴趣/ 的/ 信息/ ,/ 建立/ 和/ 更新/ 目标程序/ 同步/ 状态/ 的/ 抽象/ 表示/ ,/ 并/ 在/ 其/ 上/ 检测/ 死锁/ ./ 离线/ 方法/ 先对/ 程序/ 源码/ 静态/ 插桩/ ,/ 然后/ 执行程序/ 并/ 获取/ 执行/ 轨迹/ ,/ 最后/ 分析/ 轨迹/ ,/ 建立/ 锁/ 占用/ 顺序/ 图/ [/ 35/ ]/ ,/ 将/ 其/ 上/ 检测/ 到/ 的/ 环/ 作为/ 死锁/ 报告/ 出来/ ./ 在线/ 方法/ 只能/ 检测/ 到/ 本次/ 执行/ 中/ 实际/ 出现/ 的/ 死锁/ ,/ 而/ 离线/ 方法/ 则/ 还/ 能/ “/ 预测/ ”/ 在/ 其他/ 执行/ 中/ 可能/ 出现/ 的/ 死锁/ ./ 例如/ MagicFuzzer/ [/ 26/ ]/ 、/ DeadlockFuzzer/ [/ 23/ ]/ 和表/ 2/ 死锁/ 规避/ 研究/ 分类/ 与/ 对比/ 类型/ 系统/ [/ 44/ -/ 45/ ]/ 效应/ 系统/ [/ 46/ -/ 48/ ]/ Petri/ 网/ 控制论/ [/ 49/ -/ 54/ ]/ 动态分析/ [/ 36/ -/ 37/ ,/ 40/ ,/ 55/ -/ 57/ ]/ 类型/ 系统/ [/ 44/ -/ 45/ ]/ 检查程序/ 中/ 各个/ 线程/ 是否/ 按照/ 某个/ 全局/ 锁/ 占用/ 顺序/ 申请/ 锁/ ./ 如果/ 所有/ 线程/ 都/ 按照/ 相同/ 的/ 锁/ 占用/ 顺序/ 请求/ 锁/ 的话/ ,/ 就/ 不会/ 出现/ 两个/ 或/ 多个/ 线程/ 按照/ 相反/ 的/ 顺序/ 占用/ 锁/ 的/ 情况/ ,/ 从而/ 避免/ 死锁/ 的/ 发生/ ./ 如果/ 某个/ 线程/ 请求/ 锁/ 的/ 顺序/ 与/ 全局/ 顺序/ 不符/ ,/ 则/ 该/ 并发程序/ 不会/ 通过/ 类型/ 检查/ ./ 虽然/ 类型/ 系统/ 支持/ 类型/ 自动/ 推断/ ,/ 但是/ 仍然/ 需要/ 为/ 某些/ 锁/ 添加/ 锁级/ (/ locklevel/ )/ 注释/ ./ 当/ 并发程序/ 规模/ 较大/ 时/ ,/ 为/ 其/ 添加/ 注释/ 将/ 是/ 一项/ 繁重/ 的/ 工作/ ./ 类型/ 系统/ 试图/ 在/ 编译/ 阶段/ 保证/ 并发程序/ 是/ 没有/ 死锁/ 的/ ,/ 而/ 效应/ 系统/ 、/ Petri/ 网/ 方法/ 和/ 动态分析/ 方法/ 则/ 在/ 并发程序/ 可能/ 存在/ 死锁/ 的/ 情况/ 下/ ,/ 控制线/ 程/ 调度/ 来/ 避开/ 包含/ 死锁/ 的/ 执行/ 交错/ ./ 效应/ 系统/ [/ 46/ -/ 48/ ]/ 静态/ 地/ 分析/ 和/ 计算/ 每/ 一个/ 加锁/ 解锁/ 操作/ 对/ 其他/ 加锁/ 解锁/ 操作/ 的/ 连续/ 效应/ (/ continua/ -/ tioneffect/ )/ ,/ 然后/ 把/ 获得/ 的/ 锁/ 效应/ 信息/ 插桩/ 到/ 相应/ 的/ 语句/ 之前/ ./ 程序/ 在/ 动态/ 执行/ 的/ 时候/ ,/ 会/ 根据/ 效应/ 信息/ 计算/ 出/ 每个/ 加锁/ 操作/ 对应/ 的/ 未来/ 锁集/ (/ futurelockset/ )/ ,/ 只有/ 当锁/ 集中/ 的/ 所有/ 锁/ 都/ 没有/ 被/ 占据/ 的/ 时候/ ,/ 当前/ 加锁/ 操作/ 才/ 会/ 被/ 执行/ ./ 这样/ 就/ 动态/ 规避/ 了/ 死锁/ 的/ 发生/ ./ 效应/ 系统/ 动静/ 分析/ 结合/ ,/ 在/ 死锁/ 规避/ 方面/ 效率/ 较/ 高/ ,/ 但/ 它/ 依赖于/ 程序/ 源码/ ./ 如果/ 目标程序/ 中/ 的/ 死锁/ 由/ 源码/ 不/ 可见/ 的/ 第三方/ 库/ 造成/ ,/ 则/ 不能/ 规避/ 这/ MagicLock/ [/ 42/ ]/ 根据/ 预测/ 到/ 的/ 死锁/ 信息/ ,/ 在/ 程序/ 的/ 下/ 一次/ 执行/ 中/ ,/ 控制线/ 程/ 调度/ ,/ 试图/ 使/ 死锁/ 暴露/ 出来/ ./ 相对/ 于/ 在线/ 方法/ ,/ 离线/ 方法/ 需要/ 存储/ 执行/ 轨迹/ ,/ 对于/ 长时间/ 运行/ 的/ 并发程序/ 不/ 可行/ ./ 动态分析/ 不/ 需要/ 人工干预/ ,/ 扩展性/ 好/ ,/ 误报率/ 低/ ./ 但/ 其/ 漏报/ 率高/ ,/ 且/ 执行/ 开销/ 较大/ ,/ 如/ Valgrind/ [/ 39/ ]/ 使/ 目标程序/ 的/ 运行/ 时间/ 增加/ 到/ 原来/ 的/ 22/ 倍/ 以上/ ./ 4.2/ 死锁/ 规避/ 死锁/ 经常/ 在/ 多个/ 线程/ 按照/ 相反/ 的/ 顺序/ 请求/ 或者/ 等待/ 某些/ 资源/ 的/ 情况/ 下/ 发生/ ./ 只要/ 合理安排/ 线程/ 请求/ 资源/ 的/ 顺序/ ,/ 死锁/ 是/ 可以/ 被/ 规避/ 的/ ./ 表/ 2/ 将/ 近年来/ 的/ 死锁/ 规避/ 研究/ 分为/ 4/ 类/ ,/ 并/ 从/ 人工干预/ 度/ 、/ 扩展性/ 和/ 执行/ 开销/ 3/ 个/ 方面/ 对/ 它们/ 进行/ 对比/ ./ 种/ 死锁/ ./ 基于/ Petri/ 网/ 控制论/ 的/ 方法/ [/ 49/ -/ 54/ ]/ ,/ 如/ Gadara/ [/ 49/ ]/ ,/ 将/ 整个/ 程序/ 转化/ 为/ 并发/ 语义/ 等价/ 的/ Petri/ 网/ 模型/ ,/ 利用/ 离散/ 控制/ 理论/ 在/ 模型/ 上/ 寻找/ 可能/ 导致/ 死锁/ 的/ 转换/ (/ transition/ )/ ,/ 并/ 插入/ 额外/ 的/ 控制/ 逻辑/ 避免/ 死锁/ 在/ 运行/ 时/ 发生/ ./ 该/ 方法/ 因在/ 程序运行/ 前/ 插入/ 控制/ 逻辑/ ,/ 对/ 目标程序/ 的/ 性能/ 影响/ 较/ 小/ ,/ 能/ 高效/ 地/ 规避/ 死锁/ ,/ 但/ 扩展性/ 差/ ,/ 且/ 对/ 指针/ 别名/ 非常/ 敏感/ ./ 在/ 最坏/ 情况/ 下/ ,/ 该/ 方法/ 可能/ 插入/ 过多/ 的/ 控制/ 逻辑/ 以致于/ 降低/ 目标程序/ 的/ 并发/ 度/ ./ 基于/ 动态分析/ 的/ 方法/ [/ 36/ -/ 37/ ,/ 40/ ,/ 55/ -/ 57/ ]/ ,/ 如/ Dimmunix/ [/ 36/ -/ 37/ ]/ 、/ Rx/ [/ 56/ ]/ 和/ Sammati/ [/ 40/ ]/ ,/ 不/ 需要/ 预先/ 获知/ 目标程序/ 的/ 任何/ 先验/ 信息/ (/ 如/ 程序/ 源码/ )/ ,/ 就/ 能/ 在/ 运行/ 时/ 动态/ 规避/ 死锁/ ./ Dimmunix/ 先/ 检测/ 死锁/ ,/ 并/ 记录/ 导致/ 死锁/ 的/ 线程/ 的/ 栈/ 帧/ 作为/ 死锁/ 的/ 特征/ ,/ 然后/ 在/ 并发程序/ 下次/ 运行/ 时/ ,/ 有意识/ 地/ 控制程序/ 执行/ ,/ 阻止/ 相关/ 线程/ 再次/ 进入/ 相应/ 的/ 栈/ 帧/ ,/ 从而/ 成功/ 规避/ 已/ 遇到/ 的/ 死锁/ ./ Rx/ 在/ 目标程序/ 执行/ 时/ 每隔/ 一段时间/ 设置/ 一个/ 检查点/ ,/ 一旦/ 检测/ 到/ 死锁/ 发生/ ,/ 就/ 将/ 目标程序/ 恢复/ 到/ 最近/ 一次/ 检查点/ 所/ 对应/ 的/ 状态/ ,/ 并/ 尝试/ 新/ 的/ 执行/ 交错/ 来/ 规避/ 死锁/ ./ Sammati/ 认为/ 设置/ 全局/ 检查点/ 开销/ 太/ 大/ ,/ 因此/ 只/ 在/ 每个/ 线程/ 尝试/ 获取/ 锁时/ 设置/ 线程/ 局部/ 的/ 恢复/ 点/ ./ Dimmunix/ 不能/ 在/ 检测/ 死锁/ 后/ 即时/ 规避/ 死锁/ ,/ 因/ Page8/ 此/ 是/ 离线/ 的/ 规避/ 方案/ ./ 而/ Rx/ 和/ Sammati/ 则/ 是/ 在线/ 规避/ 死锁/ ,/ 无需/ 重新/ 执行程序/ ./ Rx/ 和/ Sammati/ 周期性地/ 设置/ 检查点/ ,/ 时空/ 开销/ 很大/ ,/ 并且/ 不是/ 所有/ 的/ 操作/ 都/ 能/ 回退/ ,/ 如/ 用户/ 输入/ 、/ 输出/ 、/ 文件系统/ 操作/ 等/ ./ 动态分析/ 无需/ 人工/ 干扰/ ,/ 能/ 处理/ 大规模/ 、/ 长时间/ 运行/ 的/ 并发程序/ ,/ 但会/ 大幅/ 降低/ 目标程序/ 的/ 运行/ 速度/ ./ 5/ 数据/ 竞争/ 检测/ 与/ 规避/ 数据/ 竞争/ 在/ 所有/ 并发/ 缺陷/ 中/ 占有/ 较大/ 比例/ [/ 8/ ]/ ,/ 并且/ 常常/ 是/ 其他/ 非/ 死锁/ 并发/ 缺陷/ 的/ 根本原因/ ./ 本节/ 分析/ 和/ 归纳/ 数据/ 竞争/ 的/ 检测/ 与/ 规避/ 研究/ ./ 图/ 10/ 数据/ 竞争/ 检测/ 研究/ 分类/ 与/ 对比/ 锁/ 集法/ 检查/ 两个/ 线程/ 对/ 同一/ 共享/ 变量/ 的/ 访问/ 是否/ 具有/ 共同/ 的/ 锁/ ./ 如果/ 不/ 具有/ 共同/ 锁/ ,/ 则/ 这/ 两个/ 访问/ 构成/ 一个/ 可能/ 的/ 数据/ 竞争/ ./ 在/ 给定/ 精确/ 信息/ 下/ ,/ 锁/ 集法/ 能/ 检测/ 所有/ 数据/ 竞争/ ,/ 但/ 因/ 忽略/ 除锁/ 之外/ 的/ 其他/ 同步/ 原语/ ,/ 如/ signal/ // wait/ 、/ fork/ // join/ 等/ ,/ 它/ 的/ 误检率/ 较/ 高/ ./ 锁/ 集法/ 的/ 实现/ 手段/ 一般/ 有/ 类型/ 系统/ 、/ 数据流/ 分析/ 和/ 动态分析/ ./ 类型/ 系统/ 将/ 竞争/ 检测/ 问题/ 转化/ 为/ 类型/ 检查/ 问题/ ,/ 检查/ 是否/ 所有/ 对/ 共享/ 数据/ 的/ 访问/ 都/ 被/ 一致性/ 锁/ 保护/ ./ 如果/ 某个/ 访问/ 没有/ 被/ 一致性/ 锁/ 保护/ ,/ 则/ 其/ 类型/ 为/ 非法/ 类型/ ,/ 该/ 访问/ 被/ 检测/ 为/ 构成/ 潜在/ 数据/ 竞争/ 的/ 一个/ 元素/ ./ 类型/ 系统/ 需要/ 用户/ 添加/ 注释/ ,/ 为/ 共享/ 变量/ 关联/ 一致性/ 锁/ 或者/ 标注/ 原子/ 集/ 标签/ ./ 数据流/ 分析/ 则/ 计算/ 每个/ 读写/ 共享/ 变量/ 的/ 访问/ 所/ 持有/ 的/ 锁/ 5.1/ 数据/ 竞争/ 检测/ 学者/ 们/ 已/ 在/ 数据/ 竞争/ 检测/ 领域/ 做出/ 了/ 大量/ 研究/ ,/ 图/ 10/ 从/ 基本/ 思想/ 和/ 方法/ 手段/ 两个/ 方面/ 对/ 已有/ 工作/ 进行/ 分类/ 和/ 对比/ ./ 现有/ 研究/ 的/ 检测/ 思路/ 可/ 分为/ 4/ 类/ :/ 锁/ 集法/ (/ lockset/ )/ 、/ 先/ 发生/ 于法/ (/ happens/ -/ before/ )/ 、/ 混合法/ (/ hybrid/ )/ 和/ 面向/ 后果/ 法/ (/ conseqence/ -/ oriented/ )/ 其中/ 前/ 3/ 种为/ 竞争/ 检测/ 的/ 传统/ 方法/ ,/ 后/ 一种/ 为/ 新近/ 提出/ 方法/ ./ 现有/ 研究/ 的/ 检测/ 手段/ 可/ 分为/ 4/ 类/ :/ 类型/ 系统/ 、/ 模型/ 检验/ 、/ 数据流/ 分析/ 和/ 动态分析/ ,/ 并/ 以/ 动态分析/ 为主/ ./ 对/ 检测/ 思想/ ,/ 我们/ 从/ 复杂度/ 、/ 误检率/ 和/ 漏检/ 率/ 3/ 个/ 方面/ 进行/ 评价/ ;/ 对/ 检测/ 手段/ ,/ 我们/ 从/ 人工干预/ 度/ 、/ 扩展性/ 、/ 误检率/ 、/ 漏检/ 率/ 和/ 执行/ 开销/ 5/ 个/ 方面/ 进行/ 评价/ ./ 集/ ,/ 如果/ 两个/ 读写/ 同一/ 共享/ 变量/ 的/ 访问/ (/ 至少/ 有/ 一个/ 为/ 写访问/ )/ 的/ 锁集/ 的/ 交集/ 为空/ ,/ 则/ 这/ 两个/ 访问/ 构成/ 一个/ 数据/ 竞争/ ./ 数据流/ 分析/ 使用/ 指向/ 分析/ 和/ 逃逸/ 分析/ ,/ 计算/ 共享/ 变量/ 集/ 和/ 判断/ 不同/ 锁/ 集中/ 的/ 元素/ 是否/ 指向/ 同一个/ 锁/ 对象/ ./ 数据流/ 分析/ 能/ 处理/ 较/ 大规模/ 程序/ ,/ 能/ 静态/ 检测/ 所有/ 可能/ 发生/ 的/ 数据/ 竞争/ ,/ 其/ 缺点/ 是/ 步骤/ 较/ 多/ ,/ 每步/ 所/ 采用/ 的/ 分析/ 都/ 是/ 不/ 精确/ 的/ ,/ 因此/ 误检/ 很多/ ./ RELAY/ [/ 61/ ]/ 在/ 不/ 使用/ 过滤/ 措施/ 的/ 情况/ 下/ ,/ 准确率/ 仅为/ 11/ %/ ./ 动态分析/ 监视/ 程序运行/ ,/ 在/ 监视/ 过程/ 中/ 识别/ 共享/ 变量/ 和/ 进行/ 锁/ 集求/ 交/ 运算/ ,/ 如果/ 结果/ 为空/ ,/ 则/ 报告/ 一个/ 数据/ 竞争/ ./ 动态分析/ 能/ 准确/ 识别/ 共享/ 变量/ 集/ 和/ 共享/ 变量/ 访问/ 的/ 锁集/ ,/ 因此/ 误检率/ 低/ ,/ 但/ 因/ 动态/ 监视/ 运行/ ,/ 会/ 对/ 目标程序/ 造成/ 较大/ 执行/ 开销/ ./ Page9/ 为/ 克服/ 锁/ 集法/ 由于/ 只/ 考虑/ 锁/ 这/ 一种/ 同步/ 设施/ 而/ 造成/ 的/ 高误/ 检率/ 问题/ ,/ 先/ 发生/ 于法/ 考虑/ 所有/ 同步/ 设施/ ,/ 利用/ 线程/ 内/ 顺序/ 和/ 线程/ 间/ 顺序/ 为/ 程序/ 中/ 的/ 所有/ 操作/ 建立/ 偏序/ 关系/ ,/ 如果/ 对/ 同一/ 共享/ 变量/ 的/ 并发/ 访问/ 不/ 具有/ 偏序/ 关系/ ,/ 则/ 它们/ 构成/ 一个/ 数据/ 竞争/ ./ 先/ 发生/ 于法/ 没有/ 误检/ ,/ 然而/ 它/ 对/ 程序/ 的/ 执行/ 交错/ 敏感/ ,/ 在/ 不同/ 的/ 执行/ 交错/ 中/ 检测/ 到/ 的/ 数据/ 竞争/ 也/ 不同/ ./ 先/ 发生/ 于法/ 的/ 竞争/ 检测/ 能力/ 弱于/ 锁/ 集法/ ,/ 在/ 同一/ 执行/ 交错/ 中/ ,/ 前者/ 可能/ 漏检/ 后者/ 能/ 检测/ 出来/ 的/ 数据/ 竞争/ ./ 另外/ ,/ 先/ 发生/ 于法/ 实现/ 起来/ 也/ 比锁/ 集法/ 困难/ ,/ 开销/ 较大/ ,/ 扩展性/ 差/ ./ 先/ 发生/ 于法/ 的/ 实现/ 手段/ 有/ 模型/ 检验/ 和/ 动态分析/ 两种/ ./ 模型/ 检验/ 先/ 建立/ 表征/ 并发程序/ 操作/ 语义/ 的/ 抽象/ 模型/ ,/ 然后/ 按照/ 某种/ 优化/ 策略/ (/ DFS/ 、/ BFS/ 或者/ 深度/ 受限/ 搜索/ )/ 搜索/ 其中/ 的/ 执行/ 交错/ ,/ 使得/ 包含/ 数据/ 竞争/ 的/ 执行/ 交错/ 被/ 尽早/ 搜索/ 到/ ./ 模型/ 检验/ 扩展性/ 差/ ,/ JRF/ 和/ JRF/ -/ E/ 都/ 只/ 针对/ 小规模/ 程序/ 适用/ ./ 动态分析/ 直接/ 监视/ 某个/ 执行/ 交错/ ,/ 并/ 实时/ 计算/ 、/ 更新/ 和/ 比较/ 共享/ 变量/ 访问/ 的/ 时间/ 戳/ ,/ 检测/ 实际/ 发生/ 的/ 数据/ 竞争/ ./ 动态/ 分析法/ 误报率/ 低/ ,/ 但/ 因/ 既/ 监视/ 每/ 一个/ 同步/ 原语/ ,/ 又/ 监视/ 每/ 一个/ 共享/ 变量/ 访问/ ,/ 执行/ 开销/ 较大/ ./ 为/ 降低/ 开销/ ,/ LiteRace/ [/ 76/ ]/ 、/ PACER/ [/ 77/ ]/ 和/ RACEZ/ [/ 79/ ]/ 对/ 程序执行/ 进行/ 动态/ 采样/ ,/ 在/ 监视/ 部分/ 同步/ 原语/ 和/ 共享/ 变量/ 访问/ 的/ 情况/ 下/ ,/ 检测/ 数据/ 竞争/ ./ 例如/ 对于/ 一个/ 在/ 当前/ 执行/ 中/ 发生/ 的/ 数据/ 竞争/ ,/ PACER/ 保证/ 以/ 近似于/ 采样率/ 的/ 概率/ 检测/ 到/ 该/ 数据/ 竞争/ ,/ 采样率/ 越高/ ,/ 检测/ 概率/ 越大/ ./ AutoClassifer/ [/ 80/ ]/ 和/ RecPlay/ 则/ 离线/ 检测/ 数据/ 竞争/ ,/ 将/ 执行/ 监视/ 与/ 竞争/ 检测/ 分离/ ./ 它们/ 在/ 程序/ 第/ 1/ 次/ 运行/ 时/ 记录/ 其/ 执行/ 轨迹/ ,/ 然后/ 根据/ 执行/ 轨迹/ 严格/ 重演/ 程序/ 第/ 1/ 次/ 的/ 运行/ ,/ 并/ 在/ 该/ 执行/ 重演/ 中/ 检测/ 数据/ 竞争/ ./ 为/ 克服/ 锁/ 集法/ 的/ 高误/ 检率/ 和/ 先/ 发生/ 于法/ 的/ 高/ 漏检/ 率/ 问题/ ,/ 混合法/ 综合/ 使用/ 锁/ 集法/ 和/ 先/ 发生/ 于法/ ./ 它/ 首先/ 使用/ 锁集/ 法分析/ 查找/ 可能/ 的/ 数据/ 竞争/ ,/ 然后/ 使用/ 先/ 发生/ 于法/ 去除/ 误检/ ./ 混合法/ 在实践中/ 取得/ 了/ 较/ 好/ 的/ 检测/ 效果/ ,/ 误报率/ 和/ 漏检/ 率/ 较/ 低/ ,/ 然而/ 由于/ 需要/ 将/ 两种/ 方法/ 有机/ 结合/ 起来/ 使用/ ,/ 其/ 复杂性/ 较/ 高/ ./ 混合法/ 的/ 主要/ 实现/ 手段/ 是/ 动态分析/ ,/ 近来/ TG/ [/ 30/ ]/ 通过/ 精确/ 的/ 静态/ 分析/ 建立/ 事务/ 图/ (/ transactiongraph/ )/ 来/ 抽象/ 表示/ 程序/ 的/ 并发/ 执行/ 行为/ ,/ 在/ 事务/ 图上/ 用/ 数据流/ 分析/ 实现/ 了/ 混合法/ ./ 传统/ 方法/ 正向/ 检测/ 数据/ 竞争/ ,/ 即/ 查找/ 可能/ 构成/ 数据/ 竞争/ 的/ 共享/ 变量/ 访问/ 转变/ ./ 而/ 面向/ 后果/ 法则/ 动静/ 结合/ 地/ 逆向/ 检测/ 数据/ 竞争/ ./ 它/ 先/ 静态/ 分析/ 数据/ 竞争/ 发生/ 后/ 可能/ 导致/ 程序/ 崩溃/ 的/ 程序/ 点/ ,/ 比如/ 读取/ 未/ 赋值/ 变量/ 、/ 空/ 指针/ 引用/ 和/ 内存/ 溢出/ 等/ ;/ 然后/ 逆向/ 查找/ 跟/ 该/ 程序/ 点/ 存在/ 数据/ 和/ 控制/ 依赖/ 的/ 程序/ 点/ ,/ 如果/ 这/ 两个/ 程序/ 点/ 来自/ 不同/ 线程/ ,/ 则/ 检测/ 到/ 一个/ 可能/ 的/ 数据/ 竞争/ ;/ 最后/ 使用/ 随机/ 延时/ 扰动/ 使/ 可能/ 的/ 数据/ 竞争/ 暴露/ 出来/ ./ 不同/ 并发/ 缺陷/ 的/ 构成/ 要素/ 虽然/ 不同/ ,/ 但/ 造成/ 的/ 后果/ 却/ 几乎/ 相同/ ./ 面向/ 后果/ 法/ ,/ 如/ ConSeq/ 和/ ConMem/ [/ 24/ ]/ ,/ 从/ 并发/ 缺陷/ 可能/ 造成/ 的/ 后果/ 出发/ 逆向/ 推断/ 构成/ 并发/ 缺陷/ 的/ 元素/ ,/ 能/ 检测/ 所有/ 非/ 死锁/ 并发/ 缺陷/ ,/ 包括/ 数据/ 竞争/ 、/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ ./ 5.2/ 数据/ 竞争/ 规避/ 规避/ 某一/ 共享/ 变量/ 上/ 的/ 数据/ 竞争/ 的/ 方法/ 有/ 两种/ :/ (/ 1/ )/ 为/ 该/ 变量/ 的/ 所有/ 访问/ 加上/ 一致性/ 锁/ 保护/ ,/ 或者/ (/ 2/ )/ 在/ 该/ 变量/ 的/ 任何/ 两个/ 访问/ 之间/ 形成/ 固定/ 执行/ 次序/ ./ 软件/ 事务/ 内存/ [/ 56/ -/ 57/ ,/ 84/ -/ 85/ ]/ 和/ AtomRace/ [/ 75/ ,/ 86/ ]/ 属于/ 第/ 1/ 种/ ,/ PSet/ [/ 87/ ]/ 属于/ 第/ 2/ 种/ ,/ 而/ CFix/ [/ 88/ -/ 89/ ]/ 和/ Loom/ [/ 90/ ]/ 则/ 综合/ 使用/ 这/ 两种/ 方法/ ./ 我们/ 从/ 规避/ 开销/ 和/ 规避/ 能力/ 角度/ 评价/ 这/ 两种/ 规避/ 方法/ ./ 软件/ 事务/ 内存/ [/ 56/ -/ 57/ ,/ 84/ -/ 85/ ]/ (/ SoftwareTransactionMemory/ ,/ STM/ )/ 把/ 对/ 共享/ 变量/ 的/ 访问/ 视为/ 事务/ ./ 对/ 共享/ 变量/ 的/ 一系列/ 操作/ 要么/ 原子/ 性/ 地/ 全部/ 执行/ ,/ 要么/ 一个/ 也/ 不/ 执行/ ./ 如果/ 两个/ 由/ 共享/ 变量/ 访问/ 构成/ 的/ 事务/ 在/ 提交/ 时/ 存在/ 冲突/ ,/ STM/ 会/ 回退/ 其中/ 一个/ 事务/ ,/ 抛弃/ 其/ 更新/ ,/ 并/ 重新/ 执行/ 被/ 回退/ 的/ 事务/ ,/ 从而/ 保证/ 共享/ 变量/ 的/ 完整性/ 和/ 一致性/ ,/ 避免/ 数据/ 竞争/ 的/ 发生/ ./ Grace/ [/ 57/ ]/ 使用/ 进程/ 模拟/ 线程/ 执行/ ,/ 这样/ “/ 线程/ ”/ 对/ 共享/ 变量/ 的/ 更新/ 都/ 被/ 隔离/ 在/ 各自/ 的/ 进程/ 空间/ 内/ ,/ 仅当/ “/ 线程/ ”/ 终结/ 时才/ 提交/ 这些/ 更新/ ./ 如果/ “/ 线程/ ”/ 之间/ 的/ 更新/ 存在/ 冲突/ ,/ 则/ 最早/ 提交/ 的/ 那个/ “/ 线程/ ”/ 的/ 更新/ 得以/ 提交/ ,/ 其他/ “/ 线程/ ”/ 重新/ 执行/ ./ 通过/ 以/ “/ 线程/ ”/ 为/ 单位/ 原子/ 性/ 地/ 执行/ ,/ Grace/ 不仅/ 能/ 规避/ 数据/ 竞争/ ,/ 也/ 能/ 规避/ 原子/ 性/ 违背/ 和/ 顺序/ 违背/ ./ STM/ 规避/ 开销/ 小/ ,/ 但/ 因为/ 有些/ 操作/ ,/ 如/ 外围设备/ I/ // O/ 和/ 网络/ I/ // O/ ,/ 不可/ 回退/ ,/ 故其/ 规避/ 能力/ 有限/ ./ AtomRace/ [/ 75/ ,/ 86/ ]/ 检测/ 到/ 某个/ 变量/ 上/ 存在/ 数据/ 竞争/ 时/ ,/ 采取/ 3/ 种/ 规避/ 措施/ :/ 插入/ 随机/ 延时/ 或者/ 改变/ 线程/ 优先级/ 以/ 影响/ 执行/ 调度/ ;/ 为/ 后继/ 对/ 该/ 共享/ 变量/ 的/ 访问/ 加锁/ ;/ 用/ 正确/ 的/ 执行/ 交错/ 的/ 值/ 代替/ 错误/ 的/ 执行/ 交错/ 的/ 值/ ./ 其中/ 第/ 1/ 种/ 措施/ 只是/ 降低/ 了/ 数据/ 竞争/ 的/ 发生/ 概率/ ,/ 没有/ 完全/ 消除/ 数据/ 竞争/ ;/ 第/ 2/ 种/ 措施/ 可能/ 引入/ 新/ 的/ 并发/ 缺陷/ 如/ 死锁/ ;/ 第/ 3/ 种/ 措施/ 实现/ 复杂/ 开销/ 大/ ./ AtomRace/ 与/ STM/ 的/ 区别/ 是/ :/ 针对/ 某/ 共享/ 变量/ ,/ 前者/ 不能/ 规避/ 该/ 变量/ 上/ 的/ 第/ 1/ 个/ 数据/ 竞争/ ,/ 而/ Page10STM/ 能/ 规避/ 该/ 变量/ 上/ 的/ 所有/ 数据/ 竞争/ ./ AtomRace/ 控制线/ 程/ 调度/ ,/ 规避/ 开销/ 比/ STM/ 高/ ./ PSet/ [/ 87/ ]/ 使用/ 第/ 2/ 种/ 方法/ 规避/ 数据/ 竞争/ ./ PSet/ 为/ 每个/ 共享/ 变量/ 操纵/ 指令/ 都/ 关联/ 一个/ 指令集/ ,/ 其中/ 的/ 元素/ 表示/ 该/ 指令/ 的/ 合法/ 前驱/ ,/ 在/ 生产性/ 运行/ 中/ ,/ 只/ 允许/ 前驱/ 集中/ 的/ 指令/ 刚好/ 在/ 该/ 指令/ 之前/ 执行/ ./ 指令/ 的/ 前驱/ 集/ 通过/ 内控/ 测试/ 自动/ 学习/ 得到/ ,/ 表示/ 那些/ 经过/ 良好/ 测试/ 、/ 不/ 包含/ 并发/ 缺陷/ 的/ 执行/ 交错/ ./ PSet/ 能/ 规避/ 所有/ 非/ 死锁/ 并发/ 缺陷/ ,/ 但/ 其/ 实现/ 需要/ 修改/ 现有/ 硬件/ 和/ 指令/ 体系结构/ ,/ 并/ 控制线/ 程/ 调度/ ,/ 故/ 规避/ 开销/ 大/ ;/ 由于/ 训练/ 不足/ 和/ 偶然/ 正确性/ 等/ 原因/ ,/ 前驱/ 集/ 对应/ 的/ 执行/ 交错/ 可能/ 仍然/ 包含/ 数据/ 竞争/ ,/ 因此/ PSet/ 规避/ 能力/ 有限/ ./ CFix/ [/ 88/ -/ 89/ ]/ 和/ Loom/ [/ 90/ ]/ 同时/ 使用/ 两种/ 方法/ 规避/ 数据/ 竞争/ ./ CFix/ 自动/ 为/ 非/ 死锁/ 并发/ 缺陷/ 生成/ 补丁/ 代码/ ./ 它/ 以/ 并发/ 缺陷/ 检测工具/ (/ 如/ CTrigger/ [/ 6/ ]/ 和/ ConSeq/ 等/ )/ 的/ 输出/ 作为/ 输入/ ,/ 通过/ 添加/ 互斥/ 锁/ 和/ 条件/ 变量/ ,/ 在/ 相关/ 代码段/ 之间/ 实施/ 符合/ 程序员/ 期望/ 的/ 互斥/ 关系/ 和/ 顺序/ 关系/ ./ CFix/ 能/ 在/ 不/ 引入/ 死锁/ 缺陷/ 的/ 情况/ 下/ ,/ 修复/ 所有/ 非/ 死锁/ 并发/ 缺陷/ ./ 但/ 其/ 缺点/ 是/ 只能/ 离线/ 规避/ 并发/ 缺陷/ ./ Loom/ 则/ 能/ 在线/ 规避/ 数据/ 竞争/ ./ 在/ 某个/ 数据/ 竞争/ 发生/ 后/ ,/ Loom/ 允许/ 用户/ 在线/ 添加/ 一个/ “/ 执行/ 过滤/ ”/ ,/ 在/ 其中/ 指出/ 正确/ 的/ 执行/ 交错/ 顺序/ ,/ 以/ 避免/ 此/ 数据/ 竞争/ 再次发生/ ./ Loom/ 使用/ 互斥/ 锁/ 和/ 信号量/ 来/ 实施/ “/ 执行/ 过滤/ ”/ ,/ 提供/ 即时/ 的/ 竞争/ 规避/ 功能/ ./ 其/ 缺点/ 是/ 不能/ 完全/ 规避/ 数据/ 竞争/ ,/ 并且/ 引入/ 死锁/ 的/ 风险/ 较/ 高/ ./ 6/ 原子/ 性/ 违背/ 检测/ 与/ 规避/ 并发程序/ 中/ 没有/ 数据/ 竞争/ ,/ 并/ 不/ 意味着/ 其中/ 没有/ 原子/ 性/ 违背/ [/ 7/ ]/ ./ 对/ 并发程序/ 来说/ ,/ 原子/ 性是/ 比/ 免于/ 数据/ 竞争/ 更强/ 的/ 正确性/ 保证/ [/ 91/ ]/ ./ 本节/ 讨论/ 原子/ 性/ 违背/ 的/ 检测/ 与/ 规避/ ./ 6.1/ 原子/ 性/ 违背/ 检测/ 原子/ 性/ 违背/ 一般/ 分为/ 单/ 变量/ 原子/ 性/ 违背/ 和/ 多/ 变量/ 原子/ 性/ 违背/ 两类/ [/ 92/ -/ 94/ ]/ ,/ 目前/ 针对/ 前者/ 的/ 检测/ 研究/ 较/ 多/ ./ 检测/ 原子/ 性/ 违背/ 的/ 关键在于/ :/ 确定/ 原子/ 性/ 区域/ 和/ 检查/ 原子/ 性/ 区域/ 是否/ 得到/ 原子/ 性/ 执行/ ./ 确定/ 原子/ 性/ 区域/ 的/ 方法/ 有/ 3/ 种/ :/ (/ 1/ )/ 模式定义/ ./ 即/ 人工/ 注释/ 应/ 原子/ 性/ 执行/ 的/ 区域/ 或者/ 经验主义/ 地/ 自动/ 定义/ 原子/ 性/ 区域/ ;/ (/ 2/ )/ 统计/ 学习/ ./ 即/ 根据/ 预定/ 义/ 的/ 原子/ 性/ 区域/ 模式/ 和/ 多个/ 正确/ 执行/ 的/ 轨迹/ ,/ 自动/ 推断/ 应/ 原子/ 性/ 执行/ 的/ 区域/ ;/ (/ 3/ )/ 规则/ 提取/ ./ 即/ 提取/ 共享/ 变量/ 访问/ ,/ 组成/ 数据库/ ,/ 然后/ 从/ 数据库/ 中/ 挖掘/ 规则/ ,/ 将/ 规则/ 视为/ 原子/ 性/ 区域/ ./ 模式定义/ 和/ 统计/ 学习/ 都/ 需要/ 预先/ 定义/ 原子/ 性/ 区域/ 模式/ ,/ 而/ 规则/ 提取/ 则/ 无/ 任何/ 先验/ 知识/ 地/ 从/ 源码/ 中/ 挖掘/ 原子/ 性/ 区域/ ./ 模式定义/ 和/ 统计/ 学习/ 虽然/ 都/ 依赖/ 经验/ 知识/ ,/ 但/ 后者/ 能/ 从/ 训练/ 性/ 执行/ 中/ 学习/ 真正/ 的/ 原子/ 性/ 区域/ ,/ 因此/ 对/ 原子/ 性/ 区域/ 的/ 识别/ 效果/ 好于/ 前者/ ./ 针对/ 一个/ 原子/ 性/ 区域/ ,/ 检查/ 其/ 是否/ 得到/ 原子/ 性/ 执行/ 的/ 方法/ 有/ 5/ 种/ :/ (/ 1/ )/ 动态/ 监视/ ./ 即/ 监视/ 是否/ 有/ 不可/ 序列化/ 的/ 访问/ 交错/ 到/ 该/ 原子/ 性/ 区域/ 中/ ;/ (/ 2/ )/ 执行/ 控制/ ./ 即/ 控制线/ 程/ 调度/ 以/ 监视/ 不可/ 序列化/ 的/ 访问/ 能否/ 交错/ 到/ 该/ 原子/ 性/ 区域/ 中/ ;/ (/ 3/ )/ 轨迹/ 分析/ ./ 即/ 记录/ 程序执行/ ,/ 分析/ 执行/ 轨迹/ ,/ 检查/ 是否/ 有/ 不可/ 序列化/ 的/ 访问/ 曾/ 交错/ 到/ 该/ 原子/ 性/ 区域/ ;/ (/ 4/ )/ 执行/ 规约/ ./ 即/ 检查/ 当前/ 执行/ 交错/ 是否/ 可/ 等价/ 规约/ 为/ 这样/ 的/ 执行/ 交错/ :/ 在/ 其中/ ,/ 原子/ 性/ 区域/ 被/ 顺序/ 执行/ ;/ (/ 5/ )/ 反例/ 检测/ ./ 即/ 根据/ 被/ 提取/ 出来/ 的/ 规则/ (/ 原子/ 性/ 区域/ )/ 的/ 置信度/ 和/ 支持/ 集/ ,/ 检查/ 是否/ 有/ 不/ 支持/ 该/ 规则/ 的/ 代码段/ ./ 根据/ 如何/ 确定/ 原子/ 性/ 区域/ 和/ 如何/ 检查/ 原子/ 性/ 执行/ ,/ 图/ 11/ 对/ 现有/ 研究/ 进行/ 分类/ ,/ 并/ 从/ 人工干预/ 度/ 、/ 扩展性/ 、/ 误检率/ 、/ 漏检/ 率/ 和/ 执行/ 开销/ 5/ 个/ 维度/ 进行/ 对比/ ./ 原子/ 性/ 违背/ 的/ 检测/ 研究/ 以/ 动态分析/ 或者/ 动静/ 结合/ 分析/ 为主/ ,/ 纯/ 静态/ 的/ 研究/ 较少/ ./ “/ 统计/ 学习/ +/ 动态/ 监视/ ”/ 方法/ [/ 15/ ,/ 18/ ]/ ,/ 分析/ 并发程序/ 多次/ 正确/ 执行/ 后/ 得到/ 的/ 多个/ 执行/ 轨迹/ ,/ 离线/ 学习/ 应/ 原子/ 性/ 执行/ 的/ 代码/ 区域/ ,/ 并/ 在/ 后续/ 的/ 执行/ 中/ 在线/ 检查/ 这些/ 原子/ 性/ 区域/ 是否/ 得到/ 原子/ 性/ 执行/ ./ AVIO/ [/ 18/ ]/ 从/ 正确/ 的/ 训练/ 性/ 执行/ 中/ 学习/ “/ 访问/ 交错/ 不/ 变量/ ”/ ,/ 即/ 线程/ 内未/ 被/ 其他/ 线程/ 的/ 指令/ 交错/ 的/ 指令/ 对/ ./ 与/ AVIO/ 类似/ ,/ DefUse/ [/ 15/ ]/ 也/ 需要/ 训练/ 性/ 执行/ ,/ 并/ 从中/ 学习/ “/ 定义/ -/ 使用/ 不/ 变量/ ”/ ./ 对于/ 图/ 6/ 所示/ 的/ 原子/ 性/ 违背/ ,/ AVIO/ 能/ 检测/ (/ e/ )/ ~/ (/ h/ )/ 所有/ 4/ 种/ 类型/ ,/ 而/ DefUse/ 只能/ 检测/ (/ g/ )/ 一种/ 类型/ ./ 虽然/ DefUse/ 原子/ 性/ 违背/ 检测/ 能力/ 较弱/ ,/ 但/ 它/ 能/ 检测/ 顺序/ 违背/ ./ 该/ 方法/ 不/ 需要/ 或者/ 只/ 需要/ 很少/ 的/ 人工干预/ ,/ 扩展性/ 好/ ,/ 动态/ 监视/ 程序执行/ 并/ 检测/ 原子/ 性/ 违背/ ,/ 因此/ 误检率/ 低/ ,/ 但/ 漏检/ 率高/ ,/ 对/ 目标程序/ 的/ 执行/ 性能/ 影响/ 较大/ ./ “/ 模式定义/ +/ 动态/ 监视/ ”/ (/ 动态分析/ )/ 方法/ [/ 95/ -/ 99/ ]/ ,/ 监视/ 程序运行/ ,/ 根据/ 预先/ 定义/ 的/ 原子/ 性/ 区域/ 模式/ ,/ 在线/ 推断/ 符合/ 预定/ 义/ 模式/ 的/ 区域/ 为/ 原子/ 性/ 区域/ ,/ 使用/ 针对/ 预定/ 义/ 模式/ 的/ 专用/ 算法/ 检测/ 原子/ 性/ 违背/ ./ SVD/ [/ 95/ ]/ 将/ 一个/ 共享/ 变量/ 的/ 读/ 指令/ ,/ 以及/ 数据/ 依赖/ 和/ Page11/ 图/ 11/ 原子/ 性/ 违背/ 检测/ 研究/ 分类/ 与/ 对比/ 控制/ 依赖/ 该/ 共享/ 变量/ 的/ 指令/ ,/ 定义/ 为/ 一个/ “/ 计算/ 单元/ ”/ ,/ 然后/ 监视/ 程序执行/ ,/ 检测/ 是否/ 有/ 其他/ 线程/ 的/ 写/ 指令/ 交错/ 到/ 该/ “/ 计算/ 单元/ ”/ ./ Velodrome/ [/ 96/ ]/ 和/ Single/ -/ Track/ [/ 97/ ]/ 在线/ 将/ 程序/ 划分/ 为/ 互不/ 相交/ 的/ 多个/ 原子/ 性/ 区域/ ,/ 根据/ 指令/ 间/ 的/ hb/ 关系/ ,/ 建立/ 区域间/ 的/ 偏序/ 图/ ,/ 并/ 实时/ 检测/ 其上/ 是否/ 有环/ 存在/ ./ 如果/ 发现/ 偏序/ 图上/ 有/ 环/ 存在/ ,/ 则/ 报告/ 检测/ 到/ 的/ 原子/ 性/ 违背/ 以及/ 被/ 违背/ 的/ 原子/ 性/ 区域/ ./ CommitNode/ [/ 98/ ]/ 在线/ 监视/ 对/ 共享/ 变量/ 的/ 读写操作/ 、/ 加锁/ 解锁/ 操作/ 和/ 条件/ 控制/ 操作/ ,/ 建立/ 访问/ 树/ 和/ 访问/ 森林/ ,/ 其中/ 一棵/ 访问/ 树/ 表示/ 一个/ 原子/ 性/ 区域/ ./ CommitNode/ 检查/ 每棵/ 访问/ 树/ 是否/ 至多/ 只/ 拥有/ 一个/ “/ 提交/ 节点/ ”/ ,/ 如果/ 否/ ,/ 则/ 检测/ 到/ 一个/ 原子/ 性/ 违背/ ./ AssV/ [/ 99/ ]/ 从/ 反面/ 定义/ 原子/ 性/ 区域/ ,/ 即/ 定义/ 能够/ 导致/ 原子/ 性/ 违背/ 的/ 内存/ 访问/ 序列/ 模式/ ./ AssV/ 通过/ 动态/ 检查/ 目标程序/ 对/ 共享内存/ 的/ 访问/ 序列/ 是否/ 符合/ 预定/ 义/ 模式/ 来/ 检测/ 原子/ 性/ 违背/ ./ 该/ 方法/ 需要/ 少量/ 人工干预/ ,/ 即/ 经验主义/ 地/ 定义/ 原子/ 性/ 区域/ 的/ 模式/ ,/ 扩展性/ 较/ 好/ ./ 但/ 由于/ 动态/ 监视/ 执行/ ,/ 因此/ 其/ 具有/ 误检率/ 低/ 的/ 优点/ 和/ 漏检/ 率高/ 、/ 执行/ 开销/ 高/ 的/ 缺点/ ./ “/ 模式定义/ +/ 动态/ 监视/ ”/ (/ 动静/ 结合/ 分析/ )/ 方法/ [/ 16/ -/ 17/ ,/ 100/ -/ 101/ ]/ 通过/ 人工/ 指定/ 或者/ 静态/ 分析/ ,/ 标注/ 原子/ 性/ 区域/ 或者/ 原子/ 变量/ 集/ ,/ 然后/ 通过/ 动态/ 监视/ 检查/ 是否/ 有/ 不可/ 序列化/ 的/ 访问/ 交错/ 到/ 原子/ 性/ 区域/ 或者/ 对/ 原子/ 变量/ 集/ 的/ 多个/ 访问/ 构成/ 的/ 执行/ 交错/ 是否/ 不可/ 序列化/ ./ Kivati/ [/ 16/ -/ 17/ ]/ 静态/ 分析/ 并/ 转换/ 程序/ 源码/ ,/ 在/ 原子/ 性/ 区域/ 的/ 开始/ 和/ 结尾/ 插入/ 插桩/ 代码/ ,/ 以便/ 在/ 运行/ 时/ 检测/ 该/ 区域/ 的/ 原子/ 性/ 是否/ 被/ 违背/ ./ ColorSafe/ [/ 101/ ]/ 将/ 属于/ 同/ 一类/ 原子/ 变量/ 集/ 的/ 变量/ 着/ 上/ 相同/ 的/ 颜色/ ,/ 并/ 将/ 所有/ 对/ 变量/ 的/ 访问/ 转变/ 为/ 对/ 某/ 一种/ 颜色/ 的/ 访问/ ./ ColorSafe/ 在/ 颜色/ 层面/ 上/ ,/ 定义/ 五种/ 不可/ 序列化/ 的/ 执/ Page12/ 行/ 交错/ ,/ 据此/ 在线/ 检测/ 多/ 变量/ (/ 含单/ )/ 原子/ 性/ 违背/ ./ 该/ 方法/ 需要/ 人工/ 指定/ 或者/ 静态/ 分析/ 来/ 标注/ 原子/ 性/ 区域/ 或者/ 原子/ 变量/ 集/ ,/ 因此/ 人工干预/ 度/ 较/ 高/ ,/ 扩展性/ 较差/ ./ 同时/ 由于/ 动态/ 监视/ 执行/ ,/ 故/ 具有/ 误检率/ 低/ 的/ 优点/ 和/ 漏检/ 率高/ 、/ 执行/ 开销/ 高/ 的/ 缺点/ ./ “/ 模式定义/ +/ 执行/ 控制/ ”/ (/ 动态分析/ )/ 方法/ [/ 6/ ]/ 根据/ 预定/ 义/ 模式/ 推断/ 原子/ 性/ 区域/ ,/ 控制线/ 程/ 调度/ ,/ 检查/ 不可/ 序列化/ 访问/ 能否/ 交错/ 到/ 原子/ 性/ 区域/ 中/ ./ CTrigger/ [/ 6/ ]/ 使用/ pcr/ 技术/ 检测/ 原子/ 性/ 违背/ ,/ 然后/ 根据/ 一条/ 可能/ 触发/ 原子/ 性/ 违背/ 的/ 测试用例/ ,/ 多次/ 运行/ 目标程序/ ,/ 利用/ 随机/ 延时/ 扰动/ 影响/ 线程/ 调度/ ,/ 试图/ 增大/ 原子/ 性/ 违背/ 暴露/ (/ 检测/ )/ 的/ 概率/ ./ 该/ 方法/ 人工干预/ 度低/ ,/ 扩展性/ 良好/ ,/ 由于/ 控制线/ 程/ 调度/ 以/ 增大/ 原子/ 性/ 违背/ 的/ 暴露/ 概率/ ,/ 该/ 方法/ 的/ 漏检/ 率/ 较/ 低/ ./ “/ 模式定义/ +/ 执行/ 控制/ ”/ (/ 动静/ 结合/ 分析/ )/ 方法/ [/ 7/ ,/ 24/ ,/ 75/ ,/ 86/ ]/ 通过/ 静态/ 分析/ ,/ 经验主义/ 地/ 标注/ 原子/ 性/ 区域/ ,/ 然后/ 在/ 运行/ 时/ 控制线/ 程/ 调度/ ,/ 试图/ 使/ 原子/ 性/ 违背/ 暴露/ 出来/ ./ ConSeq/ 背/ 的/ 方式/ 与/ 检测/ 数据/ 竞争/ 类似/ (/ 5.1/ 节/ )/ ,/ 这里/ 不再/ 赘述/ ./ AtomRace/ [/ 75/ ,/ 86/ ]/ 静态/ 在/ 每个/ 共享/ 变量/ 访问/ 的/ 前后/ 插桩/ ,/ 在/ 运行/ 时/ 根据/ 插桩/ 信息/ 检测/ 原子/ 性/ 违背/ ./ 该/ 方法/ 无需/ 人工干预/ ,/ 但/ 由于/ 使用/ 静态/ 分析/ 确定/ 原子/ 性/ 区域/ ,/ 其/ 扩展性/ 一般/ ,/ 漏检/ 率低/ ,/ 同时/ 由于/ 控制线/ 程/ 调度/ ,/ 其/ 执行/ 开销/ 较大/ ./ “/ 模式定义/ +/ 执行/ 规约/ ”/ (/ 静态/ 分析/ )/ 方法/ [/ 60/ ,/ 102/ ]/ 通过/ 人工/ 注释/ 来/ 标注/ 原子/ 性/ 区域/ ,/ 静态/ 检查/ 并发程序/ 的/ 所有/ 执行/ 交错/ 是否/ 可/ 规约/ 为/ 某个/ 所有/ 原子/ 性/ 区域/ 顺序/ 执行/ 的/ 执行/ 交错/ ./ EPAJ/ [/ 60/ ]/ 和/ AJ2/ [/ 102/ ]/ 定义/ 五种/ 基本/ 的/ 原子/ 性/ 类型/ 及其/ 偏序/ 关系/ ./ 每个/ 原子/ 性/ 区域/ 根据/ 类型/ 推理/ 规则/ 被/ 赋予/ 一个/ 原子/ 性/ 类型/ ./ 如果/ 某个/ 原子/ 性/ 区域/ 的/ 类型/ 不为/ atomic/ ,/ 则/ 报告/ 该/ 区域/ 可能/ 得不到/ 原子/ 性/ 执行/ ./ 该/ 方法/ 静态/ 检查/ 原子/ 性/ ,/ 对/ 目标程序/ 的/ 性能/ 影响/ 小/ ;/ 但/ 需要/ 人工/ 注释/ ,/ 人工干预/ 度高/ ,/ 扩展性/ 差/ ;/ 由于/ 依赖/ 指向/ 分析/ 等/ 不/ 精确/ 的/ 静态/ 分析/ 技术/ ,/ 其误/ 检率/ 较/ 高/ ,/ 但/ 漏检/ 率低/ ./ “/ 模式定义/ +/ 执行/ 规约/ ”/ (/ 动静/ 结合/ 分析/ )/ 方法/ [/ 92/ ]/ 依赖/ 经验/ 知识/ ,/ 静态/ 标注/ 原子/ 性/ 区域/ ,/ 然后/ 动态/ 检查/ 当前/ 执行/ 交错/ 是否/ 可/ 规约/ 为/ 如下/ 的/ 执行/ 交错/ :/ 其中/ 的/ 原子/ 性/ 区域/ 都/ 顺序/ 执行/ ./ BlockReduction/ [/ 92/ ]/ 监视/ 程序执行/ ,/ 在线/ 进行/ 执行/ 规约/ ,/ 并/ 使用/ 动态/ 逃逸/ 分析/ 、/ hb/ 分析/ 和/ 多重/ 锁集/ 分析/ 等/ 技术/ 提高/ 静态/ 执行/ 规约/ 方法/ [/ 60/ ,/ 102/ ]/ 的/ 准确度/ 和/ 检测/ 能力/ ./ 由于/ 使用/ 锁集/ 分析/ ,/ BlockReduction/ 不仅/ 能/ 检测/ 当前/ 执行/ 交错/ 中/ 的/ 原子/ 性/ 违背/ ,/ 而且/ 能/ 预测/ 其他/ 未/ 被/ 执行/ 的/ 执行/ 交错/ 中/ 的/ 原子/ 性/ 违背/ ./ 该/ 方法/ 需要/ 静态/ 标注/ 原子/ 性/ 区域/ ,/ 人工干预/ 度/ 较/ 高/ ,/ 扩展性/ 较差/ ,/ 但/ 由于/ 能/ 预测/ 原子/ 性/ 违背/ ,/ 其/ 漏检/ 率/ 较/ 低/ ./ “/ 模式定义/ +/ 轨迹/ 分析/ ”/ 方法/ [/ 93/ -/ 94/ ,/ 103/ -/ 104/ ]/ 分析/ 多个/ 正确/ 或者/ 错误/ 执行/ 的/ 执行/ 轨迹/ ,/ 根据/ 预定/ 模式识别/ 不可/ 序列化/ 的/ 执行/ 交错/ ,/ 并/ 将/ 这些/ 执行/ 交错/ 与/ 执行/ 结果/ (/ 正确/ 或者/ 错误/ )/ 关联/ 起来/ ,/ 利用/ 错误/ 定位/ 的/ 方法/ 检测/ 导致/ 并发程序/ 执行/ 出错/ 的/ 原子/ 性/ 违背/ ./ FC/ [/ 103/ ]/ 和/ Falcon/ [/ 104/ ]/ 定义/ 5/ 种/ 不可/ 序列化/ 模式/ ,/ 据此/ 检测/ 单/ 变量/ 原子/ 性/ 违背/ ,/ 而/ Unicorn/ [/ 93/ ]/ 和/ Griffin/ [/ 94/ ]/ 定义/ 14/ 种/ 不可/ 序列化/ 模式/ ,/ 能/ 检测/ 双/ (/ 和/ 单/ )/ 变量/ 原子/ 性/ 违背/ ./ 该/ 方法/ 无需/ 人工干预/ ,/ 扩展性/ 良好/ ;/ 由于/ 通过/ 分析/ 执行/ 轨迹/ 检测/ 原子/ 性/ 违背/ ,/ 其误/ 检率/ 低/ ,/ 漏检/ 率高/ ;/ 且/ 由于/ 监视/ 程序运行/ 以/ 生成/ 执行/ 轨迹/ ,/ 其/ 执行/ 开销/ 大/ ./ “/ 规则/ 提取/ +/ 反例/ 检测/ ”/ 方法/ [/ 105/ ]/ 使用/ 数据挖掘/ 静态/ 挖掘/ 规则/ (/ 即/ 原子/ 性/ 区域/ )/ ,/ 然后/ 根据/ 规则/ 的/ 置信度/ 和/ 支持/ 集/ ,/ 检查/ 是否/ 有/ 违反/ 该/ 规则/ 的/ 代码段/ ./ MUVI/ [/ 105/ ]/ 从/ 程序/ 源码/ 中/ 挖掘/ “/ 多/ 变量/ 访问/ 关联/ ”/ 规则/ ./ 这些/ 规则/ 表示/ 多个/ 变量/ 应该/ 被/ 一致性/ 更新/ 和/ 读取/ ./ 通过/ 检查/ 那些/ 置信度/ 不为/ 1/ 的/ 关联/ 规则/ ,/ MUVI/ 检测/ 违反/ 关联/ 规则/ 的/ 反例/ ,/ 它们/ 所/ 对应/ 的/ 程序/ 片段/ 即/ 为/ 原子/ 性/ 违背/ ./ 该/ 方法/ 不/ 需要/ 人工干预/ ,/ 扩展性/ 好/ ;/ 但/ 由于/ 数据挖掘/ 结果/ 的/ 偶然/ 相关性/ ,/ 被/ 挖掘/ 出来/ 的/ 规则/ 可能/ 并/ 不/ 表示/ 一个/ 原子/ 性/ 区域/ ,/ 与/ 此/ 规则/ 相关/ 的/ 原子/ 性/ 违背/ 都/ 是/ 误检/ ,/ 因此/ 该/ 方法/ 误检率/ 高/ ;/ 同时/ 由于/ 只/ 考虑/ 检测/ 违反/ “/ 多/ 变量/ 访问/ 关联/ ”/ 规则/ 的/ 原子/ 性/ 违背/ ,/ 该/ 方法/ 漏检/ 率高/ ./ 6.2/ 原子/ 性/ 违背/ 规避/ 原子/ 性/ 违背/ 的/ 规避/ 研究/ 根据/ 规避/ 措施/ 分成/ 3/ 类/ :/ 控制线/ 程/ 调度/ [/ 16/ -/ 17/ ,/ 75/ ,/ 86/ -/ 87/ ,/ 91/ ,/ 106/ ]/ ,/ 添加/ 同步/ 设施/ [/ 75/ ,/ 86/ ,/ 88/ -/ 89/ ,/ 107/ -/ 109/ ]/ 或者/ 实施/ 事务/ 内存/ [/ 57/ ,/ 101/ ,/ 110/ -/ 111/ ]/ ./ 控制线/ 程/ 调度/ 可能/ 造成/ 活锁/ ,/ 而/ 添加/ 同步/ 设施/ 和/ 实施/ 事务/ 内存/ 则/ 可能/ 导致/ 死锁/ ./ 我们/ 从/ 规避/ 开销/ 和/ 规避/ 能力/ 两/ 方面/ 评价/ 这/ 3/ 类/ 措施/ ./ 第/ 1/ 类/ 措施/ 控制线/ 程/ 调度/ 以/ 使得/ 不可/ 序列化/ 的/ 访问/ 在/ 原子/ 性/ 区域/ 之外/ 执行/ ./ Kivati/ [/ 16/ -/ 17/ ]/ 借助/ 处理器/ 硬件/ 的/ 帮助/ ,/ 消除/ 交错/ 到/ 原子/ 性/ 区域/ 中/ 的/ 远程/ 指令/ 的/ 影响/ ,/ 重新排列/ 本地/ 指令/ 和/ 远程/ 指令/ 的/ 执行/ ,/ 实现/ 对/ 原子/ 性/ 违背/ 的/ 在线/ 规避/ ./ AtomRace/ [/ 75/ ,/ 86/ ]/ 在/ 不可/ 序列化/ 访问/ 即将/ 发生/ 时/ 插入/ 随机/ 延时/ ,/ 以/ 降低/ 其/ 交错/ 到/ 原子/ 性/ 区域/ 的/ 概率/ ./ PSet/ [/ 87/ ]/ 根据/ 指令/ 的/ 前驱/ Page13/ 集/ 调度/ 线程/ ,/ 只/ 允许/ 前驱/ 集中/ 的/ 指令/ 在/ 本/ 指令/ 之前/ 执行/ ./ AtomAid/ [/ 91/ ]/ 和/ BulkSC/ [/ 106/ ]/ 将/ 所有/ 被/ 执行/ 的/ 指令/ 划分/ 为/ 指令/ 块/ ,/ 线程/ 调度/ 以/ 指令/ 块/ 为/ 单位/ 进行/ ./ 如果/ 某一/ 原子/ 性/ 区域/ 落/ 在/ 某/ 一/ 指令/ 块/ 内/ ,/ 则/ 其/ 一定/ 会/ 被/ 原子/ 性/ 执行/ ./ 该类/ 措施/ 直接/ 控制/ 或者/ 间接/ 影响/ 线程/ 调度/ ,/ 规避/ 开销/ 较大/ ./ 如果/ 间接/ 影响/ 线程/ 调度/ ,/ 则/ 其/ 只能/ 降低/ 原子/ 性/ 违背/ 的/ 发生/ 概率/ ,/ 而/ 不能/ 完全/ 规避/ 原子/ 性/ 违背/ ./ 第/ 2/ 类/ 措施/ 为/ 原子/ 性/ 区域/ 添加/ 锁/ 等/ 同步/ 设施/ ,/ 使/ 有/ 可能/ 冲突/ 的/ 原子/ 性/ 区域/ 互斥/ 执行/ ./ AtomRace/ [/ 75/ ,/ 86/ ]/ 在线/ 检测/ 原子/ 性/ 违背/ ,/ 并/ 为/ 原子/ 性/ 违背/ 涉及/ 到/ 的/ 原子/ 性/ 区域/ 添加/ 锁/ 保护/ ,/ 这样/ 原子/ 性/ 违背/ 一旦/ 被/ 检测/ 到/ 就/ 会/ 在/ 后续/ 的/ 执行/ 中/ 被/ 规避/ 掉/ ./ JAS/ [/ 107/ ]/ 根据/ “/ 原子/ 变量/ 集/ ”/ 注释/ ,/ 使用/ 静态/ 分析/ ,/ 为/ 读取/ 和/ 更新/ “/ 原子/ 变量/ 集/ ”/ 中/ 的/ 变量/ 的/ 操作/ 加上/ 一致性/ 锁/ 保护/ ./ CFix/ [/ 88/ -/ 89/ ]/ 和/ Axis/ [/ 108/ ]/ 以/ 其他/ 原子/ 性/ 违背/ 检测工具/ (/ 如/ CTrigger/ [/ 6/ ]/ )/ 的/ 检测/ 结果/ 为/ 输入/ ,/ 静态/ 分析/ 源码/ ,/ 为/ 被/ 违背/ 的/ 原子/ 性/ 区域/ 添加/ 锁/ 保护/ ./ Autolocker/ [/ 109/ ]/ 与/ JAS/ 类似/ ,/ 不过/ 前者/ 允许/ 用户/ 指定/ 原子/ 性/ 区域/ ,/ 因而/ 支持/ 细粒度/ 的/ 原子/ 执行/ ./ 该类/ 措施/ 通常/ 通过/ 分析程序/ 源码/ 为/ 原子/ 性/ 区域/ 添加/ 锁/ 保护/ ,/ 能/ 在/ 编译/ 阶段/ 规避/ 原子/ 性/ 违背/ ,/ 对/ 目标程序/ 的/ 性能/ 影响/ 小/ ,/ 故/ 规避/ 开销/ 小/ ,/ 但/ 其/ 规避/ 能力/ 受限于/ 用户/ 注释/ 或者/ 其他/ 检测工具/ 的/ 输出/ ./ 第/ 3/ 类/ 措施/ 将/ 原子/ 性/ 区域/ 置于/ 事务/ 中/ 执行/ ./ Grace/ [/ 57/ ]/ 使用/ 5.2/ 节/ 的/ 方法/ 规避/ 原子/ 性/ 违背/ ./ Color/ -/ Safe/ [/ 101/ ]/ 能/ 在/ 某次/ 没有/ 发生/ 原子/ 性/ 违背/ 的/ 执行/ 中/ 预测/ 可能/ 发生/ 的/ 原子/ 性/ 违背/ ,/ 并/ 监视/ 与此相关/ 的/ 多个/ 变量/ ,/ 在/ 后续/ 执行/ 中/ 一旦/ 发现/ 对/ 这些/ 变量/ 的/ 访问/ ,/ 就/ 自动/ 添加/ 瞬时/ 事务/ 内存/ ,/ 使得/ 这些/ 访问/ 在/ 事务/ 内存/ 的/ 保护/ 中/ 进行/ ,/ 从而/ 动态/ 规避/ 原子/ 性/ 违背/ ./ 事务/ 内存/ 乐观/ 地/ 看待/ 并发程序/ 的/ 执行/ ,/ 认为/ 事务/ 之间/ 发生冲突/ 的/ 可能性/ 很/ 低/ ,/ 如果/ 发生冲突/ ,/ 就/ 提交/ 先/ 执行/ 的/ 那个/ 事务/ ,/ 重新/ 执行/ 另/ 一个/ 事务/ ./ 因此/ ,/ 第/ 3/ 类/ 措施/ 对/ 目标程序/ 的/ 执行/ 影响/ 小且/ 规避/ 能力/ 强/ ./ 7/ 研究/ 展望/ 在/ 当前/ 多核/ 架构/ 充分/ 普及/ 的/ 硬/ 并发/ 时代/ ,/ 并发程序/ 设计/ 已经/ 成为/ 软件开发/ 行业/ 的/ 主流/ ./ 可以/ 预见/ ,/ 今后/ 导致/ 软件/ 不能/ 正常/ 工作/ 的/ 缺陷/ 将/ 不再/ 是/ 传统/ 结构化程序/ 设计/ 中/ 的/ bug/ ,/ 而/ 主要/ 是/ 并发程序/ 设计/ 中/ 的/ cug/ (/ concurrencybug/ )/ ./ 目前/ ,/ 针对/ 并发/ 缺陷/ 的/ 暴露/ 、/ 检测/ 和/ 规避/ 研究/ 正/ 方兴未艾/ ,/ 我们/ 预计/ 在/ 今后/ 一段时间/ 内/ ,/ 研究/ 工作/ 的/ 重点/ 将/ 集中/ 在/ 以下/ 几个/ 方面/ :/ (/ 1/ )/ 智能/ 快速/ 的/ 缺陷/ 暴露/ ./ 当前/ 的/ 缺陷/ 暴露/ 技术/ 要么/ 盲目/ 控制线/ 程/ 调度/ ,/ 不能/ 保证/ 一定/ 触发/ 并发/ 缺陷/ ;/ 要么/ 依赖/ 其他/ 检测工具/ 的/ 输出/ 作为/ 输入/ ,/ 限制/ 了/ 自身/ 的/ 暴露/ 能力/ ./ 将来/ 的/ 缺陷/ 暴露/ 技术/ 应/ 不/ 依赖于/ 外界/ 输入/ ,/ 而是/ 根据/ 经验/ 知识/ 有意识/ 地/ 调度/ 线程/ ,/ 快速/ 定位/ 到/ 那些/ 包含/ 并发/ 缺陷/ 的/ 执行/ 交错/ ./ (/ 2/ )/ 通用/ 准确/ 的/ 缺陷/ 检测/ ./ 当前/ 的/ 缺陷/ 检测/ 研究/ 的/ 通用性/ 较差/ ,/ 大多数/ 只能/ 检测/ 一种/ 并发/ 缺陷/ ,/ 少数/ 研究/ (/ 如/ ConMem/ [/ 24/ ]/ 、/ ConSeq/ 能/ 检测/ 多种/ ,/ 但/ 却/ 不能/ 检测/ 所有/ 并发/ 缺陷/ ./ 这/ 就/ 导致/ 测试人员/ 不得不/ 使用/ 多种/ 工具/ 对/ 同一/ 软件/ 进行/ 缺陷/ 检测/ ./ 另/ 一个/ 问题/ 是/ 误检率/ 或者/ 漏检/ 率/ 偏高/ ,/ 基于/ 静态/ 分析/ 的/ 检测/ 技术/ 误检率/ 高/ ,/ 而/ 基于/ 动态分析/ 和/ 动静/ 结合/ 分析/ 的/ 检测/ 技术/ 漏检/ 率高/ ./ 将来/ 的/ 缺陷/ 检测/ 方案/ 应/ 能/ 检测/ 所有/ 并发/ 缺陷/ ,/ 同时/ 具有/ 较/ 低/ 的/ 误检率/ 和/ 漏检/ 率/ ./ (/ 3/ )/ 确定性/ 重/ 放/ 支持/ ./ 并发程序/ 执行/ 的/ 不确定性/ 导致/ 并发程序/ 的/ 执行/ 交错/ 数量/ 巨大/ ,/ 并发/ 缺陷/ 不/ 容易/ 暴露/ 和/ 检测/ ./ 目前/ 基于/ 动态分析/ 的/ 并发/ 缺陷/ 暴露/ 和/ 检测/ 技术/ 对/ 执行/ 交错/ 敏感/ ,/ 即/ 如果/ 在/ 当前/ 执行/ 交错/ 暴露/ 和/ 检测/ 到/ 某个/ 并发/ 缺陷/ ,/ 则/ 下次/ 执行/ 交错/ 中/ 几乎/ 不/ 可能/ 再次/ 暴露/ 和/ 检测/ 到/ 该/ 并发/ 缺陷/ ./ 这/ 就/ 大大降低/ 了/ 暴露/ 和/ 检测/ 技术/ 的/ 有效性/ ,/ 增加/ 了/ 并发/ 缺陷/ 调试/ 的/ 难度/ ./ 确定性/ 重放能/ 使/ 并发程序/ 的/ 某次/ 执行/ 具有/ 可重复性/ ,/ 从而/ 并发/ 缺陷/ 在/ 新/ 的/ 执行/ 中/ 仍然/ 能/ 被/ 暴露/ 和/ 检测/ 出来/ ./ 将来/ 的/ 缺陷/ 暴露/ 和/ 检测/ 技术/ 应/ 具有/ 确定性/ 重/ 放/ 支持/ ./ (/ 4/ )/ 软硬件/ 协同/ ./ 基于/ 动态分析/ 的/ 并发/ 缺陷/ 检测/ 和/ 规避/ 技术/ ,/ 如果/ 以纯/ 软件/ 方法/ 实现/ 则/ 对/ 现有/ 的/ 硬件平台/ 没有/ 特别/ 的/ 要求/ ,/ 因而/ 有/ 较/ 强/ 的/ 适用性/ ./ 但/ 在/ 软件/ 层面/ 监视/ 运行/ 并/ 实施/ 检测/ 和/ 轨迹/ 技术/ 会/ 严重/ 降低/ 并发程序/ 的/ 执行/ 速度/ ./ 为/ 降低/ 执行/ 开销/ ,/ 部分/ 研究/ 使用/ 纯/ 硬件/ 的/ 方式/ 检测/ 和/ 规避/ 并发/ 缺陷/ ,/ 如/ HW/ -/ IF/ [/ 84/ ]/ 和/ RaceSMM/ [/ 82/ ]/ 添加/ 新/ 硬件/ 以/ 高效/ 检测/ 和/ 规避/ 数据/ 竞争/ ,/ AVIO/ -/ H/ [/ 18/ ]/ 修改/ 缓存/ 一致性/ 协议/ 来/ 检测/ 原子/ 性/ 违背/ ./ 有/ 硬件/ 支持/ 的/ 检测/ 和/ 规避/ 方案/ 需要/ 修改/ 当前/ 体系/ 架构/ ,/ 可用性/ 较差/ ./ 另外/ ,/ 基于/ 硬件/ 的/ 解决方案/ 针对/ 不同/ 种类/ 的/ 并发/ 缺陷/ 需要/ 开发/ 设计/ 不同/ 的/ 硬件/ 和/ 缓存/ 协议/ ,/ 缺乏/ 通用性/ ./ 将来/ 的/ 并发/ 缺陷/ 检测/ 和/ 规避/ 研究/ 应/ 提出/ 一种/ 软硬/ 结合/ 的/ 解决方案/ ,/ 设计/ 通用/ 的/ 硬件/ 体系结构/ 以/ 支持/ 多种/ 并发/ 缺陷/ Page14/ 的/ 检测/ 和/ 规避/ ,/ 将/ 检测/ 和/ 规避/ 功能/ 合理/ 划分/ 到/ 软件/ 和/ 硬件/ 中/ ,/ 以/ 充分利用/ 各自/ 的/ 优势/ ./ (/ 5/ )/ 新/ 的/ 并发/ 编程/ 模型/ ./ 现有/ 并发/ 编程/ 模型/ 为/ 实现/ 计算/ 任务/ 的/ 并发/ // 并行/ 化/ ,/ 既/ 需要/ 程序员/ 划分/ 任务/ 的/ 输入/ 数据/ 集/ ,/ 又/ 需要/ 程序员/ 熟悉/ 底层/ 的/ 同步/ 设施/ 和/ 实现/ 应用/ 层面/ 的/ 同步/ 机制/ ./ 这/ 就/ 导致/ 在/ 现有/ 模型/ 下/ ,/ 并发/ 缺陷/ 几乎/ 不/ 可能/ 得到/ 完全彻底/ 的/ 解决/ ./ 为/ 彻底消除/ 并发/ 缺陷/ ,/ 人们/ 已/ 尝试/ 新/ 的/ 并发/ 编程/ 模型/ ,/ 如/ MapReduce/ [/ 112/ -/ 115/ ]/ 系列/ ./ MapReduce/ ,/ 特别/ 是/ Phoenix/ [/ 114/ ]/ ,/ 为/ 从根本上/ 消除/ 并发/ 缺陷/ 提供/ 了/ 一种/ 思路/ ,/ 但/ 并/ 不是/ 万能/ 药/ ./ MapReduce/ 需要/ 程序员/ 将/ 待处理/ 的/ 数据/ 集/ 划分/ 成/ 多个/ 独立/ 的/ 数据/ 块/ ,/ 然而/ 有些/ 计算/ 任务/ (/ 如/ LU/ 分解/ )/ 的/ 数据/ 集中/ 元素/ 相互/ 关联/ ,/ 无法/ 划分/ 成/ 独立/ 的/ 数据/ 块/ ./ 另外/ ,/ MapReduce/ 不/ 适合/ 规模较/ 小/ 的/ 计算/ 任务/ ,/ 并且/ 对于/ 输入/ 数据/ 集是/ 随/ 时间/ 变化/ 的/ 计算/ 任务/ (/ 如/ 在线视频/ 解析/ ,/ 其/ 输入/ 是/ 流式/ 数据/ )/ ,/ MapReduce/ 也/ 不/ 适用/ ./ 将来/ 的/ 并发/ 编程/ 模型/ 应/ 借鉴/ MapReduce/ 的/ 基本原理/ ,/ 同时/ 克服/ 其/ 缺点/ ,/ 即/ 允许/ 数据/ 块/ 之间/ 存在/ 关联/ ,/ 能/ 处理/ 各种/ 规模/ 的/ 计算/ 任务/ ,/ 允许/ 计算/ 任务/ 的/ 输入/ 数据/ 集是/ 流式/ 数据/ ./ 8/ 总结/ 本文/ 综述/ 了/ 近/ 10/ 年来/ 共享内存/ 系统/ 中/ 并发/ 缺陷/ 的/ 暴露/ 、/ 检测/ 与/ 规避/ 机制/ 与/ 策略/ ./ 我们/ 首先/ 指出/ 软件开发/ 必须/ 从/ 顺序/ 设计模式/ 转向/ 并发/ 设计模式/ ,/ 然后/ 讨论/ 并发程序/ 的/ 特点/ 以及/ 由此/ 导致/ 的/ 并发/ 缺陷/ 为何/ 难以/ 暴露/ 、/ 检测/ 与/ 修复/ 的/ 问题/ ./ 本文/ 将/ 常见/ 并发/ 缺陷/ 分成/ 四大/ 类/ ,/ 逐类/ 给出/ 定义/ 和/ 示例/ ,/ 讨论/ 4/ 类/ 并发/ 缺陷/ 相互之间/ 的/ 关系/ ,/ 并/ 就/ 如何/ 快速/ 暴露/ 、/ 及时/ 检测/ 和/ 在线/ 规避/ 这/ 4/ 类/ 并发/ 缺陷/ 对/ 已有/ 研究/ 作出/ 分析/ 、/ 比较/ 和/ 归纳/ ./ 最后/ 从/ 5/ 个/ 方面/ 展望/ 了/ 未来/ 的/ 研究/ 重点/ ./ 

