Page1COStream/ :/ 一种/ 面向/ 数据流/ 的/ 编程语言/ 和/ 编译器/ 实现/ 张/ 维维/ 1/ )/ 魏/ 海涛/ 1/ )/ 于俊清/ 1/ )/ ,/ 2/ )/ 李鹤/ 1/ )/ 黎昊/ 1/ )/ 杨秋吉/ 1/ )/ 1/ )/ (/ 华中科技大学/ 计算机科学/ 与/ 技术/ 学院/ 武汉/ 430074/ )/ 2/ )/ (/ 华中科技大学/ 网络/ 与/ 计算中心/ 武汉/ 430074/ )/ 摘要/ 数据流/ 编程/ 模型/ 作为/ 高效/ 的/ 并行/ 编程/ 模型/ 被/ 广泛应用/ 于/ 媒体/ 处理/ 和/ 网络服务/ 等/ 应用/ 中/ ./ 然而/ ,/ 多/ // 众核/ 结构/ 的/ 底层/ 计算/ 、/ 存储/ 和/ 通信/ 的/ 复杂性/ 对/ 数据流/ 程序/ 的/ 性能/ 提出/ 了/ 新/ 的/ 挑战/ ,/ 数据流/ 程序/ 在/ 不同/ 的/ 多/ // 众核/ 结构/ 上/ 的/ 可移植性/ 和/ 可编程/ 性/ 也/ 为/ 编译器/ 提出/ 了/ 更/ 高/ 的/ 要求/ ./ 针对/ 数据流/ 程序/ 所/ 面临/ 的/ 问题/ ,/ 提出/ 并/ 设计/ 实现/ 一种/ 数据流/ 编程/ 模型/ —/ —/ —/ COStream/ 数据流/ 编程语言/ 及其/ 编译系统/ ,/ 提高/ 了/ 数据流/ 程序/ 的/ 可编程/ 性/ ./ COStream/ 在/ C语言/ 文法/ 的/ 基础/ 上/ 加入/ 表征/ 数据流/ 图/ 的/ 文法/ 结构/ ,/ 文法/ 结构/ 清晰/ ,/ 具有/ 良好/ 的/ 可/ 重用/ 性/ 和/ 可扩展性/ ./ COStream/ 编译系统/ 利用/ 同步/ 数据流/ 图/ 作为/ 中间/ 表示/ ,/ 根据/ 目标/ 系统/ 的/ 结构/ 特点/ 对/ 数据流/ 程序/ 进行/ 并行/ 优化/ 并/ 构造/ 流水线/ 调度/ ,/ 进而/ 生成/ 高效/ 的/ 可/ 并行执行/ 的/ 目标/ 代码/ ./ 在/ X86/ 多核/ 架构/ 下/ 实现/ 了/ COStream/ 编译系统/ ,/ 并/ 对/ 该/ 领域/ 的/ 多个/ 实验/ 程序/ 进行/ 了/ 测试/ ,/ 测试/ 结果表明/ ,/ COStream/ 具有/ 良好/ 的/ 可扩展性/ 和/ 高/ 加速/ 比/ ./ 关键词/ 多核/ 处理器/ ;/ 数据流/ ;/ 编译/ ;/ COStream1/ 引言/ 随着/ 半导体技术/ 的/ 发展/ ,/ 多/ // 众核/ 平台/ 作为/ 新/ 的/ 计算/ 平台/ ,/ 为/ 各类/ 应用/ 提供/ 了/ 强大/ 的/ 并行计算/ 能力/ ,/ 但/ 它/ 也/ 将/ 如何/ 充分/ 挖掘/ 程序/ 的/ 并行性/ 以及/ 如何/ 充分利用/ 资源/ 等/ 问题/ 暴露/ 给/ 了/ 编程人员/ ./ C/ 、/ C++/ 和/ Fortran/ 等/ 传统/ 的/ 编程/ 模型/ ,/ 主要/ 对应/ 的/ 是/ 单/ 指令流/ 和/ 传统/ 集中式/ 内存/ 管理模式/ ,/ 无法/ 很/ 好/ 地/ 适合/ 这种/ 新型/ 的/ 并行/ 平台/ 结构/ ./ 当前/ 比较/ 流行/ 的/ 编程/ 模型/ ,/ 如/ OpenMP/ 和/ MPI/ ,/ 虽然/ 显式/ 地/ 提供/ 了/ 访问/ 底层/ 资源/ 的/ 接口/ ,/ 但/ 要求/ 编程人员/ 必须/ 熟悉/ 平台/ 系统/ 底层/ 结构/ ,/ 设计/ 并行程序/ 时/ 需要/ 根据/ 系统/ 底层/ 结构/ 进行/ 精心/ 的/ 任务/ 划分/ 、/ 数据通信/ 以及/ 同步/ 设计/ ,/ 导致/ 了/ 程序/ 性能/ 受制于/ 编程人员/ 并行算法/ 的/ 设计/ 和/ 对/ 并行/ 系统/ 的/ 理解/ ,/ 极大/ 地/ 增加/ 了/ 编程人员/ ,/ 尤其/ 是/ 各个/ 应用领域/ 编程人员/ 的/ 编程/ 负担/ ./ 为此/ ,/ 数据流/ 编程/ 模型/ 作为/ 新/ 的/ 高效/ 的/ 并行/ 编程/ 模型/ 被/ 提出/ 来/ ./ 目前/ ,/ 支持/ 流/ 应用/ 的/ 计算/ 平台/ 主要/ 有片/ 内/ 多处理机/ Raw/ [/ 1/ ]/ 、/ 片上/ 众核/ 处理器/ Godson/ -/ T/ [/ 2/ ]/ 、/ SIMD/ 流/ 处理器/ Merrimac/ [/ 3/ ]/ 和/ CELL/ [/ 4/ ]/ 等/ ./ 主要/ 的/ 支持/ 流/ 编程/ 的/ 流/ 语言/ 有/ Streamit/ [/ 5/ ]/ 、/ Brook/ [/ 6/ ]/ 、/ Cg/ [/ 7/ ]/ 和/ DFBrook/ [/ 8/ ]/ ./ 这些/ 流/ 编程语言/ 一般/ 是/ 针对/ 特定/ 平台/ 系统/ 开发/ 的/ ,/ 尽管/ 它们/ 能够/ 充分利用/ 特定/ 平台/ 的/ 底层/ 硬件资源/ ,/ 但是/ 用/ 这些/ 流/ 语言/ 编写/ 的/ 程序/ 在/ 可移植/ 、/ 可扩展性/ 以及/ 跨平台/ 使用/ 上/ 存在/ 一定/ 的/ 局限性/ ,/ 如/ Brook/ 是/ 在/ Merrimac/ 上/ 开发/ 的/ ,/ 而/ StreamIt/ 是/ 针对/ Raw/ 开发/ 的/ ./ 为此/ ,/ 针对/ 多/ // 众核/ 平台/ 上/ 并行/ 编程/ 困难/ 、/ 资源/ 利用率/ 低等/ 问题/ ,/ 结合/ 大规模/ 数据/ 计算/ 等/ 计算/ 密集型/ 应用/ ,/ 以/ 实际/ 应用程序/ 为/ 驱动/ ,/ 开展/ 面向/ 多/ // 众核/ 平台/ 的/ 编程语言/ 、/ 编程/ 模型/ 及/ 相关/ 编译/ 支持/ 技术/ 的/ 研究/ ,/ 具有/ 重要/ 的/ 理论/ 研究/ 和/ 实际/ 应用/ 价值/ ./ 本文/ 基于/ 多核/ 与/ 分布式系统/ 结构/ 的/ 特点/ 以及/ 数据流/ 编程/ 模型/ ,/ 设计/ 并/ 实现/ 了/ COStream/ 数据流/ 编程语言/ 及其/ 编译系统/ ./ COStream/ 数据流/ 编程语言/ 是/ 对/ C语言/ 做/ 数据流/ 扩展/ ,/ 语言/ 文法/ 是/ 在/ C语言/ 的/ 基础/ 上/ 结合/ 数据流/ 编程/ 模型/ 而/ 设计/ 的/ ,/ 它/ 能够/ 屏蔽/ 目标/ 底层/ 系统/ 的/ 细节/ ,/ 提高/ 了/ 编程人员/ 编程/ 效率/ ,/ 同时/ 针对/ 不同/ 的/ 多/ // 众核/ 平台/ 系统/ 均/ 具有/ 良好/ 的/ 可移植性/ ./ 另外/ ,/ COStream/ 编译系统/ 能够/ 针对/ 并行/ 系统/ 的/ 底层/ 特点/ 做/ 编译/ 优化/ ,/ 提高/ 数据流/ 程序/ 在/ 特定/ 平台/ 上/ 的/ 执行/ 效率/ ./ COStream/ 编译系统/ 主要/ 有/ 3/ 个/ 组成部分/ :/ 前端/ 语言/ 编译/ 模块/ 、/ 针对/ 不同/ 底层/ 架构/ 的/ 编译/ 优化/ 模块/ 和/ 目标/ 代码生成/ 模块/ ./ 本文/ 的/ 主要/ 贡献/ 有/ 以下/ 3/ 点/ :/ (/ 1/ )/ 设计/ 并/ 实现/ 了/ 数据流/ 编程语言/ COStream/ 及/ 相应/ 的/ 编译器/ 框架/ ;/ (/ 2/ )/ 针对/ 共享/ 存储/ 架构/ 和/ 数据流/ 程序/ 的/ 特点/ 提出/ 基于/ 共享/ 存储/ 的/ 多/ 核/ 架构/ 的/ 编译/ 优化/ 框架/ ;/ (/ 3/ )/ 在/ X86/ 架构/ 上/ 实现/ 了/ 该/ 编译器/ 框架/ 和/ 后/ 端/ 优化/ 框架/ ,/ 通过/ 实验/ 验证/ 了/ 框架/ 的/ 有效性/ ./ 本文/ 第/ 2/ 节/ 介绍/ COStream/ 数据流/ 编程语言/ ;/ 第/ 3/ 节/ 讨论/ COStream/ 编译器/ 的/ 设计/ 架构/ ;/ 第/ 4/ 节/ 介绍/ 针对/ X86/ 共享/ 存储/ 的/ 多/ 核/ 架构/ 的/ 编译/ 优化/ 框架/ ;/ 第/ 5/ 节/ 介绍/ 在/ X86/ 架构/ 下/ 的/ 实验/ 方法/ 和/ 结果/ ;/ 第/ 6/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 7/ 节对/ 全文/ 进行/ 总结/ ./ 2COStream/ 数据流/ 编程语言/ 2.1/ 数据流/ 编程/ 模型/ 数据流/ 编程语言/ (/ DataFlowProgrammingLanguage/ )/ [/ 1/ ]/ 是/ 一种/ 面向/ 领域/ 的/ 编程语言/ (/ DomainSpecificLanguage/ ,/ DSL/ )/ [/ 9/ ]/ ,/ 以/ 数据/ 为/ 中心/ ,/ 通过/ 将/ 应用领域/ 中/ 功能/ 独立/ 和/ 数据/ 驱动/ 等/ 特性/ 与/ 程序语言/ 设计/ 相结合/ ,/ 采用/ 数据/ 驱动/ 的/ 执行/ 方式/ ,/ 将/ 计算/ 和/ 通信/ 分离/ ,/ 暴露/ 程序/ 本身/ 固有/ 的/ 结构/ 特点/ ,/ 简化/ 编程/ ,/ 被/ 广泛/ 用于/ 数字/ 媒体/ 处理/ 和/ 网络服务/ 等/ 应用领域/ ./ 使用/ 数据流/ 编程/ 模型/ 时/ ,/ 编程人员/ 无需/ 对/ 底层/ 系统/ 有/ 很/ 详细/ 的/ 了解/ ,/ 只/ 需要/ 按照/ 领域/ 应用/ 问题/ 本身/ 的/ 数据/ 流程/ 特点/ 进行/ 编程/ ,/ 简化/ 了/ 领域/ 编程/ ./ 数据流/ 模型/ 分成/ 动态/ 数据流/ 模型/ 和/ 静态数据/ 流/ 模型/ ./ 数据流/ 编程/ 模型/ SWARM/ [/ 10/ ]/ 和/ DARTS/ [/ 11/ ]/ 采用/ Codelet/ [/ 10/ ]/ 动态/ 数据流/ 模型/ ,/ 对于/ 大规模/ 并行/ 系统/ 它/ 在/ 运行/ 时/ 实现/ 细粒度/ 并行/ ,/ 在/ 运行/ 时/ 确定/ 数据/ 依赖/ 和/ 任务调度/ ./ 但/ 在/ 信号处理/ 领域/ ,/ 静态数据/ 流/ 特别/ 是/ 同步/ 数据流/ 模型/ (/ SynchronousDataFlow/ ,/ SDF/ )/ [/ 12/ ]/ 则/ 是/ 比较/ 理想/ 的/ 选择/ ./ 编程语言/ 是/ 底层/ 程序执行/ 模型/ 的/ 体现/ ./ COStream/ 采用/ SDF/ 作为/ 语言/ 的/ 执行/ 模型/ ./ 在/ SDF/ 中/ ,/ 程序/ 由/ 一个/ SDF/ 图/ 表示/ ,/ SDF/ 图中/ 每个/ 结点/ 代表/ 一个/ 计算/ 任务/ ,/ 称为/ actor/ ,/ 边/ 代表/ 了/ 生产者/ actor/ 与/ 消费者/ actor/ 之间/ 的/ 数据/ 流动/ ,/ 每条/ 边上/ 具有/ 两个/ 权值/ ,/ 分别/ 代表/ 生产者/ 每次/ 执行/ 生产/ 数据/ 的/ 个数/ (/ 称为/ 产生/ 率/ )/ 和/ 消费者/ 每次/ 执行/ 消耗/ 数据/ 的/ 个数/ (/ 称为/ 消耗率/ )/ ./ 在/ SDF/ 图中/ actor/ 有/ 独立/ 地址/ 空间/ ,/ actor/ 间/ 的/ 数据/ 流动/ 是/ 通过/ FirstInFirstOut/ (/ FIFO/ )/ 队列/ 来/ 实现/ ./ actor/ 采用/ 数据/ 驱动/ 的/ 方式/ 执行/ ,/ 只要/ actor/ 的/ 输入/ 边有/ 足够/ 的/ 数据/ ,/ actor/ 将/ 不停/ 地/ 重复/ 执行/ 并/ 产生/ 数据/ 到/ 输出/ Page3/ 边/ ./ 在/ SDF/ 模型/ 中/ ,/ actor/ 有/ 两种/ 类型/ 即/ 有/ 状态/ 的/ actor/ 和/ 无/ 状态/ 的/ actor/ ./ 一个/ 有/ 状态/ 的/ actor/ 执行/ 时/ 需要/ 根据/ 上次/ 执行/ 的/ 状态/ 来/ 决定/ 之后/ 的/ 执行/ 状态/ ,/ 而/ 一个/ 无/ 状态/ 的/ actor/ 当前/ 的/ 执行/ 与/ 上/ 一次/ 执行/ 状态/ 无关/ ./ SDF/ 模型/ 将/ 通信/ 与/ 计算/ 分离/ ,/ 为/ 编译器/ 的/ 并行/ 优化/ 提供/ 了/ 机遇/ ./ 图/ 1/ 的/ SDF/ 图中/ 有/ 2/ 个/ actor/ ,/ actorP/ 和/ actorC/ ,/ 都/ 是/ 独立/ 的/ 计算/ 单元/ ,/ actorP/ 每次/ 执行/ 向/ 缓存/ 中/ 产生/ 2/ 个/ 数据/ ,/ 即/ 生产率/ 为/ 2/ ,/ actorC/ 每次/ 执行/ 从/ 缓存/ 中/ 消耗/ 4/ 个/ 数据/ ,/ 消耗率/ 为/ 4/ ./ 两个/ actor/ 都/ 采用/ 数据/ 驱动/ 的/ 方式/ 执行/ ,/ 只要/ 数据/ 足够/ ,/ 自动/ 开始/ 执行/ ./ 2.2/ COStream/ 数据流/ 语言/ 的/ 设计/ COStream/ 编程语言/ 是/ 一种/ 面向/ 并行/ 体系结构/ 的/ 高性能/ 数据流/ 编程语言/ ,/ 语言/ 的/ 名称/ 由/ 3/ 个/ 关键字/ :/ Composite/ 、/ Operator/ 和/ Stream/ 组合/ 而来/ ./ COStream/ 程序/ 采用/ 有向图/ 来/ 描述/ 应用/ 的/ 处理过程/ ,/ 图中/ 节点/ 表示/ 计算/ ,/ 边/ 表示/ 数据/ 依赖/ ,/ 边/ 的/ 方向/ 表示/ 数据/ 流动/ 方向/ ./ COStream/ 数据流/ 编程语言/ 是/ 对/ C语言/ 做/ 数据流/ 扩展/ ,/ 语言/ 文法/ 是/ 在/ C语言/ 文法/ 基础/ 上/ 加入/ 表征/ 数据流/ 图/ 结构/ 的/ 文法/ ,/ 实现/ 对/ 数据流/ 图/ 最/ 基本/ 的/ 抽象/ ,/ 方便/ 数据流/ 程序/ 的/ 编写/ ./ 它/ 主要/ 包括/ 如下/ 几个/ 特点/ :/ (/ 1/ )/ 复合/ 数据流/ 类型/ 的/ 定义/ ./ COStream/ 支持/ 类似/ 于/ C语言/ 中/ struct/ 类型/ 的/ 数据流/ 类型定义/ ,/ 来/ 实现/ 复杂/ 的/ 数据/ 操作/ ./ (/ 2/ )/ actor/ 之间/ 采用/ 参数传递/ 方式/ 实现/ 连接/ ,/ 增强/ actor/ 的/ 复用/ ./ COStream/ 采用/ 类似/ 于/ C语言/ 参数传递/ 方式/ 实现/ actor/ 之间/ 依赖/ 关系/ 的/ 建立/ ./ (/ 3/ )/ 采用/ 窗口/ 机制/ 实现/ 对/ 数据流/ 的/ 访问/ ./ 窗口/ 的/ 长度/ 定义/ 了/ actor/ 每次/ 执行/ 生产/ 或/ 消耗/ 数据/ 的/ 码率/ ./ 另外/ ,/ 在/ actor/ 内部/ 支持/ 对/ 窗口/ 内/ 数据/ 的/ 随机/ 访问/ ./ (/ 4/ )/ 支持/ 层次性/ 数据流/ 图/ 的/ 构造/ ./ 层次性/ 流图/ 是/ 对/ SDF/ 图/ 中子/ 图/ 的/ 抽象/ ,/ COStream/ 设计/ 层次性/ 流/ 图文/ 法/ 用来/ 支持/ 层次性/ 流图/ 的/ 构造/ ,/ 方便/ 编程/ ./ 图/ 2/ 给出/ 了/ 一个/ 用/ COStream/ 编写/ 的/ 一个/ 程序/ 实例/ ,/ 程序/ 的/ 功能/ 为求/ 移动/ 平均值/ ,/ 该/ 程序/ 由/ 3/ 个/ operator/ 组成/ 即/ Source/ 、/ Avg/ 和/ Sink/ ./ 图/ 3/ 给出/ 了/ 该/ 程序/ 对应/ 的/ SDF/ 图/ ./ 2.2/ ./ 1Stream/ 数据流/ (/ stream/ )/ 作为/ 通信/ 载体/ 连接/ 数据流/ 图中/ 各个/ 计算/ 单元/ ,/ 是/ 对/ 数据流/ 图中/ 通信/ 边/ 的/ 抽象/ ,/ 是/ 由/ 一系列/ 数据流/ 成员/ (/ token/ )/ 组成/ 的/ 序列/ ,/ 它/ 为/ SDF/ 中/ 的/ actor/ 提供/ 可/ 并行处理/ 的/ 对象/ ./ 数据流/ 成员/ 的/ 声明/ 类似/ 于/ C语言/ 的/ 结构/ 体/ ,/ 是/ 一种/ 复合/ 数据类型/ ,/ 可以/ 包括/ 任意/ 基本/ C/ 内置/ 数据类型/ 、/ 字符串/ 类型/ 和/ 基本/ 内置/ 类型/ 的/ 数组/ 等/ ,/ 存储器/ 对/ 数据流/ 成员/ 的/ 组织/ 对/ 编程人员/ 是/ 透明/ 的/ ./ 数据流/ 分为/ 输入/ 数据流/ 和/ 输出/ 数据流/ 两种/ 类型/ ./ 在/ SDF/ 图中/ 输入/ 数据流/ 对应/ actor/ 的/ 输入/ 边/ ,/ 对/ actor/ 是/ 只读/ 的/ ;/ 输出/ 数据流/ 对应/ actor/ 的/ 输出/ 边/ ,/ 对/ actor/ 是/ 可/ 读写/ 的/ ./ 一般/ Page4/ 来说/ ,/ 一个/ stream/ 是/ 一个/ actor/ 的/ 输入/ 数据流/ 同时/ 又/ 是/ 另/ 一个/ actor/ 的/ 输出/ 数据流/ ./ 2.2/ ./ 2OperatorSDF/ 图中/ 最/ 基本/ 的/ 组成/ 单元/ 和/ 计算/ 单元/ 是/ actor/ ,/ 在/ COStream/ 中/ 由/ operator/ 文法/ 结构/ 表示/ ./ Operator/ 在/ SDF/ 中/ 被/ 抽象/ 成/ 一个/ actor/ ,/ 专门/ 用来/ 处理/ stream/ 中/ 的/ 数据/ ,/ operator/ 定义/ 了/ actor/ 输入/ 边/ 、/ 输出/ 边/ 和/ 具体/ 的/ 处理过程/ ./ Operator/ 由/ 头部/ 定义/ 和体/ 定义/ 组成/ ,/ 其中/ operator/ 头部/ 定义/ 了/ 该/ operator/ 处理/ 的/ 输入/ 、/ 输出/ 流/ 以及/ operator/ 名称/ ,/ COStream/ 暂时/ 不/ 支持/ 匿名/ operator/ 的/ 定义/ ./ COStream/ 中/ 一个/ operator/ 可以/ 有/ 多个/ 输入/ 流/ 和/ 多个/ 输出/ 流/ ./ Operator/ 体/ 包括/ 该/ operator/ 内/ 需要/ 用到/ 的/ 变量/ 声明/ 和/ 定义/ 、/ init/ 、/ work/ 和/ window/ 这/ 4/ 个/ 部分/ ./ 其中/ ,/ work/ 是/ operator/ 的/ 核心/ 结构/ ,/ 是/ 数据流/ 程序/ 周期性/ 迭代/ 的/ 执行/ 单元/ ./ Operator/ 对/ 输入/ 流/ 和/ 输出/ 流中/ 的/ 数据/ 访问/ 操作/ 也/ 是/ 在/ work/ 中/ 进行/ 的/ ./ Operator/ 内部/ 变量/ 的/ 声明/ 或者/ 定义/ 主要/ 是/ 为了/ 说明/ 该/ operator/ 的/ work/ 在/ 执行/ 时/ 是/ 需要/ 的/ 一些/ 静态/ 变量/ ,/ 类似/ 于/ C语言/ 中/ static/ 关键字/ 修饰/ 的/ 变量/ ,/ 对于/ 无/ 状态/ 的/ operator/ 来说/ ,/ 这部分/ 可以/ 为空/ ./ Init/ 定义/ 了/ operator/ 开始/ 执行/ 时/ 需要/ 进行/ 的/ 初始化/ 工作/ ./ COStream/ 采用/ 窗口/ 机制/ 确定/ 对流/ 中/ 数据/ 的/ 访问/ 方式/ ,/ operator/ 中/ 的/ window/ 结构/ 规定/ 对/ 输入/ 流/ 和/ 输出/ 流中/ 数据/ 访问/ 的/ 窗口/ 类型/ 和/ 窗口/ 大小/ ./ 下面/ 详细/ 讨论/ COStream/ 中/ 的/ 窗口/ 机制/ ./ COStream/ 对流/ 中/ 的/ 数据/ 访问/ 采用/ 窗口/ 机制/ ,/ 窗口/ 用/ 前沿/ 和/ 后/ 沿/ 界定/ ,/ 前沿/ 和/ 后/ 沿/ 的/ 距离/ 就是/ 当前/ operator/ 执行/ 时/ 可/ 操作/ 的/ 输入/ 、/ 输出/ 缓冲区/ 的/ 大小/ ,/ 它/ 由/ window/ 中/ 的/ 参数/ 确定/ ./ COStream/ 中/ 窗口/ 类型/ 有/ 两种/ :/ 一种/ 是/ sliding/ 类型/ ,/ 代表/ 滑动/ 窗口/ 类型/ ,/ 该/ 类型/ 的/ 窗口/ 支持/ peek/ ,/ pop/ 和/ push/ 这/ 3/ 种/ 操作/ 方式/ ,/ 一般/ 用于/ 输入/ 流/ ;/ 另/ 一种/ 是/ tumbling/ 类型/ ,/ 代表/ 翻转/ 窗口/ 类型/ ,/ 该/ 类型/ 窗口/ 只/ 支持/ push/ 和/ pop/ 两种/ 操作/ 方式/ ,/ 既/ 可以/ 用于/ 输入/ 流/ 也/ 可以/ 用于/ 输出/ 流/ ./ pop/ 操作/ 删除/ 最先/ 到达/ 流中/ 的/ token/ ,/ 并/ 返回/ 该/ token/ ;/ peek/ (/ i/ )/ 操作/ 返回/ 流/ 中距离/ 流/ 窗口/ 前沿/ 的/ 第/ i/ 个/ token/ ;/ push/ 操作/ 是/ 将/ 计算/ 得到/ 的/ token/ 放到/ 流/ ,/ 对/ 缓冲区/ 的/ 使用/ 是从/ 前沿/ 到/ 后/ 沿/ 的/ ./ Operator/ 一次/ 执行/ 完成/ 后/ 同时/ 移动/ 窗口/ 的/ 前沿/ 和/ 后/ 沿/ ./ 图/ 4/ (/ a/ )/ 图/ 描述/ COStream/ 中/ 的/ 输入输出/ 流/ 的/ 窗口/ 示意图/ ,/ 图/ 4/ (/ b/ )/ 和/ (/ c/ )/ 分别/ 表示/ 如果/ (/ a/ )/ 对应/ 的/ 窗口/ 分别/ 是/ sliding/ (/ 5/ ,/ 3/ )/ 和/ tumbling/ (/ 5/ )/ 时/ ,/ 一次/ operator/ 执行/ 完成/ 后/ 窗口/ 的/ 移动/ 情况/ ./ 为了/ 便于/ 操作/ 输入输出/ 流中/ 的/ 数据/ COStream/ ,/ 对/ 输入输出/ 窗口/ 操作/ 是/ 通过/ 下标/ 操作符/ [/ ]/ 来/ 实现/ 的/ ./ 图/ 3/ 中/ 3/ 个/ actor/ :/ Source/ 、/ Avg/ 和/ Sink/ 分别/ 对应/ 图/ 2/ 中/ 的/ 3/ 个/ operator/ ./ 以图/ 2/ 的/ operatorSource/ 为例/ ,/ Source/ 内/ 声明/ 了/ 一个/ 整型/ 变量/ x/ ,/ 在/ work/ 函数/ 第一次/ 执行/ 时先/ 调用/ init/ 函数/ 初始化/ x/ 为/ 0/ ./ Source/ 在/ 做/ 周期性/ 迭代/ 时/ work/ 会/ 对/ x/ 的/ 值加/ 1/ ,/ 将/ 新/ 的/ x/ 值/ push/ 到/ 输出/ 流/ S/ 中以/ 供/ Avg/ 消耗/ ./ Window/ 中/ 的/ 语句/ Stumbling/ (/ 1/ )/ 定义/ 了/ Source/ 的/ 输出/ 窗口/ 类型/ 为/ 翻转/ 窗口/ 类型/ ,/ 生产率/ 为/ 1/ ,/ 即/ 每次/ 迭代/ 向/ 输出/ 流中/ push/ 一个/ 数据/ ./ 综上/ ,/ Source/ 作为/ 源/ actor/ 执行/ 周期性/ 迭代/ 产生/ 自然数/ 序列/ ,/ 在/ 迭代/ 过程/ 中/ 并/ 将/ 其/ 结果/ 添加/ 到/ 输出/ 流中供/ SDF/ 图中/ 其它/ actor/ 的/ 消耗/ ./ 2.2/ ./ 3CompositeOperator/ 定义/ 了/ 数据流/ 图中/ 的/ 计算/ 节点/ ,/ 为了/ 将/ 不同/ 节点/ 连接/ 构造/ 数据流/ 图/ ,/ COStream/ 定义/ 了/ composite/ 结构/ ,/ 相对/ 于/ operatorcomposite/ 属于/ 高层次/ 的/ 复合/ 结构/ ,/ 代表/ 一个/ 由/ 单个/ 或/ 若干个/ operator/ 组成/ 的/ 可/ 重用/ 的/ 数据流/ 图/ 结构/ ,/ 它/ 是/ 对/ SDF/ 图中/ 可/ 复用/ 的/ 子/ 图/ 的/ 抽象/ ./ 一个/ composite/ 既/ 可以/ 作为/ 一个/ 完整/ 的/ 数据流/ 程序/ 形成/ 一个/ 完整/ SDF/ 图/ ,/ 也/ 可以/ 作为/ 子程序/ 被/ 其它/ 的/ composite/ 调用/ ,/ 作为/ 一个/ 完整/ SDF/ 图/ 的/ 一部分/ ./ composite/ 由/ composite/ 头部/ 和/ composite/ 体/ 组成/ ./ composite/ 头部/ 表明/ 该/ composite/ 的/ 输入输出/ 边/ 参数/ 、/ composite/ 参数/ 以及/ composite/ 的/ 名称/ ,/ COStream/ 不/ 支持/ 匿名/ composite/ ./ Composite/ 的/ 输入输出/ 边/ 参数/ 是/ 用来/ 确定/ 在/ 生成/ SDF/ 图时/ 该/ Page5composite/ 结构/ 所/ 形成/ 的/ 子/ 图/ 与/ SDF/ 图中/ 其它/ 节点/ 的/ 连接/ 关系/ ./ Composite/ 可以/ 同时/ 有/ 多个/ 输入/ 多个/ 输出/ 边/ ./ Composite/ 参数/ 主要/ 是/ 指/ composite/ 结构/ 在/ 实际/ 被/ 调用/ 时/ 需要/ 从/ 调用/ 处/ 传入/ 的/ 参数/ ,/ 可以/ 根据/ 参数/ 的/ 情况/ 决定/ composite/ 最终/ 子图/ 的/ 结构/ ,/ 该/ 参数/ 可以/ 在/ composite/ 内部/ 被/ 使用/ ./ composite/ 体/ 主要/ 由/ 如下/ 两/ 部分/ 组成/ :/ 一部分/ 是/ composite/ 内部/ 需要/ 使用/ 的/ 变量/ 的/ 定义/ 和/ 一些/ 相关/ 的/ 操作/ 语句/ ,/ 这/ 一部分/ 可以/ 看作/ 与/ 普通/ 的/ C语言/ 语句/ 类似/ ;/ 另/ 一部分/ 是/ composite/ 内部/ 能够/ 对流/ 中/ 的/ 数据/ 进行/ 处理/ 的/ 表征/ 子/ 数据流/ 图/ 结构/ 的/ 语句/ 块/ ,/ 它/ 是/ 由/ 一个/ 或/ 若干/ oper/ -/ ator/ 根据/ 数据流/ 依赖/ 关系/ 连接/ 而成/ ,/ 是/ composite/ 的/ 核心/ ./ Composite/ 结构/ 在/ 编译/ 阶段/ 被/ 扩展/ ,/ 经过/ 编译/ 数据流/ 程序/ 的/ 数据流/ 图/ 子结构/ 将/ 被/ 扩展/ 成/ 完整/ 的/ 数据流/ 图/ ,/ 程序/ 中/ 的/ 多个/ composite/ 也/ 将/ 转变/ 为/ 一个/ 用于/ 形成/ 最终/ 的/ SDF/ 图/ ./ 在/ 图/ 2/ 示例/ 中/ 程序/ 是/ 由/ 2/ 个/ composite/ 组成/ ,/ 程序/ 入口/ 为/ 名为/ Main/ 的/ composite/ ,/ Main/ 中/ 调用/ 了/ MovAvgcomposite/ ,/ 在/ 编译/ 时/ MovAvg/ 将/ 根据/ 输入输出/ 边/ 的/ 关系/ 被/ 实例/ 化/ ,/ 最终/ 形成/ 一个/ 完整/ 的/ SDF/ 图/ ,/ 如图/ 3/ 所示/ ./ 2.2/ ./ 4Operator/ 的/ 其它/ 连接/ 形上/ 一/ 小节/ 提出/ 了/ 可/ 复用/ 的/ composite/ ,/ 它/ 允许/ 编程人员/ 自定义/ operator/ 的/ 连接/ ./ COStream/ 为了/ 使/ 编程人员/ 更/ 高效/ 地/ 构建/ 数据流/ 图/ ,/ 在/ composite/ 内部/ 引入/ 支持/ 流水线/ 和/ 并行/ 结构化/ 的/ 层次性/ 编程/ 结构/ ,/ 图/ 6splitjoin/ 和/ pipeline/ 应用/ 举例/ 即/ pipeline/ 和/ splitjoin/ 结构/ [/ 5/ ]/ ./ 图/ 5/ 描述/ 了/ 这/ 两种/ 基本/ 的/ 层次性/ 数据流/ 结构/ ./ pipeline/ 结构/ 将/ 不同/ 的/ operator/ 顺序/ 直线/ 连接/ ;/ splitjion/ 结构/ 对/ 输入/ 流/ 进行/ 分批/ 并行处理/ ,/ 提高/ 了/ 数据流/ 处理/ 的/ 任务/ 并行性/ ./ 下面/ 详细/ 介绍/ 这/ 两种/ 结构/ 的/ 特点/ ./ 图/ 5COStream/ 支持/ 的/ operator/ 的/ 其它/ 连接/ 形式/ COStream/ 引入/ add/ 操作/ 将/ operator/ 和/ composite/ 调用/ 添加/ 到/ pipeline/ 和/ splitjoin/ 中/ ./ 图/ 6/ 中/ 的/ 例子/ 能够/ 说明/ splitjoin/ 和/ pipeline/ 的/ 层次性/ 特点/ 和/ 使用/ 特性/ ./ 在/ 图/ 中/ 左边/ 部分/ 是/ COStream/ 的/ 源码/ 片段/ ,/ 右边/ 是/ 对应/ 的/ 数据流/ 图/ ./ 在/ 本例/ 中/ 可以/ 看到/ 添加/ 了/ 层次性/ 的/ 结构/ 有助于/ 增加/ 数据流/ 程序/ 编程/ 的/ 灵活性/ 和/ 可扩展性/ ./ 另外/ ,/ 在/ splitjoin/ 和/ pipeline/ 中流/ 能够/ 被/ 参数/ 化/ ,/ 在/ 本例/ compositeVocodeBank/ 中/ 关于/ 内置/ 的/ pipeline/ 调用/ 次数/ 可以/ 由/ 参数/ N/ 来/ 确定/ ,/ 通过/ N/ 控制/ splitjoin/ 结构/ 的/ 宽度/ ,/ 同样/ 在/ pipeline/ 中/ 可以/ 通过/ 参数/ 来/ 控制/ pipeline/ 的/ 深度/ ./ Page62/ ./ 2.5/ 内置/ Composite/ 和/ 外部/ 程序接口/ 为了/ 便于/ 对/ 文件/ 操作/ ,/ COStream/ 对/ 文件/ 的/ I/ // O/ 提供/ 了/ 内置/ composite/ 支持/ ,/ 通过/ 调用/ 内置/ 的/ 文件/ I/ // OcompositeCOStream/ 可以/ 完成/ 对/ 文件/ 读写操作/ ./ FileReader/ 和/ FileWriter/ 是/ COStream/ 为/ I/ // O/ 提供/ 的/ 内置/ 的/ composite/ 接口/ ./ FileReader/ 用于/ 将/ 文件/ 中/ 的/ 数据/ 读到/ 流中/ ,/ FileWriter/ 是/ 将/ 流中/ 的/ 数据/ 写/ 到/ 文件/ 中/ ./ 具体/ 用法/ 如下/ :/ stream/ 〈/ doublex/ 〉/ A/ ,/ B/ ;/ // // 1A/ =/ FileReader/ (/ “/ data/ ./ bin/ ”/ )/ ;/ // // 2FileWriter/ (/ B/ )/ (/ “/ result/ ./ txt/ ”/ )/ ;/ // // 3/ 行/ 2/ 表示/ 将/ data/ ./ bin/ 文件/ 中/ 的/ 数据/ 读入/ 到/ 数据流/ A/ 中/ ,/ 行/ 3/ 表示/ 将/ 处理/ 后/ 输出/ 的/ 流/ B/ 中/ 的/ 数据/ 保存/ 至/ 文件/ result/ ./ txt/ ./ 另外/ ,/ COStream/ 还/ 提供/ 了/ 程序/ 的/ 外部/ 接口/ ,/ 使/ COStream/ 程序/ 可以/ 嵌入/ 到/ C++/ 程序/ 中/ ,/ 通过/ 这种/ 方式/ 可以/ 使得/ 在/ C++/ 程序/ 中/ 满足/ 数据流/ 程序/ 特性/ 的/ 对/ 程序/ 性能/ 有/ 关键/ 影响/ 的/ 模块/ 通过/ COStream/ 实现/ ,/ 以便/ 使/ 程序/ 在/ 执行/ 时/ 能够/ 充分利用/ 处理器/ 资/ (/ 1/ )/ 编译器/ 前端/ ./ 编译器/ 前端/ 是/ 对/ COStream/ 源程序/ 进行/ 词法/ 分析/ 、/ 语法分析/ 和/ 语义/ 动作/ 分析/ 建立/ 图/ 7COStream/ 数据流/ 编译系统/ 框架图/ 源/ ,/ 而/ 编程人员/ 又/ 可以/ 不/ 需要/ 关心/ 底层/ 硬件/ 结构/ 的/ 细节/ ./ 在/ 3.2/ 节/ 中将/ 会/ 对/ 调用/ COStream/ 外部/ 接口/ 的/ C++/ 程序/ 的/ 编译/ 过程/ 做/ 详细/ 的/ 介绍/ ./ 本节/ 针对/ COStream/ 的/ 执行/ 模型/ 和/ 语言/ 结构/ 进行/ 了/ 详细/ 的/ 讨论/ ./ 语言/ 设计/ 综合/ 考虑/ 了/ 与/ 高级/ 语言/ 的/ 语法/ 相似性/ 和/ 数据流/ 编程/ 模型/ 的/ 特性/ ,/ 利于/ 编程人员/ 进行/ 编程/ ./ 3/ 面向/ 多/ // 众核/ 架构/ 的/ COStream/ 编译/ 框架/ 3.1/ COStream/ 编译器/ 总体/ 框架图/ 7/ 描述/ 了/ COStream/ 编译系统/ 的/ 总体/ 框架图/ ./ COStream/ 编译器/ 的/ 源语言/ 为/ COStream/ 数据流/ 语言/ ,/ 目标语言/ 根据/ 目标/ 系统/ 不同/ 生成/ 不同/ 底层/ 语言/ ,/ 如/ C/ 、/ C++/ 和/ openCL/ [/ 13/ ]/ 等/ ,/ 编译器/ 通过/ 调用/ 底层/ 语言/ 编译器/ 生成/ 对应/ 目标/ 平台/ 的/ 可执行文件/ ./ 下面/ 详细/ 介绍/ COStream/ 编译系统/ 的/ 组成部分/ ./ 抽象/ 语法/ 树/ ./ 通过/ 编译器/ 前端/ COStream/ 源程序/ 将/ 被/ 转换成/ 一棵/ 由/ 顶层/ 语法/ 树/ 节点/ 表示/ 的/ 层次性/ 抽象/ Page7/ 语法/ 树结构/ ./ COStream/ 编译系统/ 采用/ Lex/ 和/ Yacc/ [/ 14/ ]/ 生成/ 词语/ 法/ 分析器/ ./ (/ 2/ )/ 语义/ 分析/ 和/ 代码优化/ ./ 编译器/ 对/ 经过/ 词/ 语法分析/ 形成/ 的/ 抽象/ 语法/ 树/ 进行/ 语义/ 分析/ 并/ 对/ 抽象/ 语法/ 树作/ 机器/ 无关/ 优化/ ,/ 得到/ 最佳/ 抽象/ 语法/ 树/ ./ (/ 3/ )/ 中间/ 代码生成/ ./ COStream/ 以/ SDF/ 图/ 作为/ 中间/ 表示/ ,/ 该/ 阶段/ 根据/ COStream/ 中/ 的/ composite/ 调用/ 关系/ 和/ stream/ 依赖/ 关系/ ,/ 对/ 经过/ 优化/ 后/ 的/ 抽象/ 语法/ 树/ 进行/ 分析/ ,/ 将/ 语法/ 树/ 进行/ 深层次/ 的/ 展开/ ,/ 得到/ 一个/ 只有/ operator/ 通过/ stream/ 相连/ 的/ 完整/ 的/ 数据流/ 图/ 的/ 抽象/ 语法/ 树结构/ ,/ 利用/ 此时/ 的/ 抽象/ 语法/ 树/ 生成/ SDF/ 图/ ,/ 该/ SDF/ 图是/ 编译器/ 后续/ 操作/ 的/ 基础/ ./ 另外/ ,/ 该/ 阶段/ 还/ 需要/ 对/ SDF/ 图中/ 的/ 各个/ 节点/ 的/ 工作量/ 进行/ 估计/ ,/ 确定/ SDF/ 图中/ 各个/ actor/ 的/ 负载/ 情况/ ./ (/ 4/ )/ 数据流/ 图/ 的/ 周期性/ 调度/ ./ 编译器/ 对/ SDF/ 图/ 表示/ 的/ 数据流/ 图/ 结构/ 采用/ 单/ 出现/ 调度/ 策略/ (/ SingleAppearanceSchedule/ ,/ SAS/ )/ [/ 15/ ]/ 得到/ 静态平衡/ 数据流/ 图/ ./ 编译器/ 根据/ 程序/ 中/ 各个/ actor/ 的/ peek/ 、/ pop/ 和/ push/ 率/ 决定/ 在/ 初态/ 和/ 稳态/ 下/ 各个/ actor/ 的/ 执行/ 次数/ ,/ 为/ 后续/ 的/ 优化/ 和/ 代码生成/ 提供/ 依据/ ./ (/ 5/ )/ 底层/ 结构/ 相关/ 优化/ ./ 编译器/ 根据/ 不同/ 底层/ 系统结构/ 特性/ ,/ 对/ COStream/ 程序/ 进行/ 与/ 底层/ 结构/ 相关/ 的/ 优化/ ,/ 主要/ 从/ 计算/ 任务分配/ 、/ 存储/ 优化/ 和/ 通信/ 优化/ 等/ 方面/ 对/ 程序/ 进行/ 优化/ ,/ 在/ 开发/ 并行性/ 的/ 同时/ 减小/ 相应/ 的/ 开销/ ,/ 使/ 数据流/ 程序/ 在/ 执行/ 时/ 能够/ 充分利用/ 底层/ 系统/ 的/ 资源/ ,/ 提高/ 程序/ 的/ 执行/ 效率/ ./ COStream/ 主要/ 针对/ X86/ 、/ Codson/ -/ T/ 、/ GPU/ 和/ 多/ 核/ 集群/ 等/ 目标/ 系统/ 做/ 编译/ 优化/ ./ 在/ 第/ 4/ 节中/ 具体/ 介绍/ 面向/ X86/ 共享/ 多核/ 架构/ 下/ 的/ 相关/ 优化/ ./ (/ 6/ )/ 代码生成/ ./ 根据/ 底层/ 结构/ 相关/ 优化/ 的/ 结果/ 、/ 目标/ 系统/ 的/ 体系结构/ 以及/ 目标/ 代码/ 的/ 特性/ ,/ 设计/ 最终目标/ 代码/ 的/ 生成/ 框架/ ,/ 生成/ 能够/ 在/ 目标/ 系统/ 上/ 高效/ 的/ 可/ 并行执行/ 的/ 代码/ ./ (/ 7/ )/ 运行/ 时/ 系统/ ./ 运行/ 时/ 系统/ 主要/ 包括/ 数据流/ 程序/ 在/ 特定/ 平台/ 上/ 执行/ 时/ 通信模型/ 的/ 设计/ 和/ 为了/ 支持/ 代码生成/ 所/ 需/ 的/ 相关/ 库函数/ 的/ 设计/ ,/ 关于/ 通信模型/ 和/ 库函数/ 一般/ 采用/ 特定/ 平台/ 上/ 的/ 目标语言/ 来/ 实现/ ./ (/ 8/ )/ 底层/ 编译系统/ ./ 编译器/ 将/ 生成/ 的/ 针对/ 特定/ 平台/ 的/ 目标/ 代码/ 交由/ 平台/ 上/ 的/ 底层/ 语言/ 对应/ 的/ 编译器/ 进行/ 编译/ ,/ 生成/ 对应/ 的/ 可执行文件/ ,/ 以/ X86/ 后端/ 为例/ ,/ 经过/ COStream/ 编译系统/ 的/ 目标/ 代码/ 模块/ 生成/ 的/ 是/ C++/ 代码/ ,/ 再/ 经过/ gcc/ 编译/ 最终/ 生成/ 能够/ 在/ 多/ 核下/ 可/ 并行执行/ 的/ 文件/ ./ 3.2/ 编译器/ 外部/ 接口/ COStream/ 编译器/ 支持/ 两种/ 程序/ 编译/ 模式/ :/ 独立/ 模式/ 和/ 嵌入/ 模式/ ./ 以/ 目标语言/ C++/ 为例/ ,/ 在/ 独立/ 模式/ 中/ ,/ COStream/ 程序/ 被/ 翻译成/ C++/ ,/ 最后/ 编译成/ 独立/ 可/ 执行/ 的/ 文件/ ,/ 无需/ 其它/ 干涉/ ;/ 在/ 嵌入/ 模式/ 中/ ,/ COStream/ 程序/ 通过/ COStream/ 的/ 外部/ 接口/ 被/ C++/ 程序/ 调用/ ,/ 成为/ C++/ 的/ 一个/ 调用/ 库/ ,/ 和/ 外部/ C++/ 一起/ 编译/ 连接/ ./ 在/ 编译/ 时/ 只/ 需/ 设置/ 相应/ 的/ 编译/ 选项/ ,/ 编译器/ 就/ 能够/ 对/ 代码/ 以/ 不同/ 的/ 方式/ 编译/ ,/ 其中/ -/ embed/ 表示/ 嵌入式/ 调用/ ,/ 而/ -/ normal/ 表示/ 独立/ 执行程序/ ./ 图/ 8/ 描述/ 了/ COStream/ 在/ 两种/ 模式/ 下/ 的/ 编译/ 过程/ ./ 4/ 面向/ X86/ 多核/ 架构/ 的/ 编译/ 优化/ 框架/ 本节/ 将/ 基于/ X86/ 共享/ 存储/ 多核/ 架构/ 提出/ 一种/ COStream/ 数据流/ 编译/ 优化/ 框架/ ./ 该/ 框架/ 目标/ 是/ 针对/ 数据流/ 程序/ 根据/ 共享/ 存储/ 多核/ 架构/ 的/ 结构/ 特点/ 构造/ 高/ 吞吐量/ 低/ 延迟/ 的/ 软件/ 流水线/ 调度/ ./ 4.1/ 软件/ 流水线/ 调度/ 4.1/ ./ 1/ 任务/ 划分/ 任务/ 划分/ 的/ 目的/ 是/ 根据/ SDF/ 图中/ actor/ 的/ 负载/ 和/ actor/ 间/ 的/ 依赖/ 关系/ 构造/ 高/ 吞吐量/ 低/ 延迟/ 的/ 软件/ 流水线/ 调度/ ,/ 以/ 最大化/ 底层/ 系统资源/ 利用率/ ./ 数据流/ 程序/ 要/ 想/ 充分利用/ 系统资源/ 就/ 必须/ 充分/ 合理/ 地/ 利用/ 其/ 自身/ 的/ 数据/ 并行性/ 、/ 任务/ 并行性/ 和/ 流水线/ 并行性/ [/ 22/ ]/ ./ 在/ 软件/ 流水线/ 调度/ 中/ ,/ 流水线/ 的/ 启动/ 间隔/ (/ InitiationInterval/ ,/ II/ )/ 是/ 指/ 相邻/ 两次/ 循环/ 迭代/ 进入/ 流水线/ 的/ 时间/ 间隔/ ,/ II/ 越小/ 意味着/ 吞吐/ 率越/ 大/ ./ 任务/ Page8/ 划分/ 的/ 目的/ 就是/ 要/ 最小化/ II/ ./ 在/ 软件/ 流水/ 中/ II/ 是/ 由/ 流水线/ 中/ 各/ 资源/ 的/ 处理/ 时间/ 决定/ ,/ 在/ X86/ 中/ ,/ 资源/ 主要/ 是/ 处理器/ 核/ ,/ 那么/ 影响/ 程序/ 最终/ 执行/ 性能/ 的/ 主要/ 因素/ 就是/ 划分/ 的/ 负载/ 均衡/ 情况/ ./ 任务/ 划分/ 是/ 要/ 确定/ SDF/ 图中/ 的/ 各个/ actor/ 被/ 分配/ 到/ 哪个/ 处理/ 核上/ ./ COStream/ 任务/ 划分/ 采取/ 以/ 负载/ 均衡/ 为/ 目标/ 同时/ 最小化/ 同步/ 通信/ 开销/ 的/ 分配/ 策略/ ./ 负载/ 均衡/ 的/ 目的/ 是/ 为了/ 保证/ 流水线/ 在/ 满/ 状态/ 时/ 各个/ 核上/ 的/ 有效/ 计算/ 时间/ 是/ 相等/ 的/ ,/ 核间/ 因/ 相互/ 等待/ 而/ 产生/ 的/ 空闲/ 时间/ 将会/ 小/ ,/ II/ 就/ 会/ 小/ ,/ 处理/ 核/ 利用率/ 就/ 高/ ,/ 系统/ 的/ 吞吐量/ 就/ 大/ ./ 同时/ ,/ 因为/ SDF/ 中/ actor/ 之间/ 有/ 数据/ 依赖/ ,/ 为了/ 保证数据/ 访问/ 的/ 局部性/ 最小化/ 同步/ 通信/ 延迟/ ,/ 在/ 任务/ 划分/ 时/ 应该/ 尽可能/ 地/ 将/ 有/ 依赖/ 关系/ 的/ actor/ 分配/ 在/ 一个/ 核上/ 以/ 最大/ 程度/ 地/ 减少/ 核/ 间通信/ 边/ 的/ 数量/ ./ 文献/ [/ 16/ ]/ 比较/ 了/ 常见/ 的/ 任务/ 划分/ 和/ 分配/ 策略/ ,/ 常见/ 的/ 分配/ 策略/ 主要/ 包括/ 有/ 循环/ 分发/ 分配/ 策略/ 、/ 亲和性/ 分配/ 策略/ 和/ 贪心/ 分配/ 策略/ 等/ ./ 综合/ COStream/ 程序运行/ 时/ 存在/ 的/ 问题/ 及常图/ 9/ 复制/ 分裂/ 算法/ 流程图/ 4.1/ ./ 2/ 阶段/ 赋值/ 经过/ 任务/ 划分/ 后/ ,/ 数据流/ 程序/ 的/ 各个/ actor/ 已经/ 被/ 分配/ 到/ 处理/ 核上/ ,/ 阶段/ 赋值/ 的/ 目的/ 是/ 确定/ 各个/ actor/ 被/ 分配/ 到/ 流水线/ 的/ 哪个/ 执行/ 阶段/ ./ 由于/ 各个/ actor/ 之间/ 存在/ 依赖/ 关系/ ,/ 因而/ 除了/ 在/ 空间/ 维度/ 上/ 对/ actor/ 进行/ 分配/ ,/ 还/ 需要/ 在/ 时间/ 维度/ 上/ 指定/ 各个/ actor/ 的/ 相对/ 计算/ 顺序/ 以/ 满足/ actor/ 间/ 数据/ 依赖/ 关系/ ./ 通见/ 任务分配/ 策略/ ,/ COStream/ 选择/ 以/ 负载/ 均衡/ 为/ 目标/ 同时/ 最小化/ 通信/ 开销/ 的/ K/ 路图/ 划分算法/ (/ MultilevelK/ -/ wayPartitioning/ ,/ MKP/ )/ [/ 17/ ]/ ./ COStream/ 采用/ Metis/ [/ 18/ ]/ 提供/ 的/ 接口/ 实现/ MKP/ 算法/ 为/ SDF/ 图作/ 任务分配/ ./ 由于/ MKP/ 作为/ 通用/ 的/ 图/ 划分算法/ ,/ 没有/ 充分/ 结合/ 数据流/ 程序/ 自身/ 存在/ 的/ 各种/ 并行性/ 其/ 结果/ 并/ 不能/ 很/ 好/ 地/ 满足/ 程序运行/ 的/ 要求/ ,/ COStream/ 在/ MKP/ 划分/ 结果/ 的/ 基础/ 上/ 根据/ 数据流/ 程序/ 的/ 特点/ 进行/ 了/ 进一步/ 优化/ ,/ 提出/ 复制/ 分裂/ 算法/ ,/ 图/ 9/ 描述/ 了/ 复制/ 分裂/ 算法/ 的/ 基本/ 流程/ ./ 复制/ 分裂/ 算法/ 根据/ MKP/ 划分/ 结果/ 的/ 负载平衡/ 情况/ ,/ 利用/ 了/ SDF/ 图中/ 无/ 状态/ 的/ actor/ 存在/ 的/ 数据/ 并行性/ ,/ 对/ 无/ 状态/ 的/ actor/ 做/ 分裂/ ,/ 增大/ 任务/ 并行性/ ,/ 将/ 分裂/ 产生/ 的/ 不同/ 副本/ 分配/ 到/ 不同/ 的/ 划分/ 子/ 集中/ ,/ 降低/ actor/ 粒度/ ,/ 使/ 不同/ 划分/ 的/ 负载/ 达到/ 平衡/ ./ 经过/ 实验/ 分析/ 看到/ ,/ COStream/ 在/ X86/ 环境/ 下/ 平衡/ 因子/ 设为/ 1.5/ 时/ 能够/ 得到/ 较/ 理想/ 的/ 结果/ ,/ 其中/ 平衡/ 因子/ 指/ 的/ 是/ 划分/ 中负载/ 最大/ 的/ 与/ 最小/ 的/ 比值/ ./ 过/ 任务/ 划分/ 的/ 结果/ 和/ actor/ 间/ 的/ 数据/ 依赖性/ 为/ 每个/ actor/ 分配/ 执行/ 阶段/ 调度/ 构造/ 软件/ 流水线/ 调度/ ./ 对于/ SDF/ 图/ G/ =/ (/ V/ ,/ E/ )/ ,/ V/ 代表/ SDF/ 图中/ 的/ 所有/ 结点/ 的/ 集合/ ,/ E/ 代表/ SDF/ 图中/ 的/ 所有/ 边/ 的/ 集合/ ./ 为了/ 保证/ SDF/ 图中/ actor/ 间/ 数据流/ 依赖/ 关系/ ,/ 规定/ :/ 对于/ SDF/ 图中/ 任意/ v/ ∈/ V/ ,/ u/ ∈/ V/ ,/ 存在/ 有/ 向/ 边/ (/ v/ ,/ u/ )/ ∈/ E/ ,/ 该边/ 的/ 终点/ u/ 的/ 阶段/ 值/ 不/ 小于/ 始点/ v/ 的/ 阶段/ 值/ ./ Page9/ 算法/ 1/ ./ 阶段/ 赋值/ 算法/ ./ 输入/ :/ SDF/ 图/ G/ (/ V/ ,/ E/ )/ ,/ 图/ G/ 计算/ 单元/ 到/ 核/ 的/ 映射/ 输出/ :/ 图/ G/ 计算/ 单元/ 到/ 阶段/ 号/ 的/ 映射/ mapActor2Stage1/ ./ topologyOrderOfActors/ =/ topologyTravSDF/ (/ )/ ;/ 2/ ./ FORallactoruINtopologyOrderOfActorsDO3/ ./ intmaxStageValue/ =/ 0/ ;/ intstageValue/ ;/ 4/ ./ FORallactorvwhichisaparentofuDO5/ ./ IF/ (/ mapActor2Partition/ [/ v/ ]/ !/ =/ 6/ ./ stageValue/ =/ mapActor2Stage/ [/ v/ ]/ +/ 1/ ;/ 7/ ./ ELSE8/ ./ stageValue/ =/ mapActor2Stage/ [/ v/ ]/ ;/ 9/ ./ ENDIF10/ ./ IF/ (/ stageValue/ >/ maxStageValue/ )/ THEN11/ ./ maxStageValue/ =/ stageValue/ ;/ 12/ ./ ENDIF13/ ./ ENDFOR14/ ./ mapActor2Stage/ [/ u/ ]/ =/ maxStageValue/ ;/ 15/ ./ ENDFOR/ 算法/ 1/ 描述/ 了/ 阶段/ 赋值/ 的/ 过程/ ./ 首先/ ,/ 对/ 数据流/ 图/ G/ (/ V/ ,/ E/ )/ 进行/ 拓扑/ 排序/ ;/ 其次/ ,/ 按照/ 数据/ 依赖/ 关系/ 依次/ 访问/ 所有/ 的/ actor/ ,/ 对/ u/ ∈/ V/ ,/ 令/ maxStage/ 为/ 0/ ,/ 遍历/ u/ 的/ 每个/ 输入/ 边/ (/ v/ ,/ u/ )/ ∈/ E/ ,/ 如果/ v/ 和/ u/ 在/ 不同/ 处理/ 核上/ ,/ 则/ u/ 的/ 阶段/ 号/ stageu/ =/ stagev/ +/ 1/ ;/ 否则/ u/ 的/ 阶段/ 号/ stageu/ =/ stagev/ ./ 如果/ stageu/ >/ maxStage/ ,/ 图/ 10/ 任务/ 划分/ 、/ 阶段/ 赋值/ 和/ 软件/ 流水/ 调度/ 事例/ 4.2/ 基于/ 软件/ 流水线/ 调度/ 的/ 代码生成/ 框架/ 基于/ X86/ 架构/ COStream/ 编译器/ 使用/ C/ // C++/ 作为/ 目标/ 代码/ ./ 数据流/ 程序/ 在/ 执行/ 时/ 根据/ 任务/ 划分/ 则/ 更新/ maxStage/ ./ 在/ 遍历/ 完/ u/ 的/ 每/ 条边/ 后/ ,/ 以/ maxStage/ 作为/ u/ 的/ 阶段/ 号/ ./ 图/ 10/ 给出/ 了/ 任务/ 划分/ 、/ 阶段/ 赋值/ 和/ 软件/ 流水/ 调度/ 执行/ 的/ 一个/ 例子/ ./ 初始/ SDF/ 图有/ A/ 、/ B/ 和/ C/ 这/ 3/ 个/ actor/ ,/ 在/ 任务/ 划分/ 阶段/ 将/ B/ 复制/ 分裂/ 成/ 两个/ 计算/ 单元/ B1/ 和/ B2/ ,/ 同时/ 引入/ 了/ split/ 和/ join/ 两个/ 计算/ 节点/ ./ 经过/ 任务/ 划分/ 后/ ,/ 计算/ 单元/ A/ 被/ 分配/ 到/ 处理器/ 核/ core0/ ,/ split/ 和/ B1/ 被/ 分配/ 到/ core1/ ,/ B2/ 、/ join/ 和/ C/ 被/ 分配/ 到/ core3/ 上/ ./ 图/ 10/ (/ a/ )/ 给出/ 了/ 经过/ 阶段/ 赋值/ 后/ 各个/ 计算/ 单元/ 的/ 阶段/ 值/ ,/ 完成/ 了/ 软件/ 流水/ 的/ 构造/ ./ 图/ 10/ (/ b/ )/ 给出/ 了/ 对应/ 的/ 软件/ 流水/ 调度/ 执行/ 过程/ ,/ 程序/ 启动/ 时/ 流水线/ 处于/ 填充/ 阶段/ ,/ 各个/ 核上/ 的/ actor/ 按照/ 其/ 阶段/ 值/ 从小到大/ 的/ 顺序/ 启动/ 执行/ ,/ 当/ 所有/ 的/ actor/ 都/ 启动/ 时/ ,/ 流水线/ 进入/ 满/ 阶段/ ;/ 在/ 流水线/ 满/ 阶段/ ,/ 所有/ 的/ actor/ 都/ 进行/ 周期性/ 的/ 迭代/ 执行/ ,/ 由于/ 任务/ 划分/ 阶段/ 基本/ 实现/ 了/ 不同/ 计算/ 核上/ 的/ 负载/ 均衡/ ,/ 此时/ 核间/ 同步/ 开销/ 小/ ,/ 资源/ 利用率/ 高/ ,/ 系统/ 的/ 吞吐/ 率/ 达到/ 最大/ ;/ 在/ 流水线/ 调度/ 的/ 排空/ 阶段/ ,/ 程序/ 开始/ 相继/ 结束/ actor/ 的/ 执行/ ,/ 各个/ 核/ 的/ actor/ 按照/ 阶段/ 值/ 从小到大/ 的/ 顺序/ 结束/ 其/ 周期性/ 的/ 迭代/ ,/ 等到/ 所有/ 的/ actor/ 结束/ 其/ 稳态/ 调度/ 后/ ,/ 整个/ 程序/ 终止/ 并/ 释放/ 运行/ 时/ 占有/ 的/ 各种/ 资源/ ./ 情况/ 为/ 每个/ 计算/ 核/ 分配/ 一个/ 线程/ ,/ 一个/ 线程/ 对应/ SDF/ 图中/ 的/ 若干个/ actor/ ,/ 线程/ 中/ 的/ actor/ 在/ 相应/ 软件/ 流水/ 的/ 执行/ 阶段/ 被/ 调度/ 到/ 处理器/ ./ COStream/ 的/ Page10/ 目标/ 代码/ 主要/ 包括/ 如下/ 几个/ 部分/ :/ (/ 1/ )/ operator/ 对应/ 的/ 类/ 定义/ 文件/ ./ 数据流/ 图/ 的/ 每个/ 计算/ 单元/ 对应/ 一个/ actor/ 类/ 的/ 定义/ ,/ 类/ 的/ 成员/ 函数/ 包含/ 一个/ 用于/ 初始化/ 该/ actor/ 访问/ 的/ 缓冲区/ 的/ 构造函数/ 、/ 一个/ 初态/ 调度/ 函数/ 以及/ 一个/ 稳态/ 调度/ 函数/ ./ 类中/ 的/ work/ 函数/ 和/ init/ 函数/ 分别/ 对/ 应该/ operator/ 中/ 的/ work/ 和/ init/ ,/ 初态/ 调度/ 函数/ 和/ 稳态/ 调度/ 函数/ 是/ 根据/ actor/ 周期性/ 调度/ 的/ 结果/ 确定/ 的/ ./ (/ 2/ )/ 定义/ actor/ 间/ 的/ 通信/ 边/ 的/ 代码/ ./ 该/ 文件/ 主要/ 对/ SDF/ 图中/ 的/ 通信/ 边/ 进行/ 管理/ ./ 数据流/ 图中/ 的/ 有/ 向/ 边/ 表示/ 数据流/ 程序/ 数据/ 的/ 流动/ 方向/ ,/ 边上/ 端/ 结点/ 生产/ 数据/ ,/ 下端/ 结点/ 消耗/ 数据/ ./ COStream/ 基于/ 数据流/ 图/ 的/ 这种/ 特点/ 采用/ 生产/ 消费者/ 模型/ 对/ 缓冲区/ 进行/ 管理/ ./ 在/ X86/ 中/ ,/ 生产者/ 和/ 消费者/ 使用/ 共享/ 缓存/ 作为/ 通信/ 方式/ ./ 在/ 目标/ 代码/ 中/ ,/ 定义/ 供/ 生产者/ 和/ 消费者/ 共同/ 访问/ 的/ 有界/ 循环/ 缓存/ 区/ buffer/ ,/ 生产者/ 将/ 数据/ 写入/ 缓冲区/ 尾部/ ,/ 消费者/ 从/ 缓冲区/ 头部/ 访问/ 数据/ ,/ COStream/ 中/ 缓冲区/ 采用/ 循环/ 队列/ 来/ 实现/ ./ voidthread/ _/ x/ _/ fun/ (/ )/ {/ 实例/ 化/ actor/ 的/ 对象/ ;/ charpipelineStage/ [/ MAXSTAGE/ ]/ =/ {/ 0/ }/ ;/ stage/ [/ 0/ ]/ =/ 1/ ;/ // // 初态/ 调度/ for/ (/ intstageIter/ =/ 0/ ;/ stageIter/ </ MAXSTAGE/ ;/ stageIter/ ++/ )/ {/ if/ (/ N/ -/ 1/ =/ =/ stageIter/ )/ {/ // // 调用/ 阶段/ 号/ 为/ N/ -/ 1/ 的/ 计算/ 单元/ 的/ 初态/ 调度/ 函数/ }/ …/ if/ (/ 0/ =/ =/ stageIter/ )/ {/ }/ }/ // // 稳态/ 调度/ for/ (/ intstageIter/ =/ 0/ ;/ stageIter/ </ maxIter/ +/ MAXSTAGE/ -/ 1/ ;/ if/ (/ pipelineStage/ [/ N/ -/ 1/ ]/ )/ {/ }/ …/ if/ (/ pipelineStage/ [/ 0/ ]/ )/ {/ }/ // // 移动/ stage/ ,/ 实现/ 流水线/ 填充/ 与/ 排空/ for/ (/ intstageIter/ =/ MAXSTAGE/ -/ 1/ ;/ stageIter/ >/ =/ 1/ ;/ // // 判断/ 是否/ 进入/ 流水线/ 排空/ 阶段/ if/ (/ stageIter/ =/ =/ maxIter/ -/ 1/ )/ barrierSync/ (/ )/ ;/ // // 同步操作/ }/ }/ (/ 3/ )/ 流水线/ 循环/ 和/ 同步控制/ 的/ 代码/ 文件/ ./ 该/ 部分/ 主要/ 是/ 指/ 根据/ 软件/ 流水线/ 调度/ 结果/ 生成/ 的/ 整个/ 程序/ 的/ 控制代码/ 和/ 各个/ 计算/ 核/ 上线/ 程/ 的/ 控制代码/ ./ COStream/ 根据/ X86/ 的/ 特点/ 通过/ 任务/ 划分/ 结果/ 决定/ 一个/ 线程/ 内/ 的/ actor/ ,/ 再/ 通过/ 软件/ 流水线/ 调度/ 确定/ actor/ 间/ 的/ 执行/ 顺序/ ,/ COStream/ 在/ 流水线/ 的/ 不同/ 阶段/ 引入/ 同步/ 机制/ ,/ 保证/ 不/ 在/ 同一个/ 线程/ 内且/ 有/ 数据/ 依赖/ 的/ actor/ 间/ 能够/ 正常/ 的/ 运行/ ./ 图/ 11/ 给出/ 了/ 一个/ 线程/ 内/ 构造/ 软件/ 流水/ 的/ 过程/ ./ 5/ 实验/ 结果/ 与/ 分析/ 本文/ 采用/ 的/ 实验/ 平台/ 是/ X86/ -/ 64/ 架构/ 的/ 服务器/ ,/ 机器/ 配有/ 2/ 颗/ 2.50/ GHzIntelXeonE5420CPU/ 和/ 最大/ 支持/ 内存/ 48GB/ ./ 实验/ 环境/ 是/ 内核/ 版本/ 为/ 2.6/ ./ 18/ 的/ Linux/ 操作系统/ ,/ gcc/ 版本/ 为/ 4.1/ ./ 2/ ./ 为了/ 对/ COStream/ 编译系统/ 面向/ X86/ 架构/ 的/ 编译/ 优化/ 进行/ 全面/ 的/ 性能/ 评估/ 和/ 分析/ ,/ 选取/ 了/ 11/ 个/ 多媒体/ 领域/ 常见/ 的/ 算法/ 作为/ 测试程序/ ,/ 用/ COStream/ 数据流/ 编程语言/ 实现/ ,/ 作为/ COStream/ 编译器/ 的/ 输入/ ./ 测试程序/ 中有/ 计算/ 密集型/ 应用/ ,/ 也/ 有/ 数据/ 和/ 计算/ 都/ 密集/ 的/ 应用/ ./ 各个/ 测试程序/ 的/ 功能/ 、/ 规模/ 和/ 结构/ 描述/ 如图/ 12/ 所示/ ,/ 在/ 图/ 12/ 中/ SDF/ 图/ 节点/ 数目/ 反映/ 了/ 该/ 程序/ 在/ 任务/ 划分/ 和/ 调度/ 方面/ 的/ 复杂性/ ./ 测试程序/ 名/ 简要/ 描述/ BeamFormer/ 滤波器/ 程序/ 2171057ChannelVocoder/ 频道/ 话路/ DCT/ 离散/ 余弦/ DESDES/ 加密/ FFT/ 傅里叶/ Filterbank/ 多/ 速率/ 信号/ FMRadio/ 调频/ 收音机/ MPEGdecoder/ 视频/ 解码/ Sperpent/ 蛇/ 加密/ 程序/ 44111460Tde/ 透明/ 数据/ Vecoder/ 比特率/ 减图/ 13/ 给出/ 了/ 测试程序/ 经过/ COStream/ 编译/ 后/ 在/ 目标/ 环境/ 上/ 执行/ 的/ 加速/ 比/ ./ 从图/ 中/ 可以/ 看出/ ,/ 每个/ Page11/ 程序执行/ 加速/ 比/ 随着/ 核/ 数目/ 的/ 增多/ 而/ 增大/ ,/ 基本/ 呈现/ 一个/ 线性/ 增长/ 趋势/ ./ 测试程序/ 在/ 2/ 个/ 核下/ 加速/ 能够/ 达到/ 1.9/ x/ ,/ 加速/ 效果/ 非常/ 理想/ ./ 在/ 8/ 个/ 核/ 的/ 情况/ 下/ ,/ 有/ 1/ 个/ 程序/ 加速/ 比/ 超过/ 了/ 7x/ ,/ 有/ 6/ 个/ 程序/ 加速/ 比/ 达到/ 6x/ ,/ 在/ 8/ 核时/ 平均/ 加速/ 比/ 能够/ 达到/ 5.9/ x/ ,/ 加速/ 效果/ 比较/ 理想/ ./ 通过/ 对/ 测试程序/ 分析/ 发现/ ,/ 如果/ 测试程序/ 任务/ 划分/ 结果/ 展现/ 了/ 很/ 好/ 的/ 连通性/ ,/ 使得/ 各个/ 处理器/ 核在/ 软件/ 流水/ 调度/ 过程/ 中有/ 很/ 好/ 的/ 数据/ 访问/ 局部性/ ,/ 加速/ 比/ 就/ 相对/ 较/ 好/ ./ COStream/ 用/ MKP/ 对/ SDF/ 图/ 进行/ 初始化/ 分/ ,/ 根据/ 划分/ 的/ 负载/ 均衡/ 情况/ 对/ 划分/ 结果/ 采用/ 复制/ 分裂/ 算法/ ,/ 增加/ SDF/ 图/ 的/ 任务/ 并行性/ 并/ 调整/ 划分/ 的/ 负载/ ,/ 但/ 通过/ 这种/ 方式/ 影响/ 划分/ 结果/ 的/ 连通性/ ,/ 故对/ 分裂/ 后/ 的/ SDF/ 图/ 再/ 用/ MKP/ 划分算法/ 进行/ 划分/ ,/ 最终/ 得到/ 较/ 好/ 的/ 划分/ 结果/ ,/ 实验/ 结果/ 也/ 证明/ 了/ 该/ 算法/ 的/ 有效性/ ./ 另外/ ,/ 从图/ 13/ 的/ 结果/ 可以/ 看出/ 对于/ FMRadio/ 和/ Vecoder/ 加速/ 效果/ 不太/ 理想/ ,/ 当/ 处理器/ 核/ 数目/ 达到/ 4/ 时/ ,/ 增加/ 处理器/ 核/ 数目/ 不能/ 对/ 程序/ 的/ 性能/ 产生/ 明显/ 的/ 改进/ ,/ 这/ 主要/ 是/ 由/ 测试程序/ 自身/ 的/ 特性/ 决定/ 的/ ./ 通过/ 分析/ 发现/ 影响/ 加速/ 比/ 主要/ 有/ 下面/ 3/ 个/ 因素/ :/ (/ 1/ )/ 负载/ 均衡/ ./ 在/ 共享/ 存储/ 的/ 多/ 核/ 系统/ 中负载/ 均衡/ 对于/ 数据流/ 程序/ 的/ 执行/ 效率/ 有/ 非常/ 重要/ 的/ 影响/ ,/ 如果/ 计算/ 核上/ 的/ 任务/ 负载/ 不/ 均衡/ ,/ 那么/ 不/ 考虑/ 同步/ 、/ 通信/ 等/ 其它/ 因素/ ,/ 数据流/ 程序/ 的/ 加速/ 效果/ 也/ 不/ 可能/ 达到/ 理想/ 的/ 要求/ ./ (/ 2/ )/ 局部性/ (/ locality/ )/ ./ 任务调度/ 后子/ 图/ 的/ 连通性/ 越差/ ,/ 划分/ 间通信/ 边/ 数目/ 就/ 越/ 多/ ,/ 程序运行/ 时/ 处理器/ 核间/ 就/ 需要/ 频繁/ 地/ 进行/ 数据通信/ ,/ 影响/ 数据/ 的/ 局部性/ ,/ 增加/ 了/ 数据/ 访问/ 延迟/ ,/ 在/ 软件/ 流水/ 时/ 同步/ 开销/ 将会/ 很大/ ,/ 对/ 加速/ 比/ 的/ 影响/ 也/ 会/ 很大/ ./ COStream/ 采用/ 的/ 任务分配/ 策略/ 就是/ 在/ 负载/ 均衡/ 的/ 前提/ 下/ 尽量/ 保证/ 局部性/ ./ (/ 3/ )/ 数据流/ 程序/ 自身/ 的/ 特性/ ,/ 即/ SDF/ 图中/ 通信/ 边/ 的/ 数目/ 和/ actor/ 的/ 负载/ ./ 对于/ FilterBank/ 测试程序/ 7.4/ x/ 的/ 加速/ 比/ 的/ 主要/ 原因/ 就是/ SDF/ 图中/ 各个/ actor/ 的/ 负载/ 几乎/ 是/ 一样/ 的/ 并且/ 通信/ 边/ 的/ 数目/ 相对/ 比较/ 少/ ,/ 这样/ SDF/ 图/ 经过/ COStream/ 划分/ 能够/ 得到/ 具有/ 良好/ 负载/ 均衡/ 和/ 局部性/ 的/ 划分/ 结果/ ,/ 从而/ 得/ 高/ 的/ 加速/ 比/ ;/ 但/ 对于/ FMRadio/ 而言/ ,/ 尽管/ SDF/ 图/ 对应/ 31/ 个/ 节点/ 但/ 各个/ 节点/ 的/ 计算/ 量/ 普遍/ 较/ 小/ ,/ 划分/ 完成/ 后/ 各个/ 核上/ 的/ 计算/ 时间/ 小于/ 核间/ 的/ 同步/ 时间/ ,/ 程序/ 的/ 计算/ 同步/ 比太低/ ,/ 只有/ 4.4/ x/ 的/ 加速/ 比/ ,/ 加速/ 效果/ 没有/ 达到/ 理想/ 要求/ ./ 通信/ 与/ 同步/ 比/ 衡量/ 了/ 测试程序/ 的/ 有用/ 计算/ 和/ 时间/ 开销/ 之间/ 的/ 比例/ ,/ 在/ 一定/ 程度/ 上/ 反应/ 了/ 程序/ 的/ 性能/ ./ 在/ X86/ 环境/ 下/ 采用/ 的/ 是/ 软件/ 流水/ 调度/ 策略/ ,/ 各个/ 并行/ 线程/ 在/ 软件/ 流水/ 调度/ 的/ 每次/ 执行/ 阶段/ 中/ 需要/ 进行/ 一次/ 同步操作/ ,/ COStream/ 采用/ sense/ -/ reversingbarrier/ [/ 19/ ]/ 做/ 核间/ 的/ 同步/ ,/ 保证/ 不同/ 核上/ 的/ actor/ 间/ 的/ 数据/ 依赖/ 关系/ 能够/ 满足/ ./ 各个/ 处理器/ 核/ 的/ 运行/ 时间/ 有/ 计算/ 时间/ 和/ 同步/ 时间/ 两/ 部分/ 组成/ ./ 图/ 14/ 给出/ 了/ 各个/ 测试程序/ 在/ 8/ 个/ 核上/ 的/ 运行/ 时/ 计算/ 同步/ 时间/ 分布/ ./ 从图/ 14/ 可以/ 看出/ ,/ FMRadio/ 和/ Vocoder/ 的/ 计算/ 同步/ 比不太/ 理想/ ,/ 同步/ 开销/ 太/ 大/ ,/ 导致/ 加速/ 比较/ 低/ ;/ 但/ 对于/ FilterBank/ 同步/ 比例/ 只/ 占/ 5/ %/ ,/ 程序执行/ 时/ 具有/ 良好/ 的/ 局部性/ 和/ 负载/ 均衡/ ,/ 从而/ 能够/ 达到/ 高/ 的/ 加速/ 比/ ./ 对比/ 图/ 13/ 可以/ 发现/ 测试程序/ 的/ 计算/ 同步/ 比/ 能够/ 达到/ 较/ 高水平/ 的/ ,/ 程序/ 的/ 加速/ 效果/ 也/ 相对/ 较为理想/ ./ 图/ 14/ 测试程序/ 在/ 8/ 核上/ 运行/ 的/ 计算/ 同步/ 比/ 6/ 相关/ 工作/ 数据流/ 编程/ 模型/ 是/ 针对/ 数据流/ 应用/ 的/ 大规模/ 密集型/ 计算/ 的/ 特点/ 以及/ 多核/ 处理器/ 体系结构/ 特点/ 而/ 设计/ 的/ 一种/ 编程/ 模型/ [/ 16/ ]/ ./ Dennis/ 等/ 人/ [/ 20/ -/ 21/ ]/ 将/ 数据流/ 作为/ 一种/ 编程/ 方法/ 引入/ 程序设计/ 领域/ ,/ 设计/ 了/ 数据流/ 编程语言/ ./ Lee/ 和/ Messerschmitt/ [/ 12/ ]/ 扩展/ 了/ 数据流/ 模型/ ,/ 提出/ 了/ 粗粒度/ 同步/ 数据流/ 模型/ ./ MIT/ 的/ Thies/ 等/ 人/ [/ 5/ ]/ 基于/ JAVA/ 采用/ 同步/ 数据流/ 模型/ 针对/ RAWPage12/ 设计/ 了/ StreamIt/ 数据流/ 编程语言/ ,/ StreamIt/ 计算/ 节点/ Filter/ 只/ 支持/ 单/ 输入/ 单/ 输出/ 流/ ,/ 程序/ 构造/ 存在/ 不/ 直观/ 不易/ 编写/ 等/ 问题/ ,/ 影响/ 编程人员/ 的/ 编程/ 效率/ ./ 另外/ ,/ StreamIt/ 中流/ 的/ 类型/ 只能/ 是/ 单一/ 的/ 基本/ 类型/ ,/ 对于/ 复合/ 类型/ 支持/ 不够/ ,/ 对于/ 处理/ 复杂/ 的/ 结构化/ 数据/ 在/ 处理/ 上/ 存在/ 一定/ 的/ 局限性/ ./ 数据流/ 程序/ 的/ 在/ 多/ 核/ 架构/ 上/ 的/ 并行/ 编译/ 优化/ 也/ 被/ 广泛/ 的/ 研究/ ./ Gordon/ 等/ 人/ [/ 22/ ]/ 针对/ Raw/ 采用/ 分裂/ 融合/ 的/ 方法/ 对/ StreamIt/ 存在/ 的/ 数据/ 、/ 任务/ 和/ 流水线/ 并行性/ 进行/ 研究/ ;/ Udupa/ 等/ 人/ [/ 23/ ]/ 采用/ 线性规划/ 方法/ 利用/ StreamIt/ 中/ 存在/ 的/ 各个/ 可/ 并行性/ ,/ 实现/ 了/ StreamIt/ 在/ GPU/ 上/ 的/ 调度/ ./ Liao/ 等/ 人/ [/ 24/ ]/ 采用/ 了/ 仿射变换/ (/ Affinepartitioning/ )/ 方法/ 将/ Brook/ 映射/ 到/ 多/ 核/ 处理器/ 上/ ./ Brook/ 编程/ 模型/ 是/ Stanford/ 大学/ 超级/ 流/ 计算机/ 项目/ Merrimac/ 设计/ 的/ ,/ 编译/ 优化/ 主要/ 集中/ 在/ 数据/ 级/ 的/ 并行/ 上/ ,/ 缺乏/ 对/ 粗粒度/ 并行/ 的/ 支持/ ./ Wei/ 等/ 人/ [/ 2/ ,/ 8/ ]/ 用/ DFBrook/ 基于/ 层次性/ 存储/ 多核/ 结构/ ,/ 对/ 数据流/ 程序/ 如何/ 在/ 资源/ 受限/ 的/ 环境/ 下/ 构造/ 最佳/ 软件/ 流水线/ 进行/ 研究/ ,/ 但/ 该/ 方法/ 不/ 适合/ 大规模/ 的/ 分布式/ 多核/ 集群/ 环境/ ,/ 且/ DFBrook/ 对大/ 数据量/ 的/ 大规模/ 计算/ 应用/ 编写/ 支持/ 不/ 理想/ ./ 针对/ 上述/ 问题/ ,/ 本文/ 基于/ 多/ // 众核/ 架构/ 提出/ 一种/ 跨平台/ 使用/ 的/ 数据流/ 编程/ 模型/ COStream/ ./ COStream/ 的/ 编译系统/ 利用/ SDF/ 图/ 作为/ 中间/ 表示/ ,/ 根据/ 并行/ 系统/ 的/ 底层/ 特点/ 进行/ 建模/ ,/ 针对/ 不同/ 的/ 底层/ 并行/ 系统/ 进行/ 不同/ 的/ 并行/ 编译/ 优化/ ./ 另外/ ,/ 本文/ 也/ 提出/ 了/ 一种/ 基于/ X86/ 共享/ 存储/ 多核/ 架构/ 下/ 开发/ 数据流/ 程序/ 多种/ 并行性/ 特别/ 是/ 任务/ 并行性/ 、/ 数据/ 并行性/ 以及/ 流水线/ 并行性/ 的/ 编译/ 优化/ 方法/ ./ 7/ 总结/ 本文/ 提出/ 并/ 实现/ 了/ 一种/ 数据流/ 编程/ 模型/ —/ —/ —/ COstream/ 数据流/ 编程语言/ 及其/ 相应/ 的/ 编译系统/ ./ COStream/ 是/ 在/ C语言/ 文法/ 的/ 基础/ 上/ 加入/ 了/ 与/ 数据流/ 相关/ 的/ 文法/ 结构/ :/ composite/ 、/ operator/ 和/ stream/ ,/ 支持/ 数据/ 级/ 并行/ 、/ 任务/ 级/ 并行/ 和/ 流水线/ 并行/ ./ COStream/ 编译器/ 编译/ 过程/ 包括/ 编译器/ 前端/ 、/ 底层/ 结构/ 相关/ 的/ 编译/ 优化/ 和/ 目标/ 代码生成/ ./ 为了/ 验证/ 当前/ 编译系统/ 的/ 有效性/ ,/ 在/ COStream/ 编译系统/ 总体/ 框架/ 的/ 基础/ 上/ 实现/ 了/ 针对/ X86/ 多核/ 架构/ 编译/ 优化/ 方法/ ./ 实验/ 结果表明/ 了/ 方法/ 的/ 有效性/ ./ 本文/ 提出/ 的/ 优化/ 方法/ 主要/ 是/ 针对/ 共享/ 处理器/ 架构/ ,/ 如何/ 设计/ 在/ 分布式/ 环境/ 下/ 的/ 层次性/ 优化/ 方法/ 和/ 面向/ 片上/ 多/ // 众核/ 处理器/ 架构/ 的/ 编译/ 优化/ 方法/ 以及/ 针对/ 共享/ 处理器/ 架构/ 中/ 的/ 层次性/ 存储/ 做/ 优化/ 是/ 将来/ 需要/ 进一步/ 研究/ 的/ 工作/ ./ 

