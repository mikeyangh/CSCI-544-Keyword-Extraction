Page1/ 一种/ 优化/ 关系/ 型/ 溯源/ 信息/ 存储/ 的/ 新/ 方法/ 王黎维/ 1/ )/ 鲍芝峰/ 2/ )/ KOEHLERHenning3/ )/ 周晓方/ 3/ )/ ,/ 4/ )/ SADIQShazia3/ )/ 1/ )/ (/ 武汉大学/ 国际/ 软件/ 学院/ 武汉/ 430072/ )/ 2/ )/ (/ 新加坡国立大学/ 计算机/ 学院/ 新加坡/ 117417/ )/ 3/ )/ (/ 昆士兰/ 大学/ 信息技术/ 与/ 电子/ 工程学院/ 澳大利亚/ 4072/ )/ 4/ )/ (/ 数据/ 工程/ 与/ 知识/ 工程/ 教育部/ 重点/ 实验室/ (/ 中国人民大学/ )/ 北京/ 100872/ )/ 摘要/ 现代/ 数据管理/ 必须/ 处理/ 来源/ 不同/ 、/ 质量/ 各异/ 的/ 数据/ ,/ 因此/ 从/ 系统/ 层面/ 支持/ 数据/ 溯源/ ,/ 让/ 用户/ 了解/ 数据/ 的/ 来源/ 及/ 派生/ 过程/ 成为/ 当前/ 至关重要/ 的/ 一个/ 研究课题/ ./ 基于/ 标注/ 的/ 方法/ 是/ 支持/ 数据/ 溯源/ 的/ 基本/ 方法/ 之一/ ./ 这种/ 方法/ 的/ 主要/ 问题/ 是/ 存储空间/ 开销/ ,/ 因为/ 溯源/ 信息/ 可能/ 会/ 超过/ 实际/ 数据/ 的/ 大小/ ./ 在/ 该文/ 中/ ,/ 作者/ 提出/ 了/ 一个/ 用/ 与/ 查询/ 结构/ 匹配/ 的/ 溯源/ 树来/ 表达/ 和/ 存储/ 溯源/ 信息/ 从而/ 避免/ 数据/ 派生/ 过程/ 中/ 冗余/ 存储/ 的/ 基本/ 框架/ ./ 基于/ 这个/ 框架/ ,/ 作者/ 提出/ 了/ 一系列/ 针对/ 关系/ 型/ 查询/ 的/ 存储/ 优化/ 方法/ ,/ 选择/ 查询/ 树/ 部分/ 节点/ 来/ 存储/ 溯源/ 信息/ ./ 这些/ 优化/ 算法/ 对于/ 查询/ 大小/ 是/ 多项式/ 时间/ ,/ 对于/ 溯源/ 信息/ 大小/ 是/ 线性/ 时间/ ,/ 在/ 溯源/ 信息/ 的/ 跟踪/ 和/ 优化/ 方面/ 均/ 不会/ 产生/ 巨大/ 的/ 开销/ ./ 这一/ 框架/ 是/ 数据/ 溯源/ 研究/ 的/ 一个/ 新思路/ ,/ 有着/ 广泛/ 的/ 应用/ 前景/ ./ 关键词/ 溯源/ 树/ ;/ 溯源/ 表/ ;/ 存储/ 优化/ ;/ 最优/ 削/ 剪/ ;/ 规则/ I/ &/ II/ 削/ 剪/ 1/ 引言/ 随着/ 互联网/ 和/ 数据/ 自动/ 采集/ 设备/ 的/ 快速/ 发展/ ,/ 人们/ 可/ 利用/ 的/ 数据源/ 以及/ 数据量/ 在/ 过去/ 的/ 十多年/ 里成/ 指数/ 倍/ 增长/ ,/ 然而/ ,/ 数据/ 的/ 质量/ 却/ 每况愈下/ ,/ 究其原因/ ,/ 大量/ 数据/ 由/ 传感器/ 网络/ 、/ RFID/ 读入/ 器/ 和/ 机器/ 识别系统/ 生成/ 以及/ 从/ 网上/ 自动/ 收集/ ,/ 数据/ 的/ 完整性/ 、/ 一致性/ 以及/ 正确性/ 无法/ 得到/ 保证/ ./ 而/ 许多/ 科学/ 应用/ 和/ 大规模/ 数据管理/ 应用/ 通常/ 需要/ 收集/ 和/ 处理/ 大量/ 不同/ 来源/ 的/ 数据/ ,/ 数据/ 来源/ 复杂/ ,/ 质量/ 参差不齐/ ,/ 使得/ 这些/ 应用/ 的/ 数据/ 和/ 结果/ 的/ 可信度/ 受到/ 质疑/ ./ 在/ 系统/ 层面/ 上/ 支持/ 数据/ 溯源/ ,/ 提供/ 对/ 数据/ 来源/ 及/ 处理/ 步骤/ 有效/ 方便/ 地/ 查询/ 支持/ 可以/ 帮助/ 用户/ 理解/ 数据/ 和/ 结果/ 的/ 可信度/ [/ 1/ ]/ ./ 数据/ 溯源/ 信息/ (/ provenance/ )/ 描述/ 数据/ 的/ 来源/ 和/ 派生/ 过程/ ,/ 在/ 数据库/ 环境/ 中/ ,/ 数据/ 派生/ 过程/ 是/ 指/ 查询/ 过程/ ,/ 而/ 科学/ 应用环境/ 中/ 的/ 派生/ 过程/ 则/ 可用/ 整个/ 工作/ 流图/ 表示/ ./ 溯源/ 信息/ 对于/ 判断/ 结果/ 的/ 正确性/ 以及/ 可信度/ 至关重要/ [/ 2/ ]/ ./ 在/ 数据库/ 环境/ 中/ ,/ 它/ 可以/ 帮助/ 解释/ 意想不到/ 的/ 结果/ ,/ 并/ 有助于/ 数据/ 集成/ [/ 3/ ]/ ./ 在/ 科学/ 应用环境/ 中/ ,/ 它/ 有助于/ 诊断/ 实验/ 执行/ 过程/ 中/ 的/ 错误/ ,/ 探索/ 未知/ 的/ 实验/ 结果/ [/ 4/ ]/ ./ 在/ 不确定性/ 数据库/ 中/ ,/ 它/ 可以/ 用来/ 追踪/ 概率/ 变量/ 之间/ 的/ 关联/ [/ 5/ ]/ ./ 数据/ 溯源/ 研究/ 从/ 类型/ 上/ 大致/ 分为/ 数据/ 级/ 溯源/ 和/ 过程/ 级/ 溯源/ ,/ 而/ 数据库/ 领域/ 的/ 研究/ 侧重于/ 前者/ [/ 6/ ]/ ./ 从/ 溯源/ 信息/ 的/ 存储/ 粒度/ 上/ 分为/ 粗和细/ 两个/ 粒度/ ./ 在/ 粗粒度/ 层次/ 上/ 完成/ 对/ 溯源/ 信息/ 的/ 追踪/ 时/ ,/ 整个/ 数据/ 集/ 的/ 工作/ 流图/ 或/ 查询/ 过程/ 作为/ 数据/ 派生/ 过程/ 存储/ ./ 在/ 细粒度/ 层次/ 上/ ,/ 每/ 一个/ “/ 对象/ ”/ (/ 可能/ 指在/ 实验/ 中/ 派生/ 的/ 单个/ 结果/ ,/ 或者/ 在/ 数据库/ 中/ 一个/ 元组/ 或/ 属性/ 的/ 值/ )/ 都/ 需要/ 记录/ 与/ 它/ 关联/ 的/ 溯源/ 信息/ ./ 粒度/ 选择/ 往往/ 根据/ 应用/ 需求/ 而定/ ./ 虽然/ 存储/ 粗粒度/ 的/ 溯源/ 信息/ 不必/ 过于/ 关注/ 存储空间/ ,/ 细粒度/ 的/ 溯源/ 信息/ 存储/ 则/ 带来/ 一系列/ 的/ 挑战/ ,/ 因为/ 细粒度/ 溯源/ 信息/ 的/ 空间/ 需求/ 往往/ 远超过/ 实际/ 数据/ 的/ 存储/ 大小/ [/ 7/ ]/ ./ 处理/ 这个/ 问题/ 的/ 方法/ 之一/ 是/ 只有/ 需要/ 数据/ 集/ 的/ 溯源/ 信息/ 时才/ 通过/ 逆/ 过程/ (/ inversion/ )/ 计算/ 出/ 它们/ ,/ 从而/ 避免/ 预先/ 存储/ 溯源/ 信息/ 导致/ 的/ 高昂/ 存储/ 代价/ [/ 8/ ]/ ./ 然而/ 这一/ 方法/ 的/ 缺点/ 是/ 如果/ 没有/ 高效/ 的/ 逆/ 过程/ ,/ 计算/ 代价/ 会/ 很/ 高/ ,/ 同时/ 它/ 也/ 可能/ 需要/ 存储/ 查询/ 中间/ 结果/ 来/ 帮助/ 计算/ 溯源/ 信息/ [/ 9/ ]/ ./ 本文/ 主要/ 关注/ 关系数据库/ 查询/ 中/ 溯源/ 信息/ 有效/ 存储/ 的/ 问题/ ,/ 提出/ 了/ 一个/ 类似/ 于/ 查询/ 树/ 的/ “/ 溯源/ 树/ ”/ 的/ 数据结构/ 用于/ 溯源/ 信息/ 存储/ ./ 在/ 此/ 结构/ 中/ ,/ 具有/ 相同/ 派生/ 过程/ 但/ 不同/ 输入/ 的/ 元组/ 被/ 分/ 在/ 一个组/ ,/ 因此/ 避免/ 有关/ 派生/ 过程/ 信息/ 的/ 冗余/ 存储/ ./ 虽然/ 本文/ 只/ 陈述/ 了/ 关于/ 数据库/ 查询/ 的/ 溯源/ 信息/ 的/ 存储/ 方法/ ,/ 当/ 任意/ 派生/ 过程/ 能/ 表示/ 成树型/ 结构/ 时/ ,/ 这种/ 存储/ 溯源/ 信息/ 的/ 方法/ 也/ 能/ 适用/ ./ 另外/ ,/ 由于/ “/ 溯源/ 树/ ”/ 这种/ 存储/ 结构/ 具有/ 较强/ 的/ 灵活性/ ,/ 文中/ 也/ 探讨/ 了/ 降低/ 溯源/ 信息/ 存储/ 成本/ 的/ 优化/ 方法/ ,/ 即/ 选择/ 查询/ 树中/ 的/ 部分/ 节点/ 而/ 非/ 全部/ 节点/ 来/ 存储/ 溯源/ 信息/ ./ 由于/ 在/ 一个/ 节点/ 中/ 不/ 存储/ 溯源/ 信息/ 可能/ 会/ 导致/ 其它/ 节点/ 溯源/ 信息/ 存储/ 规模/ 的/ 增长/ ,/ 因此/ ,/ 考虑/ 在/ 哪些/ 节点/ 中/ 存储/ 是/ 非常/ 重要/ 的/ ,/ 也/ 是/ 本文/ 论述/ 的/ 重点/ ./ 本文/ 第/ 2/ 节/ 描述/ “/ 溯源/ 树/ ”/ 以及/ 总体/ 框架/ ;/ 第/ 3/ 节/ 讨论/ 选择/ 查询/ 树中/ 的/ 部分/ 节点/ 来/ 存储/ 溯源/ 信息/ 的/ 优化/ 方法/ ;/ 第/ 4/ 节/ 简要/ 概述/ 相关/ 的/ 工作/ ;/ 第/ 5/ 节/ 进行/ 实验/ 测试/ 以及/ 结果/ 分析/ ;/ 第/ 6/ 节/ 总结/ 全文/ ./ 2/ 溯源/ 树/ 本文/ 主要/ 考虑/ 数据库/ 查询/ 的/ 溯源/ 信息/ ./ 溯源/ 信息/ 可以/ 在/ 数据库/ 中以/ 不同/ 粒度/ 的/ 形式/ 存储/ ,/ 即/ 数值/ 粒度/ 、/ 元组/ 粒度/ 或表/ 粒度/ ./ 对于/ 大多数/ 数据库/ 查询/ (/ 不/ 涉及/ 用户/ 自定义/ 函数/ 的/ 查询/ )/ ,/ 数值/ 粒度/ 的/ 溯源/ 信息/ 可以/ 以/ 一种/ 有效/ 的/ 方式/ 从/ 元组/ 粒度/ 的/ 溯源/ 信息/ 派生/ ./ 元组/ 粒度/ 的/ 溯源/ 信息/ 也/ 可以/ 通过/ 重新/ 执行/ 查询/ 从表/ 粒度/ 的/ 溯源/ 信息/ 中/ 派生/ ,/ 或/ 使用/ 文献/ [/ 9/ ]/ 中/ 所述/ 的/ 逆/ 过程/ 派生/ ./ 然而/ ,/ 涉及/ 大/ 数据/ 集/ 和/ 复杂/ 查询/ 时/ ,/ 通过/ 表/ 粒度/ 这种/ 方法/ 计算/ 元组/ 的/ 溯源/ 信息/ 代价/ 比较/ 大/ ,/ 因此/ ,/ 通常/ 存储/ 元组/ 粒度/ 的/ 溯源/ 信息/ ./ 目前/ 已/ 提出/ 了/ 许多/ 不同/ 的/ 方式/ 存储/ 元组/ 粒度/ 的/ 溯源/ 信息/ ,/ 最/ 常用/ 的/ 方法/ 是/ 将/ 数据库/ 查询/ 的/ 子/ 查询/ 作为/ 溯源/ 信息/ 的/ 一部分/ 存储/ ,/ 然而/ ,/ 如果/ 有/ 多个/ 元组/ 共享/ 相同/ 的/ 转换/ 过程/ ,/ 那么/ 在/ 存储空间/ 方面/ 将/ 产生/ 巨大/ 的/ 开销/ ./ 本文/ 通过/ 使用/ 具有/ 嵌套/ 数据类型/ 的/ 树结构/ 来/ 存储/ 溯源/ 信息/ 有效/ 地/ 解决/ 了/ 这个/ 问题/ ./ 定义/ 1/ (/ 溯源/ 类型/ // 元组/ // 表/ )/ ./ 一个/ 溯源/ 类型/ (/ provenancetype/ )/ 是/ 通过/ 基本/ 类型/ tupleID/ 构成/ 的/ 元组/ 类型/ 和/ 集合/ 类型/ 的/ 嵌套/ 而/ 构成/ ./ 它/ 的/ 值域/ 包含/ 对/ 元组/ 的/ 引用/ 和/ 一个/ 特殊/ 的/ 空值/ ⊥/ ./ (/ 1/ )/ tupleID/ 是/ 一个/ 基本/ 溯源/ 类型/ ,/ 简称/ 为/ 基本/ 类型/ ,/ 表示/ 一个/ 基本/ 元组/ 的/ 类型/ ./ (/ 2/ )/ 如果/ T1/ ,/ …/ ,/ Tn/ 是/ 溯源/ 类型/ ,/ 那么/ (/ T1/ ,/ …/ ,/ Tn/ )/ 是/ 一个/ 元组/ 溯源/ 类型/ ,/ 简称/ 为/ 元组/ 类型/ ./ (/ 3/ )/ 如果/ T/ 是/ 一个/ 溯源/ 类型/ ,/ 那么/ {/ T/ }/ 是/ 一个/ 集合/ 溯源/ 类型/ ,/ 简称/ 为/ 集合/ 类型/ ./ Page3/ 一个/ 溯源/ 类型/ 的/ 值/ 被/ 称为/ 溯源/ 元组/ (/ provenancetuple/ )/ ,/ 类型/ 为/ T/ 的/ 溯源/ 元组/ 的/ 集合/ 形成/ 了/ 一个/ 类型/ 为/ T/ 的/ 溯源/ 表/ (/ provenancetable/ )/ ./ (/ 1/ )/ 引用/ 数据/ 元组/ 或者/ 溯源/ 元组/ 的/ 元组/ 和/ ⊥/ 是/ 类型/ 为/ tupleID/ 的/ 溯源/ 元组/ ./ (/ 2/ )/ 如果/ t1/ ,/ …/ ,/ tn/ 分别/ 是/ 类型/ T1/ ,/ …/ ,/ Tn/ 的/ 溯源/ 元组/ ,/ 那么/ (/ t1/ ,/ …/ ,/ tn/ )/ 是/ 类型/ (/ T1/ ,/ …/ ,/ Tn/ )/ 的/ 溯源/ 元组/ ./ (/ 3/ )/ 如果/ t1/ ,/ …/ ,/ tm/ 是/ 类型/ T/ 的/ 所有/ 溯源/ 元组/ ,/ 那么/ {/ t1/ ,/ …/ ,/ tm/ }/ 是/ 类型/ {/ T/ }/ 的/ 溯源/ 元组/ ./ 例/ 1/ ./ ri/ 表示/ 对/ 元组/ 的/ 引用/ ,/ 那么/ (/ r1/ ,/ {/ (/ r2/ ,/ ⊥/ )/ ,/ (/ r3/ ,/ r4/ )/ }/ ,/ {/ {/ r5/ ,/ r6/ ,/ r7/ }/ }/ )/ ,/ 是/ 一个/ 溯源/ 元组/ ,/ 它/ 的/ 溯源/ 类型/ 为/ T/ =/ (/ tupleID/ ,/ {/ (/ tupleID/ ,/ tupleID/ )/ }/ ,/ {/ {/ tupleID/ }/ }/ )/ ./ 表/ 1/ 是/ 一个/ 类型/ 为/ T/ 的/ 溯源/ 表/ ./ r1r2/ 一个/ 数据/ 元组/ 的/ 溯源/ 信息/ 可/ 由/ 一个/ 溯源/ 元组/ 描述/ ./ 由于/ 中间/ 结果/ 表中/ 的/ 所有/ 数据/ 元组/ 都/ 以/ 同样/ 的/ 方式/ 派生/ ,/ 即/ 使用/ 相同/ 的/ 操作/ ,/ 因此/ 相应/ 的/ 溯源/ 元组/ 将/ 拥有/ 相同/ 的/ 溯源/ 类型/ ,/ 所以/ ,/ 可以/ 将/ 他们/ 存储/ 在/ 一个/ 溯源/ 表中/ ./ 所有/ 的/ 中间/ 结果/ 或/ 最终/ 的/ 结果/ 的/ 溯源/ 表/ 形成/ 了/ 一个/ 溯源/ 树/ (/ provenancetree/ )/ ./ 定义/ 2/ (/ 溯源/ 树/ )/ ./ 假设/ 一个/ 拥有/ 节点/ 集/ N/ 和/ 根/ 节点/ R/ 的/ 查询/ 树/ Q/ ,/ Q/ 的/ 一个/ 溯源/ 树/ 表示/ 成/ 一个二元/ 组/ P/ =/ (/ PN/ ,/ PO/ )/ ,/ 其中/ PN/ 是从/ 节点/ N/ 到/ 该/ 节点/ 的/ 溯源/ 表/ 的/ 部分/ 映射/ ,/ 其中/ ,/ N/ 中/ 的/ 叶/ 节点/ (/ 即/ 基本/ 关系/ 表/ )/ 没有/ 被/ 映射/ ./ PO/ 是/ Q/ 中/ 的/ 输出/ 元组/ 到/ PN/ (/ R/ )/ 中/ 的/ 溯源/ 元组/ 的/ 全部/ 映射/ ./ 例/ 2/ 详细/ 阐述/ 了/ 溯源/ 树/ 的/ 定义/ ,/ 其中/ ,/ 一个/ 溯源/ 树/ 不/ 包含/ 数值/ ,/ 只/ 包含/ 对/ (/ 数据/ 或/ 溯源/ )/ 元组/ 的/ 引用/ ./ 图/ 2/ 溯源/ 树/ 这里/ 只/ 存储/ 溯源/ 树/ ,/ 而/ 不/ 存储/ 中间/ 结果/ ./ 例/ 2/ ./ 表/ 2/ 表示/ 关系/ PropertyForRent/ ,/ 其中/ “/ ID/ ”/ 表示/ 引用/ 元组/ 的/ 数据库/ 内部/ 分配/ 的/ 元组/ 号/ ./ IDP/ ./ 1P/ ./ 2P/ ./ 3/ 下面/ 的/ SQL/ 语句/ 选择/ 出租/ 房产/ 多于/ 一处/ 的/ 机/ SELECTp/ ./ BranchNo/ ,/ p/ ./ PropertyNoFROMPropertyForRentp/ ,/ (/ SELECTBranchNo/ ,/ PropertyNoFROMPropertyForRentGROUPBYBranchNoHAVINGcount/ (/ / )/ >/ 1/ )/ sWHEREp/ ./ BranchNo/ =/ s/ ./ BranchNo/ 图/ 1/ 是/ 该/ 查询/ 对应/ 的/ 查询/ 树/ ,/ 括号/ 中/ 的/ 数字/ 构和/ 房产信息/ ./ 〈/ ·/ 〉/ 用于/ 标识/ 节点/ ./ 图/ 2/ 显示/ 了/ 例/ 2/ 执行/ 的/ 中间/ 结果/ 以及/ 对应/ 的/ 溯源/ 树/ ./ 其中/ ,/ 执行/ 的/ 中间/ 结果显示/ 在/ 左边/ 的/ 树/ 中/ ,/ 相应/ 的/ 溯源/ 树/ 显示/ 在/ 右边/ 的/ 树/ 中/ ./ 节点/ 4/ 中/ ID/ 为/ 4.1/ 的/ 元组/ ,/ 它/ 的/ 溯源/ 元组/ 为/ (/ {/ P/ ./ 1/ ,/ P/ ./ 2/ }/ )/ ./ 节点/ 3/ 中/ ID/ 为/ 3.1/ 的/ 元组/ ,/ 它/ 的/ 溯源/ 元组/ 为/ (/ 4.1/ )/ ./ 节点/ 1/ 中/ ID/ 为/ 1.1/ 的/ 元组/ ,/ 它/ 的/ 溯源/ 元组/ 为/ (/ 2.1/ ,/ P/ ./ 1/ )/ ./ Page4/ 定义/ 3/ (/ 完全/ // 冗余/ 树/ )/ ./ 一个/ 溯源/ 树/ P/ 是/ 完全/ (/ complete/ )/ 的/ ,/ 如果/ 每个/ 输出/ 数据/ 元组/ 被/ 映射/ 到/ 一个/ 溯源/ 元组/ 上/ ,/ 并且/ P/ 中/ 的/ 溯源/ 表上/ 的/ 每个/ 不/ 等于/ 空值/ ⊥/ 的/ tupleID/ 类型/ 的/ 数据项/ 引用/ (/ 1/ )/ P/ 中/ 的/ 一个/ 溯源/ 元组/ ,/ 或者/ (/ 2/ )/ 对应/ 于/ 一个/ 叶/ 节点/ 的/ 基本/ 表中/ 的/ 一个/ 元组/ ./ 与/ 输出/ 数据/ 元组/ 不/ 关联/ 的/ 溯源/ 元组/ 被/ 称为/ 冗余/ 元组/ ,/ 即该/ 溯源/ 元组/ 从没/ 被/ 引用/ 过/ ./ 如果/ P/ 中/ 包含/ 任何/ 冗余/ 元组/ 叫树/ P/ 是/ 冗余/ 的/ ,/ 否则/ 就/ 是非/ 冗余/ 的/ ./ 例如/ ,/ 例/ 2/ 中/ 显示/ 的/ 溯源/ 树是/ 完全/ 的/ ,/ 但是/ 冗余/ 的/ ,/ 因为/ 溯源/ 元组/ 4.2/ 没有/ 被/ 引用/ 过/ ./ 本文/ 在/ 以下/ 的/ 论述/ 中将/ 仅仅/ 考虑/ 完全/ 的/ 溯源/ 树/ ./ 2.1/ 溯源/ 树/ 的/ 构造/ 本/ 节/ 描述/ 了/ 一个/ 简单/ 的/ 方法/ 构造/ 完全/ 非/ 冗余/ 的/ 溯源/ 树/ ./ 首先/ 假设/ 使用/ 关系/ 代数/ 操作/ 生成/ 了/ 一个/ 查询/ 树/ ,/ 为了/ 迎合/ 业界/ 的/ SQL/ 标准/ 应该/ :/ (/ 1/ )/ 允许/ 使用/ 任意/ 的/ 选择函数/ ./ (/ 2/ )/ 使用/ 多集/ (/ 允许/ 冗余/ )/ 而/ 不是/ 集合/ ./ 在/ 多集/ 上/ 的/ 投影/ 操作/ 并/ 不能/ 消除/ 冗余/ 元组/ ./ (/ 3/ )/ 引入/ 一个/ 聚集/ 操作/ α/ ,/ 下标/ 表示/ 聚集/ 的/ 属性/ 和/ 分组/ 函数/ ./ (/ 4/ )/ 引入/ 一个/ 替代/ 操作/ β/ ,/ 用/ 一些/ 其它/ 的/ 元组/ 代替/ 关系/ (/ 多集/ )/ 中/ 的/ 每个/ 元组/ ./ 这些/ 扩展/ 不会/ 对/ 溯源/ 信息/ 的/ 存储/ 问题/ 造成/ 影响/ ./ 而/ 集合/ 上/ 的/ 投影/ 操作/ 能/ 表达/ 为先/ 进行/ 多集/ 上/ 的/ 投影/ 操作/ ,/ 然后/ 再/ 对/ 投影/ 之后/ 的/ 结果/ 进行/ 聚集/ 操作/ ./ 并/ 操作/ 和/ 交/ 操作/ 也/ 是/ 多集/ 操作/ 的/ 一种/ ./ 每个/ 操作/ 的/ 初始/ 溯源/ 树/ 都/ 能/ 直接/ 被/ 构造/ ./ 每个/ 操作/ 的/ 溯源/ 类型/ 在/ 以下/ 标出/ ,/ 即/ 与/ 使用/ 这个/ 操作/ 派生/ 的/ 查询/ 结果/ 相关联/ 的/ 溯源/ 表/ 的/ 溯源/ 类型/ ./ (/ 1/ )/ 选择/ (/ selection/ )/ σ/ :/ tupleID/ ;/ (/ 2/ )/ 投影/ (/ projection/ )/ π/ :/ tupleID/ ;/ (/ 3/ )/ 差/ (/ minus/ )/ / tupleID/ ;/ (/ 4/ )/ 替代/ (/ replacement/ )/ β/ :/ tupleID/ ;/ (/ 5/ )/ 并/ (/ union/ )/ ∪/ :/ (/ tupleID/ ,/ tupleID/ )/ ;/ (/ 6/ )/ 连接/ (/ join/ )/ / (/ 7/ )/ 交/ (/ intersect/ )/ ∩/ :/ (/ tupleID/ ,/ tupleID/ )/ ;/ (/ 8/ )/ 聚集/ (/ aggregation/ )/ α/ :/ {/ tupleID/ }/ ./ 本文/ 阐述/ 的/ 溯源/ 的/ 概念/ 与/ 文献/ [/ 6/ ]/ 中/ 的/ 术语/ “/ why/ -/ provenance/ ”/ 非常/ 类似/ ./ 这/ 表示/ 溯源/ 信息/ 需要/ 获取/ 每个/ 输出/ 元组/ 的/ 所有/ 输入/ 元组/ ./ 对于/ 选择/ 、/ 投影/ 、/ 差/ 和/ 替代/ 操作/ ,/ 每个/ 输出/ 元组/ 实际上/ 都/ 是从/ 一个/ 输入/ 元组/ 中/ 计算/ 得到/ ./ 对于/ 连接/ 和/ 多集/ 交/ 操作/ ,/ 每个/ 输出/ 元组/ 由/ 两个/ 输入/ 元组/ 创建/ ./ 对于/ 并/ 操作/ ,/ 一个/ 元组/ 由/ 两个/ 表中/ 的/ 其中/ 一个/ 拷贝/ 得到/ ,/ 通过/ 使用/ 一个二元/ 组/ ,/ 并用/ ⊥/ 值/ 描述/ 另/ 一个/ 源/ 元组/ 的/ 缺失/ ,/ 能/ 结构化/ 的/ 标识/ 一个/ 元组/ 来自/ 哪个/ 输入/ 关系/ ./ 多集/ 交/ 操作/ 能/ 被/ 表达/ 为先/ 进行/ 聚集/ 操作/ 用于/ 消除/ 冗余/ ,/ 然后/ 进行/ 集合/ 交/ 操作/ ./ 对于/ 聚集/ 操作/ ,/ 每个/ 输出/ 元组/ 通过/ 一组/ 输入/ 元组/ 派生/ ,/ 因此/ ,/ 需要/ 将/ 所有/ 这些/ 元组/ 存储/ 起来/ ./ 当然/ ,/ 如果/ 聚集/ 操作/ 是/ 求/ 最大/ 最小值/ ,/ 那么/ 只/ 需要/ 将/ 最大/ 最小/ 的/ 元素/ 存储/ 起来/ 即可/ ./ 总之/ ,/ 执行/ 查询/ 时/ ,/ 首先/ 自/ 底向上/ 构造/ 初始/ 的/ 溯源/ 树/ ./ 然后/ 采用/ 自顶向下/ 的/ 方式/ ,/ 消除/ 多余/ 的/ 溯源/ 元组/ ./ 这种/ 方式/ 获得/ 的/ 溯源/ 树是/ 完全/ 非/ 冗余/ 的/ ,/ 也/ 是/ 进一步/ 优化/ 的/ 出发点/ ./ 例如/ ,/ 将/ 图/ 2/ 中/ 多余/ 的/ 溯源/ 元组/ 4.2/ 删除/ ,/ 便/ 可/ 得到/ 完全/ 非/ 冗余/ 的/ 溯源/ 树/ ./ 2.2/ 溯源/ 树/ 的/ 存储/ 溯源/ 树/ 可以/ 使用/ 支持/ 复杂/ 类型/ ,/ 尤其/ 是/ 支持/ 元组/ 和/ 集合/ 类型/ 嵌套/ 的/ 存储系统/ 直接/ 存储/ ./ 如果/ 需要/ 在/ 关系/ 数据库系统/ 中/ 存储/ 溯源/ 树/ ,/ 即/ 无需/ 使用/ 外部/ 结构/ 直接/ 处理/ 溯源/ 信息/ 的/ 计算/ 、/ 存储/ 和/ 查询/ ,/ 那么/ 可以/ 采用/ 文献/ [/ 10/ ]/ 中/ 类似/ 的/ 方法/ ,/ 将/ 溯源/ 树/ 的/ 节点/ 对应/ 的/ 溯源/ 表/ 映射/ 成/ 关系/ 表/ 的/ 来/ 存储/ 溯源/ 树/ ./ 例如/ ,/ 如果/ 溯源/ 表/ R/ 中有/ 一个/ 元组/ t/ ,/ (/ {/ r1/ ,/ …/ ,/ rk/ }/ )/ 是/ t/ 的/ 溯源/ 信息/ ,/ 也/ 即/ 溯源/ 元组/ ,/ 那么/ ,/ 关系/ 表/ R/ 中将/ 存储/ k/ 个/ 元组/ t1/ ,/ …/ ,/ tk/ ,/ 其中/ 每个/ ti/ 对应/ 一个/ ri/ ,/ 1/ / i/ / k/ ./ 这里/ 的/ ri/ 通过/ 元组/ 的/ 行号/ 来/ 引用/ 元组/ ./ 本文/ 主要/ 探讨/ 的/ 是/ 可以/ 通过/ “/ 溯源/ 树/ ”/ 这种/ 数据结构/ 来/ 存储/ 溯源/ 信息/ ,/ 而/ 不是/ 探讨/ 溯源/ 信息/ 具体/ 的/ 物理/ 存储/ ,/ 且/ 本文/ 的/ 实现/ 主要/ 基于/ Java/ 开发/ 的/ 一个/ 关系/ 查询/ 引擎/ ,/ 因此/ ,/ 本文/ 未/ 着重/ 关注/ 溯源/ 信息/ 的/ 物理/ 存储/ 结构/ ./ 3/ 优化/ 溯源/ 树/ 只/ 在/ 查询/ 树/ 的/ 部分/ 节点/ 而/ 非/ 全部/ 节点/ 中/ 存储/ 溯源/ 信息/ 将会/ 使得/ 存储/ 更/ 高效/ ./ 3.1/ 极端/ 的/ 解决/ 方法/ 当前/ 的/ 应用/ 通常/ 使用/ 两种/ 对立/ 且/ 极端/ 的/ 溯源/ 信息/ 储存/ 方法/ ./ 第/ 1/ 种/ 方法/ 称为/ “/ 存储/ 最终/ ”/ ,/ 它/ 只/ 使用/ 一个/ 溯源/ 表/ 记录/ 最终/ 结果/ 元组/ 与/ 基本/ 元组/ 之间/ 的/ 引用/ 关系/ ./ 第/ 2/ 种/ 方法/ 称为/ “/ 存储/ 全部/ ”/ ,/ 这/ 是/ 另/ 一个/ 极端/ ,/ 因为/ 它/ 为/ 每/ 一个/ 中间/ 结果/ ,/ 即/ 查询/ 树/ 的/ 每个/ 节点/ 都/ 存储/ 一个/ 溯源/ 表/ ./ 一些/ 现有/ 的/ 方法/ 可以/ 归纳到/ 以上/ 的/ 两种/ 类别/ 中/ ./ 这些/ 方法/ 存储/ 每次/ “/ 转换/ ”/ 之后/ 的/ 溯源/ 信息/ ,/ 这些/ 信息/ 是/ 任意/ 粒度/ 的/ [/ 11/ -/ 12/ ]/ ./ 将/ 整个/ 查询/ 作为/ 一个/ 转换/ 等同于/ “/ 存储/ 最终/ ”/ ./ 查询/ 也/ 可以/ 使用/ σ/ ,/ π/ ,/ / 作来/ 构成/ ,/ 如果/ 将/ 每个/ 操作/ 作为/ 一个/ 转换/ ,/ 那么/ 就/ 等同于/ “/ 存储/ 全部/ ”/ ./ 当然/ ,/ 也/ 可以/ 将/ 查询/ 分解成/ 子查/ Page5/ 例/ 4/ ./ 考虑/ 一个/ 查询/ R1/ / 询/ ,/ 对待/ 每/ 一个/ 子/ 查询/ 作为/ 一个/ 转换/ ./ 因此/ ,/ 关键/ 是/ 找到/ 一个/ 很/ 好/ 的/ 分解/ ,/ 将/ 其/ 划成/ 子/ 查询/ ./ 首先/ 要/ 分析/ 存储/ 最终/ 和/ 存储/ 全部/ 在/ 总体/ 性能/ 上/ 都/ 比较/ 差/ ./ 例/ 3/ ./ 考虑/ 一个/ 查询/ σ/ 1/ (/ σ/ 2/ (/ …/ (/ σ/ n/ (/ R/ )/ )/ )/ )/ 由/ n/ 个/ 连续/ 的/ 选择/ 操作/ 构成/ (/ 或者/ 其它/ 具有/ tupleID/ 类型/ 的/ 操作/ )/ ./ 那么/ “/ 存储/ 全部/ ”/ 的/ 方法/ 所/ 需/ 的/ 存储空间/ 是/ “/ 存储/ 最终/ ”/ 的/ n/ 倍/ ./ 以至于/ r1/ 和/ r2/ 分别/ 包含/ n/ 个/ 元组/ ,/ r2/ 中/ 所有/ 的/ 元组/ 被/ 聚集/ 成/ 一个/ 元组/ t2/ ,/ 并且/ r1/ 中/ 所有/ 的/ 元组/ 都/ 和/ t2/ 连接/ ./ 那么/ “/ 存储/ 全部/ ”/ 方法/ 仅仅/ 需要/ 节点/ α/ (/ R2/ )/ 上/ 的/ n/ 个/ 引用/ ,/ 加上/ 最终/ 节点/ R1/ / 用/ ,/ 然而/ ,/ “/ 存储/ 最终/ ”/ 方法/ 需要/ 在/ 最终/ 节点/ 上/ n2/ 个/ 引用/ ./ 因此/ ,/ “/ 存储/ 最终/ ”/ 方法/ 需要/ n/ 存储空间/ ./ 结合/ 以上/ 的/ 两个/ 例子/ ,/ 如/ σ/ 1/ (/ σ/ 2/ (/ …/ (/ σ/ n/ (/ R1/ / α/ (/ R2/ )/ )/ )/ )/ )/ ,/ 两种/ 极端/ 的/ 方法/ 都/ 不能/ 产生/ 很/ 好/ 的/ 结果/ ./ 由于/ 这/ 两种/ 方法/ 总体/ 上/ 都/ 不是/ 很/ 好/ 的/ 解决/ 方法/ ,/ 下面/ 将/ 探讨/ 另/ 一种/ 方法/ ,/ 它/ 只/ 在/ 查询/ 树上/ 的/ 几个/ 但/ 不是/ 所有/ 的/ 节点/ 上/ 存储/ 溯源/ 表/ ./ 这里/ 的/ 关键问题/ 是/ 选择/ 哪些/ 节点/ 存储/ 溯源/ 表/ ./ 3.2/ 基于/ 规则/ 的/ 溯源/ 树削/ 剪/ 对于/ 削/ 剪/ 方法/ ,/ 首先/ 根据/ 2.1/ 节/ 的/ 描述/ 来/ 构造/ “/ 存储/ 全部/ ”/ 的/ 溯源/ 树/ ./ 然后/ 通过/ 将/ 多个/ 表中/ 的/ 溯源/ 图/ 3/ 削/ 剪/ 的/ 溯源/ 树/ 左右两个/ 削/ 剪/ 的/ 溯源/ 树/ 虽然/ 形式/ 不同/ ,/ 但/ 却是/ 同构/ 的/ ,/ 因此/ ,/ 可以/ 将/ 溯源/ 表/ 移动/ 到/ 溯源/ 树上/ 不同/ 的/ 节点/ 中/ 存储/ ,/ 并/ 重新命名/ 引用/ ,/ 但/ 不能/ 改变/ 它/ 的/ 内容/ ./ 为了/ 避免/ 过于/ 复杂/ 的/ 同构/ 的/ 定义/ ,/ 首先/ 将/ 溯源/ 树/ 转换成/ 引用/ 树/ (/ referencetree/ )/ ,/ 然后/ 定义/ 引用/ 树/ 之间/ 的/ 同构/ 概念/ ./ 定义/ 4/ (/ 子/ 类型/ // 子/ 元组/ )/ ./ 溯源/ 类型/ (/ 元组/ )/ 之间/ 的/ 子/ 类型/ (/ 子/ 元组/ )/ 关系/ </ P/ (/ </ T/ )/ 是/ 以下/ 规则/ 的/ 传递/ 扩展/ ./ 信息/ 合并/ 为/ 一个/ 溯源/ 表来/ 改进/ 它/ ./ 通过/ 复制/ 溯源/ 元组/ ,/ 而/ 不是/ 引用/ 它们/ 来/ 合并/ 溯源/ 表/ ,/ 显然/ 有益于/ 存储空间/ ./ 这/ 就/ 引入/ 了/ 以下/ 规则/ ./ 规则/ I/ ./ 当/ 一个/ 溯源/ 表中/ 的/ 所有/ 元组/ 最多/ 被/ 引用/ 一次/ 时/ ,/ 复制/ 所有/ 元组/ 的/ 溯源/ 信息/ 而/ 不是/ 引用/ 它们/ ./ 规则/ II/ ./ 当/ 引用/ 一个/ tupleID/ 类型/ 的/ 溯源/ 表时/ (/ 即/ 被/ 引用/ 的/ 元组/ 只/ 包含/ 一个/ 引用/ )/ ,/ 复制/ 被/ 引用/ 元组/ 的/ 溯源/ 信息/ ./ 规则/ I/ 表示/ 不/ 引入/ 任何/ 冗余/ ,/ 并/ 避免/ 存放/ 额外/ 的/ 溯源/ 表/ ./ 考虑/ 规则/ II/ 的/ 原因/ 是/ 引用/ 一个/ tupleID/ 类型/ 的/ 溯源/ 信息/ 不会/ 比/ 复制/ 它/ 所用/ 的/ 存储空间/ 更/ 小/ ,/ 同时/ 也/ 避免/ 了/ 存储/ 额外/ 的/ 溯源/ 表/ ./ 引用/ 被/ 复制/ 后/ ,/ 立即/ 删除/ 不再/ 被/ 引用/ 的/ 溯源/ 元组/ ,/ 也/ 就是/ 不/ 与/ 输出/ 元组/ 对应/ 的/ 元组/ ./ 构建/ 削/ 剪/ 的/ 溯源/ 树/ 的/ 方法/ 一般/ 包括/ 3/ 个/ 步骤/ :/ 1/ ./ 构造/ 初始/ 的/ 溯源/ 树/ ./ 2/ ./ 移除/ 不/ 被/ 引用/ 的/ 溯源/ 元组/ ./ 3/ ./ 使用/ 规则/ I/ 和/ 规则/ II/ 合并/ 溯源/ 表/ ./ 对于/ 最后/ 一步/ ,/ 规则/ I/ 和/ II/ 可以/ 以/ 不同/ 的/ 顺序/ 应用/ ,/ 这/ 导致/ 了/ 不同/ 的/ 结果/ ./ 根据/ 2.1/ 节/ ,/ 初始/ 的/ 溯源/ 树是/ 完全/ 非/ 冗余/ 的/ ,/ 因此/ ,/ 将/ 图/ 2/ 中/ 的/ 溯源/ 元组/ 4.2/ 删除/ 后/ 得到/ 的/ 是/ 初始/ 的/ 溯源/ 树/ ,/ 再/ 对/ 该/ 树以/ 不同/ 的/ 顺序/ 应用/ 规则/ I/ 和/ II/ ,/ 可以/ 得到/ 图/ 3/ 中/ 显示/ 的/ 两个/ 削/ 剪/ 的/ 溯源/ 树/ ./ 其中/ ,/ 左面/ 的/ 树/ 是/ 先/ 应用/ 规则/ II/ 得到/ 的/ ,/ 而/ 右边/ 的/ 树/ 是/ 先/ 应用/ 规则/ I/ 得到/ 的/ ./ (/ 1/ )/ pi/ </ P/ (/ p1/ ,/ …/ ,/ pn/ )/ ;/ (/ 1/ )/ ti/ </ T/ (/ t1/ ,/ …/ ,/ tn/ )/ ;/ (/ 2/ )/ p/ </ P/ {/ p/ }/ ;/ 如果/ 一个/ 子/ 类型/ (/ 元组/ )/ 直接/ 遵循/ 以上/ 规则/ ,/ 而/ 不是/ 通过/ 传递/ 扩展/ 得到/ ,/ 那么/ 称/ 它/ 为/ 直接/ 子/ 类型/ (/ 元组/ )/ ./ 定义/ 5/ (/ 引用/ 树/ )/ ./ 溯源/ 树/ P/ 的/ 引用/ 树是/ 一个/ 有/ 向/ 无/ 环图/ (/ DAG/ )/ ,/ 它/ 由/ 以下/ 方式/ 构建/ ./ 每个/ 被/ 引用/ 的/ 基本/ 元组/ 为/ 一个/ 节点/ ./ 对/ 每个/ 溯源/ 元组/ t/ 增加/ 一个/ 节点/ ,/ 节点/ 上/ 标记/ 它/ 所在/ 溯源/ 表/ 的/ 位置/ ,/ 同时/ ,/ Page6/ 为/ t/ 的/ 每个/ 子/ 元组/ 增加/ 一个/ 无/ 标号/ 的/ 节点/ ./ 最后/ ,/ 在/ 每个/ 被/ 引用/ 的/ 元组/ 和/ 引用/ 它/ 的/ 元组/ 之间/ 增加/ 一条/ 弧/ ,/ 同时/ 也/ 为/ 每个/ 直接/ 子/ 元组/ 关系/ 增加/ 弧/ ./ 对于/ 形式/ (/ 1/ )/ 中/ 的/ 直接/ 子/ 元组/ 关系/ ,/ 用子/ 元组/ 在/ 溯源/ 元组/ t/ 中/ 的/ 相应/ 的/ 位置/ i/ 来/ 标记/ 弧/ ./ 将/ 图/ 3/ 中削/ 剪/ 的/ 溯源/ 树/ 转换成/ 了/ 引用/ 树/ ,/ 如图/ 4/ 所示/ ./ 虽然/ 在/ 图/ 4/ 中/ ,/ 无/ 标记/ 的/ 节点/ ·/ 似乎/ 是/ 没/ 必要/ 的/ ,/ 但是/ ,/ 当/ 溯源/ 元组/ 包含/ 嵌套/ 的/ 集合/ 类型/ 时/ 却/ 非常/ 重要/ ./ 例如/ ,/ (/ {/ tupleID/ }/ ,/ {/ tupleID/ }/ )/ ./ 定义/ 6/ (/ 同构/ )/ ./ P1/ 和/ P2/ 是/ 同一个/ 查询/ 树上/ 的/ 两个/ 溯源/ 树/ ,/ 双射/ / :/ tupleID/ →/ tupleID/ 是/ P1/ 和/ P2/ 的/ 同构/ 映射/ ,/ 如果/ (/ 1/ )/ / 是/ P1/ 和/ P2/ 的/ 引用/ 树/ 之间/ 的/ 一个/ 图同构/ 映射/ ,/ 其中/ P1/ 和/ P2/ 的/ 引用/ 树/ 保留/ 弧/ 标记/ 且/ 与/ 节点/ 标记/ 相容/ ,/ 即/ 节点/ 有/ 相同/ 的/ 标记/ ./ 节点/ 有/ 相同/ 的/ 标记/ 当且/ 仅/ 当/ 通过/ / 的/ 映射/ ,/ 两/ 节点/ 同像/ ;/ (/ 2/ )/ / 固定/ 基本/ (/ 输入/ )/ 元组/ ,/ 并且/ 每个/ 输出/ 元组/ t/ 被/ 映射/ 到/ 相应/ 的/ 溯源/ 元组/ :/ / (/ P1/ (/ t/ )/ )/ =/ P2/ (/ t/ )/ ./ 如果/ 存在/ 一个/ 这样/ 的/ / ,/ 那么/ 称/ P1/ 和/ P2/ 是/ 同构/ 的/ ./ 容易/ 看出/ 同构/ 是/ 一个/ 等价关系/ ,/ 如果/ / 12/ 是/ P1/ 和/ P2/ 的/ 同构/ 映射/ ,/ / 23/ 是/ P2/ 和/ P3/ 的/ 同构/ 映射/ ,/ 那么/ / 23/ / / 12/ 是/ P1/ 和/ P3/ 的/ 同构/ 映射/ ./ 定理/ 1/ ./ P/ 是/ 一个/ 溯源/ 树/ ./ 以/ 任意/ 的/ 顺序/ 应用/ 规则/ I/ 和/ 规则/ II/ 削/ 剪/ P/ ,/ 直到/ 不能/ 再/ 应用/ 任何/ 规则/ 为止/ ,/ 那么/ 由此/ 产生/ 的/ 削/ 剪/ 的/ 溯源/ 树是/ 同构/ 的/ ./ 证明/ ./ 规则/ I/ 和/ II/ 的/ 应用/ ,/ 可以/ 被/ 看作/ 是/ 同构/ 的/ 溯源/ 树上/ 的/ 削/ 剪/ 步骤/ ./ 根据/ 著名/ 的/ Church/ -/ Rosser/ 定理/ [/ 13/ ]/ ,/ 当/ 两个/ 不同/ 的/ 削/ 剪/ 步骤/ 应用/ 到/ 同构/ 的/ 溯源/ 树上/ 并/ 由此/ 产生/ 不同/ 的/ 溯源/ 树时/ ,/ 可以/ 通过/ 进一步/ 应用/ 削/ 剪/ 步骤/ 使/ 它们/ 达到/ 同构/ ./ 每/ 一个/ 削/ 剪/ 步骤/ (/ 即/ 规则/ I/ 和/ II/ 的/ 应用/ )/ 与/ 一个/ 非空/ 的/ 溯源/ 表/ 相关联/ ,/ 并且/ 应用/ 削/ 剪/ 步骤/ 到/ 相应/ 的/ 溯源/ 表/ 保留/ 了/ 溯源/ 树/ 之间/ 的/ 同构/ 关系/ ./ 接下来/ 对/ 一个/ 溯源/ 树/ 进行/ 削/ 剪/ ,/ 使/ 之/ 产生/ 一个/ 不同/ 但/ 同构/ 的/ 溯源/ 树/ ./ 现在/ ,/ 假设/ P1/ 和/ P2/ 是/ 两个/ 同构/ 的/ 溯源/ 树/ ,/ δ/ 1/ 、/ δ/ 2/ 是/ 两个/ 分别/ 应用/ 到/ P1/ 和/ P2/ 中/ 的/ 溯源/ 表/ T1/ 、/ T2/ 上/ 的/ 削/ 剪/ 步骤/ ./ 如果/ T1/ 和/ T2/ 不/ 邻近/ ,/ 也/ 就/ 表示/ T1/ 和/ T2/ 之间/ 没有/ 直接/ 引用/ 关系/ ,/ 那么/ δ/ 1/ 和/ δ/ 2/ 并/ 不/ 冲突/ ,/ 即/ δ/ 1/ 的/ 应用/ 不会/ 阻碍/ 随后/ δ/ 2/ 的/ 应用/ ,/ 反之亦然/ ./ 因此/ ,/ 应用/ δ/ 2/ 到/ δ/ 1/ (/ P1/ )/ 以及/ 应用/ δ/ 1/ 到/ δ/ 2/ (/ P2/ )/ 可以/ 获得/ 同构/ 的/ 溯源/ 树/ ./ 最后/ ,/ 假设/ T1/ 和/ T2/ 邻近/ ,/ 且/ T1/ →/ T2/ ./ 如果/ T1/ 中/ 的/ 每个/ 元组/ 仅/ 被/ 引用/ 一次/ (/ δ/ 1/ 使用/ 规则/ I/ )/ ,/ δ/ 2/ 的/ 应用/ 不/ 可能/ 改变/ 这个/ 性质/ ,/ 所以/ δ/ 1/ 和/ δ/ 2/ 并/ 不/ 冲突/ ./ 同样/ 的/ ,/ 如果/ T2/ 的/ 溯源/ 类型/ 是/ tupleID/ (/ δ/ 2/ 使用/ 规则/ II/ )/ ,/ δ/ 1/ 的/ 应用/ 也/ 不能/ 改变/ 这个/ 性质/ ,/ 因此/ δ/ 1/ 和/ δ/ 2/ 仍然/ 是/ 不/ 冲突/ 的/ ./ 同理/ ,/ 应用/ δ/ 2/ 到/ δ/ 1/ (/ P1/ )/ 以及/ 应用/ δ/ 1/ 到/ δ/ 2/ (/ P2/ )/ 可以/ 获得/ 同构/ 的/ 溯源/ 树/ ./ 还/ 需要/ 考虑/ 一种/ 情况/ ,/ 如果/ T1/ 具有/ 类型/ tupleID/ (/ δ/ 1/ 使用/ 规则/ II/ )/ ,/ 同时/ ,/ T2/ 中/ 的/ 每个/ 元组/ 被/ 仅仅/ 引用/ 一次/ (/ δ/ 2/ 使用/ 规则/ I/ )/ ,/ 那么/ ,/ 应用/ 了/ δ/ 1/ 之后/ ,/ T2/ 中/ 的/ 元组/ 可能/ 被/ 引用/ 多次/ ,/ 因此/ ,/ 规则/ I/ 不能/ 被/ 应用/ ./ 同样/ 的/ ,/ 当/ 应用/ 了/ δ/ 2/ 之后/ ,/ 新/ 产生/ 的/ T1/ 不/ 具有/ 类型/ tupleID/ ,/ 因此/ ,/ 规则/ II/ 不能/ 被/ 应用/ ./ 所以/ ,/ δ/ 1/ 和/ δ/ 2/ 是/ 冲突/ 的/ ./ 然而/ ,/ δ/ 1/ (/ P1/ )/ 和/ δ/ 2/ (/ P2/ )/ 已经/ 是/ 同构/ 的/ :/ 与/ 它们/ 相关/ 的/ 同构/ 映射/ / 能/ 被/ 构造/ 成/ / =/ / Δ/ / / ,/ 其中/ / Δ/ 将/ T2/ 中/ 每个/ 元组/ 的/ tupleID/ 类型/ 映射/ 到/ 引用/ 这个/ 元组/ 的/ T1/ 中/ 的/ 元组/ 的/ tupleID/ 类型/ 上/ ./ 削/ 剪/ 一个/ 溯源/ 树/ 可以/ 在/ O/ (/ N/ )/ 时间/ 内/ 完成/ ,/ 其中/ N/ 是/ 初始/ 的/ 溯源/ 树中/ 元组/ 引用/ 的/ 总数/ ./ 3.3/ 最优/ 溯源/ 树/ 削减/ 虽然/ 上面/ 所述/ 的/ 削/ 剪/ 规则/ 算法/ 执行/ 速度/ 快且/ 容易/ 实现/ ,/ 但/ 由此/ 产生/ 的/ 削/ 剪/ 溯源/ 树/ 可能/ 不是/ 最优/ 的/ ./ 3.3/ 节将/ 描述/ 一个/ 多项式/ 时间/ 算法/ ,/ 当/ 溯源/ 树/ 的确/ 是/ 一个/ 树/ ,/ 而/ 不是/ 一个/ 任意/ 的/ DAG/ 时/ ,/ 该/ 算法/ 采用/ 了/ 动态/ 规划/ 方法/ 来/ 寻找/ 最优/ 解/ ./ 查询/ 树中/ 除根/ 和/ 叶/ 节点/ 之外/ 的/ 每个/ 节点/ 都/ 必须/ 考虑/ 是否/ 需要/ 存储/ 溯源/ 表/ ,/ 需要/ 存储/ 的/ 节点/ 称为/ 物化/ 节点/ ./ 这里/ 采用/ tupleID/ 类型/ 的/ 数量/ 来/ 衡量/ 溯源/ 表/ 的/ 大小/ ,/ 因此/ 每个/ 溯源/ 表/ 的/ 大小/ 是/ 指向/ 每个/ 最近/ 的/ 物化/ 的/ 后代/ 节点/ 中/ 元组/ 的/ tupleID/ 数量/ 的/ 总和/ ./ 决定/ 是否/ 物化/ 一个/ 节点/ N/ 时/ ,/ 只/ 需要/ 考虑/ 其/ 最近/ 的/ 物化/ 祖先/ 以及/ 最近/ 的/ 物化/ 后裔/ ,/ 而/ 不必/ 考虑/ 任何/ 兄弟/ 节点/ ,/ 因为/ 祖先/ 的/ 大小/ 将/ 受到/ N/ 的/ 影响/ ,/ 而/ 后裔/ 会/ 影响/ 节点/ N/ 的/ 大小/ ./ 这里/ 称/ 任何/ 非/ 祖先/ 非/ 后代/ 的/ 节点/ 为/ 兄弟/ 节点/ ./ 虽然/ 兄弟/ 节点/ 的/ 物化/ ,/ 可能/ 会/ 影响/ 到/ 一个/ 共同/ 的/ 最近/ 的/ 物化/ 祖先/ 的/ 大小/ ,/ 但/ 这种/ 物化/ 对/ 祖先/ 表/ 大小/ 的/ 影响/ 是/ 相互/ 独立/ 的/ ./ 首先/ 介绍/ 一些/ 概念/ ./ 定义/ 7/ (/ 子树/ )/ ./ T/ 是/ 一个/ 树/ ,/ N1/ ,/ N2/ 是/ T/ 上/ 的/ 节点/ ,/ N1/ 是/ N2/ 的/ 一个/ 祖先/ (/ 考虑/ 每个/ 节点/ 都/ 是/ 它/ 自/ Page7/ 己/ 的/ 祖先/ 和/ 后裔/ )/ ,/ 表示/ 为/ N1/ →/ N2/ ./ 集合/ (/ N1/ ,/ N2/ )/ 包含/ 除/ N1/ 和/ N2/ 之外/ 的/ N1/ 的/ 后裔/ 和/ N2/ 的/ 祖先/ ./ T/ [/ N1/ ]/ 为/ T/ 的/ 子树/ ,/ 包含/ N1/ 的/ 所有/ 后裔/ ,/ 同时/ T/ [/ N1/ →/ N2/ ]/ 为/ T/ [/ N1/ ]/ 的/ 子树/ ,/ 包含/ 所有/ N2/ 的/ 祖先/ 和/ 后裔/ ./ 假设/ T/ 中/ 节点/ 的/ 一个/ 集合/ S/ ,/ 并且/ s1/ ,/ s2/ ∈/ S/ ,/ 如果/ s1/ →/ s2/ ,/ s1/ ≠/ s2/ ,/ 并且/ 不/ 存在/ s/ ∈/ S/ \/ {/ s1/ ,/ s2/ }/ ,/ s1/ →/ s/ →/ s2/ ,/ 那么/ s1/ 是/ s2/ 的/ 直接/ 祖先/ ,/ 表示/ 成/ s1/ →/ ds2/ ./ 例/ 5/ ./ 图/ 5/ 从左到右/ 显示/ 了/ 树/ T/ 以及/ 它/ 的/ 两个/ 子树/ T/ [/ N2/ ]/ 和/ T/ [/ N2/ →/ N5/ ]/ ./ 对于/ S/ =/ {/ N1/ ,/ N4/ ,/ N5/ ,/ N8/ }/ ,/ 节点/ N1/ 是/ N4/ 的/ 直接/ 祖先/ ,/ 是/ N5/ 、/ N8/ 的/ 祖先/ 但/ 非/ 直接/ 祖先/ ./ 定义/ 8/ (/ 部分/ 结果/ )/ ./ P/ 是/ 初始/ 的/ 溯源/ 树/ ,/ N1/ 和/ N2/ 是/ P/ 上/ 的/ 节点/ 且/ N1/ →/ N2/ ./ ref/ (/ N1/ ,/ N2/ )/ 表示/ N1/ 的/ 溯源/ 表对/ N2/ 中/ 的/ 溯源/ 元组/ 引用/ 的/ 数量/ ./ 假设/ 需要/ 物化/ P/ 中/ 节点/ 的/ 一个/ 集合/ ,/ S/ 的/ 代价/ 是/ 如果/ S/ 包含/ 一个/ 子树/ P/ 的/ 根/ 和/ 所有/ 叶/ 节点/ ,/ 那么/ 称/ S/ 对于/ P/ 是/ 有效/ 的/ ./ opt/ (/ N1/ )/ 表示/ 在/ P/ [/ N1/ ]/ 的/ 所有/ 有效/ 的/ 节点/ 集合/ 中/ 最小化/ cost/ (/ S/ )/ 的/ 集合/ S/ ,/ opt/ (/ N1/ ,/ N2/ )/ 表示/ 在/ P/ [/ N1/ →/ N2/ ]/ 的/ 所有/ 有效/ 的/ 节点/ 集合/ 中/ 最小化/ cost/ (/ S/ )/ 的/ 集合/ S/ 且/ S/ ∩/ (/ N1/ ,/ N2/ )/ =/ / ,/ 即/ N1/ 和/ N2/ 之间/ 没有/ 任何/ 物化/ 节点/ ./ 可以/ 将/ opt/ (/ N/ ,/ N/ )/ 简写/ 成/ opt/ (/ N/ )/ ./ 现在/ 需要/ 寻找/ opt/ (/ root/ )/ ,/ 其中/ 的/ root/ 是/ 溯源/ 树/ 的/ 根/ ,/ 即/ 需要/ 寻找/ 一个/ 物化/ 节点/ 集/ 使得/ 溯源/ 信息/ 的/ 存储/ 成本/ 最小/ ./ 定理/ 2/ ./ N1/ 是/ N2/ 的/ 祖先/ ,/ N/ 是/ 一个/ 节点/ ./ (/ 1/ )/ 如果/ N2/ 是/ 一个/ 叶/ 节点/ (/ 基本/ 表/ )/ ,/ 那么/ opt/ (/ N1/ ,/ N2/ )/ =/ {/ N1/ ,/ N2/ }/ ./ (/ 2/ )/ 如果/ N/ 不是/ 一个/ 叶/ 节点/ ,/ 那么/ opt/ (/ N/ )/ =/ opt/ (/ N/ ,/ C1/ )/ ∪/ …/ ∪/ opt/ (/ N/ ,/ Ck/ )/ ,/ 其中/ C1/ ,/ …/ ,/ Ck/ 是/ N/ 的/ 孩子/ 节点/ ./ (/ 3/ )/ 如果/ N1/ ≠/ N2/ 并且/ N2/ 不是/ 一个/ 叶/ 节点/ ,/ 那么/ opt/ (/ N1/ ,/ N2/ )/ =/ {/ N1/ }/ ∪/ opt/ (/ N2/ )/ 或者/ opt/ (/ N1/ ,/ N2/ )/ =/ opt/ (/ N1/ ,/ C1/ )/ ∪/ …/ ∪/ opt/ (/ N1/ ,/ Ck/ )/ ,/ 其中/ C1/ ,/ …/ ,/ Ck/ 是/ N2/ 的/ 孩子/ 节点/ ./ 证明/ ./ (/ 1/ )/ 根据/ 定义/ 8/ ,/ opt/ (/ N1/ ,/ N2/ )/ 一定/ 包含/ 节点/ N1/ 和/ N2/ ,/ 并且/ N1/ 和/ N2/ 之间/ 没有/ 任何/ 物化/ 节点/ ,/ 因为/ ,/ N2/ 是/ 一个/ 叶/ 节点/ ,/ 因此/ opt/ (/ N1/ ,/ N2/ )/ 只/ 包含/ 节点/ N1/ 和/ N2/ ./ (/ 2/ )/ 因为/ N/ 不是/ 一个/ 叶/ 节点/ ,/ 因此/ ,/ 根据/ 定义/ 8/ ,/ opt/ (/ N/ )/ 表示/ 包含/ 根/ 节点/ N/ 和/ N/ 的/ 所有/ 后裔/ 节点/ 集合/ 中/ 最小化/ cost/ (/ S/ )/ 的/ 集合/ S/ ./ 同时/ ,/ opt/ (/ N/ ,/ Ci/ )/ ,/ 1/ / i/ / k/ ,/ 表示/ 包含/ 根/ 节点/ N/ 以及/ Ci/ 的/ 所有/ 后裔/ 节点/ 集合/ 中/ 最小化/ cost/ (/ Si/ )/ 的/ 集合/ Si/ ,/ 并且/ N/ 和/ Ci/ 之间/ 没有/ 任何/ 物化/ 节点/ ,/ cost/ (/ Si/ )/ ·/ ·/ =/ ∑/ si1/ / i/ / k/ ,/ 且/ si1/ 和/ si2/ 是/ N/ ∪/ {/ Ci/ 的/ 所有/ 后裔/ 节点/ 集/ }/ ./ 那么/ cost/ (/ S/ )/ ·/ ·/ =/ ∑/ k/ 可得/ ,/ cost/ (/ S/ )/ ·/ ·/ =/ ∑/ kS1/ ∪/ …/ ∪/ Sk/ ./ (/ 3/ )/ 根据/ 定义/ 8/ ,/ opt/ (/ N1/ ,/ N2/ )/ 是/ 包含/ 节点/ N1/ 以及/ N2/ 的/ 所有/ 后裔/ 节点/ 中/ 的/ 最优/ 解/ ,/ 又/ 因为/ N1/ ≠/ N2/ ,/ 且/ N2/ 不是/ 一个/ 叶/ 节点/ ,/ 如果/ 最优/ 解中/ 包含/ N2/ ,/ 那么/ ,/ opt/ (/ N1/ ,/ N2/ )/ =/ {/ N1/ }/ ∪/ opt/ (/ N2/ )/ ;/ 如果/ 最优/ 解中/ 不/ 包含/ N2/ ,/ 结合/ 定理/ 2/ (/ 2/ )/ ,/ 那么/ opt/ (/ N1/ ,/ N2/ )/ =/ opt/ (/ N1/ ,/ C1/ )/ ∪/ …/ ∪/ opt/ (/ N1/ ,/ Ck/ )/ ./ 这个/ 定理/ 可以/ 转换成/ 算法/ 1/ ,/ 该/ 算法/ 能/ 通过/ 存储/ opt/ (/ N1/ ,/ N2/ )/ 和/ cost/ (/ opt/ (/ N1/ ,/ N2/ )/ )/ ,/ 而/ 不是/ 重新/ 计算/ 来/ 找到/ 最小/ 物化/ 节点/ 集/ ./ 算法/ 1/ ./ DP/ -/ opt/ ./ 输入/ :/ P/ ,/ N1/ ,/ N2/ 输出/ :/ opt/ (/ N1/ ,/ N2/ )/ 1/ ./ 如果/ N2/ 是/ 一个/ 叶/ 节点/ ,/ 那么/ 返回/ {/ N1/ ,/ N2/ }/ ./ 2/ ./ O2/ ·/ ·/ =/ DP/ -/ opt/ (/ P/ ,/ N1/ ,/ C1/ )/ ∪/ …/ ∪/ DP/ -/ opt/ (/ P/ ,/ N1/ ,/ Ck/ )/ ./ 3/ ./ 如果/ N1/ =/ N2/ ,/ 那么/ 返回/ O2/ ./ 4/ ./ O1/ ·/ ·/ =/ {/ N1/ }/ ∪/ DP/ -/ opt/ (/ P/ ,/ N2/ ,/ N2/ )/ ./ 5/ ./ 如果/ cost/ (/ O1/ )/ / cost/ (/ O2/ )/ ,/ 那么/ 返回/ O1/ ./ 6/ ./ 否则/ 返回/ O2/ ./ 引理/ 1/ ./ n/ 表示/ 节点/ 的/ 数量/ ,/ N/ 是/ 初始/ 溯源/ 树中/ 元组/ 引用/ 的/ 数量/ ./ 算法/ 1/ 能/ 在/ O/ (/ n/ ·/ N/ )/ 时间/ 内/ 计算/ 出/ 具有/ 最小/ 存储/ 代价/ 的/ 溯源/ 树/ ./ 证明/ ./ 给定/ 一个/ 节点/ N/ ,/ 以/ 自顶向下/ 的/ 方式/ 计算/ 出/ 节点/ N/ 对/ 任何/ 后裔/ 表/ N/ 中/ 每个/ 元组/ 的/ 引用/ 数量/ ,/ 对/ 每个/ 后裔/ 表/ ,/ 计算/ 总/ 的/ 引用/ 数量/ ,/ 得到/ ref/ (/ N/ ,/ Ν/ )/ ,/ 这/ 需要/ O/ (/ N/ )/ 的/ 时间/ ./ 为/ 所有/ 的/ 祖先/ -/ 后裔/ 对/ 计算/ ref/ (/ N1/ ,/ N2/ )/ 可能/ 需要/ O/ (/ n/ ·/ N/ )/ 时间/ ./ 然后/ ,/ 每次/ 算法/ DP/ -/ opt/ 的/ 调用/ 可/ 在/ 固定/ 时间/ 内/ 进行/ ./ 如果/ 存储/ 算法/ 1/ 的/ 中间/ 计算结果/ ,/ 那么/ 最/ 多/ 需要/ 花费/ O/ (/ n2/ )/ 时间/ 完成/ 算法/ 的/ 调用/ ,/ 将/ 以上/ 3/ 个/ 时间/ 求和/ ,/ 显然/ ,/ O/ (/ n/ ·/ N/ )/ 是/ 算法/ 1/ 完成/ 的/ 时间/ 复杂度/ ./ 以上/ 提出/ 的/ 动态/ 规划/ 方法/ 只/ 适用/ 于树型/ 查询/ 图/ ./ 今后/ 将/ 进一步/ 探讨/ 是否/ 存在/ 优化/ 任意/ 查询/ DAGPage8/ 存储空间/ 最小/ ./ 些/ 削/ 剪/ 规则/ :/ 的/ 一个/ 多项式/ 时间/ 算法/ ./ 3.4/ 对比/ 研究/ 本节/ 将/ 探讨/ 由/ 简单/ 的/ 削/ 剪/ 规则/ 获得/ 溯源/ 表/ 的/ 存储/ 大小/ 是否/ 接近/ 3.3/ 节中/ 的/ 最优/ 解/ ./ 考虑/ 如下/ 存储/ 溯源/ 信息/ 的/ 策略/ :/ (/ 1/ )/ 最优/ 削/ 剪/ ./ 在/ 部分/ 节点/ 上/ 存储/ 溯源/ 表/ ,/ 使得/ (/ 2/ )/ 基于/ 规则/ 的/ 削/ 剪/ ./ 对/ 所有/ 的/ 溯源/ 表/ 应用/ 一/ ①/ 完全/ 削/ 剪/ ./ 仅/ 在/ 根/ 节点/ 上/ 存储/ 溯源/ 表/ ./ ②/ 不削/ 剪/ ./ 在/ 所有/ 节点/ 上/ 存储/ 溯源/ 表/ ./ ③/ 使用/ 规则/ I/ 和/ // 或/ 规则/ II/ 的/ 削/ 剪/ ./ 不同/ 削/ 剪/ 规则/ 之间/ 的/ 区别/ 可能/ 很大/ ,/ 见例/ 3/ 和/ 例/ 4/ ./ 显然/ ,/ 最优/ 的/ 削/ 剪/ 方法/ 至少/ 不能/ 比/ 任何/ 基于/ 规则/ 的/ 削/ 剪/ 方法/ 差/ ./ 为了/ 简化/ 分析/ ,/ 假定/ 存储/ 引用/ 的/ 集合/ (/ 类型/ 为/ {/ tupleID/ }/ 的/ 一个/ 值/ )/ 需要/ 至少/ 相当于/ 一个/ 额外/ 的/ 单独/ 引用/ 的/ 存储空间/ ./ 假设/ 不同/ 的/ (/ 合理/ 的/ )/ 大小/ 可以/ 影响/ 将/ 在/ 以下/ 确立/ 的/ 存储空间/ 因子/ 的/ 范围/ ,/ 但/ 仍然/ 在/ 一个/ 固定/ 的/ 有限/ 边界/ 内/ ./ 定理/ 3/ ./ 基于/ 规则/ II/ 的/ 削/ 剪/ 方法/ 需要/ 少于/ 最优/ 削/ 剪/ 方法/ 2/ 倍/ 的/ 存储空间/ ./ 证明/ ./ 规则/ II/ 应用/ 到/ 溯源/ 树中后/ ,/ 每个/ 被/ 引用/ 的/ 溯源/ 元组/ 都/ 具有/ 元组/ 类型/ 或者/ 集合/ 类型/ ,/ 称/ 这个/ 削/ 剪/ 的/ 溯源/ 树为/ PII/ ./ 考虑/ PII/ 中/ 至少/ 被/ 引用/ 了/ 两次/ 的/ 溯源/ 元组/ ./ 考虑/ 最优/ 削/ 剪/ 方法/ ,/ 删除/ 这样/ 的/ 元组/ 并/ 不能/ 降低/ 整体/ 存储空间/ ,/ 可以/ 假设/ 它们/ 仍/ 出现/ 在/ 最优/ 削/ 剪/ 的/ 溯源/ 树上/ ./ 因此/ ,/ 所有/ 对/ 这些/ 元组/ 的/ 引用/ 也/ 必须/ 出现/ 在/ 最优/ 削/ 剪/ 的/ 溯源/ 树上/ ./ 同样/ ,/ 对/ 基本/ 元组/ 的/ 引用/ 也/ 是/ 不可避免/ 的/ ,/ 称/ 对/ 基本/ 元组/ 的/ 引用/ 或/ 被/ 引用/ 多次/ 的/ 元组/ 的/ 引用/ 为/ 不可避免/ 引用/ ,/ 所有/ 其它/ 引用/ 为/ 可/ 避免/ 引用/ ./ 由于/ PII/ 中/ 每个/ 可/ 避免/ 的/ 溯源/ 元组/ 引用/ 了/ 至少/ 两个/ 其它/ 的/ 元组/ (/ 根据/ 刚才/ 所述/ ,/ 假设/ 集合/ 类型/ 的/ 数据项/ 需要/ 一个/ 额外/ 的/ 单独/ 引用/ 的/ 存储空间/ )/ ,/ 这里/ 可以/ 形成/ 一个/ 引用/ 的/ 有/ 向/ 无/ 环图/ ,/ 其中/ 可/ 避免/ 的/ 引用/ 数量/ 小于/ 不可避免/ 的/ 引用/ 数量/ ./ 因为/ 最优/ 的/ 削/ 剪/ 算法/ 只能/ 消除/ 可/ 避免/ 引用/ ,/ 或者说/ ,/ 通过/ 消除/ 不可避免/ 的/ 引用/ 并/ 不能/ 减少/ 引用/ 总数/ ,/ 那么/ 剩余/ 的/ 引用/ 数量/ 是/ 基于/ 规则/ II/ 削/ 剪/ 算法/ 得到/ 的/ 引用/ 数量/ 的/ 一半/ 以上/ ./ 正如/ 以上/ 所述/ ,/ 仅/ 使用/ 规则/ II/ 已经/ 达到/ 了/ 最优/ 溯源/ 存储/ 的/ 近似/ 2/ 倍/ ./ 在/ 此基础/ 上/ 应用/ 规则/ I/ ,/ 可以/ 进一步/ 减少/ 存储/ 成本/ ,/ 但/ 不/ 降低/ 理论/ 边界/ ./ 4/ 相关/ 工作/ 目前/ ,/ 溯源/ 信息/ 的/ 存储/ 、/ 管理/ 和/ 查询/ 变得/ 越来越/ 重要/ ,/ 涌现/ 了/ 大量/ 的/ 研究/ 工作/ ./ 溯源/ 信息/ 追踪/ 主要/ 包括/ 标记/ (/ annotation/ )/ 和/ 逆/ 过程/ (/ inversion/ )/ 两种/ 方法/ ./ 逆/ 过程/ 主要/ 是/ 应用/ 逆向/ 查询/ 或者/ 逆向/ 函数/ ,/ 由/ 结果/ 数据/ 溯源/ 到/ 其源/ 数据/ ./ 而/ 标记/ 的/ 方法/ 则/ 是/ 将/ 一个/ 数据/ 的/ 派生/ 历史/ 搜集/ 起来/ 作为/ 元/ 数据/ ,/ 与/ 数据/ 一起/ 存放/ 在/ 数据库/ 中/ ./ 这里/ 仅仅/ 给出/ 简要/ 概述/ ,/ 详细/ 的/ 内容/ 请/ 参见/ 文献/ [/ 2/ ,/ 14/ ]/ ./ 4.1/ 溯源/ 的/ 语义/ 对于/ 溯源/ 的/ 语义/ ,/ 文献/ [/ 4/ ,/ 6/ ]/ 分别/ 给出/ 了/ 不同/ 的/ 解释/ ./ 文献/ [/ 6/ ]/ 主要/ 从/ 数据库/ 的/ 角度/ 来/ 定义/ “/ 溯源/ ”/ ,/ 认为/ “/ 溯源/ ”/ 是/ 数据源/ 以及/ 数据/ 如何/ 出现/ 在/ 数据库/ 中/ 的/ 描述/ ,/ 并/ 提供/ 了/ 对/ 溯源/ 语义/ 的/ 分类/ ,/ 将/ “/ Why/ -/ provenance/ ”/ 和/ “/ Where/ -/ provenance/ ”/ 严格/ 区分/ 开/ ,/ 其中/ “/ Why/ -/ provenance/ ”/ 描述/ 了/ 哪些/ 源/ 元组/ 参与/ 了/ 结果/ 元组/ 的/ 派生/ ,/ 例如/ ,/ 为什么/ 元组/ 出现/ 在/ 结果/ 集里/ ,/ “/ Where/ -/ provenance/ ”/ 仅仅/ 提供/ 了/ 对源/ 元组/ 中/ 属性/ 值/ 的/ 引用/ ,/ 描述/ 了/ 结果/ 元组/ 的/ 值/ 从/ 哪里/ 拷贝/ 而来/ ./ 文献/ [/ 4/ ]/ 将/ “/ 溯源/ ”/ 定义/ 成/ 一种/ 元/ 数据/ ,/ 用于/ 记录/ 实验/ 工作/ 流/ 的/ 过程/ ,/ 是/ 对/ 实验/ 过程/ 的/ 标记/ ./ 文献/ [/ 15/ ]/ 提出/ 派生/ 一个/ 数据/ 值/ 所/ 应用/ 的/ 转换/ 过程/ 也/ 同样/ 重要/ ,/ 并/ 引入/ 了/ 基于/ 数据/ 值/ (/ 而/ 不是/ 基于/ 元组/ )/ 的/ “/ Why/ -/ provenance/ ”/ 的/ 变体/ 叫/ “/ What/ -/ provenance/ ”/ ./ 文献/ [/ 14/ ]/ 给出/ 了/ “/ 溯源/ ”/ 的/ 一般性/ 说明/ ,/ 认为/ “/ 溯源/ ”/ 是/ 一个/ 数据/ 的/ 派生/ 信息/ ,/ 它/ 主要/ 包括/ 两个/ 重要/ 的/ 特征/ :/ 派生/ 这些/ 数据/ 的/ 源/ 数据/ 以及/ 经历/ 的/ 转换/ 过程/ ./ 从/ 数据库/ 的/ 角度/ 而言/ ,/ 转换/ 过程/ 也/ 就是/ 查询/ ./ 本文/ 探讨/ 了/ 关系/ 型/ 溯源/ 信息/ 的/ 存储/ 以及/ 元组/ 出现/ 在/ 结果/ 集中/ 的/ 原因/ ,/ 因此/ ,/ 主要/ 关注/ 的/ 是/ “/ Why/ -/ provenance/ ”/ ./ 另外/ ,/ 很多/ 研究/ 工作/ [/ 16/ -/ 19/ ]/ 也/ 将/ 溯源/ 的/ 语义/ 扩展/ 到/ 解释/ 为什么/ 查询/ 的/ 结果/ 集中/ 没有/ 出现/ 所/ 希望/ 的/ 元组/ ./ 4.2/ 标记/ 当前/ ,/ 大部分/ 的/ 溯源/ 信息管理系统/ 采用/ 标记/ 来/ 进行/ 溯源/ 信息/ 的/ 追踪/ ./ 文献/ [/ 10/ ,/ 20/ ]/ 为/ 元组/ 中/ 的/ 每个/ 属性/ 添加/ 一个/ 额外/ 的/ 列/ ,/ 用于/ 存储/ 属性/ 值/ 的/ 标记/ 信息/ ,/ 其中/ 文献/ [/ 10/ ]/ 将/ SQL/ 扩展/ 成/ 了/ 包含/ 标记/ 信息/ 的/ PSQL/ ,/ 允许/ 用户/ 使用/ PSQL/ 说明/ 如何/ 跟踪/ 和/ 迁移/ 标记/ 信息/ ,/ 即/ 执行/ 查询/ 时/ ,/ 源/ 元组/ 属性/ 上/ 的/ 标记/ 信息/ 会/ 自动/ 地/ 迁移/ 到/ 结果/ 元组/ 的/ 相关/ 属性/ 上/ ./ PERM/ [/ 21/ ]/ 将/ 标记/ 的/ 迁移/ 作为/ 常规/ 的/ SQL/ 查询/ 的/ 一部分/ ,/ 通过/ 在/ 关系/ 表中/ 存储/ 额外/ 的/ 溯源/ 属性/ 以及/ 查询/ 重写/ 来/ 实现/ 溯源/ 信息/ 的/ 跟踪/ ./ 文献/ [/ 20/ ]/ 则/ 更/ 深入/ 地/ 探讨/ 了/ 关系/ 代数/ 操作/ 的/ 各种/ 标记/ 信息/ 的/ 迁移/ 规则/ ./ 具体/ 而言/ ,/ 对于/ 选择/ 和/ 投影/ 操作/ ,/ 结果/ 元组/ 上/ 属性/ 值/ 的/ 标记/ 信息/ 也/ 就是/ 源/ 元组/ 上/ 对应/ 的/ 属性/ 值/ ;/ 对于/ 连接/ 操作/ ,/ 结果/ 元组/ 上/ 属性/ 值/ 的/ 标记/ 信息/ 可能/ 来自/ 于/ 多个/ 源/ 元组/ Page9/ 上/ 对应/ 的/ 属性/ 值/ ./ 对于/ 聚集/ 操作/ ,/ 由于/ 聚集/ 操作/ 的/ 结果/ 并非/ 拷贝/ 而/ 来/ ,/ 而是/ 通过/ 计算/ 得到/ ,/ 因此/ ,/ 结果/ 元组/ 上/ 属性/ 值/ 的/ 标记/ 信息/ 来自/ 所有/ 涉及/ 计算/ 它/ 的/ 源/ 元组/ 上/ 的/ 属性/ 值/ ./ 然而/ ,/ 以上/ 这种/ 存储/ 标记/ 信息/ 的/ 方法/ 显然/ 需要/ 非常/ 大/ 的/ 存储空间/ ,/ 通常/ 要/ 超出/ 数据/ 本身/ 的/ 存储/ 大小/ ,/ 并且/ 这种/ 方法/ 仅仅/ 能/ 处理/ 属性/ 级别/ 上/ 的/ 标记/ 信息/ ,/ 而/ 不能/ 处理/ 元组/ 或/ 关系/ 级别/ 上/ 的/ 标记/ 信息/ ./ 在/ 科学/ 应用/ 中/ ,/ GridDB/ [/ 12/ ]/ 也/ 采用/ 了/ 类似/ 的/ 溯源/ 信息/ 跟踪/ 方法/ ,/ 它/ 通过/ 存储/ 每/ 一个/ 处理/ 步骤/ 的/ 标记/ 信息/ ,/ 并/ 使用/ 递归/ 查询/ 来/ 检索/ 源/ 数据/ ./ CHIMERA/ 系统/ [/ 22/ ]/ 以/ 推导/ 图/ 的/ 形式/ 跟踪/ 整个/ 数据/ 集/ 的/ 溯源/ 信息/ ,/ 它/ 使用/ 虚拟/ 数据/ 语言/ 构造/ 工作/ 流/ ,/ 在/ 执行/ 过程/ 中/ ,/ 工作/ 流为/ 每个/ 计算/ 程序/ 自动/ 创建/ 触发/ 对象/ ,/ 触发/ 对象连接/ 输入/ 数据/ 和/ 输出/ 数据/ ,/ 它们/ 一起/ 构成/ 了/ 表示/ 数据/ 派生/ 过程/ 的/ 标记/ 模式/ ,/ 因此/ ,/ 必要/ 时/ 可/ 用于/ 重新/ 生成/ 这些/ 数据/ 集/ ./ 另外/ ,/ 一个/ 通用/ 的/ 用于/ 跟踪/ 和/ 查询/ 溯源/ 信息/ 的/ 半环/ 模型/ 在/ 文献/ [/ 23/ -/ 24/ ]/ 中/ 被/ 提出/ ./ 文献/ [/ 6/ ]/ 以/ 树形/ 结构/ (/ 如/ XML/ )/ 存储/ 溯源/ 信息/ ,/ 并/ 使用/ 根/ 节点/ 到/ 特定/ 数值/ 节点/ 的/ 路径/ 作为/ 溯源/ 信息/ ./ 然而/ ,/ 这个/ 方法/ 并/ 没有/ 探讨/ 溯源/ 信息/ 查询处理/ 的/ 高效性/ 和/ 存储/ 代价/ ./ 和/ 本文/ 的/ 工作/ 类似/ ,/ 文献/ [/ 7/ ]/ 提出/ 了/ 高效/ 的/ 溯源/ 信息/ 存储/ 方法/ ,/ 但/ 目标/ 是/ 要/ 存储/ 科学/ 应用/ 产生/ 的/ 复杂/ 数据/ 的/ 溯源/ 信息/ ./ 由于/ 这些/ 数据/ 具有/ 相似/ 或者/ 相同/ 的/ 结构/ 信息/ ,/ 因此/ 结构/ 继承/ 、/ 可/ 选/ 节点/ 分解/ 等/ 优化/ 技术/ 可/ 用于/ 最小化/ 溯源/ 信息/ 的/ 存储/ ./ 这些/ 优化/ 技术/ 虽然/ 并/ 不适/ 用于/ 数据库/ 查询/ ,/ 但/ 其/ 节点/ 和/ 参数/ 分解/ 技术/ 具有/ 与/ 本文/ 所/ 提出/ 的/ 溯源/ 树/ 存储/ 模型/ 类似/ 的/ 目标/ ./ 文献/ [/ 25/ ]/ 探讨/ 了/ 专业/ 数据库/ 的/ 溯源/ 信息管理/ ,/ 由于/ 专业/ 数据库/ 的/ 内容/ 通常/ 需要/ 专业/ 科学家/ 从/ 不同/ 的/ 数据源/ 中/ 手动/ 拷贝/ ,/ 为了/ 追踪/ 构建/ 专业/ 数据库/ 的/ 用户/ 行为/ (/ 溯源/ 信息/ )/ ,/ 该文/ 提出/ 了/ 自动/ 追踪/ 数据源/ 到/ 目标/ 数据库/ 的/ 方法/ ,/ 将/ 用户/ 行为/ ,/ 也/ 即/ 目标/ 数据/ 的/ 拷贝/ 路径/ 记录/ 在/ 一个/ 溯源/ 表中/ ,/ 并/ 采用/ 多种/ 存储/ 优化/ 技术/ 对此/ 溯源/ 表/ 进行/ 优化/ ./ 显然/ ,/ 该/ 方法/ 跟踪/ 的/ 溯源/ 类型/ 与/ 本文/ 论述/ 的/ 溯源/ 类型/ 非常/ 不同/ ,/ 因此/ 这个/ 优化/ 技术/ 并/ 不适/ 用于/ 解决/ 本文/ 提出/ 的/ 这个/ 问题/ ./ 4.3/ 逆/ 过程/ 逆/ 过程/ (/ 包括/ 逆/ 查询/ 和/ 逆函数/ )/ 从/ 存储/ 角度看/ ,/ 特别/ 对/ 大量/ 细粒度/ 的/ 数据/ 似乎/ 是/ 更佳/ 的/ 选择/ ./ 文献/ [/ 7/ ]/ 中/ 首先/ 探讨/ 了/ 通过/ 逆函数/ 计算/ 溯源/ 信息/ ,/ 而/ 不是/ 将/ 溯源/ 信息/ 预先/ 存储/ 起来/ 的/ 思想/ ./ 逆/ 过程/ 方法/ 虽然/ 减少/ 了/ 细粒度/ 溯源/ 信息/ 的/ 存储/ 代价/ ,/ 但/ 其/ 适用性/ 被/ 限制/ 在/ 具有/ 高效/ 的/ 逆/ 过程/ 中/ ./ 如果/ 没有/ 这样/ 的/ 逆/ 过程/ ,/ 该/ 方法/ 等价/ 于/ 重新/ 执行/ 查询/ ./ 文献/ [/ 26/ ]/ 将/ 与/ 关系数据库/ 查询/ 相关/ 的/ 溯源/ 信息/ 的/ 逆/ 查询/ 显示/ 存储/ 起来/ ,/ 用于/ 实现/ 高效/ 的/ 数据源/ 查询/ ./ 然而/ ,/ 这种/ 方法/ 仅仅/ 当/ 存在/ 这样/ 一个/ 逆/ 查询/ 时才/ 有用/ ./ 文献/ [/ 9/ ]/ 研究/ 了/ 关系/ 型/ ASPJ/ 视图/ 中逆/ 查询/ 用于/ 溯源/ 信息/ 跟踪/ 的/ 方法/ ,/ 其/ 基本/ 思想/ 是/ 通过/ 物化/ 中间/ 结果/ ,/ 确保/ 了/ 逆/ 查询/ 的/ 存在/ ,/ 并/ 利用/ 结果/ 元组/ 中/ 的/ 属性/ 值/ 执行/ 逆/ 查询/ 来/ 跟踪/ 数据源/ ./ 之后/ ,/ 文献/ [/ 3/ ]/ 对此/ 进行/ 了/ 改进/ ,/ 将/ 其/ 扩展/ 到/ 更/ 一般/ 的/ 转换/ 操作/ 中/ ./ 以上/ 的/ 方法/ 使用/ 逆/ 查询/ 作为/ 核心/ ,/ 而/ 不是/ 标记/ ,/ 与/ 本文/ 的/ 工作/ 有/ 很/ 明确/ 的/ 相似之处/ ,/ 物化/ 中间/ 结果/ 类似/ 于/ 本文/ 提出/ 的/ 溯源/ 表/ ./ 与/ 本文/ 方法/ 不同/ 的/ 是/ ,/ 首先/ ,/ 这个/ 方法/ 用/ 属性/ 值/ 而/ 不是/ 元组/ 引用/ 作为/ 溯源/ 信息/ ;/ 其次/ ,/ 这个/ 方法/ 的/ 执行/ 效率/ 取决于/ 结果/ 元组/ 中/ 可用/ 的/ 属性/ 值/ 的/ 多少/ 以及/ 逆/ 查询/ 的/ 关系/ 操作/ 类型/ ;/ 最后/ ,/ 这个/ 方法/ 只有/ 当/ 需要/ 结果/ 元组/ 的/ 溯源/ 信息/ 时/ ,/ 才/ 实时/ 产生/ 逆/ 查询/ ,/ 当/ 数据量/ 很大/ 时/ ,/ 其/ 效率/ 可能/ 不高/ ./ 这个/ 方法/ 和/ 本文/ 所/ 提出/ 的/ 方法/ 都/ 只/ 选定/ 查询/ 树/ 的/ 部分/ 节点/ 存储/ 数据/ ,/ 只是/ 节点/ 的/ 选择/ 策略/ 并不相同/ ,/ 因此/ ,/ 本文/ 中/ 所/ 提到/ 的/ 优化/ 技术/ 可以/ 被/ 纳入/ 文献/ [/ 3/ ,/ 9/ ]/ 的/ 方法/ 中/ ,/ 反过来/ 也/ 一样/ ./ 具体来说/ ,/ 如果/ 需要/ 标识/ 一个/ 元组/ 的/ 源/ 元组/ 的/ 集合/ ,/ 而/ 这个/ 元组/ 是/ 对/ 一些/ 数据/ 值/ 使用/ 聚集/ 方法/ 得到/ 的/ 一个/ 聚集/ 的/ 结果/ ./ 如果/ 这些/ 源/ 元组/ 是/ 基本/ 关系/ 中/ 的/ 元组/ ,/ 采用/ 以上/ 方法/ 可能/ 比/ 维持/ 元组/ 引用/ 集合/ 更/ 高效/ ./ 探讨/ 以上/ 两种/ 方法/ 的/ 混合策略/ 是/ 今后/ 的/ 主要/ 研究/ 工作/ ./ 4.4/ 其它/ 研究/ 一些/ 研究/ 工作/ 将/ 数据/ 值/ 的/ 溯源/ 信息/ 和/ 数据/ 的/ 不确定性/ 结合/ 起来/ ./ TRIO/ 系统/ [/ 11/ ]/ 不仅/ 跟踪/ 数据/ 的/ 溯源/ 信息/ ,/ 也/ 表达/ 数据/ 的/ 不确定性/ ./ 其中/ ,/ 溯源/ 信息/ 在/ 查询/ (/ 或/ 程序运行/ )/ 时/ 被/ 计算出来/ ,/ 然后/ 存储/ 在/ 一个/ 单独/ 的/ 溯源/ 信息/ 关系/ 中/ ,/ 对/ 每个/ 数据/ 元组/ ,/ 存储/ 一个/ 溯源/ 元组/ ./ 关于/ 结合/ 溯源/ 信息/ 和/ 不确定性/ 的/ 进一步/ 的/ 研究/ [/ 5/ ]/ 是/ 基于/ 源/ 数据/ 的/ 概率/ 值/ 和/ 结果/ 元组/ 的/ 溯源/ 信息/ 计算/ 出/ 结果/ 元组/ 正确/ 的/ 概率/ 值/ ./ 以上/ 方法/ 的/ 难点/ 是/ 设计/ 一个/ 包括/ 数据/ 精确性/ 和/ 溯源/ 信息/ 的/ 简单/ 数据模型/ 以及/ 一个/ 扩展/ 的/ SQL/ 查询/ 语句/ 处理/ 数据/ 精确性/ 和/ 溯源/ 信息/ 的/ 管理/ 和/ 查询/ ./ 另外/ ,/ 有些/ 研究/ 工作/ 也/ 使用/ 标记/ 信息/ 来/ 判断/ 数据/ 的/ 可信度/ ./ 文献/ [/ 27/ ]/ 使用/ 标记/ 信息/ 完成/ 不同/ 数据库/ 间/ 可靠/ 数据/ 的/ 迁移/ ,/ 也/ 即源/ 数据库/ 的/ 数据/ 根据/ 映射/ 关系/ 迁移/ 到/ 目标/ 数据库/ 时/ ,/ 需要/ 通过/ 标记/ 信息/ 判断/ 目标/ 数据库/ 是否/ 信任/ 该/ 数据/ ,/ 不/ 信任/ 的/ 数据/ 不能/ 进行/ 迁移/ ./ 同样/ ,/ 在/ 文献/ [/ 28/ ]/ 中/ ,/ 标记/ 信息/ 用于/ 跟踪/ 用户/ 关于/ 数据/ 的/ 信任度/ ./ 文献/ [/ 29/ ]/ 也/ 提出/ 一个/ 模型/ 来/ 追踪/ 用户/ 标记/ 信息/ 的/ 可信度/ ./ Page105/ 实验/ 评估/ 本文/ 实验/ 的/ 目标/ 主要/ 是/ 讨论/ 第/ 3/ 节中/ 提到/ 的/ 不同/ 优化/ 模式/ 下/ 的/ 溯源/ 信息/ 存储/ 需求/ ,/ 它们/ 分别/ 是/ 最优/ 的/ 削/ 剪/ 、/ 使用/ 规则/ I/ 的/ 削/ 剪/ 和/ 使用/ 规则/ II/ 的/ 削/ 剪/ 、/ 不削/ 剪/ 、/ 完全/ 削/ 剪/ ./ 最后/ ,/ 实验/ 评估/ 了/ 溯源/ 信息/ 跟踪/ 和/ 优化/ 方法/ 的/ 效率/ ./ 实验/ 建立/ ./ 本文/ 使用/ Java/ 建立/ 了/ 一个/ 关系/ 查询/ 引擎/ ,/ 它/ 实现/ 了/ 主码/ 和/ 外码/ 属性/ 上/ 的/ Hash/ 连接/ 以及/ 基于/ B/ 树/ 索引/ 的/ 连接/ ,/ 其中/ ,/ 溯源/ 元组/ 和/ 溯源/ 表都/ 是/ 作为/ Java/ 中/ 的/ 一个/ 对象/ 存储/ ./ 因为/ 本文/ 主要/ 评估/ 溯源/ 信息/ 的/ 存储/ 代价/ ,/ 因此/ 目前/ 关系/ 查询/ 引擎/ 的/ 实现/ 还/ 未/ 考虑/ 查询/ 优化/ ./ 该/ 查询/ 引擎/ 支持/ 执行/ 所表/ 3/ 数据/ 集/ conservation/ _/ sts/ (/ cs/ _/ conservation/ _/ status/ ,/ cs/ _/ conservation/ _/ status/ _/ desc/ )/ redlist/ _/ species/ (/ rs/ _/ red/ _/ list/ _/ category/ ,/ rs/ _/ wwf/ _/ species/ _/ id/ )/ cn/ (/ cn/ _/ cn/ ,/ cn/ _/ si/ )/ cs/ (/ cs/ _/ cs/ ,/ cs/ _/ csd/ )/ es/ (/ es/ _/ ec/ ,/ es/ _/ si/ )/ e/ (/ e/ _/ ec/ ,/ e/ _/ en/ ,/ e/ _/ cs/ ,/ e/ _/ rc/ )/ ecoregions/ (/ e/ _/ ecoregion/ _/ code/ ,/ e/ _/ ecoregion/ _/ name/ ,/ rc/ (/ rc/ _/ rc/ ,/ rc/ _/ r/ )/ rs/ (/ rs/ _/ rlc/ ,/ rs/ _/ wsi/ )/ h/ (/ h/ _/ pn/ ,/ h/ _/ hn/ ,/ h/ _/ x/ )/ hosp/ (/ h/ _/ prov/ _/ number/ ,/ h/ _/ hospital/ _/ name/ ,/ h/ _/ xstate/ )/ hm/ (/ hm/ _/ pn/ ,/ hm/ _/ hn/ ,/ hm/ _/ x/ ,/ hm/ _/ mr/ ,/ hm/ _/ np/ )/ 从表/ 3/ 中/ 可以/ 看出/ 所/ 使用/ 的/ 数据/ 集不太大/ ,/ 这/ 是因为/ 实验/ 主要/ 是/ 测试/ 本文/ 所/ 提出/ 的/ 方法/ 的/ 正确性/ 以及/ 不同/ 优化/ 模式/ 下/ 的/ 溯源/ 信息/ 存储/ 代价/ ./ 查询/ 和/ 查询/ 计划/ 是/ 根据/ 实验/ 目的/ 设计/ 的/ ,/ 其/ 目标/ 是/ 获得/ “/ 实际/ ”/ 的/ 查询/ 和/ 避免/ “/ 不好/ ”/ 的/ 查询/ 计划/ ./ 查询/ 的/ 设计/ 主要/ 考虑/ 连接/ 操作/ 和/ 聚集/ 操作/ ,/ 因为/ 这/ 两个/ 操作/ 是/ 影响/ 溯源/ 信息/ 存储/ 代价/ 的/ 主要/ 因素/ ./ 同时/ ,/ 查询/ 计划/ 也/ 只/ 针对/ 树型/ 结构设计/ ,/ 以便/ 于/ 高效/ 地/ 使用/ 算法/ 1/ 计算/ 出/ 最佳/ 的/ 解决方案/ ,/ 并/ 将/ 此/ 作为/ 实验/ 中/ 比较/ 的/ 基准/ ./ 系统/ 原型/ 的/ 源代码/ 、/ 实验/ 中/ 所/ 使用/ 的/ 数据/ 集/ 和/ 查询/ 集在/ 文献/ [/ 30/ ]/ 中/ 可以/ 找到/ ./ 5.1/ 溯源/ 信息/ 的/ 存储/ 代价/ 当/ 评估/ 优化/ 方法/ 的/ 成效/ 时/ ,/ 不/ 直接/ 比较/ 本文/ 的/ 方法/ 与/ 现有/ 的/ 方法/ 对于/ 溯源/ 信息/ 存储/ 的/ 研究/ 结果/ ,/ 其/ 原因/ 如下/ ,/ 首先/ ,/ 有些/ 方法/ 并/ 不是/ 专门/ 为/ 关系/ 查询/ 设计/ 的/ ,/ 如果/ 将/ 查询/ 简单/ 当成/ 工作/ 流/ 的/ 查询/ 会/ 产生/ 巨大/ 的/ 开销/ ,/ 也/ 会/ 使得/ 比较/ 不/ 公平/ ;/ 其次/ ,/ 有些/ 方法/ 也/ 探讨/ 了/ 关系/ 查询/ 的/ 溯源/ 信息/ 的/ 追踪/ ,/ 它们/ 主要/ 使用/ “/ 标记/ ”/ 或/ “/ 逆/ 过程/ ”/ 的/ 方法/ ./ “/ 标记/ ”/ 方法/ 的/ 侧重点/ 并非/ 讨论/ 溯源/ 信息/ 的/ 存储/ ,/ 而是/ 探讨/ 溯源/ 信息/ 的/ 使/ 需/ 的/ SQL/ 风格/ 的/ 查询/ 以及/ 在/ 查询/ 执行/ 过程/ 中/ 溯源/ 树/ 的/ 建立/ ,/ 并且/ 已/ 实现/ 了/ 第/ 3/ 节中/ 提出/ 的/ 所有/ 削/ 剪/ 方法/ ./ 实验/ 运行/ 在/ 2.0/ GHz/ 双核/ 2GBRAM/ 内存/ 的/ Windows7/ 机器/ 上/ ./ 查询/ 引擎/ 返回/ 的/ 查询/ 结果/ 的/ 正确性/ 已/ 通过/ MySQL5/ ./ 1/ 核实/ ./ 数据/ 集/ 和/ 查询/ 集/ ./ 本文/ 选择/ 了/ 两个/ 数据库/ :/ Wildfinder/ 数据库/ (/ www/ ./ worldwildlife/ ./ org/ )/ 和/ 医疗/ 数据/ 集/ (/ www/ ./ medicare/ ./ gov/ )/ ./ 实验/ 采用/ 了/ Wild/ -/ finder/ 数据库/ 的/ 6/ 张表/ ,/ 分别/ 是/ 动物/ 名称/ 表/ cn/ 、/ 动物/ 保护/ 状态表/ cs/ 、/ 动物/ 生态区/ 物种/ 表/ es/ 、/ 动物/ 生态区/ 表/ e/ 、/ 领域/ 表/ rc/ 、/ 濒危/ 物种/ 表/ rs/ ;/ 以及/ 医疗/ 数据/ 集中/ 的/ 2/ 张表/ ,/ 分别/ 是/ 医院/ 名称/ 表/ h/ 、/ 医院/ 死亡率/ 表/ hm/ ./ 详细/ 的/ 数据/ 集见表/ 3/ ./ 表/ 模式/ 用/ 和/ 管理/ ,/ 因此/ ,/ 在/ 存储/ 上/ 是/ 将/ 溯源/ 信息/ 作为/ 数据/ 本身/ 的/ 一部分/ 来/ 存储/ ,/ 根据/ 4.2/ 节/ 的/ 分析/ ,/ 这个/ 方法/ 的/ 弊端/ 显而易见/ ./ 而/ “/ 逆/ 过程/ ”/ 方法/ 虽然/ 其/ 思想/ 与/ 本文/ 有/ 相似之处/ ,/ 但/ 其/ 侧重点/ 也/ 是/ 探讨/ 逆/ 过程/ 的/ 产生/ ,/ 通过/ 逆/ 过程/ 计算/ 出/ 溯源/ 信息/ ,/ 而/ 非/ 溯源/ 信息/ 的/ 存储/ ./ 下面/ 将/ 详细/ 陈述/ 6/ 个/ 有/ 代表性/ 的/ 查询/ 的/ 结果/ ,/ wwf1/ ,/ med1/ ,/ med2/ 为/ 复杂/ 的/ 查询/ ,/ 而/ wwf2/ ,/ wwf3/ ,/ wwf4/ 只是/ 连接/ 查询/ ./ 图/ 6/ 显示/ 了/ 各个/ 查询/ 对应/ 的/ 查询/ 树/ ,/ 为了/ 简单/ 表达/ 查询/ 树/ ,/ 部分/ 投影/ 操作/ 的/ 投影/ 属性/ 以及/ 连接/ 操作/ 的/ 连接/ 属性/ 没有/ 在/ 查询/ 树中/ 具体/ 描述/ ./ 详细/ 的/ 查询/ 集/ 信息/ 可以/ 在/ 文献/ [/ 30/ ]/ 中/ 找到/ ./ 其中/ wwf1/ 主要/ 是/ 查询/ 大洋洲/ 濒危动物/ 的/ 名字/ 、/ 个数/ 、/ 它/ 所属/ 的/ 生态区/ 名字/ 以及/ 保护/ 状态/ ,/ 涉及/ 多达/ 8/ 个/ 投影/ 、/ 2/ 个/ 选择/ 、/ 7/ 个/ 连接/ 和/ 1/ 个/ 聚集/ 操作/ ;/ med2/ 主要/ 是/ 查询/ 病人数/ 不/ 小于/ 100/ 且/ 平均/ 死亡率/ 不/ 小于/ 150/ 的/ 医院/ 名称/ ;/ med2/ 主要/ 是/ 查询/ 因/ 心脏病/ 发作/ 引发/ 死亡率/ 大于/ 平均/ 死亡率/ 的/ 医院/ 名称/ ./ wwf2/ ,/ wwf3/ ,/ wwf4/ 只是/ 分别/ 连接/ Wildfinder/ 数据库/ 中/ 的/ 3/ 张表/ 、/ 5/ 张表/ 和/ 6/ 张表/ ./ Page11/ 图/ 66/ 个样/ 例/ 查询/ 的/ 查询/ 树表/ 4/ 记录/ 了/ 6/ 个/ 查询/ 的/ 溯源/ 树/ 被/ 初始/ 构建/ 时/ ,/ 删除/ 冗余/ 的/ 元组/ 后/ (/ 不削/ 剪/ )/ 、/ 完全/ 削/ 剪/ 、/ 使用/ 规则/ I/ 和/ // 或/ 规则/ II/ 削/ 剪/ 及/ 最优/ 削/ 剪/ 后/ 溯源/ 树/ 的/ 大小/ ./ 溯源/ 树/ 的/ 存储/ 需求/ 可以/ 通过/ 溯源/ 树中/ 的/ 所有/ 溯源/ 表中/ 的/ 元组/ 引用/ 的/ 数量/ 来/ 衡量/ ./ 本文/ 所/ 提出/ 的/ 这种/ 方法/ 的/ 存储空间/ 需求/ 的/ 上/ 下界/ 值/ 可以/ 通过/ 不削/ 剪/ 、/ 完全/ 削/ 剪/ 方法/ 来/ 确定/ ./ 削/ 剪/ 规则/ wwf1wwf2wwf3wwf4med1med2/ 初始/ 的/ 树/ 12091332203224901221765124/ 不削/ 剪/ 41703322032249039340827/ 完全/ 削/ 剪/ 816224912701494109477530/ 规则/ I20682491270149410913609/ 规则/ II30283322032249017521353/ 规则/ I/ &/ II19502491270149410913609/ 最优/ 187516650849810913367/ 从/ 以上/ 的/ 表中/ 我们/ 可以/ 观察/ 到/ :/ (/ 1/ )/ 基于/ 规则/ I/ 及/ II/ 的/ 削/ 剪/ 方法/ 得到/ 的/ 结果/ 往往/ 是/ 接近/ 于/ 最优/ 解/ 的/ ,/ 并且/ 基于/ 规则/ I/ 及/ II/ 的/ 削/ 剪/ 明显/ 优于/ 不削/ 剪/ 和/ 完全/ 削/ 剪/ ./ (/ 2/ )/ 即使/ 单独/ 使用/ 规则/ I/ 的/ 效果/ 并/ 没有/ 进行/ 理论/ 的/ 分析/ 和/ 保证/ ,/ 但/ 在/ 实际/ 中/ ,/ 它/ 往往/ 取得/ 比/ 单独/ 应用/ 规则/ II/ 更好/ 的/ 效果/ ./ (/ 3/ )/ 在/ 许多/ 情况/ 下/ ,/ 基于/ 规则/ I/ 和/ II/ 的/ 解决方案/ 确实/ 能/ 取得/ 最优/ ./ 这/ 主要/ 归因于/ 这个/ 事实/ :/ 出现/ 在/ 实际/ 和/ 本文/ 的/ 查询/ 集合/ 中/ 的/ 大多数/ 连接/ 是/ 键值/ 连接/ ./ (/ 4/ )/ 虽然/ 不削/ 剪会/ 带来/ 明显/ 的/ 开销/ 且/ 难于/ 取得/ 最优/ 解/ ,/ 但/ 开销/ 也/ 不会/ 到达/ 一个/ 极端/ 值/ ,/ 通常/ 是/ 最优/ 解/ 的/ 2/ ~/ 4/ 倍/ (/ 存储/ 代价/ 因子/ 为/ 2/ ~/ 4/ )/ ./ 出现/ 这个/ 稳定性/ 的/ 理由/ 是/ 代价/ 因子/ 的/ 大小/ 被/ 查询/ 树/ 的/ 高度/ 界定/ ./ (/ 5/ )/ 完全/ 削/ 剪/ 有时/ 可以/ 取得/ 最优/ 解/ (/ 简单/ 的/ 查询/ 更/ 容易/ 产生/ )/ ,/ 但/ 也/ 可能/ 会/ 导致/ 极高/ 的/ 存储/ 成本/ ./ 这种/ 极端/ 的/ 情况/ 通常/ 涉及/ 一个/ 聚集/ 操作/ 后面/ 出现/ 一个/ 连接/ 操作/ ./ 除此以外/ ,/ 本文/ 还/ 做/ 了/ 大量/ 的/ 查询/ 测试/ ,/ 完整/ 的/ 查询/ 集在/ 文献/ [/ 30/ ]/ 中/ 可以/ 找到/ ./ 表/ 5/ 给出/ 了/ 整个/ 查询/ 集/ 的/ 测试/ 结果/ ,/ 因为/ 不同/ 的/ 查询/ 对/ 存储/ 溯源/ 信息/ 的/ 空间/ 需求/ 相差/ 很大/ ,/ 因此/ 表/ 5/ 总结/ 了/ 相对/ 于/ 最优/ 解/ 的/ 不同/ 方法/ 的/ 存储空间/ ,/ 同时/ 给出/ 了/ 平均/ 和/ 最大/ (/ 最坏/ 情况/ )/ 的/ 结果/ ./ 规则/ I/ &/ II/ 削/ 剪/ 5.2/ 算法/ 的/ 效率/ 本文/ 还/ 需要/ 测试方法/ 的/ 时间/ 效率/ ./ 前面/ 已经/ 证明/ 了/ 方法/ 的/ 时间/ 复杂度/ 的/ 理论/ 界限/ :/ 所有/ 算法/ 是/ 所/ 访问/ 元组/ 数目/ 的/ 线性/ 或近/ 线性/ 时间/ 算法/ ,/ 是/ 查询/ 树/ 的/ 大小/ ,/ 即/ 节点/ 数量/ 的/ 低阶/ 多项式/ 时间/ 算法/ ./ 对于/ 以上/ 每/ 一个样/ 例/ 查询/ ,/ 可以/ 将/ 时间/ 划分/ 为/ SQL/ 查询/ 执行/ 时间/ 、/ 初始/ 溯源/ 树/ 构建/ 时间/ 以及/ 各种/ 削/ 剪/ 策略/ 的/ 处理/ 时间/ ./ 这/ 6/ 个样/ 例/ 查询/ 的/ 时间/ 如图/ 7/ 所示/ ,/ 时间/ 是/ log/ 规模/ 的/ ./ Page12/ 从图/ 7/ 中/ 我们/ 可以/ 看到/ :/ (/ 1/ )/ 初始/ 溯源/ 树/ 的/ 构建/ 需要/ 与/ 查询/ 执行/ 大致相同/ 的/ 时间/ ./ 这是/ 可以/ 预料/ 的/ ,/ 因为/ 在/ 初始/ 的/ 溯源/ 树中/ 的/ 溯源/ 元组/ 的/ 数量/ 实际上/ 是/ 中间/ 结果/ 和/ 最终/ 结果/ 中/ 数据/ 元组/ 的/ 总数/ ./ (/ 2/ )/ 所有/ 的/ 削/ 剪/ 方法/ 比/ 查询/ 执行/ 花费/ 的/ 时间/ 更/ 少/ ,/ 虽然/ 这/ 主要/ 依赖于/ 查询/ ,/ 但/ 通常/ 查询/ 执行/ 时间/ 是/ 削/ 剪/ 方法/ 所用/ 时间/ 的/ 一个/ 或/ 两个/ 数量级/ ./ 其/ 主要/ 原因/ 是/ 初始/ 溯源/ 树中/ 冗余/ 元组/ 的/ 删除/ 使得/ 时间/ 大大的/ 缩短/ ./ (/ 3/ )/ 最优/ 削/ 剪/ 算法/ 明显/ 比/ 基于/ 规则/ I/ &/ II/ 的/ 削/ 剪/ 算法/ 慢/ ,/ 但/ 从来不/ 会/ 超过/ 一个/ 量级/ ./ 这/ 是因为/ 本文/ 提出/ 的/ 动态/ 编程/ 方法/ 的/ 多项式/ 时间/ 的/ 性质/ 决定/ 的/ ,/ 如/ 引理/ 1/ 所示/ ./ 整个/ 查询/ 集合/ [/ 30/ ]/ 的/ 结果/ 在/ 表/ 6/ 中/ 显示/ ,/ 是/ 以/ 查询/ 执行/ 的/ 代价/ 作为/ 基准/ ,/ 仍然/ 用/ 平均/ 和/ 最大/ (/ 最坏/ 情况/ )/ 的/ 结果/ 来/ 评估/ ./ 结果/ 可以/ 解释/ 为/ 由/ 跟踪/ 或/ 优化/ 溯源/ 信息/ 而/ 间接/ 导致/ 的/ 计算/ 负载/ ./ 本文/ 所/ 提出/ 的/ 优化/ 溯源/ 信息/ 存储/ 的/ 方法/ 是/ 正交/ 于/ 查询/ 执行/ 的/ ,/ 可以/ 无缝/ 地/ 整合/ 到/ 现有/ 的/ 数据库/ 引擎/ 中/ ./ 规则/ I/ &/ II/ 的/ 削减/ 查询/ 执行/ 初始/ 溯源/ 树/ 最优/ 削/ 剪/ 整个/ 实验/ 可以/ 得到/ 以下/ 的/ 结论/ ./ 对于/ 基于/ 削/ 剪/ 的/ 优化/ ,/ 两个/ 比较突出/ 的/ 方法/ 是/ 基于/ 规则/ I/ &/ II/ 的/ 削/ 剪/ 和/ 最优/ 削/ 剪/ ./ 由于/ 计算/ 效率/ 通常/ 不是/ 一个/ 问题/ ,/ 当/ 查询/ 是/ 树型/ 结构/ 时/ ,/ 最优/ 削/ 剪/ 方法/ 的/ 效果/ 最好/ ,/ 而/ 基于/ 规则/ I/ &/ II/ 的/ 削/ 剪/ 方法/ 能/ 取得/ 与/ 最优/ 结果/ 最/ 接近/ 的/ 结果/ ./ 6/ 结论/ 本文/ 介绍/ 了/ 一种/ 关系数据库/ 中/ 溯源/ 信息/ 存储/ 的/ 新/ 方法/ ,/ 即/ 通过/ 一个/ 与/ 查询/ 结构/ 匹配/ 的/ 初始/ 溯源/ 树来/ 表达/ 和/ 存储/ 溯源/ 信息/ ./ 考虑/ 到/ 溯源/ 信息/ 存储/ 代价/ ,/ 本文/ 提出/ 了/ 基于/ 规则/ I/ &/ II/ 的/ 削/ 剪/ 方法/ ,/ 并/ 证明/ 了/ 该/ 方法/ 能/ 达到/ 最优/ 溯源/ 存储/ 的/ 近似/ 2/ 倍/ ,/ 因此/ 能够/ 普遍/ 适用/ 于/ 支持/ 溯源/ 信息/ 的/ 应用/ ./ 此外/ ,/ 本文/ 也/ 提出/ 了/ 一个/ 多项式/ 时间/ 的/ 最优/ 削/ 剪/ 算法/ ,/ 该/ 算法/ 能为/ 树状/ 结构/ 的/ 查询/ 计算/ 出/ 一个/ 最优/ 解/ ./ 实验/ 结果表明/ 本文/ 提出/ 的/ 方法/ 可以/ 显著/ 减少/ 存储/ 需求/ ,/ 同时/ 溯源/ 信息/ 的/ 跟踪/ 和/ 优化/ 的/ 计算/ 开销/ 也/ 是/ 合理/ 的/ ./ 

