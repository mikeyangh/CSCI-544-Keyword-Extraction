Page1/ 单遍/ 数据/ 读取/ 的/ GPU/ 上/ 的/ 多片/ 元/ 效果/ 绘制/ 谢/ 国富/ 1/ )/ ,/ 2/ )/ 王文成/ 1/ )/ 1/ )/ (/ 中国科学院/ 软件/ 研究所/ 计算机科学/ 国家/ 重点/ 实验室/ 北京/ 100190/ )/ 2/ )/ (/ 中国科学院/ 研究生院/ 北京/ 100049/ )/ 摘要/ 在/ GPU/ 上/ 进行/ 多片/ 元/ 效果/ 的/ 绘制/ ,/ 已有/ 的/ 方法/ 往往/ 需要/ 对模型/ 进行/ 多遍/ 的/ 数据/ 读取/ ,/ 以/ 进行/ 片元/ 的/ 有效/ 排序/ ./ 由于/ 往/ GPU/ 传输数据/ 的/ 带宽/ 限制/ ,/ 多遍/ 的/ 数据/ 读取/ 严重/ 制约/ 了/ 绘制/ 效率/ 的/ 提高/ ./ 虽然/ ,/ 随着/ CUDA/ 的/ 出现/ ,/ 已有/ 方法/ 可/ 将/ 数据/ 完全/ 装入/ GPU/ 进行/ 多片/ 元/ 效果/ 的/ 绘制/ ,/ 但/ 受/ 存储空间/ 的/ 限制/ ,/ 难以/ 处理/ 大规模/ 的/ 模型/ ./ 对此/ ,/ 文中/ 提出/ 一种/ 只/ 需要/ 单遍/ 数据/ 读取/ 的/ 绘制/ 方法/ ,/ 即将/ 模型/ 进行/ 凸/ 多面体/ 方式/ 的/ 组织/ ,/ 并/ 依据/ 绘制/ 的/ 需求/ 逐个/ 地/ 将/ 凸/ 多面体/ 传输/ 到/ GPU/ 中/ ,/ 以/ 实现/ 片元/ 的/ 正确/ 排序/ ./ 在/ 这/ 过程/ 中/ ,/ 及时/ 地/ 进行/ 同/ 像素/ 片元/ 的/ 色彩/ 混合/ 操作/ ,/ 以/ 大幅/ 降低/ 片元/ 排序/ 的/ 空间/ 需求/ ,/ 由此/ 可/ 使用/ 更/ 多/ 的/ 光照/ 参数/ 来/ 增强/ 绘制/ 效果/ ./ 实验/ 表明/ ,/ 新/ 方法/ 优化/ 了/ 模型/ 的/ 数据/ 读取/ ,/ 可/ 有效/ 提高/ 绘制/ 速度/ ,/ 即便/ 与/ 基于/ CUDA/ 的/ 一次性/ 装载/ 数据/ 的/ 方法/ 相比/ ,/ 也/ 能/ 提高/ 速度/ ,/ 且/ 能/ 方便/ 地/ 处理/ 大/ 模型/ 和/ 深度/ 层次/ 大/ 的/ 模型/ ./ 关键词/ 图形/ 处理器/ (/ GPU/ )/ ;/ 片元/ 处理/ ;/ 凸/ 多面体/ ;/ 透明/ ;/ 半透明/ 1/ 引言/ 图形/ 处理器/ (/ GraphicProcessingUnit/ ,/ GPU/ )/ 的/ 高效/ 运算/ 能力/ 得到/ 了/ 越来越/ 多/ 的/ 重视/ ./ 其中/ ,/ 利用/ GPU/ 进行/ 多片/ 元/ 效果/ 的/ 绘制/ 是/ 当前/ 图形学/ 方向/ 的/ 重要/ 研究/ 内容/ ,/ 即/ 在/ GPU/ 中/ 如何/ 高效/ 地/ 进行/ 需要/ 片元/ 深度/ 排序/ 操作/ 的/ 3/ 维/ 模型/ 绘制/ ,/ 如/ 透明/ 或/ 半透明/ 绘制/ 、/ 反/ 走样/ 、/ 体/ 绘制/ 、/ 碰撞检测/ 等/ ./ 由于/ GPU/ 不便/ 进行/ 动态/ 的/ 空间/ 分配/ 及/ 它/ 自身/ 计算/ 方式/ 的/ 限制/ ,/ 片元/ 深度/ 排序/ 操作/ 很难/ 在/ GPU/ 中/ 完全/ 实现/ ./ 为此/ ,/ 人们/ 提出/ 了/ 多种/ 方法/ 以/ 解决/ 深度/ 排序/ 的/ 问题/ ,/ 如/ 深度/ 剥离/ 方法/ [/ 1/ ]/ 、/ 双面/ 深度/ 剥离/ 方法/ [/ 2/ ]/ 、/ K/ -/ Buffer/ 方法/ [/ 3/ ]/ 、/ 桶/ 深度/ 剥离/ 方法/ [/ 4/ ]/ 及/ 基于/ CUDA/ 的/ 深度/ 剥离/ 方法/ [/ 5/ ]/ 等/ ./ 对/ 深度/ 层次/ 复杂/ 的/ 模型/ ,/ 这些/ 方法/ 需要/ 进行/ 多遍/ 的/ 数据/ 读取/ ,/ 才能/ 得到/ 有效/ 的/ 片元/ 深度/ 序列/ ./ 由于/ 实际/ 应用/ 中/ 的/ 模型/ 一般/ 都/ 很大/ ,/ 也/ 有/ 较/ 多/ 的/ 深度/ 层次/ ,/ 而往/ GPU/ 中/ 传输数据/ 又/ 很/ 费时/ ,/ 因此/ 数据/ 读取/ 成/ 了/ 制约/ GPU/ 上/ 多片/ 元/ 效果/ 绘制/ 效率/ 的/ 瓶颈/ 之一/ ./ 本文/ 提出/ 一种/ 方法/ ,/ 只/ 需/ 单遍/ 读取/ 模型/ 数据/ 就/ 能/ 在/ GPU/ 中/ 完成/ 多片/ 元/ 效果/ 的/ 绘制/ ./ 其/ 工作思路/ 是/ 将/ 模型/ 进行/ 基于/ 凸/ 多面体/ 方式/ 的/ 组织/ ,/ 以便/ 绘制/ 时/ 可/ 根据/ 视点/ 方位/ 快速/ 地/ 决定/ 往/ GPU/ 传送/ 凸/ 多面体/ 的/ 顺序/ ,/ 以/ 保证/ 多片/ 元/ 绘制/ 所/ 需/ 的/ 片元/ 深度/ 排序/ 能/ 在/ GPU/ 中/ 得到/ 正确/ 的/ 实现/ ./ 新/ 方法/ 基于/ GPU/ 的/ Shader/ 实现/ ,/ 处理/ 简单/ ,/ 占用/ 显存/ 小/ ,/ 特别/ 方便/ 处理/ 大/ 模型/ ./ 实验/ 表明/ ,/ 相比/ 于/ 已有/ 先进/ 方法/ ,/ 我们/ 方法/ 能/ 有效/ 提高效率/ ,/ 并/ 可/ 使用/ 更/ 多/ 的/ 光照/ 参数/ 增强/ 绘制/ 效果/ ./ 比如/ 2010/ 年/ 发表/ 的/ 基于/ CUDA/ 的/ 深度/ 剥离/ 方法/ [/ 5/ ]/ ,/ 虽然/ 只/ 需要/ 将/ 数据/ 装入/ GPU/ 一次/ ,/ 但/ 新/ 方法/ 依然/ 要/ 比/ 它/ 快/ ,/ 并/ 能/ 方便/ 处理/ 它/ 不能/ 处理/ 的/ 大/ 模型/ ,/ 特别/ 是/ 深度/ 层次/ 大/ 的/ 模型/ ./ 由于/ 实践/ 中/ 的/ 模型/ 一般/ 都/ 比较复杂/ ,/ 有/ 较/ 多/ 的/ 深度/ 层次/ ,/ 因此/ 我们/ 的/ 方法/ 更/ 便于/ 实践/ 应用/ ./ 本文/ 在/ 第/ 2/ 节对/ 相关/ 工作/ 进行/ 简要/ 的/ 介绍/ ;/ 在/ 第/ 3/ 节/ 讨论/ 基于/ 凸/ 多面体/ 方式/ 的/ 模型/ 组织/ 方法/ ;/ 然后/ 在/ 第/ 4/ 节/ 介绍/ 针对/ GPU/ 的/ 单遍/ 数据/ 读取/ 的/ 片元/ 深度/ 排序/ ;/ 最后/ 给出/ 实验/ 结果/ 并/ 进行/ 讨论/ 和/ 总结/ ./ 2/ 相关/ 工作/ 很多/ 绘制/ 效果/ 是/ 依赖于/ 模型/ 面片/ 的/ 深度/ 排序/ 的/ ,/ 即/ 对应/ 于/ 一个/ 像素/ 的/ 光线/ 与/ 面片/ 相交/ 的/ 顺序/ 对/ 该/ 像素/ 的/ 色彩/ 有/ 很大/ 的/ 影响/ ,/ 比如/ 反/ 走样/ 、/ 半透明/ 绘制/ 及体/ 绘制/ 等/ ./ 这方面/ 的/ 工作/ 一直/ 是/ 图形学/ 中/ 的/ 重要/ 研究/ 内容/ ,/ 比如/ 早期/ 的/ 基于/ CPU/ 的/ A/ -/ Buffer/ 方法/ [/ 6/ ]/ ,/ 它/ 为/ 每个/ 像素/ 建立/ 一个/ 列表/ 以/ 顺序/ 地/ 存储/ 相关/ 的/ 片元/ ,/ 以/ 有效/ 进行/ 反/ 走样/ 处理/ ./ 但是/ ,/ 每个/ 像素/ 对应/ 的/ 片元数/ 难以/ 事先/ 确定/ ,/ 因此/ 需要/ 存储空间/ 的/ 动态分配/ ,/ 而/ 这/ 难以/ 在/ GPU/ 中/ 实现/ ./ 为/ 有效/ 利用/ 硬件加速/ ,/ 在/ A/ -/ Buffer/ 方法/ 的/ 基础/ 上/ ,/ R/ -/ Buffer/ 方法/ [/ 7/ ]/ 用/ 一个/ 基于/ FIFO/ 队列/ 的/ 再循环/ 帧/ 缓存/ 来/ 排序/ 及/ 存储/ 像素/ 相关/ 的/ 所有/ 片元/ ;/ Z3/ 方法/ [/ 8/ ]/ 则/ 使/ 每个/ 像素/ 存储/ 固定/ 数目/ 的/ 片元/ ,/ 一旦/ 片元数/ 达到/ 一个/ 固定值/ ,/ 就/ 混合/ 两个/ 最/ 邻近/ 的/ 片元/ ./ 但/ 这些/ 方法/ 需要/ 对/ 现有/ 硬件/ 架构/ 进行/ 修改/ ,/ 它们/ 目前/ 只是/ 进行/ 了/ 软件/ 方式/ 的/ 模拟/ ,/ 而/ 没有/ 在/ 当前/ 硬件/ 上/ 实现/ ./ 为/ 能/ 在/ 当前/ 图形/ 硬件/ 架构/ 上/ 实现/ 基于/ 深度/ 排序/ 的/ 绘制/ 效果/ ,/ 深度/ 剥离/ 方法/ [/ 1/ ]/ 提出/ 将/ 模型/ 进行/ 多次/ 的/ 绘制/ ,/ 每次/ 绘制/ 时/ 获得/ 最靠近/ 视点/ 的/ 一层/ 片元/ ,/ 并且/ 这层/ 片元/ 不/ 参加/ 后续/ 的/ 深度/ 比较/ ,/ 由此/ 可/ 实现/ 片元/ 的/ 排序/ ./ 该/ 方法/ 的/ 复杂度/ 与/ 深度/ 层次/ 有关/ ,/ 对于/ 深度/ 层次/ 为/ N/ 的/ 模型/ ,/ 它/ 需要/ 进行/ N/ 次/ 的/ 数据/ 读取/ 与/ 绘制/ 及/ N2/ 次/ 的/ 深度/ 比较/ ./ 为/ 减少/ 数据/ 读取/ 的/ 遍数/ ,/ 双面/ 深度/ 剥离/ 方法/ [/ 2/ ]/ 使用/ GPU/ 中/ 的/ MAX/ // MIN/ 混合/ 拓展/ ,/ 每遍/ 绘制/ 可/ 同时/ 剥离/ 最近/ 和/ 最远/ 的/ 2/ 层片/ 元/ ;/ 而/ 文献/ [/ 9/ ]/ 利用/ GPU/ 中/ 多个/ MultipleRenderTargets/ (/ MRT/ )/ 可/ 同时/ 剥离/ 多个/ 层次/ 的/ 片元/ ./ 但/ 它们/ 依然/ 要/ 多/ 遍地/ 读取/ 模型/ 数据/ ./ 另有/ 一些/ 方法/ 提出/ 新/ 的/ 排序/ 对象/ ,/ 以/ 提高/ 排序/ 计算/ 的/ 效率/ ,/ 比如/ Vis/ -/ Sort/ [/ 10/ ]/ 就/ 针对/ 物体/ 对象/ 进行/ 可见/ 性/ 的/ 深度/ 排序/ ,/ 而/ 不是/ 片元/ ;/ Z/ -/ Batches/ [/ 11/ ]/ 将/ 模型/ 离散/ 化为/ 像素/ 大小/ 的/ 微/ 多边形/ 网格/ (/ Grid/ )/ ,/ 并/ 将/ 这些/ 网格/ 单元/ 划分/ 到/ 不同/ 的/ 深度/ 层次/ ,/ 以便/ 在/ 各个/ 深度/ 层次/ 并行/ 地/ 使用/ 深度/ 剥离/ 方法/ ;/ 而/ 文献/ [/ 12/ ]/ 则/ 提出/ 在/ GPU/ 中/ 对模型/ 进行/ 均匀/ 的/ 体素化/ 划分/ ,/ 以便/ 根据/ 规则/ 数据/ 场/ 的/ 性质/ 进行/ 便捷/ 的/ 排序/ 计算/ ./ 但/ 为/ 绘制/ 高质量/ 的/ 多片/ 元/ 效果/ ,/ 这些/ 方法/ 还是/ 要/ 对模型/ 数据/ 进行/ 多遍/ 的/ 读取/ ./ 在/ 一些/ 情况/ 下/ ,/ 只有/ 前/ 若干/ 层次/ 的/ 片元/ 对/ 多片/ 元/ 效果/ 的/ 绘制/ 有/ 较大/ 作用/ ,/ 后面/ 层次/ 的/ 片元/ 对/ 绘制/ 效果/ 的/ 作用/ 可/ 忽略不计/ ./ 为此/ ,/ 一些/ 研究者/ 提出/ 了/ 只/ 进行/ 一遍/ 模型/ 数据/ 读取/ 的/ 绘制/ 方法/ ./ 但/ 这些/ 方法/ 将/ 排序/ 计算/ 放到/ GPU/ 中/ 进行/ ,/ 往往/ 会/ 出现/ 排序/ 失误/ 而/ 影响/ 绘制/ 质量/ ./ 比如/ K/ -/ Buffer/ 算法/ [/ 3/ ]/ 力图/ 使用/ Read/ -/ Modify/ -/ Write/ (/ RMW/ )/ 操作/ 来/ 实现/ 前/ K/ 层片/ 元/ 的/ 排序/ ,/ 但/ 在/ 进行/ 片元/ 插入/ 操作/ 时/ ,/ 一个/ 像素/ 相关/ Page3/ 的/ 多个/ 片元/ 可能/ 同时/ 对/ 一个/ 存储/ 位置/ 进行/ 读写操作/ 而/ 引起/ 排序/ 失误/ ./ 为/ 避免/ RMW/ 的/ 读写/ 冲突/ ,/ 文献/ [/ 13/ ]/ 提出/ 利用/ MultisampleAntialiasing/ (/ MSAA/ )/ 缓存/ 和/ StencilRouting/ 操作/ 来/ 进行/ 排序/ ,/ 但/ 由于/ MSAA/ 缓存/ 的/ 限制/ ,/ 它/ 至多/ 只能/ 处理/ 前/ 8/ 层片/ 元/ ./ 为/ 提高/ 排序/ 的/ 效率/ ,/ 文献/ [/ 4/ ]/ 利用/ GPU/ 中/ 的/ MRT/ 缓存/ 为/ 每个/ 像素/ 分配/ 一个/ 包含/ 32/ 个/ 单元/ 的/ 桶/ 结构/ ,/ 然后/ 将/ 模型/ 深度/ 分为/ 32/ 个/ 区间/ ,/ 再/ 根据/ 片元/ 的/ 深度/ 将/ 其/ 放入/ 桶/ 结构/ 中/ 的/ 适当/ 单元/ ,/ 但/ 这样/ 会/ 将/ 同一/ 深度/ 区间/ 的/ 片元/ 插入/ 同一/ 存储单元/ 而/ 引起/ 排序/ 失误/ ./ 这些/ 方法/ 除了/ 可能/ 引起/ 排序/ 失误/ 外/ ,/ 一般/ 只能/ 处理/ 前/ 若干/ 层次/ 的/ 片元/ ./ 当/ 需要/ 绘制/ 较/ 多/ 深度/ 层次/ 的/ 模型/ 时/ ,/ 它们/ 依然/ 要/ 对模型/ 进行/ 多遍/ 的/ 数据/ 读取/ ./ 特别/ 是/ ,/ 为/ 化解/ 排序/ 失误/ ,/ 它们/ 也/ 会/ 增加/ 数据/ 读取/ 的/ 遍数/ ,/ 如/ 文献/ [/ 4/ ]/ 提出/ 多遍/ 桶/ 深度/ 剥离/ 及/ 自/ 适应/ 桶/ 深度/ 剥离/ ,/ 以/ 减少/ 排序/ 冲突/ ,/ 但/ 这样/ 的/ 改进/ 至少/ 需要/ 两遍/ 读取/ ./ 为/ 解决/ RMW/ 读写/ 冲突/ 及片/ 元/ 排序/ 失误/ ,/ 文献/ [/ 5/ ]/ 提出/ 把/ 多片/ 元/ 效果/ 绘制/ 流程/ 完整/ 映射/ 到/ CUDA/ 编程/ 模型/ 上/ ,/ 以便/ 灵活/ 控制/ Blending/ 操作/ 和/ 显存/ 分配/ ./ 对于/ 片元/ 排序/ ,/ 它/ 提出/ 两种/ 策略/ :/ 第/ 1/ 种为/ Multi/ -/ DepthTestScheme/ (/ MDTS/ )/ ,/ 第/ 2/ 种为/ A/ -/ BufferScheme/ (/ ABS/ )/ ./ 在/ 第/ 1/ 种/ 策略/ 中/ ,/ 它/ 预先/ 在/ CUDA/ 全局/ 内存/ 中为/ 每个/ 像素/ 分配/ 固定/ 大小/ 的/ 整型/ 数组/ ,/ 以便/ 片元能/ 根据/ 深度/ 信息/ 插入/ 到/ 此/ 数组/ 中/ 的/ 相应/ 位置/ ./ 由于/ CUDA/ 不/ 支持/ 64/ 位/ 原子/ 操作/ ,/ 故/ MDTS/ 不能/ 同时/ 更新/ 深度/ 及/ 颜色/ 信息/ ,/ 于是/ ,/ 它/ 把/ 深度/ 及/ 颜色/ 信息/ 打包/ 在/ 一个/ 32/ 位/ 的/ 数中/ ,/ 但/ 这样/ 会/ 导致/ 深度/ 精度/ 的/ 损失/ ./ 同时/ MDTS/ 在/ 全局/ 内存/ 进行/ 插入排序/ 的/ 时间/ 复杂度/ 为/ N2/ (/ 深度/ 为/ N/ )/ ./ 为/ 缓解/ 上述/ 问题/ ,/ 第/ 2/ 种/ 策略/ 提出/ 预先/ 为/ 每个/ 像素/ 分配/ 固定/ 大小/ 的/ 结构/ 体/ (/ 存储/ 深度/ 及/ 颜色/ )/ ,/ 并/ 按/ 处理/ 的/ 先后顺序/ 将片/ 元/ 存入/ 到/ 数组/ 中/ ,/ 之后/ 对/ 数组/ 进行/ 插入排序/ 操作/ ./ 此/ 策略/ 仍然/ 需要/ 打包/ 深度/ 及/ 颜色/ ,/ 但/ 排序/ 是/ 在/ 寄存器/ 级别/ 上/ 进行/ ,/ 排序/ 计算/ 很快/ ./ 虽然/ 该/ 方法/ 取得/ 了/ 不错/ 的/ 加速/ 效果/ ,/ 但/ 由于/ 空间/ 的/ 限制/ ,/ 它/ 所/ 处理/ 的/ 模型/ 不能/ 很大/ ,/ 模型/ 的/ 深度/ 层次/ 不能/ 太多/ ./ 与/ 已有/ 工作/ 相比/ ,/ 本文/ 方法/ 只/ 进行/ 模型/ 数据/ 的/ 一遍/ 读取/ ,/ 就/ 能/ 对/ 所有/ 片元/ 进行/ 正确/ 的/ 深度/ 排序/ ,/ 且/ 没有/ 深度/ 层次/ 的/ 限制/ ,/ 故能/ 有效/ 提高/ 多片/ 元/ 效果/ 绘制/ 的/ 速度/ ,/ 且/ 方便/ 处理/ 大/ 模型/ ./ 由于/ 新/ 方法/ 可/ 及时/ 进行/ 合并/ 计算/ 以/ 节省/ 空间/ ,/ 所以/ 可/ 使用/ 更/ 多/ 的/ 光照/ 参数/ 增强/ 绘制/ 效果/ ,/ 这是/ 已有/ 基于/ GPU/ 进行/ 多片/ 元/ 绘制/ 的/ 方法/ 所/ 不/ 具备/ 的/ ./ 3/ 基于/ 凸/ 多面体/ 方式/ 的/ 网格化/ 组织/ 一个/ 凸/ 多面体/ 的/ 面片/ ,/ 从/ 任一/ 视点/ 观察/ ,/ 只会/ 有/ 前后/ 2/ 层/ 的/ 深度/ 关系/ ,/ 它们/ 的/ 排序/ 可以/ 在/ GPU/ 中/ 方便/ 地/ 实现/ ,/ 详情/ 将/ 在/ 第/ 4/ 节/ 介绍/ ./ 据此/ ,/ 我们/ 对/ 3/ 维/ 模型/ 进行/ 凸化/ 组织/ ,/ 生成/ 凸/ 多面体/ 集/ 并/ 对/ 它们/ 进行/ 网格化/ 的/ 组织/ ;/ 由此/ ,/ 在/ 绘制/ 时/ ,/ 可/ 根据/ 当前/ 视点/ 方位/ 快速/ 地/ 确定/ 将/ 凸/ 多面体/ 逐个/ 地/ 传入/ GPU/ 的/ 序列/ ,/ 以/ 保证/ 片元/ 的/ 深度/ 层次/ 关系/ 能/ 得到/ 正确/ 的/ 处理/ ,/ 以/ 完成/ 多片/ 元/ 效果/ 的/ 绘制/ ./ 在/ 此/ ,/ 我们/ 并/ 不/ 要求/ 每个/ 凸/ 多面体/ 都/ 是/ 一个/ 封闭/ 的/ 整体/ ,/ 只是/ 将/ 位于/ 一个/ 凸/ 多面体/ 上/ 的/ 所有/ 面片/ 当作/ 一个/ 整体/ 进行/ 计算/ ./ 在/ 这/ 过程/ 中/ ,/ 所有/ 面片/ 只会/ 传输/ 到/ GPU/ 中/ 1/ 次/ ,/ 有利于/ 化解/ 数据/ 读取/ 对/ GPU/ 上/ 多片/ 元/ 绘制/ 效率/ 的/ 瓶颈/ 影响/ ./ 模型/ 的/ 凸/ 多面体/ 化及/ 网格化/ 组织/ 只/ 需/ 预计/ 算/ 一次/ ,/ 可/ 进行/ 反复/ 的/ 绘制/ 计算/ ./ 下面/ 我们/ 先/ 介绍/ 模型/ 的/ 凸/ 多面体/ 分解/ ,/ 再/ 介绍/ 凸/ 多面体/ 的/ 网格化/ 组织/ 及/ 传输/ 顺序/ 的/ 处理/ 方法/ ./ 3.1/ 凸/ 多面体/ 的/ 生成/ 在/ 此/ 我们/ 使用/ 以下/ 的/ 方法/ 来/ 生成/ 凸/ 多面体/ :/ 将/ 一个三维/ 模型/ 分解成/ 凸/ 多面体/ 的/ 工作/ 很多/ ,/ (/ 1/ )/ 导入/ 模型/ ,/ 计算/ 面片/ 的/ 法/ 向量/ 并/ 记录/ 每个/ 面片/ 相邻/ 的/ 面片/ ./ (/ 2/ )/ 对/ 任一/ 还/ 没/ 被/ 处理/ 的/ 面片/ ,/ 将/ 其/ 作为/ 种子/ 点/ 进行/ 逐步/ 的/ 扩展/ ,/ 以/ 得到/ 一个/ 新/ 的/ 凸/ 多面体/ ./ 此时/ ,/ 剔除/ 位于/ 此/ 面片/ 所在/ 的/ 平面/ 正面/ 之上/ 的/ 面片/ ,/ 并/ 将/ 与其/ 邻接/ 的/ 位于/ 其/ 平面/ 正面/ 之下/ 的/ 面片/ 加入/ 该/ 凸/ 多面体/ 中/ ;/ 然后/ ,/ 对/ 新/ 加入/ 的/ 面片/ ,/ 也/ 依次/ 进行/ 上述/ 的/ 剔除/ 操作/ ,/ 并/ 加入/ 新/ 的/ 面片/ ./ 如此/ 迭代/ 进行/ ,/ 直至/ 没有/ 新/ 的/ 面片/ 加入/ ,/ 就/ 完成/ 了/ 一个/ 凸/ 多面体/ 的/ 生成/ ./ (/ 3/ )/ 反复/ 进行/ 步/ (/ 2/ )/ 的/ 计算/ ,/ 直至/ 模型/ 的/ 所有/ 面片/ 都/ 被/ 划分/ 到/ 某/ 一个/ 生成/ 的/ 凸/ 多面体/ 中/ ./ 3.2/ 网格化/ 组织/ 及/ 排序/ 将/ 模型/ 分解成/ 一些/ 凸/ 多面体/ 后/ ,/ 我们/ 对模型/ 的/ 包围/ 盒/ 进行/ 网格化/ 划分/ ,/ 即/ 生成/ 正交/ 网格/ ,/ 并/ 使得/ 每个/ 网格/ 中/ 只有/ 数目/ 不多/ 的/ 几个/ 凸/ 多面体/ (/ 我们/ 的/ 实现/ 中/ 一般/ 生成/ 均匀/ 网格/ ,/ 以/ 减少/ 网格化/ 的/ 开销/ ,/ 且/ 不会/ 影响/ 凸/ 多面体/ 处理/ 顺序/ 的/ 判定/ )/ ./ 根据/ 规则/ 数据/ 场体/ 绘制/ 技术/ 的/ 研究/ ,/ 这些/ 正交/ 网格/ 可/ 根据/ 坐标轴/ 方向/ 形成/ 一层层/ 的/ 组织/ ,/ 而/ 每层/ 网格/ 可/ 形成/ 一行行/ 的/ 组织/ ./ 由此/ ,/ 根据/ 视点/ 方位/ ,/ 可/ 确定/ 这些/ 网格/ 层/ 的/ 处理/ 顺序/ ,/ 以/ 保证/ 先/ 处理/ 的/ 层/ 一定/ 位于/ 后处理/ 的/ 层/ 前面/ ;/ 而/ 在/ 处理/ 每层/ 时/ ,/ 也/ 可/ 类似/ 地/ 确定/ 网格/ 行/ 处理/ 的/ Page4/ 顺序/ ,/ 以/ 保证/ 先/ 处理/ 的/ 行/ 一定/ 位于/ 后处理/ 的/ 行/ 前面/ ./ 对于/ 一行/ 中/ 的/ 网格/ 单元/ ,/ 也/ 容易/ 获知/ 它们/ 处理/ 的/ 前后/ 顺序/ ./ 因此/ ,/ 借助于/ 正交/ 网格/ 的/ 帮助/ ,/ 我们/ 可/ 确定/ 凸/ 多面体/ 的/ 传输/ 顺序/ ,/ 以/ 保证/ 先/ 传送/ 的/ 凸/ 多面体/ 一定/ 位于/ 后/ 传送/ 的/ 凸/ 多面体/ 前面/ ./ 具体/ 的/ 计算/ 如下/ :/ 按照/ 网格/ 处理/ 的/ 前后/ 顺序/ ,/ 依次/ 检测/ 各个/ 网格/ 中/ 是否/ 有/ 凸/ 多面体/ ./ 如果/ 有/ ,/ 就/ 将/ 该/ 网格/ 中/ 的/ 凸/ 多面体/ 处理/ 完/ 以后/ ,/ 再/ 继续/ 检测/ 后续/ 的/ 网格/ ./ 如果/ 一个/ 凸/ 多面体/ 覆盖/ 多个/ 网格/ ,/ 就要/ 使/ 位于/ 这些/ 网格/ 前面/ 的/ 网格/ 均/ 被/ 处理/ 完/ 以后/ ,/ 才能/ 处理/ 这个/ 凸/ 多面体/ ./ 对于/ 网格化/ 组织/ 中/ 的/ 网格/ 层/ 和/ 网格/ 行/ ,/ 由于/ 它们/ 均/ 可/ 各自/ 独立/ 地/ 进行/ 其/ 局部/ 的/ 前后/ 顺序排列/ ,/ 因此/ ,/ 我们/ 就/ 可/ 正确/ 地/ 得到/ 凸/ 多面体/ 传输/ 的/ 顺序/ ./ 不失/ 一般性/ ,/ 我们/ 以/ 一个/ 2/ 维/ 例子/ 进行/ 说明/ ./ 在/ 图/ 1/ 中/ ,/ 有/ 5/ 个/ 凸/ 多面体/ ./ 根据/ 视点/ V/ ,/ 我们/ 知道/ 由/ 前往/ 后处理/ 这些/ 网格/ 的/ 顺序/ 是/ ,/ 沿着/ y/ 坐标/ 降低/ 的/ 顺序/ 依次/ 处理/ 网格/ 行/ ,/ 在/ 每行/ 中/ 沿着/ x/ 坐标/ 增加/ 的/ 顺序/ 依次/ 处理/ 各个/ 网格/ ./ 因此/ ,/ 凸/ 多面体/ A/ 被/ 最先/ 处理/ ;/ 当/ 顺序/ 检测/ 到/ 网格/ (/ 2/ ,/ 3/ )/ 时/ 遇到/ 凸/ 多面体/ B/ ,/ 由于/ 它/ 覆盖/ 多个/ 网格/ ,/ 因此/ 要/ 转而/ 检测/ 下/ 一行/ 网格/ ,/ 即/ 从/ 网格/ (/ 0/ ,/ 2/ )/ 开始/ 检测/ ./ 由于/ 网格/ (/ 0/ ,/ 2/ )/ 中有/ 凸/ 多面体/ C/ ,/ 且/ 也/ 覆盖/ 多个/ 网格/ ,/ 因此/ 也/ 要/ 检测/ 它/ 前面/ 的/ 网格/ (/ 0/ ,/ 1/ )/ ./ 此时/ ,/ 凸/ 多面体/ C/ 就/ 可/ 处理/ 了/ ./ 处理/ 完/ 以后/ ,/ 就/ 根据/ 迭代/ 处理/ 的/ 顺序/ ,/ 再/ 继续/ 检测/ 网格/ (/ 1/ ,/ 2/ )/ ,/ (/ 1/ ,/ 1/ )/ ,/ (/ 1/ ,/ 2/ )/ ,/ (/ 2/ ,/ 2/ )/ ,/ 至此/ ,/ 就/ 可/ 处理/ 凸/ 多面体/ B/ 了/ ./ 依此类推/ ,/ 再/ 处理/ 凸/ 多面体/ D/ ,/ 最后/ 是/ 凸/ 多面体/ E/ ./ 这样/ ,/ 就/ 完成/ 了/ 这些/ 凸/ 多面体/ 传输/ 顺序/ 的/ 判断/ ,/ 保证/ 先/ 处理/ 的/ 凸/ 多面体/ 一定/ 是/ 位于/ 后处理/ 的/ 凸/ 多面体/ 前面/ ,/ 使得/ 多片/ 元/ 效果/ 能/ 得到/ 正确/ 的/ 绘制/ ./ 图/ 14/ ×/ 5/ 的/ 二维/ 网格/ (/ 圆/ 表示/ 凸多边形/ ,/ V/ 表示/ 在/ 左上方/ 位/ 的/ 视点/ 位置/ ,/ 它/ 的/ 主/ 观测/ 方向/ 为/ (/ Vx/ ,/ Vy/ )/ )/ 在/ 以上/ 例子/ 的/ 说明/ 中/ ,/ 每个/ 网格/ 所/ 包含/ 的/ 凸/ 多面体/ 最/ 多/ 只有/ 一个/ ./ 如果/ 网格/ 组织/ 中/ 的/ 凸/ 多面体/ 之间/ 不/ 存在/ 循环/ 遮挡/ 关系/ ,/ 则/ 按照/ 上面/ 的/ 遍历/ 算法/ 总能/ 得到/ 凸/ 多面体/ 序列/ ./ 对/ 凸/ 多面体/ 之间/ 存在/ 循环/ 遮挡/ 的/ 情况/ ,/ 可以/ 采用/ 文献/ [/ 14/ ]/ 中/ 的/ 方法/ 先/ 去除/ 循环/ 遮挡/ ,/ 然后/ 再/ 使用/ 上述/ 方法/ 遍历/ ./ 当/ 一个/ 网格/ 中/ 包含/ 多个/ 凸/ 多面体/ 时/ ,/ 则/ 要/ 将/ 该/ 网格/ 中/ 的/ 凸/ 多面体/ 进行/ 有效/ 的/ 处理/ ,/ 以/ 保证/ 与/ 一个/ 像素/ 相关/ 的/ 片元能/ 得到/ 正确/ 的/ 前后/ 排序/ ./ 下面/ 我们/ 分/ 几种/ 情况/ 对此/ 进行/ 讨论/ ./ 3.2/ ./ 1/ 嵌套/ 多面体/ 对于/ 一个/ 凸/ 多面体/ 内部/ 包含/ 其它/ 凸/ 多面体/ 的/ 情况/ ,/ 我们/ 要/ 进行/ 如下/ 的/ 处理/ ,/ 以/ 保证/ 这些/ 凸/ 多面体/ 的/ 面片/ 得到/ 正确/ 的/ 排序/ ./ 首先/ ,/ 在/ 建立/ 网格化/ 组织/ 时/ ,/ 我们/ 要/ 探测/ 是否/ 有/ 凸/ 多面体/ 包含/ 其它/ 的/ 凸/ 多面体/ 的/ 情况/ ./ 如果/ 有/ ,/ 就/ 将/ 该/ 凸/ 多面体/ 及其/ 包含/ 的/ 凸/ 多面体/ 作为/ 一个/ 整体/ 处理/ (/ 只/ 包含/ 部分/ 的/ ,/ 就/ 将/ 所/ 包含/ 的/ 部分/ 分割/ 进来/ )/ ./ 处理/ 它们/ 时/ ,/ 只有/ 当其/ 所/ 包含/ 的/ 凸/ 多面体/ 都/ 被/ 处理/ 了/ 以后/ ,/ 才能/ 处理/ 这个/ 凸/ 多面体/ ./ 这样/ ,/ 就/ 根据/ 凸/ 多面体/ 之间/ 的/ 包含/ 关系/ 形成/ 了/ 一种/ 嵌套/ 组织/ 的/ 处理/ 方法/ ./ 具体情况/ ,/ 详见/ 第/ 4/ 节/ ./ 3.2/ ./ 2/ 相邻/ 凸/ 多面体/ 的/ 分离/ 对于/ 3/ 维空间/ 中/ 相邻/ 的/ 两个/ 凸/ 多面体/ ,/ 很/ 难用/ 一个/ 平面/ 将/ 两者/ 分离/ ./ 为/ 保证/ 它们/ 的/ 面片/ 的/ 正确处理/ 顺序/ ,/ 我们/ 提出/ 一种/ slab/ 结构/ 将/ 它们/ 分离/ ./ 如图/ 2/ 中/ 的/ 2/ 维/ 例子/ 所示/ ,/ slab/ 是/ 由/ 两个/ 平行/ 平面/ 组成/ 的/ 一个/ 夹层/ 结果/ ,/ 保证/ 这/ 2/ 个/ 凸/ 多面体/ 只能/ 位于/ 该/ slab/ 结构/ 的/ 两侧/ ,/ 而/ slab/ 内部/ 包含/ 有/ 这/ 2/ 个/ 凸/ 多面体/ 的/ 面片/ ./ 沿着/ slab/ 结构/ 的/ 平行/ 平面/ 的/ 法向/ ,/ 将/ 这/ 两个/ 凸/ 多面体/ 往/ slab/ 的/ 平行/ 平面/ 上/ 投影/ ,/ 就/ 能/ 得到/ slab/ 结构/ 的/ 大小/ ,/ 一般/ 是/ 将/ 其/ 生成/ 一个/ 薄/ 的/ 长方体/ 形状/ ./ 图/ 2/ 将/ 相邻/ 的/ 两个/ 凸多边形/ 进行/ 分离/ 的/ slab/ 结构/ 不失/ 一般性/ ,/ 我们/ 以/ 一个/ 例子/ 来/ 说明/ 一个/ slab/ 结构/ 的/ 生成/ 方法/ ./ 对于/ 相邻/ 的/ 两个/ 凸/ 多面体/ 为/ A/ 、/ B/ ,/ 先/ 计算/ A/ 中/ 与/ B/ 相邻/ 的/ 面片/ 集/ Sa/ ,/ 并/ 对/ Sa/ 进行/ 主元/ 分析/ (/ PCA/ )/ ,/ 得到/ 其/ 最/ 短轴所/ 对应/ 的/ 法向/ 犖/ 犪/ ;/ 根据/ 犖/ 犪/ 生成/ 一些/ 平行/ 平面/ ,/ 从中/ 找到/ 两个/ 平面/ ,/ 使得/ 它们/ 形成/ 的/ 夹层/ 可/ 将/ 这/ 两个/ 凸/ 多面体/ 分开/ ./ 这/ 就/ Page5/ 形成/ 了/ 一个/ 可能/ 的/ slab/ 结构/ ./ 对于/ B/ 中/ 与/ A/ 相邻/ 的/ 面片/ 集/ Sb/ ,/ 我们/ 进行/ 类似/ 的/ 计算/ ,/ 也/ 得到/ 一个/ 可能/ 的/ slab/ 结构/ ./ 比较/ 这/ 两个/ 结构/ 的/ 厚度/ ,/ 即/ 相关/ 平行/ 平面/ 的/ 间距/ ,/ 选择/ 其中/ 较/ 小/ 的/ 作为/ 这/ 两个/ 凸/ 多面体/ 的/ slab/ 结构/ ./ 基于/ 这样/ 的/ slab/ 结构/ ,/ 就/ 可/ 将/ 两个/ 凸/ 多面体/ 分离/ ,/ 使得/ 它们/ 之间/ 的/ 排序/ 容易/ 进行/ (/ 此时/ ,/ 它们/ 各自/ 要/ 舍弃/ 位于/ slab/ 结构/ 中/ 的/ 面片/ )/ ./ 由于/ 一个/ slab/ 结构/ 中/ 只/ 含有/ 2/ 个/ 凸/ 多面体/ 的/ 面片/ ,/ 它们/ 最/ 多/ 形成/ 4/ 个/ 深度/ 层次/ ,/ 因此/ 可/ 方便/ 地/ 在/ GPU/ 中/ 排序/ ,/ 这/ 将/ 在/ 第/ 4/ 节/ 介绍/ ./ 3.2/ ./ 3/ 凸/ 多面体/ 密集/ 的/ 网格/ 对于/ 包含/ 较/ 多/ 凸/ 多面体/ 的/ 网格/ ,/ 我们/ 将/ 采取/ 下面/ 的/ 方法/ 进行/ 处理/ ,/ 以便/ 绘制/ 时能/ 对/ 它们/ 进行/ 高效/ 的/ 排序/ ./ 首先/ ,/ 对于/ 这些/ 凸/ 多面体/ 中/ 相邻/ 的/ 情况/ ,/ 通过/ 生成/ slab/ 结构/ 进行/ 分离/ ,/ 而/ 对/ 不/ 相邻/ 但/ 比较/ 靠近/ 的/ 2/ 个/ 凸/ 多面体/ ,/ 则/ 找到/ 一个/ 平面/ 片/ 进行/ 分离/ ./ 然后/ ,/ 根据/ 这些/ 平面/ 片/ 和/ slab/ 结构/ 的/ 分布/ 情况/ ,/ 进行/ 相应/ 的/ 处理/ ./ 由于/ 它们/ 的/ 分布/ 可/ 分为/ 向心/ 分布/ (/ 此/ 针对/ 二维/ 情况/ ,/ 三维/ 则/ 是/ 楔形/ 分布/ )/ 与非/ 向心/ 分布/ 2/ 种/ 情况/ ,/ 我们/ 可/ 采用/ 2/ 种/ 方式/ 进行/ 分别/ 的/ 处理/ ./ 图/ 3/ 一个/ 网格/ 中/ slab/ 结构/ 及/ 分离/ 平面/ 的/ 分布/ (/ 1/ )/ 当/ 它们/ 的/ 分布/ 呈现/ 向心/ 分布/ 时/ ,/ 如图/ 3/ (/ a/ )/ 所示/ ,/ 我们/ 就/ 根据/ 这些/ 平面/ 片及/ slab/ 结构/ 的/ 平行/ 平面/ ,/ 将/ 它们/ 的/ 包围/ 球/ (/ 图中/ 2/ 维/ 情况/ 下/ 是/ 包围/ 圆/ )/ 进行/ 剖分/ ,/ 然后/ ,/ 对于/ 剖分/ 的/ 每个/ 球面/ 部分/ ,/ 记录/ 当/ 视点/ 位于/ 该/ 球面/ 部分/ 对应/ 的/ 相位/ 时/ ,/ 这些/ 凸/ 多面体/ 被/ 处理/ 的/ 前后/ 顺序/ ./ 这样/ ,/ 在/ 绘制/ 时/ ,/ 就/ 只要/ 调用/ 这个/ 记录/ ,/ 就/ 可/ 对/ 这些/ 凸/ 多面体/ 及/ slab/ 结构/ 进行/ 正确/ 的/ 顺序/ 处理/ ./ 由于/ 这种/ 结构/ 一般/ 不/ 多/ ,/ 因此/ 这样/ 记录/ 的/ 信息/ 不会/ 占用/ 太/ 多/ 空间/ ./ (/ 2/ )/ 对于/ 非/ 向心/ 分布/ 的/ 情况/ ,/ 如图/ 3/ (/ b/ )/ 所示/ ,/ 我们/ 可/ 对/ 该/ 网格/ 进行/ 更/ 小/ 尺寸/ 的/ 子/ 网格/ 划分/ ,/ 使得/ 每个/ 子/ 网格/ 中/ 不/ 包含/ 多于/ 2/ 个/ 凸/ 多面体/ 的/ 情况/ ./ 当然/ ,/ 对于/ 分布/ 疏密/ 不/ 均衡/ 的/ 情况/ ,/ 可以/ 进行/ 多/ 分辨率/ 的/ 子/ 网格/ 创建/ ./ 由此/ ,/ 可用/ 前面/ 所述/ 的/ 方法/ 对/ 凸/ 多面体/ 进行/ 排序/ ./ 对于/ 向心/ 分布/ 的/ 探测/ ,/ 我们/ 可用/ 以下/ 方法/ 进行/ :/ 对于/ 这些/ slab/ 结构/ 的/ 平行/ 平面/ 与/ 分离/ 面片/ 所在/ 平面/ ,/ 从中/ 任意/ 选一/ 作为/ 考察/ 平面/ ,/ 然后/ 求取/ 其它/ 平面/ 与/ 该/ 考察/ 平面/ 的/ 交线/ 情况/ ,/ 如果/ 这些/ 交线/ 的/ 交点/ 位于/ 一个/ 较/ 小/ 的/ 范围/ 内/ ,/ 则/ 说明/ 是/ 向心/ 分布/ 的/ ./ 4GPU/ 上/ 的/ 片元/ 前后/ 排序/ 多片/ 元/ 效果/ 的/ 绘制/ ,/ 根本/ 的/ 是/ 要/ 保证/ 每个/ 像素/ 的/ 片元能/ 正确/ 地/ 前后/ 排序/ ./ 在/ 本节/ ,/ 我们/ 先/ 讨论/ 单个/ 凸/ 多面体/ 情况/ 下/ 的/ 片元/ 排序/ ,/ 然后/ 介绍/ 网格/ 组织/ 方式/ 下/ 的/ 片元/ 前后/ 序列/ 的/ 正确/ 实现/ ,/ 由此/ 实现/ 数据/ 单遍/ 读取/ 情况/ 下/ 的/ GPU/ 上/ 的/ 多片/ 元/ 效果/ 绘制/ ./ 4.1/ 单个/ 凸/ 多面体/ 对于/ 一个/ 凸/ 多面体/ ,/ 其/ 靠近/ 视点/ 的/ 那/ 层面/ 片/ 是/ 朝向/ 视点/ 的/ ,/ 而/ 远离/ 视点/ 的/ 那/ 层面/ 片/ 是/ 背离/ 视点/ 的/ ./ 因此/ ,/ 根据/ 视线/ 方向/ 与/ 片/ 元法/ 向/ 的/ 点/ 乘/ ,/ 即可/ 将片/ 元/ 分成/ 前后/ 两层/ ./ 对于/ 一个/ 封闭/ 的/ 凸/ 多面体/ ,/ 所有/ 被/ 它/ 覆盖/ 的/ 任一/ 像素/ ,/ 其/ 相关/ 的/ 视线/ 只会/ 有/ 2/ 层片/ 元/ ./ 为此/ ,/ 我们/ 使用/ MRT/ 的/ 两块/ 纹理/ 缓存/ 保存/ 前/ 后面/ 的/ 片元/ 信息/ ,/ 在/ 对/ 它们/ 分别/ 进行/ 光照/ 计算/ 后/ ,/ 再/ 对/ 它们/ 进行/ 合并/ 运算/ ./ 如图/ 4/ (/ a/ )/ 所示/ ,/ 纹理/ 缓存/ T1/ 保存/ 凸多边形/ C1/ 的/ 前/ 向/ 面片/ 元/ ,/ 而/ T2/ 保存/ 其后/ 向面/ 的/ 片元/ ./ 具体/ 实现/ 时/ ,/ 我们/ 不/ 采用/ MRT/ 默认/ 的/ REPLACE/ 合并/ 操作/ 模式/ ,/ 因为/ 在/ 更新/ 某个/ 纹理/ 单元/ 时/ ,/ 它会/ 并发/ 更新/ 同/ 像素/ 位置/ 的/ 所有/ 纹理/ 单元/ ,/ 导致/ 一些/ 已/ 处理/ 的/ 片元/ 信息/ 丢失/ ./ 为此/ ,/ 我们/ 采用/ 32/ 比特/ 浮点/ 型/ MAX/ 合并/ 操作/ ,/ 并/ 先/ 将/ 两块/ 纹理/ 缓存/ 的/ 值/ 都/ 初始化/ 为/ 0/ (/ 该值/ 在/ 透明/ 绘制/ 时/ 将/ 保存/ 色彩/ 信息/ ,/ 而/ 在/ 半透明/ 绘制/ 时/ 是/ 深度/ 信息/ ,/ 这些/ 值/ 都/ 不会/ 小于/ 0/ )/ ./ 当/ 处理/ 一个/ 片元时/ ,/ 先/ 判断/ 其/ 是/ 前/ 向/ 还是/ 后/ 向/ ./ 若/ 是/ 前/ 向/ 片元/ ,/ 就/ 将/ 在/ T1/ 中/ 存储/ 其/ 颜色/ 、/ 深度/ 等值/ ,/ 而/ 在/ T2/ 中/ 对应/ 位置/ 置/ 0/ ;/ 反之/ ,/ 就/ 将/ 在/ T1/ 中置/ 0/ ,/ 而/ 在/ T2/ 中/ 对应/ 位置/ 存储/ 其/ 颜色/ 、/ 深度/ 等值/ ./ 当然/ ,/ 实际/ 写入/ 前/ ,/ 要/ 进行/ 值/ 的/ 比较/ ,/ 即/ 只有/ 将/ 写入/ 的/ 值/ 大于/ 已/ 在/ Page6/ 图/ 4/ 单个/ 凸/ 多面体/ 的/ 面片/ 的/ 前后/ 排序/ 及/ 合并/ 计算/ 该/ 位置/ 存储/ 的/ 值/ 的/ 时候/ ,/ 才/ 会/ 有/ 真正/ 写入/ ./ 由此/ ,/ 前后/ 2/ 层片/ 元/ 的/ 情况/ 就/ 能/ 得到/ 真实/ 的/ 反映/ ,/ 然后/ 将/ 它们/ 进行/ 合并/ 操作/ ,/ 就/ 完成/ 了/ 该/ 凸/ 多面体/ 的/ 绘制/ ./ 对于/ 不/ 完全/ 封闭/ 的/ 凸/ 多面体/ ,/ 我们/ 的/ 算法/ 也/ 可/ 同样/ 地/ 处理/ ,/ 因为/ 对于/ 只有/ 1/ 层片/ 元/ 覆盖/ 的/ 像素/ ,/ 其/ 另/ 一层/ 对应/ 的/ 纹理/ 单元/ 值/ 一直/ 是/ 0/ ,/ 并/ 不会/ 影响/ 混合/ 的/ 绘制/ 效果/ ./ 如图/ 4/ (/ b/ )/ 所示/ ,/ C2/ 为/ 不/ 完整/ 的/ 凸多边形/ ,/ 纹理/ 缓存/ T4/ 保存/ 了/ 它/ 后/ 向面/ 的/ 片元/ ,/ 而/ T3/ 只/ 保存/ 了/ 一些片/ 元/ 信息/ ,/ 在/ 色彩/ 混合/ 计算/ 时/ ,/ 这/ 并/ 不会/ 影响/ 最终/ 的/ 结果/ ./ 4.2/ 凸/ 多面体/ 序列/ 在/ 绘制/ 一个/ 模型/ 时/ ,/ 根据/ 预计/ 算/ 得到/ 的/ 凸/ 多面体/ 的/ 网格化/ 组织/ 和/ 当前/ 视点/ 的/ 方位/ ,/ 我们/ 按照/ 第/ 3/ 节/ 的/ 方法/ ,/ 先对/ 网格/ 结构/ 进行/ 遍历/ ,/ 计算/ 出凸/ 多面体/ 的/ 传输/ 顺序/ ,/ 然后/ 逐个/ 地/ 传送/ 凸/ 多面体/ 到/ GPU/ 中/ 处理/ ./ 对于/ 送到/ GPU/ 中/ 的/ 凸/ 多面体/ ,/ 我们/ 先/ 将/ 其/ 按照/ 4.1/ 节/ 介绍/ 的/ 方法/ 进行/ 绘制/ ,/ 然后/ 将/ 其/ 结果/ 与/ 已/ 绘制/ 的/ 凸/ 多面体/ 的/ 结果/ 进行/ 合并/ 绘制/ ,/ 就/ 能/ 在/ GPU/ 中/ 完成/ 整个/ 模型/ 的/ 多片/ 元/ 效果/ 绘制/ ./ 对于/ 不/ 包含/ 凸/ 多面体/ 嵌套/ 的/ 情况/ ,/ 我们/ 直接/ 将/ 凸/ 多面体/ 按照/ 可见/ 性/ 的/ 前后/ 顺序/ 进行/ 传输/ ./ 此时/ ,/ 刚/ 传入/ 的/ 凸/ 多面体/ 一定/ 与/ 已/ 处理/ 的/ 凸/ 多面体/ 形成/ 前后/ 排列/ 的/ 情况/ ,/ 于是/ ,/ 在/ GPU/ 中/ 使用/ 合并/ 操作/ 即可/ ./ 而/ 对于/ 包含/ 嵌套/ 凸/ 多面体/ 的/ 情况/ ,/ 我们/ 的/ 处理/ 如下/ :/ 对于/ 一个/ 嵌套/ 的/ 情况/ ,/ 先/ 将/ 最/ 外层/ 的/ 凸/ 多面体/ 进行/ 绘制/ ,/ 并/ 将/ 其/ 前后/ 两层/ 的/ 情况/ 分别/ 存放/ 在/ 2/ 个/ 纹理/ 缓存/ 中/ ;/ 然后/ 对/ 其/ 所/ 包含/ 的/ 凸/ 多面体/ 进行/ 绘制/ 和/ 合并/ 操作/ ,/ 将/ 所/ 形成/ 的/ 一个/ 纹理/ 图像/ ,/ 插入/ 该/ 嵌套/ 的/ 最/ 外层/ 凸/ 多面体/ 所/ 形成/ 的/ 2/ 层/ 纹理/ 之间/ ,/ 并/ 进行/ 这/ 3/ 个/ 纹理/ 层/ 的/ 合并/ 操作/ ,/ 就/ 完成/ 了/ 该/ 嵌套/ 的/ 绘制/ ./ 对于/ 嵌套/ 层次/ 比较/ 深/ 的/ 情况/ ,/ 我们/ 要/ 先/ 处理/ 最/ 里面/ 的/ 嵌套/ 结构/ ,/ 再/ 逐步/ 处理/ 较浅/ 的/ 嵌套/ 结构/ ,/ 以/ 减轻/ GPU/ 中/ 的/ 空间/ 需求/ ./ Slab/ 结构/ 是/ 一种/ 特殊/ 的/ 情况/ ./ 由于/ 它/ 最/ 多/ 可/ 形成/ 4/ 个/ 深度/ 层次/ ,/ 因此/ ,/ 我们/ 采用/ 文献/ [/ 13/ ]/ 的/ 方法/ 就/ 可/ 完成/ 一个/ slab/ 结构/ 的/ 处理/ ./ 文献/ [/ 13/ ]/ 一次/ 可以/ 对/ 8/ 个片/ 元/ 进行/ 排序/ ,/ 且/ 没有/ RMW/ 的/ 读写/ 冲突/ ,/ 故此/ 方法/ 可/ 对/ slab/ 进行/ 完整/ 的/ 处理/ ./ 当/ 所有/ 凸/ 多面体/ 都/ 送入/ GPU/ 中/ 绘制/ 后/ ,/ 我们/ 就/ 完成/ 了/ 整个/ 模型/ 的/ 多片/ 元/ 效果/ 绘制/ ./ 在/ 此/ 过程/ 中/ ,/ 模型/ 的/ 所有/ 面片/ 都/ 只/ 被/ 读取/ 了/ 一遍/ ./ 5/ 实验/ 及/ 讨论/ 我们/ 用/ OpenGL2/ ./ 0/ 及/ GLSL1/ ./ 20/ 实现/ 了/ 本文/ 提出/ 的/ 方法/ ,/ 并/ 与/ 基于/ CUDA/ 方法/ 的/ 两种/ 策略/ (/ MDTS/ 和/ ABS/ )/ [/ 5/ ]/ 、/ 桶/ 深度/ 剥离/ 算法/ 及其/ 拓展/ 的/ 两遍/ 桶/ 深度/ 剥离/ 算法/ (/ BDP2/ )/ 和/ 自/ 适应/ 桶/ 深度/ 剥离/ 算法/ (/ ADP/ )/ [/ 4/ ]/ 、/ 双面/ 剥离/ 算法/ (/ DDP/ )/ [/ 2/ ]/ 及/ 深度/ 剥离/ 算法/ (/ DP/ )/ [/ 1/ ]/ 等/ 进行/ 对比/ 实验/ ./ 实验/ 在/ 一台/ 微机/ 上/ 进行/ ,/ 该/ 机器/ 装有/ 一个/ IntelQuadCoreQ6600CPU/ ,/ 3GB/ 内存/ 和/ 一个/ 带有/ 1024MB/ 显存/ 的/ NVIDIAGTX280GPU/ ./ 实验/ 中/ ,/ 我们/ 选择/ 了/ 两种/ 有/ 代表性/ 的/ 多片/ 元/ 效果/ 绘制/ ,/ 即/ 透明/ 和/ 半透明/ 效果/ 的/ 绘制/ ./ 透明/ 绘制/ 时/ ,/ 主要/ 是/ 片元/ 的/ 光照/ 色彩/ 和/ 透明度/ 根据/ 片元/ 的/ 前后/ 顺序/ 进行/ 混合/ 计算/ ,/ 不必/ 考虑/ 片元/ 的/ 深度/ 值/ ;/ 而/ 在/ 半透明/ 绘制/ 时/ ,/ 还要/ 考虑/ 光线/ 在/ 模型/ 内部/ 行走/ 路径/ 长度/ 对/ 光照/ 的/ 影响/ ,/ 因此/ 需要/ 计算/ 各个/ 片元/ 的/ 深度/ 信息/ ./ 在/ 我们/ 的/ 方法/ 中/ ,/ 因为/ 各个/ 凸体/ 元/ 的/ 色彩/ 信息/ 进行/ 了/ 及时/ 的/ 混合/ ,/ 在/ GPU/ 中/ 对/ 纹理/ 空间/ 的/ 要求/ 不高/ ,/ 因此/ 可以/ 有/ 更/ 多/ 的/ 空间/ 用于/ 存储/ 片元/ 的/ 材质/ 信息/ ,/ 以/ 进行/ 更好/ 的/ 光照/ 计算/ ./ 而/ 目前/ 计算速度/ 较/ 快/ 的/ 桶/ 深度/ 剥离/ 方法/ [/ 4/ ]/ 和/ 基于/ CUDA/ 的/ 深度/ 剥离/ 方法/ [/ 5/ ]/ 要/ 在/ GPU/ 中/ 保留/ 多层/ 的/ 片元/ 深度/ 信息/ ,/ 使用/ 了/ 大量/ 的/ 显存/ ./ 半透明/ 绘制/ 时/ ,/ 我们/ 主要/ 考虑/ 了/ 两种/ 光/ 能/ 衰减/ Page7/ 的/ 影响/ 因素/ ,/ 其一/ 是/ 光线/ 穿越/ 模型/ 路径/ 的/ 长度/ 的/ 影响/ ,/ 按照/ Beer/ -/ Lambert/ 法则/ ,/ 其/ 衰减系数/ 的/ 计算公式/ 是/ exp/ (/ -/ σ/ tl/ )/ ,/ 在/ 此/ σ/ t/ 为/ 吸收系数/ ,/ l/ 为/ 光线/ 穿越/ 模型/ 路径/ 的/ 长度/ ,/ 可/ 由/ 相邻/ 两层/ 片元/ 之间/ 的/ 深度/ 差/ 获得/ ;/ 其二/ 是/ 关于/ 折射/ 的/ Fresnel/ 效果/ 所/ 引起/ 的/ 光能/ 衰减/ ,/ 我们/ 在/ 此/ 使用/ Schlick/ 公式/ 近似/ Fresnel/ 效图/ 5/ 透明/ 与/ 半透明/ 绘制/ 效果图/ 5.1/ 性能/ 分析/ 由于/ 不同/ 方位/ 观察/ 模型/ 时/ ,/ 深度/ 层次/ 的/ 差异/ 比较/ 大/ ,/ 对/ 绘制/ 效率/ 有/ 比较/ 大/ 的/ 影响/ ./ 为此/ ,/ 测试/ 时/ 我们/ 在/ 这些/ 模型/ 的/ 周围/ 比较/ 均匀/ 地/ 分布/ 一些/ 视点/ ,/ 然后/ 求其/ 平均/ 绘制/ 速度/ 以/ 进行/ 比较/ ,/ 统计/ 结果/ 在/ 表/ 1/ 中/ 列出/ (/ 在/ 此/ 所/ 绘制/ 的/ 图像/ 都/ 是/ 512/ ×/ 512/ 像素/ ./ 表/ 1/ 测试/ 模型/ 的/ 透明/ 绘制/ 速度/ 比较/ 绘制/ 速度/ // (/ 帧/ ·/ s/ -/ 1/ )/ 模型/ (/ 面片/ 数/ )/ (/ 凸体/ 个数/ // 层次/ )/ Teapot/ (/ 6320/ )/ Person/ (/ 12936/ )/ Hourglass/ (/ 38141/ )/ (/ 12/ // 6/ )/ 1083.34348/ ./ 43/ (/ 2.11/ )/ 703.32/ (/ 0.54/ )/ 412.24/ (/ 1.63/ )/ 215.4/ (/ 4.03/ )/ 923/ (/ 0.17/ )/ 625.45/ (/ 0.73/ )/ (/ 28/ // 14/ )/ 909.35246/ ./ 34/ (/ 2.69/ )/ 653.45/ (/ 0.39/ )/ 378.45/ (/ 1.4/ )/ 218.34/ (/ 3.16/ )/ 366.45/ (/ 1.48/ )/ 212.77/ (/ 3.27/ )/ (/ 19/ // 12/ )/ 423.4378/ ./ 34/ (/ 4.41/ )/ 324.34/ (/ 0.31/ )/ 215/ (/ 0.97/ )/ 142.34/ (/ 1.97/ )/ 219.57/ (/ 0.93/ )/ 212.31/ (/ 0.99/ )/ Desk/ (/ 56340/ )/ (/ 24/ // 12/ )/ 243.3236/ ./ 34/ (/ 5.7/ )/ 139.34/ (/ 0.75/ )/ 317.35/ (/ -/ 0.23/ )/ 214.34/ (/ 0.14/ )/ 160.24/ (/ 0.52/ )/ 141.46/ (/ 0.72/ )/ Horse/ (/ 96966/ )/ (/ 68/ // 8/ )/ 403.25178/ ./ 34/ (/ 1.26/ )/ 394.56/ (/ 0.02/ )/ 212.77/ (/ 0.9/ )/ 128.21/ (/ 2.15/ )/ 75.79/ (/ 4.32/ )/ 51.18/ (/ 6.88/ )/ Hand/ (/ 654666/ )/ (/ 103/ // 10/ )/ 273.4697/ ./ 36/ (/ 1.81/ )/ 263.43/ (/ 0.04/ )/ 141.42/ (/ 0.93/ )/ 106.45/ (/ 1.57/ )/ 44.29/ (/ 5.17/ )/ 26.60/ (/ 9.28/ )/ 注/ :/ 表中/ 对比/ 方法/ 的/ 速度/ 数据/ 后面/ 括号/ 中/ 的/ 数字/ ,/ 是/ 新/ 方法/ 相比/ 于/ 它们/ 的/ 加速/ 率/ ./ 果/ 的/ 计算/ [/ 15/ ]/ ,/ 相关/ 的/ 衰减系数/ 计算公式/ 为/ 1/ -/ (/ 1/ -/ cos/ θ/ )/ 5/ ,/ 这里/ ,/ θ/ 为片/ 元/ 上/ 所/ 绘制/ 位置/ 相关/ 的/ 入射光/ 线/ 与/ 视线/ 的/ 夹角/ 的/ 一半/ 角度/ ./ 图/ 5/ 中/ 的/ (/ a/ )/ 、/ (/ b/ )/ 为/ 透明/ 绘制/ 效果图/ ,/ (/ c/ )/ 、/ (/ d/ )/ 、/ (/ e/ )/ 、/ (/ f/ )/ 为/ 半透明/ 绘制/ 效果图/ ./ 显然/ ,/ 这些/ 图/ 都/ 具有/ 很/ 高/ 的/ 质量/ ./ MDTS/ 及/ ABS/ 为/ 基于/ CUDA/ 的/ 深度/ 剥离/ 方法/ 的/ 两种/ 策略/ ,/ BDP2/ 及/ ADP/ 为/ 两遍/ 桶/ 深度/ 剥离/ 算法/ 和/ 自/ 适应/ 桶/ 深度/ 剥离/ 算法/ ,/ DDP/ 及/ DP/ 为/ 双面/ 深度/ 剥离/ 及/ 深度/ 剥离/ 方法/ ./ 凸/ 多面体/ 生成/ 和/ 网格化/ 组织/ 等/ 都/ 属于/ 预处理/ 阶段/ 的/ 操作/ ,/ 故/ 没有/ 把/ 这些/ 操作/ 的/ 处理/ 时间/ 加入/ 到/ 绘制/ 时间/ 中/ )/ ./ 从表中/ 可见/ ,/ 当/ 模型/ 较/ 简/ BDP2Page8/ 单/ 、/ 深度/ 层次/ 不大时/ ,/ 新/ 方法/ 的/ 加速/ 效果/ 不是/ 很/ 明显/ ,/ 比如/ 处理/ Desk/ 模型/ 时/ ,/ 新/ 方法/ 相对/ 于/ ADP/ 方法/ 的/ 加速/ 率/ 只有/ 14/ %/ ,/ 甚至/ 比/ BDP2/ 方法/ 还略慢/ ;/ 但/ 当/ 模型/ 复杂/ ,/ 深度/ 层次/ 较大/ 时/ ,/ 新/ 方法/ 的/ 加速/ 幅度/ 很大/ ,/ 比如/ 处理/ Hand/ 模型/ 时/ ,/ 可/ 提高/ 速度/ 多倍/ ./ 由于/ 新/ 方法/ 是/ 逐个/ 地/ 传输/ 凸/ 多面体/ 进行/ 绘制/ ,/ 凸/ 多面体/ 数目/ 较大/ 时/ ,/ 新/ 方法/ 的/ 速度/ 也/ 会/ 受/ 影响/ ./ 但/ 总的来说/ ,/ 新/ 方法/ 相比/ 于/ 已有/ 方法/ 都/ 能/ 提高/ 速度/ ,/ 即便/ 与/ 基于/ CUDA/ 的/ 一次性/ 装载/ 数据/ 的/ 方法/ 相比/ [/ 5/ ]/ ./ 为了/ 评估/ 深度/ 层次/ 对/ 各类/ 方法/ 的/ 绘制/ 效率/ 影响/ ,/ 我们/ 使用/ 图/ 6/ 中/ 的/ 场景/ 进行/ 测试/ ./ 各类/ 方法/ 的/ 绘制/ 速度/ 如表/ 2/ 所示/ (/ 在/ 此/ 所/ 绘制/ 的/ 图像/ 都/ 是/ 1024/ ×/ 1024/ 像素/ ./ 层次/ 16/ ~/ 96/ 分别/ 对应/ 的/ “/ 面片/ 数/ // 凸/ 多面体/ 个数/ ”/ 为/ 1267200/ // 32/ ,/ 2534400/ // 64/ ,/ 3801600/ // 96/ ,/ 表/ 2/ 不同/ 深度/ 场景/ 的/ 绘制/ 效率/ 比较/ 深度/ 层次/ 163248648096/ 注/ :/ “/ / ”/ 表示/ 由于/ 空间/ 需求/ 过大/ ,/ MDTS/ 方法/ 不能/ 运行/ ;/ 表中/ 对比/ 方法/ 的/ 速度/ 数据/ 后面/ 括号/ 中/ 的/ 数字/ ,/ 是/ 新/ 方法/ 相比/ 于/ 它们/ 的/ 加速/ 率/ ./ 5.2/ 内存/ 分析/ 对于/ 分辨率/ 为/ 512/ ×/ 512/ 的/ 场景/ 绘制/ ,/ 我们/ 的/ 方法/ 只/ 需要/ 2MB/ 显存/ 来/ 存储/ 前/ 后面/ 的/ 片元/ ,/ 同时/ 使用/ 2MB/ 显存/ 存储/ 中间/ 绘制/ 结果/ ,/ 与/ 双面/ 深度/ 剥离/ 方法/ 相当/ ./ 而/ 对于/ MDTS/ 及/ ABS/ 这/ 两种/ 基于/ CUAD/ 的/ 方法/ 及桶/ 剥离/ 的/ 方法/ ,/ 它们/ 需要/ 消耗/ 非常/ 大/ 的/ 显存/ ,/ 表/ 3/ 不同/ 图像/ 分辨率/ 及/ 场景/ 深度/ 下/ 的/ 各/ 对比/ 方法/ 的/ 显存/ 使用/ 情况/ 216181241/ 层次/ (/ 分辨率/ )/ 20/ 层/ (/ 512/ ×/ 512/ )/ 60/ 层/ (/ 512/ ×/ 512/ )/ 20/ 层/ (/ 1024/ ×/ 1024/ )/ 60/ 层/ (/ 1024/ ×/ 1024/ )/ 6/ 结束语/ 在/ GPU/ 上/ 进行/ 多片/ 元/ 效果/ 的/ 绘制/ ,/ 已有/ 方法/ 往往/ 要/ 进行/ 多遍/ 的/ 数据/ 读取/ ,/ 以/ 对/ 片元/ 进行/ 排序/ ./ 对此/ ,/ 本文/ 提出/ 一种/ 只/ 需/ 单遍/ 读取/ 模型/ 数据/ 的/ 方法/ ,/ 以/ 有效/ 降低/ 数据/ 读取/ 对/ 绘制/ 效率/ 的/ 影响/ ,/ 提高/ 绘制/ 速度/ ,/ 同时/ ,/ 能/ 使用/ 更/ 多/ 的/ 材质/ 信息/ 进行/ 复杂/ 的/ 光照/ 计算/ ,/ 提高/ 绘制/ 效果/ ./ 该/ 方法/ 主要/ 是/ 对模型/ 进行/ 凸/ 多面体/ 化/ 的/ 组织/ ,/ 逐个/ 地/ 将/ 凸/ 多面体/ 送入/ GPU/ 中以/ 有效/ 5068800/ // 128/ ,/ 6336000/ // 160/ ,/ 7603200/ // 192/ )/ ./ 从中/ 可见/ ,/ 新/ 方法/ 是/ 最快/ 的/ ,/ 即便/ 与/ 基于/ CUDA/ 的/ MDTS/ 方法/ 相比/ ,/ 新/ 方法/ 的/ 加速/ 效率/ 也/ 是/ 随着/ 深度/ 层次/ 的/ 增加/ 而/ 更好/ 的/ ./ 图/ 6/ 评估/ 深度/ 层次/ 对/ 绘制/ 效率/ 影响/ 的/ 16/ 层/ 测试/ 场景/ (/ 沿着/ 球面/ 层叠/ 方向/ 平行/ 观察/ ,/ 此/ 场景/ 深度/ 为/ 16/ 层/ ./ 其它/ 深度/ 的/ 测试/ 场景/ 列数/ 不变/ ,/ 深度/ 依次/ 加深/ 到/ 32/ 至/ 96/ 层/ )/ 场景/ 深度/ 越高/ ,/ 消耗/ 的/ 越/ 大/ ./ 相关/ 统计数据/ 在/ 表/ 3/ 中/ 列出/ ./ 从中/ 可见/ ,/ 当/ 绘制/ 分辨率/ 达到/ 1024/ ×/ 1024/ 时/ ,/ 我们/ 只/ 需/ 16MB/ 显存/ ,/ 而/ MDTS/ 方法/ 在/ 分辨率/ 为/ 1024/ ×/ 1024/ 、/ 层次/ 为/ 60/ 层时/ ,/ 所/ 需/ 的/ 内存/ 为/ 240MB/ ./ 显然/ ,/ 在/ 实际/ 应用/ 中/ 如此/ 大/ 的/ 空间/ 需求/ 是/ 难以/ 处理/ 的/ ./ 显存/ 需求/ // MB/ 处理/ 片元/ 的/ 排序/ ,/ 由此/ 实现/ 单遍/ 数据/ 读取/ 的/ 目的/ ./ 实验/ 表明/ ,/ 新/ 方法/ 相比/ 于/ 已有/ 工作/ 都/ 能/ 提高/ 速度/ ,/ 特别/ 是/ 在/ 处理/ 深度/ 复杂性/ 高/ 的/ 模型/ 时/ ,/ 其/ 加速/ 效果/ 更好/ ./ 本文/ 方法/ 的/ 效率/ 是/ 与/ 凸/ 多面体/ 个数/ 相关/ 的/ ./ 个数/ 越/ 少/ ,/ 加速/ 效果/ 越好/ ./ 因此/ ,/ 在/ 将来/ 的/ 工作/ 中/ ,/ 我们/ 将/ 进一步/ 研究/ 模型/ 的/ 凸/ 多面体/ 生成/ 方法/ ,/ 尽量减少/ 模型/ 分解/ 的/ 凸/ 多面体/ 个数/ ./ 致谢/ 感谢/ LouisBavoil/ 和/ KevinMyers/ 的/ 开源/ 测试代码/ ./ 感谢/ 刘芳/ 博士/ 和/ 黄梦成/ 博士/ 的/ 讨论/ 与/ 帮助/ !/ Page9/ 

