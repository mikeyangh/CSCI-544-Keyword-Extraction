Page1/ 软件/ 运行/ 时/ 可变性/ 动态/ 演化/ 机制/ 研究/ 刘吉伟/ 毛/ 新军/ (/ 国防科学技术大学/ 计算机/ 学院/ 长沙/ 410073/ )/ 摘要/ 持续/ 变化/ 的/ 需求/ 对/ 开放/ 环境/ 下/ 软件系统/ 的/ 灵活性/ 和/ 可伸缩性/ 提出/ 了/ 较/ 高/ 的/ 要求/ ./ 在/ 许多/ 情况/ 下/ ,/ 这/ 需要/ 系统/ 中/ 能够/ 发生变化/ 的/ 位置/ 、/ 变化/ 的/ 程度/ 等/ 可以/ 被/ 动态/ 调整/ ,/ 即/ 要求/ 软件/ 的/ 运行/ 时/ 可变性/ 是/ 可以/ 动态/ 演化/ 的/ ./ 然而/ 在/ 多数/ 系统/ (/ 例如/ 自/ 适应/ 系统/ )/ 中/ ,/ 软件/ 运行/ 时/ 可变性/ 受限于/ 开发者/ 在/ 设计阶段/ 基于/ 当时/ 需求/ 和/ 环境/ 要求/ 做出/ 的/ 决策/ 和/ 假设/ ,/ 使得/ 软件/ 可变性/ 模型/ 本身/ 是/ 难以/ 动态/ 改变/ 的/ ,/ 进而/ 导致/ 了/ 系统/ 在/ 运行/ 时/ 难以/ 适应/ 持续/ 变化/ 的/ 需求/ 和/ 环境/ ./ 软件/ 运行/ 时/ 可变性/ 动态/ 演化/ 是/ 解决问题/ 的/ 关键/ ./ 但/ 目前/ 只有/ 少数/ 研究/ 工作/ 关注/ 该/ 方面/ ,/ 而且/ 它们/ 往往/ 停留/ 在/ 模型/ 建立/ 和/ 验证/ 阶段/ ,/ 缺乏/ 如何/ 实现/ 动态/ 演化/ 的/ 研究/ ./ 为/ 解决/ 此/ 问题/ ,/ 提出/ 了/ 元变/ 机制/ 以/ 支持/ 对/ 可变性/ 要素/ 数量/ 、/ 属性/ 、/ 关系/ 的/ 改变/ ./ 元变/ 机制/ 利用/ 体系结构/ 动态/ 调整/ 技术/ 在/ 体系结构/ 和/ 构件/ 两个/ 层次/ 上/ 实现/ 可变性/ 演化/ 的/ 基本操作/ ,/ 即/ 可变性/ 要素/ 的/ 增加/ 、/ 替换/ 和/ 删除/ ;/ 又/ 利用/ 可变性/ 对象/ 实现/ 了/ 对/ 这些/ 操作/ 的/ 封装/ 和/ 信息/ 隐藏/ ,/ 使/ 人们/ 在/ 关注/ 高层/ 的/ 可变性/ 模型/ 变化/ 时/ 无须/ 考虑/ 可变性/ 要素/ 的/ 异构/ 性/ 等/ 细节/ ./ 该文/ 给出/ 了/ 元变/ 机制/ 的/ 基础设施/ 并/ 基于/ ./ NetFramework/ 阐述/ 了/ 其/ 生成/ 方法/ ,/ 并/ 提供/ 了/ 相应/ 工具/ 以/ 观察/ 或/ 触发/ 运行/ 时/ 可变性/ 模型/ 的/ 变化/ ,/ 最后/ 以/ 个人/ 云/ 资源/ 分享/ 为/ 背景/ ,/ 解决/ 了/ 资源/ 清理/ 案例/ 中/ 的/ 运行/ 时/ 可变性/ 的/ 动态/ 演化/ 问题/ ,/ 展示/ 了/ 元变/ 机制/ 的/ 可行性/ 和/ 有效性/ ;/ 并/ 对元变/ 机制/ 的/ 基本操作/ 进行/ 了/ 性能/ 测试/ ,/ 展示/ 了/ 其/ 高效性/ ./ 关键词/ 运行/ 时/ 可变性/ 动态/ 演化/ ;/ 演化/ 机制/ ;/ 运行/ 时/ 可变性/ ;/ 可变性/ 对象/ ;/ 软件体系结构/ 动态/ 调整/ ;/ 可变性/ 要素/ 1/ 引言/ 软件/ 可变性/ (/ SoftwareVariability/ )/ 是/ 指/ 在/ 一定/ 上下文/ 中/ 一个/ 软件系统/ 或/ 软件/ 制品/ (/ SoftwareArtefact/ )/ 被/ 有效/ 改变/ (/ 扩展/ 、/ 配置/ 、/ 调整/ )/ 的/ 能力/ [/ 1/ ]/ ./ 在/ 许多/ 软件系统/ 的/ 开发/ 运行/ 阶段/ 乃至/ 整个/ 生命周期/ 中/ ,/ 软件/ 可变性/ 都/ 是/ 其/ 设计/ 开发者/ 所/ 要/ 面对/ 的/ 基本/ 问题/ [/ 2/ ]/ ./ 软件/ 在/ 运行/ 时/ 表现/ 出/ 的/ 可变性/ 即/ 运行/ 时/ 可变性/ (/ RuntimeVariability/ )/ 被/ 认为/ 是/ 软件/ 应对/ 不断/ 演化/ 的/ 需求/ 或/ 环境/ 的/ 基本/ 能力/ [/ 3/ ]/ ,/ 近年来/ 越来越/ 受到/ 自/ 适应/ 系统/ [/ 4/ ]/ 、/ 动态/ 软件产品/ 线/ [/ 5/ ]/ 等/ 软件工程/ 领域/ 的/ 重视/ ./ 在/ 大多数/ 系统/ 中/ ,/ 运行/ 时/ 可变性/ 表现/ 为/ 软件/ 在/ 某个/ 或/ 某些/ 可变/ 点处/ 对/ 变体/ 的/ 绑定/ ./ 其中/ 可变/ 点/ (/ VariationPoint/ )/ 是/ 指/ 软件/ 中/ 可以/ 发生变化/ (/ 绑定/ 变体/ )/ 的/ 位置/ [/ 6/ ]/ ,/ 而/ 变体/ (/ Variant/ )/ 则/ 是/ 变化/ 发生/ 时/ ,/ 人/ 或/ 机器/ 可以/ 在/ 相应/ 位置/ 做出/ 的/ 选择/ (/ Option/ )/ ./ 可变/ 点/ 与/ 变体/ 统称/ 为/ 可变性/ 要素/ (/ VariabilityElement/ )/ ./ 例如/ 在/ 某/ 基于/ P2P/ 的/ 网络/ 数据传输/ 中/ ,/ 为/ 保证/ 用户/ 隐私/ 安全/ ,/ 数据/ 在/ 发送/ 之前/ 需要/ 使用/ 一定/ 算法/ 加密/ ./ 如图/ 1/ (/ 图例/ 参见/ 附录/ )/ ,/ 系统/ 设计者/ 将/ 抽象/ 的/ 加密算法/ (/ 在/ 代码/ 层面/ 上/ 可能/ 表现/ 为/ 委托/ 或/ 函数指针/ 等/ )/ 设置/ 为/ 可变/ 点/ ,/ 将/ 可/ 供选择/ 的/ 具体/ 算法/ 设置/ 为/ 变体/ ./ 机器/ 或/ 人/ 可以/ 根据/ 需要/ 通过/ 动态/ 的/ 绑定/ 具体/ 算法/ 以/ 在/ 系统/ 运行/ 时/ 被/ 调用/ ./ 可以/ 看出/ ,/ 在/ 软件/ 的/ 运行/ 实例/ 中/ ,/ 变化/ 发生/ 的/ 位置/ 、/ 变化/ 发生/ 的/ 程度/ (/ 决定/ 于/ 变体/ 和/ 可变性/ 要素/ 之间/ 的/ 关系/ )/ 是/ 在/ 设计阶段/ 预定/ 义/ 的/ ./ 而/ 这种/ 定义/ 又/ 在/ 很大/ 程度/ 上/ 依赖于/ 软件/ 的/ 需求/ 分析/ 以及/ 在/ 此基础/ 上/ 做出/ 的/ 种种/ 假设/ [/ 7/ -/ 8/ ]/ ./ 系统/ 虽然/ 具有/ 变体/ 绑定/ 能力/ 来/ 满足/ 既定/ 的/ 需求/ ,/ 但/ 可变性/ 模型/ (/ 可变/ 点/ 、/ 变体/ 以及/ 它们/ 之间/ 的/ 关系/ )/ 本身/ 没有/ 变化/ ,/ 导致/ 软件/ 在/ 应对/ 变化/ 的/ 需求/ 或/ 环境/ 时/ 存在/ 一定/ 限制/ ./ 在/ 上例/ 中/ ,/ 假如/ 系统/ 安全系数/ 提高/ ,/ 算法/ A/ 、/ B/ 、/ C/ 都/ 不能/ 达到/ 安全/ 标准/ ,/ 显然/ 仅/ 通过/ 传统/ 的/ 变体/ 绑定/ (/ VariantBinding/ )/ ,/ 无论/ 选择/ 哪个/ 变体/ 都/ 无法/ 使/ 系统/ 满足要求/ ./ 在/ 传统意义/ 上/ ,/ 软件/ 运行/ 时/ 可变性/ 模型/ 被/ 认为/ 是/ 静态/ 的/ ./ 在/ 许多/ 研究/ 工作/ 中/ (/ 如/ 文献/ [/ 9/ ]/ )/ ,/ 模型/ 被/ 以/ 只读/ 的/ 方式/ 访问/ ,/ 以/ 支持软件/ 适应/ 外部/ 的/ 环境/ (/ 见/ 第/ 2/ 节/ )/ ./ 人们/ 将/ 注意力/ 集中/ 在/ 可变性/ 绑定/ 方面/ (/ 即/ 为什么/ (/ 重新/ )/ 绑定/ 变体/ 、/ 绑定/ 什么/ 变体/ 、/ 怎样/ 绑定/ )/ ,/ 而/ 忽视/ 了/ 对/ 运行/ 时/ 可变性/ 模型/ 本身/ 蕴含/ 的/ 限制/ 的/ 突破/ ./ 随着/ 计算机技术/ 的/ 发展/ 进步/ 、/ 用户/ 需求/ 的/ 增多/ 及/ 变化/ 的/ 加快/ 、/ 系统/ 驻留/ 环境/ 的/ 开放/ 、/ 外界/ 对系统/ 灵活性/ 和/ 可伸缩性/ 要求/ 的/ 提高/ ,/ 这种/ 限制/ 显得/ 愈加/ 突出/ ./ 软件/ 运行/ 时/ 可变性/ 动态/ 演化/ 是/ 一种/ 解决问题/ 的/ 方法/ ./ 它/ 是/ 指人/ 或/ 机器/ 在/ 运行/ 时/ 对/ 软件/ 的/ 运行/ 时/ 可变性/ 模型/ 做出/ 的/ 调整/ ①/ ./ 这种/ 调整/ 表现/ 为/ 对/ 可变性/ 要素/ 数量/ 、/ 属性/ 和/ 相互/ 关系/ 的/ 改变/ ./ 对于/ 可变性/ 要素/ 数量/ 的/ 调整/ 可以/ 通过/ 向/ 当前/ 运行/ 时/ 可变性/ 模型/ 增加/ 新/ 的/ 可变/ 点/ 或/ 变体/ ,/ 或者/ 是/ 删除/ 模型/ 内/ 已/ 存在/ 的/ 要素/ 来/ 实现/ ./ 比如/ 在/ 上例/ 中/ 算法/ A/ 、/ B/ 、/ C/ 都/ 不/ 满足/ 安全/ 标准/ 的/ 情况/ 下/ ,/ 就/ 可以/ 通过/ 增加/ 满足/ 安全/ 需求/ 的/ 新/ 算法/ D/ (/ 变体/ )/ 以/ 使/ 软件/ 可/ 在/ 相应/ 的/ 可变/ 点处/ 绑定/ 它/ ,/ 进而/ 解决问题/ ./ 对于/ 可变性/ 要素/ 属性/ 的/ 改变/ 可以/ 通过/ 替换/ 相应/ 的/ 可变性/ 要素/ 来/ 完成/ ./ 如/ 在/ 上例/ 中/ ,/ 假设/ 人们/ 需要/ 在/ 绑定/ 算法/ 的/ 同时/ 配置/ 算法/ 的/ 参数/ ,/ 而/ 原有/ 可变/ 点/ 的/ ①/ 软件/ 的/ 运行/ 时/ 可变性/ 可以/ 在/ 其他/ 阶段/ 被/ 调整/ ,/ 比如/ 设计/ 阶/ Page3/ 属性/ 不能/ 满足/ 这个/ 要求/ (/ 如/ 函数/ 签名/ 不/ 匹配/ )/ ,/ 那么/ 其/ 属性/ 就/ 需要/ 发生/ 改变/ ./ 一般/ 通过/ 将/ 其/ 替换/ 为/ 具有/ 新/ 属性/ 的/ 可变/ 点/ 即可/ 达到/ 目的/ ./ 在/ 上例/ 中/ ,/ 假设/ 新增/ 的/ 算法/ D/ 需要/ 软件/ 在/ 可变/ 点处/ 通过/ 新/ 的/ 函数/ 签名/ 来/ 调用/ 之/ ,/ 那么/ 就/ 可以/ 通过/ 替换/ 原有/ 可变/ 点来/ 达到/ 目的/ ./ 可变性/ 要素/ 之间/ 的/ 关系/ 可以/ 视为/ 相关/ 要素/ 的/ 一种/ 特殊/ 属性/ ./ 因而/ 可以/ 通过/ 替换/ 关系/ 双方/ 之一/ 或/ 全部/ 来/ 调整/ 之/ ./ 在/ 上例/ 中/ ,/ 假设/ 因为/ 资源/ 占用/ 原因/ ,/ 使用/ 算法/ B/ 的/ 同时/ 不能/ 使用/ 算法/ C/ (/ 换言之/ ,/ B/ 排斥/ C/ )/ ,/ 而/ 新/ 需求/ 的/ 出现/ 使得/ 系统/ 需要/ 同时/ 调用/ B/ 和/ C/ 来/ 完成/ 数据/ 加密/ ./ 为/ 解决/ 此/ 问题/ ,/ 可以/ 通过/ 替换/ B/ 为/ 更为/ 优化/ 的/ 算法/ B/ 以/ 取消/ 原有/ B/ 与/ C/ 之间/ 的/ 排斥/ 关系/ ,/ 进而/ 使/ 系统/ 满足/ 需求/ ./ 综上所述/ ,/ 运行/ 时/ 可变性/ 动态/ 演化/ 是/ 通过/ 增加/ 、/ 替换/ 或/ 删除/ 可变性/ 要素/ 这些/ 基本操作/ 完成/ 的/ ./ 这些/ 操作/ 所/ 依赖/ 的/ 机制/ 即/ 软件/ 运行/ 时/ 可变性/ 动态/ 演化/ 机制/ (/ 下文/ 中/ 简称/ 演化/ 机制/ )/ ./ 对于/ 软件/ 可变性/ 演化/ 的/ 现有/ 研究/ (/ 如/ 文献/ [/ 10/ -/ 14/ ]/ 等/ )/ 基本上/ 停留/ 在/ 对于/ 可变性/ 及其/ 演化/ 的/ 模型/ 建立/ 、/ 表示/ [/ 15/ ]/ 和/ 验证/ 层面/ [/ 16/ ]/ ,/ 很少/ 有/ 研究/ 工作/ 关注/ 如何/ 设计/ 出/ 上述/ 的/ 演化/ 机制/ 以/ 实现/ 运行/ 时/ 可变性/ 的/ 动态/ 演化/ ./ 本文/ 认为/ 该/ 问题/ 难点/ 有/ 二/ :/ 首先/ 是/ 如何/ 找到/ 一种/ 独立/ 于/ 可变性/ 物理/ 实现/ 的/ 一般/ 机制/ ./ 演化/ 机制/ 与/ 可变性/ 要素/ 的/ 实现/ 密切相关/ ./ 因为/ 可变性/ 要素/ 的/ 异构/ 性/ 、/ 可追踪/ 性/ 和/ 抽象性/ 等/ 方面/ (/ 见/ 3.1/ 节/ 的/ 分析/ )/ 的/ 原因/ ,/ 在/ 可变性/ 演化过程/ 中/ 对/ 可变性/ 要素/ 实施/ 直接/ 的/ 操作/ (/ 尤其/ 是/ 对/ 可变/ 点/ 的/ 操作/ )/ 是/ 较为/ 困难/ 的/ ./ 我们/ 需要/ 一种/ 对/ 可变性/ 要素/ 的/ 实现/ 形式/ 具有/ 一般性/ 的/ 机制/ ./ 其次/ 是/ 什么样/ 的/ 基础设施/ 能够/ 支撑/ 这样/ 的/ 演化/ 机制/ ./ 我们/ 需要/ 它/ 能够/ 在/ 较/ 高/ 的/ 抽象/ 层面/ 隐藏/ 演化/ 机制/ 的/ 执行/ 细节/ (/ 这些/ 细节/ 可能/ 会/ 因为/ 可变性/ 要素/ 的/ 异构/ 性/ 等/ 原因/ 而/ 有所不同/ )/ ;/ 在/ 较/ 低/ 的/ 抽象/ 层面/ 又/ 能/ 支持/ 机制/ 的/ 执行/ ./ 针对/ 这/ 两个/ 问题/ ,/ 在/ 可变性/ 对象/ 和/ 体系结构/ 动态/ 调整/ 的/ 基础/ 上/ 设计/ 了/ 相应/ 机制/ (/ 称为/ 元变/ 机制/ )/ 及其/ 相关/ 基础设施/ ./ 本文/ 第/ 2/ 节/ 分析/ 相关/ 研究/ 工作/ ,/ 对比/ 本文/ 主题/ 与/ 解决/ 类似/ 问题/ 的/ 相关/ 研究/ 领域/ ;/ 第/ 3/ 节/ 首先/ 分析/ 可变性/ 要素/ 的/ 异构/ 性/ 、/ 可追踪/ 性/ 和/ 抽象性/ ,/ 而后/ 在/ 此基础/ 上/ 论述/ 元变/ 机制/ 的/ 执行/ 过程/ 、/ 基础设施/ 及其/ 关键技术/ ;/ 第/ 4/ 节以/ 个人/ 云为/ 背景/ 展示/ 元变/ 机制/ 对/ 软件/ 运行/ 时/ 可变性/ 动态/ 演化/ 的/ 支持/ 并/ 对/ 机制/ 作/ 性能/ 测试/ ;/ 最后/ 一节/ 总结/ 全文/ 并/ 做出/ 展望/ ./ 2/ 相关/ 工作/ 分析/ 本/ 节/ 通过/ 对比/ 自/ 适应/ 系统/ 、/ 动态/ 软件产品/ 线/ 等/ 领域/ 的/ 概念/ 和/ 思想/ 与/ 软件/ 运行/ 时/ 可变性/ 动态/ 演化/ 的/ 不同/ ,/ 以/ 进一步/ 明确/ 本文/ 的/ 问题/ 与/ 主要/ 贡献/ ./ 2.1/ 自/ 适应/ 系统/ 与/ 运行/ 时/ 可变性/ 动态/ 演化/ 自/ 适应/ 系统/ (/ Self/ -/ adaptiveSystems/ )/ 可以/ 自动/ 地/ 根据/ 环境/ 的/ 变化/ 来/ 调整/ 自身/ [/ 4/ ]/ ./ 换言之/ ,/ 它/ 可以/ 收集/ 和/ 分析/ 有关/ 环境/ 的/ 信息/ ,/ 基于/ 分析/ 的/ 结果/ 决定/ 是否/ 改变/ 自己/ 的/ 结构/ 或/ 行为/ ,/ 如果/ 是/ ,/ 再/ 采取/ 调整/ 动作/ [/ 17/ ]/ ./ 这/ 4/ 个/ 环节/ 构成/ 了/ 自/ 适应/ 系统/ 以及/ 与其/ 类似/ 系统/ 最/ 基本/ 的/ 行为/ 模式/ ,/ 也/ 决定/ 了/ 自/ 适应/ 系统/ 本身/ 难以/ 应对/ 不断/ 演化/ 的/ 需求/ 或/ 环境/ ./ 原因/ 如下/ :/ 系统/ 的/ 设计者/ 必须/ 指出/ 或/ 假设/ 系统/ 所/ 面对/ 环境/ 变化/ 等/ 信息/ ,/ 才能/ 确定/ 系统/ 所/ 能够/ 感知/ 和/ 收集/ 的/ 环境/ 数据/ ,/ 进而/ 以/ 一定/ 的/ 数据结构/ 将/ 其/ 表示/ 在/ 计算机/ 内/ ./ 而后/ 才能/ 设计/ 相应/ 的/ 算法/ 对/ 这些/ 信息/ 进行/ 分析/ 并/ 做出/ 决策/ ./ 设计者/ 难以/ 在/ 系统/ 部署/ 运行/ 之前/ 设想/ 所有/ 的/ 需求/ 或/ 环境/ 的/ 变化/ ,/ 当/ 超过/ 预期/ 的/ 变化/ 出现/ 时/ ,/ 已经/ 成型/ 的/ 自/ 适应/ 系统/ 无法/ 自动/ 地/ 收集/ 与其/ 相关/ 的/ 信息/ ,/ 更/ 不论/ 其余/ 3/ 个/ 环节/ ./ 换言之/ ,/ 自/ 适应/ 技术/ 难以解决/ 运行/ 时/ 可变性/ 动态/ 演化/ 能够/ 解决/ 的/ 问题/ ./ 其次/ ,/ 在/ 大部分/ 情况/ 下/ ,/ 自/ 适应/ 在/ 执行/ 环节/ 对于/ 自身/ 的/ 调整/ 实际上/ 是/ 软件/ 在/ 可变/ 点处/ 对于/ 变体/ 的/ 动态/ 绑定/ ,/ 这/ 是/ 其/ 运行/ 时/ 可变性/ 的/ 表现/ (/ 如/ 文献/ [/ 9/ ]/ )/ ./ 比如/ 在/ 图/ 1/ 的/ 例子/ 中/ ,/ 系统/ 能够/ 根据/ 不同/ 的/ 加密/ 级别/ 选择/ 绑定/ 不同/ 的/ 算法/ ./ 自/ 适应/ 并未/ 改变/ 可变性/ 要素/ 的/ 数量/ 、/ 属性/ 或/ 关系/ ,/ 所以/ 不是/ 运行/ 时/ 可变性/ 的/ 动态/ 演化/ ./ 再次/ ,/ 系统/ 的/ 自/ 适应/ 行为/ 不/ 需要/ 人类/ 干预/ (/ 至少/ 人们/ 希望/ 是/ 这样/ )/ ./ 这/ 意味着/ 来源于/ 自动控制/ 理论/ 的/ 闭合/ 控制/ 环路/ 是/ 必不可少/ 的/ ./ 运行/ 时/ 可变性/ 的/ 动态/ 演化/ 需要/ 系统/ 开发者/ 或/ 维护者/ 触发/ 系统对/ 可变性/ 要素/ 的/ 增加/ 、/ 删除/ 或/ 替换/ 行为/ ,/ 并/ 干预/ 其中/ 的/ 一部分/ 活动/ ./ 闭合/ 环路/ 对于/ 系统/ 的/ 构建/ 而言/ 不是/ 必要条件/ ./ 最后/ ,/ 针对/ 自/ 适应/ 系统/ 难以/ 应对/ 非/ 预期/ 环境/ 变化/ 的/ 问题/ ,/ 有/ 研究/ 工作/ 提出/ 对系统/ 本身/ 进行/ 演化/ 的/ 解决/ 方法/ ./ 例如/ 文献/ [/ 18/ ]/ ,/ 通过/ 对/ 感知/ 、/ 决策/ 、/ 执行/ 等/ 环节/ 的/ 封装/ 以及/ 体系结构/ 的/ 动态/ 调整/ ,/ 支持/ 对系统/ 适应环境/ 能力/ 的/ 在线/ 调整/ ./ 这种/ 调整/ 类似/ 于/ 2.2/ 节/ 提到/ 的/ 动态/ 软件产品/ 线/ 的/ 领域/ 工程/ 过程/ ./ 值得注意/ Page4/ 的/ 是/ ,/ 上述/ 的/ 调整/ 并/ 不/ 意味着/ 闭合/ 控制/ 环路/ 和/ 自动/ 执行/ ,/ 所以/ 其/ 已/ 超过/ 了/ 自/ 适应/ 这一/ 概念/ 涵盖/ 的/ 范围/ ./ 实际上/ ,/ 运行/ 时/ 可变性/ 的/ 动态/ 演化/ 允许/ 系统/ 设计者/ 从/ 更为/ 一般/ 的/ 意义/ 上/ 实现/ 对系统/ 的/ 改变/ ./ 比如/ ,/ 它/ 也/ 可以/ 应用/ 于/ 自/ 适应/ 系统/ ,/ 而且/ 可以/ 实现/ 对系统/ 中/ 各个/ 层面/ 上/ 可变性/ 要素/ 的/ 调整/ ,/ 并/ 不/ 局限于/ 系统/ 的/ 执行/ 环节/ ./ 与/ 自/ 适应/ 系统/ 类似/ 的/ 是/ 自治/ 系统/ (/ AutonomicSystem/ )/ [/ 19/ ]/ ./ 自治/ 系统/ 观察/ 的/ 对象/ 是/ 其/ 自身/ ,/ 目标/ 是/ 自我管理/ ,/ 具有/ 监视/ 、/ 分析/ 、/ 计划/ 和/ 执行/ 共/ 4/ 个/ 环节/ 组成/ 的/ 控制/ 环路/ ./ 该/ 系统/ 实际上/ 是/ 一类/ 特殊/ 的/ 自/ 适应/ 系统/ [/ 20/ ]/ ,/ 所以/ 不再/ 赘述/ 自治/ 技术/ 与/ 软件/ 运行/ 时/ 可变性/ 动态/ 演化/ 的/ 不同/ ./ 2.2/ 动态/ 软件产品/ 线/ 与/ 运行/ 时/ 可变性/ 动态/ 演化/ 软件产品/ 线/ (/ SoftwareProductLine/ )/ 包括/ 一组/ 核心/ 资产/ (/ CoreAssets/ )/ 和/ 从/ 资产/ 开发/ 而来/ 的/ 一系列/ 具有/ 共同/ 特征/ 的/ 软件/ 密集/ 系统/ (/ 即/ 软件产品/ )/ [/ 21/ ]/ ./ 它/ 是/ 目前/ 可变性/ 研究/ 最为/ 深入/ 的/ 领域/ ./ 动态/ 软件产品/ 线/ (/ DynamicSoftwareProductLine/ ,/ DSPL/ )/ 专注/ 于/ 传统/ 软件产品/ 线/ 所/ 不/ 关注/ 的/ 运行/ 时/ 可变性/ ,/ 扩展/ 了/ 后者/ 的/ 概念/ 和/ 范畴/ [/ 22/ ]/ ./ 但是/ 目前/ 其/ 关注/ 的/ 运行/ 时/ 可变性/ 大部分/ 都/ 是/ 封闭/ 的/ 而/ 非/ 开放/ 的/ [/ 22/ ]/ ,/ 这/ 意味着/ 运行/ 时/ 可变性/ 应对/ 的/ 是/ 开发者/ 在/ 设计/ 期/ 设想/ 的/ 环境/ 变化/ ,/ 导致/ 软件产品/ 难以/ 应对/ 超过/ 预期/ 的/ 环境/ 变化/ ./ DSPL/ 本质/ 上/ 是/ 一种/ 建立/ (/ 一系列/ )/ 自/ 适应/ 系统/ 的/ 方法/ [/ 23/ ]/ ./ 如/ 文献/ [/ 22/ ]/ 所/ 言/ ,/ 产品线/ 自身/ 的/ 设计者/ 可以/ 通过/ 领域/ 工程/ 过程/ 和/ 应用/ 工程/ 过程/ 快速/ 开发/ 出/ 具有/ 运行/ 时/ 可变性/ 的/ 软件产品/ ,/ 并/ 赋予/ 其/ 自主/ 选择/ 绑定/ 变体/ 的/ 能力/ ./ 与其/ 不同/ 的/ 是/ ,/ 运行/ 时/ 可变性/ 动态/ 演化/ 面向/ 的/ 是/ 单个/ 系统/ (/ SingleSystem/ )/ ,/ 而且/ 并非/ 针对/ 自/ 适应/ 系统/ ./ 根据/ 文献/ [/ 24/ ]/ 的/ 综述/ ,/ 软件/ 运行/ 时/ 可变性/ 并/ 不/ 局限于/ 软件/ 动态/ 产品线/ ,/ 这/ 意味着/ 其/ 动态/ 演化/ 可能/ 发生/ 在/ 任何/ 面对/ 持续/ 变化/ 需求/ 和/ 环境/ 的/ 系统/ 中/ ./ 这样/ 的/ 系统/ 能够/ 在/ 人/ 或/ 软件/ 的/ 干预/ 下/ 使/ 自身/ 的/ 结构/ 或/ 行为/ 发生变化/ ,/ 而/ 演化/ 的/ 目的/ 就是/ 调整/ 这种/ 变化/ 发生/ 的/ 位置/ 和/ 变化/ 的/ 程度/ ./ 2.3/ 运行/ 时/ 可变性/ 绑定/ 机制/ 与/ 运行/ 时/ 可变性/ 动态/ 演化/ 运行/ 时/ 可变性/ 绑定/ 机制/ ①/ (/ RuntimeVariabilityMechanisms/ ,/ 下文/ 中/ 简称/ 绑定/ 机制/ )/ 描述/ 一个/ 运行/ 中/ 的/ 软件/ 如何/ 在/ 一个/ 可变/ 点/ 绑定/ 相应/ 的/ 变体/ ,/ 是/ 软件/ 可变性/ 实现/ 的/ 核心/ ,/ 是/ 上述/ 自/ 适应/ 系统/ 、/ 自治/ 系统/ 、/ 动态/ 软件产品/ 线/ 等/ 所/ 依赖/ 的/ 基本/ 技术/ 之一/ ,/ 与/ 本文/ 问题/ 联系/ 相对/ 紧密/ ,/ 在/ 目前/ 多篇/ 文献/ (/ 如/ 文献/ [/ 1/ ,/ 3/ ,/ 25/ -/ 27/ ]/ )/ 中/ 有所/ 总结/ 和/ 论述/ ./ 绑定/ 机制/ 可以/ 按照/ 可变性/ 要素/ 在/ 软件体系结构/ 中/ 不同/ 层次/ 的/ 实现/ [/ 28/ ]/ 分类/ ./ (/ 1/ )/ 体系结构/ 层/ 这/ 一/ 层次/ 的/ 绑定/ 机制/ 往往/ 涉及/ 软件体系结构/ 的/ 重/ 配置/ 或是/ 对系统/ 内/ 已有/ 构件/ 的/ 动态/ 绑定/ ./ 体系结构/ 的/ 重/ 配置/ 即/ 调整/ 构件之间/ 关系/ ,/ 重新/ 组织系统/ 内/ 已有/ 构件/ ./ 构件/ 的/ 动态/ 绑定/ 即/ 软件/ 在/ 运行/ 时/ 根据/ 不同/ 的/ 需要/ 在/ 具有/ 相同/ 接口/ 的/ 一组/ 构件/ 中/ 选择/ 并/ 完成/ 初始化/ 和/ 调用/ 过程/ ./ (/ 2/ )/ 构件/ 层/ 和/ 代码/ 层/ 这/ 两个/ 层次/ 的/ 绑定/ 机制/ 涉及/ 对/ 构件/ 内部结构/ 和/ 行为/ 的/ 调整/ ./ 同/ 软件体系结构/ 类似/ ,/ 调整/ 构件/ 内部结构/ 也/ 包括/ 对子/ 构件/ (/ 或者/ 更/ 小/ 粒度/ 的/ 软件/ 实体/ )/ 的/ 重/ 配置/ 和/ 动态/ 绑定/ ./ 对/ 构件/ 行为/ 的/ 调整/ 往往/ 通过/ 重新/ 组织/ 构件/ 的/ 工作/ 流/ 或是/ 重新/ 设置/ 构件/ 内部/ 参数/ 来/ 实现/ ./ 通常/ 绑定/ 机制/ 并/ 不/ 改变/ 可变性/ 要素/ 的/ 数量/ 、/ 属性/ 和/ 关系/ ./ 但/ 有/ 一种/ 例外/ :/ 重新/ 组织系统/ 内部/ 的/ 软件/ 实体/ 可以/ 用于/ 动态/ 生成/ 新/ 的/ 变体/ (/ 即/ 3.1/ 节/ 的/ 组织/ 型/ 变体/ )/ ./ 在/ 图/ 1/ 的/ 例子/ 中/ ,/ 以/ 不同/ 的/ 顺序/ 和/ 参数/ 组织/ 多种/ 加密算法/ 可以/ 在/ 运行/ 时/ 生成/ 新/ 的/ 加密/ 过程/ ./ 这些/ 过程/ 具有/ 一致/ 的/ 接口/ ,/ 可以/ 作为/ 变体/ 被/ 相应/ 的/ 可变/ 点/ 绑定/ 和/ 调用/ ./ 这是/ 绑定/ 机制/ 用于/ 软件/ 可变性/ 动态/ 演化/ 的/ 一个/ 特例/ ./ 在/ 本文/ 中/ ,/ 该/ 绑定/ 机制/ 被/ 视作/ 增加/ 组织/ 型/ 变体/ 的/ 一种/ 方法/ ./ 3/ 支持/ 运行/ 时/ 可变性/ 动态/ 演化/ 的/ 元变/ 机制/ 本/ 节/ 根据/ 可变性/ 要素/ 的/ 异构/ 性/ 、/ 可追踪/ 性/ 和/ 抽象性/ 指出/ 了/ 可变性/ 要素/ 的/ 不同/ 实现/ 形式/ ,/ 以及/ 元变/ 机制/ 所/ 采用/ 的/ 技术/ ,/ 而后/ 描述/ 了/ 元变/ 机制/ 在/ 软件体系结构/ 和/ 构件/ 两个/ 层次/ 上/ 对/ 可变性/ 要素/ 的/ 操作过程/ ,/ 最后/ 论述/ 支持/ 元变/ 机制/ 实现/ 的/ 关键技术/ ./ 3.1/ 基于/ 可变性/ 要素/ 的/ 异构/ 性/ 、/ 可追踪/ 性/ 和/ 抽象性/ 的/ 技术/ 考虑/ 3.1/ ./ 1/ 可变性/ 要素/ 的/ 异构/ 性/ 、/ 可追踪/ 性/ 和/ 抽象性/ (/ 1/ )/ 异构/ 性/ 可变性/ 要素/ 的/ 异构/ 性/ 表现/ 在/ :/ 在/ 逻辑/ 层面/ 上同/ ①/ 这里/ 的/ “/ 绑定/ 机制/ ”/ 是/ 为了/ 在/ 术语/ 方面/ 与/ “/ 演化/ 机制/ ”/ 相区/ Page5/ 一个/ 系统/ 中/ 的/ 两个/ 可变性/ 要素/ ,/ 在/ 代码/ 层面/ 上/ 可能/ 具有/ 不同/ 的/ 实现/ ./ 比如/ ,/ 因为/ 忽略/ 实现/ 细节/ ,/ 在/ 逻辑/ 层面/ 上/ 的/ 两个/ 变体/ 可能/ 仅仅/ 是/ 名称/ 等/ 属性/ 不同/ ;/ 而/ 在/ 实现/ 层面/ 两者/ 的/ 实现/ 形式/ 可能/ 完全/ 不同/ ./ 具体/ 可/ 参见/ 下文/ 对/ 可变性/ 要素/ 实现/ 形式/ 的/ 分类/ ./ 由于/ 编程语言/ 、/ 运行/ 环境/ 等/ 因素/ ,/ 可变性/ 要素/ 的/ 实现/ 形式/ 是/ 多种多样/ 的/ ./ 这/ 导致/ 与其/ 实现/ 形式/ 相关/ 的/ 增加/ 、/ 删除/ 和/ 替换/ 操作/ (/ 如果/ 这些/ 操作/ 存在/ 且/ 可行/ )/ 也/ 是/ 具有/ 不同/ 的/ 实现/ 细节/ ./ 如果/ 直接/ 采用/ 这些/ 操作/ 来/ 完成/ 演化/ ,/ 软件/ 内部/ 需要/ 包含/ 所有/ 不同/ 类型/ 操作/ 的/ 代码/ ,/ 开发/ 和/ 维护/ 一个/ 这样/ 的/ 软件/ 很/ 可能/ 会/ 消耗/ 较大/ 的/ 成本/ ./ (/ 2/ )/ 可追踪/ 性/ 在/ 软件/ 可变性/ 的/ 上下文/ 中/ ,/ 可追踪/ 性/ 考察/ 逻辑/ 层面/ 上/ 的/ 可变性/ 要素/ 在/ 软件/ 中/ 的/ 物理/ 实现/ 以及/ 在/ 逻辑/ (/ 符号/ )/ 层面/ 上/ 表达/ 这种/ 实现/ 的/ 难易/ 程度/ ./ 因为/ 模块化/ 程度/ 等/ 原因/ ,/ 一个/ 变体/ 可能/ 被/ 非/ 显式/ 的/ 表达/ 为/ 一个/ 代码/ 片断/ (/ 如/ 一个/ 函数/ 的/ 一部分/ )/ ,/ 也/ 有/ 可能/ 被/ 实现/ 为/ 构件/ 的/ 一部分/ (/ 如/ 一个/ 构件/ 内部/ 的/ 软件/ 实体/ )/ ,/ 或者/ 是/ 一个/ 构件/ ,/ 甚或/ 是/ 由/ 多个/ 构件/ 组成/ 的/ (/ 如/ 一个/ 子系统/ )/ ①/ (/ 如图/ 2/ )/ ./ 其/ 对应/ 的/ 可变/ 点/ 也/ 可能/ 存在/ 同样/ 的/ 情况/ ./ 图/ 2/ 可变性/ 要素/ 在/ 体系结构/ 层面/ 的/ 可追踪/ 性/ 一般而言/ ,/ 可变性/ 要素/ 对应/ 的/ 软件/ 制品/ (/ 指/ 软件/ 生命周期/ 中/ 人工/ 制造/ 出/ 的/ 产物/ ,/ 如/ 代码/ 片段/ )/ 的/ 模块化/ 程度/ 越高/ ,/ 其/ 可追踪/ 性越/ 高/ ,/ 对/ 增加/ 、/ 删除/ 或/ 替换/ 操作/ 的/ 支持/ 也/ 可能/ 越好/ ./ 但/ 出于/ 其他/ 方面/ (/ 如/ 开发成本/ )/ 的/ 考虑/ ,/ 并/ 不是/ 每个/ 可变性/ 要素/ 都/ 实现/ 为/ 模块化/ 的/ 软件/ 制品/ ./ 这/ 在/ 一定/ 程度/ 上/ 导致/ 难以/ 直接/ 对/ 可追踪/ 性差/ 的/ 可变性/ 要素/ 进行/ 演化/ 操作/ ./ (/ 3/ )/ 抽象性/ 从/ 可追踪/ 性/ 角度/ 而言/ ,/ 变体/ 可以/ 被/ 实现/ 为/ 具有/ 独立/ 意义/ 的/ 软件/ 实体/ ,/ 但/ 不/ 一定/ 是/ 可以/ 被/ 动态/ 增加/ 或/ 删除/ 的/ 构件/ ./ 可变/ 点/ 的/ 抽象性/ 比/ 变体/ 高/ ./ 而/ 可变/ 点/ 在/ 体系结构/ 层面/ 上/ 往往/ 不/ 具有/ 直接/ 的/ 实现/ 形式/ 而/ 只有/ 抽象/ 的/ 表现/ (/ 见图/ 3/ )/ ./ 可变/ 点/ 所在/ 的/ 抽象层次/ 使得/ 很难/ 在/ 物理/ 实现/ 层面/ 上将/ 可变/ 点/ 从/ 软件/ 实体/ 中/ 独立/ 出来/ ,/ 形成/ 关注点/ 分离/ ./ 这个/ 性质/ 导致/ 直接/ 实现/ 可变/ 点/ 的/ 增加/ 、/ 删除/ 或/ 替换/ 较为/ 困难/ ,/ 而且/ 往往/ 需要/ 人/ 的/ 参与/ [/ 31/ ]/ ./ 这是/ 软件/ 运行/ 时/ 可变性/ 动态/ 演化/ 需要/ 人/ 干预/ 的/ 原因/ 之一/ ./ 在/ 大多数/ 情况/ 下/ ,/ 由于/ 可变性/ 要素/ 的/ 可追踪/ 性/ 和/ 抽象性/ ,/ 并/ 不是/ 所有/ 的/ 可变性/ 要素/ 都/ 可以/ 通过/ 与其/ 实现/ 形式/ 直接/ 相关/ 的/ 操作/ 来/ 完成/ 可变性/ 演化/ ./ 即使/ 这些/ 直接/ 操作/ 都/ 存在/ 且/ 可行/ ,/ 由于/ 可变性/ 要素/ 的/ 异构/ 性/ ,/ 系统/ 需要/ 包含/ 其/ 所有/ 种类/ 操作/ 的/ 代码/ 描述/ ,/ 会/ 带来/ 较大/ 的/ 开发/ 和/ 维护/ 成本/ ./ 综上所述/ ,/ 在/ 可变性/ 演化过程/ 中/ 直接/ 操作/ 可变性/ 要素/ 是/ 较为/ 困难/ 的/ ./ 3.1/ ./ 2/ 可变性/ 要素/ 的/ 实现/ 形式/ 根据/ 上/ 一节/ 对/ 可变性/ 要素/ 的/ 异构/ 性/ 、/ 可追踪/ 性/ 和/ 抽象性/ 的/ 讨论/ ,/ 可变性/ 要素/ 在/ 软件体系结构/ 中/ 的/ 3/ 个/ 层次/ (/ 体系结构/ 层/ 、/ 构件/ 层/ 和/ 代码/ 层/ [/ 28/ ]/ )/ 内/ 存在/ 不同/ 的/ 实现/ 形式/ ./ 可变性/ 要素/ 的/ 实现/ 意味着/ 可变/ 点/ 可/ 在/ 体系结构/ 内/ 被/ 表示/ ,/ 或/ 变体/ 可/ 在/ 体系结构/ 内/ 被/ 实现/ ./ 体系结构/ 中/ 最/ 根本/ 的/ 要素/ 即/ 构件/ [/ 32/ ]/ ,/ 即/ 具有/ 预定/ 义/ 接口/ 的/ 一段/ 代码/ ,/ 可以/ 对外/ 提供/ 封装/ 在/ 其/ 内部/ 的/ 功能/ [/ 33/ ]/ ./ 然而/ 构件/ 与/ 可变性/ 要素/ 之间/ 不/ 存在/ 一定/ 的/ 关系/ ,/ 可变性/ 要素/ 具有/ 异构/ 性/ ./ 可变/ 点/ 和/ 变体/ 都/ 可/ 在/ 软件体系结构/ 层/ 、/ 构件/ 层/ 和/ 代码/ 层内/ 被/ 表示/ 或/ 被/ 实现/ ,/ 如图/ 3/ ./ 属于/ 制品/ 依赖/ (/ ArtefactDependency/ )/ [/ 2/ ]/ 的/ “/ 被/ 包含/ 于/ ”/ 关系/ 是/ 指/ (/ 构件/ 层/ 或/ 代码/ 层/ 的/ )/ 变体/ 可/ 在/ 构件/ 内部/ 被/ 实现/ ;/ 可变/ ①/ 一个/ 可变性/ 要素/ 究竟/ 实现/ 为什么/ 软件/ 实体/ 决定/ 于/ 设计者/ 按/ Page6/ 点/ 制品/ 依赖/ (/ VariationPointArtefactDependency/ )/ [/ 2/ ]/ 的/ “/ 被/ 包含/ 于/ ”/ 关系/ 是/ 指/ (/ 构件/ 层/ 或/ 代码/ 层/ 的/ )/ 可变/ 点/ 可/ 在/ 构件/ 内部/ 被/ 表示/ ./ 值得注意/ 的/ 是/ ,/ 根据/ 对/ 可追踪/ 性/ 的/ 讨论/ ,/ 直接/ 表示/ 可变/ 点/ 或/ 直接/ 实现/ 变体/ 的/ 软件/ 制品/ 并不一定/ 是/ (/ 完全/ )/ 模块化/ 的/ ,/ 然而/ 我们/ 总能/ 找到/ 一个/ 粒度/ 较大/ 的/ 模块化/ 的/ 软件/ 制品/ (/ 例如/ 一个/ 构件/ )/ ,/ 其/ 包含/ 该软件/ 制品/ ,/ 能够/ 运行/ 该软件/ 制品/ 的/ 实例/ ./ 这/ 是/ 图/ 3/ 中/ 各类/ “/ 被/ 包含/ 于/ ”/ 关系/ 的/ 确切/ 含义/ ./ 在下文/ 中/ ,/ 为/ 论述/ 简洁/ ,/ 我们/ 说/ “/ 某/ 可变性/ 要素/ 被/ 实现/ 为/ 某/ 软件/ 制品/ ”/ ,/ 即/ 指该/ 可变/ 点/ 或/ 变体/ 被/ 直接/ 表示/ 为/ 或/ 被/ 实现/ 为/ 该软件/ 制品/ ,/ 或/ 在/ 后者/ 内/ 被/ 表示/ 或/ 被/ 实现/ ./ 演化/ 机制/ 与/ 可变性/ 要素/ 的/ 实现/ 紧密/ 相关/ ./ 不同/ 的/ 实现/ 形式/ 意味着/ 不同/ 的/ 演化/ 机制/ ./ 按照/ 可变性/ 要素/ 对应/ 的/ 绑定/ 机制/ ,/ 可变性/ 要素/ 的/ 实现/ 形式/ 可/ 分为/ 选择/ 型/ 和/ 组织/ 型/ ,/ 每种/ 形式/ 可以/ 根据/ 其/ 实现/ 进一步/ 细化/ 分类/ ,/ 如图/ 4/ 所示/ ./ 选择/ 型/ 可变性/ 要素/ 通常/ 具有/ 特定/ 的/ 语义/ ,/ 不能/ 通过/ 组合/ 系统/ 内/ 其他/ 的/ 可变性/ 要素/ 或/ 软件/ 制品/ 来/ 生成/ ./ 例如/ 在/ 体系结构/ 层内/ ,/ 此类/ 可变性/ 要素/ 可能/ 属于/ 构件/ 型/ ./ 其/ 可变/ 点/ 表现/ 为/ 构件/ 接口/ ,/ 变体/ 实现/ 为/ 满足/ 该/ 接口/ 的/ 构件/ ./ 软件/ 可以/ 在/ 诸多/ 变体/ 中/ 选择/ 一个/ 进行/ 绑定/ ./ 组织/ 型/ 可变性/ 要素/ 对应/ 的/ 变体/ 是/ 通过/ 组织系统/ 内/ 已有/ 的/ 软件/ 实体/ 形成/ 的/ ./ 换言之/ ,/ 一个/ 变体/ 实际上/ 是/ 软件/ 实体/ 的/ 一种/ 组织/ 形式/ (/ 在/ 实现/ 层面/ 可能/ 是/ 描述性/ 的/ 数据/ ,/ 不/ 包含/ 程序/ )/ ./ 例如/ 在/ 服务/ 组合/ 的/ 上下文/ 中/ ,/ 不同/ 的/ 变体/ 即/ 原子/ 服务/ 的/ 不同/ 组合/ ,/ 相应/ 的/ 可变/ 点/ 表现/ 为/ 可/ 对/ 它们/ 进行/ 调用/ 的/ 接口/ ./ 两种/ 类型/ 的/ 可变性/ 要素/ 的/ 细化/ 分类/ 参见/ 表/ 1/ ,/ 其中/ 可变性/ 要素/ 的/ 具体/ 实现/ 与/ 软件/ 运行/ 平台/ 和/ 编程语言/ 等/ 方面/ 有关/ ,/ 表/ 1/ 中仅/ 为/ 举例/ ./ 表/ 1/ 可变性/ 要素/ 的/ 细化/ 分类/ 及/ 举例/ (/ 以/ C#/ 语言/ 为/ 背景/ )/ 实现/ 形式/ 构件/ 型/ 参数/ 型/ 功能型/ 配置/ 型/ 工作/ 流型/ 数据/ 集型/ 3.1/ ./ 3/ 技术/ 考虑/ 元变/ 机制/ 对/ 技术/ 的/ 采用/ 主要/ 考虑/ 两个/ 方面/ :/ 一是/ 运行/ 时/ 可变性/ 模型/ 的/ 表示/ ;/ 二是/ 增加/ 、/ 替换/ 、/ 删除/ 可变性/ 要素/ 操作/ 所/ 依赖/ 的/ 方法/ ./ 软件/ 中/ 对/ 运行/ 时/ 可变性/ 模型/ 进行/ 表示/ 是/ 为了/ 方便/ 在/ 演化过程/ 中/ 对/ 可变性/ 要素/ 信息/ 的/ 表示/ 和/ 管理/ ./ 在/ 本文/ 中/ ,/ 模型表示/ 的/ 意义/ 在于/ 在/ 较/ 高/ 的/ 抽象层次/ 隐藏/ 对/ 可变性/ 要素/ 操作/ 的/ 细节/ (/ 如/ 可变性/ 要素/ 的/ 异构/ 性/ 带来/ 的/ 操作方法/ 的/ 不同/ )/ ,/ 并/ 在/ 较/ 低层次/ 支持/ 演化/ 机制/ 的/ 执行/ (/ 即/ 增加/ 、/ 替换/ 、/ 删除/ 某/ 类型/ 的/ 可变性/ 要素/ )/ ./ 这样/ 可以/ 便于/ 系统/ 开发者/ 或/ 管理者/ 考虑/ 相对/ 于/ 演化/ 机制/ 而言/ 更/ 高层次/ 的/ 问题/ ./ 本文/ 利用/ 运行/ 时/ 可变性/ 对象/ 来/ 进行/ 模型表示/ ,/ 即将/ 演化/ 的/ 对象/ ,/ 也/ 就是/ 可变性/ 要素/ 的/ 数量/ 、/ 属性/ 、/ 关系/ 表示/ 为/ 对象/ 实例/ 中/ 的/ 数据/ 参与/ 可变性/ 演化/ 的/ 运算/ ./ 具体地说/ ,/ 我们/ 使用/ 一组/ 基类/ 描述/ 可变性/ 模型/ 逻辑/ 上/ 信息/ (/ 如/ 可变性/ 要素/ 间/ 的/ 关系/ )/ ,/ 又/ 在/ 其子/ 类/ 对/ 父类/ 方法/ 和/ 属性/ 的/ 精化/ 中/ 又/ 描述/ 了/ 与/ 可变性/ 要素/ 的/ 具体/ 实现/ 相关/ 的/ 信息/ (/ 如/ 如何/ 实现/ 变体/ 绑定/ ,/ 如何/ 增加/ 、/ 替换/ 、/ 删除/ 此/ 类型/ 的/ 变体/ )/ ./ 3.3/ ./ 1/ 节对/ 可变性/ 对象/ 的/ 基类/ 及其/ 精化/ 过程/ 进行/ 了/ 详细/ 论述/ ./ 可变性/ 对象/ 与/ 运行/ 时/ 可变性/ 模型/ 及/ 可变性/ 要素/ 的/ 实现/ 关系/ 如图/ 5/ 所示/ ./ Page7/ 根据/ 3.1/ ./ 1/ 节/ 的/ 结论/ ,/ 需要/ 找到/ 一种/ 独立/ 于/ 可变性/ 要素/ 实现/ 形式/ 的/ 方法/ 直接/ 对/ 可变/ 点/ 和/ 变体/ (/ 例如/ 数据/ 集型/ 的/ 可变/ 点/ 和/ 变体/ )/ 进行/ 增加/ 、/ 替换/ 或/ 删除/ ./ 本文/ 采用/ 体系结构/ 的/ 动态/ 调整/ 这种/ 间接/ 的/ 方式/ ./ 它/ 不/ 考虑/ 可变性/ 要素/ 的/ 具体/ 实现/ ,/ 仅/ 在/ 选择/ 型/ 和/ 组织/ 型/ 两种/ 抽象/ 类型/ 上作/ 区分/ ./ 3.2/ 节/ 对此/ 有/ 详细/ 论述/ ./ 3.2/ 元变/ 机制/ 概述/ 3.2/ ./ 1/ 元变/ 机制/ 基础设施/ 元变/ 机制/ 基于/ 可变性/ 对象/ 在/ 体系结构/ 层/ 和/ 构件/ 层/ 支持/ 运行/ 时/ 可变性/ 的/ 演化/ ./ 如图/ 6/ ,/ 在/ 构件/ 实例/ 中图/ 6/ 元变/ 机制/ 的/ 基础设施/ 在/ 实际/ 的/ 软件/ 运行/ 中/ ,/ 每/ 一个/ 具有/ 运行/ 时/ 可变性/ 的/ 构件/ 实例/ 都/ 关联/ 一个/ 构件/ 级/ 可变性/ 对象/ 群/ ,/ 籍/ 以/ 管理/ 该/ 构件/ 内/ (/ 构件/ 层/ 或/ 代码/ 层/ 的/ )/ 可能/ 包含/ 的/ 大量/ 可变性/ 要素/ 对象/ ./ 同时/ 可变性/ 对象/ 群/ 也/ 有/ 汇总/ 可变性/ 要素/ 信息/ 的/ 功能/ ./ 在/ 可变性/ 演化/ 的/ 过程/ 中/ ,/ 它/ 负责/ 调用/ 可变性/ 要素/ 对象/ 的/ 方法/ 以/ 实现/ 对/ 可变性/ 要素/ 的/ 操作/ ./ 软件/ 运行/ 实例/ 在/ 体系结构/ 层次/ 也/ 包含/ 至少/ 一个/ 可变性/ 对象/ 群/ ./ 后者/ 负责管理/ 和/ 调整/ 软件系统/ 的/ 体系结构/ 配置/ ,/ 也/ 就是/ 构件之间/ 的/ 关系/ 形成/ 的/ 拓扑/ 结构/ ./ 每/ 一种/ 配置/ 都/ 被/ 视作/ 一个/ 组织/ 型/ 变体/ ,/ 而/ 可变性/ 对象/ 群则/ 具有/ 一个/ 相应/ 的/ 可变/ 点/ ./ 它会/ 根据/ 构件/ 层/ 可变性/ 要素/ 对象/ 的/ 请求/ 或/ 人类/ 的/ 指令/ 选择/ 其中/ 之一/ 进行/ 绑定/ (/ 即/ 加载/ 配置/ )/ ./ 如果/ 请求/ 的/ 配置/ 不/ 存在/ ,/ 它会/ 利用/ 2.3/ 节/ 介绍/ 的/ 方法/ 自行/ 生成/ 一个/ 新/ 的/ 变体/ 并/ 绑定/ ./ 体系结构/ 级/ 和/ 构件/ 级/ 的/ 可变性/ 对象/ 群/ 之间/ 存在/ 交互/ ./ 这种/ 交互/ 与/ 构件/ 间/ 的/ 交互/ 是/ 垂直/ 的/ ,/ 换言之/ ,/ 它们/ 利用/ 不同/ 的/ 通信/ 渠道/ ,/ 不/ 相互影响/ ./ 可变性/ 对象/ 群/ 之间/ 的/ 交互/ 大部分/ 是/ 通知/ 对方/ 体系结构/ 配置/ 发生变化/ ,/ 也/ 可能/ 是/ 构件/ 级/ 可变性/ 对象/ 群向/ 体系结构/ 级/ 运行/ 有/ 可变性/ 要素/ 对象/ ./ 每/ 一个/ 可变性/ 要素/ 对象/ (/ 某类/ 运行/ 时/ 可变性/ 对象/ 的/ 实例/ )/ 都/ 与/ 构件/ 中/ 某个/ 可变性/ 要素/ 的/ 实现/ (/ 包含/ 于/ 软件/ 制品/ )/ 关联/ ./ 它/ 收集/ 关于/ 该/ 可变性/ 要素/ 诸如/ 名称/ 、/ 实现/ 形式/ 等/ 信息/ ,/ 并/ 具有/ 增加/ 、/ 删除/ 、/ 替换/ 该/ 类型/ 要素/ 的/ 方法/ ./ 这些/ 方法/ 可以/ 调整/ 可变性/ 要素/ 之间/ 的/ 关系/ ,/ 但/ 无权/ 直接/ 调整/ 软件/ 的/ 体系结构/ 配置/ ./ 配制/ 调整/ 需要/ 构件/ 级/ 可变性/ 对象/ 群向/ 体系结构/ 级/ 可变性/ 对象/ 群/ 发出请求/ ,/ 要求/ 动态/ 调整/ 软件体系结构/ 以/ 间接/ 作用/ 于/ 实现/ 要素/ 的/ 软件/ 制品/ ,/ 进而/ 实现/ 运行/ 时/ 可变性/ 的/ 演化/ ./ 可变性/ 对象/ 群/ 发送/ 调整/ 体系结构/ 的/ 请求/ ./ 3.2/ ./ 2/ 元变/ 机制/ 执行/ 过程/ 3.2/ ./ 2.1/ 软件/ 可变性/ 模型/ 及元变/ 机制/ 执行/ 过程/ 符/ 上述/ 文段/ 中/ 提到/ 的/ 软件体系结构/ 动态/ 调整/ 包括/ 增加/ 新/ 构件/ 、/ 替换/ 或/ 删除/ 已/ 在/ 系统/ 中/ 的/ 构件/ ./ 为/ 简化/ 问题/ ,/ 本文/ 假设/ 构件之间/ 只/ 存在/ 调用/ // 被/ 调用/ 的/ 关系/ ./ 下文/ 以/ 符号/ 说明/ 简述/ 理论/ 上/ 的/ 软件/ 可变性/ 模型/ 及其/ 增加/ 、/ 删除/ 、/ 替换/ 可变性/ 要素/ 的/ 一般/ 过程/ ./ 定义/ 软件系统/ 的/ 可变性/ 模型/ M/ 为/ 元组/ 〈/ E/ ,/ R/ 〉/ ,/ 其中/ E/ =/ {/ ei/ |/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ }/ 为/ 可变性/ 要素/ 的/ 集合/ ,/ R/ =/ E/ ×/ E/ 为/ 要素/ 之间/ 关系/ 的/ 集合/ ./ E/ =/ P/ ∪/ V/ ,/ 其中/ P/ 为/ 可变/ 点/ 的/ 集合/ ,/ V/ 为/ 变体/ 的/ 集合/ ,/ P/ ∩/ V/ =/ / ./ P/ =/ {/ p0/ ,/ p1/ ,/ …/ ,/ pm/ }/ ,/ pi/ (/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ m/ )/ 定义/ 为/ 元组/ 〈/ sname/ ,/ sid/ ,/ trtype/ ,/ Vopt/ ,/ Vman/ ,/ Vbind/ ,/ Ereq/ ,/ Eex/ 〉/ ,/ 其中/ sname/ ,/ sid/ 和/ trtype/ 分别/ 是/ 指/ 可变/ 点/ 的/ 名称/ 、/ 标示/ 符/ 、/ 实现/ 类型/ ;/ Vopt/ ,/ Vman/ ,/ Vbind/ ,/ Ereq/ 和/ Eex/ 分别/ 是/ 可变/ 点/ 的/ 可选/ 关联/ 变体/ 、/ 强制/ 关联/ 变体/ 、/ 已/ 绑定/ 变体/ 、/ 依赖/ 的/ 可变性/ 要素/ 、/ 排斥/ 的/ 可变性/ 要素/ 的/ 集合/ ./ V/ =/ {/ v0/ ,/ v1/ ,/ …/ ,/ vn/ }/ ,/ vj/ (/ j/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ )/ 定义/ 为/ 元组/ 〈/ sname/ ,/ sid/ ,/ trtype/ ,/ Pass/ ,/ Pbind/ ,/ Ereq/ ,/ Eex/ 〉/ ,/ 其中/ sname/ ,/ sid/ ,/ Page8trtype/ 分别/ 是/ 指/ 变体/ 的/ 名称/ 、/ 标示/ 符/ 、/ 实现/ 类型/ ;/ PassPbind/ ,/ Ereq/ 和/ Eex/ 分别/ 是/ 变体/ 关联/ 的/ 可变/ 点/ 、/ 绑定/ 自身/ 的/ 可变/ 点/ 、/ 依赖/ 的/ 可变性/ 要素/ 、/ 排斥/ 的/ 可变性/ 要素/ 的/ 集合/ ./ 显然/ ,/ / r/ ∈/ R/ ,/ r/ =/ 〈/ es/ ,/ eo/ 〉/ ,/ 如果/ es/ ∈/ P/ ,/ 那么/ eo/ ∈/ es/ ./ {/ Vopt/ ∪/ Vman/ ∪/ Vbind/ ∪/ Ereq/ ∪/ Eex/ }/ ;/ 如果/ es/ ∈/ V/ ,/ 那么/ eo/ ∈/ es/ ./ {/ Pass/ ∪/ Pbind/ ∪/ Ereq/ ∪/ Eex/ }/ ./ 令/ C/ =/ {/ ci/ |/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ m/ }/ 为/ 组成/ 系统/ 的/ 构件/ 的/ 集合/ ,/ 有/ / e/ ∈/ E/ ,/ / c/ ∈/ C/ ,/ e/ / c/ ./ 其中/ e/ / c/ 指/ 构件/ c/ 实现/ 了/ 可变性/ 要素/ e/ ./ 定义/ 向/ M/ 增加/ 可变性/ 要素/ ea/ (/ ea/ / E/ )/ 的/ 一般/ 过程/ fa/ :/ {/ M/ }/ ×/ {/ ea/ }/ →/ {/ Ma/ }/ ,/ 其中/ Ma/ =/ 〈/ Ea/ ,/ Ra/ 〉/ ,/ Ea/ =/ E/ ∪/ {/ ea/ }/ ,/ Ra/ =/ Ea/ ×/ Ea/ ./ 假设/ ea/ / ca/ ,/ ca/ / C/ ,/ 取/ Ca/ ,/ / e/ ∈/ Ea/ ,/ e/ / c/ ,/ c/ ∈/ Ca/ ,/ 有/ Ca/ =/ C/ ∪/ {/ ca/ }/ (/ 增加/ 构件/ ca/ )/ 或/ Ca/ =/ (/ C/ -/ {/ cs/ |/ cs/ ∈/ C/ }/ )/ ∪/ {/ ca/ }/ (/ 替换/ 构件/ cs/ 为/ ca/ ,/ 此时/ 有/ / e/ ∈/ {/ e/ |/ e/ / cs/ }/ ,/ e/ / ca/ )/ ./ 定义/ 从/ M/ 中/ 去除/ 可变性/ 要素/ er/ (/ er/ ∈/ E/ )/ 的/ 一般/ 过程/ fr/ :/ {/ M/ }/ ×/ {/ er/ }/ →/ {/ Mr/ }/ ,/ Mr/ =/ 〈/ Er/ ,/ Rr/ 〉/ ,/ Er/ =/ E/ -/ {/ er/ }/ ,/ Rr/ =/ Er/ ×/ Er/ ./ 假设/ er/ / cr/ ,/ cr/ ∈/ C/ ,/ 取/ Cr/ ,/ / e/ ∈/ Er/ ,/ e/ / c/ ,/ c/ ∈/ Ca/ ,/ 有/ Cr/ =/ C/ -/ {/ cr/ }/ (/ 删除/ 构件/ ca/ )/ 或/ Cr/ =/ (/ C/ -/ {/ cr/ }/ )/ ∪/ {/ cs/ }/ (/ 替换/ 构件/ cr/ 为/ cs/ ,/ 此时/ 有/ / e/ ∈/ {/ e/ |/ e/ / cs/ }/ ,/ e/ / cr/ 但是/ er/ / cs/ 不/ 成立/ )/ ./ 替换/ M/ 中/ 可变性/ 要素/ es/ 为/ es/ (/ es/ ∈/ E/ ,/ es/ / E/ )/ 的/ 过程/ fs/ :/ {/ M/ }/ ×/ {/ es/ }/ ×/ {/ es/ }/ →/ {/ Ms/ }/ 可/ 被/ 视为/ 前/ 两种/ 过程/ 的/ 组合/ ,/ 即/ fs/ (/ M/ ,/ es/ ,/ es/ )/ =/ fr/ (/ fa/ (/ M/ ,/ es/ )/ ,/ es/ )/ ,/ 或/ fs/ (/ M/ ,/ es/ ,/ es/ )/ =/ fa/ (/ fr/ (/ M/ ,/ es/ )/ ,/ es/ )/ ./ 3.2/ ./ 2.2/ 元变/ 机制/ 执行/ 过程/ 物理/ 实现/ 概述/ 物理/ 实现/ 层面/ 上/ 的/ 元变/ 机制/ 执行/ 过程/ (/ 即/ 演化过程/ )/ 会因/ 可变性/ 要素/ 的/ 实现/ 类型/ 而/ 稍/ 异于/ 一般/ 过程/ ./ 下文/ 按/ 可变性/ 要素/ 的/ 实现/ 形式/ 、/ 操作/ 类型/ (/ 包括/ 增加/ 、/ 替换/ 、/ 删除/ )/ 简述/ 动态/ 调整/ 软件体系结构/ 如何/ 达到/ 演化/ 的/ 目的/ ./ (/ 1/ )/ 增加/ 选择/ 型/ 变体/ 在/ 运行/ 的/ 软件/ 实例/ 内/ 增加/ 构件/ 型/ 或/ 功能型/ 变体/ 通常/ 包含/ 两个/ 步骤/ :/ 向/ 软件体系结构/ 增加/ 实现/ 该/ 变体/ 的/ 软件/ 制品/ ,/ 建立/ 该/ 变体/ 与/ 其他/ 要素/ 之间/ 的/ 关系/ 以使/ 它/ 有效/ (/ Active/ )/ ./ 对于/ 构件/ 型/ 变体/ 而言/ ,/ 实现/ 它/ 的/ 软件/ 制品/ 就是/ 构件/ 本身/ ,/ 因此/ 直接/ 向/ 软件系统/ 增加/ 该/ 构件/ 实例/ (/ 连同/ 其中/ 的/ 可变性/ 要素/ 对象/ ,/ 具体/ 实现/ 见/ 3.3/ ./ 2/ 节/ )/ 即可/ 完成/ 第一个/ 步骤/ ./ 对于/ 功能型/ 变体/ 而言/ ,/ 软件/ 制品/ 的/ 增加/ 可以/ 通过/ 增加/ 包含/ 其/ 的/ 构件/ 来/ 完成/ ,/ 也/ 可以/ 通过/ 替换/ 原/ 系统/ 中/ 相关/ 构件/ 为/ 实现/ 该/ 变体/ 的/ 构件/ 来/ 达到/ 目的/ ,/ 如图/ 7/ 所示/ ./ 图/ 7/ 通过/ 将/ 构件/ D/ 替换/ 为/ D/ 以/ 增加/ 变体/ v2/ 第/ 2/ 个/ 步骤/ 中/ 变体/ 有效/ 是/ 指/ 直接/ 实现/ 变体/ 的/ 相关/ 代码/ 实例/ 在/ 软件/ 的/ 运行/ 期内/ 有/ 机会/ 得到/ 执行/ ./ 建立/ 它/ 与/ 其他/ 可变性/ 要素/ 之间/ 的/ 关系/ ,/ 尤其/ 是/ 它/ 与/ 相关/ 可变/ 点/ 之间/ 的/ 可变性/ 依赖/ ,/ 可以/ 使/ 可变/ 点/ 知悉/ 它/ 的/ 存在/ 并/ 能够/ 选择/ 和/ 绑定/ 它/ ./ (/ 2/ )/ 替换/ 或/ 删除/ 选择/ 型/ 变体/ 替换/ 构件/ 型/ 或/ 功能型/ 的/ 变体/ 的/ 步骤/ 有/ 三/ :/ 向/ 软件体系结构/ 增加/ 实现/ 新/ 变体/ 的/ 软件/ 制品/ ,/ 取消/ 原有/ 变体/ 与/ 其他/ 要素/ 之间/ 的/ 关系/ 以使/ 其/ 无效/ (/ Inactive/ )/ ,/ 建立/ 新/ 变体/ 与/ 其他/ 要素/ 之间/ 的/ 关系/ 以使/ 其/ 有效/ ./ 由于/ 原有/ 变体/ 可能/ 正在/ 被/ 调用/ ,/ 不/ 建议/ 去除/ 实现/ 原有/ 变体/ 的/ 软件/ 制品/ ./ 删除/ 该/ 类型/ 的/ 变体/ 也/ 遵循/ 类似/ 的/ 原理/ ,/ 即/ 取消/ 原有/ 变体/ 与/ 其他/ 要素/ 之间/ 的/ 关系/ 以/ 使/ 其他/ 要素/ (/ 尤其/ 是/ 其/ 关联/ 的/ 可变/ 点/ )/ 无法/ 感知/ 它/ ,/ 这样/ 该/ 变体/ 就/ 相当于/ 被/ 删除/ 了/ ./ (/ 3/ )/ 增加/ 、/ 替换/ 、/ 删除/ 组织/ 型/ 变体/ 配置/ 型/ 和/ 工作/ 流型/ 的/ 变体/ 通常/ 是/ 纯粹/ 的/ 数据/ ./ 针对/ 此类/ 变体/ 的/ 操作/ 一般/ 需要/ 增加/ 、/ 替换/ 或/ 删除/ 可变性/ 要素/ 对象/ 连同/ 相关/ 数据/ ,/ 并/ 改变/ 可变性/ 要素/ 之间/ 关系/ (/ 这个/ 方面/ 与/ 选择/ 型/ 变体/ 操作/ 是/ 类似/ 的/ ,/ 不再/ 赘述/ )/ ./ 为了/ 使/ 新/ 变体/ 有效/ ,/ 其/ 增加/ 或/ 替换/ 可能/ 涉及/ 对/ 软件体系结构/ 的/ 调整/ ./ 数据/ 集型/ 变体/ 本质/ 上/ 是/ 编程语言/ 上下文/ 中/ 的/ 类型/ (/ Type/ )/ ,/ 与/ 之/ 相关/ 的/ 运行/ 时/ 可变性/ 在/ 动态/ 类型/ 语言/ [/ 34/ ]/ (/ 如/ Python/ )/ 领域/ 有/ 深入/ 的/ 研究/ ./ 在/ 一般/ 意义/ 上/ ,/ 增加/ 、/ 替换/ 或/ 删除/ 此类/ 变体/ 可能/ 需要/ 通过/ 替换/ 相关/ 的/ 构件/ 来/ 实现/ ./ 在/ 这个/ 过程/ 中/ ,/ 可变性/ 要素/ 之间/ 关系/ 也/ 需要/ 作/ 类似/ 于/ 选择/ 型/ 变体/ 操作/ 的/ 调整/ ./ (/ 4/ )/ 增加/ 、/ 替换/ 、/ 删除/ 选择/ 型/ 或/ 组织/ 型/ 的/ 可变/ 点为/ 实现/ 可变/ 点/ 的/ 增加/ ,/ 可/ 将/ 在/ 其中/ 没有/ 该/ 可变/ 点/ 表示/ 的/ 相关/ 构件/ 替换/ 为/ 新/ 的/ 具有/ 该/ 可变/ 点/ 表示/ 的/ 构件/ ./ 如果/ 该/ 可变/ 点/ 可/ 绑定/ 的/ 变体/ 数目/ 下限/ 不是/ 0/ (/ 即/ 不是/ 可/ 选/ (/ Optional/ )/ 可变/ 点/ )/ ,/ 还/ 需要/ 增加/ 一个/ 默认/ 的/ 与/ 之/ 关联/ 和/ 绑定/ 的/ 变体/ ,/ 以/ 使/ 软件/ 实例/ 能够/ Page9/ 在/ 该/ 可变/ 点/ 运行/ 实现/ 该/ 变体/ 的/ 代码/ ,/ 进而/ 使该/ 可变/ 点/ 是/ 有效/ 的/ ./ 替换/ 构件/ 也/ 是/ 实现/ 替换/ 可变/ 点/ 的/ 一种/ 可行/ 的/ 方式/ ./ 与/ 增加/ 可变/ 点/ 不同/ 的/ 是/ ,/ 这个/ 替换/ 过程/ 可能/ 涉及/ 新旧/ 可变/ 点/ 之间/ 的/ 状态/ 迁移/ (/ StateTransformation/ )/ ,/ 即旧/ 可变/ 点/ 的/ 状态/ (/ 如其/ 当前/ 绑定/ 的/ 是/ 哪/ 一个/ 变体/ )/ 经过/ 转换/ 后/ 成为/ 等价/ 的/ 新/ 可变/ 点/ 的/ 状态/ ./ 删除/ 可变/ 点/ 可以/ 采用/ 较为/ 轻量级/ 的/ 方式/ ./ 事实上/ ,/ 如果/ 按照/ 上述/ 方法/ 将/ 待/ 删除/ 的/ 可变/ 点/ 当前/ 关联/ 但/ 未/ 绑定/ 的/ 变体/ 删除/ ,/ 可变/ 点/ 就/ 只能/ 选择/ 当前/ 绑定/ 的/ 变体/ ./ 如果/ 再/ 取消/ 该/ 可变/ 点/ 与/ 其他/ 可变性/ 要素/ 之间/ 关系/ ,/ 该/ 可变/ 点/ 就/ 相当于/ 被/ 删除/ 了/ ./ 3.3/ 关键技术/ 本文/ 涉及/ 基于/ ./ NetFramework/ 对/ 上述/ 元变/ 机制/ 的/ 实现/ ./ 本节/ 主要/ 阐述/ 其/ 关键技术/ ,/ 包括/ 运行/ 时/ 可变性/ 对象/ 、/ 软件体系结构/ 动态/ 调整/ 以及/ 用于/ 辅助/ 建立/ 元变/ 机制/ 基础设施/ 的/ 代码生成/ 技术/ ./ 3.3/ ./ 1/ 运行/ 时/ 可变性/ 对象/ 运行/ 时/ 可变性/ 对象/ 包括/ 3.2/ 节/ 提到/ 的/ 可变性/ 要素/ 对象/ 和/ 可变性/ 对象/ 群/ ./ 可变性/ 要素/ 对象/ 对应/ 的/ 基类/ 是/ 根据/ 3.2/ ./ 2.1/ 节/ 的/ 可变性/ 模型/ 设计/ 的/ ,/ 其/ 包括/ 可变/ 点/ 对象/ 类/ (/ RTVariationPoint/ )/ 、/ 变体/ 对象/ 类/ (/ RTVariant/ )/ 和/ 可变性/ 对象/ 群/ (/ RTVarObject/ -/ Group/ )/ ,/ 如图/ 8/ 所示/ ./ 可变/ 点/ 对象/ 类/ 和/ 变体/ 对象/ 类/ 统称/ 为/ 可变性/ 对象/ (/ RTVarObject/ )/ 类/ ,/ 用于/ 表示/ 和/ 操纵/ 软件/ 中/ 可变性/ 要素/ 及其/ 它们/ 之间/ 的/ 关系/ ./ 可以/ 观察/ 到/ 它/ 具有/ 可变/ 点/ 和/ 变体/ 的/ 共同/ 属性/ (/ 见/ 3.2/ ./ 2.1/ 节/ )/ ,/ 如/ 名称/ (/ Name/ )/ 、/ 实现/ 类型/ (/ VarType/ )/ 、/ 依赖/ 的/ 可变性/ 要素/ 的/ 集合/ (/ RequiredElementList/ ,/ 列表/ 类型/ ,/ 元素/ 类型图/ 9/ 运行/ 时/ 可变性/ 模型/ 在/ 软件/ 运行/ 实例/ 中/ 的/ 描述/ 为/ 对/ RTVarObject/ 的/ 引用/ )/ 、/ 排斥/ 的/ 可变性/ 要素/ 的/ 集合/ (/ ExcludedElementList/ )/ ./ 如图/ 9/ 所示/ ,/ 变体/ 绑定/ (/ BindVairant/ )/ 等/ 活动/ 都/ 由/ 此类/ (/ 或/ 子类/ )/ 的/ 方法/ 描述/ ./ 可变性/ 要素/ 对象/ 类/ 还/ 具有/ 一组/ 抽象/ 方法/ OnAdd/ 、/ OnRemove/ 和/ OnReplace/ ,/ 分别/ 用以/ 描述/ 如何/ 处理/ 可变性/ 要素/ 的/ 增加/ (/ Add/ )/ 、/ 删除/ (/ Remove/ )/ 和/ 替换/ (/ Replace/ )/ 对系统/ 可能/ 造成/ 的/ 影响/ (/ 这种/ 影响/ 通常/ 与/ 相关/ 可变性/ 要素/ 的/ 实现/ 形式/ 相关/ )/ ./ 这些/ 方法/ 会/ 在/ 系统/ 利用/ 软件体系结构/ 动态/ 调整/ 完成/ 演化/ 主要/ 过程/ 之后/ 被/ 调用/ ,/ 完成/ 某些/ 后续/ 工作/ (/ 例如/ 改变/ 自身/ 的/ 关系/ 属性/ (/ 如/ RequiredElementList/ )/ 以/ 正确/ 反映/ 当前/ 元素/ 之间/ 的/ 关系/ 等/ )/ 以/ 维护/ 系统/ 的/ 一致性/ ./ Page10RTVariationPoint/ 和/ RTVariant/ 分别/ 针对/ 3.2/ ./ 2.1/ 节/ 模型/ 中/ 可变/ 点/ 和/ 变体/ 的/ 特点/ 具有/ 各自/ 的/ 属性/ 和/ 方法/ ,/ 如/ 可变/ 点/ 的/ OptionalVariantList/ ,/ 即可/ 选/ 变体/ 的/ 集合/ (/ 列表/ 类型/ ,/ 元素/ 类型/ 为/ 对/ RTVariant/ 的/ 引用/ )/ ;/ MandatoryVariantList/ ,/ 即/ 强制/ 变体/ 的/ 集合/ ;/ BoundVariantList/ ,/ 即/ 已/ 绑定/ 变体/ 的/ 集合/ ;/ 再/ 如/ 变体/ 的/ RealisedEntity/ 是/ 对/ 实现/ 变体/ 的/ 软件/ 制品/ 的/ 引用/ ,/ 该/ 属性/ 可以/ 用于/ 对/ 变体/ 的/ 追踪/ ;/ Associated/ -/ VPList/ 记录/ 关联/ 该/ 变体/ 的/ 可变/ 点/ 的/ 集合/ ;/ Bound/ -/ VPList/ 记录/ 绑定/ 该/ 变体/ 的/ 可变/ 点/ 的/ 集合/ ./ 为了/ 利用/ 可变性/ 对象/ 类/ 实现/ 对/ 具体/ 系统/ 中/ 可变性/ 要素/ 的/ 表示/ ,/ 开发人员/ 需要/ 在/ 代码/ 中/ 添加/ 对/ 上述/ 基类/ RTVariationPoint/ 和/ RTVariant/ 的/ 继承/ 以/ 具体/ 描述/ 不同/ 种类/ 的/ 可变/ 点/ 和/ 变体/ ./ 在/ 此/ 过程/ 中/ ,/ 开发人员/ 需要/ 指出/ 可变性/ 要素/ 的/ 名称/ 、/ 标示/ 符/ 、/ 实现/ 形式/ 等/ 属性/ 值/ ,/ 也/ 需要/ 实现/ 基类/ 的/ 抽象/ 方法/ ,/ 尤其/ 是/ OnAdd/ ,/ OnRemove/ 和/ OnReplace/ 方法/ ./ 多态/ 会/ 保证系统/ 开发者/ 或/ 维护者/ 在/ 触发/ 运行/ 时/ 可变性/ 动态/ 演化/ 的/ 过程/ 后/ 无须/ 关心/ 元变/ 机制/ 如何/ 处理/ 与/ 异构/ 的/ 可变性/ 要素/ 相关/ 的/ 问题/ ./ 需要/ 注意/ 的/ 是/ ,/ 相互/ 关联/ 的/ 可变/ 点/ 与/ 变体/ 的/ 实现/ 形式/ 必须/ 是/ 匹配/ 的/ ,/ 例如/ 假设/ 某/ 可变/ 点/ 实现/ 为/ 一个/ 参数/ ,/ 那么/ 其/ 关联/ 的/ 变体/ 必须/ 是/ 具有/ 参数/ 类型/ 的/ 值/ ./ 一般/ 的/ ,/ 实现/ 构件/ 层/ 和/ 代码/ 层/ 可变性/ 要素/ 的/ 软件/ 制品/ 、/ 其/ 对应/ 的/ 可变性/ 要素/ 对象/ 子类/ 被/ 封装/ 在/ 同一个/ 程序/ 集/ (/ Assembly/ )/ [/ 35/ ]/ 中/ ./ 在/ 运行/ 时/ ,/ 可变性/ 要素/ 对象/ 的/ 属性/ (/ 如/ RealisedEntity/ )/ 中/ 存储/ 软件/ 制品/ 的/ 句柄/ (/ Object/ 类型/ 对象/ )/ ./ 对象/ 通过/ 它/ 可以/ 直接/ 访问/ 实现/ 要素/ 的/ 软件/ 制品/ 的/ 信息/ ./ 除了/ 变体/ 绑定/ 外/ ,/ 可变性/ 要素/ 对象/ 不/ 直接参与/ 软件/ 制品/ 的/ 功能/ 执行/ 、/ 交互/ 和/ 其他软件/ 实体/ 的/ 运行/ ./ 理想/ 情况/ 下/ ,/ 如果/ 在/ 程序/ 集中/ 除去/ 有关/ 可变性/ 要素/ 对象/ 的/ 代码/ ,/ 其余/ 的/ 功能性/ 代码/ 应当/ 能够/ 正常/ 运行/ ./ 一般/ 的/ ,/ 可变性/ 对象/ 群/ 用于/ 集中管理/ 和/ 控制/ 一组/ 可变性/ 要素/ 对象/ ,/ 其中/ 包含/ 后者/ 信息/ 的/ 列表/ (/ VariationPointList/ 和/ VariantList/ )/ 等/ 组成部分/ ,/ 如图/ 8/ 所示/ ./ 它/ 扮演/ 运行/ 时/ 可变性/ 动态/ 演化过程/ 中/ 执行者/ 的/ 角色/ ./ 其中/ 交互/ 代理/ (/ Proxy/ )/ 负责/ 可变性/ 对象/ 群/ 之间/ 的/ 交互/ (/ 如/ 通知/ 对方/ 软件系统/ 体系结构/ 发生变化/ )/ ./ 具体/ 地/ ,/ 它/ 使用/ Web/ 服务/ 与/ 处于/ 其他/ 主机/ 上/ 的/ 可变性/ 对象/ 群/ 进行/ 远程/ 通信/ ,/ 使用/ 命名/ 管道/ (/ NamedPipe/ )/ [/ 35/ ]/ 与/ 本地/ 的/ 可变性/ 对象/ 通信/ ./ 可变性/ 对象/ 管理器/ 有/ 3/ 种/ 功能/ :/ (/ 1/ )/ 汇总/ 其/ 管理/ 的/ 可变性/ 要素/ 对象/ 的/ 信息/ (/ 主要/ 是/ 地址/ 信息/ )/ ,/ 并/ 将/ 其/ 存入/ 可变/ 点/ 信息/ 列表/ 或/ 变体/ 信息/ 列表/ ;/ (/ 2/ )/ 管理/ 可变性/ 要素/ 对象/ 的/ 生命周期/ ,/ 可以/ 按/ 需要/ 启动/ 或/ 卸载/ 对象/ 实例/ ;/ (/ 3/ )/ 根据/ 人类/ 的/ 指令/ 执行/ 增加/ 、/ 替换/ 和/ 删除/ 可变性/ 对象/ 的/ 操作/ (/ 其/ 过程/ 中/ 利用/ 多态/ 调用/ 了/ 可变性/ 要素/ 对象/ 子类/ 重载/ 的/ OnAdd/ ,/ OnRemove/ 和/ OnReplace/ 的/ 方法/ )/ ./ 状态/ 迁移/ 器/ 在/ 替换/ 操作/ 中/ 被/ 用来/ 实现/ 旧/ 可变性/ 对象/ 状态/ 向/ 新/ 可变性/ 对象/ 状态/ 的/ 转化/ (/ 具体/ 过程/ 见/ 3.3/ ./ 2/ 节/ )/ ./ 它会/ 提取/ 旧/ 可变性/ 要素/ 对象/ 的/ 属性/ 信息/ ,/ 按照/ 由/ 程序员/ 提供/ 的/ 状态/ 迁移/ 脚本/ ,/ 将/ 数据/ 转化/ 为/ 新/ 可变性/ 要素/ 对象/ 的/ 属性/ 值/ ./ 图/ 10/ 中/ 展示/ 了/ 状态/ 迁移/ 器向/ 新增/ 的/ 可变性/ 要素/ 对象/ 进行/ 数据/ 输入/ ./ 构件/ 级/ 可变性/ 对象/ 群类/ 可以/ 位于/ 独立/ 的/ 程序/ 集中/ ,/ 也/ 可以/ 与其/ 管理/ 的/ 可变性/ 要素/ 位于/ 同一个/ 程序/ 集中/ ./ 在/ 执行/ 可变性/ 演化/ 时/ ,/ 它/ 可以/ 通过/ 交互/ 代理/ 向/ 体系结构/ 级/ 可变性/ 对象/ 群/ 发出/ 调整/ 软件体系结构/ 的/ 请求/ ./ 体系结构/ 级/ 可变性/ 对象/ 群/ 以及/ 其/ 管理/ 的/ 可变性/ 要素/ 对象/ 被/ 封装/ 在/ 一个/ 独立/ 的/ 程序/ 集中/ ./ 体系结构/ 级/ 可变性/ 对象/ 群/ 通常/ 不/ 包含/ 状态/ 迁移/ 器/ ,/ 因为/ 很少/ 出现/ 替换/ 配置/ 变体/ 的/ 情况/ ,/ 而且/ 配置/ 本身/ 一般/ 不/ 具有/ 状态/ ./ 3.3/ ./ 2/ 软件体系结构/ 动态/ 调整/ 理论/ 上/ ,/ 元变/ 机制/ 并/ 不/ 依赖于/ 某种/ 特定/ 的/ 构件/ 模型/ 和/ 体系结构/ 动态/ 调整/ 技术/ ,/ 其/ 只/ 要求/ 后者/ 能够/ 实现/ 构件/ 的/ 增加/ 、/ 替换/ 和/ 删除/ ,/ 并/ 允许/ 在/ 此/ 过程/ 中/ 对/ 可变性/ 模型/ 按/ 演化/ 目标/ 进行/ 相应/ 的/ 改变/ ①/ ./ 除此/ 之/ ①/ 从/ 一般性/ 角度/ 考虑/ ,/ 除了/ 运行/ 时/ 可变性/ 动态/ 演化/ 之外/ ,/ 设计/ Page11/ 外/ ,/ 伴随/ 着/ 体系结构/ 调整/ 的/ 往往/ 还有/ 状态/ 迁移/ [/ 36/ ]/ (/ 包括/ 可变性/ 状态/ 的/ 迁移/ )/ ,/ 以/ 维持/ 系统/ 的/ 运行/ ./ 在/ 实现/ 上/ ,/ 由于/ 本文/ 采用/ ./ NetFramework/ 构建/ 元变/ 机制/ 的/ 基础设施/ (/ 见/ 3.3/ ./ 3/ 节/ )/ ,/ 所以/ 除/ 上述/ 要求/ 外/ ,/ 还/ 需要/ 构件/ 的/ 运行/ 实例/ 能够/ 与/ ./ NetFramework/ 互操作/ ./ 下文/ 以/ 变体/ 的/ 增加/ 为例/ 阐述/ 元变/ 机制/ 中/ 构件/ 增加/ 和/ 替换/ 的/ 一般/ 过程/ ./ 过程/ 1/ ./ 元变/ 机制/ 中以/ 增加/ 变体/ V/ 为/ 目的/ 增加/ 构件/ C/ 的/ 过程/ ./ 1/ ./ 加载/ C/ 至/ 软件/ 进程/ 空间/ ,/ 初始化/ 构件/ 实例/ ;/ 2/ ./ 查找/ 并/ 获取/ 目标/ 可变性/ 对象/ 群/ G/ ,/ 该/ 可变性/ 对象/ 群/ 管理/ 需要/ 增加/ 变体/ 的/ 目标/ 可变/ 点/ P/ ;/ 3/ ./ 生成/ 并/ 初始化/ 构件/ 实例/ 中/ 包含/ 的/ 所有/ 可变性/ 要素/ (/ 包括/ 待/ 增加/ 的/ 变体/ V/ )/ 对应/ 的/ 可变性/ 要素/ 对象/ ,/ 并/ 将/ 其/ 向/ G/ 注册/ ,/ 使/ 其/ 置于/ 后者/ 管理/ 之下/ ;/ 4/ ./ 通过/ 修改/ P/ 和/ V/ 的/ 属性/ 关联/ P/ 和/ V/ ;/ 5/ ./ 生成/ 包含/ 新/ 构件/ C/ 的/ 体系结构/ 配置/ (/ 变体/ )/ ,/ 并/ 向/ 体系结构/ 级/ 可变性/ 对象/ 群/ 注册/ ,/ 这个/ 步骤/ 实际上/ 实现/ 了/ 在/ 体系结构/ 层面/ 增加/ 和/ 绑定/ 组织/ 型/ 变体/ 的/ 过程/ ./ 过程/ 2/ ./ 元变/ 机制/ 中以/ 增加/ 变体/ V/ 为/ 目的/ 替换/ 构件/ C/ 为/ C/ 的/ 过程/ ./ 1/ ./ 加载/ 构件/ C/ 至/ 软件/ 进程/ 空间/ ,/ 初始化/ 构件/ 实例/ ;/ 2/ ./ 查找/ 并/ 获取/ 目标/ 可变性/ 对象/ 群/ G/ ,/ 该/ 可变性/ 对象/ 群/ 管理/ 需要/ 增加/ 变体/ 的/ 目标/ 可变/ 点/ P/ ;/ 3/ ./ 初始化/ C/ 实例/ 中/ 包含/ 的/ 所有/ 可变性/ 要素/ (/ 包括/ 待/ 增加/ 的/ 变体/ V/ )/ 对应/ 的/ 可变性/ 要素/ 对象/ ,/ 并/ 将/ 其/ 向/ G/ 注册/ ,/ 使/ 其/ 置于/ 后者/ 管理/ 之下/ ;/ 4/ ./ 通过/ 修改/ 的/ P/ 和/ V/ 属性/ 关联/ P/ 和/ V/ ;/ 5/ ./ (/ 可/ 选/ 过程/ )/ 提取/ C/ 的/ 运行/ 状态/ (/ 包括/ 每个/ 可变/ 点/ 的/ 状态/ )/ ,/ 并/ 转化/ 为/ C/ 的/ 运行/ 状态/ ;/ 其中/ C/ 的/ 资源/ 如/ 内存/ 、/ 硬件/ 句柄/ 等/ 都/ 由/ C/ 接管/ (/ 这个/ 步骤/ 需要/ 人/ 参与/ 以/ 保证/ 语义/ 一致性/ ,/ 参见/ 作者/ 前期工作/ [/ 37/ ]/ )/ ;/ 6/ ./ 查找/ 并/ 获取/ 可变性/ 对象/ 群/ G/ ,/ 该/ 可变性/ 对象/ 群/ 管理/ C/ 中/ 所有/ 可变性/ 要素/ 对应/ 的/ 可变性/ 对象/ ;/ 反/ 注册/ 后者/ 并/ 终止/ 其/ 运行/ ;/ 7/ ./ 释放/ C/ 实例/ ,/ 终止/ 其/ 运行/ ;/ 8/ ./ 生成/ 包含/ 新/ 构件/ C/ 的/ 体系结构/ 配置/ (/ 变体/ )/ ,/ 向/ 体系结构/ 级/ 可变性/ 对象/ 群/ 注册/ 并/ 绑定/ 之/ ./ 在/ 过程/ 2/ 中/ ,/ 除了/ 待/ 增加/ 的/ 变体/ 及其/ 实现/ ,/ C/ 的/ 其他/ 部分/ 应当/ 与/ C/ 一致/ ,/ 以/ 最大/ 程度/ 的/ 减小/ 可能/ 的/ 维护/ 成本/ ,/ 尤其/ 是/ C/ 中/ 实现/ 的/ 可变性/ 元素/ 也/ 需要/ 在/ C/ 中/ 实现/ ,/ C/ 中/ 可变性/ 要素/ 本身/ 的/ 状态/ 也/ 需要/ 通过/ 状态/ 迁移/ 与/ C/ 中/ 的/ 状态/ 保持一致/ ./ 可变性/ 要素/ 状态/ 迁移/ 的/ 基本/ 步骤/ 为/ :/ 过程/ 3/ ./ 可变性/ 要素/ e/ 从/ 构件/ C/ 到/ C/ 的/ 状态/ 迁移/ ./ 1/ ./ 利用/ ./ NetFramework/ 提供/ 的/ API/ 将/ 构件/ C/ 上下文/ 中/ 的/ e/ 对应/ 的/ 可变性/ 要素/ 对象/ 序列化/ 为/ 二进制码/ ;/ 2/ ./ 在/ C/ 的/ 上下文/ 中反/ 序列化/ 二进制码/ ,/ 生成/ 可变性/ 要素/ 对象/ ,/ 并/ 将/ 该/ 对象/ 与/ e/ 在/ C/ 中/ 的/ 实现/ 关联/ ;/ 3/ ./ 调用/ C/ 的/ 上下文/ 中/ 的/ 可变性/ 要素/ 对象/ 的/ 方法/ OnReplace/ ,/ 该/ 方法/ 会/ 提取/ e/ 在/ C/ 中/ 的/ 实现/ 的/ 状态/ ,/ 并/ 执行/ 程序员/ 修改/ 的/ Python/ 脚本/ 以/ 转化/ 其为/ e/ 在/ C/ 中/ 的/ 实现/ 的/ 状态/ ./ 步/ 2/ 中/ ,/ 程序员/ 在/ 编写/ 脚本/ 时/ 需要/ 决定/ 哪些/ 状态/ 需要/ 转化/ ,/ 需要/ 怎样/ 转化/ ./ 相关/ 的/ 可变性/ 对象/ 群会/ 自动/ 生成/ 状态/ 迁移/ Python/ 脚本/ ,/ 并/ 将/ 新旧/ 可变性/ 要素/ 的/ 状态变量/ 按/ 名称/ 类似/ 程度/ 和/ 数据类型/ 对应/ 在/ 一起/ 表述/ ,/ 以/ 减少/ 程序员/ 的/ 工作量/ ./ 程序员/ 需要/ 指明/ 脚本/ 描述/ 的/ 哪些/ 转化/ 是/ 不必要/ 的/ ,/ 或者/ 哪些/ 转化/ 需要/ 类型转换/ 等等/ 细节/ ,/ 程序员/ 需要/ 负责/ 新旧/ 状态/ 的/ 语义/ 一致性/ ,/ 通过/ 对/ 脚本/ 的/ 修改/ 指出/ 必要/ 的/ 转化/ 步骤/ ./ 详见/ 本文/ 之前/ 的/ 工作/ [/ 37/ ]/ ./ 以/ 可变/ 点/ 增加/ 或/ 替换/ 为/ 目的/ 而/ 进行/ 的/ 构件/ 替换/ 与/ 上述/ 过程/ 2/ 类似/ ,/ 不同/ 的/ 是/ 步/ 4/ 需要/ 改为/ 保证/ 新增/ 可变/ 点/ 有效/ (/ 即/ 具有/ 一定/ 数量/ 的/ 关联/ 的/ 变体/ )/ 的/ 步骤/ ./ 可变性/ 要素/ 的/ 删除/ 通常/ 不/ 涉及/ 体系结构/ 的/ 动态/ 调整/ ;/ 同时/ ,/ 元变/ 机制/ 中/ 需要/ 对/ 构件/ 进行/ 删除/ 操作/ 的/ 情况/ 比较/ 罕见/ ,/ 所以/ 不再/ 赘述/ ./ 3.3/ ./ 3/ 元变/ 机制/ 基础设施/ 生成元/ 变/ 机制/ 的/ 基础设施/ 主要/ 包括/ 处于/ 体系结构/ 层/ 和/ 构建/ 层/ 的/ 可变性/ 对象/ 群/ 及其/ 管理/ 的/ 可变性/ 要素/ 对象/ 、/ 与/ 这些/ 可变性/ 对象/ 群/ 进行/ 交互/ 的/ 人机界面/ 等/ ./ 基于/ ./ NetFramework/ 技术/ 框架/ ,/ 我们/ 提供/ 了/ 一系列/ 可/ 复用/ 的/ 类库/ 和/ 工具/ 支持/ 可变性/ 要素/ 对象/ 和/ 可变性/ 对象/ 群/ 的/ 构建/ 过程/ ./ 如图/ 11/ 所示/ ,/ 系统/ 设计者/ 在/ 编译/ 阶段/ 除了/ 需要/ 提供/ 构件/ 的/ 源代码/ 之外/ ,/ 还/ 需要/ 利用/ 可变性/ 要素/ 对象/ 信息/ 编辑器/ 编辑/ 一个/ 描述/ 构件/ 中/ 所/ 实现/ 可变性/ 要素/ 对象/ 的/ 基本/ 属性/ 信息/ (/ 如/ 名称/ 、/ 实现/ 形式/ 等/ )/ ./ 可变性/ 要素/ 生成器/ 会/ 自动/ 将/ 用户/ 编辑/ 的/ 信息/ 中/ 的/ 每一项/ 都/ 转化/ 为/ 继承/ 可变性/ 要素/ 对象/ 类/ 的/ 子类/ 的/ 属性/ 值/ ,/ 而类/ 的/ 方法/ (/ 描述/ 变体/ 绑定/ 、/ 增加/ // 删除/ // 替换/ 可变性/ 要素/ )/ 是/ 在/ 原型/ 方法/ 的/ 基础/ 上/ 生成/ 的/ ./ 原型/ 方法/ 的/ 代码/ 需要/ 根据/ 要素/ 的/ 实现/ 形式/ 从元变/ 机制/ 代码/ 库中/ 查询/ 并/ 提取/ 出来/ ,/ 如果/ 查询/ 无果/ ,/ 生成器/ 会/ 要求/ 设计者/ 在/ 类/ 的/ 方法/ 或/ 代码/ 库中/ 添加/ 相应/ 代码/ ./ 构件/ 级/ 可变性/ 对象/ 群/ 的/ 源代码/ 是/ 在/ 代码/ 库中/ 的/ 原型/ 类/ 的/ 基础/ 上/ 根据/ 用户/ 编辑/ 的/ 定制/ 信息/ (/ 主要/ 包括/ 可变性/ 对象/ 群/ 最初/ 包含/ 的/ 可变性/ 要素/ 对象/ 的/ ID/ ,/ 关联/ 的/ 体系结构/ 级/ 可变性/ 对象/ 群/ 信息/ 等/ )/ 生成/ 的/ ./ 可变性/ 对象/ 群/ 生成器/ 会/ 在/ 其/ 初始化/ 代码/ 中/ 关联/ 指定/ 的/ 可变性/ 要素/ 实例/ ,/ 以/ 形成/ 对/ 要素/ 的/ 管理/ ./ Page12/ 图/ 11/ 构件/ 级/ 可变性/ 要素/ 程序/ 集/ 和/ 可变性/ 对象/ 群/ 的/ 生成/ 体系结构/ 级/ 可变性/ 对象/ 群/ 的/ 生成/ 与/ 构件/ 级/ 可变性/ 对象/ 群/ 类似/ ./ 但/ 不同/ 的/ 是/ ,/ 其/ 所在/ 的/ 程序/ 集在/ 编译/ 时/ 不/ 需要/ 用户/ 描述/ 其/ 信息/ ./ 这/ 是因为/ 其中/ 只/ 包含/ 一个/ 可变性/ 对象/ 群/ 、/ 一个/ 可变/ 点/ 和/ 一个/ 变体/ (/ 软件/ 最初/ 的/ 体系结构/ 配置/ )/ ./ 该/ 变体/ 是/ 系统/ 在/ 初始化/ 时/ 利用/ ./ NetFramework/ 的/ 反射/ 机制/ 收集/ 软件/ 当前/ 配置/ 信息/ 生成/ 的/ ./ 4/ 实例/ 研究/ 及/ 性能/ 测试/ 本节/ 以/ 个人/ 云为/ 实验/ 背景/ ,/ 以/ 实际/ 应用/ 案例/ 展示/ 如何/ 根据/ 需求/ 变化/ 来/ 调整/ 软件系统/ 的/ 运行/ 时/ 可变性/ ,/ 进而/ 展示/ 了/ 元变/ 机制/ 对/ 软件/ 运行/ 时/ 可变性/ 动态/ 演化/ 的/ 支持/ ./ 而后/ 测试/ 比较/ 了/ 演化过程/ 中/ 对/ 不同/ 实现/ 形式/ 可变性/ 要素/ 的/ 不同/ 操作/ 的/ 时间/ 开销/ ,/ 以/ 展示/ 元变/ 机制/ 的/ 高效性/ ./ 4.1/ 案例/ 描述/ 个人/ 数据/ 资源/ 网络/ (/ PersonalDataResourceNetwork/ ,/ PDRN/ )/ 是/ 一个/ 部署/ 于/ 一组/ 互联/ 的/ 个人/ 设备/ (/ 如/ PC/ ,/ 移动/ 终端/ 等/ )/ 之上/ ,/ 用于/ 管理/ 数据/ 资源/ (/ 如/ 数字视频/ )/ 的/ 个人/ 云/ (/ PersonalCloud/ )/ ①/ ,/ 旨在/ 向/ 单个/ 用户/ 或/ 单个/ 家庭/ 提供/ 随时随地/ 的/ 可/ 定制/ 的/ 服务/ ,/ 例如/ 分布式/ 数据/ 存储/ 、/ 基于/ 语义/ 网/ 的/ 资源/ 自动/ 分类/ 等/ ./ PDRN/ 的/ 一项/ 功能性/ 需求/ 是/ 资源共享/ ,/ 即/ 按照/ 用户/ 的/ 意愿/ 向/ 其他人/ 或/ 公共/ 网络/ 开放/ 云中/ 管理/ 的/ 一部分/ 资源/ 供其/ 访问/ ./ 这种/ 共享/ 的/ 方式/ 按照/ 资源/ 的/ 内容/ 、/ 开放/ 的/ 范围/ 等/ 而/ 有所不同/ ./ 这种/ 差异/ 到/ 了/ 软件/ 的/ 运行/ 阶段/ 即/ 表现/ 为/ 运行/ 时/ 可变性/ ,/ 反映/ 了/ 设计者/ 对于/ 资源共享/ 这一/ 功能性/ 需求/ 的/ 理解/ 和/ 假设/ ./ 我们/ 以/ 资源/ 清理/ 为例/ 演示/ 如何/ 根据/ 需求/ 变化/ 来/ 演化/ 软件系统/ 的/ 运行/ 时/ 可变性/ :/ 基于/ 安全性/ 考虑/ ,/ PDRN/ 中将/ 用户/ 指定/ 的/ 共享资源/ 从/ 云中/ 的/ 其他/ 节点/ 复制到/ 一个/ 长期/ 在线/ 的/ 节点/ (/ 称/ 共享/ 节点/ )/ 上/ ./ 在/ 具有/ 一定/ 权限/ 的/ 情况/ 下/ ,/ 访问者/ 可以/ 浏览/ 或/ 下载/ 该/ 节点/ 上/ 公开/ 的/ 资源/ 内容/ ./ 由于/ 共享/ 节点/ 的/ 存储空间/ 是/ 有限/ 的/ ,/ 共享/ 节点/ 会/ 依照/ 用户/ 动态/ 指定/ 的/ 策略/ 自动/ 删除/ 满足/ 一定/ 条件/ (/ 如/ 有效期/ 已过/ )/ 的/ 资源/ ,/ 以为/ 新/ 的/ 共享资源/ 留出/ 空间/ ./ 如图/ 12/ 所示/ ,/ 为/ 尽量/ 多地/ 保留/ 存储空间/ ,/ 系统/ 可以/ 优先/ 删除/ 过/ 了/ 一定/ 日期/ (/ 日期/ 阈值/ ,/ 为/ 可变/ 点/ ,/ 由该/ 策略/ 描述/ ;/ 这/ 意味着/ 对于/ 所有/ 资源/ ,/ 日期/ 阈值/ 都/ 相同/ )/ 的/ 较大/ 的/ 资源/ ;/ 而/ 为/ 尽快/ 保留/ 存储空间/ ,/ 系统/ 可以/ 优先/ 删除/ 过/ 了/ 指定/ 日期/ (/ 有效期/ ,/ 为/ 可变/ 点/ ,/ 由/ 资源/ 的/ 属性/ 描述/ ;/ 这/ 意味着/ 对于/ 每/ 一个/ 资源/ ,/ 有效期/ 可能/ 是/ 不/ 一样/ 的/ )/ 的/ 资源/ ./ 图/ 12/ 关于/ PDRN/ 中/ 资源共享/ 节点/ 清理/ 策略/ 的/ ①/ http/ :/ // // personal/ -/ clouds/ ./ org/ // wiki/ // Main/ _/ PagePage13/ 图/ 12/ 中/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 是/ 一个/ 功能型/ 可变/ 点/ ./ 表示/ 该/ 可变/ 点/ 的/ 软件/ 制品/ 是/ 一个/ 委托/ ,/ 位于/ “/ 共享/ 节点/ 资源管理/ ”/ 构件/ 中/ “/ 过期/ 资源/ 检测/ ”/ 这一/ 模块/ ./ 其/ 变体/ (/ 即/ 具体/ 的/ 策略/ )/ 的/ 实现/ 是/ 具有/ 签名/ boolIsOutofDate/ (/ UInt32index/ )/ 的/ 函数/ ./ 其中/ 参数/ 表示/ 资源/ 列表/ (/ 位于/ “/ 资源/ 属性/ 数据库/ 管理/ ”/ 模块/ )/ 中/ 包含/ 资源/ 信息/ 的/ 数据项/ 的/ 索引/ ;/ 返回值/ 表示/ 依据/ 函数/ 内置/ 的/ 判断/ 逻辑/ 该/ 资源/ 是否/ 过期/ ./ 在/ 这样/ 的/ 实现/ 背景/ 下/ ,/ 该/ 可变/ 点/ 绑定/ 变体/ 的/ 方式/ 即将/ 具有/ 上述/ 签名/ 的/ 函数/ 赋予/ 该/ 委托/ ./ (/ 1/ )/ 场景/ 1/ ./ 添加/ 优化/ 策略/ (/ 增加/ 功能性/ 变体/ )/ 在/ 实际/ 的/ 系统/ 运行/ 中/ ,/ 设计者/ 发现/ ,/ 用户/ 希望/ 有些/ 资源/ 存在/ 于/ 共享/ 节点/ 的/ 时间/ 要长/ ,/ 不能/ 仅/ 单凭/ 有效期/ 或/ 大小/ 删除/ 它们/ 以/ 节省/ 存储空间/ ./ 换言之/ ,/ 用户/ 希望/ 增加/ 更为/ 优化/ 的/ 策略/ (/ 变体/ )/ ,/ 即/ 综合/ 考虑/ 资源/ 大小/ 和/ 在线/ 时间/ 的/ 策略/ 以/ 供选择/ ./ (/ 2/ )/ 场景/ 2/ ./ 不/ 统一/ 的/ 资源/ 清理/ 策略/ (/ 增加/ 参数/ 型/ 可变/ 点/ 和/ 功能性/ 变体/ )/ 在/ 以上/ 论述/ 中/ ,/ 清理/ 策略/ 对于/ 共享/ 节点/ 上/ 的/ 资源/ 而言/ 是/ 统一/ 的/ ./ 然而/ 为了/ 更为/ 灵活/ 的/ 管理/ 资源/ ,/ 用图/ 13/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 可变/ 点/ 对象/ 类及/ 相关/ 变体/ 对象/ 类/ 的/ 简要/ 代码/ 在/ 可变性/ 对象/ 的/ 基础/ 上/ ,/ 论述/ 问题/ 的/ 解决/ ./ (/ 1/ )/ 场景/ 1/ 问题/ 的/ 解决/ 该/ 场景/ 相关/ 的/ 可变性/ 要素/ 即图/ 12/ 中/ 的/ “/ 共享/ 节点/ 清理/ 策略/ ”/ ,/ 在/ “/ 资源管理/ 策略/ 执行/ ”/ 构件/ 中/ 被/ 表示/ ./ 在/ 运行/ 时/ ,/ 相应/ 的/ 可变/ 点/ 对象/ 实例/ 化/ 了/ 可变/ 点/ 对户/ 希望/ 对/ 不同/ 的/ 资源/ 指定/ 不同/ 的/ 清理/ 策略/ ./ 为/ 解决/ 这一/ 问题/ ,/ 设计者/ 决定/ 将/ 原先/ 节点/ 内/ 统一/ 的/ 清理/ 策略/ 改为/ 资源/ 的/ 附加/ 属性/ (/ 如同/ 有效期/ 一样/ ,/ 也/ 是/ 可变/ 点/ )/ ,/ 这样/ 就/ 可以/ 为/ 每个/ 资源/ 选择/ 不同/ 的/ 变体/ ./ 4.2/ 运行/ 时/ 可变性/ 动态/ 演化/ PDRN/ 中/ “/ 共享/ 节点/ 资源管理/ ”/ 模块/ 是/ 在/ ./ NetFramework/ 的/ 基础/ 上/ 由/ 多个/ 构件实现/ 的/ ./ 采用/ 3.3/ ./ 3/ 节/ 论述/ 的/ 方法/ 生成/ 其元变/ 机制/ 基础设施/ ,/ 其中/ 与/ 4.1/ 节/ 问题/ 相关/ 的/ 包括/ 一个/ 构件/ 级/ 可变性/ 对象/ 群类/ ResAdminVarObjectGroup/ 、/ 相应/ 的/ 可变性/ 要素/ 对象/ 类/ 、/ 与/ 可变性/ 对象/ 群/ 交互/ 的/ 用户界面/ 等/ (/ 它们/ 在/ 同一个/ 程序/ 集内/ )/ ,/ 它们/ 与/ “/ 资源管理/ 策略/ 执行/ ”/ 构件/ ResPolicyExecutionComponent/ 、/ “/ 资源/ 控制/ ”/ 构件/ ResControlComponent/ 、/ “/ 资源/ 属性/ 数据库/ 管理/ ”/ 构件/ ResPropertyDataSetComponent/ 等/ 关联/ ./ 同时/ ,/ 共享/ 节点/ 还/ 存在/ 一个/ 体系结构/ 级/ 的/ 可变性/ 对象/ 群/ ShareNodeVarObjectGroup/ ./ 为/ 支持/ 动态/ 演化/ ,/ 使用/ 可变性/ 对象/ 来/ 表示/ 两个/ 场景/ 中/ 所/ 涉及/ 的/ 可变/ 点/ 和/ 变体/ ./ 以/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 可变/ 点及/ 相关/ 变体/ 为例/ ,/ 其/ 相关/ 简要/ 代码/ 如图/ 13/ 所示/ ./ 象类/ 的/ 子类/ ResDisposingPolicy/ ,/ 并/ 管理/ 与其/ 关联/ 的/ 可变/ 点/ 的/ 信息/ (/ 作为/ 该类/ 的/ 属性/ )/ ./ 作为/ ResDisposingPolicy/ 的/ 方法/ ,/ 该/ 可变/ 点/ 对/ 变体/ 的/ 绑定/ 由/ 向/ 委托/ 赋值/ (/ 函数/ 地址/ )/ 实现/ (/ 如图/ 13/ 所示/ )/ ./ 绑定/ 操作/ 本身/ 一般/ 是/ ResDisposingPolicy/ 的/ Page14/ 实例/ 根据/ 用户/ 的/ 指令/ 进行/ 自我/ 调用/ ./ “/ 资源管理/ 策略/ 执行/ ”/ 构件/ 本身/ 不/ 关心/ 绑定/ 问题/ ./ 待/ 增加/ 的/ 优化/ 策略/ 具有/ 与/ 可变/ 点/ 已/ 关联/ 的/ 其他/ 变体/ 相同/ 的/ 函数/ 签名/ ./ 由于/ 它/ 的/ 实现/ 不/ 在/ 系统/ 已经/ 加载/ 的/ 任何/ 构件/ 实例/ 当中/ ,/ 因而/ 可以/ 通过/ 增加/ 新/ 的/ 实现/ 该/ 函数/ 的/ 构件/ 或/ 替换/ “/ 资源/ 策略/ 库/ 管理/ ”/ 构件/ ResPolicySetAdminComponent/ 为/ 新/ 的/ 实现/ 了/ 函数/ 的/ 构件/ ./ 基于/ 维护/ 成本/ 的/ 考虑/ ,/ 本文/ 采用/ 第/ 1/ 种/ 方法/ ./ 元变/ 机制/ 对于/ 优化/ 策略/ 变体/ 增加/ 的/ 过程/ 简述/ 为/ :/ ResAdminVarObjectGroup/ 接到/ 指令/ 增加/ 变体/ (/ 具有/ IsOutofDate/ 签名/ 的/ 函数/ ,/ 对应/ 变体/ 对象/ 为/ OptPolicyVarObject/ )/ ,/ 并/ 根据/ 后者/ 的/ 信息/ 确定/ 待/ 增图/ 14/ 以新/ 变体/ 增加/ 为/ 目的/ 的/ 基于/ ./ NetFramework/ 的/ 构件/ 增加/ 过程/ 系统/ 在/ 元变/ 机制/ 基础设施/ 中/ 提供/ 了/ 能够/ 与/ 可变性/ 对象/ 群/ 交互/ 的/ 用户界面/ (/ 控制面板/ (/ ControlPanel/ )/ 和/ 监视器/ (/ Monitor/ )/ )/ ,/ 可以/ 观察/ 到/ 上述/ 元变/ 机制/ 执行/ 的/ 过程/ 前后/ 可变性/ 模型/ 的/ 变化/ ./ 如图/ 15/ 所示/ ,/ 左侧/ 矩形框/ 内/ 标定/ 的/ 是/ 演化/ 之前/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 的/ 可变/ 点/ ,/ 在/ 该处/ 只有/ 两个/ 变体/ 可/ 供选择/ ,/ 而/ 右侧/ 圆角/ 矩形框/ 内/ 标定/ 的/ 是/ 演化/ 之后/ 的/ 同名/ 可变/ 点/ ,/ 可以/ 发现/ 优化/ 策略/ 变体/ 已经/ 加入/ ./ 同时/ 也/ 可以/ 观察/ 到/ 演化过程/ 增加/ 了/ “/ 过期/ 权重/ ”/ 可变/ 点/ ./ 它/ 是/ 指/ 优化/ 策略/ 中/ 过期/ 时间/ 在/ 综合/ 指数/ 中/ 占/ 的/ 权重/ ,/ 不/ 属于/ 场景/ 1/ 中所要/ 满足/ 的/ 需求/ 的/ 范围/ ,/ 但/ 它/ 是/ 优化/ 策略/ 变体/ 所/ 依赖/ (/ Require/ )/ 的/ 可变/ 点/ ,/ 位于/ 实现/ 新/ 变体/ 的/ 构件/ ,/ 所以/ 也/ 伴随/ 着/ 构件/ 增加/ 被/ 加入/ 系统/ 中/ ,/ 受到/ ResAdmin/ -/ VarObjectGroup/ 的/ 管理/ ./ 为了/ 显示/ 场景/ 1/ 可变性/ 演化/ 的/ 有效性/ ,/ 我们/ 通过/ 控制面板/ 在/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 处/ 选择/ 绑定/ 新/ 增加/ 加/ 的/ 构件/ NewVarComponent/ ;/ 而后/ 向/ ShareNode/ -/ VarObjectGroup/ 发送/ 增加/ 该/ 构件/ 的/ 请求/ ;/ 最后/ ShareNodeVarObjectGroup/ 满足/ 请求/ ./ 采用/ 3.3/ ./ 3/ 节/ 的/ 过程/ 1/ 作为/ 一般/ 步骤/ 增加/ 包含/ 的/ 构件/ 的/ 具体/ 过程/ 以/ 活动/ 图/ 表示/ 如图/ 14/ ./ 其中/ “/ Assembly/ ./ LoadFile/ ”/ 是/ 调用/ ./ NetFramework/ 中/ Assembly/ 的/ 静态方法/ LoadFile/ 生成/ 待/ 增加/ 的/ 构件/ 所/ 位于/ 的/ 程序/ 集/ 的/ 实例/ ,/ “/ CreateInstance/ ”/ 则/ 是/ 利用/ 该/ 实例/ 的/ CreateInstance/ 方法/ 创建/ 程序/ 集中/ 的/ 构件/ 实例/ 和/ 变体/ 对象/ 实例/ ./ 实际上/ 新/ 增加/ 的/ 构件/ 中/ 还/ 包含/ 其他/ 可变性/ 要素/ ,/ 其/ 对应/ 的/ 可变性/ 要素/ 对象/ 也/ 是/ 通过/ 上述/ 方法/ 创建/ 的/ ,/ 但/ 未/ 在/ 图/ 14/ 中/ 描述/ ./ 的/ 优化/ 策略/ ./ 我们/ 设置/ “/ 有效期/ ”/ 为/ 10s/ ,/ “/ 过期/ 权重/ ”/ 可变/ 点/ 绑定/ 0.6/ (/ 即/ ResPolicyExecutionComponentPage15/ 在/ 清理/ 资源/ 时/ “/ 有效期/ ”/ 占/ 0.6/ 的/ 权重/ ,/ “/ 大小/ ”/ 占/ 0.4/ 的/ 权重/ )/ ./ 共享/ 节点/ 上/ 原有/ A/ ,/ B/ ,/ C/ 三份/ 资源/ ,/ 表/ 2/ 显示/ 了/ 系统/ 在/ 做出/ 如/ 上/ 设置/ 的/ 10min/ 后/ 对/ 这些/ 资源/ 的/ 清理/ 情况/ ./ 在/ 资源/ A/ ,/ B/ ,/ C/ 具有/ 表/ 2/ 中/ 大小/ 、/ 有效期/ 和/ 超过/ 有效期/ 时间/ 的/ 情况/ 下/ :/ 如果/ 按照/ 资源/ 大小/ 清除/ 的/ 策略/ ,/ 清理/ 的/ 先后顺序/ 应当/ 是/ B/ →/ C/ →/ A/ ;/ 如果/ 是/ 按/ 在线/ 时间/ 清除/ 的/ 策略/ (/ 超过/ 有效期/ 时间/ 加上/ 有效期/ 即/ 在线/ 时间/ )/ ,/ 清理/ 的/ 先后顺序/ 应当/ 是/ A/ →/ C/ →/ B/ ;/ 而/ 从表/ 2/ 可以/ 看出/ ,/ 资源/ A/ 是/ 最先/ 被/ 清除/ 的/ ,/ 其次/ 是/ 资源/ B/ ,/ 而后/ 是/ C/ ./ 这/ 说明/ 在/ 绑定/ 优化/ 策略/ 后/ ,/ 共享/ 节点/ 对/ 资源/ 的/ 清理/ 行为/ 发生/ 了/ 改变/ ./ 应当/ 指出/ 的/ 是/ ,/ 系统/ 之所以/ 可以/ 能够/ 这样/ 绑定/ 是因为/ 我们/ 之前/ 增加/ 优化/ 策略/ 变体/ 的/ 演化过程/ 得到/ 了/ 有效/ 完成/ ./ 表/ 2/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 在/ 绑定/ 优化/ 策略/ 10min/ 后/ 资源/ A10KB10s/ 资源/ B509MB10s/ 资源/ C315KB10s/ (/ 2/ )/ 场景/ 2/ 问题/ 的/ 解决/ 从/ 可变性/ 角度/ 而言/ ,/ 满足/ 场景/ 2/ 的/ 需求/ 需要/ 做到/ 两点/ :/ ①/ 增加/ 可变/ 点/ ./ 在/ 描述/ 资源/ 的/ 元/ 数据/ (/ 如/ 名称/ 、/ 类型/ 、/ 大小/ 、/ 有效期/ 等/ 资源/ 附加/ 属性/ )/ 中/ 增加/ “/ 定制/ 清理/ 策略/ ”/ 可变/ 点/ (/ 参数/ 型/ ,/ 从元/ 数据/ 的/ 角度/ 来看/ 是/ 附加/ 属性/ )/ ,/ 这/ 意味着/ 每/ 一个/ 资源/ 的/ 信息/ 描述/ 中/ 都/ 会/ 包含/ 这一/ 可变/ 点/ ;/ ②/ 增加/ 变体/ ./ 在/ 图/ 12/ 所示/ 的/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 可变/ 点/ 增加/ 一个/ 功能型/ 变体/ “/ 个性/ 策略/ ”/ (/ 也/ 是/ 具有/ IsOutofDate/ 签名/ 的/ 函数/ )/ ,/ 其/ 在/ 运行/ 时会/ 执行/ 资源/ 的/ “/ 定制/ 清理/ 策略/ ”/ 可变/ 点/ 具体/ 指定/ 的/ 清理/ 策略/ ./ 可变/ 点/ 通常/ 涉及/ 软件/ 的/ 深层/ 设计/ ,/ 以/ 预定/ 义/ 的/ 方式/ 被/ 置于/ 系统/ 中/ [/ 1/ ,/ 3/ ]/ ./ 设计者/ 最初/ 并未/ 考虑/ 到/ 个性化/ 的/ 清除/ 策略/ 需求/ ,/ 所以/ 未/ 在/ 相关/ 构件/ ResProperty/ -/ DataSetComponent/ 中/ 设计/ 出/ 具有/ 相应/ 可变/ 点/ 的/ 资源/ 元/ 数据/ ./ 设计者/ 也/ 未/ 考虑/ 到/ 在/ 需求/ 演化/ 时元/ 数据/ 的/ 变化/ ,/ 所以/ 未/ 将/ 其/ 设计/ 为/ 数据/ 集型/ 可变/ 点/ ,/ 否则/ 解决/ 场景/ 2/ 中/ 的/ 问题/ 会/ 相对/ 简单/ 一些/ ./ 基于/ 上述/ 讨论/ ,/ 增加/ 可变/ 点/ 的/ 过程/ 具体/ 如下/ ./ 过程/ 4/ ./ 清理/ 策略/ 可变/ 点/ 的/ 增加/ ./ 1/ ./ ResAdminVarObjectGroup/ 接到/ 用户/ 指令/ 增加/ 可变/ 点/ ;/ 2/ ./ ResAdminVarObjectGroup/ 根据/ 新/ 增加/ 的/ 可变/ 点/ 和/ 关联/ 变体/ 的/ 基本/ 信息/ 和/ 人为/ 的/ 通过/ 控制面板/ 的/ 设置/ ,/ 确定/ 其/ 实现/ 所在/ 的/ 构件/ ResPropertyDataSetComponent/ _/ Ver/ _/ 02/ ;/ 3/ ./ 向/ ShareNodeVarObjectGroup/ 发送/ 消息/ ,/ 请求/ 替换/ ResPropertyDataSetComponent/ 为/ 该/ 构件/ ;/ 4/ ./ ShareNodeVarObjectGroup/ 满足/ 请求/ ./ 本文/ 中/ 替换/ 构件/ 以/ 过程/ 2/ 为/ 参考/ ,/ 除/ 第/ 5/ 步/ 状态/ 迁移/ 之外/ 其余/ 的/ 步骤/ 或/ 与/ 场景/ 1/ 的/ 类似/ ,/ 或/ 实现/ 相对/ 简单/ ,/ 本/ 节/ 不再/ 赘述/ ./ 状态/ 迁移/ 的/ 过程/ 包括/ 新/ 增加/ 可变/ 点/ 的/ 状态/ 初始化/ 、/ 原有/ 可变性/ 要素/ 的/ 状态/ 迁移/ 以及/ 构件/ 本身/ 其他/ 状态/ 的/ 迁移/ ./ 因为/ 新增/ 的/ 可变/ 点/ “/ 定制/ 清理/ 策略/ ”/ 绑定/ 的/ 变体/ 数量/ 下限/ 和/ 上限/ 都/ 是/ 1/ ,/ 所以/ 其/ 至少/ 应当/ 关联/ 并/ 绑定/ 一个/ 变体/ 才/ 能够/ 是/ 有效/ 的/ ./ 该/ 可变/ 点/ 在/ 初始化/ 时/ 关联/ 变体/ “/ 策略/ A/ ”/ 、/ “/ 策略/ B/ ”/ 、/ “/ 策略/ C/ ”/ ,/ 并/ 默认/ 绑定/ 第一个/ 变体/ ./ 原/ 构件/ 内/ 可变性/ 要素/ 的/ 状态/ 迁移/ 主要/ 是/ 将/ 可变/ 点/ 与/ 变体/ 之间/ 的/ 绑定/ 关系/ 转化/ 为/ 新/ 构件/ 中/ 的/ 绑定/ 关系/ ./ 人们/ 需要/ 保证/ 两者之间/ 的/ 一致性/ ,/ 以使/ 新/ 构件/ 能够/ 保持/ 人们/ 对/ 构件/ 内/ 实现/ 的/ 可变性/ 的/ 设定/ ,/ 并/ 能够/ 提供/ 原/ 构件/ 的/ 服务/ ./ 为了/ 使/ 软件/ 能够/ 持续/ 运行/ ,/ 除了/ 可变性/ 之外/ ,/ 构件/ 本身/ 的/ 其他/ 状态/ 也/ 需要/ 在/ 新旧/ 构件/ 实例/ 之间/ 迁移/ ./ 可以/ 采用/ 我们/ 前期工作/ [/ 37/ ]/ 的/ 方式/ 来/ 完成/ 上述/ 状态/ 迁移/ 过程/ ./ 这/ 就/ 要求/ 旧/ 构件/ 将/ 自身/ 的/ 状态/ (/ 如/ 内存/ 变量/ 、/ 可变性/ 绑定/ 信息/ )/ 暴露/ 给/ ShareNodeVar/ -/ ObjectGroup/ ,/ 由/ 其/ 提取/ 到/ 缓冲区/ 内/ 而后/ 再/ 根据/ 系统/ 维护者/ 写/ 的/ 状态/ 迁移/ 脚本/ 将/ 之/ 转化/ 为/ 新/ 构件/ 的/ 状态/ ./ 经过/ 上述/ 过程/ 的/ 演化/ 之后/ ,/ PDRN/ 中/ 关于/ 资源共享/ 节点/ 清理/ 策略/ 的/ 运行/ 时/ 可变性/ 模型/ 改变/ 为/ 如图/ 16/ (/ a/ )/ 所示/ ./ 在/ 此/ 上下文/ 中/ ,/ 如果/ 用户/ 为/ 每个/ 资源/ 定制/ 个性化/ 的/ 清理/ 策略/ ,/ 则/ 需要/ 在/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 处/ 选择/ “/ 个性/ 策略/ ”/ 变体/ ,/ 而后/ 才能/ 在/ “/ 资源/ 属性/ 数据库/ 管理/ ”/ 构件/ 的/ 支持/ 下为/ 每/ 一个/ 资源/ 指定/ 不同/ 的/ 清理/ 策略/ ID/ (/ 参数/ )/ ./ 而/ 这些/ 清理/ 策略/ ID/ 对应/ 着/ 判断/ 资源/ 是否/ 过期/ 的/ 功能性/ 代码/ ,/ 在/ 个性/ 策略/ 对应/ 的/ IsOutofDate/ 函数/ 运行/ 时/ 被/ 调用/ ./ 图/ 16/ (/ b/ )/ 为/ 经过/ 两个/ 场景/ 演化/ 之后/ 共享/ 节点/ 运行/ 时/ 可变性/ 模型/ ./ 图/ 16/ 显示/ ,/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 又/ 增加/ 了/ 一个/ 新/ 变体/ “/ 个性/ 策略/ ”/ ,/ 它/ 依赖/ 新增/ 的/ 可变/ 点/ “/ 定制/ 清理/ 策略/ ”/ ./ 后者/ 在/ 共享/ 节点/ 的/ 每个/ 资源/ 的/ 元/ 数据/ 描述/ 中/ 都/ 具有/ 一个/ 实例/ ./ 换言之/ ,/ 用户/ 可以/ 为/ 每个/ 资源/ 选择/ 属于/ 它/ 自身/ 的/ 清理/ 策略/ ,/ 而/ ResPolicyExecution/ -/ Component/ 在/ 使用/ “/ 个性/ 策略/ ”/ 时会/ 考察/ 这些/ 策略/ 并/ 执行/ 之/ ./ Page16/ 图/ 16/ 我们/ 使用/ 场景/ 1/ 中/ 的/ 资源/ A/ ,/ B/ ,/ C/ 来/ 说明/ 上述/ 演化过程/ 的/ 有效性/ ./ 3/ 份/ 资源/ 仍然/ 具有/ 表/ 2/ 中/ 的/ 大小/ 、/ 有效期/ 和/ 超过/ 有效期/ 时间/ ,/ 其/ 分别/ 在/ “/ 定制/ 清理/ 策略/ ”/ 处/ 绑定/ 策略/ A/ ,/ B/ ,/ C/ ,/ 在/ 做出/ 如/ 上/ 设置/ 10min/ 后/ ,/ 清理/ 情况/ 如表/ 3/ 所示/ ./ 表/ 3/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 在/ 绑定/ 个性/ 策略/ 10min/ 后/ 资源/ A/ 资源/ B/ 资源/ C/ 可以/ 看出/ ,/ 资源/ 清理/ 的/ 先后顺序/ 是/ B/ →/ A/ →/ C/ ,/ 与/ 场景/ 1/ 内/ 所述/ 情况/ 不同/ ./ 这/ 说明/ “/ 共享/ 节点/ 清理/ 策略/ ”/ 在/ 绑定/ “/ 个性/ 策略/ ”/ 之后/ ,/ 系统/ 行为/ 又/ 发生/ 了/ 变化/ ,/ 场景/ 2/ 的/ 需求/ 得到/ 了/ 满足/ ./ 这/ 进一步/ 说明/ 上述/ 的/ 运行/ 时/ 可变性/ 动态/ 演化/ 使得/ 清理/ 策略/ 对/ 不同/ 资源/ 的/ 个性化/ 成为/ 可能/ ,/ 也/ 说明/ 了/ 演化过程/ 的/ 有效性/ ./ 4.3/ 性能/ 测试/ 我们/ 在/ Windows7/ 专业版/ ./ NetFramework4/ ./ 5/ 环境/ 下/ ,/ 利用/ VisualStudio2010/ 的/ 性能/ 分析器/ ,/ 在/ 上述/ 个人/ 云/ 共享/ 节点/ 上下文/ 中/ ,/ 针对/ 不同/ 实现/ 形式/ 的/ 可变性/ 要素/ 的/ 增加/ 、/ 删除/ 、/ 替换/ 操作/ 的/ 执行/ 时间/ 销/ 进行/ 了/ 测试/ 和/ 比较/ ./ 测试/ 是/ 为了/ 展示/ 采用/ 3.3/ ./ 3/ 节/ 生成/ 技术/ 构建/ 的/ 软件系统/ 的/ 运行/ 时/ 可变性/ 演化/ 的/ 执行/ 效率/ ,/ 因而/ 不再/ 说明/ 演化/ 的/ 具体/ 目的/ (/ 即/ 为了/ 应对/ 怎样/ 的/ 需求/ 或/ 环境/ 变化/ )/ ./ 我们/ 按/ 可变性/ 要素/ 的/ 不同/ 实现/ 形式/ 将/ 演化/ 操作/ 分为/ 六组/ 进行/ 实验/ ,/ 我们/ 按/ 增加/ 可变/ 点/ →/ 增加/ 变体/ →/ 替换/ 变体/ →/ 删除/ 变体/ →/ 替换/ 可变/ 点/ →/ 删除/ 可变/ 点/ 的/ 顺序/ 分别/ 对/ 每组/ 相应/ 的/ 操作/ 进行/ 100/ 万次/ 调用/ (/ 分批/ 10/ 次/ 运行/ 测试/ ,/ 每/ 批次/ 测试/ 循环/ 调用/ 10/ 万次/ )/ 并/ 记录时间/ 开销/ (/ 包括/ 可能/ 的/ 体系结构/ 动态/ 调整/ 的/ 时间/ 和/ 状态/ 迁移/ 的/ 时间/ )/ ./ 其中/ 参数/ 型/ 可变性/ 要素/ 实现/ 采用/ 32/ 位/ 整数/ 类型/ 变量/ ,/ 功能型/ 可变性/ 要素/ 实现/ 采用/ 上述/ 场景/ 1/ 中/ 优化/ 策略/ 的/ IsOutofDate/ 方法/ ,/ 构件/ 型/ 可变性/ 要素/ 实现/ 采用/ 实现/ 该/ 方法/ 的/ 程序/ 集/ ,/ 数据/ 集型/ 可变性/ 要素/ 实现/ 采用/ 上述/ 描述/ 资源/ 属性/ 的/ 元/ 数据类型/ ,/ 工作/ 流型/ 可变性/ 要素/ 实现/ 采用/ 描述/ 清理/ 策略/ 的/ 数据/ ,/ 配置/ 型/ 可变性/ 要素/ 实现/ 采用/ 描述/ (/ 实现/ 清理/ 策略/ 的/ )/ 构件/ 的/ 数据/ ./ 附录/ B/ 展示/ 了/ 6/ 组/ 实验/ 中/ 演化/ 操作过程/ 10/ 次/ 测量/ 的/ 平均/ 时间/ 开销/ (/ 这里/ 平均值/ 代表/ 了/ 10/ 万次/ 循环/ 调用/ 耗时/ 的/ 总和/ )/ ./ 实验/ 数据/ 表明/ 元变/ 机制/ 是/ 较为/ 高效/ 的/ ./ 按/ 每次/ 操作/ 所/ 使用/ 的/ 总/ 时间/ 计算/ ,/ 平均/ 一次/ 增加/ 、/ 删除/ 、/ 替换/ 可变性/ 要素/ 耗时/ 大约/ 0.0177/ ms/ ./ 同时/ 可以/ 观察/ 到/ ,/ 不论/ 实现/ 形式/ 和/ 操作/ 类型/ ,/ 一项/ 操作/ 的/ 各个/ 步骤/ 的/ 时间/ 开销/ 的/ 加/ 和/ 小于/ 相应/ 的/ 总/ 时间/ ,/ 这/ 是因为/ ./ NetFramework/ 会/ 在/ 可变性/ 演化/ 时/ 根据/ 程序代码/ 自动/ 完成/ 相关/ 的/ 系统/ 调用/ (/ 如/ 内存/ 垃圾/ 回收/ )/ ,/ 导致/ 演化/ 耗时/ 比仅/ 执行/ 代码/ 时间/ (/ 称/ 应用程序/ 非/ 独占/ 时间/ [/ 35/ ]/ )/ 要长/ ./ 从/ 一次/ 可变性/ 演化过程/ 耗时/ 的/ 角度/ 考虑/ ,/ 除去/ Page17/ 不/ 需要/ 调整/ 体系结构/ 的/ 删除/ 操作/ 之外/ ,/ 体系结构/ 调整/ (/ 主要/ 是/ 增加/ 或/ 替换/ 构件/ )/ 耗时/ 占/ 总开销/ 的/ 86.43/ %/ ~/ 88.69/ %/ ./ 而/ 其他/ 步骤/ 如/ 调整/ 可变性/ 对象/ 群/ (/ 将/ 新/ 可变性/ 要素/ 对象/ 在/ 其中/ 注册/ )/ 等/ 所/ 消耗/ 的/ 时间/ 不/ 超过/ 10/ %/ ./ 体系结构/ 作何/ 调整/ 取决于/ 待/ 演化/ 的/ 可变性/ 要素/ 与/ 演化/ 目的/ 的/ 关系/ ,/ 而/ 与其/ 实现/ 形式/ 基本/ 无关/ ./ 如果/ 除去/ 体系结构/ 调整/ 耗时/ 和/ 系统/ 调用/ 时间/ ,/ 不同/ 实现/ 形式/ 的/ 可变性/ 要素/ 的/ 操作/ 时间/ 开销/ 是/ 较为/ 接近/ 的/ (/ 标准差/ 在/ 0.2692/ ~/ 1.8831/ 之间/ )/ ,/ 如图/ 17/ 所示/ ./ 无论/ 何种/ 实现/ 形式/ ,/ 替换/ 可变性/ 要素/ 的/ 时间/ 开销/ 大约/ 是/ 增加/ 该种/ 要素/ 和/ 删除/ 相应/ 的/ 时间/ 开销/ 的/ 总和/ ./ 这/ 也/ 符合/ 我们/ 在/ 3.2/ 节/ 的/ 论述/ ./ 可以/ 认为/ ,/ 在/ 不/ 考虑/ 体系结构/ 调整/ 的/ 情况/ 下/ ,/ 我们/ 所/ 提出/ 的/ 支持/ 运行/ 时/ 可变性/ 演化/ 的/ 方法/ 是/ 与/ 相应/ 的/ 可变性/ 要素/ 实现/ 形式/ 无关/ 的/ ,/ 达到/ 了/ 引言/ 中/ 提出/ 的/ 目标/ ./ 图/ 17/ 不同/ 实现/ 形式/ 的/ 要/ 变性/ 要素/ 演化/ 操作/ 的/ 5/ 结论/ 软件/ 运行/ 时/ 可变性/ 近年/ 受到/ 来自/ 适应/ 系统/ 、/ 动态/ 软件产品/ 线/ 等/ 软件工程/ 领域/ 的/ 关注/ ./ 但/ 在/ 大多数/ 情况/ 下/ ,/ 自/ 适应/ 系统/ 或/ 类似/ 的/ 系统/ 难以/ 满足/ 在/ 运行/ 期/ 持续/ 变化/ 的/ (/ 而且/ 往往/ 是/ 超过/ 预期/ 的/ )/ 需求/ 和/ 环境/ 要求/ ./ 本文/ 指出/ 造成/ 该/ 问题/ 的/ 主要/ 原因/ 是/ 它们/ 对/ 静态/ 运行/ 时/ 可变性/ 模型/ 的/ 依赖/ ./ 运行/ 时/ 可变性/ 的/ 动态/ 演化/ 则/ 是/ 解决问题/ 的/ 关键/ ./ 针对/ 该/ 领域/ 内/ 缺乏/ 对/ 实现/ 技术/ 的/ 研究/ 这一/ 问题/ ,/ 本文/ 提出/ 了/ 元变/ 机制/ ,/ 其/ 可/ 通过/ 可变性/ 对象/ 对/ 运行/ 时/ 可变性/ 模型/ 进行/ 表示/ ,/ 并/ 通过/ 体系结构/ 动态/ 调整/ 实现/ 对/ 可变性/ 要素/ 数量/ 、/ 属性/ 或/ 关系/ 的/ 改变/ ./ 可变性/ 对象/ 在/ 抽象/ 层面/ 上/ 屏蔽/ 了/ 可变性/ 要素/ 的/ 具体/ 实现/ 和/ 可变性/ 演化/ 的/ 底层/ 细节/ ,/ 而/ 使/ 人们/ 专注/ 于/ 可变性/ 模型/ 及其/ 变化/ ./ 后者/ 在/ 两层/ 可变性/ 对象/ 群/ 的/ 主导/ 下/ 利用/ 构件/ 的/ 增加/ 、/ 替换/ 和/ 删除/ 具体/ 实现/ 了/ 可变性/ 演化/ 的/ 主要/ 过程/ ./ 本文/ 还/ 论述/ 了/ 支持/ 元变/ 机制/ 运作/ 的/ 基础设施/ ,/ 以及/ 辅助/ 开发者/ 生成/ 这些/ 基础设施/ 的/ 技术/ ./ 下/ 一步/ 的/ 工作/ 主要/ 围绕/ 体系结构/ 调整/ 和/ 可变性/ 要素/ 的/ 增加/ 、/ 替换/ 和/ 删除/ 展开/ :/ 从/ 性能/ 测试/ 结果/ 可以/ 看出/ ,/ 相对/ 可变性/ 演化/ 而言/ ,/ 体系结构/ 的/ 动态/ 调整/ 带来/ 的/ 代价/ 仍然/ 较/ 高/ ./ 因而/ 我们/ 将/ 在/ 考虑/ 可变性/ 要素/ 异构/ 性/ 、/ 可追踪/ 性/ 和/ 抽象性/ 的/ 同时/ ,/ 寻求/ 一种/ 更为/ 轻量级/ 的/ 方法/ 达到/ 运行/ 时/ 可变性/ 演化/ 的/ 目的/ ./ 未来/ 工作/ 还/ 包括/ 对元变/ 机制/ 基础设施/ 的/ 完善/ ,/ 加入/ 模型/ 一致/ 检查/ 机制/ 及/ 设施/ ,/ 并/ 在/ 更/ 广泛/ 的/ 场景/ 下/ 进行/ 实验/ 验证/ ./ 

