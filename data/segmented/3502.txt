Page1/ 基于/ 实体/ 描述/ 属性/ 技术/ 的/ XML/ 重复/ 对象/ 检测/ 方法/ 李亚坤/ 王宏志/ 高宏/ 李建中/ (/ 哈尔滨工业大学/ 计算机/ 学院/ 哈尔滨/ 150001/ )/ 摘要/ 由于/ XML/ 文档/ 越来越/ 广泛/ 地被/ 用于/ 信息/ 交换/ 与/ 集成/ ,/ 其/ 数据/ 质量/ 问题/ 引起/ 了/ 人们/ 的/ 关注/ ./ 解决/ 由/ 数据/ 质量/ 引发/ 的/ 问题/ ,/ 实体/ 识别/ 技术/ 非常/ 关键/ ./ 当/ 实体/ 识别/ 被/ 应用/ 于/ XML/ 数据/ 中/ 时/ ,/ 最为/ 关键/ 的/ 操作/ 是/ 实体/ 数据/ 对象/ 的/ 匹配/ ./ 为了/ 克服/ 现有/ 方法/ 的/ 不足/ ,/ 在/ 海量/ XML/ 数据/ 上/ 进行/ 高效/ 的/ 重复/ 对象/ 检测/ ,/ 文中/ 提出/ 一种/ 基于/ 实体/ 描述/ 属性/ 技术/ 的/ 高效/ XML/ 重复/ 数据/ 对象/ 检测/ 方法/ ./ 它/ 将/ 所有/ 标签/ 属性/ 与/ 结点/ 统称/ 为/ 属性/ ,/ 用/ 实体/ 来/ 描述/ 属性/ ,/ 通过/ 属性/ 的/ 属性/ 结点/ 表/ 的/ 构建/ ,/ 快速/ 地/ 找到/ 在/ 某个/ 属性/ 上/ 相同/ 的/ 所有/ 实体/ 对象/ ,/ 然后/ 比较/ 它们/ 是否/ 重复/ ./ 此/ 方法/ 的/ 优势/ 体现/ 在/ 无需/ 比较/ 所有/ 实体/ 对象/ ,/ 只/ 需要/ 比较/ 在/ 属性/ 结点/ 表中/ 同一/ 位置/ 的/ 结点/ ,/ 大大/ 节省/ 了/ 时间/ ./ 此外/ ,/ 我们/ 提出/ 的/ Max/ -/ Merge/ 算法/ ,/ 在/ 兼顾/ 相似/ 对象/ 传递性/ 与/ 独立性/ 的/ 基础/ 之上/ ,/ 将/ 所有/ 相似/ 对象/ 进行/ 聚类/ ,/ 大大提高/ 了/ 算法/ 的/ 精确/ 率/ 与/ 召回/ 率/ ./ 关键词/ XML/ ;/ 数据/ 集成/ ;/ 数据/ 质量/ ;/ 实体/ 识别/ 1/ 引言/ 主要/ 标准/ ,/ 其/ 主要/ 原因/ 是/ 其/ 良好/ 的/ 可扩展性/ ,/ 以及/ 其/ 结构/ 的/ 灵活性/ ./ 由于/ 使用/ 日趋/ 广泛/ ,/ XML/ 文档/ 的/ 数据/ 质量/ 问题/ 引起/ 了/ 人们/ 的/ 关注/ ,/ 如/ 输入/ 错误/ 、/ 各/ 数据/ XML/ 已经/ 成为/ Web/ 上/ 数据交换/ 与/ 数据/ 集成/ 的/ 源/ 中/ 数据/ 的/ 结构/ 差异/ 、/ 表达方式/ 不同/ 等/ 因素/ 令/ XMLPage2/ 文档/ 中/ 存在/ 着/ 大量/ 的/ 数据/ 冗余/ ,/ 从而/ 对/ 数据/ 发布/ 、/ 数据/ 交互/ 、/ 数据/ 集成/ 及/ 数据挖掘/ 等/ 操作/ 产生/ 不良影响/ [/ 1/ ]/ ./ 为了/ 克服/ 由/ 数据/ 质量/ 引发/ 的/ 问题/ ,/ 研究/ 人员/ 已经/ 提出/ 许多/ 技术/ [/ 2/ -/ 5/ ]/ ,/ 其中/ 实体/ 识别/ 起着/ 重要/ 作用/ ./ 实体/ 识别/ 是/ 找到/ 那些/ 指向/ 相同/ 实体/ 的/ 数据/ 对象/ ./ 当/ 实体/ 识别/ 被/ 应用/ 于/ XML/ 数据/ 时/ ,/ 最为/ 关键/ 的/ 操作/ 是/ 实体/ 数据/ 对象/ 的/ 匹配/ ./ 实体/ 数据/ 对象/ 匹配/ 是/ 指/ 判断/ 两个/ 数据/ 对象/ 是否/ 指向/ 同一/ 真实世界/ 的/ 实体/ ,/ 如当/ 两家/ 书店/ 合并/ 以后/ ,/ 需要/ 合并/ 所有/ 图书资料/ ,/ 可是/ 有些/ 图书/ 可能/ 分别/ 存在/ 于/ 原来/ 的/ 两个/ 数据源/ 中/ ,/ 数据/ 表现形式/ 可能/ 不同/ ./ 〈/ booktitle/ =/ "/ IntroductiontoAlgorithms/ ,/ ThirdEdition/ "/ 〉/ 〈/ // book/ 〉/ 〈/ booktitle/ =/ "/ IntroductiontoAlgorithms/ "/ edition/ =/ "/ ThirdEdition/ "/ 〉/ 〈/ // book/ 〉/ 图/ 1/ 一个/ 脏/ 数据/ 片段/ 实体/ 识别/ 技术/ 的/ 许多/ 方法/ 已经/ 在/ 关系数据/ 上/ 提出/ 并/ 使用/ [/ 6/ -/ 9/ ]/ ,/ 但是/ 由于/ XML/ 数据结构/ 多样/ ,/ 致使/ 这些/ 方法/ 并/ 不/ 适用/ ./ 近年来/ ,/ 一些/ 在/ XML/ 数据/ 上/ 识别/ 实体/ 的/ 方法/ 被/ 提出/ 来/ ./ 第/ 1/ 种/ 方法/ [/ 10/ ]/ 为了/ 解决/ 元素/ 多样性/ 问题/ ,/ 先/ 通过/ 采用/ XQuery/ 语言/ 将/ 结构/ 不同/ 的/ XML/ 数据/ 元素/ 变换/ 成/ 统一/ 的/ 结构/ ,/ 再/ 将/ 同一/ 层次/ 的/ 内容/ 合并/ 为/ 一个/ 元素/ 来/ 处理/ ./ 但/ 这种/ 方法/ 使/ 原本/ 具有/ 不同/ 标签/ 的/ 数据/ 之间/ 也/ 进行/ 相似性/ 计算/ ,/ 因此/ 得到/ 的/ 精度/ 不高/ ./ 第/ 2/ 种/ 方法/ [/ 1/ ,/ 11/ ]/ 将/ XML/ 数据抽象/ 形成/ 为/ 一个/ 树/ ,/ 通过/ 计算/ 树/ 之间/ 的/ 编辑/ 距离/ 得出/ 对象/ 相似/ 度/ ./ 这种/ 方法/ 的/ 时间/ 复杂度/ 在/ O/ (/ |/ T/ (/ e/ )/ |/ ×/ n2/ )/ 数量级/ 上/ ,/ 其中/ e/ 为/ 实体/ 对象/ 元素/ ,/ n/ 为/ 实体/ 数量/ ./ 若/ 实体/ 的/ 描述/ 信息/ 庞大/ ,/ 这种/ 方法/ 的/ 效率/ 将会/ 非常低/ ./ 第/ 3/ 种/ 方法/ [/ 12/ ]/ 将/ 具有/ 相似/ 结构/ 的/ XML/ 元素/ 进例/ 1/ ./ 图/ 1/ 是/ 一个/ 集成/ 后/ 的/ 脏/ 数据/ 片段/ ,/ 在/ 这个/ 数据源/ 中/ ,/ 4/ 个/ 元素/ 都/ 指向/ 同一/ 实体/ ,/ 但/ 它们/ 的/ 表现形式/ 有/ 很大/ 不同/ ./ 不仅/ 数据/ 内容/ 不尽相同/ ,/ 数据组织/ 结构/ 也/ 有/ 很大/ 差异/ ./ 如/ :/ 元素/ 1/ 的/ 书名/ 中/ 加入/ 了/ 版本号/ ;/ 元素/ 2/ 中/ 的/ 作者/ 被/ 写/ 到/ 了/ 一起/ ,/ publishdate/ 以/ 属性/ 的/ 形式/ 给出/ ;/ 元素/ 3/ 中/ 增加/ 了/ 版本/ 属性/ 、/ 作者/ 不/ 全且/ 多/ 了/ 一个/ publish/ 结点/ ;/ 元素/ 4/ 中多/ 了/ lan/ -/ guage/ 、/ page/ 、/ rank/ 子/ 结点/ ./ 各/ 元素/ 的/ price/ 中/ 的/ 数值/ 也/ 各不相同/ ,/ 并且/ 还/ 有些/ 简单/ 的/ 拼写错误/ 存在/ 于/ 各/ 属性/ 及/ 属性/ 值/ 当中/ ./ 〈/ booktitle/ =/ "/ IntroductiontoAlgorithms/ "/ 〉/ 〈/ // book/ 〉/ 〈/ book/ 〉/ 〈/ title/ 〉/ IntroductiontoAlgorithms/ 〈/ // title/ 〉/ 〈/ author/ 〉/ ThomasH/ ./ Cormen/ 〈/ // author/ 〉/ 〈/ author/ 〉/ CharlesE/ ./ Leiserson/ 〈/ // author/ 〉/ 〈/ author/ 〉/ RonaldL/ ./ Rivest/ 〈/ // author/ 〉/ 〈/ author/ 〉/ CliffordStein/ 〈/ // author/ 〉/ 〈/ ISBN/ 〉/ 0262033844/ 〈/ // ISBN/ 〉/ 〈/ price/ 〉/ 63.8/ 〈/ // price/ 〉/ 〈/ publisher/ 〉/ TheMITPress/ 〈/ // publisher/ 〉/ 〈/ publishdate/ 〉/ 2009/ -/ 9/ -/ 30/ 〈/ // publishdate/ 〉/ 〈/ language/ 〉/ English/ 〈/ // language/ 〉/ 〈/ page/ 〉/ 1312/ 〈/ // page/ 〉/ 〈/ rank/ 〉/ 136663/ 〈/ // rank/ 〉/ 〈/ // book/ 〉/ 行/ 合并/ ,/ 提出/ 了/ 三类/ 启发式/ 聚类/ 算法/ ,/ 分别/ 使用/ 全部/ 比较/ 聚类/ 、/ 选择/ 比较/ 聚类/ 、/ M/ 树聚类/ 方法/ 来/ 实现/ 重复/ 元素/ 的/ 合并/ ./ 主要/ 不足/ 在于/ 没有/ 解决/ XML/ 数据结构/ 多样性/ 的/ 问题/ ./ 总而言之/ ,/ 现有/ 方法/ 的/ 缺点/ 可以/ 归纳/ 为/ 三点/ :/ 第一/ ,/ 这些/ 方法/ 需要/ 将/ 所有/ 实体/ 对象/ 一一/ 比较/ ,/ 效率/ 不高/ ;/ 第二/ ,/ 这些/ 方法/ 不能/ 区别对待/ 各个/ 属性/ 及/ 结点/ ,/ 从而/ 产生/ 的/ 精确度/ 不高/ ;/ 第三/ ,/ 现有/ 方法/ 可扩展性/ 差/ ,/ 不适/ 用于/ 海量/ 数据/ ./ 为了/ 克服/ 现有/ 方法/ 的/ 不足/ ,/ 在/ 海量/ XML/ 数据/ 上/ 进行/ 高效/ 的/ 重复/ 对象/ 检测/ ,/ 我们/ 提出/ 一种/ 基于/ 实体/ 描述/ 属性/ 的/ 高效/ XML/ 重复/ 数据/ 对象/ 检测/ 方法/ ./ 这种/ 方法/ 将/ 待/ 识别/ 元素/ 定义/ 为/ 实体/ 对象/ ,/ 将/ 标签/ 、/ 属性/ 和子/ 元素/ 都/ 看作/ 实体/ 属性/ ,/ 用/ 实体/ 属性/ 来/ 辨识/ 实体/ ./ 通过/ 属性/ 结点/ 表/ 的/ 构建/ ,/ 可以/ 快速/ 地/ 找到/ 在/ 某个/ Page3/ 属性/ 上/ 相同/ 的/ 所有/ 实体/ 对象/ ,/ 从而/ 达到/ 发现/ 描述/ 同一/ 实体/ 的/ 不同/ 数据/ 对象/ 的/ 目的/ ./ 此/ 方法/ 的/ 优势/ 体现/ 在/ 仅/ 需/ 比较/ 在/ 某些/ 属性/ 上值/ 相同/ 或/ 相似/ 的/ 元素/ ,/ 而/ 无需/ 比较/ 所有/ 的/ 实体/ 对象/ ,/ 从而/ 提高/ 了/ 效率/ ./ 这种/ 方法/ 还/ 通过/ 抽取/ 属性/ 与/ 结点/ 值/ 降低/ 了/ XML/ 数据/ 中/ 描述/ 实体/ 对象/ 结构/ 的/ 复杂性/ ./ 在/ 本文/ 的/ 方法/ 中/ ,/ 各个/ 属性/ 的/ 权值/ 根据/ 其/ 区分/ 实体/ 对象/ 的/ 能力/ 确定/ ,/ 当/ 得到/ 两个/ 候选/ 对象/ 后/ ,/ 将/ 所有/ 相似/ 的/ 属性/ 的/ 权值/ 累加/ ,/ 若/ 大于/ 阈值/ 则/ 以/ 二元/ 组/ 的/ 形式/ 输出/ ./ 再/ 通过/ 使用/ Max/ -/ Merge/ 算法/ ,/ 在/ 兼顾/ 相似/ 对象/ 的/ 传递性/ 与/ 独立性/ 的/ 基础/ 之上/ ,/ 将/ 所有/ 相似/ 的/ 对象/ 进行/ 聚类/ ./ 本文/ 的/ 贡献/ 如下/ :/ (/ 1/ )/ 提出/ 了/ 基于/ 实体/ 描述/ 属性/ 技术/ 的/ 高效/ XML/ 重复/ 对象/ 检测/ 算法/ ./ 两个/ 数据/ 对象/ 如果/ 描述/ 同一个/ 真实世界/ 的/ 实体/ ,/ 那么/ 它们/ 很难/ 在/ 所有/ 相应/ 属性/ 上/ 都/ 不同/ ,/ 因此/ 我们/ 重点/ 考虑/ 在/ 所有/ 不同/ 属性/ 中有/ 若干/ 属性/ 相同/ 或/ 相似/ 的/ 情况/ ./ 通过/ 实体/ 对象/ 的/ 改造/ 、/ 插入/ 属性/ 结点/ 表/ 、/ 查询/ 属性/ 结点/ 表/ 进行/ 重复/ 对象/ 的/ 检测/ ./ 使用/ 这种/ 算法/ 进行/ XML/ 数据/ 的/ 重复/ 对象/ 检测/ 架构/ 对于/ 删除/ 冗余/ 是/ 有效/ 且/ 实际/ 的/ ./ (/ 2/ )/ 提出/ 了/ 有效/ 的/ 实体/ 对象/ 改造/ 方法/ ./ 经过/ 改造/ ,/ 其/ 结果/ 适用/ 于/ 具有/ 多种/ 结构/ 的/ XML/ 文档/ 上/ 的/ 实体/ 识别/ ./ (/ 3/ )/ 提出/ 了/ 高效/ 的/ 用于/ 实体/ 识别/ 的/ 聚类/ 算法/ MaxMerge/ ./ 它/ 兼顾/ 了/ 各个/ 实体/ 对象/ 之间/ 相似/ 的/ 传递性/ 与/ 独立性/ ,/ 是/ 一种/ 快速/ 有效/ 的/ 聚类/ 方法/ ./ (/ 4/ )/ 通过/ 实验/ ,/ 我们/ 证实/ 了/ 本文/ 提出/ 算法/ 的/ 效率/ 和/ 有效性/ ,/ 并/ 对/ 其/ 参数/ 影响/ 进行/ 了/ 验证/ ./ 本文/ 第/ 2/ 节/ 介绍/ 为了/ 使/ 输入/ 数据/ 满足/ 算法/ 要求/ 而/ 对/ 数据/ 进行/ 的/ 改造/ 的/ 方法/ ./ 基于/ 实体/ 描述/ 属性/ 的/ 重复/ 对象/ 检测/ 算法/ 将/ 在/ 第/ 3/ 节/ 提出/ ./ 为了/ 将/ 输出/ 的/ 重复/ 对象/ 二元/ 组/ 进行/ 聚类/ ,/ 我们/ 将/ 在/ 第/ 4/ 节/ 提出/ MaxMerge/ 算法/ ,/ 并/ 对/ 算法/ 进行/ 分析/ ./ 结论/ 将/ 在/ 第/ 5/ 节/ 给出/ ./ 2/ 实体/ 对象/ 改造/ 在/ 实体/ 识别/ 过程/ 中/ ,/ XML/ 数据/ 不规则/ 可能/ 会/ 引发/ 一系列/ 问题/ ./ 例如/ ,/ 没有/ 主键/ 便/ 无法/ 直接/ 定位/ 到/ 对象/ ,/ 两个/ 不同/ 的/ XML/ 数据源/ 中/ 对/ 某个/ 属性/ 的/ 属性/ 名/ 表述/ 可能/ 不同/ ,/ 而/ 两个/ 相同/ 的/ 属性/ 名/ 在/ 不同/ 的/ 数据源/ 中/ 可能/ 代表/ 不同/ 的/ 意义/ ,/ 对象/ 的/ 父级/ 及/ 以上/ 的/ 结点/ 降低/ 了/ 对象/ 的/ 检索/ 速度/ ./ 如/ 在/ 图/ 2/ 中/ 的/ 两个/ 实体/ 对象/ 中/ ,/ 两个/ book/ 路径/ 不/ 一致/ ,/ 难以/ 唯一/ 定位/ 到/ 实体/ 对象/ ;/ 结点/ 1/ 中/ 作者/ 这一/ 属性/ 的/ 属性/ 名为/ name/ ,/ 而/ 在/ 结点/ 2/ 中为/ author/ ;/ 结点/ 1/ 中/ 的/ 属性/ 名/ name/ 与/ 结点/ 2/ 中/ 的/ 属性/ 名/ name/ 分别/ 代表/ 对象/ 的/ 作者/ 和/ 书名/ 这/ 两个/ 不同/ 的/ 属性/ ;/ 结点/ 2/ 中/ 属性/ 结点/ edition/ 与子/ 结点/ edition/ 的/ 属性/ 值/ 完全相同/ ,/ 它们/ 对于/ 对象/ 的/ 描述/ 意义/ 冗余/ ;/ 结点/ 1/ 中/ 的/ 父/ 结点/ 与/ 结点/ 2/ 同/ 处于/ 一个/ 层上/ ,/ 检索/ 对象/ 结点/ 时/ 不/ 属于/ 同一个/ 结果/ 集/ ,/ 降低/ 了/ 检索/ 的/ 效率/ ./ 〈/ books/ 〉/ 〈/ booktitle/ =/ "/ IntroductiontoAlgorithms/ "/ 〉/ 〈/ // book/ 〉/ 〈/ // books/ 〉/ 〈/ bookname/ =/ "/ IntroductiontoAlgorithms/ "/ edition/ =/ "/ ThirdEdition/ "/ 〉/ 〈/ // book/ 〉/ 为了/ 支持/ 有效/ 的/ 实体/ 识别/ ,/ 需要/ 对/ XML/ 数据/ 进行/ 预处理/ ,/ 使/ 其/ 具有/ 适用/ 于/ 实体/ 识别/ 的/ 结构/ ./ 我们/ 首先/ 基于/ XML/ 数据/ 的/ 特征/ 提出/ 了/ 4/ 条/ 数据源/ 改造/ 规则/ ./ 规则/ 1/ 使/ 对象/ 结点/ 检索/ 具有/ 唯一性/ ;/ 规则/ 2/ 统一/ 了/ 不同/ 数据源/ 中/ 的/ 属性/ 名/ ;/ 规则/ 3/ 消除/ 了/ 冗余/ 的/ 属性/ 对/ ;/ 规则/ 4/ 令/ 所有/ 实体/ 对象/ 结点/ 处在/ 数据源/ 中/ 的/ 同/ 一层/ 上/ ,/ 极大/ 地方/ 便/ 了/ 对象/ 的/ 检索/ ./ 以下/ 是/ 这/ 4/ 条/ 规则/ 的/ 详细描述/ ,/ 其中/ 对于/ 实体/ 对象/ a/ 和/ b/ ,/ path/ (/ a/ )/ 表示/ 对象/ a/ 的/ XQuery/ 路径/ ,/ height/ (/ a/ )/ 表示/ a/ 到/ 根/ 结点/ 的/ 高度/ ,/ path/ (/ a/ )/ =/ path/ (/ b/ )/ 表示/ a/ 与/ b/ 的/ 路径/ 完全相同/ ,/ a/ =/ b/ 表示/ 是/ 同一个/ 对象/ ./ 对于/ 属性/ 名/ namea/ ,/ mean/ (/ namea/ )/ 代表/ namea/ 所/ 代表/ 属性/ 的/ 语义/ ,/ mean/ (/ namea/ )/ =/ mean/ (/ nameb/ )/ 表示/ 两个/ 属性/ 名所/ 代表/ 的/ 意义/ 相同/ ./ 规则/ 1/ ./ 对于/ 实体/ 对象/ a/ 和/ b/ ,/ path/ (/ a/ )/ =/ path/ (/ b/ )/ / a/ =/ b/ ./ Page4/ 规则/ 2/ ./ 对于/ 属性/ 名/ namea/ ∈/ a/ ,/ nameb/ ∈/ b/ ,/ namea/ =/ nameb/ / mean/ (/ namea/ )/ =/ mean/ (/ nameb/ )/ ./ 规则/ 3/ ./ 对于/ 实体/ 对象/ a/ ,/ 属性/ 对/ 〈/ name/ ,/ value1/ 〉/ ∈/ a/ ∧/ 〈/ name/ ,/ value2/ 〉/ ∈/ a/ / value1/ ≠/ value2/ ./ 规则/ 4/ ./ 对于/ 实体/ 对象/ a/ ,/ height/ (/ a/ )/ =/ 1/ ./ 为了/ 使/ 待处理/ XML/ 数据/ 满足/ 上述/ 条件/ ,/ 需要/ 对/ 其/ 进行/ 预处理/ ,/ 该/ 处理/ 主要/ 包含/ 如下/ 4/ 个/ 步骤/ ./ 第/ 1/ 步/ ./ 使/ 对象/ 具有/ 唯一性/ ./ 由于/ XML/ 数据/ 中/ 没有/ 主键/ 这一/ 概念/ ,/ 可以/ 存在/ 部分/ 甚至/ 完全相同/ 的/ 实体/ 对象/ ,/ 因此/ 实体/ 对象/ 具有/ 不/ 唯一性/ ./ 而/ 我们/ 的/ 算法/ 需要/ 将/ 对象/ 的/ 唯一/ 标识/ 插入/ 属性/ 结点/ 表/ ,/ 并/ 通过/ 这一/ 标识/ 来/ 检索/ 对象/ ,/ 因此/ 需要/ 将/ 实体/ 对象/ 改造/ 为/ 具有/ 唯一/ 标识/ 的/ 元素/ ./ 改造/ 的/ 方法/ 可以/ 为/ 把/ 实体/ 对象/ 的/ 标签/ 改成/ 字母/ +/ 数字/ 的/ 形式/ ,/ 通过/ 遍历/ 各个/ 实体/ 对象/ 结点/ ,/ 将/ 各/ 对象/ 的/ 标签/ 名字/ 中/ 的/ 数字/ 部分/ 逐一/ 增加/ ./ 第/ 2/ 步/ ./ 统一/ 属性/ 名/ ./ 两个/ 不同/ 的/ XML/ 数据源/ 中/ 对/ 某个/ 属性/ 的/ 属性/ 名/ 表述/ 可能/ 不同/ ,/ 而/ 两个/ 相同/ 的/ 属性/ 名/ 在/ 不同/ 的/ 数据源/ 中/ 可能/ 代表/ 不同/ 的/ 意义/ ./ 我们/ 希望/ 通过/ 相应/ 属性/ 上/ 的/ 属性/ 结点/ 表来/ 定位/ 实体/ 对象/ ,/ 因此/ 有/ 必要/ 在/ 开始/ 阶段/ 将/ 对应/ 的/ 属性/ 名/ 进行/ 统一/ ./ 令/ 所有/ 代表/ 相同/ 意义/ 的/ 属性/ 名/ 相同/ ,/ 所有/ 代表/ 不同/ 意义/ 的/ 属性/ 名/ 不同/ ./ 第/ 3/ 步/ ./ 消除/ 冗余/ 的/ 属性/ 对/ 冗余/ 的/ 属性/ 对/ 是/ 指/ 在/ 一个/ 实体/ 对象/ 当中/ 属性/ 名/ 和/ 属性/ 值/ 都/ 完全相同/ 的/ 属性/ 对/ ./ 如果/ 存在/ 冗余/ 的/ 属性/ 对/ ,/ 它们/ 对/ 实体/ 的/ 描述/ 价值/ 可以/ 由/ 其中/ 之一/ 替代/ ,/ 因此/ 我们/ 可以/ 直接/ 删除/ 冗余/ 的/ 属性/ 对/ ./ 第/ 4/ 步/ ./ 使/ 所有/ 对象/ 结点/ 处于/ 同/ 一层/ 上/ 实体/ 对象/ 的/ 具有/ 的/ 复杂/ 层次结构/ 降低/ 了/ 对象/ 的/ 处理/ 效率/ ,/ 我们/ 可以/ 将/ 其/ 祖先/ 和/ 父亲/ 改造/ 成为/ 对象/ 的/ 子/ 结点/ ,/ 表示/ 其/ 对/ 对象/ 的/ 描述/ ./ 如果/ 事先/ 已经/ 得知/ 对象/ 的/ 部分/ 或/ 全部/ 父级/ 上/ 的/ 结点/ 对/ 其/ 并/ 无/ 描述/ 的/ 意义/ ,/ 那么/ 我们/ 可以/ 直接/ 删去/ 这些/ 结点/ ,/ 把/ 对象/ 结点/ 上/ 提到/ 根/ 结点/ 的/ 直接/ 子/ 结点/ 的/ 位置/ 上/ ./ 经过/ 以上/ 的/ 4/ 步/ 改造/ ,/ XML/ 数据/ 中/ 的/ 对象/ 具备/ 了/ 标识/ 唯一性/ 和/ 属性/ 统一性/ ,/ 消除/ 了/ 冗余/ 属性/ 对/ ,/ 且/ 使得/ 属性/ 处在/ 了/ 同/ 一层/ ,/ 从而/ 满足/ 了/ 上面/ 所/ 提出/ 的/ 4/ 条/ 规则/ ./ 例/ 2/ ./ 下面/ 我们/ 使用/ 这/ 4/ 步对/ 图/ 2/ 中/ 的/ 两个/ 结点/ 进行/ 预处理/ ./ 第/ 1/ 步/ ./ 将/ 两个/ 结点/ 的/ 标签/ 分别/ 改为/ book1/ 和/ book2/ ,/ 使/ 其/ 具有/ 唯一性/ ./ 第/ 2/ 步/ ./ 将/ 结点/ 1/ 中/ 的/ 属性/ 名/ name/ 改为/ author/ ,/ 将/ 结点/ 2/ 中/ 的/ 属性/ 名/ name/ 改为/ title/ ./ 第/ 3/ 步/ ./ 删除/ 结点/ 2/ 中/ 的/ 属性/ 结点/ edition/ ./ 第/ 4/ 步/ ./ 删除/ 结点/ 1/ 的/ 父/ 结点/ ,/ 将/ 结点/ 1/ 上/ 提/ 经过/ 4/ 步/ 预处理/ 后/ ,/ 改造/ 后/ 的/ 两个/ 结点/ 为/ 图/ 3/ 到/ 与/ 结点/ 2/ 同/ 一层/ 的/ 位置/ 上/ ./ 中/ 的/ 两个/ 结点/ ./ 〈/ book1title/ =/ "/ IntroductiontoAlgorithms/ "/ 〉/ 〈/ // book1/ 〉/ 〈/ book2title/ =/ "/ IntroductiontoAlgorithms/ "/ 〉/ 〈/ // book2/ 〉/ 3/ 重复/ 对象/ 检测/ 两个/ 数据/ 对象/ 如果/ 描述/ 同一个/ 真实世界/ 实体/ ,/ 尽管/ 它们/ 很/ 可能/ 在/ 某些/ 属性/ 的/ 表现形式/ 上/ 有所不同/ ,/ 但是/ 它们/ 的/ 某些/ 属性/ 值/ 可能/ 相似/ ./ 因此/ ,/ 我们/ 提出/ 了/ 重复/ 对象/ 模型/ 检测/ 算法/ ./ 该/ 算法/ 按照/ 属性/ 组织/ 对象/ ,/ 把/ 在/ 某个/ 属性/ 上/ 相同/ 的/ 对象/ 放到/ 同一个/ 属性/ 结点/ 表中/ 的/ 相同/ 位置/ 上/ ,/ 这样/ 就/ 可以/ 通过/ 一次/ 对/ 数据源/ 的/ 遍历/ 操作/ ,/ 把/ 各个/ 对象/ 的/ 唯一/ 标识/ 插入/ 到/ 其/ 各/ 属性/ 结点/ 表中/ 的/ 相应/ 位置/ 上/ ,/ 然后/ 只/ 比较/ 在/ 对应/ 属性/ 上/ 相同/ 的/ 对象/ ./ 本/ 小节/ 首先/ 给出/ 算法/ 的/ 基本/ 模型/ ,/ 接着/ 介绍/ 将/ 实体/ 对象/ 插入/ 到/ 其/ 各个/ 属性/ 的/ 属性/ 结点/ 表/ 的/ 方法/ (/ 3.1/ 节/ )/ ,/ 然后/ 再/ 利用/ 已得/ 的/ 属性/ 结点/ 表/ 进行/ 重复/ 对象/ 的/ 检测/ 工作/ ,/ 得到/ 描述/ 同一/ 实体/ 的/ 对象/ 对/ (/ 3.2/ 节/ )/ ,/ 其中/ 用于/ 利用/ 对象/ 对/ 求得/ 最终/ 实体/ 识别/ 结果/ 的/ MaxMerge/ 算法/ 将/ 在/ 下/ 一部分/ 详细/ 介绍/ ./ Page53/ ./ 1/ 将/ 对象/ 插入/ 属性/ 结点/ 表/ 我们/ 的/ 方法/ 需要/ 按照/ 属性/ 组织/ 实体/ 对象/ ./ 因此/ ,/ 我们/ 提出/ 了/ 属性/ 结点/ 表/ 用于/ 实现/ XML/ 数据/ 上/ 的/ 实体/ 识别/ ./ 本/ 小节/ 将/ 介绍/ 该/ 数据结构/ 与其/ 维护/ 方法/ ./ 属性/ 节点/ 表/ 分为/ 两个/ 部分/ ,/ 分别/ 是/ 属性/ 名表/ 与/ 对象/ 表/ ./ 首先/ 介绍/ 属性/ 名表/ ,/ 由于/ 我们/ 的/ 算法/ 把/ 描述/ 实体/ 对象/ 的/ 所有/ 〈/ 文本/ 元素/ 标签/ ,/ 文本/ 元素/ 值/ 〉/ 及/ 〈/ 元素/ 属性/ 名/ ,/ 属性/ 值/ 〉/ 都/ 看成/ 属性/ 对/ ,/ 从而/ 得到/ 的/ 属性/ 名/ 的/ 个数/ 较/ 多/ ,/ 且/ 事先/ 无法/ 预知/ 其/ 具体/ 数目/ ,/ 因此/ 需要/ 为/ 所有/ 属性/ 名/ 建立/ 一个/ 属性/ 名表/ ,/ 这样/ 我们/ 可以/ 通过/ 查询/ 此表/ 而/ 得知/ 某/ 属性/ 是否/ 已经/ 出现/ 过/ ,/ 并/ 能/ 得到/ 它/ 的/ 唯一/ 序号/ ./ 如图/ 5/ 所示/ ,/ 属性/ 名表/ 中/ 的/ 每个/ 位置/ 上/ 的/ 链表/ 中/ 的/ 每一项/ 包含/ 属性/ 名/ 、/ 属性/ 序号/ 、/ 属性/ 出现/ 的/ 次数/ 与/ 指向/ 下/ 一项/ 的/ 指针/ ./ 当/ 我们/ 遍历/ 到/ 实体/ 对象/ 的/ 某个/ 属性/ 对时/ ,/ 为了/ 确定/ 将/ 实体/ 对象/ 插入/ 到/ 哪个/ 对象/ 表中/ ,/ 需要/ 查询/ 属性/ 名表/ 获得/ 这一/ 属性/ 的/ 序号/ ./ 首先/ 检查一下/ 这个/ 属性/ 名/ 是否/ 已经/ 存在/ 于/ 属性/ 名表/ 当中/ ,/ 如果/ 存在/ ,/ 那么/ 返回/ 这个/ 属性/ 的/ 属性/ 序号/ ;/ 如果/ 不/ 存在/ ,/ 就要/ 把/ 这个/ 属性/ 名/ 插入/ 到/ 属性/ 名表/ 当中/ ,/ 并/ 得到/ 唯一/ 的/ 属性/ 序号/ ./ 然后/ 我们/ 将/ 实体/ 对象/ 的/ 唯一/ 标识/ 插入/ 到/ 得到/ 的/ 属性/ 序号/ 的/ 属性/ 结点/ 表中/ ./ 算法/ 如下/ ./ 算法/ 1/ ./ 属性/ 序号/ 计算/ 算法/ ./ 输入/ :/ 所有/ 属性/ 名/ attrName/ 输出/ :/ 属性/ 序号/ 1/ ./ whilegetattrNameandattrValue/ ;/ 2/ ./ hashattrNameintoanumber/ ;/ 3/ ./ number/ =/ number/ %/ attrNameIndexSize/ ;/ 4/ ./ ifattrNameinattrNameIndex/ [/ number/ ]/ 5/ ./ attrName/ ./ times/ ++/ ;/ 6/ ./ getattrOrder/ ;/ 7/ ./ else8/ ./ addattrNameintoattrNameIndex/ [/ number/ ]/ ;/ 9/ ./ attrName/ ./ times/ =/ 1/ ;/ 10/ ./ getattrOrder/ ;/ 11/ ./ endif/ ;/ 12/ ./ endwhile/ ;/ 当/ 我们/ 得到/ 属性/ 名/ 的/ 属性/ 序号/ 后/ ,/ 我们/ 就/ 可以/ 把/ 当前/ 对象/ 的/ 唯一/ 标识/ 插入/ 对象/ 表中/ 相应/ 位置/ 上/ ./ 首先/ 通过/ 一个/ 字符串/ 散列/ 函数/ 把/ 当前/ 属性/ 值散/ 列成/ 一个/ 数值/ ,/ 再用/ 这/ 一/ 数值/ 模上/ 对象/ 表/ 的/ 尺寸/ ,/ 然后/ 把/ 当前/ 对象/ 的/ 唯一/ 标识/ 插入/ 到/ 对象/ 表中/ 的/ 这/ 一/ 数值/ 的/ 位置/ 上/ ./ 插入/ 算法/ 如下/ ./ 算法/ 2/ ./ 实体/ 对象/ 唯一/ 标识/ 插入/ 算法/ ./ 输入/ :/ 所有/ 属性/ 名/ 序号/ attrOrder/ 与/ 属性/ 值/ attrValue/ 输出/ :/ 对象/ 表/ 1/ ./ getattrOrderandattrValue/ ;/ 2/ ./ ifattrValuehasnotbeeninserted/ ;/ 3/ ./ hashattrValueintoanumber/ ;/ 4/ ./ number/ =/ number/ %/ attrValueIndexSize/ ;/ 5/ ./ adduniqueIdentifierto6/ ./ attrValueIndex/ [/ attrOrder/ ]/ [/ number/ ]/ ;/ 7/ ./ endif/ ;/ 将/ 所有/ 对象/ 的/ 标识/ 插入/ 到/ 对象/ 表后/ ,/ 最后/ 得到/ 的/ 对象/ 表如图/ 6/ 所示/ ./ 3.2/ 重复/ 对象/ 检测/ 过程/ 在/ 遍历/ 完/ 所有/ 实体/ 对象/ ,/ 把/ 它们/ 的/ 唯一/ 标识/ 分别/ 插入/ 到/ 其/ 相应/ 对象/ 表中后/ ,/ 基于/ 实体/ 对象/ 表/ 进行/ 重复/ 对象/ 的/ 检测/ ,/ 获得/ 可能/ 描述/ 同一/ 实体/ 的/ 对象/ 对/ ./ 该/ 过程/ 分为/ 如下/ 两个/ 步骤/ ./ 3.2/ ./ 1/ 计算/ 各/ 属性/ 权值/ 由于/ 不同/ 的/ 属性/ 对于/ 对象/ 的/ 描述/ 重要性/ 可能/ 不同/ ,/ 为了/ 更加/ 精确/ 地/ 识别/ 实体/ 对象/ ,/ 需要/ 根据/ 属性/ 描述/ 对象/ 的/ 重要性/ 赋予/ 不同/ 的/ 权值/ ./ 在/ 将/ 所有/ 实体/ 对象/ 分别/ 插入/ 到/ 各个/ 属性/ 结点/ 表中后/ ,/ 每个/ 属性/ 出现/ 的/ 次数/ 已经/ 被/ 记录下来/ ,/ 我们/ 认为/ 在/ 所有/ 对象/ 中/ 出现/ 次数/ 较/ 多/ 的/ 属性/ 更/ 能够/ 描述/ 对象/ ./ 因此/ 我们/ 选择/ 出现/ 次数/ 最多/ 的/ 属性/ 的/ 次数/ T/ 作为/ 计算/ 各个/ 属性/ 权值/ 的/ 基值/ ,/ 各个/ 属性/ 的/ 权值/ (/ Weight/ )/ 定义/ 为/ 其出/ Page6/ 现/ 次数/ 除以/ 基值/ 所得/ 的/ 商/ ,/ 可/ 表示/ 为/ Weighti/ =/ TiTMAX/ ,/ 其中/ Ti/ 是/ 各个/ 属性/ 自己/ 出现/ 的/ 次数/ ,/ TMAX/ 是/ 出现/ 次数/ 最多/ 的/ 属性/ 的/ 次数/ ./ 3.2/ ./ 2/ 得到/ 候选/ 对象/ 及其/ 相似性/ 比较/ 所示/ ./ 首先/ 我们/ 介绍/ 一下/ 用到/ 的/ 符号/ 和/ 缩写/ ,/ 如表/ 1Similarity/ ∧/ OiattriWeightiK/ γ/ iSize/ (/ O1/ [/ attri/ ]/ )/ O1/ 中/ attri/ 中/ 属性/ 值/ 的/ 个数/ SimilarM/ 为了/ 找出/ 数据源/ 中/ 的/ 重复/ 对象/ 对/ ,/ 检测/ 的/ 过程/ 如下/ :/ 首先/ 遍历/ 第/ 1/ 个/ 属性/ 的/ 属性/ 结点/ 表/ ,/ 若表中/ 某/ 一/ 位置/ 的/ 标识/ 数为/ 0/ 或/ 1/ ,/ 则/ 跳/ 过/ 该/ 位置/ ,/ 继续/ 遍历/ 下/ 一/ 位置/ ;/ 若此/ 位置/ 的/ 标识/ 数/ 大于/ 等于/ 2/ ,/ 则/ 取出/ 所有/ 标识/ ./ 通过/ 第/ 1/ 个/ 标识/ ,/ 取出/ 其所/ 代表/ 的/ 节点/ ,/ 创建/ 一个/ 包含/ 所有/ 出现/ 过/ 的/ 属性/ 名/ 的/ 链表/ 数组/ ,/ 将/ 此/ 节点/ 的/ 所有/ 属性/ 值/ 分别/ 插入/ 到/ 对应/ 位置/ 的/ 链表/ 中/ ./ 然后/ 创建/ 一个/ 相同/ 大小/ 的/ 链表/ 数组/ ,/ 将/ 第/ 2/ 个/ 标识/ 代表/ 的/ 节点/ 的/ 所有/ 属性/ 分别/ 插入/ 到/ 此/ 链表/ 数组/ 中/ ./ 开始/ 比较/ 之前/ ,/ 相似/ 度/ (/ Similarity/ )/ 为/ 0/ ./ 从/ 第/ 1/ 个/ 属性/ 进行/ 比较/ ,/ 将/ 第/ 1/ 个/ 对象/ 的/ 此/ 属性/ 名内/ 的/ 所有/ 属性/ 值/ 分别/ 与/ 第/ 2/ 个/ 对象/ 的/ 此/ 属性/ 名内/ 的/ 所有/ 属性/ 值/ 进行/ 字符串/ 相似性/ (/ Similar/ )/ 比较/ ,/ 由于/ 在/ XML/ 数据/ 中/ 同一/ 属性/ 名/ 可能/ 对应/ 多个/ 不同/ 的/ 属性/ 值/ ,/ 而/ 我们/ 的/ 算法/ 认为/ 只有/ 当/ 两个/ 对象/ 在/ 同一/ 属性/ 对应/ 所有/ 属性/ 值/ 相等/ 情况/ 下/ ,/ 才能/ 达到/ 此/ 属性/ 原本/ 的/ 权值/ ,/ 若/ 只有/ 部分/ 属性/ 值/ 对应/ 相同/ ,/ 设/ 此对应/ 相同/ 的/ 属性/ 值/ 总数/ 为/ K/ ,/ 对象/ O1/ 、/ O2/ 中此/ 属性/ 名/ attri/ 下/ 的/ 属性/ 值/ 个数/ 分别/ 为/ Size/ (/ O1/ [/ attri/ ]/ )/ 、/ Size/ (/ O2/ [/ attri/ ]/ )/ ,/ 则/ 此/ 属性/ 权值/ 的/ 累加/ 值/ γ/ i/ 应为/ γ/ i/ =/ Weighti/ ×/ 若/ 两个/ 对象/ 此/ 属性/ 内/ 所有/ 值/ 都/ 不/ 相同/ ,/ 则/ 累加/ 值/ γ/ =/ 0/ ./ 将/ 所有/ h/ 个/ 属性/ 的/ 累加/ 值加/ 到/ 一起/ ,/ 便/ 可/ 得到/ 两个/ 对象/ 的/ 相似/ 度/ (/ Similarity/ )/ 若/ 两个/ 对象/ 的/ 相似/ 度/ 大于/ 我们/ 输入/ 的/ 阈值/ M/ ,/ 则/ 认为/ 它们/ 是/ 重复/ 的/ ,/ 输出/ 这/ 两个/ 对象/ ./ 该/ 算法/ 依次/ 扫描/ 所有/ 对象/ 表/ ,/ 得到/ 所有/ 描述/ 同一/ 实体/ 的/ 数据/ 对象/ 对/ ./ 例/ 3/ ./ 使用/ 该/ 算法/ 对/ 已经/ 改造/ 并/ 插入/ 到/ 属性/ 结点/ 表后/ 的/ 图/ 1/ 中/ 的/ 数据/ 集合/ 进行/ 重复/ 对象/ 检测/ 过程/ 如下/ ./ 先/ 检测/ title/ 属性/ 的/ 对象/ 表/ ,/ 发现/ O2/ 、/ O3/ 、/ O4/ 处在/ 此表中/ 的/ 同一/ 位置/ 上/ ,/ 根据/ 其/ 插入/ 的/ 唯一/ 标识/ 取出/ 这/ 3/ 个/ 结点/ ,/ 对/ O2/ 与/ O3/ 的/ 所有/ 对应/ 属性/ 进行/ 相似性/ 比较/ ,/ 得到/ 其/ 相似/ 度/ 大于/ M/ ,/ 输出/ (/ O2/ ,/ O3/ )/ ;/ 然后/ 以/ 同样/ 的/ 方法/ 比较/ O3/ 与/ O4/ 、/ O2/ 与/ O4/ ,/ 输出/ 相似/ 度/ 大于/ M/ 的/ 对象/ 对/ ./ 然后/ 检测/ author/ 属性/ 的/ 对象/ 表/ ,/ 发现/ O1/ 与/ O4/ 同时/ 出现/ 在/ 4/ 个/ 位置/ 上/ ,/ 其中/ 两个/ 位置/ 上/ 还有/ O2/ ,/ 依次/ 进行/ 各个/ 对象/ 的/ 两/ 两/ 比较/ ,/ 输出/ 相似/ 的/ 对象/ 对/ ./ 再/ 检测/ 下/ 一个/ 对象/ 表/ 直至/ 结束/ ,/ 得到/ 了/ 所有/ 的/ 相似/ 对象/ 对/ ./ 3.3/ 算法/ 分析/ 实体/ 对象/ 改造/ 与/ 插入/ 属性/ 结点/ 表/ 两步/ 可以/ 在/ 扫描/ 数据/ 一次/ 之内/ 完成/ ,/ 因此/ 在/ 预处理/ 时/ 只/ 需要/ 扫描/ 数据/ 1/ 次/ ./ 设/ 数据源/ 中/ 实体/ 结点/ 的/ 个数/ 为/ n/ 个/ ,/ 所有/ 实体/ 对象/ 共有/ g/ 个/ 不同/ 的/ 属性/ ,/ 其中/ i/ 个/ 用于/ 生成/ 属性/ 结点/ 表/ ,/ 每个/ 属性/ 结点/ 表/ 包含/ s/ 个/ 元素/ ,/ 在/ 遍历/ 属性/ 结点/ 表/ 的/ 某/ 一/ 位置/ 时/ ,/ 得到/ 的/ 候选/ 对象/ 的/ 平均/ 个数/ 为/ m/ ,/ 考虑/ 到/ 在/ 真实/ 数据/ 中/ 冗余/ 的/ 概率/ 很/ 低/ ,/ 若/ 选取/ 建立/ 属性/ 结点/ 表/ 的/ 属性/ 恰当/ 、/ Hash/ 函数/ 的/ 冲突/ 率/ 足够/ 低/ 、/ 属性/ 结点/ 表/ 的/ 尺寸/ 足够/ 大/ 的话/ ,/ 属性/ 结点/ 表中/ 的/ 很多/ 位置/ 的/ 候选/ 对象/ 数都/ 为/ 0/ 或/ 1/ ,/ 考虑/ 到/ 在/ 对象/ 数为/ 0/ 或/ 1/ 的/ 位置/ 上/ 不/ 存在/ 可以/ 比较/ 的/ 候选/ 对象/ 对/ ,/ 因此/ 计算/ 平均/ 候选/ 对象/ 时/ 只/ 考虑/ 对象/ 个数/ 大于/ 等于/ 2/ 的/ 候选/ 组/ ./ 设/ 候选/ 对象/ 数/ 大于/ 等于/ 2/ 的/ 位置/ 的/ 平均/ 数量/ 为/ q/ ,/ 故有/ iqm/ / ng/ ,/ 且/ m/ / 2/ ,/ q/ / s/ ./ 每/ 得到/ 一组/ 候选/ 对象/ ,/ 就要/ 对/ 其/ 每个/ 结点/ 的/ 所有/ 信息/ 进行/ 一次/ 扫描/ ,/ 抽取/ 出其/ 各/ 属性/ 值/ ,/ 一共/ 需要/ 访问/ iqm/ 个/ 结点/ ./ 每/ 两个/ 候选/ 结点/ 的/ 每个/ 对应/ 的/ 属性/ 之间/ 都/ 需要/ 进行/ 一次/ 比较/ 操作/ ,/ 共/ 需要/ 比较/ 的/ 次数/ 为/ giqC2m/ ./ 设/ 访问/ 一个/ 实体/ 结点/ 所/ 需要/ 的/ 平均/ 时间/ 为/ t1/ ,/ 比较/ 两个/ 属性/ 值/ 所/ 需要/ 的/ 平均/ 时间/ 为/ t2/ ,/ 则/ 整个/ 算法/ 所/ 需要/ 的/ 时间/ T/ 为/ 由此/ 可得/ 在/ 属性/ 结点/ 表/ 尺寸/ s/ 不变/ 的/ 条件/ 下/ ,/ 候选/ 对象/ 数/ 大于/ 等于/ 2/ 的/ 位置/ 数量/ 为/ q/ 越小/ 、/ 平均/ 候选/ 对象/ 数/ m/ 越小/ ,/ 我们/ 算法/ 运行/ 所/ 需要/ 的/ 时间/ 越少/ ./ 即当/ 对象/ 在/ 属性/ 结点/ 表/ 的/ 冗余度/ 越小/ ,/ 我们/ 的/ 算法/ 的/ 效率/ 越高/ ./ 由/ tqm/ / ng/ 可以/ 得到/ 此/ 算法/ 运行/ 所/ Page7/ 需要/ 的/ 最大/ 时间/ 为/ TMAX/ =/ nt1/ +/ ngt1/ +/ n2g3/ 当/ 结点/ 属性/ 表中/ 所有/ 位置/ 均/ 为/ 0/ 或/ 1/ ,/ 即/ 没有/ 冗余/ 或/ 冗余/ 很少/ 时/ q/ =/ 0/ ,/ 此时/ 达到/ 算法/ 的/ 最高/ 效率/ ,/ 代入/ 式/ (/ 1/ )/ 得到/ 算法/ 运行/ 所/ 需要/ 的/ 最小/ 时间/ 为/ TMIN/ =/ nti/ ./ 考虑/ 到/ 真实/ 数据/ 中/ 冗余/ 通常/ 较/ 低/ ,/ 插入/ 到/ 属性/ 结点/ 表后/ 候选/ 对象/ 大于/ 等于/ 2/ 的/ 位置/ 较少且/ 平均/ 候选/ 对象/ 很少/ ,/ 因而/ 我们/ 的/ 算法/ 在/ 大多数/ 情况/ 下/ 效率/ 较/ 高/ ,/ 算法/ 时间/ 复杂度/ 是/ O/ (/ n/ )/ ./ 4MaxMerge/ 算法/ 重复/ 对象/ 检测/ 工作/ 完成/ 以后/ ,/ 我们/ 只/ 输出/ 了/ 两/ 两/ 重复/ 的/ 实体/ 对象/ 对/ ,/ 而/ 我们/ 希望/ 得到/ 的/ 结果/ 是/ 元素/ 的/ 聚类/ ,/ 每/ 一类/ 中/ 的/ 元素/ 描述/ 同一/ 实体/ ,/ 因此/ 我们/ 需要/ 对/ 重复/ 对象/ 检测/ 工作/ 输出/ 的/ 结果/ 进行/ 合并/ ,/ 让/ 所有/ 相似/ 的/ 元素/ 聚类/ 到/ 一起/ ./ 为了/ 实现/ 快速/ 地/ 合并/ ,/ 我们/ 提出/ 了/ MaxMerge/ 算法/ ,/ 它/ 兼顾/ 了/ 各个/ 实体/ 对象/ 之间/ 相似/ 的/ 传递性/ 与/ 独立性/ ,/ 是/ 一种/ 快速/ 有效/ 的/ 聚类/ 方法/ ./ 4.1/ MaxMerge/ 算法/ 模型/ 在/ 该/ 算法/ 中/ ,/ 我们/ 首先/ 用/ 一个/ 实体/ 对象/ 信息/ 表/ (/ infoBook/ )/ 来/ 记录/ 所有/ 实体/ 对象/ 的/ 基本/ 信息/ (/ info/ )/ ./ 根据/ 对象/ 的/ 唯一/ 标识/ 可以/ 得到/ 其/ 在/ 对象/ 信息/ 表中/ 的/ 位置/ (/ position/ )/ ,/ 如/ 对象/ a246/ 的/ 信息/ 应当/ 插入/ 到/ 实体/ 对象/ 信息/ 表中/ 的/ 第/ 246/ 的/ 位置/ 上/ ./ 所/ 需要/ 插入/ 的/ 对象/ 信息/ 如下/ 图/ 所示/ ,/ 其中/ 含有/ 对象/ 的/ 名字/ (/ name/ )/ 、/ 对象/ 是否/ 已经/ 出现/ 过/ (/ show/ )/ ,/ 对象/ 被/ 归并到/ 的/ 所有/ 的/ 聚类/ 的/ 编号/ (/ clusterNO/ )/ ,/ 及其/ 在/ 此/ 聚类/ 中/ 出现/ 的/ 次数/ (/ time/ )/ ,/ 聚类/ 的/ 编号/ 与其/ 出现/ 的/ 次数/ 合/ 称为/ 聚类/ 信息/ ClusterInfo/ ./ 当/ 算法/ 扫描/ 到/ 一个二元/ 组/ 的/ 实体/ 对象/ (/ a/ ,/ b/ )/ 时/ ,/ 首先/ 判断/ 它们/ 是否/ 已经/ 出现/ 过/ ./ 若/ 两个/ 对象/ 都/ 未/ 出现/ 过/ ,/ 我们/ 新建/ 一个/ 聚类/ ,/ 并/ 把/ 此/ 聚类/ 的/ 编号/ 存入/ 两个/ 对象/ 的/ 信息/ 当中/ ,/ 此聚类/ 出现/ 的/ 次数/ 都/ 为/ 1/ ,/ 两个/ 对象/ 是否/ 出现/ 过/ 的/ 标记/ 改为/ true/ ;/ 若/ 两个/ 对象/ 中/ 只有/ 一个/ 出现/ 过/ ,/ 那么/ 取出/ 出现/ 过/ 的/ 对象/ 中/ 出现/ 次数/ 最多/ 的/ 聚类/ 编号/ ,/ 然后/ 把/ 它/ 存到/ 未/ 出现/ 过/ 的/ 对象/ 的/ 信息/ 中/ ,/ 设置/ 其/ 次数/ 为/ 1/ ,/ 把/ 它/ 的/ 标记/ 改为/ true/ ;/ 若/ 两个/ 对象/ 都/ 出现/ 过/ ,/ 则/ 检测/ 这/ 两个/ 对象/ 中/ 的/ 聚类/ 编号/ 中/ 是否/ 有/ 重复/ ,/ 如/ 有/ 重复/ ,/ 则/ 增加/ 此/ 重复/ 的/ 聚类/ 编号/ 次数/ ,/ 如果/ 没有/ 重复/ 的/ ,/ 那么/ 把/ 两个/ 对象/ 中/ 各自/ 出现/ 次数/ 最多/ 的/ 聚类/ 编号/ 增加/ 到/ 对方/ 信息/ 中/ ,/ 并/ 设置/ 其/ 次数/ 为/ 1/ ./ 在/ 扫描/ 完/ 所有/ 二元/ 组/ 的/ 实体/ 对象/ 后/ ,/ 新建/ 一个/ 聚类表/ ,/ 开始/ 遍历/ 每个/ 实体/ 对象/ 的/ 信息/ ,/ 将/ 对象/ 插入/ 到/ 聚类/ 表中/ 自己/ 所有/ 聚类/ 编号/ 中/ 出现/ 次数/ 最多/ 的/ 编号/ 的/ 位置/ 上/ ./ 在/ 插入/ 聚类表/ 完成/ 后/ ,/ 输出/ 整个/ 聚类表/ 作为/ 聚类/ 结果/ ./ 算法/ 3/ ./ MaxMerge/ 算法/ ./ 输入/ :/ 所有/ 相似/ 对象/ 二元/ 组/ 输出/ :/ 聚类/ 结果/ 1/ ./ whileapairofobjects2/ ./ getnumsandnamesfromobjects/ ;/ 3/ ./ ifneithershowedthen4/ ./ addnewclustertoitem1anditem2/ ;/ 5/ ./ makebothofthemshowed/ ;/ 6/ ./ elseifjustoneshowedthen7/ ./ addthemaxClusteroftheshowedtotheunshowed/ ;/ 8/ ./ maketheunshowedshowed/ ;/ 9/ ./ elseifbothofthemhaveasameclusterthen10/ ./ thetimeofthesamecluster/ ++/ ;/ 11/ ./ else12/ ./ addthemaxClustertoeachother/ ;/ 13/ ./ endif/ ;/ 14/ ./ endwhile/ ;/ 15/ ./ whiletraversetheinfo/ _/ book16/ ./ ifnameBook/ [/ i/ ]/ showedthen17/ ./ maxCluster/ =/ theMaxClusterofitem/ ;/ 18/ ./ addthenametocluster/ _/ table/ [/ maxCluster/ ]/ ;/ 19/ ./ endif/ ;/ 20/ ./ endwhile/ ;/ 4.2/ MaxMerge/ 算法/ 分析/ 文献/ [/ 4/ ]/ 中/ 使用/ 了/ 传递/ 闭包/ 的/ 方法/ 来/ 进行/ 重复/ 元素/ 对/ 的/ 聚类/ ,/ 它/ 仅仅/ 考虑/ 到/ 了/ 相似/ 的/ 传递性/ ,/ 如果/ 元素/ 1/ 与/ 元素/ 2/ 、/ 元素/ 2/ 与/ 元素/ 3/ 重复/ ,/ 那么/ 元素/ 1/ 与/ 元素/ 3/ 必/ 重复/ ./ 但是/ 这种/ 方法/ 忽略/ 了/ 各/ 相似/ 对/ 的/ 判断/ 是/ 独立/ 的/ ,/ 并且/ 有/ 可能/ 由于/ 一个/ 相似/ 的/ 元素/ 对/ ,/ 而/ 导致/ 两个/ 指向/ 不同/ 实体/ 的/ 元素/ 聚/ 类聚/ 到/ 一起/ ./ 当/ 重复/ 的/ 元素/ 规模/ 增大/ 时/ ,/ 会/ 导致/ 重复/ 检测/ 方法/ 的/ 精确/ 率变/ 低/ ./ 在/ MaxMerge/ 算法/ 中/ ,/ 同时/ 兼顾/ 了/ 相似/ 的/ 传递性/ 与/ 独立性/ ,/ 主要/ 体现/ 在/ 如下/ 两个/ 方面/ :/ 元素/ 由于/ 相似/ 次数/ 的/ 增加/ 而/ 不断/ 增加/ 自己/ 某个/ 聚类/ 编号/ 的/ 出现/ 次数/ ,/ 一个/ 元素/ 必然/ 与/ 自己/ 所属/ 聚类/ 中/ 的/ 多个/ 元素/ 相似/ ,/ 而/ 这些/ 相似/ 的/ 元素/ 会/ 不断/ 增加/ 此/ 元素/ 中/ 相应/ Page8/ 的/ 聚类/ 编号/ 出现/ 的/ 次数/ ,/ 这是/ MaxMerge/ 算法/ 中/ 传递性/ 的/ 体现/ ;/ 而/ 最后/ 把/ 元素/ 分别/ 插入/ 到/ 各个/ 聚类/ 中时/ ,/ 仅/ 考虑/ 它/ 的/ 所有/ 聚类/ 编号/ 当中/ 出现/ 次数/ 最多/ 的/ 那个/ ,/ 对于/ 元素/ 中/ 出现/ 次数/ 不多/ 的/ 聚类/ 编号/ 直接/ 忽略/ ,/ 把/ 元素/ 放到/ 自己/ 最/ 可能/ 所属/ 的/ 聚类/ 中/ ,/ 这是/ MaxMerge/ 算法/ 中/ 独立性/ 的/ 体现/ ./ 在/ 文献/ [/ 4/ ]/ 中/ 的/ 传递/ 闭包/ 方法/ 中/ ,/ 当/ 检测/ 到/ 两个/ 元素/ 重复/ 时/ ,/ 就/ 需要/ 将/ 所有/ 之前/ 与/ 这/ 两个/ 元素/ 重复/ 的/ 元素/ 聚类/ ,/ 所以/ 检测/ 是/ 非线性/ 的/ ,/ 而/ 在/ MaxMerge/ 算法/ 中/ ,/ 当/ 检测/ 到/ 两个/ 元素/ 重复/ 时/ ,/ 只/ 对/ 两个/ 元素/ 的/ 结构/ 信息/ 进行/ 改变/ ,/ 无需/ 修改/ 之前/ 与/ 它们/ 重复/ 的/ 元素/ ,/ 因此/ 检测/ 过程/ 是/ 线性/ 的/ ./ 因此/ MaxMerge/ 算法/ 运行/ 所/ 需要/ 的/ 时间/ 仅为/ 扫描/ 一次/ 二元/ 组/ 文件/ 与/ 扫描/ 一次/ 内存/ 中/ 对象/ 信息/ 表所/ 需要/ 的/ 时间/ ./ 5/ 实验/ 验证/ 本文/ 所/ 提出/ 的/ 基于/ 实体/ 描述/ 属性/ 技术/ 的/ 算法/ 可/ 快速/ 地/ 找到/ 可能/ 相似/ 的/ 候选/ 对象/ ,/ 然后/ 再/ 在/ 候选/ 对象/ 中/ 进行/ 任意/ 一种/ 核心/ 的/ 实体/ 识别/ 算法/ 即可/ ./ 本/ 实验/ 内/ 采用/ 的/ 核心/ 实体/ 识别/ 算法/ 为/ 一般/ 的/ 基于/ 规则/ 的/ 实体/ 识别/ 算法/ ./ 为了/ 验证/ 本/ 算法/ 的/ 有效性/ 并/ 测试/ 影响/ 效率/ 的/ 主要/ 因素/ ,/ 我们/ 进行/ 了/ 大量/ 的/ 实验/ ,/ 并/ 对/ 实验/ 结果/ 进行/ 相关/ 的/ 分析/ ./ 为了/ 验证/ MaxMerge/ 算法/ 的/ 运行/ 效率/ ,/ 还/ 进行/ 了/ 一系列/ 的/ 对比/ 实验/ ./ 实验/ 采用/ 的/ 硬件/ 环境/ 为/ IntelPentium4CPU/ ,/ 内存/ 1GHz/ ,/ 操作系统/ 为/ WindowsXP/ ,/ 系统/ 代码/ 用/ Java/ 实现/ ,/ 软件开发/ 环境/ 为/ Eclipse3/ ./ 4.1/ ./ 5.1/ 算法/ 效率/ 实验/ 在/ 本/ 实验/ 中/ ,/ 我们/ 利用/ 数据/ 生成/ 系统生成/ 6/ 个/ 含有/ 不同/ 数量/ 实体/ 对象/ 的/ XML/ 数据/ 集合/ ./ 前/ 3/ 个/ 数据/ 集合/ 分别/ 为/ ,/ S1/ 含有/ 4k/ 实体/ 对象/ ,/ S2/ 含有/ 8k/ 实体/ 对象/ ,/ S3/ 含有/ 16k/ 实体/ 对象/ ,/ 这/ 3/ 个/ 数据/ 集合/ 中/ 冗余/ 程度/ 相近/ 且/ 适中/ ./ S4/ 、/ S5/ 、/ S6/ 也/ 分别/ 含有/ 4k/ 、/ 8k/ 、/ 16k/ 个/ 实体/ 对象/ ,/ 但/ 数据/ 中/ 的/ 冗余/ 程度/ 较/ 低/ ./ 数据/ 集合/ 中/ 的/ 每个/ 实体/ 对象/ 的/ 结构/ 中/ 不/ 存在/ 孙级/ 以下/ 的/ 结点/ ./ 子级/ 、/ 孙级/ 结点/ 共/ 由/ 8/ ~/ 11/ 个/ 属性/ 组成/ ,/ 这些/ 属性/ 或/ 以/ 结点/ 属性/ 的/ 形式/ 给出/ ,/ 或/ 以/ 结点/ 的/ 子/ 、/ 孙/ 结点/ 的/ 形式/ 给出/ ,/ 其中/ cluster/ 属性/ 的/ 值/ 代表/ 其实/ 体/ 对象/ 真实/ 归属/ 的/ 聚类/ ,/ 不/ 参与/ 重复/ 对象/ 检测/ 过程/ ,/ 但/ 用于/ 统计/ 精确/ 率/ 与/ 召回/ 率/ ./ 其它/ 7/ ~/ 10/ 个/ 属性/ 用来/ 参与/ 实体/ 对象/ 的/ 重复/ 对象/ 检测/ ,/ 每个/ 属性/ 由/ 6/ ~/ 12/ 个/ 英文字母/ 组成/ ,/ 如图/ 8/ 中/ 的/ 两个/ 对象/ 结点/ ./ 〈/ bookcluster/ =/ "/ 11/ "/ 〉/ 我们/ 的/ 算法/ 运行/ 于/ 4k/ 、/ 8k/ 、/ 16k/ 个/ 结点/ 的/ 数据/ 集合/ 上/ 进行/ 重复/ 对象/ 检查/ 时/ ,/ 所/ 需要/ 的/ 时间/ 如图/ 9/ 所示/ ,/ 分别/ 为/ 2.58/ min/ 、/ 11.54/ min/ 、/ 61.55/ min/ ./ 可见/ ,/ 当/ 数据/ 中/ 冗余/ 的/ 对象/ 比率/ 大致相同/ 时/ ,/ 数据/ 集合/ 的/ 尺寸/ 增大/ ,/ 重复/ 检测/ 所/ 需要/ 的/ 时间/ 显著/ 增加/ ./ 运行/ 结果/ 如图/ 10/ 所示/ ,/ 精确/ 率/ 都/ 接近/ 100/ %/ ,/ 召回/ 率/ 也/ 都/ 在/ 90/ %/ 以上/ ,/ 这/ 验证/ 了/ 算法/ 的/ 有效性/ ./ Page9/ 由图/ 11/ 可得/ ,/ 当/ 数据/ 的/ 冗余度/ 较/ 低时/ ,/ 处理/ 数据/ 所/ 需要/ 的/ 时间/ 显著/ 减少/ ./ 并且/ 在/ 低/ 冗余度/ 时/ ,/ 当/ 处理/ 的/ 数据量/ 为/ 原来/ 的/ 2/ 倍/ 时/ ,/ 所/ 需要/ 的/ 时间/ 呈/ 线性/ 增长/ ./ 由此/ 可/ 得/ ,/ 算法/ 在/ 低/ 冗余/ 时/ 的/ 时间/ 复杂度/ 小于/ O/ (/ n2/ )/ ,/ 接近/ O/ (/ n/ )/ ,/ 这/ 验证/ 了/ 我们/ 之前/ 对/ 算法/ 的/ 高效性/ 分析/ ./ 5.2/ 数据/ 冗余/ 程度/ 的/ 影响/ 为了/ 测试数据/ 冗余/ 程度/ 对/ 算法/ 的/ 影响/ ,/ 我们/ 生成/ 了/ 10/ 个/ 数据/ 集合/ ,/ 其中/ 每个/ 数据/ 集合/ 都/ 含有/ 4096/ 个/ 对象/ ,/ 每个/ 数据/ 集合/ 中/ 指向/ 相同/ 实体/ 的/ 对象/ 的/ 集合/ 叫做/ 一个/ 聚类/ ,/ 数据/ 集合/ D1/ 中/ 的/ 所有/ 实体/ 对象/ 共/ 可以/ 划分/ 为/ 100/ 个/ 聚类/ ,/ D2/ 可/ 划分/ 为/ 200/ 个/ 聚类/ ,/ 依次/ 类推/ ,/ D10/ 可/ 划分/ 为/ 1000/ 个/ 聚类/ ,/ 并且/ 在/ 数据/ 集合/ 当中/ 所有/ 的/ 实体/ 对象/ 平均分配/ 到/ 各个/ 聚类/ 当中/ ./ 算法/ 在/ 冗余/ 程度/ 不同/ 的/ 数据/ 集合/ 当中/ 的/ 运行/ 效率/ 如图/ 12/ 所示/ ./ 可以/ 看出/ ,/ 算法/ 在/ 运行/ 10/ 个/ 冗余/ 程度/ 不同/ 但/ 实体/ 对象/ 总数/ 同为/ 4k/ 的/ 数据/ 集合/ 时/ ,/ 聚类/ 数量/ 最少/ 的/ D1/ 所/ 需要/ 运行/ 的/ 时间/ 最/ 多/ ,/ 其它/ 数据/ 集合/ 所/ 需要/ 运行/ 的/ 时间/ 随着/ 聚类/ 数量/ 的/ 增多/ 而/ 减少/ ./ 由于/ 在/ 数据/ 集合/ 当中/ 所有/ 的/ 实体/ 对象/ 是/ 平均分配/ 到/ 各个/ 聚类/ 当中/ 的/ ,/ 在/ 实体/ 对象/ 总数/ 不变/ 的/ 前提/ 下/ ,/ 聚类/ 数量/ 越/ 多/ ,/ 算法/ 的/ 冗余度/ 越低/ ./ 所以/ 可以/ 得/ 数据/ 集合/ 中/ 的/ 实体/ 对象/ 的/ 冗余/ 程度/ 越低/ ,/ 算法/ 的/ 运行/ 效率/ 越高/ ./ 这/ 也/ 验证/ 了/ 我们/ 之前/ 对/ 算法/ 进行/ 的/ 分析/ ./ 图/ 13/ 是/ 算法/ 在/ 冗余/ 程度/ 不同/ 的/ 数据/ 集合/ 当中/ 运行/ 后/ 的/ 精确/ 率/ 与/ 召回/ 率/ ./ 易/ 看出/ ,/ 算法/ 的/ 精确/ 率/ 一直/ 稳定/ 在/ 将近/ 100/ %/ ,/ 而/ 召回/ 率/ 也/ 一直/ 浮动/ 于/ 80/ %/ 以上/ ,/ 召回/ 率/ 的/ 浮动/ 与/ 数据/ 集合/ 中/ 数据/ 本身/ 有关/ ./ 召回/ 率/ 与/ 精确/ 率/ 都/ 很/ 高/ ,/ 这/ 验证/ 了/ 算法/ 的/ 有效性/ ./ 5.3/ 数据/ 的/ 结构/ 复杂度/ 的/ 影响/ 我们/ 所/ 测试/ 的/ 是/ 3/ 个/ 除/ 平均/ 深度/ 不同/ 外/ ,/ 叶/ 结点/ 与/ 属性/ 结点/ 互相/ 完全相同/ 的/ 含有/ 4k/ 个/ 结点/ 的/ 数据/ 集合/ ./ 也就是说/ 这/ 3/ 个/ 数据/ 集合/ S1/ 、/ S2/ 、/ S3/ 只是/ 从/ 对象/ 结点/ 到/ 叶/ 结点/ 的/ 路径/ 长度/ 不同/ ,/ 其中/ S1/ 、/ S2/ 、/ S3/ 到/ 叶/ 结点/ 的/ 平均/ 路径/ 长度/ 分别/ 为/ 1/ 、/ 10/ 、/ 20/ ./ 由图/ 14/ 可以/ 看出/ ,/ 当/ 实体/ 对象/ 的/ 结构/ 变得复杂/ 时/ ,/ 算法/ 运行/ 的/ 时间/ 明显/ 增多/ ,/ 这/ 表明/ 算法/ 执行/ 过程/ 中/ 的/ 相当/ 大/ 的/ 一部分/ 时间/ 被/ 用来/ 遍历/ 描述/ 实体/ 的/ 结点/ 与/ 属性/ ,/ 对于/ 结构/ 越/ 简单/ 的/ 实体/ ,/ 算法/ 的/ 执行/ 效率/ 越高/ ./ 5.4/ MaxMerge/ 算法/ 的/ 对比/ 实验/ 表/ 2/ 是/ MaxMerge/ 算法/ 与/ 文献/ [/ 4/ ]/ 中/ 的/ 传递/ 闭/ Page10/ 包/ 算法/ 的/ 对比/ 实验/ 结果/ ./ 分别/ 使用/ 两个/ 算法/ 处理/ 数据/ 总量/ 为/ 1k/ 、/ 2k/ 、/ 4k/ 的/ 数据/ 集合/ ,/ 得到/ 的/ 结果/ 如下/ ./ 容易/ 看出/ ,/ MaxMerge/ 算法/ 所/ 需要/ 的/ 时间/ 都/ 略低于/ 传递/ 闭包/ 方法/ ,/ 并且/ 精确/ 率/ 与/ 召回/ 率/ 都/ 有/ 显著/ 的/ 差距/ ./ 由于/ 兼顾/ 了/ 相似/ 的/ 传递性/ 与/ 独立性/ ,/ MaxMerge/ 算法/ 是/ 一种/ 高效/ 且/ 有效/ 的/ 方法/ ./ 时间/ // s/ 精确/ 率/ 召回/ 率/ 数据量/ 1K0/ ./ 28110.945730/ ./ 3280.851100/ ./ 699942K0/ ./ 47110.902210/ ./ 4730.717010/ ./ 485104K0/ ./ 62010.946140/ ./ 6310.833030/ ./ 69661/ 实验/ 结果/ 总结/ :/ 本文/ 提出/ 的/ 算法/ 在/ XML/ 数据/ 集合/ 当中/ 可以/ 快速/ 有效/ 地/ 检测/ 重复/ 实体/ ,/ 且/ 当/ 数据/ 集合/ 中/ 冗余/ 的/ 程度/ 很/ 低时/ ,/ 算法/ 的/ 时间/ 复杂度/ 接近/ 于/ O/ (/ n/ )/ ./ 算法/ 运行/ 中/ 的/ 大部分/ 时间/ 被/ 用来/ 遍历/ 对象/ 的/ 结点/ 与/ 属性/ ,/ 当/ 描述/ 实体/ 的/ XML/ 对象/ 的/ 数据结构/ 很/ 简单/ 时/ ,/ 算法/ 的/ 运行/ 效率/ 会/ 很/ 高/ ./ 用于/ 对/ 重复/ 的/ 数据/ 对象/ 进行/ 聚类/ 的/ MaxMerge/ 算法/ ,/ 由于/ 其/ 扫描/ 时/ 是/ 线性/ 的/ ,/ 所/ 花费/ 的/ 时间/ 要略/ 小于/ 传递/ 闭包/ 方法/ ./ 由于/ 其/ 兼顾/ 了/ 相似/ 的/ 传递性/ 与/ 独立性/ ,/ 其/ 精确/ 率/ 与/ 召回/ 率/ 都/ 显著/ 的/ 优于/ 传递/ 闭包/ 方法/ ,/ 是/ 一种/ 高效/ 精确/ 的/ 聚类/ 方法/ ./ 6/ 结论/ 本文/ 提出/ 的/ 使用/ 实体/ 描述/ 属性/ 的/ XML/ 数据/ 对象/ 实体/ 识别方法/ ,/ 通过/ 使用/ 属性/ 结点/ 表/ 快速/ 定位/ 在/ 某个/ 属性/ 上/ 相同/ 的/ 实体/ 对象/ ,/ 大大减少/ 了/ 所/ 需要/ 的/ 比较/ 次数/ ,/ 再/ 通过/ 使用/ MaxMerge/ 算法/ 对/ 输出/ 的/ 重复/ 对象/ 二元/ 组/ 进行/ 聚类/ ,/ 同时/ 考虑/ 了/ 相似/ 的/ 传递性/ 与/ 独立性/ ,/ 显著/ 提升/ 了/ 算法/ 的/ 精确/ 率/ 与/ 召回/ 率/ ./ 大量/ 的/ 实验/ 验证/ 了/ 我们/ 的/ 方法/ 是/ 高效/ 且/ 有效/ 的/ ./ WANGHong/ -/ Zhi/ ,/ bornin1978/ ,/ associateprofessor/ ,/ Ph/ ./ D/ ../ Hisresearchinterestsincludedataquality/ ,/ XML/ 

