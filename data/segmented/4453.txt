Page1/ 软件/ 安全漏洞/ 检测/ 技术/ 李舟军/ 1/ )/ 张俊贤/ 1/ )/ 廖湘科/ 2/ )/ 马金鑫/ 1/ )/ 1/ )/ (/ 北京航空航天大学/ 计算机/ 学院/ 北京/ 100191/ )/ 2/ )/ (/ 国防科学技术大学/ 计算机/ 学院/ 长沙/ 410073/ )/ 摘要/ 软件/ 安全漏洞/ 检测/ 技术/ 是/ 提高/ 软件/ 质量/ 和/ 安全性/ 、/ 减少/ 软件/ 安全漏洞/ 的/ 重要/ 方法/ 和/ 基本/ 手段/ ,/ 受到/ 学术界/ 和/ 工业界/ 的/ 广泛/ 关注/ 和/ 高度重视/ ./ 其/ 主要/ 途径/ 包括/ 软件测试/ 、/ 程序/ 分析/ 、/ 模型/ 检验/ 与/ 符号执行/ 等/ ./ 近年来/ ,/ 综合利用/ 多种/ 研究/ 方法/ 和/ 技术手段/ 来/ 检测/ 软件/ 安全漏洞/ 已/ 成为/ 软件/ 安全/ 领域/ 的/ 研究/ 热点/ ./ 文中/ 首先/ 回顾/ 了/ 程序/ 分析/ 与/ 软件/ 安全漏洞/ 检测/ 的/ 基本概念/ 、/ 核心/ 问题/ 和/ 传统/ 手段/ ./ 然后/ 重点/ 介绍/ 该/ 领域/ 的/ 最新进展/ ,/ 主要/ 包括/ 轻量级/ 动态/ 符号执行/ 、/ 自动化/ 白盒/ 模糊/ 测试/ 以及/ 其/ 实现/ 技术/ 和/ 相应/ 的/ 工具/ ./ 最后/ ,/ 指出/ 了/ 其/ 所/ 面临/ 的/ 挑战/ 和/ 发展趋势/ ./ 关键词/ 安全漏洞/ ;/ 静态/ 分析/ ;/ 动态分析/ ;/ 符号执行/ ;/ 白盒/ 测试/ 1/ 引言/ 软件/ 质量/ 是/ 软件产品/ 的/ 生命线/ ,/ 由于/ 不合理/ 的/ Page2/ 重时/ 甚至/ 危及/ 人们/ 的/ 生命安全/ ./ 由于/ 某些/ 特定/ 程序/ 缺陷/ 的/ 存在/ ,/ 计算机程序/ 在/ 运行/ 时刻/ 会/ 出现/ 一些/ 设计/ 时非/ 预期/ 的/ 行为/ ,/ 其/ 非但/ 不能/ 完成/ 预期/ 的/ 功能/ ,/ 反而/ 会/ 出现/ 意料之外/ 的/ 执行/ 状况/ ./ 这种/ 预期/ 之外/ 的/ 程序/ 行为/ 轻则/ 会/ 损害/ 程序/ 的/ 预期/ 功能/ ,/ 重则/ 会/ 导致/ 程序/ 崩溃/ ,/ 使/ 其/ 不能/ 正常/ 运行/ ./ 更为严重/ 的/ 情况/ 下/ ,/ 与/ 安全/ 相关/ 的/ 程序/ 缺陷/ 可以/ 被/ 恶意程序/ 利用/ ,/ 使/ 程序/ 宿主/ 机器/ 受到/ 侵害/ ./ 前/ 两种/ 情况/ 还/ 只是/ 损害/ 程序/ 本身/ 的/ 质量/ 和/ 可靠性/ ,/ 后者/ 却/ 可能/ 致使/ 系统/ 被/ 黑客程序/ 控制/ ,/ 以至于/ 泄露/ 与/ 程序/ 本身/ 完全/ 无关/ 的/ 信息/ ,/ 如/ 银行账号/ 等/ 私密/ 数据/ ./ 我们/ 把/ 这种/ 导致/ 软件系统/ 出现/ 安全性/ 问题/ 的/ 缺陷/ 称为/ 软件/ 的/ 安全漏洞/ ./ 安全漏洞/ 检测/ 技术/ 是/ 提高/ 软件/ 质量/ 和/ 安全性/ 、/ 减少/ 软件/ 安全漏洞/ 的/ 重要/ 方法/ 和/ 基本/ 手段/ ,/ 受到/ 学术界/ 和/ 工业界/ 的/ 广泛/ 关注/ 和/ 高度重视/ ./ 为此/ ,/ 学术界/ 和/ 工业界/ 投入/ 了/ 大量/ 人力/ 和/ 科研经费/ ,/ 从/ 不同/ 角度/ 提出/ 各种/ 检测/ 方法/ 和/ 技术/ ,/ 并/ 开发/ 了/ 相应/ 的/ 检测工具/ ./ 随着/ 对/ 问题/ 研究/ 的/ 深入/ ,/ 新/ 的/ 方法/ 、/ 技术/ 和/ 工具/ 不断/ 出现/ ,/ 一种/ 发展趋势/ 是/ 结合/ 多种/ 方法/ 、/ 综合利用/ 诸多/ 新/ 出现/ 的/ 技术/ 进行/ 软件/ 安全漏洞/ 检测/ ./ 本文/ 首先/ 回顾/ 了/ 程序/ 分析/ 与/ 软件/ 漏洞/ 检测/ 的/ 基本概念/ 、/ 核心/ 问题/ 和/ 传统/ 手段/ ,/ 然后/ 重点/ 介绍/ 该/ 领域/ 的/ 最新进展/ ,/ 主要/ 包括/ 轻量级/ 动态/ 符号执行/ 、/ 自动化/ 白盒/ 模糊/ 测试/ 以及/ 其/ 实现/ 技术/ 和/ 相应/ 的/ 工具/ ./ 最后/ ,/ 指出/ 了/ 其/ 所/ 面临/ 的/ 挑战/ 和/ 发展趋势/ ./ 2/ 问题/ 陈述/ 计算机/ 程序代码/ 是/ 符合/ 程序设计/ 语言/ 文法/ 规则/ 的/ 有/ 穷/ 长度/ 字符串/ ,/ 它/ 以/ 文本/ 形式/ 描述/ 程序运行/ 时/ 预期/ 出现/ 的/ 一系列/ 计算/ 行为/ ./ 计算机程序/ 总是/ 在/ 特定/ 环境/ 下/ 执行/ ,/ 这个/ 环境/ 包括/ 程序/ 输入/ 、/ 内存/ 状态/ 、/ 系统配置/ 等等/ ,/ 由于/ 执行/ 环境/ 的/ 易变性/ ,/ 程序/ 每次/ 执行/ 过程/ 中/ 出现/ 的/ 行为/ 及其/ 顺序/ 通常/ 并/ 不/ 完全相同/ ,/ 所有/ 可能/ 出现/ 的/ 程序/ 行为/ 和/ 可能/ 达到/ 的/ 程序/ 状态/ 构成/ 计算机程序/ 的/ 语义/ 域/ ./ 早期/ 的/ 研究/ 更/ 多/ 集中/ 于/ 如何/ 确保/ 程序实现/ 了/ 预期/ 的/ 功能/ ,/ 即/ 程序正确性/ 问题/ ,/ 并/ 在/ 这个/ 领域/ 取得/ 了/ 许多/ 重要/ 的/ 理论/ 成果/ ,/ 如/ 程序正确性/ 证明/ 等/ ./ 比/ 程序正确性/ 弱/ 一点/ 的/ 问题/ ,/ 则/ 是/ 关注/ 如何/ 确保/ 程序/ 在/ 任意/ 执行/ 环境/ 中/ 不会/ 出现/ 损害/ 程序/ 和/ 系统安全/ 的/ 行为/ ,/ 如除/ 零/ 错误/ 和/ 溢出/ 错误/ 等/ ,/ 解决/ 这些/ 问题/ 的/ 关键在于/ 如何/ 定性/ 和/ 定量/ 地/ 描述/ 软件/ 的/ 行为/ 并/ 刻画/ 其/ 语义/ 性质/ ,/ 这是/ 软件/ 理论/ 的/ 基本/ 问题/ 之一/ ./ 软件/ 的/ 静态/ 语法/ 与其/ 动态/ 语义/ 的/ 分离/ 是/ 造成/ 软件/ 行为/ 难以描述/ 和/ 推理/ 的/ 根本原因/ [/ 2/ ]/ ./ 为/ 描述/ 计算机程序/ 的/ 行为/ 并/ 研究/ 其/ 语义/ 性质/ ,/ 研究者/ 提出/ 了/ 多种不同/ 的/ 语义/ 模型/ ,/ 并/ 发展/ 为/ 一个/ 专门/ 的/ 研究/ 领域/ ,/ 其中/ 被/ 使用/ 最多/ 的/ 有/ 操作/ 语义/ 、/ 指称/ 语义/ 和/ 公理/ 语义/ 等/ ./ 以/ 某种/ 特定/ 的/ 程序/ 语义/ 性质/ 描述/ 方式/ 为/ 前提/ ,/ 安全漏洞/ 检测/ 问题/ 可以/ 重新/ 描述/ 为/ :/ 给定/ 程序/ 和/ 需要/ 检测/ 的/ 安全/ 性质/ ,/ 设计/ 算法/ 能够/ 回答/ :/ 程序/ 中/ 所有/ 可能/ 出现/ 的/ 行为/ 和/ 状态/ 是否/ 都/ 满足/ 待/ 检验/ 的/ 安全/ 性质/ ,/ 若/ 程序/ 在/ 某次/ 执行/ 过程/ 中/ 存在/ 违反/ 该/ 安全/ 性质/ 的/ 行为/ ,/ 则/ 说明/ 存在/ 相应/ 的/ 安全漏洞/ ./ 3/ 理论/ 和/ 方法/ 判断/ 程序/ 是否/ 满足/ 某种/ 安全/ 性质/ 是/ 一个/ 逻辑/ 命题/ ,/ 程序正确性/ 证明/ 一般/ 使用/ Hoare/ 逻辑/ [/ 3/ -/ 4/ ]/ 等/ 公理/ 系统/ 从/ 语法/ 推导/ 的/ 角度/ 证明/ 程序/ 的/ 公理/ 语义/ 是否/ 满足/ 待/ 检验/ 的/ 安全/ 性质/ ;/ 模型/ 检验/ 则/ 使用/ 有穷/ 自动机/ 表示/ 程序/ 的/ 状态/ 迁移/ 系统/ ,/ 并/ 从/ 语义/ 的/ 角度/ 验证/ 所/ 建立/ 的/ 状态/ 迁移/ 系统/ 是否/ 为/ 待/ 检验/ 性质/ 的/ 一个/ 模型/ ./ 基于/ 程序正确性/ 证明/ 方法/ 开发/ 的/ 工具/ 通常/ 需要/ 事先/ 给出/ 程序/ 的/ 安全性/ 规约/ ,/ 是/ 一件/ 费时费力/ 的/ 事情/ ;/ 另一方面/ ,/ 模型/ 检验/ 只能/ 应用/ 于/ 有/ 穷/ 状态/ 系统/ ,/ 且/ 存在/ 状态/ 爆炸/ 问题/ ./ 程序/ 分析/ 是/ 指/ ,/ 对/ 软件/ 进行/ 人工/ 或者/ 自动/ 分析/ ,/ 以/ 验证/ 、/ 确认/ 或/ 发现/ 软件/ 性质/ (/ 或者/ 规约/ 、/ 约束/ )/ 的/ 过程/ 或/ 活动/ [/ 5/ ]/ ./ 将/ 程序/ 分析/ 的/ 方法/ 应用/ 于/ 软件/ 安全性/ 检测/ ,/ 可/ 有效/ 发现/ 和/ 检测/ 软件/ 中/ 存在/ 的/ 安全/ 缺陷/ 或/ 漏洞/ ./ 1953/ 年/ HenryRice/ [/ 3/ ]/ 证明/ ,/ 在/ 普遍意义/ 上/ ,/ 程序/ 分析/ 不/ 可能/ 完全/ 判定/ 程序/ 的/ 任意/ 非/ 平凡/ 性质/ ,/ 即/ 无法/ 构造/ 出/ 停机/ 的/ 通用/ 算法/ ,/ 能够/ 对/ 任意/ 给定/ 的/ 程序/ 判定/ 其/ 是否/ 满足/ 指定/ 的/ 性质/ ./ 尽管/ 通用/ 算法/ 不/ 存在/ ,/ 但是/ 若/ 对/ 问题/ 稍加/ 限制/ ,/ 在/ 有限/ 范围/ 内/ 解决/ 这一/ 问题/ 却是/ 可行/ 的/ ./ 经过/ 不断/ 努力/ 和/ 尝试/ ,/ 科研人员/ 提出/ 了/ 多种/ 程序/ 分析方法/ 和/ 支撑/ 工具/ ,/ 可/ 根据/ 对/ 程序/ 安全性/ 的/ 实际/ 需求/ 从/ 不同/ 的/ 角度/ 和/ 程度/ 解决问题/ ./ 评价/ 程序/ 分析/ 与/ 软件/ 安全漏洞/ 检测/ 方法/ 和/ 工具/ 的/ 优良/ 与否/ 有/ 多种/ 指标/ ,/ 其中/ 最/ 重要/ 的/ 是/ 误报率/ 和/ 漏报/ 率/ [/ 5/ ]/ ,/ 分别/ 表示/ 误报/ 和/ 漏报/ 现象/ 发生/ 的/ 概率/ ./ 误报/ 是/ 指/ 算法/ 报告/ 了/ 实际/ 不/ 存在/ 的/ 错误/ ,/ 漏报/ 是/ 指/ 算法/ 遗漏/ 了/ 本来/ 存在/ 的/ 错误/ ./ 为了/ 对/ 各种/ 程序/ 分析方法/ 做/ 较/ 全面/ 的/ 了解/ ,/ 对/ Page3/ 其/ 进行/ 合理/ 的/ 分类/ 是/ 必要/ 的/ ,/ 常见/ 的/ 分类/ 方式/ 有/ 以下/ 两种/ :/ 一种/ 按照/ 程序代码/ 的/ 文本/ 形式/ 分为/ 二进制/ 和/ 源代码/ 分析/ ,/ 这种/ 分类法/ 更/ 多/ 是从/ 技术/ 实现/ 的/ 角度/ 出发/ ;/ 另/ 一种/ 按照/ 是否/ 运行/ 程序代码/ ,/ 将/ 程序/ 分析方法/ 分为/ 动态/ 和/ 静态/ 分析/ ,/ 这种/ 分类/ 方式/ 更/ 容易/ 说/ 清/ 漏报/ 和/ 误报/ 的/ 发生/ 根源/ ./ 静态/ 分析方法/ 从/ 语法/ 或/ 语义/ 的/ 层面/ 分析程序/ 文本/ (/ 源代码/ 或/ 二进制/ )/ ,/ 以/ 推导/ 其/ 语法/ 或/ 语义/ 性质/ ./ 其/ 目的/ 较/ 偏重于/ 说明/ 程序/ 不/ 包含/ 某种/ 错误/ ,/ 多数/ 静态方法/ 存在/ 误报/ ,/ 有/ 的/ 也/ 同时/ 存在/ 漏报/ ./ 动态分析/ 方法/ 通过/ 运行/ 待测/ 程序/ 以/ 获取/ 和/ 分析/ 程序运行/ 过程/ 中/ 产生/ 的/ 动态/ 信息/ ,/ 以/ 判断/ 其/ 运行/ 时/ 语义/ 性质/ ./ 由于/ 运行/ 时/ 动态/ 信息/ 是/ 准确/ 的/ ,/ 因此/ 动态分析/ 方法/ 本质/ 上/ 不/ 存在/ 误报/ ,/ 但是/ 由于/ 很难/ 完全/ 枚举/ 程序/ 所有/ 的/ 执行/ 情况/ ,/ 动态分析/ 方法/ 通常/ 存在/ 漏报/ ./ 需要/ 指出/ 的/ 是/ ,/ 二进制/ 分析/ 多/ 采用/ 动态分析/ 方法/ ,/ 源代码/ 分析/ 多/ 采用/ 静态/ 分析方法/ ./ 图/ 1/ 不同/ 近似/ 方式/ 引起/ 漏报/ 和/ 误报/ 总而言之/ ,/ 各种/ 具体/ 的/ 分析方法/ 均须/ 隐式/ 或/ 显式/ 地/ 对/ 被/ 分析程序/ 的/ 可达/ 状态/ 集合/ 建立/ 分析模型/ ,/ 这个/ 模型/ 总/ 可以/ 被/ 视为/ 是/ 对/ 实际/ 语义/ 域/ 的/ 上/ 近似/ 或/ 下/ 近似/ ./ 清楚/ 区分/ 分析方法/ 对/ 程序/ 可/ 达/ 状态/ 集/ 的/ 近/ 3.1/ 软件测试/ 迄今为止/ 工业界/ 采用/ 最多/ 的/ 依然/ 是/ 软件测试/ 方法/ ,/ 据统计/ ,/ 在/ 美国/ 每年/ 耗费/ 在/ 测试/ 上/ 的/ 费用/ 高达/ 几图/ 2/ 方法/ 分类/ 对动/ 、/ 静态方法/ 引起/ 漏报/ 和/ 误报/ 的/ 原因/ 做/ 深入/ 的/ 考察/ 则/ 可以/ 发现/ ,/ 动态分析/ 只/ 获取/ 程序/ 的/ 实际/ 可行/ 路径/ 和/ 可达/ 状态/ ,/ 这是/ 保证/ 分析/ 结果/ 没有/ 误报/ 的/ 根本原因/ ./ 但/ 由于/ 其/ 大多/ 时候/ 并/ 不能/ 遍历/ 程序/ 的/ 所有/ 可行/ 路径/ ,/ 因而/ 可能/ 错过/ 了/ 某些/ 可以/ 引发/ 程序/ 错误/ 的/ 执行/ 路径/ ,/ 进而/ 导致/ 漏报/ ,/ 如图/ 1/ (/ a/ )/ 所示/ ./ 换言之/ ,/ 动态分析/ 方法/ 对/ 程序/ 的/ 实际/ 可/ 达/ 状态/ 做下/ 近似/ 处理/ (/ under/ -/ approximation/ )/ [/ 6/ ]/ ./ 大部分/ 静态/ 分析方法/ 为了/ 建立/ 用于/ 分析/ 的/ 模型/ 需要/ 对/ 程序/ 的/ 动态/ 语义/ 做/ 某种/ 形式/ 的/ 抽象/ ,/ 其/ 抽象/ 结果/ 难免会/ 引入/ 实际/ 不/ 可行/ 路径/ 和/ 不可/ 达/ 状态/ ,/ 如图/ 1/ (/ b/ )/ 所示/ ,/ 而/ 静态/ 分析方法/ 难以/ 在/ 有限/ 时间/ 内/ 判定/ 抽象/ 路径/ 的/ 可行性/ ,/ 这是/ 导致/ 误报/ 的/ 主要/ 原因/ ./ 换言之/ ,/ 这/ 类/ 方法/ 对/ 被/ 分析程序/ 的/ 实际/ 可/ 达/ 状态/ 做/ 上/ 近似/ 处理/ (/ over/ -/ approximation/ )/ [/ 7/ ]/ ./ 也/ 存在/ 一些/ 静态方法/ 同时/ 做/ 上/ 近似/ 和/ 下/ 近似/ ,/ 因而/ 同时/ 引入/ 漏报/ 和/ 误报/ ,/ 如图/ 1/ (/ c/ )/ 所示/ ./ 似/ 方式/ ,/ 是/ 考察/ 各种/ 分析方法/ 是否/ 存在/ 误报/ 和/ 漏报/ 的/ 根本/ 角度/ ./ 从/ 这点/ 出发/ ,/ 本/ 节/ 后续/ 部分/ 将/ 分别/ 对/ 软件测试/ 、/ 静态/ 程序/ 分析/ 和/ 将/ 程序/ 性质/ 表达/ 为/ 逻辑/ 公式/ 的/ 方法/ 做/ 介绍/ 和/ 对比/ ,/ 图/ 2/ 给出/ 各种/ 方法/ 分类/ ./ 十/ 亿美金/ ,/ 在/ 那些/ 对/ 软件/ 质量/ 要求/ 较/ 严格/ 的/ 公司/ ,/ 项目/ 开发/ 总/ 投入/ 中/ 花费/ 在/ 测试/ 上/ 的/ 部分/ 甚至/ 达到/ 50/ %/ [/ 1/ ,/ 6/ ]/ ./ 软件测试/ 目的/ 有/ 多种/ ,/ 功能性/ 测试/ 考察/ 程/ Page4/ 序/ 是否/ 正确/ 实现/ 了/ 预期/ 的/ 功能/ ;/ 可靠性/ 测试/ 则/ 尽量/ 选取/ 广泛/ 的/ 测试数据/ 运行/ 程序/ 以/ 观察/ 程序/ 是否/ 出现异常/ 行为/ ;/ 由于/ 软件开发/ 是/ 个/ 进化/ 的/ 过程/ ,/ 期间/ 会/ 不断/ 产生/ 新/ 的/ 程序/ 版本/ ,/ 回归/ 测试/ 用于/ 检验/ 新/ 版本/ 是否/ 保留/ 了/ 旧版本/ 的/ 正确/ 部分/ ;/ 安全性/ 测试/ 则/ 可/ 检测/ 并/ 识别/ 程序/ 中/ 潜在/ 的/ 安全性/ 缺陷/ ,/ 并/ 验证/ 该/ 缺陷/ 是否/ 可/ 被/ 利用/ 进而/ 导致系统/ 出现/ 安全性/ 问题/ ./ 测试/ 需要/ 准备/ 测试用例/ ,/ 为了/ 考察/ 测试用例/ 集合/ 是否/ 能够/ 真正/ 说明/ 问题/ 以及/ 能/ 在/ 多/ 大程度/ 上/ 说明/ 问题/ ,/ 研究者/ 从/ 覆盖率/ 的/ 角度/ 提出/ 多种/ 测试用例/ 的/ 评价/ 标准/ ,/ 主要/ 包括/ 语句/ 覆盖率/ 、/ 分支/ 覆盖率/ 、/ 分支/ 组合/ 覆盖率/ 和/ 路径/ 覆盖率/ ./ 手工/ 创建/ 测试用例/ 需要/ 测试人员/ 花费/ 大量/ 精力/ 和/ 时间/ ,/ 因此/ 如何/ 设计/ 算法/ 自动/ 生成/ 测试用例/ 以/ 减轻/ 测试/ 工作/ 的/ 负担/ ,/ 成为/ 测试方法/ 研究/ 的/ 核心/ 问题/ 之一/ ./ 1996/ 年/ Ferguson/ 和/ Korel/ [/ 8/ -/ 10/ ]/ 将/ 自动化/ 测试用例/ 生成/ 的/ 方法/ 分为/ 三类/ :/ 面向/ 目标/ (/ Goal/ -/ Oriented/ )/ 的/ 测试用例/ 生成/ 、/ 面向/ 路径/ 的/ (/ Path/ -/ Oriented/ )/ 测试用例/ 生成/ 以及/ 随机化/ 模糊/ 测试/ (/ RandomFuzz/ )/ ./ 前/ 两种/ 方法/ 通过考察/ 程序/ 内部结构/ 来/ 选择/ 测试数据/ ,/ 以/ 覆盖/ 某条/ 指定/ 语句/ 或/ 程序执行/ 路径/ ,/ 因此/ 也/ 被称作/ 结构化/ 测试/ 或/ 白盒/ 测试/ ./ 随机/ 测试/ 又/ 称为/ 黑盒/ 模糊/ 测试/ [/ 11/ ]/ ,/ 是/ 一种/ 将/ 大量/ 随机/ 数据/ 输入/ 到/ 目标程序/ 中/ ,/ 通过/ 监视/ 程序运行/ 过程/ 中/ 的/ 异常/ 来/ 挖掘/ 软件/ 漏洞/ 的/ 方法/ ./ 由于/ 模糊/ 测试/ 不/ 需要/ 了解/ 程序/ 源代码/ ,/ 能/ 较/ 快/ 地/ 定位/ 和/ 确认/ 安全漏洞/ ,/ 已/ 成为/ 软件/ 安全性/ 检测/ 的/ 重要/ 方法/ 和/ 有效/ 手段/ ./ 自/ 模糊/ 测试方法/ 提出/ 以来/ ,/ 已/ 挖掘出/ 大量/ 的/ 高危/ 漏洞/ ,/ 因而/ 吸引/ 了/ 安全/ 领域/ 的/ 研究者/ 和/ 公司/ 的/ 高度重视/ ,/ 各种/ 模糊/ 测试/ 通用/ 框架/ 和/ 专用工具/ 不断涌现/ ./ 限于/ 篇幅/ ,/ 有/ 兴趣/ 者/ 可/ 参考文献/ [/ 11/ -/ 22/ ]/ ./ 需要/ 指出/ 的/ 是/ ,/ 极小/ 语义/ 缺陷/ 是/ 指/ 只能/ 由/ 程序/ 输入/ 中/ 极小/ 比例/ 数据/ 揭示/ 的/ 软件缺陷/ [/ 23/ ]/ ,/ 而/ 模糊/ 测试/ 则/ 很/ 难/ 发现/ 此类/ 缺陷/ ./ 如图/ 3/ 所示/ ,/ 典型/ 的/ 测试数据/ 生成/ 系统/ 包含/ 三个/ 部分/ :/ 程序/ 分析器/ 、/ 路径/ 选择器/ 和/ 测试数据/ 生成器/ ./ 程序/ 分析器/ 对/ 源代码/ 作/ 预处理/ 分析/ ,/ 产生/ 必要/ 的/ 分析/ 结果/ 提供/ 给/ 路径/ 选择器/ ,/ 较/ 重要/ 的/ 分析/ 信息/ 包括/ 过程/ 调用/ 图/ 、/ 数据/ 依赖图/ 和/ 控制流/ 图/ 等/ ;/ 路径/ 选择器/ 以/ 提高/ 某种/ 覆盖率/ 为/ 目标/ ,/ 根据/ 路径/ 选择/ 策略/ 选取/ 适当/ 的/ 程序/ 路径/ 并/ 提供/ 给/ 测试数据/ 生成器/ 使用/ ,/ 路径/ 选择/ 问题/ 对/ 整个/ 测试数据/ 生成/ 过程/ 都/ 有/ 极大/ 影响/ [/ 10/ ]/ ;/ 测试数据/ 生成器/ 根据/ 这些/ 路径/ 生成/ 测试数据/ ,/ 有时/ 也/ 给/ 路径/ 选择器/ 提供/ 反馈/ 信息/ ,/ 如/ 发现/ 某条/ 路径/ 不/ 可行/ 等/ ./ 需要/ 注意/ 的/ 是/ ,/ 测试/ 过程/ 本身/ 是/ 动态/ 的/ ,/ 但/ 测试用例/ 的/ 生成/ 不必/ 运行/ 被/ 测试/ 的/ 程序/ ./ 做/ 为/ 一种/ 动态分析/ 方法/ ,/ 测试/ 不会/ 产生/ 误报/ ,/ 但/ 存在/ 漏报/ ,/ 正如/ Dijkstra/ 所言/ ,/ “/ 测试/ 可/ 有效/ 地/ 揭示/ 程序/ 包含/ 错误/ ,/ 但/ 并/ 不能/ 确保/ 程序/ 无错/ ”/ ./ 相对/ 于/ 静态/ 分析/ 的/ 高/ 误报率/ ,/ 很多/ 公司/ 为/ 保证/ 软件开发/ 效率/ 而/ 容忍/ 少量/ 缺陷/ 的/ 存在/ ,/ 即/ 接受/ 漏报/ ,/ 拒绝/ 误报/ [/ 6/ ]/ ,/ 这/ 使得/ 测试方法/ 成为/ 工业界/ 保证/ 软件/ 质量/ 的/ 最/ 常用/ 方法/ ./ 3.2/ 静态/ 程序/ 分析/ 和/ 抽象/ 解释/ 静态/ 程序/ 分析/ [/ 24/ -/ 25/ ]/ 源自/ 于/ 编译/ 优化/ 技术/ ,/ 它/ 通过/ 分析/ 程序代码/ 来/ 求解/ 关于/ 程序/ 特定/ 性质/ 的/ 问题/ ,/ 是/ 多种/ 分析/ 技术/ 的/ 集合/ ,/ 其中/ 最/ 基本/ 的/ 两类/ 是/ 控制流/ 分析/ 和/ 数据流/ 分析/ ./ 控制流/ 分析/ [/ 25/ ]/ 提取/ 代码/ 中/ 的/ 控制结构/ ,/ 以/ 控制流/ 图/ 作为/ 对/ 程序/ 中/ 分支/ 跳转/ 关系/ 的/ 抽象/ ,/ 描述/ 程序/ 的/ 所有/ 可能/ 执行/ 路径/ ./ 数据流/ 分析/ [/ 24/ ]/ 内容/ 较/ 多/ ,/ 大致/ 可以/ 按照/ 三个/ 角度/ 考察/ :/ 流/ 敏感/ // 流/ 不/ 敏感/ ,/ 路径/ 敏感/ // 路径/ 不/ 敏感/ ,/ 上下文/ 敏感/ // 上下文/ 不/ 敏感/ ./ 流/ 敏感/ 的/ 分析/ 考虑/ 程序/ 中/ 语句/ 的/ 顺序/ ,/ 举例来说/ ,/ 一个/ 流/ 不/ 敏感/ 的/ 指针/ 分析/ 可能/ 认为/ “/ 变量/ x/ 和/ y/ 可能/ 指向/ 了/ 同一/ 位置/ ”/ ,/ 而/ 一个/ 流/ 敏感/ 分析/ 会/ 认为/ “/ 在/ 某条/ 语句/ 执行/ 后/ ,/ 变量/ x/ 和/ y/ 可能/ 指向/ 了/ 同一/ 位置/ ”/ ;/ 路径/ 敏感/ 的/ 分析/ 考虑/ 了/ 程序/ 的/ 控制流/ ,/ 比如/ 一个/ 分支/ 条件/ 是/ x/ >/ 0/ ,/ 那么/ 在/ 条件/ 不/ 满足/ 的/ 分支/ 下/ 分析/ 过程/ 会/ 假设/ x/ / 0/ ,/ 而/ 在/ 满足条件/ 的/ 分支/ 则/ 会/ 假设/ x/ >/ 0/ 成立/ ;/ 上下文/ 敏感/ 的/ 分析/ 则/ 处理过程/ 调用/ ,/ 在/ 分析/ 目标/ 函数/ 的/ 调用/ 时/ ,/ 它/ 将/ 根据/ 调用/ 的/ 上下文/ 信息/ 确保/ 被/ 调用函数/ 能够/ 返回/ 到/ 正确/ 的/ 调用/ 点/ ,/ 而/ 如果/ 没有/ 这种/ 信息/ ,/ 返回/ 时/ 就/ 必须/ 考虑/ 所有/ 可能/ 的/ 调用/ 点/ ,/ 因而/ 丧失/ 潜在/ 的/ 精度/ ./ 数据流/ 分析/ 以格/ 做/ 为/ 问题/ 的/ 解/ 空间/ 模型/ ,/ 以格/ 理论/ 做/ 为/ 考察/ 问题/ 的/ 角度/ ,/ 以/ 不动点/ 计算/ 做/ 为/ 求解/ 方法/ ./ 很多/ 时候/ ,/ 数据流/ 分析/ 所/ 建立/ 的/ 解/ 空间/ 格/ 模型/ 过于/ 庞大/ ,/ 致使/ 问题/ 的/ 求解/ 实际/ 不可/ 计算/ ./ CousotP/ 和/ CousotR/ [/ 26/ -/ 27/ ]/ 于/ 1977/ 年/ 提出/ 基于/ 格/ 理论/ 的/ 抽象/ Page5/ 解释/ (/ AbstractInterpretation/ )/ 方法/ ,/ 用于/ 简化/ 和/ 逼近/ (/ Approximation/ )/ 程序/ 不动点/ 计算/ ,/ 其/ 方法/ 使用/ 另/ 一个/ 抽象/ 对象/ 域/ 上/ 的/ 计算/ 逼近/ 程序/ 指称/ 的/ 对象/ 域/ (/ 具体/ 对象/ 域/ )/ 上/ 的/ 计算/ ,/ 使得/ 程序/ 抽象/ 执行/ 的/ 结果/ 能够/ 反映/ 出/ 程序/ 真实/ 运行/ 的/ 部分/ 信息/ ,/ 本质/ 上/ 是/ 在/ 计算/ 效率/ 和/ 计算精度/ 之间/ 取得/ 均衡/ ,/ 以/ 损失/ 计算精度/ 换取/ 实际/ 计算/ 的/ 可行性/ [/ 27/ ]/ ./ 基于/ 语法/ 制导/ 的/ 静态/ 错误/ 检查/ 工具/ 不/ 需要/ 运行/ 程序/ ,/ 而是/ 使用/ 静态/ 分析方法/ 从/ 语法/ 角度/ 分析/ 程序代码/ ,/ 并/ 报告/ 可能/ 的/ 软件缺陷/ ./ 比较/ 知名/ 的/ 工具/ 有/ Lint/ 工具/ 族/ 、/ Prefix/ 、/ Coverity/ 、/ Fortify/ 和/ Klocwork/ 等/ ,/ 此类/ 工具/ 通常/ 会/ 产生/ 大量/ 误报/ [/ 28/ ]/ ./ 3.3/ 将/ 程序/ 性质/ 表达/ 为/ 逻辑/ 公式/ 的/ 方法/ 将/ 程序/ 性质/ 表达/ 为/ 逻辑/ 公式/ 的/ 方法/ 在/ 20/ 世纪/ 60/ 年代/ 就/ 已经/ 被/ Floyd/ [/ 29/ ]/ 和/ Hoare/ [/ 4/ ]/ 提出/ ,/ 是/ 程序正确性/ 研究/ 的/ 主要/ 方法/ ,/ 研究者/ 在/ 已有/ 成果/ 的/ 基础/ 上/ 不断/ 做出/ 新/ 的/ 发展/ ,/ 本/ 节/ 介绍/ 其中/ 比较/ 重要/ 的/ 4/ 种/ 方法/ ./ 3.3/ ./ 1/ 程序正确性/ 证明/ 程序正确性/ 证明/ 试图/ 从/ 语法/ 推导/ 的/ 角度/ 证明/ 程序/ 满足/ 其/ 功能/ 规约/ ./ 程序/ 的/ 功能/ 规约/ 是/ 一对/ 谓词/ 公式/ ,/ 包括/ 前置/ 谓词/ 和/ 后置/ 谓词/ ,/ 它们/ 用/ 内涵/ 的/ 方式/ 分别/ 定义/ 了/ 程序执行/ 前后/ 的/ 可能/ 状态/ 集合/ ./ 由于/ 造成/ 状态/ 变迁/ 的/ 唯一/ 原因/ 是/ 程序/ 的/ 执行/ ,/ 因此/ 这样/ 一对/ 谓词/ 公式/ 足以/ 描述/ 程序/ 的/ 功能/ ./ 程序/ 的/ 正确性/ 包括/ 部分/ 正确性/ 和/ 完全/ 正确性/ ,/ 区别/ 在于/ 是否/ 保证/ 程序/ 终止/ ./ 假设/ 程序/ 从/ 满足/ 其/ 前置/ 谓词/ 的/ 某/ 一/ 状态/ 开始/ 执行/ ,/ 若能/ 终止/ 执行/ 则/ 其/ 终止/ 状态/ 必/ 满足/ 其后/ 置/ 谓词/ ,/ 则/ 称/ 程序/ 满足/ 部分/ 正确性/ ./ 以/ 同样/ 假设/ 为/ 起点/ ,/ 若/ 程序/ 必然/ 终止/ 且/ 其/ 终止/ 状态/ 满足/ 其后/ 置/ 谓词/ ,/ 则/ 称/ 程序/ 满足/ 完全/ 正确性/ ./ 可/ 用于/ 证明/ 程序/ 部分/ 正确性/ 的/ 方法/ 有/ Floyd/ 的/ 不变式/ 断言/ 法/ 、/ Manna/ 的/ 子目标/ 断言/ 法/ 和/ Hoare/ 的/ 公理化/ 方法/ [/ 30/ ]/ ;/ 可/ 用于/ 证明/ 程序/ 终止/ 性/ 的/ 方法/ 有/ Floyd/ 的/ 良序集/ 方法/ 、/ Manna/ 等/ 人/ 的/ 不动点/ 方法/ 和/ Knuth/ 的/ 计数器/ 方法/ ./ 为/ 证明/ 程序/ 的/ 完全/ 正确性/ ,/ Manna/ 和/ Pnueli/ 对/ Hoare/ 的/ 公理化/ 方法/ 做出/ 推广/ ,/ 另外/ Dijkstra/ 提出/ 最/ 弱/ 前置/ 谓词/ 转换方法/ 以及/ 验证/ 方法/ ./ 需要/ 说明/ 的/ 是/ ,/ Hoare/ 逻辑/ 是/ 一个/ 完整/ 的/ 程序逻辑/ 系统/ ,/ 每个/ 公式/ 由/ 一个/ 程序/ 语句/ 及其/ 前后/ 置/ 断言/ 构成/ ,/ 其/ 理论/ 只/ 包含/ 一条/ 赋值/ 公理/ ,/ 其/ 形式演算/ 系统/ 在/ 一阶/ 谓词/ 逻辑/ 的/ 基础/ 上/ 分别/ 为/ 顺序/ 、/ 分支/ 和/ 循环/ 指令/ 添加/ 了/ 三条/ 演算/ 规则/ ./ 已经/ 证明/ ,/ Hoare/ 逻辑/ 具有/ 可靠性/ 和/ 相对/ 完备/ 性/ ,/ 但/ 其/ 形式演算/ 系统/ 半可/ 判定/ ./ 程序正确性/ 证明/ 的/ 主要/ 问题/ 有/ 两个/ ,/ 一是/ 需要/ 程序设计/ 人员/ 使用/ 逻辑/ 公式/ 描述/ 程序/ 的/ 功能/ 规约/ ;/ 二是/ 需要/ 为/ 循环体/ 寻找/ 循环/ 不变式/ ./ 3.3/ ./ 2/ 模型/ 检验/ 模型/ 检验/ 方法/ 在/ 计算机硬件/ 、/ 通信协议/ 、/ 控制系统/ 、/ 安全/ 协议/ 的/ 分析/ 与/ 验证/ 中/ ,/ 取得/ 了/ 令人瞩目/ 的/ 成就/ [/ 31/ ]/ ,/ 并且/ 可以/ 验证/ 程序/ 是否/ 满足/ 指定/ 的/ 安全/ 性质/ ./ 它/ 使用/ 有穷/ 状态/ 迁移/ 图对/ 程序/ 的/ 行为/ 建模/ ,/ 同时/ 使用/ 模态/ 或/ 时序/ 逻辑/ 公式/ 描述/ 待/ 检验/ 的/ 安全/ 性质/ ,/ 程序/ 的/ 每条/ 执行/ 路径/ 及其/ 相应/ 的/ 状态/ 对应/ 于/ 迁移/ 图中/ 的/ 一条/ 状态/ 迁移/ 轨迹/ ./ 模型/ 检验/ 方法/ 通过/ 穷举/ 状态/ 迁移/ 图中/ 每/ 一条/ 状态/ 迁移/ 轨迹/ ,/ 逐次/ 判定/ 该/ 轨迹/ 上/ 的/ 所有/ 状态/ 是否/ 满足/ 待/ 检验/ 性质/ ,/ 若/ 都/ 满足/ 则/ 认为/ 程序/ 满足/ 了/ 待/ 检验/ 性质/ ,/ 也/ 即/ 获得/ 了/ 程序/ 满足/ 待/ 检验/ 安全/ 性质/ 的/ 一个/ 证明/ ,/ 否则/ 模型/ 检验/ 器/ 给出/ 使/ 性质/ 为/ 假/ 的/ 系统/ 状态/ 迁移/ 轨迹/ 做/ 为/ 反例/ ./ 在/ 软件/ 验证/ 领域/ ,/ 模型/ 检验/ 方法/ 的/ 主要/ 困难/ 是/ 状态/ 爆炸/ 问题/ ,/ 目前/ 的/ 解决/ 思路/ 有/ 四类/ :/ 一类/ 是/ 抽象/ 方法/ ,/ 通过/ 深度/ 发掘/ 所/ 建立/ 模型/ 的/ 状态/ 空间结构/ 特征/ 和/ 相关/ 知识/ 对模型/ 进行/ 抽象/ (/ 编码/ 和/ 压缩/ )/ ,/ 消减/ 原/ 模型/ 中/ 与/ 待/ 检验/ 性质/ 无关/ 的/ 信息/ ,/ 以/ 获取/ 模型/ 的/ 简约/ 表示/ ,/ 以/ 最终/ 减少/ 计算/ 代价/ ,/ 抽象/ 方法/ 包括/ 符号化/ 模型/ 检验/ 、/ 对称/ 模型/ 检验/ 和/ 偏序/ 模型/ 检验/ 等/ ./ 需注意/ 的/ 是/ ,/ 抽象/ 必须/ 是/ 保持/ 性质/ 的/ ,/ 即/ 若/ 简化/ 的/ 模型/ 满足/ 性质/ ,/ 则/ 原来/ 的/ 模型/ 亦/ 满足/ 该/ 性质/ ;/ 一类/ 在/ 生成/ 模型/ 的/ 同时/ 检验/ 安全/ 性质/ ,/ 绕过/ 状态/ 空间/ 过大/ 的/ 问题/ ,/ 如/ On/ -/ the/ -/ fly/ 方法/ ;/ 另一类/ 对/ 程序/ 中/ 的/ 循环/ 结构/ 做/ 有限/ 次/ 展开/ ,/ 并/ 利用/ SAT/ 技术/ 只/ 对/ 有限/ 长度/ 轨迹/ 做/ 检验/ ,/ 如/ 限界/ 模型/ 检验/ ;/ 最后/ 一类/ 是/ 组合/ 验证/ 方法/ ,/ 基于/ 分而治之/ 的/ 思想/ 把/ 整个/ 模型/ 分解/ 为/ 可/ 处理/ 的/ 子/ 模型/ ,/ 先/ 验证/ 各个/ 子/ 模型/ 的/ 局部/ 性质/ ,/ 并/ 可/ 保证/ 当/ 各个/ 子/ 模型/ 都/ 满足/ 其/ 局部/ 性质/ 时/ ,/ 整个/ 模型/ 必然/ 满足/ 待/ 检验/ 的/ 安全/ 性质/ ./ 3.3/ ./ 3/ 反例/ 制导/ 的/ 谓词/ 抽象/ 求精/ 谓词/ 抽象/ 是/ 一种/ 特殊/ 的/ 程序/ 抽象/ 方法/ ,/ 它/ 以/ 一组/ 谓词/ 为/ 准则/ 对/ 程序/ 进行/ 约/ 减/ ,/ 只/ 保留/ 程序/ 的/ 控制流/ 和/ 程序/ 中/ 涉及/ 到/ 谓词/ 集合/ 中/ 所/ 包含/ 的/ 自由/ 变量/ 的/ 语句/ ,/ 得到/ 原程序/ 的/ 一个/ 简化/ 版本/ ,/ 可以/ 看作/ 原程序/ 在/ 谓词/ 集合/ 上/ 的/ 投影/ ./ 抽象/ 后/ 所得/ 程序/ 的/ 可达/ 状态/ 集合/ 是/ 原程序/ 可/ 达/ 状态/ 集合/ 的/ 超集/ ./ 反例/ 制导/ 的/ 谓词/ 抽象/ 求精/ 方法/ [/ 7/ ,/ 32/ ]/ 认为/ 程序/ 的/ 抽象/ 模型/ 的/ 建立/ 是/ 一个/ 逐步/ 逼近/ 的/ 过程/ ./ 首先/ 根据/ 初始/ 谓词/ 集合/ 对/ 程序/ 进行/ 谓词/ 抽象/ ,/ 并/ 通过/ 对/ 抽象/ Page6/ 模型/ 的/ 迭代/ 求精/ 逐步/ 建立/ 程序/ 的/ 精确/ 模型/ ./ 对/ 每次/ 迭代/ 得到/ 的/ 抽象/ 模型/ 进行/ 模型/ 检验/ ,/ 若/ 存在/ 反例/ ,/ 则/ 根据/ 其/ 反例/ 路径/ 在/ 原程序/ 中/ 找到/ 对应/ 的/ 程序/ 路径/ ,/ 并/ 判断/ 该/ 路径/ 的/ 可行性/ ./ 如果/ 该/ 路径/ 可行/ ,/ 则/ 该/ 反例/ 为/ 真实/ 的/ ,/ 否则/ 即/ 为/ 虚假/ 反例/ ./ 根据/ 虚假/ 反例/ 产生/ 的/ 原因/ ,/ 指导/ 谓词/ 集合/ 的/ 进一步/ 求精/ ,/ 进而/ 得到/ 一个/ 不再/ 含有/ 该/ 虚假/ 反例/ 的/ 新/ 的/ 抽象/ 模型/ ./ 重复/ 这一/ 过程/ ,/ 直到/ 模型/ 不再/ 存在/ 反例/ ./ 在/ 模型/ 检验/ 技术/ 中/ ,/ 使用/ 谓词/ 抽象/ 能够/ 对/ 程序/ 状态/ 空间/ 进行/ 有效/ 压缩/ ,/ 很大/ 程度/ 上/ 缓解/ 了/ 模型/ 检验所/ 面临/ 的/ 状态/ 空间/ 爆炸/ 问题/ ./ 在/ 基于/ 这种/ 方法/ 开发/ 的/ 工具/ 中/ ,/ 比较/ 著名/ 的/ 有/ 微软/ 的/ SLAM/ [/ 7/ ,/ 32/ ]/ 和/ CMU/ 的/ Blast/ 等/ ,/ 其中/ SLAM/ 被/ 用做/ 检验/ Windows/ 驱动程序/ 可靠性/ 的/ 基本/ 工具/ 之一/ ./ 但/ 由于/ 抽象/ 过程/ 是/ 对/ 程序/ 实际/ 可/ 达/ 状态/ 集合/ 的/ 上/ 近似/ ,/ 这种/ 方法/ 不可避免/ 地/ 引入/ 误报/ 问题/ ,/ 如/ SLAM/ 的/ 误报率/ 高达/ 30/ %/ [/ 33/ ]/ ./ 3.3/ ./ 4/ 符号执行/ 最早/ 提出/ 符号执行/ 概念/ 的/ 文献/ 首/ 见于/ 1969/ 年/ ,/ 随后/ 即/ 获得/ 研究者/ 大量/ 关注/ [/ 34/ -/ 36/ ]/ ,/ 但是/ 直到/ 最近/ 十几年/ 才/ 开始/ 逐渐/ 步入/ 实用化/ [/ 37/ -/ 39/ ]/ ,/ 这种/ 方法/ 的/ 核心/ 在于/ :/ 通过/ 描述/ 程序/ 的/ 执行/ 路径/ 和/ 伴随/ 的/ 状态/ 变化/ 来/ 表示/ 程序/ 语义/ 并/ 揭示/ 程序/ 的/ 内部结构/ ./ 程序/ 测试/ 和/ 程序正确性/ 证明/ 可/ 被/ 视为/ 两个/ 极端/ ./ 测试/ 容易/ 实现/ 自动化/ ,/ 但/ 即使/ 被/ 测试程序/ 能够/ 正确/ 执行/ 测试用例/ 并/ 产生/ 预期/ 的/ 结果/ ,/ 也/ 并/ 不能/ 保证/ 没有/ 被/ 测试/ 到/ 的/ 数据/ 都/ 能/ 使/ 程序/ 正确/ 工作/ ;/ 另一方面/ ,/ 程序/ 证明/ 不/ 需要/ 运行/ 程序/ ,/ 只/ 需要/ 证明/ 程序/ 所有/ 可能/ 的/ 执行/ 情况/ 都/ 满足/ 程序/ 规约/ ,/ 但/ 程序/ 规约/ 需要/ 程序/ 的/ 设计者/ 理解/ 程序/ 的/ 功能/ 需求/ ,/ 只能/ 手工/ 注释/ 而/ 难以实现/ 自动化/ 生成/ ./ 符号执行/ 可/ 被/ 视为/ 介于/ 二者之间/ 的/ 一种/ 实际/ 可行/ 的/ 折中/ 方法/ ,/ 程序/ 不/ 以/ 实际/ 的/ 数据/ 作为/ 输入/ ,/ 而是/ 将/ 输入/ 向量/ 空间/ 做/ 等价/ 划分/ ,/ 以/ 符号/ 变量/ 所/ 表达/ 的/ 等价/ 类/ 作为/ 输入/ ,/ 并/ “/ 符号化/ ”/ 执行程序/ ./ 每次/ 符号化/ 执行/ 相当于/ 该/ 等价/ 类中/ 的/ 数据/ 均/ 被/ 执行/ 一次/ ,/ 而/ 一次/ 普通/ 执行/ 则/ 可/ 被/ 视为/ 一次/ 符号执行/ 的/ 一个/ 特例/ ,/ 可以/ 说/ 符号执行/ 用/ 新/ 的/ 方式/ 捕获/ 程序/ 的/ 执行/ 语义/ ,/ 这/ 是/ 对/ 普通/ 执行/ 的/ 扩展/ 和/ 一般化/ ./ 需要/ 注意/ 的/ 是/ ,/ 等价/ 类/ 的/ 划分/ 由/ 程序/ 对/ 输入/ 的/ 控制/ 依赖/ 所/ 决定/ ,/ 由于/ 循环/ 和/ 递归/ 等/ 程序结构/ 的/ 存在/ ,/ 很多/ 时候/ 等价/ 类/ 的/ 划分/ 是/ 无限/ 的/ ,/ 所以/ 在/ 有限/ 时间/ 内要/ 穷尽/ 所有/ 情况/ 通常/ 是/ 不/ 可能/ 的/ [/ 34/ ]/ ./ 对于/ 符号执行/ 而言/ ,/ 执行/ 路径/ 、/ 路径/ 约束/ 和/ 执行/ 树是/ 其/ 核心/ 概念/ ./ 假设/ 程序/ 只/ 由/ 分支/ 语句/ 集合/ C/ 、/ 赋值/ 语句/ 集合/ A/ 、/ abort/ 语句/ (/ 异常/ 终止/ ,/ 对应/ 于/ 程序/ 错误/ )/ 、/ halt/ 语句/ (/ 程序/ 正常/ 终止/ )/ 构成/ ,/ 则/ 执行/ 路径/ 是/ 一个/ 只/ 包含/ 以上/ 4/ 种/ 语句/ 的/ 有/ 穷/ 序列/ (/ A/ ∪/ C/ )/ / (/ abort/ |/ halt/ )/ [/ 6/ ]/ ,/ 若/ 将/ 每条/ 语句/ 视为/ 一个/ 树/ 节点/ ,/ 则/ 全部/ 执行/ 路径/ 构成/ 程序/ 的/ 符号执行/ 树/ ,/ 其中/ 程序/ 入口/ 为/ 执行/ 树/ 的/ 根/ 节点/ ,/ 每条/ 赋值/ 语句/ 对应/ 的/ 树/ 节点/ 只有/ 一个/ 后继/ 结点/ ,/ 每条/ 分支/ 语句/ 对应/ 的/ 树/ 节点/ 有/ 一/ 或/ 两个/ 后继/ 结点/ ,/ abort/ 或/ halt/ 对应/ 的/ 树/ 节点/ 为/ 执行/ 树/ 的/ 叶子/ 节点/ ./ 符号执行/ 使用/ 符号/ 变量/ 表示/ 程序/ 输入/ 参数/ ,/ 执行/ 过程/ 中/ 使用/ 符号/ 值/ 代替/ 实际/ 值/ 作为/ 程序/ 输入/ 数据/ ,/ 并/ 使用/ 符号/ 表达式/ (/ SymbolicExpression/ )/ 描述/ 程序/ 变量/ 取值/ 情况/ ,/ 于是/ 程序/ 的/ 执行/ 结果/ 可以/ 被/ 表示/ 为/ 符号/ 变量/ 的/ 函数/ ./ 符号执行/ 过程/ 为/ 每个/ 符号/ 变量/ 维持/ 一个/ 符号/ 状态/ (/ SymbolicState/ )/ ,/ 它/ 将/ 符号/ 变量/ 映射/ 为/ 符号/ 表达式/ 以及/ 与此相关/ 的/ 路径/ 约束/ PC/ (/ PathCondition/ )/ ./ 其中/ ,/ 路径/ 约束/ 是/ 一个/ 以/ 符号/ 变量/ 为/ 自由/ 变量/ 的/ 、/ 不带/ 量词/ 的/ 一阶/ 谓词/ 逻辑/ 公式/ ./ 路径/ 约束/ 沿着/ 当前/ 执行/ 路径/ 收集/ 关于/ 符号/ 输入/ 的/ 约束/ ,/ 每当/ 遇到/ 一条/ 赋值/ 语句/ ,/ 则/ 修改/ 被/ 赋值/ 变量/ 在/ 符号/ 状态/ 中/ 所/ 对应/ 的/ 符号/ 表达式/ ,/ 而/ 每当/ 遇到/ 一条/ 分支/ 语句/ 如/ :/ if/ (/ e/ )/ S1elseS2/ ,/ 分支/ 条件/ e/ 的/ 取值/ 决定/ 执行/ 路径/ 应/ 选择/ 的/ 分支/ ,/ 路径/ 约束/ 按照/ 所/ 选/ 分支/ 得到/ 更新/ ./ 若为/ then/ 分支/ ,/ 则/ 路径/ 约束/ PC/ 更新/ 为/ PC/ ∧/ σ/ (/ e/ )/ ;/ 若为/ else/ 分支/ ,/ 则/ 路径/ 约束/ PC/ 更新/ 为/ PC/ ∧/ σ/ (/ / e/ )/ ,/ 其中/ ,/ σ/ (/ e/ )/ 表示/ 在/ 当前/ 符号/ 状态/ σ/ 下/ 对/ e/ 符号/ 求值/ 的/ 结果/ ./ 具体/ 执行/ 在/ 分支/ 节点/ 的/ 两条/ 分支/ 只能/ 选取/ 其中/ 之一/ ,/ 与/ 之/ 不同/ 的/ 是/ ,/ 符号执行/ 在/ 分支/ 节点/ 可以/ 同时/ 选取/ 两者/ ,/ 并/ 因而/ 得到/ 两组/ 不同/ 的/ 路径/ 约束/ ./ 当/ 一条/ 路径/ 符号执行/ 结束/ 时/ ,/ 使用/ 谓词/ 公式/ 判定/ 过程/ 对/ 所/ 获取/ 的/ 路径/ 约束/ 进行/ 求解/ 以/ 得到/ 一组/ 具体/ 输入/ 值/ ,/ 若有解/ ,/ 则/ 此解/ 可/ 作为/ 这/ 条/ 路径/ 所/ 对应/ 等价/ 类/ 的/ 代表/ 元/ ,/ 以此/ 作为/ 测试用例/ 重新/ 执行程序/ ,/ 则/ 程序/ 必定会/ 沿/ 相同/ 路径/ 执行/ ./ 由于/ 路径/ 约束/ 是/ 以/ 谓词/ 公式/ 的/ 形式/ 存在/ ,/ 自然/ 需要/ 考虑/ 其/ 可/ 满足/ 性/ 问题/ ,/ 可/ 满足/ 的/ 路径/ 约束/ 对应/ 于/ 某条/ 实际/ 可行/ 路径/ ,/ 不可/ 满足/ 的/ 路径/ 约束则/ 对应/ 于/ 不/ 可行/ 路径/ ./ 一阶/ 谓词/ 逻辑/ 公式/ 的/ 可/ 满足/ 性/ 问题/ 属于/ 半可/ 判定/ 问题/ ,/ 因此/ 路径/ 可行性/ 问题/ 同样/ 属于/ 半可/ 判定/ 问题/ ./ 早期/ 的/ 基于/ 符号执行/ 的/ 测试/ 生成/ 只/ 针对/ 源代码/ 作/ 分析/ ,/ 属于/ 静态方法/ ,/ 其/ 过程/ 首先/ 使用/ 静态/ 程序/ 分析方法/ 中/ 的/ 控制流/ 分析/ 构造/ 控制流/ 图/ (/ ControlFlowGraph/ )/ ,/ 之后/ 通过/ 选取/ 控制流/ 图中/ 某条/ 路径/ 并/ 针对/ 此/ 路径/ 作/ 符号执行/ 和/ 路径/ 约束/ 求解/ 生成/ 测试用例/ ./ 实践/ 表明/ ,/ 静态/ 符号执行/ 选取/ 的/ 路径/ 中/ 很大/ 一部分/ 是/ 实际/ 不/ 可行/ 路径/ ,/ 这是/ 导致/ 基于/ 静态/ 符号/ 执/ Page7/ 行/ 的/ 测试方法/ 存在/ 误报/ 的/ 根源/ ./ 另一方面/ ,/ 程序代码/ 中/ 的/ 分支/ 语句/ 的/ 存在/ 决定/ 了/ 程序/ 的/ 路径/ 数/ 相对/ 于/ 程序/ 的/ 规模/ 必然/ 呈/ 指数/ 型/ 增长/ ,/ 不仅如此/ ,/ 代码/ 中/ 包含/ 的/ 循环/ 和/ 递归结构/ 更/ 可能/ 导致/ 路径/ 数目/ 达到/ 无穷/ ,/ 这种/ 情况/ 被/ 称为/ 路径/ 爆炸/ 问题/ ,/ 是/ 符号执行/ 的/ 核心/ 问题/ 之一/ [/ 37/ -/ 39/ ]/ ./ 4/ 自动化/ 白盒/ 模糊/ 测试/ 多年/ 来/ ,/ 研究者/ 和/ 产业界/ 对/ 基于/ 各种/ 方法/ 开发/ 的/ 支撑/ 工具/ 获取/ 了/ 大量/ 研究/ 和/ 使用/ 经验/ ,/ 通过/ 综合/ 对比/ ,/ 对/ 各种/ 方法/ 的/ 优势/ 和/ 劣势/ 有/ 了/ 比较/ 清晰/ 的/ 认识/ ./ 2005/ 年/ Bell/ 实验室/ 的/ Godefroid/ 等/ [/ 6/ ]/ 学者/ 提出/ 了/ 基于/ 轻量级/ 动态/ 符号执行/ 的/ 自动化/ 白盒/ 模糊/ 测试方法/ ,/ 近十年/ 来/ 得到/ 了/ 学术界/ 大量/ 关注/ ,/ 是/ 本/ 领域/ 当前/ 的/ 研究/ 热点/ 之一/ ,/ 研究者/ 基于/ 这种/ 方法/ 开发/ 了/ 多种/ 工具/ 如/ DART/ [/ 6/ ]/ 、/ CUTE/ [/ 40/ -/ 42/ ]/ 、/ KLEE/ [/ 43/ ]/ 和/ SAGE/ [/ 44/ -/ 45/ ]/ 等/ ,/ 初步/ 经验/ 表明/ 这/ 是/ 很/ 有/ 前景/ 的/ 方法/ 和/ 技术/ ./ 新/ 方法/ 借鉴/ 了/ 动态/ 和/ 静态/ 分析/ 的/ 经验/ 和/ 不足/ ,/ 在/ 更/ 深层次/ 上/ 对/ 两类/ 方法/ 进行/ 结合/ ,/ 其/ 核心内容/ 为/ :/ (/ 1/ )/ 对/ 静态/ 符号执行/ 进行/ 扩展/ ,/ 混合/ 具体/ 执行/ ,/ 提出/ 轻量级/ 动态/ 符号执行/ 方法/ [/ 6/ ,/ 40/ ]/ :/ Concolic/ 执行/ ;/ (/ 2/ )/ 借助于/ 逐渐/ 实用化/ 的/ SMT/ 求解/ 器/ (/ Satisfi/ -/ abilityModuloTheorySolver/ )/ 技术/ 对/ 路径/ 约束/ 求解/ ;/ (/ 3/ )/ 使用/ 新/ 的/ 启发式/ 算法/ 探索/ 程序/ 的/ 路径/ 空间/ (/ 程序执行/ 树/ )/ [/ 44/ -/ 46/ ]/ ./ 4.1/ 整体/ 框架图/ 4/ 给出/ 总体/ 框架图/ ,/ 新/ 方法/ 结合/ 了/ 传统/ 的/ 模糊/ 测试/ ,/ 使用/ 模糊/ 器/ 产生/ 随机/ 输入/ 数据/ 并/ Concolic/ 执行/ 需要/ 测试/ 的/ 程序/ ,/ 同时/ 使用/ SMT/ 求解/ 器/ 检验所/ 执行/ 的/ 程序/ 路径/ 是否/ 满足/ 要/ 验证/ 的/ 性质/ ./ 每次/ 执行/ 结束/ 后/ ,/ 使用/ 启发式/ 算法/ 搜索/ 路径/ 空间/ ,/ 并/ 在/ 搜索/ 结果/ 中/ 按照/ 路径/ 选择/ 策略/ 选取/ 下/ 一条/ 需要/ 执行/ 的/ 路径/ ,/ 迭代/ 整个/ 过程/ ,/ 直到/ 所有/ 路径/ 执行/ 完毕/ 或者/ 系统/ 运行/ 时间/ 超过/ 了/ 提前/ 设置/ 好/ 的/ 时间/ 阈值/ ./ 4.2/ 轻量级/ 动态/ 符号执行/ 方法/ :/ Concolic/ 执行/ 基于/ 具体/ 执行/ 的/ 动态分析/ 工具/ 如/ Valgrind/ [/ 47/ ]/ 或/ Purify/ [/ 48/ ]/ 等/ 只/ 针对/ 某次/ 具体/ 执行/ 实例/ 作/ 分析/ ,/ 由于/ 具体/ 执行/ 是/ 精确/ 的/ ,/ 因而/ 不/ 产生/ 误报/ ./ 此类/ 工具/ 的/ 缺点/ 在于/ 过于/ 依赖/ 所/ 使用/ 的/ 具体/ 输入/ 的/ 典型性/ ,/ 只有/ 在/ 所/ 选取/ 的/ 具体/ 输入/ 能够/ 触发/ 程序/ 错误/ 的/ 情况/ 下/ ,/ 动态分析/ 工具/ 才能/ 捕获/ 错误/ ,/ 程序/ 的/ 输入/ 空间/ 过大/ 导致/ 程序/ 输入/ 的/ 选取/ 不/ 可能/ 覆盖/ 整个/ 空间/ ,/ 而/ 只能/ 是/ 其中/ 一部分/ ,/ 这是/ 导致/ 动态分析/ 工具/ 产生/ 漏报/ 的/ 根源/ ./ 符号执行/ 由于/ 实质/ 上/ 是/ 以/ 执行/ 树对/ 程序/ 输入/ 空间/ 做/ 等价/ 划分/ ,/ 并/ 以/ 每组/ 等价/ 类/ 作为/ 程序/ 输入/ ,/ 所有/ 能/ 使/ 程序/ 沿同/ 一条/ 路径/ 执行/ 的/ 输入/ 落入/ 同一/ 等价/ 类中/ ,/ 因此/ 能够/ 对/ 输入/ 数据/ 做到/ 最大/ 的/ 覆盖/ ,/ 但/ 其/ 作为/ 一种/ 静态方法/ ,/ 静态/ 符号执行/ 不能/ 获取/ 精确/ 的/ 运行/ 时/ 信息/ ,/ 其/ 分析/ 目标/ 包含/ 了/ 实际/ 不/ 可行/ 路径/ ,/ 导致/ 误报/ 的/ 产生/ ./ Concolic/ 执行/ 在/ 动态/ 与/ 静态/ 分析/ 技术/ 之间/ 做出/ 了/ 新/ 的/ 取舍/ 和/ 折中/ ,/ 混合/ 两种/ 执行/ 方式/ ,/ 在/ 具体/ 执行/ 的/ 同时/ 对/ 所/ 执行/ 到/ 的/ 代码/ 施行/ 符号执行/ ,/ 具体/ 执行/ 的/ 特性/ 决定/ 了/ 每次/ Concolic/ 执行/ 获取/ 的/ 路径/ 都/ 是/ 可行/ 路径/ ,/ 因此/ 避免/ 了/ 误报/ ,/ 这是/ Concolic/ 执行/ 相对/ 于/ 静态/ 符号执行/ 的/ 主要/ 优势/ 之一/ ./ 一次/ Concolic/ 执行/ 结束/ 时/ ,/ 其/ 路径/ 约束/ 是/ 一组/ 约束/ 的/ 合取/ ,/ 对/ 其中/ 某个/ 或/ 某/ 几个/ 约束/ 取反/ 的/ 同时/ 保持/ 其余部分/ 不变/ ,/ 则/ 可以/ 得到/ 路径/ 约束/ 的/ 一个/ 变体/ ,/ 利用/ SMTSolver/ 求解/ 这个/ 变换/ 后/ 的/ 新/ 约束/ ,/ 若有解/ ,/ 则/ 意味着/ 它/ 可能/ 对应/ 于/ 另/ 一条/ 可行/ 路径/ ./ 理论/ 上/ ,/ 若/ 程序/ 不/ 存在/ 无限/ 路径/ (/ 没有/ 死循环/ 和/ 无穷/ 递归/ )/ ,/ 迭代/ 此/ 过程/ 可以/ 遍历/ 执行/ 树中/ 所有/ 路径/ ./ Concolic/ 执行/ 使用/ SMTSolver/ 求解/ 路径/ 约束/ ,/ 尽管/ 近年来/ SMTSolver/ 有/ 了/ 长足发展/ ,/ 逐渐/ 步入/ 实用化/ ,/ 但/ 其/ 能够/ 求解/ 的/ 约束/ 类型/ 依然/ 有限/ ,/ 比如/ ,/ 就/ 目前/ 所知/ 并/ 没有/ 发现/ 任何/ 一款/ 求解/ 器/ 能够/ 完全/ 支持/ 非线性/ 算术/ 理论/ ./ 在/ 程序执行/ 到/ 某条/ 分支/ 时/ ,/ 若/ 其/ 产生/ 的/ 约束/ 超出/ 了/ 求解/ 器/ 的/ 求解/ 能力/ 范围/ ,/ 传统/ 的/ 静态/ 符号执行/ 就/ 会/ 卡壳/ ,/ 于是/ 丢弃/ 掉/ 这条/ 路径/ ,/ 进而/ 可能/ 导致/ 漏报/ ./ 而/ Concolic/ 执行/ 在/ 此处/ 则/ 会/ 使用/ 当前/ 的/ 具体/ 值/ 代替/ 符号/ 值/ ,/ 因而/ 得到/ 一个/ 不/ 完全/ 的/ 、/ 包含/ 了/ 具体/ 值/ 的/ 简化/ 的/ 符号/ 表达式/ ,/ 这/ 就/ 使/ 简化/ 后/ 的/ 路径/ 约束/ 落/ 回到/ SMTSolver/ 所/ 支持/ 的/ 理论/ 中/ ,/ 这样/ 一方面/ 降低/ 了/ SMT/ 求解/ 器/ 的/ 使用/ 限制/ ,/ 另一方面/ 则/ 保证/ 算法/ 能够/ 继续/ 运行/ 进而/ ,/ 提高/ 了/ 代码/ 覆盖率/ ,/ 这个/ 过程/ 被/ 称为/ 路径/ 约束/ 的/ 部分/ 具体化/ ,/ 是/ Concolic/ 相对/ 于/ 静态/ 分析方法/ 的/ 另/ 一个/ 主要/ 优势/ ./ 为了/ 更/ 清楚/ 地/ 阐述/ ,/ 考虑/ 图/ 5/ (/ a/ )/ 所示/ C/ 代码/ ./ Page8/ 图/ 5/ 程序运行/ 示例/ 图图/ 5/ (/ b/ )/ 为/ 相应/ 的/ 符号执行/ 树/ ,/ 假设/ 第/ 1/ 次/ 运行/ 这/ 段/ 代码/ 时/ ,/ 随机/ 生成/ x/ =/ =/ 2/ ,/ y/ =/ =/ 33/ ,/ 执行/ 到/ 第/ 12/ 行时/ ,/ 分支/ 条件/ x/ / x/ / x/ =/ =/ y/ 不/ 满足/ ,/ 因此/ 下/ 一步/ 选择/ else/ 分支/ ,/ 因此/ 第/ 1/ 次/ 执行/ 遗漏/ 了/ then/ 分支/ (/ 第/ 13/ 行/ )/ ./ 第/ 1/ 次/ 执行/ 结束/ 后/ ,/ 我们/ 期望/ 得到/ 满足/ x/ / x/ / x/ =/ =/ y/ 的/ x/ 和/ y/ 以/ 在/ 之后/ 的/ 执行/ 中/ 覆盖/ 第/ 13/ 行/ ,/ 然而/ ,/ x/ / x/ / x/ =/ =/ y/ 是/ 非线性/ 约束/ ,/ 超出/ 了/ 求解/ 器/ 的/ 求解/ 能力/ 范围/ ,/ 静态/ 符号执行/ 在/ 此时/ 会/ 丢弃/ 掉/ 这个/ 分支/ ,/ 因而/ 导致/ 漏报/ ./ Concolic/ 由于/ 混合/ 了/ 具体/ 执行/ ,/ 可以/ 获取/ x/ 和/ y/ 在/ 上/ 一次/ 运行/ 中/ 的/ 具体/ 取值/ 分别/ 为/ 2/ 和/ 33/ ,/ 如果/ 固定/ x/ 的/ 值/ ,/ 则/ 可以/ 得到/ 部分/ 具体化/ 的/ 路径/ 约束/ 8/ =/ =/ Y/ ,/ 对/ 其/ 求解/ 可/ 得/ :/ y/ =/ =/ 8/ ./ 第/ 2/ 次/ 运行/ 时/ 使用/ x/ =/ =/ 2/ ,/ y/ =/ =/ 8/ 作为/ 新/ 的/ 测试/ 输入/ ,/ 使/ 第/ 13/ 行/ 得到/ 运行/ ,/ 触发/ (/ 并/ 捕获/ )/ 了/ 程序运行/ 时/ 错误/ ./ 4.3/ 路径/ 空间/ 启发式/ 搜索算法/ 和/ 路径/ 选择/ 自动化/ 白盒/ 测试/ 过程/ 遍历/ 程序执行/ 树中/ 的/ 路径/ ,/ 并/ 针对/ 每条/ 路径/ 生成/ 测试数据/ ,/ 由于/ 路径/ 爆炸/ 问题/ 的/ 存在/ ,/ 完全/ 遍历/ 整个/ 路径/ 空间/ 常常/ 是/ 不/ 可能/ 的/ ,/ 因此/ 如何/ 设计/ 启发式/ 算法/ ,/ 在/ 采用/ 某种/ 覆盖率/ 标准/ 的/ 前提/ 下/ ,/ 尽可能/ 覆盖/ 到/ 更/ 多/ 的/ 代码/ 和/ 最/ 可能/ 触发/ 程序/ 错误/ 的/ 路径/ 就/ 变得/ 极为重要/ ./ 研究者/ 提出/ 了/ 多种/ 启发式/ 算法/ ,/ 这里/ 简单/ 介绍/ 其中/ 较/ 有/ 影响/ 的/ 两种/ :/ 对/ 路径/ 约束/ 变异/ 和/ 对/ 基本块/ 覆盖/ 打分/ 方法/ ./ (/ 1/ )/ 对/ 路径/ 约束/ 变异/ ./ Concolic/ 执行/ 在/ 每次/ 执行/ 完毕/ 一条/ 程序/ 路径/ 后/ 会/ 得到/ 一组/ 路径/ 约束/ ,/ DART/ 和/ CUTE/ 对/ 其中/ 最后/ 一个/ 约束/ 取反/ 以/ 产生/ 新/ 的/ 路径/ 约束/ ,/ 实质/ 上/ 是/ 对/ 符号执行/ 树/ 做/ 深度/ 优先/ 搜索/ ,/ 这/ 意味着/ 对/ 一条/ 路径/ 上/ 的/ 非/ 叶子/ 节点/ 的/ 符号执行/ 将会/ 执行/ 多次/ ,/ 同样/ ,/ 对/ 相同/ 的/ 中间性/ 路径/ 约束/ 需要/ 多次/ 求解/ ,/ 这/ 给/ 符号执行/ 引擎/ 带来/ 了/ 很大/ 负担/ ./ SAGE/ 对此/ 改进/ 并/ 提出/ 按代/ 搜索算法/ ,/ 每/ 得到/ 一组/ 路径/ 约束/ 后/ ,/ 按照/ 不同/ 组合/ 对/ 其中/ 多个/ 约束/ 取反/ ,/ 因而/ 可以/ 同时/ 得到/ 多组/ 新/ 的/ 路径/ 约束/ ,/ 这种/ 方法/ 一方面/ 极大/ 减少/ 了/ 重复性/ 计算/ ,/ 另一方面/ 可以/ 更/ 方便/ 地/ 使用/ 并行/ 求解/ 算法/ 在/ 多台/ 机器/ 上/ 同时/ 对/ 路径/ 约束/ 进行/ 求解/ ./ (/ 2/ )/ 对/ 基本块/ 覆盖/ 打分/ ./ 这种/ 方法/ 被/ KLEE/ [/ 43/ ]/ 采用/ ,/ 程序/ 在/ 每个/ 分支/ 处/ 使用/ 打分/ 函数/ 给/ 当前/ 路径/ 已经/ 执行/ 的/ 部分/ 设定/ 分值/ ,/ 打分/ 的/ 依据/ 可以/ 为/ :/ 距离/ 未/ 覆盖/ 指令/ 的/ 距离/ 、/ 调用/ 栈/ 高度/ 或/ 被/ 调用/ 符号/ 进程/ 的/ 最近/ 一次/ 执行/ 是否/ 覆盖/ 了/ 新/ 基本块/ ./ KLEE/ 被/ 设计/ 为/ 可以/ 同时/ 执行/ 多条/ 路径/ ,/ 可以/ 视为/ 对/ 程序/ 路径/ 的/ 并发/ 执行/ ,/ 每次/ 使用/ 调度/ 算法/ 在/ 现存/ 的/ 路径/ 集合/ 中/ 选取/ 一条/ 执行/ ,/ 其/ 选取/ 的/ 标准/ 就是/ 路径/ 集合/ 中/ 分值/ 最高者/ ./ 这种/ 方法/ 借鉴/ 了/ 贪心/ 算法/ 的/ 思想/ ,/ 即/ 最/ 重要/ 的/ 应该/ 被/ 优先/ 处理/ ./ 4.4/ 安全/ 性质/ 检验/ 模糊/ 测试/ 能/ 触发/ 很多/ 类型/ 的/ 程序/ 错误/ ,/ 导致/ 程序/ 崩溃/ ,/ 但/ 在/ 有/ 的/ 情况/ 下/ 出现/ 的/ 异常/ 行为/ 并/ 不会/ 使/ 程序/ 崩溃/ ,/ 如/ 数组/ 溢出/ 等/ ,/ 这种/ 隐蔽/ 的/ 程序/ 漏洞/ 对/ 黑客/ 更/ 有/ 价值/ ./ 异常/ 行为/ 的/ 难以/ 观察/ 导致/ 模糊/ 测试工具/ 错过/ 了/ 发现/ 漏洞/ 的/ 机会/ ,/ 对/ 程序/ 出错/ 的/ 类型/ 进行/ 总结/ 和/ 深入/ 理解/ ,/ 获取/ 能够/ 刻画/ 程序/ 错误/ 本质/ 的/ 安全/ 性质/ ,/ 并/ 检验/ 一组/ 输入/ 是否/ 破坏/ 了/ 此/ 性质/ 是/ 解决/ 此/ 问题/ 的/ 基本思路/ ./ 传统/ 的/ 模糊/ 测试/ 通常/ 结合/ AppVerifier/ 或/ Purify/ [/ 48/ ]/ 等/ 动态分析/ 工具/ 进行/ 运行/ 时/ 性质/ 检验/ ,/ 由于/ 使用/ 的/ 是/ 具体/ 执行/ ,/ 这种/ 方式/ 一次/ 只能/ 针对/ 一组/ 具体/ 输入/ 检查/ 其/ 是否/ 破坏/ 了/ 安全/ 性质/ ,/ 因而/ 被/ 称为/ 被动式/ 运行/ 时/ 性质/ 检验/ ./ Godefroid/ 等/ 人/ [/ 49/ ]/ 对/ 被动/ 运行/ 时/ 检验/ 方法/ 进行/ 扩展/ ,/ 提出/ 了/ 主动式/ 运行/ 时/ 检验/ 的/ 概念/ ,/ 期望/ 能够/ 检验/ 沿/ 同一/ 路径/ 执行/ 的/ 所有/ 输入/ 是否/ 都/ 满足/ 待/ 检验/ 性质/ ./ 其/ 方法/ 为/ :/ 在/ 待/ 检验/ 程序/ 点/ 注入/ 描述/ 安全/ 性质/ 的/ 运行/ 时/ 符号/ 约束/ ,/ 若此/ 约束/ Page9/ 的/ 否定/ 可/ 被/ 求解/ ,/ 则/ 求解/ 器/ 生成/ 的/ 测试/ 输入/ 即/ 为/ 能/ 破坏/ 安全/ 性质/ 的/ 反例/ ./ 在/ 模型/ 检验/ 中/ ,/ 针对/ 特定/ 系统/ ,/ 确定/ 需要/ 检验/ 哪些/ 安全/ 性质/ 才能/ 使人/ 信服/ 的/ 度量/ 系统/ 的/ 可信/ 程度/ 和/ 安全/ 质量/ ,/ 是/ 一件/ 需要/ 花费/ 精力/ 仔细/ 思考/ 的/ 事情/ ./ 而/ 对于/ 软件/ 漏洞/ 检测/ 而言/ ,/ 该/ 问题/ 得到/ 了/ 很大/ 程度/ 的/ 简化/ ,/ 待/ 检验/ 安全/ 性质/ 通常/ 来自/ 于/ 对/ 已知/ 漏洞/ 类型/ 和/ 模式/ 的/ 总结/ ./ 较/ 典型/ 的/ 安全/ 性质/ 包括/ 数组/ 越界/ 访问/ 、/ 空/ 指针/ 引用/ 、/ 除/ 零/ 错误/ 、/ 整数/ 溢出/ 、/ 栈/ 溢出/ 等等/ ./ 以除/ 零/ 错误/ 为例/ ,/ 若/ 一次/ 混合/ 符号执行/ 过程/ 中/ 遇到/ 一条/ 除法/ 指令/ ,/ 且/ 本次/ 执行/ 中/ 除数/ 不为/ 零/ ,/ 主动式/ 安全/ 性质/ 检验/ 将/ 产生/ 安全/ 性质/ 约束/ 并/ 向/ 求解/ 器/ 询问/ ,/ 是否/ 存在/ 一组/ 输入/ ,/ 使/ 程序/ 沿/ 本次/ 执行/ 路径/ 执行/ 时使/ 除数/ 为/ 零/ ?/ 再/ 以/ 数组/ 越界/ 访问/ 错误/ 为例/ ,/ 设/ 数组/ 上/ 下界/ 分别/ 为/ lb/ 和/ hb/ ,/ 数组/ 索引/ 变量/ 为/ i/ ,/ 其中/ lb/ 通常/ 为/ 0/ ,/ hb/ 可以/ 为/ 固定值/ (/ 静态/ 分配/ )/ ,/ 或者/ 为/ 变量/ (/ 动态分配/ )/ ,/ 求解/ 是否/ 存在/ 一组/ 输入/ 使/ I/ </ LB/ 或/ I/ >/ HB/ 成立/ ,/ 其中/ LB/ 、/ HB/ 和/ I/ 分别/ 为/ 程序/ 变量/ lb/ 、/ hb/ 和/ i/ 所/ 对应/ 的/ 符号/ 变量/ ,/ 若/ 存在/ 这种/ 输入/ ,/ 则/ 表示/ 程序/ 存在/ 数组/ 越界/ 访问/ 错误/ ./ 安全/ 性质/ 检验/ 伴随/ 着/ 符号执行/ ,/ 需要/ 求解/ 器/ 的/ 参与/ ,/ 检验/ 的/ 安全/ 性质/ 越/ 多/ 意味着/ 算法/ 运行/ 的/ 速度/ 越慢/ ./ 若/ 预先/ 知道/ 或者/ 猜测/ 待/ 测试程序/ 中/ 某种/ 特定/ 类型/ 的/ 漏洞/ 存在/ 较/ 多/ ,/ 或者/ 我们/ 最/ 关心/ 哪/ 种/ 类型/ 的/ 漏洞/ ,/ 则/ 可以/ 有/ 针对性/ 地/ 检查/ 相应/ 的/ 安全/ 性质/ ,/ 这种/ 轻量级/ 的/ 检验/ 方法/ 能够/ 极大/ 地/ 减轻/ 计算/ 的/ 负担/ ,/ 被/ CatchCov/ 等/ 工具/ 采用/ [/ 50/ ]/ ./ 5/ 实现/ 技术/ 自动化/ 白盒/ 模糊/ 测试/ 的/ 实现/ 需要/ 综合利用/ 多种/ 技术/ ,/ 内容/ 较为/ 繁多/ ./ 本文/ 着重/ 介绍/ 其中/ 的/ 程序/ 插装/ 、/ 程序执行/ 环境模拟/ 和/ 求解/ 器/ 技术/ ./ 5.1/ 插装/ Concolic/ 执行/ 和/ 安全/ 性质/ 检验/ 通过/ 对/ 程序/ 的/ 实际/ 执行/ 情况/ 进行/ 观察/ ,/ 以/ 获取/ 其/ 运行/ 时/ 信息/ 和/ 动态/ 语义/ ,/ 并/ 以此/ 为/ 基础/ 对/ 其/ 安全/ 语义/ 性质/ 进行/ 推理/ ./ 是否/ 能够/ 准确/ 可靠/ 地/ 捕获/ 程序执行/ 时/ 的/ 动态/ 语义/ 信息/ ,/ 势必/ 将/ 影响/ 到/ 程序/ 语义/ 推理/ 的/ 有效性/ ./ 程序/ 插装/ 技术/ 是/ 实现/ 这一/ 目的/ 的/ 主要/ 技术手段/ ,/ 本文/ 主要/ 介绍/ 4/ 种/ 插装/ 方式/ :/ (/ 1/ )/ 基于/ 源代码/ 源代码/ 插装/ 技术/ 可/ 分为/ 手动/ 和/ 自动/ 两种/ ,/ 手动/ 插装/ 需要/ 分析/ 人员/ 手工/ 对/ 代码/ 插入/ 附加/ 代码/ ,/ 其/ 优点/ 是/ 较为/ 灵活/ ,/ 且/ 不/ 需要/ 额外/ 的/ 技术支持/ ,/ 但/ 程序/ 规模/ 过大时/ ,/ 插装/ 工作/ 会/ 过于/ 繁琐/ ./ 自动/ 插装/ 首先/ 使用/ 词法/ 分析/ 和/ 语法分析/ 对/ 源代码/ 进行/ 处理/ ,/ 确定/ 插/ 装点/ ,/ 之后/ 根据/ 插/ 装点/ 的/ 类型/ 加入/ 附加/ 代码/ ,/ 典型/ 工具/ 如/ RationalRose/ ,/ 它/ 通过/ 修改/ 被/ 插装/ 源代码/ 所/ 对应/ 的/ 抽象/ 语法/ 树以/ 达到/ 源代码/ 到/ 源代码/ 的/ 转换/ ,/ 实现/ 插装/ 目的/ ./ (/ 2/ )/ 基于/ 中间代码/ 基于/ 中间代码/ 的/ 安全漏洞/ 检测/ 通常/ 借助于/ 工具/ 先/ 将/ 源代码/ 编译/ 为/ 某种/ 中间/ 语言/ 代码/ 如/ CIL/ [/ 51/ ]/ 、/ LLVM/ [/ 52/ ]/ 等/ ,/ 之后/ 针对/ 每条/ 中间/ 语言/ 指令/ 插入/ 调用/ 指令/ ,/ 对/ 事先/ 编写/ 的/ 符号执行/ 引擎/ 库/ 的/ 函数/ 进行/ 调用/ ,/ 最后/ 将/ 插/ 装后/ 得到/ 的/ 中间/ 语言/ 代码/ 编译成/ 可执行程序/ ,/ 在/ 其/ 实际/ 执行/ 过程/ 中/ 实现/ 动态/ 符号执行/ ./ 相比/ 于/ 源代码/ 插装/ ,/ 这种/ 方式/ 的/ 通用性/ 得到/ 较大/ 提高/ ,/ 但/ 必须/ 以/ 能够/ 获取/ 源代码/ 为/ 前提/ ,/ 因此/ 不能/ 较/ 好/ 地/ 处理程序/ 对/ 未/ 开源/ 的/ 第三方/ 库/ 的/ 调用/ ./ (/ 3/ )/ 动态/ 二进制/ 插装/ 在/ 不能/ 获取/ 程序/ 源代码/ 的/ 情况/ 下/ ,/ 可以/ 借助于/ 动态/ 插装/ 工具/ 对/ 可执行程序/ 做/ 动态/ 二进制/ 插装/ ,/ 比较/ 知名/ 的/ 工具/ 有/ Valgrind/ [/ 47/ ]/ 、/ Pin/ [/ 53/ ]/ 等/ ./ 以/ 这种/ 方式/ 工作/ 的/ 系统/ ,/ 如/ BitScope/ [/ 54/ ]/ 等/ ,/ 在/ 监视/ 程序/ 实际/ 执行/ 的/ 同时/ ,/ 捕获/ 指令/ 序列/ ,/ 根据/ 指令/ 的/ 种类/ ,/ 调用/ 预先/ 编写/ 的/ 符号执行/ 引擎/ 和/ 分析/ 模块/ ./ (/ 4/ )/ 二进制/ 离线/ 插装/ 对于/ 大型/ 程序/ ,/ 一条/ 执行/ 路径/ 的/ 指令/ 数/ 可以/ 达到/ 数十亿/ 条之多/ ,/ 这/ 对/ 分析/ 工作/ 带来/ 极大/ 困难/ ,/ 超出/ 了/ 求解/ 器/ 的/ 正常/ 工作/ 能力/ 范围/ ,/ 微软/ 的/ SAGE/ 工具/ 针对/ 这种/ 情况/ ,/ 提出/ 离线/ 分析/ 方式/ ,/ 大致/ 步骤/ 为/ :/ ①/ 抓取/ 二进制/ 执行/ 轨迹/ ;/ ②/ 对/ 其/ 静态/ 插装/ ;/ ③/ 重放/ 插/ 装后/ 轨迹/ 并/ 获取/ 需要/ 的/ 约束条件/ ./ 5.2/ 程序执行/ 环境模拟/ 测试/ 的/ 根本/ 目的/ 是/ 通过/ 生成/ 不同/ 的/ 测试/ 输入/ 数据/ 来/ 控制/ 和/ 观察/ 程序/ 的/ 执行/ ,/ 从/ 程序设计/ 的/ 角度看/ ,/ 这些/ 输入/ 数据/ 会以/ 实参/ 的/ 形式/ 传递/ 给/ 被/ 调用/ 的/ 函数/ ,/ 但/ 就/ 实际/ 执行/ 的/ 角度/ 而言/ ,/ 多数/ 程序/ 输入/ 来自/ 于/ 外部环境/ 如/ 键盘/ 、/ 磁盘/ 文件/ 、/ 网络/ 数据包/ 等/ ./ 不/ 与/ 外部环境/ 交互/ 的/ 程序/ 是/ 罕见/ 的/ ,/ 数据/ 表明/ 使用/ 面向对象/ 语言/ 设计/ 的/ 软件/ 中/ 90.7/ %/ 的/ 类会/ 产生/ 环境/ 交互/ ./ 文献/ [/ 55/ ]/ 指出/ ,/ 很多/ 研究性/ 项目/ 声称/ 的/ 覆盖率/ 很/ 高/ 是/ 由于/ 其/ 选择/ 的/ 测试/ 集/ 太小/ 且/ 没有/ 环境/ 交互/ ,/ 环境/ 交互/ 能够/ 极大/ 影响/ 覆盖率/ ./ 程序执行/ 环境模拟/ 技术/ 通过/ 建立/ 虚拟/ 的/ 程序执行/ 环境/ ,/ 模拟程序/ 的/ 外部/ 输入/ 并/ 精确/ 控制程序/ 输入/ 数据/ 的/ 内容/ ,/ 以/ 达到/ 测试/ 目的/ ./ 从/ 实现/ 的/ 角度/ 来看/ ,/ Page10/ 环境/ 建模/ 主要/ 有/ 两种/ 方式/ :/ (/ 1/ )/ 虚拟机/ 方法/ ;/ (/ 2/ )/ 重写/ 库函数/ 并/ 截取/ 系统/ 调用/ 的/ 方法/ ./ S2E/ [/ 56/ ]/ 是/ 以/ 虚拟机/ 形式/ 实现/ 环境/ 建模/ 的/ 典型/ ,/ 这种/ 方法/ 能/ 对/ 程序执行/ 的/ 外部环境/ 做到/ 完全/ 控制/ ,/ 灵活/ 而/ 强大/ ,/ 但/ 对/ 工程/ 和/ 技术/ 的/ 要求/ 非常/ 高/ ,/ 实现/ 起来/ 工作量/ 很大/ ./ KLEE/ 是/ 后者/ 的/ 典范/ ,/ 优点/ 在于/ 可以/ 灵活/ 选择/ 环境/ 建模/ 的/ 强度/ ,/ 从/ 技术/ 的/ 角度/ 说/ ,/ 实现/ 起来/ 比较/ 灵活/ ./ 5.3/ 求解/ 器/ 近十年/ 来/ ,/ 布尔/ 可/ 满足/ 性/ (/ BooleanSatisfiability/ ,/ SAT/ )/ 求解/ 技术/ 飞速发展/ ,/ 从/ 2000/ 年/ 的/ Grasp/ 到/ 2007/ 年/ 的/ Rsat/ ,/ 主流/ 的/ SAT/ 求解/ 器/ 的/ 效率/ 提高/ 了/ 近/ 200/ 倍/ [/ 57/ ]/ ,/ 目前/ SAT/ 求解/ 器/ 可以/ 高效/ 地/ 处理/ 数百万/ 变量/ 的/ 问题/ ,/ 已/ 成功/ 应用/ 于/ 模型/ 检验/ 、/ 定理/ 证明/ 等/ 领域/ ./ SAT/ 求解/ 器/ 用于/ 判定/ 命题逻辑/ 公式/ 的/ 可/ 满足/ 性/ ,/ 命题逻辑/ 的/ 表达能力/ 相对/ 较弱/ ,/ SMT/ 求解/ 器以/ SAT/ 求解/ 技术/ 为/ 基础/ ,/ 引入/ 基于/ 一阶/ 谓词/ 逻辑/ 的/ 各种/ 理论/ ,/ 将/ 能力/ 范围/ 扩充/ 到/ 判定/ 一阶/ 谓词/ 逻辑/ 公式/ 的/ 可/ 满足/ 性/ ./ 表/ 1/ 列举/ 4/ 种/ 比较/ 常见/ 的/ 求解/ 器/ ,/ 包括/ 其/ 支持/ 的/ 操作系统/ 、/ 支持/ 的/ 理论/ 和/ API/ ./ 求解/ 器/ 操作系统/ 支持/ 的/ 理论/ 和/ 特性/ APICVC4LinuxSTPuclidLinux/ 空/ 理论/ 整数/ 线性/ 算术/ Z36/ 关键性/ 挑战/ 和/ 解决/ 现状/ Concolic/ 执行/ 是/ 对/ 静态/ 符号执行/ 的/ 发展/ ,/ 由于/ 混合/ 了/ 动态/ 执行/ 和/ 静态/ 符号执行/ ,/ 传统意义/ 符号执行/ 方法/ 自身/ 难以克服/ 的/ 诸多/ 难题/ 也/ 同时/ 被/ 引入/ 到/ 新/ 的/ 方法/ ,/ 如何/ 面对/ 并/ 解决/ 这些/ 问题/ ,/ 是/ 决定/ Concolic/ 方法/ 是否/ 能/ 获得成功/ 的/ 关键/ ,/ 以下/ 就/ 其中/ 研究/ 的/ 一部分/ 热点问题/ 简要/ 介绍/ :/ (/ 1/ )/ 对/ 指针/ 和/ 数组/ 的/ 处理/ ./ 早期/ 的/ 静态/ 符号执行/ 工具/ 较少/ 对/ 指针/ 和/ 数组/ 建模/ ,/ 如何/ 对/ 程序/ 中/ 的/ 指针/ 和/ 数组/ 进行/ 建模/ 是/ 符号执行/ 工具/ 必须/ 要/ 处理/ 的/ 难题/ 之一/ ./ DART/ 使用/ 具体/ 执行/ 绕过/ 了/ 这/ 一/ 问题/ ,/ 但是/ 具体/ 执行/ 是/ 对/ 程序/ 可/ 达/ 状态/ 集合/ 的/ 下/ 近似/ ,/ 因而/ 存在/ 漏报/ ./ CUTE/ 在/ DART/ 的/ 基础/ 上/ 针对/ 指针/ 建立/ 了/ 较/ 简单/ 的/ 处理/ ,/ 支持/ 指针/ 之间/ 相等/ 和/ 不/ 等/ 关系/ 的/ 比较/ ./ EXE/ [/ 58/ -/ 60/ ]/ 认为/ 指针/ 和/ 数组/ 可以/ 被/ 统一/ 地/ 看待/ 为/ BYTE/ 类型/ 的/ 数组/ ,/ 并/ 利用/ 其/ 附带/ 的/ STP/ 求解/ 器/ 对/ BYTE/ 类型/ 数组/ 的/ 内置/ 支持/ 来/ 解决/ 这一/ 问题/ ./ SAGE/ 利用/ Z3/ 求解/ 器/ 做/ 了/ 类似/ 的/ 处理/ ,/ Z3/ [/ 61/ ]/ 求解/ 器/ 支持/ 数组/ 理论/ ,/ 且/ 在/ BYTE/ 类型/ 数组/ 之外/ 也/ 支持/ 其他/ 类型/ 的/ 数组/ ./ 需要/ 特别/ 指出/ 的/ 是/ ,/ C语言/ 中/ 的/ 指针/ 问题/ 可以/ 转化/ 为/ 数组/ 的/ 上/ 下界/ 问题/ ,/ 可以/ 使用/ 整数/ 区间/ 来/ 进行/ 表示/ ,/ 进而/ 可以/ 采用/ 统一/ 的/ 算法/ 加以/ 处理/ ./ (/ 2/ )/ 对/ 过程/ 调用/ 的/ 处理/ ./ 静态/ 符号执行/ 工具/ 的/ 另/ 一个/ 问题/ 是/ 如何/ 处理过程/ 调用/ ,/ DART/ 和/ CUTE/ 工具/ 对/ 过程/ 调用/ 只/ 做/ 具体/ 执行/ ,/ 其/ 优点/ 在于/ 能够/ 利用/ 精确/ 的/ 运行/ 时/ 信息/ 避免/ 静态/ 过程/ 间/ 分析/ 导致/ 的/ 误报/ ./ 其/ 问题/ 是/ ,/ 一次/ 执行/ 结束/ 后/ ,/ 这些/ 信息/ 就/ 被/ 丢弃/ ,/ 之后/ 对/ 同一/ 函数/ 的/ 调用/ 不能/ 利用/ 以前/ 对/ 函数/ 已经/ 获取/ 的/ 知识/ ,/ 造成/ 了/ 计算资源/ 的/ 浪费/ ./ Godefroid/ [/ 62/ ]/ 提出/ 使用/ 函数/ 摘要/ 来/ 处理/ 这一/ 问题/ ,/ 其/ 过程/ 是/ :/ 先/ 通过/ 静态/ 结构/ 分析/ 获得/ 程序/ 调用/ 图/ 并/ 使用/ 图/ 算法/ 将/ 其/ 划分/ 为/ 多个/ 子图/ ,/ 每个/ 子图/ 作为/ 后续/ 处理/ 的/ 单元/ ;/ 然后/ 使用/ 谓词/ 公式/ 以/ 部分/ (/ 不/ 完全/ )/ 程序/ 规约/ 的/ 形式/ 对/ 函数/ 的/ 功能/ 编码/ ,/ 在/ 后续/ 的/ 符号执行/ 过程/ 中/ 可以/ 重用/ 已经/ 获取/ 的/ 函数/ 摘要/ 做/ 为/ 路径/ 约束/ 的/ 一部分/ 以/ 避免/ 重复/ 计算/ ./ Joshi/ 等/ 人/ [/ 63/ ]/ 提出/ 对/ 函数调用/ 先/ 抽象/ 后求/ 精/ 的/ 思路/ ,/ 程序/ 在/ Concolic/ 执行/ 过程/ 中/ 遇到/ 函数调用/ 时/ 只/ 对/ 被/ 调用函数/ 做/ 具体/ 执行/ ,/ 符号执行/ 引擎/ 并/ 不/ 进入/ 被/ 调用/ 的/ 函数/ ,/ 而是/ 在/ 函数/ 返回/ 后/ ,/ 以/ 其/ 输出/ 作为/ 新/ 的/ 符号/ 变量/ 加入/ 到/ 符号/ 状态/ ,/ 并/ 继续/ 运行/ 程序/ ./ 本次/ 执行/ 结束/ 后/ ,/ 回到/ 调用/ 点/ ,/ 根据/ 执行/ 的/ 结果/ 搜索/ 被/ 调用函数/ 的/ 路径/ 空间/ ,/ 利用/ 本次/ 执行/ 已/ 获得/ 的/ 信息/ 只/ 搜集/ 所/ 需/ 部分/ 的/ 路径/ 约束/ 从而/ 避免/ 了/ 枚举/ 所有/ 路径/ ,/ 达到/ 节省/ 计算/ 的/ 目的/ ./ (/ 3/ )/ 路径/ 爆炸/ 问题/ ./ 符号执行/ 可以/ 被/ 视为/ 程序执行/ 树上/ 各条/ 分支/ 的/ 枚举/ 过程/ ,/ 由于/ 循环/ 和/ 调用/ 等/ 程序结构/ 的/ 存在/ ,/ 程序/ 的/ 执行/ 树/ 的/ 分支/ 可能/ 无限/ ./ 处理/ 循环/ 的/ 直接/ 方法/ 是/ 设置/ 最高/ 阈值/ ,/ 即/ 只/ 对/ 其/ 做/ 有限/ 次数/ 的/ 搜索/ ,/ 这种/ 方法/ 类似/ 于/ 限界/ 符号执行/ ./ 一种/ 比较/ 新颖/ 的/ 方法/ 是/ 路径/ 约束/ 抽象/ 方法/ ,/ 通过/ 对/ 循环体/ 先/ 抽象/ 后求/ 精/ 的/ 方式/ 来/ 处理/ 循环/ 问题/ [/ 64/ ]/ ./ Boonstoppel/ 等/ 人/ [/ 65/ ]/ 在/ EXE/ 工具/ 的/ 基础/ 上/ ,/ 根据/ 程序/ 的/ 执行/ 特点/ 提出/ 了/ 路径/ 剪裁/ 算法/ ,/ 实验/ 结果表明/ 该/ 方法/ 可较/ 好/ 地/ 缓解/ 路径/ 爆炸/ 问题/ ,/ 由于/ 符号执行/ 的/ 实现/ 机制/ Page11/ 不同/ ,/ EXE/ 的/ 升级/ 版本/ KLEE/ 并/ 没有/ 使用/ 这个/ 算法/ ./ 此外/ ,/ 实现/ Concolic/ 执行/ 的/ 并行/ 化/ ,/ 借助于/ 大规模/ 并行计算/ 能力/ 提高/ 解题/ 的/ 规模/ 和/ 速度/ [/ 66/ ]/ ,/ 在/ 多台计算机/ 上/ 并行处理/ 程序/ 的/ 多条/ 路径/ 是/ 另/ 一种/ 缓解/ 路径/ 爆炸/ 问题/ 的/ 有效途径/ ./ (/ 4/ )/ 覆盖率/ 和/ 路径/ 选择/ 问题/ ./ 关注/ 如何/ 选取/ 较少/ 的/ 路径/ 就/ 能够/ 覆盖/ 大多数/ 代码/ ./ Concolic/ 执行/ 需要/ 不断/ 选取/ 下/ 一条/ 需要/ 执行/ 的/ 程序/ 路径/ ,/ 因此/ 路径/ 空间/ 搜索/ 和/ 路径/ 选择/ 算法/ 决定/ 了/ 整个/ 系统/ 最终/ 能/ 达到/ 的/ 覆盖率/ ./ 较/ 好/ 的/ 路径/ 选择/ 方法/ 如/ KLEE/ 使用/ 的/ 基本块/ 打分/ 方法/ ,/ 能够/ 尽量/ 执行/ 并/ 覆盖/ 更/ 多/ 基本块/ 的/ 代码/ ./ 另外/ ,/ 恰当/ 的/ 路径/ 空间/ 搜索算法/ 能够/ 及早/ 发现/ 程序/ 错误/ ,/ 比如/ SAGE/ 在/ DART/ 的/ 深度/ 优先/ 搜索算法/ 上/ 进行/ 改进/ 提出/ 了/ 按代/ 搜索算法/ ,/ 作者/ 声称/ [/ 44/ -/ 45/ ]/ 大多数/ 发现/ 的/ 错误/ 都/ 是/ 在/ 四代/ 变异/ 之前/ 发现/ 的/ ./ Burnim/ 等/ 人/ [/ 46/ ]/ 提出/ 了/ CREST/ 系统/ ,/ 并/ 对/ 多种/ 启发式/ 算法/ 做/ 了/ 综合/ 比较/ ,/ 文献/ [/ 46/ ]/ 是/ 关于/ 如何/ 选取/ 启发式/ 算法/ 搜索/ 路径/ 空间/ 的/ 较/ 好/ 的/ 综述/ 文章/ ./ 如何/ 通过/ 更/ 多/ 的/ 工程/ 实践/ 观察/ 到/ 不同/ 类型/ 程序/ 的/ 执行/ 特征/ 和/ 现象/ ,/ 结合/ 并/ 利用/ 其他/ 分析方法/ 的/ 思路/ 和/ 成果/ ,/ 从/ 新/ 的/ 角度/ 对/ 问题/ 建模/ 并/ 提出/ 更/ 先进/ 的/ 算法/ ,/ 是/ 值得/ 长期/ 研究/ 的/ 问题/ ./ (/ 5/ )/ 性能/ 问题/ ./ Concolic/ 执行/ 通过/ 程序/ 插装/ 实现/ 符号执行/ ,/ 并/ 使用/ SMT/ 求解/ 器/ 对/ 符号执行/ 过程/ 中/ 获取/ 的/ 路径/ 约束/ 进行/ 求解/ ./ 据统计/ ,/ 2000/ 行/ C/ 代码/ 插装后/ 能/ 达到/ 40000/ 行/ [/ 60/ ]/ ,/ 这/ 不仅/ 意味着/ 需要/ 执行/ 的/ 代码/ 量/ 的/ 增加/ ,/ 更/ 意味着/ 对/ 求解/ 器/ 的/ 调用/ 次数/ 也/ 要/ 随之/ 增加/ ,/ 而/ 求解/ 器/ 的/ 性能/ 决定/ 了/ 约束/ 求解/ 的/ 效率/ ,/ 是/ 基于/ 新/ 方法/ 所/ 开发工具/ 的/ 主要/ 性能/ 瓶颈/ ./ 解决/ 这一/ 问题/ 的/ 关键在于/ 如何/ 减少/ 对/ 求解/ 器/ 的/ 依赖/ ,/ 目前/ 主要/ 技术/ 途径/ 有/ 两种/ [/ 43/ -/ 44/ ]/ ,/ 一是/ 对/ 路径/ 约束/ 进行/ 优化/ ,/ 主要/ 包括/ 表达式/ 重写/ 、/ 约束/ 集合/ 化简/ 、/ 隐含/ 值/ 具体化/ 和/ 无关/ 约束/ 消去/ 等/ ;/ 二是/ 使用/ 缓存/ 技术/ 减少/ 重复/ 求解/ ,/ 主要/ 包括/ 符号/ 表达式/ 缓存/ 、/ 局部/ 约束/ 缓存/ 和/ 反例/ 缓存/ 等/ ./ 这/ 两种/ 手段/ 的/ 共同之处/ 在于/ 它们/ 都/ 利用/ 了/ 约束/ 求解/ 的/ 以下/ 3/ 个/ 特点/ :/ ①/ 若/ 约束/ 集合/ 无/ 解/ ,/ 则/ 其/ 超集/ 也/ 无解/ ;/ ②/ 若/ 约束/ 集合/ 有解/ ,/ 则/ 此解/ 也/ 是/ 其/ 子集/ 的/ 解/ ;/ ③/ 约束/ 集合/ 的/ 解/ 很多/ 时候/ 也/ 是/ 其/ 超集/ 的/ 解/ ./ 据称/ ,/ 几种/ 优化/ 方法/ 一起/ 使用/ 能/ 提高/ 求解/ 效率/ 30/ 倍/ 左右/ [/ 43/ ]/ ./ 7/ 工具/ 和/ 应用/ 2005/ 年/ ,/ Bell/ 实验室/ 和/ 斯坦福大学/ 分别独立/ 提出/ 混合/ 符号执行/ 的/ 概念/ ,/ 并/ 各自/ 开发/ 出/ 原型/ 工具/ DART/ 和/ EGT/ ,/ 其后/ DART/ 的/ 合作者/ 之一/ Sen/ 等/ 人/ [/ 40/ ]/ 对/ DART/ 进行/ 扩展/ 开发/ 了/ CUTE/ 工具/ 以/ 处理/ C/ 代码/ 中/ 的/ 指针/ 、/ 别名/ 和/ 线程/ 以及/ 针对/ JAVA/ 程序/ 的/ jCUTE/ 工具/ ./ 斯坦福/ 的/ 团队/ 对/ EGT/ [/ 58/ ]/ 进行/ 完善/ 开发/ 出/ EXE/ ,/ 值得一提的是/ ,/ 斯坦福/ 的/ 开发/ 小组/ 同时/ 开发/ 了/ STP/ 求解/ 器以/ 供/ EXE/ 使用/ ,/ 获得/ 了/ 很大/ 成功/ ./ 尽管/ 这些/ 工具/ 在/ 提出/ 时/ 还/ 处于/ 原型/ 阶段/ ,/ 但是/ 初步/ 的/ 试验/ 已经/ 表明/ 这种/ 方法/ 十分/ 有效/ ,/ 并/ 引起/ 了/ 研究者/ 和/ 工业界/ 的/ 极大/ 兴趣/ ./ 随后/ ,/ DART/ 的/ 主要/ 作者/ Godefroid/ 被/ 微软/ 聘请/ 并/ 帮助/ 其/ 设计/ 了/ SAGE/ 工具/ ./ SAGE/ 是/ 基于/ 二进制/ 代码/ 的/ 重量级/ 文件/ 模糊/ 测试工具/ ,/ 其/ 作者/ 声称/ [/ 39/ ]/ ,/ 在/ Windows7/ 的/ 开发/ 过程/ 中/ ,/ 通过/ 模糊/ 测试/ 发现/ 的/ 全部/ 程序/ 错误/ 中有/ 三分之一/ 是/ 使用/ SAGE/ 发现/ 的/ ./ 从/ 2008/ 年/ 开始/ ,/ SAGE/ 被/ 配置/ 在/ 微软/ 的/ 安全/ 测试/ 实验室/ 的/ 100/ 多台/ 机器/ 上/ 7/ ×/ 24/ 不间断/ 地/ 持续/ 运行/ ,/ 并/ 针对/ 几百个/ 程序/ 进行/ 自动测试/ ,/ 这是/ 迄今为止/ 所/ 知道/ 的/ 对/ Z3/ 求解/ 器/ 的/ 最/ 大规模/ 的/ 使用/ ./ 除此之外/ ,/ 微软/ 又/ 将/ Concolic/ 执行/ 与/ 单元测试/ 领域/ 结合/ 设计/ 了/ PEX/ [/ 67/ -/ 68/ ]/ 工具/ ,/ PEX/ 做/ 为/ 微软/ 的/ visualstudio/ 的/ 插件/ ,/ 可以/ 在/ 开发/ 工作/ 的/ 同时/ 进行/ 单元测试/ 工作/ ,/ 针对/ 于/ 一个/ 代码/ 单元/ (/ 函数/ 或类/ )/ 自动/ 生成/ 测试用例/ ,/ 并/ 指出/ 可能/ 的/ 错误/ ./ SLAM/ 是/ 微软/ 开发/ 的/ 基于/ 抽象/ 解释/ 和/ 反例/ 制导/ 的/ 求/ 精/ 方法/ 的/ 模型/ 检验/ 工具/ ,/ 用于/ 检验/ 驱动程序/ 的/ 可靠性/ ,/ 在/ 多年/ 来/ 的/ 实践/ 中/ 获得/ 了/ 很大/ 成功/ ,/ 微软/ 基于/ Concolic/ 执行/ 对/ SLAM/ 进行/ 改进/ ,/ 重新/ 设计/ 并/ 推出/ 了/ YOGI/ [/ 69/ -/ 72/ ]/ 工具/ ,/ 相比/ 于/ SLAM/ 、/ YOGI/ 的/ 执行/ 效率/ 得到/ 了/ 极大/ 提高/ ./ 斯坦福/ 的/ 团队/ 基于/ 对/ EXE/ 的/ 开发/ 和/ 使用/ 所/ 获取/ 的/ 实践经验/ ,/ 对/ EXE/ 重新/ 设计/ 和/ 实现/ ,/ 开发/ 出新/ 的/ 自动化/ 白盒/ 测试工具/ KLEE/ ./ KLEE/ 是/ 个/ 里程碑式/ 的/ 工具/ ,/ 极大/ 地/ 推动/ 了/ 这个/ 领域/ 的/ 进展/ ,/ 其/ 面世/ 之后/ ,/ 基于/ KLEE/ 开发/ 的/ 、/ 针对/ 不同/ 领域/ 和/ 目的/ 的/ 工具/ 竞相/ 出现/ ,/ 比如/ 漏洞/ 利用/ 自动/ 生成/ 工具/ AGE/ [/ 73/ ]/ 、/ 性能/ 分析/ 工具/ S2E/ [/ 56/ ]/ 和/ 逆向/ 工程/ 分析/ 工具/ RevNIC/ [/ 74/ ]/ 等/ ./ 此外/ 还/ 存在/ 许多/ 其他/ 工具/ ,/ 如/ UIUC/ 提出/ 的/ 检查/ SQL/ 注入/ 的/ 工具/ [/ 75/ ]/ 、/ MIT/ 提出/ 的/ 检查/ JavaScript/ 安全性/ 的/ 工具/ [/ 76/ ]/ 、/ CMU/ 提出/ 的/ 检查/ 僵尸/ 网络/ 的/ 二进制/ 动态分析/ 工具/ BitScope/ [/ 54/ ]/ 等等/ ./ 国内/ ,/ 如/ 南京大学/ [/ 77/ ]/ 、/ 北京大学/ [/ 78/ -/ 81/ ]/ 、/ 国防科技大学/ [/ 82/ ]/ 、/ 北京航空航天大学/ [/ 83/ ]/ 和/ 北京邮电大学/ [/ 84/ -/ 85/ ]/ 等/ 众多/ 研究/ 团队/ ,/ 在/ 软件/ 安全漏洞/ 检测/ 领域/ 进行/ Page12/ 了/ 系统/ 而/ 深入/ 的/ 研究/ ./ 特别/ 值得一提的是/ ,/ 北京大学/ 王铁磊/ 等/ 在/ 该/ 领域/ 取得/ 了/ 重要/ 研究进展/ ,/ 首次/ 提出/ 了/ 一种/ 绕过/ 校验/ 和/ 机制/ 的/ 模糊/ 测试方法/ ,/ 并/ 开发/ 了/ 相应/ 的/ 工具/ TaintScope/ ,/ 发现/ 了/ AdobeAcrobat/ 、/ GooglePicasa/ 、/ MicrosoftPaint/ 和/ ImageMagick/ 等/ 软件/ 中/ 的/ 多个/ 未知/ 漏洞/ ,/ 得到/ 领域/ 内/ 研究/ 人员/ 的/ 广泛/ 关注/ ./ 8/ 未来/ 研究/ 展望/ 基于/ 轻量级/ 动态/ 符号执行/ 的/ 自动化/ 白盒/ 模糊/ 测试方法/ 的/ 提出/ 不足/ 十年/ ,/ 仍然/ 属于/ 较/ 新/ 的/ 方法/ ,/ 这个/ 领域/ 的/ 发展/ 方兴未艾/ ,/ 尽管/ 取得/ 了/ 初步/ 的/ 成果/ ,/ 但/ 依然/ 有/ 大量/ 的/ 问题/ 亟待解决/ ,/ 未来/ 研究/ 的/ 主要/ 内容/ 大概/ 可以/ 分为/ 3/ 个/ 方面/ :/ (/ 1/ )/ 从/ 方法/ 的/ 角度/ 来看/ ,/ 现有/ 研究/ 主要/ 集中/ 在/ 如何/ 将/ Concolic/ 执行/ 与/ 模糊/ 测试/ 、/ 模型/ 检验/ 、/ 单元测试/ 等/ 方法/ 结合/ 并/ 开发/ 出新/ 的/ 工具/ ,/ 如/ SAGE/ 基于/ Concolic/ 执行/ 对/ 传统/ 的/ 文件/ 模糊/ 测试/ 做出/ 改进/ ;/ Yogi/ 是/ Concolic/ 执行/ 与/ 模型/ 检验/ 结合/ 的/ 一次/ 尝试/ ;/ PEX/ 将/ Concolic/ 执行/ 引入/ 单元测试/ ./ 如何/ 深刻/ 认识/ 问题/ 和/ 方法/ 的/ 本质/ ,/ 同时/ 吸收/ 并/ 利用/ 其他/ 方法/ 的/ 优秀成果/ ,/ 相互/ 启发/ ,/ 对/ 传统/ 方法/ 进行/ 改进/ ,/ 扩大/ 新/ 方法/ 的/ 作用/ 范围/ 并/ 提高/ 其/ 使用/ 效果/ ,/ 是/ 进一步/ 研究/ 方向/ 之一/ ./ (/ 2/ )/ 从/ 技术/ 的/ 角度/ 来看/ ,/ 现有/ 工具/ 实现/ 主要/ 是/ 针对/ 有限/ 的/ 几种/ 操作系统/ 、/ 语言/ 和/ 指令系统/ ./ 近年来/ ,/ 物/ 联网/ 、/ 工控/ 系统/ 和/ 移动/ 计算/ 等/ 领域/ 的/ 蓬勃发展/ 对/ 安全/ 问题/ 提出/ 了/ 严峻/ 挑战/ ,/ 特别/ 的/ ,/ 这些/ 领域/ 对/ 安全漏洞/ 检测/ 的/ 需求/ 也/ 日益/ 增加/ ./ 如何/ 针对/ 这些/ 领域/ 中/ 应用/ 的/ 特性/ ,/ 将/ 新/ 方法/ 有效/ 引入/ 到/ 这些/ 领域/ 的/ 安全漏洞/ 检测/ 工作/ 中/ ,/ 具有/ 重要/ 研究/ 意义/ ./ (/ 3/ )/ 发现/ 程序/ 存在/ 的/ 问题/ 是/ 软件测试/ 的/ 主要/ 目的/ ,/ 然而/ 单纯/ 通过/ 测试/ 通常/ 只能/ 发现/ 浅层/ 次/ 程序/ 错误/ ./ 不仅如此/ ,/ 不同/ 领域/ 的/ 程序/ 中/ 存在/ 的/ 问题/ 类型/ 也/ 大不相同/ ./ 例如/ ,/ 跨站/ 脚本/ 漏洞/ 和/ SQL/ 注入/ 漏洞/ 是/ Web/ 应用领域/ 的/ 主要/ 安全/ 问题/ ,/ 与/ 传统/ 的/ 溢出/ 漏洞/ 呈现出/ 不同/ 特征/ ./ 如何/ 对/ 更/ 多/ 领域/ 内所/ 独有/ 的/ 程序/ 漏洞/ 类型/ 进行/ 细致/ 地/ 观察/ 并/ 刻画出/ 其/ 本质特征/ ,/ 是/ 查找/ 程序/ 漏洞/ 的/ 关键/ 之一/ ./ 一些/ 新/ 工具/ 已经/ 使用/ 本文/ 所述/ 新/ 方法/ ,/ 对/ 跨/ 站/ 脚本/ 漏洞/ 和/ SQL/ 注入/ 漏洞/ 的/ 检测/ 做出/ 了/ 初步/ 尝试/ ,/ 实验性/ 结果/ 揭示/ 了/ 新/ 方法/ 的/ 有效性/ ./ 因此/ ,/ 如何/ 针对/ 更/ 多/ 应用领域/ 的/ 程序/ ,/ 总结/ 和/ 整理/ 其/ 经常出现/ 的/ 漏洞/ 类型/ 和/ 安全性/ 约束/ ,/ 是/ 开发新/ 方法/ 或/ 改进/ 上述/ 方法/ 适用范围/ 的/ 有效途径/ ./ 致谢/ 北京航空航天大学/ 计算机/ 学院/ 的/ 张玉平/ 教授/ 为/ 本文/ 的/ 修改/ 提供/ 了/ 大量/ 帮助/ ,/ 在/ 此/ 表示/ 衷心感谢/ !/ 

