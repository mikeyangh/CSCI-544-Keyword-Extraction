Page1/ 面向/ MAX/ // MIN/ 优化/ 的/ SQLWindow/ 函数/ 处理/ 马建松/ 王科强/ 宋光旋/ 张凯/ 王晓玲/ 金澈/ 清/ (/ 华东师范大学/ 数据/ 科学/ 与/ 工程/ 研究院/ 上海市/ 高/ 可信计算/ 重点/ 实验室/ 上海/ 200062/ )/ 摘要/ Window/ (/ 窗口/ )/ 函数/ 作为/ 关系数据库/ 领域/ 中/ 数据分析/ 技术/ 的/ 一种/ 解决方案/ ,/ 其/ 精妙/ 的/ 语义/ 特征/ 使/ 其能/ 代替/ 自/ 连接/ (/ SelfJoin/ )/ 和/ 相关/ 子/ 查询/ (/ SubQueries/ )/ 等/ 完成/ 传统/ 复杂/ 查询/ 功能/ ,/ 现已/ 被/ 广泛应用/ 到/ 互联网/ 应用/ 的/ 数据管理/ 和/ 分析/ 中/ ./ 在/ 目前/ 互联网/ 应用/ 步入/ 大/ 数据/ 时代/ 的/ 背景/ 下/ ,/ 针对/ 高/ 吞吐/ 和/ 实时/ 响应/ 等/ 需求/ ,/ 已有/ 的/ Window/ (/ 窗口/ )/ 函数/ 的/ 处理/ 性能/ 已经/ 出现/ 了/ 瓶颈/ ./ 文中/ 首先/ 介绍/ 了/ 关系数据库/ 中/ 窗口/ 函数/ 在/ 执行器/ 中/ 的/ 两/ 阶段/ 执行/ 框架/ ,/ 然后/ 基于/ PostgreSQL/ 数据库/ 中原/ 有/ MAX/ // MINWindow/ (/ 窗口/ )/ 函数/ 执行/ 框架/ ,/ 提出/ 了/ 一种/ 基于/ 临时/ 窗口/ 的/ 优化/ 方法/ ,/ 来/ 优化/ SQLWindow/ 查询/ 针对/ MAX/ // MIN/ 函数/ 的/ 处理/ ,/ 并/ 给出/ 了/ 查询/ 代价/ 的/ 分析模型/ ,/ 从/ 理论/ 上/ 分析/ 了/ 该/ 算法/ 的/ 性能/ ./ 通过/ 与/ 现有/ 商业/ 数据库/ SQLServer/ 进行/ 性能/ 上/ 的/ 对比/ ,/ 验证/ 了/ 该/ 方案/ 的/ 有效性/ ./ 关键词/ Window/ 函数/ ;/ 查询处理/ ;/ 性能/ 优化/ ;/ MAX/ // MIN/ ;/ PostgreSQL1/ 引言/ 随着/ 互联网/ 的/ 普及/ 和/ 互联网/ 用户数量/ 的/ 不断/ 增加/ ,/ 互联网/ 应用/ 逐渐/ 进入/ 了/ 大/ 数据/ 时代/ ./ 大/ 数据/ 时代/ 的/ 来临/ ,/ 使得/ 互联网/ 应用/ 面临/ 着/ 数据/ 的/ 爆发式/ 增长/ ./ 由于/ 用户/ 数据/ 中/ 包含/ 了/ 丰富/ 的/ 用户/ 行为/ 模式/ 信息/ ,/ 因此/ ,/ 大/ 数据量/ 的/ 用户/ 数据/ 对/ 互联网/ 应用/ 来说/ 变得/ 越来越/ 重要/ ./ 如何/ 存储/ 和/ 分析/ 这些/ 大/ 数据/ 成为/ 了/ 互联网/ 应用/ 中/ 的/ 难题/ ./ 随着/ 用户/ 对/ 数据处理/ 效率/ 的/ 要求/ 不断/ 提高/ ,/ 融合/ 数据/ 存储/ 和/ 数据分析/ 的/ 内/ 数据库/ 分析/ (/ In/ -/ DatabaseAnalytics/ )/ 技术/ ,/ 受到/ 了/ 越来越/ 多/ 企业/ 和/ 研究者/ 的/ 关注/ ./ Window/ (/ 窗口/ )/ 函数/ 作为/ 关系数据库/ 领域/ 中内/ 数据库/ 分析/ 技术/ 的/ 一种/ 解决方案/ ,/ 最初/ 以/ 扩展/ 文档/ 的/ 形式/ 被/ 引入/ 到/ SQL/ :/ 1999/ ,/ 之后/ 不久/ ,/ SQL/ :/ 2003/ 就/ 正式/ 规范/ 了/ Window/ (/ 窗口/ )/ 函数/ 的/ 标准/ ,/ 并/ 在/ 后续/ 的/ 标准/ 版本/ 中/ 有所/ 丰富/ 与/ 扩展/ ./ Window/ 函数/ 拥有/ SQL/ 语句/ 惯有/ 的/ 简洁/ 构成/ 模式/ ,/ 但是/ 其/ 精妙/ 的/ 语义/ 特征/ 使/ 其能/ 代替/ 自/ 连接/ (/ SelfJoin/ )/ 和/ 相关/ 子/ 查询/ (/ SubQueries/ )/ 等/ 完成/ 传统/ 复杂/ 查询/ 的/ 功能/ ./ 在/ 数据处理/ 中/ ,/ 窗口/ 概念/ 的/ 引入/ 使得/ 计算/ 被/ 应用/ 到/ 特定/ 的/ 数据/ 集合/ (/ dataset/ )/ 上/ ,/ 或者说/ 是/ 一个/ 窗口/ 所/ 包含/ 的/ 元组/ (/ tuple/ )/ 之上/ ./ 在/ 此基础/ 上/ ,/ 随之/ 产生/ 了/ 一系列/ 常规/ 分析/ 函数/ ./ 例如/ ,/ 平均值/ (/ average/ )/ 、/ 累积/ 求和/ (/ sum/ )/ 、/ 最大值/ (/ max/ )/ 、/ 最小值/ (/ min/ )/ 、/ 排序/ (/ ranking/ )/ 、/ 百分比/ (/ percentile/ )/ 等/ ./ 这些/ 函数/ 都/ 可以/ 用/ 一条/ SQL/ 语句/ 精确/ 、/ 直观/ 、/ 有效/ 地/ 表达出来/ ./ 现今/ ,/ 主流/ 商业/ 数据库系统/ 中/ 都/ 实现/ 了/ Window/ 函数/ 以/ 支持/ 数据分析/ 任务/ ,/ 比如/ DB2/ 的/ 联机/ 分析/ 处理/ (/ OnlineAnalyticalProcessing/ ,/ OLAP/ )/ 函数/ ,/ Oracle/ 的/ 解析/ 函数/ (/ analyticfunction/ )/ 和/ SQLServer/ 的/ Window/ 函数/ 等/ ./ 随着/ 互联网/ 应用/ 逐渐/ 步入/ 大/ 数据/ 时代/ ,/ Window/ 函数/ 也/ 逐渐/ 被/ 应用/ 于/ 各类/ 互联网/ 应用/ 的/ 数据管理/ 和/ 数据分析/ 中/ ,/ 如/ 商务/ 智能/ 的/ 查询/ 报表/ 和/ 各类/ 分析/ 应用/ ./ 越来越/ 多/ 的/ 企业级/ 数据/ 的/ 查询/ 和/ 分析/ 逐渐/ 将/ 旧/ 的/ 查询/ 替换成/ Window/ 函数/ 的/ 方案/ ./ Window/ 函数/ 在/ 数据/ 查询/ 和/ 分析/ 中/ 的/ 应用/ 使得/ 查询处理/ 更加/ 高效/ ,/ 尤其/ 是/ 可以/ 有效/ 地/ 消除/ 效率/ 低下/ 的/ 自/ 连接/ (/ SelfJoin/ )/ 和/ 相关/ 子/ 查询/ (/ SubQueries/ )/ [/ 1/ -/ 2/ ]/ ,/ 而且/ 查询处理/ 过程/ 中/ 可以/ 尽可能/ 地/ 减少/ 临时/ 表/ 的/ 使用/ ./ 尽管/ Window/ 函数/ 在/ 数据/ 查询/ 和/ 分析/ 中/ 可以/ 尽可能/ 地/ 提高/ 查询/ 效率/ ,/ 其/ 执行/ 框架/ 也/ 设计/ 的/ 足够/ 精简/ ,/ 但/ 由于/ 其/ 应用/ 场景/ 的/ 多样性/ 使/ 其/ 在/ 实现/ 时/ 并/ 没有/ 得到/ 足够/ 的/ 优化/ ./ 在/ 目前/ 互联网/ 应用/ 步入/ 大/ 数据/ 时代/ 的/ 背景/ 下/ ,/ 针对/ 高/ 吞吐/ 和/ 实时/ 响应/ 等/ 需求/ ,/ 已有/ 的/ Window/ 函数/ 的/ 处理/ 性能/ 已经/ 出现/ 了/ 瓶颈/ ./ 因此/ ,/ 针对/ 特定/ 的/ 数据分析/ 场景/ ,/ 需要/ 设计/ 出/ 更/ 适合/ Window/ 函数/ 执行/ 的/ 优化/ 方法/ ./ 1.1/ Window/ 函数/ Window/ 函数/ 由/ 一个/ 分析/ 函数/ 和/ 一个/ 窗口/ 定义/ 子句/ 构成/ ./ 在/ 标准/ SQL/ 的/ 定义/ 中/ ,/ 使用/ 窗口/ 定义/ 函数/ 所/ 作用/ 于/ 的/ 上下文/ 区间/ ,/ 窗口/ 的/ 具体/ 规范/ 则/ 由/ 一个/ OVER/ 子句/ 来/ 定义/ ./ 例/ 1/ ./ 给定/ 一张/ 员工/ 工资表/ empsalary/ (/ 如表/ 1/ 所示/ )/ ,/ 包含/ 3/ 个/ 属性/ ,/ empno/ 、/ depno/ 和/ salary/ (/ 其中/ empno/ 是/ 主键/ )/ ./ empno/ 指/ 的/ 是/ 员工/ 的/ 员工/ 编号/ (/ 唯一/ 的/ )/ ,/ depno/ 指/ 的/ 是/ 部门/ 编号/ ,/ salary/ 指/ 的/ 是/ 员工工资/ ./ 下面/ 是/ 一条/ 带/ Window/ 函数/ 的/ SQL/ 查询/ 语句/ ./ 表示/ 将/ 所有/ 员工/ 按/ 部门/ 号/ 划分/ ,/ 按/ 员工/ 编号/ 排序/ ,/ 将/ 每位/ 员工/ 的/ 工资/ 与/ 前后/ 20/ 位/ 比较/ ,/ 得到/ 工资/ 最高/ 的/ 员工/ 的/ 工资/ ./ SELECTempno/ ,/ depno/ ,/ salary/ ,/ MAX/ (/ salary/ )/ OVER/ (/ PARTITIONBYdepnoORDERBYempnoROWSBETWEEN10PRECEDINGAND10FOLLOWING/ )/ Fromempsalary/ ;/ empnoPage3/ 如例/ 1/ 中/ 的/ SQL/ 语句/ 所示/ ,/ Window/ 函数/ 包含/ 一个/ 分析/ 函数/ (/ 例/ 1/ 的/ SQL/ 语句/ 中为/ MAX/ 函数/ )/ 和/ 一个/ 规定/ 窗口/ 大小/ 的/ OVER/ 子句/ ./ 其中/ OVER/ 子句/ 中/ 包含/ 了/ 3/ 个/ 组成部分/ :/ (/ 1/ )/ PARTITIONBY/ 子句/ ./ PARTITIONBY/ 子句/ 用来/ 定义数据/ 分区/ ,/ 形式/ 为/ PARTITIONBYexpr/ _/ list/ ./ 后面/ 的/ 属性/ 值/ expr/ _/ list/ 决定/ 了/ 数据表/ 按照/ 哪些/ 属性/ 进行/ 划分/ ,/ expr/ _/ list/ 的/ 值/ 相同/ 的/ 元组/ 属于/ 同一个/ 分区/ ./ (/ 2/ )/ ORDERBY/ 子句/ ./ ORDERBY/ 子句/ 用来/ 定义数据/ 排序/ 模式/ ,/ 形式/ 为/ ORDERBYorder/ _/ list/ ./ 后面/ 的/ 属性/ 值/ order/ _/ list/ 决定/ 了/ 数据表/ 按照/ 哪些/ 属性/ 进行/ 排序/ ./ (/ 3/ )/ ROWS/ 子句/ ./ ROWS/ 子句/ 用来/ 定义/ Window/ 函数/ 中/ 一个/ 窗口/ 的/ 大小/ ,/ 形式/ 为/ ROWSBETWEENpre/ _/ valueandpost/ _/ value/ ./ 其中/ pre/ _/ value/ 包含/ 了/ UNBOUNDEDPRECEDING/ (/ 窗口/ 的/ 起始/ 位置/ 为/ 分区/ 的/ 第一个/ 元组/ )/ 、/ valuePRECEDING/ (/ 窗口/ 的/ 起始/ 位置/ 为/ 当前/ 行/ 的/ 前/ value/ 个/ 元组/ )/ 和/ CURRENTROW/ (/ 窗口/ 的/ 起始/ 位置/ 为/ 当前/ 行/ )/ 3/ 种/ ,/ post/ _/ value/ 包含/ 了/ UNBOUNDEDFOLLOWING/ (/ 窗口/ 的/ 终止/ 位置/ 为/ 分区/ 的/ 最后/ 一个/ 元组/ )/ 、/ valueFOLLOWING/ (/ 窗口/ 的/ 终止/ 位置/ 为/ 当前/ 行/ 的/ 后/ value/ 个/ 元组/ )/ 和/ CURRENTROW/ (/ 窗口/ 的/ 终止/ 位置/ 为/ 当前/ 行/ )/ 3/ 种/ ./ 数据表/ 中/ 的/ 每/ 一个/ 元组/ 作为/ 当前/ 行都/ 对应/ 一个/ 窗口/ ,/ 窗口/ 的/ 大小/ 由/ OVER/ 子句/ 确定/ ,/ 其/ 定义/ 跟/ 当前/ 行/ 相关/ 的/ 一个/ 元组/ 的/ 集合/ (/ 元组/ 的/ 集合/ 通常/ 包括/ 一个/ 或者/ 多个/ 元组/ ,/ 也/ 可以/ 是/ 整张/ 数据表/ )/ ./ 例/ 1/ 中/ 的/ SQL/ 语句/ 部分/ 查询/ 结果/ 如表/ 2/ 所示/ ./ salary123456789101112131415/ …/ 窗口/ 函数/ 的/ 计算/ 过程/ 包括/ 3/ 个/ 过程/ :/ 分区/ 、/ 排序/ 和/ 确定/ 窗口/ 大小/ ./ 如图/ 1/ 所示/ ./ (/ 1/ )/ 分区/ 是/ 将/ 输入/ 元/ 组分/ 成/ 相互/ 独立/ 的/ 组/ ,/ 不同/ 组/ 的/ 元组/ 在/ 计算/ 时/ 不会/ 出现/ 在/ 同一/ 窗口/ 内/ ,/ 接下来/ 的/ 排序/ 和/ 确定/ 窗口/ 大小/ 的/ 工作/ 都/ 是/ 在/ 各个/ 分/ 区内/ 进行/ ,/ 分/ 区间/ 相互/ 不/ 影响/ ./ 基于/ 这种/ 特性/ ,/ 窗口/ 函数/ 其实/ 非常适合/ 于/ 并行计算/ ,/ 在/ 多/ 核/ 计算机/ 上/ ,/ 我们/ 可以/ 将/ 每个/ 分区/ 的/ 任务/ 放到/ 不同/ 的/ 核上/ 独立/ 运行/ ,/ 从而/ 提高/ 计算/ 效率/ ./ (/ 2/ )/ 排序/ 则/ 比较简单/ ,/ 在/ 每个/ 划分/ 内部/ 运用/ ORDERYBY/ 子句/ 指定/ 的/ 属性/ 列/ 进行/ 排序/ 即可/ ,/ 整个/ 流程/ 与/ 通常/ 使用/ 的/ 排序/ 子句/ 并/ 无/ 不同/ ./ (/ 3/ )/ 确定/ 窗口/ 大小/ 这/ 一步/ 主要/ 是/ 在/ 分/ 区内/ 为/ 当前/ 的/ 元组/ 确定/ 窗口/ 函数/ 所/ 能/ 作用/ 的/ 范围/ ,/ 这个/ 范围/ 是/ 以/ 当前/ 元组/ 为/ 中心/ 与/ 它/ 相邻/ 的/ 某些/ 元组/ 构成/ ./ SQL/ 中有/ 两种/ 确定/ 范围/ 的/ 模式/ :/ ROW/ 和/ RANGE/ ./ ROW/ 模式/ 比较简单/ ,/ 只/ 需/ 指定/ 当前/ 元组/ 与/ 在/ 它/ 之前/ 或者/ 之后/ 的/ 元组/ 数量/ 即可/ ./ RANGE/ 模式/ 则/ 是/ 根据/ 当前/ 元组/ 的/ 数值/ 来/ 确定/ ,/ 凡是/ 满足/ 数值/ 范围/ 的/ 与/ 之/ 相邻/ 的/ 所有/ 元组/ 都/ 构成/ 窗口/ ./ 如图/ 2/ 所示/ ,/ 当前/ 元组/ 为/ 灰色/ 部分/ 的/ 元组/ ,/ 采用/ ROWBETWEEN2PRECEDINGAND2FOLLOWING/ 子句/ 确定/ 的/ 窗口/ 是从/ 当前/ 元组/ 往前/ 取/ 两个/ 相邻/ 的/ 元组/ 和/ 往后/ 取/ 两个/ 相邻/ 元组/ 构成/ 的/ ,/ 也/ 就是/ [/ 5/ ,/ 5.5/ ,/ 6/ ,/ 6.5/ ,/ 7/ ]/ ./ 而/ 采用/ RANGEBETWEEN2PRECEDINGAND2FOLLOWING/ 子句/ 确定/ 窗口/ 大/ 小时/ ,/ 首先/ 要/ 取出/ 当前/ 元组/ 的/ 值/ ,/ 然后/ 往前/ 或者/ 往后/ 读取/ 相邻/ 元组/ 的/ 值/ ,/ 如果/ 两个/ 值/ 的/ 差/ 不/ 超过/ 2/ ,/ 那么/ 这个/ 元组/ 就/ 包含/ 在/ 图/ 2/ 当前/ 元组/ (/ 图中/ 的/ 灰色/ 部分/ )/ 的/ 取值/ 为/ 6/ (/ 当/ 窗口/ 范围/ 为/ 2/ 时/ ,/ row/ 模式/ 的/ 窗口/ 为/ [/ 5/ ,/ 5.5/ ,/ 6/ ,/ 6.5/ ,/ 7/ ]/ ;/ 而/ range/ 模式/ 对应/ 的/ 窗口/ 为/ [/ 4/ ,/ 4.5/ ,/ 5/ ,/ 5.5/ ,/ 6/ ,/ 6.5/ ,/ 7/ ,/ 7.5/ ,/ 8/ ]/ )/ Page4/ 窗口/ 之中/ ,/ 直到/ 差值/ 超过/ 2/ 也/ 就/ 确定/ 了/ 窗口/ 的/ 边界/ ,/ 也/ 就是/ [/ 4/ ,/ 4.5/ ,/ 5/ ,/ 5.5/ ,/ 6/ ,/ 6.5/ ,/ 7/ ,/ 7.5/ ,/ 8/ ]/ ./ 从中/ 我们/ 可以/ 看/ 出来/ ,/ ROW/ 模式/ 窗口/ 数量/ 相对/ 固定/ ,/ RANGE/ 模式/ 则/ 与/ 元组/ 的/ 取值/ 紧密/ 相关/ ,/ 因此/ 窗口/ 大小/ 不/ 确定/ ./ 1.2/ 相关/ 工作/ 当前/ ,/ 主流/ 的/ 数据仓库/ 厂商/ ,/ 如/ Teradata/ 、/ Green/ -/ plum/ 等/ ,/ 针对/ 高/ 吞吐量/ 、/ 实时/ 响应/ (/ 比如/ 作弊/ 检测/ 、/ 风险/ 控制/ )/ 等/ 应用/ 都/ 提供/ 了/ 不同/ 程度/ 的/ 内/ 数据库/ 分析/ 支持/ ./ Window/ 函数/ 针对/ 每个/ 窗口/ 都/ 会/ 计算/ 出/ 一列/ 额外/ 的/ 属性/ ./ GROUPBY/ 及其/ 3/ 类/ 扩展/ :/ GROUPSETS/ 、/ ROLLUP/ 和/ CUBE/ ,/ 是/ 将/ 数据表/ 中/ 的/ 数据/ 按照/ 不同/ 的/ 划分/ 方式/ 进行/ 分组/ ,/ 然后/ 对/ 每个/ 组内/ 的/ 元组/ 进行/ 各种/ 数据/ 操作/ ,/ 其/ 操作/ 方式/ 跟/ Window/ 函数/ 类似/ ./ 但是/ ,/ 如/ 文献/ [/ 3/ -/ 5/ ]/ 等/ 关于/ GROUPBY/ 及其/ 扩展/ 的/ 优化/ 工作/ ,/ 并/ 不适/ 用于/ Window/ 函数/ 的/ 执行/ 框架/ ./ 主要/ 有/ 两/ 方面/ 的/ 原因/ :/ (/ 1/ )/ GROUPBY/ 及其/ 扩展/ 的/ 计算/ 模式/ 和/ Window/ 函数/ 的/ 计算/ 模式/ 并/ 不/ 一样/ ./ Window/ 函数/ 在/ 保留/ 原始数据/ 的/ 基础/ 上/ ,/ 计算/ 出/ 额外/ 属性/ 列/ ,/ 输出/ 结果/ 可以/ 包含/ 原始/ 表/ 的/ 详细信息/ ,/ 而/ GROUPBY/ 及其/ 扩展/ 是/ 在/ 数据表/ 分组/ 的/ 基础/ 上/ 得出/ 数据/ 操作/ 的/ 信息/ ,/ 因此/ GROUPBY/ 及其/ 扩展/ 的/ 输出/ 最/ 多/ 保留/ 分组/ 信息/ ;/ (/ 2/ )/ GROUPBY/ 及其/ 扩展/ 中/ ,/ 数据/ 操作/ 是/ 针对/ 整个/ 分组/ 的/ ,/ 而/ Window/ 函数/ 的/ 语意/ 特性/ 更强/ ,/ 在/ 分组/ 的/ 基础/ 上/ 可以/ 指定/ 任意/ 物理/ 上/ 或/ 逻辑/ 上/ 的/ 窗口/ 大小/ ./ 数据流/ 领域/ 也/ 引入/ 了/ 窗口/ 的/ 概念/ ./ 在/ 数据流/ 领域/ ,/ 由于/ 数据/ 是/ 持续/ 不断/ 产生/ 的/ ,/ 因此/ ,/ 处理/ 的/ 数据/ 具有/ 数据量/ 大/ 和/ 持续/ 更新/ 等/ 特性/ ./ 在/ 数据流/ 领域/ ,/ 由于/ 数据/ 其/ 特有/ 的/ 特征/ ,/ 将/ 整个/ 数据/ 作为/ 操作/ 的/ 对象/ 是/ 基本/ 不/ 可能/ 的/ ,/ 常用/ 的/ 数据/ 操作方法/ 是/ 使用/ 滑动/ 窗口/ (/ slidingwindow/ )/ 来/ 处理/ 最新/ 到达/ 的/ 数据/ ,/ 并/ 在/ 窗口/ 范围/ 内/ 进行/ 数据/ 上/ 的/ 操作/ ./ 针对/ 数据流/ 上/ 的/ 窗口/ 操作/ ,/ 尤其/ 是/ 聚合/ (/ aggregate/ )/ 操作/ ,/ 已经/ 有/ 了/ 大量/ 的/ 研究/ 工作/ ./ 如/ 文献/ [/ 6/ ]/ 对/ 经典/ 的/ top/ -/ k/ 问题/ 做/ 了/ 研究/ ,/ 文献/ [/ 7/ ]/ 则/ 在/ 滑动/ 窗口/ 中/ 加入/ 了/ 语义/ 信息/ ./ 由于/ 在/ 数据流/ 处理过程/ 中/ ,/ 其/ 数据/ 访问/ 和/ 结果/ 要求/ 与/ 关系数据库/ 存在/ 差异/ ,/ 因此/ 许多/ 优化/ 策略/ 在/ 关系数据库/ 中/ 并/ 不/ 适用/ ./ 文献/ [/ 8/ ]/ 则/ 针对/ 滑动/ 窗口/ 计算/ 过程/ 中/ 存在/ 的/ 很多/ 重叠/ 部分/ ,/ 提出/ 了/ 一种/ 基于/ 计算/ 共享/ 思想/ 的/ 优化/ 方法/ ./ 在/ 连续/ 查询/ 领域/ (/ continuousquery/ )/ ,/ 文献/ [/ 9/ -/ 12/ ]/ 也/ 是/ 基于/ 这种/ 计算/ 共享/ 思想/ 对/ 计算/ 过程/ 进行/ 了/ 相应/ 的/ 优化/ ./ 重/ 排序/ 和/ 顺序调用/ 是/ Window/ 函数/ 执行/ 过程/ 中/ 的/ 两个/ 重要/ 阶段/ ./ 文献/ [/ 13/ -/ 17/ ]/ 是/ 重点/ 关注/ Window/ 函数/ 执行/ 优化/ 工作/ 的/ 几篇/ 文献/ ./ 其中/ ,/ 文献/ [/ 13/ ]/ 提出/ 了/ 一种/ 基于/ 全/ 排序/ (/ fullsort/ )/ 的/ 重/ 排序/ 方法/ ,/ 文献/ [/ 14/ ]/ 则/ 在/ 此基础/ 上/ 提出/ 了/ 更/ 高效/ 的/ 哈希/ 排序/ (/ hashsort/ )/ 和/ 分段/ 排序/ (/ segmentsort/ )/ ./ 文献/ [/ 15/ ]/ 则/ 从/ 排序/ 顺序/ (/ sortorder/ )/ 和/ 排序/ 共享/ (/ sortshare/ )/ 的/ 角度/ ,/ 提出/ 了/ 一种/ 协同/ 排序/ 技术/ ,/ 其/ 排序/ 代价/ 极为/ 接近/ 全局/ 最优/ ./ 文献/ [/ 16/ ]/ 基于/ 窗口/ 分组/ 共享/ 的/ 思想/ 针对/ 顺序调用/ 阶段/ 进行/ 了/ 优化/ ,/ 文献/ [/ 17/ ]/ 基于/ segment/ 树/ 共享/ 的/ 思想/ 针对/ 顺序调用/ 阶段/ 进行/ 了/ 优化/ ,/ 都/ 是/ 一个/ 通用/ 框架/ ,/ 但/ 不能/ 保证/ 每种/ 类型/ 的/ 函数/ 处理/ 都/ 能/ 达到/ 最优/ ./ 1.3/ 知识/ 预定/ 义/ 为了/ 尽可能/ 全面/ 、/ 细致/ 地/ 量化/ Window/ 函数/ 在/ 数据库/ 中/ 的/ 执行/ 过程/ 的/ 消耗/ ,/ 在/ 描述/ Window/ 函数/ 的/ 消耗/ 模型/ 时/ 需要/ 用到/ 以下/ 几个/ 参数/ ,/ 如表/ 3/ 所示/ ./ 参数/ nWiwiseriRiCCt2Window/ 函数/ 执行/ 过程/ 2.1/ 两/ 阶段/ 执行/ 框架/ Window/ 函数/ 的/ 执行/ 过程/ 被/ 分为/ 两个/ 部分/ (/ 如图/ 3/ 所示/ )/ :/ (/ 1/ )/ 重/ 排序/ 阶段/ :/ 根据/ PARTITIONBY/ 子句/ 和/ ORDERBY/ 子句/ 将表/ 进行/ 划分/ 和/ 重/ 排序/ ;/ (/ 2/ )/ 顺序调用/ 阶段/ :/ 得到/ 重/ 排序/ 后/ 的/ 表/ ,/ 对/ 窗口/ 内/ 的/ 元组/ 依次/ 调用/ 转移/ 函数/ (/ transitionfunction/ )/ ,/ 依次/ 得到/ 转移/ 值/ (/ transitionvalue/ )/ ,/ 拥有/ 最终/ 计算/ 函数/ (/ finalfunction/ )/ 的/ Window/ 函数/ 通过/ 调用/ 最终/ 计算/ 函数/ 得到/ 每个/ 窗口/ 的/ 最终/ 结果/ 值/ ./ 如果/ 一条/ 查询/ 中/ 含有/ 多个/ 窗口/ 函数/ ,/ 且/ 每个/ 函数/ 的/ 窗口/ 定义/ 都/ 不/ 一样/ ,/ 则/ 会/ 形成/ 一条/ 窗口/ 函数/ 链/ ,/ 顺序/ 的/ 执行/ 窗口/ 函数/ ,/ 当前/ 窗口/ 函数/ 的/ 输出/ 结果/ ,/ 可以/ 作为/ 下/ 一个/ 窗口/ Page5/ 函数/ 的/ 输入/ ,/ 每个/ 窗口/ 函数/ 执行/ 前/ 都/ 会/ 有/ 一个/ 相应/ 的/ 重/ 排序/ 操作/ ./ 通过/ 分析/ 发现/ ,/ 重/ 排序/ 阶段/ 对于/ 所有/ 类型/ 的/ 聚集/ 函数/ 来说/ 基本一致/ ./ 主要/ 的/ 不同/ 体现/ 在/ 执行/ 的/ 第/ 2/ 阶段/ ,/ 也/ 就是/ 顺序调用/ 阶段/ ./ 顺序调用/ 实际/ 也/ 包含/ 两个/ 过程/ ,/ 第/ 1/ 个/ 过程/ 是/ 顺序/ 地/ 接收/ 处理/ 每/ 一个/ 划分/ ,/ 第/ 2/ 个/ 过程/ 则/ 顺序/ 地/ 将/ 窗口/ 函数/ 作用/ 于/ 划分/ 中/ 的/ 每/ 一行/ 对应/ 的/ 窗口/ 上/ ,/ 这/ 两个/ 过程/ 对于/ 所有/ 窗口/ 函数/ 都/ 是/ 一样/ 的/ ./ 但/ 不同/ 类型/ 的/ 函数/ 在/ 窗口/ 上/ 具体/ 如何/ 执行/ 又/ 各有不同/ ,/ 主要/ 分为/ 3/ 类/ :/ 分布/ 型函数/ 、/ 偏移/ 类/ 函数/ 和/ 聚集/ 类/ 函数/ ./ (/ 1/ )/ 分布/ 型函数/ ,/ 边框/ 不会/ 起/ 作用/ ,/ 即/ 在/ 窗口/ 函数/ 的/ 具体/ 运算/ 时/ ,/ 其/ 窗口/ 大小/ 为/ 1/ ,/ 也/ 就是/ 只/ 包含/ 当前/ 行/ ,/ 因此/ 计算/ 过程/ 非常简单/ ,/ 只/ 需/ 遍历/ 一遍/ 数据/ ./ 即使/ 是/ 求/ 百分比/ 的/ 函数/ ,/ 最/ 多只/ 需要/ 再/ 对/ 每个/ 分割/ 提前/ 做/ 一次/ 统计/ ,/ 然后/ 这个/ 统计/ 值/ 就/ 可/ 用于/ 当前/ 分割/ 中/ 所有/ 行/ 的/ 计算/ ,/ 所/ 占/ 百分比/ 通过/ 当前/ 行/ 的/ 值/ 与/ 这个/ 统计/ 值/ 相除/ 即可/ 求出/ ./ 这样/ 对于/ 每个/ 分割/ ,/ 最/ 多只/ 需要/ 扫描/ 两遍/ 数据/ ,/ 一遍/ 用于/ 计算/ 统计/ 值/ ,/ 一遍/ 用于/ 获取/ 当前/ 行/ ./ (/ 2/ )/ 偏移/ 类/ 函数/ ,/ 其/ 函数/ 意义/ 是/ 将/ 划分/ 内/ 的/ 所有/ 元组/ 向前/ 或者/ 向/ 后/ 移动/ 一段距离/ ,/ 对于/ 这/ 类/ 函数/ ,/ 只/ 需要/ 在/ 计算/ 第一个/ 元组/ 时/ ,/ 确认/ 其/ 位置/ ,/ 然后/ 顺序/ 从/ 该/ 位置/ 往后/ 读取/ 即可/ ./ (/ 3/ )/ 聚集/ 类/ 函数/ 计算/ 的/ 对象/ 是/ 一个/ 集合/ 里/ 的/ 所有/ 行/ ,/ 与/ 传统/ 的/ 聚集/ 函数/ 类似/ ,/ 只不过/ 聚集/ 的/ 范围/ 被/ 限定/ 在/ 当前/ 窗口/ ,/ 每个/ 窗口/ 聚集/ 函数/ 都/ 有/ 一个/ 转移/ 函数/ 和/ 一个/ 可/ 选/ 最终/ 计算/ 函数/ 与/ 之/ 对应/ ./ 计算/ 的/ 过程/ 会/ 维护/ 一个/ 转移/ 值/ ,/ 转移/ 值/ 本身/ 可以/ 是/ 基本/ 数据/ 图/ 4PostgreSQL/ 中/ MAX/ // MINWindow/ 函数/ 在/ 顺序调用/ 阶段/ 的/ 执行/ 过程/ 类型/ 也/ 可以/ 是/ 抽象/ 类型/ ./ 在/ 重/ 排序/ 阶段/ ,/ MAX/ // MINWindow/ 函数/ 跟/ 其他/ Window/ 函数/ 一样/ ,/ 主要/ 是/ 针对/ PARTITIONBY/ 子句/ 和/ ORDERBY/ 子句/ 对表/ 进行/ 划分/ 和/ 重/ 排序/ ./ 由于/ MAX/ // MINWindow/ 函数/ 并/ 没有/ 最终/ 计算/ 函数/ ,/ 因此/ 每个/ 窗口/ 得到/ 的/ 最终/ 转移/ 值/ 即/ 为/ 该/ 窗口/ 的/ 最终/ 结果/ 值/ ./ 因此/ ,/ 对于/ MAX/ // MINWindow/ 函数/ ,/ 在/ 顺序调用/ 阶段/ ,/ 主要/ 是/ 对/ 重/ 排序/ 后/ 的/ 表中/ 的/ 每/ 一个/ 窗口/ 中/ 的/ 元组/ 去/ 顺序调用/ 转移/ 函数/ 求/ 转移/ 值/ 的/ 过程/ ./ 2.2/ 顺序调用/ 阶段/ 的/ 执行/ 过程/ 本文/ 是/ 针对/ 窗口/ 聚集/ 函数/ 中/ 的/ MAX/ // MIN/ 进行/ 优化/ ./ 在/ 顺序调用/ 阶段/ ,/ 主体/ 的/ 计算/ 过程/ 是/ 由/ 转移/ 函数/ 完成/ 的/ ./ 对于/ 像/ AVG/ 等/ 拥有/ 最终/ 计算/ 函数/ 的/ Window/ 函数/ ,/ 最终/ 结果/ 是/ 由/ 最终/ 计算/ 函数/ 获得/ ./ 对于/ 像/ MAX/ // MIN/ 等/ 函数/ ,/ 并/ 不/ 拥有/ 最终/ 计算/ 函数/ ,/ 其/ 最终/ 结果/ 就是/ 最终/ 获得/ 的/ 转移/ 值/ ./ 定义/ 1/ ./ 窗口/ (/ Window/ )/ ./ 由/ OVER/ 子句/ 定义/ 的/ 包含/ 一系列/ 元组/ 的/ 集合/ (/ 包含/ 了/ 一个/ 起始/ 位置/ 和/ 一个/ 终止/ 位置/ ,/ 并且/ 拥有/ 其/ 对应/ 的/ 转移/ 值/ )/ ,/ Wi/ (/ s/ ,/ e/ ,/ TV/ )/ ./ 其中/ Wi/ 指/ 一个/ 分区/ 中/ 的/ 第/ i/ 个/ 窗口/ ,/ s/ 指/ 窗口/ Wi/ 的/ 起始/ 位置/ ,/ e/ 指/ 窗口/ Wi/ 的/ 终止/ 位置/ ,/ TV/ 指/ 窗口/ Wi/ 的/ 转移/ 值/ ./ 对于/ 例/ 1/ 中/ 的/ SQL/ 查询/ ,/ PostgreSQL/ 中/ 的/ Window/ 函数/ 在/ 顺序调用/ 阶段/ 的/ 执行/ 过程/ 如图/ 4/ 所示/ (/ 有色/ 的/ 元组/ 表示/ 此/ 窗口/ 的/ 当前/ 行/ ,/ 黑色/ 实体/ 箭头/ 表示/ 转移/ 值/ 的/ 计算/ 过程/ )/ :/ 对于/ 第一个/ 窗口/ W1/ ,/ 窗口/ 的/ 起始/ 位置/ 为/ r1/ ,/ 终止/ 位置/ 为/ r11/ ./ 转移/ 函数/ 依次/ 作用/ 于/ 窗口/ 中/ 的/ 每/ 一个/ 元组/ 之上/ ,/ 获得/ 的/ 最终/ 转移/ Page6/ 值/ 即/ 是/ 窗口/ W1/ 要求/ 的/ 最终/ 结果/ 值/ ./ 对于/ 窗口/ W2/ ,/ 起始/ 位置/ 为/ r1/ ,/ 终止/ 位置/ 为/ r12/ ./ 相对/ 于/ 窗口/ W1/ 来说/ ,/ 只/ 比/ 其/ 多出/ 了/ 位置/ r12/ 处/ 的/ 这/ 一个/ 元组/ ./ 因此/ ,/ 对于/ 窗口/ W2/ 来说/ ,/ 并不需要/ 重新/ 计算/ r1/ 至/ r11/ 的/ 元组/ 的/ 转移/ 值/ ./ 只/ 需/ 将/ 窗口/ W1/ 的/ 转移/ 值/ W1/ ./ TV/ 赋予/ 窗口/ W2/ 的/ 转移/ 值/ W2/ ./ TV/ ,/ 并/ 计算/ r12/ 处/ 的/ 元组/ 的/ 转移/ 值/ ,/ 得到/ 的/ 最终/ 转移/ 值/ 即/ 是/ 窗口/ W2/ 要求/ 的/ 最终/ 结果/ 值/ ./ 接下来/ 的/ 计算/ 过程/ 都/ 是/ 如此/ 直到/ 窗口/ W12/ ./ 从/ 窗口/ W12/ 开始/ ,/ 窗口/ 的/ 起始/ 位置/ 不再/ 是/ r1/ ,/ 开始/ 逐渐/ 依次/ 增加/ ./ 对于/ 窗口/ W12/ ,/ 计算/ 过程/ 与/ 窗口/ W1/ 类似/ ,/ 转移/ 函数/ 依次/ 作用/ 于/ 窗口/ 中/ 的/ 每/ 一个/ 元组/ 之上/ ,/ 最终/ 的/ 转移/ 值/ 即/ 是/ 要求/ 的/ 最终/ 结果/ 值/ ./ 后面/ 的/ W13/ 、/ W14/ 等/ 窗口/ 的/ 计算/ 过程/ 同/ 窗口/ W12/ 类似/ ./ 算法/ 1/ ./ PostgreSQL/ 顺序调用/ 算法/ ./ 输入/ :/ 经过/ 重/ 排序/ 的/ 表/ T/ 输出/ :/ 每/ 一个/ 元组/ 所/ 对应/ 的/ 窗口/ 的/ MAX/ // MIN/ 函数/ 值/ 1/ ./ FOR/ 表/ T/ 中/ 的/ 每/ 一个/ 分区/ PDO2/ ./ FOR/ 分区/ P/ 中/ 的/ 每/ 一个/ 窗口/ WiDO3/ ./ 初始化/ Wi/ ./ s/ ,/ Wi/ ./ e/ ,/ Wi/ ./ TV/ ;/ 4/ ./ IFWi/ ./ s/ =/ =/ Wi/ -/ 1/ ./ sTHEN5/ ./ 6.7/ ./ 8/ ./ ELSE9/ ./ 10.11/ ./ RETURNWi/ ./ TV/ ;/ PostgreSQL/ 中/ 的/ MAX/ // MINWindow/ 函数/ ,/ 在/ 顺序调用/ 阶段/ ,/ 转移/ 函数/ 执行/ 过程/ 的/ 具体/ 算法/ 如/ 算法/ 1/ 所示/ :/ 首先/ ,/ 初始化/ 当前/ 窗口/ 的/ 参数/ (/ s/ ,/ e/ ,/ TV/ )/ ,/ 并/ 将/ 读/ 指针/ 置于/ 窗口/ 的/ 起始/ 位置/ ./ 当前/ 窗口/ 的/ 起始/ 位置/ 与/ 上/ 一个/ 窗口/ 的/ 起始/ 位置/ 比较/ ,/ 如果/ 位置/ 不/ 相同/ ,/ 则/ 遍历/ 窗口/ 内/ 的/ 所有/ 元组/ ,/ 并/ 计算/ 其/ 相应/ 的/ 转移/ 值/ (/ 第/ 8/ ~/ 10/ 行/ )/ ./ 如果/ 位置/ 相同/ ,/ 则/ 只/ 需/ 遍历/ 与/ 上/ 一个/ 窗口/ 相比/ 新增/ 的/ 元组/ ,/ 并/ 计算/ 其/ 相应/ 的/ 转移/ 值/ (/ 第/ 4/ ~/ 7/ 行/ )/ ./ 2.3/ 消耗/ 模型/ 为了/ 更好/ 的/ 发现/ MAX/ // MINWindow/ 函数/ 在/ 顺序调用/ 阶段/ 执行/ 过程/ 中/ 存在/ 的/ 瓶颈/ ,/ 我们/ 建立/ 一个/ 量化/ 模型/ 去/ 刻画/ 其/ 在/ 数据库/ 执行/ 过程/ 中/ 的/ 消耗/ ./ 首先/ ,/ 我们/ 假设/ 表/ 中共/ 有/ n/ 个/ 元组/ (/ n/ / 1/ )/ ,/ n/ 个/ 元组/ 处在/ 同一/ 分区/ 中/ ,/ 且/ 在/ Window/ 函数/ 顺序调用/ 阶段/ 的/ 执行/ 过程/ 中/ ,/ 每/ 一个/ 元组/ 进行/ 数据/ 读取/ 和/ 转移/ 函数/ 计算/ 的/ 总/ 消耗/ 为/ C/ ./ 由于/ 表中/ 的/ 每/ 一个/ 元组/ 作为/ 当前/ 行时/ 都/ 会/ 唯一/ 的/ 确定/ 一个/ 窗口/ ,/ 因此/ ,/ 包含/ 有/ n/ 个/ 元组/ 的/ 表/ ,/ 在/ Window/ 函数/ 执行/ 过程/ 中共/ 有/ n/ 个/ 窗口/ 的/ 函数/ 值/ 需要/ 计算/ ./ 在/ 此/ ,/ 我们/ 假设/ n/ 个/ 窗口/ 的/ 大小/ 都/ 是/ w/ ,/ 且/ 每个/ 窗口/ 的/ 起始/ 位置/ 相对/ 于/ 上/ 一个/ 窗口/ 都/ 向下/ 平移/ 一个/ 元组/ ./ 则/ 传统/ 计算/ 框架/ 中/ ,/ Window/ 函数/ 在/ 顺序调用/ 阶段/ 的/ 消耗/ 为/ 从中/ 可以/ 看出/ ,/ 在/ 每/ 一个/ 元组/ 的/ 数据/ 读取/ 和/ 计算/ 消耗/ 固定/ 的/ 情况/ 下/ ,/ 执行/ 过程/ 中/ 的/ 瓶颈/ 主要/ 存在/ 于/ 元组/ 重复/ 地/ 进行/ 数据/ 读取/ 和/ 计算/ ,/ 也/ 就是/ 在/ 窗口/ 头部/ 发生变化/ 时/ ,/ 上/ 一个/ 窗口/ 的/ 转移/ 值/ 无法/ 重新/ 利用/ ,/ 需要/ 从头/ 重新/ 计算/ ,/ 而/ 两个/ 相邻/ 窗口/ 转移/ 值/ 计算/ 时/ 的/ 数据/ 大部分/ 都/ 是/ 重叠/ 的/ ,/ 因而/ 计算/ 效率/ 非常低/ ./ 当然/ 这种/ 默认/ 的/ 方式/ 在/ 有些/ 情况/ 下/ 也/ 是/ 有/ 比较/ 不错/ 的/ 效率/ ,/ 之前/ 求取/ 的/ 消耗/ 代价/ nwC/ 是/ 在/ 假设/ 窗口/ 大小/ 固定/ ,/ 依次/ 下移/ 的/ 前提/ 下/ 计算/ 的/ ./ 如果/ 窗口/ 定义/ 时/ 采用/ 类似/ BETWEENUNBOUNDEDPRECEDINGandCURRENTROW/ 的/ 方式/ ,/ 即/ 窗口/ 大小/ 是从/ 第一行/ 到/ 当前/ 行/ ,/ 那么/ 默认/ 的/ 这种/ 执行/ 方式/ 除了/ 第一次/ 需要/ 遍历/ 所有/ 元组/ 之外/ ,/ 每次/ 只/ 需要/ 额外/ 计算/ 一个/ 新/ 的/ 转移/ 值/ 即可/ ,/ 计算/ 消耗/ 为/ 这时/ 消耗/ 代价/ 仅为/ O/ (/ n/ )/ 级别/ ./ 只不过/ 在/ 实际/ 应用/ 当中/ 采用/ 这种/ 定义/ 方式/ 的/ 情况/ 相比/ BETWEENvaluePRECEDINGandvalueFOLLOWING/ 的/ 定义/ 方式/ 要少/ 很多/ ,/ 不/ 具有/ 代表性/ ,/ 我们/ 着重/ 讨论/ 更为/ 一般/ 的/ 情况/ ,/ 以后/ 不/ 做/ 特殊/ 说明/ 都/ 是/ 指/ 最为/ 一般/ 的/ 情况/ ./ 3/ 基于/ 临时/ 窗口/ 的/ MAX/ // MINWindow/ 函数/ 优化/ MAX/ // MINWindow/ 函数/ 是/ 不/ 拥有/ 最终/ 计算/ 函数/ 的/ Window/ 函数/ ./ 因此/ ,/ 每个/ 窗口/ 的/ 最终/ 转移/ 值/ 即/ 是/ 其/ 要求/ 的/ Window/ 函数/ 值/ ./ 优化/ MAX/ // MINWindow/ 函数/ 的/ 核心思想/ 是/ 在/ 函数/ 执行/ 过程/ 中/ 维持/ 一个/ 临时/ 窗口/ ,/ 其中/ 包含/ 了/ 此/ 临时/ 窗口/ 对应/ 的/ 临时/ 转移/ 值/ ,/ 用于/ 共享/ 计算/ ./ 以此/ 来/ 减少/ 在/ 顺序调用/ 过程/ 中/ 重复/ 进行/ 的/ 数据/ 元组/ 的/ 读取/ 和/ 计算/ 消耗/ ./ 3.1/ 优化/ 执行/ 过程/ 定义/ 2/ ./ 临时/ 窗口/ (/ TemporaryWindow/ )/ ./ 临/ Page7/ 时/ 产生/ 的/ 包含/ 一系列/ 元组/ 的/ 集合/ (/ 包含/ 了/ 一个/ 起始/ 位置/ 和/ 一个/ 终止/ 位置/ ,/ 并且/ 拥有/ 其/ 对应/ 的/ 临时/ 转移/ 值/ )/ ,/ TW/ (/ h/ ,/ t/ ,/ TTV/ )/ ./ 其中/ h/ 为/ 临时/ 窗口/ TW/ 的/ 起始/ 位置/ ,/ t/ 为/ 临时/ 窗口/ TW/ 的/ 终止/ 位置/ ,/ TTV/ (/ TemporaryTransitionValue/ )/ 为/ 临时/ 窗口/ TW/ 的/ 临时/ 转移/ 值/ ./ 对于/ 例/ 1/ 中/ 的/ SQL/ 查询/ ,/ 其/ 优化/ 算法/ 的/ 执行/ 过程/ 如图/ 5/ 所示/ (/ 图中/ 有色/ 元组/ 为/ 每个/ 窗口/ 的/ 最大值/ 所/ 处/ 位置/ )/ :/ 对于/ 第一个/ 窗口/ W1/ ,/ 转移/ 函数/ 依次/ 作用/ 于/ 窗口/ 中/ 的/ 每/ 一个/ 元组/ 之上/ ,/ 与此同时/ ,/ 并/ 记录/ 下图/ 5/ 计算/ 过程/ 由于/ R12/ 小于/ TTV/ ,/ 因此/ 我们/ 只/ 需/ 将/ 临时/ 窗口/ 的/ 终止/ 位置/ (/ t/ )/ 的/ 值/ 由/ r11/ 更新/ 为/ r12/ 即可/ ./ 后面/ 的/ 窗口/ 的/ 执行/ 过程/ 与/ 窗口/ W2/ 的/ 计算/ 过程/ 类似/ ./ 对于/ 窗口/ W12/ ,/ 其/ 起始/ 位置/ 与/ 上/ 一个/ 窗口/ W11/ 相比/ 向下/ 移动/ 了/ 一个/ 元组/ ,/ 但是/ 并/ 没有/ 超过/ 记录/ 的/ 临时/ 窗口/ 的/ 起始/ 位置/ ,/ 因此/ 决定/ 了/ ,/ 窗口/ W12/ 中/ 的/ 前/ 20/ 个/ 元组/ 中/ 的/ 最终/ 转移/ 值为/ 记录下来/ 的/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ (/ TTV/ )/ ./ 对于/ 前/ 20/ 行/ 元组/ ,/ 我们/ 无需/ 重复/ 的/ 进行/ 数据/ 读取/ 和/ 调用/ 转移/ 函数/ ,/ 只/ 需/ 将/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ (/ TTV/ )/ 赋给/ 窗口/ W12/ 的/ 转移/ 值/ (/ W12/ ./ TV/ )/ 即可/ ./ 接下来/ ,/ 我们/ 只/ 需/ 对/ r22/ 处/ 的/ 元组/ 进行/ 数据/ 读取/ 和/ 调用/ 转移/ 函数/ ,/ 并/ 更新/ 临时/ 窗口/ 的/ 终止/ 位置/ ./ 同理/ ,/ 窗口/ W13/ 的/ 计算/ 过程/ 也/ 与/ 窗口/ W12/ 的/ 计算/ 过程/ 类似/ ./ 但是/ ,/ 对于/ 窗口/ W14/ 来说/ ,/ 其/ 起始/ 位置/ (/ r4/ )/ 超过/ 了/ 临时/ 窗口/ 的/ 起始/ 位置/ (/ r3/ )/ ,/ 因此/ ,/ 临时/ 窗口/ 已经/ 不再/ 适用/ 于/ 窗口/ W14/ 的/ 计算/ 过程/ ./ 因此/ ,/ 窗口/ W14/ 的/ 计算/ 过程/ 与/ 窗口/ W1/ 的/ 类似/ ,/ 转移/ 函数/ 依次/ 作用/ 于/ 窗口/ 中/ 的/ 每/ 一个/ 元组/ 之上/ ,/ 与此同时/ ,/ 并/ 记录/ 下/ 最大/ 转移/ 值/ 的/ 位置/ (/ r12/ )/ 作为/ 临时/ 窗口/ 的/ 起始/ 位置/ (/ h/ )/ ,/ 记录/ 下/ 窗口/ 的/ 终止/ 位置/ (/ r24/ )/ 作为/ 临时/ 窗口/ 的/ 终止/ 最大/ 转移/ 值/ 的/ 位置/ (/ r3/ )/ 来/ 作为/ 临时/ 窗口/ 的/ 起始/ 位置/ (/ h/ )/ ,/ 记录/ 下/ 窗口/ 的/ 终止/ 位置/ (/ r11/ )/ 作为/ 临时/ 窗口/ 的/ 终止/ 位置/ (/ t/ )/ 以及/ 记录/ 下/ 最大/ 转移/ 值/ 作为/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ (/ TTV/ )/ ./ 对于/ 窗口/ W2/ ,/ 起始/ 位置/ 为/ r1/ ,/ 终止/ 位置/ 为/ r12/ ./ 相对/ 于/ 窗口/ W1/ 来说/ ,/ 只/ 比/ 其/ 多出/ 了/ 位置/ r12/ 处/ 的/ 这/ 一个/ 元组/ ./ 因此/ ,/ 对于/ 窗口/ W2/ 来说/ ,/ 并不需要/ 重新/ 计算/ r1/ 至/ r11/ 处/ 的/ 元组/ 的/ 转移/ 值/ ./ 只/ 需/ 将/ 窗口/ W1/ 的/ 转移/ 值/ W1/ ./ TV/ 赋予/ 窗口/ W2/ 的/ 转移/ 值/ W2/ ./ TV/ ,/ 并/ 计算/ r12/ 处/ 的/ 元组/ 的/ 转移/ 值/ ,/ 得到/ 的/ 最终/ 转移/ 值/ 即/ 是/ 窗口/ W2/ 要求/ 的/ 最终/ 结果/ 值/ ./ 位置/ (/ t/ )/ ,/ 记录/ 下/ 最大/ 转移/ 值/ 作为/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ (/ TTV/ )/ ./ 对于/ 窗口/ W15/ ,/ 由于/ 其/ 起始/ 位置/ (/ r5/ )/ 没有/ 超过/ 临时/ 窗口/ 的/ 起始/ 位置/ (/ r12/ )/ ,/ 因此/ ,/ 窗口/ W15/ 的/ 计算/ 过程/ 与/ 窗口/ W12/ 类似/ ./ 后面/ 的/ 窗口/ 的/ 计算/ 过程/ 以此类推/ ./ 计算/ 过程/ 中/ ,/ 不仅/ 需要/ 更新/ 临时/ 窗口/ 的/ 终止/ 位置/ ,/ 同时/ 还/ 需要/ 更新/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ 和/ 其/ 起始/ 位置/ ./ 例如/ ,/ 对于/ 例/ 1/ 中/ 的/ SQL/ 查询/ ,/ 我们/ 假设/ 前/ 11/ 个/ 窗口/ 的/ 计算/ 过程/ 如图/ 6/ 中/ 所示/ 一样/ (/ 前/ 21/ 行中/ 的/ 最大值/ 为/ R3/ 的/ 值/ )/ ,/ 并且/ R22/ 的/ 值/ 大于/ R3/ 的/ 值/ ./ 因此/ ,/ 对于/ 窗口/ W12/ 来说/ ,/ 由于/ 其/ 起始/ 位置/ (/ r2/ )/ 并/ 没有/ 超过/ 临时/ 窗口/ 的/ 起始/ 位置/ (/ r3/ )/ ,/ 因此/ ,/ r2/ 处到/ r21/ 处/ 的/ 元组/ 并不需要/ 重复/ 的/ 进行/ 数据/ 读取/ 和/ 调用/ 转移/ 函数/ ,/ 只/ 需/ 对/ r22/ 处/ 的/ 元组/ 进行/ 数据/ 读取/ 和/ 调用/ 转移/ 函数/ 即可/ ./ 由于/ R22/ 的/ 值/ 大于/ R3/ 的/ 值/ ,/ 因此/ 我们/ 需要/ 将/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ 更新/ 为/ R22/ 的/ 值/ ,/ 并且/ 将/ 临时/ 窗口/ 的/ 起始/ 位置/ 由/ r3/ 更新/ 为/ r22/ ./ 对于/ 窗口/ W13/ 来说/ ,/ 其/ 起始/ 位置/ (/ r3/ )/ 没有/ 超过/ 临时/ 窗口/ 的/ 起始/ 位置/ (/ r22/ )/ ,/ 因此/ ,/ 计算/ 过程/ 类似/ 于/ 窗口/ W2/ ./ 同理/ ,/ 后面/ 的/ 窗口/ 的/ 计算/ 过程/ 以此类推/ ./ Page8/ 图/ 6/ 更新过程/ 算法/ 2/ ./ TW/ (/ TemporaryWindow/ )/ 顺序调用/ 优化/ 算法/ ./ 输入/ :/ 经过/ 重/ 排序/ 的/ 表/ T/ 输出/ :/ 每/ 一个/ 元组/ 所/ 对应/ 的/ 窗口/ 的/ MAX/ // MIN/ 函数/ 值/ 1/ ./ FOR/ 表/ T/ 中/ 的/ 每/ 一个/ 分区/ PDO2/ ./ 初始化/ h/ ,/ t/ ,/ TTV/ ;/ 3/ ./ FOR/ 分区/ P/ 中/ 的/ 每/ 一个/ 窗口/ WiDO4/ ./ 初始化/ Wi/ ./ s/ ,/ Wi/ ./ e/ ,/ Wi/ ./ TV/ ;/ 5/ ./ IFWi/ ./ s/ =/ =/ Wi/ -/ 1/ ./ sTHEN6/ ./ 7.8/ ./ 9.10/ ./ 11.12/ ./ t/ ←/ Wi/ ./ e/ ;/ 13/ ./ ELSEIFWi/ ./ s/ / hTHEN14/ ./ Wi/ ./ TV/ ←/ TTV/ ;/ 15.16/ ./ 17.18/ ./ 19.20/ ./ t/ ←/ Wi/ ./ e/ ;/ 21/ ./ ELSE22/ ./ 23.24/ ./ 25.26/ ./ 27/ ./ t/ ←/ Wi/ ./ e/ ;/ 28/ ./ RETURNWi/ ./ TV/ ;/ MAX/ // MINWindow/ 函数/ TW/ (/ TemporaryWin/ -/ dow/ )/ 顺序调用/ 优化/ 算法/ 在/ 顺序调用/ 阶段/ 执行/ 过程/ 的/ 具体/ 算法/ 如/ 算法/ 2/ 所示/ :/ 对于/ 数据表/ 中/ 的/ 每/ 一个/ 分区/ ,/ 初始化/ 临时/ 窗口/ 的/ 参数/ (/ h/ ,/ t/ ,/ TTV/ )/ (/ 第/ 2/ 行/ )/ ./ 对于/ 分区/ 中/ 的/ 每/ 一个/ 窗口/ ,/ 初始化/ 当前/ 窗口/ 的/ 参数/ (/ s/ ,/ e/ ,/ TV/ )/ ,/ 并/ 将/ 读/ 指针/ 置于/ 窗口/ 的/ 起始/ 位置/ (/ 第/ 4/ 行/ )/ ./ 当前/ 窗口/ 的/ 起始/ 位置/ 与/ 上/ 一个/ 窗口/ 的/ 起始/ 位置/ 相/ 比较/ ,/ 如果/ 位置/ 相同/ ,/ 则/ 只/ 需/ 遍历/ 与/ 上/ 一个/ 窗口/ 相比/ 新增/ 的/ 元组/ ,/ 并/ 计算/ 其/ 相应/ 的/ 转移/ 值/ ./ 与此同时/ ,/ 如果/ 转移/ 值/ 不/ 等于/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ ,/ 就/ 更新/ 临时/ 窗口/ 的/ 起始/ 位置/ 和/ 临时/ 转移/ 值/ ./ 所有/ 元组/ 遍历/ 结束/ 后/ 更新/ 临时/ 窗口/ 的/ 结束/ 位置/ (/ 第/ 5/ ~/ 12/ 行/ )/ ./ 如果/ 位置/ 不/ 相同/ ,/ 则/ 比较/ 当前/ 窗口/ 的/ 起始/ 位置/ 与/ 临时/ 窗口/ 的/ 起始/ 位置/ ./ 如果/ 当前/ 窗口/ 的/ 起始/ 位置/ 不/ 大于/ 临时/ 窗口/ 的/ 起始/ 位置/ ,/ 首先/ 将/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ 赋予/ 当前/ 窗口/ 的/ 转移/ 值/ ,/ 并/ 遍历/ 临时/ 窗口/ 的/ 终止/ 位置/ 后/ 直到/ 当前/ 窗口/ 的/ 终止/ 位置/ 处/ 的/ 元组/ 及/ 计算/ 相应/ 的/ 转移/ 值/ ./ 与此同时/ ,/ 如果/ 转移/ 值/ 不/ 等于/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ ,/ 就/ 更新/ 临时/ 窗口/ 的/ 起始/ 位置/ 和/ 临时/ 转移/ 值/ ./ 所有/ 元组/ 遍历/ 结束/ 后/ 更新/ 临时/ 窗口/ 的/ 结束/ 位置/ (/ 第/ 13/ ~/ 20/ 行/ )/ ./ 如果/ 当前/ 窗口/ 的/ 起始/ 位置/ 大于/ 临时/ 窗口/ 的/ 起始/ 位置/ ,/ 遍历/ 窗口/ 内/ 的/ 所有/ 元组/ ,/ 并/ 计算/ 其/ 相应/ 的/ 转移/ 值/ ./ 与此同时/ ,/ 如果/ 转移/ 值/ 不/ 等于/ 临时/ 窗口/ 的/ 临时/ 转移/ 值/ ,/ 就/ 更新/ 临时/ 窗口/ 的/ 起始/ 位置/ 和/ 临时/ 转移/ 值/ ./ 所有/ 元组/ 遍历/ 结束/ 后/ 更新/ 临时/ 窗口/ 的/ 结束/ 位置/ (/ 第/ 21/ ~/ 27/ 行/ )/ ./ 3.2/ 消耗/ 模型/ 与/ PostgreSQL/ 原有/ 顺序调用/ 阶段/ 的/ 消耗/ 模型/ 类似/ ,/ 我们/ 假设/ 表/ 中共/ 有/ n/ 个/ 元组/ (/ n/ / 1/ )/ ,/ n/ 个/ 元组/ 处在/ 同一/ 分区/ 中/ ,/ 且/ 在/ Window/ 函数/ 的/ 执行/ 过程/ 中/ ,/ 每/ 一个/ 元组/ 的/ 数据/ 读取/ 和/ 计算/ 消耗/ 为/ C/ ./ 假设/ n/ 个/ Page9/ 窗口/ 的/ 大小/ 都/ 是/ w/ ,/ 且/ 每个/ 窗口/ 的/ 起始/ 位置/ 都/ 相对/ 于/ 上/ 一个/ 窗口/ 向下/ 平移/ 一个/ 元组/ ./ 更新/ 一次/ 临时/ 窗口/ 信息/ 的/ 消耗/ 为/ Ct/ ./ 优化/ 后/ 的/ 方法/ 计算/ 效率/ 和/ 数据分布/ 有/ 一定/ 的/ 关系/ ,/ 在/ 最好/ 情况/ 下/ 是/ 不/ 需要/ 重新/ 遍历/ 窗口/ ,/ 也就是说/ 在/ 当前/ 窗口/ 起始/ 位置/ 快要/ 逼近/ 临时/ 窗口/ 起始/ 位置/ 时/ ,/ 正好/ 更新/ 临时/ 转移/ 值/ ,/ 因为/ C/ / Ct/ 这种/ 情况/ 下/ 的/ 消耗/ 接近/ 于/ nC/ ./ 而/ 在/ 最坏/ 情况/ 下/ ,/ 每/ 一次/ 都/ 需要/ 重新/ 选择/ 临时/ 转移/ 值/ ,/ 也/ 就是/ 退化/ 为/ 没有/ 优化/ 的/ 情况/ ,/ 消耗/ 变成/ nw/ (/ C/ +/ Ct/ )/ ./ 最好/ 和/ 最坏/ 不/ 具有/ 代表性/ ,/ 下面/ 我们/ 讨论/ 更为/ 一般/ 的/ 情况/ ./ 对于/ 第一个/ 窗口/ ,/ 我们/ 需要/ 将/ 从/ 窗口/ 起始/ 位置/ 到/ 窗口/ 终止/ 位置/ 处/ 的/ 所有/ 元组/ 依次/ 进行/ 数据/ 的/ 读取/ 和/ 计算/ ,/ 并且/ 更新/ 临时/ 窗口/ 的/ 信息/ ./ 因此/ ,/ 对于/ 第一个/ 窗口/ 的/ 消耗/ 为/ 其中/ pt/ 指/ 的/ 是/ 每次/ 遍历/ 一个/ 元组/ 时/ 需要/ 更新/ 临时/ 窗口/ 信息/ 的/ 平均/ 概率/ ./ 对于/ 后面/ 的/ 窗口/ ,/ 当/ 窗口/ 的/ 起始/ 位置/ 没有/ 超越/ 临时/ 窗口/ 的/ 起始/ 位置/ 时/ ,/ 共用/ 临时/ 窗口/ 的/ 信息/ (/ 同时/ 更新/ 临时/ 窗口/ 的/ 信息/ )/ ./ 当/ 窗口/ 的/ 起始/ 位置/ 超过/ 临时/ 窗口/ 的/ 起始/ 位置/ 时/ ,/ 无可避免/ 的/ 需要/ 重新/ 遍历/ 窗口/ 内/ 的/ 所有/ 元组/ ./ 因此/ ./ 剩余/ 窗口/ 的/ 消耗/ 为/ Costw2/ →/ wn/ =/ (/ n/ -/ 1/ )/ p/ (/ wC/ +/ Ct/ +/ (/ w/ -/ 1/ )/ ptCt/ )/ +/ 其中/ p/ 指/ 的/ 是/ 一个/ 窗口/ 需要/ 重新/ 遍历/ 全部/ 元组/ 的/ 平均/ 概率/ ./ 总/ 消耗/ 为/ Cost/ =/ (/ 1/ +/ (/ n/ -/ 1/ )/ p/ )/ wC/ +/ (/ 1/ +/ (/ n/ -/ 1/ )/ p/ )/ Ct/ +/ 令/ f/ =/ Cost/ -/ Costpg/ ,/ 则/ 得/ f/ =/ (/ n/ -/ 1/ )/ (/ w/ -/ 1/ )/ Ctptp/ +/ (/ n/ -/ 1/ )/ (/ w/ -/ 1/ )/ Cp/ +/ (/ w/ -/ 1/ )/ Ctpt/ +/ nCt/ +/ (/ n/ -/ 1/ )/ (/ 1/ -/ w/ )/ C/ ./ 当/ w/ =/ 1/ 并且/ p/ =/ 1/ 时/ ,/ f/ =/ nCt/ >/ 0/ ./ 当/ w/ >/ 1/ 时/ ,/ 函数/ f/ 简写/ 形式/ 如下/ :/ 由于/ C/ / Ct/ ,/ 很/ 显然/ θ/ 2/ >/ θ/ 4/ ,/ θ/ 1/ >/ θ/ 3/ ./ 令/ θ/ 4/ -/ θ/ 1/ >/ 0/ ,/ 化简/ 得/ Cw/ >/ 1/ 时/ ,/ 1/ +/ 较大/ 时/ 1/ +/ C/ / Ct/ (/ 尤其/ 是/ 数据量/ 足够/ 大/ ,/ 致使/ 数据库/ 工作/ 内存/ 已经/ 无法/ 存放/ 所有/ 数据/ ,/ 使得/ 部分/ 数据/ 不得不/ 存放/ 在/ 磁盘/ 上/ )/ ,/ 即/ θ/ 4/ -/ θ/ 1/ >/ 0/ 成立/ ,/ 从而/ 得到/ θ/ 2/ >/ θ/ 4/ >/ θ/ 1/ >/ θ/ 3/ ./ 令/ θ/ 1/ =/ 200/ ,/ θ/ 2/ =/ 1110/ ,/ θ/ 3/ =/ 22/ ,/ θ/ 4/ =/ -/ 1100/ 可得/ 如下/ 函数/ 图像/ (/ 图/ 7/ )/ ./ 其中/ 横轴/ 为/ p/ ,/ 纵轴/ 为/ pt/ ,/ 竖轴为/ f/ ./ 随着/ 窗口/ w/ 和/ 数据量/ n/ 的/ 逐渐/ 增加/ ,/ θ/ 4/ 对/ 整个/ 函数/ 下移/ 的/ 影响/ 要/ 远/ 比/ 其他/ 3/ 个/ 参数/ 对/ 函数/ 上移/ 的/ 影响/ 大/ ./ 因此/ ,/ 窗口/ 越大/ ,/ 数据量/ 越/ 多/ ,/ 优化/ 效果/ 越/ 明显/ ./ 由于/ pt/ 指/ 的/ 是/ 每次/ 遍历/ 一个/ 元组/ 时/ 需要/ 更新/ 临时/ 窗口/ 信息/ 的/ 概率/ ,/ p/ 指/ 的/ 是/ 一个/ 窗口/ 需要/ 重新/ 遍历/ 全部/ 元组/ 的/ 概率/ ,/ 因此/ pt/ 、/ p/ 反映/ 了/ 一种/ 数据分布/ 趋势/ ./ 由/ 以上/ 分析/ 可以/ 看出/ ,/ 数据分布/ 与/ 取值/ 函数/ 越/ 趋于/ 一致/ ,/ 优化/ 效果/ 会越/ 好/ ./ 3.3/ 总结/ 本/ 节/ 主要/ 介绍/ MAX/ // MIN/ 窗口/ 函数/ 的/ 优化/ 算法/ 并/ 分析/ 其/ 计算/ 效率/ ./ 我们/ 的/ MAX/ // MIN/ 窗口/ 函数/ 优化/ 算法/ 简单/ 而/ 有效/ ,/ 仅仅/ 在/ PostgreSQL/ 默认/ 执行/ 算法/ 的/ 基础/ 之上/ 增加/ 一个/ 结构/ 用于/ 存放/ 临时/ 转移/ 值/ ,/ 从/ 额外/ 空间/ 消耗/ 的/ 角度/ 上/ 来说/ 几乎/ 可以/ 忽略/ ./ 但是/ 从/ 时间/ 消耗/ 的/ 角度/ 上/ ,/ 通过/ 我们/ 前/ 两/ 部分/ 的/ 介绍/ 可以/ 知道/ ,/ 优化/ 后/ 的/ 算法/ 在/ 绝大多数/ 情况/ 下/ 是/ 远/ 好/ 于/ 默认/ 执行/ 方法/ ,/ 即便/ 在/ 最差/ 情况/ 下/ 也/ 仅仅/ 是/ 退化/ 为/ 与/ 默认/ 算法/ 同等/ 的/ 时间/ 复杂度/ ./ 表/ 4/ 默认/ 执行/ 方式/ 与/ 优化/ 执行/ 方式/ 消耗/ 代价/ 比较/ 执行/ 情况/ 最好/ 情况/ 最差/ 情况/ 一般/ 情况/ 对于/ 默认/ 执行/ 方式/ 最好/ 情况/ 所/ 采用/ 的/ 窗口/ 定义/ 形式/ (/ BETWEENUNBOUNDEDPRECEDINGandPage10CURRENTROW/ )/ ,/ 我们/ 的/ 优化/ 策略/ 依然/ 能够/ 保证/ 最少/ 消耗/ 为/ nC/ ./ 而/ 我们/ 优化/ 策略/ 在/ 最坏/ 情况/ 下/ ,/ 只/ 比/ 默认/ 执行/ 策略/ 多/ 消耗/ nwCt/ ,/ 多出/ 的/ 开销/ 是/ 为了/ 维护/ 临时/ 窗口/ 信息/ ./ 最为/ 重要/ 的/ 是/ ,/ 上述/ 两种/ 极端/ 情况/ 在/ 实际/ 查询/ 当中/ 所/ 占/ 的/ 比例/ 很/ 低/ ,/ 也就是说/ 大多数/ 情况/ 下/ ,/ 优化/ 策略/ 能够/ 发挥/ 其/ 作用/ ,/ 对于/ 系统/ 效率/ 的/ 提高/ 大有裨益/ ./ 更为/ 具体/ 的/ 优化/ 的/ 效果/ 我们/ 将/ 在/ 下/ 一部分/ 通过/ 实验/ 加以/ 说明/ ./ 4/ 实验/ 结果/ 与/ 分析/ 4.1/ 实验/ 环境/ 我们/ 更改/ 了/ PostgreSQL9/ ./ 3.6/ 的/ 内核/ ,/ 实现/ 了/ 基于/ 临时/ 窗口/ 的/ MAX/ // MINWindow/ 函数/ 优化/ 算法/ ./ 我们/ 将/ 其/ 与/ MicrosoftSQLServer2012/ (/ ExpressEdition/ )/ 共同/ 部署/ 在/ 一台/ ThinkPadX220i/ 电脑/ 上/ ./ CPU/ 型号/ 是/ Intel/ (/ R/ )/ Core/ (/ TM/ )/ i3/ -/ 2310MCPU/ @/ 2.10/ Hz/ ,/ 内存/ 4GB1333MHzDDR3/ ./ 所有/ 数据库/ 的/ 工作/ 内存/ (/ work/ _/ mem/ )/ 设置/ 为/ 500MB/ ./ 4.2/ 实验/ 数据/ 本文/ 的/ 实验/ 数据/ 是/ 使用/ TPC/ -/ HDBGEN/ 生成/ 的/ ./ 指令/ 如下/ :/ 生成/ 的/ 是/ TPC/ -/ H/ 中/ 的/ 表/ “/ order/ ”/ ,/ 指令/ 1/ 生成/ 的/ 数据/ 集/ 大小/ 为/ 170MB/ ,/ 包含/ 1500000/ 条/ 元组/ ,/ 指令/ 2/ 生成/ 的/ 数据/ 集/ 大小/ 是/ 1.7/ GB/ ,/ 包含/ 15000000/ 条/ 元组/ ./ 4.3/ SQL/ 查询/ 语句/ 本文/ 实验/ 采用/ 的/ SQL/ 查询/ 如下/ 所示/ :/ SELECTo/ _/ totalprice/ ,/ MAX/ (/ o/ _/ totalprice/ )/ OVER/ (/ ORDERBYo/ _/ orderkeyROWSBETWEENframeoffsetPRECEDINGANDframeoffsetFOLLOWING/ )/ FROMorder/ ;/ 我们/ 通过/ 更改/ 参数/ frameoffset/ 来/ 改变/ 实验/ 中/ 窗口/ 的/ 大小/ ./ 4.4/ 实验/ 对比/ (/ 1/ )/ PG/ :/ PostgreSQL/ 中原/ 有/ 的/ 顺序调用/ 算法/ ;/ (/ 2/ )/ TW/ :/ TW/ (/ TemporaryWindow/ )/ 顺序调用/ 优化/ 算法/ ;/ (/ 3/ )/ SQLServer/ :/ MSSQLServer2012/ (/ ExpressEdition/ )/ ./ 4.5/ 实验/ 结果/ 本文/ 的/ 实验/ 对比/ 方法/ 有/ 3/ 种/ :/ (/ 1/ )/ PostgreSQL/ 数据库/ ,/ 原有/ 执行/ 框架/ ;/ (/ 2/ )/ 实现/ 了/ 基于/ 临时/ 窗口/ 的/ MAX/ // MINWindow/ 函数/ 优化/ 算法/ 的/ PostgreSQL/ 数据库/ ;/ (/ 3/ )/ MicrosoftSQLServer2012/ (/ ExpressEdition/ )/ ./ 图/ 8/ 是/ 本文/ 实验/ 采用/ 的/ SQL/ 查询/ 在/ 170MB/ 数据/ 集上/ 的/ SQL/ 查询/ 执行/ 时间/ 对比/ 图/ ./ 其中/ 横轴/ 为/ frameoffset/ ,/ 大小/ 从/ 10/ 到/ 500/ ,/ 纵轴/ 为/ SQL/ 查询/ 执行/ 时间/ ,/ 单位/ 为/ 秒/ (/ s/ )/ ./ 由图/ 中/ 可以/ 看出/ ,/ 采用/ 优化/ 算法/ TW/ 的/ 执行/ 效率/ 要/ 远/ 好/ 于/ PG/ 和/ SQLServer/ ./ 而且/ ,/ 随着/ 窗口/ 的/ 增大/ ,/ TW/ 的/ 执行/ 效率/ 的/ 提升/ 越来越/ 明显/ ,/ 其/ 基本/ 稳定/ 在/ 5s/ 之内/ ,/ 相比之下/ ,/ PG/ 和/ SQLServer/ 的/ 执行/ 时间/ 已经/ 增长/ 到/ 几百/ 秒/ ./ 图/ 8MAXWindow/ 函数/ 执行/ 时间/ (/ 170MB/ )/ 图/ 9/ 是/ 本文/ 实验/ 采用/ 的/ SQL/ 查询/ 在/ 1.7/ GB/ 的/ 数据/ 集上/ 的/ SQL/ 查询/ 执行/ 时间/ 对比/ 图/ ./ 其中/ 横轴/ 为/ frameoffset/ ,/ 大小/ 从/ 10/ 到/ 500/ ,/ 纵轴/ 为/ SQL/ 查询/ 执行/ 时间/ ,/ 单位/ 为/ 秒/ (/ s/ )/ ./ 与/ 图/ 8/ 结果/ 类似/ ,/ 采用/ 优化/ 算法/ TW/ 的/ 执行/ 效率/ 要/ 远/ 好/ 于/ PG/ 和/ SQLServer/ ./ 图/ 9/ 中/ 3/ 种/ 数据库/ 的/ SQL/ 查询/ 执行/ 时间/ ,/ 相比/ 于图/ 8/ 都/ 要/ 有所/ 上升/ ,/ 这/ 是因为/ 数据/ 集/ 的/ 增大/ 导致/ 了/ 查询处理/ 过程/ 中/ 相应/ 窗口/ 的/ 数量/ 也/ 随之/ 增加/ ,/ 使得/ 查询处理/ 时间/ 随之/ 上升/ ./ Page11/ 图/ 10/ 是/ TW/ 在/ 不同/ 数据/ 集/ 和/ 不同/ 的/ 窗口/ 大小/ 下/ SQL/ 查询/ 执行/ 时间/ 结果/ 图/ ,/ 其中/ 横轴/ 是/ frameoffset/ ,/ 纵轴/ 是/ SQL/ 查询/ 执行/ 时间/ ./ 由图/ 7/ 可以/ 看出/ ,/ 基于/ 临时/ 窗口/ 的/ MAX/ // MINWindow/ 函数/ 优化/ 算法/ TW/ ,/ 在/ 数据/ 集/ 大小/ 一定/ 的/ 情况/ 下/ ,/ SQL/ 查询/ 的/ 执行/ 时间/ 随着/ 窗口/ 大小/ 的/ 变化/ 基本/ 维持/ 稳定/ ,/ 并/ 不会/ 出现/ 较/ 大幅度/ 的/ 改变/ ./ 相比/ 于/ PG/ 、/ SQLServer/ 在/ 数据/ 集/ 一定/ 的/ 情况/ 下/ ,/ SQL/ 查询/ 执行/ 时间/ 随着/ 窗口/ 的/ 增大/ 而/ 呈/ 指数/ 级/ 增长/ ,/ TW/ 的/ 这/ 一/ 特性/ ,/ 在/ 数据处理/ 中/ 会/ 更加/ 有/ 优势/ ./ 5/ 结束语/ 针对/ MAX/ // MINSQLWindow/ 函数/ 在/ 顺序调用/ 阶段/ 的/ 执行/ ,/ 本文/ 提出/ 了/ 一种/ 基于/ 临时/ 窗口/ 的/ 优化/ 算法/ ./ 利用/ 执行/ 过程/ 中/ 产生/ 的/ 一些/ 临时/ 结果/ ,/ 极大/ 地/ 避免/ 了/ 数据库/ 中/ 元组/ 的/ 重复/ 读取/ 和/ 调用/ 转移/ 函数/ ,/ 从而/ 大大提高/ 了/ MAX/ // MINSQLWindow/ 函数/ 在/ 顺序调用/ 阶段/ 的/ 执行/ 时间/ 和/ 效率/ ./ 与/ 现有/ 的/ 算法/ 相比/ ,/ 该/ 算法/ 在/ 保证/ 结果/ 正确/ 的/ 基础/ 上/ 极大/ 提高/ 了/ 运行/ 效率/ ,/ 其/ 独有/ 的/ 特性/ 在/ 处理/ 大/ 数据/ 时/ 也/ 有/ 明显/ 的/ 优势/ ./ 致谢/ 北京/ EMC/ 实验室/ 的/ 曹/ 逾/ 博士/ 对/ 本文/ 的/ 模型/ 完善/ 和/ 实验设计/ 提出/ 了/ 有益/ 的/ 建议/ ./ 评审/ 老师/ 对/ 本文/ 提出/ 了/ 宝贵/ 的/ 修改/ 建议/ ./ 在/ 此/ 表示感谢/ !/ 

