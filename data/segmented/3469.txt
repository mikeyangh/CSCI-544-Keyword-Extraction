Page1/ 基于/ 消息传递/ 机制/ 的/ MapReduce/ 图/ 算法/ 研究/ 潘巍/ 1/ )/ 李战怀/ 1/ )/ 伍赛/ 2/ )/ 陈群/ 1/ )/ 1/ )/ (/ 西北工业大学/ 计算机/ 学院/ 西安/ 710072/ )/ 2/ )/ (/ 新加坡国立大学/ 计算机/ 学院/ 新加坡/ 119077/ )/ 摘要/ 单机/ 运行/ 环境/ 难以/ 满足/ 基于/ 海量/ 数据/ 的/ 大图/ 算法/ 对/ 时空/ 开销/ 的/ 需求/ ,/ 如何/ 设计/ 高效/ 的/ 面向/ 云/ 计算环境/ 的/ 分布式/ 大图/ 算法/ 越来越/ 受到/ 人们/ 的/ 关注/ ,/ MapReduce/ 作为/ 云/ 计算/ 的/ 核心/ 计算/ 模式/ 受限于/ 易/ 并行/ (/ EP/ )/ 计算/ 模型/ 的/ 制约/ 不易/ 表达/ 图/ 算法/ ./ 文中/ 突破/ 了/ MapReduce/ 基于/ 易/ 并行计算/ 的/ 假设/ ,/ 增强/ 了/ MapReduce/ 既有/ 的/ 编程/ 规范/ ,/ 新/ 的/ 大/ 同步/ (/ BSP/ )/ 计算/ 模型/ 既/ 能/ 保证/ 兼容/ 旧/ 的/ MapReduce/ 作业/ 可以/ 无/ 改动/ 的/ 运行/ ,/ 同时/ 引入/ 消息传递/ 机制/ 允许/ 变化/ 的/ 状态/ 数据/ 在/ 并行任务/ 的/ 超级/ 步间/ 进行/ 交互/ ./ 系统/ 提供/ 高度/ 灵活/ 的/ 消息/ 自定义/ 接口/ ,/ 针对/ 不同/ 应用/ 需求/ 设计/ 了/ 轻量级/ 和/ 重量级/ 两种/ 自/ 适应/ 的/ 消息传递/ 机制/ ,/ 更/ 高效/ 地/ 支持/ 有/ 数据/ 交互/ 需求/ 的/ 包含/ 迭代/ 处理/ 的/ 一大/ 类图/ 算法/ ./ 在/ 真实/ 大规模/ 图/ 数据/ 集上/ 的/ 实验/ 结果表明/ ,/ 相比/ 于/ 原始/ 的/ MapReduce/ 作业/ 外部/ 链式/ 处理/ ,/ 该文/ 提出/ 的/ BSP/ 模型/ 下/ 的/ 内部/ 超级/ 步/ 迭代/ 计算/ 模式/ 大幅/ 降低/ 了/ 大图/ 算法/ 的/ 处理/ 时间/ ./ 关键词/ 云/ 计算/ ;/ MapReduce/ ;/ 大/ 同步/ 模型/ ;/ 消息传递/ ;/ 图/ 算法/ ;/ PageRank1/ 引言/ 云/ 计算/ 、/ 物/ 联网/ 和/ 社交/ 网络/ 等/ 技术/ 的/ 飞速发展/ ,/ 极大丰富/ 了/ 各种/ 海量/ 异构/ 数据/ 的/ 产生/ 渠道/ ,/ 高可/ 扩展/ 的/ 海量/ 数据/ 并行处理/ 是/ 其中/ 关键性/ 的/ 技术/ 之一/ ./ MapReduce/ [/ 1/ ]/ 是/ Google/ 提出/ 的/ 一种/ 处理/ 超大规模/ 数据/ 集/ 的/ 分布式/ 并行/ 编程/ 模型/ ,/ 也/ 是/ 云/ 计算/ 目前/ 的/ 核心/ 计算/ 模式/ ./ MapReduce/ 编程/ 规范/ (/ Paradigm/ )/ 借用/ 函数/ 式/ 语言/ 的/ 映射/ (/ Map/ )/ 和/ 规约/ (/ Reduce/ )/ 原语/ ,/ 通过/ 自动/ 切分/ 输入/ 数据/ 集/ ,/ 在/ 独立/ 的/ 数据/ 切片/ (/ split/ )/ 上/ 应用/ Map/ 操作/ 产生/ 中间/ 结果/ 的/ 键值/ 对/ (/ key/ // valuepair/ )/ 集合/ ,/ 然后/ 通过/ 分区/ 操作/ (/ partition/ )/ 确保/ 具有/ 同样/ 键/ 的/ 数据/ 映射/ 到/ 同一/ 分区/ 中/ 并/ 借助/ 混洗/ 操作/ (/ shuffle/ )/ 在/ 无/ 共享/ (/ shared/ -/ nothing/ )/ 的/ 集群/ 网络/ 中/ 传递/ 中间/ 结果/ ,/ 最后/ 在/ 不同/ 的/ 中间/ 结果/ 分区/ 上/ 应用/ Reduce/ 操作/ 产生/ 最终/ 的/ 规约/ 结果/ ./ 也就是说/ 整个/ MapReduce/ 作业/ 的/ 执行/ 主要/ 分为/ Map/ 和/ Reduce/ 两个/ 处理/ 键值/ 对/ 集合/ 的/ 并行/ 运算/ 阶段/ ,/ Map/ 阶段/ 同时/ 存在/ 多个/ 异步/ 执行/ 的/ 处理/ 输入/ 键值/ 对/ 的/ Map/ 操作/ (/ 下文/ 称之为/ Mapper/ )/ ,/ Reduce/ 阶段/ 同时/ 存在/ 多个/ 异步/ 执行/ 的/ 处理/ 中间/ 键值/ 对/ 的/ Reduce/ 操作/ (/ 下文/ 称之为/ Reducer/ )/ ,/ Map/ 和/ Reduce/ 阶段/ 之间/ 需要/ 同步/ 交互/ 数据/ ./ 利用/ 这种/ 方式/ ,/ MapReduce/ 屏蔽/ 了/ 底层/ 复杂/ 的/ 并行处理/ 细节/ ,/ 极大/ 简化/ 了/ 并行程序/ 的/ 设计/ ,/ 应用/ 开发者/ 只/ 需要/ 关注/ 与/ 具体/ 应用/ 相关/ 的/ Map/ 和/ Reduce/ 的/ 处理/ 逻辑/ 本身/ ,/ 而/ 将/ 其余/ 复杂/ 的/ 并行/ 事务/ 交与/ 系统/ 完成/ ./ 近年来/ ,/ 不少/ 科研机构/ 和/ 公司/ 团体/ 都/ 研发/ 了/ 自己/ 的/ 基于/ MapReduce/ 设计规范/ 的/ 海量/ 数据/ 并行处理/ 系统/ ,/ 其中/ Apache/ 的/ Hadoop/ 是/ MapReduce/ 的/ 一种/ 开源/ 实现/ ,/ 也/ 是/ 目前/ 学术界/ 和/ 业界/ 事实上/ 的/ 海量/ 数据/ 并行处理/ 标准/ ./ Hadoop/ 可以/ 方便/ 地/ 部署/ 在/ 通用/ 的/ 商用机/ 集群/ 中/ ,/ 为/ 简化/ 用户/ 的/ 并行/ 编程/ 环境/ ,/ 高/ 抽象/ 度/ 的/ Hadoop/ 仅为/ 使用者/ 提供/ 了/ 有限/ 的/ 执行/ 策略/ ,/ 因此/ 在/ 某些/ 应用/ 上/ (/ 特别/ 是/ 图/ 的/ 算法/ )/ 只能/ 采取/ 高/ 通用性/ 低效率/ 的/ 方法/ ,/ 意图/ 在/ 易用性/ 和/ 执行/ 性能/ 上/ 进行/ 折衷/ ./ 大量/ 的/ 分布式/ 图/ 算法/ 都/ 包含/ 明显/ 的/ 迭代/ 过程/ 并且/ 在/ 数据/ 内部/ 存在/ 一定/ 的/ 依赖/ 关系/ ,/ 在/ 原始/ 的/ MapReduce/ 中/ ,/ 只能/ 通过/ 多趟/ 的/ 外部/ 链式/ 调用/ MapReduce/ 作业/ [/ 2/ -/ 3/ ]/ 来/ 支持/ 迭代/ 和/ 数据/ 交互/ ,/ 这/ 不但/ 需要/ 开发者/ 主动/ 干预/ 执行/ 的/ 过程/ ,/ 还/ 不可避免/ 会/ 引入/ 大量/ 不必要/ 的/ 重复/ 代价/ ./ 因为/ 对于/ 外部/ 链式/ 调用/ 的/ 作业/ ,/ 每轮/ 迭代/ 都/ 不可避免/ 会/ 产生/ 作业/ 启动/ 开销/ (/ 包括/ 作业/ 分发/ 、/ 输入/ 划分/ 、/ 任务/ 划分/ 等/ 一些/ 初始化/ 操作/ ,/ 根据/ 实验/ 数据分析/ 这部分/ warm/ -/ up/ 代价/ 占/ 到/ 整个/ 作业/ 执行/ 代价/ 的/ 7/ ~/ 10/ %/ 左右/ )/ 、/ 不变/ 数据/ 的/ 序列化/ 和/ 网络/ 传输/ 开销/ ,/ 迭代/ 中间/ 结果/ 的/ HDFS/ 持久/ 化/ 开销/ 等/ ./ 某些/ 进化/ 的/ 基于/ Hadoop/ 的/ 系统/ 或类/ MapReduce/ 系统/ ,/ 如/ HaLoop/ [/ 4/ ]/ 、/ Twister/ [/ 5/ ]/ 等/ 试图/ 在/ 作业/ 内部/ 完成/ 迭代/ ,/ 以期/ 减少/ 多轮/ 中间/ 结果/ 的/ 持久/ 化/ 代价/ ,/ 但是/ 在/ 实现/ 上/ 多/ 采用/ 分布式/ 内存/ 和/ 本地/ 缓存/ 来/ 存储/ 图/ 的/ 拓扑/ ,/ 这种/ 设计/ 策略/ 对/ 具有/ 海量/ 数据/ 的/ 大图/ 处理/ 存在/ 一定/ 的/ 局限性/ ./ 这种/ 并/ 不/ 优雅/ 的/ 解决问题/ 的/ 方式/ 源于/ MapReduce/ 编程/ 规范/ 中/ 一个/ 很/ 重要/ 的/ 假设/ :/ Mapper/ 或/ Reducer/ 间/ 不/ 存在/ 任何/ 依赖/ ,/ 可以/ 无/ 交互/ 的/ 在/ 不同/ 的/ 数据/ 切片/ 上/ 独立/ 执行/ ./ 这是/ 一种/ 称之为/ “/ 易/ 并行计算/ ”/ [/ 6/ ]/ (/ EmbarrassinglyParallelComputation/ ,/ EPC/ )/ 的/ “/ 理想/ ”/ 的/ 并行计算/ 模式/ ./ 基于/ 此/ 模式/ 可以/ 解决/ 的/ 并行/ 问题/ 都/ 可以/ 分解/ 为/ 多个/ 完全/ 独立/ 的/ 部分/ 且/ 他们/ 能够/ 异步/ 独立/ 执行/ ,/ 这种/ 理想/ 模式/ 下/ 异步/ 并行/ 的/ Mapper/ 之间/ (/ 或/ Reducer/ 之间/ )/ 不/ 存在/ 通信/ ,/ 数据/ 交互/ 仅/ 依赖于/ Mapper/ 和/ Reducer/ 之间/ 的/ Shuffle/ 处理/ ./ 因此/ 一些/ 有/ 中间/ 数据/ 交互/ 需求/ 的/ 包含/ 迭代/ 过程/ 的/ 并行算法/ 只能/ 借助/ MapReduce/ 作业/ 的/ 链式/ 调用/ 来/ 满足/ 多轮/ 迭代/ 的/ 数据/ 交互/ 需求/ ,/ 并/ 根据/ 应用/ 的/ 迭代/ 收敛/ 条件/ 决定/ 何时/ 终止/ 链式/ 的/ 调用/ ./ 本文/ 突破/ 了/ MapReduce/ 基于/ 易/ 并行计算/ 的/ 假设/ ,/ 设计/ 了/ 基于/ Hadoop/ 的/ 支持/ 大/ 同步/ 编程/ 规范/ [/ 7/ ]/ (/ BulkSynchronousProgramming/ ,/ BSP/ )/ 的/ 并行计算/ 框架/ ./ 改进/ 的/ 框架/ 增强/ 了/ MapReduce/ 既有/ 的/ 编程/ 规范/ ,/ 既/ 能/ 保证/ 兼容/ 旧/ 的/ MapReduce/ 作业/ 可以/ 无/ 改动/ 的/ 运行/ 在/ 新/ 的/ 并行/ 运行/ 环境/ 中/ ,/ 同时/ 利用/ 有效/ 的/ 消息传递/ 机制/ 允许/ 变化/ 的/ 中间状态/ 数据/ 在/ 任务/ 间/ 进行/ 交互/ ./ 新/ 框架/ 中将/ Map/ (/ Reduce/ )/ 阶段/ 分解/ 为/ 多个/ 同步/ 的/ 超级/ 步/ ,/ 超级/ 步内/ 任务/ 异步/ 高度/ 并行/ ,/ 超级/ 步间/ 利用/ 消息传递/ 机制/ 完成/ 任务/ 间/ 的/ 数据/ 交互/ ./ 新/ 框架/ 利用/ 图/ 节点/ 驱动/ 的/ 方式/ 更/ 高效/ 地/ 支持/ 有/ 信息/ 交互/ 需求/ 和/ 包含/ 迭代/ 处理过程/ 的/ 一大/ 类图/ 算法/ ,/ 极大/ 地/ 减少/ 了/ 图/ 算法/ 在/ MapReduce/ 既往/ 处理/ 模式/ 中/ 不必要/ 的/ 代价/ ./ 本文/ 主要/ 贡献/ 包括/ :/ (/ 1/ )/ 抽象/ 了/ 支持/ 大/ 同步/ 编程/ 规范/ 的/ 改进/ 的/ 并行计算/ 框架/ 的/ 编程/ 模型/ ,/ 利用/ 易/ 并行计算/ 的/ 形式化/ 定义/ 描述/ 了/ MapReduce/ 的/ 框架/ 实现/ ,/ 通过/ 引入/ 大/ 同步/ 模型/ 增强/ 了/ MapReduce/ 的/ 编程/ 规范/ ,/ 为/ 解决/ 包含/ 迭代/ 过程/ 且/ 有/ 交互/ 需求/ 的/ 分布式/ 大图/ 算法/ 提供/ 了/ 一种/ 高效/ 的/ 实现/ 途径/ ./ (/ 2/ )/ 定义/ 了/ 改进/ 的/ 并行计算/ 框架/ 中图/ 的/ 通用/ 表示/ 格式/ ,/ 抽象/ 了/ 以/ 节点/ 为/ 驱动/ 的/ 分布式/ 图/ 并行计算/ 模型/ ./ Page3/ (/ 3/ )/ 设计/ 了/ 障栅/ 消息/ 格式/ ,/ 实现/ 了/ 自/ 适应/ 的/ 基于/ Hadoop/ 原有/ 消息传递/ 结构/ 的/ 轻量级/ 消息传递/ 机制/ 和/ 独立/ 消息/ 服务器/ 模式/ 的/ 重量级/ 消息传递/ 机制/ ,/ 系统/ 利用/ 对/ 使用者/ 透明/ 的/ 隐式/ 同步/ 完成/ 超级/ 步间/ 的/ 同步/ 和/ 消息传递/ ./ (/ 4/ )/ 通过/ 在/ 72/ 节点/ 的/ 集群/ 环境/ 下/ 使用/ 标准/ 的/ Stanford/ 大型/ 网络/ 数据/ 集/ 设计/ 并/ 完成/ 了/ 相关/ 实验/ ,/ 实验/ 结果表明/ 在/ 给定/ 的/ 数据/ 集/ 和/ 实验/ 环境/ 下/ ,/ 改进版/ 的/ Hadoop/ 集群/ 中/ PageRank/ 算法/ 的/ 执行/ 性能/ 相比/ 于/ 原始/ 的/ Hadoop/ 集群/ 最高/ 可/ 提升/ 51/ %/ ./ 本文/ 第/ 2/ 节对/ 相关/ 工作/ 进行/ 介绍/ ;/ 第/ 3/ 节/ 描述/ 易/ 并行计算/ 和/ 大/ 同步/ 计算/ 的/ 并行/ 编程/ 模型/ 并/ 分析/ 了/ 改进/ 的/ 并行计算/ 框架/ 下/ 作业/ 执行/ 的/ 代价/ ;/ 第/ 4/ 节/ 抽象/ 大/ 同步/ 模型/ 下图/ 算法/ 的/ 计算/ 模型/ ,/ 并/ 以/ PageRank/ 为/ 典型/ 应用/ 给出/ 具体/ 的/ 示例/ ;/ 第/ 5/ 节/ 给出/ 障栅/ 消息/ 的/ 定义/ 和/ 格式/ ,/ 并/ 详细描述/ 自/ 适应/ 的/ 轻量级/ 和/ 重量级/ 消息传递/ 机制/ ;/ 第/ 6/ 节/ 通过/ 实验/ 结果/ 验证/ 改进/ 的/ 并行计算/ 框架/ 对/ PageRank/ 算法/ 的/ 高效性/ ;/ 最后/ 一节/ 对/ 全文/ 进行/ 总结/ 并/ 给出/ 未来/ 研究/ 工作/ 的/ 展望/ ./ 2/ 相关/ 工作/ MapReduce/ 已经/ 受到/ 了/ 学术界/ 和/ 工业界/ 的/ 广泛/ 关注/ 和/ 讨论/ [/ 8/ -/ 13/ ]/ ,/ 目前/ 具有/ 代表性/ 的/ 基于/ MapReduce/ 的/ 海量/ 数据/ 并行处理/ 系统/ 有/ Google/ 的/ Sawzall/ [/ 14/ ]/ 系统/ ,/ 微软/ 的/ Dryad/ [/ 15/ ]/ 系统/ 和/ SCOPE/ [/ 16/ ]/ 系统/ 、/ Yahoo/ 的/ Pig/ [/ 3/ ]/ 系统/ 以及/ Apache/ 的/ Hive/ [/ 2/ ]/ 系统/ ./ 其中/ Sawzall/ 是/ 一种/ 用于/ 极/ 大规模/ 数据/ 集合/ 的/ 平行/ 分析/ 语言/ ,/ 其/ 采用/ filter/ -/ aggregator/ (/ 过滤器/ -/ 聚合/ 器/ )/ 两/ 阶段/ 式/ 的/ 执行/ 方式/ ,/ 通过/ 限制/ 编程/ 模式/ 来/ 保证/ 高/ 并发/ 和/ 扩展/ 能力/ ,/ 它/ 在/ 语言/ 级别/ 保证/ 了/ 平行/ 处理/ 的/ 任务/ 间/ 不/ 存在/ 相互依赖/ ./ Dryad/ 提供/ 了/ 能够/ 在/ Win/ -/ dows/ 或者/ ./ Net/ 平台/ 上/ 编写/ 大规模/ 的/ 并行/ 应用程序/ 的/ 分布式/ 并行计算/ 基础/ 平台/ ,/ 利用/ 过程/ 式/ 高级/ 语言/ 接口/ DryadLINQ/ 使得/ 无/ 并行/ 编程/ 经验/ 的/ 程序员/ 可以/ 轻松/ 完成/ 大规模/ 的/ 分布式计算/ 任务/ ./ SCOPE/ 系统/ 是/ 建立/ 在/ Dryad/ 之上/ 的/ 用于/ 大规模/ 数据/ 并行/ 分析/ 的/ 声明/ 式/ 语言/ ,/ 允许/ 用户/ 自定义/ 函数/ 来/ 实现/ 更/ 丰富/ 的/ 计算/ ./ Pig/ 和/ Hive/ 基于/ Hadoop/ 提供/ 了/ 高层/ 的/ 语言/ 支持/ ,/ Pig/ 引入/ 了/ 一种/ SQL/ -/ Like/ 语言/ PigLatin/ ,/ 借助/ 该/ 语言/ 编写/ 的/ 脚本/ 可以/ 被/ 自动/ 转化/ 为/ MapReduce/ 作业/ ;/ Hive/ 是/ 一个/ 开源/ 的/ 数据仓库/ 解决方案/ ,/ 提供/ 了/ SQL/ -/ Like/ 的/ 陈述/ 性/ 语言/ HiveQL/ ,/ 支持/ 类似/ SQL/ 的/ 海量/ 数据/ 查询/ 方式/ ,/ 查询/ 被/ 编译成/ MapReduce/ 作业/ 在/ Hadoop/ 上/ 执行/ ./ 两者/ 都/ 简化/ 了/ 编写/ MapReduce/ 作业/ 的/ 代价/ ,/ 但是/ 这种/ 简便/ 是/ 以/ 牺牲/ 执行/ 性能/ 为/ 代价/ 的/ ./ 此外/ 还有/ Hyracks/ [/ 17/ ]/ 、/ Spark/ [/ 18/ ]/ 、/ Nephele/ [/ 19/ ]/ 等/ 多个/ 受/ MapReduce/ 启发/ 的/ 海量/ 数据处理系统/ ,/ 上述/ 并行处理/ 系统/ 都/ 是/ 高/ 通用性/ 的/ 并行/ 平台/ ,/ 并/ 没有/ 针对/ 分布式/ 并行/ 图/ 算法/ 的/ 特点/ 设计/ 高效/ 的/ 支持/ 方法/ ,/ 因此/ 处理/ 效率/ 都/ 不/ 理想/ ./ 针对/ 传统/ 的/ MapReduce/ 不/ 易于/ 表达/ 迭代/ 式/ 操作/ 的/ 问题/ ,/ Bu/ 等/ 人/ [/ 4/ ]/ 设计/ 了/ HaLoop/ 一种/ 基于/ Hadoop/ 的/ 支持/ 内部/ 迭代/ 的/ 数据/ 并行处理/ 系统/ ,/ 有效/ 减少/ 了/ 迭代/ 过程/ 中/ 数据/ 重载/ 以及/ 迭代/ 中间/ 结果/ 持久/ 化/ 的/ 开销/ ,/ 但是/ 无法/ 消除/ 中间/ 数据/ 排序/ 以及/ 重复/ 任务/ 启动/ 的/ 代价/ ./ 相比/ 于/ Hadoop/ ,/ Twister/ [/ 5/ ,/ 20/ ]/ 是/ 一个/ 研究性/ 实验/ 项目/ ,/ 其/ 基于/ MapReduce/ 思想/ 设计/ 了/ 支持/ 迭代/ 的/ 并行/ 编程/ 模型/ ,/ 但/ 该/ 系统/ 假设/ 待处理/ 数据/ 不/ 需要/ 分布式文件系统/ 支持/ 可/ 完全/ 加载/ 于/ 分布式/ 内存/ ,/ 导致/ 其/ 不/ 满足/ 海量/ 数据处理/ 的/ 实际/ 应用/ 需求/ ,/ 且/ 其/ 输入/ 数据/ 手动/ 切分/ 的/ 策略/ 也/ 增加/ 了/ 开发者/ 设计/ 并行/ 应用/ 的/ 难度/ ./ Apache/ 的/ 开源/ 项目/ Mahout/ [/ 21/ ]/ 其/ 设计/ 目标/ 是/ 基于/ Hadoop/ 创建/ 高可/ 伸缩/ 的/ 机器/ 学习/ 算法/ ,/ 几乎/ 所有/ 的/ 机器/ 学习/ 算法/ 都/ 涉及/ 迭代/ 的/ 过程/ ,/ Mahout/ 专门/ 设计/ 了/ 外部/ 驱动程序/ 来/ 控制/ 迭代/ 的/ 执行/ ,/ 每轮/ 迭代/ 都/ 需要/ 启动/ 新/ 的/ MapReduce/ 作业/ ,/ 如/ 引言/ 中/ 所述/ ,/ 这种/ 外部/ 迭代/ 的/ 方式/ 会/ 引入/ 很多/ 不必要/ 的/ 执行/ 代价/ ./ 目前/ 专门/ 面向/ 大规模/ 图/ 算法/ 的/ 分布式/ 并行/ 编程/ 模型/ 及/ 相关/ 优化/ 的/ 研究/ 工作/ 也/ 有/ 很多/ 成果/ ./ Google/ 的/ Pregel/ [/ 22/ ]/ 编程/ 框架/ 能够/ 为/ 图/ 算法/ 提供/ 并行/ 支持/ ,/ 其/ 根据/ 图/ 的/ 特点/ 是/ 设计/ 了/ 顶点/ 传递信息/ 的/ 多轮/ 迭代/ 处理/ 模式/ ./ 但/ 该/ 平台/ 并/ 不/ 基于/ Hadoop/ ,/ 在/ 开放性/ 和/ 通用性/ 上均/ 有所/ 限制/ ,/ 并且/ 其/ 所有/ 的/ 计算/ 状态/ 均/ 保存/ 于/ 内存/ ,/ 因此/ 也/ 缺乏/ 对/ 大规模/ 数据/ 的/ 有效/ 支持/ ./ AveryChing/ 等/ 人/ 提出/ 了/ 一种/ 基于/ Hadoop/ 的/ 大规模/ 图/ 处理/ 框架/ Giraph/ ①/ ,/ 该/ 框架/ 支持/ 动态/ 资源管理/ ,/ 利用/ 高/ 可用/ 容错/ 的/ ZooKeeper/ 实现/ 系统/ 工作/ 单元/ 的/ 分布式/ 协调/ ,/ 并/ 提供/ 了/ 支持/ 迭代/ 的/ 图形处理/ 库/ ,/ 其/ 和/ 本文/ 设计/ 的/ 编程/ 框架/ 都/ 已期/ 在/ Hadoop/ 平台/ 上/ 利用/ 大/ 同步/ 编程/ 规范/ 提升/ 迭代/ 式/ 图/ 算法/ 的/ 处理/ 能力/ ,/ 但/ 在/ 设计/ 策略/ 和/ 实现/ 细节/ (/ 特别/ 是/ 消息/ 处理/ )/ 上/ 有/ 诸多/ 不同/ ,/ 相对/ 于/ Giraph/ 构建/ 于/ Hadoop/ 之上/ 的/ 多线程/ 架构/ ,/ 本文/ 设计/ 的/ 框架/ 采用/ 了/ 侵入/ 式/ 的/ 设计模式/ ,/ 利用/ 通信/ 实现/ 工作/ 节点/ 间/ 的/ 分布式/ 协调/ ,/ 无需/ 手工/ 切分/ 和/ 分布/ 输入/ 数据/ 等/ ,/ 因此/ 在/ 兼容性/ 、/ 易用性/ 和/ 通用性/ 等/ 特性/ 上/ 更具/ 优势/ ./ Surfer/ [/ 23/ ]/ 系统/ 提供/ 了/ ①/ Giraph/ ./ http/ :/ // // incubator/ ./ apache/ ./ org/ // giraph/ // Page4MapReduce/ 原语/ 和/ Propagation/ 原语/ ,/ 并/ 利用/ 基于/ 原语/ 的/ 构建/ 块/ 来/ 支持/ 在/ 云/ 上/ 的/ 大图/ 算法/ ,/ 其/ 主要/ 目标/ 在于/ 提供/ 运行/ 期/ 的/ 可视化/ 监控/ ,/ 并/ 没有/ 涉及/ 针对/ 图/ 特征/ 的/ 具体/ 实现/ 细节/ ./ Lin/ 等/ 人/ 在/ 文献/ [/ 24/ -/ 25/ ]/ 中/ 对/ MapReduce/ 的/ 图/ 算法/ 实现/ 进行/ 局部优化/ ,/ 提出/ 了/ Mapper/ 内/ 合并/ 、/ 避免/ 图/ 拓扑/ 重复/ 传递/ 以及/ 范围/ 分区/ 等/ 优化/ 技术/ ,/ 但/ 其/ 还是/ 基于/ 多轮/ 的/ MapReduce/ 作业/ 调度/ ./ 还有/ 很多/ 并行处理/ 框架/ ,/ 像/ Apache/ 的/ HAMA/ [/ 26/ ]/ 和/ CMU/ 的/ GraphLab/ [/ 27/ ]/ 等/ 也/ 都/ 支持/ 迭代/ ,/ 但是/ 这些/ 平台/ 均/ 面向/ 特定/ 的/ 问题/ 领域/ ./ 此外/ 还有/ 很多/ 研究/ [/ 28/ -/ 29/ ]/ 是/ 希望/ 借鉴/ 并行计算/ 中/ 的/ 成熟/ 的/ 消息传递/ 接口/ (/ MessagePassingInterface/ ,/ MPI/ )/ 技术/ 提升/ MapReduce/ 的/ 处理/ 能力/ ,/ 但/ 这些/ 研究/ 都/ 没有/ 给出/ 基于/ Hadoop/ 平台/ 的/ 实现/ ,/ 在/ 容错/ 、/ 可/ 扩展/ 、/ 鲁棒性/ 等/ 特性/ 上/ 都/ 存在/ 缺失/ ./ 本文/ 旨在/ 继承/ Hadoop/ 原有/ 的/ 诸多/ 特性/ 的/ 基础/ 上/ 通过/ 引入/ 大/ 同步/ 模型/ ,/ 利用/ 消息传递/ 机制/ 和/ 超级/ 步/ 同步/ 来/ 更/ 高效/ 地/ 支持/ 分布式/ 图/ 算法/ ./ 3/ 并行/ 编程/ 模型/ 抽象/ 和/ 代价/ 分析/ 本节/ 将/ 介绍/ MapReduce/ 支持/ 的/ 既有/ 计算/ 模式/ 和/ 本文/ 改进/ 的/ 计算/ 模式/ ,/ 并/ 分析/ 了/ 改进/ 模式/ 的/ 相关/ 代价/ ./ 同时/ 抽象/ 出/ 基于/ 稀疏/ 有向图/ 的/ 并行算法/ 在/ MapReduce/ 并行/ 编程/ 环境/ 下/ 迭代/ 执行/ 的/ 设计模式/ ./ 3.1/ 易/ 并行/ (/ EP/ )/ 计算/ 并行计算/ 可以/ 用/ 多种不同/ 的/ 并行/ 编程/ 模型表示/ 和/ 实现/ ,/ 每/ 一种/ 模型/ 都/ 有/ 与其/ 相适应/ 的/ 一类/ 计算/ 应图/ 1/ 并行/ 编程/ 模型/ 用/ ./ 为/ 简化/ 并行/ 应用/ 开发者/ 的/ 开发/ 工作/ ,/ 使/ 无/ 并行/ 开发/ 经验/ 的/ 程序员/ 也/ 可以/ 正确/ 快速/ 地/ 编写/ 并行/ 应用/ ,/ MapReduce/ 对/ 编程/ 模型/ 进行/ 了/ 限制/ ,/ 使/ MapReduce/ 编程/ 模型/ 主要/ 针对/ 易/ 并行/ (/ EmbarrassinglyParallel/ ,/ EP/ )/ 计算/ 抽象/ ./ 正是/ 利用/ 这种/ 限制性/ 的/ 模式/ ,/ MapReduce/ 实现/ 了/ 并行程序/ 的/ 自动/ 并发/ 处理/ ,/ 并/ 在/ 内部/ 提供/ 了/ 诸如/ 输入/ 划分/ 、/ 并行/ 任务调度/ 及/ 通信/ 、/ 容错/ 、/ 负载/ 均衡/ 等/ 并行/ 细节/ 的/ 自动/ 支持/ ,/ 实现/ 了/ 高/ 可扩展性/ 和/ 高度/ 并行性/ ./ 下面/ 先/ 给出/ 易/ 并行计算/ 的/ 形式化/ 定义/ ./ 定义/ 1/ (/ 易/ 并行计算/ )/ ./ 并行计算/ 中/ ,/ 假定/ 给定/ 一个/ 并行/ 作业/ J/ ,/ 其/ 可以/ 分解/ 为/ 一系列/ 可/ 异步/ 并行执行/ 的/ 任务/ T/ ,/ 同时/ 给定/ 一个/ 输入/ 数据/ 集/ W/ 和/ 并行任务/ 间/ 的/ 通信/ 代价/ C/ ,/ 如果/ 对/ 输入/ 数据/ 集/ W/ 的/ 任一/ 划分/ / P/ =/ {/ p1/ ,/ p2/ ,/ …/ ,/ pm/ }/ ,/ 若/ 其/ 满足/ pi/ ∩/ pj/ =/ / ,/ ∪/ ipi/ =/ W/ 以及/ C/ (/ T/ (/ pi/ )/ ,/ T/ (/ pj/ )/ )/ =/ 0/ (/ 1/ </ m/ </ |/ W/ |/ ,/ 1/ </ i/ ,/ j/ </ m/ )/ 条件/ 时/ ,/ 并行/ 作业/ J/ 可/ 表示/ 为/ J/ =/ ∪/ mi/ =/ 1T/ (/ pi/ )/ ,/ 称/ 满足/ 以上/ 条件/ 的/ 并行计算/ 为易/ 并行计算/ ./ 也就是说/ ,/ 若干/ 并行任务/ 可以/ 在/ 互斥/ 的/ 输入/ 集/ 划分/ 上/ 无/ 通信/ 代价/ 地/ 独立/ 执行/ ./ 下面/ 利用/ 易/ 并行/ 的/ 形式化/ 定义/ 分析/ MapReduce/ 的/ 编程/ 模型/ ./ 从图/ 1/ (/ a/ )/ 中/ 可以/ 看到/ ,/ MapReduce/ 作业/ 执行/ 计划/ 分为/ Map/ 和/ Reduce/ 两个/ 阶段/ ,/ 也/ 称之为/ 一次/ MR/ 过程/ ,/ MR/ 过程/ 中/ 每个/ 阶段/ 内部/ 的/ 异步/ 并行任务/ (/ Map0/ ~/ Mapm/ 或者/ Reduce0/ ~/ Reducen/ )/ 都/ 运行/ 在/ 易/ 并行/ 的/ 理想/ 模式/ 下/ ./ Page5/ 在/ Map/ 阶段/ ,/ 输入/ 数据/ 被/ 自动/ 切/ 分成/ 等/ 大小/ 的/ 独立/ 输入/ 片段/ Split0/ ~/ Splitm/ (/ Split/ 的/ 默认值/ 是/ 64MB/ ,/ 和/ 底层/ 分布式系统/ 存储/ 块/ 等/ 大小/ ,/ 这种/ 策略/ 避免/ 了/ Split/ 跨越/ 块/ 边界/ 而/ 可能/ 引发/ 的/ 数据传输/ 导致/ 的/ 网络/ 代价/ )/ ,/ 输入/ 片段/ 是/ 若干/ 键值/ 对/ 构成/ 的/ 集合/ ./ MapReduce/ 并行处理/ 框架/ 会/ 依据/ 数据/ 本地化/ 优化/ 策略/ 将/ Map0/ ~/ Mapm/ 分布/ 到/ 输入/ 片段/ 所在/ 的/ 执行/ 节点/ 上/ 运行/ ./ 执行/ 过程/ 中/ Map0/ ~/ Mapm/ 之间/ 不/ 存在/ 任何/ 依赖/ 关系/ 无需/ 通信/ 交互/ ,/ 符合/ 易/ 并行/ 的/ 形式化/ 定义/ ,/ 其/ 产生/ 的/ 中间/ 结果/ 是/ 新/ 的/ 键值/ 对/ 集合/ ./ 在/ Reduce/ 阶段/ ,/ 由/ Map0/ ~/ Mapm/ 产生/ 的/ 中间/ 结果/ 经过/ 按/ 输出/ 键/ 分区/ 操作/ 后/ (/ 默认/ 是/ 采用/ 散列/ 分区/ 的/ 方式/ ,/ 在/ 输入/ 数据/ 集/ 的/ 分布/ 不/ 偏斜/ 的/ 情况/ 下/ ,/ 散列/ 能/ 得到/ 分散/ 均匀/ 的/ 中间/ 结果/ 分区/ )/ 产生/ 的/ 中间/ 结果/ 分区/ Part0/ ~/ Partn/ 作为/ Reduce0/ ~/ Reducen/ 的/ 输入/ ./ 执行/ 过程/ 中/ Reduce0/ ~/ Reducen/ 之间/ 不/ 存在/ 任何/ 依赖/ 关系/ 无需/ 通信/ 交互/ ,/ 符合/ 易/ 并行/ 的/ 形式化/ 定义/ ,/ 最终/ Reducer/ 的/ 输出/ 结果/ 会/ 自动/ 被/ 持久/ 化到/ 底层/ 存储介质/ 上/ (/ 默认/ 是/ HDFS/ )/ ./ Map/ 阶段/ 和/ Reduce/ 阶段/ 之间/ 是/ 串行/ 同步/ 的/ ,/ 存在/ 一个/ 相对/ 用户/ 透明/ 的/ 隐式/ 同步/ 和/ 通信/ 过程/ ./ Reducer/ 必须/ 等到/ 最后/ 一个/ Mapper/ 执行/ 完毕/ 后/ 才/ 开始/ 执行/ (/ 但是/ ,/ 其中/ Mapper/ 产生/ 的/ 中间/ 数据/ 的/ Shuffle/ 过程/ 是/ 与/ Mapper/ 以/ 重叠/ 方式/ 执行/ 的/ ,/ 即任/ 一个/ Mapper/ 结束/ 后/ ,/ Reducer/ 就/ 可以/ Shuffle/ 中间/ 结果/ ,/ 这样/ 可以/ 缩短/ 并行/ 流水/ 处理/ 的/ 长度/ ,/ 提高/ 处理/ 的/ 效率/ )/ ./ 如果/ 一个/ 并行/ 应用/ 需要/ 使用/ 多趟/ 的/ MR/ 过程/ ,/ 那么/ 一次/ MR/ 过程/ 与/ 下/ 一次/ MR/ 过程/ 之间/ 也/ 是/ 链式/ 串行/ 同步/ 的/ ./ 通信/ 和/ 数据/ 交互/ 也/ 仅/ 发生/ 在/ 一次/ MR/ 过程/ 中/ 的/ Map/ 阶段/ 和/ Reduce/ 阶段/ 之间/ 以及/ 多趟/ MR/ 过程/ 之间/ ./ 大量/ 实际/ 应用/ 属于/ 易/ 并行计算/ 模式/ ,/ 如/ 分布式/ 的/ Grep/ 、/ 倒排/ 索引/ 以及/ 分布式/ 排序/ 等/ ,/ 这/ 类/ 问题/ 非常适合/ 用易/ 并行计算/ 模式/ 处理/ ./ 然而/ ,/ 易/ 并行计算/ 是/ 整个/ 并行计算/ 设计/ 体系/ 中/ 最/ 理想/ 的/ 一类/ 计算/ 问题/ ./ Sutter/ 等/ 人/ [/ 30/ ]/ 将/ 并行计算/ 模式/ 分为/ 3/ 种/ 类型/ :/ 无/ 依赖/ 并行/ (/ Independentparallelism/ )/ 、/ 规则/ 并行/ (/ Regu/ -/ larparallelism/ )/ 和/ 无/ 结构/ 并行/ (/ Unstructuredparal/ -/ lelism/ )/ ./ 其中/ 无/ 依赖/ 并行/ 即/ 是/ 前文/ 讨论/ 的/ 易/ 并行/ ,/ 规则/ 并行/ 是/ 比易/ 并行/ 更/ 高级/ 的/ 并行/ 模式/ ./ 规则/ 并行/ 适用/ 于/ 并行计算/ 工作/ 存在/ 一定/ 依赖/ 、/ 在/ 并行操作/ 间/ 有/ 通信/ 或/ 同步/ 需求/ 的/ 并行/ 应用/ 类型/ ./ 本文/ 希望/ 通过/ 引入/ 消息传递/ 机制/ 扩展/ MapReduce/ 支持/ 的/ 并行/ 模式/ ,/ 使/ MapReduce/ 以/ 更/ 优雅/ 更/ 高效/ 的/ 方式/ 支持/ 诸如/ PageRank/ 等/ 大量/ 的/ 规则/ 并行/ 应用/ ./ 3.2/ 大/ 同步/ (/ BSP/ )/ 计算/ 引入/ 消息传递/ 机制/ 的/ 主要/ 挑战/ 在于/ 在/ 现有/ 的/ MapReduce/ 并行计算/ 框架/ 中/ ,/ Mapper/ 之间/ 或/ Reducer/ 之间/ 不/ 支持/ 消息传递/ ./ 本文/ 中/ Map/ (/ 或/ Reduce/ )/ 阶段/ 内部/ 支持/ 消息传递/ 的/ 灵感/ 来源于/ 并行计算/ 的/ BSP/ 模型/ ,/ BSP/ 模型/ 相对/ 现有/ 的/ MapReduce/ 提供/ 了/ 更/ 高级/ 别的/ 并行/ 抽象/ ,/ 利用/ 障栅/ 实现/ 同步控制/ ,/ 使用/ 消息传递/ 机制/ 完成/ 并行任务/ 间/ 数据/ 的/ 交互/ ./ 下面/ 先/ 给出/ BSP/ 模型/ 的/ 定义/ ./ 定义/ 2/ (/ 大/ 同步/ 计算/ )/ ./ 大/ 同步/ 计算/ 模型/ 中/ ,/ 一个/ 并行/ 作业/ 由/ 一系列/ 的/ 超级/ 步/ (/ Supersteps/ )/ 组成/ ,/ 每个/ 超级/ 步/ 构成/ 一个/ 相/ 并行/ (/ PhaseParallel/ )/ ./ 大/ 同步/ 计算/ 主要/ 由/ 3/ 个/ 有序/ 的/ 部分/ 构成/ :/ (/ 1/ )/ 易/ 并行计算/ ./ 超级/ 步内/ 各/ 任务/ 独立/ 的/ 异步/ 并行执行/ ;/ (/ 2/ )/ 通信/ ./ 并行任务/ 在/ 超级/ 步/ 结束/ 前/ 利用/ 消息传递/ 机制/ 完成/ 数据/ 的/ 交互/ ;/ (/ 3/ )/ 障栅/ 同步/ ./ 同步/ 等待/ 同一个/ 超级/ 步内/ 所有/ 并行任务/ 的/ 交互/ 全部/ 完成/ ,/ 则/ 整个/ 并行/ 才/ 可以/ 向下/ 一个/ 超级/ 步/ 移动/ ,/ 进入/ 下/ 一轮/ 的/ 相/ 并行/ ./ 从图/ 1/ (/ b/ )/ 中/ 可以/ 看到/ 本文/ 设计/ 的/ 支持/ BSP/ 模型/ 的/ MapReduce/ 并行处理/ 框架/ 和/ 原始/ 的/ MapReduce/ 并行处理/ 框架/ 在/ 整体/ 框架/ 逻辑/ 上/ 保持一致/ ./ 从/ 宏观/ 的/ 角度观察/ ,/ 如果/ 将/ 一次/ MR/ 过程/ 的/ 整个/ Map/ 阶段/ 视为/ 一个/ 超级/ 步/ ,/ 整个/ Reduce/ 阶段/ 视为/ 另/ 一个/ 超级/ 步/ ,/ 两个/ 阶段/ 间/ 的/ Shuffle/ 过程/ 视为/ 超级/ 步间/ 的/ 障栅/ 同步/ 和/ 通信/ 过程/ ,/ 那么/ 其实/ MapReduce/ 本身/ 也/ 是/ 符合/ 大/ 同步/ 计算/ 的/ ,/ 这/ 也/ 是/ 为什么/ 通过/ 链式/ 的/ MapReduce/ 作业/ 调度/ 可以/ 满足/ 有/ 交互/ 需求/ 的/ 迭代/ 运算/ 的/ 实现/ 依据/ ./ BSP/ 模型/ 中/ ,/ 利用/ 消息传递/ 机制/ 并行任务/ 间/ 可以/ 交互/ 变化/ 的/ 中间状态/ 数据/ ,/ 并行任务/ 间/ 的/ 消息传递/ 不是/ 任务/ 间/ 单独/ 分散/ 的/ 行为/ ,/ 而是/ 被/ 视为/ 一个/ 整体/ 并/ 约束/ 在/ 相邻/ 超级/ 步/ 之间/ ./ 任务/ 发送/ 的/ 消息/ 需要/ 在/ 一个/ 超级/ 步内/ 进行/ 汇集/ ,/ 上/ 一个/ 超级/ 步/ 汇集/ 的/ 消息/ 需要/ 等到/ 下/ 一个/ 超级/ 步内/ 并行任务/ 执行/ 时/ 才能/ 使用/ ,/ 消息/ 不能/ 跨越/ 不/ 连续/ 的/ 超级/ 步/ 使用/ ./ 利用/ 消息传递/ ,/ 同样/ 的/ 并行/ 逻辑/ 可以/ 使用/ 交互/ 的/ 数据/ 在/ 一个/ 新/ 的/ 状态/ 下/ 继续/ 运行/ ./ 迭代/ 的/ 计算/ 都/ 可以/ 抽象/ 为/ 相同/ 的/ 处理/ 逻辑/ ,/ 在/ 新/ 的/ 状态/ 数据/ 集中/ 期望/ 收敛/ 地/ 连续/ 执行/ ,/ 因此/ 这种/ 模式/ 非常适合/ 存在/ 迭代/ 需求/ 的/ 分布式/ 并行/ 图/ 算法/ ./ 并且/ 这种/ 不/ 跨越/ 超级/ 步/ 的/ 消息传递/ 模式/ 也/ 有效/ 简化/ 了/ 大量/ 并行任务/ 间/ 消息/ 的/ 维护/ 代价/ ./ 要/ 保证/ 消息/ 能以/ 整体/ 汇集/ 的/ 形式/ 有序/ 地/ 在/ 超级/ 步间/ 传递/ ,/ 就/ 必须/ 依赖/ 超级/ 步间/ 有效/ 的/ 同步/ 机制/ ./ 在/ Page6BSP/ 模型/ 中/ ,/ 超级/ 步/ 之间/ 的/ 同步/ 等待/ 是/ 借助/ 障栅/ [/ 31/ ]/ 来/ 实现/ 的/ ./ 障栅是/ 一种/ 可控/ 的/ 粗粒度/ 级/ 的/ 全局/ 同步/ 机制/ ,/ 利用/ 障栅/ 可以/ 将/ 一趟/ 并行任务/ 划分/ 为/ 多个/ 连续/ 的/ 松散/ 同步/ 的/ 超级/ 步/ ,/ 如图/ 1/ (/ b/ )/ 中/ 的/ SS0/ 、/ SS1/ 等/ ./ 其/ 保证/ 了/ 消息/ 仅/ 在/ 一个/ 超级/ 步/ 之内/ 汇集/ ,/ 并/ 在/ 相邻/ 的/ 后继/ 超级/ 步间/ 传递/ ,/ 关于/ 障栅/ 的/ 概念/ 在/ 第/ 5.1/ 节中/ 有/ 更/ 详细/ 的/ 介绍/ ./ 本文/ 改进/ 的/ 并行处理/ 框架/ 试图/ 在/ Map/ 或/ Reduce/ 阶段/ 内部/ 支持/ 超级/ 步/ ,/ 基于/ 这种/ 设计模式/ ,/ 以往/ 需要/ 通过/ 多趟/ MapReduce/ 作业/ 外部/ 链式/ 调用/ 才能/ 实现/ 的/ 迭代/ 式/ 计算/ ,/ 现在/ 可以/ 在/ 一次/ MR/ 过程/ 中/ ,/ 利用/ Map/ 阶段/ 内部/ (/ 或/ Reduce/ 阶段/ 内部/ )/ 的/ 多个/ 超级/ 步/ 的/ 同步/ 执行/ 就/ 可以/ 完成/ ./ 复杂/ 的/ 消息传递/ 控制/ 由/ 新/ 的/ 运行/ 时/ 系统/ 处理/ (/ 具体/ 实现/ 细节/ 参看/ 第/ 5/ 节/ )/ ,/ 并行程序/ 开发者/ 只/ 需要/ 利用/ 原有/ 的/ MapReduce/ 程序开发/ 经验/ 就/ 可以/ 在/ 改进/ 的/ 并行/ 框架/ 下/ 编写/ 更/ 高效/ 的/ 并行/ 应用/ ./ 改进/ 的/ 并行/ 框架/ 有效/ 减少/ 了/ 占据/ 大量/ 处理/ 时间/ 的/ 外部/ 迭代/ 引入/ 的/ 代价/ ./ 但是/ ,/ 相对/ 于/ 原有/ 的/ Hadoop/ 并行计算/ 框架/ 的/ 代价/ [/ 32/ ]/ ,/ 改进/ 的/ 支持/ BSP/ 模型/ 的/ 并行计算/ 框架/ 也/ 引入/ 了/ 一些/ 新/ 的/ 代价/ :/ 首先/ ,/ 粗粒度/ 的/ 障栅/ 同步/ 使得/ 单个/ 超级/ 步/ 的/ 总体/ 执行/ 时间/ 对/ 单个/ 最慢/ 完成/ 任务/ 是/ 敏感/ 的/ ,/ 针对/ 非/ 一致性/ 状态/ 下/ 任务/ 完成/ 时间/ 异常/ 的/ 问题/ 可以/ 借助/ Hadoop/ 的/ 推测/ 执行/ (/ SpeculativeExecution/ )/ 机制/ [/ 1/ ]/ ,/ 利用/ 冗余/ 执行/ 的/ 备用/ 任务/ 有效/ 缓解/ ,/ 并且/ 由于/ 一个/ 超级/ 步内/ 并发/ 的/ 多个/ 任务/ 的/ 计算/ 和/ 通信/ 是/ 重叠/ 执行/ 的/ ,/ 所以/ 此/ 代价/ 还/ 能/ 进一步/ 地被/ 一个/ 超级/ 步内/ 异步/ 并行/ 的/ 多个/ 任务/ 摊销/ ;/ 其次/ ,/ 新/ 代价/ 模型/ 中/ 的/ 障栅/ 同步/ 是/ 一个/ 潜在/ 的/ 可能/ 会/ 造成/ 性能/ 下降/ 的/ 瓶颈/ ,/ 但是/ ,/ 实际上/ 改进/ 模型/ 中/ 的/ 障栅/ 同步/ 只是/ 将/ 原/ 模型/ 中/ 多次/ MR/ 过程/ 间/ Map/ 和/ Reduce/ 阶段/ 的/ 隐式/ 障栅/ 同步/ 转移/ 成/ 一次/ MR/ 过程/ 中/ Map/ 和/ Reduce/ 阶段/ 内/ 的/ 多次/ 障栅/ 同步/ ,/ 所以/ 本质/ 上/ 并/ 没有/ 增加/ 任何/ 新/ 的/ 同步/ 代价/ ./ 4BSP/ 模型/ 下图/ 算法/ 的/ 计算/ 模型/ 本/ 节/ 根据/ 新/ 引入/ 的/ BSP/ 模型/ ,/ 介绍/ 如何/ 在/ 此/ 模型/ 下/ 进行/ 高效/ 的/ 图/ 算法/ 的/ 设计/ 和/ 实现/ ,/ 包括/ 图/ 如何/ 在/ 改进/ 的/ 并行计算/ 框架/ 中/ 表示/ ,/ 以及/ 如何/ 建立/ 以/ 节点/ 为/ 驱动/ 的/ 图/ 并行计算/ 模型/ ,/ 并/ 以/ PageRank/ 为/ 典型/ 应用/ 给出/ 具体/ 的/ 应用/ 示例/ ./ 4.1/ 图/ 在/ 并行计算/ 框架/ 中/ 的/ 表示/ 基于/ BSP/ 模型/ 的/ 并行计算/ 框架/ 主要/ 意图/ 在于/ 利用/ 图/ 的/ 特点/ 以/ 更/ 高效/ 的/ 方式/ 支持/ 分布式/ 图/ 算法/ ./ 众所周知/ ,/ 在/ 单机/ 运行/ 环境/ 中/ 往往/ 难以/ 满足/ 图/ 运算/ (/ 特别/ 是/ 大图/ )/ 对/ 时空/ 开销/ 的/ 需求/ ,/ MapReduce/ 并行计算/ 框架/ 虽然/ 可以/ 满足/ 分布式/ 图/ 运算/ 对/ 可扩展性/ 的/ 需求/ ./ 但是/ 由于/ 其/ 无/ 状态/ 并行/ 的/ 任务/ 没有/ 利用/ 节点/ 的/ 依赖/ 关系/ ,/ 所以/ 不易/ 直接/ 表达/ 图/ 算法/ ./ 把/ 图/ 运算/ 放入/ 并行计算/ 框架/ 中/ 执行/ 首先/ 需要/ 把/ 图剖/ 分成/ 适合/ MapReduce/ 处理/ 的/ 输入/ 键值/ 对/ 集合/ ./ 邻接矩阵/ 和/ 邻接/ 链表/ 是/ 两种/ 最/ 常用/ 图/ 的/ 表示/ 形式/ ./ 因为/ 实际/ 应用/ 中/ 的/ 大/ 图常/ 呈现出/ 典型/ 的/ 稀疏/ 特性/ [/ 22/ ]/ ,/ 如/ 社交/ 网络图/ 、/ 网页/ 链接/ 关系/ 图/ 等/ ,/ 所以/ 相对/ 于/ O/ (/ n2/ )/ 空间/ 需求/ 的/ 邻接矩阵/ 形式/ ,/ 邻接/ 链表/ 更/ 适合/ 稀疏/ 大图/ 的/ 表示/ 需求/ ./ 下面/ 以/ 邻接/ 链表/ 为/ 图/ 的/ 基本/ 表示/ 形式/ ,/ 进一步/ 构造/ 适合/ 改进/ 框架/ 的/ 图/ 的/ 键值/ 对/ 表示/ 形式/ ./ 假设/ 有向图/ G/ =/ (/ V/ ,/ E/ )/ (/ 不失/ 一般性/ 的/ 情况/ 下/ ,/ 下文/ 讨论/ 均/ 以/ 有向图/ 为例/ ,/ 无向/ 图/ 可以/ 用/ 一对/ 节点/ 间/ 互相/ 指向/ 的/ 有/ 向/ 边/ 表示/ 成/ 有向图/ )/ ,/ 其/ 由/ 顶点/ 集/ V/ (/ G/ )/ =/ {/ v1/ ,/ v2/ ,/ …/ ,/ vn/ }/ ,/ 和/ 连接/ 两个/ 顶点/ 的/ 边集/ E/ (/ G/ )/ =/ {/ (/ vi/ ,/ vj/ )/ |/ i/ ,/ j/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ }/ 构成/ ./ 其中/ 与/ 一个/ 顶点/ 直接/ 相邻/ 的/ 图/ 的/ 局部/ 拓扑/ 结构/ 可以/ 用该/ 节点/ 的/ 直接/ 前驱/ 集合/ 和/ 直接/ 后继/ 集合/ 表示/ ,/ 先/ 给出/ 直接/ 前驱/ 集合/ 和/ 直接/ 后继/ 集合/ 的/ 形式化/ 定义/ ./ 定义/ 3/ (/ 直接/ 前驱/ 集合/ )/ ./ 设/ 节点/ vi/ ∈/ V/ 是/ 有向图/ G/ =/ (/ V/ ,/ E/ )/ 的/ 一个/ 节点/ ,/ 若图/ 中/ 有/ 节点/ vj/ 满足/ (/ vj/ ,/ vi/ )/ ∈/ E/ ,/ 则/ 集合/ χ/ p/ (/ vi/ )/ =/ {/ vj/ |/ (/ vj/ ,/ vi/ )/ ∈/ E/ }/ 就是/ 节点/ vi/ 的/ 直接/ 前驱/ 集合/ ./ 定义/ 4/ (/ 直接/ 后继/ 集合/ )/ ./ 设/ 节点/ vi/ ∈/ V/ 是/ 有向图/ G/ =/ (/ V/ ,/ E/ )/ 的/ 一个/ 节点/ ,/ 若图/ 中/ 有/ 节点/ vj/ 满足/ (/ vi/ ,/ vj/ )/ ∈/ E/ ,/ 则/ 集合/ χ/ s/ (/ vi/ )/ =/ {/ vj/ |/ (/ vi/ ,/ vj/ )/ ∈/ E/ }/ 就是/ 节点/ vi/ 的/ 直接/ 后继/ 集合/ ./ 直接/ 前驱/ 集合/ 和/ 直接/ 后继/ 集合/ 代表/ 了/ 基于/ 节点/ 的/ 并行计算/ 任务/ 间/ 的/ 依赖/ ,/ 也/ 是/ 消息传递/ 的/ 路径/ ./ 我们/ 在/ 基于/ 邻接/ 链表/ 的/ 基础/ 上/ 通过/ 适当/ 扩充/ 变形/ ,/ 抽象/ 出/ 在/ 改进/ 框架/ 下/ 使用/ 的/ 有向图/ 的/ 输入/ 键值/ 对/ 表示/ 格式/ ,/ 如图/ 2/ 所示/ ./ Key/ 键名/ 节点/ 标识符/ 图/ 2/ 中/ 输入/ 键/ 可以/ 是/ 任意/ 内容/ (/ 默认/ 的/ 键/ 是/ 文本/ 行/ 起始/ 处/ 的/ 偏移量/ )/ ,/ 输入/ 值/ 分为/ 5/ 个/ 基本/ 部分/ :/ 节点/ 标识符/ 、/ 直接/ 前驱/ 集合/ 、/ 直接/ 后继/ 集合/ 、/ 元/ 数据/ 和/ 当前/ 节点/ 状态/ ./ 其中/ 元/ 数据/ 是/ 图/ 元素/ 代表/ 的/ 实体/ Page71/ ./ 节点/ 驱动/ 的/ 功能/ 函数/ 启动/ 处理/ ./ 如前所述/ ,/ 图/ 经过/ 预处理/ 被/ 剖/ 分为/ 输入/ 键值/ 对/ 集合/ ,/ 每/ 一个/ 键值/ 对/ 即/ 代表/ 以/ 节点/ 为/ 中心/ 的/ 计算/ 元/ ,/ 用户/ 设计/ Map/ 处理/ 逻辑/ 根据/ 应用/ 需求/ 利用/ 键值/ 对/ 中/ 包含/ 的/ 信息/ 计算/ 首轮/ 迭代/ 中/ 节点/ 的/ 中间/ 状态值/ ;/ 2/ ./ 节点/ 间/ 状态/ 的/ 交互/ 处理/ ./ 利用/ 消息传递/ 机制/ ,/ 将/ 节点/ 的/ 中间/ 状态值/ 依据/ 节点/ 在/ 图/ 中/ 的/ 邻接/ 关系/ 进行/ 传递/ ,/ 邻接/ 关系/ 即用/ 节点/ 的/ 直接/ 前驱/ 集合/ 和/ 直接/ 后继/ 集合/ 完全/ 表示/ ;/ 3/ ./ 节点/ 驱动/ 的/ 功能/ 函数/ 迭代/ 处理/ ./ 接受/ 并/ 解析/ 上/ 一个/ 超级/ 步/ 传递/ 的/ 消息/ 获取/ 邻接/ 节点/ 的/ 新/ 的/ 中间/ 状态值/ ,/ 在/ 新/ 的/ 邻接/ 节点/ 中间/ 状态值/ 集合/ 和/ 代表/ 图/ 拓扑/ 的/ 原始/ 输入/ 键值/ 对/ 集合/ 上/ ,/ 应用/ 用户/ 设计/ 的/ Map/ 处理/ 逻辑/ 计算/ 本轮/ 迭代/ 中/ 节点/ 的/ 中间/ 状态值/ ;/ 关键/ 信息/ ,/ 包含/ 节点/ 的/ 元/ 数据/ 和/ 边/ 的/ 元/ 数据/ 两/ 部分/ ./ 例如/ ,/ 在/ 交通/ 网络图/ 中/ ,/ 节点/ 代表/ 道路/ 交叉口/ ,/ 其中/ 节点/ 元/ 数据/ 可能/ 包括/ 位置/ 坐标/ 、/ 所属/ 区域/ 以及/ 节点/ 名称/ 等/ 信息/ ;/ 边/ 代表/ 节点/ 间/ 连通/ 路段/ ,/ 其中/ 边元/ 数据/ 可能/ 包括/ 路段/ 长度/ 、/ 断面/ 通行/ 能力/ 、/ 单向/ 通行/ 与否/ 等/ 信息/ ./ 当前/ 节点/ 状态/ 是/ 随着/ 迭代/ 运算/ 不断更新/ 的/ 当前/ 状态值/ ,/ 其/ 代表/ 本次/ 迭代/ 的/ 节点/ 中间状态/ ,/ 当/ 迭代/ 收敛/ 时/ ,/ 中间/ 状态值/ 就/ 成为/ 图/ 运算/ 的/ 结果/ 状态值/ ./ 4.2/ 图/ 的/ 计算/ 模式/ 下面/ 抽象/ 出/ 在/ 改进/ 框架/ 下/ ,/ 以/ 节点/ 为/ 驱动/ 的/ 包含/ 迭代/ 过程/ 的/ 稀疏/ 有向图/ 的/ 计算/ 模式/ ./ 每/ 一次/ 迭代/ 过程/ 包含/ 相同/ 的/ 处理/ 逻辑/ ,/ 其/ 包括/ 以下/ 主要/ 处理/ 步骤/ :/ 4/ ./ 迭代/ 终止/ 检测/ ./ 根据/ 具体/ 应用/ 的/ 迭代/ 终止/ 条件/ 决定/ 是/ 返回/ 步/ 2/ 继续执行/ 迭代/ 处理/ ,/ 还是/ 停止/ 迭代/ 返回/ 计算结果/ ./ 系统/ 可以/ 指定/ 两种/ 迭代/ 终止/ 条件/ ,/ 一是/ 比较/ 相邻/ 超级/ 步间/ 的/ 结果/ 误差/ 是否/ 小于/ 指定/ 阈值/ ,/ 二是/ 迭代/ 次数/ 是否/ 达到/ 设定/ 上限/ ./ 由/ 上述/ 描述/ 可知/ ,/ 基于/ MapReduce/ 的/ 图/ 的/ 计算/ 模式/ 的/ 核心内容/ 是/ 基于/ 节点/ 的/ 异步/ 并行计算/ 和/ 基于/ 邻边/ 的/ 同步/ 消息传递/ ./ 4.3/ 实例/ :/ PageRank/ 的/ 实现/ 现实/ 中/ 的/ 很多/ 问题/ 都/ 可以/ 转化/ 为/ 图来/ 处理/ ,/ 如/ 以/ 社交/ 网络/ 为/ 代表/ 的/ 诸多/ 应用/ ,/ 下面/ 就/ 以/ PageRank/ 为/ 改进/ 框架/ 中/ 的/ 典型/ 应用/ 展开/ 介绍/ ./ PageRank/ [/ 33/ ]/ 是/ 一种/ 用于/ 搜索引擎/ 的/ 基于/ 超/ 连接结构/ 测度/ 网页/ 质量/ 的/ 算法/ ,/ 其/ 是/ 有/ 交互/ 和/ 迭代/ 需求/ 的/ 图/ 算法/ 中/ 最具/ 代表性/ 的/ 例子/ ./ 假定/ Web/ 网/ 表示/ 为/ 图/ G/ =/ (/ V/ ,/ E/ )/ ,/ 其中/ 节点/ vi/ ∈/ V/ 代表/ 网页/ ,/ PR/ (/ vi/ )/ 是/ 该/ 节点/ 代表/ 的/ 网页/ 的/ PageRank/ 值/ ,/ 其/ 表示/ 浏览/ 到/ Web/ 图中/ 页面/ vi/ 的/ 可能性/ ,/ 这个/ 可能性/ 与/ Web/ 图/ 的/ 拓扑/ 结构/ 高度/ 相关/ ,/ 例如/ 指向/ 它/ 的/ 页面/ 的/ 状况/ (/ 即/ 直接/ 前驱/ 集合/ )/ ,/ 也就是说/ 一个/ 页面/ 的/ PR/ 值/ 是/ 由/ 其它/ 指向/ 页面/ 的/ PR/ 值/ 计算/ 得到/ 的/ ,/ 一个/ 基本/ 的/ PageRank/ 计算公式/ 可/ 表示/ 为/ PR/ (/ vi/ )/ r/ =/ 其中/ ,/ r/ 表示/ 迭代/ 的/ 轮次/ ,/ s0/ 是/ 节点/ 的/ PageRank/ 初始值/ ,/ q/ 表示/ 阻尼/ 系数/ (/ 详细/ 的/ 介绍/ 可/ 参阅/ 文献/ [/ 33/ ]/ )/ ./ 在/ 给定/ 每个/ 节点/ 一个/ 随机/ 的/ PageRank/ 初始值/ s0/ 的/ 情况/ 下/ ,/ 经过/ 多轮/ 迭代/ 计算/ ,/ 节点/ 的/ PR/ 值会/ 趋向/ 收敛/ ./ 在/ MapReduce/ 并行处理/ 框架/ 下/ 计算/ PageRank/ ,/ 首先/ 需要/ 将/ 图/ 转化/ 为/ 键值/ 对/ 集合/ ,/ 图/ 最/ 简单/ 的/ 表示/ 形式/ 形/ 如/ 二元/ 组/ 〈/ FromVertexID/ ,/ ToVertexID/ 〉/ ,/ 元组/ 元素/ 表示/ 有/ 向/ 边/ 关联/ 的/ 端/ 节点/ ./ 这种/ 最/ 原始/ 的/ 图/ 表示/ 形式/ 仅/ 需/ 通过/ 两次/ 简单/ 的/ MR/ 过程/ 就/ 可以/ 转化/ 为/ 图/ 2/ 所示/ 的/ 通用/ 形式/ ,/ 其中/ 状态值/ 代表/ 节点/ 的/ PR/ 值/ ./ 算法/ 1/ ./ 基于/ 原始/ MapReduce/ 的/ PageRank/ 算法/ ./ Map/ 阶段/ :/ // // 图/ 分解/ 为/ 图/ 2/ 所示/ 的/ 键值/ 对/ G/ =/ (/ V/ ,/ E/ )/ →/ [/ (/ key/ ,/ value/ )/ 1/ …/ ]/ // // parse/ :/ 解析/ 键值/ 对/ 的/ 函数/ // // countPageRank/ :/ 计算/ 节点/ PR/ 值/ 的/ 函数/ 1/ ./ MAP/ (/ Keykey/ ,/ Valuevalue/ )/ 2/ ./ vi/ =/ parse/ (/ value/ )/ ;/ χ/ s/ (/ vi/ )/ =/ parse/ (/ value/ )/ ;/ 3/ ./ PR/ (/ vi/ )/ =/ countPageRank/ (/ value/ )/ ;/ 4/ ./ foreachvj/ ∈/ χ/ s/ (/ vi/ )/ do5/ ./ output/ (/ keyvj/ ,/ valuePR/ (/ vi/ )/ )/ ;/ 6/ ./ endforeach7/ ./ output/ (/ keyvi/ ,/ valuevalue/ )/ ;/ // // 传递/ 原图/ 拓扑/ Reduce/ 阶段/ :/ 1/ ./ REDUCE/ (/ Keyvj/ ,/ Value/ [/ w1/ ,/ w2/ ,/ …/ ]/ )/ 2/ ./ newPagerankSet/ ←/ / ;/ 3/ ./ foreachwi/ ∈/ [/ w1/ ,/ w2/ ,/ …/ ]/ do4/ ./ ifwi/ ∈/ χ/ p/ (/ vj/ )/ then5/ ./ newPagerankSet/ =/ newPagerankSet/ +/ wi/ ;/ 6/ ./ else7/ ./ value/ =/ wi8/ ./ endif9/ ./ endforeach10/ ./ PR/ (/ vj/ )/ =/ countPageRank/ (/ value/ ,/ newPagerankSet/ )/ ;/ 11/ ./ value/ =/ update/ (/ value/ ,/ PR/ (/ vj/ )/ ,/ newPagerankSet/ )/ ;/ 12/ ./ output/ (/ keyvj/ ,/ Valuevalue/ )/ ./ 上述/ 是/ 一次/ MR/ 的/ 处理过程/ ,/ 运算/ 需要/ 多次/ MR/ 过程/ 迭代/ 执行/ ,/ 并且/ 需要/ 在/ 两次/ MR/ 过程/ 间/ 增/ Page8/ 加/ 收敛/ 判断/ 来/ 确定/ 何时/ 终止/ 迭代/ 过程/ ./ 值得/ 关注/ 的/ 是/ ,/ 除了/ 更新/ 的/ 节点/ 中间/ 状态值/ (/ 本例/ 中即/ PR/ 值/ )/ 需要/ 借助/ Shuffle/ 机制/ 在/ 不同/ 执行/ 节点/ 间/ 传递/ ,/ 为/ 保证/ 下/ 一次/ 迭代/ 的/ 执行/ ,/ 运算/ 过程/ 中/ 并/ 没有/ 改变/ 的/ 整个/ 图/ 的/ 拓扑/ (/ 如/ χ/ p/ (/ vi/ )/ 、/ χ/ s/ (/ vi/ )/ 以及/ md/ 等/ )/ 也/ 需要/ 在/ 每次/ MR/ 过程/ 中/ 反复/ 传递/ 和/ 持久/ 化/ ./ 实际/ 图/ 运算/ 过程/ 中未/ 改变/ 的/ 部分/ (/ 图/ 2/ 中/ 浅色/ 部分/ )/ 比例/ 远大于/ 变化/ 的/ 中间/ 状态值/ 集/ (/ 图/ 2/ 中/ 深色/ 部分/ )/ ,/ 如式/ (/ 2/ )/ 所示/ ./ 所以/ ,/ 多次/ MR/ 过程/ 中/ 这个/ 代价/ 相对/ 于/ 整个/ 计算/ 过程/ 而言/ 是/ 非常/ 大/ 的/ ./ (/ ∑/ vi/ ∈/ V/ (/ χ/ s/ (/ vi/ )/ +/ χ/ p/ (/ vi/ )/ +/ md/ (/ vi/ )/ )/ +/ ∑/ ei/ ∈/ E/ 所以/ ,/ MapReduce/ 虽然/ 可以/ 执行/ 图/ 的/ 运算/ 但是/ 并/ 不/ 易于/ 表达/ 这种/ 有/ 数据/ 交互/ 依赖/ 和/ 迭代/ 需求/ 的/ 计算/ ./ 改进/ 的/ 并行/ 框架/ 下图/ 的/ 计算/ 则/ 充分利用/ 图/ 本身/ 的/ 拓扑/ 特征/ 和/ 运算/ 特点/ ,/ 根据/ 图/ 计算/ 内在/ 的/ 迭代/ 需求/ ,/ 利用/ Map/ 和/ Reduce/ 阶段/ 内/ 的/ 多个/ 同步/ 的/ 超级/ 步/ 完成/ 迭代/ ./ 改变/ 的/ 中间/ 状态值/ 在/ 超级/ 步间/ 通过/ 消息传递/ ,/ 未/ 变化/ 的/ 图/ 的/ 拓扑/ 无需/ 传递/ 和/ 持久/ 化/ ./ 对于/ PageRank/ 算法/ 甚至/ 仅/ 需/ Map/ -/ only/ 的/ 方式/ 即可/ 完成/ ./ 下面/ 给出/ 新/ 并行计算/ 框架/ 下/ PageRank/ 分布式/ 算法/ 的/ 实现/ 伪/ 代码/ ./ 算法/ 2/ ./ 基于/ 支持/ BSP/ 模型/ 的/ MapReduce/ 的/ PageRank/ 算法/ ./ Map/ 阶段/ -/ setup/ 操作/ :/ 1/ ./ i/ =/ superstepCounter/ ++/ ;/ // // 超级/ 步/ 计数器/ 2/ ./ Msgi/ =/ newuserdefineMessage/ (/ )/ ;/ 3/ ./ resetInputDataOffset/ (/ )/ ;/ // // 重置/ 输入/ 数据/ 访问/ 偏移/ Map/ 阶段/ -/ map/ 操作/ :/ 1/ ./ MAP/ (/ Keykey/ ,/ Valuevalue/ )/ 2/ ./ vj/ =/ parse/ (/ value/ )/ ;/ χ/ s/ (/ vj/ )/ =/ parse/ (/ value/ )/ ;/ 3/ ./ if/ (/ stopflag/ =/ =/ false/ )/ 4/ ./ if/ (/ i/ =/ =/ 0/ )/ // // 首次/ 迭代/ ,/ 执行/ 启动/ 处理/ 5/ ./ PR/ (/ vj/ )/ =/ countPageRank/ (/ value/ )/ ;/ 6/ ./ else/ // // 执行/ 迭代/ 处理/ 7/ ./ PR/ (/ vj/ )/ =/ countPageRank/ (/ value/ ,/ newValueSeti/ -/ 1/ )/ ;/ 8/ ./ endif9/ ./ Msgi/ ./ setStateValue/ (/ PR/ (/ vj/ )/ )/ ;/ 10/ ./ else/ // // 终止/ 迭代/ ,/ 输出/ 11/ ./ value/ =/ update/ (/ value/ ,/ newValueSeti/ -/ 1/ )/ ;/ 12/ ./ output/ (/ Keyvj/ ,/ Valuevalue/ )/ ;/ 13/ ./ endifMap/ 阶段/ -/ cleanup/ 操作/ :/ 1/ ./ if/ (/ compare/ (/ Msgi/ -/ 1/ ,/ Msgi/ )/ >/ threshold/ )/ 2/ ./ headeri/ =/ createMessageHeader/ (/ i/ ,/ timestamp/ )/ ;/ 3/ ./ barrierMsgi/ =/ assembleMessage/ (/ headeri/ ,/ Msgi/ )/ ;/ 4/ ./ send/ (/ barrierMsgi/ )/ ;/ // // 发送/ 消息/ ,/ 执行/ 交互/ 处理/ 5/ ./ sleep/ (/ )/ ;/ // // 陷入/ 等待/ 状态/ 6/ ./ MsgSeti/ =/ receive/ (/ )/ ;/ // // 被/ 唤醒/ 后/ 接受/ 汇集/ 消息/ 7/ ./ newValueSeti/ =/ getNewValue/ (/ MsgSeti/ )/ ;/ 8/ ./ else9/ ./ stopflag/ =/ true/ ;/ // // 设置/ 迭代/ 终止/ 标志/ 10/ ./ endifsetup/ 和/ cleanup/ 操作/ 仅/ 在/ 每次/ 超级/ 步/ 的/ 任务/ 运算/ 前/ 和/ 运算/ 后/ 执行/ ,/ map/ 操作/ 则/ 循环/ 处理/ 输入/ 数据/ 切片/ 上/ 的/ 键值/ 对/ ./ 此外/ ,/ 新/ 系统/ 还/ 提供/ 了/ 继承/ Mapper/ 类/ 的/ 新/ 超类/ MsgMapper/ 和/ 若干/ 方法/ 来/ 支持/ 在/ 框架/ 内部/ 完成/ 迭代/ 处理/ ,/ 迭代/ 控制/ 过程/ 对/ 用户/ 而言/ 是/ 透明/ 的/ ./ 5/ 基于/ 消息传递/ 的/ 系统/ 框架/ 设计/ 与/ 实现/ 本/ 节/ 介绍/ 基于/ BSP/ 模型/ 的/ 改进版/ 并行计算/ 框架/ 所/ 支持/ 的/ 通信协议/ 和/ 基于/ 开源/ Hadoop0/ ./ 20.2/ 版本/ 的/ 具体/ 实现/ 细节/ ./ 系统/ 引入/ 的/ 两种/ 自/ 适应/ 的/ 消息传递/ 机制/ 可以/ 高效/ 地/ 处理/ 图/ 运算/ 的/ 中间状态/ 信息/ 的/ 交互/ ./ 5.1/ 障栅/ 消息/ 障栅/ (/ Barrier/ )/ 是/ 可/ 用于/ 消息传递/ 系统/ 的/ 一种/ 有效/ 的/ 同步/ 机制/ ./ 对于/ 计算/ 过程/ 中有/ 数据/ 依赖/ 且/ 不能/ 完全/ 独立/ 执行/ 的/ 计算/ 任务/ ,/ 其/ 需要/ 借助/ 消息/ 传递数据/ ./ 为/ 保证/ 消息/ 整体/ 有序/ 地/ 传递/ ,/ 同一/ 超级/ 步内/ 的/ 异步/ 并行/ 的/ 计算/ 任务/ 在/ 发送/ 消息/ 后/ 需/ 插入/ 障栅/ 同步/ 等待/ ./ 插入/ 障栅/ 的/ 任务/ 会/ 陷入/ 等待/ 状态/ ,/ 直到/ 该/ 超级/ 步内/ 所有/ 任务/ 通过/ 消息/ 完成/ 数据/ 的/ 交互/ ,/ 然后/ 此/ 超级/ 步内/ 所有/ 被障/ 栅/ 阻隔/ 并/ 陷入/ 等待/ 状态/ 的/ 任务/ 才能/ 被/ 重新/ 唤醒/ 并/ 利用/ 接收/ 到/ 的/ 汇集/ 消息/ 中/ 的/ 新/ 数据/ 在/ 下/ 一个/ 超级/ 步内/ 继续/ 运行/ ./ 支持/ BSP/ 模型/ 的/ MapReduce/ 并行计算/ 框架/ ,/ 需要/ 利用/ 障栅将/ MR/ 过程/ 中/ 的/ Map/ 阶段/ 和/ Reduce/ 阶段/ 分割/ 成/ 同步/ 执行/ 的/ 若干/ 超级/ 步/ ./ 一个/ 超级/ 步内/ 异步/ 并行/ 的/ 多个/ Mapper/ 或者/ Reducer/ 在/ 发送/ 消息/ 后/ 借助/ 障栅/ 互相/ 等待/ ,/ 本文/ 称/ 这种/ 在/ 一个/ 超级/ 步内/ 被/ 障栅/ 分隔/ 的/ 由/ 任务/ 发送/ 的/ 消息/ 为障/ 栅/ 消息/ ./ 障栅/ Page9/ 消息/ 仅能/ 在/ 相邻/ 的/ 超级/ 步间/ 进行/ 传递/ ,/ 超级/ 步/ i/ 中/ 任务/ 发送/ 的/ 消息/ 经过/ 汇集/ 处理/ 可以/ 被/ 超级/ 步/ i/ +/ 1/ 中/ 的/ 任务/ 使用/ ./ 也就是说/ ,/ 超级/ 步内/ 任务/ 的/ 执行/ 完全/ 异步/ ,/ 超级/ 步间/ 所有/ 任务/ 通过/ 障栅/ 同步/ ,/ 并/ 借助/ 障栅/ 消息/ 交互/ 数据/ ./ 为/ 支持/ 消息/ 的/ 传递/ ,/ 系统/ 新增/ 了/ 预置/ 的/ 消息/ 接口/ ,/ 用户/ 可以/ 根据/ 应用/ 的/ 需求/ 灵活/ 地/ 设计/ 实现/ 该/ 接口/ 的/ 自定义/ 消息/ 类型/ ./ 这种/ 可/ 插入式/ 的/ 消息/ 设计模式/ 保证/ 了/ 运行/ 的/ Hadoop/ 集群/ 可以/ 在/ 不/ 重启/ 的/ 情况/ 下/ 动态/ 支持/ 任意/ 类型/ 的/ 用户/ 消息/ ,/ 只要/ 用户/ 实现/ 了/ 系统/ 预置/ 的/ 消息/ 接口/ ./ 预置/ 的/ 消息/ 接口/ 中/ 主要/ 设置/ 了/ 系统/ 用于/ 维护/ 障栅/ 消息/ 所/ 需要/ 的/ 消息/ 元/ 数据/ ,/ 而/ 用户/ 自定义/ 消息/ 的/ 具体内容/ 则/ 依赖于/ 应用/ 的/ 需求/ ./ 障栅/ 消息/ 格式/ 主要/ 由/ 两/ 部分/ 组成/ :/ 消息/ 头/ 和/ 消息/ 体/ ,/ 每/ 一部分/ 的/ 具体内容/ 如图/ 3/ 所示/ ./ 消息/ 头/ 包含/ 的/ 是/ 障栅/ 消息/ 的/ 元/ 数据/ ,/ 其/ 由/ 6/ 部分/ 构成/ (/ 图中/ 灰色/ 部分/ )/ ./ 其中/ JobID/ 、/ TaskID/ 和/ TaskAttemptID/ 三者/ 构成/ 了/ 具体任务/ (/ Mapper/ 或/ Reducer/ )/ 在/ 集群/ 中/ 的/ 唯一/ 标识/ ./ 用户/ 编写/ 的/ 并行/ 应用/ 以/ 作业/ (/ Job/ )/ 为/ 单元/ 提交/ 到/ Hadoop/ 集群/ 中/ 执行/ ,/ JobID/ 即/ 集群/ 中该/ 作业/ 的/ 唯一/ 标识/ ,/ TaskID/ 即/ 任务/ 在/ 作业/ 内/ 的/ 唯一/ 标识/ ,/ 由于/ 推测/ 执行/ 机制/ ,/ 同一个/ 输入/ 片段/ 可能/ 同时/ 会/ 在/ 不同/ 工作/ 节点/ 上/ 存在/ 多个/ 完全相同/ 的/ 冗余/ 任务/ ,/ TaskAttemptID/ 就是/ 用以/ 区分/ 冗余/ 任务/ 的/ 唯一/ 标识/ ./ 所以/ ,/ 集群/ 内/ 一个/ 具体/ 执行/ 计算/ 图/ 4/ 轻量级/ 消息传递/ 实现/ 框架/ 的/ 任务/ 可以/ 用/ 〈/ Job/ -/ ID/ ,/ Task/ -/ ID/ ,/ Task/ -/ Attempt/ -/ ID/ 〉/ 三元/ 标识/ 组合/ 来/ 唯一/ 确定/ ./ 障栅/ 消息/ 和/ 发送/ 消息/ 的/ 任务/ 绑定/ ,/ 因此/ 该/ 三元/ 标识/ 组合/ 同时/ 也/ 可/ 被/ 系统/ 用于/ 区分/ 超级/ 步内/ 的/ 障栅/ 消息/ ./ MessageType/ 用于/ 区分/ 发送/ 消息/ 的/ 任务/ 类别/ ,/ 包含/ Map/ 任务/ 和/ Reduce/ 任务/ 两大类/ ./ StepID/ 用于/ 区分/ 消息/ 隶属/ 的/ 超级/ 步/ ,/ 因为/ Map/ 或/ Reduce/ 阶段/ 被/ 分为/ 一系列/ 同步/ 的/ 超级/ 步/ ,/ 每/ 一个/ 超级/ 步/ 都/ 伴随/ 着/ 消息/ 的/ 传递/ 和/ 交互/ ,/ 一个/ 超级/ 步中/ 的/ 消息/ 仅/ 在/ 此/ 超级/ 步内/ 进行/ 汇集/ ,/ 不同/ 超级/ 步内/ 的/ 消息/ 不能/ 混/ 和/ 汇集/ ,/ 这种/ 同步/ 方式/ 简化/ 了/ 消息/ 维护/ 的/ 代价/ ./ 消息/ 体是/ 由/ 用户/ 根据/ 具体/ 应用/ 需求/ 所/ 构造/ 的/ 可/ 序列化/ 的/ 消息/ 实体/ ,/ 其/ 可以/ 是/ 基本/ 数据类型/ (/ 如/ 整型/ 或/ 实型/ )/ ,/ 也/ 可以/ 是/ 复杂/ 的/ 复合/ 类型/ (/ 如/ 容器/ 类型/ 或/ 构造类型/ )/ ,/ 用户/ 可以/ 完全/ 控制/ 消息/ 内容/ 的/ 格式/ ./ 因为/ 消息/ 需在/ 集群/ 中/ 通过/ 网络/ 传递/ ,/ 所以/ 必须/ 强制/ 要求/ 用户/ 按照/ Hadoop/ 集群/ 序列化/ 的/ 要求/ 实现/ 自定义/ 消息/ 内容/ 的/ 序列/ 和/ 反/ 序列化/ 逻辑/ ./ 借助/ Hadoop/ 提供/ 的/ 各种/ 序列化/ 操作/ 基元/ ,/ 可以/ 很/ 容易/ 地/ 实现/ 自定义/ 消息/ 体/ 的/ 序列/ 和/ 反/ 序列化/ ./ 消息/ 头/ 是/ 由/ 系统/ 自动/ 生成/ 和/ 维护/ 的/ ,/ 消息/ 体/ 发送/ 时/ 系统/ 会/ 自动/ 为/ 其/ 添加/ 相应/ 的/ 消息/ 头/ ,/ 然后/ 完整/ 的/ 消息/ 再/ 被/ 序列化/ 为/ 可/ 在/ 网络/ 中/ 传递/ 的/ 字符/ 序列/ ,/ 在/ 集群/ 的/ 工作/ 节点/ 间/ 传递/ ./ 此外/ 借助/ 动态/ 加载/ 技术/ 可以/ 让/ 运行/ 中/ 的/ 集群/ 系统/ 在/ 不/ 停机/ 的/ 情况/ 下/ 自动/ 加载/ 用户/ 创建/ 的/ 自定义/ 消息/ 类型/ ./ 5.2/ 轻量级/ 消息传递/ 机制/ 轻量级/ 的/ 消息传递/ 机制/ 旨在/ 利用/ Hadoop/ 现有/ 的/ 消息传递/ 机制/ ,/ 在/ 不/ 影响/ 既有/ 功能/ 的/ 情况/ 下/ ,/ 通过/ 修改/ 和/ 新增/ 部分/ 通信协议/ 以/ 实现/ 小/ 体量/ 的/ 消息传递/ ./ 图/ 4/ 描述/ 了/ 轻量级/ 消息传递/ 机制/ 的/ 实现/ 框架/ ./ 先/ 介绍/ Hadoop/ 既有/ 的/ 通信/ 机制/ 以/ 提供/ 技术/ 实/ Page10/ 现/ 的/ 背景/ ./ Hadoop/ 分布式/ 并行计算/ 系统/ 是/ 典型/ 的/ 主从/ (/ Master/ // Slave/ )/ 架构/ ,/ 如图/ 4/ 中/ 所示/ 集群/ 由/ 一个/ JobTracker/ 节点/ 和/ 若干个/ TaskTracker/ 节点/ 组成/ ./ 用户/ 作业/ 通过/ JobClient/ 向/ MapReduce/ 集群/ 投交/ ,/ JobTracker/ 负责/ 接受/ 作业/ 的/ 投交/ 请求/ ,/ 将/ 作业/ 自动/ 分解/ 为/ 多个/ 并行/ 的/ 任务/ ,/ 并/ 依据/ 数据/ 本地化/ 原则/ 尽可能/ 的/ 将/ 任务调度/ 到/ 输入/ 数据/ 所在/ 的/ Task/ -/ Tracker/ 节点/ 上/ 执行/ ./ TaskTracker/ 节点/ 会/ 根据/ 分配任务/ 的/ 类型/ 启动/ 独立/ 的/ 子/ 进程/ Child/ 执行/ Map/ 任务/ 或者/ Reduce/ 任务/ ./ JobTracker/ 同时/ 还/ 负责/ 监控/ 和/ 维护/ 整个/ 集群/ 中/ 所有/ TaskTracker/ 节点/ 的/ 运行/ 状态/ 以及/ 投入/ 作业/ 的/ 执行/ 情况/ ./ 状态/ 信息/ 及/ 任务调度/ 等/ 信息/ 主要/ 籍/ 由/ 节点/ 间/ 的/ 通信/ 来/ 传递/ ,/ 集群/ 中/ 节点/ 间/ 的/ 通信/ 是/ 使用/ Hadoop/ 的/ RPC/ (/ 远程/ 过程/ 调用/ )/ 机制/ 来/ 实现/ 的/ ,/ 各/ 节点/ 利用/ RPC/ 协调/ 各自/ 的/ 运行/ 状态/ 确保/ 集群/ 流畅/ 的/ 运作/ ./ TaskTracker/ 节点/ 通过/ RPC/ 协议/ 向/ JobTracker/ 发送/ 周期性/ 的/ 心跳/ (/ 图/ 4/ 中/ 所示/ 的/ heartbeat/ )/ 来/ 通知/ 自己/ 的/ 当前/ 状态/ ,/ 并/ 根据/ 自身/ 的/ 负载/ 能力/ 请求/ 新/ 的/ 任务/ ;/ 执行/ 具体任务/ 的/ Child/ 子/ 进程/ 也/ 会/ 通过/ RPC/ 协议/ 向/ TaskTracker/ 节点/ 发送/ 周期性/ 的/ 连通/ 指令/ (/ 图/ 4/ 中/ 所示/ 的/ ping/ )/ ,/ 利用/ 该/ 指令/ Child/ 子/ 进程/ 查看/ 作为/ 父/ 进程/ 存在/ 的/ TaskTracker/ 节点/ 的/ 当前/ 状态/ 来/ 确定/ 继续/ 还是/ 终止/ 任务/ 的/ 执行/ ;/ JobClient/ 则/ 通过/ RPC/ 协议/ 向/ JobTracker/ 发送/ 投交/ 指令/ (/ 图/ 4/ 中/ 所示/ 的/ submitJob/ )/ 提交/ 用户/ 作业/ ./ 发起/ RPC/ 请求/ 的/ 作为/ RPC/ 客户端/ ,/ 而/ 接受/ RPC/ 请求/ 并/ 执行/ 处理/ 逻辑/ 的/ 作为/ RPC/ 服务端/ ./ 如图/ 4/ 所示/ ,/ JobTracker/ 和/ TaskTracker/ 都/ 实现/ 了/ RPC/ 服务端/ 接受/ 不同/ 的/ RPC/ 请求/ ,/ JobClient/ 和/ Child/ 作为/ PRC/ 客户端/ 利用/ 动态/ 通信/ 代理/ 发送/ RPC/ 请求/ ,/ Child/ 对于/ JobTracker/ 而言/ 是/ 透明/ 的/ ,/ 没有/ 直接/ 的/ 信息/ 交互/ ./ 另外/ ,/ TaskTracker/ 同时/ 也/ 作为/ JobTracker/ 的/ RPC/ 客户端/ 与/ JobTracker/ 进行/ 信息/ 交互/ ./ 为/ 在/ 集群/ 原有/ 的/ 通信/ 框架/ 内/ 支持/ 任务/ 间/ 的/ 障栅/ 消息/ 的/ 传递/ ,/ 必须/ 修改/ Hadoop/ 既有/ 的/ 部分/ 通信协议/ 和/ 新增/ 个别/ 专用/ 于障/ 栅/ 消息传递/ 的/ 通信协议/ ./ 系统/ 新增/ 了/ 两个/ 通信协议/ :/ send/ 和/ repeater/ ./ 其中/ send/ 协议/ 用于/ Child/ 发送/ 障栅/ 消息/ 给/ TaskTracker/ ,/ repeater/ 协议/ 则/ 用于/ TaskTracker/ 把/ 局部/ 汇集/ 的/ 障栅/ 消息/ 转发给/ JobTracker/ ./ 系统/ 修改/ 和/ 增强/ 了/ 原有/ 的/ 两个/ 通信协议/ :/ heartbeat/ 和/ ping/ ./ 其中/ 增强/ 后/ 的/ heartbeat/ 在/ 保持/ 原有/ 功能/ 的/ 基础/ 上/ 可以/ 通过/ 心跳/ 返回值/ 定期/ 的/ 将/ JobTracker/ 处理/ 后/ 的/ 汇集/ 障栅/ 消息/ 回/ 带给/ 发送/ 心跳/ 的/ TaskTracker/ ,/ ping/ 经过/ 增强/ 后/ 可以/ 将/ TaskTracker/ 从/ JobTracker/ 接受/ 并/ 缓存/ 的/ 汇集/ 障栅/ 消息/ 转发给/ Child/ ./ 接收/ 到/ 消息/ 后/ ,/ 被障/ 栅/ 陷入/ 等待/ 状态/ 的/ Child/ 可以/ 被/ 唤醒/ ,/ 通过/ 解析/ 携带/ 交互/ 数据/ 的/ 信息/ 进入/ 下/ 一个/ 超级/ 步/ 的/ 执行/ 态/ ./ 轻量级/ 消息传递/ 机制/ 的/ 设计/ 原则/ 是/ :/ 执行/ 具体任务/ 的/ Child/ 之间/ 不/ 建立/ 直接/ 的/ 通信/ ,/ 以/ 转发/ 和/ 分发/ 的/ 形式/ 建立/ 通信/ 层级/ ,/ 与/ 任务/ 绑定/ 的/ 障栅/ 消息/ 经/ TaskTracker/ 转发/ 后/ ,/ 统一/ 在/ JobTracker/ 中/ 汇集/ ,/ 然后/ 再/ 分/ 发给/ 具体任务/ ./ 这样/ 设计/ 的/ 原因/ 在于/ :/ (/ 1/ )/ 首先/ JobTracker/ 中/ 维护/ 有/ 基于/ 整个/ 集群/ 的/ 全局/ 的/ 作业/ 与/ 任务/ 、/ 任务/ 与/ 执行/ 节点/ 等/ 诸多/ 映射/ 信息/ ,/ 所以/ JobTracker/ 可以/ 利用/ 这些/ 全局/ 信息/ 维护/ 和/ 管理/ 不同/ 作业/ 间/ 、/ 同一/ 作业/ 不同/ 任务/ 间/ 、/ 同一/ 任务/ 不同/ 超级/ 步间/ 的/ 障栅/ 消息/ ;/ (/ 2/ )/ 其次/ 分布式系统/ 中/ 一个/ 很/ 重要/ 的/ 假设/ 是/ 节点/ 失效/ 是/ 常态/ ,/ 也就是说/ 集群/ 中/ 任务/ 的/ 执行/ 有/ 较大/ 的/ 不稳定性/ ,/ 直接/ 维护/ Child/ 之间/ 的/ 通信/ 状态/ 过于/ 复杂/ ,/ 在/ 高度/ 并行/ 的/ 情况/ 下/ 也/ 不/ 可行/ ./ 所以/ 这种/ 层级/ 的/ 通信/ 体系/ 能确/ 保障/ 栅/ 消息/ 有序/ 高效/ 地/ 传递/ ./ 5.3/ 重量级/ 消息传递/ 机制/ 利用/ Hadoop/ 现有/ 的/ 消息传递/ 机制/ 实现/ 的/ 轻量级/ 通信/ 机制/ 存在/ 几个/ 潜在/ 的/ 问题/ :/ (/ 1/ )/ JobTracker/ 节点/ 是/ 整个/ Hadoop/ 集群/ 资源管理/ 和/ 任务调度/ 的/ 唯一/ 主控/ 节点/ ,/ 其/ 也/ 是/ 整个/ Hadoop/ 集群/ 中/ 潜在/ 的/ 瓶颈/ ./ 特别/ 当/ 作业/ 密集/ 投交时/ JobTracker/ 的/ 管理负担/ 变得/ 非常/ 繁重/ ,/ 其/ 计算/ 和/ 内存/ 资源/ 会/ 更加/ 紧缺/ ,/ 如果/ 障栅/ 消息/ 不是/ 小/ 体/ 量级/ 的/ ,/ 那么/ 维护/ 汇集/ 障栅/ 消息/ 的/ 代价/ 会/ 加重/ JobTracker/ 的/ 工作/ 负载/ ,/ 并且/ 受限于/ 轻量级/ 通信/ 机制/ 的/ 设计/ 策略/ ,/ 消息/ 的/ 两层/ 传递/ 不可避免/ 地会/ 增加/ 通信/ 开销/ ,/ 进一步/ 会/ 导致/ 集群/ 整体/ 吞吐量/ 、/ 作业/ 完成/ 时间/ 等/ 重要/ 技术指标/ 的/ 下降/ ;/ (/ 2/ )/ 其次/ 利用/ 原有/ 的/ 周期性/ 心跳/ 和/ 连通/ 指令/ 回带/ 汇集/ 障栅/ 消息/ 的/ 模式/ 可能/ 会/ 产生/ 一定/ 的/ 作业/ 延迟/ ./ 因为/ 集群/ 规模/ 的/ 变化/ 会/ 影响/ 心跳/ 和/ 连通/ 指令/ 的/ 工作/ 周期/ ,/ 因此/ 当/ 集群/ 规模/ 增长/ 到/ 一定/ 程度/ 时/ ,/ 即使/ 集群/ 中/ 可/ 用于/ 执行/ 任务/ 的/ 空闲/ 工作/ 节点/ 增多/ ,/ 需要/ 传递/ 消息/ 的/ 作业/ 执行/ 时间/ 反而/ 会/ 变得/ 更长/ ./ 因此/ 需要/ 一种/ 专用/ 的/ 模式/ 能/ 把/ 障栅/ 消息/ 的/ 维护/ 工作/ 从/ JobTracker/ 节点/ 中/ 剥离/ 出来/ ,/ 以/ 更/ 高效/ 的/ 方式/ 维护/ 整个/ 集群/ 中/ 的/ 障栅/ 消息/ ./ 5.3/ ./ 1/ 主要/ 组件/ 和/ 功能/ 重量级/ 消息传递/ 机制/ 就是/ 为/ 应对/ 这些/ 可能/ 的/ 问题/ 而/ 设计/ 出来/ 的/ 工作/ 模式/ ./ 系统/ 新增/ 了/ 一个/ 专门/ 用/ Page11/ 于/ 维护/ 障栅/ 消息/ 的/ 障栅/ 消息/ 服务器/ (/ MessageTracker/ ,/ MT/ )/ ,/ 如图/ 5/ 所示/ ./ 障栅/ 消息/ 服务/ 运行/ 于/ 集群/ 的/ 独立/ 节点/ 中/ ,/ 该/ 新增/ 节点/ 可以/ 随/ Hadoop/ 集群/ 一起/ 启动/ 和/ 关闭/ ,/ 也/ 可以/ 单独/ 地/ 启动/ 和/ 关闭/ 而/ 不/ 影响/ 集群/ 既有/ 的/ 功能/ ./ 借助/ 新增/ 的/ 障栅/ 消息/ 通信协议/ ,/ 图/ 5/ 重量级/ 消息传递/ 实现/ 框架/ (/ 1/ )/ MT/ 中/ 建立/ 了/ 一个/ RPC/ 服务器/ 用于/ 接收/ 任务/ 进程/ Child/ 发送/ 的/ 障栅/ 消息/ 以及/ 接受/ JobTracker/ 发送/ 的/ 作业/ 初始化/ 以及/ 用户/ 自定义/ 消息/ 类型/ 等/ 同步/ 数据/ ;/ (/ 2/ )/ 包含/ 一系列/ 的/ 维护/ 障栅/ 消息/ 的/ 数据结构/ 和/ 技术/ ,/ 提供/ 障栅/ 消息/ 的/ 汇集/ 、/ 过滤/ 和/ 裁剪/ 等/ 核心/ 功能/ 的/ 处理/ ;/ (/ 3/ )/ MT/ 中/ 拥有/ JobTracker/ 的/ RPC/ 客户端/ 用于/ 与/ JobTracker/ 建立/ 通信/ ,/ MT/ 利用/ 动态/ 通信/ 代理/ 获取/ JobTracker/ 所/ 维护/ 的/ 各种/ 与/ 集群/ 节点/ 和/ 作业/ 相关/ 的/ 映射/ 信息/ ,/ 从而/ 保证/ MT/ 与/ JobTracker/ 所/ 持有/ 的/ 集群/ 状态/ 的/ 一致性/ ;/ (/ 4/ )/ JobTracker/ 中/ 建立/ 一个/ 连接/ MT/ 的/ RPC/ 客户端/ ,/ 将/ 用户/ 投入/ 作业/ 的/ 信息/ ,/ 特别/ 是/ 使用/ 了/ 障栅/ 消息/ 接口/ 的/ 新/ 作业/ 的/ 用户/ 自定义/ 消息/ 类型/ 等/ 信息/ 主动/ 同步/ 到/ MT/ 中/ ./ 因为/ 作业/ 分配/ 等/ 主要/ 的/ 工作/ 仍然/ 由/ JobTracker/ 完成/ ,/ 这部分/ 操作/ 产生/ 的/ 各种/ 映射/ 关系/ 是/ 维护/ 障栅/ 消息/ 时所/ 必须/ 的/ ./ (/ 5/ )/ Child/ 中/ 建立/ 一个/ 连接/ MT/ 的/ RPC/ 客户端/ ,/ 用于/ 在/ 超级/ 步内/ 发送/ 障栅/ 消息/ 以及/ 以/ 定时/ 轮询/ 的/ 方式/ 获取/ 汇集/ 障栅/ 消息/ 反馈/ ./ 5.3/ ./ 2/ 主要/ 执行/ 流程/ 基于/ 独立/ 障栅/ 消息/ 服务器/ 的/ 重量级/ 消息传递/ 机/ MT/ 可以/ 与/ 原始/ 的/ Hadoop/ 集群/ 高度/ 协作/ ,/ 在/ 完全/ 兼容/ 既有/ 作业/ 类型/ 的/ 基础/ 上/ ,/ 同时/ 提供/ 对/ 新/ 的/ 可/ 传递/ 消息/ 的/ 作业/ 类型/ 的/ 支持/ ./ 重量级/ 消息传递/ 机制/ 的/ 主要/ 组件/ 和/ 功能/ 如下/ (/ 下面/ 仅/ 针对/ 支持/ 障栅/ 消息/ 的/ 新/ 作业/ 类型/ 展开讨论/ )/ ./ 制/ 的/ 主要/ 执行/ 流程/ 如下/ (/ 以/ MT/ 与/ 集群/ 同步/ 启动/ 为例/ ,/ 主要/ 描述/ 与/ 障栅/ 消息/ 相关/ 的/ 执行/ 步骤/ ,/ 其他/ 与/ 原始/ 作业/ 相同/ 的/ 执行/ 处理/ 被/ 省略/ )/ :/ (/ 1/ )/ 用户/ 根据/ 需求/ 在/ 配置文件/ 中/ 新增/ MT/ 入口/ 随后/ 启动/ 集群/ ./ 〈/ property/ 〉/ 〈/ value/ 〉/ hdfs/ :/ // // host/ :/ port/ 〈/ // value/ 〉/ 〈/ // property/ 〉/ (/ 2/ )/ 开发者/ 可/ 使用/ 新增/ 接口/ setMTServerMode/ 在/ 编写/ 并行/ 应用/ 作业/ 时/ 显式/ 开启/ 障栅/ 消息/ 服务器/ 模式/ ,/ 默认设置/ 是/ 关闭/ ./ (/ 3/ )/ JobTracker/ 和/ MT/ 在/ 等待/ 各自/ 的/ RPC/ 服务端/ 启动/ 后/ ,/ 利用/ 动态/ 代理/ 互相/ 建立/ 连接/ 到/ 对方/ 的/ RPC/ 客户端/ ./ (/ 4/ )/ JobTracker/ 接受/ 用户/ 投交/ 的/ 支持/ 障栅/ 消息/ 的/ 新/ 类型/ 作业/ ,/ 利用/ 新/ 的/ synchronize/ 协议/ 把/ 作业/ 包/ 所在/ 的/ 位置/ 信息/ 、/ 作业/ 的/ 任务/ 划分/ 情况/ 以及/ 用户/ 自定义/ 障栅/ 消息/ 类型/ 同步/ 推送/ 到/ MT/ 中/ ./ (/ 5/ )/ 任务/ 执行/ 子/ 进程/ Child/ 启动/ 后/ 利用/ 动态/ 代理/ 建立/ 连接/ 到/ MT/ 的/ RPC/ 客户端/ ,/ 当/ 任务/ 执行/ 到障/ 栅/ 插入/ 点时/ ,/ 利用/ send/ 协议/ 将/ 携带/ 交互/ 数据/ 的/ 用户/ 自定义/ 障栅/ 消息/ 发送给/ MT/ ,/ 同时/ 任务/ 执行/ 线程/ 陷/ Page12/ 入到/ 等待/ 状态/ ./ (/ 6/ )/ MT/ 汇集/ 任务/ 发送/ 的/ 障栅/ 消息/ ,/ 同时/ 利用/ query/ 协议/ 保持/ 与/ JobTracker/ 任务/ 执行/ 状态/ 的/ 一致性/ ./ (/ 7/ )/ Child/ 子/ 进程/ 利用/ 周期性/ 的/ check/ 协议/ 询问/ MT/ 当前/ 障栅/ 消息/ 的/ 处理/ 状况/ ,/ 当/ 同一/ 作业/ 的/ 同一/ 超级/ 步内/ 的/ 所有/ 任务/ 障栅/ 消息/ 汇集/ 完毕/ ,/ 则/ 借助/ check/ 协议/ 回带/ 处理/ 后/ 的/ 汇集/ 障栅/ 消息/ 给/ Child/ 子/ 进程/ ./ (/ 8/ )/ Child/ 收到/ 障栅/ 消息/ 反馈/ 后/ ,/ 唤醒/ 处于/ 等待/ 状态/ 的/ 任务/ 线程/ ,/ 被/ 唤醒/ 的/ 任务/ 线程/ 解析/ 收到/ 的/ 障栅/ 消息/ ,/ 获取/ 其/ 需要/ 的/ 新/ 数据/ 同时/ 结合/ 原/ 输入/ 数据/ 切片/ ,/ 推动/ 任务/ 在/ 下/ 一个/ 超级/ 步中/ 继续/ 迭代/ 执行/ ./ (/ 9/ )/ 任务/ 在/ 进入/ 下/ 一次/ 障栅点/ 前/ 执行/ 用户/ 定义/ 的/ 收敛/ 检查/ 确定/ 任务/ 是否/ 满足/ 终止/ 条件/ ./ 5.3/ ./ 3/ 一致性/ 、/ 容错/ 处理/ 及/ 可扩展性/ 为/ 维护/ 障栅/ 消息/ ,/ MT/ 中/ 需要/ 持有/ JobTracker/ 中所/ 维护/ 的/ 若干/ 映射/ 和/ 状态/ 信息/ 的/ 一个/ 副本/ ,/ 系统/ 采用/ 推拉/ 协作/ 的/ 更新/ 模式/ 确保/ 这些/ 信息/ 在/ Job/ -/ Tracker/ 和/ MT/ 中/ 的/ 最终/ 一致性/ ./ 信息/ 的/ 更新/ 一是/ 采用/ 客户端/ (/ MT/ )/ 的/ 按/ 需/ 请求/ 模型/ 利用/ query/ 协议/ 从/ JobTracker/ 中用/ 拉/ 模式/ (/ pull/ )/ 获取/ 所/ 需/ 信息/ 的/ 最新/ 副本/ ;/ 或者/ 是/ 采用/ 服务端/ (/ JobTracker/ )/ 急切/ 更新/ (/ EagerUpdate/ )/ 模型/ 利用/ synchronize/ 协议/ 以/ 推/ 模式/ (/ push/ )/ 将/ JobTracker/ 中/ 的/ 关键/ 更新/ 及时/ 同步/ 到/ MT/ 中/ ,/ 以期/ 最小化/ 不/ 一致/ 的/ 时间/ 窗口/ ./ 同时/ 副本/ 信息/ 以/ 只读/ 的/ 形式/ 在/ MT/ 中/ 被/ 访问/ 也/ 有效/ 消除/ 了/ 资源/ 竞争/ 的/ 问题/ ./ 一些/ 重要/ 的/ 副本/ 更新/ 时机/ 包括/ :/ 作业/ 投交/ 、/ 作业/ 的/ 任务/ 切分/ 、/ 任务/ 推测/ 执行/ 、/ 作业/ 完成/ 、/ 工作/ 节点/ 失效/ 等/ ./ 新/ 作业/ 类型/ 执行/ 中/ 的/ 容错/ 需/ 利用/ 原/ Hadoop/ 集群/ 的/ 容错/ 机制/ 并/ 辅以/ 适当/ 的/ 增强/ ./ Master/ 节点/ 会/ 定期/ 轮询/ 集群/ 中/ slave/ 节点/ 的/ 状态/ ,/ 若/ 存在/ 无/ 响应/ 节点/ 则/ 重新/ 调度/ 分配/ 该/ 失效节点/ 的/ 任务/ 到/ 其他/ 活动/ 节图/ 6/ 障栅/ 消息/ 树及/ 剪枝/ 示意图/ 点上/ 重新/ 执行/ ,/ 失效节点/ 已/ 完成/ 的/ 任务/ 也/ 需要/ 重新/ 执行/ 因为/ 任务/ 产生/ 的/ 中间/ 结果/ 仅/ 持久/ 化到/ 失效节点/ 的/ 本地/ 存储/ 中/ ,/ 当/ 节点/ 失效/ 时/ 执行/ 结果/ 也/ 无法访问/ ,/ 若/ 失效节点/ 中/ 包含/ 有/ 支持/ 障栅/ 消息/ 的/ 新/ 作业/ 类型/ 的/ 任务/ ,/ 则/ 同时/ 需要/ 通知/ MT/ 清除/ 与/ 这些/ 任务/ 绑定/ 的/ 障栅/ 消息/ ,/ 等待/ 重新/ 执行/ 的/ 任务/ 发送/ 的/ 新/ 消息/ ./ 在/ 重量级/ 消息传递/ 机制/ 中/ ,/ MT/ 也/ 作为/ 一个/ 特殊/ 的/ 工作/ 节点/ 受控/ 于/ JobTracker/ ,/ 当/ MT/ 失效/ 时/ ,/ JobTracker/ 会/ 暂时/ 迁移/ 到/ 轻量级/ 消息传递/ 工作/ 模式/ 下/ ,/ 所有/ 支持/ 障栅/ 消息/ 的/ 运行/ 中/ 的/ 任务/ 都/ 需要/ 重新/ 执行/ ,/ 因为/ 汇集/ 消息/ 在/ MT/ 中/ 维护/ ,/ 当/ MT/ 失效/ 时/ 这些/ 汇集/ 消息/ 也/ 无法访问/ (/ 更/ 细粒度/ 的/ 重/ 做/ 机制/ 也/ 可以/ 定制/ 实现/ ,/ 如/ 指定/ 从/ 某/ 一个/ 超级/ 步/ 开始/ 重做/ ,/ 因为/ 篇幅/ 原因/ 不再/ 详述/ )/ ./ 扩展性/ 有/ 多方面/ 的/ 衡量/ 指标/ ,/ 主要/ 包括/ 集群/ 工作/ 节点/ 规模/ 、/ 处理/ 数据/ 规模/ 、/ 消息/ 规模/ 等/ ./ 本文/ 在/ 6.3/ 节/ 的/ 实验/ 环节/ 中/ 对/ 改进/ 框架/ 在/ 工作/ 节点/ 个数/ 和/ 原始数据/ 规模/ 的/ 扩展性/ 指标/ 上/ 进行/ 了/ 验证/ ,/ 实验/ 结果表明/ 框架/ 在/ 这些/ 指标/ 上/ 具有/ 较/ 好/ 的/ 可扩展性/ ./ 目前/ 本/ 框架/ 适用/ 于/ 传递/ 消息/ 的/ 频度/ 和量/ 都/ 比较/ 小/ 的/ 稀疏/ 图/ 问题/ ,/ 因为/ 在/ 实际/ 应用/ 中/ 稠密/ 图是/ 比较/ 少/ 的/ [/ 22/ ]/ ,/ 而且/ 大多数/ 图/ 算法/ 的/ 迭代/ 过程/ 中仅/ 需要/ 交互/ 一些/ 信息量/ 不大/ 的/ 状态/ 数据/ ./ 当/ 消息/ 量/ 和/ 频度/ 激增/ 时/ ,/ 系统/ 的/ 工作/ 性能/ 会/ 退化/ 到/ 原始/ 的/ Hadoop/ 链式/ 调用/ 水平/ ,/ 但是/ 本文/ 设计/ 的/ 系统/ 具有/ 足够/ 的/ 弹性/ 可以/ 进行/ 有/ 针对性/ 的/ 优化/ ,/ 例如/ 采用/ 传递/ 消息/ 元/ 、/ 压缩/ 消息/ 体等/ 优化/ 技术/ ,/ 这部分/ 优化/ 工作/ 是/ 我们/ 下/ 一步/ 重点/ 研究/ 的/ 内容/ ./ 5.4/ 障栅/ 消息/ 处理/ 技术/ 所有/ 的/ 障栅/ 消息/ 维护/ 工作/ 都/ 基于/ 图/ 6/ 所示/ 的/ 障栅/ 消息/ 树/ (/ BarrierMessageTree/ ,/ BMT/ )/ ,/ BMT/ 是/ 逻辑/ 多叉/ 树状/ 结构/ ,/ 其/ 由/ 4/ 个/ 层次/ 组成/ ,/ 包含/ :/ 任务/ 类型/ 层/ 、/ 作业/ 层/ 、/ 超级/ 步层/ 、/ 任务/ 层/ ./ Page13/ 先/ 建立/ 只有/ 根/ 节点/ 的/ 空树/ ,/ 当障/ 栅/ 消息/ 维护/ 节点/ 收到/ 任务/ 发送/ 的/ 障栅/ 消息/ 时/ ,/ 用/ 算法/ 3/ 建立/ BMT/ ,/ 同时/ 在/ 叶/ 节点/ 上/ 关联/ 障栅/ 消息/ ,/ 概要/ 逻辑/ 如下/ ./ 算法/ 3/ ./ BMT/ 的/ 插入/ 算法/ ./ 输入/ :/ 障栅/ 消息/ barrierMsg1/ ./ 解析/ 障栅/ 消息/ 头/ barrierMsg/ ./ header/ ,/ 获取/ Message/ -/ Type/ ,/ JobID/ ,/ StepID/ ,/ TaskID/ ,/ TimeStamp/ 以及/ TaskAttemptID/ 等/ 各/ 部分/ 的/ 值/ ;/ 2/ ./ 先/ 根据/ MessageType/ 定位/ 到/ BMT/ 中/ 正确/ 的/ 任务/ 类型/ 层/ ,/ 然后/ 根据/ JobID/ 创建/ 或者/ 定位/ 障栅/ 消息/ 所属/ 的/ 作业/ 层/ ,/ 再/ 根据/ StepID/ 创建/ 或者/ 定位/ 障栅/ 消息/ 所属/ 的/ 超级/ 步层/ ,/ 并/ 将/ TimeStamp/ 关联/ 到/ 超级/ 步/ 节点/ 上/ ,/ 最后/ 依据/ TaskID/ 建立/ 叶子/ 节点/ ;/ 节点/ 上/ ./ 3/ ./ 将障/ 栅/ 消息/ 中/ 的/ 消息/ 体/ barrierMsg/ ./ Msg/ 关联/ 到/ 叶/ 值得注意/ 的/ 是/ ,/ 具有/ 相同/ TaskID/ 不同/ TaskAttemptID/ 的/ 消息/ 只/ 建立/ 一个/ TaskID/ 叶/ 节点/ ,/ 因为/ 冗余/ 的/ 推测/ 执行/ 任务/ 产生/ 的/ 障栅/ 消息/ 是/ 完全/ 一样/ 的/ ,/ 所以/ 实质/ 上障/ 栅/ 消息/ 是/ 和/ TaskID/ 唯一/ 对应/ 的/ ./ 当/ 作业/ 执行/ 完成/ 、/ 作业/ 失效/ 或者/ 时间/ 窗口/ 过期/ 时会/ 自动/ 触发/ BMT/ 的/ 删除/ 逻辑/ ,/ 删除/ 算法/ 如下/ ./ 算法/ 4/ ./ BMT/ 的/ 删除/ 算法/ ./ 输入/ :/ JobID/ 、/ 过期/ 时间/ 窗口/ w1/ ./ if/ (/ 作业/ 完成/ or/ 作业/ 失效/ )/ 2/ ./ 依据/ JobID/ 在/ BMT/ 中/ 进行/ 定位/ ;/ 3/ ./ 删除/ JobID/ 为根/ 的/ 子树/ ;/ 4/ ./ else/ // // 时间/ 窗口/ 过期/ 5/ ./ foreachJobID/ 节点/ inBMT6/ ./ if/ (/ 不是/ 最新/ 的/ StepID/ 节点/ 7/ ./ 删除/ StepID/ 为根/ 的/ 子树/ ;/ 8/ ./ endif9/ ./ endforeach10/ ./ endif/ 算法/ 4/ 中/ 时间/ 窗口/ 过期/ 是/ 基于/ 维护/ 障栅/ 消息/ 的/ 节点/ 的/ 内存容量/ 和/ 维护/ 复杂性/ 的/ 限制/ ./ 作业/ 可能/ 在/ 不同/ 超级/ 步中/ 迭代/ 执行/ 多次/ ,/ 当下/ 一个/ 超级/ 步/ 所属/ 的/ 消息/ 被/ 接收/ 时/ ,/ 同时/ 也/ 表明/ 之前/ 超级/ 步中/ 汇集/ 完成/ 的/ 消息/ 已经/ 过期/ ,/ 那么/ 根据/ 用户/ 设定/ 的/ 过期/ 时间/ 窗口/ ,/ 可以/ 删除/ 以/ 既往/ 的/ 超级/ 步/ 节点/ 为根/ 的/ 子树/ ./ 之所以/ 不/ 在/ 新/ 超级/ 步/ 节点/ 创建/ 时/ 立刻/ 删除/ 旧/ 超级/ 步/ 节点/ 为根/ 的/ 子树/ ,/ 是/ 基于/ 细粒度/ 容错/ 的/ 考虑/ ,/ 当/ 任务/ 执行/ 发生/ 问题/ 时/ ,/ 可以/ 基于/ 超级/ 步/ 的/ 粒度/ 重新/ 投入/ 执行/ ./ 何时/ 释放/ 障栅/ 以及/ 回传/ BMT/ 上/ 哪些/ 汇集/ 的/ 障栅/ 消息/ 是/ 两个/ 很/ 重要/ 的/ 问题/ ,/ 这些/ 问题/ 在/ 剪枝/ 算法/ 中/ 解决/ ./ 算法/ 5/ ./ BMT/ 的/ 剪枝/ 算法/ ./ 输入/ :/ JobID/ ,/ TaskTrackerID1/ ./ S/ ←/ / ,/ 保存/ TaskTrackerID/ 标识/ 的/ TaskTracker2/ ./ O/ ←/ / ,/ 保存/ 可/ 反馈/ 消息/ 的/ JobID/ 的/ 集合/ 3/ ./ 获取/ 发送/ 心跳/ 请求/ 的/ TaskTracker/ 节点/ 当前/ 运行/ 4/ ./ foreachjob/ ∈/ Sdo5/ ./ releaseFlag/ =/ true/ ;/ // // 可/ 反馈/ (/ 释放/ 障栅/ )/ 标志/ 6/ ./ 在/ BMT/ 中/ 找到/ job/ 节点/ 下/ 最新/ 的/ 超级/ 步/ 节点/ ;/ 7/ ./ foreachtask/ ∈/ jobdo8/ ./ if/ (/ 叶子/ 节未/ 关联/ 障栅/ 消息/ )/ then9/ ./ releaseFlag/ =/ flase/ ;/ 10/ ./ break/ ;/ 11/ ./ endif12/ ./ endforeach13/ ./ if/ (/ releaseFlag/ =/ =/ true/ )/ 14/ ./ O/ =/ O/ +/ job/ ;/ // // 所有/ 叶/ 节点/ 都/ 关联/ 消息/ 后该/ 作业/ 15/ ./ endif16/ ./ endforeach17/ ./ foreachjob/ ∈/ O18/ ./ 以此/ job/ 的/ JobID/ 为根/ ,/ 在/ BMT/ 中/ 剪下/ 最新/ 超级/ 19/ ./ endforeach/ 假设/ TaskTracker/ 节点/ 中/ 正在/ 运行/ 的/ 作业/ 包括/ J1/ 、/ J2/ 和/ J3/ ,/ 因为/ J3/ 不/ 满足/ 障栅/ 释放/ 条件/ ,/ 所以/ 只有/ 满足/ 障栅/ 释放/ 条件/ 的/ J1/ 和/ J2/ 的/ 最新/ 超级/ 步/ 节点/ 被/ 裁剪/ ,/ 图/ 6/ 中/ 虚线/ 框内/ 显示/ 了/ 剪枝/ 处理/ 的/ 结果/ ./ 算法/ 5/ 描述/ 的/ 是/ JobTracker/ 维护/ 的/ BMT/ 的/ 剪枝/ 算法/ ,/ 裁剪/ 的/ 子/ BMT/ 回/ 传给/ TaskTracker/ ,/ 同理/ 如图所示/ TaskTracker/ 也/ 会/ 裁剪/ 其/ 维护/ 的/ BMT/ 回/ 传给/ Task/ ./ 障栅/ 消息/ 的/ 发送/ 源会/ 周期性地/ 通过/ ping/ 或者/ check/ 协议/ 向障/ 栅/ 消息/ 维护/ 节点/ 发送/ 请求/ ,/ 接收/ 到/ 请求/ 后/ ,/ BMT/ 的/ 剪枝/ 算法/ 就/ 会/ 被/ 触发/ 来/ 决定/ 是否/ 反馈/ 以及/ 反馈/ 哪些/ 消息/ ./ 整个/ 消息/ 的/ 汇集/ 、/ 删除/ 、/ 裁剪/ 等/ 过程/ 对于/ 用户/ 而言/ 是/ 完全/ 透明/ 的/ ,/ 由/ 系统/ 框架/ 在/ 后台/ 自动/ 处理/ ,/ 用户/ 只/ 需要/ 关注/ 自定义/ 消息/ 的/ 内容/ 和/ 格式/ ./ 6/ 实验/ 结果/ 与/ 分析/ 6.1/ 集群/ 环境/ 评估/ ,/ 集群/ 节点/ 的/ 硬件/ 环境/ 如表/ 1/ 所示/ ./ 实验/ 在/ 72/ 节点/ 构成/ 的/ Hadoop/ 集群/ [/ 11/ ]/ 中/ 进行/ Page14/ 表/ 1/ 集群/ 硬件/ 环境/ MasterNodeE56204/ (/ 8/ )/ @/ 2.4/ GHz482/ ×/ 146GBSAS15kSlaveNodeX34304/ (/ 4/ )/ @/ 2.4/ GHz82/ ×/ 500GBSATA7/ ./ 2kGigabitEthernetCentOS5/ ./ 5/ 节点/ 间/ 通过/ 3/ 个/ 交换机/ 和/ 千兆比特/ 网卡/ 连接/ ,/ 24/ 个/ 节点/ 为/ 一组/ 共置/ 一个/ 机架/ 中/ ,/ 节点/ 配置/ Hadoop0/ ./ 20.2/ 版本/ 以及/ 本文/ 支持/ BSP/ 模型/ 的/ 基于/ 该/ 版本/ 的/ 开/ 源代码/ 实现/ 的/ 改进版/ ./ 6.2/ 数据/ 集/ 实验/ 主要/ 采用/ 标准/ 的/ StanfordLargeNetworkDatasetCollection/ 中/ 的/ soc/ -/ LiveJournal/ 作为/ 测试/ PageRank/ 的/ 数据/ 集/ ,/ 该/ 数据/ 集/ 的/ 主要/ 特征/ 如表/ 2/ 所示/ ./ DataSetNodesLinksMeta/ -/ DataVolumesoc/ -/ LiveJournal4847571689937730G1GLiveJournal/ -/ V148475716899377314G15GLiveJournal/ -/ V248475716899377329G30GLiveJournal/ -/ V348475716899377344G45Gsoc/ -/ LiveJournal/ 是/ StanfordLargeNetworkDatasetCollection/ 数据/ 集中/ 的/ 有关/ 社交/ 网络/ 的/ 图/ 数据/ 子集/ ./ LiveJournal/ 是/ 一个/ 具有/ 强大/ 社交/ 网络/ 功能/ 的/ 博客/ 站点/ ,/ LiveJournal/ 数据/ 集以/ 〈/ FromNodeIdToNodeId/ 〉/ 二元/ 组/ 集合/ 的/ 形式/ 提供/ 该/ 网络/ 的/ 高度/ 抽象/ 的/ 有向图/ 拓扑/ ,/ 其/ 节点/ 表示/ 用户/ ,/ 边/ 是/ 用户/ 间/ 的/ 好友/ 关系/ ./ 由于/ 其/ 省略/ 了/ 图/ 2/ 中/ 提及/ 的/ 节点/ 或边/ 的/ 元/ 数据/ ,/ 原始数据/ 集/ 的/ 大小/ 约/ 为/ 1G/ ,/ 为/ 保证/ 实际/ 应用/ 时/ 处理/ 的/ 合理性/ ,/ 实验/ 以该/ 数据/ 集/ 为/ 基准/ ,/ 在/ 不/ 改变/ 图/ 拓扑/ 结构/ 的/ 条件/ 下以/ 字符串/ 形式/ 增加/ 了/ 节点/ 和/ 边/ 的/ 元/ 数据/ ,/ 形成/ 了/ 3/ 个/ 扩展/ 的/ LiveJournal/ 数据/ 集/ LiveJournal/ -/ V1/ ~/ V3/ ./ 在/ 实验/ 的/ 预处理/ 阶段/ ,/ 需要/ 将/ 二元/ 组/ 形式/ 的/ 图/ 转化/ 为/ 文中/ 图/ 2/ 所/ 描述/ 的/ 并行/ 框架/ 下/ 的/ 图/ 的/ 标准/ 键值/ 对/ 形式/ ,/ 使用/ 两个/ 简单/ 的/ 原始/ MapReduce/ 作业/ 即可/ 完成/ 所有/ 的/ 转换/ 工作/ ,/ 实验/ 中/ 并行处理/ 框架/ 的/ 输入/ 和/ 输出/ 都/ 基于/ 分布式文件系统/ HDFS/ ./ 6.3/ 评估/ 及/ 结果/ 分析/ 实验/ 首先/ 在/ 固定/ 规模/ 的/ LiveJournal/ -/ V1/ 数据/ 集/ 和/ 24/ 个/ 节点/ 上/ 测试/ 原始/ Hadoop/ 和/ 基于/ 轻量级/ 消息传递/ 以及/ 基于/ 重量级/ 消息传递/ 的/ 改进版/ Hadoop/ 的/ 总体/ 执行/ 性能/ ,/ 并用/ 线性/ 增加/ 的/ 迭代/ 次数/ 验证/ 并行执行/ 框架/ 的/ 可扩展性/ ./ 如图/ 7/ 所示/ ,/ PageRank/ 分布式/ 图/ 算法/ 在/ 基于/ 超/ HardDisk/ 级步/ 内部/ 迭代/ 的/ 改进版/ Hadoop/ 上/ 的/ 总体/ 执行/ 性能/ 明显/ 优于/ 基于/ 链式/ 调用/ 外部/ 迭代/ 的/ 原始/ Hadoop/ ./ 并且/ 随着/ 迭代/ 次数/ 的/ 增多/ ,/ 改善/ 的/ 性能/ 幅度/ 也/ 随之/ 增大/ ,/ 在/ 第/ 20/ 轮/ 迭代/ 时/ ,/ 基于/ 重量级/ 消息传递/ 机制/ 的/ 改进版/ Hadoop/ 执行/ 性能/ 相比/ 于/ 原始/ Hadoop/ 提高/ 近/ 51/ %/ ./ 因为/ 对于/ 链式/ 调用/ 的/ Hadoop/ 作业/ ,/ 每轮/ 迭代/ 都/ 不可避免/ 地/ 产生/ 作业/ 启动/ 开销/ 、/ 不变/ 数据/ 的/ 序列化/ 和/ 网络/ 传输/ 开销/ 、/ 迭代/ 中间/ 结果/ 的/ HDFS/ 持久/ 化/ 开销/ ./ 相比之下/ ,/ 改进版/ 的/ Hadoop/ ,/ 利用/ 障栅/ 消息/ 在/ 超级/ 步间/ 仅/ 传递/ 在/ 整个/ 图/ 数据/ 中所/ 占/ 比例/ 很小/ 的/ 一部分/ 随/ 迭代/ 操作/ 变化/ 的/ 状态/ 数据/ ,/ 执行/ 过程/ 中未/ 改变/ 的/ 图/ 拓扑/ 数据/ 和/ 节点/ 与/ 边/ 的/ 元/ 数据/ 作为/ 任务/ 的/ 输入/ ,/ 仍/ 驻留/ 在/ 执行/ 任务/ 的/ 工作/ 节点/ 中/ 不/ 需要/ 重新/ 加载/ ,/ 在/ 任务/ 执行/ 到/ 下/ 一个/ 超级/ 步时/ 只/ 需要/ 重置/ 输入/ 数据/ 的/ 访问/ 偏移/ 即可/ ./ 并且/ 由图/ 7/ 可以/ 观察/ ,/ 随着/ 迭代/ 次数/ 的/ 增多/ ,/ 并行执行/ 框架/ 的/ 整体/ 执行/ 性能/ 表现/ 出/ 良好/ 的/ 线性/ 可扩展性/ ,/ 这/ 得益于/ Hadoop/ 本身/ 的/ 高/ 可/ 扩展/ 特性/ ,/ 且/ 改进版/ 基于/ Hadoop/ 实现/ 并/ 继承/ 了/ 该/ 并行计算/ 框架/ 的/ 可扩展性/ ./ 图/ 7PageRank/ 总体/ 执行/ 性能/ (/ LiveJournal/ -/ V1/ ,/ 24nodes/ )/ 同时/ 还/ 可以/ 观测/ 到/ 重量级/ 消息传递/ 机制/ 在/ 整体/ 执行/ 性能指标/ 上/ 是/ 优于/ 轻量级/ 消息传递/ 机制/ 的/ ,/ 这是/ 由于/ 轻量级/ 消息传递/ 机制/ 受限于/ 集群/ 心跳/ 和/ 连通/ 指令/ 发送/ 的/ 间隔/ ,/ 为/ 保证/ JobTracker/ 节点/ 的/ 工作/ 性能/ ,/ 指令/ 发送/ 不能/ 过于/ 频繁/ ,/ 最差/ 情况/ 是/ 在/ 消息/ 汇集/ 完毕/ 后/ 仍/ 需/ 等待/ 整个/ 间隔时间/ 该/ 汇集/ 消息/ 才能/ 被/ 回/ 传到/ 消息/ 接收/ 节点/ ./ 因此/ ,/ 随着/ 迭代/ 轮次/ 的/ 增加/ ,/ 这个/ 间隔/ 延时/ 也/ 会/ 同步/ 累积/ ,/ 并/ 导致/ 性能/ 下降/ ./ 图/ 8/ 通过/ 增加/ 节点/ 规模/ 进一步/ 验证/ 了/ 这个/ 问题/ ./ Page15MapReduce/ 本身/ 是/ 一个/ 线性/ 可/ 扩展/ 的/ 计算/ 模型/ ,/ 也就是说/ Hadoop/ 集群/ 的/ 处理/ 能力/ 理论/ 上/ 可/ 随着/ 集群/ 节点/ 数/ 的/ 增加/ 实现/ 近/ 线性/ 扩展/ ./ 但是/ 由图/ 8/ 中/ 可以/ 看出/ ,/ 当/ 节点/ 初始/ 增加/ 时/ 总体/ 执行/ 时间/ 线性/ 下降/ ,/ 但是/ 当/ 集群/ 节点/ 规模/ 增加/ 到/ 一定/ 程度/ 时/ ,/ 两种/ 模式/ 的/ 总体/ 执行/ 时间/ 的/ 提升/ 幅度/ 都/ 趋于/ 减小/ ,/ 甚至/ 对于/ 轻量级/ 消息传递/ 机制/ ,/ 其/ 总体/ 执行/ 时间/ 在/ 节点/ 增加/ 到/ 60/ 以后/ 还有/ 部分/ 回升/ ./ 其/ 原因/ 在于/ 同时/ 最大/ 并发/ 的/ 任务/ 数是/ 由/ 输入/ 数据/ 的/ 切片/ 个数/ 决定/ 的/ ,/ 当/ 节点/ 增加/ 到/ 一定/ 程度/ 时/ 已经/ 能/ 满足/ 特定/ 大小/ 的/ 测试数据/ 集/ 最大/ 并发/ 性/ 的/ 要求/ ,/ 此后/ 即使/ 在/ 集群/ 中/ 投入/ 更/ 多/ 的/ 空闲/ 工作/ 节点/ 也/ 无法/ 再/ 提升/ 作业处理/ 的/ 并发/ 度/ ,/ 总体/ 执行/ 时间/ 也/ 不会/ 再进一步/ 缩短/ ./ 其次/ ,/ 对于/ 轻量级/ 消息传递/ 机制/ 的/ 执行/ 时间/ 回升/ 现象/ 是因为/ ,/ 当/ 集群/ 节点/ 数/ 增加/ 并且/ JobTracker/ 的/ 压力/ 增大/ 时/ 心跳/ 周期/ 也/ 会/ 平滑/ 地/ 增大/ ,/ 因此/ 借助/ 轮询/ 的/ 心跳/ 指令/ 回带/ 汇集/ 消息/ 的/ 轻量级/ 消息传递/ 机制/ 会/ 受到/ 影响/ ,/ 进而/ 会/ 增加/ 任务/ 移入/ 下/ 一个/ 超级/ 步/ 的/ 延迟/ ./ 因此/ 轻量级/ 消息传递/ 机制/ 适用/ 于/ 非/ 巨量/ 待处理/ 数据/ 集且/ 集群/ 节点/ 规模/ 和/ 运行/ 压力/ 适中/ 的/ 应用环境/ 中/ ./ 图/ 9/ 测试/ 的/ 是/ 当/ 数据/ 集/ 规模/ 增大/ 时/ 并行处理/ 框架/ 对于/ PageRank/ 算法/ 表现/ 的/ 可扩展性/ ./ 在/ 24/ 节点/ 集群/ 中/ 通过/ 设定/ 的/ 10/ 次/ 迭代/ 可以/ 看到/ 当/ 数据/ 规模/ 的/ 增加/ 时/ 并行/ 框架/ 显示/ 了/ 良好/ 的/ 线性/ 扩展/ 处理/ 能力/ ./ 同时/ 可以/ 发现/ 重量级/ 消息传递/ 机制/ 的/ 算法/ 总体/ 执行/ 时间/ 增加/ 幅度/ 最小/ ,/ 也/ 说明/ 该/ 机制/ 具有/ 很/ 好/ 的/ 应对/ 海量/ 数据/ 规模/ 的/ 可/ 扩展/ 能力/ ./ 最后/ 图/ 10/ 表示/ 的/ 是/ 新/ 并行/ 框架/ 的/ 兼容性/ 测试/ 结果/ ,/ 实验/ 在/ 原始/ 的/ Hadoop/ 集群/ 中/ 和/ 支持/ BSP/ 模型/ 的/ 改进型/ Hadoop/ 集群/ 中/ 分别/ 以/ 相同/ 的/ 规模/ 线性/ 增加/ 的/ 数据/ 集在/ 24/ 个/ 节点/ 上/ 进行/ 原始/ MapReduce/ 作业/ 的/ 运行/ 测试/ (/ 改进型/ Hadoop/ 运行/ 时/ 对于/ 原始/ 的/ MapReduce/ 作业/ 不会/ 触发/ 消息传递/ 机能/ )/ ,/ 实验/ 选择/ 最具/ 代表/ 型/ 的/ WordCount/ 应用/ 作为/ 原始/ 的/ MapReduce/ 作业/ ./ 实验/ 表明/ 改进型/ Hadoop/ 集群/ 可以/ 无损/ 地/ 兼容/ 原始/ 的/ MapReduce/ 作业/ ,/ 不同/ 类型/ 的/ 作业/ 的/ 调度/ 由/ 系统/ 运行/ 时/ 自动/ 处理/ ./ 图/ 10/ 兼容性/ 测试/ (/ WordCount/ ,/ 24nodes/ ,/ 无/ 迭代/ )/ 7/ 总结/ 与/ 展望/ 本文/ 针对/ 目前/ 基于/ MapReduce/ 的/ 图/ 算法/ 执行/ 性能/ 低下/ 的/ 问题/ ,/ 在/ 开源/ 的/ Hadoop/ 基础/ 上/ 通过/ 引入/ 大/ 同步/ 模型/ 实现/ 了/ 一种/ 支持/ 障栅/ 消息传递/ 的/ 改进型/ 并行计算/ 框架/ ./ 通过/ 将/ 迭代/ 过程/ 内化/ 到/ Map/ 或/ Reduce/ 阶段/ 的/ 超级/ 步间/ ,/ 有效/ 地/ 减少/ 了/ 以往/ 多轮/ 作业/ 调度/ 的/ 开销/ ,/ 为/ 分布式/ 大图/ 算法/ 的/ 设计/ 提供/ 了/ 一种/ 高效/ 的/ 计算/ 模式/ ./ 实验/ 证明/ 相比/ 于/ 原始/ 的/ MapReduce/ 图/ 算法/ ,/ 新/ 计算/ 框架/ 下/ 的/ 分布式/ 大图/ 算法/ 可行/ 、/ 高效/ ./ 此外/ ,/ 如何/ 解决/ 信息/ 交互/ 频繁/ 的/ 稠密/ 图/ 性能/ 退化/ 的/ 问题/ 以及/ 更/ 广泛/ 的/ 机器/ 学习/ 、/ 聚类/ 等/ 算法/ 在/ 该/ 平台/ 下/ 的/ 实现/ 还/ 有待于/ 进一步/ 研究/ ./ 

