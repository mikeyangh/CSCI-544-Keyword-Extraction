Page1/ 基于/ 内存/ 混合/ 复制/ 方式/ 的/ 虚拟机/ 在线/ 迁移/ 机制/ 陈阳怀/ 进鹏/ 胡春明/ (/ 北京航空航天大学/ 计算机/ 学院/ 北京/ 100191/ )/ 摘要/ 虚拟机/ VM/ (/ VirtualMachine/ )/ 在线/ 迁移/ 技术/ (/ LiveMigration/ )/ 充分利用/ 虚拟化/ 技术/ 的/ 灵活性/ 和/ 封装/ 性/ ,/ 有利于/ 实现/ 大规模/ 虚拟化/ 环境/ 中负载/ 的/ 动态/ 调整/ 以及/ 应用/ 的/ 灵活/ 部署/ ./ 已有/ 的/ 在线/ 迁移/ 机制/ 存在/ 内存/ 迭代/ 收敛/ 、/ 迁移/ 数据/ 冗余/ 以及/ 客户/ 操作系统/ 不/ 透明/ 等/ 问题/ ./ 文中/ 结合/ 内存/ 推送/ 复制/ 以及/ 按/ 需/ 复制/ 两种/ 方式/ ,/ 提出/ 了/ 基于/ 内存/ 混合/ 复制/ 方式/ 的/ VM/ 在线/ 迁移/ 机制/ HybMEC/ ,/ 以/ 实现/ 对/ VM/ 运行/ 状态/ 的/ 快速/ 迁移/ ./ 基于/ KVM/ 虚拟机/ 监控器/ ,/ 实现/ 了/ HybMEC/ 原型/ 系统/ ./ 多种不同/ 类型/ 应用/ 负载/ 下/ 的/ 实验/ 结果表明/ ,/ HybMEC/ 能够/ 高效/ 地/ 支持/ 虚拟化/ 环境/ 中/ 低/ 开销/ 、/ 低/ 延时/ 的/ VM/ 在线/ 迁移/ ,/ 并/ 在/ 总/ 迁移/ 时间/ 、/ 内存/ 同步/ 数据量/ 以及/ VM/ 停机/ 时间/ 等/ 方面/ 具有/ 显著/ 的/ 性能/ 提升/ ./ 关键词/ 虚拟机/ ;/ 虚拟机/ 监控器/ ;/ 在线/ 迁移/ ;/ 按/ 需/ 复制/ ;/ 预取/ 页/ 1/ 引言/ 渐/ 成为/ 科学界/ 和/ 工业界/ 研究/ 的/ 热点/ 主题/ ./ 云/ 计算/ 实现/ 了/ 资源/ 、/ 平台/ 以及/ 软件/ 的/ 服务化/ ,/ 并/ 通过/ 计算机网络/ 向/ 用户/ 提供/ 按/ 需/ 、/ 灵活/ 、/ 可/ 伸缩/ 的/ 计算/ 和/ 存储资源/ ./ 其中/ ,/ 基础设施/ 即/ 服务/ IaaS/ (/ Infrastructureasa/ 当前/ 云/ 计算/ 作为/ 一种/ 新型/ 网络应用/ 模式/ ,/ 已逐/ Page2Service/ )/ ,/ 例如/ AmazonEC2/ ①/ 、/ Eucalyptus/ [/ 1/ ]/ ,/ 更/ 被/ 认为/ 是/ 云/ 计算/ 的/ 先行者/ [/ 2/ ]/ ./ IaaS/ 以/ “/ 按/ 需/ 付费/ ”/ 的/ 模式/ 向/ 用户/ 提供/ 虚拟化/ 基础设施/ ,/ 有效/ 地/ 提高/ 了/ 物理/ 资源/ 利用率/ 以及/ 应用程序/ 的/ 可用性/ ,/ 同时/ 简化/ 了/ 用户/ 对于/ IT/ 基础设施/ 配置/ 和/ 运维/ 管理/ ,/ 大幅度/ 地/ 降低/ 了/ 硬件/ 投资/ 成本/ ./ 在/ IaaS/ 高/ 灵活性/ 和/ 高/ 可扩展性/ 的/ 背后/ ,/ 虚拟机/ VM/ 技术/ (/ VirtualMachineTech/ -/ nology/ )/ [/ 3/ -/ 4/ ]/ 是/ 其/ 实现/ 的/ 核心技术/ ./ 后者/ 通过/ 软件/ 抽象/ 将/ 单个/ 物理/ 机/ 资源/ 划分/ 成/ 多个/ 相互/ 隔离/ 的/ 虚拟/ 资源/ ,/ 实现/ 了/ 多个/ 操作系统/ 实例/ 对/ 单个/ 物理/ 资源/ 的/ 复用/ ./ 然而/ ,/ VM/ 在线/ 迁移/ 技术/ 更是/ VM/ 技术/ 灵活性/ 和/ 可用性/ 的/ 重要/ 应用/ 和/ 体现/ ./ 在线/ 迁移/ 技术/ 实现/ 了/ VM/ 运行/ 状态/ (/ 即/ 操作系统/ 运行/ 状态/ )/ 在/ 分布/ 、/ 异构/ 的/ 物理/ 运行/ 环境/ 中/ 快速/ 的/ 平移/ ./ 整个/ 迁移/ 过程/ 中/ ,/ VM/ 的/ 运行/ 状态/ 只/ 在/ 极小/ 的/ 时间/ 间隔/ 内/ 被/ 中断/ ,/ 这/ 使得/ VM/ 应用/ 对外/ 表现/ 出/ “/ 不间断/ ”/ 的/ 可/ 访问/ 性/ ./ 目前/ ,/ VM/ 在线/ 迁移/ 技术/ 广泛/ 地/ 应用/ 于云/ 计算/ 虚拟化/ 数据中心/ (/ virtualdatacenter/ )/ 环境/ 中/ 的/ 运维/ 管理/ ,/ 例如/ ,/ 动态/ 负载/ 均衡/ 和/ 资源管理/ 、/ 物理/ 设备/ 能耗/ 调整/ 以及/ 在线/ 的/ 设备/ 维护/ (/ onlinemaintenance/ )/ 等/ ./ 实现/ VM/ 内存/ 状态/ 在/ 源/ 、/ 目的/ 宿主机/ (/ hostma/ -/ chine/ )/ 之间/ 的/ 高效/ 复制/ 是/ VM/ 在线/ 迁移/ 技术/ 的/ 关键所在/ ./ 目前/ ,/ 主流/ 虚拟化/ 平台/ 均/ 提供/ VM/ 在线/ 迁移/ 功能/ ,/ 并且/ 在/ 实现/ 上/ 普遍/ 采用/ 了/ 基于/ 内存/ 预/ 拷贝/ Pre/ -/ copy/ 机制/ [/ 5/ -/ 6/ ]/ ./ 但是/ ,/ Pre/ -/ copy/ 机制/ 受其/ 自身/ 特性/ 的/ 约束/ ,/ 在/ 一些/ 情况/ 下/ 并/ 不能/ 取得/ 理想/ 的/ 迁移/ 效率/ ./ 例如/ ,/ 在/ 低/ 带宽/ 网络/ 环境/ 中/ 或/ 对于/ 大/ 内存/ VM/ ,/ Pre/ -/ copy/ 机制/ 很/ 可能/ 会/ 由于/ 迭代/ 收敛性/ 问题/ ,/ 导致/ 迁移/ 过程/ 中/ VM/ 应用/ 性能/ 出现/ 明显/ 的/ 下降/ ./ 而/ 对于/ 访存/ 密集型/ 应用/ ,/ 由于/ VM/ 内存/ 更新/ 频繁/ ,/ Pre/ -/ copy/ 机制/ 需要/ 经历/ 低效/ 的/ 内存/ 迭代/ 同步/ 才能/ 完成/ 内存/ 一致性/ 状态/ 的/ 复制/ ./ 过长/ 的/ 迭代/ 过程/ 导致/ 迁移/ 总/ 时间/ 被/ 延长/ ,/ 造成/ 迁移/ 过程/ 对/ 物理/ 资源/ 的/ 长时间/ 占用/ ./ 此外/ ,/ 程序/ 访存/ 的/ 局部性/ 还会/ 造成/ Pre/ -/ copy/ 机制/ 在/ 内存/ 迭代/ 复制/ 过程/ 中/ 一些/ 内存/ 数据/ 被/ 多次重复/ 地/ 复制/ ./ 这种/ 迁移/ 数据/ 的/ 高度/ 冗余/ 性/ 从/ 另一方面/ 导致/ 了/ 迁移/ 过程/ 对/ 物理/ 资源/ 不合理/ 的/ 消耗/ ./ 云/ 计算/ 系统/ 服务/ 于/ 大量/ 企业/ 或/ 个人用户/ ,/ 而/ 系统/ 中/ 有限/ 的/ 物理/ 资源/ 需要/ 在/ 众多/ 用户/ 之间/ 实现/ 共享/ ,/ 因此/ 单用户/ 往往/ 不/ 允许/ 以/ 独占/ 的/ 方式/ 使用/ 系统/ 分配/ 的/ 物理/ 资源/ ./ 但是/ ,/ 现有/ 的/ VM/ 在线/ 迁移/ 机制/ 在/ 资源/ 受限/ 的/ 环境/ 中/ ,/ 常/ 表现/ 出/ 低效/ 的/ 性能/ 甚至/ 出现/ 迁移/ 失败/ 的/ 情况/ ./ 另外/ ,/ 在/ 物理/ 资源共享/ 的/ 环境/ 中/ ,/ 当前/ 用户/ 所/ 执行/ 迁移/ 的/ 操作/ ,/ 可能/ 会/ 损害/ 其他/ 用户/ 对/ 物理/ 资源/ 的/ 需求/ ;/ 或者/ 迁移/ 操作/ 受限于/ 被/ 其他/ 用户/ 占用/ 的/ 物理/ 资源/ ./ 因此/ ,/ 在线/ 迁移/ 机制/ 在/ 实现/ VM/ 执行/ 环境/ 快速/ 切换/ 的/ 同时/ ,/ 更/ 需要/ 考虑/ 迁移/ 过程/ 本身/ 对于/ 物理/ 资源/ 的/ 占用/ 和/ 消耗/ ./ 针对/ 现有/ 在线/ 迁移/ 机制/ 性能/ 和/ 实现/ 上/ 的/ 不足/ ,/ 以及/ 云/ 计算环境/ 中/ 用户/ 物理/ 资源共享/ 且/ 受限/ 的/ 特点/ ,/ 本文/ 提出/ 基于/ 内存/ 混合/ 复制/ 方式/ 的/ VM/ 在线/ 迁移/ 机制/ HybMEC/ (/ HybridMEmoryCopy/ )/ ./ 即/ HybMEC/ 在/ 迁移/ 过程/ 中/ 充分/ 结合/ 内存/ 推送/ 复制/ 和/ 按/ 需/ 复制/ 两种/ 方式/ 实现/ VM/ 内存/ 状态/ 快速/ 、/ 高效/ 的/ 同步/ ./ 其中/ ,/ 推送/ 复制/ 是/ 指源/ 宿主机/ 主动/ 向/ 目的/ 宿主机/ 复制/ 内存/ 数据/ ;/ 而/ 按/ 需/ 复制/ 是/ 指/ 目的/ 宿主机/ 适时地/ 向源/ 宿主机/ 请求/ 某/ 一部分/ 内存/ 数据/ ./ HybMEC/ 以/ 缩短/ 总/ 迁移/ 时间/ ,/ 避免/ 迁移/ 过程/ 对/ 物理/ 宿主机/ 的/ 长时间/ 依赖/ 为首/ 要/ 目标/ ./ 同时/ ,/ HybMEC/ 还/ 尽可能/ 地/ 减少/ 迁移/ 过程/ 对/ 物理/ 资源/ 的/ 消耗/ ,/ 同时/ 降低/ VM/ 应用/ 在/ 迁移/ 过程/ 中/ 的/ 性能/ 损失/ ./ 总体/ 上/ 看/ ,/ HybMEC/ 将/ 内存/ 同步/ 的/ 过程/ 严格/ 划分/ 为/ 全/ 内存/ 同步/ 、/ 内存/ 位/ 图/ 同步/ 以及/ 脏/ 内存/ 同步/ 3/ 个/ 阶段/ ./ 其中/ ,/ 全/ 内存/ 同步/ 阶段/ ,/ Hyb/ -/ MEC/ 在/ 保持/ VM/ 运行/ 的/ 前提/ 下/ ,/ 利用/ 源/ 宿主机/ 主动/ 推送/ 的/ 方式/ 将/ VM/ 完整/ 的/ 内存/ 数据/ 复制到/ 迁移/ 目的/ 端/ ./ 该/ 阶段/ 保证/ 了/ 在/ VM/ 切换/ 到/ 目的/ 宿主机/ 上/ 运行/ 时/ ,/ 绝大多数/ 内存/ 数据/ 经过/ 一次/ 复制/ 已经/ 驻留/ 在/ 在/ 目的/ 宿主机/ 本地/ ./ 在/ 全/ 内存/ 同步/ 结束/ 后/ ,/ Hyb/ -/ MEC/ 不/ 陷入/ 脏/ 内存/ 的/ 迭代/ 复制/ ,/ 而是/ 迅速/ 地/ 复制/ 脏/ 内存/ 位/ 图/ 数据/ 并/ 在/ 目的/ 宿主机/ 上/ 恢复/ VM/ 执行/ ,/ 随后/ 真正/ 进入/ 脏/ 内存/ 同步/ 阶段/ ./ 一方面/ 利用/ 虚拟机/ 监控器/ VMM/ (/ VirtualMachineMonitor/ )/ 在/ 目的/ 宿主机/ 端/ 捕获/ VM/ 对脏/ 页面/ 的/ 访问/ ,/ HybMEC/ 通过/ 网络/ 缺页/ 处理/ 从源/ 宿主机/ 端/ 按/ 需地/ 复制/ 某/ 一部分/ 未/ 同步/ 的/ 脏/ 页面/ 数据/ ;/ 另一方面/ 为了/ 加速/ 脏/ 页面/ 的/ 同步/ ,/ HybMEC/ 定时/ 地/ 从源/ 宿主机/ 上/ 推送/ 剩余/ 的/ 脏/ 页面/ 数据/ ./ 因此/ ,/ 从/ 迁移/ 过程/ 上/ 看/ ,/ HybMEC/ 分阶段/ 地/ 利用/ 推送/ 复制/ 和/ 按/ 需/ 复制/ 实现/ 了/ 内存/ 状态/ 的/ 高效/ 同步/ ;/ 而/ 从脏/ 内存/ 数据/ 的/ 角度/ ,/ HybMEC/ 充分/ 结合/ 按/ 需/ 复制/ 及/ 定时/ 推送/ 的/ 优势/ ,/ 实现/ 了/ 对脏/ 内存/ 数据/ 的/ 快速/ 复制/ ./ 由于/ 脏/ 页面/ 的/ 按/ 需/ 复制/ 要求/ 中断/ 当前/ VM/ 的/ 正常/ 运行/ 后/ 才能/ 开始/ 执行/ 网络/ 缺页/ 处理/ ./ 因此/ ,/ 频繁/ 的/ 按/ 需/ 复制/ 势必/ 导致/ 迁移/ 过程/ 中/ VM/ 运行/ 性能/ 出现/ 剧烈/ 抖动/ ,/ 并/ 延长/ VM/ 应用/ 的/ 执行/ 延时/ ./ 为了/ 避/ ①/ AmazonElasticComputeCloud/ ./ http/ :/ // // aws/ ./ amazon/ ./ Page3/ 免/ 频繁/ 地/ 陷入/ 由/ 按/ 需/ 复制/ 引起/ 的/ 缺页/ 中断/ 处理/ ,/ 根据/ 访存/ 的/ 局部性/ 和/ 顺序/ 性/ 原理/ ,/ HybMEC/ 在/ 该/ 类型/ 缺页/ 中断/ 处理/ 中/ 采用/ 了/ 预取/ 页/ (/ Pre/ -/ paging/ )/ 机制/ ./ 即/ 从源/ 宿主机/ 端/ 按/ 需地/ 复制/ 一个/ 脏/ 页面/ 时/ ,/ HybMEC/ 会/ “/ 捎带/ ”/ 地/ 预先/ 复制/ 该/ 缺页/ 页面/ 的/ 邻居/ 脏/ 页面/ ./ 这样/ ,/ 在/ 很大/ 程度/ 上/ HybMEC/ 保证/ 了/ VM/ 后续/ 访问/ 邻居/ 脏/ 页面/ 时/ ,/ 这些/ 页面/ 已经/ 驻留/ 在/ 目的/ 宿主机/ 本地/ ,/ 而/ 避免/ 再/ 一次/ 引发/ 高/ 延时/ 的/ 网络/ 缺页/ 处理/ ./ 另外/ ,/ 为/ 进一步提高/ 内存/ 同步/ 的/ 效率/ ,/ 一方面/ ,/ HybMEC/ 主动/ 避免/ 对/ 空闲/ 页面/ 的/ 按/ 页面/ 大小/ (/ 4KB/ )/ 进行/ 复制/ ;/ 另一方面/ ,/ HybMEC/ 禁止/ 空闲/ 脏/ 页面/ 引起/ 按/ 需/ 复制/ 处理/ ,/ 转而/ 通过/ VMM/ 为/ 空闲/ 的/ 脏/ 页面/ 直接/ 分配/ 本地/ 内存/ 页/ ./ 我们/ 在/ KVM/ 虚拟化/ 平台/ 上/ 实现/ 了/ HybMEC/ 原型/ 系统/ ,/ 并/ 通过/ 多种不同/ 类型/ 的/ 应用/ 负载/ 验证/ 了/ HybMEC/ 机制/ 的/ 高效性/ 和/ 可用性/ ./ 实验/ 结果表明/ ,/ 相比/ 于/ Pre/ -/ copy/ 机制/ ,/ HybMEC/ 不仅/ 减少/ 了/ 迁移/ 过程/ 的/ 同步/ 数据量/ 、/ 降低/ 了/ 迁移/ 过程/ 造成/ 的/ VM/ 运行/ 性能/ 损失/ ,/ 而且/ 缩短/ 了/ VM/ 停机/ 时间/ 以及/ 总/ 迁移/ 时间/ ./ 特别/ 是/ 对/ 具有/ 访存/ 密集型/ 应用/ 的/ VM/ ,/ HybMEC/ 在/ 上述/ 的/ 各/ 方面/ 性能/ 上/ 均/ 有/ 显著/ 的/ 提升/ ./ 本文/ 第/ 2/ 节将/ 详细/ 介绍/ VM/ 在线/ 迁移/ 机制/ 基本/ 背景/ 以及/ HybMEC/ 机制/ 的/ 原理/ 和/ 方法/ ;/ 第/ 3/ 节/ 介绍/ HybMEC/ 在/ KVM/ 上/ 的/ 具体/ 实现/ 细节/ ;/ 第/ 4/ 节/ 介绍/ 原型/ 系统/ 的/ 实验/ 结果/ 及/ 分析/ ;/ 第/ 5/ 节/ 介绍/ 相关/ 工作/ 对比/ ;/ 最后/ 第/ 6/ 节/ 小结/ 全文/ ./ 2HybMEC/ 实现/ 原理/ 2.1/ VM/ 在线/ 迁移/ 原理/ 本质/ 上/ ,/ 在线/ 迁移/ 机制/ 实现/ 了/ VM/ 运行/ 状态/ 通过/ 计算机网络/ 在/ 物理/ 宿主机/ 之间/ 的/ 高效/ 复制/ ./ 其中/ ,/ 运行/ 状态/ 包括/ VM/ 的/ 虚拟/ 处理器/ VCPU/ 寄存器/ 、/ 内存/ 以及/ 外部/ 资源/ 设备/ 状态/ (/ 即/ 外部/ 磁盘/ 文件系统/ 和/ 图/ 1Pre/ -/ copy/ 与/ HybMEC/ 内存/ 同步/ 过程/ 对比/ 网络连接/ 状态/ )/ ./ 在/ 局域网/ LAN/ 环境/ 中/ ,/ VM/ 外部/ 资源/ 设备/ 状态/ 一般/ 可/ 通过/ 配置/ 网络共享/ 存储设备/ (/ NAS/ 、/ NFS/ 等/ )/ 以及/ 主动/ 汇报/ 网络拓扑/ 变化/ ,/ 解决/ 迁移/ 过程/ 中/ VM/ 外部设备/ 的/ 状态/ 一致性/ 问题/ [/ 5/ -/ 6/ ]/ ./ 因此/ ,/ 解决/ 内存/ 状态/ 的/ 高效/ 同步/ 成为/ VM/ 在线/ 迁移/ 的/ 关键问题/ ./ 通过/ 计算机网络/ ,/ 将/ VM/ 内存/ 状态/ 从/ 一台/ 物理/ 宿主机/ 复制到/ 另一台/ 物理/ 宿主机/ 可/ 通过/ 以下/ 3/ 种/ 方式/ [/ 6/ -/ 7/ ]/ :/ (/ 1/ )/ 停机/ 拷贝/ ./ 源/ 宿主机/ 暂停/ VM/ ,/ 将/ VM/ 内存/ 状态/ 完整/ 地/ 复制到/ 目的/ 宿主机/ ;/ 目的/ 宿主机/ 正确/ 加载/ 内存/ 状态/ 后/ 启动/ VM/ ./ (/ 2/ )/ 目的/ 端/ 按/ 需/ 复制/ ./ 源/ 宿主机/ 暂停/ VM/ 运行/ ,/ VM/ 内存/ 状态/ 驻留/ 在/ 源/ 宿主机/ 上/ ;/ 随后/ VM/ 在/ 目的/ 宿主机/ 上/ 恢复/ 运行/ ,/ 并/ 按/ 需地/ 从源/ 宿主机/ 获取/ 内存/ 页面/ ./ (/ 3/ )/ 源端/ 推送/ 复制/ ./ 源/ 宿主机/ 保持/ VM/ 持续/ 运行/ ,/ 并/ 主动/ 将/ VM/ 内存/ 状态/ 复制到/ 目的/ 宿主机/ ./ 现有/ 的/ 迁移/ 机制/ 中/ ,/ 基于/ 内存/ 预/ 拷贝/ (/ Pre/ -/ copy/ )/ 的/ 迁移/ 机制/ 结合/ 了/ 源端/ 推送/ 复制/ 和/ 停机/ 拷贝/ 两种/ 方式/ ;/ 而/ 基于/ 内存/ 后/ 拷贝/ (/ Post/ -/ copy/ )/ 的/ 迁移/ 机制/ [/ 8/ ]/ 结合/ 停机/ 拷贝/ 和/ 目的/ 端/ 按/ 需/ 同步/ 两种/ 方式/ ./ 以/ Pre/ -/ copy/ 机制/ 为例/ ,/ 其/ 完整/ 的/ 迁移/ 流程/ 如图/ 1/ (/ a/ )/ 所示/ ./ 迁移/ 初始/ ,/ VMM/ 将/ 所有/ 的/ VM/ 内存/ 页面/ 标记/ 为/ “/ 脏/ 页面/ ”/ ;/ 接着/ ,/ 迁移/ 过程/ 开始/ 进入/ 多轮/ 的/ 内存/ 迭代/ 同步/ 过程/ ./ 值得注意/ 的/ 是/ ,/ 由于/ 所有/ 页面/ 都/ 被/ 置/ 为/ “/ 脏/ 页面/ ”/ ,/ 第一轮/ 内存/ 同步/ 需要/ 复制/ 全部/ 的/ VM/ 内存/ 数据/ ;/ 而/ 后续/ 的/ 每/ 一轮/ 同步/ 只/ 需要/ 复制/ 上/ 一轮/ 同步/ 过程/ 中/ 被/ VM/ 修改/ 的/ 脏/ 页面/ 数据/ ./ 经过/ 若干次/ 迭代/ 后/ ,/ 如果/ 剩余/ 脏/ 页面/ 数/ 小于/ 预设/ 最小值/ 或/ 迭代/ 次数/ 大于/ 预设/ 最大值/ ,/ Pre/ -/ copy/ 机制/ 终止/ 迭代/ ,/ 并/ 主动/ 暂停/ 源/ 宿主机/ 上/ 的/ VM/ ,/ 将/ 剩余/ 的/ 脏/ 页面/ 以及/ 其它/ 虚拟/ 设备/ 状态/ 推送/ 至/ 目的/ 宿主机/ ./ 最后/ ,/ 目的/ 宿主机/ 接收/ 并/ 加载/ 最后/ 的/ 状态/ 数据/ 后/ 立即/ 恢复/ VM/ 执行/ ,/ 同时/ 向源/ 宿主机/ 确认/ 迁移/ 完成/ ./ Page4/ 在/ 迁移/ 过程/ 中/ ,/ 为了/ 获得/ VM/ 在/ 某/ 一/ 时刻/ 的/ 完整/ 运行/ 状态/ (/ VCPU/ 寄存器/ 、/ 内存/ 以及/ 其它/ 虚拟/ 设备/ 状态/ )/ ,/ VM/ 正常/ 运行/ 需要/ 在/ 一段时间/ 内/ 被/ 中断/ ./ 如果/ 该/ 时间/ 间隔/ 足够/ 小/ ,/ 迁移/ 机制/ 就/ 能/ 保证/ VM/ 与/ 外部/ 的/ 网络连接/ 在此期间/ 不/ 发生/ 超时/ ,/ 并/ 避免/ VM/ 应用/ 对外部/ 表现/ 出/ 明显/ 的/ 不可/ 访问/ ./ 例如/ ,/ Pre/ -/ copy/ 机制/ 在/ 结束/ 内存/ 迭代/ 同步/ 后/ ,/ 立即/ 暂停/ 源/ 宿主机/ 上/ VM/ 的/ 运行/ ,/ 并/ 在/ 随后/ 的/ 某/ 一/ 时刻/ 恢复/ VM/ 在/ 目的/ 宿主机/ 上/ 的/ 运行/ ./ 理想/ 情况/ 下/ ,/ Pre/ -/ copy/ 机制/ 能够/ 保证/ 该/ 时间/ 间隔/ 介于/ 几十/ 毫秒/ 到/ 1/ 秒/ 之间/ ./ 我们/ 将/ 该/ 时间/ 间隔/ 定义/ 为/ VM/ 停机/ 时间/ ,/ 它/ 等于/ 源/ 宿主机/ 暂停/ VM/ 时刻/ 与/ 目的/ 宿主机/ 恢复/ VM/ 执行/ 时刻/ 的/ 间隔/ ,/ 即/ VM/ 分别/ 在/ 源/ 和/ 目的/ 宿主机/ 上/ 切换/ 运行/ 状态/ 的/ 时间/ 间隔/ ./ 对于/ Pre/ -/ copy/ 机制/ ,/ VM/ 停机/ 时间/ 主要/ 由/ 停机/ 时刻/ 剩余/ 状态/ 数据/ 的/ 大小/ 及/ 可用/ 物理/ 网络带宽/ 决定/ ./ 因此/ ,/ 如果/ 剩余/ 脏/ 页面/ 数据/ 过大/ 或者/ 物理/ 网络带宽/ 过/ 小/ ,/ 那么/ VM/ 停机/ 时间/ 将/ 受此/ 影响/ 而/ 被/ 延长/ ./ 在/ 实现/ 上/ ,/ VM/ 在线/ 迁移/ 机制/ 首先/ 需要/ 保证/ 透明性/ ,/ 即/ 迁移/ 过程/ 对/ VM/ 以及/ 其/ 内部/ 应用/ 透明/ ./ 同时/ ,/ 迁移/ 机制/ 还/ 需要/ 权衡/ 各/ 方面/ 的/ 性能/ 以及/ 迁移/ 过程/ 本身/ 对/ 物理/ 资源/ 的/ 占用/ ./ (/ 1/ )/ VM/ 停机/ 时间/ ./ VM/ 被/ 暂停/ 执行/ 的/ 时间/ 间隔/ ;/ 直接/ 反映/ 了/ VM/ 不可/ 访问/ 的/ 时间/ ./ (/ 2/ )/ 总/ 迁移/ 时间/ ./ 从/ 迁移/ 开始/ 到/ 结束/ 的/ 持续时间/ ;/ 决定/ 了/ 迁移/ 过程/ 对/ 物理/ 资源/ 的/ 依赖/ 时间/ ,/ 其中/ 物理/ 资源/ 主要/ 包括/ 物理/ 网络带宽/ 、/ 宿主机/ CPU/ 资源/ ./ (/ 3/ )/ 内存/ 同步/ 数据量/ ./ 整个/ 迁移/ 过程/ 中/ 复制/ 的/ 内存/ 页面/ 数量/ ;/ 直接/ 反映/ 了/ 迁移/ 过程/ 对/ 物理/ 网络带宽/ 的/ 占用/ 情况/ ./ (/ 4/ )/ VM/ 应用/ 性能/ 损失/ ./ VM/ 内部/ 应用/ 执行/ 延时/ 或/ 对外/ 表现/ 出/ 的/ 性能/ 抖动/ ;/ 直接/ 反映/ 了/ 迁移/ 过程/ 对/ VM/ 应用/ 性能/ 的/ 影响/ ./ 虽然/ Xen/ [/ 3/ ]/ 、/ VMware/ [/ 5/ ]/ 及/ KVM/ [/ 9/ ]/ 等/ 虚拟化/ 平台/ 均/ 提供/ 了/ 基于/ 上述/ Pre/ -/ copy/ 机制/ 的/ 在线/ 迁移/ 功能/ ,/ 但是/ 由于/ 依赖/ 基于/ 源端/ 推送/ 复制/ 的/ 内存/ 迭代/ 同步/ ,/ Pre/ -/ copy/ 机制/ 并/ 不能/ 保证/ 稳定/ 的/ 迁移/ 性能/ ./ 例如/ ,/ 潜在/ 的/ 迭代/ 收敛性/ 问题/ ,/ 即当/ 网络/ 传输速率/ 小于/ VM/ 更新/ 其/ 内存/ 的/ 速率/ 时/ ,/ 迁移/ 过程/ 经过/ 多轮/ 迭代/ 复制/ 后/ 剩余/ 的/ 脏/ 页面/ 仍/ 无法/ 收敛/ 于/ 预设/ 的/ 最少/ 脏/ 页面/ 数/ 的/ 问题/ ./ 在/ 该/ 情况/ 下/ Pre/ -/ copy/ 机制/ 需要/ 被迫/ 终止/ 内存/ 迭代/ 同步/ ,/ 立即/ 暂停/ VM/ 运行/ 并/ 进入/ 停机/ 拷贝/ 阶段/ ./ 但/ 此时/ ,/ 大量/ 未/ 同步/ 脏/ 页面/ 数据/ 驻留/ 源/ 宿主机/ 上/ 等待/ 停机/ 时间/ 内/ 的/ 复制/ ,/ 造成/ VM/ 停机/ 时间/ 被/ 延长/ ./ 其次/ ,/ 内存/ 迭代/ 同步/ 方式/ 直接/ 造成/ 迁移/ 性能/ 对/ 剩余/ 脏/ 内存/ 收敛/ 速率/ 的/ 过分/ 依赖/ ./ 而/ 后者/ 在/ 不同/ 的/ VM/ 应用/ 负载/ 下/ 往往/ 表现/ 出/ 强烈/ 的/ 不确定性/ ./ 最后/ ,/ 访存/ 的/ 局部性/ 使得/ Pre/ -/ copy/ 机制/ 在/ 上/ 一次/ 迭代/ 中/ 复制/ 的/ 内存/ 页面/ 很/ 可能/ 在/ 后续/ 的/ 迭代/ 中/ 被/ 再次/ 修改/ ,/ 并且/ 修改/ 只/ 局限于/ 该/ 页面/ 上/ 的/ 某/ 一小部分/ 数据/ ./ 因此/ ,/ 内存/ 迭代/ 同步/ 造成/ 了/ 迁移/ 数据/ 具有/ 很/ 高/ 的/ 冗余/ 性/ ./ 上述/ 数据/ 的/ 冗余/ 性/ 必定会/ 导致/ 迁移/ 过程/ 对/ 物理/ 网络带宽/ 不必要/ 的/ 消耗/ 和/ 占用/ ./ 2.2/ HybMEC/ 原理/ 针对/ 现有/ 迁移/ 机制/ 的/ 不足/ ,/ 如图/ 1/ (/ b/ )/ 所示/ ,/ HybMEC/ 在/ 迁移/ 过程/ 中/ 分阶段/ 地/ 利用/ 源/ 宿主机/ 推送/ 复制/ 以及/ 目的/ 宿主机/ 按/ 需/ 复制/ 两种/ 方式/ ,/ 实现/ 对/ VM/ 内存/ 状态/ 的/ 高效/ 同步/ ./ HybMEC/ 将/ 整个/ 内存/ 同步/ 过程/ 划分/ 为/ 3/ 个/ 阶段/ :/ (/ 1/ )/ 全/ 内存/ 同步/ ./ HybMEC/ 按页/ 为/ 单位/ 将/ 整个/ VM/ 内存/ 数据/ 从源/ 宿主机/ 复制到/ 目的/ 宿主机/ ,/ 并/ 在/ 结束/ 时刻/ 暂停/ VM/ 运行/ ./ 由于/ 该/ 过程/ 中/ VM/ 在/ 源/ 宿主机/ 上/ 仍/ 保持/ 运行/ ,/ 因此/ HybMEC/ 需要/ 主动/ 地/ 标记/ 所有/ 被/ 更新/ 的/ 脏/ 页面/ ./ (/ 2/ )/ 内存/ 位/ 图/ 同步/ ./ 源/ 宿主机/ 推送/ 上一阶段/ 里/ 记录/ “/ 脏/ 页面/ ”/ 的/ 位图/ 数据/ dirty/ _/ bitmap/ ;/ 目的/ 端/ 宿主机/ 根据/ 接收/ 到/ 的/ dirty/ _/ bitmap/ 数据/ 设置/ VM/ 相应/ 页面/ 的/ 状态/ ./ (/ 3/ )/ 脏/ 内存/ 同步/ ./ 目的/ 宿主机/ 恢复/ VM/ 执行/ ,/ HybMEC/ 利用/ VM/ 访问/ 未/ 同步/ 的/ 脏/ 页面/ 产生/ 的/ 缺页/ 异常/ ,/ 从源/ 宿主机/ 端/ 按/ 需地/ 复制/ 脏/ 页面/ 数据/ ;/ 同时/ ,/ 源/ 宿主机/ 定时/ 向/ 目的/ 宿主机/ 端/ 推送/ 未/ 同步/ 的/ 脏/ 页面/ ./ 当/ 所有/ 脏/ 页面/ 复制/ 完成/ 后/ ,/ 在线/ 迁移/ 过程/ 结束/ ./ 相对/ 于/ Pre/ -/ copy/ 机制/ ,/ HybMEC/ 从根本上/ 避免/ 了/ 内存/ 迭代/ 同步/ ./ 同时/ ,/ 在/ VM/ 停机/ 时间/ 内/ ,/ Hyb/ -/ MEC/ 只/ 复制/ 内存/ 位/ 图/ 数据/ dirty/ _/ bitmap/ ,/ 减少/ 了/ VM/ 停机/ 时间/ 内/ 复制/ 的/ 数据量/ ,/ 缩短/ 了/ VM/ 运行/ 被/ 中断/ 的/ 持续时间/ ./ 其次/ ,/ 由于/ 在/ 整个/ 迁移/ 过程/ 中/ 只有/ 脏/ 页面/ 数据/ 需要/ 额外/ 的/ 一次/ 复制/ ,/ 而/ 绝大多数/ 的/ 内存/ 数据/ 只/ 需要/ 经过/ 一次/ 的/ 复制/ 即/ 完成/ 同步/ ./ 因此/ ,/ HybMEC/ 大幅/ 地/ 减少/ 迁移/ 过程/ 中/ 同步/ 数据量/ ,/ 同时/ 降低/ 对于/ 宿主机/ 物理/ 资源/ 以及/ 物理/ 网络带宽/ 的/ 占用/ ./ 最后/ ,/ 虽然/ 每/ 一次/ 的/ 脏/ 页面/ 按/ 需/ 复制/ 需要/ 强制/ 中断/ VM/ 的/ 运行/ ,/ 但是/ 相对/ 于/ Post/ -/ copy/ 机制/ 全/ 内存/ 按/ 需/ 复制/ 的/ 方式/ ,/ HybMEC/ 只/ 按/ 需/ 复制/ 部分/ 脏/ 页面/ 数据/ ,/ 这/ 在/ 很大/ 程度/ 上/ 降低/ 了/ 缺页/ 处理/ 造成/ 的/ 性能/ 损失/ ,/ 避免/ 了/ VM/ 应用/ 性能/ 出现/ 剧烈/ 抖动/ ,/ 同时/ 也/ Page5/ 缩短/ 了/ 迁移/ 持续时间/ ./ 完整/ 的/ HybMEC/ 迁移/ 过程/ 如图/ 2/ 所示/ ./ 其中/ ,/ 步骤/ VI/ -/ VIII/ 将/ 循环/ 执行/ 直至/ 所有/ VM/ 内存/ 同步/ 完毕/ ./ 步骤/ I/ 中/ ,/ 源/ 宿主机/ 发起/ 迁移/ 操作/ 并/ 向/ 目的/ 宿主机/ 复制/ 完整/ 的/ VM/ 内存/ 数据/ ,/ 同时/ 在/ dirty/ _/ bitmap/ 中/ 标记/ 复制/ 过程/ 中/ 被/ 修改/ 的/ 页面/ ;/ 随后/ 的/ 步骤/ II/ 中/ ,/ 源/ 宿主机/ 暂停/ VM/ 执行/ ./ 此时/ VM/ 的/ 内存/ 、/ VCPU/ 寄存器/ 以及/ 其它/ 虚拟/ 设备/ 状态/ 在/ 源/ 宿主机/ 上/ 被/ 冻结/ ./ 在/ 步骤/ III/ 里/ ,/ 源/ 宿主机/ 向/ 目的/ 宿主机/ 复制/ dirty/ _/ bitmap/ 、/ VCPU/ 寄存器/ 以及/ 其它/ 虚拟/ 设备/ 状态/ ./ 另一端/ ,/ 目的/ 宿主机/ 执行/ 步骤/ IV/ ,/ 根据/ 图/ 2HybMEC/ 迁移/ 流程/ 在/ 上述/ 的/ 迁移/ 过程/ 中/ ,/ 步骤/ I/ -/ II/ 对应/ 于全/ 内存/ 同步/ 阶段/ ,/ 完成/ 了/ 大部分/ 内存/ 数据/ 的/ 一次性/ 复制/ ;/ 而/ 步骤/ III/ -/ IV/ 对应/ 内存/ 位/ 图/ 同步/ 阶段/ ,/ 除了/ dirty/ _/ bitmap/ 数据/ ,/ 源/ 宿主机/ 同时/ 向/ 目的/ 宿主机/ 复制/ VCPU/ 寄存器/ 以及/ 除/ 内存/ 外/ 的/ 其它/ 虚拟/ 设备/ 状态/ 数据/ ./ 最后/ ,/ 步骤/ VI/ -/ VIII/ 对应/ 脏/ 内存/ 同步/ 阶段/ ./ 当/ 所有/ 脏/ 页面/ 完成/ 同步/ 后/ ,/ 目的/ 宿主机/ 上/ VM/ 的/ 运行/ 不再/ 依赖/ 源/ 宿主机/ ,/ HybMEC/ 断开/ 两端/ 宿主机/ 之间/ 用于/ 内存/ 同步/ 的/ 网络连接/ ,/ 并/ 释放/ 源/ 宿主机/ 上/ 为/ 迁移/ VM/ 分配/ 的/ 物理/ 内存/ ./ 2.3/ 脏/ 页面/ 同步/ VM/ 在/ 目的/ 宿主机/ 端/ 恢复/ 运行/ ,/ HybMEC/ 正式/ 进入/ 脏/ 内存/ 同步/ 阶段/ 后/ ,/ 由于/ 程序/ 访存/ 的/ 不确定性/ [/ 10/ ]/ ,/ VM/ 可能/ 在/ 一段时间/ 内/ 不再/ 访问/ 某/ 一些/ 脏/ 页面/ ./ 这/ 将/ 造成/ 依赖于/ “/ 脏/ 页面/ 访问/ ”/ 驱动/ 的/ 按/ 需/ 复制/ 不能/ 快速/ 完成/ 所有/ 脏/ 页面/ 的/ 同步/ ,/ 同时/ 也/ 导致/ 总/ 迁移/ 时间/ 的/ 不确定性/ ./ 因此/ ,/ 在/ 该/ 阶段/ 里/ HybMEC/ 利用/ 脏/ 页面/ 定时/ 推送/ 来/ 辅助/ 脏/ 页面/ 按/ 需/ 复制/ ,/ 以/ 避免/ 脏/ 页面/ 的/ 同步/ 过程/ 受限于/ VM/ 对/ 内存/ 访问/ 模式/ ./ 在/ 进入/ 脏/ 页面/ 同步/ 阶段/ 后/ ,/ 源/ 宿主机/ 上/ HybMEC/ 按/ dirty/ _/ bitmap/ 设置/ 脏/ 页面/ 的/ “/ 缺页/ ”/ 状态/ ,/ 同时/ 加载/ VCPU/ 寄存器/ 以及/ 其它/ 虚拟/ 设备/ 状态/ ;/ 最后/ 恢复/ VM/ 执行/ ./ 随后/ ,/ VM/ 在/ 目的/ 宿主机/ 上/ 正常/ 运行/ 的/ 过程/ 中/ 访问/ “/ 缺页/ ”/ 状态/ 的/ 脏/ 页面/ ,/ 产生/ 缺页/ 异常/ 被/ VMM/ 捕获/ (/ 步骤/ VI/ )/ 并/ 通过/ 目的/ 宿主机/ 向源/ 宿主机/ 发送/ 缺页/ 请求/ (/ 步骤/ VII/ )/ ./ 步骤/ VIII/ 中/ ,/ 源/ 宿主机/ 根据/ 请求/ 消息/ 中/ 缺页/ 信息/ 以及/ 本地/ dirty/ _/ bitmap/ 定位/ 脏/ 页面/ ,/ 并/ 以/ 该/ 页面/ 数据/ 响应/ 缺页/ 请求/ ;/ 而/ 目的/ 宿主机/ 接收/ 该/ 缺页数/ 据后/ ,/ 将/ 其/ 写入/ 缺页/ 地址/ 指示/ 的/ 内存/ 页/ ,/ 并/ 立即/ 恢复/ VM/ 执行/ ./ 预设/ 的/ 时间/ 间隔/ ,/ 定时/ 地向/ 目的/ 宿主机/ 推送/ 未/ 同步/ 的/ 脏/ 页面/ 数据/ ./ 这样/ ,/ 即使/ 在/ 最坏/ 情况/ 里/ ,/ VM/ 不再/ 访问/ 任一/ 脏/ 页面/ 或者/ 访问/ 任一/ 脏/ 页面/ 之前/ 该/ 页面/ 已经/ 被/ 预先/ 复制/ ,/ HybMEC/ 仍/ 可以/ 通过/ 有限/ 次/ 的/ 定时/ 推送/ 完成/ 所有/ 脏/ 页面/ 的/ 同步/ ./ 每/ 一次/ 的/ 脏/ 页面/ 按/ 需/ 复制/ 都/ 需要/ 借助于/ 网络/ 缺页/ 异常/ 处理/ 从源/ 宿主机/ 端/ 复制/ 指定/ 的/ 脏/ 页面/ ./ 在/ 该/ 过程/ 中/ ,/ VM/ 需要/ 被/ 无条件/ 地挂/ 起/ ,/ 直至/ 脏/ 页面/ 数据/ 被/ 加载/ 后/ 才能/ 恢复/ 运行/ ./ 因此/ ,/ 简单/ 的/ “/ 一次/ 一页/ 面/ ”/ 的/ 响应/ 模式/ 将会/ 恶化/ 脏/ 内存/ 同步/ 的/ 效率/ ,/ 同时/ 造成/ VM/ 应用/ 性能/ 的/ 损失/ ./ 因此/ ,/ HybMEC/ 在/ 源/ 宿主机/ 上/ 维护/ 一个/ 同步/ 窗口/ ,/ 适时地/ 用脏/ 内存/ 数据/ 填充/ 该/ 窗口/ ,/ 并/ 以/ 窗口/ 大小/ 为/ 基本/ 单位/ 执行/ 脏/ 页面/ 复制/ ./ 然而/ ,/ 频繁/ 的/ 脏/ 页面/ 按/ 需/ 复制/ 势必会/ 频繁/ 地/ 打断/ VM/ 正常/ 运行/ ,/ 导致/ VM/ 应用/ 性能/ 出现/ 抖动/ ./ 同时/ ,/ 由于/ 按/ 需/ 复制/ 的/ 处理/ 依赖于/ 高/ 延时/ 的/ 网络/ 处理/ 以及/ 大/ 开销/ 的/ VM/ 状态/ 切换/ ,/ 频繁/ 的/ 脏/ 内存/ 按/ 需/ 复制/ 势必/ 还会/ 影响/ VM/ 应用/ 的/ 执行/ 延时/ ./ 所以/ ,/ 为了/ 避免/ 频繁/ 的/ 缺页/ 中断/ 处理/ ,/ 缩短/ VM/ 应用/ 的/ 执行/ 延时/ ,/ 并/ 加速/ 脏/ 内存/ 的/ 同步/ 过程/ ,/ HybMEC/ 在/ 按/ 需/ 复制/ 的/ 缺页/ Page6/ 处理/ 中/ 采用/ 预取/ 页/ 机制/ ./ 预取/ 页/ 机制/ 最早/ 由/ Denning/ 提出/ ,/ 它/ 利用/ 程序/ 的/ 历史/ 运行/ 信息/ 预测/ 程序/ 最近/ 的/ 工作/ 集/ (/ workingset/ )/ [/ 11/ ]/ ./ 该/ 机制/ 常/ 被/ 应用/ 于/ 程序/ 内存/ 页面/ 的/ 预先/ 加载/ ,/ 例如/ 磁盘/ 数据文件/ 的/ 预先/ 加载/ ./ 根据/ 应用/ 访存/ 的/ 局部性/ 和/ 顺序/ 性/ 原理/ [/ 10/ ]/ ,/ 当前/ 被/ 访问/ 且/ 发生/ 缺页/ 异常/ 的/ 脏/ 页面/ 的/ 邻居/ 页面/ 很/ 可能/ 在/ 后续/ 的/ 运行/ 过程/ 中/ 被/ 访问/ ./ 如果/ 该/ 邻居/ 也/ 是/ 脏/ 页面/ 且/ 未/ 被/ 同步/ ,/ 那么/ VM/ 在/ 访问/ 该/ 邻居/ 脏/ 页面/ 时/ 必然/ 会/ 再/ 一次/ 引起/ 网络/ 缺页/ 处理/ ./ 但是/ ,/ 如果/ HybMEC/ 在/ 当前/ 缺页/ 响应/ 时/ “/ 捎带/ ”/ 上该/ 邻居/ 脏/ 页面/ ,/ 那么/ 就/ 能/ 直接/ 地/ 避免/ 上述/ 潜在/ 的/ 网络/ 缺页/ 处理/ ./ 因此/ ,/ 当源/ 宿主机/ 在/ 收到/ 一次/ 缺页/ 请求/ 后/ ,/ HybMEC/ 利用/ 缺页/ 信息/ 以及/ dirty/ _/ bitmap/ 数据/ 定位/ 当前/ 缺页/ 页面/ ,/ 有/ 选择地/ 用/ “/ 邻居/ ”/ 脏/ 页面/ 填充/ 上述/ 的/ 同步/ 窗口/ ,/ 并/ 迅速/ 响/ 应该/ 缺页/ 请求/ ./ 随后/ ,/ 当/ VM/ 访问/ 被/ “/ 捎带/ ”/ 的/ 脏/ 页面/ 时/ 不再/ 发生/ 缺页/ 异常/ ,/ 而/ 转向/ 对/ 本地/ 内存/ 的/ 直接/ 访问/ ./ 2.4/ 内存/ 缺页/ 设置/ 在/ 脏/ 内存/ 同步/ 阶段/ ,/ HybMEC/ 需要/ 及时/ 地/ 捕获/ VM/ 对/ 任一/ 脏/ 页面/ 的/ 访问/ ./ 如若不然/ ,/ HybMEC/ 将/ 错过/ 了/ 复制/ 该/ 页面/ 数据/ 的/ 时机/ ,/ 很/ 可能/ 造成/ VM/ 由于/ 读写/ 了/ 错误/ 的/ 内存/ 数据/ 而/ 出错/ 甚至/ 导致/ VM/ 宕机/ ./ 考虑/ 到/ 透明性/ 需求/ ,/ HybMEC/ 不能/ 依靠/ VM/ 访问/ 脏/ 页面/ 时/ 的/ 主动/ 通知/ 来/ 执行/ 按/ 需/ 页面/ 复制/ ./ 因此/ ,/ 为了/ 感知/ VM/ 对/ 任一/ 脏/ 页面/ 的/ 访问/ ,/ HybMEC/ 需要/ 根据/ 内存/ 虚拟化/ 原理/ ,/ 在/ 目的/ 宿主机/ 恢复/ VM/ 运行/ 之前/ 预先/ 为脏/ 页面设置/ 相应/ 的/ 缺页/ 状态/ ./ 同时/ ,/ 由于/ 设置/ 缺页/ 状态/ 的/ 操作/ 在/ VM/ 停机/ 期间/ 执行/ ,/ 因此/ 该/ 操作/ 的/ 执行/ 延时/ 直接/ 影响/ 了/ 迁移/ 过程/ 中/ VM/ 停机/ 时间/ ./ 所以/ ,/ HybMEC/ 需/ 通过/ 透明/ 、/ 高效/ 的/ 方式/ 控制/ 脏/ 页面/ 状态/ ./ 系统/ 虚拟化/ 中/ 的/ 地址/ 转换/ 相比/ 于/ 传统/ 操作系统/ ,/ 额外/ 引入/ 了/ 一层/ 地址映射/ 转换/ 的/ 工作/ ./ 其中/ ,/ 客户机/ 操作系统/ (/ 简称/ ,/ 客户/ OS/ )/ 负责/ VM/ 内部/ 的/ 线性/ 地址/ 到/ 客户/ OS/ 物理地址/ 的/ 映射/ ;/ 而/ VMM/ 中/ 内存/ 虚拟化/ 模块/ 负责/ 客户/ OS/ 物理地址/ 到/ 真实/ 机器/ 地址/ 的/ 映射/ ./ VM/ 运行/ 时/ ,/ VMM/ 负责/ 将/ 由/ 其/ 维护/ 的/ 页表/ 数据结构/ 写入/ 物理/ MMU/ (/ MemoryManagementUnit/ )/ 用于/ VM/ 访存/ 时/ 的/ 地址/ 转换/ ./ 因此/ ,/ HybMEC/ 可/ 通过/ 控制/ 该/ 页表/ 数据结构/ 中/ 相应/ 表项/ 的/ 属性/ 以/ 实现/ 对脏/ 页面/ 缺页/ 状态/ 的/ 设置/ ./ 在/ 迁移/ 步骤/ IV/ 中/ ,/ 目的/ 宿主机/ 在/ 接收/ 到/ dirty/ _/ bitmap/ 数据/ 后/ ,/ HybMEC/ 根据/ dirty/ _/ bitmap/ 中/ 记录/ 的/ 脏/ 页面/ 客户/ OS/ 物理地址/ 对/ 相应/ 的/ 页面设置/ 缺页/ 状态/ ./ 虽然/ ,/ 利用/ 内存/ 虚拟化/ 的/ 纯/ 软件/ 实现/ 影子/ 页表/ 技术/ SPT/ (/ ShadowPageTable/ )/ [/ 12/ ]/ ,/ HybMEC/ 亦/ 能/ 实现/ 对于/ 任一/ VM/ 内存/ 页/ 状态/ 的/ 控制/ ,/ 但是/ 考虑/ 到/ 执行/ 的/ 效率/ 及/ 实现/ 的/ 复杂性/ ,/ HybMEC/ 选择/ 利用/ EPT/ (/ ExtendingPageTable/ )/ 硬件/ 辅助/ 功能/ [/ 13/ -/ 14/ ]/ 实现/ 对脏/ 内存/ 页/ 透明/ 、/ 高效/ 的/ 控制/ ./ 这样/ ,/ 为/ 一个/ 脏/ 页面设置/ 缺页/ 状态/ 的/ 操作/ ,/ HybMEC/ 只/ 需要/ 根据/ 该/ 页面/ 的/ 客户/ OS/ 物理地址/ 查找/ EPT/ ,/ 并/ 将/ 相应/ 的/ 表项/ 上/ 设置/ 为/ “/ 不/ 存在/ ”/ (/ non/ -/ present/ )/ ./ 随后/ 在/ 脏/ 内存/ 同步/ 阶段/ ,/ VM/ 访问/ “/ 不/ 存在/ ”/ 脏/ 页面/ 时/ ,/ 将/ 产生/ 缺页/ 异常/ 并/ 自然/ 地/ 陷入/ VMM/ ,/ 而/ 被/ HybMEC/ 捕获/ ./ 2.5/ 内存/ 页/ 复制/ 优化/ 通常/ 情况/ ,/ VM/ 运行/ 时/ 并/ 不会/ 使用/ 物理/ 宿主机/ 分配/ 的/ 全部/ 内存/ ,/ 因此/ VM/ 内存/ 页/ 中/ 往往/ 含有/ 大量/ 未/ 使用/ 的/ 空闲/ 页面/ (/ freepage/ )/ ,/ 并且/ 这些/ 页面/ 一般/ 被/ 初始化/ 为/ 全零页/ (/ zeropage/ )/ ./ 如果/ 迁移/ 过程/ 中/ HybMEC/ 完整/ 地/ 复制/ 这些/ 空闲/ 页面/ 势必会/ 不必要/ 地/ 占用/ 物理/ CPU/ 及/ 网络带宽/ 资源/ ./ 最近/ ,/ Hines/ 等/ 人/ [/ 15/ ]/ 提出/ 利用/ 动态内存/ 气泡/ 机制/ (/ dyanmicself/ -/ ballooning/ )/ 避免/ 在/ Post/ -/ copy/ 迁移/ 过程/ 中/ 复制/ 空闲/ 的/ 内存/ 页面/ ./ 其/ 思想/ 是/ ,/ 迁移/ 过程/ 中/ 通过/ 定时/ 的/ 气泡/ 回收/ 机制/ ,/ 将/ VM/ 空闲/ 页面/ 换/ 出主/ 内存/ ,/ 从而/ 一定/ 程度/ 上/ 避免/ 由于/ VM/ 访问/ 空闲/ 页面/ 引起/ 网络/ 缺页/ 处理/ ./ 但是/ ,/ 在/ VM/ 在线/ 迁移/ 机制/ 中/ 引入/ 动态内存/ 气泡/ 回收/ 机制/ ,/ 一方面/ 使得/ VM/ 在线/ 迁移/ 与/ 机制/ 复杂/ 的/ VM/ 内存/ 虚拟化/ 紧/ 耦合/ ;/ 另一方面/ 要求/ 客户/ OS/ 主动/ 支持/ 内存/ 气泡/ 回收/ 机制/ ./ 为了/ 避免/ 迁移/ 过程/ 中/ 按照/ 4KB/ 大小/ 复制/ 空闲/ 内存/ 页/ ,/ HybMEC/ 采用/ 了/ 简单/ 而/ 高效/ 的/ 方法/ ./ 即/ 在/ 复制/ 一个/ 页面/ 之前/ ,/ HybMEC/ 首先/ 判断/ 该/ 页面/ 是否/ 为/ 空闲/ 页/ ./ 如果/ 是/ 空闲/ 页面/ ,/ HybMEC/ 只/ 需要/ 在/ 迁移/ 数据流/ 中/ 设置/ 一个/ 标志/ 位/ 指示/ 该/ 页面/ 为/ 空闲/ 页/ ;/ 反之/ ,/ HybMEC/ 向/ 数据流/ 中/ 写入/ 完整/ 的/ 页面/ 数据/ ./ 相比/ 于/ 复杂/ 的/ 内存/ 压缩算法/ [/ 16/ ]/ ,/ 上述/ 的/ 方法/ 只/ 针对/ 空闲/ 页面/ 处理/ ,/ 在/ 内存/ 同步/ 数据量/ 和/ 物理/ CPU/ 资源/ 消耗/ 上/ 做出/ 较/ 好/ 的/ 折衷/ ./ 实验/ 表明/ ,/ 上述/ 主动/ 避免/ 空闲/ 页面/ 复制/ 的/ 方法/ 能够/ 有效/ 地/ 节省/ 迁移/ 过程/ 占用/ 网络带宽/ 资源/ ./ 另外/ ,/ 为/ 一个/ 空闲/ 脏/ 页面/ 执行/ 按/ 需/ 复制/ 的/ 做法/ 显然/ 是/ 低效/ 而/ 不/ 可取/ 的/ ./ 这/ 是因为/ 空闲/ 脏/ 页面/ 的/ 按/ 需/ 复制/ 不但/ 造成/ VM/ 发生/ 不必要/ 的/ 状态/ 切换/ ,/ 而且/ 还/ 使得/ 迁移/ 过程/ 占用/ 不必要/ 的/ 物理/ 网络带宽/ ./ 因此/ ,/ 迁移/ 步骤/ I/ 中/ ,/ HybMEC/ 在/ dirty/ _/ bitmap/ 数据结构/ 中/ 还/ 标注/ 了/ 所有/ 的/ 空闲/ 脏/ 页面/ ;/ 迁移/ 步骤/ VI/ 中/ ,/ 当/ VM/ 访问/ 一个/ 空闲/ 脏/ 页面/ 而/ 陷入/ 缺页/ 处理/ 时/ ,/ 目的/ Page7/ 宿主机/ 上/ HybMEC/ 不向源/ 宿主机/ 发送/ 缺页/ 处理/ 请求/ ,/ 转而/ 通过/ VMM/ 直接/ 从/ 本地/ 分配/ 一个/ 页面/ ,/ 并/ 立即/ 恢复/ VM/ 运行/ ./ 3HybMEC/ 实现/ 我们/ 在/ KVM/ 虚拟化/ 平台/ (/ 版本/ KVM/ -/ 86/ // 88/ )/ 上/ 实现/ 了/ HybMEC/ 原型/ 系统/ ./ KVM/ 以/ 驱动/ 模块/ 的/ 形式/ 加载/ 进入/ Linux/ 内核/ ,/ 将/ Linux/ 操作系统/ 转换/ 成为/ 一个/ 高效/ 的/ 虚拟机/ 监控器/ ./ 同时/ ,/ KVM/ 通过/ 系统/ 调用/ ioctl/ 及/ 内存/ 共享/ 实现/ 与/ 用户/ 态/ 进程/ QEMU/ 交互/ ./ 后者/ 负责/ VM/ 初始化/ 配置/ 及/ 关键/ 虚拟/ 设备/ 模图/ 3HybMEC/ 原型/ 实现/ 3.1/ 迁移/ 数据流/ 处理/ 在/ 迁移/ 过程/ 中/ ,/ VM/ 内存/ 、/ VCPU/ 寄存器/ 、/ 内存/ 以及/ 其它/ 虚拟/ 设备/ 状态/ 数据/ 以/ 迁移/ 数据流/ 的/ 形式/ 从源/ 宿主机/ 传输/ 到/ 目的/ 宿主机/ ./ 为了/ 保证/ VM/ 状态/ 同步/ 的/ 正确性/ ,/ HybMEC/ 需要/ 准确/ 控制/ 数据流/ 在/ 源/ 和/ 目的/ 宿主机/ 上/ 的/ 发送/ 和/ 接收/ ./ 同时/ ,/ 这/ 也/ 要求/ HybMEC/ 明确/ 定义/ 不同/ 虚拟/ 设备/ 在/ 数据流/ 中/ 的/ 格式/ ,/ 并/ 正确区分/ 同一/ 虚拟/ 设备/ 在/ 不同/ 迁移/ 阶段/ 中/ 的/ 数据/ 内容/ ./ 如图/ 4/ 所示/ ,/ HybMEC/ 定义/ 了/ 4/ 种/ 类型/ 的/ 数据/ 段/ 格式/ ,/ 其中/ WPAGES/ 、/ BITMAP/ 和/ DPAGE3/ 种/ 数据/ 段/ 格式/ 分别/ 对应/ 3/ 个/ 内存/ 同步/ 阶段/ 中/ 内存/ 状态/ 数据/ ,/ 剩余/ 的/ DEVICE/ 类型/ 数据/ 段/ 格式/ 则/ 对应/ VM/ 虚拟/ 设备/ 状态/ 数据/ ./ 其中/ ,/ WPAGES/ 类型/ 数据/ 段/ 用于/ 全/ 内存/ 同步/ ;/ BITMAP/ 和/ DEVICE/ 类型/ 数据/ 段/ 则/ 用于/ 内存/ 位/ 图/ 同步/ ;/ DPAGE/ 类型/ 数据/ 段/ 则/ 用于/ 脏/ 内存/ 同步/ ./ 每/ 一种/ 数据/ 段由首/ 字节/ 标识/ 其/ 类型/ ,/ 后/ 跟/ 一段/ 不定/ 长/ 的/ 设备/ 标识/ 字/ 段/ 指明/ 该/ 数据/ 段/ 所/ 对应/ 的/ VM/ 虚拟/ 设备/ ;/ 设备/ 标识/ 字段/ 后/ 跟随/ 真正/ 的/ 状态/ 数据/ ./ 其中/ ,/ 内存/ 状态/ 数据/ 以页/ 为/ 单位/ ,/ 每个/ 页面/ 数据/ 拟/ ,/ 例如/ PCI/ 总线/ 、/ 网卡/ NIC/ 、/ IDE/ 硬盘/ 等/ ./ 原型/ 系统/ 的/ 实现/ 如图/ 3/ 所示/ ./ 在/ 用户/ 态/ 进程/ QEMU/ 中/ ,/ 我们/ 用/ HybMEC/ 迁移/ 控制器/ 替换/ 了/ KVM/ 原有/ 的/ 基于/ Pre/ -/ copy/ 迁移/ 机制/ 的/ 迁移/ 控制/ 模块/ ,/ 同时/ 增加/ 了/ HybMEC/ 脏/ 页面/ 同步/ 模块/ ,/ 即源/ 和/ 目的/ 宿主机/ QEMU/ 进程/ 中/ 的/ 缺页/ 响应/ 控制器/ 和/ 缺页/ 请求/ 控制器/ ./ 此外/ ,/ 我们/ 还/ 主要/ 修改/ 了/ KVM/ 内核/ 驱动/ 中/ 的/ 内存/ 虚拟化/ 模块/ KVM/ _/ MMU/ ./ 修改/ 后/ 的/ KVM/ _/ MMU/ 通过/ ioctl/ 向/ 用户/ 态/ QEMU/ 提供/ 设置/ VM/ 内存/ 页/ 的/ 访问控制/ 的/ 接口/ ./ 同时/ ,/ KVM/ _/ MMU/ 还/ 将/ 捕获/ VM/ 对脏/ 页面/ 访问/ ,/ 并/ 通过/ dpage/ _/ pull/ 回调/ 函数/ 向/ QEMU/ 提交/ 网络/ 缺页/ 处理/ 请求/ ./ page/ _/ data/ 的/ 前/ 8/ 字节/ 被/ 用于/ 记录/ 该/ 页面/ 信息/ 标记/ page/ _/ flag/ :/ 包括/ 该/ 页面/ 首/ 地址/ (/ 客户/ OS/ 物理地址/ )/ 以及/ 是否/ 为/ 空闲/ 页/ 等/ 重要/ 信息/ ./ 如果/ page/ _/ flag/ 指示/ 一个/ 内存/ 页面/ 为/ 空闲/ 页/ ,/ 那么/ page/ _/ data/ 字/ 段长度/ 为/ 1/ 字节/ ,/ 并且/ 其值/ 等于零/ ;/ 反之/ ,/ page/ _/ data/ 字段/ 包含/ 了/ 该/ 页面/ 完整/ 的/ 数据/ 内容/ ./ 值得注意/ 的/ 是/ ,/ DEVICE/ 类型/ 数据/ 段/ 包含/ 了/ 除/ 内存/ 外/ 的/ 所有/ 虚拟/ 设备/ 状态/ 数据/ ,/ 不同/ 设备/ 状态/ 数据/ 之间/ 以/ 虚拟/ 设备/ 标识/ 字/ 段/ 区分/ ./ HybMEC/ 原型/ 系统/ 中/ ,/ 源/ 、/ 目的/ 宿主机/ 上/ 迁移/ 控制器/ 与/ 缺页/ 控制器/ 分阶段/ 共享/ 数据流/ 通道/ (/ socket/ 连接/ )/ 用于/ 传输数据/ 流/ ./ 其中/ ,/ 迁移/ 控制器/ 负责/ 前/ 两个/ 迁移/ 阶段/ 的/ 数据流/ 传输/ ,/ 而脏/ 页面/ 同步/ 阶段/ 数据流/ 由源/ 、/ 目的/ 宿主机/ 上/ 的/ 缺页/ 控制器/ 控制/ ./ Page83/ ./ 2/ 脏/ 页面/ 按/ 需/ 复制/ 目的/ 宿主机/ 上/ HybMEC/ 除/ 对脏/ 页面设置/ 缺页/ 状态/ 之外/ ,/ 还/ 需要/ 在/ 内核/ 态/ KVM/ 模块/ 中/ 维护/ dirty/ _/ bitmap/ 数据结构/ ./ 这样/ 做/ 的/ 直接/ 好处/ 是/ ,/ 避免/ 了/ 在/ KVM/ _/ MMU/ 确认/ 当前/ 缺页/ 异常/ 页/ 是否是/ 脏/ 页面/ 时/ ,/ 从/ 内核/ 态/ 切换/ 至/ 用户/ 态/ 查询/ dirty/ _/ bitmap/ ./ 但/ 这/ 也/ 要求/ HybMEC/ 在/ 每/ 一次/ 收到/ 到/ 脏/ 页面/ 数据/ 后/ ,/ 主动/ 地/ 更新/ 内核/ 态中/ 的/ dirty/ _/ bitmap/ ./ 因此/ ,/ 目的/ 宿主机/ 迁移/ 控制器接收/ 到/ dirty/ _/ bitmap/ 数据/ 后/ ,/ HybMEC/ 通过/ ioctl/ 系统/ 调用/ 访问/ KVM/ _/ MMU/ 接口/ ,/ 对/ 所有/ 脏/ 页面设置/ 缺页/ 状态/ ,/ 并/ 在/ KVM/ 创建/ 一个/ dirty/ _/ bitmap/ 的/ 复本/ ./ 由于/ HybMEC/ 执行/ 上述/ 操作/ 时/ ,/ VM/ 在/ 目的/ 宿主机/ 上/ 仍/ 处于/ 暂停状态/ ,/ 因此/ KVM/ _/ MMU/ 还/ 未/ 为/ 一些/ 页面/ 建立/ 有效/ 的/ EPT/ 表项/ ./ 因此/ ,/ HybMEC/ 根据/ 脏/ 页面/ 地址/ 查找/ 对应/ 的/ EPT/ 表项/ 的/ 过程/ 中/ ,/ 还/ 需要/ 适时地/ 为/ 该/ 地址/ 建立/ 各级/ EPT/ 表项/ ,/ 并/ 将/ 最/ 低级/ EPT/ 表项/ 设置/ non/ -/ present/ 属性/ ./ 当/ VM/ 访问/ 一个/ 未/ 同步/ 的/ 脏/ 页面/ 时/ ,/ 将/ 产生/ 缺页/ 异常/ 而/ 陷入/ KVM/ 异常/ 处理/ 入口/ 函数/ handle/ _/ excep/ -/ toin/ ./ 后者/ 根据/ 异常/ 类型/ ,/ 确定/ 是/ 缺页/ 异常/ 后/ 则/ 调用/ 缺页/ 异常/ 处理函数/ kvm/ _/ mmu/ _/ page/ _/ fault/ ./ kvm/ _/ mmu/ _/ page/ _/ fault/ 将/ 首先/ 确认/ 产生/ 该/ 缺页/ 异常/ 的/ 原因/ 是否是/ VM/ 对/ 未/ 同步/ 的/ 脏/ 页面/ 的/ 访问/ ,/ 并且/ 当前/ 缺页/ 页面/ 不是/ 空闲/ 页面/ ./ 如果/ 上述/ 确认/ 通过/ ,/ kvm/ _/ mmu/ _/ page/ _/ fault/ 则/ 调用/ dpage/ _/ pull/ 函数/ 向/ 用户/ 态/ QEMU/ 进程/ 转发/ 脏/ 页面/ 缺页/ 事件/ ./ QEMU/ 进程/ 中/ 缺页/ 请求/ 控制器/ 模块/ 接收/ 到/ 该/ 缺页/ 事件/ 后/ ,/ 立即/ 执行/ 脏/ 页面/ 的/ 按/ 需/ 复制/ ,/ 并/ 通过/ 数据流/ 通道/ 向源/ 宿主机/ 上/ 的/ QEMU/ 进程/ 提交/ “/ 缺页/ ”/ 请求/ ./ 需要/ 注意/ 的/ 是/ ,/ 如果/ kvm/ _/ mmu/ _/ page/ _/ fault/ 函数/ 确认/ 缺页/ 脏/ 页面/ 为/ 空闲/ 页面/ ,/ 那么/ 该/ 函数/ 直接/ 为/ 该页/ 分配/ 一个零/ 页面/ ,/ 并/ 调用/ vm/ _/ lanch/ 恢复/ VM/ 运行/ ./ 对于/ 其它/ 情况/ 的/ 缺页/ 异常/ ,/ kvm/ _/ mmu/ _/ page/ _/ fault/ 将/ 按/ 正常/ 缺页/ 异常/ 处理/ 逻辑/ 执行/ ./ 3.3/ 脏/ 页面/ 预取源/ 宿主机/ 上/ 的/ QEMU/ 进程/ 在/ 进入/ 脏/ 页面/ 同步/ 阶段/ 时/ ,/ 缺页/ 响应/ 控制器/ 模块/ 将/ 自动/ 开启/ 同步/ 定时器/ ,/ 并/ 初始化/ 同步/ 窗口/ ./ 其中/ ,/ 定时器/ 间隔/ 长短/ 以及/ 同步/ 窗口/ 大小/ 都/ 会/ 对脏/ 页面/ 同步/ 效率/ 以及/ VM/ 应用/ 性能/ 造成/ 影响/ ./ 例如/ ,/ 窗口/ 过/ 小/ 或/ 定时/ 间隔/ 过长/ ,/ 可能/ 延长/ 脏/ 页面/ 同步/ 阶段/ 的/ 持续时间/ ,/ 并/ 导致/ 过多/ 的/ 网络/ 缺页/ 处理/ 而/ 造成/ VM/ 应用/ 性能/ 的/ 抖动/ ;/ 过大/ 的/ 窗口/ 或/ 过/ 短/ 的/ 超时/ 间隔/ ,/ 可能/ 会/ 导致/ 脏/ 页面/ 同步/ 过程/ 占用/ 过多/ 的/ 物理/ 资源/ 而/ 造成/ VM/ 应用/ 性能/ 的/ 明显/ 下降/ ./ 目前/ HybMEC/ 原型/ 实现/ 中/ ,/ 我们/ 将/ 定时器/ 间隔/ 设定/ 为/ 10ms/ ,/ 同步/ 窗口/ 大小/ 等于/ 64/ 页/ (/ 256KB/ )/ ./ 通过/ 定量/ 的/ 实验/ 分析/ ,/ 明确/ 上述/ 两个/ 参数/ 对/ HybMEC/ 迁移/ 性能/ 的/ 影响/ 将/ 是/ 我们/ 下/ 一步/ 工作/ 内容/ 之一/ ./ 当源/ 宿主机/ 上/ 同步/ 定时器/ 发生/ 超时/ 时/ ,/ 缺页/ 响应/ 控制器/ 会/ 将/ 同步/ 窗口/ 首/ 地址/ 移置/ 窗口/ 上/ 一次/ 结束/ 位置/ 的/ 下/ 一个/ 脏/ 页面/ 处/ ,/ 并/ 依次/ 将页/ 框号/ (/ framenumber/ )/ 大于/ 窗口/ 当前/ 起始页/ 面/ 的/ 剩余/ 脏/ 页面/ 填入/ 同步/ 窗口/ ,/ 直至/ 窗口/ 剩余/ 空间/ 或/ 剩余/ 脏/ 页面/ 数为/ 零/ ./ 随后/ ,/ 缺页/ 响应/ 控制器/ 开始/ 推送/ 同步/ 窗口/ 中/ 的/ 脏/ 页面/ 数据/ ,/ 并/ 在/ 本次/ 推送/ 结束/ 时/ 更新/ 本地/ dirty/ _/ bitmap/ 数据/ 以及/ 同步/ 定时器/ ,/ 等待/ 同步/ 定时器/ 下/ 一次/ 超时/ 的/ 到来/ ./ 如果/ 源/ 宿主机/ QEMU/ 进程/ 接收/ 到/ 缺页/ 请求/ ,/ 那么/ 缺页/ 响应/ 控制器/ 立刻/ 结束/ 当前/ 的/ 定时器/ 等待/ 而/ 进入/ 缺页/ 响应/ 处理/ ./ 此时/ ,/ 缺页/ 响应/ 控制器/ 立即/ 将/ 同步/ 窗口/ 首/ 地址/ 调整/ 至/ 当前/ 缺页/ 页面/ 处/ ,/ 并/ 将/ 该/ 页面/ 剩余/ 邻居/ 脏/ 页面/ 填入/ 窗口/ ,/ 直至/ 窗口/ 剩余/ 空间/ 或/ 剩余/ 脏/ 页面/ 数为/ 零/ ;/ 接着/ ,/ 缺页/ 响应/ 控制器/ 立即/ 以/ 窗口/ 中/ 的/ 页面/ 数据/ 响应/ 缺页/ 请求/ ./ 此外/ ,/ 在/ 源/ 宿主机/ 上/ ,/ 缺页/ 响应/ 控制器/ 真正/ 传输/ 一个/ 页面/ 数据/ 前/ 同样/ 需要/ 确认/ 该/ 页面/ 是否/ 为/ 空闲/ 页/ ,/ 避免/ 空闲/ 的/ 脏/ 页面/ 通过/ “/ 捎带/ ”/ 或者/ 定时/ 推送/ 以/ 完整/ 页/ 数据/ 的/ 形式/ 被/ 复制/ ./ 在/ 目的/ 宿主机/ 上/ ,/ QEMU/ 进程/ 中/ 的/ 缺页/ 请求/ 控制器/ 除了/ 控制/ 向源/ 宿主机/ QEMU/ 进程/ 提交/ 缺页/ 请求/ ,/ 还/ 负责/ 接收/ 脏/ 页面/ 数据流/ ./ 在/ 接收/ 到/ 脏/ 页面/ 数据/ 后/ ,/ 缺页/ 请求/ 控制器/ 通过/ ioctl/ 调用/ 通知/ 内核/ 态/ KVM/ _/ MMU/ 更新/ VM/ 内存/ 页面/ 映射/ 关系/ 以及/ dirty/ _/ bitmap/ 数据/ ./ 4/ 实验/ 评估/ 前/ 文/ 介绍/ 了/ HybMEC/ 原型/ 系统/ 的/ 实现/ 细节/ ,/ 本节/ 将/ 通过/ 具体/ 实验/ 验证/ HybMEC/ 的/ 有效性/ 和/ 可用性/ ,/ 并/ 说明/ 各项/ 关键技术/ 对于/ 迁移/ 性能参数/ 的/ 影响/ ./ 在/ 多种不同/ 类型/ 的/ 应用/ 负载/ 下/ ,/ 我们/ 将/ 对比/ KVMPre/ -/ copy/ 机制/ ,/ 并/ 关注/ 总/ 迁移/ 时间/ 、/ VM/ 停机/ 时间/ 、/ 内存/ 同步/ 数据量/ 以及/ VM/ 应用/ 性能/ 损失/ 等/ 性能参数/ ./ 最终/ 的/ 实验/ 结果表明/ ,/ 相比/ 于/ Pre/ -/ copy/ 机制/ ,/ HybMEC/ 不仅/ 减少/ 了/ 迁移/ 数据量/ 、/ 降低/ 了/ 迁移/ 过程/ 造成/ 的/ VM/ 运行/ 性能/ 损失/ ,/ 而且/ 缩短/ 了/ VM/ 停机/ 时间/ 以及/ 总/ 迁移/ 时间/ ./ 特别/ 是/ 对/ 具有/ 访存/ 密集型/ Page9/ 应用/ 的/ VM/ ,/ HybMEC/ 表现/ 出/ 明显/ 的/ 稳定性/ 和/ 高效性/ ./ 4.1/ 实验/ 环境/ 我们/ 在/ DELLT1500/ 工作站/ 上/ 完成/ 所有/ 迁移/ 实验/ ./ 各/ 物理/ 机/ 配置/ :/ Intel/ (/ R/ )/ Core/ (/ TM/ )/ i7860/ @/ 2.80/ GHzCPU/ ,/ 8GB/ 内存/ ,/ 320GBSATA/ 硬盘/ 以及/ BroadcomBCM57780Gigabit/ 网卡/ ./ 物理/ 机/ 之间/ 通过/ H3CS5120/ -/ 28C/ -/ EI/ 千兆/ 交换机/ 连接/ ;/ 所有/ 的/ VM/ 磁盘镜像/ 文件/ 存放/ 在/ iSCSI/ 共享/ 存储/ 服务器/ ./ KVM/ 宿主机/ 软件/ 环境/ 为/ UbutunServer10/ ./ 04TLS/ ,/ 内核/ 版本/ 2.6/ ./ 32/ -/ 24/ ,/ KVM/ 版本/ kvm/ -/ 88/ ./ 实验/ 中/ ,/ VM/ 均/ 配置/ 了/ 一个/ VCPU/ ,/ 并/ 安装/ UbuntuDesktop10/ ./ 04LTS/ 版本/ 操作系统/ ,/ 内存大小/ 介于/ 256MB/ ~/ 2GB/ 之间/ ./ 此外/ ,/ 所有/ VM/ 通过/ 桥接/ 模式/ 接入/ 物理/ 网络/ ./ 如果/ 没有/ 特别/ 指出/ ,/ 实验/ 中/ VM/ 虚拟内存/ 大小/ 默认设置/ 为/ 512MB/ ./ 另外/ ,/ 同/ 一组/ 应用/ 负载/ 下/ VM/ 迁移/ 实验/ 被/ 重复/ 10/ 次/ ,/ 本节/ 中/ 实验/ 结果/ 为/ 10/ 次/ 结果/ 均值/ ./ 4.2/ 内存/ 压力/ 负载/ 为了/ 验证/ 访存/ 密集型/ 负载/ 条件/ 下/ ,/ HybMEC/ 迁移/ 的/ 高效性/ 和/ 可用性/ ,/ 我们/ 以/ 一个/ 内部/ 持续/ 运行/ 内存/ 更新/ 程序/ 的/ VM/ 作为/ 迁移/ 对象/ ./ 其中/ ,/ 内存/ 更新/ 程序/ 模拟/ 一个/ 访存/ 密集型/ 应用/ ,/ 以/ 页面/ 为/ 单位/ ,/ 按照/ 指定/ 的/ 速率/ 循环/ 更新/ 其/ 线性/ 地址/ 空间/ 内/ 的/ 一块/ 内存/ 区域/ ;/ 每次/ 访问/ 一个/ 内存/ 页/ 时/ ,/ 该/ 程序/ 将/ 向/ 内存/ 页/ 首/ 字节/ 写入/ 一个/ 随机数/ ./ 每/ 一组/ 迁移/ 实验/ 中/ ,/ 当/ 内存/ 更新/ 程序运行/ 15s/ 后/ ,/ VM/ 开始/ 执行/ 在线/ 迁移/ 如图/ 5/ 所示/ ,/ 当/ 内存/ 更新/ 速率/ 由/ 0/ 逐渐/ 上升/ 至/ 10240/ 页/ // s/ ,/ Pre/ -/ copy/ 机制/ 迁移/ 性能/ 急剧下降/ ./ 其中/ ,/ 总/ 迁移/ 时间/ 从/ 最初/ 的/ 8.3901/ s/ 上升/ 至/ 188.7537/ s/ ./ 实验/ 中/ ,/ 我们/ 发现/ 当/ 内存/ 更新/ 速率/ 大于/ 16348/ 页/ // s/ ,/ Pre/ -/ copy/ 迁移/ 即/ 出现/ 无法/ 正常/ 结束/ 的/ 情况/ ./ 因此/ ,/ Pre/ -/ copy/ 机制/ 的/ 内存/ 压力/ 负载/ 实验/ 中/ ,/ 我们/ 只/ 给出/ 了/ 内存/ 更新/ 速率/ 小于/ 10240/ 页/ // s/ 的/ 实验/ 结果/ ./ 最图/ 5Pre/ -/ copy/ 迁移/ 总/ 时间/ 随/ 内存/ 更新/ 速率/ 的/ 变化/ 后/ ,/ 我们/ 还/ 发现/ 即使/ 在/ 相同/ 内存/ 负载/ 条件/ 下/ ,/ Pre/ -/ copy/ 机制/ 的/ 总/ 迁移/ 时间/ 具有/ 明显/ 的/ 不稳定性/ ./ 例如/ ,/ 当/ 内存/ 更新/ 速率/ 设定/ 为/ 10240/ 页/ // s/ ,/ 总/ 迁移/ 时间/ 的/ 最大/ 差值/ 接近/ 75s/ ./ 上述/ 的/ 实验/ 结果表明/ ,/ VM/ 内存/ 更新/ 速率/ 明显/ 地/ 制约/ 着/ Pre/ -/ copy/ 机制/ 迁移/ 性能/ ./ 随着/ 内存/ 更新/ 速率/ 上升/ ,/ 迁移/ 性能/ 出现/ 大幅度/ 下降/ 同时/ 还/ 伴随/ 着/ 强烈/ 的/ 不稳定性/ ./ 通过/ 分析/ KVM/ (/ 版本/ kvm/ -/ 86/ ~/ kvm/ -/ 0.12/ ./ 4/ )/ 的/ Pre/ -/ copy/ 机制/ 源代码/ ,/ 我们/ 发现/ 造成/ 上述/ 结果/ 的/ 原因/ 在于/ KVM/ 仅以/ 最小/ 脏/ 内存/ 数/ 作为/ 内存/ 迭代/ 同步/ 的/ 终止/ 条件/ ,/ 而/ 未/ 考虑/ 通过/ 设置/ 最大/ 迭代/ 次数/ 或/ 最大/ 数据传输/ 量/ 限制/ 迭代/ 同步/ ./ 因此/ ,/ 当/ VM/ 内存/ 更新/ 速率/ 大于/ 物理/ 网络/ 传输速率/ 时/ ,/ Pre/ -/ copy/ 机制/ 因为/ 剩余/ 脏/ 页面/ 数/ 不能/ 收敛/ 于/ 最小/ 脏/ 内存/ 数而/ 导致/ 迁移/ 失败/ ./ 但是/ ,/ 由于/ 最小/ 剩余/ 脏/ 内存/ 数/ 的/ 限制/ ,/ Pre/ -/ copy/ 机制/ 在/ 不同/ 的/ 负载/ 下/ 停机/ 时间/ 内/ 复制/ 的/ 数据量/ 大致/ 相等/ ,/ 这/ 使得/ VM/ 停机/ 时间/ 反而/ 不/ 随着/ 内存/ 更新/ 速率/ 的/ 上升/ 而/ 表现/ 出/ 明显/ 变化/ ,/ 如图/ 6/ 所示/ ./ 但是/ ,/ 这样/ 的/ 稳定性/ 以/ 剩余/ 脏/ 内存/ 数可/ 收敛/ 为/ 前提/ ,/ 以/ 延长/ 总/ 迁移/ 时间/ 为/ 代价/ ./ 虽然/ ,/ 不同/ 的/ 虚拟化/ 平台/ 对于/ Pre/ -/ copy/ 机制/ 在/ 实现/ 细节/ 上/ 不尽相同/ ,/ 但是/ 通过/ 上述/ 的/ 实验/ 及/ 分析/ ,/ 我们/ 有/ 理由/ 相信/ 由于/ 依赖于/ 剩余/ 脏/ 内存/ 收敛/ 速率/ ,/ Pre/ -/ copy/ 机制/ 在/ 访存/ 密集型/ 负载/ 下/ 不能/ 保证/ 理想/ 的/ 迁移/ 性能/ ./ 相反/ ,/ 因为/ 不/ 依赖于/ 迭代/ 同步/ ,/ 所以/ 即使/ VM/ 内存/ 更新/ 速率/ 远大于/ 物理/ 网络/ 传输速率/ ,/ HybMEC/ 亦/ 能/ 高效/ 地/ 完成/ 迁移/ 任务/ ./ 如图/ 7/ 所示/ ,/ 当/ VM/ 内存/ 更新/ 速率/ 由/ 0/ 增加/ 至/ 65536/ 页/ // s/ ,/ 总/ 迁移/ 时间/ 只是/ 缓慢/ 增加/ 至/ 最初/ 值/ 的/ 10.2/ 倍/ ./ 即便/ 是/ 内存/ 更新/ 速率/ 上升/ 为/ 65536/ 页/ // s/ ,/ HybMEC/ 迁移/ 平均/ 持续时间/ 为/ 32s/ ,/ 平均/ 复制/ 了/ 203100/ 个/ 内存/ 页面/ ,/ 其中/ 大约/ 有/ 67930/ 个/ 页面/ (/ 约/ 265MB/ )/ 经过/ 脏/ 内存/ 同步/ 的/ 二次/ 复制/ ./ 图/ 6/ 对比/ 了/ 两种/ 迁移/ 机制/ 的/ VMPage10/ 停机/ 时间/ 随/ 内存/ 更新/ 速率/ 的/ 上升/ 的/ 变化/ 情况/ ./ 我们/ 发现/ ,/ 当/ 内存/ 更新/ 速率/ 较/ 小/ 的/ 情况/ 下/ ,/ HybMEC/ 的/ VM/ 停机/ 时间/ 明显/ 低于/ Pre/ -/ copy/ 机制/ ./ 这/ 是因为/ 在/ 停机/ 时间/ 内/ ,/ HybMEC/ 只/ 需要/ 复制/ 脏/ 页面/ 位/ 图/ 数据/ ,/ 并且/ 脏/ 页面/ 缺页/ 状态/ 设置/ 执行/ 延时/ 小于/ Pre/ -/ copy/ 的/ 剩余/ 脏/ 内存/ 复制/ 延时/ ,/ 因此/ HybMEC/ 能够/ 保证/ 相对/ 更/ 小/ 的/ VM/ 停机/ 时间/ ./ 但是/ ,/ 随着/ 内存/ 更新/ 速率/ 的/ 进一步/ 上升/ ,/ 停机/ 时刻/ 剩余/ 脏/ 页面/ 数/ 增加/ ,/ HybMEC/ 执行/ 脏/ 页面/ 缺页/ 状态/ 设置/ 的/ 延时/ 增大/ ./ 因此/ ,/ 当/ 内存/ 更新/ 速率/ 大致/ 为/ 5600/ 页/ // s/ (/ 约/ 22MB/ // s/ )/ 时/ ,/ HybMEC/ 的/ VM/ 停机/ 时间/ 超过/ Pre/ -/ copy/ 机制/ ./ 然而/ ,/ 实验/ 中/ 我们/ 也/ 发现/ 即便/ 内存/ 更新/ 速率/ 上升/ 至/ 65536/ 页/ // s/ ,/ HybMEC/ 也/ 只/ 造成/ 293.024/ ms/ 的/ 停机/ 时间/ ./ 在/ 图/ 8/ 中/ ,/ 我们/ 给出/ 了/ 相同/ 内存/ 更新/ 速率/ 的/ 条件/ 下/ ,/ 两种/ 机制/ 在/ 迁移/ 过程/ 中/ 内存/ 同步/ 数据量/ 对比/ 情况/ ./ 从图/ 中/ 我们/ 看到/ ,/ 随着/ 内存/ 更新/ 速率/ 的/ 增大/ ,/ 两种/ 机制/ 在/ 同步/ 数据量/ 上/ 的/ 差距/ 被/ 迅速/ 拉大/ ./ 其/ 原因/ 在于/ 随着/ 内存/ 更新/ 速率/ 的/ 增大/ ,/ 迁移/ 过程/ 中/ Pre/ -/ copy/ 机制/ 重复/ 复制/ 的/ 内存/ 页面/ 数/ 急剧/ 上升/ ,/ 而/ HybMEC/ 只有/ 部分/ 的/ 脏/ 页面/ 执行/ 额外/ 的/ 一次/ 复制/ ./ 此外/ ,/ HybMEC/ 对于/ 空闲/ 页面/ 的/ 处理/ 进一步/ 减小/ 了/ 被/ 复制/ 的/ 内存/ 页/ 数量/ ./ 图/ 7HybMEC/ 迁移/ 总/ 时间/ 随/ 内存/ 更新/ 速率/ 的/ 变化/ 图/ 8Pre/ -/ copy/ 与/ HybMEC/ 迁移/ 内存/ 同步/ 数据量/ 对比/ 上述/ 3/ 方面/ 的/ 迁移/ 性能/ 对比/ 结果/ 说明/ ,/ 由于/ 依赖于/ 剩余/ 脏/ 内存/ 收敛/ 速率/ ,/ Pre/ -/ copy/ 机制/ 在/ 访存/ 密集型/ 应用/ 负载/ 下/ ,/ 并/ 不能/ 保证/ 理想/ 的/ 迁移/ 性能/ ,/ 甚至/ 出现/ 迁移/ 失败/ 的/ 情况/ ./ 然而/ ,/ HybMEC/ 通过/ 推送/ 和/ 按/ 需/ 复制/ 相结合/ 的/ 方式/ ,/ 减缓/ 了/ 内存/ 更新/ 对/ 迁移/ 性能/ 的/ 影响/ ,/ 加速/ 迁移/ 过程/ 的/ 同时/ ,/ 大幅度/ 地/ 降低/ 同步/ 数据量/ ,/ 减少/ 了/ 迁移/ 过程/ 对/ 物理/ 资源/ 的/ 消耗/ ./ 4.3/ 并发/ Web/ 负载/ 为了/ 研究/ HybMEC/ 在/ 迁移/ 过程/ 中/ 对/ VM/ 应用/ I/ // O/ 性能/ 造成/ 的/ 影响/ ,/ 我们/ 以/ 内部/ 运行/ Apache2/ 服务器/ 的/ VM/ 为/ 迁移/ 对象/ ,/ 跟踪/ 并/ 分析/ 了/ 迁移/ 过程/ 中/ Apache2/ 服务器/ 在/ 并发/ 访问/ 下/ 输出/ 带宽/ 的/ 变化/ 情况/ ./ 实验/ 中/ ,/ 我们/ 在/ 第/ 3/ 台/ 物理/ 机上/ 模拟/ 了/ 50/ 个/ 并发/ 客户端/ 持续/ 从/ Apache2/ 服务器/ 下载/ 512KB/ 静态/ 文件/ 的/ 行为/ ./ 图/ 9/ 和/ 图/ 10/ 分别/ 给出/ 了/ Pre/ -/ copy/ 和/ HybMEC/ 迁移/ 过程/ Apache2/ 服务器/ 输出/ 带宽/ 的/ 变化/ 曲线/ ./ 其中/ ,/ 两次/ 迁移/ 实验/ 分别/ 从图/ 中/ 的/ 10.5/ s/ 和/ 1.5/ s/ 时刻/ 开始/ ./ 图中/ 我们/ 可以/ 看出/ ,/ 两种/ 迁移/ 实验/ 中/ 输出/ 带宽/ 曲线/ 均/ 出现/ 了/ 瞬时/ 下降/ 和/ 恢复/ ./ 但是/ ,/ HybMEC/ 曲线/ 中/ Apache2/ 输出/ 带宽/ 出现/ 明显/ 波动/ ,/ 即/ 从/ 最小/ 带宽/ 值/ 恢复/ 至/ 正常/ 波动/ 范围/ 的/ 持续时间/ 要/ 小于/ Pre/ -/ copy/ 机制/ ./ 出现/ 上述/ 实验/ 结果/ 的/ 原因/ 在于/ HybMEC/ 在/ 目的/ 宿主机/ 上/ 恢复/ VM/ 执行/ 后/ ,/ 通过/ “/ 定时/ 推送/ ”/ 以及/ “/ 预取/ 页/ ”/ 加速/ 了/ 脏/ 内存/ 页/ 数据/ 的/ 同步/ 过程/ ,/ 避免/ 了/ 频繁/ 的/ 脏/ 页面/ 按/ 需/ 复制/ 对/ VM/ 运行/ 性能/ 的/ 影响/ ./ 此外/ ,/ 将/ VM/ 切换/ 到/ 目的/ 宿主机/ 上/ 运行/ 之前/ ,/ Hyb/ -/ MEC/ 通过/ 为脏/ 页面设置/ 缺页/ 状态/ 的/ 操作/ ,/ 预先/ 为脏/ 页面/ 在/ EPT/ 表中/ 建立/ 了/ 地址映射/ 关系/ ./ 这样/ ,/ 当/ VM/ 访问/ 上述/ 脏/ 页面/ 时/ 不再/ 因为/ 地址映射/ 关系/ 未建图/ 9Pre/ -/ copy/ 迁移/ 过程/ 中/ Apache2/ 输出/ 带宽/ 变化/ 图/ 10HybMEC/ 迁移/ 过程/ 中/ Apache2/ 输出/ 带宽/ 变化/ Page11/ 立而/ 通过/ 缺页/ 异常/ 陷入/ 内核/ 态/ KVM/ _/ MMU/ 处理/ 地址映射/ 关系/ 的/ 建立/ ./ 相反/ ,/ Pre/ -/ copy/ 机制/ 由于/ 在/ 切换/ VM/ 运行/ 的/ 时刻/ ,/ 目的/ 宿主机/ 上/ EPT/ 基本/ 为空/ ,/ KVM/ 需要/ 在/ 后续/ 的/ 运行/ 过程/ 中/ 通过/ 缺页/ 异常/ 处理/ 动态/ 地为/ VM/ 访问/ 的/ 页面/ 建立/ 地址映射/ 关系/ ./ 因此/ ,/ 如图/ 9/ 所示/ ,/ Pre/ -/ copy/ 机制/ 造成/ VM/ 性能/ 在/ 迁移/ 结束/ 后/ 的/ 5s/ 时间/ 里/ 才/ 恢复正常/ ./ 此外/ ,/ 在/ 实验/ 中/ 我们/ 也/ 发现/ 与/ 内存/ 压力/ 负载/ 实验/ 类似/ 的/ 结果/ ./ 在/ 并发/ Web/ 负载/ 下/ ,/ HybMEC/ 的/ 迁移/ 持续时间/ 仍/ 明显/ 小于/ Pre/ -/ copy/ 机制/ ./ 上述/ 实验/ 结果/ 说明/ ,/ 即使/ 是/ 高/ 并发/ I/ // O/ 负载/ 条件/ 下/ ,/ HybMEC/ 在/ 脏/ 内存/ 同步/ 阶段/ ,/ 采用/ 定时/ 推送/ 复制/ 辅助/ 按/ 需/ 复制/ 的/ 方式/ ,/ 保证/ 了/ VM/ 应用/ 在/ 迁移/ 过程/ 中/ 更为/ 稳定/ 的/ I/ // O/ 性能/ ./ 4.4/ 综合/ 负载/ 对比/ 实验/ 的/ 最后/ ,/ 我们/ 对比/ 了/ 4/ 种/ 不同/ 类型/ 负载/ 下/ HybMEC/ 与/ KVMPre/ -/ copy/ 机制/ 迁移/ 的/ 性能/ ,/ 包括/ 总/ 迁移/ 时间/ 、/ VM/ 停机/ 时间/ 以及/ 内存/ 同步/ 数据量/ ,/ 实验/ 结果/ 分别/ 如图/ 11/ ~/ 图/ 13/ 所示/ ./ 实验/ 中/ ,/ 除了/ 上述/ 内存/ 压力/ 负载/ (/ Mem/ _/ stress/ )/ 和/ 并发/ Web/ 负载/ (/ Apache2/ _/ web/ )/ ,/ 我们/ 还/ 选取/ Linux/ 内核/ 编译/ (/ Liux/ -/ kbuild/ )/ 以及/ 空闲/ 系统/ (/ idle/ )/ 作为/ 迁移/ 实验/ 的/ 应用/ 负载/ ./ 其中/ ,/ Linux/ -/ kbuild/ 是/ 一种/ 系统/ 调用/ 密集型/ 应用/ 负载/ ,/ 其/ 对于/ CPU/ 、/ 内存/ 以及/ 磁盘/ 文件/ 读写/ 的/ 操作/ 需求/ 大致/ 均衡/ ;/ 而/ idle/ 负载/ 除了/ 必要/ 的/ 系统/ 程序/ 随/ 客户/ OS/ 启动/ 后/ ,/ 无/ 额外/ 的/ 应用/ 程序运行/ ,/ 近似/ 为/ 低/ 负载/ 应用/ 场景/ ./ 从图/ 11/ 中/ 我们/ 不难看出/ 4/ 种/ 负载/ 情况/ 下/ ,/ 相对/ 于/ Pre/ -/ copy/ 机制/ ,/ HybMEC/ 均/ 大幅/ 地/ 缩短/ 了/ 迁移/ 总/ 时间/ ./ 其中/ ,/ 在/ 内存/ 更新/ 速率/ 最大/ 的/ Mem/ _/ stress/ 负载/ 下/ (/ 内存/ 更新/ 速率/ 被/ 设定/ 为/ 4096/ 页/ // s/ ,/ 即/ 16MB/ // s/ )/ ,/ 两种/ 机制/ 的/ 迁移/ 持续时间/ 差距/ 最大/ ./ 在/ 该/ 实验/ 中/ ,/ HybMEC/ 平均/ 复制/ 了/ 76684/ 个/ 内存/ 页面/ ,/ 其中/ 大约/ 有/ 5200/ 个/ 页面/ (/ 约/ 20.3/ MB/ )/ 经过/ 脏/ 页面/ 同步/ 二次/ 复制/ ;/ 而/ Pre/ -/ copy/ 在/ 完成/ 第一轮/ 内存/ 复制/ 后/ ,/ 即/ 近入/ 了/ 迭代/ 同步/ 过程/ 直至/ 剩余/ 脏/ 页面/ 数/ 小于/ 预设值/ 10/ ,/ 导致/ 总/ 迁移/ 时间/ 依赖于/ 剩余/ 脏/ 页面/ 收敛/ 速率/ 而/ 被/ 延长/ ./ 而/ 即使/ 在/ 最/ 理想/ 的/ idle/ 负载/ 实验/ 里/ ,/ Hyb/ -/ MEC/ 迁移/ 持续时间/ 仍/ 明显/ 小于/ Pre/ -/ copy/ 机制/ ./ 在/ 图/ 12/ 中/ ,/ 我们/ 看到/ 在/ 相同/ 的/ 负载/ 情况/ 下/ ,/ HybMEC/ 均/ 取得/ 了/ 更/ 小/ 的/ 停机/ 时间/ ./ 其中/ ,/ 在/ idle/ 负载/ 条件/ 下/ HybMEC/ 取得/ 了/ 最小/ 的/ VM/ 停机/ 时间/ ./ 其/ 原因/ 如前/ 文所/ 分析/ 的/ ,/ 由于/ idle/ 负载/ 的/ 内存/ 更新/ 速率/ 小于/ 其它/ 负载/ 情况/ ,/ 在/ 停机/ 阶段/ 剩余/ 的/ 脏/ 页面/ 数/ 也/ 少于/ 其它/ 负载/ ./ 这/ 也/ 使得/ HybMEC/ 在/ 停机/ 时间/ 内/ 设置/ 脏/ 页面/ 缺页/ 状态/ 的/ 执行/ 延时/ 相对/ 于/ 其它/ 应用/ 负载/ 要/ 小/ ./ 相反/ ,/ Pre/ -/ copy/ 机制/ 在/ 停机/ 时间/ 内/ 需要/ 复制/ 剩余/ 脏/ 内存/ 页/ 数据/ ,/ 并且/ 复制/ 的/ 页面/ 数/ 不/ 大于/ 预设/ 的/ 最小/ 剩余/ 脏/ 页面/ 数/ ./ 因此/ ,/ 虽然/ Pre/ -/ copy/ 在/ 4/ 种/ 负载/ 下/ 的/ 停机/ 时间/ 大致/ 相当/ ,/ 约/ 为/ 30ms/ ,/ 但是/ 仍/ 大于/ HybMEC4/ 种/ 负载/ 实验/ 中/ 的/ 12ms/ 平均/ 时间/ ./ 最后/ ,/ 在/ 图/ 13/ 中/ ,/ 我们/ 对比/ 两种/ 迁移/ 机制/ 在/ 4/ 种/ 类型/ 负载/ 下/ 的/ 内存/ 同步/ 数据量/ ./ 即使/ 是/ 理想/ 的/ idle/ 负载/ ,/ Pre/ -/ copy/ 迁移/ 的/ 内存/ 同步/ 数据量/ 仍然/ 是/ HybMEC/ 的/ 3.72/ 倍/ ./ 通过/ 上述/ 4/ 种/ 不同/ 类型/ 负载/ 下/ 的/ 迁移/ 实验/ 对比/ ,/ 我们/ 不难/ 发现/ HybMEC/ 在/ 减少/ 迁移/ 同步/ 数据量/ 、/ 缩短/ 总/ 迁移/ 时间/ 以及/ 减小/ VM/ 应用/ 性能/ 损失/ 等/ 方面/ 明显/ 好于/ 现有/ Pre/ -/ copy/ 机制/ ./ 同时/ ,/ 实验/ 结果/ 从/ 另/ 一个/ 侧面/ 验证/ 了/ Pre/ -/ copy/ 机制/ 对于/ 访存/ 密集/ Page12/ 型/ 负载/ 的/ 低效/ 性/ 和/ 不/ 适用性/ ./ 同比/ 于/ 其它/ 3/ 种/ 类型/ 负载/ ,/ Pre/ -/ copy/ 机制/ 在/ 内存/ 压力/ 负载/ 的/ 实验/ 中/ 各/ 方面/ 的/ 迁移/ 性能/ 均/ 取得/ 最差/ 结果/ ./ 对/ 剩余/ 脏/ 内存/ 收敛/ 速率/ 的/ 过分/ 依赖/ 是/ 造成/ 该/ 结果/ 的/ 根本原因/ ./ 但是/ ,/ Hyb/ -/ MEC/ 通过/ 内存/ 混合/ 复制/ 方式/ 以及/ 页面/ 数据/ 复制/ 优化/ ,/ 大幅/ 地/ 减小/ 了/ 由于/ VM/ 内存/ 频繁/ 更新/ 所/ 造成/ 的/ 各/ 方面/ 迁移/ 性能/ 下降/ ./ 同时/ ,/ HybMEC/ 在/ 复制/ 页面/ 时/ 对于/ 空闲/ 页/ 的/ 优化/ 处理/ ,/ 大幅度/ 地/ 削减/ 了/ 内存/ 同步/ 数据量/ ,/ 并/ 提升/ 了/ VM/ 状态/ 迁移/ 的/ 整体/ 速度/ ./ 5/ 相关/ 工作/ 最早/ 由/ Clark/ 等/ 人/ [/ 5/ -/ 6/ ]/ 提出/ 并/ 实现/ 的/ 基于/ 内存/ 预/ 拷贝/ (/ Pre/ -/ copy/ )/ 方式/ 的/ VM/ 在线/ 迁移/ 机制/ ,/ 将/ 恢复/ VM/ 在/ 目的/ 宿主机/ 上/ 的/ 运行/ 推迟/ 在/ 内存/ 一致性/ 状态/ 同步/ 完成/ 之后/ ./ 其中/ ,/ 内存/ 状态/ 需要/ 通过/ 多轮/ 的/ 脏/ 内存/ 复制/ 实现/ 同步/ ./ 目前/ ,/ Xen/ [/ 3/ ]/ 、/ VMware/ [/ 5/ ]/ 及/ KVM/ [/ 9/ ]/ 等/ 主流/ 系统/ 虚拟化/ 平台/ 上均/ 提供/ 了/ 对于/ 该/ 机制/ 的/ 实现/ ,/ 并/ 广泛应用/ 于/ 局域网/ 环境/ 中/ 跨/ 物理/ 机/ 的/ VM/ 快速/ 迁移/ ./ 由于/ 需要/ 经过/ 多轮/ 迭代/ 复制/ 才能/ 实现/ 迁移/ 目的/ 端/ 对/ VM/ 内存/ 状态/ 的/ 一致性/ 备份/ ,/ 而/ 机制/ 本身/ 不能/ 控制/ 或/ 预测/ 迁移/ 过程/ 中/ VM/ 内存/ 更新/ 速率/ ,/ 因此/ Pre/ -/ copy/ 机制/ 存在/ 内存/ 同步/ 的/ 收敛性/ 问题/ [/ 15/ ]/ ./ 该/ 问题/ 是/ 指当/ 网络/ 传输速率/ 小于/ VM/ 修改/ 其/ 内存/ 的/ 速率/ 时/ ,/ 内存/ 状态/ 的/ 迭代/ 复制/ 过程/ 由于/ 不/ 满足/ 最少/ 剩余/ 脏/ 页面/ 数而/ 不能/ 主动/ 停止/ ./ 目前/ ,/ 解决/ 上述/ 问题/ 的/ 普遍/ 方法/ 是/ 通过/ 预设/ 定/ 最大/ 迭代/ 次数/ 或/ 数据传输/ 量/ ,/ 约束/ 迁移/ 过程/ 中/ 内存/ 状态/ 的/ 迭代/ 复制/ ./ 但是/ ,/ 对于/ 具有/ 大/ 内存/ 或/ 访存/ 密集型/ 应用/ 的/ VM/ ,/ 在/ 停机/ 阶段/ 里/ 大量/ 剩余/ 脏/ 内存/ 数据/ 等待/ 复制/ ,/ 延缓/ 了/ VM/ 在/ 目的/ 宿主机/ 上/ 的/ 恢复/ 运行/ ,/ 这/ 势必/ 延长/ 了/ VM/ 停机/ 时间/ ,/ 并/ 影响/ VM/ 在/ 迁移/ 过程/ 中/ 的/ 外部/ 可/ 访问/ 性/ ./ 类似/ 的/ ,/ 在/ 低速/ 网络/ 环境/ 中/ 执行/ VM/ 在线/ 迁移/ 时/ ,/ Pre/ -/ copy/ 机制/ 也/ 可能/ 遇到/ 上述/ 的/ 收敛性/ 问题/ ./ 另外/ ,/ Pre/ -/ copy/ 机制/ 的/ 内存/ 迭代/ 复制/ 还/ 造成/ 了/ 迁移/ 数据/ 的/ 高/ 冗余/ 性/ ,/ 导致/ 了/ 迁移/ 过程/ 对/ 物理/ 资源/ 的/ 不合理/ 消耗/ ./ 最近/ ,/ 在/ 一些/ 研究/ 中/ 提出/ 利用/ 内存/ 压缩/ [/ 16/ -/ 17/ ]/ 或/ 消除/ 内存/ 冗余/ 数据/ [/ 18/ ]/ 等/ 方法/ 减小/ 迁移/ 数据量/ ./ 但是/ ,/ 这些/ 方法/ 仍以/ Pre/ -/ copy/ 迁移/ 机制/ 作为/ 性能/ 优化/ 前提/ ,/ 本质/ 上/ 没有/ 脱离/ 两/ 阶段/ 迁移/ 基本模式/ ,/ 也/ 没有/ 从根本上/ 消除/ 迁移/ 过程/ 对/ 内存/ 迭代/ 同步/ 的/ 依赖/ ./ 此外/ ,/ 压缩算法/ 的/ 引入/ 势必会/ 造成/ 迁移/ 过程/ 对/ 宿主机/ CPU/ 资源/ 额外/ 的/ 消耗/ ./ 基于/ 内存/ 后/ 拷贝/ (/ Post/ -/ copy/ )/ 方式/ 的/ VM/ 在线/ 迁移/ 机制/ [/ 15/ ,/ 19/ ]/ ,/ 将/ 内存/ 的/ 同步/ 过程/ 推迟/ 到/ VM/ 在/ 目的/ 宿主机/ 上/ 恢复/ 运行/ 之后/ ./ 迁移/ 过程/ 首先/ 在/ 两端/ 宿主机/ 之间/ 同步/ VM/ 的/ VCPU/ 以及/ 除/ 内存/ 外/ 的/ 虚拟/ 设备/ 的/ 状态/ ,/ 接着/ 立即/ 在/ 目的/ 宿主机/ 上/ 恢复/ VM/ 执行/ ./ 随后/ ,/ VM/ 内存/ 数据/ 则/ 通过/ 目的/ 宿主机/ 按/ 需取/ 页/ 的/ 方式/ 实现/ 同步/ ./ Post/ -/ copy/ 机制/ 中/ VM/ 在/ 目的/ 宿主机/ 上/ 的/ 恢复/ 执行/ 先于/ 内存/ 状态/ 同步/ ,/ 所以/ 在/ VM/ 恢复/ 执行/ 的/ 时刻/ ,/ 只有/ 源/ 宿主机/ 拥有/ 完整/ 的/ VM/ 内存/ 状态/ ./ Post/ -/ copy/ 机制/ 能够/ 保证/ 在/ 迁移/ 过程/ 中/ 每/ 一个/ 内存/ 页/ 至多/ 被/ 复制/ 一次/ ./ 因此/ ,/ 该/ 机制/ 从根本上/ 避免/ 了/ 冗余/ 数据/ 对/ 网络带宽/ 的/ 不必要/ 的/ 占用/ ./ 然而/ ,/ VM/ 切换/ 至/ 目的/ 宿主机/ 上/ 运行/ ,/ 并/ 访问/ 一个/ 未/ 同步/ 的/ 内存/ 页面/ 时/ ,/ Post/ -/ copy/ 机制/ 被迫/ 中断/ VM/ 正常/ 运行/ ,/ 通过/ 网络/ 缺页/ 处理/ 及时/ 地/ 解决/ 该/ 页面/ 的/ 加载/ 问题/ ./ 虽然/ ,/ 类似/ HybMEC/ 采用/ 的/ 预取/ 页/ 机制/ 能够/ 帮助/ Post/ -/ copy/ 机制/ 减少/ 网络/ 缺页/ 处理/ 的/ 次数/ ,/ 但是/ ,/ 由于/ 驻留/ 在/ 源/ 宿主机/ 上/ 的/ 内存/ 页面/ 数/ 远大于/ HybMEC/ 中/ 的/ 脏/ 页面/ 数/ ,/ Post/ -/ copy/ 机制/ 仍/ 无法/ 避免/ 频繁/ 的/ 按/ 需/ 加载/ 内存/ 页/ 所/ 造成/ 的/ VM/ 性能/ 下降/ 以及/ 内部/ 应用/ 执行/ 延时/ 的/ 上升/ ./ 此外/ ,/ 上述/ 工作/ 在/ 实现/ 上/ 未能/ 很/ 好/ 地/ 满足/ 在线/ 迁移/ 机制/ 的/ 透明性/ 要求/ ./ Hines/ 等/ 人/ [/ 15/ ]/ 的/ 工作/ 需要/ 分别/ 修改/ 客户/ OS/ 以及/ 宿主机/ OS/ 的/ 内核/ 以/ 实现/ 动态内存/ 气泡/ 回收/ 和/ 内存/ 页面/ 的/ 按/ 需/ 加载/ ./ 因此/ ,/ 该/ 方法/ 中/ 预先/ 正确/ 配置/ 客户/ OS/ 以及/ 宿主机/ OS/ 是/ VM/ 能够/ 执行/ Post/ -/ copy/ 迁移/ 的/ 前提/ ./ Hirofuchi/ [/ 19/ ]/ 在/ 工作/ 中/ ,/ 网络/ 缺页/ 处理/ 需要/ 通过/ 除/ QEMU/ 进程/ 以及/ KVM/ 内核模块/ 外/ 的/ 辅助/ 用户/ 态/ 进程/ 和/ 内核模块/ 完成/ ./ 由于/ 辅助/ 进程/ 在/ 启动/ 时即/ 严格/ 绑定/ 与/ VM/ 内存/ 映射/ 关系/ ,/ 因此/ 在/ VM/ 执行/ 在线/ 迁移/ 的/ 前后/ ,/ 该/ 辅助/ 进程/ 不能/ 由/ KVM/ 控制/ 启动/ 或/ 停止/ ,/ 而/ 需要/ 通过/ 手动/ 控制/ ./ 最近/ ,/ VM/ 动态/ 克隆/ 系统/ SnowFlock/ [/ 20/ ]/ 利用/ 了/ 与/ Post/ -/ copy/ 机制/ 类似/ 的/ VM/ 内存/ 加载/ 方式/ ./ 当/ 开始/ 执行/ 克隆/ 操作/ 时/ ,/ 原/ VM/ 的/ VCPU/ 及/ 虚拟/ 设备/ 的/ 状态/ 被/ 迅速/ 复制到/ 目标/ 宿主机/ 上/ ;/ 接着/ ,/ 原/ VM/ 和/ 克隆/ VM/ 各自/ 恢复/ 执行/ ,/ 并且/ 分别/ 按照/ “/ 写时/ 复制/ ”/ 和/ “/ 按/ 需/ 加载/ ”/ 方式/ 处理/ 内存/ 访问/ ./ 当/ 克隆/ VM/ 访问/ 未/ 加载/ 的/ 内存/ 页/ 时/ ,/ VMM/ 通过/ 网络/ 缺页/ 处理/ 从原/ VM/ 复制/ 页面/ 数据/ ./ 但是/ ,/ 通过/ HybMEC/ 的/ 工作/ 我们/ 有/ 理由/ 相信/ ,/ 仅/ 依靠/ “/ 按/ 需/ 加载/ ”/ 处理/ 克隆/ VM/ 对/ 内存/ 页/ 的/ 缺页/ 访问/ ,/ SnowFlock/ 很难/ 保证/ 克隆/ VM/ 内部/ 应用/ 的/ 执行/ 性能/ 和/ 效率/ ./ 此外/ ,/ SnowFlock/ 在/ 实现/ 上/ 同样/ 需要/ 修改/ Xen/ 及/ Linux/ 客户/ OS/ 以/ 实现/ VMM/ 对/ VM/ 访存/ 的/ 捕获/ 和/ 内存/ 页面/ 的/ 网络/ 加载/ ./ 另/ Page13/ 外/ ,/ 与/ VM/ 在线/ 迁移/ 工作/ 类似/ ,/ VM/ 快照/ 恢复/ 同样/ 需要/ 解决/ VM/ 内存/ 页/ 加载/ 的/ 问题/ ,/ 区别/ 在于/ 后者/ 的/ 内存/ 数据/ 从/ 本地/ 或/ 网络/ 磁盘/ 上/ 的/ 快照/ 文件/ 中/ 加载/ ./ Zhang/ 等/ 人/ [/ 21/ ]/ 提出/ 利用/ “/ 懒/ 恢复/ ”/ (/ lazilyrestoring/ )/ 机制/ 实现/ 对/ VM/ 内存/ 快照/ 的/ 快速/ 加载/ ,/ 即/ VM/ 快照/ 恢复/ 的/ 初始/ 阶段/ ,/ 预先/ 加载/ 内存/ 工作/ 集/ (/ workingset/ )/ 中/ 的/ 内存/ 页面/ ./ 该/ 工作/ 更多地/ 关注/ 执行/ VM/ 快照/ 过程/ 对/ 内存/ 工作/ 集/ 的/ 跟踪/ 以及/ 内存/ 工作/ 集中/ 页面/ 数据/ 的/ 存储/ ./ 与/ HybMEC/ 类似/ ,/ 该/ 工作/ 中/ 利用/ 了/ 内存/ 硬件/ 辅助/ 虚拟化/ 技术/ ,/ 以/ 实现/ VM/ 内存/ 访问/ 跟踪/ ./ 6/ 结论/ 与/ 下/ 一步/ 工作/ 虚拟机/ 技术/ 充分利用/ 复用/ 单个/ 物理/ 机/ 资源/ 的/ 优势/ ,/ 结合/ 其/ 灵活性/ 、/ 封装/ 性/ ,/ 实现/ 了/ 物理/ 资源/ 的/ 高度/ 共享/ 、/ 资源/ 利用率/ 的/ 显著/ 提升/ 以及/ 软件应用/ 的/ 灵活/ 部署/ ./ 而/ VM/ 在线/ 迁移/ 技术/ 更是/ 充分利用/ VM/ 技术/ 的/ 封装/ 性/ 和/ 灵活性/ ,/ 实现/ 了/ VM/ 运行/ 状态/ 通过/ 计算机网络/ 在/ 物理/ 机/ 之间/ 的/ 快速/ 迁移/ ./ 通过/ 结合/ 源/ 宿主机/ 复制/ 推送/ 和/ 目的/ 宿主机/ 按/ 需/ 复制/ 两种/ 方式/ ,/ 本文/ 提出/ 了/ 基于/ 内存/ 混合/ 复制/ 方式/ 的/ VM/ 在线/ 迁移/ 机制/ HybMEC/ ./ 在/ 实现/ 上/ ,/ HybMEC/ 不/ 需要/ 修改/ 或/ 重新/ 编译/ 客户机/ 操作系统/ 内核/ ,/ 对/ 客户机/ 操作系统/ 及其/ 应用程序/ 完全/ 透明/ ./ 本文/ 的/ 基本/ 思想/ 是/ :/ 利用/ 源/ 宿主机/ 主动/ 推送/ 的/ 方式/ 完成/ 绝大多数/ 的/ 内存/ 数据/ 的/ 一次性/ 复制/ ;/ 而/ 将/ 少数/ 状态/ 不/ 一致/ 的/ 脏/ 内存/ 数据/ 推迟/ 到/ VM/ 在/ 目的/ 宿主机/ 上/ 恢复/ 执行/ 之后/ ,/ 通过/ 按/ 需/ 复制/ 或/ 定时/ 推送/ 的/ 方式/ 实现/ 同步/ ./ 相对/ 于/ 已有/ 的/ 迁移/ 机制/ ,/ 由于/ 不/ 依赖于/ 内存/ 轮/ 迭代/ 同步/ ,/ HybMEC/ 能够/ 大幅度/ 地/ 减少/ 迁移/ 过程/ 中/ 的/ 同步/ 数据量/ ,/ 并/ 缩短/ 总/ 迁移/ 时间/ ./ 同时/ ,/ 在/ VM/ 停机/ 时间/ 内/ ,/ HybMEC/ 不/ 需要/ 复制/ 剩余/ 脏/ 页面/ 数据/ ,/ 从而/ 有效/ 地/ 缩短/ 了/ VM/ 停机/ 造成/ 的/ 不可/ 访问/ 时间/ ./ 为了/ 进一步/ 优化/ 迁移/ 性能/ ,/ 本文/ 还/ 对/ 内存/ 页/ 数据/ 的/ 复制/ 做/ 了/ 重要/ 的/ 优化/ ,/ 例如/ 采用/ 预取/ 页/ 机制/ 以/ 减少/ 脏/ 内存/ 按/ 需/ 复制/ 造成/ 的/ VM/ 性能/ 损失/ ,/ 采用/ 定时/ 推送/ 机制/ 以/ 缩短/ 脏/ 内存/ 同步/ 过程/ 的/ 持续时间/ ,/ 以及/ 禁止/ 空闲/ 脏/ 页面/ 引发/ 网络/ 缺页/ 处理/ 以/ 避免/ VM/ 运行/ 状态/ 发生/ 不必要/ 的/ 状态/ 切换/ ./ 基于/ KVM/ 上/ ,/ 我们/ 设计/ 并/ 实现/ 了/ HybMEC/ 原型/ 系统/ ,/ 并/ 通过/ 多种不同/ 类型/ 的/ 应用/ 负载/ 验证/ 了/ HybMEC/ 机制/ 的/ 高效性/ 和/ 可用性/ ./ 实验/ 结果表明/ ,/ 即使/ 对于/ 访存/ 密集型/ 应用/ ,/ HybMEC/ 也/ 能够/ 保证/ 更/ 短/ 的/ VM/ 停机/ 时间/ 以及/ 总/ 迁移/ 时间/ ,/ 缩短/ 迁移/ 过程/ 对源/ 宿主机/ 的/ 长时间/ 依赖/ ./ 同时/ ,/ HybMEC/ 极大/ 地/ 降低/ 了/ 迁移/ 过程同步/ 数据量/ ,/ 减少/ 了/ 迁移/ 过程/ 本身/ 对/ 物理/ 资源/ 的/ 占用/ ./ 当/ VM/ 在/ 目的/ 宿主机/ 上/ 恢复/ 执行/ 后/ ,/ HybMEC/ 迁移/ 过程/ 开始/ 进入/ 脏/ 页面/ 同步/ 阶段/ ./ 在/ 此/ 阶段/ 中/ ,/ VM/ 的/ 完整/ 状态/ 需要/ 由源/ 和/ 目的/ 宿主机/ 共同/ 维护/ :/ 源/ 宿主机/ 拥有/ 正确/ 的/ 脏/ 内存/ 状态/ ;/ 而/ 目的/ 宿主机/ 拥有/ VM/ 当前/ VCPU/ 、/ 部分/ 内存/ 以及/ 其它/ 虚拟/ 设备/ 的/ 状态/ ./ 因此/ ,/ 在/ 该/ 阶段/ 中源/ 或/ 目的/ 宿主机/ 的/ 宕机/ 不但/ 会/ 导致/ VM/ 迁移/ 过程/ 失败/ ,/ 而且/ 还会/ 造成/ VM/ 运行/ 状态/ 的/ 丢失/ ./ 因此/ ,/ HybMEC/ 如何/ 保证/ 上述/ 阶段/ 中/ 的/ 迁移/ 可靠性/ 将/ 成为/ 我们/ 下/ 一步/ 即将/ 开展/ 的/ 重要/ 工作/ ./ 

