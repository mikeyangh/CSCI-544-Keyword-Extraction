Page1/ 基于/ 可验证/ 计算/ 的/ 可信/ 云/ 计算/ 研究/ 1/ )/ (/ 北京邮电大学/ 计算机/ 学院/ 北京/ 100876/ )/ 2/ )/ (/ 北京邮电大学/ 软件/ 学院/ 北京/ 100876/ )/ 3/ )/ (/ 北京邮电大学/ 可信/ 分布式计算/ 与/ 服务/ 教育部/ 重点/ 实验室/ 北京/ 100876/ )/ 摘要/ 云/ 计算/ 的/ 可信性/ 直接/ 决定/ 了/ 其/ 能否/ 被/ 广泛/ 使用/ 和/ 推广/ ./ 如果/ 能/ 使得/ 云/ 计算/ 用户/ 验证/ 存储/ 在/ 云/ 平台/ 的/ 数据/ 的/ 完整性/ 或者/ 在/ 云/ 平台/ 执行/ 的/ 程序/ 的/ 正确性/ ,/ 将会/ 大大/ 加快/ 云/ 计算/ 的/ 应用/ ./ 而/ 可验证/ 计算/ 协议/ 可/ 检测/ 出/ 远程/ 服务器返回/ 的/ 程序执行/ 结果/ 是否/ 正确/ ,/ 且/ 不/ 需要/ 将/ 远程/ 服务器/ 所/ 执行/ 的/ 程序/ 再/ 重新/ 执行/ 一遍/ ./ 因此/ ,/ 近年来/ ,/ 可验证/ 计算/ 协议/ 引起/ 了/ 学术界/ 和/ 工业界/ 的/ 广泛/ 关注/ ,/ 成为/ 实现/ 可信/ 云/ 计算/ 的/ 一种/ 建设性/ 思路/ ./ 文中/ 在/ 系统/ 梳理/ 和/ 总结/ 可验证/ 计算/ 协议/ 国内外/ 相关/ 研究/ 的/ 基础/ 上/ ,/ 依据/ 可验证/ 计算/ 协议/ 的/ 实施/ 流程/ 对/ 其/ 按照/ 编译/ 处理/ 和/ 证明/ 系统分类/ ./ 其中/ ,/ 依据/ 可验证/ 计算/ 协议/ 使用/ 的/ 编译器/ 的/ 复杂程度/ ,/ 分为/ 使用/ 简单/ 编译器/ 的/ 可验证/ 计算/ 协议/ 和/ 使用/ 复杂/ 编译器/ 的/ 可验证/ 计算/ 协议/ ;/ 依据/ 证明/ 系统/ 的/ 分类/ ,/ 主要/ 研究/ 基于/ 交互式/ 证明/ 系统/ 的/ 可验证/ 计算/ 协议/ 和/ 基于/ 论证/ 系统/ 的/ 有/ 预处理/ 的/ 可验证/ 计算/ 协议/ ./ 随后/ 对/ 依据/ 证明/ 系统/ 划分/ 的/ 每/ 一/ 分类/ ,/ 围绕/ 基本/ 定义/ 、/ 典型/ 协议/ 原理/ 及/ 流程/ 、/ 适用/ 应用/ 场景/ 、/ 性能/ 分析/ 等/ 问题/ ,/ 对/ 基于/ 可验证/ 计算/ 的/ 可信/ 云/ 计算/ 进行/ 了/ 综述/ ./ 最后/ ,/ 总结/ 和/ 展望/ 了/ 待/ 解决/ 的/ 关键性/ 问题/ 和/ 未来/ 的/ 研究/ 方向/ ./ 上述/ 工作/ 将/ 对/ 可验证/ 计算/ 协议/ 在/ 云/ 计算/ 中/ 的/ 应用/ 起到/ 一定/ 推动/ 作用/ ./ 关键词/ 云/ 计算/ ;/ 可验证/ 计算/ ;/ 云/ 安全/ ;/ 交互式/ 证明/ 系统/ ;/ 论证/ 系统/ 1/ 引言/ 云/ 计算/ [/ 1/ ]/ 作为/ 一种/ 新兴/ 的/ 网络/ 计算/ 商业/ 服务/ 模式/ ,/ 使得/ 用户/ 可以/ 随时/ 在/ 远/ 端的/ 云/ 服务器/ 存储/ 数据/ 和/ 运行/ 程序/ ./ 但/ 这种/ 新兴/ 的/ 计算/ 模式/ 在/ 给/ 用户/ 带来/ 诸多/ 便利性/ 的/ 同时/ ,/ 也/ 带来/ 了/ 一些/ 新/ 的/ 安全/ 挑战/ ./ 用户/ 可能/ 担心/ 云/ 计算/ 平台/ 本身/ 的/ 安全性/ ,/ 比如/ 云/ 平台/ 漏洞/ 和/ 错误/ 配置/ 、/ 管理员/ 的/ 恶意/ 行为/ 等等/ ,/ 而/ 这/ 都/ 可能/ 直接/ 导致用户/ 数据/ 的/ 完整性/ 和/ 隐私/ 性/ 受到/ 危害/ ,/ 导致用户/ 应用程序/ 无法/ 正确/ 执行/ [/ 2/ -/ 3/ ]/ ./ 这/ 就/ 产生/ 了/ 一个/ 问题/ :/ 用户/ 如何/ 相信/ 云/ 提供商/ 执行/ 的/ 程序/ 结果/ 是/ 正确/ 的/ ?/ 如何/ 确保/ 存储/ 在/ 远/ 端的/ 数据/ 的/ 完整性/ 和/ 私密性/ ?/ 检测/ 远程/ 服务器返回/ 的/ 结果/ 是否/ 正确/ 的/ 传统/ 解决方案/ 有/ 以下/ 几种/ :/ (/ 1/ )/ 采用/ 审计/ 的/ 方法/ ,/ 即/ 随机/ 选取/ 服务器/ 执行/ 的/ 一小部分/ 程序/ 进行/ 验证/ ,/ 这/ 就/ 可能/ 发生/ 错误/ 执行/ 的/ 程序/ 没有/ 被/ 服务器/ 验证/ 的/ 情况/ ,/ 所以/ 说/ 这种/ 方法/ 必须/ 假设/ 错误/ 执行/ 的/ 程序/ 的/ 发生/ 频率/ 是/ 很小/ 的/ ;/ (/ 2/ )/ 利用/ 可信/ 硬件/ [/ 4/ -/ 5/ ]/ 和/ 远程/ 证明/ [/ 6/ -/ 7/ ]/ 来/ 保证/ 远程/ 服务器/ 运行/ 的/ 程序/ 是/ 正确/ 的/ ,/ 但是/ 这种/ 方法/ 必须/ 假设/ 云/ 提供商/ 是/ 完全/ 可信/ 的/ ,/ 由于/ 硬件/ 基础设施/ 是/ 在/ 云/ 提供商/ 的/ 控制/ 之下/ ,/ 如果/ 云/ 提供商/ 内部人员/ 恶意/ 控制/ 了/ 可信/ 硬件/ (/ 如/ CPU/ 、/ TPM/ )/ ,/ 就/ 无法/ 保障/ 云/ 提供商/ 运行/ 的/ 程序/ 的/ 机密性/ 和/ 可验证/ 性/ ./ 而且/ 还/ 需要/ 假设/ 存在/ 一个/ 可信/ 链/ ,/ 而/ 运行/ 时/ 可信/ 链/ 的/ 建立/ 在/ 可信计算/ 领域/ 依然/ 是/ 一个/ 难题/ ./ 事实上/ ,/ 在/ 实际/ 的/ 云/ 计算/ 应用/ 场景/ 中/ 这/ 两个/ 假设/ 通常/ 是/ 无法/ 满足/ 的/ ./ 在/ 云/ 计算/ 场景/ 中/ ,/ 用户/ 无法/ 完全/ 相信/ 云/ 提供商/ ,/ 即使/ 用户/ 出于/ 声誉/ 的/ 考虑/ 相信/ 云/ 提供商/ 本身/ ,/ 也/ 无法/ 相信/ 其/ 内部/ 管理人员/ ;/ (/ 3/ )/ 采用/ 冗余/ 计算/ 的/ 方法/ ,/ 用户/ 可以/ 让/ 多个/ 远程/ 服务器/ 把/ 相同/ 的/ 程序执行/ 多次/ ,/ 然后/ 检测/ 他们/ 返回/ 的/ 结果/ 是否/ 一致/ [/ 8/ -/ 12/ ]/ ./ 但/ 这/ 在/ 云/ 计算/ 中/ 也/ 是/ 行不通/ 的/ ,/ 云/ 计算/ 中/ 的/ 软硬件/ 平台/ 配置/ 通常/ 是/ 相同/ 的/ ,/ 而/ 这/ 违背/ 了/ 冗余/ 计算/ 中/ 错误/ 必须/ Page3/ 是/ 不/ 相关/ 的/ 假设/ ,/ 且/ 远程/ 服务器/ 很/ 容易/ 窜通/ ,/ 合谋/ 返回/ 一个/ 错误/ 的/ 程序执行/ 结果/ ./ 而/ 可/ 证明/ 数据/ 持有/ [/ 13/ ]/ (/ ProvableDataPossession/ ,/ PDP/ )/ 方法/ 和/ 可/ 恢复/ 证明/ [/ 14/ ]/ (/ ProofofRetrievability/ ,/ POR/ )/ 方法/ 可以/ 用来/ 确保/ 存储/ 在/ 远/ 端的/ 数据/ 的/ 完整性/ ,/ 避免/ 云/ 提供商/ 删除/ 和/ 篡改/ 数据/ ./ 相比/ PDP/ 方法/ ,/ POR/ 除了/ 能/ 确保/ 数据/ 的/ 完整性/ 之外/ ,/ 还/ 能/ 确保/ 数据/ 的/ 可/ 恢复性/ ,/ 但是/ PDP/ 和/ POR/ 无法/ 确保/ 在/ 云/ 提供商/ 端/ 执行/ 的/ 程序/ 的/ 正确性/ ./ 另一方面/ ,/ 基于/ 复杂性/ 理论/ 的/ 交互式/ 证明/ 系统/ (/ InteractiveProofsystem/ ,/ IPs/ )/ [/ 15/ -/ 19/ ]/ 和/ 概率/ 可验证/ 证明/ 系统/ (/ ProbabilisticallyCheckableProofsystem/ ,/ PCPs/ )/ [/ 20/ -/ 23/ ]/ 以及/ 密码学/ 理论/ [/ 24/ -/ 29/ ]/ 构造/ 的/ 可验证/ 计算/ 协议/ 能以/ 很/ 高/ 的/ 正确率/ 检测/ 出/ 远程/ 服务器返回/ 的/ 程序执行/ 结果/ 是否/ 正确/ 并且/ 不/ 需要/ 对/ 远程/ 服务器/ (/ 云/ 提供商/ )/ 做/ 任何/ 假设/ ./ 可验证/ 计算/ 协议/ 致力于/ 设计/ 验证/ 者/ 与/ 证明/ 者/ 之间/ 的/ 协议/ ,/ 协议/ 允许/ 在/ 计算能力/ 上/ 相对/ 较弱/ 的/ 验证/ 者/ (/ 如云/ 计算/ 中/ 的/ 用户/ )/ 将/ 其/ 程序/ 发送到/ 一个/ 计算能力/ 强大/ 的/ ,/ 但/ 不可/ 信/ 的/ 证明/ 者/ (/ 例如/ 云/ 提供商/ )/ ,/ 并/ 要求/ 证明/ 者/ 执行/ 其/ 发送/ 的/ 程序/ ./ 所/ 设计/ 的/ 协议/ 应/ 确保/ 证明/ 者/ 不但/ 返回/ 程序/ 的/ 执行/ 结果/ 给/ 验证/ 者/ ,/ 并且/ 使得/ 验证/ 者/ 相信/ 这个/ 程序执行/ 结果/ 是/ 正确/ 的/ ./ 其/ 主要/ 目标/ 是/ 使得/ 服务器/ 在/ 发送/ 程序执行/ 结果/ 的/ 同时/ 提供/ 程序/ 正确/ 执行/ 的/ 证据/ ,/ 而/ 用户/ 验证/ 证据/ 的/ 过程/ 必须/ 要/ 比/ 用户/ 自己/ 执行程序/ 的/ 开销/ 小/ (/ 当然/ 有时/ 由于/ 资源/ 比如/ 存储/ 的/ 限制/ ,/ 用户/ 根本无法/ 自己/ 执行程序/ ,/ 在/ 这种/ 情况/ 下/ 是/ 指/ 和/ 假设/ 用户/ 有/ 足够/ 的/ 资源/ 执行程序/ 时/ 的/ 开销/ 相比/ 要/ 小/ )/ ./ 近年来/ ,/ 由于/ 云/ 计算/ 的/ 兴起/ 和/ 复杂性/ 相关/ 理论/ 以及/ 密码学/ 理论/ 的/ 进一步/ 发展/ ,/ 可验证/ 计算/ 协议/ 的/ 研究/ 重新/ 受到/ 了/ 关注/ ./ Ishai/ 等/ 人/ [/ 30/ ]/ 阐述/ 了/ 如何/ 使用/ 简单/ 的/ PCPs/ 和/ 密码学/ 承诺/ 来/ 验证/ 通用/ 计算/ ;/ Goldwasser/ 等/ 人/ [/ 18/ ]/ 把/ 交互式/ 证明/ 系统/ 应用/ 于用/ 特定/ 电路/ 表示/ 的/ 计算/ 中/ ;/ Gentry/ 等/ 人/ [/ 31/ -/ 32/ ]/ 在/ 全/ 同态/ 加密/ 领域/ 的/ 突破性/ 研究/ 使得/ 起源于/ GGP/ 的/ 通用/ 计算/ 的/ 非/ 交互式/ 协议/ 的/ 构造/ 有/ 了/ 理论依据/ [/ 22/ ,/ 25/ ]/ ./ 这些/ 研究/ 具有/ 重大意义/ ,/ 基于/ 这些/ 理论/ 的/ 改进/ 使得/ 可验证/ 计算/ 协议/ 最终/ 得以/ 适用/ 于/ 某些/ 特殊/ 构造/ 的/ 应用/ 场景/ ,/ 但是/ 仍然/ 无法/ 适用/ 于/ 通用/ 的/ 云/ 计算/ 场景/ ./ 然而/ 可验证/ 计算/ 协议/ 领域/ 的/ 工作/ 目前/ 进展/ 很快/ ,/ 相信/ 在/ 不久/ 的/ 未来/ 将/ 可以/ 应用/ 于云/ 计算/ 的/ 实际/ 场景/ 中/ ./ 目前/ 使用/ 可验证/ 计算/ 的/ 思路/ 和/ 方法/ 来/ 构建/ 可信/ 云/ 计算/ ,/ 解决/ 云/ 计算/ 中/ 所有权/ 和/ 管理权/ 分离/ 所/ 带来/ 的/ 信任/ 问题/ 的/ 工作/ 还/ 很少/ ./ 所以/ 本文/ 的/ 主要/ 贡献/ 是/ 系统/ 的/ 梳理/ 和/ 总结/ 可验证/ 计算/ 协议/ 领域/ 的/ 工作/ ./ 出于/ 本文/ 的/ 研究/ 目的/ ,/ 更/ 关注/ 适用/ 于/ 构建/ 可信/ 云/ 计算/ 的/ 可验证/ 计算/ 协议/ 或者/ 对/ 可信/ 云/ 计算/ 的/ 构建/ 提供/ 建设性/ 思路/ 的/ 可验证/ 计算/ 协议/ ;/ 关注/ 性能/ 合理/ 的/ ,/ 适用/ 于/ 通用/ 场景/ 的/ ,/ 和/ 无条件/ 的/ (/ 即/ 除了/ 相关/ 的/ 密码学/ 协议/ 假设/ 不/ 做/ 任何/ 假设/ )/ 可验证/ 计算/ 协议/ ;/ 关注/ 只/ 需要/ 一个/ 证明/ 者/ ,/ 并/ 试图/ 将/ 理论/ 付诸实践/ 的/ 协议/ ./ 不/ 关注/ 基于/ 特定/ 计算/ 的/ 可验证/ 计算/ 协议/ [/ 32/ ,/ 34/ -/ 41/ ]/ ,/ 不/ 关注/ 基于/ 多个/ 证明/ 者/ 的/ 可验证/ 计算/ 协议/ [/ 33/ ]/ ,/ 不/ 关注/ 应用/ 同态/ 加密/ 的/ 可验证/ 计算/ 协议/ ,/ 因为/ 同态/ 加密/ 目前/ 还/ 无法/ 适用/ 于/ 实际/ 场景/ ./ 接下来/ 的/ 章节/ 中/ ,/ 本文/ 首先/ 介绍/ 可验证/ 计算/ 协议/ 的/ 问题/ 描述/ 和/ 设计/ 原则/ ,/ 接着/ 介绍/ 如何/ 生成/ 协议/ 需要/ 的/ 计算/ 模型/ ,/ 然后/ 依据/ 可验证/ 计算/ 协议/ 的/ 协议/ 流程/ 分别/ 对/ 目前/ 的/ 协议/ 做出/ 分类/ ,/ 之后/ 详细/ 说明/ 每个/ 分类/ 的/ 进展/ 情况/ ./ 最后/ ,/ 总结/ 和/ 展望/ 该/ 领域/ 目前/ 存在/ 的/ 问题/ 和/ 未来/ 的/ 研究/ 方向/ ,/ 以期/ 对/ 其/ 在/ 国内/ 的/ 研究/ 起到/ 一定/ 推动/ 作用/ ./ 2/ 问题/ 描述/ 和/ 协议/ 设计/ 原则/ 问题/ 描述/ :/ 验证/ 者/ V/ 把/ 程序/ f/ 和/ 输入/ 变量/ 狓/ 发送给/ 证明/ 者/ P/ ,/ P/ 计算/ f/ (/ 狓/ )/ ,/ 并/ 把/ f/ (/ 狓/ )/ 赋值/ 给/ 变量/ 狔/ ,/ 返回/ 狔/ 给/ V/ ,/ 然后/ V/ 和/ P/ 以/ 如下/ 方式/ 进行/ 交互/ :/ (/ 1/ )/ 如果/ 狔/ =/ f/ (/ 狓/ )/ ,/ 那么/ P/ 应该/ 能/ 向/ V/ 证明/ 狔/ 的/ 正确性/ ,/ 即使/ 得/ V/ 接受/ 狔/ ./ 其中/ ,/ 证明/ 可以/ 通过/ 回答/ V/ 提出/ 的/ 一些/ 问题/ 完成/ ,/ 也/ 可以/ 通过/ 给/ V/ 提供/ 一个/ 证书/ 完成/ ./ (/ 2/ )/ 如果/ 狔/ ≠/ f/ (/ 狓/ )/ ,/ V/ 能以/ 很/ 高/ 的/ 概率/ 拒绝接受/ 狔/ ./ 可验证/ 计算/ 协议/ 的/ 设计/ 必须/ 满足/ 3/ 个/ 基本/ 原则/ :/ (/ 1/ )/ 协议/ 应该/ 使得/ 验证/ 者/ 的/ 开销/ 比其/ 在/ 本地/ 执行程序/ f/ (/ 狓/ )/ 的/ 开销/ 要/ 低/ ,/ 但/ 可以/ 允许/ 证明/ 者/ 为/ 达到/ 协议/ 的/ 目标/ 产生/ 合理/ 的/ 开销/ ,/ 因为/ 提供/ 运行/ 程序/ 的/ 正确性/ 保障/ 本身/ 就/ 需要/ 用户/ 付出/ 一定/ 的/ 代价/ ,/ 在/ 云/ 计算/ 实际/ 场景/ 中/ ,/ 表现/ 为云/ 提供商/ 可能/ 会/ 对/ 需要/ 提供/ 程序/ 正确/ 执行/ 证据/ 的/ 用户/ 收取/ 额外/ 的/ 费用/ ;/ (/ 2/ )/ 不能/ 假设/ 证明/ 者/ 完全/ 遵守/ 协议/ ,/ 也就是说/ 证明/ 者/ 可能/ 是/ 恶意/ 的/ ,/ 这和云/ 计算/ 中/ 不能/ 假设/ 云/ 提供商/ 是/ 完全/ 可信/ 的/ 实际/ 场景/ 也/ 是/ 十分/ 吻合/ 的/ ;/ (/ 3/ )/ f/ 应该/ 是/ 通用/ 程序/ ,/ 然而/ 在/ 具体/ 的/ 协议/ 设计/ 中/ ,/ 可能/ 需要/ 对/ f/ 表示/ 的/ 程序/ 做/ 一些/ 假设/ ,/ 从而/ 通过/ 限制/ 可验证/ 计算/ 协议/ 适用/ 的/ 应用程序/ 种类/ 使得/ 协议/ 的/ 性能/ 达到/ 实际/ 应用/ 场景/ 的/ 要求/ ,/ 但是/ 可验证/ 计算/ 协议/ 的/ 设计/ 原/ Page4/ 则/ 依然/ 是/ 尽量/ 能/ 表示/ 通用/ 程序/ ./ 通常/ 的/ 安全/ 保障/ 工具/ 比如说/ 病毒检测/ 关注/ 的/ 都/ 是/ 不/ 正确/ 的/ 行为/ 的/ 识别/ 和/ 防范/ ,/ 可验证/ 计算/ 协议/ 则/ 有所不同/ ,/ 其/ 不/ 关心/ 证明/ 者/ 可能/ 的/ 不/ 正确/ 行为/ ,/ 比如/ 犯/ 了/ 什么/ 错误/ ,/ 出现/ 了/ 什么/ 故障/ 等等/ ,/ 而/ 只/ 关心/ 其/ 执行程序/ 的/ 结果/ 是否是/ 正确/ 的/ ,/ 却/ 无法/ 推测/ 程序/ 错误/ 执行/ 的/ 原因/ ./ 这和云/ 计算/ 中/ 用户/ 对于/ 程序执行/ 的/ 要求/ 也/ 是/ 相符/ 的/ ./ 3/ 协议/ 流程/ 和/ 关键/ 3.1/ 可验证/ 计算/ 协议/ 流程/ 可验证/ 计算/ 协议/ 的/ 流程/ 主要/ 包括/ 编译/ 处理/ 和/ 证明/ 系统/ ,/ 具体/ 流程/ 如图/ 1/ 所示/ ./ 首先/ 是/ 编译/ 处理/ 阶段/ ,/ 验证/ 者/ V/ 和/ 证明/ 者/ P/ 将/ 高级/ 语言/ (/ 比如/ C语言/ )/ 编写/ 的/ 程序转换/ 成/ 一组/ 布尔/ 电路/ 集/ (/ 根据/ 协议/ 的/ 不同/ ,/ 也/ 可以/ 是/ 其他/ 计算/ 模型/ 比如/ 算术/ 电路/ 集/ 或者/ 约束/ 集等/ )/ ./ 具体方法/ 在/ 第/ 4/ 节/ 详述/ ./ 接下来/ ,/ P/ 和/ V/ 进行/ 一系列/ 协议/ 交互/ ,/ 不失/ 一般性/ ,/ 这里/ 用/ 布尔/ 电路/ 集/ 犆/ 表示/ 程序/ f/ ./ V/ 把/ 输入/ 变量/ 狓/ 传输/ 给/ P/ ,/ P/ 计算/ 犆/ ,/ 输出/ 程序执行/ 结果/ 狔/ 和/ 犆/ 正确/ 执行/ 的/ 一组/ 轨迹/ {/ 犆/ ,/ 狓/ ,/ 狔/ }/ 给/ V/ ,/ {/ 犆/ ,/ 狓/ ,/ 狔/ }/ 也/ 称为/ 犆/ 的/ 一个/ 可/ 满足/ 性/ 赋值/ 狕/ (/ 步骤/ ②/ )/ ./ 其中/ ,/ 犆/ 正确/ 执行/ 的/ 一组/ 轨迹/ 是/ 指/ 犆/ 的/ 输入/ 线路/ 被/ 赋值/ 为/ 狓/ ,/ 输出线路/ 被/ 赋值/ 为/ f/ (/ 狓/ )/ 时/ ,/ 电路/ 集中/ 所有/ 电路/ 门/ 的/ 赋值/ 集合/ ./ 在/ 程序执行/ 的/ 过程/ 中/ ,/ 证明/ 者/ P/ 获得/ 了/ 正确/ 计算/ 电路/ 的/ 执行/ 轨迹/ {/ 犆/ ,/ 狓/ ,/ 狔/ }/ (/ 步骤/ ②/ )/ ./ 如果/ P/ 声称/ 的/ 输出/ 狔/ 是/ 不/ 正确/ 的/ ,/ 即/ 狔/ 不/ 等于/ f/ (/ 狓/ )/ ,/ 那么/ 对于/ {/ 犆/ ,/ 狓/ ,/ 狔/ }/ ,/ 就/ 不/ 可能/ 存在/ 一个/ 有效/ 的/ 执行/ 轨迹/ (/ 电路/ 犆/ 正确/ 计算/ 的/ 一个/ 证明/ )/ ./ 因此/ ,/ 如果/ P/ 能够/ 对/ {/ 犆/ ,/ 狓/ ,/ 狔/ }/ 构建/ 一个/ 有效/ 的/ 执行/ 轨迹/ ,/ 那么/ 就/ 一定/ 能/ 使得/ 验证/ 者/ V/ 相信/ 它/ 返回/ 的/ 结果/ 是/ 正确/ 的/ ./ 显然/ ,/ 电路/ 正确/ 计算/ 过程/ 中/ 的/ 各个/ 门/ 的/ 赋值/ 本身/ 就/ 能/ 说明/ 存在/ 有效/ 的/ 执行/ 轨迹/ ./ 但是/ ,/ 如果/ 需要/ V/ 依次/ 验证/ 所有/ 电路/ 门/ 在/ 计算/ 电路/ 过程/ 中/ 的/ 值/ ,/ 进而/ 确定/ 程序/ 是否/ 正确/ 执行/ ,/ 这个/ 工作量/ 和/ V/ 本地/ 执行/ f/ 是/ 相当/ 的/ ,/ 这/ 就/ 违背/ 了/ 可验证/ 计算/ 协议/ 设计/ 的/ 基本/ 原则/ ./ 所以/ ,/ 图中/ 第/ ③/ 步/ 就/ 需要/ 证明/ 者/ 对/ 程序执行/ 轨迹/ 编码/ ,/ 生成/ 一个/ 很长/ 的/ 字符串/ ,/ 并/ 使得/ 不同/ 的/ 执行/ 轨迹/ 生成/ 的/ 编码/ 在/ 所有/ 不同/ 的/ 位置/ 的/ 取值/ 是/ 不/ 相同/ 的/ ./ 这样/ ,/ 验证/ 者/ 就/ 可以/ 通过/ 检查/ 随机/ 选择/ 的/ 编码/ 的/ 特定/ 的/ 位置/ 的/ 取值/ ,/ 来/ 验证/ 执行/ 轨迹/ 的/ 有效性/ ,/ 进而/ 对/ 返回/ 的/ 结果/ 采取/ 特定/ 的/ 测试/ 来/ 确定/ 证明/ 者/ 返回/ 的/ 结果/ 是否/ 正确/ ./ 但是/ 由于/ 编码/ 很长/ ,/ 读取/ 其/ 需要/ 的/ 时间/ 开销/ 也/ 相应/ 很大/ ,/ 验证/ 者/ 就/ 不/ 可能/ 取回/ 程序执行/ 轨迹/ 的/ 所有/ 编码/ 来/ 完成/ 验证/ 过程/ ./ 而且/ ,/ 出于/ 时间/ 开销/ 的/ 考虑/ ,/ 证明/ 者/ 也/ 不/ 可能/ 把/ 执行/ 轨迹/ 的/ 所有/ 编码/ 都/ 写/ 出来/ ,/ 因为/ 验证/ 者/ 只/ 需要/ 查询/ 几个/ 特定/ 位置/ 的/ 值/ (/ 检查/ 编码/ 的/ 一小部分/ )/ 就/ 可以/ 完成/ 验证/ ,/ 如果/ 把/ 所有/ 编码/ 都/ 写/ 出来/ ,/ 大部分/ 工作/ 就是/ 被/ 浪费/ 的/ ./ 然而/ ,/ 不/ 可能/ 让/ 验证/ 者/ 询问/ 证明/ 者/ 特定/ 位置/ 的/ 编码/ 包含/ 的/ 结果/ ,/ 因为/ 元素/ 的/ 随机性/ 在/ 协议/ 中是/ 非常/ 重要/ 的/ ,/ 可以/ 用来/ 防止/ 证明/ 者/ 的/ 欺骗/ ./ 假如/ 验证/ 者/ 的/ 询问/ 事先/ 被/ 证明/ 者/ 了解/ 到/ ,/ 证明/ 者/ 就/ 可能/ 设计/ 好/ 相应/ 的/ 回答/ 来/ 欺骗/ 验证/ 者/ ./ 因此/ ,/ 验证/ 者/ 必须/ 仔细/ 慎重/ 的/ 选择/ (/ 构造/ )/ 要/ 查询/ 的/ 编码/ 位置/ (/ 第/ ④/ 步/ )/ ./ 而/ 这/ 也/ 是/ 可验证/ 计算/ 协议/ 设计/ 的/ 核心/ 问题/ ./ 3.2/ 可验证/ 计算/ 协议/ 的/ 理论依据/ 理解/ 可验证/ 计算/ 协议/ 的/ 原理/ 和/ 流程/ 关键在于/ 理解/ 两个/ 等价关系/ ,/ 如图/ 2/ 所示/ ./ 如/ 3.1/ 节/ 所述/ ,/ 可验证/ 计算/ 协议/ 的/ 流程/ 主要/ 包括/ 编译/ 处理/ 和/ 证明/ 系统/ ./ 其中/ ,/ 编译/ 处理/ 阶段/ ,/ 编译器/ 完成/ 高级/ 语言/ 程序/ 到/ 电路/ 集/ 或者/ 约束/ 集/ (/ 可以/ 看做/ 方程组/ )/ 等/ 计算/ 模型/ 的/ 转化/ ,/ 其/ 实现/ 的/ 理论依据/ 在于/ 等价关系/ :/ 程序执行/ 的/ 正确性/ 等价/ 于/ 电路/ 集/ 或者/ 约束/ 集可/ 满足/ 问题/ ./ 定义/ 1/ ./ 电路/ 集是/ 可/ 满足/ 的/ ./ 给定/ 输入/ 狓/ ,/ 输出/ 狔/ ,/ 存在/ 一组/ 所有/ 中间/ 电/ 路线/ 的/ 赋值/ 狕/ ,/ 使得/ 电/ 路线/ 所有/ 的/ 电路/ 门/ 都/ 可以/ 同时/ 满足/ ,/ 则/ 称/ 电路/ 集是/ 可/ 满足/ 的/ ,/ 且/ 狕/ 称为/ 犆/ (/ 犡/ =/ 狓/ ,/ 犢/ =/ 狔/ )/ 的/ 可/ 满足/ 赋值/ [/ 42/ ]/ ./ 定义/ 2/ ./ 约束/ 集是/ 可/ 满足/ 的/ ./ 给定/ 输入/ 狓/ ,/ 输出/ 狔/ ,/ 存在/ 一组/ 犣/ =/ 狕/ ,/ 使得/ C/ (/ 犡/ =/ 狓/ ,/ 犢/ =/ 狔/ )/ 中/ 的/ 约束/ 能/ Page5/ 同时/ 满足/ ,/ 则/ 称/ 约束/ 集是/ 可/ 满足/ 的/ ,/ 且/ 犣/ =/ 狕/ 称为/ 犆/ (/ 犡/ =/ 狓/ ,/ 犢/ =/ 狔/ )/ 的/ 可/ 满足/ 赋值/ [/ 43/ ]/ ./ 定理/ 1/ ./ 程序执行/ 的/ 正确性/ 等价/ 于/ 约束/ 集/ // 电路/ 集是/ 可/ 满足/ 的/ ,/ 对于/ 所有/ 的/ 狓/ ,/ 狔/ ,/ 狔/ =/ f/ (/ 狓/ )/ 当且/ 仅/ 当/ 约束/ 集/ // 电路/ 集/ 犆/ (/ 犡/ =/ 狓/ ,/ 犢/ =/ 狔/ )/ 是/ 可/ 满足/ 的/ [/ 42/ -/ 43/ ]/ ./ 证明/ 系统/ 的/ 主要/ 作用/ 在于/ 依据/ 编译器/ 输出/ 的/ 采用/ 特定/ 计算/ 模型表示/ 的/ 应用程序/ ,/ 设计/ 验证/ 者/ V/ (/ 等同于/ 用户/ )/ 和/ 证明/ 者/ P/ (/ 等同于/ 云/ 提供商/ )/ 之间/ 的/ 交互/ 协议/ ,/ 保证/ 用户/ 应用程序/ 执行/ 的/ 正确性/ ./ 其/ 理论依据/ 在于/ 使用/ 代数/ 化/ 方法/ 构造/ 如图/ 2/ 第/ 2/ 个/ 等价关系/ :/ 电路/ 集/ 或者/ 约束/ 集可/ 满足/ 问题/ 等价/ 于/ 一类/ 很难/ 计算/ 但是/ 容易/ 验证/ 的/ 问题/ ,/ 比如说/ QAP/ (/ QuadraticArithmeticProgram/ )/ 理论/ 中/ 的/ 整除/ 关系/ ./ 至此/ ,/ 验证/ 程序/ 是否/ 正确/ 执行/ 的/ 问题/ 转化成/ 了/ 验证/ 特定/ 代数/ 关系/ 是否/ 满足/ 的/ 问题/ ./ 4/ 计算/ 模型/ 生成/ 原理/ 流程/ 为了/ 应用/ IPs/ 和/ PCPs/ 理论/ 构造/ 可验证/ 计算/ 协议/ ,/ 必须/ 先/ 把/ 高级/ 语言/ 程序转换/ 成/ IPs/ 和/ PCPs/ 判定/ 器/ 可以/ 接受/ 的/ 计算/ 模型/ ,/ 比如说/ 电路/ 集/ 和/ 约束/ 集/ ./ Cook/ -/ Levin/ 理论/ [/ 44/ ]/ 表明/ 这种/ 转换/ 理论/ 上/ 是/ 可以/ 的/ ,/ 因为/ 任何/ 程序/ f/ 都/ 可以/ 用/ 图灵机/ 来/ 模拟/ ,/ 同时/ 图灵机/ 可以/ 转换成/ 布尔/ 电路/ ,/ 且/ 不会/ 超过/ 程序/ 的/ 步骤/ ./ 目前/ 可验证/ 计算/ 协议/ 中/ 编译器/ 都/ 是/ 基于/ Fairplay/ 和/ Benjamin/ 编译器/ 设计/ 的/ ,/ 常用/ 的/ 计算/ 模型/ 主要/ 有/ 电路/ 集/ 和/ 约束/ 集/ 两种/ ./ Fairplay/ 和/ 通常/ 的/ 硬件/ 编译器/ [/ 45/ -/ 51/ ]/ 不同/ ,/ 不能/ 使用/ 寄存器/ ,/ 没有/ 时序/ 逻辑/ ,/ 通过/ FairplayWeb/ 网站/ [/ 52/ ]/ 可以/ 获取/ 该/ 编译器/ ./ Fairplay/ 可以/ 用来/ 把/ 高级/ 语言/ 编写/ 的/ 程序/ 编译成/ 一组/ 布尔/ 电路/ 集/ ,/ 但/ 这种/ 高级/ 语言/ 并/ 不是/ 通常/ 所说/ 的/ 高级/ 语言/ ,/ 而是/ 一种/ 类似/ Pascal/ 或者/ C语言/ 的/ 子集/ 的/ 程序语言/ ,/ 称为/ (/ 安全/ 函数/ 定义/ )/ SFDL/ 语言/ ./ Benjamin/ 提出/ 的/ 编译器/ [/ 43/ ]/ 继承/ 并/ 改进/ 了/ Fairplay/ 编译器/ ,/ 用于/ 把/ 高级/ 语言/ 表示/ 的/ 程序/ 编译成/ 一组/ 约束/ 集/ ./ 这种/ 编译器/ 也/ 引入/ 了/ 一种/ 类似/ SFDL/ 的/ 高级/ 程序语言/ ,/ 称为/ 扩展/ 函数/ 描述/ BFDL/ ./ 不失/ 一般性/ ,/ 本文/ 以/ Benjamin/ 编译器/ 为例/ 说明/ 从/ 高级/ 语言/ 程序/ (/ C语言/ 为例/ )/ 转化成/ 约束/ 集/ 的/ 原理/ 和/ 工作/ 流程/ ./ BFDL/ 的/ 语法/ 很/ 容易/ 理解/ ,/ 很多/ 地方/ 都/ 是从/ C/ 和/ Pascal/ 语言/ 继承/ 的/ ./ BFDL/ 语言/ 使用/ C/ 风格/ 的/ 语法/ ,/ 是/ 一种/ 静态/ 类型/ 语言/ ,/ 支持/ 类型/ 引用/ ./ 其/ 程序结构/ 如图/ 3/ :/ 第一/ 部分/ 是/ 类型/ 声明/ ,/ 定义/ 将要/ 使用/ 的/ 数据类型/ 、/ 支持/ 布尔/ 型/ 、/ 整型/ 、/ 结构/ 体/ 和/ 数组/ ./ BFDL/ 编译器/ 不/ 支持/ 数据/ 下标/ 为/ 变量/ 的/ 程序代码/ ./ 图/ 4/ 是/ Benjamin/ 编译器/ 的/ 执行/ 流程/ ./ ①/ 使用/ BFDL/ 编译器/ 把/ BFDL/ 语言/ 表示/ 的/ 代码/ 经过/ 函数/ 内联/ 、/ 循环展开/ 等/ 步骤/ 编译成/ 单/ 赋值/ 列表/ ;/ ②/ 使用/ 修改/ 过/ 的/ SFDL/ 中/ 的/ 优化/ 方法/ 来/ 减少/ 单/ 赋值/ 列表/ 中/ 的/ 赋值/ 描述/ 数量/ ;/ ③/ 把/ 赋值/ 描述/ 列表/ 转换/ 为/ 可验证/ 计算/ 协议/ 比如/ Zaatar/ 和/ Ginger/ 可以/ 接受/ 的/ 约束/ 集/ ./ 下面/ 以/ 计算/ 一个/ m/ =/ 14/ 的/ 输入/ 数组/ 中/ 出现/ 目标/ 关键字/ 的/ 次数/ 的/ 程序/ 为例/ 说明/ 从/ C语言/ 到/ 约束/ 集/ 的/ 编译/ 处理过程/ ,/ 图/ 5/ 是/ C语言/ 描述/ 示例/ ,/ 图/ 6/ 是/ 相应/ 程序/ 依据/ 定义/ [/ 43/ ]/ 编译/ 的/ BFDL/ 语言/ 描述/ 实例/ ./ 图/ 7/ 和/ 图/ 8/ 显示/ 了/ 上述/ 范例/ 从/ BFDL/ 代码/ 到/ 单/ 赋值/ 形式/ (/ 程序/ 的/ 中间/ 表示/ )/ 、/ 再/ 从/ 单/ 赋值/ 形式/ 到/ 约束/ 集/ 的/ 转化/ ./ 从图/ 8/ 中/ ,/ 可以/ 看出/ 图/ 6/ 中/ 第/ 19/ 行/ 的/ 循环/ 已经/ 展开/ ,/ if/ 语句/ 通过/ 构造/ 一个/ 复用/ 转化/ 器/ 表示/ 成/ 单/ 赋值/ 形式/ ./ 图/ 7/ [/ 43/ ]/ 中/ 列出/ 了/ 布尔/ 表达式/ 和/ 约束/ 的/ 对应/ 关系/ ./ 其他/ 诸如/ 条件/ 语句/ 、/ 不/ 等/ 测试/ 、/ 比较/ 操作/ 和/ 约束/ 的/ 对应/ 关系/ 见/ 文献/ [/ 43/ ]/ ./ 而/ 从/ 单/ 赋值/ 形式/ 到/ 约束/ 集/ 的/ 转化/ 由/ 上述/ 规则/ 直接/ 转化/ ./ 表/ 1/ 给出/ 了/ 布尔/ 表达式/ 和/ 约束/ 的/ 对应/ 关系/ ./ Page6/ 布尔/ 函数/ FALSEX2/ ,/ NOTX1NOTX1X1/ ,/ NOTX2EQUALX1/ →/ X2/ 烄/ 犆/ =/ 烅/ Mcond/ 烆/ 5/ 可验证/ 计算/ 协议/ 分类/ 5.1/ 依据/ 编译器/ 复杂程度/ 分类/ 由/ 第/ 3/ 节/ 所述/ ,/ 可验证/ 计算/ 协议/ 主要/ 流程/ 包括/ 编译/ 处理/ 和/ 证明/ 系统/ 两个/ 阶段/ ,/ 所以/ 下文/ 将/ 依据/ 协议/ 流程/ 对/ 不同/ 协议/ 分类/ ,/ 如图/ 9/ ,/ 并/ 说明/ 每种/ 分类/ 的/ 特点/ 和/ 典型/ 协议/ ./ 本文/ 提到/ 的/ 协议/ 中/ 的/ 编译/ 处理/ 都/ 是/ 直接/ 使用/ Fairplay/ 和/ Benjamin/ 编译器/ 或者/ 对/ 其/ 改进/ 后/ 使用/ ,/ 生成/ 证明/ 系统/ 可以/ 接受/ 的/ 计算/ 模型/ ./ 依据/ 可验证/ 计算/ 协议/ 使用/ 的/ 编译器/ 的/ 复杂程度/ ,/ 可以/ 分为/ 简单/ 编译器/ 的/ 可验证/ 计算/ 协议/ 和/ 复杂/ 编译器/ 的/ 可验证/ 计算/ 协议/ ./ 简单/ 的/ 编译器/ 是/ 指/ 不/ 支持/ 内存/ 随机存取/ 的/ 编译器/ ,/ 即/ 不/ 考虑/ 内存/ 概念/ ,/ 假设/ 程序/ 的/ 输入/ 都/ 来源于/ 验证/ 者/ ./ 简单/ 编译器/ 的/ 可验证/ 计算/ 协议/ 包括/ GKR/ [/ 18/ ]/ 、/ CMT/ [/ 53/ ]/ 、/ Thaler/ [/ 54/ ]/ 、/ Allspice/ [/ 55/ ]/ 、/ Pepper/ [/ 56/ ]/ 、/ Ginger/ [/ 57/ ]/ 、/ Zaatar/ [/ 58/ ]/ 和/ Pinocchio/ [/ 59/ ]/ 等/ ,/ 其中/ Pinocchio/ 是/ 第一个/ 直接/ 接受/ C语言/ 程序/ 的/ 协议/ ,/ 而/ 其他/ 协议/ 则/ 需要/ 先/ 将/ C语言/ 程序/ 转化/ 为/ 另/ 一种/ 指定/ 的/ 高级/ 语言/ 比如/ BFDL/ 语言/ ,/ 然后/ 再/ 转化成/ 证明/ 系统/ 可以/ 接受/ 的/ 计算/ 模型/ ./ GKR/ 使用/ 算术/ 电路/ 作为/ 计算/ 模型/ ,/ 相/ 比较/ 之前/ 协议/ 使用/ 的/ 布尔/ 电路/ 减少/ 了/ 程序/ 编译/ 的/ 开销/ ./ CMT/ 、/ Thaler/ 、/ Allspice/ 、/ Pepper/ 基本/ 沿用/ 了/ GKR/ 中/ 的/ 编译器/ ,/ 且/ Pepper/ 对/ 算术/ 电路/ 进行/ 了/ 简化/ ,/ Ginger/ 扩展/ 了/ 算术/ 电路/ 模型表示/ 的/ 程序/ 种类/ ,/ 使得/ 模型/ 包含/ 浮点数/ 类型/ ,/ 不/ 等/ 测试/ ,/ 逻辑/ 表达式/ ,/ 条件/ 语句/ 等等/ ,/ 因而/ 使得/ 模型/ 能/ 表示/ 的/ 程序/ 更加/ 接近/ 于/ 通用/ 程序/ ./ Allspice/ 编译器/ 通过/ 增加/ 了/ 一个/ 静态/ 分析器/ 来/ 自动/ 确定/ 并/ 运行/ Zaatar/ 或/ GKR/ 两个/ 协议/ 中/ 效率/ 较/ 高/ 的/ 一个/ ,/ 增加/ 了/ 协议/ 的/ 可扩展性/ ./ 复杂/ 编译器/ 的/ 可验证/ 计算/ 协议/ 包括/ Pantry/ 和/ BCGTV/ [/ 61/ ]/ ./ 复杂/ 的/ 编译器/ 支持/ 内存/ 操作/ ,/ 这/ 更符/ Page7/ 合/ 实际/ 应用/ 场景/ ./ Pantry/ 中/ 的/ 编译器/ 改进/ 了/ Zaatar/ 和/ Pinocchio/ 使用/ 的/ 编译器/ ,/ 结合/ 了/ 不可/ 信/ 存储/ 中/ 使用/ 的/ 技术/ [/ 62/ -/ 65/ ]/ ,/ 使用/ Merkle/ -/ hash/ 树来/ 支持/ 内存/ 随机存取/ ./ 通过/ 构建/ 一个/ 二叉树/ 来/ 表示/ 内存/ ,/ 二叉树/ 的/ 每个/ 叶/ 节点/ 存储/ 相应/ 内存地址/ 的/ 值/ ,/ 每个/ 内部/ 节点/ 存储/ 作用/ 于其子/ 节点/ 的/ 抗/ 冲突/ 哈希/ 函数/ 的/ 值/ ./ 每当/ 验证/ 者/ 通过/ (/ 根/ 节点/ 值/ 、/ 内存地址/ )/ 二元/ 组/ 访问/ 一个/ 内存地址/ (/ 叶/ 节点/ )/ 时/ ,/ 证明/ 者/ 可以/ 通过/ 提供/ 沿叶/ 节点/ 到/ 根/ 节点/ “/ 证明/ 路径/ ”/ 的/ 所有/ 值来/ “/ 证明/ ”/ 其/ 返回值/ 是/ 正确/ 的/ ./ 证明/ 者/ 欺骗/ 验证/ 者/ 的/ 唯一/ 方法/ 是/ 通过/ 找到/ 哈希/ 函数/ 中/ 的/ 冲突/ ./ 由于/ Pantry/ 使用/ 的/ 抗/ 冲突/ 哈希/ 函数/ 的/ 计算/ 函数/ 可以/ 有效/ 地/ 表示/ 成/ 约束/ 集/ ,/ 从而/ 使得/ 内存/ 操作/ 也/ 可以/ 有效/ 的/ 表示/ 成/ 约束/ 集/ ./ 如果/ 把/ 内存/ 操作/ 也/ 看作/ 普通/ 的/ 程序/ ,/ 就/ 可以/ 实现/ 包含/ 内存/ 操作/ 的/ 程序/ 的/ 可验证/ 计算/ 了/ ./ 更/ 重要/ 的/ 是/ ,/ Pantry/ 支持/ “/ 远程/ 输入/ ”/ ,/ 这使/ 其能/ 更好/ 的/ 支持/ MapReduce/ 程序/ ,/ 且/ 在/ MapReduce/ 程序/ 中/ 为了/ 降低/ 开销/ 定义/ 了/ GetBlock/ 和/ PutBlock/ 两种/ 元/ 操作/ 来/ 代替/ 构造/ Merkle/ -/ hash/ 树/ ./ BCGTV/ 基于/ 文献/ [/ 28/ ,/ 58/ ,/ 66/ ]/ ,/ 把/ 程序/ 编译成/ 一种/ 特殊/ 的/ 电路/ 表示/ [/ 67/ ]/ ,/ 并/ 把/ 这种/ 计算/ 模型/ 称为/ TinyRAM/ ./ BCGTV/ 适用/ 于/ 通用/ 程序/ ,/ 它/ 支持/ 所有/ 的/ C/ 程序/ ,/ 包括/ 独立/ 于/ 数据/ 的/ 循环/ 和/ RAM/ ,/ 但/ 不/ 支持/ “/ 远程/ 输入/ ”/ ./ 然而/ BCGTV/ 的/ 通用性/ 是/ 通过/ 牺牲/ 协议/ 性能/ 来/ 达到/ 的/ ,/ 这使/ 其/ 编译器/ 的/ 开销/ 通常/ 比/ Pinocchio/ 和/ Zaatar/ 编译器/ 开销/ 高/ 好几个/ 数量级/ ./ 从/ 性能/ 考虑/ ,/ BCGTV/ 仍/ 无法/ 用于/ 实际/ 应用程序/ ./ 5.2/ 依据/ 证明/ 系统分类/ 依据/ 可验证/ 计算/ 协议/ 的/ 证明/ 系统/ 的/ 构造方法/ 不同/ 可/ 将/ 协议/ 分为/ 3/ 大类/ :/ 基于/ 交互式/ 证明/ 系统/ 的/ 可验证/ 计算/ 协议/ 、/ 基于/ 论证/ 系统/ 的/ 有/ 预处理/ 的/ 可验证/ 计算/ 协议/ 和/ 基于/ 论证/ 系统/ 的/ 无/ 预处理/ 的/ 可验证/ 计算/ 协议/ ./ 本文/ 不/ 讨论/ 基于/ 论证/ 系统/ 的/ 无/ 预处理/ 的/ 可验证/ 计算/ 协议/ ,/ 因为/ 无/ 预处理/ 的/ 论证/ 系统/ 大多/ 基于/ shortPCPs/ [/ 68/ -/ 71/ ]/ ,/ 由于/ 其/ 开销/ 过大/ ,/ 仍/ 处于/ 理论/ 研究/ 阶段/ ,/ 还/ 无法/ 用于/ 实际/ 的/ 应用程序/ ./ IPs/ 和/ PCPs/ 理论/ 表明/ 对于/ 给定/ 的/ 数学/ 论断/ ,/ 证明/ 者/ 有/ 能力/ 使得/ 验证/ 者/ 相信/ 论断/ 的/ 正确性/ ./ IPs/ 和/ PCPs/ 理论/ 为/ 可验证/ 计算/ 协议/ 证明/ 系统/ 的/ 构造/ 提供/ 了/ 非常/ 强/ 的/ 保证/ ,/ 使/ 其/ 可以/ 抵御/ 任意/ 的/ 恶意/ 证明/ 者/ ./ 本文/ 说/ 任意/ 的/ 恶意/ 证明/ 者/ 是/ 指/ 不仅/ 包括/ 故意/ 作恶/ 的/ 证明/ 者/ ,/ 还/ 包括/ 不可/ 预期/ 的/ 行为/ 导致/ 的/ 故障/ 或/ 错误/ ./ 交互式/ 证明/ 系统/ 由/ Goldwasser/ 、/ Micali/ 和/ Rackoff/ [/ 19/ ]/ 以及/ Babai/ 分别/ 提出/ [/ 15/ ]/ ./ 两种/ 定义/ 是/ 等价/ 的/ [/ 72/ ]/ ,/ 其中/ Babai/ 的/ 系统/ 又/ 称为/ 公开/ 投币/ 系统/ (/ Pulic/ -/ CoinSystem/ )/ ./ 定义/ 3/ ./ 一个/ 语言/ L/ / {/ 0/ ,/ 1/ }/ / 的/ 交互式/ 证明/ 系统/ [/ 19/ ]/ 是/ 一个/ 由/ 证明/ 者/ P/ 和/ 验证/ 者/ V/ 组成/ 的/ 交互/ 过程/ ,/ 对于/ 任意/ 的/ 输入/ 串/ x/ ,/ 他们/ 的/ 交互/ 过程/ 满足/ 如下/ 的/ 条件/ :/ (/ 1/ )/ 验证/ 者/ V/ 是/ 一台/ 多项式/ 时间/ 的/ 、/ 带/ 外部/ 信息源/ 的/ 随机/ 图灵机/ ;/ (/ 2/ )/ 证明/ 者/ P/ 的/ 计算能力/ 无/ 限制/ ;/ P/ 是/ 一个/ 串/ 函数/ :/ {/ 0/ ,/ 1/ }/ / →/ {/ 0/ ,/ 1/ }/ / ;/ (/ 3/ )/ 正确性/ 要求/ :/ ①/ 完备/ 性/ ./ 如果/ x/ ∈/ L/ ,/ 存在/ P/ ,/ 证明/ 者/ P/ 能以/ 至少/ 2/ // 3/ 的/ 概率/ 使得/ 验证/ 者/ V/ 接受/ ;/ ②/ 可靠性/ ./ 如果/ x/ / L/ ,/ 则/ 对于/ 任意/ P/ ,/ 至多/ 只能/ 以/ 1/ // 3/ 的/ 概率/ 使得/ 验证/ 者/ V/ 接受/ ./ 文献/ [/ 19/ ]/ 进一步/ 证明/ 了/ 其/ 完备/ 性/ 可以/ 达到/ 1/ -/ 1/ // nk/ ,/ 可以/ 把/ 交互式/ 证明/ 系统/ 记为/ k/ -/ (/ V/ ,/ P/ )/ (/ x/ )/ ,/ 其中/ |/ x/ |/ =/ n/ ,/ 在/ 计算/ 过程/ 中/ 至多/ 交互/ k/ (/ n/ )/ 次/ ,/ k/ (/ ·/ )/ :/ N/ →/ N/ 是/ 一个/ 多项式/ 时间/ 内/ 可/ 计算/ 函数/ ./ 为了/ 描述/ 方便/ ,/ 本文/ 把/ 交互式/ 证明/ 系统/ k/ -/ (/ V/ ,/ P/ )/ (/ x/ )/ 称为/ 一个/ 含有/ 外部/ 信息源/ 的/ 判定/ 器/ ,/ 判定/ 器/ V/ (/ ·/ ,/ ·/ )/ 按/ 如下/ 方式/ 工作/ :/ (/ 1/ )/ 在/ 输入/ 带上/ 放置/ 输入/ x/ ,/ 外部/ 信息源/ 记/ 为/ π/ ,/ π/ 也/ 称为/ 证明/ 串/ ,/ 放置/ 在/ 一条/ 专用/ 证明/ 带上/ ,/ 这里/ 证明/ 带/ 充当/ 证明/ 者/ P/ ;/ (/ 2/ )/ 计算/ 过程/ 中/ 产生/ w/ 个/ 地址/ :/ i1/ ,/ …/ ,/ iw/ ;/ 依照/ i1/ ,/ …/ ,/ iw/ (/ i1/ ,/ …/ ,/ iw/ 依赖于/ 随机/ 选择/ )/ ,/ 从/ 证明/ 带上/ 获取/ 一个/ “/ 局部/ 证明/ ”/ :/ z/ =/ π/ [/ ir/ (/ 3/ )/ 计算/ V/ (/ x/ ,/ z/ )/ ./ 在/ 多项式/ 时间/ 内/ 验证/ 一个/ 解/ 是否/ 正确/ 的/ 问题/ 存在/ 交互式/ 证明/ 系统/ [/ 16/ -/ 17/ ]/ ,/ 由/ 上述/ 可见/ ,/ 应用/ 交互式/ 证明/ 系统/ 来/ 设计/ 可验证/ 计算/ 协议/ ,/ 实际上/ 就是/ 设计/ 一个/ 判定/ 器/ ./ 对于/ 给出/ 的/ 某个/ 程序/ 的/ 计算结果/ ,/ P/ 总是/ 要/ 设法/ 让/ V/ 相信/ 程序执行/ 结果/ 的/ 正确性/ (/ 无论/ 这个/ 结果/ 本身/ 是否/ 正确/ )/ ./ 交互式/ 证明/ 系统/ 通常/ 含有/ 一个/ 随机/ 操作/ 机制/ ,/ 因为/ V/ 可能/ 有/ 很多/ 问题/ (/ 即/ 地址/ )/ 需要/ P/ 来/ 证明/ ,/ 但/ 又/ 没有/ 足够/ 的/ 时间/ 验证/ ,/ 所以/ 只能/ 随机/ 的/ 选择/ 一些/ 问题/ ,/ 同时/ V/ 依靠/ 使用/ 随机/ 串/ 机制/ 来/ 防止/ P/ 的/ “/ 欺骗/ ”/ ./ P/ 通过/ 上述/ 多轮/ 交互/ 过程/ ,/ 判断/ P/ 给出/ 的/ 证明/ 过程/ 是否/ 足以/ 证明/ 程序/ 正确/ 执行/ ./ 论证/ 系统/ [/ 24/ ,/ 34/ ,/ 73/ -/ 74/ ]/ 实际上/ 也/ 是/ 一种/ 特殊/ 的/ 交互式/ 证明/ 系统/ ,/ 其中/ ,/ 交互/ 的/ 次数/ 最多为/ 两轮/ ,/ 证明/ 者/ P/ 的/ 计算能力/ 限制/ 在/ 多项式/ 时间/ 内/ ./ 在/ 本文/ 中/ ,/ 我们/ Page8/ 将/ 基于/ 论证/ 系统/ 的/ 可验证/ 计算/ 协议/ 和/ 基于/ 交互式/ 证明/ 系统/ 的/ 可验证/ 计算/ 协议/ 分成/ 不同/ 的/ 类别/ 讨论/ ,/ 主要/ 基于/ 以下/ 考虑/ :/ (/ 1/ )/ 本文/ 中/ 讨论/ 的/ 基于/ 交互式/ 证明/ 系统/ 的/ 可验证/ 计算/ 协议/ ,/ 其/ 交互/ 轮数/ 是/ 指/ 多于/ 两轮/ 的/ 交互/ ,/ 而/ 基于/ 论证/ 系统/ 的/ 可验证/ 计算/ 协议/ ,/ 其/ 交互/ 的/ 轮数/ 被/ 限制/ 在/ 两轮/ 之内/ ,/ 由此/ 带来/ 的/ 协议/ 的/ 性能/ 开销/ 和/ 支持/ 的/ 安全/ 属性/ 都/ 会/ 有/ 很大/ 的/ 不同/ ,/ 在/ 表/ 2/ 详细/ 对比/ ;/ (/ 2/ )/ 基于/ 交互式/ 证明/ 系统/ 的/ 可验证/ 计算/ 协议/ 和/ 基于/ 论证/ 系统/ 的/ 可验证/ 计算/ 协议/ 由于/ 协议/ 交互/ 的/ 轮数/ 不同/ ,/ 使得/ 协议/ 具体/ 的/ 构造/ 也/ 有/ 显著/ 的/ 不同/ ,/ 这/ 在/ 本文/ 后续/ 关于/ 协议/ 的/ 具体/ 介绍/ 中会/ 有/ 体现/ ./ 表/ 2/ 基于/ 交互式/ 证明/ 系统/ 和/ 基于/ 论证/ 系统/ 的/ 协议/ 比较/ 计算能力/ 初始/ 阶段/ 开销/ 证明/ 者/ 开销/ 程序/ 种类/ 交互/ 轮数/ 零/ 知识性/ 公开/ 可验证/ 性/ 文献/ [/ 30/ ]/ 说明/ 所有/ 有效/ 的/ 论证/ 系统/ 的/ 构造/ 都/ 依赖于/ PCPs/ ./ PCPs/ 以及/ 基于/ 此/ 的/ 论证/ 系统/ 实现/ 起来/ 相当/ 复杂/ ,/ 是/ 无法/ 用于/ 实际/ 应用/ 场景/ 的/ 可验证/ 计算/ 协议/ 的/ ,/ 所以/ 基于/ 论证/ 系统/ 的/ 有/ 预处理/ 的/ 可验证/ 计算/ 协议/ 使用/ 的/ 都/ 是/ 特殊/ 构造/ 的/ PCPs/ ./ 所谓/ 预处理/ ,/ 也/ 称为/ 协议/ 的/ 初始/ 阶段/ ,/ 是/ 需要/ 证明/ 者/ 预先/ 做/ 一个/ 承诺/ 或者/ 验证/ 者/ 预先/ 加密/ 询问/ 向量/ ./ 依据/ 预处理/ 的/ 方法/ 不同/ ,/ 可验证/ 计算/ 协议/ 又/ 可以/ 分为/ 使用/ 基于/ 承诺/ 方案/ 的/ 论证/ 系统/ 的/ 可验证/ 计算/ 协议/ 和/ 使用/ 加密/ 询问/ 向量/ 的/ 论证/ 系统/ 的/ 可验证/ 计算/ 协议/ ./ 有/ 预处理/ 的/ 协议/ 的/ 优势/ 在于/ 其/ 适用/ 于/ 数据/ 并行度/ 高/ 的/ 应用程序/ ,/ 因为/ 此类/ 情形/ 下/ ,/ 验证/ 者/ 能/ 把/ 初始/ 阶段/ 的/ 开销/ 分摊/ 给/ 同一/ 程序/ 中/ 的/ 多个/ 实例/ ,/ 这样/ 才能/ 使得/ 其/ 开销/ 可以/ 被/ 实际/ 应用程序/ 所/ 接受/ (/ 即当/ 同一/ 程序/ 被/ 独立/ 应用/ 于/ 许多/ 不同/ 的/ 输入/ 实例/ 时/ 有效/ )/ ,/ 这和云/ 计算/ 应用/ 场景/ 也/ 十分/ 吻合/ ./ 承诺/ 方案/ [/ 75/ ]/ 是/ 一种/ 基本/ 而/ 用途/ 广泛/ 的/ 密码学/ 原语/ ,/ 是/ 理论/ 密码学/ 中/ 重要/ 的/ 基本/ 模块/ 之一/ ./ 承诺/ 方案/ 由/ 两个/ 概率/ 多项式/ 时间/ (/ ProbabilisticPolynomial/ -/ Time/ ,/ PPT/ )/ 算法/ 组成/ ,/ 分别/ 称为/ 承诺/ 方/ 和/ 接收/ 方/ ./ 承诺/ 方案/ 允许/ 承诺/ 方对/ 选定/ 的/ 值/ 或者/ 声明/ 进行/ 承诺/ (/ 即/ 计算/ 承诺/ 函数/ 的/ 值/ )/ ./ 承诺/ 方案/ 有/ 两个/ 阶段/ :/ 承诺/ 阶段/ 和/ 公开/ 阶段/ ./ 在/ 承诺/ 阶段/ ,/ 承诺/ 方/ 发送/ 其/ 秘密/ 输入/ (/ 选择/ 的/ 值/ 或者/ 声明/ )/ m/ 的/ 承诺/ 值/ 给/ 接收/ 方/ ;/ 在/ 公开/ 阶段/ ,/ 承诺/ 方/ 可以/ 公开/ 其/ 秘密/ 输入/ m/ ./ 接收者/ 计算/ 承诺/ 值/ ,/ 并/ 与/ 承诺/ 方/ 发送/ 的/ 承诺/ 值相/ 比较/ ,/ 若/ 相等/ 则/ 承诺/ 被/ 接受/ 否则/ 被/ 拒绝/ ./ 承诺/ 方案/ 要/ 满足/ 隐藏/ 性/ 和/ 绑定/ 性/ 两个/ 性质/ ./ 隐藏/ 性即/ 接收/ 方/ 根据/ 承诺/ 值/ 不能/ 计算/ 关于/ 承诺/ 方/ 秘密/ 输入/ m/ 的/ 信息/ ./ 绑定/ 性即/ 承诺/ 方/ 一旦/ 做出/ 承诺/ ,/ 则/ 无法/ 改变/ 其值/ ,/ 也就是说/ 承诺/ 方/ 不能/ 将/ 承诺/ 值/ 公开/ 为/ 两个/ 不同/ 的/ m/ 和/ m/ ./ 基于/ 承诺/ 方案/ 的/ 论证/ 系统/ 的/ 交互/ 一共/ 有/ 两轮/ ,/ 也/ 称为/ 基于/ 交互/ 的/ 论证/ 系统/ ,/ 承诺/ 方/ 的/ 角色/ 由/ 证明/ 者/ 代替/ ,/ 接收/ 方/ 的/ 角色/ 由/ 验证/ 者/ 代替/ ,/ 验证/ 者/ 首先/ 需要/ 证明/ 者/ 对/ 执行/ 轨迹/ (/ 证据/ )/ 的/ 编码/ 作出/ 一个/ 承诺/ ./ 在/ 第/ 2/ 轮中/ ,/ 验证/ 者/ 询问/ 其要/ 查询/ 的/ 证据/ 的/ 位置/ ,/ 然后/ 证明/ 者/ 回答/ 证据/ 在/ 特定/ 位置/ 的/ 值/ ,/ 证明/ 者/ 的/ 回答/ 必须/ 和/ 承诺/ 一致/ ./ 使用/ 加密/ 询问/ 向量/ 的/ 论证/ 系统/ 由于/ 验证/ 者/ 在/ 协议/ 的/ 初始/ 阶段/ 发送/ 加密/ 后/ 的/ 询问/ 向量/ 给/ 证明/ 者/ 之后/ ,/ 无需/ 验证/ 者/ 在/ 每个/ 实例/ 再/ 重新/ 发送/ 询问/ 向量/ ,/ 从而/ 也/ 称作/ 无/ 交互/ 的/ 论证/ 系统/ ./ 然后/ ,/ 在/ 之后/ 的/ 验证/ 阶段/ ,/ 验证/ 者/ 和/ 证明/ 者/ 使用/ 复杂/ 的/ 密码学/ 协议/ 实现/ 如下/ 的/ 步骤/ :/ 证明/ 者/ 响应/ 询问/ 向量/ ,/ 但/ 不/ 知道/ 具体/ 要/ 询问/ 的/ 证据/ 的/ 位置/ ,/ 使用/ 证明/ 者/ 的/ 答案/ ,/ 验证/ 者/ 使用/ PCP/ 来/ 验证/ 答案/ ,/ 正如/ 使用/ 基于/ 承诺/ 方案/ 的/ 论证/ 系统/ 的/ 协议/ 一样/ ./ 使用/ 基于/ 承诺/ 方案/ 的/ 论证/ 系统/ 的/ 可验证/ 计算/ 协议/ 和/ 使用/ 加密/ 询问/ 向量/ 的/ 论证/ 系统/ 的/ 协议/ 的/ 比较/ 如表/ 3/ 所示/ ,/ 前者/ 使用/ 了/ 较/ 少/ 的/ 加密/ 机制/ ,/ 前者/ 验证/ 者/ 发送/ 明确/ 的/ 询问/ 向量/ ,/ 而/ 后者/ 需要/ 证明/ 者/ 计算/ 加密/ 过/ 的/ 询问/ 向量/ 的/ 值/ ./ 然而/ ,/ 后者/ 提供/ 了/ 前者/ 没有/ 的/ 功能/ ,/ 支持/ 公开/ 验证/ 性/ 和/ 零/ 知识性/ ,/ 且/ 减少/ 了/ 交互/ 的/ 轮数/ ,/ 允许/ 初始/ 阶段/ 的/ 开销/ 在/ 相同/ 的/ 计算/ 中/ 的/ 所有/ 计算/ 实例/ 分摊/ ./ 表/ 3/ 基于/ 承诺/ 方案/ 和/ 使用/ 加密/ 询问/ 向量/ 的/ 协议/ 比较/ 交互/ 轮数/ 密码学/ 公开/ 验证/ 零/ 知识/ 初始/ 阶段/ 基于/ 交互式/ 证明/ 系统/ 的/ 可验证/ 计算/ 协议/ 与/ 基于/ 论证/ 系统/ 的/ 有/ 预处理/ 的/ 协议/ 的/ 比较/ 如表/ 2/ 所示/ ./ 前者/ 优点/ 主要/ 有/ 3/ 个/ ;/ (/ 1/ )/ 即使/ 对/ 有/ 无限/ 计算能力/ 的/ 证明/ 者/ 也/ 是/ 安全/ 的/ ,/ 而/ 后者/ 只是/ 针对/ 多项式/ 时间/ 的/ 证明/ 者/ 是/ 安全/ 的/ ;/ (/ 2/ )/ 交互式/ 证明/ 系统对/ 简单/ 的/ 并行计算/ 能/ 完全/ 不/ 需要/ 预处理/ 阶段/ ,/ 对/ 数据/ 并行/ 的/ 计/ Page9/ 算/ 预处理/ 阶段/ 开销/ 也/ 相对/ 较/ 小/ ,/ 而/ 论证/ 系统/ 中/ 验证/ 者/ 固有/ 地/ 需要/ 一个/ 预处理/ 阶段/ 且/ 开销/ 很大/ ;/ (/ 3/ )/ 交互式/ 证明/ 系统/ 在/ 它/ 适用/ 的/ 情况/ 下/ 可/ 使得/ 证明/ 者/ 的/ 开销/ 大大减少/ ,/ 并且/ 事实上/ 对/ 像/ 矩阵/ 乘法/ 这样/ 的/ 基本操作/ 完全/ 可以/ 避免/ 编译成/ 电路/ 的/ 开销/ ./ 具体/ 而言/ ,/ Zaatar/ 的/ 证明/ 者/ 是/ 比/ 没有/ 正确性/ 验证/ 的/ 计算/ 慢/ 大约/ 3/ 个/ 数量级/ ,/ 这/ 与/ CMT/ 中/ 实现/ 的/ GKR/ 中/ 证明/ 者/ 的/ 开销/ 大致/ 相符/ ,/ 但/ 由于/ 生成/ 计算/ 模型/ 的/ 开销/ ,/ 它/ 比/ CMT/ 为/ “/ 规范化/ ”/ 电路/ 实现/ 的/ 交互式/ 证明/ 系统/ 所/ 能/ 达到/ 的/ 速度/ 要/ 慢且/ 开销/ 大/ (/ 规范化/ 电路/ 是/ 指/ 易于/ 用/ 加法器/ 和/ 乘法器/ 计算/ 的/ 电路/ )/ ./ 交互式/ 证明/ 系统/ 也/ 有/ 其/ 固有/ 的/ 缺点/ :/ (/ 1/ )/ 它们/ 只/ 适用/ 于/ 深度/ 小/ 的/ 电路/ (/ 即/ 并行计算/ )/ ;/ (/ 2/ )/ 它们/ 不/ 支持/ “/ 非/ 规范化/ ”/ 电路/ ,/ 实际上/ 缺乏/ 对非/ 规范化/ 电路/ 的/ 支持/ 是/ 使用/ 交互式/ 证明/ 系统/ 所/ 固有/ 的/ ./ 这/ 意味着/ ,/ 某些/ 种类/ 的/ 计算/ ,/ 如/ 那些/ 涉及/ 许多/ 随机/ 访问/ 存储器/ 或/ 排序/ // 比较/ 操作/ 的/ 计算/ 在/ 交互式/ 证明/ 中是/ 有/ 一定/ 问题/ 的/ ;/ (/ 3/ )/ 交互式/ 证明/ 系统/ 不能/ 支持/ 有些/ 属性/ 像/ Pinocchio/ 的/ 零/ 知识性/ 和/ 公开/ 验证/ 性/ ;/ (/ 4/ )/ 交互式/ 证明/ 系统对/ 证明/ 者/ 和/ 验证/ 者/ 之间/ 的/ 互动/ 需要/ 多轮/ 的/ 对数/ 运算/ ,/ 而/ 论证/ 系统/ 通常/ 只/ 需要/ 一轮/ 或者/ 两轮/ 交互/ ./ 下/ 两节/ 将/ 按照/ 可验证/ 计算/ 协议/ 依据/ 证明/ 系统/ 的/ 分类/ 详述/ 每/ 一种/ 分类/ 的/ 相关/ 研究成果/ ,/ 其中/ ,/ 在/ 对/ 每/ 一种/ 分类/ 的/ 典型/ 系统/ 的/ 描述/ 基本/ 遵从/ 如下/ 顺序/ :/ 从/ 效率/ 最高/ 的/ 但/ 最/ 不/ 通用/ 的/ 协议/ 到/ 更为/ 通用/ 但/ 效率/ 较/ 低/ 的/ 协议/ ./ 6/ 基于/ 交互式/ 证明/ 系统/ 的/ 可验证/ 计算/ 协议/ 本文/ 首先/ 说明/ 交互式/ 证明/ 系统/ 是/ 如何/ 使/ 验证/ 者/ V/ 确信/ 它/ 接收/ 到/ 的/ 程序执行/ 结果/ 是/ 正确/ 的/ ,/ 如图/ 10/ 所示/ ./ 假设/ 要/ 执行/ 的/ 程序/ 是/ 计算/ 输入/ 为/ 狓/ 的/ 函数/ f/ ./ 首先/ ,/ 验证/ 者/ 在/ 把/ 输入/ 狓/ 和/ f/ 传输/ 给/ 证明/ 者/ ,/ 同时/ 随机/ 选取/ 关于/ 输入/ 的/ 低阶/ 多项式/ 扩展/ 函数/ 的/ 值/ [/ 17/ ]/ (/ 比如/ 加权/ 和/ )/ 作为/ 秘密/ s/ ,/ s/ 不/ 依赖于/ 要/ 执行/ 的/ 程序/ ,/ 因此/ 无需/ 在/ 输入/ 要/ 执行/ 的/ 程序/ 之前/ 选取/ 秘密/ s/ ./ 接下来/ ,/ P/ 和/ V/ 进行/ 一系列/ 交互/ (/ d/ 轮/ ,/ d/ 为/ 电路/ 层数/ )/ ,/ 这些/ 交互/ 的/ 目的/ 在于/ V/ 控制/ 并/ 引导/ P/ 从/ 生成/ V0/ (/ 0/ ,/ 0/ ,/ …/ ,/ 0/ )/ =/ 犚/ 0/ 递归/ 到/ Vd/ (/ 犣/ d/ )/ =/ 犚/ d/ (/ 从/ 一层/ 的/ 电路/ 门/ 的/ 值/ 的/ 低阶/ 多项式/ 扩展/ 函数/ 的/ 某个/ 点/ 的/ 值/ 递归/ 到/ 下/ 一层/ 的/ 电路/ 门/ 的/ 值/ 的/ 低阶/ 多项式/ 扩展/ 函数/ 的/ 某个/ 点/ 的/ 值/ ,/ 其中/ 低阶/ 多项式/ 扩展/ 函数/ 是/ 每层/ 的/ 线性组合/ ,/ 如/ 加权/ 和/ )/ ,/ Vd/ 是/ 输入/ x/ 的/ 低阶/ 多项式/ 扩展/ 函数/ ,/ V/ 此时/ 的/ 任务/ 就是/ 计算/ Vd/ 在/ 特定/ 点/ Zd/ 的/ 函数/ 值/ ,/ 并/ 检测/ 和/ P/ 的/ 回复/ 是否/ 一致/ ./ 在/ 这个/ 过程/ 中/ ,/ V/ 发送给/ P/ 询问/ 向量/ 犣/ i/ =/ (/ z1/ ,/ z2/ ,/ …/ ,/ zm/ )/ ,/ P/ 计算/ 犚/ i/ =/ Vi/ (/ 犣/ i/ )/ ,/ 用/ 犚/ i/ 回复/ V/ 的/ 询问/ ./ 这些/ 询问/ 向量/ (/ 一共/ d/ 个/ )/ 都/ 是/ 相关/ 的/ ,/ V/ 递归/ 检测/ P/ 对/ 所有/ 询问/ 向量/ 的/ 回复/ 是否/ 一致/ ./ V/ 随机/ 生成/ 的/ 询问/ 向量/ 使得/ P/ 对/ 第一个/ 询问/ 向量/ 的/ 回复/ 包含/ 所/ 执行/ 的/ 程序/ f/ 的/ 结果/ 的/ 声称/ 值/ ./ 同样/ 的/ ,/ P/ 对/ 最后/ 一个/ 询问/ 的/ 回复/ 包含/ 一个/ 关于/ V/ 的/ 输入/ 变量/ 的/ 低阶/ 多项式/ 扩展/ 函数/ 的/ 某个/ 点/ 的/ 值/ 的/ 声称/ 犚/ d/ ./ 如果/ P/ 对/ 所有/ 向量/ 的/ 回复/ 都/ 是/ 一致/ 的/ ,/ 且/ 声称/ 的/ 值/ 犚/ d/ 和/ 犚/ d/ 的/ 真实/ 值/ 相匹配/ ,/ 然后/ P/ 使得/ V/ 确信/ 其/ 遵守/ 了/ 协议/ ,/ 即/ 正确/ 的/ 执行/ 了/ 程序/ ,/ 因此/ 接受/ 结果/ ./ 否则/ ,/ V/ 知道/ P/ 在/ 某个/ 点/ 欺骗/ 它/ ,/ 因此/ 拒绝接受/ ./ 交互式/ 证明/ 系统/ 在/ 可验证/ 计算/ 协议/ 中/ 的/ 理论/ 应用/ 起源于/ GKR/ 协议/ [/ 18/ ]/ ,/ 代表/ 协议/ 有/ CMT/ [/ 53/ ]/ ,/ Allspice/ [/ 55/ ]/ ,/ Thaler/ 等/ 人/ [/ 54/ ]/ ./ Goldwasser/ 、/ Kalai/ 和/ Rothblum/ (/ GKR/ )/ 在/ 2008/ 年/ 提出/ 了/ 一个/ 强大/ 的/ 交互式/ 证明/ 系统/ 用于/ 验证/ 程序执行/ 的/ 正确性/ ./ 其中/ ,/ 验证/ 者/ 的/ 成本/ 随着/ 电路/ 的/ 深度/ 呈/ 线性/ 增长/ (/ 深度/ 小/ 意味着/ 程序/ 的/ 并行性/ 更好/ )/ ,/ 所以/ 该/ 系统/ 仅/ 实现/ 了/ 在/ 电路/ 具有/ 较/ 小/ 深度/ 时/ 的/ 一个/ 高效/ 验证/ ./ 而/ 实际/ 中/ 云/ 计算/ 中/ 的/ 大多/ 计算/ (/ 应用程序/ )/ 都/ 表现/ 出/ 大量/ 的/ 并行性/ ./ GKR/ 协议/ 如图/ 11/ 所示/ ,/ P/ 和/ V/ 就/ 输入/ 为/ 两个/ 变量/ (/ 输入/ 变量/ 和/ 声称/ 的/ 输出/ 变量/ )/ 的/ 函数/ 生成/ 的/ 分层/ 算术/ 电路/ 达成/ 共识/ ./ 算术/ 电路/ 就/ 像/ 布尔/ 电路/ 一样/ ,/ 只是/ 其/ 输入/ 是域/ F/ 中/ 的/ 元素/ ,/ 而/ 不是/ 布尔值/ ,/ 且/ 相比/ 之前/ 计算/ 与/ 或非/ 操作/ ,/ 算术/ 电路/ 是/ 执行/ 域/ F/ 上/ 的/ 加乘门/ 运算/ ./ 假设/ 电路/ 的/ 输出/ 层/ 是/ 层/ d/ ,/ 输入/ 层/ 是/ 层/ 0/ ./ GKR/ 协议/ 如下/ 迭代/ 运行/ ,/ 每/ 一轮/ 运行/ 对应/ 于/ 电路/ 的/ 每/ 一层/ ./ 第/ 1/ 轮/ 运行/ 中/ ,/ V/ 引导/ P/ 通过/ 一系列/ 的/ Page10/ 询问/ 向量/ 和/ 响应/ 从/ 声明/ 电路/ 的/ 输出/ 演绎/ 到/ 声明/ 秘密/ s/ ./ V/ 发送/ 的/ 询问/ 向量/ 可以/ 看作/ 有限/ 域/ F/ 中/ 的/ 随机/ 向量/ ,/ P/ 的/ 响应/ 是/ 低阶/ 多项式/ 的/ 值/ ,/ 每/ 一个/ 返回/ 的/ 多项式/ 的/ 值/ 依赖于/ 相应/ 的/ 询问/ 向量/ ./ 第/ 1/ 轮中/ 秘密/ s/ 是/ 层/ d/ -/ 1/ 的/ 电路/ 门/ 的/ 值/ 的/ 纠错码/ 的/ 几位/ 的/ 组合/ ./ 然而/ V/ 并/ 不能/ 直接/ 计算/ 这个/ s/ ,/ 要/ 计算/ s/ 必须/ 计算/ 电路/ 的/ 之前/ 所有/ 层/ ,/ 这样/ 会/ 使得/ 可验证/ 计算/ 协议/ 变得/ 毫无意义/ ./ 因此/ ,/ V/ 必须/ 使得/ P/ 能/ 告诉/ 它/ s/ 的/ 值/ ./ 同时/ V/ 必须/ 确认/ P/ 返回/ 的/ s/ 是/ 正确/ 的/ 而/ 不是/ 恶意/ 作假/ 的/ 值/ ./ 这/ 正是/ 第/ 2/ 轮要/ 实现/ 的/ 内容/ ,/ V/ 指引/ P/ 从/ 声明/ 秘密/ s/ 到/ 声明/ d/ -/ 2/ 层/ 电路/ 门值/ 的/ 纠错码/ 中/ 的/ 几位/ 的/ 组合/ ,/ 作为/ 新/ 的/ 秘密/ s/ ./ 如此/ 迭代/ ,/ 直到/ 输入/ 层/ ./ 这时/ ,/ 秘密/ 正是/ 输入/ 纠错码/ 的/ 几位/ 的/ 组合/ ,/ V/ 就/ 能/ 自己/ 预先/ 计算/ 这个/ 秘密/ ./ 任何/ 良好/ 的/ 纠错码/ 都/ 满足/ 属性/ :/ 如果/ x/ 和/ x/ 在/ 一个/ 地方/ 不同/ ,/ 那么/ Enc/ (/ x/ )/ 和/ Enc/ (/ x/ )/ 在/ 很多/ 地方/ 都/ 不同/ ./ 正是/ 由于/ Enc/ (/ x/ )/ 的/ 纠错码/ 具有/ 这样/ 的/ 属性/ ,/ 才/ 使得/ V/ 具有/ 强大/ 且/ 准确/ 的/ 验证/ 能力/ ./ 这样/ ,/ IP/ 协议/ 中/ ,/ 即使/ 是/ P/ 反转/ 了/ 一个/ 消息/ 中/ 的/ 一位/ ,/ 那么/ P/ 不得不/ 在/ 随后/ 的/ 一个点/ 做出/ 不/ 一致/ 的/ 声称/ ,/ 或者/ 不得不/ 在/ 秘密/ s/ 的/ 值/ 的/ 声称/ 的/ 几乎/ 每个/ 地方/ 都/ 撒谎/ ./ 这时/ V/ 就/ 能/ 以/ 很/ 高/ 的/ 频率/ 检测/ 到/ P/ 的/ 欺骗/ 行为/ ./ CMT/ 协议/ 和/ Thaler/ 协议/ 在/ 2012/ 年/ 实现/ 并/ 改进/ 了/ GKR/ 协议/ ./ CMT/ 协议/ 假设/ Vi/ 为/ 每层/ 电路/ 的/ 评估/ 函数/ ,/ 并/ 定义/ 了/ 两个/ 连接/ 谓词/ addi/ (/ g1/ ,/ g2/ ,/ g3/ )/ 和/ multi/ (/ g1/ ,/ g2/ ,/ g3/ )/ ,/ 使用/ 连接/ 谓词/ 来/ 表示/ 评估/ 函数/ ,/ 使得/ 评估/ 函数/ 的/ 形式/ 正好/ 与/ 和校验/ 协议/ 一样/ ,/ 从而/ 使用/ 和校验/ 协议/ 的/ d/ 个/ 实例/ (/ d/ 为/ 电路/ 的/ 层数/ )/ 来/ 校验/ 评估/ 函数/ ./ 协议/ 的/ 交互/ 要/ 使得/ 从/ 声明/ V0/ (/ 0/ )/ =/ 0/ 演绎/ 到/ 声明/ V1/ ,/ 进而/ 演绎/ 到/ V2/ ,/ 直到/ 输入/ 的/ 声明/ ,/ 这时/ ,/ V/ 就/ 可以/ 直接/ 检查/ 其/ 是否/ 正确/ ./ 协议/ 对/ CMT/ 适用/ 的/ 计算/ 种类/ 性能/ 比较/ 高/ ,/ 很/ 大部分/ 是因为/ CMT/ 协议/ 不/ 需要/ 密码学/ 操作/ 和/ 假设/ ./ CMT/ 使得/ 证明/ 者/ 的/ 运行/ 时间/ 从/ O/ (/ S/ / 3/ )/ 降低/ 到/ O/ (/ SlogS/ )/ ,/ 其中/ S/ 为/ 电路/ 门/ 的/ 数目/ ./ 实验/ 表明/ ,/ 验证/ 者/ 的/ 成本/ 是/ 非常低/ 的/ ,/ 但/ CMT/ 协议/ 对/ GKR/ 的/ 实现/ 有/ 两个/ 缺点/ :/ (/ 1/ )/ 证明/ 者/ 的/ 运行/ 时间/ 仍然/ 是/ 一个/ 瓶颈/ ,/ 其/ 相比/ 没有/ 正确性/ 保证/ 的/ 程序/ 多花/ 了/ 大约/ 3/ 个/ 数量级/ 的/ 开销/ ;/ (/ 2/ )/ 除非/ 该/ 电路/ 的/ 布线/ 满足/ “/ 规范化/ ”/ 条件/ (/ 电路/ 易于/ 加乘门/ 计算/ )/ ,/ 否则/ 验证/ 者/ 需要/ 一个/ 高/ 成本/ 的/ 预处理/ 阶段/ 来/ “/ 提取/ ”/ 关于/ 电路/ 的/ 布线/ 信息/ ./ Thaler/ 协议/ [/ 54/ ]/ 进一步/ 改进/ 了/ CMT/ ./ Thaler/ 对于/ 某些/ 种类/ 的/ 程序/ ,/ 证明/ 者/ 的/ 开销/ 可以/ 降低/ 为/ 本地/ 执行程序/ 所/ 需/ 开销/ 的/ 常数/ 级别/ ,/ 这/ 在/ 可验证/ 计算/ 协议/ 领域/ 是/ 非常/ 大/ 的/ 一个/ 改进/ ./ 首先/ ,/ 对于/ “/ 规范化/ ”/ 电路/ (/ 朴素/ naive/ 矩阵/ 乘法/ 、/ 模式匹配/ 和/ FFT/ 等/ 满足/ 此/ 条件/ )/ ,/ 证明/ 者/ 的/ 运行/ 时间/ 可/ 从/ O/ (/ SlogS/ )/ 降低/ 到/ O/ (/ S/ )/ ./ 具体/ 而言/ ,/ 对于/ 这些/ 电路/ ,/ 证明/ 者/ 现在/ 运行/ 速度/ 比/ 不能/ 保证/ 正确性/ 的/ 电路/ 计算/ 大约/ 慢/ 10/ 倍/ ./ 第二/ ,/ Thaler/ 协议/ 给出/ 了/ 用于/ 矩阵/ 乘法/ 的/ 一个/ 简单/ 协议/ ,/ 完全/ 去/ 除了/ 电路/ 表示/ 的/ 开销/ ,/ 使/ 证明/ 者/ 除/ 执行程序/ 的/ 开销/ 外/ ,/ 只/ 需/ O/ (/ n/ / 2/ )/ 的/ 开销/ 来/ 证明/ 程序执行/ 结果/ 是/ 正确/ 的/ ./ 然而/ ,/ 因为/ CMT/ 协议/ 最初/ 就是/ 为流/ 程序设计/ 的/ (/ 验证/ 者/ 处理/ 并/ 丢弃/ 输入/ )/ ,/ 使得/ Thaler/ 协议/ 更/ 适用/ 于流/ 程序/ ,/ 且/ 对模型/ 的/ 要求/ 有/ 很多/ 限制/ ,/ 要求/ 电路/ 必须/ 是/ 规范化/ 的/ 相似/ 并行/ 结构/ ./ 显然/ ,/ 并/ 不是/ 所有/ 应用程序/ 都/ 可以/ 用/ 这样/ 的/ 模型表示/ ./ 2013/ 年/ ,/ Allspice/ 协议/ [/ 55/ ]/ 对/ CMT/ 的/ 限制/ 条件/ 作/ 了/ 改进/ ,/ 使得/ 其/ 通用性/ 更强/ ,/ 并/ 将/ CMT/ 协议/ 和/ 后边/ 提到/ 的/ Zaatar/ 协议/ 集合/ 成/ 系统/ 的/ 子/ 协议/ 模块/ ,/ 通过/ 一个/ 静态/ 分析器/ 计算/ 各自/ 的/ 效率/ 来/ 决定/ 具体/ 使用/ 哪个/ 协议/ ./ 7/ 基于/ 论证/ 系统/ 的/ 有/ 预处理/ 的/ 可验证/ 计算/ 协议/ 7.1/ 使用/ 基于/ 承诺/ 方案/ 的/ 论证/ 系统/ 基于/ 承诺/ 方案/ 的/ 论证/ 系统/ ,/ 结合/ 承诺/ 方案/ 和/ 线性/ PCPs/ 来/ 构造/ 论证/ 系统/ ,/ 其/ 在/ 可验证/ 计算/ 系统/ 中/ 的/ 应用/ 起源于/ IKO/ 协议/ [/ 30/ ]/ ,/ 典型/ 协议/ 有/ Pepper/ [/ 56/ ]/ 、/ Ginger/ [/ 57/ ]/ 和/ Zaatar/ [/ 58/ ]/ ./ Ishai/ ,/ Kushilevitz/ 和/ Ostrovsky/ (/ IKO/ )/ 在/ 2007/ 年/ Page11/ 提出/ 了/ 一个/ 使用/ 线性/ PCPs/ [/ 20/ ]/ 代替/ shortPCPs/ [/ 68/ -/ 70/ ]/ (/ shortPCPs/ 是/ 之前/ 的/ 论证/ 系统/ 使用/ 的/ 非常复杂/ 的/ 复杂度/ 理论/ )/ 构造/ 论证/ 系统/ ,/ 从而/ 减少/ 了/ 证据/ 的/ 长度/ 和/ 复杂性/ ,/ 使得/ 可验证/ 计算/ 协议/ 的/ 实用性/ 有/ 了/ 很大/ 的/ 改进/ ./ 线性/ PCPs/ 是/ 指/ 证据/ π/ 是/ 线性/ 函数/ ,/ 即/ π/ (/ 狇/ 1/ +/ 狇/ 2/ )/ =/ π/ (/ 狇/ 1/ )/ +/ π/ (/ 狇/ 2/ )/ ,/ 狇/ 1/ 和/ 狇/ 2/ 是/ 询问/ 向量/ ./ 一个/ 线性/ 函数/ π/ :/ π/ (/ 狇/ )/ =/ 犕/ ·/ 狇/ ./ 特别/ 的/ ,/ 当/ b/ =/ 1/ 时/ ,/ π/ 返回/ 犕/ 和/ 输入/ 变量/ 的/ 点积/ ./ 对于/ 线性/ 函数/ ,/ 求其/ 给/ 定点/ 的/ 值/ 是/ 很/ 容易/ 的/ ./ 下面/ 详细描述/ IKO/ 协议/ 原理/ ,/ 主要/ 分为/ 两个/ 部分/ :/ 假设/ 证据/ π/ 是/ 有限/ 域/ 上/ 的/ 线性/ 函数/ ,/ 第一/ 部分/ 说明/ π/ 的/ 编码/ 和/ 构造/ 线性/ PCPs/ ;/ 第二/ 部分/ 说明/ V/ 如何/ 和/ π/ (/ P/ )/ 交互/ ./ 首先/ ,/ 说明/ π/ 如何/ 编码/ 原始/ 证据/ (/ 即/ 电路/ 的/ 可/ 满足/ 性/ 赋值/ )/ 的/ ,/ V/ 首先/ 构造/ 一个/ 多项式/ P/ (/ 犣/ )/ ,/ 使得/ P/ (/ 狕/ )/ =/ 0/ 和/ 高级/ 程序/ 编译/ 生成/ 的/ 电路/ C/ 的/ 可/ 满足/ 赋值/ 狕/ 是/ 等价/ 的/ ,/ π/ 的/ 构造/ 必须/ 能/ 求解/ 此/ 多项式/ ./ P/ (/ 犣/ )/ 按/ 如下/ 方式/ 构造/ :/ 对于/ C/ (/ 一共/ s/ 个/ 电路/ 门/ )/ 中/ 的/ 每个/ 门/ ,/ V/ 构造/ 一个/ 变量/ 犣/ i/ ∈/ {/ 0/ ,/ 1/ }/ 来/ 表示/ 电路/ 门/ i/ 的/ 输出/ ./ 同时/ ,/ V/ 依照/ 表/ 4/ 中/ 的/ 规则/ 构造/ 一个/ 算术/ 约束/ ./ 如果/ 门/ i/ 是/ 犣/ j/ 和/ 犣/ k/ 的/ 与/ 门/ ,/ 那么/ V/ 构造/ 约束/ 犣/ i/ -/ 犣/ j/ ·/ 犣/ k/ =/ 0/ ;/ 如果/ 门/ i/ 是/ 犣/ j/ 的/ 非门/ ,/ 那么/ 构造/ 约束/ 1/ -/ (/ 犣/ i/ +/ 犣/ j/ )/ =/ 0/ ;/ 如果/ 门/ i/ 是/ 第/ j/ 个/ 输入/ 的/ 输入/ 门/ ,/ 那么/ 构造/ 约束/ 犣/ i/ -/ inj/ =/ 0/ ;/ 针对/ 表示/ 电路/ 输出/ 的/ 最后/ 一个/ 门/ 构造/ 约束/ 犣/ s/ -/ 1/ =/ 0/ ./ 通过/ 组合/ 所有/ 的/ 约束/ 来/ 构造/ 多项式/ P/ (/ 犣/ )/ :/ P/ (/ 犣/ )/ =/ ∑/ i/ 犣/ =/ (/ 犣/ 1/ ,/ …/ ,/ 犣/ s/ )/ ,/ 每/ 一个/ Qi/ (/ 犣/ )/ 由/ 一个/ 约束/ (/ 比如/ 犣/ i/ -/ 犣/ j/ ·/ 犣/ k/ =/ 0/ )/ 给定/ ./ vi/ 是/ V/ 从/ 有限/ 域/ 因为/ {/ Qi/ (/ 犣/ )/ }/ 都/ 是/ 度/ 为/ 2/ 的/ 函数/ ,/ V/ 可以/ 把/ P/ (/ 犣/ )/ 表示/ 如下/ :/ / 式/ 中/ :/ {/ r2/ ,/ r1/ ,/ r0/ }/ 由/ {/ Qi/ (/ 犣/ )/ }/ 和/ {/ vi/ }/ 决定/ ,/ r2/ ∈/ / s/ ,/ r0/ ∈/ / ./ 这样/ V/ 可以/ 通过/ 询问/ 〈/ r2/ ,/ 狕/ / 狕/ 〉/ 和/ 〈/ r1/ ,/ 狕/ 〉/ 的/ 值/ 进而/ 计算/ P/ (/ 狕/ )/ ./ 为了/ 说明/ 编码/ ,/ 这里/ 令/ 〈/ 狓/ ,/ 狔/ 〉/ 表示/ 两个/ 向量/ 狓/ 和/ 狔/ 的/ 内积/ ,/ 令/ 狓/ / 狔/ 表示/ 外积/ 狓/ ·/ 狔/ T/ ./ 由此/ ,/ 可以/ 构造/ 一个/ 正确/ 的/ 证据/ 神谕/ π/ 来编/ (/ 1/ )/ ,/ π/ 码/ 电路/ C/ 的/ 可/ 满足/ 赋值/ 狕/ ,/ 写作/ 〈/ 狕/ ,/ 狕/ / 狕/ 〉/ ,/ 意味着/ π/ =/ (/ π/ 狕/ / 狕/ 〉/ ./ 以下/ 解释/ P/ (/ 狕/ )/ =/ 0/ 和/ 狕/ 是/ 可/ 满足/ 赋值/ 的/ 等价/ 性/ ,/ 首先/ 这里/ 假设/ 给/ V/ 的/ 是/ 语义/ 正确/ 但/ 不可/ 满足/ 的/ π/ ,/ 也就是说/ ,/ π/ =/ 〈/ 狕/ ,/ 狕/ / 狕/ 〉/ ,/ 但是/ 狕/ 是/ 不可/ 满足/ 赋值/ ./ 那么/ 要/ 使得/ P/ (/ 狕/ )/ =/ 0/ ,/ 必然/ 存在/ 至少/ 一个/ i/ 使得/ Qi/ (/ 狕/ )/ ≠/ 0/ ,/ 也就是说/ 当且/ 仅/ 当/ vi/ ·/ Qi/ (/ 狕/ )/ =/ vi/ ·/ Qi/ (/ 狕/ )/ ,/ 测试/ 才/ 可以/ 通过/ ./ 这种/ 概率/ 是/ 很/ 低/ -/ ∑/ i/ ≠/ i/ 的/ ,/ {/ vi/ }/ 是/ 在/ 狕/ 之后/ 选择/ 的/ ,/ 所以/ 出错/ 的/ 概率/ 不会/ 超过/ 1/ // / ./ 接着/ 说明/ V/ 和/ π/ (/ P/ )/ 的/ 交互/ ./ 如图/ 12/ 所示/ 在/ V/ 发送/ f/ 和/ 狓/ 并/ 获得/ P/ 执行/ 的/ 结果/ 狔/ 之后/ ,/ V/ 执行/ 承诺/ 方案/ 的/ 承诺/ 阶段/ ,/ 验证/ 者/ V/ 选取/ 随机/ 向量/ 狉/ ∈/ / 应用/ 同态/ 加密算法/ (/ 这里/ 并不需要/ 假设/ 加密/ 函数/ 是/ 全/ 同态/ 的/ [/ 76/ ]/ )/ 得到/ Enc/ (/ 狉/ )/ 发送给/ 证明/ 者/ P/ ,/ P/ 计算/ Enc/ (/ π/ (/ 狉/ )/ )/ 并/ 发送给/ V/ ,/ 然后/ V/ 生成/ 针对/ PCP/ 方案/ 的/ / =/ 14/ 个/ 询问/ 向量/ 和/ 针对/ 承诺/ 方案/ 的/ / =/ 14/ 个/ 询问/ 向量/ ,/ P/ 响应/ V/ 的/ 询问/ 向量/ ./ 这轮/ 交互/ 也/ 说明/ 了/ V/ 可以/ 通过/ 针对/ π/ 的/ 常数/ 个/ 询问/ 向量/ 就/ 可以/ 验证/ 电路/ 是否/ 可/ 满足/ ./ PCP/ 方案/ 验证/ 分为/ 4/ 类/ :/ 第/ 1/ 类/ 称为/ 电路/ 测试/ ,/ 验证/ P/ (/ 狕/ )/ =/ 0/ 是否/ 成立/ ./ V/ 选择/ 狇/ 12/ ∈/ R/ / 狇/ 14/ ∈/ R/ / (/ π/ (/ 狇/ 11/ )/ -/ π/ (/ 狇/ 12/ )/ )/ +/ (/ π/ (/ 狇/ 13/ )/ -/ π/ (/ 狇/ 14/ )/ )/ +/ r0/ 是否/ 等于/ 0/ ,/ 即/ π/ 路/ C/ 的/ 可/ 满足/ 赋值/ 且/ π/ 被/ 正确/ 的/ 计算/ 了/ ,/ 那么/ z/ 同样/ 满足/ 所有/ 的/ {/ Qi/ (/ 犣/ )/ }/ ,/ P/ (/ 狕/ )/ =/ 0/ ,/ 验证/ 就/ 可以/ 通过/ ./ 如果/ 狕/ 不是/ 可/ 满足/ 赋值/ ,/ 这/ 同时/ 意味着/ C/ 不可/ 满足/ ,/ 那么/ {/ vi/ }/ 选择/ 的/ 随机性/ 使得/ P/ (/ 狕/ )/ 不/ 可能/ 等于/ 0/ ,/ V/ 以/ 极大/ 的/ 概率/ 拒绝/ ./ 第/ 2/ 类/ 称为/ 线性/ 测试/ [/ 77/ -/ 78/ ]/ ,/ 验证/ 对于/ 狕/ ,/ π/ Page12/ 〈/ ·/ ,/ u/ 〉/ 是否/ 成立/ ,/ V/ 针对/ π/ 验证/ 响应/ 结果/ ./ 狇/ 1/ ,/ 狇/ 2/ ∈/ R/ / 狇/ 1/ +/ 狇/ 2/ ,/ 狇/ 6/ =/ 狇/ 4/ +/ 狇/ 5/ ./ 如果/ 验证/ 通过/ ,/ V/ 就/ 可以/ 确认/ (/ 2/ )/ 和/ π/ π/ 验证/ 两个/ 线性/ 函数/ 的/ 形式/ 是否/ 正确/ ,/ 也就是说/ 检测/ u/ =/ 狕/ / 狕/ ./ V/ 构造/ 4/ 个/ 查询/ 并/ 响应/ 验证/ 结果/ ./ 狇/ 7/ ,/ 狇/ 8/ ∈/ s/ 和/ 狇/ 10/ ∈/ R/ / R/ / 通过/ ,/ 电路/ 测试/ 才/ 有效/ ./ 线性/ 测试/ 、/ 二次/ 正交/ 测试/ 和/ 电路/ 测试/ 是/ 为了/ 解除/ 电路/ 测试/ 中/ π/ (/ 2/ )/ 和/ π/ (/ 1/ )/ 是/ 互相/ 一致/ 的/ 线性/ 函数/ 的/ 假设/ ./ 也就是说/ 若/ 假设/ π/ 是/ 无效/ 的/ ,/ 它/ 编码/ 的/ 一定/ 是/ 不可/ 满足/ 的/ 赋值/ ,/ 而/ 实际上/ 一个/ 恶意/ 构造/ 的/ 神谕/ π/ 可能/ 不/ 满足/ 这个/ 假设/ ./ 第/ 4/ 类/ 测试/ 称为/ 一致性/ 测试/ ,/ 使用/ 基于/ 同态/ 加密/ 的/ 承诺/ 方案/ ./ 测试/ P/ 的/ 响应/ 是否/ 和/ 之前/ 对/ (/ π/ 的/ )/ PCPs/ 的/ 线性/ 特征/ 做出/ 的/ 承诺/ 相一致/ ./ 在/ 承诺/ 方案/ 的/ 公开/ 阶段/ ,/ V/ 解密/ 得到/ π/ (/ r/ )/ ,/ 选取/ 随机/ 向量/ 狇/ ∈/ / 发送/ (/ 狇/ ,/ r/ +/ α/ 狇/ )/ 给/ P/ ,/ 获得/ P/ 返回/ 的/ π/ (/ 狇/ )/ 和/ α/ ∈/ / π/ (/ r/ +/ α/ 狇/ )/ ,/ α/ 是从/ 域/ π/ (/ r/ +/ α/ 狇/ )/ =/ π/ (/ r/ )/ +/ α/ π/ (/ 狇/ )/ 是否/ 成立/ ./ 通过/ 并行/ 运行/ 承诺/ 方案/ 的/ 多个/ 实例/ (/ 每/ 一次/ V/ 需要/ 询问/ π/ 都/ 需要/ 一个/ 实例/ ,/ 仿佛/ P/ 的/ 响应/ 是/ 由/ 若干个/ 非/ 共谋/ 神谕/ 提供/ 的/ ,/ 每/ 一个/ PCP/ 询问/ 由/ 一个/ 神谕/ 提供/ )/ ,/ IKO/ 协议/ 把/ 使用/ 线性/ 函数/ 的/ PCP/ 协议/ 转换成/ 论证/ 系统/ [/ 19/ ,/ 24/ ]/ ./ 如果/ C/ 是/ 可/ 满足/ 的/ ,/ 那么/ V/ 一定/ 相信/ π/ ,/ 否则/ ,/ C/ 是/ 不可/ 满足/ 的/ ,/ V/ 让/ 测试通过/ 的/ 概率/ 不/ 超过/ 常数/ κ/ (/ 对于/ 任意/ 珘/ π/ )/ ./ 如果/ 重复/ ρ/ 次/ ,/ 构造/ 询问/ μ/ =/ 2/ / ·/ ρ/ 个/ ,/ 那么/ 可靠性/ 错误/ ε/ =/ κ/ ρ/ ./ 然而/ ,/ IKO/ 无法/ 用于/ 实际/ ,/ 其/ 对/ 验证/ 者/ 需要/ 高/ 开销/ 的/ 预处理/ 阶段/ ./ 即使/ 是/ 对/ 一个/ m/ ×/ m/ 的/ 矩阵/ 乘法/ ,/ 验证/ 者/ 的/ 开销/ 也/ 达到/ 109/ ·/ m6/ ,/ 要/ 比/ 本地/ 执行/ 矩阵/ 乘法/ 的/ 开销/ 多/ 109/ ·/ m3/ ./ 这些/ 开销/ 来源于/ 程序/ 的/ 编码/ 编译/ 、/ 大量/ 的/ 密码学/ 承诺/ 和/ 大量/ 的/ 初始/ 阶段/ 开销/ ./ 虽然/ IKO/ 协议/ 通过/ 承诺/ 方案/ 降低/ 了/ 证据/ 的/ 复杂性/ 和/ 长度/ ,/ 却/ 使得/ 并行/ 承诺/ 开销/ 很大/ ./ 承诺/ 需要/ 密码学/ 操作/ ,/ IKO/ 协议/ 过度/ 的/ 调用/ 承诺/ 实例/ 使得/ 协议/ 无法/ 用于/ 实践/ ./ Pepper/ [/ 56/ ]/ 和/ Ginger/ [/ 57/ ]/ 在/ 2012/ 年/ 改进/ IKO/ 协议/ ,/ 使得/ 协议/ 有效/ 的/ 支持/ 批处理/ ,/ 大大/ 减小/ 了/ 验证/ 者/ 和/ 证明/ 者/ 的/ 开销/ ./ 利用/ 批处理/ (/ 同一个/ 程序/ 的/ 不同/ 输入/ 实例/ )/ 来/ 分摊/ 验证/ 者/ 初始/ 阶段/ 的/ 开销/ ./ 通常/ 需要/ 大量/ 实例/ 并行/ 才/ 可以/ 使得/ 协议/ 有/ 实际意义/ ./ Pepper/ 相比/ IKO/ 的/ 直接/ 实现/ 开销/ 降低/ 了/ 1017/ ./ 用/ 算术/ 电路/ 代替/ 布尔/ 电路/ 并/ 简化/ 算术/ 电路/ 减少/ 了/ 程序/ 编码/ 的/ 开销/ ;/ 通过/ 降低/ 承诺/ 实例/ 的/ 调用/ 降低/ 了/ 承诺/ 的/ 开销/ ,/ 如图/ 13/ 可以/ 看出/ ,/ 相比/ IKO/ ,/ Pepper/ 不/ 需要/ 每次/ 询问/ 证据/ π/ 时/ 都/ 调用/ 一次/ 承诺/ 实例/ ,/ 同时/ 提供/ 了/ 更好/ 的/ 安全性/ ;/ 通过/ 批处理/ 来/ 分摊/ 验证/ 者/ 的/ 开销/ ,/ 图/ 13/ 中/ 标识/ 的/ 消息/ 在/ 批处理/ 的/ 多个/ 实例/ 中/ 只/ 需/ 执行/ 一次/ ;/ 针对/ 特殊/ 场景/ 降低/ 了/ PCP/ 编码/ 的/ 冗余度/ 从而/ 减少/ 了/ 证明/ 者/ P/ 的/ 开销/ ./ Pepper/ 协议/ 中/ 证明/ 了/ 这些/ 改进/ 并/ 没有/ 改变/ IKO/ 协议/ 的/ 完备/ 性/ 和/ 可靠性/ ./ 然而/ Pepper/ 协议/ 的/ 计算/ 开销/ 和/ 网络/ 开销/ 依然/ 很大/ ,/ 适用/ 的/ 应用/ 种类/ 有限/ ,/ 局限于/ 顺序/ 结构/ 的/ 数值/ 计算/ ./ Ginger/ 协议/ [/ 57/ ]/ 进一步/ 降低/ 了/ 开销/ ,/ 其/ 证明/ 了/ 一致性/ 测试/ 是/ 包含/ 线性/ 测试/ 的/ ,/ 即使/ 是/ 一个/ 恶意/ 的/ 证明/ 者/ 也/ 一定/ 会/ 提供/ 线性/ 的/ π/ ,/ 从而/ 去/ 除了/ 图/ 13/ 中/ 的/ PCP/ 验证/ 的/ 线性/ 测试/ ./ 如图/ 14/ 所示/ ,/ V/ 以/ 如下/ 方式/ 构造/ 查询/ :/ 狇/ 1/ ,/ 狇/ 2/ ∈/ R/ / 狇/ 5/ ←/ r1/ +/ 狇/ 1/ ,/ 狇/ 6/ ←/ r2/ +/ 狇/ 4/ ,/ 且/ 在/ 二次/ 正交/ 测试/ 和/ 电路/ 测试/ 中/ 重用/ 了/ 部分/ 询问/ 向量/ ,/ 使得/ 一个/ 实例/ 中/ PCP/ 验证/ 中/ 询问/ 的/ 次数/ 从/ 13/ 降到/ 了/ 6/ ,/ 进一步/ 降低/ 了/ 询问/ 的/ 次数/ ./ Ginger/ 协议/ 扩大/ 了/ 应用/ 的/ 适用/ 类型/ ,/ 使得/ 程序/ 包括/ 浮点数/ 、/ 不/ 等/ 测试/ 、/ 逻辑/ 表达式/ ,/ 条件/ 语句/ 等等/ ./ 但/ 仍/ 不能/ 很/ 好/ 的/ 处理/ 循环/ ./ 且/ 相/ 比较/ Pepper/ ,/ Ginger/ 编译器/ 可以/ 自动/ 完成/ 绝大部分/ 程序/ 的/ 编译/ ./ Page13/ 然而/ Ginger/ 协议/ 有/ 一个/ 严重/ 的/ 问题/ ,/ 就是/ 证明/ 者/ 的/ 每个/ 实例/ 的/ 工作/ 和/ 验证/ 者/ 生成/ 询问/ 向量/ 的/ 初始/ 阶段/ 的/ 开销/ 是/ 计算/ 规模/ 大小/ 的/ 二次方/ ./ Ginger/ 针对/ 特定/ 程序/ (/ 比如/ 矩阵/ 乘/ )/ 通过/ 手工/ 裁剪/ 证据/ 向量/ 和/ 询问/ 向量/ 来/ 解决/ 这个/ 问题/ ,/ 但是/ 这/ 只/ 适用/ 于/ 某些/ 应用/ 场景/ ./ Pepper/ 和/ Ginger/ 协议/ 仅仅/ 在/ 有/ 重复/ 结构/ 的/ 顺序/ 结构/ 程序/ 是/ 有/ 意义/ ,/ 而且/ 他们/ 针对/ 不同/ 的/ 应用程序/ 需要/ 特殊/ 构造/ 的/ PCP/ ./ 且/ 为了/ 使得/ Pepper/ 和/ Ginger/ 协议/ 获得/ 好/ 的/ 性能/ 从而/ 能/ 用于/ 实际/ ,/ 在/ 程序/ 的/ 通用性/ 上/ 做/ 了/ 限制/ ,/ 只/ 适用/ 于/ 特定/ 种类/ 的/ 程序/ ./ Zaatar/ 协议/ 保留/ 了/ Pepper/ 和/ Ginger/ 协议/ 的/ 大部分/ 结构/ ,/ 并/ 对/ 其/ 做/ 了/ 改进/ ,/ 引入/ 了/ (/ GGPR/ )/ [/ 28/ ]/ 中/ 的/ 基于/ QAPs/ 的/ 线性/ PCP/ 取代/ 了/ Arora/ 等/ 人/ [/ 20/ ]/ 中/ 的/ 线性/ PCP/ ,/ 和/ Ginger/ 协议/ 的/ 承诺/ 方案/ 相结合/ ,/ 使得/ 验证/ 者/ 的/ 初始/ 阶段/ 的/ 开销/ 和/ 证据/ π/ 的/ 长度/ 等于/ 程序运行/ 时间/ 和/ 程序/ 长度/ 之/ 和/ 的/ 线性/ 函数/ ,/ 从而/ 使得/ 证明/ 者/ 的/ 开销/ 接近/ 线性/ ./ 虽然/ 这种/ 编码/ 引入/ 了/ 额外/ 的/ 开销/ ,/ 但/ 这些/ 开销/ 相对/ Ginger/ 协议/ 以及/ 之前/ 的/ 同类/ 协议/ 来说/ 仍旧/ 是/ 最/ 优秀/ 的/ ./ 证明/ 者/ 的/ 开销/ 和/ Ginger/ 中/ 最优化/ 的/ 手动/ 构造/ 的/ 程序/ 协议/ 基本一致/ ./ 在/ 大部分/ 程序/ 种类/ 中/ ,/ 基本/ 取代/ 了/ Pepper/ 和/ Ginger/ 协议/ ./ Zaatar/ 协议/ 可以/ 自动/ 将/ 程序/ 编译成/ 约束/ 集/ ,/ Pepper/ 和/ Ginger/ 协议/ 都/ 是/ 手动/ 构造/ 的/ ./ 基于/ 一些/ 基准/ 测试/ (/ 排序/ 、/ 聚类分析/ 、/ 最短/ 路径/ )/ ,/ Zaatar/ 协议/ 的/ 证明/ 者/ 的/ 性能/ 降低/ 了/ 3/ ~/ 6/ 个/ 数量级/ ,/ 验证/ 者/ 的/ 性能/ 也/ 降低/ 了/ 3/ ~/ 6/ 个/ 数量级/ ,/ 因而/ 验证/ 者/ 的/ 批处理/ 实例/ 可以/ 降低/ 到/ 上/ 千个/ 计算/ ./ 同时/ 由于/ 用户/ 愿意/ 为/ 安全/ 保证/ 付出/ 一定/ 的/ 代价/ ,/ 这/ 使得/ Zaatar/ 协议/ 在/ 实际/ 应用/ 中/ 的/ 开销/ 已经/ 可以/ 接受/ ,/ 且/ 批处理/ 和/ 付费/ 问题/ 等/ 特征/ 和/ 云/ 计算/ 的/ 当前/ 应用/ 也/ 一致/ ./ 比如说/ ,/ 大规模/ 的/ 科学/ 模拟计算/ 通常/ 有/ 重复/ 的/ 结构/ ,/ MapReduce/ 程序/ 的/ map/ 阶段/ 也/ 如此/ ,/ 但是/ 由于/ 其/ 使用/ 的/ 计算/ 模型/ 的/ 局限性/ ,/ 使得/ Zaatar/ 协议/ 还/ 无法/ 应用/ 于云/ 计算/ 场景/ ,/ 因为/ 它/ 需要/ 验证/ 者/ 本地/ 拥有/ 所有/ 的/ 输入/ ./ 为了/ 使得/ Zaatar/ 协议/ 能/ 应用/ 于/ MapReduce/ 程序/ ,/ 需要/ 修改/ 协议/ ,/ 使得/ 协议/ 能够/ 处理/ 远程/ 输入/ 的/ 场景/ ,/ 比如/ 下/ 一节/ 介绍/ 的/ 和/ 不可/ 信/ 存储/ [/ 64/ -/ 65/ ,/ 79/ -/ 80/ ]/ 集成/ 的/ Pantry/ 协议/ ./ 7.2/ 使用/ 加密/ 询问/ 向量/ 的/ 论证/ 系统/ 相比/ 使用/ 基于/ 承诺/ 方案/ 的/ 论证/ 系统/ ,/ 使用/ 加密/ 询问/ 向量/ 的/ 论证/ 系统/ 需要/ 验证/ 者/ 预先/ 加密/ 它/ 的/ 询问/ 向量/ ,/ 证明/ 者/ 无法/ 看到/ 询问/ 的/ 实际/ 内容/ ./ 随后/ ,/ 在/ 验证/ 阶段/ ,/ 验证/ 者/ 和/ 证明/ 者/ 使用/ 复杂/ 的/ 密码学/ 协议/ 实现/ 如下/ 的/ 流程/ :/ 证明/ 者/ 回答/ 询问/ 向量/ ,/ 而/ 不能/ 分辨/ 询问/ 向量/ 询问/ 的/ 证据/ 的/ 位置/ ,/ 验证/ 者/ 用/ 密钥/ 解密/ 验证/ 者/ 的/ 响应/ ./ 有/ 了/ 证明/ 者/ 的/ 响应/ ,/ 验证/ 者/ 继续执行/ PCP/ 验证/ ,/ 就/ 如/ 使用/ 基于/ 承诺/ 方案/ 的/ 论证/ 系统/ 的/ 协议/ 一样/ ./ 这个/ 方法/ 在/ 文献/ [/ 28/ ,/ 66/ ]/ 中/ 详细/ 说明/ ,/ 文献/ [/ 59/ -/ 60/ ]/ 改进/ 和/ 实现/ 了/ 该/ 方法/ ./ Parno/ 等/ 人/ [/ 59/ ]/ 提出/ Pinocchio/ 协议/ ,/ 其/ 第一次/ 使用/ 了/ 加密/ 询问/ 向量/ 的/ 论证/ 系统/ 的/ 方法/ ,/ 这/ 对于/ 用户/ 的/ 隐私/ 有/ 重要/ 的/ 意义/ ./ Pinocchio/ 协议/ 不但/ 实现/ 了/ GGPR/ 中/ 的/ 证据/ 编码/ ,/ 还/ 实现/ 了/ 其/ 复杂/ 的/ 密码学/ 协议/ ,/ 使得/ Pinocchio/ 协议/ 具有/ 零/ 知识性/ 和/ 公开/ 可验证/ 性/ ,/ 任何/ 拥有/ 密钥/ 的/ 用户/ 都/ 可以/ 验证/ 程序/ 是否/ 正确/ 执行/ ,/ 只要/ 其/ 生成/ 的/ 询问/ 向量/ 是/ 正确/ 的/ ./ 加密/ 询问/ 向量/ 的/ 论证/ 系统/ 很大/ 的/ 一个/ 优点/ 是/ 可以/ 重用/ 询问/ 向量/ ,/ 大大减少/ 了/ 询问/ 向量/ 生成/ 的/ 时间/ ,/ 而且/ 使得/ 协议/ 中/ 交互/ 的/ 次数/ 更/ 少/ ,/ 在/ 每/ 一个/ 程序/ 的/ 初始/ 阶段/ 之后/ ,/ 验证/ 者/ 只/ 需/ 发送/ 每/ 一个/ 实例/ 的/ 输入/ 数据/ 即可/ ,/ 所以/ 也/ 称为/ 无/ 交互/ 的/ 论证/ 系统/ ./ 从/ 定性/ 的/ 分析/ 来看/ ,/ Pinocchio/ 协议/ 具有/ 更好/ 的/ 分摊/ 性/ ./ 如图/ 15/ 所示/ Pinocchio/ 协议/ 可以/ 把/ 每/ 一个/ 程序/ 的/ 初始/ 阶段/ 的/ 开销/ 分摊/ 给/ 未来/ 的/ 所有/ 此/ 程序/ 的/ 实例/ ,/ 而/ 使用/ 基于/ 承诺/ 的/ 论证/ 系统/ 的/ 可验证/ 计算/ 协议/ 只是/ 把/ 每/ 一个/ 程序/ 的/ 初始/ 阶段/ 开销/ 分摊/ 给/ 一次/ 批处理/ 中/ 的/ 所有/ 实例/ ./ 虽然/ 复杂/ 的/ 密码学/ 协议/ 的/ 应用/ 相比/ 基于/ 承诺/ 的/ 协议/ 而言/ 给/ 初始/ 阶段/ 带来/ 了/ 一些/ 额外/ 的/ 开销/ ,/ 但/ 这些/ 开销/ 比较/ 小/ ,/ 而且/ 通过/ 分摊/ 可以/ 使/ 开销/ 忽略不计/ ./ 图/ 15Pinocchio/ 和/ 基于/ 承诺/ 方案/ 的/ 协议/ 区别/ 尽管/ Pinocchio/ 协议/ 已经/ 在/ 可验证/ 计算/ 领域/ 取得/ 了/ 很大/ 的/ 突破/ ,/ 但是/ 其所/ 采用/ 的/ 计算/ 模型/ 仍/ 不能/ Page14/ 很/ 好/ 的/ 表示/ 通用/ 程序/ ./ 首先/ ,/ 协议/ 需要/ 在/ 编译/ 时/ 定义/ 循环/ 的/ 次数/ ./ 其次/ ,/ 不/ 支持/ 间接/ 内存/ 引用/ ,/ 这/ 就/ 无法/ 表示/ 通用/ 程序/ 中/ 的/ RAM/ 操作/ ./ 第三/ ,/ 这些/ 程序/ 不/ 支持/ 远程/ 输入/ ,/ 也就是说/ 验证/ 者/ 必须/ 处理/ 所有/ 的/ 输入/ 和/ 输出/ ,/ 这/ 就/ 无法/ 表示/ MapReduce/ 程序/ ,/ 远程/ 数据库/ 查询/ 等等/ ,/ 无法/ 适用/ 于云/ 计算/ 中/ ./ Pantry/ 协议/ [/ 60/ ]/ 对/ 其/ 进行/ 了/ 进一步/ 的/ 改进/ ,/ 把/ Pinocchio/ 协议/ 和/ 不可/ 信/ 存储技术/ [/ 62/ -/ 65/ ,/ 79/ -/ 81/ ]/ 相结合/ ,/ 引入/ 了/ 存储/ 的/ 概念/ ,/ 使用/ Merkle/ -/ hash/ 树/ 技术/ 来/ 支持/ 内存/ 随机存取/ ,/ 其中/ hash/ 函数/ 采用/ Ajtai/ [/ 82/ -/ 83/ ]/ ,/ 其/ 相比/ SHA/ -/ 1/ ,/ 时间/ 开销/ 只是/ 其/ 10/ %/ ./ Pantry/ 协议/ 定义/ 了/ 如图/ 16/ 两个/ 基本/ 原语/ PutBlock/ 和/ GetBlock/ ,/ 使用/ 编译器/ 将/ 其/ 表示/ 成/ 约束/ 集/ CH/ 和/ CH/ 然后/ 使用/ PutBlock/ 和/ GetBlock/ 来/ 构建/ 可验证/ 的/ MapReduce/ 、/ 可验证/ 的/ RAM/ 、/ 远程/ 数据库/ 的/ 可验证/ 的/ 查询/ ./ 以/ MapReduce/ 为例/ 说明/ ,/ 如图/ 17/ 所示/ ,/ 程序员/ 使用/ C语言/ 和/ block/ =/ GetBlock/ (/ name/ )/ 和/ name/ =/ PutBlock/ (/ block/ )/ 原语/ 来/ 构建/ 可验证/ 的/ MapReduce/ 框架/ ,/ 只是/ 输入/ 和/ 输出/ 文件/ 用/ 其/ 内容/ 的/ 摘要/ 来/ 表示/ ./ 如此/ 构造/ 的/ 程序/ ,/ Pantry/ 协议/ 则/ 可以/ 直接/ 把/ 程序/ 作为/ Pinocchio/ 协议/ 的/ 输入/ 程序/ 来/ 处理/ ./ 同时/ Pantry/ 也/ 可以/ 集成/ Zaatar/ 协议/ ,/ 只是/ 如果/ 要/ 提供/ 公开/ 可验证/ 性/ 和/ 零/ 知识性/ ,/ 就/ 必须/ 集成/ Pinocchio/ 协议/ 处理/ ./ Pantry/ 协议/ 是/ 目前/ 处理/ 验证/ 者/ 不/ 包含/ 所有/ 输入/ 的/ 程序/ 的/ 可验证/ 计算/ 的/ 唯一/ 协议/ ./ 由于/ Pantry/ 协议/ 中/ 验证/ 者/ 不/ 处理/ 输入/ ,/ 节省/ 了/ CPU/ 和/ 网络/ 开销/ ./ 但是/ 由于/ hash/ 函数/ 的/ 开销/ 很大/ ,/ 使得/ Pantry/ 协议/ 无法/ 适用/ 于/ 内存/ 密集型/ 程序/ ./ 而且/ 由于/ hash/ 函数/ 的/ 开销/ ,/ 使得/ 需要/ 很多/ 的/ 计算/ 实例/ 才/ 可以/ 分摊/ 初始/ 阶段/ 的/ 开销/ ./ Pantry/ 对于/ 数据库/ 查询/ 应用/ ,/ 数据库/ 只能/ 有/ 一个/ 写入/ 者/ ,/ 这离/ 实际/ 的/ 数据库/ 应用/ 的/ 可验证/ 计算/ 还有/ 一定/ 的/ 距离/ ./ 8/ 问题/ 与/ 展望/ 目前/ 可验证/ 计算/ 协议/ 还/ 只是/ “/ 玩具/ ”/ 系统/ ,/ 由于/ 性能/ 开销/ 过大/ ,/ 仍/ 无法/ 真正/ 用于/ 通用/ 应用程序/ 和/ 云/ 计算/ 的/ 实际/ 场景/ 中/ ./ 本文/ 说/ 这些/ 协议/ 接近/ 实际/ 场景/ ,/ 是因为/ 相对/ 于/ 相关/ 理论/ 的/ 直接/ 实现/ 所/ 产生/ 的/ 开销/ 来说/ ,/ 这些/ 协议/ 已经/ 有/ 了/ 质/ 的/ 飞跃/ ./ 在/ 特定/ 构造/ 的/ 程序/ 中/ ,/ 这些/ 协议/ 还是/ 有/ 意义/ 的/ ./ 而且/ ,/ 在/ 某些/ 需要/ 牺牲/ 性能/ 来换/ 得/ 安全性/ 的/ 场景/ 下/ ,/ 比如/ 在/ 高/ 确保/ 计算/ 场景/ 中/ ,/ 为了/ 掌握/ 部署/ 在/ 远/ 端的/ 机器/ 的/ 运行/ 是否/ 正常/ ,/ 通常/ 愿意/ 花费/ 比较/ 大/ 的/ 代价/ ./ 更/ 幸运/ 的/ 是/ ,/ 现有/ 可验证/ 计算/ 协议/ 基于/ 性能/ 的/ 考虑/ 要求/ 证明/ 者/ 有/ 大量/ 空闲/ 的/ CPU/ 周期/ ,/ 验证/ 的/ 程序/ 有/ 多个/ 不同/ 的/ 实例/ (/ 同一/ 程序/ 、/ 不同/ 输入/ )/ ,/ 这些/ 和/ 数据/ 并行/ 的/ 云/ 计算/ 场景/ 十分/ 吻合/ ,/ 因而/ 研究/ 可验证/ 计算/ 协议/ ,/ 对于/ 解决/ 引言/ 中/ 提出/ 的/ 云/ 计算/ 中/ 的/ 程序执行/ 的/ 可信/ 问题/ 从而/ 构建/ 可信/ 的/ 云/ 计算/ 是/ 有/ 意义/ 的/ ./ 然而/ ,/ 可验证/ 计算/ 协议/ 领域/ 以及/ 其/ 构建/ 可信/ 云/ 计算/ 领域/ 在/ 以下/ 几个/ 方面/ 还有/ 待/ 进一步/ 的/ 研究/ :/ (/ 1/ )/ 相关/ 的/ 理论/ 工具/ 还/ 有待于/ 进一步/ 改进/ ./ 一方面/ 需要/ 通过/ 理论/ 工具/ 的/ 研究/ 和/ 改进/ 来/ 降低/ 验证/ 者/ 和/ 证明/ 者/ 的/ 开销/ ,/ 尤其/ 是/ 要/ 把/ 证明/ 者/ 的/ 开销/ 降低/ 到/ 一个/ 合理/ 的/ 范围/ ,/ 使得/ 协议/ 真正/ 能/ 用于/ 实际/ 的/ 场景/ 中/ ./ 验证/ 者/ 的/ 开销/ 可以/ 分为/ 固定/ 的/ 开销/ (/ 可以/ 分摊/ ,/ 通常/ 指/ 每个/ 程序/ 或者/ 每次/ 批处理/ 的/ 初始/ 阶段/ 的/ 开销/ )/ 和/ 可变/ 的/ 开销/ (/ 程序/ 的/ 每个/ 实例/ 的/ 验证/ 开/ Page15/ 销/ )/ ./ 研究/ 如何/ 降低/ 验证/ 者/ 的/ 可变/ 开销/ ,/ 研究/ 能否/ 使用/ 密码学/ 操作/ 和/ 复杂/ 的/ 理论/ 工具/ 来/ 降低/ 或/ 取消/ 验证/ 者/ 初始/ 阶段/ 的/ 开销/ ./ 改进/ 基于/ 无/ 预处理/ 的/ 论证/ 系统/ 的/ 可验证/ 计算/ 协议/ ,/ 使得/ 其能/ 用于/ 实际/ 场景/ ./ 另一方面/ ,/ 研究/ 利用/ 理论/ 工具/ 来/ 建立/ 更加/ 合理/ 的/ 计算/ 模型/ ,/ 用于/ 高效/ 的/ 表示/ 通用/ 程序/ ,/ 从而/ 提高/ 协议/ 的/ 效率/ ./ 目前/ 的/ 系统/ 要/ 不/ 不能/ 很/ 好/ 的/ 处理/ 循环/ 结构/ ,/ 要/ 不/ 就是/ 编译/ 的/ 代价/ 太高/ 无法/ 实用/ ./ BCGTV/ 协议/ 可以/ 处理/ 独立/ 于/ 数据/ 的/ 循环/ 的/ 程序/ ,/ 但是/ 其/ 对于/ 程序/ 转化成/ 特殊/ 的/ 电路/ 模型/ 引入/ 了/ 过/ 大/ 的/ 开销/ ./ BCGTV/ 和/ Pantry/ 协议/ 可以/ 处理/ 包含/ RAM/ 的/ 程序/ ,/ 但是/ Pantry/ 协议/ 对/ 内存/ 操作/ 转换成/ 约束/ 集/ 也/ 引入/ 了/ 过/ 大/ 的/ 开销/ (/ 目前/ ,/ 在/ T/ 机器运行/ 的/ 一些/ 计算机程序/ 原本/ 需要/ T/ 步/ ,/ 转换成/ 由/ 电路/ 计算/ 远远/ 超过/ T/ 步/ )/ ./ 有/ 必要/ 改进/ 这/ 两种/ 计算/ 模型/ 使得/ 其/ 既/ 可以/ 很/ 好/ 的/ 处理/ 循环/ 结构/ 和/ RAM/ ,/ 又/ 不至于/ 引入/ 过大/ 的/ 开销/ ./ 或者/ 设计/ 新/ 的/ 更加/ 高效/ 的/ 计算/ 模型/ 来/ 表示/ 通用/ 计算/ ./ (/ 2/ )/ 在/ 系统/ 和/ 编程语言/ 方面/ 值得/ 研究/ ./ 针对/ 已有/ 的/ 电路/ 和/ 约束/ 计算/ 模型/ ,/ 设计/ 定制/ 的/ 高级/ 程序语言/ ,/ 降低/ 程序/ 到/ 计算/ 模型/ 的/ 转化/ 开销/ ./ 目前/ ,/ 一些/ 可验证/ 计算/ 协议/ 编译/ 处理/ 和/ 证明/ 系统/ 的/ 工作/ 已经/ 有所/ 交叉/ ,/ 而且/ 很多/ 协议/ 在/ 并行计算/ 中/ 性能/ 更优/ ,/ 由于/ 计算/ 模型/ 的/ 高效/ 转化/ ,/ 可以/ 使得/ 验证/ 的/ 效率/ 提高/ ./ 所以/ 设计/ 一整套/ 相应/ 的/ 高级/ 语言/ 程序/ 、/ 计算/ 模型/ 、/ 验证/ 机器/ 十分必要/ ./ 目前/ 还/ 没有/ 协议/ 在/ 真实/ 的/ 云/ 计算/ 场景/ 中/ 测试/ ,/ 开发/ 适用/ 于云/ 计算/ 实际/ 场景/ 的/ 支持/ 并发/ 、/ 访问控制/ 、/ 合理/ 结构/ 的/ 数据库/ 应用/ 的/ 可验证/ 计算/ ,/ 使得/ 协议/ 支持/ 多用户/ 数据库/ ,/ 才能/ 更好/ 的/ 构建/ 可信/ 的/ 云/ 计算/ ./ (/ 3/ )/ 改变/ 协议/ 的/ 目标/ 和/ 原则/ ,/ 减少/ 可验证/ 计算/ 协议/ 的/ 限制/ 条件/ ,/ 比如/ 可验证/ 计算/ 协议/ 的/ 无条件/ 假设/ ,/ 即/ 除了/ 密码学/ 假设/ 之外/ 不/ 做/ 任何/ 其他/ 假设/ ./ 如果/ 假设/ 多个/ 证明/ 者/ 之间/ 不能/ 相互/ 交互/ 、/ 合谋/ ,/ 那么/ 多/ 证明/ 协议/ 相对/ 单/ 证明/ 者/ 的/ 开销/ 则/ 降低/ 很多/ ./ 实际上/ ,/ 如果/ 假设/ 两个/ 证明/ 者/ 至少/ 有/ 一个/ 是/ 计算/ 正确/ 的/ ,/ 就/ 可以/ 使得/ 很多/ 协议/ 能/ 用于/ 特定/ 构造/ 的/ 场景/ 中/ ./ (/ 4/ )/ 增加/ 安全/ 相关/ 的/ 属性/ 用于/ 构建/ 可信/ 的/ 云/ 计算/ ./ Pinocchio/ 、/ Pantry/ 协议/ 说明/ 了/ 在/ 证明/ 者/ 对/ 验证/ 者/ 隐藏/ 询问/ 信息/ 的/ 场景/ 下/ 的/ 简单/ 应用/ ,/ 还有/ 很多/ 地方/ 值得/ 研究/ ,/ 比如说/ 提供/ 隐私/ 相关/ 的/ 其他/ 安全/ 属性/ ,/ 可以/ 用来/ 保护/ 云/ 计算/ 用户/ 的/ 隐私/ ./ 再/ 比如说/ 公开/ 可验证/ 性/ 的/ 特性/ 使得/ 任何/ 拥有/ 密码/ 的/ 用户/ 都/ 可以/ 验证/ 其/ 可信性/ ,/ 这为/ 第/ 3/ 方/ 审计/ 来/ 保证/ 云/ 计算/ 的/ 可信性/ 提供/ 了/ 良好/ 的/ 思路/ ./ 可验证/ 计算/ 协议/ 把/ 复杂/ 的/ 密码学/ 和/ 理论/ 计算机科学/ 的/ 研究成果/ 用于/ 实际/ 本身/ 就/ 具有/ 里程碑/ 的/ 意义/ ./ 基于/ 证据/ 的/ 可验证/ 计算/ 协议/ 是/ 一个/ 趋势/ ,/ 这/ 不仅/ 使/ 理论/ 应用/ 于/ 实际/ ,/ 而且/ 开创/ 了/ 理论/ 计算机/ 新/ 的/ 研究/ 领域/ ./ 虽然/ 可验证/ 计算/ 协议/ 的/ 性能/ 和/ 在/ 云/ 计算/ 实际/ 场景/ 中/ 的/ 部署/ 还有/ 一定/ 的/ 距离/ ./ 但是/ 以/ 当前/ 的/ 研究/ 节奏/ ,/ 相信/ 不久/ 的/ 将来/ ,/ 就/ 会/ 有/ 基于/ 证据/ 的/ 可验证/ 计算/ 协议/ 应用/ 到/ 云/ 计算/ 的/ 真实/ 场景/ 中/ ./ 而且/ ,/ 可验证/ 计算/ 的/ 潜力/ 很大/ ,/ 远远/ 不/ 只是/ 云/ 计算/ ./ 如果/ 这个/ 领域/ 的/ 研究/ 性能/ 降低/ 到/ 合理/ 的/ 范围/ ,/ 除了/ 验证/ 云/ 计算/ 之外/ ,/ 还有/ 更大/ 的/ 价值/ ./ 将会/ 有/ 新/ 的/ 方法/ 来/ 构建/ 协议/ ,/ 在/ 任何/ 一个/ 模块/ 为/ 另/ 一个/ 模块/ 执行程序/ 的/ 场景/ 中/ 都/ 可以/ 应用/ ./ 包括/ 微观/ 层面/ (/ microlevel/ )/ ,/ 如果/ CPU/ 可以/ 验证/ GPU/ ,/ 则/ 可以/ 消除/ 硬件/ 错误/ ;/ 宏观/ 层面/ (/ macrolevel/ )/ 分布式计算/ 将/ 基于/ 不同/ 的/ 可信/ 假设/ 构建/ ./ 而且/ ,/ 随着/ 计算能力/ 的/ 增加/ 和/ 计算成本/ 的/ 下降/ ,/ 原本/ 无法/ 实践/ 的/ 协议/ 也/ 可以/ 用于/ 实际/ 场景/ 中/ ./ 

