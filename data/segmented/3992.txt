Page1/ 过程/ 间/ 循环/ 路径/ 剖析/ 方法/ 王璐璐/ 李必信/ (/ 东南大学/ 计算机科学/ 与/ 工程学院/ 南京/ 211189/ )/ (/ 东南大学/ 计算机网络/ 和/ 信息/ 集成/ 教育部/ 重点/ 实验室/ 南京/ 210096/ )/ 摘要/ 该文/ 在/ 过程/ 内/ 剖析/ 技术/ 的/ 基础/ 上/ 提出/ 了/ 一种/ 新/ 的/ 过程/ 间/ 路径/ 剖析/ 方法/ PIP/ ,/ 能够/ 精确/ 地/ 编码/ 过程/ 间/ 路径/ 和/ 方法/ 级/ 执行/ 序列/ ./ 为了/ 有效/ 地/ 处理/ 方法/ 间/ 多态/ 等/ 复杂/ 调用/ ,/ 文中/ 提出/ 了/ 一种/ 新/ 的/ 剖析/ 模型/ PCCG/ (/ PolymorphicClusterCallGraph/ )/ ,/ 能够/ 精确/ 描述/ 多态/ 信息/ ,/ 并且/ 支持/ 以/ “/ 方法/ 集簇/ ”/ 的/ 方式/ 对/ 多个/ 被/ 调用/ 方法/ 统一/ 处理/ ,/ 简化/ 调用/ 结构/ ,/ 减少/ 剖析/ 耗费/ ./ 基于/ PCCG/ 模型/ ,/ PIP/ 方法/ 能够/ 精确/ 地/ 进行/ 过程/ 间/ 路径/ 剖析/ ,/ 并/ 可/ 采用/ 多种/ 方法/ 集簇/ 策略/ 来/ 优化/ 剖析/ 效率/ ./ 理论/ 分析/ 和/ 实验/ 结果表明/ ,/ PIP/ 方法/ 具有/ 较/ 高/ 的/ 精确性/ 和/ 循环/ 处理/ 能力/ ,/ 且/ 各种/ 集簇/ 策略/ 能够/ 适应/ 不同/ 的/ 应用/ 情况/ ,/ 有效/ 地/ 提升/ 效率/ ./ 关键词/ 路径/ 剖析/ ;/ 过程/ 间/ 路径/ ;/ 多态/ ;/ 动态分析/ ;/ 软件测试/ 1/ 引言/ 路径/ 剖析/ 是/ 动态/ 软件/ 分析/ 中/ 的/ 一个/ 重要/ 领域/ ,/ Page2/ 式/ 使得/ 目标程序/ 在/ 执行/ 的/ 同时/ 可以/ 进行/ 编码/ 的/ 计算/ ,/ 在/ 执行/ 完毕/ 后/ 统计/ 各个/ 路径/ 编码/ 的/ 出现/ 频率/ ,/ 进而/ 通过/ 解码/ 得出/ 最终/ 的/ 路径/ 剖析/ 结果/ ./ 故/ 路径/ 剖析/ 主要/ 可以/ 分为/ 两个/ 阶段/ :/ 静态/ 的/ 路径/ 编码/ 和/ 插装/ 实现/ ,/ 以及/ 执行/ 时/ 对/ 路径/ 频率/ 进行/ 统计/ ./ 路径/ 编码/ 的/ 精确性/ 和/ 完备/ 性/ 决定/ 了/ 剖析/ 结果/ 是否/ 精确/ 和/ 完整/ ./ 1996/ 年/ Ball/ 和/ Larus/ 提出/ 了/ 首个/ 路径/ 剖析/ 技术/ EPP/ (/ EfficientPathProfiling/ )/ [/ 1/ ]/ ,/ 该/ 方法/ 可以/ 精确/ 、/ 高效/ 地/ 剖析/ 过程/ 内/ 所有/ 无环/ 路径/ ./ 此后/ ,/ 路径/ 剖析/ 领域/ 相继/ 出现/ 了/ 多种/ 方法/ ,/ 或/ 致力于/ 提升/ 循环/ 处理/ 能力/ ,/ 或/ 致力于/ 扩展/ 剖析/ 的/ 应用/ 场景/ ,/ 这些/ 结果/ 已/ 广泛应用/ 于/ 编译/ 优化/ 、/ 调试/ 、/ 测试/ 和/ 程序/ 理解/ 等/ 多个/ 领域/ [/ 2/ -/ 7/ ]/ ./ 但是/ 其中/ 大部分/ 方法/ 将/ 剖析/ 的/ 目标/ 限定/ 为/ 过程/ 内/ 路径/ ,/ 即/ 不/ 涉及/ 方法/ 调用/ 的/ 路径/ ./ 由于/ 方法/ 调用/ 广泛/ 存在/ 于/ 程序执行/ 之中/ ,/ 过程/ 内/ 的/ 剖析/ 结果/ 在/ 很多/ 应用领域/ 不/ 能够/ 提供/ 充分/ 的/ 信息/ ./ 在/ 过程/ 间/ 路径/ 剖析/ 方面/ ,/ 研究/ 人员/ 在/ 过程/ 内/ 剖析/ 算法/ 的/ 基础/ 之上/ 进行/ 扩展/ ,/ 纳入/ 对/ 方法/ 调用/ 的/ 编码/ ,/ 使得/ 不同/ 的/ 过程/ 间/ 路径/ 对应/ 于/ 不同/ 的/ 编码/ ,/ 以/ 获取/ 其/ 剖析/ 结果/ ./ IPP/ (/ Inter/ -/ ProceduralProfiling/ )/ 方法/ 在/ EPP/ 方法/ 的/ 基础/ 之上/ 做/ 了/ 改进/ ,/ 在/ 单个/ 过程/ 内部/ 使用/ EPP/ 探针/ 进行/ 插装/ ,/ 而/ 每个/ 过程/ 的/ 调用/ 边界/ 处/ 使用/ 额外/ 的/ 运算/ 方法/ 将/ 过程/ 内无环/ 路径/ 编码/ 与/ 过程/ 间/ 调用/ 边/ 的/ 编码/ 相/ 整合/ ,/ 以/ 完成/ 过程/ 间/ 剖析/ [/ 8/ ]/ ./ 但是/ IPP/ 方法/ 具有/ 两个/ 主要/ 的/ 缺陷/ :/ 首先/ ,/ 由于/ EPP/ 方法/ 本身/ 不/ 剖析/ 循环/ 路径/ ,/ 所以/ IPP/ 方法/ 难以/ 处理/ 循环/ ;/ 其次/ ,/ 在/ 整合/ 编码/ 的/ 过程/ 之中/ ,/ IPP/ 需要/ 对/ 所有/ 可/ 剖析/ 的/ 静态/ 路径/ 进行/ 枚举/ 以/ 完成/ 紧凑/ 编码/ ,/ 故其/ 应对/ 复杂/ 流图/ 时/ 耗费/ 过大/ ./ Tallam/ 等/ 人/ 在/ 其/ 提出/ 的/ 过程/ 内有/ 环/ 路径/ 的/ 近似/ 剖析/ 方法/ ExPP/ (/ ExtendedPathProfiling/ )/ 的/ 基础/ 之上/ ,/ 将/ 之/ 扩展/ 为/ 过程/ 间/ 剖析/ 方法/ [/ 9/ ]/ ./ 该/ 方法/ 的/ 主要/ 缺陷/ 在于/ :/ 由于/ ExPP/ 方法/ 本身/ 是非/ 精确/ 的/ ,/ 且/ 在/ 循环/ 处理/ 上/ 有/ 限制/ ,/ 所以/ 其/ 扩展/ 后/ 的/ 剖析/ 方法/ 也/ 在/ 精确度/ 和/ 路径/ 循环/ 上/ 有/ 限制/ ./ 总之/ ,/ 现有/ 的/ 过程/ 间/ 剖析/ 方法/ 或者/ 能够/ 精确/ 剖析/ 无环/ 路径/ ,/ 或者/ 能够/ 近似/ 剖析/ 带有/ 少量/ 循环/ 执行/ 的/ 路径/ ./ 基于/ 此/ ,/ 为了/ 满足/ 过程/ 间/ 有/ 环/ 路径/ 的/ 精确/ 剖析/ ,/ 本文/ 基于/ PAP/ 方法/ [/ 10/ ]/ (/ ProfilingAllPaths/ ,/ 一种/ 过程/ 内/ 循环/ 路径/ 的/ 精确/ 剖析/ 方法/ )/ 提出/ 了/ PIP/ (/ ProfilingInter/ -/ proceduralPaths/ )/ 方法/ ,/ 用于/ 剖析/ 包含/ 任意/ 有限/ 次/ 循环体/ 执行/ 和/ 任意/ 有限/ 次/ 方法/ 调用/ 的/ 路径/ ./ 本文/ 的/ 主要/ 贡献/ 有/ 3/ 个/ 方面/ :/ 首先/ ,/ 基于/ 方法/ 调用/ 图/ 模型/ 提出/ 了/ 一种/ 新/ 的/ 过程/ 间/ 控制流/ 图/ 模型/ PCCG/ (/ PolymorphicClusterCallGraph/ )/ ,/ 能够/ 描述/ 方法/ 调用/ 中/ 的/ 多态/ 信息/ ,/ 并/ 支持/ 采用/ 集簇/ 的/ 方式/ 同时/ 处理/ 多个/ 被/ 调用/ 方法/ ,/ 以/ 改善/ 效率/ ./ 其次/ ,/ 基于/ PCCG/ 模型/ 将/ PAP/ 方法/ 扩展/ 为/ PIP/ 方法/ ,/ 以/ 精确/ 剖析/ 过程/ 间/ 有/ 环/ 路径/ ,/ 并/ 提出/ 集簇/ 策略/ 以/ 优化/ 剖析/ 性能/ ./ 最后/ ,/ 使用/ 基准/ 测试程序/ 对/ PIP/ 方法/ 和/ 相关/ 方法/ 进行/ 了/ 实验/ 比较/ ,/ 验证/ 其/ 有效性/ ,/ 并/ 使用/ 随机/ 生成/ 的/ PCCG/ 图对/ 如何/ 选择/ 最优/ 集簇/ 策略/ 的/ 问题/ 进行/ 了/ 探索/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 背景/ 知识/ 和/ 技术/ ;/ 第/ 3/ 节/ 讨论/ PIP/ 的/ 实现/ 细节/ ;/ 第/ 4/ 节/ 给出/ 实验/ 评估/ 及/ 结果/ ;/ 第/ 5/ 节对/ 全文/ 内容/ 进行/ 总结/ ./ 2/ 研究/ 背景/ 本/ 章节/ 内容/ 安排/ 如下/ :/ 2.1/ 节/ 介绍/ 研究/ 动机/ ;/ 2.2/ 节/ 回顾/ 相关/ 背景/ 技术/ ,/ 包括/ EPP/ 方法/ 和/ IPP/ 方法/ ;/ 2.3/ 节/ 介绍/ PAP/ 方法/ 及其/ 在/ 过程/ 内/ 剖析/ 方面/ 应对/ 编码/ 溢出/ 时所/ 采用/ 的/ 断点/ 机制/ ./ 2.1/ 研究/ 动机/ 经过/ 几十年/ 的/ 发展/ ,/ 软件/ 的/ 应用/ 日益/ 广泛/ ,/ 软件/ 的/ 复杂度/ 也/ 日益/ 提升/ ./ 从/ 程序结构/ 的/ 角度/ 来看/ ,/ 过程/ 间/ 调用/ 已/ 是/ 软件/ 中/ 几乎/ 必不可少/ 的/ 要素/ 之一/ ./ 路径/ 剖析/ 是/ 收集/ 软件/ 中/ 执行/ 路径/ 频率/ 的/ 方法/ ,/ 其/ 结果/ 是/ 软件/ 分析/ 、/ 理解/ 和/ 改进/ 的/ 基础/ ,/ 剖析/ 价值/ 与/ 所/ 针对/ 的/ 路径/ 息息相关/ ./ 传统/ 的/ 过程/ 内/ 剖析/ 方法/ 只能/ 针对/ 单/ 过程/ 程序/ 进行/ ,/ 在/ 软件/ 复杂化/ 的/ 今天/ 应用/ 效果/ 有限/ ;/ 已有/ 的/ 过程/ 间/ 剖析/ 技术/ 尚/ 不/ 成熟/ ,/ 或者/ 不能/ 处理程序/ 中/ 广泛/ 存在/ 的/ 循环/ 和/ 复杂/ 调用/ ,/ 或者/ 不能/ 给出/ 完全/ 精确/ 的/ 结果/ ./ 本文/ 以/ 过程/ 间/ 路径/ 剖析/ 为/ 目标/ ,/ 旨在/ 提升/ 剖析/ 的/ 应用/ 价值/ ,/ 包括/ 可/ 剖析/ 路径/ 的/ 广泛性/ 和/ 剖析/ 的/ 精确度/ ./ 主要/ 面对/ 的/ 问题/ 如下/ :/ 复杂/ 调用/ ;/ (/ 1/ )/ 如何/ 处理过程/ 间/ 调用/ ,/ 特别/ 是/ 递归/ 、/ 多态/ 等/ (/ 2/ )/ 如何/ 处理过程/ 间/ 路径/ 中/ 的/ 循环/ ;/ (/ 3/ )/ 如何/ 在/ 剖析/ 的/ 过程/ 中/ 保持/ 精确/ ./ 2.2/ 研究/ 现状/ 为了/ 收集/ 执行/ 路径/ 的/ 频率/ ,/ 现有/ 技术/ 普遍/ 采用/ 插装/ 的/ 方式/ 实现/ 路径/ 编码/ 的/ 计算/ 和/ 频率/ 统计/ ./ 以/ Page3EPP/ 方法/ 为例/ ,/ 其/ 使用/ 一个/ 整型/ 变量/ r/ 进行/ 编码/ ,/ 在/ 执行/ 过程/ 中/ 对/ r/ 进行/ 累加/ 操作/ ,/ 每条/ 路径/ 的/ 编码/ 即/ 为/ 该/ 路径/ 中/ 所有/ 边/ 的/ 权值/ 之/ 和/ ./ 相应/ 插装/ 的/ 编码/ 计算/ 语句/ 形式/ 为/ “/ r/ ·/ ·/ =/ r/ +/ i/ ”/ ,/ 其中/ i/ 为/ 无/ 环控制/ 流图/ 中边/ 的/ 权值/ ,/ 由/ Ball/ -/ Larus/ 权值/ 分配/ 算法/ 得出/ ,/ 可以/ 保证/ 无环图/ 中/ 所有/ 路径/ 的/ 唯一/ 编码/ ,/ 如图/ 1/ (/ a/ )/ 所示/ ,/ 图中/ “/ Nx/ ”/ 表示/ 经过/ 节点/ x/ 的/ 静态/ 路径/ 总数/ ,/ 据此/ 可以/ 计算/ 每条/ 边/ 的/ 权值/ ./ 这样/ 插装/ 完毕/ 之后/ ,/ 在/ 目标程序/ 执行/ 的/ 同时/ 可以/ 计算/ 相应/ 的/ 路径/ 编码/ ./ 针对/ 图/ 2/ (/ a/ )/ 中/ 的/ 控制流/ 图/ ,/ EPP/ 插装/ 结果/ 如图/ 2/ (/ b/ )/ 所示/ ,/ 变量/ i/ 对/ 执行/ 的/ 路径/ 编码/ 进行/ 计算/ ,/ 每条/ 路径/ 编码/ 的/ 出现/ 频率/ 统计/ 在/ 数组/ count/ 之中/ ,/ 其中/ 数组/ 下标/ 对应/ 路径/ 编码/ ,/ 数组/ 中/ 存储/ 的/ 值/ 即/ 为/ 路径/ 执行/ 频率/ ./ 针对/ 有/ 循环/ 的/ 程序/ ,/ EPP/ 不/ 对/ 执行/ 了/ 循环/ 的/ 路径/ 进行/ 编码/ ,/ 如图/ 2/ (/ e/ )/ 所示/ ./ 图/ 2EPP/ 和/ PAP/ 插装/ 结果/ (/ 插装/ 代码/ 用/ 下划线/ 标识/ )/ EPP/ 是/ 一种/ 过程/ 内/ 剖析/ 方法/ ,/ IPP/ [/ 8/ ]/ 将/ 之/ 拓展/ 至/ 过程/ 间/ 剖析/ 场景/ 之中/ ./ 其/ 思想/ 在于/ 按照/ 过程/ 间/ 调用/ 关系/ ,/ 将/ 各个/ 过程/ 内部/ 的/ 控制流/ 结构图/ 进行/ 衔接/ ,/ 得到/ 全局/ 控制流/ 图/ SuperGraph/ ,/ 并/ 使用/ 类似/ EPP/ 的/ 算法/ 在/ SuperGraph/ 上/ 进行/ 各个/ 节点/ 和/ 边/ 的/ 权值/ 计算/ ,/ 进而/ 插装/ 相应/ 的/ 探针/ ./ 如图/ 3/ (/ a/ )/ 所示/ ,/ 方法/ method1/ 中/ 的/ 节点/ A/ 调用/ 了/ method2/ ,/ 所以/ 节点/ A/ 到/ method2/ 入口/ 节点/ C/ 的/ 调用/ 边/ 可以/ 视为/ 节点/ C/ 的/ 入边/ ,/ 使用/ EPP/ 算法/ 时/ ,/ 需要/ 将/ 节点/ A/ 的/ 权值/ (/ 未/ 考虑/ 调用/ 关系/ 时/ 计算/ 的/ 权值/ )/ 累加/ 到/ 节点/ C/ 的/ 权值/ 之中/ ;/ 同样/ ,/ method2/ 的/ 出口/ 节点/ D/ 对/ 节点/ A/ 的/ 后继/ 节点/ B/ 的/ 返回/ 边/ 可以/ 视为/ B/ 的/ 入边/ ,/ 需要/ 将/ 节点/ D/ 的/ 权值/ 累/ 加入/ 节点/ B/ 的/ 权值/ 之中/ ./ 节点/ 的/ 权值/ 计算/ 完毕/ 之后/ ,/ 即可/ 得/ 相应/ 的/ 边/ (/ 包括/ 调用/ 边/ 和/ 返回/ 边/ )/ 的/ 权值/ ./ 由于/ IPP/ 未能/ 改进/ EPP/ 处理/ 循环/ 的/ 能力/ ,/ 故其/ 不能/ 剖析/ 带有/ 回边/ 的/ 过程/ 间/ 路径/ ,/ 当回边/ 执行/ 时/ ,/ IPP/ 即/ 终止/ 该次/ 执行/ ,/ 不/ 将/ 相应/ 路径/ 纳入/ 频率/ 统计/ 之中/ ./ 如图/ 3/ (/ b/ )/ 所示/ ,/ IPP/ 定义/ 了/ 一个/ 全局/ 出口/ 节点/ Global/ -/ Exit/ ,/ 并/ 将/ 所有/ 的/ 循环/ 回边/ 修改/ 为/ 指向/ 该/ 节点/ ,/ 实际/ 执行/ 之中/ 不会/ 执行/ 任何/ 的/ 回边/ ./ 2.3/ PAP/ 方法/ PAP/ 方法/ 的/ 目的/ 在于/ 增强/ 过程/ 内/ 剖析/ 方面/ 对/ 循环/ 处理/ 的/ 能力/ [/ 10/ ]/ ./ 与/ EPP/ 等/ 方法/ 不同/ ,/ PAP/ 插装/ 的/ 语句/ 形式/ 为/ “/ r/ ·/ ·/ =/ r/ / n/ +/ i/ ”/ (/ 简记/ 为/ n/ (/ i/ )/ )/ ./ PAP/ 方法/ 对于/ 控制流/ 图中/ 入度/ 大于/ 1/ 的/ 节点/ 的/ 所有/ 入边/ 进行/ 权值/ 分配/ ,/ 分配/ 的/ n/ 即/ 为/ 该/ 节点/ 的/ 入度/ ,/ i/ 为/ 从/ 0/ 开始/ 的/ 连续/ 整数/ ./ 如图/ 1/ (/ b/ )/ 所示/ ,/ 对于/ 节点/ d/ 的/ 3/ 条入/ 边/ 依次/ 分配/ 3/ (/ 0/ )/ ,/ 3/ (/ 1/ )/ 和/ 3/ (/ 2/ )/ ,/ 当/ 程序执行/ 相应/ 的/ 入边/ 时/ ,/ 将/ 路径/ 编码/ 乘以/ 3/ 后/ 再/ 分别/ 加上/ 0/ ,/ 1/ 或/ 2/ ./ 这种/ 编码方式/ 可以/ 对/ 过程/ 内/ 的/ 任一/ 静态/ 路径/ 分配/ 一个/ 唯一/ 的/ 编码/ ,/ 保证/ 剖析/ 结果/ 的/ 精确性/ ./ PAP/ 插装/ 过程/ 与/ EPP/ 类似/ ,/ 区别/ 在于/ 编码/ 的/ 计算/ 方式/ ,/ 如图/ 2/ (/ c/ )/ 所示/ ./ 使用/ 乘加/ 结合/ 的/ 编码方式/ 可以/ 处理/ 包含/ 循环/ 任意/ 有限/ 次/ 执行/ 的/ 路径/ ,/ 如图/ 2/ (/ f/ )/ 所示/ ,/ 可以/ 保证/ 每条/ 静态/ 路径/ 具有/ 不同/ 的/ 编码/ ,/ 进而/ 保证/ 剖析/ 结果/ 的/ 完整/ 和/ 精确性/ ./ 在/ 另一方面/ ,/ 由于/ PAP/ 方法/ 不/ 限制/ 循环/ 执行/ 次数/ ,/ 在/ 实际/ 执行/ 过程/ 中/ 可能/ 会/ 发生/ 编码/ 过大/ ,/ 变量/ 溢/ Page4/ 出/ 的/ 情况/ ./ 针对/ 这一/ 问题/ ,/ 文献/ [/ 10/ ]/ 提出/ 了/ 断点/ 机制/ ,/ 当/ 溢出/ 发生/ 时/ ,/ 将/ 未/ 溢出/ 的/ 编码/ 和/ 相应/ 位置/ 记录/ 到/ 编码/ 栈/ 之中/ ,/ 并/ 重置/ 相应/ 变量/ 取值/ ,/ 继续/ 编码/ ./ 相应/ 的/ ,/ 在/ 解码/ 过程/ 中/ ,/ 每个/ 断点/ 记录/ 了/ 所/ 执行/ 路径/ 的/ 一个/ 片段/ ,/ 将/ 各个/ 断点/ 对应/ 的/ 路径/ 片段/ 依次/ 衔接/ ,/ 即可/ 获得/ 编码/ 所/ 对应/ 的/ 路径/ ./ 同时/ ,/ PAP/ 方法/ 剖析/ 过程/ 中/ 的/ 编码/ 存储/ 耗费/ 和/ 解码/ 耗费/ 与/ 相异/ 断点/ 数目/ 相关/ (/ 即/ 断点/ 的/ 重复性/ 可以/ 提升/ 剖析/ 效率/ )/ ./ 3/ 过程/ 间/ 路径/ 剖析/ 本/ 章节/ 内容/ 安排/ 如下/ :/ 首先/ ,/ 由于/ PAP/ 方法/ 可以/ 处理过程/ 内/ 的/ 路径/ 编码/ ,/ 为了/ 叙述/ 的/ 简便/ ,/ 3.1/ 节/ 介绍/ 如何/ 等价/ 地/ 忽略/ 过程/ 内部结构/ ,/ 以/ 简化/ 过程/ 间/ 剖析/ ./ 然后/ ,/ 3.2/ 节将/ PAP/ 方法/ 扩展/ 到/ 过程/ 间/ 剖析/ 之中/ ,/ 并/ 使/ 之/ 能够/ 处理/ 多态/ 调用/ ./ 每条/ 过程/ 间/ 静态/ 路径/ 被/ 编码/ 为/ 不同/ 的/ 整数/ ,/ 而/ 当/ 某/ 一条/ 路径/ 被/ 执行/ 时/ ,/ 其/ 编码/ 随着/ 执行/ 进行/ 计算/ ,/ 当该/ 路径/ 执行/ 完毕/ 后/ ,/ 计算所/ 得出/ 的/ 一个/ 或/ 多个/ 整数/ 即/ 为/ 其/ 唯一/ 的/ 编码/ ./ 最后/ ,/ 3.3/ 节/ 提出/ 一种/ 过程/ 间/ 剖析/ 的/ 控制流/ 模型/ PCCG/ (/ PolymorphicClusterCallGraph/ )/ 以/ 描述/ 多态/ 调用/ 的/ 情况/ ,/ 据此/ 3.4/ 节/ 提出/ 过程/ 间/ 路径/ 剖析/ 方法/ PIP/ 以及/ 使用/ 方法/ 集簇/ 的/ 方式/ 来/ 优化/ 剖析/ 效率/ ./ 3.1/ 忽略/ 过程/ 内部结构/ 在/ 不/ 包含/ 多态/ 调用/ 的/ 情况/ 下/ ,/ (/ 添加/ 返回/ 边后/ 的/ )/ 过程/ 间/ 控制流/ 图/ 和/ 过程/ 内/ 控制流/ 图/ 没有/ 本质/ 的/ 区别/ ./ 类似/ 于/ IPP/ 方法/ 中将/ 各个/ 过程/ 内部结构/ 组合/ 以/ 获取/ 全局/ 控制流/ 图/ 的/ 方式/ ,/ 所有/ 过程/ 的/ CFG/ ,/ 无论/ 有环/ 或/ 无环/ ,/ 可以/ 按照/ 过程/ 之间/ 的/ 调用/ 关系/ 组合/ 为/ 全局/ 控制流/ 图/ ,/ 这样/ 每/ 一条/ 过程/ 间/ 路径/ 可以/ 精确/ 地/ 反映/ 在/ 全局/ 控制流/ 图/ 之上/ ./ 这样/ 组合/ 后/ 的/ 全局/ 控制流/ 图/ 的/ 结构/ 和/ 单个/ 过程/ 的/ CFG/ 相/ 类似/ ,/ 可以/ 应用/ PAP/ 方法/ 保证/ 任意/ 两条/ 不同/ 静态/ 路径/ 具有/ 相异/ 的/ 编码/ ./ 对于/ 包含/ 多态/ 调用/ 的/ 情况/ ,/ 每个/ 过程/ 内部结构/ 可以/ 独立/ 应用/ PAP/ 探针/ 进行/ 编码/ 计算/ ,/ 这样/ 将/ PAP/ 方法/ 扩展/ 到/ 过程/ 间/ 剖析/ 的/ 工作/ 即可/ 仅/ 着眼于/ 方法/ 调用/ 的/ 编码/ 和/ 插装/ ./ 因此/ ,/ 在/ PAP/ 精确/ 剖析/ 过程/ 内/ 路径/ 的/ 情况/ 下/ ,/ 可以/ 专注/ 于/ 过程/ 间/ 控制流/ 的/ 剖析/ ./ 3.2/ 拆分/ 调用/ 边以/ 处理/ 多态/ 在/ 包含/ 多态/ 关系/ 的/ 过程/ 间/ 控制流/ 图上/ ,/ 每条/ 可能/ 发生/ 多态/ 调用/ 关系/ 的/ 方法/ 调用/ 边/ 都/ 可以/ 等价/ 地/ 拆/ 分为/ 多条/ 普通/ (/ 无/ 多态/ )/ 调用/ 边/ ,/ 其中/ 每条/ 普通/ 调用/ 边/ 表示/ 该/ 多态/ 调用/ 边/ 在/ 执行/ 过程/ 中/ 的/ 一种/ 可能/ 调用/ 关系/ ./ 经过/ 这样/ 的/ 边/ 替换/ 后/ ,/ 有/ 多态/ 关系/ 的/ 控制流/ 图/ 可以/ 等价/ 地/ 转化/ 为/ 无/ 多态/ 关系/ 的/ 控制流/ 图/ ./ 如图/ 4/ 所示/ ,/ B/ 类/ 继承/ 了/ A/ 类/ ,/ 并且/ 覆盖/ ①/ 了/ A/ 类中/ 的/ 方法/ m/ ,/ 那么/ 当/ C/ 类中/ 的/ 方法/ f/ 显式/ 地/ 调用/ A/ 类中/ 的/ 方法/ m/ 时/ ,/ 由于/ 面向对象/ 软件/ 中/ 的/ 动态/ 绑定/ 机制/ ,/ 在/ 实际/ 执行/ 过程/ 中/ 如果/ 该/ 方法/ 调用/ 的/ 当前/ 对象/ 类型/ 为/ B/ ,/ 那么/ 调用/ 的/ 方法/ 即为/ B/ / m/ ./ 为了/ 处理/ 这样/ 的/ 多态/ 调用/ ,/ 我们/ 可以/ 按照/ 动态/ 绑定/ 类型/ 集合/ 对/ 该/ 调用/ 边/ 进行/ 拆分/ ,/ 以/ 保证/ 拆分/ 后/ 的/ 每/ 条边/ 都/ 具有/ 唯一/ 的/ 、/ 确定/ 的/ 调用/ 目标/ 方法/ ./ 在/ 图/ 4/ 中/ ,/ 由于/ 变量/ a/ 的/ 该/ 多态/ 调用/ 边/ 可以/ 拆/ 分为/ 两条/ 边/ ,/ 一条/ 指向/ A/ / m/ ,/ 另/ 一条/ 指向/ B/ / m/ ,/ 相应/ 的/ 源代码/ 也/ 需要/ 进行/ 修改/ ,/ 按照/ 变量/ a/ 的/ 各种/ 可能/ 类型/ 依次/ 进行/ 判断/ ./ 要/ 注意/ 的/ 是/ ,/ 进行/ 判断/ 时/ ,/ 各种类型/ 有/ 顺序/ 要求/ :/ 子/ 类型/ 需要/ 在/ 父/ 类型/ 之前/ 判断/ ./ 因此/ ,/ 完成/ 多态/ 调用/ 边/ 的/ 拆分/ 还/ 需要/ 对/ 继承/ 树上/ 的/ 各个/ 类型/ 进行/ 逆/ 拓扑/ 排序/ ./ 使用/ 如上/ 的/ 拆分/ 方式/ 可以/ 精确/ 处理/ 多态/ 调用/ 带来/ 的/ 剖析/ 问题/ ./ 但是/ 却/ 具有/ 如下/ 的/ 缺点/ :/ 首先/ ,/ 调用/ 的/ 边/ 的/ 拆分/ 需要/ 对应/ 到/ 源代码/ 的/ 修改/ 之中/ ,/ 这/ 对于/ 多态/ 关系/ 比较复杂/ 的/ 情况/ 可能/ 会/ 带来/ 较/ 高/ 的/ 耗费/ ;/ 其次/ ,/ 该/ 拆分/ 增加/ 了/ 调用/ 边/ ,/ 将/ 控制流/ 图/ 的/ 结构/ 变得/ 更/ 复杂/ ,/ 很/ 可能/ 会/ 导致/ 剖析/ 需要/ 更/ 多/ 的/ 探针/ 来/ 实现/ ./ 为了/ 应对/ 拆分/ 调用/ 边/ 所/ 带来/ 的/ 以上/ 问题/ ,/ 后/ 文中/ 我们/ 设计/ 了/ 将/ 多个/ 过程/ 进行/ 集簇/ 的/ 方式/ 来/ 处理/ 多态/ 问题/ ./ 3.3/ 剖析/ 模型/ PCCG/ 图/ 为了/ 描述/ 多态/ 调用/ 信息/ ,/ 我们/ 提出/ 了/ 一种/ 新/ 的/ 方法/ 调用/ 模型/ —/ —/ —/ PCCG/ 图/ ,/ 该图/ 是/ 一个/ 有向图/ ,/ 由/ ①/ Overwrite/ ,/ 指/ 子类/ 重/ 定义/ 了/ 父类/ 中/ 的/ 同名/ 方法/ ./ 用于/ 多态/ Page5/ 以下/ 4/ 个/ 集合/ 组成/ :/ 包含/ 一个/ 或/ 多个/ 方法/ ;/ 由/ 一个/ 方法/ 指向/ 一个/ 方法/ 簇/ ;/ 包含/ 在/ 一个/ 且/ 仅/ 一个/ 方法/ 簇中/ ;/ (/ 1/ )/ 方法/ 簇/ 集合/ CS/ (/ ClusterSet/ )/ ,/ 每个/ 方法/ 簇/ (/ 2/ )/ 方法/ 集合/ PS/ (/ ProcedureSet/ )/ ,/ 每个/ 方法/ 都/ (/ 3/ )/ 调用/ 边/ 集合/ CE/ (/ CallEdges/ )/ ,/ 每条/ 调用/ 边/ (/ 4/ )/ 返回/ 边/ 集合/ RE/ (/ ReturnEdges/ )/ ,/ 每条/ 返回/ 边/ 从/ 被/ 调用/ 方法/ 指向/ 调用者/ 所在/ 的/ 方法/ 簇/ ./ 图/ 5/ 给出/ 了/ 一个/ PCCG/ 的/ 示例/ ./ 图/ 5/ (/ a/ )/ 表示/ 了/ 一个/ 具有/ 5/ 个/ 方法/ 的/ 调用/ 图/ ,/ 其中/ 有/ 两个/ (/ 显式/ )/ 调用/ 关系/ ,/ 分别/ 从/ A/ 指向/ C/ ,/ 从/ B/ 指向/ D/ ;/ 其中/ 包含/ 3/ 个/ 覆盖/ 关系/ (/ 虚线/ 所示/ )/ :/ B/ 覆盖/ A/ ,/ D/ 覆盖/ C/ ,/ E/ 覆盖/ D/ ./ 在/ 这些/ 信息/ (/ 方法/ 集合/ 、/ 调用/ 关系/ 、/ 覆盖/ 关系/ )/ 的/ 基础/ 之上/ ,/ 我们/ 可以/ 按照/ 如下/ 步骤/ 计算/ 相应/ 的/ PCCG/ 图/ :/ (/ 1/ )/ 在/ 调用/ 图上/ 添加/ 潜在/ 的/ 调用/ 边/ (/ 即/ 拆分/ 多态/ 调用/ 边/ )/ ./ 图/ 5/ (/ a/ )/ 中/ 在/ 前述/ 信息/ 基础/ 上/ 增加/ 了/ 3/ 条/ 调用/ 边/ :/ AD/ 、/ AE/ 和/ BE/ ./ (/ 2/ )/ 在/ 拆分/ 多态/ 边/ 的/ 基础/ 上/ ,/ 按照/ 不同/ 的/ 集/ 簇图/ 6PIP/ 关键步骤/ 在/ PAP/ 方法/ 中/ ,/ 组成/ 路径/ 的/ 边/ 的/ 形式/ 是从/ CFG/ 节点/ 指向/ 节点/ ;/ 而/ 在/ PIP/ 方法/ 中/ ,/ 方法/ 调用/ 边/ 、/ 返回/ 边/ 是从/ 一个/ 方法/ 节点/ 指向/ 一个/ 方法/ 簇/ ./ PIP/ 使/ 标准/ 对/ 方法/ 进行/ 集簇/ ,/ 然后/ 删除/ 冗余/ 的/ 调用/ 边/ ,/ 如图/ 5/ (/ b/ )/ 所示/ ./ 图/ 5/ (/ b/ )/ 中将/ 方法/ A/ 和/ B/ 划归/ 一簇/ ,/ 将/ C/ 、/ D/ 和/ E/ 划归/ 另/ 一簇/ ,/ 在/ 此集/ 簇/ 关系/ 下/ ,/ 调用/ 边/ 被/ 重/ 约简/ 为/ 2/ 条/ ./ (/ 3/ )/ 在/ PCCG/ 上/ 添加/ 返回/ 边/ ,/ 如图/ 5/ (/ c/ )/ 所示/ ./ 如果/ 一个/ 方法/ A/ 调用/ 了/ 某个/ 方法/ 簇/ C/ ,/ 那么/ C/ 中/ 的/ 每个/ 方法/ 都/ 有/ 一条/ 返回/ 边/ 指向/ A/ 所在/ 的/ 簇/ ,/ 即/ 返回/ 边/ 也/ 是从/ 方法/ 指向/ 方法/ 簇/ ./ 以上/ 步骤/ 将/ 多态/ 方法/ 调用/ 信息/ 转化/ 为/ PCCG/ 的/ 过程/ 中是/ 安全/ 的/ ,/ 即/ 所有/ 的/ 调用/ 可能性/ 均/ 包含/ 在/ 转化/ 后/ 的/ PCCG/ 图中/ ;/ 但是/ 该/ 过程/ 不是/ 精确/ 的/ ,/ 因为/ 在/ 集簇/ 的/ 过程/ 中/ 可能/ 添加/ 了/ 某些/ 调用/ 可能性/ ,/ 如/ 原本/ 方法/ B/ 不/ 可能/ 调用/ 方法/ C/ ,/ 但是/ 在/ PCCG/ 图上/ 无法/ 得出/ 这一/ 信息/ ./ 因此/ ,/ PCCG/ 模型/ 是/ 多态/ 方法/ 调用/ 关系/ 的/ 安全/ 非/ 精确/ 模型/ ./ 由于/ 过程/ 间/ 路径/ 剖析/ 所/ 获取/ 的/ 信息/ 仅/ 针对实际/ 发生/ 的/ 执行/ ,/ 所以/ PCCG/ 的/ 非/ 精确性/ 并/ 不会/ 导致/ 剖析/ 结果/ 的/ 非/ 精确性/ ,/ 使用/ PCCG/ 作为/ 剖析/ 模型/ 是/ 合理/ 可行/ 的/ ./ 3.4/ 过程/ 间/ 路径/ 剖析/ PIP/ 方法/ 主要/ 的/ 实施/ 步骤/ 如下/ (/ 图/ 6/ 所示/ )/ :/ (/ 1/ )/ PIP/ 方法/ 的/ 输入/ 包括/ 过程/ 间/ 控制流/ 图/ 、/ 过程/ 调用/ 关系/ 以及/ 方法/ 的/ 集簇/ 策略/ ,/ 在/ 此/ 输入/ 的/ 基础/ 上/ ,/ 将/ 过程/ 间/ 控制流/ 图/ 建模/ 为/ PCCG/ 图/ ;/ (/ 2/ )/ 在/ PCCG/ 模型/ 上/ 产生/ 需要/ 插装/ 的/ 探针/ ,/ 对/ 入度/ 大于/ 1/ 的/ 每个/ 被/ 调用/ 簇/ 的/ n/ 条入/ 边/ ,/ 依次/ 分配/ 探针/ n/ (/ 0/ )/ ,/ n/ (/ 1/ )/ ,/ …/ ,/ n/ (/ n/ -/ 1/ )/ ,/ 并/ 根据/ 探针/ 对待/ 剖析/ 程序/ 源码/ 进行/ 插装/ ;/ (/ 3/ )/ 运行/ 插装后/ 的/ 程序/ 源码/ ,/ 并/ 收集/ 执行/ 路径/ 的/ 编码/ 及/ 频率/ 信息/ ,/ 将/ 之/ 解码/ 为/ 剖析/ 结果/ ./ 用/ 方法/ 簇/ 作为/ 路径/ 中/ 的/ 部分/ 节点/ 却/ 不会/ 降低/ 其/ 路径/ 的/ 描述/ 信息/ ,/ 这是/ 由于/ 后/ 一种/ 形式/ 的/ 路径/ 可以/ 精确/ 地/ 反应/ 出前/ 种/ 路径/ ./ Page6/ 因此/ ,/ 在/ PIP/ 解码/ 路径/ 的/ 时候/ ,/ 方法/ 到/ 方法/ 簇/ 的/ 调用/ 边/ 和/ 返回/ 边/ 可以/ 等价/ 地/ 转化/ 为/ 方法/ 到/ 方法/ 的/ 边/ ,/ 不会/ 导致/ 路径/ 描述/ 由/ 细粒度/ 变为/ 粗粒度/ ,/ 造成/ 任何/ 路径/ 信息/ 的/ 损失/ ./ 4/ 实验/ 分析/ 本/ 章节/ 对/ PIP/ 方法/ 的/ 应用/ 效果/ 分/ 两个/ 方面/ 进行/ 测试/ ./ 首先/ ,/ 在/ 基准/ 测试程序/ 上/ 对/ PIP/ 方法/ 和/ IPP/ 方法/ 进行/ 比较/ ,/ 以/ 检验/ PIP/ 的/ 有效性/ ;/ 其次/ ,/ 由于/ PIP/ 方法/ 需要/ 应用/ 集簇/ 策略/ ,/ 我们/ 随机/ 生成/ 多种/ 结构/ 类型/ 的/ PCCG/ 图/ ,/ 对/ 多个/ 策略/ 进行/ 模拟/ ,/ 以期/ 检验/ 出/ 最佳/ 策略/ ,/ 指导/ 实际/ 情况/ 中/ 的/ 应用/ ./ 4.1/ 检验/ PIP/ 有效性/ 从前/ 文/ 的/ 理论/ 分析/ 可知/ ,/ PIP/ 方法/ 可以/ 精确/ 地/ 剖析/ 过程/ 间/ 路径/ ,/ 尤其/ 是/ 带有/ 循环/ (/ 包括/ 回边/ 和/ 递归/ 调用/ )/ 的/ 路径/ ./ 而/ IPP/ 方法/ 不/ 剖析/ 带有/ 回边/ 的/ 路径/ ,/ ExPP/ 方法/ 仅/ 剖析/ 带有/ 一次/ 回边/ 执行/ 的/ 路径/ 且/ 给出/ 的/ 是/ 近似/ 剖析/ 结果/ ,/ 且/ 欠缺/ 具体/ 的/ 实现/ 细节/ ./ 这里/ 我们/ 将/ PIP/ 方法/ 与/ IPP/ 方法/ 进行/ 比较/ ./ 4.1/ ./ 1/ 度量/ 标准/ 一种/ 剖析/ 方法/ 主要/ 有/ 3/ 个/ 方面/ 的/ 度量/ 标准/ :/ 效率/ 、/ 完整性/ 和/ 精确性/ ./ 效率/ 指/ 的/ 是/ 剖析/ 的/ 时间/ 耗费/ ,/ 可以/ 用/ 插/ 装后/ 的/ 程序执行/ 时间/ 来/ 进行/ 衡量/ ;/ 完整性/ 指/ 的/ 是/ 是否/ 能够/ 收集/ 所有/ 执行/ 路径/ 的/ 频率/ ;/ 精确性/ 我们/ 遍历/ JDK/ [/ 11/ ]/ 的/ 所有/ 包/ (/ package/ )/ ,/ 按照/ 如/ (/ 1/ )/ 包/ 的/ 入口/ 方法/ 为/ static/ 类型/ ,/ 便于/ 构建/ 测试/ (/ 2/ )/ 以/ 入口/ 方法/ 及其/ 可/ 达/ 方法/ 构建/ 的/ 调用/ 图/ 必须/ 包含/ 较/ 多/ 的/ 调用/ 边/ ,/ 以/ 更好/ 地/ 对/ PIP/ 和/ IPP/ 方法/ 的/ 过程/ 间/ 剖析/ 能力/ 进行/ 检验/ ;/ (/ 3/ )/ 入口/ 方法/ 的/ 参数/ 必须/ 易于/ 构建/ ./ 这样/ 便于/ 计算/ 出其/ 输入/ 域/ ,/ 进而/ 构建/ 较为/ 全面/ 的/ 测试用例/ 进行/ 完整/ 的/ 测试/ ./ 准则/ 1/ 和/ 2/ 可以/ 自动化/ 实现/ ,/ 准则/ 3/ 需要/ 人工干预/ ./ 我们/ 首先/ 求解/ JDK/ 中/ 满足/ 准则/ 1/ 和/ 2/ 的/ 包/ ,/ 然后/ 从中/ 按照/ 准则/ 3/ 进一步/ 选取/ 出/ 最终/ 使用/ 的/ 基准/ 测试程序/ ./ JDK/ 中/ 满足/ 准则/ 1/ 和/ 2/ 的/ 包/ 共有/ 14/ 个/ ,/ 如表/ 1/ 所列/ ./ 最终/ 我们/ 按照/ 准则/ 3/ 选择/ 其中/ 的/ 5/ 个/ 作为/ 测试/ 用/ 程序/ ./ 表/ 1JDK/ 入口/ 方法/ 及/ 调用/ 边/ 信息/ GIFImageWriter/ :/ computeRegionsGIFImageWriter/ :/ createColorTableImageUtil/ :/ getUnpackedBinaryDataPaletteBuilder/ :/ createIndexColorModel/ 入口/ 方法/ ImageUtil/ :/ getTileSizeImageUtil/ :/ setPackedBinaryDataImageUtil/ :/ setUnpackedBinaryDataImageUtil/ :/ getPackedBinaryDataImageUtil/ :/ createColorModelImageUtil/ :/ getBandSizePaletteBuilder/ :/ createIndexedImageJFIFMarkerSegment/ :/ writeICCAdobeMarkerSegment/ :/ writeAdobeSegmentJFIFMarkerSegment/ :/ writeDefaultJFIFcom/ ./ sun/ ./ imageio/ ./ plugins/ ./ gifcom/ ./ sun/ ./ imageio/ ./ plugins/ ./ commoncom/ ./ sun/ ./ imageio/ ./ plugins/ ./ jpeg4/ ./ 1.3/ 使用/ 的/ 集簇/ 策略/ 法/ 单独/ 作为/ 一个/ 簇/ ;/ 本/ 实验/ 中/ 我们/ 设计/ 了/ 3/ 个/ 集簇/ 策略/ :/ (/ 1/ )/ 策略/ SC/ (/ Single/ -/ procedureCluster/ )/ ,/ 每个/ 方/ (/ 2/ )/ 策略/ IC/ (/ InheritanceCluster/ )/ ,/ 如果/ 两个/ 方/ (/ 3/ )/ 策略/ AC/ (/ All/ -/ procedureCluster/ )/ ,/ 所有/ 方法/ 法/ 之间/ 存在/ 覆盖/ 关系/ ,/ 那么/ 将/ 其/ 划归/ 一簇/ ;/ 包含/ 在/ 一个/ 簇中/ ./ 指/ 的/ 是/ 收集/ 的/ 路径/ 频率/ 是否/ 精准/ 可信/ ./ 对于/ IPP/ 方法/ 来说/ ,/ 由于/ 其/ 在/ 回边/ 处/ 终止/ ,/ 得出/ 的/ 剖析/ 结果/ 不/ 包括/ 所有/ 路径/ ,/ 具有/ 不/ 完整性/ ,/ 而/ PIP/ 的/ 剖析/ 结果/ 是/ 完整/ 的/ ;/ 对于/ PIP/ 和/ IPP/ ,/ 两种/ 方法/ 均/ 是/ 完全/ 精确/ 的/ ./ 因此/ ,/ 实验/ 的/ 度量/ 标准/ 包括/ 执行/ 时间/ 和/ IPP/ 方法/ 的/ 不/ 完整性/ ./ 4.1/ ./ 2/ 基准/ 测试程序/ 下/ 的/ 准则/ 选取/ 合适/ 的/ 测试程序/ :/ 用例/ ;/ 图/ 7/ 举例说明/ 了/ 策略/ AC/ :/ 图/ 7/ (/ b/ )/ 是/ 图/ 7/ (/ a/ )/ 中/ 方法/ 调用/ 图/ 按照/ 策略/ AC/ 集簇/ 后/ 的/ 结果/ ,/ 所有/ 方法/ 在/ 同一/ 簇/ 之后/ ,/ 每个/ 调用者/ 方法/ 均/ 只有/ 一条/ 调用/ 边/ 指向/ 唯一/ 的/ 簇/ ,/ 调用/ 边/ 数目/ 减小/ 到/ 极致/ ./ 4.1/ ./ 4/ 实验/ 结果/ 首先/ 我们/ 得出/ PIP/ 方法/ 和/ IPP/ 方法/ 插装后/ 5/ 个/ 基准/ 程序/ 的/ 执行/ 时间/ ,/ 如图/ 8/ 所示/ ./ 图中/ Original/ 系列/ 指/ 的/ 是/ 未/ 插装/ 之前/ 的/ 程序执行/ 时间/ ,/ IPP/ 系列/ 指/ Page7/ 的/ 是/ 使用/ IPP/ 方法/ 插装后/ 的/ 执行/ 时间/ ,/ PIP/ (/ SC/ )/ 系列/ 指/ 的/ 是/ 以集/ 簇/ 策略/ SC/ 进行/ PIP/ 插装/ 的/ 执行/ 时间/ ,/ 其余/ 策略/ 同样/ ./ 从图/ 8/ 中/ 的/ 结果/ 可以/ 看出/ ,/ 总计/ 5/ 个/ 程序/ 上/ ,/ 有/ 两个/ 程序/ (/ computeRegions/ 和/ getBandSize/ )/ PIP/ 方法/ 的/ 时间/ 耗费/ 多于/ IPP/ 方法/ ,/ 有/ 两个/ (/ getTileSize/ 和/ getUnpackedBinaryData/ )/ PIP/ 方法/ 耗费/ 小于/ IPP/ ,/ 有/ 一个/ (/ writeAdobeSegment/ )/ PIP/ 和/ IPP/ 插装/ 均/ 未/ 带来/ 明显/ 的/ 耗费/ 增加/ ./ 图/ 9/ 展示/ 了/ IPP/ 方法/ 不能/ 剖析/ 的/ 路径/ (/ 即/ 循环/ 路径/ )/ 占/ 总/ 执行/ 路径/ 的/ 百分比/ ,/ 其中/ 在/ getTileSize/ 和/ getUnpackedBinaryData/ 上/ IPP/ 的/ 不/ 完整/ 度/ 分别/ 达到/ 了/ 24.90/ %/ 和/ 88.06/ %/ ,/ 而/ 在/ 其它/ 3/ 个/ 程序/ 上/ 未/ 观察/ 到/ 循环/ 路径/ 的/ 执行/ ./ 相比之下/ ,/ PIP/ 方法/ 能够/ 精确/ 剖析/ 循环/ 路径/ ,/ 剖析/ 结果/ 更为/ 完整/ ./ 4.1/ ./ 5/ 分析/ 与/ 讨论/ 从/ 实验/ 结果/ 可以/ 看出/ ,/ PIP/ 和/ IPP/ 方法/ 的/ 应用/ 效果/ 可以/ 按照/ 待/ 剖析/ 程序/ 的/ 类型/ 分为/ 3/ 类/ :/ (/ 1/ )/ 类似/ 于/ 程序/ writeAdobeSegment/ ,/ 其中/ 的/ 执行/ 非常简单/ ,/ PIP/ 和/ IPP/ 方法/ 的/ 插/ 装均/ 不会/ 导致/ 明显/ 的/ 执行/ 时间/ 耗费/ 增加/ ./ 但是/ 由于/ PIP/ 方法/ 能够/ 处理/ 有环/ 路径/ ,/ 其/ 剖析/ 能力/ 强于/ IPP/ ,/ 故/ 在/ 此类/ 程序/ 上/ 应该/ 使用/ PIP/ 方法/ 进行/ 剖析/ ./ (/ 2/ )/ 类似/ 于/ 程序/ computeRegions/ 和/ getBand/ -/ Size/ ,/ 其中/ 的/ 程序执行/ 并/ 不会/ 设计/ 循环/ ,/ 由于/ IPP/ 的/ 时间/ 耗费/ 小于/ PIP/ ,/ 故/ 应该/ 使用/ IPP/ 方法/ 进行/ 剖析/ ./ (/ 3/ )/ 类似/ 于/ 程序/ getUnpackedBinaryData/ 和/ getTileSize/ ,/ 其中/ 存在/ 大量/ 涉及/ 回边/ 的/ 执行/ ,/ IPP/ 方法/ 会/ 产生/ 较/ 高/ 的/ 不/ 完整性/ ,/ 为了/ 获取/ 准确/ 的/ 剖析/ 结果/ ,/ 应该/ 使用/ PIP/ 方法/ 进行/ 剖析/ ./ 此外/ ,/ 在/ 集簇/ 策略/ 方面/ ,/ 3/ // 5/ 的/ 程序/ 上/ 策略/ AC/ 的/ 时间/ 耗费/ 小于/ IC/ 和/ SC/ ,/ 仅/ 在/ 程序/ writeAdobe/ -/ Segment/ 和/ getUnpackedBinaryData/ 上/ 耗费/ 略高于/ SC/ (/ 约/ 高/ 0.45/ %/ 和/ 2.3/ %/ )/ ;/ 所有/ 程序/ 上/ 平均/ AC/ 较/ IC/ 耗费/ 降低/ 约/ 11.8/ %/ ,/ 较/ SC/ 耗费/ 降低/ 约/ 22.0/ %/ ./ 因此/ 在/ 本/ 实验/ 中/ ,/ 使用/ 策略/ AC/ 进行/ 集簇/ 的/ 效果/ 最好/ ./ 4.2/ 检验/ PIP/ 集簇/ 策略/ 4.1/ 小节/ 的/ 实验/ 在/ 基准/ 测试程序/ 上/ 检验/ 了/ PIP/ 方法/ 的/ 有效性/ ./ 而/ 在/ 应用/ PIP/ 方法/ 时/ ,/ 需要/ 给定/ 方法/ 的/ 集簇/ 策略/ ,/ 且/ 不同/ 的/ 集簇/ 策略/ 带来/ 不同/ 的/ 剖析/ 效率/ (/ 对/ 剖析/ 结果/ 没有/ 影响/ )/ ./ 因此/ ,/ 我们/ 需要/ 找出/ 较优/ 的/ 集簇/ 策略/ 以/ 达到/ 较/ 好/ 的/ 应用/ 效果/ ./ 本/ 小节/ 的/ 实验/ 使用/ 随机/ 生成/ 的/ 方法/ 调用/ 图/ ,/ 对/ 多种/ 集簇/ 策略/ 的/ 效果/ 进行/ 模拟/ 和/ 比较/ ./ 我们/ 按照/ 如下/ 的/ 步骤/ 生成/ 随机/ 的/ 方法/ 调用/ 图/ :/ (/ 1/ )/ 随机/ 生成/ 多个/ 节点/ ,/ 每个/ 节点/ 代表/ 一个/ 方法/ ,/ 并/ 从中/ 选择/ 其一/ 作为/ 程序/ 的/ 入口/ 方法/ ./ (/ 2/ )/ 在/ 各个/ 节点/ 中/ ,/ 我们/ 按照/ 两个/ 参数/ RP/ (/ RatioofcallsbetweeneachpairofProcedures/ )/ 和/ PR/ (/ ratioofPolymorphicRelations/ )/ 来/ 随机/ 在/ 节点/ 之间/ 生成/ 调用/ 边/ ./ 其中/ RP/ 参数/ 的/ 含义/ 为/ 每/ 对/ 节点/ 之间/ 存在/ 调用/ 边/ 的/ 概率/ ,/ 计算/ 方式/ 为/ 图/ 中/ 调用/ 边/ 总数/ 除以/ 节点/ 总数/ 的/ 平方/ ;/ PR/ 参数/ 的/ 含义/ 为/ 每/ 对/ 方法/ 之间/ 存在/ 覆盖/ 关系/ 的/ 概率/ ,/ 计算/ 方式/ 为/ 覆盖/ 边/ 总数/ 除以/ 节点/ 总数/ 的/ 平方/ ./ 连通性/ ,/ 即/ 入口/ 节点/ 需要/ 可达图/ 中/ 每个/ 节点/ ./ 4.2/ ./ 1/ 度量/ 标准/ 由于/ 是/ 在/ 抽象层次/ 的/ PCCG/ 图上/ 进行/ 的/ 实验/ ,/ 不适/ 用于/ 执行/ 时间/ 等/ 度量/ 标准/ ,/ 需要/ 从/ 抽象层次/ 的/ 特性/ 中/ 寻找/ 合适/ 的/ 、/ 具有/ 实际/ 指导意义/ 的/ 度量/ 标准/ ./ 由于/ PAP/ 方法/ 的/ 效率/ 与/ 执行/ 中/ 产生/ 的/ 非/ 重复/ 断点/ 的/ 数目/ 有关/ ,/ 非/ 重复/ 断点/ 的/ 数目/ 越小/ ,/ 执行/ 效率/ 越高/ [/ 10/ ]/ ./ 由于/ PIP/ 方法/ 使用/ 类似/ PAP/ 方法/ 的/ 探针/ ,/ 故/ 这里/ 我们/ 沿用/ 此/ 结论/ ,/ 并/ 以/ 非/ 重复/ 断点/ 数目/ 作为/ (/ 3/ )/ 为/ 方法/ 调用/ 图/ 添加/ 必要/ 的/ 调用/ 边以/ 保证/ 其/ Page8/ 衡量/ 各个/ 集簇/ 策略/ 的/ 效率/ 的/ 标准/ ./ 在/ PCCG/ 图上/ ,/ 根据/ 集簇/ 关系/ 、/ 路径/ 以及/ 探针/ 插装/ 情况/ ,/ 就/ 可以/ 计算/ 路径/ 编码/ ,/ 进而/ 计算/ 出/ 剖析/ 所/ 需要/ 的/ 独特/ 断点/ (/ 即非/ 重复/ 断点/ )/ 的/ 数目/ ./ 4.2/ ./ 2/ 集簇/ 策略/ 在/ 4.1/ 小节/ 中/ 所/ 构建/ 的/ 3/ 个/ 集簇/ 策略/ SC/ 、/ IC/ 和/ AC/ 之外/ ,/ 我们/ 增加/ 一类/ 更具/ 一般性/ 的/ 集簇/ 策略/ :/ s/ (/ n/ )/ ./ 该/ 策略/ 的/ 含义/ 为/ :/ 在/ PCCG/ 图上/ ,/ 如果/ 两个/ 节点/ 同时/ 被/ n/ 个/ 方法/ 调用/ ,/ 那么/ 这/ 两个/ 节点/ 需要/ 归于/ 一簇/ ./ 显然/ ,/ s/ (/ 0/ )/ 等同于/ AC/ ,/ 因为/ 任意/ 两个/ 节点/ ,/ 无论/ 其/ 是否/ 被/ 同样/ 的/ 方法/ 调用/ ,/ 均会/ 被/ 归于/ 一簇/ ;/ s/ (/ )/ (/ 表示/ 正/ 无穷大/ )/ 等同于/ SC/ ,/ 因为/ 任意/ 两个/ 节点均/ 不会/ 归于/ 一类/ 之中/ ./ 使用/ 策略/ s/ (/ i/ +/ 1/ )/ 集簇/ 的/ 结果/ 中/ ,/ 每个/ 簇/ 不/ 小于/ 使用/ 策略/ s/ (/ i/ )/ 的/ 结果/ ./ 在/ 特定/ 的/ 情况/ ,/ 可能/ 存在/ s/ (/ i/ )/ 和/ s/ (/ j/ )/ (/ i/ ≠/ j/ )/ 集簇/ 结果/ 相同/ 的/ 情况/ ./ 在/ 本/ 小节/ 的/ 实验/ 中/ ,/ 我们/ 测试/ 集簇/ 策略/ SC/ 、/ s/ (/ 2/ )/ 、/ s/ (/ 3/ )/ 、/ s/ (/ 4/ )/ 、/ s/ (/ 5/ )/ 、/ IC/ 和/ AC/ 的/ 应用/ 效果/ ./ 4.2/ ./ 3/ 实验/ 结果/ 我们/ 使用/ 包含/ 100/ 个/ 方法/ 的/ 调用/ 图/ ./ 为了/ 在/ 生成/ PCCG/ 图时/ 选择/ 更/ 贴近/ 实际/ 的/ RP/ 和/ PR/ 参数/ 取值/ ,/ 我们/ 对/ JDK/ 中/ 的/ 所有/ 包/ 进行/ 统计/ ,/ 计算/ 出/ 其中/ 的/ RP/ 和/ PR/ 实际/ 取值/ ,/ 如图/ 10/ 所示/ ./ 从图/ 10/ 中/ 可以/ 看出/ ,/ 参数/ RP/ 的/ 取值/ 主要/ 集中/ 图/ 111/ 条/ 路径/ 的/ 实验/ 结果/ 于/ 0/ ~/ 10/ %/ ,/ 而/ PR/ 的/ 取值/ 主要/ 集中/ 于/ 0/ ~/ 40/ %/ ,/ 所以/ 我们/ 以/ RP/ =/ 1/ %/ ,/ 2/ %/ ,/ …/ ,/ 10/ %/ ,/ PR/ =/ 0/ ,/ 10/ %/ ,/ 20/ %/ ,/ 30/ %/ ,/ 40/ %/ 作为/ 参数/ 取值/ ,/ 并/ 以/ 二者/ 取值/ 的/ 两/ 两/ 组合/ 生成/ PCCG/ 图/ ./ 基于/ 随机/ 生成/ 的/ PCCG/ 图和图/ 上/ 的/ 路径/ (/ 每条/ 路径/ 不少/ 于/ 1000/ 次/ 方法/ 调用/ )/ ,/ 我们/ 计算/ 出/ 1/ 、/ 100/ 和/ 2000/ 条/ 独立/ 路径/ 下/ 各个/ 集簇/ 策略/ 的/ 效果/ ,/ 如图/ 11/ ~/ 图/ 13/ 所示/ ./ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaPage9/ 图/ 12100/ 条/ 路径/ 的/ 实验/ 结果/ 图/ 132000/ 条/ 路径/ 的/ 实验/ 结果/ 4.2/ ./ 4/ 分析/ 与/ 讨论/ 从/ 实验/ 结果/ 中/ 可以/ 观察/ 到/ 如下/ 几点/ :/ (/ 1/ )/ 当/ 执行/ 的/ 路径/ 很少/ 时/ ,/ 如图/ 11/ 所示/ ,/ PIP/ 方法/ 的/ 耗费/ 对/ PCCG/ 的/ 具体/ 结构/ 有着/ 较/ 高/ 的/ 依赖/ (/ 实验/ 结果/ 的/ 随机性/ 较大/ )/ ,/ 没有/ 一个集/ 簇/ 策略/ 能够/ 在/ 所有/ 情况/ 下/ 表现/ 最好/ ./ 但是/ 从/ 平均/ 程度/ 看/ ,/ 较/ 小/ 的/ 簇会/ Page10/ 带来/ 较/ 高/ 的/ 效率/ ,/ 而/ 策略/ SC/ 相较/ 其他/ 策略/ 而言/ 效率/ 较/ 高/ ./ 这种/ 结果/ 是/ 由/ 两/ 方面/ 的/ 原因/ 导致/ 的/ :/ 一方面/ ,/ 当/ 路径/ 较/ 少时/ ,/ 各个/ 断点/ 重复/ 的/ 概率/ 不/ 大/ ;/ 另一方面/ ,/ 总/ 断点/ 数目/ 在/ 很大/ 程度/ 上/ 决定/ 于/ 路径/ 的/ 编码/ 大小/ ,/ 而/ 较/ 小/ 的/ 簇会/ 导致/ 探针/ 的/ 权值/ 较/ 小/ ,/ 进而/ 导致/ 非/ 重复/ 断点/ 的/ 数目/ 较/ 小/ ./ 失/ ,/ 而/ 可以/ 明显/ 观察/ 到/ :/ (/ 2/ )/ 随着/ 路径/ 数目/ 的/ 增多/ ,/ 上述/ 随机性/ 逐渐/ 消/ ①/ SC/ 在/ 剖析/ 较/ 多路径/ 时/ 效果/ 较差/ ,/ 而且/ 它/ 与/ 其它/ 集簇/ 策略/ 的/ 差距/ 随着/ 路径/ 数目/ 的/ 增多/ 而/ 增大/ (/ 例如/ 图/ 12/ 中/ 路径/ 数目/ 为/ 100/ ,/ 当/ PR/ =/ 0/ 时/ ,/ SC/ 的/ 耗费/ 是/ AC/ 的/ 10.8/ 倍/ ;/ 而/ 在/ 图/ 13/ 中/ 路径/ 数目/ 为/ 2000/ 时/ ,/ 该/ 差距/ 增加/ 到/ 38.8/ 倍/ )/ ;/ ②/ AC/ 在/ 大部分/ 情况/ 下/ 效果/ 最好/ ,/ 因为/ 使用/ AC/ 集簇/ 图中/ 的/ 边/ 很少/ ,/ 产生/ 重复/ 断点/ 的/ 概率/ 更高/ ;/ ③/ 当/ PR/ 较大/ 时/ ,/ IC/ 在/ 部分/ 情况/ 下/ 的/ 效果/ 要/ 好/ 于/ AC/ ,/ 例如/ 图/ 12/ 中/ ,/ PR/ =/ 0.3/ 的/ 情况/ 下/ ,/ 10/ 个/ 实例/ 中/ IC/ 效果/ 好于/ AC/ 的/ 有/ 两个/ ,/ PR/ =/ 0.4/ 时有/ 3/ 个/ ,/ 且/ IC/ 在/ PR/ =/ 0.4/ 时/ IC/ 的/ 平均/ 效果/ 也/ 高于/ AC/ ;/ 在/ 图/ 13/ 中/ ,/ PR/ =/ 0.3/ 时有/ 两个/ 实例/ IC/ 比/ AC/ 效果/ 更好/ ,/ PR/ =/ 0.4/ 时有/ 4/ 个/ ./ (/ 3/ )/ 在/ s/ (/ n/ )/ 中/ ,/ 仅/ 有/ s/ (/ 2/ )/ 在/ 部分/ 情况/ 下/ 效果/ 较/ 好/ ,/ 而/ s/ (/ 3/ )/ ~/ s/ (/ 5/ )/ 普遍/ 效果/ 较差/ ,/ 且/ 在/ 路径/ 较多时/ 效果/ 不如/ s/ (/ 2/ )/ ./ 4.3/ 实验/ 结论/ 从/ 以上/ 实验/ 结果/ 中/ ,/ 我们/ 可以/ 得出/ 如下/ 结论/ :/ (/ 1/ )/ 在/ PIP/ 与/ IPP/ 的/ 比较/ 方面/ ,/ PIP/ 适用/ 于/ 较/ 短/ 的/ 执行/ 或者/ 带有/ 回边/ 的/ 执行/ ;/ 而/ IPP/ 方法/ 适用/ 于/ 较/ 长/ 的/ 无环/ 执行/ ./ (/ 2/ )/ 在/ PIP/ 集簇/ 策略/ 的/ 选择/ 方面/ ,/ 当待/ 剖析/ 的/ 路径/ 较多时/ ,/ 应/ 选择/ AC/ 或/ s/ (/ 2/ )/ 作为/ 集簇/ 策略/ ,/ 以/ 获得/ 较大/ 的/ 簇/ 并/ 使得/ 执行/ 中/ 的/ 断点/ 能够/ 大量/ 重复/ ;/ 反之/ ,/ 当/ 路径/ 数目/ 较/ 少时/ ,/ 应/ 选择/ SC/ 作为/ 集簇/ 策略/ ,/ 以/ 压缩/ 路径/ 编码/ 和/ 总/ 断点/ 数目/ ;/ 当/ 方法/ 调用/ 图中/ 具有/ 复杂/ 的/ 覆盖/ 关系/ 时/ ,/ 也/ 可以/ 考虑/ 使用/ IC/ 策略/ ./ 4.4/ 威胁/ 分析/ 我们/ 的/ 实验/ 主要/ 有/ 3/ 种/ 内部/ 威胁/ 和/ 2/ 种/ 外部/ 威胁/ ./ 内部/ 威胁/ :/ (/ 1/ )/ 实验/ 人员/ 偏好/ ./ 我们/ 基于/ Java/ 和/ Eclipse/ 平台/ 实现/ 了/ PIP/ 方法/ ,/ 可以/ 自动/ 地/ 进行/ 插装/ 和/ 输出/ 实验/ 结果/ ,/ 避免/ 剖析/ 过程/ 中/ 的/ 人工干预/ ,/ 以/ 避免/ 实验者/ 的/ 个人/ 偏好/ 对/ 实验/ 结果/ 产生/ 影响/ ./ (/ 2/ )/ 选择/ 偏好/ ./ 在/ 4.1/ 节/ 的/ 实验/ 中/ ,/ 在/ 基准/ 测试程序/ 的/ 选择/ 上/ ,/ 首先/ 自动/ 地/ 从/ JDK/ 程序/ 中/ 选出/ 14/ 个/ 待用/ 程序/ ,/ 然后/ 人工/ 地/ 按照/ 既定/ 的/ 准则/ 从中/ 再/ 选出/ 5/ 个/ 作为/ 最终/ 选择/ 结果/ ;/ 在/ 4.2/ 节/ 的/ 实验/ 中/ ,/ 所有/ 的/ 调用/ 图/ 和/ 路径/ 均/ 是/ 自动/ 生成/ ,/ 故/ 最大/ 程度/ 上/ 避免/ 了/ 实验/ 的/ 选择/ 偏好/ ./ (/ 3/ )/ 实验/ 精度/ ./ 实验/ 所用/ 的/ Eclipse/ 平台/ 具有/ 较/ 高/ 的/ 可靠性/ ,/ PIP/ 方法/ 和/ IPP/ 方法/ 的/ 实现/ 也/ 进行/ 了/ 正确性/ 检验/ ./ 外部/ 威胁/ :/ (/ 1/ )/ 实验/ 结论/ 可靠性/ ./ 5/ 个/ 基准/ 测试程序/ 覆盖/ 了/ 3/ 种/ 应用/ 情况/ ,/ 随机/ PCCG/ 图/ 也/ 包括/ 了/ 较/ 多/ 的/ RP/ 和/ PR/ 参数/ 取值/ 可能/ ,/ 实验/ 结论/ 是/ 在/ 覆盖/ 较/ 多/ 情况/ 的/ 实验/ 结果/ 上/ 做出/ 的/ ,/ 应/ 具有/ 较/ 高可靠性/ ./ (/ 2/ )/ 实验/ 对象/ 的/ 代表性/ ./ 基准/ 测试程序/ 可能/ 尚/ 缺少/ 反应/ 其他/ 程序/ 的/ 能力/ ,/ 而/ 随机/ PCCG/ 图/ 可能/ 与/ 实际/ 程序/ 中/ 的/ 调用/ 结构/ 有所区别/ ./ 在/ 将来/ 需要/ 对/ PIP/ 方法/ 进行/ 更/ 广泛/ 的/ 实验/ 评估/ ./ 5/ 总结/ 自/ 1996/ 年/ EPP/ 方法/ 诞生/ 以来/ ,/ 已/ 出现/ 了/ 约/ 十种/ 剖析/ 方法/ ,/ 适应/ 各种/ 应用/ 场景/ ./ 与/ 本文/ PIP/ 方法/ 相关/ 的/ 技术/ 线索/ 可以/ 整理/ 如下/ :/ (/ 1/ )/ EPP/ 能够/ 精确/ 剖析/ 过程/ 内/ 的/ 无环/ 路径/ ,/ 既/ (/ 2/ )/ IPP/ 在/ EPP/ 的/ 基础/ 上/ 增加/ 了/ 处理过程/ 调用/ 的/ 能力/ ,/ 保持/ 了/ 剖析/ 的/ 精确性/ 但是/ 依然/ 不能/ 处理/ 循环/ 路径/ ;/ 不能/ 处理/ 循环/ 路径/ ,/ 亦/ 不/ 包含/ 过程/ 调用/ ;/ (/ 3/ )/ ExPP/ 一方面/ 扩展/ 了/ EPP/ 处理/ 循环/ 的/ 能力/ ,/ 但是/ 不能/ 维持/ 精确性/ ,/ 属于/ 近似/ 剖析/ ;/ 另一方面/ 可以/ 处理过程/ 间/ 调用/ ,/ 但是/ 缺乏/ 具体/ 方案/ ;/ 精确性/ ,/ 但是/ 未能/ 处理过程/ 间/ 调用/ ;/ (/ 4/ )/ PAP/ 扩展/ 了/ EPP/ 处理/ 循环/ 的/ 能力/ ,/ 保持/ 了/ (/ 5/ )/ PIP/ 方法/ 利用/ 了/ PAP/ 的/ 循环/ 处理/ 能力/ ,/ 增加/ 了/ 对/ 过程/ 间/ 调用/ 的/ 处理/ ,/ 并/ 保持/ 了/ 剖析/ 结果/ 的/ 精确/ ./ 总之/ ,/ 在/ 过程/ 间/ 剖析/ 中/ ,/ 已有/ 的/ 方法/ 或/ 不能/ 剖析/ 有/ 回边/ 的/ 路径/ ,/ 或/ 不能/ 给出/ 准确/ 的/ 剖析/ 结果/ ,/ 且/ 均/ 未/ 考虑/ 多态/ 调用/ 对/ 剖析/ 所/ 带来/ 的/ 影响/ ./ 由于/ 回边/ 、/ 递归/ 调用/ 和/ 多态/ 在/ 面向对象/ 软件/ 中是/ 普遍存在/ 的/ ,/ 一个/ 完整/ 的/ 剖析/ 解决方案/ 不可或缺/ 要/ 对/ 其/ 进行/ 处理/ ./ 本文/ 关注/ 于/ 过程/ 间/ 路径/ 的/ 剖析/ ,/ 主要/ 包含/ 如下/ 工作/ :/ (/ 1/ )/ 在/ PAP/ 方法/ 的/ 基础/ 上/ 说明/ 和/ 证明/ 了/ 过程/ 间/ 路径/ 剖析/ 可以/ 忽略/ 过程/ 内部结构/ ,/ 从而/ 专注/ 于/ 过程/ 间/ 方法/ 调用/ 和/ 返回/ ;/ (/ 2/ )/ 提出/ 了/ 一种/ 描述/ 有/ 多态/ 调用/ 关系/ 的/ 方法/ 调用/ 图/ PCCG/ 模型/ ,/ 并/ 提出/ 以/ PCCG/ 图为/ 基础/ 进行/ 路/ Page11/ 径/ 剖析/ ,/ 可以/ 通过/ 基于/ 多态/ 信息/ 的/ 方法/ 集簇/ 提高效率/ ;/ (/ 3/ )/ 在/ PAP/ 和/ PCCG/ 的/ 基础/ 上/ 提出/ 了/ PIP/ 方法/ ,/ 精确/ 的/ 剖析/ 过程/ 间/ 带有/ 循环/ 的/ 路径/ ./ 此外/ ,/ 在/ 应用/ PIP/ 方法/ 时/ 需要/ 使用/ 合适/ 的/ 集簇/ 策略/ ,/ 以/ 达到/ 较/ 好/ 的/ 效果/ ./ 通过/ 设计/ 多种/ 集簇/ 策略/ ,/ 并/ 基于/ 实验/ 结果/ ,/ 我们/ 给出/ 了/ 在/ 实际/ 应用/ 中/ ,/ 依据/ 调用/ 关系/ 和/ 待/ 剖析/ 路径/ 的/ 特性/ 对集/ 簇/ 策略/ 进行/ 设计/ 和/ 选取/ 的/ 准则/ ./ 在/ 未来/ 工作/ 中/ ,/ 还/ 需要/ 在/ 以下/ 几个/ 方面/ 做/ 进一步/ 研究/ :/ 文中/ 设计/ 并/ 评估/ 了/ 7/ 种集/ 簇/ 策略/ ,/ 却/ 并/ 不能/ 保证/ 其中/ 包含/ 最优/ 策略/ ,/ 对于/ 更好/ 的/ 集簇/ 策略/ 有待/ 进一步/ 寻找/ ;/ 需要/ 在/ 更/ 广泛/ 的/ 应用/ 中/ 对/ PIP/ 的/ 效果/ 和/ 各种/ 集簇/ 策略/ 的/ 优缺点/ 做/ 进一步/ 的/ 验证/ ;/ 实际/ 应用/ 中/ 可能/ 出现/ 的/ 异常/ 处理/ 、/ 进程/ 终止/ 等/ 意外/ 的/ 执行/ 情况/ ,/ 如何/ 进行/ 此类/ 控制流/ 的/ 剖析/ 也/ 有待/ 进一步/ 的/ 分析/ ./ 

