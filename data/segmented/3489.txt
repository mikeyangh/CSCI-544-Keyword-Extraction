Page1/ 层次/ 数据/ 上/ 关键字/ 检索/ 的/ 结果/ 聚合/ 胡昊/ 何震/ 瀛/ (/ 复旦大学/ 计算机/ 科学技术/ 学院/ 上海/ 200433/ )/ 摘要/ 由于/ 使用方便/ 等/ 优点/ ,/ 数据库/ 上/ 的/ 关键字/ 检索/ 技术/ 使/ 用户/ 可以/ 得到/ 所/ 需/ 信息/ 而/ 不必/ 书写/ 复杂/ 的/ SQL/ 语句/ ./ 但/ 大部分/ 现有/ 的/ 检索/ 方法/ 都/ 关注/ 通过/ 连接/ 操作/ 得到/ 包含/ 所有/ 关键字/ 的/ 元组/ 连接/ 树/ ,/ 忽略/ 了/ 对于/ 检索/ 结果/ 的/ 信息/ 整合/ ,/ 这/ 从/ 某种程度/ 上/ 影响/ 了/ 用户/ 对于/ 检索/ 结果/ 的/ 判断/ ./ 文中/ 提出/ 并/ 实现/ 一种/ 改进/ 的/ 关键字/ 检索系统/ 框架/ ,/ 在/ 具有/ 层次结构/ 的/ 属性/ 指导/ 下/ 对/ 得到/ 的/ 元组/ 连接/ 树/ 结果/ 做/ 聚合/ 操作/ ,/ 通过/ 寻找/ 最低/ 层次/ 最小/ 覆盖/ 聚合/ 将/ 关系/ 更为/ 紧密/ 的/ 元组/ 作为/ 更加/ 相关/ 的/ 检索/ 结果/ 反馈/ 给/ 用户/ ./ 文中/ 还/ 提出/ 了/ 基本/ 的/ 聚合/ 算法/ 并/ 对/ 其/ 做/ 改进/ 从而/ 减少/ 了/ 系统/ 的/ 响应/ 时间/ ./ 同时/ ,/ 为了/ 改善/ 用户/ 体验/ ,/ 文中/ 定义/ 并/ 给出/ 了/ 检索/ 结果/ 的/ 摘要/ 问题/ 及其/ 算法/ ,/ 使/ 用户/ 最大/ 程度/ 地/ 了解/ 检索/ 结果/ ./ 实验/ 数据/ 表明/ ,/ 文中/ 的/ 方法/ 能够/ 以较/ 高/ 的/ 效率/ 和/ 较/ 低/ 的/ 计算/ 代价/ 有效/ 地/ 完成/ 检索/ 结果/ 的/ 聚合/ 和/ 摘要/ ./ 关键词/ 关键字/ 检索/ ;/ 聚合/ 操作/ ;/ 层次结构/ ;/ 摘要/ 算法/ 1/ 引言/ 作为/ 从/ 结构化/ 和/ 半/ 结构化/ 数据/ 中/ 提取/ 所/ 需/ 信息/ 的/ 一种/ 方法/ ,/ 关键字/ 检索/ 获得/ 广泛/ 关注/ [/ 1/ -/ 6/ ]/ ./ 近年来/ ,/ 数据库/ 上/ 的/ 关键字/ 检索/ 方法/ 大量/ 涌现/ [/ 1/ ,/ 4/ -/ 5/ ,/ 7/ -/ 8/ ]/ ./ 为/ 获得/ 包含/ 所有/ 关键字/ 的/ 元组/ 或/ 元组/ 连接/ 树/ ,/ 现有/ 方法/ 往往/ 导致/ 冗余/ 信息/ 或/ 无/ 意义/ 结果/ 的/ 产生/ ./ 另一方面/ ,/ 这些/ 方法/ 认为/ 同一/ 关系/ 中/ 的/ 元组/ 间/ 相互/ 独立/ ,/ 事实上/ ,/ 这些/ 元组/ 往往/ 具有/ 层次/ 关系/ ./ 如何/ 利用/ 元组/ 间/ 的/ 图/ 1/ 一个/ 层次/ 关系数据库/ 模式/ 及其/ 实例/ 表/ 1/ 一个/ 可能/ 的/ 检索/ 结果/ Feature1A0010301C00115/ ~/ 20/ …/ ,/ 手自/ 一体/ ,/ 涡轮/ 增压/ 一汽/ 丰田/ 丰田/ 汽车/ (/ 日本/ )/ 2A0020301C00210/ ~/ 15/ …/ ,/ 手自/ 一体/ ,/ 涡轮/ 增压/ 广汽/ 丰田/ 丰田/ 汽车/ (/ 日本/ )/ 4A0040301C00110/ ~/ 15/ …/ ,/ 手自/ 一体/ ,/ 涡轮/ 增压/ 一汽/ 丰田/ 丰田/ 汽车/ (/ 日本/ )/ 5A0050301C00110/ ~/ 15/ 手自/ 一体/ ,/ 涡轮/ 增压/ …/ 一汽/ 丰田/ 丰田/ 汽车/ (/ 日本/ )/ 6A0060301C00210/ ~/ 15/ …/ ,/ 手自/ 一体/ ,/ 涡轮/ 增压/ 广汽/ 丰田/ 丰田/ 汽车/ (/ 日本/ )/ 7A0070302C00115/ ~/ 20/ 手自/ 一体/ ,/ 涡轮/ 增压/ …/ 一汽/ 丰田/ 丰田/ 汽车/ (/ 日本/ )/ 8A0080302C00225/ ~/ 30/ …/ ,/ 手自/ 一体/ ,/ 涡轮/ 增压/ 广汽/ 丰田/ 丰田/ 汽车/ (/ 日本/ )/ 表/ 1/ 的/ 结果/ 只是/ 简单/ 的/ 将/ 符合条件/ 的/ 元组/ 陈列/ 给/ 用户/ ,/ 这/ 需要/ 用户/ 花费/ 一定/ 的/ 时间/ 来/ 分析/ 结果/ ./ 为/ 使/ 检索/ 过程/ 更加/ 有效/ ,/ 将/ 具有/ 共同/ 特征/ 的/ 元组/ 聚合/ 可/ 帮助/ 用户/ 更加/ 容易/ 地/ 熟悉/ 返回/ 结果/ ./ 图/ 2/ 是/ 按照/ 层次/ 关系/ 进行/ 信息/ 整合/ ,/ 为/ 用户/ 提供/ 更好/ 的/ 体验/ ,/ 是/ 研究者/ 需/ 解决/ 的/ 一个/ 主要/ 问题/ ./ 1.1/ 研究/ 动机/ 例/ 1/ ./ 图/ 1/ 给出/ 了/ 某/ 汽车/ 销售/ 的/ 数据库/ ,/ 图/ 1/ (/ e/ )/ 是/ 该/ 数据库/ 的/ 模式/ ,/ 图/ 1/ (/ a/ )/ ~/ (/ d/ )/ 是/ 数据库/ 中/ 的/ 实例/ 片段/ ./ 图/ 1/ (/ e/ )/ 中/ 的/ 有/ 向/ 箭头/ 表示/ 在/ 模式/ 之间/ 存在/ 有/ 主键/ 指向/ 外键/ 的/ 关系/ ./ 当/ 用户/ 试图/ 检索/ 日系车/ 中/ 配备/ 涡轮/ 增压/ 发动机/ 的/ 产品/ 时/ ,/ 他/ 可能/ 提交/ 的/ 关键字/ 组合/ 为/ “/ 涡轮/ 增压/ ”/ 和/ “/ 日本/ ”/ ./ 表/ 1/ 展示/ 了/ 按/ 现有/ 技术/ 的/ 检索/ 结果/ ./ 具体/ 的/ 每个/ 公司/ 聚合/ 后/ 的/ 结果/ ,/ 圆圈/ 中/ 数字/ 表示/ 表/ 1/ 中/ 元组/ 的/ 序号/ ,/ 每个/ 圆圈/ 代表/ 一条/ 元组/ ./ 同时/ ,/ 在/ 每个/ 公司/ 内部/ ,/ 我们/ 也/ 按照/ 层次/ 关系/ 将/ 乘用车/ (/ 0301/ )/ 和/ 商用车/ (/ 0302/ )/ 区分/ 开来/ ./ 这样/ 的/ 结果/ 由于/ 特征/ 鲜明/ 更/ 易于/ 被/ 用户/ 接受/ ./ 当然/ ,/ 用户/ 也/ 有/ 可能/ 比较关心/ 汽车/ 产品/ 的/ 价位/ ,/ 而/ 对于/ 汽车/ 的/ 品牌/ 没有/ 那么/ 敏感/ ./ 因此/ ,/ 我们/ 的/ 聚合/ 操作/ 也/ 应当/ 能够/ 在/ 价格/ 区间/ 属性/ 上/ 展开/ ./ 本文/ 中/ ,/ 为/ 使/ 用户/ 获得/ 更好/ 的/ 检索/ 体验/ ,/ 我们/ 利用/ 层次/ 关系数据/ 对/ 检索/ 结果/ 进行/ 信息/ 整合/ ,/ 即/ 聚合/ Page3/ 和/ 摘要/ ./ 在/ 考虑/ 这些/ 问题/ 时/ ,/ 我们/ 将/ 遵循/ 以下/ 原则/ :/ (/ 1/ )/ 聚合/ 粒度/ 适当/ ./ 检索/ 结果/ 集/ 的/ 聚合/ 粒度/ 的/ 过/ 小/ 或者/ 过大/ ,/ 都/ 会/ 影响/ 用户/ 分析/ 结果/ ./ (/ 2/ )/ 摘要/ 集/ ./ 为/ 使/ 用户/ 能够/ 在/ 短时间/ 内/ 比较/ 全面/ 地/ 了解/ 聚合/ 结果/ 的/ 特性/ ,/ 我们/ 应有/ 针对性/ 地/ 给出/ 具有/ 代表性/ 的/ k/ 个/ 聚合/ 结果/ 即/ 摘要/ 集/ ./ (/ 3/ )/ 良好/ 的/ 扩展/ 特性/ ./ 目前/ 已有/ 工作/ 致力于/ 关系数据库/ 上/ 关键字/ 检索/ 问题/ ,/ 为/ 与/ 这些/ 工作/ 结合/ ,/ 我们/ 的/ 改进/ 应/ 尽可能少/ 地/ 改变/ 现有/ 系统/ ./ 1.2/ 相关/ 工作/ 近十年/ 来/ ,/ 互联网/ 搜索引擎/ 的/ 巨大成功/ 使/ 关系数据库/ 上/ 的/ 关键字/ 检索/ 问题/ 引起/ 越来越/ 多/ 学者/ 的/ 关注/ ,/ 并/ 已/ 在/ 业界/ 许多/ 成熟/ 的/ 商业/ 数据库系统/ 上/ 有/ 简单/ 实现/ (/ 如/ MicrosoftSQLServer/ 、/ Oracle/ 和/ IBMDB2/ 等/ )/ ./ 以往/ 的/ 研究/ 更多地/ 关注/ 如何/ 得到/ 连接/ 元组/ 来/ 获得/ 同时/ 包含/ 所有/ 关键字/ 的/ 元组/ 连接/ 树/ [/ 1/ ,/ 4/ -/ 5/ ,/ 7/ ,/ 9/ -/ 16/ ]/ ,/ 并/ 基于/ 此/ 提出/ 了/ DBXplorer/ [/ 1/ ]/ 、/ DISCOVER/ [/ 4/ ]/ 、/ BANKS/ [/ 7/ ]/ 、/ SPARK/ [/ 5/ ]/ 、/ SQAK/ [/ 8/ ]/ 等/ 具体/ 的/ 实现/ 方法/ ./ DISCOVER/ 系统/ 是/ 此/ 领域/ 实现/ 较/ 早/ 也/ 较为/ 成功/ 的/ 检索系统/ ,/ 后续/ 在/ 此基础/ 上/ 的/ SPARK/ 、/ SQAK/ 等/ 都/ 是/ 对/ DISCOVER/ 的/ 具有/ 某/ 方面/ 特性/ 的/ 改进/ 工作/ ./ 为了/ 使/ 本文/ 的/ 方法/ 能/ 更好/ 地/ 与/ 其它/ 关键字/ 检索/ 的/ 方法/ 整合/ 在/ 一个/ 系统/ 中/ ,/ 我们/ 选取/ DISCOVER/ 作为/ 扩展/ 的/ 基础/ ./ 该/ 系统/ 利用/ 数据库/ 模式图/ ,/ 在/ 模式图/ 的/ 基础/ 上/ 枚举/ 可能/ 包含/ 查询/ 结果/ 的/ 所有/ 候选/ 网络/ ,/ 然后/ 依据/ 查询/ 表达式/ 生成/ SQL/ 语句/ 投入/ 数据库/ 中/ 进行/ 处理/ 并/ 取回/ 结果/ ./ DISCOVER/ 系统/ 通过/ 枚举/ 所有/ 连接/ 表达式/ 避免/ 了/ 在/ 构造/ 表达式/ 时有/ 可能/ 出现/ 的/ 关键字/ 与/ 多个/ 关系/ 上/ 多个/ 属性/ 值/ 匹配/ 的/ 情况/ 而/ 导致/ 的/ 二义性/ ./ 对于/ 检索/ 结果/ 的/ 进一步/ 处理/ 等/ 工作/ 包括/ 打分/ 方法/ 和/ 结果/ 聚合/ 也/ 都/ 在/ 文献/ [/ 3/ ,/ 17/ -/ 18/ ]/ 中/ 有所/ 研究/ ./ Zhou/ 等/ 人/ 在/ 文献/ [/ 17/ ]/ 中/ 提出/ 关系数据库/ 检索/ 结果/ 的/ 聚合/ 问题/ ,/ 但/ 该/ 研究/ 仅/ 关注/ 于/ 一张/ 表上/ 的/ 聚合/ 操作/ ./ 然而/ ,/ 实际/ 应用/ 中/ ,/ 信息/ 会/ 依据/ 范式/ 被/ 分解成/ 不同/ 的/ 部分/ 存储/ 于/ 多/ 张表中/ ./ 若/ 简单/ 的/ 将/ 该/ 方法/ 应用/ 于/ 多/ 张表/ 的/ 问题/ 中/ 会/ 根据/ 连接/ 关系/ 生成/ 一张/ 非常/ 大/ 的/ 表/ ,/ 这是/ 耗时/ 且/ 不/ 实际/ 的/ ./ 另外/ ,/ 该/ 问题/ 中/ 的/ 属性/ 上/ 并/ 无/ 层次/ 关系/ ./ SQAK/ 的/ 工作/ 也/ 对/ 类似/ 的/ 聚集/ 操作/ 予以/ 支持/ [/ 8/ ]/ ,/ 但/ 需要/ 由/ 用户/ 指定/ 在/ 哪些/ 属性/ 上/ 进行/ 聚集/ 操作/ ,/ 这/ 对于/ 不/ 熟悉/ 数据库/ 模式/ 的/ 用户/ 来讲/ 是/ 十分困难/ 的/ ./ 而且/ ,/ SQAK/ 中/ 的/ 聚集/ 操作/ 是/ 对/ 结果/ 集/ 进行/ 聚集/ 选择/ (/ 即/ 计算/ 元组/ 数目/ 或求/ 最大/ 最小值/ 等/ )/ ,/ 并非/ 在/ 此基础/ 上/ 做/ 信息/ 整合/ ./ Buranasaksee/ 本文/ 的/ 主要/ 贡献/ 如下/ :/ (/ 1/ )/ 在/ 具有/ 层次/ 关系数据/ 的/ 背景/ 下/ 提出/ 检索/ 结果/ 的/ 最小/ 覆盖/ 聚合/ 和/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 概念/ ,/ 以此/ 概念/ 帮助/ 用户/ 更好/ 地/ 了解/ 检索/ 结果/ ./ 我们/ 还/ 在/ 此基础/ 上/ 提出/ 了/ 求解/ 最低/ 层次/ 聚合/ 的/ 基本/ 算法/ 和/ 增强/ 算法/ ./ (/ 2/ )/ 引入/ 针对/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 族/ 的/ 摘要/ 问题/ 并/ 提出/ 了/ 求解/ 的/ 贪心/ 算法/ 及/ 具有/ 剪枝/ 的/ 优化/ 算法/ ./ 等/ 人/ 在/ 文献/ [/ 18/ ]/ 中/ 也/ 提出/ 类似/ 的/ 问题/ ,/ 他们/ 的/ 解决方案/ 是/ 直接/ 使用/ DISCOVER/ [/ 4/ ]/ 系统/ 得到/ 结果/ 以后/ 再/ 做/ 聚合/ ,/ 并/ 没有/ 考虑/ 依据/ 关系/ 上/ 的/ 其它/ 特性/ (/ 例如/ :/ 层次/ 特性/ )/ 对/ 结果/ 进行/ 更好/ 的/ 区分/ ./ 因此/ ,/ 得到/ 的/ 结果/ 有/ 可能/ 使/ 关系/ 不是/ 很/ 紧密/ 的/ 元组/ 聚合/ 在/ 一起/ ;/ 此外/ ,/ 该/ 方案/ 也/ 没有/ 考虑/ 到/ 检索/ 结果/ 集/ 的/ 摘要/ 问题/ ./ Roy/ 等/ 人/ 在/ 文献/ [/ 19/ ]/ 一文/ 中/ 也/ 提到/ 了/ 类似/ 的/ package/ 的/ 摘要/ 问题/ ,/ 并/ 给出/ 了/ 基于/ 贪心/ 和/ 随机/ 算法/ 的/ 两种/ 解决方案/ ./ 这/ 与/ 我们/ 的/ 问题/ 类似/ ,/ 但是/ 由于/ 我们/ 的/ 检索/ 结果/ 集合/ 在/ 共有/ 属性/ 上/ 并/ 无/ 交集/ ,/ 因此/ 我们/ 设计/ 了/ 针对/ 该/ 问题/ 的/ 剪枝/ 策略/ ./ 1.3/ 本文/ 贡献/ 和/ 组织/ (/ 3/ )/ 基于/ DISCOVER/ 提出/ 具有/ 反馈/ 机制/ 的/ 检索系统/ 结构/ ./ 本文/ 第/ 2/ 节/ 介绍/ 系统/ 概要/ 、/ 数据模型/ 和/ 问题/ 定义/ ;/ 第/ 3/ 节/ 给出/ 求解/ MaxLMC/ (/ S/ ,/ Q/ )/ 的/ Groupby/ 方法/ 和/ 按序/ 连接/ 方法/ ;/ 第/ 4/ 节/ 介绍/ 摘要/ 问题/ 并/ 在/ Baseline/ 方法/ 上/ 给出/ 3/ 个/ 剪枝/ 条件/ ;/ 第/ 5/ 节/ 介绍/ 实验/ ;/ 第/ 6/ 节/ 总结/ 展望/ 本文/ 工作/ ./ 2/ 概要/ 与/ 数据模型/ 2.1/ 系统/ 概要/ 展/ ,/ 系统/ 的/ 结构/ 示意/ 如图/ 3/ 所示/ ./ 该/ 系统/ 由/ 6/ 部分/ 组成/ ./ 其/ 设计/ 遵循/ 良好/ 扩展/ 特性/ 的/ 原则/ ,/ 最大/ 限度/ 地/ 减少/ 现有/ 系统结构/ 的/ 更改/ ./ 聚合/ 模块/ (/ Aggregator/ )/ 部分/ 主要/ 负责/ 检索/ 结果/ 的/ 聚合/ ;/ 摘要/ 模块/ (/ Summarization/ )/ 部分/ 则/ 对/ 聚合/ 结果/ 做/ 摘要/ ./ 此处/ 需注意/ 的/ 是/ 返回/ 结果/ 时/ 并非/ 只/ 返回/ 摘要/ ,/ 而是/ 在/ 返回/ 摘要/ 的/ 基础/ 上先/ 使得/ 用户/ 了解/ 检索/ 结果/ 的/ 特性/ ,/ 而后/ 再/ 返回/ 其它/ 所有/ 结果/ ./ 检索/ 时/ ,/ 首先/ 由/ 用户/ 将/ 用于/ 检索/ 的/ 关键字/ 集合/ {/ k1/ ,/ k2/ ,/ …/ ,/ km/ }/ 输入/ 系统/ ./ 依据/ 数据库/ 表项/ 中/ 的/ 倒排/ 索引/ ,/ 对于/ 数据库/ 中/ 的/ 每/ 一张/ 表/ ,/ 我们/ 都/ 可以/ 得到/ 包/ 我们/ 的/ 系统/ 在/ DISCOVER/ 的/ 基础/ 上/ 进行/ 扩/ Page4/ 含/ 关键字/ k1/ ,/ k2/ ,/ …/ ,/ km/ 的/ 元组/ 集合/ Rk1i/ ,/ Rk2i/ ,/ …/ ,/ Rkmi/ ./ 其中/ 元组/ 集合/ Rkji/ 中/ 表示/ 关系/ Ri/ 中/ 属性/ 上/ 包含/ 关键字/ kj/ 的/ 所有/ 元组/ ./ 然后/ ,/ 依据/ 数据库/ 模式图/ ,/ 在/ 这些/ 元组/ 集合/ 的/ 基础/ 上/ 按照/ 完整/ 和/ 无/ 冗余/ 的/ 规则/ 生成/ 连接/ 的/ 候选/ 网络/ (/ candidatenetworks/ )/ ./ 候选/ 网络/ 经由/ SQLGenerator/ 生成/ 对应/ 的/ SQL/ 语句/ 并/ 投入/ 数据库/ 管理系统/ 进行/ 检索/ ./ 我们/ 的/ 系统/ 与/ DISCOVER/ 不同/ 的/ 一点/ 是/ 我们/ 不会/ 一次/ 将/ 所有/ 的/ 候选/ 网络/ 都/ 生成/ 出来/ ,/ 而是/ 按照/ 候选/ 网络/ 的/ 规模/ 大小/ (/ 例如/ ,/ 边/ 的/ 数目/ )/ 分批/ 生成/ ./ 这是/ 由于/ 先生/ 成/ 的/ 结果/ 可以/ 对/ 后续/ 候选/ 网络/ 或/ SQL/ 语句/ 的/ 生成/ 是否/ 执行/ 起/ 反馈/ 和/ 指导作用/ ,/ 过早/ 的/ 投入/ 生成/ 会/ 造成/ 计算资源/ 的/ 浪费/ ./ 对于/ 生成/ 的/ 结果/ 元组/ 分别/ 由/ Aggregator/ 聚合/ 和/ Summarization/ 步骤/ 摘要/ 返还/ 给/ 用户/ ./ 本/ 系统/ 的/ 提出/ 是/ 在/ DISCOVER/ 的/ 工作/ 上/ 进行/ 的/ ,/ 因此/ 与/ DISCOVER/ 系统/ 中/ 相同/ 的/ 部分/ 其/ 模型/ 和/ 定义/ 我们/ 不再/ 赘述/ ,/ 这些/ 部分/ 包括/ Joiningnet/ -/ workoftuples/ 、/ KeywordQuery/ 、/ MTJNT/ 、/ JoiningNetworkofTupleSets/ 、/ CandidateNetwork/ 等/ 定义/ ,/ 请参阅/ 文献/ [/ 4/ ]/ ./ 我们/ 的/ 工作/ 主要/ 在/ 检索/ 结果/ 的/ 聚合/ 和/ 摘要/ 上/ ,/ 因此/ ,/ 下文/ 分别/ 给出/ 两者/ 定义/ ./ 2.2/ 聚合/ 和/ 覆盖/ 定义/ 1/ (/ 划分/ )/ ./ 设/ S/ 是/ 一个/ 元组/ 集合/ ,/ π/ / 2S/ ./ 如果/ 下列/ 条件/ 成立/ 则/ 称/ π/ 为/ S/ 的/ 一个/ 划分/ :/ ①/ S/ =/ ∪/ P/ ∈/ π/ P/ ,/ ②/ 对于/ 任意/ Pi/ ,/ Pj/ ∈/ π/ ,/ 若/ i/ ≠/ j/ ,/ 则/ Pi/ ∩/ Pj/ =/ / ./ 定义/ 2/ (/ 聚合/ 关系/ )/ ./ 设/ α/ =/ {/ S1/ ,/ S2/ ,/ …/ ,/ Sn/ }/ 是/ 一个/ 有限元/ 组集族/ ,/ Si/ (/ 1/ / i/ / n/ )/ 是/ 任意/ 元组/ 集合/ ,/ / 是/ 如下/ 定义/ 的/ 二元关系/ :/ 对于/ α/ 中/ 任意/ 集合/ Si/ 和/ Sj/ ,/ 如果/ 存在/ 一个/ 函数/ F/ :/ π/ →/ Sj/ (/ π/ 是/ Si/ 的/ 划分/ )/ ,/ 则/ 称/ Si/ 和/ Sj/ 满足/ / ,/ 记作/ Si/ / Sj/ ,/ F/ 称为/ 聚合/ 函数/ ./ 如果/ 满足/ 下列/ 条件/ 则/ 称为/ α/ 上/ 的/ 聚合/ 关系/ :/ 对于/ α/ 中/ 任意/ 集合/ Si/ 和/ Sj/ ,/ 如果/ Si/ / Sj/ ,/ Sj/ / Si/ ,/ 则/ Si/ =/ Sj/ ./ 引理/ 1/ ./ 集族/ α/ 上/ 的/ 聚合/ 关系/ 是/ 一个/ 偏序/ ./ 证明/ ./ 从略/ ./ 例如/ ,/ α/ =/ {/ S1/ ,/ S2/ }/ ,/ 其中/ S1/ 为表/ 1/ 中/ 7/ 条/ 元组/ 的/ 集合/ ,/ S2/ 为/ 图/ 1/ 中/ AUTO/ 表/ 和/ COMPANY/ 表做/ 自然/ 连接/ 后/ 的/ 所有/ 元组/ 集合/ ,/ 我们/ 知道/ ,/ S1/ 中/ 的/ 元组/ 都/ 能够/ 在/ S2/ 中/ 找到/ 与/ 之/ 对应/ 的/ (/ AutoKey/ 相同/ )/ 但是/ 属性/ 比/ 它/ 本身/ 多/ 的/ 元组/ ./ 现在/ 将/ S1/ 中/ 的/ 元组/ 按照/ 公司/ (/ CompanyKey/ )/ 划分/ ,/ 即/ 所有/ 相同/ 的/ 公司/ 共同/ 属于/ 某一/ 划分/ 单元/ (/ 注意/ :/ 不同/ 公司/ 之间/ 的/ 元组/ 也/ 可能/ 属于/ 相同/ 划分/ 单元/ )/ ,/ 记此/ 划分/ 为/ π/ ./ 定义/ 其上/ 的/ 聚合/ 函数/ F/ ,/ 我们/ 令/ F/ :/ π/ →/ S2/ 当且/ 仅/ 当该/ 划分/ 下/ 所有/ 元组/ 同/ 属于/ 一个/ 国家/ (/ 即/ ,/ 在/ S2/ 中/ NationKey/ 是/ 一致/ 的/ )/ ./ 此时/ F/ 是/ “/ 公司/ ”/ 关于/ “/ 国家/ ”/ 的/ 聚合/ 函数/ ,/ 我们/ 称/ S1/ 的/ 划分/ π/ 满足/ 国家/ 上/ 的/ 聚合/ 关系/ ./ 显然/ ,/ 满足/ 这样/ 聚合/ 关系/ 的/ 集合/ 很多/ ./ 例如/ ,/ 从/ S1/ 中/ 去掉/ n/ (/ n/ </ |/ S1/ |/ )/ 条/ 元组/ 得到/ 的/ 新/ 的/ 集合/ 都/ 满足/ π/ 上/ 关于/ 国家/ 的/ 聚合/ 关系/ ,/ 因此/ ,/ 我们/ 关心/ 的/ 是/ 如何/ 得到/ 完备/ 的/ 这样/ 的/ 集合/ ,/ 后/ 文中/ 借助于/ Groupby/ 的/ 方法/ 实现/ 这/ 一点/ ./ 另一方面/ ,/ 由于/ 可以/ 在/ 不同/ 的/ 属性/ 上/ 构造/ 聚合/ 关系/ ,/ 因此/ 在/ 构造/ 过程/ 中/ 应当/ 注意/ 全面性/ ./ 一般/ 地/ ,/ 我们/ 将/ 构造/ 聚合/ 关系/ 的/ 过程/ 称为/ 聚合/ 操作/ ./ 定义/ 3/ (/ 划分/ 的/ 覆盖/ )/ ./ 设/ S/ 是/ 一个/ 元组/ 集合/ ,/ π/ =/ {/ S1/ ,/ S2/ ,/ …/ ,/ Sm/ }/ ,/ π/ / 2S/ 是/ S/ 上/ 的/ 一个/ 划分/ ./ D/ 是/ S/ 上/ 的/ 字典/ ,/ Q/ / D/ 是/ S/ 中/ 出现/ 的/ 某些/ 词/ ,/ 谓词/ contain/ 表示/ 集合/ 中/ 包含/ 词项/ ./ 则/ Cov/ (/ π/ ,/ Q/ )/ =/ {/ Si/ |/ SicontainQ/ }/ 是/ 划分/ π/ 关于/ Q/ 的/ 覆盖/ ./ 定义/ 4/ (/ 最小/ 覆盖/ 聚合/ ,/ MC/ )/ ./ 设/ α/ =/ {/ S1/ ,/ S2/ ,/ …/ ,/ Sn/ }/ 是/ 一个/ 有限元/ 组集族/ ./ Q/ / D/ 是/ α/ 中/ 出现/ 的/ 某些/ 词/ ,/ 给定/ Si/ 和/ π/ ,/ π/ / 2Si/ 是/ Si/ 上/ 的/ 一个/ 划分/ ,/ 若/ / Sj/ ∈/ α/ ,/ Sj/ / Si/ ,/ 不/ 存在/ 划分/ π/ / 2Sj/ ,/ 使得/ Sj/ 上/ 有/ 划分/ 的/ 覆盖/ Cov/ (/ π/ ,/ Q/ )/ ,/ 则/ Si/ 是/ 关于/ Q/ 的/ 最小/ 覆盖/ 聚合/ (/ MC/ )/ ./ 定义/ 5/ (/ 层次/ 关系/ )/ ./ 设/ H/ 是/ 一个/ 有限/ 集合/ ,/ / 是/ 自反/ 的/ 、/ 反对/ 称/ 的/ 和/ 传递/ 的/ 偏序/ 关系/ ,/ 且/ :/ 对于/ H/ 中/ 的/ 任意/ 元素/ hi/ ,/ 若/ hi/ 非/ 极小/ 元/ ,/ 如果/ 存在/ 一个/ 函数/ F/ :/ hi/ →/ H/ ,/ H/ / H/ ,/ 且/ F/ 值域/ 中/ 的/ 各个/ H/ / H/ 互不/ 相交/ ,/ 则/ 称/ F/ 为/ 分层/ 函数/ ,/ 称/ / 是/ H/ 上/ 的/ 层次/ 关系/ ./ 例如/ ,/ CLASS/ 表中/ 的/ CLASSKEY/ 集合/ 上/ 的/ 包含/ 关系/ 就是/ 一个/ 层次/ 关系/ ./ 层次/ 关系/ 是/ 针对/ 集合/ 中/ Page5/ 的/ 元素/ 而/ 定义/ 的/ ,/ 而/ 聚合/ 关系/ 是/ 针对/ 集族/ 中/ 的/ 集合/ 而/ 定义/ 的/ ./ 一般/ 地/ ,/ 若/ hi/ / hj/ ,/ 我们/ 称/ hj/ 是/ hi/ 的/ 上层/ ./ 为了/ 说明/ 最低/ 上层/ 关系/ ,/ 我们/ 定义/ 运算/ MH/ ,/ 该/ 运算/ 返回/ 层次/ 集合/ 上/ 子集/ H/ / H/ 中/ 最小/ 的/ 上层/ ,/ 即/ H/ 的/ 上/ 确界/ ./ 形式化/ 表述/ 为/ :/ MH/ (/ H/ )/ =/ {/ hi/ |/ 存在/ hk/ ∈/ H/ ,/ / hj/ ∈/ H/ ,/ j/ ≠/ k/ ,/ 有/ hj/ / hk/ ,/ 并且/ 对于/ 所有/ 这样/ 的/ hk/ ,/ hi/ 是/ 其中/ 的/ 极小/ 元/ 或者/ H/ 中/ 的/ 最大/ 元/ }/ ./ 由于/ H/ 中/ 极大元/ 不/ 唯一/ ,/ 实际操作/ 中/ ,/ 我们/ 引入/ τ/ ,/ 并令/ / h/ ∈/ H/ ,/ h/ 是/ 极大元/ ,/ 有/ h/ / τ/ ./ 引理/ 2/ ./ 若/ MH/ (/ H/ )/ 存在/ ,/ 则/ 必/ 唯一/ ./ 定义/ 6/ (/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ ,/ LMC/ )/ ./ 设/ S/ 为/ 关于/ Q/ 的/ MC/ ,/ MH/ (/ S/ )/ 表示/ S/ 中/ 层次/ 关系/ 属性/ 上/ 的/ 最低/ 上层/ ,/ 若/ 对于/ 任意/ 的/ S2/ / S/ ,/ S2/ 中/ 包含/ 所有/ Q/ ,/ 不/ 存在/ S1/ / S/ ,/ 且/ / wi/ ∈/ Q/ ,/ S1containQ/ ,/ 使得/ MH/ (/ S1/ )/ / MH/ (/ S2/ )/ ,/ 则/ 称/ S2/ 为/ 关于/ Q/ 的/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ (/ LMC/ )/ ./ 若/ 同时/ 也/ 不/ 存在/ s/ ∈/ S/ ,/ 且/ S2/ ∪/ {/ s/ }/ 也/ 是/ LMC/ ,/ 则/ 称/ S2/ 为/ MaxLMC/ ,/ 此时/ S2/ 中所含/ 的/ 元组/ 数目/ 在/ 满足/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 的/ 条件/ 下/ 达到/ 最多/ ./ 显然/ ,/ 关于/ Q/ 的/ 最大/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ (/ MaxLMC/ )/ 是/ 对/ 最小/ 覆盖/ 聚合/ 的/ 一个/ 细分/ ./ 例如/ ,/ 图/ 2/ 中/ {/ 1/ ,/ 4/ ,/ 5/ ,/ 7/ }/ 是/ 在/ “/ 一汽/ 丰田/ ”/ 公司/ 上/ 的/ MC/ ,/ {/ 1/ ,/ 4/ }/ 和/ {/ 7/ }/ 是/ 基于/ 层次/ 关系/ 的/ LMC/ ,/ 而/ {/ 1/ ,/ 4/ ,/ 5/ }/ 则/ 是/ 一个/ MaxLMC/ ,/ 可以/ 看出/ ,/ 所有/ MaxLMC/ 是/ 对/ MC/ 的/ 细分/ ./ 不同/ 层次/ 关系/ 的/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 更多地/ 反映/ 了/ 检索/ 结果/ 在/ 认知/ 上/ 的/ 粒度/ 大小/ ,/ 而/ 聚合/ 则/ 反映/ 了/ 检索/ 结果/ 在/ 某/ 一/ 自身/ 属性/ 上/ 的/ 同质/ ./ 问题/ 1/ (/ MaxLMC/ (/ S/ ,/ Q/ )/ )/ ./ 给定/ 关系数据库/ 模式/ Sc/ 及其/ 实例/ DSc/ ,/ Q/ 是/ 用户/ 提交/ 的/ 检索/ ,/ S/ 是/ 对应/ 于/ 检索/ 结果/ 的/ 元组/ 集合/ ./ 求解/ :/ MaxLMC/ (/ S/ ,/ Q/ )/ ,/ S/ 关于/ Q/ 的/ 最大/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 族/ ./ 2.3/ 摘要/ 尽管/ 我们/ 致力于/ 寻找/ MaxLMC/ ,/ 而/ 这/ 已经/ 将/ 可能/ 的/ 问题/ 结果/ LMC/ 大大减少/ ,/ 但是/ 实际/ 情况/ 中/ MaxLMC/ (/ S/ ,/ Q/ )/ 的/ 数目/ 仍然/ 有/ 很多/ ./ 可以/ 想象/ ,/ 日系车/ 中/ 含有/ 涡轮/ 增压/ 的/ 产品/ 数目/ 本身/ 就/ 有/ 许多/ ,/ 为/ 使/ 用户/ 了解/ 检索/ 结果/ 的/ 特性/ ,/ 我们/ 可以/ 根据/ 公司/ 属性/ 聚合/ 结果/ ,/ 也/ 可以/ 根据/ 价位/ 属性/ 聚合/ 结果/ ,/ 这/ 中间/ 重要/ 的/ 一点/ 是/ 许多/ 汽车/ 会/ 在/ 不同/ 的/ 聚合/ 集中/ 有/ 重叠/ ./ 因此/ ,/ 在/ 计算/ MaxLMC/ (/ S/ ,/ Q/ )/ 的/ 基础/ 上/ ,/ 我们/ 应当/ 进一步/ 对/ 结果/ 做/ 摘要/ ,/ 即/ 从中/ 选出/ k/ 个/ 具有/ 代表性/ 的/ 最小/ 覆盖/ 聚合/ (/ 一般/ 为/ 5/ ~/ 10/ 个/ )/ ,/ 这/ 使得/ 用户/ 在/ 较/ 短时间/ 内能/ 较/ 全面/ 地/ 了解/ 检索/ 结果/ 的/ 特性/ ./ 问题/ 2/ (/ 摘要/ )/ ./ 给定/ MaxLMC/ (/ S/ ,/ Q/ )/ 和/ k/ ,/ 如何/ 计算/ MaxLMC/ (/ S/ ,/ Q/ )/ 的/ 具有/ 代表性/ 的/ k/ 个/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ k/ -/ MaxLMC/ (/ S/ ,/ Q/ )/ ./ 换言之/ ,/ 这/ k/ 个/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 可以/ 最大/ 限度/ 地/ 表示/ 之前/ 求出/ 的/ MaxLMC/ (/ S/ ,/ Q/ )/ ./ 文中/ ,/ 我们/ 称/ k/ -/ MaxLMC/ (/ S/ ,/ Q/ )/ 为/ 摘要/ 集/ ./ 摘要/ 的/ 目的/ 是/ 展示/ 给/ 用户/ 一个/ 简短/ 的/ 具有/ k/ 个/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 的/ 结果/ ,/ 同时/ ,/ 在/ 这/ k/ 个/ 结果/ 中/ 可以/ 最大/ 限度/ 地/ 将/ 检索/ 结果/ 元组/ 的/ 集合/ 涵盖/ 进来/ ./ 3/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 算法/ 本/ 节/ 讨论/ 如何/ 在/ 检索/ 结果/ 中/ 得到/ 最低/ 层次/ 的/ 最小/ 覆盖/ 聚合/ ./ 为了/ 将/ SQL/ 语句/ 的/ 这/ 一/ 特性/ 应用/ 进来/ ,/ 我们/ 可以/ 在/ 系统/ 中/ SQLGenerator/ 生成/ 语句/ 时/ 添加/ 相应/ 的/ Groupby/ 语句/ ./ 为此/ ,/ 我们/ 先/ 定义/ 属性/ 划分/ ./ 定义/ 7/ (/ 属性/ 划分/ )/ ./ 设/ A/ 是/ 给定/ 关系数据库/ 模式/ Sc/ 上/ 的/ 属性/ 集合/ ./ A/ =/ AC/ ∪/ AP/ ∪/ AU/ 是/ 关于/ A/ 的/ 一个/ 划分/ ,/ 其中/ AC/ 表示/ 分类/ 属性/ ,/ AP/ 表示/ 具有/ 偏序/ 关系/ 的/ 聚合/ 属性/ ,/ AU/ 是/ 其/ 补集/ ./ AC/ 和/ AP/ 统称/ 为/ 聚合/ 属性/ ./ 例如/ ,/ AUTO/ 表中/ PriceInterval/ 是/ 分类/ 属性/ ,/ CompanyKey/ 和/ COMPANY/ 表中/ 的/ NationKey/ 等/ 外键/ 是/ 具有/ 偏序/ 关系/ 的/ 聚合/ 属性/ ,/ 这/ 是因为/ 若/ 某/ 汽车/ 属于/ 某/ 公司/ ,/ 其必/ 属于/ 相应/ 的/ 国家/ ,/ 为此/ ,/ 在/ 聚合/ 时应/ 先/ 选择/ 偏序/ 次序/ 较为/ 靠/ 前/ 的/ 属性/ ./ 我们/ 可以/ 在/ 这/ 两类/ 属性/ 上/ 做/ 聚合/ 操作/ ./ 而/ Feature/ 和/ COMPANY/ 表中/ 的/ Establish/ 属性/ 则/ 不是/ 分类/ 属性/ ./ 在/ 生成/ SQL/ 语句/ 时/ ,/ 我们/ 应/ 选择/ 所有/ 可能/ 用于/ 聚合/ 操作/ 的/ 属性/ 并/ 在/ 其/ 上/ 做/ Groupby/ 操作/ ./ 但是/ 这样/ 会/ 增加/ 系统生成/ 的/ SQL/ 语句/ 数目/ 从而/ 增大/ 开销/ ./ 因此/ ,/ 我们/ 仅/ 在/ 偏序/ 关系/ 的/ 聚合/ 属性/ 上/ 做/ Groupby/ 操作/ ,/ 而/ 分类/ 属性/ 上/ 的/ 聚合/ 操作/ 我们/ 将/ 在/ 具体/ 的/ SQL/ 语句/ 得到/ 结果/ 后/ 进行/ ,/ 此/ 操作/ 只/ 需要/ 简单/ 地/ 遍历/ 一遍/ 结果/ 元组/ ,/ 并/ 将/ 不同/ 的/ 类别/ 元组/ 置于/ 不同/ 的/ 最小/ 覆盖/ 中/ 即可/ ./ 若/ SQL/ 语句/ 中/ 涉及/ 到/ 两个/ 或/ 以上/ 的/ 聚合/ 属性/ AP1/ ,/ AP2/ ,/ …/ ,/ APk/ ,/ 则/ 根据/ AP/ 的/ 偏序/ 关系/ 选择/ 划分/ 更为/ 细致/ 的/ 属性/ APi/ ,/ 使得/ / APi/ ,/ j/ ≠/ i/ ,/ 有/ APi/ / AP/ 里/ 使用/ / 来/ 表示/ APi/ 上/ 聚合/ 的/ 结果/ 之间/ 聚合/ 关系/ 的/ 比较/ ,/ 下同/ )/ ./ 当然/ ,/ 有/ 可能/ 在/ APi/ 上/ 并/ 无/ 聚合/ 结果/ ,/ 此时/ 根据/ Feedback/ 机制/ 使/ SQLGenerator/ 重新/ 生成/ SQL/ 语句/ ,/ 并/ 选择/ 仅/ 在/ APi/ 之上/ (/ 即/ APi/ +/ 1/ )/ 的/ 属性/ Page6/ 聚合/ ./ 3.1/ 基于/ Groupby/ 的/ 方法/ 为/ 求得/ MaxLMC/ (/ S/ ,/ Q/ )/ ,/ 根据/ 定义/ ,/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 是/ 对/ 最小/ 覆盖/ 聚合/ 的/ 一个/ 细分/ ,/ 因此/ 我们/ 需要/ 首先/ 计算/ 出/ 最小/ 覆盖/ 聚合/ ./ 定理/ 1/ ./ 基于/ SQLGenerator/ 生成/ 的/ 带有/ Groupby/ 操作/ 的/ SQL/ 语句/ 的/ 执行/ 结果/ 为/ 最小/ 覆盖/ 聚合/ MC/ ./ 这/ 与/ 选择/ 的/ Feedback/ 机制/ 有关/ ,/ 证明/ 从略/ ./ 我们/ 关心/ 的/ 是/ LMC/ ./ 假设/ 用户/ 在/ 检索/ 时/ 需要/ 含有/ 特性/ “/ a/ ”/ 和/ “/ b/ ”/ 的/ 产品/ ,/ 根据/ 候选/ 网络/ 生成/ SQL/ 语句/ 得到/ 的/ 可能/ 连接/ 结果/ 如表/ 2/ ,/ 这些/ 结果/ 都/ 是/ 在/ 公司/ C/ 上/ Groupby/ 得到/ 的/ ./ 表/ 2/ 一部分/ 可能/ 的/ 连接/ 结果/ (/ 中间/ 一/ 列为/ 公司/ )/ AutoKey/ 层次/ 特征/ AutoKey/ 层次/ 特征/ A0010301aCA0020301bA0010301aCA0030302bA0040302aCA0020301bA0040302aCA0030302bA0050301aCA0020301b/ 易知/ ,/ 表中/ 的/ 5/ 条/ 结果/ 已经/ 是/ 最小/ 覆盖/ 聚合/ ,/ 但是/ 若/ 考虑/ 到/ 层次/ 关系/ ,/ 则/ 只有/ 第/ 1/ ,/ 4/ ,/ 5/ 条/ 元组/ 满足/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ ./ 这/ 是因为/ 第/ 1/ 条/ 元组/ 的/ 最低/ 上层/ 为/ 0301/ ,/ 而/ 第/ 2/ 条/ 元组/ 的/ 最低/ 上层/ 为/ 03/ ,/ 因此/ 我们/ 保留/ 第/ 1/ 条/ 元组/ ./ 同理/ ,/ 第/ 4/ ,/ 5/ 条/ 元组/ 得到/ 保留/ ./ 算法/ 1/ 给出/ 求解/ 最大/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 的/ Nave/ 方法/ ,/ 其中/ MH/ (/ ti/ )/ 表示/ ti/ 元组/ 上/ 层次/ 关系/ 的/ 最小/ 上层/ ./ 算法/ 1/ ./ NaveMaxLMC/ (/ S/ ,/ Q/ )/ ./ 输入/ :/ 最小/ 覆盖/ 聚合/ S/ 输出/ :/ MaxLMC/ (/ S/ ,/ Q/ )/ ,/ 结果/ 用/ R/ 表示/ ,/ R/ =/ {/ RS1/ ,/ 1/ ./ R/ =/ empty2/ ./ foreachtupletiinS3/ ./ {/ Lowest/ =/ true4/ ./ foreachtupletjwiththesamevalueonjoining5/ ./ {/ if/ (/ MH/ (/ tj/ )/ / MH/ (/ ti/ )/ )/ 6/ ./ Lowest/ =/ false7/ ./ }/ 8/ ./ if/ (/ Lowest/ =/ true/ )/ 9/ ./ RMH/ (/ ti/ )/ =/ RMH/ (/ ti/ )/ ∪/ {/ ti/ }/ 10/ ./ }/ 11/ ./ returnR/ 算法/ 1/ 求解/ 最大/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ ,/ 它/ 的/ 输出/ 为/ MaxLMC/ (/ S/ ,/ Q/ )/ ,/ 每/ 一个/ MaxLMC/ 中/ 包含/ 了/ 所有/ 相同/ 最低/ 上层/ 的/ 聚合/ 结果/ ./ 算法/ 的/ 流程/ 是/ :/ 对于/ 每/ 一条/ 元组/ 都/ 遍历/ 与/ 之/ 连接/ 属性/ 上值/ 相同/ 的/ 其它/ 元组/ ,/ 若/ 其它/ 元组/ 的/ 最低/ 上层/ 层次/ 都/ 不/ 低于/ 该/ 元组/ ,/ 则/ 将/ 该/ 元组/ 加入/ 其/ 自身/ 的/ 最低/ 上层/ 层次/ 的/ MaxLMC/ ./ 上例/ 中/ 的/ 结果/ 应为/ (/ 以/ 序号/ 表示/ 元组/ )/ :/ {/ 1/ ,/ 5/ }/ ,/ {/ 4/ }/ ./ 假定/ 在/ 最小/ 覆盖/ 聚合/ S/ 上/ 共有/ n/ 条/ 元组/ ,/ 连接/ 属性/ 共有/ d/ 种同/ 的/ 值/ ,/ 因此/ 平均/ 在/ 每个/ 连接/ 属性/ 的/ 值/ 上/ 有/ n/ 度为/ n/ (/ )/ dO/ (/ n2/ // d/ )/ ./ 3.2/ 按序/ 连接/ 方法/ 注意/ 到/ ,/ 上例/ 中/ 连接/ 的/ 结果/ 2/ 、/ 3/ 并未/ 被/ 选用/ ./ 因此/ 若/ 可以/ 设计/ 一种/ 连接/ 操作/ 时/ 避免/ 生成/ 2/ 、/ 3/ 元组/ 的/ 方法/ ,/ 则/ 将/ 大大减少/ 时间/ 开销/ ./ 由于/ 结果/ 是/ 由/ SQL/ 语句/ 生成/ 的/ ,/ 因此/ 有/ 两种/ 方案/ 可/ 供/ 实现/ 改进/ 算法/ :/ (/ 1/ )/ 完全/ 弃用/ 数据库/ 管理系统/ 提供/ 的/ SQL/ 检索/ 方式/ ,/ 根据/ 层次/ 关系/ 实现/ 系列/ 操作/ ;/ (/ 2/ )/ 在/ SQL/ 语句/ 在/ 做/ 最后/ 一步/ 连接/ 操作前/ ,/ 根据/ 层次/ 上/ 的/ 最低/ 上层/ 选择/ 在/ 做/ 连接/ 时/ 剔除/ 掉/ 部分/ 结果/ ./ 本文/ 中/ ,/ 我们/ 选取/ 后者/ ./ 在/ SQL/ 语句/ 最后/ 做/ 连接/ 之前/ ,/ 有/ 两个/ 待/ 连接/ 的/ 元组/ 集/ ,/ 称之为/ T1/ 和/ T2/ ,/ 其中/ T1/ 和/ T2/ 中/ 的/ 每条/ 元组/ 分别/ 包含/ Q/ 的/ 一个/ 子集/ Q/ ,/ 并且/ 在/ 连接/ 时/ 对于/ ti/ ∈/ T1/ ,/ tj/ ∈/ T2/ ,/ 则/ ti/ / / tj/ 的/ 结果/ 必须/ 含有/ 所有/ 的/ Q/ ,/ 记为/ Qti/ ∪/ Qtj/ =/ Q/ ./ 并且/ ,/ T1/ 和/ T2/ 中/ 的/ 元组/ 都/ 具有/ 层次/ 关系/ 的/ 属性/ ,/ 若/ 某/ Ti/ 中/ 没有/ 层次/ 属性/ ,/ 则/ 可/ 认为/ Ti/ 中/ 的/ 层次/ 为/ H/ 上/ 的/ 极小/ 元/ ,/ 使得/ MH/ (/ tj/ )/ =/ MH/ (/ ti/ / / tj/ )/ ,/ 这样/ 不/ 影响/ 后面/ 的/ 计算/ ./ 我们/ 的/ 改进/ 算法/ 是/ 基于/ 层次/ 关系/ 的/ 传递/ 性质/ ,/ 即/ 若/ 某/ ti/ ∈/ T1/ ,/ 它/ 的/ 层次/ 为/ MH/ (/ ti/ )/ ,/ 则/ ti/ 的/ 连接/ 结果/ (/ 用/ Join/ (/ ti/ )/ 表示/ )/ 的/ 最低/ 上层/ MH/ (/ Join/ (/ ti/ )/ )/ 满足/ :/ MH/ (/ ti/ )/ / MH/ (/ Join/ (/ ti/ )/ )/ ./ 算法/ 开始/ 于/ 两个/ 先/ 按照/ 连接/ 属性/ 排序/ 后/ 按照/ 层次/ 偏序/ 排序/ (/ 同一/ 层次/ 的/ 排序/ 按/ 字典/ 序/ )/ 的/ 元组/ 集/ T1/ ,/ T2/ (/ 这/ 可以/ 在/ SQL/ 中/ 使用/ Groupby/ 和/ asc/ 实现/ )/ ./ 选择/ 层次/ 种类/ 较/ 多/ 的/ 元组/ 集/ (/ 假设/ 为/ T1/ ,/ 没有/ 层次/ 属性/ 的/ 待/ 连接/ 元组/ 集/ 层次/ 种类/ 为/ 0/ )/ ,/ 在/ 顺序/ 遍历/ T1/ 的/ 过程/ 中/ ,/ 对于/ T1/ 中/ 的/ 每个/ 元组/ ti/ ,/ 选择/ 连接/ 属性/ 上值/ 相同/ 的/ tj/ ∈/ T2/ ,/ 设/ 为/ {/ tj0/ ,/ tj1/ ,/ …/ ,/ tjm/ }/ ,/ 顺序/ 遍历/ 这样/ 的/ tj/ 即可/ ,/ 且/ 从/ tj0/ 开始/ ,/ MH/ (/ ti/ / / tj/ )/ 层次/ 较/ 低/ 的/ 连接/ 元组/ 会/ 按序/ 聚合/ 在/ Page7/ 一起/ ,/ 根据/ 最低/ 上层/ 条件/ ,/ 若/ 对于/ tjk/ ,/ MH/ (/ ti/ / / tj0/ )/ / MH/ (/ ti/ / / tjk/ )/ ,/ 则/ tjk/ 以后/ 的/ 元组/ 都/ 不必/ 考虑/ ,/ 因而/ ti/ / / tjk/ ,/ ti/ / / tjk/ +/ 1/ ,/ …/ ,/ ti/ / / tjm/ 这些/ 连接/ 操作/ 不必要/ 执行/ ./ 算法/ 2/ ./ MaxLMC/ (/ S/ ,/ Q/ )/ ./ 输入/ :/ 待/ 连接/ 元组/ 集/ T1/ ,/ T2/ 输出/ :/ MaxLMC/ (/ S/ ,/ Q/ )/ ,/ 结果/ 用/ R/ 表示/ ,/ R/ =/ {/ RS1/ ,/ RS2/ ,/ …/ ,/ 1/ ./ R/ =/ empty2/ ./ foreachtupletiinT13/ ./ {/ foreachtupletjinT2withthesamevalueon4/ ./ {/ if/ (/ MH/ (/ ti/ / / tj0/ )/ / MH/ (/ ti/ / / tjk/ )/ )/ 5/ ./ break6/ ./ else7/ ./ t/ =/ Jion/ (/ ti/ ,/ tj/ )/ 8/ ./ RMH/ (/ ti/ / / tj09/ ./ }/ 10/ ./ }/ 11/ ./ returnR/ 定理/ 2/ ./ 算法/ 2/ 产生/ 与/ 算法/ 1/ 相同/ 的/ 结果/ ./ 需要/ 说明/ 的/ 是/ :/ 算法/ 2/ 当/ 其中/ 有/ 一/ Ti/ 上/ 不/ 具有/ 层次/ 属性/ 时/ 退化/ 为/ 算法/ 1/ ./ 此时/ 对于/ Tj/ 中/ 的/ 任一/ 元组/ ,/ 都/ 需要/ 在/ Ti/ 上/ 连接/ ,/ 因此/ 不/ 节省/ 连接/ 操作/ ./ 此外/ ,/ 对于/ 没有/ 做/ 连接/ 的/ 元组/ ,/ 在/ 返回/ 结果/ 时/ 我们/ 将/ 直接/ 返回/ ,/ 这/ 保证/ 了/ 返回/ 所有/ 结果/ 按/ 算法/ 2/ 生成/ 的/ 对于/ 某一/ 连接/ 属性/ 的/ 连接/ 元组/ 聚合/ 得到/ 的/ 一系列/ MaxLMC/ ,/ 我们/ 按照/ 聚合/ 元组/ 数目/ 的/ 降序/ 在/ 其/ 上/ 维护/ 一个/ 优先/ 队列/ ,/ 使得/ MaxLMC/ (/ S/ ,/ Q/ )/ 在/ 每/ 一/ 属性/ 上/ 都/ 是/ 有序/ 的/ ,/ 这样/ 的/ 顺序/ 便于/ 用户/ 查看/ ,/ 同时/ 也/ 为/ 我们/ 的/ 摘要/ 算法/ 做好/ 数据/ 准备/ ./ 4/ 摘要/ 算法/ 直接/ 将/ 所有/ 的/ MaxLMC/ (/ S/ ,/ Q/ )/ 返还/ 给/ 用户/ (/ 如/ 2.4/ 节/ 所述/ )/ 具有/ 两个/ 缺点/ ./ 一是/ MaxLMC/ (/ S/ ,/ Q/ )/ 的/ 数目/ 非常/ 多/ ;/ 二是/ 各/ MaxLMC/ 之间/ 有/ 很大/ 比例/ 上/ 的/ 重叠/ ./ 我们/ 做/ 摘要/ 的/ 目的/ 是/ 找到/ k/ 个/ 具有/ 代表性/ 的/ MaxLMC/ ,/ 给/ 用户/ 尽可能/ 全面/ 地/ 提供/ 检索/ 结果/ 并/ 使/ 其/ 可以/ 进一步/ 掌握/ 检索/ 结果/ ./ 生成/ 摘要/ 的/ 常用/ 方法/ 是/ 聚类/ 算法/ :/ 我们/ 可以/ 在/ MaxLMC/ 上/ 定义/ 两/ 两/ 之间/ 的/ 距离/ 函数/ ,/ 然后/ 应用/ 各类/ 聚类/ 算法/ (/ 例如/ ,/ k/ -/ means/ )/ ./ 在/ 将/ MaxLMC/ (/ S/ ,/ Q/ )/ 分成/ k/ 类后/ ,/ 从/ 每/ 一类/ 中/ 随机/ 选取/ 一个/ 聚合/ 集/ 即可/ ./ 但是/ ,/ 在/ 当前/ 的/ 问题/ 中/ 定义/ 距离/ 函数/ 是/ 十分困难/ 的/ ./ 本文/ 中/ ,/ 我们/ 根据/ 最大/ 覆盖/ 原理/ 设计/ 了/ 一种/ 不同/ 的/ 方法/ 用以/ 求解/ 该/ 问题/ ,/ 目的/ 是/ 找到/ 尽可能/ 完整/ 的/ 覆盖/ 检索/ 结果/ 集/ 的/ k/ 个/ 代表/ MaxLMC/ ./ 直观/ 地看/ ,/ 这/ k/ 个/ MaxLMC/ 的/ 并/ 集中/ 所含/ 的/ 元组/ 数目/ 最/ 多/ ,/ 这/ 能够/ 更好/ 地/ 展示/ 给/ 用户/ 检索/ 结果/ 的/ 共有/ 特性/ ./ 而且/ ,/ 从/ LMC/ 的/ 角度/ 来看/ ,/ 用户/ 可以/ 从/ 摘要/ 集中/ 构造/ 出/ 更/ 多/ 的/ LMC/ ./ 例如/ ,/ 在/ 图/ 4/ 中/ ,/ 实线/ 和/ 虚/ 线框/ 分别/ 代表/ 不同/ 的/ 分类/ 属性/ 上/ 的/ 聚合/ 结果/ ./ 若/ k/ =/ 2/ ,/ 我们/ 的/ 摘要/ 集/ 应为/ S1/ ,/ S4/ ,/ 因为/ S1/ ∪/ S4/ 中所/ 涵盖/ 的/ 元素/ 数目/ 最多/ ./ 我们/ 的/ 问题/ 是/ 给定/ MaxLMC/ (/ S/ ,/ Q/ )/ ,/ 选择/ 其中/ 的/ k/ 个/ 集合/ 使得/ 这/ k/ 个/ 集合/ 包含/ 的/ 元素/ 最多/ ./ 最/ 简单/ 的/ 解法/ 是/ :/ 对/ 所有/ 可能/ 的/ k/ 个/ 集合/ 的/ 并/ 集/ 分别/ 计算/ 元素/ 个数/ ,/ 并取/ 使/ 并/ 集中/ 元素/ 个/ 数最多/ 的/ k/ 个/ 集合/ ./ 这/ 具有/ 指数/ 的/ 时间/ 复杂度/ ./ 为/ 解决/ 这一/ 问题/ ,/ 我们/ 给出/ 一个/ 基本/ 的/ 贪心/ 算法/ ./ 4.1/ 基本/ (/ Baseline/ )/ 方法/ 算法/ 3/ 伪码/ 如下/ ,/ 基本/ 思想/ 是/ :/ 从/ 最大/ 的/ 集合/ (/ 元素/ 数目/ 最/ 多/ )/ 开始/ ,/ 记为/ I/ ,/ 在/ 每/ 一轮/ 迭代/ 中/ 都/ 选择/ Si/ 使/ I/ ∪/ Si/ 最大/ ./ 算法/ 在/ k/ 轮/ 迭代/ 后/ 停止/ ./ 算法/ 3/ ./ GreedySummary/ ./ 输入/ :/ MaxLMC/ (/ S/ ,/ Q/ )/ =/ {/ S1/ ,/ S2/ ,/ …/ ,/ Sn/ }/ 输出/ :/ 覆盖/ I1/ ./ I/ =/ empty2/ ./ LetSmaxbethelargestsetinMaxLMC/ (/ S/ ,/ Q/ )/ 3/ ./ removeSmaxfromMaxLMC/ (/ S/ ,/ Q/ )/ 4/ ./ I/ =/ I/ ∪/ Smax5/ ./ iteration/ =/ 06/ ./ Whileiteration/ </ kdo7/ ./ Smax/ =/ MaxS/ ∈/ MaxLMC/ (/ S/ ,/ Q/ )/ {/ I/ ∪/ S/ }/ 8/ ./ removeSmaxfromMaxLMC/ (/ S/ ,/ Q/ )/ 9/ ./ I/ =/ I/ ∪/ Smax10/ ./ iteration/ ++/ 11/ ./ returnI/ 算法/ 3/ 是/ Maximumk/ -/ SetCover/ 问题/ 的/ 经典/ 贪心/ 解法/ ,/ Maximumk/ -/ SetCover/ 问题/ 是/ 集合/ 上/ 最小/ 覆盖/ 问题/ [/ 13/ ]/ 的/ 最优化/ 问题/ ,/ 是/ 一个/ 经典/ 的/ NP/ 完全/ 问题/ ./ 上述/ 贪心/ 解法/ 不能/ 完全正确/ 地/ 求解/ Maximumk/ -/ SetCover/ 问题/ ,/ 但是/ 能/ 给出/ (/ 1/ -/ 1/ // e/ )/ 的/ 近似/ 率/ [/ 20/ ]/ ./ Page8/ 引理/ 3/ ./ 给定/ k/ -/ MaxLMC/ (/ S/ ,/ Q/ )/ 问题/ ,/ 令/ Iopt/ 表示/ 其/ 最优/ 解/ ,/ Igreedy/ 表示/ Baseline/ 贪心/ 法/ 的/ 解/ ,/ C/ (/ I/ )/ 表示/ I/ 中/ 涵盖/ 的/ 元组/ 数目/ ./ 则/ C/ (/ Igreedy/ )/ // C/ (/ Iopt/ )/ / (/ 1/ -/ 1/ // e/ )/ ./ e/ 为/ 自然对数/ 的/ 底/ ./ 4.2/ 改进/ (/ Improved/ )/ 方法/ 观察/ 到/ 我们/ 的/ 问题/ 中/ 在/ 某/ 属性/ 上/ 的/ 聚合/ 结果/ 是/ 互不/ 相交/ 的/ ,/ 即/ ,/ MaxLMC/ (/ S/ ,/ Q/ )/ 中/ 的/ 结果/ 按照/ 聚合/ 属性/ 的/ 不同/ (/ 假设/ 其中/ 涉及/ 到/ m/ 个/ 聚合/ 属性/ )/ 可/ 分为/ m/ 类/ ,/ 其中/ 每类/ 上/ 的/ 最大/ 最低/ 上层/ 最小/ 覆盖/ 聚合/ 集/ MaxLMC/ 之间/ 互不/ 相交/ ./ 例如/ ,/ 在/ 图/ 4/ 中/ ,/ 若/ S1/ 和/ S3/ 是/ 按照/ 价格/ 区间/ 属性/ 上求/ MaxLMC/ 的/ 结果/ ,/ 则/ 它们/ 是/ 不/ 相交/ 的/ ,/ 这/ 是因为/ 对于/ 某一/ 汽车/ ,/ 其/ 价格/ 区间/ 唯一/ ,/ 因此/ 其/ 属于/ 且/ 只/ 属于/ 一类/ 中/ ./ 由于/ m/ 类中/ 每/ 一类/ 上/ 的/ MaxLMC/ 是/ 对/ MC/ 的/ 细分/ ,/ 因此/ 这/ m/ 类中/ 的/ 集合/ 之间/ 互不/ 相交/ ./ 形式化/ 的/ 表述/ 为/ :/ MaxLMC/ (/ S/ ,/ Q/ )/ 按照/ 聚合/ 属性/ 归类/ 为/ {/ M1/ ,/ M2/ ,/ …/ ,/ Mm/ }/ ,/ 其中/ 每/ 一类/ Mi/ =/ {/ Mimi/ }/ 中/ 的/ 聚合/ 覆盖/ 互不/ 相交/ ,/ 且/ 前文/ 已述/ ,/ Mi/ 中/ 的/ Mi/ 各个/ MaxLMC/ (/ 以下/ 简称/ 聚合/ 集/ )/ 是/ 按照/ 规模/ 降序/ 排列/ ./ 例/ 2/ ./ 如图/ 5/ 所示/ ,/ MaxLMC/ (/ S/ ,/ Q/ )/ 中有/ m/ =/ 2/ 时/ 两类/ 聚合/ 集族/ a/ ,/ b/ ,/ 数字/ 表示/ MaxLMC/ 中/ 元组/ 的/ 数目/ ,/ 每一族/ 上/ 的/ 各个/ 聚合/ 集/ 互不/ 相交/ ./ 我们/ 先/ 给出/ 算法/ 3/ 的/ 3/ 个/ 剪枝/ 条件/ ,/ 然后/ 分别/ 对照/ 此例/ 阐述/ ./ 图/ 5m/ =/ 2/ 时/ MaxLMC/ (/ S/ ,/ Q/ )/ 可能/ 的/ 情况/ ,/ 数字/ 代/ (/ 1/ )/ InitialFilter/ ./ 若/ 初始/ 最大/ MaxLMC/ 来自/ 1/ ,/ 则/ 若/ |/ MiMi/ 立/ ,/ Mi/ 选择/ 直到/ 出现/ k/ ≠/ i/ 使得/ |/ Mi2/ 应是/ 下/ 一个/ 选择/ 的/ MaxLMC/ ,/ 而且/ 可以/ 继续/ 例如/ ,/ 图/ 5/ 中/ ,/ 我们/ 从/ 元组/ 最多/ 的/ 聚合/ 集/ a1/ 开始/ 选取/ ,/ 当选/ 取/ 第/ 2/ 个/ 集合/ 时/ ,/ 由于/ a2/ 中/ 元组/ 为/ 19/ 条/ ,/ 比/ b1/ 要/ 多/ ,/ 因此/ 不必/ 考虑/ 其它/ 聚合/ 集/ ,/ 将/ a2/ 作为/ 结果/ 输出/ 即可/ ./ 同样/ 的/ ,/ a3/ 也/ 因此/ 被/ 输出/ ./ (/ 2/ )/ InclusiveFilter/ ./ 若/ 当前/ 摘要/ 集为/ I/ ,/ 并/ 处于/ 第/ r/ 次/ 迭代/ 当中/ ./ 在/ 考察/ Mi/ 的/ 时候/ ,/ 从/ Mi1/ ∩/ I/ |/ =/ t/ ,/ |/ I/ -/ ∪/ mi/ |/ Mi/ 要/ 按序/ 考察/ x/ -/ t/ +/ 1/ 个/ MaxLMC/ ./ 这是/ 基于/ 这样/ 的/ 原理/ :/ 当/ 按序/ 考察/ 集族/ a/ 的/ 聚合/ 集时/ ,/ 若/ 某/ ai/ 与/ I/ 不/ 相交/ ,/ 它/ 对/ |/ I/ ∪/ ai/ |/ 的/ 贡献/ 为/ |/ ai/ |/ ,/ 则/ ai/ +/ 1/ 以后/ 的/ 集合/ 均/ 不必/ 考虑/ ,/ 因为/ |/ ai/ +/ 1/ |/ / |/ ai/ |/ ,/ 其/ 以后/ 的/ 对/ 摘要/ 集/ 的/ 贡献/ 不会/ 多于/ 当前/ ai/ ./ 例如/ ,/ 图/ 5/ 中/ ,/ 假设/ 灰色/ 标记/ 的/ MaxLMC/ 的/ 并/ 集是/ 已经/ 选择/ 的/ 摘要/ 集/ I/ ,/ 当前/ 为/ 第/ 5/ 次/ 迭代/ ./ 对于/ a4/ 来说/ ,/ 假设/ 8/ 条/ 元组/ 中有/ 3/ 条/ 在/ I/ 中/ 出现/ (/ 此例/ 中/ 这/ 3/ 条/ 元组/ 来自/ b1/ )/ ,/ 且/ I/ 中共/ 有/ 9/ 条/ 元组/ 来自/ 集族/ b/ (/ 此例/ 中均/ 来自/ b1/ )/ ,/ 则/ 在/ 集族/ a/ 中/ 剩余/ 的/ 集合/ 最多/ 还/ 可能/ 与/ I/ 相交/ 的/ 数目/ 为/ 9/ -/ 3/ =/ 6/ ,/ 因此/ ,/ 在/ 按序/ 的/ 6/ +/ 1/ 个/ MaxLMC/ 内/ 必将/ 出现/ 一个/ 不/ 与/ I/ 相交/ 的/ 集合/ (/ 抽屉/ 原理/ )/ ,/ 此后/ 的/ 聚合/ 集均/ 不必/ 考虑/ ,/ 因为/ 依据/ 之前/ 分析/ ,/ 一旦/ 找到/ 一条/ 不/ 与/ 当前/ 摘要/ 集/ I/ 相交/ 的/ 聚合/ 集/ ,/ 以后/ 集合/ 均/ 不必/ 考虑/ ./ (/ 3/ )/ ExclusiveFilter/ ./ 若/ 当前/ 摘要/ 集为/ I/ ,/ 并/ 处于/ 第/ r/ 次/ 迭代/ 当中/ ./ 在/ 考察/ Mi/ 的/ 时候/ ,/ 从/ Mi1/ ∩/ I/ |/ =/ t/ ,/ 则/ 在/ Mi/ 中/ ,/ 我们/ 只/ 需要/ 考察/ 到/ 规模/ 若/ |/ Mi1/ |/ -/ t/ 的/ MaxLMC/ ./ 为/ |/ Mi/ 例如/ ,/ 图/ 5/ 中/ ,/ 当前/ 为/ 第/ 5/ 次/ 迭代/ ,/ 同上例/ ,/ 对于/ a4/ ,/ 有/ 3/ 条/ 元组/ 在/ b1/ 中/ ,/ 则/ a4/ 的/ 贡献/ 为/ 8/ -/ 3/ =/ 5/ ,/ 那么/ 我们/ 仅/ 需/ 考察/ 到/ 规模/ 为/ 5/ 的/ a5/ 即可/ ,/ 因为/ a5/ 以后/ 的/ MaxLMC/ 规模/ 都/ 小于/ 5/ ,/ 贡献/ 不/ 可能/ 比/ a4/ 大/ ./ 我们/ 的/ 改进/ 的/ Summary/ 方法/ 即/ 在/ 基本/ 的/ 方法/ 基础/ 上/ 应用/ 上述/ 3/ 种/ 剪枝/ 策略/ 得到/ ./ 具体/ 伪码/ 略/ ./ 5/ 实验/ 为了/ 验证/ 文中/ 所/ 提出/ 的/ 关于/ 聚合/ 问题/ 和/ 摘要/ 问题/ 的/ 改进/ 方法/ ,/ 我们/ 分别/ 在/ 真实/ 数据/ 和/ 模拟/ 数据/ 上/ 做/ 实验/ ./ 真实/ 数据/ 来自/ 电子/ 工业部/ 某/ 研究所/ 的/ 保密/ 数据/ ./ 为了/ 验证/ 本文/ 方法/ ,/ 我们/ 依照/ 图/ 1/ (/ e/ )/ 中/ 给出/ 的/ 模式/ 生成/ 了/ 模拟/ 数据/ ./ 如图/ 1/ 所示/ ,/ 该/ 数据库/ 模式/ 上/ 共有/ 4/ 个/ 分类/ 属性/ 和/ 3/ 个/ 具有/ 偏序/ 关系/ 的/ 聚合/ 属性/ ./ 生成/ 数据/ 时/ ,/ 我们/ 指定/ 了/ 各/ 分类/ 属性/ 和/ 聚合/ 属性/ 上值/ 相同/ 的/ 元组/ 最多为/ 100/ 条/ ,/ 这/ 也就是说/ ,/ 聚合/ 得到/ 的/ MaxLMC/ 的/ 最/ 大规模/ 不会/ 超过/ 100/ ./ 在/ 其它/ 属性/ 上/ 我们/ 均/ 是从/ 预先/ 定义/ 的/ 字典/ 中/ 随机/ 赋值/ ./ 另外/ ,/ CLASS/ 表/ 的/ 层次/ 最大/ 深度/ 为/ 5/ ,/ 平均/ 深度/ 为/ 3.12/ ;/ 其余/ 三张/ 表/ 的/ 元组/ 数目/ 如表/ 3/ ./ Page9AUTO1000005/ ./ 1/ 数据/ 准备/ 对于/ 真实/ 数据/ 和/ 模拟/ 数据/ ,/ 首先/ 我们/ 在/ 其/ 上/ 做/ 关键字/ 的/ 倒排/ 索引/ ,/ 按照/ DISCOVER/ 系统/ 的/ 方案/ 生成/ 在/ 分类/ 属性/ 或/ 聚合/ 属性/ 上带/ Groupby/ 的/ SQL/ 语句/ ./ 然后/ 将/ 这些/ SQL/ 语句/ 投入/ 数据库/ 中/ ./ 本/ 实验/ 是/ 在/ VisualStudio2010/ 平台/ 上/ 开发/ ,/ 用/ C++/ 编写/ ,/ 数据库/ 使用/ MySQL5/ ./ 0/ 版本/ ./ 运行/ 在/ PC/ 上/ ,/ IntelCPU/ ,/ 主频/ 2.8/ GHz/ ,/ 内存/ 8GB/ ./ 5.2/ 聚合/ 结果/ 真实/ 数据/ 和/ 模拟/ 数据/ 上/ 我们/ 都/ 选取/ 了/ 10/ 组/ 用于/ 检索/ 的/ 关键字/ ./ 由于/ 聚合/ 操作/ 的/ 两个/ 算法/ 之间/ 涉及/ 到/ 不同/ 的/ 数据库/ 操作/ ,/ 直接/ 比较/ 时间/ 代价/ 是/ 不/ 可行/ 的/ ./ 因此/ 我们/ 在/ 此/ 比较/ 按序/ 连接/ 方法/ 的/ 节省/ 比/ ,/ 即/ 按序/ 连接/ 方法/ 的/ 连接/ 次数/ 占/ 基于/ Groupby/ 方法/ 的/ 连接/ 次数/ 的/ 比例/ ./ 另外/ ,/ 由于/ 有/ 多个/ 聚合/ 属性/ ,/ 我们/ 对/ 每个/ 检索/ 都/ 分别/ 在/ 每个/ 聚合/ 属性/ 上/ 做/ 聚合/ ,/ 然后/ 用/ 总/ 的/ 节省/ 连接/ 次数/ 除以/ 总/ 的/ 连接/ 次数/ 做/ 平均/ 节省/ 比/ ./ 由于/ 在/ 按序/ 连接/ 方法/ 中/ 我们/ 不/ 需要/ 数据库/ 管理系统/ 来/ 做/ 连接/ ,/ 而是/ 需要/ 待/ 连接/ 元组/ 集/ (/ 见/ 3.2/ 小节/ )/ ,/ 因此/ 在/ 本/ 实验/ 中/ ,/ 我们/ 将/ DISCOVER/ 由/ 候选/ 网络/ 翻译成/ SQL/ 语句/ 时/ 从/ 候选/ 网络/ 的/ 连接/ 操作/ 处/ 断开/ 拆分/ 成为/ 个/ 候选/ 网络/ ,/ 然后/ 分别/ 生成/ SQL/ 语句/ 投入/ 数据库/ 中/ 得到/ 待/ 连接/ 元组/ 集/ ./ 对于/ 涉及/ 到/ 两次/ 连接/ 以上/ 的/ 候选/ 网络/ ,/ 我们/ 将/ 指定/ 最/ 晚/ 连接/ 属性/ 并/ 从/ 该/ 连接/ 属性/ 处/ 断开/ ./ 具体/ 实现/ 时/ ,/ 由于/ 模式图/ 已知/ ,/ 我们/ 事先/ 指定/ 某些/ 外键/ 属性/ 为/ 最晚/ 连接/ 属性/ ./ 例如/ ,/ 对于/ 本次/ 实验/ 的/ 模拟/ 数据/ ,/ 我们/ 选择/ 自然/ 连接/ 时/ 的/ 公共/ 属性/ 做/ 为/ 最晚/ 连接/ 属性/ (/ 即例/ 中/ 的/ ClassKey/ 、/ Com/ -/ panyKey/ 和/ NationKey/ 属性/ )/ ./ 需要/ 注意/ 的/ 是/ ,/ 若/ 某/ 候选/ 网络/ 中/ 同时/ 具有/ 两个/ 以上/ 的/ 连接/ 操作/ ,/ 则/ 我们/ 按序/ 从/ 首先/ 出现/ 最/ 晚/ 连接/ 属性/ 的/ 那个/ 连接/ 操作/ 处/ 断开/ ./ 图/ 6/ 和/ 图/ 7/ 分别/ 是/ 真实/ 数据/ 和/ 模拟/ 数据/ 上/ 的/ 节省/ 比率/ ./ 图中/ ,/ 横坐标/ 是/ 10/ 次/ 不同/ 的/ 查询/ ,/ 纵坐标/ 则/ 为/ 节省/ 比/ ./ 在/ 图/ 6/ 中/ ,/ Q1/ 和/ Q6/ 的/ 节省/ 为/ 0/ ,/ 这/ 是因为/ Q1/ 和/ Q6/ 的/ 关键字/ 分别/ 来自/ 两张/ 不同/ 的/ 表/ ,/ 其中/ 有/ 一张/ 表上/ 没有/ 层次/ 关系/ ,/ 此时/ 算法/ 2/ 退化/ 为/ 算法/ 1/ ,/ 并/ 没有/ 节省/ 连接/ 操作/ ./ 这/ 在/ 实际/ 情况/ 中/ 时有发生/ ,/ 与/ 具体/ 的/ 数据/ 和/ 检索/ 都/ 有/ 关系/ ./ 而/ 在/ 模拟/ 数据/ 中/ ,/ 算法/ 退化/ 并/ 不/ 明显/ ,/ 这是/ 由于/ 我们/ 随机/ 赋值/ ,/ 因此/ 包含/ 不同/ 的/ 关键字/ 的/ 元组/ 基本上/ 都/ 可以/ 来自/ 具有/ 层次/ 属性/ 的/ 关系/ ,/ 故而/ 按序/ 连接/ 方法/ 在/ 此处/ 没有/ 完全/ 退化/ ./ 5.3/ 摘要/ 我们/ 考察/ 当/ k/ 不/ 同时/ 及/ MaxLMC/ 中/ 分类/ M/ 不/ 同时/ Improved/ 方法/ 的/ 效率/ 差异/ ./ 真实/ 数据/ 上/ 返回/ 结果/ 的/ 平均/ 元组/ 数目/ 为/ 1743/ 条/ ,/ 针对/ 每个/ 检索/ ,/ 我们/ 都/ 分别/ 选定/ 聚合/ 属性/ 为/ 2/ 个/ 和/ 3/ 个/ 时/ 做/ 摘要/ 算法/ 的/ 比较/ ,/ 平均/ 每次/ 聚合/ 生成/ 223/ 个/ (/ m/ =/ 2/ 时/ )/ 和/ 421/ 个/ (/ m/ =/ 3/ 时/ )/ MaxLMC/ ./ 模拟/ 数据/ 上/ 返回/ 结果/ 的/ 平均/ 元组/ 数目/ 为/ 5201/ 条/ ,/ 同样/ 的/ ,/ 我们/ 也/ 在/ 2/ 个/ 和/ 3/ 个/ 聚合/ 属性/ 上/ 做/ 聚合/ ,/ 平均/ 每次/ 聚合/ 生成/ 2210/ 个/ (/ m/ =/ 2/ 时/ )/ 和/ 3102/ 个/ (/ m/ =/ 3/ 时/ )/ MaxLMC/ ,/ 这/ 与/ 真实/ 数据/ 差异/ 较大/ ,/ 主要/ 因为/ 模拟/ 数据/ 的/ 关键字/ 分布/ 比较/ 随机/ ,/ 并非/ 真实/ 数据/ 上/ 呈/ 明显/ 的/ 分布/ 区分/ ./ 在/ 做/ 摘要/ 时/ ,/ 贪心/ 法/ 随着/ k/ 的/ 增长/ 时间/ 代价/ 增长/ 很快/ ,/ 图/ 8/ 、/ 图/ 9/ 显示/ 了/ 这种/ 情况/ ,/ 上方/ 的/ 曲线/ 为/ 基本/ 的/ 贪心/ 方法/ 随着/ k/ 值/ 从/ 5/ ~/ 25/ 变化/ 所/ 需/ 的/ 时间/ 花费/ ,/ 其中/ 纵坐标/ 取/ 时间/ 的/ 对数/ ./ 这/ 是因为/ 在/ k/ 增长/ 时/ ,/ 每/ 一轮/ 迭代/ 都/ 要/ 遍历/ 所有/ 的/ 元组/ 集合/ 用以/ 判定/ 最大/ 覆盖/ ./ 图/ 8/ 考察/ 了/ 对/ 2/ 类/ 属性/ 上/ MaxLMC/ 摘要/ 的/ 结果/ ./ 上方/ 曲线/ 为/ Baseline/ 方法/ 随着/ 摘要/ 集/ 规模/ k/ 的/ 增长/ 摘要/ 时间/ 的/ 增长/ ,/ 下方/ 曲线/ 为/ 具有/ 剪枝/ 的/ Improved/ 方法/ 时间/ 花费/ ./ 从/ 数据/ 上/ 可以/ 看出/ ,/ 剪枝/ 以后/ 的/ 时间/ 效率/ 大幅/ 提升/ ./ 同时/ ,/ 无论/ 在/ 真实/ 数据/ 和/ 模拟/ 数据/ 上/ ,/ 我们/ 的/ 剪枝/ 算法/ 都/ 能/ 保证/ 时间/ 效率/ ./ 但是/ 随着/ k/ 的/ 增长/ ,/ 剪枝/ 算法/ 时间/ 代价/ 仍/ 近似/ 指数/ 增/ Page10/ 长/ ./ 考虑/ 到/ 实际/ 应用/ 中/ k/ 值/ 选取/ 一般/ 不会/ 很大/ ,/ 因此/ 我们/ 的/ 剪枝/ 算法/ 可以/ 保证/ 摘要/ 的/ 实时性/ ./ 图/ 8m/ =/ 2/ 时/ 真实/ (/ 上/ )/ 和/ 模拟/ (/ 下/ )/ 数据/ 比较/ 图/ 9/ 考察/ 了/ 对/ 3/ 类/ 属性/ 上/ MaxLMC/ 做/ 摘要/ 的/ 结果/ ,/ 仍/ 可/ 从中/ 看出/ 剪枝/ 后/ 时间/ 效率/ 的/ 大幅/ 提升/ ./ 当/ 与/ 图/ 8/ 中/ m/ =/ 2/ 时/ 情况/ 对比/ ,/ 可以/ 发现/ ,/ 我们/ 的/ 剪枝/ 算法/ 效率/ 有所/ 下降/ ,/ 但/ 仍然/ 可/ 保证/ 实时性/ ./ 这/ 是因为/ 我们/ 的/ 剪枝/ 是/ 针对/ 某/ 一个/ 属性/ 上/ 的/ 聚合/ 结果/ 的/ 剪枝/ ,/ 若/ m/ 值/ 增大/ ,/ 时间/ 耗费/ 也/ 会/ 随之/ 逐渐/ 增大/ ./ 图/ 9m/ =/ 3/ 时/ 真实/ (/ 上/ )/ 和/ 模拟/ (/ 下/ )/ 数据/ 比较/ 6/ 总结/ 本文/ 在/ 具有/ 层次/ 关系/ 的/ 关系数据库/ 上/ 提出/ 了/ 关键字/ 检索/ 结果/ 的/ 聚合/ 问题/ 和/ 聚合/ 结果/ 的/ 摘要/ 问题/ ,/ 我们/ 以/ DISCOVER/ 作为/ 基础/ ,/ 在/ 其/ 上/ 进行/ 扩展/ ./ 此外/ ,/ 针对/ 两个/ 问题/ 的/ 基本/ 算法/ 我们/ 又/ 提出/ 了/ 具体/ 的/ 改进/ 算法/ ./ 分析/ 和/ 实验/ 结果表明/ ,/ 改进/ 算法/ 的/ 时间/ 花费/ 较/ 小/ ,/ 具有/ 明显/ 优势/ ./ 进一步/ 的/ 工作/ 包括/ 考虑/ 更加/ 有/ 意义/ 的/ 反馈/ 机制/ 和/ 对/ 摘要/ 结果/ 进行/ 打分/ ,/ 用以/ 将/ 聚合/ 结果/ 按照/ 相关/ 顺序/ 返回/ ./ 

