Page1/ 确定性/ 并行/ 技术/ 周旭/ 卢凯/ 陈沉/ (/ 国防科技大学/ 计算机/ 学院/ 长沙/ 410073/ )/ (/ 国防科技大学/ 并行/ 与/ 分布/ 处理/ 国家/ 重点/ 实验室/ 长沙/ 410073/ )/ 摘要/ 由于/ 执行/ 个体/ 之间/ 的/ 同步/ 、/ 竞争/ 和/ 干扰/ ,/ 并行程序/ 的/ 执行/ 存在/ 着/ 不确定性/ 问题/ ,/ 即/ 程序/ 在/ 相同/ 输入/ 下/ 多次/ 执行/ 可能/ 得到/ 不同/ 的/ 结果/ ./ 不确定性/ 给/ 并行程序/ 在/ 开发/ 、/ 调试/ 、/ 测试/ 、/ 容错/ 和/ 安全/ 等/ 方面/ 都/ 带来/ 了/ 挑战/ ,/ 严重/ 降低/ 了/ 并行程序/ 的/ 可靠性/ ,/ 阻碍/ 了/ 并行程序/ 的/ 发展/ ./ 确定性/ 并行/ 技术/ 通过/ 控制/ 并行程序/ 执行/ 个体/ 间/ 的/ 同步/ 、/ 竞争/ 和/ 干扰/ ,/ 使/ 程序/ 的/ 执行/ 结果/ 仅/ 依赖于/ 输入/ ./ 确定性/ 并行/ 技术/ 能够/ 从根本上/ 解决/ 了/ 目前/ 并行程序/ 存在/ 的/ 诸多/ 问题/ ,/ 提升/ 了/ 并行程序/ 的/ 可靠性/ ,/ 给/ 并行程序/ 的/ 发展/ 带来/ 了/ 新/ 的/ 机遇/ ./ 文中/ 调查/ 、/ 分析/ 和/ 比较/ 了/ 目前/ 主流/ 的/ 确定性/ 并行/ 技术/ 和/ 方法/ ,/ 分析/ 了/ 弱/ 内存/ 一致性/ 对/ 确定性/ 并行/ 系统/ 的/ 影响/ ,/ 并/ 对/ 未来/ 确定性/ 并行/ 技术/ 的/ 发展趋势/ 做出/ 了/ 展望/ ./ 关键词/ 确定性/ ;/ 并行计算/ ;/ 可靠性/ ;/ 数据/ 竞争/ 1/ 引言/ 和/ 传统/ 的/ 串行/ 程序/ 相比/ ,/ 并行程序/ 在/ 给/ 计算/ 性能/ 带来/ 提升/ 的/ 同时/ ,/ 也/ 给/ 程序/ 的/ 开发/ 和/ 维护/ 带来/ 了/ 挑战/ ./ 并行程序/ 通常/ 由/ 多个/ 并行执行/ 个体/ (/ 如/ 线程/ )/ 协同/ 完成/ 一个/ 任务/ ,/ 因此/ 执行/ 个体/ 之间/ 就/ 广泛/ 存在/ 着/ 同步/ 、/ 竞争/ 和/ 干扰/ 的/ 问题/ ,/ 这/ 就/ 导致/ 了/ 并行程序/ 的/ 不确定性/ ,/ 即/ 程序/ 在/ 相同/ 的/ 输入/ 下/ 多次/ 执行/ ,/ 可能/ 产生/ 不同/ 的/ 执行/ 路径/ 和/ 结果/ ./ 这种/ 不确定性/ 给/ 并行程序/ 在/ 许多/ 方面/ (/ 如/ 开发/ 、/ 测试/ 、/ 维护/ 、/ 容错/ 和/ 安全/ 等/ )/ 都/ 带来/ 了/ 新/ 的/ 挑战/ ./ 目前/ ,/ 确定性/ 并行/ 技术/ 被/ 认为/ 是/ 应对/ 这个/ 挑战/ 的/ 关键/ 核心技术/ [/ 1/ -/ 7/ ]/ ./ 确定性/ 并行/ 技术/ 要求/ 程序/ 在/ 相同/ 的/ 输入/ 下/ 运行/ 时/ 总是/ 能/ 得到/ 相同/ 的/ 执行/ 流程/ 和/ 结果/ ./ 确定性/ 并行/ 技术/ 的/ 基本/ 思想/ 是/ 控制/ 并行执行/ 个体/ 之间/ 的/ 同步/ 、/ 竞争/ 和/ 干扰/ ,/ 使/ 执行/ 个体/ 之间/ 按照/ 一定/ 的/ 规则/ 和/ 顺序/ 进行/ 交互/ ,/ 从而/ 确保/ 每次/ 执行/ 都/ 能/ 复现/ 这种/ 规则/ 和/ 顺序/ ,/ 使/ 程序/ 即使/ 在/ 不同/ 的/ 环境/ 中/ 执行/ 也/ 能/ 得到/ 相同/ 的/ 结果/ ./ 在/ 确定性/ 并行/ 技术/ 下/ ,/ 程序/ 的/ 执行/ 结果/ 仅/ 依赖于/ 输入/ 和/ 程序逻辑/ 本身/ ,/ 因此/ 排除/ 了/ 外界/ 环境/ 对于/ 执行/ 结果/ 的/ 影响/ ./ 然而/ 目前/ 确定性/ 并行/ 技术/ 的/ 研究/ 还/ 不/ 成熟/ ,/ 存在/ 着/ 诸多/ 问题/ :/ 例如/ 纯/ 软件/ 实现/ 的/ 确定性/ 并行/ 系统/ 效率/ 普遍/ 低下/ ,/ 可以/ 达到/ 2/ ~/ 10/ 倍/ 的/ 性能/ 开销/ ,/ 这使/ 它们/ 很难/ 在/ 实际/ 应用/ 中/ 被/ 接受/ [/ 1/ -/ 2/ ]/ ;/ 而/ 硬件/ 支持/ 的/ 确定性/ 并行/ 系统/ 如今/ 只有/ 模拟/ 结果/ ,/ 在/ 实验室/ 和/ 工业界/ 都/ 不/ 存在/ 真实/ 的/ 硬件/ 确定性/ 系统/ [/ 1/ ,/ 7/ ]/ ./ 除此之外/ ,/ 确定性/ 并行/ 系统/ 还/ 存在/ 着/ 诸如/ 移植性/ 、/ 稳定性/ 、/ 可扩展性/ 等/ 方面/ 的/ 问题/ ./ 这些/ 问题/ 制约/ 了/ 确定性/ 并行/ 技术/ 的/ 实用化/ ,/ 亟需/ 解决/ ./ 本文/ 分析/ 了/ 引起/ 并行程序/ 不确定性/ 的/ 原因/ ,/ 介绍/ 了/ 确定性/ 并行/ 技术/ 的/ 优势/ ;/ 对/ 目前/ 的/ 确定性/ 并行/ 技术/ 方法/ 做/ 了/ 总结/ 和/ 归类/ ,/ 详细/ 对比/ 了/ 几种/ 主要/ 的/ 确定性/ 并行/ 技术/ 方法/ ,/ 其中/ 也/ 包括/ 我们/ 自己/ 实现/ 的/ 三个/ 确定性/ 算法/ ;/ 并/ 针对/ 弱/ 内存/ 一致性/ 对/ 确定性/ 并行/ 系统/ 的/ 影响/ 做/ 了/ 深入分析/ ./ 在/ 此基础/ 上/ ,/ 展望/ 了/ 未来/ 确定性/ 并行/ 技术/ 的/ 发展趋势/ ./ 2/ 并行程序/ 的/ 不确定性/ 并行/ 主要/ 有/ 两种/ 形式/ ,/ 一种/ 是/ 多线程/ 并行/ ,/ 即/ 各个/ 并行执行/ 个体/ 之间/ 共享内存/ 空间/ ;/ 另/ 一种/ 是/ 多/ 进程/ 并行/ ,/ 即/ 各个/ 执行/ 个体/ 之间/ 不/ 共享内存/ 空间/ ,/ 而是/ 通过/ 其他/ 方式/ (/ 例如/ 管道/ 或者/ 网络/ )/ 进行/ 通信/ ./ 然而/ 不管/ 是/ 何种/ 并行/ 形式/ ,/ 都/ 存在/ 着/ 不确定性/ 执行/ 的/ 问题/ ./ 在/ 本节/ 中/ ,/ 我们/ 将/ 分析/ 引起/ 并行程序/ 不确定性/ 的/ 主要/ 因素/ 及/ 不确定性/ 给/ 程序/ 带来/ 的/ 挑战/ ./ 2.1/ 不确定性/ 因素/ 在/ 多线程/ 并行/ 中/ ,/ 导致/ 程序/ 不确定性/ 的/ 原因/ 是/ 线程/ 对于/ 共享内存/ 的/ 竞争/ 访问/ ./ 我们/ 可以/ 将/ 其/ 分为/ 数据/ 竞争/ 和/ 同步/ 竞争/ 两种/ 形式/ ./ 数据/ 竞争/ 是/ 指/ 并行执行/ 的/ 两个/ 访存/ 操作/ 对/ 同一个/ 内存/ 单元/ 进行/ 访问/ ,/ 它们/ 的/ 执行/ 顺序/ 没有/ 被/ 任何/ 同步/ 语句/ 所/ 限制/ ,/ 并且/ 其中/ 至少/ 一个/ 访存/ 操作/ 为/ 写/ 指令/ ./ 同步/ 竞争/ 是/ 指/ 两个/ 互斥/ 同步/ 语句/ 同时/ 访问/ 一个/ 同步/ 变量/ ,/ 例如/ 两个/ 加锁/ 操作/ (/ lock/ )/ 同时/ 在/ 加/ 一把/ 锁/ (/ L/ )/ ./ 实际上/ 同步/ 竞争/ 是/ 一种/ 特殊/ 的/ 数据/ 竞争/ ,/ 是/ 线程/ 通过/ 原子/ 指令/ 对/ 同步/ 变量/ 的/ 一种/ 竞争/ 访问/ ./ 但是/ 因为/ 同步/ 语句/ 的/ 特殊性/ ,/ 有/ 必要/ 将/ 其/ 单列/ 出来/ ./ 图/ 1/ 展示/ 了/ 数据/ 竞争/ 和/ 同步/ 竞争/ 引起/ 程序执行/ 不确定性/ 的/ 两段/ 代码/ ./ 线程/ T1/ 和/ 线程/ T2/ 同时/ 进行/ 存款/ 和/ 取款/ 的/ 操作/ ,/ 当/ 两次/ 执行/ 的/ 线程/ 访存/ 交织/ 顺序/ 不/ 同时/ ,/ 代码/ 的/ 最终/ 执行/ 结果/ 就/ 会/ 不同/ ./ 图/ 1/ (/ a/ )/ 中/ 的/ 代码/ 没有/ 用锁/ 保护/ ,/ 因此/ 并行执行/ 时会/ 产生/ 对/ 共享/ 变量/ x/ 的/ 数据/ 竞争/ (/ T1/ :/ 1/ 和/ T2/ :/ 2/ ,/ T1/ :/ 2/ 和/ T2/ :/ 1/ ,/ T1/ :/ 2/ 和/ T2/ :/ 2/ 都/ 会/ 分别/ 形成/ 数据/ 竞争/ )/ ./ 竞争/ 的/ 结果/ 会/ 导致/ 变量/ x/ 最终/ 的/ 值/ 可能/ 为/ 9/ ,/ 10/ 或者/ 11/ ./ 图/ 1/ (/ b/ )/ 中/ 的/ 代码/ 虽然/ 用锁/ 保护/ 了/ 存款/ 和/ 取款/ 操作/ 的/ 原子/ 性/ ,/ 不会/ 产生/ 对/ 变量/ x/ 的/ 竞争/ 访问/ ,/ 然而/ 两个/ 线程/ 对锁/ 的/ 竞争/ 依然/ 存在/ ,/ 因此/ 不确定性/ 仍然/ 没有/ 消除/ ./ 如果/ 线程/ T1/ 先/ 得到/ 锁/ ,/ 就/ 会/ 使/ 客户/ 的/ 存款/ 量/ 达到/ 10/ 以上/ ,/ 因此/ 账户/ 会/ 自动/ 升级/ 为/ VIP/ 账户/ ./ 反之/ ,/ 如果/ 线程/ T2/ 先/ 得到/ 锁/ ,/ 线程/ T1/ 再/ 执行/ 存款/ 操作/ 时/ 存款/ 量/ 就/ 只有/ 10/ ,/ 因此/ 最终/ 此/ 账户就/ 不会/ 升级/ 为/ VIP/ 账户/ ./ 在/ 多/ 进程/ 程序/ 中/ ,/ 同样/ 存在/ 着/ 进程/ 间/ 的/ 交互/ ,/ 因此/ 也/ 可能/ 引发/ 不确定性/ ./ 例如/ ,/ MPI/ 消息传递/ 是/ 一/ Page3/ 种/ 常见/ 的/ 多/ 进程/ 并行/ 模型/ ./ 进程/ 通过/ 调用/ 消息/ 发送/ 和/ 接收/ 函数/ 来/ 进行/ 交互/ ./ 在/ MPI/ 中/ 存在/ 着/ 异步/ 消息/ 传递函数/ 和/ 混杂/ 消息/ 接收/ 函数/ ./ 异步/ 消息/ 传递函数/ 并/ 不能/ 保证/ 消息传递/ 能够/ 在/ 确定/ 的/ 程序执行/ 点/ 完成/ ,/ 而/ 混杂/ 消息/ 接收/ 函数/ 可以/ 选择/ 接收/ 任意/ 到达/ 的/ 消息/ ,/ 它们/ 都/ 能/ 引起/ 程序执行/ 状态/ 的/ 不/ 确定/ [/ 8/ -/ 9/ ]/ ./ 非/ 并行/ 引起/ 的/ 不确定性/ ./ 程序/ 中/ 还/ 可能/ 存在/ 其他/ 一些/ 能够/ 引起/ 不确定性/ 的/ 操作/ ,/ 例如/ 对/ 随机数/ 发生器/ rand/ 函数/ 的/ 调用/ ./ 这种/ 不确定性/ 是/ 一种/ 人为/ 的/ 不确定性/ ,/ 是/ 程序逻辑/ 本身/ 所/ 需要/ 的/ ,/ 同时/ 也/ 是/ 一种/ 可控/ 的/ 不确定性/ ./ 这种/ 不确定性/ 不是/ 由/ 并行/ 所/ 引起/ 的/ ,/ 因此/ 并/ 不是/ 并行程序/ 所/ 固有/ 的/ ,/ 在/ 串行/ 程序/ 中/ 同样/ 存在/ ./ 由于/ 这种/ 不确定性/ 并/ 不/ 增加/ 程序/ 的/ 开发/ 和/ 维护/ 难度/ ,/ 因此/ 不/ 属于/ 确定性/ 并行/ 技术/ 的/ 研究/ 范畴/ ./ 2.2/ 不确定性/ 的/ 挑战/ 和/ 安全/ 等/ 许多/ 方面/ 都/ 带来/ 了/ 严峻/ 的/ 挑战/ ./ 不确定性/ 给/ 并行程序/ 的/ 开发/ 、/ 维护/ 、/ 测试/ 、/ 容错/ 不确定性/ 对/ 程序开发/ 的/ 挑战/ ./ 并行程序/ 的/ 开发/ 要/ 比/ 串行/ 程序/ 困难/ 得/ 多/ ./ 因为/ 线程/ 之间/ 的/ 交织/ 顺序/ 是/ 没有/ 任何/ 限定/ 的/ ,/ 这/ 导致/ 程序员/ 在/ 编写/ 并行程序/ 时/ 不但/ 要/ 考虑/ 程序逻辑/ ,/ 更要/ 注意/ 线程/ 之间/ 所有/ 可能/ 的/ 交织/ 顺序/ ,/ 小心/ 的/ 使用/ 同步/ 语句/ 保证/ 程序/ 并行执行/ 的/ 正确性/ ./ 这/ 就/ 给/ 普通/ 程序员/ 形成/ 了/ 很/ 高/ 的/ 门槛/ ,/ 即便/ 是/ 熟练/ 的/ 程序员/ 也/ 难免/ 出现/ 各种/ 错误/ ./ Lee/ [/ 4/ ]/ 在/ 其/ 研究/ 中/ 指出/ ,/ 即使/ 对于/ 很小/ 的/ 一段/ 并行算法/ ,/ 经验丰富/ 的/ 程序员/ 也/ 很/ 难/ 一次性/ 写出/ 正确/ 的/ 代码/ ./ 不确定性/ 对/ 程序/ 维护/ 的/ 挑战/ ./ 调试/ 是/ 程序/ 维护/ 的/ 重要/ 方面/ ./ 不确定性/ 导致/ 并行程序/ 的/ bug/ 不可/ 复现/ ,/ 从而/ 阻碍/ 了/ 调试/ 的/ 进行/ ./ 传统/ 的/ 最/ 直接/ 的/ 调试/ 方法/ 是/ :/ 通过/ 多次/ 迭代/ 式/ 的/ 运行/ 程序/ ,/ 追踪/ bug/ 信息/ ,/ 从而/ 一步步/ 逼近/ bug/ 的/ 根源/ ./ 然而/ 在/ 并行程序/ 中/ 很多/ bug/ 是/ 依赖于/ 特定/ 的/ 线程/ 交织/ 顺序/ 的/ ,/ 这些/ bug/ 因为/ 只有/ 在/ 特定/ 的/ 线程/ 交织/ 顺序/ 下/ 才/ 会/ 出现/ ,/ 因此/ 就/ 具有/ 很强/ 的/ 潜伏性/ ./ 即便/ 偶尔/ 出现/ 一次/ ,/ 也/ 很/ 难/ 通过/ 重新/ 运行/ 程序/ 来/ 重现/ bug/ ,/ 从而/ 导致/ 调试/ 方法/ 失效/ [/ 1/ -/ 3/ ,/ 5/ -/ 6/ ]/ ./ 不确定性/ 对/ 程序/ 测试/ 的/ 挑战/ ./ 由于/ 不确定性/ 的/ 影响/ ,/ 并行程序/ 在/ 相同/ 的/ 输入/ 下/ 往往/ 不能/ 得到/ 相同/ 的/ 输出/ ./ 在/ 并行程序/ 测试/ 时/ ,/ 即使/ 观察/ 到/ 程序/ 在/ 某个/ 输入/ 下/ 得到/ 了/ 正确/ 的/ 输出/ 结果/ ,/ 也/ 不能/ 保证/ 程序/ 在/ 生产/ 环境/ 中/ 在/ 同样/ 的/ 输入/ 下/ 一定/ 能/ 得到/ 同样/ 的/ 结果/ ./ 因此/ 传统/ 的/ 通过/ 输入/ 对/ 程序/ 进行/ 压力/ 测试/ 的/ 方法/ 在/ 一定/ 程度/ 上/ 会/ 失效/ ./ 不确定性/ 使得/ 程序/ 的/ 执行/ 不仅/ 依赖于/ 输入/ 的/ 变化/ ,/ 而且/ 还/ 受/ 线程/ 调度/ 等/ 时间/ 相关/ 因素/ 的/ 影响/ ./ 因此/ 要/ 得到/ 可信/ 的/ 测试/ 结果/ ,/ 就/ 必须/ 对/ 并行程序/ 的/ 交织/ 顺序/ 也/ 进行/ 覆盖/ ./ 然而/ 线程/ 的/ 交织/ 顺序/ 是/ 不/ 受限制/ 的/ ,/ 这/ 就/ 极大/ 的/ 增加/ 了/ 程序/ 的/ 测试/ 空间/ ,/ 给/ 程序/ 测试/ 带来/ 了/ 挑战/ [/ 1/ ,/ 5/ ,/ 10/ ]/ ./ 不确定性/ 对/ 程序/ 容错/ 的/ 挑战/ ./ 副本/ 容错/ 是/ 一种/ 常用/ 的/ 容错/ 技术/ ,/ 主要/ 使用/ 在/ 一些/ 对/ 可靠性/ 要求/ 很/ 高/ 的/ 领域/ ,/ 经常/ 用来/ 容/ 硬件/ 产生/ 的/ 偶发/ 错/ ./ 副本/ 容错/ 一般/ 要求/ 同时/ 运行/ 一个/ 程序/ 的/ 多个/ 实例/ (/ 称为/ 副本/ )/ ,/ 所有/ 运行/ 副本/ 给定/ 同样/ 的/ 输入/ ./ 在/ 这种/ 情况/ 下/ 即便/ 个别/ 硬件/ 产生/ 了/ 偶发/ 错/ ,/ 只要/ 正常/ 的/ 硬件/ 达到/ 一定/ 的/ 数量/ ,/ 运行/ 在/ 这些/ 硬件/ 上/ 的/ 副本/ 就/ 能/ 得到/ 正确/ 并且/ 一致/ 的/ 输出/ 结果/ ,/ 因此/ 最终/ 我们/ 依然/ 可以/ 得到/ 正确/ 的/ 执行/ 结果/ ./ 然而/ 不确定性/ 却/ 破坏/ 了/ 副本/ 容错/ 技术/ 在/ 并行程序/ 中/ 的/ 应用/ ./ 由于/ 不确定性/ 的/ 影响/ ,/ 即使/ 硬件/ 没有/ 产生/ 偶发/ 错/ ,/ 软件/ 仍然/ 有/ 可能/ 产生/ 不/ 一致/ 的/ 输出/ 结果/ ,/ 导致/ 我们/ 不能/ 判断/ 出/ 正确/ 的/ 运行/ 结果/ [/ 1/ -/ 3/ ]/ ./ 不确定性/ 对/ 程序/ 安全/ 的/ 挑战/ ./ 数据/ 竞争/ 和/ 不确定性/ 导致/ 并行程序/ 面临/ 着/ 一种/ 新/ 的/ 安全漏洞/ ,/ 即/ 并发/ 漏洞/ [/ 11/ -/ 13/ ]/ ./ 不同于/ 以往/ 由于/ 输入/ 引起/ 的/ 漏洞/ ,/ 并发/ 漏洞/ 是/ 由/ 特定/ 的/ 线程/ 交织/ 顺序/ 所/ 触发/ 的/ ,/ 不确定性/ 使得/ 这种/ 漏洞/ 具有/ 极强/ 的/ 隐蔽性/ 和/ 不可/ 复现/ 性/ ,/ 从而/ 对/ 漏洞/ 检测/ 和/ 入侵/ 检测/ 等/ 安全/ 领域/ 造成/ 了/ 严峻/ 的/ 挑战/ ./ 首先/ ,/ 不确定性/ 导致/ 这些/ 安全漏洞/ 很难/ 被/ 现有/ 的/ 漏洞/ 检测工具/ 所/ 发现/ ./ 其次/ ,/ 漏洞/ 一旦/ 被/ 利用/ 使/ 系统/ 遭到/ 攻击/ ,/ 系统管理员/ 也/ 很/ 难追踪/ 和/ 分析/ 入侵/ 代码/ 行为/ ,/ 不利于/ 漏洞/ 的/ 及时/ 修复/ ./ 3/ 确定性/ 并行/ 技术/ 确定性/ 并行/ 技术/ 的/ 目标/ 是/ 消除/ 由于/ 并行/ 引起/ 的/ 不确定性/ ,/ 降低/ 并行程序/ 的/ 开发/ 和/ 维护/ 成本/ ,/ 提高/ 并行程序/ 的/ 可靠性/ ,/ 为/ 并行程序/ 的/ 持续/ 发展/ 提供/ 技术/ 支撑/ ./ 3.1/ 相关/ 技术/ 与/ 确定性/ 并行/ 技术/ 比较/ 相关/ 的/ 两种/ 技术/ 领域/ 是/ 记录/ -/ 回放/ 技术/ 和/ 数据/ 竞争/ 检测/ 技术/ ./ 这/ 三种/ 技术/ 的/ 核心/ 都/ 是/ 发现/ 并/ 控制程序/ 中/ 的/ 数据/ 竞争/ ,/ 但是/ 目标/ 和/ 侧重/ 各有不同/ ./ 数据/ 竞争/ 检测/ 技术/ 侧重于/ 发现/ 程序/ 中/ 的/ 数据/ 竞争/ ;/ 而/ 其他/ 两种/ 技术/ 则/ 侧重于/ 动态/ 地/ 消除/ 数据/ 竞争/ 所/ 引起/ 的/ 不确定性/ ./ 数据/ 竞争/ 检测/ 技术/ 通过/ 静态/ 分析/ 或者/ 动态/ 执行/ Page4/ 的/ 方式/ 发现/ 可能/ 产生/ 数据/ 竞争/ 的/ 代码/ 位置/ 并/ 报告/ 给/ 程序员/ ,/ 由/ 程序员/ 手动/ 修复/ 数据/ 竞争/ [/ 14/ -/ 19/ ]/ ./ 最新/ 的/ 研究/ 还/ 包括/ 了/ 利用/ 数据/ 竞争/ 检测/ 结果/ 自动/ 修复/ 并行/ 错误/ 的/ 技术/ [/ 20/ -/ 21/ ]/ ./ 记录/ -/ 回放/ 技术/ 通过/ 复现/ 数据/ 竞争/ 等/ 不确定性/ 事件/ 来/ 实现/ 确定性/ 执行/ ./ 记录/ -/ 回放/ 技术/ 分为/ 两步/ :/ 首先/ 针对/ 程序/ 在/ 某/ 一/ 输入/ 下/ 的/ 执行/ 进行/ 记录/ ,/ 记录/ 的/ 内容/ 包括/ 所有/ 程序执行/ 中/ 的/ 不确定性/ 事件/ ,/ 主要/ 是/ 数据/ 竞争/ 的/ 顺序/ ;/ 然后/ 在/ 回放/ 阶段/ 根据/ 所/ 记录/ 的/ 日志/ 重/ 放程序/ 的/ 执行/ ,/ 从而/ 确保/ 程序/ 在/ 回放/ 阶段/ 的/ 行为/ 和/ 记录/ 阶段/ 完全一致/ [/ 9/ ,/ 22/ -/ 26/ ]/ ./ 与/ 其他/ 两种/ 技术/ 相比/ ,/ 确定性/ 并行/ 技术/ 的/ 功能/ 更为/ 强大/ ,/ 应用/ 更为/ 广泛/ ./ 确定性/ 并行/ 技术/ 的/ 优势/ 主要/ 体现/ 在/ 以下/ 几个/ 方面/ ./ 首先/ ,/ 确定性/ 并行/ 技术支持/ 任意/ 输入/ 下/ 程序/ 的/ 自动/ 确定性/ 执行/ ,/ 应用领域/ 更为/ 广泛/ ./ 数据/ 竞争/ 检测/ 技术/ 能够/ 检测/ 和/ 自动/ 消除/ 部分/ 数据/ 竞争/ ,/ 却/ 不能/ 实现/ 确定性/ ./ 这/ 是因为/ 同步/ 竞争/ 也/ 能/ 引起/ 不确定性/ ,/ 图/ 1/ 的/ 例子/ 可以/ 证实/ 这/ 一点/ ./ 对/ 并行/ 错误/ 的/ 研究/ 同样/ 表明/ ,/ 数据/ 竞争/ 只是/ 引起/ 并行/ 错误/ 的/ 一种/ 主要/ 形式/ ,/ 而/ 不是/ 唯一/ 的/ 形式/ [/ 27/ -/ 28/ ]/ ./ 在/ 这种/ 情况/ 下/ ,/ 实现/ 程序/ 的/ 确定性/ 就/ 具有/ 更/ 重要/ 的/ 意义/ ,/ 它/ 可以/ 应用/ 于/ 程序开发/ 、/ 测试/ 和/ 调试/ 等/ 多种/ 领域/ ./ 记录/ -/ 回放/ 技术/ 虽然/ 也/ 能/ 实现/ 确定性/ ,/ 但是/ 只能/ 保证/ 程序/ 在/ 特定/ 输入/ 下/ 的/ 确定性/ ,/ 前提/ 是/ 已经/ 记录/ 了/ 程序/ 在/ 该/ 输入/ 下/ 的/ 执行/ 过程/ ./ 因此/ ,/ 虽然/ 记录/ -/ 回放/ 技术/ 对/ 程序调试/ 的/ 意义/ 明显/ ,/ 但是/ 却/ 很/ 难/ 应用/ 于/ 开发/ 和/ 测试/ 等/ 领域/ ./ 其次/ ,/ 确定性/ 并行/ 技术/ 无需/ 外部/ 日志/ 的/ 支持/ ,/ 使用方便/ ./ 确定性/ 并行/ 技术/ 实现/ 的/ 是/ 程序/ 内在/ 的/ 确定性/ ,/ 无需/ 外部/ 日志/ 的/ 支持/ ,/ 可以/ 简化/ 系统/ 的/ 部署/ 和/ 使用/ ./ 与/ 此/ 不同/ 的/ 是/ ,/ 记录/ -/ 回放/ 技术/ 依赖于/ 外部/ 日志/ ,/ 因此/ 日志/ 和/ 程序/ 必须/ 同时/ 存在/ 才能/ 保证/ 确定性/ ./ 而/ 维护/ 日志/ 还会/ 产生/ 额外/ 的/ 时间/ 和/ 空间/ 开销/ ,/ 对于/ 某些/ 系统/ 来说/ ,/ 这种/ 日志/ 开销/ 十分/ 显著/ [/ 25/ -/ 26/ ,/ 29/ ]/ ./ 最后/ ,/ 确定性/ 并行/ 技术/ 能够/ 实现/ 首次/ 确定性/ ,/ 即/ 程序/ 在/ 第一次/ 运行/ 时/ 就/ 能/ 保持/ 确定性/ ./ 而/ 记录/ -/ 回放/ 技术/ 的/ 首次/ 运行/ 即/ 记录/ 阶段/ 的/ 执行/ 是/ 不/ 确定/ 执行/ ./ 首次/ 确定性/ 使得/ 确定性/ 并行/ 技术/ 可以/ 解决/ 并行程序/ 在/ 测试/ 和/ 容错/ 等/ 应用领域/ 的/ 困难/ [/ 10/ ]/ ./ 然而/ ,/ 确定性/ 并行/ 技术/ 的/ 优势/ 并非/ 说/ 它/ 可以/ 完全/ 代替/ 其他/ 两种/ 技术/ ./ 事实上/ ,/ 确定性/ 并行/ 技术/ 和/ 其他/ 两种/ 技术/ 的/ 结合/ 会/ 产生/ 更好/ 的/ 效果/ ./ 例如/ ,/ 利用/ 数据/ 竞争/ 检测/ 技术/ 首先/ 发现/ 程序/ 中/ 的/ 数据/ 竞争/ ,/ 从而/ 减少/ 记录/ -/ 回放/ 技术/ 或者/ 确定性/ 并行/ 技术/ 的/ 运行/ 时/ 开销/ [/ 30/ ]/ ./ 3.2/ 技术/ 分类/ 根据/ 实现/ 层次/ 和/ 手段/ 的/ 不同/ ,/ 本文/ 将/ 确定性/ 并行/ 技术/ 分为/ 确定性/ 编程语言/ 、/ 确定性/ 运行/ 时/ 系统/ 、/ 确定性/ 操作系统/ 、/ 确定性/ 编程/ 模型/ 和/ 确定性/ 算法/ ./ 例如/ Jade/ 、/ StreamIt/ 和/ SHIM/ 属于/ 支持/ 确定性/ 的/ 并行/ 编程语言/ ;/ Dthreads/ 是/ 一种/ 完全/ 兼容/ POSIXpthreads/ 的/ 确定性/ 多线程/ 运行/ 时库/ [/ 6/ ]/ ;/ Determinitor/ 和/ dOS/ 则/ 属于/ 支持/ 确定性/ 的/ 操作系统/ [/ 5/ ,/ 31/ ]/ ;/ Grace/ 是/ 一种/ 面向/ 确定性/ 的/ 并行/ 编程/ 模型/ [/ 32/ ]/ ,/ Blelloch/ 等/ 人/ [/ 33/ ]/ 则/ 提出/ 了/ 利用/ 基本/ 的/ 可/ 交换/ 操作/ 构建/ 确定性/ 并行算法/ 的/ 理论/ ./ 确定性/ 并行/ 按照/ 其他/ 标准/ 也/ 有/ 不同/ 的/ 分类/ 方法/ ,/ 例如/ 按照/ 所/ 支持/ 并行/ 级别/ 的/ 不同/ 可以/ 分为/ 线程/ 级/ 确定性/ 系统/ 和/ 进程/ 级/ 确定性/ 系统/ ,/ 按照/ 是否/ 有/ 硬件/ 支持/ 的/ 标准/ 可以/ 分为/ 纯/ 软件/ 确定性/ 系统/ 和/ 硬件/ 支持/ 的/ 确定性/ 系统/ ./ 而/ 按照/ 实现/ 层次/ 分类/ 的/ 方法/ 最能体现/ 确定性/ 并行/ 系统/ 在技术上/ 的/ 差别/ ,/ 因此/ 本文/ 采用/ 了/ 这种/ 分类法/ ./ 在/ 所有/ 的/ 这些/ 确定性/ 技术/ 中/ ,/ 确定性/ 运行/ 时/ 系统/ 在/ 灵活性/ 、/ 移植性/ 、/ 兼容性/ 、/ 通用性/ 等/ 方面/ 都/ 具有/ 优势/ ,/ 是/ 确定性/ 并行/ 领域/ 最/ 重要/ 的/ 一个/ 研究/ 分支/ ./ 确定性/ 运行/ 时/ 系统/ 是/ 指以/ 编译器/ 加/ 运行/ 时库/ 的/ 方式/ 实现/ 的/ 确定性/ 并行/ 系统/ ./ 确定性/ 运行/ 时/ 系统/ 简单/ 易用/ ,/ 只/ 需要/ 将/ 原来/ 的/ 并行程序/ 重新/ 编译/ 和/ 链接/ (/ 个别/ 系统/ 只/ 需要/ 重新/ 链接/ )/ 即可/ ,/ 可以/ 较/ 好/ 地/ 兼容/ 现有/ 并行程序/ ./ 确定性/ 运行/ 时/ 系统/ 部署/ 在/ 操作系统/ 和/ 应用程序/ 之间/ ,/ 因此/ 又/ 具有/ 较/ 好/ 的/ 移植性/ ./ 目前/ 确定性/ 运行/ 时/ 系统/ 是/ 确定性/ 并行/ 系统/ 的/ 主流/ 实现/ 方式/ ./ 3.3/ 技术/ 对比/ 本节/ 从/ 性能/ 、/ 确定性/ 、/ 可扩展性/ 、/ 兼容性/ 、/ 稳定性/ 和/ 可移植性/ 等/ 方面/ 对/ 现有/ 的/ 主流/ 确定性/ 技术/ 进行/ 对比/ ./ 注意/ ,/ 这里/ 的/ 稳定性/ 是/ 指/ 系统/ 抵御/ 代码/ 或者/ 输入/ 的/ 微小/ 变化/ 对/ 确定性/ 扰动/ 的/ 能力/ [/ 34/ -/ 35/ ]/ ./ 为了/ 能够/ 直观/ 的/ 比较/ 各种/ 确定性/ 技术/ ,/ 我们/ 采取/ 了/ 量化/ 评分/ 的/ 方式/ ./ 首先/ 我们/ 假设/ 存在/ 理想/ 的/ 确定性/ 系统/ ,/ 它/ 必须/ 在/ 性能/ 和/ 可扩展性/ 方面/ 接近/ 非/ 确定性/ 并行/ 实现/ (/ 例如/ 接近/ pthreads/ 库/ 的/ 性能/ )/ ;/ 在/ 确定性/ 方面/ 必须/ 能够/ 实现/ 执行/ 流程/ 和/ 结果/ 的/ 完全一致/ ;/ 在/ 兼容性/ 方面/ ,/ 必须/ 能够/ 保证/ 在/ 不/ 修改/ 程序代码/ 的/ 情况/ 下/ 完全/ 兼容/ 现有/ 并行程序/ ;/ 在/ 稳定性/ 方面/ ,/ 其/ 确定性/ 不/ 受/ 代码/ 或者/ 输入/ 微小/ 扰动/ 的/ 影响/ ;/ 在/ 可移植性/ 方面/ ,/ 必须/ 能够/ 保证/ 确定性/ 在/ 各种/ 硬件平台/ 和/ 操作系统/ 之间/ 能够/ 方便/ 地/ 移植/ ./ 我们/ 以/ 理想/ 的/ 确定性/ 系统/ 为/ 基准/ ,/ 对/ 上述/ 每个/ 指标/ 进行/ 量化/ 评分/ (/ 评分/ 数值/ 为/ 离散/ 的/ 1/ ,/ 2/ ,/ 3/ )/ ./ 如/ Page5/ 果/ 确定性/ 系统/ 在/ 某个/ 指标/ 上/ 达到/ 或/ 接近/ 理想/ 确定性/ 系统/ 的/ 标准/ ,/ 则/ 其/ 在/ 这个/ 指标/ 上/ 的/ 量化/ 评分/ 为/ 3/ 分/ ./ 如果/ 确定性/ 系统/ 在/ 某个/ 指标/ 上/ 完全/ 没有/ 达到/ 要求/ ,/ 则/ 其/ 量化/ 评分/ 为/ 1/ 分/ ./ 而/ 如果/ 确定性/ 系统/ 在/ 某个/ 指标/ 上/ 部分/ 达到/ 了/ 要求/ ,/ 其/ 量化/ 评分/ 就/ 为/ 2/ 分/ ./ 在/ 这个/ 表/ 1/ 主流/ 确定性/ 并行/ 系统/ 的/ 分类/ 和/ 量化/ 比较/ 确定性/ 系统/ DMPKendoCoreDetRCDCDthreads/ 运行/ 时/ 系统/ dOSClavinDeterminitor/ 操作系统/ TernPeregrine/ 运行/ 时/ 系统/ DDOSFPDetDMPIRFDetpthreads/ 运行/ 时/ 系统/ 注意/ ,/ 表/ 1/ 的/ 主要/ 作用/ 是/ 对比/ 各种/ 确定性/ 系统/ ,/ 方便/ 发现/ 系统/ 的/ 问题/ ,/ 其中/ 的/ 量化/ 评分/ 并/ 不/ 具有/ 绝对/ 意义/ ./ 随着/ 技术/ 的/ 改进/ ,/ 一个/ 原本/ 接近/ 理想/ 标准/ 的/ 系统/ 也/ 可能/ 变为/ 完全/ 没有/ 达到/ 理想/ 标准/ ./ 因此/ ,/ 这些/ 评分/ 只有/ 在/ 当前/ 技术/ 条件/ 下/ 比较/ 同/ 类型/ 的/ 确定性/ 系统/ 时才/ 有/ 意义/ ./ 另外/ ,/ 如/ 无/ 特殊/ 说明/ ,/ 表中/ 的/ 性能/ 评分/ 都/ 是/ 针对/ 算法/ 的/ 软件/ 实现/ ,/ 例如/ DMP/ 算法/ 就/ 存在/ 软件/ 和/ 硬件/ 两种/ 实现/ 方式/ ./ 而/ Calvin/ 系统/ 只有/ 硬件/ 实现/ 方式/ ,/ 因此/ 表/ 1/ 中/ 只有/ 它/ 的/ 性能/ 评分/ 是/ 针对/ 硬件/ 实现/ ./ 表/ 1/ 中带/ 星号/ 的/ 数据表示/ 确定性/ 系统/ 在/ 某个/ 指标/ 上/ 达到/ 该/ 评分/ 时受/ 某些/ 非/ 关键因素/ 影响/ ./ 例如/ Kendo/ 的/ 可移植性/ 受/ 硬件/ 性能/ 计数器/ 的/ 影响/ ;/ 而/ CoreDet/ 和/ RCDC/ 的/ 兼容性/ 可能/ 会/ 受到/ 弱/ 内存/ 一致性/ 的/ 影响/ ;/ Cavlin/ 由于/ 采用/ 硬件/ 实现/ ,/ 一般/ 只能/ 保证/ 整个/ 系统/ 的/ 确定性/ ,/ 而/ 人们/ 一般/ 更加/ 关注/ 单个/ 程序/ 的/ 确定性/ ;/ Tern/ 和/ Peregrine/ 的/ 可移植性/ 受/ 所/ 记录/ 的/ 线程/ 调度/ 的/ 影响/ ,/ 如果/ 新/ 平台/ 缺乏/ 原先/ 记录/ 的/ 线程/ 调用/ ,/ 将/ 不/ 能够/ 按照/ 原来/ 的/ 确定性/ 运行/ 程序/ ./ 从/ 以上/ 对比/ 可以/ 看出/ ,/ 目前/ 确定性/ 系统/ 或多或少/ 都/ 存在/ 一些/ 问题/ ,/ 尤其/ 是/ 在/ 性能/ 方面/ ./ 对于/ 通用/ 确定性/ 系统/ 来说/ ,/ 目前/ 还/ 不/ 存在/ 真实/ 的/ 硬件/ 实现/ ,/ 纯/ 软件/ 实现/ 的/ 方法/ 性能/ 开销/ 又/ 非常/ 大/ ./ 此外/ ,/ 确定性/ 并行/ 技术/ 的/ 研究/ 对于/ 进程/ 级/ 并行/ 的/ 支持/ 还/ 不够/ ./ 针对/ 这些/ 问题/ ,/ 我们/ 基于/ 现有/ 工作/ 对/ 确定性/ 技术/ 做/ 了/ 一些/ 标准/ 上/ ,/ 我们/ 根据/ 文献/ 中/ 报告/ 的/ 数据/ 对/ 现有/ 的/ 主流/ 确定性/ 系统/ 进行/ 了/ 评分/ ,/ 结果/ 如表/ 1/ 所示/ ./ 其中/ pthreads/ 为/ 标准/ 的/ POSIX/ 线程/ 库/ ,/ 它/ 除了/ 不/ 具有/ 确定性/ 之外/ ,/ 其他/ 方面/ 都/ 是/ 线程/ 级/ 确定性/ 并行/ 系统/ 的/ 理想/ 标准/ ./ 确定性/ 性能/ 可扩展性/ 兼容性/ 稳定性/ 可移植性/ 311313232323/ / 3123/ / 133123/ / 133222333/ / 33311332131222333/ / 322333/ / 311313232323332223133333/ 研究/ 和/ 优化/ ,/ 表/ 1/ 中/ 加粗/ 的/ 三项/ 是/ 我们/ 的/ 研究成果/ ./ 从/ 整体/ 上/ 讲/ ,/ 目前/ 确定性/ 并行/ 技术/ 离/ 实用化/ 还/ 存在/ 差距/ ,/ 需要/ 做/ 更加/ 深入/ 的/ 研究/ ./ 4/ 确定性/ 技术/ 分析/ 本/ 节/ 我们/ 通过/ 介绍/ 几种/ 主流/ 的/ 确定性/ 并行/ 方法/ ,/ 深入/ 讨论/ 确定性/ 并行/ 技术/ 的/ 实现/ 细节/ ,/ 分析/ 这些/ 技术/ 的/ 特点/ 和/ 不足/ ,/ 在/ 此基础/ 上/ 分析/ 弱/ 内存/ 一致性/ 对/ 确定性/ 技术/ 的/ 影响/ ./ 4.1/ 轮转/ 法/ Devietti/ 等/ 人/ 最早/ 提出/ 了/ 一种/ 轮转/ 法来/ 实现/ 通用/ 多线程/ 程序/ 的/ 确定性/ ,/ 称之为/ DMP/ [/ 1/ ]/ 算法/ (/ DeterministicMultiprocessing/ )/ ./ DMP/ 算法/ 按照/ 执行/ 指令/ 数将/ 程序执行/ 分成/ “/ 轮/ ”/ ,/ 每/ 一轮/ 每个/ 线程/ 只/ 允许/ 执行/ 一定/ 数量/ 的/ 指令/ ,/ 指令/ 执行/ 完则/ 该轮/ 结束/ ./ 一轮/ 执行/ 又/ 可以/ 分为/ 并行/ 阶段/ 和/ 串行/ 阶段/ ,/ 在/ 每/ 一轮/ 开始/ 时/ ,/ 程序/ 首先/ 进入/ 并行/ 阶段/ ./ 这时/ 只要/ 线程/ 之间/ 的/ 访存/ 不/ 发生冲突/ ,/ 就/ 可以/ 一直/ 执行/ 到/ 该轮/ 结束/ ;/ 一旦/ 检测/ 到/ 线程/ 的/ 访存/ 与/ 其他/ 线程/ 发生冲突/ ,/ 则/ 强制/ 线程/ 暂停/ 执行/ ,/ 等待/ 进入/ 串行/ 阶段/ 解决/ 访存/ 冲突/ ./ 当/ 所有/ 线程/ 都/ 因为/ 发生/ 访存/ 冲突/ 或者/ 执行/ 完/ 该轮/ 的/ 指令/ 数而/ 暂停/ 时/ ,/ 程序/ 就/ 会/ 进入/ 串行/ 执行/ 阶段/ ./ 在/ 串行/ 阶段/ 线程/ 根据/ ID/ 号/ 的/ 顺序/ 依次/ 轮流/ 执行/ ./ 由于/ 并行/ 阶段/ 不/ 存在/ 访存/ 冲突/ ,/ 而/ 串行/ 阶段/ 线程/ 按照/ 确定/ Page6/ 的/ 顺序/ 执行/ ,/ 于是/ 就/ 以/ 确定/ 的/ 方式/ 解决/ 了/ 原本/ 的/ 访存/ 冲突/ ,/ 消除/ 了/ 不确定性/ ./ 为了/ 检测/ 访存/ 冲突/ ,/ DMP/ 将/ 程序/ 内存/ 以/ “/ 块/ ”/ 为/ 粒度/ 进行/ 划分/ ,/ 每/ 一块/ 设置/ 一个/ 拥有权/ 标志/ 位/ ,/ 标记/ 当前/ 拥有/ 该/ 内存/ 块/ 的/ 线程/ ./ 在/ 每/ 一轮/ 的/ 并行执行/ 中/ ,/ 线程/ 只能/ 根据/ 内存/ 块/ 的/ 拥有权/ 标记/ 来/ 访问/ 内存/ :/ 当/ 线程/ 拥有/ 内存/ 块/ 时/ ,/ 该/ 线程/ 就/ 可以/ 对/ 该/ 内存/ 块/ 进行/ 读写访问/ ,/ 其他/ 线程/ 不能/ 对/ 该/ 内存/ 块/ 进行/ 读写操作/ ;/ 当/ 内存/ 块/ 不/ 被/ 任何/ 线程/ 拥有/ 时/ (/ 内存/ 块/ 的/ 状态/ 为/ 共享/ 态/ )/ ,/ 任何/ 线程/ 可以/ 对/ 该/ 内存/ 块/ 进行/ 读/ 操作/ ,/ 而/ 不能/ 写/ ./ 内存/ 块/ 的/ 状态/ 在/ 并行/ 阶段/ 中/ 不会/ 发生/ 改变/ ,/ 直到/ 程序/ 进入/ 串行/ 阶段/ ./ 进入/ 串行/ 阶段/ 后/ ,/ 由于/ 每次/ 只有/ 一个/ 线程/ 对/ 内存/ 进行/ 独占/ 访问/ ,/ 当前/ 执行/ 的/ 线程/ 就/ 可以/ 访问/ 任何/ 内存/ 块/ ,/ 同时/ 根据/ 访存/ 指令/ 修改/ 内存/ 块/ 的/ 状态/ :/ 当/ 线程/ 写/ 内存/ 块/ 时/ ,/ 内存/ 块/ 变为/ 独占/ 状态/ ,/ 并/ 归/ 该/ 线程/ 拥有/ ,/ 以/ 方便/ 后续/ 该/ 线程/ 对于/ 内存/ 块/ 的/ 读写/ ;/ 当/ 线程/ 读/ 内存/ 块/ 时/ ,/ 内存/ 块/ 的/ 状态/ 变为/ 共享/ 态/ ,/ 以/ 方便/ 其他/ 线程/ 后续/ 对/ 该/ 内存/ 块/ 的/ 读/ ./ DMP/ 算法/ 虽然/ 能够/ 保证/ 确定性/ ,/ 但是/ 其/ 串行/ 执行/ 的/ 方法/ 却/ 损失/ 了/ 并行度/ ./ 一种/ 极端/ 的/ 情况/ 是/ 线程/ 因为/ 一条/ 访存/ 冲突/ 指令/ 进入/ 串行/ 阶段/ ,/ 但是/ 串行/ 阶段/ 执行/ 的/ 其他/ 指令/ 都/ 不/ 发生/ 访存/ 冲突/ ./ 因此/ ,/ 纯/ 软件/ 的/ DMP/ 实现/ 有/ 2/ ~/ 10/ 倍/ 的/ 开销/ ./ 针对/ 这/ 一点/ 我们/ 对/ DMP/ 算法/ 进行/ 了/ 改进/ ,/ 实现/ 了/ 全/ 并行/ 的/ 确定性/ 多线程/ 算法/ FPDet/ [/ 35/ ]/ ./ FPDet/ 仍/ 采用/ 轮转/ 法/ 执行/ 多线程/ 程序/ ,/ 但是/ 和/ DMP/ 算法/ 不同/ ,/ 当/ 发生/ 访存/ 冲突/ 时/ FPDet/ 算法/ 并/ 不/ 强制/ 程序/ 进入/ 串行/ 阶段/ ,/ 而是/ 通过/ 在线/ 程/ 之间/ 交换/ 内存/ 块/ 的/ 拥有权/ 来/ 解决/ 访存/ 冲突/ ,/ 从而/ 使/ 没有/ 发生/ 访存/ 冲突/ 的/ 指令/ 可以/ 尽可能/ 的/ 并行执行/ ./ 这种/ 方法/ 在/ 一定/ 程度/ 上/ 提升/ 了/ DMP/ 算法/ 的/ 性能/ ,/ 但/ 性能/ 开销/ 仍然/ 有/ 2/ ~/ 8/ 倍/ [/ 1/ ,/ 6/ ]/ ./ DMP/ 算法/ 和/ FPDet/ 算法/ 都/ 实现/ 了/ 强/ 确定性/ 和/ 顺序/ 一致性/ ./ 顺序/ 一致性/ 使/ 它们/ 能够/ 很/ 好/ 地/ 兼容/ 已有/ 程序/ ,/ 运行/ 时/ 系统/ 的/ 实现/ 方式/ 使/ 其/ 具有/ 可移植性/ ./ 然而/ ,/ 由于/ 需要/ 监控/ 每条/ 访存/ 指令/ ,/ 这/ 两种/ 算法/ 的/ 性能/ 和/ 可扩展性/ 都/ 比较/ 差/ ./ DMP/ 和/ FPDet/ 算法/ 都/ 需要/ 静态/ 配置/ 两个/ 基本/ 的/ 参数/ :/ 即轮/ 长度/ R/ 和/ 内存/ 块/ 大小/ B/ ./ 轮/ 长度/ 以/ 指令/ 数为/ 计量单位/ ,/ 程序执行/ R/ 条/ 指令/ 为/ 一轮/ ./ 由于/ 这/ 两个/ 静态/ 配置/ 参数/ 的/ 影响/ ,/ 这/ 两种/ 算法/ 都/ 不/ 具有/ 稳定性/ ./ 当/ 程序/ 的/ 指令/ 数/ 发生/ 微小/ 变化/ 时/ ,/ 例如/ 程序员/ 插入/ 一条/ printf/ 函数调用/ ,/ 就/ 会/ 导致/ printf/ 调用/ 之后/ 每/ 一轮/ 的/ 指令/ 位置/ 发生变化/ ,/ 造成/ 程序执行/ 结果/ 的/ 巨大变化/ ./ 同理/ ,/ 由于/ 内存/ 块/ 大小/ 的/ 配置/ 参数/ ,/ 在/ 输入/ 发生/ 微小/ 变化/ 时/ 同样/ 会/ 导致/ 执行/ 结果/ 的/ 巨大变化/ ./ 因此/ ,/ 静态/ 配置/ 的/ 轮/ 长度/ 和/ 数据/ 块/ 大小/ 等/ 参数/ 使/ 它们/ 实现/ 的/ 确定性/ 很难/ 抵御/ 代码/ 或者/ 输入/ 的/ 微小/ 改变/ 所/ 带来/ 的/ 扰动/ ,/ 因此/ 不/ 具有/ 稳定性/ ./ 另外/ ,/ 这/ 两个/ 算法/ 的/ 实现/ 复杂度/ 较/ 低/ ,/ 而/ 软件/ 实现/ 方法/ 对/ 访存/ 指令/ 的/ 插/ 桩/ 相对/ 于/ 算法/ 本身/ 开销/ 较大/ ,/ 因此/ 从/ 性能/ 和/ 算法/ 复杂度/ 上/ 考虑/ 这/ 两种/ 算法/ 更/ 适合/ 于/ 硬件/ 实现/ ./ 4.2/ 弱/ 确定性/ 算法/ 经典/ 轮转/ 法/ 的/ 性能/ 问题/ 很大/ 程度/ 上/ 是/ 由/ 处理/ 数据/ 竞争/ 引起/ 的/ ./ Olszewski/ 等/ 人/ [/ 3/ ]/ 从/ 另/ 一个/ 角度/ 出发/ ,/ 假设/ 程序/ 中/ 不/ 存在/ 数据/ 竞争/ ,/ 于是/ 提出/ 了/ 弱/ 确定性/ 的/ 概念/ ./ 所谓/ 弱/ 确定性/ 是/ 指/ 系统/ 只/ 保证/ 程序/ 同步/ 语句/ 的/ 执行/ 顺序/ 是/ 具有/ 确定性/ 的/ ./ 为了/ 实现/ 弱/ 确定性/ ,/ Olszewski/ 等/ 人/ 设计/ 了/ Kendo/ 算法/ ./ 算法/ 的/ 思想/ 是/ 利用/ 逻辑/ 时钟/ 来/ 对/ 线程/ 的/ 加锁/ 机会/ 排序/ ,/ 由于/ 逻辑/ 时钟/ 的/ 快慢/ 仅/ 依赖于/ 程序代码/ 执行/ 的/ 数量/ ,/ 因此/ 能够/ 保证/ 程序/ 加锁/ 顺序/ 是/ 确定/ 的/ ,/ 而/ 这/ 等价/ 于/ 程序/ 同步/ 语句/ 的/ 执行/ 顺序/ 是/ 确定/ 的/ ./ Kendo/ 算法/ 的/ 关键问题/ 是/ 弱/ 确定性/ 的/ 基本/ 假设/ 在/ 实际/ 情况/ 中/ 很/ 难/ 成立/ ./ 由于/ 各种/ 原因/ (/ 程序员/ 的/ 疏忽/ 等/ )/ ,/ 绝大多数/ 多线程/ 程序/ 都/ 存在/ 数据/ 竞争/ ,/ 对于/ 这些/ 程序/ ,/ Kendo/ 算法/ 不能/ 直接/ 保证/ 其/ 确定性/ ,/ 而是/ 必须/ 要求/ 程序员/ 首先/ 对/ 所有/ 的/ 数据/ 竞争/ 代码/ 进行/ 加锁/ ,/ 将/ 数据/ 竞争/ 转换/ 为/ 同步/ 竞争/ ,/ 这样/ 才能/ 保证/ 确定性/ ./ 然而/ 精确/ 的/ 定位/ 和/ 消除/ 程序/ 中/ 的/ 数据/ 竞争/ 本身/ 就是/ 一件/ 非常/ 困难/ 的/ 事情/ ,/ 现有/ 的/ 数据/ 竞争/ 检测工具/ 无法/ 完全/ 解决/ 误报/ 和/ 漏报/ 的/ 问题/ [/ 36/ -/ 37/ ]/ ./ Kendo/ 通过/ 牺牲/ 一部分/ 确定性/ 来/ 换取/ 性能/ 的/ 提升/ ./ 实验/ 显示/ ,/ 它/ 的/ 性能/ 开销/ 只有/ 不到/ 16/ %/ [/ 3/ ]/ ./ Kendo/ 算法/ 之所以/ 能够/ 提升/ 性能/ ,/ 主要/ 是因为/ 在/ 弱/ 确定性/ 的/ 需求/ 下/ 系统/ 无需/ 控制/ 每条/ 访存/ 指令/ ,/ 而/ 只/ 需/ 处理/ 同步/ 语句/ 即可/ ./ 由于/ 同步/ 语句/ 的/ 数量/ 相对/ 于/ 普通/ 访存/ 指令/ 的/ 数量/ 要少/ 很多/ ,/ 因此/ 会/ 极大/ 地/ 降低/ 开销/ ./ 除此之外/ ,/ Kendo/ 算法/ 不/ 改变/ 原有/ 程序/ 的/ 内存/ 一致性/ 模型/ ,/ 因此/ 能够/ 很/ 好/ 地/ 兼容/ 已有/ 程序/ ./ Kendo/ 算法/ 的/ 可扩展性/ 受限于/ 线程/ 对/ 逻辑/ 时钟/ 的/ 等待/ ,/ 即/ 每次/ 同步操作/ 都/ 要/ 等待/ 线程/ 的/ 逻辑/ 时钟/ 变为/ 最小/ ,/ 任何/ 线程/ 的/ 延迟/ 都/ 会/ 导致/ 等待时间/ 的/ 加长/ ,/ 在线/ 程数/ 增加/ 时/ 这种/ 等待/ 开销/ 会/ 急剧/ 增加/ ./ 利用/ 硬件/ 性能/ 计数器/ 来/ 实现/ 逻辑/ 时钟/ 使得/ Kendo/ 算法/ 的/ 稳定性/ 和/ 移植性/ 都/ 受到/ 一定/ 的/ 影响/ [/ 38/ ]/ ./ 类似/ 实现/ 弱/ 确定性/ 的/ 系统/ 还/ 包括/ Tern/ ./ 由于/ Tern/ 系统/ 的/ 特点/ 是/ 实现/ 了/ 稳定性/ ,/ 因此/ 我们/ 将/ 在/ 4.6/ 节/ 重点/ 介绍/ ./ 4.3/ 弱化/ 内存/ 一致性/ 为了/ 解决/ 确定性/ 技术/ 的/ 性能/ 问题/ ,/ 学术界/ 提出/ 了/ Page7/ 通过/ 弱化/ 内存/ 一致性/ 来/ 提升/ 并行度/ 的/ 方法/ ./ Bergan/ 等/ 人/ 在/ DMP/ 算法/ 的/ 基础/ 上/ 做/ 了/ 进一步/ 改进/ ,/ 实现/ 了/ CoreDet/ [/ 2/ ]/ 和/ RCDC/ [/ 39/ ]/ 确定性/ 系统/ ./ CoreDet/ 系统/ 首次/ 使用/ 了/ TotalStoreOrder/ (/ TSO/ )/ 弱/ 内存/ 一致性/ 模型/ 来/ 优化/ 确定性/ 系统/ 的/ 性能/ ./ CoreDet/ 使用/ 和/ DMP/ 同样/ 的/ 方法/ 将/ 程序执行/ 分轮/ ,/ 每/ 一轮/ 执行/ 一定/ 数量/ 的/ 指令/ ./ 不同/ 的/ 是/ ,/ 在/ 每/ 一轮/ 中/ 每个/ 线程/ 都/ 工作/ 在/ 共享内存/ 的/ 本地/ 副本/ 中/ ./ 确切/ 地说/ ,/ 当/ 一个/ 线程/ 需要/ 写/ 一块/ 共享内存/ 时/ ,/ 系统/ 首先/ 为/ 该/ 线程/ 创建/ 这个/ 内存/ 块/ 的/ 本地/ 副本/ ,/ 然后/ 将/ 内容/ 写/ 到/ 本地/ 副本/ 中/ ./ 随后/ 该/ 线程/ 对于/ 这块/ 内存/ 的/ 读写/ 都/ 在/ 本地/ 副本/ 中/ 进行/ ./ 如果/ 线程/ 只/ 对/ 内存/ 进行/ 读/ 操作/ 就/ 不/ 需要/ 创建/ 本地/ 副本/ ,/ 直接/ 在/ 共享内存/ 中/ 进行/ ./ CoreDet/ 在/ 每/ 一轮/ 结束/ 时会/ 将/ 本地/ 副本/ 中/ 的/ 内存/ 修改/ 合并/ 到/ 共享内存/ 中/ ,/ 然后/ 清除/ 本地/ 副本/ ./ 由于/ 本地/ 副本/ 的/ 机制/ ,/ 线程/ 之间/ 就/ 不会/ 存在/ R/ // W/ 和/ W/ // R/ 冲突/ ./ 而/ 所有/ 的/ W/ // W/ 型/ 访存/ 冲突/ 都/ 被/ 集中/ 在/ 每/ 一轮/ 结束/ 时/ 的/ 内存/ 修改/ 合并/ 阶段/ ./ 在/ 这个/ 阶段/ ,/ 各个/ 线程/ 依次/ 按照/ ID/ 号/ 顺序/ 合并/ 内存/ 修改/ ,/ 因此/ 也/ 可以/ 保证/ 确定性/ ./ 在/ CoreDet/ 系统/ 中/ ,/ 由于/ 使用/ 了/ TSO/ 弱/ 内存/ 一致性/ 模型/ ,/ 原本/ 需要/ 在/ 串行/ 阶段/ 执行/ 的/ 冲突/ 代码/ 可以/ 在/ 并行/ 阶段/ 执行/ ./ 因此/ 就/ 提升/ 了/ 系统/ 的/ 并行度/ ,/ 对系统/ 可扩展性/ 的/ 提升/ 有着/ 重要/ 的/ 作用/ ./ 需要/ 注意/ 的/ 是/ ,/ 在/ CoreDet/ 系统/ 中/ ,/ 每轮/ 的/ 结束/ 阶段/ 仍然/ 有/ 一小/ 段/ 串行/ 执行/ ,/ 这是/ 为了/ 执行/ 原子/ 指令/ ./ 原子/ 指令/ 由于/ 其/ 特殊性/ ,/ 必须/ 直接/ 在/ 共享内存/ 上/ 执行/ ./ 因此/ ,/ 在/ 遇到/ 原子/ 指令/ 时/ ,/ 线程/ 需要/ 提前结束/ 本轮/ 执行/ ,/ 等/ 所有/ 线程/ 提交/ 了/ 本轮/ 的/ 内存/ 修改/ 之后/ ,/ 按/ 线程/ 号/ 顺序/ 依次/ 执行/ 剩余/ 部分/ 的/ 指令/ ./ RCDC/ 在/ CoreDet/ 的/ 基础/ 之上/ 进一步/ 弱化/ 了/ 内存/ 一致性/ ./ RCDC/ 使用/ 的/ 内存/ 一致性/ 模型/ 为/ DRF/ (/ DataRaceFree/ )/ 放松/ 一致性/ 模型/ [/ 39/ ]/ ./ 在/ CoreDet/ 系统/ 中/ ,/ 所有/ 的/ 原子/ 指令/ 是/ 不能/ 并行执行/ 的/ ./ 而/ RCDC/ 观察/ 到/ ,/ 有些/ 原子/ 指令/ 是/ 可以/ 并行执行/ 的/ ./ 例如/ 两个/ 线程/ 分别/ 执行/ lockL1/ 和/ lockL2/ ,/ 由于/ 所加/ 的/ 锁/ 不同/ ,/ 因此/ 可以/ 并行执行/ 而/ 不会/ 引起/ 不确定性/ ./ RCDC/ 通过/ 追踪/ 由于/ 线程/ 同步/ 所/ 形成/ 的/ happens/ -/ before/ 关系/ ,/ 对于/ 不/ 存在/ happens/ -/ before/ 关系/ 的/ 加锁/ 操作/ 可以/ 在/ 不/ 影响/ 确定性/ 的/ 情况/ 下令/ 其/ 并行执行/ ./ CoreDet/ 和/ RCDC/ 算法/ 通过/ 弱化/ 内存/ 一致性/ 来/ 提升/ 并行度/ ,/ 其/ 优点/ 是/ 具有/ 强/ 确定性/ 、/ 较/ 好/ 的/ 可扩展性/ 和/ 较/ 好/ 的/ 可移植性/ ./ 但是/ 弱化/ 内存/ 一致性/ 可能/ 导致/ 兼容性问题/ ./ 如果/ 原本/ 程序/ 的/ 正确性/ 是/ 建立/ 在/ 顺序/ 一致性/ 的/ 基础/ 上/ ,/ 那么/ 弱化/ 内存/ 一致性/ 将/ 可能/ 导致/ 程序/ 不能/ 正确/ 运行/ ./ 在/ 性能/ 方面/ ,/ 由于/ 没有/ 改变/ 轮转/ 法/ 使用/ 编译/ 插桩/ 的/ 实现/ 方式/ ,/ 这/ 两种/ 方法/ 的/ 性能/ 几乎/ 没有/ 提升/ ,/ 仍然/ 有/ 2/ ~/ 8/ 倍/ 的/ 性能/ 开销/ [/ 2/ ]/ ./ 同时/ 这/ 两个/ 系统/ 采用/ 了/ 和/ DMP/ 算法/ 同样/ 的/ 指令/ 分轮/ 和/ 内存/ 分块/ 方法/ ,/ 因此/ 稳定性/ 也/ 没有/ 改善/ [/ 34/ ]/ ./ Calvin/ [/ 7/ ]/ 同样/ 采用/ 了/ TSO/ 弱/ 内存/ 一致性/ ,/ 从/ 算法/ 上/ 来讲/ 和/ CoreDet/ 算法/ 一致/ ,/ 但是/ 完全/ 基于/ 硬件/ 实现/ ./ 因此/ 其/ 确定性/ 、/ 性能/ 、/ 可扩展性/ 都/ 比较/ 好/ ./ 由于/ 需要/ 特殊/ 的/ 硬件/ 支持/ ,/ 因此/ 它/ 存在/ 比较严重/ 的/ 兼容性问题/ ,/ 即/ 不能/ 兼容/ 已有/ 的/ 二进制/ 程序/ ;/ 另一方面/ ,/ 如果/ 有/ 编译器/ 的/ 支持/ ,/ Calvin/ 系统/ 可以/ 兼容/ 具有/ 源码/ 的/ 程序/ ./ Calvin/ 系统/ 的/ 不足/ 是/ 稳定性/ (/ 仍然/ 由轮/ 长度/ 等/ 参数/ 引起/ )/ 和/ 可移植性/ 较差/ ,/ 在/ 没有/ 商用/ 硬件/ 的/ 情况/ 下/ 这种/ 可移植性/ 问题/ 尤为/ 严重/ ./ 4.4/ 隔离/ 通信/ 法/ Liu/ 等/ 人/ [/ 6/ ]/ 通过/ 完全/ 隔离线/ 程/ 通信/ 的/ 方法/ 开发/ 了/ Dthreads/ 确定性/ 系统/ ./ Dthreads/ 突破/ 了/ 纯/ 软件/ 确定性/ 系统/ 实现/ 手段/ 的/ 瓶颈/ ,/ 通过/ 完全/ 隔离线/ 程/ 的/ 内存空间/ ,/ 有效/ 化解/ 了/ CoreDet/ 系统/ 的/ 编译/ 插桩/ 开销/ ,/ 并/ 成为/ 一段时间/ 内/ 最/ 高效/ 的/ 纯/ 软件/ 确定性/ 系统/ [/ 6/ ]/ ./ 与/ CoreDet/ 等/ 系统/ 采用/ 编译/ 插桩/ 控制/ 访存/ 冲突/ 不同/ 的/ 是/ ,/ Dthreads/ 采用/ 了/ 页面/ 保护/ 机制/ 来/ 隔离线/ 程/ 内存空间/ ,/ 从而/ 消除/ 访存/ 冲突/ ./ 首先/ ,/ Dthreads/ 将/ 多线程/ 程序/ 的/ 线程/ 全部/ 转换/ 为/ 轻量级/ 进程/ ,/ 这样/ 每个/ 线程/ 就/ 可以/ 拥有/ 独立/ 的/ 页表/ ,/ 从而/ 实现/ 对/ 共享内存/ 不同/ 的/ 访问/ 权限/ ./ 其次/ ,/ Dthreads/ 在线/ 程/ 首次/ 修改/ 共享内存/ 时/ 做/ Copy/ -/ on/ -/ Write/ ,/ 为/ 每个/ 线程/ 生成/ 共享内存/ 的/ 本地/ 副本/ ,/ 从而/ 避免/ 直接/ 的/ 访存/ 冲突/ ./ 这些/ 副本/ 以/ 页面/ 为/ 单位/ 组织/ ,/ 称为/ 双胞胎/ 页面/ (/ Twin/ -/ Page/ )/ ./ 在/ 每次/ 需要/ 将/ 本地/ 内存/ 修改/ 提交/ 到/ 共享内存/ 时/ ,/ 通过/ 逐字/ 节/ 比较/ 原始/ 页面/ 和/ 双胞胎/ 页面/ 就/ 可以/ 获得/ 线程/ 的/ 内存/ 修改/ ./ Dthreads/ 所/ 采用/ 的/ 这种/ 控制/ 访存/ 冲突/ 的/ 方法/ 取得/ 了/ 明显/ 的/ 性能/ 提升/ ,/ 主要/ 原因/ 是/ 它/ 消除/ 了/ 对/ 读写/ 指令/ 的/ 编译/ 插桩/ 开销/ ./ 需要/ 注意/ 的/ 是/ ,/ 与/ CoreDet/ 等/ 轮转/ 法/ 系统/ 不同/ 的/ 是/ ,/ Dthreads/ 每轮/ 的/ 长度/ 不是/ 由/ 执行/ 指令/ 数/ 决定/ 的/ ./ Dthreads/ 规定/ ,/ 线程/ 在/ 遇到/ 任何/ 一条/ 同步/ 指令/ 时/ 结束/ 当前/ 轮/ 的/ 执行/ ./ 这样/ 做/ 主要/ 是因为/ Dthreads/ 要/ 和/ POSIXpthreads/ 的/ 使用/ 接口/ 完全/ 兼容/ ,/ 因此/ 抛弃/ 了/ 编译/ 插桩/ 的/ 方法/ ./ 这样/ Dthreads/ 就/ 只/ 需要/ 重新/ 实现/ pthreads/ 库函数/ ,/ 而/ 应用程序/ 仅/ 需要/ 重新/ 链接/ Dthreads/ 库来/ 获取/ 确定性/ ./ 显然/ ,/ 这种/ 实现/ 方式/ 的/ 劣势/ 是/ 可能/ 造成/ 线程/ 之间/ 在/ 每轮/ 执行/ 中/ 的/ 负载/ 不均/ Page8/ 衡/ ./ 例如/ ,/ 如果/ 两个/ 线程/ 在/ 进入/ 下/ 一个/ 同步/ 语句/ 前/ 执行/ 的/ 指令/ 数/ 差别/ 很大/ ,/ 就/ 会/ 造成/ 其中/ 一个/ 线程/ 等待时间/ 过长/ ./ 对于/ 那些/ 具有/ 典型/ 不规则/ 同步/ 的/ 程序/ 来说/ ,/ Dthreads/ 可能/ 造成/ 较大/ 的/ 性能/ 开销/ ./ Dthreads/ 系统/ 极大/ 地/ 提升/ 了/ 纯/ 软件/ 确定性/ 系统/ 的/ 性能/ ,/ 使得/ 平均/ 性能/ 开销/ 不/ 超过/ 2/ 倍/ ,/ 但是/ 某些/ 程序/ 开销/ 仍然/ 可达/ 8/ 倍/ [/ 40/ ]/ ./ Dthreads/ 系统/ 能够/ 提升/ 性能/ 的/ 主要/ 原因/ 有/ 两/ 方面/ :/ 首先/ ,/ 它/ 采用/ 页面/ 保护/ 机制/ 来/ 隔离线/ 程/ 之间/ 的/ 访存/ 冲突/ ,/ 避免/ 了/ CoreDet/ 等/ 软件/ 算法/ 的/ 插/ 桩/ 开销/ ;/ 其次/ ,/ 它/ 的/ 指令/ 分块/ 粒度/ 较大/ ,/ 极大/ 地/ 减少/ 了/ 线程/ 间/ 的/ 全局/ 同步/ 次数/ ,/ 降低/ 了/ 同步/ 开销/ ./ Dthreads/ 同时/ 具有/ 强/ 确定性/ 、/ 稳定性/ 和/ 较/ 好/ 的/ 可移植性/ ./ Dthreads/ 系统/ 的/ 可扩展性/ 受限于/ 全局/ 同步/ 所/ 引起/ 的/ 负载/ 均衡/ 问题/ ./ 同时/ ,/ 由于/ 使用/ 了/ TSO/ 弱/ 内存/ 一致性/ 模型/ ,/ 并且/ 内存/ 一致性/ 较/ Core/ -/ Det/ 更弱/ ,/ 因此/ 导致/ 了/ 更为严重/ 的/ 兼容性问题/ ,/ 例如/ 它/ 明确/ 不/ 支持/ Adhoc/ 同步/ 方式/ [/ 6/ ]/ ./ 4.5/ 全局/ 同步/ 问题/ 以上/ 介绍/ 的/ 强/ 确定性/ 系统/ 存在/ 一个/ 共同/ 的/ 问题/ :/ 那/ 就是/ 依赖于/ 全局/ 同步/ 来/ 实现/ 确定性/ ./ 全局/ 同步/ 是/ 指/ 由/ 确定性/ 系统/ 插入/ 到/ 程序执行/ 中/ 的/ 一种/ 额外/ 的/ 同步/ 点/ ,/ 它/ 要求/ 所有/ 线程/ 在/ 这个/ 同步/ 点中/ 暂停/ 执行/ ,/ 以/ 方便/ 系统/ 处理/ 不确定性/ ./ 全局/ 同步/ 使/ 确定性/ 的/ 实现/ 变得/ 简单/ ,/ 但/ 同时/ 也/ 带来/ 了/ 性能/ 和/ 正确性/ 方面/ 的/ 问题/ ./ 全局/ 同步/ 问题/ 根源/ 在于/ 它/ 并非/ 程序/ 固有/ 的/ 同步/ 策略/ ,/ 而是/ 由/ 确定性/ 系统/ 引入/ 的/ 额外/ 的/ 同步/ 策略/ ./ 因此/ 全局/ 同步/ 是/ 没有/ 任何/ 程序/ 语义/ 的/ ,/ 它/ 的/ 存在/ 仅仅/ 是/ 为了/ 实现/ 确定性/ ,/ 和/ 线程/ 之间/ 的/ 通信/ 需求/ 毫无关系/ ./ 当/ 线程/ 本身/ 的/ 同步/ 策略/ 和/ 确定性/ 系统/ 所/ 引入/ 的/ 全局/ 同步/ 产生/ 冲突/ 时/ ,/ 就/ 有/ 可能/ 产生/ 正确性/ 和/ 性能/ 方面/ 的/ 问题/ ./ 为了/ 消除/ 全局/ 同步/ ,/ 我们/ 提出/ 了/ 一种/ DLRC/ 弱/ 内存/ 一致性/ 模型/ ,/ 并/ 在/ 此基础/ 上/ 实现/ 了/ 一种/ 免/ 全局/ 同步/ 的/ 确定性/ 并行算法/ RFDet/ [/ 40/ ]/ ./ 确定性/ 算法/ 的/ 关键/ 是/ 限制/ 数据/ 竞争/ ,/ 在/ 没有/ 全局/ 同步/ 的/ 情况/ 下/ ,/ 我们/ 必须/ 保证/ 能够/ 通过/ 程序/ 本身/ 的/ 同步/ 来/ 限制/ 数据/ 竞争/ ./ 而/ 根据/ C++/ 内存/ 一致性/ 模型/ ,/ 如果/ 两个/ 访存/ 操作/ 之间/ 具有/ happens/ -/ before/ 时序/ 关系/ ,/ 后/ 一个/ 操作/ 就/ 必须/ 能够/ 看到/ 前/ 一个/ 操作/ 对/ 内存/ 的/ 更新/ [/ 41/ ]/ ,/ 这是/ 保证/ C++/ 程序正确性/ 最/ 基本/ 的/ 内存/ 一致性/ ./ 因此/ ,/ 为了/ 限制/ 数据/ 竞争/ ,/ 我们/ 就/ 将/ 内存/ 一致性/ 弱化/ 到/ 这个/ 程度/ ,/ 并且/ 保证/ 任何/ 指令/ 仅/ 能够/ 看到/ 和/ 它/ 具有/ happens/ -/ before/ 时序/ 关系/ 并且/ 发生/ 在/ 它/ 之前/ 的/ 指令/ 对/ 内存/ 的/ 修改/ ,/ 这/ 就是/ 我们/ 提出/ 的/ DLRC/ 内存/ 一致性/ 模型/ ./ 根据/ 这个/ 模型/ ,/ 我们/ 就/ 可以/ 阻止/ 所有/ 通过/ 共享内存/ 访问/ 形成/ 的/ 线程/ 间通信/ ,/ 将/ 这些/ 通信/ 全部/ 延迟/ 到/ 线程/ 同步/ 的/ 时候/ ./ 这样一来/ ,/ 我们/ 就/ 将/ 原本/ 程序/ 中/ 的/ 数据/ 竞争/ 都/ 限制/ 在线/ 程/ 同步/ 点上/ ,/ 从而/ 可以/ 在/ 不/ 引入/ 任何/ 额外/ 同步/ 的/ 前提/ 下/ 处理/ 数据/ 竞争/ ./ DLRC/ 内存/ 一致性/ 模型/ 的/ 效果/ 是/ 数据/ 竞争/ 的/ 结果/ 仅/ 依赖于/ 同步/ 竞争/ 的/ 结果/ ,/ 因此/ 程序/ 的/ 确定性/ 仅/ 和/ 同步/ 语句/ 的/ 执行/ 顺序/ 相关/ ./ 在/ DLRC/ 内存/ 一致性/ 模型/ 的/ 基础/ 上/ ,/ 我们/ 通过/ Kendo/ 算法/ 保证/ 同步/ 语句/ 执行/ 顺序/ 的/ 确定性/ ,/ 于是/ 实现/ 了/ 一个/ 高效/ 、/ 免/ 全局/ 同步/ 的/ 确定性/ 系统/ RFDet/ ./ 实验/ 显示/ RFDet/ 的/ 性能比/ 同样/ 是/ 纯/ 软件/ 实现/ 但/ 使用/ 了/ 全局/ 同步/ 的/ Dthreads/ 性能/ 提升/ 了/ 近/ 1/ 倍/ ./ 和/ Dthreads/ 系统/ 相比/ ,/ RFDet/ 系统/ 最大/ 的/ 特点/ 是/ 消除/ 了/ 全局/ 同步/ ./ 对于/ 具有/ 不规则/ 同步/ 的/ 程序/ 来说/ ,/ Dthreads/ 方法/ 的/ 全局/ 同步/ 会/ 引起/ 线程/ 之间/ 的/ 负载/ 不/ 均衡/ ,/ 严重/ 的/ 还/ 会/ 导致/ 死锁/ ,/ 而/ RFDet/ 算法/ 由于/ 完全/ 基于/ 线程/ 原有/ 同步/ 实现/ 确定性/ ,/ 因此/ 更能/ 发挥/ 程序/ 细粒度/ 的/ 并行/ ,/ 从而/ 取得/ 更好/ 的/ 性能/ ./ RFDet/ 系统/ 实现/ 了/ 强/ 确定性/ ,/ 平均/ 性能/ 开销/ 不到/ 50/ %/ [/ 40/ ]/ ./ 此外/ 纯/ 软件/ 运行/ 时/ 系统/ 的/ 实现/ 方式/ 使/ 其/ 具有/ 可移植性/ ./ 不足之处/ 是/ RFDet/ 系统/ 增加/ 了/ 很多/ 写/ 操作/ ,/ 一定/ 程度/ 上/ 影响/ 了/ 可扩展性/ ./ 其抗/ 代码/ 扰动/ 的/ 能力/ ,/ 即/ 稳定性/ ,/ 受限于/ Kendo/ 算法/ 中/ 逻辑/ 时钟/ 受/ 代码/ 微小/ 变化/ 的/ 影响/ ./ 同样/ ,/ 因为/ 采用/ 了/ 弱/ 内存/ 一致性/ 模型/ ,/ RFDet/ 不/ 支持/ Adhoc/ 同步/ 方式/ ,/ 降低/ 了/ 兼容性/ ./ 4.6/ 稳定/ 确定性/ DMP/ 等/ 基于/ 轮转/ 法/ 的/ 确定性/ 系统/ 存在/ 一个/ 问题/ ,/ 即/ 不/ 具有/ 稳定性/ ./ 对于/ 传统/ 的/ 并行执行/ 模型/ (/ 如/ pthreads/ )/ 来说/ ,/ 当/ 输入/ 发生/ 微小/ 变化/ 时/ ,/ 只要/ 不是/ 关键/ 数据/ 的/ 改变/ ,/ 程序/ 一般/ 都/ 会/ 走/ 类似/ 的/ 执行/ 路径/ ,/ 偏差/ 不会/ 太大/ ./ 但是/ 由于/ 确定性/ 系统/ 的/ 干扰/ ,/ 程序/ 的/ 稳定性/ 可能/ 会/ 被/ 破坏/ ,/ 即当/ 程序/ 的/ 输入/ 发生/ 微小/ 变化/ 时/ ,/ 程序执行/ 路径/ 的/ 变化/ 可能/ 会/ 被/ 放大/ ,/ 造成/ 执行/ 结果/ 的/ 显著/ 变化/ [/ 42/ -/ 43/ ]/ ./ 也就是说/ 确定性/ 系统/ 在/ 保证/ 确定性/ 的/ 同时/ ,/ 可能/ 将/ 程序/ 的/ 计算/ 过程/ 变成/ 一个/ 混沌/ 系统/ ./ Yang/ 等/ 人/ 提出/ 了/ 稳定/ 确定性/ 的/ 概念/ ,/ 并/ 通过/ Tern/ 算法/ 解决/ 了/ 稳定性/ 的/ 问题/ [/ 34/ ]/ ./ Tern/ 算法/ 会/ 首先/ 对/ 程序执行/ 进行/ 记忆/ ,/ 并/ 以/ 〈/ 输入/ ,/ 调度/ 〉/ 二元/ 组/ 的/ 形式/ 存储/ 在/ 数据库/ 中/ ./ 在/ 以后/ 的/ 执行/ 中/ ,/ 系统/ 会/ 首先/ 在/ 数据库/ 中/ 依据/ 输入/ 条件/ 匹配/ 调度/ 二元/ 组/ ./ 注意/ 二元/ 组中/ 的/ 输入/ 是/ 一个/ 输入/ 条件/ ,/ 只要/ 符合/ 这个/ 输入/ 条件/ 就/ 会/ 匹配/ 上/ ,/ 因此/ 实际上/ 代表/ 了/ 一组/ 输入/ ./ 一旦/ 匹配/ 上/ ,/ 系统/ 就/ 会/ 使用/ 相应/ 的/ 调度/ 去/ 执行程序/ ./ 否/ Page9/ 则/ ,/ 系统/ 以/ 正常/ 的/ 方式/ 执行程序/ ,/ 记录/ 其/ 执行/ 路径/ 和/ 输入/ 条件/ ,/ 并/ 将/ 其/ 存放/ 到/ 数据库/ 中/ ./ 由于/ Tern/ 不/ 支持/ 数据/ 竞争/ (/ 类似/ 于/ Kendo/ )/ ,/ Peregrine/ 算法/ [/ 44/ ]/ 在/ Tern/ 算法/ 的/ 基础/ 上/ 做/ 了/ 进一步/ 改进/ ,/ 使/ 其/ 可以/ 支持/ 数据/ 竞争/ ./ Bergan/ 等/ 人/ [/ 43/ ]/ 进一步/ 将/ 调度/ 精确化/ 简/ ,/ 保证/ 能够/ 覆盖/ 到/ 所有/ 的/ 输入/ 集合/ ./ 稳定性/ 是/ 多线程/ 程序/ 应该/ 具备/ 的/ 一个/ 重要/ 特性/ [/ 42/ ]/ ,/ 然而/ 由于/ 确定性/ 系统/ 强加/ 的/ 调度/ 限制/ ,/ 程序/ 的/ 稳定性/ 被/ 破坏/ 了/ ./ Yang/ 等/ 人/ 所/ 提出/ 的/ 稳定/ 确定性/ 方法/ 从/ 一定/ 程度/ 上/ 解决/ 了/ 这个/ 问题/ ,/ 但是/ 他们/ 设计/ 的/ 系统/ 复杂度/ 太高/ ,/ 部署/ 和/ 使用/ 不/ 方便/ ,/ 其/ 致命/ 的/ 问题/ 是/ 输入/ 不能/ 匹配/ 调度/ 数据库/ 的/ 情况/ ,/ 这/ 对于/ 商用/ 软件/ 来说/ 是/ 不可/ 接受/ 的/ ./ 因此/ 未来/ 有/ 必要/ 对/ 确定性/ 系统/ 的/ 稳定性/ 做/ 进一步/ 研究/ ./ Tern/ 和/ Peregrine/ 两个/ 系统/ 最大/ 的/ 优点/ 是/ 具有/ 好/ 的/ 稳定性/ ./ 这/ 两种/ 方法/ 不/ 改变/ 原有/ 多线程/ 程序/ 的/ 调度/ 方式/ ,/ 而是/ 从/ 原有/ 多线程/ 程序/ 的/ 调度/ 集合/ 中/ 选择/ 其中/ 的/ 一部分/ 作为/ 自己/ 的/ 调度/ 集合/ ./ 由于/ 在/ 一定/ 程序/ 上/ 缩小/ 了/ 调度/ 集合/ ,/ 因此/ 这种/ 方法/ 具有/ 较/ 好/ 的/ 稳定性/ ./ 其次/ 这/ 两个/ 系统/ 采用/ 纯/ 软件/ 的/ 方法/ 实现/ ,/ 不/ 改变程序/ 原有/ 的/ 内存/ 一致性/ 模型/ ,/ 因此/ 也/ 具有/ 较/ 好/ 的/ 兼容性/ 和/ 可移植性/ ./ 在/ 性能/ 方面/ ,/ 两个/ 系统/ 在/ 输入/ 不/ 匹配/ 时/ 性能/ 开销/ 不可/ 容忍/ ,/ 可以/ 达到/ 上/ 百倍/ [/ 34/ ,/ 43/ -/ 44/ ]/ ./ 由于/ 需要/ 强制/ 线程/ 按照/ 特定/ 的/ 调度/ 执行/ ,/ 可扩展性/ 并/ 不能/ 达到/ 理想/ 标准/ ./ 另外/ ,/ Tern/ 系统/ 不/ 解决/ 数据/ 竞争/ 问题/ ,/ 因此/ 仅/ 实现/ 了/ 弱/ 确定性/ ./ 4.7/ 确定性/ 多/ 进程/ 目前/ 大多数/ 确定性/ 并行/ 方法/ 都/ 是/ 针对/ 单个/ 多线程/ 程序/ ,/ 然而/ 多/ 进程/ 程序/ 的/ 确定性/ 也/ 不容忽视/ ./ 很多/ 程序/ 都/ 会/ 采用/ 多/ 进程/ 的/ 并行/ 方式/ 来/ 提升/ 安全性/ ,/ 例如/ Apache/ 服务器/ 和/ Chrome/ 浏览器/ ./ Bergan/ 等/ 人/ [/ 31/ ]/ 设计/ 了/ dOS/ 宣布/ 支持/ 多/ 进程/ 程序/ 的/ 确定性/ ./ dOS/ 是/ 对/ Linux/ 操作系统/ 的/ 一种/ 扩展/ ,/ 它/ 可以/ 保证/ Linux/ 系统/ 上/ 一组/ 进程/ 的/ 确定性/ ./ 每/ 一个/ 确定性/ 的/ 进程/ 组/ 被/ 称为/ 一个/ DPG/ (/ DeterministicProcessGroup/ )/ ./ 由于/ 有/ 来自/ 于/ 操作系统/ 内核/ 的/ 支持/ ,/ dOS/ 可以/ 控制/ 进程/ 间通信/ ,/ 同时/ 屏蔽/ 了/ 来自/ 于/ 操作系统/ 内部/ 状态/ 变化/ 对/ 应用程序/ 的/ 影响/ ./ 进程/ 内部/ 由于/ 线程/ 竞争/ 引起/ 的/ 不确定性/ 使用/ DMP/ 算法/ 解决/ ./ 进程/ 组与/ 外部/ 其他/ 进程/ 或者/ 进程/ 组/ 的/ 通信接口/ 通过/ SHIM/ 层/ 实现/ ,/ 这个/ SHIM/ 层/ 负责/ 记录/ 外部/ 进程/ 与/ 进程/ 组/ 交互/ 时/ 产生/ 的/ 不确定性/ 事件/ ./ 这样/ 就/ 可以/ 通过/ 记录/ -/ 回放/ 技术/ 重现/ 进程/ 组/ 执行/ ./ 最近/ ,/ Bergan/ 等/ 人/ 又/ 将/ dOS/ 扩展/ ,/ 实现/ 了/ 可以/ 支持/ 分布式/ 环境/ 的/ 确定性/ 系统/ DDOS/ [/ 45/ ]/ ./ 这些/ 确定性/ 操作系统/ 功能强大/ ,/ 但/ 因为/ 实现/ 在/ 操作系统/ 级别/ ,/ 因此/ 移植性/ 较差/ ,/ 部署/ 和/ 使用/ 极/ 不/ 方便/ ./ 同时/ ,/ dOS/ 和/ DDOS/ 的/ 开销/ 问题/ 非常/ 严重/ [/ 31/ ,/ 45/ ]/ ,/ 这/ 是因为/ 一方面/ 它们/ 采用/ 了/ 开销/ 较大/ 的/ DMP/ 算法/ ,/ 另一方面/ ,/ 它们/ 并/ 没有/ 采用/ 一层/ 抽象/ 级别/ 来/ 屏蔽/ 底层/ 细节/ ,/ 因此/ 需要/ 处理/ 进程/ 之间/ 的/ 各种/ 交互/ 操作/ ,/ 带来/ 较大/ 的/ 开销/ ./ Determinitor/ 也/ 是/ 一个/ 支持/ 确定性/ 的/ 操作系统/ ,/ 它/ 采用/ 了/ 新/ 的/ 编程/ 模型/ ./ 在/ 这种/ 编程/ 模型/ 下/ ,/ 线程/ 之间/ 只能/ 通过/ 特定/ 的/ 系统/ 调用/ 进行/ 交互/ ,/ 使/ 线程/ 在/ 正常/ 执行/ 时/ 不会/ 发生/ 访存/ 冲突/ ,/ 因此/ 其/ 性能/ 较/ 好/ ./ 该/ 系统/ 另/ 一个/ 优点/ 是/ 程序/ 本身/ 已经/ 定义/ 了/ 所有/ 访存/ 操作/ 的/ 顺序/ ,/ 不/ 需要/ 外部/ 运行/ 时/ 系统/ 的/ 干预/ ,/ 因此/ 程序/ 的/ 稳定性/ 好/ ./ 然而/ 新型/ 的/ 编程/ 模型/ 导致/ 在/ 该/ 系统/ 下/ 编程/ 方式/ 的/ 改变/ ,/ 从而/ 造成/ 系统/ 完全/ 不/ 兼容/ 现有/ 的/ 多线程/ 程序/ [/ 5/ ]/ ./ 与/ 这些/ 直接/ 支持/ 确定性/ 多/ 进程/ 的/ 方法/ 不同/ ,/ 我们/ 通过/ 在/ MPI/ 编程/ 模型/ 上/ 实现/ 确定性/ 消息传递/ 技术/ (/ DMPI/ )/ 来/ 支持/ 多/ 进程/ 的/ 确定性/ [/ 8/ ]/ ./ DMPI/ 利用/ 逻辑/ 时钟/ 控制/ 消息/ 的/ 发送/ 和/ 接受/ ,/ 强制/ 异步/ 消息传递/ 操作/ 在/ 确定/ 数量/ 个/ 逻辑/ 时钟/ 之后/ 完成/ 消息/ 传输/ ,/ 同时/ 强制/ 混杂/ 消息/ 接收/ 函数/ 只/ 接收/ 具有/ 最小/ 逻辑/ 时钟/ 的/ 消息/ ,/ 最终/ 消除/ 了/ 这/ 两个/ 不确定性/ 操作/ 对/ 应用程序/ 状态/ 的/ 影响/ ./ DMPI/ 系统/ 的/ 性能/ 开销/ 主要/ 来自/ 于/ 两个/ 方面/ ,/ 一是/ 实现/ 逻辑/ 时钟/ 所/ 产生/ 的/ 插/ 桩/ 开销/ ,/ 二是/ 消息传递/ 操作/ 额外/ 的/ 等待/ 开销/ ./ 由于/ 插桩/ 粒度/ 较大/ ,/ 并且/ 消息传递/ 操作/ 相对/ 于/ 普通/ 指令/ 执行/ 数量/ 很少/ ,/ 因此/ DMPI/ 系统/ 的/ 总体/ 性能/ 开销/ 并不大/ ,/ 平均/ 性能/ 开销/ 仅/ 有/ 14/ %/ ./ 同时/ MPI/ 是/ 介于/ 操作系统/ 和/ 应用程序/ 之间/ 的/ 运行/ 时/ 系统/ ,/ 对于/ 现有/ 的/ MPI/ 程序/ 具有/ 很/ 好/ 的/ 兼容性/ 和/ 可移植性/ ./ DMPI/ 的/ 可扩展性/ 和/ 稳定性/ 都/ 受限于/ 系统对/ 逻辑/ 时钟/ 的/ 依赖/ ,/ 这/ 是因为/ 逻辑/ 时钟/ 比较/ 会/ 牵扯/ 到/ 所有/ 系统/ 中/ 的/ 进程/ ,/ 具有/ 全局/ 同步/ 的/ 特性/ ./ 而/ 逻辑/ 时钟/ 计数/ 结果/ 会/ 受到/ 指令/ 数/ 微小/ 改变/ 的/ 影响/ ./ 最后/ ,/ DMPI/ 没有/ 实现/ 强/ 确定性/ ,/ 它/ 不/ 支持/ MPI/ 中/ 一些/ 不/ 常用/ 的/ 非/ 确定性/ 操作/ ,/ 如/ 单边/ 通信/ ./ MPI/ 是/ 一种/ 通用/ 的/ 编程/ 模型/ ,/ 其/ 应用/ 十分/ 广泛/ ,/ 因此/ 对/ MPI/ 的/ 确定性/ 支持/ 具有/ 重要/ 的/ 应用/ 价值/ ./ 4.8/ 内存/ 一致性/ 和/ 确定性/ 在/ 共享内存/ 的/ 多/ 核/ 体系结构/ 中/ ,/ 内存/ 一致性/ 定义/ 了/ 内存/ 修改/ 可见/ 性/ 的/ 延迟/ 程度/ ./ Lamport/ 最早/ 给出/ 了/ 顺序/ 一致性/ 的/ 定义/ :/ 并行程序/ 的/ 执行/ 结果/ 等价/ 于/ 某种/ 串行/ 执行/ 方式/ 的/ 结果/ ,/ 并且/ 对于/ 每个/ 执行/ 单/ Page10/ 位/ (/ 线程/ )/ 来说/ ,/ 其/ 执行/ 指令/ 的/ 顺序/ 和/ 串行/ 等价/ 执行/ 中/ 这些/ 指令/ 的/ 顺序/ 完全一致/ [/ 46/ ]/ ./ 如果/ 用/ 内存/ 修改/ 的/ 可见/ 性来/ 解释/ ,/ 顺序/ 一致性/ 等价/ 于/ 线程/ 对/ 内存/ 的/ 修改/ 会/ 对/ 所有/ 其他/ 线程/ 立即/ 可见/ ./ 顺序/ 一致性/ 是/ 最/ 直接/ 的/ 一种/ 内存/ 一致性/ 模型/ ,/ 也/ 是/ 程序员/ 最/ 容易接受/ 的/ 内存/ 一致性/ 模型/ ./ 然而/ 顺序/ 一致性/ 要求/ 每个/ 访存/ 指令/ 都/ 必须/ 等待/ 前/ 一个/ 访存/ 指令/ 到达/ 主存/ 后/ 才能/ 开始/ ,/ 因此/ 其/ 性能/ 较/ 低/ ./ 为了/ 优化/ 访存/ 性能/ ,/ 现代/ 体系结构/ 一般/ 通过/ 弱化/ 顺序/ 一致性/ 来/ 提升/ 性能/ ./ 常用/ 的/ 内存/ 一致性/ 模型/ 包括/ TSO/ (/ TotalStoreOrder/ )/ 、/ PSO/ (/ PartialStoreOrder/ )/ 、/ RC/ (/ ReleaseConsistency/ )/ 和/ LRC/ (/ LazyReleaseConsistency/ )/ 等/ ./ 弱/ 内存/ 一致性/ 通过/ 延迟线/ 程写/ 操作/ 对/ 其他/ 线程/ 的/ 可见/ 性来/ 提升/ 性能/ ./ 在/ TSO/ 模型/ 中/ ,/ 本地/ CPU/ 核所/ 写入/ 的/ 值/ 存放/ 在/ 一个/ 写/ 缓冲区/ 中/ ,/ 写/ 缓冲区/ 中/ 的/ 值/ 对/ 远端/ CPU/ 核是/ 不/ 可见/ 的/ ,/ 只有/ 当写/ 缓冲区/ 满/ 或者/ 程序执行/ 了/ fence/ 指令/ 后写/ 缓冲区/ 中/ 的/ 值/ 才/ 会/ 被/ 写入/ 到/ 主存/ 中/ ,/ 这时/ 其他/ CPU/ 核才/ 可以/ 看到/ 这些/ 值/ ./ 内存/ 一致性/ 对/ 确定性/ 技术/ 有着/ 重要/ 影响/ ./ 首先/ ,/ 弱/ 内存/ 一致性/ 能够/ 有效/ 地/ 减少/ 线程/ 间/ 的/ 访存/ 冲突/ ,/ 而/ 确定性/ 系统/ 的/ 开销/ 主要/ 来自/ 于/ 处理/ 线程/ 间/ 的/ 访存/ 冲突/ ,/ 因此/ 弱/ 一致性/ 可以/ 降低/ 确定性/ 系统/ 的/ 开销/ ./ 例如/ 在/ 顺序/ 一致性/ 模型/ 下/ ,/ 一个/ 线程/ 的/ 写/ 操作/ W/ 是/ 立即/ 可见/ 的/ ,/ 因此/ 就/ 会/ 和/ 其他/ 线程/ 对于/ 同一个/ 内存/ 位置/ 的/ 读/ R/ 或者/ 写/ W/ 发生冲突/ ,/ 引起/ 不确定性/ ./ 正是/ 因为/ 这样/ ,/ DMP/ 等/ 算法/ 必须/ 控制/ 每/ 一个/ 访存/ 操作/ ,/ 安排/ 这些/ 访存/ 操作/ 的/ 执行/ 顺序/ ,/ 避免/ 不确定性/ 的/ 发生/ ./ 然而/ 同样/ 的/ 代码/ 在/ TSO/ 模型/ 下/ 就/ 会/ 有所不同/ ,/ 由于/ 线程/ 的/ 写/ W/ 并/ 不是/ 立即/ 可见/ 的/ ,/ 因此/ 即便/ 其他/ 线程/ 有/ 对/ 同一个/ 内存/ 的/ 读/ R/ 或者/ 写/ W/ ,/ 它们/ 之间/ 也/ 不会/ 产生/ 冲突/ ./ 在/ CoreDet/ 系统/ 中/ ,/ 写/ 操作/ 被/ 延迟/ 到/ 每轮/ 执行/ 的/ 末尾/ 才/ 提交/ 到/ 主存/ ,/ 这样/ 就/ 只/ 需/ 在/ 提交/ 内存/ 修改/ 时/ 安排/ 所有/ 写/ 操作/ 的/ 顺序/ ,/ 因此/ 会/ 极大/ 的/ 提升/ 并行度/ ./ 理论/ 上/ 讲/ ,/ 内存/ 一致性/ 越弱/ ,/ 确定性/ 并行/ 系统/ 需要/ 安排/ 的/ 访存/ 顺序/ 就/ 越少/ ,/ 就/ 越/ 容易/ 获得/ 较/ 高/ 的/ 性能/ ./ 然而/ 这/ 并/ 不是/ 绝对/ 的/ ,/ 系统/ 的/ 性能/ 还/ 和/ 具体/ 的/ 实现/ 技术/ 相关/ ./ 除了/ 性能/ ,/ 弱/ 内存/ 一致性/ 还/ 能/ 改善/ 确定性/ 系统/ 的/ 稳定性/ ./ 例如/ 在/ Dthreads/ 系统/ 中/ ,/ 各个/ 线程/ 对/ 内存/ 的/ 修改/ 只有/ 在线/ 程/ 同步/ 时才/ 会/ 合并/ 到/ 共享内存/ ,/ 因此/ 其/ 确定性/ 并/ 不受/ 输入/ 和/ 代码/ 微小/ 扰动/ 的/ 影响/ ./ 弱/ 内存/ 一致性/ 为/ 确定性/ 并行/ 性能/ 优化/ 带来/ 契机/ 的/ 同时/ 也/ 给/ 可编程/ 性/ 和/ 兼容性/ 带来/ 了/ 困难/ ./ 在/ 多线程/ 编程/ 中/ ,/ 程序员/ 最/ 容易接受/ 的/ 是/ 顺序/ 一致性/ ,/ 程序员/ 在/ 编写程序/ 时会/ 自然/ 认为/ 对/ 一个/ 变量/ 的/ 修改/ 会/ 立即/ 可见/ ./ 如果/ 确定性/ 系统/ 不能/ 保证/ 程序员/ 的/ 这种/ 期望/ ,/ 就/ 可能/ 造成/ 程序执行/ 的/ 错误/ ./ 因此/ 弱/ 内存/ 一致性/ 一般/ 都/ 要求/ 程序员/ 增加/ 额外/ 的/ fence/ 指令/ 来/ 强制/ 内存/ 修改/ 必须/ 在/ 某/ 一个点/ 之后/ 可见/ ,/ 这/ 无疑/ 会/ 增加/ 程序员/ 的/ 负担/ ./ 另一方面/ ,/ 按照/ 顺序/ 一致性/ 模型/ 编写/ 的/ 程序/ 一般/ 不能/ 在/ 弱/ 内存/ 一致性/ 的/ 体系结构/ 中/ 正确/ 执行/ ,/ 更进一步/ ,/ 支持/ 较强/ 内存/ 一致性/ 的/ 程序/ 一般/ 不能/ 在/ 具有/ 较弱/ 内存/ 一致性/ 的/ 体系结构/ 中/ 正确/ 运行/ ./ 这/ 是因为/ 程序/ 中/ 可能/ 不/ 存在/ 合理/ 的/ fence/ ,/ 因此/ 产生/ 了/ 向/ 后/ 兼容/ 的/ 问题/ ./ 和/ 体系结构/ 面临/ 的/ 问题/ 一样/ ,/ 使用/ 弱/ 内存/ 一致性/ 的/ 确定性/ 并行/ 系统/ 也/ 存在/ 着/ 这种/ 兼容性/ 和/ 可编程/ 性/ 的/ 问题/ ./ 例如/ Dthreads/ 的/ 弱/ 内存/ 一致性/ 模型/ 就/ 不/ 支持/ Adhoc/ 同步/ 语句/ ./ 即便/ 是/ 这样/ ,/ 弱/ 内存/ 一致性/ 仍然/ 是/ 目前/ 确定性/ 并行/ 技术/ 的/ 主流/ [/ 47/ -/ 49/ ]/ ./ 这/ 是因为/ 性能/ 和/ 稳定性/ 是/ 影响/ 确定性/ 并行/ 系统/ 实用性/ 的/ 关键/ ,/ 而/ 可编程/ 性/ 和/ 兼容性/ 可以/ 通过/ 其他/ 方法/ 来/ 弥补/ ./ 例如/ ,/ 可以/ 设计/ 新/ 的/ 编程/ 模型/ ,/ 使/ 程序员/ 在/ 编写/ 多线程/ 程序/ 时/ 并/ 不/ 直接/ 考虑/ 线程/ 同步/ ,/ 这样/ 就/ 能/ 屏蔽/ 弱/ 内存/ 一致性/ 的/ 问题/ ./ 另一方面/ ,/ 也/ 可以/ 利用/ 一些/ 自动化/ 的/ 工具/ 来/ 实现/ 对/ 传统/ 代码/ 的/ 兼容/ ./ 例如/ Liu/ 等/ 人/ [/ 50/ ]/ 提出/ 了/ 一种/ 自动/ 根据/ 弱/ 内存/ 一致性/ 模型/ 为/ 程序/ 加/ fence/ 的/ 方法/ ,/ 类似/ 的/ 方法/ 也/ 可以/ 用/ 在/ 确定性/ 系统/ 中/ ./ 弱/ 内存/ 一致性/ 在/ 确定性/ 多线程/ 的/ 实现/ 中/ 占有/ 重要/ 地位/ ./ 如图/ 2/ 所示/ ,/ 目前/ 确定性/ 并行/ 技术/ 已经/ 探讨/ 了/ SC/ 、/ TSO/ 等/ 内存/ 一致性/ 模型/ ./ 我们/ 也/ 在/ RFDet/ 算法/ 的/ 实现/ 中/ 尝试/ 了/ LRC/ 内存/ 一致性/ ./ 初步/ 结果显示/ ,/ 在/ LRC/ 内存/ 一致性/ 模型/ 下/ ,/ 确定性/ 并行/ 能/ 取得/ 更好/ 的/ 性能/ ,/ 但/ 同时/ 也/ 会/ 将/ 系统/ 的/ 兼容性/ 降低/ ./ 其他/ 的/ 一些/ 内存/ 一致性/ 模型/ 如/ PSO/ 还/ 没有/ 被/ 任何/ 确定性/ 技术/ 所/ 使用/ ./ 目前/ 哪种/ 弱/ 内存/ 一致性/ 模型/ 最/ 适合/ 确定性/ 并行/ 还/ 不得而知/ ,/ 很/ 有/ 可能/ 需要/ 为/ 确定性/ 并行/ 设计/ 一种/ 全新/ 的/ 内存/ 一致性/ 模型/ 来/ 同时/ 解决/ 性能/ 和/ 兼容性/ 方面/ 的/ 问题/ ,/ 未来/ 需要/ 在/ 这方面/ 做/ 深入探讨/ ./ Page115/ 确定性/ 并行/ 发展趋势/ 展望/ 确定性/ 并行/ 技术/ 作为/ 一种/ 并行程序/ 的/ 解决方案/ ,/ 上/ 接/ 应用程序/ ,/ 下/ 接/ 体系结构/ ,/ 因此/ 它/ 的/ 发展/ 同时/ 受/ 两/ 方面/ 因素/ 的/ 主导/ :/ 一是/ 体系结构/ 的/ 发展/ ;/ 二是/ 应用程序/ 的/ 需求/ ./ 目前/ 异构/ 和/ 大规模/ 并行/ 是/ 体系结构/ 的/ 两个/ 重要/ 发展趋势/ ;/ 而/ 上层/ 应用程序/ 则/ 要求/ 尽可能/ 的/ 发挥/ 体系结构/ 的/ 性能/ ,/ 同时/ 方便/ 用户/ 编程/ ./ 受/ 这些/ 因素/ 的/ 影响/ ,/ 目前/ 确定性/ 并行/ 技术/ 存在/ 着/ 向/ 大规模/ 并行/ 、/ 异构/ 和/ 新型/ 编程/ 模型/ 等/ 方向/ 发展/ 的/ 趋势/ ./ 5.1/ 大规模/ 并行/ 支持/ 受/ 科学计算/ 和/ 云/ 计算/ 等/ 应用/ 的/ 影响/ ,/ 并行计算/ 正在/ 向/ 大规模/ 并行/ 和/ 分布式/ 并行/ 等/ 方面/ 发展/ ./ 针对/ 这一/ 趋势/ ,/ 确定性/ 并行/ 技术/ 不能/ 仅仅/ 停留/ 在/ 支持/ 多线程/ 并行/ ./ 在/ 大规模/ 并行计算/ 领域/ 中/ ,/ 由于/ 程序/ 并行度/ 极高/ ,/ 更加/ 容易/ 出现/ 问题/ ,/ 因此/ 更加/ 迫切需要/ 确定性/ 并行/ 技术/ 的/ 支持/ ./ 目前/ 国际/ 上/ 已经/ 开始/ 研究/ 面向/ 分布式/ 环境/ 的/ 确定性/ 系统/ ./ 然而/ 由于/ 并行度/ 很大/ ,/ 这种/ 系统/ 的/ 开销/ 也/ 会/ 急速/ 上升/ ./ 例如/ ,/ Bergan/ 等/ 人/ [/ 45/ ]/ 实现/ 的/ 面向/ 分布式系统/ 的/ 确定性/ 并行/ 系统/ DDOS/ 的/ 性能/ 开销/ 可高达/ 20/ 倍/ ,/ 远远/ 不能/ 满足/ 实用/ 需求/ ./ 支持/ 大规模/ 并行程序/ 的/ 确定性/ 技术/ 能够/ 应用/ 于云/ 计算/ 和/ 科学计算/ 等/ 领域/ ,/ 例如/ 应用/ 在/ 天河/ 超级计算机/ 中/ [/ 51/ ]/ ,/ 为/ 大规模/ 并行计算/ 和/ 云/ 计算/ 的/ 可靠性/ 提升/ 提供/ 技术/ 支撑/ ,/ 是/ 未来/ 的/ 一个/ 发展趋势/ ./ 5.2/ 异构/ 体系结构/ 支持/ 目前/ 异构/ 体系结构/ 也/ 是/ 一个/ 重要/ 的/ 发展趋势/ ,/ 因此/ 确定性/ 并行/ 技术/ 必须/ 能够/ 支持/ 异构/ 体系结构/ ,/ 否则/ 将/ 很/ 难/ 适应/ 未来/ 硬件/ 的/ 发展/ ./ 目前/ Jooybar/ 等/ 人/ 已经/ 研究/ 了/ GPU/ 的/ 确定性/ 并行/ 技术/ [/ 52/ ]/ ./ 然而/ ,/ 异构/ 并非/ 只有/ GPU/ 一种/ 形式/ ,/ 其/ 实现/ 层次/ 也/ 可以/ 多元化/ ./ 例如/ 在/ 通用/ 的/ OpenCL/ 语言/ 级别/ 上/ 实现/ 确定性/ ,/ 这样/ 便于/ 屏蔽/ 底层/ 硬件/ 的/ 差别/ ,/ 同时/ 具有/ 较/ 好/ 的/ 移植性/ ./ 另外/ ,/ 由于/ 异构/ 体系结构/ 中/ 各个/ 执行/ 单元/ 之间/ 的/ 速率/ 和/ 指令集/ 可能/ 存在/ 差别/ ,/ 因此/ 也/ 会/ 给/ 确定性/ 并行/ 技术/ 带来/ 新/ 的/ 挑战/ ./ 5.3/ 确定性/ 编程/ 模型/ 目前/ 大多数/ 确定性/ 系统/ 都/ 是/ 对/ 现有/ 多线程/ 模型/ 的/ 修补/ ./ 由于/ 多线程/ 模型/ 本身/ 的/ 限制/ ,/ 可能/ 导致/ 确定性/ 系统/ 在/ 性能/ 等/ 方面/ 的/ 问题/ ./ 因此/ 有些/ 研究者/ 倾向/ 于/ 设计/ 新/ 的/ 编程/ 模型/ 来/ 从根本上/ 改善/ 确定性/ 并行/ 技术/ ./ 我们/ 在/ 一些/ 确定性/ 系统/ 中/ 能/ 看到/ 新/ 编程/ 模型/ 的/ 影子/ ,/ 例如/ Determinitor/ 系统/ [/ 5/ ]/ ,/ Grace/ [/ 11/ ]/ 系统/ 等/ ./ 最近/ ,/ Merrifield/ 等/ 人/ [/ 53/ ]/ 又/ 提出/ 了/ 利用/ 版本控制/ 模型/ 来/ 实现/ 确定性/ 的/ 方法/ ,/ 取得/ 了/ 较/ 好/ 的/ 实验/ 效果/ ./ 设计/ 全新/ 的/ 编程/ 模型/ 能够/ 有效/ 地/ 避开/ 数据/ 竞争/ 的/ 问题/ ,/ 同时/ 能够/ 让/ 程序员/ 专注/ 于/ 算法/ 逻辑/ ,/ 具有/ 很强/ 的/ 吸引力/ ./ 因此/ ,/ 设计/ 高效/ 通用/ 的/ 确定性/ 并行/ 编程/ 模型/ 也/ 是/ 未来/ 确定性/ 并行/ 技术/ 的/ 一个/ 发展趋势/ ./ 6/ 结束语/ 并行程序/ 的/ 执行/ 具有/ 不确定性/ ,/ 这/ 给/ 并行程序/ 带来/ 了/ 严峻/ 的/ 挑战/ ,/ 已经/ 成为/ 影响/ 并行程序/ 可靠性/ 的/ 关键问题/ ./ 确定性/ 并行/ 技术/ 给/ 我们/ 带来/ 了/ 很多/ 期待/ :/ 通过/ 保证/ 并行程序/ 在/ 相同/ 的/ 输入/ 下/ 总是/ 产生/ 相同/ 的/ 输出/ ,/ 确定性/ 并行/ 技术/ 能够/ 同时/ 解决/ 并行程序/ 在/ 开发/ 、/ 测试/ 、/ 调试/ 、/ 容错/ 和/ 安全/ 等/ 方面/ 的/ 问题/ ./ 然而/ 目前/ 确定性/ 并行/ 技术/ 在/ 很多/ 方面/ ,/ 尤其/ 是/ 性能/ 方面/ 还/ 难以/ 满足/ 实用性/ 的/ 需求/ ./ 本文/ 介绍/ 了/ 目前/ 主流/ 的/ 一些/ 确定性/ 并行/ 技术/ 方法/ ,/ 包括/ 我们/ 自己/ 实现/ 的/ 三个/ 确定性/ 算法/ ,/ 分析/ 和/ 对比/ 了/ 这些/ 方法/ 的/ 优缺点/ ,/ 讨论/ 了/ 弱/ 内存/ 一致性/ 对/ 确定性/ 并行/ 技术/ 的/ 影响/ ,/ 并/ 对/ 未来/ 确定性/ 并行/ 技术/ 的/ 发展趋势/ 作出/ 了/ 展望/ ./ 

