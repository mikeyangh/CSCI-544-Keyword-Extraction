Page1/ 基于/ 关联/ 挖掘/ 的/ 软件/ 错误/ 定位/ 方法/ 赵磊/ 1/ )/ ,/ 2/ )/ 王丽娜/ 1/ )/ ,/ 2/ )/ 高/ 东明/ 1/ )/ ,/ 2/ )/ 张震宇/ 3/ )/ 熊作婷/ 1/ )/ ,/ 2/ )/ 1/ )/ (/ 武汉大学/ 空天/ 信息安全/ 与/ 可信计算/ 教育部/ 重点/ 实验室/ 武汉/ 430072/ )/ 2/ )/ (/ 武汉大学/ 计算机/ 学院/ 武汉/ 430072/ )/ 3/ )/ (/ 中国科学院/ 软件/ 研究所/ 计算机科学/ 国家/ 重点/ 实验室/ 北京/ 100190/ )/ 摘要/ 基于/ 覆盖率/ 的/ 错误/ 定位/ (/ CoverageBasedFaultLocalization/ ,/ CBFL/ )/ 方法/ 旨在/ 通过/ 分析程序/ 执行/ 的/ 结果/ 预测/ 错误信息/ ,/ 是/ 一种/ 行之有效/ 的/ 错误/ 定位/ 方法/ ./ 然而/ ,/ CBFL/ 方法/ 中/ 代码/ 覆盖率/ 的/ 独立/ 统计/ 忽略/ 了/ 程序/ 内/ 存在/ 的/ 复杂/ 控制/ 依赖/ 和/ 数据/ 依赖/ ,/ 从而/ 忽视/ 了/ 语句/ 间/ 的/ 语义/ 关系/ ,/ 影响/ 错误/ 定位/ 的/ 准确性/ ./ 该文/ 借助/ 实例/ 重点/ 分析/ 了/ 基于/ 代码/ 覆盖率/ 所/ 得到/ 的/ 错误/ 可疑/ 度/ 与/ 错误代码/ 的/ 表现/ 关系/ ,/ 指出/ 现有/ CBFL/ 方法/ 的/ 不足/ 是/ 片面/ 地/ 将/ 基于/ 覆盖率/ 的/ 错误/ 可疑/ 度/ 直接/ 作为/ 错误代码/ 判定/ 的/ 依据/ ;/ 提出/ 程序/ 失效/ 规则/ 及/ 基于/ 覆盖/ 向量/ 的/ 覆盖/ 信息/ 分析模型/ ,/ 并/ 在/ 此/ 模型/ 基础/ 之上/ ,/ 指出/ 高/ 可疑/ 代码/ 与/ 错误代码/ 在/ 执行/ 路径/ 上/ 的/ 覆盖/ 一致性/ ,/ 进而/ 提出/ 用以/ 挖掘/ 与/ 高/ 可疑/ 代码/ 相关联/ 的/ 错误代码/ 的/ 频繁/ 集/ 求解/ 方法/ ./ 以/ SIR/ 基准/ 程序/ 为/ 实验/ 对象/ 建立/ 的/ 受控/ 实验/ 结果表明/ ,/ 相比/ 之前/ 的/ 研究/ ,/ 文中/ 方法/ 在/ 一定/ 程度/ 上/ 能够/ 改进/ 错误/ 定位/ 结果/ ./ 关键词/ 软件/ 调试/ ;/ 错误/ 定位/ ;/ 关联/ 挖掘/ ;/ 覆盖/ 向量/ ;/ 频繁/ 集/ 1/ 引言/ 近年来/ ,/ 软件/ 发展/ 日新月异/ ,/ 覆盖/ 了/ 日常生活/ 、/ 工作/ 等/ 社会/ 各个/ 层次/ ./ 然而/ ,/ 软件缺陷/ 的/ 存在/ 却/ 经常/ 导致/ 信息系统/ 的/ 失效/ 和/ 崩溃/ ,/ 给/ 系统/ 的/ 可信/ 运行/ 带来/ 挑战/ [/ 1/ ]/ ./ 缺陷/ 的/ 产生/ ,/ 很大/ 一部分/ 是/ 由/ 编码/ 阶段/ 注入/ 的/ 软件/ 错误/ 导致/ 的/ ./ “/ 软件/ 调试/ ”/ 是/ 定位/ 并/ 排除/ 软件/ 错误/ 的/ 常用/ 手段/ ,/ 也/ 是/ 软件开发/ 过程/ 中/ 繁琐/ 且易/ 出错/ 的/ 过程/ ,/ 具有/ 很/ 高/ 的/ 自动化/ 需求/ ./ “/ 错误/ 定位/ ”/ 指/ 的/ 是/ 在/ 已知/ 程序/ 失效/ 的/ 情况/ 下/ 定位/ 错误代码/ 的/ 过程/ [/ 2/ ]/ ,/ 是/ 软件/ 调试/ 的/ 首要/ 步骤/ ./ 精确/ 的/ 错误/ 定位/ 方法/ 研究/ ,/ 一方面/ 有利于/ 缺陷/ 的/ 检测/ 、/ 诊断/ 及/ 修复/ ,/ 另一方面/ 则/ 可以/ 降低/ 软件测试/ 及/ 维护/ 成本/ ,/ 对/ 软件/ 质量/ 及/ 可靠性/ 的/ 提高/ 具有/ 重要/ 意义/ [/ 3/ ]/ ./ 基于/ 覆盖率/ 的/ 错误/ 定位/ (/ CoverageBasedFaultLocalization/ ,/ CBFL/ )/ 以/ 多次/ 程序执行/ 轨迹/ 之间/ 的/ 统计/ 与/ 比较/ 作为/ 其/ 主要/ 实践/ 方法/ ,/ 是/ 一种/ 行之有效/ 的/ 软件/ 错误/ 定位/ 技术/ [/ 1/ ,/ 3/ -/ 5/ ]/ ./ 然而/ ,/ 现有/ CBFL/ 方法/ 只是/ 统计/ 代码/ 语句/ 或/ 代码/ 基本块/ 的/ 覆盖率/ ,/ 并/ 基于/ 代码/ 覆盖率/ 计算/ 代码/ 的/ 错误/ 可疑/ 度/ ./ 这种/ 计算方法/ 对/ 程序/ 的/ 执行/ 流程/ 进行/ 了/ 高度/ 的/ 简化/ ,/ 忽略/ 了/ 软件/ 中/ 存在/ 着/ 的/ 复杂/ 控制/ 依赖/ 和/ 数据/ 依赖/ 关系/ [/ 5/ ]/ ./ 由于/ 程序/ 内/ 错误/ 的/ 触发/ 及/ 失效/ 在/ 很大/ 程度/ 上/ 取决于/ 程序执行/ 时/ 的/ 上下文/ 环境/ [/ 6/ -/ 7/ ]/ ,/ 因此/ 现有/ CBFL/ 方法/ 在/ 很多/ 情况/ 下/ 的/ 错误/ 定位/ 并/ 不/ 准确/ [/ 5/ ]/ ,/ 如何/ 提高/ 错误/ 定位/ 方法/ 的/ 准确性/ 和/ 有效性/ 是/ CBFL/ 方法/ 研究/ 中/ 的/ 重点/ 问题/ ,/ 也/ 是/ 近几年/ 的/ 研究/ 热点/ ./ 本文/ 首先/ 分析/ 了/ CBFL/ 方法/ 在/ 某些/ 情况/ 下/ 准确性/ 缺失/ 的/ 原因/ ,/ 指出/ 基于/ 覆盖率/ 计算所/ 得到/ 的/ 错误/ 可疑/ 度/ 与/ 错误代码/ 之间/ 并/ 不/ 存在/ 直接/ 的/ 因果关系/ ,/ 进而/ 不能/ 将/ 错误/ 可疑/ 度/ 直接/ 作为/ 判定/ 代码/ 出错/ 与否/ 的/ 依据/ ./ 考虑/ 程序/ 的/ 失效/ 过程/ ,/ 具有/ 较/ 高/ 错误/ 可疑/ 度/ 的/ 高/ 可疑/ 代码/ 是/ 程序/ 失效/ 的/ 重要/ 特征/ ,/ 是/ 错误/ 定位/ 的/ 重要/ 线索/ ,/ 同时/ 高/ 可疑/ 代码/ 与/ 错误代码/ 之间/ 存在/ 强/ 关联性/ ,/ 这种/ 关联性/ 是/ 提高/ 错误/ 定位/ 的/ 重要/ 因素/ ./ 为了/ 挖掘/ 这种/ 关联性/ ,/ 我们/ 基于/ 覆盖/ 向量/ 建立/ 执行/ 轨迹/ 分析/ 及/ 频繁/ 集/ 求解/ 模型/ ./ 该/ 模型/ 以高/ 可疑/ 代码/ 为/ 目标/ ,/ 通过/ 在/ 失效/ 执行/ 轨迹/ 上/ 的/ 频繁/ 集/ 求解/ 来/ 挖掘/ 该/ 高/ 可疑/ 代码/ 的/ 关联/ 代码/ ,/ 并/ 以/ 挖掘出/ 的/ 关联/ 代码/ 作为/ 代码/ 检查/ 的/ 对象/ ./ 以/ SIR/ 基准/ 程序/ 的/ 实验/ 表明/ ,/ 基于/ 覆盖/ 向量/ 的/ 频繁/ 集/ 挖掘/ 方法/ 能/ 在/ 一定/ 程度/ 上/ 提高/ 错误/ 定位/ 的/ 准确性/ ./ 本文/ 的/ 贡献/ 主要/ 有/ 以下几点/ :/ (/ 1/ )/ 首次/ 提出/ 以/ 挖掘/ 错误代码/ 与/ 高/ 可疑/ 度/ 代码/ 之间/ 的/ 关联/ 关系/ 为/ 手段/ 的/ 错误/ 定位/ 方法/ ;/ (/ 2/ )/ 以/ SIR/ 基准/ 程序/ 为/ 对象/ 的/ 验证/ 实验/ 表明/ ,/ 本文/ 方法/ 较/ 现有/ 方法/ 能够/ 在/ 一定/ 程度/ 上/ 提高/ 错误/ 定位/ 准确度/ ./ 本文/ 第/ 2/ 节/ 介绍/ 和/ 总结/ 目前/ 的/ 研究进展/ 和/ 相关/ 工作/ ,/ 并/ 以/ 实例/ 论述/ 研究/ 动机/ ;/ 第/ 3/ 节/ 给出/ 一些/ 基本/ 定义/ 及/ 规则/ ;/ 第/ 4/ 节/ 论述/ 错误/ 定位/ 分析模型/ 的/ 建立/ 以及/ 在/ 此/ 模型/ 基础/ 上/ 的/ 关联/ 挖掘/ 算法/ ;/ 第/ 5/ 节以/ SIR/ 基准/ 程序/ 为/ 对象/ 建立/ 实验/ 环境/ 、/ 分析/ 实验/ 结果/ ;/ 第/ 6/ 节/ 讨论/ 本文/ 方法/ 的/ 有效性/ 及/ 可能/ 的/ 改进/ 方式/ ;/ 最后/ 总结/ 全文/ ./ 2/ 相关/ 工作/ 及/ 研究/ 动机/ 本/ 节/ 主要/ 介绍/ 以/ 分析/ 比较/ 测试/ 结果/ 为/ 主要/ 手段/ 的/ 错误/ 定位/ 方法/ 的/ 研究/ 现状/ ,/ 并/ 着重/ 分析/ CBFL/ 的/ 相关/ 研究/ ,/ 以/ 实例/ 来/ 说明/ 本文/ 的/ 研究/ 动机/ ./ 2.1/ 错误/ 定位/ 方法/ 研究/ 现状/ 错误/ 定位/ 的/ 研究/ 按照/ 其/ 方法/ 大致/ 分为/ 3/ 类/ :/ 基于/ 程序/ 切片/ 的/ 错误/ 定位/ 方法/ 、/ 差分/ 式/ 错误/ 定位/ 方法/ 及/ 基于/ 覆盖率/ 的/ 错误/ 定位/ 方法/ ./ 基于/ 程序/ 切片/ 的/ 错误/ 定位/ 利用/ 程序执行/ 的/ 代码/ 语句/ 对/ 程序/ 输出/ 的/ 数据/ 传递/ 关系/ ,/ 动态/ 切分/ 程序执行/ 代码/ ,/ 得到/ 失效/ 路径/ [/ 8/ ]/ ./ 该类/ 方法/ 具有/ 很/ 好/ 的/ 实用性/ ,/ 但是/ 在/ 处理/ 复杂/ 软件/ 时/ 依然/ 面临/ 切片/ 代码/ 庞大/ 的/ 问题/ [/ 9/ ]/ ./ 借助于/ 执行/ 轨迹/ 之间/ 的/ 比较/ ,/ Agrawal/ 等/ 人/ [/ 2/ ]/ 提出/ 通过/ 计算/ 成功/ 与/ 失效/ 执行/ 轨迹/ 的/ 差/ 集以/ 隔离/ 代码/ 的/ 方法/ ./ 在/ 此基础/ 之上/ ,/ Renieris/ 和/ Reiss/ [/ 6/ ]/ 提出/ 基于/ 最小/ 距离/ 邻近/ 路径/ 的/ 定位/ 方法/ ,/ 较/ 之前/ 的/ 方法/ 具有/ 更好/ 效果/ ./ Cleve/ 和/ Zeller/ [/ 10/ ]/ 以/ 二分法/ 构造/ 测试/ 输入/ ,/ 并且/ 以/ 细粒度/ 的/ 程序执行/ 状态/ 对比/ 为/ 手段/ ,/ 提出/ 了/ 差分/ 式/ 调试/ 方法/ (/ DeltaDebugging/ )/ ./ CBFL/ 方法/ 引入/ 概率/ 计算/ ,/ 统计/ 和/ 比较/ 语句/ 、/ 分支/ 和/ 谓词/ 等/ 在/ 多个/ 不同/ 的/ 成功/ 及/ 失效/ 的/ 执行/ 过程/ 下/ 的/ 覆盖率/ ,/ 计算错误/ 可疑/ 度/ ,/ 然后/ 再/ 依据/ 可疑/ 度/ 对/ 代码/ 进行/ 隔离/ 和/ 排序/ ,/ 优先/ 检查/ 可疑/ 度高/ 的/ 代码/ [/ 11/ ]/ ./ 实验/ 研究/ 表明/ ,/ CBFL/ 方法/ 不管/ 在/ 可/ 实施/ 性/ 还是/ 有效性/ 方面/ 均/ 较/ 其它/ 方法/ 具有/ 更好/ 的/ 效果/ [/ 3/ ]/ ./ 根据/ 代码/ 覆盖/ 信息/ 的/ 体现/ 方式/ 不同/ ,/ CBFL/ 方法/ 又/ 可以/ 分为/ 两种/ ,/ 分别/ 是/ 基于/ 代码/ 语句/ 覆盖/ 的/ 错误/ 定位/ 方法/ 和/ 基于/ 谓词/ 覆盖/ 的/ 错误/ 定位/ 方法/ ./ 基于/ 代码/ 语句/ 覆盖/ 的/ 方法/ 中/ 的/ 覆盖/ 信息/ 是/ 程序代码/ 在/ 某/ 一次/ 程序执行/ 过程/ 中/ 是否/ 被/ 执行/ ,/ 如/ Page3Tarantula/ [/ 11/ ]/ 、/ Jaccard/ [/ 4/ ]/ 、/ Ochiai/ [/ 4/ ]/ 等/ ./ Tarantula/ 认为/ 代码/ 被/ 失效/ 执行/ 覆盖/ 的/ 比例/ 越大/ ,/ 意味着/ 该/ 代码/ 出错/ 的/ 可能性/ 越大/ ./ Abreu/ 等/ 人/ [/ 4/ ]/ 引入/ Jaccard/ 和/ Ochiai/ 相似/ 度/ 系数/ ,/ 分别/ 提出/ Jaccard/ 和/ Ochiai/ 方法/ ./ 基于/ 谓词/ 覆盖/ 的/ 错误/ 定位/ 方法/ 通过/ 插桩/ 方式/ 在/ 源代码/ 中/ 插入/ 能够/ 表征/ 软件/ 行为/ (/ 如/ 程序/ 的/ 不同/ 分支/ 、/ 返回值/ 、/ 特定/ 值/ 的/ 比较/ 等/ )/ 的/ 谓词/ [/ 12/ ]/ ,/ 然后/ 以/ 谓词/ 覆盖率/ 分析/ 其/ 周围/ 代码/ 的/ 出错/ 概率/ ./ 代表性/ 的/ 方法/ 有/ CBI/ [/ 12/ -/ 13/ ]/ 、/ SOBER/ [/ 14/ ]/ 等/ ,/ 此外/ ,/ Yu/ 等/ 人/ [/ 15/ ]/ 将/ CBI/ 方法/ 改造/ 成/ 基于/ 代码/ 语句/ 的/ SBI/ 方法/ ./ 与/ 基于/ 代码/ 语句/ 覆盖/ 的/ 方法/ 对比/ ,/ CBI/ [/ 12/ ]/ 等/ 方法/ 得到/ 的/ 代码/ 覆盖/ 信息/ 更加/ 丰富/ ./ 虽然/ 覆盖/ 信息/ 的/ 体现/ 方式/ 不同/ ,/ 但/ 上述/ 两类/ CBFL/ 方法/ 中/ 代码/ 语句/ 和/ 谓词/ 的/ 错误/ 可疑/ 度/ 计算/ 都/ 是/ 依据/ 其/ 覆盖率/ 的/ 统计/ 与/ 比较/ [/ 15/ ]/ ./ 借助于/ 调试/ 反馈/ 信息/ ,/ Hao/ 等/ 人/ [/ 16/ ]/ 提出/ 了/ 一种/ 交互式/ 错误/ 定位/ 方法/ ;/ 同时/ 考虑/ 到/ 测试用例/ 相似性/ 对/ CBFL/ 方法/ 结果/ 的/ 影响/ ,/ Hao/ 等/ 人/ [/ 17/ ]/ 又/ 提出/ 了/ 测图/ 1/ 本文/ 研究/ 动机/ 1/ 依据/ 执行/ 过程/ 收集/ 到/ b2/ 和/ b3/ 的/ 代码/ 覆盖/ 信息/ 为/ {/ failed/ (/ b2/ )/ =/ 2/ ,/ passed/ (/ b2/ )/ =/ 2/ }/ 和/ {/ failed/ (/ b3/ )/ =/ 1/ ,/ passed/ (/ b3/ )/ =/ 0/ }/ ,/ 即/ 覆盖/ b3/ 的/ 执行/ 均/ 为/ 失效/ 执行/ ,/ 而/ 覆盖/ b2/ 的/ 执行/ 中仅/ 一部分/ 为/ 失效/ 执行/ ,/ 按照/ 现有/ CBFL/ 方法/ 如/ Tarantula/ 或/ SBI/ 等/ 可/ 得到/ b2/ 的/ 错误/ 可疑/ 度/ 小于/ b3/ 的/ 错误/ 可疑/ 度/ ,/ 而/ 实际上/ 错误代码/ 位于/ b2/ ./ 考察/ 程序/ 的/ 执行/ 过程/ ,/ b2/ 执行/ 后/ 产生/ 了/ 错误/ 数据/ count/ ,/ 同时/ b3/ 的/ 执行/ 会/ 调用/ 变量/ count/ ,/ 这/ 使得/ 覆盖/ b3/ 的/ 执行/ 均/ 由于/ 引用/ 错误/ 数据/ count/ 而/ 引发/ 失效/ ,/ 即/ 覆盖/ b3/ 的/ 执行/ 均/ 是/ 失效/ 执行/ ./ 由于/ 覆盖/ b3/ 的/ 执行/ 中/ 失效/ 执行/ 所/ 占/ 的/ 比例/ 要/ 大于/ 覆盖/ b2/ 执行/ 中/ 的/ 失效/ 执行/ 所/ 占/ 比例/ ,/ 按照/ Tarantula/ 和/ SBI/ 等/ 的/ 方法/ 可以/ 计算/ 得到/ b3/ 的/ 错误/ 可疑/ 度/ 大于/ b2/ ./ 试用/ 例约/ 减/ 方法/ 以/ 进一步提高/ CBFL/ 方法/ 的/ 有效性/ ./ CBFL/ 方法/ 中/ 不同/ 代码/ 的/ 覆盖率/ 统计/ 是/ 相互/ 独立/ 的/ ,/ 事实上/ 程序/ 先后/ 执行/ 的/ 代码/ 有/ 很/ 强/ 的/ 依赖/ 关系/ [/ 5/ ]/ ,/ 在/ 失效/ 执行/ 上/ 则/ 表现/ 为/ 程序/ 感染/ 状态/ 的/ 传递/ 与/ 转换/ ./ 所以/ ,/ 独立/ 的/ 代码/ 覆盖率/ 统计/ 没有/ 考虑/ 程序结构/ 中/ 的/ 依赖/ 以及/ 动态/ 执行/ 中/ 程序/ 感染/ 状态/ 的/ 传递/ 等/ 关系/ ,/ 进而/ 将/ 导致/ 定位/ 的/ 不/ 准确/ ,/ 如/ CBFL/ 方法/ 经常/ 可以/ 定位/ 出/ 程序/ 失效/ 时/ 的/ 执行/ 代码/ ,/ 而/ 程序/ 失效/ 时/ 的/ 执行/ 代码/ 很多/ 情况/ 下/ 并/ 不是/ 错误代码/ [/ 5/ ]/ ./ 如何/ 挖掘/ 导致/ 程序/ 失效/ 的/ 错误代码/ 以/ 提高/ 错误/ 定位/ 的/ 有效性/ 是/ 本文/ 的/ 研究/ 动机/ ./ 2.2/ 本文/ 研究/ 动机/ 图/ 1/ 所示/ 是/ 一个/ 实际/ 代码/ 中/ 的/ 错误/ 、/ 程序控制/ 流图/ 及/ 测试/ 情况/ [/ 5/ ]/ ,/ 代码/ 中/ 框内/ 的/ 部分/ 表示/ 错误/ 所在/ 的/ 位置/ ,/ 测试用例/ 编号/ 为/ t1/ ~/ t7/ ,/ 每个/ 测试用例/ 对应/ 的/ 执行/ 覆盖/ 信息/ 如图/ 1/ 中/ “/ ●/ ”/ 所示/ ,/ 其中/ 被/ 阴影/ 覆盖/ 的/ 测试用例/ 对应/ 失效/ 执行/ ./ 如/ 本文/ 引言/ 所述/ ,/ 该/ 问题/ 产生/ 的/ 原因/ 是/ 孤立/ 的/ 代码/ 覆盖率/ 统计/ 简化/ 了/ 程序/ 的/ 执行/ 过程/ ./ 针对/ 这一/ 问题/ ,/ 文献/ [/ 5/ ]/ 以/ 状态/ 转换/ 为/ 手段/ ,/ 将/ 程序执行/ 看作/ 感染/ 状态/ 的/ 转换/ 和/ 传递/ 模型/ ,/ 迭代/ 计算错误/ 转换/ 概率/ ,/ 提出/ 了/ 一种/ 基于/ 状态/ 转换/ 的/ 错误/ 定位/ 方法/ ./ 然而/ ,/ 文献/ [/ 5/ ]/ 中/ 按照/ 执行/ 顺序/ 从后/ 往前/ 的/ 感染/ 状态/ 计算方法/ 可能/ 并/ 不适/ 用于/ 所有/ 情况/ ./ 文献/ [/ 5/ ]/ 以/ 连接/ 两个/ 连续/ 基本块/ 的/ 分支/ 路径/ 上/ 的/ 失效/ 覆盖/ 比例/ 来/ 表示/ 感染/ 状态/ 的/ 传递/ 概率/ ,/ 但是/ 被/ 失效/ 执行/ 覆盖/ 的/ 代码/ 基本块/ 并/ 不/ 意味着/ 该段/ 代码/ 在/ 执行/ 时/ 程序/ 状态/ 已/ 感染/ ,/ 在/ 错误/ 被/ 触发/ 之前/ 执行/ 的/ 代码/ 同样/ 会/ 被/ 失效/ 执行/ 覆盖/ ,/ 所以/ ,/ 分支/ 路径/ 上/ 的/ 失效/ 覆盖/ 比例/ 并/ 不能/ 直接/ 作为/ 从/ 程序/ 感染/ 状态/ 在/ 基本块/ 之间/ 的/ 传递/ 概率/ ./ 比如/ ,/ b1/ 和/ b2/ 为/ 两个/ 连续/ 基本块/ ,/ 错误/ 位于/ b2Page4/ 而/ b1/ 优先/ b2/ 执行/ ,/ 错误/ 的/ 触发/ 必须/ 满足条件/ C/ ,/ 同时/ 当且/ 仅/ 当/ b1/ 执行/ 之后/ 才/ 会/ 使得/ 当前/ 的/ 程序/ 状态/ 满足/ C/ 并/ 触发/ 错误/ ./ 这种/ 情况/ 下/ ,/ 覆盖/ b1/ 的/ 失效/ 执行/ 比例/ 很大/ ,/ 但是/ b1/ 执行/ 时/ 程序/ 并非/ 处于/ 感染/ 状态/ ./ 为了/ 更好/ 地/ 说明/ 问题/ ,/ 本文/ 构造/ 了/ 图/ 2/ 中/ 的/ 示例/ 代码/ ./ 图/ 2/ 中/ 代码/ 中/ 错误/ 存在/ 于/ b4/ ,/ 假设/ 代码/ 的/ 测试用例/ 执行/ 情况/ 与/ 图/ 1/ 相同/ ,/ 则/ 所有/ b2/ →/ b3/ →/ b4/ 的/ 路径/ 均/ 为/ 失效/ 路径/ ,/ b2/ →/ b4/ 的/ 路径/ 中/ 一部分/ 为/ 成功/ 路径/ ,/ 一部分/ 为/ 失效/ 路径/ ,/ 可/ 得/ ,/ 覆盖/ b3/ 的/ 执行/ 中/ 失效/ 执行/ 的/ 比例/ 为/ 100/ %/ ,/ 而/ 按照/ 文献/ [/ 5/ ]/ 的/ 方法/ 计算/ 出错/ 的/ 代码/ 极大/ 可能/ 存在/ 于/ b2/ ./ 综合/ 考虑/ 上述/ 几种/ 情形/ ,/ 基于/ 覆盖率/ 计算/ 得到/ 的/ 高/ 错误/ 可疑/ 度/ 的/ 代码/ 主要/ 有/ 如下/ 几种/ 情况/ :/ 情形/ 1/ ./ 该/ 高/ 可疑/ 代码/ 本身/ 含有/ 错误/ ,/ 在/ 代码/ 覆盖率/ 上/ 表现/ 为/ 覆盖/ 该/ 代码/ 的/ 执行/ 多为/ 失效/ 执行/ ,/ 而/ 成功/ 执行/ 一般/ 不/ 覆盖/ 该/ 代码/ ./ 这是/ 一种/ 较为简单/ 的/ 错误/ 定位/ ,/ 但/ 实际/ 情况/ 中/ 更/ 多/ 的/ 错误/ 触发/ 及/ 程序/ 失效/ 并/ 不该/ 满足/ 简单/ 情形/ ./ 情形/ 2/ ./ 该/ 高/ 可疑/ 代码/ 的/ 执行/ 会/ 引用/ 错误/ 触发/ 所/ 产生/ 的/ 错误/ 数据/ ,/ 并/ 将/ 程序/ 的/ 感染/ 状态/ 一直/ 传递/ 至/ 失效/ ./ 图/ 1/ 中/ 的/ 示例/ 满足/ 情形/ 2/ ./ 这种/ 情况/ 下/ 一般/ 错误/ 位于/ 高/ 可疑/ 代码执行/ 之前/ ./ 情形/ 3/ ./ 该/ 高/ 可疑/ 代码/ 的/ 执行/ 会/ 产生/ 满足/ 错误/ 触发/ 的/ 特殊/ 程序/ 状态/ ./ 在/ 这种/ 情况/ 下/ ,/ 错误/ 的/ 触发/ 只有/ 在/ 该/ 代码执行/ 后/ 才/ 可能/ 发生/ ./ 示/ 例如/ 图/ 2/ 中/ 的/ 代码/ ,/ 这种/ 情况/ 下/ 一般/ 错误/ 位于/ 高/ 可疑/ 度/ 代码执行/ 之后/ ./ 错误/ 定位/ 的/ 不/ 准确/ 表现/ 为/ 错误代码/ 的/ 可疑/ 度/ 较/ 低/ 而/ 错误/ 无关/ 的/ 代码/ 却/ 被/ 计算/ 赋予/ 了/ 更/ 高/ 的/ 可疑/ 度/ ./ 为了/ 解决/ 这一/ 问题/ ,/ 有效/ 的/ 可疑/ 度/ 计算方法/ [/ 5/ ]/ 固然/ 是/ 一个/ 思路/ ;/ 同时/ ,/ CBFL/ 方法/ 的/ 准确性/ 缺失/ 表现/ 为/ “/ 错误/ 无关/ 的/ 代码/ 却/ 计算/ 得到/ 较/ 高/ 的/ 错误/ 可疑/ 度/ ”/ ./ 分析/ 这种/ 现象/ 的/ 产生/ ,/ 高/ 可疑/ 代码/ 与/ 程序/ 错误/ 的/ 触发/ 、/ 感染/ 状态/ 传递/ 及/ 程序/ 失效/ 具有/ 直接/ 关系/ ./ 仔细/ 考察/ 如上/ 的/ 3/ 种/ 情形/ 可以/ 发现/ ,/ 大多数/ 情况/ 下/ ,/ 可疑/ 度高/ 的/ 代码/ 或者/ 是/ 错误代码/ (/ 情形/ 1/ )/ ,/ 或者/ 和/ 错误代码/ 之间/ 存在/ 程序/ 感染/ 状态/ 的/ 传递/ 关系/ (/ 情形/ 2/ )/ ,/ 或者/ 是/ 导致/ 错误/ 触发/ 的/ 诱因/ (/ 情形/ 3/ )/ ./ 既然/ 错误代码/ 与/ 高/ 可疑/ 度/ 的/ 代码/ 之间/ 存在/ 从/ 感染/ 状态/ 产生/ 到/ 感染/ 状态/ 表现/ 的/ 这种/ 关联性/ ,/ 那么/ 能否/ 建立/ 能够/ 体现/ 关联性/ 的/ 程序执行/ 的/ 分析模型/ ,/ 并/ 在/ 该/ 模型/ 之上/ 挖掘/ 这种/ 关联性/ 以/ 作为/ 错误/ 定位/ 的/ 重要/ 因素/ ?/ 一旦/ 挖掘出/ 与/ 高/ 可疑/ 代码/ 相关/ 的/ 关联/ 代码/ ,/ 则/ 意味着/ 缩小/ 了/ 待/ 检查/ 代码/ 的/ 范围/ ,/ 进而/ 提高/ 错误/ 定位/ 的/ 有效性/ ./ 因此/ ,/ 本文/ 的/ 主要/ 研究/ 问题/ 集中/ 在/ :/ (/ 1/ )/ 如何/ 建立/ 能够/ 突出/ 错误/ 与/ 失效/ 因果关系/ 的/ 执行/ 轨迹/ 分析模型/ ;/ (/ 2/ )/ 如何/ 挖掘/ 与/ 高/ 可疑/ 度/ 相关联/ 的/ 错误代码/ ./ 事实上/ ,/ 结合/ 静态/ 分析/ 考虑/ ,/ 程序/ 的/ 执行/ 轨迹/ 包含/ 着/ 丰富/ 的/ 结构化/ 信息/ ,/ 在/ 此基础/ 之上/ ,/ 挖掘/ 错误/ 和/ 程序/ 失效/ 之间/ 的/ 因果关系/ 从而/ 准确/ 定位/ 错误/ 是/ 可行/ 的/ ./ 本文/ 将/ 在/ 以下/ 部分/ 中/ 从/ 程序执行/ 轨迹/ 的/ 分析方法/ 和/ 错误/ 与/ 失效/ 的/ 关联/ 挖掘/ 方法/ 两/ 方面/ 进行/ 详细/ 论述/ ./ 2.3/ 同/ 相关/ 工作/ 的/ 关系/ 在/ 之前/ 的/ 研究/ 中/ ,/ 与/ 本文/ 方法/ 相近/ 的/ 有/ 文献/ [/ 18/ ]/ 和/ 文献/ [/ 19/ ]/ ./ 本文/ 与/ 文献/ [/ 18/ ]/ 都/ 是/ 通过/ 搜索/ 关联/ 代码/ 来/ 提高/ 错误/ 定位/ 准确度/ ,/ 然而/ 文献/ [/ 18/ ]/ 通过/ 静态/ 分析/ 获取/ 高/ 可疑/ 代码/ 的/ 数据/ 依赖/ 关系/ ,/ 而/ 我们/ 则/ 是/ 通过/ 执行/ 路径/ 上/ 的/ 频繁/ 集/ 求解/ 来/ 实现/ ,/ 相/ 比较而言/ ,/ 本文/ 中/ 路径分析/ 的/ 代价/ 比/ 数据流/ 分析/ 的/ 代价/ 小/ ./ 文献/ [/ 19/ ]/ 以/ 揭示/ 错误/ 的/ 发生/ 过程/ 为/ 出发点/ ,/ 首先/ 基于/ 元素/ 选择/ 和/ 机器/ 学习/ 方法/ 遴选出/ 错误/ 可疑/ 代码/ ,/ 然后/ 再/ 将/ 错误/ 可疑/ 代码/ 通过/ 控制流/ 联系/ 起来/ ./ 然而/ 文献/ [/ 19/ ]/ 并/ 没有/ 在/ 代码/ 的/ 错误/ 可疑/ 度/ 或/ 错误/ 排查/ 建议/ 的/ 组织/ 方法/ 上/ 改进/ ./ 3/ 基本/ 定义/ 及/ 规则/ 3.1/ 基本/ 定义/ 句/ 构成/ 一个/ 代码/ 基本块/ ,/ 简称/ 为/ 基本块/ ./ 定义/ 1/ ./ 中间/ 不/ 存在/ 控制/ 跳转/ 的/ 连续/ 代码/ 语/ 例如/ ,/ 图/ 1/ 中/ b2/ 包含/ 的/ 4/ 个/ 语句/ 构成/ 基本块/ b2/ ./ 定义/ 2/ ./ 程序代码/ 中/ 的/ 一个/ 函数/ 构成/ 一个/ 控制流/ 图/ CFG/ ,/ 定义/ CFG/ =/ {/ B/ ,/ E/ }/ ,/ 其中/ B/ 表示/ 基本/ Page5/ 块/ 集合/ ,/ E/ 为/ 基本块/ 之间/ 的/ 跳转/ 集合/ ./ 例如/ ,/ 图/ 1/ 中/ B/ =/ {/ b1/ ,/ b2/ ,/ b3/ ,/ b4/ }/ ,/ E/ =/ {/ e1/ ,/ e2/ ,/ e3/ ,/ e4/ ,/ e5/ }/ ./ 定义/ 3/ ./ 执行/ 路径/ 表示/ 程序/ 在/ 一定/ 输入/ 下/ 所/ 执行/ 代码/ 的/ 路径/ 表示/ ./ 例如/ ,/ 图/ 1/ 中/ t2/ 的/ 执行/ 表示/ 为/ b1/ →/ b4/ ./ 根据/ 程序运行/ 结果/ 来/ 区分/ ,/ 成功/ 执行/ 中/ 的/ 路径/ 简称/ 为/ 成功/ 执行/ 路径/ ,/ 失效/ 执行/ 中/ 的/ 路径/ 简称/ 为/ 失效/ 执行/ 路径/ ./ 3.2/ 程序/ 失效/ 执行/ 规则/ 规则/ 1/ ./ 失效/ 执行/ 只能/ 覆盖/ 控制流/ 图中/ 的/ 可/ 执行/ 路径/ ./ 不可/ 执行/ 路径/ 意味着/ 程序/ 在/ 当前/ 测试用例/ 集中/ 的/ 任何/ 测试/ 输入/ 下/ 都/ 不能/ 执行/ 的/ 路径/ ,/ 所以/ 感染/ 状态/ 也/ 不/ 可能/ 沿着/ 不可/ 测试/ 路径/ 传递/ ./ 规则/ 2/ ./ 若/ 程序执行/ 表现/ 为/ 失效/ ,/ 则/ 本次/ 执行/ 一定/ 触发/ 了/ 错误/ ,/ 即/ 与/ 本次/ 执行/ 相对/ 应/ 的/ 执行/ 路径/ 会/ 覆盖/ 错误代码/ ./ 根据/ PIE/ 模型/ [/ 20/ ]/ ,/ 程序/ 的/ 失效/ 必须/ 满足/ 如下/ 3/ 个/ 条件/ :/ (/ 1/ )/ 错误/ 触发/ 并/ 产生/ 感染/ 状态/ ;/ (/ 2/ )/ 感染/ 状态/ 随着/ 程序/ 的/ 执行/ 而/ 传递/ ;/ (/ 3/ )/ 程序/ 的/ 输出/ 受/ 感染/ 状态/ 影响/ ./ 根据/ 条件/ (/ 1/ )/ 可知/ 执行/ 时/ 触发/ 错误/ ./ 根据/ 条件/ (/ 2/ )/ 和/ (/ 3/ )/ ,/ 错误/ 被/ 触发/ 后/ 所/ 产生/ 的/ 感染/ 状态/ 随着/ 执行/ 路径/ 一直/ 传递/ 直至/ 程序/ 失效/ ./ 因此/ ,/ 错误代码/ 会/ 出现/ 在/ 执行/ 路径/ 上/ ./ 需要/ 说明/ 的/ 是/ ,/ 如果/ 错误/ 为/ 语句/ 缺失/ 型/ 错误/ (/ statementsomissionfault/ )/ ,/ 比如/ 条件/ 判断/ 分支/ 不/ 充分/ 导致/ 的/ 部分/ 代码/ 被/ 遗漏/ ,/ 则/ 该/ 错误代码/ 不会/ 出现/ 在/ 程序/ 源代码/ 中/ ,/ 失效/ 执行/ 也/ 不会/ 覆盖/ 错误代码/ ./ 但是/ ,/ 在/ 定位/ 缺失/ 型/ 错误/ 时/ ,/ 相关/ 的/ 方法/ 也/ 是/ 通过/ 缺失/ 型/ 错误/ 相关/ 的/ 代码/ 来/ 分析/ [/ 21/ ]/ ./ 图/ 2/ 中/ 的/ 代码/ 错误/ 遗漏/ 了/ 一个/ 条件/ 判断/ ,/ 定位/ 该/ 错误/ 时/ 仍/ 需要/ 从/ 程序/ 中/ 存在/ 的/ 且/ 与/ 缺失/ 型/ 错误/ 相关/ 的/ 代码/ 入手/ ,/ 如图/ 2/ 中/ 的/ 斜体/ 代码/ ./ 因此/ ,/ 缺失/ 型/ 错误/ 的/ 定位/ 仍然/ 满足/ 规则/ 2.4/ 面向/ 关联/ 挖掘/ 的/ 频繁/ 集/ 求解/ 根据/ 定义/ 3/ 、/ 规则/ 1/ 和/ 规则/ 2/ 可以/ 发现/ ,/ 执行/ 路径/ 可以/ 很/ 好/ 的/ 来/ 表示/ 错误代码/ 与/ 高/ 可疑/ 度/ 代码/ 之间/ 的/ 关联/ 关系/ ,/ 它们/ 在/ 执行/ 路径/ 的/ 覆盖/ 信息/ 上/ 表现/ 出/ 很/ 好/ 的/ 一致性/ ,/ 这种/ 一致性/ 体现/ 在/ 失效/ 执行/ 路径/ 在/ 覆盖/ 高/ 可疑/ 度/ 代码/ 的/ 同时/ 也/ 会/ 覆盖/ 引起/ 失效/ 的/ 错误代码/ ./ 然而/ ,/ 执行/ 轨迹/ 的/ 路径/ 表示/ 是/ 一个/ 很/ 复杂/ 和/ 耗时/ 的/ 工作/ [/ 22/ ]/ ,/ 为此/ ,/ 我们/ 采用/ 相对/ 轻量级/ 的/ 覆盖/ 向量/ [/ 15/ ]/ 来/ 近似/ 表示/ 路径/ 的/ 覆盖/ 信息/ ./ 4.1/ 路径/ 的/ 覆盖/ 向量/ 表示/ 定义/ 4/ ./ 覆盖/ 向量/ 指/ 代码/ 基本块/ 在/ 每次/ 执行/ 中/ 的/ 覆盖/ 信息/ 构成/ 的/ 向量/ 狆/ 犪/ 狋/ 犺/ i/ =/ 〈/ b1/ ,/ b2/ ,/ …/ ,/ bi/ ,/ …/ ,/ bn/ 〉/ ,/ 其中/ 狆/ 犪/ 狋/ 犺/ i/ 表示/ 覆盖/ 向量/ ,/ bj/ 表示/ 程序/ 中/ 的/ 代码/ 基本块/ ,/ 记为/ 该/ 向量/ 的/ 分量/ ,/ j/ 记为/ 分量/ 的/ 序号/ ./ bj/ =/ 0/ 表示/ 基本块/ bj/ 没有/ 执行/ ,/ 记为/ bj/ 没有/ 被/ 狆/ 犪/ 狋/ 犺/ i/ 覆盖/ ;/ bj/ =/ 1/ 表示/ 基本块/ bj/ 执行/ ,/ 记为/ bj/ 被/ 狆/ 犪/ 狋/ 犺/ i/ 覆盖/ ./ 在/ 本文/ 的/ 后续/ 章节/ 中/ (/ 如/ 算法/ 1/ )/ ,/ 我们/ 也/ 使用/ 狆/ 犪/ 狋/ 犺/ i/ (/ bk/ )/ 来/ 表示/ bk/ 在/ 覆盖/ 向量/ 狆/ 犪/ 狋/ 犺/ i/ 上/ 的/ 分量/ 值/ ./ 狆/ 犪/ 狋/ 犺/ i/ (/ bk/ )/ =/ 1/ 表示/ bk/ 在/ 狆/ 犪/ 狋/ 犺/ i/ 上/ 的/ 分量/ 值为/ 1/ ,/ 狆/ 犪/ 狋/ 犺/ i/ (/ bk/ )/ =/ 0/ 表示/ bk/ 在/ 狆/ 犪/ 狋/ 犺/ i/ 上/ 的/ 分量/ 值为/ 0/ ./ 例如/ ,/ 图/ 1/ 中/ t2/ 执行/ 的/ 覆盖/ 对应/ 的/ 向量/ 为/ 〈/ 1/ ,/ 0/ ,/ 0/ ,/ 1/ 〉/ ./ 虽然/ 覆盖/ 向量/ 并/ 不能/ 直接/ 等价/ 于/ 执行/ 路径/ [/ 15/ ]/ ,/ 即/ 相同/ 的/ 覆盖/ 向量/ 可能/ 对应/ 于/ 不同/ 的/ 执行/ 路径/ ./ 但是/ ,/ 覆盖/ 向量/ 可以/ 保持/ 本文/ 所/ 关注/ 的/ 覆盖/ 信息/ 的/ 一致性/ ,/ 而/ 覆盖/ 向量/ 的/ 获取/ 相对/ 完整/ 的/ 执行/ 路径/ 更/ 简单/ 便捷/ ./ 定义/ 5/ ./ 对于/ 程序/ 中/ 的/ 自定义/ 函数/ 和/ 主/ 函数/ ,/ 定义/ 函数/ 在/ 测试/ 集下/ 的/ 执行/ 轨迹/ 的/ 符号化/ 表示/ 为/ EXEM/ (/ fi/ )/ =/ {/ B/ ,/ T/ ,/ 犘/ 犃/ 犜/ 犎/ }/ ,/ 其中/ B/ 表示/ 函数/ fi/ 源代码/ 中/ 的/ 基本/ 代码/ 块/ 集合/ ,/ T/ 表示/ 测试/ 集中/ 的/ 所有/ 测试用例/ 的/ 集合/ ,/ 犘/ 犃/ 犜/ 犎/ =/ {/ 狆/ 犪/ 狋/ 犺/ 0/ ,/ 狆/ 犪/ 狋/ 犺/ 1/ ,/ …/ ,/ 狆/ 犪/ 狋/ 犺/ m/ }/ 表示/ 全部/ 测试用例/ 对应/ 的/ 覆盖/ 向量/ 集合/ ./ 根据/ 定义/ 4/ ,/ 我们/ 对/ 程序/ 的/ 每/ 一次/ 执行/ 分别/ 计算/ 其/ 覆盖/ 向量/ ,/ 即/ 覆盖/ 向量/ 和/ 测试/ 集中/ 的/ 测试用例/ 一一对应/ ./ 设定/ n/ 即为/ B/ 中/ 基本块/ 的/ 个数/ ,/ m/ 为/ T/ 中/ 测试用例/ 的/ 个数/ 即/ 程序执行/ 的/ 次数/ ,/ 那么/ 覆盖/ 向量/ 集合/ 犘/ 犃/ 犜/ 犎/ 是/ 由/ 多个/ 多维/ 向量/ 构成/ 的/ n/ ×/ m/ 的/ 矩阵/ ./ 此外/ ,/ 根据/ 程序执行/ 结果/ 的/ 不同/ ,/ 我们/ 将/ 执行/ 轨迹/ 分为/ 成功/ 执行/ 和/ 失效/ 执行/ 两类/ ,/ 分别/ 标记/ 为/ EXEMp/ 和/ EXEMf/ ./ 4.2/ 频繁/ 集/ 求解/ 依据/ 高/ 可疑/ 代码/ 与/ 错误代码/ 在/ 覆盖/ 向量/ 上/ 表现/ 出/ 的/ 一致性/ ,/ 假设/ 我们/ 能够/ 用/ 某种/ “/ 频繁/ 集/ ”/ 刻画出/ 与/ 高/ 可疑/ 代码/ 直接/ 相关/ 的/ 基本块/ 集合/ ,/ 那么/ ,/ 如果/ 高/ 可疑/ 代码/ 没有/ 错误/ ,/ 错误代码/ 则/ 存在/ 于/ 高/ 可疑/ 代码/ 的/ 频繁/ 集中/ ./ 在/ 我们/ 的/ 模型/ 中/ ,/ 频繁/ 集/ 按照/ 如下/ 的/ 方法/ 建立/ ./ 根据上述/ 分析/ ,/ 基于/ 关联/ 挖掘/ 的/ 错误/ 定位/ 模型/ 可/ 归结为/ 如下/ 描述/ ./ 模型/ 1/ ./ 待/ 考察/ 基本块/ bo/ ∈/ B/ 具有/ 一定/ 的/ 错误/ 可疑/ 度/ ,/ 同时/ 已知/ 程序/ 的/ 失效/ 执行/ 轨迹/ EXEMf/ ,/ Page6/ 则/ 错误/ 定位/ 的/ 对象/ 除了/ 包括/ 基本块/ bo/ 之外/ ,/ 还/ 包括/ 在/ EXEMf/ 中/ 在/ 所有/ 覆盖/ 向量/ 上/ 对/ bo/ 保持/ 覆盖/ 一致性/ 的/ 分量/ 所/ 对应/ 的/ 基本块/ ,/ 这些/ 分量/ 共同/ 构成/ 基本块/ bo/ 的/ 频繁/ 集/ ,/ bo/ 称之为/ 目标/ 基本块/ ./ 需要/ 说明/ 的/ 是/ ,/ 这里/ 所指/ 的/ 覆盖/ 一致性/ 需要/ 针对/ 目标/ 基本块/ bo/ 而言/ ,/ 与/ bo/ 保持/ 覆盖/ 一致性/ 的/ 分量/ 仅/ 包括/ 那些/ 在/ 所有/ EXEMf/ 覆盖/ 向量/ 中当/ bo/ 分量/ 为/ 1/ 时/ ,/ 该/ 分量/ 值/ 也/ 为/ 1/ ./ 此外/ ,/ 覆盖/ 一致性/ 是/ 单向/ 的/ ,/ 举例/ 而言/ ,/ b1/ 对/ b2/ 保持/ 覆盖/ 一致性/ 是/ 指当/ b2/ 分量/ 为/ 1/ 时/ ,/ b1/ 分量/ 总为/ 1/ ./ 但是/ 却/ 不能/ 推出/ b2/ 对/ b1/ 保持/ 覆盖/ 一致性/ ,/ 这/ 是因为/ 当/ b2/ 分量/ 为/ 0/ 时/ ,/ b1/ 分量/ 可以/ 为/ 1/ ./ 本文/ 后/ 文中/ 的/ 覆盖/ 一致性/ 均/ 是/ 此意/ ./ 由于/ 频繁/ 集内/ 的/ 基本块/ 具有/ 一定/ 的/ 执行/ 序列/ 关系/ ,/ 所以/ 我们/ 对/ 频繁/ 集/ 也/ 用/ 向量/ 形式/ 表示/ ./ 同时/ 为了/ 行文/ 方便/ ,/ 频繁/ 集中/ 的/ 项/ 也/ 称之为/ 频繁/ 集/ 的/ 分量/ ,/ 且/ 分量/ 依据/ 其/ 在/ 频繁/ 集中/ 的/ 位置/ 具有/ 一定/ 的/ 序号/ ./ 在/ 错误/ 可疑/ 度/ 的/ 计算/ 方面/ ,/ 本文/ 采用/ 现有/ 成果/ ,/ 并/ 按/ 可疑/ 度/ 从/ 大到/ 小/ 的/ 顺序/ 对/ 各个/ 代码/ 基本块/ 进行/ 排序/ ,/ 降序/ 排列/ 的/ 基本块/ 标记/ 为/ OBS/ ./ 建立/ 频繁/ 集/ 的/ 算法/ 见/ 算法/ 1/ ./ 算法/ 1/ 中/ bk/ 为/ 目标/ 代码/ ,/ 犳/ 犵/ (/ bk/ )/ 表示/ 对/ bk/ 保持/ 频繁/ 一致性/ 的/ 分量/ 集/ ,/ 即/ 求解/ 出/ 的/ 以/ bk/ 为/ 目标/ 代码/ 的/ 频繁/ 集/ ./ 首先/ 初始化/ 犳/ 犵/ (/ bk/ )/ 为/ 单位向量/ ,/ 然后/ 依次/ 遍历/ bk/ 分量/ 不为/ 0/ 的/ 覆盖/ 向量/ 并/ 将/ 该/ 覆盖/ 向量/ 与/ 犳/ 犵/ (/ bk/ )/ 进行/ 向量/ 的/ 与/ 操作/ ./ 最后/ 可得/ bk/ 的/ 频繁/ 集/ ./ 算法/ 1/ ./ 频繁/ 集/ 求解/ ./ 输入/ :/ OBS/ ,/ EXEMf/ 输出/ :/ 犉/ 犌/ (/ 频繁/ 集/ 集合/ )/ 符号/ 表示/ :/ 犳/ 犵/ (/ bk/ )/ :/ 以/ bk/ 为/ 目标/ 代码/ 的/ 频繁/ 集/ ,/ u/ ∧/ v/ :/ 向量/ 与/ 操作/ 犐/ :/ 单位向量/ ,/ 维度/ 为/ 基本块/ 个数/ 初始化/ :/ 犉/ 犌/ ←/ / 1/ ./ foreachbk/ ∈/ OBS2/ ./ 犳/ 犵/ (/ bk/ )/ ←/ 犐/ 3/ ./ foreach/ 狆/ 犪/ 狋/ 犺/ i/ ∈/ 犘/ 犃/ 犜/ 犎/ 4/ ./ if/ 狆/ 犪/ 狋/ 犺/ i/ (/ bk/ )/ >/ 0then5/ ./ 犳/ 犵/ (/ bk/ )/ ←/ 犳/ 犵/ (/ bk/ )/ ∧/ 狆/ 犪/ 狋/ 犺/ i6/ ./ endif7/ ./ endfor8/ ./ 犉/ 犌/ ←/ 犉/ 犌/ ∪/ 犳/ 犵/ (/ bk/ )/ 9/ ./ endfor4/ ./ 3/ 代码/ 检查/ 次序/ 组织/ 通过/ 频繁/ 集/ 挖掘/ ,/ 我们/ 可以/ 获得/ 与/ 待/ 检查/ 代码/ ,/ 尤其/ 对/ 高/ 可疑/ 代码/ 保持/ 覆盖/ 一致性/ 的/ 代码/ 语句/ 序列/ ./ 如果/ 高/ 可疑/ 代码/ 不是/ 错误代码/ ,/ 我们/ 可以/ 通过/ 优先/ 检查/ 频繁/ 集中/ 的/ 代码/ 语句/ 的/ 方式/ 来/ 组织/ 检查/ 顺序/ ,/ 以/ 减小/ 代码/ 检查/ 率/ ./ 事实上/ ,/ 本文/ 的/ 方法/ 依据/ 程序执行/ 覆盖/ 信息/ 中/ 的/ 向量分析/ 提出/ 了/ 一种/ 用以/ 提高/ 错误/ 定位/ 有效性/ 的/ 待/ 检查/ 的/ 代码/ 语句/ 的/ 次序/ 组织/ 方法/ ./ 在/ Tarantula/ 等/ 方法/ 中/ ,/ 每条/ 代码/ 语句/ 具有/ 独立/ 可疑/ 度/ ,/ 而/ 本文/ 方法/ 计算/ 得到/ 的/ 频繁/ 集则/ 是/ 一组/ 代码/ 语句/ 序列/ ,/ 为了/ 能够/ 与/ 之前/ 的/ 方法/ 形成/ 对比/ ,/ 我们/ 设计/ 了/ 如下/ 的/ 待/ 检查/ 代码/ 语句/ 排序/ 方式/ :/ (/ 1/ )/ 依据/ CBFL/ 方法/ 计算/ 每一/ 基本块/ 的/ 错误/ 可疑/ 度/ ;/ 并/ 将/ 各/ 基本块/ 按照/ 其/ 可疑/ 度/ 的/ 大小/ 降序/ 排列/ ./ (/ 2/ )/ 从/ 排序/ 后/ 的/ 列表/ 中/ 依次/ 检查/ 基本块/ 是否/ 含有/ 错误/ ,/ 如果/ 确认/ 错误/ 存在/ ,/ 转/ (/ 5/ )/ ,/ 否则/ 转/ (/ 3/ )/ ./ (/ 3/ )/ 将/ 没有/ 错误/ 的/ 基本块/ 作为/ 目标/ 代码/ ,/ 依据/ 覆盖/ 信息/ 矩阵/ 求解/ 其/ 频繁/ 集/ ./ (/ 4/ )/ 将/ 频繁/ 集中/ 的/ 基本块/ 依据/ 其/ 可疑/ 度/ 大小/ 降序/ 排列/ ,/ 依次/ 检查/ 各/ 基本块/ 是否/ 含有/ 错误/ ,/ 如果/ 定位/ 出/ 错误/ ,/ 转/ (/ 5/ )/ ,/ 否则/ 转/ (/ 2/ )/ ./ (/ 5/ )/ 统计/ 已/ 检查/ 的/ 基本块/ 数量/ ./ 针对/ 相同/ 可疑/ 度/ 的/ 不同/ 基本块/ 之间/ 的/ 检查/ 次序/ 问题/ ,/ 本文/ 在/ 计算/ 代码/ 检查/ 率时/ 采取/ 最差/ 检查/ 策略/ [/ 23/ ]/ ,/ 即将/ 所有/ 与/ 错误代码/ 具有/ 相同/ 可疑/ 度/ 的/ 代码/ 都/ 认定/ 为/ 定位/ 错误/ 所/ 必须/ 检查/ 的/ 代码/ ./ 4.4/ 复杂度/ 分析/ 本文/ 方法/ 的/ 复杂度/ 主要/ 体现/ 在/ 频繁/ 集/ 的/ 求解/ 上面/ ./ 依据/ 不同/ 类型/ 的/ 错误/ ,/ 复杂度/ 也/ 会/ 不同/ ./ 设定/ 程序/ 源代码/ 中/ 的/ 某/ 函数/ 代码/ 的/ 基本块/ 数量/ 为/ bm/ ,/ 测试用例/ 个数/ 为/ tm/ ./ 如果/ 程序/ 中仅/ 含有/ 一个/ 错误/ 且/ 该/ 错误/ 不是/ 代码/ 缺失/ 性/ 错误/ ,/ 则/ 通过/ 一次/ 的/ 频繁/ 集/ 求解/ 则/ 可/ 定位/ 出/ 错误/ ,/ 复杂度/ 为/ O/ (/ bm/ ×/ tm/ )/ ./ 如果/ 程序/ 中/ 含有/ 多个/ 错误/ ,/ 则/ 频繁/ 集/ 求解/ 过程/ 需要/ 进行/ 多次/ ,/ 最坏/ 的/ 情况/ 是/ 对/ 每/ 一行/ 代码/ 语句/ 均/ 求解/ 其/ 频繁/ 集/ ,/ 复杂度/ 为/ O/ (/ b2m/ ×/ tm/ )/ ./ 5/ 实验/ 及/ 结果/ 分析/ 在/ 程序/ 没有/ 崩溃/ 而/ 被/ 正常/ 捕获/ 异常/ 的/ 情况/ 下/ ,/ 基本/ 代码/ 块/ 内/ 所有/ 的/ 代码/ 语句/ 是/ 连续/ 执行/ 的/ ,/ 因而/ 具有/ 相同/ 的/ 覆盖率/ ./ 本文/ 在/ 实验/ 部分/ 采用/ 代码/ 语句/ 作为/ 错误/ 可疑/ 度/ 计算/ 的/ 最小/ 粒度/ [/ 11/ ,/ 15/ ]/ ./ 5.1/ 实验/ 建立/ 参照/ 之前/ CBFL/ 的/ 相关/ 研究/ ,/ 本文/ 采用/ 3/ 个经/ Page7/ 常用/ 到/ 的/ 实际/ Unix/ 程序/ (/ flex/ ,/ gzip/ ,/ grep/ )/ 和/ SIR/ [/ 24/ ]/ 提供/ 的/ Siemens/ 程序/ 集/ 作为/ 实验/ 对象/ ./ flex/ ,/ gzip/ ,/ grep/ 的/ 代码/ 行数/ 在/ 8000/ ~/ 10000/ 之间/ ,/ 而/ Siemens/ 程序/ 集中/ 的/ 7/ 个/ 程序代码/ 量/ 较/ 小/ ,/ 相比/ Siemens/ 程序/ 集/ 而言/ ,/ Unix/ 程序/ 是/ 实际/ 的/ 应用程序/ 且/ 程序结构/ 更加/ 复杂/ ,/ 经常/ 被/ 相关/ 研究/ 当作/ 实验/ 对象/ [/ 5/ ,/ 23/ ,/ 25/ ]/ ./ 表/ 1/ 所示/ 为/ 本文/ 实验/ 中/ 的/ 程序/ 及/ 相应/ 的/ 测试用例/ 集/ ./ 与/ 之前/ 的/ 研究/ 一样/ [/ 5/ ,/ 8/ ]/ ,/ 我们/ 在/ 实验/ 中/ 去掉/ 了/ 那些/ 不能/ 被/ 测试/ 集中/ 的/ 测试用例/ 触发/ 的/ 错误/ ,/ 实际/ 实验/ 中/ 的/ 错误/ 版本/ 数量/ 共计/ 为/ 222/ ./ flexgrepgzipprint/ _/ tokensprint/ _/ tokens2replacescheduleschedule2tcastot/ _/ info/ 合计/ 我们/ 的/ 实验/ 平台/ 是/ ubuntu10/ ./ 4/ ,/ 编译器/ 为/ gcc/ -/ 4.4/ ./ 1/ ,/ 使用/ gcc/ 的/ 组件/ gcov/ 来/ 收集/ 执行/ 轨迹/ ./ 5.2/ 评估/ 指标/ 在/ 评估/ 错误/ 定位/ 结果/ 的/ 优劣/ 上/ 本文/ 采用/ 定位/ 错误/ 所/ 需/ 检查/ 的/ 代码/ 比例/ (/ 简称/ 代码/ 检查/ 率/ )/ 作为/ 评估/ 指标/ ./ 按照/ CBFL/ 计算方法/ ,/ 不同/ 的/ 代码/ 语句/ 或/ 谓词/ 可/ 分别/ 计算/ 得到/ 不同/ 的/ 错误/ 可疑/ 度/ ,/ 代码/ 语句/ 的/ 错误/ 可疑/ 度越/ 高则/ 意味着/ 该/ 代码/ 语句/ 越/ 应该/ 被/ 优先/ 检查/ ,/ 然后/ 对/ 程序/ 内/ 的/ 所有/ 代码/ 语句/ 依据/ 其/ 错误/ 可疑/ 度/ 进行/ 降序/ 排列/ ./ 所谓/ 代码/ 检查/ 率/ ,/ 则/ 是/ 指/ 从/ 错误/ 可疑/ 度/ 最大/ 的/ 代码/ 语句/ 开始/ 检查/ ,/ 到/ 检查/ 到/ 含有/ 错误/ 图/ 3/ 中/ 的/ 实线/ 分别/ 表示/ 基于/ 关联/ 挖掘/ 的/ AM/ -/ Jaccard/ 、/ AM/ -/ Ochiai/ 、/ AM/ -/ Tarantula/ 和/ AM/ -/ SBI/ 方法/ 图/ 3Unix/ 实验/ 结果/ 总体/ 对比/ 的/ 代码/ 语句/ 时/ 的/ 代码/ 检查/ 总量/ 占/ 全部/ 可/ 执行/ 代码/ 的/ 比例/ ./ 可/ 执行/ 代码/ 不/ 包括/ 程序/ 注释/ 、/ 空行/ 、/ 函数/ 及/ 变量/ 声明/ 、/ 类型/ 等/ ./ 本文/ 分别/ 采用/ 了/ 两种/ 不同/ 实验/ 结果/ 体现/ 方法/ :/ (/ 1/ )/ 在/ 一定/ 代码/ 检查/ 率/ 范围/ 内/ ,/ 不同/ 的/ 定位/ 方法/ 所/ 能够/ 定位/ 出/ 的/ 错误/ 比例/ ;/ (/ 2/ )/ 不同/ 方法/ 在/ 定位/ 同一/ 错误/ 时/ 所/ 需/ 的/ 代码/ 检查/ 率/ ./ 5.3/ 实验/ 结果/ 总体/ 分析/ 本文/ 分别/ 采用/ Jaccard/ [/ 4/ ]/ 、/ Ochiai/ [/ 4/ ]/ 、/ Tarantula/ [/ 11/ ]/ 和/ SBI/ [/ 15/ ]/ 方法/ 计算/ 代码/ 的/ 错误/ 可疑/ 度/ ./ Jaccard/ 、/ Ochiai/ 和/ Tarantula/ 方法/ 都/ 是/ 基于/ 代码/ 语句/ 的/ 定位/ 方法/ ,/ 具有/ 很强/ 的/ 代表性/ ,/ 且/ 经常/ 被/ 相关/ 研究/ 用作/ 对比/ 分析/ ./ CBI/ [/ 12/ ]/ 是/ 基于/ 谓词/ 的/ 定位/ 方法/ 的/ 代表/ ./ 文献/ [/ 15/ ]/ 将/ CBI/ 方法/ 修改/ 为/ 基于/ 代码/ 语句/ 的/ SBI/ 方法/ ,/ 因此/ 我们/ 也/ 将/ SBI/ 方法/ 用作/ 对比/ ./ 除此之外/ ,/ 基于/ 谓词/ 的/ 代表性/ 方法/ 还/ 包括/ Liblit05/ [/ 13/ ]/ 和/ SOBER/ [/ 14/ ]/ ,/ 但是/ 由于/ Liblit05/ 和/ SOBER/ 方法/ 更/ 多/ 的/ 是/ 依据/ 谓词/ 的/ 真假/ 在/ 不同/ 执行/ 中/ 体现/ 出来/ 的/ 频谱/ 差距/ ,/ 这/ 与/ 本文/ 中/ 代码/ 语句/ 的/ 可疑/ 度/ 计算/ 略有不同/ ,/ 我们/ 没有/ 将/ Liblit05/ 和/ SOBER/ 用作/ 对比/ ./ 本文/ 方法/ 中/ 的/ 代码/ 语句/ 的/ 错误/ 可疑/ 度/ 计算/ 也/ 分别/ 采用/ Jaccard/ 、/ Ochiai/ 、/ Tarantula/ 和/ SBI/ 方法/ ,/ 并/ 分别/ 命名/ 为/ AM/ -/ Jaccard/ 、/ AM/ -/ Ochiai/ 、/ AM/ -/ Tarantula/ 和/ AM/ -/ SBI/ 方法/ ./ 由于/ flex/ 、/ grep/ 、/ gzip/ 等/ 3/ 个/ 实际/ 的/ Unix/ 程序/ 和/ Siemens/ 程序/ 集在/ 程序/ 来源/ 和/ 源代码/ 规模/ 上均/ 不同/ ,/ 所以/ 我们/ 分别/ 针对/ Unix/ 程序/ 和/ Siemens/ 程序/ 集/ 建立/ 了/ 实验/ ./ Unix/ 程序/ 实验/ 结果/ 如图/ 3/ 所示/ ./ 图中/ 横坐标/ 表示/ 代码/ 检查/ 率/ ,/ 纵坐标/ 表示/ 在/ 一定/ 的/ 代码/ 检查/ 率/ 范围/ 内/ 能够/ 定位/ 出/ 的/ 错误/ 个数/ 占/ 错误/ 总数/ 的/ 比例/ ./ 所/ 能够/ 定位/ 出/ 的/ 错误/ 比例/ 随/ 代码/ 检查/ 率/ 的/ 变化趋势/ ,/ 虚线/ 分别/ 表示/ Jaccard/ 、/ Ochiai/ 、/ Tarantula/ 和/ SBIPage8/ 方法/ 所/ 能够/ 定位/ 出/ 的/ 错误/ 比例/ 随/ 代码/ 检查/ 率/ 的/ 变化趋势/ ./ 相同/ 代码/ 检查/ 率下/ ,/ 定位/ 出/ 错误/ 的/ 比例/ 越高/ 说明/ 方法/ 越/ 有效/ ./ 从图/ 3/ 中/ 可以/ 看出/ ,/ 在/ Unix/ 的/ 3/ 个/ 程序/ 上/ ,/ AM/ -/ Jaccard/ 、/ AM/ -/ Ochiai/ 、/ AM/ -/ Tarantula/ 和/ AM/ -/ SBI/ 方法/ 在/ 定位/ 效果/ 上/ 都/ 要/ 好/ 于/ 原始/ 方法/ ./ 比如/ ,/ 在/ 10/ %/ 的/ 代码/ 检查/ 率/ 范围/ 内/ ,/ AM/ -/ Jaccard/ 的/ 定位/ 结果/ 为/ 74.5/ %/ ,/ 而/ Jaccard/ 的/ 结果/ 为/ 66.1/ %/ ;/ AM/ -/ Ochiai/ 的/ 定位/ 结果/ 为/ 73.9/ %/ ,/ 而/ Ochiai/ 的/ 结果/ 为/ 67.6/ %/ ;/ AM/ -/ Tarantula/ 方法/ 能够/ 定位/ 出/ 69.1/ %/ 的/ 错误/ ,/ 而/ Tarantula/ 方法/ 能够/ 定位/ 出/ 59.8/ %/ 的/ 错误/ ;/ 同样/ 的/ ,/ AM/ -/ SBI/ 的/ 定位/ 结果/ 为/ 63.5/ %/ ,/ 而/ SBI/ 的/ 结果/ 为/ 54.3/ %/ ./ 对于/ flex/ 、/ grep/ 和/ gzip3/ 个/ Unix/ 程序/ ,/ 从图/ 3/ 可以/ 看出/ ,/ 在/ 代码/ 检查/ 率/ 很/ 低时/ (/ 比如/ 5/ %/ )/ ,/ 本文/ 的/ 方法/ 和/ 其它/ 方法/ 相比/ 并/ 没有/ 明显/ 优势/ ./ 这种/ 情况/ 产生/ 的/ 原因/ 是/ ,/ 错误/ 定位/ 所/ 需/ 的/ 代码/ 检查/ 率越/ 低/ ,/ 说明/ 错误代码/ 与/ 错误/ 可疑/ 度/ 之间/ 的/ 表现/ 关系/ 越/ 明显/ ,/ 如/ 2.2/ 节中/ 的/ 情形/ 1/ ./ 通常/ 情况/ 下/ ,/ 这种/ 错误/ 的/ 触发/ 是/ 很/ 容易/ 被/ 观察/ 并/ 检测/ 到/ 的/ ./ 然而/ ,/ 对于/ 需要/ 较大/ 代码/ 检查/ 率/ 才能/ 定位/ 出/ 的/ 错误/ ,/ 错误/ 可疑/ 度/ 很/ 高/ 的/ 代码/ 很多/ 情况/ 下/ 并/ 没有/ 错误/ ,/ 而是/ 受到/ 了/ 程序/ 感染/ 状态/ 的/ 传递/ 或者/ 代码执行/ 后/ 产生/ 了/ 能够/ 触发/ 错误/ 的/ 数据/ 状态/ ,/ 如/ 2.2/ 节中/ 的/ 情形/ 2/ 和/ 情形/ 3/ ./ 定位/ 这种/ 错误/ 往往/ 需要/ 沿着/ 程序/ 的/ 执行/ 路径/ 进行/ 审查/ ,/ 会/ 花费/ 更大/ 的/ 代价/ ,/ 本文/ 方法/ 正是/ 在/ 定位/ 此类/ 错误/ 时/ 效果显著/ ./ 除此之外/ ,/ 我们/ 还/ 统计/ 了/ AM/ -/ Jaccard/ 、/ AM/ -/ Ochiai/ 、/ AM/ -/ Tarantula/ 和/ AM/ -/ SBI/ 方法/ 在/ 不同/ 的/ 程序/ 集/ 样本/ 上/ 相对/ 于/ Jaccard/ 、/ Ochiai/ 、/ Tarantula/ 和/ SBI/ 方法/ 的/ 有效性/ 增益/ ./ 在/ 评估/ 指标/ 下/ ,/ 方法/ 的/ 有效/ 图/ 4Siemens/ 实验/ 结果/ 总体/ 对比/ 图/ 4/ 是/ Siemens/ 程序/ 实验/ 结果/ ,/ 图中/ 横坐标/ 和/ 纵坐标/ 具有/ 和/ 图/ 3/ 中横/ 纵坐标/ 相同/ 的/ 含义/ ./ 图/ 4/ 表示/ ,/ 在/ Siemens/ 程序/ 集/ 的/ 实验/ 上/ ,/ AM/ -/ Jaccard/ 、/ AM/ -/ 性/ 体现/ 在/ 定位/ 错误/ 所/ 需/ 检查/ 的/ 代码/ 语句/ 的/ 比例/ ,/ 因而/ ,/ 方法/ 有效性/ 增益/ 定义/ 为/ 基于/ 关联/ 挖掘/ 的/ 方法/ 所/ 带来/ 的/ 代码/ 检查/ 率/ 的/ 降低/ 占原/ 方法/ 中/ 代码/ 检查/ 率/ 的/ 比例/ ./ 以/ AM/ -/ Jaccard/ 和/ Jaccard/ 为例/ 进行/ 说明/ ,/ AM/ -/ Jaccard/ 相对/ 于/ Jaccard/ 的/ 有效性/ 增益/ 为/ Δ/ E/ =/ ∑/ n/ (/ 1/ -/ EffectivenessAM/ -/ J/ (/ vi/ )/ // EffectivenessJ/ (/ vi/ )/ )/ 其中/ n/ 为/ 错误/ 版本/ 数量/ ,/ EffectivenessAM/ -/ J/ (/ vi/ )/ 和/ EffectivenessJ/ (/ vi/ )/ 分别/ 指定/ 位/ vi/ 版本/ 中/ 的/ 错误/ 所/ 需/ 的/ 代码/ 检查/ 率/ ./ 按此/ 方法/ 计算/ 得到/ 的/ 分析/ 结果/ 如表/ 2/ 所示/ ./ 表/ 2/ 本文/ 方法/ 在/ 不同/ Unix/ 程序/ 集/ 样本/ 上/ 的/ 有效性/ 增益/ 分析/ i/ =/ 1/ [/ -/ 50/ %/ ,/ 50/ %/ ]/ [/ -/ 0.5/ %/ ,/ 0.5/ %/ ]/ </ -/ 0.5/ %/ >/ 0.5/ %/ </ -/ 5/ %/ [/ -/ 5/ %/ ,/ 5/ %/ ]/ >/ 5/ %/ </ -/ 50/ %/ >/ 50/ %/ 从表/ 2/ 中/ 可以/ 看出/ ,/ 在/ Unix/ 程序/ 集上/ ,/ AM/ -/ Jaccard/ 、/ AM/ -/ Ochiai/ 、/ AM/ -/ Tarantula/ 和/ AM/ -/ SBI/ 方法/ 相比/ Jaccard/ 、/ Ochiai/ 、/ Tarantula/ 和/ SBI/ 方法/ 能够/ 提高/ 错误/ 定位/ 的/ 准确率/ ,/ 比如/ ,/ AM/ -/ Jaccard/ 方法/ 相比/ Jaccard/ 能够/ 将/ 其中/ 的/ 15/ 个/ 错误/ 的/ 定位/ 有效性/ 提高/ 50/ %/ 以上/ ,/ 同时/ ,/ 只/ 对/ 8/ 个/ 程序/ 产生/ 了/ 副作用/ (/ Jaccard/ 的/ 有效性/ 相比/ AM/ -/ Jaccard/ 高/ 50/ %/ 以上/ )/ ./ 从表/ 2/ 中/ 可以/ 观察/ 到/ ,/ AM/ -/ 方法/ 在/ Tarantula/ ,/ Ochiai/ ,/ 和/ SBI/ 方法/ 上/ 表现/ 出/ 了/ 类似/ 的/ 效果/ ,/ 这里/ 不再/ 赘述/ ./ Ochiai/ 、/ AM/ -/ Tarantula/ 和/ AM/ -/ SBI/ 方法/ 相比/ 其/ 原始/ 方法/ 并/ 没有/ 表现/ 出/ 同样/ 稳定/ 的/ 有效性/ 增益/ 效果/ ./ 例如/ ,/ 相比/ Jaccard/ 和/ AM/ -/ Jaccard/ ,/ 后者/ 在/ 10/ %/ ~/ Page930/ %/ 和/ 50/ %/ ~/ 100/ %/ 的/ 代码/ 检查/ 率/ 情况/ 下/ 表现/ 出/ 优势/ ,/ 而/ 前者/ 在/ 0/ %/ ~/ 10/ %/ 及/ 30/ %/ ~/ 50/ %/ 的/ 代码/ 检查/ 率/ 情况/ 下/ 表现/ 出/ 优势/ ./ 在/ Ochiai/ 方法/ 上/ ,/ 本文/ 提出/ 的/ 关联/ 挖掘/ 方法/ (/ 以下/ 简记/ 为/ AM/ -/ 方法/ )/ 的/ 使用/ 表现/ 出/ 同样/ 的/ 效果/ ;/ 而/ 在/ Tarantula/ 和/ SBI/ 方法/ 上/ ,/ AM/ -/ 方法/ 的/ 使用/ 甚至/ 表现/ 出/ 有效性/ 的/ 退化/ 趋势/ ./ 我们/ 进而/ 用表/ 3/ 对/ Siemens/ 程序/ 的/ 结果/ 进行/ 进一步/ 分析/ (/ 表/ 3/ 的/ 含义/ 和表/ 2/ 类似/ )/ ./ 从表/ 3/ 中/ 还/ 可以/ 得到/ 与/ 图/ 4/ 一致/ 的/ 分析/ 结果/ :/ 在/ Siemens/ 程序/ 集上/ ,/ AM/ -/ Jaccard/ 、/ AM/ -/ Ochiai/ 、/ AM/ -/ Tarantula/ 和/ AM/ -/ SBI/ 方法/ 相比/ Jaccard/ 、/ Ochiai/ 、/ Tarantula/ 和/ SBI/ 方法/ 没有/ 明显/ 的/ 有效性/ 增益/ ,/ 通过/ 500/ %/ 增益/ 的/ 数目/ 统计/ 比较/ ①/ ,/ 我们/ 发现/ ,/ 对于/ 及/ 个别/ 的/ 错误/ 版本/ (/ 少于/ 5/ 个/ )/ ,/ Ochiai/ 程序/ 的/ 有效性/ 甚至/ 能够/ 达到/ AM/ -/ Ochiai/ 程序/ 有效性/ 的/ 500/ %/ 以上/ ./ 这样/ 的/ 意外/ 结果/ 显然/ 是/ 造成/ 本文/ 方法/ 在/ Siemens/ 程序/ 上/ 效果/ 欠图/ 5/ 不同/ 程序/ 的/ 实验/ 结果/ 独立/ 对比/ 从图/ 5/ 可以/ 看出/ ,/ 各个/ 程序/ 的/ 实验/ 结果/ 与/ 总体/ 结果/ 类似/ ,/ 本文/ 方法/ 在/ flex/ 和/ gzip/ 程序/ 样本/ 上/ 表现/ 出/ 优势/ ,/ 而/ 在/ grep/ 程序/ 上/ 尚存有/ 不足/ ./ 针对/ 这一/ 问题/ ,/ 我们/ 将/ 在/ 本文/ 的/ 第/ 6/ 节/ 通过/ 代码/ 架构/ 、/ 错误/ 类型/ 等/ 展开/ 详细分析/ ./ 同时/ ,/ 我们/ 采用/ t/ 检验/ [/ 26/ ]/ 对/ Jaccard/ 和/ AM/ -/ Jaccard/ 、/ Ochiai/ 和/ AM/ -/ Ochiai/ 、/ Tarantula/ 和/ AM/ -/ Tarantula/ 以及/ SBI/ 和/ AM/ -/ SBI/ 在/ 不同/ 程序/ 中/ 的/ 结果/ 进行/ 了/ 假设检验/ ./ 如表/ 4/ 所示/ ,/ 在/ Unix/ 程序/ 上/ ,/ Jaccard/ 同/ AM/ -/ Jaccard/ 的/ t/ -/ test/ 分析/ 结果/ 为/ 0.0075/ ./ 这/ 可以/ 直观/ 地/ 解释/ 为/ ,/ Jaccard/ 方法/ 在/ Unix/ 程序/ 上/ 的/ 效果/ 和/ AM/ -/ Jaccard/ 方法/ 在/ Unix/ 程序/ 上/ 的/ 效果/ 来自/ 同一/ 分布/ 的/ 可能性/ 为/ 0.75/ %/ ./ 如果/ 我们/ 把/ 常用/ 的/ 5/ %/ 作为/ 阈值/ [/ 26/ ]/ ,/ 可以/ 排除/ “/ 二者/ 没有/ 显著/ 区别/ ”/ 的/ 假设/ ./ 因为/ 我们/ 在/ 图/ 3/ ,/ 表/ 3/ 和/ 图/ 5/ 中/ 都/ 观察/ 到/ ,/ AM/ -/ Jaccard/ 方法/ 相比/ Jaccard/ 方法/ 在/ 平均/ 意义/ 上/ 具有/ 一般性/ 优势/ ,/ 因此/ 我们/ 通过/ 假设检验/ 得出/ 结果/ ,/ 在/ Unix/ 程序/ 佳/ 的/ 原因/ ./ 表/ 3/ 本文/ 方法/ 在/ 不同/ Siemens/ 程序/ 集/ 样本/ 上/ 的/ 有效性/ 增益/ 分析/ [/ -/ 0.05/ %/ ,/ 0.05/ %/ ]/ </ -/ 0.05/ %/ >/ 0.05/ %/ </ -/ 5/ %/ [/ -/ 5/ %/ ,/ 5/ %/ ]/ >/ 5/ %/ [/ -/ 500/ %/ ,/ 500/ %/ ]/ </ -/ 500/ %/ >/ 500/ %/ 这一/ 原因/ 我们/ 将/ 在/ 第/ 6/ 节中/ 进行/ 分析/ ./ 5.4/ 不同/ 程序/ 的/ 独立/ 结果/ 分析/ 和/ 相互/ 比较/ 程序结构/ 的/ 不同/ 可能/ 会/ 影响/ 实验/ 结果/ ,/ 为了/ 更好/ 地/ 说明/ 本/ 方法/ 的/ 有效性/ ,/ 我们/ 又/ 分别/ 统计/ 了/ 各种/ 方法/ 应用/ 在/ flex/ 、/ grep/ 和/ gzip/ 等/ 程序/ 上/ 的/ 实验/ 结果/ ②/ ,/ 如图/ 5/ 所示/ ./ 上/ ,/ AM/ -/ Jaccard/ 方法/ 相比/ Jaccard/ 方法/ 具有/ 假设检验/ 含义/ 中/ 的/ “/ 显著/ ”/ 优势/ ./ AM/ -/ 方法/ 在/ Ochiai/ ,/ Taran/ -/ tula/ 和/ SBI/ 方法/ 上/ 的/ 效果/ 可以/ 类似/ 地/ 解释/ ./ AM/ -/ Jaccard/ 同/ Jaccard/ 比较/ 0.00750/ ./ 00480.00800/ ./ 0079AM/ -/ Jaccard/ 同/ Jaccard/ 比较/ 0.35780/ ./ 05040.02820/ ./ 0282/ 在/ 表/ 4/ 中/ ,/ 我们/ 同时/ 观察/ 到/ ,/ 如果/ 以/ 5/ %/ 作为/ 阈值/ ,/ Jaccard/ 和/ AM/ -/ Jaccard/ 在/ Siemens/ 程序/ 上/ ,/ 以及/ ①/ ②/ Page10Ochiai/ 和/ AM/ -/ Ochiai/ 在/ Siemens/ 程序/ 上/ “/ 没有/ 显著/ 区别/ ”/ 的/ 假设/ 不能/ 被/ 排除/ ./ 因此/ ,/ 我们/ 认为/ ,/ Jaccard/ 和/ AM/ -/ Jaccard/ 在/ Siemens/ 程序/ 上/ 以及/ Ochiai/ 和/ AM/ -/ Ochiai/ 在/ Siemens/ 程序/ 上/ 的/ 效果/ 没有/ 显著/ 区别/ ./ 这/ 和/ 我们/ 对图/ 4/ 的/ 分析/ 是/ 一致/ 的/ ./ 同时/ ,/ 由于/ 我们/ 在/ 图/ 4/ 中/ 观察/ 到/ AM/ -/ 方法/ 在/ Tarantula/ 和/ SBI/ 方法/ 上/ 的/ 使用/ 会/ 带来/ 效果/ 退化/ 的/ 趋势/ ,/ 结合/ 二者/ 的/ t/ -/ test/ 结果/ (/ 均/ 为/ 0.0282/ )/ ,/ 我们/ 可以/ 以/ 5/ %/ 为/ 阈值/ 拒绝/ “/ 二者/ 没有/ 显著/ 区别/ ”/ 的/ 假设/ ,/ 并/ 得出结论/ —/ —/ —/ 在/ Siemens/ 方法/ 上/ ,/ AM/ -/ 方法/ 在/ Tarantula/ 和/ SBI/ 方法/ 上/ 的/ 使用/ 将/ 降低/ Tarantula/ 和/ SBI/ 的/ 差错/ 效果/ ./ 这一/ 现象/ 与/ 我们/ 在/ 表/ 3/ 和/ 图/ 4/ 中/ 的/ 观察/ 结果/ 是/ 一致/ 的/ ./ 我们/ 将/ 在/ 第/ 6/ 节中/ 对/ 其/ 原因/ 进行/ 分析/ ./ 我们/ 进一步/ 分析/ AM/ -/ 方法/ 在/ 不同/ 方法/ 上/ 的/ 应用/ 是否/ 有/ 一致/ 的/ 效果/ 增益/ ./ 表/ 5/ 用/ t/ -/ test/ 检查/ 了/ AM/ -/ 方法/ 在/ 不同/ 方法/ 上/ 使用/ 时/ 是否/ 有/ 显著/ 的/ 差异/ ./ 应用/ 同/ 上/ 一节/ 中/ 类似/ 的/ 分析方法/ ,/ 我们/ 可以/ 得出/ 以表/ 5/ 不同/ 方法/ 间/ 的/ 效果/ 增益/ 比较/ 的/ 假设检验/ 分析/ AM/ -/ SBI/ 的/ 增益/ 0.29010/ ./ 31950.2559/ AM/ -/ Tarantula/ 的/ AM/ -/ Ochiai/ 的/ 增益/ 0.3647/ 增益/ 0.29010/ ./ 3195AM/ -/ SBI/ 的/ 增益/ 0.01000/ ./ 60951.0000/ AM/ -/ Tarantula/ 的/ AM/ -/ Ochiai/ 的/ 增益/ 0.0389/ 增益/ 0.01000/ ./ 6095/ 图/ 6/ 针对/ 不同/ 错误/ 的/ 代码/ 覆盖率/ 横向/ 比较/ 如图/ 6/ 所示/ ,/ 在/ 选出/ 的/ 26/ 个/ 不同/ 错误/ 中/ ,/ 有/ 15/ 个/ 错误/ 在/ AM/ -/ Tarantula/ 方法/ 下/ 的/ 代码/ 检查/ 率/ 明显/ 低于/ 在/ Tarantula/ 方法/ 下/ 的/ 代码/ 检查/ 率/ ,/ 4/ 个/ 错误/ 在/ 两种/ 方法/ 下/ 的/ 代码/ 检查/ 率/ 相等/ ,/ 另外/ 有/ 7/ 个/ 错误/ 在/ AM/ -/ Tarantula/ 方法/ 下/ 的/ 代码/ 检查/ 率/ 高于/ 在/ 下/ 的/ 结论/ ./ 以/ 5/ %/ 为/ 阈值/ 进行/ 分析/ ,/ 在/ Unix/ 程序/ 上/ ,/ AM/ -/ 方法/ 在/ Jaccard/ 、/ Ochiai/ 、/ Tarantula/ 和/ SBI/ 上面/ 分别/ 使用/ 时/ ,/ 会/ 带来/ 普遍/ 的/ 效果/ 增益/ ,/ 并/ 无/ “/ 显著/ ”/ 区别/ ./ 同理/ ,/ 在/ Siemens/ 程序/ 上/ ,/ AM/ -/ 方法/ 在/ Jaccard/ 上/ 的/ 使用/ 和/ 在/ 其它/ 3/ 种/ 方法/ 上/ 的/ 使用/ 有/ 显著/ 的/ 效果/ 区别/ ;/ 在/ Ochiai/ 上/ 的/ 使用/ 和/ 在/ SBI/ 、/ Tarantula/ 上/ 的/ 使用/ 没有/ 显著/ 的/ 效果/ 区别/ ;/ 在/ SBI/ 和/ Tarantula/ 上/ 使用/ 时/ 效果/ 完全一致/ ./ 这样/ 的/ 结果/ 与/ 图/ 4/ 的/ 观察/ 结果/ 是/ 一致/ 的/ ./ 结合/ 表/ 2/ 和表/ 3/ 的/ 数据/ ,/ 通过/ 假设检验/ ,/ 我们/ 得出/ 以下/ 的/ 结论/ ./ 在/ Unix/ 程序/ 上/ ,/ 无论/ AM/ -/ 方法/ 在/ 何种/ 方法/ (/ Jaccard/ ,/ Ochiai/ ,/ Tarantula/ 或/ SBI/ )/ 上/ 使用/ ,/ 具有/ 普遍/ 的/ 效果/ 增强/ 现象/ ./ 在/ Siemens/ 程序/ 上/ ,/ AM/ -/ 方法/ 在/ Jaccard/ 和/ Ochiai/ 上/ 效果/ 不/ 明显/ ,/ 也/ 没有/ 达到/ t/ -/ test/ 的/ 显著性/ 差异/ (/ 阈值/ 0.05/ )/ ,/ 在/ Tarantula/ 和/ SBI/ 上/ 有/ 副作用/ (/ 会/ 引起/ 二者/ 的/ 错误/ 定位/ 效果/ 退化/ )/ ./ 5.5/ 针对/ 不同/ 错误/ 的/ 结果/ 分析/ 之前/ 的/ 研究/ 认为/ ,/ 错误/ 定位/ 方法/ 在/ 代码/ 检查/ 率/ 较/ 低/ (/ 比如/ 10/ %/ [/ 27/ ]/ 或/ 20/ %/ [/ 5/ ,/ 14/ ]/ )/ 的/ 范围/ 内/ 的/ 定位/ 准确率/ 更能/ 说明/ 方法/ 的/ 有效性/ ./ 为此/ ,/ 我们/ 以/ 10/ %/ 的/ 代码/ 检查/ 率为/ 阈值/ ,/ 以/ Tarantula/ 方法/ 为例/ ,/ 从/ Unix/ 的/ 3/ 个/ 程序/ 中/ 选择/ 出/ 那些/ 在/ Tarantula/ 或者/ AM/ -/ Tarantula/ 方法/ 下/ 代码/ 检查/ 率/ 大于/ 10/ %/ 同时/ 小于/ 100/ %/ 的/ 单个/ 错误/ ,/ 横向/ 比较/ 这些/ 错误/ 在/ AM/ -/ Tarantula/ 和/ Tarantula/ 方法/ 下/ 的/ 代码/ 检查/ 率/ ,/ 按照/ 这种/ 选择/ 方法/ ,/ 共/ 在/ Unix/ 的/ 3/ 个/ 程序/ 中/ 选择/ 出/ 26/ 个/ 错误/ ,/ 其/ 实验/ 结果/ 如图/ 6/ ./ Tarantula/ 方法/ 下/ 的/ 代码/ 检查/ 率/ ./ 在/ 其余/ 的/ 69/ 个/ 错误/ 版本/ 中/ ,/ AM/ -/ Tarantula/ 和/ Tarantula/ 的/ 效果/ 差别/ 均/ 在/ 10/ %/ 以下/ ./ 在/ Jaccard/ 、/ Ochiai/ 和/ SBI/ 方法/ 上/ ,/ 本文/ 方法/ 的/ 应用/ 具有/ 类似/ 的/ 效果/ ;/ 总体/ 来看/ ,/ 本文/ 的/ 方法/ 在/ Page11Unix/ 程序/ 上/ 的/ 大多数/ 情况/ 下/ 具有/ 相比/ 原/ 方法/ 更佳/ 的/ 错误/ 定位/ 效果/ ./ 6/ 讨论/ 6.1/ 本文/ 方法/ 的/ 不足/ 针对/ AM/ -/ Jaccard/ 、/ AM/ -/ Ochiai/ 、/ AM/ -/ Tarantula/ 和/ AM/ -/ SBI/ 方法/ 在/ Siemens/ 程序/ 集/ 和/ Unix/ 中/ 的/ grep/ 程序/ 上/ 存在/ 的/ 不足/ ,/ 我们/ 从/ 源代码/ 结构/ 、/ 错误/ 类型/ 、/ 评估/ 指标/ 等/ 多个/ 方面/ 仔细分析/ 了/ 实验/ 结果/ ./ 得出/ 如下/ 结论/ :/ 在/ 目前/ 的/ 评估/ 指标/ 下/ ,/ 本文/ 的/ 方法/ 不能/ 很/ 好/ 地/ 处理/ 错误代码/ 和/ 高/ 可疑/ 代码/ 分属/ 不同/ 的/ 函数/ 体/ 的/ 情况/ ./ 遵循/ 之前/ 的/ 研究/ 中/ 所/ 采用/ 的/ 执行/ 路径/ 和/ 控制流/ 图/ 等/ 方法/ [/ 5/ -/ 19/ ]/ ,/ 本文/ 为/ 每/ 一个/ 函数/ 体/ 构建/ 其/ 覆盖/ 向量/ 和/ 覆盖/ 矩阵/ ./ 一旦/ 高/ 可疑/ 代码/ 与/ 错误代码/ 分属/ 不同/ 的/ 函数/ 体/ ,/ 本文/ 方法/ 则/ 会/ 优先/ 检查/ 高/ 可疑/ 代码/ 所/ 处/ 函数/ 体中/ 的/ 与/ 高/ 可疑/ 代码/ 保持/ 覆盖/ 一致性/ 的/ 代码/ 语句/ ,/ 一定/ 程序/ 上/ 提高/ 了/ 整个/ 函数/ 的/ 检查/ 顺序/ ,/ 相对而言/ 则/ 降低/ 了/ 错误代码/ 的/ 定位/ 准确度/ ./ 6.2/ 案例/ 分析/ 针对/ 错误代码/ 与/ 高/ 可疑/ 代码/ 分属/ 不同/ 的/ 函数/ 体/ 这/ 一/ 情况/ ,/ 本文/ 有/ 针对性/ 的/ 作/ 了/ 进一步/ 的/ 分析/ 比较/ 实验/ ./ 针对/ 每/ 一个/ 错误/ 版本/ ,/ 首先/ ,/ 我们/ 分析/ 以/ Jaccard/ 、/ Ochiai/ 、/ Tarantula/ 或/ SBI/ 方法/ 得到/ 的/ 具有/ 最高/ 可疑/ 度/ 的/ 代码/ 与/ 实际/ 的/ 错误代码/ 语句/ 是否/ 存在/ 同一/ 函数/ 体/ ,/ 然后/ 统计/ 出高/ 可疑/ 代码/ 语句/ 与/ 错误代码/ 语句/ 不/ 在/ 同一/ 函数/ 体/ 的/ 错误/ 版本/ 数/ ./ 分析/ 结果/ 如表/ 6/ ./ flexgrepgzipprint/ _/ tokens10print/ _/ tokens2250replacescheduleschedule22100tcastot/ _/ info/ 在/ 表/ 6/ 中/ ,/ 我们/ 以/ faults/ 来/ 表示/ 满足/ AM/ -/ Tarantula/ 的/ 结果/ 优于/ Tarantula/ 或者/ Tarantula/ 优于/ AM/ -/ Tarantula/ 等/ 条件/ 的/ 错误/ 版本/ 数量/ ,/ diff/ %/ 来/ 表示/ 高/ 可疑/ 代码/ 与/ 错误代码/ 分属/ 不同/ 函数/ 体/ 的/ 错误/ 版本/ 占/ faults/ 数量/ 的/ 比例/ ./ 从表中/ 可以/ 看出/ ,/ 在/ Tarantula/ 优于/ AM/ -/ Tarantula/ 的/ 情况/ 下/ ,/ 错误/ 版本/ 的/ 程序/ 中/ ,/ 错误代码/ 与/ 高/ 可疑/ 代码/ 全部/ 分属/ 不同/ 的/ 函数/ 体/ ./ 以/ grep/ 为例/ ,/ grep/ 共有/ 21/ 个/ 错误/ 版本/ ./ 在/ 其中/ 的/ 6/ 个/ 错误/ 版本/ 上/ ,/ Tarantula/ 方法/ 要/ 好/ 于/ AM/ -/ Tarantula/ 方法/ ,/ 且/ 这/ 6/ 个/ 错误/ 版本/ 中/ 的/ 代码/ 语句/ 与/ 高/ 可疑/ 的/ 代码/ 语句/ 都/ 不/ 属于/ 同一/ 函数/ 体/ ./ 比如/ ,/ 在/ grep/ -/ v1/ -/ fault3/ 版本/ 中/ ,/ 共有/ 22/ 行/ 代码/ 语句/ 的/ 可疑/ 度/ 比/ 错误代码/ 语句/ 高/ ,/ 这/ 22/ 行/ 代码/ 语句/ 分属/ 4/ 个/ 不同/ 的/ 函数/ ,/ 在/ 这种/ 情况/ 下/ ,/ 本文/ 算法/ 则/ 会/ 优先/ 处理/ 这/ 4/ 个/ 函数/ 中/ 的/ 频繁/ 集/ 求解/ ,/ 进而/ 可能/ 导致/ 整体/ 上/ 的/ 效果/ 并/ 不好/ ./ 6.3/ 可/ 改进/ 之/ 处/ 针对/ 6.1/ 节/ 和/ 6.2/ 节中/ 的/ 问题/ ,/ 构建/ 不/ 区分/ 函数/ 的/ 全局/ 覆盖/ 向量/ 和/ 覆盖/ 矩阵/ 或许/ 是/ 一种/ 解决/ 高/ 可疑/ 代码/ 与/ 错误代码/ 分属/ 不同/ 函数/ 体/ 的/ 情况/ ,/ 一种/ 较易/ 实现/ 的/ 方法/ 是/ 以/ 全部/ 代码/ 语句/ 的/ 行数/ 作为/ 索引/ ,/ 构建/ 全局/ 覆盖/ 向量/ ,/ 这样/ 可以/ 确保/ 频繁/ 集/ 求解/ 不/ 单独/ 针对/ 某/ 一个/ 函数/ ,/ 从而/ 可能/ 提高/ 错误/ 定位/ 的/ 准确度/ ./ 从/ 实际效果/ 上/ 看/ ,/ 本文/ 方法/ 的/ 有效性/ 在/ 如下/ 几个/ 方面/ 需要/ 进一步/ 讨论/ ./ 首先/ ,/ 本文/ 的/ 实验/ 首先/ 使用/ gcov/ 来/ 获取/ 代码/ 的/ 覆盖/ 信息/ ,/ 然后/ 再/ 结合/ 静态/ 分析/ 获取/ 执行/ 路径/ ./ gcov/ 获得/ 的/ 覆盖/ 信息/ 不能/ 反映/ 代码/ 的/ 先后/ 执行/ 顺序/ ,/ 因此/ 对于/ 程序结构/ 的/ 执行/ 路径分析/ 存在/ 一定/ 误差/ ./ 但是/ ,/ 在/ 错误/ 类型/ 不是/ 代码/ 缺失/ 型/ 错误/ 时/ ,/ 覆盖/ 向量/ 对于/ 错误代码/ 与/ 高/ 可疑/ 代码/ 之间/ 的/ 覆盖/ 一致性/ 是/ 没有/ 影响/ 的/ ./ 其次/ ,/ 本文/ 的/ 方法/ 更/ 适于/ 解决/ 单个/ 错误/ 的/ 错误/ 定位问题/ ./ 程序/ 中/ 多个/ 错误/ 同时/ 存在/ 的/ 情况/ 会/ 对/ 本文/ 方法/ 有效性/ 产生/ 不利/ 影响/ ,/ 比如/ ,/ 多个/ 错误/ 的/ 存在/ 可能/ 会/ 使得/ 求解/ 出/ 的/ 频繁/ 集仅/ 包含/ 目标/ 基本块/ ./ 一个/ 解决/ 该/ 问题/ 的/ 方法/ 是/ 面向/ 错误/ 的/ 程序/ 失效/ 分类/ [/ 28/ ]/ ,/ 如果/ 能够/ 针对/ 不同/ 的/ 错误/ 将/ 程序/ 失效/ 分类/ ,/ 则/ 本文/ 方法/ 可以/ 体现/ 出/ 实验/ 结果/ 中/ 的/ 优势/ ./ 程序/ 中总有/ 一部分/ 基本块/ 是/ 某些/ 代码执行/ 时所/ 必须/ 覆盖/ 的/ ,/ 如/ 控制流/ 图中/ 的/ 控制/ 依赖/ 节点/ [/ 29/ ]/ ,/ 如何/ 甄别/ 频繁/ 集中/ 诸如/ 控制/ 依赖/ 基本块/ 对应/ 的/ 分量/ 以/ 进一步/ 缩小/ 待/ 检查/ 代码/ 的/ 范围/ ,/ 是/ 目前/ 困扰/ 我们/ 的/ 主要/ 问题/ ./ 此外/ ,/ 程序执行/ 中/ 的/ 巧合/ 性/ 正确/ [/ 25/ ]/ 以及/ 测试用例/ 的/ 相似性/ [/ 30/ ]/ 一直/ 是/ 困扰/ 错误/ 定位/ 的/ 重要/ 问题/ ,/ 本文/ 的/ 方法/ 仍然/ 不能/ 避免/ 这种/ 影响/ ,/ 我们/ 将/ 在/ Page12/ 后续/ 的/ 工作/ 中/ 开展/ 这方面/ 研究/ ./ 7/ 结论/ 本文/ 以/ 提高/ CBFL/ 方法/ 的/ 准确性/ 为/ 出发点/ ,/ 首先/ 分析/ 了/ CBFL/ 方法/ 准确性/ 有待/ 提高/ 的/ 原因/ ,/ 随后/ 提出/ 失效/ 执行/ 规则/ ,/ 然后/ 在/ 执行/ 规则/ 的/ 指导/ 下/ ,/ 建立/ 基于/ 覆盖/ 向量/ 的/ 执行/ 轨迹/ 分析模型/ ./ 基于/ 此/ 模型/ ,/ 本文/ 提出/ 用于/ 挖掘/ 与/ 高/ 可疑/ 代码/ 相关联/ 的/ 错误代码/ 的/ 频繁/ 集/ 求解/ 算法/ ./ 以/ SIR/ 基准/ 程序/ 为/ 对象/ 建立/ 的/ 受控/ 实验/ 证明/ ,/ 相比/ 之前/ 的/ 研究/ ,/ 本文/ 方法/ 在/ 一定/ 程度/ 上/ 可以/ 改进/ 错误/ 定位/ 结果/ ./ 

