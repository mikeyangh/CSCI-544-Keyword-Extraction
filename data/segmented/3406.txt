Page1/ 提高/ 路径/ 敏感/ 缺陷/ 检测/ 方法/ 的/ 效率/ 及/ 精度/ 研究/ 赵云/ 山/ 1/ )/ 宫云战/ 1/ )/ 刘莉/ 1/ )/ 肖庆/ 1/ )/ 杨朝红/ 1/ )/ ,/ 2/ )/ 1/ )/ (/ 北京邮电大学/ 网络/ 与/ 交换/ 技术/ 国家/ 重点/ 实验室/ 北京/ 100876/ )/ 2/ )/ (/ 装甲兵/ 工程学院/ 信息工程/ 系/ 北京/ 100072/ )/ 摘要/ 路径/ 敏感/ 的/ 缺陷/ 检测/ 方法/ 其/ 缺陷/ 状态/ 会/ 关联/ 当前/ 控制流/ 节点/ 的/ 所有/ 数据流/ 信息/ ,/ 由于/ 其中/ 包含/ 与/ 缺陷/ 检测/ 无关/ 的/ 数据流/ ,/ 因此/ 会/ 导致/ 分析/ 效率/ 下降/ ./ 为了/ 避免/ 全/ 路径/ 敏感/ 分析/ 时/ 的/ 路径/ 爆炸/ 问题/ ,/ 一般/ 会/ 在/ 控制流/ 汇合/ 节点/ 进行/ 缺陷/ 状态/ 合并/ ,/ 而/ 这种/ 粗糙/ 的/ 合并/ 策略/ 带来/ 的/ 精度/ 损失/ 会/ 引起/ 误报/ ./ 针对/ 上述/ 问题/ ,/ 文中/ 提出/ 一种/ 基于/ 缺陷/ 的/ 程序/ 切片/ 方法/ ,/ 该/ 方法/ 基于/ 缺陷/ 特征/ 和/ 路径/ 条件/ 建立/ 切片/ 准则/ ,/ 根据/ 控制流/ 节点/ 上/ 的/ 数据流/ 信息/ 与/ 切片/ 准则/ 的/ 包含/ 关系/ 进行/ 程序/ 切片/ ,/ 得到/ 的/ 切片/ 程序/ 在/ 缺陷/ 检测/ 时/ 切片/ 掉/ 了/ 缺陷/ 无/ 关节点/ 且/ 与/ 源程序/ 完全/ 等价/ ,/ 以/ 提高/ 缺陷/ 检测/ 效率/ ./ 为了/ 进一步/ 减少/ 路径/ 敏感/ 分析方法/ 的/ 误报/ ,/ 提出/ 一种/ 基于/ 切片/ 的/ 缺陷/ 状态/ 合并/ 策略/ ,/ 根据/ 控制流/ 分支/ 节点/ 的/ 路径/ 条件/ ,/ 对/ 缺陷/ 状态/ 添加/ 状态/ 属性/ ,/ 从而/ 有/ 选择地/ 对/ 控制流/ 汇合/ 节点/ 进行/ 状态/ 合并/ ,/ 减少/ 精度/ 损失/ ./ 文中/ 所述/ 方法/ 已/ 在/ 缺陷/ 检测/ 系统/ (/ DTSGCC/ )/ 中/ 实现/ ./ 对/ 大量/ Linux/ 中/ GCC/ 开源/ 工程/ 的/ 测试/ 结果表明/ ,/ 文中/ 提出/ 的/ 方法/ 可以/ 提高/ 路径/ 敏感/ 缺陷/ 检测/ 方法/ 的/ 效率/ ,/ 并/ 减少/ 误报/ ./ 关键词/ 静态/ 分析/ ;/ 缺陷/ 检测/ ;/ 路径/ 敏感/ ;/ 误报/ ;/ 程序/ 切片/ ;/ 上下文/ 敏感/ 分析/ ;/ 域/ 敏感/ 分析/ 1/ 引言/ 软件测试/ 是/ 提高/ 软件/ 质量/ 的/ 重要/ 手段/ ,/ 根据/ 是否/ 运行/ 被/ 测试程序/ ,/ 软件测试/ 可以/ 分为/ 动态/ 测试/ 和/ 静态/ 测试/ ./ 基于/ 软件缺陷/ 的/ 静态/ 分析方法/ 可以/ 针对/ 小/ 概率/ 缺陷/ 实施/ 有效/ 测试/ ,/ 受到/ 了/ 学术界/ 和/ 工业界/ 的/ 广泛/ 关注/ ./ 静态/ 分析/ 的/ 效率/ 是/ 影响/ 其/ 能否/ 应用/ 于/ 大型/ 软件缺陷/ 检测/ 的/ 关键/ ,/ 它/ 与/ 分析/ 过程/ 中/ 的/ 计算/ 复杂度/ 密切相关/ ./ 由于/ 静态/ 分析/ 需要/ 抽象/ 出/ 完整/ 的/ 程序/ 语义/ 信息/ ,/ 该/ 抽象/ 语义/ 信息/ 往往/ 是/ 精确/ 程序/ 语义/ 的/ “/ 保守/ ”/ 近似/ ,/ 从而/ 导致/ 其/ 计算/ 量/ 要/ 远大于/ 程序/ 精确/ 语义/ 所/ 表示/ 的/ 计算/ 量/ ,/ 因此/ 减少/ 保守/ 性/ 分析/ 时/ 的/ 计算/ 量/ 可以/ 提高/ 分析/ 效率/ ./ 根据/ Rice/ 定理/ [/ 1/ ]/ ,/ 静态/ 分析/ 针对/ 程序/ 的/ 任何/ 非/ 平凡/ 属性/ (/ 例如/ :/ 是否/ 存在/ 运行/ 时/ 错误/ )/ ,/ 不/ 可能/ 做到/ 既/ 是/ 可靠/ 的/ (/ sound/ )/ 又/ 是/ 完备/ 的/ (/ complete/ )/ ,/ 导致/ 其/ 计算结果/ 可能/ 会/ 出现/ 误报/ (/ falsepositive/ )/ 和/ 漏报/ (/ falsenegative/ )/ ./ 大量/ 的/ 误报/ 会/ 使/ 人/ 对/ 分析/ 工具/ 失去/ 信心/ ,/ 而/ 漏报/ 会/ 造成/ 程序/ 具有/ 较/ 高质量/ 的/ 假象/ ,/ 因此/ 提高/ 精度/ 是/ 完善/ 静态/ 分析/ 功能/ 的/ 又/ 一/ 挑战/ ./ 路径/ 敏感/ 的/ 缺陷/ 检测/ 方法/ 从/ 控制流/ 图头/ 节点/ 依次/ 进行/ 状态/ 迭代/ ,/ 每个/ 缺陷/ 状态/ 都/ 会/ 关联/ 当前/ 控制流/ 节点/ 的/ 所有/ 数据流/ 信息/ ,/ 在/ 缺陷/ 状态/ 迭代/ 计算/ 时/ ,/ 与/ 缺陷/ 无关/ 的/ 数据流/ 信息/ 会/ 在/ 控制流/ 上/ 进行/ 传递/ 和/ 计算/ ,/ 这种/ 无关/ 计算/ 势必/ 降低/ 缺陷/ 检测/ 的/ 效率/ [/ 2/ -/ 4/ ]/ ./ 文献/ [/ 5/ -/ 6/ ]/ 通过/ 增加/ 控制流/ 节点/ 构造/ 新/ 的/ 路径/ ,/ 或/ 重构/ 控制流/ 图以/ 消除/ 不可/ 达/ 路径/ 的/ 方法/ ,/ 实现/ 了/ 路径/ 敏感/ 分析/ ,/ 这是/ 一种/ 典型/ 的/ 以/ 效率/ 换/ 精度/ 的/ 方法/ ,/ 限制/ 了/ 其/ 在/ 大型/ 软件缺陷/ 检测/ 中/ 的/ 应用/ ./ 基于/ 数据流/ 分析/ 的/ 路径/ 敏感/ 检测/ 方法/ 考虑/ 分支/ 间/ 的/ 组合/ 关系/ ,/ 可以/ 记录/ 控制流/ 图上/ 的/ 不同/ 路径/ 信息/ ,/ 从而/ 有效/ 减少/ 静态/ 分析/ 时/ 的/ 误报/ ./ 精确/ 的/ 路径/ 敏感/ 分析方法/ 会/ 记录/ 程序/ 中/ 的/ 所有/ 路径/ 信息/ ,/ 在/ 控制流/ 分支/ 较/ 多/ 或/ 存在/ 循环/ 时会/ 导致/ 路径/ 爆炸/ ,/ 从而/ 无法/ 进行/ 分析/ ./ 因此/ ,/ 实用/ 的/ 路径/ 敏感/ 分析方法/ 往往/ 会/ 采用/ 一些/ 折衷/ 策略/ ,/ 有/ 可能/ 导致/ 精度/ 损失/ :/ (/ 1/ )/ 不同/ 路径/ 上/ 的/ 数据流/ 信息/ 在/ 控制流/ 汇合处/ 合并/ ;/ (/ 2/ )/ 数据流/ 在/ 不可/ 达/ 路径/ 上/ 进行/ 传递/ ./ 文献/ [/ 4/ ]/ 采用/ 迭代/ 求精/ 策略/ ,/ 每次/ 迭代/ 分析/ 的/ 结果/ 都/ 会/ 更新/ 状态/ 合并/ 准则/ ,/ 这种/ 可/ 调整/ 的/ 合并/ 准则/ 会/ 减少/ 由于/ 关键/ 路径/ 合并/ 而/ 带来/ 的/ 精度/ 损失/ ,/ 但/ 迭代/ 求/ 精要/ 进行/ 重复/ 计算/ ,/ 且/ 有/ 可能/ 面临/ 迭代/ 不/ 终止/ 的/ 情况/ ./ 文献/ [/ 3/ ]/ 采用/ 变量/ 的/ 抽象/ 取值/ 来/ 表示/ 状态/ 条件/ ,/ 在/ 控制流/ 汇合/ 节点/ 通过/ 合并/ 相同/ 状态/ 中/ 的/ 状态/ 条件/ 来/ 避免/ 路径/ 爆炸/ ,/ 但/ 该/ 方法/ 的/ 状态/ 合并/ 策略/ 没有/ 区分/ 在/ 哪些/ 汇合/ 节点/ 可以/ 进行/ 安全/ 的/ 状态/ 合并/ ,/ 导致/ 与/ 缺陷/ 相关/ 的/ 路径/ 信息/ 丢失/ 从而/ 引起/ 误报/ ./ 基于/ 上述/ 对/ 路径/ 敏感/ 缺陷/ 检测/ 方法/ 的/ 分析/ ,/ 可以/ 得到/ 以下/ 结论/ :/ (/ 1/ )/ 控制流/ 图/ 节点/ 数/ 决定/ 了/ 状态/ 迭代/ 计算/ 的/ 次数/ ;/ (/ 2/ )/ 状态/ 条件/ 中/ 关联/ 数据流/ 信息/ 的/ 数量/ 决定/ 了/ 沿/ 控制流/ 进行/ 状态/ 迭代/ 时/ 的/ 复杂度/ ;/ (/ 3/ )/ 状态/ 合并/ 策略/ 影响/ 路径/ 敏感/ 检测/ 方法/ 的/ 精度/ ./ 本文/ 主要/ 关注点/ 是/ 如何/ 优化/ 这/ 3/ 个/ 方面/ ,/ 以/ 提高/ 路径/ 敏感/ 分析方法/ 的/ 效率/ 和/ 精度/ ./ 借鉴/ 需求/ 驱动/ [/ 7/ ]/ 程序/ 分析方法/ 的/ 思想/ ,/ 本文/ 将/ 程序/ 切片/ 技术/ [/ 8/ ]/ 应用/ 于/ 缺陷/ 检测/ ,/ 提出/ 一种/ 基于/ 缺陷/ 的/ 程序/ 切片/ 方法/ ./ 该/ 方法/ 基于/ 缺陷/ 特征/ 和/ 路径/ 条件/ 建立/ 切片/ 准则/ ,/ 根据/ 控制流/ 节点/ 上/ 的/ 数据流/ 信息/ 与/ 切片/ 准则/ 的/ 包含/ 关系/ 进行/ 程序/ 切片/ ,/ 得到/ 的/ 切片/ 程序/ 在/ 缺陷/ 检测/ 时/ 不仅/ 切片/ 掉/ 了/ 缺陷/ 无/ 关节点/ ,/ 从而/ 减少/ 了/ 数据流/ 迭代/ 时/ 的/ 计算/ 量/ ,/ 而且/ 与/ 源程序/ 完全/ 等价/ 从而/ 保证/ 了/ 静态/ 分析/ 的/ 保守/ 性/ ./ 为了/ 进一步/ 减少/ 误报/ ,/ 提出/ 一种/ 基于/ 切片/ 的/ 缺陷/ 状态/ 合并/ 策略/ ,/ 根据/ 控制流/ 分支/ 节点/ 的/ 路径/ 条件/ ,/ 对/ 缺陷/ 状态/ 添加/ 状态/ 属性/ ,/ 从而/ 有/ 选择地/ 对/ 控制流/ 汇合/ 节点/ 进行/ 状态/ 合并/ ,/ 以/ 提高/ 检测/ 精度/ ./ 为/ 验证/ 方法/ 的/ 有效性/ ,/ 在/ 缺陷/ 检测/ 系统/ DTSGCC/ (/ DefectTestingSystemforGCC/ )/ 中/ 实现/ 了/ 上述/ 方法/ ,/ 对/ Linux/ 中/ 10/ 个/ 开源/ 项目/ 的/ 缺陷/ 检测/ 结果表明/ ,/ 本文/ 方法/ 在/ 检测/ 代码/ 量/ 较大/ 的/ 程序/ 时/ ,/ 有效/ 提高/ 了/ 路径/ 敏感/ 缺陷/ 检测/ 方法/ 的/ 效率/ ,/ 同时/ 减少/ 了/ 误报/ ,/ 为/ 提高/ 软件/ 质量/ 及/ 安全性/ 提供/ 了/ 有效/ 可行/ 的/ 方法/ 及/ 工具/ ./ 我们/ 的/ 贡献/ 主要/ 有/ :/ (/ 1/ )/ 将/ 程序/ 切片/ 技术/ 应用/ 于/ 缺陷/ 检测/ ,/ 根据/ 缺陷/ 特征/ 和/ 路径/ 条件/ 建立/ 切片/ 准则/ 进行/ 程序/ 切片/ ;/ (/ 2/ )/ 采用/ 基于/ 切片/ 的/ 缺陷/ 状态/ 合/ Page3/ 并/ 策略/ ,/ 有/ 选择地/ 对/ 控制流/ 汇合/ 节点/ 进行/ 状态/ 合并/ ;/ (/ 3/ )/ 设计/ 实现/ 了/ 针对/ Linux/ 系统/ 中/ GCC/ 程序/ 的/ 路径/ 敏感/ 缺陷/ 检测工具/ ,/ 在/ 检测/ 代码/ 量/ 较大/ 的/ 程序/ 时/ ,/ 与/ 同类/ 工具/ 相比/ 效率/ 更高/ ./ 本文/ 第/ 2/ 节/ 首先/ 介绍/ 缺陷/ 检测/ 的/ 一些/ 基本概念/ ,/ 包括/ 控制流/ 图/ 、/ 缺陷/ 模式/ 、/ 缺陷/ 状态/ 自动机/ 等/ ,/ 然后/ 以/ 资源/ 泄露/ 缺陷/ 模式/ 为例/ 介绍/ 了/ 路径/ 敏感/ 缺陷/ 检测/ 方法/ 的/ 原理/ ,/ 并/ 给出/ 我们/ 的/ 研究/ 动机/ ;/ 第/ 3/ 节对/ 提高/ 分析/ 效率/ 和/ 精度/ 的/ 方法/ 进行/ 详细描述/ ,/ 并/ 通过/ 一个/ 具体/ 的/ 例子/ 展示/ 如何/ 进行/ 程序/ 切片/ 及/ 状态/ 合并/ ;/ 第/ 4/ 节/ 介绍/ 缺陷/ 检测工具/ DTS/ 的/ 框架/ 及/ 实验/ 环境/ ,/ 并/ 对/ 10/ 个开/ 源程序/ 的/ 检测/ 结果/ 进行/ 分析/ ;/ 第/ 5/ 节/ 给出/ 相关/ 工作/ 比较/ ;/ 第/ 6/ 节/ 总结/ 全文/ 并/ 展望未来/ 工作/ ./ 2/ 研究/ 背景/ 与/ 动机/ 本/ 节/ 首先/ 对/ 缺陷/ 检测/ 的/ 基本概念/ 作/ 简要/ 介绍/ ,/ 然后/ 使用/ 相同/ 状态/ 合并/ 的/ 路径/ 敏感/ 分析方法/ ,/ 通过/ 对/ 一个/ 具体/ 的/ 例子/ 进行/ 分析/ ,/ 给出/ 我们/ 的/ 研究/ 动机/ ./ 2.1/ 研究/ 背景/ 根据/ 是否/ 考虑/ 程序/ 语句/ 的/ 执行/ 次序/ ,/ 静态/ 分析/ 可以/ 分为/ 流/ 敏感/ 分析/ (/ flowsensitive/ )/ 和/ 非流/ 敏感/ 分析/ (/ flowinsensitive/ )/ ./ 程序/ 的/ 控制流/ 图/ (/ ControlFlowGraph/ ,/ CFG/ )/ 即/ 是/ 对/ 语句/ 执行/ 次序/ 的/ 抽象/ ,/ 是/ 具有/ 单一/ 的/ 、/ 固定/ 的/ 入口/ 节点/ 和/ 出口/ 节点/ 的/ 有向图/ ./ 定义/ 1/ ./ 控制流/ 图/ ./ 程序/ 的/ 控制流/ 图/ 可以/ 表示/ 为/ 一个/ 有向图/ G/ =/ (/ N/ ,/ E/ ,/ n0/ ,/ nf/ )/ ,/ 其中/ :/ N/ 代表/ 节点/ 的/ 集合/ ,/ 每个/ 节点/ ni/ ∈/ N/ 反映/ 程序/ 中/ 的/ 顺序/ 执行/ 语句/ CommonStmt/ 、/ 条件/ 判断/ (/ 循环/ )/ 语句/ SelectionStmt/ 等/ ,/ 与/ 节点/ ni/ 关联/ 的/ 程序/ 语句/ 块/ 表示/ 为/ Stmt/ (/ ni/ )/ ;/ E/ ∈/ N/ ×/ N/ 代表/ 有/ 向/ 边/ 的/ 集合/ ,/ 反映/ 程序/ 中/ 语句/ 间/ 的/ 控制流/ 关系/ ,/ eh/ 和/ et/ 分别/ 表示/ 有/ 向/ 边/ e/ 的/ 头/ 节点/ 和/ 尾/ 节点/ ;/ n0/ 为/ 函数/ 的/ 唯一/ 入口/ 节点/ ,/ nf/ 为/ 函数/ 的/ 唯一/ 退出/ 节点/ ./ 静态/ 缺陷/ 检测/ 方法/ 关键/ 是/ 对/ 缺陷/ 模式/ 进行/ 定义/ 和/ 检测/ ,/ 能/ 处理/ 的/ 缺陷/ 模式/ 种类/ 越/ 多则/ 分析/ 检测/ 能力/ 越强/ ./ 定义/ 2/ ./ 缺陷/ 模式/ ./ 指/ 程序/ 中/ 经常/ 发生/ 的/ 缺陷/ (/ BUG/ )/ 所/ 呈现出/ 的/ 语法/ 或/ 语义/ 特征/ ./ 缺陷/ 模式/ 是/ 对/ 程序/ 属性/ 的/ 一种/ 描述/ ,/ 如果/ 违反/ 该/ 属性/ 则/ 造成/ 一个/ 缺陷/ ./ 例如/ ,/ 申请/ 的/ 资源/ 在/ 使用/ 完后/ 必须/ 释放/ ,/ 否则/ 造成/ 资源/ 泄漏/ 缺陷/ (/ ResourceLeak/ ,/ RL/ )/ ;/ 数组/ 下/ 标的/ 使用/ 必须/ 在/ 其/ 数组/ 声明/ 大小/ 范围/ 以内/ ,/ 否则/ 会/ 造成/ 数组/ 越界/ 缺陷/ (/ OutOfBoundary/ ,/ OOB/ )/ ;/ 指针/ 在/ 解/ 引用/ 之前/ 必须/ 确保/ 其/ 指向/ 非空/ ,/ 否则/ 会/ 造成/ 空/ 指针/ 引用/ 缺陷/ (/ NullPointerDereference/ ,/ NPD/ )/ ./ 状态机/ 是/ 对/ 程序/ 语义/ 的/ 一种/ 常用/ 和/ 易于/ 理解/ 的/ 抽象/ 表示/ ,/ 缺陷/ 模式/ 可以/ 用/ 缺陷/ 模式/ 状态机/ 来/ 表示/ ./ 定义/ 3/ ./ 缺陷/ 模式/ 状态机/ ①/ ./ 用于/ 描述/ 缺陷/ 模式/ 的/ 有限/ 状态机/ (/ FiniteStateMachine/ ,/ FSM/ )/ ,/ 包括/ 状态/ 集合/ D/ 、/ 状态/ 迁移/ 集合/ T/ 及/ 迁移/ 条件/ 集合/ Conditions/ ,/ 其中/ D/ =/ {/ $/ start/ ,/ $/ error/ }/ ∪/ Dother/ ,/ T/ :/ D/ ×/ Conditions/ →/ D/ ./ $/ start/ 和/ $/ error/ 分别/ 表示/ 起始/ 状态/ 和/ 错误/ 状态/ ,/ Dother/ 表示/ 其它/ 中间状态/ 的/ 集合/ ./ 本文/ 用/ XML/ 文件/ 对/ 不同/ 种类/ 的/ 缺陷/ 模式/ 状态机/ 进行/ 形式化/ 描述/ ,/ 在/ 缺陷/ 检测/ 时/ 根据/ 待测/ 程序/ 的/ 语法/ 、/ 语义/ 特征/ 决定/ 是否/ 创建/ 某/ 类型/ 的/ 状态机/ 实例/ ,/ 并/ 将/ 产生/ 的/ 状态机/ 实例/ 集合/ 置于/ 待测/ 函数/ 控制流/ 入口处/ ;/ 然后/ 在/ 遍历/ 控制流/ 图/ 过程/ 中/ ,/ 根据/ 当前/ 控制流/ 节点/ 的/ 数据流/ 信息/ 更新/ 状态机/ 实例/ 的/ 缺陷/ 状态/ 同时/ 判定/ 是否/ 会/ 发生/ 状态/ 迁移/ ,/ 以/ 检测/ 某种/ 类型/ 的/ 缺陷/ ./ 缺陷/ 模式/ 状态机/ 可以/ 用/ 有向图/ 直观/ 地/ 表示/ ,/ 例如/ RL/ 和/ NPD/ 缺陷/ 模式/ 分别/ 可用/ 状态机/ 描述/ ,/ 如图/ 1/ 所示/ ./ 图/ 1/ 资源/ 泄漏/ 模式/ 和/ 空/ 指针/ 引用/ 模式/ 的/ 缺陷/ 状态机/ 2.2/ 研究/ 动机/ 路径/ 敏感/ 的/ 缺陷/ 检测/ 方法/ ,/ 从/ 控制流/ 图头/ 节点/ 依次/ 进行/ 状态/ 迭代/ ,/ 每个/ 状态/ 都/ 关联/ 当前/ 控制流/ 节/ ①/ 在/ 不/ 引起/ 混淆/ 的/ 情况/ 下/ ,/ 缺陷/ 模式/ 状态机/ 在下文/ 中/ 也/ 简称/ Page4/ 点/ 的/ 所有/ 变量/ 取值/ 信息/ ,/ 称之为/ 状态/ 条件/ (/ statecondition/ )/ ./ 我们/ 用/ 变量/ 的/ 抽象/ 取值/ [/ 9/ ]/ 来/ 表示/ 状态/ 条件/ ,/ 在/ 数据流/ 迭代/ 过程/ 中/ 不断更新/ 状态/ 条件/ ,/ 就/ 会/ 导致/ 缺陷/ 状态/ 发生/ 迁移/ ,/ 一旦/ 发现/ 状态/ 迁移/ 到/ $/ error/ 图/ 2/ 示例/ 代码/ 片段/ 表/ 1/ 图/ 2/ 中/ 代码/ 片段/ (/ a/ )/ 的/ 缺陷/ 状态/ 迁移/ 序列/ 语句/ L1/ $/ start/ :/ L2/ $/ start/ :/ {/ f/ [/ null/ ]/ ,/ dump/ [/ true/ ]/ ,/ flag/ [/ 1/ ,/ 1/ ]/ }/ L3/ $/ start/ :/ {/ f/ [/ null/ ]/ ,/ dump/ [/ false/ ]/ ,/ flag/ [/ 0/ ,/ 0/ ]/ }/ P1/ $/ start/ :/ {/ f/ [/ null/ ]/ ,/ dump/ [/ true/ _/ or/ _/ false/ ]/ ,/ flag/ [/ 0/ ,/ 1/ ]/ ,/ i/ [/ inf/ ]/ ,/ j/ [/ inf/ ]/ }/ 控制流/ 汇合/ 节点/ 的/ 缺陷/ 状态/ 合并/ 策略/ :/ 相同/ 状态/ 中/ 的/ 状态/ P2/ $/ start/ :/ {/ f/ [/ null/ ]/ ,/ dump/ [/ true/ _/ or/ _/ false/ ]/ ,/ flag/ [/ 0/ ,/ 1/ ]/ ,/ i/ [/ inf/ ]/ ,/ j/ [/ inf/ ]/ }/ 在/ 状态/ 条件/ 中/ 添加/ i/ 和/ j/ ,/ 其/ 区间/ 未知/ L4/ $/ start/ :/ {/ f/ [/ null/ ]/ ,/ dump/ [/ true/ _/ or/ _/ false/ ]/ ,/ flag/ [/ 0/ ,/ 1/ ]/ ,/ i/ [/ inf/ ]/ ,/ j/ [/ inf/ ]/ }/ L5/ $/ open/ :/ {/ f/ [/ notnull/ ]/ ,/ dump/ [/ true/ ]/ ,/ flag/ [/ 0/ ,/ 1/ ]/ ,/ i/ [/ inf/ ]/ ,/ j/ [/ inf/ ]/ }/ L6/ $/ start/ :/ {/ f/ [/ null/ ]/ ,/ dump/ [/ false/ ]/ ,/ flag/ [/ 0/ ,/ 1/ ]/ ,/ i/ [/ inf/ ]/ ,/ j/ [/ inf/ ]/ }/ L7/ $/ error/ :/ {/ f/ [/ null/ ]/ ,/ dump/ [/ false/ ]/ ,/ flag/ [/ 1/ ,/ 1/ ]/ ,/ i/ [/ inf/ ]/ ,/ j/ [/ inf/ ]/ }/ L8/ 根据/ 表/ 1/ 中/ 缺陷/ 状态/ 迁移/ 序列/ ,/ 在/ L7/ 处/ 缺陷/ 状态/ 自动机/ 迁移/ 到/ $/ error/ ,/ 这是/ 一个/ 明显/ 的/ 误报/ ./ 原因/ 在于/ :/ L3/ 之后/ 的/ 控制流/ 汇合处/ ,/ 将/ 真假/ 分支/ 中/ 两个/ $/ start/ 状态/ 进行/ 了/ 合并/ ,/ 导致/ flag/ 与/ dump/ 的/ 关联/ 关系/ 丢失/ ./ 另外/ 还/ 可以/ 观察/ 到/ ,/ P1/ 之后/ 的/ 状态/ 条件/ 中/ 都/ 关联/ 了/ i/ 和/ j/ 的/ 抽象/ 取值/ ,/ 此类/ 数据流/ 信息/ 对/ RL/ 缺陷/ 检测/ 的/ 结果/ 不会/ 产生/ 任何/ 影响/ ,/ 只会/ 增加/ 状态/ 迭代/ 时/ 的/ 计算/ 量/ ./ 通过/ 对/ 上述/ 示例/ 程序/ 的/ 分析/ ,/ 本文/ 的/ 研究/ 动机/ 为/ :/ (/ 1/ )/ 消除/ 与/ 缺陷/ 检测/ 无关/ 的/ 冗余/ 代码/ ,/ 可以/ 减少/ 控制流/ 图/ 节点/ 数/ ,/ 从而/ 减少/ 状态/ 迭代/ 的/ 次数/ ;/ (/ 2/ )/ 减少/ 状态/ 条件/ 中/ 与/ 缺陷/ 检测/ 无关/ 的/ 变量/ ,/ 可以/ 降低/ 数据流/ 传递/ 和/ 计算/ 时/ 的/ 复杂度/ ;/ (/ 3/ )/ 对/ 控制流/ 汇合/ 节点/ 的/ 缺陷/ 状态/ 合并/ 策略/ 进行/ 优化/ ,/ 可以/ 减少/ 路径/ 合并/ 导致/ 的/ 精度/ 损失/ ./ 根据/ 研究/ 动机/ 中/ 的/ 三/ 方面/ 需求/ ,/ 就/ 表示/ 程序/ 中/ 存在/ 该/ 类型/ 的/ 缺陷/ ./ 例如/ 图/ 2/ 中/ 代码/ 片段/ (/ a/ )/ ,/ 对/ 其中/ 存在/ 的/ RL/ 缺陷/ 进行/ 检测/ ,/ 采用/ 相同/ 状态/ 合并/ 的/ 路径/ 敏感/ 分析方法/ ,/ 其/ 状态/ 迁移/ 序列/ 如表/ 1/ 所示/ ./ voidfun/ (/ inti/ ,/ intj/ )/ {/ else/ // // noisecodessliced/ // // noisecodessliced/ }/ (/ b/ )/ 初始状态/ 为/ $/ start/ 根据/ 真/ 分支/ 中/ 数据流/ ,/ 更新/ 状态/ 条件/ 根据/ 假/ 分支/ 中/ 数据流/ ,/ 更新/ 状态/ 条件/ 条件/ 进行/ 合并/ 真/ 分支/ 中/ 的/ 状态/ 条件/ 更新/ 导致/ $/ start/ 迁移/ 到/ $/ open/ ;/ 假/ 分支/ 中/ 隐含/ 的/ 缺陷/ 状态/ :/ $/ start/ :/ {/ f/ [/ null/ ]/ ,/ dump/ [/ false/ ]/ ,/ flag/ [/ 0/ ,/ 1/ ]/ ,/ i/ [/ inf/ ]/ ,/ j/ [/ inf/ ]/ }/ 真/ 分支/ 中/ 状态/ 条件/ 更新/ 导致/ $/ start/ 迁移/ 到/ $/ error/ ,/ $/ open/ 迁移/ 到/ $/ close/ ;/ 假/ 分支/ 为/ 空语句/ ,/ 不会/ 发生/ 状态/ 迁移/ ;/ 发现/ $/ error/ 状态/ ,/ 迭代/ 终止/ 我们/ 借鉴/ 需求/ 驱动/ 分析/ 技术/ 的/ 思想/ ,/ 提出/ 了/ 本文/ 提高/ 缺陷/ 检测/ 效率/ 和/ 精度/ 的/ 方法/ ./ 3/ 提高/ 检测/ 效率/ 和/ 精度/ 的/ 方法/ 需求/ 驱动/ 的/ 静态/ 分析/ 技术/ [/ 7/ ,/ 10/ ]/ 从/ 程序/ 分析/ 的/ 需求/ 出发/ ,/ 抽取/ 程序/ 语义/ 信息/ ,/ 在/ 进行/ 分析/ 之前/ 降低/ 程序/ 的/ 复杂度/ ,/ 大幅/ 减少/ 了/ 分析/ 过程/ 中/ 的/ 计算/ 量/ ,/ 不仅/ 可以/ 快速/ 准确/ 地/ 复现/ 程序/ 缺陷/ [/ 11/ ]/ ,/ 而且/ 可以/ 对/ 大型/ 程序/ 中/ 某些/ 特定/ 故障/ 进行/ 检测/ ./ 借鉴/ 文献/ [/ 7/ ,/ 10/ ]/ 的/ 思想/ ,/ 本文/ 采用/ 程序/ 切片/ 技术/ 实现/ 了/ 需求/ 驱动/ 的/ 缺陷/ 检测/ 方法/ ,/ 根据/ 不同/ 的/ 缺陷/ 检测/ 目的/ 计算/ 程序/ 的/ 不同/ 切片/ ,/ 从而/ 缩小/ 了/ 缺陷/ 检测/ 的/ 范围/ ,/ 以/ 提高/ 缺陷/ 检测/ 效率/ ./ 由于/ 程序/ 切片/ 考虑/ 程序/ 中/ 存在/ 的/ 各种/ 依赖/ 关系/ (/ 数据/ 依赖/ 和/ 控制/ 依赖/ )/ ,/ 而且/ 任何/ 一个/ 程序/ Page5/ 可以/ 与/ 一组/ 程序/ 切片/ 的/ 并/ 集/ 等价/ ,/ 检测/ 每个/ 切片/ 实际/ 就是/ 测试/ 了/ 整个/ 程序/ ,/ 因此/ 基于/ 缺陷/ 的/ 程序/ 切片/ 方法/ 满足/ 了/ 静态/ 分析方法/ 的/ 保守/ 性/ ./ 3.1/ 节/ 首先/ 根据/ 缺陷/ 特征/ 及/ 路径/ 条件/ 建立/ 切片/ 准则/ ,/ 3.2/ 节/ 应用/ 切片/ 准则/ 对/ 控制流/ 图/ 进行/ 程序/ 切片/ ,/ 然后/ 3.3/ 节/ 根据/ 控制流/ 分支/ 节点/ 的/ 路径/ 条件/ ,/ 对/ 缺陷/ 状态/ 添加/ 状态/ 属性/ ,/ 实现/ 优化/ 的/ 状态/ 合并/ 策略/ ,/ 最后/ 在/ 3.4/ 节/ 根据上述/ 方法/ 给出/ 一个/ 完整/ 的/ 实例/ 分析/ 流程/ ./ 3.1/ 基于/ 缺陷/ 特征/ 及/ 路径/ 条件/ 生成/ 的/ 切片/ 准则/ 程序/ 切片/ 是/ 一种/ 分析/ 和/ 理解/ 程序/ 的/ 技术/ ,/ 通过/ 对/ 源程序/ 中/ 的/ 每个/ 兴趣/ 点/ 分别/ 计算/ 切片/ 来/ 达到/ 对/ 程序/ 的/ 分析/ 和/ 理解/ ./ 程序/ 切片/ 的/ 原理/ 和/ 方法/ 由/ Weiser/ 于/ 1979/ 年/ 在/ 其/ 博士论文/ 中/ 首次/ 提出/ [/ 8/ ]/ ,/ Weiser/ 认为/ 程序/ 切片/ 与/ 人们/ 在/ 调试程序/ 时/ 所/ 做/ 的/ 智力/ 抽象/ 是/ 相对/ 应/ 的/ ,/ 他/ 定义/ 程序/ P/ 的/ 切片/ S/ 是/ 一个/ 可/ 执行/ 的/ 程序/ ,/ 这个/ 切片/ 程序/ 在/ 某个/ 功能属性/ 上/ 与/ P/ 完全/ 等效/ ./ 根据/ 程序/ 分析/ 和/ 理解/ 时/ 不同/ 的/ 兴趣/ 点/ ,/ 可以/ 定义/ 相应/ 的/ 切片/ 准则/ (/ slicingcriteria/ )/ ,/ 根据/ 不同/ 的/ 切片/ 准则/ 可以/ “/ 按/ 需/ ”/ 地/ 对/ 源程序/ 进行/ 功能/ 切片/ ./ 正是/ 基于/ 这种/ “/ 简化/ 问题/ 、/ 缩小/ 目标/ 范围/ ”/ 的/ 原则/ ,/ 程序/ 切片/ 技术/ 成为/ 提高/ 静态/ 分析/ 效率/ 的/ 有效途径/ 之一/ ./ 根据/ 路径/ 敏感/ 缺陷/ 检测/ 方法/ 的/ 特点/ ,/ 切片/ 准则/ 可以/ 从/ 缺陷/ 特征/ 及/ 路径/ 条件/ 两个/ 角度/ 获得/ ./ 定义/ 4/ ./ 缺陷/ 特征/ (/ defectfeature/ )/ ./ 给定/ 缺陷/ 模式/ fsm/ ,/ 它/ 可以/ 检测/ 某一/ 程序/ 属性/ feature/ 是否/ 违反/ 了/ 程序/ 语法/ 或/ 语义/ 规则/ ,/ 该/ feature/ 对应/ 的/ 程序/ 变量/ 即/ 为/ 缺陷/ 模式/ fsm/ 的/ 缺陷/ 特征/ ,/ 记为/ Df/ (/ fsm/ )/ ./ 定义/ 5/ ./ 节点/ 关联/ 变量/ (/ vexrelatedvariable/ )/ ./ 对于/ 控制流/ 图/ G/ =/ (/ N/ ,/ E/ ,/ n0/ ,/ nf/ )/ ,/ / n/ ∈/ N/ ,/ / Var/ / Stmt/ (/ n/ )/ ,/ 其中/ 的/ Var/ 即为/ 节点/ n/ 的/ 关联/ 变量/ ,/ 记为/ RelVar/ (/ n/ )/ ./ 定义/ 6/ ./ 路径/ 条件/ (/ pathcondition/ )/ ./ 指在/ 控制流/ 迭代/ 过程/ 中/ 会/ 产生/ 路径/ 分支/ 的/ 数据流/ 值/ ./ CFG/ 中/ 只有/ 条件/ 分支/ 及/ 循环/ 节点/ 可以/ 产生/ 新/ 的/ 路径/ ,/ 因此/ 路径/ 条件/ 只能/ 在/ SelectionStmt/ 语句/ 中/ 产生/ ,/ 定义/ 条件/ 分支/ 头/ 节点/ n/ 的/ 路径/ 条件/ Pc/ (/ n/ )/ =/ {/ var/ |/ var/ ∈/ RelVar/ (/ n/ )/ ∧/ Stmt/ (/ n/ )/ ∈/ SelectionStmt/ }/ ,/ 它/ 包含/ 控制流/ 图中/ 条件/ 分支/ 及/ 循环/ 头/ 节点/ 关联/ 的/ 所有/ 变量/ ./ 缺陷/ 特征/ 可以/ 理解/ 为/ 缺陷/ 检测/ 是否/ 与/ 程序/ 中/ 某个/ 变量/ 相关/ ,/ 例如/ NPD/ 模式/ 必然/ 与/ 一个/ 指针/ 变量/ 相关/ ,/ RL/ 模式/ 必然/ 与/ 一个/ 资源/ 句柄/ 相关/ ;/ 路径/ 条件/ 则/ 是/ 程序/ 中/ 可能/ 会/ 产生/ 新/ 路径/ 的/ 条件/ 分支/ 语句/ 所/ 关联/ 的/ 变量/ ,/ 例如/ if/ -/ else/ 、/ switch/ 、/ while/ 等/ 语句/ 块/ 中/ 关联/ 的/ 条件/ 变量/ ./ 通过/ 对/ 程序控制/ 流/ 的/ 进一步/ 观察/ 发现/ ,/ 并非/ 所有/ 的/ 路径/ 条件/ 都/ 影响/ 缺陷/ 检测/ 结果/ ,/ 如图/ 2/ 程序/ 片段/ (/ a/ )/ 中/ P1/ 、/ P2/ 处/ 的/ 条件/ 分支/ 不会/ 对/ RL/ 的/ 检测/ 结果/ 产生/ 任何/ 影响/ ,/ 此类/ 路径/ 条件/ 不/ 应/ 作为/ 切片/ 准则/ ./ 另外/ ,/ 变量/ 间/ 的/ 数据/ 依赖/ 关系/ 也/ 会/ 影响/ 切片/ 准则/ 的/ 生成/ :/ 考虑/ 图/ 2/ 程序/ 片段/ (/ c/ )/ ,/ L2/ 处/ 赋值/ 语句/ 使得/ 数据流/ 迭代/ 计算/ 时/ a/ 的/ 数据流/ 值/ 依赖于/ b/ ,/ 同时/ 也/ 为/ a/ =/ 0/ ,/ flag/ =/ true/ 数据流/ 值/ 建立/ 了/ 关联/ 关系/ ;/ 由于/ b/ 并非/ 路径/ 条件/ ,/ 如果/ 将/ L1/ 处/ 语句/ 切片/ 掉/ 会/ 导致/ 上述/ 变量/ 间/ 的/ 关联/ 关系/ 丢失/ ,/ 有/ 可能/ 导致/ 数据流/ 迭代/ 的/ 断流/ ./ 本文/ 方法/ 通过/ 提前/ 进行/ 区间/ 运算/ ,/ 避免/ 了/ 赋值/ 语句/ 形成/ 的/ 数据/ 依赖/ 关系/ 对/ 程序/ 切片/ 的/ 影响/ ./ 我们/ 采用/ 数值/ 区间/ 来/ 表示/ 变量/ 的/ 抽象/ 取值/ ,/ 在/ 程序/ 切片/ 前/ 已经/ 通过/ 区间/ 运算/ 获取/ 了/ a/ 的/ 区间/ 信息/ ,/ 即使/ L1/ 处/ 切片/ 掉/ 也/ 不会/ 对/ 缺陷/ 检测/ 产生/ 影响/ ./ 基于/ 上述/ 分析/ ,/ 本文/ 切片/ 准则/ 定义/ 如下/ :/ SCSet/ =/ Df/ (/ fsm/ )/ ∪/ {/ Pc/ (/ ni/ )/ Stmt/ (/ ni/ )/ ∈/ 算法/ 1/ ./ 切片/ 准则/ 生成/ 算法/ ./ BranchList/ :/ 程序/ 中/ 所有/ 的/ 条件/ 分支/ 节点/ ./ IsPc/ (/ n/ )/ :/ 标志/ 条件/ 分支/ 节点/ n/ 所在/ 的/ 条件/ 语句/ 块/ Stmt/ (/ n/ )/ 中/ 是否/ 包含/ 切片/ 准则/ ,/ 以/ 标志/ 后续/ 的/ 切片/ 算法/ 中/ 是否/ 可以/ 将/ 整个/ 分支/ 语句/ 块/ 切片/ 掉/ ./ GetBranchVexList/ (/ n/ )/ :/ 获取/ 当前/ 条件/ 分支/ n/ 所在/ 分支/ 的/ 所有/ 语句/ 块/ ./ SkipBranchVexList/ (/ n/ )/ :/ 如果/ 条件/ 分支/ n/ 所在/ 的/ 条件/ 语句/ 块/ Stmt/ (/ n/ )/ 中/ 不/ 包含/ 切片/ 准则/ ,/ 则/ 可以/ 跳过/ 当前/ 分支/ 语句/ 块/ ,/ 继续/ 在/ 分支/ 后续/ 节点/ 中/ 遍历/ 查找/ 路径/ 条件/ ./ 输入/ :/ 控制流/ 图/ G/ 和/ 缺陷/ 模式/ fsm/ 输出/ :/ 切片/ 准则/ SCSet1/ ./ 获取/ 缺陷/ 特征/ Var/ =/ Df/ (/ fsm/ )/ ;/ SCSet/ ./ add/ (/ Var/ )/ ;/ 2/ ./ 计算/ 路径/ 条件/ 2.1/ ./ 查询/ 控制流/ 中/ 所有/ 条件/ 分支/ 头/ 节点/ ,/ 生成/ 条件/ foreachn/ ∈/ Gif/ (/ OutDegree/ (/ n/ )/ >/ 1/ )/ thenBranchList/ ./ add/ (/ n/ )/ ;/ end2/ ./ 2/ ./ 遍历/ 条件/ 分支/ 列表/ ,/ 查询/ 路径/ 条件/ Reverse/ (/ BranchList/ )/ ;/ foreachn/ ∈/ BranchListIsPc/ (/ n/ )/ =/ false/ ;/ Page6foreachn/ ∈/ GetBranchVexList/ (/ n/ )/ if/ (/ OutDegree/ (/ n/ )/ </ 2/ )/ thenif/ (/ Var/ ∈/ RelVar/ (/ n/ )/ )/ thenSCSet/ ./ add/ (/ Pc/ (/ n/ )/ )/ ;/ IsPc/ (/ n/ )/ =/ true/ ;/ break/ ;/ elseif/ (/ IsPc/ (/ n/ )/ )/ thenSCSet/ ./ add/ (/ Pc/ (/ n/ )/ )/ ;/ IsPc/ (/ n/ )/ =/ true/ ;/ break/ ;/ elseSkipBranchVexList/ (/ n/ )/ ;/ endend/ 算法/ 1/ 的/ 主要/ 开销/ 是步/ 2/ 中/ 路径/ 条件/ 的/ 查询/ ,/ 假设/ CFG/ 节点/ 数为/ N/ ,/ 分支/ 节点/ 数为/ Q/ ,/ 每个/ 分支/ 语句/ 块/ 的/ 节点/ 数为/ P/ (/ P/ / N/ )/ :/ 步/ 2.1/ 对/ CFG/ 节点/ 进行/ 遍历/ ,/ 将/ 所有/ 条件/ 分支/ 节点/ 加入/ 到/ BranchList/ 列表/ 中/ ,/ 复杂度/ 为/ O/ (/ N/ )/ ;/ 步/ 2.2/ 首先/ 将/ 条件/ 分支/ 列表/ BranchList/ 逆序/ ,/ 然后/ 依次/ 遍历/ 每个/ 条件/ 分支/ 语句/ 块/ GetBranchVexList/ (/ )/ 中/ 是否/ 包含/ 缺陷/ 相关/ 变量/ Var/ ,/ 一旦/ 当前/ 节点/ 关联/ 变量/ 包含/ Var/ ,/ 则/ 将/ 当前/ 路径/ 条件/ Pc/ (/ n/ )/ 加入/ 到/ SCSet/ ,/ 同时/ 设置/ IsPc/ (/ n/ )/ =/ true/ 标志/ 当前/ 条件/ 语句/ 块/ 中/ 包含/ 切片/ 准则/ ;/ 如果/ 存在/ 嵌套/ 分支/ 结构/ ,/ 通过/ 判断/ 内层/ 分支/ 语句/ 块/ 的/ IsPc/ (/ n/ )/ ,/ 决定/ 是否/ 可以/ 跳过/ 内层/ 分支/ 语句/ 块/ 的/ 分析/ SkipBranchVexList/ (/ )/ ,/ 复杂度/ 为/ O/ (/ Q/ ×/ P/ )/ ./ 因此/ ,/ 算法/ 1/ 的/ 复杂度/ 为/ O/ (/ N/ )/ +/ O/ (/ Q/ ×/ P/ )/ ./ 3.2/ 基于/ 缺陷/ 的/ 程序/ 切片/ 方法/ 程序/ 切片/ 算法/ 比较/ 经典/ 的/ 有/ Weiser/ 基于/ 数据流/ 方程/ 的/ 算法/ 、/ OttensteinKJ/ 和/ OttensteinLM/ [/ 12/ ]/ 以及/ Horwitz/ [/ 13/ ]/ 的/ 基于/ 程序/ 依赖图/ 的/ 可达性/ 算法/ ,/ 以及/ 基于/ 系统/ 依赖图/ 的/ 上下文/ 敏感/ 算法/ 等/ ./ 本文/ 采用/ Weiser/ 基于/ 数据流/ 方程/ 的/ 算法/ ,/ 按/ 如下/ 基本/ 规则/ 进行/ 切片/ :/ 遍历/ CFG/ 节点/ ,/ 观察/ 当前/ 节点/ 数据流/ 集合/ 中/ 是否/ 包含/ 算法/ 1/ 切片/ 准则/ 中/ 的/ 相关/ 变量/ ,/ 以/ 确定/ 该/ 节点/ 是否/ 应该/ 被/ 切片/ ,/ 并/ 根据/ 每个/ 节点/ 的/ 切片/ 标志/ 重构/ 控制流/ 图/ ./ 由于/ 切片/ 准则/ SCSet/ 中/ 可能/ 包含/ 全局变量/ ,/ 而/ 全局变量/ 可以/ 当作/ 函数/ 的/ “/ 隐式/ ”/ 参数/ ,/ 因此/ 对于/ 程序/ 中/ 存在/ 函数调用/ 的/ 语句/ 节点/ ,/ 在/ 切片/ 时/ 需要/ 特殊/ 处理/ :/ 如果/ 切片/ 准则/ 中/ 包含/ 全局变量/ ,/ 且/ 被/ 调用函数/ 的/ 函数/ 摘要/ 中/ 存在/ 对/ 该/ 全局变量/ 的/ 前置/ 约束/ ①/ ,/ 则/ 该/ 函数调用/ 语句/ 不应/ 被/ 切片/ ,/ 否则/ 会/ 造成/ 缺陷/ 检测/ 的/ 漏报/ ;/ 对于/ 其它/ 类型/ 的/ 函数调用/ 语句/ ,/ 可以/ 统一/ 按/ 上述/ 规则/ 进行/ 切片/ ,/ 即/ 根据/ 函数调用/ 点/ 的/ 实/ 参与/ 切片/ 准则/ 的/ 包含/ 关系/ 决定/ 是否/ 进行/ 切片/ ./ 对于/ C语言/ 中/ 较为/ 常见/ 的/ 复杂/ 数据类型/ 成员/ 引用/ ,/ 如/ 结构/ 体/ 成员/ 、/ 数组/ 元素/ 等/ ,/ 由于/ 本文/ 采用/ 的/ 是非/ 域/ 敏感/ 分析/ ,/ 从而/ 切片/ 准则/ 中/ 的/ 相关/ 变量/ 是/ 整个/ 的/ 结构/ 体/ 或/ 数组/ 变量/ (/ 例如/ inta/ [/ ]/ ,/ structs/ )/ ,/ 而/ 非/ 具体/ 的/ 某个/ 成员/ (/ 例如/ a/ [/ i/ ]/ ,/ s/ ./ field/ )/ ,/ 因此/ 包含/ 此类/ 变量/ 的/ 程序/ 语句/ 可以/ 统一/ 按/ 基本/ 规则/ 进行/ 切片/ ./ 本文/ 切片/ 算法/ 的/ 局限性/ 在于/ C语言/ 中/ 的/ 指针/ 变量/ :/ 指针/ 有/ 可能/ 对/ 切片/ 准则/ 中/ 的/ 变量/ 生成/ 复杂/ 或/ 难以/ 发现/ 的/ 别名/ 关系/ ,/ 进一步/ 地会/ 对/ 本文/ 的/ 切片/ 算法/ 产生/ 干扰/ ;/ 为了/ 减少/ 指针/ 操作/ 对/ 本文/ 切片/ 精度/ 的/ 影响/ ,/ 我们/ 已/ 实现/ 了/ 别名/ 分析/ ,/ 如何/ 提高/ 别名/ 分析/ 的/ 精度/ 也/ 是/ 我们/ 未来/ 工作/ 的/ 一个/ 重要/ 方面/ ./ 总之/ ,/ 本文/ 切片/ 算法/ 的/ 根本/ 原则/ 是/ “/ 保守/ 切片/ ”/ ,/ 即/ 对/ 无法/ 确定/ 是否/ 应该/ 被/ 切片/ 掉/ 的/ 语句/ 予以/ 保留/ ,/ 以/ 保证/ 缺陷/ 检测/ 过程/ 中/ 与/ 缺陷/ 相关/ 的/ 程序/ 语义/ 的/ 完备/ 性/ ./ 算法/ 2/ ./ 程序/ 切片/ 算法/ ./ sliceProcCall/ :/ 为/ false/ 时/ 表示/ 对/ 函数调用/ 语句/ 不/ 进行/ 切片/ ,/ 默认/ 为/ true/ ./ GetScope/ (/ var/ )/ :/ 获取/ 程序/ 中/ 变量/ var/ 的/ 作用域/ (/ 分为/ SourceFileScope/ ,/ MethodScope/ ,/ LocalScope/ 等/ )/ ./ SliceBranchVexList/ (/ n/ )/ :/ 如果/ 条件/ 分支/ 节点/ n/ 所在/ 语句/ 块/ Stmt/ (/ n/ )/ 不/ 包含/ 切片/ 准则/ ,/ 则/ 将/ n/ 所在/ 的/ 整个/ 分支/ 语句/ 块/ 切片/ 掉/ ,/ 以/ 提高/ 切片/ 效率/ ./ ExistProcCall/ (/ n/ )/ :/ 查询/ 节点/ n/ 所在/ 的/ 程序/ 语句/ Stmt/ (/ n/ )/ 中/ 是否/ 包含/ 函数调用/ ./ Slice/ (/ n/ )/ :/ 将/ n/ 从/ 控制流/ 图中/ 切片/ 掉/ ,/ 将/ 其/ 所有/ 前驱/ 与/ 后继/ 节点/ 相关联/ ./ 输入/ :/ 控制流/ 图/ G/ ,/ 切片/ 准则/ SCSet/ 输出/ :/ 切片/ 后/ 的/ 控制流/ 图/ G1/ ./ 查询/ 切片/ 准则/ 中/ 是否/ 包含/ 全局变量/ ,/ 以/ 标志/ 函数/ 调/ sliceProcCall/ =/ true/ ;/ foreachvar/ ∈/ SCSetif/ (/ GetScope/ (/ var/ )/ =/ =/ SourceFileScope/ )/ sliceProcCall/ =/ false/ ;/ break/ ;/ end2/ ./ 进行/ 程序/ 切片/ foreachn/ ∈/ G/ ∧/ n/ ≠/ n0/ ∧/ n/ ≠/ nf/ ①/ 本文/ 采用/ 函数/ 摘要/ 技术/ 实现/ 函数/ 间/ 分析/ :/ 根据/ 函数调用/ 关/ Page7if/ (/ RelVar/ (/ n/ )/ ∩/ SCSet/ =/ =/ null/ )/ thenif/ (/ !/ IsPc/ (/ n/ )/ )/ thenend/ 算法/ 2/ 首先/ 检测/ 切片/ 准则/ 中/ 是否/ 存在/ 文件/ 作用域/ 的/ 全局变量/ ,/ 并/ 设置/ sliceProcCall/ 标志/ 是否/ 需要/ 对/ 函数调用/ 语句/ 进行/ 切片/ ;/ 然后/ 遍历/ CFG/ ,/ 计算/ 每个/ 节点/ 关联/ 变量/ 与/ 切片/ 准则/ SCSet/ 的/ 交集/ ,/ 如果/ 交集/ 为空/ ,/ 再/ 根据/ 函数调用/ 语句/ 的/ 切片/ 规则/ ,/ 决定/ 当前/ 节点/ 是否/ 应该/ 被/ 切片/ 掉/ Slice/ (/ )/ ./ 为了/ 进一步提高/ 算法/ 效率/ ,/ 如果/ 被/ 切片/ 的/ 节点/ 为/ 条件/ 分支/ 节点/ ,/ 则/ 可以/ 利用/ 算法/ 1/ 中/ 设置/ 的/ 条件/ 语句/ 块/ 是否/ 包含/ 切片/ 准则/ 标志/ IsPc/ (/ )/ ,/ 确定/ 能否/ 切片/ 掉/ 整个/ 分支/ 语句/ 块/ SliceBranchVexList/ (/ )/ ./ 上述/ 切片/ 算法/ 中/ ,/ 切片/ 准则/ SCSet/ 中/ 变量/ 数为/ 常量/ ,/ 因此/ 步/ 1/ 中/ for/ 循环/ 的/ 复杂度/ 为/ O/ (/ 1/ )/ ;/ 在/ 控制流/ 图/ 创建/ 过程/ 中/ 可以/ 为/ 每个/ 节点/ n/ 添加/ 是否/ 存在/ 函数调用/ 语句/ 的/ 附加/ 属性/ ,/ 因此/ ExistProcCall/ (/ n/ )/ 的/ 复杂度/ 为/ O/ (/ 1/ )/ ;/ Slice/ (/ n/ )/ 将/ n/ 的/ 所有/ 前驱/ 与/ 后继/ 相关联/ ,/ 复杂度/ 取决于/ n/ 的/ 出度/ 与/ 入度/ 之/ 和/ ,/ 在/ 实际/ 程序/ 中为/ 常值/ ;/ SliceBranchVex/ -/ List/ (/ n/ )/ 直接/ 将/ 分支/ 语句/ 块/ 的/ 前驱/ 及/ 后继/ 相关联/ ,/ 复杂度/ 取决于/ 从/ 分支/ 入口/ 节点/ 遍历/ 至/ 汇合/ 节点/ 处/ 的/ 节点/ 数/ ,/ 即/ 分支/ 语句/ 块/ 的/ 节点/ 数/ P/ ,/ 因此/ 复杂度/ 为/ O/ (/ P/ )/ ./ 整个/ 算法/ 的/ 复杂度/ 取决于/ for/ 循环/ 中/ CFG/ 节点/ 数/ N/ ,/ 因此/ 算法/ 2/ 的/ 复杂度/ 为/ O/ (/ N/ ×/ P/ )/ ./ 应用程序/ 切片/ 技术/ 后/ ,/ 控制流/ 图/ 节点/ 数及/ 状态/ 条件/ 中/ 变量/ 数会/ 相应/ 地/ 减少/ ,/ 从而/ 分别/ 影响/ 缺陷/ 状态/ 迭代/ 的/ 次数/ 及/ 每次/ 迭代/ 时/ 的/ 计算/ 量/ ,/ 因此/ 可以/ 通过/ 切片/ 效果/ 对/ 效率/ 提升/ 情况/ 进行/ 粗略/ 估计/ ./ 切片/ 效果/ η/ 可以/ 理解/ 为/ 切片/ 掉/ 节点/ 数/ 与/ 原/ 节点/ 数/ 的/ 比值/ ,/ η/ 越/ 接近/ 1/ 则/ 表明/ 切片/ 效果/ 越好/ ./ 假定/ 源程序/ 中/ 控制流/ 节点/ 总数/ 为/ / ,/ 切片/ 程序/ 中/ 节点/ 总数/ 为/ φ/ ,/ 则/ 切片/ 效果/ η/ =/ / -/ φ/ 少/ 而/ 引发/ 的/ 效率/ 提升/ 情况/ ./ 当然/ ,/ 实际/ 的/ 缺陷/ 检测/ 还/ 受到/ 其它/ 因素/ 的/ 影响/ ,/ 如/ 状态/ 条件/ 的/ 计算/ 和/ 传递/ 、/ 状态/ 迁移/ 条件/ 是否/ 成立/ 的/ 判断/ 等/ ,/ 因此/ 实际/ 的/ 效率/ 提升/ 值会/ 小于/ η/ ./ 3.3/ 一种/ 基于/ 切片/ 的/ 缺陷/ 状态/ 合并/ 策略/ 为/ 进一步提高/ 检测/ 精度/ ,/ 本文/ 提出/ 一种/ 基于/ 切片/ 的/ 缺陷/ 状态/ 合并/ 策略/ ,/ 根据/ 控制流/ 分支/ 节点/ 的/ 路径/ 条件/ ,/ 在/ 缺陷/ 状态/ 上/ 添加/ 状态/ 属性/ (/ stateattribute/ )/ ,/ 从而/ 可以/ 根据/ 状态/ 属性/ 来/ 决定/ 在/ 控制流/ 汇合/ 节点/ 是否/ 需要/ 进行/ 状态/ 合并/ ./ 该/ 合并/ 策略/ 有/ 选择地/ 在/ 汇合/ 节点/ 进行/ 状态/ 合并/ ,/ 保存/ 了/ 与/ 缺陷/ 特征/ (/ defectfeature/ )/ 有关/ 的/ 路径/ 信息/ 从而/ 减少/ 误报/ ./ 定义/ 7/ ./ 状态/ 属性/ (/ stateattribute/ )/ ./ 给定/ 缺陷/ 状态/ S/ 及/ 当前/ CFG/ 节点/ n/ ,/ 如果/ Stmt/ (/ n/ )/ ∈/ SelectionStmt/ ,/ 则/ S/ 的/ 状态/ 属性/ Attr/ (/ S/ )/ =/ RelVar/ (/ n/ )/ ./ 算法/ 3/ ./ 一种/ 基于/ 切片/ 的/ 缺陷/ 状态/ 合并/ 算法/ ./ ST/ 、/ SF/ :/ 真假/ 分支/ 中/ 的/ 缺陷/ 状态/ ./ StateCompute/ (/ S/ )/ :/ 根据/ 当前/ 节点/ 的/ 数据流/ 信息/ ,/ 更新/ S/ 的/ 状态/ 条件/ ,/ 并/ 判断/ 状态/ 迁移/ 情况/ ./ MergeState/ (/ ST/ ,/ SF/ )/ :/ 合并/ 真假/ 分支/ 汇聚/ 处/ 的/ 缺陷/ 状态/ ,/ 同时/ 将/ 相同/ 的/ 状态/ 条件/ 进行/ 合并/ ./ IsSameTypeState/ (/ ST/ ,/ SF/ )/ :/ 判断/ 分支/ 汇聚/ 处/ 真假/ 分支/ 的/ 缺陷/ 状态/ ST/ 、/ SF/ 是否/ 为/ 相同/ 类型/ 的/ 状态/ ./ 输入/ :/ 分支/ 节点/ n/ 及/ 缺陷/ 状态/ S/ 输出/ :/ 汇合/ 节点/ n/ 处/ 的/ 缺陷/ 状态/ S1/ ./ 遍历/ 条件/ 分支/ 语句/ 的/ 真假/ 分支/ ,/ 进行/ 缺陷/ 状态/ 迭代/ Var/ =/ Pc/ (/ n/ )/ ;/ Attr/ (/ ST/ )/ =/ Attr/ (/ SF/ )/ =/ Var/ ;/ StateCompute/ (/ ST/ )/ ;/ StateCompute/ (/ SF/ )/ ;/ 2/ ./ 在/ 条件/ 分支/ 语句/ 的/ 汇合/ 节点/ ,/ 按/ 规则/ 合并/ 真假/ 分支/ if/ (/ !/ IsSameTypeState/ (/ ST/ ,/ SF/ )/ )/ thenS/ =/ ST/ ∪/ SF/ ;/ elseif/ (/ Attr/ (/ ST/ )/ / SCSet/ ∨/ Attr/ (/ SF/ )/ / SCSet/ )/ thenS/ =/ ST/ ∪/ SF/ ;/ elseS/ =/ MergeState/ (/ ST/ ,/ SF/ )/ ./ 上述/ 算法/ 中/ ,/ 步/ 1/ 首先/ 计算/ 分支/ 节点/ n/ 的/ 路径/ 条件/ Pc/ (/ n/ )/ ,/ 为/ 初始状态/ S/ 添加/ 状态/ 属性/ ,/ 然后/ 根据/ 真假/ 分支/ 中/ 不同/ 的/ 数据流/ 值/ 进行/ 状态/ 迭代/ StateCompute/ (/ )/ 并/ 更新/ S/ 的/ 状态/ 条件/ ;/ 状态/ 迭代/ 的/ 复杂度/ 取决于/ 分支/ 语句/ 块/ 的/ 节点/ 数/ P/ ,/ 因此/ 复杂度/ 为/ O/ (/ P/ )/ ;/ 步/ 2/ 首先/ 通过/ IsSameTypeState/ (/ ST/ ,/ SF/ )/ 判断/ 汇合/ 节点/ 是否/ 为/ 相同/ 状态/ ,/ 状态/ 合并/ 前/ 再进一步/ 检查/ 状态/ 属性/ Attr/ (/ S/ )/ 是否/ 包含/ 于/ 切片/ 准则/ ,/ 以/ 确定/ 是否/ 需要/ 状态/ 合并/ MergeState/ (/ ST/ ,/ SF/ )/ ;/ 状态/ 合并/ 实际上/ 是/ 对/ 相同/ 缺陷/ 状态/ 的/ 状态/ 条件/ 进行/ 合并/ ,/ 复杂度/ 取决于/ 执行/ 路径/ 上/ 相关/ 变量/ 的/ 数量/ ,/ 在/ 实际/ 程序/ 中/ 这/ 是/ 一个/ 常值/ ,/ 因此/ 算法/ 3/ 的/ 复杂度/ 为/ O/ (/ P/ )/ ./ 通过/ 前文/ 对/ 算法/ 1/ ~/ 3/ 复杂度/ 的/ 描述/ ,/ 本文/ 算法/ 复杂度/ 主要/ 依赖于/ 控制流/ 图/ 节点/ 数/ N/ 、/ 条件/ 分支/ 数/ Page8/ 量/ Q/ 及/ 每个/ 条件/ 分支/ 语句/ 块/ 包含/ 的/ 节点/ 数/ P/ ,/ 实际/ 程序/ 中/ Q/ / P/ / N/ </ λ/ ,/ λ/ 为/ 常量/ ,/ 因此/ 本文/ 算法/ 复杂度/ 较/ 低/ ./ 另外/ ,/ 算法/ 1/ 生成/ 了/ 后续/ 算法/ 2/ 、/ 3/ 所用/ 到/ 的/ 大部分/ 数据/ ,/ 且/ 该/ 部分/ 数据/ 可以/ 作为/ 控制流/ 节点/ 的/ 静态/ 属性/ 进行/ 传递/ ,/ 从而/ 进一步/ 减少/ 了/ 算法/ 2/ 、/ 3/ 的/ 计算/ 量/ ./ 3.4/ 实例/ 分析/ 对于/ 图/ 2/ 中/ 程序/ 片段/ (/ a/ )/ ,/ 应用/ 前/ 文/ 描述/ 的/ 程序/ 切片/ 方法/ 和/ 缺陷/ 状态/ 合并/ 策略/ 对/ RL/ 模式/ 进行/ 检测/ ,/ 其/ 简要/ 的/ 分析/ 流程/ 如下/ :/ 1/ ./ 得到/ RL/ 缺陷/ 模式/ 特征/ :/ Df/ (/ RL/ )/ =/ {/ f/ }/ ;/ 表/ 2/ 应用/ 本文/ 方法/ 后图/ 2/ 中/ 程序/ (/ b/ )/ 的/ 状态/ 迁移/ 序列/ 语句/ L1L2L3L4L5L6L7L84/ 实验/ 结果/ 及/ 分析/ 本/ 节/ 首先/ 介绍/ 缺陷/ 检测/ 系统/ (/ DefectTestingSystem/ ,/ DTS/ )/ 测试/ 框架/ 及/ 缺陷/ 检测/ 的/ 整体/ 分析/ 流程/ ,/ 给出/ 我们/ DTSGCC/ 的/ 实验/ 环境/ 设置/ ,/ 然后/ 对/ 实验/ 数据/ 进行/ 分析/ ,/ 分别/ 以/ 检测时间/ 和/ 误报率/ 作为/ 衡量/ 效率/ 和/ 精度/ 提升/ 情况/ 的/ 指标/ ./ 4.1/ 实验/ 环境/ DTS/ [/ 3/ ,/ 14/ ]/ 采用/ 状态机/ 来/ 统一/ 描述/ 缺陷/ 模式/ ,/ 目前/ 能/ 检测/ 的/ 缺陷/ 模式/ 包括/ 200/ 多种/ ,/ 且/ 可以/ 根据/ 用户/ 需求/ 进行/ 快速/ 模式/ 定制/ ./ 将/ 缺陷/ 模式/ 按/ 其/ 造成/ 的/ 影响/ 分为/ 四类/ :/ 故障/ 模式/ 、/ 安全漏洞/ 模式/ 、/ 疑问/ 代码/ 模式/ 、/ 规则/ 模式/ ,/ 本文/ 讨论/ 的/ RL/ 和/ NPD/ 模式/ 属于/ 故障/ 模式/ ./ DTS/ 总体/ 框架/ 及/ 整体/ 的/ 缺陷/ 检测/ 流程/ 如图/ 3/ :/ (/ 1/ )/ 对外/ 接口/ ./ 输入/ 部分/ 收集/ 待测/ 程序/ 源文件/ ,/ 并/ 从/ 缺陷/ 模式/ 配置文件/ 中/ 读取/ 待/ 检测/ 的/ 缺陷/ 模式/ ;/ 测试/ 结果/ 模块/ 负责/ 将/ 缺陷/ 检测/ 结果/ 写入/ 缺陷/ 库中/ ,/ 并/ 提供/ UI/ 界面/ 以/ 方便/ 人工/ 缺陷/ 确认/ ;/ (/ 2/ )/ 基本/ 处理/ 模块/ 是/ 整个/ 静态/ 缺陷/ 检测/ 的/ 基/ 2/ ./ 应用/ 算法/ 1/ ,/ 得到/ L4/ 、/ L6/ 处/ 路径/ 条件/ Pc/ (/ L4/ )/ =/ {/ dump/ }/ ,/ Pc/ (/ L6/ )/ =/ {/ flag/ }/ ,/ 因此/ 切片/ 准则/ SCSet/ (/ RL/ )/ =/ {/ f/ ,/ dump/ ,/ flag/ }/ ;/ 3/ ./ 应用/ 算法/ 2/ 将/ 程序/ 片段/ (/ a/ )/ 进行/ 切片/ ,/ 即可/ 切片/ 掉/ P1/ 、/ P2/ 处/ 与/ RL/ 分析/ 无关/ 的/ 代码/ ,/ 得到/ 程序/ 片段/ (/ b/ )/ ;/ 4/ ./ 应用/ 算法/ 3/ ,/ (/ b/ )/ 片段/ 的/ 状态/ 迭代/ 序列/ 如表/ 2/ ./ 由于/ 切片/ 掉/ 了/ P1/ 、/ P2/ 处/ 的/ 冗余/ 语句/ ,/ 因此/ 状态/ 条件/ 中/ 与/ 缺陷/ 检测/ 无关/ 的/ 变量/ i/ 和/ j/ 被/ 切片/ 掉/ ;/ 在/ L4/ 处/ 由于/ Attr/ (/ Start/ )/ =/ {/ dump/ }/ / SCSet/ (/ RL/ )/ ,/ 因此/ L2/ 分支/ 产生/ 的/ 两个/ $/ start/ 状态/ 在/ 控制流/ 汇合/ 节点/ L4/ 不/ 进行/ 状态/ 合并/ ;/ 在/ L6/ 处/ ,/ $/ start/ 状态/ 保留/ 了/ flag/ 与/ dump/ 的/ 关联/ 关系/ ,/ 不会/ 执行/ 真/ 分支/ 中/ 的/ Close/ 操作/ ,/ 因此/ 不会/ 产生/ 误报/ ./ 础/ ./ 首先/ 通过/ 语法分析/ 器/ (/ CParser/ )/ 生成/ 待测/ 代码/ 的/ 抽象/ 语法/ 树/ (/ AbstractSyntaxTree/ ,/ AST/ )/ ,/ 然后/ 遍历/ AST/ 生成/ 符号表/ (/ SymbolTable/ )/ ,/ 其中/ 包含/ 了/ 源程序/ 中/ 各/ 词法/ 单元/ 的/ 类型/ 、/ 作用域/ 等/ 信息/ ,/ 进一步/ 生成/ 源程序/ 中/ 各/ 函数/ 的/ 控制流/ 图/ ,/ 并/ 基于/ 控制流/ 图/ 进行/ 定义/ -/ 使用/ 链分析/ ;/ (/ 3/ )/ 缺陷/ 模式/ 自动检测/ 模块/ 按照/ 函数调用/ 关系/ 的/ 拓扑/ 逆序/ ,/ 依次/ 对/ 每个/ 函数/ 进行/ 缺陷/ 自动机/ 状态/ 迭代/ ./ 首先/ 调用/ 缺陷/ 模式/ 状态机/ 解析器/ 加载/ 待/ 检测/ 的/ 缺陷/ 模式/ ,/ 然后/ 根据/ 缺陷/ 模式/ 的/ 创建/ 条件/ 遍历/ 函数/ 语法/ 树/ ,/ 将/ 创建/ 的/ 自动机/ 实例/ 集合/ 置于/ 函数/ 控制/ 流入/ 口/ 节点/ ,/ 最后/ 根据/ 每个/ 控制流/ 节点/ 数据流/ 分析/ 的/ 结果/ 更新/ 所有/ 缺陷/ 状态/ 的/ 状态/ 条件/ 同时/ 进行/ 状态/ 迁移/ 判断/ ,/ 直至/ 缺陷/ 状态/ 迁移/ 为/ Error/ 表示/ 发现/ 某/ 类型/ 的/ 缺陷/ ,/ 或者/ 迁移/ 到/ End/ 状态/ 表示/ 未/ 发现/ 缺陷/ 并/ 自动/ 销毁/ 状态机/ 实例/ ;/ (/ 4/ )/ 提高/ 精度/ 模块/ ./ 区间/ 分析/ 的/ 结果/ 直接/ 影响/ 整个/ 缺陷/ 检测/ 的/ 精度/ ,/ 因此/ DTS/ 分别/ 实现/ 了/ 基于/ 函数/ 摘要/ 的/ 上下文/ 敏感/ 的/ 函数/ 间/ 分析/ ,/ 及/ 基于/ 缺陷/ 状态/ 合并/ 的/ 路径/ 敏感/ 的/ 函数/ 内/ 分析/ ,/ 本文/ 的/ 研究/ 点/ 即/ 为/ 如何/ 使/ 后者/ 效率/ 及/ 精度/ 更好/ ./ Page9/ 图/ 3DTS/ 总体/ 框架/ 及/ DTS/ 整体/ 分析/ 流程/ DTS/ 除/ 对外/ 接口/ 外/ ,/ 其它/ 模块/ 对/ 用户/ 是/ 透明/ 的/ ,/ 且/ 底层/ 改动/ 不会/ 影响/ 上层/ 处理/ 逻辑/ ,/ 这种/ 松/ 耦合/ 架构/ 使/ 其/ 具有/ 良好/ 的/ 扩展性/ ,/ 例如/ 通过/ 自定义/ 缺陷/ 模式/ 及/ 第三方/ 语法/ 生成器/ (/ CompilerCompiler/ )/ ,/ 可以/ 快速/ 生成/ 支持/ 某一/ 语言/ 族/ 程序/ ①/ 的/ 缺陷/ 检测工具/ ./ GCC/ 作为/ Linux/ 系统/ 中/ 开发/ C语言/ 程序/ 的/ 主流/ 编译器/ ,/ 通过/ 对/ ANSIC/ 标准/ 进行/ 语法/ 扩展/ 获得/ 了/ 更/ 高/ 灵活性/ 的/ 同时/ ,/ 其/ 程序/ 语义/ 也/ 更加/ 复杂/ ,/ 导致/ 其/ 出现/ 软件缺陷/ 的/ 机率/ 也/ 更/ 高/ ,/ 且/ 难于/ 检测/ ./ 本文/ 基于/ 上述/ DTS/ 框架/ 设计/ 实现/ 了/ 路径/ 敏感/ 的/ 静态/ 缺陷/ 检测工具/ DTSGCC/ ,/ 不仅/ 可以/ 检测/ ANSIC/ 标准/ 的/ 源程序/ ,/ 而且/ 可以/ 针对/ Linux/ 中/ GCC/ 标准/ 的/ 开源/ 工程/ 进行/ 检测/ :/ 首先/ 修改/ 工程/ 配置文件/ 中/ 的/ 预处理/ 选项/ ,/ 并/ 调用/ 修改/ 后/ 的/ 配置文件/ 编译/ 原/ 工程/ ,/ 使/ 之/ 保留/ 编译/ 过程/ 中/ 产生/ 的/ 中间/ 文件/ (/ 后缀名/ 为/ ./ i/ )/ ;/ 然后/ ,/ 以此/ 预处理/ 后/ 的/ 中间/ 文件/ 作为/ DTSGCC/ 的/ 输入/ ,/ 即/ 可以/ 按照/ 图/ 3/ 中/ 的/ 分析/ 流程/ 进行/ 缺陷/ 检测/ ②/ ./ 本文/ 使用/ DTSGCC1/ ./ 0/ 采用/ 不同/ 的/ 分析方法/ 对/ Linux/ 中/ 10/ 个/ 开源/ 工程/ 进行/ 了/ 缺陷/ 检测/ 对比/ 实验/ ,/ 扫描/ 的/ 缺陷/ 模式/ 包括/ RL/ 和/ NPD/ ./ 这/ 10/ 个/ 开源/ 工程/ 中/ ,/ 源代码/ 量/ 最小/ 的/ Combine/ 为/ 1.6/ 万行/ ,/ 最大/ 的/ Binutils/ 为/ 103/ 万行/ ./ 实验所/ 使用/ 电脑/ 基本/ 配置/ 为/ IntelE21601/ ./ 8GHzCPU/ 、/ 2GB/ 内存/ 、/ WindowsXP/ 操作系统/ ./ 实验/ 过程/ 中/ 使用/ 两种/ 不同/ 的/ 分析方法/ :/ 方法/ 1/ ./ 文献/ [/ 3/ ]/ 提出/ 的/ 相同/ 状态/ 合并/ 的/ 路径/ 敏感/ 方法/ ;/ 方法/ 2/ ./ 本文/ 提出/ 的/ 基于/ 程序/ 切片/ 的/ 路径/ 敏感/ 方法/ ./ 4.2/ 检测/ 结果/ 及/ 分析/ 基于/ 以上/ 实验/ 设置/ ,/ 对/ 静态/ 缺陷/ 检测/ 结果/ 进行/ 了/ 人工/ 确认/ ,/ 结果/ 如表/ 3/ 所示/ ./ 其中/ ,/ 文件/ 数只/ 统计/ 后缀/ 为/ ./ c/ 或/ ./ h/ 的/ 源文件/ ,/ 源代码/ 行数/ 为/ 去/ 除了/ 空行/ 后/ 的/ 统计/ 结果/ ./ DTSGCC/ 并/ 不/ 对/ C/ 源文件/ 直接/ 进行/ 检测/ ,/ 而是/ 通过/ GCC/ 编译器/ 对/ 其/ 进行/ 预处理/ (/ 包括/ 头文件/ 展开/ 、/ 条件/ 编译/ 执行/ 、/ 宏/ 定义/ 替换/ )/ ,/ 对/ 得到/ 的/ 中间/ 文件/ 进行/ 处理/ ,/ 因此/ 实际/ 测试代码/ 量/ 为/ 中间/ 文件/ 的/ 代码/ 量/ ./ 应用/ 本文/ 程序/ 切片/ 方法/ 后/ ,/ 控制流/ 图/ 节点/ 数/ 的/ 变化/ 可以/ 反映/ 程序/ 切片/ 的/ 效果/ ,/ 从而/ 可以/ 粗略地/ 估计/ 效率/ 提升/ 情况/ ./ 统计/ 结果表明/ ,/ 对表/ 3/ 中/ 10/ 个/ 工程/ 检测/ 其/ NPD/ 和/ RL/ 缺陷/ ,/ 共/ 检测/ 源代码/ 量/ 154/ 万行/ ,/ 中间/ 文件/ 代码/ 量/ 761/ 万行/ ,/ 方法/ 1/ 用时/ 13.52/ h/ ,/ 共/ 上报/ 2228/ 个/ 检查点/ (/ InspectionPoint/ ,/ IP/ )/ ,/ 而/ 本文/ 方法/ 用时/ 11.73/ h/ ,/ IP/ 数/ 减少/ 为/ 1896/ 个/ ,/ 检测/ 效率/ 提高/ 了/ 13.28/ %/ ,/ 误报率/ 降低/ 了/ 5.90/ %/ ./ 下文/ 分别/ 对/ 效率/ 、/ ①/ ②/ Page10/ 精度/ 提升/ 情况/ 及/ DTS/ 缺陷/ 检测工具/ 的/ 有效性/ 进行/ 分析/ ./ (/ 1/ )/ 效率/ 提升/ 分析/ ./ 3.2/ 节/ 从/ 理论/ 上/ 分析/ 了/ 应用/ 本文/ 方法/ 后/ 效率/ 提升/ 情况/ 与/ 切片/ 效果/ 的/ 关系/ ./ 表/ 3/ 统计/ 结果表明/ ,/ 在/ 切片/ 效果/ η/ =/ 41.19/ %/ 时/ ,/ 实际/ 的/ 效率/ 提升/ 为/ 13.28/ %/ ,/ 与/ 我们/ 的/ 分析/ 结论/ 是/ 相吻合/ 的/ ./ 工程/ 名称/ 源文件/ 数/ 源代码/ 表/ 3/ 对比/ 实验/ 结果/ 1Combine/ -/ 0.3/ ./ 474167013289286779153283360134217Antiword/ -/ 0.378024315126058281674231611096992651028/ Make3/ ./ 81Readline/ -/ 6.1/ Wdiff/ -/ 0.6/ ./ 3gnome/ -/ media/ -/ 2.14/ ./ 01182745715220371412753709392716158925834UUCP/ -/ 1.07/ Bash/ -/ 4.1/ Openssl/ -/ 0.9/ ./ 811182267223110791179130401220353807435818877399/ -/ 19Binutils/ -/ 2.20/ ./ 1166810350451284531113449591034126126639915920061/ 合计/ 387915473487617471751329923486812228194032422161896332/ (/ 2/ )/ 精度/ 提升/ 分析/ ./ 上述/ 分析表明/ 本文/ 方法/ 可以/ 减少/ 5.90/ %/ 的/ 误报/ ,/ 但/ 对于/ Openssl/ 工程/ ,/ 误报/ 反而/ 出现/ 了/ 增长/ 的/ 情况/ ./ 经过/ 人工/ 确认/ ,/ 这种/ 精度/ “/ 反/ 提升/ ”/ 是/ 由于/ 部分/ 文件/ 分析/ 时/ 内存/ 溢出/ 导致/ 分析/ 失败/ 造成/ 的/ ./ 对/ 中间代码/ 进行/ 逐个/ 排查/ 发现/ ,/ 导致/ 内存/ 溢出/ 的/ 原因/ 是/ 预处理/ 后/ 的/ 中间/ 文件/ 过于/ 复杂/ ,/ 另外/ 一些/ 成员/ 数量/ 非常/ 多/ 的/ enum/ 、/ struct/ 类型/ 也/ 是/ 导致/ 分析/ 失败/ 的/ 另/ 一/ 重要/ 原因/ ./ 一个/ 非常/ 典型/ 的/ 分析/ 失败/ 的/ 例子/ 如下/ :/ 位于/ openssl/ -/ 0.9/ ./ 8/ // crypto/ // bn/ // bn/ _/ asm/ ./ c/ 源文件/ 中/ 435/ 行/ 的/ 宏/ 定义/ mul/ _/ add/ _/ c/ ,/ 在/ 550/ 行/ 的/ 函数/ bn/ _/ mul/ _/ comba8/ 中/ 大量/ 使用/ ,/ 经过/ 预处理/ 后宏/ 定义/ 的/ 展开/ 形式/ 非常复杂/ ①/ ,/ 这种/ 复杂/ 的/ 中间代码/ 有/ 可能/ 导致/ 本文/ 语法分析/ 器/ 创建/ AST/ 时/ 失败/ ,/ 或者/ 造成/ 在/ 数据流/ 分析/ 过程/ 中/ 由于/ 控制流/ 节点/ 众多/ 而/ 导致/ 迭代/ 分析/ 失败/ ,/ 从而/ 造成/ 整个/ 源文件/ 的/ 分析/ 失败/ ;/ 另外/ ,/ 由于/ C/ 工程/ 中/ 的/ 交叉/ 引用/ 关系/ ,/ 使得/ 依赖于/ 此/ 文件/ 的/ 其它/ 文件/ 也/ 分析/ 失败/ ,/ 从而/ 导致/ 分析/ 结果/ 中/ 上报/ IP/ 的/ 数量/ 减少/ ./ 而/ 采用/ 切片/ 算法/ 后/ ,/ 由于/ 切片/ 后/ 控制流/ 图/ 节点/ 数/ 减少/ ,/ 原来/ 由于/ 第/ 2/ 种/ 原因/ 分析/ 失败/ 的/ 文件/ 将/ 有/ 可能/ 正常/ 分析/ ,/ 因此/ 会/ 上报/ 更/ 多/ 的/ IP/ ,/ 也/ 就/ 出现/ 了/ IP/ 数/ 不减/ 反增/ 的/ 现象/ ./ 对于/ 可以/ 正常/ 分析/ 的/ 文件/ ,/ 对/ 其/ 缺陷/ 检测/ 结果/ 进行/ 人工/ 确认/ 后/ ,/ 发现/ 了/ 引起/ 误报/ 的/ 几类/ 主要/ 原因/ ./ 一是/ 由于/ DTSGCC/ 并未/ 对/ 数组/ 、/ 结构/ 体/ 成员/ 建模/ ,/ 即/ 另外/ ,/ 对/ Combine/ 和/ Antiword/ 等/ 代码/ 量/ 相对/ 较/ 小/ 的/ 工程/ ,/ 采用/ 程序/ 切片/ 方法/ 后/ 对/ 效率/ 影响/ 不/ 大/ ,/ 甚至/ 极端/ 情况/ 下/ 分析/ 时间/ 会/ 略有/ 增长/ ,/ 而/ 对于/ 代码/ 量/ 较大/ 的/ 工程/ 则/ 不会/ 出现/ 类似/ 情况/ ,/ 主要/ 原因/ 是/ 代码/ 量/ 较/ 小时/ 切片/ 准则/ 计算/ 及/ 程序/ 切片/ 所用/ 时间/ 与/ 方法/ 1/ 中/ 冗余/ 节点/ 的/ 状态/ 迭代/ 计算/ 时间/ 抵消/ 了/ ./ 相同/ 状态/ 合并/ 策略/ 的/ 结果/ 节点/ 数/ 分析/ 时间/ // s/ 没有/ 实现/ 域/ 敏感/ 分析/ [/ 15/ -/ 16/ ]/ ,/ 而/ 实际/ 工程/ 中/ 结构/ 体/ 、/ 数组/ 应用/ 非常/ 广泛/ ,/ 导致/ 此类/ 误报/ 较/ 多/ ,/ 例如/ combine/ 工程/ src/ \/ index/ ./ c/ 文件/ 会/ 在/ 500/ 行/ 上报/ 一个/ NPD/ :/ 487/ :/ curr/ _/ record/ _/ position/ =/ chunk/ [/ key/ _/ position/ ]/ ./ first/ _/ record/ ;/ 488/ :/ curr/ _/ record/ _/ entry/ =/ NULL/ ;/ 489/ :/ while/ (/ curr/ _/ record/ _/ position/ !/ =/ 0/ )/ {/ …/ …/ 494/ :/ if/ (/ curr/ _/ record/ _/ entry/ =/ =/ NULL/ )/ 495/ :/ returnEXIT/ _/ FAILURE/ ;/ …/ …/ 500/ :/ curr/ _/ record/ _/ entry/ -/ >/ next/ _/ same/ _/ key/ =/ // // 循环/ 条件/ 信息/ 不/ 准确/ ,/ 导致/ 循环/ 内/ 区间/ 计算/ 不/ 精确/ }/ 由于/ 487/ 行将/ 结构/ 体/ 成员/ 赋值/ 给/ curr/ _/ record/ _/ position/ ,/ 在/ 489/ 行/ 的/ 循环/ 无法/ 判断/ 循环/ 迭代/ 情况/ ,/ 因此/ 494/ 行/ 的/ 条件/ 判断/ 只能/ 保守/ 性/ 计算/ 出/ curr/ _/ record/ _/ entry/ 的/ 值/ 为/ 空/ 或非/ 空/ 的/ 集合/ ,/ 因此/ 500/ 行会/ 出现/ NPD/ 误报/ ./ 另一类/ 误报/ 则/ 是/ 由于/ 本文/ 方法/ 采用/ 的/ 上下文/ 敏感/ 分析/ 策略/ 不/ 完善/ ,/ 导致/ 程序/ 中/ 的/ 函数调用/ 节点/ 无法/ 精确/ 计算/ 其/ 对/ 上下文/ 数据流/ 迭代/ 的/ 影响/ ,/ 从而/ 状态/ 迁移/ 的/ 条件/ 无法/ 精确/ 计算/ ,/ ①/ 如/ 位于/ 563/ 行/ 的/ 宏/ 定义/ mul/ _/ add/ _/ c/ (/ a/ [/ 0/ ]/ ,/ b/ [/ 0/ ]/ ,/ c1/ ,/ c2/ ,/ c3/ )/ ,/ Page11/ 导致/ 误报/ ./ 第/ 1/ 类/ 误报/ 的/ 消除/ 需要/ 在/ DTS/ 框架/ 中/ 实现/ 域/ 敏感/ 分析/ ,/ 从而/ 对/ 结构/ 体/ 和/ 数组/ 成员/ 都/ 可以/ 独立/ 分析/ ;/ 第/ 2/ 类/ 误报/ 的/ 消除/ 需要/ 改进/ 现有/ 的/ 上下文/ 敏感/ 分析/ 策略/ ,/ 避免/ 由于/ 函数调用/ 引起/ 状态/ 迭代/ 错误/ ./ 尽管/ 存在/ 上述/ 不足/ ,/ 实验/ 统计/ 结果表明/ 误报率/ 由/ 66.29/ %/ 降低/ 到/ 了/ 60.39/ %/ ,/ 减少/ 了/ 6/ %/ 左右/ ,/ 说明/ 本文/ 方法/ 对/ 精度/ 提升/ 的/ 效果/ 较/ 好/ ./ (/ 3/ )/ DTSGCC/ 的/ 有效性/ ./ 从表/ 3/ 可以/ 观察/ 到/ ,/ DTSGCC/ 真正/ 分析/ 的/ 中间/ 文件/ 代码/ 量/ 一般/ 是/ 源代码/ 量/ 的/ 几倍/ 甚至/ 十几倍/ ,/ 其中/ binutils/ 、/ openssl/ 、/ gnome/ -/ media/ 等/ 工程/ 更是/ 达到/ 了/ 几百万/ 行/ 代码/ ./ 在/ 我们/ 的/ 实验/ 环境/ 中/ ,/ DTSGCC/ 内存/ 占用/ 最多/ 800MB/ 左右/ ,/ CPU50/ %/ 左右/ ,/ 百万/ 行/ 代码/ 量/ 平均/ 可以/ 在/ 1.54/ h/ 内/ 完成/ 检测/ ./ ASTR/ ?/ E/ 的/ 统计/ 结果表明/ ,/ 要/ 检测/ 程序/ 的/ 运行/ 时/ 错误/ (/ RunTimeError/ ,/ RTE/ )/ ,/ 万行/ 代码/ 的/ 平均/ 检测时间/ 为数/ 小时/ ①/ ./ 我们/ 的/ DTSGCC/ 与/ Saturn/ [/ 17/ ]/ 相比/ ,/ Saturn/ 检测/ Binutils/ 工程/ 内存/ 泄露/ 缺陷/ 的/ 时间/ 为/ 4h/ 左右/ [/ 18/ ]/ ,/ 而/ 我们/ 检测/ 该/ 工程/ 的/ RL/ 和/ NPD/ 故障/ 用时/ 2.87/ h/ 左右/ ②/ ./ 上述/ 测试/ 结论/ 验证/ 了/ DTSGCC/ 在/ 检测/ 代码/ 量/ 较大/ 工程/ 时/ ,/ 与/ 同类/ 静态/ 检测工具/ 相比/ 检测/ 效率/ 更高/ ./ 实验/ 1/ 的/ 分析/ 结论/ 表明/ ,/ 应用/ 本文/ 程序/ 切片/ 方法/ 后/ ,/ 控制流/ 图/ 节点/ 数/ 减少/ 40/ %/ 左右/ ,/ 从而/ 在/ 路径/ 敏感/ 的/ 缺陷/ 状态/ 迭代/ 过程/ 中/ 总/ 的/ 状态/ 迭代/ 次数/ 大幅/ 减少/ ,/ 因此/ 缺陷/ 检测时间/ 减少/ 13/ %/ 左右/ ./ 为了/ 验证/ 缺陷/ 无关/ 的/ 数据流/ 信息/ 在/ 状态/ 迭代/ 时/ 对/ 内存/ 占用/ 的/ 影响/ ,/ 我们/ 实现/ 了/ 不同/ 的/ 方法/ 与/ 实验/ 1/ 相同/ 的/ 实验/ 设置/ 进行/ 对比/ 实验/ ./ 方法/ 1/ ./ 在/ 程序/ 切片/ 的/ 同时/ 消除/ 控制流/ 节点/ 中/ 与/ 缺陷/ 无关/ 的/ 变量/ ./ 实验/ 结果/ 如表/ 4/ 所示/ ./ 方法/ 2/ ./ 只/ 进行/ 程序/ 切片/ 而/ 不/ 消除/ 无关/ 变量/ ,/ 方法/ 113.29/ 方法/ 211.73/ 方法/ 1/ 较/ 方法/ 2/ 虽然/ 检测/ 效率/ 降低/ 了/ 13/ %/ ,/ 但/ 内存/ 占用率/ 降低/ 了/ 20.75/ %/ ,/ 因此/ 方法/ 1/ 在/ 检测/ 过程/ 中/ 由于/ 内存/ 溢出/ 而/ 分析/ 失败/ 的/ 文件/ 数量/ 也/ 明显/ 减少/ ./ 方法/ 1/ 检测/ 效率/ 降低/ 的/ 原因/ 是/ 显而易见/ 的/ :/ 在/ 每次/ 状态/ 迭代/ 过程/ 中/ ,/ 方法/ 1/ 都/ 需要/ 查询/ 当前/ 控制流/ 节点/ 的/ 关联/ 变量/ 集合/ ,/ 通过/ 与/ 切片/ 准则/ 的/ 对比/ 来/ 删除/ 缺陷/ 无关/ 变量/ ;/ 然而/ 对/ 大型/ 程序/ 来说/ ,/ 控制流/ 节点/ 关联/ 的/ 变量/ 集合/ 较大/ ,/ 对/ 其中/ 某个/ 变量/ 的/ 查询/ 和/ 删除/ 操作/ 的/ 开销/ 抵消/ 了/ 程序/ 切片/ 后/ 带来/ 的/ 正面/ 影响/ ./ 实验/ 2/ 的/ 分析/ 结论/ 表明/ ,/ 在/ 代码/ 量/ 较大/ 的/ 缺陷/ 检测/ 过程/ 中/ ,/ 通过/ 本文/ 方法/ 切片/ 掉/ 缺陷/ 无关/ 变量/ ,/ 可以/ 有效/ 减少/ 内存/ 使用/ ,/ 降低/ 缺陷/ 检测/ 过程/ 中/ 某些/ 复杂/ 文件/ 分析/ 失败/ 的/ 几率/ ./ 5/ 相关/ 工作/ 对比/ 路径/ 敏感/ 分析方法/ 最早/ 应用/ 于/ 模型/ 检测/ 领域/ ,/ 它/ 可以/ 对/ 建模/ 后/ 的/ 程序/ 进行/ 全/ 路径/ 覆盖/ 测试/ ,/ 每次/ 执行/ 一条/ 路径/ 并/ 检测/ 当前/ 路径/ 上/ 的/ 错误/ [/ 19/ -/ 22/ ]/ ./ SLAM/ [/ 19/ ]/ 是/ 一个/ 路径/ 敏感/ 的/ 模型/ 检测工具/ ,/ 它/ 基于/ 迭代/ 求精/ 策略/ ,/ 其/ 初始状态/ 是/ 对/ 程序/ 语义/ 的/ 粗略/ 近似/ ,/ 在/ 迭代/ 过程/ 中/ 不断更新/ 状态/ 信息/ ,/ 通过/ 定理/ 证明/ 检测/ 不可/ 达/ 路径/ 、/ 验证/ 程序/ 的/ 时序/ 安全/ 属性/ ,/ 但/ 它/ 采用/ 的/ 谓词/ 抽象/ 理论/ 存在/ 状态/ 数/ 爆炸/ 的/ 隐患/ ./ 结合/ 谓词/ 抽象/ 和/ 符号执行/ 方法/ ,/ 文献/ [/ 20/ -/ 21/ ]/ 将/ 路径/ 上/ 的/ 每个/ 谓词/ 转化/ 为/ 一个/ 布尔/ 变量/ ,/ 将/ 路径/ 上/ 的/ 数据流/ 信息/ 抽象/ 为/ 符号执行/ 状态/ ,/ 通过/ 约束/ 求解/ 理论/ 进行/ 不可/ 达/ 路径/ 判断/ ,/ 并/ 通过/ 符号执行/ 状态/ 间/ 的/ 关系/ 检测/ 程序/ 缺陷/ ,/ 但/ 该类/ 方法/ 中/ 约束/ 求解/ 所/ 能/ 处理/ 的/ 程序/ 语义/ 复杂度/ 是/ 其/ 潜在/ 的/ 瓶颈/ ./ 模型/ 检测/ 方法/ 虽然/ 能够/ 发现/ 程序/ 深层次/ 的/ 错误/ ,/ 但/ 它/ 需要/ 对/ 软件/ 的/ 运行/ 环境/ 进行/ 建模/ ,/ 这/ 也/ 限制/ 了/ 其/ 在/ 大型/ 软件缺陷/ 检测/ 中/ 的/ 应用/ ,/ 而/ 基于/ 数据流/ 分析/ 框架/ 的/ 静态/ 分析/ 技术/ 可以/ 很/ 好地解决/ 上述/ 问题/ ./ 基于/ 数据流/ 迭代/ 的/ 路径/ 敏感/ 分析方法/ 可以/ 记录/ 程序/ 中/ 的/ 不同/ 路径/ 信息/ ,/ 减少/ 控制流/ 汇合/ 节点/ 数据流/ 合并/ 带来/ 的/ 精度/ 损失/ ./ 由于/ 全/ 路径分析/ 时/ 的/ 路径/ 爆炸/ 会/ 导致/ 分析/ 代价/ 较大/ ,/ 因此/ 实际/ 采用/ 的/ 往往/ 是/ 部分/ 路径/ 敏感/ 分析/ 策略/ (/ partialpath/ -/ sensitive/ )/ :/ (/ 1/ )/ 有/ 选择地/ 对/ 控制流/ 汇合/ 节点/ 进行/ 数据流/ 合并/ ;/ (/ 2/ )/ 通过/ 路径/ 可达性/ 分析/ 防止/ 不可/ 达/ 路径/ 上/ 的/ 数据流/ 传递/ ./ 策略/ 1/ 的/ 典型/ 应用/ 是/ ESP/ [/ 2/ ]/ ,/ 它/ 是/ 微软/ ESC/ 研究/ 小组/ 开发/ 的/ 路径/ 敏感/ 的/ 轻量级/ 静态/ 测试工具/ ,/ 通过/ 在/ 模型/ 检测/ 的/ 属性/ 状态/ 上/ 增加/ 程序执行/ 符号/ 状态/ 信息/ ,/ 跟踪/ 属性/ 状态/ 和/ 程序执行/ 符号/ 状态/ 间/ 的/ 关联/ 关系/ ,/ 并/ 将/ 其/ 用于/ 排除/ 不可/ 达/ 路径/ 来/ 提高/ 数据流/ 分析/ 的/ 精度/ ,/ 其/ 不足之处/ 在于/ 它/ 的/ 状态/ 合并/ 策略/ 是/ ①/ ②/ Page12/ 静态/ 的/ ,/ 无法/ 在/ 关键/ 路径/ 合并/ 处/ 改变/ 合并/ 策略/ ,/ 而/ 本文/ 所述/ 基于/ 切片/ 的/ 状态/ 合并/ 策略/ 可以/ 根据/ 切片/ 准则/ 和/ 数据流/ 分析/ 结果/ 动态/ 生成/ ./ Dhurjati/ 等/ 人/ [/ 4/ ]/ 对/ ESP/ 中/ 上述/ 不足/ 加以改进/ ,/ 在/ 迭代/ 求精/ 过程/ 中/ 更新/ 状态/ 合并/ 准则/ 并/ 预测/ 精度/ 损失/ 原因/ ,/ 避免/ 了/ 关键/ 路径/ 的/ 合并/ 而/ 减少/ 精度/ 损失/ ./ 文献/ [/ 3/ ]/ 采用/ 变量/ 的/ 抽象/ 取值/ 来/ 表示/ 状态/ 条件/ ,/ 在/ 控制流/ 汇合/ 节点/ 通过/ 合并/ 相同/ 状态/ 中/ 的/ 状态/ 条件/ 来/ 避免/ 路径/ 爆炸/ ./ 本文/ 与/ 文献/ [/ 3/ -/ 4/ ]/ 相比/ ,/ 都/ 是/ 有/ 选择地/ 对/ 控制流/ 汇合/ 节点/ 进行/ 状态/ 合并/ ,/ 但/ 文献/ [/ 3/ ]/ 方法/ 仅/ 根据/ 缺陷/ 状态/ 是否/ 相同/ 来/ 进行/ 状态/ 合并/ ,/ 有/ 可能/ 导致/ 与/ 缺陷/ 相关/ 的/ 路径/ 信息/ 丢失/ ,/ 而/ 本文/ 通过/ 切片/ 准则/ 识别/ 出/ 在/ 哪些/ 节点/ 可以/ 安全/ 地/ 进行/ 状态/ 合并/ ;/ 文献/ [/ 4/ ]/ 采用/ 的/ 迭代/ 求精/ 策略/ 利用/ 首次/ 缺陷/ 检测/ 的/ 结果/ ,/ 更新/ 状态/ 合并/ 策略/ 然后/ 进行/ 二次/ 迭代/ 计算/ ,/ 实际上/ 会/ 进行/ 两次/ 或/ 多次/ 分析/ ,/ 会/ 导致/ 更大/ 的/ 计算/ 量/ ,/ 且/ 迭代/ 有/ 可能/ 面临/ 不/ 终止/ 的/ 情况/ ,/ 而/ 本文/ 的/ 程序/ 切片/ 操作/ 某种意义/ 上/ 也/ 可以/ 视为/ 一种/ 迭代/ 求精/ 技术/ ,/ 但/ 实施/ 代价/ 较/ 低且/ 可以/ 很快/ 终止/ ./ 策略/ 2/ 路径/ 可达性/ 分析/ 可以/ 发现/ 程序/ 语义/ 中/ 不可/ 达/ 的/ 程序/ 状态/ ,/ 在/ 缺陷/ 检测工具/ 、/ 程序验证/ 工具/ 及/ 测试用例/ 生成/ 工具/ 中/ 都/ 有/ 广泛/ 使用/ ./ Saturn/ [/ 17/ ,/ 23/ ]/ 将/ 路径/ 上/ 的/ 每个/ 谓词/ 转化/ 为/ 一个/ 布尔/ 变量/ ,/ 利用/ SAT/ 求解/ 器/ 进行/ 不可/ 达/ 路径/ 判断/ ,/ 能/ 针对/ C/ 程序/ 进行/ 路径/ 敏感/ 的/ 缺陷/ 检测/ ,/ 但/ 它/ 采用/ 启发式/ 方法/ 以/ 跟踪/ 程序/ 中/ 的/ 关键/ 谓词/ ,/ 可能/ 忽略/ 程序/ 中/ 某些/ 平凡/ 属性/ ,/ 因此/ 其/ 测试/ 结果/ 不是/ 可靠/ 的/ ./ Bodik/ [/ 24/ ]/ 提出/ 一种/ 低/ 代价/ 的/ 基于/ 检测/ 静态/ 边/ 关联/ 的/ 查找/ 不可/ 达/ 路径/ 方法/ ,/ 用于/ 提高/ 定义/ 使用/ 分析/ (/ define/ -/ useanalysis/ )/ 的/ 精度/ ./ Fischer/ [/ 25/ ]/ 通过/ 在/ 数据流/ 分析/ 半格/ 中/ 元素/ 上/ 增加/ 谓词/ 信息/ 来/ 提高/ 数据流/ 分析/ 精度/ ,/ 实际上/ 这些/ 谓词/ 将/ 程序/ 路径/ 集合/ 进行/ 了/ 划分/ ,/ 从/ 另/ 一个/ 角度/ 也/ 可以/ 认为/ 是/ 记录/ 了/ 不同/ 的/ 路径/ 信息/ ,/ 该/ 信息/ 可/ 用于/ 不可/ 达/ 路径/ 判断/ ./ 文献/ [/ 26/ ]/ 将/ 控制流/ 图中/ 分支/ 节点/ 的/ 条件/ 特征/ 分为/ 4/ 类/ :/ 相同/ // 相反/ 的/ 条件/ 、/ 互斥/ 的/ 条件/ 、/ 检测/ -/ 执行/ 逻辑/ 、/ 循环/ 标记/ ,/ 通过/ 识别/ 程序/ 中/ 这/ 四类/ 可以/ 生成/ 不可/ 达/ 路径/ 的/ 模式/ 来/ 检测/ 不可/ 达/ 路径/ ./ Ammons/ 等/ 人/ [/ 27/ ]/ 使用/ 路径/ 形态/ 特征/ 识别/ 出/ 程序/ 中/ 的/ “/ 热门/ 路径/ ”/ (/ hotpaths/ )/ ,/ 在/ CFG/ 中/ 增加/ 节点/ 避免/ 此类/ 热门/ 路径/ 上/ 的/ 数据流/ 合并/ ,/ 从而/ 通过/ 传统/ 的/ 数据流/ 分析/ 得到/ 了/ 路径/ 敏感/ 的/ 分析/ 结果/ ,/ 这是/ 一种/ 典型/ 的/ 以/ 效率/ 换/ 精度/ 的/ 方法/ ./ SLR/ [/ 5/ ]/ 通过/ 路径/ 可达性/ 分析/ 得到/ 不可/ 达/ 路径/ 上/ 相关/ 节点/ ,/ 然后/ 重构/ 控制流/ 图使/ 该类/ 节点/ 不再/ 位于/ 同一/ 路径/ ,/ 从而/ 在/ 程序/ 语义/ 不变/ 的/ 前提/ 下去/ 除了/ 不可/ 达/ 路径/ ./ 本文/ 方法/ 与/ 文献/ [/ 5/ ]/ 相比/ ,/ 虽然/ 没有/ 消除/ 不可/ 达/ 路径/ ,/ 但/ 通过/ 程序/ 切片/ 技术/ 实现/ 了/ 基于/ 切片/ 的/ 状态/ 合并/ 策略/ ,/ 从而/ 达到/ 了/ 同样/ 目的/ ./ 6/ 小结/ 本文/ 从/ 提高/ 路径/ 敏感/ 缺陷/ 检测/ 方法/ 的/ 效率/ 和/ 精度/ 出发/ ,/ 借鉴/ 需求/ 驱动/ 的/ 程序/ 分析/ 思想/ ,/ 将/ 程序/ 切片/ 技术/ 应用/ 于/ 静态/ 缺陷/ 检测/ ,/ 提出/ 一种/ 基于/ 缺陷/ 的/ 程序/ 切片/ 方法/ ,/ 切片/ 程序/ 在/ 缺陷/ 检测/ 时/ 与/ 源程序/ 完全/ 等价/ ,/ 减少/ 了/ 状态/ 迭代/ 时/ 的/ 计算/ 量/ ./ 为了/ 进一步/ 减少/ 误报/ ,/ 根据/ 控制流/ 分支/ 节点/ 的/ 路径/ 条件/ 生成/ 缺陷/ 的/ 状态/ 属性/ ,/ 有/ 选择地/ 对/ 控制流/ 汇合/ 节点/ 进行/ 状态/ 合并/ ,/ 减少/ 了/ 路径/ 合并/ 导致/ 的/ 与/ 缺陷/ 检测/ 相关/ 的/ 精度/ 损失/ ./ 实验/ 结果表明/ ,/ 本文/ 方法/ 在/ 检测/ 代码/ 量/ 较大/ 程序/ 时/ ,/ 可以/ 提高/ 13/ %/ 左右/ 的/ 分析/ 效率/ ,/ 并/ 减少/ 6/ %/ 左右/ 的/ 误报/ ./ 由于/ GCC/ 语法/ 的/ 复杂性/ ,/ 可能/ 导致/ 切片/ 准则/ 计算/ 不/ 准确/ ,/ 得到/ 的/ 切片/ 程序/ 可能/ 仍然/ 包含/ 冗余/ 语句/ ,/ 虽然/ 对/ 分析/ 效率/ 产生/ 影响/ ,/ 但/ 并/ 不/ 妨碍/ 本/ 方法/ 应用/ 于/ 实际/ 的/ 缺陷/ 检测/ ./ 将来/ 的/ 工作/ 主要/ 有/ 两个/ 方面/ :/ 一方面/ 是/ 研制/ 较为/ 精确/ 的/ 程序/ 切片/ 算法/ ,/ 进一步/ 减少/ 切片/ 不/ 准确/ 对/ 缺陷/ 检测/ 效率/ 的/ 影响/ ;/ 另一方面/ 考虑/ 如何/ 实现/ 域/ 敏感/ 分析方法/ ,/ 减少/ 由于/ 结构/ 体/ 、/ 数组/ 成员/ 引用/ 造成/ 的/ 误报/ ./ 如何/ 提高/ 指针/ 别名/ 分析/ 的/ 精度/ ,/ 以/ 减少/ 指针/ 操作/ 对/ 切片/ 精度/ 、/ 分析/ 精度/ 的/ 影响/ ,/ 也/ 是/ 今后/ 的/ 一个/ 研究/ 重点/ ./ 

