Page1BIOP/ :/ 自动/ 构造/ 增强型/ ROP/ 攻击/ 邢骁/ 陈平/ 丁文彪/ 茅兵/ 谢立/ (/ 南京大学/ 软件/ 新/ 技术/ 国家/ 重点/ 实验室/ 南京/ 210093/ )/ (/ 南京大学/ 计算机科学/ 与/ 技术/ 系/ 南京/ 210093/ )/ 摘要/ 针对/ 传统/ 的/ 代码/ 注入/ 和/ 代码/ 复用/ 等/ 攻击/ 技术/ 的/ 缺陷/ ,/ 返回/ 导向/ 编程/ (/ Return/ -/ OrientedProgramming/ ,/ ROP/ )/ 提出/ 了/ 复用/ 以/ ret/ 指令/ 结尾/ 的/ 短/ 指令/ 序列/ ,/ 实现/ 图灵/ 完备/ 编程/ 的/ 思想/ ./ ROP/ 攻击/ 可以/ 绕开/ 现有/ 的/ 针对/ 代码/ 注入/ 的/ 防御/ ,/ 且/ 相比/ 于/ 传统/ 代码/ 复用技术/ ,/ 构造/ 功能/ 更为/ 强大/ ./ 但/ ROP/ 攻击/ 使用/ 的/ ret/ 指令/ 结尾/ 的/ 指令/ 序列/ 具有/ 明显/ 的/ 特征/ ,/ 这些/ 特征/ 导致/ ROP/ 攻击/ 容易/ 被/ 检测/ 到/ ./ 现有/ 的/ ROP/ 改进/ 技术/ 使用/ jmp/ 指令/ 结尾/ 的/ 短/ 指令/ 序列/ 构造/ 攻击/ ,/ 虽然/ 消除/ 了/ 以/ ret/ 指令/ 结尾/ 的/ 特征/ ,/ 但/ 同时/ 引入/ 了/ 新/ 的/ 特征/ ,/ 且/ 并/ 不/ 具有/ 实用性/ ./ 文中/ 提出/ 了/ 一种/ 分支/ 指令/ 导向/ (/ BranchInstruction/ -/ OrientedProgramming/ ,/ BIOP/ )/ 攻击/ 技术/ ,/ 使用/ jmp/ 指令/ 或/ call/ 指令/ 结尾/ 的/ 短/ 指令/ 序列/ 构造/ 攻击/ ./ 相比/ 于/ 以前/ 的/ 工作/ ,/ BIOP/ 不/ 引入/ 新/ 的/ 特征/ ,/ 能/ 有效/ 避免/ 现有/ 的/ 防御/ 技术/ ./ 同时/ 我们/ 分析/ 并/ 解决/ 了/ 构造/ 攻击/ 时/ 寄存器/ 的/ 副作用/ ,/ 提出/ 控制指令/ 序列/ 概念/ 解决/ 构造/ 时/ 内存/ 冲突/ ,/ 实现/ 自动化/ 构造/ BIOP/ 攻击/ ./ 作者/ 设计/ 了/ 一个/ 自动化/ 构造/ BIOP/ 工具/ ,/ 构造/ 了/ 大量/ 实际/ 的/ BIOPshellcode/ ,/ 实验/ 结果表明/ BIOP/ 攻击/ 可以/ 绕过/ 现有/ 的/ ROP/ 防御/ 技术/ ./ 关键词/ 返回/ 导向/ 编程/ ;/ 指令/ 序列/ ;/ 寄存器/ 副作用/ ;/ 自动化/ ;/ 信息安全/ ;/ 网络安全/ 1/ 引言/ 传统/ 的/ 攻击/ 方法/ 通常/ 使用/ 代码/ 注入/ 和/ 代码/ 复用技术/ ./ 现在/ 流行/ 操作系统/ 中/ 普遍/ 部署/ 的/ 数据/ 执行/ 保护/ 技术/ (/ 如/ Linux/ 系统/ 中/ PAX/ 补丁/ ①/ 和/ Windows/ 系统/ 中/ 的/ DEP/ ②/ )/ ,/ 可以/ 对/ 代码/ 注入/ 技术/ 实施/ 有效/ 的/ 防御/ ./ 传统/ 代码/ 复用技术/ 如/ return/ -/ to/ -/ libc/ 攻击/ 技术/ [/ 1/ ]/ ,/ 依赖于/ 库中/ 的/ 函数/ 功能/ ,/ 攻击能力/ 受到/ 严重/ 限制/ ./ 且/ 现有/ 的/ 防御/ 方法/ 如/ Libsafe/ ③/ ,/ 通过/ 替换/ 特定/ 的/ 库函数/ 有效/ 的/ 防御/ 该/ 攻击/ ./ 返回/ 导向/ 编程/ (/ Return/ -/ OrientedProgramming/ ,/ ROP/ )/ 技术/ 是/ 由/ Shacham/ [/ 2/ ]/ 在/ 2007/ 年/ 提出/ 的/ 代码/ 复用技术/ ,/ 它/ 复用/ 现有/ 的/ 库/ 和/ 可/ 执行/ 代码/ 中以/ ret/ 结尾/ 的/ 指令/ 序列/ (/ gadget/ )/ ,/ 通过/ 将/ 地址/ 和/ 数据/ 压入/ 栈/ ,/ 使/ 程序/ 从/ 一个/ 指令/ 序列/ 跳到/ 另/ 一个/ 指令/ 序列/ ,/ 实现/ 任意/ 的/ 恶意/ 行为/ ./ 与/ 传统/ 的/ 攻击/ 方法/ 相比/ ,/ ROP/ 无需/ 引入/ 恶意代码/ ,/ 可以/ 有效/ 绕开/ 数据/ 执行/ 保护/ 技术/ ,/ 同时/ ROP/ 更/ 细粒度/ 复用/ 短/ 指令/ 序列/ ,/ 增加/ 了/ 攻击/ 构造/ 能力/ 和/ 检测/ 难度/ ,/ 被/ 认为/ 是/ 一种/ 更/ 强大/ 的/ 攻击/ 技术/ ④/ ./ 但/ 由于/ ROP/ 使用/ 以/ ret/ 结尾/ 的/ 指令/ 序列/ 构造/ 攻击/ ,/ 这种/ 明显/ 的/ 特征/ 使/ ROP/ 攻击/ 容易/ 被/ 检测/ 到/ ,/ 常用/ 的/ 检测/ 方法/ 有/ :/ (/ 1/ )/ 正常/ 的/ 程序/ 中/ ,/ call/ 指令/ 和/ ret/ 指令/ 存在/ 一一对应/ 关系/ ,/ 而/ ROP/ 使用/ 单独/ 的/ 以/ ret/ 结尾/ 指令/ 序列/ ,/ call/ 指令/ 和/ ret/ 指令/ 不/ 匹配/ ./ 利用/ 这种/ 特性/ ,/ 文献/ [/ 3/ -/ 4/ ]/ 分别/ 从/ 硬件/ 和/ 软件/ 角度/ 对/ ROP/ 攻击/ 进行/ 检测/ ;/ (/ 2/ )/ ROP/ 攻击/ 常常/ 频繁/ 复用/ 多个/ ret/ 结尾/ 的/ 短/ 指令/ 序列/ ,/ 文献/ [/ 5/ -/ 6/ ]/ 利用/ 这个/ 特性/ ,/ 检测/ 是否/ 存在/ 多个/ 连续/ 的/ ret/ 指令/ 序列/ ,/ 以/ 检测/ ROP/ 攻击/ ;/ (/ 3/ )/ 消除/ 系统/ 中/ 库函数/ 或/ 可/ 执行/ 代码/ 中/ 的/ ret/ 指令/ ,/ 使/ ROP/ 攻击/ 无法/ 找到/ 可用/ ret/ 指令/ 序列/ ./ 文献/ [/ 7/ ]/ 提供/ 一种/ 消除/ ret/ 指令/ 的/ 编译器/ ,/ 该/ 编译器/ 编译/ 的/ 内核/ 可以/ 有效/ 防止/ ROProotkit/ ./ 为了/ 弥补/ ROP/ 的/ 这些/ 缺陷/ ,/ 攻击者/ 们/ 对/ ROP/ 技术/ 进行/ 一定/ 程度/ 的/ 改进/ ,/ 如/ 文献/ [/ 8/ ]/ 中/ 使用/ 含/ pop/ -/ jmp/ 这种/ 类似/ ret/ 功能/ 的/ 指令/ 序列/ 代替/ 原有/ 的/ 以/ ret/ 结尾/ 的/ 指令/ 序列/ ,/ 文献/ [/ 9/ ]/ 中/ 试图/ 寻找/ 以/ jmp/ 结尾/ 的/ 指令/ 序列/ 构造/ 攻击/ ,/ 这/ 类/ 技术/ 被称作/ 跳转/ 导向/ 编程/ (/ Jump/ -/ OrientedProgramming/ ,/ JOP/ )/ 技术/ ./ 这/ 两种/ 方法/ 虽然/ 都/ 可以/ 绕过/ 现有/ ROP/ 防御/ ,/ 但/ 仍然/ 存在/ 缺陷/ :/ (/ 1/ )/ 这/ 两种/ 构造方法/ 仍/ 具有/ 明显/ 特征/ ,/ 通过/ 对/ ROP/ 检测/ 技术/ 简单/ 的/ 修改/ 即/ 可以/ 检测/ 到/ 这类/ 攻击/ ./ 如/ 文献/ [/ 8/ ]/ 中/ 使用/ pop/ -/ jmp/ 固定/ 指令/ ,/ 可以/ 通过/ 检测/ 这种/ pop/ -/ jmp/ 的/ 频率/ 或/ 语义/ 分析/ 即/ 可以/ 检测/ 此类/ 攻击/ ,/ 文献/ [/ 9/ ]/ 中/ 使用/ 调度/ 指令/ 序列/ (/ 调度/ 指令/ 序列/ )/ 分发/ 控制流/ ,/ 每次/ 实现/ 功能/ 的/ 指令/ 序列/ 执行/ 完毕/ 以后/ ,/ 都/ 会/ 跳/ 回/ 调度/ 指令/ 序列/ ,/ 继而/ 转到/ 下/ 一个/ 指令/ 序列/ 执行/ ./ 这种/ 控制流/ 特征/ 在/ 正常/ 程序/ 中/ 并/ 不会/ 出现/ ,/ 根据/ 这种/ 特征/ ,/ 动态/ 检测/ 很/ 容易/ 发现/ 此类/ 攻击/ ;/ (/ 2/ )/ 由于/ 使用/ 固定/ 类型/ 的/ 指令/ (/ pop/ -/ jmp/ 、/ 调度/ 指令/ 序列/ )/ ,/ 这/ 两种/ 方法/ 构造/ 攻击/ 的/ 能力/ 有限/ ./ 它们/ 都/ 没有/ 考虑/ 构造/ 时/ 寄存器/ 的/ 副作用/ ,/ 只能/ 手工/ 构造/ 特定/ 的/ 攻击/ ./ 寄存器/ 副作用/ 指/ 不同/ 指令/ 序列/ 在/ 使用/ 同一个/ 寄存器/ 时会/ 存在/ 冲突/ ,/ 如/ 文献/ [/ 8/ ]/ 中/ 使用/ gadget1/ (/ popeax/ ;/ …/ )/ ,/ gadget2/ (/ …/ ;/ jmpeax/ )/ 进行/ 构造/ 时/ ,/ gadget1/ 会/ 给/ eax/ 寄存器/ 赋值/ ,/ 而/ 这个/ 值会/ 在/ gadget2/ 中/ 使用/ ./ 如果/ 这/ 两个/ gadget/ 中间/ 存在/ 一个/ 指令/ 序列/ 对/ eax/ 的/ 值/ 进行/ 改动/ ,/ 将会/ 影响/ gadget1/ 和/ gadget2/ 之间/ 的/ 协作/ ,/ 攻击者/ 需要/ 寻找/ 其他/ gadget/ 来/ 代替/ 其中/ 的/ 某/ 几个/ 指令/ 序列/ ;/ 同样/ ,/ 文献/ [/ 9/ ]/ 中/ 使用/ addebp/ ,/ edi/ ;/ jmp/ [/ ebp/ -/ 0x39/ ]/ 作为/ 调度/ 指令/ 序列/ ,/ 实现/ 功能/ 的/ 指令/ 序列/ 中则/ 无法/ 对/ ebp/ 和/ edi/ 进行/ 改动/ ./ 寄存器/ 副作用/ 限制/ 了/ 这/ 两类/ 攻击/ 的/ 构造/ 能力/ ,/ 使/ 这/ 两类/ 方法/ 都/ 无法/ 大规模/ 自动化/ 的/ 构造/ 攻击/ ./ 我们/ 会/ 在/ 第/ 3/ 节/ 详细/ 的/ 分析/ 寄存器/ 副作用/ 问题/ 及其/ 解决/ 方法/ ./ 为了/ 解决/ ROP/ 及/ JOP/ 技术/ 的/ 缺陷/ ,/ 构造/ 隐蔽性/ 更强/ 、/ 能力/ 更为/ 强大/ 的/ 攻击/ ,/ 我们/ 试图/ 解决/ 以下/ 问题/ :/ (/ 1/ )/ 消除/ 攻击/ 代码/ 的/ 特征/ ./ 我们/ 期望/ 用于/ 构造/ 攻击/ 的/ 指令/ 序列/ 不/ 受限于/ 特定/ 的/ 指令/ 形式/ ,/ 如/ ROP/ 使用/ 以/ ret/ 结尾/ 的/ 指令/ 序列/ ,/ JOP/ 中/ pop/ -/ jmp/ 、/ 调度/ 指令/ 序列/ 等/ ,/ 且/ 程序控制/ 流/ 和/ 正常/ 程序/ 类似/ ./ 使/ 检测/ 此类/ 攻击/ 变/ 的/ 更为/ 困难/ ./ (/ 2/ )/ 从/ 可执行程序/ 或库/ 中/ 抽取/ 出/ 可用/ 指令/ 序列/ ,/ 利用/ 这些/ 指令/ 序列/ 自动/ 的/ 构造/ 多种/ 功能/ 的/ 攻击/ ./ 现有/ 的/ JOP/ 技术/ 都/ 无法/ 自动化/ 构造/ ,/ 从而/ 造成/ 这/ 类/ ①/ ②/ ③/ ④/ Page3/ 攻击/ 并/ 不/ 实用/ ./ 为此/ ,/ 我们/ 提出/ 了/ 一种/ 自动化/ 构造/ 分支/ 指令/ 导向/ 编程/ (/ BranchInstruction/ -/ OrientedProgramming/ ,/ BIOP/ )/ 技术/ ,/ 它/ 使用/ 间接/ 转移/ 指令/ (/ 间接/ 跳转/ 指令/ indirectjump/ 、/ 间接/ 调用/ 指令/ indirectcall/ )/ 结尾/ 的/ 指令/ 序列/ 代替/ ROP/ 中以/ ret/ 结尾/ 的/ 指令/ 序列/ ./ 相比/ 于/ ROP/ 以及/ 现有/ 的/ ROP/ 改进/ 技术/ ,/ 这种/ 新型/ 代码/ 复用技术/ 不/ 引入/ 新/ 的/ 特征/ ,/ 攻击/ 控制流/ 与/ 正常/ 程序控制/ 流/ 类似/ ,/ 使/ 检测/ 更加/ 困难/ ./ 同时/ 我们/ 分析/ 了/ 构造/ BIOP/ 时/ 遇到/ 的/ 问题/ ,/ 如/ 寄存器/ 副作用/ ,/ 内存/ 冲突/ 等/ ./ 我们/ 提供/ 了/ 一种/ 自动化/ 构造/ BIOP/ 的/ 方法/ ,/ 指定/ 构造/ 规则/ 以/ 消除/ 寄存器/ 副作用/ ,/ 并/ 引入/ 控制指令/ 序列/ 以/ 解决/ 构造/ 时/ 内存/ 冲突/ 问题/ ,/ 使/ BIOP/ 攻击/ 具有/ 实用性/ ./ 本文/ 的/ 贡献/ 如下/ :/ (/ 1/ )/ 提出/ 了/ 一种/ 新型/ 的/ BIOP/ 代码/ 复用/ 攻击/ ,/ 它/ 打破/ 了/ ROP/ 攻击/ 需要/ 以/ ret/ 结尾/ 的/ 局限/ ,/ 不/ 引入/ 新/ 的/ 特征/ ,/ 使/ 现有/ ROP/ 防御/ 技术/ 失效/ ./ (/ 2/ )/ 分析/ 了/ BIOP/ 攻击/ 的/ 可行性/ 和/ 完备/ 性/ ,/ 并/ 抽取/ libc/ -/ 2.3/ ./ 5/ ./ so/ 库/ 和/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ 库中/ 的/ 可用/ 指令/ 序列/ ./ 我们/ 发现/ 寄存器/ 副作用/ 是/ 限制/ 构造/ 攻击/ 的/ 重要/ 因素/ ,/ 提出/ 自动/ 构造/ shellcode/ 的/ 一般/ 方法/ 和/ 规则/ ,/ 以/ 有效/ 的/ 避免/ 寄存器/ 副作用/ ./ 同时/ 我们/ 提出/ 控制指令/ 序列/ ,/ 使用/ 控制指令/ 序列/ 可以/ 解决/ 内存/ 冲突/ 、/ 简化/ 构造方法/ 、/ 优化/ 构造/ 代码/ ./ (/ 3/ )/ 设计/ 实现/ 构造/ 攻击/ 的/ 自动化/ 工具/ ,/ 并/ 使用/ 该/ 工具/ 构造/ 大量/ 的/ BIOPshellcode/ ./ 实验/ 证明/ 我们/ 的/ 工具/ 具有/ 很强/ 的/ 实用性/ ./ 本文/ 第/ 2/ 节/ 详细/ 介绍/ BIOP/ 攻击/ 并/ 分析攻击/ 的/ 可行性/ ,/ 同时/ 给出/ BIOP/ 指令/ 序列/ 搜索算法/ ;/ 第/ 3/ 节/ 介绍/ 构造/ BIOP/ 攻击/ 的/ 条件/ 和/ 自动化/ 构造/ BIOPshellcode/ 工具/ 的/ 原理/ ;/ 第/ 4/ 节/ 给出/ 使用/ 工具/ 构造/ shellcode/ 的/ 结果/ 和/ 构造/ 的/ shellcode/ 避开/ 检测/ 的/ 能力/ ;/ 第/ 5/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 6/ 节/ 总结/ 全文/ ./ 2BIOP/ 概述/ 2.1/ BIOP/ 基本/ 组成/ 单元/ 在/ 这里/ ,/ 我们/ 将/ jmp/ 指令/ 和/ call/ 指令/ 统称/ 为/ 转移/ 指令/ ,/ BIOP/ 的/ 基本/ 组成/ 单元/ 由以/ 转移/ 指令/ 结尾/ 的/ 指令/ 序列/ 构成/ ./ 由于/ 我们/ 通过/ 转移/ 指令/ 来/ 控制程序/ 的/ 执行/ ,/ 而/ 直接/ 寻址/ 指令/ 跳转/ 的/ 偏移/ 是/ 固定/ 的/ ,/ 所以/ 这里/ 我们/ 只/ 考虑/ 两种/ 情况/ :/ 分别/ 以/ indirectcall/ 指令/ 和/ indirectjmp/ 指令/ 作为/ BIOP/ 指令/ 序列/ 的/ 结尾/ ./ 如图/ 1/ 所示/ ,/ 图/ 1/ (/ a/ )/ 描述/ 了/ 传统/ ROP/ 攻击/ ,/ 它/ 执行/ 一系列/ 以/ ret/ 结尾/ 的/ 短/ 指令/ 序列/ ,/ 这些/ 指令/ 序列/ 中/ ret/ 指令/ 并/ 没有/ 调用/ 指令/ 与其/ 相匹配/ ./ 现有/ 的/ ROP/ 防御/ 技术/ 通过/ 检测/ 这/ 类/ 特征/ 可以/ 有效/ 的/ 阻止/ ROP/ 攻击/ ./ 如果/ 将/ 构造/ ROP/ 攻击/ 的/ 以/ ret/ 结尾/ 的/ 指令/ 序列/ 更换/ 为/ 以/ jmp/ 或/ call/ 结尾/ 的/ 指令/ 序列/ ,/ 则/ 可以/ 有效/ 绕过/ 现有/ 的/ ROP/ 防御/ 技术/ ./ 注意/ ,/ 简单/ 的/ 使用/ jmp/ 或/ call/ 来/ 代替/ ret/ 可能/ 会/ 产生/ 问题/ ,/ 如/ 使用/ pop/ -/ jmp/ 来/ 代替/ ret/ ,/ 虽然/ 可以/ 消除/ ret/ 的/ 特征/ ,/ 但是/ pop/ -/ jmp/ 的/ 特征/ 同样/ 明显/ ,/ 防御者/ 只/ 需要/ 对/ ROP/ 防御/ 技术/ 进行/ 简单/ 的/ 修改/ 就/ 可以/ 有效/ 防御/ 此类/ 攻击/ ./ 为此/ ,/ 我们/ 提出/ BIOP/ 攻击/ ,/ 它/ 的/ 基本/ 组成/ 单元/ 是/ 以/ jmp/ 指令/ 和/ call/ 指令/ 结尾/ 的/ 指令/ 序列/ ,/ 如图/ 1/ (/ b/ )/ 所示/ ./ BIOP/ 通过/ jmp/ 指令/ 和/ call/ 指令/ 来/ 传递/ 控制流/ ,/ 消除/ ROP/ 中/ 使用/ 孤立/ ret/ 指令/ 的/ 缺陷/ ./ 同时/ ,/ BIOP/ 中/ 包含/ 一类/ 联合/ 指令/ 序列/ ,/ 这/ 类/ 指令/ 序列/ 是/ 由/ 一个/ 含/ call/ 指令/ 的/ 指令/ 序列/ 和/ 一个/ 含/ ret/ 指令/ 的/ 指令/ 序列/ 构成/ ,/ call/ 指令/ 用来/ 调用/ ROPgadget/ ,/ 然后/ 由/ ROP/ 指令/ 序列/ 中/ 的/ ret/ 指令/ 返回/ ./ 这样/ ,/ 在/ BIOP/ 中/ ,/ 每/ 一个/ ret/ 指令/ 都/ 有/ 一个/ call/ 指令/ 与/ 之/ 对应/ ./ 由图/ 1/ 可以/ 看出/ ,/ 传统/ 的/ ROP/ 攻击/ 中/ ret/ 指令/ 作用/ 是/ 将/ 控制/ 流传/ 递给/ 下/ 一个/ 指令/ 序列/ ,/ 所以/ ROP/ 中由栈/ 来/ 控制程序/ 的/ 执行/ 流程/ ./ 在/ BIOP/ 中/ ,/ 控制流/ 的/ 传递/ 由/ 间接/ 转移/ 指令/ 完成/ ,/ 控制流/ 的/ 传递/ 依赖于/ 间接/ 转移/ 指令/ 中/ 的/ 寄存器/ 的/ 值/ ./ 所以/ BIOP/ 的/ 构造/ 不/ 依赖于/ 栈/ 的/ 控制/ 而/ 依赖于/ 寄存器/ ,/ 每次/ 控制流/ 从/ 一个/ 指令/ 序列/ 传递/ 到/ 另/ 一个/ 指令/ 序列/ 时/ 必须/ 先/ 将/ jmp/ 指令/ 后/ 的/ 寄存器/ 赋值/ ,/ 这/ 导致/ 指令/ 序列/ 之间/ 具有/ 一定/ 的/ 约束/ 关系/ ./ 同时/ 我们/ 发现/ 新型/ 的/ BIOP/ 攻击/ 与/ 库/ 中/ 现有/ 的/ 程序控制/ 流/ 类似/ ,/ 不会/ 产生/ 明显/ 的/ 特征/ ./ 2.2/ 构造/ BIOP/ 可行性/ 本/ 节/ 我们/ 研究/ 普通/ 的/ 库/ 和/ 可/ 执行/ 代码/ 中/ 构造/ BIOP/ 的/ 可行性/ ./ x86/ 结构/ 中/ ,/ indirectcall/ 指令/ 和/ Page4indirectjmp/ 指令/ 的/ 第/ 1/ 个/ 比特/ 都/ 是/ 0xff/ ,/ 对于/ indirectcall/ 指令/ ,/ 第/ 2/ 个/ 比特/ 是/ 在/ 0x10/ 到/ 0x1f/ ,/ 0x50/ 到/ 0x5f/ ,/ 0x90/ 到/ 0x9f/ 和/ 0xd0/ 到/ 0xd7/ 的/ 区间/ 内/ ,/ 而/ indirectjmp/ 指令/ 的/ 第/ 2/ 个/ 比特/ 是/ 在/ 0x20/ 到/ 0x2f/ ,/ 0x60/ 到/ 0x6f/ ,/ 0xa0/ 到/ 0xaf/ 和/ 0xe0/ 到/ 0xe7/ 的/ 区间/ 内/ ./ 我们/ 对/ 两个/ 常用/ 的/ 库/ libc/ -/ 2.3/ ./ 5/ ./ so/ (/ C/ 库/ )/ 和/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ (/ java/ 运行/ 动态链接库/ )/ 进行/ 分析/ ,/ 统计/ ret/ 指令/ 、/ indirectcall/ 指令/ 和/ indirectjmp/ 指令/ 的/ 个数/ ./ 统计/ 结果/ 如图/ 2/ 和表/ 1/ 所示/ ./ 图/ 2/ 给出/ libc/ -/ 2.3/ ./ 5/ ./ so/ 和/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ 中/ 0xff/ 之后/ 字节/ 分布/ ,/ 表/ 1/ 给出/ 了/ 库/ 中/ 指令/ 数目/ 的/ 统计/ ./ 由表/ 1/ 可/ 看出/ ,/ 在/ 大小/ 为/ 1489572/ 字节/ 的/ libc/ -/ 2.3/ ./ 5/ ./ so/ 库/ 和/ 大小/ 为/ 41090990/ 字节/ 的/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ 库中/ ,/ indirectjmp/ 指令/ 分别/ 有/ 3723/ 个/ 和/ 20462/ 个/ ,/ indirectcall/ 指令/ 分别/ 有/ 3243/ 个/ 和/ 31940/ 个/ ,/ 数目/ 少于/ ret/ 指令/ ,/ 但/ 仍/ 可以/ 提供/ 足够/ 的/ gadget/ ./ 0xc3/ (/ ret/ 指令/ )/ 57900.39582990/ ./ 140xffcall32430/ ./ 22319400.08/ 库/ 大小/ 1489572100410909901002.3/ BIOP/ 指令/ 序列/ 快速/ 搜索算法/ 为了/ 快速/ 有效/ 找到/ 可用/ 指令/ 序列/ ,/ 我们/ 提出/ BIOP/ 指令/ 序列/ 快速/ 搜索算法/ ,/ 如/ 算法/ 1/ 所示/ ./ 对于/ 输入/ 的/ 一段/ 二进制/ 代码/ ,/ 算法/ 构建/ 一个/ 指令/ 序列/ 树/ 集合/ ,/ 集合/ 中/ 每个/ 树根/ 节点/ 为/ 指令/ 序列/ 尾部/ 的/ jmp/ 或/ call/ 指令/ ,/ 代码/ 中/ 每条/ 指令/ 是/ 它/ 上/ 一条/ 指令/ 的/ 父/ 节点/ ,/ 当/ 某条/ 指令/ 前面/ 二进制/ 代码/ 序列/ 可以/ 被/ 解释/ 成/ 多条/ 不同/ 指令/ 时/ ,/ 这/ 条/ 指令/ 将会/ 有/ 多个/ 不同/ 的/ 孩子/ 节点/ ,/ 每个/ 节点/ 存放/ 这些/ 不同/ 的/ 指令/ ./ 算法/ 1/ ./ BIOP/ 指令/ 序列/ 搜索/ ./ 该/ 算法/ 描述/ 如下/ :/ 首先/ 创建/ 一个/ 集合/ G/ ,/ 用于/ 放置/ 指令/ 序列/ 树/ ,/ 树/ 的/ 根/ 节点/ 为/ 非/ 条件/ 转移/ 指令/ 序列/ ./ 然后/ ,/ pos/ 指针/ 指向/ 二进制/ 代码/ 的/ 第一个/ byte/ ,/ 并/ 由此/ 位置/ 依次/ 向/ 后/ 搜索/ ,/ 当/ pos/ 指针/ 指向/ 的/ byte/ 序列/ 可以/ 被/ 解释/ 成/ 一条/ 非/ 条件/ 转移/ 指令/ 时/ ,/ 将/ 这个/ 指令/ 序列/ 放入/ 集合/ G/ 中/ ,/ 调用/ BuildTree/ (/ )/ 函数/ 构建/ 非/ 条件/ 转移/ 指令/ 树/ ./ 构建/ 的/ 方法/ 是从/ pos/ 指针/ 指向/ 的/ 位置/ 开始/ ,/ 依次/ 向前/ 搜索/ 1/ 到/ max/ _/ insn/ _/ len/ 个/ 比特/ ,/ 这里/ max/ _/ insn/ _/ len/ 是/ 指/ 所在/ 机器/ 结构/ (/ 如/ x86/ 系统/ )/ 中/ 最大/ 指令/ 的/ 比特/ 数/ ./ 如果/ 从/ pos/ -/ 1/ 位置/ 到/ pos/ -/ step/ 位置/ 的/ 二进制/ 序列/ 可以/ 被/ 解释/ 成/ 一个/ 合法/ 指令/ insn/ ,/ 则/ 调用/ Viable/ (/ )/ 函数/ 判断/ 它/ 是否是/ 转移/ 指令/ ,/ 因为/ 转移/ 指令/ 可以/ 改变/ 控制流/ ,/ BIOP/ 只能/ 由/ 指令/ 序列/ 最后/ 的/ 非/ 条件/ 转移/ 指令/ 控制程序/ 执行/ ,/ 不/ 允许/ insn/ 为/ 转移/ 指令/ ./ 注意/ ,/ 这里/ 将/ call/ 指令/ 排除/ 在/ 分支/ 指令/ 外/ ,/ 因为/ call/ 指令/ 可以/ 构成/ 联合/ 指令/ 序列/ ./ 如果/ insn/ 不是/ call/ 之外/ 的/ 间接/ 转移/ 指令/ ,/ 那么/ 将/ insn/ 作为/ parent/ _/ insn/ (/ 即/ pos/ 所/ 指向/ 的/ 非/ 条件/ 转移/ 指令/ )/ 的/ 一个/ 孩子/ 节点/ ,/ 然后/ 递归/ 调用/ BuildTreePage5/ 来/ 构建/ insn/ 的/ 孩子/ 节点/ ./ 算法/ 生成/ 的/ 指令/ 序列/ 中/ ,/ 相邻/ 两条/ 指令/ 的/ 后/ 一条/ 指令/ 在/ 树/ 中/ 是/ 前/ 一条/ 指令/ 的/ 父亲/ 节点/ ./ 例如/ 指令/ 序列/ 005858ffe1/ ,/ 可/ 得到/ 如图/ 3/ (/ a/ )/ 一个/ 子树/ ./ 通过/ 这个/ 子树/ ,/ 可/ 得到/ 图/ 3/ (/ b/ )/ 4/ 个/ BIOP/ 指令/ 序列/ ./ 所以/ ,/ 使用/ 该/ 算法/ 得到/ 的/ 树/ 集合/ ,/ 从树/ 的/ 某个/ 节点/ 到/ 根/ 节点/ 的/ 指令/ 序列/ 就是/ 一个/ BIOP/ 指令/ 序列/ ./ 2.4/ BIOPgadget/ 实例/ 本/ 节/ 我们/ 研究/ 在/ libc/ -/ 2.3/ ./ 5/ ./ so/ 和/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ 两个/ 库中/ 找到/ 的/ BIOP/ 指令/ 序列/ ,/ 并且/ 依据/ 它们/ 可以/ 实现/ 的/ 功能/ 对/ 其/ 分类/ ./ 通过/ 实例/ 可/ 看出/ ,/ 库中/ 存在/ 的/ 指令/ 序列/ 可以/ 实现/ 大部分/ 的/ x86/ 操作/ ,/ 如/ 数据/ 传送/ 、/ 算术/ 运算/ 、/ 逻辑运算/ 、/ 分支/ 语句/ 和/ 系统/ 调用/ 等等/ ./ 2.4/ ./ 1/ 数据/ 传送数据/ 传送/ 指令/ 的/ 功能/ 是/ 将/ 数据/ 或/ 地址/ 传送/ 到/ 寄存器/ 或/ 存储器/ 单元/ 中/ ,/ 如/ pop/ %/ edx/ 指令/ ,/ 可以/ 使用/ 如下/ 两个/ 指令/ 序列/ 实现/ :/ 上述/ 两个/ 指令/ 序列/ 运行/ 如图/ 4/ 所示/ ,/ 首先/ 栈/ 内设/ 好/ 传递/ 给/ esi/ 寄存器/ 的/ 值/ 和/ 递给/ edx/ 寄存器/ 的/ 值/ 0xdeadbeef/ ,/ 传递/ 给/ esi/ 寄存器/ 的/ 值/ 是/ 内存空间/ 某个/ 地址/ ./ 当/ 程序执行/ gadget/ (/ 1/ )/ 时/ ,/ pop/ %/ esi/ 将栈/ 顶值/ 传递/ 给/ esi/ ,/ 此时/ esi/ 指向/ 的/ 内存/ 中/ 存放/ gadget/ (/ 2/ )/ 地址/ ,/ 当/ 执行/ jmp/ / 0x0/ (/ %/ esi/ )/ 时/ ,/ 程序/ 跳转/ 到/ gadget/ (/ 2/ )/ ,/ 执行/ pop/ %/ edx/ ,/ 将/ 0xdeadbeef/ 传递/ 给/ edx/ 寄存器/ ./ -/ 0x7d/ (/ %/ esi/ )/ 中/ 存放/ 着/ 下/ 一个/ 要/ 跳转/ 的/ 指令/ 序列/ 地址/ ,/ 执行/ 完/ gadget/ (/ 2/ )/ ,/ 程序/ 自动/ 跳转/ 到/ 下/ 一个/ 设定/ 的/ 指令/ 序列/ ./ 数据/ 传送/ 指令/ 中/ 的/ 标志/ 传送/ 指令/ 用于/ 传送/ 标志/ 器/ 寄存器/ eflag/ 中/ 的/ 标志/ 位/ ,/ 以便/ 设置/ 、/ 修改/ 和/ 保存/ eflag/ 寄存器/ 中/ 的/ 标志/ ./ 如/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ 中/ 的/ gadget/ (/ 3/ )/ :/ 2.4/ ./ 2/ 算术/ 运算/ 和/ 逻辑运算/ 对于/ 算术/ 运算/ 和/ 逻辑运算/ ,/ 先/ 使用/ 数据/ 传送/ 指令/ 序列/ 将/ 操作数/ 传入/ 寄存器/ 或/ 内存/ 中/ ,/ 然后/ 使用/ 对应/ 的/ 指令/ 序列/ 完成/ 算术/ 运算/ 和/ 逻辑运算/ ./ 例如/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ 中/ 的/ gadget/ (/ 4/ )/ :/ 2.4/ ./ 3/ 分支/ 语句/ 在/ BIOP/ 中/ 我们/ 使用/ 类似/ jmp/ / (/ reg1/ ,/ reg2/ ,/ 1/ )/ 或/ call/ / (/ reg1/ ,/ reg2/ ,/ 1/ )/ 的/ 指令/ 序列/ 实现/ 分支/ 指令/ ./ reg1/ 中/ 放置/ 地址/ 偏移/ ,/ 它/ 的/ 值/ 随着/ 标志/ 寄存器/ 不同/ 而/ 不同/ ,/ reg2/ 放置/ 基/ 地址/ ./ 如/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ 中/ 的/ gadget/ (/ 5/ )/ :/ 图/ 5/ 是/ 一个/ 简单/ 的/ 条件/ 跳转/ 实例/ ,/ 它/ 可以/ 实现/ jz/ 指令/ 或/ jnz/ 指令/ ,/ 用到/ 指令/ 序列/ 序列/ 如下/ :/ Page6/ 我们/ 假设/ 数据传输/ 指令/ 序列/ 已经/ 设置/ 好/ eax/ 、/ edx/ 、/ ebp/ 和/ esi/ 的/ 值/ ,/ 同时/ 将/ ebp/ 的/ 值/ 设置/ 为/ 0xffffffbf/ ./ 程序运行/ 时/ ,/ 首先/ 将/ 标志/ 寄存器/ 的/ 值入/ 栈/ ,/ 然后/ 传递/ 给/ 寄存器/ edx/ ,/ 将/ edx/ 的/ 值/ 与/ ebp/ 的/ 值/ 进行/ 或/ 操作/ ,/ 并/ 将/ 结果/ 保存/ 在/ edx/ 中/ ./ 当/ 保存/ 在/ edx/ 中/ 的/ 标志/ 寄存器/ 值/ 的/ zf/ 位为/ 0/ 时/ ,/ 得到/ 的/ 值/ 为/ 0xffffffbf/ ,/ jmp/ / (/ %/ edx/ ,/ %/ esi/ ,/ 1/ )/ 相当于/ 执行/ jmp/ / -/ 0x41/ (/ %/ esi/ )/ ./ 当/ zf/ 位为/ 1/ 时/ ,/ 得到/ 的/ 值/ 为/ 0xffffffff/ ,/ 相当于/ 执行/ jmp/ / -/ 0x1/ (/ %/ esi/ )/ ./ 这样/ 就/ 根据/ zf/ 位/ 的/ 不同/ 而/ 跳转/ 到/ 不同/ 的/ 地方/ ./ 注意/ ,/ 使用/ 这种/ 方法/ 实现/ jc/ 或/ jnc/ 等/ 与/ cf/ 标志/ 位/ 相关/ 的/ 指令/ 时/ ,/ 会/ 出现/ jmp/ / -/ 0x2/ (/ %/ esi/ )/ 和/ jmp/ / -/ 0x1/ (/ %/ esi/ )/ 地址/ 重叠/ 的/ 情况/ ,/ 针对/ 这种/ 情况/ ,/ 我们/ 使用/ 左/ 移位指令/ 序列/ 或者/ 乘法/ 运算/ 指令/ 序列/ 去/ 放大/ 地址/ 之间/ 的/ 距离/ ./ 2.4/ ./ 4/ 系统/ 调用/ 在/ BIOP/ 中/ 我们/ 一般/ 使用/ 联合/ 指令/ 序列/ 实现/ 系统/ 调用/ 功能/ ,/ 如/ gadget/ (/ 6/ )/ :/ ff5654call/ / 0x54/ (/ %/ esi/ )/ 首先/ 使用/ 数据/ 传送/ 指令/ 序列/ 设置/ esi/ 和/ ebp/ 寄存器/ 的/ 值/ ,/ 0x54/ (/ %/ esi/ )/ 内/ 存放/ 的/ 是/ lcall/ %/ gs/ :/ 0x10/ (/ ,/ 0/ )/ 的/ 地址/ ,/ -/ 0x18/ (/ %/ ebp/ )/ 中/ 存放/ 下/ 一个/ 指令/ 序列/ 地址/ ./ 然后/ 用/ 数据/ 传送/ 指令/ 序列/ 将/ 需要/ 传递/ 的/ 参数传递/ 给/ 对应/ 的/ 寄存器/ ,/ 执行/ 这个/ 指令/ 序列/ 就/ 可以/ 实现/ 系统/ 调用/ 功能/ ./ 2.5/ BIOP/ 构造/ 形式/ 图/ 6/ 描述/ 了/ BIOP/ 的/ 构造/ 形式/ ,/ BIOP/ 由/ 多个/ 以/ call/ 或/ jmp/ 结尾/ 的/ 指令/ 序列/ 串联/ 起来/ 构成/ ,/ 每个/ 指令/ 序列/ 在/ 执行/ 完毕/ 以后/ 都/ 会/ 跳转/ 到/ 下/ 一个/ 指令/ 序列/ 开头/ ,/ 多个/ 指令/ 序列/ 内部/ 的/ 指令/ 的/ 组合/ 可以/ 实现/ 特定/ 的/ 语义/ ./ 首先/ ,/ 我们/ 看到/ 这/ 类/ 指令/ 序列/ 并/ 不/ 存在/ 特殊/ 的/ 指令/ 类型/ ,/ 如/ 文献/ [/ 8/ ]/ 中/ 必须/ 使用/ pop/ 指令/ 为/ 以后/ 的/ jmp/ 指令/ 中/ 寄存器/ 赋值/ 从而/ 确定/ 跳转/ 地址/ 的/ 情况/ ./ 在/ 这里/ ,/ 给/ jmp/ 指令/ 中/ 寄存器/ 赋值/ 的/ 指令/ 可以/ 有/ 多种类型/ ,/ 如/ mov/ 、/ add/ 等/ ./ 其次/ ,/ 区别/ 于/ 文献/ [/ 9/ ]/ 中/ 使用/ 调度/ 指令/ 序列/ 管理/ 分发/ 控制流/ ,/ BIOP/ 攻击/ 的/ 控制流/ 与/ 普通/ 程序/ 的/ 控制流/ 类似/ ,/ 每个/ 指令/ 序列/ 执行/ 完毕/ 后/ ,/ 都/ 会/ 经过/ call/ 或/ jmp/ 指令/ 将/ 控制/ 流传/ 递给/ 下/ 一个/ 指令/ 序列/ ./ 而/ 在/ 普通/ 程序/ 中/ ,/ 使用/ call/ 指令/ 或/ jmp/ 指令/ 跳转/ 到/ 其他/ 指令/ 序列/ 这种/ 情况/ 也/ 普遍存在/ ./ 所以/ BIOP/ 攻击/ 的/ 程序/ 更/ 类似/ 于/ 正常/ 程序/ ,/ 不易/ 被/ 检测/ 到/ ./ 3/ 自动/ 构造/ BIOP/ 攻击/ 本节/ 将/ 对/ 自动/ BIOP/ 构造/ 时/ 出现/ 的/ 问题/ 进行/ 探讨/ ,/ 并/ 给出/ 解决/ 方法/ ./ 同时/ 在/ 本节/ 我们/ 会/ 介绍/ 自动化/ 构造/ 工具/ 的/ 基本原理/ ./ 3.1/ BIOP/ 寄存器/ 副作用/ 对/ 攻击/ 构造/ 的/ 影响/ 在/ 构造/ BIOP/ 攻击/ 时/ ,/ 会/ 出现/ 多个/ 指令/ 序列/ 使用/ 到/ 同一个/ 寄存器/ ,/ 导致/ 寄存器/ 在/ 赋值/ 和/ 使用/ 时/ 出现/ 数据/ 不/ 一致/ 的/ 问题/ ./ 这类/ 问题/ 同样/ 在/ 传统/ 的/ ROP/ 和/ ROP/ 改进/ 工作/ 中/ 出现/ ,/ 传统/ 的/ 方法/ 是/ 人工/ 分析/ 构造/ 的/ 指令/ 序列/ 序列/ 是否/ 可行/ ,/ 导致/ ROP/ 和/ JOP/ 不/ 具有/ 实用性/ ./ 为此/ ,/ 我们/ 在/ 本节/ 深入探讨/ 造成/ 这种/ 原因/ 的/ 主要/ 因素/ ./ 我们/ 把/ 构造/ 中/ 寄存器/ 使用/ 时/ 冲突/ ,/ 称之为/ 寄存器/ 副作用/ ./ 导致/ 寄存器/ 副作用/ 的/ 原因/ 有/ Page73/ 种/ ,/ (/ 1/ )/ 用/ 某个/ 寄存器/ 传递/ 控制流/ 和/ 将/ 该/ 寄存器/ 用作/ 其他/ 用途/ 时/ 产生/ 的/ 冲突/ ;/ (/ 2/ )/ 两个/ 指令/ 序列/ 用/ 同一个/ 寄存器/ 传递/ 控制流/ 跳时/ 产生/ 的/ 冲突/ ;/ (/ 3/ )/ 指令/ 序列/ 本身/ 某些/ 指令/ 会/ 改变/ 已设/ 寄存器/ 的/ 值/ ./ 我们/ 以/ 文献/ [/ 9/ ]/ 的/ 调度/ 指令/ 序列/ 为例/ ,/ 在/ 程序/ 中/ 的/ 每个/ 功能/ 指令/ 序列/ 都/ 会/ 跳转/ 到/ 调度/ 指令/ 序列/ ,/ 然后/ 由/ 这个/ 调度/ 指令/ 序列/ 决定/ 下/ 一个/ 要/ 使用/ 的/ 功能/ 指令/ 序列/ ./ 如下/ 是/ 某个/ 理想/ 的/ 调度/ 指令/ 序列/ :/ 83c204add/ $/ 0x4/ ,/ %/ edx/ 对于/ 第/ 1/ 种/ 原因/ ,/ 有/ 多种/ 可能/ 的/ 情况/ ./ 如/ 在/ 这个/ 指令/ 序列/ 中/ ,/ 需要/ 使用/ edx/ 寄存器/ 确定/ 指令/ 序列/ 要/ 跳转/ 的/ 地址/ ./ 如果/ 程序/ 中/ 需要/ 用到/ edx/ 作为/ 参数/ 的/ 系统/ 调用/ ,/ 那么/ 我们/ 需要/ 一个/ 数值/ 传递/ 指令/ 序列/ 将/ 参数传递/ 给/ edx/ 寄存器/ ,/ 此处/ 如果/ 仍然/ 使用/ 调度/ 指令/ 序列/ ,/ 就/ 会/ 产生/ 错误/ ./ 这/ 在/ 很大/ 程度/ 上/ 限制/ 了/ 构造/ 的/ 能力/ ./ 对于/ 第/ 2/ 种/ 原因/ ,/ 例如/ 在/ 程序/ 中/ 使用/ 了/ 如下/ gadget/ (/ 8/ )/ ./ 由于/ 都/ 是/ 用/ edx/ 寄存器/ 实现/ 指令/ 序列/ 的/ 跳转/ ,/ 所以/ 调度/ 指令/ 序列/ 和/ gadget/ (/ 8/ )/ 不能/ 在/ 一起/ 使用/ ./ 8b6110mov0x10/ (/ %/ ecx/ )/ ,/ %/ esp/ 同样/ ,/ 我们/ 也/ 用/ 如下/ 的/ gadget/ (/ 9/ )/ 来/ 解释/ 第/ 3/ 种/ 原因/ ./ 当/ 使用/ 这个/ 指令/ 序列/ 对/ al/ 进行/ 与/ 操作/ 时/ ,/ cdq/ 指令/ 会/ 改变/ edx/ 值/ ,/ 导致/ 调度/ 指令/ 序列/ 不能/ 继续/ 使用/ ./ 所以/ 使用/ 类似/ 调度/ 指令/ 序列/ 会/ 严重/ 影响/ JOP/ 构造/ 的/ 能力/ ./ 同样/ ,/ 这种/ 寄存器/ 副作用/ 也/ 存在/ 于/ BIOP/ 程序/ 中/ ./ 3.2/ 消除/ 寄存器/ 副作用/ 由于/ BIOP/ 程序/ 中/ 存在/ 的/ 寄存器/ 副作用/ ,/ 导致/ BIOP/ 的/ 构造/ 具有/ 一定/ 的/ 困难/ 和/ 挑战/ ,/ 为了/ 解决/ 这个/ 问题/ ,/ 我们/ 在/ 本节/ 给出/ 两个/ 构造/ 攻击/ 的/ 规则/ 以/ 消除/ 寄存器/ 副作用/ 和/ 一个/ 指令/ 序列/ 排列/ 算法/ 以/ 实现/ 自动化/ 选择/ 和/ 排列/ 指令/ 序列/ ./ 的/ 赋值/ ./ 规则/ 1/ ./ 每个/ 寄存器/ 在/ 使用/ 之前/ 必须/ 有/ 对应/ 我们/ 根据/ 对/ 某个/ 寄存器/ 的/ 操作/ 将/ 指令/ 序列/ 分为/ 如/ 对于/ gadget/ (/ 9/ )/ 是/ 赋值/ 指令/ 序列/ ,/ 而/ 紧随其后/ 是/ 需要/ 用/ eax/ 值为/ 0x1/ 的/ 系统/ 调用/ 指令/ 序列/ ,/ 由于/ 任何/ 数/ 和/ 0xe8/ 进行/ 与/ 操作/ 的/ 结果/ 不为/ 0x1/ ,/ 这种/ 情况/ 违反/ 了/ 规则/ 2/ ./ 通过/ 满足/ 规则/ 2/ 确保/ 每次/ 指令/ 序列/ 所用/ 到/ 的/ 寄存器/ 的/ 值/ 都/ 是/ 符合/ 预期/ 的/ ./ 为了/ 实现/ BIOP/ 构造/ 的/ 自动化/ ,/ 我们/ 提供/ 了/ 一个/ 指令/ 序列/ 排列/ 算法/ (/ 算法/ 2/ )/ 来/ 解决/ 这个/ 问题/ ./ 如图/ 8/ 所示/ ./ 赋值/ 指令/ 序列/ 和/ 应用/ 指令/ 序列/ 两类/ ,/ 赋值/ 指令/ 序列/ 将/ 某个/ 数据/ 传入/ 该/ 寄存器/ ,/ 应用/ 指令/ 序列/ 则/ 使用/ 该/ 寄存器/ 完成/ 特定/ 操作/ ./ 如/ 3.4/ ./ 3/ 节中/ 实现/ jz/ 或/ jnz/ 功能/ 的/ 指令/ 序列/ 组/ ,/ 对于/ edx/ 寄存器/ 来说/ ,/ gadget/ (/ 2/ )/ 是/ 赋值/ 指令/ 序列/ ,/ gadget/ (/ 4/ )/ 相对/ 于/ gadget/ (/ 5/ )/ 是/ 赋值/ 指令/ 序列/ ,/ 相对/ 于/ gadget/ (/ 2/ )/ 是/ 应用/ 指令/ 序列/ ,/ gadget/ (/ 5/ )/ 是/ 应用/ 指令/ 序列/ ./ 规则/ 2/ ./ 使用/ 寄存器/ 前/ ,/ 最近/ 给/ 该/ 寄存器/ 赋值/ 的/ 指令/ 序列/ 的/ 赋值/ 结果/ ,/ 必须/ 是/ 使用/ 该/ 寄存器/ 时所/ 需要/ 的/ 值/ ./ 算法/ 2/ ./ gadget/ 排列/ 算法/ ./ LoadGadgetsSelectionAlgorithmLr/ :/ LoadregistersingadgetLi/ :/ LimitedregistersingadgetR/ :/ ThecandidateregistersneedtobesetT/ :/ GadgetssetwhichcontainstheselectedG/ :/ Allloadgadgetsgetformlibinput/ :/ R/ ,/ G/ ;/ output/ :/ TwhileR/ !/ =/ NULLdoTheruleofselectgadgetinGasfollows/ :/ fromMAXto1/ ,/ registersofgadget/ ./ Lr/ ∩/ RdoIfgadget/ ./ Li/ ∩/ R/ =/ =/ NULLdoRemoveregistersinbothLrandRPutgadgetinTendifendfromendwhile/ 在/ 算法/ 2/ 中/ ,/ 我们/ 对/ 搜索/ 到/ 的/ 每/ 一个/ 具有/ Load/ 功能/ 的/ 指令/ 序列/ 定义/ 赋值/ 寄存器/ 集合/ Lr/ 和/ 受限/ 的/ 寄存器/ 集合/ Li/ ./ 以/ gadget/ (/ 2/ )/ 为例/ ,/ gadget/ (/ 2/ )/ ./ Lr/ 为/ {/ edx/ }/ ,/ gadget/ (/ 2/ )/ ./ Li/ 为/ {/ esi/ }/ ./ 注意/ ,/ 如果/ 在/ 指令/ 序列/ 中/ 某个/ 受限/ 寄存器/ 之前/ 已经/ 有/ 给/ 这个/ 寄存器/ 赋值/ 的/ 指令/ ,/ 则/ 不/ 把/ 这个/ 寄存器/ 加入/ Li/ 中/ ./ 如/ 在/ gadget/ (/ 1/ )/ 中/ 的/ Lr/ 为/ esi/ ,/ Li/ 为/ / ./ 我们/ 对/ 所有/ 的/ 指令/ 序列/ 按/ 赋值/ 寄存器/ 与/ 待/ 赋值/ 寄存器/ 集合/ 并集/ 元素/ 个数/ 从/ 多/ 到/ 少/ 进行/ 搜索/ ,/ 找出/ gadget/ ./ Li/ 与/ 集合/ R/ 并/ 集为/ 空/ 的/ 指令/ 序列/ ,/ 将/ 赋值/ 的/ 寄存器/ 从/ 集合/ R/ 中/ 移除/ ,/ 并/ 将/ 指令/ 序列/ 放入/ 集合/ Page8T/ ,/ 当/ R/ 中/ 不再/ 存在/ 寄存器/ 时/ ,/ T/ 中/ 存放/ 的/ 是/ 实现/ 赋值/ 功能/ 的/ 指令/ 序列/ ./ 这个/ 算法/ 保证/ 在/ 每次/ 将/ 某个/ 寄存器/ 从/ R/ 中/ 移除/ 时/ ,/ 都/ 已经/ 给/ 这个/ 寄存器/ 赋值/ ,/ 在此之后/ 的/ 赋值/ 指令/ 序列/ 都/ 不会/ 改变/ 这个/ 寄存器/ ./ 3.3/ BIOP/ 的/ 图灵/ 完备/ 性/ Shacham/ [/ 2/ ]/ 认为/ ROP/ “/ 从/ 直觉/ 上/ ”/ 看/ 是/ 图灵/ 完备/ 的/ ,/ 通过/ 一些/ 技巧/ 可以/ 实现/ 任意/ 功能/ ./ 实际上/ ROP/ 、/ JOP/ 与/ BIOP/ 的/ 能力/ 受限于/ 系统/ 中/ 的/ 函数库/ 或者/ 可/ 执行/ 代码/ ,/ 如果/ 某个/ 功能/ 在/ 库/ 或/ 可/ 执行/ 代码/ 中/ 找/ 不到/ 对应/ 的/ gadget/ ,/ 同时/ 也/ 无法/ 使用/ 其他/ 技巧/ 来/ 实现/ 时/ ,/ 可能/ 这个/ 操作/ 就/ 无法/ 用/ ROP/ 或/ BIOP/ 来/ 实现/ ./ 通过/ 上述/ 讨论/ 我们/ 知道/ BIOP/ 的/ 构造/ 存在/ 一些/ 限制/ ,/ 如/ 系统/ 调用/ 指令/ 序列/ ,/ 我们/ 并/ 没有/ 找到/ syscall/ -/ jmp/ 这类/ 指令/ 序列/ ,/ 所以/ 我们/ 只有/ 通过/ 联合/ 指令/ 序列/ 实现/ 这/ 类/ 功能/ ./ 但是/ 如果/ 某个/ 系统/ 调用/ 需要/ 用到/ 多个/ 寄图/ 7/ 控制/ gadget/ 原理/ 在/ 构造/ ROP/ 与/ BIOP/ 时/ ,/ 还/ 存在/ 一类/ 地址/ 冲突/ 问题/ ,/ 例如/ gadget/ (/ 10/ )/ 和/ gadget/ (/ 11/ )/ ,/ 由于/ jmp/ 的/ 跳转/ 地址/ 均/ 存放/ 在/ -/ 0x77/ (/ %/ esi/ )/ 地址/ 空间/ 中/ ,/ 所以/ 在/ 连续/ 使用/ 这/ 两个/ 指令/ 序列/ 时会/ 出现/ 地址/ 冲突/ 问题/ ,/ 如果/ 使用/ 以/ call/ 指令/ 结尾/ 的/ 指令/ 序列/ ,/ call/ 指令/ 运行/ 时会/ 将/ 指令/ 地址/ 入栈/ ,/ 从而/ 占用/ 当前/ 栈/ 的/ 空间/ ,/ 存器/ 传递/ 参数/ ,/ 那么/ 使用/ 联合/ 指令/ 序列/ 来/ 实现/ 系统/ 调用/ 也/ 不是/ 一个/ 理想/ 选择/ ./ 当然/ ,/ 这是/ 一个/ 开放性/ 问题/ ,/ 是否/ 有/ 其他/ 技巧/ 可以/ 实现/ 类似/ 功能/ ,/ 我们/ 在/ 此/ 并/ 不/ 讨论/ ./ 3.4/ 控制/ gadget/ 本节/ 我们/ 提出/ 一种/ 特殊/ 的/ 控制指令/ 序列/ ,/ 用于/ 解决/ BIOP/ 构造/ 中/ 可能/ 出现/ 的/ 地址/ 冲突/ 问题/ 和/ 内存/ 安排/ 问题/ ./ 这类/ 指令/ 序列/ 对于/ 寄存器/ 是/ 一种/ 自省/ 控制/ 方式/ ,/ 它/ 可以/ 在/ 指令/ 序列/ 内部/ 同时/ 实现/ 对/ 寄存器/ 的/ 赋值/ 和/ 使用/ 该/ 寄存器/ 控制/ 将要/ 跳转/ 的/ 地址/ ,/ 理想/ 状态/ 下/ 并/ 不/ 影响/ 其他/ 的/ 寄存器/ ./ 图/ 7/ 是/ 控制指令/ 序列/ 的/ 原理图/ ./ 在/ 图/ 7/ 中/ ,/ gadget/ (/ 1/ )/ 是/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ 库中/ 一个/ 典型/ 的/ 控制指令/ 序列/ ,/ 它/ 利用/ 栈/ 对/ esi/ 进行/ 赋值/ 同时/ 使用/ esi/ 控制指令/ 序列/ 的/ 跳转/ ,/ 且/ 它/ 很少/ 影响/ 其他/ 寄存器/ ./ 使此/ 指令/ 序列/ 之后/ 的/ 指令/ 无法/ 从/ 这个/ 栈内/ 取值/ ./ ROP/ 中/ 通过/ 栈/ 控制程序/ 执行/ ,/ 并/ 不/ 存在/ 这/ 类/ 问题/ ,/ 但是/ BIOP/ 中/ ,/ 由于/ BIOP/ 指令/ 序列/ 的/ 数量/ 有限/ ,/ 这/ 类/ 问题/ 便/ 显得/ 尤为/ 突出/ ./ 通过/ 在/ gadget/ (/ 10/ )/ 和/ gadget/ (/ 11/ )/ 之间/ 插入/ 控制/ gadget/ (/ 1/ )/ ,/ 改变/ esi/ 寄存器/ 的/ 值/ ,/ 从而/ 解决/ 地址/ 冲突/ ./ Page9/ 在/ BIOP/ 中/ ,/ 同时/ 还/ 存在/ 内存空间/ 安排/ 问题/ ,/ 例如/ gadget/ (/ 11/ )/ 和/ 系统/ 调用/ gadget/ (/ 6/ )/ ,/ 他们/ 都/ 是/ 用/ esi/ 寄存器/ 控制程序/ 跳转/ ,/ 如果/ 连续/ 使用/ 这/ 两个/ 指令/ 序列/ ,/ 那么/ 在/ esi/ -/ 0x76/ 到/ esi/ +/ 0x53/ 这段/ 内存/ 中/ 的/ 某些/ 空间/ 将会/ 被/ 闲置/ ./ 通过/ 使用/ 联合/ gadget/ (/ 1/ )/ ,/ 改变/ esi/ 的/ 值/ ,/ 可以/ 使/ 闲置/ 空间/ 缩短/ 为/ esi/ +/ 0x1/ 到/ esi/ +/ 0x53/ ./ 3.5/ BIOP/ 构造/ 自动化/ 工具/ 造/ BIOP/ 攻击/ 的/ 工具/ ,/ 原理/ 如图/ 8/ 所示/ ./ 通过/ 上述/ 分析/ ,/ 我们/ 设计/ 实现/ 了/ 一个/ 自动化/ 构/ 我们/ 的/ 工具/ 主要/ 由/ 指令/ 序列/ 收集器/ (/ ①/ )/ 、/ 指令/ 序列/ 排列/ 器/ (/ ②/ )/ 和/ 内存/ 优化/ 器/ (/ ③/ )/ 3/ 部分/ 组成/ ./ 指令/ 序列/ 收集器/ 通过/ 算法/ 1/ (/ BIOPgadgetSearchingAlgorithm/ )/ 从库/ 或/ 可执行文件/ 中/ 收集/ 可用/ 的/ 指令/ 序列/ ./ 指令/ 序列/ 排列/ 器/ 通过/ 对/ shellcode/ 的/ 分析/ ,/ 找出/ 对应/ 功能/ 的/ 指令/ 序列/ ,/ 并/ 通过/ 算法/ 2/ (/ LoadGadgetsSelectionAlgorithm/ )/ 实现/ 各个/ 功能/ 中/ 寄存器/ 的/ 赋值/ ./ 内存/ 优化/ 器/ 使用/ 控制指令/ 序列/ 解决/ 指令/ 序列/ 排列/ 器/ 生成/ 的/ 指令/ 序列/ 中/ 的/ 内存/ 冲突/ 和/ 空间/ 安排/ 问题/ ,/ 并/ 生成/ 所/ 最终/ 的/ BIOPshellcode/ ./ 4/ 实验/ 与/ 评估/ 4.1/ BIOPshellcode/ 实例/ 本/ 节/ 给出/ 一个/ 使用/ 自动化/ 工具/ 构造/ 的/ shell/ -/ code/ 实例/ ,/ 功能/ 是/ 通过/ 执行/ execve/ 系统/ 调用/ 运行/ 一个/ shell/ ./ 这个/ shellcode/ 具体/ 实现/ 如下/ :/ 在/ 执行/ 系统/ 调用/ 之前/ ,/ 将/ 系统/ 调用/ 号/ 0xb/ 传递/ 给/ eax/ 寄存器/ ,/ 执行程序/ 的/ 路径/ “/ // bin/ // // sh/ ”/ 地址/ 传递/ 给/ ebx/ 寄存器/ ,/ 参数/ 向量/ 传递/ 给/ ecx/ 寄存器/ (/ 参数/ 向量/ 指向/ 两个/ 指针/ 的/ 队列/ ,/ 一个/ 是/ 指向/ “/ // bin/ // // sh/ ”/ 字符串/ ,/ 另/ 一个/ 是/ 空/ 指针/ )/ ,/ 环境/ 向量/ (/ 空/ 指针/ )/ 传递/ 给/ edx/ 寄存器/ ./ 具体/ 实现/ 方法/ 如图/ 9/ 所示/ ,/ 图中/ 左侧/ 给出/ BIOP/ 的/ 内存/ 安排/ 和/ 内存地址/ 的/ 后/ 12/ 位/ ./ 右侧/ 虚线/ 代表/ 了/ 指令/ 序列/ 的/ 执行/ 循序/ ./ 通过/ 一次/ 缓冲区/ 溢出/ ,/ 将/ 返回值/ 地址/ 用/ gadget/ (/ 12/ )/ 所在/ 的/ 地址/ 改写/ ,/ 程序/ 在/ 返回/ 时/ 跳转/ 到/ 我们/ 设定/ 的/ 指令/ 序列/ ,/ 然后/ 循环/ 3/ 次/ 使用/ gadget/ (/ 12/ )/ 和/ gadget/ (/ 13/ )/ ./ 对于/ gadget/ (/ 13/ )/ ,/ 把/ edi/ 和/ ebx/ 指向/ 的/ 内存/ 设定/ 好/ 相应/ 的/ 值/ ,/ 相加/ 后会/ 将/ 结果/ 放入/ ebx/ 指向/ 的/ 内存/ 中/ ./ 这/ 在/ 构造/ 攻击/ 中/ 可以/ 解决/ 0/ 比特/ 的/ 问题/ ,/ 因为/ 在/ 缓冲区/ 溢出/ 中/ ,/ 不/ 允许/ 有/ 0x0/ 的/ 存在/ ./ 如给/ eax/ 赋值/ 为/ 0xb/ ,/ 首先/ 使用/ gadget/ (/ 12/ )/ 将/ edi/ 设置/ 为/ 0xeeeeeee0/ ,/ ebx/ 指向/ 的/ 空间/ 设置/ 为/ 0x1111112b/ ,/ 这个/ 空间/ 以后/ 将会/ 给/ eax/ 赋值/ ,/ 所以/ 在/ 执行/ gadget/ (/ 13/ )/ 之后/ ,/ ebx/ 指向/ 空间/ 结果/ 为/ 0xb/ ./ 同样/ 在/ shellcode/ 中/ ,/ 第/ 2/ 次/ 和/ 第/ 3/ 次/ 使用/ 是/ 将/ 相应/ 的/ 内存空间/ 赋值/ 为/ 0x0/ ./ 使用/ gadget/ (/ 12/ )/ 和/ gadget/ (/ 14/ )/ 给/ eax/ 、/ ebx/ 、/ ecx/ 、/ edx/ 、/ esi/ 、/ edi/ 、/ ebp7/ 个/ 寄存器/ 赋好/ 相应/ 的/ 值/ ,/ 在/ 这里/ 给/ eax/ 赋值/ 的/ 内存/ 恰好/ 是/ 在/ 通过/ gadget/ (/ 13/ )/ 设置/ 的/ ,/ 在/ 运行/ gadget/ (/ 14/ )/ 后/ ,/ eax/ 的/ 值/ 是/ 系统/ 调用/ 号/ 0xb/ ./ 最后/ 执行/ 系统/ 调用/ 完成/ execve/ 启动/ 一个/ shell/ ./ 在/ 内存/ 中/ ,/ 我们/ 没有/ 用到/ 的/ 闲置/ 内存/ ,/ 全部/ 用/ 字符/ ”/ A/ ”/ 填充/ ./ BIOPshellcode/ 二进制/ 代码/ 如图/ 10/ 所示/ ./ Page10/ 图/ 9BIOPshellcode/ 构造/ 图/ 10BIOPshellcode/ 实例/ Page114/ ./ 2BIOPshellcode/ 我们/ 从/ 网站/ ①/ 中/ 选取/ 了/ 22/ 个/ shellcode/ 进行/ 构造/ ,/ 使用/ 常见/ 的/ libc/ -/ 2.3/ ./ 5/ ./ so/ 库/ 和/ libgcj/ ./ so/ ./ 5.0/ ./ 0/ 表/ 2BIOPshellcode12345678setreuid/ (/ getuid/ (/ )/ ,/ getuid/ (/ )/ )/ ,/ execve/ (/ “/ // bin/ // sh/ ”/ ,/ 0/ ,/ 0/ )/ 91011121314ejectcd/ -/ rom/ (/ follows/ // dev/ // cdromsymlink/ )/ +/ exit/ (/ )/ 15anti/ -/ debugtrick/ (/ INT3htrap/ )/ +/ execve/ // bin/ // sh16171819202122/ 在/ 我们/ 构造/ 的/ shellcode/ 中/ ,/ 有/ 的/ 涉及/ 了/ 复杂/ 的/ shellcode/ 的/ 设计/ ./ 包括/ 使用/ 多个/ 系统/ 调用/ 、/ 条件/ 跳转/ 和/ loop/ 指令/ 等/ ./ 如/ setreuid/ (/ getuid/ (/ )/ ,/ getuid/ (/ )/ )/ ,/ execve/ (/ “/ // bin/ // sh/ ”/ ,/ 0/ ,/ 0/ )/ ,/ 需要/ 涉及/ 3/ 个/ 系统/ 调用/ ,/ dup2/ (/ 0/ ,/ 0/ )/ 、/ dup2/ (/ 0/ ,/ 1/ )/ 、/ dup2/ (/ 0/ ,/ 2/ )/ ,/ Ho/ ’/ Detector/ 使用/ 条件/ 跳转/ 指令/ ,/ RadicallySelfModifyingCode/ 使用/ loop/ 指令/ 等/ ./ 由表/ 2/ 可以/ 看出/ ,/ 随着/ shellcode/ 复杂性/ 的/ 增加/ ,/ 构造/ BIOPshellcode/ 的/ 复杂度/ 也/ 在/ 增大/ ./ shellcode/ 的/ 长度/ 越大/ ,/ 构造/ 的/ BIOPshellcode/ 的/ gadget/ 数目/ 和/ 大小/ 也/ 越/ 大/ ,/ 一般/ BIOPshellcode/ 都/ 在/ 100/ 比特/ 之上/ ./ 4.3/ BIOP/ 攻击/ 效力/ 我们/ 同时/ 测试/ BIOP/ 对/ 现有/ 的/ ROP/ // JOP/ 防御/ 技术/ 的/ 效力/ ./ 如表/ 3/ 所示/ ,/ 我们/ 选取/ 3/ 种/ 典型/ 的/ ROP/ 防御/ 方法/ 进行/ 测试/ ,/ 分别/ 是/ :/ (/ 1/ )/ DROP/ [/ 5/ ]/ ,/ 检测/ 运行/ 时以/ ret/ 结尾/ 的/ 短/ 指令/ 序列/ 是否/ 频繁/ 出现/ ;/ (/ 2/ )/ ROPdefender/ [/ 6/ ]/ ,/ 检测/ 运行/ 时/ call/ 指令/ 与/ ret/ 指令/ 是否/ 一一对应/ ;/ (/ 3/ )/ Return/ -/ lessCompiler/ [/ 7/ ]/ ,/ 使用/ 消除/ ret/ 指令/ 的/ 编译器/ ./ 为了/ 方便/ 比较/ ,/ 我们/ 也/ 测试/ 了/ 传统/ 的/ ROP/ 攻击/ 、/ Tyler/ 提出/ 的/ JOP/ 攻击/ 对/ 这/ 3/ 种/ 防御/ 技术/ 的/ 效力/ ./ 从表/ 3/ 可以/ 看出/ ,/ 传统/ 的/ ROP/ 技术/ 使用/ 以/ ret/ 结尾/ 的/ gadget/ 片段/ ,/ 这种/ 明显/ 的/ 特征/ 可以/ 被/ 这/ 3/ 种/ 技术/ 检测/ 到/ ./ Tyler/ 的/ JOP/ 技术/ [/ 9/ ]/ 库/ ,/ 实验/ 环境/ 是/ 2.6/ ./ 15/ 版本/ 内核/ 的/ Fedora5/ 系统/ ./ 22/ 个/ shellcode/ 中/ 包括/ 数据传输/ 、/ 算术/ 运算/ 、/ 系统/ 调用/ 和/ 条件/ 转移/ 等/ 基本/ 语句/ ./ 实验/ 结果/ 如表/ 2/ 所示/ ./ shellcode/ 大小/ (/ bytes/ )/ 消除/ 了/ ret/ 指令/ 带来/ 的/ 负面影响/ ,/ 可以/ 有效/ 绕过/ DROP/ 和/ Return/ -/ lessCompiler/ 的/ 防御/ 方法/ ,/ 但是/ 它/ 所/ 使用/ 的/ call/ 指令/ 并/ 没有/ 相应/ 的/ ret/ 指令/ ,/ 基于/ 这种/ 特征/ 的/ ROPdefender/ 技术/ 仍然/ 可以/ 检测/ 到/ 这类/ 攻击/ ./ BIOP/ 技术/ 避免/ 使用/ 连续/ 的/ ret/ 指令/ ,/ 同时/ 使/ call/ 指令/ 与/ ret/ 指令/ 一一对应/ ,/ 从而/ 可以/ 有效/ 的/ 绕开/ 所有/ 这/ 3/ 种/ 防御/ 技术/ ./ ROPshellcode/ 有效/ 有效/ Tyler/ ’/ sJOP/ 失效/ 有效/ BIOP/ 失效/ 失效/ 5/ 相关/ 工作/ ROP/ 技术/ 是/ 一种/ 全新/ 的/ 代码/ 复用/ 攻击/ 方法/ ,/ 它/ 被/ 认为/ 是/ 未来/ 主流/ 攻击/ 方法/ 之一/ ./ ROP/ 攻击/ 技术/ 和/ 防御/ 技术/ 近几年/ 发展/ 迅速/ ,/ 我们/ 在/ 此章/ 介绍/ ROP/ 的/ 发展/ 背景/ 和/ 相关/ 工作/ ,/ 使/ 读者/ 对/ ROP/ 的/ 发展/ 有/ 更/ 清楚/ 的/ 了解/ ./ ①/ milw0rm/ :/ http/ :/ // // www/ ./ milw0rm/ ./ com/ // shellcode/ // linux/ // Page125/ ./ 1Return/ -/ to/ -/ libc/ 攻击/ 为了/ 解决/ 向/ W/ / X/ 或/ DEP/ 保护/ 的/ 内存/ 页/ 注入/ 恶意代码/ 失效/ 的/ 问题/ ,/ 攻击者/ 尝试/ 复用/ 系统/ 已经/ 存在/ 的/ 函数/ 级/ 代码/ ,/ return/ -/ to/ -/ libc/ [/ 1/ ]/ 是/ 一种/ 典型/ 的/ 代码/ 复用/ 攻击/ ,/ 它/ 通过/ 劫持/ 控制流/ ,/ 跳转/ 到/ C语言/ 函数库/ libc/ ,/ 复用/ libc/ 中/ 已有/ 的/ 函数/ ,/ 可以/ 有效/ 的/ 绕开/ W/ / X/ 和/ DEP/ 技术/ ./ 然而/ ,/ renturn/ -/ to/ -/ libc/ 攻击/ 存在/ 以下/ 缺陷/ :/ (/ 1/ )/ 只能/ 顺序调用/ 函数/ ,/ 不能/ 实现/ 图灵/ 完备/ 的/ 行为/ ,/ 如/ 分支/ 操作/ 、/ 循环/ 操作/ 等/ ;/ (/ 2/ )/ 依赖于/ 系统/ 中/ 存在/ 的/ 库函数/ ,/ 移除/ 或/ 修改/ libc/ 中/ 的/ 特定/ 函数/ 将/ 严重/ 限制/ 攻击能力/ ./ 5.2/ Return/ -/ OrientedProgramming/ 由于/ return/ -/ to/ -/ libc/ 攻击/ 具有/ 一定/ 局限性/ ,/ Shacham/ [/ 2/ ]/ 于/ 2007/ 年/ 提出/ 一种/ 新型/ 的/ 代码/ 复用技术/ —/ —/ —/ 返回/ 导向/ 编程/ 攻击/ ,/ 将/ 复用/ 的/ 代码/ 粒度/ 从/ return/ -/ to/ -/ libc/ 的/ 函数/ 级别/ 缩小/ 到/ 指令/ 序列/ ,/ 每个/ 指令/ 序列/ 都/ 是/ 一个/ 以/ ret/ 指令/ 结尾/ 的/ 指令/ 序列/ ,/ 通过/ 在/ 栈/ 内/ 设置/ 下/ 一个/ 要/ 跳转/ 的/ 指令/ 序列/ 地址/ ,/ 攻击者/ 可以/ 将/ 多个/ 指令/ 序列/ 串联/ 起来/ 以/ 实现/ 恶意/ 语义/ ./ Schacham/ 认为/ libc/ 中/ 的/ 指令/ 序列/ 集合/ 是/ 图灵/ 完备/ 的/ ,/ 可以/ 构造/ 任意/ 功能/ 的/ 攻击/ ./ 然而/ ,/ ROP/ 使用/ 以/ ret/ 指令/ 结尾/ 的/ 指令/ 序列/ 构造/ 攻击/ ,/ 与/ 正常/ 程序/ 相比/ ,/ ROP/ 具有/ 以下/ 特征/ :/ (/ 1/ )/ ret/ 指令/ 并/ 没有/ 相应/ 的/ call/ 指令/ 与其/ 对应/ ;/ (/ 2/ )/ 频繁/ 使用/ 以/ ret/ 指令/ 结尾/ 的/ 短/ 指令/ 序列/ ,/ 这/ 在/ 正常/ 程序/ 流中/ 非常/ 少见/ ./ 5.3/ Return/ -/ OrientedProgramming/ 防御/ 技术/ 针对/ ROP/ 的/ 特点/ ,/ 防御/ 技术/ 主要/ 可以/ 分为/ 以下/ 3/ 类/ :/ (/ 1/ )/ ROP/ 中/ ret/ 指令/ 并/ 没有/ 相应/ 的/ call/ 指令/ 与其/ 匹配/ ,/ Francillon/ 等/ 人/ [/ 3/ ]/ 使用/ 一个/ 嵌入式/ 的/ 微处理器/ 保护/ call/ // ret/ 栈/ 不/ 被/ 任意/ 数据/ 改写/ ,/ ROPdefender/ [/ 5/ ]/ 使用/ 影子/ 内存/ 来/ 检测/ 对/ 返回值/ 地址/ 的/ 修改/ ;/ (/ 2/ )/ ROP/ 指令/ 序列/ 一般/ 只有/ 两三个/ 指令/ 长度/ ,/ 每个/ 指令/ 序列/ 都/ 以/ ret/ 指令/ 结尾/ ,/ Chen/ 等/ 人/ [/ 6/ ]/ 和/ Davi/ 等/ 人/ [/ 4/ ]/ 针对/ ROP/ 的/ 这种/ 特性/ 进行/ 检测/ ,/ 当/ 系统/ 频繁/ 的/ 执行/ 含/ ret/ 指令/ 的/ 短/ 指令/ 序列/ 时/ ,/ 则/ 认为/ 系统/ 受到/ ROP/ 攻击/ ;/ (/ 3/ )/ 消除/ 库中/ ret/ 指令/ 可以/ 有效/ 消除/ ROP/ 攻击/ 的/ 构造/ 基础/ ./ 如/ Li/ 等/ 人/ [/ 7/ ]/ 设计/ 了/ 一种/ 编译器/ 可以/ 在/ 程序/ 编译/ 时候/ 消除/ ret/ 指令/ ./ 5.4/ ROP/ 技术/ 演化/ 为了/ 克服/ ROP/ 的/ 缺陷/ ,/ 攻击者/ 试图/ 改进/ ROP/ 攻击/ ./ Checkoway/ 等/ 人/ [/ 8/ ,/ 10/ ]/ 提出/ 使用/ 含/ pop/ -/ jmp/ 指令/ 序列/ 替换/ 原来/ 以/ ret/ 指令/ 结尾/ 的/ 指令/ 序列/ ./ 但/ 这种/ 方法/ 使用/ 类似/ ret/ 功能/ 的/ pop/ -/ jmp/ 指令/ (/ 如/ popebx/ ,/ …/ ,/ jmp/ [/ ebx/ ]/ )/ ./ 虽然/ 这种/ 改进/ 可以/ 使/ 现有/ ROP/ 防御/ 技术/ 失效/ ,/ 但是/ 没有/ 从/ 本质/ 上/ 解决/ ROP/ 技术/ 的/ 缺陷/ ./ 因为/ 虽然/ 避免/ 使用/ ret/ 指令/ ,/ 但是/ 引入/ 的/ pop/ -/ jmp/ 指令/ 同样/ 具有/ 明显/ 的/ 特征/ ,/ 通过/ 对栈/ 的/ 保护/ 或/ 对/ ROP/ 动态/ 检测/ 技术/ 进行/ 修改/ 可以/ 很/ 容易/ 检测/ 此类/ 攻击/ ./ Bletsch/ 等/ 人/ [/ 9/ ]/ 提出/ Jump/ -/ OrientedProgram/ -/ ming/ (/ JOP/ )/ 消除/ 对/ ret/ 指令/ 的/ 依赖/ ,/ 但/ 这种/ 技术/ 存在/ 缺陷/ ./ 首先/ 他们/ 使用/ 含/ call/ 指令/ 的/ 指令/ 序列/ ,/ 但/ 并/ 没有/ 相应/ ret/ 指令/ 与其/ 匹配/ ,/ 使用/ 栈/ 保护/ 技术/ 可以/ 防御/ 这/ 类/ 攻击/ [/ 3/ ,/ 8/ ]/ ;/ 其次/ ,/ JOP/ 的/ 构造/ 具有/ 寄存器/ 依赖性/ ,/ 在/ 某个/ 指令/ 序列/ 中/ 使用/ 寄存器/ 会/ 影响/ 到/ 其他/ 指令/ 序列/ 对/ 该/ 寄存器/ 的/ 使用/ ,/ Bletsch/ 等/ 人/ 并/ 没有/ 对/ 这个/ 问题/ 进行/ 讨论/ ,/ 而且/ 他们/ 提出/ 的/ 调度/ 指令/ 序列/ 加剧/ 了/ 这种/ 依赖性/ ,/ 使/ JOP/ 功能/ 受到限制/ ./ 事实上/ ,/ 我们/ 发现/ ,/ 在/ Bletsch/ 等/ 人/ 使用/ 了/ addebp/ ,/ edi/ ;/ jmp/ [/ ebp/ -/ 0x39/ ]/ 这个/ 调度/ 指令/ 序列/ 以后/ ,/ 将/ 无法/ 在/ 以后/ 的/ gadget/ 中/ 更改/ ebp/ 和/ edi/ 这/ 两个/ 寄存器/ 值/ ,/ 导致/ JOP/ 的/ 构造/ 能力/ 受到/ 严重/ 限制/ ./ 我们/ 在/ 第/ 4/ 节中/ 讨论/ 了/ 这个/ 问题/ ,/ 同时/ 我们/ 也/ 提出/ 如何/ 消除/ 寄存器/ 依赖性/ ,/ 可以/ 构造/ 能力/ 更/ 强大/ 的/ 攻击/ ./ 再者/ ,/ 调度/ 指令/ 序列/ 的/ 使用/ 使/ 程序/ 流/ 与/ 正常/ 程序/ 流/ 相比/ ,/ 具有/ 明显/ 的/ 特征/ ,/ 通过/ 动态/ 检测/ 很/ 容易/ 发现/ 此类/ 攻击/ ./ 最后/ ,/ 调度/ 指令/ 序列/ 是/ 一种/ 理想/ 的/ 指令/ 序列/ ,/ 现实/ 的/ libc/ 库中/ 很/ 难/ 找到/ ,/ 从而/ 使/ JOP/ 的/ 攻击/ 取决于/ 现有/ 的/ 库/ 中/ 是否/ 可以/ 找到/ 有效/ 的/ 调度/ 指令/ 序列/ ./ 如上所述/ ,/ 已有/ 的/ ROP/ 及/ ROP/ 改进/ 技术/ 都/ 存在/ 明显/ 特征/ ,/ 易/ 被/ 检测/ ,/ 不利于/ 实际/ 的/ 应用/ ./ 本文/ 提出/ 的/ BIOP/ 技术/ 消除/ 了/ 原有/ 的/ ROP/ 及/ ROP/ 改进/ 技术/ 的/ 特征/ ,/ 隐蔽性/ 更强/ ./ 同时/ 我们/ 考虑/ 了/ 寄存器/ 对/ 构造/ 攻击能力/ 的/ 影响/ ,/ 并/ 分析/ 解决/ 了/ 构造/ 时/ 寄存器/ 副作用/ 问题/ ,/ 为/ 我们/ 自动化/ 构造/ 攻击/ 奠定/ 理论/ 基础/ ./ 我们/ 设计/ 了/ 一个/ 自动化/ 构造/ BIOP/ 的/ 工具/ ,/ 使用/ 我们/ 的/ 工具/ 可以/ 大规模/ 有效/ 的/ 构造/ BIOPshellcode/ ./ 6/ 结束语/ 本文/ 提出/ 了/ 一类/ 新型/ ROP/ 攻击/ 技术/ BIOP/ ,/ 它/ 通过/ 复用/ 现有/ 库/ 和/ 可执行文件/ 中含/ jmp/ 指令/ 和/ call/ 指令/ 的/ 指令/ 序列/ ,/ 从而/ 有效/ 绕开/ 现有/ 的/ ROP/ 防御/ 技术/ ./ 它/ 不仅/ 消除/ 了/ ROP/ 中/ ret/ 和/ call/ 非/ 一一对应/ 的/ 缺陷/ ,/ 且/ 不/ 依赖于/ 对栈/ 的/ 控制/ ./ 我们/ 提出/ 了/ 一个/ 指令/ 序列/ 快速/ 搜索算法/ ,/ 并且/ 分析/ 了/ 利用/ 这些/ 指令/ 序列/ 自动/ 构造/ 攻击/ 时/ 的/ 难点/ 和/ 挑战/ ,/ 针对/ 这些/ 难点/ 和/ 挑战/ 我们/ 提出/ 解决/ 方法/ ./ 同时/ 我们/ 设计/ 了/ 一个/ 自动化/ 构造/ 工具/ ./ 通过/ 自动化/ 工具/ ,/ 我们/ 能/ 方便/ 构造/ 各种/ 语义/ 的/ shellcode/ ./ 实验/ 结果表明/ ,/ BIOP/ 具有/ 与/ ROPPage13/ 相同/ 的/ 能力/ ,/ 并/ 可以/ 有效/ 避开/ 当前/ 的/ ROP/ 检测/ 技术/ ./ 我们/ 相信/ 基于/ BIOP/ 的/ 攻击/ 将会/ 成为/ 系统安全/ 的/ 新/ 威胁/ ./ 

