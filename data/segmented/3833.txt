Page1/ 针对/ 组/ 相联/ 缓存/ 的/ 无效/ 缓存/ 路/ 访问/ 混合/ 过滤/ 机制/ 研究/ 范灵俊/ 1/ )/ ,/ 2/ )/ 徐远超/ 1/ )/ ,/ 5/ )/ 施巍松/ 3/ )/ 范东/ 睿/ 1/ )/ 娄杰/ 4/ )/ 1/ )/ (/ 中国科学院计算技术研究所/ 计算机/ 体系结构/ 国家/ 重点/ 实验室/ 北京/ 100190/ )/ 2/ )/ (/ 中国科学院/ 大学/ 北京/ 100049/ )/ 3/ )/ (/ 韦恩/ 州立大学/ 计算机科学/ 系/ 底特律/ 美国/ 48202/ )/ 4/ )/ (/ 英特尔公司/ 北京/ 100190/ )/ 5/ )/ (/ 首都师范大学/ 信息/ 工程学院/ 北京/ 100048/ )/ 摘要/ 近年来/ ,/ 功耗/ 成为/ 处理器/ 设计/ 领域/ 的/ 关键问题/ 之一/ ./ 传统/ 应对/ 功耗/ 的/ 方法/ 如/ DVFS/ (/ DynamicVoltageFrequencyScaling/ )/ 目前/ 遭遇/ 了/ 收益/ 递减/ 律/ ./ 随着/ 多核/ // 众核/ 处理器/ 的/ 普及化/ ,/ 片上/ 缓存/ 占有/ 了/ 越来越/ 多/ 的/ CPU/ 芯片/ 面积/ 和/ 功耗/ ./ 针对/ 降低功耗/ 的/ 问题/ ,/ 文中/ 提出/ 了/ 通过/ 过滤/ 不必要/ 的/ 缓存/ 路/ 访问/ 来/ 降低/ 缓存/ 动态/ 功耗/ 的/ 方法/ ./ 该/ 方法/ 包括/ 采用/ 无效/ 访问/ 过滤器/ (/ InvalidFilter/ )/ 来/ 消除/ 对/ 含/ 无效/ 数据/ 块/ 的/ 缓存/ 路/ 的/ 访问/ ;/ 采用/ 指令/ 数据/ 访问/ 过滤器/ (/ I/ // DFilter/ )/ 来/ 消除/ 对/ 与/ 访问/ 类型/ (/ 指令/ 或/ 数据/ )/ 不/ 匹配/ 的/ 数据/ 块/ 所在/ 的/ 缓存/ 路/ 的/ 访问/ ;/ 以及/ 采用/ tag/ 低位/ 过滤器/ (/ Tag/ -/ 2Filter/ )/ 来/ 消除/ 对/ tag/ 低位/ 不/ 匹配/ 的/ 数据/ 块/ 所在/ 的/ 缓存/ 路/ 的/ 访问/ ./ 文中/ 提出/ 将/ 以上/ 3/ 种/ 方法/ 合并/ ,/ 称为/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ ,/ 以期/ 取得/ 更好/ 的/ 效果/ ./ 通过/ 分析/ 和/ 实验/ 验证/ 了/ 3/ 种/ 方法/ 的/ 有效性/ 和/ 互补性/ ./ 同时/ ,/ 实验/ 也/ 表明/ ,/ 与/ Invalid/ +/ I/ // DFilter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 在/ 64KB4/ 路组/ 相联/ 缓存/ 上/ 可以/ 取得/ 19.6/ %/ ~/ 47.8/ %/ (/ 平均/ 34.3/ %/ )/ 的/ 效果/ 提升/ ,/ 在/ 128KB8/ 路组/ 相联/ 缓存/ 上/ 可以/ 取得/ 19.6/ %/ ~/ 55.2/ %/ (/ 平均/ 39.2/ %/ )/ 的/ 效果/ 提升/ ;/ 与/ Invalid/ +/ Tag/ -/ 2Filter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 在/ 64KB4/ 路组/ 相联/ 缓存/ 上/ 可以/ 取得/ 16.1/ %/ ~/ 27.7/ %/ (/ 平均/ 16.6/ %/ )/ 的/ 效果/ 提升/ ,/ 在/ 128KB8/ 路组/ 相联/ 缓存/ 上/ 可以/ 取得/ 6.9/ %/ ~/ 44.4/ %/ (/ 平均/ 25.0/ %/ )/ 的/ 效果/ 提升/ ./ 关键/ 词组/ 相联/ 缓存/ ;/ 动态/ 功耗/ ;/ 无效/ 访问/ 过滤器/ ;/ 访问/ 类型/ 过滤器/ ;/ tag/ 低位/ 过滤器/ 1/ 引言/ 近年来/ ,/ 功耗/ 是/ 处理器/ 设计/ 领域/ 被/ 关注/ 的/ 热点问题/ 之一/ ./ DVFS/ (/ DynamicVoltageandFrequencyScaling/ )/ 技术/ 是/ 最常/ 被/ 采用/ 的/ 节省/ CPU/ 功耗/ 的/ 技术/ ,/ 但/ 通过/ DVFS/ 降低功耗/ 目前/ 正/ 遭遇/ 收益/ 递减/ 律/ [/ 1/ ]/ ./ 此外/ ,/ 文献/ [/ 2/ ]/ 的/ 研究/ 也/ 表明/ ,/ 随着/ 多核/ 处理器/ 核数/ 的/ 不断/ 上升/ ,/ 将/ 带来/ 芯片/ 的/ 功耗/ 受限/ ,/ 很快/ 会/ 遇到/ darksilicon/ 问题/ ./ 即/ 所有/ 处理器/ 核都/ 工作/ 起来/ 将/ 导致/ 芯片/ 的/ 功耗/ 不可/ 忍受/ ./ 因此/ ,/ 需要/ 找到/ 一种/ 新/ 的/ 有效/ 并且/ 通用/ 的/ 降低/ CPU/ 功耗/ 的/ 方法/ ./ 得益于/ 程序/ 访存/ 的/ 局部性/ ,/ 从/ 1980/ 年代/ 开始/ ,/ 缓存/ 在/ 填补/ 处理器/ 速度/ 和/ 内存/ 速度/ 之间/ 的/ 鸿沟/ 中/ 扮演/ 了/ 重要/ 的/ 角色/ ,/ 并/ 带来/ 了/ 处理器/ 性能/ 的/ 不断/ 提升/ ./ 因为/ 大多数/ 应用程序/ 都/ 表现/ 出/ 了/ 良好/ 的/ 数据/ 访问/ 的/ 空间/ // 时间/ 局部性/ ,/ 对于/ 一个/ 特定/ 的/ 处理器/ 结构/ ,/ 越大/ 的/ 缓存/ 往往/ 预示/ 着/ 更好/ 的/ 程序/ 性能/ ./ 在/ 现代/ 处理器/ 设计/ 中/ ,/ 采用/ 多种多样/ 的/ 缓存/ 结构/ 和/ 缓存/ 层次/ ,/ 来/ 应对/ “/ 存储/ 墙/ [/ 3/ ]/ ”/ 问题/ ./ 组/ 相联/ 缓存/ 是/ 最/ 基本/ 的/ 结构/ 之一/ ,/ 由于/ 其能/ 很/ 好/ 地/ 降低/ 冲突/ 失效/ ,/ 从而/ 得到/ 了/ 最为/ 广泛/ 的/ 应用/ ./ 此外/ ,/ 在/ 多/ 核/ // 众核/ 处理器/ 领域/ ,/ 集成/ 更/ 多/ 的/ 处理器/ 核/ 必然/ 需要/ 更/ 多/ 的/ 片/ 上/ 缓存/ 来/ 供数/ ,/ 以/ 保证/ 可以/ 带来/ 不断/ 的/ 性能/ 提高/ ./ 因此/ ,/ 片上/ 缓存/ 占用/ 了/ 越来越/ 多/ 的/ 芯片/ 面积/ [/ 4/ -/ 5/ ]/ ./ 然而/ ,/ 更大/ 的/ 缓存/ 也/ 带来/ 了/ 更/ 多/ 的/ 功耗/ ,/ 有/ 的/ 甚至/ 达到/ 了/ 处理器/ 总/ 功耗/ 的/ 40/ %/ ~/ 50/ %/ [/ 6/ ]/ ./ 一直/ 以来/ ,/ 降低/ 缓存/ 的/ 功耗/ 引起/ 了/ 国内外/ 研究者/ 的/ 高度/ 关注/ [/ 7/ -/ 17/ ]/ ./ 然而/ ,/ 大部分/ 研究/ 工作/ 都/ 有/ 其/ 不足/ ,/ 它们/ 或者/ 需要/ 软件/ 的/ 支持/ ,/ 或者/ 带来/ 了/ 性能/ 损失/ ,/ 或者/ 引入/ 了/ 太/ 多/ 的/ 硬件/ 开销/ ,/ 并且/ 提高/ 了/ 硬件/ 设计/ 复杂度/ ,/ 而/ 不/ 容易/ 具体/ 实现/ ./ 本文/ 中/ ,/ 为了/ 降低/ CPU/ 的/ 动态/ 功耗/ ,/ 提出/ 了/ 不必要/ 缓存/ 路/ 访问/ 的/ 混合/ 过滤/ 方法/ ,/ 包括/ 无效/ 访问/ 过滤器/ (/ InvalidFilter/ )/ 、/ 指令/ 数据/ 访问/ 类型/ 匹配/ 过滤器/ (/ Instruction/ // DataFilter/ ,/ I/ // DFilter/ )/ 和/ Tag/ 低位/ 匹配/ 过滤器/ (/ Tag/ -/ 2Filter/ )/ ./ 它们/ 都/ 基于/ 组/ 相联/ 缓存/ 结构/ ,/ 混合/ 后/ 的/ 方法/ 可以/ 在/ 指令/ 数据共享/ 的/ 缓存/ 中/ 得到/ 应用/ ./ 针对/ 每次/ 访问/ ,/ InvalidFilter/ 可以/ 提前/ 检查/ 含有/ 无效/ 数据/ 块/ 的/ 缓存/ 路/ ,/ I/ // DFilter/ 可以/ 提前/ 检查/ 与/ 本次/ 指令/ 或/ 数据/ 访问/ 类型/ 不/ 匹配/ 的/ 缓存/ 路/ ,/ Tag/ -/ 2Filter/ 可以/ 提前/ 检查/ Tag/ 最低/ 2/ 位/ 不/ 匹配/ 的/ 缓存/ 路/ ./ 符合/ 以上/ 3/ 种/ 情况/ ,/ 被/ 以上/ 过滤器/ 提前/ 检测/ 出/ 的/ 缓存/ 路/ ,/ 在/ 接下来/ 的/ 操作/ 中将/ 不/ 被/ 使/ 能/ (/ disabled/ )/ ./ 以上/ 方法/ 由于/ 消除/ 了/ Cache/ 结构/ 中/ 不必要/ 的/ 活跃/ 行为/ (/ activities/ )/ ,/ 从而/ 将/ 有效/ 降低/ CPU/ 的/ 动态/ 功耗/ ./ 实验/ 表明/ ,/ 对于/ 不同/ 的/ 应用程序/ ,/ 采用/ Invalid/ +/ I/ // DFilter/ ,/ 在/ 64KB/ -/ 4way/ 组/ 相联/ Cache/ 结构/ 上/ 可以/ 消除/ 36.65/ %/ ~/ 65.88/ %/ 的/ 无效/ 路/ 访问/ ,/ 在/ 128KB/ -/ 8way/ 组/ 相联/ Cache/ 结构/ 上/ 消除/ 无效/ 路/ 访问/ 达到/ 了/ 46.49/ %/ ~/ 82.94/ %/ ;/ 而/ 采用/ Invalid/ +/ Tag/ -/ 2Filter/ ,/ 在/ 64KB/ -/ 4way/ 组/ 相联/ Cache/ 结构/ 上/ 59.65/ %/ ~/ 69.32/ %/ 的/ 无效/ 路/ 访问/ 可以/ 被/ 消除/ ,/ 上述/ 结果/ 在/ Page3128KB/ -/ 8way/ 组/ 相联/ Cache/ 结构/ 上/ 测试/ 时/ 也/ 提高/ 到/ 了/ 67.86/ %/ ~/ 84.66/ %/ ./ 此外/ ,/ 我们/ 提出/ 的/ 合并/ 方法/ (/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ )/ 的/ 实验/ 效果/ 比/ 以上/ 两者/ (/ Invalid/ +/ I/ // DFilter/ ,/ Invalid/ +/ Tag/ -/ 2Filter/ )/ 都/ 好/ ,/ 在/ 第/ 4/ 节/ 做/ 详细/ 介绍/ ./ 同时/ ,/ 采用/ CACTI6/ ./ 0/ 模拟器/ 进行/ 的/ 测试表明/ ,/ 实际/ 应用/ 程序运行/ 在/ 以上/ 64KB/ -/ 4way/ 和/ 128KB/ -/ 8wayCache/ 结构/ 上/ 也/ 获得/ 了/ 同等/ 的/ 能耗/ 降低/ ./ 本文/ 第/ 2/ 节/ 讨论/ 相关/ 工作/ ;/ 第/ 3/ 节/ 介绍/ 本文/ 方法/ 和/ 无效/ 缓存/ 路/ 访问/ 过滤/ 机制/ 的/ 逻辑/ 结构/ 以及/ 带有/ 无效/ 缓存/ 路/ 访问/ 过滤/ 机制/ 的/ 缓存/ 访问/ 流程/ ;/ 第/ 4/ 节/ 分析/ 和/ 验证/ 方法/ 的/ 互补性/ ,/ 并/ 给出/ 具体/ 的/ 实验/ 结果/ ;/ 第/ 5/ 节对/ 全文/ 进行/ 总结/ ./ 2/ 相关/ 工作/ 作为/ 处理器/ 设计/ 领域/ 的/ 研究/ 热点/ 之一/ ,/ 降低/ 缓存/ 的/ 功耗/ 近年来/ 得到/ 了/ 学术界/ 持续/ 的/ 关注/ [/ 7/ -/ 17/ ]/ ./ 以下/ ,/ 将/ 讨论/ 和/ 比较/ 一些/ 常见/ 的/ 通过/ 减少/ 缓存/ 中/ 不必要/ 行为/ 来/ 降低/ 缓存/ 功耗/ 的/ 方法/ ./ 分段/ 访问/ 缓存/ (/ PhasedCaches/ )/ [/ 7/ ]/ ,/ 如图/ 1/ 所示/ ,/ 先/ 访问/ tag/ ,/ 再/ 访问/ 数据/ ./ 访问/ 数据/ 时/ ,/ 只/ 访问/ 命中/ 的/ 那/ 一路/ ./ 此/ 方法/ 的/ 缺点/ 是/ ,/ 每/ 一次/ 缓存/ 访问/ 都/ 多/ 了/ 一/ 拍/ ,/ 增加/ 了/ 访存/ 延迟/ ./ 以/ 4/ 路组/ 相联/ 缓存/ 为例/ ,/ 命中/ 的/ 情况/ 下/ ,/ 每次/ 访问/ 的/ 动态/ 功耗/ 为/ 4T/ +/ 1D/ (/ 4/ 路/ tag/ 访问/ 和/ 1/ 路/ data/ 访问/ )/ ./ 如图/ 2/ 所示/ ,/ 路/ 预测/ 缓存/ (/ Way/ -/ predictionCache/ )/ [/ 8/ ]/ 提前/ 预测/ 可能/ 匹配/ 的/ 一路/ ,/ 然后/ 只/ 访问/ 这/ 一路/ ./ 每次/ 访问/ 的/ 动态/ 功耗/ 为/ 1T/ +/ 1D/ ,/ 即/ 1/ 路/ tag/ 访问/ 和/ 1/ 路/ data/ 访问/ ./ 但是/ ,/ 当/ 预测/ 错误/ 时/ ,/ 访问/ 要/ 再/ 发生/ 一次/ ./ 文献/ [/ 9/ ]/ 提出/ 了/ 采用/ 指令/ // 数据/ 过滤器/ 来/ 减少/ 缓存/ 中/ 缓存/ 路/ 的/ 访问/ 操作/ 从而/ 降低功耗/ 的/ 方法/ ./ 采用/ 指令/ // 数据/ 过滤器/ ,/ 每次/ 访问/ 的/ 功耗/ 为/ hT/ +/ hD/ ,/ 其中/ h/ 是/ 与/ 本次/ 访问/ 类型/ (/ 指令/ 或/ 数据/ )/ 符合/ 的/ 缓存/ 块/ 数量/ ./ 此/ 方法/ 单独/ 作用/ 效果/ 有限/ ,/ 因此/ ,/ 本文/ 提出/ 的/ 混合/ 过滤器/ 将/ 此/ 方法/ 作为/ 其中/ 的/ 一部分/ ./ 在/ 文献/ [/ 10/ ]/ 中/ ,/ Keramidas/ 等/ 利用/ cachedecay/ 来/ 降低/ 组/ 相联/ 缓存/ 的/ 动态/ 功耗/ ,/ 称作/ Way/ -/ selectionCache/ ./ 如图/ 3/ 所示/ ./ Cachedecay/ 技术/ 最初/ 由/ 文献/ [/ 11/ ]/ 提出/ ,/ 用来/ 降低/ 静态/ 功耗/ ./ 方法/ 是/ ,/ 当/ 一个/ 缓存/ 块/ 里/ 的/ 数据/ 不再/ 被/ 用到/ 时/ ,/ 将/ 其/ 所在/ 的/ 缓存/ 路/ 关掉/ (/ poweroff/ )/ ./ 此/ 缓存/ 结构/ ,/ 或者/ 利用/ decaybits/ ,/ 或者/ 利用/ decaybloomfilters/ 来/ 追踪/ 和/ 判断/ 一个/ 缓存/ 块/ 是/ 处于/ live/ 状态/ ,/ 还是/ 处于/ dead/ 状态/ ,/ 然后/ 当/ 访问/ 发生/ 时/ ,/ 只/ 访问/ 处于/ live/ 状态/ 的/ 缓存/ 块/ ./ 然而/ ,/ 用/ decaybits/ 的/ 方法/ 会/ 带来/ 低/ 的/ 准确度/ ,/ 用/ decaybloomfilters/ 会/ 引入/ 过多/ 的/ 硬件/ 开销/ ./ 在/ Way/ -/ selectionPage4Cache/ 中/ ,/ 每次/ 访问/ 的/ 动态/ 功耗/ 为/ yT/ +/ yD/ ,/ 其中/ ,/ y/ 是/ 所/ 访问/ 的/ 缓存/ 组中/ live/ 的/ 缓存/ 块/ 数量/ ./ Zhang/ 等/ 人/ 在/ 文献/ [/ 12/ ]/ 中/ 提出/ 了/ Way/ -/ haltingCache/ ,/ 一种/ 4/ 路组/ 相联/ 缓存/ ,/ 将/ 每/ 一路/ tag/ 位/ 的/ 最低/ 4/ 位/ 存在/ 一个/ 全/ 相联/ 的/ 缓存/ 中/ ,/ 称为/ halttag/ 阵列/ ./ Halttag/ 阵列/ 提前/ 比较/ 最低/ 4/ 位来/ 预先/ 检查/ 哪些/ 路/ 是/ 不会/ 被/ 匹配/ 的/ ,/ 在/ 随后/ 的/ 访问/ 中/ ,/ 这些/ 路/ 被/ 屏蔽掉/ ,/ 进而/ 节省/ 了/ 访问/ 时/ 产生/ 的/ 功耗/ ./ 在/ Way/ -/ haltingCache/ 中/ ,/ 每次/ 访问/ 的/ 动态/ 功耗/ 是/ zT/ +/ zD/ ,/ 其中/ z/ 取决于/ 可能/ 匹配/ 的/ 缓存/ 路/ 的/ 数量/ ./ 表/ 1/ 中/ ,/ 将/ 现有/ 的/ 一些/ 低功耗/ 缓存/ 结构/ 进行/ 总结/ 和/ 对比/ ./ 对于/ 本文/ 提出/ 的/ 采用/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 方法/ 的/ Way/ -/ filteringCache/ ,/ 每次/ 访问/ 的/ 动态/ 功耗/ 为/ xT/ +/ xD/ ,/ 其中/ x/ 为/ 数据/ 有效/ 、/ 访问/ 类型/ 匹配/ 并且/ tag/ 低/ 2/ 位/ 匹配/ 的/ 缓存/ 块/ 数量/ ./ 缓存/ 结构/ 访问/ 对象/ 每次/ 访问/ Way/ -/ predictionpredictedline1T/ +/ 1DmorewrongWay/ -/ selectionlivelinesyT/ +/ yDmorewrongPhasedCachehitline4T/ +/ 1DlittleonemoreWay/ -/ haltingmaymatchI/ // DFilteringI/ // DmatchlineshT/ +/ hDlittleonemoreWay/ -/ filtering3/ 本文/ 方法/ 得益于/ 程序/ 访存/ 的/ 局部性/ 原理/ ,/ 片上/ 缓存/ 在/ 现代/ 处理器/ 性能/ 的/ 提高/ 中/ 扮演/ 了/ 重要/ 的/ 角色/ ./ 组/ 相联/ 缓存/ 结构/ 由于/ 可以/ 有效/ 减少/ 冲突/ 缺失/ 从而/ 得到/ 了/ 最为/ 广泛/ 的/ 使用/ ./ 在/ 对/ 组/ 相联/ 缓存/ 的/ 每/ 一次/ 访问/ 中/ ,/ 虽然/ 访问/ 一个/ 缓存/ 组中/ 的/ 所有/ 缓存/ 块/ ,/ 但/ 最/ 多/ 只有/ 一路/ 缓存/ 块/ 是/ 命中/ 的/ ./ 所以/ ,/ 如果/ 我们/ 能够/ 事先/ 消除/ 不必要/ 的/ 缓存/ 路/ 访问/ ,/ 则/ 由/ 读/ 操作/ 产生/ 的/ 动态/ 功耗/ 必将/ 被/ 有效/ 降低/ ./ 缓存/ 的/ 功耗/ 来源/ 有/ 两/ 部分/ 组成/ :/ 一是/ 电路状态/ 稳定/ 时/ 的/ 静态/ 功耗/ ;/ 另/ 一/ 是/ 电路/ 的/ 翻转/ 带来/ 的/ 动态/ 功耗/ ./ 读/ 操作/ 和/ 写/ 操作/ 是/ 缓存/ 结构/ 中/ 两种/ 最/ 基本/ 的/ 操作/ ,/ 文献/ [/ 18/ ]/ 指出/ ,/ 在/ 程序/ 访存/ 序列/ 中/ ,/ 读/ 操作/ 的/ 数量/ 大概/ 是/ 写/ 操作/ 的/ 两倍/ ./ 此外/ ,/ 每次/ 写/ 操作/ 发生/ 时/ ,/ 也/ 伴随/ 有/ 一次/ 读/ 操作/ ,/ 以/ 检查/ 要/ 写/ 的/ 数据/ 块/ 是否/ 在/ 缓存/ 中/ 命中/ ./ 由此可见/ ,/ 读/ 操作/ 在/ 动态/ 功耗/ 的/ 产生/ 中/ 占有/ 了/ 很大/ 的/ 比例/ ./ 3.1/ 不必要/ 的/ 缓存/ 路/ 访问/ 对组/ 相联/ 缓存/ 的/ 每次/ 访问/ 产生/ 的/ 能耗/ (/ Ecache/ )/ 可以/ 由/ 文献/ [/ 8/ ]/ 给出/ 的/ 公式/ 进行/ 预估/ ./ 如式/ (/ 1/ )/ 和/ 式/ (/ 2/ )/ 所示/ ./ 其中/ ,/ Edecode/ 表示/ 驱动/ 地址总线/ 和/ 解析/ 访存/ 地址/ 的/ 能耗/ ;/ Ememory/ 表示/ 访问/ tag/ 阵列/ 和/ data/ 阵列/ 的/ 能耗/ ;/ EI/ // O/ 表示/ 当/ 替换/ 发生/ 时/ 驱动/ 外部/ I/ // O/ 管脚/ 的/ 能耗/ ;/ Ntag/ 和/ Ndata/ 表示/ 访问/ tag/ 阵列/ 和/ data/ 阵列/ 的/ 个数/ ;/ Etag/ 和/ Edata/ 表示/ 访问/ 单个/ tag/ 阵列/ 和/ data/ 阵列/ 的/ 能耗/ ./ 鉴于/ Ememory/ 是/ 整个/ 能耗/ Ecache/ 的/ 主要/ 来源/ ,/ 本文/ 方法/ 主要/ 是/ 通过/ 减少/ Ntag/ 和/ Ndata/ 来/ 降低/ Ememory/ ./ 在/ 传统/ 的/ 组/ 相联/ 缓存/ 中/ ,/ 访存/ 地址/ 通常/ 包含/ tag/ 段/ 、/ index/ 段/ 和/ offset/ 段/ ./ 当读/ 操作/ 发生/ 时/ ,/ 在/ 访存/ 地址/ 生成/ 以后/ ,/ index/ 段/ 被/ 用来/ 索引/ 到/ 相应/ 的/ 缓存/ 组/ ,/ 进而/ 读出/ 此/ 缓存/ 组中/ 的/ 所有/ tag/ 和/ 数据/ ,/ 然后/ 将/ 读出/ 的/ tag/ 和/ tag/ 段/ 进行/ 比较/ ,/ 看/ 是否/ 命中/ ./ 如果/ 命中/ ,/ 并且/ 缓存/ 块/ 中/ 的/ 数据/ 有效/ ,/ offset/ 段/ 用来/ 选择/ 需要/ 的/ 数据/ 写回/ ./ 否则/ ,/ 发出/ 缺失/ 消息/ ,/ 并/ 等待/ 数据/ 的/ 回填/ ./ 因为/ 程序/ 访存/ 的/ 空间/ 局部性/ ,/ 组/ 相联/ 缓存/ 同一个/ 缓存/ 组中/ ,/ tag/ 比/ 对/ 导致/ 不/ 匹配/ 发生/ 的/ 情况/ 大多/ 是/ 由/ tag/ 低位/ 不/ 匹配/ 造成/ 的/ ./ 所以/ ,/ 我们/ 可以/ 提前/ 检查/ tag/ 最低/ 两位/ 的/ 匹配/ 情况/ ,/ 进而/ 在/ 进一步/ 的/ 访问/ 中/ 过滤/ 掉/ 对/ 最低/ 两位/ 不/ 匹配/ 缓存/ 路/ 的/ 访问/ ./ 同时/ ,/ 每次/ 对/ 某个/ 缓存/ 组/ 的/ 访问/ ,/ 并非/ 任何/ 时候/ 每个/ 要/ 访问/ 的/ 缓存/ 组/ 含有/ 的/ 数据/ 块/ 都/ 是/ 有效/ 的/ ,/ 比如/ ,/ 当/ 某个/ 缓存/ 组中/ 的/ 块/ 没有/ 被/ 填满/ ,/ 或者/ 某/ 数据/ 块/ 被/ 无效/ 消息/ 无效/ 掉/ 时/ ./ 在/ 这种/ 情况/ 下/ ,/ 我们/ 可以/ 先/ 通过/ 检查/ 要/ 访问/ 缓存/ 组/ 的/ Valid/ // Invalid/ 标志/ 位/ ,/ 然后/ 在/ 进一步/ 的/ 操作/ 中/ ,/ 消除/ 对/ 含/ 无效/ 数据/ 块/ 的/ 缓存/ 路/ 的/ 访问/ ./ 此外/ ,/ 在/ 被/ 指令和数据/ 共享/ 的/ 缓存/ 中/ ,/ 一个/ 缓存/ 组/ 可能/ 存有/ 数据/ 块/ ,/ 也/ 可能/ 存有/ 指令/ 块/ ./ 而/ 每次/ 访问/ ,/ 要么/ 访问/ 数据/ ,/ 要么/ 访问/ 指令/ ./ 所以/ ,/ 可以/ 对/ 每个/ 数据/ 块/ 设置/ 一个/ 标志/ 位/ (/ I/ // Dbit/ )/ ,/ 来/ 指示/ 里面/ 存放/ 的/ 是/ 指令/ 还是/ 数据/ ,/ 然后/ 访问/ 前/ 检查/ 此/ 标志/ 位/ ,/ 从而/ 在/ 进一步/ 的/ 操作/ 中/ ,/ 消除/ 对/ 访问/ 类型/ 不/ 匹配/ 的/ 数据/ 块/ 的/ 访问/ ./ Page5/ 以上/ 过滤/ 方法/ 都/ 对/ 缓存/ 的/ 命中率/ 没有/ 产生/ 影响/ ,/ 但是/ 由于/ 在/ 缓存/ 访问/ 前/ 放置/ 了/ 一个/ 过滤器/ (/ Filter/ )/ ,/ 所以/ 从/ 硬件/ 实现/ 的/ 角度/ ,/ 需要/ 多/ 一/ 拍/ 的/ 延迟/ 来/ 检测/ 不/ 符合/ 进一步/ 访问/ 条件/ 的/ 缓存/ 块/ ./ 因此/ ,/ 建议/ 此/ 过滤/ 方法/ 最好/ 运用/ 在/ 延迟/ 非/ 敏感/ 的/ 缓存/ 结构/ 中/ ,/ 如/ UnifiedL2Cache/ 或/ 共享/ LLC/ (/ Last/ -/ Level/ -/ Cache/ )/ ./ 3.2/ 硬件/ 结构/ 下面/ 介绍/ 以上/ 3/ 种/ 不必要/ 缓存/ 路/ 访问/ 过滤/ 机制/ 的/ 逻辑/ 结构/ ,/ 用于/ 检查/ 无效/ 数据/ 块/ 的/ InvalidFilter/ ,/ 用于/ 检查/ 指令/ // 数据/ 访问/ 类型/ 不/ 匹配/ 数据/ 块/ 的/ I/ // DFilter/ 以及/ 用于/ 检查/ tag/ 最低/ 2/ 位/ 不/ 匹配/ 数据/ 块/ 的/ Tag/ -/ 2Filter/ ,/ 它们/ 可以/ 基于/ 传统/ 的/ 组/ 相联/ 缓存/ 而/ 实现/ ./ 图/ 4/ 以/ 4/ 路组/ 相联/ 缓存/ 为例/ ,/ 对/ InvalidFilter/ 的/ 结构/ 进行/ 了/ 描述/ ./ 由于/ 传统/ 的/ 组/ 相联/ 缓存/ 中/ ,/ 已/ 存在/ Valid/ // Invalid/ 标志/ 位/ ,/ 图中/ 为/ ValidBitsTable/ ./ 因此/ ,/ 我们/ 只/ 需/ 将/ 标志/ 位/ 的/ 检查/ 逻辑/ 从/ 读出/ 数据/ 和/ tag/ 之后/ ,/ 移/ 到/ 读出/ 数据/ 和/ tag/ 之前/ ,/ 并/ 将/ 此/ 逻辑/ 的/ 输出/ 与/ 各个/ 缓存/ 路/ 使/ 能/ 信号/ 的/ 生成/ 逻辑/ 合并/ 即可/ ./ 无效/ 标志/ 位/ 所在/ 的/ 缓存/ 路/ 将/ 不/ 被/ 使/ 能/ ./ 图/ 5/ 对/ I/ // DFilter/ 的/ 结构/ 进行/ 了/ 描述/ ,/ 也/ 以/ 4/ 路组/ 相联/ 缓存/ 为例/ ./ 为了/ 区分/ 指令/ 块/ 和/ 数据/ 块/ ,/ 我们/ 为/ 每个/ 缓存/ 块/ 添加/ 了/ 一位/ 标志/ 位/ ,/ 置/ 为/ 1/ 表示/ 数据/ 块/ ,/ 为/ 0/ 表示/ 指令/ 块/ ./ 如图/ 5/ 所示/ ,/ 还/ 需要/ 在/ 访问/ 缓存/ 的/ 请求/ 消息/ 中/ 设置/ 一位/ 来/ 指示/ 访问/ 类型/ (/ 数据/ 或/ 指令/ )/ ,/ 从/ 数据/ 缓存/ 发出/ 置/ 为/ 1/ ,/ 从/ 指令/ 缓存/ 发出/ 置/ 为/ 0/ ./ 数据/ 块/ 的/ 标志/ 位/ 在/ 发生/ 回填/ 时/ 根据/ miss/ 类型/ 设置/ ./ Tag/ -/ 2Filter/ 的/ 结构/ 由图/ 6/ 给出/ ,/ 我们/ 将/ 所有/ tag/ 的/ 最低/ 2/ 位/ 单独/ 存储/ ,/ 在/ 图/ 6/ 中/ 称为/ tag/ 最低/ 两位/ 表/ ./ 在/ 访问/ 缓存/ 组前/ ,/ 首先/ 检查/ 相应/ 的/ tag/ 最低/ 两位/ 表/ ,/ 并/ 将/ 结果/ 输出/ 与/ 各个/ 缓存/ 路/ 的/ 使/ 能/ 信号/ 产生/ 逻辑/ 合并/ ./ 以/ 缓存/ 块/ 大小/ 为/ 32byte/ 为例/ ,/ 加上/ tag/ 位/ ,/ 每个/ 缓存/ 块/ 的/ 大小/ 将/ 超过/ 256bit/ ,/ 所以/ 使/ 每个/ 缓存/ 块/ 多/ 2bit/ 的/ tag/ 最低/ 两位/ 表/ 的/ 硬件/ 开销/ 不到/ 百分之一/ ,/ 可/ 忽略不计/ ./ 3.3/ 访问/ 流程图/ 7/ 描述/ 了/ 引入/ 3/ 种/ 访问/ 过滤器/ 的/ 缓存/ 访问/ 流程图/ ./ 访存/ 地址/ 生成/ 后/ ,/ 根据/ 地址/ 首先/ 查找/ Valid/ 表/ 、/ I/ // D/ 表/ 以及/ Tag/ -/ 2/ 表/ ,/ 检查/ 要/ 访问/ 的/ 缓存/ 组中/ 数据/ 无效/ 的/ 缓存/ 块/ 、/ I/ // D/ 位/ 不/ 符合/ 的/ 缓存/ 块/ 以及/ tag/ 最低/ 两位/ 不/ 匹配/ 的/ 缓存/ 块/ ,/ 查询/ 操作/ 同时/ 进行/ ./ 根据/ 检查/ 结果/ ,/ 在/ 进一步/ 的/ 缓存/ 访问/ 时/ ,/ 将/ 不/ 满足/ 访问/ 条/ Page6/ 件/ (/ Invalid/ ,/ I/ // D/ 位/ 不/ 匹配/ ,/ tag/ 低/ 两位/ 不/ 匹配/ )/ 的/ 缓存/ 块/ 所在/ 的/ 缓存/ 路/ 不/ 使/ 能/ (/ disable/ )/ ,/ 只/ 读出/ Valid/ 并且/ I/ // D/ 位/ 和/ tag/ 低/ 两位/ 都/ 与/ 各自/ 表中/ 对应/ 项/ 相匹配/ 的/ 缓存/ 块/ ,/ 然后/ 通过/ 进一步/ 的/ tag/ 比/ 对/ ,/ 根据/ 是否/ 命中/ 选择/ 数据/ 写回/ ,/ 或/ 发出/ 缺失/ 消息/ ./ 如果/ 检查/ 时/ ,/ 所有/ 缓存/ 路/ 的/ 数据/ 都/ 不/ 满足/ 进一步/ 访问/ 的/ 条件/ ,/ 则/ 直接/ 发出/ 缺失/ 消息/ ,/ 等待/ 数据/ 回填/ ./ 由此可见/ ,/ 对于/ 访问/ 即将/ 发生/ 缺失/ 时/ ,/ 最/ 理想/ 的/ 情况/ 是/ ,/ 通过/ 预先/ 检查/ ,/ 直接判断/ 最后/ 的/ 结果/ ,/ 而/ 对/ tag/ 和/ data/ 阵列/ 根本/ 不再/ 发生/ 访问/ ./ 另外/ ,/ 值得注意/ 的/ 是/ ,/ 由于/ 以上/ 3/ 种/ 方法/ 可以/ 并行/ 工作/ ,/ 具有/ 互补性/ ,/ 所以/ ,/ 将/ 以上/ 方法/ 混合/ 使用/ 后/ 可以/ 达到/ 更好/ 的/ 过滤/ 和/ 节能/ 效果/ ,/ 第/ 4/ 节/ 我们/ 将/ 通过/ 具体/ 的/ 实验/ 对此/ 进行/ 验证/ ./ 4/ 实验/ 结果/ 本/ 节/ 我们/ 通过/ 实验/ 来/ 评估/ 混合/ 过滤/ 方法/ (/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ )/ 的/ 效果/ ./ 首先/ ,/ 我们/ 分析/ 并/ 通过/ 初步/ 实验/ 验证/ 3/ 种/ 方法/ 之间/ 的/ 互补性/ ./ 紧接着/ ,/ 我们/ 将/ 实际/ 程序/ 的/ 访存/ Trace/ 在/ 实现/ 了/ 混合/ 过滤器/ 的/ 缓存/ 上/ 进行/ 测试/ ,/ 以/ 得到/ 能够/ 通过/ 混合/ 过滤器/ 而/ 消除/ 的/ 无效/ 缓存/ 路/ 访问/ 占/ 整个/ 访问/ 的/ 比率/ ./ 然后/ ,/ 我们/ 采用/ CACTI6/ ./ 0/ [/ 19/ ]/ 来/ 评估/ 采用/ 过滤/ 方法/ 后/ 被/ 减少/ 的/ 动态/ 功耗/ ./ 同时/ ,/ 我们/ 还/ 将/ 混合/ 过滤器/ 与/ 只/ 采用/ Invalid/ +/ I/ // DFilter/ 的/ 方法/ 和/ 只/ 采用/ Invalid/ +/ Tag/ -/ 2/ 的/ 方法/ 取得/ 的/ 效果/ 进行/ 对比/ ./ 4.1/ 方法/ 互补性/ 分析/ 本文/ 提出/ 的/ 3/ 种/ 不必要/ 缓存/ 路/ 访问/ 过滤/ 方法/ (/ I/ // DFilter/ ,/ InvalidFilter/ ,/ Tag/ -/ 2Filter/ )/ 分别/ 是从/ 程序/ 数据类型/ (/ instruction/ // data/ )/ 、/ 程序/ 数据/ 状态/ (/ Valid/ // Invalid/ )/ 以及/ 访存/ 空间/ 局部性/ 原理/ 导致/ 的/ 访存/ 地址/ 差异/ (/ tag/ 低位/ 不同/ )/ 3/ 个/ 方面/ 进行/ 考虑/ ,/ 其中/ I/ // DFilter/ 区分/ 了/ 同一/ 缓存/ 组中/ 的/ 指令/ 缓存/ 块/ 和/ 数据/ 缓存/ 块/ ;/ InvalidFilter/ 区分/ 了/ 同一/ 缓存/ 组中/ 的/ 有效/ 缓存/ 块/ 和/ 无效/ 缓存/ 块/ (/ 如空/ 缓存/ 块/ )/ ;/ Tag/ -/ 2Filter/ 区分/ 了/ tag/ 低位/ 地址/ 差异/ 的/ 缓存/ 块/ ./ 3/ 种/ 方法/ 互相/ 补充/ ./ 当然/ ,/ 3/ 种/ 方法/ 混合/ 作用/ ,/ 也/ 会/ 有/ 重叠/ 的/ 部分/ ./ 这里/ ,/ 我们/ 以/ InvalidFilter/ 和/ Tag/ -/ 2Filter/ 为例/ ,/ 通过/ 初步/ 的/ 实验/ 验证/ 方法/ 的/ 有效性/ 和/ 互补性/ ./ 我们/ 知道/ ,/ 在/ 程序运行/ 初期/ 或/ 程序/ 数据量/ 较/ 小/ 而/ 局部性/ 又/ 很/ 好/ (/ 即/ 缓存/ 未/ 被/ 数据/ 填满/ )/ 的/ 时候/ ,/ 缓存/ 中/ 存在/ 一定/ 数量/ 的/ 空置/ 缓存/ 块/ (/ 无效/ 缓存/ 块/ )/ ,/ 如图/ 8/ 所示/ ,/ InvalidFilter/ 此时/ 可以/ 发挥作用/ ./ 而/ 当/ 缓存/ 块/ 被/ 数据/ 逐渐/ 填满/ 时/ ,/ 各个/ 缓存/ 组中/ 的/ 缓存/ 块/ 由于/ 空间/ 局部性/ 大多/ 只是/ tag/ 低/ 几位/ 的/ 不同/ ,/ Tag/ -/ 2Filter/ 此时/ 可以/ 发挥作用/ ./ 为了/ 验证/ 这/ 一点/ ,/ 我们/ 将/ 两个/ 常用/ 算法/ 矩阵/ 乘/ 和/ 矩阵/ 转置/ 在/ 实现/ 了/ InvalidFilter/ 和/ Tag/ -/ 2Filter/ 的/ 缓存/ 行为/ 分析器/ 上/ 进行/ 测试/ ,/ 并/ 逐渐/ 增大/ 测试/ 的/ 数据/ 规模/ ,/ 从而/ 模拟/ 和/ 测试/ 了/ 上述/ 过程/ ./ 缓存/ 的/ 大小/ 设置/ 为/ 32KB/ ,/ 4/ -/ way/ 组/ 相联/ ./ 设/ RIA/ 为/ 不必要/ 缓存/ 块/ 的/ 访问率/ ,/ TBR/ (/ i/ )/ 为/ i/ 路/ 不必要/ 缓存/ 块/ 的/ 访问/ 次数/ ,/ 其中/ i/ 从/ 0/ ~/ N/ ,/ N/ 是/ 缓存/ 的/ 最大/ 相联/ 度/ ,/ TR/ 为/ 缓存/ 块/ 的/ 总/ 访问/ 次数/ ,/ 则/ 根据/ 式/ (/ 3/ )/ 计算/ 访问/ 不必要/ 数据/ 块/ 的/ 比例/ ./ RIA/ =/ ∑/ n/ 测试/ 结果/ 如表/ 2/ 和表/ 3/ 所示/ ./ 统计/ 结果/ 都/ 表明/ ,/ InvalidFilter/ 和/ Tag/ -/ 2Filter/ 各自/ 发挥/ 了/ 作用/ ,/ 在/ 矩阵/ 乘/ 程序/ 中/ ,/ InvalidFilter/ 最高/ 可/ 过滤/ 68.46/ %/ 的/ 缓存/ 路/ 访问/ ,/ Tag/ -/ 2Filter/ 最高/ 可/ 过滤/ 63/ %/ 的/ 缓存/ 路/ 访问/ ;/ 在/ 矩阵/ 转置/ 程序/ 中/ ,/ InvalidFilter/ 最高/ 可过/ Page7/ 滤/ 68.6/ %/ 的/ 缓存/ 路/ 访问/ ,/ Tag/ -/ 2Filter/ 最高/ 可/ 过滤/ 69/ %/ 的/ 缓存/ 路/ 访问/ ./ 并且/ ,/ 随着/ 数据/ 规模/ 的/ 增大/ (/ 即/ 缓存/ 逐渐/ 被/ 填满/ )/ ,/ 两种/ 方法/ 的/ 作用/ 此消彼长/ ,/ 而/ 总体/ 效果/ 分别/ 保持/ 在/ 61.65/ %/ ~/ 74.74/ %/ 和/ 71.58/ %/ ~/ 77.9/ %/ ./ 因此/ 可以/ 说/ ,/ 两者/ 具有/ 很/ 好/ 的/ 互补性/ ./ 表/ 2/ 矩阵/ 乘/ 程序/ 在/ 32KB/ -/ 4way/ 带有/ InvalidFilter/ 和/ MatrixDataAmount32/ ×/ 3268.4648/ ×/ 4832.7464/ ×/ 6496/ ×/ 96128/ ×/ 1280.15/ 表/ 3/ 矩阵/ 转置/ 程序/ 在/ 32KB/ -/ 4way/ 带有/ InvalidFilter/ 和/ MatrixDataAmount48/ ×/ 3268.6064/ ×/ 4849.9064/ ×/ 6433.60128/ ×/ 6414.58256/ ×/ 1284.65/ 需要/ 注意/ 的/ 是/ ,/ 为/ 简单/ 起/ 见/ ,/ 我们/ 这里/ 只/ 模拟/ 了/ 空置/ 缓存/ 块/ ,/ 而/ 未/ 被/ 使用/ 的/ 空置/ 缓存/ 块/ 只是/ 缓存/ 块/ 无效/ 的/ 其中/ 一种/ 状态/ ,/ 在/ 实际/ 程序运行/ 中/ ,/ 缓存/ 块/ 的/ 无效/ 状态/ 还/ 包括/ 被/ Invalid/ 消息/ 无效/ 掉/ 的/ ,/ 如/ 来自/ DMA/ (/ DirectMemoryAccess/ )/ 控制器/ 的/ Invalid/ 消息/ 或/ 处理器/ 核/ 的/ Invalid/ 消息/ 等/ ./ 下/ 一节/ ,/ 我们/ 将/ 通过/ 实际/ 应用程序/ 对/ 3/ 种/ 方法/ 的/ 有效性/ 做/ 进一步/ 的/ 测试/ ,/ 并且/ 将/ 不同/ 方法/ 进行/ 组合/ ,/ 通过/ 对比/ ,/ 进一步/ 验证/ 方法/ 之间/ 的/ 互补性/ ./ 4.2/ 可/ 被/ 消除/ 的/ 缓存/ 路/ 访问/ 比率/ 本/ 节/ ,/ 我们/ 将/ 通过/ 实验/ 来/ 测试通过/ 3/ 种/ 过滤器/ 可/ 被/ 消除/ 的/ 缓存/ 路/ 访问/ 比率/ ./ 实验/ 用/ 了/ 2/ 个/ 应用程序/ (/ spice/ ,/ tex/ )/ 和/ 6/ 个/ 从/ SPECCPU2000/ 测试程序/ 集中/ 随机/ 挑选/ 的/ 测试程序/ ,/ 其中/ 3/ 个/ 来自/ SPECCPU2000Integer/ (/ gcc/ 、/ mcf/ 和/ eon/ )/ ,/ 另外/ 3/ 个/ 来自/ SPECCPU2000floating/ -/ point/ (/ mesa/ 、/ ammp/ 和/ art/ )/ ,/ 被/ 用来/ 验证/ 通过/ 各种/ 过滤器/ 可以/ 消除/ 缓存/ 路/ 访问/ 比率/ ./ 其中/ ,/ 每个/ 测试/ Benchmark/ 的/ 访存/ Trace/ 都/ 超过/ 百万条/ ./ 针对/ 3/ 种/ 不同/ 的/ 组合/ 过滤器/ (/ Invalid/ +/ I/ // DFilter/ ,/ Invalid/ +/ Tag/ -/ 2Filter/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ )/ ,/ 我们/ 分别/ 在/ 64KB/ -/ 4way/ 和/ 128KB/ -/ 8way/ 组/ 相联/ 缓存/ 上/ 进行/ 了/ 测试/ ,/ 这些/ 缓存/ 可以/ 被/ 指令和数据/ 存储/ 共享/ ./ 实验/ 结果/ 分别/ 如图/ 9/ 和/ 图/ 10/ 所示/ ./ 为了/ 集中/ 于/ 我们/ 所/ 关注/ 的/ 问题/ ,/ 缓存/ 块/ 大小/ 固定/ 为/ 32Byte/ ,/ 替换/ 策略/ 采用/ 随机/ 替换/ ./ 不必要/ 缓存/ 路/ 访问/ 比率/ 统计/ 计算方法/ 如/ 4.1/ 节/ 中式/ (/ 3/ )/ 所示/ ./ 图/ 964KB/ -/ 4way/ 缓存/ 上/ 可/ 被/ 消除/ 的/ 路/ 访问/ 比率/ 图/ 10128KB/ -/ 8way/ 缓存/ 上/ 可/ 被/ 消除/ 的/ 路/ 访问/ 比率/ 图/ 9/ 的/ 结果显示/ ,/ 在/ 64KB/ -/ 4way/ 带有/ Invalid/ +/ I/ // DFilter/ 的/ 缓存/ 结构/ 上/ ,/ 能够/ 被/ 消除/ 的/ 缓存/ 路/ 访问/ 比率/ 分别/ 为/ gcc47/ ./ 63/ %/ ,/ mcf52/ ./ 73/ %/ ,/ eon49/ ./ 60/ %/ ,/ art52/ ./ 41/ %/ ,/ mesa62/ ./ 50/ %/ ,/ ammp36/ ./ 65/ %/ ,/ spice50/ ./ 49/ %/ ,/ tex65/ ./ 88/ %/ ;/ 在/ 64KB/ -/ 4way/ 带有/ Invalid/ +/ Tag/ -/ 2Filter/ 的/ 缓存/ 结构/ 上/ ,/ 能够/ 被/ 消除/ 的/ 缓存/ 路/ 访问/ 比率/ 分别/ 为/ gcc59/ ./ 65/ %/ ,/ mcf60/ ./ 07/ %/ ,/ eon65/ ./ 53/ %/ ,/ art61/ ./ 64/ %/ ,/ mesa66/ ./ 38/ %/ ,/ ammp60/ ./ 25/ %/ ,/ spice66/ ./ 67/ %/ ,/ tex69/ ./ 32/ %/ ;/ 在/ 64KB/ -/ 4way/ 带有/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 的/ 缓存/ 结构/ 上/ ,/ 能够/ 被/ 消除/ 的/ 缓存/ 路/ 访问/ 比率/ 分别/ 为/ gcc71/ ./ 42/ %/ ,/ mcf73/ ./ 58/ %/ ,/ eon68/ ./ 24/ %/ ,/ art73/ ./ 19/ %/ ,/ mesa71/ ./ 08/ %/ ,/ ammp68/ ./ 50/ %/ ,/ spice74/ ./ 16/ %/ ,/ tex72/ ./ 97/ %/ ./ 以上/ 结果/ 还/ 表明/ ,/ 与/ Invalid/ +/ I/ // DFilter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 可以/ 获得/ 平均/ 19.41/ %/ 的/ 效果/ 提高/ ;/ 与/ Invalid/ +/ Tag/ -/ 2Filter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 可以/ 获得/ 平均/ 7.95/ %/ 的/ 效果/ 提高/ ./ 图/ 10/ 的/ 结果显示/ ,/ 在/ 128KB/ -/ 8way/ 带有/ Invalid/ +/ I/ // DFilter/ 的/ 缓存/ 结构/ 上/ ,/ 能够/ 被/ 消除/ 的/ 缓存/ 路/ 访问/ Page8/ 比率/ 分别/ 为/ gcc59/ ./ 41/ %/ ,/ mcf61/ ./ 95/ %/ ,/ eon74/ ./ 54/ %/ ,/ art63/ ./ 12/ %/ ,/ mesa80/ ./ 39/ %/ ,/ ammp46/ ./ 49/ %/ ,/ spice72/ ./ 81/ %/ ,/ tex82/ ./ 94/ %/ ;/ 在/ 128KB/ -/ 8way/ 带有/ Invalid/ +/ Tag/ -/ 2Filter/ 的/ 缓存/ 结构/ 上/ ,/ 能够/ 被/ 消除/ 的/ 缓存/ 路/ 访问/ 比率/ 分别/ 为/ gcc67/ ./ 86/ %/ ,/ mcf68/ ./ 52/ %/ ,/ eon82/ ./ 52/ %/ ,/ art71/ ./ 29/ %/ ,/ mesa82/ ./ 80/ %/ ,/ ammp71/ ./ 09/ %/ ,/ spice82/ ./ 10/ %/ ,/ tex84/ ./ 66/ %/ ;/ 在/ 128KB/ -/ 8way/ 带有/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 的/ 缓存/ 结构/ 上/ ,/ 能够/ 被/ 消除/ 的/ 缓存/ 路/ 访问/ 比率/ 分别/ 为/ gcc82/ ./ 46/ %/ ,/ mcf83/ ./ 23/ %/ ,/ eon84/ ./ 07/ %/ ,/ art83/ ./ 42/ %/ ,/ mesa85/ ./ 31/ %/ ,/ ammp78/ ./ 91/ %/ ,/ spice86/ ./ 78/ %/ ,/ tex86/ ./ 48/ %/ ./ 以上/ 结果/ 还/ 表明/ ,/ 与/ Invalid/ +/ I/ // DFilter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 可以/ 获得/ 平均/ 16.13/ %/ 的/ 效果/ 提高/ ;/ 与/ Invalid/ +/ Tag/ -/ 2Filter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 可以/ 获得/ 平均/ 7.48/ %/ 的/ 效果/ 提高/ ./ 4.3/ 能耗/ 节省/ 评估/ 及/ 对比/ 由于/ 大量/ 不必要/ 的/ 缓存/ 路/ 访问/ 可以/ 通过/ 本文/ 过滤/ 方法/ 预先/ 消除/ ,/ 由此/ 产生/ 的/ 动态/ 能耗/ 也/ 必将/ 大大降低/ ./ 接下来/ ,/ 我们/ 采用/ CACTI6/ ./ 0/ 来/ 评估/ 和/ 比较/ 通过/ 不同/ 过滤器/ 所/ 能/ 节省/ 的/ 能耗/ ./ 实验/ 中/ 只/ 考虑/ 由于/ 缓存/ 的/ 访问/ 而/ 产生/ 的/ 动态/ 能耗/ ./ 实验/ 结果表明/ ,/ 采用/ 混合/ 过滤/ 机制/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 的/ 效果/ 比/ Invalid/ +/ I/ // DFilter/ 和/ Invalid/ +/ Tag/ -/ 2Filter/ 的/ 效果/ 都/ 好/ ,/ 实验/ 结果/ 的/ 比较/ 如图/ 11/ 和/ 图/ 12/ 所示/ ./ 图/ 11/ 的/ 结果表明/ ,/ 在/ 64KB/ -/ 4way/ 缓存/ 上/ ,/ 与/ 采用/ Invalid/ +/ I/ // DFilter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 能/ 得到/ 的/ 能耗/ 降低/ 效果/ 提升/ 为/ gcc39/ ./ 0/ %/ ,/ mcf35/ ./ 3/ %/ ,/ eon36/ ./ 6/ %/ ,/ art34/ ./ 7/ %/ ,/ mesa20/ ./ 1/ %/ ,/ ammp47/ ./ 8/ %/ ,/ spice41/ ./ 5/ %/ ,/ tex19/ ./ 6/ %/ ,/ 平均/ 提高/ 34.3/ %/ ;/ 与/ 采用/ Invalid/ +/ Tag/ -/ 2Filter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 能/ 得到/ 的/ 能耗/ 降低/ 效果/ 提升/ 为/ gcc22/ ./ 5/ %/ ,/ mcf27/ ./ 7/ %/ ,/ eon6/ ./ 2/ %/ ,/ art23/ ./ 2/ %/ ,/ mesa11/ ./ 5/ %/ ,/ ammp17/ ./ 7/ %/ ,/ spice16/ ./ 2/ %/ ,/ tex8/ ./ 0/ %/ ,/ 平均/ 提高/ 16.6/ %/ ./ 图/ 12/ 的/ 结果表明/ ,/ 在/ 128KB/ -/ 8way/ 缓存/ 上/ ,/ 与/ 采用/ Invalid/ +/ I/ // DFilter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 能/ 得到/ 的/ 能耗/ 降低/ 效果/ 提升/ 为/ gcc48/ ./ 3/ %/ ,/ mcf45/ ./ 7/ %/ ,/ eon36/ ./ 6/ %/ ,/ art44/ ./ 7/ %/ ,/ mesa19/ ./ 0/ %/ ,/ ammp55/ ./ 2/ %/ ,/ spice44/ ./ 1/ %/ ,/ tex19/ ./ 6/ %/ ,/ 平均/ 提高/ 39.2/ %/ ;/ 与/ 采用/ Invalid/ +/ Tag/ -/ 2Filter/ 相比/ ,/ Invalid/ +/ I/ // D/ +/ Tag/ -/ 2Filter/ 能/ 得到/ 的/ 能耗/ 降低/ 效果/ 提升/ 为/ gcc44/ ./ 4/ %/ ,/ mcf43/ ./ 3/ %/ ,/ eon7/ ./ 0/ %/ ,/ art40/ ./ 0/ %/ ,/ mesa12/ ./ 4/ %/ ,/ ammp24/ ./ 7/ %/ ,/ spice20/ ./ 0/ %/ ,/ tex8/ ./ 0/ %/ ,/ 平均/ 提高/ 25.0/ %/ ./ 5/ 结束语/ 一直/ 以来/ ,/ 降低/ 高速缓存/ 的/ 功耗/ ,/ 作为/ 处理器/ 领域/ 的/ 研究/ 热点/ 之一/ ,/ 无论/ 在/ 单核/ 处理器/ 还是/ 在/ 多/ 核/ 处理器/ 中/ ,/ 都/ 得到/ 了/ 国内外/ 同行/ 的/ 广泛/ 关注/ ./ 本文/ 提出/ 了/ 在/ 组/ 相联/ 缓存/ 中/ 采用/ 过滤/ 机制/ 通过/ 消除/ 不必要/ 缓存/ 路/ 访问/ 来/ 降低/ CPU/ 动态/ 功耗/ 的/ 方法/ ./ 对于/ 每次/ 访问/ ,/ 利用/ InvalidFilter/ 可以/ 预先/ 检查/ 无效/ 数据/ 块/ ,/ I/ // DFilter/ 可以/ 提前/ 查出/ 指令/ // 数据/ 访问/ 类型/ 不/ 匹配/ 的/ 数据/ 块/ ,/ Tag/ -/ 2Filter/ 可以/ 提前/ 查出/ tag/ 最低/ 2/ 位/ 不/ 匹配/ 数据/ 块/ ,/ 被/ 查出/ 的/ 数据/ 块/ 所在/ 的/ 缓存/ 路/ 的/ 访问/ 在/ 随后/ 得到/ 消除/ ./ 实验/ 表明/ ,/ 以上/ 方法/ 可以/ 有效/ 降低/ 缓存/ 的/ 能耗/ ,/ 并且/ 当/ 3/ 种/ 方法/ 混合/ 使用/ 时/ ,/ 效果/ 最好/ ./ 本文/ 方法/ 也/ 可以/ 在/ 多/ 核/ // 众核/ 处理器/ 的/ 共享/ LLC/ (/ Last/ -/ Level/ -/ Cache/ )/ 中/ 得以/ 应用/ ,/ 这/ 将/ 是/ 我们/ 下/ 一步/ 的/ 工作/ ./ 致谢/ 在/ 此/ ,/ 我们/ 向/ 中国科学院计算技术研究所/ 的/ 张轮凯/ 和/ 唐士斌/ 表示感谢/ ,/ 感谢/ 他们/ 在/ 本文/ 方法/ 讨论/ 中/ 给予/ 的/ 建议/ ;/ 向/ 美国/ 韦恩/ 州立大学/ 的/ 王世楠/ 表示感谢/ ,/ 感谢/ 他/ 在/ 本文/ 的/ 实验/ 中/ 参与/ 的/ 分析/ 和/ 讨论/ ;/ 向/ 中国科学院计算技术研究所/ 的/ 王达/ 博士/ 和/ 宋风龙/ 博士/ 表示感谢/ ,/ 感谢/ 他们/ 在/ 本文/ 撰写/ 过程/ 中/ 给予/ 的/ 帮助/ !/ Page9/ 

