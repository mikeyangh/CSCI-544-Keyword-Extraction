Page1/ 列/ 存储/ 数据仓库/ 中/ 启发式/ 查询/ 优化/ 机制/ 严秋玲/ 1/ )/ 孙莉/ 1/ )/ 王梅/ 1/ )/ 乐嘉锦/ 1/ )/ 刘/ 国华/ 1/ )/ ,/ 2/ )/ 1/ )/ (/ 东华大学/ 计算机科学/ 与/ 技术/ 学院/ 上海/ 201620/ )/ 2/ )/ (/ 南京大学/ 计算机软件/ 新/ 技术/ 国家/ 重点/ 实验室/ 南京/ 210093/ )/ 摘要/ 研究/ 和/ 实践/ 表明/ 列/ 存储/ 更加/ 适合/ 于/ 大规模/ 数据/ 集上/ 的/ 即席/ 查询/ 的/ “/ 读/ 优化/ ”/ 应用/ 需求/ ./ 然而/ 由于/ 列/ 存储/ 的/ 处理/ 对象/ 是/ 列/ ,/ 此时/ 传统/ 的/ 基于/ 规则/ 的/ 查询/ 优化/ 方法/ 并/ 不/ 完全/ 适用/ ./ 文中/ 首先/ 比较/ 了/ 列/ 存储系统/ 中/ 查询/ 优化/ 与行/ 存储系统/ 的/ 不同/ ,/ 在/ 此基础/ 上/ 提出/ 适合/ 于列/ 存储/ 的/ 启发式/ 查询/ 优化/ 机制/ ,/ 其中/ 包括/ 启发式/ 优化/ 策略/ 、/ 重写/ 规则/ 、/ 左深/ 连接/ 树结构/ 和/ 相关/ 算法/ ./ 实验/ 表明/ :/ 该文/ 提出/ 的/ 启发式/ 优化/ 机制/ 能/ 有效/ 减少/ 候选/ 计划/ 的/ 规模/ ,/ 排除/ 大量/ 不/ 可能/ 生成/ 最优/ 计划/ 的/ 计划/ ,/ 使得/ 查询处理/ 代价/ 和/ 执行/ 时间/ 大大/ 减小/ ./ 关键词/ 列/ 存储/ ;/ 查询/ 优化/ ;/ 优化/ 策略/ ;/ 重写/ 规则/ ;/ 左深/ 连接/ 树/ 1/ 引言/ 传统/ 的/ 事务/ 型/ 数据库系统/ 是/ 写/ 优化/ (/ write/ -/ optimized/ )/ 的/ ,/ 它们/ 多数/ 采用/ 行/ 存储/ 的/ 方式/ 来/ 存储/ 数据/ ,/ 而/ 分析/ 型/ 的/ 数据仓库/ 常常/ 是/ 短时间/ 内/ 写入/ 大批/ 新/ 数据/ ,/ 然后/ 长时间/ 地/ 进行/ ad/ -/ hoc/ 查询/ 操作/ ,/ 面向/ ad/ -/ hoc/ 大/ 数据量/ 查询/ 的/ 系统/ 应该/ 是/ 读/ 优化/ (/ read/ -/ optimized/ )/ 的/ [/ 1/ ]/ ,/ 此时/ 列/ 存储/ 的/ 方式/ 就/ 表现/ 出比行/ 存储/ 具有/ 更加/ 显著/ 的/ 性能/ 优势/ ./ 列/ 存储系统/ 是/ 将/ 同/ Page2/ 一列/ 数据/ 连续/ 存储/ ,/ 避免/ 了/ 将/ 不/ 相关/ 列/ 的/ 数据/ 读入/ 内存/ ,/ 这种/ 技术/ 的/ 特点/ 是/ 对/ 复杂/ 数据/ 查询/ 效率高/ 、/ 读/ 磁盘/ 少/ 、/ 存储空间/ 小/ [/ 2/ ]/ ,/ 这样/ 的/ 列/ 存储系统/ 就/ 成为/ 了/ 构建/ 数据仓库/ 的/ 理想/ 架构/ ,/ 因而/ 引起/ 数据库/ 学术前沿/ 和/ 相关/ 高新科技/ 企业/ 投入/ 大量/ 的/ 人力/ 和/ 物力/ 研发/ ,/ 相继/ 开发/ 出/ 不少/ 列/ 存储系统/ 如/ C/ -/ Store/ [/ 2/ ]/ 、/ Sybase/ [/ 3/ ]/ 、/ MonetDB/ [/ 4/ ]/ 等/ ,/ 它们/ 也/ 实际/ 验证/ 了/ 列/ 存储技术/ 在读/ 优先/ 系统/ 上/ 的/ 优越性/ ./ 而/ 作为/ 数据仓库/ 中/ 最/ 常用/ 、/ 最/ 重要/ 的/ 语句/ ,/ 查询/ 语句/ 的/ 执行/ 效率/ 直接/ 影响/ 了/ 数据仓库/ 的/ 性能/ ,/ 这/ 使得/ 在/ 大容量/ 的/ 数据仓库/ 上/ 探索/ 更/ 高效/ 的/ 查询处理/ 技术/ 成为/ 一种/ 必然/ ./ 查询/ 优化/ 在/ 现代/ 数据仓库/ 管理系统/ 中/ 一直/ 占有/ 重要/ 的/ 地位/ ,/ 目前/ ,/ 学界/ 和/ 业界/ 多数/ 在/ 底层/ 存储/ 和/ 执行/ 上/ 做/ 优化/ 处理/ ,/ 如/ 压缩/ 技术/ 、/ 索引/ 技术/ 、/ 不/ 可见/ 连接/ 技术/ [/ 5/ -/ 8/ ]/ 等等/ ./ 现有/ 的/ 列/ 存储系统/ 也/ 多/ 通过/ 在/ 存储/ 上/ 做/ 改进/ 来/ 减少/ 查询/ 中/ 的/ 连接/ 开销/ ,/ 如/ C/ -/ Store/ 的/ “/ 投影/ (/ projection/ )/ [/ 1/ -/ 2/ ,/ 8/ ]/ ”/ 技术/ 将/ 属于/ 同表/ 的/ 列/ 按/ 不同/ 的/ 组合/ 存储/ ,/ 以此/ 来/ 提高/ 查询/ 效率/ ;/ MonetDB/ 的/ “/ 饼干/ 图/ (/ crackermap/ )/ [/ 9/ ]/ ”/ 技术/ 在/ 查询/ 时/ 建立/ 相关/ 列/ 的/ 映射/ 关系/ ;/ 由此/ 可以/ 看出/ ,/ 列/ 存储技术/ 在/ 存储/ 方面/ 的/ 优化/ 已有/ 不少/ 研究成果/ ./ 查询/ 重写/ [/ 10/ ]/ (/ 语法/ 重新/ 构造/ )/ 作为/ 查询/ 语句/ 逻辑/ 优化/ 的/ 一个/ 重要/ 组成部分/ ,/ 它/ 是/ 将/ 查询/ 语句/ 转换/ 为/ 另/ 一种/ 等价/ 且/ 高效/ 的/ 内部/ 表示/ ,/ 也/ 就是/ 帮助/ 查询/ 优化/ 器/ 获得/ 更好/ 的/ 执行/ 计划/ [/ 11/ ]/ ./ 目前/ ,/ 基于/ 规则/ 的/ 优化/ (/ RBO/ )/ [/ 10/ ,/ 12/ ]/ 是/ 查询/ 重写/ 中/ 一个/ 比较/ 成熟/ 的/ 方法/ ,/ 它/ 是/ 根据/ 指定/ 的/ 规则/ 对/ 逻辑/ 计划/ 进行/ 优化/ ./ 在/ 基于/ 规则/ 的/ 模式/ 下/ ,/ 优化/ 的/ 代价/ 小/ ,/ 获得/ 的/ 执行/ 计划/ 通常/ 也/ 比较稳定/ ./ 大多数/ 情况/ 下/ ,/ 启发式/ 查询/ 优化/ [/ 13/ -/ 14/ ]/ 是/ 基于/ 规则/ 的/ 查询/ 重写/ 中/ 应用/ 最多/ 的/ 一种/ 机制/ ,/ 它/ 结合/ 启发式/ 优化/ 策略/ ,/ 遵循/ 关系/ 代数/ 中/ 多个/ 代数/ 定律/ 的/ 重写/ 规则/ 来/ 改写/ 查询/ 计划/ ,/ 使/ 之/ 转化成/ 一个/ 与其/ 所/ 需/ 时间/ 较/ 小/ 的/ 等价/ 的/ 计划/ ./ 由于/ 列/ 存储系统/ 与行/ 存储系统/ 在/ 处理/ 对象/ 、/ 选择/ 和/ 连接/ 的/ 级联/ 形式/ 、/ 自然/ 连接/ 等/ 方面/ 存在/ 较大/ 差异/ ,/ 这/ 就/ 使得/ 传统/ 的/ 启发式/ 查询/ 优化/ 方法/ 并/ 不/ 完全/ 适用/ 于列/ 存储系统/ ./ 针对/ 上述/ 问题/ ,/ 本文/ 提出/ 了/ 一种/ 适用/ 于列/ 存储/ 数据仓库/ 的/ 启发式/ 优化/ 机制/ ./ 首先/ ,/ 本文/ 研究/ 了/ 传统/ 的/ 启发式/ 查询/ 优化/ 的/ 主要/ 策略/ ,/ 并/ 深入/ 比较/ 了/ 列/ 存储系统/ 和行/ 存储系统/ 各自/ 的/ 存储/ 特点/ ,/ 给出/ 了/ 它们/ 在/ 查询/ 优化/ 中/ 的/ 具体/ 区别/ ;/ 然后/ 提出/ 了/ 适合/ 于列/ 存储系统/ 的/ 启发式/ 优化/ 策略/ 和/ 关系/ 代数/ 表达式/ 重写/ 规则/ ;/ 接着/ 论述/ 了/ 左深/ 连接/ 树/ 在/ 构建/ 逻辑/ 查询/ 计划/ 时/ 的/ 适用性/ ,/ 并/ 给出/ 了/ 本文/ 设计/ 的/ 双层/ 左深/ 连接/ 树结构/ ;/ 再/ 接着/ 给出/ 了/ 相关/ 的/ 优化/ 算法/ ;/ 最后/ ,/ 通过/ 实验/ 论证/ ,/ 本文/ 提出/ 的/ 优化/ 机制/ 能/ 生成/ 高效/ 的/ 逻辑/ 查询/ 计划/ ,/ 使得/ 查询/ 效率/ 大大提高/ ./ 本文/ 第/ 2/ 节/ 介绍/ 列/ 存储技术/ 的/ 研究/ 背景/ 以及/ 列/ 存储/ 查询/ 优化/ 的/ 研究/ 现状/ ;/ 第/ 3/ 节/ 基于/ 对/ 查询/ 优化/ 过程/ 、/ 传统/ 启发式/ 优化/ 方法/ 和/ 列/ 存储/ 特点/ 的/ 分析/ 研究/ ,/ 给出/ 适应/ 的/ 优化/ 策略/ 和/ 重写/ 规则/ ;/ 第/ 4/ 节/ 介绍/ 左深/ 连接/ 树结构/ 和/ 相关/ 的/ 优化/ 算法/ ;/ 第/ 5/ 节/ 描述/ 实验/ 并/ 对/ 实验/ 结果/ 进行/ 分析/ ;/ 最后/ 是/ 总结/ 和/ 展望/ ./ 2/ 相关/ 工作/ 1985/ 年/ ,/ Copeland/ 等/ 人/ [/ 15/ ]/ 提出/ 了/ 一种/ 新/ 的/ 存储/ 概念/ ,/ 简称/ DSM/ ,/ 这/ 就是/ 列/ 存储系统/ 的/ 雏形/ ,/ 它/ 对列/ 存储/ 模型/ 做/ 了/ 比较/ 详细/ 的/ 介绍/ ./ 接着/ 在/ 以/ Stone/ -/ brakerMichael/ ,/ AbadiDanielJ/ ,/ BonczPeter/ 为首/ 的/ 一批/ 专家/ 的/ 大力提倡/ 下/ ,/ 列/ 存储/ 的/ 相关/ 技术/ 及/ 应用/ 快速/ 发展/ ,/ 相继/ 出现/ PAX/ [/ 16/ ]/ 、/ S/ -/ PAX/ [/ 17/ ]/ 存储/ 模型/ ,/ 其中/ PAX/ 将/ 同一/ 元组/ 的/ 属性/ 存储/ 在/ 一个/ 磁盘/ 页/ 上/ ,/ 而页/ 内/ 所有/ 元组/ 属性/ 值/ 按列/ 连续/ 存放/ ,/ 以此/ 来/ 加速/ 元组/ 重构/ ./ 而/ S/ -/ PAX/ 在/ PAX/ 基础/ 上/ ,/ 由/ 若干/ 磁盘/ 页/ 逻辑/ 上/ 构成/ 一个/ 超页/ ,/ 元组/ 的/ 不同/ 属性/ 分别/ 存放/ 在/ 同一/ 超页/ 内/ 的/ 不同/ 磁盘/ 页/ 上/ ,/ 即/ 每个/ 磁盘/ 页/ 按列/ 连续/ 存放/ 元组/ 属性/ 值/ ,/ 以此/ 来/ 避免/ 在/ 查询/ 执行/ 过程/ 中/ ,/ 将/ 元组/ 的/ 无关/ 列/ 读入/ 缓冲区/ ,/ 又/ 能/ 加速/ 元组/ 重构/ ./ C/ -/ Stor/ [/ 2/ ]/ 是/ 一款/ 开源/ 的/ 、/ 运行/ 于/ Linux/ 系统/ 的/ 列/ 存储/ 数据库系统/ ,/ 于/ 2006/ 年/ 10/ 月/ 发布/ ,/ 目前/ 主要/ 的/ 学术研究/ 都/ 采用/ 了/ 该/ 系统/ 进行/ 实验/ ,/ 在/ 学术界/ 比较/ 流行/ ./ 它/ 是/ 将/ 每列/ 连续/ 存储/ ,/ 多列/ 的/ 一个/ 组合/ 保存/ 在/ 一个/ 投影/ (/ projection/ )/ 中/ ,/ 按照/ 其中/ 一列/ 排序/ ./ 因此/ C/ -/ Store/ 查询/ 经常/ 基于/ 一个/ 投影/ ,/ 或者/ 含有/ 公共/ 排/ 序列/ 的/ 不同/ 投影/ ,/ 以此/ 减少/ 元组/ 重构/ 和/ 列/ 的/ 连接/ 代价/ ./ 这样/ ,/ C/ -/ Store/ 很/ 好/ 地/ 完善/ 了/ 查询/ 执行器/ ,/ 但是/ 没有/ 对/ 初始/ 的/ 逻辑/ 执行/ 计划/ 进行/ 必要/ 的/ 优化/ 处理/ ./ MonetDB/ [/ 4/ ]/ 是/ 一款/ 运行/ 于/ Linux/ 和/ Windows/ 系统/ 上/ 的/ 高性能/ 开源/ 列/ 存储/ 数据库/ ,/ 同时/ 是/ 一款/ 内存/ 数据库/ ./ 在/ 存储/ 设计/ 上/ ,/ 采用/ DSM/ 模型/ ,/ 同时/ 用散/ 列法/ 代替/ B/ +/ 树/ ,/ 以此/ 解决/ 建立/ 多个/ B/ +/ 树/ 空间/ 利用率/ 低/ 的/ 问题/ ;/ 对/ 初始/ 的/ 逻辑/ 计划/ ,/ MonetDB/ 也/ 采用/ 一些/ 简单/ 的/ 优化/ 策略/ 和/ 重写/ 规则/ 进行/ 优化/ ,/ 如下/ 推/ 选择/ 策略/ ,/ 使得/ 选择/ 操作/ 尽早/ 执行/ ,/ 减小/ 中间/ 关系/ 大小/ ,/ 进而/ 减少/ 读写/ 的/ I/ // O/ 次数/ ,/ 以此/ 达到/ 优化/ 效果/ ./ 但/ 这些/ 用到/ 的/ 策略/ 和/ 规则/ 相对/ 于列/ 存储系统/ 的/ Page3/ 特点/ 并/ 不够/ 深入/ ,/ MonetDB/ 也/ 仅仅/ 设计/ 和/ 实现/ 了/ 一个/ 比较/ 粗糙/ 的/ 查询/ 优化/ 器/ ./ 此外/ 包括/ 其它/ 的/ 一些/ 列/ 存储系统/ 如/ :/ Rasdaman/ 、/ SybaseIQ/ 、/ ParAccel/ 等/ 也/ 在/ 查询/ 优化/ 方面/ 提供/ 了/ 一些/ 很/ 好/ 的/ 解决/ 方法/ ,/ 但/ 它们/ 的/ 重点/ 大都/ 放在/ 物理/ 存储/ 的/ 改变/ 上/ ,/ 在/ 重写/ 逻辑/ 查询/ 计划/ 这方面/ 涉及/ 较/ 少/ ,/ 实现/ 过程/ 中/ 仅仅/ 简单/ 引入/ 了/ 传统/ 行/ 存储系统/ 的/ 一些/ 优化/ 策略/ 和/ 重写/ 规则/ ,/ 这些/ 列/ 存储系统/ 基本/ 没有/ 更/ 深入/ 地/ 分析/ 列/ 存储系统/ 的/ 存储/ 特点/ ,/ 提出/ 一些/ 列/ 存储系统/ 特有/ 的/ 优化/ 策略/ 和/ 重写/ 规则/ ./ 基于/ 以上/ 分析/ ,/ 本文/ 结合/ 行/ 存储/ 启发式/ 查询/ 优化/ 的/ 方法/ 和/ 列/ 存储系统/ 的/ 存储/ 特点/ ,/ 提出/ 了/ 面向/ 列/ 存储系统/ 的/ 基本/ 优化/ 策略/ 、/ 详细/ 的/ 重写/ 规则/ 、/ 双层/ 左深/ 连接/ 树结构/ 以及/ 相关/ 优化/ 算法/ ,/ 从而/ 建立/ 了/ 一种/ 比较完善/ 的/ 适用/ 于列/ 存储/ 数据仓库/ 的/ 启发式/ 查询/ 优化/ 机制/ ./ 3/ 优化/ 策略/ 和/ 重写/ 规则/ 3.1/ 相关/ 概念/ 查询处理/ ./ 是/ 指/ 从/ 数据库/ 中/ 检索/ 数据/ 的/ 活动/ ,/ 其/ 目标/ 是/ 将/ 高级/ 语言/ (/ 例如/ SQL/ )/ 表示/ 的/ 查询/ 转换/ 为/ 正确/ 有效/ 的/ 、/ 用/ 低级语言/ 表达/ 的/ 执行/ 计划/ ,/ 即/ 实现/ 关系/ 代数/ ,/ 并/ 通过/ 执行/ 该/ 计划/ 来/ 获取/ 所/ 需/ 的/ 数据/ ./ 查询/ 编译/ ./ 它/ 是/ 指/ 通过/ 语法分析/ 、/ 查询/ 优化/ 、/ 制定/ 物理/ 执行/ 策略/ 将/ 最初/ 查询/ 语句/ 等价/ 转化/ 为/ 物理/ 执行/ 计划/ 的/ 过程/ ./ 它/ 主要/ 分为/ 3/ 个/ 步骤/ :/ 分析/ 查询/ 、/ 生成/ 逻辑/ 计划/ 、/ 生成/ 物理/ 计划/ ./ 查询/ 优化/ ./ 它/ 是/ 指/ 选择/ 高效/ 的/ 执行/ 计划/ 的/ 活动/ ./ 由于/ 一个/ 高级/ 查询/ 有/ 多种/ 等价/ 的/ 转换/ 形式/ ,/ 查询/ 优化/ 的/ 目标/ 是/ 选择/ 其中/ 资源/ 占用/ 最少/ 的/ 一种/ ./ 启发式/ 查询/ 优化/ ./ 在/ 查询/ 优化/ 过程/ 按照/ 启发式/ 重写/ 规则/ 将/ 初始/ 的/ 查询/ 计划/ 转换成/ 一个/ 等价/ 的/ 、/ 高效/ 的/ 查询/ 计划/ ,/ 该/ 查询/ 计划/ 可/ 被/ 转换成/ 最/ 有效/ 的/ 物理/ 查询/ 计划/ ./ 可能/ 深地/ 靠近/ 查询/ 树/ 的/ 叶端/ ;/ 可能/ 深地/ 靠近/ 查询/ 树/ 的/ 叶端/ ;/ 典型/ 的/ 启发式/ 优化/ 策略/ 有/ (/ 1/ )/ 对/ 每/ 一个/ 选择/ ,/ 利用/ 等价/ 变换/ 规则/ 使/ 其/ 尽/ (/ 2/ )/ 对/ 每/ 一个/ 投影/ ,/ 利用/ 等价/ 变换/ 规则/ 使/ 其/ 尽/ (/ 3/ )/ 利用/ 等价/ 变换/ 规则/ 把/ 选择/ 和/ 投影/ 的/ 串接/ 合并/ 成/ 单个/ 选择/ 、/ 单个/ 投影/ 或/ 一个/ 选择/ 后/ 跟/ 一个/ 投影/ ./ 3.2/ 列/ 存储系统/ 启发式/ 查询/ 优化/ 与行/ 存储系统/ 的/ 区别/ 在/ 列/ 存储系统/ 中/ ,/ 为了/ 重构/ 元组/ ,/ 存储/ 每/ 一列/ 数据/ 时/ ,/ 每/ 一列/ 都/ 附加/ 一个/ 伪列/ rowid/ ,/ 形/ 如/ 〈/ rowid/ ,/ value/ 〉/ ./ 这样/ 可以/ 将/ 每个/ 列/ 看作/ 是/ 〈/ rowid/ ,/ value/ 〉/ 形式/ 的/ 二元/ 表/ ,/ 此时/ 列/ 存储系统/ 的/ 查询/ 优化/ 与行/ 存储系统/ 的/ 区别/ 如下/ :/ 操作/ 对象/ ./ 在/ 行/ 存储/ 中/ ,/ 下推/ 的/ 目标/ 对象/ 是/ 表/ ;/ 而/ 在/ 列/ 存储/ 中/ ,/ 下推/ 的/ 目标/ 对象/ 具体/ 到/ 某个/ 列/ ,/ 每个/ 列/ 相当于/ 一个/ 由/ (/ rowid/ ,/ value/ )/ 组成/ 的/ 小表/ ./ 投影/ 操作/ ./ 行/ 存储/ 由于/ 是/ 逐行/ 存储/ ,/ 为了/ 减少/ 中间/ 结果/ ,/ 需要/ 投影/ 查询/ 中/ 需要/ 操作/ 的/ 列/ ,/ 因此/ 在/ 每个/ 选择/ 操作/ 后/ ,/ 都/ 伴随/ 着/ 投影/ 操作/ ,/ 挑选/ 对/ 后面/ 有用/ 的/ 属性/ ,/ 有/ 相关/ 投影/ 的/ 启发式/ 重写/ 规则/ ./ 而/ 在/ 逐列/ 存储/ 的/ 系统/ 中/ ,/ 根本/ 不/ 需要/ 投影/ ,/ 只/ 需/ 操作/ 与/ 查询/ 相关/ 的/ 列/ 即可/ ,/ 所以/ 没有/ 相关/ 投影/ 的/ 重写/ 规则/ ./ 选择/ 的/ 级联/ 形式/ ./ 行/ 存储/ 对于/ 同表/ 的/ 选择/ ,/ 是/ 级联/ 形式/ 的/ ,/ 先/ 根据/ 一个/ 选择/ 条件/ 过滤/ 元组/ ,/ 再/ 根据/ 另/ 一个/ 条件/ 过滤/ 经过/ 筛选/ 的/ 元组/ ./ 这样/ 能/ 减少/ 中间/ 结果/ ,/ 也/ 能/ 减少/ 代价/ ./ 而/ 在/ 列/ 存储/ 中/ ,/ 由于/ 操作/ 对象/ 是/ 单列/ ,/ 因此/ 既/ 可以/ 选择/ 级联/ 形式/ 减少/ 中间/ 结果/ ,/ 也/ 可以/ 选择/ 单列/ rowid/ 求交/ 的/ 形式/ 减少/ 中间/ 结果/ ,/ 因此/ ,/ 列/ 的/ 选择/ 相当于/ 集合/ 交/ ,/ 不会/ 转化成/ 固定/ 的/ 级联/ 形式/ ./ 表/ 之间/ 连接/ 的/ 级联/ 形式/ ./ 行/ 存储系统/ 中多表/ 连接/ 的/ 处理/ 需要/ 得到/ 较/ 小/ 的/ 中间/ 结果/ ,/ 需要/ 估计/ 连接/ 的/ 代价/ ,/ 然后/ 决定/ 连接/ 顺序/ 再/ 去/ 执行/ ./ 而列/ 存储系统/ 中/ 由于/ 连接/ 条件/ 具体/ 到/ 某/ 两个/ 列/ 上/ ,/ 我们/ 既/ 可以/ 选择/ 级联/ 地/ 执行/ 多个/ 空间/ 的/ 连接/ 条件/ ,/ 也/ 可以/ 选择/ 求交/ 的/ 执行/ 方法/ ,/ 同样/ 可以/ 减少/ 中间/ 结果/ ./ 自然/ 连接/ ./ 列/ 存储系统/ 中/ 由于/ 操作/ 对象/ 是/ 列/ ,/ 因此/ 所有/ 的/ 自然/ 连接/ 都/ 会/ 转换成/ 列/ 与/ 列/ 的/ 等值/ 比较/ ,/ 也/ 就是/ 转化成/ θ/ 连接/ ,/ 因此/ ,/ 没有/ 自然/ 连接/ 的/ 重写/ 规则/ ./ 相反/ 在/ 行/ 存储系统/ 需要/ 有/ 关于/ 自然/ 连接/ 的/ 重写/ 规则/ ./ Page4/ 本文/ 启发式/ 优化/ 的/ 基本/ 思想/ 是/ :/ 首先/ 执行/ 最具/ 3.3/ 列/ 存储系统/ 的/ 启发式/ 优化/ 策略/ 限制性/ 的/ 选择/ 和/ 连接/ 操作/ ./ 具体/ 优化/ 策略/ 如下/ :/ (/ 1/ )/ 把/ 选择/ 操作/ 尽可能/ 深/ 地下/ 推/ 到/ 查询/ 树叶/ 端/ (/ 使得/ 尽早/ 执行/ 选择/ 操作/ ./ 选择/ 操作/ 减少/ 了/ 关系/ 中/ 元组/ 的/ 数量/ 从而/ 降低/ 了/ 后面/ 关系/ 处理/ 的/ 复杂度/ ,/ 它/ 一般/ 可/ 使得/ 中间/ 结果/ 大大/ 变小/ ,/ 常常/ 能/ 使/ 执行/ 时间/ 节约/ 几个/ 数量级/ )/ ;/ (/ 2/ )/ 如果/ 由/ 多个/ 谓词/ 组成/ 的/ 选择/ 条件/ ,/ 则/ 可/ 把/ 该/ 条件/ 分解/ 并/ 分别/ 将/ 每个/ 选择/ 条件/ 下推/ (/ 有效/ 地/ 将/ 不同/ 表/ 的/ 选择/ 条件/ 下推/ 到/ 相关/ 表/ 的/ 复杂/ 操作/ 下面/ )/ ;/ (/ 3/ )/ 合并/ 同表/ 同列/ 的/ 选择/ 操作/ (/ 消除/ 重复/ 和/ 一/ (/ 4/ )/ 将/ 同表/ 不同/ 列/ 的/ 选择/ 操作/ 分组/ (/ 一次性/ 执行/ 完同/ 一张/ 表中/ 的/ 所有/ 相关/ 列/ 操作/ ,/ 大大减少/ 后面/ 表/ 之间/ 连接/ 操作/ 的/ 中间/ 关系/ )/ ;/ 次性/ 执行/ 完/ 同列/ 的/ 所有/ 操作/ )/ ;/ 论/ 是否/ 来自/ 同/ 一张/ 表/ ,/ 都/ 是/ 二元/ 连接/ 操作/ ;/ (/ 5/ )/ 两列/ 之间/ 的/ 比较/ 谓词/ 操作/ 或/ 数学/ 操作/ ,/ 无/ (/ 6/ )/ 把/ 某些/ 选择/ 运算/ 同/ 在/ 其/ 前面/ 执行/ 的/ 笛卡尔/ 积/ 结合/ 起来/ 成为/ 一个/ 连接/ 运算/ (/ 连接/ 特别/ 是/ 等值/ 连接/ 的/ 执行/ 时间/ 远远/ 低于/ 笛卡尔/ 积/ 的/ 执行/ 时间/ )/ ./ 3.4/ 启发式/ 重写/ 规则/ 本文/ 重点/ 研究/ 如下/ 形式/ 的/ sql/ 查询/ :/ selectLfromRwhere/ ∧/ // ∨/ (/ A1/ ,/ …/ ,/ An/ )/ ./ R/ 是/ 关系/ 的/ 集合/ ,/ L/ 是/ 关系/ R/ 的/ 属性/ 集/ ,/ A1/ ,/ …/ ,/ An/ 是/ 由/ and/ 或者/ or/ 连接/ 的/ 谓词/ ./ 在/ 列/ 存储系统/ 中/ ,/ 查询处理/ 的/ 对象/ 是/ 列/ ,/ 所以/ 此类/ 查询/ 可以/ 作/ 以下/ 转化/ :/ selectLfrom/ (/ K1/ ×/ K2/ ×/ …/ )/ whereKi/ 是/ 查询/ 相关/ 的/ 列/ ,/ 再/ 根据/ 前面/ 提出/ 的/ 优化/ 策略/ ,/ 本文/ 制定/ 了/ 如表/ 1/ 所示/ 的/ 关系/ 代数/ 表达式/ 重写/ 规则/ ./ 序号/ Rule1/ 〈/ rowid/ ,/ value/ 〉/ 形式/ 的/ 二元/ 表/ ,/ 所以/ 可以/ 在/ 传统/ 的/ 处理/ 对象/ 是/ 表/ 的/ 基础/ 上/ 具体化/ 到/ 列上来/ :/ σ/ θ/ i/ (/ R/ )/ =/ σ/ θ/ i/ (/ Ki/ )/ ,/ θ/ i/ 是/ 涉及/ 引用/ 关系/ R/ 中列/ Ki/ 的/ 选择/ 条件/ ;/ σ/ θ/ (/ R1/ ×/ R2/ )/ =/ σ/ θ/ (/ Ki/ ×/ Kj/ )/ ,/ θ/ 是/ 涉及/ 引用/ 关系/ R1/ 、/ R2/ 中列/ Ki/ 、/ Kj/ 的/ 选择/ 条件/ ;/ σ/ θ/ i/ (/ Ki/ )/ ∧/ // ∨/ σ/ θ/ j/ (/ Kj/ )/ =/ σ/ θ/ j/ (/ Kj/ )/ ∧/ // ∨/ σ/ θ/ i/ (/ Ki/ )/ ,/ σ/ θ/ i/ (/ Ki/ )/ / / θ/ σ/ θ/ j/ (/ Kj/ )/ =/ σ/ θ/ j/ (/ Kj/ )/ / / θ/ σ/ θ/ i/ (/ Ki/ )/ ,/ θ/ 是/ 连接/ 条件/ ,/ θ/ i/ ,/ θ/ j/ 是/ 涉及/ 同一/ 引用/ 关系/ 中列/ Ki/ 、/ Kj/ 的/ 选择/ 条件/ ,/ i/ ≠/ j/ ;/ (/ σ/ θ/ i/ (/ Ki/ )/ ∧/ σ/ θ/ j/ (/ Kj/ )/ )/ ∧/ σ/ θ/ x/ (/ Kx/ )/ =/ (/ σ/ θ/ i/ (/ Ki/ )/ ∧/ σ/ θ/ x/ (/ Kx/ )/ )/ ∧/ σ/ θ/ j/ (/ Kj/ )/ ;/ Rule2Rule3/ θ/ i/ ,/ θ/ j/ 分别/ 是/ 引用/ 关系/ R1/ 、/ R2/ 中列/ Ki/ 、/ Kj/ 的/ 选择/ 条件/ ;/ 序号/ Rule4/ σ/ θ/ i/ ∧/ θ/ j/ (/ R1/ ×/ R2/ )/ =/ σ/ θ/ j/ (/ Ki/ )/ ∧/ σ/ θ/ j/ (/ Kj/ )/ ,/ Rule5/ σ/ θ/ i/ (/ K/ )/ ∧/ // ∨/ σ/ θ/ j/ (/ K/ )/ =/ σ/ θ/ i/ ∧/ // ∨/ θ/ j/ (/ K/ )/ ,/ θ/ i/ ,/ θ/ j/ 都/ 是/ 涉及/ 引用/ 列/ K/ 的/ 选择/ 条件/ ;/ Rule6/ σ/ θ/ i/ (/ Ki/ )/ ∧/ // ∨/ σ/ θ/ j/ (/ Kj/ )/ =/ σ/ θ/ i/ ∧/ // ∨/ θ/ j/ (/ Ki/ ×/ Kj/ )/ ;/ σ/ θ/ (/ Ki/ ×/ Kj/ )/ =/ Ki/ / / θ/ Kj/ ,/ θ/ 是/ 涉及/ 列/ Ki/ 、/ Kj/ 的/ 比较/ 条件/ ,/ σ/ θ/ i/ ∧/ // ∨/ θ/ j/ (/ Ki/ ×/ Kj/ )/ =/ σ/ θ/ i/ (/ Ki/ )/ / / θ/ σ/ θ/ j/ (/ Kj/ )/ ,/ θ/ 是/ 两列/ 的/ 连接/ Rule7Rule8/ σ/ θ/ (/ Ki/ ×/ Kj/ )/ =/ Rki/ / / θ/ Rkj/ θ/ 是/ 列/ Ki/ 、/ Kj/ 的/ 连接/ 条件/ ,/ 且/ 不可/ 分解/ ;/ Rki/ 、/ Rkj/ 分别/ 是/ 列/ Ki/ 、/ Kj/ 的/ 引用/ 关系/ ;/ Rule9/ σ/ θ/ i/ (/ Ki/ )/ ∧/ (/ Ri/ ◇/ Rj/ )/ =/ σ/ θ/ i/ (/ Ki/ )/ ◇/ Rj/ ,/ Ri/ 是/ 列/ Ki/ 的/ 引用/ 关系/ ;/ σ/ θ/ i/ (/ Ki/ )/ ∧/ σ/ θ/ j/ (/ Kj/ )/ ∧/ (/ Ri/ ◇/ Rj/ )/ =/ σ/ θ/ i/ (/ Ki/ )/ ◇/ σ/ θ/ j/ (/ Kj/ )/ ,/ Ri/ ,/ Rj/ 分别/ 是/ 列/ Ki/ 、/ Kj/ 的/ 引用/ 关系/ ;/ σ/ θ/ i/ (/ Ki/ )/ ∧/ σ/ θ/ j/ (/ Kj/ )/ ∧/ (/ Ri/ ◇/ Rj/ )/ =/ σ/ θ/ i/ (/ Ki/ )/ ◇/ R2/ ×/ σ/ θ/ j/ (/ Kj/ )/ ,/ Ri/ 是/ 列/ Ki/ 的/ 引用/ 关系/ ,/ Kj/ 的/ 引用/ 关系/ 既/ 不是/ Ri/ ,/ 也/ 不是/ Rj3/ ./ 5/ 查询/ 重写/ 举例/ 对于/ 查询/ :/ selectA/ ./ a/ ,/ B/ ./ bfromA/ ,/ B/ ,/ CwhereA/ ./ a/ >/ 1andB/ ./ b/ >/ 3andA/ ./ a/ >/ 4and/ 此/ 查询/ 用/ 关系/ 代数/ 表达式/ 可/ 表示/ 为/ Qex/ =/ Π/ A/ ./ b/ ,/ B/ ./ b/ (/ σ/ A/ ./ a/ >/ 1andB/ ./ b/ >/ 3andA/ ./ a/ >/ 4and/ 根据/ 上面/ 提出/ 的/ 优化/ 规则/ 对/ Qex/ 进行/ 重写/ :/ 首先/ 使用/ Rule1/ 、/ Rule4/ 将/ Qex/ 处理/ 对象/ 由表/ 具体化/ 到/ 引用/ 列/ ,/ 就/ 可/ 得到/ 如表/ 2/ 中/ 所示/ 的/ T1/ (/ Step1/ )/ ;/ 然后/ 根据/ Rule2/ 、/ Rule5/ 合并/ A/ 表中/ 涉及/ a/ 列/ 的/ 选择/ 操作/ 得到/ T2/ ,/ 合并/ B/ 表中/ 涉及/ b/ 列/ 的/ 选择/ 操作/ 得到/ T3/ (/ Step2/ )/ ;/ (/ Step3/ )/ 接着/ 将/ 涉及/ A/ 、/ B/ 表/ 的/ 同表/ 不同/ 列/ 的/ 选择/ 条件/ 合并/ 为/ 笛卡尔/ 积/ (/ Rule2/ 、/ Rule6/ )/ ,/ 再/ 根据/ Rule7/ 将/ 笛卡尔/ 积/ 转化/ 为/ 同表/ 不同/ 列/ 的/ θ/ (/ rowid/ 相等/ 的/ 连接/ 条件/ )/ 连接/ T4/ 、/ T5/ ,/ 同时/ 根据/ Rule8/ 将/ A/ 与/ B/ 、/ B/ 与/ C/ 的/ 列/ 之间/ 的/ 笛卡尔/ 积/ 转化/ 为表/ 之间/ 的/ θ/ (/ 有关/ 两/ 表列/ 之间/ 的/ 比较/ 条件/ )/ 连接/ T7/ 、/ T8/ ;/ 最后/ 根据/ Rule9/ 将/ 关于/ A/ 、/ B/ 、/ C/ 表中列/ 的/ 选择/ 条件/ T4/ 、/ T5/ 、/ T6/ 下推/ 到/ θ/ 连接/ T7/ 、/ T8/ 下/ ,/ 使得/ 对/ 每张/ 表/ 尽早/ 执行/ 选择/ 操作/ ,/ 再/ 做表/ 之间/ 的/ 连接/ 操作/ (/ 见表/ 2/ )/ ./ Page5/ 步骤/ Step1Qex/ =/ Π/ A/ ./ a/ ,/ B/ ./ b/ (/ T1/ )/ ,/ T1/ =/ σ/ A/ ./ a/ >/ 1/ (/ A/ ./ a/ )/ ∧/ σ/ B/ ./ b/ >/ 3/ (/ B/ ./ b/ )/ ∧/ σ/ A/ ./ a/ >/ 4/ (/ A/ ./ a/ )/ ∧/ T1/ =/ T2/ ∧/ T3/ ∧/ σ/ A/ ./ e/ =/ 7/ (/ A/ ./ e/ )/ ∧/ σ/ B/ ./ f/ =/ 9/ (/ B/ ./ f/ )/ ∧/ Step2Step3T2/ =/ σ/ A/ ./ a/ >/ 1/ (/ A/ ./ a/ )/ ∧/ σ/ A/ ./ a/ >/ 4/ (/ A/ ./ a/ )/ =/ σ/ A/ ./ a/ >/ 4/ (/ A/ ./ a/ )/ ,/ T3/ =/ σ/ B/ ./ b/ >/ 3/ (/ B/ ./ b/ )/ ∧/ σ/ B/ ./ b/ </ 5/ (/ B/ ./ b/ )/ =/ σ/ B/ ./ b/ >/ 3/ ∧/ B/ ./ b/ </ 5/ (/ B/ ./ b/ )/ ./ T1/ =/ T4/ ∧/ T5/ ∧/ T6/ ∧/ T7/ ∧/ T8/ ,/ T4/ =/ T2/ ∧/ σ/ A/ ./ e/ =/ 7/ (/ A/ ./ e/ )/ ∧/ σ/ A/ ./ b/ =/ 5/ (/ A/ ./ b/ )/ T5/ =/ T3/ ∧/ σ/ B/ ./ f/ =/ 9/ (/ B/ ./ f/ )/ =/ σ/ B/ ./ b/ >/ 3/ ∧/ B/ ./ b/ </ 5/ (/ B/ ./ b/ )/ / / θ/ σ/ B/ ./ f/ =/ 9/ (/ B/ ./ f/ )/ ,/ T6/ =/ σ/ C/ ./ a/ =/ 2/ (/ C/ ./ a/ )/ ,/ T7/ =/ σ/ A/ ./ c/ =/ B/ ./ c/ (/ A/ ./ c/ ×/ B/ ./ c/ )/ =/ A/ / / A/ ./ c/ =/ B/ ./ cB/ ,/ T8/ =/ σ/ C/ ./ g/ =/ B/ ./ g/ (/ C/ ./ g/ ×/ B/ ./ g/ )/ =/ C/ / / C/ ./ g/ =/ B/ ./ gB/ ./ Step4T1/ =/ T4/ / / A/ ./ c/ =/ B/ ./ cT5/ / / C/ ./ g/ =/ B/ ./ gT6/ ./ 4/ 左深/ 连接/ 树/ 和/ 算法/ 实现/ 4.1/ 左深/ 连接/ 树/ 一般来说/ ,/ 一个/ 二叉树/ 如果/ 所有/ 右边/ 的/ 子女/ 都/ 是/ 叶子/ 结点/ 的话/ ,/ 它/ 就是/ 左深树/ ;/ 一个/ 二叉树/ 如果/ 所有/ 左边/ 的/ 子女/ 都/ 是/ 叶子/ 结点/ 的话/ ,/ 它/ 就是/ 右/ 深树/ ;/ 既/ 不是/ 左深树/ ,/ 也/ 不是/ 右/ 深树/ ,/ 称之为/ 紧密/ 树/ ;/ 一个/ 左深/ 连接/ 树/ [/ 18/ ]/ 的/ 叶/ 结点/ 是/ 带有/ 除了/ 连接/ 之外/ 的/ 操作符/ 的/ 内部/ 结点/ ./ 随着/ 关系/ 数目/ 的/ 增长/ ,/ 可/ 形成/ 的/ 左深/ 连接/ 树/ 的/ 数目/ 的/ 增长/ 几乎/ 不会/ 像/ 可/ 形成/ 的/ 所有/ 树/ (/ 包括/ 左深树/ 、/ 右/ 深树/ 、/ 紧密/ 树/ )/ 的/ 数目/ 增长/ 那样/ 快/ ,/ 这样/ 有利于/ 代价/ 估计/ 过程/ 对/ 给定/ 关系/ 数目/ 形成/ 的/ 不同/ 连接/ 树/ 的/ 考虑/ ;/ 同时/ 基于/ 对/ 连接/ 顺序/ 考虑/ ,/ 这种/ 结构/ 还/ 具有/ 以下/ 优点/ :/ (/ 1/ )/ 查询/ 计划/ 的/ 搜索/ 将/ 可以/ 用于/ 比较/ 大/ 的/ 查询/ ./ (/ 2/ )/ 用于/ 连接/ 的/ 左深/ 连接/ 树/ 可以/ 和/ 通用/ 的/ 连接/ 算法/ 很/ 好/ 地/ 交互/ —/ —/ —/ 尤其/ 是/ 嵌套循环/ 连接/ 和/ 一趟/ 连接/ 算法/ ./ (/ 3/ )/ 基于/ 左深/ 连接/ 树/ 生成/ 的/ 执行/ 计划/ 将会/ 比非/ 左深/ 连接/ 树/ 更/ 有效/ ./ 如果/ 用/ 的/ 是/ 一趟/ 连接/ ,/ 并且/ “/ 建立/ 关系/ ”/ 是/ 在/ 左边/ ,/ 则/ 任何/ 时候/ 所/ 需要/ 的/ 内存/ 都/ 将/ 比/ 同样/ 关系/ 用非/ 左/ 深树/ 的/ 情况/ 要/ 小/ ;/ 如果/ 是/ 用/ 迭代/ 的/ 方法/ 实现/ 的/ 嵌套循环/ 连接/ ,/ 则/ 可以/ 避免/ 多次/ 构建/ 任意/ 中间/ 关系/ ./ 本文/ 提出/ 一种/ 双层/ 左深/ 连接/ 树结构/ (/ 如图/ 2/ 所示/ )/ ,/ 表层/ 为/ 不同/ 表/ (/ R1/ …/ Rn/ )/ 之间/ 的/ 左深/ 连接/ 树/ ,/ θ/ 1/ …/ θ/ n/ -/ 1/ 是/ 不同/ 表/ 的/ 列/ 之间/ 的/ 连接/ 条件/ ,/ θ/ i/ (/ 1/ / i/ / n/ -/ 1/ )/ 可以/ 为空/ ,/ 即/ 表示/ 为/ 笛卡尔/ 积/ 的/ 连接/ 关系/ ;/ 内层/ 为/ 同表/ 不同/ 列/ (/ K1/ …/ Ki/ )/ 之间/ 的/ 左深/ 连接/ 树/ ,/ f1/ …/ fi/ -/ 1/ 是/ 同/ 表列/ 之间/ 的/ 连接/ 条件/ ,/ fj/ (/ 1/ / i/ / i/ -/ 1/ )/ 不可/ 空/ ,/ 它/ 是/ 涉及/ 同表/ 不同/ 列/ 之间/ 的/ 比较/ 操作/ 连接/ 条件/ 或者/ rowid/ 相等/ 的/ 连接/ 条件/ ./ 4.2/ 算法/ 实现/ 在/ 查询处理/ 过程/ 中/ ,/ 经过/ 词法/ 语法分析/ 得到/ 语法/ 树/ ,/ 再/ 对/ 语法/ 树/ 进行/ 预处理/ 可以/ 生成/ 初始/ 的/ 查询/ 计划/ ,/ 它/ 仅仅/ 是/ 对/ 查询/ 语句/ 的/ 简单/ 翻译/ ,/ 其/ 树结构/ 是/ 比较/ 粗糙/ 的/ ,/ 也/ 还/ 没有/ 经过/ 优化/ 重写/ ,/ 是/ 不能/ 作为/ 最终/ 的/ 逻辑/ 查询/ 计划/ ./ 本文/ 对/ 初始/ 的/ 查询/ 计划/ 树/ 使用/ 规则/ 重写/ 和/ 构建/ 双层/ 左深/ 连接/ 树/ 的/ 实现/ 过程/ 如下/ :/ 步骤/ 1/ ./ 建立/ 表/ 之间/ 的/ 左深/ 连接/ 树/ ./ 从/ 得到/ 的/ 查询/ 树根/ 结点/ 遍历/ 整棵树/ ,/ 不断/ 地/ 访问/ 孩子/ 结点/ ,/ 找出/ 关于/ 表/ 之间/ 连接/ 操作/ 的/ 二元/ 结点/ ,/ 同时/ 对/ 其/ 结构/ 作/ 适当/ 调整/ 后/ ,/ 将/ 它/ 压入/ 目标/ 左深树/ R/ _/ tree/ 中/ ./ 其/ 算法/ 描述/ 如下/ :/ Function/ :/ LeftTreeInput/ :/ 查询/ 树根/ 结点/ root/ _/ node/ ,/ 空树/ R/ _/ treeOutput/ :/ R/ _/ treeLeftTree/ (/ root/ _/ node/ ,/ R/ _/ tree/ )/ 1/ ./ begin2/ ./ 遍历/ 查询/ 树/ root/ _/ node/ ;/ 3/ ./ if/ 遍历/ 到/ 的/ 结点/ 是/ “/ and/ ”/ 操作/ 的/ 二元/ 结点/ then4/ ./ R/ _/ tree/ =/ LeftTree/ (/ left/ _/ child/ ,/ R/ _/ tree/ )/ ;/ // // 递归/ 5/ ./ R/ _/ tree/ =/ LeftTree/ (/ right/ _/ child/ ,/ R/ _/ tree/ )/ ;/ 6/ ./ returnR/ _/ tree/ ;/ 7/ ./ elseif/ 遍历/ 到/ 的/ 结点/ 是/ 连接/ 操作/ 的/ 二元/ 结点/ then8/ ./ R/ _/ tree/ =/ Push/ (/ R/ _/ tree/ ,/ connect/ _/ node/ )/ ;/ 9/ ./ returnR/ _/ tree/ ;/ 10/ ./ endif11/ ./ endif12/ ./ endPage6/ 步骤/ 2/ ./ 建立/ 同表/ 的/ 列/ 之间/ 的/ 左深/ 连接/ 树/ ./ 根据/ 每/ 一张/ 表/ 的/ 表号/ ,/ 遍历/ 整棵/ 查询/ 树/ ,/ 找出/ 属于/ 同/ 一张/ 表/ 的/ 选择/ 操作/ ,/ 并/ 将/ 其/ 构建/ 成/ 一个/ 同/ 表列/ 之间/ 的/ 左深/ 连接/ 树/ L/ _/ tree/ ,/ 接着/ 对/ L/ _/ tree/ 进行/ 常量/ 转化/ 、/ 消除/ 重复/ 、/ 合并/ 同列/ 选择/ 操作/ 等/ 规则/ 优化/ 操作/ ,/ 最后/ 就/ 生成/ 了/ 优化/ 的/ 同/ 表列/ 之间/ 的/ 左深/ 连接/ 树/ L/ _/ tree/ ./ 其/ 算法/ 描述/ 如下/ :/ Function/ :/ Opt/ _/ L/ _/ treeInput/ :/ 查询/ 树根/ 结点/ root/ _/ node/ ,/ 空树/ L/ _/ tree/ ,/ 表号/ idOutput/ :/ L/ _/ treeOpt/ _/ L/ _/ tree/ (/ id/ ,/ root/ _/ node/ ,/ L/ _/ tree/ )/ 1/ ./ begin2/ ./ 遍历/ 查询/ 树/ root/ _/ node/ ;/ 3/ ./ if/ 遍历/ 到/ 的/ 结点/ 是/ “/ and/ ”/ 操作/ 的/ 二元/ 结点/ then4/ ./ L/ _/ tree/ =/ Opt/ _/ L/ _/ tree/ (/ id/ ,/ left/ _/ child/ ,/ L/ _/ tree/ )/ ;/ 5/ ./ L/ _/ tree/ =/ Opt/ _/ L/ _/ tree/ (/ id/ ,/ right/ _/ child/ ,/ L/ _/ tree/ )/ ;/ 6/ ./ L/ _/ tree/ =/ Opt/ _/ onetable/ (/ L/ _/ tree/ )/ ;/ 7/ ./ returnL/ _/ tree/ ;/ 8/ ./ elseif/ 遍历/ 到/ 的/ 结点/ 是/ 选择/ 操作/ 的/ 一元/ 结点/ then9/ ./ if/ 该/ 选择/ 结点/ 的/ 表号/ =/ =/ idthen10/ ./ L/ _/ tree/ =/ Push/ (/ L/ _/ tree/ ,/ select/ _/ node/ )/ ;/ 11/ ./ returnL/ _/ tree/ ;/ 12/ ./ endif13/ ./ endif14/ ./ endif15/ ./ end/ 步骤/ 3/ ./ 下推/ 选择/ ./ 遍历/ 目标/ 左深树/ R/ _/ tree/ ,/ 根据/ 其/ 叶子/ 结点/ 的/ 表号/ ,/ 将/ 对应/ 的/ L/ _/ tree/ 下推/ 到表/ 连接/ 操作/ 结点/ 下面/ ./ 其/ 算法/ 描述/ 如下/ :/ Function/ :/ PushdownInput/ :/ 表/ 之间/ 的/ 左/ 深树/ R/ _/ tree/ ,/ 查询/ 树根/ 结点/ root/ _/ nodeOutput/ :/ R/ _/ treePushdown/ (/ R/ _/ tree/ ,/ root/ _/ node/ )/ // // 下推/ 1/ ./ begin2/ ./ 遍历/ R/ _/ tree/ 中/ 的/ 每个/ 内/ 结点/ ;/ 3/ ./ 对/ 遍历/ 到/ 的/ 每个/ 结点/ ,/ 根据/ 右/ 孩子/ 表号/ 获得/ L/ _/ tree/ ;/ 4/ ./ right/ _/ child/ =/ L/ _/ tree/ ;/ 5/ ./ if/ 左/ 孩子/ 不是/ 叶子/ 结点/ 6/ ./ left/ _/ child/ =/ Pushdown/ (/ left/ _/ child/ ,/ root/ _/ node/ )/ ;/ 7/ ./ else8/ ./ 根据/ 左/ 孩子/ 表号/ 获得/ L/ _/ tree9/ ./ right/ _/ child/ =/ L/ _/ tree/ ;/ 10/ ./ endif11/ ./ returnR/ _/ tree/ ;/ 12/ ./ end/ 这里/ 以上/ 一节/ 提到/ 的/ Qex/ 为例/ ,/ 在/ 查询处理/ 的/ 过程/ ,/ 它/ 初始/ 的/ 查询/ 计划/ 树如图/ 3/ ./ 首先/ 调用/ LeftTree/ 函数/ ,/ 从树/ 的/ 根/ 结点/ 开始/ 遍历/ 整棵/ 查询/ 树/ ,/ 若/ 结点/ 是/ 逻辑/ 操作/ “/ and/ ”/ 的/ 二元/ 结点/ ,/ 则/ 左右/ 孩子/ 递归/ 调用/ LeftTree/ 函数/ ;/ 遍历/ 到/ “/ A/ ./ c/ =/ B/ ./ c/ ”/ 二元/ 结点/ ,/ 则/ 将/ 该/ 结点/ 取出/ 并/ 通过/ Push/ 函数/ 压入/ 预先/ 建立/ 的/ 空树/ R/ _/ tree/ 中/ ,/ 同样/ 遍历/ 到/ “/ B/ ./ g/ =/ C/ ./ g/ ”/ 二元/ 结点/ ,/ 该/ 结点/ 也/ 会/ 被/ 压入/ R/ _/ tree/ 树中/ ,/ 此时/ 得到/ 一棵/ 关于/ A/ 、/ B/ 、/ C/ 三表且/ 带有/ 连接/ 条件/ 的/ 左深/ 连接/ 树/ (/ 1/ )/ (/ 见图/ 4/ )/ ./ 然后/ ,/ 通过/ Pushdown/ 函数/ 遍历/ (/ 1/ )/ ,/ 首先/ 遍历/ 到/ 的/ 结点/ 的/ 右/ 孩子/ 的/ 表号/ 代表/ 的/ 是/ A/ ,/ 则/ 根据/ A/ 的/ 表号/ 调用/ Opt/ _/ L/ _/ tree/ 函数/ ,/ 在/ 查询/ 树中/ 遍历/ 到/ 涉及/ A/ 表/ 的/ 选择/ 条件/ 一元/ 结点/ “/ A/ ./ a/ >/ 1/ ”/ ,/ 则/ 将/ 该/ 结点/ 取出/ 并/ 通过/ Push/ 函数/ 压入/ 预先/ 建立/ 的/ 空树/ L/ _/ tree/ 中/ ,/ 同样/ “/ A/ ./ a/ >/ 4/ ”/ 、/ “/ A/ ./ b/ =/ 5/ ”/ 、/ “/ A/ ./ e/ =/ 7/ ”/ 会/ 依次/ 被/ 压入/ L/ _/ tree/ 中/ ,/ 再/ 调用/ Opt/ _/ onetable/ 函数/ 对/ L/ _/ tree/ 作/ 一些/ 优化/ 处理/ (/ 合并/ 同表/ 同列/ 选择/ 操作/ 、/ 常量/ 计算/ 、/ 常量/ 转换/ 、/ 消除/ 重复/ 等/ )/ ,/ 这里/ 是/ 将/ “/ A/ ./ a/ >/ 1/ ”/ 和/ “/ A/ ./ a/ >/ 4/ ”/ 合并/ 为/ “/ A/ ./ a/ >/ 4/ ”/ ,/ 从而/ 得到/ 列/ 之间/ 的/ 左/ 深树/ (/ 2/ )/ ,/ 接着/ 将/ (/ 2/ )/ 压入/ (/ 1/ )/ 中/ A/ 的/ 位置/ ,/ 也/ 就是/ 将/ A/ 表/ 的/ 所有/ 选择/ 操作/ (/ 2/ )/ 下推/ 到/ 了/ 关于/ A/ 表/ 的/ 连接/ 操作/ 下面/ ,/ 由此/ 生成/ 的/ 查询/ 执行/ 计划/ ,/ 将/ 使得/ (/ 2/ )/ 会/ 优先/ 于/ 关于/ A/ 表/ 的/ 连接/ 操作/ “/ A/ ./ c/ =/ B/ ./ c/ ”/ 执行/ ./ 同理/ 可/ 通过/ B/ 、/ C/ 的/ 表号/ 得到/ 经过/ 优化/ 处理/ 的/ (/ 3/ )/ 、/ (/ 4/ )/ ,/ 并/ 将/ 其/ 下推/ 到/ 左/ 深树/ 的/ 对应/ 叶子/ 结点/ 位置/ ./ Page74/ ./ 3/ 算法/ 分析/ 本文/ 的/ 二叉树/ 采用/ 链式/ 存储/ 结构/ ,/ 设/ n/ 为/ 遍历/ 的/ 树/ 中/ 结点/ 总数/ ./ 在/ 前面/ 介绍/ 的/ 算法/ 中/ ,/ 步骤/ 1/ 建立/ 表/ 之间/ 的/ 左深/ 连接/ 树/ ,/ 需从/ 查询/ 树根/ 结点/ 遍历/ 所有/ 的/ 内部/ 结点/ (/ 连接/ 操作/ 设计/ 为/ 二元/ 结点/ ,/ 即/ 有/ 在/ 初始/ 的/ 查询/ 树中/ 肯定/ 为/ 内部/ 结点/ ,/ 所以/ 不/ 需要/ 遍历/ 到/ 叶子/ 结点/ )/ ,/ 再/ 根据/ 初始/ 的/ 查询/ 树中/ 的/ 每个/ 结点/ 的/ 出度/ 是/ 0/ 或者/ 2/ 的/ 特点/ ,/ 内部/ 结点/ 数目/ (/ n/ -/ 1/ )/ // 2/ 是/ 随/ n/ 线性/ 变化/ 的/ ,/ 所以/ 算法/ LeftTree/ 的/ 时间/ 复杂度/ 为/ O/ (/ n/ )/ ;/ 同理/ 在/ 步骤/ 2/ 中/ 只/ 需/ 遍历/ 到/ and/ 二元/ 结点/ 下面/ 的/ 选择/ 叶子/ 结点/ 即可/ ,/ 算法/ Opt/ _/ L/ _/ tree/ 的/ 时间/ 复杂度/ 也/ 为/ O/ (/ n/ )/ ;/ 而/ 步骤/ 3/ 则/ 需/ 遍历/ 所有/ 的/ 查询/ 树/ 结点/ ,/ 所以/ 算法/ Pushdown/ 的/ 时间/ 复杂度/ 为/ O/ (/ n/ )/ ;/ 由此可知/ ,/ 3/ 个/ 算法/ 的/ 总/ 的/ 复杂度/ 为/ 3O/ (/ n/ )/ ,/ 即/ 本文/ 所提/ 方法/ 总/ 的/ 时间/ 复杂度/ 为/ O/ (/ n/ )/ ./ 5/ 实验/ 5.1/ 实验/ 环境/ 实验/ 运行/ 的/ 硬件/ 环境/ 为/ Intel/ (/ R/ )/ Core/ (/ TM/ )/ i3CPUM380/ @/ 2.53/ GHz/ ,/ 内存/ 2.00/ GB/ ,/ 操作系统/ 为/ Windows7/ ,/ 开发/ 环境/ 为/ Visual/ C++/ 6.0/ ./ 实验/ 以列/ 存储/ 数据仓库/ 管理系统/ DBMS3/ ./ 0/ 为/ 平台/ ,/ 它/ 是/ 以/ (/ rowid/ ,/ value/ )/ 形式/ 存放/ 每列/ 数据/ ,/ rowid/ 是/ 为了/ 重构/ 元组/ ,/ 在/ 每/ 一列/ 都/ 附加/ 一个/ 行号/ ,/ 这样/ 可以/ 将/ 每个/ 列/ 看作/ 是/ 〈/ rowid/ ,/ value/ 〉/ 形式/ 的/ 二元/ 表/ ;/ 其/ 优化/ 器/ 也/ 就/ 可以/ 采用/ 本文/ 提出/ 的/ 优化/ 策略/ 、/ 重写/ 规则/ 和/ 双层/ 左深/ 连接/ 树结构/ 来/ 对/ 初始/ 的/ 查询/ 计划/ 进行/ 优化/ 处理/ ./ 5.2/ 数据/ 集/ 实验/ 采用/ 的/ 数据/ 来源于/ 数据仓库/ 基准/ 数据/ 集/ SSB/ [/ 19/ ]/ ,/ 数据库/ 的/ 模型/ 是/ 星型/ 模型/ ,/ 我们/ 使用/ 基准/ 测试/ 提供/ 的/ 数据/ 产生器/ 生成/ 了/ SSB/ 的/ 数据/ 集/ 实例/ ./ 每个/ 实例/ 数据/ 集/ 的/ 大小/ 是/ 用/ 一个/ 增量/ 因子/ 控制/ 的/ ,/ 记为/ SF/ ./ 实验/ 选用/ SF/ =/ 1/ ,/ 事实/ 表/ lineorder/ 的/ 数据量/ 为/ 6000000/ 行/ ,/ 维表/ part/ 的/ 数据量/ 为/ 2000000/ 行/ 、/ Customer/ 的/ 数据量/ 为/ 30000/ 行/ 、/ Supplier/ 的/ 数据量/ 为/ 2000/ 行/ ./ 5.3/ 实验/ 结果/ 与/ 分析/ (/ 1/ )/ 从/ 前面/ 的/ 启发式/ 重写/ 规则/ 介绍/ 可知/ ,/ 查询/ 语句/ 中/ 能/ 合并/ 和/ 下推/ 的/ 选择/ 条件/ 直接/ 影响/ 着重/ 写/ 规则/ 对/ 性能/ 优化/ 的/ 显著性/ ,/ 为了/ 测试/ 重写/ 规则/ 在/ 优化/ 过程/ 的/ 有效性/ ,/ 在/ 此/ 设计/ 了/ 10/ 例/ 查询/ 语句/ 进行/ 实验/ ,/ 其中/ 前/ 5/ 例/ 选取/ 表/ Part/ 为/ 引用/ 表/ ,/ 逐渐/ 增加/ 关于/ 列/ partkey/ 、/ size/ 和/ color/ 的/ 选择/ 条件/ 的/ 个数/ ;/ 后/ 5/ 例/ 选取/ 表/ Lineorder/ 、/ Part/ 为/ 引用/ 表/ ,/ 并/ 带有/ Lineorder/ ./ partkey/ =/ Part/ ./ partkey/ 连接/ 操作/ ,/ 逐渐/ 增加/ 关于/ 两个/ 引用/ 表中列/ 的/ 选择/ 条件/ ./ 前/ 5/ 例和后/ 5/ 例/ 分别/ 在/ 相同/ 的/ 条件/ 下/ ,/ 重写/ 查询/ 计划/ 前后/ 的/ 执行/ 时间/ 对/ 比如/ 表/ 3/ 所示/ ./ Query10/ 从表/ 3/ 可/ 看到/ 10/ 例/ 查询/ 的/ 各自/ 的/ 执行/ 时间/ ,/ 先/ 来/ 对比/ 观察/ 前/ 5/ 例/ 查询/ 的/ 执行/ 时间/ ,/ Query1/ 到/ Query5/ 的/ 重写/ 后/ 的/ 执行/ 时间/ 对/ 比重/ 写前/ 的/ 有/ 显著/ 的/ 减少/ ,/ 且/ 减少/ 程度/ 递增/ ,/ 而/ Query1/ 到/ Query5/ 是/ 逐渐/ 增加/ 同表/ 同列/ 的/ 选择/ 条件/ ,/ 这/ 表明/ 本文/ 提出/ 的/ 重写/ 规则/ 能/ 有效/ 合并/ 同表/ 同列/ 选择/ 条件/ ,/ 使得/ 查询/ 计划/ 在/ 执行/ 中/ 能/ 消除/ 重复/ 和/ 一次性/ 处理/ 完/ 一列/ 的/ 所有/ 选择/ 操作/ ,/ 减少/ 查询/ 的/ 执行/ 时间/ ,/ 从而/ 达到/ 优化/ 的/ 目的/ ;/ 再/ 来/ 观察/ 后面/ 5/ 例/ 查询/ 语句/ ,/ Query6/ 到/ Query10/ 重写/ 后/ 的/ 执行/ 时间/ 比较/ 重写/ 前有/ 大大的/ 减少/ ,/ 并/ 随着/ 引用/ 表/ 相关/ 列/ 选择/ 条件/ 的/ 增多/ (/ 可/ 下推/ 选择/ 条件/ 的/ 增多/ )/ ,/ 重写/ 后/ 的/ 执行/ 时间/ 相对/ 重写/ 前/ 减少/ 的/ 更/ 多/ ,/ 这/ 也/ 较/ 好/ 地/ 验证/ 了/ 通过/ 将/ 选择/ 条件/ 下推/ 到/ 复杂/ 的/ 操作/ 前面/ ,/ 可/ 尽早/ 执行/ 选择/ 操作/ ,/ 有效/ 地/ 减少/ 中间/ 关系/ 的/ 大小/ ,/ 使得/ 查询/ 的/ 执行/ 时间/ 大大/ 减小/ ;/ 此时/ 再/ 对比/ 前面/ 5/ 例/ 重写/ 前后/ 执行/ 时间/ 上/ 的/ 变化/ ,/ 可/ 看出/ 下推/ 选择/ 后/ 带来/ 的/ 时间/ 效率/ 提升/ 的/ 更/ 高/ ,/ 表明/ 下推/ 策略/ 的/ 优化/ 程度/ 比/ 同列/ 合并/ 要/ 高/ ,/ 体现/ 了/ 它/ 的/ 必要性/ ;/ 因为/ 连接/ 操作/ 普遍/ 比/ 其它/ 操作/ 的/ 代价/ 更高/ ,/ 也/ 造成/ 了/ 后/ 5/ 例/ 的/ 执行/ 时间/ 基本/ 比前/ 5/ 例/ 的/ 偏/ 高/ 的/ 现象/ ;/ 通过/ 分析/ 这些/ 重写/ 规则/ ,/ 不难看出/ 它们/ 都/ 会/ 大大/ 减小/ 中间/ 结果/ ,/ 使得/ 内存/ 尽早/ 释放/ 对/ 查询/ 结果/ 无用/ 的/ 数据/ ,/ 从而/ 提高/ 了/ 空间/ 利用率/ ,/ 鉴于/ 重写/ 规则/ 对/ 查询/ 时间/ 和/ 空间/ 性能/ 的/ 提升/ ,/ 表明/ 本文/ 提出/ 的/ 规则/ 在/ 查询/ 优化/ 过程/ 中/ 的/ 必要性/ 和/ 有效性/ ./ (/ 2/ )/ 前/ 文/ 论述/ 过/ 左深/ 连接/ 树结构/ 的/ 适用性/ ,/ 它/ 的/ 优化/ 性能/ 与/ 查询/ 相关/ 表和列/ 的/ 个数/ 有着/ 密切/ 联/ Page8/ 系/ ./ 为了/ 测试/ 双层/ 左深/ 连接/ 树结构/ 能够/ 带来/ 查询/ 性能/ 提升/ ,/ 实验设计/ 4/ 种/ 查询/ 计划/ 树结构/ :/ 表/ 之间/ 连接/ 和/ 同/ 表列/ 之间/ 都/ 采用/ 非/ 左深/ 连接/ 树/ (/ RR/ )/ 、/ 表/ 之间/ 采用/ 左深/ 连接/ 树而同/ 表列/ 之间/ 采用/ 非/ 左深/ 连接/ 树/ (/ LR/ )/ 、/ 表/ 之间/ 采用/ 非/ 左深/ 连接/ 树而同/ 表列/ 之间/ 采用/ 左深/ 连接/ 树/ (/ RL/ )/ 、/ 表/ 之间/ 和/ 同/ 表列/ 之间/ 都/ 采用/ 左深/ 连接/ 树/ (/ LL/ )/ ,/ 在/ 此/ 设计/ 了/ 逐步/ 增加/ 引用/ 表和列/ 的/ 个数/ (/ 当/ 引用/ 表和列/ 的/ 个数/ 超过/ 2/ 个/ 才能/ 构建/ 典型/ 的/ 左深/ 连接/ 树结构/ )/ 的/ 10/ 例/ 查询/ 语句/ ,/ 其中/ 查询/ 1/ 的/ 引用/ 表/ 只有/ Lineorder/ 表/ ,/ 在/ 此基础/ 上/ 逐步/ 加入/ 引用/ 表/ Part/ 、/ Customer/ 、/ Supplier/ 表/ ,/ 同时/ 增加/ 每张/ 表/ 的/ 相关/ 列/ 的/ 选择/ 条件/ ./ 这/ 10/ 例/ 查询/ 语句/ 在/ 查询处理/ 过程/ 分别/ 采用/ 这/ 4/ 种/ 结构/ ,/ 在/ 相同/ 的/ 条件/ 下/ 其/ 执行/ 时间/ 实验/ 结果/ 如图/ 5/ 所示/ ./ 从图/ 中/ 观测/ 4/ 条线/ 的/ 高低/ 位置/ ,/ 对于/ 相同/ 的/ 查询/ 语句/ ,/ RR/ 位置/ 多数/ 偏高/ ,/ 花费/ 的/ 时间/ 最/ 多/ ,/ LL/ 位置/ 多数/ 偏低/ ,/ 花费/ 的/ 时间/ 最少/ ,/ 实践/ 论证/ 了/ 左深/ 连接/ 树结构/ 在/ 本文/ 的/ 优化/ 机制/ 中/ 能/ 进一步/ 促进/ 查询/ 优化/ ./ 从图/ 中/ 也/ 可/ 看到/ 四条线/ 有时/ 会/ 有/ 重合/ 的/ 点/ ,/ 这/ 是因为/ 当/ 查询/ 中/ 引用/ 表/ 的/ 个数/ 或者/ 列/ 的/ 个数/ 没有/ 超过/ 2/ 个/ 的/ 时候/ ,/ 左深/ 连接/ 树和非/ 左深/ 连接/ 树/ 的/ 结构/ 是/ 一样/ 的/ ,/ 也/ 就/ 不会/ 带来/ 执行/ 时间/ 上/ 的/ 变化/ ,/ 但/ 当表/ 的/ 个数/ 或者/ 列/ 的/ 个数/ 超过/ 2/ 个/ 的/ 时候/ ,/ 左深/ 连接/ 树和非/ 左深/ 连接/ 树/ 的/ 结构/ 差异/ 就/ 直接/ 影响/ 着/ 各自/ 的/ 查询/ 执行/ 时间/ ,/ 正如/ 图中/ LL/ 这条线/ 除去/ 重合/ 的/ 点/ ,/ 一直/ 处于/ 其余/ 三条/ 线/ 下方/ ,/ 表明/ 了/ 采用/ 左深/ 连接/ 树结构/ 的/ 查询/ 计划/ 的/ 执行/ 效率/ 更高/ ./ (/ 3/ )/ 结合/ 前面/ 两个/ 实验/ 提到/ 的/ 重写/ 规则/ 和/ 左深/ 连接/ 树结构/ ,/ 在/ 此/ 提出/ 下面/ 4/ 种/ 情况/ :/ 使用/ 重写/ 规则/ 和/ 左深/ 连接/ 树结构/ (/ TL/ )/ ;/ 使用/ 重写/ 规则/ 和/ 非/ 左深/ 连接/ 树结构/ (/ TR/ )/ ;/ 不/ 使用/ 重写/ 规则/ ,/ 但/ 使用/ 左深/ 连接/ 树结构/ (/ FL/ )/ ;/ 既/ 不/ 使用/ 重写/ 规则/ ,/ 也/ 不/ 使用/ 左深/ 连接/ 树结构/ (/ FR/ )/ ./ 实验设计/ 了/ 10/ 例/ 查询/ 语句/ ,/ 查询/ 1/ 到/ 查询/ 10/ 逐步/ 增加/ 可/ 合并/ 、/ 下推/ 的/ 选择/ 条件/ 以及/ 查询/ 引用/ 表和列/ 的/ 数量/ ./ 在/ 相同/ 的/ 条件/ 下/ ,/ 这/ 4/ 种/ 情况/ 下/ 的/ 执行/ 时间/ 如图/ 6/ 所示/ ./ 图/ 6/ 基于/ 重写/ 规则/ 和/ 左深/ 连接/ 树/ 的/ 执行/ 时间/ 比较/ 从图/ 中/ 可/ 看出/ ,/ FR/ 执行/ 时间/ 最/ 多/ ,/ TL/ 执行/ 时间/ 最少/ ,/ 由此/ 充分/ 验证/ 了/ 同时/ 使用/ 重写/ 规则/ 和/ 左深/ 连接/ 树结构/ 能/ 更/ 大/ 提升/ 优化/ 器/ 的/ 有效性/ ,/ 使得/ 查询/ 效率/ 更高/ ,/ 也/ 就/ 达到/ 了/ 本文/ 提出/ 这些/ 优化/ 方法/ 的/ 目的/ ./ 6/ 总结/ 与/ 展望/ 基于/ 传统/ 的/ 行/ 存储/ 的/ 启发式/ 查询/ 优化/ 方法/ ,/ 本文/ 分析/ 了/ 列/ 存储/ 查询/ 优化/ 与行/ 存储/ 的/ 区别/ ,/ 重点/ 抓住/ 列/ 存储/ 数据仓库/ 的/ 处理/ 对象/ 已经/ 具体/ 到/ 每列/ 的/ 关键点/ ,/ 进而/ 提出/ 了/ 适合/ 于列/ 存储系统/ 优化/ 策略/ 、/ 重写/ 规则/ 和/ 双层/ 左深/ 连接/ 树结构/ ./ 通过/ 实验/ 验证/ 了/ 查询/ 语句/ 通过/ 本文/ 的/ 启发式/ 优化/ 机制/ ,/ 能/ 得到/ 可/ 生成/ 最优/ 计划/ 的/ 候选/ 树/ ,/ 大大提高/ 了/ 查询/ 效率/ ./ 未来/ 的/ 工作/ 将/ 继续/ 完善/ 本文/ 提出/ 的/ 启发式/ 优化/ 机制/ ,/ 重点/ 将/ 转向/ 将/ goup/ _/ by/ 聚集/ 的/ 一些/ 选择/ 操作/ 上推/ 到/ 连接/ 操作/ 下面/ 和/ 将子/ 查询/ 转化/ 为/ 半/ 连接/ 的/ 重写/ 规则/ ,/ 同时/ 考虑/ 相关/ 列/ 上/ 是否/ 建有/ 索引/ 来/ 调整/ 该列/ 在/ 左深/ 连接/ 树中/ 位置/ 的/ 策略/ ,/ 使得/ 本文/ 提出/ 的/ 优化/ 机制/ 得到/ 进一步/ 完善/ ,/ 以/ 获得/ 查询/ 效率/ 的/ 最大/ 提升/ ./ 

