Page1/ 网络协议/ 的/ 自动化/ 模糊/ 测试/ 漏洞/ 挖掘/ 方法/ 李伟明/ 张爱芳/ 刘建财/ 李之棠/ (/ 华中科技大学/ 计算机/ 学院/ 武汉/ 430074/ )/ 摘要/ 随着/ 网络应用/ 越来越/ 复杂/ 和/ 重要/ ,/ 对/ 网络协议/ 的/ 安全性/ 要求/ 也/ 越来越/ 高/ ./ 模糊/ 测试/ (/ FuzzTesting/ )/ 作为/ 一种/ 重要/ 的/ 测试/ 手段/ ,/ 通过/ 大量/ 数据/ 的/ 注入/ 来/ 测试/ 网络协议/ 的/ 安全/ ,/ 能够/ 发现/ 拒绝服务/ 、/ 缓冲区/ 溢出/ 和/ 格式化/ 字符串/ 等/ 多种/ 重要/ 漏洞/ ./ 但是/ 手工/ 进行/ FuzzTesting/ 需要/ 精确/ 了解/ 网络协议/ 细节/ 并/ 需要/ 繁重/ 的/ 工作/ 来/ 构造/ 大量/ 测试数据/ 集/ ,/ 导致/ 覆盖率/ 有限/ ,/ 效果/ 也/ 不好/ ./ 为了/ 解决/ 这个/ 问题/ ,/ 文中/ 结合/ 网络协议/ 逆向/ 工程/ 和/ FuzzTesting/ 技术/ ,/ 提出/ 了/ 一种/ 能够/ 自动化/ 识别/ 各种/ 网络协议/ 并/ 产生/ 模糊/ 器/ 进行/ FuzzTesting/ 的/ 漏洞/ 挖掘/ 方法/ ./ 这种/ 方法/ 通过/ 报文/ 分类/ 、/ 多/ 序列/ 比/ 对/ 、/ 特定/ 域/ 识别/ 、/ 模糊/ 器/ 生成/ 多个/ 阶段/ ,/ 自动识别/ 网络协议/ 报文/ 结构/ 并/ 进行/ FuzzTesting/ ./ 经过/ 测试/ FTP/ 、/ TNS/ 、/ EM/ 、/ ISQLPlus/ 等/ 多种/ 已知/ 和/ 未知/ 网络协议/ ,/ 结果表明/ 这种/ 方法/ 在/ 漏洞/ 挖掘/ 方面/ 效果/ 超过/ 手工/ 分析/ ,/ 并/ 显著/ 提升/ 了/ 测试/ 效率/ ,/ 为/ 提高/ 网络协议/ 的/ 安全性/ 提供/ 了/ 良好/ 的/ 基础/ ,/ 具有/ 重要/ 的/ 应用/ 价值/ ./ 关键词/ 协议/ 逆向/ 工程/ ;/ 模糊/ 测试/ ;/ 漏洞/ 挖掘/ 1/ 引言/ 传输/ 的/ 敏感/ 信息/ ./ 但是/ 如何/ 测试/ 网络协议/ 安全性/ 一直/ 是/ 个/ 非常/ 困难/ 的/ 问题/ ./ 特别/ 是/ 测试/ 未公开/ 网络协议/ (/ closedprotocols/ )/ 的/ 安全性/ 对于/ 网络安全/ 有着/ 重要/ 的/ 意义/ ,/ 因为/ 大量/ 厂商/ 并/ 没有/ 公开/ 自己/ 软件系统/ 网络协议/ 只有/ 安全/ 的/ 设计/ 和/ 实现/ 才能/ 保护/ 用户/ Page2/ 使用/ 的/ 网络协议/ 细节/ ,/ 例如/ MicroSoft/ 的/ 网络/ 文件共享/ SMB/ 协议/ 、/ Oracle/ 数据库/ 访问/ 的/ TNS/ 协议/ 、/ 各种/ IPTV/ 和/ 及时/ 通信软件/ 使用/ 的/ 协议/ ./ 这些/ 未公开/ 网络协议/ 在/ 网络/ 中/ 被/ 大量/ 使用/ ,/ 一旦/ 其/ 未公开/ 漏洞/ 被/ 攻击者/ 利用/ ,/ 将/ 产生/ 巨大/ 的/ 危害/ ./ 因此/ ,/ 本文/ 提出/ 了/ 一种/ 自动化/ 识别/ 各种/ 网络协议/ 报文/ 结构/ 并/ 进行/ 模糊/ 检测/ (/ FuzzTesting/ )/ 的/ 方法/ ,/ 能够/ 找到/ 协议/ 中/ 拒绝服务/ 、/ 缓冲区/ 溢出/ 和/ 格式化/ 字符串/ 等/ 多种/ 重要/ 漏洞/ ,/ 既/ 可以/ 避免/ 手工/ 测试/ 带来/ 的/ 繁重/ 工作/ 和/ 低效率/ ,/ 又/ 能/ 深入/ 测试/ 网络协议/ 的/ 安全性/ ./ 本文/ 第/ 2/ 节/ 介绍/ 网络/ 逆向/ 工程/ 以及/ 模糊/ 检测/ 漏洞/ 挖掘/ 方法/ 的/ 研究/ 现状/ ,/ 并/ 提出/ 本文/ 的/ 总体/ 思路/ 和/ 实现/ 结构/ ;/ 第/ 3/ 节/ 介绍/ 数据/ 报文/ 分类/ 方法/ ;/ 第/ 4/ 节/ 详细/ 介绍/ 如何/ 对/ 未知/ 网络协议/ 进行/ 识别/ ,/ 并/ 对/ 采用/ 的/ 多/ 序列/ 比/ 对/ 中/ 的/ 渐进/ 比/ 对/ 和/ 遗传算法/ 进行/ 比较/ ,/ 提出/ 改进/ 的/ 渐进/ 比/ 对/ 算法/ 和/ 优化/ 的/ NeedlemanWunsch/ 算法/ ;/ 第/ 5/ 节则/ 进一步/ 介绍/ 如何/ 自动化/ 识别/ 网络协议/ 的/ 特定/ 域/ ;/ 第/ 6/ 节/ 描述/ 如何/ 将/ 识别/ 出/ 的/ 网络协议/ 转化/ 为/ Fuzzer/ ,/ 构造/ 针对/ 目标/ 协议/ 的/ 模糊/ 测试/ 器/ ;/ 第/ 7/ 节是/ 实验/ 测试/ ,/ 通过/ 具体/ 数据分析/ 自动化/ 漏洞/ 挖掘/ 方法/ 的/ 有效性/ ;/ 第/ 8/ 节对/ 工作/ 进行/ 总结/ 和/ 展望/ ./ 2/ 介绍/ 在/ 网络协议/ 逆向/ 工程/ 领域/ ,/ 国内外/ 进行/ 了/ 较为/ 深入/ 的/ 研究/ ,/ 主要/ 分为/ 两个/ 大/ 的/ 方向/ :/ 一个/ 方向/ 是/ 单纯/ 利用/ 网络流量/ 来/ 推测/ 网络协议/ ,/ 这/ 类/ 方法/ 也/ 称为/ 基于/ “/ NetworkTrace/ ”/ 的/ 方法/ ;/ 另外/ 一个/ 方向/ 是/ 对/ 实现/ 网络协议/ 的/ 服务器程序/ 进行/ 二进制/ 的/ 动态/ 跟踪/ 分析/ ,/ 通过/ 跟踪/ 二进制/ 文件/ 对/ 报文/ 的/ 处理/ 流程/ 对/ 报文/ 进行/ 解析/ ,/ 这种/ 方法/ 也/ 称为/ 基于/ “/ TaintedData/ ”/ 的/ 方法/ ./ 基于/ “/ NetworkTrace/ ”/ 的/ 方法/ ,/ 典型/ 的/ 有/ 2004/ 年/ 由/ MarshallBeddoe/ 启动/ 的/ “/ ProtocolInformaticsproject/ ”/ 分析/ 未知/ 或者/ 未公开/ 的/ 网络协议/ 的/ 结构/ ①/ ./ 这个/ 项目/ 的/ 目标/ 是/ 类比/ 生物学/ 从/ DNA/ 中/ 查找/ 产生/ 氨基酸/ 的/ 蛋白质/ 的/ 算法/ ,/ 通过/ 对/ 大量/ 网络流量/ 进行/ 对比/ 分析/ ,/ 最终/ 分析/ 协议/ 结构/ ./ 具体方法/ 是/ 首先/ 读取/ 目标/ 协议/ 的/ 抓/ 包/ 文件/ 形成/ 序列/ 集/ ./ 然后/ 通过/ 局部/ 序列/ 比/ 对/ 算法/ 计算/ 这些/ 序列/ 之间/ 的/ 相对/ 距离/ ,/ 形成/ 距离/ 矩阵/ ./ 接着/ 使用/ 非/ 加权/ 成对/ 群/ 算术平均/ 法/ (/ unweightedpairgroupmethodwitharithmeticmean/ )/ ,/ 构造/ 一棵/ 向导/ 树/ ,/ 实现/ 序列/ 的/ 聚类/ ,/ 每/ 一类/ 中/ 的/ 序列/ 被/ 认为/ 是/ 具有/ 很大/ 相似性/ ./ 最后/ ,/ 针对/ 每/ 一个/ 聚类/ ,/ 利用/ 渐进/ 比/ 对/ 算法/ 遍历/ 系统/ 树/ ,/ 完成/ 多/ 序列/ 比/ 对/ ./ 根据/ 比/ 对/ 结果/ ,/ 就/ 可以/ 区分/ 固定/ 不变/ 的/ 区域/ 和/ 动态/ 改变/ 的/ 区域/ ./ 但是/ 这种/ 方法/ 仅仅/ 提取/ 了/ 协议/ 中/ 的/ 可变/ 和/ 不可/ 变域/ ,/ 划分/ 粒度/ 很粗/ ,/ 同时/ 分析/ 结论/ 也/ 对/ 流量/ 的/ 依赖性/ 很强/ ./ 另外/ ,/ 其聚类/ 方法/ 以/ LCS/ (/ LongestCommonSubsequence/ )/ 匹配/ 数量/ 作为/ 参考/ 标准/ ,/ 因此/ 无法/ 区分/ 和/ 提取/ 序列/ 中/ 相对/ 简短/ 的/ 协议/ 域/ ./ 总之/ PI/ 项目/ 只是/ 处于/ 初步阶段/ ,/ 算法/ 还/ 很/ 不/ 成熟/ ./ 2005/ 年/ CorradoLeita/ 、/ KenMermoud/ 和/ MarcDacier/ 提出/ 使用/ PI/ 项目/ 改造/ Honeyd/ ,/ 实现/ Honeyd/ 配置/ 脚本/ 的/ 自动/ 提取/ [/ 1/ ]/ ./ 文章/ 的/ 主要/ 设计/ 思路/ 由/ 4/ 个/ 步骤/ 组成/ :/ 首先/ 从/ 网络/ 抓包/ 文件/ 中/ 获取/ 数据包/ 的/ Message/ 序列/ ,/ 然后/ 分析/ 这些/ 序列/ ,/ 为/ 每个/ 请求/ 维护/ 一个/ 状态机/ ,/ 记录/ 客户端/ 和/ 服务器之间/ 的/ 信息/ 交互/ 过程/ ./ 然而/ ,/ 此时/ 的/ 状态机/ 没有/ 进行/ 任何/ 的/ 语义/ 分析/ ,/ 不能/ 完成/ 实际/ 的/ 交互/ 动作/ ,/ 因此/ 需要/ 优化/ 状态机/ ,/ 最后/ 完成/ 脚本/ 的/ 自动/ 生成/ ./ 同样/ Cui/ 和/ Paxson/ 等/ 人/ 提出/ 了/ 一种/ 网络协议/ 识别/ 和/ 自动/ 恢复/ 的/ 解决方案/ RolePlayer/ [/ 2/ ]/ ./ 其/ 设计/ 思路/ 是/ ,/ 在/ 获取/ 用户/ 输入/ 参数/ 的/ 条件/ 下/ ,/ 通过/ 分析/ 少量/ 样例/ 数据流/ ,/ 采用/ 算法/ 定位/ 终端/ 信息/ (/ IP/ 、/ hostname/ )/ 、/ 用户/ 参数/ 、/ 长度/ 域/ 、/ Cookie/ 、/ 任意/ 域/ ,/ 然后/ 根据/ 这些/ 信息/ 生成/ 交互/ 脚本/ ./ 此后/ ,/ 该/ 系统/ 根据/ 这些/ 脚本/ 信息/ 识别/ 任意/ 一段/ 新/ 的/ 流量/ 是否/ 符合/ 已经/ 学习/ 的/ 协议/ ,/ 并且/ 可以/ 通过/ 关键/ 域/ 替换/ ,/ 实现/ 自动/ 交互/ 的/ 效果/ ./ 在/ 另外/ 一篇/ 论文/ 中/ [/ 3/ ]/ ,/ 他们/ 结合/ HoneyFarm/ 和/ 上面/ 提到/ 的/ Role/ -/ Player/ 技术/ ,/ 实现/ 了/ 一种/ 全新/ 的/ 恶意代码/ 捕获/ 框架/ GQ/ :/ 所有/ 进入/ 的/ 流量/ ,/ 首先/ 进行/ 匹配/ ,/ 如果/ 发现/ 是/ 已知/ 协议/ ,/ 则/ 直接/ 由/ RolePlayer/ 响应/ ,/ 一旦/ 发现/ 未知/ 协议/ ,/ 则/ 将/ 这些/ 流量/ 重定向/ 到/ 高/ 交互/ 蜜罐/ 中/ 并/ 扮演/ 代理服务器/ 的/ 角色/ ,/ 以便/ 捕获/ 到/ 最新/ 的/ 恶意代码/ 和/ 恶意/ 攻击/ ./ 连续/ 4/ 个/ 月/ 的/ 测试/ 中/ ,/ GQ/ 捕获/ 了/ 66/ 种/ 不同/ 的/ 蠕虫/ ,/ 这/ 充分说明/ ,/ RolePlayer/ 在/ GQ/ 中/ 确实/ 发挥/ 了/ 重要/ 而且/ 有效/ 的/ 作用/ ./ 但是/ 这种/ 方法/ 没有/ 分析/ 协议/ 结构/ ,/ 可变性/ 不高/ ,/ 流量/ 稍微/ 有点/ 变化/ 就/ 导致/ 无法/ 正常/ 响应/ ./ 在/ 随后/ 的/ 研究/ 中/ ,/ 他们/ 引入/ 了/ Discover/ 系统/ [/ 4/ ]/ ,/ 试图/ 从/ 大量/ 的/ 网络/ 报文/ 中/ 识别/ 出同/ 类型/ 报文/ ,/ 然后/ 分析/ 报文格式/ ,/ 这种/ 方法/ 显然/ 比/ RolePlayer/ 更加/ 实用/ ,/ 但是/ 文章/ 缺乏/ 对于/ Discover/ 所/ 采用/ 方法/ 的/ 精确/ 定义/ ./ ①/ Networkprotocolanalysisusingbioinformaticsalgorithms/ ./ Page3/ 基于/ “/ TaintedData/ ”/ 的/ 协议/ 识别方法/ 是/ 建立/ 在/ 动态/ 污点/ 分析/ 技术/ 基础/ 之上/ 的/ ./ 动态/ 污点/ 分析/ 技术/ 是/ 近几年/ 兴起/ 的/ 一种/ 解决方案/ ,/ 它/ 可以/ 在/ 二进制/ 代码/ 层/ 实现/ 对/ 不可/ 信/ 数据/ 的/ 传播/ 情况/ 的/ 跟踪/ 和/ 分析/ ,/ Argos/ [/ 5/ ]/ 和/ TaintCheck/ [/ 6/ ]/ 就是/ 两个/ 典型/ 的/ 实例/ ./ 基于/ “/ TaintedData/ ”/ 的/ 协议/ 识别方法/ 将/ 所有/ 网络/ 传输数据/ 作为/ 不可/ 信/ 数据源/ ,/ 通过/ 监控/ 服务器/ 处理/ 这些/ 不可/ 信/ 数据/ 的/ 流程/ ,/ 获取/ 协议/ 结构/ 信息/ ,/ 因此/ 其/ 准确性/ 要/ 好/ 于/ 第一种/ 方法/ ./ 例如/ 服务器程序/ 在/ 污点/ 数据/ 中/ 搜索/ 非/ 污点/ 数据/ “/ Username/ ”/ ,/ 那么/ 就/ 可以/ 肯定/ 污点/ 数据/ 中/ 的/ “/ Username/ ”/ 是/ 报文/ 结构/ 中/ 的/ 一个/ 关键字/ ./ Wondracek/ 详细描述/ 了/ 这种/ 方法/ 的/ 机制/ [/ 7/ ]/ :/ 利用网络/ 报文/ 作为/ 输入/ 的/ TaintedData/ ,/ 在/ 指令/ 级/ 对/ 其/ 进行/ 监控/ ,/ 然后/ 根据/ 监控/ 信息/ 分析/ 对应/ 报文/ 的/ 语义/ 特征/ ./ 最后/ 根据/ 多次/ 监控/ 的/ 分析/ 结果/ ,/ 将/ 所有/ 相同/ 格式/ 报文/ 的/ 语义/ 信息/ 融合/ ,/ 提取/ 出/ 一个/ 通用/ 的/ 报文/ 结构/ ./ Caballero/ 等/ 人/ 提出/ 的/ Polyglot/ 系统/ 也/ 是/ 基于/ 类似/ 的/ 思想/ 实现/ 的/ [/ 8/ ]/ ./ Comparetti/ 设计/ 的/ Prospex/ [/ 9/ ]/ 在/ 引用/ 以上/ 方法/ 识别/ 单个/ 报文/ 结构/ 的/ 同时/ ,/ 也/ 利用/ 污点/ 数据/ 跟踪/ 过程/ 中/ 获取/ 的/ 统计/ 特征/ (/ 包括/ 系统/ 调用/ 特征/ 、/ 文件系统/ 操作/ 特征/ 等/ )/ 对/ 报文/ 进行/ 聚类/ ./ 此外/ ,/ 文中/ 还/ 引入/ 状态机/ 识别/ 机制/ 并/ 简化/ ,/ 最终/ 将/ 客户机/ 和/ 服务器/ 的/ 交互/ 过程/ 以/ DFA/ 的/ 方式/ 显示/ 出来/ ,/ 达到/ 解析/ 交互/ 流程/ 和/ 报文/ 结构/ 的/ 目的/ ./ 然而/ 这种/ 基于/ “/ TaintedData/ ”/ 的/ 方法/ 也/ 存在/ 一些/ 限制/ :/ 它/ 需要/ 得到/ 服务器程序/ 并/ 让/ 其/ 在/ 指定/ 环境中运行/ ;/ 其次/ ,/ 跟踪/ 复杂/ 程序运行/ 也/ 会/ 产生/ 大量/ 数据/ 需要/ 分析/ 并且/ 降低/ 服务器/ 性能/ ./ 关于/ FuzzTesting/ 的/ 研究/ 也/ 很/ 活跃/ ./ FuzzTesting/ 是/ 一种/ 通过/ 外部/ 输入/ 数据/ 影响/ 内部/ 程序执行/ 的/ 测试/ 技术/ ./ 它/ 的/ 基本原理/ 是/ 将/ 尽可能/ 多/ 的/ 可能/ 导致/ 程序/ 出现/ 问题/ 的/ 错误/ 数据/ 注入/ 应用程序/ 中/ ,/ 观察/ 运行/ 结果/ ,/ 通过观察/ 和/ 分析/ 程序运行/ 的/ 错误/ 来/ 挖掘/ 软件/ 的/ 脆弱/ 点/ ./ FuzzTesting/ 看似/ 简单/ 并且/ 需要/ 大量/ 数据/ 和/ 注入/ 点/ ,/ 但/ 它/ 却/ 能/ 揭示/ 出/ 程序/ 中/ 的/ 重要/ 漏洞/ ,/ 而且/ 通过/ FuzzTesting/ 挖掘/ 到/ 的/ 漏洞/ 通常/ 都/ 比较严重/ ./ Miller/ [/ 10/ ]/ 用/ FuzzTesting/ 测试/ 了/ 大量/ 的/ Unix/ 程序/ ,/ 结果/ 发现/ 超过/ 40/ %/ 的/ 命令行/ 程序/ 可以/ 出现/ 内存/ 出错/ 和/ 死循环/ ,/ 同样/ 超过/ 40/ %/ 的/ X/ -/ Windows/ 程序/ 也/ 会/ 出错/ ,/ 显示/ 了/ FuzzTesting/ 的/ 有效性/ ./ 在/ 此基础/ 上/ Forrester/ [/ 11/ ]/ 采用/ 类似/ 的/ 方法/ 对/ WindowsGUI/ 程序/ 进行/ FuzzTesting/ ,/ 测试数据/ 注入/ 点/ 是/ 键盘/ 鼠标/ 输入/ 和/ 消息/ ,/ 同样/ 使/ 21/ %/ 的/ 程序/ 内存/ 出错/ 和/ 24/ %/ 的/ 程序/ 陷入/ 死循环/ ,/ 说明/ 了/ FuzzTesting/ 对/ 不同/ 平台/ 程序/ 都/ 是/ 有效/ 的/ ./ 现在/ FuzzTesting/ 已经/ 发展/ 成为/ 一种/ 模块化/ 的/ 测试方法/ ,/ 典型/ 的/ 软件/ 是/ SPIKE/ [/ 12/ ]/ ./ SPIKE/ 是/ Immunitysec/ 公司/ 的/ DaveAitel/ 写/ 的/ 一个/ 黑盒/ 安全/ 测试工具/ ,/ 主要/ 可以/ 测试/ 应用程序/ 输入/ 和/ 网络协议/ 报文/ ./ 微软/ 的/ GodefroidPatrice/ 在/ FuzzTesting/ 方法/ 中/ 引入/ 了/ 白盒/ 测试/ 的/ 方法/ ,/ 使得/ Fuzz/ 更加/ 精确/ ,/ 覆盖率/ 也/ 更/ 高/ [/ 13/ ]/ ./ 国内/ 研究者/ 张玉清/ 教授/ 分别/ 对/ MP3/ 播放器/ 、/ TFTP/ 客户端/ 进行/ 了/ FuzzTesting/ [/ 14/ -/ 15/ ]/ ./ FuzzTesting/ 的/ 主要/ 问题/ 在于/ 它/ 是/ 一种/ 盲/ 注入/ 的/ 方式/ ,/ 手工/ 进行/ FuzzTesting/ 工作/ 量过大/ ,/ 甚至/ 几乎/ 无法/ 进行/ 比较/ 全面/ 的/ 测试/ ,/ 导致/ FuzzTesing/ 的/ 实用价值/ 受到/ 很大/ 影响/ ./ 本文/ 提出/ 的/ 方法/ 建立/ 在/ 这/ 两个/ 领域/ 的/ 研究/ 基础/ 上/ ,/ 提出/ 一个/ 适用/ 于/ FuzzTesting/ 的/ 网络协议/ 自动识别/ 的/ 方法/ ./ 由于/ FuzzTesting/ 需要/ 输入/ 大量/ 数据/ ,/ 为了/ 避免/ 在/ 服务器端/ 产生/ 过量/ 的/ 二进制/ 执行/ 信息/ ,/ 本/ 方法/ 基于/ “/ NetworkTrace/ ”/ ,/ 但是/ 也/ 引入/ 了/ 简单/ 的/ 服务器/ 监控/ 机制/ ./ 重点/ 在/ 通过/ 分析/ 网络协议/ 的/ 报文/ ,/ 自动化/ 精细/ 识别/ 网络/ 报文/ 中/ 各个/ 域/ ,/ 并/ 推断/ 其/ 数据类型/ ./ 然后/ 根据/ 域/ 的/ 划分/ ,/ 自动/ 产生/ SPIKE/ 所/ 需/ 的/ FuzzTesting/ 脚本/ ,/ 对/ 每个/ 域/ 进行/ 注入/ 测试/ ./ 测试/ 过程/ 中/ 仅仅/ 对/ 服务器端/ 运行/ 结果/ 进行/ 监控/ ,/ 一旦/ 发现/ 服务器端/ 出现/ 拒绝服务/ 或者/ 溢出/ 错误/ 则/ 记录/ 相应/ 的/ 输入/ 和/ 输出/ ./ 通过/ 这种/ 方式/ 来/ 发现/ 网络协议/ 设计/ 和/ 实现/ 中/ 的/ 漏洞/ ./ 经过/ 对/ 典型/ 的/ 公开/ 和/ 未公开/ 网络协议/ 的/ 测试/ ,/ 证明/ 这种/ 方法/ 是/ 非常/ 有效/ 的/ ,/ 其/ 主要/ 的/ 系统结构/ 如图/ 1/ 所示/ ./ 图/ 1/ 描述/ 了/ 本/ 方法/ 的/ 核心/ 流程/ ./ 本/ 方法/ 主要/ 部分/ 都/ 采用/ 自动化/ 的/ 方法/ ,/ 但是/ 需要/ 一个/ 手工/ 截获/ 报文/ 的/ 阶段/ ,/ 即/ 使用/ Tcpdump/ 或者/ WireShark/ 等/ 工具/ ,/ 截获/ 网络协议/ 的/ 报文/ ./ 这个/ 阶段/ 需要/ 用户/ 对/ 网络服务/ 多次/ 使用/ (/ 一般/ 3/ ~/ 4/ 次/ )/ ,/ 然后/ 将/ 每次/ 截获/ 的/ 报文/ 保存/ 到/ 一个/ PCAP/ 文件/ 中/ ,/ 以/ 多个/ PCAP/ 文件/ 作为/ 自动化/ 阶段/ 的/ 输入/ ./ 这个/ 阶段/ 不/ 需要/ 进行/ 协议/ 识别/ 或者/ 测试/ 工作/ ,/ 因此/ 易于/ 操作/ 和/ 实现/ ./ 在/ 自动化/ 部分/ 主要/ 分为/ 两个/ 阶段/ :/ 协议/ 识别/ 和/ FuzzTesting/ ./ 在/ 协议/ 识别/ 阶段/ ,/ 首先/ 采用/ 类型/ 匹配/ ,/ 将/ 不同/ 的/ PCAP/ 文件/ 中同/ 类型/ 的/ 报文/ 序列/ 提取/ 出来/ ,/ 作为/ 一个/ 报文/ 组/ ./ 然后/ 对/ 这个/ 报文/ 组/ 进行/ 多/ 序列/ 比/ 对/ ,/ 将/ 不变/ 域/ 和/ 可变/ 域/ 分离出来/ ,/ 得到/ 一个/ 初步/ 的/ 报文/ 域/ 划分/ ./ 报文/ 域/ 识别/ 模块/ 再/ 进行/ 进一步/ 的/ ANSII/ 字符串/ 域/ 、/ Unicode/ 字符串/ 域/ 、/ 二进制/ 域/ 、/ 长度/ 域/ 的/ 识别/ ,/ 得到/ 一个/ 较为/ 准确/ 的/ 报文格式/ ./ 报文格式/ 得到/ 后/ ,/ 可以/ 根/ Page4/ 图/ 1/ 系统/ 结构图/ 据此/ 格式/ 生成/ SPIKE/ 脚本/ ,/ 由/ SPIKE/ 根据/ 脚本/ 构造/ 实际/ 的/ 报文/ 对/ 服务器进行/ 测试/ ./ 而/ 服务器/ 主要/ 安装/ FaultMon/ 等/ 监控/ 软件/ ,/ 一方面/ 监控/ 内存/ 使用/ 情况/ ,/ 监控/ 内存/ 异常/ 和/ 系统/ 服务/ 状态/ ;/ 另外/ 一个/ 方面/ 是/ 记录/ 被/ 测试/ 服务程序/ 的/ 异常/ 和/ 日志/ ./ 通过/ 这/ 两个/ 部分/ 的/ 信息/ ,/ 可以/ 反推/ 漏洞/ 可能/ 的/ 类型/ 和/ 存在/ 的/ 位置/ ./ 在/ 这样/ 的/ 系统结构/ 下/ ,/ 可以/ 实现/ 自动化/ 地/ 对/ 网络/ 服务器进行/ FuzzTesting/ ,/ 测试/ 网络协议/ 在/ 设计/ 和/ 实现/ 上/ 的/ 安全性/ ./ 3/ 报文/ 聚类/ 为了/ 能够/ 识别/ 未知/ 网络协议/ ,/ 首先/ 需要/ 人工/ 对/ 网络协议/ 进行/ 多次/ 访问/ ,/ 每次/ 访问/ 为/ 一个/ Session/ ,/ 每/ 一个/ Session/ 的/ 报文/ 都/ 截获/ 保存/ 到/ 一个/ PCAP/ 文件/ 中/ ./ 为了/ 提取/ 同/ 类型/ 报文/ ,/ 需要/ 对/ 多个/ PCAP/ 文件/ 中/ 的/ 报文/ 进行/ 聚类/ ,/ 将/ 相同/ 类型/ 的/ 报文/ 序列/ 组成/ 一个/ 报文/ 组/ ,/ 属于/ 同一个/ 报文/ 组/ 的/ 报文/ 被/ 认为/ 是/ 网络协议/ 中/ 相同/ 格式/ 的/ 报文/ ,/ 它们/ 将/ 被/ 作为/ 多/ 序列/ 比/ 对/ 算法/ 的/ 基本/ 输入/ ./ 具体方法/ 为/ ,/ 提取/ PCAP/ 文件/ 中/ 的/ 非空/ 负载/ 报文/ ,/ 每个/ 报文/ 以/ 各自/ 原始/ 序号/ 标记/ ,/ 具有/ 相同/ 序号/ 的/ 报文/ 作为/ 一组/ ./ 此时/ 的/ 报文/ 组/ ,/ 并/ 不能/ 保证/ 它们/ 是/ 相同/ 类型/ 的/ ,/ 因为/ 考虑/ 到/ 网络/ 传输/ 中/ 可能/ 出现/ 丢包/ 、/ 乱序/ 等/ 情况/ ,/ 甚至/ 相同/ 类型/ 的/ 数据包/ 的/ 内容/ 也/ 极/ 有/ 可能/ 有/ 很大/ 差异/ ./ 因此/ 需要/ 对/ 每个/ 报文/ 组/ 进行/ 进一步/ 分析/ ./ 对/ 每个/ 报文/ 序列/ 的/ 每个/ 字节/ 识别/ 相应/ 的/ 类型/ ,/ 如果/ 是/ 可/ 打印/ 字符/ 用/ ‘/ A/ ’/ 表示/ ,/ 非可/ 打印/ 字符/ 用/ ‘/ B/ ’/ 表示/ ,/ 此时/ 这个/ 报文/ 序列/ 对应/ 的/ 类型/ 就/ 形成/ 一个/ 由/ 若干/ ‘/ A/ ’/ 、/ ‘/ B/ ’/ 组成/ 的/ 字符串/ ./ 考虑/ 到/ 字符串/ 长度/ 是/ 可变/ 的/ ,/ 我们/ 将/ 连续/ 的/ ‘/ A/ ’/ 合并/ 成/ 一个/ ‘/ A/ ’/ ,/ 如此/ 形成/ 一个/ 新/ 的/ 序列/ ,/ 我们/ 称/ 这个/ 序列/ 为/ 类型/ 序列/ (/ TypeSquence/ )/ ./ 对/ 类型/ 序列/ 进行/ 聚类/ 的/ 算法/ 如下/ ./ defclusterSequences/ (/ typeSquences/ )/ typeCompare/ =/ FalseforseqintypeSquencesdodoneiftypeComparedoelsedoneforseqintypeSquencesdodone/ 算法/ 判断/ 如果/ 是/ 纯/ 文本/ 的/ 协议/ 通过/ 查找/ 报文/ 之间/ 的/ 最/ 频繁/ 最长/ 共同/ 串/ (/ longestcommonstring/ )/ ,/ 找到/ 具有/ 共同/ 类型/ 序列/ 的/ 报文/ ./ 而/ 具有/ 不可/ 打印/ 字符/ 的/ 报文/ ,/ 说明/ 不是/ 纯/ 文本/ 协议/ ,/ 通过/ 找到/ 最/ 频繁/ 的/ 类型/ 序列/ ,/ 发现/ 具有/ 共同/ 类型/ 的/ 报文/ ,/ 移除/ 不/ 符合要求/ 的/ 报文/ ./ 4/ 多/ 序列/ 比/ 对/ 已有/ 的/ 多/ 序列/ 比/ 对/ 算法/ 大体/ 分/ 3/ 类/ :/ 精确/ 比/ 对/ Page5/ 算法/ 、/ 渐进/ 比/ 对/ 算法/ 和/ 迭代/ 比/ 对/ 算法/ [/ 16/ ]/ ./ 精确/ 比/ 对/ 算法/ 最为/ 经典/ 的/ 是/ 多维/ NeedlmanWunsch/ 算法/ ,/ 但/ 其/ 可行/ 的/ 计算/ 维数/ 为/ 3/ ,/ CarrilloLipman/ 算法/ 通过/ 减小/ 计算/ 空间/ ,/ 将/ 计算/ 维数/ 提高/ 到/ 10/ ./ 渐进/ 比/ 对/ 算法/ 由/ Hogeweg/ 首先/ 提出/ ,/ Feng/ 和/ Taylor/ 又/ 加以/ 完善/ ,/ 被/ 广泛/ 使用/ 的/ 多/ 序列/ 比/ 对/ 软件包/ CLUSTALW/ 就是/ 基于/ 渐进/ 比/ 对/ 思想/ 构建/ ./ 近年来/ ,/ 迭代/ 比/ 对/ 算法/ 被/ 越来越/ 多地/ 用于/ 求解/ 多/ 序列/ 比/ 对/ 问题/ ,/ 基于/ 模拟退火/ 、/ 遗传算法/ 、/ HiddenMarkovModel/ 、/ Gibbs/ 抽样/ 等/ 的/ 多/ 序列/ 比/ 对/ 算法/ 被/ 广泛应用/ 于/ 多/ 序列/ 比/ 对/ 问题/ 的/ 求解/ ./ 由于/ 网络/ 报文/ 的/ 多/ 序列/ 比/ 对/ 具有/ 序列/ 很长/ 、/ 报文/ 数量/ 多/ 的/ 特点/ ,/ 精确/ 匹配/ 需要/ 大量/ 的/ 计算/ 时间/ 和/ 内存空间/ ,/ 因此/ 我们/ 放弃/ 了/ 精确/ 比/ 对/ ,/ 主要/ 考虑/ 了/ 基于/ 序列/ 长度/ 的/ 渐进/ 比/ 对/ 算法/ 和/ 基于/ 遗传算法/ 的/ 迭代/ 比/ 对/ 算法/ ./ 通过/ 比较/ 这/ 两种/ 算法/ ,/ 我们/ 发现/ 简单/ 的/ 基于/ 序列/ 长度/ 的/ 渐进/ 比/ 对/ 算法/ 在/ 效果/ 和/ 效率/ 上/ 大大/ 优于/ 后者/ ,/ 所以/ 最终/ 选择/ 渐进/ 比/ 对/ 算法/ 作为/ 协议/ 分析/ 的/ 多/ 序列/ 比/ 对/ 算法/ ./ 在/ 本节/ ,/ 分别/ 介绍/ 我们/ 对/ 这/ 两种/ 算法/ 的/ 改进/ ,/ 以及/ 对/ 两种/ 序列/ 比/ 对/ 算法/ 的/ 效果/ 和/ 性能/ 测试/ ./ 4.1/ 基于/ 遗传算法/ 的/ 迭代/ 比/ 对/ 算法/ 本文/ 利用/ 基于/ 遗传算法/ 的/ 多/ 序列/ 比/ 对/ 算法/ 对/ 多个/ 数据包/ 进行/ 比/ 对/ ,/ 得到/ 反映/ 这些/ 报文/ 共性/ 和/ 差异/ 的/ 比/ 对/ 结果/ ./ 具体/ 的/ 遗传算法/ 设计/ 如下/ ./ 目标/ 函数/ ./ 在/ 序列/ 比/ 对/ 结果/ 中/ ,/ 每个/ 序列/ 插入/ 的/ 空位/ (/ Gap/ )/ 数量/ 越少/ 越/ 好/ ,/ 因此/ 目标/ 函数/ 加大/ 了/ 对/ Gap/ 的/ 惩罚/ 力度/ ,/ 设/ 多个/ 序列/ 为/ seqs/ =/ {/ s1/ ,/ s2/ ,/ …/ ,/ sn/ }/ ,/ 经过/ 遗传算法/ 填充/ 序列/ 长度/ 相等/ 都/ 为/ len/ ,/ 则/ SP/ (/ seqs/ )/ =/ ∑/ lenSPCol/ (/ c1/ ,/ c2/ ,/ …/ ,/ clen/ )/ =/ ∑/ i/ =/ lenCmp/ (/ c1/ ,/ c2/ )/ =/ 式/ (/ 1/ )/ 即为/ Sum/ -/ of/ -/ Pairs/ 目标/ 函数/ 的/ 评分/ 规则/ (/ 简称/ SP/ )/ ,/ 注意/ 如果/ 遇到/ 全部/ 为/ Gap/ 的/ 列/ ,/ 直接/ 删除/ ,/ 不/ 计算/ 分数/ ./ 可以/ 看出/ ,/ 对于/ 空位/ Gap/ 的/ 限制/ 比/ 其它/ 字符/ 要/ 大/ ,/ 因此/ ,/ 最终/ 比/ 对/ 结果/ 中/ 出现/ 的/ Gap/ 数量/ 也/ 相应/ 减少/ ./ 遗传/ 算子/ ./ 这里/ 实现/ 了/ 9/ 种/ 遗传/ 算子/ ,/ 假设/ 每个/ 个体/ 包含/ N/ 个/ 序列/ ,/ 下面/ 分别/ 简要/ 介绍/ [/ 17/ ]/ ./ (/ 1/ )/ CrossOver/ ./ 随机/ 选择/ 两个/ 个体/ p1/ 和/ p2/ ,/ 然后/ 将/ p1/ 的/ 前/ i/ 个/ 序列/ 和/ p2/ 的/ 后/ (/ N/ -/ i/ )/ 个/ 序列/ 进行/ 组合/ ,/ 形成/ 新/ 的/ 个体/ ./ (/ 2/ )/ Mutate/ ./ 随机/ 选择/ 一个/ 个体/ 及/ 这个/ 个体/ 中/ 的/ 一个/ 序列/ ,/ 删除/ 这个/ 序列/ 中/ 所有/ 的/ 空格/ ,/ 然后/ 随机/ 插入/ 相同/ 数量/ 的/ 空格/ ,/ 形成/ 新/ 的/ 个体/ ./ (/ 3/ )/ LocalShuffle/ ./ 随机/ 选择/ 一个/ 个体/ 及/ 这个/ 个体/ 中/ 的/ 一个/ 序列/ ,/ 将/ 这个/ 序列/ 中/ 的/ 一个/ Gap/ 和/ 相邻/ 字符/ 交换/ ./ (/ 4/ )/ BlockShuffle/ ./ 随机/ 选择/ 一个/ 个体/ 及/ 这个/ 个体/ 中/ 的/ 一个/ 序列/ ,/ 将/ 这个/ 序列/ 中/ 的/ 一个/ Gap/ 和/ 相邻/ 字符串/ 交换/ ./ (/ 5/ )/ InsertGap/ ./ 随机/ 选择/ 一个/ 个体/ 及/ 这个/ 个体/ 中/ 的/ 一个/ 序列/ ,/ 随机/ 删除/ 这个/ 序列/ 中/ 的/ 一个/ Gap/ 并/ 随机/ 插入/ 一个/ Gap/ ./ (/ 6/ )/ DeleteGap/ ./ 随机/ 选择/ 一个/ 个体/ 及/ 这个/ 个体/ 中/ 的/ 一个/ 序列/ ,/ 随机/ 删除/ 这个/ 序列/ 中/ 的/ 一个/ Gap/ ,/ 并/ 在/ 序列/ 末尾/ 添加/ 一个/ Gap/ ./ (/ 7/ )/ Union/ ./ 随机/ 选择/ 一个/ 个体/ 及/ 这个/ 个体/ 中/ 的/ 一个/ 序列/ ,/ 将/ 这个/ 序列/ 中/ 两个/ 相邻/ 的/ 字符串/ 合并/ ,/ 即/ 删除/ 一个/ 连续/ 的/ Gap/ 串/ ,/ 然后/ 在/ 相邻/ 字符串/ 的/ 左边/ 或/ 右边/ 插入/ 相同/ 数量/ 的/ Gap/ ./ (/ 8/ )/ Division/ ./ 随机/ 选择/ 一个/ 个体/ 及/ 这个/ 个体/ 中/ 的/ 一个/ 序列/ ,/ 将/ 这个/ 序列/ 的/ 一个/ 字符串/ 拆分/ ,/ 即/ 随机/ 删除/ 一个/ Gap/ ,/ 然后/ 随机/ 插入/ 一个/ Gap/ 到/ 这个/ 字符串/ 中/ ./ (/ 9/ )/ CleanUpGapColumn/ ./ 检查/ 是否/ 存在/ 全为/ Gap/ 的/ 列/ ,/ 如果/ 存在/ 的话/ ,/ 将/ 此列/ 删除/ 并/ 在/ 每个/ 序列/ 的/ 末尾/ 添加/ 一个/ 全为/ Gap/ 的/ 列/ ./ 动态/ 退出/ 流程/ ./ 在/ 遗传算法/ 的/ 实现/ 中/ ,/ 所有/ 序列/ 的/ 长度/ 都/ 是/ 固定/ 的/ (/ 默认设置/ 为/ 最大/ 长度/ 的/ 1.2/ 倍/ )/ ./ 在/ 编程/ 实现/ 中/ ,/ 采用/ 轮盘/ 赌/ 算法/ 随机/ 选择/ SP/ 值/ 比较/ 大/ 的/ 个体/ 进入/ 下一代/ 种群/ 的/ 演变/ ./ 我们/ 知道/ ,/ 轮盘/ 赌/ 算法/ 中/ ,/ 对应/ 的/ 特征值/ 不能/ 为/ 负值/ ./ 但是/ 根据/ 以上/ 算法/ 计算/ 的/ 目标/ 函数/ 很/ 有/ 可能/ 是/ 一个/ 小于/ 0/ 的/ 整数/ ./ 为了/ 避免出现/ 负值/ 的/ 现象/ ,/ 在/ 进行/ 轮盘/ 赌/ 选择/ 的/ 时候/ ,/ 需要/ 将/ 所有/ 值/ 转换/ 为/ 正值/ ,/ 然后/ 进行/ 选择/ ./ 目前/ 实现/ 了/ 9/ 中/ 遗传/ 算子/ ./ 但是/ 这些/ 遗传/ 算子/ 的/ 一个/ 特点/ 在于/ ,/ 它们/ 随机性/ 较强/ ,/ 增加/ 了/ 种群/ 的/ 多样性/ ,/ 不过/ 这/ 也/ 是/ 它们/ 的/ 一个/ 缺点/ ,/ 即/ 如果/ 进入/ 一个/ Page6/ 很差/ 的/ 解/ 空间/ ,/ 有/ 可能/ 一直/ 在/ 这个/ 空间/ 内/ 迭代/ ,/ 无法/ 再/ 优化/ ./ 为了/ 得到/ 更优/ 的/ 结果/ ,/ 本文/ 从/ 每次/ 产生/ 的/ 最优/ 个体/ 中/ 提取/ 免疫/ 因子/ ,/ 通过/ 免疫/ 因子/ ,/ 产生/ 新/ 个体/ ./ 实验/ 测试表明/ ,/ 免疫/ 算子/ 可以/ 在/ 很大/ 程度/ 上/ 优化/ 比/ 对/ 的/ 结果/ ./ 在/ 程序/ 中/ 增加/ 实现/ 了/ 两种/ 免疫/ 算子/ :/ 单一/ 免疫/ 因子/ 和/ 多/ 免疫/ 因子/ ./ 单一/ 免疫/ 因子/ 每次/ 提取/ 最优/ 个体/ 中/ 最长/ 的/ 连续/ 的/ 相同/ 的/ 列/ 作为/ 免疫/ 因子/ ,/ 产生/ 新/ 个体/ ,/ 而/ 多/ 免疫/ 因子/ 则/ 提取/ 最优/ 个体/ 中/ 多个/ 连续/ 的/ 相同/ 的/ 列为/ 免疫/ 因子/ ,/ 产生/ 新/ 个体/ ./ 遗传算法/ 测试/ ./ 为了/ 测试/ 遗传算法/ 在/ 多个/ 报文/ 序列/ 对比/ 中/ 的/ 效果/ ,/ 本文/ 设计/ 了/ 6/ 组/ 测试数据/ ,/ 每组/ 数据/ 包含/ 4/ 个/ 相似/ 的/ 网络/ 报文/ ,/ 对/ 每组/ 数据/ 进行/ 基于/ 遗传算法/ 的/ 多/ 序列/ 比/ 对/ ,/ 共测/ 10/ 次/ ,/ 取/ 平均/ 结果/ ./ 表/ 1/ 为/ 测试数据/ 描述/ ,/ 表/ 2/ 左侧/ 是/ 不/ 引入/ 免疫/ 因子/ 的/ 测试/ 结果/ ,/ 右侧/ 为/ 引入/ 免疫/ 因子/ 后/ 的/ 实验/ 结果/ ./ 报文/ 组/ 平均/ 报文/ 长度/ 1200/ 字节/ 左右/ 每行/ 大约/ 0/ ~/ 10/ 个/ 字节/ 发生/ 不同/ 2200/ 字节/ 左右/ 每行/ 大约/ 10/ ~/ 20/ 个/ 字节/ 发生变化/ 3200/ 字节/ 左右/ 每行/ 大约/ 0/ ~/ 10/ 个/ 字节/ 发生变化/ ,/ 4200/ 字节/ 左右/ 每行/ 大约/ 10/ ~/ 20/ 个/ 字节/ 发生变化/ ,/ 5200/ 字节/ 左右/ 每行/ 大约/ 0/ ~/ 10/ 个/ 字节/ 发生变化/ ,/ 6200/ 字节/ 左右/ 每行/ 大约/ 10/ ~/ 20/ 个/ 字节/ 发生变化/ ,/ 普通/ 遗传算法/ 测试/ 结果/ 平均/ SP/ 值/ 报文/ 组/ 1793.346639/ ./ 6446.511206/ ./ 248839.4727/ ./ 7250048020.8448/ ./ 82962.745829/ ./ 7666.33353/ ./ 352084.6494/ ./ 23816.751674/ ./ 6770.24/ -/ 64.737862/ ./ 4381.84695/ ./ 352858.6775/ ./ 25570.952065/ ./ 8508.451096/ ./ 857300.78296212/ ./ 638786.7389/ ./ 86906.570889/ ./ 5985.9/ 总体而言/ ,/ 遗传算法/ 实现/ 多/ 序列/ 比/ 对/ 还是/ 存在/ 一些/ 不足/ ./ 首先/ ,/ 遗传算法/ 本身/ 存在/ 很大/ 的/ 随机性/ ./ 即便/ 是/ 相同/ 的/ 序列/ ,/ 多次/ 比/ 对/ 的/ 结果/ 也/ 并不一定/ 相同/ ,/ 最佳/ 分析/ 结果/ 得到/ 的/ SP/ 值/ 也/ 较/ 低/ ./ 而/ 在/ 协议/ 自动/ 分析/ 中/ ,/ 对/ 序列/ 比/ 对/ 结果/ 要求/ 极为/ 苛刻/ ,/ 任何/ 错误/ 的/ 比/ 对/ ,/ 都/ 将/ 直接/ 影响/ 后续/ 分析/ 工作/ ./ 此外/ ,/ 遗传算法/ 消耗/ 的/ 时间/ 相对/ 比较/ 长/ ,/ 当/ 序列/ 数量/ 或者/ 序列/ 长度/ 达到/ 一定/ 阈值/ 之后/ ,/ 运行/ 时间/ 甚至/ 无法忍受/ ./ 因此/ 遗传算法/ 不/ 适合/ 用于/ 协议/ 自动/ 分析/ 的/ 多/ 序列/ 比/ 对/ 中/ ./ 4.2/ 基于/ 序列/ 长度/ 的/ 渐进/ 比/ 对/ 算法/ 渐进/ 比/ 对/ 算法/ 建立/ 在/ 二维/ NeedlemanWunsch/ 算法/ 基础/ 上/ ,/ 基于/ 相似/ 序列/ 通常/ 具有/ 进化/ 相关性/ 这一/ 假设/ ,/ 它/ 的/ 思想/ 是/ 通过/ 迭代/ 地/ 利用/ 双/ 序列/ 动态/ 规划/ 比/ 对/ 算法/ ,/ 先由/ 两条/ 序列/ 的/ 比/ 对/ 开始/ ,/ 逐渐/ 添加/ 新/ 序列/ ,/ 直到/ 所有/ 序列/ 都/ 加入/ 为止/ ./ 但是/ 不同/ 的/ 添加/ 顺序/ 会/ 产生/ 不同/ 的/ 比/ 对/ 结果/ ./ 因此/ 确定/ 适合/ 的/ 比/ 对/ 顺序/ 是/ 渐进/ 比/ 对/ 算法/ 的/ 一个/ 关键问题/ ./ 渐进/ 比/ 对/ 算法/ 主要/ 由/ 3/ 个/ 步骤/ 组成/ :/ (/ 1/ )/ 计算/ 距离/ 矩阵/ ;/ (/ 2/ )/ 构建/ 向导/ 树/ ;/ (/ 3/ )/ 依据/ 向导/ 树/ 进行/ 渐进/ 比/ 对/ ./ 针对/ 报文/ 序列/ 比/ 对/ 的/ 特点/ ,/ 我们/ 实现/ 了/ 一种/ 优化/ 的/ NeedlemanWunsch/ 算法/ ./ 优化/ 的/ NeedlemanWunsch/ 算法/ ./ NeedlemanWunsch/ 算法/ 属于/ 动态/ 规划/ 算法/ ,/ 算法/ 结束/ 时/ 通过/ 回溯/ 得到/ 一个/ 全局/ 的/ 比/ 对/ 结果/ ,/ 根据/ 该/ 比/ 对/ 的/ 结果/ 计算/ 出/ 的/ 序列/ 相似/ 度值/ 最大/ ./ 算法/ 有/ 两个/ 步骤/ :/ (/ 1/ )/ 根据/ 状态/ 转换/ 函数/ 计算/ 两个/ 序列/ 的/ 相似/ 分值/ ,/ 得到/ 一个/ 相似/ 度/ 矩阵/ ./ (/ 2/ )/ 根据/ 相似/ 度/ 矩阵/ ,/ 按照/ 动态/ 规划/ 的/ 方法/ 回溯/ 寻找/ 最优/ 的/ 比/ 对/ ./ 核心/ 的/ 状态/ 转换/ 函数/ 定义/ 如下/ :/ 其中/ ,/ Mij/ 表示/ 当前/ 状态/ 得分/ ,/ Sij/ 是/ 字母/ 匹配/ 得分/ (/ 如果/ 不/ 匹配/ 就是/ 罚分/ )/ ,/ w/ 是/ 加入/ 空位/ 的/ 惩罚/ ./ 因为/ 空位/ 不/ 属于/ 原始/ 报文/ ,/ 为了/ 保持/ 报文/ 长度/ 和/ 增加/ 匹配/ 的/ 可信度/ ,/ 应该/ 尽量少/ 加入/ 空位/ ,/ 所以/ 我们/ 设置/ 字母/ 匹配/ Sij/ 得/ 分为/ 2/ ,/ 不/ 匹配/ Sij/ 罚/ 分为/ -/ 1/ ,/ w/ =/ -/ 2/ ./ 这样/ 的/ 设置/ 在/ 大部分/ 情况/ 下/ 有效/ ,/ 但是/ 经典/ 的/ NeedlemanWunsch/ 算法/ 的/ 每个/ 状态/ 仅仅/ 基于/ 上/ 一个/ 状态/ 得到/ ,/ 没有/ 考虑/ 对于/ 连续/ 匹配/ 进行/ 奖励/ ,/ 因此/ 可能/ 出现/ 为了/ 避免/ 增加/ 空位/ 导致/ 不能/ 对齐/ 的/ 现象/ ./ 图/ 2/ 上侧/ 截取/ 了/ 两个/ 互相/ 比/ 对/ 的/ 报文/ 中/ 的/ 部分/ 序列/ ,/ 采用/ 经典/ 的/ NeedlemanWunsch/ 算法/ 匹配/ 后/ ,/ 发现/ 这/ 两个/ 序列/ 没有/ 正确/ 地/ 对齐/ 字符串/ Referer/ :/ ht/ -/ tp/ :/ // // 192.168/ ./ 1.1/ // ,/ 这/ 是因为/ 为了/ 避免/ 过多/ 的/ 插入/ 空位/ ,/ 算法/ 宁可/ 选择/ 字符串/ 不/ 匹配/ ./ 那么/ 最终/ 得到/ 的/ FuzzTesting/ 报文/ 模板/ 不会/ 把/ 这个/ 部分/ 作为/ 不可/ 变域/ ,/ 影响/ 分析/ 效果/ ./ 因此/ 我们/ 修改/ 了/ NeedlemanWun/ -/ sch/ 算法/ 的/ 状态/ 转换/ 函数/ ,/ 增加/ 对于/ 连续/ 匹配/ 的/ 奖励/ ./ Mij/ =/ max/ 其中/ ,/ n/ 是/ 连续/ 匹配/ 的/ 字母/ 数目/ ,/ b/ 为/ 连续/ 匹配/ 奖励/ ,/ Page7/ 设定/ 为/ 2/ ,/ 这样/ 鼓励/ 算法/ 将/ 连续/ 的/ 字母/ 比/ 对/ 在/ 一起/ ,/ 即使/ 插入/ 更/ 多/ 的/ 空位/ 也/ 不会/ 产生/ 比/ 对/ 的/ 碎片/ ,/ 达到/ 如图/ 2/ 下侧/ 的/ 效果/ ,/ 虽然/ 插入/ 了/ 更/ 多/ 的/ 空位/ ,/ 但是/ 实际上/ 更加/ 符合/ 网络/ 报文/ 匹配/ 的/ 要求/ ,/ 得到/ 的/ 结果/ 更/ 便于/ 发现/ 报文/ 中/ 的/ 变化/ 域/ ./ 即/ Referer/ :/ http/ :/ // // 192.168/ ./ 1.1/ // 在/ 两个/ 报文/ 中/ 正确/ 地/ 匹配/ 在/ 一起/ ,/ 而/ 客户端/ 识别/ 的/ 图/ 2/ 优化/ 算法/ 前后/ 效果/ 对比/ (/ 用/ 下划线/ 代替/ 空位/ )/ 渐进/ 比/ 对/ 算法/ 流程/ ./ 由于/ 通过/ 了/ 报文/ 聚类/ ,/ 我们/ 认为/ 剩下/ 的/ 报文/ 应该/ 是/ 相似/ 的/ ,/ 而且/ 长度/ 决定/ 了/ 报文/ 变化/ 的/ 大小/ ./ 因此/ 我们/ 提出/ 了/ 基于/ 报文/ 长度/ 的/ 渐进/ 比/ 对/ 算法/ ./ 算法/ 的/ 核心/ 就是/ 构建/ 一棵/ 二叉树/ ,/ 通过/ 比较/ 报文/ 的/ 长度/ ,/ 将/ 长度/ 最为/ 接近/ 的/ 报文/ 两/ 两/ 编组/ ,/ defConstructTree/ (/ seqs/ )/ forseqinseqsdonode/ =/ newTreeNode/ (/ seq/ )/ nodeList/ ./ append/ (/ node/ )/ donewhile/ (/ len/ (/ nodeList/ )/ >/ 1/ )/ node1/ ,/ node2/ =/ newNode/ =/ newTreeNode/ (/ )/ newNode/ ./ seq/ ,/ node1/ ./ gapList/ ,/ node2/ ./ gapList/ =/ newNode/ ./ left/ =/ node1newNode/ ./ right/ =/ node2nodeList/ ./ append/ (/ newNode/ )/ donereturnnodeList/ [/ 0/ ]/ 算法/ 的/ 核心/ 是/ 每次/ 查找/ 最短/ 的/ 两个/ 序列/ 作为/ 二叉树/ 的/ 叶子/ 节点/ ,/ 然后/ 进行/ Needleman/ -/ Wunsch/ 算法/ 比/ 对/ ,/ 返回/ 的/ 三个/ 值/ ,/ 第一个/ 是/ 插入/ Gap/ 较少/ 的/ 比/ 对/ 结果/ ,/ 后/ 两个/ 是/ 两个/ 比/ 对/ 结果/ 相对/ 原始/ 序列/ 需要/ 插入/ 的/ Gap/ 位置/ 列表/ ,/ 这样/ 递归/ 下去/ ,/ 直到/ 根/ 节点/ ./ 另外/ 一个/ 算法/ 是/ 构建/ 多/ 序列/ 比/ 对/ 结果/ :/ defSequenceResult/ (/ treeNode/ ,/ resultSeqs/ )/ iftreeNode/ ./ gapList/ !/ =/ nulldoGapListStack/ ./ push/ (/ treeNode/ ./ gapList/ )/ SequenceResult/ (/ treeNode/ ./ left/ )/ SequenceResult/ (/ treeNode/ ./ right/ )/ 文件类型/ 和/ 服务器端/ 的/ 页面/ 路径/ 被/ 标识/ 出来/ ,/ 这/ 两个/ 区域/ 可以/ 分开/ 进行/ FuzzTesting/ ,/ 增加/ 了/ 检测/ 的/ 粒度/ ,/ 容易/ 触发/ 更/ 多/ 漏洞/ ,/ 而且/ 这样/ 的/ 报文/ 更加/ 容易/ 通过/ 服务器/ 的/ 格式/ 检查/ ./ 当然/ 增加/ 了/ 连续/ 奖励/ 会/ 增加/ 算法/ 的/ 复杂度/ ,/ 因为/ 必须/ 更新/ 状态/ ,/ 记住/ 连续/ 匹配/ 是否/ 产生/ 以及/ 匹配/ 的/ 字符/ 个数/ ./ GapListStack/ ./ pop/ (/ )/ doneiftreeNode/ ./ left/ =/ nullandtreeNode/ ./ right/ =/ nulldonewSeq/ =/ resultSeqs/ ./ append/ (/ newSeq/ )/ doneSequenceResult/ 是从/ 根/ 节点/ 开始/ ,/ 递归/ 调用/ ,/ 将/ 所有/ 的/ gapList/ 都/ 应用/ 到/ 叶子/ 节点/ ,/ 最终/ 形成/ 结果/ 序列/ 保存/ 在/ resultSeqs/ 中/ ./ 测试/ 结果/ ./ 为了/ 测试/ 渐进/ 比/ 对/ 算法/ 的/ 效果/ ,/ 我们/ 采用/ 了/ 和/ 遗传算法/ 同样/ 的/ 测试/ 集合/ ,/ 进行/ 了/ 同样/ 的/ 测试/ ./ 表/ 3/ 显示/ 了/ 对/ 第/ 6/ 个/ 报文/ 组/ 的/ 测试/ 结果/ ./ 算法/ 平均/ 时间/ // s/ 最佳/ SP/ 值/ 平均/ SP/ 值/ 免疫/ 遗传算法/ >/ 601187906.5/ 渐进/ 比/ 对/ 算法/ 1.98517821782/ ./ 0/ 表/ 3/ 中/ 数据/ 显示/ ,/ 同样/ 的/ 程序/ 多次/ 分析/ 同样/ 的/ 序列/ ,/ 渐进/ 比/ 对/ 算法/ 比/ 对/ 结果/ 明显/ 优于/ 遗传算法/ 结果/ ./ 协议/ 自动/ 分析/ 需要/ 数据包/ 序列/ 中/ 每个/ 字节/ 严格/ 同/ 序列/ 中/ 相同/ 含义/ 的/ 字节/ 对齐/ ,/ 否则/ 分析/ 无法/ 成功/ 进行/ ./ 另外/ 遗传算法/ 还/ 存在/ 很大/ 的/ 随机性/ ,/ 每次/ 执行/ 的/ 结果/ 可能/ 不/ 一致/ ,/ 这/ 意味着/ 如果/ 采用/ 遗传算法/ 进行/ 序列/ 分析/ 的话/ ,/ 最终/ 的/ 协议/ 结构/ 也/ 可能/ 是/ 不/ 一致/ 的/ ./ 这/ 在/ 协议/ 自动/ 分析/ 中是/ 无法/ 接受/ 的/ ./ 此外/ ,/ 遗传算法/ 所/ 消耗/ 的/ 时间/ 也/ 明显/ 比/ 渐进/ 算法/ 长/ ./ 测试/ 文件/ 6/ 中/ 序列/ 在/ 200/ 字节/ 左右/ ,/ 最长/ 运行/ 时间/ 已经/ 达到/ 4/ 分/ 1/ 秒/ ./ 随着/ 序列/ 长度/ 的/ 增加/ ,/ 比/ 对/ 时间/ 也/ 急剧/ 增加/ ./ 综上所述/ ,/ 我们/ 得出结论/ :/ 在/ 协议/ 自动/ 分析/ 中/ 不/ 适合/ 使用/ 遗传算法/ 实现/ 多/ 序列/ 比/ 对/ ./ 因此/ 在/ 研究/ 中/ Page8/ 采用/ 渐进/ 比/ 对/ 算法/ 作为/ 协议/ 自动/ 分析/ 中/ 的/ 多/ 序列/ 比/ 对/ 算法/ ./ 5/ 协议/ 自动识别/ 技术/ 为了/ 方便/ 描述/ ,/ 我们/ 将/ 数据包/ 结构/ 中/ 的/ 各个/ 有/ 意义/ 的/ 组成部分/ 称为/ “/ 域/ ”/ (/ Field/ )/ ./ 通过/ 多/ 序列/ 比/ 对/ ,/ 可以/ 将/ 多个/ 报文/ 进行/ 对齐/ ,/ 然后/ 根据/ 每/ 一列/ 字节/ 的/ 变化/ ,/ 识别/ 出/ 不变/ 域/ 和/ 可变/ 域/ ,/ 其中/ 不变/ 域/ 中/ 每个/ 字节/ 对应/ 的/ 变化率/ 都/ 为/ 0/ ./ 从/ 类型/ 上/ 看/ ,/ 域/ 又/ 可以/ 分为/ 二进制/ 域/ 和/ 字符串/ 域/ ,/ 其中/ 字符串/ 域/ 对应/ 可/ 打印/ 文本/ 串/ ./ 此外/ ,/ 还/ 需要/ 识别/ 出/ 两种/ 特殊/ 的/ 域/ :/ 长度/ 域/ 和/ Unicode/ 编码/ 域/ ./ 长度/ 域/ 记录/ 数据包/ 中/ 若干/ 连续/ 域/ 的/ 长度/ ,/ 而/ Unicode/ 编码/ 域/ 指/ 的/ 是/ 由/ Unicode/ 编码/ 的/ 文本/ 域/ ./ 由于/ 我们/ 的/ 识别/ 目标/ 是/ 应用层/ 协议/ ,/ 而/ 在/ 下层/ 协议/ 中/ 已经/ 提供/ 了/ 校验/ 和/ ,/ 因此/ 就/ 没有/ 考虑/ 在/ 应用层/ 出现/ 校验/ 和域/ 的/ 情况/ ./ 总体而言/ ,/ 我们/ 希望/ 通过/ 协议/ 自动/ 分析/ ,/ 能够/ 准确/ 地/ 识别/ 出/ 协议/ 报文/ 中/ 的/ 不变/ 二进制/ 域/ 、/ 可变/ 二进制/ 域/ 、/ 不变/ 字符串/ 域/ 、/ 可变/ 字符串/ 域/ 、/ 不变/ Unicode/ 编码/ 域/ 、/ 可变/ Unicode/ 编码/ 域/ 和/ 长度/ 域/ ./ 识别/ 各种/ 域/ 之后/ ,/ 域/ 的/ 集合/ 就/ 构成/ 了/ 数据包/ 的/ 模型/ ,/ 称为/ PacketModel/ ,/ 而/ 若干/ 数据包/ 模型/ 和/ 交互/ 控制/ 信息/ 构成/ 了/ 目标/ ProtocolModel/ ./ 为了/ 得到/ ProtocolModel/ ,/ 需要/ 完成/ 以下/ 步骤/ :/ 根据/ 多/ 序列/ 比/ 对/ 结果/ 划分/ 域/ ;/ 进行/ 类型/ 纠错/ ;/ 按照/ 类型/ 划分/ 标准/ 数据包/ ;/ 识别/ Unicode/ 编码/ ;/ 识别/ 长度/ 域/ ;/ 类型/ 细粒度/ 划分/ ;/ 格式化/ 序列/ ;/ 输出/ PacketModel/ ./ 另外/ 还要/ 强调/ 一点/ ,/ 为了/ 方便使用/ PacketModel/ 产生/ 模糊/ 器/ ,/ 本文/ 要求/ 在/ 参与/ 比/ 对/ 的/ 数据包/ 中/ ,/ 必须/ 有/ 一个/ 是/ 进行/ 漏洞/ 测试/ 的/ 主机/ 之间/ 的/ 流量/ 抓包/ 文件/ ./ 而/ 这个/ 数据包/ 对应/ 的/ 序列/ 称为/ 默认/ 序列/ ,/ 它/ 是/ PacketModel/ 对应/ 的/ 一个/ 模板/ ./ 5.1/ 根据/ 多/ 序列/ 比/ 对/ 结果/ 划分/ 域/ 在/ 进行/ 多/ 序列/ 比/ 对/ 时/ ,/ 为了/ 能够/ 使/ 序列/ 最大/ 程度/ 对齐/ ,/ 在/ 必要/ 的/ 情况/ 下/ 需要/ 插入/ 空位/ ,/ 即/ 前面/ 提到/ 的/ Gap/ ./ 在/ 比/ 对/ 完成/ 之后/ ,/ 每个/ 序列/ 具有/ 相同/ 的/ 长度/ ./ 统计/ 每个/ 序列/ 中/ 相同/ 偏移/ 的/ 字节/ ,/ 计算/ 对应/ 的/ 变化率/ ./ 如果/ 相同/ 偏移/ 的/ 所有/ 字节/ 数值/ 都/ 相等/ ,/ 则/ 变化率/ 为/ 0/ ;/ 如果/ 不/ 相等/ ,/ 计算/ 不同/ 数值/ 的/ 数量/ ,/ 它/ 和/ 序列/ 个数/ 的/ 比值/ 作为/ 变化率/ ./ 根据/ 变化率/ 识别/ 出/ 不同/ 的/ 域/ ,/ 相同/ 变化率/ 的/ 字节/ 构成/ 一个/ 域/ ,/ 其中/ 包括/ 不变/ 域/ 和/ 可变/ 域/ ./ 接着/ 识别/ 每个/ 域/ 的/ 类型/ ./ 对于/ 每个/ 域/ ,/ 除去/ Gap/ 以外/ ,/ 如果/ 找到/ 一个/ 不可/ 打印/ 字符/ ,/ 则/ 表示/ 这个/ 域/ 是/ 二进制/ 域/ ,/ 否则/ 该域/ 为/ 可/ 打印/ 字符/ 域/ ./ 5.2/ Unicode/ 编码/ 识别/ 这里/ 的/ Unicode/ 编码/ ,/ 指/ 的/ 是/ 在/ 每个/ 字符/ 添加/ 一个/ “/ 00/ ”/ 作为/ 前缀/ 或/ 后缀/ ,/ 例如/ 字符/ ‘/ A/ ’/ 的/ Unicode/ 编码/ 为/ “/ 4100/ ”/ ./ 很/ 显然/ ,/ Unicode/ 字符串/ 的/ 一个/ 很/ 明显/ 的/ 特征/ 在于/ 每个/ 可/ 打印/ 字符/ 之间/ 以/ “/ 00/ ”/ 间隔/ ,/ 这/ 也/ 是/ 我们/ 识别/ Unicode/ 编码/ 的/ 标准/ ./ 遍历/ 每个/ 序列/ ,/ 查找/ 连续/ 间隔/ 出现/ “/ 00/ ”/ 、/ 而/ 每/ 两个/ “/ 00/ ”/ 之间/ 是/ 可/ 打印/ 字符/ 的/ 字节/ 范围/ ./ 根据/ “/ 00/ ”/ 相对/ 可/ 打印/ 字符/ 的/ 位置/ 确定/ Unicode/ 编码/ 类型/ ./ 然后/ 将/ 这个/ 字节/ 范围/ 的/ 字节/ 合并/ 成/ 一个/ 整体/ ,/ 作为/ 一个/ Unicode/ 域/ ./ 整个/ 识别/ 过程/ 中/ ,/ 忽略/ Gap/ 信息/ ./ 如果/ 进行/ 扩展/ 可以/ 识别/ 报文/ 中/ 的/ 汉字/ ,/ 例如/ IIS/ 的/ FTP/ 服务器/ 采用/ UTF/ -/ 8/ 传输/ 汉字/ ./ 5.3/ 类型/ 纠错/ 前面/ 的/ 处理/ 中/ 可以/ 根据/ 字节/ 的/ 数值/ ,/ 确定/ 一个/ 域/ 类型/ 为/ 二进制/ 域/ 或/ 字符串/ 域/ ,/ 但是/ 这种/ 方法/ 在/ 某些/ 情况/ 下/ 是/ 不/ 正确/ 的/ ./ 例如/ ,/ 对于/ 数值/ 0x40/ ,/ 它/ 既/ 可以/ 解释/ 成/ ‘/ @/ ’/ 字符/ ,/ 但是/ 也/ 可以/ 表示/ 一个/ 二进制/ 数值/ ./ 在/ 这种/ 情况/ 下/ ,/ 很难/ 直接/ 通过/ 数值/ 来/ 判断/ 数值/ 的/ 类型/ ./ 考虑/ 到/ 每个/ 字节/ 和/ 前后/ 字节/ 序列/ 之间/ 存在/ 一定/ 的/ 联系/ ,/ 因此/ 可以/ 根据/ 字节/ 所/ 处/ 环境/ 来/ 判断/ ./ 这里/ 假定/ 所有/ 的/ 可/ 打印/ 字符/ 域/ 有/ 一个/ 最小/ 长度/ 值/ ,/ 所有/ 长度/ 小于/ 这个/ 阈值/ 的/ 字符串/ 域/ ,/ 都/ 被/ 认为/ 是/ 二进制/ 域/ ./ 理论/ 上/ 讲/ ,/ 这种/ 策略/ 并/ 不是/ 很/ 精确/ ,/ 因为/ 我们/ 无法/ 保证/ 所有/ 的/ 字符串/ 域/ 的/ 长度/ 都/ 大于/ 或/ 等于/ 这个/ 阈值/ ,/ 但是/ 却/ 可以/ 在/ 大多数/ 情况/ 下/ 能够/ 正确/ 识别/ 出域/ 类型/ ./ 在/ 实现/ 中/ ,/ 我们/ 将/ 这个/ 阈值/ 作为/ 一个/ 参数/ 供/ 用户/ 配置/ ,/ 默认值/ 为/ 4.5/ ./ 4/ 长度/ 域/ 识别/ 在/ 多/ 序列/ 比/ 对/ 时/ ,/ 已经/ 向/ 序列/ 中/ 插入/ Gap/ ,/ 这些/ Gap/ 在/ 计算长度/ 域/ 时/ 不/ 应该/ 存在/ ./ 为了/ 保留/ 细粒度/ 划分/ 片段/ 所/ 需要/ 的/ 信息/ ,/ 此时/ 保存/ 默认/ 序列/ 的/ Gap/ 信息/ 及/ 各/ 字节/ 的/ 变化率/ 信息/ ,/ 然后/ 删除/ 所有/ 的/ Gap/ ./ 长度/ 域/ 用来/ 描述/ 数据包/ 某/ 一部分/ 的/ 长度/ ,/ 实际上/ 也/ 就是/ 表示/ 若干/ 连续/ 的/ 序列/ 片段/ 长度/ 之/ 和/ ./ 在/ 实际/ 网络/ 中/ ,/ 如果/ 一个/ 数据包/ 中/ 的/ 长度/ 域/ 出现/ 错误/ ,/ 那么/ 极有/ 可能/ 是/ 传输/ 错误/ 而/ 要求/ 重传/ ,/ 因此/ 长度/ 域/ 的/ 确定/ 是/ 协议/ 结构/ 自动/ 分析/ 的/ 一个/ 很/ 重要/ 的/ 部分/ ./ 长度/ 域/ 的/ 识别/ 过程/ 相当/ 复杂/ ,/ 而且/ 最终/ 的/ 分析/ 结果/ 可能/ 遗漏/ ,/ 甚至/ 不能/ 保证/ 分析/ 结果/ 一定/ 是/ 正确/ 的/ ./ 长度/ 域/ 的/ 识别/ 策略/ 基于/ 以下/ 几个/ 假设/ :/ (/ 1/ )/ 首先/ ,/ 不/ 考虑/ 一个/ 报文/ 分为/ 多个/ 数据包/ 到达/ 的/ 情况/ ,/ 此外/ 数据包/ 乱序/ 到达/ 也/ 应该/ 排除/ ./ (/ 2/ )/ 其次/ ,/ 长度/ 域/ 用于/ 记录/ 若干/ 连续/ 序列/ 片段/ 的/ 长度/ 之/ 和/ ./ 而/ 长度/ 域/ 都/ 是/ 1/ ~/ 2/ 个/ 字节/ 长度/ 的/ 二/ Page9/ 进制/ 数值/ ,/ 而且/ 高位/ 在/ 前/ ./ 暂时/ 不/ 考虑/ 以/ 明文/ 方式/ 表示/ 的/ 长度/ 域/ ,/ 例如/ EM/ 协议/ 中/ 请求/ 报文/ 中/ 存在/ “/ Content/ -/ Length/ :/ 95/ ”/ 的/ 长度/ 域/ ./ (/ 3/ )/ 长度/ 域/ 不/ 可能/ 出现/ 在/ 它/ 所/ 标记/ 的/ 序列/ 片段/ 范围/ 之后/ ./ 实际上/ ,/ SPIKE/ 框架/ 也/ 不/ 支持/ 这种/ 情况/ ./ 长度/ 域/ 的/ 识别/ 思路/ 如下/ :/ 对/ 每个/ 参与/ 比/ 对/ 的/ 序列/ ,/ 在/ 已经/ 识别/ 的/ 域/ 的/ 基础/ 上/ ,/ 穷举/ 所有/ 可能/ 的/ 位置/ 连续/ 的/ 域/ ,/ 并/ 计算/ 其/ 长度/ ,/ 位置/ 连续/ 的/ 域/ 称为/ 连续/ 域/ 集合/ ./ 然后/ 在/ 整个/ 序列/ 的/ 二进制/ 域/ 中/ 搜索/ 长度/ 信息/ ,/ 一旦/ 发现/ 二进制/ 域/ 中/ 存在/ 匹配/ 的/ 连续/ 域/ 长度/ ,/ 就/ 记录下来/ ,/ 这个/ 信息/ 成为/ 长度/ 向量/ (/ 采用/ 相对/ 位移/ 表示/ )/ ./ 每个/ 序列/ 都/ 会/ 产生/ 一个/ 长度/ 向量/ 集/ ,/ 对/ 所有/ 的/ 长度/ 向量/ 集求/ 交集/ ,/ 在/ 解决/ 长度/ 向量/ 交集/ 的/ 冲突/ 之后/ ,/ 剩下/ 的/ 长度/ 向量/ 就/ 代表/ 最终/ 的/ 长度/ 域/ ./ 下面/ 为/ 详细/ 识别/ 过程/ ./ 在/ 进行/ 长度/ 域/ 定位/ 之前/ ,/ 已经/ 完成/ 域/ 的/ 类型/ 识别/ 、/ 类型/ 纠错/ 、/ Unicode/ 编码/ 识别/ ,/ 这/ 几个/ 阶段/ 的/ 准确率/ 直接/ 关系/ 到/ 长度/ 域/ 定位/ 的/ 准确度/ ./ 为了/ 最大/ 限度/ 查找/ 到/ 长度/ 域/ ,/ 需要/ 穷举/ 所有/ 可能/ 的/ 连续/ 的/ 序列/ 片段/ 组合/ ,/ 计算/ 每种/ 组合/ 的/ 长度/ 值/ ./ 假设/ 每个/ 序列/ 的/ 域/ 数量/ 为/ n/ ,/ 那么/ 总共/ 可能/ 出现/ 的/ 组合/ 数量/ 为/ 1/ +/ 2/ +/ …/ +/ n/ =/ n/ (/ n/ +/ 1/ )/ // 2/ ./ 当/ 在/ 二进制/ 域/ 中/ 搜索/ 到/ 匹配/ 的/ 值时/ ,/ 就/ 表示/ 这个/ 值/ 可能/ 记录/ 了/ 对应/ 的/ 域/ 的/ 长度/ ./ 但是/ 不能/ 排除/ 这是/ 一种/ 巧合/ ,/ 需要/ 将/ 所有/ 匹配/ 的/ 信息/ 以/ (/ 起始/ 域/ 序号/ 、/ 终止/ 域/ 序号/ 、/ 长度/ 域/ 所在/ 二进制/ 域/ 序号/ 、/ 长度/ 域/ 所在/ 二进制/ 域/ 内/ 偏移/ ,/ 长度/ 域/ 长度/ )/ 的/ 形式/ 记录下来/ ,/ 形成/ 一系列/ 的/ 长度/ 向量/ ,/ 一个/ 序列/ 的/ 所有/ 长度/ 向量/ 组成/ 一个/ 长度/ 向量/ 集/ ./ 一个/ 长度/ 向量/ 集/ 表示/ 了/ 在/ 对应/ 序列/ 中/ 可能/ 出现/ 长度/ 域/ 的/ 组合/ ./ 对/ 所有/ 的/ 序列/ 的/ 长度/ 向量/ 集求/ 交集/ ./ 由于/ 长度/ 向量/ 采用/ 的/ 是/ 相对/ 偏移/ ,/ 和/ 具体/ 序列/ 无关/ ,/ 因此/ 交/ 集中/ 的/ 每个/ 长度/ 向量/ 意味着/ 它/ 所/ 标记/ 的/ 长度/ 域/ 在/ 所有/ 的/ 序列/ 中/ 都/ 是/ 符合/ 的/ ./ 在/ 实际/ 测试/ 中/ ,/ 我们/ 发现/ 长度/ 域交/ 集中/ 可能/ 存在/ 冲突/ 的/ 现象/ ./ 主要/ 表现/ 为/ (/ 1/ )/ 一个/ 长度/ 域/ 标记/ 多个/ 连续/ 域/ 集合/ ;/ (/ 2/ )/ 一个/ 连续/ 域/ 集合/ 可能/ 被/ 多个/ 长度/ 域/ 标记/ ;/ (/ 3/ )/ 长度/ 域/ 本身/ 重叠/ ./ 例如/ ,/ “/ 00ff/ ”/ 可以/ 作为/ 长度/ 域/ 标记/ 一个/ 连续/ 域/ 集合/ ,/ 但是/ “/ ff/ ”/ 本身/ 也/ 可能/ 作为/ 长度/ 域/ 标记/ 另/ 一个/ 连续/ 域/ 集合/ ./ 遇到/ 第/ 1/ 种/ 冲突/ 情况/ ,/ 总是/ 优先选择/ 距离/ 长度/ 域近/ 的/ 连续/ 域/ 集合/ 作为/ 长度/ 范围/ ./ 第/ 2/ 种/ 冲突/ 在/ 实际/ 数据包/ 中/ 出现/ 过/ ,/ 因此/ 被/ 认为/ 是/ 一种/ 正常/ 情况/ ,/ 无须/ 解决/ 冲突/ ./ 第/ 3/ 种/ 冲突/ 中/ 优先选择/ 2/ 个/ 字节/ 长度/ 域/ ,/ 而/ 删除/ 一个/ 字节/ 的/ 长度/ 域/ 信息/ ./ 当/ 所有/ 冲突/ 解决/ 之后/ ,/ 此时/ 的/ 长度/ 向量/ 集合/ 的/ 每/ 一个/ 向量/ ,/ 都/ 标志/ 着/ 一个/ 识别/ 出来/ 的/ 长度/ 域/ ./ 前面/ 已经/ 提/ 过/ 默认/ 序列/ 的/ 概念/ ./ 默认/ 序列/ 是/ 需要/ 进行/ 漏洞/ 挖掘/ 的/ 主机/ 之间/ 的/ 数据包/ 序列/ ./ 从/ 序列/ 组中/ 提取/ 出/ 默认/ 序列/ ,/ 然后/ 利用/ 长度/ 向量/ 集/ ,/ 划分/ 默认/ 序列/ 的/ 二进制/ 域/ ,/ 将/ 长度/ 域/ 独立/ 出来/ ,/ 并/ 记录/ 对应/ 的/ 片段/ 组合/ 信息/ ./ 此时/ 默认/ 序列/ 是/ 我们/ 进一步/ 分析/ 的/ 对象/ ,/ 其它/ 序列/ 信息/ 已经/ 可以/ 删除/ ./ 5.5/ 格式化/ 输出/ 在/ 报文/ 序列/ 的/ 可/ 打印/ 字符串/ 序列/ 中/ ,/ 还/ 可能/ 出现/ 一些/ 特殊字符/ ,/ 例如/ “/ (/ ”/ 、/ “/ )/ ”/ 、/ “/ :/ ”/ 、/ “/ ,/ ”/ 、/ “/ =/ ”/ 等/ ,/ 这些/ 字符/ 作为/ 分隔符/ 而/ 存在/ ./ 例如/ 在/ 报文/ 中常/ 出现/ “/ userName/ =/ sys/ ”/ 的/ 情况/ ,/ 得到/ 的/ 是/ 不变/ 域/ “/ user/ -/ Name/ =/ ”/ 、/ 可变/ 域/ “/ sys/ ”/ ./ 相对来说/ ,/ 我们/ 更/ 希望/ 得到/ 的/ 结果/ 是/ 不变/ 域/ “/ userName/ ”/ 、/ 不变/ 域/ “/ =/ ”/ 、/ 可变/ 域/ “/ sys/ ”/ ./ 因此/ 这/ 一步/ 操作/ 就是/ 将/ 分隔符/ 从/ 默认/ 序列/ 中/ 独立/ 出来/ ,/ 从而/ 更/ 细粒度/ 划分/ 字符串/ 域/ ./ 在/ 格式化/ 默认/ 序列/ 之后/ ,/ 就/ 完成/ 了/ 协议/ 自动识别/ 过程/ ./ 默认/ 序列/ 分析/ 结构/ 将/ 以/ HTML/ 的/ 方式/ 输出/ ,/ 称为/ PacketModel/ ./ 而/ 进行/ 模糊/ 测试/ 器/ 也/ 是/ 在/ PacketModel/ 的/ 基础/ 上/ 完成/ 的/ ./ 表/ 4/ 为/ Oracle/ 数据库/ 的/ 非/ 公开/ 协议/ TNS/ 经过/ 自动/ 分析/ 后/ ,/ 在/ 默认/ 序列/ 上/ 形成/ 的/ PacketModel/ ./ 序号/ 域/ 属性/ 0LengthField/ (/ 2/ )/ :/ 0/ ~/ 42x00xff1Binary/ -/ constant2LengthField/ (/ 2/ )/ :/ 5/ ~/ 42x00xc53LengthField/ (/ 2/ )/ :/ 0/ ~/ 4x00x3a4Binary/ -/ constant5String/ -/ constant/ (/ 6String/ -/ constantDESCRIPTION7String/ -/ constant/ =/ (/ 8String/ -/ constantCONNECT/ _/ DATA9String/ -/ constant/ =/ (/ 10String/ -/ constantSERVICE/ _/ NAME11String/ -/ constant/ =/ 12/ -/ 0String/ -/ variableorcl13String/ -/ constant/ )/ (/ 14String/ -/ constantCID15String/ -/ constant/ =/ (/ 16String/ -/ constantPROGRAM17String/ -/ constant/ =/ 18/ -/ 0String/ -/ variableF18/ -/ 1String/ -/ variable/ :/ 18/ -/ 2String/ -/ variable/ \/ oracle/ \/ 19String/ -/ constant10/ ./ 2.0/ \/ db/ _/ 1/ \/ bin/ \/ Page10/ 序号/ 域层性/ 20String/ -/ constant/ )/ (/ 21String/ -/ constantHOST22String/ -/ constant/ =/ 23/ -/ 0String/ -/ variable3226663CCD3D49224String/ -/ constant/ )/ (/ 25String/ -/ constantUSER26String/ -/ constant/ =/ 27/ -/ 0String/ -/ variableAdministrator28String/ -/ constant/ )/ )/ )/ (/ 29String/ -/ constantADDRESS30String/ -/ constant/ =/ (/ 31String/ -/ constantPROTOCOL32String/ -/ constant/ =/ 33String/ -/ constantTCP34String/ -/ constant/ )/ (/ 35String/ -/ constantHOST36String/ -/ constant/ =/ 37/ -/ 0String/ -/ variable192/ ./ 168.1/ ./ 7838String/ -/ constant/ )/ (/ 39String/ -/ constantPORT40String/ -/ constant/ =/ 41String/ -/ constant152142String/ -/ constant/ )/ )/ )/ 图/ 3/ 根据/ PacketModel/ 自动/ 生成/ 的/ TNS/ 协议/ 第/ 4/ 个/ 报文/ 的/ SPK/ 脚本/ 6/ 构造/ 模糊/ 器/ 本文/ 在/ SPIKE/ 框架/ 的/ 基础/ 上/ ,/ 自动/ 生成/ 模糊/ 测试/ 器/ Fuzzer/ ./ SPIKE/ 是/ 一个/ 对/ 网络协议/ 进行/ FuzzTesting/ 的/ 通用/ 框架/ ,/ 也/ 是/ 使用/ 最为/ 广泛/ 并且/ 被/ 人/ 所/ 熟知/ 的/ 模糊/ 测试/ 框架/ 之一/ ./ SPIKE/ 使用/ 数据/ 块/ 的/ 网络协议/ 分析/ 测试方法/ ,/ 通过/ 这种/ 方法/ ,/ 可以/ 自动/ 完成/ 数据/ 块/ 长度/ 的/ 计算/ 和/ 填充/ ,/ 提高/ 了/ 测试/ 成功率/ ,/ 同时/ 也/ 使/ 开发/ 过程/ 相对/ 简单/ ./ Fuzzer/ ,/ 实际上/ 是/ 进行/ Fuzzing/ 测试/ 的/ 程序/ ./ 在/ SPIKE/ 框架/ 下/ ,/ 它/ 由/ 两/ 部分/ 组成/ :/ 主控/ 程序/ 和/ 数据包/ 构造程序/ ./ 主控/ 程序/ 负责/ 和/ 目标/ 服务程序/ 进行/ 交互/ 操作/ ,/ 例如/ 发送/ 、/ 接收/ 数据包/ 等/ ./ 数据包/ 构造程序/ 可以/ 通过/ SPK/ 脚本/ 的/ 形式/ 实现/ ./ SPK/ 脚本/ 存放/ 着/ 构造/ 相应/ 数据包/ 的/ 语句/ ,/ 主控/ 程序/ 根据/ SPK/ 脚本/ 构造/ 具体/ 的/ 数据/ 报文/ ./ 本文/ 分析/ 目标/ 网络协议/ ,/ 得到/ 了/ 两/ 方面/ 的/ 信息/ :/ Page11/ 其一/ ,/ 默认/ 序列/ ,/ 它/ 反映/ 了/ 数据包/ 的/ 交互/ 过程/ ,/ 可以/ 通过/ 读取/ 默认/ 序列/ 了解/ 网络协议/ 的/ 类型/ 、/ IP地址/ 、/ 端口/ 、/ 主机名/ 、/ 报文/ 交互/ 过程/ 等/ 特征/ ./ 另外/ 一个/ 是/ PacketModel/ ,/ 它/ 记录/ 了/ 数据/ 报文/ 应该/ 如何/ 构造/ 以及/ 报文/ 中/ 哪些/ 部分/ 是/ 可以/ 变化/ 的/ ./ 因此/ 可以/ 从/ 默认/ 序列/ 自动化/ 产生/ 主控/ 程序/ ,/ 而/ 从/ PacketModel/ 自动化/ 产生/ SPK/ 脚本/ ./ 这样/ 来/ 产生/ SPIKE/ 框架/ 所/ 需要/ 的/ 所有/ 信息/ ./ 根据/ TNS/ 协议/ 第/ 4/ 个/ 报文/ 的/ PacketModel/ 产生/ 的/ SPK/ 脚本/ 如图/ 3/ 所示/ ./ 7/ 实验/ 测试/ 为了/ 测试/ 系统/ 的/ 运行/ 效果/ ,/ 我们/ 选择/ 了/ 多种/ 协议/ 进行/ 了/ 深入/ 测试/ ./ 通过/ 对/ 不同/ 协议/ 的/ 测试/ ,/ 检验/ 本/ 方法/ 对/ 不同/ 报文格式/ 和/ 数据类型/ 的/ 适应性/ ./ 为了/ 分析/ 比较/ ,/ 目标/ 协议/ 首先/ 经过/ 人工/ 分析/ ,/ 设计/ 出/ 数据包/ 构造/ 脚本/ 和/ 交互/ 控制/ 信息/ ,/ 利用/ SPIKE/ 挖掘/ 相关/ 协议/ 漏洞/ ./ 然后/ 在/ 没有/ 任何/ 人工干预/ 的/ 情况/ 下/ ,/ 利用/ 协议/ 自动/ 分析/ 技术/ ,/ 自动/ 生成/ SPIKE/ 模糊/ 器/ ,/ 再次/ 挖掘/ 协议/ 漏洞/ ./ 通过/ 比较/ 两次/ 漏洞/ 挖掘/ 情况/ ,/ 来/ 验证/ 自动化/ 方法/ 的/ 有效性/ ./ 7.1/ FTP/ 协议/ 测试/ FTP/ 协议/ 是/ 一个/ 公开/ 的/ 协议/ ,/ 它/ 的/ 应用/ 也/ 非常/ 广泛/ ./ 在/ FTP/ 服务器软件/ ServU4/ ./ 0/ 上/ 存在/ 两个/ 远程/ 缓冲区/ 溢出/ 漏洞/ ./ 其中/ 一个/ 是/ 列/ 目录/ LIST/ 命令/ :/ LIST/ -/ l/ :/ ParamString/ ./ 如果/ ParamString/ 是/ 一个/ 超长/ 的/ 字符串/ ,/ 那么/ 就/ 会/ 导致/ 缓冲区/ 溢出/ ./ 另/ 一个/ 存在/ 溢出/ 漏洞/ 的/ 是/ MDTM/ 命令/ ,/ 格式/ 为/ MDTMtime/ +/ timezoneremote/ -/ filename/ ,/ 当/ “/ +/ ”/ 后面/ timezone/ 的/ 参数/ 是/ 超长/ 字符串/ 时/ ,/ 也/ 会/ 导致/ 溢出/ ./ 通过/ 对/ FTP/ 协议/ 进行/ 自动化/ 分析/ ,/ 能够/ 正确/ 地/ 建立/ LIST/ 和/ MDTM/ 两个/ 命令/ 的/ 报文格式/ ,/ 例如/ MDTM/ 命令/ 经过/ 分析/ 产生/ PacketModel/ ,/ 并/ 生成/ SPIKE/ 构造/ 脚本/ 如图/ 4/ 所示/ ./ 图/ 5/ 自动识别/ 和/ 手工/ 识别/ 的/ 可变/ 域/ 经过/ 实际/ 测试/ 发现/ ,/ 当/ “/ 20151207233859/ ”/ 或/ “/ ZZZ/ ”/ 被/ 超长/ 字符串/ 替换/ 的/ 时候/ ,/ 都/ 将/ 导致/ 服务器/ 进程/ 直接/ 发生/ 溢出/ 异常/ 而/ 停止/ 服务/ ,/ 即/ 无论/ 溢出/ “/ +/ ”/ 前面/ 的/ 时间/ 还是/ “/ +/ ”/ 后面/ 的/ 时区/ 都/ 存在/ 溢出/ 漏洞/ ./ 而/ LIST/ 超长/ 参数/ 溢出/ 漏洞/ 也/ 能够/ 被/ 正确/ 地/ 检测/ 到/ ./ 因此/ 自动化/ FuzzTesting/ 漏洞/ 挖掘/ 方法/ 对于/ FTP/ 协议/ 取得/ 了/ 很/ 好/ 的/ 测试/ 效果/ ./ 7.2/ TNS/ 协议/ 测试/ 分析/ TNS/ 协议/ 是/ Oracle/ 数据库/ 管理系统/ 服务端/ 和/ 客户端/ 通信/ 的/ 协议/ ,/ 暂时/ 没有/ 官方/ 文档/ 进行/ 详细/ 介绍/ ,/ 属于/ 一种/ 未公开/ 协议/ ./ TNS/ 协议/ 传输/ 可以/ 使用/ 多种/ 方式/ 传输/ ,/ 包括/ TCP/ // IP/ 协议/ 、/ SSL/ 的/ TCP/ // IP/ 协议/ 、/ 命名/ 管道/ 和/ IPC/ 等/ ,/ 其中/ TCP/ // IP/ 协议/ 传输/ 部分/ 使用/ 明文/ 传送/ ./ 根据/ 观察/ ,/ TNS/ 有/ 10/ 多种不同/ 的/ 报文格式/ ,/ 属于/ 比较复杂/ 的/ 协议/ ,/ 而且/ 不同/ 的/ Oracle/ 版本/ 的/ TNS/ 协议/ 也/ 有/ 一定/ 的/ 差异/ ,/ 说明/ 该/ 协议/ 仍然/ 处于/ 不断/ 开发/ 和/ 改进/ 中/ ,/ 同时/ 也/ 容易/ 存在/ 未公开/ 漏洞/ ,/ 因此/ 本文/ 选择/ Oracle10g2/ 版本/ 进行/ 分析测试/ ,/ 既/ 可以/ 检验/ 自动化/ FuzzTesting/ 漏洞/ 挖掘/ 方法/ 对/ 未公开/ 网络协议/ 的/ 测试/ 效果/ ,/ 又/ 具有/ 一定/ 的/ 应用/ 价值/ ./ TNS/ 协议/ 在/ 完成/ 三次/ 握手/ 之后/ ,/ 从/ 第/ 4/ 个/ 数据包/ 开始/ 和/ 服务器/ 交互/ ,/ 在/ 第/ 18/ 个/ 数据包/ 以/ 明文/ 的/ 方式/ 发送/ 用户名/ 到/ 服务器/ ,/ 而/ 在/ 第/ 20/ 个/ 数据包/ 以/ 密文/ 的/ 方式/ 发送/ 密码/ ./ 由于/ 加密/ 报文/ 无法/ 有效/ 地/ 进行/ FuzzTesting/ ,/ 本文/ 主要/ 对/ TNS/ 的/ 前/ 20/ 个/ 数据包/ 进行/ 了/ 分析/ (/ 图/ 3/ 为/ 第/ 4/ 个/ 数据包/ 的/ PacketModel/ )/ ,/ 采样/ 的/ 报文/ 一共/ 是/ 7/ 组/ ./ 首先/ 手工/ 分析/ 该/ 协议/ ,/ 构造/ SPIKE/ 测试/ 脚本/ 进行/ 测试/ ./ 另外/ ,/ 利用/ 自动化/ FuzzTesting/ 漏洞/ 挖掘/ 方法/ ,/ 同样/ 产生/ 了/ 相应/ 的/ 脚本/ 信息/ ,/ 进行/ 自动化/ 测试/ ./ 对/ 两次/ 的/ 分析/ 结果/ 如图/ 5/ 所示/ ./ Page12/ 图/ 5/ 中/ 左侧/ 为/ 自动化/ 识别/ 出来/ 的/ 各种/ 可变/ 域/ ,/ 右侧/ 为/ 手工/ 识别/ 出来/ 的/ 各种/ 可变/ 域/ ./ 可以/ 看出/ 自动化/ 识别/ 的/ 可变/ 域/ 数量/ 远远/ 小于/ 手工/ 识别/ 数量/ ,/ 主要/ 是因为/ 自动化/ 识别/ 的/ 报文/ 变化/ 不够/ 大/ ,/ 局限/ 在/ 一定/ 的/ 范围/ ,/ 导致/ 很多/ 可变/ 域/ 不能/ 识别/ ./ 人工/ 分析/ 时/ ,/ 可以/ 根据/ 分析/ 者/ 的/ 经验/ ,/ 识别/ 可以/ 测试/ 的/ 域/ ./ 对/ 这些/ 可变/ 域/ 分别/ 进行/ 测试/ ,/ 结果/ 如表/ 5/ 所示/ ./ 报文/ 序号/ 4000000600000080000001029112021215610113011000160110001801100020112000/ 总和/ 41822303/ 表/ 5/ 中/ 手工/ 分析/ 发现/ 的/ 漏洞/ 而言/ ,/ 长度/ 域/ 导致/ 的/ 漏洞/ 为/ 4/ 个/ ,/ 其它/ 的/ 异常/ 均/ 由于/ 二进制/ 域/ 引发/ ,/ 而/ 字符串/ 则/ 没有/ 测试/ 出/ 任何/ 异常情况/ ,/ 总/ 的/ 发现/ 漏洞/ 个数/ 远大于/ 自动化/ 分析/ 发现/ 的/ 3/ 个/ 漏洞/ ./ 由于/ 自动化/ 分析/ 的/ 可变/ 域/ 和/ 不可/ 变域/ 是/ 根据/ 采样/ 的/ 报文/ 得到/ 的/ ,/ 因此/ 很/ 可能/ 很多/ 不可/ 变域/ 其实/ 是/ 可变/ 的/ ,/ 因此/ 可以/ 进一步/ 地/ 采样/ ,/ 当/ 采样/ 的/ 报文/ 组/ 达到/ 15/ 组/ 的/ 时候/ ,/ 可以/ 看到/ 自动化/ 识别/ 的/ 可变/ 域/ 增加/ 非常/ 显著/ ,/ 如图/ 6/ 所示/ ./ 根据/ 图/ 6/ ,/ 在/ 自动化/ 识别/ 的/ 大量/ 可变/ 域/ 中/ 进行/ FuzzTesting/ ,/ 可以/ 得到/ 如表/ 6/ 所示/ 的/ 漏洞/ 挖掘/ 结果/ ./ 数据包/ 手工/ 分析/ 40000000060000000080000000010290112911212150616071301010101160101010118010101012011020101/ 总和/ 418022319123/ 实验/ 数据/ 表明/ ,/ 协议/ 自动/ 分析/ 发现/ 的/ 漏洞/ 为/ 23/ 个/ ,/ 已经/ 超过/ 手工/ 分析/ 发现/ 的/ 22/ 个/ 漏洞/ ./ 就/ 漏洞/ 数量/ 而言/ ,/ 二者/ 性能/ 基本/ 类似/ ,/ 只有/ 少量/ 数据包/ 中/ 存在/ 差别/ ./ 这/ 充分说明/ ,/ 利用/ 协议/ 自动/ 分析/ 技术/ 来/ 替换/ 手工/ 分析/ 完成/ 数据包/ 的/ 分析/ 和/ Fuzzer/ 的/ 构造/ 是/ 可行/ 的/ ./ 通过/ 分析/ 两种/ 方法/ 发现/ 漏洞/ 的/ 差异/ ,/ 可以/ 进一步/ 地/ 了解/ 各自/ 的/ 优势/ ./ 首先/ ,/ 在/ 对/ 第/ 10/ 号/ 数据包/ 进行/ 分析/ 的/ 时候/ ,/ 协议/ 自动识别/ 发现/ 了/ 一个/ 字符串/ 产生/ 的/ 漏洞/ ,/ 而/ 手工/ 分析/ 遗漏/ 该/ 漏洞/ ./ 分析/ 数据包/ 构造/ 脚本/ 可以/ 发现/ ,/ 在/ 手工/ 分析/ 时/ ,/ 将/ 字符串/ ”/ NTLMSSP/ ”/ 作为/ 二进制/ 数据处理/ ,/ 虽然/ 对/ 这个/ 域/ 进行/ 了/ 测试/ ,/ 但是/ 却/ 遗漏/ 了/ 这个/ 漏洞/ ./ 而/ 在/ 协议/ 自动识别/ 中/ 成功/ 地/ 识别/ 这个/ 结构/ 并且/ 进行/ 了/ 测试/ 分析/ ./ 实际上/ ,/ 在/ 我们/ 进行/ TNS/ 协议/ 测试/ 中/ ,/ 这是/ 唯一/ 的/ 一个/ 由/ 字符串/ 引发/ 的/ 漏洞/ ,/ 而且/ 这个/ 字符串/ 导致/ 的/ 是/ 缓冲区/ 溢出/ 漏洞/ ,/ 可能/ 会/ 导致/ 非常/ 严重/ 的/ 安全/ 问题/ ./ 在/ 第/ 20/ 号/ 数据包/ 的/ 分析/ 中/ ,/ 协议/ 自动识别/ 产生/ 的/ Fuzzer/ 遗漏/ 了/ 一个/ 长度/ 域/ 造成/ 的/ 拒绝服务/ 漏洞/ ./ 我们/ 通过/ 对比/ 二者/ 产生/ 的/ 数据包/ 构造/ 脚本/ 分析/ 产生/ 这种/ 情况/ 的/ 原因/ ./ 在/ 手工/ 分析/ 中/ ,/ 在/ 传输/ “/ SessionKey/ ”/ 的/ 时候/ ,/ 有/ 两个/ 前置/ 的/ 长度/ 域/ ,/ 这/ 两个/ 长度/ 域/ 由/ 3/ 个/ 字节/ 的/ 0x00/ 分隔/ ./ 而/ 在/ 协议/ 自动识别/ 过程/ 中/ ,/ 这个/ 结构/ 完全/ 被/ 破坏/ :/ 首先/ ,/ 传输/ 的/ SessionKey/ 被/ 认为/ 是/ 字符串/ ,/ 而/ SessionKey/ 对应/ 的/ 长度/ 0x40/ 刚好/ 被/ 认为/ 是/ “/ @/ ”/ 字符/ (/ 也/ 就是/ 图/ 7/ 中/ 第/ 1/ 行/ 表示/ 的/ 字节/ )/ ,/ 这样/ 处理/ 的/ 主要/ 原因/ 是/ 这/ 两个/ 0x40/ 分别/ 在/ 两个/ 字符串/ 的/ 末端/ ./ 正是/ 由于/ 协议/ 自动识别/ 中将/ 这个/ 结构/ 破坏/ 了/ ,/ 所以/ 导致/ 最终/ 遗漏/ 这个/ 长度/ 域/ 引发/ 的/ 漏洞/ ./ 图/ 7/ 手工/ 分析/ 的/ 20/ 号/ 报文/ SessionKey/ 结构/ Page13/ 图/ 8/ 自动化/ 分析/ 的/ 20/ 号/ 报文/ SessionKey/ 结构/ 另外/ 在/ 第/ 12/ 个/ 数据包/ 的/ 环境/ 中/ ,/ 自动化/ 识别/ 的/ 划分/ 粒度/ 比/ 人工/ 识别/ 的/ 划分/ 粒度/ 更/ 小/ ,/ 也/ 导致/ 自动识别/ 报告/ 的/ 漏洞/ 数量/ 大于/ 人工/ 识别/ 的/ 数量/ ./ 7.3/ 其它/ 协议/ 测试/ 分析/ 利用/ 自动化/ 网络协议/ 漏洞/ 挖掘/ 方法/ ,/ 本文/ 继续/ 测试/ 了/ Oracle/ 数据库/ 的/ EM/ 和/ ISQLPlus/ 协议/ ./ Oracle/ 服务器/ 本地/ 可以/ 通过/ SQLPlus/ 登录/ 数据库/ 并/ 执行/ 数据库/ 操作/ ./ 为了/ 方便管理/ ,/ Oracle/ 服务器/ 也/ 提供/ 了/ HTTP/ 方式/ 管理/ 数据库/ ./ 在/ Oracle10G2/ 版本/ 中/ ,/ 通过/ 基于/ HTTP/ 的/ EM/ 协议/ 登录/ 远程/ 服务器/ 并/ 执行/ 管理/ 操作/ ,/ ISQLPlus/ 则/ 是/ 执行/ 数据库/ 语句/ 的/ 接口/ ./ 这/ 两个/ 服务/ 都/ 是/ 基于/ HTTP/ 的/ ,/ 而且/ 传输/ 过程/ 没有/ 加密/ ,/ 包括/ 用户名/ 和/ 密码/ ,/ 本文/ 仅/ 对/ 每个/ 协议/ 的/ 第一个/ 数据包/ 进行/ 了/ 漏洞/ 挖掘/ ,/ 测试/ 结果表明/ 协议/ 自动识别/ 能够/ 正确/ 地/ 识别/ 协议/ 中/ 的/ 域/ ./ 在/ EM/ 协议/ 中共/ 测试/ 出/ 2/ 个/ 拒绝服务/ 漏洞/ ,/ 在/ ISQLPlus/ 中/ 测试/ 出/ 3/ 个/ 拒绝服务/ 漏洞/ ./ 8/ 结论/ 和/ 展望/ 本文/ 描述/ 了/ 自动化/ 识别/ 网络协议/ 并/ 产生/ 模糊/ 器/ 对/ 网络协议/ 进行/ FuzzTesting/ 的/ 漏洞/ 挖掘/ 方法/ ,/ 并用/ 这种/ 方法/ 对/ 多种/ 公开/ 和/ 未公开/ 网络协议/ 进行/ 了/ 测试/ ./ 结论/ 是/ 这种/ 方法/ 具有/ 快速/ 、/ 准确/ 的/ 优点/ ./ 同时/ 无需/ 预先/ 了解/ 网络协议/ 的/ 语法/ ,/ 配置/ 非常简单/ ,/ 能够/ 节省/ 大量/ 的/ 手工/ 分析/ 时间/ ./ 在/ 网络协议/ 安全性/ 检测/ 、/ 网络/ 风险/ 分析/ 、/ 模拟/ 网络服务/ 的/ 蜜罐/ 系统/ 方面/ ,/ 具有/ 重要/ 的/ 应用/ 价值/ ./ 本文/ 主要/ 做出/ 的/ 工作/ 包含/ 如下/ 部分/ :/ 首先/ 提出/ 了/ 自动化/ 网络协议/ FuzzTesting/ 的/ 完整/ 方案/ ;/ 其次/ ,/ 在/ 网络/ 报文/ 多/ 序列/ 比/ 对/ 过程/ 中/ 提出/ 了/ 基于/ 报文/ 长度/ 的/ 渐进/ 比/ 对/ 和/ 连续/ 匹配/ 奖励/ 的/ NeedlemanWunsch/ 算法/ ,/ 这/ 两个/ 方法/ 在/ 实验/ 中/ 比/ 基于/ 免疫/ 的/ 遗传算法/ 要/ 优越/ 很多/ ,/ 适合/ 网络/ 报文/ 的/ 比/ 对/ ;/ 对/ 网络/ 报文/ 特殊/ 域/ 的/ 识别/ 做/ 了/ 较为/ 深入/ 的/ 研究/ ,/ 例如/ 长度/ 域/ 、/ Unicode/ 域/ 和/ 特殊/ 分隔符/ 等/ ,/ 并/ 提出/ 了/ 二进制/ 和/ 文本/ 网络协议/ 应该/ 区分/ 处理/ ,/ 相比/ 之前/ 的/ 研究成果/ 更加/ 深入/ 和/ 细致/ ./ 最后/ ,/ 在/ 测试/ 部分/ ,/ 针对/ 公开/ 和/ 未公开/ 的/ FTP/ 、/ TNS/ 、/ IM/ 、/ ISQLPlus/ 进行/ 了/ 深入/ 测试/ ,/ 给出/ 了/ 详细/ 的/ 测试/ 结果/ ./ 在/ 实验/ 中/ ,/ 我们/ 也/ 发现/ 本/ 方法/ 的/ 效果/ 依赖于/ 采样/ 报文/ 本身/ 的/ 多样性/ ,/ 需要/ 对/ 网络协议/ 多次/ 采样/ ,/ 并/ 尽量/ 保证/ 每次/ 用/ 不同/ 参数/ 来/ 使用/ 网络协议/ ./ 如何/ 以/ 尽量少/ 的/ 采样/ 次数/ 得到/ 最好/ 的/ 网络协议/ 识别/ 结果/ 是/ 我们/ 未来/ 需要/ 深入研究/ 的/ 工作/ ./ 

