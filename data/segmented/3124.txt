Page1/ 基于/ 输入/ 端/ 无/ 冲突/ 算法/ 的/ 面向/ 输出/ 排队/ 的/ 交换/ 结构/ 夏羽/ 高志/ 江曾/ 华遷/ (/ 西南/ 交通/ 大学/ 信息科学/ 与/ 技术/ 学院/ 成都/ 610031/ )/ 摘要/ 该文/ 提出/ 了/ 一种/ 全新/ 的/ 面向/ 输出/ 排队/ 的/ 交换/ 结构/ ,/ 该/ 结构/ 将/ 信元/ 存储/ 于/ 输入/ 端/ ,/ 而/ 信元/ 的/ 调度/ 请求/ 面向/ 输出/ 端/ 排队/ ./ 利用/ 输入/ 端/ 无/ 冲突/ 调度/ 算法/ ,/ 可以/ 使/ 结构/ 对/ 存储器/ 带宽/ 的/ 需求/ 和/ 输入/ 排队/ 交换机/ 一致/ ./ 该文/ 设计/ 的/ 调度/ 矩阵/ 使/ 算法/ 复杂度/ 和/ 端口/ 规模/ 呈/ 线性关系/ ,/ 且/ 每/ 一步/ 只/ 需要/ 一次/ 按位/ “/ 与/ ”/ 操作/ ./ 文章/ 同时/ 证明/ 了/ 结构/ 要/ 达到/ 稳定/ 的/ 充分条件/ 是/ 使用/ 2/ 倍/ 传输/ 加速/ 比/ ./ 仿真/ 实验/ 表明/ ,/ 对于/ 均匀/ 流量/ ,/ 该/ 结构/ 时延/ 性能/ 和/ 主流/ 交换/ 结构/ 相似/ ,/ 且/ 抖动/ 性能/ 远/ 优于/ 主流/ 交换/ 结构/ ,/ 而/ 在/ 2/ 倍/ 传输/ 加速/ 比时/ ,/ 其时/ 延/ 性能/ 和/ OQ/ 完全相同/ ;/ 对于/ 非/ 均匀/ 流量/ ,/ 该/ 结构/ 吞吐/ 率/ 性能/ 优于/ 主流/ 交换/ 结构/ ,/ 且/ 在/ 使用/ 1.14/ 倍/ 传输/ 加速/ 比时/ ,/ 其/ 吞吐/ 率/ 性能/ 和/ OQ/ 相同/ ./ 关键词/ 交换机/ 架构/ ;/ 吞吐/ 率/ ;/ 稳定性/ ;/ 输入/ 排队/ ;/ 面向/ 输出/ 排队/ 1/ 引言/ 交换机/ // 路由器/ 已经/ 成为/ 影响/ 网络/ 性能/ 的/ 关键设备/ ,/ 对于/ 未来/ 单/ 波长/ 速率/ 高达/ 100Gbps/ 以上/ 的/ 高速/ 骨干/ 通信子网/ ,/ 对/ 交换/ 结构/ 和/ 调度/ 算法/ 的/ 挑战/ 更为/ 严峻/ ./ 早期/ 交换机/ 使用/ 的/ 共享/ 存储/ (/ SharedMem/ -/ ory/ ,/ SM/ )/ 和/ 输出/ 排队/ (/ Output/ -/ Queued/ ,/ OQ/ )/ 结构/ 虽/ Page2/ 然/ 被/ 证明/ 能够/ 提供/ 最好/ 的/ 性能/ ,/ 但/ 却/ 不能/ 用于/ 现代/ 高速/ 网络/ 环境/ ,/ 原因/ 在于/ 它们/ 需要/ 存储器/ 速率/ 分别/ 为/ 2NR/ (/ N/ 次/ 写入/ 和/ N/ 次/ 读出/ )/ 和/ (/ N/ +/ 1/ )/ R/ (/ N/ 次/ 写入/ 1/ 次/ 读出/ )/ ,/ 其中/ N/ 为/ 交换/ 结构/ 的/ 端口数/ ,/ R/ 为/ 端口/ 速率/ ./ 目前/ 的/ 商用/ 存储器/ 发展/ 远远/ 落后/ 于/ 交换机/ 对/ 存储器/ 的/ 需求/ ,/ 存储器/ 已经/ 成为/ 交换机/ 性能/ 的/ 瓶颈/ ,/ 而/ OQ/ 交换机/ 需要/ 交换/ 矩阵/ (/ switchfabric/ )/ 工作/ 速率/ 为线/ 速率/ 的/ N/ 倍/ ,/ 这/ 也/ 使/ 其/ 难以/ 满足/ 大规模/ 高速/ 交换/ 的/ 需要/ ./ 输入/ 排队/ (/ Input/ -/ Queued/ ,/ IQ/ )/ 的/ 交换/ 结构/ 只/ 需要/ 在/ 每个/ 时/ 槽内/ 对/ 存储器/ 读/ 、/ 写/ 各/ 一次/ ,/ 在/ 同样/ 的/ 端口/ 速率/ 下/ ,/ 其/ 对/ 存储器/ 速率/ 的/ 要求/ (/ 2R/ )/ 远远/ 低于/ OQ/ 交换机/ ,/ 且/ 与/ 交换/ 规模/ 无关/ ,/ 因此/ 成为/ 目前/ 主流/ 的/ 交换/ 结构/ ./ 但是/ IQ/ 交换机/ 受/ “/ 队头/ 阻塞/ ”/ (/ Head/ -/ of/ -/ LineBlocking/ ,/ HoLblocking/ )/ 的/ 制约/ ,/ 对/ 均匀/ 流量/ 也/ 只能/ 提供/ 58/ %/ 左右/ 的/ 吞吐/ 率/ [/ 1/ ]/ ./ 采用/ 虚拟/ 输出/ 队列/ (/ VirtualOutputQueue/ ,/ VOQ/ )/ 可以/ 解决/ “/ 队头/ 阻塞/ ”/ 问题/ ,/ 但/ 加剧/ 了/ 输出/ 竞争/ ,/ 需要/ 额外/ 的/ 匹配/ 调度/ 算法/ ./ 基于/ VOQ/ 的/ 交换/ 结构/ 的/ 仲裁/ 配/ 调度/ 问题/ 被/ 抽象/ 成/ 图论/ 中/ 的/ 二分/ 图/ 匹配/ (/ bipartitegraphmatching/ )/ 问题/ ,/ 并/ 有如/ 下结论/ :/ (/ 1/ )/ 使用/ 最大/ 匹配/ (/ MaximizeSizeMatching/ ,/ MSM/ )/ 算法/ ,/ 其/ 复杂度/ 为/ O/ (/ N2/ ./ 5/ )/ ,/ 且/ 不能/ 达到/ 100/ %/ 吞吐/ 率/ ;/ (/ 2/ )/ 使用/ 最大/ 权值/ 匹配/ (/ MaximizeWeightMatching/ ,/ MWM/ )/ 算法/ ,/ 如/ LQF/ (/ LongestQueueFirst/ )/ 、/ OCF/ (/ OldestCellFirst/ )/ 或/ LPF/ (/ LongestPortFirst/ )/ ,/ 可以/ 达到/ 100/ %/ 的/ 吞吐/ 率/ [/ 2/ ]/ ./ 但是/ MWM/ 算法/ 的/ 复杂度/ 为/ O/ (/ N3/ )/ ,/ 这/ 使得/ 它/ 难以/ 在/ 高速/ (/ high/ -/ speed/ )/ 或/ 大规模/ (/ large/ -/ scale/ )/ 的/ 交换机/ 中/ 使用/ ./ 随后/ 的/ 文献/ 提出/ 了/ 大量/ 时间/ 复杂度/ 较/ 低/ 的/ 极大/ 匹配/ (/ maximalSizeMatching/ ,/ mSM/ )/ 算法/ ,/ 如/ 著名/ 的/ PIM/ [/ 3/ ]/ 、/ iSLIP/ [/ 4/ ]/ 和/ DRRM/ [/ 5/ ]/ 等/ 算法/ 以及/ 它们/ 的/ 大量/ 改进/ 算法/ 都/ 是/ 对/ 极大/ 匹配/ 算法/ 的/ 趋近/ ./ 然而/ ,/ 这些/ 启发式/ 算法/ (/ heuristicalgo/ -/ rithms/ )/ ,/ 最多/ 也/ 只能/ 对/ 均匀/ 流量/ 提供/ 100/ %/ 的/ 吞吐/ 率/ ,/ 而/ 对/ 非/ 均匀/ 流量/ 不能/ 保证/ 100/ %/ 的/ 吞吐/ 率/ ./ 文献/ [/ 6/ ]/ 提出/ 的/ MQWS/ 算法/ 在/ 保持/ 和/ iSLIP/ 算法/ 相似/ 复杂度/ 的/ 条件/ 下/ ,/ 可以/ 对非/ 均匀/ 流量/ 提供/ 很/ 高/ 的/ 吞吐/ 率/ ,/ 但/ 还是/ 不/ 保证/ 在/ 任意/ 许可/ 流量/ 下均/ 达到/ 100/ %/ 吞吐/ 率/ ./ 因此/ 如何/ 设计/ 高效/ 、/ 稳定/ 且/ 高性能/ 的/ 匹配/ 调度/ 算法/ 便/ 成为/ 基于/ VOQ/ 的/ 交换机/ 设计/ 中/ 的/ 核心/ 问题/ ./ 另/ 一种/ 可以/ 有效/ 提高/ IQ/ 交换/ 结构/ 的/ 吞吐/ 率/ ,/ 而/ 不/ 需要/ 高/ 复杂度/ 调度/ 算法/ 的/ 途径/ 是/ 使用/ 加速/ 比/ (/ speedup/ )/ ,/ 输入/ 端口/ 接收/ 一个/ 信元/ 的/ 时间/ 称为/ 一个/ (/ 外部/ )/ 时槽/ (/ externaltimeslot/ )/ ,/ 在/ 加速/ 比为/ s/ 的/ 条件/ 下/ ,/ 一个/ 外部/ 时/ 槽内/ 有/ s/ 个/ 信元/ 可以/ 从/ 输入/ 端/ 通过/ 交换/ 矩阵/ 被/ 发送到/ 输出/ 端/ (/ 其中/ 传输/ 一个/ 信元/ 的/ 时间/ 称为/ 一个/ 传输/ 时槽/ ,/ 有/ 的/ 文献/ 也/ 称/ 其/ 为/ 内部/ 时槽/ (/ internaltimeslot/ )/ )/ ,/ 而/ 一个/ 时/ 槽内/ ,/ 只有/ 一个/ 信元/ 可以/ 从/ 输出/ 端口/ 离开/ ,/ 因此/ 输出/ 端/ 需要/ 缓存/ ,/ 从而/ 形成/ 输入输出/ 结合/ 排队/ 的/ (/ CombinedInput/ &/ OutputQueued/ ,/ CIOQ/ )/ 交换/ 结构/ ./ 当/ 加速/ 比为/ 2/ 时/ ,/ 采用/ 极大/ 匹配/ 算法/ (/ MaximalSizeMatching/ )/ 的/ CIOQ/ 结构/ 可以/ 提供/ 100/ %/ 的/ 吞吐/ 率/ ./ 上述/ 交换/ 结构/ 的/ 后续/ 研究/ 文献/ 中/ 还/ 提出/ 过/ 多种/ 新型/ 交换/ 结构/ ,/ 如/ 基于/ BufferedCrossbar/ 的/ 交换/ 结构/ [/ 7/ ]/ 、/ Clos/ 的/ 网络结构/ [/ 8/ ]/ 和/ 负载/ 均衡/ 的/ BvN/ (/ LoadBalancedBirkhoff/ -/ vonNewmen/ )/ 交换/ 结构/ [/ 9/ ]/ ./ 第/ 1/ 种/ 结构/ 需要/ 使用/ 交叉/ 节点/ 带/ 缓存/ 的/ crossbar/ ,/ 而后/ 两者/ 属于/ 多级/ 交换/ 结构/ ./ BufferedCrossbar/ 交换/ 结构/ 的/ 规模/ 受限于/ 超大规模/ 集成电路/ 的/ 工艺/ 而/ 性能/ 受限于/ 大/ 往返/ 时间/ (/ LongRound/ -/ TripTime/ ,/ LongRTT/ )/ 问题/ ;/ Clos/ 结构/ 的/ 内部/ 冲突/ 问题/ ,/ 需要/ 额外/ 的/ 算法/ 来/ 解决/ ,/ 且/ 其/ 性能/ 的/ 好坏/ 还要/ 取决于/ 其所/ 使用/ 的/ 单级/ 交换/ 结构/ ;/ 负载/ 均衡/ 交换/ 结构/ 虽然/ 无需/ 调度/ 算法/ 但/ 时延/ 性能/ 不佳/ ,/ 且/ 存在/ 分组/ 失序/ 问题/ ,/ 解决/ 分组/ 失序/ 需要/ 额外/ 的/ 算法/ ,/ 且会/ 进一步/ 降低/ 时延/ 性能/ 甚至/ 吞吐/ 率/ ./ 这些/ 问题/ 都/ 阻碍/ 了/ 这些/ 新/ 结构/ 在/ 工业界/ 的/ 大规模/ 使用/ ,/ 因此/ 目前/ 主流/ 交换机/ 的/ 设计/ 和/ 生产/ 主要/ 还是/ 使用/ 或者/ 基于/ crossbar/ 单级/ 交换/ 结构/ ./ IQ/ 交换/ 结构/ 调度/ 算法/ 复杂度/ 高且/ 可达性/ 能/ 受限/ ,/ 而/ OQ/ 交换/ 结构/ 性能/ 较/ 好/ 却/ 依赖于/ 高速/ 存储器/ 以及/ 具有/ N/ 倍/ 加速/ 比/ 的/ 交换/ 矩阵/ ./ 本文/ 试图/ 在/ 交换/ 性能/ 、/ 调度/ 及/ 实现/ 复杂度/ 之间/ 找/ 一个/ 平衡点/ ,/ 提出/ 了/ 一种/ 能够/ 发挥/ 两种/ 典型/ 存储/ 排队/ 方式/ 的/ 优势/ ,/ 同时/ 调度/ 与/ 实现/ 复杂度/ 相对/ 较/ 低/ 的/ 面向/ 输出/ 排队/ (/ Out/ -/ put/ -/ OrientedQueued/ )/ 的/ 交换/ 结构/ ,/ 它/ 属于/ 输入/ 存储/ 的/ 单级/ crossbar/ 交换/ 结构/ ./ 本文/ 设计/ 的/ 输入/ 端/ 无/ 冲突/ (/ InputConflict/ -/ Free/ ,/ ICF/ )/ 算法/ ,/ 可以/ 保证/ 在/ 2/ 倍/ 传输/ 加速/ 比/ (/ 无/ 调度/ 加速/ 比/ )/ 的/ 条件/ 下/ ,/ 即/ 每块/ 存储器/ 只/ 需要/ 3R/ 的/ 带宽/ (/ 输入/ 缓存/ 为/ 一次/ 写入/ 和/ 两次/ 读取/ ,/ 输出/ 缓存/ 为/ 两次/ 写入/ 一次/ 读取/ )/ ,/ 使/ OOQ/ 交换/ 结构/ 对/ 任意/ 许可/ 流量/ 提供/ 100/ %/ 的/ 吞吐/ 率/ ./ 配合/ 本文/ 设计/ 的/ 调度/ 矩阵/ ,/ 每个/ 分组/ 到达/ 时/ ,/ 只/ 需要/ 一次/ 并行/ 按位/ “/ 与/ ”/ (/ bitwiseand/ )/ 操作/ 即可/ 完成/ 调度/ ./ 仿真/ 实验/ 表明/ ,/ 在/ 许可/ 流量/ 下/ ,/ 不/ 需要/ 加速/ 比/ ,/ 该/ 交换/ 结构/ 即可/ 对/ 均匀/ 流量/ 提供/ 100/ %/ 的/ 吞吐/ 率/ ,/ 且/ 时延/ 和/ 现有/ 主流/ 结构/ 或/ 算法/ 相当/ ,/ 而/ 由于/ OOQ/ 结构/ 能/ 最大/ 程度/ 地/ 保持/ 信元/ 先进先出/ 的/ 顺序/ ,/ 因此/ 时延/ 抖/ Page3/ 动/ 性能/ 明显/ 高于/ 现有/ 交换/ 结构/ 而/ 和/ OQ/ 相当/ ;/ 对非/ 均匀/ 流量/ ,/ OOQ/ 也/ 可以/ 提供/ 很/ 高/ 的/ 吞吐/ 率/ ,/ 当/ 使用/ 1.14/ 倍/ 传输/ 加速/ 比/ 而/ 无需/ 调度/ 加速/ 比/ ,/ 就/ 可以/ 对/ 各种/ 非/ 均匀/ 流量/ 提供/ 100/ %/ 的/ 吞吐/ 率/ ./ 本文/ 第/ 2/ 节/ 介绍/ 面向/ 输出/ 排队/ 的/ 交换/ 结构/ 和/ 输入/ 端/ 无/ 冲突/ 算法/ ;/ 第/ 3/ 节/ 证明/ 交换/ 结构/ 传输/ 加速/ 比为/ 2/ 是/ OOQ/ // ICF/ 结构/ 对/ 任意/ 许可/ 流量/ 提供/ 100/ %/ 吞吐/ 率/ 的/ 充分条件/ ;/ 第/ 4/ 节/ 探讨/ ICF/ 调度/ 矩阵/ 的/ 硬件/ 实现/ ;/ 第/ 5/ 节/ 通过/ 仿真/ 比较/ OOQ/ // ICF/ 和/ 其它/ 主流/ 交换/ 结构/ 和/ 算法/ 的/ 性能/ ;/ 第/ 6/ 节将/ 讨论/ OOQ/ // ICF/ 交换/ 结构/ 为何/ 能/ 更好/ 地/ 支持/ SUPANET/ 网络/ 环境/ ;/ 第/ 7/ 节/ 总结/ 全文/ 并/ 展望/ 下/ 一步/ 的/ 工作/ ./ 2/ 面向/ 输出/ 排队/ 的/ (/ OOQ/ )/ 交换/ 结构/ 和/ 输入/ 端/ 无/ 冲突/ (/ ICF/ )/ 算法/ 2.1/ OOQ/ 交换/ 结构/ 设/ 一个/ 交换机/ 有/ N/ 个/ 输入/ 端口/ 和/ N/ 个/ 输出/ 端口/ (/ 记为/ N/ ×/ N/ 的/ 交换机/ )/ ,/ 通常/ 交换机/ 内部/ 只/ 处理/ 定/ 长/ 分组/ ,/ 称为/ 信元/ (/ cell/ )/ ,/ 若/ 输入/ 端口/ 接收/ 的/ 是/ 变长/ 分组/ ,/ 则/ 将/ 其/ 切分/ (/ segment/ )/ 为定/ 长信/ 元/ ,/ 而/ 在/ 图/ 1/ 面向/ 输出/ 排队/ 的/ 交换/ 结构/ 由于/ 受到/ 输入/ 端口/ 速率/ 的/ 制约/ ,/ 一个/ 时/ 槽内/ ,/ 只会/ 有/ 一个/ 信元/ 到达/ ,/ 因此/ 对于/ 输入/ 端/ 缓存/ 只有/ 一次/ 写入/ ./ 但是/ 在/ 同一个/ 时刻/ ,/ 一个/ 输入/ 单元/ 可能/ 同时/ 被/ 多个/ 输出/ 单元/ “/ 拉/ ”/ ,/ 然而/ ,/ 一个/ 输入/ 单元/ 只能/ 同时/ 响应/ 一个/ 输出/ 单元/ 的/ 拉/ 请求/ ./ 因此/ 需要/ 额外/ 的/ 调度/ 算法/ 来/ 解决/ 这个/ 冲突/ ./ 2.2/ 节将/ 介绍/ 的/ 输入/ 端/ 不/ 冲突/ (/ ICF/ )/ 算法/ 可以/ 保证/ ,/ 在/ 同一/ 时刻/ ,/ 最/ 多/ 只有/ 一个/ 输出/ 单元/ 从/ 一个/ 输入/ 端/ “/ 拉/ ”/ 信元/ ./ 2.2/ ICF/ 算法/ 和/ 传统/ 的/ 使用/ FIFO/ 队列/ (/ FirstInFirstOut/ 输出/ 端口/ 再/ 将/ 属于/ 同一个/ 分组/ 的/ 信元/ 重组/ (/ reas/ -/ semble/ )/ ./ 在/ 传统/ 的/ 交换/ 结构/ 中/ ,/ 存储/ 与/ 排队/ 同时/ 进行/ ./ 例如/ 传统/ 的/ IQ/ 结构/ ,/ 信元/ 存储/ 在/ 输入/ 端/ ,/ 排队/ 也/ 在/ 输入/ 端/ ,/ 而/ OQ/ 结构/ 信元/ 存储/ 于/ 输出/ 端/ ,/ 而/ 排队/ 也/ 在/ 输出/ 端/ ./ 在/ 我们/ 的/ 新/ 交换/ 结构/ 中/ ,/ 如图/ 1/ 所示/ ,/ 实际/ 的/ 信元/ 存储/ 于/ 输入/ 端的/ 缓存/ 中/ ,/ 而/ 排队/ 则/ 在/ 调度/ 模块/ 中/ 进行/ ,/ 且/ 队列/ 被/ 组织/ 成/ 面向/ 输出/ 端的/ 方式/ ,/ 因此/ 我们/ 将/ 其/ 称为/ 面向/ 输出/ 排队/ (/ Output/ -/ OrientedQueued/ ,/ OOQ/ )/ 的/ 交换/ 结构/ ./ 当/ 一个/ 信元/ 从/ 某/ 输入/ 端口/ 到达/ ,/ 该/ 输入/ 单元/ 在/ 将/ 信元/ 存储/ 于/ 输入/ 缓存/ 的/ 同时/ 向/ 调度/ 组件/ 发送/ 一个/ 排队/ 请求/ ./ 调度/ 组件/ 接收/ 到/ 输入/ 单元/ 发送/ 的/ 请求/ 后/ ,/ 使用/ 相应/ 的/ 调度/ 算法/ ,/ 在/ 对应/ 的/ 输出/ 端/ 请求/ 队列/ 中/ 找/ 一个/ 合适/ 的/ 位置/ ,/ 将/ 该/ 请求/ 入队/ ./ 每个/ 传输/ 时槽/ 开始/ 时/ ,/ 输出/ 单元/ 取出/ 队头/ 请求/ ,/ 并/ 配置/ 交换/ 矩阵/ 从/ 输入/ 单元/ 取得/ 对应/ 的/ 信元/ 并/ 发送/ ,/ 此/ 过程/ 称为/ “/ 拉/ ”/ ./ 在/ 传统/ 的/ 匹配/ 算法/ (/ 如/ iSLIP/ )/ 中/ ,/ 一个/ 信元/ 可能/ 要/ 请求/ 多次/ 才能/ 匹配/ 成功/ ,/ 而/ 在/ OOQ/ 结构/ 中/ ,/ 一个/ 信元/ 一旦/ 请求/ 即可/ 成功/ 入队/ ,/ 从而/ 避免/ 了/ 在/ 输入/ 单元/ 和/ 调度/ 组件/ 之间/ 多次/ 交换/ 信息/ ./ 队列/ ,/ 只能/ 从队/ 尾/ 写入/ ,/ 从队/ 头/ 读出/ )/ 的/ 交换/ 结构/ 不同/ ,/ OOQ/ // ICF/ 使用/ RIFO/ 队列/ (/ RandomInFirstOut/ 队列/ ,/ 可以/ 在/ 队列/ 中/ 任意/ 为空/ 的/ 位置/ 写入/ ,/ 但/ 只能/ 从队/ 头/ 读出/ )/ 作为/ OOQ/ 交换/ 结构/ 的/ 输出/ 端/ 请求/ 队列/ ./ 由于/ 存储器/ 可以/ 随机/ 访问/ (/ randomaccess/ )/ ,/ 对于/ 定/ 长信/ 元/ ,/ 只要/ 给定/ 入队/ 位置/ ,/ 则/ RIFO/ 的/ 实现/ 和/ FIFO/ 的/ 实现/ 复杂度/ 相同/ ./ 在/ OOQ/ 交换机/ 中/ ,/ 一个/ 输入/ 单元/ 可能/ 收到/ 多个/ 拉/ 请求/ ,/ 为了/ 解决/ 这一/ 冲突/ ,/ 我们/ 希望/ 算法/ 可以/ 将/ 请求/ 安排/ 到/ 输出/ 端/ 请求/ 队列/ 中/ 一个/ 合适/ 的/ 位置/ ,/ 该/ Page4/ 位置/ 在/ 输出/ 时/ 不会/ 和/ 其它/ 输出/ 单元/ 发生/ “/ 拉/ ”/ 冲突/ ./ 为此/ ,/ 我们/ 定义/ 输入/ 端/ 无/ 冲突/ 位置/ ./ 定义/ 1/ ./ 输入/ 端/ 无/ 冲突/ (/ InputConflict/ -/ Free/ ,/ ICF/ )/ 位置/ :/ 对于/ 某个/ 输入/ 单元/ i/ 发送到/ 输出/ 单元/ j/ 的/ 请求/ 来说/ ,/ 输出/ 端/ j/ 的/ 请求/ 队列/ 中/ 的/ 某/ 一/ 空闲/ 位置/ ,/ 如果/ 在/ 其它/ 输出/ 端/ k/ ≠/ j/ 的/ 请求/ 队列/ 中/ 的/ 同一/ 位置/ 上/ ,/ 没有/ 来自/ 输入/ 单元/ i/ 的/ 请求/ ,/ 则/ 该/ 位置/ 被/ 称为/ 是/ 关于/ 输入/ 端/ i/ 无/ 冲突/ 的/ 位置/ ./ 对于/ 特定/ 的/ 请求/ 来说/ ,/ 输入/ 端/ 无/ 冲突/ 位置/ 也/ 称为/ 可用/ 位置/ (/ availablelocation/ )/ ,/ 如果/ 将/ 每个/ 请求/ 都/ 入队/ 到/ 对应/ 输出/ 端/ 请求/ 队列/ 中/ 的/ 可用/ 位置/ ,/ 则/ 在/ 所有/ 输出/ 端/ 请求/ 队列/ 中/ 的/ 同一/ 列/ 上/ ,/ 不会/ 存在/ 来自/ 同一/ 输入/ 单元/ 的/ 请求/ ./ 从而/ 在/ 任一/ 时刻/ ,/ 不同/ 的/ 输出/ 单元/ 不会/ 同时/ 向/ 同一个/ 输入/ 单元/ “/ 拉/ ”/ 信元/ ./ 因此/ 每次/ 输出/ 时/ ,/ 输入/ 缓存/ 只/ 需/ 读取/ 一次/ ,/ 最终/ 需要/ 的/ 存储器/ 速率/ 仅为/ 2R/ ,/ 和/ IQ/ 交换机/ 一致/ ./ 在/ 信元/ 到达/ 的/ 时刻/ ,/ 对应/ 的/ 请求/ 队列/ 中/ 可能/ 存在/ 多个/ 可用/ 位置/ ,/ 如果/ 在/ 其中/ 随机/ 地/ 选择/ 一个/ 位置/ 放置/ 请求/ ,/ 则/ 信元/ 离开/ 的/ 顺序/ 可能/ 会/ 与/ 信元/ 到达/ 的/ 顺序/ 不同/ ,/ 即/ 可能/ 产生/ 错序/ ./ 为/ 防止/ 错序/ ,/ 我们/ 始终/ 将/ 输入/ 端/ 发送/ 的/ 排队/ 请求/ 安排/ 在/ 首个/ 可用/ 位置/ (/ 最/ 接近/ 队头/ 的/ 位置/ )/ ,/ 对于/ 从/ 同一个/ 输入/ 端口/ 进入/ 而/ 指向/ 同一个/ 输出/ 端口/ 的/ 所有/ 信元/ ,/ 先/ 到达/ 的/ 信元/ 的/ 请求/ 一定/ 排在/ 后/ 到达/ 信元/ 的/ 请求/ 之前/ ,/ 而/ 请求/ 只能/ 从队/ 头/ 取出/ ,/ 因此/ 可以/ 确保/ 信元/ 不会错/ 序/ ./ 对于/ 一个/ 信元/ ,/ 只要/ 它/ 的/ 请求/ 在/ OOQ/ // ICF/ 中/ 被/ 入队/ ,/ 则/ 其/ 离开/ 时间/ (/ 排队/ 时延/ )/ 就/ 已经/ 确定/ ./ ICF/ 的/ 执行/ 过程/ 可以/ 分为/ 输入/ 调度/ 和/ 输出/ 调度/ 两个/ 独立/ 的/ 过程/ ,/ 其/ 具体/ 过程/ 可/ 分别/ 描述/ 如下/ ./ 输入/ 端/ ./ 在/ 每个/ 时槽/ 开始/ 时/ 1/ ./ 对于/ 每/ 一个/ 输入/ 端口/ ,/ 如果/ 该/ 输入/ 端/ 有/ 分组/ 到达/ (/ 各/ 1.1/ ./ 将/ 该/ 分组/ 缓存/ 于/ 对应/ 的/ 输入/ 端/ 缓存/ 中/ ;/ 1.2/ ./ 向/ 调度/ 组件/ 发送/ 一个/ 请求/ ,/ 该/ 请求/ 包含/ 了/ 对应/ 2/ ./ 对于/ 每/ 一个/ 输入/ 端/ 发送/ 的/ 请求/ :/ 2.1/ ./ 调度/ 组件/ 在/ 对应/ 的/ 输出/ 端/ 请求/ 队列/ 中/ 查找/ 首个/ 2.2/ ./ 将/ 请求/ 入队/ 到/ 首个/ 可用/ 位置/ ;/ 步/ 2.1/ 的/ 查找/ 过程/ 是/ 整个/ 算法/ 的/ 核心/ ,/ 我们/ 将/ 在/ 第/ 4/ 节中/ 介绍/ 专门/ 设计/ 的/ 硬件/ (/ ICF/ 调度/ 矩阵/ )/ 来/ 实现/ 快速/ 查找/ ./ 使用/ ICF/ 调度/ 矩阵/ ,/ 每次/ 查找/ 只/ 需要/ 做/ 一次/ 寄存器/ 的/ 按位/ “/ 与/ ”/ 操作/ ./ 输出/ 端/ ./ 在/ 每个/ 时槽/ 开始/ 时/ 1/ ./ 对于/ 每/ 一个/ 输出/ 端/ 请求/ 队列/ (/ 各个/ 输出/ 端口/ 之间/ 并/ 1.1/ ./ 如果/ 队首/ 是/ 空/ 请求/ :/ 1.1/ ./ 1/ ./ 移除/ 队首/ ,/ 队列/ 中/ 所有/ 元素/ 向/ 输出/ 端/ 方向/ 1.2/ ./ 如果/ 队首/ 不是/ 空/ 请求/ :/ 1.2/ ./ 1/ ./ 取出/ 队首/ 请求/ (/ 请求/ 中/ 包含/ 输入/ 端口号/ 和/ 1.2/ ./ 2/ ./ 配置/ 交换/ 矩阵/ ;/ 1.2/ ./ 3/ ./ 向/ 对应/ 输入/ 端/ 发送/ 拉/ 信号/ ,/ 拉/ 信号/ 中/ 包含/ 1.2/ ./ 4/ ./ 对应/ 输入/ 端口/ 接收/ 到/ 拉/ 信号/ 后/ ,/ 将/ 对应/ 分/ 由于/ 输入/ 调度/ 过程/ 已经/ 解决/ 了/ 拉/ 冲突/ ,/ 输出/ 时/ 已经/ 不/ 存在/ 冲突/ ,/ 而/ 仅仅只是/ 取出/ 请求/ ,/ 然后/ 拉/ 对应/ 的/ 分组/ ,/ 随后/ 输出/ ,/ 该/ 过程/ 将/ 非常简单/ ./ 为了/ 更好/ 地/ 理解/ ICF/ 调度/ 算法/ ,/ 在/ 图/ 2/ 中/ ,/ 我们/ 列举/ 了/ ICF/ 的/ 调度/ 过程/ 的/ 实例/ ./ 如图/ 2/ (/ a/ )/ 所示/ ,/ 输入/ 端口/ 1/ 有/ 一个/ 指向/ 输出/ 端口/ A/ 的/ 分组/ 到达/ ,/ 则/ 输入/ 单元/ 1/ 发送/ 一个/ 请求/ 给/ 调度/ 模块/ ,/ 对于/ 该/ 请求/ 来说/ ,/ 位置/ 4/ 、/ 5/ 是/ 输入/ 端/ 无/ 冲突/ 位置/ ./ 虽然/ 位置/ 2/ 未/ 被/ 任何/ 请求/ 占用/ ,/ 但是/ 输出/ 端/ B/ 的/ 请求/ 队列/ 中/ ,/ 位置/ 2/ 有/ 一个/ 来自/ 输入/ 单元/ 1/ 的/ 请求/ ,/ 因此/ 位置/ 2/ 是/ 输入/ 冲突/ 位置/ ,/ 不能/ 使用/ ./ 根据/ 选择/ 首个/ 可用/ 位置/ 的/ 原则/ ,/ 该/ 请求/ 应该/ 被/ 放置/ 在/ 位置/ 4/ ./ 如图/ 2/ (/ b/ )/ 所示/ ,/ 输入/ 端口/ 1/ 到达/ 一个/ 指向/ 输出/ 端口/ C/ 的/ 分组/ ,/ 则/ 输入/ 端口/ 1/ 向/ 调度/ 模块/ 发送/ 请求/ ,/ 对于/ 该/ 请求/ 来说/ ,/ 位置/ 3/ 、/ 5/ 是/ 输入/ 端/ 无/ 冲突/ 位置/ ,/ 因此/ 选择/ 首个/ 可用/ 位置/ 3/ 放置/ 该/ 请求/ ./ 从/ 同一/ 列/ (/ 图中/ 的/ 虚/ 线框/ )/ 上/ 看/ ,/ 所有/ 请求/ 都/ 来自/ 不同/ 的/ 输入/ 单元/ ,/ 所以/ 不会/ 产生/ “/ 拉/ ”/ 冲突/ ./ 每/ 一个/ 传输/ 时槽/ 开始/ 时/ ,/ 所有/ 输出/ 端口/ 都/ 同时/ 取出/ 队头/ 请求/ ,/ 而/ 不管/ 该队/ 头/ 请求/ 是否/ 为空/ ,/ 例如/ 输出/ 端口/ A/ 的/ 请求/ 队列/ 中/ 的/ 位置/ 2/ 为/ 一个/ 空/ 请求/ ,/ 当该/ 位置/ 到达/ 队头/ 时/ 还/ 依然/ 为空/ 请求/ ,/ 则/ 输出/ 端口/ A/ 将/ 该/ 空/ 请求/ 移除/ ,/ 输出/ 端口/ A/ 在/ 该/ 传输/ 时/ 槽内/ 将/ 处于/ 空闲/ 状态/ ./ Page53OOQ/ // ICF/ 结构/ 稳定性/ 分析/ 在/ IQ/ 交换机/ 的/ 设计/ 中/ ,/ 可以/ 通过/ 提高/ 加速/ 比/ 来/ 提高/ 交换/ 吞吐/ 率/ ./ 本节/ 将/ 证明/ 2/ 倍/ 传输/ 加速/ 比/ 足够/ 让/ OOQ/ // ICF/ 结构/ 在/ 任意/ 许可/ 流量/ 下/ 达到/ 100/ %/ 的/ 吞吐/ 率/ ./ 3.1/ 符号/ 和/ 定义/ 对于/ 一个/ N/ ×/ N/ 的/ 基于/ VOQ/ 的/ 交换机/ ,/ 其/ 调度/ 问题/ 可/ 转化/ 为/ 图论/ 中/ 的/ 二分/ 图/ 匹配/ 问题/ ./ 用/ 随机/ 过程/ Ai/ ,/ j/ (/ n/ )/ ∈/ {/ 0/ ,/ 1/ }/ 表示/ 时槽/ n/ 从/ 输入/ 端口/ i/ 到达/ 并/ 指向/ 输出/ 端口/ j/ 的/ 信元数/ ,/ 称/ 方阵/ 犃/ (/ n/ )/ =/ [/ Ai/ ,/ j/ (/ n/ )/ ]/ N/ ×/ N/ 为/ 到达/ 过程/ 矩阵/ ./ 其/ 均值/ E/ [/ Ai/ ,/ j/ ]/ =/ λ/ i/ ,/ j/ / 1/ 称为/ 从/ 输入/ 端口/ i/ 到达/ 并/ 指向/ 输出/ 端口/ j/ 的/ 信元/ 到达/ 速率/ ,/ 而/ 方阵/ Λ/ =/ [/ λ/ i/ ,/ j/ ]/ N/ ×/ N/ 称为/ 到达/ 速率/ 矩阵/ ./ 定义/ 2/ ./ 许可/ 流量/ (/ admissibletraffic/ )/ ./ 如果/ 到达/ 过程/ 犃/ (/ n/ )/ 满足/ 如下/ 条件/ :/ 则/ 称/ 其/ 为/ 许可/ 流量/ ./ 用/ 方阵/ 犕/ =/ [/ mi/ ,/ j/ ]/ N/ ×/ N/ 表示/ 匹配/ 矩阵/ ,/ 其中/ mi/ ,/ j/ =/ 1/ 表示/ 输入/ 端口/ i/ 和/ 输出/ 端口/ j/ 匹配/ ,/ 而/ mi/ ,/ j/ =/ 0/ 表示/ 输入/ 端口/ i/ 和/ 输出/ 端口/ j/ 无/ 匹配/ ./ 该/ 匹配/ 矩阵/ 其实/ 就是/ crossbar/ 的/ 配置/ 矩阵/ ,/ 因此/ 犕/ 是/ 一个/ 置换/ 矩阵/ (/ permutationmatrix/ )/ ./ 用/ ti/ ,/ j/ (/ n/ )/ 表示/ 在/ 时/ 槽/ n/ 时/ ,/ VOQi/ ,/ j/ 的/ 队头/ 信元/ 的/ 等待时间/ ,/ 则/ 方阵/ 犜/ (/ n/ )/ =/ [/ ti/ ,/ j/ (/ n/ )/ ]/ N/ ×/ N/ 称为/ 在/ 时/ 槽/ n/ 的/ (/ 队头/ )/ 等待时间/ 矩阵/ ./ 用/ di/ ,/ j/ (/ n/ )/ 表示/ 在/ 时/ 槽/ n/ 时/ ,/ 队列/ VOQi/ ,/ j/ 中/ 的/ 队头/ 信元/ 和/ 其下/ 一个/ 信元/ 的/ 到达/ 时间/ 之差/ ,/ 则/ 方阵/ 犇/ (/ n/ )/ =/ [/ di/ ,/ j/ (/ n/ )/ ]/ N/ ×/ N/ 称为/ 时槽/ n/ 时/ 的/ 到达/ 时间/ 间隔/ 矩阵/ ./ 对于/ 任意/ N/ 阶/ 方阵/ 犡/ =/ [/ xi/ ,/ j/ ]/ N/ ×/ N/ ,/ 可以/ 定义/ 其/ 对应/ 的/ 向量/ 形式/ 犡/ =/ (/ x1/ ,/ 1/ ,/ …/ ,/ x1/ ,/ N/ ,/ …/ ,/ xN/ ,/ N/ )/ ./ 而/ 对于/ 两个/ 向量/ 犡/ =/ (/ x1/ ,/ x2/ ,/ …/ ,/ xn/ )/ 和/ 犢/ =/ (/ y1/ ,/ y2/ ,/ …/ ,/ yn/ )/ ,/ 有/ 犡/ 犢/ T/ =/ ∑/ n/ 图/ 3OOQ/ // ICF/ 和/ GMWM/ // OCF/ 逻辑关系/ (/ 相同/ )/ 示意/ 3.2/ 稳定性/ 证明/ 文献/ [/ 10/ ]/ 证明/ 了/ 强/ 稳定/ (/ stronglystable/ ,/ 简称/ 稳定/ )/ 的/ 排队/ 系统/ 可以/ 保证/ 100/ %/ 的/ 吞吐/ 率/ ,/ 并/ 介绍/ 了/ 如何/ 用/ Lyapunov/ 方法/ 来/ 证明/ 稳定性/ ./ 文献/ [/ 2/ ]/ 用该/ 方法/ 证明/ 了/ MWM/ // OCF/ (/ MaximumWeightMatching/ // OldestCellFirst/ )/ 算法/ 对/ 任意/ 许可/ 流量/ 保证/ 稳定/ ./ MWM/ 算法/ 属于/ 线性规划/ 算法/ ,/ 它/ 从/ 全局/ 的/ 角度/ 来/ 优化/ 匹配/ ,/ 从而/ 可以/ 保证/ 得到/ 的/ 最终/ 权值/ 最优/ ./ 对于/ 规划/ 问题/ ,/ 另/ 一种/ 复杂度/ 相对/ 较/ 低/ 的/ 算法/ 是/ 贪婪/ 算法/ (/ greedyalgorithm/ )/ ,/ 它/ 只/ 在/ 每/ 一步/ 寻求/ 最优/ 解/ ,/ 但是/ 最终/ 结果/ 不/ 一定/ 全局/ 最优/ ./ 贪婪/ 极大/ 匹配/ 算法/ (/ GreedyMaximalWeightMatching/ // OldestCellFirst/ ,/ GMWM/ // OCF/ )/ 过程/ 如下/ ./ 1/ ./ 将/ 所有/ VOQ/ 队头/ 信元/ 的/ 等待时间/ 写入/ 矩阵/ 犜/ (/ n/ )/ ,/ 如果/ VOQ/ 为空/ ,/ 则/ 相应/ 元素/ 为空/ ,/ 矩阵/ 犕/ (/ n/ )/ 元素/ 全置/ 为/ 0.2/ ./ 如果/ 矩阵/ 犜/ (/ n/ )/ 中/ 所有/ 的/ 元素/ 都/ 为/ 空/ ,/ 则/ 结束/ 并/ 返回/ 矩阵/ 犕/ (/ n/ )/ ,/ 否则/ 继续/ 步/ 3/ ./ 所有/ 元素/ 也/ 置/ 为/ 空/ ./ 然后/ 返回/ 步/ 2.3/ ./ 从/ 矩阵/ 犜/ (/ n/ )/ 的/ 所有/ 元素/ 中/ 选择/ 一个/ 最大/ 的/ ti/ ,/ j/ (/ n/ )/ ./ 4/ ./ 将/ 矩阵/ 犕/ (/ n/ )/ 中/ 对应/ 的/ 元素/ mi/ ,/ j/ (/ n/ )/ 设为/ 1.5/ ./ 将/ 矩阵/ 犜/ (/ n/ )/ 中/ 第/ i/ 行/ 的/ 所有/ 元素/ 置/ 为/ 空/ ,/ 第/ j/ 列/ 的/ 本/ 小节/ 我们/ 先/ 证明/ ICF/ 算法/ 调度/ 的/ 结果/ 和/ GMWM/ // OCF/ 调度/ 的/ 结果/ 一致/ ./ 随后/ 再/ 证明/ GM/ -/ WM/ // OCF/ 算法/ 达到/ 稳定/ 的/ 充分条件/ 是/ 使用/ 2/ 倍/ 加速/ 比/ ./ 定理/ 1/ ./ ICF/ 调度/ 算法/ 的/ 调度/ 结果/ 和/ GMWM/ // OCF/ 算法/ 的/ 调度/ 结果/ 一致/ ./ 证明/ ./ 如果/ 所有/ 请求/ 都/ 按/ 其/ 到达/ 顺序/ 被/ 插入/ 到/ 队列/ 中/ ,/ 那么/ 很/ 容易/ 可以/ 证明/ ICF/ 和/ GMWM/ // OCF/ 算法/ 具有/ 相同/ 的/ 调度/ 结果/ ./ 因此/ 我们/ 主要/ 证明/ 在/ 请求/ 插入/ 队列/ 时/ 错序/ 的/ 情况/ 下/ ,/ 两种/ 算法/ 仍然/ 具有/ 同样/ 的/ 调度/ 结果/ ./ 若有/ 两个/ 请求/ A/ 和/ B/ ,/ 如果/ B/ 比/ A/ 晚/ 到达/ ,/ 但是/ B/ 却/ 插入/ 到/ 了/ A/ 的/ 前面/ ./ 如图/ 3/ 所示/ ,/ 这有/ 两种/ 可能/ 情况/ ./ Page6/ (/ a/ )/ A/ 和/ B/ 在/ 同一个/ 请求/ 队列/ l/ 中/ ,/ 若/ 请求/ A/ 和/ B/ 是从/ 同一个/ 输入/ 端口/ 到达/ 的/ ,/ 则/ 它们/ 一定/ 是/ 按/ 到达/ 顺序/ 插入/ 队列/ 的/ ./ 因此/ 我们/ 只/ 需/ 证明/ A/ 和/ B/ 从/ 不同/ 的/ 输入/ 端口/ 到达/ 的/ 情况/ ,/ 则/ 此时/ 在/ 另外/ 一个/ 队列/ m/ 中/ 一定/ 存在/ 一个/ 与/ A/ 到达/ 端口/ 相同/ 的/ 请求/ C/ ,/ C/ 的/ 到达/ 时间/ 一定/ 早于/ A/ ,/ 否则/ ,/ 当/ A/ 到达/ 时/ B/ 的/ 位置/ 还/ 不/ 存在/ 冲突/ ,/ 因此/ A/ 应该/ 插入/ 到/ B/ 的/ 位置/ 上/ ./ 而/ 对于/ GMWM/ // OCF/ 算法/ ,/ 由于/ A/ 与/ C/ 关于/ 输入/ 端口/ 冲突/ ,/ 它/ 也/ 将/ 选择/ C/ 来/ 匹配/ ,/ 而/ 不是/ A/ ,/ 因为/ C/ 的/ 等待时间/ 大于/ A/ ./ (/ b/ )/ A/ 和/ B/ 在/ 不同/ 队列/ 中/ ,/ 假设/ B/ 在/ 队列/ l/ 中/ ,/ 而/ A/ 在/ 队列/ m/ 中/ ./ 这时/ 存在/ 3/ 种/ 情况/ :/ (/ b1/ )/ A/ 和/ B/ 从/ 同一个/ 输入/ 单元/ 到达/ ,/ 则/ 在/ 队列/ m/ 中/ B/ 的/ 位置/ 上/ 一定/ 存在/ 一个/ 和/ A/ 从/ 不同/ 端口/ 到达/ 的/ 请求/ C/ ,/ 且/ C/ 的/ 到达/ 时间/ 一定/ 早于/ A/ ,/ 否则/ 当/ A/ 到达/ 时/ B/ 的/ 位置/ 还/ 没有/ 被/ 占用/ ,/ 则/ A/ 将/ 被/ 插入/ 到/ 队列/ m/ 中/ B/ 的/ 位置/ ./ 同样/ 对于/ GMWM/ // OCF/ 算法/ ,/ 由于/ A/ 与/ C/ 关于/ 输出/ 端口/ 冲突/ ,/ 它/ 也/ 将/ 选择/ C/ 而/ 不是/ A/ 来/ 匹配/ ,/ 因为/ C/ 具有/ 更长/ 的/ 等待时间/ ./ (/ b2/ )/ 和/ (/ b3/ )/ 都/ 是/ A/ 和/ B/ 从/ 不同/ 输入/ 单元/ 到达/ 的/ 情况/ ,/ 无论/ 在/ 哪/ 一种/ 情况/ 中/ ,/ A/ 一定/ 是/ 被/ 一个/ 更/ 早/ 到达/ 的/ 信元/ C/ 所/ 阻挡/ ,/ 这/ 和/ 在/ GMWM/ // OCF/ 中/ 的/ 情况/ 是/ 一致/ 的/ ./ 在/ 所有/ 情况/ 下/ ,/ ICF/ 和/ GMWM/ // OCF/ 都/ 具有/ 同样/ 的/ 调度/ 结果/ ,/ 因此/ 我们/ 说/ ICF/ 和/ GMWM/ // OCF/ 在/ 逻辑/ 上/ 相同/ ./ 文献/ [/ 11/ ]/ 中/ 的/ 定理/ 4/ 提供/ 了/ 一种/ 比较/ 不同/ 调度/ 算法/ 稳定性/ 的/ 工具/ ./ 我们/ 将/ 利用/ 此/ 工具/ 比较/ GMWM/ // OCF/ 算法/ 和/ MWM/ // OCF/ 算法/ 的/ 稳定性/ ,/ 从而/ 最终/ 证明/ GMWM/ // OCF/ 算法/ 稳定/ 的/ 充分/ (/ 非必要/ )/ 条件/ 是/ 使用/ 两倍/ 加速/ 比/ ./ 为此/ 我们/ 先/ 证明/ 如下/ 引理/ ./ 引理/ 1/ ./ 如果/ 一个/ 调度/ 算法/ / 满足/ 如下/ 条件/ ./ 犕/ / i/ (/ n/ )/ 犠/ Ti/ (/ n/ )/ / 1/ 其中/ 犠/ i/ (/ n/ )/ 是/ 第/ n/ 个/ 时/ 槽/ ,/ 第/ i/ 个/ 内部/ 时槽/ 的/ 权值/ 向量/ ,/ 而/ Ki/ (/ n/ )/ / 0/ 是/ 同时/ 被/ 算法/ / 和/ MWM/ // OCF/ 选中/ 的/ 各/ 队列/ 在/ 队头/ 信元/ 离开/ 之后/ 的/ 权值/ 变化/ 量/ 之/ 和/ ,/ 则/ 一个/ 采用/ 算法/ / 的/ 交换机/ 稳定/ 的/ 充分条件/ 是/ 使用/ 两倍/ 加速/ 比/ ./ 证明/ ./ 为/ 简短/ 起/ 见/ ,/ 我们/ 这里/ 只/ 基于/ GMWM/ // OCF/ 算法/ 证明/ ./ 对于/ GMWM/ // OCF/ 算法/ ,/ 权值/ 变化/ 就是/ 队列/ 中队/ 头信元/ 到达/ 时间/ 和/ 次/ 信元/ 到达/ 时间/ 的/ 差值/ ,/ 但/ 如果/ 队列/ 中/ 没有/ 次/ 信元/ ,/ 则/ 队头/ 信元/ 离开/ 后/ ,/ 队列/ 的/ 权值/ 将/ 变为/ 0/ ,/ 此时/ 权值/ 变化/ 即/ 等于/ 队头/ 信元/ 的/ 等待时间/ ./ 假设/ GMWM/ // OCF/ 算法/ 符合/ 式/ (/ 1/ )/ ,/ 则/ 可分解/ 得到/ 如下/ 两个/ 公式/ :/ 犕/ GMWM1/ (/ n/ )/ 犜/ T1/ (/ n/ )/ / 1/ 犕/ GMWM2/ (/ n/ )/ 犜/ T2/ (/ n/ )/ / 1/ 根据/ MWM/ 的/ 定义/ ,/ 即/ 犕/ MWM2/ (/ n/ )/ 犜/ T2/ (/ n/ )/ =/ max/ 犕/ {/ 犕/ 犜/ T2/ (/ n/ )/ }/ ,/ 其中/ 犕/ 表示/ 所有/ 可能/ 的/ N/ !/ 种/ 匹配/ ;/ 并且/ 第/ 1/ 个/ 内部/ 时槽/ 中/ 可能/ 有/ 信元/ 离开/ 队列/ ,/ 从而/ 到/ 第/ 2/ 个/ 内部/ 时槽/ 时/ 权值/ 可能/ 减小/ ,/ 因此/ 有/ 犕/ MWM2/ (/ n/ )/ 犜/ T2/ (/ n/ )/ / 犕/ MWM1/ (/ n/ )/ 犜/ T2/ (/ n/ )/ 同样/ 对于/ GMWM/ 算法/ ,/ 第一个/ 内部/ 时槽/ 也/ 会/ 有/ 信元/ 离开/ ,/ 因此/ 有/ 则/ 由式/ (/ 3/ )/ ~/ (/ 5/ )/ 可以/ 得到/ 犕/ GMWM2/ (/ n/ )/ 犜/ T1/ (/ n/ )/ / 1/ 最后/ 合并式/ (/ 2/ )/ 和/ (/ 6/ )/ 可以/ 得到/ 应用/ 文献/ [/ 11/ ]/ 中/ 的/ 定理/ 4/ 和/ 式/ (/ 7/ )/ 可以/ 证明/ 在/ 两倍/ 加速/ 比下/ 算法/ / 稳定/ ./ 我们/ 也/ 可以/ 从/ 一般/ 意义/ 上来/ 解释/ 式/ (/ 7/ )/ :/ 以/ 两倍/ 加速/ 比/ 运行/ / 算法/ (/ 即/ 一个/ 时槽/ 运行/ 两次/ )/ 得到/ 的/ 权值/ 大于/ 等于/ MWM/ 算法/ 得到/ 的/ 权值/ ,/ 因为/ MWM/ 算法/ 稳定/ ,/ 则/ / 算法/ 必然/ 也/ 稳定/ ./ 引理/ 2/ ./ 对于/ 任意/ 一个/ 非空/ 的/ VOQi/ ,/ j/ ,/ 用/ wi/ ,/ j/ 表示/ 在/ 队头/ 分组/ 离开/ 后该/ 队列/ 权值/ 的/ 变化/ 量/ ,/ 那么/ 一定/ 有/ 如下/ 关系/ 成立/ :/ 其中/ ti/ ,/ j/ 表示/ 在/ 队头/ 信元/ 离开/ 前/ 的/ 等待时间/ ./ 证明/ ./ 存在/ 两种/ 情况/ ./ (/ a/ )/ 该/ 队列/ 中队/ 头/ 分组/ 之后/ 没有/ 分组/ ./ 在/ 这种/ 情况/ 下/ ,/ 队头/ 分组/ 离开/ 之后/ 队列/ 的/ 权值/ 将/ 变为/ 0/ ,/ 那么/ 队列/ 的/ 权值/ 变化/ 量/ 直接/ 等于/ 队头/ 分组/ 的/ 等待时间/ ti/ ,/ j/ ./ (/ b/ )/ 如果/ 队头/ 分组/ 之后/ 有/ 其它/ 分组/ ,/ 为了/ 不失/ 一般性/ ,/ 我们/ 假设/ 当前/ 时槽/ 为/ n/ ,/ 队头/ 分组/ 的/ 到达/ 时/ Page7/ 证明/ ./ 根据/ 引理/ 1/ 只/ 需要/ 证明/ GMWM/ // OCF/ 间/ 为/ k/ ,/ 而队/ 头/ 分组/ 后/ 的/ 分组/ 的/ 到达/ 时间/ 为/ k/ +/ m/ ,/ 其中/ m/ 是/ 这/ 两个/ 分组/ 的/ 到达/ 时间/ 间隔/ ./ 证明/ 的/ 关键/ 是/ 注意/ 到/ m/ =/ wi/ ,/ j/ 以及/ ti/ ,/ j/ =/ n/ -/ k/ ./ 由于/ 当前/ 队头/ 分组/ 后面/ 的/ 分组/ 已经/ 存在/ ,/ 也就是说/ k/ +/ m/ / n/ ,/ 因此/ 可以/ 得到/ ti/ ,/ j/ =/ n/ -/ k/ / m/ =/ wi/ ,/ j/ ./ 综合/ 两种/ 情况/ ,/ 最终/ 可以/ 证明/ 式/ (/ 8/ )/ ./ 证毕/ ./ 由于/ 在/ 引理/ 1/ 中/ ,/ 我们/ 假设/ GMWM/ // OCF/ 满足/ 式/ (/ 1/ )/ ,/ 下面/ 我们/ 将/ 证明/ 其/ 确实/ 满足/ 式/ (/ 1/ )/ ,/ 从而/ 最终/ 证明/ GMWM/ // OCF/ 算法/ 在/ 两倍/ 加速/ 比/ 条件/ 下/ 稳定/ ./ 定理/ 2/ ./ 一个/ 使用/ GMWM/ // OCF/ 调度/ 算法/ 的/ 交换机/ 稳定/ 的/ 充分/ (/ 非必要/ )/ 条件/ 是/ 使用/ 两倍/ 加速/ 比/ ./ 算法/ 在/ 每个/ 内部/ 时槽/ 满足/ 如下/ 条件/ :/ 犕/ GMWM/ (/ n/ )/ 犜/ T/ (/ n/ )/ >/ 1/ 其中/ K/ (/ n/ )/ 是/ 同时/ 被/ 算法/ / 和/ MWM/ 算法/ 选中/ 的/ 队列/ 在/ 队头/ 信元/ 离开/ 之后/ 的/ 权值/ 变化/ 之/ 和/ ,/ 即可/ 证明/ 其/ 稳定性/ ./ 分别/ 让/ IMWM/ (/ 1/ )/ (/ n/ )/ 和/ IGMWM/ (/ 1/ )/ (/ n/ )/ 表示/ 被/ MWM/ 算法/ 和/ GMWM/ // OCF/ 算法/ 选中/ 的/ 队列/ 的/ 集合/ ./ 那么/ 该/ 集合/ 之间/ 只有/ 如下/ 两种/ 关系/ ./ 情况/ 1/ ./ IMWM/ (/ 1/ )/ (/ n/ )/ =/ IGMWM/ (/ 1/ )/ (/ n/ )/ ,/ 则/ 表明/ MWM/ 算法/ 和/ GMWM/ // OCF/ 算法/ 选择/ 了/ 相同/ 的/ 队列/ ,/ 因此/ 它们/ 选中/ 队列/ 的/ 权值/ 之/ 和/ 也/ 相等/ :/ 犕/ GMWM/ (/ n/ )/ 犜/ T/ (/ n/ )/ =/ 犕/ MWM/ (/ n/ )/ 犜/ T/ (/ n/ )/ ,/ 因此/ GMWM/ // OCF/ 算法/ 稳定/ ./ 示/ 集合/ IGMWM/ (/ 1/ )/ (/ n/ )/ 中/ 具有/ 最大/ 队头/ 等待时间/ 的/ 队列/ ,/ 则/ 又/ 有/ 两种/ 情况/ :/ 情况/ 2.1/ ./ g/ (/ 1/ )/ 2W/ (/ g/ (/ 1/ )/ 与/ 集合/ IMWM/ (/ 1/ )/ (/ n/ )/ 中/ 都/ 包含/ 队列/ g/ (/ 1/ )/ 其中/ W/ (/ c/ )/ 表示/ 队列/ c/ 的/ 队头/ 信元/ 的/ 等待时间/ ,/ 然后/ 令/ 情况/ 2/ ./ IMWM/ (/ 1/ )/ (/ n/ )/ ≠/ IGMWM/ (/ 1/ )/ (/ n/ )/ ,/ 则/ 令/ g/ (/ 1/ )/ 情况/ 2.2/ ./ g/ (/ 1/ )/ 中/ 最/ 多/ 可能/ 包含/ 两个/ 在/ 输入/ 或者/ 输出/ 端口/ 上/ 与/ g/ (/ 1/ )/ 冲突/ 的/ 队列/ ,/ 设/ 它们/ 分别/ 是/ c/ (/ 1/ )/ 于/ g/ (/ 1/ )/ i/ ,/ j/ (/ n/ )/ 具有/ 最大/ 的/ 队头/ 等待时间/ ,/ 所以/ 有/ 2W/ (/ g/ (/ 1/ )/ 然后/ 令/ IGMWM/ (/ 2/ )/ (/ n/ )/ =/ IGMWM/ (/ 1/ )/ (/ n/ )/ -/ {/ g/ (/ 1/ )/ IMWM/ (/ 2/ )/ (/ n/ )/ =/ IMWM/ (/ 1/ )/ (/ n/ )/ -/ {/ c/ (/ 1/ )/ 则/ 此时/ IMWM/ (/ 2/ )/ (/ n/ )/ 中/ 不再/ 含有/ 与/ g/ (/ 1/ )/ 接下来/ 再/ 考虑/ IGWMW/ (/ 2/ )/ (/ n/ )/ 中队/ 头/ 等待时间/ 最长/ 的/ 队列/ g/ (/ 2/ )/ IGMWM/ (/ i/ )/ (/ n/ )/ 和/ IMWM/ (/ i/ )/ (/ n/ )/ ,/ 直到/ 集合/ IGMWM/ (/ i/ )/ (/ n/ )/ 为空/ 为止/ ./ 假设/ 集合/ IGMWM/ (/ k/ )/ (/ n/ )/ 为空/ ,/ 则/ 集合/ IMWM/ (/ k/ )/ (/ n/ )/ 只/ 可能/ 包含/ 空/ 队列/ ./ 如果/ IMWM/ (/ k/ )/ (/ n/ )/ 包含/ 非空/ 队列/ ci/ ,/ j/ (/ n/ )/ ,/ 则/ ci/ ,/ j/ (/ n/ )/ 一定/ 与/ IGMWM/ (/ 1/ )/ (/ n/ )/ 中/ 的/ 任何/ 队列/ 都/ 不/ 冲突/ ./ 而/ GMWM/ // OCF/ 是/ 极大/ 匹配/ 算法/ ,/ 因此/ 这样/ 的/ ci/ ,/ j/ (/ n/ )/ 是/ 不/ 存在/ 的/ ./ 注意/ 式/ (/ 10/ )/ 表示/ 集合/ IMWM/ (/ i/ )/ (/ n/ )/ 和/ IGMWM/ (/ i/ )/ (/ n/ )/ 包含/ 相同/ 队列/ 的/ 情况/ ,/ 而式/ (/ 11/ )/ 表示/ 集合/ IGMWM/ (/ i/ )/ (/ n/ )/ 与/ IMWM/ (/ i/ )/ (/ n/ )/ 包含/ 不同/ 队列/ 的/ 情况/ ./ 这/ 两种/ 情况/ 之间/ 互斥/ ,/ 且/ 在/ 每/ 一步/ 中/ ,/ 两者/ 有/ 一个/ 成立/ ./ 因此/ 将式/ (/ 10/ )/ 与/ (/ 11/ )/ 合并/ 可以/ 得到/ 犕/ GMWM/ (/ n/ )/ 犜/ T/ (/ n/ )/ >/ 1/ 注意/ 此时/ 的/ V/ (/ n/ )/ 是/ 同时/ 被/ GMWM/ // OCF/ 算法/ 和/ MWM/ // OCF/ 算法/ 选中/ 的/ 队列/ 的/ 队头/ 等待时间/ 之/ 和/ ./ 而/ 由/ 引理/ 2/ 可以/ 推导/ 出/ :/ 犕/ GMWM/ (/ n/ )/ 犜/ T/ (/ n/ )/ >/ 1/ 因此/ 最终/ 可以/ 证明/ GMWM/ // OCF/ 算法/ 稳定/ 的/ 充分条件/ 是/ 使用/ 两倍/ 的/ 加速/ 比/ ./ 由于/ ICF/ 调度/ 算法/ 最终/ 从/ 逻辑/ 上/ 等效于/ GMWM/ // OCF/ 算法/ ,/ 所以/ ICF/ 算法/ 稳定/ 的/ 充分条件/ 也/ 是/ 使用/ 两倍/ 加速/ 比/ ./ 但是/ GMWM/ // OCF/ 算法/ 最/ 多/ 需要/ N/ 次/ 迭代/ 才能/ 得出/ 一个/ 极大/ 匹配/ ,/ 且/ 第/ i/ 次/ 迭代/ 最/ 多/ 需要/ 从/ (/ N/ -/ i/ )/ 2/ 个数/ 中/ 查找/ 一个/ 最大值/ ./ 如果/ 还要/ 使用/ 两倍/ 加速/ 比/ ,/ 则/ 每个/ 时槽/ 需要/ 运行/ 算法/ 两次/ ./ 在/ 高速/ 交换机/ 中/ ,/ GMWM/ // OCF/ 算法/ 太/ 过于/ 复杂/ ./ 而/ 对于/ ICF/ 算法/ ,/ 由于/ 每个/ 时槽/ 最/ 多/ 有/ N/ 个/ 信元/ 到达/ ,/ 因此/ 每个/ 时槽/ 只/ 需要/ 运行/ 算法/ 一次/ ,/ 即可/ 将/ 所有/ 请求/ 调度/ 完成/ ,/ 而/ 对于/ 输出/ 过程/ ,/ 只/ 需/ 从/ 队头/ 取出/ 请求/ 即可/ ./ 下/ 一节/ 介绍/ 的/ 调度/ 矩阵/ 可以/ 快速/ 地/ 查找/ 出/ 请求/ 的/ 入队/ 位置/ ./ 4ICF/ 调度/ 矩阵/ 的/ 实现/ ICF/ 调度/ 器/ 的/ 工作/ 方式/ 不同于/ 任何/ 其它/ 基于/ crossbar/ 的/ 调度/ 器/ ,/ 传统/ 的/ crossbar/ 调度/ 器/ 在/ 信元/ 需要/ 输出/ 时/ 执行/ 调度/ ,/ 而/ ICF/ 调度/ 模块/ 在/ 信元/ 到达/ 时/ 执行/ 调度/ ,/ 且/ 调度/ 的/ 结果/ 即为/ crossbar/ 的/ 配置/ 矩/ Page8/ 阵/ ./ 它们/ 的/ 区别/ 在于/ :/ 如果/ 交换/ 结构/ 使用/ s/ 倍/ 加速/ 比/ ,/ 则/ 传统/ 的/ crossbar/ 调度/ 器/ 一个/ 时槽/ 必须/ 执行/ s/ 次/ ,/ 而/ ICF/ 只/ 需/ 在/ 每个/ 时槽/ 开始/ 时/ 执行/ 一次/ ,/ 因为/ 一个/ 时/ 槽内/ 每个/ 输入/ 端口/ 最/ 多/ 到达/ 一个/ 信元/ ,/ 而/ ICF/ 调度/ 矩阵/ 一次/ 可/ 处理/ N/ 个/ 排队/ 请求/ ./ 下面/ 介绍/ ICF/ 调度/ 模块/ 的/ 核心/ 组件/ :/ ICF/ 调度/ 矩阵/ ,/ 该/ 矩阵/ 的/ 主要/ 功能/ 是/ 在/ 接收/ 到/ 输入/ 单元/ 发送/ 的/ 请求/ 后/ ,/ 在/ 相应/ 的/ 输出/ 端/ 请求/ 队列/ 中/ 快速/ 查找/ 到/ 首个/ 可用/ 位置/ ,/ 然后/ 将/ 该/ 请求/ 入队/ ./ 如图/ 4/ (/ a/ )/ 所示/ ,/ 位置/ 查询/ 单元/ (/ LocationSearcher/ ,/ LS/ )/ 维护/ 相应/ 的/ 输出/ 请求/ 队列/ 的/ 占用/ 和/ 冲突/ 状态/ ./ 其中/ LSi/ ,/ j/ 用于/ 为/ 从/ 输入/ 单元/ i/ 到达/ 的/ 请求/ 在/ 输出/ 端/ j/ 的/ 请求/ 队列/ 中图/ 4/ 调度/ 矩阵/ 示意图/ LS/ 的/ 核心/ 功能/ 就是/ 在/ 对应/ 输出/ 端/ 请求/ 队列/ 中/ 找/ 首个/ 可用/ 位置/ ,/ 在/ 查找/ 时/ ,/ 关键/ 要/ 排除/ 两种/ 位置/ :/ (/ 1/ )/ 队列/ 中/ 已经/ 被/ 占用/ 的/ 位置/ ;/ (/ 2/ )/ 队列/ 中/ 没有/ 被/ 占用/ ,/ 但是/ 和/ 其它/ 队列/ 存在/ 输入/ 端/ 冲突/ 的/ 位置/ ./ 假设/ 输出/ 端/ 请求/ 队列/ 最大/ 队长/ 为/ L/ ,/ 则/ 我们/ 在/ 每个/ LS/ 中/ 使用/ 两个/ 容量/ 为/ L/ 位/ 的/ 寄存器/ 分别/ 表示/ 队列/ 中/ 各个/ 位置/ 的/ 占用/ 情况/ 和/ 冲突/ 情况/ ,/ 如图/ 5/ (/ a/ )/ 所示/ ,/ 这/ 两个/ 寄存器/ 分别/ 称为/ 占用/ 指示/ 寄存器/ (/ OccupationIn/ -/ dicationRegister/ ,/ OIR/ )/ 和/ 冲突/ 指示/ 寄存器/ (/ ConflictIndicationRegister/ ,/ CIR/ )/ ,/ 而/ 占用/ 寄存器/ 中/ 的/ 各个/ 位/ 称为/ 占用/ 指示/ 位/ (/ OccupationIndicator/ ,/ OI/ )/ ,/ 1/ 表示/ 该/ 位置/ 未/ 被/ 占用/ ,/ 而/ 0/ 则/ 表示/ 该/ 位置/ 被/ 占用/ ;/ 类似/ 地/ ,/ 冲突/ 寄存器/ 中/ 的/ 各个/ 位/ 称为/ 冲突/ 指示/ 位/ (/ Con/ -/ flictIndicator/ ,/ CI/ )/ ,/ 为/ 1/ 表示/ 该/ 位置/ 没有/ 和/ 其它/ 队图/ 5/ 位置/ 查询/ 单元/ 工作/ 原理/ 逻辑图/ 查找/ 首个/ 可用/ 位置/ ,/ 一个/ LS/ 查找/ 到/ 相应/ 位置/ 后/ ,/ 会/ 将/ 该/ 位置/ 广播/ 给/ 同行/ 同列/ 的/ LS/ ,/ 以便/ 它们/ 及时/ 更新/ 占用/ 和/ 冲突/ 的/ 状态/ ./ 图/ 4/ (/ b/ )/ 展示/ 了/ 一种/ 理想/ 情况/ ,/ 各个/ 输入/ 端口/ 发送/ 的/ 信元/ 是/ 指向/ 不同/ 的/ 输出/ 端口/ ,/ 则/ 各个/ LS/ 可以/ 同时/ 调度/ ./ 图/ 4/ (/ c/ )/ 显示/ 了/ 一种/ 极端/ 情况/ ,/ 各个/ 输入/ 端/ 到达/ 的/ 信元/ 都/ 指向/ 同一/ 输出/ 端口/ ,/ 由于/ 各个/ LS/ 独立/ 工作/ ,/ 因此/ 它们/ 选择/ 的/ 位置/ 可能/ 存在/ 冲突/ ,/ 因此/ 每/ 一步/ 只能/ 有/ 一个/ LS/ 进行/ 查找/ 位置/ ,/ 等/ 完成/ 后/ ,/ 将/ 其/ 结果/ 广播/ 给/ 同行/ 同列/ 的/ LS/ 更新/ 它们/ 的/ 状态/ ,/ 然后/ 下/ 一个/ LS/ 再/ 执行/ 查找/ ,/ 直到/ 所有/ 请求/ 处理/ 完成/ ./ 列/ 相同/ 位置/ 发生冲突/ ,/ 为/ 0/ 则/ 表示/ 发生冲突/ ./ 图/ 5/ (/ a/ )/ 中/ 位置/ 0/ 虽然/ 未/ 被/ 占用/ ,/ 但是/ 该位/ 与/ 其它/ 队列/ 冲突/ ;/ 位置/ 1/ 虽然/ 未/ 与/ 其它/ 队列/ 冲突/ ,/ 但/ 已经/ 被/ 占用/ ;/ 位置/ 3/ 既/ 被/ 占用/ 也/ 和/ 其它/ 队列/ 中/ 的/ 相同/ 位置/ 冲突/ ;/ 位置/ 2/ 和/ 位置/ 4/ 都/ 未/ 被/ 占用/ 和/ 冲突/ ,/ 都/ 属于/ 可用/ 位置/ ./ 因此/ OIR/ 和/ CIR/ 按位/ 与/ 的/ 结果/ 中/ 所有/ 为/ 1/ 的/ 位置/ 都/ 是/ 可用/ 位置/ ./ 由于/ 需要/ 找到/ 首个/ 可用/ 位置/ ,/ 如图/ 5/ (/ b/ )/ 所示/ ,/ 我们/ 引入/ 了/ 优先级/ 编码器/ ,/ 优先/ 编码器/ 可以/ 处理/ 优先级/ 最高/ 的/ 输入/ ,/ 并/ 编码/ 输出/ ./ 编码/ 的/ 另/ 一个/ 目的/ 是/ 减少/ 结果/ 的/ 位/ 宽/ ,/ 便于/ 在/ 各个/ LS/ 之间/ 广播/ 数据/ ./ 同行/ 的/ LS/ 接收/ 到/ 广播/ 的/ 结果/ 之后/ 将/ 更新/ 其/ CIR/ ,/ 而/ 同列/ 的/ LS/ 接收/ 到/ 广播/ 结果/ 之后/ 将/ 更新/ 其/ OIR/ ./ CIR/ 和/ OIR/ 更新过程/ 相同/ ,/ 如图/ 5/ (/ c/ )/ 所示/ ,/ 一个/ LS/ 接收/ 到/ 广播/ 数据/ 之后/ ,/ 先/ 通过/ 二进制/ Page9/ 译码器/ 将/ 位置/ 信息/ 恢复/ ,/ 其中/ 为/ 1/ 的/ 位置/ 是/ 需要/ 更新/ 的/ 位置/ ,/ 将/ 其/ 取反/ 之后/ 再/ 与/ 寄存器/ 中/ 原来/ 的/ 数据/ 按位/ 与/ ,/ 最后/ 得到/ 更新/ 结果/ ./ 对于/ 调度/ 矩阵/ ,/ 每个/ 时槽/ 最多/ 只要/ 做/ N/ 次/ 查找/ 即可/ 将/ 所有/ 请求/ 都/ 入队/ ,/ 属于/ 线性/ 时间/ 复杂度/ ,/ 而/ 每次/ 查询/ 只/ 需/ 一次/ 寄存器/ 的/ 并行/ “/ 与/ ”/ 操作/ ,/ 由于/ “/ 与/ ”/ 和/ 优先/ 编码/ 都/ 属于/ 组合/ 逻辑/ ,/ 因此/ 该/ 过程/ 只/ 存在/ 门/ 时延/ ./ 我们/ 使用/ Verilog/ 语言/ 对/ 一个/ 4/ ×/ 4/ 的/ OOQ/ 交换机/ 的/ 调度/ 矩阵/ 的/ 调度/ 情况/ 进行/ 了/ 验证/ ,/ 图/ 6/ 为/ 运图/ 64/ ×/ 4/ 交换机/ 调度/ 矩阵/ 硬件/ 仿真/ 波形图/ 5/ 仿真/ 实验/ 我们/ 在/ 为/ NS/ -/ 3/ (/ NetworkSimulator3/ )/ 建立/ 的/ 交换机/ 仿真/ 平台/ [/ 12/ ]/ 上/ 对/ OOQ/ // ICF/ 和/ 主流/ 交换/ 结构/ 进行/ 了/ 仿真/ 实验/ ./ 所有/ 仿真/ 中/ 我们/ 都/ 设置/ 端口数/ 为/ 32/ (/ 其它/ 端口数/ 情况/ 有/ 类似/ 结果/ )/ ./ 每/ 一个/ 仿真/ 都/ 运行/ 106/ 个/ 时/ 槽/ ,/ 并/ 从/ 第/ 103/ 个/ 时/ 槽/ 开始/ 收集/ 数据/ ./ 平均/ 时延/ 为/ 所有/ 收集/ 到/ 的/ 时延/ 的/ 平均值/ ,/ 而/ 时延/ 的/ 变化/ 为/ 收集/ 到/ 的/ 时延/ 偏离/ 均值/ 的/ 情况/ ./ 吞吐/ 率/ 的/ 统计/ 方法/ 为/ 在/ 数据/ 采集/ 时段/ 内/ ,/ 所有/ 离开/ 交换机/ 的/ 分组/ 数/ 和/ 所有/ 到达/ 交换机/ 分组/ 数/ 的/ 比值/ ./ 限于/ 篇幅/ ,/ 本文/ 只/ 列举/ 两组/ 主要/ 的/ 仿真/ 结果/ ./ 第/ 1/ 组/ 仿真/ 是/ 对/ 均匀分布/ 流量/ 下/ 时延/ 和/ 抖动/ 的/ 仿真/ ,/ 由于/ 在/ 低/ 负载/ 下/ 各/ 算法/ 性能/ 比较/ 接近/ ,/ 从而/ 曲线/ 不易/ 区分/ ,/ 因此/ 在/ 图/ 中/ ,/ 所有/ 负载/ 均/ 从/ 70/ %/ 开始/ ,/ 以便/ 可以/ 区别/ 各条/ 曲线/ ./ s/ 为/ 传输/ 加速/ 比/ ,/ Burst/ 为/ 突发/ 流量/ 长度/ ./ 图/ 7/ (/ a/ )/ 为/ Bernoulli/ 流量/ 下/ 的/ 仿真/ 结果/ ,/ 从中/ 可见/ ,/ ICF/ 算法/ 和/ GMWM/ // OCF/ 算法/ 性能/ 完全一致/ ,/ 行/ 过程/ 中/ 3/ 个/ 时/ 槽/ 的/ 波形图/ ,/ 该/ 调度/ 矩阵/ 共有/ 16/ 个/ 位置/ 查询/ 单元/ ,/ 图中/ 只/ 显示/ 了/ 位置/ 查询/ 单元/ 1/ ,/ 1/ 的/ 状态/ ./ 时槽/ 1/ 为/ 4/ 个/ 输入/ 端口/ 到达/ 的/ 信元/ 分别/ 指向/ 不同/ 输出/ 端口/ 的/ 调度/ 结果/ ;/ 时槽/ 2/ 为/ 所有/ 输入/ 的/ 信元/ 都/ 指向/ 同一个/ 输出/ 端口/ 的/ 调度/ 结果/ ;/ 时槽/ 3/ 是/ 部分/ 输入/ 端口/ 到达/ 的/ 信元/ 指向/ 同一个/ 输出/ 端口/ 的/ 调度/ 结果/ ./ 从图/ 中/ 可以/ 看出/ ,/ 调度/ 结果/ 与/ 预期/ 的/ 一致/ ./ 该/ 调度/ 矩阵/ 已经/ 在/ Altera/ 的/ FPGA/ 上/ 验证/ 通过/ ./ 这/ 和/ 分析/ 是/ 一致/ 的/ ./ ICF/ 算法/ 和/ 5/ -/ SLIP/ 算法/ 时延/ 性能/ 相似/ 但略/ 差于/ 后者/ (/ 但/ 在/ 实际/ 中/ ,/ iSLIP/ 算法/ 一般/ 都/ 只会/ 实现/ 3/ 次/ 迭代/ 而/ 不是/ 5/ 次/ )/ ./ 而/ 使用/ 1.2/ 倍/ 传输/ 加速/ 比/ 的/ ICF/ 算法/ 性能/ 相对/ 5/ -/ SLIP/ 有/ 大幅度提高/ ,/ 值得注意/ 的/ 是/ ,/ ICF/ 算法/ 提高/ 传输/ 加速/ 比时/ ,/ 并不需要/ 提高/ 调度/ 加速/ 比/ ,/ 而/ 这个/ 特性/ 对于/ 其它/ 算法/ 并/ 不/ 成立/ ./ 使用/ 1.6/ 倍/ 传输/ 加速/ 比时/ ,/ OOQ/ // ICF/ 结构/ 的/ 时延/ 性能/ 将/ 优于/ CICB/ -/ 1/ // RR/ 结构/ 而/ 和/ OQ/ 非常/ 接近/ ,/ 其中/ CICB/ -/ 1/ // RR/ 表示/ 交叉点/ 带/ 一个/ 缓存/ 的/ BufferedCrossbar/ 交换机/ ,/ 且/ 输入/ 端/ 和/ 输出/ 端均/ 使用/ 轮询/ (/ Round/ -/ Robin/ )/ 调度/ 机制/ ./ 使用/ 2/ 倍/ 传输/ 加速/ 比时/ ,/ OOQ/ // ICF/ 时延/ 性能/ 和/ OQ/ 完全一致/ ./ 图/ 7/ (/ b/ )/ 所示/ 为/ ON/ // OFF/ 突发/ 流量/ 下/ 的/ 时延/ 性能/ 仿真/ ,/ 其中/ 处于/ ON/ 和/ OFF/ 状态/ 的/ 时间/ 均/ 服从/ 几何/ 分布/ ,/ 处于/ ON/ 状态/ 时/ ,/ 每/ 一个/ 时槽/ 都/ 发送/ 一个/ 信元/ ./ 处于/ ON/ 状态/ 的/ 时间/ 的/ 均值/ 称为/ 突发/ 长度/ ,/ 仿真/ 中/ 我们/ 取/ 10/ 、/ 32/ 和/ 100/ 分别/ 表示/ 小/ 突发/ 、/ 中等/ 突发/ 和/ 大/ 突发/ ./ 同一/ 突发/ 内/ 到达/ 的/ 信元/ 都/ 指向/ 同一/ 输出/ 端口/ ,/ 而/ 突发/ 之间/ 的/ 指向/ 在/ 各个/ 输出/ 端口/ 间/ 均匀分布/ ./ 从图/ 中/ 可见/ ,/ 在/ 这/ 3/ 种/ 突发/ 长度/ 下/ ,/ 各/ 结构/ 时延/ Page10/ 性能/ 之间/ 的/ 关系/ 与/ Bernoulli/ 流量/ 下/ 类似/ ./ 但/ 随着/ 突发/ 长度/ 的/ 增大/ ,/ ICF/ 、/ iSLIP/ 和/ CICB/ -/ 1/ // RR/ 结构/ 的/ 时延/ 性能/ 越来越/ 接近/ ./ 当/ 使用/ 2/ 倍/ 传输/ 加速/ 比时/ ,/ ICF/ 算法/ 将/ 获得/ 和/ OQ/ 相同/ 的/ 时延/ 性能/ ./ 图/ 7/ (/ c/ )/ 所示/ 为/ 各种/ 结构/ 时延/ 抖动/ 的/ 仿真/ ./ 从图/ 中/ 可以/ 看出/ 在/ Bernoulli/ 流量/ 或者/ 突发/ 流量/ 下/ ,/ 5/ -/ SLIP/ (/ SLIP/ 最好/ 迭代/ 结果/ )/ 都/ 有/ 较大/ 的/ 时延/ 抖动/ ./ 而/ 随着/ 突发/ 长度/ 的/ 增大/ ,/ CICB/ -/ 1/ // RR/ 结构/ 的/ 抖动/ 逐渐/ 图/ 7/ 均匀分布/ 流量/ 下/ 时延/ 和/ 抖动/ 的/ 仿真/ 结果/ 第/ 2/ 组/ 仿真/ 主要/ 考查/ 在/ 非/ 均匀/ 流量/ 下/ 各/ 交换机/ 的/ 吞吐/ 率/ ./ 交换机/ 仿真/ 中/ 常用/ 的/ 非/ 均匀/ 流量/ 主要/ 有/ 非/ 平衡/ 流量/ (/ unbalancedtraffic/ )/ 、/ 非对称/ 流量/ (/ asymmetrictraffic/ )/ 和/ 对角/ 流量/ (/ diagonaltraffic/ )/ (/ 包括/ 强/ 对角/ 和/ 弱/ 对角/ )/ ./ 若设/ 端口/ 负载/ 率为/ λ/ ,/ 而/ 分别/ 用/ λ/ Ui/ ,/ j/ ,/ λ/ Ai/ ,/ j/ 和/ λ/ Di/ ,/ j/ 表示/ 从/ 输入/ 端口/ i/ 到/ 输出/ 端口/ j/ 的/ 数据流/ 在/ 非/ 平衡/ 流量/ 、/ 非对称/ 流量/ 和/ 强/ 对角/ 流量/ (/ 弱/ 对角/ 流量/ 和/ 非/ 平衡/ 流量/ 类似/ )/ 情况/ 下/ 的/ 负载/ ,/ 则/ 有/ 如下/ 表达式/ :/ λ/ Ui/ ,/ j/ =/ λ/ Ai/ ,/ j/ =/ ak/ λ/ ,/ j/ =/ (/ i/ +/ k/ )/ modN/ ,/ ak/ =/ λ/ Di/ ,/ j/ =/ 其中/ 参数/ w/ ∈/ [/ 0/ ,/ 1/ ]/ 称为/ 非/ 平衡/ 系数/ ;/ 参数/ f/ ∈/ (/ 1/ ,/ +/ ]/ 称为/ 非对称/ 系数/ ;/ 参数/ d/ ∈/ [/ 0/ ,/ 0.5/ ]/ 称为/ 对角/ 系数/ (/ 与/ 取值/ [/ 0.5/ ,/ 1/ ]/ 时/ 对称/ )/ ./ 增大/ ,/ 最终/ 和/ 5/ -/ SLIP/ 的/ 抖动/ 重合/ ./ 而/ 对于/ OOQ/ // ICF/ 结构/ ,/ 其/ 抖动/ 始终/ 和/ OQ/ 结构/ 相当/ ,/ 且/ 当/ 突发/ 长度/ 增大/ 时/ ,/ 其时/ 延/ 抖动/ 逐渐/ 和/ OQ/ 重合/ ./ 这个/ 特性/ 主要/ 是/ 得益于/ ICF/ 算法/ 最大/ 程度/ 地/ 保持/ 了/ 信元/ 先进先出/ 的/ 顺序/ ./ 对于/ 目前/ 多媒体/ 和/ 实时/ 交互/ 数据/ 比重/ 越来越/ 大/ 的/ 网络/ 环境/ ,/ 保持/ 时延/ 抖动/ 稳定/ 无疑/ 有/ 重要/ 的/ 实际意义/ ./ 图/ 8/ (/ a/ )/ 显示/ 了/ 在/ 非/ 平衡/ 流量/ 下/ 的/ 吞吐/ 率/ 仿真/ 结果/ ,/ 从中/ 可以/ 看出/ ,/ 在/ 最坏/ 情况/ 下/ ,/ iSLIP/ 只能/ 达到/ 80/ %/ 左右/ 的/ 吞吐/ 率/ ,/ 而/ CICB/ -/ 1/ // RR/ 结构/ 可以/ 达到/ 85/ %/ 左右/ 的/ 吞吐/ 率/ ,/ 而/ ICF/ 算法/ 在/ 无/ 加速/ 比/ 的/ 情况/ 下/ 就/ 可以/ 达到/ 98/ %/ 以上/ 的/ 吞吐/ 率/ ,/ 而仅/ 需要/ 1.02/ 倍/ 传输/ 加速/ 比/ ,/ 其/ 吞吐/ 率/ 即可/ 达到/ 100/ %/ ./ 图/ 8/ (/ b/ )/ 显示/ 了/ 在/ 非对称/ 流量/ 下/ 的/ 吞吐/ 率/ 仿真/ 结果/ ,/ 该/ 结果表明/ 在/ 最坏/ 情况/ 下/ ,/ ICF/ 在/ 无/ 传输/ 加速/ 比时/ 的/ 吞吐/ 率/ 可以/ 达到/ 95/ %/ 以上/ ,/ 远远/ 高于/ iSLIP/ 和/ CICB/ -/ 1/ // RR/ ./ 当/ 使用/ 1.08/ 倍/ 传输/ 加速/ 比时/ ,/ ICF/ 算法/ 可/ 达到/ 100/ %/ 吞吐/ 率/ ./ 图/ 8/ (/ c/ )/ 为/ 在/ 强/ 对角/ 流量/ 下/ 的/ 吞吐/ 率/ 仿真/ 结果/ ,/ 强/ 对角/ 流量/ 是/ 一种/ 非常/ 扭曲/ 的/ 许可/ 输入/ 流量/ ./ 当/ 对角/ 系数/ d/ 取值/ 为/ 0.5/ 时/ ,/ 表示/ 一个/ 输入/ 端口/ 只会/ 有/ 指向/ 两个/ 相邻/ 的/ 输出/ 端口/ 的/ 信元/ 等/ 概率/ 地/ 到达/ ,/ 这种/ 情况/ 对/ ICF/ 算法/ 是/ 最/ 不利/ 的/ ./ 此时/ ,/ ICF/ 算法/ 的/ 吞吐/ 率/ 只能/ 达到/ 88/ %/ 左右/ ,/ 略高于/ CICB/ -/ 1/ // RR/ 在/ 最坏/ 情况/ 下/ 的/ 吞吐/ 率/ (/ 87/ %/ )/ ./ 只有/ 当/ 加速/ 比/ 增加/ 到/ 1.14/ 时/ ,/ 才能/ 达到/ 100/ %/ 吞吐/ 率/ ./ 从/ 仿真/ 结果/ 来看/ ,/ ICF/ 算法/ 只要/ 使用/ 1.2/ 倍/ 传输/ 加速/ 比/ 就/ 可以/ 在/ 时延/ 和/ 吞吐/ 率上/ 均/ 达到/ 比较/ 理想/ 的/ 效果/ ,/ 而/ 不/ 需要/ 使用/ 前/ 文/ 证明/ 的/ 2/ 倍/ 传输/ 加速/ 比/ ,/ 1.2/ 倍/ 传输/ 加速/ 比/ 从/ 实现/ 的/ 观点/ 看/ 也/ 比较/ 合理/ ./ Page11/ 图/ 8/ 非/ 均匀/ 流量/ 下/ 吞吐/ 率/ 的/ 仿真/ 结果/ 6OOQ/ // ICF/ 交换机/ 对/ EPFTS/ 环境/ 的/ 支持/ “/ 单层/ 用户/ 数据交换/ 平台/ 体系结构/ ”/ (/ Single/ -/ layerUser/ -/ dataswitchingPlatformArchitecture/ ,/ SUPA/ )/ 是/ 四川省/ 西南/ 交通/ 大学/ 网络通信/ 技术/ 重点/ 实验室/ 针对/ 目前/ Internet/ 面临/ 的/ 高速/ 交换/ 、/ 服务质量/ 保障/ 、/ 安全/ 等/ 方面/ 的/ 挑战/ 而/ 提出/ 的/ 下一代/ 高速/ 网络/ 的/ 体系结构/ 框架/ [/ 13/ ]/ ./ 考虑/ 到/ “/ 未来/ 骨干/ 通信子网/ 必然/ 以/ 光通信/ 技术/ (/ 别是/ DWDM/ )/ 支撑/ ,/ 光通信/ 技术/ 的/ 误码率/ 已经/ 降低/ 到/ 10/ -/ 12/ ”/ ,/ OSI/ // RM/ 设置/ 独立/ 的/ 数据/ 链路层/ 完成/ 检错/ 后/ 重传/ 的/ 必要性/ 已经/ 大大降低/ ./ 加上/ 许多/ 物理层/ 传输技术/ 都/ 引入/ 了/ 物理层/ 帧/ 的/ 概念/ ,/ 而层/ 帧/ 间/ 的/ 不/ 兼容/ 又/ 需要/ 额外/ 的/ “/ 帧/ 间/ 适配/ 开销/ ”/ ,/ 因此/ 将/ 部分/ 功能/ 融合/ ,/ 并/ 对/ 网络/ 层次/ 进行/ 简化/ ,/ 就是/ 我们/ 为/ 骨干/ 通信子网/ 提出/ 的/ 单层/ 用户/ 数据交换/ 平台/ 体系结构/ ./ 通过/ 对/ 现有/ 的/ 基于/ 光纤/ 的/ 通信/ 技术/ 的/ 分析/ ,/ 我们/ 认为/ 这些/ 技术/ 都/ 不/ 适应/ 单/ 物理层/ 用户/ 数据传输/ 平台/ 的/ 需要/ ./ ITU/ 的/ 工作/ 以/ 光纤/ 交换/ (/ fiberswitching/ )/ 和/ 波长/ 交换/ (/ lambdaswitching/ )/ 为主/ ,/ 缺少/ 多/ 粒度/ 能够/ 适应/ 不同/ 速率/ 的/ 应用/ 数据流/ 向下/ 复用/ 和/ 交换/ 的/ 需要/ ;/ 在/ 多/ 波长/ 环境/ 中/ 直接/ 利用/ SDH/ 技术/ 实现/ 单/ 波长/ 内/ 的/ 向下/ 复用/ 又/ 存在/ 成本/ 较/ 高/ 和/ 对/ 计算机网络/ 典型/ 分组/ 提供/ 服务/ 时/ 需要/ 切分/ 与/ 重组/ 等/ 不利因素/ ;/ 而/ 学界/ 对/ DWDM/ 交换/ 技术/ 的/ 研究/ ,/ 如/ :/ 光/ 突发/ 数据交换/ (/ OpticalBurstSwitching/ ,/ OBS/ )/ ,/ 为了/ 避免/ 在/ 电域/ 内/ 进行/ 交换/ ,/ 采用/ 全光域/ 内/ 数据/ 传输方式/ ,/ 由于/ 光域/ 内/ 缺少/ 缓存/ 和/ 处理/ 能力/ ,/ 难以解决/ 好/ 服务质量/ 保障/ 与/ 信道/ 利用率/ 之间/ 的/ 严重/ 矛盾/ [/ 13/ ]/ ./ 由此可见/ ,/ 需要/ 提出/ 新/ 的/ 交换/ 技术/ 来/ 构建/ 单/ (/ 1/ )/ 长帧/ ./ EPFTS/ 帧/ 长/ 2024/ 字节/ ,/ 以/ 实现/ 对/ 最大/ “/ 以太网/ MAC/ 帧/ ”/ 的/ 封装/ 而/ 不/ 需要/ 进行/ 分割/ 与/ 重组/ ;/ 对于/ 传统/ 的/ 64/ 字节/ 的/ 信元/ 交换/ 时槽/ ,/ EPF/ 时槽/ 可为/ 交换/ 节点/ 提供/ 更/ 充足/ 调度/ 时间/ ./ (/ 2/ )/ 定长/ 帧/ 交换/ ./ 变长/ 分组/ 在/ 交换/ 前/ 需切/ 分为/ 定/ 长信/ 元/ 进行/ 交换/ ,/ 交换/ 后/ 再/ 重组/ ;/ 而/ SUPANET/ 的/ 以/ EPF/ 定长/ 帧/ 为/ 基础/ 交换/ ,/ 交换/ 前后/ 不需/ 拆分/ 和/ 重组/ ,/ 不/ 存在/ 帧/ 内/ 信元/ 错序/ 问题/ ;/ 定长/ 帧/ 的/ 存储管理/ 简单/ ,/ 队列/ 的/ 实现/ 也/ 更加/ 简单/ ./ 物理层/ 用户/ 数据传输/ 平台/ ,/ 这/ 正是/ 面向/ 以太网/ 的/ 物理/ 帧/ 时/ 槽/ 交换/ 技术/ (/ Ethernet/ -/ orientedPhysicalTimeslotSwitching/ ,/ EPFTS/ )/ [/ 14/ ]/ 提出/ 的/ 背景/ ./ 我们/ 的/ 经验/ 表明/ ,/ SUPA/ 及其/ EPFTS/ 技术/ 为/ OOQ/ // ICF/ 的/ 实现/ 提供/ 了/ 有利/ 的/ 条件/ ,/ 而/ OOQ/ // ICF/ 技术/ 又/ 反过来/ 进一步/ 支持/ 了/ SUPA/ 目标/ 的/ 实现/ ./ 与/ 现有/ 的/ 网络体系结构/ 相比/ ,/ SUPA/ 对/ 路由/ 和/ 交换/ 平台/ 的/ 支持/ 具有/ 如下/ 优势/ :/ (/ 3/ )/ 面向/ 连接/ 的/ 用户/ 传输/ 与/ 交换/ 服务/ ./ SUPA/ 通过/ 运行/ 服务质量/ 协商/ 协议/ (/ QoSNP/ )/ 为/ 一对/ 用户/ 间/ 的/ 数据流/ 的/ 传输/ 建立/ 基于/ 服务质量/ 的/ 端/ 到/ 端的/ 虚通路/ (/ virtualpath/ )/ ,/ 因此/ ,/ 同一/ 对/ 用户/ 间/ 的/ 数据流/ 可/ 保证/ 无错/ 序帧/ ;/ Internet/ 在/ 网络层/ 提供/ 无/ 连接/ 的/ 转发/ 服务/ ,/ 每个/ IP/ 报文/ 都/ 必须/ 查找/ 路径/ 表后/ 再/ 进行/ 转发/ ,/ 而/ 基于/ IP/ 的/ 查找/ 复杂度/ 较/ 高/ ./ 此外/ ,/ 路径/ 更新/ 可能/ 造成/ 同一/ 对/ 用户/ 间/ 的/ 报文/ 流内/ 报文/ 错序/ 或/ 因/ 形成/ 环路/ 而/ 造成/ TTL/ 超限/ 被/ 丢失/ ;/ SUPANET/ 与/ 其它/ 面向/ 连接/ 的/ 交换/ 技术/ ,/ 如/ ATM/ (/ AsynchronousTransferMode/ )/ 和/ MPLS/ (/ Multi/ -/ ProtocolLabelSwitching/ )/ 一样/ ,/ 仅/ 需/ 在/ 建立/ 连接/ 阶段/ 查找/ 路径/ 表/ ,/ 而/ 连接/ 一旦/ 建立/ ,/ 就/ 只/ 需要/ 通过/ 每个/ 帧/ 所/ 携带/ 的/ 路径/ 信息/ ,/ 使用/ 固定/ 长度/ 的/ 路径/ 标示/ 查找/ 出口/ 信息/ ,/ 从/ Page12/ 而/ 简化/ 查表/ 操作/ ,/ 降低/ 线卡/ 功耗/ 和/ 发热量/ ./ (/ 4/ )/ 超前/ 交换/ (/ stepforwardswitching/ )/ 技术/ ./ 充分利用/ 建立/ 连接/ 过程/ 中/ 获得/ 的/ 下游/ 节点/ 的/ 输出/ 端口/ 信息/ 作为/ 连接/ 标识符/ ,/ 因而/ 当帧/ 到达/ 输出/ 端口/ 时/ ,/ 不/ 经/ 查表/ 即/ 可以/ 直接/ 发送/ 排队/ 请求/ ./ 而/ 下/ 一个/ 节点/ 的/ 出口/ 信息/ 的/ 查找/ 过程/ 可以/ 在/ 帧/ 交换/ 时/ 并行/ 查找/ ,/ 并/ 在/ 出口处/ 再/ 进行/ 更新/ ./ 综上所述/ ,/ OOQ/ // ICF/ 结构/ 在/ SUPA/ 以/ EPFTS/ 技术/ 为/ 基础/ 的/ 平台/ 上/ 实现/ ,/ 可以/ 充分利用/ SUPA/ 和/ EPFTS/ 的/ 优势/ ,/ 并且/ 可以/ 为/ SUPA/ 提供/ 更好/ 的/ 服务质量/ 保证/ ./ 相对/ 于/ 目前/ 以/ IP/ 为/ 基础/ 的/ 网络/ 环境/ ,/ 我们/ 认为/ OOQ/ // ICF/ 在/ SUPA/ 环境/ 下/ 实现/ 具有/ 不可/ 比拟/ 的/ 优势/ ./ 7/ 总结/ 与/ 展望/ 本文/ 提出/ 了/ 一种/ 面向/ 输出/ 端/ 排队/ 的/ 交换/ 结构/ (/ OOQ/ )/ ,/ 该/ 结构/ 将/ 实际/ 的/ 信元/ 存储/ 于/ 输入/ 单元/ ,/ 但是/ 其/ 请求/ 在/ 输出/ 单元/ 排队/ ./ 输出/ 单元/ 在/ 一个/ 传输/ 时槽/ 开始/ 时/ 从/ 请求/ 队列/ 中/ 取出/ 队头/ 请求/ ,/ 然后/ 从/ 输入/ 单元/ “/ 拉/ ”/ 信元/ ./ 此时/ 存在/ 多个/ 输出/ 单元/ “/ 拉/ ”/ 同一个/ 输入/ 单元/ 的/ 冲突/ ./ 本文/ 随后/ 提出/ 了/ 一种/ 输入/ 端/ 不/ 冲突/ (/ ICF/ )/ 的/ 算法/ 来/ 解决/ 这一/ 冲突/ ,/ 为了/ 配合/ 这一/ 算法/ ,/ 我们/ 设计/ 了/ 一种/ 调度/ 矩阵/ 来/ 快速/ 选择/ 出/ 队列/ 中/ 的/ 可用/ 位置/ ,/ 并/ 将/ 请求/ 放置/ 到/ 该/ 位置/ ./ 使用/ 这种/ 调度/ 矩阵/ ,/ ICF/ 算法/ 的/ 复杂度/ 和/ 端口数/ 呈/ 线性关系/ ./ 我们/ 同时/ 也/ 证明/ 了/ OOQ/ // ICF/ 结构/ 调度/ 的/ 结果/ 等价/ 于/ 贪婪/ 算法/ GMWM/ // OCF/ 的/ 调度/ 结果/ ,/ 在/ 此基础/ 上/ 进一步/ 证明/ 了/ ICF/ 算法/ 要/ 达到/ 100/ %/ 吞吐/ 率/ 的/ 充分条件/ 是/ 使用/ 2/ 倍/ 的/ 传输/ 加速/ 比/ ./ 在/ 研究/ 过程/ 中/ 我们/ 发现/ ,/ ICF/ 算法/ 的/ 思路/ 和/ FPCF/ (/ ForwardingPlanningConflict/ -/ Free/ )/ [/ 15/ ]/ 策略/ 类似/ ,/ 但/ 区别/ 在于/ :/ (/ 1/ )/ 后者/ 没有/ 给出/ 相应/ 的/ 理论/ 分析/ 并/ 证明/ 算法/ 达到/ 稳定性/ 的/ 条件/ ;/ (/ 2/ )/ FPCF/ 给出/ 的/ 位置/ 查找/ 算法/ 性能/ 低/ ,/ 不/ 实用/ ,/ 本文/ 设计/ 了/ 一种/ 实用/ 的/ 快速/ 查找/ 不/ 冲突/ 位置/ 的/ 调度/ 矩阵/ ;/ (/ 3/ )/ 也/ 是/ 最/ 重要/ 的/ 区别/ ,/ ICF/ 算法/ 排队/ 是/ 在/ 输出/ 端/ 进行/ ,/ 而/ FPCF/ 算法/ 排队/ 还是/ 在/ 输入/ 端/ 进行/ ,/ 从而/ 输出/ 端口/ 不/ 知道/ 要/ 到达/ 该/ 端口/ 的/ 具体/ 信元/ 数量/ ./ 实验/ 表明/ 面向/ 输出/ 的/ 排队/ 机制/ 对于/ 拥塞/ 控制/ 和/ 主动/ 队列/ 管理/ 的/ 实现/ 都/ 有/ 很大/ 优势/ ./ 文章/ 最后/ 通过/ 仿真/ 发现/ ,/ 无论/ 在/ Bernoulli/ 还是/ 突发/ 的/ 均匀/ 流量/ 下/ ,/ ICF/ 算法/ 和/ 5/ -/ SLIP/ 算法/ 的/ 时延/ 性能/ 都/ 比较/ 接近/ ,/ 特别/ 当/ 突发/ 长度/ 较大/ 时/ ,/ ICF/ 和/ 其它/ 结构/ 或/ 算法/ 的/ 时延/ 趋于/ 相同/ ./ 同时/ ,/ ICF/ 算法/ 的/ 抖动/ 性能/ 都/ 优于/ iSLIP/ 算法/ 和/ CICB/ -/ 1/ // RR/ 结构/ ,/ 且/ 当/ 突发/ 增大/ 时/ ,/ ICF/ 算法/ 的/ 抖动/ 性能/ 越来越/ 接近/ OQ/ ./ 这/ 对于/ 当前/ 多媒体/ 数据/ 和/ 实时/ 数据传输/ 非常/ 有利/ ./ 在/ 非/ 均匀/ 流量/ 下/ ,/ 仿真/ 结果表明/ ,/ 只要/ 使用/ 1.14/ 倍/ 左右/ 的/ 加速/ 比/ 即可/ 达到/ 100/ %/ 吞吐/ 率/ ./ 综合/ 时延/ 和/ 吞吐/ 率/ 的/ 仿真/ 结果/ 来看/ 只要/ 使用/ 1.2/ 倍/ 的/ 传输/ 加速/ 比/ ,/ 即可/ 达到/ 比较/ 好/ 的/ 时延/ 、/ 抖动/ 和/ 吞吐/ 率/ 性能/ ./ 由于/ 本文/ 中/ 证明/ 的/ 2/ 倍/ 加速/ 比/ 不是/ 必要条件/ ,/ 我们/ 在/ 下/ 一步/ 的/ 工作/ 中将/ 试图/ 找到/ 比/ 2/ 更/ 低/ 的/ 条件/ ,/ 使得/ 结构/ 达到/ 100/ %/ 的/ 吞吐/ 率/ ;/ 其次/ 我们/ 将/ 着重/ 研究/ 基于/ OOQ/ // ICF/ 结构/ 的/ 优先级/ 策略/ 、/ 拥塞/ 控制/ 、/ 准入/ 控制/ 以及/ 主动/ 队列/ 管理策略/ ./ 

