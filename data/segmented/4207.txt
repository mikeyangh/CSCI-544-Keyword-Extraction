Page1/ 大规模/ RFID/ 系统/ 中/ 一种/ 能量/ 有效/ 的/ 丢失/ 标签/ 快速/ 检测/ 算法/ 张士庚/ 1/ )/ ,/ 3/ )/ 刘光亮/ 1/ )/ 刘璇/ 2/ )/ 王建新/ 1/ )/ 1/ )/ (/ 中南大学/ 信息科学/ 与/ 工程学院/ 长沙/ 410083/ )/ 2/ )/ (/ 香港理工大学/ 计算机系/ 香港/ )/ 3/ )/ (/ 计算机软件/ 新/ 技术/ 国家/ 重点/ 实验室/ (/ 南京大学/ )/ 南京/ 210046/ )/ 摘要/ 在/ 基于/ 主动式/ 标签/ 构建/ 的/ RFID/ 系统/ 中/ ,/ 如何/ 以/ 能量/ 有效/ 的/ 方式/ 检测/ 出/ 丢失/ 标签/ 是/ 一个/ 重要/ 的/ 研究/ 问题/ ./ 针对/ 多/ 阅读器/ RFID/ 系统/ ,/ 首次/ 提出/ 一种/ 基于/ 虚拟/ 布鲁姆/ 过滤器/ 的/ 丢失/ 标签/ 检测/ 算法/ BMD/ ,/ 能够/ 以较/ 低/ 的/ 能量/ 开销/ 快速/ 地/ 检测/ 出/ 丢失/ 标签/ ./ 算法/ 的/ 核心思想/ 是/ 让/ 标签/ 在/ 一个/ 查询/ 帧/ 中/ 对/ RFID/ 阅读器/ 进行/ 多次/ 回复/ ,/ 并/ 基于/ 回复/ 信息/ 构造/ 若干/ “/ 虚拟/ ”/ 布鲁姆/ 过滤器/ 来/ 进行/ 丢失/ 标签/ 检测/ ./ 理论/ 分析/ 和/ 仿真/ 结果/ 均/ 表明/ 了/ BMD/ 算法/ 的/ 有效性/ ./ 相比/ 于/ 传统/ 的/ 基于/ 标签/ 标识号/ 收集/ 的/ 检测/ 方法/ ,/ BMD/ 算法/ 的/ 能耗/ 要/ 低/ 一个/ 数量级/ ,/ 算法/ 执行/ 时间/ 减少/ 了/ 最高/ 达/ 52/ %/ ;/ 相比/ 于/ 当前/ 最好/ 的/ 单/ 阅读器/ 丢失/ 标签/ 检测/ 算法/ IIP/ ,/ BMD/ 算法/ 的/ 能耗/ 要/ 低/ 两个/ 数量级/ 以上/ ,/ 并且/ 算法/ 执行/ 时间/ 减少/ 了/ 最高/ 达/ 80/ %/ ./ 关键词/ 无线/ 射频/ 识别/ ;/ 丢失/ 标签/ 检测/ ;/ 布鲁姆/ 过滤器/ ;/ 能量/ 有效/ ;/ 物/ 联网/ 1/ 引言/ 无线/ 射频/ 识别/ (/ RFID/ )/ 技术/ 是/ 物/ 联网/ 体系/ 中/ 一种/ 不可或缺/ 的/ 核心/ 关键技术/ ,/ 目前/ 已经/ 被/ 广泛/ 地/ 应用/ 于/ 包括/ 物流/ 追踪/ 、/ 仓储/ 管理/ 、/ 智能/ 交通/ 等/ 许多/ 领域/ ./ 在/ 这些/ 应用/ 中/ ,/ 每个/ 货物/ 上/ 都/ 安装/ 一个/ RFID/ 标签/ (/ Tag/ )/ ,/ 该/ 标签/ 存储/ 了/ 货物/ 对应/ 的/ 相关/ 信息/ ,/ 如/ 产品/ 标识号/ 和/ 货物/ 状态/ 等/ ./ 利用/ 预先/ 部署/ 的/ RFID/ 阅读器/ (/ Reader/ )/ ,/ 可以/ 通过/ 无线电/ 信号/ 对/ RFID/ 标签/ 中/ 存储/ 的/ 数据/ 进行/ 读写/ ,/ 从而/ 有效/ 地/ 对/ 货物/ 状态/ 进行/ 追踪/ 和/ 管理/ ./ 与/ 传统/ 的/ 二维码/ 和/ 条形码/ 等/ 技术/ 不同/ ,/ RFID/ 阅读器/ 可以/ 在/ 相对/ 较大/ 的/ 范围/ 内/ 对/ 标签/ 中/ 的/ 数据/ 进行/ 读写/ ,/ 并且/ 不/ 需要/ 阅读器/ 与/ 标签/ 之间/ 满足/ 视距/ (/ lineofsight/ )/ 传输/ ,/ 因而/ 能够/ 极大/ 地/ 提升/ 读取/ 效率/ ./ 目前/ ,/ RFID/ 自动识别/ 技术/ 以及/ 相关/ 研究/ 已经/ 成为/ 国内外/ 研究/ 的/ 热点问题/ [/ 1/ -/ 5/ ]/ ./ RFID/ 标签/ 可以/ 分为/ 两类/ [/ 1/ ,/ 4/ ]/ :/ 主动式/ 标签/ 和/ 被动式/ 标签/ ./ 主动式/ 标签/ 利用/ 内嵌/ 的/ 电池/ 和/ 阅读器/ 进行/ 通信/ ,/ 而/ 被动式/ 标签/ 通过/ 反射/ RFID/ 阅读器/ 发射/ 的/ 信号/ 来/ 与/ 阅读器/ 通信/ ./ 相比/ 于/ 被动式/ 标签/ ,/ 主动式/ 标签/ 可以/ 提供/ 更/ 多/ 的/ 附加/ 功能/ ,/ 如对/ 周围环境/ 信息/ 进行/ 感知/ 等/ ,/ 因此/ 目前/ 在/ 很多/ 的/ 应用/ 中/ 大量/ 使用/ 的/ 是/ 主动/ 标签/ ,/ 特别/ 是/ 在/ 对/ 贵重物品/ 或者/ 大型/ 物品/ 的/ 监控/ 方面/ 更是如此/ [/ 6/ -/ 8/ ]/ ./ 由于/ 主动式/ 标签/ 是/ 利用/ 内嵌/ 电池/ 供电/ 的/ ,/ 因此/ 针对/ 基于/ 主动式/ 标签/ 构建/ 的/ RFID/ 系统/ 来/ 设计/ 能量/ 有效/ 的/ 监控/ 和/ 识别/ 算法/ 是/ 目前/ 国内外/ 学术界/ 的/ 一个/ 关注/ 热点/ [/ 4/ ,/ 7/ -/ 8/ ]/ ./ 在/ RFID/ 系统/ 中/ ,/ 如何/ 快速/ 检测/ 丢失/ 标签/ 从而/ 快速/ 发现/ 丢失/ 的/ 货物/ 是/ 一个/ 很/ 重要/ 的/ 研究/ 问题/ ./ 例如/ ,/ 假设/ 有/ 一个/ 武器/ 仓库/ ,/ 其中/ 存储/ 了/ 大量/ 的/ 枪支/ ./ 如果/ 有人/ 未经/ 允许/ 将/ 仓库/ 中/ 的/ 武器/ 私自/ 带/ 出/ ,/ 将会/ 对/ 社会/ 安全/ 造成/ 极大/ 的/ 隐患/ ./ 因此/ ,/ 我们/ 需要/ 对/ 仓库/ 中/ 的/ 枪支/ 进行/ 严密/ 监控/ ,/ 在/ 武器/ 丢失/ 时/ (/ 在/ RFID/ 系统/ 中/ 表现/ 为/ 对应/ 的/ 标签/ 丢失/ )/ 能够/ 及时/ 地/ 检测/ 出该/ 事件/ 并/ 判断/ 出是/ 哪件/ 武器/ 丢失/ ./ 理论/ 上/ ,/ 我们/ 可以/ 通过/ 读取/ 所有/ 标签/ 的/ 标识号/ ,/ 并/ 将/ 所/ 搜集/ 到/ 的/ 标签/ 集合/ 与/ 系统/ 中/ 存储/ 的/ 标签/ 集合/ 进行/ 对比/ 来/ 检测/ 出/ 丢失/ 标签/ ./ 然而/ ,/ 目前/ RFID/ 标签/ 的/ 识别/ 仍然/ 是/ 一个/ 比较/ 耗时/ 的/ 过程/ :/ 标签/ 识别/ 的/ 吞吐量/ 只有/ 100/ 个/ ~/ 200/ 个/ // s/ [/ 3/ ,/ 6/ ,/ 9/ ]/ ./ 当/ 系统/ 规模/ 很大/ 时/ (/ 大型超市/ 中/ 的/ 标签/ 数目/ 可能/ 达到/ 几十万/ 甚至/ 上百万/ )/ ,/ 利用/ 标签/ 读取/ 的/ 方法/ 来/ 检测/ 丢失/ 标签/ 是/ 一个/ 很/ 耗时/ 的/ 过程/ ./ 更/ 重要/ 的/ 是/ ,/ RFID/ 标签/ 的/ 识别/ 需要/ 传输/ 标签/ 的/ 标识号/ ,/ 而/ 这/ 是/ 一个/ 非常/ 耗能/ 的/ 过程/ ,/ 特别/ 是/ 对于/ 使用/ 内嵌/ 电池/ 供电/ 的/ 主动/ 标签/ 来说/ ./ 因此/ ,/ 如何/ 在/ 不/ 收集/ 标签/ 标识号/ 的/ 情况/ 下/ ,/ 以/ 一种/ 能量/ 有效/ 的/ 方式/ 快速/ 准确/ 地/ 检测/ 出/ 系统/ 中/ 的/ 丢失/ 标签/ ,/ 是/ 近年来/ RFID/ 研究/ 领域/ 中/ 的/ 一个/ 重要/ 研究/ 方向/ ./ 在/ 本文/ 中/ ,/ 针对/ 基于/ 主动式/ 标签/ 构建/ 的/ RFID/ 系统/ ,/ 我们/ 提出/ 了/ 一种/ 能量/ 有效/ 的/ 快速/ 丢失/ 标签/ 检测/ 算法/ ./ 其/ 核心思想/ 是/ 通过/ 让/ 标签/ 在/ 一个/ 查询/ 帧/ 中/ 对/ 阅读器/ 进行/ 多次/ 回复/ 来/ 构建/ “/ 虚拟/ ”/ 的/ 布鲁姆/ 过滤器/ (/ Bloomfilter/ )/ ,/ 然后/ 基于/ 所/ 构造/ 的/ 虚拟/ 布鲁姆/ 过滤器/ 来/ 判断/ 标签/ 是否/ 丢失/ ./ 由于/ 布鲁姆/ 过滤器/ 能够/ 以较/ 小/ 的/ 空间/ 开销/ 表示/ 元素/ 与/ 集合/ 的/ 从属关系/ [/ 10/ ]/ ,/ 因此/ 我们/ 所/ 构建/ 的/ 虚拟/ 布鲁姆/ 过滤器/ 能够/ 以较/ 小/ 的/ 时间/ 开销/ 来/ 检测/ 出/ 标签/ 是否/ 存在/ 于/ 系统/ 中/ ./ 更/ 重要/ 的/ 是/ ,/ 我们/ 所/ 提出/ 的/ 算法/ 既/ 不/ 需要/ 收集/ 标签/ 标识号/ ,/ 也/ 不/ 需要/ 向/ 标签/ 广播/ 大量/ 的/ 信息/ ,/ 从而/ 能够/ 极大/ 地/ 降低/ 通信/ 开销/ ,/ 达到/ 节省/ 能量/ 的/ 目的/ ./ 我们/ 所/ 提出/ 的/ 算法/ 适用/ 于/ 包含/ 多个/ 阅读器/ 的/ 大规模/ RFID/ 系统/ ./ 本文/ 主要/ 创新/ 点/ 如下/ :/ (/ 1/ )/ 针对/ 基于/ 主动式/ 标签/ 构建/ 的/ 多/ 阅读器/ RFID/ 系统/ ,/ 首次/ 提出/ 一种/ 基于/ 虚拟/ 布鲁姆/ 过滤器/ 的/ 丢失/ 标签/ 检测/ 算法/ BMD/ ,/ 能够/ 以较/ 低/ 的/ 能量/ 开销/ 快速/ 地/ 检测/ 出/ 丢失/ 标签/ ./ (/ 2/ )/ 对/ 算法/ 的/ 性能/ 进行/ 了/ 理论/ 分析/ ,/ 从/ 理论/ 上/ 推导/ 出/ 了/ 在/ 保证/ 检测/ 概率/ 的/ 前提/ 下/ 的/ 关键/ 系统/ 参数/ 的/ 最优/ 值/ ,/ 以/ 达到/ 最小化/ 标签/ 平均/ 能耗/ 的/ 同时/ 减少/ 检测时间/ 的/ 目的/ ./ (/ 3/ )/ 通过/ 仿真/ 证明/ 了/ 所/ 提出/ 算法/ 的/ 有效性/ ./ 相比/ 于/ 传统/ 的/ 基于/ 标签/ 标识号/ 收集/ 的/ 方法/ ,/ 本文/ 所/ 提出/ 算法/ 的/ 标签/ 平均/ 能耗/ 要/ 低/ 一个/ 数量级/ 以上/ ,/ 并且/ 检测时间/ 减少/ 了/ 最高/ 达/ 52/ %/ ./ 相比/ 于/ 当前/ 最好/ 的/ 单/ 阅读器/ 丢失/ 标签/ 检测/ 算法/ IIP/ [/ 11/ ]/ ,/ BMD/ 算法/ 的/ 能耗/ 要/ 低/ 两个/ 数量级/ 以上/ ,/ 并且/ 算法/ 执行/ 时间/ 减少/ 了/ 最高/ 达/ 80/ %/ ./ 本文/ 在/ 第/ 2/ 节/ 介绍/ 相关/ 工作/ ;/ 在/ 第/ 3/ 节/ 给出/ 系统/ 模型/ 和/ 问题/ 定义/ ;/ 在/ 第/ 4/ 节/ 介绍所/ 提出/ 的/ BMD/ 算法/ ,/ 并/ 对/ 算法/ 性能/ 进行/ 了/ 理论/ 分析/ ,/ 讨论/ 了/ 如何/ 设置/ 系统/ 参数/ 来/ 最小化/ 标签/ 能耗/ 和/ 算法/ 执行/ 时间/ ;/ 第/ 5/ 节/ 给出/ 仿真/ 结果/ 并/ 进行/ 了/ 讨论/ ;/ 最后/ ,/ 第/ 6/ 节/ 进行/ 总结/ 并/ 探讨/ 将来/ 研究/ 方向/ ./ 2/ 相关/ 工作/ 早期/ RFID/ 领域/ 的/ 研究/ 大多/ 集中/ 于/ 如何/ 设计/ 高/ Page3/ 效/ 的/ RFID/ 标签/ 识别/ 协议/ 来/ 提升/ 标签/ 识别/ 的/ 吞吐量/ [/ 5/ ,/ 12/ -/ 16/ ]/ ./ 现有/ 的/ RFID/ 标签/ 识别/ 协议/ 可以/ 分为/ 两种/ :/ 基于/ ALOHA/ 的/ 协议/ 和/ 基于/ 树/ 的/ 协议/ ./ 在/ 基于/ ALOHA/ 的/ 协议/ [/ 13/ -/ 16/ ]/ 中/ ,/ 标签/ 和/ 阅读器/ 之间/ 的/ 通信/ 划分/ 成帧/ ,/ 而/ 帧/ 又/ 进一步/ 划分/ 为/ 不同/ 的/ 时隙/ ./ 当/ 一个/ 标签/ 收到/ 阅读器/ 的/ 查询/ 命令/ 后/ ,/ 就/ 会/ 在/ 当前/ 帧/ 中/ 随机/ 选择/ 一个/ 时隙/ 对/ 阅读器/ 进行/ 回复/ ./ 如果/ 在/ 某个/ 时隙/ 中/ 只有/ 一个/ 标签/ 对/ 阅读器/ 进行/ 回复/ ,/ 则/ 该/ 标签/ 能够/ 被/ 阅读器/ 正确/ 识别/ ./ 如果/ 在/ 当前/ 帧/ 完成/ 之后/ 还/ 存在/ 未/ 识别/ 的/ 标签/ ,/ 则/ 阅读器/ 启动/ 一个/ 新帧/ 来/ 对/ 剩余/ 未/ 识别/ 的/ 标签/ 进行/ 继续/ 识别/ ./ 在/ 基于/ 树/ 的/ 协议/ 中/ [/ 1/ ,/ 4/ -/ 5/ ]/ ,/ 阅读器/ 在/ 每次/ 的/ 查询/ 命令/ 中/ 广播/ 一个/ 前缀/ 信息/ ,/ 所有/ 满足/ 这个/ 前缀/ 的/ 标签/ 均会/ 向/ 阅读器/ 发送/ 回复/ ./ 阅读器/ 检测/ 回复/ 是否/ 冲突/ ./ 如果/ 回复/ 冲突/ ,/ 则/ 阅读器/ 通过/ 更改/ 前缀/ 将/ 回复/ 的/ 标签/ 分成/ 两/ 部分/ ,/ 并/ 通过/ 广播/ 不同/ 的/ 新/ 前缀/ 来/ 让/ 不同/ 的/ 标签/ 子集合/ 回复/ ./ 当/ 阅读器/ 检测/ 到/ 只有/ 一个/ 标签/ 回复/ 时/ ,/ 则/ 成功/ 识别/ 该/ 标签/ ./ 虽然/ 已有/ 的/ RFID/ 标签/ 识别/ 协议/ 可以/ 用于/ 检测/ 丢失/ 标签/ ,/ 但是/ 标签/ 的/ 识别/ 耗时/ 较大/ ,/ 并且/ 标签/ ID/ 的/ 传输/ 会/ 造成/ 较大/ 的/ 通信/ 开销/ ./ 特别/ 是/ 对/ 依赖/ 电池/ 供电/ 的/ 主动/ 标签/ 来说/ ,/ 利用/ RFID/ 识别/ 来/ 进行/ 丢失/ 标签/ 检测/ 所/ 消耗/ 的/ 能量/ 过高/ ./ 与/ 直接/ 收集/ 标签/ 标识号/ 的/ 方法/ 相比/ ,/ 我们/ 所/ 提出/ 的/ BMD/ 算法/ 不仅/ 极大/ 地/ 降低/ 了/ 能量消耗/ (/ 标签/ 的/ 平均/ 能耗/ 降低/ 了/ 一个/ 数量级/ 以上/ )/ ,/ 而且/ 有效/ 地/ 减少/ 了/ 算法/ 执行/ 时间/ ./ 目前/ 已经/ 有/ 学者/ 展开/ 了/ 在/ 不/ 收集/ 标签/ 标识号/ 的/ 情况/ 下来/ 检测/ 丢失/ 标签/ 的/ 研究/ [/ 11/ ,/ 17/ ]/ ./ 在/ 文献/ [/ 17/ ]/ 中/ ,/ 作者/ 提出/ 了/ 一个/ 概率/ 性/ 的/ 丢失/ 标签/ 检测/ 算法/ ./ 该/ 算法/ 通过/ 比较/ 阅读器/ 在/ 每个/ 时隙/ 期望/ 得到/ 的/ 回复/ 状态/ 和/ 实际/ 检测/ 到/ 的/ 回复/ 状态/ 来/ 判断/ 系统/ 中/ 是否/ 有/ 标签/ 丢失/ ./ 但是/ 该/ 算法/ 不能/ 准确/ 地/ 确定/ 具体/ 是/ 哪些/ 标签/ 丢失/ ./ 在/ 文献/ [/ 11/ ]/ 中/ ,/ 作者/ 针对/ 单/ 阅读器/ RFID/ 系统/ 提出/ 了/ 一个/ 高效/ 的/ 丢失/ 标签/ 检测/ 算法/ IIP/ (/ Itera/ -/ tiveID/ -/ freeProtocol/ )/ ./ 在/ 该/ 算法/ 中/ ,/ 阅读器/ 首先/ 根据/ 系统/ 中/ 存储/ 的/ 标签/ 信息/ 来/ 计算/ 一个/ 帧/ 前/ 向量/ (/ pre/ -/ framevector/ )/ 并/ 将/ 该/ 向量/ 广播/ 给/ 系统/ 中/ 所有/ 的/ 标签/ ./ 系统/ 中/ 的/ 标签/ 收到/ 该/ 向量/ 后/ ,/ 根据/ 向量/ 中/ 的/ 值来/ 判断/ 自己/ 是否/ 应该/ 向/ 阅读器/ 发送/ 回复/ ./ 当/ 阅读器/ 收集/ 到/ 标签/ 的/ 回复/ 后/ ,/ IIP/ 协议/ 就/ 可以/ 判断/ 出/ 哪些/ 标签/ 是/ 未/ 丢失/ 的/ 并/ 基于/ 此/ 计算/ 出/ 一个/ 帧/ 后/ 向量/ (/ post/ -/ framevector/ )/ 来/ 通知/ 这些/ 标签/ 在/ 下/ 一个/ 帧/ 中/ 退出/ 协议/ ./ 当/ 所有/ 的/ 标签/ 均/ 回复/ 后/ ,/ IIP/ 协议/ 即可/ 判断/ 出/ 丢失/ 标签/ ./ 由于/ 阅读器/ 可以/ 利用/ 一个/ 标签/ ID/ 发送/ 多位/ 向量/ ,/ 因此/ IIP/ 可以/ 快速/ 地/ 检测/ 丢失/ 标签/ ,/ 其/ 对/ 每个/ 标签/ 的/ 平均/ 检测时间/ 可以/ 达到/ 一个/ 常/ 数值/ (/ 约/ 0.86/ ms/ )/ ./ 同时/ 该/ 算法/ 不仅/ 能够/ 检测/ 是否/ 有/ 标签/ 丢失/ ,/ 还/ 能够/ 准确/ 地/ 确定/ 出是/ 哪些/ 标签/ 丢失/ ./ 然而/ ,/ 在/ IIP/ 协议/ 中/ ,/ 每个/ 标签/ 需要/ 从/ 阅读器/ 接收/ 大量/ 的/ 信息/ ,/ 对于/ 主动式/ 标签/ 来说/ IIP/ 会/ 带来/ 较大/ 的/ 能量/ 开销/ ./ 在/ 文献/ [/ 8/ ]/ 中/ 作者/ 指出/ ,/ 主动/ 标签/ 的/ 能耗/ 主要/ 取决于/ 发送/ 和/ 接收数据/ 量/ 的/ 多少/ ./ 在/ IIP/ 协议/ 中/ ,/ 标签/ 需要/ 接收/ 阅读器/ 发送/ 的/ 大量/ 信息/ ,/ 因而/ 不/ 适合/ 于用/ 主动/ 标签/ 构件/ 的/ 大规模/ RFID/ 系统/ ./ 同时/ ,/ 当/ IIP/ 协议/ 应用/ 到/ 多/ 阅读器/ RFID/ 系统/ 中/ 时/ ,/ 其/ 执行/ 时间/ 也/ 会/ 大大增加/ ./ 这/ 是因为/ 在/ 协议/ 执行/ 过程/ 中/ 的/ 每/ 一轮/ ,/ IIP/ 协议/ 都/ 要/ 根据/ 系统/ 中/ 所有/ 的/ 标签/ 来/ 计算/ 前置/ 向量/ 和/ 后置/ 向量/ ,/ 并/ 广播/ 给/ 所有/ 的/ 标签/ ./ 同时/ ,/ 在/ IIP/ 协议/ 中/ 阅读器/ 需要/ 将/ 系统/ 中/ 所有/ 标签/ 的/ 回复/ 收集/ 完成/ 后/ 才/ 能够/ 计算/ 出/ 后置/ 向量/ ,/ 这/ 使得/ IIP/ 协议/ 无法/ 并行执行/ ./ 在/ 多/ 阅读器/ 环境/ 下/ ,/ 由于/ 阅读器/ 之间/ 的/ 冲突/ ,/ 多个/ 阅读器/ 需要/ 调度/ 交替/ 执行/ ./ 假设/ 需要/ k/ 轮/ 才能/ 将/ 所有/ 的/ 阅读器/ 调度/ 执行/ 完毕/ ,/ 则/ IIP/ 协议/ 的/ 执行/ 时间/ 会/ 变为/ 单/ 阅读器/ 情况/ 下/ 的/ k/ 倍/ ./ 因此/ ,/ 在/ 多/ 阅读器/ 环境/ 下/ ,/ IIP/ 协议/ 的/ 执行/ 时间/ 将会/ 大为/ 增加/ ./ 与/ 前述/ 工作/ 相比/ ,/ 本文/ 中/ 提出/ 的/ 方法/ 通过/ 构造/ 虚拟/ 布鲁姆/ 过滤器/ 来/ 检测/ 丢失/ 标签/ ./ 在/ 该/ 方法/ 中/ ,/ 标签/ 和/ 阅读器/ 之间/ 的/ 通信/ 数据量/ 较/ 少/ ,/ 因此/ 能够/ 极大/ 地/ 降低/ 标签/ 的/ 能量消耗/ ./ 同时/ ,/ 利用/ 多/ 阅读器/ 之间/ 的/ 并行性/ ,/ 本文/ 所/ 提出/ 的/ 方法/ 能够/ 有效/ 地/ 减少/ 检测时间/ ,/ 适用/ 于/ 多/ 阅读器/ 大规模/ RFID/ 系统/ 中/ 的/ 丢失/ 标签/ 检测/ ./ 3/ 系统/ 模型/ 和/ 问题/ 定义/ 3.1/ 系统/ 模型/ 我们/ 考虑/ 的/ RFID/ 系统/ 由/ 3/ 部分/ 组成/ :/ 一个/ 后台/ 服务器/ ,/ 一组/ RFID/ 阅读器/ 以及/ 大量/ 的/ RFID/ 标签/ ./ 图/ 1/ 给出/ 了/ 一个/ 包含/ 3/ 个/ RFID/ 阅读器/ 的/ 例子/ ./ 在/ 系统/ 中/ ,/ 后台/ 服务器/ 负责/ 对/ 阅读器/ 进行/ 协调/ 和/ 调度/ ,/ 来/ 确定/ 不同/ 阅读器/ 的/ 工作/ 次序/ 以/ 避免/ 冲突/ ,/ 并/ 设定/ 各/ 阅读器/ 的/ 工作/ 参数/ ./ 这里/ ,/ 我们/ 假设/ 后台/ 服务器/ 和/ 各个/ RFID/ 阅读器/ 之间/ 存在/ 着/ 有/ 线或/ 无线/ 的/ 高速/ 连接/ ,/ 服务器/ 和/ 阅读器/ 之间/ 可以/ 进行/ 直接/ 通信/ 来/ 交换/ 信息/ ./ 阅读器/ 在/ 服务器/ 所/ 分配/ 的/ 时间段/ 中/ 利用/ 服务器/ 所/ 确定/ 的/ 参数/ 与/ 自己/ 覆盖范围/ 内/ 的/ 标签/ 通信/ ,/ 并/ 将/ 所/ 收集/ 的/ 标签/ 回复/ 信息/ 传回/ 给/ 服务器进行/ 处/ Page4/ 理/ ./ 与/ 已有/ 的/ 工作/ [/ 16/ -/ 17/ ]/ 一致/ ,/ 这里/ 我们/ 假设/ 后台/ 服务器/ 存储/ 着/ 系统/ 中/ 所有/ 标签/ 的/ 信息/ (/ 包括/ 当前/ 系统/ 中/ 仍/ 存在/ 的/ 标签/ 和/ 丢失/ 的/ 标签/ )/ ./ 图/ 1/ 系统/ 模型/ 示意图/ (/ 黑色/ 的/ 点/ 表示/ 丢失/ 标签/ )/ 在/ 协议/ 运行/ 过程/ 中/ ,/ RFID/ 标签/ 接收/ 阅读器/ 的/ 查询/ 命令/ ,/ 并/ 返回/ 相应/ 的/ 回复/ 信息/ ./ 我们/ 假设/ 阅读器/ 和/ 标签/ 之间/ 的/ 通信/ 采用/ 帧/ -/ 时隙/ ALOHA/ 协议/ (/ FrameslottedALOHAprotocol/ )/ ./ 在/ 该/ 协议/ 中/ ,/ 阅读器/ 和/ 标签/ 之间/ 的/ 通信/ 划分/ 为/ 帧/ 进行/ ./ 在/ 每个/ 帧/ 中/ ,/ 阅读器/ 广播/ 查询/ 命令/ 并/ 指明/ 当前/ 帧/ 所/ 包含/ 时隙/ 的/ 个数/ ,/ 每个/ 标签/ 在/ 帧/ 中/ 随机/ 选择/ 一个/ 时隙/ 对/ 阅读器/ 进行/ 回复/ ./ 具体来说/ ,/ 在/ 每个/ 查询/ 帧/ 的/ 开始/ ,/ 阅读器/ 广播/ 两个/ 参数/ :/ 帧/ 大小/ f/ 和/ 一个/ 随机数/ s/ ,/ 其中/ f/ 指明/ 了/ 该/ 帧/ 包含/ 的/ 时隙/ 个数/ ,/ 而/ s/ 用来/ 帮助/ 标签/ 在/ 该/ 帧/ 中/ 随机/ 选择/ 一个/ 时隙/ 对/ 阅读器/ 进行/ 回复/ ./ 假设/ 标签/ T/ 的/ 标识号/ 为/ TID/ ./ 当/ 收到/ 阅读器/ 所/ 广播/ 的/ 参数/ 后/ ,/ 标签/ T/ 利用/ 一个/ Hash/ 函数/ H/ 将/ 自己/ 的/ 标识号/ 映射/ 到/ [/ 0/ ,/ f/ -/ 1/ ]/ 中/ 的/ 一个/ 值/ :/ sc/ =/ H/ (/ TID/ ‖/ s/ )/ modf/ ,/ 并/ 在/ 第/ sc/ 个/ 时隙/ 回复/ 阅读器/ ./ 根据/ 回复/ 标签/ 数目/ 的/ 不同/ ,/ 时隙/ 可以/ 分为/ 3/ 种/ 不同/ 的/ 类型/ :/ (/ 1/ )/ 空/ 时隙/ ,/ 其中/ 没有/ 标签/ 回复/ ;/ (/ 2/ )/ 单/ 时隙/ ,/ 仅/ 有/ 一个/ 标签/ 回复/ ;/ (/ 3/ )/ 冲突/ 时隙/ ,/ 有/ 两个/ 以上/ 的/ 标签/ 同时/ 回复/ ./ 只有/ 在/ 单/ 时隙/ 中/ 回复/ 的/ 标签/ 才/ 能够/ 被/ 正确/ 识别/ ,/ 而/ 在/ 冲突/ 时隙/ 中/ 回复/ 的/ 标签/ 必须/ 参加/ 下/ 一个/ 帧/ 继续/ 识别/ ./ 随机数/ s/ 的/ 作用/ 是/ 让/ 同一个/ 标签/ 在/ 不同/ 的/ 帧/ 中/ 选择/ 不同/ 的/ 时隙/ 回复/ ,/ 以/ 避免/ 冲突/ 始终/ 存在/ ./ 在/ 我们/ 的/ 系统/ 模型/ 中/ ,/ 与/ 已有/ 工作/ [/ 7/ -/ 8/ ,/ 18/ ]/ 类似/ ,/ 对/ 基本/ 的/ 帧/ -/ 时隙/ ALOHA/ 通信协议/ 进行/ 了/ 一些/ 改动/ ./ 首先/ ,/ 在/ 基本/ 帧/ -/ 时隙/ ALOHA/ 协议/ 中/ ,/ 标签/ 将/ 它们/ 的/ 标识号/ (/ ID/ )/ 回复/ 给/ 阅读器/ ./ 而/ 在/ 我们/ 的/ 系统/ 模型/ 中/ ,/ 标签/ 不/ 需要/ 向/ 阅读器/ 回复/ 自身/ 标识号/ ,/ 而/ 仅仅/ 需要/ 向/ 阅读器/ 发送/ 一个/ 1/ 比特/ 的/ 短/ 回复/ ./ 目前/ 在/ 标签/ 集合/ 动态/ 监控/ 方面/ 的/ 研究/ 大都/ 基于/ 这种/ 改动/ 的/ ALOHA/ 协议/ (/ 见/ 文献/ [/ 7/ -/ 8/ ,/ 18/ ]/ )/ ,/ 并且/ 当前/ 的/ RFID/ 标签/ ,/ 例如/ 飞利浦/ I/ -/ CODE/ 标签/ [/ 6/ ]/ 与/ EPCClass1Gen2/ 标签/ [/ 9/ ]/ 等/ 均/ 可以/ 支持/ 这种/ 操作/ ./ 其次/ ,/ 我们/ 假设/ 一个/ RFID/ 标签/ 在/ 一个/ 帧/ 中/ 可以/ 选择/ 多个/ 时隙/ 对/ 阅读器/ 进行/ 多次/ 回复/ ./ 这/ 要求/ 一个/ RFID/ 标签/ 同时/ 产生/ 多个/ Hash/ 值/ ./ 这/ 可以/ 通过/ 在/ 标签/ 中/ 存储/ 多个/ Hash/ 函数/ 或者/ 在/ 一个/ 帧/ 的/ 开始/ 发送/ 多个/ 随机数/ 来/ 实现/ ./ 这种/ 技术/ 已经/ 在/ 很多/ RFID/ 识别/ 技术/ 研究/ 领域/ 采用/ ,/ 包括/ 标签/ 搜索/ [/ 18/ ]/ 、/ 标签/ 数据/ 收集/ [/ 8/ ]/ 以及/ 标签/ 数目/ 估计/ [/ 19/ ]/ 等/ ./ 在/ 本文/ 中/ ,/ 我们/ 通过/ 让/ 阅读器/ 在/ 一个/ 帧/ 的/ 开始/ 发送/ 多个/ 随机数/ 来/ 实现/ 这种/ 功能/ ./ 在/ 多/ 阅读器/ RFID/ 系统/ 中/ ,/ 相邻/ 阅读器/ 之间/ 会/ 产生/ 两种/ 冲突/ [/ 20/ -/ 22/ ]/ ,/ 如图/ 2/ 所示/ ./ 第/ 1/ 种/ 称作/ 阅读器/ -/ 阅读器/ 冲突/ (/ Reader/ -/ ReaderCollision/ ,/ 简称/ 为/ R/ -/ R/ 冲突/ )/ ./ 如图/ 2/ (/ a/ )/ 所示/ ,/ 当/ 标签/ T/ 同时/ 处在/ 两个/ 阅读器/ A/ 和/ B/ 的/ 读取/ 范围/ 之内/ 时/ ,/ A/ 和/ B/ 之间/ 就/ 会/ 产生/ R/ -/ R/ 冲突/ ./ 这种/ 情况/ 下/ ,/ 如果/ 阅读器/ A/ 和/ 阅读器/ B/ 同时/ 广播/ 查询/ 请求/ ,/ 标签/ T/ 收到/ 的/ 信号/ 将会/ 受到/ 干扰/ 从而/ 不能/ 正确/ 地/ 对/ 查询/ 命令/ 进行/ 解码/ ./ 第/ 2/ 种/ 冲突/ 称为/ 阅读器/ -/ 标签/ 冲突/ (/ Reader/ -/ TagColli/ -/ sion/ ,/ 简称/ 为/ R/ -/ T/ 冲突/ )/ ./ 如图/ 2/ (/ b/ )/ 所示/ ,/ 当/ 阅读器/ A/ 位于/ 另/ 一个/ 阅读器/ B/ 的/ 读取/ 范围/ 内时/ ,/ 标签/ T/ 向/ A/ 发送/ 的/ 回复/ 可能/ 会/ 被/ 阅读器/ B/ 的/ 信号/ 所/ 干扰/ ,/ 从而/ 不能/ 正确/ 解码/ ./ 相互之间/ 会/ 产生/ 冲突/ 的/ 阅读器/ 不能/ 同时/ 工作/ ./ 在/ 多/ 阅读器/ RFID/ 系统/ 中/ ,/ 我们/ 要/ 通过/ 对/ 阅读器/ 的/ 工作/ 次序/ 进行/ 调度/ ,/ 来/ 避免/ 这/ 两种/ 冲突/ ./ 我们/ 将/ 基于/ 图/ 着色/ 算法/ 来/ 对/ 不同/ 阅读器/ 的/ 工作/ 次序/ 进行/ 调度/ ,/ 详见/ 第/ 4.3/ 节/ ./ 3.2/ 问题/ 定义/ 在/ 这/ 一节/ 我们/ 给出/ 问题/ 的/ 定义/ ./ 在/ 很多/ 情况/ 下/ ,/ 我们/ 需要/ 保证/ 丢失/ 标签/ 以/ 一定/ 的/ 概率/ 被/ 检测/ 出来/ ./ 记/ 系统/ 中/ 所有/ 标签/ 的/ 集合/ 为/ W/ ,/ 而/ 所有/ 丢失/ 标签/ 的/ 集合/ 为/ M/ ./ 我们/ 的/ 问题/ 定义/ 如下/ :/ 假设/ 已知/ 系统/ 中/ 标签/ 集合/ W/ ./ 基于/ 前述/ 系统/ 模/ Page5/ 型/ ,/ 如何/ 通过/ 阅读器/ 和/ 标签/ 之间/ 的/ 交互/ 检测/ 出/ 丢失/ 标签/ ,/ 使得/ 每/ 一个/ 丢失/ 标签/ T/ ∈/ M/ 被/ 检测/ 出/ 的/ 概率/ 大于/ 指定/ 的/ 检测/ 概率/ α/ ?/ 在/ 算法/ 的/ 设计/ 过程/ 中/ ,/ 我们/ 的/ 主要/ 目标/ 是/ 在/ 满足/ 检测/ 概率/ 的/ 前提/ 下/ ,/ 最小化/ 标签/ 的/ 能量消耗/ 并/ 尽量减少/ 算法/ 的/ 执行/ 时间/ ./ 在/ 下/ 一节/ ,/ 我们/ 将/ 详述/ 所/ 提出/ 的/ 丢失/ 标签/ 检测/ 算法/ 并/ 分析/ 如何/ 达到/ 这/ 两个/ 目标/ ./ 4/ 算法/ 描述/ 4.1/ 算法/ 概述/ 假设/ 系统/ 中/ 存在/ L/ 个/ RFID/ 阅读器/ ,/ 记/ 为/ / =/ {/ R1/ ,/ R2/ ,/ …/ ,/ RL/ }/ ,/ 这些/ 阅读器/ 覆盖/ 了/ 整个/ 监控/ 区域/ ./ 我们/ 的/ 算法/ 基于/ 如下/ 观察/ :/ 如果/ 一个/ 标签/ 为/ 丢失/ 标签/ ,/ 则/ 该/ 标签/ 不会/ 出现/ 在/ 任何/ 阅读器/ 的/ 读取/ 范围/ 内/ ./ 否则/ ,/ 如果/ 一个/ 标签/ 为/ 未/ 丢失/ 标签/ ,/ 该/ 标签/ 应该/ 出现/ 在/ 至少/ 一个/ 阅读器/ 的/ 读取/ 范围/ 内/ ./ 因此/ ,/ 我们/ 可以/ 通过/ 检测/ 一个/ 标签/ 在/ 所有/ 阅读器/ 读取/ 范围/ 内/ 的/ 存在/ 情况/ ,/ 来/ 判断/ 该/ 标签/ 是否/ 丢失/ ./ 如果/ 该/ 标签/ 在/ 至少/ 一个/ 阅读器/ 范围/ 内/ 出现/ 了/ ,/ 则/ 我们/ 认为/ 该/ 标签/ 存在/ 于/ 系统/ 中/ ,/ 不是/ 丢失/ 标签/ ./ 否则/ ,/ 如果/ 该/ 标签/ 在/ 所有/ 阅读器/ 的/ 读取/ 范围/ 内/ 都/ 没/ 出现/ ,/ 则/ 该/ 标签/ 必定/ 为/ 丢失/ 标签/ ./ 算法/ 1/ 给出/ 了/ 该/ 算法/ 的/ 框架/ ./ 为了/ 实现/ 这个/ 算法/ ,/ 我们/ 需要/ 准确/ 地/ 判定/ 一个/ 标签/ 是否/ 在/ 一个/ 阅读器/ 的/ 读取/ 范围/ 内/ ./ 通过/ 收集/ 阅读器/ 读取/ 范围/ 内/ 的/ 所有/ 标签/ 的/ 标识号/ ,/ 我们/ 可以/ 做到/ 这/ 一点/ ./ 然而/ ,/ 如同/ 我们/ 前面/ 所/ 讨论/ 的/ 那样/ ,/ 标签/ 的/ 识别/ 通常/ 是/ 一个/ 耗能/ 耗时/ 的/ 过程/ ./ 我们/ 提出/ 一种/ 基于/ 虚拟/ 布鲁姆/ 过滤器/ 的/ 算法/ ,/ 在/ 不/ 收集/ 标签/ 标识号/ 的/ 情况/ 下/ 快速/ 地/ 判断/ 一个/ 标签/ 是否/ 在/ 一个/ 阅读器/ 读取/ 范围/ 内/ ./ 该/ 算法/ 的/ 具体/ 细节/ 在/ 下/ 一/ 小节/ 给出/ ./ 算法/ 1/ ./ 丢失/ 标签/ 检测/ 算法/ ./ 输入/ :/ W/ // // 系统/ 中/ 所有/ 标签/ 集合/ 输出/ :/ M/ // // 丢失/ 标签/ 集合/ M/ =/ / ;/ FORT/ ∈/ WENDFORRETURNM4/ ./ 2/ 基于/ 虚拟/ 布鲁姆/ 过滤器/ 的/ 存在/ 性/ 测试/ 算法/ 本/ 节/ 我们/ 提出/ 一种/ 基于/ 虚拟/ 布鲁姆/ 过滤器/ 的/ 标签/ 存在/ 性/ 测试/ 算法/ ./ 我们/ 首先/ 介绍/ 布鲁姆/ 过滤器/ 的/ 概念/ ,/ 然后/ 讨论/ 如何/ 利用/ 标签/ 回复/ 来/ 构建/ 虚拟/ 布鲁姆/ 过滤器/ ,/ 并/ 基于/ 此来/ 检测/ 一个/ 标签/ 是否/ 存在/ 于/ 某个/ 阅读器/ 的/ 读取/ 范围/ 内/ ./ 4.2/ ./ 1/ 布鲁姆/ 过滤器/ 布鲁姆/ 过滤器/ [/ 10/ ]/ 是/ 一种/ 能够/ 高效/ 地/ 表示/ 集合/ 从属关系/ 的/ 数据结构/ ./ 具体来说/ ,/ 布鲁姆/ 过滤器/ 可以/ 用/ 一个/ 二进制/ 向量/ 和/ k/ 个/ Hash/ 函数/ 表示/ ,/ 向量/ 中/ 的/ 比特/ 可以/ 置位/ 为/ “/ 0/ ”/ 或者/ “/ 1/ ”/ ./ 初始/ 时/ ,/ 向量/ 中/ 的/ 所有/ 比特/ 都/ 初始化/ 为/ “/ 0/ ”/ ,/ 对应/ 于/ 一个/ 空/ 的/ 集合/ ./ 当向/ 一个/ 布鲁姆/ 过滤器/ 中/ 插入/ 一个/ 对象/ 时/ ,/ 利用/ 该/ 对象/ 和/ k/ 个/ Hash/ 函数/ ,/ 将/ 向量/ 中该/ 对象/ 对应/ 的/ k/ 个/ 位置/ 均/ 置/ 为/ “/ 1/ ”/ ./ 图/ 3/ 给出/ 了/ 一个/ 使用/ 3/ 个/ Hash/ 函数/ 的/ 布鲁姆/ 过滤器/ 的/ 例子/ ./ 在/ 3/ 个/ Hash/ 函数/ 的/ 作用/ 下/ ,/ 对象/ a/ 分别/ 对应/ 着/ 向量/ 中/ 的/ 第/ 1/ 、/ 4/ 、/ 7/ 个/ 比特/ ,/ 因此/ 当/ 将/ 对象/ a/ 插入/ 到/ 该/ 布鲁姆/ 过滤器/ 后/ ,/ 第/ 1/ 、/ 4/ 、/ 7/ 个/ 比特/ 将会/ 被/ 置/ 为/ “/ 1/ ”/ ./ 假设/ 集合/ S/ =/ {/ a/ ,/ b/ ,/ c/ }/ ,/ 将/ S/ 中/ 的/ 对象/ 全部/ 插入/ 到/ 该/ 布鲁姆/ 过滤器/ 后/ ,/ 向量/ 中/ “/ 0/ ”/ 和/ “/ 1/ ”/ 的/ 分布/ 情况/ 如图/ 2/ 所示/ ./ 这个/ 布鲁姆/ 过滤器/ 就/ 表示/ 了/ 集合/ S/ ./ 利用/ 布鲁姆/ 过滤器/ ,/ 可以/ 在/ 常数/ 时间/ 内/ 测试/ 一个/ 对象/ 是否/ 存在/ 于/ 某个/ 集合/ 中/ ./ 给定/ 对象/ x/ ,/ 要/ 测试/ x/ 是否/ 存在/ 于/ 集合/ S/ 中/ ,/ 我们/ 可以/ 检查/ x/ 对应/ 的/ k/ 个/ 比特/ 是否/ 被/ 置/ 为/ “/ 1/ ”/ ./ 如果/ x/ 对应/ 的/ 所有/ k/ 个/ 比特/ 都/ 置/ 为/ “/ 1/ ”/ ,/ 则/ 认为/ 该/ 对象/ 在/ 集合/ S/ 中/ ./ 否则/ ,/ 认为/ 该/ 对象/ 不/ 在/ 集合/ S/ 中/ ./ 比如/ ,/ 对象/ a/ 对应/ 的/ 3/ 个/ 比特/ 全部/ 为/ “/ 1/ ”/ ,/ 则/ 我们/ 判定/ 对象/ a/ 属于/ 对象/ S/ ./ 对象/ d/ 对应/ 的/ 3/ 个/ 比特/ 不全/ 为/ “/ 1/ ”/ ,/ 因此/ 我们/ 判定/ 对象/ d/ 不/ 属于/ 集合/ S/ ./ 必须/ 指出/ ,/ 对/ 不/ 属于/ 集合/ S/ 的/ 对象/ ,/ 布鲁姆/ 过滤器/ 有/ 可能/ 会/ 产生/ 误判/ ./ 比如/ ,/ 假设/ 对象/ e/ 对应/ 着/ 第/ 1/ ,/ 2/ ,/ 4/ 个/ 比特/ ,/ 则/ 布鲁姆/ 过滤器/ 会/ 判断/ 对象/ e/ 属于/ 集合/ S/ ,/ 而/ 实际上/ 集合/ S/ 并/ 不/ 包含/ 对象/ e/ ./ 产生/ 这种/ 错误/ 的/ 概率/ 称为/ 假/ 阳性/ 概率/ (/ falsepositivePage6probability/ )/ ./ 我们/ 将/ 在/ 4.4/ 节/ 讨论/ 假/ 阳性/ 概率/ 对/ 算法/ 的/ 影响/ ./ 4.2/ ./ 2/ 基于/ 虚拟/ 布鲁姆/ 过滤器/ 的/ 存在/ 性/ 测试/ 我们/ 利用/ 标签/ 在/ 一个/ 帧/ 中/ 对/ 阅读器/ 多次/ 回复/ 来/ 模拟/ 布鲁姆/ 过滤器/ 的/ 插入/ 过程/ ,/ 构建/ 一个/ “/ 虚拟/ ”/ 的/ 布鲁姆/ 过滤器/ ./ 利用/ 该/ 虚拟/ 布鲁姆/ 过滤器/ ,/ 来/ 测试/ 一个/ 标签/ 是否/ 存在/ 于/ 某个/ 阅读器/ 的/ 读取/ 范围/ 之内/ ./ 具体步骤/ 如下/ ./ (/ 1/ )/ 后台/ 服务器/ 首先/ 根据/ 所/ 要求/ 的/ 检测/ 概率/ 和/ 每个/ 阅读器/ 范围/ 内/ 的/ 标签/ 数目/ 来/ 计算所/ 需/ 的/ 帧/ 大小/ f/ 和/ 所/ 需/ 的/ Hash/ 函数/ 个数/ k/ (/ 我们/ 将/ 在/ 4.4/ 节/ 讨论/ 如何/ 计算/ 这/ 两个/ 值/ )/ ./ 然后/ ,/ 对/ 每个/ 阅读器/ Ri/ ,/ 后台/ 服务器/ 产生/ k/ 个/ 随机数/ ,/ 并/ 将/ 这/ k/ 个/ 随机数/ 连同/ 帧/ 大小/ f/ 发送给/ 阅读器/ Ri/ ./ 然后/ ,/ 后台/ 服务器/ 计算/ 一个/ 可行/ 的/ 阅读器/ 调度/ 次序/ 来/ 调度/ 各个/ 阅读器/ 依次/ 工作/ ./ 阅读器/ 的/ 调度/ 将/ 在/ 4.3/ 节/ 给出/ ./ (/ 2/ )/ 阅读器/ Ri/ 收到/ 服务器发送/ 来/ 的/ 帧/ 长度/ f/ 和/ k/ 个/ 随机数/ 后/ ,/ 就/ 向/ 标签/ 广播/ 这些/ 参数/ ./ 标签/ 利用/ 收到/ 的/ k/ 个/ 随机数/ ,/ 在/ 帧/ 中/ 随机/ 选择/ k/ 个/ 时隙/ 对/ 阅读器/ 进行/ 回复/ ./ 由于/ 我们/ 只/ 需要/ 知道/ 某个/ 时隙/ 是/ 空/ 还/ 是非/ 空/ ,/ 标签/ 只/ 需要/ 向/ 阅读器/ 发送/ 一个/ 1/ 比特/ 的/ 回复/ 信息/ ./ 阅读器/ 扫描/ 帧/ 中/ 各个/ 时隙/ 的/ 状态/ ,/ 并/ 在/ 此基础/ 上/ 构建/ 一个/ “/ 虚拟/ ”/ 的/ 布鲁姆/ 过滤器/ 如下/ ./ 首先/ ,/ 阅读器/ 产生/ 一个/ 长度/ 为/ f/ 的/ 比特/ 向量/ ,/ 并/ 将/ 其中/ 所有/ 比特/ 初始化/ 为/ “/ 0/ ”/ ./ 然后/ ,/ 根据/ 所/ 收集/ 到/ 的/ 时隙/ 的/ 不同/ 状态/ 来/ 对/ 向量/ 中/ 相应/ 的/ 比特/ 进行/ 置位/ :/ 如果/ 第/ i/ 个/ 时隙/ 是非/ 空/ 时隙/ ,/ 则/ 将/ 向量/ 中/ 的/ 第/ i/ 个/ 比特/ 置/ 为/ “/ 1/ ”/ ;/ 否则/ ,/ 将/ 第/ i/ 个/ 比特/ 置/ 为/ “/ 0/ ”/ ./ 根据/ 4.2/ ./ 1/ 节/ 可知/ ,/ 该/ 向量/ 实际上/ 等同于/ 一个/ 表示/ 该/ 阅读器/ 中/ 所有/ 标签/ 的/ 布鲁姆/ 过滤器/ ./ 由于/ 该/ 布鲁姆/ 过滤器/ 是/ 根据/ 标签/ 的/ 回复/ 虚拟/ 构建/ 的/ ,/ 我们/ 称之为/ “/ 虚拟/ ”/ 布鲁姆/ 过滤器/ ,/ 记为/ BF/ (/ Ri/ )/ ./ 阅读器/ 将/ 构建/ 的/ 虚拟/ 布鲁姆/ 过滤器/ 发回/ 给/ 后台/ 服务器进行/ 存在/ 性/ 测试/ ./ (/ 3/ )/ 后台/ 服务器/ 利用/ 阅读器/ 发送/ 回来/ 的/ 虚拟/ 布鲁姆/ 过滤器/ BF/ (/ Ri/ )/ 来/ 判断/ 标签/ T/ 是否/ 在/ 阅读器/ Ri/ 的/ 读取/ 范围/ 内/ ./ 因为/ 服务器/ 知道/ Ri/ 所用/ 的/ k/ 个/ 随机数/ ,/ 它/ 利用/ 这/ k/ 个/ 随机数/ 和/ 标签/ T/ 的/ 标识号/ 来/ 检测/ T/ 在/ BF/ (/ Ri/ )/ 中/ 对应/ 的/ k/ 个/ 比特/ ./ 如果/ 这/ k/ 个/ 比特/ 都/ 为/ “/ 1/ ”/ ,/ 则/ 认为/ T/ 在/ Ri/ 的/ 读取/ 范围/ 内/ ;/ 否则/ ,/ 认为/ T/ 不/ 在/ Ri/ 的/ 读取/ 范围/ 内/ ./ 4.3/ 多/ 阅读器/ 调度/ 在/ 第/ 2.2/ 节/ 我们/ 介绍/ 了/ 阅读器/ 之间/ 可能/ 存在/ 着/ 冲突/ ./ 当/ 系统/ 中/ 存在/ 多个/ 阅读器/ 时/ ,/ 我们/ 需要/ 对/ 阅读器/ 进行/ 调度/ 来/ 避免/ 阅读器/ 之间/ 的/ 冲突/ ./ 已经/ 有/ 很多/ 工作/ 研究/ 了/ 在/ 多/ 阅读器/ RFID/ 系统/ 中/ 如何/ 对/ 阅读器/ 进行/ 调度/ 来/ 提高/ RFID/ 标签/ 识别/ 的/ 吞吐量/ [/ 20/ -/ 22/ ]/ ./ 这里/ 我们/ 借鉴/ 已有/ 工作/ ,/ 通过/ 将/ 阅读器/ 之间/ 的/ 潜在/ 冲突/ 关系/ 构建/ 成/ 一个/ 冲突/ 图/ ,/ 并/ 通过/ 在/ 该/ 冲突/ 图上/ 利用/ 着色/ 算法/ 来/ 寻找/ 一个/ 可行/ 的/ 阅读器/ 调度/ ./ 具体步骤/ 如下/ :/ (/ 1/ )/ 构建/ 阅读器/ 之间/ 的/ 冲突/ 图/ ./ 基于/ 阅读器/ 集合/ / ,/ 构建/ 冲突/ 图/ G/ =/ 〈/ V/ ,/ E/ 〉/ ,/ 其中/ V/ 中/ 每个/ 顶点/ vi/ 对应/ 阅读器/ Ri/ ,/ 而/ 顶点/ 〈/ vi/ ,/ vj/ 〉/ 之间/ 有/ 边/ 对应/ 阅读器/ Ri/ 和/ 阅读器/ Rj/ 之间/ 存在/ 着/ R/ -/ R/ 冲突/ 或者/ R/ -/ T/ 冲突/ ./ 两个/ 阅读器/ 之间/ 是否/ 存在/ 着/ 冲突/ 可以/ 通过/ 它们/ 之间/ 的/ 距离/ 来/ 判断/ ,/ 或者/ 通过/ 在/ RFID/ 系统/ 的/ 监控/ 范围/ 内/ 进行/ 场景/ 分析/ 得到/ [/ 21/ ]/ ./ (/ 2/ )/ 利用/ 着色/ 算法/ ,/ 为/ 图/ G/ 中/ 的/ 顶点/ 进行/ 着色/ ./ 着色/ 算法/ 为/ 图/ 中/ 每个/ 顶点/ 赋予/ 一个/ 颜色/ ,/ 使得/ 任意/ 相邻/ 的/ 两个/ 顶点/ 的/ 颜色/ 都/ 不/ 相同/ ./ 利用/ 着色/ 算法/ 的/ 结果/ ,/ 我们/ 让/ 同一/ 颜色/ 的/ 阅读器/ 同时/ 工作/ ,/ 而/ 调度/ 不同/ 颜色/ 的/ 阅读器/ 在/ 不同/ 时间/ 工作/ 以/ 避免/ 冲突/ ./ 在/ 这里/ ,/ 我们/ 采用/ DSATUR/ 算法/ ,/ 因为/ 这个/ 算法/ 可以/ 在/ 节点/ 数较/ 多/ 的/ 情况/ 下/ 快速/ 找到/ 一个/ 近似/ 最优/ 的/ 解/ ./ DSATUR/ 的/ 具体/ 介绍/ 请/ 参见/ 文献/ [/ 23/ ]/ ./ 4.4/ 算法/ 性能/ 分析/ 在/ 这/ 一节/ 我们/ 讨论/ 如何/ 为/ 阅读器/ Ri/ 设置/ 帧/ 长度/ f/ 和/ Hash/ 函数/ 个数/ k/ 来/ 满足/ 所/ 要求/ 的/ 检测/ 概率/ ./ 为了/ 便于/ 讨论/ ,/ 我们/ 假设/ 知道/ 阅读器/ Ri/ 读取/ 范围/ 内/ 的/ 标签/ 数目/ ./ 我们/ 将/ 在/ 第/ 5/ 节/ 利用/ 仿真/ 讨论/ 标签/ 数目/ 估计/ 精度/ 对/ 算法/ 性能/ 的/ 影响/ ./ 假设/ 阅读器/ Ri/ 读取/ 范围/ 内/ 共有/ Ni/ 个/ 标签/ ,/ 而/ 帧/ 大小/ 设为/ fi/ ./ 则/ 对/ BF/ (/ Ri/ )/ 中/ 的/ 任意/ 一个/ 比特/ ,/ 该/ 比特/ 被/ 置/ 为/ “/ 0/ ”/ 的/ 概率/ 为/ 而/ 该/ 比特/ 被/ 置/ 为/ “/ 1/ ”/ 的/ 概率/ 为/ 对/ 一个/ 不/ 在/ Ri/ 读取/ 范围/ 内/ 的/ 标签/ T/ 来说/ ,/ 若该/ 标签/ 对应/ 的/ k/ 个/ 比特/ 在/ BF/ (/ Ri/ )/ 中均/ 置/ 为/ “/ 1/ ”/ ,/ 则/ 该/ 标签/ 会/ 被/ 误判/ 为/ 在/ Ri/ 的/ 读取/ 范围/ 内/ ,/ 其/ 概率/ 为/ 而/ 其/ 被/ 正确/ 地/ 判定/ 为/ 不/ 在/ Ri/ 读取/ 范围/ 内/ 的/ 概率/ 为/ 假设/ 系统/ 中共/ 有/ L/ 个/ 阅读器/ ,/ 若/ 一个/ 丢失/ 标签/ 在/ 每个/ 阅读器/ 中/ 都/ 被/ 正确/ 地/ 判定/ 为/ 不/ 在/ 该/ 阅读器/ 范围/ 内/ ,/ 则/ 我们/ 能够/ 成功/ 地/ 检测/ 出该/ 丢失/ 标签/ ,/ 概率/ 为/ (/ 为/ 方便/ 推导/ ,/ 这里/ 我们/ 假设/ 对/ 所有/ 的/ 阅读器/ Ri/ ,/ 其/ 误判/ 概率/ Piw/ 都/ 相同/ 并/ 简记/ 为/ Pw/ )/ Page7/ 可以/ 看出/ ,/ 当/ L/ 值/ 固定/ 时/ ,/ PFP/ 为/ Pw/ 的/ 减/ 函数/ ,/ 其值/ 在/ Pw/ 取/ 最小值/ 时/ 达到/ 最大/ ./ 根据/ 文献/ [/ 4/ ]/ ,/ 当/ Ni/ 和/ fi/ 给/ 定时/ ,/ 存在/ 最优/ 的/ k/ 值/ 使得/ Pw/ 值/ 最小/ :/ 此时/ Pw/ 值为/ 为了/ 达到/ 所/ 需/ 的/ 检测/ 概率/ ,/ 需要/ 将式/ (/ 3/ )/ 代入/ 式/ (/ 8/ )/ ,/ 我们/ 可以/ 得到/ 即/ 阅读器/ Ri/ 的/ 帧/ 长度/ 必须/ 至少/ 为/ Ni/ ×/ log/ / (/ 1/ -/ α/ 1/ // L/ )/ ,/ 此时/ 所/ 需/ 的/ Hash/ 函数/ 个数/ 为/ 可以/ 看出/ ,/ 由式/ (/ 9/ )/ 所/ 确定/ 的/ f/ 值/ 和/ 由式/ (/ 10/ )/ 所/ 确定/ 的/ k/ 值/ 即/ 为/ 相应/ 的/ 帧/ 大小/ 和/ 随机数/ 个数/ 的/ 最优/ 值/ ./ 这是/ 由于/ 若/ 采用/ 更/ 小/ 的/ f/ 值则/ 无法/ 保证/ 所/ 需/ 的/ 检测/ 概率/ ./ 而/ 若/ 采用/ 更大/ 的/ f/ 值/ ,/ 则/ 为了/ 满足/ 所/ 需/ 的/ 检测/ 概率/ 必须/ 相应/ 地/ 增大/ k/ 值/ ,/ 会/ 增加/ 标签/ 的/ 能耗/ (/ 标签/ 发送/ 的/ 数据量/ 恰为/ k/ 比特/ )/ ,/ 同时/ 也/ 会/ 增加/ 算法/ 的/ 执行/ 时间/ ./ 因此/ 在/ 第/ 5/ 节/ 的/ 仿真/ 中/ ,/ 我们/ 利用/ 式/ (/ 9/ )/ 和/ 式/ (/ 10/ )/ 来/ 确定/ 每个/ 阅读器/ 所/ 需/ 的/ 帧/ 大小/ f/ 和/ 随机数/ 个数/ k/ ./ 4.5/ 相关/ 讨论/ 在/ 上/ 一节/ 的/ 分析/ 中/ 我们/ 假设/ 每个/ 阅读器/ 读取/ 范围/ 的/ 标签/ 数目/ 已知/ ./ 而/ 在/ 实际/ 环境/ 中/ ,/ 一个/ 阅读器/ 范围/ 内/ 的/ 标签/ 数目/ 是/ 不能/ 准确/ 得到/ 的/ ./ 我们/ 可以/ 利用/ 已有/ 的/ 标签/ 数目/ 估计/ 算法/ 如/ 文献/ [/ 19/ ]/ 来/ 快速/ 对/ 标签/ 数目/ 进行/ 估计/ ./ 估计/ 算法/ 的/ 精度/ 会/ 影响/ 所提/ 算法/ 的/ 性能/ :/ 当/ 标签/ 数目/ 估计值/ 大于/ 实际/ 值时/ ,/ 丢失/ 标签/ 的/ 检测/ 概率/ 会/ 增加/ ,/ 但是/ 算法/ 的/ 时间/ 开销/ 和/ 通信/ 开销/ 也/ 增加/ ;/ 当/ 标签/ 数目/ 的/ 估计值/ 小于/ 实际/ 标值/ 时/ ,/ 丢失/ 标签/ 的/ 实际/ 检测/ 概率/ 有/ 可能/ 达/ 不到/ 要求/ 的/ 检测/ 概率/ α/ ./ 在/ 第/ 5/ 节中/ 我们/ 基于/ 仿真/ 讨论/ 了/ 标签/ 数目/ 估计/ 误差/ 对/ 所/ 提/ 算法/ 性能/ 的/ 影响/ ./ 结果表明/ ,/ 当/ 估计/ 标签/ 数目/ 大于/ 实际/ 标签/ 数目/ 的/ 90/ %/ 时/ ,/ 算法/ 的/ 检测/ 概率/ 不/ 受/ 影响/ ./ 标签/ 的/ 移动性/ 也/ 会/ 对/ 所/ 提/ 算法/ 的/ 检测/ 概率/ 造成/ 影响/ ./ 实际上/ ,/ 假设/ 在/ 算法/ 执行/ 过程/ 中/ 一个/ 标签/ 从/ 一个/ 阅读器/ 检测/ 范围/ 内/ 移动/ 到/ 另/ 一个/ 阅读器/ 检测/ 范围/ 内/ ,/ 最坏/ 的/ 情况/ 是/ 当/ 这/ 两个/ 阅读器/ 工作/ 时该/ 标签/ 都/ 位于/ 对应/ 的/ 阅读器/ 范围/ 内/ ./ 这种/ 情况/ 其实/ 可以/ 归结/ 于/ 阅读器/ 读取/ 范围/ 内/ 的/ 实际/ 标签/ 个数/ 大于/ 估计值/ ,/ 因此/ 有/ 可能/ 造成/ 检测/ 概率/ 下降/ ./ 然而/ ,/ 当/ 节点/ 移动性/ 较/ 小时/ ,/ 对/ 检测/ 概率/ 造成/ 的/ 影响/ 并/ 不/ 很大/ ./ 如果/ 节点/ 移动/ 速率/ 较大/ ,/ 我们/ 可以/ 通过/ 增大/ 每个/ 阅读器/ 范围/ 内/ 标签/ 数目/ 的/ 估计值/ 来/ 容忍/ 这种/ 情况/ ./ 这会/ 稍稍/ 增加/ 检测时间/ ,/ 但是/ 可以/ 保证/ 所/ 需/ 的/ 检测/ 概率/ ./ 5/ 仿真/ 结果/ 我们/ 进行/ 了/ 仿真/ 来/ 测试/ 所/ 提出/ 算法/ 的/ 性能/ ./ 为了/ 便于/ 描述/ ,/ 我们/ 将/ 所/ 提出/ 的/ 丢失/ 标签/ 检测/ 算法/ 称为/ BMD/ (/ Bloom/ -/ filterbasedMissingtagDetection/ )/ ./ 作为/ 对比/ ,/ 我们/ 实现/ 了/ 基于/ 标签/ ID/ 收集/ 的/ 算法/ (/ 称为/ Collection/ )/ 和/ 目前/ 最好/ 的/ 单/ 阅读器/ 丢失/ 标签/ 检测/ 算法/ IIP/ [/ 11/ ]/ ,/ 并/ 将/ 它们/ 的/ 性能/ 与/ 所/ 提出/ 的/ BMD/ 算法/ 进行/ 比较/ ./ 在/ 计算/ 不同/ 算法/ 的/ 执行/ 时间/ 时/ ,/ 我们/ 采用/ 文献/ [/ 6/ ]/ 中/ 给出/ 的/ 设定/ ./ 我们/ 主要/ 考查/ 算法/ 两/ 方面/ 的/ 性能/ :/ 执行/ 时间/ 和/ 算法/ 过程/ 中/ 标签/ 发送/ // 接收/ 的/ 总/ 数据量/ ,/ 其中/ 后者/ 表示/ 算法/ 执行/ 过程/ 中/ 标签/ 的/ 能量消耗/ ./ 对于/ 可能/ 影响/ 算法/ 性能/ 的/ 参数/ ,/ 我们/ 考虑/ 标签/ 的/ 密度/ 、/ 所/ 期望/ 的/ 检测/ 概率/ 以及/ RFID/ 系统/ 监测/ 的/ 范围/ ./ 在/ 仿真/ 过程/ 中/ ,/ 我们/ 假设/ 如果/ 标签/ 与/ 阅读器/ 之间/ 的/ 距离/ 小于/ 一个/ 给定/ 的/ 读取/ 半径/ r/ ,/ 则/ 标签/ 可以/ 与/ 阅读器/ 通信/ ./ 阅读器/ 之间/ 的/ 冲突/ 情况/ 根据/ 阅读器/ 之间/ 的/ 距离/ 进行/ 确定/ ./ 默认/ 情况/ 下/ ,/ 我们/ 假设/ 所有/ 标签/ 随机/ 均匀分布/ 在/ 一个/ 50m/ ×/ 50m/ 的/ 正方形/ 区域/ 内/ ,/ 阅读器/ 的/ 读取/ 半径/ 设为/ r/ =/ 10m/ ,/ 每个/ 阅读器/ 范围/ 内/ 的/ 平均/ 标签/ 个数/ 为/ 500/ 个/ ,/ 阅读器/ 采用/ 规则/ 的/ 正方形/ 部署/ 模式/ ./ 默认/ 情况/ 下/ ,/ 我们/ 将/ 检测/ 概率/ α/ 设为/ 0.95/ ,/ 假设/ 系统/ 中有/ 1/ %/ 的/ 标签/ 丢失/ ./ 对/ 每组/ 实验/ ,/ 我们/ 重复/ 100/ 次/ 并/ 取/ 其/ 平均值/ 作为/ 结果/ ./ 5.1/ 标签/ 数目/ 估计/ 误差/ 的/ 影响/ 在/ 第/ 4.5/ 节/ 我们/ 提到/ ,/ 每个/ 阅读器/ 读取/ 范围/ 内/ 标签/ 的/ 数目/ 估计/ 误差/ 对/ BMD/ 算法/ 的/ 性能/ 会/ 产生/ 影响/ ./ 定义/ 标签/ 数目/ 估计/ 误差/ η/ 如下/ :/ 其中/ Ni/ 为/ 阅读器/ Ri/ 读取/ 范围/ 内/ 标签/ 数目/ 的/ 估计值/ ,/ 而/ N/ 为/ 标签/ 数目/ 的/ 真实/ 值/ ./ 图/ 4/ 给出/ 了/ 当/ η/ 值/ 在/ [/ -/ 0.2/ ,/ 0.2/ ]/ 之间/ 变化/ 时/ BMD/ 算法/ 的/ 实际/ 检测/ 概率/ 变化/ 情况/ (/ 假设/ 期望/ 检测/ 概率/ α/ =/ 0.95/ )/ ./ 我们/ 可以/ 看出/ ,/ 当/ 标签/ 数目/ 估计值/ 显著/ 小于/ 标签/ 数目/ 真/ Page8/ 实值/ 时/ (/ η/ </ -/ 0.1/ )/ 时/ ,/ 实际/ 检测/ 概率/ 会/ 小于/ 期望/ 检测/ 概率/ ./ 然而/ ,/ 当/ 标签/ 数目/ 估计值/ 接近/ 于/ 或者/ 大于/ 标签/ 数目/ 真实/ 值时/ ,/ 实际/ 检测/ 概率/ 总是/ 大于/ 期望/ 检测/ 概率/ 的/ ./ 目前/ 常用/ 的/ 标签/ 估计/ 算法/ 一般/ 可以/ 达到/ 小于/ 5/ %/ 的/ 误差/ ,/ 因此/ 利用/ 估计/ 的/ 方法/ 来/ 获取/ 标签/ 数目/ 能够/ 达到/ 系统/ 所/ 需/ 的/ 检测/ 概率/ ./ 然而/ ,/ 标签/ 数目/ 估计值/ 并/ 不是/ 越大越/ 好/ ,/ 因为/ 标签/ 数目/ 估计值/ 变/ 大会/ 使/ 算法/ 执行/ 时间/ 增加/ ./ 图/ 4/ 同时/ 给出/ 了/ 当/ η/ 变化/ 时/ 算法/ 执行/ 时间/ 的/ 变化/ 情况/ ./ 从式/ (/ 9/ )/ 可以/ 推论/ 出/ ,/ 算法/ 的/ 执行/ 时间/ 与/ 标签/ 数目/ 的/ 估计值/ 成正比/ ,/ 当/ 标签/ 数目/ 估计值/ 增大/ 时/ ,/ 算法/ 执行/ 时间/ 也/ 增大/ ./ 图/ 4/ 清楚/ 地/ 显示/ 了/ 这/ 一点/ ./ 注意/ 到/ Collection/ 算法/ 和/ IIP/ 算法/ 同样/ 需要/ 知道/ 标签/ 数目/ 的/ 准确/ 估计/ ,/ 在/ 以下/ 的/ 仿真/ 中/ ,/ 我们/ 假设/ 已经/ 知道/ 每个/ 阅读器/ 覆盖范围/ 内/ 标签/ 数目/ 的/ 真实/ 值来/ 比较/ 各个/ 算法/ 的/ 性能/ ./ 5.2/ 期望/ 检测/ 概率/ 的/ 影响/ 图/ 5/ 中/ 给出/ 了/ 当/ 期望/ 检测/ 概率/ α/ 从/ 0.90/ 增加/ 到/ 0.99/ 时/ ,/ 各/ 算法/ 执行/ 时间/ 的/ 变化/ 情况/ ./ 我们/ 可以/ 看出/ ,/ 当/ 期望/ 检测/ 概率/ 增加/ 时/ ,/ BMD/ 算法/ 的/ 执行/ 时间/ 也/ 相应/ 增加/ ./ 当/ α/ 从/ 0.90/ 增加/ 到/ 0.99/ 时/ ,/ 算法/ 的/ 执行/ 时间/ 增加/ 了/ 大约/ 46/ %/ ,/ 从/ 13.8/ s/ 增加/ 到/ 19.8/ s/ ./ Collection/ 算法/ 和/ IIP/ 算法/ 的/ 执行/ 时间/ 不随/ α/ 值/ 改变/ 而/ 变化/ ./ 然而/ ,/ 即使/ 当/ α/ =/ 0.99/ 时/ ,/ BMD/ 算法/ 的/ 执行/ 时间/ 仍/ 显著/ 低于/ 另外/ 两种/ 算法/ ./ 相比/ 于/ Collection/ 算法/ ,/ BMD/ 算法/ 的/ 执行/ 时间/ 平均/ 减少/ 了/ 44/ %/ ,/ 最高/ 减少/ 幅度/ 达/ 52/ %/ ./ 相比/ 于/ IIP/ 算法/ ,/ BMD/ 算法/ 的/ 执行/ 时间/ 平均/ 减少/ 了/ 37/ %/ ,/ 最高/ 达/ 46/ %/ ./ BMD/ 算法/ 更大/ 的/ 优势/ 体现/ 在/ 标签/ 的/ 低/ 通信/ 开销/ 上/ ./ 图/ 6/ 给出/ 了/ 3/ 种/ 算法/ 中/ 每个/ 标签/ 的/ 平均/ 通信/ 开销/ (/ 发送数据/ 量/ 和/ 接收数据/ 量/ 之/ 和/ )/ ./ 可以/ 看出/ ,/ 虽然/ BMD/ 算法/ 的/ 通信/ 开销/ 随着/ α/ 值/ 的/ 增加/ 而/ 略有/ 增加/ ,/ 但是/ 总体而言/ 要/ 比/ 另外/ 两种/ 算法/ 低/ 的/ 多/ ./ BMD/ 算法/ 中/ 每个/ 标签/ 的/ 通信/ 开销/ 要/ 比/ Collection/ 算法/ 低/ 一个/ 数量级/ 以上/ ,/ 比/ IIP/ 算法/ 要/ 低/ 3/ 个/ 数量级/ 以上/ ./ 其/ 原因/ 如下/ ./ 在/ BMD/ 算法/ 中/ ,/ 每个/ 标签/ 仅/ 需要/ 向/ 阅读器/ 发送/ k/ 个/ 比特/ (/ k/ 值/ 通常/ 在/ 10/ ~/ 20/ 之间/ )/ ./ 而/ 在/ Collection/ 算法/ 中/ ,/ 标签/ 需要/ 向/ 阅读器/ 发送/ 自身/ ID/ (/ 通常/ 为/ 96/ 比特/ )/ ./ 由于/ ALOHA/ 协议/ 的/ 效率/ 问题/ ,/ 每个/ 标签/ 平均/ 需要/ 传输/ e/ (/ ≈/ 2.72/ )/ 次/ 才/ 能够/ 被/ 正确/ 识别/ ,/ 因此/ 在/ Collection/ 算法/ 中/ 每个/ 标签/ 的/ 通信/ 开销/ 约/ 在/ 几百个/ 比特/ ./ 而/ 在/ IIP/ 算法/ 中/ ,/ 由于/ 阅读器/ 需要/ 向/ 标签/ 广播/ 多个/ 向量/ ,/ 而/ 向量/ 的/ 长度/ 由/ 系统/ 中/ 标签/ 的/ 总/ 数目/ 决定/ ,/ 因此/ IIP/ 算法/ 的/ 通信/ 开销/ 要/ 比/ Collection/ 算法/ 和/ BMD/ 算法/ 大得多/ ./ 5.3/ 标签/ 密度/ 的/ 影响/ 图/ 7/ 中/ 给出/ 了/ 当/ 每个/ 阅读器/ 覆盖范围/ 内/ 的/ 平均/ 标签/ 数目/ 从/ 500/ 个/ 增加/ 到/ 2000/ 个/ 时/ 不同/ 算法/ 执行/ 时间/ 的/ 变化/ 情况/ ./ 3/ 种/ 算法/ 的/ 执行/ 时间/ 均/ 随着/ 标签/ 密度/ 的/ 增加/ 而/ 增加/ ./ BMD/ 算法/ 的/ 性能/ 最好/ ,/ 相比/ 于/ Collection/ 算法/ 和/ IIP/ 算法/ ,/ 其/ 执行/ 时间/ 分别/ 减少/ 了/ 45/ %/ 和/ 39/ %/ ./ IIP/ 算法/ 的/ 执行/ 时间/ 略/ 小于/ Collection/ 算法/ ./ 图/ 8/ 给出/ 了/ 当/ 标签/ 密度/ 增加/ 时/ 3/ 个/ 算法/ 中/ 每个/ 标签/ 的/ 平均/ 通信/ 开销/ 的/ 对比/ 情况/ ./ 我们/ 可以/ 看到/ ,/ 在/ Page9BMD/ 算法/ 和/ Collection/ 算法/ 中/ 每个/ 标签/ 的/ 通信/ 开销/ 保持/ 不变/ ./ 然而/ ,/ 对于/ IIP/ 算法/ 来说/ ,/ 其/ 通信/ 开销/ 随着/ 标签/ 密度/ 的/ 增加/ 而/ 线性/ 增加/ ./ 这是/ 由于/ 在/ 该/ 算法/ 中/ 阅读器/ 需要/ 向/ 标签/ 广播/ 多个/ 向量/ ,/ 而/ 向量/ 的/ 长度/ 与/ 系统/ 中/ 标签/ 的/ 总/ 数目/ 成正比/ ./ 因此/ ,/ 当/ 标签/ 密度/ 增加/ 时/ ,/ 每个/ 标签/ 所/ 需要/ 接收/ 的/ 数据量/ 随之/ 增加/ ./ 相反/ ,/ 对于/ BMD/ 算法/ 和/ Collection/ 算法/ 来说/ ,/ 通信/ 开销/ 与/ 系统/ 中/ 的/ 标签/ 数目/ 无关/ ./ 从式/ (/ 10/ )/ 也/ 可以/ 看出/ ,/ BMD/ 算法/ 的/ 通信/ 开销/ 仅/ 与/ 阅读器/ 个数/ L/ 和/ 期望/ 检测/ 概率/ α/ 有关/ ./ 5.4/ 系统/ 规模/ 的/ 影响/ 当/ 系统/ 规模/ 增加/ 时/ ,/ 系统/ 中/ 阅读器/ 数目/ 增多/ ,/ 此时/ 根据/ 式/ (/ 9/ )/ 和/ 式/ (/ 10/ )/ 可以/ 看出/ ,/ BMD/ 算法/ 的/ 执行/ 时间/ 和/ 通信/ 开销/ 都/ 会/ 变大/ (/ f/ 和/ k/ 均/ 是/ L/ 的/ 增函数/ )/ ./ 图/ 9/ 给出/ 了/ 当/ 系统/ 规模/ 增大/ 时/ ,/ 3/ 种/ 算法/ 执行/ 时间/ 的/ 变化/ 情况/ ./ 我们/ 可以/ 看到/ ,/ 当/ 系统/ 规模/ 增加/ 时/ ,/ BMD/ 算法/ 的/ 执行/ 时间/ 略有/ 增加/ :/ 当/ 系统监控/ 区域/ 从/ 25r2/ 增加/ 到/ 100r2/ 时/ ,/ 算法/ 执行/ 时间/ 从/ 15.5/ s/ 增加/ 到/ 19.2/ s/ ,/ 增幅/ 约/ 为/ 24/ %/ ./ 然而/ IIP/ 算法/ 的/ 执行/ 时间/ 随着/ 系统/ 规模/ 的/ 扩大/ 而/ 线性/ 增加/ ./ 当/ 系统/ 规模/ 从/ 25r2/ 增加/ 到/ 100r2/ 时/ ,/ IIP/ 算法/ 的/ 执行/ 时间/ 从/ 25.2/ s/ 增加/ 到/ 96s/ ,/ 增加/ 到/ 原来/ 的/ 3.8/ 倍/ ,/ 其/ 性能/ 甚至/ 比/ Collection/ 算法/ 还/ 差得多/ ./ 原因/ 正如/ 前面/ 所/ 分析/ 的/ ,/ 由于/ IIP/ 算法/ 中/ 每轮/ 需要/ 广播/ 多个/ 向量/ ,/ 而/ 向量/ 的/ 长度/ 取决于/ 系统/ 中/ 标签/ 的/ 总数/ ,/ 因此/ IIP/ 算法/ 无法/ 利用/ 阅读器/ 之间/ 的/ 并行性/ 来/ 减少/ 执行/ 时间/ ./ 相反/ ,/ BMD/ 算法/ 和/ Collection/ 算法/ 均/ 可以/ 利用/ 阅读器/ 之间/ 的/ 并行性/ 来/ 有效/ 减少/ 执行/ 时间/ ./ 相比/ 于/ Collection/ 算法/ 和/ IIP/ 算法/ ,/ BMD/ 算法/ 的/ 执行/ 时间/ 分别/ 减少/ 了/ 最高/ 达/ 45/ %/ 和/ 80/ %/ ./ 同样/ ,/ 系统/ 规模/ 的/ 增加/ 也/ 会/ 影响/ BMD/ 算法/ 的/ 通信/ 开销/ ./ 图/ 10/ 给出/ 了/ 当/ 系统/ 规模/ 增加/ 时/ 3/ 种/ 算法/ 中/ 每个/ 标签/ 的/ 平均/ 通信/ 开销/ 对比/ ./ 可以/ 看出/ ,/ BMD/ 算法/ 的/ 通信/ 开销/ 仅仅/ 是/ 略为/ 增加/ ,/ 但是/ 维持/ 在/ 一个/ 较/ 低/ 的/ 水平/ 上/ (/ 从/ 13.6/ 增加/ 到/ 17.3/ )/ ./ 然而/ ,/ IIP/ 算法/ 的/ 通信/ 开销/ 与/ 系统/ 规模/ 成/ 线性/ 增加/ (/ 增加/ 了/ 3/ 倍/ )/ ./ 其/ 原因/ 前面/ 已经/ 分析/ ,/ 在/ 此/ 不再/ 赘述/ ./ Collection/ 算法/ 的/ 通信/ 开销/ 不/ 受/ 系统/ 规模/ 的/ 影响/ ./ BMD/ 算法/ 的/ 通信/ 开销/ 要/ 比/ Collection/ 算法/ 低/ 一个/ 数量级/ ,/ 比/ IIP/ 算法/ 低/ 3/ 个/ 数量级/ ./ 6/ 结论/ 在/ 本文/ 中/ ,/ 针对/ 基于/ 主动式/ 标签/ 构建/ 的/ RFID/ 系统/ ,/ 我们/ 提出/ 了/ 一种/ 基于/ 虚拟/ 布鲁姆/ 过滤器/ 的/ 能量/ 有效/ 的/ 快速/ 丢失/ 标签/ 检测/ 算法/ BMD/ ./ 其/ 核心思想/ Page10/ 是/ 让/ 标签/ 在/ 一个/ 帧/ 内/ 对/ 阅读器/ 进行/ 多次/ 回复/ 来/ 构建/ 虚拟/ 布鲁姆/ 过滤器/ ,/ 并/ 利用/ 布鲁姆/ 过滤器/ 能够/ 高效/ 表示/ 集合/ 从属关系/ 的/ 特性/ 来/ 高效/ 地/ 判断/ 标签/ 是否/ 丢失/ ./ 相比/ 与/ 基于/ 直接/ 收集/ 标签/ 标识号/ 的/ 算法/ 和/ 当前/ 最好/ 的/ 单/ 阅读器/ 丢失/ 标签/ 检测/ 算法/ ,/ BMD/ 算法/ 中/ 标签/ 的/ 平均/ 通信/ 开销/ 销/ 降低/ 了/ 1/ 到/ 3/ 个/ 数量级/ ,/ 因此/ 能/ 极大/ 地/ 降低/ 标签/ 能耗/ ,/ 特别/ 适用/ 于/ 利用/ 内嵌/ 电池/ 供电/ 的/ 主动/ 标签/ ./ 同时/ ,/ BMD/ 算法/ 的/ 检测时间/ 也/ 显著/ 低于/ 这/ 两种/ 算法/ ./ 我们/ 提出/ 的/ 算法/ BMD/ 是/ 一个/ 概率/ 性/ 的/ 算法/ ,/ 并/ 不能/ 保证/ 检测/ 出/ 所有/ 的/ 丢失/ 标签/ ./ 当/ 丢失/ 标签/ 数目/ 较/ 少时/ ,/ 我们/ 可以/ 通过/ 提高/ 检测/ 概率/ 来/ 在/ 绝大多数/ 情况/ 下/ 检测/ 出/ 所有/ 丢失/ 标签/ ./ 在/ 将来/ 工作/ 中/ ,/ 我们/ 将/ 进一步/ 研究/ 如何/ 能够/ 保证/ 确定性/ 地/ 检测/ 出/ 所有/ 丢失/ 标签/ ,/ 并/ 考虑/ 有/ 新/ 标签/ 加入/ 时/ 和/ 标签/ 移动性/ 较/ 高时/ 如何/ 改进/ 算法/ 的/ 性能/ ./ 

