Page1/ 低/ 代价/ 锁步/ EDDI/ :/ 处理器/ 瞬时/ 故障/ 检测/ 机制/ 王超/ 1/ )/ 傅忠传/ 1/ )/ 陈/ 红松/ 2/ )/ 崔刚/ 1/ )/ 1/ )/ (/ 哈尔滨工业大学/ 计算机科学/ 与/ 技术/ 学院/ 哈尔滨/ 150001/ )/ 2/ )/ (/ 北京科技大学/ 计算机/ 与/ 通信/ 工程学院/ 北京/ 100083/ )/ 摘要/ 随着/ ULSI/ 工艺/ 步入/ 深亚/ 微米/ 时代/ ,/ 处理器/ 内部/ 组合/ 逻辑/ 的/ 瞬时/ 故障/ 敏感性/ 迅速/ 提高/ ,/ 文中/ 在/ 设计/ 初期/ 将/ 硬件/ 寄存器/ 纠/ 检错/ 能力/ 和/ 系统软件/ 检错/ 能力/ 纳入/ 考虑/ ,/ 兼顾/ 处理器/ 内/ 组合/ 逻辑/ 、/ 时序/ 逻辑/ 两类/ 部件/ ,/ 设计/ 应用/ 级/ “/ 低/ 代价/ 锁步/ EDDI/ (/ ErrorDetectionbyDuplicatedInstructions/ )/ ”/ 机制/ ./ 创新/ 如下/ :/ (/ 1/ )/ 提出/ 基于/ 概率论/ 的/ 故障/ 漏检/ 率/ 量化/ 估计/ 方法/ ,/ 为/ 纠/ 检错/ 与/ 性能/ 折中/ 进行/ 指导/ ./ 以往/ 的/ 应用/ 级/ 检错/ 机制/ 在/ 设计/ 过程/ 中/ 并/ 没有/ 考虑/ 到/ 下层/ 操作系统/ 的/ 检错/ 能力/ ,/ 这会/ 造成/ 可靠性/ 估计不足/ 而/ 带来/ 性能/ 损失/ ./ 文中/ 依照/ 指令/ 流经/ 的/ 部件/ 将/ 故障/ 划分/ 为/ 不同/ 子类/ ,/ 并/ 将/ 操作系统/ 纳入/ 考虑/ ,/ 提出/ 基于/ 概率论/ 的/ 故障/ 漏检/ 率/ 量化/ 估计/ 方法/ ,/ 理论/ 估计/ 与/ 故障注入/ 结果/ 拟合/ 良好/ ./ (/ 2/ )/ 低/ 代价/ 锁步/ EDDI/ 机制/ ,/ 结合/ 硬件/ 纠/ 检错/ 能力/ ,/ 兼顾/ 处理器/ 内/ 组合/ 逻辑/ 和/ 时序/ 逻辑/ 两类/ 部件/ ,/ 大幅/ 降低/ 了/ 性能/ 代价/ ./ 提出/ 独特/ 的/ 低/ 代价/ 锁步/ 指令/ 复制/ 规则/ ,/ 并/ 通过/ 编译/ 链/ 前端/ 的/ 寄存器/ 分配/ ,/ 大幅/ 减少/ 了/ 寄存器/ 预留/ 数/ ,/ 有效/ 缓解/ 了/ 寄存器/ 压力/ ,/ 降低/ 了/ 访存/ 代价/ ,/ 提高/ 了/ 寄存器/ 的/ 性能/ ./ 寄存器/ 预留/ 也/ 保证/ 了/ 本/ 机制/ 无需/ 修改/ 编译器/ 传参/ 规则/ ,/ 无需/ 重新/ 编译系统/ 库/ ,/ 提高/ 了/ 通用性/ ./ (/ 3/ )/ 采用/ 单/ 比特/ 故障/ 模型/ ,/ 基于/ SPARC/ 体系结构/ ,/ 选取/ 处理器/ 中/ 代表性/ 部件/ :/ 解码/ (/ DecoderUnit/ )/ 单元/ 、/ 地址/ 生成/ (/ AddressGENUnit/ )/ 单元/ 、/ 算逻/ 单元/ (/ ALU/ )/ 进行/ 故障注入/ ,/ 对/ 低/ 代价/ 锁步/ EDDI/ 实现/ 代价/ 进行/ 详细/ 评测/ ./ 与/ 全/ 复制/ EDDI/ 相比/ ,/ 低/ 代价/ 锁步/ EDDI/ 仅以/ 故障/ 漏检/ 率/ SDC/ (/ SilentDataCorruption/ )/ 平均/ 升高/ 0.8/ %/ 的/ 代价/ ,/ 换取/ 了/ 动态/ 执行/ 指令/ 数/ 平均/ 减少/ 36.1/ %/ ,/ 执行/ 时间/ 平均/ 降低/ 35.2/ %/ 的/ 性能/ 优势/ ./ 关键词/ EDDI/ ;/ 故障/ 漏检/ 率/ ;/ 组合/ 逻辑/ ;/ 瞬时/ 故障/ ;/ SEU1/ 引言/ 瞬时/ 故障/ (/ transientfault/ )/ ,/ 常/ 被/ 称为/ 软故障/ (/ softerror/ )/ ,/ 主要/ 由/ 宇宙射线/ 和/ 封装/ 中/ 的/ α/ 粒子/ 引发/ ,/ 通常/ 导致/ 器件/ 暂时性/ 失效/ 或/ 状态/ 改变/ ,/ 不会/ 产生/ 物理/ 性/ 损伤/ ./ 瞬时/ 故障/ 对于/ 组合/ 电路/ 和/ 时序电路/ 的/ 影响/ 有所不同/ ./ α/ 粒子/ 或/ 宇宙射线/ 进入/ 内存/ 单元/ 或/ 动态/ 寄存器/ ,/ 引发/ 比特/ 翻转/ (/ bit/ -/ flip/ )/ 或/ 不/ 确定/ 故障/ (/ indeterminationfault/ )/ ,/ 一经/ 锁存/ 就/ 会/ 持续/ 到/ 重新/ 写入/ 或/ 刷新/ ./ 除此之外/ ,/ 还会/ 诱发/ 组合/ 逻辑/ 产生/ 干扰/ 脉冲/ [/ 1/ ]/ ./ 组合/ 逻辑/ 对/ 此类/ 脉冲/ 虽/ 有/ 屏蔽/ 能力/ ,/ 但/ 随着/ 特征/ 尺寸/ 的/ 缩小/ 、/ 供电/ 电压/ 的/ 降低/ 和/ 工作频率/ 的/ 提升/ ,/ 故障/ 易感性/ 将/ 越发/ 提升/ ./ 文献/ [/ 2/ ]/ 预计/ 2011/ 年/ 组合/ 逻辑/ 故障/ 易感性/ 将会/ 与/ 时序/ 逻辑/ 持平/ ,/ 之后/ 将/ 超过/ 后者/ ./ 瞬时/ 故障/ 并非/ 由/ 设备/ 内因/ 引起/ ,/ 受/ 环境因素/ 影响/ 较大/ ,/ 具有/ 随机性/ ,/ 这/ 无疑/ 对/ 诊断/ 提出/ 了/ 挑战/ ./ 2000/ 年/ 美国在线/ 和/ ebay/ 曾/ 暂停/ 服务/ ,/ 原因/ 在于/ 所/ 使用/ 的/ UltraSPARC/ -/ II/ 服务器/ 中/ 的/ SRAM/ 对/ 瞬时/ 故障/ 防护/ 不足/ [/ 3/ ]/ ./ 2005/ 年/ LosAlamos/ 国家/ 实验室/ 一台/ 2048/ -/ CPU/ 的/ 惠普/ 超级计算机/ 因/ 太空/ 辐射/ 引发/ 的/ 软故障/ 频繁/ 崩溃/ ./ Cypress/ 半导体/ 公司/ 也/ 在/ 2004/ 年/ 公布/ 了/ 一系列/ 瞬时/ 故障/ 事件/ [/ 4/ ]/ ./ 目前/ ,/ 硬件/ 提供/ 的/ 瞬时/ 故障/ 纠/ 检错/ 机制/ 主要/ 有/ ECC/ 、/ 校验/ 和/ ./ 该类/ 方法/ 对/ 时序/ 逻辑/ 瞬时/ 故障/ 行之有效/ ,/ 却/ 无法/ 覆盖/ 组合/ 逻辑/ ./ 高端/ 机型/ 一般/ 采用/ 多模/ 冗余/ 或多机/ 备份/ 的/ 方式/ 对/ 组合/ 逻辑/ 进行/ 保护/ ,/ 如/ 惠普/ 的/ non/ -/ stop/ [/ 5/ ]/ 、/ IBM/ 高端/ 大型机/ [/ 6/ ]/ ./ 但/ 硬件/ 代价/ 是/ 一般/ 商用机/ 型/ 无法/ 承受/ 的/ ./ 在/ 这个/ 方面/ ,/ 软件/ 冗余/ 以/ 其/ 灵活性/ 和/ 低/ 硬件/ 代价/ 的/ 特点/ 格外/ 具备/ 竞争力/ ./ 软件/ 冗余/ 一般/ 通过/ 在/ 编译/ 的/ 前/ 、/ 后/ 端/ 增加/ 组件/ 自动/ 实现/ 冗余/ 功能/ ./ 主要/ 包括/ 增加/ 控制流/ 软件/ 签名/ 、/ 复制/ 指令/ 备份/ 数据/ 以及/ 软件/ EDAC/ 等/ 方式/ ./ 实现/ 的/ 过程/ 中/ ,/ 处处/ 存在/ 着/ 可靠性/ 与/ 性能/ 的/ 折中/ ,/ 例如/ 软件/ 签名/ 代价/ 较/ 低/ 但是/ 只/ 对/ 控制流/ 有效/ ,/ 指令/ 复制/ 会/ 导致/ 内存/ 占用/ 翻倍/ ,/ 访存/ 代价/ 过/ 高等/ ./ 不同/ 体系结构/ 下/ ,/ EDDI/ 机制/ 的/ 移植/ 工作/ 也/ 存在/ 亟待解决/ 的/ 问题/ ./ 例如/ ,/ SPARC/ 属/ 窗口/ 寄存器/ 体系结构/ ,/ 具有/ 独特/ 的/ 寄存器/ 环/ 结构/ ,/ 这/ 与/ 在/ ARM/ 、/ MIPS/ 等/ 平面/ 寄存器/ 体系结构/ 下/ 的/ 移植/ 工作/ 相比/ ,/ 机制/ 的/ 移植/ 工作/ 面临/ 完全/ 不同/ 的/ 问题/ 与/ 挑战/ ./ 例如/ ,/ 编译器/ 传参/ 规则/ 的/ 修改/ ,/ 系统/ 库/ 的/ 重新/ 编译/ 等/ 工作/ ,/ 严重/ 降低/ 了/ 机制/ 的/ 通用性/ ./ Page3/ 基于/ 以上/ 分析/ ,/ 本文/ 提出/ 了/ 一种/ 软硬件/ 混合/ 的/ 冗余/ 方式/ —/ —/ —/ 低/ 代价/ 锁步/ EDDI/ 机制/ ./ 期望/ 最大化/ 利用/ 普遍/ 使用/ 的/ 硬件/ 纠/ 检错/ 机制/ ,/ 同时/ 将/ 处于/ 应用层/ 之下/ 的/ 系统软件/ 纠/ 检错/ 能力/ (/ 如段/ 越界/ 检查/ 、/ 非法/ 指令/ 检查/ 等/ )/ 纳入/ 考虑/ ,/ 对/ 指令/ 复制/ 机制/ 进行/ 裁剪/ 和/ 设计/ ,/ 以/ 达到/ 整个/ 系统/ 的/ 可靠性/ 与/ 性能/ 高效/ 结合/ ./ 本/ 机制/ 主/ 指令/ 与/ 影子/ 指令/ 以锁步/ (/ lock/ -/ stepped/ )/ 方式/ 执行/ ,/ 以/ 编译/ 选项/ 的/ 形式/ 集成/ 在/ 编译/ 链后/ 端/ ,/ 创新/ 如下/ :/ (/ 1/ )/ 本文/ 依照/ 指令/ 流经/ 的/ 部件/ 将/ 故障/ 划分/ 为/ 不同/ 子类/ ,/ 经过/ 对/ 每/ 种子/ 类/ 故障/ 详细分析/ 给出/ 基于/ 概率论/ 的/ 故障/ 覆盖率/ 量化/ 估计/ 方法/ ,/ 为/ 故障/ 覆盖率/ 与/ 性能/ 的/ 折中/ 提出/ 指导/ ./ 经/ 实验/ 验证/ ,/ 理论/ 估计/ 与/ 故障注入/ 结果/ 拟合/ 良好/ ./ (/ 2/ )/ 以往/ 的/ 应用/ 级/ 检错/ 机制/ 在/ 设计/ 过程/ 中/ 并/ 没有/ 考虑/ 到/ 下层/ 操作系统/ 的/ 检错/ 能力/ ,/ 这/ 通常/ 会/ 造成/ 可靠性/ 估计不足/ 而/ 带来/ 性能/ 损失/ ./ 在/ 本/ 机制/ 设计/ 初期/ 将/ 操作系统/ 因素/ 纳入/ 考虑/ ./ (/ 3/ )/ 提出/ 低/ 代价/ 锁步/ 的/ 指令/ 复制/ 规则/ 和/ 寄存器/ 分配/ 方式/ ./ 锁步/ 规则/ 结合/ 硬件/ 纠/ 检错/ 机制/ ,/ 既/ 兼顾/ 组合/ 逻辑/ 、/ 时序/ 逻辑/ 两类/ 部件/ ,/ 又/ 大幅/ 降低/ 了/ 性能/ 代价/ ./ 同时/ ,/ 编译/ 前端/ 实现/ 的/ 寄存器/ 分配/ 方式/ ,/ 大幅/ 减少/ 了/ 寄存器/ 预留/ 数/ 、/ 有效/ 缓解/ 寄存器/ 压力/ ,/ 降低/ 了/ 访存/ 代价/ ./ 寄存器/ 预留/ 机制/ 的/ 引入/ 也/ 保证/ 了/ 机制/ 实现/ 无需/ 修改/ 编译器/ 传参/ 规则/ ,/ 无需/ 重新/ 编译系统/ 库/ ,/ 提高/ 了/ 本/ 机制/ 的/ 通用性/ ./ (/ 4/ )/ 实验/ 验证/ 阶段/ ,/ 选择/ 单/ 比特/ 故障/ 模型/ ,/ 在/ SPARC/ 体系结构/ 平台/ ,/ 选取/ 处理器/ 中/ 代表性/ 部件/ :/ 解码/ (/ DecoderUnit/ )/ 单元/ 、/ 地址/ 生成/ (/ AddressGENUnit/ )/ 单元/ 和/ 算/ 逻/ 单元/ (/ ALU/ )/ 进行/ 故障注入/ ./ 本文/ 第/ 2/ 节/ 介绍/ 国内外/ 相关/ 工作/ ;/ 第/ 3/ 节/ 阐述/ 故障/ 覆盖率/ 理论/ 估计/ 方法/ ;/ 第/ 4/ 节对/ 低/ 代价/ 锁步/ EDDI/ 机制/ 进行/ 描述/ ;/ 第/ 5/ 节/ 介绍/ 故障注入/ 实验/ 和/ 性能/ 测试/ 并/ 对/ 结果/ 进行/ 分析/ ;/ 最后/ 得出结论/ ./ 2/ 相关/ 工作/ SIHFT/ (/ SoftwareImplementedHardwareFaultTolerance/ )/ 采用/ 软件/ 手段/ 实现/ 硬件/ 故障/ 容错/ ,/ 源于/ 美国斯坦福大学/ ,/ 并于/ 1999/ 年/ 进行/ 星载/ 实验/ ,/ 引起/ 广泛/ 关注/ [/ 7/ -/ 9/ ]/ ./ SIHFT/ 包括/ 多种/ 技术/ :/ 针对/ 存储系统/ 故障/ 提出/ 的/ 软件/ EDAC/ ,/ 针对/ 处理器/ 内/ 瞬时/ 故障/ 引发/ 控制流/ 错误/ 的/ CFCSS/ (/ ControlFlowCheckingbySoftwareSignatures/ )/ 、/ 针对/ 引发/ 的/ 数据流/ 错误/ 的/ EDDI/ (/ ErrorDetectionbyDuplicatedInstructions/ )/ 技术/ 以及/ 针对/ 永久/ 故障/ 的/ ED4I/ [/ 10/ -/ 13/ ]/ 等/ ./ 国内外/ 本/ 领域/ 的/ 相关/ 工作/ 一直/ 较为/ 活跃/ ./ 普林斯/ 敦/ 大学/ 提出/ 了/ SWIFT/ (/ SoftwareImplementedFaultTolerance/ )/ 来/ 检测/ 处理器/ 内/ 发生/ 的/ 数据流/ 错误/ 与/ 控制流/ 错误/ ,/ 并/ 设计/ 相关/ 优化/ 策略/ [/ 14/ ]/ ./ 法国/ TIMA/ 实验室/ 提出/ 具有/ 全/ 覆盖/ 能力/ 的/ DSM/ 检错/ 技术/ [/ 15/ ]/ ./ 近年来/ 国内/ 多个/ 课题组/ 对此/ 展开/ 跟踪/ 研究/ [/ 16/ -/ 19/ ]/ ./ EDDI/ // CFCSS/ // ED4I/ 等/ 技术/ 通常/ 在/ 编译/ 链后/ 端/ 实现/ ,/ 与/ 体系结构/ 和/ ISA/ 紧密/ 相关/ ,/ 可移植性/ 受到/ 制约/ ./ Yu/ 等/ 人/ [/ 20/ ]/ 基于/ LLVM/ 编译/ 工具/ 链/ ,/ 在/ SSA/ 高级/ 中间代码/ 表示/ 级别/ 对/ 应用/ 进行/ 加固/ ,/ 并/ 提出/ 多种/ 优化/ 机制/ 降低/ 实现/ 代价/ ,/ 成功/ 解决/ 了/ 可移植性/ 问题/ ./ 但是/ ,/ 该/ 方法/ 与/ 编译/ 链/ 前端/ 耦合/ 紧密/ ,/ 开发周期/ 长/ ,/ 且/ 随/ 编译器/ 不同/ 版本/ 的/ 发布/ ,/ 需/ 频繁/ 修改/ ./ 3/ 可靠性/ 理论/ 估计/ 提出/ 锁步/ 机制/ 目的/ 在于/ 追求/ 整体/ 故障/ 检测/ 能力/ 最大化/ ,/ 同时/ 将/ 机制/ 间/ 故障/ 覆盖/ 能力/ 的/ 重叠/ 降到/ 最低/ ,/ 以此/ 降低/ 性能/ 代价/ ./ 为/ 实现/ 这个/ 目标/ ,/ 需要/ 综合/ 考虑/ 操作系统/ 、/ 固件/ 以及/ 硬件/ 具备/ 的/ 故障/ 检测/ 能力/ ,/ 并/ 在/ 此基础/ 上/ 设计/ 指令/ 复制/ 规则/ ./ 本节/ 提出/ 了/ 基于/ 概率论/ 的/ 故障/ 覆盖率/ 估计/ 方法/ ,/ 用于/ 指导/ 故障/ 覆盖率/ 与/ 性能/ 的/ 折中/ 策略/ ./ 本文/ 主要/ 针对/ 处理器/ 内/ 瞬时/ 故障/ ,/ 故障/ 发生/ 后/ ,/ 经/ 微结构/ 级/ 、/ 结构/ 级/ 蔓延/ ,/ 传播/ 至/ 操作系统/ ,/ 最终/ 在/ 应用层/ 外显/ ./ 故障/ 的/ 传播/ 路径/ 涵盖/ 多个/ 层级/ ,/ 各/ 层级/ 的/ 特点/ 决定/ 了/ 它们/ 在/ 故障/ 纠/ 检错/ 方面/ 的/ 不同/ 角色/ ./ 据此/ ,/ 本文/ 采用/ 面向/ 部件/ 的/ 故障/ 分类/ 方法/ ,/ 以/ 紧密结合/ 耦合/ 路径/ 的/ 故障/ 覆盖/ 特性/ 对/ 覆盖率/ 进行/ 准确/ 估计/ ./ 本文/ 选择/ 了/ 单/ 比特/ 故障/ 模型/ ,/ 并/ 以/ SPARCV9/ 指令集/ 为例/ 进行/ 验证/ ,/ 本文/ 方法/ 适用/ 于/ 所有/ RISC/ 指令集/ ./ 3.1/ 故障/ 分类/ 首先/ ,/ 将/ 指令集/ 分为/ 计算/ 指令/ (/ computationalinstruction/ )/ 、/ 访存/ 指令/ (/ memoryaccessinstruction/ )/ 、/ 跳转/ 指令/ (/ branchinstruction/ )/ 和/ 其它/ 类/ 指令/ (/ otherinstruction/ )/ ./ 其中/ ,/ 计算/ 指令/ 包括/ 所有/ 算术/ 运算/ 、/ 逻辑关系/ 运算/ 和/ 赋值/ 指令/ ./ 访存/ 指令/ 包括/ 取数/ 、/ 存数/ 和/ 内存/ 栅栏/ 指令/ ./ 跳转/ 指令/ 包括/ 无/ // 有/ 条件/ 跳转/ 和/ 函数调用/ (/ call/ )/ 指令/ ./ 其它/ 类/ 指令/ 是/ 除了/ 计算/ 指令/ 、/ 访存/ 指令/ 、/ 跳转/ 指令/ 以外/ 的/ 指令/ 集合/ ,/ 同时/ 为/ 涵盖/ 故障/ 引/ Page4/ 发/ 的/ 正常/ 指令/ 转为/ 非法/ 指令/ 的/ 情况/ ,/ 此处/ 将/ 非法/ 指令/ 纳入/ 其它/ 类/ 指令/ 中/ ./ 每种/ 指令/ 发生/ 的/ 故障/ 仅/ 包括/ 两种/ 情况/ :/ 操作码/ 故障/ 和/ 操作数/ 故障/ ./ 据此/ ,/ 将/ 故障/ 类型/ 细分/ 为/ 14/ 子类/ ,/ 基于/ SPARCV9/ 的/ 指令/ 分类/ 及/ 故障/ 类型/ 详见/ 表/ 1/ ./ 表中/ 各/ 故障/ 类型/ 发生/ 概率/ 由/ 故障/ 源/ 所在/ 部件/ 和/ 指令集/ 编码/ 决定/ ,/ 例如/ ,/ 解码/ 部件/ 故障/ 涵盖/ 全部/ 类型/ ./ 但是/ 同/ 类型/ (/ C/ →/ C/ 、/ M/ →/ M/ 、/ B/ →/ B/ 和/ OT/ →/ OT/ )/ 转化/ 概率/ 明显/ 高于/ 类型/ 间/ 转化/ ,/ 这/ 一点/ 由图/ 1/ 给出/ 的/ 指令集/ 编码/ 可知/ ./ 类别/ 符号/ 指令/ 类型/ 故障/ 类型/ 计算/ 指令/ C/ 访存/ 指令/ M/ 跳转/ 指令/ B/ 其它/ 指令/ OT/ 如果/ 故障/ 源自/ 算逻/ 部件/ ,/ 只/ 可能/ 触发/ C/ →/ C/ 一类/ ,/ 发生/ 概率/ 为/ 100/ %/ ./ 由此可知/ 同/ 类型/ 故障/ 能否/ 良好/ 覆盖/ ,/ 对系统/ 的/ 纠/ 检错/ 能力/ 起/ 关键作用/ ,/ 因此/ 在/ 表/ 1/ 中/ 重点/ 标示/ ./ 3.2/ 故障/ 模型/ 瞬时/ 故障/ 在/ 组合/ 逻辑/ 诱发/ 后/ ,/ 在/ 多级/ 逻辑/ 门/ 传输/ 路径/ 中/ 蔓延/ ,/ 被/ 微结构/ 级/ (/ 锁/ 存器/ 、/ 触发器/ )/ 时间/ 窗口/ 捕获/ 后/ ,/ 通常/ 导致/ 多/ 比特/ 故障/ ./ 但/ 我们/ 采用/ 微结构/ 级单/ 比特/ 故障/ 模型/ ,/ 主要/ 因为/ :/ (/ 1/ )/ 目前/ 尚无/ 统一/ 的/ 多/ 比特/ 故障/ 模型/ ./ 因为/ 故障/ 传播/ 特性/ 与/ 设计/ 细节/ ,/ 如/ 结构/ // 微结构/ 级/ 、/ 门级/ ,/ 乃至/ 设备/ 级/ ,/ 耦合/ 紧密/ ;/ (/ 2/ )/ 由于/ 多/ 比特/ 模型/ 增大/ 了/ 出错/ 的/ 概率/ ,/ 实验/ 中会/ 更/ 容易/ 被/ 容错/ 机制/ (/ 如/ EDDI/ 机制/ )/ 检测/ 到/ ,/ 从而/ 导/ 地址/ 生成/ 部件/ 地址/ 生成/ 部件/ 计算/ 得出/ 当前/ 指令/ 和/ 下条/ 指令/ 地址/ (/ PC/ // NPC/ )/ ,/ 由取/ 指/ 逻辑/ 访存/ 将/ 指令/ 取回/ ./ 该/ 部件/ 属/ 组合/ 逻辑/ 部件/ ,/ 故障/ 触发/ 将/ 直接/ 影响/ PC/ // NPC/ ,/ 发生/ 概率/ 为/ 100/ %/ ./ 此类/ 故障/ 引发/ 控制流/ 错误/ ,/ 包括/ C/ →/ B/ 、/ M/ →/ B/ 、/ B/ →/ B/ 和/ OT/ →/ B/ 类型/ ./ 这/ 也/ 是/ 指令/ 复制/ 类/ 容错/ 机制/ 覆盖/ 能力/ 相对/ 薄弱/ 的/ 方面/ ./ 然而/ ,/ 操作系统/ 对此/ 提供/ 了/ 强大/ 覆盖/ 能力/ (/ 具体/ 数据/ 见/ 5.2/ 节/ )/ ./ 地址/ 翻转/ 发生/ 在/ 低位/ ,/ 会/ 导致/ 字/ 未/ 对齐/ ,/ 引发/ 总线/ 故障/ ;/ 发生/ 在/ 高位/ ,/ 通常/ 造成/ 段/ 越界/ 访问/ ,/ 引发/ 段/ 错误/ ./ 对于/ 后者/ ,/ 具体/ 的/ 故障/ 覆盖/ 能力/ 取决于/ 程序/ 规模/ ./ 这些/ 现象/ 在/ 故障注入/ 过程/ 中/ 表现/ 十分/ 明显/ ./ 解码/ 部件/ 解码/ 部件/ 负责/ 解析/ 存放/ 于/ 指令/ 队列/ 中/ ,/ 等待/ 进入/ 流水/ 的/ 指令/ 操作码/ ./ 解码/ 完成/ 后/ 负责/ 将/ 生成/ 的/ 控制/ 信号/ 送到/ 相关/ 执行/ 部件/ ,/ 如算逻/ 单元/ ./ 该/ 部件/ 故障/ 包括/ 全部/ 14/ 种/ 类型/ ./ 由/ 计算/ 指令/ 引发/ 的/ 4/ 种/ 类型/ ,/ 发生/ 概率/ 最大/ 的/ 是/ C/ →/ C/ ,/ 该类/ 故障/ 无法/ 由/ 硬件/ 和/ 操作系统/ 覆盖/ ,/ 因此/ 需要/ 在/ 机制/ 中将/ 计算/ 指令/ 复制/ 和/ 锁步/ 比较/ ./ 其余/ 10/ 类/ 故障/ 经/ 估计/ 和/ 实验/ 验证/ ,/ 会以/ 较/ 高/ 概率/ 被/ 操作系统/ 捕获/ (/ 具体/ 数据/ 见/ 5.2/ 节/ )/ ./ 如对/ 剩余/ 部分/ 有/ 覆盖/ 要求/ ,/ 则/ 需/ 复制/ 全部/ 指令/ ,/ 完全/ 拷贝/ 数据/ 段/ 、/ 堆栈/ 段/ 等/ 程序/ 信息/ ./ 而/ 在/ 程序/ 实际/ 执行/ 过程/ 中/ 相当/ 一部分/ 不会/ 被/ 执行/ 到/ ,/ 却会/ 造成/ 访存/ 次数/ 增多/ 、/ 执行/ 时间/ 增长/ 、/ 内存空间/ 浪费/ 等/ 后果/ ./ 关于/ 覆盖率/ 与/ 性能/ 折中/ 的/ 详细分析/ 见/ 5.2/ 、/ 5.3/ 节/ ./ 致过/ 高地/ 估计/ 容错/ 机制/ 带来/ 的/ 可靠性/ 提高/ ./ 出于/ 对/ 用户/ 负责/ 的/ 角度/ ,/ 我们/ 有/ 理由/ 选择/ 后者/ ./ 单/ 比特/ 模型/ 假设/ 系统/ 同一/ 时刻/ 只/ 触发/ 一次/ 瞬时/ 故障/ ,/ 故障/ 经/ 传播/ 到达/ 微结构/ // 结构/ 级/ 引发/ 单/ 比特/ 翻转/ ./ 不同/ 部件/ 发生/ 故障/ 的/ 概率/ 依/ 部件/ 复杂度/ 服从/ 均匀分布/ (/ 本文/ 假设/ 各/ 部件/ 单/ 比特/ 故障/ 触发/ 概率/ 相等/ )/ ./ 3.3/ 部件/ 模型/ 算逻/ 单元/ 计算/ 指令/ 经/ 复制/ 、/ 锁步/ 比较/ ,/ 绝大多数/ 会/ 被/ 覆盖/ ./ 但/ 需要/ 指出/ ,/ 有/ 一类/ 计算/ 指令/ 引入/ 的/ 比较/ 指令/ 无法/ 覆盖/ ,/ 否则/ 会/ 引发/ 循环/ 锁步/ 的/ 情况/ ./ 寄存器/ 文件/ 本文/ 假设/ 寄存器/ 文件/ 有/ ECC/ 或/ 校验/ 和/ 保护/ ,/ 在/ 该/ 部件/ 触发/ 的/ 单/ 比特/ 故障/ 都/ 会/ 被/ 检出/ ,/ 即/ 系统对/ 寄存器/ 文件/ 的/ 故障/ 漏检/ 率为/ 0/ ./ 因此/ ,/ 有/ 理由/ 在/ 后续/ 实验/ 中/ 省去/ 对/ 该/ 部件/ 的/ 故障注入/ ,/ 直接/ 将/ 其/ 故障/ 漏检/ Page5/ 基于/ 上述/ 指令/ 分类/ 和/ 详细/ 的/ 部件/ 分析/ ,/ 下面/ 进率/ 带入/ 统计/ ./ 其它/ 部件/ 其它/ 部件/ ,/ 如/ 处理器/ 核外/ 的/ 各级/ 缓存/ 、/ 内存/ 以及/ 这些/ 部件/ 间/ 的/ 关键/ 数据通路/ 、/ 胶合/ 逻辑/ ,/ 它们/ 的/ 物理/ 实现/ 一般/ 配有/ 不同/ 的/ 校验/ 机制/ ./ 虽然/ 无法/ 保证/ 这些/ 部件/ 的/ 原发性/ 故障/ 都/ 被/ 检出/ ,/ 但是/ 对/ 这些/ 部件/ 的/ 瞬时/ 故障/ 易感性/ 与/ 性能/ 、/ 功耗/ 的/ 折中/ 具有/ 显著/ 、/ 积极/ 的/ 作用/ [/ 20/ ]/ ./ 由于/ 处理器/ 外/ 的/ 部件/ 故障/ 不属/ 本文/ 的/ 研究/ 范围/ ,/ 因此/ ,/ 本文/ 假设/ 核外/ 的/ 各级/ 缓存/ 、/ 内存/ 与/ 之间/ 的/ 胶合/ 逻辑/ 是/ 无故障/ 的/ ./ 至于/ 从/ 处理器/ 流出/ 的/ 漏检/ 指令/ 或者/ 数据/ ,/ 可/ 归类/ 到/ 以上/ 几个/ 部件/ 触发/ 的/ 故障/ 类型/ 中/ ./ 3.4/ 估计/ 方法/ 行/ 理论/ 估计/ ./ 我们/ 将/ A/ 类/ 指令/ 由于/ 单/ 比特/ 翻转/ 而/ 转变/ 为/ B/ 类/ 指令/ ,/ 定义/ 为/ A/ →/ B/ 类/ 故障/ ,/ 其中/ A/ 和/ B/ 可能/ 为/ 同类/ 指令/ ./ n/ 表示/ 故障/ 类型/ 总数/ ,/ m/ 表示/ 故障/ 部件/ 总数/ ,/ 故障/ 发生/ 在/ 部件/ j/ 的/ 事件/ 用/ Uj/ 表示/ ,/ Y/ 表示/ 故障/ 漏检/ 事件/ ./ SDC/ (/ SilentDataCorruption/ )/ 表示/ 故障/ 未/ 被/ 硬件/ 、/ 操作系统/ 和/ EDDI/ 机制/ 检测/ 到/ ,/ 并且/ 最终/ 导致/ 程序/ 错误/ 的/ 故障/ 比例/ ./ 则/ P/ (/ SDC/ )/ =/ ∑/ mP/ (/ SDCj/ |/ Uj/ )/ =/ δ/ j/ ×/ P/ (/ Y/ |/ Uj/ )/ ,/ δ/ j/ =/ NSDCjNSDCj/ +/ NCRj/ 其中/ ,/ NSDCj/ 为/ 测试/ 基准/ 中/ 结果/ 为/ SDC/ 的/ 总数/ ,/ NCRj/ 为/ 测试/ 基准/ 中/ 出现/ 正确/ 结果/ 的/ 总数/ ./ 解码/ 部件/ 故障/ 漏检/ 率/ 估计/ 用/ Xi/ 表示/ 发生/ 于/ 解码/ 部件/ 的/ 第/ i/ 类/ 故障/ 事件/ ,/ 则/ P/ (/ Y/ |/ Uj/ )/ =/ ∑/ n/ 如果/ 用/ N/ 表示/ 测试/ 基准/ 总/ 指令/ 数/ ,/ Ci/ 表示/ 由/ 解码/ 部件/ 触发/ 的/ 第/ i/ 类/ 故障/ 的/ 指令/ 集合/ ,/ nb/ 为/ 指令/ 位数/ ,/ Wi/ 指第/ i/ 类/ 故障/ 的/ 故障/ 比特/ 所在/ 的/ 指令/ 域/ 宽度/ ,/ 则/ 在/ 解码/ 部件/ 发生/ 第/ i/ 类/ 故障/ 的/ 概率/ 为/ 其中/ ,/ P/ (/ O/ |/ Xi/ )/ 指第/ i/ 类/ 故障/ 发生/ 后/ 操作系统/ 检测/ 不到/ 的/ 概率/ ,/ 则/ 式/ 中/ ,/ P/ (/ b/ )/ 为/ 引发/ 总线/ 错误/ 的/ 概率/ ;/ P/ (/ s/ )/ 为/ 引发/ 段/ 错误/ 的/ 概率/ ;/ P/ (/ i/ )/ 为/ 引发/ 非法/ 指令/ 的/ 概率/ ./ P/ (/ 珚/ O/ |/ Xi/ )/ 表现/ 了/ 系统软件/ 纠/ 检错/ 的/ 能力/ ./ 考虑/ 其中/ 的/ 段/ 越界/ (/ segmentationfault/ )/ 和/ 总线/ 错误/ (/ buserror/ )/ :/ 段/ 越界/ 一般/ 发生/ 在/ 指令/ // 数据/ 地址/ 的/ 高位/ ,/ 具体/ 区域/ 取决于/ 应用程序/ 编译/ 后/ 各个/ 段/ 大小/ (/ Lseg/ )/ ;/ 总线/ 错误/ 往往/ 是/ 由/ 单/ 比特/ 故障/ 引起/ 的/ 字/ 不/ 对齐/ 引发/ ,/ 取决于/ 指令/ // 数据/ 字长/ (/ Lword/ )/ ./ 因此/ ,/ 可得/ P/ (/ b/ )/ +/ P/ (/ s/ )/ =/ log2Lseg/ -/ log2Lwordna/ =/ log2Lseg/ // Lwordna/ 其中/ ,/ na/ 为/ 地址/ 域/ 宽度/ ./ 对于/ A/ →/ B/ 类/ 故障/ ,/ Cii/ 表示/ 合法/ 的/ A/ 指令/ 单/ 比特/ 故障/ 发生/ 后/ 没有/ 对应/ 的/ 合法/ 的/ B/ 指令/ 的/ 集合/ ,/ Cai/ 表示/ 合法/ 的/ A/ 指令/ 的/ 集合/ ,/ 得/ 操作系统/ 漏检/ 指令/ 会/ 蔓延/ 至/ 应用层/ ,/ 这些/ 指令/ 都/ 处于/ Ci/ 集合/ 内/ ,/ 其中/ 部分/ 指令/ 一定/ 不会/ 被/ 低/ 代价/ 锁步/ EDDI/ 算法/ 所/ 覆盖/ ,/ 这些/ 指令/ 的/ 集合/ 称为/ Ci/ ;/ 而/ 在/ Ci/ -/ Ci/ 集合/ 中/ ,/ 如果/ 故障/ 发生/ 在/ 特殊/ 的/ 指令/ 比特/ ,/ 又/ 不能/ 被/ 覆盖/ ,/ 这些/ 特殊/ 的/ 指令/ 比特/ 总数/ 称为/ Wi/ ./ P/ (/ Y/ |/ O/ |/ Xi/ )/ 指第/ i/ 类/ 故障/ 发生/ 后/ 操作系统/ 检测/ 不到/ 的/ 条件/ 下/ ,/ 低/ 代价/ 锁步/ EDDI/ 算法/ 检测/ 不到/ 的/ 概率/ ,/ 则/ P/ (/ Y/ |/ O/ |/ Xi/ )/ =/ α/ 1/ +/ α/ 2/ ×/ Ci/ 其中/ ,/ α/ 1/ 、/ α/ 2/ 和/ α/ 3/ 为/ 0/ 或者/ 1/ ,/ 取决于/ 具体/ 的/ 故障/ 类型/ ./ 对于/ A/ →/ B/ 类/ 故障/ ,/ 考虑/ 下面/ 一段/ 代码/ :/ 1/ ./ sethi/ %/ hi/ (/ ./ LL0/ )/ ,/ %/ g1/ // // 未/ 复制/ 2/ ./ add/ %/ g1/ ,/ %/ g0/ ,/ %/ g2/ // // 影子/ 指令/ 3/ ./ add/ %/ g1/ ,/ %/ g0/ ,/ %/ g1/ // // 主/ 指令/ 4/ ./ cmp/ %/ g2/ ,/ %/ g3/ // // 比较/ 5/ ./ bneerror1/ 、/ 3/ 为主/ 指令/ ,/ 如果/ A/ →/ B/ 类/ 故障/ 导致/ 控制/ 流出/ 错/ ,/ 而/ 跳转/ 到/ 指令/ 3/ 、/ 4/ 时/ ,/ 该/ 故障/ 可/ 被/ 算法/ 检出/ ;/ 如果/ 跳/ 到/ 指令/ 1/ 、/ 2/ 、/ 5/ 处/ ,/ 则/ 检测/ 不到/ ./ 此种/ 情况/ 下/ Wi/ // Wi/ 采用/ 如下/ 的/ 估计/ 方法/ :/ 令/ Neddi/ 表示/ 经/ EDDI/ 机制/ 加固/ 后/ 的/ 程序/ 指令/ 数/ ,/ Ncopy/ 表示/ 未/ 加固/ 测试/ 基准/ 需要/ 复制/ 的/ 指令/ 数/ ./ 可以/ 近似/ 得到/ Page6/ 综上/ ,/ 可得/ P/ (/ SDCj/ )/ =/ δ/ j/ ×/ P/ (/ Y/ |/ Uj/ )/ ×/ P/ (/ Uj/ )/ ,/ jisDecoder/ 其中/ ,/ δ/ j/ =/ NSDCjNSDCj/ +/ NCRj/ 地址/ 生成/ 部件/ 故障/ 漏检/ 率/ 估计/ 对于/ 地址/ 生成/ 部件/ ,/ 估计/ 方法/ 如下/ :/ 综上/ ,/ 可/ 得/ 其中/ ,/ P/ (/ O/ )/ 为/ 地址/ 生成/ 部件/ 发生/ 故障/ 后/ ,/ 操作系统/ 漏检/ 的/ 概率/ ,/ 计算方法/ 与/ 式/ (/ 5/ )/ 相同/ ./ P/ (/ SDCj/ )/ =/ δ/ j/ ×/ P/ (/ Y/ |/ Uj/ )/ ×/ P/ (/ Uj/ )/ ,/ jisAGEN/ 其中/ ,/ δ/ j/ =/ NSDCjNSDCj/ +/ NCRj/ 算逻/ 单元/ 故障/ 漏检/ 率/ 估计/ 算逻/ 单元/ 的/ 估计/ 方法/ 与/ 解码/ 、/ 地址/ 生成/ 部件/ 稍/ 有/ 不同/ ,/ 部件/ 的/ 原发性/ 故障/ 无法/ 被/ 系统软件/ 检出/ ./ 设未/ 被/ 覆盖/ 的/ 指令/ 集合/ 为/ Ci/ ,/ Ci/ 为/ 未/ 处理/ 的/ 源程序/ 中/ cmp/ 指令/ 集合/ ,/ 可得/ P/ (/ Y/ |/ Uj/ )/ =/ |/ Ci/ |/ P/ (/ SDCj/ )/ =/ δ/ j/ ×/ P/ (/ Y/ |/ Uj/ )/ ×/ P/ (/ Uj/ )/ ,/ jisALU/ // FPU/ 其中/ ,/ δ/ j/ =/ NSDCjNSDCj/ +/ NCRj4/ 低/ 代价/ 锁步/ EDDI/ 机制/ 设计/ 本/ 节/ 给出/ 了/ 具体/ 的/ 指令/ 复制/ 原则/ ,/ 并/ 以/ SPARC/ 架构/ 为/ 目标/ 平台/ 提出/ 了/ 寄存器/ 预留/ 方法/ ./ 4.1/ 指令/ 复制/ 原则/ 低/ 代价/ 锁步/ EDDI/ 影子/ 指令/ 生成/ 原则/ 如下/ :/ (/ 1/ )/ 计算/ 指令/ (/ C/ 类/ 指令/ )/ 复制/ ,/ 即/ 进入/ 算逻/ 单元/ 的/ 指令/ ./ (/ 2/ )/ 同步/ 指令/ 不/ 复制/ ./ 同步/ 指令/ 包括/ :/ 访存/ 指令/ (/ M/ 类/ 指令/ )/ ,/ 跳转/ 指令/ (/ B/ 类/ 指令/ )/ ./ (/ 3/ )/ 主/ 指令/ 与/ 影子/ 指令/ 按照/ 严格/ 锁步/ 方式/ 执行/ ,/ 在/ 主/ 指令/ 与/ 影子/ 指令/ 之间/ 不能/ 有/ 其它/ 指令/ ,/ 且/ 在/ 主/ 指令/ 与/ 影子/ 指令/ 执行/ 之后/ 立即/ 比较/ 执行/ 结果/ ./ (/ 4/ )/ 影子/ 指令/ 在/ 主/ 指令/ 之前/ 执行/ ./ 4.2/ 寄存器/ 预留/ 基于/ 上述/ 的/ 指令/ 复制/ 原则/ ,/ 本/ 机制/ 只/ 需/ 预留/ 数目/ 确定/ 的/ 少数几个/ 寄存器/ ,/ 用于/ 保存/ 影子/ 指令/ 的/ 执行/ 结果/ 和/ 状态/ 寄存器/ 的/ 内容/ ./ 本文/ 以/ SPARC/ 架构/ 为/ 目标/ 平台/ ,/ 将/ 寄存器/ 预留/ 方法/ 说明/ 如下/ :/ 为/ 整型/ 应用/ 预留/ 两个/ 全局/ 寄存器/ ,/ 一个/ 作为/ 影子/ 指令/ 目的/ 寄存器/ ,/ 一个/ 用于/ 保存/ 整型/ 状态/ 寄存器/ (/ icc/ // xcc/ )/ 的/ 内容/ ./ 对于/ 浮点运算/ ,/ 可能/ 出现/ 128/ 位/ 的/ 结果/ ,/ 需要/ 预留/ 4/ 个/ 32/ 位/ 浮点/ 寄存器/ ./ SPARC/ 有/ 4/ 个/ 独立/ 的/ 浮点/ 状态/ 寄存器/ (/ fcc/ )/ ,/ 预留/ 其中/ 一个/ 保存/ 运算/ 状态/ ./ 4.3/ 影子/ 指令/ 生成/ 规则/ 本文/ 针对/ 整型/ 和/ 浮点运算/ 分别/ 提出/ 了/ 具体/ 的/ 影子/ 指令/ 生成/ 规则/ ,/ 并/ 成功/ 解决/ 了/ SPARCV9/ 指令/ 集中/ 副作用/ 影子/ 指令/ 的/ 生成/ 问题/ ./ 浮点运算/ 影子/ 指令/ 与/ 主/ 指令/ 状态/ 寄存器/ 相互/ 独立/ ,/ 使得/ 浮点运算/ 影子/ 指令/ 生成/ 不/ 涉及/ 副作用/ 问题/ ,/ 直接/ 按/ 指令/ 复制/ 原则/ 操作/ 即可/ ./ 摘自/ MiBench/ 中/ FFT/ 典型/ 代码/ 片段/ 如下/ :/ fdivd/ %/ f10/ ,/ %/ f8/ ,/ %/ f28/ // // 影子/ 指令/ fdivd/ %/ f10/ ,/ %/ f8/ ,/ %/ f10/ // // 主/ 指令/ fcmpd/ %/ fcc3/ ,/ %/ f10/ ,/ %/ f28/ // // 比较/ 指令/ fbne/ ,/ pn/ %/ fcc3/ ,/ ./ error/ // // 错误处理/ 整型/ 运算/ 由于/ SPARC/ 架构/ 对于/ 整型/ 运算/ 没有/ 提供/ 多份/ 状态/ 寄存器/ ,/ 因此/ 我们/ 单独/ 预留/ 了/ 一个/ 全局/ 寄存器/ 用于/ 保存/ // 恢复/ 指令/ 状态/ ./ 整型/ 运算/ 影子/ 指令/ 具体/ 生成/ 规则/ 如下/ :/ 来自/ spec2000gzip/ 代码/ 片段/ 如下/ :/ addcc/ %/ o3/ ,/ -/ 1/ ,/ %/ g2/ // // 影子/ 指令/ addcc/ %/ o3/ ,/ -/ 1/ ,/ %/ o3/ // // 主/ 指令/ rd/ %/ ccr/ ,/ %/ g3cmp/ %/ o3/ ,/ %/ g2/ // // 比较/ 指令/ bne/ ,/ pn/ %/ xcc/ ,/ ./ errornopwr/ %/ g3/ ,/ %/ g0/ ,/ %/ ccr/ // // 恢复/ 状态/ 寄存器/ (/ 1/ )/ 非/ 复制/ 指令/ 对于/ 副作用/ 指令/ ,/ 必须/ 先/ 保存/ 状态/ ,/ 并/ 在/ 后续/ 其它/ 副作用/ 指令/ 执行/ 之前/ 恢复/ 状态/ ./ 来自/ spec2000mcf/ 代码/ 片段/ 例子/ 如下/ :/ cmp/ %/ o4/ ,/ %/ i4/ // // 主/ 指令/ rd/ %/ ccr/ ,/ %/ g3/ // // 保存/ 状态/ 寄存器/ st/ %/ o2/ ,/ [/ %/ l0/ +/ 64/ ]/ // // 主/ 指令/ wr/ %/ g3/ ,/ %/ g0/ ,/ %/ ccr/ // // 恢复/ 状态/ movl/ %/ icc/ ,/ %/ i4/ ,/ %/ o4/ // // 主/ 指令/ (/ 2/ )/ 复制/ 指令/ 对于/ 副作用/ 指令/ ,/ 需/ 将/ 影子/ 指令/ 放在/ 主/ 指令/ 前/ 执行/ ,/ 在/ 主/ 指令/ 后/ 保存/ 状态/ ,/ 并/ 在/ 后续/ 使用/ icc/ 的/ 指令/ 之前/ 恢复/ icc/ ./ Page7bne/ ,/ a/ ,/ pt/ %/ icc/ ,/ ./ LL53/ 综上/ ,/ 本文/ 分别/ 针对/ 整型/ 运算/ 与/ 浮点运算/ ,/ 提出/ 了/ 独特/ 的/ 指令/ 复制/ 规则/ ,/ 并/ 成功/ 解决/ 了/ 副作用/ 指令/ 生成/ 问题/ ./ 通过/ 寄存器/ 预留/ 成功/ 实现/ 主/ 指令/ 与/ 影子/ 指令/ 对/ 寄存器/ 的/ 分割/ ,/ 寄存器/ 预留/ 比远/ 小于/ 全/ 复制/ EDDI/ 寄存器/ 分半/ 的/ 50/ %/ ./ 本/ 机制/ 通用性/ 强/ ,/ 无需/ 传参/ 规则/ 的/ 修改/ ,/ 无需/ 系统/ 库/ 的/ 重新/ 编译/ ./ 5/ 实验/ 5.1/ 实验/ 环境/ 故障注入/ 系统/ 编译/ 工具/ 链/ 选择/ GCC4/ ./ 2.1/ ,/ 通过/ 对/ 体系结构/ 文件/ 的/ 重/ 配置/ ,/ 实现/ 编译器/ 支持/ 的/ 寄存器/ 预留/ 、/ 分配/ 和/ 后/ 端/ 优化/ ./ 为/ 避免/ 编译器/ 指令/ 调度/ 破坏/ 主/ 、/ 影子/ 指令/ 间/ 严格/ 锁步/ ,/ 我们/ 在/ 编译/ 、/ 汇编/ 之间/ 插入/ 指令/ 复制/ 规则/ 的/ 具体/ 实现/ ./ 故障注入/ 通过/ 对/ 结构/ 级/ 全/ 系统/ 模拟器/ SAM/ [/ 21/ ]/ 的/ 修改/ 实现/ ,/ 目标/ 架构/ 为/ UltraSPARCT2/ ,/ 指令集/ 为/ SPARCV9/ ./ 评测/ 环境/ 本文/ 将/ 低/ 代价/ 锁步/ EDDI/ 实现/ 代价/ 与/ 全/ 复制/ EDDI/ 进行/ 比较/ [/ 20/ ]/ ,/ 后者/ 实现/ 方法/ 为/ :/ 主/ 指令/ 、/ 影子/ 指令/ 各/ 占用/ 一份/ 寄存器/ ;/ 计算/ 指令/ 复制/ 并/ 在/ 同步/ 指令/ 之前/ 比较/ ,/ 同步/ 指令/ 包括/ load/ ,/ store/ ,/ 跳转/ ,/ 函数调用/ ,/ 函数/ 返回/ ;/ 跳转/ 指令/ 不/ 复制/ ;/ 访存/ 执行/ 一次/ ,/ 若/ 是/ 取数/ 指令/ 需将/ 取来/ 的/ 数据/ 写入/ 影子/ 寄存器/ ./ 测试/ 基准/ 的/ 选取/ 故障注入/ 的/ 目的/ 是/ 观察/ 实验/ 平台/ 运行/ 测试/ 基准/ 时/ ,/ 注入/ 故障/ 引发/ 的/ 种种/ 表现/ ./ 广泛/ 使用/ 的/ spec/ 系列/ 测试/ 基准/ ,/ 主要/ 用于/ 性能/ 测试/ ,/ 运行/ 时间/ 较长/ (/ 从/ 数分钟/ 到数/ 小时/ 不/ 等/ ,/ 在/ 模拟器/ 上/ 更/ 要/ 高出/ 几个/ 数量级/ )/ ,/ 而且/ 应用/ 个数/ 较/ 多/ (/ 通常/ 有/ 20/ 个/ 左右/ )/ ./ 因此/ ,/ 研究/ 人员/ 通常/ 采用/ 运行/ 指定/ 代码/ 片段/ 、/ 记录/ trace/ 的/ 方式/ 进行/ 试验/ ./ 然而/ ,/ 这种/ 方式/ 与/ 瞬时/ 故障/ 模型/ 的/ 随机性/ 相悖/ [/ 22/ ]/ ,/ 故/ 本文/ 没有/ 采用/ spec/ 系列/ 测试/ 基准/ ./ 文献/ [/ 23/ ]/ 将/ MiBench/ 与/ SPEC/ 进行/ 了/ 对比/ ,/ MiBench/ 的/ 指令/ 类型/ 和/ 吞吐量/ 等/ 方面/ 不逊于/ SPEC/ ,/ 完全/ 满足/ 故障注入/ 的/ 要求/ ./ 而且/ ,/ MiBench/ 输入/ 集较/ 小/ ,/ 运行/ 时间/ 大大缩短/ ,/ 有利于/ 提高/ 故障注入/ 样本空间/ ./ 因此/ ,/ 本文/ 采用/ MiBench/ 测试/ 基准/ ,/ 应用/ 包括/ FFT/ 、/ stringsearch/ 、/ dijkstra/ 和/ basicmath/ ,/ 采用/ 标准/ 输入/ 集/ ./ 5.2/ 可靠性/ 评测/ 故障注入/ 方式/ 在/ SAM/ 模拟器/ 进行/ 故障注入/ ,/ 分别/ 模拟/ 处理器/ 组合/ 逻辑/ 的/ 代表性/ 部件/ :/ 解码/ 单元/ 、/ 地址/ 生成/ 单元/ 和/ 算/ 逻/ 单元/ 发生/ 瞬时/ 故障/ ,/ 蔓延/ 至/ 部件/ 输入/ // 输出/ 锁存/ 引发/ 的/ 单/ 比特/ 翻转/ ./ 每种/ 故障/ 类型/ 每个/ 测试/ 基准/ 注入/ 100/ 次/ ./ 令/ Tload/ 表示/ 测试/ 基准/ 在/ SAM/ 上/ 运行/ 时/ 长/ ,/ 在/ [/ 0/ ,/ Tload/ ]/ 区间/ 随机/ 生成/ 时刻/ Tinject/ ./ 地址/ 生成/ 单元/ 故障/ SPARC/ 处理器/ 除了/ 包含/ 程序/ 计数器/ PC/ 外/ ,/ 还/ 具有/ NPC/ (/ NextProgramCounter/ )/ ./ 此/ 寄存器/ 包含/ 下/ 一条/ 要/ 执行/ 指令/ 的/ 地址/ ./ 本文/ 对/ NPC/ 寄存器/ 注入/ 单/ 比特/ 故障/ 来/ 模拟/ 地址/ 生成/ 单元/ 故障/ ./ 解码/ 单元/ 故障/ 对/ SAM/ 指令/ 缓存/ 中/ 即将/ 进入/ 执行/ 段/ 的/ 指令/ 注入/ 单/ 比特/ 故障/ ,/ 模拟/ 解码/ 单元/ 瞬时/ 故障/ 经/ 蔓延/ 引发/ 的/ 微结构/ 级单/ 比特/ 翻转/ ./ 因为/ 指令/ 缓存/ 中/ 的/ 故障/ 指令/ 可能/ 被/ 后续/ 过程/ 中/ 执行/ 到/ ,/ 所以/ 在/ 故障/ 指令/ 执行/ 结束/ 后/ 需/ 恢复/ ./ 算逻/ 单元/ 故障/ 算逻/ 单元/ 的/ 故障模拟/ 与/ 上述/ 两个/ 部件/ 不同/ ./ 计算/ 指令/ 进入/ 算逻/ 单元/ 后/ ,/ 流经/ 部件/ 均/ 为/ 故障/ 蔓延/ 的/ 潜在/ 路径/ ./ 如图/ 2/ 所示/ ,/ 可能/ 的/ 故障/ 源有/ 5/ 处/ ,/ 从/ 寄存器/ 文件/ 读取/ 操作数/ 时/ ,/ 经/ ①/ 数据通路/ 读入/ ②/ 输入/ 锁存/ ,/ 经/ ③/ 组合/ 逻辑运算/ 生成/ 结果/ ,/ 通过/ ④/ 输出/ 锁存/ 和/ ⑤/ 数据通路/ 被/ 写/ 回/ 寄存器/ 文件/ ./ 据此/ 可/ 将/ 故障/ 归为/ 3/ 类/ :/ (/ 1/ )/ 操作数/ 在/ 数据通路/ 引发/ 翻转/ 和/ 输入/ 锁存/ 受/ 辐射/ 翻转/ ,/ 最终/ 都/ 会/ 导致/ 输入/ 锁/ 存单/ 比特/ 翻转/ ./ (/ 2/ )/ 运算/ 过程/ 中/ 组合/ 逻辑/ 故障/ ,/ 与/ 输入/ 锁/ 存单/ 比特/ 翻转/ 导致/ 的/ 故障/ 表现/ 类似/ ./ (/ 3/ )/ 同理/ ,/ 输出/ 锁存/ 故障/ 和/ 写/ 回/ 过程/ 中/ 数据通路/ 故障/ ,/ 三者/ 也/ 可用/ 输入/ 锁/ 存单/ 翻转/ 模拟/ ./ 由/ 上述/ 分析/ 可知/ ,/ 本文/ 在/ SAM/ 执行/ 过程/ 中/ 随机/ 选择/ 算术/ 指令/ ,/ 并/ 在/ 此/ 算术/ 指令/ 读取/ 源/ 操作数/ 寄/ Page8/ 存器/ 时/ 注入/ 单/ 比特/ 故障/ ./ 故障/ 漏检/ 率/ 估计/ 表/ 2/ 给出/ 了/ 解码/ 单元/ (/ Decoder/ )/ 、/ 算逻/ 单元/ (/ ALU/ )/ 和/ 地址/ 生成/ 单元/ (/ AGEN/ )/ 故障/ 漏检/ 率/ 的/ 估计/ 和/ 实际/ 值/ 的/ 对比/ ./ 其中/ ,/ 实际/ 正确/ 结果/ 项为/ 故障注入/ 后/ ,/ 未经/ 硬件/ 、/ 系统软件/ 以及/ EDDI/ 检出/ ,/ 而且/ 程序/ 结果/ 仍然/ 正确/ 的/ 比例/ ./ 本文/ 假设/ 寄存器/ 文件/ 有/ 硬件/ 保护/ ,/ 该/ 部件/ 故障/ 漏检/ 率为/ 0/ ./ 因此/ ,/ 对/ 4/ 个/ 部件/ 故障/ 漏检/ 率依/ 故障/ 发生/ 概率/ 加权/ 求和/ ,/ 可得/ 低/ 代价/ 锁步/ 机制/ 对/ 处理器/ (/ system/ )/ 的/ 总体/ 故障/ 漏检/ 率/ (/ 本文/ 假设/ 各/ 部件/ 单/ 比特/ 故障/ 触发/ 概率/ 相等/ )/ ./ 总体/ 故障/ 漏检/ 率/ 估计值/ 为/ 3.1/ %/ ,/ 实际/ 漏检/ 率为/ 2.8/ %/ ./ 估计/ 表/ 2/ 故障/ 漏检/ 率/ 估计/ 漏检/ 率/ // %/ 漏检/ 率/ // %/ 测试/ 实际/ 正确/ 结果/ fftdijkstra0/ ./ 30.454/ ./ 70.1029/ ./ 23.12/ ./ 112.80/ ./ 90.624/ ./ 2stringsearch0/ ./ 80.954/ ./ 00.10/ ./ 531.52/ ./ 32.318/ ./ 20.80/ ./ 925.9/ basicmath10/ ./ 39.737/ ./ 10.20/ ./ 94.112/ ./ 88.79/ ./ 35.84/ ./ 812.6/ average4/ ./ 14.146/ ./ 20.10/ ./ 621.88/ ./ 26.311/ ./ 93.12/ ./ 820.0/ 对于/ 算逻/ 单元/ ,/ 估计值/ 低于/ 实际/ 值/ ,/ 主要/ 原因/ 是/ 故障注入/ 到/ 运算/ 指令/ 操作数/ 寄存器/ 后/ 可能/ 被/ 逻辑/ 屏蔽/ ./ 例如/ :/ and/ %/ g1/ ,/ 1/ ,/ %/ g2/ // // 影子/ 指令/ and/ %/ g1/ ,/ 1/ ,/ %/ g1/ // // 主/ 指令/ and/ 指令/ 将/ 寄存器/ g1/ 的/ 值/ 和/ 立即/ 数/ 1/ 逻辑/ 与/ ,/ 并/ 将/ 结果/ 赋给/ 目的/ 寄存器/ ./ 若/ 故障/ 发生/ 在/ g1/ ,/ 仅当/ g1/ 末位/ 发生/ 单/ 比特/ 翻转/ ,/ 才/ 会/ 影响/ 执行/ 结果/ ,/ 其它/ 情况/ 均/ 导致/ 逻辑/ 屏蔽/ ./ 对于/ 地址/ 生成/ 部件/ ,/ 估计/ 漏检/ 率/ 高于/ 实际/ 值/ 的/ 主要/ 原因/ 是/ :/ 测试/ 基准/ 中/ 的/ 部分/ 访存/ 指令/ ,/ 访问/ 地址/ 由/ 计算/ 得出/ (/ 间接/ 寻址/ 等/ )/ ,/ 致使/ 理论/ 估计/ 无法/ 精确/ 计算/ 操作系统/ 检错/ 能力/ ,/ 导致/ 估计/ 的/ 漏检/ 率/ 偏高/ ./ 故障注入/ 结果/ 与/ 分析测试/ 基准/ 在/ SAM/ 注入/ 故障/ 之后/ ,/ 将/ 故障/ 实例/ 的/ 输出/ 与/ 标准/ 输出/ 进行/ 对比/ ./ 根据/ 故障/ 表现/ 的/ 不同/ ,/ 可/ 将/ 注入/ 结果/ 分为/ 以下/ 5/ 类/ :/ (/ 1/ )/ 正确/ 结果/ (/ Correctresult/ )/ :/ 运行/ 结果/ 的/ 输出/ 和/ 标准/ 输出/ 一致/ ./ (/ 2/ )/ EDDI/ 检测/ (/ EDDI/ )/ :/ 故障/ 被/ EDDI/ 机制/ 检测/ 到/ ./ (/ 3/ )/ 操作系统/ 检测/ :/ 包括/ 段/ 错误/ (/ SegmentationFault/ )/ 、/ 非法/ 指令/ (/ IllegalInstruction/ )/ 、/ 总线/ 错误/ 值/ 与/ 实际/ 值/ 拟合/ 良好/ ./ 估计值/ 偏高/ 的/ 主要/ 原因/ 在于/ 间接/ 寻址/ 方式/ 导致/ 操作系统/ 检错/ 能力/ 被/ 低估/ ,/ 从而/ 最终/ 使/ 总体/ 故障/ 漏检/ 率/ 估计值/ 偏高/ ./ 但/ 对于/ 不同/ 的/ 部件/ 其/ 估计值/ 表现/ 不同/ ,/ 具体/ 如下/ :/ 在/ SPARC/ 体系结构/ 中/ ,/ 解码/ 部件/ 的/ 估计值/ 略低于/ 实际/ 值/ ,/ 原因/ 是/ 测试/ 基准/ 中/ 某些/ 运算/ 指令/ 实现/ 的/ 特殊性/ ,/ 使得/ 故障注入/ 到/ 这些/ 指令/ 后/ 被/ 屏蔽/ ,/ 例如/ mov/ 指令/ (/ 该/ 指令/ 将源/ 寄存器/ 值赋/ 给/ 目的/ 寄存器/ )/ 的/ 一个/ 源/ 操作数/ 为/ %/ g0/ (/ SPARC/ 架构/ g0/ 值恒为/ 0/ )/ ,/ 若/ 故障/ 导致/ 寄存器/ 号/ 改变/ 为/ g1/ ,/ 恰好/ g1/ 的/ 值/ 还是/ 0/ ,/ 则/ 不/ 影响/ 执行/ 结果/ ./ 此种/ 情况/ 在/ 故障注入/ 试验/ 中/ 发生/ 频率/ 较/ 高/ ./ 估计/ SDC/ (/ BusError/ )/ ./ 导致/ 操作系统/ 重新启动/ ./ (/ 4/ )/ 操作系统/ 崩溃/ (/ OSPanic/ 、/ HighOS/ )/ :/ 故障/ (/ 5/ )/ 错误/ 结果/ :/ 运行/ 结果/ 和/ 无故障/ 结果/ 不/ 一致/ ./ 其中/ 操作系统/ 崩溃/ 和/ 错误/ 结果/ 之/ 和/ 为/ 漏检/ 比例/ ,/ 称为/ SDC/ (/ SilentDataCorruption/ )/ ./ 图/ 3/ 显示/ 原/ 测试/ 基准/ 、/ 全/ 复制/ EDDI/ 加固/ 、/ 低/ 代价/ 锁步/ EDDI/ 加固/ 后/ 分别/ 在/ 解码/ 单元/ 、/ 算逻/ 单元/ 和/ 地址/ 生成/ 单元/ 注入/ 故障/ 的/ 结果/ ./ 与/ 未/ 加固/ 测试/ 基准/ 相比/ ,/ EDDI/ 机制/ 带来/ 的/ 容错性/ 能/ 提升/ 十分/ 明显/ 操作系统/ 的/ 故障/ 覆盖/ 能力/ 也/ 相当可观/ ./ 全/ 复制/ EDDI/ 整体/ SDC/ 为/ 2.0/ %/ ,/ 低/ 代价/ 锁步/ EDDI/ 为/ 2.8/ %/ ./ 对于/ 解码/ 部件/ 故障/ ,/ 未/ 加固/ 测试/ 基准/ 正确/ 结果/ 为/ 60.2/ %/ ,/ 操作系统/ 检测/ 比例/ 为/ 24.9/ %/ ,/ SDC/ 为/ 14.9/ %/ ./ 全/ 复制/ EDDI/ 加固/ 后/ SDC/ 平均值/ 为/ 1.9/ %/ ,/ 经/ 本文/ 锁步/ EDDI/ 加固/ 后/ SDC/ 平均值/ 为/ 4.1/ %/ ./ 而锁步/ EDDI/ 的/ SDC/ 高于/ 全/ 复制/ EDDI/ 的/ 原因/ 主要/ 是/ 前者/ 没有/ 对/ 测试/ 基准/ 中/ cmp/ 指令/ 进行/ 加固/ ./ 在/ SPARC/ 体系结构/ 中/ ,/ cmp/ 指令/ 是/ 由/ 目的/ 操作数/ 为/ g0/ 的/ subcc/ 指令/ 实现/ ,/ 如果/ 注入/ 的/ 故障/ 修改/ 了/ 目的/ 操作数/ 域/ ,/ 会/ 导致/ g0/ 以外/ 的/ 寄存器/ 误/ 写入/ ./ 若该/ 寄存器/ 影响/ 程序/ 数据流/ ,/ 就/ 会/ 引发/ 错误/ 结果/ ./ 但/ 此种/ 情况/ 对/ 整体/ 检错/ 性能/ 贡献/ 并/ 不/ 明显/ ,/ 而全/ 复制/ EDDI/ 为/ 覆/ Page9/ 图/ 3/ 故障注入/ 结果/ 盖/ cmp/ 指令/ ,/ 也/ 付出/ 了/ 寄存器/ 分半/ 的/ 代价/ ./ 由此/ 带来/ 的/ 性能/ 下降/ 十分/ 明显/ ,/ 具体分析/ 见/ 5.3/ 节/ 性能/ 评测/ ./ 对于/ 地址/ 生成/ 部件/ ,/ 没有/ EDDI/ 加固/ 的/ 测试/ 基准/ 结果/ SDC/ 平均值/ 为/ 8.6/ %/ ./ 全/ 复制/ EDDI/ 加固/ 后/ SDC/ 平均值/ 为/ 6.1/ %/ ./ 经/ 本文/ 低/ 代价/ 锁步/ EDDI/ 加固/ 后/ SDC/ 平均值/ 为/ 6.3/ %/ ./ 其中/ 略高于/ 全/ 复制/ EDDI/ ,/ 主要/ 原因/ 是/ 本/ 机制/ 复制/ 指令/ 原则/ 是/ 影子/ 指令/ 和/ 主/ 指令/ 源/ 操作数/ 都/ 来自/ 同一个/ 寄存器/ ./ 图/ 4/ 性能/ 代价/ 静态/ 指令/ 代价/ 全/ 复制/ EDDI/ 静态/ 指令/ 总数/ 平均值/ 是/ 原/ 测试/ 基准/ 指令/ 总数/ 的/ 4.63/ 倍/ ,/ 而/ 低/ 代价/ 锁步/ EDDI/ 则/ 是/ 原/ 测试/ 基准/ 指令/ 总数/ 的/ 2.29/ 倍/ ./ 主要/ 原因/ 是/ :/ (/ 1/ )/ 比较/ 原则/ ./ 全/ 复制/ EDDI/ 在/ 同步/ 指令/ 之前/ 比较/ 值/ 和/ 地址/ ,/ store/ 带来/ 至少/ 两次/ 的/ 比较/ (/ 值/ 、/ 地址/ )/ 和/ 对/ 标志/ 寄存器/ ccr/ 的/ 保存/ 和/ 恢复/ ,/ 函数调用/ 会/ 带来/ 和/ 参数/ 个数/ 相同/ 数量/ 的/ 比较/ ,/ 跳转/ 指令/ 之前/ 还/ 需/ 比较/ 标志/ 寄存器/ ./ 而/ 低/ 代价/ 锁步/ EDDI/ 只/ 比较/ 运算/ 指令/ 结果/ ,/ 对于/ 标志/ 寄存器/ 也/ 只是/ 在/ 修改/ 时/ 保存/ ,/ 使用/ 时/ 恢复/ ,/ 而/ 对于/ 算逻/ 单元/ ,/ 经/ 本文/ 低/ 代价/ 锁步/ EDDI/ 加固/ 后/ ,/ SDC/ 平均值/ 从/ 无/ EDDI/ 加固/ 的/ 19.6/ %/ 降低/ 为/ 0.6/ %/ ./ 全/ 复制/ EDDI/ 为/ 0.1/ %/ ./ 5.3/ 性能/ 评测/ 本节/ 从/ 静态/ 指令/ 数/ 、/ 动态/ 指令/ 数/ 和/ 执行/ 时间/ 3/ 个/ 方面/ 对比/ 了/ 低/ 代价/ 锁步/ EDDI/ 与/ 全/ 复制/ EDDI/ 机制/ 的/ 性能/ 表现/ ./ 所列/ 数据/ 均/ 为/ 与/ 未/ 加固/ 测试/ 基准/ 规格化/ 的/ 结果/ ,/ 如图/ 4/ 所示/ ./ 此/ 原则/ 在/ 寄存器/ 有/ 保护/ 的/ 情况/ 下/ ,/ 不会/ 带来/ 容错性/ 能/ 的/ 下降/ ./ 与/ 低/ 代价/ 锁步/ EDDI/ 相比/ ,/ 全/ 复制/ EDDI/ 的/ 比较/ 指令/ 高出/ 121.1/ %/ ./ (/ 2/ )/ 寄存器/ 压力/ ./ 全/ 复制/ EDDI/ 主/ 指令/ 、/ 影子/ 指令/ 各/ 占用/ 一份/ 寄存器/ ,/ 使/ 程序/ 中/ 可/ 分配/ 的/ 通用寄存器/ 变/ 少/ ,/ 这样/ 就/ 增加/ 了/ 程序/ 中访存/ 指令/ 和/ 运算/ 指令/ 的/ 比例/ ./ 与/ 低/ 代价/ 锁步/ EDDI/ 相比/ ,/ 全/ 复制/ EDDI/ 访存/ 指令/ 比例/ 平均/ 增加/ 33.8/ %/ ,/ 运算/ 指令/ 数/ 平均/ 增加/ 41.3/ %/ ./ 其中/ FFT/ 的/ 访存/ 指令/ 增加/ 比例/ 达到/ 69.1/ %/ ,/ 可知/ 低/ 代价/ 锁步/ EDDI/ 对于/ 诸如/ FFT/ 这类/ 寄存器/ 负载/ 较/ 高/ 的/ 应用/ ,/ Page10/ 带来/ 的/ 性能/ 提升/ 尤其/ 明显/ ./ 需要/ 指出/ 的/ 是/ ,/ 访存/ 指令/ 的/ 增多/ 会/ 进一步提高/ 全/ 复制/ EDDI/ 的/ 比较/ 代价/ ./ 动态/ 性能/ 代价/ 全/ 复制/ EDDI/ 动态/ 执行/ 指令/ 数是/ 原/ 测试/ 基准/ 的/ 2.37/ 倍/ ,/ 执行/ 时间/ 是/ 原/ 测试/ 基准/ 的/ 1.92/ 倍/ ./ 与/ 低/ 代价/ 锁步/ EDDI/ 相比/ ,/ 全/ 复制/ EDDI/ 平均/ 执行/ 的/ 比较/ 指令/ 增加/ 253.5/ %/ ,/ 运算/ 指令/ 增加/ 50.1/ %/ ,/ 访存/ 指令/ 增加/ 8.7/ %/ ,/ 其中/ FFT/ 的/ 访存/ 指令/ 增加/ 比例/ 达到/ 18.3/ %/ ./ 总之/ ,/ 由于/ 本文/ 低/ 代价/ 锁步/ EDDI/ 独特/ 的/ 复制/ 原则/ 和/ 在/ 编译/ 前端/ 实现/ 的/ 寄存器/ 预留/ 两个/ ,/ 减少/ 了/ 寄存器/ 预留/ 数/ 、/ 有效/ 缓解/ 寄存器/ 压力/ ,/ 降低/ 了/ 访存/ 代价/ ,/ 同时/ 也/ 降低/ 了/ 插入/ 指令/ 总数/ ./ 与/ 全/ 复制/ EDDI/ 相比/ ,/ 低/ 代价/ 锁步/ EDDI/ 在/ 性能/ 上/ 提高/ 显著/ :/ 平均/ 执行/ 时间/ 缩短/ 35.2/ %/ ,/ 平均/ 动态/ 执行/ 指令/ 则/ 减少/ 36.1/ %/ ./ 这/ 充分证明/ 了/ 本文/ 代价/ 互锁/ EDDI/ 在/ 性能/ 上/ 的/ 优势/ ./ 6/ 结论/ 本文/ 在/ 设计/ 初期/ 将/ 硬件/ 和/ 系统软件/ 的/ 故障/ 纠/ 检错/ 能力/ 纳入/ 考虑/ ,/ 针对/ 处理器/ 内/ 瞬时/ 故障/ ,/ 设计/ 应用/ 级/ “/ 低/ 代价/ 锁步/ EDDI/ ”/ ./ 主要/ 内容/ 如下/ :/ (/ 1/ )/ 设计/ 了/ 低/ 代价/ 锁步/ EDDI/ 机制/ ,/ 提出/ 低/ 代价/ 锁步/ 的/ 指令/ 复制/ 规则/ 和/ 寄存器/ 分配/ 方式/ ./ 本/ 机制/ 结合/ 硬件/ 纠/ 检错/ 能力/ ,/ 兼顾/ 处理器/ 内/ 组合/ 逻辑/ 、/ 时序/ 逻辑/ 两类/ 部件/ ./ 与/ 传统/ EDDI/ 将/ 寄存器/ 分半/ 不同/ ,/ 通过/ 编译/ 链/ 前端/ 寄存器/ 分配/ 大幅/ 减少/ 了/ 寄存器/ 预留/ 数/ ,/ 有效/ 缓解/ 寄存器/ 压力/ ,/ 降低/ 了/ 访存/ 代价/ ,/ 减少/ 了/ 性能/ 损失/ ./ 无需/ 修改/ 编译器/ 传参/ 规则/ ,/ 无需/ 重新/ 编译系统/ 库/ ,/ 提高/ 了/ 通用性/ ./ (/ 2/ )/ 基于/ 概率论/ 提出/ 故障/ 漏检/ 率/ 量化/ 估计/ 方法/ ,/ 为/ 纠/ 检错/ 与/ 性能/ 折中/ 进行/ 指导/ ./ 通过/ 对/ 处理器/ 中/ 代表性/ 部件/ :/ 算逻/ 单元/ 、/ 解码/ 单元/ 和/ 地址/ 生成/ 部件/ 进行/ 故障注入/ ,/ 验证/ 理论/ 估计/ 方法/ 的/ 有效性/ ./ (/ 3/ )/ 选择/ 单/ 比特/ 瞬时/ 故障/ 模型/ ,/ 对/ 机制/ 故障注入/ 实验/ 结果/ 、/ 静态/ 性能/ 代价/ ,/ 与/ 动态/ 性能/ 代价/ 进行/ 详细/ 评测/ ./ 与/ 全/ 复制/ EDDI/ 相比/ ,/ 低/ 代价/ 锁步/ EDDI/ 仅以/ SDC/ 平均/ 升高/ 0.8/ %/ 的/ 代价/ ,/ 换取/ 了/ 平均/ 执行/ 时间/ 缩短/ 35.2/ %/ ,/ 平均/ 动态/ 执行/ 指令/ 则/ 减少/ 36.1/ %/ 的/ 性能/ 优势/ ./ 

