Page1/ 一个/ 高效/ BDD/ 的/ 简洁/ 实现/ 苏开乐/ 1/ )/ ,/ 2/ )/ 吕/ 关锋/ 3/ )/ 宋炯/ 1/ )/ 1/ )/ (/ 浙江师范大学/ 数理/ 信息/ 工程学院/ 浙江/ 金华/ 312004/ )/ 2/ )/ (/ 清华大学/ 清华/ -/ 阿姆斯特丹/ 逻辑学/ 联合/ 研究/ 中心/ 北京/ 100084/ )/ 3/ )/ (/ 北京工业大学/ 计算机/ 学院/ 北京/ 100022/ )/ 摘要/ 二叉/ 判定/ 图/ BDD/ 作为/ 一种/ 表示/ 和/ 操作/ 布尔/ 函数/ 的/ 数据结构/ ,/ 被/ 广泛/ 地/ 应用/ 在/ 模型/ 检测/ 、/ 系统验证/ 等/ 领域/ ./ 在/ 最坏/ 情况/ 下/ ,/ BDD/ 的/ 空间/ 规模/ 是/ 指数/ 级/ 的/ ,/ 因此/ 为了/ 设计/ 和/ 实现/ 一个/ 高效/ BDD/ 包/ ,/ 研究者/ 们/ 做/ 了/ 大量/ 技术性/ 工作/ ,/ 同时/ 涌现出/ 多个/ 高效/ BDD/ 包/ ./ 为了/ 节省/ 空间/ 和/ 提高/ 运算/ 速度/ ,/ 这些/ BDD/ 包/ 的/ 实现/ 都/ 限定/ 了/ 一个/ 较/ 小/ 的/ 变量/ 个数/ 上限/ (/ 不/ 超过/ 216/ )/ ,/ 然而/ 这种/ 限定/ 同时/ 也/ 限制/ 了/ BDD/ 包/ 的/ 适用性/ ./ 为了/ 突破/ 这种/ 限制/ ,/ 文中/ 给出/ 了/ 一个/ 高效/ 的/ BDD/ 包/ 实现/ ,/ 该包/ 在/ 采纳/ 了/ 经典/ BDD/ 包/ 高效/ 实现/ 技术/ 的/ 同时/ ,/ 使用/ 了/ 内存/ 分片/ 分配/ 、/ 轻量级/ 垃圾/ 回收/ 等/ 技术/ ./ 这些/ 技术/ 使得/ BDD/ 包在/ 保持/ 高性能/ 的/ 情况/ 下/ ,/ 将/ 可/ 处理/ 的/ 变量/ 规模/ 提高/ 到/ 232/ ,/ 与/ 现有/ BDD/ 包/ 的/ 处理/ 规模/ 216/ 相比/ ,/ 大大提高/ 了/ BDD/ 包/ 的/ 适用性/ ./ 实验/ 证明/ 其/ 性能/ 非常/ 接近/ 可/ 获得/ 的/ 最快/ 的/ 216/ 变量/ 规模/ 的/ BDD/ 包/ —/ —/ —/ CUDD/ ./ 关键词/ 二叉/ 判定/ 图/ ;/ 布尔/ 函数/ ;/ 内存/ 分配/ 1/ 引言/ 二叉/ 判定/ 图/ (/ BinaryDecisionGiagram/ ,/ BDD/ )/ 作为/ 布尔/ 函数/ 的/ 一种/ 等价/ 表示/ 形式/ ,/ 最初/ 被/ 成功/ 应用/ 在/ 模型/ 检测/ [/ 1/ -/ 2/ ]/ 、/ 系统验证/ [/ 3/ ]/ 等/ 领域/ ./ 由于/ BDD/ 所/ 具有/ 的/ 压缩/ 表示/ 特点/ ,/ 使/ 其/ 作为/ 一种/ 重要/ 的/ 数据结构/ 得到/ 了/ 越来越/ 广泛/ 的/ 应用/ ,/ 如/ 知识/ 表达/ 与/ 推理/ [/ 4/ ]/ 、/ 命题/ 公式/ 可/ 满足/ 问题/ (/ SAT/ )/ [/ 5/ ]/ 、/ 安全/ 协议/ 验证/ [/ 6/ ]/ 、/ 网络/ 可靠性/ 测量/ [/ 7/ -/ 8/ ]/ 等/ ./ 尽管/ BDD/ 是/ 对/ 布尔/ 函数/ 的/ 一种/ 压缩/ 表示/ (/ 与/ 真值表/ 等价/ )/ ,/ 但/ 其/ 对/ 空间/ 的/ 需求/ 仍然/ 很/ 高/ ,/ 有/ 可能/ 是/ 指数/ 级/ 的/ ;/ 同时/ 时间/ 复杂度/ 在/ 最坏/ 情况/ 下/ 也/ 是/ 指数/ 级/ 的/ (/ 因为/ 判定/ 一个/ 布尔/ 公式/ 是/ 恒真式/ 问题/ 是/ co/ -/ NP/ 的/ )/ ./ 为了/ 节省/ 空间/ 和/ 赢得/ 时间/ ,/ 现有/ 的/ BDD/ 包/ 的/ 实现/ ,/ 往往/ 使用/ 16/ 位/ 比特/ 来/ 表示/ 变量/ ,/ 这/ 就/ 意味着/ ,/ BDD/ 包/ 最/ 多/ 能够/ 支持/ 216/ (/ 65536/ )/ 个/ 变量/ ./ 216/ 个/ 变量/ 对于/ 一些/ 应用领域/ 来说/ 显然/ 太小/ ,/ 例如/ 对于/ 命题/ 公式/ 可/ 满足/ 问题/ (/ SAT/ )/ ./ 为了/ 提高/ 求解/ SAT/ 问题/ 的/ 效率/ ,/ Franco/ [/ 5/ ]/ 把/ BDD/ 作为/ 预处理/ 工具/ ,/ 而/ SAT/ 问题/ 中/ 公式/ 的/ 变量/ 数/ 可能/ 是/ 10/ 万级/ 甚至/ 100/ 万级/ ;/ 作者/ 在/ 研究/ 安全/ 协议/ 验证/ [/ 6/ ]/ 问题/ 时/ ,/ 为了/ 提高/ 处理速度/ 和/ 压缩/ 空间/ ,/ 在/ 生成/ 验证/ 规范/ 过程/ 中/ 使用/ BDD/ 来/ 表示/ 中间/ 结果/ ,/ 而/ 其/ 变量/ 数/ 也/ 很/ 可能/ 超过/ 216/ 个/ ./ 所以/ 216/ 这个/ 变量/ 上限/ 极大/ 地/ 限制/ 了/ BDD/ 包/ 能够/ 处理/ 的/ 问题/ 规模/ ,/ 从而/ 限制/ 了/ BDD/ 包/ 的/ 应用/ ./ 因此/ 一个/ 高效/ 的/ 可/ 处理/ 大规模/ 变量/ 的/ BDD/ 包/ 成为/ 一种/ 现实/ 需求/ ./ 本文/ 给出/ 了/ 一个/ BDD/ 包/ 的/ 实现/ ,/ 其/ 主要/ 优点/ 或/ 目标/ 体现/ 在/ :/ 用/ 32/ 位/ 比特/ 表示/ 变量/ ,/ 即可/ 处理/ 变量/ 数/ 达到/ 232/ ;/ 速度/ 可比/ 目前/ 可/ 获得/ 的/ 最好/ 的/ BDD/ 包/ ;/ 实现/ 目前/ BDD/ 包/ 的/ 所有/ 重要/ 算子/ ;/ 用/ 标准/ C++/ 实现/ ,/ 做到/ 代码/ 简洁/ ,/ 接口/ 明确/ ,/ 便于/ 用户/ 使用/ (/ 目前/ 开源/ 的/ 高效/ BDD/ 包/ 实现/ 都/ 较/ 复杂/ ,/ 甚至/ 与/ 平台/ 具有/ 一定/ 相关性/ ,/ 不/ 方便/ 用户/ 使用/ )/ ./ 第/ 2/ 节/ 给出/ BDD/ 及/ 经典/ BDD/ 包/ 高效/ 实现/ 的/ 扼要/ 介绍/ ;/ 第/ 3/ 节/ 给出/ 新/ BDD/ 包/ 的/ 实现/ 技术/ ;/ 第/ 4/ 节/ 给出/ 实验/ 结果/ ;/ 第/ 5/ 节/ 讨论/ 相关/ 工作/ ,/ 总结/ 全文/ ,/ 并/ 指出/ 下/ 一步/ 工作/ ./ 2/ 二叉/ 判定/ 图/ BDD/ 是/ 一种/ 表示/ 布尔/ 函数/ 的/ 高效/ 方法/ ./ 它/ 首先/ 是/ 作为/ 二叉/ 判定/ 树/ (/ BinaryDecisionTrees/ ,/ BDT/ )/ 被/ 提出/ 的/ ./ 在/ BDT/ 中/ ,/ 每个/ 非/ 终结/ 节点/ 被/ 布尔/ 变量/ x/ ,/ y/ ,/ z/ ,/ …/ 标注/ (/ 记为/ var/ (/ v/ )/ ,/ v/ 为/ 节点/ )/ ,/ 终结/ 节点/ 用/ 1/ 或/ 0/ 标注/ ,/ 每个/ 非/ 终结/ 节点/ v/ 有/ 两个/ 后继/ 节点/ ,/ 记为/ low/ (/ v/ )/ (/ 当/ v/ 赋值/ 0/ 时/ )/ 和/ high/ (/ v/ )/ (/ 当/ v/ 赋值/ 1/ 时/ )/ ./ BDT/ 不是/ 布尔/ 函数/ 的/ 高效/ 简洁/ 表达方法/ ,/ 因为/ 它/ 大小/ 和/ 真值表/ 一样/ ./ Bryant/ 在/ 文献/ [/ 9/ ]/ 中/ 阐明/ 如何/ 通过/ 使用/ 两个/ 限制/ 来/ 得到/ BDD/ 的/ 规范/ 表达/ :/ 首先/ ,/ 变量/ 出现/ 的/ 顺序/ 要/ 保持一致/ ;/ 其次/ ,/ 不/ 存在/ 同构/ 的/ 子树/ 和/ 多余/ 的/ 节点/ ./ 概括/ 起来/ ,/ 有/ 3/ 种/ 方法/ 可/ 得到/ BDD/ 的/ 简洁/ 规范/ 形式/ :/ (/ 1/ )/ 删除/ 多余/ 终结/ 节点/ :/ 只/ 留下/ 一个/ (/ 1/ 或/ 0/ ,/ 或/ 两者/ )/ 终结/ 节点/ ,/ 删除/ 其余/ 终结/ 节点/ ,/ 并/ 使/ 指向/ 被/ 删除/ 终结/ 节点/ 的/ 连接/ 指向/ 剩下/ 的/ 相应/ 节点/ ./ (/ 2/ )/ 删除/ 多余/ 的/ 非/ 终结/ 节点/ :/ 如果/ 一个/ 节点/ n/ 的/ Then/ 和/ Else/ 边/ 都/ 指向/ 节点/ m/ ,/ 则/ 删除/ n/ 节点/ ,/ 并且/ 把/ 指向/ 它/ 的/ 所有/ 连接/ 都/ 指向/ m/ 节点/ ./ (/ 3/ )/ 如果/ 二个/ 非/ 终结/ 节点/ u/ 和/ v/ 有/ var/ (/ u/ )/ =/ var/ (/ v/ )/ ,/ low/ (/ u/ )/ =/ low/ (/ v/ )/ 并且/ high/ (/ u/ )/ =/ high/ (/ v/ )/ ,/ 则/ 删除/ u/ 或/ v/ ,/ 并且/ 重定向/ 所有/ 指向/ 它/ 的/ 连接/ 指向/ 另/ 一/ 节点/ ./ 重复/ 上述/ 方法/ ,/ 直到/ BDD/ 的/ 大小/ 不再/ 改变/ ,/ 则/ 得到/ BDD/ 的/ 唯一/ 规范/ 表示/ (/ ROBDD/ )/ [/ 9/ ]/ ./ 这/ 可/ 通过/ 一从/ 底向上/ 的/ 过程/ 得到/ ,/ 时间/ 复杂度/ 是/ 线性/ 时间/ ./ 经典/ 的/ BDD/ 包/ 的/ 高效/ 实现/ 主要/ 采用/ 了/ 以下/ 几项/ 技术/ [/ 10/ ]/ ./ 2.1/ 节点/ 的/ 表示/ 节点/ 的/ 结构/ 中/ 主要/ 包括/ 变量/ 以及/ 两个/ 后继/ 节点/ Then/ 和/ Else/ ./ 我们/ 一般/ 称该/ 变量/ 为/ 顶/ 变量/ (/ TopVariable/ )/ ./ 在/ BDD/ 中/ 每个/ 节点/ 都/ 表示/ 一个/ 布尔/ 函数/ ,/ 而/ 顶/ 变量/ 就/ 表示/ 在/ 整个/ 布尔/ 函数/ 中/ 最小/ 的/ 变量/ ./ 这种/ 节点/ 的/ 定义/ 方式/ ,/ 思想/ 主要/ 来自/ ITE/ (/ If/ -/ Then/ -/ Else/ )/ 算子/ ./ ITE/ (/ If/ -/ Then/ -/ Else/ )/ 算子/ F/ ,/ G/ ,/ H/ 为/ 布尔/ 函数/ ,/ ITE/ (/ F/ ,/ G/ ,/ H/ )/ 定义/ 如下/ :/ ITE/ (/ F/ ,/ G/ ,/ H/ )/ =/ F/ ×/ G/ +/ ~/ F/ ×/ H/ ;/ 基本/ 的/ 二元/ 逻辑运算/ 都/ 可以/ 通过/ ITE/ 运算/ 来/ 表示/ ,/ 因此/ 现有/ 的/ 高效/ BDD/ 包都/ 把/ ITE/ 算子/ 作为/ 实现/ 核心/ ,/ 即/ 把/ 每个/ 节点/ 都/ 表示/ 为/ ITE/ (/ v/ ,/ Then/ ,/ Else/ )/ ,/ 当/ 变量/ v/ 取值/ 为/ 1/ 时该/ 布尔/ 函数/ 等价/ 于/ Then/ 节点/ 表示/ 的/ 布尔/ 函数/ ,/ 否则/ 等价/ 于/ Else/ 节点/ 表示/ 的/ 布尔/ 函数/ ,/ 例如/ :/ A/ +/ B/ +/ C/ =/ ITE/ (/ A/ ,/ 1/ ,/ ITE/ (/ B/ ,/ 1/ ,/ ITE/ (/ C/ ,/ 1/ ,/ 0/ )/ )/ )/ ./ ITE/ 实际上/ 是/ 一个/ 递归/ 的/ 运算/ ,/ 它/ 的/ 实现/ 过程/ 如下/ 所示/ ./ Page3ITE/ (/ F/ ,/ G/ ,/ H/ )/ If/ 是/ 终结/ 情况/ ElseIf/ 在/ 计算/ 表中/ 找到/ 该/ 节点/ (/ F/ ,/ G/ ,/ H/ )/ ElseENDIF2/ ./ 2/ 唯一/ 表在/ BDD/ 的/ 生成/ 过程/ 中/ 会/ 产生/ 大量/ 的/ 节点/ ,/ 能够/ 有效/ 地/ 管理/ 这些/ 节点/ 对于/ 实现/ 一个/ 高效/ 的/ BDD/ 包是/ 非常/ 重要/ 的/ ./ 而/ 唯一/ 表/ (/ UniqueTable/ )/ 的/ 作用/ 就是/ 管理/ BDD/ 中/ 所有/ 的/ 节点/ ./ 为了/ 维持/ BDD/ 的/ 规范性/ ,/ 唯一/ 表/ 一般/ 是/ 采用/ 哈希/ 表/ 的/ 结构/ ,/ 它/ 将/ 一个/ 三元组/ (/ v/ ,/ G/ ,/ H/ )/ 同/ 节点/ F/ =/ (/ v/ ,/ G/ ,/ H/ )/ 映射/ ./ 每个/ 节点/ 在/ 唯一/ 表中/ 存在/ 一个/ 入口/ ,/ 即/ 每个/ 节点/ 在/ 唯一/ 表中/ 都/ 有/ 一个/ 唯一/ 的/ ID/ (/ 索引/ )/ ,/ 所以/ 当/ 添加/ 一个/ 节点/ 时/ ,/ 需要/ 对/ 唯一/ 表/ 进行/ 查找/ ,/ 判断/ 该/ 节点/ 是否/ 已经/ 存在/ ./ 若/ 存在/ 则/ 将/ 该/ 节点/ 返回/ ,/ 否则/ 添加/ 新/ 节点/ ,/ 以此/ 来/ 维持/ BDD/ 的/ 规范性/ ./ 唯一/ 表/ 可以/ 通过/ 这种/ 方式/ 建立/ 一个/ 多根/ 的/ BDD/ 节点/ 图来/ 表示/ 出/ 所有/ 用户/ 布尔/ 函数/ ./ 2.3/ 计算/ 表在/ 生成/ BDD/ 的/ 过程/ 中/ 会/ 产生/ 很多/ 的/ 中间/ 结果/ ,/ 计算/ 表/ (/ ComputedTable/ )/ 就是/ 一个/ 存储/ 运算/ 结果/ 的/ 哈希/ 表/ ./ 它/ 将/ 一个/ 三元组/ (/ F/ ,/ G/ ,/ H/ )/ 同该/ 操作/ 的/ 结果/ 进行/ 映射/ ./ 当/ 构建/ BDD/ 节点/ 的/ 时候/ ,/ 如果/ ITE/ (/ F/ ,/ G/ ,/ H/ )/ 已经/ 在/ 计算/ 表中/ ,/ 并且/ 该/ 结果/ 已经/ 找到/ ,/ 就/ 可以/ 快速/ 地/ 将/ 结果/ 返回/ 而/ 不/ 需要/ 进行/ 重新/ 计算/ ./ 因此/ 计算/ 表/ 可以/ 有效/ 地/ 提高/ 运算/ 的/ 速度/ ./ 但/ 在/ 处理/ 冲突/ 的/ 方式/ 上/ ,/ 它同/ 唯一/ 表/ 有所不同/ ./ 唯一/ 表中/ 处理/ 冲突/ 的/ 方式/ 是/ 产生/ 一个/ 冲突/ 链/ ,/ 而/ 计算/ 表/ 为了/ 节省/ 运算/ 中/ 消耗/ 的/ 空间/ ,/ 它/ 并/ 不/ 存储/ 所有/ 的/ 运算/ 结果/ ,/ 而是/ 将/ 旧/ 的/ 结果/ 冲掉/ ,/ 并/ 存储/ 新/ 的/ 结果/ ./ 2.4/ 垃圾/ 回收/ 机制/ 为了/ 节省/ 空间/ ,/ 必须/ 对/ 死/ 节点/ 进行/ 删除/ ./ 文献/ [/ 9/ ]/ 中/ 提到/ 垃圾/ 回收/ (/ GarbageCollection/ )/ 虽然/ 会/ 消耗/ 一定/ 的/ 时间/ 但会/ 节省/ 出/ 大量/ 的/ 空间/ ,/ 所以/ 应该/ 适当/ 地/ 调用/ 垃圾/ 回收/ ./ 在/ 执行/ 垃圾/ 回收/ 过程/ 中/ 对于/ 是否/ 删除/ 某/ 节点/ ,/ 判定/ 的/ 标准/ 是/ 该/ 节点/ 的/ 参考/ 次数/ (/ RefCount/ )/ ./ 当/ 垃圾/ 回收/ 启动/ 的/ 时候/ 会/ 删除/ 掉/ 所有/ 参考/ 次数/ 等于/ 0/ 的/ 节点/ ,/ 即/ 死/ 节点/ ./ 当死/ 节点/ 的/ 个数/ 达到/ 一定/ 程度/ 的/ 时候/ 就/ 启动/ 垃圾/ 回收/ 机制/ 将/ 所有/ 死/ 节点/ 进行/ 删除/ ./ 对/ 死/ 节点/ 参考/ 次数/ 的/ 更新/ 是/ 一个/ 递归/ 运算/ ./ 如果/ 节点/ 的/ 参考/ 次数/ 更新/ 为/ 0/ 时/ ,/ 它/ 的/ Then/ ,/ Else/ 下/ 的/ 所有/ 节点/ 的/ 参考/ 次数/ 也/ 会/ 递归/ 地/ 减少/ ./ 当/ 查询/ 计算/ 表/ 返回/ 的/ 是/ 死/ 节点/ (/ 还/ 没有/ 被/ 删除/ )/ 的/ 时候/ ,/ 会/ 执行/ 复苏/ 操作/ ,/ 将/ 该/ 节点/ 下/ 的/ 所有/ 死/ 节点/ 复苏/ ./ 2.5/ 补边/ 在/ BDD/ 运算/ 中/ 可能/ 会/ 产生/ 节点/ G/ 和/ 节点/ ~/ G/ (/ G/ 的/ 取反/ 操作/ )/ ,/ 二者/ 除了/ 终端/ 节点/ 互换/ 以外/ ,/ 其他/ 性质/ 都/ 是/ 一样/ ,/ 因此/ 补边/ (/ ComplementEdges/ )/ 作为/ 一种/ 能够/ 有效/ 提高/ 空间/ 利用率/ 的/ 方法/ 被/ 提出/ 来/ ./ 在/ 生成/ 过程/ 中/ 只/ 对/ G/ 分配/ 空间/ ,/ 对/ ~/ G/ 不再/ 额外/ 分配/ 空间/ ,/ 只/ 需要/ 对/ 节点/ 指针/ 的/ 最后/ 一位/ 进行/ 标识/ ,/ 如果/ 最后/ 一位/ 为/ 1/ 就是/ ~/ G/ ,/ 否则/ 为/ G/ ./ 3/ 新/ BDD/ 包/ 的/ 高效/ 实现/ 技术/ 主要/ 体现/ 在/ 几个/ 关键技术/ 上/ :/ 节点/ 表示/ 、/ 唯一/ 表/ 、/ 垃圾/ 回收/ 、/ 计算/ 表等/ ./ 具体/ 如下/ ./ 3.1/ BDD/ 节点/ 的/ 表示/ structDDNode/ {/ intVar/ ;/ intRefCount/ ;/ intThen/ ;/ intElse/ ;/ intNext/ ;/ }/ ./ 在/ 经典/ 的/ BDD/ 包/ 实现/ 中/ ,/ 为了/ 节省/ 空间/ (/ 从而/ 提高/ 速度/ )/ 往往/ 把/ Var/ (/ 变量/ 编号/ )/ 和/ RefCount/ (/ 参考/ 次数/ )/ 合/ 在/ 一个/ int/ 中/ ,/ Var/ 被/ 分配/ 16/ 比特/ ,/ Ref/ -/ Count/ 被/ 分配/ 不/ 超过/ 16/ 个/ 比特/ ./ 所以/ 当/ RefCount/ 超过/ 216/ 时/ ,/ 该/ 节点/ 将/ 永远/ 不会/ 被/ 删除/ ./ 而/ 这里/ ,/ RefCount/ 用/ 32/ 个/ 比特/ 表示/ ,/ 这样/ 死/ 节点/ 不/ 被/ 删除/ 的/ 可能性/ 极小/ ,/ 从而/ 提高/ 空间/ 利用率/ ./ DDNode/ 的/ 总长度/ 是/ 20/ 个/ 字节/ ./ 同时/ 使用/ 了/ 补边/ 技术/ ,/ 即用/ 节点/ 地址/ 最低/ 比特/ 位/ 表示/ 该/ BDD/ 是否/ 为/ 补/ ./ 3.2/ 唯一/ 表同/ 传统/ 思想/ 不同/ 的/ 是/ 我们/ 并/ 没有/ 直接/ 对/ 唯一/ 表/ Page4/ 采用/ 哈希/ 表/ 的/ 结构/ 而是/ 先/ 将/ 它/ 进行/ 划分/ ./ 划分/ 的/ 标准/ 就是/ 节点/ 的/ 顶/ 变量/ 的/ 不同/ ,/ 根据/ 不同/ 将/ 它/ 划分/ 为/ 多个/ 模块/ (/ 模块/ 的/ 个数/ 等于/ 变量/ 个数/ )/ ,/ 其中/ 每个/ 模块/ 都/ 采用/ 哈希/ 表/ 的/ 结构/ ./ 它/ 的/ 结构/ 如下/ .#/ defineDDint/ // // DDNode/ 地址/ typedefstructUTableNodeStruct/ {/ DD/ / Slot/ ;/ // // 内存/ 块/ ;/ DDNode/ 地址/ 集合/ intSlotSize/ ;/ // // 内存/ 块/ 长度/ intLoadCount/ ;/ // // 填充/ 个数/ intShiftSize/ ;/ // // 偏移/ 值/ }/ UTableNode/ ;/ 当/ 插入/ 新/ 的/ 节点/ 时/ ,/ 我们/ 不再/ 将/ 一个/ 三元组/ (/ v/ ,/ G/ ,/ H/ )/ 同/ 节点/ F/ =/ (/ v/ ,/ G/ ,/ H/ )/ 直接/ 映射/ ,/ 而是/ 首先/ 根据/ 节点/ 顶/ 变量/ 的/ 不同/ ,/ 将/ 节点/ 划分/ 到/ 唯一/ 表/ 的/ 不同/ 模块/ 中/ ,/ 然后/ 根据/ (/ G/ ,/ H/ )/ 将/ 该/ 节点/ 映射/ 到/ 指定/ 模块/ 的/ 哈希/ 表中/ ./ 我们/ 这样/ 做/ 的/ 好处/ 主要/ 是/ 先/ 通过/ 顶/ 变量/ 将/ 节点/ 最大/ 限度/ 分散/ 开/ ,/ 避免/ 由于/ 节点/ 集中/ 而/ 造成/ 冲突/ 链/ 过长/ 的/ 问题/ ,/ 从而/ 提高/ 节点/ 查找/ 效率/ ./ 并且/ 每个/ 哈希/ 表/ 的/ 映射/ 只有/ 两个/ 变量/ ,/ 这样/ 将/ 有益于/ 提高/ 查找/ 命中率/ ./ 我们/ 将/ 每个/ 模块/ 的/ SlotSize/ 初始/ 为/ 一个/ 较/ 小/ 的/ 值/ (/ / 256/ )/ ,/ 当/ LoadCount/ 达到/ 一定/ 程度/ 时/ 再/ 对/ 它/ 进行/ 扩容/ ,/ 这样/ 可以/ 有效/ 地/ 节省/ 空间/ ,/ 提高/ 空间/ 的/ 利用率/ ./ 另外/ 由于/ 采用/ 的/ 是/ 内存/ 连续/ 分配/ 的/ 技术/ ,/ 使得/ 查找/ 过程/ 比/ 采用/ 链表/ 的/ 方式/ 更/ 节省时间/ ./ 相对/ 于/ 当今/ 的/ 高速/ CPU/ ,/ 主存/ 的/ 延迟/ 是/ BDD/ 包/ 性能/ 的/ 主要/ 瓶颈/ [/ 11/ ]/ ./ 所以/ 对于/ BDD/ 节点/ ,/ 我们/ 采用/ 了/ 内存/ 分片/ 分配/ 的/ 技术/ 来/ 实现/ ,/ 主要/ 思想/ 如下/ ./ (/ a/ )/ 初始化/ :/ 分配/ 连续/ k/ 兆/ 空间/ (/ 比如/ k/ =/ 50/ )/ ;/ (/ b/ )/ 新/ 增加/ 节点/ 时/ ,/ 如果/ 现有/ 空间/ 足够/ ,/ 则/ 插/ (/ c/ )/ 新/ 连续/ 分配/ k/ 兆/ 空间/ ,/ 插入/ 新增/ 节点/ ./ 新增/ 节点/ 算法/ 伪/ 代码/ 如下/ :/ Find/ _/ or/ _/ Add/ _/ Unique/ _/ Table/ (/ v/ ,/ A/ ,/ B/ )/ // // v/ 是/ 变量/ ,/ A/ 、/ B/ 为/ BDD/ 节点/ pos/ =/ 该/ 节点/ 在/ 唯一/ 表中/ 的/ 位置/ R/ =/ 在/ pos/ 位置/ 下/ 查找/ 该/ 节点/ IfR/ 不为/ 空/ ,/ 即该/ 节点/ 已经/ 存在/ ReturnREndifIf/ 装载/ 率/ 超过/ 阈值/ 重新分配/ 更大/ 的/ 空间/ ;/ EndifNode/ =/ 从/ 节点/ 管理器/ 中/ 获取/ 空闲/ 节点/ 位置/ 设置/ 节点/ Node/ 属性/ 将/ 该/ 节点/ 插入/ 到/ 唯一/ 表中/ ReturnNode/ 入/ ,/ 否则/ 转/ (/ c/ )/ ;/ 这/ 使得/ 内存/ 的/ 使用/ 是/ 成块/ 递增/ 的/ ,/ 在/ 一定/ 程度/ 上/ 保证/ 节点/ 在/ 内存/ 中距离/ 较近/ 和/ 满足/ 时间/ 序/ (/ 即子/ 节点/ 在/ 父/ 节点/ 之前/ 创建/ )/ ./ 这样/ 做/ 的/ 好处/ 主要/ 体现/ 在/ 提高/ CPUCache/ 的/ 命中率/ ,/ 从而/ 提高/ BDD/ 运算/ 速度/ [/ 11/ ]/ ./ 3.3/ 垃圾/ 回收/ 在/ 创建/ BDD/ 的/ 过程/ 中/ 会/ 产生/ 大量/ 的/ 垃圾/ 节点/ ,/ 在/ 传统/ 的/ 高效/ 实现/ 过程/ 中/ ,/ 为了/ 节省/ 空间/ ,/ 提高/ 查找/ 速度/ ,/ 当死/ 节点/ 的/ 个数/ 达到/ 一定/ 程度/ 的/ 时候/ ,/ 就/ 启动/ 垃圾/ 回收/ 机制/ 将/ 所有/ 死/ 节点/ 进行/ 删除/ ./ 但/ 这种/ 对/ 内存/ 的/ 不断/ 分配/ 和/ 释放/ 过程/ 往往/ 会/ 造成/ 空间/ 利用率/ 不高/ ./ 为了/ 提高/ 内存/ 的/ 重用/ 性/ ,/ 我们/ 并/ 没有/ 在/ 内存/ 中/ 真正/ 删除/ 死/ 节点/ ,/ 只是/ 做/ 了/ 一个/ 标记/ ,/ 当/ 需要/ 分配/ 新/ 节点/ 时/ ,/ 根据/ 这个/ 标记/ ,/ 可/ 判断/ 是否/ 重用/ 该/ 节点/ 空间/ ./ 从而/ 避免/ 了/ 对/ 内存/ 的/ 不断/ 释放/ 和/ 申请/ ./ 垃圾/ 回收/ 是/ 以/ 牺牲/ 时间/ 来/ 换取/ 空间/ 的/ 方法/ ,/ 所以/ 对/ 垃圾/ 回收/ 的/ 调用/ 必须/ 有/ 一定/ 的/ 限制/ ./ 因此/ 我们/ 为了/ 保证/ 空间/ 利用率/ ,/ 同时/ 方便/ 用户/ 使用/ ,/ 在/ 初始/ 情况/ 下/ 允许/ 用户/ 自主/ 决定/ 垃圾/ 回收/ 的/ 调用/ 条件/ ,/ 在/ 计算/ 过程/ 中/ ,/ 根据/ 节点/ 的/ 产生/ 情况/ 对/ 该/ 条件/ 进行/ 适当/ 调节/ ./ 这样/ 既/ 不会/ 高频率/ 地/ 调用/ 垃圾/ 回收/ ,/ 又/ 不会/ 因/ 垃圾/ 节点/ 过多/ 而/ 导致/ 空间/ 不足/ 的/ 情况/ ,/ 最大/ 限度/ 地/ 提高/ 了/ 空间/ 利用率/ ./ 算法/ 伪/ 代码/ 如下/ :/ Garbage/ _/ Collection/ (/ )/ For/ 每个/ 内存/ 分片/ Endfor/ // // -/ -/ -/ -/ -/ -/ -/ -/ -/ 处理/ 计算/ 表/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ // // For/ 计算/ 表中/ 每个/ 位置/ Endfor/ // // -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ 处理/ 唯一/ 表/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ -/ // // For/ 唯一/ 表中/ 每个/ 位置/ Endfor3/ ./ 4/ 计算/ 表/ 尽管/ 我们/ 采用/ 了/ 内存/ 分片/ 分配/ ,/ 但是/ 在/ 计算/ 时/ ,/ 仍然/ 以/ 节点/ 地址/ 作为/ 操作数/ ,/ 所以/ 计算/ 表/ 的/ 实现/ 仍/ Page5/ 然与/ 经典/ 的/ BDD/ 包/ 高效/ 实现/ 保持一致/ [/ 10/ ]/ ./ 4/ 实验/ 结果/ 根据/ 本文/ 提出/ 的/ 技术/ 思想/ ,/ 我们/ 用/ 标准/ C++/ 实现/ 了/ 一个/ BDD/ 包/ (/ 记为/ MiniBDD/ ①/ )/ ,/ 代码/ 量/ 接近/ 1200/ 行/ ./ 我们/ 实验/ 环境/ 是/ Pentium4PC2/ ./ 8/ ,/ 1GB/ 内存/ ,/ Linux/ 操作系统/ ./ 对比/ 对象/ 是/ 著名/ 的/ BDD/ 包/ —/ —/ —/ CUDD/ (/ http/ :/ // // vlsi/ ./ colorado/ ./ edu/ // ~/ fabio/ // ,/ 版本/ 2.4/ ./ 1/ )/ ./ 测试用例/ 为/ SuperscalarSuite1/ ./ 0/ (/ trace/ 格式/ )/ ②/ ./ 实验/ 结果/ 如表/ 1/ 所示/ ,/ 并/ 图形化/ 显示/ 为/ 图/ 1/ ./ 测试用例/ 时间/ dlx2/ _/ cc/ _/ bug01dlx2/ _/ cc/ _/ bug02dlx2/ _/ cc/ _/ bug03dlx2/ _/ cc/ _/ bug04dlx2/ _/ cc/ _/ bug05dlx2/ _/ cc/ _/ bug06dlx2/ _/ cc/ _/ bug07dlx2/ _/ cc/ _/ bug08dlx2/ _/ cc/ _/ bug09dlx2/ _/ cc/ _/ bug10dlx2/ _/ cc/ _/ bug11dlx2/ _/ cc/ _/ bug12dlx2/ _/ cc/ _/ bug13dlx2/ _/ cc/ _/ bug14dlx2/ _/ cc/ _/ bug15dlx2/ _/ cc/ _/ bug16dlx2/ _/ cc/ _/ bug17dlx2/ _/ cc/ _/ bug18dlx2/ _/ cc/ _/ bug19dlx2/ _/ cc/ _/ bug20/ 从表/ 1/ 可以/ 看出/ ,/ MiniBDD/ 运算/ 速度/ 和/ CUDD/ 非常/ 接近/ (/ 平均/ 时间/ 之比为/ 1.0651/ ,/ 图/ 1/ 中/ 大部分/ 点落/ 于/ 主/ 对角线/ 附近/ 区域/ 内/ )/ ./ 内存/ 方面/ :/ 二者/ 节点/ 数/ 一样/ ,/ MiniBDD/ 每个/ 节点/ 20/ 字节/ (/ 232/ 个/ 变量/ 规模/ )/ ,/ 而/ CUDD/ 为/ 16/ 个/ 字节/ (/ 216/ 个/ 变量/ 规模/ )/ ./ 由于/ MiniBDD/ 采取/ 的/ 是/ 内存/ 分片/ 分配/ 策略/ ,/ 因此/ MiniBDD/ 的/ 内存/ 消耗/ 可能/ 会/ 比/ 4/ ×/ NodeCount/ 多/ 一部分/ ,/ 多出/ 的/ 这/ 一部分/ 最多/ 是/ 内存/ 分片/ 的/ 大小/ ,/ 平均/ 情况/ 下/ ,/ 多出/ 的/ 部分/ 是/ 内存/ 分片/ 大小/ 的/ 一半/ ./ 当然/ ,/ 内存/ 分片/ 大小/ 是/ 可控/ 的/ ,/ 我们/ 可以/ 根据/ 实际/ 应用环境/ 适当/ 调节/ 分片/ 大小/ ,/ 在/ 保证/ 性能/ 的/ 情况/ 下/ 尽量减少/ 内存/ 的/ 消耗/ ./ 5/ 相关/ 工作/ 及/ 结论/ 为了/ 在/ BDD/ 操作/ 中/ 提高/ 高速缓存/ 的/ 性能/ ,/ Long/ 在/ 文献/ [/ 11/ ]/ 中/ 提出/ 了/ 节点/ 在/ 内存/ 中/ 连续/ 分配/ 的/ 策略/ ,/ 但/ 没有/ 做/ 分片/ 处理/ ,/ 同时/ 所有/ 节点/ 都/ 必须/ 严格遵守/ 在/ 时间/ 序上/ 的/ 一致性/ ./ 这样一来/ ,/ 在/ 垃圾/ 回收/ 的/ 时候/ ,/ 工作量/ 较大/ ,/ 并且/ 非常复杂/ ./ Janssen/ [/ 12/ ]/ 也/ 采用/ 类似/ 内存/ 分配/ 策略/ ,/ 但/ 不再/ 使用/ 指针/ 来/ 标注/ 节点/ ,/ 而是/ 用/ 一个/ 和/ 节点/ 位置/ 相一致/ 的/ 整数/ 表示/ ,/ 同时/ 也/ 要求/ 所有/ 节点/ 都/ 必须/ 在/ 时间/ 序上/ 保持一致/ ,/ 垃圾/ 回收/ 同样/ 非常复杂/ ./ 二者/ 的/ BDD/ 包可/ 处理/ 的/ 变量/ 个数/ 上限/ 都/ 是/ 216/ ./ 为了/ 突破/ 现有/ 高效/ BDD/ 包对/ 变量/ 个数/ 的/ 限制/ (/ 不/ 大于/ 216/ )/ ,/ 本文/ 给出/ 了/ 一个/ 最/ 多/ 支持/ 232/ 个/ 变量/ 的/ 高效/ BDD/ 包/ 的/ 实现/ 技术/ ./ 该/ BDD/ 包对/ 空间/ 的/ 利用率/ 很/ 高/ ,/ 主要/ 体现/ 在/ :/ (/ 1/ )/ 在/ 内存/ 上/ 采取/ 分片/ 分配/ ;/ (/ 2/ )/ 垃圾/ 回收/ 过程/ 不/ 删除/ 节点/ (/ 只是/ 将/ 死/ 节点/ 进行/ 标识/ )/ 这种/ 轻量级/ 的/ 垃圾/ 回收/ 机制/ ;/ (/ 3/ )/ 唯一/ 表/ 使用/ 动态/ 分配内存/ 的/ 方法/ ,/ 在/ BDD/ 的/ 生成/ 过程/ 中/ 根据/ 节点/ 产生/ 情况/ ,/ 自动/ 调节/ 该表/ 的/ 大小/ ./ 我们/ 使用/ 标准/ C++/ 完整/ 地/ 实现/ 了/ 一个/ 高效/ BDD/ 包/ —/ —/ —/ MiniBDD/ ./ MiniBDD/ 实现/ 简洁/ (/ C++/ 源代码/ 不到/ 1200/ 行/ )/ ,/ 实验/ 证明/ 其/ 性能/ 与/ 著名/ 的/ BDD/ 包/ —/ —/ —/ CUDD/ 的/ 最新/ 版本/ (/ 2.4/ ./ 1/ )/ 非常/ 接近/ (/ 时间/ 之比为/ 1.0651/ )/ ./ 在/ MiniBDD/ 基础/ 上/ ,/ 通过/ 实现/ 动态/ 计算/ 表/ 技术/ ,/ 我们/ 可以/ 得到/ 的/ 一个/ 更为/ 高效/ 版本/ 的/ BDD/ 包/ —/ —/ —/ CacBDD/ [/ 13/ ]/ ./ 因为/ 变量/ 顺序/ 会/ 直接/ 影响/ 到/ BDD/ 的/ 大小/ ,/ 所以/ 我们/ 下/ 一步/ 的/ 工作/ 重点/ 是/ 实现/ 变量/ 的/ 动态/ 排序/ [/ 14/ ]/ ./ 

