Page1/ 一种/ 面向/ 非/ 规则/ 引用/ 的/ Cell/ 多核/ 处理器/ 自/ 适应/ Cache/ 行/ 策略/ 曹倩/ 胡长军/ 张云星/ 朱于/ 畋/ (/ 北京科技大学/ 信息/ 工程学院/ 北京/ 100083/ )/ 摘要/ 非/ 规则/ 问题/ 是/ 大规模/ 并行/ 应用/ 中/ 普遍存在/ 和/ 影响/ 程序/ 效率/ 的/ 关键问题/ ,/ 软件/ Cache/ 是/ Cell/ 处理器/ 上/ 解决/ 该/ 问题/ 的/ 一种/ 普遍/ 手段/ ./ 鉴于/ 通常/ 的/ 软件/ Cache/ 忽略/ 了/ 非/ 规则/ 引用/ 的/ 内存/ 访问/ 模式/ ,/ 将/ Cache/ 行/ 设定/ 为/ 一个/ 固定/ 的/ 长度/ ,/ 而/ 加重/ 内存/ 带宽/ 负荷/ 及/ 制约/ Cache/ 利用率/ 的/ 问题/ ,/ 文中/ 提出/ 了/ 一种/ 自/ 适应/ 的/ Cache/ 行/ 算法/ ,/ 它/ 根据/ 非/ 规则/ 内存/ 访问/ 的/ 特点/ ,/ 在/ 程序执行/ 过程/ 中/ 不断/ 地/ 调整/ Cache/ 行/ 的/ 大小/ ,/ 因此/ 减少/ 了/ 传输/ 的/ 数据量/ ./ 同时/ ,/ 针对/ 不同/ 的/ Cache/ 行/ 大小/ ,/ 设计/ 了/ 一种/ 相应/ 的/ 软件/ Cache/ 结构/ —/ —/ —/ 混合/ 行/ 大小/ 的/ Cache/ ./ 它/ 包含/ 多种/ Tag/ 项/ 数组/ ,/ 每种/ Tag/ 项/ 数组/ 对应/ 于/ 一种/ Cache/ 行/ 大小/ ./ 该/ Cache/ 设计/ 是/ 一种/ 分级/ 的/ 结构/ ,/ 因为/ 当长/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 缺失/ 的/ 时候/ 直接/ 进行/ 缺失/ 处理/ ,/ 而/ 当/ 短/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 发生/ 缺失/ 的/ 时候/ 启动/ 缺失/ 处理/ ,/ 同时/ 检查/ 长/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 是否/ 命中/ ,/ 若/ 命中/ ,/ 则/ 终止/ 缺失/ 处理/ ./ 通过/ 对/ Tag/ 项/ 数组/ 的/ 分级/ 查找/ ,/ Cache/ 的/ 命中率/ 有/ 了/ 显著/ 的/ 提高/ ./ 除此之外/ ,/ 文中/ 提出/ 了/ 一种/ 新/ 的/ 行/ 索引/ 对齐/ 的/ Cache/ 替换/ 策略/ ,/ 它/ 能够/ 在/ 多种不同/ 的/ Cache/ 行/ 大小/ 并存/ 的/ 情况/ 下/ 实现/ LRU/ 替换/ 策略/ ./ 实验/ 表明/ 该文/ 提出/ 的/ 自/ 适应/ 的/ 软件/ Cache/ 行/ 策略/ 极大/ 地/ 减少/ 了/ 冗余/ 的/ 数据传输/ ,/ 提高/ 了/ Cache/ 的/ 命中率/ ./ 同时/ ,/ 与/ 固定/ 的/ 1024B/ ,/ 512B/ ,/ 256B/ ,/ 128B/ 的/ Cache/ 行/ 的/ 性能/ 相比/ ,/ 自/ 适应/ 的/ Cache/ 行/ 策略/ 的/ 执行/ 速度/ 分别/ 提高/ 了/ 28.9/ %/ ,/ 29.7/ %/ ,/ 32.1/ %/ 和/ 33.5/ %/ ./ 关键词/ 非/ 规则/ ;/ 混合/ ;/ 软件/ Cache/ ;/ 多核/ ;/ 编译/ 优化/ 1/ 引言/ Cell/ 处理器/ 是/ 一款/ 异构/ 多核/ 处理器/ ,/ 结构/ 如图/ 1/ 所示/ ./ 它/ 包含/ 一个/ 基于/ Power/ 架构/ 的/ 主/ 处理器/ PPE/ (/ PowerPCProcessorElement/ )/ 和/ 8/ 个/ 协同/ 处理器/ SPE/ (/ SynergisticProcessorElement/ )/ ./ PPE/ 是/ 一个/ 通用/ 的/ 双线/ 程/ 的/ 处理器/ ,/ 包含/ 两级/ 硬件/ Cache/ 结构/ ./ 每个/ SPE/ 包含/ 一个/ 软件/ 可控/ 的/ 256KB/ 的/ 本地/ 存储/ ,/ 但/ 不/ 具有/ 硬件/ Cache/ ./ SPE/ 依赖/ 直接/ 内存/ 访问/ (/ DirectMemoryAccess/ ,/ DMA/ )/ 操作/ 来/ 完成/ 主存/ 和/ 本地/ 存储/ 之间/ 的/ 数据传输/ ./ PPE/ 和/ 8/ 个/ SP/ E通/ 过/ 互联/ 总线/ EIB/ 和/ 主存储器/ 以及/ I/ // O/ 连接/ 在/ 一起/ ./ 内存/ 接口/ 控制器/ MIC/ 提供/ 了/ EIB/ 和/ 主存/ 之间/ 的/ 接口/ ./ 非/ 规则/ 问题/ 是/ 指/ 在/ 编译/ 时/ 无法/ 确定/ 内存/ 访问/ 情况/ ,/ 且/ 循环/ 界限/ 和/ 数组/ 引用/ 下标/ 不再/ 是/ 循环/ 控制变量/ 的/ 线性/ 表达式/ ./ 该类/ 问题/ 在/ 程序/ 中/ 的/ 一个/ 主要/ 体现/ 是/ 对/ 间接/ 数组/ 的/ 访问/ ,/ 如/ A/ [/ B/ [/ i/ ]/ ]/ ,/ 它/ 的/ 最大/ 特点/ 就是/ 内存/ 访问/ 的/ 非/ 连续性/ ./ 非/ 规则/ 引用/ 问题/ 在/ 实际/ 应用/ 中/ 普遍存在/ ,/ 如/ 大规模/ 油藏/ 数值/ 模拟/ 生产/ 系统/ (/ 见图/ 2/ )/ 、/ 分子/ 动力学/ (/ 见图/ 3/ )/ 和/ 流体力学/ 等/ ./ 非/ 规则/ 问题/ 作为/ 影响/ 大规模/ 科学计算/ 效率/ 的/ 关键因素/ 之一/ ,/ 其/ 优化/ 技术/ 对于/ 充分发挥/ 异构/ 多核/ 系统/ 的/ 计算能力/ 具有/ 重要/ 的/ 理论/ 和/ 现实意义/ ./ 图/ 2/ 油藏/ 数值/ 模拟程序/ 中/ 的/ 非/ 规则/ 计算/ 程序/ 片段/ 图/ 3/ 分子/ 动力学/ 中/ 计算/ 电子密度/ 的/ 程序/ 片段/ SPE/ 不能/ 直接/ 访问/ 系统/ 内存/ ,/ 而/ 需要/ 通过/ 显式/ 的/ DMA/ 操作/ 来/ 完成/ 主存/ 和/ 本地/ 存储/ 之间/ 的/ 数据传输/ ./ 而/ 每次/ SPE/ 对系统/ 存储器/ 中/ 变量/ 的/ 访问/ ,/ 如果/ 都/ 简单/ 地/ 通过/ 插入/ DMA/ 传输/ 指令/ 进行/ ,/ 那么/ SPE/ 将/ 在/ 等待/ 总线/ 数据/ 时空/ 转/ ,/ 数据总线/ 也/ 将/ 在/ SPE/ 处理/ 数据/ 时空/ 等/ ,/ SPE/ 的/ 利用效率/ 将/ 非常低/ ./ 如果/ 将/ 这些/ 数据/ 分块/ 传输/ 并存/ 放在/ 本地/ 存储/ 中/ 进行/ 重复/ 利用/ ,/ 将/ 有利于/ 提高/ 程序/ 性能/ ./ 所以/ ,/ 对于/ 非/ 规则/ 的/ 内存/ 访问/ 的/ 情况/ ,/ 运行/ 时/ 系统/ 采用/ 有效/ 的/ 软件/ Cache/ 技术/ 来/ 模拟/ 硬件/ Cache/ ,/ 便/ 可以/ 重用/ 本地/ 存储/ 中/ 临时/ 的/ 镜像/ 数据/ ,/ 减少/ 不必要/ 的/ DMA/ 操作/ ./ 因此/ 软件/ 实现/ 的/ Cache/ 成为/ Cell/ 处理器/ 上/ 解决/ 非/ 规则/ 问题/ 时/ 的/ 通用/ 手段/ ./ 但/ 现有/ 的/ 软件/ Cache/ 方案/ 通常/ 忽略/ 了/ 非/ 规则/ 内存/ 访问/ 的/ 特点/ 而/ 将/ Cache/ 行/ 设定/ 为/ 一/ 固定/ 长度/ ,/ 从而/ 加重/ 了/ 内存/ 带宽/ 负荷/ ,/ 制约/ 了/ Cache/ 的/ 利用率/ ./ 本文/ 将/ 提出/ 一种/ 自/ 适应/ 的/ Cache/ 行/ 策略/ ,/ 它/ 根据/ 非/ 规则/ 引用/ 的/ 特点/ 在/ 程序运行/ 过程/ 中/ 连续/ 地/ 、/ 自/ 适应/ 地/ 调整/ Cache/ 行/ 的/ 长度/ ./ 该/ 方案/ 首先/ 收集/ 非/ 规则/ 引用/ 访问/ 到/ 的/ 内存地址/ ,/ 如果/ 有/ 任意/ 两个/ 或/ 多个/ 地址映射/ 到/ 同/ 一条/ 长/ Cache/ 行/ 的/ 不同/ 短/ Cache/ 行中/ ,/ 则/ 这样/ 的/ 地址/ 被/ 记作长/ Cache/ 行/ 地址/ ,/ 其它/ 地址/ 则/ 被/ 记作/ 短/ Cache/ 行/ 的/ 地址/ ./ 当/ 地址/ 被/ 划分/ 之后/ ,/ 需要/ 查找/ Tag/ 项/ 数组/ (/ TagEntryArray/ )/ 以/ 判断/ 命中/ 或/ 缺失/ ./ 因此/ ,/ 我们/ 设计/ 了/ 一种/ 在/ Cell/ 多核/ 处理器/ 上/ 实现/ 的/ 软件/ Cache/ 结构/ —/ —/ —/ 混合/ 行/ 大小/ 的/ Cache/ (/ HybridLineSizePage3Cache/ ,/ HLSC/ )/ ./ 该/ 设计/ 基于/ 传统/ 的/ 四路/ 组/ 相联/ Cache/ ,/ 它/ 包含/ 了/ 多种/ Tag/ 项/ 数组/ (/ 方便/ 起/ 见/ ,/ 本文/ 中/ 给/ 的/ 图仅/ 包含/ 了/ 两种/ Cache/ 行/ )/ ,/ 每/ 一种/ Tag/ 项/ 数组/ 对应/ 一种/ Cache/ 行/ 大小/ ./ 该/ Cache/ 设计/ 是/ 分级/ 的/ ,/ 表现/ 为/ 当长/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 缺失/ 的/ 时候/ 直接/ 进行/ 缺失/ 处理/ ,/ 而/ 当/ 短/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 发生/ 缺失/ 的/ 时候/ 启动/ 缺失/ 处理/ ,/ 同时/ 检查/ 长/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 是否/ 命中/ ,/ 若/ 命中/ ,/ 则/ 立即/ 终止/ 缺失/ 处理/ ./ 经过/ 分级/ 地/ 查找/ Tag/ 项/ 数组/ ,/ Cache/ 的/ 命中率/ 有/ 了/ 明显/ 的/ 提高/ ./ 为了/ 在/ 多种/ Cache/ 行下/ 解决/ Cache/ 替换/ 问题/ ,/ 本文/ 对/ 最近/ 最久/ 未/ 使用/ (/ LeastRecentlyUnused/ ,/ LRU/ )/ Cache/ 替换/ 策略/ 进行/ 扩展/ ,/ 提出/ 一种/ 新/ 的/ 行/ 索引/ 对齐/ 的/ LRU/ 策略/ —/ —/ —/ IndAlign/ _/ LRU/ 策略/ ./ 它/ 引入/ 一个/ 链表/ 数组/ ,/ 其中/ 的/ 每个/ 链表/ 同时/ 对应/ 于长/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 的/ 一个组/ 和/ 短/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 的/ 多个/ 组/ ./ 链表/ 结点/ 的/ 数据/ 域/ 存储/ 了/ Cache/ 行/ 的/ 索引/ ,/ 通过/ 移动/ 结点/ 来/ 实现/ 多种不同/ Cache/ 行/ 的/ LRU/ 替换/ 策略/ ./ 为了/ 评估/ 自/ 适应/ 的/ Cache/ 行/ 策略/ 的/ 性能/ ,/ 我们/ 在/ Cell/ 处理器/ 上/ 实现/ 了/ HLSC/ 方案/ ,/ 并/ 与/ 传统/ 的/ 固定/ Cache/ 行/ 方案/ 以及/ 扩展/ 的/ 组/ 索引/ Cache/ (/ Extend/ -/ edSet/ -/ IndexCache/ ,/ ESC/ )/ 策略/ [/ 1/ ]/ 进行/ 了/ 比较/ ./ 实验/ 结果表明/ HLSC/ 策略/ 明显/ 地/ 提高/ 了/ Cache/ 命中率/ ,/ 极大/ 地/ 减少/ 了/ 传输/ 的/ 字节/ 总数/ ./ 与/ 扩展/ 的/ 组/ 索引/ Cache/ 中自/ 适应/ 的/ Cache/ 行/ 技术/ 相比/ ,/ 加速/ 比/ 可/ 达到/ 1.52/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 3/ 节/ 详细/ 提出/ 自/ 适应/ 的/ Cache/ 行/ 算法/ ;/ HLSC/ 的/ 结构/ 在/ 第/ 4/ 节作/ 具体/ 介绍/ ;/ 第/ 5/ 节对/ HLSC/ 的/ 操作/ 模型/ 进行/ 详细描述/ ;/ 第/ 6/ 节/ 应用/ 多种/ 测试用例/ 评估/ 自/ 适应/ 的/ Cache/ 行/ 策略/ 的/ 性能/ ;/ 最后/ 为/ 文章/ 的/ 结论/ 及下/ 一步/ 工作/ ./ 2/ 相关/ 工作/ 及/ 问题/ 分析/ Cell/ 多核/ 处理器/ 问世/ 之前/ ,/ 关于软件/ Cache/ 的/ 研究/ 已经/ 有/ 了/ 一些/ 成果/ [/ 2/ -/ 7/ ]/ ./ Miller/ 等/ 人/ [/ 2/ ]/ 提出/ 了/ 一种/ 软件/ Cache/ 设计/ ,/ 该/ 方案/ 自动/ 地/ 维护/ 部分/ 或/ 全部/ 的/ scratchpad/ 内存/ 作为/ Cache/ ./ 但/ 其/ 只/ 对/ 指令/ 进行/ 缓存/ ,/ 而/ 本文/ 提到/ 的/ 应用软件/ Cache/ 来/ 解决/ 非/ 规则/ 问题/ 主要/ 是/ 对/ 数据/ 进行/ 缓存/ ./ Moritz/ 等/ 人/ [/ 3/ -/ 4/ ]/ 设计/ 的/ Hotpage/ // FlexCache/ 需要/ 相当/ 精确/ 的/ 编译器/ 指针/ 分析/ 以/ 标记/ 出/ 可以/ 重用/ 某些/ 页/ 的/ 内存/ 引用/ ,/ 实现/ 起来/ 相当/ 复杂/ ./ Udayakumaran/ 等/ 人/ [/ 5/ ]/ 提出/ 的/ 软件/ Cache/ 方案/ 通过/ 代码/ profiling/ 技术/ 以及/ 内存/ 访问/ 的/ 频率/ 进行/ 代码/ 区域分析/ ,/ 根据/ 获得/ 的/ 信息/ 将/ 每个/ 基本块/ 赋予/ 一个/ 时间/ 戳/ ,/ 并/ 在/ 程序/ 的/ 特定/ 位置/ 插入/ 控制代码/ 以/ 实现/ 系统/ 内存/ 与/ Cache/ 之间/ 进行/ 数据传输/ ./ 这种/ 方法/ 对/ 静态/ 的/ 内存/ 访问/ 很/ 有效/ ,/ 但是/ 当/ 涉及/ 到/ 基于/ 指针/ 的/ 内存/ 访问/ 时该/ 方案/ 就/ 失效/ 了/ ./ 文献/ [/ 6/ -/ 7/ ]/ 中/ 软件/ Cache/ 的/ 设计/ 主要/ 是/ 为了/ 在/ 嵌入式/ 系统/ 中/ 减少/ 能耗/ ./ Witchel/ 等/ 人/ [/ 6/ ]/ 提出/ 了/ DirectAddressedCaches/ ,/ 它/ 依赖/ 硬件/ 记住/ Cache/ 行/ 的/ 准确/ 位置/ ,/ 因此/ 消除/ 了/ Tag/ 查找/ 的/ 开销/ ./ 但是/ 该/ 方案/ 需要/ 定义新/ 的/ 寄存器/ 将/ load/ // store/ 操作/ 跟/ 具体/ 的/ Cache/ 行/ 联系/ 起来/ ,/ 同时/ 还/ 需要/ 提供/ 新/ 的/ load/ // store/ 命令/ 才能/ 充分发挥/ 寄存器/ 的/ 作用/ ./ Fryman/ 等/ 人/ [/ 7/ ]/ 提出/ 了/ 软件/ Cache/ —/ —/ —/ SoftCache/ ,/ 它/ 基于/ 对/ 二进位/ 的/ 重写/ ,/ 需要/ 对/ 二进制/ 图/ 进行/ 完整/ 的/ 数据流/ 和/ 控制流/ 分析/ ,/ 因此/ 实现/ 起来/ 很/ 复杂/ ./ 具体/ 到/ Cell/ 多核/ 处理器/ ,/ 由于/ SPE/ 本身/ 没有/ 硬件/ 实现/ 的/ Cache/ ,/ 软件/ Cache/ [/ 8/ -/ 12/ ]/ 已经/ 成为/ 近几年/ 的/ 一个/ 研究/ 热点/ ./ Eichenberger/ 等/ 人/ [/ 8/ ]/ 提出/ 了/ 一个/ 在/ Cell/ 处理器/ 上用/ 软件/ 实现/ 的/ 传统/ 的/ 四路/ 组/ 相联/ 的/ Cache/ 设计/ ./ 该/ 设计/ 采用/ LRU/ 的/ Cache/ 替换/ 策略/ ,/ 以/ 单指令/ 多/ 数据/ (/ SIMD/ )/ 的/ 方式/ 在/ 组内/ 查找/ 是否/ 有/ 匹配/ ./ Balart/ 等/ 人/ [/ 9/ ]/ 设计/ 了/ 一种/ 面向/ Cell/ 处理器/ 的/ Cache/ ,/ 它/ 使得/ 用户/ 可以/ 确定/ 一个/ 代码/ 区域/ ,/ 从而/ 避免/ 了/ Cache/ 冲突/ ,/ 用户/ 还/ 可以/ 在/ 该/ 区域/ 中/ 对/ 多次/ 访问/ lookup/ 操作/ 以及/ misshandler/ 操作/ 进行/ 重排/ ,/ 从而/ 有效/ 地/ 将/ 计算/ 与/ 通信/ 重叠/ 起来/ ./ 该/ 方案/ 对于/ Cache/ 访问/ 时间/ 局部性/ 很/ 高/ 的/ 特定/ 循环/ 效率/ 很/ 好/ ,/ 但是/ 对/ 一般/ 的/ 循环/ 来讲/ ,/ 由于/ lookup/ 过程/ 需要/ 对/ 地址/ 执行/ 模/ 操作/ ,/ 从而/ 确定/ 对/ 多个/ 链表/ 中/ 的/ 哪/ 一个/ 进行/ 遍历/ ,/ 因此/ 实现/ 的/ 开销/ 很大/ ./ 文献/ [/ 10/ -/ 12/ ]/ 中/ 提到/ 了/ 在/ Cell/ 处理器/ 上/ 实现/ 一种/ 混合/ 的/ Cache/ 结构/ ./ 该/ 方案/ 首先/ 将/ 内存/ 访问/ 模式/ 划分/ 为/ 两类/ —/ —/ —/ 高/ 局部性/ 的/ 内存/ 访问/ 和/ 非/ 规则/ 的/ 内存/ 访问/ ,/ 然后/ 提出/ 一种/ 包含/ 两种/ Cache/ 结构/ 的/ 软件/ Cache/ 设计/ ,/ 不同/ 的/ Cache/ 结构/ 采用/ 不同/ 的/ Cache/ 替换/ 策略/ ./ 该/ 方案/ 需要/ 精确/ 的/ 内存/ 访问/ 的/ 分类/ ,/ 不但/ 引入/ 了/ 额外/ 的/ 内存/ 开销/ ,/ 实现/ 起来/ 比较复杂/ ./ 此外/ ,/ 它/ 侧重于/ 区分/ 规则/ 和/ 非/ 规则/ 的/ 内存/ 访问/ ,/ 而/ 忽视/ 了/ 非/ 规则/ 内存/ 访问/ 本身/ 的/ 数据/ 局部性/ ./ 以上/ 软件/ Cache/ 实现/ 的/ 共同点/ 是/ 忽略/ 了/ 非/ 规则/ 内存/ 访问/ 自身/ 所/ 表现/ 的/ 数据/ 局部性/ ,/ 而/ 将/ Cache/ 行/ Page4/ 设置/ 成/ 一个/ 固定/ 的/ 长度/ ,/ 因此/ 增加/ 了/ 冗余/ 的/ 数据传输/ ,/ 加重/ 了/ 内存/ 访问/ 带宽/ 的/ 负荷/ ,/ 从而/ 影响/ 了/ 非/ 规则/ 应用/ 的/ 整体/ 性能/ ./ 显然/ ,/ 采用/ 自/ 适应/ 的/ 调节/ Cache/ 行/ 大小/ 的/ 策略/ ,/ 会/ 极大地提高/ SPE/ 上/ 本地/ 存储/ 的/ 利用率/ ,/ 减少/ 冗余/ 数据/ 的/ 传输/ ./ 目前/ 已经/ 有/ 一些/ 基于/ 硬件/ 实现/ 的/ 自/ 适应/ 的/ Cache/ 行/ 策略/ [/ 13/ -/ 15/ ]/ ,/ 但/ 由于/ SPE/ 本身/ 不/ 具备/ 硬件/ Cache/ ,/ 因此/ 需要/ 研究/ Cell/ 上/ 的/ 软件/ 管理/ 的/ 自/ 适应/ Cache/ 行/ 算法/ ./ 然而/ 这方面/ 的/ 研究成果/ 却/ 很少/ ,/ 典型/ 的/ 工作/ 是/ Seo/ 等/ 人/ [/ 1/ ]/ 提出/ 的/ 扩展/ 的/ 组/ 索引/ Cache/ (/ ExtendedSet/ -/ IndexCache/ ,/ ESC/ )/ 中/ 的/ 自/ 适应/ 的/ 执行/ 算法/ ,/ 它/ 能够/ 在/ Cell/ 处理器/ 上/ 自/ 适应/ 地/ 调整/ 软件/ Cache/ 行/ 长度/ ./ ESC/ 的/ 自/ 适应/ 调整/ Cache/ 行/ 的/ 策略/ 作用/ 对象/ 为/ 一个/ 循环/ ,/ 其/ 基本/ 思想/ 是/ 假设/ 该/ 循环/ 在/ 程序运行/ 过程/ 中/ 被/ 多次/ 调用/ ,/ 在/ 前几次/ 调用/ 中/ 分别/ 选用/ 不同/ 的/ Cache/ 行/ 执行/ 该/ 循环/ 并测/ 得/ 执行/ 时间/ ,/ 从而/ 选出/ 一个/ 最优/ 的/ Cache/ 行/ 长度/ ./ 而/ 当该/ 循环/ 被/ 再次/ 调用/ 时/ ,/ 便/ 选择/ 该/ 最优/ 的/ Cache/ 行/ 进行/ 执行/ ./ 该/ 自/ 适应/ 的/ 算法/ 存在/ 以下/ 不足/ :/ (/ 1/ )/ 该/ 算法/ 作用/ 的/ 对象/ 为/ 一个/ 循环/ ,/ 而/ 对于/ 循环/ 内/ 的/ 单个/ 迭代/ 区域/ 不起作用/ ./ 因此/ ,/ 当/ 某个/ 循环/ 其/ 迭代/ 次数/ 很多/ ,/ 并且/ 不同/ 迭代/ 区间/ 表现/ 出/ 不同/ 的/ 内存/ 访问/ 的/ 局部性/ 时/ ,/ 该/ 策略/ 就/ 不够/ 准确/ ./ 而/ 本文/ 的/ 自/ 适应/ Cache/ 行/ 策略/ 作用/ 对象/ 为/ 循环/ 内/ 的/ 每个/ 迭代/ 区间/ ,/ 自/ 适应/ 的/ 选择/ 过程/ 更为/ 准确/ ;/ (/ 2/ )/ 为了/ 得到/ 某一/ 循环/ 最优/ 的/ Cache/ 行/ ,/ ESC/ 的/ 自/ 适应/ 的/ Cache/ 行/ 算法/ 需要/ 计算/ 该/ 循环/ 被/ 调用/ 的/ 前几次/ 的/ 性能/ ,/ 特别/ 是/ 当/ 候选/ 的/ Cache/ 行/ 种类/ 比较/ 多时/ ,/ 性能/ 比较/ 可能/ 会/ 引入/ 更大/ 的/ 开销/ ;/ (/ 3/ )/ 该/ 算法/ 只/ 对/ 循环/ 在/ 应用/ 中/ 被/ 多次/ 调用/ 的/ 情况/ 起/ 作用/ ,/ 而/ 当/ 某个/ 循环/ 在/ 程序执行/ 过程/ 中/ 只/ 被/ 调用/ 了/ 一次/ 或/ 很少/ 的/ 几次/ 时/ ,/ 该/ 自/ 适应/ 的/ 算法/ 就/ 失效/ 了/ ./ 而/ 本文/ 提出/ 的/ 自/ 适应/ Cache/ 行/ 策略/ 对/ 循环/ 被/ 调用/ 的/ 次数/ 没有/ 要求/ ./ 3/ 自/ 适应/ 的/ Cache/ 行/ 策略/ 本节/ 给/ 出自/ 适应/ 的/ Cache/ 行/ 算法/ ,/ 根据/ 非/ 规则/ 引用/ 的/ 特点/ 连续/ 地/ 、/ 自/ 适应/ 地/ 调整/ Cache/ 行/ 的/ 长度/ ./ 它/ 首先/ 将/ 非/ 规则/ 引用/ 访问/ 的/ 内存地址/ 收集/ 起来/ ,/ 并存/ 放在/ 一个/ 临时/ 数组/ ea/ 中/ ./ 之后/ 将/ 这些/ 地址/ 对齐/ 到长/ Cache/ 行/ 的/ 边界/ ,/ 并/ 将/ 对齐/ 后/ 的/ 地址/ 存放/ 在/ 另/ 一个/ 数组/ work/ _/ ea/ 中/ ./ 如果/ work/ _/ ea/ 中有/ 相同/ 的/ 元素/ ,/ 则/ 说明/ 它们/ 的/ 内存地址/ 是/ 能够/ 在/ 长/ Cache/ 行/ 的/ 边界/ 对齐/ 的/ ,/ 并且/ 如果/ 该/ 内存/ 地址映射/ 到/ 不同/ 的/ 短/ Cache/ 行/ 地址/ 中/ ,/ 则/ 这样/ 的/ 地址/ 就/ 可以/ 合并/ 为/ 一个/ 长/ Cache/ 行/ 地址/ ./ 为了/ 便于/ 描述/ ,/ 本文/ 从/ NASbenchmarks/ [/ 16/ ]/ 的/ CG/ 中/ 提取/ 出/ 了/ 一个/ 循环/ ,/ 将/ 其/ 边界/ 标准化/ ,/ 如图/ 4/ (/ a/ )/ 所示/ ./ 该/ 自/ 适应/ 的/ 算法/ 针对/ 非/ 规则/ 引用/ p/ [/ colidx/ [/ k/ ]/ ]/ 进行/ 最优/ 的/ Cache/ 行/ 选择/ ,/ 为了/ 便于/ 描述/ ,/ 该/ 算法/ 提供/ 了/ 两种/ 可选/ 的/ Cache/ 行/ ,/ 其/ 过程/ 如图/ 4/ (/ b/ )/ 所示/ ./ // / 第/ 1/ 步/ :/ 初始化/ / // lb/ _/ tmp/ =/ 0/ ;/ ub/ _/ tmp/ =/ 0/ ;/ Longline/ =/ 256/ ;/ // // 长/ Cache/ 行/ Shortline/ =/ 128/ ;/ // // 短/ Cache/ 行/ do/ {/ // / 第/ 2/ 步/ :/ 动态/ 地/ 确定/ 迭代/ 区间/ / // ub/ _/ tmp/ =/ collect/ _/ dynamic/ (/ lb/ _/ tmp/ ,/ ub/ _/ tmp/ )/ ;/ // / 第/ 3/ 步/ :/ 自/ 适应/ 的/ Cache/ 行/ 选择/ 过程/ / // // / 将/ 收集/ 到/ 的/ 地址/ 存储/ 到/ 数组/ ea/ 中/ / // for/ (/ k/ =/ lb/ _/ tmp/ ;/ k/ </ ub/ _/ tmp/ ;/ k/ ++/ )/ ea/ [/ k/ ]/ =/ &/ p/ [/ colidx/ [/ k/ ]/ ]/ ;/ // / 将/ 收集/ 到/ 的/ 地址/ 对齐/ 到/ 256B/ 的/ 边界/ 并/ 存储/ 到/ 数组/ for/ (/ k/ =/ lb/ _/ tmp/ ;/ k/ </ ub/ _/ tmp/ ;/ k/ ++/ )/ work/ _/ ea/ [/ k/ ]/ =/ ea/ [/ k/ ]/ &/ (/ ~/ (/ Longline/ -/ 1/ )/ )/ ;/ // / 在/ 数组/ work/ _/ ea/ 中/ 查找/ 相同/ 的/ 值/ ,/ 比如/ ,/ work/ _/ ea/ [/ i/ ]/ =/ search/ _/ same/ _/ data/ (/ work/ _/ ea/ ,/ i/ ,/ j/ )/ ;/ if/ (/ (/ ea/ [/ i/ ]/ &/ (/ ~/ (/ Shortline/ -/ 1/ )/ )/ )/ !/ =/ i/ ,/ j/ 被/ 记作长/ Cache/ 行/ 地址/ 的/ 索引/ ;/ 其它/ 下标/ 被/ 记作/ 短/ Cache/ 行/ 地址/ 的/ 索引/ ;/ // / 第/ 4/ 步/ :/ 迭代/ 内/ 的/ 计算/ 循环/ / // for/ (/ k/ =/ lb/ _/ tmp/ ;/ k/ </ ub/ _/ tmp/ ;/ k/ ++/ )/ if/ (/ k/ 为长/ Cache/ 行/ 地址/ 的/ 索引/ )/ sum/ +/ =/ a/ [/ k/ ]/ / 长/ Cache/ 行/ 对应/ 的/ 操作/ (/ ea/ [/ k/ ]/ )/ ;/ elsesum/ +/ =/ a/ [/ k/ ]/ / 短/ Cache/ 行/ 对应/ 的/ 操作/ (/ ea/ [/ k/ ]/ )/ ;/ // / 返回值/ ub/ _/ tmp/ 作为/ 下次/ 循环/ 的/ lb/ _/ tmp/ / // lb/ _/ tmp/ =/ ub/ _/ tmp/ ;/ }/ while/ (/ lb/ _/ tmp/ </ ub/ )/ 该/ 过程/ 大致/ 分为/ 以下/ 步/ :/ 第/ 1/ 步为/ 初始化/ ./ 简单/ 起/ 见/ ,/ 假设/ 有/ 两种/ 可选/ 的/ Cache/ 行/ ,/ 128B/ 和/ 256B/ ./ 第/ 2/ 步为/ 确定/ 迭代/ 区间/ ./ 迭代/ 区间/ 指/ 连续/ 两次/ 组/ 冲突/ 之间/ 的/ 迭代/ 上/ 下界/ ./ 本文/ 提出/ 的/ 自/ 适应/ 算法/ 作用/ 的/ 对象/ 是/ 循环/ 内/ 一个个/ 迭代/ 区间/ ,/ 即/ 对/ 每个/ 迭代/ 区间/ 内/ 的/ 非/ 规则/ 访存/ 地址/ 进行/ 长/ 、/ 短/ Cache/ 行/ 地址/ 划分/ ,/ 因此/ 迭代/ 区间/ 是/ 一个/ 非常/ 重要/ 的/ 因素/ ./ 一方面/ ,/ 迭代/ 区间/ 不能/ 太小/ ,/ 因为/ 这些/ 迭代/ 要/ 分摊/ 后面/ 地址/ 收集/ 、/ 地址/ 划分/ 及/ 计算/ 的/ 开销/ ./ 另一方面/ ,/ 迭代/ 区/ Page5/ 间/ 也/ 不能/ 太/ 大/ ,/ 因为/ 有/ 可能/ 导致/ 物理地址/ 上/ 很/ 临近/ 但/ 访问/ 时间/ 差距/ 很大/ 的/ 两个/ 短/ Cache/ 行/ 的/ 地址/ 错误/ 地/ 合并/ 为/ 一个/ 长/ Cache/ 行/ 的/ 地址/ ./ 因此/ ,/ 该/ 算法/ 提出/ 了/ 一个/ 动态/ 迭代/ 区间/ ,/ 它/ 规定/ 顺序/ 地/ 收集/ 非/ 规则/ 引用/ 访问/ 的/ 内存地址/ 直到/ 发生/ 组/ 冲突/ 的/ 时候/ 停止/ ./ 为了/ 确定/ 何时/ 发生/ 组/ 冲突/ ,/ 对/ 短/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 的/ 每个/ 组/ 设定/ 一个/ 计数器/ ,/ 初始化/ 为/ 0/ ./ 当/ 一个/ 地址映射/ 到/ 某个/ 组时/ ,/ 该组/ 的/ 计数器/ 加/ 1/ ,/ 并/ 判断/ 该/ 计数器/ 是否/ 到达/ 4/ (/ 因为/ 是/ 四路/ 组/ 相联/ )/ ,/ 若/ 没有/ 到达/ ,/ 则/ 继续/ 判断/ 下/ 一次/ 迭代/ 的/ 非/ 规则/ 访存/ 的/ 地址映射/ 情况/ ./ 直到/ 到达/ 第/ ub/ _/ tmp/ 次/ 迭代/ 时/ ,/ 非/ 规则/ 访存/ 地址/ 所/ 映射/ 到/ 的/ 组其/ 计数器/ 达到/ 了/ 4/ ,/ 即/ 发生/ 了/ 第一次/ 组/ 冲突/ ./ 此时/ ,/ 各个/ 组/ 的/ 计数器/ 均/ 置/ 为/ 0/ ,/ 该次/ 迭代/ 区间/ 的/ 上界/ 为/ ub/ _/ tmp/ ,/ 并/ 将/ 其/ 作为/ 下次/ 迭代/ 区间/ 的/ 下界/ ./ 为了/ 方便/ 起/ 见/ ,/ 动态/ 确定/ 组/ 冲突/ 的/ 过程/ 在/ 代码/ 中/ 用/ 函数/ collect/ _/ dynamic/ (/ lb/ _/ tmp/ ,/ ub/ _/ tmp/ )/ 表示/ ,/ 其/ 返回值/ 为/ 停止/ 收集/ 地址/ 时即/ 发生/ 组/ 冲突/ 时/ 的/ 迭代/ ,/ 该/ 返回值/ 将/ 作为/ 下次/ 地址/ 收集/ 时/ 的/ lb/ _/ tmp/ ,/ 即/ 下次/ 地址/ 收集/ 时/ 的/ 起始/ 迭代/ ./ 第/ 3/ 步对/ 本次/ 迭代/ 区间/ 内/ 的/ 地址/ 进行/ 长/ 、/ 短/ Cache/ 行/ 地址/ 的/ 划分/ ./ 首先/ ,/ 将/ 本次/ 收集/ 到/ 的/ 非/ 规则/ 引用/ 的/ 地址/ 存放/ 在/ 一个/ 临时/ 数组/ ea/ 中/ ./ 经过/ ea/ [/ k/ ]/ &/ (/ ~/ (/ Longline/ -/ 1/ )/ )/ 操作/ ,/ ea/ 中/ 的/ 每个/ 元素/ 即/ 每个/ 地址/ 都/ 对齐/ 到/ 256B/ 的/ 边界/ 上/ ./ 如果/ ea/ 中/ 的/ 两个/ 元素/ ea/ [/ i/ ]/ 和/ ea/ [/ j/ ]/ 经过/ 256B/ 边界/ 对齐/ 后/ 的/ 值/ 相等/ ,/ 并且/ 经过/ 128B/ 边界/ 对齐/ 后/ 的/ 值/ 不/ 等/ ,/ 那么/ 这/ 两个/ 地址/ 就/ 可以/ 合并/ 为/ 一个/ 长/ Cache/ 行/ 对应/ 的/ 地址/ ,/ 下标/ i/ ,/ j/ 被/ 记作长/ Cache/ 行/ 地址/ 的/ 索引/ ./ 相应/ 地/ ,/ ea/ 数组/ 中/ 不/ 满足/ 这样/ 条件/ 的/ 地址/ 则/ 被/ 记作/ 短/ Cache/ 行/ 地址/ ./ 第/ 4/ 步为/ 本地/ 迭代/ 内/ 的/ 计算/ ./ 根据/ 第/ 3/ 步/ 确定/ 的/ 下标/ 是否/ 属于/ 长/ Cache/ 行/ 索引/ 地址/ ,/ 在/ 相应/ 的/ Cache/ 的/ Tag/ 项/ 数组/ 中/ 进行/ 查找/ 并/ 进行/ 相应/ 的/ 命中/ 或/ 缺失/ 处理/ 操作/ ,/ 具体/ 的/ 操作/ 见/ 第/ 5/ 节/ ./ 为了/ 更/ 清楚/ 地/ 说明/ 自/ 适应/ 的/ Cache/ 行/ 策略/ ,/ 图/ 5/ 给出/ 了/ 一个/ 实例/ ./ 作/ 如下/ 假设/ :/ (/ 1/ )/ 在/ 某个/ 迭代/ 区间/ 内/ ,/ 有/ 5/ 个/ 有效/ 地址/ a1/ 到/ a5/ 位于/ 内存/ 区间/ [/ 256N/ ,/ 256/ (/ N/ +/ 2/ )/ )/ 内/ ,/ 其中/ ,/ N/ 为/ 一/ 正整数/ ;/ (/ 2/ )/ 位于/ 内存/ 区间/ [/ 256N/ ,/ 256/ (/ N/ +/ 1/ )/ )/ 的/ 数据/ 被/ 记作/ Li/ ,/ 前/ 128/ 字节/ 的/ 数据表示/ 为/ Li/ -/ 1/ ,/ 后/ 128/ 字节/ 的/ 数据表示/ 为/ Li/ -/ 2/ ;/ Li/ -/ 1/ 和/ Li/ -/ 2/ 互为/ “/ 邻接/ 行/ ”/ ;/ (/ 3/ )/ 位于/ 内存/ 区间/ [/ 256/ (/ N/ +/ 1/ )/ ,/ 256/ (/ N/ +/ 2/ )/ )/ 的/ 数据/ 被/ 记作/ Lj/ ,/ 前/ 128/ 字节/ 的/ 数据表示/ 为/ Lj/ -/ 1/ ,/ 后/ 128/ 字节/ 的/ 数据表示/ 为/ Lj/ -/ 2/ ;/ Lj/ -/ 1/ 和/ Lj/ -/ 2/ 互为/ “/ 邻接/ 行/ ”/ ./ 初始状态/ 下/ ,/ 该/ 迭代/ 区间/ 内/ 所有/ 的/ 地址/ 都/ 记作/ 短/ Cache/ 行/ 地址/ ,/ 如图/ 5/ (/ a/ )/ ./ 地址/ a1/ 和/ a2/ 分别/ 映射/ 到/ 两个/ 邻接/ 行/ Li/ -/ 1/ 和/ Li/ -/ 2/ 中/ ,/ 在/ 响应/ 其中/ 率先/ 到达/ 的/ 一个/ 内存/ 请求/ 时/ ,/ 如果/ 从/ 系统/ 内存/ 中取/ 到/ 一个/ 短/ Cache/ 行/ ,/ 则/ 在/ 响应/ 晚/ 到达/ 的/ 内存/ 请求/ 时/ 仍然/ 需要/ 再次/ 访问/ 系统/ 内存/ 取得/ 下/ 一个/ 短/ 的/ Cache/ 行/ ,/ 即/ 需要/ 两次/ DMA/ 操作/ 分别/ 从/ 系统/ 内存/ 将/ Li/ -/ 1/ 和/ Li/ -/ 2/ 取到/ Cache/ 中/ ./ 为了/ 降低/ 多次/ 内存/ 访问/ 的/ 开销/ ,/ 本文/ 的/ 自/ 适应/ Cache/ 行/ 策略/ 将/ 两个/ 短/ Cache/ 行/ 地址/ 合并/ 为/ 一个/ 长/ Cache/ 行/ 地址/ ,/ 即将/ 两个/ 短/ Cache/ 行/ 合并/ 为/ 一个/ 长/ Cache/ 行/ ,/ 显然/ 响应/ a1/ 和/ a2/ 的/ 内存/ 请求/ 时/ ,/ 只/ 需要/ 进行/ 一次/ DMA/ 操作/ ,/ 将长/ Cache/ 行/ Li/ 一次/ 取到/ Cache/ 中/ ./ 同理/ ,/ 地址/ a3/ 也/ 被/ 记作长/ Cache/ 行/ 地址/ ,/ 见图/ 5/ (/ b/ )/ ./ 地址/ a4/ 和/ a5/ 均/ 被/ 映射/ 到/ Lj/ -/ 2/ 中/ ,/ 而/ 没有/ 地址映射/ 到/ 其/ 邻接/ 行/ Lj/ -/ 1/ 中/ ,/ 所以/ 地址/ a4/ 和/ a5/ 均/ 为/ 记作/ 短/ Cache/ 行/ 地址/ ./ 总之/ ,/ 该/ 自/ 适应/ 的/ Cache/ 行/ 策略/ 可以/ 作用/ 于/ 循环/ 内部/ 的/ 迭代/ 区间/ ,/ 对于/ 不同/ 迭代/ 区间/ 中/ 最优/ Cache/ 行/ 发生变化/ 的/ 循环/ 优势/ 更为/ 明显/ ./ 同时/ ,/ 与/ ESC/ 中自/ 适应/ 方案/ 不同/ ,/ 该/ 策略/ 对/ 循环/ 被/ 调用/ 的/ 次数/ 没有/ 要求/ ./ 4/ 混合/ 行/ 大小/ 的/ Cache/ 结构设计/ 经过/ 自/ 适应/ 的/ Cache/ 行/ 算法/ 之后/ ,/ 收集/ 到/ 的/ 非/ 规则/ 引用/ 的/ 地址/ 被/ 划分/ 为长/ Cache/ 行/ 地址/ 和/ 短/ Cache/ 行/ 地址/ ./ 因此/ ,/ 本文/ 设计/ 了/ 一种/ 新型/ 的/ 软件/ Cache/ 结构/ ,/ 混合/ 行/ 大小/ 的/ Cache/ (/ HybridLineSizeCache/ ,/ HLSC/ )/ ./ 它/ 基于/ 传统/ 的/ 四路/ 组/ 相联/ Cache/ ,/ 但是/ 它/ 引入/ 了/ 多个/ Tag/ 项/ 数组/ (/ 简单/ 起/ 见/ ,/ 这里/ 以/ 两个/ 的/ 为例/ )/ ./ 其/ 具体/ 结构/ 如图/ 6/ 所示/ ./ (/ 1/ )/ Cache/ _/ Storage/ (/ Cache/ 存储/ )/ 用来/ 存储/ 应用/ 数据/ ;/ (/ 2/ )/ Cache/ _/ Parameter1/ 用来/ 记录/ 长/ Cache/ 行相/ Page6/ 应/ 的/ 参数/ ;/ 项/ 数组/ ;/ (/ 3/ )/ Tag/ _/ Entry/ _/ Array1/ 为长/ Cache/ 行/ 的/ Tag/ (/ 4/ )/ Cache/ _/ Parameter2/ 用来/ 记录/ 短/ Cache/ 行相/ (/ 5/ )/ Tag/ _/ Entry/ _/ Array2/ 为/ 短/ Cache/ 行/ 的/ Tag/ 应/ 的/ 参数/ ;/ 图/ 6/ 混合/ 行/ 大小/ 的/ Cache/ 的/ 结构/ Cache/ _/ Storage/ (/ Cache/ 存储/ )/ 用来/ 存储/ 应用/ 数据/ ,/ 本文/ 将/ 其/ 设置/ 为/ 64KB/ ./ Cache/ _/ Parameter1/ 用来/ 记录/ 长/ Cache/ 行/ 相应/ 的/ 参数/ ,/ 它/ 包含/ 长/ Cache/ 行/ 的/ 大小/ 以及/ 掩码/ mask1/ ./ 本节/ 将/ 长/ Cache/ 行/ 设置/ 为/ 256B/ ,/ 所以/ 长/ Cache/ 行/ 的/ 数目/ 为/ n/ _/ L/ =/ 256/ (/ 64KB/ // 256B/ )/ ./ Tag/ _/ Entry/ _/ Array1/ 为长/ Cache/ 行/ 的/ lookup/ 表/ ,/ 它/ 包含/ 了/ S1/ (/ S1/ =/ n/ _/ L/ // 4/ =/ 64/ )/ 个组/ ,/ 每/ 一个/ TE/ 映射/ 到/ 一个/ 256B/ 的/ 长/ Cache/ 行/ ./ Cache/ _/ Parameter2/ 用来/ 记录/ 短/ Cache/ 行/ 相应/ 的/ 参数/ ,/ 短/ Cache/ 行/ 设置/ 为/ 128B/ ,/ 则/ 短/ Cache/ 行/ 的/ 数目/ n/ _/ S/ 等于/ 512/ (/ 64KB/ // 128B/ )/ ./ Tag/ _/ Entry/ _/ Array2/ 为/ 短/ Cache/ 行/ 的/ lookup/ 表/ ,/ 每/ 一个/ TE/ 映射/ 到/ 一个/ 128B/ 的/ 短/ Cache/ 行/ ./ Cache/ _/ Storage/ 中/ 的/ 每/ 一个/ 基本/ 的/ Cache/ 行有/ 个/ 索引/ (/ index/ )/ ,/ 由于/ 长/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 的/ 一个组/ 对应/ Cache/ 存储/ 中/ 的/ 8/ 个/ 基本/ 的/ Cache/ 行/ ,/ 所以/ 将/ Cache/ 存储/ 中/ 的/ 基本/ 的/ Cache/ 行/ 的/ 索引/ 值/ 依次/ 设为/ 0/ ,/ 1/ ,/ …/ ,/ 7/ ,/ 0/ ,/ 1/ ,/ …/ ,/ 7/ ./ 为了/ 在/ 多种/ Cache/ 行中/ 实现/ LRU/ 的/ Cache/ 替换/ 策略/ ,/ 本文/ 对/ 传统/ 的/ LRU/ 替换/ 策略/ 进行/ 扩展/ ,/ 提出/ 了/ 行/ 索引/ 对齐/ 的/ LRU/ 策略/ —/ —/ —/ IndAlign/ _/ LRU/ 策略/ ./ 它/ 引入/ 了/ 索引/ 链表/ 数组/ (/ Index/ _/ Link/ _/ Array/ )/ ,/ 图/ 7/ 给出/ 了/ 它/ 的/ 初始/ 信息/ 以及/ 它/ 与/ Cache/ 行/ 的/ 映射/ 关系/ ./ 项/ 数组/ ;/ 索引/ 以/ 实现/ 多种/ Cache/ 行/ 的/ LRU/ 替换/ 策略/ ;/ (/ 6/ )/ Index/ _/ Link/ _/ Array/ 用来/ 存储/ Cache/ 行/ 的/ (/ 7/ )/ V1/ 和/ V2/ 数组/ 用来/ 记录/ 有效/ 位/ ;/ (/ 8/ )/ D1/ 和/ D2/ 数组/ 用以/ 记录/ 脏字/ 节/ ./ 图/ 7/ 初始/ 的/ 索引/ 链表/ 数组/ 及其/ 与/ Cache/ 行/ 的/ 映射/ 关系/ Index/ _/ Link/ _/ Array/ (/ 索引/ 链表/ 数组/ )/ 是/ 一个/ 由/ Cache/ 行/ 的/ 索引/ 组成/ 的/ 链表/ 数组/ ,/ 该/ 数组/ 包含/ 了/ S1/ 个/ 链表/ ,/ 每个/ 链表/ 同时/ 映射/ 到/ Tag/ _/ Entry/ _/ Array1/ 的/ 一个组/ 和/ Tag/ _/ Entry/ _/ Array2/ 的/ 两个/ 组/ ./ 每个/ 链表/ 包含/ 了/ 8/ 个/ 结点/ ,/ 每个/ 结点/ 的/ 数据/ 域/ 存储/ 行/ 索引/ Page7/ 值/ ./ 每个/ 链表/ 从头/ 结点/ 到/ 尾/ 结点/ 其/ 数据/ 域/ 依次/ 存储/ 了/ 从/ 最早/ 访问/ 到/ 最新/ 访问/ 的/ Cache/ 行/ 的/ 索引/ 值/ ,/ 通过/ 将/ 对应/ 链表/ 中/ 的/ 结点/ 移动/ 到/ 链头/ (/ head/ )/ 或者/ 链尾/ (/ tail/ )/ 即/ 可以/ 记录/ 基本/ Cache/ 行/ 的/ 活跃/ 信息/ ./ 显然/ 行/ 索引/ 对齐/ 的/ LRU/ 替换/ 策略/ 既/ 可以/ 在/ 单一/ 的/ Cache/ 行/ 又/ 可以/ 在/ 多种/ Cache/ 行下/ 实现/ LRU/ 替换/ 策略/ ./ V1/ 和/ V2/ 数组/ 用来/ 记录/ Cache/ 行/ 的/ 数据/ 是否/ 有效/ ./ 当/ 赋值/ 为/ 1/ 和/ 0/ 时/ ,/ 分别/ 表示/ 有效/ 和/ 无效/ ./ D1/ 和/ D2/ 数组/ 用来/ 记录/ Cache/ 行中/ 的/ 脏字/ 节/ ,/ 以/ 减少/ Cache/ 行/ 被/ 剔/ 出去/ 时/ 传输/ 的/ 数据量/ ./ 该/ Cache/ 设计/ 是/ 一种/ 分级/ 的/ 结构/ ./ 为了/ 说明/ 该/ 问题/ ,/ 图/ 8/ 给出/ 了/ 长/ 、/ 短/ Cache/ 行/ 地址/ 的/ 组/ 掩码/ (/ SetMask/ )/ ./ 因为/ 长/ 、/ 短/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 的/ 组数/ 均/ 为/ 2/ 的/ 幂/ ,/ 所以/ 在/ 计算/ 组号/ (/ SetID/ )/ 时/ 可以/ 用/ 简单/ 的/ 位操作/ 代替/ 复杂/ 的/ 模/ 运算/ ./ 即/ 其中/ ,/ 2N/ _/ bit/ 等于/ 相应/ Cache/ 行/ 的/ 字节数/ ./ 因为/ 短/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 包含/ 了/ 128/ 个组/ ,/ 所以/ 需要/ 7/ 位/ (/ 图/ 8/ 所示/ 的/ 第/ 7/ ~/ 13/ 位/ ,/ 用/ 灰色/ 表示/ )/ 来/ 确定/ 组号/ ./ 同理/ ,/ 长/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 需要/ 6/ 位/ (/ 第图/ 9/ 简单/ 的/ HLSC/ 的/ 操作/ 流程图/ 5.1/ 犔/ 狅/ 狅/ 犽/ 狌/ 狆/ _/ 犾/ 狅/ 狀/ 犵/ 和/ 犔/ 狅/ 狅/ 犽/ 狌/ 狆/ _/ 狊/ 犺/ 狅/ 狉/ 狋/ 当/ Cache/ 接收/ 到/ 一个/ 有效/ 地址/ 为/ ea/ 的/ 内存/ 请求/ 时/ ,/ 根据/ 自/ 适应/ 的/ Cache/ 行/ 算法/ ,/ 查询/ 相应/ 的/ Tag/ 项/ 数组/ ./ 对长/ Cache/ 行和短/ Cache/ 行/ 的/ 查询/ 过程/ 跟/ 传统/ 的/ 四路/ 组/ 相联/ 的/ 过程/ 相似/ ,/ 分别/ 叫做/ Lookup/ _/ long/ 和/ Lookup/ _/ short/ ./ 5.2/ 犐/ 狀/ 犱/ 犃/ 犾/ 犻/ 犵/ 狀/ _/ 犔/ 犚/ 犝/ _/ 犾/ 狅/ 狀/ 犵/ 和/ 犐/ 狀/ 犱/ 犃/ 犾/ 犻/ 犵/ 狀/ _/ 犔/ 犚/ 犝/ _/ 狊/ 犺/ 狅/ 狉/ 狋/ 当/ 长/ Cache/ 行/ 地址/ 命中/ 时/ ,/ IndAlign/ _/ LRU/ _/ long/ 被/ 调用/ ;/ 而/ 当/ 短/ Cache/ 行/ 地址/ 命中/ 时/ ,/ IndAlign/ _/ LRU/ _/ short/ 被/ 调用/ ./ 假设/ SPE/ 接收/ 到/ 一个/ 长/ Cache/ 行/ 地址/ ,/ 经过/ Lookup/ _/ long/ 之后/ 该/ 地址/ 命中/ ,/ 匹配/ 的/ 组和路/ 分别/ 为/ set/ _/ L/ 和/ hit/ _/ index/ _/ L/ ,/ IndAlign/ _/ LRU/ _/ long/ 操作/ 就是/ 将/ 第/ set/ _/ L/ 个/ 链表/ 中/ 结点/ 数据/ 域/ 的/ 值/ 为/ (/ 2/ / hit/ _/ index/ _/ L/ )/ 和/ (/ 2/ / hit/ _/ index/ _/ L/ +/ 1/ )/ 的/ 结点/ 8/ ~/ 13/ 位/ )/ 来/ 确定/ 组号/ ./ 当/ Cache/ 接收/ 到/ 一个/ 有效/ 地址/ ,/ 将/ 其/ 与/ 短/ Cache/ 行/ 的/ 组/ 掩码/ 进行/ 按位/ 与/ 操作/ ,/ 如果/ 在/ 确定/ 的/ 组内/ 发生/ 缺失/ 的话/ ,/ 可以/ 将/ 它/ 与/ 长/ Cache/ 行/ 的/ 组/ 掩码/ 进行/ 按位/ 与/ 操作/ ,/ 因为/ 确定/ 组号/ 的/ 位少/ 一位/ ,/ 则/ 该/ 地址/ 有/ 可能/ 在/ 长/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 中/ 命中/ ./ 5/ 混合/ 行/ 大小/ Cache/ 的/ 操作/ 模型/ 该/ 部分/ 介绍/ HLSC/ 的/ 操作/ 模型/ ,/ 主要/ 包含/ Lookup/ _/ long/ ,/ Lookup/ _/ short/ ,/ IndAlign/ _/ LRU/ _/ long/ ,/ IndAlign/ _/ LRU/ _/ short/ ,/ Misshandler/ _/ long/ 以及/ Misshandler/ _/ short/ ./ 图/ 9/ 给出/ 了/ 一个/ 简单/ 的/ 操作/ 流程图/ ,/ 下面/ 来/ 分别/ 对/ 这些/ 操作/ 加以/ 介绍/ ./ 移到/ 链尾/ ,/ 即/ 标记/ 为/ 最新/ 访问/ 的/ Cache/ 行/ ./ 图/ 10/ (/ a/ )/ 给出/ 当/ 匹配/ 的/ 路/ hit/ _/ index/ _/ L/ 等于/ 0/ 时/ 的/ 一个/ 实例/ ./ 假定/ 随后/ Cache/ 接收/ 到/ 一个/ 短/ Cache/ 行/ 的/ 地址/ ,/ 经过/ Lookup/ _/ short/ 之后/ 该/ 地址/ 命中/ ,/ 命中/ 的/ 组和路/ 分别/ 为/ set/ _/ S/ 和/ hit/ _/ index/ _/ S/ ,/ 当/ 满足/ set/ _/ L/ / 2/ =/ set/ _/ S/ 或者/ set/ _/ L/ / 2/ +/ 1/ =/ set/ _/ S/ 的/ 时候/ ,/ 就/ 表示/ Tag/ _/ Entry/ _/ Array1/ 中/ 的/ 第/ set/ _/ L/ 组和/ Tag/ _/ Entry/ _/ Array2/ 中/ 的/ 第/ set/ _/ S/ 组/ 同时/ 映射/ 到/ 第/ set/ _/ L/ 个/ 索引/ 链表/ ./ 当/ 前者/ 满足/ 的/ 时候/ ,/ 表示/ 短/ Cache/ 地址/ 命中/ 的/ 是/ Tag/ _/ Entry/ _/ Array2/ 中/ 的/ 第/ 偶数/ 个组/ ,/ 根据/ TE/ 与/ Cache/ 行/ 的/ 映射/ 关系/ ,/ 第/ set/ _/ L/ 个/ 索引/ 链表/ 中/ 数据/ 域/ 的/ 值/ 为/ hit/ _/ index/ _/ S/ 的/ 结点/ 移到/ 链尾/ ,/ 记/ 为/ 最新/ 被/ 访问/ 到/ 的/ Cache/ 行/ ./ 图/ 10/ (/ b/ )/ 给出/ 了/ 当/ hit/ _/ index/ _/ S/ 等于/ 3/ 的/ 时候/ 该/ 条件/ 被/ 满足/ 时/ 索引/ 链表/ 的/ 操作/ Page8/ 图/ 10HLSC/ 操作/ 的/ 具体/ 实例/ 情况/ ./ 当/ 后者/ 满足/ 的/ 时候/ ,/ 表示/ 短/ Cache/ 地址/ 命中/ 的/ 是/ Tag/ _/ Entry/ _/ Array2/ 中/ 的/ 第/ 奇数/ 个组/ ,/ 第/ set/ _/ L/ 个/ 索引/ 链表/ 中/ 数据/ 域/ 的/ 值/ 为/ (/ hit/ _/ index/ _/ S/ +/ 4/ )/ 的/ 结点/ 移到/ 链尾/ ,/ 记/ 作/ 最新/ 被/ 访问/ 的/ Cache/ 行/ ./ 图/ 10/ (/ c/ )/ 给出/ 了/ 当/ hit/ _/ index/ _/ S/ 等于/ 3/ 的/ 时候/ 该/ 条件/ 被/ 满足/ 时/ 索引/ 链表/ 的/ 操作/ 情况/ ./ 总之/ ,/ 在/ 短/ Cache/ 行/ 地址/ 命中/ 的/ 情况/ 下/ ,/ 对/ 链表/ 的/ 操作/ 以/ 实现/ LRU/ 的/ 替换/ 策略/ 都/ 称为/ IndAlign/ _/ LRU/ _/ short/ ./ 5.3/ 犕/ 犻/ 狊/ 狊/ 犺/ 犪/ 狀/ 犱/ 犾/ 犲/ 狉/ _/ 犾/ 狅/ 狀/ 犵/ 当/ 一个/ 长/ Cache/ 行/ 地址/ 缺失/ 的/ 时候/ ,/ 调用/ Misshandler/ _/ long/ ./ 用/ IndAlign/ (/ index/ _/ L/ )/ 表示/ 当/ 链表/ 的/ 链头/ 结点/ 的/ 数据/ 域/ 的/ 值/ 为/ index/ _/ L/ 的/ 时候/ ,/ 最早/ 访问/ 的/ 长/ Cache/ 行/ 的/ 对齐/ 的/ 行/ 索引/ 值/ ./ 为了/ 便于/ 描述/ ,/ 简单/ 地/ 定义/ IndAlign/ (/ index/ _/ L/ )/ 如下/ :/ IndAlign/ (/ index/ _/ L/ )/ =/ index/ _/ L/ 和/ (/ index/ _/ L/ +/ 1/ )/ 当/ index/ _/ L/ 为/ 偶数/ 的/ 时候/ ,/ 当/ index/ _/ L/ 为/ 奇数/ 的/ 时候/ ,/ IndAlign/ (/ index/ _/ L/ )/ =/ (/ index/ _/ L/ -/ 1/ )/ 和/ index/ _/ L/ 假定/ Cache/ 接收/ 到/ 一个/ 长/ Cache/ 行/ 地址/ ,/ 该/ 地址映射/ 到/ Tag/ _/ Entry/ _/ Array1/ 中/ 的/ 第/ set/ _/ L/ 组/ ,/ 并且/ 该/ 地址/ 缺失/ ,/ 则/ Misshandler/ _/ long/ 被/ 调用/ ,/ 该/ 过程/ 包含/ 以下/ 几步/ :/ ①/ 选择/ 最早/ 访问/ 过/ 的/ 长/ Cache/ 行/ 作为/ 被/ 换/ 出/ 的/ 行/ ./ 因为/ 链表/ 索引/ 数组/ 规定/ 了/ 链头/ 结点/ 记录/ 最早/ 访问/ 的/ Cache/ 行/ 的/ 行/ 索引/ ,/ 所以/ 从/ 第/ set/ _/ L/ 个/ 索引/ 链表/ 中/ 选择/ 链头/ 的/ 数据/ 域/ 的/ 值/ ,/ 记作/ index/ _/ L/ ,/ 根据/ index/ _/ L/ 的/ 奇偶性/ ,/ 选择/ 定义/ (/ 1/ )/ 或/ 定义/ (/ 2/ )/ ,/ 从而/ 确定/ 最早/ 访问/ 的/ 长/ Cache/ 行/ 的/ 行/ 索引/ 值/ ./ 同时/ 将/ 该长/ Cache/ 行/ 包含/ 的/ 两个/ 短/ Cache/ 行/ 的/ 行/ 索引/ 从小到大/ 依次/ 记作/ index/ _/ low/ 和/ index/ _/ high/ ./ 图/ 10/ (/ d/ )/ 中/ index/ _/ low/ 和/ index/ _/ high/ 的/ 值/ 分别/ 为/ 2/ 和/ 3/ ./ ②/ 检查/ 对应/ 的/ V/ 数组/ 并/ 将/ 脏字/ 节写/ 回/ 主存/ ./ 如果/ 数组/ V1/ 的/ 对应/ 元素/ 为/ 1/ ,/ 即/ 整个/ 长/ Cache/ 行/ 的/ 有效/ 位为/ 1/ ,/ 则/ 作为/ victim/ 的/ 长/ Cache/ 行中/ 的/ 脏字/ 节/ 被/ 写/ 回/ 主存/ ./ 如果/ 整个/ 长/ Cache/ 行/ 对应/ 的/ 有效/ 位为/ 0/ ,/ 可是/ 长/ Cache/ 行中/ 的/ 两个/ 短/ Cache/ 行/ 无论/ 哪个/ 对应/ 的/ 有效/ 位为/ 1/ ,/ 则/ 相应/ 的/ 短/ Cache/ 行/ 的/ 脏字/ 节写/ 回/ 主存/ ,/ 并/ 将/ 其/ 有效/ 位置/ 为/ 0/ ,/ 同时/ 将长/ Cache/ 行/ 对应/ 的/ 有效/ 位置/ 为/ 1/ ./ ③/ 从/ 主存/ 中/ 取得/ 需要/ 的/ 长/ Cache/ 行/ 的/ 数据/ ,/ 同时/ 将/ 作为/ victim/ 的/ 长/ Cache/ 行/ 对应/ 的/ 结点/ 移至/ 第/ set/ _/ L/ 个/ 索引/ 链表/ 的/ 链尾/ ./ 5.4/ 犕/ 犻/ 狊/ 狊/ 犺/ 犪/ 狀/ 犱/ 犾/ 犲/ 狉/ _/ 狊/ 犺/ 狅/ 狉/ 狋/ 用/ IndAlign/ (/ index/ _/ S/ )/ 表示/ 当/ 链表/ 的/ 链头/ 结点/ 的/ 数据/ 域/ 的/ 值/ 为/ index/ _/ S/ 的/ 时候/ ,/ 最早/ 访问/ 的/ 短/ Cache/ 行/ 的/ 行/ 索引/ 值/ ./ 对于/ 一个/ 映射/ 到/ Tag/ _/ Entry/ _/ Array2/ 中/ 第/ set/ _/ S/ 组/ 的/ 短/ Cache/ 行/ 的/ 地址/ 来说/ ,/ IndAlign/ (/ index/ _/ S/ )/ 定义/ 如下/ :/ 当/ set/ _/ S/ 是/ 偶数/ 的/ 时候/ ,/ IndAlign/ (/ index/ _/ S/ )/ =/ earlist/ (/ 0/ ,/ 1/ ,/ 2/ ,/ 3/ )/ (/ 3/ )/ 当/ set/ _/ S/ 是/ 奇数/ 的/ 时候/ ,/ IndAlign/ (/ index/ _/ S/ )/ =/ earlist/ (/ 4/ ,/ 5/ ,/ 6/ ,/ 7/ )/ (/ 4/ )/ 这里/ earlist/ (/ para1/ ,/ para2/ ,/ para3/ ,/ para4/ )/ 中/ 的/ 4/ 个/ 参数/ 表示/ 短/ Cache/ 行/ 的/ 行/ 索引/ ,/ earlist/ (/ para1/ ,/ para2/ ,/ para3/ ,/ para4/ )/ 表示/ 括号/ 中/ 4/ 个/ 短/ Cache/ 行中/ 最早/ 访问/ 的/ Cache/ 行/ 的/ 索引/ ./ 假设/ Cache/ 接收/ 到/ 一个/ 短/ Cache/ 行/ 的/ 地址/ ,/ 该/ 地址映射/ 到/ Tag/ _/ Entry/ _/ Array2/ 中/ 的/ 第/ set/ _/ S/ 组/ ,/ 并且/ 满足/ set/ _/ S/ // 2/ =/ set/ _/ L/ ,/ 如果/ 该/ 地址/ 在/ Tag/ _/ Entry/ _/ Array2/ 中/ 缺失/ ,/ 它/ 跟/ 长/ Cache/ 行/ 的/ 缺失/ 不/ 一样/ ,/ 在/ 调用/ 缺失/ 处理/ 的/ 同时/ 检查/ Tag/ _/ Entry/ _/ Array1/ ./ 如果/ 在/ Tag/ _/ Entry/ _/ Array1/ 中查/ 到/ 一个/ 有效/ 匹配/ ,/ 则/ 立即/ 终止/ 缺失/ 处理/ ,/ 之后/ 的/ 操作/ 类似/ 于/ 短/ Cache/ 行/ 的/ 命中/ ./ 如果/ 在/ Tag/ _/ Entry/ _/ Array1/ 中/ 仍然/ 缺失/ ,/ 则/ 返回/ Misshandler/ _/ short/ 的/ 值/ ./ Page9/ 为了/ 清楚/ 地/ 描述/ 该/ 过程/ ,/ 图/ 11/ 给出/ 了/ 一个/ 局部/ 的/ HLSC/ 的/ 结构图/ ./ 假定/ 短/ Cache/ 行/ 的/ 地址映射/ 到/ 第/ set/ _/ L/ 个/ 链表/ ,/ 该/ 链表/ 对应/ 的/ 短/ Cache/ 行/ 标记/ 为/ L/ [/ 0/ ]/ 到/ L/ [/ 7/ ]/ ./ Misshandler/ _/ short/ 的/ 具体/ 实现/ 如下/ :/ ①/ 选择/ 最早/ 访问/ 的/ 短/ Cache/ 行/ 作为/ victim/ ./ 判断/ set/ _/ S/ 的/ 奇偶性/ ,/ 从而/ 根据/ 定义/ (/ 3/ )/ 或/ 定义/ (/ 4/ )/ 确定/ 最早/ 访问/ 的/ 短/ Cache/ 行/ 的/ 索引/ index/ _/ old/ ./ 图/ 11/ 中/ 假定/ index/ _/ old/ 等于/ 5/ ./ ②/ 检查/ 对应/ 的/ V/ 数组/ 并/ 写/ 回/ 脏字/ 节/ ./ 先/ 检查/ index/ _/ old/ 对应/ 的/ 长/ Cache/ 行/ 的/ 有效/ 位/ V1/ [/ 2/ ]/ 是否/ 有效/ ./ 如果/ 有效/ ,/ 则/ L/ [/ 4/ ]/ 和/ L/ [/ 5/ ]/ 组成/ 的/ 长/ Cache/ 行/ 的/ 脏字/ 节写/ 回/ 主存/ ,/ 同时/ 将/ V1/ [/ 2/ ]/ 设置/ 为/ 无效/ ./ 如果/ 无效/ ,/ 则/ 检查/ V2/ [/ 5/ ]/ 是否/ 有效/ ,/ 如果/ 有效/ ,/ 则/ 需/ 将/ L/ [/ 5/ ]/ 中/ 的/ 脏字/ 节写/ 回/ 主存/ ./ ③/ 从/ 主存/ 中/ 取得/ 需要/ 的/ 短/ Cache/ 行/ 的/ 数据/ ,/ 填写/ 相应/ 的/ TE/ ,/ 将/ V2/ [/ 5/ ]/ 设置/ 为/ 有效/ ./ 最后/ 将/ 链表/ 中/ 数据/ 域/ 的/ 值/ 为/ 5/ 的/ 结点/ 移到/ 链尾/ ,/ 记/ 作/ 最新/ 访问/ 的/ Cache/ 行/ 索引/ ./ 6/ 实验/ 6.1/ 实验/ 环境/ 该/ 实验/ 在/ 一个/ 3.2/ GHz/ 的/ Cell/ 处理器/ 上/ 进行/ ./ Cell/ 处理器/ 上/ 的/ PPE/ 包含/ 一个/ 32KB/ 的/ 一级/ 指令/ Cache/ ,/ 一个/ 32KB/ 的/ 一级/ 数据/ Cache/ 以及/ 512KB/ 的/ 二级/ Cache/ ./ 每个/ SPE/ 包含/ 一个/ 256KB/ 的/ 本地/ 存储/ ./ 测试/ 使用/ 的/ 系统/ 为/ Fedora9/ (/ LinuxKernel2/ ./ 6.25/ -/ 14/ )/ ,/ 编译程序/ 使用/ 的/ 是/ CellSDK3/ ./ 1/ ./ 为了/ 评估/ 本文/ 提出/ 的/ 方案/ ,/ 我们/ 在/ Cell/ 处理器/ 上/ 实现/ 了/ HLSC/ 方案/ ,/ 并/ 与/ 传统/ 的/ 固定/ Cache/ 行/ 方案/ 以及/ ESC/ 方案/ 进行/ 了/ 比较/ ./ 实验/ 中/ 应用/ 稀疏/ 矩阵/ 向量/ 乘/ (/ SpMV/ )/ 以及/ NASbenchmarks/ [/ 16/ ]/ 中/ 的/ FT/ 、/ IS/ 、/ CG/ 、/ MG/ 进行/ 性能/ 评估/ ./ 稀疏/ 矩阵/ 来源于/ 佛罗里达/ 大学/ 的/ 稀疏/ 矩阵/ 向量/ 集/ [/ 17/ ]/ ,/ 这些/ 矩阵/ 涵盖/ 了/ 实际/ 应用/ 的/ 很多/ 领域/ ,/ 如/ 计算/ 流体力学/ 、/ 电路/ 模拟/ 、/ 分子/ 动力学/ 、/ 线性规划/ 等/ ./ 实验/ 中自/ 适应/ 的/ Cache/ 行/ 算法/ 动态/ 地/ 从/ 128B/ ,/ 256B/ ,/ 512B/ 和/ 1024B/ 中/ 选择/ 最优/ 的/ Cache/ 行/ ./ 6.2/ 加速/ 比/ 首先/ 将/ HLSC/ 的/ 自/ 适应/ 策略/ 与/ 固定/ 的/ Cache/ 行/ 设计/ 作/ 比较/ ./ 将/ 256B/ 的/ Cache/ 行/ 设计/ 的/ 执行/ 速度/ 设置/ 为/ 标准/ 的/ 速度/ ,/ 那么/ 各种/ Cache/ 设计/ 的/ 加速/ 比如/ 图/ 12/ 所示/ ./ 整体/ 上/ 来讲/ ,/ HLSC/ 的/ 执行/ 速度/ 要/ 明显/ 优于/ 固定/ 的/ Cache/ 行/ 设计/ 的/ 执行/ 速度/ ./ 跟/ 固定/ 的/ 1024B/ ,/ 512B/ ,/ 256B/ 和/ 128B/ 的/ Cache/ 行/ 设计/ 相比/ ,/ HLSC/ 的/ 平均/ 执行/ 速度/ 分别/ 提高/ 了/ 28.9/ %/ ,/ 29.7/ %/ ,/ 32.1/ %/ 和/ 33.5/ %/ ./ 特别/ 是/ MG/ ,/ 它/ 的/ 性能/ 随/ Cache/ 行/ 长度/ 的/ 改变/ 而/ 发生/ 明显/ 的/ 变化/ ,/ 因此/ 当/ 采用/ 自/ 适应/ 的/ Cache/ 行/ 策略/ 之后/ ,/ 它/ 的/ 性能/ 提升/ 得/ 最/ 多/ ./ IS/ 对/ Cache/ 行/ 大小/ 不/ 敏感/ ,/ 因此/ 跟/ 固定/ 的/ Cache/ 行/ 设计/ 相比/ ,/ HLSC/ 的/ 性能/ 改善/ 不太/ 明显/ ./ 然后/ ,/ 将/ HLSC/ 的/ 自/ 适应/ 策略/ 跟/ 现有/ 的/ Cell/ 处理器/ 上/ 实现/ 的/ ESC/ 的/ 策略/ 作/ 比较/ ./ 这/ 两种/ 自/ 适应/ 的/ 算法/ 均/ 从/ 128B/ ,/ 256B/ ,/ 512B/ ,/ 1024B4/ 种/ Cache/ 行/ 大小/ 中自/ 适应/ 地/ 选择/ 最优/ 的/ Cache/ 行/ ./ 以/ ESC/ 中/ 的/ 自/ 适应/ 算法/ 的/ 执行/ 速度/ 作为/ 基准/ ,/ 标准化/ 了/ 的/ 加速/ 比见/ 图/ 13/ ./ 图/ 13ESC/ 和/ HLSC/ 的/ 自/ 适应/ 的/ 算法/ 性能/ 比较/ Page10/ 整体/ 上/ 来讲/ ,/ HLSC/ 的/ 自/ 适应/ 算法/ 提高/ 了/ 程序/ 的/ 执行/ 速度/ ,/ 特别/ 是/ 对于/ MG/ ,/ 性能/ 提升/ 最为/ 明显/ ,/ 加速/ 比/ 可/ 达到/ 1.52/ ./ 主要/ 在于/ 以下/ 两点/ :/ (/ 1/ )/ HLSC/ 的/ 自/ 适应/ 算法/ 可以/ 作用/ 到/ 循环/ 内部/ 每个/ 迭代/ 区间/ ,/ 可是/ ESC/ 的/ 自/ 适应/ 算法/ 只/ 对/ 某个/ 循环/ 起/ 作用/ ,/ 而/ 对/ 内部/ 迭代/ 不/ 敏感/ ./ MG/ 对/ 循环/ 内/ 的/ 迭代/ 区间/ Cache/ 行/ 的/ 改变/ 很/ 敏感/ (/ 如图/ 12/ 所示/ )/ ,/ 因此/ 性能/ 提升/ 较为/ 明显/ ./ (/ 2/ )/ 在/ 某些/ 情况/ 下/ ,/ ESC/ 的/ 自/ 适应/ 算法/ 选出/ 的/ Cache/ 行/ 长度/ 可能/ 不是/ 最优/ 的/ ./ 为了/ 说明/ 问题/ ,/ 作/ 如下/ 假设/ :/ ①/ 有/ 5/ 种/ 候选/ 的/ Cache/ 行/ 大小/ ,/ LS0/ 到/ LS4/ ,/ Cache/ 行/ 长度/ 依次/ 增长/ ;/ ②/ 对/ 某个/ 循环/ 来说/ ,/ 这/ 5/ 种/ Cache/ 行/ 的/ 性能/ 级别/ 分别/ 为/ 1/ ,/ 3/ ,/ 2/ ,/ 4/ ,/ 0/ (/ 数字/ 越大/ ,/ 表示/ 对应/ 的/ Cache/ 行/ 的/ 性能/ 越/ 好/ )/ ,/ 则/ ESC/ 中自/ 适应/ 的/ 选择/ Cache/ 行/ 的/ 执行/ 过程/ 如下/ :/ 当/ 循环/ 第一次/ 被/ 调用/ 的/ 时候/ ,/ 选择/ 中间/ 长度/ 的/ Cache/ 行/ ,/ 即/ LS2/ ,/ 测得/ 其/ 每次/ 迭代/ 的/ 执行/ 时间/ TPI/ (/ TimePerIteration/ )/ 记作/ TPI1/ ;/ 当该/ 循环/ 被/ 再次/ 调用/ 时/ ,/ 选择/ 一个/ 稍短/ 的/ Cache/ 行/ (/ 即/ LS1/ )/ 执行/ 该/ 循环/ ,/ 此时/ 计算/ 得到/ 每次/ 迭代/ 的/ 执行/ 时间/ 为/ TPI2/ ./ 根据/ 假定/ 的/ 性能/ 级别/ ,/ TPI1/ 肯定/ 会/ 比/ TPI2/ 大/ ,/ ESC/ 的/ 自/ 适应/ 算法/ 会/ 认为/ 短/ 的/ Cache/ 行/ 性能/ 会/ 好/ 一些/ ;/ 所以/ 在/ 下次/ 该/ 循环/ 被/ 调用/ 时/ ,/ ESC/ 自/ 适应/ 的/ 算法/ 选择/ 一个/ 更/ 短/ 一些/ 的/ Cache/ 行/ (/ 即/ LS0/ )/ 来/ 执行/ 该/ 循环/ ,/ 并测/ 得/ 此时/ 的/ TPI/ 为/ TPI3/ ,/ 根据/ 假定/ 的/ Cache/ 行/ 的/ 性能/ 级别/ ,/ TPI3/ 比/ TPI2/ 大/ ./ 因此/ ,/ ESC/ 自/ 适应/ 的/ 算法/ 选择/ 最小/ 的/ TPI/ 对应/ 的/ Cache/ 行/ (/ 即/ LS1/ )/ 作为/ 其/ 最优/ 的/ Cache/ 行/ ./ 但是/ ,/ 从/ 假设/ 的/ 性能/ 级别/ 可以/ 看到/ LS3/ 才/ 是/ 针对/ 此/ 循环/ 的/ 最优/ 的/ Cache/ 行/ ./ 产生/ 这样/ 的/ 问题/ 主要/ 因为/ :/ 当/ TPI1/ 比/ TPI2/ 大时/ ,/ ESC/ 的/ 自/ 适应/ 算法/ 会/ 认为/ 短/ 的/ Cache/ 行/ 性能/ 会/ 好/ 一些/ ,/ 这个/ 推理/ 不/ 一定/ 成立/ ,/ 因为/ 在/ 长度/ 上/ 连续/ 的/ 两种/ Cache/ 行对/ 某个/ 循环/ 来说/ ,/ 其/ 执行/ 性能/ 不/ 一定/ 连续/ ,/ 即/ 可能/ 出现/ 随着/ Cache/ 长度/ 依次/ 递变/ ,/ 执行/ 性能/ 却/ 发生/ 跳变/ 的/ 情况/ ./ 从图/ 12/ 可以/ 看到/ MG/ 是/ 一个/ 随/ Cache/ 行/ 长度/ 递变/ 性能/ 会/ 出现/ 跳变/ 的/ 应用/ ,/ 因此/ MG/ 的/ 性能/ 提升/ 受到/ 了/ ESC/ 中自/ 适应/ 算法/ 的/ 限制/ ./ SpMV/ 中/ 稀疏/ 矩阵/ 向量/ 乘/ 的/ 循环/ 只/ 被/ 调用/ 了/ 一次/ ,/ 为了/ 测试/ 两种/ 不同/ 自/ 适应/ 策略/ 下/ 的/ 性能/ ,/ 本文/ 将/ 选择/ 中间/ 长度/ 的/ 256B/ 和/ 512B/ 中/ 性能/ 较/ 好/ 的/ 256B/ 作为/ ESC/ 中自/ 适应/ 策略/ 确定/ 的/ 最优/ Cache/ 行/ ./ ESC/ 算法/ 需要/ 多次/ 调用/ 某个/ 循环/ 以/ 确定/ 最优/ 的/ Cache/ 行/ ,/ 而/ SpMV/ 中/ 稀疏/ 矩阵/ 向量/ 乘/ 的/ 循环/ 只/ 运行/ 了/ 一次/ ,/ 所以/ 该/ 应用/ 从/ ESC/ 的/ 自/ 适应/ 策略/ 中/ 获得/ 的/ 性能/ 提升/ 并/ 不/ 明显/ ./ 而/ 本文/ 提出/ 的/ HLSC/ 的/ 自/ 适应/ 算法/ 对/ 循环/ 被/ 调用/ 次数/ 没有/ 限制/ ,/ 因此/ 对于/ SpMV/ 应用/ 来说/ ,/ HLSC/ 的/ 自/ 适应/ 策略/ 明显/ 优于/ ESC/ 的/ 自适/ 的/ 算法/ ./ IS/ 是/ 一个/ 对/ Cache/ 行/ 变化/ 不/ 敏感/ 的/ 应用/ ,/ 所以/ 对于/ 固定/ 的/ Cache/ 行/ 、/ ESC/ 的/ 自/ 适应/ 算法/ 和/ HLSC/ 的/ 自/ 适应/ 策略/ 性能/ 变化/ 都/ 不/ 明显/ ./ 6.3/ 传输/ 的/ 字节数/ 如果/ 将/ 128B/ 的/ Cache/ 行/ 设计/ 传输/ 的/ 字节数/ 作为/ 基准/ ,/ 则/ 各种/ Cache/ 行/ 设计/ 传输/ 的/ 字节数/ 如图/ 14/ 所示/ ./ 很/ 明显/ ,/ HLSC/ 传输/ 的/ 字节数/ 要/ 少于/ 固定/ 的/ 1024B/ ,/ 512B/ ,/ 256B/ 和/ 128B/ 的/ Cache/ 行/ 设计所/ 传输/ 的/ 字节数/ ./ 特别/ 是/ 跟/ 最长/ 的/ 1024B/ 的/ Cache/ 行/ 设计/ 相比/ ,/ HLSC/ 设计/ 传输/ 的/ 字节数/ 约/ 占/ 1024B/ 的/ Cache/ 行/ 设计/ 的/ 31/ %/ ./ 主要/ 在于/ 假如/ 计算/ 中/ 只/ 需要/ 一个/ 字节/ ,/ 1024B/ 的/ Cache/ 行/ 设计/ 需要/ 传输/ 全部/ 的/ 1024B/ 的/ 数据/ ,/ 而/ HLSC/ 设计/ 可能/ 只/ 需要/ 传输/ 128B/ 的/ 数据/ ./ HLSC/ 设计/ 传输/ 的/ 字节数/ 之所以/ 也/ 会/ 少于/ 128B/ ,/ 256B/ 等/ 短/ 的/ 固定/ 的/ Cache/ 行/ 设计/ 是因为/ 当短/ 的/ 固定/ 的/ Cache/ 行/ 设计/ 遇到/ 缺失/ 处理/ 时/ 立即/ 传输数据/ (/ 不管/ 是/ 直接/ 从/ 内存/ 中取数/ 还是/ 组/ 冲突/ 之后/ 先/ 剔出/ Cache/ 中/ 的/ 数据/ 再/ 从/ 内存/ 中取/ 数据/ )/ ,/ 而/ HLSC/ 方案/ 有/ 可能/ 在/ 较/ 长/ 的/ Tag/ 项/ 数组/ 中/ 找到/ 需要/ 的/ 数据/ ,/ 而/ 无需/ 进行/ 冗余/ 的/ 数据传输/ ./ 6.4/ 命中率/ 图/ 15/ 给出/ 了/ 以/ 128B/ 的/ Cache/ 行/ 设计/ 的/ 命中率/ 为/ 基准/ 的/ 情况/ 下/ ,/ 各种/ Cache/ 行/ 设计/ 的/ 命中率/ ./ 与/ 固定/ 的/ 1024B/ ,/ 512B/ ,/ 256B/ 和/ 128B/ 的/ Cache/ 行/ 设计/ 相比/ ,/ HLSC/ 的/ 命中率/ 分别/ 提高/ 了/ 20.5/ %/ ,/ 21.1/ %/ ,/ 23.4/ %/ ,/ 24.7/ %/ ./ 主要/ 因为/ HLSC/ 设计/ 是/ 分级/ 的/ ,/ 当/ Page11/ 短/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 发生/ 缺失/ 时/ ,/ 还要/ 检查/ 较长/ Cache/ 行/ 的/ Tag/ 项/ 数组/ 是否/ 命中/ ./ 在/ 大多数/ 情况/ 下/ ,/ 固定/ 的/ 长/ Cache/ 行/ 的/ 命中率/ 要/ 高于/ 固定/ 的/ 短/ Cache/ 行/ 的/ 命中率/ ./ 因为/ 一次/ 长/ Cache/ 行/ 的/ DMA/ 操作/ 取到/ 的/ 数据/ 可能/ 相当于/ 多次/ 短/ 的/ Cache/ 行/ 的/ DMA/ 操作/ 取到/ 的/ 数据/ ./ 以/ 固定/ 的/ 1024B/ 和/ 512B/ 为例/ ,/ 如果/ Cache/ 接收/ 到/ 两个/ 连续/ 的/ 内存/ 请求/ ,/ 并且/ 请求/ 的/ 数据/ 均/ 未取/ 到/ Cache/ 中/ ,/ 这/ 两个/ 地址/ 分别/ 映射/ 到/ 1024B/ 的/ Cache/ 行中/ 的/ 前/ 、/ 后/ 512B/ ,/ 那么/ 采用/ 固定/ 的/ 512B/ 的/ Cache/ 行/ 的/ 两次/ 请表/ 1/ 除/ Cache/ 外/ 的/ 额外/ 存储/ 开销/ CacheLineTable/ (/ CLT/ )/ LTE/ / N/ =/ 6NLTE/ / N/ =/ 2NLTE/ / N/ =/ 6NTotalSize/ (/ TEArray/ +/ CLT/ )/ 14N32S/ +/ 6N/ 表/ 1/ 给出/ 了/ 除了/ Cache/ 存储/ 以外/ 各种/ Cache/ 结构/ 的/ 额外/ 存储/ 开销/ ./ 其中/ :/ “/ FAC/ ”/ 和/ “/ 4WC/ ”/ 分别/ 代表/ 全/ 相联/ Cache/ (/ fully/ -/ associativecache/ )/ 和/ 四路/ 组/ 相联/ Cache/ (/ 4/ -/ wayset/ -/ associativecache/ )/ ./ HLSC/ 采用/ 的/ 是/ 128B/ ,/ 256B/ ,/ 512B/ 和/ 1024B4/ 种/ Cache/ 行/ 结构/ ./ HLSC/ 的/ 额外/ 存储/ 负荷/ 比/ FAC/ 和/ 4WC/ 的/ 多一些/ ,/ 但是/ 在/ 一个/ 数量级/ 上/ 差别/ 不/ 明显/ ./ ESC/ 结构/ 中/ 的/ S/ 的/ 值/ 是/ 最/ 接近/ S/ 的/ 2/ 的/ 幂/ ,/ 所以/ S/ 的/ 值/ 跟/ S/ 在/ 同一个/ 数量级/ 上/ ./ 因此/ ,/ 4/ 种/ Cache/ 结构/ 的/ 额外/ 存储/ 开销/ 相当/ ./ 7/ 结论/ 和/ 下/ 一步/ 工作/ 本文/ 提出/ 了/ 一种/ 在/ Cell/ 异构/ 多核/ 处理器/ 上/ 解决/ 非/ 规则/ 问题/ 的/ 自/ 适应/ 的/ Cache/ 行/ 策略/ ,/ 它/ 根据/ 非/ 规则/ 访问/ 的/ 特点/ 自/ 适应/ 地/ 调整/ Cache/ 行/ 大小/ ,/ 极大/ 求/ 一定/ 都/ 是/ 缺失/ ,/ 而/ 采用/ 固定/ 的/ 1024B/ 的/ Cache/ 行/ 设计/ 的/ 第一次/ 请求/ 的/ 地址/ 缺失/ ,/ 但/ 第二次/ 请求/ 的/ 数据/ 已经/ 被/ 第一次/ DMA/ 操作/ 取到/ Cache/ 中/ ,/ 因此/ 命中/ ./ 从图/ 14/ 和/ 图/ 15/ 中/ 可以/ 看出/ ,/ HLSC/ 性能/ 提高/ 不仅/ 来源于/ 减少/ 了/ 冗余/ 的/ 数据传输/ ,/ 还/ 在于/ 提高/ 了/ Cache/ 的/ 命中率/ ./ 6.5/ 存储/ 开销/ 比较/ 为了/ 形式化/ 表示/ 存储/ 的/ 开销/ ,/ 作/ 如下/ 假定/ :/ (/ 1/ )/ Cache/ 存储/ 中/ 包含/ N/ 个/ 128B/ 的/ Cache/ 行/ ,/ 则/ 四路/ 组/ 相联/ 的/ Cache/ 中/ 包含/ S/ (/ S/ =/ N/ // 4/ )/ 个组/ ;/ (/ 2/ )/ ESC/ 中/ 的/ 组数/ 表示/ 为/ S/ ,/ 依据/ ESC/ 的/ 设计/ ,/ S/ 是/ 跟/ S/ 最/ 接近/ 的/ 2/ 的/ 幂/ ;/ (/ 3/ )/ Tag/ 是/ 4/ 个/ 字节/ 的/ 整数/ ,/ 脏位/ 和/ 有效/ 位均/ 为/ 一个/ 字节/ ;/ (/ 4/ )/ 每个/ TE/ 需要/ 一个/ 四/ 字节/ 的/ 行/ 索引/ (/ line/ _/ index/ )/ ;/ (/ 5/ )/ “/ LTE/ ”/ (/ LineTableEntry/ )/ 代表/ 行/ 表项/ ,/ 在/ FAC/ 和/ ESC/ 结构/ 的/ 行/ 表项/ 中均/ 包含/ 了/ 一个/ 跟/ TE/ 中/ 一致/ 的/ Tag/ 项/ (/ TagEntry/ ,/ TE/ )/ ,/ 用以/ 记录/ 全局/ 地址/ ./ 地/ 减少/ 了/ 冗余/ 的/ 数据传输/ ./ 同时/ ,/ 设计/ 了/ 一种/ 混合/ 的/ 软件/ Cache/ 结构/ —/ —/ —/ HLSC/ ,/ 它/ 包含/ 了/ 多种/ Tag/ 项/ 数组/ ,/ 提高/ 了/ Cache/ 的/ 命中率/ ./ 除此之外/ ,/ 文中/ 还/ 提出/ 一个/ 面向/ 多种/ Cache/ 行/ 设计/ 的/ LRU/ 的/ 替换/ 策略/ ./ 实验/ 结果/ 证明/ 自/ 适应/ Cache/ 行/ 技术/ 极大地提高/ 了/ Cache/ 命中率/ ,/ 跟/ 固定/ 的/ 1024B/ ,/ 512B/ ,/ 256B/ ,/ 128B/ 的/ Cache/ 行/ 的/ 性能/ 相比/ ,/ 自/ 适应/ 的/ Cache/ 行/ 技术/ 的/ 执行/ 速度/ 分别/ 提高/ 了/ 28.9/ %/ ,/ 29.7/ %/ ,/ 32.1/ %/ 和/ 33.5/ %/ ./ 并且/ 与/ ESC/ 相比/ ,/ HLSC/ 不仅/ 具有/ 明显/ 的/ 性能/ 提升/ 而且/ 应用/ 范围/ 更为/ 广泛/ ./ 下/ 一步/ 工作/ 中/ ,/ 我们/ 将/ 同时/ 考虑/ 规则/ 和/ 非/ 规则/ 两种/ 内存/ 引用/ 的/ 特点/ [/ 18/ ]/ ,/ 把/ 该/ 自/ 适应/ 的/ Cache/ 行/ 的/ 策略/ 扩展/ 到/ 混合/ 的/ 内存/ 引用/ 中/ [/ 19/ -/ 20/ ]/ ,/ 从而/ 使该/ 策略/ 更具/ 通用性/ ./ 同时/ 通过观察/ 发现/ ,/ 预取/ 技术/ 能/ 有效/ 地/ 将/ 通信/ (/ DMA/ 操作/ )/ 与/ 计算/ 重叠/ 起来/ ,/ 因此/ ,/ 设计/ 一种/ 面向/ 非/ 规则/ 引用/ 的/ 自/ 适应/ 软件/ Cache/ 的/ 预取/ 技术/ 将/ 是/ 我们/ 下/ 一步/ 的/ 研究/ 重点/ ./ Page12/ 

