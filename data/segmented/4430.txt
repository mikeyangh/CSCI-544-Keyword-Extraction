Page1/ 基于/ GINI/ 指数/ 分类/ 的/ 嵌入式/ CPU/ 功耗/ 预测/ 方法/ 王海/ 高岭/ 宋振孝/ 戴小平/ 卢怡杰/ (/ 西北大学/ 信息科学/ 与/ 技术/ 学院/ 西安/ 710069/ )/ 摘要/ 文中/ 提出/ 了/ 一种/ 基于/ 嵌入式/ 系统/ CPU/ 功耗/ 预测/ 并/ 对/ 其/ 进行/ 低功耗/ 优化/ 的/ 方法/ ./ 引入/ GINI/ 指数/ 的/ 构建/ 训练/ 分类器/ ,/ 利用/ PowerTop/ 工具/ 对系统/ CPU/ 进行/ 监测/ ,/ 并/ 以此/ 作为/ 训练/ 数据/ 集/ ,/ 将/ 该/ 分类器/ 封装/ 到/ 系统/ 中/ ,/ 对/ 嵌入式/ 系统/ 的/ CPU/ 频率/ 、/ 电压/ 及/ 所处/ 的/ 状态/ 进行/ 预测/ ./ 通过/ 仿真/ 实验/ 表明/ ,/ 该/ 方法/ 在/ 系统/ 负载/ 较/ 小/ 的/ 情况/ 下/ ,/ 对/ 嵌入式/ CPU/ 功耗/ 的/ 优化/ 的/ 效果/ 更好/ ./ 关键词/ GINI/ 指数/ ;/ 功耗/ 预测/ ;/ 机器/ 学习/ ;/ CPU/ 功耗/ ;/ 移动/ 互联网/ 1/ 引言/ 近年来/ ,/ 互联网/ 已/ 扩展/ 到/ 以/ 智能手机/ 作为/ 代表性/ 接入/ 设备/ 的/ 移动/ 时代/ ./ 根据/ 2013/ 年/ 2/ 月/ 14/ 日/ 全球/ 技术/ 研究/ 和/ 咨询/ 公司/ 据/ 分析/ 机构/ Gartner/ 发布/ 的/ 新闻/ 公告/ 显示/ ,/ 虽然/ 2012/ 年/ 全球/ 手机/ 销量/ 为/ 17.5/ 亿部/ ,/ 比/ 2011/ 年/ 下降/ 1.7/ %/ ,/ 但/ 2012/ 年/ 智能手机/ 的/ 销量/ 创记录/ 的/ 达到/ 2.07/ 亿/ ,/ 比/ 上年/ 同期/ 增长/ 38.3/ %/ ,/ 预计/ 2013/ 年/ 智能/ 设备/ (/ 智能手机/ 及/ 平板/ 电脑/ )/ 的/ 销量/ 将会/ 突破/ 十亿/ 大关/ ./ 其次/ ,/ 伴随/ 智能/ 终端/ 数量/ 的/ 快速增长/ ,/ 移动/ 应用/ 的/ 深度/ 与/ 广度/ 也/ 得到/ 进一步/ 的/ 发展/ ,/ 并/ 几乎/ 涵盖/ 了/ 传统/ 网络应用/ 的/ 所有/ 层面/ ./ 现在/ 的/ 问题/ 是/ 移动/ 应用/ 增加/ 了/ ,/ 移动/ 终端/ 的/ 功能/ 增加/ 了/ ,/ 但/ 移动/ 终端/ 的/ 供电/ 能力/ 却/ 没有/ 同/ 比例/ 的/ 先行/ 增长/ ,/ 特别/ 是/ 在/ 保证/ 移动/ 重点/ 性能/ 的/ 前提/ 下/ 如何/ 来/ 降低功耗/ 的/ 问题/ 没有/ 得到/ 有效/ 的/ 解决/ ./ 因此/ 要/ 使得/ 移动/ 应用/ 进一步/ 深入/ 普及/ ,/ 迫切需要/ 解决/ “/ 性能/ -/ 功耗/ ”/ 优化/ 问/ Page2/ 题/ ,/ 以/ 有效/ 延长/ 移动/ 设备/ 的/ 待机时间/ 及/ 有效/ 工作/ 时间/ ./ 如何/ 更好/ 的/ 控制/ 嵌入式软件/ 功耗/ 成为/ 当今/ 技术/ 发展/ 的/ 一大/ 热点问题/ ./ 高功耗/ 的/ 嵌入式/ 设备/ 不仅/ 会/ 降低/ 设备/ 性能指标/ ,/ 还会/ 增加/ 系统/ 的/ 不稳定性/ ,/ 电池/ 温度/ 每/ 上升/ 10/ ,/ 系统/ 失效率/ 将/ 提高/ 1/ 倍/ [/ 1/ ]/ ./ 降低/ 嵌入式/ 设备/ 功耗/ 研究/ 包括/ 硬件/ 低功耗/ 设计/ 和/ 软件/ 低功耗/ 设计/ ./ 嵌入式/ 系统/ 的/ 重要/ 特点/ 之一/ 就是/ 工作/ 负载/ 的/ 不/ 均匀/ 性/ 以及/ 动态变化/ 性/ ,/ 可以/ 通过/ 动态/ 关闭/ 设备/ 或者/ 动态/ 调节/ 处理器/ 的/ 工作电压/ 来/ 取得/ 系统/ 性能/ 和/ 功耗/ 之间/ 的/ 平衡/ ./ 而且/ 由于/ 系统/ 支持/ ACPI/ [/ 高级/ 配置/ 和/ 电源/ 管理/ 接口/ ]/ ,/ 易于/ 将/ 低功耗/ 设计/ 策略/ 嵌入/ 到/ 系统/ 内核/ 中/ ./ 鉴于/ 以上/ 原因/ ,/ 本文/ 提出/ 了/ 一种/ 基于/ GINI/ 指数/ 分类/ 方法/ ,/ 将/ 学习/ 到/ 的/ 分类器/ 作为/ 预测/ 模块/ ,/ 插入/ 到/ 已有/ 的/ 系统对/ CPU/ 所处/ 状态/ 进行/ 预测/ ./ 以/ 达到/ 最大化/ 的/ 降低/ 系统/ 的/ 功耗/ ,/ 提高/ 其/ 性能/ 的/ 目的/ ./ 2/ 相关/ 工作/ 目前/ 大量/ 的/ 优化/ 方法/ 集中/ 在/ 硬件/ 级/ [/ 1/ -/ 4/ ]/ 、/ 编译/ 级/ [/ 5/ ]/ 、/ 系统/ 级/ [/ 6/ ]/ 等/ 方面/ ,/ 还/ 没有/ 从根本上/ 实现/ 降低功耗/ 的/ 预期/ 目标/ ./ 在/ 对/ 嵌入式/ 系统/ 功耗/ 的/ 研究/ 中/ ,/ 基于/ 不同/ 的/ 设计/ 目标/ 提出/ 了/ 很多/ 的/ 方法/ ,/ 例如/ 文献/ [/ 7/ ]/ 提出/ 了/ 基于/ CSP/ 的/ 构件/ 化/ 嵌入式软件/ 能耗/ 分析/ 与/ 评估/ 研究/ 方法/ ,/ 文献/ [/ 8/ ]/ 提出/ 了/ 基于/ 模拟器/ 的/ 嵌入式操作系统/ 能耗/ 估算/ 与/ 分析/ ./ 文献/ [/ 9/ ]/ 提出/ 的/ 基于/ 并行度/ 分析模型/ 的/ GPU/ 功耗/ 优化/ 技术/ ,/ 这些/ 多数/ 都/ 是从/ 指令/ 级/ 角度/ 及/ 硬件/ 方面/ 考虑/ 的/ [/ 10/ -/ 13/ ]/ ./ 但是/ 从/ 对系统/ CPU/ 所处/ 的/ 状态/ 进行/ 功耗/ 优化/ 来/ 考虑/ ,/ 这些/ 方法/ 都/ 有/ 其/ 一定/ 的/ 使用/ 局限性/ [/ 14/ ]/ ./ 3/ 基于/ GINI/ 指数/ 的/ 分类/ 预测/ 方法/ 分类/ 是/ 机器/ 学习/ 和/ 数据挖掘/ 的/ 一种/ 重要/ 方法/ ./ 分类/ 是/ 通过/ 对/ 已有/ 标记/ 数据/ 集/ 的/ 学习/ ,/ 构建/ 具有/ 一定/ 泛化/ 能力/ 的/ 分类器/ ,/ 分类器/ 能/ 把/ 未知/ 数据/ 映射/ 到/ 分类器/ 可/ 区分/ 的/ 给定/ 类别/ ./ 已有/ 的/ 分类/ 方法/ 有/ :/ 决策树/ 、/ 贝叶斯/ 网络/ 、/ 遗传算法/ 、/ 粗糙集/ 、/ k/ -/ 最/ 临近/ 法/ 等等/ [/ 15/ ]/ ./ 在/ 已有/ 分类/ 方法/ 中/ ,/ 决策树/ 方法/ 具有/ 计算/ 量/ 小/ 、/ 易于/ 理解/ 、/ 同时/ 适应/ 处理/ 连续/ 和/ 离散/ 数据/ ,/ 能够/ 明确/ 的/ 给出/ 最具/ 区分/ 能力/ 的/ 属性/ 等/ 优点/ ,/ 受到重视/ 和/ 被/ 广泛/ 的/ 应用/ [/ 16/ ]/ ./ 本文/ 提出/ 的/ 基于/ GINI/ 指数/ 的/ 分类/ 预测/ 方法/ 正是/ 决策树/ 的/ 一种/ ./ 3.1/ 决策树/ 算法/ 决策树/ 方法/ 通过/ 对/ 实例/ 进行/ 归纳/ 学习/ ,/ 从/ 无次序/ 、/ 无规则/ 的/ 实例/ 集合/ 构建/ 起/ 一个/ 使用/ 树型/ 结构/ 来/ 表示/ 的/ 分类器/ ./ 构建/ 决策树/ 的/ 分成/ 两个/ 阶段/ :/ 决策树/ 生成/ 与/ 决策树/ 修剪/ ./ 因为/ 决策树/ 创建/ 相对/ 复杂程度/ 更高/ ,/ 因此/ 我们/ 讨论/ 重点/ 落/ 在/ 树/ 的/ 创建/ 上/ ./ 决策树/ 的/ 建立/ 是/ 一个/ 递归/ 的/ 过程/ ,/ 构造/ 树/ 的/ 通用/ 过程/ 如下/ :/ (/ 1/ )/ 从/ 训练样本/ 中/ 选取/ 有/ 代表性/ 的/ 单个/ 结点/ ,/ 开始/ 构造/ 树/ ./ (/ 2/ )/ 如果/ 所有/ 样本/ 都/ 属于/ 该/ 结点/ 类/ ./ 则/ 用/ 该/ 结点/ 的/ 类/ 标号/ 标记/ 此树/ ,/ 称该/ 结点/ 为/ 叶子/ 结点/ ./ (/ 3/ )/ 否则/ 以/ 信息熵/ 的/ 信息/ 增益/ 作为/ 度量/ ,/ 选择/ 分类/ 能力/ 最大/ 的/ 结点/ 属性/ 作为/ 决策树/ 的/ 当前/ 结点/ ./ (/ 4/ )/ 针对/ 每/ 一个/ 训练/ 属性/ 的/ 值/ 构建/ 一个/ 分支/ ,/ 并/ 据此/ 分支/ 值/ 对/ 样本/ 进行/ 划分/ ./ (/ 5/ )/ 算法/ 递归/ 形成/ 各个/ 划分/ 上/ 的/ 判定/ 树/ ./ 如果/ 某个/ 样本/ 已经/ 出现/ 在/ 一个/ 构造/ 过/ 的/ 节点/ 上/ ,/ 则/ 该/ 节点/ 所有/ 后代/ 都/ 不再/ 进行/ 考虑/ ./ 算法/ 终止/ 条件/ :/ ①/ 样本/ 的/ 所有/ 给定/ 结点/ 都/ 属于/ 同/ 一类/ ./ ②/ 可以/ 进一步/ 划分/ 样本/ 的/ 属性/ 已经/ 不/ 存在/ ./ 出现/ 这种/ 情况/ 后/ ,/ 就/ 会/ 使用/ 一种/ 称为/ 多数/ 表决/ 的/ 方法/ ,/ 将/ 剩余/ 的/ 样本/ 结点/ 转换成/ 树叶/ ,/ 以/ 样本/ 中/ 元组/ 个数/ 所属/ 类别/ 最多/ 的/ 那个/ 类别/ 作为/ 标记/ ./ GINI/ 指数/ 等/ ./ 类/ 创建/ 一个/ 树叶/ ./ ③/ 如果/ 某一/ 分枝/ 没有/ 样本/ ,/ 则/ 以/ 样本/ 中/ 的/ 多数/ 属性/ 选择/ 度量/ 有/ 信息/ 增益/ (/ informationgain/ )/ 、/ 在/ 树/ 的/ 构建/ 过程/ 中/ ,/ 有/ 两个/ 关键问题/ :/ (/ 1/ )/ 分割/ 点/ 选取/ ;/ (/ 2/ )/ 如何/ 分割/ 数据/ ./ 决策树/ 算法/ 在/ 对/ 数据/ 进行/ 分类/ 的/ 时候/ ,/ 选取/ 哪个/ 属性/ 作为/ 分割/ 点/ 是/ 一个/ 重要/ 的/ 问题/ ./ 可以/ 用来/ 作为/ 判定/ 分割/ 属性/ 的/ 方法/ 有/ 诸如/ ID3/ ,/ C4/ ./ 5/ 算法/ 中/ 根据/ 信息熵/ 原理/ 总结/ 的/ 信息/ 增益/ 与/ 信息/ 增益/ 率/ ,/ CART/ 、/ SLIQ/ 以及/ SPRINT/ 算法/ 中/ 的/ GINI/ 指数/ 等/ ./ 虽然/ ID3/ 与/ C4/ ./ 5/ 算法/ 在/ 对/ 训练样本/ 集/ 的/ 学习/ 中/ 能够/ 挖掘/ 尽可能/ 多/ 的/ 信息/ ,/ 但是/ 由于/ 利用/ 了/ 信息熵/ 的/ 原理/ ,/ 因而/ 其/ 生成/ 的/ 决策树/ 分支/ 较/ 多/ ,/ 规模/ 较大/ ,/ 算法/ 的/ 可伸缩性/ 与/ 并行性/ 较差/ ./ 而/ 使用/ GINI/ 指/ Page3/ 数来/ 作为/ 判定/ 分割/ 点/ 的/ 标准/ ,/ 则/ 简化/ 了/ 生成/ 决策树/ 的/ 规模/ ,/ 提高/ 了/ 决策树/ 生成/ 的/ 效率/ ./ 并且/ 在/ 算法/ 的/ 可伸缩性/ 与/ 并行性/ 方面/ 的/ 性能/ 也/ 有/ 较大/ 提高/ ./ 因此/ 本文/ 利用/ GINI/ 指数/ 来/ 判定/ 分割/ 点/ ,/ 降低/ 了/ 计算/ 任务/ 的/ 复杂性/ ,/ 从而/ 达到/ 减少/ 在/ 计算/ 方面/ 的/ 开销/ 的/ 目的/ ./ 3.2/ 基于/ GINI/ 指数/ 的/ 分类/ 方法/ 分裂/ 指数/ 是/ 用来/ 度量/ 属性/ 分裂/ 规则/ 优劣/ 程度/ 的/ 一个/ 量度/ ,/ 即/ 我们/ 用来/ 判定/ 选择/ 哪/ 一个/ 属性/ 作为/ 创建/ 决策树/ 的/ 分割/ 点/ 的/ 依据/ ./ 基尼/ 指数/ (/ GINICoeffi/ -/ cient/ )/ 是/ 意大利/ 经济学家/ 基尼/ (/ CorradoGini/ ,/ 1884/ ~/ 1965/ )/ 于/ 1912/ 年/ 提出/ 的/ 用于/ 定量/ 度量/ 的确/ 收入/ 差异/ 程度/ 的/ 指标/ ./ 当/ 我们/ 在/ 选择/ 分割/ 属性/ 的/ 时候/ 遇到/ 离散/ 型/ 属性/ ,/ 首先/ 将/ 其/ 属性/ 分组/ ,/ 然后/ 根据/ 各/ 属性/ 的/ 取值/ 将/ 其/ 排序/ ,/ 以/ 方便/ 计算/ ./ 如果/ 我们/ 在/ 选择/ 分割/ 属性/ 的/ 时候/ 遇到/ 连续型/ 属性/ ,/ 首先/ 对/ 该/ 连续型/ 属性/ 的/ 值/ 进行/ 排序/ ,/ 得到/ 一组/ 有序/ 的/ 数据/ 集/ ,/ 然后/ 对/ 该/ 数据/ 集/ 使用/ 一个/ 称为/ 游标/ 的/ 标尺/ 来/ 标记/ ,/ 将/ 其/ 分为/ 两个/ 部分/ ,/ 这样/ 就/ 相当于/ 将/ 其/ 离散/ 化成/ 两个/ 值/ ./ 分别/ 计算/ 这/ 两/ 部分/ 数据/ 的/ GINI/ 指数/ ,/ 然后/ 将/ 游标/ 向/ 后/ 移动/ 一位/ ,/ 继续/ 对/ 数据/ 进行/ 划分/ ,/ 再/ 分别/ 计算/ 这/ 两/ 部分/ 数据/ 的/ GINI/ 指数/ ,/ 直到/ 将/ 数据/ 划分/ 完毕/ ,/ 对/ 所/ 计算/ 的/ GINI/ 指数/ 进行/ 比较/ ,/ 选择/ 最小/ 的/ 那个/ 作为/ 这组/ 数据/ 的/ 分裂/ 指标/ [/ 17/ ]/ ./ 计算/ 具体/ GINI/ 指数/ 的/ 方法/ 如下/ :/ 关/ 的/ 类/ ,/ 则/ 设/ 数据/ 集/ S/ 有/ n/ 条/ 记录/ ,/ 分别/ 属于/ c/ 个/ 互不/ 相/ 其中/ Pj/ =/ m/ // n/ ,/ m/ 为/ S/ 中/ 属于/ 类/ j/ 的/ 记录/ 个数/ ./ 如果/ 集合/ S/ 划分/ 为/ 两个/ 子集/ S1/ ,/ S2/ ,/ 分别/ 对应/ n1/ ,/ n2/ 条/ 记录/ ,/ 那么/ 这个/ 分割/ 的/ GINI/ 指数/ 就是/ Ginisplit/ (/ S/ )/ =/ n1nGini/ (/ S1/ )/ +/ n2nGini/ (/ S2/ )/ ./ 若/ 这个/ 值越/ 小/ ,/ 则/ 这个/ 分裂/ 规则/ 越好/ ./ 例如/ ,/ 现在/ 有/ n/ 个/ 连续型/ 属性/ ,/ 首先/ 将/ 此/ n/ 个/ 属性/ 进行/ 排序/ ,/ 对于/ 排序/ 完成/ 的/ 数据/ 集/ ,/ 我们/ 用/ 一个/ 称为/ 游标/ 的/ 标尺/ 来/ 对/ 数据/ 进行/ 划分/ ./ 这个/ 游标/ 主要/ 是/ 用来/ 对/ 我们/ 所/ 要/ 处理/ 的/ 数据/ 进行/ 标识/ ./ 当/ 我们/ 进行/ 数据处理/ 时/ ,/ 移动/ 游标/ ,/ 分别/ 将/ 数据/ 划分/ 为/ 游标/ 左端/ 与/ 右端/ 两/ 部分/ (/ Cbelow/ -/ Cabove/ )/ ,/ 即/ 1/ -/ (/ n/ -/ 1/ )/ ,/ 2/ -/ (/ n/ -/ 2/ )/ ,/ 3/ -/ (/ n/ -/ 3/ )/ …/ (/ n/ -/ 2/ )/ -/ 2/ ,/ (/ n/ -/ 1/ )/ -/ 1/ ,/ 并且/ 这些/ 数据/ 都/ 是/ 按照/ 从大到/ 小/ 的/ 顺序排列/ 的/ ./ 分别/ 根/ Cbelow/ 与/ Cabove/ 作为/ 分割/ 标准/ [/ 18/ ]/ ./ 据/ 不同/ 的/ Cbelow/ 与/ Cabove/ ,/ 计算/ 出/ :/ Ginisplit/ (/ S1/ )/ =/ Gini/ (/ S1/ (/ 1/ )/ )/ +/ Gini/ (/ S1/ (/ n/ -/ 1/ )/ )/ ,/ Ginisplit/ (/ S2/ )/ =/ Gini/ (/ S2/ (/ 2/ )/ )/ +/ Gini/ (/ S2/ (/ n/ -/ 2/ )/ )/ …/ Ginisplit/ (/ Sn/ -/ 1/ )/ =/ Gini/ (/ Sn/ -/ 1/ (/ n/ -/ 1/ )/ )/ +/ Gini/ (/ Sn/ -/ 1/ (/ 1/ )/ )/ ./ 选择/ 这些/ Ginisplit/ 中/ 的/ 最小值/ ,/ 并/ 以/ 最小值/ 的/ 基于/ GINI/ 指数/ 的/ 分类/ 方法/ 通过/ 划分/ 连续型/ 属性/ 值/ ,/ 将/ 其/ 离散/ 化为/ 两个/ 值/ ,/ 大大简化/ 了/ 计算/ 复杂度/ ,/ 提高/ 了/ 效率/ ,/ 是/ 一种/ 简单/ 有效/ 的/ 方法/ ,/ 且/ 其/ 效果/ 经过/ 证明/ 也/ 是/ 非常/ 理想/ 的/ ./ 4Linux/ 内核/ 中/ CPU/ 的/ 工作/ 状态/ 基于/ Linux/ 的/ 嵌入式/ 系统/ 中/ ,/ CPU/ 的/ 工作/ 功耗/ 是/ 整个/ 系统/ 中/ 至关紧要/ 的/ 部分/ ,/ 如何/ 降低/ CPU/ 的/ 工作/ 功耗/ ,/ 关系/ 到/ 整个/ 系统/ 节能/ 工作/ 的/ 成败/ ./ 对于/ 处理器/ 功耗/ 的/ 控制/ 的/ 一种/ 手段/ 就是/ 降低/ CPU/ 的/ 工作频率/ 以及/ 使/ 处理器/ 长期/ 处在/ 无/ 任务调度/ 的/ 睡眠/ 状态/ 下/ ./ 在/ Linux/ 系统/ 中/ 通过/ ACPI/ 可以/ 实现/ 对/ 处理器/ 的/ 各种/ 工作/ 状态/ 的/ 控制/ ,/ 并且/ 通过/ CPUfreq/ 子系统/ 可以/ 实现/ 对/ 处理器/ 动态/ 频率/ 的/ 控制/ ./ 4.1/ ACPI/ 中/ 处理器/ 的/ 状态/ ACPI/ 即/ AdvancedConfigurationandPowerManagementInterface/ ,/ 高级/ 配置/ 电源/ 管理/ 接口/ [/ 19/ ]/ ./ 1997/ 年/ 由/ Intel/ 、/ Microsoft/ 、/ Toshiba/ 所/ 共同/ 制定/ 提供/ 操作系统/ 应用程序/ 管理/ 所有/ 电源/ 管理/ 接口/ ./ 在/ 处理器/ 电源/ 管理/ 中/ ,/ 它/ 定义/ 了/ 处理器/ 的/ 4/ 个/ 状态/ :/ C0/ 、/ C1/ 、/ C2/ 、/ C3/ ,/ 当/ 处理器/ 处于/ C1/ 、/ C2/ 、/ C3/ 态时/ ,/ 比/ C0/ 态/ 能耗/ 低/ ,/ 散热/ 也/ 低/ ,/ 处理器/ 处于/ 睡眠/ 态/ ,/ 不/ 执行/ 指令/ ,/ 也/ 就是/ 所谓/ 的/ 低功耗/ 工作/ 状态/ ./ (/ 1/ )/ C0/ 态/ 这/ 是/ 处理器/ 正常/ 工作/ 状态/ ,/ 可以/ 执行/ 指令/ ,/ 也/ 是/ 正常/ 能耗/ 状态/ ./ (/ 2/ )/ C1/ 态/ 通过/ “/ HLT/ ”/ 指令/ 进入/ ,/ 所有/ 处理器/ 都/ 支持/ 此/ 状态/ ./ 从/ C1/ 到/ C0/ 的/ 唤醒/ 时间/ 最短/ ,/ 任何/ CPU/ 唤醒/ 事件/ ,/ 例如/ 处理器/ 产生/ 中断/ ,/ 必须/ 返回/ C0/ 态/ ./ (/ 3/ )/ C2/ 态/ 处理器/ 时钟/ 和/ I/ // O/ 缓冲/ 停止/ ,/ 它/ 比/ C1/ 态/ 能耗/ 低/ ./ 可/ 通过/ P/ -/ LV3/ 寄存器/ 进入/ 此/ 状态/ ./ 从/ C2/ 态/ 进入/ C0/ 态/ 需要/ 至少/ 100ns/ ./ 在/ 此/ 状态/ 时/ ,/ 任何/ CPU/ 唤醒/ 事件/ ,/ 也/ 都/ 需要/ 返回/ C0/ 态/ ./ Page4/ (/ 4/ )/ C3/ 态/ 与/ C2/ 态/ 类似/ ,/ 总线/ 和/ PLL/ 均/ 锁定/ ,/ 内存/ 关闭/ ,/ 保持/ CACHE/ ,/ 因此/ 能耗/ 比较/ 低/ ,/ 但/ C2/ 态大/ ,/ 唤醒/ 需/ 一定/ 时间/ ./ 在/ 此/ 状态/ 时/ ,/ 任何/ CPU/ 唤醒/ 事件/ ,/ 也/ 都/ 返回/ C0/ 状态/ ./ CPU/ 的/ 睡眠/ 程度/ 越深/ ,/ 能耗/ 越低/ ,/ 因此/ 为了/ 节能/ 需要/ 尽可能/ 让/ CPU/ 更/ 多/ 处于/ C1/ 、/ C2/ 、/ C3/ 等/ 状态/ ./ 由于/ 任务/ 的/ 不确定性/ 导致/ CPU/ 在/ 此/ 4/ 种/ 状态/ 间/ 频频/ 切换/ ,/ 会/ 产生/ 大量/ 因/ 切换/ 而/ 带来/ 的/ 能耗/ 开销/ ./ 对/ 这些/ 开销/ 进行/ 控制/ ,/ 可以/ 更好/ 的/ 控制/ CPU/ 的/ 功耗/ ./ 处理器/ 的/ 电源/ 状态/ 如图/ 1/ 所示/ ./ 4.2/ CPUfreq/ 子系统/ 2.6/ ./ 10Linux/ 以上/ 所/ 支持/ 的/ CPUfreq/ 子系统/ 可以/ 动态/ 地/ 调节/ 处理器/ 的/ 频率/ ./ 可以/ 用/ CPUfreq/ 子系统/ 和/ 内核/ 调控/ 器来/ 修改/ 处理器/ 的/ 频率/ ,/ 改善/ 系统/ 的/ 效率/ ./ 当/ 处理器/ 以较/ 低/ 的/ 时钟/ 速度/ 运行/ 时/ ,/ 它们/ 消耗/ 的/ 电能/ 和/ 产生/ 的/ 热量/ 也/ 相对/ 较少/ ./ CPUfreq/ 结构/ 利用/ 调控/ 器来/ 为/ 系统/ 设置/ 静态/ 或/ 动态/ 电源/ 策略/ ./ 动态/ 调控/ 器/ 可以/ 根据/ CPU/ 利用率/ 来/ 调整/ CPU/ 频率/ ,/ 从而/ 有助于/ 节省/ 电能/ ,/ 且/ 不会/ 牺牲/ 性能/ ./ 图/ 2/ 显示/ 了/ CPU/ 频率/ ,/ 电压/ 和/ 功耗/ 之间/ 的/ 关系/ ./ 所谓/ 的/ CPU/ 性能/ 状态/ (/ P/ -/ state/ )/ ,/ 是/ 与/ CPU/ 频率/ 和/ 电压/ 相关/ 的/ 运转/ 状态/ ./ C/ -/ state/ 对应/ 相应/ 的/ 处理器/ 工作/ 状态/ ,/ CPU/ 在/ 不同/ 状态/ 之间/ 进行/ 切换/ 的/ 时候/ 也/ 会/ 产生/ 额外/ 的/ 功耗/ ,/ 如果/ CPU/ 在/ 进入/ 一个/ 休眠状态/ 后/ 需要/ 立即/ 唤醒/ ,/ 那么/ 由此/ 产生/ 的/ 功耗/ 比/ 处于/ 休眠状态/ 节省/ 的/ 功耗/ 还要/ 多/ ,/ 因此/ 便/ 达/ 不到/ 节省/ 系统/ 功耗/ 的/ 目的/ ./ 如何/ 让/ CPU/ 更/ 多/ 的/ 处于/ 低电压/ 低/ 频率/ 的/ 工作/ 状态/ 并且/ 又/ 不/ 影响/ 系统/ 的/ 整体/ 性能/ 即/ 避免/ 产生/ 额外/ 的/ 功耗/ 便是/ 整个/ 问题/ 的/ 关键/ ./ 这里/ 我们/ 提出/ 了/ 基于/ GINI/ 指数/ 的/ 分类/ 预测/ 方法/ ,/ 对系统/ 任务/ 进行/ 分类/ 预测/ ,/ 从而/ 使/ CPU/ 更/ 多/ 的/ 处于/ 低电压/ 低/ 频率/ 的/ 工作/ 状态/ ,/ 达到/ 降低/ 系统/ 功耗/ 的/ 目的/ ./ 5/ 能耗/ 预测/ 模块/ 的/ 构造/ 建立/ 能耗/ 预测/ 模块/ 的/ 过程/ 可以/ 分为/ 3/ 个/ 阶段/ :/ (/ 1/ )/ 通过/ 系统/ 监测/ 获取/ 训练/ 数据/ 集/ ;/ (/ 2/ )/ 使用/ 基于/ GINI/ 指数/ 的/ 分类/ 方法/ 通过/ 训练/ 集/ 生成/ 分类器/ ;/ 本文/ 通过/ PowerTop/ 记录/ 系统/ 运行/ 的/ 各种/ 参数/ (/ 3/ )/ 能耗/ 预测/ ./ 5.1/ 训练/ 数据/ 采集/ 以/ 得到/ 能耗/ 预测/ 模块/ 所/ 需/ 的/ 训练/ 数据/ ./ 5.2/ 分类器/ 训练/ 传统/ 的/ 动态/ 电压/ 调节/ 算法/ 都/ 是/ 按/ 一定/ 周期/ 去/ 检测/ CPU/ 使用率/ ,/ 以此/ 为/ 根据/ 动态/ 调节/ CPU/ 电压/ 及/ 频率/ 进行/ “/ 性能/ -/ 功耗/ ”/ 优化/ ./ 动态/ 调节/ CPU/ 电压/ 和/ 频率/ 一般/ 分为/ 两类/ :/ 任务/ 外/ (/ intra/ -/ task/ )/ 方式/ 和/ 任务/ 内/ (/ inter/ -/ task/ )/ 方式/ ./ 这里/ 主要/ 介绍/ 任务/ 内/ (/ inter/ -/ task/ )/ 方式/ ./ 根据/ 依据/ 的/ 信息/ 不同/ ,/ 任务/ 内/ (/ inter/ -/ task/ )/ 方式/ 可/ 分为/ 3/ 类/ :/ (/ 1/ )/ 基于/ 任务/ 最后/ 期限/ 作为/ CPU/ 调节/ 的/ 依据/ ,/ 根据/ 最坏/ 情况/ 下/ 任务/ 需要/ 的/ 时间/ ,/ 计算/ 下/ 一个/ 时间段/ 的/ 大小/ ./ 由于/ 难以获得/ 任务/ 的/ 最后/ 期限/ 信息/ ,/ 因此/ 此/ 方法/ 可行性/ 不高/ ./ (/ 2/ )/ 实时/ 检测/ 任务/ 执行/ 过程/ ,/ 例如/ 创建/ 、/ 删除/ 、/ 切换/ 及/ 系统/ 调用/ 等/ ,/ 据此/ 作为/ 调节/ CPU/ 的/ 依据/ ./ 检测/ 任务/ 的/ 这些/ 特征/ 信息/ 会/ 带来/ 额外/ 的/ 消耗/ ,/ 大约/ 占/ 1/ %/ ~/ 4/ %/ ./ (/ 3/ )/ 按/ 一定/ 周期/ 监测/ CPU/ 使用率/ ,/ 通过/ 对下/ 一个/ 时间段/ CPU/ 使用率/ 进行/ 预测/ 来/ 调节/ CPU/ ./ 这种/ 方式/ 实用性/ 强/ ,/ 且/ 实现/ 简单/ ./ 在/ 本文/ 中/ ,/ 我们/ 从/ 另/ 一个/ 角度/ 去/ 考虑/ ,/ 每个/ 任务/ Page5/ 在/ 执行/ 的/ 时候/ 不是/ 一直/ 在/ 占用/ CPU/ ,/ 而是/ 会/ 不断/ 唤醒/ CPU/ ,/ 因为/ 任务/ 在/ 执行/ 的/ 时候/ 需要/ 准备/ 数据/ 并/ 做出/ 相应/ 的/ 处理/ ,/ 然后/ 当/ 这些/ 处理完毕/ 的/ 时候/ ,/ 才/ 会/ 去/ 中断/ CPU/ 的/ 休眠状态/ ,/ 让/ CPU/ 执行/ ./ 然后/ 再/ 做/ 相应/ 的/ 准备/ 工作/ ,/ 反复/ 占用/ CPU/ 运行/ ,/ 直到/ 运行/ 完毕/ ./ 首先/ ,/ 根据/ 所/ 获取信息/ ,/ 判断/ 一个/ 任务/ 是/ 属于/ CPU/ 密集型/ 任务/ (/ C/ )/ 还是/ I/ // O/ 密集型/ 任务/ (/ IO/ )/ ,/ 不同/ 类型/ 的/ 任务/ 需要/ 不同/ 的/ 运行/ 策略/ ,/ 非/ CPU/ 密集型/ 任务/ 可以/ 暂时/ 不去/ 唤醒/ CPU/ ,/ 而是/ 等待/ 合适/ 的/ 时间/ 再/ 去/ 唤醒/ CPU/ ,/ 这样/ 可以/ 让/ CPU/ 在/ 更/ 多/ 的/ 时间/ 内/ 处于/ 低电压/ 低功耗/ 的/ 休眠/ 的/ 状态/ ,/ 然后/ 根据/ 任务/ 单位/ 时间/ 内/ 唤醒/ CPU/ 的/ 次数/ ,/ 计算/ 其/ 处于/ C0/ 状态/ (/ 运行/ 态/ )/ 以及/ C1/ ,/ C2/ ,/ C3/ 等/ 状态/ (/ 低功耗/ 态/ )/ 的/ 比例/ ,/ 并/ 根据/ 其/ 不同/ 的/ 比例/ 把/ 任务/ 分成/ 高功耗/ 任务/ 与/ 低功耗/ 任务/ ./ 对于/ 高功耗/ 任务/ ,/ 我们/ 让/ 其/ 更/ 多/ 的/ 时间/ 处于/ CPU/ 较/ 高频率/ 与/ 电压/ 状态/ ,/ 即/ 尽快/ 执行/ 完毕/ ./ 对于/ 低功耗/ 任务/ ,/ 我们/ 则/ 根据/ 系统/ 情况/ ,/ 让/ 其/ 更/ 多/ 的/ 处于/ 低电压/ 低/ 频率/ 状态/ ,/ 从而/ 达到/ 降低/ 系统/ 功耗/ 的/ 目的/ ./ 根据/ 所/ 获得/ 的/ 历史数据/ ,/ 更新/ 所有/ 进程/ 在/ 已/ 执行/ 时间/ 内/ 的/ CPU/ 使用率/ ,/ 设/ Q/ 为/ 最小/ 时间段/ 长度/ ,/ 每隔/ Q/ 的/ 时间/ 后/ 产生/ 一个/ 时钟/ 中断/ ./ 进程/ i/ 的/ CPU/ 使用率/ 为/ ei/ // I/ ,/ 其中/ ei/ 为/ 该/ 进程/ 的/ 执行/ 时间/ ,/ I/ 为/ 计时器/ 的/ 间隔时间/ 长度/ ./ 进程/ 的/ 执行/ 时间/ 需要/ 根据/ 系统/ 最佳/ 性能/ 进行/ 标准化/ ./ 例如/ ,/ 假定/ CPU/ 频率/ 最大值/ 为/ 600MHz/ ,/ 某个/ 进程/ 在/ CPU/ 频率/ 为/ 300MHz/ 时/ 执行/ 了/ 10ms/ ,/ 标准化/ 后/ 其/ 执行/ 时间/ 为/ 5ms/ ./ 通过/ 正在/ 进行/ 的/ 优先级/ 及/ 时间/ 片/ 预测/ 下一阶段/ 将要/ 运行/ 的/ 进程/ ,/ 算法/ 进一步/ 预测/ 下/ 一个/ 周期/ CPU/ 可以/ 使用/ 的/ 频率/ ,/ 并/ 根据/ 系统/ 所/ 获取/ 的/ 数据/ ,/ 预测/ 最佳/ 的/ 系统/ 模式/ ,/ 这样/ 做/ 既保证/ 进程/ 的/ 执行/ ,/ 又/ 节约/ 系统/ 功耗/ ./ 5.3/ 预测/ 算法/ 能耗/ 预测/ 算法/ 过程/ 如下/ :/ (/ 1/ )/ 首先/ 分析/ 任务/ 运行/ 中/ 的/ 参数值/ ,/ 包括/ 任务/ 类型/ 、/ 需/ 唤醒/ CPU/ 次数/ 等/ ;/ (/ 2/ )/ 根据/ 分析/ 得到/ 的/ 数值/ ,/ 使用/ 分类器/ 对/ 任务/ 所属/ 类型/ 进行/ 分类/ ;/ (/ 3/ )/ 根据/ (/ 2/ )/ 中/ 分类/ 结果/ ,/ 判断/ 任务/ 执行/ 时/ 合适/ 的/ 唤醒/ CPU/ 时间/ 以及/ 预测/ 下个/ 任务/ 执行/ 时/ CPU/ 所处/ 的/ 最佳/ 状态/ ,/ 将/ 结果/ 返回/ 给/ 用户/ ./ 预测/ 过程/ 的/ 算法/ 如下/ ./ 算法/ 1/ ./ 预测/ 过程/ 算法/ ./ 输入/ :/ 将/ 在/ CPU/ 中/ 运行/ 的/ 任务/ 样本/ X/ 输出/ :/ 任务/ 类别/ S/ // // 输入/ 为/ 系统/ 将要/ 运行/ 的/ 任务/ 样本/ X/ // // 输出/ 为/ x/ 的/ 预测/ 判断/ 结果/ // // S/ 为/ 判断/ 任务/ 运行/ 中/ 处理器/ 所处/ 的/ 状态/ ,/ 分为/ S0/ 、/ S1/ 、/ S2/ 、/ S3/ (/ S0/ 中/ 处理器/ 80/ %/ 的/ 时间/ 处于/ C0/ 状态/ ,/ 并/ 将/ 处理器/ 电压/ 频率/ 调/ 至/ 最高/ ,/ 其他/ 时间/ 处于/ C1/ 等/ 低功耗/ 状态/ ./ S1/ 中/ 处理器/ 60/ %/ 的/ 时间/ 处于/ C0/ 状态/ ,/ 并/ 将/ 处理器/ 电压/ 频率/ 调至/ 比/ 在/ C0/ 状态/ 时低/ 一些/ ,/ S2/ 中/ 处理器/ 40/ %/ 的/ 时间/ 处于/ C0/ 状态/ ,/ 并/ 将/ 处理器/ 电压/ 频率/ 调至/ 比/ 在/ C1/ 状态/ 时低/ 一些/ ,/ S3/ 中/ 处理器/ 20/ %/ 的/ 时间/ 处于/ C0/ 状态/ ,/ 并/ 将/ 处理器/ 电压/ 频率/ 调/ 至/ 最低/ )/ 的/ 类别/ 的/ 建议/ ;/ 1/ ./ S/ =/ 0/ ;/ 2/ ./ 从/ 数据库/ 表中/ 取出/ 任务/ X/ 的/ 数据/ ;/ 3/ ./ 根据/ 获得/ 的/ 任务/ X/ 的/ 运行/ 状态参数/ ,/ 按照/ 已/ 训练/ 好/ 的/ 分类器/ 预测/ 其/ 运行/ 中需/ 唤醒/ CPU/ 的/ 次数/ ,/ 与/ 外设/ 的/ 交互/ 时间/ 以及/ 在/ 处理器/ 中/ 的/ 运行/ 时间/ ;/ 4/ ./ 根据/ 预测/ 的/ 结果/ 给出/ 任务/ X/ 运行/ 时/ CPU/ 的/ 状态/ ,/ S5/ ./ 将/ 预测/ 的/ 结果/ 返回/ 给/ 系统/ ;/ 6/ ./ 结束/ ;/ 7/ ./ 返回/ 最终/ 的/ 结果/ ./ 算法/ 在/ 判断/ 每个/ 任务/ 所属/ 的/ 类型/ 及其/ 在/ 运行/ 过程/ 中/ 所/ 需要/ 唤醒/ 的/ 等/ CPU/ 的/ 次数/ 以及/ 由此/ 引起/ 的/ CPU/ 的/ 状态/ 的/ 变化/ 方面/ 具有/ 简单/ 、/ 有效/ 且/ 差错率/ 小/ 的/ 特点/ ./ 最终/ 结果/ 反馈/ 给/ 用户/ 即/ 系统/ ,/ 使/ 系统/ 确定/ 其/ CPU/ 可以/ 处于/ 哪/ 一个/ 低功耗/ 的/ 工作/ 状态/ 且/ 不/ 牺牲/ 其/ 性能/ ,/ 从而/ 达到/ 降低/ 系统/ 功耗/ 的/ 目的/ ./ 5.4/ 自动更新/ 能耗/ 预测/ 模块/ 持续/ 记录/ 数据/ ,/ 定期/ 重新/ 生成/ 分类器/ ./ 通过/ 保持/ 训练/ 数据/ 的/ 时效性/ 来/ 确保/ 预测/ 的/ 准确/ ./ 6/ 仿真/ 实验/ 分析/ 为了/ 展示/ 我们/ 在/ 系统/ 电源/ 管理/ 上/ 的/ 优化/ 效果/ ,/ 在/ 这里/ 通过/ 模拟/ 单一/ 任务/ 在/ 单/ 处理器/ 中/ 按照/ 分类/ 策略/ 预测/ 算法/ 与/ 无/ 分类/ 策略/ 预测/ 算法/ 运行/ 的/ 情况/ ,/ 并/ 进一步/ 对/ 两种/ 运行/ 方式/ 的/ 结果/ 进行/ 对比/ 分析/ ,/ 可以/ 发现/ 我们/ 提出/ 的/ 分类/ 预测/ 方法/ 在/ 系统/ 能耗/ 的/ 节省/ 方面/ 达到/ 了/ 预期/ 效果/ ./ 6.1/ 实验/ 准备/ 本/ 实验/ 使用/ MatLab/ 进行/ 系统/ 能耗/ 仿真/ ,/ 使用/ WEKA/ 分析/ 仿真/ 数据/ ,/ 仿真/ 系统/ 在/ 单核/ 情况/ 下/ 运行/ 单任务/ ./ 假设/ 没有/ 任何/ 能耗/ 优化/ 策略/ 情况/ 下/ 系统/ 的/ 能耗/ 为/ 1/ ,/ 即/ 作为/ 比较/ 的/ 基准/ ./ 通过/ 系统/ 仿真/ ,/ 观察/ Page6/ 并/ 记录/ 系统/ 在/ 没有/ 应用/ 任何/ 策略/ 的/ 情况/ 下/ 的/ 运行/ 情况/ ,/ 然后/ 再/ 观察/ 并/ 记录/ 在/ 应用/ 了/ 分类/ 策略/ 的/ 情况/ 下/ 的/ 系统/ 运行/ 情况/ ,/ 最后/ 将/ 运行/ 结果/ 进行/ 汇总/ 为/ 对比/ 分析/ 做/ 准备/ ./ 6.2/ 实验/ 数据分析/ 获取/ 训练/ 数据/ 与/ 分类器/ 训练/ 的/ 主要/ 任务/ 就是/ 确定/ 要/ 研究/ 的/ 任务/ 类型/ 及其/ 在/ 系统/ 运行/ 中/ 的/ 能耗/ 情况/ ./ 根据/ 前面/ 所/ 提出/ 的/ 算法/ 的/ 需要/ ,/ 需要/ 模拟/ 程序运行/ 过程/ 中使/ 处理器/ 处于/ 工作/ 的/ 时间/ ,/ 与/ 外设/ 进行/ 数据/ 交互/ 的/ 时间/ 、/ 唤醒/ CPU/ 的/ 次数/ ./ 根据/ 最后/ 模拟/ 的/ 运行/ 结果/ 判断/ 任务/ 运行/ 过程/ 中/ 处理器/ 所应/ 处/ 的/ 工作/ 模式/ 类型/ ./ 根据/ 对/ 已有/ 研究成果/ 的/ 学习/ ,/ 系统/ 任务/ 的/ 运行/ 情况/ 是/ 一个/ 随机/ 的/ 过程/ ,/ 对/ 任务/ 运行/ 时/ 具体/ 的/ 实验/ 数据/ 的/ 提取/ 存在/ 一定/ 的/ 困难/ ,/ 因此/ 在/ 这里/ 对/ 数据/ 需要/ 进行/ 一定/ 的/ 假设/ ./ 利用/ PowerTop/ 对系统/ 运行/ 的/ 情况/ 进行/ 监控/ ,/ 可以/ 发现/ 任务/ 在/ 运行/ 的/ 过程/ 中/ ,/ 前面/ 提到/ 的/ 3/ 个/ 指标/ 大体上/ 服从/ 一种/ 平均/ 分布/ ,/ 我们/ 假设/ 要/ 模拟/ 的/ 实验/ 数据/ 服从/ 平均/ 分布/ 情况/ ,/ 对/ 其/ 数据/ 在/ 一定/ 范围/ 内/ 进行/ 限制/ 设置/ ./ 在/ 仿真/ 实验/ 中/ ,/ 实验/ 条件/ 设置/ 如下/ :/ (/ 1/ )/ 任务/ 在/ 处理器/ 中/ 的/ 运行/ 时间/ (/ T1/ )/ 限制/ 为/ (/ 2/ )/ 任务/ 与/ 外设/ 的/ 交互/ 时间/ (/ T2/ )/ 限制/ 为/ 1/ ~/ 200/ ,/ (/ 3/ )/ 任务/ 唤醒/ CPU/ 的/ 次数/ (/ R1/ )/ 限制/ 为/ 1/ ~/ 50/ ,/ 1/ ~/ 100/ ,/ 单位/ 为/ 毫秒/ (/ ms/ )/ ./ 单位/ 为/ 毫秒/ (/ ms/ )/ ./ 单位/ 为次/ // 毫秒/ (/ 次/ // ms/ )/ ./ 6.3/ 实验/ 结果/ 与/ 分析/ 用/ MatLab/ 随机/ 生成/ 两千/ 组/ 数据/ 作为/ 我们/ 模拟/ 的/ 任务/ ,/ 每组/ 数据/ 包含/ 3/ 个数/ ,/ 分别/ 代表/ 处理器/ 运行/ 时间/ 、/ 与/ 外设/ 交互/ 时间/ 以及/ 唤醒/ CPU/ 次数/ ,/ 在/ 这里/ 我们/ 不/ 考虑/ 其他/ 因素/ 对/ 任务/ 实际/ 运行/ 中/ 的/ 能耗/ 影响/ ./ 为了/ 得到/ 最终/ 需要/ 的/ 分类/ 结果/ ,/ 在/ 这里/ 我们/ 为/ T1/ ,/ T2/ ,/ R1/ 分别/ 赋予/ 一个/ 影响/ 因子/ ,/ 考虑/ 到/ 对系统/ 能耗/ 的/ 影响/ 不同/ ,/ 分别/ 赋予/ 的/ 因子/ 为/ 0.8/ ,/ 0.2/ ,/ 0.05/ ,/ 结合/ 影响/ 因子/ 计算/ 出/ 每个/ 任务/ 产生/ 的/ 系统/ 能耗/ ./ 表/ 1/ 给出/ 了/ 模拟/ 的/ 任务/ 数据/ ,/ 最后/ 一项/ 系统/ 功耗/ 是/ 结合/ 影响/ 因子/ 及/ 处理器/ 工作/ 时/ 处于/ 不同/ 的/ 电压/ 频率/ 计算/ 得出/ ./ 通过/ 表/ 1/ 的/ 数据/ 我们/ 可以/ 看到/ ,/ 当/ 任务/ 在/ 处理器/ 中/ 运行/ 的/ 时间/ 接近/ ,/ 而/ 与/ 外设/ 的/ 交互/ 时间/ 不/ 一样/ 时/ ,/ 例如/ 任务/ 1/ 与/ 任务/ 2/ ,/ 他们/ 与/ 外设/ 的/ 交互/ 时间/ 相差/ 很大/ ,/ 但是/ 最终/ 消耗/ 的/ 系统/ 能耗/ 确/ 相差/ 不/ 大/ ,/ 再/ 看/ 任务/ 1/ 与/ 任务/ 1998/ ,/ 它们/ 在/ 运行/ 过程/ 中/ 与/ 外设/ 交互/ 的/ 时间/ 相差无几/ ,/ 但是/ 在/ 处理器/ 中/ 的/ 运行/ 时间/ 相差/ 很多/ ,/ 最终/ 消耗/ 的/ 系统/ 能耗/ 相差/ 了/ 3/ 倍/ 之/ 多/ ,/ 这/ 说明/ 与/ 外设/ 交互/ 时/ 消耗/ 的/ 能耗/ 占/ 整个/ 任务/ 运行/ 期间/ 消耗/ 的/ 系统/ 能耗/ 比例/ 很/ 低/ ,/ 唤醒/ CPU/ 产生/ 的/ 系统/ 功耗/ 也/ 只/ 占/ 总/ 的/ 系统/ 能耗/ 的/ 一小部分/ ,/ 大部分/ 的/ 能耗/ 由/ 任务/ 在/ 处理器/ 中/ 运行/ 时/ 产生/ ./ 图/ 3/ 反应/ 了/ 任务/ 在/ 没有/ 应用/ 任何/ 运行/ 策略/ 时所/ 产生/ 的/ 系统/ 能耗/ 的/ 曲线图/ ./ 在/ 这里/ 为了/ 绘图/ 的/ 方便/ ,/ 我们/ 选取/ 前/ 100/ 个/ 任务/ 作为/ 样本/ ,/ 使/ 大家/ 可以/ 清晰/ 的/ 看到/ 运行/ 效果/ ./ 任务/ 号/ 处理器/ 运行/ 123456/ / 199819992000/ 接下来/ 使用/ WEKA/ 来/ 分类/ 数据/ 达到/ 模拟/ 分类器/ 的/ 效果/ ,/ 首先/ 将/ 数据/ 按/ 类别/ 排序/ 分别/ 计算/ 其/ GINI/ 指数/ ,/ 计算方法/ 按照/ 前面/ 提出/ 的/ 算法/ 进行/ ./ 按照/ 计算/ 所得/ 的/ GINI/ 指数/ 对/ 任务/ 进行/ 分类/ ,/ 对于/ 高功耗/ 的/ 任务/ ,/ 使/ 其/ 处于/ 分类/ 结果/ 中/ 的/ S0/ ,/ 然后/ 依次/ 按照/ 计算/ 得出/ 的/ 功耗/ 数值/ 分为/ S1/ ,/ S2/ ,/ S3/ ,/ 将/ 数据/ 代入/ WEKA/ 中/ ,/ 分类/ 效果/ 及/ 分类/ 树/ 情况/ 分别/ 如图/ 4/ 与/ 图/ 5/ 所示/ ./ 通过/ 实验/ 可以/ 看到/ ,/ 我们/ 所/ 提出/ 的/ 分类/ 算法/ 在/ 类型/ 分类/ 的/ 正确率/ 上/ 达到/ 了/ 96/ %/ ,/ 为/ 接下来/ 的/ 系统/ 预测/ 算法/ 提供/ 了/ 有效性/ 的/ 保证/ ./ 为了/ 验证/ 所/ 提出/ 的/ 算法/ 的/ 节能/ 效果/ ,/ 在/ 这里/ 我们/ 将/ 前面/ 所/ 选取/ 的/ 100/ 个/ 任务/ 样本/ 在/ 应用/ 分类/ 算法/ 之后/ 重新/ 进行/ 运行/ 分析/ ,/ 结果/ 如图/ 6/ 所示/ ./ Page7/ 图/ 4WEKA/ 数据/ 分类/ 效果图/ 5WEKA/ 分类/ 树/ 结果/ 图/ 6/ 前/ 100/ 个/ 样本/ 的/ 应用/ 分类/ 策略/ 的/ 运行/ 效果/ 从图/ 6/ 可以/ 看出/ ,/ 应用/ 了/ 分类/ 策略/ 之后/ ,/ 相对/ 于/ 系统/ 运行/ 在/ 没有/ 应用/ 任何/ 策略/ 时/ ,/ 系统/ 首先/ 会/ 将/ 功耗/ 较/ 低/ 的/ 任务/ 按照/ 优先级/ 尽量/ 放在/ 最/ 前面/ 执行/ ,/ 以/ 使/ 系统/ 可以/ 在/ 不/ 影响/ 性能/ 的/ 前提/ 前/ 尽量减少/ 系统/ 功耗/ ,/ 而/ 把/ 高功耗/ 的/ 任务/ 集中/ 到/ 一起/ ,/ 使/ 系统/ 在/ 性能/ 最优/ 且/ 尽量/ 可以/ 完成/ 任务/ 的/ 前提/ 下/ 减少/ 系统/ 功耗/ ./ 对图/ 6/ 进行/ 具体分析/ ,/ 系统/ 开始/ 的/ 时候/ 会/ 利用/ 模拟/ 的/ 分类器/ ,/ 首先/ 根据/ 获取/ 的/ 运行/ 信息/ 对/ 的/ 系统/ 接下来/ 将要/ 运行/ 的/ 任务/ 进行/ 分类/ ,/ 判断/ 其/ 所属/ 功耗/ 类型/ ,/ 然后/ 将/ 其/ 提交/ 给/ 系统/ 并/ 对系统/ 的/ 运行/ 状态/ 给出/ 建议/ ./ 系统/ 按照/ 预测/ 算法/ 给出/ 的/ 预测/ 结果/ 建议/ 进行/ 运行/ ,/ 首先/ 让/ 更/ 多/ 的/ 在/ 分类/ 的/ 时候/ 被/ 划归/ 于/ S3/ 状态/ 的/ 任务/ 先/ 执行/ ,/ 在/ 图/ 中/ 表现/ 为/ 一/ 开始/ 的/ 系统/ 处于/ 消耗/ 较/ 低能耗/ 的/ 状态/ 运行/ ,/ 此时/ CPU/ 的/ 电压/ 频率/ 会/ 维持/ 在/ 一个/ 较/ 低/ 的/ 水平/ ,/ 因为/ 此时/ 运行/ 的/ 任务/ 对系统/ 的/ 性能/ 要求/ 不高/ ,/ 所以/ 总体/ 上/ 看/ 并/ 没有/ 降低/ 系统/ 性能/ ./ 接下来/ 对于/ 能耗/ 比较/ 大/ 的/ 任务/ ,/ 系统/ 会/ 逐步提高/ 其/ CPU/ 的/ 电压/ 频率/ 以/ 满足/ 任务/ 的/ 需求/ ,/ 并/ 在/ 此基础/ 上/ 尽可能/ 的/ 将/ 系统/ 的/ 运行/ 结束/ 时间/ 提前/ ,/ 从而/ 达到/ 功耗/ 优化/ 的/ 目的/ ./ 与/ 没有/ 应用/ 任何/ 策略/ 的/ 运行/ 结果/ 相/ 比较/ ,/ 应用/ 分类/ 策略/ 运行/ 时/ 节省/ 的/ 系统/ 能耗/ 达到/ 了/ 32.61/ %/ ./ 这/ 在/ 很大/ 程度/ 了/ 减少/ 了/ 系统/ 的/ 能耗/ ,/ 达到/ 了/ 系统/ 功耗/ 的/ 优化/ 效果/ ./ 为了/ 让/ 大家/ 有/ 一个/ 直观/ 的/ 观察/ 效果/ ,/ 在/ 这里/ 我们/ 将/ 两者/ 运行/ 结果/ 合并/ 到/ 一起/ ,/ 如图/ 7/ ,/ 从图/ 中/ 可以/ 更加/ 直观/ 的/ 看到/ 我们/ 所/ 提出/ 的/ 算法/ 的/ 节能/ 效果/ ./ 虽然/ 算法/ 在/ 执行/ 计算/ 的/ 时候/ 会/ 相对/ 增加/ 约/ 2/ %/ 的/ 系统/ 消耗/ ,/ Page8/ 但是/ 与/ 取得/ 的/ 节能/ 效果/ 相比/ ,/ 增加/ 的/ 开销/ 可以/ 忽略/ ./ 为了/ 进一步/ 验证/ 算法/ 的/ 有效性/ ,/ 我们/ 从/ 所/ 模拟/ 的/ 实验/ 数据/ 中/ 取出/ 8/ 组/ ,/ 每组/ 100/ 个/ ,/ 分别/ 进行/ 无/ 任何/ 策略/ 的/ 运行/ ,/ 加入/ 分类/ 算法/ 策略/ 的/ 运行/ ,/ 将/ 最终/ 的/ 结果/ 进行/ 对比/ 分析/ ,/ 更加/ 说明/ 了/ 算法/ 的/ 有效性/ ./ 图/ 8/ ~/ 图/ 15/ 展示/ 了/ 我们/ 所/ 进行/ 的/ 8/ 次/ 模拟实验/ 结果/ ,/ 从图/ 中/ 可以/ 很/ 直观/ 地/ 看到/ 系统/ 的/ 节能/ 效果/ ./ 对于/ 8/ 组/ 实验/ 的/ 模拟/ 结果/ ,/ 将/ 在/ 无/ 策略/ 运行/ 下/ 的/ 能耗/ 与/ 在/ 分类/ 策略/ 运行/ 下/ 的/ 能耗/ 进行/ 统计分析/ ,/ 如表/ 2/ 所示/ ./ 通过/ 计算/ 对比/ ,/ 8/ 组/ 实验/ 的/ 系统/ 功耗/ 平均/ 降低/ 了/ 30.71/ %/ ,/ 基于/ 这样/ 一个/ 实验/ 事实/ ,/ 可以/ 得到/ 这样/ 的/ 结论/ :/ 我们/ 所/ 提出/ 的/ 算法/ 在/ 系统/ 功耗/ 的/ 优化/ 方面/ 确实/ 取得/ 了/ 预期/ 效果/ ./ Page9/ 实验组/ 号/ 12345678/ 在/ 这里/ 我们/ 还/ 应该/ 考虑/ 到/ 一个/ 系统/ 运行/ 时间/ 的/ 问题/ ,/ 相/ 比较/ 于/ 没有/ 应用/ 分类/ 策略/ 的/ 系统/ 运行/ 时间/ ,/ 应用/ 了/ 分类/ 策略/ 之后/ ,/ 系统/ 在/ 运行/ 时间/ 上会/ 有/ 一定/ 的/ 增加/ ,/ 这是/ 由于/ 对系统/ 的/ 运行/ 状态/ 进行/ 调整/ 之后/ ,/ 有些/ 任务/ 在/ 运行/ 的/ 过程/ 中/ ,/ 处理器/ 的/ 状态/ 会/ 被/ 调整/ 到/ 一个/ 较/ 低/ 的/ 电压/ 及/ 频率/ 上/ ,/ 那么/ 运行/ 时间/ 不可避免/ 的/ 要/ 出现/ 增加/ ,/ 图/ 16/ 显示/ 模拟/ 的/ 20/ 组/ 实验/ 中/ 无/ 分类/ 策略/ 运行/ 与/ 有/ 分类/ 策略/ 运行/ 时/ 系统/ 的/ 能耗/ 情况/ ./ 从图/ 中/ 我们/ 可以/ 看到/ ,/ 与/ 没有/ 运行/ 任何/ 策略/ 的/ 情况/ 相比/ ,/ 应用/ 了/ GINI/ 指数/ 分类/ 策略/ 之后/ ,/ 系统/ 在/ 能耗/ 方面/ 有/ 了/ 显著/ 的/ 降低/ 了/ ./ 实验/ 的/ 结果/ 与/ 理论/ 计算/ 的/ 结果/ 基本/ 吻合/ ,/ 从/ 实验/ 模拟/ 与/ 理论/ 计算/ 两个/ 方面/ 都/ 验证/ 了/ 结果/ 的/ 有效性/ ./ 虽然/ 有时候/ 在/ 某些/ 任务/ 的/ 运行/ 中/ 出现/ 了/ 系统/ 能耗/ 的/ 增加/ ,/ 但是/ 相对/ 于/ 系统/ 整个/ 运行/ 过程/ 中/ 节省/ 的/ 能耗/ ,/ 增加/ 的/ 能耗/ 完全/ 在/ 可以/ 接受/ 的/ 范围/ ./ 7/ 结论/ 本文/ 将/ 机器/ 学习/ 的/ 理论/ 应用/ 于/ 嵌入式/ CPU/ 能耗/ 的/ 预测/ ,/ 提出/ 的/ 基于/ GINI/ 指数/ 分类/ 策略/ 的/ 功耗/ 优化/ 预测/ 方法/ ,/ 可以/ 更好/ 的/ 对系统/ 状态/ 进行/ 预测/ ,/ 对于/ 降低/ 系统/ 功耗/ 有/ 明显/ 的/ 效果/ ./ 我们/ 下/ 一步/ 的/ 工作/ 包括/ :/ 进一步/ 细化/ 完善/ 能耗/ 的/ 分析/ 与/ 评估/ 的/ 方法/ 体系/ 开发/ 嵌入式/ 系统/ 的/ 软件/ 建模/ 与/ 验证/ 的/ 原型/ 工具/ ,/ 并/ 将/ 继续加强/ 对/ 预测/ 算法/ 的/ 优化/ ,/ 进一步/ 探索/ 更好/ 的/ 分类/ 模型/ ./ 致谢/ 匿名/ 审稿/ 专家/ 对/ 本文/ 提出/ 了/ 宝贵/ 修改意见/ ,/ 在/ 此/ 表示/ 由衷/ 的/ 感谢/ !/ Page10/ 

