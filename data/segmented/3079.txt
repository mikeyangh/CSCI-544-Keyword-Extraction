Page1/ 静/ 动态/ 结合/ 的/ Java/ 程序/ 不变性/ 分析方法/ 于利前/ 王林章/ 雷斌/ 赵建华/ 李宣东/ (/ 南京大学/ 计算机软件/ 新/ 技术/ 国家/ 重点/ 实验室/ 南京/ 210093/ )/ (/ 南京大学/ 计算机科学/ 与/ 技术/ 系/ 南京/ 210093/ )/ 摘要/ 程序/ 的/ 不变性/ (/ immutability/ )/ 是/ 指类/ 的/ 实例/ 对象/ 在/ 其/ 生命周期/ 内/ 状态/ 不会/ 发生/ 改变/ ./ 不变性/ 信息/ 可以/ 用来/ 指导/ 程序/ 的/ 分析/ 、/ 测试/ 和/ 验证/ 等/ 工作/ ./ 现有/ 分析/ 不变性/ 的/ 技术/ 主要/ 集中/ 于/ 对/ 程序/ 的/ 静态/ 分析/ ,/ 而/ 动态分析/ 方面/ 的/ 工作/ 很少/ ./ 文中/ 在/ 分析/ 了/ 静/ 、/ 动态分析/ 技术/ 各自/ 的/ 优缺点/ 后/ ,/ 提出/ 了/ 一种/ 静/ 动态/ 结合/ 的/ 混合/ 分析/ 技术/ ./ 首先/ 通过/ 对/ 程序/ 进行/ 静态/ 分析/ ,/ 即/ 对/ 程序/ 进行/ 分析测试/ 和/ 验证/ ,/ 来/ 获得/ 初步/ 的/ 程序/ 不变性/ 信息/ ,/ 然后/ 对/ 静态/ 分析/ 的/ 结果/ 中/ 不/ 确定/ 的/ 部分/ 再/ 进行/ 动态分析/ ,/ 即/ 通过观察/ 程序运行/ 时/ 各个/ 对象/ 的/ 状态/ 变化/ 进行/ 分析/ ,/ 同时/ 还/ 将/ 动态分析/ 用于/ 对/ 静态/ 分析/ 结果/ 的/ 验证/ ./ 静/ 动态/ 结合/ 的/ 分析/ 技术/ 比/ 单纯/ 的/ 静态/ 分析/ 提高/ 了/ 分析/ 结果/ 的/ 精度/ ,/ 同时/ 也/ 比/ 单纯/ 的/ 动态分析/ 降低/ 了/ 开销/ ,/ 提高/ 了/ 效率/ ./ 关键词/ 不变性/ ;/ 静态/ 分析/ ;/ 动态分析/ ;/ 混合/ 分析/ 1/ 引言/ 不变性/ 是/ 面向对象/ 程序/ 的/ 重要/ 性质/ ,/ 包含/ 对象/ 不变性/ 、/ 类/ 的/ 不变性/ 、/ 属性/ 不变性/ 和/ 方法/ 不变性/ 等/ 几个/ 方面/ ./ 对象/ 的/ 不变性/ 是/ 指该/ 对象/ 从/ 被/ 完全/ 创建/ 时起/ 一直/ 到/ 该/ 对象/ 被/ 消亡/ ,/ 它/ 的/ 状态/ 都/ 不会/ 发生/ 改变/ [/ 1/ ]/ ./ 对象/ 的/ 状态/ 是/ 指/ 所有/ 组成/ 该/ 对象/ 的/ 属性/ 的/ 值/ Page2/ 在/ 某个/ 时刻/ 的/ 快照/ ./ 一个/ 对象/ 的/ 状态/ 不/ 发生/ 改变/ ,/ 不仅/ 要求/ 该/ 对象/ 的/ 基本/ 数据类型/ 属性/ 的/ 值/ 在/ 其/ 生命周期/ 内/ 不/ 发生/ 改变/ ,/ 而且/ 要求/ 该/ 对象/ 的/ 引用/ 类型/ 属性/ 的/ 指向/ 关系/ 以及/ 该/ 引用/ 指向/ 的/ 对象/ 状态/ 在/ 其/ 生命周期/ 内/ 不/ 发生/ 改变/ ;/ 一个/ 类/ 是/ 不变/ 的/ 是/ 指/ 由/ 该类/ 实例/ 化而/ 得到/ 的/ 所有/ 对象/ 都/ 是/ 不变/ 的/ ;/ 一个/ 属性/ 是/ 不变/ 的/ 是/ 指该/ 属性/ 的/ 值/ 在/ 由/ 其/ 所属/ 的/ 类/ 创建/ 的/ 对象/ 的/ 生命周期/ 内/ 不会/ 发生/ 改变/ ;/ 一个/ 方法/ 是/ 不变/ 的/ 是/ 指该/ 方法/ 被/ 调用/ 以后/ ,/ 不会/ 改变/ 由/ 其/ 所属/ 的/ 类/ 创建/ 的/ 对象/ 的/ 状态/ ./ 不变性/ 是/ 面向对象/ 程序/ 的/ 一个/ 重要/ 性质/ ,/ 已有/ 研究/ 工作/ 表明/ 它/ 可以/ 作为/ 启发式/ 信息/ 用于/ 程序/ 的/ 设计/ 、/ 测试/ 、/ 验证/ 和/ 调试/ 等/ 领域/ [/ 1/ -/ 2/ ]/ ./ 下面/ 通过/ 4/ 个/ 例子/ 来/ 说明/ 不变性/ 的/ 应用/ ./ (/ 1/ )/ 并发程序/ 设计/ 中/ 减少/ 同步/ 开销/ ./ 当/ 两个/ 并发/ 执行/ 的/ 线程/ 基于/ 某/ 一个/ 对象/ 的/ 状态/ 进行/ 同步/ 时/ ,/ 一个/ 线程/ 对于/ 对象/ 状态/ 的/ 改变/ 会/ 影响/ 到/ 另/ 一个/ 线程/ 的/ 执行/ ./ 为了/ 维护/ 两个/ 线程/ 之间/ 的/ 同步/ ,/ 不得不/ 通过/ 很多/ 额外/ 的/ 措施/ 来/ 保证/ 线程/ 的/ 同步/ ,/ 例如/ 给/ 对象/ 的/ 状态/ 加锁/ ./ 当/ 线程/ 的/ 数量/ 超过/ 两个/ 、/ 共享/ 的/ 资源/ 也/ 不止/ 一个/ 的/ 时候/ ,/ 加锁/ 的/ 机制/ 就/ 会/ 变得/ 非常复杂/ ,/ 加锁/ 的/ 不当/ 甚至/ 会/ 造成/ 程序/ 的/ 死锁/ ./ 如果/ 通过/ 分析/ 发现/ 各个/ 线程/ 的/ 同步/ 所/ 基于/ 的/ 对象/ 状态/ 是/ 不变/ 的/ ,/ 对于/ 以该/ 对象/ 为/ 共享资源/ 的/ 线程/ ,/ 就/ 可以/ 不用/ 考虑/ 对/ 其/ 加锁/ ,/ 从而/ 减少/ 了/ 同步/ 的/ 开销/ ./ (/ 2/ )/ 减少/ 测试/ 的/ 工作量/ ./ 鲁棒性/ 测试/ 中/ ,/ 有时/ 需要/ 将类/ 中/ 所有/ 方法/ 的/ 组合/ 进行/ 测试/ ,/ 以/ 确定/ 各个/ 方法/ 调用/ 的/ 先后顺序/ 对/ 对象/ 状态/ 的/ 影响/ ./ 测试用例/ 的/ 复杂度/ 是/ O/ (/ N/ !/ )/ (/ N/ 是/ 类/ 中/ 方法/ 的/ 数目/ )/ ,/ 当/ 方法/ 的/ 数量/ 超过/ 10/ 个/ 时/ ,/ 测试用例/ 将会/ 非常/ 多/ ./ 如果/ 通过/ 对/ 程序/ 的/ 不变性/ 分析/ 发现/ 某些/ 方法/ 不会/ 改变/ 对象/ 的/ 状态/ ,/ 那么/ 在/ 方法/ 组合/ 中/ ,/ 就/ 可以/ 不用/ 考虑/ 这些/ 方法/ ./ 经过/ 对/ 多个/ 实际/ 程序/ 的/ 分析/ ,/ 发现/ 有/ 大约/ 65/ %/ 的/ 方法/ 不会/ 改变/ 对象/ 的/ 状态/ ,/ 这样/ 在/ 对/ 方法/ 进行/ 组合/ 时/ ,/ 这些/ 不/ 改变/ 对象/ 状态/ 的/ 方法/ 都/ 可以/ 不用/ 考虑/ ,/ 从而/ 大大/ 地/ 减少/ 了/ 测试用例/ 的/ 数量/ ./ (/ 3/ )/ 代码优化/ ./ 代码优化/ 的/ 一个/ 很/ 重要/ 原则/ ,/ 就是/ 循环/ 不变式/ 外移/ ,/ 因此/ 就/ 需要/ 分析/ 循环/ 中/ 的/ 所有/ 不变式/ ,/ 而/ 不变性/ 的/ 分析/ 可以/ 提供/ 这方面/ 的/ 信息/ ./ 例如/ 在/ 某个/ 循环体/ 中/ ,/ 每次/ 循环/ 都/ 会/ 读取/ 对象/ 的/ 不变/ 属性/ 或者/ 调用/ 该/ 对象/ 的/ 一个/ 不会/ 改变/ 状态/ 的/ 方法/ ,/ 那么/ 可以/ 把/ 这样/ 的/ 语句/ 外移/ 到/ 循环/ 外/ ,/ 从而/ 减少/ 了/ 每次/ 循环/ 的/ 计算/ 量/ ./ (/ 4/ )/ 减少/ 调试/ 的/ 工作量/ ./ 在/ 开发/ 程序/ 的/ 过程/ 当中/ ,/ 当/ 发现/ 程序/ 出现/ 错误/ 时/ ,/ 需要/ 通过/ 调试/ 来/ 定位/ 错误/ 的/ 位置/ ./ 调试/ 通常/ 通过/ 单步/ 执行/ 的/ 方式/ 来/ 检查/ 程序运行/ 过程/ 中/ 某个/ 时刻/ 各/ 变量/ 的/ 值/ 与/ 预计/ 值/ 是否/ 吻合/ ,/ 如果/ 执行/ 到/ 某/ 一步/ ,/ 发现/ 变量/ 的/ 值/ 与/ 预计/ 的/ 值/ 不/ 吻合/ ,/ 那么/ 该条/ 语句/ 很/ 有/ 可能/ 就是/ 错误/ 的/ 语句/ ./ 当/ 程序/ 的/ 变量/ 数目/ 比较/ 多/ 、/ 取值/ 范围/ 较广/ 时/ ,/ 要/ 找出/ 程序/ 出错/ 的/ 位置/ 就/ 比较/ 困难/ ,/ 经常/ 需要/ 调试/ 多次/ 才能/ 找出/ 错误/ 所在/ ./ 当/ 通过/ 程序/ 分析/ 发现/ 某些/ 变量/ 的/ 值/ 是/ 不/ 发生/ 改变/ 的/ ,/ 那么/ 在/ 调试/ 时/ 就/ 可以/ 不用/ 考虑/ 这些/ 变量/ ,/ 只/ 需要/ 关注/ 那些/ 可能/ 会/ 发生/ 状态/ 改变/ 的/ 对象/ 的/ 值/ ,/ 从而/ 减少/ 调试/ 的/ 工作量/ ./ 要/ 获取/ 程序/ 的/ 不变性/ 信息/ ,/ 就/ 需要/ 分析程序/ 中/ 各个/ 成分/ 的/ 不变性/ 性质/ ./ 现有/ 的/ 分析/ 技术/ 主要/ 集中/ 在/ 静态/ 分析/ 上/ ,/ 也/ 有/ 少量/ 动态分析/ 技术/ ./ 静态/ 分析/ 技术/ 是/ 通过/ 对/ 程序/ 进行/ 静态/ 扫描/ ,/ 然后/ 分析程序/ 中/ 各个/ 成分/ 之间/ 的/ 关系/ 来/ 获得/ 类/ 、/ 属性/ 、/ 方法/ 的/ 不变性/ 信息/ ./ 由于/ 静态/ 分析/ 技术/ 的/ 局限性/ ,/ 分析/ 的/ 结果/ 精度/ 不高/ ,/ 当/ 分析/ 过程/ 中有/ 某个/ 属性/ 依赖于/ 分析/ 范围/ 之外/ 的/ 成分/ 时/ ,/ 静态/ 分析/ 采取/ 的/ 是/ 保守/ 的/ 分析/ 策略/ ,/ 这些/ 分析/ 范围/ 之外/ 的/ 成分/ 全部/ 被/ 作为/ 不/ 确定/ 的/ ,/ 从而/ 会/ 有/ 大量/ 属性/ 的/ 不变性/ 性质/ 被/ 标记/ 为/ 不/ 确定/ (/ undecided/ )/ [/ 1/ ]/ ;/ 另外/ ,/ 还有/ 误判/ 或/ 漏判/ 的/ 问题/ ,/ 即使/ 被/ 标记/ 为/ 不变/ 的/ (/ immutable/ )/ 或者/ 可变/ 的/ (/ mutable/ )/ 属性/ ,/ 也/ 有/ 可能/ 标记/ 错误/ ./ 对/ 引用/ 类型/ 的/ 属性/ ,/ 因为/ 引用/ 别名/ 的/ 存在/ ,/ 导致/ 引用/ 类型/ 的/ 属性/ 所/ 指向/ 的/ 对象/ 可能/ 同时/ 被/ 多个/ 引用/ 所/ 指引/ ,/ 因此/ 改变/ 该/ 对象/ 状态/ 的/ 途径/ 也/ 很多/ [/ 3/ ]/ ./ 精确/ 的/ 分析/ 需要/ 对/ 所有/ 的/ 指引/ 关系/ 进行/ 分析/ ,/ 而/ 指引/ 关系/ 分析/ 是/ 程序/ 静态/ 分析/ 的/ 难点/ 之一/ ./ 动态分析/ 技术/ 就是/ 通过/ 运行/ 程序/ ,/ 动态/ 地/ 记录/ 各个/ 对象/ 在/ 运行/ 时刻/ 的/ 状态/ 并且/ 观察/ 这些/ 对象/ 的/ 状态/ 是否/ 发生/ 改变/ ./ 一旦/ 发现/ 某个/ 对象/ 的/ 状态/ 在/ 程序运行/ 过程/ 中/ 发生/ 了/ 改变/ ,/ 则/ 可以/ 确信/ 该/ 对象/ 是/ 可变/ 的/ ./ 但是/ 动态分析/ 是/ 不/ 完备/ 的/ ,/ 即使/ 在/ 程序/ 多次/ 运行/ 过程/ 中/ 一个/ 对象/ 的/ 状态/ 都/ 没有/ 发生/ 改变/ ,/ 也/ 无法/ 确定/ 该/ 对象/ 就是/ 不变/ 的/ ./ 而且/ 由于/ 动态分析/ 技术/ 需要/ 多次/ 运行/ 程序/ ,/ 在/ 分析/ 的/ 过程/ 中/ 往往/ 需要/ 人工干预/ ,/ 开销/ 较大/ ,/ 分析程序/ 的/ 不变性/ 效率/ 低下/ ,/ 特别/ 是/ 当所要/ 分析/ 的/ 程序/ 规模/ 较大/ 时/ ,/ 动态分析/ 技术/ 的/ 劣势/ 更加/ 明显/ ,/ 因此/ 目前/ 很少/ 有/ 研究者/ 单纯/ 用/ 动态分析/ 技术/ 来/ 分析程序/ 的/ 不变性/ 信息/ ./ 静态/ 分析/ 的/ 优点/ 在于/ 它/ 可以/ 做到/ 自动化/ ,/ 但是/ 缺点/ 在于/ 它/ 分析/ 的/ 精度/ 不高/ [/ 3/ ]/ ;/ 动态分析/ 的/ 优点/ 在于/ 它/ 可以/ 对/ 部分/ 情况/ 给出/ 确切/ 的/ 分析/ 结果/ ,/ 但/ 却是/ Page3/ 不/ 完备/ 的/ ,/ 并且/ 需要/ 多次/ 运行/ 程序/ ,/ 开销/ 很大/ ./ 我们/ 比较/ 了/ 静态/ 分析/ 技术/ 和/ 动态分析/ 技术/ 各自/ 的/ 优缺点/ 后/ ,/ 提出/ 了/ 一种/ 结合/ 了/ 静态/ 分析/ 和/ 动态分析/ 各自/ 优点/ 的/ 综合/ 分析/ 技术/ ./ 首先/ ,/ 设计/ 了/ 预处理/ 过程/ ,/ 经过/ 分析/ ,/ 发现/ java/ ./ lang/ 和/ java/ ./ util/ 两个/ 包中/ 的/ 类/ 在/ Java/ 程序设计/ 中/ 使用/ 频繁/ ,/ 也/ 容易/ 导致/ 静态/ 分析/ 的/ 不/ 确定/ ,/ 对/ 这/ 两个/ 包/ 进行/ 预/ 分析/ ,/ 将/ 预/ 分析/ 的/ 结果/ 作为/ 已知/ 信息/ 提供/ 给/ 静态/ 分析/ 过程/ ;/ 然后/ ,/ 通过/ 静态/ 分析方法/ 对/ 程序/ 进行/ 分析/ ,/ 给出/ 不变性/ 的/ 静态/ 分析/ 的/ 初步/ 结果/ ;/ 最后/ 基于/ 静态/ 分析/ 的/ 结果/ ,/ 通过/ 运行/ 程序/ 进行/ 动态分析/ :/ 一方面/ 判定/ 在/ 静态/ 分析/ 中/ 被/ 标记/ 的/ 不/ 确定/ 结果/ ,/ 另一方面/ 验证/ 静态/ 分析/ 结果/ 的/ 准确性/ ./ 静/ 动态/ 结合/ 的/ 分析/ 技术/ 提高/ 了/ 静态/ 分析/ 的/ 精度/ ,/ 与/ 动态分析/ 相比/ ,/ 又/ 减少/ 了/ 相当/ 的/ 开销/ ,/ 提高/ 了/ 整体/ 分析/ 的/ 效率/ ./ 本文/ 的/ 主要/ 贡献/ 如下/ :/ (/ 1/ )/ 提出/ 了/ 静/ 动态/ 结合/ 的/ 不变性/ 分析/ 技术/ ,/ 用/ 动态分析/ 技术/ 对/ 静态/ 分析/ 结果/ 中/ 不/ 确定/ 的/ 部分/ 进行/ 判定/ ,/ 同时/ 对/ 静态/ 分析/ 的/ 部分/ 结果/ 进行/ 正确性/ 验证/ ./ (/ 2/ )/ 提出/ 了/ 对/ java/ ./ lang/ 和/ java/ ./ util/ 两个/ 使用/ 频繁/ 的/ Java/ 包/ 进行/ 预/ 分析/ ,/ 在/ 一定/ 程度/ 上/ 缩小/ 了/ 静态/ 分析/ 的/ 范围/ ,/ 提高/ 了/ 分析/ 的/ 精度/ 和/ 效率/ ./ (/ 3/ )/ 对/ 属性/ 的/ 不变性/ 性质/ 进行/ 了/ 细分/ ,/ 从不/ 确定/ 中/ 细分/ 出/ 引用/ 逃逸/ (/ referenceescape/ )/ 一类/ ,/ 可以/ 用于/ 提示/ 程序员/ 减少/ 方法/ 调用/ 的/ 副作用/ ./ 本文/ 第/ 2/ 节/ 给出/ 了/ 不变性/ 的/ 规约/ ;/ 第/ 3/ 节/ 详细/ 地/ 阐述/ 了/ 静/ 动态/ 结合/ 的/ 不变性/ 分析/ 技术/ ;/ 第/ 4/ 节/ 介绍/ 了/ 原型/ 工具/ ,/ 并且/ 进行/ 了/ 相关/ 实验/ ;/ 第/ 5/ 节/ 比较/ 了/ 相关/ 工作/ ;/ 最后/ 对/ 全文/ 进行/ 了/ 总结/ 并/ 讨论/ 了/ 进一步/ 的/ 工作/ ./ 2/ 不变性/ 的/ 规约/ 2.1/ 改变/ 不变性/ 的/ 示例/ 代码/ 改变/ 属性/ 不变性/ 的/ 可能/ 情形/ 只有/ 两种/ :/ (/ 1/ )/ 改变/ 基本/ 数据类型/ 属性/ 的/ 值/ ;/ (/ 2/ )/ 改变/ 引用/ 类型/ 属性/ 的/ 指向/ 关系/ 或者/ 该/ 引用/ 所/ 指向/ 的/ 对象/ 状态/ ./ 下面/ 通过/ 4/ 个/ 例子/ 来/ 分别/ 说明/ 这/ 几种/ 情形/ ./ 2.1/ ./ 1/ 对/ 属性/ 进行/ 重/ 赋值/ 通过/ 赋值/ 语句/ 直接/ 对/ 属性/ 进行/ 重新/ 赋值/ ,/ 这是/ 直观/ 且/ 常见/ 的/ 改变/ 不变性/ 的/ 方法/ ./ 它/ 不仅/ 可以/ 改变/ 基本/ 数据类型/ 的/ 属性/ 值/ ,/ 还/ 可以/ 改变/ 引用/ 类型/ 属性/ 的/ 指向/ 关系/ ./ 如/ 下面/ 例/ 1/ 所示/ ,/ setAge/ 方法/ 可以/ 改变/ int/ 型/ 属性/ age/ 的/ 值/ ,/ 而/ setTeacher/ 方法/ 可以/ 改变/ 类型/ 为/ Teacher/ 的/ 属性/ teacher/ 的/ 指向/ 关系/ ,/ 调用/ 该/ 方法/ 后/ ,/ 属性/ teacher/ 指向/ 了/ 新/ 的/ 对象/ ./ 例/ 1/ ./ 属性/ 直接/ 赋值/ ./ publicclassStudent/ {/ }/ 2.1/ ./ 2/ 通过/ 引用/ 逃逸/ 的/ 方式/ 改变/ 对象/ 状态/ 除了/ 像例/ 1/ 那样/ 通过/ 直接/ 赋值/ 的/ 方式/ 以外/ ,/ 还/ 可以/ 将/ 引用/ 属性/ 逃逸/ 定义/ 它/ 的/ 类/ ,/ 从而/ 间接/ 地/ 改变/ 对象/ 的/ 状态/ ./ 引用/ 逃逸/ 的/ 方式/ 有/ 两种/ :/ 一种/ 是/ 将/ 引用/ 作为/ 方法/ 调用/ 的/ 参数/ 逃逸/ ;/ 另/ 一种/ 是/ 通过/ return/ 语句/ 将/ 引用/ 传递/ 出去/ ./ 如/ 下面/ 例/ 2/ 所示/ ,/ 方法/ f1/ 将/ this/ ./ teacher/ 作为/ 参数/ 调用/ 了/ 类/ Utils/ 中/ 方法/ f/ ,/ 这样/ 在/ f/ 的/ 定义/ 点/ 就/ 可以/ 获得/ 对/ 属性/ teacher/ 的/ 引用/ ,/ 改变/ 参数/ teacher/ 的/ 值/ ./ 方法/ f2/ 将/ 引用/ 属性/ 返回/ ,/ 这样/ 在/ 调用/ f2/ 的/ 地方/ 也/ 就/ 获得/ 了/ 对/ 属性/ teacher/ 的/ 操作/ 权/ ,/ 从而/ 也/ 可以/ 间接/ 地/ 改变/ 对象/ 的/ 状态/ ./ 例/ 2/ ./ 属性/ 逃逸/ ./ publicclassStudent/ {/ publicvoidf1/ (/ )/ {/ }/ publicTeacherf2/ (/ )/ {/ }/ }/ publicclassUtils/ {/ publicstaticvoidf/ (/ Teacherteacher/ )/ {/ }/ }/ 2.1/ ./ 3/ 改变/ 引用/ 属性/ 所/ 指向/ 的/ 对象/ 状态/ 在/ 这种/ 情形/ 里/ ,/ 引用/ 属性/ 的/ 指向/ 关系/ 不/ 发生/ 改变/ ,/ 但是/ 可以/ 通过/ 引用/ 属性/ 对/ 其/ 指向/ 的/ 对象/ 状态/ 进行/ 间接/ 的/ 改变/ ./ 如/ 下面/ 例/ 3/ 所示/ ,/ v/ 是/ 一个/ 指向/ int/ 型/ 的/ 数组/ 的/ 引用/ ,/ v/ 的/ 指向/ 关系/ 在/ 整个/ 程序/ 当中/ 不/ Page4/ 会/ 发生/ 改变/ ,/ 它/ 一直/ 指向/ 原来/ 的/ 那个/ 数组/ ,/ 但是/ 可以/ 改变/ 其/ 指向/ 的/ 数组/ 中/ 的/ 值/ ,/ 从而/ 改变/ 引用/ 属性/ v/ 的/ 值/ ./ 在/ sum/ 方法/ 中/ ,/ 数组/ v/ 中/ 的/ 每/ 一个/ 值/ 都/ 乘以/ 了/ 2/ ./ 另/ 一种/ 改变/ 引用/ 属性/ 所/ 指向/ 的/ 对象/ 状态/ 的/ 方式/ 是/ 调用/ 该/ 对象/ 的/ 成员/ 方法/ ,/ 如/ 下面/ 例/ 4/ 所示/ ,/ 引用/ 属性/ teacher/ 的/ 指向/ 关系/ 没有/ 发生/ 改变/ ,/ 但是/ 在/ changeTeacherName/ 方法/ 中/ 调用/ teacher/ 的/ 成员/ 方法/ setName/ ,/ 从而/ 改变/ 了/ 引用/ 属性/ teacher/ 的/ 值/ ./ 例/ 3/ ./ 改变/ 引用/ 对象/ 的/ 状态/ ./ publicclassIntVector/ {/ privateint/ [/ ]/ v/ =/ {/ 0/ ,/ 1/ ,/ 2/ ,/ 3/ ,/ 4/ ,/ 5/ }/ ;/ privateintcount/ ;/ publicintSum/ (/ )/ {/ }/ 例/ 4/ ./ 调用/ 可以/ 改变/ 对象/ 状态/ 的/ 成员/ 方法/ ./ publicclassStudent/ {/ privateStringname/ ;/ privateintage/ ;/ privateTeacherteacher/ ;/ publicvoidchangeTeacherName/ (/ StringnewName/ )/ }/ 2.2/ 不变性/ 规约/ 2.2/ ./ 1/ 属性/ (/ field/ )/ 的/ 不变性/ 规约/ 本文/ 将/ 属性/ ①/ 的/ 不变性/ 性质/ 分为/ 3/ 类/ :/ 不变/ (/ immutable/ )/ 、/ 可变/ (/ mutable/ )/ 和/ 不/ 确定/ (/ undecided/ )/ ,/ 在/ 不/ 确定/ (/ undecided/ )/ 的/ 类别/ 中/ 又/ 细分/ 出/ 引用/ 逃逸/ (/ referenceescape/ )/ 一类/ ,/ 下面/ 分/ 4/ 种/ 具体情况/ 进行/ 说明/ (/ 在/ 这些/ 定义/ 中/ ,/ 都/ 不/ 考虑/ 类/ 的/ 构造方法/ )/ :/ (/ 1/ )/ 属性/ 是/ 不变/ 的/ ,/ 当且/ 仅/ 当该/ 属性/ 满足/ 如下/ 任意/ 条件/ 之一/ :/ ①/ 它/ 是/ 基本/ 数据类型/ ,/ 并且/ 没有/ 被/ 重新/ 赋值/ ;/ ②/ 它/ 是/ 引用/ 类型/ ,/ 其/ 指向/ 关系/ 没有/ 被/ 重新/ 赋值/ ,/ 并且/ 它/ 所/ 指向/ 的/ 对象/ 所属/ 的/ 类/ 是/ 不变/ 的/ ;/ ③/ 它/ 是/ 引用/ 类型/ ,/ 其/ 指向/ 关系/ 没有/ 被/ 重新/ 赋值/ ,/ 并且/ 它/ 所/ 指向/ 的/ 对象/ 所属/ 的/ 类/ 是/ 可变/ 的/ ,/ 但是/ 该/ 引用/ 没有/ 被/ 逃逸/ ,/ 并且/ 该/ 引用/ 没有/ 调用/ 可变/ 的/ 成员/ 方法/ ;/ (/ 2/ )/ 属性/ 是/ 可变/ 的/ ,/ 当且/ 仅/ 当该/ 属性/ 满足/ 如下/ 任意/ 条件/ 之一/ :/ ①/ 它/ 是/ 基本/ 数据类型/ ,/ 并且/ 被/ 重新/ 赋值/ ;/ ②/ 它/ 是/ 引用/ 类型/ ,/ 其/ 指向/ 关系/ 被/ 重新/ 赋值/ 或者/ 它/ 调用/ 了/ 可变/ 的/ 成员/ 方法/ ;/ (/ 3/ )/ 属性/ 是/ 引用/ 逃逸/ ,/ 当且/ 仅/ 当该/ 属性/ 是/ 引用/ 类型/ ,/ 其/ 指向/ 关系/ 没有/ 被/ 重新/ 赋值/ ,/ 但是/ 该/ 引用/ 被/ 逃逸/ ,/ 并且/ 该/ 引用/ 所/ 指向/ 的/ 对象/ 所属/ 的/ 类/ 是/ 可变/ 的/ ;/ (/ 4/ )/ 其它/ 情况/ 都/ 是/ 不/ 确定/ 的/ ./ 2.2/ ./ 2/ 方法/ (/ method/ )/ 的/ 不变性/ 规约/ 将/ 方法/ 的/ 不变性/ 性质/ 分为/ 3/ 类/ :/ 不变/ 、/ 可变/ 和/ 不/ 确定/ ,/ 下面/ 分/ 3/ 种/ 具体情况/ 进行/ 说明/ :/ (/ 1/ )/ 方法/ 是/ 不变/ 的/ ,/ 当且/ 仅/ 当该/ 方法/ 同时/ 满足/ 以下/ 所有/ 条件/ :/ ①/ 该/ 方法/ 中/ 不/ 存在/ 对/ 属性/ 的/ 赋值/ 语句/ ;/ ②/ 该/ 方法/ 中/ 没有/ 调用/ 引用/ 类型/ 属性/ 的/ 可变/ 成员/ 方法/ ;/ ③/ 该/ 方法/ 没有/ 将/ 那些/ 所/ 指向/ 的/ 对象/ 所属/ 的/ 类/ 是/ 可变/ 的/ 引用/ 类型/ 属性/ 逃逸/ ;/ (/ 2/ )/ 方法/ 是/ 可变/ 的/ ,/ 当且/ 仅/ 当该/ 方法/ 满足/ 以下/ 任意/ 条件/ 之一/ :/ ①/ 该/ 方法/ 中/ 存在/ 对/ 属性/ 的/ 赋值/ 语句/ ;/ ②/ 该/ 方法/ 调用/ 了/ 引用/ 类型/ 属性/ 的/ 可变/ 成员/ 方法/ ;/ ③/ 该/ 方法/ 中/ 存在/ 将/ 引用/ 类型/ 属性/ 逃逸/ 的/ 语句/ ,/ 且/ 这些/ 逃逸/ 的/ 引用/ 所/ 指向/ 的/ 对象/ 所属/ 的/ 类/ 是/ 可变/ 的/ ;/ (/ 3/ )/ 其它/ 情况/ 都/ 是/ 不/ 确定/ 的/ (/ 例如/ ,/ 该/ 方法/ 将/ 引用/ 类型/ 属性/ 逃逸/ ,/ 但是/ 该/ 引用/ 所/ 指向/ 的/ 对象/ 所属/ 的/ 类/ 是/ 不/ 确定/ 的/ ;/ 该/ 方法/ 调用/ 了/ 引用/ 属性/ 的/ 成员/ 方法/ 但是/ 该/ 成员/ 方法/ 是/ 不/ 确定/ 的/ )/ ./ 2.2/ ./ 3/ 类/ (/ class/ )/ 的/ 不变性/ 规约/ 确定/ ,/ 下面/ 分/ 3/ 种/ 具体/ 情形/ 进行/ 说明/ :/ 属性/ 都/ 是/ 不变/ 的/ ;/ 将类/ 的/ 不变性/ 性质/ 划分/ 成/ 3/ 类/ :/ 不变/ 、/ 可变/ 和/ 不/ (/ 1/ )/ 类/ 是/ 不变/ 的/ ,/ 当且/ 仅/ 当/ 该类/ 中/ 定义/ 的/ 所有/ (/ 2/ )/ 类/ 是/ 可变/ 的/ ,/ 当且/ 仅/ 当/ 该类/ 中/ 至少/ 存在/ 一/ (/ 3/ )/ 其它/ 情况/ 都/ 是/ 不/ 确定/ 的/ (/ 例如/ :/ 该类/ 中/ 所有/ 属性/ 都/ 是/ 不/ 确定/ 的/ ;/ 该类/ 中/ 部分/ 属性/ 是/ 不变/ 的/ 但是/ 其它/ 属性/ 都/ 是/ 不/ 确定/ 的/ )/ ./ 3/ 静/ 动态/ 结合/ 的/ 不变性/ 分析/ 个/ 属性/ 是/ 可变/ 的/ ;/ 本文/ 提出/ 一种/ 静/ 动态/ 结合/ 的/ 不变性/ 分析/ 技术/ ,/ 具体/ 过程/ 如图/ 1/ 所示/ ,/ 主要/ 分为/ 两个/ 阶段/ ,/ 第/ 1/ 个/ 阶段/ 是/ 静态/ 分析/ 过程/ ,/ 主要/ 包括/ 对/ 字节/ 码/ 的/ 静态/ 扫描/ ,/ 以及/ 静态/ 不变性/ 分析/ ,/ 静态/ 分析阶段/ 结束/ 后/ 将/ 会/ 给出/ 静态/ 分析/ 结果/ ,/ 如果/ 静态/ 分析/ 结果/ 中/ 没有/ 不/ 确定/ ①/ 对于/ public/ 的/ 属性/ ,/ 因为/ 它/ 可以/ 被/ 类/ 的/ 外部/ 直接/ 修改/ ,/ 因此/ Page5/ 的/ 部分/ ,/ 则/ 静态/ 分析/ 结果/ 即/ 最终/ 分析/ 结果/ ,/ 分析/ 结束/ ;/ 如果/ 静态/ 分析/ 结果/ 中有/ 不/ 确定/ 的/ 部分/ ,/ 则/ 进入/ 第/ 2/ 阶段/ ,/ 即/ 进行/ 动态分析/ 过程/ ,/ 主要/ 包括/ 对/ 代码/ 的/ 插装/ 、/ 驱动程序/ 运行/ 、/ 动态/ 不变性/ 分析/ ,/ 将/ 动态分析/ 的/ 结果/ 与/ 静态/ 分析/ 的/ 结果/ 结合/ ,/ 形成/ 最终/ 的/ 分析/ 结果/ ./ 3.1/ 静态/ 分析/ 过程/ 静态/ 分析/ 过程/ 分为/ 3/ 个/ 步骤/ :/ 首先/ 对/ java/ ./ lang/ 和/ java/ ./ util/ 这/ 两个/ 包/ 进行/ 预处理/ ;/ 接着/ 对待/ 分析/ 的/ Java/ 程序/ 进行/ 静态/ 扫描/ ;/ 最后/ 采用/ 迭代/ 分析/ 技术/ 对待/ 分析程序/ 进行/ 静态/ 不变性/ 分析/ ./ 3.1/ ./ 1java/ ./ lang/ 和/ java/ ./ util/ 包/ 的/ 预处理/ 因为/ 静态/ 不变性/ 分析/ 一般/ 采取/ 保守/ 的/ 策略/ ,/ 当/ 分析/ 的/ 类/ 、/ 属性/ 或者/ 方法/ 依赖于/ 被/ 分析/ 的/ 程序包/ 以外/ 的/ 类时/ ,/ 程序包/ 以外/ 的/ 类/ 都/ 被/ 当作/ 不/ 确定/ 的/ ,/ 从而/ 导致/ 静态/ 分析/ 结果/ 中/ 不/ 确定/ 的/ 比例/ 较/ 高/ ./ 而/ java/ ./ lang/ 和/ java/ ./ util/ 两个/ 包在/ Java/ 程序设计/ 中/ 使用/ 频繁/ ,/ 为/ 程序员/ 所/ 熟知/ ,/ 因此/ ,/ 首先/ 对/ 这/ 两个/ 包中/ 的/ 类/ 进行/ 了/ 预处理/ ,/ 把/ 这/ 两个/ 包中/ 的/ 类/ 的/ 不变性/ 性质/ 作为/ 已知/ 信息/ ,/ 保存/ 到/ 配置文件/ 里面/ ,/ 例如/ java/ ./ lang/ ./ String/ 、/ java/ ./ lang/ ./ Object/ 、/ java/ ./ lang/ ./ Integer/ 等/ 类/ 都/ 是/ 不变/ 的/ ,/ 而/ java/ ./ util/ ./ Stack/ 、/ java/ ./ util/ ./ Array/ -/ List/ 、/ java/ ./ util/ ./ HashMap/ 等/ 类/ 都/ 是/ 可变/ 的/ ①/ ./ 对/ java/ ./ lang/ 和/ java/ ./ util/ 这/ 两个/ 包做/ 了/ 预处理/ 以后/ ,/ 当/ 被/ 分析/ 的/ 类/ 、/ 属性/ 或者/ 方法/ 依赖于/ 这/ 两个/ 包中/ 的/ 类时/ ,/ 就/ 可以/ 给出/ 确切/ 的/ 不变性/ 性质/ ,/ 从而/ 减少/ 分析/ 结果/ 中/ 的/ 不/ 确定/ 比例/ ./ 3.1/ ./ 2/ 静态/ 扫描/ 静态/ 扫描/ 的/ 主要/ 思想/ 是/ 通过/ 对待/ 分析/ Java/ 程序/ 的/ 字节/ 码/ 进行/ 逐条/ 遍历/ ,/ 获取/ 程序/ 的/ 相关/ 信息/ ,/ 这些/ 信息/ 包括/ :/ (/ 1/ )/ 属性/ 的/ 类型/ ;/ (/ 2/ )/ 属性/ 是否/ 被/ 重新/ 赋值/ ;/ (/ 3/ )/ 属性/ 是否/ 作为/ 方法/ 的/ 返回值/ 被/ 返回/ ;/ (/ 4/ )/ 属性/ 是否/ 作为/ 方法/ 调用/ 语句/ 的/ 参数/ 被/ 逃逸/ ;/ (/ 5/ )/ 引用/ 属性/ 所/ 调用/ 的/ 成员/ 方法/ 列表/ ./ 静态/ 扫描/ 的/ 算法/ 如图/ 2/ 所示/ ,/ 它/ 的/ 输入/ 是/ 一个/ jar/ 包/ ,/ 输出/ 是/ 每个/ 属性/ 、/ 方法/ 和/ 类/ 的/ 一些/ 基本/ 信息/ ./ 算法/ 主要/ 分为/ 3/ 步/ ,/ (/ 1/ )/ 先/ 从/ 字节/ 码/ 文件/ 中/ 解析/ 出/ JavaClass/ 对象/ ;/ (/ 2/ )/ 遍历/ JavaClass/ 对象/ 中/ 的/ 每/ 一个/ 属性/ ,/ 记录/ 下/ 这个/ 属性/ 的/ 类型/ ;/ (/ 3/ )/ 遍历/ JavaClass/ 对象/ 中/ 的/ 所有/ 方法/ 的/ 所有/ 语句/ ,/ 如果/ 是/ 赋值/ 语句/ ,/ 判断/ 是否/ 对/ 属性/ 进行/ 了/ 重新/ 赋值/ ,/ 如果/ 是/ 方法/ 调用/ 语句/ ,/ 需要/ 判断/ 是否/ 调用/ 了/ 引用/ 属性/ 的/ 成员/ 方法/ 以及/ 是否/ 将/ 引用/ 属性/ 作为/ 参数/ 逃逸/ ,/ 如果/ 是/ 返回/ 语句/ ,/ 需要/ 判断/ 是否/ 将/ 引用/ 属性/ 作为/ 返回值/ 逃逸/ ./ Algorithm/ :/ ScanningInput/ :/ thejarpackagetobescannedOutput/ :/ thebasicinformationofclasses/ ,/ fieldsandmethodsforeveryclassfileinthepackage/ {/ JavaClassjavaClass/ =/ parse/ (/ classfile/ )/ ;/ foreveryfieldinthejavaClassrecordthetypeofthefield/ ;/ // // 记录/ 该/ 属性/ 的/ 类型/ foreverymethodintheclass/ {/ // // 遍历/ 该类/ 中/ 所有/ 方法/ if/ (/ methodisconstructor/ )/ continue/ ;/ forallbytecodeinstructioninthemethod/ {/ // // 遍历/ 该/ 方法/ 所有/ 字节/ 码/ 指令/ iftheinstructionassignednewValuetoafield/ // // 如果/ 该/ 指令/ 给/ 某个/ 属性/ 赋值/ ,/ 则/ 记录/ 下该/ 属性/ 被/ 赋值/ iftheinstructioninvokeamethodofafield/ // // 如果/ 这/ 条/ 语句/ 调用/ 了/ 某个/ 属性/ 的/ 成员/ 方法/ ,/ 将/ 被/ 调用/ 的/ iftheinstructionpassesafieldtoamethodasaparameter/ // // 如果/ 这/ 条/ 语句/ 将/ 某个/ 属性/ 作为/ 参数传递/ 给/ 了/ 另外/ 一个/ 方/ iftheinstructionisareturninstructionandreturnedafield/ // // 如果/ 这/ 条/ 语句/ 是/ 一个/ 返回/ 语句/ ,/ 并且/ 将/ 该/ 属性/ 作为/ 返回/ }/ }/ }/ 3.1/ ./ 3/ 静态/ 不变性/ 分析/ 静态/ 不变性/ 分析/ 是/ 对/ Java/ 程序/ 不变性/ 分析/ 的/ 核心/ 部分/ ,/ 根据/ 预处理/ 阶段/ 获得/ 的/ 已知/ 信息/ 和/ 静态/ 扫描/ 阶段/ 获得/ 的/ 程序/ 基本/ 信息/ ,/ 结合/ 不变性/ 规约/ ,/ 采取/ 迭代/ 的/ 方法/ 判定/ 程序/ 中/ 每个/ 类/ 、/ 属性/ 和/ 方法/ 的/ 不变性/ 性质/ ./ 静态/ 不变性/ 分析/ 的/ 算法/ 如图/ 3/ 所示/ ,/ 算法/ 的/ 输入/ 是/ 在/ 静态/ 扫描/ 过程/ 中/ 获得/ 的/ 基本/ 信息/ ,/ 输出/ ①/ 在/ 本文/ 工具/ 和/ 实验/ 主页/ http/ :/ // // seg/ ./ nju/ ./ edu/ ./ cn/ // IA4J/ 上面/ Page6/ 是/ 程序/ 中/ 所有/ 的/ 类/ 、/ 属性/ 和/ 方法/ 的/ 不变性/ 性质/ ./ Algorithm/ :/ ImmutabilityAnalysisInput/ :/ thebasicinformationofclasses/ ,/ fieldsandmethodsOutput/ :/ theimmutabilitylabelsofalltheclasses/ ,/ fieldsandInitialalltheclasses/ ,/ fieldsandmethodsasundecided/ ;/ // // 初始/ 时/ 所有/ 的/ 类/ 、/ 属性/ 和/ 方法/ 都/ 是/ 不/ 确定/ 的/ While/ (/ hasnewresultgenerated/ )/ {/ // // 迭代/ 分析/ foreachclassinthepackage/ {/ // // 遍历/ 包中/ 的/ 所有/ 类/ foreachfieldintheclass/ {/ // // 遍历/ 该类/ 中/ 所有/ 的/ 属性/ ifthefieldisassignednewvalueifthefieldinvokesamethodwhichismutableifthefieldisnotassignednewvalue/ &/ itstypeisimmuta/ -/ ifthefieldisescape/ &/ itstypeismutable/ }/ foreachmethodintheclass/ {/ // // 遍历/ 该类/ 中/ 所有/ 的/ 方法/ getallthefieldsreferedinthemethod/ ;/ ifthemethodchangedanyfieldtomutableorescapeifthemethoddoesnotchangedanyfieldtomutableorref/ -/ }/ ifallthefieldsintheclassisimmutablelabelthentheclassasimmutable/ ;/ // // 如果/ 这个/ 类中/ 所有/ 的/ 属性/ 都/ 是/ 不变/ 的/ ,/ 那么/ 该类/ 就是/ 不变/ 的/ ifthereexistanyfieldintheclassismutablelabeltheclassasmutable/ ;/ // // 如果/ 这个/ 类中/ 有/ 任何/ 一个/ 属性/ 是/ 可变/ 的/ ,/ 那么/ 该类/ 就是/ }/ }/ 可变/ 的/ 静态/ 分析/ 初始/ 时/ ,/ 每个/ 类/ 、/ 属性/ 和/ 方法/ 都/ 是/ 不/ 确定/ 的/ ,/ 在/ 静态/ 分析/ 的/ 每/ 一次/ 迭代/ 过程/ 中/ ,/ 针对/ 每/ 一个/ 类/ ,/ 首先/ 遍历/ 该类/ 中/ 的/ 所有/ 属性/ ,/ 根据/ 静态/ 扫描/ 阶段/ 获得/ 的/ 信息/ 、/ 预处理/ 得到/ 的/ 已知/ 信息/ 和/ 不变性/ 规约/ ,/ 判断/ 该/ 属性/ 的/ 不变性/ 性质/ ;/ 接着/ 遍历/ 该类/ 中/ 所有/ 的/ 方法/ ,/ 对于/ 每/ 一个/ 方法/ ,/ 如果/ 它/ 没有/ 将/ 任何/ 属性/ 的/ 不变性/ 性质/ 变为/ 可变/ 的/ 、/ 引用/ 逃逸/ ,/ 那么/ 该/ 方法/ 就是/ 不变/ 的/ ,/ 如果/ 它/ 使得/ 某个/ 属性/ 的/ 性质/ 变为/ 可变/ 的/ 或者/ 引用/ 逃逸/ ,/ 那么/ 该/ 方法/ 就是/ 可变/ 的/ ;/ 最后/ ,/ 根据/ 类中/ 所有/ 的/ 属性/ 性质/ 来/ 判断/ 该类/ 的/ 不变性/ 性质/ ,/ 如果/ 所有/ 的/ 属性/ 都/ 是/ 不变/ 的/ ,/ 那么/ 该类/ 就是/ 不变/ 的/ ,/ 如果/ 有/ 一个/ 属性/ 的/ 性质/ 为/ 可变/ 的/ ,/ 那么/ 该类/ 就是/ 可变/ 的/ ./ 在/ 程序/ 的/ 每/ 一次/ 迭代/ 过程/ 中/ ,/ 都/ 可能/ 有/ 新/ 的/ 结果/ 产生/ ,/ 这些/ 新/ 的/ 结果/ 可以/ 作为/ 下/ 一次/ 迭代/ 的/ 已知/ 信息/ ,/ 如果/ 某次/ 迭代/ 过程/ 结束/ 后/ ,/ 没有/ 新/ 的/ 结果/ 产生/ ,/ 那么/ 静态/ 分析/ 过程/ 就/ 结束/ 3.2/ 动态分析/ 过程/ 动态分析/ 过程/ 是/ 对/ 静态/ 分析/ 结果/ 中/ 不/ 确定/ 的/ 部分/ 进行/ 进一步/ 的/ 精化/ ,/ 它/ 需要/ 运行/ 程序/ ,/ 记录/ 程序运行/ 过程/ 中/ 各个/ 对象/ 的/ 属性/ 值/ 是否/ 发生/ 改变/ ,/ 以此/ 来/ 判断/ 属性/ 和/ 方法/ 是否是/ 可变/ 的/ ./ 如果/ 属性/ 的/ 值/ 在/ 运行/ 过程/ 中/ 被/ 改变/ 了/ ,/ 可以/ 推断/ 这个/ 属性/ 是/ 可变/ 的/ ,/ 但/ 即使/ 一个/ 对象/ 的/ 状态/ 在/ 程序/ 的/ 多次/ 运行/ 过程/ 中/ 都/ 没有/ 发生/ 改变/ ,/ 也/ 无法/ 推断/ 这个/ 对象/ 是/ 不变/ 的/ ./ 动态分析/ 过程/ 分为/ 3/ 个/ 步骤/ :/ 代码/ 插桩/ 、/ 代码运行/ 和/ 运行/ 结果/ 分析/ ./ 在/ 动态分析/ 过程/ 中/ ,/ 需要/ 搜集/ 程序运行/ 过程/ 中/ 属性/ 的/ 值/ 是否/ 发生/ 改变/ 的/ 信息/ ,/ 因此/ 需要/ 对/ 代码/ 进行/ 插桩/ ./ 插桩/ 的/ 主要/ 目的/ 是/ 在/ 需要/ 关注/ 的/ 方法/ 的/ 入口/ 点/ 和/ 出口/ 点/ 输出/ 需要/ 关注/ 的/ 属性/ 的/ 值/ ./ 这样/ ,/ 在/ 进入/ 方法/ 时/ ,/ 记录/ 下/ 属性/ 的/ 初始值/ ,/ 在/ 退出/ 方法/ 时/ 记录/ 下该/ 属性/ 的/ 当前/ 值/ ,/ 就/ 可以/ 判断/ 该/ 方法/ 的/ 执行/ 是否/ 会/ 改变/ 该/ 属性/ 的/ 值/ ./ 图/ 4/ 为/ 插/ 桩/ 的/ 算法/ ,/ 它/ 的/ 输入/ 是/ 待/ 插/ 桩/ 的/ Java/ 程序/ 以及/ 一组/ 关注/ 的/ 属性/ 和/ 方法/ 列表/ ,/ 输出/ 是/ 插/ 桩/ 后/ 的/ 程序/ ./ 它/ 分为/ 两个/ 步骤/ ,/ 第/ 1/ 步先/ 扫描/ 代码/ 找出/ 使用/ 了/ 这组/ 关注/ 的/ 属性/ 的/ 方法/ 列表/ ,/ 与/ 输入/ 中/ 的/ 方法/ 列表/ 合并/ 得到/ 一个/ 新/ 的/ 需要/ 插桩/ 的/ 方法/ 列表/ ,/ 并且/ 建立/ 需要/ 插桩/ 的/ 每个/ 方法/ 与/ 关注/ 的/ 属性/ 之间/ 的/ 关联/ 关系/ ;/ 第/ 2/ 步/ 遍历/ 需要/ 插桩/ 的/ 方法/ 列表/ ,/ 在/ 每个/ 方法/ 的/ 入口/ 点/ 和/ 出口/ 点/ ,/ 插入/ 语句/ 用于/ 记录/ 与/ 这个/ 方法/ 关联/ 的/ 一组/ 属性/ 值/ ./ Algorithm/ :/ InstrumentationInput/ :/ thecodetobeinstrumented/ ,/ alistofmethods/ ,/ alistofOutput/ :/ theinstrumentedcodeListmethodList/ =/ newList/ (/ )/ ;/ foreachinstructioninthecode/ )/ {/ // // 遍历/ 代码/ 中/ 每/ 一条/ 语句/ iftheinstructionusesafieldinthefields/ {/ addthemethoddefinestheinstructiontothemethodList/ ;/ addthefieldtotherefered/ -/ fieldlistofthemethod/ ;/ // // 如果/ 这条语/ 使用/ 了/ 关注/ 的/ 属性/ 列表/ 中/ 的/ 某个/ 属性/ ,/ 将/ 这/ }/ }/ mergemethodListandmethodstonewMethodList/ ;/ // // 将/ 与/ 待/ 插/ 桩/ 属性/ 相关/ 的/ 方法/ 列表/ 和/ 输入/ 的/ 待/ 插/ 桩/ 方法/ 列表/ 合并/ 成为/ 一个/ 新/ 的/ 待/ 插/ 桩/ 方法/ 列表/ foreachmethodinthenewMethodList/ {/ // // 遍历/ 新/ 的/ 待/ 插/ 桩/ 方法/ 列表/ 中/ 的/ 所有/ 方法/ insertprintstatementstorecordthereferedfieldsofthemethodintheentryanddetryofthemethod/ ;/ // // 在/ 方法/ 的/ 入口/ 和/ 出口/ 插入/ 打印/ 语句/ ,/ 用于/ 记录/ 与/ 这个/ 方法/ }/ 相关联/ 的/ 属性/ 的/ 值/ Page7/ 为了/ 搜集/ 程序运行/ 过程/ 中/ 属性/ 的/ 值/ 是否/ 发生/ 改变/ 的/ 信息/ ,/ 需要/ 运行/ 插桩/ 后/ 的/ 程序/ ./ 为了/ 能够/ 覆盖/ 更/ 多/ 的/ 程序/ 路径/ ,/ 可以/ 用/ 不同/ 的/ 参数/ 组合/ 运行/ 程序/ 多次/ ./ 运行/ 结束/ 的/ 准则/ 是/ 尽可能/ 多地/ 覆盖/ 程序/ 的/ 主要/ 场景/ 并且/ 尽可能/ 多地/ 覆盖/ 被/ 插/ 桩/ 的/ 方法/ ./ 在/ 程序/ 的/ 每次/ 运行/ 过后/ ,/ 插入/ 的/ 代码/ 都/ 会/ 输出/ 一组/ 信息/ ,/ 这些/ 信息/ 记录/ 了/ 需要/ 跟踪/ 的/ 属性/ 在/ 方法/ 执行/ 前/ 和/ 执行/ 后/ 的/ 值/ ,/ 可以/ 比较/ 这/ 两组/ 值/ ,/ 看/ 是否/ 发生变化/ ,/ 如果/ 发生/ 了/ 变化/ ,/ 那么/ 该/ 属性/ 就是/ 可变/ 的/ ,/ 并且/ 被/ 执行/ 的/ 方法/ 也/ 是/ 可变/ 的/ ./ 动态分析/ 过程/ 的/ 目的/ 和/ 粒度/ 可控/ ,/ 主要/ 通过/ 改变/ 关注/ 的/ 属性/ 和/ 方法/ 列表/ 完成/ ./ 例如/ ,/ 如果/ 是/ 希望/ 对/ 静态/ 不变性/ 分析/ 的/ 结果/ 进行/ 确认/ ,/ 则/ 将/ 需要/ 确认/ 的/ 属性/ 、/ 方法/ 列表/ 作为/ 动态分析/ 过程/ 的/ 输入/ ,/ 运行/ 动态分析/ 过程/ ,/ 观察/ 这些/ 属性/ 在/ 运行/ 过程/ 中/ 值/ 是否/ 发生/ 改变/ ,/ 以及/ 这些/ 方法/ 是否/ 改变/ 了/ 它们/ 所/ 关联/ 的/ 属性/ 的/ 值/ ./ 当/ 需要/ 对/ 不/ 确定/ 的/ 属性/ 和/ 方法/ 进行/ 进一步/ 确认/ 时/ ,/ 只/ 需要/ 将/ 这些/ 需要/ 确认/ 的/ 属性/ 和/ 方法/ 列表/ 作为/ 动态分析/ 过程/ 的/ 输入/ ,/ 然后/ 运行/ 动态分析/ 过程/ ,/ 当/ 观察/ 到/ 某个/ 属性/ 的/ 值/ 被/ 改变/ 了/ ,/ 那么/ 可以/ 确认/ 该/ 属性/ 是/ 可变/ 的/ ,/ 如果/ 某个/ 方法/ 改变/ 了/ 它/ 关联/ 的/ 属性/ 的/ 值/ ,/ 那么/ 该/ 方法/ 也/ 可以/ 被/ 确认/ 为/ 可变/ 的/ ./ 4/ 原型/ 工具/ 和/ 实验/ 4.1/ 原型/ 工具/ 我们/ 实现/ 了/ 原型/ 工具/ IA4J/ ①/ (/ ImmutabilityAnalysisforJava/ )/ 用于/ 静态/ 不变性/ 分析/ ./ IA4J/ 的/ 输入/ 是/ 待/ 分析程序/ 的/ jar/ 包/ 或者/ Java/ 程序/ 编译/ 后/ 的/ class/ 文件/ ,/ 输出/ 是/ 程序/ 中/ 所有/ 的/ 类/ 、/ 属性/ 和/ 方法/ 的/ 不变性/ 信息/ ./ IA4J/ 用/ BCEL/ ②/ 来/ 解析/ jar/ 包中/ 的/ class/ 文件/ ,/ 然后/ 扫描/ 所有/ 的/ class/ 文件/ 获得/ 类/ ,/ 属性/ 和/ 方法/ 的/ 基本/ 信息/ ,/ 最后/ 采用/ 迭代/ 分析/ 技术/ 给出/ jar/ 包中/ 所有/ 成分/ 的/ 分析/ 结果/ ./ IA4J/ 实现/ 了/ 单机版/ 和/ 网络版/ 两个/ 版本/ ,/ 它/ 既/ 可以/ 作为/ 一个/ 独立/ 的/ 应用程序/ 用于/ 不变性/ 分析/ ,/ 也/ 可以/ 作为/ 动态/ 网页/ 的/ 后台/ 分析/ 引擎/ ./ 在/ 本文/ 的/ 工具/ 主页/ 上面/ ,/ 给出/ 了/ 详细/ 的/ 使用/ 说明/ ./ 4.2/ 实验设计/ 我们/ 设计/ 了/ 3/ 组/ 实验/ ./ 第/ 1/ 组/ 实验/ 选择/ 了/ 10/ 个/ jar/ 包/ 用于/ 静态/ 分析/ 的/ 输入/ ,/ 其中/ 7/ 个/ 选择/ JDK1/ ./ 5/ 中/ 包含/ 的/ jar/ 包/ ,/ 另外/ 3/ 个/ 分别/ 为/ tomcat/ -/ 6.0/ ./ 20/ 中/ 的/ catalina/ ./ jar/ 、/ junit/ -/ 4.5/ ./ jar/ 和/ antlr/ -/ 2.7/ ./ 7/ ./ jar/ ,/ 运行/ 静态/ 分析/ 工具/ 并/ 给出/ 了/ 分析/ 结果/ ;/ 第/ 2/ 组/ 实验/ 比较/ 了/ 没有/ 对/ java/ ./ lang/ 和/ java/ ./ util/ 两个/ 包/ 进行/ 预处理/ 和/ 进行/ 了/ 预处理/ 的/ 分析/ 结果/ ,/ 并且/ 给出/ 了/ 进行/ 了/ 预处理/ 减少/ 不确定性/ 的/ 比例/ ;/ 第/ 3/ 组/ 实验/ 选择/ 了/ 一个/ 网上/ 的/ 开/ 源程序/ ATM/ 用于/ 静/ 动态/ 结合/ 的/ 分析/ ,/ 首先/ 用/ IA4J/ 对/ 它/ 进行/ 了/ 静态/ 分析/ ,/ 然后/ 对/ 静态/ 分析/ 结果/ 中/ 不/ 确定/ 的/ 部分/ 进行/ 了/ 动态分析/ ,/ 并/ 给出/ 了/ 最终/ 的/ 分析/ 结果/ ,/ 此外/ 还/ 对/ 静态/ 分析/ 结果/ 中/ 部分/ 确定/ 的/ 结果/ 用/ 动态分析/ 技术/ 进行/ 了/ 正确性/ 验证/ ./ 4.3/ 实验/ 结果/ 4.3/ ./ 1/ 静态/ 分析/ 结果/ 本文/ 的/ 实验/ 环境/ 如下/ :/ Intel/ (/ R/ )/ Core/ (/ TM/ )/ 2DuoCPUP8600/ @/ 2.40/ GHz/ ,/ RAM2048MB/ ,/ SUNJVM1/ ./ 5/ ./ 实验/ 步骤/ 就是/ 运行/ 静态/ 分析/ 工具/ (/ 包含/ 了/ java/ ./ lang/ 和/ java/ ./ util/ 的/ 预处理/ )/ ,/ 实验/ 的/ jar/ 包选自/ JDK1/ ./ 5/ 的/ lib/ 目录/ 下面/ 包含/ 的/ 7/ 个/ jar/ 包/ ,/ tomcat/ -/ 6.0/ ./ 20/ 中/ 的/ catalina/ ./ jar/ 、/ junit/ -/ 4.5/ ./ jar/ 以及/ antlr/ -/ 2.7/ ./ 7/ ./ jar/ ./ 实验/ 的/ 结果/ 见表/ 1/ ~/ 3/ ,/ 其中/ 表/ 1/ 为/ 类级/ 的/ 分析/ 结果/ ,/ 表/ 2/ 为/ 属性/ 级/ 的/ 分析/ 结果/ ,/ 表/ 3/ 为/ 方法/ 级/ 的/ 分析/ 结果/ ./ 包名/ charsets/ ./ jar6912973940deploy/ ./ jar404326780javaws/ ./ jar361266950jce/ ./ jarjsse/ ./ jarplugin/ ./ jar402319830tools/ ./ jar191313126010catalina/ ./ jar5243212030junit/ -/ 4.5/ ./ jar188167210antlr2/ ./ 7.7/ ./ jar224125990/ 包名/ charsets/ ./ jar16901034591632deploy/ ./ jar13328831672820javaws/ ./ jar11306382342580jce/ ./ jarjsse/ ./ jarplugin/ ./ jar13579642281650tools/ ./ jar8151517321428360catalina/ ./ jar238014057292460junit/ -/ 4.5/ ./ jar24613931760antlr2/ ./ 7.7/ ./ jar130803282450/ ①/ ②/ Page8/ 包名/ charsets/ ./ jar2171147466730deploy/ ./ jar19531374351228javaws/ ./ jar19641310386268jce/ ./ jarjsse/ ./ jarplugin/ ./ jar26362079405152tools/ ./ jar13487906732851135catalina/ ./ jar509430391684371junit/ -/ 4.5/ ./ jar85968446129antlr2/ ./ 7.7/ ./ jar242717625281374/ ./ 3.2/ 有无/ 预处理/ 的/ 实验/ 结果/ 在/ 上/ 一/ 小节/ 中/ ,/ 列出/ 了/ 对/ java/ ./ lang/ 和/ java/ ./ util/ 两个/ 包先/ 进行/ 了/ 预处理/ 的/ 静态/ 分析/ 结果/ ,/ 我们/ 又/ 进行/ 了/ 另外/ 一组/ 实验/ ,/ 在/ 运行/ 静态/ 分析/ 工具/ 之前/ ,/ 不/ 进行/ java/ ./ lang/ 和/ java/ ./ util/ 包/ 的/ 预处理/ ./ 对/ 有无/ 预处理/ 的/ 两组/ 实验/ 进行/ 了/ 比较/ ,/ 并且/ 给出/ 了/ 分析/ 结果/ ,/ 在/ 本次/ 实验/ 中/ ,/ 没有/ 不/ 确定/ 的/ 类/ ,/ 因此/ 如表/ 4/ 所示/ ,/ 表中仅/ 列出/ 了/ 属性/ 和/ 方法/ 在/ 两次/ 实验/ 后/ 不/ 确定/ 部分/ 的/ 数目/ ,/ 并且/ 给出/ 了/ 进行/ 了/ 预处理/ 使得/ 不/ 确定/ 数目/ 减少/ 的/ 比例/ ./ 包名/ charsets/ ./ jar986533/ ./ 7363016.7/ deploy/ ./ jar40528230/ ./ 431322827.2/ javaws/ ./ jar40025835/ ./ 539526832.2/ jce/ ./ jarjsse/ ./ jar1681361922718319/ ./ 4plugin/ ./ jar28016541/ ./ 220015224tools/ ./ jar117583628/ ./ 91463113522.4/ catalina/ ./ jar61124659/ ./ 776937151.8/ junit/ -/ 4.5/ ./ jar1147633/ ./ 317512926.3/ antlr2/ ./ 7.7/ ./ jar844546/ ./ 416913718.94/ ./ 3.3/ 静/ 动态/ 结合/ 的/ 实验/ 本/ 实验/ 选择/ 并/ 改编/ 了/ 一个/ 模拟/ 自助/ 银行/ 的/ 开/ 源程序/ ATM/ ①/ 作为/ 静/ 动态/ 结合/ 的/ 分析程序/ ,/ 该/ 程序/ 共/ 包含/ 了/ 4700/ 行/ 源代码/ ./ 首先/ 对/ 这个/ 包/ 进行/ 了/ 静态/ 分析/ ,/ 在/ 静态/ 分析/ 结果/ 中有/ 31/ 个/ 属性/ 和/ 34/ 个/ 方法/ (/ 其中/ 8/ 个/ 方法/ 是/ 内部/ 方法/ )/ 被/ 标记/ 为/ 不/ 确定/ 的/ ./ 接着/ 对/ 这些/ 不/ 确定/ 的/ 属性/ 和/ 方法/ 进行/ 了/ 动态分析/ ,/ 首先/ 对/ 26/ 个/ 方法/ 进行/ 了/ 插/ 桩/ (/ 那/ 8/ 个/ 内部/ 方法/ 被/ 包含/ 在/ 了/ 这/ 26/ 个/ 方法/ 中/ 某些/ 方法/ 体/ 的/ 内部/ )/ ,/ 然后/ 按照/ ATM/ 机/ 的/ 4/ 种/ 场景/ ,/ 取款/ 、/ 存款/ 、/ 转账/ 和/ 查询/ 余额/ ,/ 对/ 每/ 一种/ 场景/ 选取/ 了/ 3/ 组/ 不同/ 的/ 参数/ 运行/ 这个/ ATM/ 程序/ ,/ 最后/ 对/ 运行/ 后/ 的/ log/ 文件/ 进行/ 分析/ ,/ 发现/ 覆盖/ 了/ 21/ 个/ 被/ 插/ 桩/ 的/ 方法/ ,/ 并且/ 有/ 9/ 个/ 属性/ 和/ 8/ 个/ 方法/ 被/ 确定/ 为/ 可变/ 的/ ,/ 实验/ 结果/ 见表/ 5/ ./ 类/ 65491606549160/ 属性/ 20214031312021404022/ 方法/ 17310334361731034228/ 我们/ 还/ 从/ 静态/ 分析/ 结果/ 中/ 确定/ 的/ 部分/ 选取/ 了/ 一些/ 类/ 、/ 属性/ 和/ 方法/ ,/ 用/ 动态分析/ 的/ 方法/ 验证/ 了/ 这些/ 结果/ 的/ 准确性/ ,/ 由于/ 动态分析/ 的/ 开销/ 较大/ ,/ 不/ 可能/ 将/ 静态/ 分析/ 结果/ 中/ 所有/ 的/ 确定/ 部分/ 都/ 进行/ 验证/ ,/ 我们/ 选择/ 了/ 5/ 个类/ (/ 其中/ 1/ 个/ 是/ 不变/ 的/ ,/ 4/ 个/ 是/ 可变/ 的/ )/ ,/ 33/ 个/ 属性/ (/ 其中/ 18/ 个/ 不变/ 的/ ,/ 9/ 个/ 可变/ 的/ ,/ 6/ 个/ 引用/ 逃逸/ )/ 和/ 36/ 个/ 方法/ (/ 其中/ 21/ 个/ 不变/ 的/ ,/ 9/ 个/ 可变/ 的/ ,/ 6/ 个/ 不/ 确定/ 的/ )/ ./ 因为/ 验证/ 是/ 需要/ 观察/ 在/ 动态分析/ 过程/ 中/ 是否/ 有/ 不变/ 的/ 属性/ 和/ 方法/ 在/ 运行/ 过程/ 中/ 发生/ 改变/ ,/ 因此/ 在/ 动态分析/ 过程/ 中/ 对/ 这/ 5/ 个类/ 中/ 18/ 个/ 不变/ 的/ 属性/ 和/ 21/ 个/ 不变/ 的/ 方法/ 进行/ 插桩/ ./ 接着/ 按照/ ATM/ 的/ 4/ 种/ 场景/ ,/ 每/ 一种/ 场景/ 运行/ 3/ 组/ 不同/ 的/ 参数/ 运行/ 了/ ATM/ 的/ 程序/ ,/ 对/ 运行/ 过程/ 中/ 产生/ 的/ 日志/ 文件/ 进行/ 分析/ ,/ 发现/ 没有/ 静态/ 分析/ 中/ 被/ 确定/ 为/ 不变/ 的/ 类/ 、/ 属性/ 和/ 方法/ ,/ 经过/ 动态分析/ 被/ 确认/ 为/ 可变/ ,/ 实验/ 结果/ 见表/ 6/ ./ 类/ 属性/ 189/ 方法/ 2194.4/ 结果/ 分析/ 和/ 讨论/ 通过/ 对/ 上述/ 3/ 组/ 实验/ 的/ 数据/ 进行/ 分析/ ,/ 发现/ :/ (/ 1/ )/ 在/ 类级/ 的/ 分析/ 结果/ 中/ ,/ 发现/ 大约/ 有/ 70/ %/ 左右/ 的/ 类/ 是/ 不变/ 的/ ,/ 而/ 可变/ 的/ 类/ 大约/ 占/ 了/ 30/ %/ ,/ 没有/ 不/ 确定/ 的/ 类/ ,/ 这/ 是因为/ 在/ 类/ 的/ 不变性/ 规约/ 中/ 规定/ 如果/ 类中/ 有/ 一个/ 属性/ 是/ 可变/ 的/ ,/ 那么/ 该类/ 就是/ 可变/ 的/ ./ 在/ 属性/ 级/ 的/ 分析/ 结果/ 中/ 大约/ 有/ 50/ %/ 左右/ 的/ 属性/ 是/ 不变/ 的/ ,/ 可变/ 的/ 属性/ 约/ 占/ 25/ %/ 左右/ ,/ 而/ 不/ 确定/ 的/ 属性/ 约/ 占/ 25/ %/ 左右/ ,/ 在/ 不/ 确定/ 的/ 属性/ 当中/ ,/ 因为/ 引用/ 逃逸/ 造成/ 的/ 不/ 确定/ 占/ 了/ 绝大部分/ ,/ 而/ 其它/ 类型/ 的/ 不/ 确定/ 只/ 占/ 了/ 很小/ 一部分/ ./ 在/ 方法/ 级/ 的/ 分析/ 结果/ 中/ ,/ 发现/ 约/ 有/ 65/ %/ 左右/ 的/ 方法/ 是/ 不变/ 的/ ,/ 可变/ 的/ 方法/ 大约/ 占/ 了/ 25/ %/ 左右/ ,/ 不/ 确定/ 的/ 方法/ 占/ 了/ 10/ %/ 左右/ ,/ 从/ 这/ ①/ 该/ ATM/ 源程序/ 可以/ 从/ http/ :/ // // www/ ./ math/ -/ cs/ ./ gordon/ ./ edu/ // Page9/ 个/ 比例/ ,/ 可以/ 看出/ 在/ 面向对象/ 程序/ 中/ ,/ 可能/ 引起/ 对象/ 状态/ 发生/ 改变/ 的/ 方法/ 调用/ 只/ 占据/ 了/ 1/ // 4/ 左右/ ,/ 这个/ 信息/ 非常/ 有用/ ,/ 可以/ 用于/ 进一步/ 对/ 程序/ 的/ 分析/ 、/ 测试/ 和/ 验证/ ./ (/ 2/ )/ 从表/ 4/ 中/ 可以/ 看出/ ,/ 在/ 静态/ 分析/ 之前/ 先对/ java/ ./ lang/ 和/ java/ ./ util/ 两个/ 包中/ 的/ 类/ 进行/ 预处理/ ,/ 可以/ 显著/ 地/ 减少/ 静态/ 分析/ 结果/ 中/ 不/ 确定/ 部分/ 的/ 数目/ ,/ 这/ 是因为/ java/ ./ lang/ 和/ java/ ./ util/ 在/ Java/ 程序/ 中/ 使用/ 频繁/ ,/ 而/ 预处理/ 就/ 可以/ 使得/ 以/ 这/ 两个/ 包中/ 的/ 类/ 为/ 类型/ 的/ 属性/ 分析/ 变得/ 确切/ ,/ 减少/ 了/ 不确定性/ 的/ 产生/ ./ (/ 3/ )/ 动态分析/ 可以/ 确切/ 地/ 知道/ 哪些/ 属性/ 在/ 运行/ 过程/ 中值/ 被/ 改变/ 了/ ,/ 哪些/ 方法/ 在/ 执行/ 过程/ 中/ 改变/ 了/ 属性/ 的/ 值/ ,/ 这是/ 动态分析/ 的/ 优势/ ,/ 在/ 实验/ 中/ ,/ 也/ 发现/ 有/ 相当/ 部分/ 的/ 属性/ 值/ 在/ 多次/ 的/ 运行/ 过程/ 中/ 都/ 没有/ 发生/ 改变/ ,/ 同样/ 不少/ 方法/ 在/ 多次/ 执行/ 后/ 也/ 没有/ 改变/ 属性/ 的/ 值/ ,/ 但是/ 因为/ 动态分析/ 的/ 不/ 完备/ 性/ ,/ 无法/ 下结论/ 认为/ 这些/ 属性/ 就是/ 不变/ 的/ ./ 在/ 用/ 动态分析/ 技术/ 对/ 静态/ 分析/ 结果/ 中/ 部分/ 的/ 类/ 、/ 属性/ 和/ 方法/ 进行/ 验证/ 时/ ,/ 没有/ 发现/ 在/ 静态/ 分析/ 结果/ 中是/ 不变/ 的/ 类/ 、/ 属性/ 或者/ 方法/ ,/ 在/ 动态分析/ 过程/ 中/ 被/ 确定/ 为/ 可变/ 的/ ,/ 这/ 是因为/ 本文/ 的/ 静态/ 分析方法/ 采用/ 了/ 保守/ 的/ 分析方法/ ,/ 在/ 不变/ 的/ 和/ 可变/ 的/ 这/ 两类/ 之间/ 还有/ 不/ 确定/ 的/ 这/ 一类/ ,/ 因此/ 可能/ 存在/ 不变/ 的/ 被/ 误报/ 成/ 不/ 确定/ 的/ 、/ 可变/ 的/ 被/ 误报/ 成/ 不/ 确定/ 的/ 这/ 两种/ 情况/ ,/ 但是/ 可变/ 的/ 被/ 误报/ 成/ 不变/ 的/ 、/ 不变/ 的/ 被/ 误报/ 成/ 可变/ 的/ 这/ 两种/ 情况/ 非常/ 非常少/ ./ 我们/ 对/ 经过/ 动态分析/ 被/ 确认/ 为/ 可变/ 的/ 属性/ 和/ 方法/ 进行/ 了/ 仔细/ 研究/ ,/ 观察/ 了/ 这些/ 属性/ 和/ 方法/ 的/ 源代码/ ,/ 发现/ 主要/ 原因/ 在于/ 对/ 字节/ 码/ 进行/ 静态/ 扫描/ 时/ ,/ 只是/ 顺序/ 扫描/ 字节/ 码/ 序列/ 并且/ 考虑/ 了/ 每条/ 字节/ 码/ 语句/ 上下/ 几条/ 语句/ ,/ 没有/ 对/ 程序/ 的/ 上下文/ 进行/ 分析/ ./ 另外/ 还/ 观察/ 了/ 经过/ 动态分析/ 仍然/ 是/ 不/ 确定/ 的/ 属性/ 和/ 方法/ ,/ 发现/ 原因/ 在于/ 这些/ 属性/ 都/ 被/ 引用/ 逃逸/ 出该/ 方法/ ,/ 无法/ 知道/ 哪里/ 会/ 获得/ 这些/ 逃逸/ 的/ 引用/ ,/ 因而/ 只能/ 将/ 其/ 划入/ 引用/ 逃逸/ 一类/ ./ 5/ 相关/ 工作/ Porat/ 等/ 人/ 在/ 文献/ [/ 1/ ]/ 中/ 首次/ 提出/ 了/ 不变性/ 的/ 检测/ 技术/ ,/ 她/ 采用/ 了/ 静态/ 分析/ 的/ 方法/ 自动/ 地/ 检测/ 属性/ 和/ 类/ 的/ 不变性/ ,/ 但是/ 没有/ 给出/ 方法/ 的/ 不变性/ 的/ 检测/ 技术/ ./ 静态/ 分析方法/ 具有/ 不/ 精确/ 的/ 缺陷/ ,/ 因此/ 在/ 该/ 方法/ 的/ 分析/ 结果/ 中/ 仍然/ 有/ 不少/ 类/ ,/ 属性/ 的/ 不变性/ 性质/ 无法/ 确定/ ./ 针对/ 该文/ 提出/ 的/ 不变性/ 分析方法/ ,/ 我们/ 做/ 了/ 比较/ 实验/ ./ 该文/ 中/ 对/ 两个/ jar/ 包/ 进行/ 了/ 分析/ ,/ 一个/ 是/ JDK1/ ./ 2/ 中/ 的/ rt/ ./ jar/ ,/ 另/ 一个/ 是/ IBM/ 内部/ 的/ 产品/ ,/ 我们/ 无法/ 获得/ 该/ 产品/ 的/ jar/ 包/ ,/ 因此/ 只能/ 对/ JDK1/ ./ 2/ 中/ 的/ rt/ ./ jar/ 进行/ 比较/ 分析/ ①/ ./ 文中/ 列出/ 了/ rt/ ./ jar/ 中/ 的/ 静态/ (/ static/ )/ 属性/ 的/ 不变性/ 统计/ 结果/ ,/ 作者/ 用/ 柱状图/ 的/ 形式/ 给出/ 了/ 不变/ 的/ 和/ 可变/ 的/ 这/ 两种/ 属性/ 的/ 统计/ 量/ ,/ 没有/ 给出/ 不/ 确定/ 的/ 数目/ ./ 我们/ 用/ IA4J/ 对/ rt/ ./ jar/ 中/ 的/ 静态/ 属性/ 进行/ 了/ 不变性/ 分析/ ,/ 进行/ 了/ 两组/ 实验/ ,/ 一组/ 没有/ 对/ java/ ./ lang/ 和/ java/ ./ util/ 包/ 进行/ 预处理/ ,/ 另一组/ 进行/ 了/ 预处理/ ,/ 表/ 7/ 为/ 比较/ 实验/ 的/ 结果/ (/ 其中/ Porat/ 实验/ 数据/ 中/ 的/ 1400/ 和/ 1200/ 为/ 柱状图/ 中/ 的/ 粗略/ 值/ ,/ 非/ 精确/ 值/ )/ ./ 从表/ 7/ 可以/ 看出/ ,/ IA4J/ 相比/ 于/ Porat/ 的/ 方法/ ,/ 在/ 没有/ 进行/ 预处理/ 的/ 情况/ 下/ ,/ 不变/ 的/ 属性/ 数目/ 提高/ 了/ 5.8/ %/ 而/ 可变/ 的/ 属性/ 数目/ 降低/ 了/ 1/ %/ ,/ 当/ 进行/ 了/ 预处理/ 以后/ ,/ 不变/ 的/ 属性/ 数目/ 比/ Porat/ 的/ 方法/ 提高/ 了/ 23.5/ %/ ,/ 而/ 可变/ 的/ 属性/ 数目/ 提高/ 了/ 1.6/ %/ ./ 对/ IA4J/ 本身/ ,/ 进行/ 了/ 预处理/ 后/ ,/ 引用/ 逃逸/ 和/ 不/ 确定/ 的/ 属性/ 数目/ 比/ 没有/ 进行/ 预处理/ 降低/ 了/ 53.8/ %/ ,/ 由此可见/ 预处理/ 确实/ 可以/ 降低/ 不确定性/ 的/ 比例/ ,/ 提高/ 分析/ 的/ 精度/ ./ 另外/ ,/ 也/ 观察/ 到/ 在/ 可变/ 属性/ 的/ 数目/ 上/ ,/ IA4J/ 与/ Porat/ 的/ 方法/ 相差/ 很小/ ,/ 这/ 是因为/ 在/ Porat/ 的/ 方法/ 中/ ,/ 如果/ 引用/ 属性/ 逃逸/ 出/ 被/ 分析/ 的/ 程序包/ ,/ 就/ 被/ 当成/ 了/ 可变/ ,/ 而/ 在/ 本文/ 的/ 方法/ 中/ ,/ 对于/ 引用/ 属性/ ,/ 又/ 细分/ 出/ 了/ 引用/ 逃逸/ 一类/ ,/ 如果/ 按照/ Porat/ 的/ 划分/ ,/ 将/ 引用/ 逃逸/ 一类/ 归为/ 可变/ 的/ ,/ 那么/ 可变/ 属性/ 数目/ 将/ 比/ Porat/ 的/ 方法/ 提高/ 20/ %/ ./ 从/ 分析/ 时间/ 上面/ 来看/ ,/ Porat/ 用/ 了/ 20min/ ,/ IA4J/ 只用/ 了/ 10s/ 多/ ,/ 我们/ 的/ CPU/ 速度/ 是/ 她/ 的/ 5/ 倍/ ,/ 而/ 内存容量/ 是/ 她/ 的/ 16/ 倍/ ,/ 扣除/ 硬件/ 速度/ 影响/ ,/ IA4J/ 效率/ 比/ Porat/ 的/ 方法/ 要/ 高/ ./ Porat/ 方法/ [/ 1/ ]/ 20min318914001200N/ // AN/ // AIA4J/ (/ 无/ 预处理/ )/ 10.899/ s318914811188260260IA4J/ (/ 有/ 预处理/ )/ 10.675/ s31891729122022614/ 静态/ 分析/ 技术/ 的/ 难点/ 在于/ 引用/ 别名/ 现象/ 的/ 存在/ ,/ Salcianu/ 等/ 人/ 在/ 文献/ [/ 4/ ]/ 中/ 提出/ 了/ 通过/ 别名/ 分析/ 的/ 技术/ 来/ 提高/ 不变性/ 分析/ 的/ 精度/ ./ Ernst/ 等/ 人/ 在/ 文献/ [/ 5/ -/ 6/ ]/ 中将/ 指针/ 分析/ 的/ 技术引进/ 到/ 不变性/ 的/ 分析/ 过程/ 中/ ,/ 在/ 一定/ 程度/ 上/ 提高/ 了/ 不变性/ 的/ 分析/ 精度/ ,/ 但/ ①/ 在/ 本文/ 的/ 实验/ 阶段/ ,/ 我们/ 联系/ 了/ 文献/ [/ 1/ ]/ 作者/ S/ ./ Porat/ ,/ 希望/ Page10/ 是/ 仍然/ 有/ 相当/ 一部分/ 的/ 属性/ 无法/ 标记/ 其/ 不变性/ 性质/ ,/ 特别/ 是/ 对于/ 分析/ 的/ jar/ 包/ 的/ 范围/ 限制/ 仍然/ 没有/ 什么/ 有效/ 的/ 手段/ ./ 现有/ 的/ 分析/ 不变性/ 的/ 技术/ ,/ 主要/ 集中/ 于/ 对/ 程序/ 的/ 静态/ 分析/ ,/ 因为/ 动态分析/ 需要/ 大量/ 的/ 人工干预/ ,/ 成本/ 太高/ ,/ 因此/ 动态分析/ 技术/ 用/ 的/ 不/ 多/ ,/ 大多/ 是/ 作为/ 静态/ 分析/ 结果/ 中/ 不/ 确定/ 部分/ 的/ 人工/ 确认/ ./ 本文/ 提出/ 了/ 静/ 动态/ 结合/ 的/ 混合/ 分析方法/ 来/ 分析/ Java/ 程序/ 的/ 不变性/ ,/ 在/ 静态/ 分析/ 的/ 基础/ 上/ ,/ 用/ 动态/ 方法/ 进一步/ 确定/ 部分/ 静态方法/ 不能/ 确定/ 的/ 成分/ ,/ 从而/ 提高/ 了/ 静态/ 分析/ 技术/ 的/ 精度/ ,/ 也/ 避免/ 了/ 完全/ 依靠/ 人工/ 确认/ 的/ 高/ 成本/ ./ 不变性/ 在/ 软件工程/ 中有/ 许多/ 应用/ ,/ Pechtchanski/ 和/ Sarkar/ 等/ 人/ 在/ 文献/ [/ 7/ ]/ 中/ 给出/ 了/ 不变性/ 的/ 形式化/ 规约/ 并且/ 提出/ 了/ 不变性/ 信息/ 的/ 一些/ 应用/ 场合/ ,/ 在/ 他/ 的/ 论文/ 中/ 主要/ 将/ 不变性/ 信息/ 用于/ 对/ 代码/ 的/ 优化/ ./ Haack/ 等/ 人/ 在/ 文献/ [/ 8/ ]/ 中/ 给出/ 了/ 改变/ 不变性/ 的/ 一些/ 可能/ 情形/ ,/ 并/ 提出/ 了/ 在/ 程序/ 中/ 加入/ immutable/ 这样/ 的/ notation/ 来/ 保证/ 程序/ 的/ 正确性/ ./ 在/ 一些/ 面向对象/ 的/ 程序设计/ 语言/ 中/ ,/ 有/ 一些/ 设施/ 可以/ 用来/ 强制/ 属性/ 的/ 值/ 在/ 对象/ 的/ 运行/ 过程/ 中/ 不会/ 发生/ 改变/ ,/ 比如/ C++/ 中/ 的/ const/ 关键字/ 和/ Java/ 中/ 的/ final/ 关键字/ ,/ 但是/ 光靠/ const/ 和/ final/ 关键字/ 是/ 远远不够/ 的/ ,/ 当/ 属性/ 是/ 引用/ (/ C++/ 中为/ 指针/ )/ 时/ ,/ const/ 和/ final/ 只能/ 保证/ 指引/ 关系/ 不会/ 发生/ 改变/ ,/ 并/ 不能/ 保证/ 指引/ 的/ 对象/ 状态/ 不会/ 发生/ 改变/ ,/ 因此/ Ernst/ 等/ 人/ 在/ 文献/ [/ 3/ ,/ 5/ -/ 6/ ,/ 9/ ]/ 中/ 提出/ 了/ 通过/ 给/ Java/ 语言/ 引入/ referenceimmutable/ 的/ 关键字/ 来/ 保证/ 程序/ 中/ 属性/ 的/ 不变/ 性质/ ,/ 并/ 提出/ 了/ 一种/ 新/ 的/ 语言/ javari/ -/ Javawithreferenceimmutability/ ./ 在/ 文献/ [/ 2/ ,/ 10/ ]/ 中/ ,/ Artzi/ 等/ 人/ 针对/ 方法/ 参数/ 的/ 不变性/ 做/ 了/ 深入/ 的/ 分析/ ,/ 给出/ 了/ 参数/ 不变性/ 的/ 形式化/ 的/ 定义/ ,/ 并且/ 在/ 此基础/ 上/ 采用/ 了/ 静/ 动态/ 结合/ 的/ 技术/ 进行/ 了/ 分析/ ,/ 提高/ 了/ 分析/ 的/ 精度/ ,/ 所/ 不同/ 的/ 是/ Artzi/ 等/ 人/ 关注/ 对/ 方法/ 参数/ 的/ 不变性/ 分析/ ,/ 而/ 本文/ 关注/ 的/ 是/ 整个/ Java/ 程序/ 中/ 所有/ 的/ 类/ 、/ 属性/ 和/ 方法/ 的/ 不变性/ 性质/ 分析/ ./ 6/ 总结/ 及/ 未来/ 工作/ 程序/ 的/ 不变性/ 信息/ 可以/ 应用/ 在/ 很多/ 方面/ ,/ 例如/ 程序/ 的/ 设计/ 、/ 测试/ 、/ 验证/ 以及/ 代码/ 的/ 优化/ 和/ 调试/ 等/ ./ 在/ 不变性/ 的/ 分析/ 工作/ 中/ ,/ 静态/ 分析/ 技术/ 具有/ 可/ 自动化/ 、/ 效率高/ 的/ 优点/ ,/ 但是/ 它/ 的/ 分析/ 精度/ 低/ ;/ 动态分析/ 技术/ 具有/ 分析/ 准确/ 的/ 优点/ ,/ 但/ 成本/ 高/ 、/ 效率/ 低/ ./ 本文/ 在/ 分析/ 了/ 静/ 、/ 动态分析/ 技术/ 各自/ 的/ 优缺点/ 后/ ,/ 提出/ 了/ 一种/ 静/ 动态/ 结合/ 的/ 混合/ 分析/ 技术/ ,/ 对/ Java/ 程序/ 中类/ 、/ 属性/ 和/ 方法/ 进行/ 了/ 全面/ 的/ 分析/ ,/ 在/ 静态/ 分析/ 前/ 首先/ 对/ java/ ./ lang/ 和/ java/ ./ util/ 包/ 进行/ 预处理/ ,/ 得到/ 其中/ 属性/ 和/ 方法/ 的/ 不变性/ 性质/ ,/ 作为/ 已知/ 信息/ 用于/ 后期/ 对/ 程序/ 的/ 不变性/ 进行/ 静态/ 分析/ ;/ 通过/ 对/ Java/ 程序/ 字节/ 码/ 的/ 静态/ 扫描/ ,/ 获取/ 程序/ 的/ 相关/ 信息/ ,/ 结合/ 预处理/ 得到/ 的/ 不变性/ 信息/ ,/ 采用/ 迭代/ 技术/ 进行/ 静态/ 不变性/ 分析/ ,/ 得到/ Java/ 程序/ 中/ 所有/ 类/ 、/ 方法/ 和/ 属性/ 的/ 不变性/ 性质/ ;/ 如果/ 静态/ 分析/ 结果/ 中有/ 不/ 确定/ 的/ 部分/ ,/ 则/ 进入/ 动态分析/ 过程/ ,/ 针对/ 关注/ 的/ 属性/ 和/ 方法/ ,/ 通过/ 代码/ 的/ 插装/ 、/ 驱动程序/ 运行/ 和/ 动态/ 不变性/ 分析/ ,/ 能/ 在/ 其中/ 确定/ 可变/ 的/ 部分/ ,/ 将/ 动态分析/ 的/ 结果/ 与/ 静态/ 分析/ 的/ 结果/ 整合/ ,/ 形成/ 最终/ 的/ 分析/ 结果/ ./ 我们/ 设计/ 实现/ 了/ 支持/ 上述/ 方法/ 的/ 工具/ 原型/ ,/ 并/ 通过/ 多组/ 实验/ 展示/ 了/ 本文/ 方法/ 的/ 有效性/ 和/ 可用性/ ./ 未来/ 的/ 工作/ 主要/ 包括/ 3/ 方面/ :/ (/ 1/ )/ 在/ 不变性/ 静态/ 分析/ 过程/ 中/ ,/ 对/ 程序/ 的/ 上下文/ 做/ 详尽/ 的/ 分析/ ,/ 减少/ 不确定性/ 的/ 产生/ ;/ (/ 2/ )/ 在/ 不变性/ 动态分析/ 过程/ 中/ ,/ 采用/ 严格/ 的/ 覆盖/ 准则/ 作为/ 动态分析/ 中/ 程序执行/ 终止/ 的/ 条件/ ;/ (/ 3/ )/ 不变性/ 信息/ 可以/ 应用/ 的/ 领域/ 很多/ ,/ 本文/ 只是/ 简单/ 的/ 列出/ 了/ 一些/ 应用/ 场景/ ,/ 而/ 对于/ 不变性/ 的/ 应用/ 仍然/ 有/ 很多/ 的/ 问题/ 值得/ 去/ 研究/ ,/ 需要/ 探索/ 其/ 在/ 软件工程/ 中/ 的/ 作用/ 和/ 应用/ 前景/ ./ 

