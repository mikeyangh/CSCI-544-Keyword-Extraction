Page1HiBase/ :/ 一种/ 基于/ 分层/ 式/ 索引/ 的/ 高效/ HBase/ 查询/ 技术/ 与/ 系统/ 1/ )/ (/ 南京大学/ 计算机软件/ 新/ 技术/ 国家/ 重点/ 实验室/ 南京/ 210046/ )/ 2/ )/ (/ 中兴通讯/ 股份/ 有限公司/ 南京/ 210012/ )/ 3/ )/ (/ 江苏省/ 软件/ 新/ 技术/ 与/ 产业化/ 协同/ 创新/ 中心/ 南京/ 210046/ )/ 4/ )/ (/ 清华大学/ 计算机科学/ 与/ 技术/ 系/ 北京/ 100084/ )/ 摘要/ 大/ 数据/ 时代/ ,/ 众多/ 应用领域/ 的/ 数据量/ 爆炸式/ 增长/ ,/ 迫切需要/ 研究/ 和/ 寻找/ 有效/ 的/ 大/ 数据/ 存储管理/ 方法/ ,/ 提供/ 实时/ 或准/ 实时/ 的/ 大/ 数据/ 查询/ 分析/ 能力/ ./ HadoopHBase/ 系统/ 为/ 大/ 数据/ 的/ 存储管理/ 提供/ 了/ 一种/ 具有/ 高/ 可扩展性/ 的/ 技术/ 方法/ 和/ 系统/ 平台/ ./ 然而/ HBase/ 只有/ 主键/ 索引/ ,/ 不/ 支持/ 非/ 主键/ 索引/ ,/ 这/ 导致/ HBase/ 的/ 数据/ 查询/ 效率/ 较/ 低/ ,/ 难以/ 满足/ 数据/ 实时/ 或准/ 实时/ 查询/ 需求/ ./ 为此/ ,/ 在/ HBase/ 基础/ 上/ 提供/ 面向/ 非/ 主键/ 的/ 快速/ 查询/ 能力/ ,/ 是/ 目前/ Hadoop/ 环境/ 下/ 急需/ 研究/ 和/ 解决/ 的/ 一个/ 重要/ 问题/ ./ 该文/ 研究/ 提出/ 了/ 一种/ 基于/ 分层/ 式/ HBase/ 非/ 主键/ 索引/ 的/ 查询/ 模型/ 和/ 方法/ ,/ 该/ 模型/ 和/ 方法/ 首先/ 建立/ 基于/ HBase/ 的/ 持久性/ 索引/ ./ 然后/ ,/ 为了/ 利用/ 内存/ 提升/ 查询/ 性能/ ,/ 该文/ 进一步/ 提出/ 了/ 一种/ 索引/ 热点/ 数据/ 缓存/ 技术/ 和/ 一种/ 高效/ 的/ 热度/ 累积/ 缓存/ 替换/ 策略/ ,/ 以/ 降低/ 对/ HBase/ 索引/ 表/ 的/ 磁盘/ 访问/ 开销/ ./ 热度/ 累积/ 缓存/ 替换/ 策略/ 克服/ 了/ 最近/ 最少/ 使用/ (/ LRU/ )/ 算法/ 的/ 局限性/ ,/ 考虑/ 数据/ 访问/ 的/ 累积/ 热度/ 和/ 时间/ 局部/ 特性/ ,/ 从而/ 更/ 准确/ 地/ 捕获/ 数据/ 访问/ 的/ 特征/ ./ 为了/ 使/ 索引/ 热点/ 数据/ 缓存/ 内存/ 层/ 具有/ 良好/ 的/ 可扩展性/ ,/ HiBase/ 设计/ 了/ 基于/ 一致性/ 哈希/ 的/ 分布式/ 内存/ 缓存/ ,/ 支持/ 高效/ 的/ 基于/ 非/ 主键/ 的/ 单点/ 查询/ 和/ 范围/ 查询/ ./ 最终/ ,/ 该文/ 设计/ 实现/ 了/ 完整/ 的/ 分层/ 式/ 索引/ 和/ 查询/ 系统/ HiBase/ ./ 在/ 千万/ 至/ 十亿/ 条/ 记录/ 规模/ 数据/ 集上/ 的/ 测试/ 结果表明/ ,/ HiBase/ 冷/ 查询/ 响应/ 时间/ 比/ 标准/ HBase/ 快/ 65/ 倍/ (/ 大/ 结果/ 集/ )/ 到/ 3000/ 多倍/ (/ 小/ 结果/ 集/ )/ ;/ 而/ 引入/ 基于/ 查询/ 热度/ 累积/ 算法/ 的/ 内存/ 索引/ 缓存/ 方法/ 后/ ,/ 热/ 查询/ 性能/ 可/ 在/ HiBase/ 冷/ 查询/ 基础/ 上/ 再/ 提升/ 5/ ~/ 15/ 倍/ ,/ 使得/ 总体/ 查询/ 性能比/ 标准/ HBase/ 快/ 300/ 多倍/ (/ 大/ 结果/ 集/ )/ 到/ 1.7/ 万倍/ (/ 小/ 结果/ 集/ )/ ,/ 比/ 开源/ 的/ Hindex/ 系统/ 快/ 5/ ~/ 20/ 倍/ ./ 关键词/ HBase/ ;/ 非/ 主键/ 索引/ ;/ 查询处理/ ;/ 分层/ 式/ 索引/ ;/ 缓存/ 替换/ 策略/ ;/ 大/ 数据/ 1/ 引言/ 继/ Google/ 在/ 2006/ 年/ 发表/ 论文/ 阐述/ BigTable/ [/ 1/ ]/ 数据模型/ 后/ ,/ 为了/ 有/ 效应/ 对/ 海量/ 数据/ 的/ 存储/ 与/ 查询/ 管理/ ,/ 人们/ 越来越/ 多/ 地用/ NoSQL/ 分布式/ 数据/ 存储系统/ 替代/ 关系数据库/ 管理系统/ (/ RDBMS/ )/ ./ 在/ 迫切/ 的/ 企业/ 大/ 数据/ 应用/ 需求/ 推动/ 下/ ,/ 目前/ 出现/ 了/ 一些/ NoSQL/ 非/ 关系数据/ 存储系统/ ,/ 例如/ ,/ Apache/ 社区/ 的/ HBase/ ①/ ,/ Facebook/ 的/ Cassandra/ [/ 2/ ]/ ,/ Amazon/ 的/ Dynamo/ [/ 3/ ]/ 以及/ 支持/ 高效/ 数据/ 查询/ 的/ 内存/ 数据/ 存储系统/ Redis/ ②/ 等等/ ./ 这些/ 数据/ 存储/ 都/ 采用/ 了/ key/ -/ value/ 数据模型/ ./ 在/ key/ -/ value/ 数据/ 存储系统/ 中/ ,/ HBase/ 的/ 使用/ 最为/ 广泛/ ./ HBase/ 在/ 主键/ 上/ 建立/ 了/ 类/ B/ +/ 树/ 索引/ ,/ 可以/ 高效/ 地/ 支持/ 基于/ 主键/ 的/ 快速/ 数据/ 查询/ ./ 然而/ ,/ 由于/ HBase/ 缺少/ 非/ 主键/ 索引/ 能力/ ,/ 在/ 面对/ 以非/ 主键/ 为/ 条件/ 的/ 查询/ 请求/ 时/ ,/ 需要/ 对/ 全表/ 进行/ 扫描/ ,/ 导致/ 查询/ 效率/ 低下/ ,/ 难以/ 满足需要/ 快速/ 响应/ 的/ 数据/ 查询/ 和/ 统计分析/ 场景/ ./ 在/ 传统/ 关系数据库/ 领域/ ,/ 面对/ 这样/ 的/ 问题/ ,/ 通常/ 会/ 借助/ 索引/ 来/ 解决/ ./ 为了/ 优化/ 非/ 主键/ 查询/ 的/ 响应/ 时间/ ,/ 降低/ 查询/ 代价/ ,/ 本文/ 研究/ 提出/ 了/ 一种/ 基于/ HBase/ 的/ 非/ 主键/ 索引/ 和/ 查询/ 模型/ 与/ 技术/ ./ 随着/ 内存/ 性能/ 的/ 持续/ 提升/ 和/ 价格/ 的/ 不断/ 下降/ ,/ 内/ 存在/ 支持/ 实时/ 大/ 数据处理/ 的/ 商业/ 需求/ 中/ 扮演着/ 越来越/ 重要/ 的/ 角色/ ./ 目前/ ,/ 用/ 内存/ 计算/ 提升/ 大/ 数据处理/ 性能/ 已/ 成为/ 普遍/ 公认/ 的/ 发展/ 方向/ [/ 4/ ]/ ./ 在/ 大/ 数据/ 查询/ 分析/ 过程/ 中/ ,/ 数据/ 访问/ 通常/ 具有/ 一定/ 的/ 80/ // 20/ 分布/ 特征/ :/ 即/ 20/ %/ 的/ 数据/ 通常/ 会/ 被/ 频繁/ 访问/ ,/ 我们/ 把/ 这些/ 数据/ 称之为/ “/ 热/ 数据/ ”/ ;/ 而/ 80/ %/ 的/ 数据/ 很少/ 被/ 访问/ ,/ 我们/ 称之为/ “/ 冷/ 数据/ ”/ ./ 为了/ 提高/ 查询/ 性能/ ,/ 低/ 延迟/ 、/ 高带宽/ 的/ 内存/ 被/ 普遍/ 用做/ 热/ 数据/ 缓存/ 来/ 填补/ CPU/ 和/ 磁盘/ 之间/ 的/ 性能/ 鸿沟/ ./ 为了/ 优化/ HBase/ 上非/ 主键/ 属性/ 查询/ 的/ 性能/ ,/ 本文/ 研究/ 实现/ 了/ 基于/ HBase/ 的/ 分层/ 式/ 索引/ 和/ 查询/ 系统/ HiBase/ (/ Hierarchical/ -/ indexedHBase/ )/ ./ 在/ 索引/ 存储/ 模型/ 上/ ,/ HiBase/ 分为/ 两层/ :/ ①/ 基于/ HBase/ 的/ 持久/ 化/ 存储/ 层/ ./ 用来/ 存储/ HBase/ 用户/ 表/ 对应/ 的/ 所有/ 非/ 主键/ 索引/ 数据/ ;/ ②/ 基于/ 分布式/ 内存/ 的/ 缓存/ 层/ ./ 为了/ 进一步提高/ 索引/ 访问/ 的/ 速度/ ,/ 本文/ 研究/ 提出/ 了/ 一种/ 基于/ 分布式/ 内存/ 的/ 索引/ 热点/ 数据/ 缓存/ 替换/ 策略/ 和/ 技术/ ,/ 将/ 部分/ 索引/ 热点/ 数据/ 缓存/ 在/ 内存/ 中/ ,/ 大幅提高/ 数据/ 查询/ 访问/ 的/ 效率/ ./ 在/ HiBase/ 中/ ,/ 我们/ 进一步/ 研究/ ①/ ②/ Page3/ 实现/ 了/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ ,/ 它/ 克服/ 了/ 最近/ 最少/ 使用/ 算法/ (/ LRU/ )/ 只/ 关注/ 数据/ 最近/ 一次/ 访问/ 时间/ 、/ 不/ 关注/ 数据/ 访问/ 频繁/ 程度/ 不同/ 的/ 局限性/ ,/ 考虑/ 数据/ 访问/ 的/ 累积/ 热度/ ,/ 并/ 对/ 早前/ 时间/ 的/ 热度/ 累积/ 进行/ 指数/ 衰减/ ,/ 从而/ 更/ 准确/ 地/ 捕获/ 数据/ 访问/ 的/ 特征/ ./ 同时/ 在/ 缓存/ 空间/ 未满/ 的/ 时候/ ,/ 采用/ “/ 访问/ 即/ 插入/ ”/ 的/ 缓存/ 插入/ 策略/ ,/ 保证/ 缓存/ 空间/ 得到/ 充分利用/ ,/ 缓存/ 命中率/ 在/ 数据/ 加载/ 阶段/ 可以/ 得到/ 快速/ 提升/ 并/ 趋于稳定/ ./ 而/ 当/ 缓存/ 充满/ 以后/ ,/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ 会/ 根据/ 记录/ 的/ 热度/ 累积/ 评分/ 选择/ “/ 牺牲者/ ”/ 淘汰/ 出/ 内存/ ,/ 选择/ 获得/ 热度/ 高分/ 的/ 记录/ 保存/ 在/ 缓存/ 中/ ./ 通过/ 实验/ 对比/ 算法/ 的/ 命中率/ 和/ 系统/ 的/ 查询/ 响应/ 时间/ ,/ 验证/ 了/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ 可以/ 有效/ 地/ 优化/ 非/ 主键/ 索引/ 上/ 的/ 查询/ 性能/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 3/ 节/ 给出/ HiBase/ 的/ 非/ 主键/ 索引/ 及其/ 存储/ 模型/ ;/ 第/ 4/ 节/ 提出/ HiBase/ 索引/ 热点/ 数据/ 缓存/ 替换/ 策略/ ;/ 第/ 5/ 节/ 阐述/ HiBase/ 的/ 系统/ 设计/ 与/ 实现/ ;/ 第/ 6/ 节对/ 实验/ 结果/ 进行/ 分析/ 评估/ ;/ 第/ 7/ 节是/ 总结/ 与/ 展望/ ./ 2/ 相关/ 工作/ 通常/ ,/ 检索/ HBase/ 表中/ 的/ 数据/ 有/ 3/ 种/ 方式/ :/ 指定/ 单个/ 行键/ 查询/ 、/ 指定/ 行键/ 的/ 范围/ 查询/ 以及/ 扫描/ (/ Scan/ )/ ./ HBase/ 以/ 字节/ 数组/ 的/ 字典/ 序对/ 行键/ 进行/ 排序/ (/ 这种/ 存储/ 格式/ 更/ 适合/ 于/ 记录/ 的/ 顺序/ 读取/ ,/ 充分利用/ 磁盘/ 传输/ 带宽/ )/ ,/ 支持/ 高效/ 的/ 指定/ 行键/ 的/ 单点/ 查询/ 和/ 指定/ 行键/ 范围/ 的/ 范围/ 查询/ ./ 扫描/ 操作/ 主要/ 用于/ 对非/ 主键/ 属性/ 的/ 查询/ ,/ 它/ 允许/ 指定/ 扫描/ 的/ 数据/ 范围/ ,/ 可以/ 在/ 查询/ 过程/ 中/ 指定/ 限定/ 条件/ 来/ 过滤/ 目标/ 结果/ 集/ ./ 扫描/ 操作/ 允许/ 对/ 任意/ 一个/ 数据/ 属性/ 进行/ 查询/ ,/ 因而/ 比/ 基于/ 行键/ 的/ 查询/ 更/ 灵活/ ,/ 但是/ 对非/ 主键/ 属性/ 的/ 扫描/ 操作/ 代价/ 很大/ ./ 基于/ 行键/ 检索/ 的/ 时间/ 复杂性/ 是/ O/ (/ logN/ )/ ,/ 甚至/ 如果/ 使用/ Bloomfilter/ 可以/ 达到/ O/ (/ 1/ )/ ,/ 而/ 扫描/ 操作/ 的/ 时间/ 复杂性/ 是/ O/ (/ N/ )/ ./ 大/ 数据/ 应用/ 的/ 数据/ 记录/ 规模/ 在/ 千万/ 至/ 亿级/ 以上/ ,/ 对/ 全表/ 进行/ 非/ 主键/ 扫描/ 的/ 时间/ 开销/ 是/ 不可/ 接受/ 的/ ,/ 这/ 导致/ 了/ HBase/ 在/ 很多/ 实际/ 应用/ 中/ 难以/ 满足/ 高/ 实时性/ 的/ 查询/ 需求/ ./ 为此/ ,/ 一些/ 研究/ 工作/ 致力于/ 改善/ HBase/ 非/ 主键/ 查询/ 的/ 性能/ ./ 这些/ 工作/ 按照/ 研究/ 目标/ 可以/ 分为/ 如下/ 几个/ 方面/ :/ (/ 1/ )/ 面向/ 选择/ 查询/ 优化/ 的/ 非/ 主键/ 索引/ 方法/ 针对/ 大/ 数据/ 上/ 基于/ 非/ 主键/ 属性/ 的/ 选择/ 查询/ (/ 包括/ 单点/ 查询/ 和/ 范围/ 查询/ )/ 需求/ ,/ 华为公司/ 研发/ 并/ 开源/ 了/ 非/ 主键/ 索引/ 查询/ 系统/ Hindex/ ①/ ./ 它/ 采用/ 基于/ Region/ 的/ 局部/ 索引/ 模型/ ,/ 通过/ 对/ HBase/ 表/ 的/ 每个/ Region/ 建立/ 单独/ 的/ 索引/ 表来/ 提高/ 非/ 主键/ 查询/ 的/ 效率/ ./ 查询/ 请求/ 发送到/ 每个/ Region/ 服务器/ ,/ 然后/ 通过/ Region/ 上/ 的/ 索引/ 表将/ 结果/ 集/ 过滤/ 并/ 返回/ ./ Hindex/ 查询/ 需要/ 访问/ 所有/ 的/ Region/ ,/ 由于/ 绝大多数/ 检索/ 任务/ 的/ 目标/ 记录/ 数量/ 相对/ 较/ 少/ ,/ 在/ 分布式/ 集群/ 中/ 并行/ 地/ 执行/ 该/ 任务/ 往往/ 造成/ 很多/ 未/ 存储/ 任何/ 目标/ 记录/ 的/ 计算/ 节点/ 也/ 触发/ 了/ 检索/ 过程/ ,/ 而/ 最终/ 却/ 返回/ 空集/ ./ 在/ 检索/ 任务/ 频繁/ 的/ 情况/ 下/ ,/ 这一/ 并行执行/ 过程/ 会/ 耗费/ 大量/ 不必要/ 的/ 计算资源/ ,/ 最终/ 将/ 降低/ 系统/ 的/ 并发/ 查询/ 吞吐量/ 和/ 系统/ 的/ 查询/ 效率/ ./ NGDATA/ 公司/ 的/ HBase/ -/ indexer/ ②/ 也/ 提供/ 了/ HBase/ 上/ 的/ 非/ 主键/ 索引/ ./ HBase/ -/ indexer/ 将/ HBase/ 的/ 更新/ 数据/ 异步/ 发送到/ 索引/ 服务器/ 上/ ,/ 在/ 索引/ 服务器/ 上/ 分析/ 数据/ 并/ 生成/ 对应/ 的/ 索引/ 数据/ ./ 索引/ 服务器/ 会/ 定期/ 将/ 索引/ 数据/ 推送/ 到/ SolrCloud/ ③/ 服务/ 集群/ 上/ ,/ 查询/ 则/ 通过/ 访问/ Solr/ 服务/ 来/ 定位/ HBase/ 上/ 的/ 内容/ ./ 这种/ 索引/ 机制/ 周期性地/ 对/ 索引/ 进行/ 异步/ 更新/ ,/ 索引/ 的/ 时效性/ 稍差/ ,/ 在/ 面向/ 实时/ 应用/ 时/ 难以/ 有效/ 地/ 满足/ 需求/ ./ (/ 2/ )/ 面向/ 范围/ 查询/ 优化/ 的/ 非/ 主键/ 索引/ 方法/ IntervalIndex/ [/ 5/ ]/ 是/ 希腊/ Patras/ 大学/ 提出/ 的/ 基于/ HBase/ 的/ 非/ 主键/ 范围/ 查询/ 索引/ ,/ 它/ 通过/ MapReduce/ 构造/ SegmentTree/ [/ 6/ ]/ 索引/ 结构/ 并/ 保存/ 在/ 内存/ 中/ ,/ 同时/ 将/ 索引/ 树中/ 存储/ 的/ 每段/ 范围/ 的/ 上界/ 保存/ 在/ HBase/ 表中/ ,/ 以/ 支持/ 有效/ 的/ 范围/ 查询/ ./ IntervalIndex/ 的/ 可扩展性/ 好/ ,/ 但是/ 对/ 单点/ 查询/ ,/ 线段/ 树/ 退化/ 成/ 二叉树/ ,/ 索引/ 的/ 空间/ 开销/ 和/ 维护/ 代价/ 都/ 很大/ ./ 中国科学院/ 研究/ 团队/ 提出/ 在/ 分布式/ 有序/ 表上/ 提供/ 高性能/ 、/ 低/ 空间/ 开销/ 和/ 高/ 可用/ 的/ 基于/ 非/ 主键/ 的/ 多维/ 范围/ 查询/ 索引/ 方案/ CCIndex/ ,/ 并/ 分别/ 在/ HBase/ 和/ Cassandra/ 上/ 实现/ 了/ 原型/ 系统/ [/ 7/ -/ 8/ ]/ ./ 其/ 主要/ 思想/ 是/ :/ 充分利用/ 数据/ 的/ 多个/ 副本/ ,/ 在/ 每个/ 副本/ 上/ 分别/ 建立/ 基于/ 不同/ 非/ 主键/ 属性/ 的/ 聚簇/ 索引/ ,/ 将/ 非/ 主键/ 查询/ 中/ 大量/ 的/ 随机/ 读/ 转换成/ 基于/ 索引/ 表/ 主键/ 的/ 顺序/ 扫描/ ./ CCIndex/ 在/ 多维/ 非/ 主键/ 范围/ 查询/ 上/ 取得/ 了/ 显著/ 的/ 性能/ 提升/ ,/ 同时/ 优化/ 了/ 索引/ 的/ 空间/ 开销/ ./ Bloomfilter/ 是/ Bloom/ 在/ 1970/ 年/ 提出/ 的/ 二进制/ 向量/ 数据结构/ ,/ 它/ 具有/ 很/ 好/ 的/ 空间/ 和/ 时间/ 效率/ ,/ 被/ 用来/ 检测/ 一个/ 元素/ 是不是/ 集合/ 中/ 的/ 一个/ 成员/ ./ Bloomfilter/ 的/ 局限性/ 是/ 它/ 仅/ 可以/ 应用/ 于/ 单值/ 查询/ (/ point/ ①/ ②/ ③/ Page4query/ )/ ./ 在/ 文献/ [/ 9/ ]/ 中/ ,/ 微软/ 提出/ 了/ 一种/ 新/ 的/ 数据结构/ AdaptiveRangeFilter/ (/ ARF/ )/ ./ 从/ 本质/ 上/ 来说/ ,/ ARF/ 是/ 适用/ 于/ 范围/ 查询/ 的/ Bloomfilter/ ,/ 可以/ 判定/ 出/ 一个/ 集合/ 中/ 的/ 全部/ 元素/ 都/ 不/ 在/ 特定/ 的/ 域值/ 空间/ 内/ ./ ARF/ 继承/ 了/ Bloomfilter/ 的/ 优点/ :/ 快速/ 、/ 节省/ 空间/ ,/ 它/ 可以/ 为/ 具有/ 可/ 排序/ 特性/ 的/ 属性/ 列/ 建立/ 索引/ ,/ 并/ 可以/ 探测/ 一个/ 属性/ 列/ 上/ 是否/ 有/ 满足/ 范围/ 查询/ 需求/ 的/ 记录/ ,/ 以此/ 来/ 优化/ 范围/ 查询/ 的/ 性能/ ./ (/ 3/ )/ 采用/ 内存/ 缓存/ 的/ 查询/ 优化/ 方法/ 随着/ 内存/ 和/ 固态/ 硬盘/ 性价比/ 的/ 持续/ 提升/ ,/ 大/ 数据/ 上/ 的/ 缓存/ 算法/ 成为/ 近几年/ 的/ 研究/ 热点/ ./ TBF/ [/ 10/ ]/ 在/ HBase/ 数据/ 存储/ 上/ 提出/ 了/ 基于/ 固态/ 硬盘/ 的/ 缓存/ 替换/ 策略/ ./ TBF/ 算法/ 结合/ CLOCK/ 和/ Bloomfilter/ 的/ 优点/ ,/ 充分利用/ HBase/ 数据/ 存储/ 行键/ 有序/ 的/ 特点/ ,/ 有效/ 地/ 降低/ 缓存/ 替换算法/ 的/ 两个/ 元/ 数据/ (/ “/ 数据/ 记录/ 是否/ 被/ 缓存/ ”/ 和/ “/ 最近/ 访问信息/ ”/ )/ 的/ 空间/ 开销/ ./ TBF/ 算法/ 的/ 空间/ 效率高/ ,/ 但/ 它/ 无法/ 避免/ CLOCK/ 算法/ 固有/ 的/ 缺陷/ ,/ 不能/ 量化/ 数据/ 最近/ 被/ 访问/ 的/ 频率/ ,/ 并且/ 不能/ 保存/ 一个/ CLOCK/ 周期/ 以外/ 的/ 数据/ 访问信息/ ./ 高效/ 、/ 准确/ 地区/ 分/ 冷热/ 数据/ 是/ 缓存/ 算法/ 的/ 基础/ ./ 将/ 频繁/ 访问/ 的/ 热/ 数据/ 缓存/ ,/ 可以/ 大幅度提高/ 查询/ 的/ 性能/ ./ 微软/ 在/ 文献/ [/ 11/ ]/ 中/ 提出/ 了/ 如何/ 区分/ 持续/ 数据/ 访问/ 中/ 的/ 冷热/ 数据/ 的/ 方法/ ./ 通过/ 指数/ 平滑/ 算法/ 将/ 数据/ 记录/ 的/ 访问/ 频率/ 量化/ ,/ 并/ 动态/ 调整/ 冷热/ 数据/ 的/ 门限/ 至/ 最终/ 收敛/ ./ 由于/ 针对/ 的/ 是/ 离线/ 日志/ 的/ 数据/ 访问/ 分析/ ,/ 所以/ 微软/ 在/ 这/ 篇文章/ 里/ 提出/ 了/ 回溯/ (/ backward/ )/ 算法/ 和/ 并行/ 回溯/ 算法/ ,/ 回溯/ 算法/ 只/ 适用/ 于/ 日志/ 数据/ 的/ 离线/ 分析/ ,/ 因为/ 只有/ 这样/ 才/ 可以/ 高效/ 地/ 从/ 新/ 时间/ 到/ 旧/ 时间/ 逆向/ 分析/ 日志/ ,/ 使/ 冷热/ 门限/ 提前/ 收敛/ ./ 本文/ 研究/ 提出/ 了/ 一种/ 分层/ 式/ 非/ 主键/ 索引/ 方案/ :/ 采用/ 全局/ 索引/ 模型/ 的/ 非/ 主键/ 持久/ 化/ 索引/ 层/ ,/ 为/ 索引/ 机制/ 提供/ 良好/ 的/ 可扩展性/ 和/ 可靠性/ ;/ 内存/ 热点/ 索引/ 数据/ 缓存/ 层/ 通过/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ 为/ 非/ 主键/ 查询/ 提供/ 实时/ 、/ 准确/ 的/ 热点/ 数据/ 缓存/ ;/ 同时/ ,/ 基于/ 一致性/ 哈希/ 的/ 分布式/ 内存/ 缓存/ 结构/ 为/ HiBase/ 缓存/ 层/ 提供/ 了/ 良好/ 的/ 可扩展性/ 和/ 容错性/ ./ 3/ 分层/ 式/ 索引/ 存储/ 机制/ 3.1/ 非/ 主键/ 持久/ 化/ 索引/ 存储/ 模型/ 为了/ 避免/ 对/ HBase/ 非/ 主键/ 查询/ 时/ 的/ 全表/ 扫描/ ,/ 提供/ 快速/ 的/ 非/ 主键/ 查询/ 能力/ ,/ HiBase/ 为/ 保存/ 在/ HBase/ 用户/ 表中/ 的/ 非/ 主键/ 属性/ 建立/ 索引/ 表/ ,/ 并/ 将/ 索引/ 表/ 保存/ 在/ HBase/ 中/ ,/ 借助/ HBase/ 获得/ 良好/ 的/ 可扩展性/ 和/ 容错性/ ./ 每个/ HiBase/ 索引/ 表/ 用来/ 存储管理/ 用户/ 表中/ 的/ 某个/ 待/ 查询/ 非/ 主键/ 属性/ 的/ 索引/ ./ 我们/ 为/ 用户/ 表中待/ 建立/ 索引/ 的/ 非/ 主键/ 属性/ 定义/ 如下/ 格式/ 的/ 索引/ 表/ 主键/ :/ 〈/ 用户/ 表/ 索引/ 列名/ (/ 简短/ 别名/ )/ ,/ 用户/ 表/ 索引/ 列值/ ,/ 用户/ 表/ 主键/ 〉/ 其中/ ,/ 用户/ 表/ 索引/ 列名/ 是/ 用户/ 表中/ 被/ 索引/ 属性/ 的/ 名称/ ./ 通过/ 将/ 列名/ 映射/ 到/ 一个/ 简短/ 的/ 别名/ ,/ 如/ “/ Age/ ”/ 映射/ 到/ “/ a/ ”/ ,/ 可/ 减少/ 索引/ 表/ 主键/ 存储空间/ 的/ 开销/ ./ 在/ 索引/ 表/ 主键/ 中/ 存储用户/ 表/ 主键/ 有/ 两个/ 作用/ :/ 一是/ 保证/ 了/ 索引/ 表/ 主键/ 的/ 唯一性/ ;/ 二是/ 提供/ HBase/ 用户/ 表中/ 被/ 索引/ 记录/ 的/ 地址/ ,/ 通过/ 用户/ 表/ 主键/ ,/ 可/ 快速/ 获得/ 用户/ 表中/ 被/ 索引/ 的/ 记录/ ./ 图/ 1/ 给出/ 了/ 一个/ HBase/ 用户/ 表示/ 例/ 以及/ 以/ Age/ 属性/ 为/ 索引/ 主键/ 的/ 索引/ 模型/ 和/ 索引/ 表示/ 例/ ./ 该/ 示例/ 中/ ,/ 索引/ 表/ 的/ 主键/ 形/ 如/ “/ a/ ,/ 12/ ,/ Tom/ ”/ ,/ 其中/ ,/ a/ 为/ Age/ 属性/ 的/ 简短/ 别名/ ;/ 12/ 是/ 用户/ 表/ 数据/ 记录/ Tom/ 的/ Age/ 值/ ,/ 也/ 就是/ 索引/ 列值/ ;/ Tom/ 是/ 该/ 记录/ 在/ 用户/ 表中/ 对应/ 的/ 主键/ ./ 与/ 关系数据库/ 中/ 的/ 部分/ 索引/ (/ partialindex/ )/ 一样/ ,/ HiBase/ 以/ 查询/ 属性/ 为/ 索引/ 表/ 主键/ ,/ 索引/ 表/ 包含/ 用户/ 表/ 的/ 部分/ 字/ 段/ ,/ 通常/ 只/ 将/ 查询/ 中/ 可能/ 需要/ 辅助性/ 访问/ 的/ 字/ 段/ 存放/ 在/ 索引/ 表/ 的/ 非/ 主键/ 属性/ 中/ ./ 这是/ 为了/ 方便/ 对/ 查询/ 中/ 需要/ 访问/ 的/ 辅助性/ 字/ 段/ 提供/ 快读/ 访问/ ,/ 避免/ 再次/ 访问/ 用户/ 表而/ 导致/ 的/ 二次/ 磁盘/ 访问/ ./ 本例/ 中/ ,/ 索引/ 表中/ 的/ value/ 部分/ 所/ 保存/ 的/ 如/ {/ Income/ :/ 500/ }/ ,/ 表示/ 查询/ Age/ 时/ 可能/ 需要/ 访问/ Income/ 列/ ./ 以上/ 描述/ 了/ 单个/ 非/ 主键/ 属性/ 索引/ 的/ 情形/ ./ 在/ 实际/ 应用/ 中/ 存在/ 多个/ 非/ 主键/ 属性/ 组合/ 查询/ 的/ 需求/ ,/ 为此/ ,/ 类似/ 于/ 数据库/ 中/ 的/ 多/ 字/ 段/ 索引/ ,/ 需要/ 构建/ 多个/ 非/ 主键/ 属性/ 列/ 的/ 组合/ 索引/ ./ 对于/ 多个/ 非/ 主键/ 属性/ 列/ 的/ 组合/ 查询/ 情况/ ,/ HiBase/ 会/ 基于/ 多个/ 查询/ 属性/ 列/ 建立/ 索引/ ./ 举例来说/ ,/ 当/ 查询/ 请求/ 的/ 条件/ 中/ 同时/ 包含/ “/ Age/ ”/ 和/ “/ Income/ ”/ 时/ ,/ 我们/ 建立/ 以/ 这/ 两个/ 非/ 主键/ 列为/ 主键/ 的/ 索引/ 表/ ./ 索引/ 表/ 的/ 主键/ 构成/ 形/ 如/ “/ a/ ,/ 12/ ,/ i/ ,/ 500/ ,/ Tom/ ”/ ./ 其中/ a/ 是/ 列名/ “/ Age/ ”/ 的/ 别名/ ,/ i/ 是/ 列名/ “/ Income/ ”/ 的/ 别名/ ./ 在/ 这里/ ,/ 我们/ 使用/ 逗号/ 做/ 分隔符/ (/ HiBase/ 的/ 分隔符/ 是/ 可/ 配置/ 的/ ,/ 对于/ 整数/ 、/ 浮点数/ 类/ Page5/ 型/ 和/ 固定/ 长度/ 字符串/ 类型/ ,/ 系统/ 指定/ 使用/ ‘/ \/ 0/ ’/ 作为/ 分隔符/ ./ 对于/ 变/ 长/ 字符串/ 类型/ ,/ 用户/ 需/ 自定义/ 分隔符/ )/ ./ 在/ 多个/ 属性/ 列/ 上/ 建立/ 了/ 索引/ 后/ ,/ 组合/ 查询/ 就/ 转换成/ 基于/ 索引/ 表/ 主键/ 的/ 查询/ ,/ 索引/ 过程/ 和/ 查询/ 过程/ 与/ 单/ 属性/ 查询/ 基本相同/ ./ 3.2/ 分层/ 式/ 索引/ 存储/ 模型/ 与/ 索引/ 缓存/ 上述/ 索引/ 表将/ 为/ HBase/ 表/ 实现/ 索引/ 数据/ 的/ 持久/ 化/ 存储/ ./ 由于/ 索引/ 数据/ 是/ 存放/ 在/ HBase/ 中/ ,/ 每次/ 查询/ 访问/ HBase/ 表会/ 涉及/ 到/ 很多/ 磁盘/ 访问/ ,/ 我们/ 进一步/ 考虑/ 把/ 索引/ 中/ 那些/ 访问/ 频率/ 高/ 的/ 索引/ 数据/ 作为/ 热点/ 数据/ 缓存/ 在/ 内存/ 中/ ,/ 形成/ 基于/ HBase/ 和/ 分布式/ 内存/ 的/ 分层/ 式/ 索引/ 存储/ 和/ 查询/ 机制/ ,/ 进一步提高/ 索引/ 的/ 查询/ 速度/ ./ HiBase/ 的/ 分层/ 式/ 索引/ 存储/ 模型/ 如图/ 2/ 所示/ ./ HiBase/ 中/ 的/ 内存/ 热点/ 索引/ 数据/ 缓存/ 格式/ 不同于/ 持久/ 化/ 存储/ 中/ 的/ 索引/ 格式/ ,/ 内存/ 缓存/ 索引/ 的/ 主键/ 格式/ 为/ 〈/ 用户/ 表/ 索引/ 列名/ (/ 简短/ 别名/ )/ ,/ 用户/ 表/ 索引/ 列值/ 〉/ 其中/ ,/ 用户/ 表/ 索引/ 列名/ 和/ 用户/ 表/ 索引/ 列值/ 的/ 含义/ 与/ 持久/ 化/ 索引/ 存储/ 层中/ 的/ 相同/ ./ 内存/ 索引/ 构建/ 的/ 基本思路/ 类似/ 于/ 倒排/ 索引/ ,/ 内存/ 索引/ 缓存/ 层中/ 的/ 每个/ 索引/ 主键/ 对应/ 着/ 一个/ 具有/ 相同/ 索引/ 列值/ 的/ 索引/ 记录/ 集合/ ,/ 该/ 集合/ 包含/ 了/ 与/ 该/ 索引/ 值/ 对应/ 的/ 所有/ 索引/ 表/ 数据/ 记录/ ./ 与/ 持久/ 化/ 索引/ 存储/ 层/ 一样/ ,/ 集合/ 中/ 也/ 包含/ 了/ 可能/ 需要/ 访问/ 的/ 其他/ 非/ 主键/ 属性/ ./ 因此/ ,/ 完整/ 的/ 内存/ 索引/ 数据格式/ 如下/ :/ 索引/ 主键/ :/ 〈/ 用户/ 表/ 索引/ 列名/ (/ 简短/ 别名/ )/ ,/ 用户/ 索引/ 集合/ :/ {/ 〈/ 用户/ 表/ 主键/ ,/ {/ 〈/ 频繁/ 访问/ 列名/ ,/ 频图/ 3/ 是/ 内存/ 缓存/ 层/ 的/ 索引/ 结构/ 示例/ ,/ 该例/ 中/ 缓存/ 了/ Age/ 属性/ 下/ 的/ 两个/ 年龄/ 值/ “/ 21/ ”/ 和/ “/ 30/ ”/ ,/ 分别/ 对应/ 于/ 索引/ 内存/ 缓存/ 层/ 的/ 主键/ “/ a/ ,/ 21/ ”/ 和/ “/ a/ ,/ 30/ ”/ ,/ 其中/ ,/ a/ 是/ Age/ 的/ 简短/ 别名/ ./ 当以/ 年龄/ 为/ 30/ 进行/ 查询/ 时/ ,/ 根据/ 索引/ 内存/ 缓存/ 层/ 主键/ “/ a/ ,/ 30/ ”/ 的/ 哈希/ 值/ 找到/ 对应/ 索引/ 在/ 内存/ 中/ 的/ 存储/ 地址/ ,/ 可以/ 得到/ 该/ 年龄/ 值/ 所/ 对应/ 的/ 索引/ 集合/ {/ 〈/ Jerry/ ,/ {/ Income/ :/ 10000/ }/ 〉/ ,/ 〈/ Ron/ ,/ {/ Income/ :/ 20000/ }/ 〉/ }/ ./ 由该/ 集合/ 对应/ 的/ 用户/ 表/ 主键/ 到/ 用户/ 表中/ 可/ 获得/ 相应/ 的/ 用户/ 数据/ 记录/ ./ 在/ 实现/ 上/ 索引/ 内存/ 缓存/ 层/ 数据/ 存储/ 在/ Redis/ 内存/ 数据库/ 中/ ,/ 并/ 由/ Redis/ 自动/ 完成/ 上述/ 哈希/ 和/ 快速/ 查询/ 过程/ ,/ 这/ 一层/ 全/ 内存/ 化/ 的/ 查询/ 相当/ 高效/ ./ 分层/ 式/ 索引/ 存储/ 模型/ 的/ 查询/ 过程/ 是/ :/ 首先/ 到/ 索引/ 内存/ 缓存/ 层/ 查询/ 热点/ 索引/ 数据/ ,/ 若/ 缓存/ 中/ 没有/ 命中/ ,/ 则/ 将/ 查询/ 转发/ 到/ 索引/ 持久/ 化/ 存储/ 层/ 进行/ 检索/ ./ 可以/ 看出/ ,/ 通过/ 将/ 索引/ 热点/ 数据/ 缓存/ 在/ 内存/ 中/ ,/ 部分/ 查询/ 可以/ 直接/ 在/ 内存/ 中/ 命中/ 结果/ 集/ ,/ 从而/ 降低/ 了/ 磁盘/ 访问/ 开销/ ,/ 提高/ 整体/ 查询/ 性能/ ,/ 这/ 对于/ 具有/ 倾斜/ 的/ 数据/ 访问/ 分布/ 特性/ 的/ 应用/ 来说/ 尤为/ 有效/ ./ 3.3/ 基于/ 一致性/ 哈希/ 的/ 分布式/ 内存/ 缓存/ HiBase/ 利用/ HBase/ 服务器/ 节点/ 上/ 的/ 分布式/ 内存/ 来/ 存储管理/ 所有/ 的/ 索引/ 热点/ 数据/ ./ 我们/ 引入/ 了/ 一致性/ 哈希/ [/ 12/ ]/ 来/ 完成/ 索引/ 热点/ 数据/ 在/ 分布式/ 内存/ 中/ 的/ 存储管理/ ./ 一致性/ 哈希/ 是/ 1997/ 年/ 由/ 麻省理工学院/ 的/ DavidKarger/ 提出/ ,/ 目的/ 是/ 为了/ 修正/ 简单/ 哈希/ 算法/ 在/ 分布式/ 环境/ 中/ 存在/ 的/ 节点/ 更新/ 带来/ 的/ 巨大/ 开销/ 等/ 问题/ ,/ 使得/ 哈希/ 算法/ 可以/ 在/ 分布式/ 环境/ 中/ 真正/ 得到/ 应用/ ./ 一致性/ 哈希/ 在/ 许多/ 分布式系统/ 中/ 得到/ 了/ 广泛/ 的/ 应用/ ,/ 如/ Dynamo/ [/ 4/ ]/ 、/ Cassandra/ [/ 3/ ]/ ./ 一致性/ 哈希/ 为/ HiBase/ 的/ 索引/ 内存/ 缓存/ 层/ 提供/ 了/ 良好/ 的/ 可扩展性/ ./ 索引/ 内存/ 缓存/ 层/ 的/ 可扩展性/ 是/ 指当/ 索引/ 缓存/ 层/ 的/ 内存/ 使用率/ 偏高时/ ,/ 通过/ 加入/ 新/ 的/ 服务/ 节点/ 即/ 能够/ 实现/ 索引/ 缓存/ 层/ 容量/ 的/ 动态/ 增加/ ./ 在/ 动态变化/ 的/ 内存/ 环境/ 中/ ,/ 单调/ 性是/ 可扩展性/ 的/ 可靠保证/ [/ 12/ ]/ ./ 单调/ 性是/ 指/ 如果/ 已经/ 有/ 一些/ 内容/ 通过/ 哈希/ 方法/ 分配/ 到/ 对应/ 节点/ 的/ 缓存/ ,/ 此后/ 又/ 有/ 新/ 的/ 节/ Page6/ 点/ 加入/ 到/ 系统/ 中/ ,/ 那么/ 哈希/ 的/ 结果/ 应/ 能够/ 保证/ 原有/ 已/ 分配/ 的/ 内容/ 要么/ 被/ 映射/ 到/ 新/ 节点/ 的/ 缓存/ 中/ ,/ 要么/ 仍然/ 被/ 映射/ 到/ 原先/ 所在/ 节点/ 的/ 缓存/ 中/ ,/ 以/ 尽量减少/ 数据/ 迁移/ 带来/ 的/ 开销/ ./ 例如/ ,/ 对于/ 最/ 简单/ 的/ 线性/ 哈希/ :/ 其中/ ,/ N/ 表示/ 全部/ 缓存/ 区/ 的/ 个数/ ,/ 在/ 本文/ 的/ 分层/ 式/ 索引/ 系统/ 中即/ 表示/ 索引/ 缓存/ 层/ 的/ 节点/ 数量/ ./ 倘若/ 不/ 使用/ 一致性/ 哈希/ 管理/ 分布式/ 的/ 索引/ 缓存/ ,/ 由于/ 服务/ 进程/ 的/ 加入/ 和/ 退出/ 而/ 使得/ 缓存/ 节点/ 个数/ N/ 发生变化/ 时/ ,/ 原来/ 所有/ 的/ 哈希/ 结果/ 均会/ 发生变化/ ,/ 意味着/ 所有/ 的/ 映射/ 关系/ 需要/ 在/ 系统/ 内/ 全部/ 更新/ ./ 节点/ 的/ 加入/ 和/ 退出/ 将/ 带来/ 极大/ 的/ 计算/ 和/ 传输/ 开销/ ./ 在/ HiBase/ 分布式/ 内存/ 缓存/ 中/ ,/ 使用/ 一致性/ 哈希/ 来/ 确定/ 数据/ 所在/ 的/ 服务器/ 节点/ ./ 一致性/ 哈希/ 的/ 基本原理/ 如下/ :/ 使用/ 某种/ 哈希/ 函数/ 将/ 所有/ 数据/ 映射/ 到/ 圆环/ 边上/ 的/ 某/ 一点/ 上/ (/ 如果/ 使用/ 32/ 位/ 地址/ 空间/ ,/ 那么/ 圆环/ 上/ 总共/ 存在/ 232/ 个点/ )/ ./ 同时/ 使用/ 另/ 一个/ 相同/ 或/ 不同/ 的/ 哈希/ 函数/ 将/ 每个/ 存储/ 节点/ 映射/ 到/ 该/ 圆环/ 边上/ 的/ 伪/ 随机/ 分布/ 点上/ ./ 当/ 查找/ 数据/ 所在/ 的/ 节点/ 时/ ,/ 一致性/ 哈希/ 算法/ 会/ 从/ 圆环/ 上该/ 数据/ 的/ 映射/ 点/ 开始/ ,/ 沿/ 顺时钟/ 方向/ 进行/ 搜索/ ,/ 找到/ 的/ 第/ 1/ 个/ 存储/ 节点/ 即/ 为/ 数据/ 所在/ 的/ 节点/ ./ 在/ 节点/ 发生变化/ 时/ (/ 如/ 节点/ 失效/ 或/ 节点/ 加入/ )/ ,/ 只有/ 和/ 变化/ 节点/ 相邻/ 的/ 节点/ 数据/ 需要/ 迁移/ ,/ 从而/ 可/ 减少/ 节点/ 的/ 加入/ 和/ 退出/ 带来/ 的/ 计算/ 和/ 数据传输/ 的/ 开销/ ./ 例如/ ,/ 当图/ 4/ (/ a/ )/ 中/ 存储/ 节点/ 2/ 出现/ 故障/ 时/ ,/ 原先/ 映射/ 到/ 该/ 节点/ 的/ 数据/ 会/ 映射/ 到/ 顺时钟/ 图/ 4/ 基于/ 一致性/ 哈希/ 的/ 分布式/ 索引/ 内存/ 缓存/ 存储/ 机制/ 方向/ 遇到/ 的/ 第/ 1/ 个/ 存储/ 节点/ 上/ ,/ 如图/ 4/ (/ b/ )/ 所示/ 部分/ 数据/ 被/ 重新/ 映射/ 到/ 存储/ 节点/ 3/ ./ 而/ 增加/ 存储/ 节点/ 的/ 时候/ ,/ 数据/ 映射/ 关系/ 的/ 变化/ 与/ 上述/ 的/ 过程/ 正好/ 相反/ ,/ 新/ 节点/ 将会/ 负责管理/ 其/ 哈希/ 地址/ 到/ 它/ 逆时针/ 方向/ 上/ 第一个/ 存储/ 节点/ 之间/ 的/ 所有/ 数据/ ./ 可以/ 看出/ ,/ 当/ 存储/ 节点/ 发生变化/ 时/ ,/ 只/ 需要/ 迁移/ 小/ 部分/ 的/ 数据/ 即可/ ./ 而且/ 通过/ 将/ 存储/ 节点/ 映射/ 到/ 圆环/ 的/ 伪/ 随机/ 分布/ 点上/ ,/ 能够/ 有效/ 地/ 保证/ 各/ 存储/ 节点/ 之间/ 的/ 负载/ 均衡/ ./ HiBase/ 的/ 内存/ 缓存/ 需要/ 通过/ 两次/ 哈希/ 来/ 找到/ 对应/ 索引/ 记录/ 的/ 真实/ 位置/ :/ 第/ 1/ 次/ 通过/ 图/ 4/ 所示/ 的/ 一致性/ 哈希/ 找到/ 索引/ 数据/ 所在/ 的/ 服务器/ 节点/ ;/ 第/ 2/ 次则/ 通过/ Redis/ 的/ 哈希/ 机制/ 找到/ 节点/ 内/ 的/ 索引/ 数据/ 地址/ ./ 3.4/ 支持/ 基于/ 内存/ 缓存/ 范围/ 查询/ 的/ 值表/ HiBase/ 在/ 索引/ 持久/ 化/ 存储/ 层中/ 存储/ 值表/ ,/ 用来/ 有序/ 地/ 记录/ 和/ 存储/ 索引/ 属性/ 所有/ 取值/ 的/ 集合/ ,/ 以/ 支持/ 高效/ 的/ 基于/ 索引/ 内存/ 缓存/ 的/ 范围/ 查询/ ,/ 如图/ 5/ (/ a/ )/ 所示/ ./ 通常/ 情况/ 下/ ,/ 一个/ 索引/ 属性/ 值/ 经常/ 会/ 对应/ 多条/ 用户/ 表/ 记录/ ./ 在/ 持久/ 化/ 存储/ 层/ 的/ 索引/ 表中/ ,/ HiBase/ 在/ 索引/ 表/ 主键/ 中/ 加入/ 用户/ 表/ 主键/ 以/ 维护/ 其/ 唯一性/ (/ 如/ 3.1/ 节/ 所示/ )/ ./ 在/ 值表中/ ,/ 我们/ 只/ 保存/ 索引/ 列值/ ,/ 因此/ 值表/ 的/ 记录/ 条数/ 会/ 比/ 用户/ 表/ 小得多/ ./ 用户/ 对/ 分层/ 式/ 索引/ 存储系统/ 进行/ 范围/ 查询/ 时/ ,/ 值表会/ 被/ 频繁/ 访问/ ,/ 因此/ 值表会/ 被/ 底层/ 文件系统/ 缓存/ 在/ 内存/ 中/ ,/ 可以/ 大大提高/ 值表/ 的/ 查询/ 效率/ ./ 这个/ 缓存/ 由/ 文件系统/ 管理/ ./ 当/ 索引/ 列/ 的/ 基数/ (/ 即/ 索引/ 列/ 取值/ 的/ 实例/ 个数/ )/ 不大时/ ,/ 上述/ 机制/ 保证/ 值表能/ 有效/ 地/ 工作/ ./ 当/ 索引/ 列/ 取值/ 很多/ 或/ 无限/ 多/ (/ 比如/ 取值/ 为/ 范围/ 变化/ 大/ 的/ 整数/ 、/ 字/ Page7/ 符串/ 或/ 浮点数/ )/ 时/ ,/ 值表会/ 带来/ 大量/ 的/ 空间/ 开销/ ./ 因此/ 我们/ 提出/ 粒度/ 值表/ 优化/ 方案/ :/ 将/ 索引/ 列/ 取值/ 进行/ 粒度/ 分段/ ,/ 每个/ 分段/ 范围/ 内/ 的/ 多个/ 索引/ 列值/ 对应/ 一条/ 值表/ 记录/ ,/ 如图/ 5/ (/ b/ )/ 所示/ ./ HiBase/ 将/ 一条/ 值表/ 记录/ 对应/ 的/ 索引/ 列/ 取值/ 范围/ 内/ 的/ 索引/ 记录/ 存储/ 在/ 同一个/ 内存/ 缓存/ 索引/ 集合/ (/ 如/ 3.2/ 节/ 所述/ 的/ 内存/ 缓存/ 索引/ 结构/ )/ 中/ ./ 因此/ ,/ 采用/ 粒度/ 值表/ 优化/ 方案/ 后/ ,/ 仍然/ 是/ 一条/ 值表/ 记录/ 对应/ 一个/ Redis/ 集合/ ./ HiBase/ 在/ 处理/ 范围/ 查询/ 时/ ,/ 首先/ 会/ 查询/ 值表/ ,/ 得到/ 落/ 在/ 查询/ 范围/ 内/ 、/ 满足/ 查询/ 条件/ 的/ 所有/ 值表/ 记录/ ./ 然后/ 以值表/ 记录/ 值为/ 请求/ 发起/ 批量/ 的/ 单值/ 查询/ ,/ 并/ 汇总/ 查询/ 结果/ ./ 如前所述/ ,/ 粒度/ 值表/ 优化/ 方案/ 中/ 仍然/ 是/ 一条/ 值表/ 记录/ 对应/ 一个/ Redis/ 集合/ ,/ 因此/ 不/ 影响/ 范围/ 查询/ 过程/ ./ 只是/ 查询/ 结果/ 可能/ 是/ Redis/ 集合/ 的/ 部分/ 子集/ ,/ 需要/ 过滤/ 筛选/ ./ 依赖于/ Redis/ 高效/ 的/ 查询/ 机制/ ,/ 以及/ 可/ 配置/ 的/ 值表/ 粒度/ ,/ 过滤/ 筛选/ 是/ 非常/ 高效/ 的/ ./ 详细/ 的/ 查询/ 执行/ 过程/ 见/ 5.3/ 节/ 数据/ 查询/ 过程/ 中/ 的/ 范围/ 查询/ ./ 4/ 索引/ 热点/ 数据/ 缓存/ 替换/ 策略/ 缓存/ 是/ 数据/ 查询/ 优化/ 常用/ 和/ 行之有效/ 的/ 方法/ ,/ 缓存/ 技术/ 一直/ 是/ 数据/ 存储/ 和/ 查询/ 的/ 研究/ 热点/ ,/ 通过/ 将/ 部分/ 数据/ 保存/ 在/ 内存/ 中/ ,/ 可以/ 提高/ 随后/ 对/ 数据/ 重复/ 访问/ 的/ 效率/ ./ 通常/ 缓存/ 的/ 容量/ 远远/ 小于/ 保存/ 全部/ 数据/ 的/ 磁盘/ 数据库/ 的/ 容量/ ,/ 所以/ 当/ 缓存/ 满/ 了/ 之后/ 需要/ 选择/ 合适/ 的/ 牺牲者/ 淘汰/ 出/ 缓存/ ,/ 这/ 就是/ 缓存/ 替换/ 策略/ ./ HBase/ 也/ 有/ 自己/ 的/ 缓存/ 策略/ ,/ 即/ HBase/ 的/ 块/ 缓存/ (/ BlockCache/ )/ ./ HBase/ 在/ 读数据/ 时会/ 以块/ (/ Block/ )/ 为/ 单位/ 进行/ 缓存/ ,/ 用来/ 提升/ 读/ 性能/ ,/ 块/ 的/ 默认/ 大小/ 是/ 64KB/ ./ 读/ 请求/ 先到/ 写/ 缓存/ (/ MemStore/ )/ 中/ 查询/ ,/ 查询/ 失败/ 则/ 继续/ 到/ 块/ 缓存/ 中/ 查询/ ,/ 再/ 查询/ 失败/ 就/ 会/ 到/ 磁盘/ 上/ 的/ HBase/ 表中/ 读取/ ,/ 同时/ 会/ 把/ 读取/ 的/ 结果/ 放入/ 块/ 缓存/ ./ 在/ 配置文件/ 中/ 会/ 指定/ 块/ 缓存/ 的/ 容量/ ,/ 当块/ 缓存/ 的/ 容量/ 已经/ 被/ 使用/ 85/ %/ 以上/ 的/ 时候/ 开始/ 采用/ 缓存/ 替换/ 策略/ 淘汰/ 数据/ ,/ 淘汰/ 过程/ 在/ 块/ 缓存/ 容量/ 占用/ 比为/ 75/ %/ 的/ 时候/ 停止/ ./ 然而/ ,/ HBase/ 的/ 缓存/ 策略/ 是/ 面向/ 系统/ 的/ 读写/ 性能/ 提升/ 的/ ,/ 而/ 不是/ 面向/ 特定/ 的/ 数据表/ 的/ ./ HBase/ 采用/ 的/ 是/ 最近/ 最少/ 使用/ (/ LeastRecentlyUsed/ )/ 的/ 缓存/ 替换/ 策略/ 来/ 淘汰/ 块/ ./ LRU/ 算法/ 是/ 基于/ 如下/ 假定/ :/ 最近/ 被/ 访问/ 的/ 数据/ 在/ 近期/ 最有/ 可能/ 被/ 重复/ 访问/ ,/ 而/ 如果/ 数据/ 很/ 长时间/ 未/ 被/ 使用/ ,/ 则/ 在/ 最近/ 的/ 未来/ 被/ 访问/ 的/ 概率/ 很/ 低/ ./ LRU/ 算法/ 只/ 关注/ 数据项/ 最近/ 一次/ 访问/ 时间/ 的/ 差异/ ,/ 没有/ 关注/ 数据项/ 访问/ 的/ 频繁/ 程度/ 不同/ ,/ 也就是说/ ,/ LRU/ 算法/ 没有/ 考虑/ 数据/ 的/ 累积/ 热度/ ./ 4.1/ HiBase/ 索引/ 热点/ 数据/ 缓存/ 基本/ 思想/ 在/ HiBase/ 中/ ,/ 我们/ 提出/ 了/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ ./ 它/ 基于/ 与/ LRU/ 算法/ 相同/ 的/ 假设/ :/ 最近/ 被/ 访问/ 的/ 数据/ 在/ 最近/ 的/ 未来/ 最有/ 可能/ 被/ 重复/ 访问/ ./ 其/ 基本/ 设计/ 思想/ 是/ 周期性地/ 累积/ 缓存/ 索引/ 集合/ 被/ 访问/ 的/ 次数/ ,/ 并/ 将/ 访问/ 次数/ 周期性地/ 累积/ 成/ 热度/ 保存/ 在/ 缓存/ 元/ 数据/ 中/ ./ 进而/ ,/ 对/ 所有/ 记录/ 的/ 累积/ 热度/ 排序/ ,/ 选择/ 累积/ 热度/ TOP/ -/ K/ 的/ 索引/ 记录/ 缓存/ 到/ 内存/ 中/ ,/ 这/ 就是/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ ./ 图/ 6/ 给出/ 了/ HiBase/ 的/ 分层/ 式/ 数据/ 存储/ 结构/ ./ 用户/ 表/ 、/ 索引/ 表和值表/ 全部/ 存储/ 在/ 基于/ HBase/ 的/ 索引/ 持久/ 化/ 存储/ 层中/ ./ 在/ 内存/ 缓存/ 中/ ,/ 我们/ 保存/ 索引/ 热点/ 数据/ ./ 索引/ 缓存/ 存储/ 结构/ 是/ 基于/ Redis/ 的/ 集合/ (/ Set/ )/ ,/ RedisSet/ 也/ 是/ 以/ 〈/ key/ ,/ value/ 〉/ 格式/ 来/ 组织/ 数据/ ./ 热点/ 数据/ 的/ 索引/ 主键/ (/ 如/ 3.2/ 节/ 描述/ )/ 做/ RedisSet/ 的/ key/ ,/ 而/ 索引/ 集合/ (/ 如/ 3.2/ 节/ 描述/ )/ 作为/ RedisSet/ 的/ value/ 保存/ 在/ 内存/ 缓存/ 中/ ./ 显然/ ,/ 具有/ 相同/ 索引/ 列值/ 的/ 记录/ 被/ 绑定/ 在/ 同一个/ 集合/ 中/ ,/ 基于/ 索引/ 列值/ 的/ 查询/ 命中/ 是/ 以/ 集合/ 为/ 单位/ 的/ ./ 同时/ ,/ 它们/ 也/ 是/ 热度/ 累积/ 的/ 基本/ 单位/ ,/ 每个/ 集合/ 都/ 会/ 累积/ 它/ 在/ 一个/ 计算/ 周期/ 内/ 的/ 访问/ 次数/ ./ 4.2/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ 在/ HiBase/ 中/ ,/ 热度/ 累积/ 缓存/ 替换/ 策略/ 的/ 热度/ Page8/ 计算公式/ 如下/ :/ scoren/ =/ α/ ×/ 其中/ 0/ / α/ / 1/ ./ 式/ 中/ 的/ countPeriod/ 即/ 热度/ 计算/ 周期/ ,/ visitCount/ 指/ 当前/ 热度/ 计算/ 周期/ 中/ ,/ 该/ 索引/ 集合/ 被/ 访问/ 的/ 次数/ ./ 历史/ 热度/ scoren/ -/ 1/ 则/ 反映/ 集合/ 累积/ 的/ 历史/ 热度/ ./ 参数/ α/ 是/ 衰减系数/ ,/ 用来/ 确定/ 当前/ 周期/ 累积/ 的/ 热度/ 和/ 历史/ 热度/ 在/ scoren/ 中/ 各自/ 所/ 占/ 的/ 权重/ ./ α/ 越大/ ,/ 则/ 最近/ 的/ 访问/ 在/ 数据/ 访问/ 热度/ 中所/ 占/ 的/ 权重/ 越大/ ,/ 历史/ 访问/ 记录/ 对/ 数据/ 热度/ 的/ 影响/ 越小/ ,/ 反之亦然/ ./ 集合/ 的/ 历史/ 热度/ 在/ 本/ 计算/ 周期/ 内以/ 系数/ (/ 1/ -/ α/ )/ 的/ 速率/ 衰减/ ,/ 经过/ 多次/ 迭代/ ,/ 更/ 早/ 计算/ 周期/ 的/ 累积/ 热度/ 经过/ 了/ 更/ 多次/ 衰减/ ,/ 所以/ 早期/ 的/ 累积/ 热度/ 对/ 数据/ 热度/ 的/ 影响/ 不断/ 降低/ ./ 为了/ 降低/ 热度/ 计算/ 带来/ 的/ 计算/ 和/ 更新/ 开销/ ,/ 在/ 执行/ 查询/ 请求/ 时/ ,/ 内存/ 缓存/ 的/ 服务/ 进程/ 将会/ 对/ 访问/ 到/ 的/ 每条/ 索引/ 数据/ 记录本/ 周期/ 内/ 的/ 访问/ 次数/ ,/ 此时/ 并/ 不/ 对/ 内存/ 缓存/ 的/ 数据/ 进行/ 替换/ ./ 直到/ 查询/ 请求/ 次数/ 达到/ countPeriod/ ,/ 即/ 到达/ 热度/ 计算/ 周期/ 时/ ,/ 服务/ 进程/ 触发/ 缓存/ 的/ 更新/ 替换/ ./ 按照/ 热度/ 累积/ 公式/ 对/ 所有/ 的/ 记录/ 计算/ 热度/ ,/ 根据/ 热度/ 排序/ ,/ 将/ 热度/ 排序/ TOP/ -/ K/ 的/ 集合/ 记录/ 缓存/ 到/ 内存/ 中/ ,/ 集合/ 中/ 包含/ 的/ 记录/ 条数/ 是/ 不/ 固定/ 的/ ,/ 所以/ 选择/ TOP/ -/ K/ 时/ ,/ 根据/ 缓存/ 空间/ 能够/ 容纳/ 的/ 记录/ 条数/ 限制/ 计算/ 出/ 热度/ 门限/ ,/ 高于/ 门限/ 的/ 集合/ 被/ 缓存/ 到/ 内存/ 中/ ./ 然而/ ,/ 在/ 系统/ 初始/ 阶段/ ,/ 缓存/ 是/ 大量/ 空闲/ 的/ ./ LRU/ 算法/ 在/ 系统/ 初始/ 阶段/ 的/ 命中率/ 提升/ 很快/ ,/ 这是/ 由于/ LRU/ 算法/ 中/ 数据/ 记录/ 是/ 访问/ 即/ 插入/ 缓存/ ,/ 最长/ 时间/ 没有/ 被/ 访问/ 的/ 数据/ 记录/ 会/ 在/ 缓存/ 充满/ 后/ 被/ 淘汰/ ./ 所以/ LRU/ 可以/ 快速/ 地/ 进入/ 稳定/ 状态/ ./ 而/ 热度/ 累积/ 的/ 访问/ 如果/ 在/ 系统/ 初始/ 阶段/ 通过/ 周期性地/ 计算/ 热度/ ,/ 等/ 被/ 访问/ 数据/ 记录/ 的/ 热度/ 累积到/ 门/ 限时/ 才/ 可以/ 插入/ 缓存/ 的话/ ,/ 那么/ 初始/ 预热/ 阶段/ 的/ 缓存/ 利用率/ 低/ ./ 所以/ 我们/ 的/ 热度/ 累积/ 算法/ 在/ 缓存/ 空闲/ 阶段/ 做/ 了/ 优化/ ,/ 只要/ 缓存/ 有/ 空闲/ ,/ 我们/ 就/ 采用/ “/ 访问/ 即/ 插入/ ”/ 的/ 策略/ ,/ 将/ 所有/ 访问/ 到/ 的/ 记录/ 都/ 插入/ 缓存/ ./ 而/ 当/ 缓存/ 充满/ 以后/ ,/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ 根据/ 记录/ 的/ 热度/ 累积/ 评分/ 选择/ “/ 牺牲者/ ”/ 淘汰/ 出/ 内存/ ,/ 选择/ 获得/ 热度/ 高分/ 的/ 记录/ 保存/ 在/ 缓存/ 中/ ./ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ 不仅/ 考虑/ 了/ 数据/ 的/ 访问/ 时间/ 远近/ ,/ 同时/ 考虑/ 了/ 数据/ 的/ 访问/ 频率/ ,/ 所以/ 比/ LRU/ 更/ 准确/ ./ 从/ 实验/ 结果/ 看出/ ,/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ 明显/ 优于/ LRU/ 算法/ ,/ 和/ 不/ 使用/ 内存/ 缓存/ 策略/ 相比/ ,/ 可以/ 提升/ 5/ ~/ 15/ 倍/ 的/ 查询/ 性能/ ./ 5HiBase/ 的/ 系统/ 设计/ 与/ 实现/ 5.1/ 系统/ 总体/ 架构/ 基于/ 以上/ 的/ 非/ 主键/ 索引/ 模型/ 和/ 技术/ 方法/ ,/ 我们/ 设计/ 并/ 实现/ 了/ 一个/ 基于/ HBase/ 的/ 分层/ 式/ 非/ 主键/ 索引/ 查询/ 系统/ HiBase/ ,/ 该/ 系统/ 实现/ 了/ 基于/ HBase/ 的/ 持久/ 化/ 索引/ 存储/ ,/ 基于/ 内存/ 的/ 索引/ 热点/ 数据/ 缓存/ ,/ 以及/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ ./ HiBase/ 提供/ 了/ 基于/ 分层/ 式/ 非/ 主键/ 索引/ 的/ 数据/ 查询方法/ ,/ 并/ 对/ 范围/ 查询/ 进行/ 了/ 并行/ 化/ 优化/ ./ HiBase/ 将/ 整个/ 分层/ 式/ 索引/ 存储系统/ 划分/ 为/ 以下/ 几个/ 模块/ ,/ 系统/ 功能模块/ 划分/ 如图/ 7/ 所示/ ./ (/ 1/ )/ 索引/ 构建/ 管理/ 模块/ ./ 管理/ 索引/ 的/ 元/ 数据/ (/ 记录/ 用户/ 表/ 对应/ 的/ 索引/ 表/ 名称/ 、/ 索引/ 列/ 等/ 信息/ )/ ,/ 并/ 实现/ 针对/ HBase/ 的/ 流式/ 数据/ 和/ 静态数据/ 两种/ 不同/ 特性/ 数据/ 的/ 索引/ 构建/ 方法/ ,/ 包括/ 支持/ 索引/ 表和值表/ 的/ 插入/ 、/ 删除/ 、/ 更新/ 操作/ ./ (/ 2/ )/ 持久/ 化/ 存储管理/ 模块/ ./ 提供/ 索引/ 表和值表/ 的/ 持久/ 化/ 存储/ ,/ HBase/ 为/ 持久/ 化/ 存储/ 数据/ 提供/ 可扩展性/ 和/ 容错性/ ./ (/ 3/ )/ 索引/ 内存/ 缓存/ 模块/ ./ 管理/ 索引/ 热点/ 数据/ 的/ 缓存/ 存储/ 、/ 更新/ 和/ 地址映射/ ,/ 实现/ 热度/ 累积/ 缓存/ 替换/ 策略/ ,/ 使得/ 最近/ 频繁/ 访问/ 的/ 数据/ 能/ 缓存/ 到/ 内存/ 中/ ./ (/ 4/ )/ 查询/ 执行/ 引擎/ ./ 将/ 用户/ 的/ 查询/ 请求/ 翻译成/ 系统/ 识别/ 的/ 命令/ ,/ 调用/ 对应/ 的/ 方法/ 执行/ 查询/ ,/ 并/ 将/ 查/ Page9/ 询/ 结果/ 汇总/ 返回/ 给/ 客户端/ ./ 为了/ 提供/ 索引/ 内存/ 缓存/ 的/ 高可用性/ ,/ HiBase/ 使用/ 了/ Hadoop/ 环境/ 中/ 的/ 分布式/ 协调/ 管理系统/ ZooKeeper/ 来/ 可靠/ 地/ 检测/ 分布式/ 内存/ 节点/ 上/ 服务/ 进程/ 的/ 存活/ 状态/ ./ 索引/ 内存/ 缓存/ 层/ 每个/ 内存/ 节点/ 服务/ 进程/ 会/ 分别/ 建立/ 与/ ZooKeeper/ 的/ 会/ 话/ ,/ 并/ 创建/ 临时/ Znode/ 来/ 表示/ 自身/ 的/ 存活/ 状态/ ./ 每个/ 内存/ 节点/ 服务/ 进程/ 从/ ZooKeeper/ 系统/ 镜像/ 中/ 可以/ 观察/ 到/ 其他/ 节点/ 进程/ 的/ 存活/ 状态/ ./ 系统/ 通过/ 对/ 分布/ 内存/ 节点/ 状态/ 的/ 监测/ 实现/ 内存/ 节点/ 的/ 失效/ 检测/ 和/ 上线/ 处理/ ,/ 从而/ 实现/ 索引/ 内存/ 缓存/ 层/ 的/ 高可用性/ ./ 5.2/ 索引/ 构建/ 过程/ 根据/ 数据/ 输入/ 方式/ 的/ 不同/ ,/ 索引/ 构建/ 可/ 分为/ 面向/ 流式/ 数据/ 和/ 面向/ 批处理/ 数据/ 的/ 索引/ 构建/ ./ 索引/ 构建/ 过程/ 都/ 是/ 读取/ 用户/ 表/ 的/ 一条/ 记录/ ,/ 在/ 非/ 主键/ 属性/ 上/ 生成/ 一条/ 索引/ 记录/ ,/ 如果/ 满足/ 缓存/ 条件/ ,/ 同时/ 生成/ 内存/ 缓存/ 层/ 的/ 索引/ 数据/ ./ 最后/ 将/ 索引/ 数据/ 分别/ 更新/ 到/ 持久/ 化/ 存储/ 层/ 与/ 内存/ 缓存/ 层/ ,/ 并/ 更新/ 值表/ ./ 对于/ 流式/ 数据/ 索引/ 构建/ 方法/ ,/ HiBase/ 利用/ Observer/ 类型/ 的/ Coprocessor/ 来/ 构建/ 相关/ 的/ 索引/ ./ 具体来说/ 是/ 使用/ HBase/ 提供/ 的/ RegionObserver/ 接口/ 的/ 回调/ 函数/ prePut/ ,/ 插入/ 一条/ 数据/ 之前/ 会/ 被/ 触发/ 调用/ ./ prePut/ 方法/ 首先/ 根据/ 索引/ 信息/ 对/ 用户/ 发起/ 的/ Put/ 操作/ 进行/ 分析/ ,/ 如果/ Put/ 操作/ 的/ 数据/ 包含/ 有/ 索引/ 列/ ,/ 即/ 包含/ 要/ 索引/ 的/ 数据/ ,/ 则/ 触发/ 索引/ 数据/ 的/ 插入/ ./ 由于/ 静态数据/ 一般/ 相对/ 较大/ ,/ 为了/ 能够/ 加快/ 静态数据/ 索引/ 的/ 构建/ 速度/ ,/ 本文/ 利用/ HadoopMapReduce/ 来/ 并行/ 化/ 执行/ 静态数据/ 索引/ 构建/ ./ MapReduce/ 任务/ 首先/ 得到/ 输入/ 〈/ Row/ ,/ Result/ 〉/ ,/ 其中/ Row/ 为/ 用户/ 表/ 的/ 行键/ ,/ Result/ 是/ 通过/ Row/ 获得/ 的/ HBase/ 记录/ ./ 然后/ 根据/ 索引/ 信息/ 生成/ 其/ 对应/ 的/ 索引/ 数据/ ,/ 并/ 将/ 索引/ 数据/ 插入/ 到/ 分层/ 式/ 索引/ 中/ ./ 整个/ 过程/ 不/ 需要/ Reduce/ 阶段/ 即可/ 完成/ ,/ 同时/ 由于/ HBase/ 用户/ 表/ 记录/ 之间/ 是/ 相互/ 独立/ 的/ ,/ 所以/ 可以/ 充分利用/ MapReduce/ 提供/ 的/ 并行/ 化/ 处理/ 能力/ 来/ 加速/ 索引/ 构建/ 过程/ ./ 5.3/ 数据/ 查询/ 过程/ (/ 1/ )/ 单值/ 查询/ HiBase/ 通过/ 建立/ 非/ 主键/ 属性/ 上/ 的/ 索引/ ,/ 支持/ 高效/ 的/ 非/ 主键/ 列上/ 的/ 单值/ 查询/ (/ pointquery/ )/ 和/ 范围/ 查询/ (/ rangequery/ )/ ./ 本文/ 所说/ 的/ 单值/ 查询/ ,/ 即/ 查询/ 请求/ 中/ 条件/ 属性/ 被/ 限定/ 取值/ 唯一/ 的/ 查询/ ./ 例如/ ,/ 对于/ 图/ 1/ 中/ 给出/ 的/ 实例/ ,/ 查询/ 年龄/ 为/ 30/ 岁/ 的/ 所有/ 记录/ ./ 对于/ 单值/ 查询/ ,/ 客户端/ 的/ 基本/ 流程/ 如下/ :/ ①/ 从/ 配置文件/ 获取/ ZooKeeper/ 的/ 地址/ ,/ 建立/ 与/ ZooKeeper/ 的/ 连接/ ,/ 获取/ 注册/ 的/ 所有/ 服务/ 进程/ ,/ 确定/ 当前/ 提供/ 内存/ 缓存/ 的/ 所有/ 服务/ 进程/ 的/ 位置/ 信息/ ./ ②/ 向/ 内存/ 缓存/ 层/ 的/ 服务/ 进程/ 发起/ 查询/ 请求/ ./ 若/ 内存/ 缓存/ 层/ 命中/ ,/ 则/ 返回/ 内存/ 缓存/ 层/ 给出/ 的/ 结果/ ,/ 结束/ 查询/ ./ ③/ 若/ 内存/ 缓存/ 层/ 未/ 命中/ ,/ 则/ 向/ HBase/ 的/ 索引/ 表/ 发起/ 查询/ 请求/ ./ 获取/ 结果/ 后/ ,/ 返回/ 查询/ 得到/ 的/ 结果/ ,/ 结束/ 查询/ ./ 可以/ 看出/ ,/ 如果/ 在/ 内存/ 缓存/ 层/ 命中/ ,/ 整个/ 查询/ 流程/ 都/ 不会/ 访问/ 到/ 磁盘/ ,/ 减少/ 了/ 磁盘/ 访问/ 开销/ ,/ 能够/ 大幅度提高/ 响应速度/ ./ 另外/ ,/ 对/ ZooKeeper/ 访问/ 获取/ 的/ 内存/ 缓存/ 层/ 服务/ 进程/ 信息/ 会/ 被/ 缓存/ 在/ 客户端/ ,/ 在/ 后续/ 的/ 访问/ 中/ 会/ 进一步/ 减少/ 数据/ 查询/ 的/ 通信/ 开销/ ./ (/ 2/ )/ 范围/ 查询/ 本文/ 所说/ 的/ 范围/ 查询/ ,/ 即/ 查询/ 请求/ 中/ 条件/ 属性/ 的/ 取值/ 是/ 范围/ 的/ 查询/ ./ 例如/ ,/ 对于/ 图/ 1/ 中/ 给出/ 的/ 示例/ ,/ 查询/ 年龄/ 在/ 15/ ~/ 35/ 岁/ 的/ 所有/ 记录/ ./ 对于/ 范围/ 查询/ ,/ 内存/ 缓存/ 层/ 通过/ 一致性/ 哈希/ 的/ 方法/ 将/ 数据分布/ 到/ 各个/ 存储/ 节点/ 上来/ 提高/ 查询/ 性能/ ,/ 而/ 哈希/ 破坏/ 了/ 索引/ 列/ 的/ 有序性/ ,/ 所以/ 我们/ 需要/ 记录/ 索引/ 表/ 主键/ 的/ 所有/ 取值/ ,/ 保存/ 在/ 值表中/ ./ 通过/ 该值表/ ,/ 我们/ 可以/ 获得/ 索引/ 主键/ 某个/ 范围/ 内/ 所有/ 存在/ 的/ 列值/ ./ 对于/ 范围/ 查询/ ,/ 客户端/ 的/ 基本/ 流程/ 如下/ :/ ①/ 从/ 配置文件/ 获取/ ZooKeeper/ 的/ 地址/ ,/ 建立/ 与/ ZooKeeper/ 的/ 连接/ ,/ 获取/ 注册/ 的/ 所有/ 服务/ 进程/ ,/ 确定/ 当前/ 提供/ 内存/ 缓存/ 的/ 所有/ 服务/ 进程/ 位置/ 信息/ ./ ②/ 从/ HBase/ 中/ 的/ 值表/ 获取/ 查询/ 范围/ 内/ 所有/ 的/ 查询/ 列值/ ./ ③/ 依次/ 发起/ 单值/ 查询/ 请求/ ./ 将/ 查询/ 结果/ 汇总/ 并/ 返回/ ./ 为了/ 进一步/ 提升/ 查询/ 效率/ ,/ HiBase/ 对/ 范围/ 查询/ 进行/ 如下/ 的/ 优化/ 和/ 改进/ :/ (/ i/ )/ 如果/ 范围/ 查询/ 中/ 的/ 某些/ 索引/ 主键/ 列值/ 是/ 由/ 同一/ 节点/ 管理/ 的/ ,/ 则/ 将/ 这些/ 列值/ 汇总/ ,/ 然后/ 向/ 该/ 节点/ 发起/ 一次/ 批量/ 查询/ 请求/ ;/ (/ ii/ )/ 向/ 范围/ 查询/ 涉及/ 到/ 的/ 多个/ 节点/ 并发/ 地/ 发起/ 查询/ 请求/ ;/ (/ iii/ )/ 当/ 索引/ 缓存/ 层/ 的/ 数据/ 未/ 命中/ 时/ ,/ 节点/ 上/ 的/ 内存/ 索引/ 服务/ 进程/ 并/ 不/ 返回/ 未/ 命中/ 标志/ ,/ 而是/ 将/ 查询/ 请求/ 转发给/ 基于/ HBase/ 的/ 持久/ 存储/ 层/ ,/ 并/ 将/ 持久/ 存储/ 层/ 的/ 查询/ 结果/ 返回/ 给/ 客户端/ ./ 优化/ 的/ 范围/ 查询/ 具体/ 流程/ 如下/ :/ ①/ 从/ 配置文件/ 获取/ ZooKeeper/ 的/ 地址/ ,/ 建立/ 与/ ZooKeeper/ 的/ 连接/ ,/ 获取/ 注册/ 的/ 所有/ 服务/ 进程/ ,/ 确定/ 当前/ 提供/ 内存/ 缓存/ 的/ 所有/ 服务/ 进程/ 位置/ 信息/ ./ Page10/ ②/ 根据/ 范围/ 查询/ 的/ 条件/ ,/ 客户端/ 从/ HBase/ 值表中/ 获取/ 范围/ 之间/ 存在/ 的/ 所有/ 索引/ 列值/ ./ ③/ 对于/ 所有/ 存在/ 的/ 索引/ 列值/ ,/ 根据/ 一致性/ 哈希/ 算法/ 计算/ 出/ 存储/ 节点/ 地址/ ,/ 从而/ 将/ 所有/ 存在/ 的/ 索引/ 列值/ 与/ 相关/ 的/ 节点/ 地址/ 一一对应/ 起来/ ./ ④/ 并发/ 地/ 对/ 相关/ 节点/ 发起/ 查询/ 请求/ ,/ 其中/ ,/ 对/ 同一/ 节点/ 发起/ 的/ 多个/ 查询/ 请求/ 将会/ 合并/ 成/ 一个/ 批量/ 请求/ ./ ⑤/ 各/ 节点/ 上/ 的/ 内存/ 索引/ 服务/ 进程/ 对/ 查询/ 请求/ 进行/ 响应/ ,/ 如果/ 查询/ 的/ 内容/ 在/ 内存/ 中/ ,/ 则/ 直接/ 返回/ 内存/ 中/ 的/ 数据/ ;/ 否则/ ,/ 服务/ 进程/ 将/ 发起/ 对/ 持久/ 存储/ 层/ 的/ 查询/ ,/ 并/ 返回/ 查询/ 结果/ ./ ⑥/ 客户端/ 汇总/ 从/ 各/ 服务/ 节点/ 返回/ 的/ 查询/ 结果/ ./ 下面/ 给出/ 一个/ 范围/ 查询/ 的/ 实例/ :/ 查询/ 年龄/ 在/ 15/ ~/ 35/ 岁/ 的/ 所有/ 记录/ ,/ 来/ 完整/ 地/ 描述/ 整个/ 基于/ 分层/ 式/ 索引/ 的/ 范围/ 查询/ 流程/ ,/ 查询/ 过程/ 如图/ 8/ 所示/ ./ ①/ 图/ 8/ (/ a/ )/ 是/ 客户端/ 根据/ 查询/ 条件/ 向值表/ 发起/ 查询/ 的/ 过程/ ./ 首先/ 客户端/ 发起/ 值表/ 查询/ ,/ HBase/ 返回值/ 表中/ 存在/ 的/ 满足/ 查询/ 条件/ 的/ 3/ 个/ 索引/ 列值/ ,/ 表明/ 用户/ 表/ 的/ 年龄/ 属性/ 列中/ 在/ 15/ ~/ 35/ 之间/ 的/ 值/ 有/ 21/ 与/ 30/ ./ ②/ 客户端/ 根据/ 一致性/ 哈希/ 算法/ 计算/ 返回/ 的/ 索引/ 列值/ 与/ 索引/ 缓存/ 层中/ 节点/ 之间/ 的/ 映射/ 关系/ ,/ 如图/ 8/ (/ b/ )/ 所示/ ,/ 21/ 映射/ 到/ 内存/ 索引/ 服务/ 进程/ 存储/ 2/ 上/ ,/ 30/ 映射/ 到/ 内存/ 索引/ 服务/ 进程/ 存储/ 3/ 上/ ./ ③/ 客户端/ 并发/ 地向/ 服务/ 进程/ 存储/ 2/ 与/ 存储/ 3/ 发起/ 查询/ ./ 如图/ 8/ (/ c/ )/ 所示/ ,/ 客户端/ 同时/ 向/ 存储/ 2/ 与/ 存储/ 3/ 发起/ 了/ 对/ 21/ 与/ 30/ 的/ 查询/ ./ 在/ 存储/ 3/ 中/ ,/ 内存/ 缓存/ 直接/ 命中/ “/ a/ ,/ 30/ ”/ ,/ 于是/ 直接/ 返回/ 结果/ ./ 而/ 在/ 存储/ 2/ 中/ ,/ 内存/ 缓存/ 并未/ 存储/ 索引/ 记录/ “/ a/ ,/ 21/ ”/ ,/ 此时/ 存储/ 2/ 将/ 此/ 查询/ 请求/ 转发/ 到/ 基于/ HBase/ 的/ 持久/ 存储/ 层/ ,/ 最终/ 将/ HBase/ 的/ 结果/ 返回/ 给/ 客户端/ ./ ④/ 最后/ ,/ 客户端/ 汇总/ 来自/ 存储/ 2/ 与/ 存储/ 3/ 的/ 查询/ 结果/ ,/ 完成/ 此次/ 范围/ 查询/ 的/ 流程/ ./ 与/ 单值/ 查询/ 一样/ ,/ 缓存/ 命中率/ 的/ 提高/ 会/ 降低/ 范围/ 查询/ 的/ 响应/ 时间/ ./ 范围/ 查询/ 中/ 对/ 值表/ 的/ 访问/ 是/ HiBase/ 为/ 哈希/ 索引/ 付出/ 的/ 代价/ ,/ 但是/ 由于/ 每次/ 范围/ 查询/ 只/ 需要/ 访问/ 一次/ 值表/ ,/ 其/ 访问/ 代价/ 占/ 整个/ 范围/ 查询/ 的/ 比重/ 是/ 较/ 小/ 的/ ./ 6/ 实验/ 与/ 性能/ 分析/ 评估/ 6.1/ 实验/ 环境/ 与/ 数据/ 集/ 我们/ 从/ 数据/ 查询/ 性能/ 、/ 数据/ 扩展性/ 、/ 集群/ 规模/ 扩展性/ 分别/ 测试/ 了/ HiBase/ 的/ 性能/ ./ 我们/ 的/ 集群/ 测试环境/ 共有/ 10/ 个/ 节点/ ,/ 集群/ 的/ 节点/ 配置/ 参见/ 表/ 1/ ./ CPUMemoryDiskNetworkOSJVMVersionHadoopVersionHBaseVersionZooKeeperVersion/ 实验/ 采用/ 的/ 数据/ 集/ 包括/ 布朗/ 大学/ 的/ 大/ 数据/ 基准/ 测试/ 和/ 国内/ 电信/ 运营商/ 的/ 电话/ 用户/ 上网/ 记录/ 数据/ ./ 首先/ ,/ 我们/ 用/ 电话/ 用户/ 上网/ 记录/ 数据测试/ 不同/ 系统/ 的/ 查询/ 响应/ 时间/ ,/ 该/ 数据/ 集共/ 1072868115/ 条/ 记录/ ,/ 每条/ 数据/ 记录/ 不等长/ ,/ 平均/ 约/ 是/ 200/ 个/ 字节/ ,/ Page1110/ 个/ 属性/ ./ 查询/ 需求/ 包括/ 下面/ 4/ 个/ :/ ①/ 根据/ 用户/ 号码/ MDN/ 查询/ 某/ 一个/ 时间段/ 内/ 的/ 详单/ 列表/ ./ ②/ 根据/ IP/ 查询/ 某个/ 时间段/ 内/ 使用/ 该/ IP/ 进行/ 上网/ 的/ 用户/ 列表/ ./ ③/ 根据/ IP/ +/ PORT/ 查询/ 某个/ 时间段/ 内/ 使用/ 该/ IP/ +/ PORT/ 进行/ 上网/ 的/ 用户/ 列表/ ./ ④/ 根据/ URL/ 查询/ 某个/ 时间段/ 内/ 登录/ 该/ URL/ 的/ 用户/ 列表/ ./ 以上/ 查询/ 需求/ 都/ 是/ 时间段/ 上/ 的/ 范围/ 查询/ ,/ 其中/ ,/ 需求/ 1/ 是/ 在/ 用户/ 表/ 主键/ 上/ 查询/ ,/ 不用/ 建立/ 索引/ ;/ 需求/ 2/ 和/ 4/ 是/ 单个/ 属性/ 上/ 的/ 非/ 主键/ 查询/ ,/ 建立/ 查询/ 属性/ 上/ 的/ 索引/ ;/ 需求/ 3/ 是/ 两个/ 属性/ 上/ 的/ 组合/ 查询/ ,/ 建立/ 组合/ 索引/ ./ 针对/ 以上/ 查询/ 需求/ ,/ 我们/ 一共/ 设计/ 了/ 10/ 个/ 测试用例/ ,/ 每个/ 查询/ 测试用例/ 分别/ 测试/ 缓存/ 未/ 命中/ 的/ 冷/ 查询/ 响应/ 时间/ 和/ 缓存/ 命中/ 的/ 热/ 查询/ 响应/ 时间/ ./ 然后/ ,/ 我们/ 再/ 进行/ 布朗/ 大学/ 的/ 大/ 数据/ 基准/ 测试/ 实验/ ./ 布朗/ 大学/ 的/ 大/ 数据/ 基准/ 测试/ ①/ 是/ 布朗/ 大学/ 在/ 文献/ [/ 13/ ]/ 中/ 为了/ 对比/ 关系数据库/ 和/ Hadoop/ 在/ 大/ 数据/ 上/ 的/ 查询/ 性能/ 而/ 提出/ 的/ 基准/ 测试/ ./ 我们/ 用该/ 基准/ 测试/ 在/ 4/ 个/ 节点/ 上/ 对/ 数据/ 集/ 进行/ 10000/ 次/ 符合/ 齐夫/ 分布/ 的/ 持续/ 查询/ (/ 包括/ 点/ 查询/ 和/ 范围/ 查询/ )/ ,/ 测试/ 在/ 不同/ 的/ 数据/ 缓存/ 比例/ 下/ 缓存/ 的/ 命中率/ 和/ 查询/ 响应/ 时间/ ./ 6.2/ 实验/ 结果/ 及其/ 分析/ (/ 1/ )/ 非/ 主键/ 索引/ 查询/ 性能/ 对比/ 实验/ 与/ 结果/ 分析/ 我们/ 用/ 10/ 亿条/ 电话/ 用户/ 上网/ 记录/ 数据/ 对/ HiBase/ 实现/ 的/ 非/ 主键/ 索引/ 的/ 性能/ 进行/ 对比/ 测试/ ./ 对比/ 如下/ 3/ 种/ 情况/ :/ ①/ 不带/ 任何/ 非/ 主键/ 索引/ 的/ 标准/ HBase/ 表上/ 进行/ 扫描/ 的/ 查询/ 性能/ ;/ ②/ 华为公司/ 的/ 开源/ HBase/ 非/ 主键/ 索引/ 系统/ Hindex/ 的/ 查询/ 性能/ ;/ ③/ HiBase/ 基于/ 热度/ 累积/ 缓存/ 算法/ 的/ 非/ 主键/ 索引/ 的/ 查询/ 性能/ ./ 图/ 9/ 给出/ 了/ 4/ 个/ 测试用例/ 的/ 查询/ 响应/ 时间/ 性能/ 对比/ ./ 图/ 9/ 中/ 的/ 横坐标/ 分别/ 是/ 查询/ 获得/ 的/ 结果/ 集/ 大小/ ,/ 纵坐标/ 是/ 查询/ 响应/ 时间/ ,/ 由于/ HBase/ 和/ HiBase/ 的/ 查询/ 响应/ 时间/ 数量级/ 相差太大/ ,/ 无法/ 用/ 等/ 比例/ 坐标/ ,/ 在/ 这里/ 使用/ 指数/ 指标/ ./ 实验/ 结果/ 可以/ 看出/ ,/ HiBase/ 的/ 查询/ 响应/ 时间/ 大大/ 优于/ 无非/ 主键/ 索引/ 的/ 标准/ HBase/ 和/ 开源/ 的/ Hindex/ 非/ 主键/ 索引/ 系统/ 的/ 查询/ 性能/ ./ 对于/ 结果/ 集/ 很小/ (/ 极端/ 情况/ 下/ ,/ 结果/ 集/ 大小/ 为/ 0/ )/ 的/ 查询/ ,/ HiBase/ 和/ 无非/ 主键/ 索引/ 的/ 标准/ HBase/ 的/ 扫描/ 方法/ 相比/ ,/ 冷/ 查询/ 的/ 性能/ 提升/ 达到/ 116912/ 倍/ ,/ 热/ 查询/ 的/ 性能/ 提升/ 可以/ 达到/ 131732/ 倍/ ./ 对于/ 结果/ 集较/ 小/ (/ 结果/ 集为/ 1155/ )/ 的/ 查询/ ,/ 冷/ 查询/ 的/ 性能/ 提升/ 达到/ 3082/ 倍/ ,/ 热/ 查询/ 的/ 性能/ 提升/ 达到/ 17751/ 倍/ ./ 对于/ 结果/ 集/ 较大/ (/ 结果/ 集为/ 97515/ )/ 的/ 查询/ ,/ 冷/ 查询/ 的/ 性能/ 提升/ 是/ 65/ 倍/ ,/ 热/ 查询/ 的/ 性能/ 提升/ 是/ 343/ 倍/ ./ 和/ 开源/ 的/ Hindex/ 非/ 主键/ 索引/ 系统/ 相比/ ,/ HiBase/ 热/ 查询/ 的/ 性能/ 提升/ 可以/ 达到/ 5/ ~/ 20/ 倍/ ./ 从/ HiBase/ 和/ 标准/ HBase/ 性能/ 对比/ 来看/ ,/ 结果/ 集小/ 的/ 查询/ 性能/ 提升/ 效果/ 更/ 明显/ ,/ 这/ 是因为/ 对于/ 标准/ HBase/ ,/ 不论/ 结果/ 集/ 大小/ ,/ 非/ 主键/ 属性/ 上/ 的/ 查询/ 都/ 需要/ 遍历/ 全部/ 数据/ ,/ 而/ HiBase/ 上/ 的/ 非/ 主键/ 索引/ 可以/ 直接/ 定位/ 到/ 记录/ ,/ 查询/ 响应/ 时间/ 随着/ 结果/ 集/ 的/ 大小/ 而/ 增长/ ./ (/ 2/ )/ 缓存/ 命中率/ 查询/ 性能/ 对比/ 实验/ 与/ 结果/ 分析/ 缓存/ 命中率/ 是/ 指/ 在/ 批量/ 查询/ 中/ ,/ 在/ 缓存/ 中/ 获得/ 结果/ 集/ 的/ 数据/ 查询/ 个数/ 占/ 全部/ 数据/ 查询/ 个数/ 的/ 比率/ ./ 提高/ 缓存/ 命中率/ 会/ 减少/ 访问/ 磁盘/ 的/ 次数/ ,/ 有效/ 降低/ 查询/ 响应/ 时间/ ,/ 因此/ 命中率/ 是/ 缓存/ 算法/ 最/ 重要/ 的/ 性能/ 评价/ 指标/ ./ 命中率/ 越高/ ,/ 缓存/ 系统/ 的/ 查询/ 性能/ 越好/ ./ 我们/ 用/ 布朗/ 大学/ 的/ 大/ 数据/ 基准/ 测试/ 对/ HiBase/ 进行/ 10000/ 次/ 符合/ 齐夫/ 分布/ 的/ 持续/ 查询/ 来/ 测试/ 缓存/ 性能/ ,/ 数据/ 规模/ 为/ 10000000/ 条/ 记录/ ./ 图/ 10/ 给出/ 了/ HiBase/ 的/ 热度/ 累积/ 缓存/ 算法/ 和/ LRU/ 算法/ 的/ 命中率/ 对比/ ,/ 图/ 11/ 给出/ 了/ 查询/ 响应/ 时间/ 对比/ ./ 图/ 10/ 热度/ 累积/ 缓存/ 算法/ 和/ LRU/ 的/ 命中率/ 对比/ ①/ BenchmarkofBrownUniversity/ ./ http/ :/ // // database/ ./ cs/ ./ Page12/ 从图/ 10/ 中/ 可以/ 看出/ ,/ 缓存/ 空间/ 增加/ ,/ 命中率/ 提高/ ./ 热度/ 累积/ 缓存/ 算法/ 的/ 命中率/ 高于/ LRU/ ,/ 尤其/ 是/ 在/ 数据/ 缓存/ 比例/ 较/ 低/ 的/ 情况/ 下/ ./ 如/ 数据/ 缓存/ 比例/ 为/ 0.2/ 时/ ,/ 热度/ 累积/ 缓存/ 算法/ 的/ 命中率/ 大约/ 比/ LRU/ 的/ 命中率/ 高/ 16/ %/ ,/ 因为/ 热度/ 累积/ 缓存/ 算法/ 的/ 热度/ 累积/ 机制/ 能够/ 更/ 精确/ 地/ 记录/ 数据/ 的/ 冷热/ 程度/ ,/ 将/ 热点/ 数据/ 缓存/ 到/ 内存/ 中/ ./ 对于/ 大/ 数据/ 应用/ ,/ 缓存/ 空间/ 受/ 内存/ 限制/ ,/ 热度/ 累积/ 缓存/ 算法/ 在/ 缓存/ 比例/ 不高/ 的/ 时候/ 正好/ 可以/ 充分发挥/ 优势/ ,/ 提高/ 大/ 数据/ 下/ 的/ 查询/ 性能/ ./ HiBase/ 是/ 为了/ 实现/ 大/ 数据/ 上/ 的/ 高效/ 非/ 主键/ 索引/ 而/ 实现/ 的/ 系统/ ,/ 我们/ 在/ HiBase/ 上/ 做/ 了/ 无/ 内存/ 缓存/ 、/ LRU/ 缓存/ 替换/ 策略/ 、/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ 的/ 10000/ 次/ 符合/ 齐夫/ 分布/ 的/ 持续/ 查询/ ,/ 并/ 记录/ 查询/ 响应/ 时间/ ,/ 如图/ 11/ 所示/ ./ 可以/ 看出/ ,/ 随着/ 缓存/ 空间/ 的/ 增大/ ,/ 命中率/ 不断/ 提升/ ,/ 使用/ 两种/ 替换/ 策略/ 的/ 索引/ 查询/ 时间/ 都/ 在/ 随之/ 降低/ ./ 由于/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ 在/ 命中率/ 上/ 的/ 优势/ ,/ 查询/ 响应/ 时间/ 明显/ 优于/ 使用/ LRU/ 替换/ 策略/ 的/ 查询/ 性能/ ,/ 提升/ 幅度/ 从/ 缓存/ 比例/ 为/ 0.2/ 时/ 的/ 30/ %/ 到/ 缓存/ 比例/ 为/ 0.8/ 时/ 的/ 67/ %/ ./ (/ 3/ )/ 冷热/ 查询/ 对比/ 实验/ 与/ 结果/ 分析/ 我们/ 在/ 10/ 亿条/ 电话/ 用户/ 上网/ 记录/ 数据/ 上/ 做/ 了/ 10/ 个/ 测试用例/ 的/ 冷热/ 查询/ 性能/ 对比/ 实验/ ./ 每个/ 测试用例/ 测试/ 了/ 第一次/ 冷/ 查询/ 和/ 随后/ 的/ 缓存/ 命中/ 热/ 查询/ 的/ 查询/ 响应/ 时间/ ./ 性能/ 对比/ 实验/ 结果/ 如图/ 12/ 所示/ ,/ 图/ 12/ 电话/ 用户/ 上网/ 记录/ 数据/ 查询/ 响应/ 时间/ 这里/ 我们/ 的/ 查询/ 响应/ 时间/ 是/ 单次/ 查询/ 的/ 性能指标/ ,/ 横坐标/ 是/ 查询/ 得到/ 的/ 结果/ 集/ 大小/ (/ 结果/ 集/ 包含/ 的/ 记录/ 条数/ )/ ./ 可以/ 看出/ ,/ 每个/ 用例/ 的/ 第/ 1/ 次/ 冷/ 查询/ 的/ 时间/ 都/ 是/ 最长/ 的/ ,/ 第/ 2/ 次/ 热/ 查询/ 由于/ 缓存/ 命中/ ,/ 所以/ 查询/ 响应/ 时间/ 缩短/ 5/ ~/ 15/ 倍/ (/ 注/ :/ 图/ 12/ 中/ 的/ 查询/ 响应/ 时间/ 是/ 指数/ 坐标/ )/ ./ (/ 4/ )/ 扩展性/ 实验/ 与/ 结果/ 分析/ 我们/ 通过/ 布朗/ 大学/ 的/ 大/ 数据/ 基准/ 测试/ 验证/ 了/ HiBase/ 在/ 不同/ 数据/ 规模/ 下/ 的/ 查询/ 性能/ ,/ 如图/ 13/ 所示/ ./ 可以/ 看到/ ,/ 部署/ 在/ 10/ 个/ 节点/ 上/ 的/ HiBase/ 在/ 数据/ 规模/ 从/ 10000000/ 扩展/ 到/ 50000000/ 条/ 数据/ 记录/ 时/ ,/ 查询/ 时间/ 保持/ 线性/ 增长/ ,/ 这/ 验证/ 了/ HiBase/ 在/ 数据/ 可扩展性/ 方面/ 有着/ 良好/ 的/ 表现/ ./ 查询/ 响应/ 时间/ 和/ 结果/ 集/ 大小/ 成正比/ ,/ 因为/ 在/ 查询/ 响应/ 时间/ 中/ ,/ 主要/ 开销/ 是/ 对/ 查询/ 结果/ 集/ 的/ 访问/ ./ 在/ 数据/ 集中/ ,/ 数据/ 是/ 符合/ 均匀分布/ 的/ ,/ 随着/ 数据/ 行/ 总数/ 的/ 增长/ ,/ 查询/ 结果/ 集/ 也/ 随之/ 增加/ ,/ 因此/ 查询/ 响应/ 时间/ 会/ 与/ 数据/ 行/ 总数/ 的/ 大小/ 成正比/ ./ 同时/ ,/ 我们/ 在/ 20000000/ 条/ 数据/ 记录/ 上/ 进行/ 了/ 10000/ 次/ 范围/ 长度/ 为/ 10/ 的/ 范围/ 查询/ 可扩展性/ 测试/ ,/ 如图/ 14/ 所示/ ./ 本/ 实验/ 不/ 使用/ 单值/ 查询/ 的/ 原因/ 是/ :/ 在/ 进行/ 单值/ 查询/ 时/ ,/ 没有/ 并发/ 的/ 过程/ ,/ 所以/ 节点/ 的/ 变化/ 几乎/ 不/ 影响/ 查询/ 时间/ ./ 可以/ 看出/ ,/ 随着/ 节点/ 数量/ 的/ 增/ Page13/ 加/ ,/ 查询/ 响应/ 时间/ 逐渐/ 降低/ ./ 在/ 范围/ 查询/ 中/ ,/ 查询/ 会/ 根据/ 范围/ 内/ 存在/ 的/ 索引/ 列值/ 向/ 各/ 节点/ 发送/ 查询/ 请求/ ,/ 查询/ 被/ 并行执行/ 后/ 汇总/ 结果/ ,/ 所以/ 查询/ 响应/ 时间/ 会/ 随着/ 节点/ 的/ 增加/ 而/ 降低/ ./ 另一方面/ ,/ 索引/ 列值/ 是/ 通过/ 一致性/ 哈希/ 算法/ 映射/ 到/ 各个/ 节点/ 上/ 的/ ,/ 我们/ 的/ 测试/ 实例/ 范围/ 固定/ 为/ 10/ ,/ 所以/ 当/ 节点/ 个数/ 增加/ 到/ 一定/ 程度/ 之后/ ,/ 查询/ 响应/ 时间/ 趋于/ 平缓/ ./ (/ 5/ )/ 索引/ 构建/ 的/ 时间/ 和/ 空间/ 开销/ 分析/ HiBase/ 非/ 主键/ 索引/ 系统/ 是/ 在/ 数据/ 导入/ 阶段/ 创建/ 索引/ ,/ 我们/ 在/ 电话/ 用户/ 上网/ 记录/ 数据/ 上/ 测试/ HiBase/ 系统/ 的/ 数据/ 导入/ 时间/ 来/ 衡量/ 系统/ 的/ 索引/ 构建/ 时间/ 开销/ ./ 同时/ 我们/ 测试/ 了/ HBase/ 的/ 数据/ 导入/ 时间/ 作为/ 对比/ ./ 数据/ 导入/ 时间/ 的/ 对比/ 实验/ 结果/ 如表/ 2/ 所示/ ./ 数据/ 规模/ (/ 记录/ 行/ 数/ )/ 65013111072868115/ 在/ 电话/ 用户/ 上网/ 记录/ 实验/ 数据/ 集上/ 我们/ 分别/ 做/ 1.4/ GB/ 部分/ 数据/ 集/ (/ 6501311/ 条/ 记录/ )/ 和/ 225GB/ 全部/ 数据/ 集/ (/ 1072868115/ 条/ 记录/ )/ 的/ 数据/ 导入/ 时间/ 对比/ 测试/ ./ 可以/ 看出/ ,/ HiBase/ 的/ 数据/ 导入/ 时间/ 分别/ 是/ HBase/ 的/ 1.03/ 和/ 1.12/ 倍/ ,/ 因为/ HiBase/ 在/ 将/ 用户/ 表/ 插入/ 到/ HBase/ 的/ 同时/ ,/ 触发/ HBaseCoprocessor/ 并行/ 地/ 构建/ 索引/ 记录/ 并/ 插入/ 到/ 索引/ 表中/ ./ 实验/ 结果表明/ ,/ HiBase/ 为/ 建立/ 索引/ 所/ 带来/ 的/ 时间/ 开销/ 是/ 完全/ 可以/ 接受/ 的/ ./ 空间/ 开销/ 上/ ,/ 索引/ 数据/ 与/ 原始/ 用户/ 表/ 数据/ 的/ 占/ 比/ 不是/ 绝对/ 固定/ 的/ ,/ 而是/ 依赖于/ 用户/ 表/ 的/ 结构/ 以及/ 索引/ 属性/ 列值/ 的/ 占用/ 空间/ ./ 在/ 本文/ 的/ 电话/ 用户/ 测试数据/ 中/ ,/ 225GB/ 全部/ 数据/ 集/ 的/ 用户/ 表/ 和/ 索引/ 表/ 空间/ 开销/ 总和/ 为/ 575GB/ ,/ 其中/ 225GB/ 文本/ 数据/ 导入到/ HBase/ 后/ 的/ 用户/ 表/ 空间/ 开销/ 为/ 238GB/ ./ 针对/ 6.1/ 节中/ 提到/ 的/ 查询/ 需求/ 1/ ~/ 4/ (/ 其中/ 查询/ 需求/ 1/ 是/ 用户/ 表/ 主键/ 查询/ )/ ,/ 我们/ 在/ HiBase/ 中为/ 查询/ 需求/ 2/ ~/ 4/ 建立/ 非/ 主键/ 索引/ ./ 索引/ 的/ 空间/ 开销/ 总和/ 为/ 337GB/ ,/ 单个/ 索引/ 的/ 平均/ 开销/ 约/ 为/ 112.3/ GB/ ,/ 故/ 单个/ 非/ 主键/ 索引/ 表/ 的/ 空间/ 开销/ 约/ 为/ 用户/ 表/ 的/ 47/ %/ ./ 对于/ 采用/ 廉价/ 的/ 分布式/ 存储/ 、/ 具有/ 优异/ 的/ 存储空间/ 可扩展性/ 的/ Hadoop/ 和/ HBase/ 系统/ 来说/ ,/ 构建/ 一个/ 十多个/ 节点/ 的/ Hadoop/ 集群/ 即可/ 获得/ 数十/ TB/ 的/ 存储容量/ ./ 因此/ ,/ 通过/ 为/ 每个/ 非/ 主键/ 索引/ 提供/ 约/ 一半/ 用户/ 表/ 的/ 空间/ 开销/ 而/ 达到/ 数十/ 至/ 数百倍/ 以上/ 的/ 查询/ 性能/ 提升/ 是/ 完全/ 值得/ 的/ ./ 7/ 总结/ 和/ 展望/ 为了/ 提高/ HBase/ 上非/ 主键/ 查询/ 的/ 效率/ ,/ 本文/ 提出/ 了/ 一种/ 基于/ HBase/ 的/ 分层/ 式/ 非/ 主键/ 索引/ 存储/ 模型/ ,/ 并/ 设计/ 实现/ 了/ 分层/ 式/ 索引/ 查询/ 系统/ HiBase/ ./ HiBase/ 在/ HBase/ 上/ 持久/ 化/ 存储用户/ 表/ 和/ 索引/ 表/ ,/ 并/ 将/ 索引/ 表/ 的/ 热点/ 数据/ 缓存/ 在/ 内存/ 中/ ./ 同时/ 我们/ 研究/ 提出/ 并/ 实现/ 了/ 一种/ 基于/ 热度/ 累积/ 的/ 缓存/ 替换/ 策略/ ,/ 通过/ 高效/ 的/ 缓存/ 替换/ 策略/ ,/ HiBase/ 获得/ 了/ 优于/ LRU/ 的/ 缓存/ 命中率/ ,/ 进一步/ 提升/ 了/ HBase/ 上非/ 主键/ 查询/ 的/ 性能/ ./ 下/ 一步/ ,/ 我们/ 会/ 针对/ 非/ 主键/ 属性/ 上/ 的/ 聚集/ 查询/ 和/ 连接/ 查询/ 进行/ 研究/ 并/ 提出/ 高效/ 的/ 解决方案/ ./ 同时/ ,/ 引入/ SSD/ 尝试/ 多层/ 热点/ 缓存/ 存储/ 方案/ ./ 另外/ ,/ 在/ HiBase/ 中/ 为了/ 支持/ 基于/ 内存/ 缓存/ 的/ 范围/ 查询/ 我们/ 引入/ 值表/ ,/ 下/ 一步/ 我们/ 会/ 针对/ 值表/ 做/ 自/ 适应/ 粒度/ 的/ 存储/ 优化/ ,/ 保证/ 值表中/ 的/ 记录/ 对应/ 的/ 集合/ 大小/ 基本/ 均衡/ ,/ 从而/ 提供/ 性能/ 稳定/ 的/ 范围/ 查询/ ./ 

