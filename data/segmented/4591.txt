Page1/ 基于/ 任务/ 合并/ 的/ 并行/ 大/ 数据/ 清洗/ 过程/ 优化/ 王宏志/ 1/ )/ 1/ )/ (/ 哈尔滨工业大学/ 计算机科学/ 与/ 技术/ 学院/ 哈尔滨/ 150001/ )/ 2/ )/ (/ 哈尔滨工业大学/ 基础/ 与/ 交叉科学/ 研究院/ 哈尔滨/ 150001/ )/ 摘要/ 数据/ 质量/ 问题/ 会/ 对/ 大/ 数据/ 的/ 应用/ 产生/ 致命/ 影响/ ,/ 因此/ 需要/ 对/ 存在/ 数据/ 质量/ 问题/ 的/ 大/ 数据/ 进行/ 清洗/ ./ MapReduce/ 编程/ 框架/ 可以/ 利用/ 并行/ 技术/ 实现/ 高/ 可扩展性/ 的/ 大/ 数据/ 清洗/ ,/ 然而/ ,/ 由于/ 缺乏/ 有效/ 的/ 设计/ ,/ 在/ 基于/ MapReduce/ 的/ 数据/ 清洗/ 过程/ 中/ 存在/ 计算/ 的/ 冗余/ ,/ 导致/ 性能/ 降低/ ./ 因此/ 文中/ 的/ 目的/ 是/ 对/ 并行/ 数据/ 清洗/ 过程/ 进行/ 优化/ 从而/ 提高效率/ ./ 通过/ 研究/ ,/ 作者/ 发现/ 数据/ 清洗/ 中/ 一些/ 任务/ 往往/ 都/ 运行/ 在/ 同一/ 输入/ 文件/ 上/ 或者/ 利用/ 同样/ 的/ 运算/ 结果/ ,/ 基于/ 该/ 发现/ 文中/ 提出/ 了/ 一种/ 新/ 的/ 优化/ 技术/ —/ —/ —/ 基于/ 任务/ 合并/ 的/ 优化/ 技术/ ./ 针对/ 冗余/ 计算/ 和/ 利用/ 同一/ 输入/ 文件/ 的/ 简单/ 计算/ 进行/ 合并/ ,/ 通过/ 这种/ 合并/ 可以/ 减少/ MapReduce/ 的/ 轮数/ 从而/ 减少/ 系统/ 运行/ 的/ 时间/ ,/ 最终/ 达到/ 系统优化/ 的/ 目标/ ./ 文中/ 针对/ 数据/ 清洗/ 过程/ 中/ 多个/ 复杂/ 的/ 模块/ 进行/ 了/ 优化/ ,/ 具体来说/ 分别/ 对/ 实体/ 识别/ 模块/ 、/ 不/ 一致/ 数据/ 修复/ 模块/ 和/ 缺失/ 值/ 填充/ 模块/ 进行/ 了/ 优化/ ./ 实验/ 结果表明/ ,/ 文中/ 提出/ 的/ 策略/ 可以/ 有效/ 提高/ 数据/ 清洗/ 的/ 效率/ ./ 关键词/ 大/ 数据/ ;/ 多任务/ 优化/ ;/ 海量/ 数据/ ;/ 数据/ 清洗/ ;/ Hadoop/ ;/ MapReduce1/ 引言/ 本/ 节/ 主要/ 介绍/ 研究/ 背景/ 及其/ 意义/ 、/ 海量/ 数据/ 清洗/ 系统/ 、/ 本文/ 优化/ 方法/ 的/ 主要/ 思想/ 、/ 本文/ 的/ 贡献/ 与/ 结构/ ./ 1.1/ 研究/ 背景/ 及其/ 意义/ 现今/ 企业/ 的/ 成功/ 和/ 社会/ 的/ 进步/ ,/ 越来越/ 依赖于/ 数据/ 和/ 对/ 其/ 所/ 做/ 的/ 分析/ ./ 为了/ 获得/ 竞争/ 优势/ 即使/ 是/ 小企业/ 也/ 会/ 投入/ 时间/ 和/ 精力/ 来/ 收集/ 和/ 分析/ 数据/ ./ 很多/ 大/ 公司/ 都/ 部署/ 了/ 自己/ 的/ 云/ 服务平台/ ,/ 国内/ 比较/ 著名/ 的/ 有/ 百度/ 云/ 、/ 阿里/ 云/ 、/ 天翼云/ ①/ 等/ ./ 但是/ 如果/ 一味/ 地/ 将/ 精力/ 投入/ 到/ 对/ 数据/ 所/ 做/ 的/ 分析/ 而/ 不/ 关注/ 数据/ 本身/ ,/ 很/ 可能/ 产生/ 灾难性/ 的/ 后果/ ./ 统计/ 表明/ ,/ 美国/ 企业/ 中/ 1/ %/ ~/ 30/ %/ 的/ 数据/ 存在/ 各类/ 错误/ 和/ 误差/ [/ 1/ ]/ ,/ 医疗/ 数据库/ 中/ 13.6/ %/ ~/ 81/ %/ 的/ 关键/ 数据/ 不/ 完整/ 或/ 陈旧/ [/ 2/ ]/ ./ 根据/ 市场/ 研究/ 公司/ Gartner/ 的/ 调查/ ,/ 全球/ 财富/ 1000/ 强/ 公司/ 超过/ 25/ %/ 的/ 关键/ 数据/ 不/ 正确/ 或/ 不/ 准确/ [/ 3/ ]/ ./ 数据/ 质量/ 问题/ 会/ 使/ 基于/ 其/ 的/ 分析/ 和/ 研究/ 毫无意义/ 甚至/ 还会/ 产生/ 灾难性/ 的/ 后果/ ,/ 在/ 美国/ 由于/ 数据/ 错误/ 引起/ 的/ 医疗事故/ 每年/ 使/ 98000/ 名/ 患者/ 丧生/ [/ 4/ ]/ ./ 上述/ 实例/ 表明/ 数据/ 质量/ 问题/ 存在/ 于/ 社会/ 生活/ 的/ 方方面面/ ,/ 数据/ 清洗/ 系统/ 应运而生/ ./ 在/ 海量/ 数据处理/ 领域/ ,/ MapReduce/ 编程/ 框架/ 作为/ 当下/ 最/ 流行/ 的/ 并行/ 编程/ 开发/ 框架/ 已/ 被/ Google/ 、/ Amazon/ 、/ Yahoo/ !/ 、/ Facebook/ 以及/ 国内/ 的/ 腾讯/ 、/ 阿里巴巴/ 等/ 大型/ 互联网/ 公司/ 奉为至宝/ ./ 将/ Hadoop/ 用于/ 海量/ 数据处理/ 主要/ 有/ 如下/ 优势/ :/ 易用性/ 、/ 高/ 可扩展性/ 、/ 高/ 容错性/ ./ 上述/ 优势/ 使得/ 基于/ MapReduce/ 的/ 海量/ 数据/ 清洗/ 顺其自然/ 的/ 产生/ 了/ ./ 海量/ 数据/ 上/ 的/ 数据分析/ 往往/ 需要/ 相对/ 高昂/ 的/ 硬件/ 成本/ 和/ 时间/ 成本/ ,/ 这/ 就/ 引起/ 了/ 人们/ 对/ 优化/ 数据分析/ 的/ 兴趣/ ./ 当前/ 已经/ 有/ 不少/ 人/ 开始/ 研究/ 大/ 数据/ 上/ 的/ 数据/ 清洗/ 系统/ ,/ 有/ 对/ 整个/ 数据/ 清洗/ 系统/ 进行/ 研究/ [/ 5/ -/ 7/ ]/ ,/ 也/ 有/ 对/ 其中/ 的/ 数据/ 一致性/ [/ 8/ -/ 10/ ]/ ,/ 实体/ 识别/ 如/ 文献/ [/ 11/ -/ 14/ ]/ 等/ 问题/ 进行/ 研究/ 的/ ./ 然而/ 现在/ 还/ 没有/ 人/ 对/ 基于/ MapReduce/ 的/ 数据/ 清洗/ 系统/ 的/ 优化/ 进行/ 研究/ ./ 现在/ 几乎/ 所有/ 的/ 数据分析/ 任务/ 都/ 可以/ 用/ MapReduce/ 编程/ 框架/ 来/ 实现/ ,/ 但是/ 在/ 实现/ 过程/ 中/ 往往/ 会/ 存在/ 冗余/ 的/ MapReduce/ ,/ 基于/ MapReduce/ 的/ 海量/ 数据/ 清洗/ 系统/ 也/ 不/ 例外/ ./ 本文/ 提出/ 的/ 基于/ 任务/ 合并/ 的/ 优化/ 方法/ 着眼于/ 系统/ 中/ 冗余/ 的/ MapReduce/ ,/ 从/ 细节/ 和/ 流程/ 的/ 各个方面/ 实施/ ./ 1.2/ 海量/ 数据/ 清洗/ 系统/ 海量/ 数据/ 清洗/ 系统/ 如图/ 1/ 所示/ ,/ 它/ 在/ Hadoop/ 平台/ 上/ 实施/ ,/ 以/ 一个/ 灵活/ 的/ 结构/ 来/ 处理/ 不同/ 类型/ 的/ 数据/ 质量/ 问题/ ,/ 每种/ 类型/ 的/ 数据/ 质量/ 问题/ 都/ 由/ 一个/ 或/ 多个/ 模块/ 来/ 处理/ ,/ 由/ 哈尔滨工业大学/ 海量/ 数据/ 计算/ 与/ 研究/ 中心/ 提供/ 源代码/ ./ 系统/ 中/ 的/ 交互/ 模块/ 提供/ 一个/ 输入/ 接口/ 来/ 输入/ 需要/ 清洗/ 的/ 文件/ 以及/ 清洗/ 数据/ 的/ 要求/ ./ 结果/ 展示/ 模块/ 提供/ 清洁/ 数据/ 的/ 下载/ 链接/ 以及/ 脏/ 数据/ 和/ 清洗/ 后/ 的/ 数据/ 的/ 对比/ 情况/ ./ 实体/ 识别/ 和/ 真值/ 发现/ 模块/ 用于/ 消冗/ ,/ 其中/ 实体/ 识别/ 把/ 指向/ 同一/ 现实/ 世界/ 实体/ 的/ 元组/ 聚类/ ,/ 而/ 真值/ 发现/ 用来/ 在/ 冲突/ 中/ 寻找/ 出/ 真实/ 值/ ./ 不/ 一致/ 检测/ 模块/ 发现/ 数据/ 中/ 违反/ 依赖/ 规则/ 的/ 部分/ 并且/ 尝试/ 把/ 数据/ 修复/ 到/ 符合/ 规则/ 的/ 状态/ ./ 数值/ 填充/ 部分/ 检测/ 数据/ 缺失/ 部分/ 并/ 填充/ ./ 用户/ 可以/ 选择/ 合适/ 的/ 模块/ 来/ 处理/ 所/ 遇到/ 的/ 数据/ 质量/ 问题/ ./ 1.3/ 本文/ 优化/ 方法/ 概要/ 和/ 其他/ 优化/ 方法/ 本/ 节/ 首先/ 给出/ 基于/ 任务/ 合并/ 的/ 优化/ 方法/ ,/ 然后/ 对/ 基于/ Hadoop/ 平台/ 的/ 海量/ 数据/ 清洗/ 系统/ 进行/ 优化/ ./ 一个/ 实际/ 的/ 系统/ 往往/ 需要/ 很多/ 轮/ MapReduce/ 来/ 实现/ ./ 有/ 文献/ 表明/ ,/ 对于/ 比较复杂/ 的/ 单一型/ 人物/ ,/ 拆分/ 开来/ 执行/ 的话/ 性能/ 反而/ 更好/ ./ 但是/ 根据/ MapReduce/ 编程/ 方式/ 的/ 特点/ ,/ 往往/ 需要/ 将/ 一个/ 问题/ 分解成/ 很多/ 简单/ 的/ 任务/ ,/ 每/ 一个/ 任务/ 由/ 一轮/ MapReduce/ 实现/ ./ 在/ 大多数/ 情况/ 下/ ,/ 这种/ “/ 分解/ ”/ 是/ 过度/ 的/ ,/ 由此/ 而/ 产生/ 冗余/ 的/ MapReduce/ ./ 将/ 可以/ 合并/ 的/ 任务/ 进行/ 适当/ 的/ 合并/ ,/ 并且/ 在/ 不/ 改变/ 原/ 系统/ 的/ 算法/ 复杂度/ 与/ 迭代/ 可/ 终止/ 性/ 等/ 前提/ 下/ ,/ 满足/ 可以/ 减少/ 原/ 系统/ 的/ MapReduce/ 轮数/ 和/ IO/ 次数/ 等/ 条件/ 进而/ 达到/ 优化/ 的/ 目的/ ./ 与/ 本文/ 研究/ 方向/ 相同/ 的/ 工作/ 最/ 杰出/ 的/ 优化/ 方法/ ①/ AmazonEC2/ ./ http/ :/ // // aws/ ./ amazon/ ./ com/ // ec2/ // Page3/ 有/ MRShare/ [/ 15/ -/ 16/ ]/ ,/ 后者/ 是/ 在/ 前者/ 的/ 基础/ 上/ 发展/ 而来/ 的/ 优化/ 方法/ 并且/ 实现/ 过程/ 复杂/ ,/ 优化/ 效率/ 提升/ 不是/ 很/ 明显/ ./ MRShare/ 把/ 多个/ 共享/ 相同/ 的/ map/ 输入/ 或/ 输出/ 的/ 任务/ 合并/ 成/ 一个/ 任务/ ,/ 减少/ 扫描/ 文件/ 的/ 次数/ ,/ 从而/ 达到/ 优化/ 的/ 目的/ ./ 但/ 当/ 合并/ 后/ 的/ 任务/ 的/ 较大/ 的/ map/ 输出/ 的/ sort/ 代价/ 高于/ 合并/ 之前/ 的/ 多个/ 独立/ 的/ 较/ 小/ 的/ map/ 输出/ 的/ 代价/ 时/ ,/ 就/ 不会/ 有/ 任何/ 优化/ 效果/ ./ 本文/ 提出/ 的/ 基于/ 任务/ 合并/ 的/ 优化/ 技术/ 针对/ 冗余/ 计算/ 和/ 利用/ 同一/ 输入/ 文件/ 的/ 简单/ 计算/ 进行/ 合并/ ,/ 通过/ 这种/ 合并/ 可以/ 减少/ MapReduce/ 的/ 轮数/ 从而/ 减少/ 系统/ 运行/ 的/ 时间/ ./ 通过/ 对/ 整个/ 系统/ 的/ 框架/ 与/ 流程/ 进行/ 优化/ 设计/ ,/ 有效/ 地/ 提高/ 系统/ 的/ 效率/ ./ 1.4/ 本文/ 的/ 贡献/ 本文/ 的/ 主要/ 贡献/ 有/ :/ (/ 1/ )/ 提出/ 一种/ 基于/ MapReduce/ 的/ 应用/ 系统/ 的/ 优化/ 方法/ ./ (/ 2/ )/ 对/ 海量/ 数据/ 清洗/ 系统/ 中/ 计算/ 较为/ 复杂/ 的/ 3/ 个/ 模块/ 进行/ 讨论/ 并/ 提出/ 优化/ 方案/ ./ (/ 3/ )/ 对/ 海量/ 数据/ 清洗/ 系统/ 的/ 各个/ 模块/ 优化/ 前后/ 进行/ 了/ 大量/ 的/ 对比/ 实验/ ./ 1.5/ 本文/ 的/ 结构/ 本文/ 第/ 1/ 节/ 介绍/ 背景/ 、/ 主要/ 内容/ 和/ 本文/ 结构/ ;/ 第/ 2/ 、/ 3/ 、/ 4/ 节/ 详细/ 讨论/ 优化/ 方法/ 与/ 实施/ 过程/ ;/ 第/ 5/ 节/ 给出/ 实验/ 结果/ 和/ 分析/ ;/ 最后/ 在/ 第/ 6/ 节/ 给出/ 结论/ ./ 2/ 优化/ 的/ 缺失/ 值/ 填充/ 在/ 实际/ 的/ 生产/ 生活/ 中/ ,/ 数据/ 缺失/ 是/ 一种/ 不可避免/ 的/ 现象/ ,/ 尤其/ 是/ 在/ 数据/ 收集/ 工作/ 日趋/ 自动化/ 的/ 今天/ ./ 本/ 模块/ 是/ 一种/ 利用/ 朴素/ 贝叶斯/ 分类/ 的/ 缺失/ 值/ 填充/ 机制/ ./ 2.1/ 缺失/ 值/ 填充/ 模块/ 介绍/ 举/ 一个/ 例子/ ,/ 假设/ 一个/ 学校/ 有/ 60/ %/ 的/ 男生/ 和/ 40/ %/ 的/ 女生/ ./ 女生/ 穿/ 裤子/ 的/ 人数/ 和/ 穿/ 裙子/ 的/ 人数/ 相等/ ,/ 所有/ 男生/ 都/ 穿/ 裤子/ ./ 一个/ 人/ 在/ 远处/ 随机/ 看到/ 了/ 一个/ 穿/ 裤子/ 的/ 学生/ ,/ 那么/ 该/ 学生/ 的/ 性别/ 是/ 什么/ ?/ 如何/ 解决/ 这一/ 问题/ 呢/ ?/ 我们/ 知道/ 性别/ 的/ 取值/ 只/ 可能/ 是/ 男/ 和/ 女/ ,/ 那么/ 可以/ 根据/ 公式/ P/ (/ Ci/ |/ X/ )/ =/ (/ P/ (/ X/ |/ Ci/ )/ ×/ P/ (/ Ci/ )/ )/ // P/ (/ X/ )/ (/ Ci/ =/ 男/ 、/ 女/ ,/ X/ =/ 穿/ 裤子/ )/ 求/ 出/ 各个/ 性别/ 取值/ 的/ 概率/ ,/ 选取/ 其中/ 具有/ 最大/ 概率/ 的/ 性别/ 取值/ 就是/ 我们/ 给出/ 的/ 答案/ ./ 在/ 这个/ 例子/ 中/ ,/ 未知/ 的/ 学生/ 性别/ 是/ 缺失/ 值/ ,/ 求解/ 缺失/ 值/ 的/ 过程/ 中/ 利用/ 了/ 朴素/ 贝叶斯/ 分类法/ ./ 下面/ 通过/ 图/ 2/ 和/ 式/ (/ 1/ )/ 简要/ 介绍/ 本/ 模块/ 的/ 实现/ ./ (/ 1/ )/ 参数估计/ 模块/ 整个/ 缺失/ 值/ 填充/ 系统/ 是/ 用/ 贝叶斯/ 分类/ 的/ 思想/ 来/ 计算/ 出/ 概率/ 最大/ 的/ 取值/ 作为/ 填充/ 值/ ./ 参数估计/ 模块/ 的/ 任务/ 是/ 利用/ 式/ (/ 1/ )/ 计算/ 出/ 所有/ 的/ 概率/ ,/ 其中/ P/ (/ X/ )/ 对/ 所有/ 取值/ 为/ 常数/ ,/ 所以/ 只/ 需要/ 计算/ P/ (/ X/ |/ Ci/ )/ ×/ P/ (/ Ci/ )/ 即可/ ./ 在/ 各个/ 取值/ 的/ 先验概率/ 未知/ 的/ 情况/ 下/ ,/ 不妨/ 假设/ 其/ 是/ 等/ 概率/ 的/ ,/ 因此/ 只/ 需/ 计算/ P/ (/ X/ |/ Ci/ )/ 即可/ ./ 对于/ 具有/ 多/ 属性/ 的/ 数据/ 集/ 本文/ 采用/ 式/ (/ 2/ )/ 来/ 计算/ P/ (/ X/ |/ Ci/ )/ ,/ P/ (/ X/ |/ Ci/ )/ =/ P/ (/ x1/ |/ Ci/ )/ P/ (/ x2/ |/ Ci/ )/ …/ P/ (/ xn/ |/ Ci/ )/ (/ 2/ )/ 因此/ 整个/ 参数估计/ 模块/ 就是/ 用来/ 计算/ 所有/ 属性/ 的/ 每个/ 取值/ 的/ 概率/ P/ (/ X/ |/ Ci/ )/ ./ 概率论/ 中/ 认为/ ,/ 当/ 样本空间/ 足够/ 大时/ 概率/ ≈/ 频率/ ,/ 系统/ 用/ 统计/ 不/ 含/ 缺失/ 值/ 的/ 元组/ 中/ 各个/ 属性/ 取值/ 出现/ 的/ 频率/ 的/ 方式/ 来/ 计算/ 概率/ P/ (/ xi/ |/ Ci/ )/ ./ (/ 2/ )/ 连接/ 模块/ 系统/ 在/ 填充/ 模块/ 会/ 根据/ 式/ (/ 2/ )/ 计算/ 出/ 含有/ 缺失/ 值/ 的/ 元组/ 在/ 它/ 的/ 依赖/ 属性/ 取值/ 确定/ 的/ 所/ 确定/ 的/ 各个/ 待/ 填充/ 值/ 的/ 概率/ ./ 但是/ 由于/ MapReduce/ 函数/ 在/ map/ 阶段/ 和/ reduce/ 阶段/ 一次/ 只能/ 处理/ 一条/ 记录/ ,/ 所以/ 系统/ 必须/ 使/ 依赖/ 属性/ 取值/ 和/ 其/ 条件/ 概率/ 关联/ 起来/ ,/ 这/ 就是/ 连接/ 模块/ 存在/ 的/ 必要性/ 和/ 需要/ 解决/ 的/ 问题/ ./ 连接/ 模块/ 的/ 输入/ 数据/ 为/ 参数估计/ 模块/ 的/ 输出/ 数据/ 和/ 原待/ 填充/ 数据/ ,/ 输出/ 数据/ 是/ 将/ 含/ 缺失/ 数据/ 的/ 元组/ 中/ 依赖/ 属性/ 取值/ 与/ 该/ 取值/ 条件/ 概率/ 相关联/ 的/ 文件/ ./ 此/ 模块/ 的/ 输入/ 数据/ 为/ 原待/ 填充/ 数据/ 和/ 连接/ 模块/ 的/ 输出/ ,/ 输出/ 数据/ 为/ 经过/ 填充/ 之后/ 的/ 数据/ ./ 利用/ 式/ (/ 2/ )/ 计算/ 出/ 每个/ Ci/ (/ 待/ 填充/ 属性/ 可能/ 的/ 取值/ )/ 对应/ 的/ 条件/ 概率/ ,/ 选择/ 其中/ P/ (/ Ci/ |/ X/ )/ 概率/ 最大/ 的/ Ci/ 进行/ 填充/ ./ (/ 3/ )/ 填充/ 模块/ 填充/ 模块/ 由/ 一轮/ MapReduce/ 实现/ ,/ 首先/ 将/ 连接/ 模块/ 的/ 输出/ 结果/ 和/ 原始/ 输入/ 数据/ 以/ 偏移量/ 为/ 键值/ 进行/ 连接/ 运算/ ,/ map/ 阶段/ 和/ 连接/ 模块/ 类似/ ,/ 在/ 此/ 不再/ 说明/ ./ reduce/ 阶段/ 利用/ 式/ (/ 2/ )/ 计算/ 出/ 每个/ Ci/ (/ 待/ 填充/ 属性/ 可能/ 的/ 取值/ )/ 对应/ 的/ 条件/ 概率/ ,/ 选择/ 其中/ P/ (/ Ci/ |/ X/ )/ 概率/ 最大/ 的/ Ci/ 进行/ 填充/ ./ 填充/ 效果/ 见图/ 3/ ./ Page4/ 以上/ 是/ 对/ 缺失/ 值/ 填充/ 模块/ 的/ 简要/ 介绍/ ,/ 详细/ 介绍/ 参考文献/ [/ 17/ ]/ ,/ 本文/ 仅/ 对/ 其/ 离散/ 类型/ 的/ 缺失/ 值/ 填充/ 做/ 考虑/ ./ 2.2/ 系统分析/ 与/ 优化/ 首先/ 分析/ 一下/ 整个/ 模块/ 各个/ 子/ 模块/ 之间/ 的/ 数据流/ 和/ 联系/ 纽带/ ./ 参数估计/ 子/ 模块/ 利用/ 输入/ 数据/ 中/ 的/ 不/ 包含/ 缺失/ 数据/ 元组/ 来/ 计算/ 以/ 依赖/ 属性/ 的/ 不同/ 取值/ 为/ 条件/ 的/ 待/ 填充/ 属性/ 的/ 各种/ 取值/ 的/ 条件/ 概率/ ①/ ./ 在/ 计算/ 填充/ 值/ 的/ 过程/ 中/ 需要/ 用到/ 以/ 各/ 依赖/ 属性/ 的/ 当前/ 取值/ 为/ 条件/ 的/ 待/ 填充/ 属性/ 的/ 各种/ 可能/ 取值/ 的/ 条件/ 概率/ ②/ ,/ ②/ 是/ ①/ 中/ 的/ 一组/ 特定/ 的/ 值/ ,/ ②/ 和/ ①/ 的/ 联系/ 纽带/ 是/ 依赖/ 属性/ 的/ 取值/ ./ 而/ ②/ 和/ 原始数据/ 中/ 的/ 待/ 填充/ 元组/ 之间/ 的/ 联系/ 是/ 该/ 元组/ 的/ 偏移量/ ./ 因此/ 在/ 参数估计/ 模块/ 和/ 填充/ 模块/ 之间/ 增加/ 了/ 连接/ 模块/ ./ 仔细观察/ 系统/ 各/ 阶段/ 数据流/ 可以/ 发现/ ,/ 在/ 参数估计/ 的/ map/ 输入/ 和/ map/ 输出/ 数据/ 中均/ 包含/ 元组/ 的/ 偏移量/ ,/ 但是/ reduce/ 输出/ 数据/ 中/ 只有/ 属性/ 值/ 和/ ②/ ./ 这种/ 情况/ 使/ 系统/ 必须/ 通过/ 增加/ 一个/ 连接/ 运算/ 才能/ 将/ ②/ 与/ 待/ 填充/ 元组/ 的/ 偏移量/ 结合/ 在/ 一起/ ./ 针对/ 上述情况/ 本文/ 提出/ 了/ 一种/ 将/ 参数估计/ 模块/ 和/ 连接/ 模块/ 的/ 任务/ 合并/ 的/ 优化/ 方案/ ,/ 即/ 在/ 参数估计/ 模块/ 就/ 将/ 输出/ 的/ 条件/ 概率/ 与/ 含有/ 缺失/ 值/ 的/ 元组/ 偏移量/ 关联/ 起来/ ./ 其/ 算法/ 如下/ ./ 算法/ 1/ ./ 参数估计/ 算法/ ./ 输入/ :/ 含/ 缺失/ 值/ 的/ 数据文件/ 、/ 缺失/ 值/ 可能/ 取值/ 的/ 文件/ 输出/ :/ 条件/ 概率/ Map/ 〈/ Object/ ,/ Text/ ,/ Text/ ,/ Text/ 〉/ Input/ :/ key/ =/ offset/ ,/ value/ =/ tuple1/ ./ FOReach/ 〈/ key/ ,/ value/ 〉/ DO2/ ./ IFtuplecontainsmissingvalueTHEN3/ ./ FOReachvalueinpossiblevalue/ ./ txtDO4/ ./ FOReachattributeinthetupleDO5/ ./ outkey/ ·/ ·/ =/ possiblevalue/ ,/ Reduce/ 〈/ Text/ ,/ Text/ ,/ Text/ ,/ Text/ 〉/ 1/ ./ FOReachvalueinvaluelistDO2/ ./ IFvaluecontain/ “/ #/ ”/ THEN3/ ./ appendthe/ “/ attributeID/ +/ attribute/ ”/ onlikelihood4/ ./ ELSE5/ ./ calculatetheconditionalprobabilityofeach6/ ./ IF/ “/ attributeID/ +/ attribute/ ”/ inthelikelihoodTHEN7/ ./ outkey/ ·/ ·/ =/ offset/ ,/ outvalue/ ·/ ·/ =/ “/ #/ ”/ +/ thelistof/ 其中/ Tvalue/ 是/ 每条/ 元组/ 在/ 含有/ 缺失/ 值/ 的/ 列上/ 的/ 属性/ 值/ ,/ offset/ 是/ 原/ 记录/ 在/ 原文件/ 中/ 的/ 偏移量/ ,/ conditionalprobability/ 为/ 当前/ 属性/ 值下/ 的/ 条件/ 概率/ ,/ possiblevalue/ ./ txt/ 是/ 包含/ 缺失/ 值/ 的/ 可能/ 取值/ 的/ 文本文件/ ,/ attributeID/ 为/ 属性/ ID/ 即/ 属性/ 的/ 列/ 号/ ./ 其/ reduce/ 阶段/ 流程/ 可见/ 于图/ 4/ ./ 下面/ 举例说明/ 优化/ 后/ 的/ 算法/ 流程/ ,/ 表/ 1/ 为/ 包含/ 缺失/ 值/ 的/ 数据/ ,/ 缺失/ 值/ 可能/ 为/ y/ 或/ n/ ./ 前/ 两条/ 元组/ 不/ 含/ 缺失/ 值/ ,/ 故仅/ 将/ 其/ 按/ 属性/ 拆分/ ;/ 第/ 3/ 条/ 元组/ 含有/ 缺失/ 值/ ,/ 我们/ 在/ 每种/ 可能/ 取值/ 的/ 情况/ 下/ 按/ 属性/ 拆分/ ,/ Map/ 阶段/ 输出/ 结果/ 见表/ 2/ ./ Reduce/ 阶段/ 检查/ 所有/ 输入/ 数据/ 的/ 前缀/ ,/ 若/ 不/ 包含/ 缺失/ 值则/ 进入/ 条件/ 概率/ 计算/ 环节/ ;/ 若/ 包含/ 缺失/ 值则/ 将/ 其/ 录入/ likelihood/ (/ 用于/ 判定/ 条件/ 概率/ 是否/ 需要/ 输出/ )/ ./ 最后/ 选择/ 属性/ 值/ 存在/ 于/ likelihood/ 中/ 的/ 条件/ 概率/ 进行/ 输出/ ,/ 输出/ 结果/ 见表/ 3/ ./ Page5Offset0120178Tvalue/ // possiblevaluePrefix/ +/ offset/ +/ attributeID/ +/ attribute/ 优化/ 后/ 的/ 参数估计/ 子/ 模块/ ,/ Map/ 阶段/ 的/ 算法/ 复杂度/ 为/ O/ (/ n/ +/ ML/ )/ ,/ 其中/ n/ 为/ 不/ 包含/ 缺失/ 值/ 的/ 元组/ 的/ 数量/ ,/ M/ 为/ 包含/ 缺失/ 值/ 的/ 元组/ 的/ 数量/ ,/ L/ 为/ 缺失/ 值/ 可能/ 取值/ 的/ 数目/ ./ 一般/ 情况/ 下/ M/ / n/ ,/ 故/ O/ (/ n/ +/ ML/ )/ =/ O/ (/ (/ 1/ +/ L/ )/ n/ )/ ./ 因为/ L/ 为/ 一个/ 远/ 小于/ n/ 的/ 常数/ ,/ 所以/ Map/ 阶段/ 的/ 算法/ 复杂度/ 为/ O/ (/ n/ )/ ./ Reduce/ 阶段/ 的/ 算法/ 复杂度/ 为/ O/ (/ n/ )/ ./ 故/ 整个/ 参数估计/ 子/ 模块/ 的/ 算法/ 复杂度/ 为/ O/ (/ n/ )/ ./ 优化/ 前后/ ,/ 参数估计/ 子/ 模块/ 的/ 算法/ 复杂度/ 一直/ 是/ O/ (/ n/ )/ ,/ 填充/ 子/ 模块/ 未/ 做/ 优化/ ./ 整个/ 缺失/ 值/ 填充/ 模图/ 5/ 实体/ 识别/ 模块/ 3.2/ 系统分析/ 与/ 优化/ 通过/ 研究/ 发现/ 初步/ 聚类/ 模块/ 和/ 实体/ 识别/ 模块/ ,/ 对/ 预处理/ 结果/ 重复/ 利用/ 了/ N/ 次/ (/ N/ 为/ 待处理/ 数据/ 每条/ 元组/ 包含/ 的/ 属性/ 个数/ )/ ,/ 而且/ 后续/ 的/ 实体/ 识别/ 模块/ 也/ 是/ 在/ 单一/ 属性/ 上/ 处理/ 的/ ./ 如果/ 将/ 预处理/ 模块/ 和/ 实体/ 识别/ 模块/ 看作/ 一个/ 整体/ (/ 系统/ 实际/ 应用/ 中/ 也/ 是/ 这样/ 的/ )/ ,/ 那么/ 就是/ 对/ 输入/ 数据文件/ 扫描/ 多次/ ,/ 并且/ 只能/ 利用/ 输入/ 数据/ 中/ 的/ 一部分/ ,/ 系统对/ 输入/ 数据/ 的/ 利用率/ 很/ 低/ ./ 此外/ 系统/ 每次/ 分配任务/ 都/ 需要/ 消耗/ 额外/ 的/ 资源/ ./ 我们/ 需要/ 将/ 分开/ 处理/ 各个/ 属性/ 的/ 初步/ 聚类/ 块/ 的/ MapReduce/ 轮数/ 和/ IO/ 次数/ 均/ 由/ 优化/ 前/ 的/ 3/ 变为/ 2/ ,/ 加速/ 比为/ 3/ // 2/ ,/ 优化/ 效果/ 明显/ ./ 3/ 优化/ 的/ 实体/ 识别/ 实体/ 识别/ ,/ 就是/ 识别/ 出/ 同一/ 实体/ 的/ 不同/ 表现形式/ ./ 不同/ 的/ 数据/ 来源/ 对/ 同一/ 对象/ 的/ 表示/ 形式/ 往往/ 有着/ 不同/ 的/ 要求/ ,/ 并且/ 在/ 数据/ 的/ 存储/ 和/ 传递/ 过程/ 中均/ 会/ 产生/ 不可避免/ 的/ 错误/ ,/ 因此/ 产生/ 了/ 同一/ 实体/ 的/ 不同/ 表现形式/ ./ 关于/ MapReduce/ 框架/ 下/ 的/ 实体/ 识别/ 技术/ ,/ 现在/ 已经/ 有/ 了/ 相关/ 研究/ 工作/ [/ 18/ -/ 19/ ]/ ,/ 但是/ 他们/ 只/ 解决/ 了/ 异名/ 实体/ 识别/ 问题/ ,/ 对/ 同名/ 问题/ 没有/ 进行/ 研究/ ;/ 而/ 我们/ 的/ 工作/ 可以/ 同时/ 解决/ 了/ 异名/ 和/ 同名/ 问题/ ./ 3.1/ 实体/ 识别/ 模块/ 介绍/ (/ 1/ )/ 预处理/ ./ 系统/ 读/ 入海量/ 数据文件/ 并/ 进行/ 预处理/ ,/ 给/ 每/ 一条/ 输入/ 元组/ 加上/ 一个/ 唯一/ 的/ 序号/ —/ —/ —/ 实体/ ID/ ,/ 方便/ 后续/ 处理/ ./ (/ 2/ )/ 初步/ 聚类/ ./ 读取/ 预处理/ 模块/ 生成/ 的/ 数据/ ,/ 按照/ 相同/ 属性/ 值/ 进行/ 初步/ 聚类/ ,/ 生成/ 属性/ 索引/ 表/ ./ (/ 3/ )/ 实体/ 识别/ ./ 对/ 实体/ 进行/ 识别/ ,/ 对/ 同一/ 属性/ 索引/ 表中/ 的/ 实体/ 对/ 计算/ 相似/ 度/ 并/ 与/ 阈值/ 进行/ 比较/ ,/ 大于/ 阈值/ 的/ 相似/ 对/ 输出/ 成/ 相似/ 对/ 集合/ 文件/ ./ (/ 4/ )/ 实体/ 划分/ ./ 依据/ 相似/ 对/ 集合/ 文件/ 生成/ 图/ ,/ 通过/ 对图/ 的/ 划分/ 获得/ 实体/ 划分/ 结果/ ./ 以上/ 是/ 对/ 实体/ 识别/ 模块/ 的/ 简要/ 介绍/ ,/ 详细/ 介绍/ 参考文献/ [/ 20/ ]/ ./ 和/ 实体/ 识别/ 合并/ 成/ 一次/ 能/ 处理/ 所有/ 属性/ 进而/ 只/ 运行/ 一轮/ 就/ 能/ 处理/ 每条/ 元组/ 所有/ 属性/ 的/ 解决方案/ ./ 为此/ 本文/ 针对/ 实体/ 识别/ 模块/ 提出/ 的/ 优化/ 思想/ 是/ :/ 在/ 初步/ 聚类子/ 模块/ 一次/ 处理/ 所有/ 属性/ ,/ 生成/ 所有/ 属性/ 值/ 的/ 属性/ 索引/ 表/ ./ 这样/ 就/ 能/ 将/ 原来/ 按/ 属性/ 分开/ 处理/ 的/ 预处理/ 和/ 实体/ 识别/ 合并/ 起来/ ./ 下面/ 给出/ 具体/ 的/ 优化/ 方案/ 和/ 算法/ ./ (/ 1/ )/ 初步/ 聚类子/ 模块/ ,/ map/ 阶段/ 不是/ 仅仅/ 输出/ 第/ i/ 个/ 属性/ 值/ ,/ 而是/ 将/ 所有/ 属性/ 值/ 都/ 输出/ ./ 但是/ 为了/ 区分/ 初步/ 聚类/ 产生/ 的/ 结果/ —/ —/ —/ 属性/ 索引/ 表/ 集合/ 中/ 的/ Page6/ 实体/ ID/ 是/ 来自/ 不同/ 的/ 属性/ ,/ 系统/ 在/ map/ 输出/ 数据/ 的/ key/ 上/ 做/ 了/ 一些/ 改动/ ,/ 在/ 原/ key/ 前/ 加上/ 了/ 一个/ 前缀/ ,/ 由/ “/ 属性/ 值/ ”/ 变成/ “/ 属性/ 序号/ $/ 属性/ 值/ ”/ ./ 因为/ MapReduce/ 是/ 按照/ key/ 进行/ 分类/ 的/ ,/ 所以/ 只有/ 同一/ 属性/ 的/ 具有/ 相同/ 属性/ 值/ 的/ 实体/ 才/ 会/ 进入/ 同一/ 属性/ 索引/ 表/ ./ reduce/ 阶段/ 将/ 属性/ 序号/ 作为/ 实体/ ID/ 的/ 前缀/ 加/ 在/ 实体/ ID/ 中/ ./ 以下/ 是/ 优化/ 后/ 的/ 初步/ 聚类/ 算法/ ./ 算法/ 2/ ./ 初步/ 聚类/ 算法/ ./ 输入/ :/ 关系/ 表/ 输出/ :/ 属性/ 索引/ 表/ Map/ 〈/ LongWritable/ ,/ Text/ ,/ Text/ ,/ Text/ 〉/ Input/ :/ key/ =/ 实体/ ID/ ,/ value/ =/ 元组/ 1/ ./ FOReach/ 〈/ key/ ,/ value/ 〉/ DO2/ ./ FOReach/ 属性/ DO3/ ./ outkey/ ·/ ·/ =/ 属性/ ID/ +/ “/ $/ ”/ +/ 属性/ 值/ ,/ Reduce/ 〈/ Text/ ,/ Text/ ,/ NullWritable/ ,/ Text/ 〉/ 1/ ./ FOReachvalueinvaluelistDO2/ ./ 实体/ ID/ ·/ ·/ =/ 属性/ ID/ +/ “/ $/ ”/ +/ 实体/ ID3/ ./ outkey/ ·/ ·/ =/ null/ ,/ outvalue/ ·/ ·/ =/ allthe/ 实体/ IDinvaluelist/ 其中/ 实体/ ID/ 是/ 每个/ 元组/ 的/ 编号/ ,/ 在/ 预处理/ 阶段/ 为/ 每/ 一个/ 元组/ (/ 一行/ 数据/ )/ 设定/ 唯一/ 的/ 实体/ ID/ ./ 属性/ ID/ 是/ 属性/ 在/ 元组/ 中/ 的/ 顺序/ ./ 下面/ 举例说明/ 优化/ 后/ 的/ 算法/ 流程/ ,/ 待/ 识别/ 数据/ 如表/ 4/ 所示/ ./ Map/ 阶段/ 将/ 所有/ 元组/ 的/ 按/ 属性/ 拆分/ 后/ 输出/ ,/ 结果/ 如表/ 5/ 所示/ ./ 属性/ 值/ 相同/ 的/ 实体/ 会/ 进入/ 同一个/ reduce/ ,/ 并/ 输出/ 成/ 属性/ 索引/ 表/ ,/ 如表/ 6/ 所示/ ./ 实体/ ID123/ 优化/ 后/ 的/ 初步/ 聚类/ 模块/ ,/ map/ 阶段/ 的/ 算法/ 复杂度/ 为/ O/ (/ n/ (/ x/ +/ x2/ )/ )/ ,/ 其中/ x/ 为/ 属性/ 个数/ ,/ 实际/ 应用/ 中/ x/ 为/ 一个/ 很小/ 的/ 常/ 数值/ ,/ 故其/ 计算/ 复杂度/ 为/ O/ (/ n/ )/ ./ reduce/ 阶段/ 除了/ 在/ 附加/ 的/ 读取/ 属性/ 序号/ 外/ 没有/ 任何/ 改动/ ,/ 其/ 计算/ 复杂度/ 为/ O/ (/ n/ )/ ./ 综上/ 整个/ 初步/ 聚类/ 模块/ 的/ 算法/ 复杂度/ 为/ O/ (/ n/ )/ ./ (/ 2/ )/ 实体/ 识别/ 子/ 模块/ ,/ 因为/ 整个/ 实体/ 识别/ 模块/ 是/ 在/ 初步/ 聚类/ 生成/ 的/ 属性/ 索引/ 表中/ 进行/ 的/ ,/ 而/ 初步/ 聚类/ 模块/ 的/ 改动/ 保证/ 了/ 同一/ 属性/ 的/ 具有/ 相同/ 属性/ 值/ 的/ 实体/ ID/ 聚集/ 在/ 同一个/ 属性/ 索引/ 表中/ ,/ 所以/ 这一/ 模块/ 的/ 算法/ 不/ 需要/ 修改/ ./ 除了/ 在/ 第/ 3/ 个/ MapReduce/ 的/ reduce/ 阶段/ 去除/ 实体/ ID/ 中/ 包含/ 的/ 前缀/ 外/ ,/ 没有/ 任何/ 更改/ ./ 这样/ 做/ 的/ 目的/ 是/ 为了/ 使/ 同一/ 实体/ 的/ 相似/ 度/ 能够/ 在/ 第/ 4/ 个/ MapReduce/ 中/ 汇合/ ./ 整个/ 实体/ 识别/ 模块/ 的/ 算法/ 没有/ 经过/ 改动/ ,/ 所以/ 其/ 算法/ 的/ 时间/ 复杂度/ 仍/ 保持/ O/ (/ n/ )/ ./ 由于/ 本文/ 只/ 对系统/ Hadoop/ 上/ 运行/ 部分/ 进行/ 优化/ 处理/ ,/ 所以/ 将/ 实体/ 划分/ 模块/ 视作/ 常量/ ./ 在/ 时间/ 复杂度/ 方面/ ,/ 从/ 上/ 一/ 小节/ 对/ 实体/ 识别/ 子系统/ 的/ 介绍/ 和/ 本/ 小节/ 前面/ 的/ 一部分/ 的/ 优化/ 方案/ 中/ 算法/ 的/ 计算/ 复杂度/ 可以/ 看出/ ,/ 优化/ 前后/ 没有/ 改变/ 各个/ 模块/ 以及/ 各个/ 模块/ 内部/ 的/ 各个/ MapReduce/ 的/ 计算/ 复杂度/ ./ 优化/ 前/ 的/ MapReduce/ 轮数/ 为/ 1/ +/ N/ (/ 1/ +/ 4/ )/ =/ 5N/ +/ 1/ ,/ 优化/ 之后/ 的/ MapReduce/ 轮数/ 为/ 1/ +/ 1/ +/ 4/ =/ 6/ ,/ 加速/ 比/ 为/ (/ 5N/ +/ 1/ )/ // 6/ ./ 正常/ 情况/ 下/ N/ 大于/ 1/ ,/ 所以/ 加速/ 比/ 大于/ 1/ ,/ 并且/ N/ 越大/ 加速/ 效果/ 越/ 明显/ ./ IO/ 次数/ 也/ 由/ 先前/ 的/ 5N/ +/ 1/ 次/ 变为/ 6/ 次/ ,/ IO/ 次数/ 减少/ 使得/ 系统/ 用于/ IO/ 的/ 时间/ 减少/ ./ 另外/ 由于/ MapReduce/ 的/ 轮数/ 减少/ ,/ 系统/ 用于/ 任务调度/ 的/ 时间/ 和/ 资源/ 也/ 相应/ 减少/ ./ 综上/ ,/ 从/ 理论/ 上/ 讲/ ,/ 通过/ 本文/ 的/ 提供/ 的/ 优化/ 方案/ 能/ 产生/ 明显/ 的/ 优化/ 效果/ ./ 4/ 优化/ 的/ 不/ 一致/ 数据/ 修复/ 在/ 实际/ 的/ 数据库系统/ 及/ 相关/ 应用/ 中/ 由于/ 种种原因/ ,/ 其中/ 包含/ 的/ 数据/ 违反/ 最初/ 定义/ 的/ 完整性/ 约束/ ,/ 所以/ 存在/ 大量/ 不/ 一致/ 数据/ ./ 本/ 系统/ 利用/ 数据/ 依赖/ 理论/ 中/ 的/ 条件/ 函数/ 依赖/ 原理/ ,/ 定义/ 完整性/ 约束/ ,/ 利用/ 完整性/ 约束/ 进行/ 不/ 一致/ 数据/ 修复/ ./ 本文/ 的/ 重点/ 在于/ 提高/ 不/ 一致/ 数据/ 修复/ 模块/ 的/ 性能/ 和/ 效率/ ,/ 使/ 之/ 一致/ ./ 至于/ 如何/ 保证/ 这样/ 的/ 修改/ 过程/ 是/ 正确/ 的/ ,/ 是/ 由/ 条件/ 函数/ 依赖/ 理论/ 所/ 决定/ 的/ ,/ 本文/ 相关/ 的/ 理论/ 证明/ 和/ 推导/ 详见/ 文献/ [/ 9/ -/ 10/ ]/ ./ Page74/ ./ 1/ 不/ 一致/ 数据/ 修复/ 模块/ 介绍/ 不/ 一致/ 数据/ 修复/ 模块/ 步骤/ 的/ 简要/ 介绍/ 如下/ :/ (/ 1/ )/ 系统/ 读入/ 待/ 修复/ 的/ 海量/ 数据文件/ 和/ cfds/ 文件/ 并/ 进行/ 预处理/ ,/ 将/ 数据格式/ 更/ 改成/ 符合/ 系统/ 要求/ 的/ 格式/ 并/ 对/ cfds/ 进行/ 初步/ 检测/ ,/ 方便/ 后续/ 处理/ ./ (/ 2/ )/ 对/ 预处理/ 结果/ 中/ 的/ 数据文件/ 进行/ 检测/ 与/ 修复/ ,/ 得到/ 初次/ 修复/ 结果/ ./ (/ 3/ )/ 对/ 初次/ 修复/ 结果/ 进行/ 检测/ ,/ 判断/ 修复/ 工作/ 是否/ 引入/ 了/ 新/ 的/ 不/ 一致/ ./ 若/ 引入/ 了/ 新/ 的/ 不/ 一致/ 则/ 返回/ 步骤/ (/ 1/ )/ ,/ 否则/ 进入/ 步骤/ (/ 3/ )/ ./ 当然/ 为了/ 避免/ 系统/ 陷入/ 死循环/ ,/ 系统/ 为/ 检测/ 与/ 修复/ 的/ 次数/ 设置/ 了/ 一个/ 上限/ ./ (/ 4/ )/ 对/ 修复/ 结果/ 进行/ 后处理/ ,/ 将/ 数据格式/ 更/ 改成/ 数据/ 的/ 原始/ 格式/ ,/ 使得/ 修复/ 结果/ 能/ 正常/ 被/ 其他/ 系统/ 使用/ ./ 以上/ 是/ 对/ 实体/ 识别/ 模块/ 的/ 简要/ 介绍/ ,/ 详细/ 介绍/ 见/ 参考文献/ [/ 21/ ]/ ./ 4.2/ 系统分析/ 与/ 优化/ 不/ 一致/ 数据/ 修复/ 子系统/ 的/ 4/ 个/ 模块/ 中除/ 第/ 1/ 个/ 模块/ 的/ CFD/ 一致性/ 检测/ 子/ 模块/ 外/ 都/ 是/ 在/ MapReduce/ 编程/ 框架/ 上/ 实现/ 的/ ,/ 在/ 本文/ 的/ 研究/ 范围/ 内/ ./ 本/ 模块/ 的/ 一个/ 重要/ 缺点/ 是/ 没有/ 掌握/ MapReduce/ 编程/ “/ 分解/ 与/ 合并/ ”/ 的/ 精髓/ ,/ 将/ 本来/ 仅/ 需要/ 一个/ Map/ 或者/ 一轮/ MapReduce/ 便/ 可/ 完成/ 的/ 任务/ 拆/ 分成/ 一轮/ 或/ 多轮/ MapReduce/ ,/ 由此/ 使/ 系统/ 效率/ 下降/ ./ 为此/ 我们/ 在/ 不/ 改变/ 系统/ 算法/ 复杂度/ 的/ 条件/ 下/ 进行/ 任务/ 合并/ ./ (/ 1/ )/ 预处理/ 模块/ 预处理/ 模块/ 的/ 脏/ 数据/ 预处理/ 子/ 模块/ 功能/ 很/ 简单/ ,/ 就是/ 给/ 输入/ 数据/ 建立/ 索引/ ,/ 实施/ 过程/ 中/ 没有/ 涉及/ 到/ 数据/ 的/ 分解/ 与/ 合并/ ,/ 可以/ 通过/ 一个/ map/ 函数/ 实现/ ./ 算法/ 如下/ ./ 算法/ 3/ ./ 预处理/ 算法/ ./ 输入/ :/ 脏/ 数据文件/ 输出/ :/ 预处理/ 结果/ Map/ 〈/ Object/ ,/ Text/ ,/ NullWritable/ ,/ Text/ 〉/ Input/ :/ key/ =/ offset/ ,/ value/ =/ tuple1/ ./ FOReach/ 〈/ key/ ,/ value/ 〉/ DO2/ ./ outkey/ ·/ ·/ =/ null/ ,/ outvalue/ ·/ ·/ =/ key/ +/ value/ ;/ 显而易见/ ,/ 本/ 模块/ 的/ 算法/ 复杂度/ 为/ O/ (/ n/ )/ ./ (/ 2/ )/ 不/ 一致/ 数据/ 检测/ 与/ 修复/ 模块/ 不/ 一致/ 数据/ 的/ 检测/ 与/ 修复/ 模块/ 中/ 常量/ 违反/ 检测/ 与/ 修复/ 模块/ 通过/ 一轮/ MapReduce/ 实现/ ,/ map/ 阶段/ 将/ 元组/ 重新/ 分发/ 了/ M/ 份/ (/ M/ 为/ 输入/ 元组/ 发生/ 常量/ 违反/ 的/ 次数/ )/ ,/ 尽管/ M/ 实际/ 值/ 一般/ 不/ 大/ ,/ 对/ reduce/ 阶段/ 的/ 计算/ 复杂度/ 几乎/ 没有/ 影响/ ./ 但是/ M/ 的/ 存在/ 会/ 使/ 中间/ 数据量/ 扩大/ M/ 倍/ ,/ 对系统/ 通信/ 造成/ 很大/ 负担/ ./ 更/ 重要/ 的/ 是/ 在/ 系统/ 计算/ 出/ 建议/ 修复/ 值/ 的/ 同时/ 就/ 可以/ 将/ 其/ 修复/ ,/ 那么/ 就/ 没有/ 必要/ 将/ 找到/ 建议/ 修复/ 值/ 的/ 过程/ 和/ 修复过程/ 分开/ ./ 为此/ 本文/ 提出/ 的/ 优化/ 方案/ 是/ 利用/ 一个/ map/ 函数/ 实现/ 常量/ 违反/ 检测/ 与/ 修复/ 子/ 模块/ ./ 将/ 常量/ 违反/ 与/ 修复/ 子/ 模块/ 通过/ 一个/ map/ 函数/ 实现/ 之后/ ,/ 经过/ 常量/ 违反/ 修复/ 的/ 数据/ 直接/ 进入/ 变量/ 违反/ 修复/ 环节/ ./ 两者/ 输入/ 数据/ 的/ 格式/ 是/ 相同/ 的/ ,/ 假如/ 原始数据/ 中/ 不/ 存在/ 常量/ 违反/ ,/ 那么/ 两者/ 输入/ 文件/ 就是/ 完全相同/ 的/ ./ 基于/ 上述/ 观点/ ,/ 本文/ 提出/ 了/ 将/ 常量/ 违反/ 修复/ 与/ 变量/ 违反/ 修复/ 合并/ 的/ 优化/ 方案/ ./ 在/ 这个/ 优化/ 方案/ 中/ 常量/ 违反/ 修复/ 位于/ 原/ 变量/ 违反/ 修复/ 的/ 第/ 1/ 轮/ MapReduce/ 的/ 前端/ ,/ 让/ 常量/ 违反/ 的/ 结果/ 在/ Map/ 函数/ 内部/ 直接/ 应用/ 于/ 变量/ 违反/ ./ 算法/ 如下/ ./ 算法/ 4/ ./ 不/ 一致/ 数据/ 监测/ 与/ 修复/ 第/ 1/ 轮/ Map/ -/ Reduce/ 中/ Map/ 算法/ ./ 输入/ :/ 预处理/ 结果/ 输出/ :/ 变量/ 违反/ 第/ 1/ 轮/ MapReduce/ 的/ Map/ 输出/ Input/ :/ key/ =/ offset/ ,/ value/ =/ tupleMap/ 〈/ Object/ ,/ Text/ ,/ Text/ ,/ Text/ 〉/ 1/ ./ FOReachCFD/ α/ =/ (/ R/ :/ X/ →/ Y/ ,/ tp/ )/ DO2/ ./ IFtuple/ [/ X/ ]/ 3/ ./ tuple/ [/ Y/ ]/ 4/ ./ FOReachCFD/ α/ =/ (/ R/ :/ X/ →/ Y/ ,/ tp/ )/ DO5/ ./ IFTHEN6/ ./ outkey/ ·/ ·/ =/ (/ cfdindex/ ,/ ptindex/ ,/ attrindex/ ,/ 1/ )/ ,/ 7/ ./ FOReachtuplethatnotmatchCFDwithvariables8/ ./ outkey/ ·/ ·/ =/ (/ cfdindex/ ,/ ptindex/ ,/ attrindex/ ,/ 0/ )/ ,/ 其中/ ,/ offset/ 为/ 元组/ 索引/ 值/ ,/ tuple/ 表示/ 该条/ 元组/ ,/ fix/ _/ tag/ 为/ 修复/ 标志/ ,/ 用来/ 区分/ 是否/ 发生/ 违反/ 需要/ 修复/ ,/ 0/ 表示/ 发生/ 违反/ 需要/ 修复/ ,/ 1/ 表示/ 不/ 需要/ 修复/ ./ cfdindex/ 是/ tuple/ 违反/ 的/ CFD/ 的/ 序号/ ,/ ptindex/ 是/ 该/ tuple/ 违反/ 的/ CFD/ 的/ 模式/ 表中/ 的/ 模式/ 元组/ 序号/ ,/ attrindex/ 标志/ 该/ tuple/ 的/ 不/ 一致/ 数据项/ 的/ 属性/ 序号/ ,/ fixvalue/ 即/ 为/ 该/ 属性/ 值应/ 修复/ 的/ 结果/ ./ 算法/ 4/ 的/ 计算/ 复杂度/ 为/ O/ (/ n/ )/ ./ 算法/ 的/ 流程图/ 如图/ 6/ 所示/ ./ Page8/ 下面/ 举例说明/ 优化/ 后/ 的/ 算法/ 流程/ ,/ 待/ 修复/ 数据/ 如表/ 7/ 所示/ ./ 为了/ 便于/ 说明/ ,/ 本例/ 中仅/ 使用/ 1/ 条/ cfd/ 和/ 一个/ tp/ ,/ 分别/ 为/ 1/ :/ (/ [/ CC/ ,/ AC/ ,/ PN/ ]/ →/ [/ STR/ ,/ CT/ ,/ ST/ ]/ )/ 和/ T1/ :/ 01/ ,/ 908/ ,/ _/ ,/ _/ ,/ MH/ ,/ _./ Map/ 阶段/ 将/ 每/ 一条/ 输入/ 的/ 待/ 修复/ 元组/ 与/ 模式/ 元组/ tp/ 作/ 比较/ ,/ 进行/ 常量/ 违反/ 修复/ ,/ 然后/ 再/ 进行/ 变量/ 违反/ 修复/ ./ 第/ 1/ 条/ 元组/ 没有/ 发生/ 常量/ 违反/ ,/ 遂/ 进入/ 变量/ 违反/ 修复/ 环节/ ,/ 其/ map/ 输出/ 为表/ 8/ 中/ 第/ 1/ 行/ ./ 第/ 2/ 条/ 元组/ 发生/ 常量/ 违反/ ,/ 经常/ 量/ 违反/ 修复/ 进入/ 变量/ 违反/ 修复/ 环节/ ,/ 其/ map/ 输出/ 为表/ 8/ 中/ 第/ 2/ 行/ ./ 下同/ ./ offsetCCACPNNM1090190811Mike1500190811RickTreeAveStr/ ./ NYC079741900190811DavidTreeAve2280190866JoJokey0/ ,/ 0/ ,/ 2/ ,/ 1109/ #/ 01/ ,/ 908/ ,/ 11/ ,/ Mike/ ,/ TreeAve/ ,/ MH/ ,/ 079740/ ,/ 0/ ,/ 2/ ,/ 1150/ #/ 01/ ,/ 908/ ,/ 11/ ,/ Rick/ ,/ TreeAveStr/ ,/ MH/ ,/ 079740/ ,/ 0/ ,/ 2/ ,/ 1190/ #/ 01/ ,/ 908/ ,/ 11/ ,/ David/ ,/ TreeAve/ ,/ MH/ ,/ 033330/ ,/ 0/ ,/ 2/ ,/ 1228/ #/ 01/ ,/ 908/ ,/ 66/ ,/ JoJo/ ,/ TreeAve/ ,/ MH/ ,/ 07974/ 在/ 时间/ 复杂度/ 方面/ ,/ 从/ 预处理/ 小节/ 和/ 本/ 小节/ 优化/ 方案/ 中/ 算法/ 的/ 计算/ 复杂度/ 可以/ 看出/ ,/ 优化/ 前后/ 没有/ 改变/ 各个/ 模块/ 以及/ 各个/ 模块/ 内部/ 的/ 各个/ MapReduce/ 的/ 计算/ 复杂度/ ./ 在/ MapReduce/ 轮数/ 和/ IO/ 次数/ 方面/ ,/ 系统/ 的/ MapReduce/ 轮数/ 由/ 优化/ 前/ 的/ 1/ +/ 1/ +/ 2/ +/ 1/ +/ 1/ +/ 1/ =/ 7/ 变成/ 优化/ 后/ 的/ 1/ +/ 2/ +/ 1/ +/ 1/ =/ 5/ ./ 仅/ 从/ MapReduce/ 轮数/ 来看/ 系统/ 的/ 加速/ 比为/ 7/ // 5/ ./ 此外/ 系统/ 的/ 优化/ 工作/ 还/ 使得/ 预处理/ 模块/ 的/ MapReduce/ 变成/ 了/ map/ ,/ 这/ 也/ 会/ 相应/ 地/ 减少/ 系统/ 的/ 运行/ 时间/ ./ 随着/ MapReduce/ 轮数/ 的/ 减少/ ,/ 系统/ 的/ IO/ 次数/ 也/ 相应/ 地/ 减少/ ,/ 这/ 也/ 使得/ 系统/ 的/ IO/ 负担/ 减小/ ./ 综上所述/ ,/ 通过/ 本文/ 提供/ 的/ 优化/ 方案/ ,/ 不/ 一致/ 修复/ 子系统/ 会/ 获得理想/ 的/ 优化/ 效果/ ./ 5/ 实验/ 结果/ 整个/ 系统/ 在/ Ubuntu12/ ./ 04.1/ 操作系统/ 中/ 的/ Hadoop1/ ./ 2.1/ 平台/ 上/ ,/ 用/ java/ 语言/ 实现/ ,/ 软件开发/ 环境/ 为/ Eclipse/ ./ 实验/ 运行/ 的/ 集群/ 采用/ 12/ 个/ 节点/ ,/ 1/ 个/ tasktraker/ (/ namenode/ )/ ,/ 11/ 个/ jobtracker/ (/ data/ -/ node/ )/ ./ 集群/ 由/ 12/ 台/ 机器/ 组成/ ,/ 硬件/ 环境/ 为/ Inteli73770/ 处理器/ ,/ 主频/ 为/ 3.4/ GHz/ ,/ 内存/ 8GB/ ,/ 1TB/ 硬盘空间/ ./ 5.1/ 实体/ 识别/ 优化/ 实验/ 为了/ 使/ 系统/ 的/ 优化/ 效果/ 更/ 有/ 说服力/ ,/ 所有/ 实验/ 数据/ 是/ 来自/ DBLP/ 的/ 真实/ 数据/ 集/ ./ 针对/ 系统/ 的/ 特点/ ,/ 实验/ 分别/ 从/ 扩展性/ 、/ 集群/ 的/ 并行/ 化/ 程度/ 和/ 数据/ 的/ 属性/ 个数/ 3/ 个/ 方面/ 验证/ 系统/ 的/ 优化/ 效果/ ./ DBLP/ 的/ 数据/ 规模/ 并不大/ ,/ 看似/ 不/ 需要/ 在/ Hadoop/ 上/ 实现/ ./ 但/ 大家/ 公认/ 的/ 数据源/ 往往/ 数据量/ 比较/ 小/ ,/ 使用/ DBLP/ 数据/ 集/ 的/ 意义/ 不是/ 因为/ 其/ 规模/ 而是/ 在于/ DBLP/ 数据/ 集是/ 真实/ 数据/ ,/ 这样/ 做/ 可以/ 增加/ 本文/ 实验/ 结果/ 的/ 可信度/ ./ 5.1/ ./ 1/ 扩展性/ 实验/ 本/ 实验/ 考虑/ 数据/ 集合/ 大小/ 对/ 优化/ 效果/ 的/ 影响/ ,/ 实验/ 采用/ 由/ 真实/ 数据/ 集/ DBLP/ 数据/ 集/ ,/ 选择/ 其中/ 的/ title/ ,/ authorandco/ -/ author/ ,/ journalorurl/ 这/ 3/ 个/ 属性/ ,/ 选择/ 大小/ 分别/ 为/ 13.2/ MB/ 、/ 32.3/ MB/ 、/ 64.9/ MB/ 、/ 97.1/ MB/ 、/ 128.9/ MB/ 的/ 数据/ 作为/ 实验/ 数据/ ./ 实验/ 中/ 各/ 属性/ 的/ 权值/ 分别/ 为/ 0.9/ 、/ 0.05/ 、/ 0.05/ ,/ 实验/ 结果/ 如图/ 7/ 所示/ ./ 实验/ 中/ 对比/ 了/ 基本/ 的/ 实现/ (/ Nave/ )/ 、/ 文献/ [/ 19/ ]/ 中/ 的/ BlockSplit/ 和/ PairRange/ 与/ 基于/ 本文/ 中/ 任务/ 合并/ 的/ 优化/ 方法/ 优化/ 后/ 的/ 实体/ 识别/ 4/ 种/ 方法/ 在/ 不同/ 数据/ 集合/ 大小/ 下/ 的/ 运行/ 结果/ ./ Page9/ 随着/ 数据/ 集合/ 的/ 增大/ ,/ 优化/ 前后/ 系统/ 的/ 运行/ 时间/ 都/ 在/ 增加/ ,/ 但是/ 优化/ 前/ 和/ 优化/ 后/ 系统/ 运行/ 时间/ 的/ 比值/ (/ 加速/ 比/ )/ 均/ 在/ 2.3/ 左右/ ./ 这/ 是因为/ 本次/ 实验所/ 使用/ 的/ 数据/ 具有/ 3/ 个/ 属性/ ,/ 按照/ 2.2/ 节中/ 对/ 优化/ 效果/ 的/ 分析/ ,/ 应/ 具有/ 的/ 理论/ 加速/ 比/ 为/ (/ 5/ ×/ 3/ +/ 1/ )/ // 6/ =/ 2.67/ 与/ 实验/ 结果/ 一致/ ./ 由于/ 基于/ BlockSplit/ 和/ Pair/ -/ Range/ 方法/ 的/ 实体/ 识别/ 实现/ 过程/ 的/ 运行/ 时间/ 比/ 基于/ 任务/ 合并/ 的/ 优化/ 方法/ 复杂/ ,/ 故其/ 运行/ 时间/ 均/ 比/ 本文/ 提出/ 的/ 优化/ 方法/ 对应/ 的/ 运行/ 时间/ 长/ ./ 本/ 实验/ 说明/ 优化/ 设计方案/ 有/ 良好/ 的/ 扩展性/ ./ 5.1/ ./ 2/ 集群/ 的/ 并行/ 化/ 程度/ 对/ 优化/ 效果/ 的/ 影响/ 实验/ 考虑/ 集群/ 中/ Reduce/ 个数/ 对/ 优化/ 效果/ 的/ 影响/ ,/ 实验/ 采用/ 由/ 真实/ 数据/ 集/ DBLP/ 数据/ 集/ ,/ 选择/ 其中/ 的/ title/ ,/ authorandco/ -/ author/ ,/ journalorurl/ 这/ 3/ 个/ 属性/ ,/ 选择/ 大小/ 分别/ 为/ 128.9/ MB/ 含有/ 100000/ 条/ 记录/ 的/ 数据/ 作为/ 实验/ 数据/ ./ 实验/ 中/ 各/ 属性/ 的/ 权值/ 分别/ 为/ 0.9/ 、/ 0.05/ 、/ 0.05/ ,/ 设置/ Reduce/ 个数/ 为/ 2/ 、/ 4/ 、/ 6/ 、/ 8/ 、/ 10/ ,/ 实验/ 结果/ 如图/ 8/ 所示/ ,/ 在/ 不同/ 的/ 并行/ 化/ 程度/ 下/ 优化/ 效果/ 明显/ ./ 从图/ 8/ 中/ 可以/ 看出/ 系统/ 运行/ 时间/ 随/ 并行/ 化/ 程度/ 的/ 增强/ 而/ 变长/ ,/ 这/ 不/ 符合/ 大家/ 普遍认为/ 的/ “/ 并行/ 化/ 程度/ 越高/ ,/ 系统/ 运行/ 时间/ 越短/ ”/ 的/ 常识/ ./ 产生/ 这一/ 现象/ 的/ 原因/ 是/ ,/ 实验/ 数据/ 集/ 数据量/ 较/ 小/ ,/ 增加/ 系统/ 的/ 并行度/ 给/ 系统/ 带来/ 的/ 开销/ 要/ 大于/ 由此/ 带来/ 的/ 好处/ ./ 无论如何/ ,/ 系统/ 在/ 不同/ 的/ 并行度/ 下/ 达到/ 了/ 大约/ 2.3/ 的/ 加速/ 比/ ,/ 优化/ 效果/ 符合/ 预期/ ./ 5.1/ ./ 3/ 数据/ 集/ 的/ 属性/ 个数/ 对/ 优化/ 效果/ 的/ 影响/ 针对/ 优化/ 方案/ 的/ 主要/ 思想/ :/ 充分利用/ 输入/ 记录/ 中/ 的/ 所有/ 属性/ ,/ 设计/ 了/ 本/ 实验/ ./ 实验/ 研究/ 输入/ 元组/ 中/ 的/ 属性/ 个数/ 对/ 优化/ 效果/ 的/ 影响/ ./ 实验/ 结果/ 如图/ 9/ 所示/ ,/ 在/ 处理/ 同样/ 大小/ (/ 记录/ 条数/ )/ 的/ 记录/ 时/ ,/ 随着/ 记录/ 中/ 包含/ 的/ 属性/ 的/ 增多/ ,/ 优化/ 效果/ 越来越/ 好/ ./ 从/ 上述/ 数据/ 可以/ 看到/ :/ 当/ 处理/ 的/ 元组/ 包含/ 一条/ 属性/ 时/ ,/ 系统/ 的/ 优化/ 效果/ 最差/ ,/ 比/ 优化/ 前/ 运行/ 效率/ 还要/ 低/ ;/ 但是/ 随着/ 属性/ 的/ 增加/ 优化/ 效果/ 越来越/ 好/ ./ 本文/ 的/ 优化/ 工作/ 针对/ 的/ 是/ 系统/ 在/ 处理/ 多/ 属性/ 时/ 不能/ 充分利用/ 输入/ 数据/ ,/ 并且/ 通过/ 循环/ 处理/ 每/ 一个/ 属性/ 增加/ 了/ MapReduce/ 轮数/ ;/ 但是/ 处理/ 单/ 属性/ 元组/ 时/ 优化/ 后/ 的/ 方案/ 产生/ 的/ 中间/ 数据量/ 多于/ 优化/ 前/ ,/ 并且/ 处理过程/ 变得/ 更加/ 复杂/ ,/ 因此/ 产生/ 了/ 上述/ 实验/ 现象/ ./ 5.2/ 不/ 一致/ 数据/ 数据/ 修复/ 优化/ 实验/ 为了/ 验证/ 系统/ 在/ 真实/ 生产/ 环境/ 中/ 的/ 工作/ 状态/ ,/ 实验/ 采用/ 来自/ 真实/ 数据/ 集/ Adult/ 的/ 数据/ 和/ 由/ TPC/ -/ H/ 生成/ 的/ 数据/ 集/ ./ 进行/ 了/ 在/ Adult/ 数据/ 集上/ 的/ 加速/ 比/ 验证/ 实验/ 、/ 在/ 人工/ 数据/ 集上/ 的/ 扩展性/ 和/ 并行性/ 验证/ 实验/ ./ 5.2/ ./ 1/ 加速/ 比/ 实验/ 实验/ 采用/ 条件/ 函数/ 依赖/ 总共/ 包含/ 2/ 条/ cfd/ ,/ 共有/ 5/ 条/ 模式/ 元组/ ./ 根据/ cfd/ 及其/ 模式/ 元组/ 为/ 来自/ Adult/ 数据/ 集中/ 的/ 无/ 缺失/ 值/ 元组/ 注入/ 错误/ ,/ 使/ 其/ 违反/ 一条/ 或者/ 多条/ 约束/ ./ 实验/ 条件/ 和/ 实验/ 结果/ 如表/ 9/ 所示/ ,/ 通过/ 实验/ 证明/ 系统/ 在/ 真实/ 数据/ 集上/ 的/ 加速/ 效果/ 明显/ ,/ 符合/ 优化/ 方案设计/ 预期/ ./ 此次/ 实验/ 加速/ 比为/ 1.39/ ,/ 理论/ 加速/ 比/ 大于/ 1.4/ ,/ 优化/ 效果/ 符合/ 预期/ ./ 5.2/ ./ 2/ 扩展性/ 实验/ 为/ 验证/ 优化/ 工作/ 在/ 不同/ 大小/ 的/ 数据/ 集上/ 同样/ 有/ 明显/ 的/ 优化/ 效果/ 设计/ 了/ 本/ 实验/ ./ 实验/ 利用/ 了/ 由/ TPC/ -/ H/ 生成/ 的/ lineitem/ ./ tbl/ 表中/ 的/ 5/ 个/ 属性/ 生成/ 的/ 数据/ 集/ ,/ CFDs/ 由/ 一条/ cfd/ 包含/ 2/ 条/ tp/ 构成/ ./ 实验/ 结果/ 如图/ 9/ 所示/ ,/ 可见/ 随着/ 数据/ 集合/ 的/ 增大/ 优化/ 效果/ 会变/ 好/ ,/ 说明/ 优化/ 设计方案/ 有/ 良好/ 的/ 扩展性/ ./ Page10/ 从图/ 9/ 可以/ 看出/ 优化/ 前/ 系统/ 运行/ 时间/ 随/ 数据/ 集/ 增加/ 呈/ 线性/ 增加/ ,/ 优化/ 后/ 系统/ 运行/ 时间/ 随/ 数据/ 集/ 的/ 增加/ 也/ 呈/ 线性/ 增加/ ,/ 但/ 前者/ 的/ 斜率/ 更大/ ./ 此外/ ,/ 系统优化/ 前后/ 的/ 加速/ 比/ 从/ 1.59/ 一直/ 上升/ 到/ 2.20/ ./ 一方面/ ,/ 优化/ 前/ 各个/ 模块/ 的/ 计算/ 任务/ 相当/ ,/ 但是/ 优化/ 工作/ 大大/ 减轻/ 了/ 除/ 不/ 一致/ 数据/ 检测/ 与/ 修复/ 模块/ 之外/ 各/ 模块/ 的/ 负载/ ;/ 另一方面/ ,/ 实验/ 中/ 为了/ 突出/ 数据/ 集/ 的/ 大小/ 对系统/ 运行/ 时间/ 的/ 影响/ ,/ 仅/ 设置/ Reduce/ 个数/ 为/ 2/ ,/ 故/ 随着/ 数据/ 集/ 的/ 增大/ 优化/ 前/ 的/ 系统/ 率先/ 满负荷/ 运行/ ./ 从而/ 出现/ 了/ 图/ 10/ 中/ 对比/ 鲜明/ 的/ 实验/ 结果/ ./ 5.2/ ./ 3/ 并行性/ 实验/ 为/ 验证/ 并行/ 程度/ 对/ 优化/ 效果/ 的/ 影响/ ,/ 设计/ 了/ 本/ 实验/ ./ 实验/ 利用/ 了/ 由/ TPC/ -/ H/ 生成/ 的/ lineitem/ ./ tbl/ 表中/ 的/ 5/ 个/ 属性/ 生成/ 的/ 数据/ 集/ ,/ CFDs/ 由/ 一条/ cfd/ 包含/ 2/ 条/ tp/ 构成/ ,/ 详见/ 图/ 11/ ./ 从图/ 10/ 可以/ 看出/ 系统/ 在/ 并行度/ 较/ 低/ (/ Reduce/ 个数/ 为/ 2/ )/ 的/ 情况/ 下/ 加速/ 比/ 最高/ 达到/ 2.20/ ,/ 之后/ 随着/ 系统/ 并行/ 化/ 程度/ 增高/ 优化/ 效果/ 变差/ ,/ 加速/ 比/ 降低/ ./ 并且/ 优化/ 前/ 的/ 系统/ 随着/ 系统/ 的/ 并行度/ 的/ 提高/ 使得/ 运行/ 时间/ 缩短/ ,/ 而/ 优化/ 后/ 的/ 系统/ 基本/ 保持/ 不变/ ./ 这/ 是因为/ 优化/ 之前/ 的/ 系统/ 处理/ 数据/ 的/ 能力/ 减弱/ ,/ 很/ 容易/ 满/ 负载/ 运行/ ,/ 只能/ 通过/ 增加/ 系统/ 的/ 并行/ 化/ 程度/ 提高/ 数据处理/ 的/ 效率/ ,/ 故/ 随着/ 并行度/ 增加/ 系统/ 运行/ 时间/ 减小/ ;/ 而/ 优化/ 后/ 的/ 系统/ 吞吐量/ 大/ ,/ 与/ 处理/ 和/ 前者/ 相同/ 的/ 数据/ 一直/ 都/ 没有/ 处于/ 满/ 负载/ 状态/ 运行/ ,/ 故/ 增加/ 系统/ 的/ 并行度/ 带来/ 的/ 好处/ 不/ 明显/ ./ 5.3/ 缺失/ 值/ 填充/ 优化/ 实验/ 为了/ 验证/ 系统/ 在/ 真实/ 生产/ 环境/ 中/ 的/ 工作/ 状态/ ,/ 本文/ 的/ 实验/ 采用/ 来自/ 真实/ 数据/ 集/ Adult/ (/ www/ ./ archive/ ./ ics/ ./ uci/ ./ edu/ // ml/ // datasets/ ./ html/ )/ 的/ 数据/ 和/ 由/ TPC/ -/ H/ 生成/ 的/ 数据/ 集/ ./ 进行/ 了/ 在/ Adult/ 数据/ 集上/ 的/ 缺失/ 率/ 对/ 优化/ 效果/ 的/ 验证/ 实验/ 、/ 在/ 人工/ 数据/ 集上/ 的/ 扩张性/ 实验/ 和/ 并行性/ 验证/ 实验/ ./ 5.3/ ./ 1/ 缺失/ 率/ 对/ 优化/ 效果/ 的/ 影响/ 实验/ 主要/ 研究/ 不同/ 的/ 数据/ 缺失/ 率/ 对/ 优化/ 结果/ 的/ 影响/ ,/ 通过/ 将/ 完整/ 数据/ 集/ 按/ 一定/ 的/ 比例/ (/ 缺失/ 率/ )/ 随机/ 置空/ 数据/ 生成/ 实验所/ 需/ 的/ 各种/ 缺失/ 率/ 的/ 数据/ ./ 本文/ 选取/ 其中/ 9/ 个/ 离散/ 属性/ ,/ 缺失/ 属性/ 有/ 7/ 种/ 取值/ ,/ 实验/ 结果/ 见图/ 12/ ./ 在/ 图/ 中/ 所示/ 缺失/ 率下/ ,/ 加速/ 比/ 稳定/ 在/ 1.5/ 左右/ ,/ 与/ 本/ 模块/ 的/ 理论/ 加速/ 比/ 3/ // 2/ 相吻合/ ./ 5.3/ ./ 2/ 扩展性/ 验证/ 实验/ 本/ 实验/ 利用/ 由/ TPC/ -/ H/ 生成/ 的/ 数据表/ lineitem/ ./ tbl/ 选取/ 其中/ 5/ 个/ 属性/ ,/ 分别/ 选择/ 不同/ 的/ 记录/ 条数/ 生成/ 实验所/ 需/ 的/ 数据/ ./ 图/ 13/ 所示/ 实验/ 结果表明/ ,/ 无论/ 优化/ 前后/ ,/ 系统/ 的/ 运行/ 时间/ 均/ 随/ 数据/ 集/ 的/ 增大/ 而/ 增大/ ,/ 但是/ 加速/ 比均/ 保持/ 在/ 1.5/ 左右/ ,/ 与/ 本/ 模块/ 的/ 理论/ 加速/ 比/ 相吻合/ ./ 5.3/ ./ 3/ 并行性/ 验证/ 实验/ 为了/ 验证/ 系统/ 在/ 不同/ 并行/ 化/ 程度/ 下/ 的/ 优化/ 效果/ ,/ 设计/ 了/ 本/ 实验/ ./ 实验/ 利用/ 由/ TPC/ -/ H/ 生成/ 的/ lineitem/ ./ tblPage11/ 数据表/ ,/ 数据表/ 共/ 包含/ 5/ 个/ 属性/ ,/ 3000000/ 条/ 元组/ ./ 随机/ 置空/ 数据表/ 第/ 1/ 列/ 5/ %/ 的/ 数据/ (/ 缺失/ 率/ 5/ %/ )/ ,/ 记录/ 在/ 不同/ 的/ 并行/ 化/ 程度/ 下/ 系统/ 的/ 优化/ 效果/ ./ 实验/ 结果/ 见图/ 14/ ./ 在/ 给定/ 数据/ 集上/ ,/ 系统优化/ 前后/ 的/ 运行/ 效率/ 都/ 未/ 随着/ 并行/ 化/ 程度/ 的/ 提高/ 而变/ 好/ ./ 这/ 是因为/ 对于/ 特定/ 大小/ 的/ 数据/ 集/ 最/ 适宜/ 的/ Reduce/ 数目/ 是/ 确定/ 的/ ,/ 一味/ 地/ 提高/ 并行/ 化/ 程度/ 只会/ 给/ 系统/ 带来/ 更多地/ 任务分配/ 的/ 开销/ ./ 无论如何/ ,/ 在/ 不同/ 的/ 并行/ 化/ 程度/ 下/ 优化/ 效果/ 明显/ ./ 6/ 结论/ 虽然/ 整个/ 行业/ 对/ Hadoop/ 的/ 研究/ 和/ 使用/ 已经/ 有/ 了/ 相当/ 的/ 积累/ ,/ 但是/ 由于/ 使用者/ 对/ MapReduce/ 编程/ 框架/ 理解/ 不够/ 深刻/ ,/ 所以/ 利用/ MapReduce/ 设计/ 的/ 软件系统/ 大都/ 效率/ 低下/ ./ 为此/ 本文/ 提出/ 了/ 一种/ 针对/ MapReduce/ 编程/ 框架/ 设计/ 的/ 系统/ 的/ 优化/ 方法/ ,/ 并/ 通过/ 了/ 在/ 海量/ 数据/ 清洗/ 系统/ 上/ 的/ 实施/ ./ 本文/ 提出/ 的/ 优化/ 方法/ 仅/ 需/ 对/ 原/ 系统/ 解决问题/ 的/ 思路/ 稍作/ 改动/ ,/ 几乎/ 不/ 影响/ 其/ 算法/ 复杂性/ ,/ 通过/ 减少/ MapReduce/ 轮数/ 和/ IO/ 次数/ 达到/ 优化/ 的/ 目的/ ./ 优化/ 方法/ 简单/ ,/ 实用性/ 强/ ./ 未来/ 的/ 工作/ 包括/ 将/ 这种/ 思想/ 利用/ 到/ 更/ 多/ 基于/ MapReduce/ 的/ 系统/ 中/ ,/ 对/ 实验/ 结果/ 进行/ 更为/ 深入/ 的/ 分析/ 以/ 发现/ 本文/ 提供/ 的/ 优化/ 方法/ 的/ 不足/ 从而/ 提出/ 更好/ 的/ 优化/ 方法/ ./ 

