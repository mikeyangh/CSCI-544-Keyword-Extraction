Page1/ 求解/ 三维/ 装箱/ 问题/ 的/ 多层/ 启发式/ 搜索算法/ 张德富/ 1/ )/ 彭煜/ 2/ )/ 张/ 丽丽/ 1/ )/ 1/ )/ (/ 厦门大学/ 信息科学/ 与/ 技术/ 学院/ 福建厦门/ 361005/ )/ 2/ )/ (/ 香港大学/ 计算机科学/ 系/ 香港/ )/ 摘要/ 文中/ 提出/ 了/ 一个/ 高效/ 求解/ 三维/ 装箱/ 问题/ 的/ 多层/ 启发式/ 搜索算法/ ./ 该/ 算法/ 基于/ 块/ 装载/ 的/ 思想/ ,/ 按照/ 块/ 选择/ 算法/ 确定/ 每个/ 阶段/ 采用/ 的/ 块/ ,/ 然后/ 以/ 一种/ 固定/ 的/ 装载/ 方式/ 装载/ 块/ ,/ 直到/ 无法/ 继续/ 装载/ ./ 文中/ 的/ 主要/ 贡献/ 在于/ 发展/ 了/ 一个/ 有效/ 的/ 复合/ 块/ 生成/ 算法/ ,/ 特别/ 的/ ,/ 提出/ 了/ 基于/ 多层/ 搜索/ 的/ 块/ 选择/ 算法/ ,/ 该/ 算法/ 用/ 多层/ 搜索/ 来/ 评价/ 可行/ 块/ ,/ 然后/ 选择/ 最合适/ 的/ 块/ 进行/ 装载/ ./ 对/ 1500/ 个/ 三维/ 装箱/ 问题/ 测试数据/ 的/ 计算/ 结果表明/ ,/ 提出/ 的/ 算法/ 几乎/ 在/ 所有/ 测试数据/ 上/ 的/ 填充/ 率/ 都/ 超过/ 了/ 目前/ 已知/ 的/ 优秀/ 算法/ ./ 关键词/ 三维/ 装箱/ 问题/ ;/ 启发式/ 算法/ ;/ 深度/ 优先/ 搜索/ 1/ 引言/ 在/ 物流/ 、/ 运输/ 等/ 工业/ 领域/ ,/ 经常/ 会/ 遇到/ 三维/ 装箱/ 问题/ ./ 如何/ 提高/ 装箱/ 的/ 效率/ ,/ 已经/ 成为/ 科学研究/ 和/ 实践/ 中/ 非常/ 关注/ 的/ 一个/ 重要/ 课题/ ./ 求解/ 装箱/ 问题/ 的/ 高效/ 求解/ 算法/ ,/ 对/ 降低成本/ 、/ 提高/ 企业/ 的/ 赢利/ 能力/ ,/ 有/ Page2/ 箱/ 问题/ 和/ 多/ 容器/ 装箱/ 问题/ ;/ 同构/ 装箱/ 问题/ (/ 只含/ 一种/ 类型/ 的/ 箱子/ )/ 和/ 异构/ 装箱/ 问题/ (/ 包含/ 多种类型/ 的/ 箱子/ )/ ./ 本文/ 研究/ 单/ 容器/ 装箱/ 问题/ ,/ 其/ 形式化/ 的/ 定义/ 可以/ 描述/ 如下/ :/ 给定/ 一个/ 容器/ (/ 其/ 体积/ 为/ V/ )/ 和/ 一系列/ 待/ 装载/ 的/ 箱子/ ,/ 容器/ 和/ 箱子/ 的/ 形状/ 都/ 是/ 长方体/ ./ 问题/ 的/ 目标/ 是/ 要/ 确定/ 一个/ 可行/ 的/ 箱子/ 装载/ 方案/ ,/ 使得/ 在/ 满足/ 给定/ 装载/ 约束/ 的/ 条件/ 下/ ,/ 使/ 容器/ 中所装/ 箱子/ 总/ 体积/ S/ (/ 或者/ 填充/ 率/ S/ // V/ ×/ 100/ %/ )/ 尽可能/ 的/ 大/ ./ 可行/ 装载/ 方案/ 要求/ 必须/ 满足/ 如下/ 两个/ 条件/ :/ (/ 1/ )/ 任一/ 装载/ 的/ 箱子/ 不能/ 与/ 其它/ 装载/ 箱子/ 或者/ (/ 2/ )/ 所有/ 装载/ 的/ 箱子/ 以/ 与/ 容器/ 平行/ 的/ 方式/ 装载/ ./ 此外/ ,/ 根据/ 实际/ 问题/ 的/ 需要/ ,/ 本文/ 还/ 考虑/ 如下/ 约/ 容器/ 互相/ 重叠/ ./ 束/ 条件/ :/ (/ C1/ )/ 方向性/ 约束/ ./ 在/ 许多/ 应用/ 中/ ,/ 箱子/ 的/ 装载/ 有/ 方向性/ 约束/ ./ 也就是说/ ,/ 每个/ 箱子/ 只有/ 它/ 的/ 1/ 条/ 或/ 2/ 条边/ 可以/ 竖直/ 放置/ 作为/ 高度/ ,/ 即/ 箱子/ 的/ 某个/ 面/ 必须/ 朝上/ ./ (/ C2/ )/ 稳定性/ 约束/ ./ 在/ 实际/ 应用/ 中/ ,/ 例如/ 物流/ 领域/ ,/ 装载/ 必须/ 满足/ 稳定性/ 约束/ ./ 这/ 意味着/ 每个/ 被/ 装载/ 的/ 箱子/ 必须/ 得到/ 容器/ 底部/ 或者/ 其它/ 已经/ 装载/ 箱子/ 的/ 支撑/ ./ 根据/ 实际/ 应用/ 需要/ ,/ 有/ 完全/ 支撑/ 约束/ ,/ 即/ 被/ 装载/ 箱子/ 的/ 底部/ 必须/ 跟/ 其它/ 已经/ 装载/ 箱子/ 完全/ 接触/ ,/ 不/ 允许/ 底部/ 有/ 悬空/ 的/ 部分/ ,/ 部分/ 支撑/ 约束/ 指/ 的/ 是/ 装载/ 箱子/ 的/ 底部/ ,/ 可以/ 允许/ 部分/ 悬空/ ./ 由于/ 三维/ 装箱/ 问题/ 是/ 一个/ 典型/ 的/ NP/ 难题/ [/ 2/ ]/ ,/ 因此/ 不/ 存在/ 多项式/ 时间/ 复杂度/ 的/ 最优/ 求解/ 算法/ ./ 用/ 传统/ 的/ 精确/ 算法/ 求解/ 这/ 类/ 问题/ ,/ 会/ 发生/ “/ 组合/ 爆炸/ ”/ 的/ 现象/ ./ 虽然/ 一些/ 研究/ 采用/ 了/ 精确/ 算法/ ,/ 但/ 其/ 求解/ 的/ 规模/ 有限/ ,/ 因此/ 启发式/ 求解/ 方法/ 成为/ 理论/ 研究/ 和/ 实际/ 应用/ 的/ 首选/ ./ 对于/ 三维/ 装箱/ 问题/ ,/ 基于/ 垂直/ “/ 层/ ”/ 或/ “/ 墙/ ”/ 概念/ 的/ 启发式/ 算法/ 比较/ 多/ ./ George/ 等/ 人/ [/ 3/ ]/ 首先/ 提出/ 了/ 基于/ 层/ 的/ 启发式/ 方法/ ./ Bischoff/ 等/ 人/ [/ 4/ ]/ 比较/ 了/ 14/ 种/ 基于/ 层/ 的/ 方法/ ./ Bortfeldt/ 等/ 人/ [/ 5/ ]/ 在/ 层/ 概念/ 的/ 基础/ 上/ ,/ 设计/ 了/ 一种/ 混合/ 遗传算法/ ./ Pisinger/ [/ 6/ ]/ 基于/ 层/ 的/ 概念/ ,/ 将/ 整个/ 容器/ 空间/ 分成/ 若干/ 垂直/ 的/ 层/ ,/ 再/ 将/ 层/ 分成/ 若干/ 水平/ 或/ 垂直/ 的/ 条形/ ,/ 然后/ 利用/ 背包/ 问题/ 的/ 算法/ 来/ 求解/ ./ Bischoff/ 等/ 人/ [/ 7/ ]/ 针对/ 异构/ 装箱/ 问题/ ,/ 以自/ 底向上/ 的/ 摆放/ 思想/ ,/ 提出/ 了/ 基于/ 平面/ 的/ 算法/ ./ Gehring/ 等/ 人/ [/ 8/ ]/ 基于/ 塔/ 的/ 概念/ ,/ 设计/ 了/ 一个/ 遗传算法/ ./ Bort/ -/ feldt/ 等/ 人/ [/ 9/ ]/ 提出/ 了/ 一个/ 禁忌/ 搜索算法/ ./ 与/ “/ 塔/ ”/ 和/ “/ 层/ ”/ 的/ 概念/ 不同/ ,/ Eley/ [/ 10/ ]/ 设计/ 了/ 基于/ 同类/ 块/ (/ Block/ )/ 的/ 算法/ ./ Bortfeldt/ 等/ 人/ [/ 11/ ]/ 进一步/ 拓展/ 了/ “/ 块/ ”/ 的/ 概念/ ,/ 然后/ 使用/ 禁忌/ 搜索/ 寻找/ 最优/ 的/ 装载/ 序列/ 作为/ 问题/ 的/ 近似/ 解/ ./ Moura/ 等/ 人/ [/ 12/ ]/ 基于/ “/ 剩余/ 空间/ ”/ 的/ 概念/ 提出/ 了/ 一个/ 贪心/ 随机/ 自/ 适应/ 搜索算法/ (/ GRASP/ )/ ./ Parreo/ 等/ 人/ [/ 13/ ]/ 进一步/ 发展/ 和/ 改进/ 了/ 该/ 算法/ ,/ 取得/ 了/ 不错/ 的/ 结果/ ./ Parreo/ 等/ 人/ [/ 14/ ]/ 基于/ 最大/ 空间/ 的/ 概念/ ,/ 提出/ 了/ 一个/ 可变/ 邻域/ 搜索算法/ ./ Fans/ -/ lau/ 等/ 人/ [/ 15/ ]/ 基于/ “/ 块/ ”/ 的/ 概念/ ,/ 提出/ 了/ “/ 复合/ 块/ ”/ 的/ 思想/ ,/ 然后/ 设计/ 了/ 一个/ 有效/ 的/ 启发式/ 树状/ 搜索算法/ ,/ 是/ 目前/ 解决/ 装箱/ 问题/ 最/ 有效/ 的/ 算法/ ./ 此外/ Ngoi/ 、/ Bischoff/ 、/ Morabito/ 、/ Sixt/ 、/ Gehring/ 、/ Lim/ 、/ Juraitis/ 和/ Bortfeldt/ 等/ 人/ 也/ 报告/ 了/ 其它/ 一些/ 有趣/ 的/ 启发式/ 算法/ ,/ 并/ 将/ 他们/ 应用/ 到/ 三维/ 装箱/ 问题/ 中/ [/ 16/ -/ 24/ ]/ ./ 国内/ 学者/ 对/ 三维/ 装箱/ 问题/ 的/ 研究/ ,/ 也/ 取得/ 了/ 一些/ 不错/ 的/ 结果/ [/ 25/ -/ 31/ ]/ ,/ 例如/ 张德富/ 等/ 人/ [/ 29/ ]/ 提出/ 了/ 一个/ 混合/ 模拟退火/ 算法/ ,/ Huang/ 等/ 人/ [/ 31/ ]/ 提出/ 了/ 一个/ 有效/ 的/ 拟人/ 型/ 穴度/ 算法/ ./ 本文/ 在/ 文献/ [/ 15/ ,/ 29/ ]/ 研究/ 的/ 基础/ 上/ ,/ 提出/ 了/ 一个/ 多层/ 启发式/ 搜索算法/ ,/ 这个/ 算法/ 与/ 文献/ [/ 15/ ]/ 不同/ 的/ 地方/ 在于/ ,/ 文献/ [/ 15/ ]/ 采用/ 基于/ 整数/ 拆分/ 的/ 树状/ 搜索算法/ ,/ 而/ 本文/ 采用/ 深度/ +/ 宽度/ 搜索/ 的/ 思想/ ,/ 提出/ 多层/ 搜索算法/ ,/ 能/ 更/ 有效/ 地/ 评价/ 可行/ 块/ 以便/ 选择/ 一个/ 近似/ 最优/ 的/ 块/ 进行/ 装载/ ./ 与/ 文献/ [/ 29/ ]/ 最大/ 的/ 不同/ 在于/ 文献/ [/ 29/ ]/ 从/ 一个/ 初始/ 装载/ 序列/ 出发/ ,/ 采用/ 模拟退火/ 算法/ 来/ 搜索/ 一个/ 好/ 的/ 装载/ 序列/ ,/ 作为/ 问题/ 的/ 近似/ 解/ ,/ 而/ 本文/ 采用/ 构造性/ 算法/ ,/ 用/ 多层/ 搜索/ 思想/ 来/ 选择/ 一个/ 近似/ 最优/ 块/ 进行/ 装载/ ,/ 然后/ 逐步/ 构造/ 直到/ 获得/ 一个/ 装载/ 序列/ ./ 实验/ 结果/ 验证/ 了/ 提出/ 算法/ 的/ 有效性/ ,/ 而且/ 本文/ 算法/ 超过/ 了/ 已/ 出版/ 的/ 优秀/ 算法/ ./ 2/ 多层/ 启发式/ 搜索算法/ 2.1/ 基本/ 的/ 块/ 装载/ 启发式/ 算法/ 因为/ 装箱/ 问题/ 本身/ 的/ 复杂性/ 和/ 实际/ 应用/ 的/ 需要/ ,/ 必须/ 使用/ 启发式/ 方法/ 才能/ 有效/ 地/ 生成/ 装载/ 方案/ ./ 一个/ 优秀/ 的/ 启发式/ 算法/ 不但/ 应该/ 能/ 迅速/ 找到/ 解/ ,/ 而且/ 应该/ 尽可能/ 地/ 找到/ 接近/ 最优/ 的/ 解/ ,/ 同时/ 算法/ 还/ 应该/ 展示/ 必要/ 的/ 灵活性/ 使/ 其/ 能够/ 适应/ 不同/ 的/ 场合/ 和/ 需求/ ./ 本文/ 提出/ 的/ 基于/ 块/ 装载/ 的/ 三维/ 装箱/ 问题/ 的/ 求解/ 算法/ ,/ 是/ 受/ 日常/ 装箱/ 经验/ 的/ 启发/ 而/ 提出/ 的/ ,/ 一些/ 算法/ 思想/ 与/ 文献/ [/ 11/ ,/ 29/ ]/ 中/ 的/ 类似/ ./ 算法/ 1/ 给出/ 了/ 基本/ 的/ 块/ 装载/ 启发式/ 算法/ 的/ 具体/ 描述/ ,/ 算法/ 首先/ 根据/ 输入/ 参数/ 指定/ 的/ isComplex/ 生成/ 所有/ 可能/ 的/ 简单/ 块/ 或/ 复合/ 块/ ;/ 接着/ 初始化/ 当前/ 部分/ 装载/ 方案/ ,/ 并/ 开始/ 装载/ 过程/ ;/ 每个/ 装载/ 阶段/ ,/ 算法/ 从/ 剩余/ 堆栈/ 栈顶/ 取出/ 一个/ 空间/ space/ ,/ 用/ GenBlock/ -/ Page3List/ 算法/ 生成/ 它/ 的/ 可行/ 块/ 列表/ ;/ 当/ 列表/ 不为/ 空时/ ,/ FindNextBlock/ 算法/ 选择/ 一个/ 块/ 进行/ 装载/ 并/ 加入/ 当前/ 部分/ 装载/ 方案/ ,/ 接着/ 采用/ GenResidulSpace/ 划分/ 未/ 填充/ 的/ 空间/ 并/ 将/ 它们/ 插入/ 堆栈/ ;/ 当/ 列表/ 为/ 空时/ ,/ 算法/ TransferSpace/ 尝试/ 将/ space/ 中/ 可/ 利用/ 的/ 部分/ 转移/ 到/ 堆栈/ 中/ 相应/ 的/ 剩余/ 空间/ ./ 算法/ 1/ ./ 块/ 装载/ 启发式/ 算法/ ./ BasicHeuristic/ (/ isComplex/ ,/ searchParams/ ,/ problem/ )/ ifisComplexthenblockTable/ ·/ ·/ =/ GenComplexBlock/ (/ problem/ ./ container/ ,/ elseblockTable/ ·/ ·/ =/ GenSimpleBlock/ (/ problem/ ./ container/ ,/ endifsetsearchparametersaccordingtosearchParamsps/ ./ avail/ ·/ ·/ =/ problem/ ./ numps/ ./ plan/ ·/ ·/ =/ {/ }/ ps/ ./ volume/ =/ 0ps/ ./ spaceStack/ ·/ ·/ =/ {/ }/ ps/ ./ spaceStack/ ./ push/ (/ problem/ ./ container/ )/ whileps/ ./ spaceStack/ ≠/ {/ }/ dospace/ ·/ ·/ =/ ps/ ./ spaceStack/ ./ top/ (/ )/ blockList/ ·/ ·/ =/ GenBlockList/ (/ ps/ ./ space/ ,/ ps/ ./ avail/ )/ ifblockList/ ≠/ {/ }/ thenelseendifendwhilereturnps/ ./ plan/ 其中/ ,/ space/ 表示/ 剩余/ 空间/ ,/ 采用/ 参考点/ 加/ 3/ 边/ 长度/ 的/ 方法/ 来/ 表示/ ;/ problem/ 包含/ 容器/ 、/ box/ 列表/ 以及/ 可用/ 箱子/ 向量/ ,/ 形式化/ 表示/ 了/ 一个/ 装箱/ 问题/ ;/ block/ 结构/ 表示/ 块/ ,/ 可以/ 是/ 简单/ 块/ 或/ 复合/ 块/ ,/ 它/ 有/ 一个/ re/ -/ quire/ 向量/ 指出/ 其/ 包含/ 的/ 所有/ 箱子/ 的/ 数量/ ./ 关于/ 算法/ 采用/ 的/ 数据结构/ 以及/ 有关/ 变量/ 的/ 含义/ ,/ 可以/ 参看/ 文献/ [/ 29/ ]/ ./ 下面/ ,/ 本文/ 提出/ 的/ 多层/ 启发式/ 算法/ ,/ 以块/ 装载/ 启发式/ 算法/ 为/ 基础/ ,/ 嵌入/ 了/ 下面/ 两个/ 核心/ 算法/ ./ 2.2/ 简单/ 块/ 、/ 复合/ 块/ 及其/ 生成/ 算法/ 简单/ 块/ 是/ 由/ 同一/ 朝向/ 的/ 同种/ 类型/ 的/ 箱子/ 堆叠/ 而成/ 的/ ,/ 箱子/ 和/ 箱子/ 之间/ 没有/ 空隙/ ,/ 堆叠/ 的/ 结果/ 必须/ 恰好/ 形成/ 一个/ 长方体/ ./ GenSimpleBlock/ 算法/ [/ 29/ ]/ 枚举/ 所有/ 可行/ 的/ 组合/ (/ nx/ ,/ ny/ ,/ nz/ )/ ,/ 并/ 将/ 其/ 对应/ 的/ 简单/ 块/ 加入/ 块表/ ./ 其中/ 可行/ 组合/ 应/ 满足/ :/ 所/ 包含/ 的/ 箱子/ 数目/ 小于/ 对应/ 可用/ 箱子/ 数目/ ,/ 且/ 块/ 大小/ 应/ 小于/ 容器/ 大小/ ./ 复合/ 块/ 是/ 通过/ 不断/ 组合/ 简单/ 块/ 而/ 得到/ 的/ ,/ 其/ 定义/ [/ 29/ ]/ 如下/ :/ (/ 1/ )/ 简单/ 块/ 是/ 最/ 基本/ 的/ 复合/ 块/ ./ (/ 2/ )/ 给定/ 两个/ 复合/ 块/ a/ ,/ b/ ./ 可以/ 按/ 3/ 种/ 方式/ 进行/ 组合/ 得到/ 复合/ 块/ c/ :/ 按/ x/ 轴/ 方向/ 组合/ ,/ 按/ y/ 轴/ 方向/ 组合/ ,/ 按/ z/ 轴/ 方向/ 组合/ ./ c/ 是/ 包含/ a/ 、/ b/ 的/ 最小/ 长方体/ ./ 显然/ ,/ 按照/ 上述/ 定义/ ,/ 复合/ 块/ 的/ 数量/ 将/ 是/ 箱子/ 数目/ 的/ 指数/ 级/ ,/ 而且/ 任意/ 组合/ 生成/ 的/ 复合/ 块/ 中/ 可能/ 有/ 很多/ 空隙/ ,/ 非常/ 不利于/ 装载/ ./ 因此/ ,/ 有/ 必要/ 对/ 复合/ 块/ 施加/ 一定/ 的/ 限制/ ,/ 本文/ 的/ 限制/ 条件/ 基本上/ 同/ 文献/ [/ 29/ ]/ ,/ 但是/ 本文/ 还/ 考虑/ 下列/ 条件/ :/ 如果/ 考虑/ 约束/ C2/ ,/ 受/ 复合/ 块/ 中/ 空隙/ 的/ 影响/ ,/ 复合/ 块/ 顶部/ 有/ 支撑/ 的/ 可/ 放置/ 矩形/ 可能/ 很小/ ,/ 为了/ 保证/ 在/ 后面/ 的/ 装载/ 过程/ 中/ 剩余/ 空间/ 不会/ 由于/ 失去/ 支撑/ 而/ 浪费/ 可用/ 空间/ ,/ 我们/ 限定/ 顶部/ 可/ 放置/ 矩形/ 与/ 相应/ 的/ 复合/ 块/ 顶部/ 面积/ 的/ 比/ 至少/ 要/ 达到/ MinAreaRate/ ./ 上述/ 条件/ 是/ 文献/ [/ 15/ ,/ 29/ ]/ 中/ 没有/ 考虑/ 的/ ,/ 它/ 能/ 减少/ 对块/ 的/ 搜索/ ,/ 加快/ 计算/ 的/ 速度/ ./ 在/ 满足/ 以上/ 约束/ 的/ 情况/ 下/ ,/ 块/ 数目/ 仍然/ 可能/ 很大/ ,/ 生成/ 算法/ 将/ 在/ 块/ 数目/ 达到/ MaxBlocks/ 时/ 停止/ 生成/ ./ 根据/ 复合/ 块/ 的/ 定义/ ,/ 可以/ 得到/ 最终/ 的/ 复合/ 块/ 生成/ 算法/ 2/ ./ 此/ 算法/ 首先/ 调用/ 简单/ 块/ 生成/ 算法/ 生成/ 所有/ 可能/ 的/ 简单/ 块/ ;/ 接着/ ,/ 迭代/ MaxTimes/ 次/ ,/ 在/ 每/ 一次/ 迭代/ 中/ ,/ 对于/ 任何/ 两个/ 已/ 生成/ 的/ 复合/ 块/ a/ 、/ b/ ,/ 尝试/ 按/ x/ 轴/ 、/ y/ 轴/ 、/ z/ 轴/ 方向/ 进行/ 组合/ ;/ 如果/ 组合/ 满足/ 前面/ 所述/ 的/ 组合/ 限制/ 条件/ ,/ 则/ 将/ 新/ 生成/ 的/ 复合/ 块/ c/ 加入/ 块/ 列表/ ./ 算法/ 2/ ./ 复合/ 块/ 生成/ 算法/ ./ GenComplexBlock/ (/ container/ ,/ boxList/ ,/ num/ )/ blockTable/ ·/ ·/ =/ GenSimpleBlock/ (/ space/ ,/ boxList/ ,/ num/ )/ fortimes/ ·/ ·/ =/ 0toMaxTimes/ -/ 1donewBlockTable/ ·/ ·/ =/ {/ }/ foreacha/ ,/ binblockTabledoifa/ ./ times/ =/ timesorb/ ./ times/ =/ timesthenPage4endifendforblockTable/ ·/ ·/ =/ blockTable/ +/ newBlockTablereduceduplicatedblockinblockTableendforsortblockTablebydecreasingvolumeofblocks/ ./ returnblockTable/ 介绍/ 了/ 块/ 的/ 概念/ 后/ ,/ 下面/ 描述/ 可行/ 块/ 列表/ 生成/ 算法/ GenBlockList/ (/ space/ ,/ avail/ )/ ./ 该/ 算法/ 用于/ 从/ blockTable/ 中/ 获取/ 适合/ 当前/ 剩余/ 空间/ 的/ 可行/ 块/ 列表/ ./ 其中/ ,/ blockTable/ 是/ 在/ 算法/ 开始/ 时/ 预先/ 生成/ 的/ 所有/ 可能/ 的/ 块/ 的/ 列表/ ,/ 以/ 避免/ 重复/ 计算/ ./ 这样/ ,/ 在/ 某/ 一/ 时刻/ 计算/ 某/ 一个/ 剩余/ 空间/ 的/ 可行/ 块/ 列表/ 时/ ,/ 只要/ 扫描/ blockTable/ ,/ 找出/ 所有/ 能/ 放入/ 该/ 剩余/ 空间/ 且/ 能/ 被/ 当前/ 剩余/ 箱子/ 满足/ 的/ 块/ 即可/ ./ 这样/ 使得/ 基本/ 的/ 块/ 装载/ 启发式/ 算法/ 与/ 块/ 生成/ 算法/ 完全/ 无关/ ,/ 块/ 生成/ 算法/ 可以/ 根据/ 需要/ 进行/ 定制/ 而/ 不/ 影响/ 块/ 装载/ 启发式/ 算法/ ./ 算法/ GenBlockList/ (/ space/ ,/ avail/ )/ 描述/ 了/ 可行/ 块/ 列表/ 生成/ 算法/ ,/ 该/ 算法/ 扫描/ blockTable/ ,/ 返回/ 所有/ 能/ 放入/ 剩余/ 空间/ 并且/ 有/ 足够/ 剩余/ 箱子/ 的/ 块/ ./ 由于/ blockTable/ 是/ 按块/ 中/ 箱子/ 总/ 体积/ 降序/ 排列/ 的/ ,/ 返回/ 的/ 可行/ 块/ 列表/ blockList/ 也/ 是/ 按/ 箱子/ 总/ 体积/ 降序/ 排列/ ./ 在/ 每个/ 装载/ 阶段/ 一个/ 剩余/ 空间/ 被/ 装载/ ,/ 装载/ 分为/ 有/ 可行/ 块/ 和/ 无/ 可行/ 块/ 两种/ 情况/ ./ 在/ 有/ 可行/ 块/ 时/ ,/ 算法/ 按照/ 块/ 选择/ 算法/ 选择/ 可行/ 块/ ,/ 然后/ 将/ 未/ 填充/ 空间/ 划分/ 成新/ 的/ 剩余/ 空间/ ,/ 这里/ 划分/ 的/ 策略/ 是/ 使/ 划分/ 出/ 的/ 剩余/ 空间/ 尽可能/ 地大/ ./ 图/ 1/ 给出/ 了/ 具有/ 稳定性/ 约束/ 的/ 剩余/ 空间/ 的/ 划分/ 过程/ ./ 令/ x/ 轴/ 、/ y/ 轴/ 和/ z/ 轴上/ 的/ 剩余/ 长度/ 分别/ 为/ mx/ 、/ my/ 、/ mz/ ./ 如果/ my/ / mx/ ,/ 则/ 按/ 图/ 1/ (/ a/ )/ 划分/ ,/ 划分/ 空间/ 的/ 入栈/ 顺序/ 为/ spaceZ/ ,/ spaceX/ ,/ spaceY/ ;/ 如果/ mx/ / my/ ,/ 则/ 按/ 图/ 1/ (/ b/ )/ 划分/ ,/ 空间/ 的/ 入栈/ 顺序/ spaceZ/ ,/ spaceY/ ,/ spaceX/ ./ 在/ 无/ 可行/ 块/ 时/ ,/ 当前/ 剩余/ 空间/ 被/ 抛弃/ ,/ 若/ 其中/ 一部分/ 空间/ 可以/ 合并/ 到/ 当前/ 堆栈/ 中/ 的/ 其它/ 空间/ ,/ 则/ 进行/ 空间/ 转移/ ,/ 重新/ 利用/ 这些/ 空间/ ./ 可/ 转移/ 空间/ 可以/ 被/ 转移/ 给/ 剩余/ 空间/ 堆栈/ 中/ 来自/ 同/ 一次/ 划分/ 的/ 其它/ 空间/ 以/ 重新/ 利用/ ./ 可/ 转移/ 空间/ 的/ 重新分配/ 实际上/ 就是/ 对/ 未/ 填充/ 空间/ 的/ 重新/ 划分/ ./ 因此/ ,/ 可以/ 通过/ 重新/ 划分/ 未/ 填充/ 空间/ 来/ 达到/ 再次/ 利用/ 可/ 转移/ 空间/ 的/ 目的/ ./ TransferSpace/ (/ space/ ,/ spaceStack/ )/ 实现/ 空间/ 转移/ ,/ 此/ 过程/ 判定/ 当前/ 剩余/ 空间/ 与/ 栈/ 顶/ 的/ 一个/ 或/ 两个/ 剩余/ 空间/ 是否是/ 由同/ 一次/ 划分/ 而/ 产生/ 的/ ,/ 若/ 是/ 则/ 将/ 可/ 转移/ 空间/ 转移/ 给/ 相应/ 的/ 一个/ 或/ 两个/ 剩余/ 空间/ ./ 其中/ 一些/ 细节/ ,/ 可/ 参考文献/ [/ 29/ ]/ ./ 2.3/ 基于/ 多层/ 搜索/ 的/ 块/ 选择/ 算法/ Fanslau/ 等/ 人/ [/ 15/ ]/ 采用/ 如下/ 基于/ 整数/ 拆分/ 的/ 树状/ 搜索算法/ 进行/ 块/ 选择/ :/ 给定/ 一个/ 整数/ 拆分/ d0/ +/ d1/ +/ …/ +/ dn/ -/ 1/ =/ d/ ,/ 搜索/ 分为/ n/ 层/ ,/ r/ 为/ 初始/ 根/ 节点/ ,/ 在/ 第/ i/ 层/ 从/ 根/ 节点/ ri/ 出发/ 进行/ 一次/ 深度/ 为/ di/ 的/ 搜索/ ,/ 选择/ 最优/ 的/ 叶/ 节点/ 作为/ 新/ 的/ 根/ 节点/ ri/ +/ 1/ ,/ rn/ 是/ 最终/ 的/ 搜索/ 结果/ ./ 为/ 限制/ 搜索/ 的/ 开销/ ,/ 每次/ 搜索/ 的/ 节点/ 数目/ 限制/ 为/ bi/ =/ max/ {/ b/ |/ bdi/ </ effort/ }/ ./ 尽管/ 这种/ 算法/ 取得/ 了/ 相当/ 优秀/ 的/ 结果/ ./ 但是/ ,/ 仔细分析/ 该/ 算法/ 的/ 执行/ 过程/ ,/ 它/ 仍然/ 有/ 一些/ 缺陷/ :/ (/ 1/ )/ 在/ 指定/ 整数/ 拆分/ 下/ ,/ 算法/ 每个/ 阶段/ 只/ 选择/ 当前/ 状态/ 下/ 的/ 局部/ 最优/ 解/ ,/ 并/ 在/ 下一阶段/ 以此/ 为/ 基础/ 进行/ 搜索/ ./ 但是/ 局部/ 最优/ 毕竟/ 不是/ 全局/ 最优/ ,/ 一旦/ 在/ 某个/ 阶段/ 选择/ 错误/ ,/ 后续/ 的/ 评估/ 结果/ 就/ 必然/ 会/ 出现/ 偏差/ ./ 虽然/ 算法/ 通过/ 枚举/ 所有/ 的/ 整数/ 拆分/ 允许/ 搜索/ 更/ 多/ 的/ 节点/ ,/ 但是/ 由于/ 每次/ 总是/ 选择/ 局部/ 最优/ 的/ 那个/ 节点/ ,/ 算法/ 很难/ 选取/ 到/ 那些/ 要/ 到/ 很大/ 的/ 深度/ 才能/ 体现/ 其/ 优势/ 的/ 块/ ./ Page5/ (/ 2/ )/ 算法/ 在/ 执行/ 搜索/ 过程/ 中/ ,/ 有/ 很大/ 一部分/ 重复/ 计算/ ,/ 一方面/ 是因为/ 不同/ 的/ 整数/ 拆分/ 方式/ 有/ 一部分/ 重叠/ ,/ 另一方面/ 是因为/ 不同/ 拆分/ 所/ 找到/ 的/ 节点/ 很/ 可能/ 是/ 相同/ 的/ ./ 针对/ 树状/ 搜索算法/ 的/ 两个/ 缺陷/ ,/ 本文/ 提出/ 了/ 多层/ 启发式/ 搜索/ ,/ 这里/ “/ 层/ ”/ 的/ 概念/ 对应/ 于/ 整数/ 拆分/ 里面/ 的/ 每/ 一个/ 拆分/ ,/ 但是/ 每/ 一层/ 的/ 深度/ 为/ 1/ ./ 第/ i/ 层/ 的/ 节点/ 是/ 初始/ 局部/ 装载/ 方案/ 装载/ 了/ i/ 个块/ 以后/ 的/ 结果/ ./ 该/ 算法/ 与/ 基于/ 整数/ 拆分/ 的/ 树状/ 搜索算法/ 最大/ 的/ 不同/ 在于/ :/ 在/ 第/ i/ 层/ ,/ 算法/ 不再/ 只/ 选择/ 一个/ 块/ 继续/ 搜索/ ,/ 而是/ 选择/ 最优/ 的/ MaxHeap/ 个/ 局部/ 装载/ 方案/ ,/ 采用/ 不同/ 的/ 深度/ d/ 调用/ 深度/ 优先/ 搜索算法/ ,/ 并/ 将/ 所有/ 搜索/ 结果/ 都/ 插入/ 到/ 相应/ 第/ i/ +/ d/ 层/ 的/ 结果/ 中去/ ./ 在/ 每个/ 层上/ ,/ 算法/ 使用/ 堆/ 存储/ 最优/ 的/ MaxHeap/ 结果/ ./ 算法/ 从/ 0/ 层/ 开始/ 迭代/ ,/ 直到/ depth/ 层/ 结束/ ./ 整个/ 算法/ 的/ 运行/ 过程/ 类似/ 树状/ 搜索/ ,/ 不过/ 此时/ 在/ 每个/ 层上/ 有/ 至多/ MaxHeap/ 个/ 节点/ 被/ 扩展/ ,/ 并且/ 已/ 计算/ 的/ 上层/ 节点/ 不会/ 被/ 再次/ 计算/ ./ 算法/ 3/ ./ 多层/ 启发式/ 搜索/ ./ MultiLayerSearch/ (/ ps/ ,/ depth/ ,/ maxD/ ,/ MaxHeap/ ,/ ef/ -/ fort/ )/ result/ ./ volumeComplete/ ·/ ·/ =/ 0addpstoheap/ [/ 0/ ]/ forlayer/ ·/ ·/ =/ 0todepth/ -/ 1dokeepheap/ [/ layer/ ]/ containingonlythebestMax/ -/ Heapelementsforeachpsinheap/ [/ layer/ ]/ doendforendforreturnthemaximuminheap/ [/ depth/ ]/ 算法/ 3/ 描述/ 了/ 多层/ 启发式/ 搜索算法/ ./ depth/ 参数/ 描述/ 了/ 要/ 装载/ 的/ 块/ 数目/ ;/ maxD/ 指定/ 了/ 在/ 每个/ 层/ 上将/ 尝试/ 的/ 最大/ 深度/ 值/ ;/ MaxHeap/ 如前所述/ 是/ 每个/ 层上/ 用/ 堆/ 维护/ 的/ 最优/ 的/ 部分/ 装载/ 方案/ 的/ 最大/ 数目/ ;/ branch/ 表示/ 可/ 放置/ 块/ 的/ 最大/ 数目/ ,/ 意味着/ 当前/ 层/ 的/ 宽度/ ;/ effort/ 正如/ 前/ 文/ 所述/ 用于/ 限制/ 每次/ 搜索/ 访问/ 的/ 节点/ 的/ 数目/ ,/ 对于/ 每/ 一个/ 搜索/ 深度/ d/ ,/ 相应/ 的/ 分支/ 数目/ b/ 被/ 计算/ 出以/ 用于/ 搜索/ ./ 算法/ 4/ 是/ 改进/ 的/ 带/ 深度/ 限制/ 的/ 深度/ 优先/ 搜索算法/ ,/ 其/ 不/ 只是/ 记录/ 局部/ 最优/ 解/ ,/ 而且/ 将/ 所有/ 叶子/ 节点/ 的/ 评估/ 结果/ 都/ 加到/ 相应/ 层上/ ./ 其中/ PlaceBlock/ ,/ RemoveBlock/ 抽象/ 了/ 块/ 装载/ 和/ 块/ 移除/ 的/ 过程/ ./ 算法/ ./ 算法/ 4/ ./ 改进/ 的/ 带/ 深度/ 限制/ 的/ 深度/ 优先/ 搜索/ DepthFirstSearch/ (/ ps/ ,/ depth/ ,/ branch/ ,/ layer/ )/ ifdepth/ ≠/ 0thenspace/ ·/ ·/ =/ ps/ ./ spaceStack/ ./ top/ (/ )/ blockList/ ·/ ·/ =/ GenBlockList/ (/ ps/ ./ space/ ,/ ps/ ./ avail/ )/ ifblockList/ ≠/ {/ }/ thenelseendifelseComplete/ (/ ps/ )/ addpstoheap/ [/ layer/ ]/ endif/ 算法/ 5/ 描述/ 了/ 块/ 装载/ 算法/ ,/ 主要/ 的/ 任务/ 是/ 将/ 块/ 和/ 栈顶/ 空间/ 结合/ 成/ 一个/ 装载/ 加入/ 当前/ 装载/ 方案/ ,/ 移除/ 栈顶/ 空间/ ,/ 去掉/ 已/ 使用/ 箱子/ ,/ 然后/ 划分/ 未/ 填充/ 空间/ 并/ 加入/ 到/ 剩余/ 空间/ 堆栈/ 中/ ./ 其中/ TransferSpace/ 用于/ 将/ 新/ 生成/ 的/ 剩余/ 空间/ 加入/ 堆栈/ ,/ TransferSpaceBack/ 是/ 其/ 逆/ 过程/ ,/ 用于/ 取消/ 被/ 加入/ 的/ 剩余/ 空间/ 以便/ 进行/ 搜索/ ./ 当/ 搜索/ 进行/ 到/ 目标/ 深度/ 时/ ,/ Complete/ (/ ps/ )/ 算法/ 每次/ 放入/ 体积/ 最大/ 的/ 块/ 直至/ 获得/ 一个/ 完整/ 的/ 装载/ 方案/ ./ 算法/ 5/ ./ 块/ 装载/ 算法/ ./ PlaceBlock/ (/ ps/ ,/ block/ )/ space/ ·/ ·/ =/ ps/ ./ spaceStack/ ./ top/ (/ )/ ps/ ./ spaceStack/ ./ pop/ (/ )/ ps/ ./ avail/ ·/ ·/ =/ ps/ ./ avail/ -/ block/ ./ requireps/ ./ plan/ ·/ ·/ =/ ps/ ./ plan/ +/ (/ space/ ,/ block/ )/ ps/ ./ plan/ ./ volume/ ·/ ·/ =/ ps/ ./ plan/ ./ volume/ +/ block/ ./ volumeps/ ./ spaceStack/ ./ push/ (/ GenResidulSpace/ (/ space/ ,/ block/ )/ )/ 算法/ 6/ 描述/ 了/ 块/ 移除/ 算法/ ,/ 它/ 是/ 算法/ 5/ 的/ 逆/ 过程/ ,/ 完成/ 的/ 工作/ 包括/ 从/ 当前/ 部分/ 装载/ 方案/ 中/ 移除/ 当前/ 块/ 所属/ 的/ 装载/ ,/ 恢复/ 已/ 使用/ 箱子/ ,/ 移除/ 空间/ 堆栈/ 栈顶/ 的/ 3/ 个/ 划分/ 出来/ 的/ 剩余/ 空间/ ,/ 并/ 将/ 已/ 使用/ 剩余/ 空间/ 重新/ 插入/ 栈顶/ ./ 算法/ 6/ ./ 块/ 移除/ 算法/ ./ RemoveBlock/ (/ ps/ ,/ block/ ,/ space/ )/ ps/ ./ avail/ ·/ ·/ =/ ps/ ./ avail/ +/ block/ ./ requireps/ ./ plan/ ·/ ·/ =/ ps/ ./ plan/ -/ (/ space/ ,/ block/ )/ ps/ ./ plan/ ./ volume/ ·/ ·/ =/ ps/ ./ plan/ ./ volume/ -/ block/ ./ volumePage6remove3topspacesfromps/ ./ spaceStackps/ ./ spaceStack/ ./ push/ (/ space/ )/ 图/ 2/ (/ a/ )/ 和/ (/ b/ )/ 分别/ 显示/ 了/ 多层/ 启发式/ 搜索算法/ 的/ 两个/ 运行/ 实例/ ,/ 图中/ 只/ 列出/ 了/ 最优/ 节点/ 相关/ 的/ 路径/ 和/ 分支/ ,/ 忽略/ 了/ 其它/ 一些/ 节点/ ./ 图/ 2/ (/ a/ )/ 显示/ 了/ 一个/ 典型/ 的/ 运行/ 结果/ ,/ 算法/ 从/ 第/ 0/ 层/ 开始/ 执行/ 深度/ 为/ 1/ 和/ 2/ 的/ 深度/ 优先/ 搜索/ ,/ 在/ 1/ 层中/ 算法/ 扩展/ 最优/ 的/ 两个/ 节点/ ,/ 其中/ 一个/ 节点/ 以/ 深度/ 2/ 执行/ 另/ 一次/ 深度/ 优先/ 搜索/ 后/ 找到/ 整个/ 过程/ 中/ 的/ 最优/ 节点/ (/ 见图/ 中/ 灰色/ 节点/ )/ ./ 图/ 2/ (/ b/ )/ 描述/ 的/ 实例/ 运行/ 过程/ 类似/ ,/ 区别/ 在于/ 这/ 一次/ 最优/ 节点/ 是/ 在/ 一次/ 深度/ 为/ 2/ 的/ 深度/ 优先/ 搜索/ 后/ 接着/ 一次/ 深度/ 为/ 1/ 的/ 搜索/ 中/ 找到/ 的/ ./ 现在/ 利用/ 多层/ 搜索算法/ 来/ 设计/ 块/ 选择/ 算法/ ./ 由于/ k/ +/ 1/ 层/ 最优/ 的/ N/ 个解/ 很/ 可能/ 只/ 来自/ k/ 层/ 最优/ 的/ N/ 个解/ ,/ 我们/ 不/ 需要/ 对/ 所有/ 的/ 可行/ 块/ 执行/ 最大/ 深度/ 的/ 多层/ 搜索/ ,/ 可以/ 用/ 不同/ 的/ 深度/ 进行/ 搜索/ ,/ 每次/ 采用/ 贪心/ 算法/ 过滤/ 掉/ 一些/ 不够/ 优秀/ 的/ 可行/ 块/ ./ 只要/ 保证/ 选择/ 的/ N/ 足够/ 大/ ,/ 使得/ 最终/ 的/ 最优/ 解以/ 很大/ 概率/ 被/ 包含/ 即可/ ./ 算法/ 7/ 描述/ 了/ 块/ 选择/ 算法/ 的/ 结构/ ./ 算法/ 采用/ 递增/ 的/ 搜索/ 深度/ 执行/ 多层/ 搜索/ ,/ 遍历/ 整个/ 可行/ 块/ 列表/ ,/ 尝试/ 装载/ 当前/ 块/ 到/ 当前/ 部分/ 装载/ 方案/ ,/ 然后/ 用/ 多层/ 搜索/ 来/ 评估/ 此/ 部分/ 装载/ 方案/ ,/ 并/ 将/ 多层/ 搜索/ 的/ 最优/ 填充/ 值/ 作为/ 被/ 选块/ 的/ 适应度/ ./ 排序/ 块/ 列表/ 中块/ 的/ 适应度/ ,/ 每次/ 过滤/ 掉/ 一半/ 不够/ 优秀/ 的/ 块/ ,/ 直到/ 可行/ 块/ 数目/ 不/ 大于/ N/ ./ 最后/ 返回/ 具有/ 最大/ 适应度/ 的/ 块/ ./ 如果/ 考虑/ C2/ 约束/ ,/ 则/ 只要/ 判断/ 当前/ 块/ 的/ 底部/ 是否/ 有/ 满足要求/ 的/ 支撑/ 即可/ ./ 算法/ 7/ ./ 块/ 选择/ 算法/ ./ FindNextBlock/ (/ ps/ ,/ blockList/ )/ fordepth/ ·/ ·/ =/ 1tomaxDepthdoforeachblockinblockListdoendforsorttheblockListbydecreasingfitnessifsize/ (/ blockList/ )/ >/ 2Nthenelseendifendforreturntheblockwithmaximumfitness3/ 实验/ 与/ 结果/ 3.1/ 算法/ 参数/ 和/ 测试数据/ 本文/ 的/ 多层/ 启发式/ 搜索算法/ (/ MLHS/ )/ 以/ C++/ 实现/ ,/ 实验/ 程序运行/ 在/ Intel/ ?/ Xeon/ ?/ X5460/ @/ 3.16/ GHz/ 处理器/ 上/ ./ 运行/ 环境/ 为/ DebianLinux/ ,/ 编译器/ 为/ gcc4/ ./ 3.2/ ./ 实验/ 中/ 设置/ 的/ 各项/ 常数/ 如表/ 1/ 所示/ ./ 常数/ 项值/ MinFillRate0/ ./ 98/ 复合/ 块/ 的/ 最低/ 填充/ 率/ MinAreaRate0/ ./ 96/ 可/ 放置/ 矩形/ 与/ 相应/ 复合/ 块/ 顶部/ 面积/ 比/ MaxTimes5/ 生成/ 块/ 的/ 最大/ 复杂/ 次数/ MaxBlocks10000/ 最大/ 块/ 数目/ N16/ 每层/ 最优/ 解/ 数目/ maxD2/ 每层/ 搜索/ 尝试/ 的/ 最大/ 深度/ MaxDepth6/ 分层/ 搜索/ 的/ 总/ 次数/ MaxHeap6/ 每层/ 扩展/ 的/ 节点/ 数/ MLHS/ 将/ 在/ 不同/ 的/ 参数设置/ 下/ 运行/ ,/ 参数/ 按照/ 从/ 简单/ 到/ 复杂/ 的/ 顺序/ 执行/ ,/ 并/ 选择/ 其中/ 最优/ 的/ 结果/ 作为/ 最终/ 解/ ./ 由于/ 当前/ 一组/ 参数/ 被/ 执行/ 完毕/ 后/ ,/ 所有/ 程序运行/ 时间/ 可能/ 会/ 超过/ 时间/ 限制/ (/ Time/ -/ Limit/ )/ ./ 因此/ ,/ 当/ 算法/ 运行/ 超过/ 时间/ 限制/ 则/ 在/ 完成/ 当前/ 参数/ 下/ 的/ 计算/ 后/ ,/ 不再/ 执行/ 下/ 一组/ 参数/ ./ 实验/ 中/ 一共/ 采用/ 6/ 组/ 参数设置/ ,/ 如表/ 2/ 所示/ ./ 其中/ 图/ 2/ 描述/ 了/ 参数/ 2/ 的/ 参数设置/ ,/ 其/ 分支/ branch/ =/ 2/ ./ Page7/ 参数/ 12/ 参数/ 23/ 参数/ 34/ 参数/ 45/ 参数/ 56/ 参数/ 67/ 本文/ 实验/ 采用/ 的/ 测试数据/ 来自/ 文献/ [/ 17/ ]/ ,/ 包括/ BR1/ ~/ BR15/ 一共/ 1500/ 个/ 三维/ 装箱/ 实例/ ,/ 它们/ 可以/ 从/ OR/ -/ Library/ ①/ 下载/ 或者/ http/ :/ // // 59.77/ ./ 16.8/ // Download/ ./ aspx/ #/ p4/ 网站/ 上/ 下载/ ./ 这些/ 实例/ 共/ 分为/ 15/ 种/ 类型/ ,/ 每类/ 100/ 个/ 问题/ ./ 每类/ 问题/ 中有/ 一定/ 数量/ 的/ 相同/ 类型/ (/ 具有/ 相同/ 的/ 长宽/ 高/ )/ 的/ 箱子/ ,/ 这/ 15/ 类/ 问题/ 中/ 箱子/ 的/ 类型/ 数从/ 1/ 到/ 100/ ,/ 异构/ 性/ 由弱到强/ ,/ 能够/ 很/ 好/ 地/ 测试/ 算法/ 在/ 不同/ 异构/ 性/ 装箱/ 问题/ 中/ 的/ 表现/ ./ 其中/ ,/ BR1/ ~/ BR7/ 的/ 箱子/ 类型/ 数为/ 3/ ~/ 20/ ,/ 属于/ 弱/ 异构/ 装箱/ 问题/ ;/ BR8/ ~/ BR15/ 的/ 箱子/ 类型/ 数从/ 30/ ~/ 100/ ,/ 属于/ 强/ 异构/ 装箱/ 问题/ ./ 3.2/ 计算结果/ 对于/ 来自/ 文献/ [/ 17/ ]/ 的/ 1500/ 个/ 实例/ ,/ 许多/ 研究者/ 表/ 3/ 各种/ 算法/ 对/ BR1/ ~/ BR7/ 的/ 填充/ 率/ 比较/ H/ _/ BR/ [/ 17/ ]/ GA/ _/ GB/ [/ 8/ ]/ TS/ _/ BG/ [/ 9/ ]/ PTSA/ [/ 11/ ]/ 顺序/ C193/ ./ 2393.2792/ ./ 8692.4091/ ./ 6190.8689/ ./ 6592.0/ 并行/ C193/ ./ 5293.7793/ ./ 5893.0592/ ./ 3491.7290/ ./ 5592.7/ MFB/ 算法/ [/ 21/ ]/ 随机/ 启发式/ 算法/ [/ 22/ ]/ H/ _/ B/ [/ 23/ ]/ SPBBL/ -/ CC4/ [/ 24/ ]/ 组合/ 启发式/ 算法/ CH/ [/ 28/ ]/ C189/ ./ 9491.1392/ ./ 0991.9491/ ./ 7291.4590/ ./ 9491.32/ GRASP/ [/ 12/ ]/ maximal/ -/ space/ [/ 13/ ]/ VNS/ [/ 14/ ]/ HSA/ [/ 29/ ]/ CLTRS/ [/ 15/ ]/ FDA/ [/ 30/ ]/ MLHS/ 从表/ 3/ 中/ 可以/ 看出/ ,/ 多层/ 启发式/ 算法/ MLHS/ 几乎/ 在/ 每类/ 问题/ 上/ 的/ 填充/ 率/ 都/ 超过/ 了/ 目前/ 已知/ 的/ 算法/ ,/ 平均/ 填充/ 率/ 超过/ 了/ 所有/ 比较/ 的/ 算法/ ./ 当/ 只/ 考虑/ C1/ 时/ ,/ MLHS/ 在/ BR1/ ~/ BR7/ 上/ 的/ 平均/ 填充/ 率/ 达到/ 了/ 95.34/ %/ ,/ 比/ 当前/ 最新/ 的/ VNS/ [/ 14/ ]/ 、/ FDA/ [/ 30/ ]/ 、/ 最好/ 的/ CLTRS/ [/ 15/ ]/ 分别/ 提高/ 了/ 0.81/ %/ ,/ 1.81/ %/ 和/ 0.32/ %/ ./ 当/ C1/ 和/ C2/ 均/ 考虑/ 时/ ,/ 比/ 当前/ 较/ 新/ 的/ HSA/ [/ 29/ ]/ 、/ 最好/ 的/ CLTRS/ [/ 15/ ]/ 分别/ 提高/ 了/ 1.39/ %/ 和/ 0.47/ %/ ./ 表/ 4/ 给出/ 了/ 各个/ 算法/ 在/ BR8/ ~/ BR15/ 上/ 的/ 运行/ 对/ 它们/ 或/ 其中/ 一部分/ 做过/ 测试/ ./ 比较/ 的/ 算法/ 包括/ 顺序/ 和/ 并行执行/ 的/ 禁忌/ 搜索算法/ (/ PTSA/ )/ [/ 11/ ]/ 、/ MFB/ 算法/ [/ 21/ ]/ 、/ 随机/ 启发式/ 算法/ [/ 22/ ]/ 、/ H/ _/ B/ 算法/ [/ 23/ ]/ 、/ 启发式/ 算法/ (/ SPBBL/ -/ CC4/ )/ [/ 24/ ]/ 、/ 组合/ 启发式/ 算法/ (/ CH/ )/ [/ 28/ ]/ ./ 这些/ 算法/ 致力于/ 研究/ 弱/ 异构/ 装箱/ 问题/ ,/ 即仅/ 测试/ BR1/ ~/ BR7/ ./ 特别/ 地/ ,/ 本文/ 还/ 比较/ 了/ H/ _/ BR/ 算法/ [/ 17/ ]/ 、/ GA/ _/ GB/ 算法/ [/ 8/ ]/ 和/ 禁忌/ 搜索算法/ TS/ _/ BG/ [/ 9/ ]/ 、/ 贪心/ 随机/ 自/ 适应/ 搜索算法/ (/ GRASP/ )/ [/ 12/ ]/ 、/ maximal/ -/ space/ 算法/ [/ 13/ ]/ 、/ 可变/ 邻域/ 搜索算法/ (/ VNS/ )/ [/ 14/ ]/ 、/ 混合/ 模拟退火/ 算法/ (/ HSA/ )/ [/ 29/ ]/ 、/ 最新/ 的/ 基于/ 整数/ 拆分/ 的/ 树状/ 搜索算法/ (/ CLTRS/ )/ [/ 15/ ]/ 以及/ FDA/ 算法/ [/ 30/ ]/ ./ 这些/ 算法/ 测试/ 了/ BR1/ ~/ BR15/ 的/ 1500/ 个/ 实例/ ./ 此外/ Huang/ 等/ 人/ [/ 31/ ]/ 提出/ 的/ A2/ 算法/ 只/ 计算/ 了/ BR8/ ~/ BR15/ ./ 上述/ 比较/ 的/ 算法/ 均/ 满足/ 方向性/ 约束/ C1/ ,/ 有些/ 算法/ 也/ 满足/ 稳定性/ 约束/ C2/ ,/ 它们/ 的/ 计算结果/ 均/ 直接/ 来自/ 于/ 相应/ 文献/ ./ 表/ 3/ 与表/ 4/ 报告/ 了/ 这些/ 算法/ 与/ MLHS/ 的/ 计算结果/ ,/ 斜体/ 数据表示/ 问题/ 满足/ 约束/ C1/ 和/ C2/ ./ 表中/ 所有/ 的/ 数据表示/ 填充/ 率/ (/ %/ )/ ,/ 即/ 不同/ 算法/ 针对/ 一类/ 问题/ 所/ 得到/ 的/ 平均/ 填充/ 率/ ,/ 而/ Mean/ 表示/ 算法/ 对/ 所/ 计算/ 问题/ 类/ 的/ 平均/ 填充/ 率/ ./ 结果/ ./ 对强/ 异构/ 问题/ ,/ MLHS/ 的/ 优势/ 更大/ ,/ 所有/ 数据/ 上/ 的/ 结果/ 均/ 超过/ 比较/ 的/ 算法/ ./ 当/ 只/ 考虑/ C1/ 时/ ,/ MLHS/ 在/ BR8/ ~/ BR15/ 上/ 的/ 平均/ 填充/ 率/ 达到/ 了/ 93.59/ %/ ,/ 比/ 当前/ 最新/ 的/ VNS/ [/ 14/ ]/ 、/ FDA/ [/ 30/ ]/ 和/ 最好/ 的/ CLTRS/ [/ 15/ ]/ 分别/ 提高/ 了/ 2.13/ %/ 、/ 1.69/ %/ 和/ 0.71/ %/ ./ 当/ C1/ 和/ C2/ 均/ 考虑/ 时/ ,/ 比/ 当前/ 较/ 新/ 的/ HSA/ [/ 29/ ]/ 和/ 最好/ 的/ CLTRS/ [/ 15/ ]/ 分别/ 提高/ 了/ 2.91/ %/ 和/ 1.01/ %/ ./ ①/ OR/ -/ Library/ ./ http/ :/ // // people/ ./ brunel/ ./ ac/ ./ uk/ // ~/ mastjjb/ // jeb/ // info/ ./ htmlPage8/ 表/ 4/ 各种/ 算法/ 对/ BR8/ ~/ BR15/ 的/ 填充/ 率/ 比较/ 算法/ H/ _/ BR/ [/ 17/ ]/ GA/ _/ GB/ [/ 8/ ]/ C1/ &/ C287/ ./ 5286.4685/ ./ 5384.8284/ ./ 2583.6782/ ./ 9982.4784/ ./ 71TS/ _/ BG/ [/ 9/ ]/ GRASP/ [/ 12/ ]/ A2/ [/ 31/ ]/ maximal/ -/ space/ [/ 13/ ]/ C191/ ./ 0290.4689/ ./ 8789.3689/ ./ 0388.5688/ ./ 4688.3689/ ./ 39VNS/ [/ 14/ ]/ HSA/ [/ 29/ ]/ CLTRS/ [/ 15/ ]/ FDA/ [/ 30/ ]/ MLHS/ 此外/ ,/ 对/ BR1/ ~/ BR15/ 数据/ ,/ 当/ 考虑/ 约束/ C1/ 时/ ,/ MLHS/ 算法/ (/ CPU/ 为/ 3.16/ GHz/ )/ 的/ 平均/ 运行/ 时间/ 为/ 197.33/ s/ ,/ 而/ CLTRS/ (/ CPU/ 为/ 2.6/ GHz/ )/ 的/ 平均/ 运行/ 时间/ 为/ 320s/ ./ 当/ 考虑/ 约束/ C1/ 和/ C2/ 时/ ,/ MLHS/ 的/ 平均/ 时间/ 为/ 187.26/ s/ ,/ 而/ CLTRS/ 的/ 平均/ 时间/ 为/ 320s/ ./ 相对来说/ ,/ MLHS/ 算法/ 所/ 需要/ 的/ 时间/ 更/ 短/ ./ 由于/ 三维/ 装箱/ 问题/ 具有/ 很大/ 的/ 实用价值/ ,/ 许多/ 研究者/ 对/ 其/ 进行/ 研究/ ,/ 填充/ 率/ 越来越/ 接近/ 最优/ ,/ 因此/ 提高/ 填充/ 率/ 已经/ 越来越/ 困难/ ,/ 但是/ MLHS/ 对/ BR/ 数据/ 集/ ,/ 当/ 考虑/ C1/ 、/ C1/ &/ C2/ 时/ ,/ 仍然/ 比/ 当前/ 最好/ 的/ 算法/ 分别/ 平均/ 改进/ 0.52/ %/ 、/ 0.74/ %/ ./ 这/ 表明/ 多层/ 启发式/ 搜索算法/ 求解/ 三维/ 装箱/ 问题/ 非常/ 有效/ ,/ 同时/ 我们/ 也/ 观察/ 到解/ 的/ 优秀/ 程度/ 在/ 一定/ 意义/ 上/ 是/ 可以/ 被/ 继承/ 的/ ,/ 即/ 一个/ 优秀/ 解/ 很/ 可能/ 导出/ 另/ 一个/ 优秀/ 解/ ./ 这个/ 特点/ 可以/ 描述/ 为/ :/ 虽然/ k/ 层上/ 的/ 最优/ 解不/ 一定/ 是/ k/ +/ 1/ 层上/ 最优/ 解/ 的/ 父/ 节点/ ;/ 但是/ ,/ k/ 层上/ 最优/ 的/ N/ 个解/ 很/ 可能/ 包括/ 了/ 所有/ k/ +/ 1/ 层上/ 最优/ 的/ N/ 个解/ 的/ 父/ 节点/ ./ 这/ 就是/ 为什么/ 多层/ 启发式/ 搜索算法/ 比/ 基于/ 整数/ 拆分/ 的/ 树状/ 搜索算法/ 更/ 优秀/ 的/ 关键/ 原因/ ,/ 只/ 选择/ 一个/ 最优/ 解有/ 可能/ 错过/ 下/ 一层/ 的/ 最优/ 解/ ,/ 而/ 选择/ 多个/ 最优/ 的/ 解/ 进行/ 后续/ 搜索/ 将/ 以/ 更/ 大/ 的/ 概率/ 包含/ 下/ 一层/ 的/ 最优/ 解/ ./ 4/ 结束语/ 在/ 文献/ [/ 15/ ,/ 29/ ]/ 研究/ 工作/ 的/ 基础/ 上/ ,/ 本文/ 提出/ 了/ 一个/ 非常/ 有效/ 的/ 多层/ 启发式/ 搜索算法/ ./ 该/ 算法/ 引入/ 了/ 复合/ 块/ 的/ 概念/ ,/ 并/ 对/ 其/ 加以/ 限制/ ,/ 同时/ 提出/ 了/ 基于/ 多层/ 搜索/ 的/ 块/ 选择/ 算法/ ,/ 使得/ 对于/ 装载/ 方案/ 的/ 评估/ 更加/ 准确/ 而/ 迅速/ ,/ 从而/ 得到/ 很/ 好/ 的/ 计算结果/ ./ 当然/ ,/ 由于/ 装箱/ 问题/ 的/ 复杂性/ 以及/ 启发式/ 算法/ 本身/ 的/ 缺陷/ ,/ 本文/ 算法/ 还有/ 一些/ 不足之处/ ./ 例如/ ,/ 随着/ 实例/ 规模/ 的/ 增大/ ,/ 复合/ 块/ 的/ 生成/ 方式/ 更/ 多/ ,/ 搜索/ 树/ 填充/ 率/ // %/ 也/ 会/ 更/ 复杂/ ,/ 可能/ 需要/ 较长/ 的/ 计算/ 时间/ ./ 因此/ ,/ 将来/ 的/ 工作/ 是/ 进一步/ 优化/ 算法/ ,/ 提高/ 计算速度/ ,/ 同时/ ,/ 结合实际/ 的/ 应用/ ,/ 考虑/ 更/ 多/ 的/ 约束条件/ ./ 

