Page1/ 一种/ 基于/ 关键/ 路径分析/ 的/ CPU/ -/ GPU/ 异构/ 系统/ 综合/ 能耗/ 优化/ 方法/ 林一松/ 杨学军/ 唐滔/ 王桂彬/ 徐/ 新海/ (/ 国防科学技术大学/ 并行/ 与/ 分布/ 处理/ 国家/ 重点/ 实验室/ 长沙/ 410073/ )/ 摘要/ GPU/ 强大/ 的/ 计算/ 性能/ 使得/ CPU/ -/ GPU/ 异构/ 体系结构/ 成为/ 高性能/ 计算/ 领域/ 热点/ 研究/ 方向/ ./ 虽然/ GPU/ 的/ 性能/ // 功耗/ 比较/ 高/ ,/ 但/ 在/ 构建/ 大规模/ 计算/ 系统/ 时/ ,/ 功耗/ 问题/ 仍然/ 是/ 限制/ 系统/ 运行/ 的/ 关键因素/ 之一/ ./ 现在/ 已有/ 的/ 针对/ GPU/ 的/ 功耗/ 优化/ 研究/ 主要/ 关注/ 如何/ 降低/ GPU/ 本身/ 的/ 功耗/ ,/ 而/ 没有/ 将/ CPU/ 和/ GPU/ 作为/ 一个/ 整体/ 进行/ 综合/ 考虑/ ./ 文中/ 深入分析/ 了/ CUDA/ 程序/ 在/ CPU/ -/ GPU/ 异构/ 系统/ 上/ 的/ 运行/ 特点/ ,/ 归纳/ 其中/ 的/ 任务/ 依赖/ 关系/ ,/ 给出/ 了/ 使用/ AOV/ 网/ 表示/ 程序执行/ 过程/ 的/ 方法/ ,/ 并/ 在/ 此基础/ 上/ 分析/ 程序运行/ 的/ 关键/ 路径/ ,/ 找出/ 程序/ 中/ 可以/ 进行/ 能耗/ 优化/ 的/ 部分/ ,/ 并/ 求解/ 相应/ 的/ 频率/ 调节/ 幅度/ ,/ 在/ 保持/ 程序/ 性能/ 不变/ 的/ 前提/ 下/ 最小化/ 程序/ 的/ 整体/ 能量消耗/ ./ 关键词/ 异构/ 系统/ ;/ GPU/ ;/ AOV/ 网络/ ;/ 动态/ 电压/ // 频率/ 调节/ ;/ 低功耗/ 优化/ 1/ 引言/ 半导体/ 工艺/ 的/ 发展/ 使得/ 芯片/ 上/ 集成/ 的/ 晶体管/ 数目/ 越来越/ 多/ ,/ 目前/ 已/ 达到/ 10/ 亿/ 的/ 量级/ ,/ 处理器/ 的/ 计算能力/ 也/ 越来越/ 强/ ./ 图形/ 处理器/ (/ GraphicsProcessingUnits/ ,/ GPU/ )/ 由于/ 最初/ 仅/ 用于/ 加速/ 图形处理/ ,/ 结构/ 比较简单/ ,/ 芯片/ 资源/ 可以/ 被/ 更为/ 有效/ 地/ 用于/ 提升/ 计算能力/ ,/ 因此/ 目前/ GPU/ 普遍/ 比/ 通用/ 处理器/ 的/ 性能/ 高出/ 一个/ 量级/ ./ 此外/ ,/ 随着/ GPU/ 的/ 编程/ 环境/ 不断完善/ ,/ 使用/ GPU/ 作为/ CPU/ 的/ 加速器/ 构造/ 异构/ 并行计算/ 系统/ 成为/ 高性能/ 计算/ 领域/ 的/ 热点/ 方向/ [/ 1/ ]/ ./ 例如/ 最新/ 发布/ 的/ 天河/ -/ 1A/ 系统/ 就/ 采用/ CPU/ -/ GPU/ 异构/ 系统结构/ ,/ 峰值/ 计算/ 性能/ 超过/ 4PFlops/ ,/ 位列/ 2010/ 年/ 12/ 月/ 发布/ 的/ Top500/ 超级计算机/ 排行榜/ 之/ 首/ ①/ ./ 由于/ 采用/ 了/ 专用/ 的/ 加速/ 部件/ ,/ 异构/ 系统/ 的/ 性能/ // 功耗/ 比/ 一般/ 高于/ 传统/ 的/ 同构/ 系统/ [/ 2/ ]/ ./ 但/ 不可否认/ 的/ 是/ ,/ 其/ 功耗/ 问题/ 依然/ 很/ 严峻/ ./ GPU/ 芯片/ 的/ 计算/ 单元/ 密度/ 高/ ,/ 发热量/ 较大/ ,/ 其/ 绝对/ 功耗/ 超出/ 通用/ 处理器/ ./ 在/ 构建/ 大规模/ 计算/ 系统/ 时/ ,/ GPU/ 的/ 功耗/ 将/ 提高/ 计算成本/ ,/ 同时/ 也/ 会/ 降低/ 系统/ 的/ 可靠性/ ,/ 因此/ 研究/ 异构/ 系统/ 的/ 功耗/ 优化/ 问题/ 具有/ 重大/ 的/ 意义/ ./ 现有/ 的/ 面向/ CPU/ -/ GPU/ 异构/ 系统/ 的/ 低功耗/ 优化/ 研究/ 多/ 关注/ 针对/ 单个/ 任务/ 的/ 划分/ 问题/ :/ 对于/ 给定/ 的/ 任务/ ,/ 如何/ 在/ CPU/ 和/ GPU/ 之间/ 进行/ 任务/ 划分/ ,/ 使得/ 异构/ 系统/ 在/ 满足/ 性能/ (/ 能量/ )/ 约束/ 的/ 条件/ 下/ ,/ 取得/ 能量/ (/ 性能/ )/ 最优/ 的/ 问题/ ./ 这里/ 的/ 任务/ 一般/ 是/ 指/ 没有/ 依赖/ 关系/ 的/ 循环/ 迭代/ ,/ 可以/ 任意/ 地/ 在/ CPU/ 和/ GPU/ 之间/ 进行/ 划分/ ./ 然而/ ,/ 很少/ 有/ 工作/ 针对/ CPU/ -/ GPU/ 异构/ 系统/ 的/ 特点/ 研究/ 整个/ 程序/ 的/ 功耗/ 优化/ 问题/ ./ CPU/ -/ GPU/ 异构/ 系统/ 上/ 执行/ 的/ 程序/ 具有/ 其/ 自身/ 的/ 特点/ ./ 对于/ 给定/ 的/ 一个/ CPU/ -/ GPU/ 程序/ 来说/ ,/ 其中/ 的/ 任务/ 大致/ 可以/ 分为/ 3/ 个/ 部分/ :/ CPU/ 计算/ 部分/ 、/ GPU/ 计算/ 部分/ 和/ CPU/ -/ GPU/ 通信/ 部分/ ./ 在/ 某些/ 条件/ 下/ ,/ 这/ 3/ 种/ 任务/ 可以/ 并行执行/ ./ 此外/ ,/ 数据/ 依赖/ 、/ 资源/ 冲突/ 等/ 原因/ 还/ 使得/ 各/ 任务/ 间/ 存在/ 一定/ 的/ 先后/ 依赖/ 关系/ ./ 因此/ 对/ 异构/ 系统/ 进行/ 能耗/ 优化/ ,/ 建立/ 能耗/ 优化/ 模型/ 的/ 关键在于/ 建立/ CPU/ -/ GPU/ 程序运行/ 过程/ 的/ 抽象/ 表示/ ,/ 该/ 抽象/ 表示/ 需要/ 描述/ CPU/ 计算/ 、/ GPU/ 计算/ 和/ CPU/ -/ GPU/ 通信/ 这/ 3/ 个/ 部分/ 以及/ 它们/ 之间/ 的/ 依赖/ 和/ 并行/ 关系/ ./ 基于/ 该/ 抽象/ 表示/ 才能/ 进一步/ 建立/ 能耗/ 优化/ 的/ 方法/ ./ 顶点/ 活动/ 网/ AOV/ (/ ActivityOnVertexnet/ -/ work/ )/ 是/ 描述/ 一项/ 工程/ 或/ 系统/ 进行/ 过程/ 的/ 有效/ 工具/ ./ 它们/ 描述/ 的/ 系统/ 运行/ 过程/ 中/ 通常/ 包含/ 若干/ 活动/ ,/ 每个/ 活动/ 都/ 持续/ 一定/ 的/ 时间/ ,/ 某些/ 活动/ 之间/ 可以/ 并行执行/ ,/ 某些/ 活动/ 之间/ 存在/ 依赖/ 关系/ ./ 这/ 一点/ 和/ 本文/ 面向/ 的/ CPU/ -/ GPU/ 异构/ 系统/ 上/ 程序/ 的/ 执行/ 过程/ 有/ 相似之处/ ,/ 但/ 也/ 不/ 完全相同/ ./ 后者/ 所/ 描述/ 的/ 任务/ 依赖/ 情况/ 更加/ 复杂/ ./ 此外/ ,/ AOV/ 网是/ 一种/ 求解/ 系统/ 关键/ 路径/ 的/ 有效/ 方法/ ,/ 而/ 程序/ 的/ 关键/ 路径/ 正是/ 进行/ 功耗/ 优化/ 的/ 重要依据/ ./ 值得/ 说明/ 的/ 是/ ,/ AOV/ 网/ 和/ 传统/ 的/ 程序/ 优化/ 经常/ 使用/ 的/ 任务/ 图/ (/ TaskGraph/ )/ 是/ 一种/ 类似/ 的/ 数据结构/ ./ 从/ 本质/ 上/ 说/ ,/ 使用/ 结点/ 表示/ 任务/ 的/ 任务/ 图/ 也/ 是/ 一种/ AOV/ 网/ ,/ 在/ 面向/ 具体/ 的/ 应用领域/ 时/ 可以/ 有/ 针对性/ 地/ 对/ 任务/ 图/ 进行/ 附加/ 的/ 定义/ 和/ 操作/ ./ 而/ 本文/ 只是/ 抽取/ 这种/ 数据结构/ 最/ 基本/ 的/ 特征/ ,/ 即/ 通过/ 任务/ 的/ 时间/ 和/ 依赖/ 关系/ 描述/ 系统/ 运行/ 过程/ 来/ 描述/ GPU/ 程序/ 的/ 执行/ 过程/ ,/ 并/ 利用/ 该/ 数据结构/ 最/ 基本/ 的/ 分析方法/ 来/ 分析程序/ 的/ 关键/ 路径/ ,/ 从而/ 为/ 功耗/ 优化/ 建模/ 提供/ 依据/ ./ 具体地说/ ,/ 本文/ 针对/ CPU/ -/ GPU/ 异构/ 系统/ 程序运行/ 的/ 特点/ ,/ 研究/ 如何/ 使用/ AOV/ 网/ 描述/ GPU/ 程序/ 的/ 运行/ 过程/ ,/ 并/ 在/ 此基础/ 上/ 对/ 程序/ 的/ 能耗/ 优化/ 问题/ 进行/ 建模/ 和/ 求解/ ./ 本文/ 的/ 创新/ 点/ 主要/ 包括/ 以下几点/ :/ (/ 1/ )/ 面向/ 典型/ 的/ CPU/ -/ GPU/ 异构/ 系统/ 编程/ 模型/ CUDA/ [/ 3/ ]/ ,/ 分析/ 并/ 归纳/ 了/ 其中/ 包含/ 的/ 4/ 种/ 任务/ 依赖/ 关系/ ./ (/ 2/ )/ 给出/ 了/ 将/ CUDA/ 程序/ 描述/ 为/ AOV/ 网/ 的/ 两个/ 算法/ ;/ (/ 3/ )/ 给出/ 了/ 基于/ AOV/ 网/ 的/ CUDA/ 程序/ 能耗/ 优化/ 方法/ ./ 本文/ 第/ 2/ 节/ 简要/ 介绍/ CUDA/ 程序运行/ 模型/ 并/ 对/ 提出/ 能耗/ 优化/ 的/ 问题/ ;/ 第/ 3/ 节/ 给出/ 基于/ AOV/ 网络/ 的/ 能耗/ 优化/ 求解/ 方法/ ;/ 第/ 4/ 节/ 给出/ 案例/ 分析/ ;/ 第/ 5/ 节/ 介绍/ 相关/ 工作/ ;/ 最后/ 总结/ 全文/ ./ 2/ 问题/ 提出/ 本/ 节/ 首先/ 简单/ 介绍/ CPU/ -/ GPU/ 异构/ 体系结构/ 和/ CUDA/ 编程/ 模型/ ,/ 然后/ 面向/ 能量消耗/ 分析/ CUDA/ 程序/ 在/ CPU/ -/ GPU/ 异构/ 系统/ 上/ 执行/ 时/ 存在/ 的/ 负载/ 不/ 平衡/ 的/ 问题/ ,/ 进而/ 给出/ 功耗/ 优化/ 的/ 问题/ 描述/ ./ 2.1/ 程序/ 模型/ 由/ CPU/ 和/ GPU/ 构成/ 的/ 异构/ 并行/ 系统结构/ 如图/ 1/ 所示/ ./ CPU/ 和/ GPU/ 一般/ 通过/ 外部/ 总线/ 互连/ ,/ 它们/ 各自/ 也/ 拥有/ 独立/ 的/ 片外/ DRAM/ 存储器/ ,/ 相互之间/ 可以/ 以/ DMA/ 的/ 方式/ 进行/ 数据通信/ ./ ①/ http/ :/ // // www/ ./ top500/ ./ org/ // lists/ // 2010/ // 11Page3CPU/ 和/ GPU/ 以/ Master/ -/ Slaver/ 的/ 方式/ 协同工作/ ,/ 其中/ CPU/ 是/ 主控/ 端/ ,/ 负责/ 组织/ 数据/ 和/ 调度/ GPU/ 的/ 执行/ ./ GPU/ 上/ 执行/ 的/ 代码/ 被/ 组织/ 成/ 一系列/ Kernel/ 函数/ ,/ CPU/ 以/ 函数调用/ 的/ 方式/ 调度/ GPU/ 执行/ ./ 图/ 2/ 给出/ 了/ 一个/ 典型/ 的/ CUDA/ 程序结构/ 及/ 执行/ 示意图/ ./ 左边/ 的/ 框图/ 为/ CUDA/ 程序/ 的/ 伪码/ ,/ 其中/ block1/ ~/ 4/ 为/ GPU/ 无关/ 的/ 计算/ 代码/ ,/ 我们/ 称为/ “/ CPU/ 任务/ ”/ ./ 涉及/ GPU/ 操作/ 的/ 部分/ 包括/ 在/ CPU/ 和/ GPU/ 存储空间/ 之间/ 传输数据/ 以及/ 启动/ Kernel/ 函数/ 的/ 执行/ ,/ 我们/ 将/ Kernel/ 函数/ 的/ 执行/ 称为/ “/ GPU/ 任务/ ”/ ,/ 而/ 数据/ 在/ CPU/ 和/ GPU/ 之间/ 的/ 传输/ 称为/ “/ 通信/ 任务/ ”/ ./ 图/ 2/ 一个/ 典型/ 的/ CUDA/ 程序/ 及/ 执行/ 示意图/ 由于/ CPU/ 和/ GPU/ 的/ 执行/ 部件/ 相互/ 独立/ ,/ 并且/ 数据通信/ 可以/ 通过/ 单独/ 的/ DMA/ 硬件/ 完成/ ,/ 因此/ 只要/ 不/ 存在/ 数据/ 依赖/ ,/ CPU/ 任务/ 、/ GPU/ 任务/ 和/ 通信/ 任务/ 是/ 可以/ 同时/ 执行/ 的/ ./ 为此/ CUDA/ 提供/ 了/ 异步/ 的/ 函数调用/ 接口/ ,/ 在/ 调用/ Kernel/ 函数/ 完成/ GPU/ 计算/ 和/ CudaMemcpy/ 完成/ 数据通信/ 时/ ,/ 可以/ 将/ 其/ 指定/ 为/ 异步/ 模式/ (/ 以/ “/ Async/ ”/ 为/ 后缀/ )/ ,/ 使得/ 它们/ 可以/ 和/ 其后/ 的/ CPU/ 代码/ 并行执行/ ./ 此外/ ,/ 异步/ 的/ 函数调用/ 之间/ 如果/ 没有/ 资源/ 冲突/ ,/ 即/ 不/ 占用/ 同/ 一种/ 硬件资源/ ,/ 也/ 可以/ 同时/ 执行/ ./ 为了/ 保证/ 程序/ 正确/ 执行/ ,/ CUDA/ 使用/ 如下/ 同步/ 机制/ 描述/ 异步/ 执行/ 的/ 函数/ 和/ 其后/ 的/ 代码/ 之间/ 的/ 依赖/ 关系/ :/ (/ 1/ )/ 为/ 每/ 一个/ 异步/ 的/ 通信/ 任务/ 和/ GPU/ 任务/ 指定/ 一个/ 任务/ 流/ (/ taskstream/ )/ ,/ 同一个/ 任务/ 流中/ 的/ 任务/ 必须/ 按照/ 到达/ 的/ 顺序/ 依次/ 执行/ ,/ 而/ 不同/ 的/ 任务/ 流/ 之间/ 则/ 没有/ 限制/ ./ (/ 2/ )/ 在/ CPU/ 端的/ 程序/ 中/ 调用/ 同步/ 函数/ 为/ 每个/ 任务/ 流/ 指定/ 一个/ 同步/ 点/ ,/ 在/ 同步/ 点处/ CPU/ 必须/ 等待/ 指定/ 的/ 任务/ 流中/ 所有/ 的/ 任务/ 执行/ 完毕/ 才能/ 继续执行/ ./ 我们/ 将/ 同步/ 函数/ 称为/ “/ 同步/ 任务/ ”/ ./ 同步/ 任务/ 又/ 可以/ 分为/ 局部/ 同步/ 任务/ 和/ 全局/ 同步/ 任务/ ,/ 前者/ 是/ 指/ 针对/ 某个/ 指定/ 的/ 任务/ 流/ 的/ 同步/ ,/ 而/ 后者/ 是/ 指/ 针对/ 所有/ 任务/ 流/ 的/ 同步/ ./ 此外/ ,/ CUDA/ 还/ 规定/ ,/ 除了/ 显式/ 地/ 调用/ 全局/ 同步/ 函数/ 外/ ,/ 没有/ 指定/ 为/ 异步/ 模式/ 的/ 通信/ 和/ GPU/ 任务/ 也/ 将/ 阻塞/ 所有/ 的/ 任务/ 流/ 直至/ 它们/ 全部/ 完成/ ,/ 即/ 在/ 这些/ 任务/ 之前/ 存在/ 一个/ 隐含/ 的/ 全局/ 同步/ 点/ ./ 2.2/ 能耗/ 优化/ 问题/ 处理器/ 的/ 功耗/ 包括/ 静态/ 功耗/ 和/ 动态/ 功耗/ ,/ 其中/ 静态/ 功耗/ 取决于/ 芯片/ 的/ 电气/ 特性/ ,/ 而/ 动态/ 功耗/ 则/ 取决于/ 芯片/ 工作/ 的/ 电压/ 和/ 频率/ ,/ 一般来说/ 后者/ 是/ 低功耗/ 优化/ 的/ 重点/ ./ 动态/ 电压/ // 频率/ 调节/ DVFS/ (/ DynamicVoltage/ // FrequencyScaling/ )/ [/ 4/ ]/ 是/ 一种/ 广泛/ 使用/ 的/ 动态/ 功耗/ 优化/ 技术/ ,/ 它/ 通过/ 在/ 一定/ 范围/ 内/ 降低/ 处理器/ 的/ 电压/ // 频率/ 以/ 减少/ 其/ 能量/ 的/ 消耗/ ./ 通常/ ,/ CMOS/ 电路/ 的/ 核心/ 电压/ 和/ 其/ 工作频率/ 一般/ 要/ 同时/ 调节/ 才能/ 保证/ 电路/ 正常/ 工作/ ,/ 它们/ 之间/ 满足/ f/ ∝/ (/ V/ -/ Vt/ )/ γ/ // V/ ,/ 其中/ Vt/ 是/ 阈值电压/ ,/ γ/ 为/ 工艺/ 相关/ 的/ 参数/ ./ 通常/ 情况/ 下/ Vt/ 远/ 小于/ V/ 且/ γ/ ∈/ [/ 1/ ,/ 2/ ]/ ./ 本文/ 假定/ γ/ =/ 2/ ,/ 此时/ 频率/ f/ 和/ 电压/ V/ 近似/ 为/ 线性关系/ ./ 此时/ 根据/ CMOS/ 电路/ 的/ 功耗/ 公式/ P/ =/ α/ CV2f/ ,/ 功耗/ P/ 可以/ 看成/ 和/ 频率/ f/ 的/ 立方/ 成正比/ ,/ 即/ P/ ∝/ f3/ ./ 此外/ ,/ 我们/ 还/ 近似/ 地/ 认为/ 程序/ 在/ 处理器/ 上/ 的/ 执行/ 时间/ 和/ 处理器/ 的/ 工作频率/ 成反比/ ,/ 即/ T/ ∝/ f/ -/ 1/ ,/ 因此/ 程序/ 在/ 处理器/ 上/ 运行/ 所/ 消耗/ 的/ 能量/ 满足/ E/ =/ PT/ ∝/ f2/ ./ 综上/ ,/ 本文/ 在/ 进行/ 能耗/ 优化/ 时/ ,/ 只/ 考虑/ 对/ 处理器/ 频率/ 的/ 调节/ ./ 注意/ 到/ ,/ 这里/ 对/ CMOS/ 电路/ 以及/ 处理器/ 的/ 功耗/ 计算/ 模型/ 进行/ 的/ 假设/ 只是/ 为了/ 简化/ 后续/ 的/ 描述/ ,/ 并/ 不/ 影响/ 本文/ 所/ 提出/ 的/ 使用/ AOV/ 网络/ 对/ 程序/ 进行/ 分析/ 并/ 构建/ 功耗/ 优化/ 模型/ 的/ 方法/ ./ 根据/ 2.1/ 节/ 的/ 描述/ ,/ CPU/ 任务/ 、/ GPU/ 任务/ 和/ 通信/ 任务/ 三者/ 间/ 的/ 异步/ 执行/ 意味着/ CPU/ 和/ GPU/ 间/ 可能/ 存在/ 负载/ 不/ 平衡/ 的/ 情况/ ,/ 即/ 在/ 某个/ 同步/ 点处/ CPU/ (/ GPU/ )/ 由于/ 提前完成/ 任务/ 而/ 等待/ GPU/ (/ CPU/ )/ 任务/ 或/ 通信/ 任务/ 的/ 完成/ ./ 从/ 能量消耗/ 的/ 角度看/ ,/ 这种/ 情况/ 不是/ 能量最优/ 的/ :/ 完成/ 较/ 早/ 的/ 任务/ 可以/ 以较/ 低/ 的/ 频率/ 运行/ ,/ 使得/ 它/ 和/ 完成/ 较晚/ 的/ 任务/ 同时/ 到达/ 同步/ 点/ ,/ 此时/ 在/ 不/ 延长/ 整体/ 执行/ 时间/ 的/ 情况/ 下/ ,/ 可以/ 降低/ 程序/ 整体/ 的/ 能量消耗/ ./ Page4/ 一般来说/ ,/ CUDA/ 程序/ 在/ CPU/ -/ GPU/ 异构/ 系统/ 上/ 运行/ 带来/ 的/ 总/ 能量消耗/ 为/ E/ =/ Eactive/ +/ Estatic/ =/ ∑/ EC/ +/ ∑/ EG/ +/ ∑/ ET/ +/ PstaticT/ ,/ 其中/ EC/ ,/ EG/ 和/ ET/ 分别/ 代表/ CPU/ 任务/ ,/ GPU/ 任务/ 和/ 通信/ 任务/ 的/ 能量消耗/ ./ 在/ 本文/ 的/ 模型/ 中/ ,/ 可以/ 通过/ DVFS/ 技术/ 调节/ 的/ 是/ CPU/ 和/ GPU/ 的/ 工作频率/ ,/ 因此/ 通信/ 部分/ 的/ 动态/ 能量消耗/ 不变/ ;/ 此外/ ,/ 能耗/ 优化/ 的/ 前提/ 是/ 保持/ 程序/ 的/ 总/ 运行/ 时间/ 不变/ ,/ 因此/ 由/ 静态/ 功耗/ 带来/ 的/ 能量消耗/ 也/ 可以/ 视为/ 常数/ ./ 此时/ ,/ 程序/ 的/ 能量最优/ 问题/ 等价/ 于/ 在/ 程序执行/ 总/ 时间/ 不变/ 的/ 前提/ 下/ 最小化/ CPU/ 任务/ 和/ GPU/ 任务/ 的/ 总/ 能量消耗/ ./ 需要/ 注意/ 的/ 是/ ,/ 这里/ 所指/ 的/ 程序执行/ 总/ 时间/ 是/ 指/ 程序/ 在/ CPU/ 和/ GPU/ 分别/ 处于/ 最高/ 工作频率/ 下/ 的/ 执行/ 时间/ ./ 使用/ DVFS/ 技术/ 调节/ CPU/ 或/ GPU/ 处理器/ 的/ 频率/ 时/ 需要/ 考虑/ 两/ 方面/ 的/ 问题/ :/ 寻找/ 调节/ 时机/ 和/ 确定/ 调节/ 幅度/ ./ 程序运行/ 过程/ 中/ ,/ 某些/ 任务/ 的/ 执行/ 时间/ 直接/ 影响/ 整个/ 程序/ 的/ 执行/ 时间/ ,/ 我们/ 称其为/ “/ 关键/ 任务/ ”/ ./ 为/ 保持/ 程序运行/ 时间/ 不变/ ,/ 我们/ 不能/ 对/ 关键/ 任务/ 进行/ 频率/ 调节/ ./ 因此/ 寻找/ 调节/ 时机/ 是/ 指/ 在/ 程序/ 中/ 寻找/ 不/ 影响/ 程序/ 总体/ 执行/ 时间/ 的/ 前提/ 下/ 可以/ 进行/ 频率/ 调节/ 的/ CPU/ 任务/ 和/ GPU/ 任务/ ,/ 我们/ 统称/ 为/ “/ 非关键/ 任务/ ”/ ;/ 而/ 确定/ 调节/ 幅度/ 则/ 根据/ 非关键/ 任务/ 的/ 执行/ 时间/ 以及/ 不/ 影响/ 程序/ 总/ 时间/ 时该/ 任务/ 最大/ 可能/ 的/ 执行/ 时间/ 确定/ 处理器/ 频率/ 调节/ 的/ 幅度/ ./ 因此/ ,/ 对于/ 给定/ 的/ CUDA/ 程序/ ,/ 其/ 面向/ CPU/ -/ GPU/ 异构/ 系统/ 的/ 能耗/ 优化/ 问题/ 可以/ 描述/ 为/ :/ 在/ 程序/ 中/ 寻找/ 一组/ 非关键/ 任务/ 并/ 确定/ 相应/ 的/ CPU/ 或/ GPU/ 频率/ 调节/ 系数/ ,/ 使得/ 程序/ 在/ CPU/ -/ GPU/ 异构/ 系统/ 上/ 运行/ 的/ 总/ 时间/ 不变/ 而/ 能量最优/ ./ 本文/ 求解/ 这一/ 问题/ 的/ 思路/ 为/ (/ 1/ )/ 首先/ 从/ 程序/ 中/ 分离/ 出/ 不同/ 类型/ 的/ 任务/ ,/ 然后/ 将/ 运行/ 的/ 过程/ 描述/ 为/ 任务/ 之间/ 的/ 依赖/ 关系/ ,/ 构造/ 表示/ 程序运行/ 过程/ 的/ AOV/ 网络/ ./ (/ 2/ )/ 其次/ 对/ AOV/ 网络/ 进行/ 分析/ ,/ 确定/ 关键/ 路径/ ,/ 则/ 非关键/ 路径/ 上/ 的/ CPU/ 和/ GPU/ 任务/ 为/ 可以/ 进行/ 频率/ 调节/ 以/ 节省/ 能耗/ 的/ 非关键/ 任务/ ./ (/ 3/ )/ 最后/ 根据/ 关键/ 路径/ 上/ 任务/ 执行/ 的/ 时间/ 确定/ 非关键/ 任务/ 可以/ 放松/ 的/ 执行/ 时间/ ,/ 从而/ 求解/ 每个/ 任务/ 的/ 处理器/ 频率/ 调节/ 幅度/ 以/ 最小化/ 能量/ 的/ 消耗/ ./ 3/ 问题/ 求解/ 3.1/ CUDA/ 程序/ 的/ AOV/ 网/ 表示/ 由于/ CUDA/ 程序运行/ 过程/ 中/ 存在/ 复杂/ 的/ 并行/ 和/ 同步/ 机制/ ,/ 因此/ 寻找/ 程序/ 中/ 所有/ 的/ 非关键/ 任务/ 的/ 难点/ 在于/ 通过/ 某种/ 抽象/ 表示/ 将/ 程序/ 中/ 任务/ 间/ 的/ 并行/ 和/ 依赖/ 关系/ 描述/ 出来/ ./ 本文/ 采用/ AOV/ 网/ 描述/ CUDA/ 程序/ 中/ 任务/ 之间/ 的/ 并行/ 和/ 依赖/ 关系/ ./ CUDA/ 程序/ 中/ 任务/ 之间/ 的/ 并行/ 与/ 依赖/ 关系/ 比较复杂/ ,/ 其中/ 并行/ 关系/ 主要/ 包括/ CPU/ 任务/ 、/ GPU/ 任务/ 和/ 通信/ 任务/ 之间/ 的/ 并行/ ,/ 而/ 依赖/ 关系/ 则/ 可以/ 归纳/ 为/ 以下/ 4/ 种/ :/ (/ 1/ )/ 程序/ 依赖/ (/ programdependency/ )/ ,/ 是/ 指/ 由/ 程序/ 序/ 决定/ 的/ 依赖/ ;/ (/ 2/ )/ 流/ 依赖/ (/ streamdependency/ )/ ,/ 是/ 指/ 同一个/ 任务/ 流/ 内部/ 的/ 任务/ 之间/ 的/ 依赖/ ;/ (/ 3/ )/ 同步/ 依赖/ (/ synchdependency/ )/ ,/ 是/ 指/ 在/ 同步/ 点处/ ,/ 除/ 0/ 号/ 任务/ 流外/ 其它/ 任务/ 流中/ 的/ 任务/ 与/ 同步/ 任务/ 之间/ 的/ 依赖/ ①/ ;/ (/ 4/ )/ 资源/ 依赖/ (/ resourcedependency/ )/ ,/ 是/ 指/ 使用/ 同/ 一种/ 资源/ ,/ 如/ 通信/ 部件/ 或/ GPU/ 的/ 多个/ 任务/ 之间/ 存在/ 的/ 依赖/ 关系/ ./ 注意/ 到/ ,/ 程序/ 依赖/ 、/ 流/ 依赖/ 和/ 同步/ 依赖/ 都/ 描述/ 了/ 一种/ 先后/ 依赖/ 关系/ ,/ 即/ 任务/ 间/ 的/ 先后/ 关系/ ,/ 而/ 资源/ 依赖/ 则/ 描述/ 了/ 任务/ 间/ 的/ 互斥/ 关系/ ./ 传统/ 的/ AOV/ 网/ 可以/ 表示/ 先后/ 的/ 依赖/ 关系/ ,/ 而/ 无法/ 表示/ 互斥/ 关系/ ,/ 因此/ 我们/ 需要/ 将/ 互斥/ 关系/ 转化/ 为/ 先后/ 依赖/ 关系/ 才能/ 完整/ 地/ 描述/ CUDA/ 程序/ 的/ 行为/ ./ 下面/ 我们/ 首先/ 根据/ CUDA/ 程序/ 构造/ 初步/ 的/ AOV/ 网/ ,/ 我们/ 称为/ 任务/ 依赖图/ ,/ 其中/ 包含/ 前/ 3/ 种/ 依赖/ 关系/ ,/ 然后/ 再/ 对/ 任务/ 依赖图/ 进行/ 处理/ ,/ 加入/ 资源/ 依赖/ 关系/ 的/ 描述/ ./ 定义/ 1/ ./ 任务/ 依赖图/ (/ TaskDependencyGraph/ )/ ./ 程序/ P/ 的/ 任务/ 依赖图/ G/ =/ (/ V/ ,/ E/ )/ 是/ 一个/ 有/ 向/ 无圈图/ ,/ 其中/ V/ 为/ 结点/ 集合/ ,/ 表示/ 程序/ 中/ 的/ 任务/ ,/ E/ 为/ 连接/ 结点/ 的/ 有/ 向/ 边/ ,/ 表示/ 任务/ 之间/ 的/ 先后/ 依赖/ 关系/ ./ 每个/ 结点/ 可以/ 用/ 一个二元/ 组/ 表示/ v/ :/ 〈/ type/ ,/ time/ 〉/ ,/ 其中/ type/ 表示/ 结点/ 的/ 类型/ ,/ 包括/ CPU/ 任务/ 、/ GPU/ 任务/ 、/ 通信/ 任务/ 和/ 同步/ 任务/ ,/ 分别/ 记为/ C/ 、/ G/ 、/ T/ 和/ S/ ;/ 而/ time/ 表示/ 该/ 任务/ 需要/ 执行/ 的/ 时间/ ./ e/ :/ 〈/ v1/ ,/ v2/ 〉/ ∈/ E/ 表示/ v2/ 必须/ 在/ v1/ 完成/ 之后/ 才能/ 开始/ ./ 由于/ 同步/ 任务/ 只/ 为/ 描述/ 异步/ 的/ GPU/ 、/ 通信/ 任务/ 和/ CPU/ 任务/ 之间/ 的/ 同步/ 关系/ ,/ 它/ 本身/ 的/ 执行/ 时间/ 为/ 0/ ;/ 通信/ 任务/ 的/ 时间/ 可以/ 根据/ 带宽/ 和/ 通信量/ 计算/ 得出/ ;/ 而/ CPU/ 任务/ 和/ GPU/ 任务/ 的/ 时间/ 可以/ 参照/ 已有/ 的/ 性能/ 模型/ [/ 5/ -/ 6/ ]/ 进行/ 估算/ ./ 关于/ 任务/ 执行/ 时间/ 的/ 静态/ 分析/ 不是/ 本文/ 研究/ 的/ 重点/ ,/ 因此/ 这里/ 不/ 展开讨论/ ./ 对于/ 图/ 2/ 中/ 所示/ 的/ 程序段/ ,/ 假定/ 所有/ 的/ 通信/ 任/ ①/ 同步/ 任务/ 由/ CPU/ 执行/ ,/ 默认/ 在/ 0/ 号/ 任务/ 流中/ ,/ 因此/ 0/ 号任/ Page5/ 务/ 和/ GPU/ 任务/ 都/ 指定/ 为/ 异步/ 的/ ,/ 并且/ 每组/ 和/ GPU/ 相关/ 的/ 两个/ 任务/ 分别/ 放入/ 两条/ 任务/ 流中/ ./ 此外/ ,/ 还/ 假定/ 程序段/ 结束/ 处/ 调用/ 了/ 全局/ 的/ 同步/ 函数/ ./ 其/ 任务/ 依赖图/ 如图/ 3/ 所示/ ./ 如图/ 3/ 所示/ ,/ 程序/ 中/ 包含/ 3/ 条/ 任务/ 流/ ,/ 根据/ CUDA/ 程序/ 的/ 定义/ ,/ 所有/ 的/ CPU/ 任务/ 、/ 同步/ 任务/ 以及/ 同步/ 模式/ 的/ 通信/ 、/ GPU/ 任务/ 都/ 被/ 划入/ 0/ 号/ 任务/ 流/ ./ 下面/ 讨论/ 任务/ 依赖图/ 的/ 构造方法/ ./ 假定/ 给定/ CUDA/ 程序/ 的/ 指令/ 序列/ 中/ 和/ GPU/ 相关/ (/ 通信/ 函数/ 、/ Kernel/ 函数/ 、/ 同步/ 函数/ )/ 的/ 指令/ 有/ P/ 个/ ,/ 并且/ 这些/ 指令/ 将/ CPU/ 指令/ 序列/ 划分/ 为/ Q/ 段/ 连续/ 的/ 子/ 序列/ ,/ 我们/ 将/ 每个/ 连续/ 的/ CPU/ 指令/ 子/ 序列/ 和/ 每个/ GPU/ 相关/ 的/ 指令/ 都/ 对应/ 为/ 一个/ 任务/ ,/ 因此/ 整个/ 程序/ 总共/ 包含/ P/ +/ Q/ 个/ 任务/ ./ 记/ / =/ (/ M1/ ,/ M2/ ,/ …/ ,/ MP/ +/ Q/ )/ 为/ 按照/ 程序/ 序/ 排列/ 的/ 任务/ 序列/ ,/ 对于/ 1/ / i/ / P/ +/ Q/ ,/ Type/ (/ Mi/ )/ 为/ 任务/ 的/ 类型/ ,/ 取值/ 范围/ 为/ {/ C/ ,/ G/ ,/ T/ ,/ S/ }/ ,/ 分别/ 表示/ CPU/ 任务/ 、/ GPU/ 任务/ 、/ 通信/ 任务/ 和/ 同步/ 任务/ ,/ Time/ (/ Mi/ )/ 为/ 任务/ 所/ 需/ 的/ 时间/ ./ 此外/ ,/ 记/ Q/ (/ Mi/ )/ 为/ 任务/ Mi/ 所属/ 的/ 任务/ 队列/ 的/ 编号/ ,/ 对于/ 所有/ 的/ 非/ 异步/ 任务/ ,/ 包括/ CPU/ 任务/ 、/ 同步/ 的/ GPU/ 、/ 通信/ 任务/ 以及/ 同步/ 任务/ ,/ 都/ 有/ Q/ (/ Mi/ )/ =/ 0/ ./ 除了/ 默认/ 的/ 0/ 号/ 任务/ 流外/ ,/ 假定/ 程序/ 中/ 一共/ 包含/ q/ 条/ 任务/ 流/ ./ 特别/ 地/ ,/ 对于/ 同步/ 任务/ ,/ 记/ TS/ (/ Mi/ )/ 为/ 该/ 同步/ 函数/ 所/ 同步/ 的/ 任务/ 流/ 的/ 编号/ ,/ 若/ 同步/ 函数/ 是/ 全局/ 同步/ 函数/ ,/ 则/ 记/ TS/ (/ Mi/ )/ =/ 0/ ./ 根据/ CUDA/ 的/ 定义/ ,/ 同步/ 的/ GPU/ 和/ 通信/ 任务/ 也/ 具有/ 全局/ 同步/ 的/ 作用/ ,/ 因此/ 对于/ 它们/ 也/ 有/ TS/ (/ Mi/ )/ =/ 0/ ./ 算法/ 1/ 给出/ 构造/ 任务/ 依赖图/ 的/ 具体/ 过程/ ./ 算法/ 1/ ./ 构造/ 任务/ 依赖图/ ./ 1/ ./ Input/ :/ / =/ (/ M1/ ,/ M2/ ,/ …/ ,/ MP/ +/ Q/ )/ 2/ ./ Output/ :/ G/ =/ (/ V/ ,/ E/ )/ 3/ ./ letT0/ ,/ T1/ ,/ …/ ,/ Tqbethelatestnodeineachtask4/ ./ T0/ ,/ T1/ ,/ …/ ,/ Tq/ ←/ / // // / meansnotaskinthestream5/ ./ V/ ←/ ∪/ 1/ / i/ / P/ +/ Q6/ ./ fori/ =/ 1toP/ +/ Qdo7/ ./ ifT0/ ≠/ / then8/ ./ E/ ←/ E/ ∪/ {/ e/ :/ 〈/ T0/ ,/ vi/ 〉/ }/ // // aprogramdependency9/ ./ endif10/ ./ ifQ/ (/ Mi/ )/ ≠/ 0then/ // // forasynchronoustask11/ ./ ifTQ/ (/ Mi/ )/ ≠/ / then12/ ./ E/ ←/ E/ ∪/ {/ e/ :/ 〈/ TQ/ (/ Mi/ )/ ,/ vi/ 〉/ }/ // // anstreamdependency13/ ./ endif14/ ./ elseifTS/ (/ Mi/ )/ =/ 0then/ // // forglobalsynchronous15/ ./ forj/ =/ 1toqdo16/ ./ ifTj/ ≠/ / then17/ ./ E/ ←/ E/ ∪/ {/ e/ :/ 〈/ Tj/ ,/ vi/ 〉/ }/ // // ansynchdependency18/ ./ Tj/ ←/ / 19/ ./ endif20/ ./ endfor21/ ./ else/ // // forlocalsynchronous22/ ./ E/ ←/ E/ ∪/ {/ e/ :/ 〈/ TTS/ (/ Mi/ )/ ,/ vi/ 〉/ }/ // // ansynchdependency23/ ./ TTS/ (/ Mi/ )/ ←/ / 24/ ./ endif25/ ./ TQ/ (/ Mi/ )/ ←/ vi26/ ./ endfor/ 从/ 算法/ 1/ 可以/ 看出/ ,/ 在/ 所有/ 的/ 任务/ 按照/ 程序/ 序/ 排列/ 构成/ 的/ 序列/ 中/ ,/ 所有/ 的/ 有/ 向/ 边/ 都/ 是从/ 一个/ 编号/ 较/ 小/ 的/ 结点/ 指向/ 一个/ 编号/ 较大/ 的/ 结点/ ,/ 这/ 就/ 保证/ 了/ 依赖图/ 中/ 必然/ 不/ 包含/ 回路/ ,/ 是/ 有/ 向/ 无圈图/ ./ 生成/ 任务/ 依赖图/ 后/ ,/ 我们/ 再/ 考虑/ 可以/ 并发/ 执行/ 的/ 任务/ 之间/ 的/ 资源/ 冲突/ ,/ 即/ 在/ 任务/ 依赖图/ 中/ 加入/ 因/ 资源/ 冲突/ 导致/ 的/ 任务/ 间/ 的/ 依赖/ 关系/ ./ 考虑/ 资源/ 冲突/ 的/ 情况/ 下/ ,/ 程序/ 的/ 实际/ 执行/ 过程/ 依赖于/ 一定/ 的/ 冲突/ 仲裁/ 机制/ ./ 本文/ 的/ 模型/ 中/ 我们/ 假定/ GPU/ 运行/ 时/ 采用/ 如下/ 冲突/ 仲裁/ 机制/ :/ 若/ 某/ 一/ 时刻/ 任务/ 流中/ 同时/ 存在/ 多个/ 满足/ 先后/ 依赖/ 关系/ 但/ 存在/ 资源/ 冲突/ 的/ 任务/ ,/ 则/ 优先选择/ 任务/ 流/ 编号/ 较/ 小/ 的/ 任务/ 执行/ ./ 例如/ ,/ 当/ CPU/ 任务/ C1/ 执行/ 完成/ 后/ ,/ 满足/ 依赖/ 关系/ 的/ 任务/ 包括/ T1/ 、/ T2/ 和/ C2/ ,/ 其中/ T1/ 和/ T2/ 同为/ 通信/ 任务/ ,/ 存在/ 资源/ 冲突/ 不能/ 同时/ 执行/ ,/ 此时/ 优先/ 执行/ T1/ ./ 当/ 两个/ 任务/ 间/ 存在/ 潜在/ 的/ 资源/ 冲突/ 时/ ,/ 必须/ 为/ 其/ 定义/ 一个/ 先后/ 的/ 依赖/ 关系/ ,/ 因此/ 在/ 任务/ 依赖图/ 中/ 加入/ 资源/ 依赖/ 的/ 目标/ 是/ :/ 对于/ 任意/ 两个/ 任务/ Mi/ 和/ Mj/ ,/ 如果/ 它们/ 使用/ 了/ 相同/ 的/ 资源/ (/ GPU/ 或/ 通信/ 部件/ )/ ,/ 则/ 它们/ 之间/ 必须/ 存在/ 通路/ ./ 为了/ 缩小/ 考察/ 的/ 任务/ 范围/ ,/ 我们/ 首先/ 分析/ 任务/ 依赖图/ 中/ 一定/ 存在/ 通路/ 的/ 情况/ ./ 根据/ 算法/ 1/ 中/ 添加/ 依赖边/ 的/ 方法/ 可以/ 得知/ AOV/ 网/ 满足/ 以下/ 3/ 个/ 性质/ ./ 性质/ 1/ ./ 若/ Mi/ 和/ Mj/ 中/ 至少/ 有/ 一个/ 是/ 同步/ 模式/ 的/ 任务/ ,/ 则/ 根据/ CUDA/ 的/ 规定/ ,/ 同步/ 模式/ 的/ GPU/ 和/ 通信/ 任务/ 本身/ 隐含/ 着/ 一次/ 全局/ 同步/ ,/ 换言之/ ,/ 它们/ 是/ 任务/ 依赖图/ 中/ 从/ 程序/ 开始/ 到/ 程序/ 结束/ 的/ 必经/ 结/ Page6/ 点/ ,/ 它们/ 和/ 任意/ 结点/ 间/ 都/ 存在/ 通路/ ;/ 性质/ 2/ ./ 若/ Mi/ 和/ Mj/ 都/ 是/ 异步/ 模式/ 的/ 任务/ ,/ 此时/ 如果/ Q/ (/ Mi/ )/ =/ Q/ (/ Mj/ )/ ,/ 即/ 两个/ 任务/ 处于/ 同/ 一条/ 任务/ 流中/ ,/ 则/ 它们/ 之间/ 必然/ 存在/ 通路/ ;/ 性质/ 3/ ./ 否则/ ,/ Mi/ 和/ Mj/ 都/ 是/ 异步/ 模式/ 的/ 任务/ ,/ 且/ Q/ (/ Mi/ )/ ≠/ Q/ (/ Mj/ )/ ,/ 此时/ 不妨/ 假定/ 在/ 程序/ 序中/ Mi/ 早于/ Mj/ (/ 记为/ Mi/ / Mj/ )/ ./ 根据/ 算法/ 1/ 的/ 第/ 8/ 行/ 可知/ ,/ 对于/ 异步/ 模式/ 的/ 任务/ Mj/ ,/ 必然/ 存在/ 一条/ 有/ 向/ 边/ 从/ 某个/ 位于/ 0/ 号/ 任务/ 流中/ 任务/ 指向/ Mj/ ,/ 记/ 这个/ 0/ 号/ 任务/ 流中/ 的/ 任务/ 为/ Pre/ (/ Mj/ )/ ;/ 此外/ ,/ 记/ Suc/ (/ Mi/ )/ 为/ 由/ Mi/ 可达/ 的/ 程序/ 序/ 最小/ 的/ 0/ 号/ 任务/ 流中/ 的/ 任务/ ./ 此时/ ,/ 从/ Mi/ 到/ Mj/ 存在/ 通路/ 的/ 等价/ 条件/ 为/ Suc/ (/ Mi/ )/ / Pre/ (/ Mj/ )/ ./ 只要/ 符合/ 上述/ 3/ 个/ 条件/ 之一/ ,/ 任务/ Mi/ 和/ Mj/ 之间/ 一定/ 存在/ 通路/ ,/ 因此/ 分析/ 资源/ 冲突/ 时/ 可以/ 忽略/ 这些/ 情况/ ./ 根据/ 本文/ 模型/ 中/ 对/ 冲突/ 仲裁/ 机制/ 的/ 假设/ ,/ 加入/ 资源/ 依赖/ 的/ 过程/ 可以/ 简单/ 描述/ 为/ :/ 对于/ 给定/ 的/ 任务/ 依赖图/ G/ ,/ 如果/ 两个/ 异步/ 模式/ 的/ GPU/ 或/ 通信/ 任务/ Mi/ 和/ Mj/ 使用/ 的/ 资源/ 相同/ ,/ 即/ Type/ (/ Mi/ )/ =/ Type/ (/ Mj/ )/ ,/ 且/ Mi/ 和/ Mj/ 之间/ 不/ 存在/ 通路/ ,/ 则/ 计算/ Mi/ 和/ Mj/ 最早/ 可能/ 开始/ 执行/ 的/ 时间/ (/ EarliestStartTime/ ,/ EST/ )/ ,/ 分别/ 记为/ EST/ (/ Mi/ )/ 和/ EST/ (/ Mj/ )/ ,/ 若/ EST/ (/ Mi/ )/ =/ EST/ (/ Mj/ )/ ,/ 则/ 添加/ 一条/ 有/ 向/ 边/ ,/ 从/ 任务/ 流/ 编号/ 较/ 小/ 的/ 任务/ 指向/ 任务/ 流/ 较大/ 的/ 任务/ ,/ 表明/ 优先/ 执行/ 任务/ 流/ 编号/ 较/ 小/ 的/ 任务/ ;/ 若/ EST/ (/ Mi/ )/ ≠/ EST/ (/ Mj/ )/ ,/ 不妨/ 假设/ EST/ (/ Mi/ )/ </ EST/ (/ Mj/ )/ ,/ 则/ 添加/ 一条/ 有/ 向/ 边/ ,/ 从/ 任务/ Mi/ 指向/ 任务/ Mj/ ,/ 表示/ Mi/ 抢占/ 了/ 资源/ ,/ Mj/ 必须/ 等待/ Mi/ 完成/ 后/ 才能/ 开始/ ./ 对于/ 给定/ 的/ 任务/ 依赖图/ G/ =/ (/ V/ ,/ E/ )/ ,/ 其中/ 任务/ Mi/ 的/ 最早/ 可能/ 开始/ 执行/ 时间/ EST/ (/ Mi/ )/ 可以/ 由/ 如下/ 递推/ 公式/ 求/ 出/ :/ {/ EST/ (/ M1/ )/ =/ 0EST/ (/ Mi/ )/ =/ max/ 〈/ vj/ ,/ vi/ 〉/ ∈/ E/ {/ EST/ (/ Mj/ )/ +/ Time/ (/ Mj/ 式/ (/ 1/ )/ 中/ ,/ 要/ 计算/ EST/ (/ Mi/ )/ 必须/ 先/ 计算/ 所有/ 的/ 满足/ 〈/ vj/ ,/ vi/ 〉/ ∈/ E/ 的/ 那些/ 任务/ 的/ 最早/ 可能/ 开始/ 时间/ ,/ 换言之/ ,/ 递推/ 的/ 过程/ 必须/ 按照/ 图中/ 所有/ 结点/ 的/ 一个/ 拓扑/ 序列/ (/ topologicalsequence/ )/ 的/ 顺序/ 进行/ ./ 注意/ 到/ 算法/ 1/ 构造/ 任务/ 依赖图/ 时/ ,/ 所有/ 的/ 有/ 向/ 边/ 都/ 满足/ 目标/ 结点/ 的/ 编号/ 大于/ 源/ 结点/ 的/ 编号/ ,/ 因此/ 这里/ 对/ 结点/ 编号/ 的/ 顺序/ (/ 程序/ 序/ )/ 本身/ 就是/ 任务/ 依赖图/ 的/ 一个/ 拓扑/ 序列/ ./ 对于/ 给定/ 的/ 任务/ 依赖图/ G/ =/ (/ V/ ,/ E/ )/ ,/ 记/ M1/ ,/ M2/ ,/ …/ ,/ MP/ +/ Q/ 为/ 按程序/ 序/ 排列/ 的/ 任务/ 序列/ ,/ v/ (/ Mi/ )/ 为/ 任务/ Mi/ 在/ G/ 中/ 相应/ 的/ 结点/ ,/ 算法/ 2/ 给出/ 了/ 在/ 任务/ 依赖图/ 加入/ 资源/ 依赖/ 的/ 具体/ 过程/ ./ 算法/ 2/ ./ 加入/ 资源/ 依赖/ 到/ 任务/ 依赖图/ ./ 1/ ./ Input/ :/ G/ =/ (/ V/ ,/ E/ )/ 2/ ./ Output/ :/ G/ =/ (/ V/ ,/ E/ )/ 3/ ./ letTT/ ,/ TGbethelatesttasksonthecommunication4/ ./ TT/ ,/ TG/ ←/ / // // / meansnotaskontheresource5/ ./ E/ ←/ E6/ ./ fori/ =/ 1toP/ +/ Qdo7/ ./ CalculateEST/ (/ Mi/ )/ byEquation/ (/ 1/ )/ 8/ ./ ifQ/ (/ Mi/ )/ ≠/ 0then/ // // accordingtoproperty19/ ./ ifTType/ (/ Mi/ )/ =/ / then10/ ./ TType/ (/ Mi/ )/ ←/ Mi11/ ./ elseifQ/ (/ TType/ (/ Mi/ )/ )/ ≠/ Q/ (/ Mi/ )/ then12/ ./ ifSuc/ (/ TType/ (/ Mi/ )/ )/ / Pre/ (/ Mi/ )/ then13/ ./ ifEST/ (/ Mi/ )/ =/ EST/ (/ TType/ (/ Mi/ )/ )/ then14/ ./ letMs/ (/ Ml/ )/ bethetaskwithsmaller/ (/ larger/ )/ 15/ ./ E/ ←/ E/ ∪/ {/ 〈/ v/ (/ Ms/ )/ ,/ v/ (/ Ml/ )/ 〉/ }/ 16/ ./ EST/ (/ Ml/ )/ ←/ EST/ (/ Ms/ )/ +/ Time/ (/ Ms/ )/ 17/ ./ TType/ (/ Mi/ )/ ←/ Ml18/ ./ else19/ ./ letMs/ (/ Ml/ )/ bethetaskwithsmaller/ (/ larger/ )/ 20/ ./ E/ ←/ E/ ∪/ {/ 〈/ v/ (/ Ms/ )/ ,/ v/ (/ Ml/ )/ 〉/ }/ 21/ ./ EST/ (/ Ml/ )/ ←/ 22/ ./ TType/ (/ Mi/ )/ ←/ Ml23/ ./ endif24/ ./ else/ // // thereexistsapath25/ ./ TType/ (/ Mi/ )/ ←/ Mi26/ ./ endif27/ ./ else/ // // thereexistsapath28/ ./ TType/ (/ Mi/ )/ ←/ Mi29/ ./ endif30/ ./ endif31/ ./ endfor/ 由于/ 算法/ 2/ 中为/ 两个/ 任务/ 结点/ 添加/ 资源/ 依赖/ 相关/ 的/ 有/ 向/ 边/ 的/ 前提/ 是/ 这/ 两个/ 结点/ 间/ 不/ 存在/ 通路/ ,/ 因此/ 添加/ 有/ 向/ 边/ 之后/ 也/ 不会/ 带来/ 回路/ ,/ 即/ 添加/ 资源/ 依赖/ 关系/ 后/ 得到/ 的/ G/ 依然/ 是/ 有/ 向/ 无圈图/ ./ 至此/ ,/ 由/ 算法/ 1/ 和/ 算法/ 2/ ,/ 我们/ 可以/ 得到/ 给定/ CUDA/ 程序/ 的/ AOV/ 网/ 表示/ ./ 以图/ 3/ 中/ 所示/ 的/ 程序/ 依赖图/ 为例/ ,/ 各/ 任务/ 的/ 一/ Page7/ 个/ 拓扑/ 排序/ (/ 程序/ 序/ )/ 为/ C1/ ,/ T1/ ,/ T2/ ,/ C2/ ,/ G1/ ,/ G2/ ,/ C3/ ,/ T3/ ,/ T4/ ,/ C4/ ,/ S/ ,/ 假定/ 各/ 任务/ 执行/ 时间/ 为/ 1/ ,/ 3/ ,/ 4/ ,/ 2/ ,/ 2/ ,/ 3/ ,/ 1/ ,/ 2/ ,/ 2/ ,/ 4/ ,/ 0/ ,/ 经过/ 算法/ 2/ 处理/ 得到/ 的/ AOV/ 网如图/ 4/ 所示/ ./ 3.2/ 非关键/ 任务/ 的/ 确定/ 建立/ CUDA/ 程序/ 的/ AOV/ 网/ 表示/ 后/ ,/ 就/ 可以/ 确定/ 降频/ 后/ 不/ 影响/ 程序执行/ 总/ 时间/ 的/ 非关键/ 任务/ ./ 算法/ 2/ 在/ 得到/ CUDA/ 程序/ 的/ AOV/ 网/ 表示/ 的/ 同时/ ,/ 还/ 为/ 每个/ 任务/ Mi/ 计算/ 出/ 最早/ 可能/ 开始/ 时间/ EST/ (/ Mi/ )/ ./ 为了/ 确定/ 非关键/ 任务/ ,/ 我们/ 还/ 需要/ 计算/ 每个/ 任务/ 的/ 最晚/ 允许/ 开始/ 时间/ LST/ (/ LatestStartTime/ )/ ,/ 即/ 在/ 程序/ 的/ 总/ 执行/ 时间/ 不变/ 的/ 前提/ 下/ ,/ 每个/ 任务/ 最/ 晚/ 允许/ 开始/ 的/ 时间/ ./ 为了/ 计算/ LST/ ,/ 需要/ 对/ CUDA/ 程序/ AOV/ 网/ 重新/ 进行/ 拓扑/ 排序/ ,/ 这是/ 由于/ 算法/ 2/ 在/ 分析/ 资源/ 依赖/ 时/ ,/ 根据/ 最早/ 可能/ 开始/ 时间/ 的/ 关系/ 可能/ 加入/ 从/ 程序/ 序/ 编号/ 较大/ 指向/ 程序/ 序/ 编号/ 较/ 小/ 的/ 结点/ 的/ 有/ 向/ 边/ ,/ 因此/ 初始/ 的/ 程序/ 序/ 不/ 一定/ 仍/ 是/ AOV/ 网/ 的/ 拓扑/ 排序/ ./ 但/ 需要/ 注意/ 的/ 是/ ,/ 重新/ 构建/ 拓扑/ 排序/ 并/ 不/ 改变/ 算法/ 2/ 中/ 计算/ 的/ 各/ 任务/ 的/ 最早/ 可能/ 开始/ 时间/ ,/ 这是/ 由于/ 算法/ 2/ 在/ 添加/ 表示/ 资源/ 依赖/ 的/ 有/ 向/ 边/ 时/ ,/ 都/ 对/ 目标/ 结点/ 的/ 最早/ 可能/ 开始/ 时间/ 进行/ 了/ 更新/ (/ 第/ 16/ ,/ 21/ 行/ )/ ./ 不失/ 一般性/ ,/ 记/ G/ =/ (/ V/ ,/ E/ )/ 为/ 由/ 算法/ 2/ 构造/ 的/ AOV/ 网络/ ,/ 其/ 拓扑/ 序列/ 为/ M1/ ,/ M2/ ,/ …/ ,/ MP/ +/ Q/ ,/ 此时/ 我们/ 可以/ 按照/ 拓扑/ 序列/ 的/ 逆/ 序列/ 进行/ 如下/ 递推/ 求解/ 总/ 时间/ 不变/ 的/ 前提/ 下/ 每个/ 任务/ 的/ 最晚/ 允许/ 开始/ 时间/ {/ LST/ (/ MP/ +/ Q/ )/ =/ EST/ (/ MP/ +/ Q/ )/ LST/ (/ Mi/ )/ =/ min/ 〈/ vi/ ,/ vj/ 〉/ ∈/ E/ {/ LST/ (/ Mj/ )/ -/ Time/ (/ Mi/ 如果/ 任务/ 的/ 最早/ 可能/ 开始/ 时间/ 等于/ 其/ 最晚/ 允许/ 开始/ 时间/ ,/ 则/ 该/ 任务/ 位于/ AOV/ 网/ 的/ 关键/ 路径/ 上/ ,/ 其/ 运行/ 时间/ 直接/ 影响/ 整个/ 程序/ 的/ 运行/ 时间/ ,/ 不能/ 进行/ 放松/ ./ 因此/ 可以/ 进行/ 频率/ 调节/ 的/ 任务/ 是/ 那些/ 最早/ 可能/ 开始/ 时间/ 小于/ 最/ 晚/ 允许/ 开始/ 时间/ 的/ CPU/ 任务/ 和/ GPU/ 任务/ ./ 3.3/ 频率/ 调节/ 幅度/ 的/ 求解/ 为了/ 求解/ 能量最优/ 的/ 目标/ 下/ ,/ 每个/ 非关键/ 的/ CPU/ 任务/ 和/ GPU/ 任务/ 的/ 频率/ 调节/ 幅度/ ,/ 我们/ 还/ 需要/ 对/ AOV/ 网/ 进行/ 进一步/ 的/ 划分/ ,/ 以/ 确定/ 每个/ 非关键/ CPU/ 、/ GPU/ 任务/ 需要/ 满足/ 的/ 时间/ 约束/ ./ 我们/ 考察/ AOV/ 网中/ 的/ 必经/ 结点/ ./ 所谓/ 必经/ 结点/ 是/ 指/ 从/ AOV/ 网中/ 第一个/ 任务/ 到/ 最后/ 一个/ 任务/ 的/ 任一/ 路径/ 必然/ 经过/ 的/ 结点/ ./ 根据/ CUDA/ 程序/ 的/ 特征/ 容易/ 知道/ ,/ 在/ AOV/ 网中/ ,/ 具有/ 全局/ 同步/ 属性/ 的/ 结点/ 都/ 是/ AOV/ 网/ 的/ 必经/ 结点/ ,/ 包括/ 全局/ 同步/ 任务/ 以及/ 非/ 异步/ 模式/ 的/ GPU/ 和/ 通信/ 任务/ ./ 此外/ ,/ 如果/ 一个/ 必经/ 结点/ 的/ 出度/ 为/ 1/ ,/ 则/ 其/ 唯一/ 的/ 后继/ 结点/ 也/ 是/ 必经/ 结点/ ./ 由于/ 必经/ 结点/ 上/ 的/ 任务/ 不/ 和/ 任何/ 其它/ 任务/ 重叠/ 执行/ ,/ 因此/ 必经/ 结点/ 一定/ 在/ AOV/ 网/ 的/ 关键/ 路径/ 上/ ./ 假设/ M1/ ,/ M2/ ,/ …/ ,/ MP/ +/ Q/ 为/ G/ 的/ 一个/ 拓扑/ 序列/ ,/ G/ 中/ 包含/ k/ 个/ 必经/ 结点/ ,/ 分别/ 为/ Mc1/ =/ M1/ ,/ McMc/ 列/ ,/ 我们/ 可以/ 将/ G/ 中/ 的/ 非/ 必经/ 结点/ 划分/ 为/ k/ -/ 1/ 个/ 集合/ Si/ (/ 1/ / i/ / k/ -/ 1/ )/ ,/ 每个/ 集合/ 包含/ 拓扑/ 序列/ 中/ 连续/ 两个/ 必经/ 结点/ 之间/ 的/ 所有/ 结点/ ,/ 即/ Si/ =/ {/ Mx/ |/ Mci/ / Mx/ / Mc/ 系/ ./ 注意/ 到/ ,/ 若/ 两个/ 必经/ 结点/ 在/ 拓扑/ 序列/ 中/ 相邻/ ,/ 则/ 相应/ 的/ 非/ 必经/ 结点/ 集合/ 为/ 空集/ ./ 前面/ 提到/ ,/ 由于/ 必经/ 结点/ 上/ 的/ 任务/ 一定/ 是/ 关键/ 任务/ ,/ 因此/ 进行/ 频率/ 调节/ 的/ 目标/ 一定/ 位于/ 这里/ 构造/ 的/ 非/ 必经/ 结点/ 集合/ 中/ ./ 由于/ 我们/ 的/ 能耗/ 优化/ 问题/ 中/ 要求/ 程序/ 的/ 总/ 执行/ 时间/ 不变/ ,/ 显然/ ,/ 程序/ 的/ 总/ 执行/ 时间/ 等于/ 关键/ 路径/ 上/ 的/ 所有/ 任务/ 的/ 执行/ 时间/ 之/ 和/ ,/ 因此/ 每个/ 关键/ 任务/ 的/ 最早/ 可能/ 开始/ 时间/ 和/ 最迟/ 允许/ 开始/ 时间/ 在/ 优化/ 过程/ 中/ 都/ 是/ 常量/ ,/ 不能/ 被/ 改变/ ./ 换言之/ ,/ 对非/ 必经/ 结点/ 集合/ Si/ 中/ 的/ CPU/ 和/ GPU/ 任务/ 进行/ 降频/ 操作/ 只要/ 不/ 增大/ Mc/ 面/ ,/ 只要/ 满足/ 上述/ 条件/ ,/ 由于/ 边界/ 结点/ 时间/ 是/ 常量/ ,/ 因此/ 对/ 某/ 一个/ 非/ 必经/ 结点/ 集合/ 中/ 的/ 任务/ 进行/ 优化/ 不会/ 影响/ 其它/ 集合/ ./ 因此/ 整个/ 程序/ 的/ 能耗/ 优化/ 问题/ 可以/ 归结为/ 对/ 每个/ 非/ 必经/ 结点/ 集合/ 的/ 能耗/ 优化/ 问题/ ./ 针对/ 非/ 必经/ 结点/ 集合/ Si/ ,/ 我们/ 构造/ 一个/ AOV/ 子网/ AOVSi/ =/ {/ Mc/ 关键/ 任务/ 结点/ ,/ 并且/ 通信/ 任务/ 和/ 同步/ 任务/ 结点/ 时间/ 不可/ 变/ ,/ 因此/ 我们/ 只/ 考虑/ 对/ Si/ 中/ 的/ 非关键/ 的/ CPU/ 和/ GPU/ 任务/ 结点/ 进行/ 频率/ 调节/ ./ 假定/ AOV/ 子网/ 中有/ N/ 个/ 非关键/ 的/ CPU/ 和/ GPU/ 任务/ 结点/ ,/ 记为/ 1/ ,/ …/ ,/ MiMiN/ ,/ 进行/ 频率/ 调节/ 后/ 它们/ 的/ 频率/ 分别/ 变为/ f/ (/ Mi/ 此时/ 各/ 任务/ 的/ 执行/ 时间/ 变为/ Time/ (/ MiPage8f/ (/ Mii/ +/ 1/ 的/ 最早/ 可能/ 开始/ 时间/ ,/ 记为/ EST/ (/ McTime/ (/ MiAOV/ 子网/ 中/ ,/ 根据/ 式/ (/ 1/ )/ 我们/ 可以/ 计算/ 出/ 调节/ 频率/ 后/ Mc/ 至此/ ,/ Si/ 的/ 能量/ 最优化/ 问题/ 可以/ 归结为/ 以下/ N/ 元/ 极值/ 问题/ 其中/ ,/ kj/ 表示/ 任务/ Mi/ 数/ ,/ 即/ E/ =/ kf2/ ./ 为了/ 简化/ 式/ (/ 3/ )/ 的/ 求解/ ,/ 我们/ 还/ 可以/ 根据/ AOV/ 子网/ 中非/ 关键/ 任务/ 结点/ 的/ 连接/ 情况/ 缩减/ 极值/ 问题/ 的/ 空间/ ./ 由式/ (/ 1/ )/ 可知/ ,/ 对/ 某/ 任务/ 进行/ 频率/ 调节/ ,/ 改变/ 其/ 执行/ 时间/ 后/ ,/ 它/ 只能/ 影响/ 从/ 其/ 可达/ 的/ 结点/ 的/ 最早/ 可能/ 开始/ 时间/ ./ 因此/ 如果/ 集合/ Si/ 可以/ 划分/ 为/ 若干个/ 子集合/ ,/ 它们/ 之间/ 两/ 两/ 互相/ 不可/ 达/ ,/ 则/ 对/ 某/ 一个/ 子集合/ 进行/ 频率/ 调节/ 不会/ 影响/ 到/ 其它/ 子集合/ ,/ 它们/ 都/ 可以/ 按照/ 上述/ 方法/ 单独/ 进行/ 求解/ ,/ 因此/ 降低/ 了/ 极值/ 问题/ 的/ 求解/ 空间/ ./ 算法/ 3/ 给出/ 了/ 对/ 集合/ Si/ 进行/ 划分/ 的/ 方法/ ./ 算法/ 3/ ./ 划分/ Si/ 为/ 多个/ 相互/ 不可/ 达/ 集合/ ./ 1/ ./ Input/ :/ Si2/ ./ Output/ :/ S1i/ ,/ S2i/ ,/ …/ 3/ ./ j/ ←/ 14/ ./ whileSi/ ≠/ / do5/ ./ Sj6/ ./ letmbeanarbitrarynodeinSi/ 图/ 5/ 案例/ 分析/ 7/ ./ Sj8/ ./ repeat9/ ./ Sj10/ ./ rotatealledgesinAOVSi11/ ./ Sj12/ ./ untilSj13/ ./ returnSj14/ ./ Si/ ←/ Si/ -/ Sj15/ ./ j/ ←/ j/ +/ 116/ ./ endwhile4/ 案例/ 分析/ 由于/ 我们/ 的/ 能耗/ 优化/ 方法/ 的/ 重点/ 在于/ 归纳/ 并/ 分析/ CUDA/ 程序/ 中/ 的/ 依赖/ 关系/ ,/ 将/ 其/ 表示/ 为/ AOV/ 网络/ ,/ 而/ 将/ 最终/ AOV/ 网中/ 频率/ 的/ 求解/ 归结为/ 一个/ 规划/ 问题/ —/ —/ —/ N/ 元/ 极值/ 问题/ ./ 因此/ 从/ 理论/ 上/ 说/ ,/ 我们/ 的/ 方法/ 可以/ 给出/ 问题/ 的/ 最优/ 解/ ./ 极值/ 问题/ 的/ 数学/ 求解/ 过程/ 不是/ 本文/ 关注/ 的/ 重点/ ,/ 因此/ 本/ 节/ 通过/ 案例/ 分析/ 给出/ 我们/ 的/ 程序/ 分析方法/ 的/ 执行/ 过程/ ,/ 并/ 给出/ 模拟/ 的/ 能耗/ 优化/ 结果/ ,/ 以/ 验证/ 我们/ 优化/ 方法/ 的/ 有效性/ ./ 图/ 5/ 给出/ 了/ 一个/ 案例/ 程序/ 的/ 分析/ 过程/ ./ 其中/ 图/ (/ a/ )/ 为/ 原始/ 算法/ 流程/ ,/ 共/ 包括/ 6/ 个/ 步骤/ :/ 首先/ 是/ 对/ a/ ,/ b/ 两个/ 数组/ 的/ 初始化/ ,/ 然后/ 调用/ 过程/ f1/ 和/ f2/ 分别/ 对/ a/ 和/ b/ 进行/ 处理/ ,/ 得到/ 数组/ c/ 和/ d/ ./ 第/ 4/ 行/ 表示/ 函数/ f3/ 由/ 一个/ 标量/ α/ 计算/ 出/ 一个/ 数组/ e/ ;/ 第/ 5/ 行则/ 表示/ 函数/ f4/ 由/ a/ ,/ b/ 两个/ 数组/ 计算/ 出/ 标量/ 结果/ β/ ;/ 最后/ 一行/ Page9/ 表示/ 函数/ f5/ 由/ β/ ,/ c/ ,/ d/ 和/ e/ 计算/ 出/ 数组/ g/ ./ 图/ (/ b/ )/ 给出/ 了/ 上述/ 算法/ 的/ 一个/ CUDA/ 实现/ ./ 假设/ f1/ ,/ f2/ ,/ f3/ 和/ f5/ 函数/ 可以/ 被/ 并行/ 化/ ,/ 因此/ 使用/ Kernel/ 函数/ 实现/ ,/ 分别/ 对应/ 于/ Kernel1/ ~/ Kernel4/ ;/ f4/ 函数/ 不能/ 被/ 并行/ 化/ ,/ 因此/ 仍/ 由/ CPU/ 完成/ ./ Kernel1/ 和/ Kernel2/ 执行/ 之前/ 需要/ 调用/ cudaMemcpy/ 将/ 输入/ 数组/ a/ 和/ b/ 载入/ GPU/ 存储器/ ,/ Kernel4/ 执行/ 结束/ 后/ 需/ 将/ 数组/ g/ 回存/ 至/ CPU/ 存储器/ ./ 为了/ 开发/ Kernel/ 计算/ 和/ 通信/ 的/ 并行性/ ,/ 隐藏/ 通信/ 开销/ ,/ CUDA/ 实现/ 中将/ Kernel1/ 、/ Kernel2/ 、/ Kernel3/ 及其/ 对应/ 的/ 通信/ 操作/ 设定/ 为/ 异步/ 模式/ ,/ 而/ Kernel4/ 使用/ 到/ 了/ 前/ 3/ 个/ Kernel/ 函数/ 的/ 输出/ ,/ 因此/ 调用/ Kernel4/ 之前/ 先/ 进行/ 全局/ 的/ 任务/ 流/ 同步操作/ ./ 图/ (/ c/ )/ 给出/ 了/ 经过/ 算法/ 1/ 处理/ 后/ 得到/ 的/ 任务/ 依赖图/ ,/ 假定/ 各个/ 任务/ 的/ 执行/ 时间/ 如图/ (/ d/ )/ 中所列/ ,/ 则/ 根据/ 算法/ 2/ 处理/ 后/ ,/ 加入/ 了/ T1/ 到/ T2/ ,/ G3/ 到/ G1/ 和/ G1/ 到/ G2/ 的/ 资源/ 依赖边/ ,/ 生成/ 的/ AOV/ 网络/ 如图/ (/ e/ )/ 所示/ ./ 此时/ 利用/ 式/ (/ 1/ )/ 和/ (/ 2/ )/ 可以/ 推算出/ 各个/ 结点/ 的/ 最早/ 可能/ 开始/ 和/ 最迟/ 允许/ 开始/ 时间/ ,/ 如表/ 1/ 所示/ ./ 可以/ 看出/ ,/ 任务/ C1/ ,/ T1/ ,/ T2/ ,/ G2/ ,/ S1/ ,/ G4/ ,/ T3/ 的/ 最早/ 可能/ 开始/ 时间/ 和/ 最晚/ 允许/ 开始/ 时间/ 相等/ ,/ 它们/ 构成/ AOV/ 网/ 的/ 关键/ 路径/ ,/ 如图/ (/ f/ )/ 中/ 的/ 阴影/ 结点/ 所示/ ./ 因此/ 系统/ 中/ 可以/ 进行/ 频率/ 调节/ 的/ 非关键/ 任务/ 包括/ G1/ 、/ G3/ 和/ C2/ ./ 根据/ 3.3/ 节/ 的/ 分析/ ,/ 这/ 3/ 个/ 任务/ 可以/ 通过/ 算法/ 3/ 划分/ 为/ 互不/ 可达/ 的/ 两组/ ,/ 如图/ (/ f/ )/ 中/ 的/ 虚/ 线框/ 所示/ ,/ 可以/ 独立/ 进行/ 功耗/ 调节/ ./ C2/ 的/ 情况/ 比较简单/ ,/ 它/ 的/ 最早/ 可能/ 和/ 最晚/ 允许/ 开始/ 时间/ 分别/ 为/ 1/ 和/ 13/ ,/ 因此/ 根据/ 式/ (/ 3/ )/ 给出/ 的/ 限定/ 条件/ ,/ 为/ C2/ 调节/ CPU/ 的/ 频率/ 只要/ 不/ 影响/ S1/ 的/ 最早/ 可能/ 开始/ 时间/ 即可/ ./ 根据/ 式/ (/ 1/ )/ 可知/ C2/ 的/ 执行/ 时间/ 可以/ 延长/ 为/ 16/ ,/ 因此/ 执行/ 任务/ C2/ 时/ ,/ CPU/ 的/ 频率/ 最低/ 可降/ 至/ 原来/ 的/ 1/ // 4/ ,/ C2/ 的/ 能量消耗/ 降/ 为/ 原来/ 的/ 1/ // 16/ ./ 对于/ G1/ 和/ G3/ ,/ 同理可知/ 对/ GPU/ 的/ 频率/ 调节/ 不能/ 影响/ S1/ 的/ 最早/ 可能/ 开始/ 时间/ ./ 由于/ G1/ 和/ G3/ 的/ 初始/ 运行/ 时间/ 都/ 是/ 2/ ,/ 不妨/ 假设/ 它们/ 在/ 初始/ 频率/ 下/ 消耗/ 的/ 能量/ 都/ 为/ E/ ,/ 调节/ 后/ 运行/ 时间/ 变为/ tG1/ 和/ tG3/ ./ 根据/ 式/ (/ 1/ )/ ,/ G1/ 和/ G3/ 任务/ 能量最优/ 的/ 运行/ 时间/ 可/ 表示/ 为/ 其中/ ,/ 最小/ ,/ 为/ 8/ // 9E/ ./ 求解/ 上式/ 可得/ ,/ tG1/ =/ tG3/ =/ 3/ 时/ ,/ 两者/ 总/ 能量消耗/ 通过/ 以上/ 的/ 例子/ 说明/ ,/ 我们/ 的/ 方法/ 可以/ 直观/ 地/ 将/ CUDA/ 程序/ 的/ 能耗/ 优化/ 问题/ 转变/ 为/ 基于/ AOV/ 网/ 的/ 数学/ 规划/ 问题/ ./ 需要/ 说明/ 的/ 是/ ,/ 实际/ 中/ 很多/ 数学/ 规划/ 问题/ 是/ NP/ 问题/ ,/ 因此/ 本文/ 的/ 方法/ 可以/ 获得/ 的/ 能耗/ 优化/ 效果/ 主要/ 取决于/ 规划/ 问题/ 求解/ 的/ 精度/ ,/ 而/ 这/ 不是/ 本文/ 所/ 关注/ 的/ 主要/ 问题/ ,/ 因此/ 这里/ 不/ 做/ 详细/ 讨论/ ./ 5/ 相关/ 工作/ 本节/ 分/ 两个/ 部分/ 介绍/ 和/ 本文/ 相关/ 的/ 工作/ ./ 首先/ 是/ 异构/ 系统/ 的/ 任务调度/ 和/ 功耗/ 优化/ 研究/ ./ Mudge/ 等/ 人/ 基于/ Amdahl/ 定律/ 建立/ 了/ 传统/ 多核/ 、/ 同构/ 众核/ 和/ 异构/ 众核/ 体系结构/ 的/ 性能/ 模型/ ,/ 通过/ 分析/ 认为/ 由/ 一个/ 高性能/ 计算/ 核心/ 和/ 大量/ 结构/ 简单/ 的/ 高/ 能效/ 计算/ 核心/ 组成/ 的/ 异构/ 体系结构/ 可以/ 有效/ 提高/ 并行处理/ 能力/ ,/ 并/ 能/ 保证/ 串行/ 执行/ 效率/ [/ 7/ ]/ ./ 文献/ [/ 2/ ]/ 通过/ 建立/ 这/ 3/ 种/ 体系结构/ 的/ 功耗/ 模型/ ,/ 指出/ 相对/ 于/ 同构/ 体系结构/ ,/ 异构/ 体系结构/ 具有/ 更/ 高/ 的/ 能效/ 优势/ ./ 文献/ [/ 8/ ]/ 中/ ,/ 作者/ 面向/ 同构/ 多核/ 体系结构/ 建立/ 了/ 性能/ 与/ 能耗/ 的/ 关系/ ,/ 分析/ 了/ 在/ 给定/ 加速/ 比/ 约束/ 的/ 前提/ 下/ 调节/ 处理器/ 的/ 频率/ 以/ 达到/ 能耗/ 最优/ ./ 随着/ GPU/ 越来越/ 多/ 地被/ 应用/ 到/ 通用/ 计算/ 领域/ ,/ 面向/ CPU/ -/ GPU/ 异构/ 系统/ 的/ 任务调度/ 与/ 功耗/ 优化/ 问题/ 逐渐/ 成为/ 该/ 领域/ 的/ 研究/ 热点/ ./ Yang/ 等/ 人/ [/ 9/ ]/ 提出/ 了/ 一种/ 动态/ 的/ 异构/ 处理器/ 选择/ 方法/ ,/ 通过/ 动态/ 采样/ 程序/ 在/ 不同/ 计算/ 单元/ 上/ 的/ 执行/ 时间/ ,/ 选择/ 性能/ 较/ 高/ 的/ 处理器/ 作为/ 后续/ 执行/ 单元/ 从而/ 优化/ 程序/ 的/ 性能/ ./ 文献/ [/ 10/ ]/ 提出/ 了/ 一种/ Page10/ 多/ GPU/ 自/ 适应/ 负载平衡/ 手段/ ,/ 通过/ 在/ CPU/ 和/ GPU/ 间/ 建立/ 任务/ 队列/ 使得/ GPU/ 可以/ 根据/ 本地/ 忙/ 闲/ 状态/ 自/ 适应/ 地/ 选择/ 任务/ 执行/ ./ Hermann/ 等/ 人/ [/ 11/ ]/ 提出/ 了/ 一种/ 异构/ 系统/ 的/ 负载平衡/ 策略/ ,/ 在/ 综合/ 考虑/ 任务/ 亲和性/ 和/ 处理器/ 差异性/ 的/ 基础/ 上/ ,/ 结合/ 任务/ 划分/ 和/ 任务/ 窃取/ 指导/ CPU/ -/ GPU/ 间/ 任务调度/ ./ 文献/ [/ 12/ ]/ 通过/ 分析程序/ 行为/ ,/ 借用/ 模糊/ 逻辑/ 计算/ 程序/ 与/ 处理器/ 核/ 的/ 适应度/ ,/ 用以/ 指导/ 能量/ 感知/ 的/ 异构/ 多核/ 系统/ 的/ 程序/ 调度/ ./ 此外/ ,/ 关于/ 异构/ 系统/ 的/ 任务调度/ 的/ 研究/ 还/ 包括/ 文献/ [/ 13/ -/ 15/ ]/ ./ 上述/ 研究/ 大部分/ 关于/ 单个/ 任务/ ,/ 通常/ 是/ 循环/ 如何/ 在/ 异构/ 系统/ 上/ 进行/ 调度/ 和/ 功耗/ 优化/ ,/ 而/ 本文/ 则/ 关注/ 整个/ 程序/ 的/ 功耗/ 优化/ ,/ 这里/ 任务/ 在/ 处理器/ 上/ 的/ 分配/ 由/ 程序/ 决定/ ,/ 而/ 优化/ 整个/ 程序/ 的/ 功耗/ 则/ 需要/ 分析/ 各/ 任务/ 在/ 异构/ 的/ 处理器/ 上/ 的/ 依赖/ 关系/ ,/ 这/ 也/ 是/ 本文/ 重点/ 研究/ 的/ 内容/ ./ 其次/ 是/ 关于/ GPU/ 性能/ 和/ 功耗/ 分析/ 方面/ 的/ 研究/ ./ 精确/ 的/ 性能/ 分析模型/ 是/ 根据/ 程序/ 特征/ 进行/ 处理器/ 低功耗/ 优化/ 的/ 重要/ 基础/ ./ 文献/ [/ 6/ ]/ 从/ 程序/ 并行度/ 的/ 角度/ 出发/ ,/ 分析/ GPU/ 程序/ 中/ 计算/ 并行度/ 和/ 访存/ 并行度/ 的/ 关系/ ,/ 从而/ 确定/ 出/ 性能/ 瓶颈/ ,/ 进而/ 给出/ GPU/ 程序/ 的/ 性能/ 分析模型/ ./ 文献/ [/ 16/ ]/ 则/ 引入/ 了/ 工作/ 流图/ ,/ 作为/ GPUKernel/ 的/ 一种/ 抽象/ 表示/ ,/ 并/ 基于/ 此/ 评估/ GPUKernel/ 的/ 执行/ 时间/ ./ 文献/ [/ 17/ ]/ 则/ 提出/ 了/ 一个/ 整个/ 的/ GPU/ 性能/ 分析/ 和/ 功耗/ 分析模型/ ,/ 用于/ 预测/ 给定/ 程序/ 所/ 需要/ 的/ 最优/ 的/ GPU/ 核数/ ./ 这些/ 模型/ 都/ 可以/ 用于/ 分析/ 给定/ 程序/ 在/ GPU/ 上/ 的/ 执行/ 时间/ ,/ 因此/ 本文/ 在/ 进行/ 异构/ 系统/ 能耗/ 优化/ 时/ ,/ 假定/ GPU/ 任务/ 的/ 执行/ 时间/ 已知/ ,/ 没有/ 讨论/ 性能/ 分析/ 问题/ ./ 6/ 结论/ 异构/ 系统/ 的/ 功耗/ 优化/ 问题/ 成为/ 异构/ 体系结构/ 的/ 研究/ 热点/ ./ 本文/ 面向/ CPU/ -/ GPU/ 体系结构/ 归纳/ 总结/ 了/ CUDA/ 程序/ 中/ 包含/ 的/ 任务/ 类型/ 以及/ 任务/ 之间/ 的/ 依赖/ 关系/ ,/ 研究/ 了/ 如何/ 将/ CUDA/ 程序/ 在/ 异构/ 系统/ 上/ 的/ 执行/ 过程/ 描述/ 为/ 一种/ 抽象/ 的/ 数学/ 表示/ AOV/ 网络/ ,/ 并/ 基于/ AOV/ 网络/ 求解/ 程序/ 的/ 关键/ 路径/ ,/ 找到/ 在/ 不/ 影响/ 程序/ 总/ 执行/ 时间/ 的/ 前提/ 下/ 可以/ 进行/ DVFS/ 降频/ 优化/ 的/ 非关键/ 任务/ ,/ 进而/ 求解/ 能量最优/ 目标/ 下/ 每个/ 非关键/ 任务/ 的/ 频率/ 调节/ 幅度/ ./ 通过/ 案例/ 分析/ 可以/ 说明/ ,/ 本文/ 方法/ 可以/ 有效/ 地/ 将/ CUDA/ 程序/ 的/ 能耗/ 优化/ 问题/ 转变/ 为/ 基于/ AOV/ 网/ 的/ 数学/ 规划/ 问题/ ,/ 从而/ 给出/ 最优/ 或近/ 优/ 的/ 优化/ 策略/ ./ 

