Page1/ 面向/ 多核/ 集群/ 的/ 数据流/ 程序/ 层次/ 流水线/ 并行/ 优化/ 方法/ 于俊清/ 1/ )/ ,/ 2/ )/ 张/ 维维/ 1/ )/ 陈文斌/ 1/ )/ 涂浩/ 2/ )/ 何云峰/ 1/ )/ 1/ )/ (/ 华中科技大学/ 计算机科学/ 与/ 技术/ 学院/ 武汉/ 430074/ )/ 2/ )/ (/ 华中科技大学/ 网络/ 与/ 计算中心/ 武汉/ 430074/ )/ 摘要/ 数据流/ 编程语言/ 是/ 一种/ 面向/ 领域/ 的/ 编程语言/ ,/ 它/ 能够/ 将/ 计算/ 与/ 通信/ 分离/ ,/ 暴露/ 应用程序/ 的/ 并行性/ ./ 多核/ 集群/ 中/ 计算/ 、/ 存储/ 和/ 通信/ 等/ 底层/ 资源/ 的/ 复杂性/ 对/ 数据流/ 程序/ 的/ 性能/ 提出/ 了/ 新/ 的/ 挑战/ ./ 针对/ 数据流/ 程序/ 在/ 多/ 核/ 集群/ 上/ 执行/ 存在/ 资源/ 利用/ 低/ 和/ 扩展性/ 差/ 等/ 问题/ ,/ 利用/ 同步/ 数据流/ 图/ 作为/ 中间/ 表示/ ,/ 文中/ 提出/ 并/ 实现/ 了/ 面向/ 多核/ 集群/ 的/ 层次性/ 流水线/ 并行/ 优化/ 方法/ ./ 方法/ 包含/ 任务/ 划分/ 与/ 调度/ 、/ 层次/ 流水线/ 调度/ 和/ 数据/ 局部性/ 优化/ ,/ 经过/ 编译/ 优化/ 后/ 生成/ 基于/ MPI/ 的/ 可/ 并行执行/ 的/ 目标/ 代码/ ./ 其中/ 任务/ 划分/ 与/ 调度/ 是/ 利用/ 程序/ 中/ 数据/ 和/ 任务/ 并行性/ 将/ 任务/ 映射/ 到/ 计算/ 核上/ ,/ 实现/ 负载/ 均衡/ 和/ 低/ 通信/ 同步/ 开销/ ;/ 层次性/ 流水线/ 调度/ 是/ 利用/ 程序/ 中/ 的/ 并行性/ 构造/ 低/ 延迟/ 流水线/ 调度/ ;/ 数据/ 局部性/ 优化/ 是/ 针对/ 数据/ 访问/ 存在/ 的/ Cache/ 伪/ 共享/ 做/ 面向/ 存储/ 的/ 优化/ ./ 实验/ 以/ X86/ 架构/ 多核/ 处理器/ 组成/ 的/ 集群/ 为/ 平台/ ,/ 选取/ 媒体/ 处理/ 领域/ 的/ 典型/ 应用/ 算法/ 作为/ 测试程序/ ,/ 对/ 层次/ 流水线/ 优化/ 进行/ 实验/ 分析/ ./ 实验/ 结果表明/ 了/ 优化/ 方法/ 的/ 有效性/ ./ 关键词/ 多核/ 集群/ ;/ 数据流/ 编程/ ;/ 编译/ ;/ 流水线/ ;/ COStream1/ 引言/ 在/ 多/ 核/ 时代/ ,/ C++/ 、/ C#/ 和/ Python/ 等/ 由于/ 能够/ 大大提高/ 编程/ 效率/ 正/ 逐渐/ 取代/ 以/ C/ 和/ Fortran/ 为/ 代表/ 的/ 传统/ 的/ 编程语言/ ,/ 但/ 它们/ 主要/ 对应/ 单/ 指令流/ 和/ 传统/ 集中式/ 内存/ 管理模式/ ,/ 无法/ 很/ 好/ 地/ 适合/ 多核/ 甚至/ 分布式/ 环境/ ./ 尽管/ 当前/ 存在/ 许多/ 高层/ 的/ 并行/ 编程/ 系统/ 如/ Erlang/ ①/ 和/ X10/ ②/ 等/ ,/ 但/ 它们/ 并/ 没有/ 将/ 可编程/ 性/ 、/ 可移植性/ 和/ 可扩展性/ 很/ 好/ 地/ 集合起来/ ./ 在/ 高性能/ 计算/ 领域/ 如/ OpenMP/ ③/ 和/ MPI/ ④/ (/ MessagePassingInterface/ )/ 提供/ 了/ 显式/ 访问/ 底层/ 系统资源/ 的/ 接口/ ,/ 但/ 依然/ 要求/ 编程人员/ 必须/ 熟悉/ 系统/ 底层/ 并行/ 结构/ ./ 设计/ 并行程序/ 时/ 需要/ 根据/ 系统/ 底层/ 结构/ 进行/ 精心/ 的/ 任务/ 划分/ 、/ 数据通信/ 和/ 同步/ 设计/ ,/ 程序/ 性能/ 受制于/ 编程人员/ 对/ 并行/ 系统/ 的/ 理解/ ,/ 极大/ 地/ 增加/ 了/ 编程人员/ 的/ 负担/ ./ 为此/ ,/ 数据流/ 编程语言/ 作为/ 面向/ 领域/ 编程语言/ 被/ 提出/ 来/ ./ 与/ 面向/ 并行/ 系统/ 的/ 并行/ 编程/ 模型/ 不同/ ,/ 编程人员/ 无需/ 对/ 并行/ 系统/ 底层/ 结构/ 有/ 很/ 深入/ 的/ 了解/ ,/ 只/ 需/ 按照/ 面向/ 领域/ 应用/ 问题/ 本身/ 数据流/ 特性/ 进行/ 编程/ ./ 目前/ ,/ 支持/ 流/ 应用/ 的/ 计算/ 平台/ 主要/ 有片/ 内/ 多处理机/ Raw/ [/ 1/ ]/ 和/ Godson/ -/ T/ [/ 2/ ]/ 、/ SIMD/ 流/ 处理器/ Imagine/ [/ 3/ ]/ 和/ Merrimac/ [/ 4/ ]/ 以及/ CELL/ [/ 5/ ]/ 等/ ./ 主要/ 流/ 语言/ 有/ StreamIt/ [/ 6/ ]/ 、/ Brook/ ⑤/ 和/ Cg/ [/ 7/ ]/ 等/ ,/ 这些/ 流/ 编程语言/ 一般/ 是/ 针对/ 特定/ 系统/ 平台/ 开发/ ,/ 能够/ 充分利用/ 特定/ 平台/ 底层/ 硬件资源/ ./ 但是/ 用/ 这些/ 流/ 语言/ 编写/ 的/ 应用/ 在/ 可移植/ 、/ 可扩展性/ 以及/ 跨平台/ 使用/ 上/ 存在/ 一定/ 局限性/ ./ 当前/ 数据流/ 程序/ 编译/ 并行/ 优化/ 研究/ 的/ 硬件平台/ 一般/ 集中/ 在/ 片/ 上/ 存储/ 结构/ 的/ 多/ 核/ 处理器/ 领域/ ,/ 但/ 随着/ 各种/ 定制/ 的/ 多/ 核/ 集群/ 系统/ 逐渐/ 成为/ 并行计算/ 平台/ 的/ 主流/ ,/ 如何/ 在/ 这种/ 分布式/ 的/ 并行/ 系统/ 中使/ 数据流/ 程序/ 能够/ 高效/ 运行/ 是/ 当前/ 急需解决/ 的/ 问题/ ./ 多核/ 集群/ 系统/ 符合/ 数据流/ 编程/ 模型/ 的/ 特性/ 即/ 计算/ 和/ 通信/ 分离/ ,/ 数据流/ 编程/ 模型/ 的/ 提出/ 是/ 为了/ 暴露/ 程序/ 中/ 存在/ 的/ 并行性/ ,/ 通过/ 合理/ 使用/ 目标/ 体系结构/ 提高/ 程序执行/ 性能/ ./ 如何/ 利用/ 多核/ 集群/ 系统/ 的/ 特点/ 以及/ 数据流/ 应用程序/ 本身/ 的/ 局部性/ 和/ 并行性/ ,/ 挖掘/ 程序/ 潜在/ 的/ 并行性/ 是/ 当前/ 关心/ 的/ 问题/ ./ 结合/ 大规模/ 数据/ 计算/ 等/ 计算/ 密集型/ 应用/ ,/ 以/ 实际/ 应用/ 为/ 驱动/ ,/ 开展/ 面向/ 多核/ 集群/ 平台/ 的/ 编程语言/ 、/ 编程/ 模型/ 及/ 相关/ 编译/ 支持/ 技术/ 的/ 研究/ ,/ 具有/ 重要/ 的/ 理论/ 研究/ 和/ 实际/ 应用/ 价值/ ./ 本文/ 基于/ COStream/ [/ 8/ ]/ 数据流/ 编程语言/ 针对/ 多核/ 集群/ 系统/ ,/ 在/ 编译/ 时/ 分析/ 和/ 利用/ 程序/ 中/ 存在/ 的/ 任务/ 、/ 数据/ 和/ 流水线/ 并行性/ ,/ 提出/ 层次/ 流水线/ 并行/ 优化/ 方法/ ./ 主要/ 贡献/ 有/ 以下/ 4/ 点/ :/ (/ 1/ )/ 基于/ 多核/ 集群/ 平台/ 设计/ 并/ 实现/ 了/ 层次性/ 任务/ 划分算法/ ;/ (/ 2/ )/ 基于/ 多核/ 集群/ 平台/ 设计/ 了/ 数据流/ 程序/ 层次性/ 流水线/ 调度/ ;/ (/ 3/ )/ 基于/ 多核/ 集群/ 平台/ 实现/ 了/ 数据流/ 程序/ 层次/ 流水线/ 并行/ 优化/ 的/ 目标/ 代码生成/ 框架/ ;/ (/ 4/ )/ 在/ 多/ 核/ 集群/ 平台/ 下/ 实现/ 了/ 层次/ 流水线/ 并行/ 优化/ 框架/ ,/ 以/ 数字/ 媒体/ 领域/ 的/ 典型/ 应用/ 作为/ 测试程序/ ,/ 通过/ 实验/ 验证/ 了/ 优化/ 方法/ 的/ 有效性/ ./ 本文/ 第/ 2/ 节/ 基于/ 多核/ 集群/ 的/ 数据流/ 程序/ 层次/ 流水线/ 编译/ 优化/ 框架/ ;/ 第/ 3/ 节/ 讨论/ COStream/ 在/ 多/ 核/ 集群/ 下/ 的/ 基于/ MPI/ 的/ 代码生成/ ;/ 第/ 4/ 节/ 描述/ 在/ 多/ 核/ 集群/ 环境/ 下/ 实验/ 方法/ 和/ 结果/ ;/ 第/ 5/ 节/ 阐述/ 相关/ 工作/ ;/ 第/ 6/ 节对/ 全文/ 进行/ 总结/ ./ 2/ 数据流/ 程序/ 层次/ 流水线/ 编译/ 优化/ 2.1/ COStream/ 数据流/ 编程语言/ COStream/ [/ 8/ ]/ 是/ 一种/ 面向/ 多核/ 并行/ 体系结构/ 的/ 高性能/ 层次性/ 流/ 编程/ 模型/ ,/ 采用/ 同步/ 数据流/ 模型/ 作为/ 执行/ 模型/ ,/ 采用/ 有/ 向/ 无/ 环图/ (/ DirectedAcyclicGraph/ ,/ DAG/ )/ 描述/ 应用/ 处理过程/ ,/ 图中/ 节点/ 表示/ 计算/ ,/ 边/ 表示/ 数据/ 依赖/ ./ COStream/ 语言/ 主要/ 有/ stream/ 、/ operator/ 和/ composite/ 三个/ 语法/ 单元/ ./ 数据流/ (/ Stream/ )/ ①/ ②/ ③/ ④/ ⑤/ Page3/ 作为/ 通信/ 载体/ 连接/ 数据流/ 图中/ 的/ 计算/ 单元/ ,/ 是/ 对/ 数据流/ 图中/ 通信/ 边/ 的/ 抽象/ ;/ SDF/ 中/ 最/ 基本/ 的/ 组成/ 单元/ 是/ actor/ ,/ 在/ COStream/ 中/ 由/ operator/ 文法/ 结构/ 表示/ ,/ 专门/ 用来/ 处理/ stream/ 中/ 的/ 数据/ ;/ composite/ 相对/ 于/ operator/ 属于/ 高层次/ 复合/ 结构/ ,/ 代表/ 一个/ 由/ 一个/ 或/ 多个/ operator/ 组成/ 的/ 可/ 重用/ 的/ 子/ 数据流/ 图/ 结构/ ,/ 是/ 对/ SDF/ 图中/ 可/ 复用/ 子图/ 的/ 抽象/ ./ 2.2/ 层次/ 流水线/ 编译/ 优化/ 框架/ 多核/ 集群/ 系统/ 在/ 并行性/ 上/ 至少/ 存在/ 节点/ 内核/ 间/ 并行性/ 和/ 节点/ 间/ 并行性/ ,/ 在/ 局部性/ (/ Locality/ )/ 上/ 至少/ 存在/ 处理器/ 高速缓存/ (/ Cache/ )/ 上/ 的/ 局部性/ 和/ 单/ 节点/ 主存/ (/ Memory/ )/ 上/ 的/ 局部性/ ./ 数据流/ 程序/ 在/ 多/ 核/ 集群/ 下/ 的/ 执行/ 要/ 充分利用/ 系统/ 的/ 多级/ 并行性/ ,/ 保证/ 程序/ 在/ 执行/ 过程/ 中有/ 良好/ 的/ 数据/ 局部性/ ./ 层次/ 流水线/ 并行/ 优化/ 是/ 为了/ 构造/ 低/ 延迟/ 高/ 吞吐量/ 的/ 流水线/ 调度/ ,/ 主要/ 从/ 计算/ 负载/ 、/ 网络通信/ 和/ 存储/ 局部性/ 等/ 方面/ 考虑/ 优化/ 策略/ ./ 图/ 1/ 所示/ 为/ 层次/ 流水线/ 编译/ 优化/ 框图/ ,/ 输入/ 为/ 数据流/ 编程语言/ 编写/ 的/ 数据流/ 程序/ ,/ 输出/ 为/ 多/ 核/ 集群/ 上/ 可/ 并行执行/ 的/ 目标/ 代码/ ./ 数据流/ 程序/ 经过/ 编译/ 前端/ 处理/ 后/ 生成/ SDF/ 图/ 作为/ 中间/ 表示/ ,/ 然后/ 进行/ 层次/ 流水线/ 并行/ 优化/ ,/ 层次/ 流水线/ 并行/ 优化/ 的/ 具体步骤/ 如下/ :/ (/ 1/ )/ 任务/ 划分/ 与/ 调度/ ./ 该/ 阶段/ 要/ 确定/ SDF/ 中/ actor/ 被/ 调度/ 到/ 集群/ 的/ 哪个/ 节点/ 的/ 哪个/ 计算/ 核上/ ./ 该/ 阶段/ 分成/ 两个/ 步骤/ :/ 首先/ 是/ 进程/ 级任务/ 划分/ ,/ 该/ 步骤/ 要/ 综合/ 考虑/ 集群/ 节点/ 上/ 的/ 负载/ 均衡/ 和/ 节点/ 间/ 的/ 通信/ 情况/ 使/ 延迟/ 最小化/ ,/ 完成/ actor/ 与/ 节点/ 间/ 的/ 映射/ ;/ 其次/ ,/ 对于/ 各个/ 进程/ 内部/ 做/ 线程/ 级任务/ 划分/ ,/ 完成/ actor/ 与/ 核/ 之间/ 的/ 映射/ ,/ 由于/ 针对/ 的/ 多/ 核/ 集群/ 的/ 单/ 节点/ 是/ 共享/ 存储/ 架构/ 的/ ,/ 在/ 该/ 架构/ 下/ 核间/ 的/ 通信/ 对/ 程序执行/ 的/ 效率/ 的/ 影响/ 相对/ 较/ 小/ ,/ 该/ 步骤/ 主要/ 考虑/ 核间/ 计算/ 的/ 负载/ 均衡/ ./ (/ 2/ )/ 层次性/ 流水线/ 构造/ ./ 流水线/ 一般/ 分/ 同步/ 流水线/ 和/ 异步/ 流水线/ 两种/ 方式/ ,/ 流水线/ 是/ 开发/ 数据流/ 程序/ 并行性/ 的/ 一种/ 有效/ 方法/ ./ 将/ 数据流/ 程序/ 看作/ 一个/ 迭代/ 循环/ ,/ 同步/ 流水线/ 能够/ 实现/ 不同/ 迭代/ 中/ 的/ actor/ 的/ 并行执行/ ,/ 但/ 性能/ 会/ 被/ 计算/ 单元/ 间通信/ 和/ 同步/ 开销/ 所/ 影响/ ;/ 相反/ ,/ 异步/ 流水线/ 将/ 计算/ 单元/ 的/ 计算/ 与/ 通信/ 分离/ ,/ 通过/ 非/ 阻塞/ 通信/ 能够/ 将/ 计算/ 与/ 通信/ 重叠/ 提升/ 程序执行/ 效率/ ./ 结合/ 同步/ 与/ 异步/ 流水线/ 的/ 特点/ ,/ 在/ 多/ 核/ 集群/ 中/ 节点/ 内部/ 采用/ 同步/ 流水线/ ,/ 节点/ 间/ 采用/ 异步/ 流水线/ 调度/ 方式/ ./ (/ 3/ )/ 数据/ 局部性/ 优化/ ./ 该/ 阶段/ 主要/ 针对/ 多核/ 集群/ 系统/ 做/ 局部性/ 优化/ ,/ 局部性/ 主要/ 包括/ 时间/ 局部性/ (/ TemporalLocality/ )/ 和/ 空间/ 局部性/ (/ SpatialLocality/ )/ ./ 根据/ 数据流/ 程序/ 在/ 多/ 核/ 处理器/ 上/ 的/ 执行/ 情况/ 基于/ Cache/ 做/ 数据/ 局部性/ 优化/ ./ 2.3/ 数据流/ 程序/ 层次性/ 任务/ 划分/ 对/ 集群/ 下/ 不同/ 层次/ 的/ 任务/ 划分/ 描述/ 如下/ :/ 进程/ 级任务/ 划分/ 要求/ 保证/ 在/ 节点/ 间/ 负载/ 均衡/ 的/ 前提/ 下/ 最小化/ 节点/ 间通信/ 开销/ ,/ 划分/ 结果/ 间/ 不/ 出现/ 环路/ ;/ 线程/ 级任务/ 划分/ 则/ 要求/ 保证/ 节点/ 间/ 负载/ 均衡/ 的/ 前提/ 下/ 最小化/ 同步/ 开销/ ,/ 且/ 尽可能/ 保证数据/ 局部性/ ./ 介绍/ 具体/ 划分算法/ 之前/ 先对/ SDF/ 图/ 进行/ 形式化/ 描述/ ./ SDF/ 图/ G/ =/ (/ V/ ,/ E/ )/ 中/ 的/ V/ 代表/ 数据流/ 程序/ 中/ 的/ operators/ 即/ SDF/ 图中/ 的/ actor/ ,/ |/ V/ |/ 表示/ 图/ G/ 中/ 顶点/ 的/ 个数/ ;/ E/ 代表/ operator/ 间/ 的/ 通信/ 通道/ 即/ SDF/ 图中/ 的/ 边/ ,/ 每/ 一个/ 通信/ 边/ 连接/ 一个/ 生产者/ actor/ 和/ 消费者/ actor/ ,/ 图/ G/ (/ V/ ,/ E/ )/ 是/ 一个/ 有/ 向/ 无/ 环图/ ,/ E/ =/ {/ (/ vi/ ,/ vj/ )/ |/ vi/ ,/ vj/ ∈/ V/ ,/ 且/ vi/ ,/ vj/ 邻接/ }/ ./ Group/ 划分/ 策略/ 是/ 针对/ 进程/ 级/ 划分/ 提出/ 的/ ,/ 线程/ 级/ 划分/ 主要/ 采用/ 复制/ 分裂/ 算法/ ./ 复制/ 分裂/ 算法/ 在/ 文献/ [/ 9/ ]/ 中有/ 详细描述/ ,/ 本/ 节/ 主要/ 针对/ 数据流/ 图/ 的/ 进程/ 级任务/ 划分/ 介绍/ Group/ 任务/ 划分算法/ ./ Group/ 任务/ 划分/ 引入/ group/ 结构/ ,/ group/ 表示/ 由/ SDF/ 图中/ 一个/ 或/ 多个/ actor/ 组成/ 的/ 集合/ ,/ 是/ V/ 的/ 子集/ ./ 初始/ 时/ 将/ SDF/ 图/ 的/ 每/ 一个/ actor/ 作为/ 一个/ group/ 对待/ ,/ group/ 间/ 依赖/ 关系/ 与/ actor/ 间/ 的/ 是/ 一致/ 的/ ./ 用/ G/ (/ GV/ ,/ C/ )/ 表示/ group/ 间/ 的/ 依赖/ 关系/ ,/ |/ GV/ |/ 表示/ group/ 图/ 的/ group/ 数目/ ,/ C/ 表示/ group/ 间通信/ 通道/ ./ Group/ 任务/ 划分/ 主要/ 有/ 4/ 个/ 步骤/ 组成/ 即/ 对/ SDF/ 图/ 预处理/ 构建/ 初始/ group/ 图/ 、/ group/ 的/ 粗粒度/ 、/ 对/ 粗化/ 后/ group/ 依赖图/ 进行/ 初始/ 划分/ 以及/ 对/ 初始化/ 分/ 结果/ 进行/ 细粒度/ Page4/ 调整/ ./ Group/ 划分/ 主要/ 报告/ 如下/ 4/ 个/ 阶段/ :/ (/ 1/ )/ 预处理/ 阶段/ 预处理/ 针对/ COStream/ 程序/ 中/ operator/ 多/ 输入/ 多/ 输出/ 而/ 设计/ ./ 单个/ operator/ 有/ 多个/ 输入输出/ 边时/ ,/ 执行/ 期间/ 会/ 出现/ 在/ 同一时间/ 要/ 与/ 集群/ 中/ 其他/ 多个/ 节点/ 进行/ 通信/ 的/ 情况/ ,/ 将/ 增大/ 该/ operator/ 所在/ 线程/ 的/ 通信/ 延迟/ ./ 预处理/ 将/ 多个/ group/ 融合/ 成/ 一个/ ,/ 降低/ 了/ group/ 内/ 单个/ actor/ 与/ 其他/ group/ 中/ actor/ 通信/ 边/ 的/ 数目/ ./ 预处理/ 过程/ 的/ 输入/ 是/ 经过/ 周期性/ 调度/ 的/ SDF/ 图/ 和/ 预处理/ 后/ 得到/ 的/ group/ 图中/ 最少/ 应该/ 有/ 的/ group/ 的/ 数目/ virtualGroupNum/ ./ virtualGroupNum/ 是/ 为/ 图/ 2SDF/ 图/ 预处理/ 的/ 示例/ (/ 2/ )/ Group/ 粗粒度/ 阶段/ Group/ 粗粒度/ 是/ 对/ 预处理/ 后/ 的/ group/ 图/ 进行/ 粗化/ 处理/ ,/ 将/ 多个/ 相邻/ 的/ group/ 融合/ 成/ 一个/ ,/ 在/ 这个/ 过程/ 中要/ 综合/ 考虑/ group/ 的/ 负载/ 以及/ 将/ 相邻/ 一对/ group/ 融合/ 时/ 对于/ 降低/ 通信/ 开销/ 产生/ 的/ 收益/ ./ 为了/ 避免/ 在/ 最终/ 划分/ 结果/ 中/ 出现/ 环/ ,/ 在/ 粗粒度/ 时要/ 避免/ group/ 图中/ 出现/ 环路/ ./ 一对/ group/ 融合/ 产生/ 的/ 收益/ 称为/ 粗化/ 收益/ ,/ 计算公式/ 如式/ (/ 1/ )/ 所示/ :/ gain/ =/ comm/ (/ SrcGroup/ ,/ SnkGroup/ )/ 其中/ ,/ workload/ (/ srcGroup/ )/ 与/ workload/ (/ snkGroup/ )/ 表示/ srcGroup/ 和/ snkGroup/ 各自/ 的/ 负载/ ,/ comm/ (/ srcGroup/ ,/ snkGroup/ )/ 表示/ srcGroup/ 与/ snkGroup/ 之间/ 的/ 通信/ 开销/ ,/ 通信/ 开销/ 包括/ 数据/ 发送/ 和/ 数据/ 接/ 了/ 防止/ 过度/ 融合/ ,/ 对/ group/ 数量/ 设置/ 的/ 阈值/ ./ 图/ 2/ 描述/ 了/ 对/ 一个/ SDF/ 图/ 预处理/ 的/ 示例/ ./ 图/ 2/ (/ b/ )/ 中/ 的/ B/ 和/ K/ 与其/ 上端/ 或/ 下端/ 节点/ 融合/ 后/ 得到/ 的/ 新/ 的/ group/ 与/ 其他/ group/ 中/ actor/ 通信/ 边/ 的/ 数目/ 明显/ 减少/ ,/ O/ 没有/ 与/ L/ 和/ P/ 组合/ 在/ 一起/ 的/ 原因/ 是/ 融合/ 前后/ 通信/ 边/ 数目/ 没有/ 变化/ ./ 图/ 2/ (/ a/ )/ 表示/ 最初/ 的/ SDF/ 图/ ,/ 图/ (/ b/ )/ 描述/ 了/ 预处理/ 的/ 过程/ ,/ 其中/ 被/ 虚/ 线圈/ 在/ 一起/ 的/ 表示/ 在/ 预处理/ 阶段/ 可以/ 被/ 融合/ ,/ 图/ (/ c/ )/ 描述/ 了/ 经过/ 预处理/ 后/ 形成/ 的/ group/ 图/ ,/ 通过/ 比较/ 发现/ 图/ (/ c/ )/ 的/ 通信/ 边/ 数目/ 明显/ 少于/ 图/ (/ a/ )/ ,/ 且/ 图/ (/ c/ )/ 的/ 结构/ 也/ 相对/ 较为简单/ ./ 收/ 两个/ 方面/ ,/ 通过/ 该/ 公式/ 刻画/ 了/ 单位/ 通信量/ 减少/ 获得/ 的/ 计算/ 负载/ 收益/ ./ 粗粒度/ 阶段/ 采用/ 贪心/ 思想/ ,/ 首先/ 计算/ 所有/ 相邻/ group/ 的/ 粗化/ 收益/ 将/ 结果/ 保存/ 在/ 一个/ 优先/ 队列/ 中/ ,/ 从/ 优先/ 队列/ 中/ 选择/ 收益/ 最大/ 的/ 一对/ group/ 做/ 融合/ ,/ 如果/ 融合/ 后/ 形成/ 的/ 新/ 的/ group/ 的/ 负载/ 不/ 大于/ 划分/ 后/ 负载/ 理论/ 平均值/ 且/ 融合/ 后/ group/ 图中/ 不会/ 出现/ 环路/ ,/ 那么/ 该次/ 融合/ 是/ 有效/ 的/ ,/ 将/ 经过/ 有效/ 融合/ 掉/ 的/ group/ 从/ group/ 图中/ 删除/ ,/ 融合/ 得到/ 的/ 新/ 的/ group/ 插入/ 到/ 图/ 中/ 更新/ group/ 间/ 依赖/ 关系/ ,/ 根据/ 新/ 的/ group/ 更新/ 优先/ 队列/ 中/ 的/ 收益/ ,/ 反复/ 迭代/ 上述/ 过程/ ./ 算法/ 的/ 终止/ 条件/ 是/ 任何/ 一对/ group/ 间/ 融合/ 都/ 不会/ 产生/ 正/ 收益/ 或者/ group/ 图中/ group/ 的/ 数目/ 小于/ 阈值/ ./ 算法/ 1/ 描述/ 了/ Group/ 划分/ 粗粒度/ 算法/ ./ 图/ 3/ (/ a/ )/ 所示/ 描述/ 了/ 图/ 2/ 预处理/ 过后/ group/ 图/ 粗粒度/ 的/ 结果/ ./ Page5/ 算法/ 1/ ./ Group/ 任务/ 划分/ 粗粒度/ 算法/ ./ 输入/ :/ 经过/ 初始化/ 过后/ group/ 间/ 的/ 依赖图/ G/ :/ (/ GV/ ,/ C/ )/ ,/ 输出/ :/ 经过/ 粗化/ 后/ group/ 间/ 的/ 依赖图/ G/ :/ (/ GV/ ,/ C/ )/ // // 计算/ 理论/ 平均/ 最佳/ 负载/ averageWorkload/ =/ Weight/ (/ groupGraph/ )/ // groupCount/ =/ Count/ (/ groupGraph/ )/ ;/ // // 构造/ 以/ 收益/ 为/ 权值/ 的/ 优先/ 队列/ priorityQueue/ =/ ConstructPriorityQueue/ (/ groupGraph/ )/ ;/ WHILE/ (/ groupCount/ >/ virtualGroupNum/ )/ {/ maxGain/ =/ GetMaxGein/ (/ priorityQueue/ )/ ;/ IF/ (/ maxGain/ </ =/ 0/ )/ break/ ;/ pair/ 〈/ srcGroup/ ,/ snkGroup/ 〉/ maxGainChannel/ =/ IF/ (/ !/ Isfused/ (/ srcGroup/ ,/ snkGroup/ )/ ‖/ Weight/ (/ srcGroup/ )/ +/ priorityQueue/ ./ delete/ (/ maxGainChannel/ )/ ;/ newGroup/ =/ Fused/ (/ srcGroup/ ,/ snkGroup/ )/ ;/ G/ ./ update/ (/ srcGroup/ ,/ snkGroup/ ,/ newGroup/ )/ ;/ priorityQueue/ ./ update/ (/ maxGainChannel/ ,/ newGroup/ )/ ;/ -/ -/ groupCount/ ;/ }/ // // ENDWHILE/ 图/ 3/ 图/ 2/ 对应/ 的/ group/ 图/ 粗化/ 和/ 初始/ 划分/ 的/ 结果/ (/ 3/ )/ 初始/ 划分/ 阶段/ 初始化/ 分/ 初步/ 决定/ 粗化/ 后/ group/ 图中/ group/ 与/ 集群/ 节点/ 之间/ 的/ 映射/ ./ 经过/ 预处理/ 和/ 粗粒度/ 后/ group/ 图/ 的/ 规模/ 已经/ 大幅度降低/ ,/ group/ 间通信/ 边/ 数量/ 也/ 相对/ 较少/ ./ 初始/ 划分/ 是/ 使得/ 各个/ 划分/ 负载/ 均衡/ 且/ 尽可能/ 保证/ 划分/ 间通信/ 最小/ ./ 在/ 初始/ 划分/ 过程/ 中/ 同样/ 要/ 避免/ group/ 间/ 出现/ 通信/ 环路/ ,/ 初始/ 划分/ 采用/ 预防/ 死锁/ 的/ 策略/ ,/ 在/ 划分/ 开始/ 就/ 避免/ 在/ 划分/ 结果/ 中/ 出现/ 环路/ ./ 粗粒度/ 后/ group/ 图是/ 一个/ DAG/ 图/ ,/ 对于/ DAG/ 图/ 拓扑/ 排序/ 能够/ 利用/ 图中/ 节点/ 间/ 的/ 偏序/ 关系/ 得/ 一个/ 拓扑/ 序列/ ./ 初始/ 划分/ 时/ 根据/ group/ 拓扑/ 序列/ 逐个/ 考察/ group/ 图中/ group/ 节点/ ,/ 确定/ 每个/ group/ 具体/ 的/ 划分/ 编号/ ./ 算法/ 2/ 描述/ 了/ 初始/ 划分算法/ ./ 图/ 3/ (/ b/ )/ 图/ 描述/ 了/ 图/ 3/ (/ a/ )/ 在/ 集群/ 节点/ 数目/ 为/ 3/ 的/ 情况/ 下/ 的/ 各个/ group/ 对应/ 的/ 划分/ 编号/ ,/ 初始化/ 分/ 完成/ 后/ 就/ 基本/ 确定/ 了/ actor/ 与/ 集群/ 节点/ 之间/ 的/ 映射/ ./ 算法/ 2/ ./ Group/ 任务/ 划分/ 初始/ 划分算法/ ./ 输入/ :/ 经过/ 粗化/ 过后/ group/ 间/ 的/ 依赖图/ G/ :/ (/ GV/ ,/ C/ )/ ,/ 输出/ :/ 经过/ 初始/ 划分/ 后/ group/ 间/ 的/ 依赖图/ G/ :/ (/ GV/ ,/ C/ )/ averageWorkload/ =/ Weight/ (/ groupGraph/ )/ // groupTopoLogicSort/ [/ ]/ =/ intcurPartitionNo/ =/ 0/ ;/ // // 当前/ 的/ 划分/ 编号/ WHILE/ (/ 依次/ 遍历/ groupTopoLogicSort/ 中/ 的/ group/ )/ {/ curPartitionWorkload/ =/ Weight/ (/ group/ )/ +/ IF/ (/ Weight/ (/ curPartitionNo/ )/ </ averageWorkload/ / }/ // // ENDIFELSEIF/ (/ curPartitionWorkload/ </ averageWorkload/ / // // 根据/ group/ 间/ 的/ 通信/ 情况/ 确定/ 该/ group/ 是否/ 能够/ localCommData/ =/ GetCommData/ (/ curPartitionNo/ ,/ groupCommData/ =/ GetCommData/ (/ group/ )/ ;/ groupChannelCount/ =/ GetChannelCount/ (/ group/ )/ ;/ IF/ (/ localCommData/ >/ groupCommData/ // }/ // // ENDELSE/ -/ IFELSE/ }/ // // ENDWHILE/ 根据/ initPartitionMap/ 融合/ 在/ 同一个/ 划分/ 中/ 的/ group/ ,/ 并/ 更新/ groupGraph/ (/ 4/ )/ 细粒度/ 调整/ 阶段/ 初始/ 划分/ 基本/ 确定/ 了/ group/ 内/ 的/ actor/ 与/ 集群/ Page6/ 节点/ 之间/ 的/ 映射/ ,/ 细粒度/ 调整/ 是/ 将/ 划分/ 的/ 边界/ actor/ ,/ 即/ 与/ 其他/ 集群/ 节点/ 上/ 的/ actor/ 存在/ 通信/ 的/ actor/ ,/ 根据/ 通信/ 情况/ 做/ 进一步/ 调优/ ,/ 降低/ 节点/ 通信/ 开销/ ./ 细粒度/ 调整/ 是/ 以/ 边界/ actor/ 作为/ 调整/ 对象/ ,/ 对/ 一个/ 边界/ actor/ 而言/ ,/ 该/ actor/ 所在/ 的/ 划分/ 集合/ 称为/ 源/ 划分/ (/ srcPartition/ )/ ,/ 与/ 该/ actor/ 有/ 依赖/ 关系/ 的/ actor/ 所在/ 的/ 划分/ 成为/ 目标/ 划分/ (/ objPartition/ )/ ,/ 一个/ actor/ 只有/ 一个/ srcPartition/ ,/ 而/ 可能/ 存在/ 多个/ objPartition/ ,/ actor/ 与/ srcPartition/ 中/ 的/ 其他/ actor/ 的/ 通信量/ 为/ internalData/ ,/ actor/ 与/ 第/ i/ 个/ objPartition/ 中/ 的/ actor/ 的/ 通信量/ 为/ externalData/ [/ i/ ]/ ,/ 在/ 细粒度/ 调整/ 时/ 维护/ 一个/ 优先/ 队列/ ,/ 其权值/ 是/ externalData/ [/ i/ ]/ —/ internalData/ ./ 在/ 调整/ 过程/ 中/ 选择权/ 值/ 最大/ 的/ 进行/ 处理/ ,/ 一个/ actor/ 能否/ 被/ 移动/ 到/ 一个/ objPartition/ 要/ 从/ 如下/ 两个/ 因素/ 考虑/ :/ 首先/ ,/ 不会/ 在/ 划分/ 中/ 引入/ 环路/ ;/ 其次/ ,/ 不会/ 破坏/ 整个/ 划分/ 间/ 的/ 负载/ 均衡/ ./ 一个/ actor/ 调整/ 完/ 过后/ 要/ 根据/ 调整/ 过后/ 的/ 结果/ 更新/ 优先/ 队列/ ,/ 对于/ 调整/ 过/ 的/ actor/ 不会/ 再/ 被/ 作为/ 调整/ 对象/ ./ 图/ 4/ 描述/ 了/ 细粒度/ 调整/ 的/ 结果/ ,/ 其中/ (/ a/ )/ 图是/ 完成/ 任务/ 划分/ 过后/ 的/ SDF/ 图/ ,/ (/ b/ )/ 图是/ 对/ J/ 节点/ 进行/ 了/ 调整/ ,/ 从/ 划分/ Ⅰ/ 移动/ 到/ Ⅱ/ 后/ 的/ 结果/ ./ 2.4/ 数据流/ 程序/ 层次性/ 流水线/ 调度/ 多核/ 集群/ 环境/ 下/ ,/ 进程/ 级/ 划分/ 在/ 将子/ 任务/ 分图/ 5/ 数据流/ 程序/ 在/ 集群/ 上/ 异步/ 流水线/ 执行/ 示意图/ 图/ 5/ 描述/ 了/ 多/ 核/ 集群/ 环境/ 下/ 数据流/ 程序/ 异步/ 流水线/ 执行/ ./ 图/ 中共/ 有/ 3/ 台多核/ 机器/ 分别/ 对应/ 编译器/ 经过/ 进程/ 级任务/ 划分/ 将/ 数据流/ 程序/ 分为/ 3/ 个子/ 任务/ Ⅰ/ 、/ Ⅱ/ 和/ Ⅲ/ ./ 机器/ 内/ actor/ 的/ 执行/ 与/ 机器/ 内部/ 并行/ 架构/ 和/ 调度/ 方式/ 有关/ ,/ 在/ 共享/ 存储/ 多核/ 平台/ 上/ 节点/ 内部/ 采用/ 同步/ 流水线/ 调度/ ./ 节点/ 间/ 异步/ 流水线/ 为了/ 摊销/ 单位/ 数据量/ 在/ 传输/ 中/ 的/ 开销/ ,/ 数据流/ 程序/ 在/ 节点/ 图/ 4/ 图/ 2/ 对应/ 的/ SDF/ 图/ 初始/ 划分/ 和/ 细粒度/ 调整/ 的/ 结果/ 配/ 到/ 节点/ 上/ 的/ 同时/ 也/ 确定/ 了/ 子/ 任务/ 间/ 的/ 依赖/ 关系/ ./ 异步/ 流水线/ 调度/ 没有/ 全局/ 同步/ 时钟/ ,/ 子/ 任务/ 执行/ 满足/ 数据/ 驱动/ 的/ 特性/ ,/ 子/ 任务/ 间/ 的/ 执行/ 符合/ 生产者/ 消费者/ 模式/ ./ 图/ 5/ 描述/ 了/ 图/ 2/ (/ a/ )/ 对应/ 的/ 数据流/ 程序/ 在/ 由/ 3/ 台/ 机器/ 组成/ 的/ 集群/ 上/ 的/ 执行/ 示意图/ ,/ 图中/ 只/ 为/ 说明/ 数据流/ 程序/ 在/ 节点/ 间/ 的/ 流水线/ 执行/ 情况/ ,/ 暂/ 不/ 考虑/ 具体任务/ 在/ 节点/ 内/ 计算/ 核上/ 的/ 执行/ ./ 间/ 采用/ 块/ 通信/ 方式/ ,/ 生产者/ 将/ 通信/ 块/ 填满/ 时/ 触发/ 消息传递/ 机制/ ,/ 消费者/ 在/ 收到/ 消息/ 后/ 开始/ 执行/ ./ 以图/ 5/ 中/ 的/ Ⅰ/ 和/ Ⅱ/ 为例/ ,/ 当/ actorC/ 执行/ 一段时间/ 后/ actorC/ 和/ actorF/ 间/ 的/ 通信/ 缓冲区/ 被/ 填满/ C/ 发送数据/ 到/ F/ ,/ F/ 收到/ C/ 产生/ 的/ 数据/ 后/ F/ 开始/ 执行/ ,/ 同时/ C/ 可以/ 继续执行/ 生成/ 新/ 的/ 数据/ ./ 通过/ 异步/ 流水线/ 执行/ 方式/ 保证/ 数据流/ 程序/ 在/ 集群/ 上/ 的/ 执行/ ./ Page7/ 多核/ 集群/ 平台/ 下/ 同步/ 流水线/ 主要/ 针对/ 节点/ 内部/ 多/ 核间/ ,/ 同步/ 流水线/ 没有/ 像/ 异步/ 流水线/ 一样/ 采用/ 数据/ 驱动/ 的/ 方式/ 执行/ ,/ 为了/ 保证/ 数据流/ 程序/ 的/ 正确/ 执行/ ,/ 节点/ 内/ actor/ 的/ 执行/ 顺序/ 需要/ 预先确定/ ./ 线程/ 级/ 划分/ 确定/ 了/ actor/ 与/ 核间/ 的/ 映射/ ,/ 同步/ 流水线/ 从/ 时间/ 上/ 确定/ actor/ 执行/ 顺序/ ./ 在/ 同步/ 流水线/ 调度/ 中/ ,/ 流水线/ 的/ 启动/ 间隔/ (/ InitiationInterval/ ,/ II/ )/ 是/ 指/ 相邻/ 两次/ 循环/ 迭代/ 进入/ 流水线/ 的/ 时间/ 间隔/ ,/ II/ 越小/ 意味着/ 吞吐/ 率越/ 大/ ./ 线程/ 级任务/ 划分/ 以/ 负载/ 均衡/ 为/ 目标/ 就是/ 最小化/ II/ ./ 在/ 软件/ 流水线/ 调度/ 中/ 通过/ 阶段/ 赋值/ 算法/ 确定/ 哪个/ actor/ 被/ 分配/ 到/ 流水线/ 的/ 哪个/ 执行/ 阶段/ ./ 为了/ 维护/ SDF/ 中/ 计算/ 节点/ 数据/ 依赖/ 的/ 正确性/ ,/ 对于/ 当前/ 多核/ 机器/ 内部/ 的/ actorv/ 和/ actoru/ ,/ 存在/ 有/ 向/ 边/ (/ u/ ,/ v/ )/ ,/ 则/ v/ 的/ 阶段/ 值/ 不/ 小于/ u/ 的/ 阶段/ 值/ ./ 算法/ 3/ 描述/ 了/ 根据/ 线程/ 级/ 划分/ 结果/ 利用/ 阶段/ 赋值/ 算法/ 构造/ 同步/ 流水线/ 调度/ 的/ 过程/ ./ 对/ 一台/ 机器/ 中/ 的/ 每个/ actor/ ,/ 如果/ 其父/ actor/ 在/ 另/ 一个/ 机器/ 上/ ,/ 该父/ actor/ 的/ 执行/ 阶段/ 不会/ 影响/ 当前/ 机器/ 中/ 的/ actor/ ;/ 如果/ 其父/ actor/ 与/ 当前/ actor/ 在/ 同一/ 台/ 机器/ 上/ 并且/ 在/ 同一个/ 计算/ 核上/ ,/ 那么/ 父/ actor/ 与子/ actor/ 能够/ 被/ 分配/ 在/ 同一个/ 执行/ 阶段/ ;/ 如果/ 父/ actor/ 与子/ actor/ 在/ 同一/ 台/ 机器/ 上/ 但/ 不/ 在/ 同一个/ 计算/ 核上/ ,/ 结合/ actor/ 间/ 数据/ 依赖/ 关系/ ,/ 子/ actor/ 的/ 阶段/ 号会/ 比父/ actor/ 的/ 阶段/ 号/ 大/ 1/ ./ 算法/ 3/ ./ 层次性/ 流水线/ 调度/ 节点/ 内/ 阶段/ 赋值/ 算法/ ./ 输入/ :/ 一个/ 节点/ 内部/ actor/ 与/ 核/ 之间/ 的/ 映射/ 输出/ :/ actor/ 与/ 执行/ 阶段/ 号/ 之间/ 的/ 映射/ actorTopoSort/ =/ TopoSort/ (/ actorCoreMap/ )/ ;/ WHILE/ (/ 依次/ 遍历/ actorTopoSort/ 中/ 的/ actor/ )/ {/ intactorMaxStage/ =/ 0/ ;/ intactorStage/ =/ 0/ ;/ parentActors/ =/ actor/ ./ GetParentActor/ (/ )/ ;/ WHILE/ (/ 依次/ 遍历/ parentActors/ 中/ 的/ parentActor/ )/ {/ }/ // // ENDWHILE/ 算法/ 3/ 描述/ 了/ 根据/ 线程/ 级/ 划分/ 结果/ 利用/ 阶段/ 赋值/ 算法/ 构造/ 同步/ 流水线/ 调度/ 的/ 过程/ ./ 对/ 一台/ 机器/ 中/ 的/ 每个/ actor/ ,/ 如果/ 其父/ actor/ 在/ 另/ 一个/ 机器/ 上/ ,/ 该父/ actor/ 的/ 执行/ 阶段/ 不会/ 影响/ 当前/ 机器/ 中/ 的/ actor/ ;/ 如果/ 其父/ actor/ 与/ 当前/ actor/ 在/ 同一/ 台/ 机器/ 上/ 并且/ 在/ 同一个/ 计算/ 核上/ ,/ 那么/ 父/ actor/ 与子/ actor/ 能够/ 被/ 分配/ 在/ 同一个/ 执行/ 阶段/ ;/ 如果/ 父/ actor/ 与子/ actor/ 在/ 同一/ 台/ 机器/ 上/ 但/ 不/ 在/ 同一个/ 计算/ 核上/ ,/ 结合/ actor/ 间/ 数据/ 依赖/ 关系/ ,/ 子/ actor/ 的/ 阶段/ 号会/ 比父/ actor/ 的/ 阶段/ 号/ 大/ 1.3/ 基于/ COStream/ 的/ 数据流/ 程序/ 目标/ 代码生成/ 3.1/ 层次性/ 流水线/ 代码生成/ 根据/ COStream/ 程序/ 在/ 多/ 核/ 集群/ 下/ 的/ 执行/ 方式/ 和/ 代码/ 结构/ ,/ COStream/ 面向/ 集群/ 后/ 端的/ 目标/ 代码/ 主要/ 包括/ 如下/ 几个/ 部分/ :/ (/ 1/ )/ actor/ 间通信/ 边/ 代码/ ./ SDF/ 图中/ 有/ 向/ 边/ 表示/ 数据/ 的/ 流动/ 方向/ ,/ 边上/ 端/ 结点/ 生产/ 数据/ ,/ 下端/ 结点/ 消耗/ 数据/ ./ COStream/ 基于/ SDF/ 图/ 的/ 这种/ 特点/ 采用/ 生产/ 消费者/ 模型/ 对/ 缓冲区/ 进行/ 管理/ ./ 在/ 多/ 核/ 节点/ 内部/ ,/ 生产者/ 和/ 消费者/ 使用/ 共享内存/ 作为/ 通信/ 方式/ ,/ 在/ 实现/ 上/ 开辟/ 供/ 生产者/ 和/ 消费者/ 共同/ 访问/ 的/ 循环/ 缓存/ 区/ ,/ 生产者/ 将/ 数据/ 写入/ 缓冲区/ 尾部/ ,/ 消费者/ 从/ 缓冲区/ 头部/ 访问/ 数据/ ./ 在/ 节点/ 之间/ ,/ 生产者/ 和/ 消费者/ 采用/ 消息传递/ 的/ 方式/ 进行/ 通信/ ,/ 在/ 实现/ 上/ 生产者/ 所在/ 的/ 节点/ 上/ 开辟/ 发送缓冲区/ ,/ 在/ 消费者/ 所在/ 的/ 节点/ 上/ 开辟/ 接收缓冲区/ ,/ 当/ 生产者/ 将/ 发送缓冲区/ 填满/ 时/ ,/ 生产者/ 发送/ 消息/ ,/ 当/ 消费者/ 收到/ 消息/ 时/ ,/ 消费者/ 从/ 消费者/ 缓冲区/ 中取/ 数据/ 开始/ 执行/ ./ (/ 2/ )/ actor/ 对应/ 类/ 定义/ 代码/ ./ SDF/ 中/ 每个/ 计算/ 节点/ 对应/ 一个/ actor/ 类/ 定义/ ,/ 这类/ 的/ 成员/ 函数/ 主要/ 包含/ :/ 一个/ 用于/ 初始化/ 该/ actor/ 访问/ 的/ 缓冲区/ 构造函数/ ;/ 一个/ 初态/ 调度/ 函数/ 以及/ 一个/ 稳态/ 调度/ 函数/ ,/ 其中/ 初态/ 调度/ 函数/ 和/ 稳态/ 调度/ 函数/ 是/ 根据/ SDF/ 周期性/ 调度/ 结果/ 确定/ 的/ ;/ actor/ 对应/ 的/ operator/ 中/ 的/ 成员/ 方法/ ;/ 用于/ 数据传输/ 的/ 方法/ ./ (/ 3/ )/ 同步/ 流水线/ 循环/ 和/ 控制代码/ ./ 根据/ 节点/ 内/ 同步/ 流水线/ 调度/ 结果/ 生成/ 该/ 节点/ 内/ 所有/ actor/ 执行/ Page8/ 的/ 控制代码/ 和/ 计算/ 核/ 上线/ 程间/ 同步/ 的/ 控制代码/ ./ COStream/ 根据/ 线程/ 级任务/ 划分/ 决定/ 一个/ 线程/ 内/ 的/ actor/ ,/ 通过/ 同步/ 流水线/ 调度/ 确定/ actor/ 间/ 的/ 执行/ 顺序/ ./ 进程/ 内部/ 的/ actor/ 间通信/ 采用/ 共享内存/ 机制/ 消除/ 数据/ 拷贝/ ,/ 利用/ 流水线/ 执行/ 阶段/ 间/ 的/ 同步/ ,/ 保证/ 在/ 同一个/ 进程/ 内有/ 数据/ 依赖/ 的/ actor/ 间/ 的/ 数据/ 能够/ 及时/ 得到/ 满足/ ./ (/ 4/ )/ 进程/ 管理/ 代码/ ./ 进程/ 管理/ 代码/ 主要/ 包括/ 根据/ 划分/ 结果/ 为/ 多/ 核/ 集群/ 上/ 的/ 节点/ 创建/ 进程/ 、/ 在/ 进程/ 内部/ 创建/ 多个/ 线程/ 、/ 为单/ 节点/ 内线/ 程/ 间通信/ 开辟/ 空间/ 和/ 控制/ 执行/ 进程/ 上/ 的/ 计算/ 任务/ 等/ ./ 3.2/ COStream/ 多核/ 节点/ 内部/ 基于/ Cache/ 的/ 通信/ 和/ 同步/ 的/ 设计/ 与/ 优化/ 集群/ 节点/ 内/ 同步/ 流水线/ 各/ 执行/ 阶段/ 的/ 同步/ 采用/ lock/ -/ free/ [/ 9/ -/ 10/ ]/ 方式/ 实现/ ,/ lock/ -/ free/ 抛开/ 锁/ 的/ 概念/ ,/ 执行/ 效率高/ ./ 由于/ 多线程/ 共享/ 缓存数据/ ,/ Cache/ 是/ 以/ CacheLine/ 为/ 存储/ 单位/ 的/ ,/ 当/ 多个/ 线程/ 修改/ 互相/ 独立/ 的/ 变量/ 且/ 这些/ 变量/ 共享/ 同一个/ CacheLine/ 上时/ ,/ 存在/ 伪/ 共享/ (/ FalseSharing/ )/ ,/ 就/ 会/ 影响/ 线程/ 的/ 性能/ ./ 线程/ 间/ 同步/ 的/ 伪/ 共享/ 利用/ 缓存/ 行/ 填充/ 机制/ 能够/ 有效/ 的/ 消除/ ,/ 这种/ 方式/ 采用/ 空间/ 换/ 时间/ 的/ 思想/ ,/ 但是/ 在/ 同一个/ 集群/ 节点/ 内部/ actor/ 间通信/ 也/ 会/ 存在/ 伪/ 共享/ ,/ 如图/ 6/ (/ a/ )/ 所示/ 生产/ 消费者/ 链中/ 如果/ P/ 、/ C/ 在/ 不同/ 的/ 核上/ 并行执行/ 时/ ,/ 当/ P/ 和/ C/ 访问/ 的/ 空间/ 在/ 同一个/ CacheLine/ 上时/ 也/ 会/ 发生/ 伪/ 共享/ ,/ 如图/ 6/ (/ b/ )/ ./ 在/ 复杂/ 的/ 数据流/ 图中会/ 存在/ 多条/ 核/ 间通信/ 边/ ,/ 如果/ 依然/ 采用/ 缓存/ 行/ 填充/ 机制/ ,/ 必然/ 会/ 造成/ 大量/ 空间/ 被/ 浪费/ ,/ 降低/ 存储/ 利用率/ 且/ 产生/ 较/ 高/ 通信/ 延迟/ ./ 为了/ 消除/ 通信/ 缓冲区/ 的/ 伪/ 共享/ 且/ 尽可能/ 提高/ Cache/ 的/ 利用率/ ,/ COStream/ 提出/ 了/ 稳态/ 扩展/ 技术/ ./ 稳态/ 扩展/ 技术/ 是/ 指/ 在/ 编译/ 阶段/ 通过/ 增/ 大S/ DF/ 图中/ actor/ 稳态/ 执行/ 次数/ ,/ 使/ actor/ 在/ 一次/ 稳态/ 执行/ 产生/ 数据量/ 至少/ 大于/ 一个/ CacheLine/ 的/ 空间/ ,/ 消除/ 通信/ 边/ 的/ 伪/ 共享/ ,/ 如图/ 6/ (/ c/ )/ 所示/ 为/ 消除/ 伪/ 共享/ 后/ Cache/ 的/ 使用/ 情况/ ./ 稳态/ 扩展/ 技术/ 主要/ 从/ 如下/ 几个/ 角度/ 对/ Cache/ 的/ 利用/ 进行/ 了/ 优化/ :/ (/ 1/ )/ 提高/ 了/ 指令/ 的/ 局部性/ ;/ (/ 2/ )/ 消除/ 核/ 间通信/ 边/ 的/ 伪/ 共享/ ;/ (/ 3/ )/ 提高/ 核内/ actor/ 数据/ 局部性/ ./ 尽管/ 增大/ actor/ 稳态/ 执行/ 次数/ 能够/ 增大/ Cache/ 的/ 利用率/ ,/ 但/ 如果/ 稳态/ 执行/ 次数/ 过大/ 可能/ 会/ 造成/ Cache/ 溢出/ ,/ 并且/ 执行/ 次数/ 过多/ 也/ 会/ 增加/ 程序执行/ 延迟/ ./ 算法/ 4/ 描述/ 了/ 对/ 数据流/ 程序/ actor/ 稳态/ 扩展/ 因子/ 的/ 确定/ ,/ 算法/ 采用/ 贪心/ 思想/ :/ 首先/ 计算/ SDF/ 稳态/ 执行/ 一次/ 所有/ 输出/ 边/ 消除/ 伪/ 共享/ 后/ 相关/ 的/ actor/ 应该/ 扩展/ 的/ 系数/ ,/ 然后/ 在/ 所有/ 扩展/ 系数/ 中/ 找/ 能够/ 使/ 所有/ actor/ 扩展/ 后/ 在/ 执行/ 时/ 都/ 不会/ 使/ L1/ 数据/ Cache/ 溢出/ 的/ 最大/ 系数/ 作为/ 最终/ 扩展/ 系数/ ./ 为了/ 使/ Cache/ 更好/ 的/ 发挥/ 效用/ ,/ 在/ 查找/ 扩展/ 系数/ 时/ 并不一定/ 要/ 使/ 所有/ 的/ actor/ 执行/ 都/ 不会/ 发生/ 数据/ Cache/ 溢出/ ,/ 根据/ “/ 90/ // 10/ 原则/ ”/ 允许/ 有/ 10/ %/ 的/ actor/ 执行/ 时/ 发生/ 溢出/ L1/ 数据/ Cache/ ,/ 但/ 不会/ 使/ L2/ // L3Cache/ 溢出/ ,/ 这样/ 也/ 能/ 取得/ 较/ 好/ 的/ 性能/ ./ 算法/ 4/ ./ 稳态/ 扩展/ 因子/ 计算/ 算法/ ./ 输入/ :/ SDF/ 图/ G/ (/ V/ ,/ E/ )/ 及其/ 稳态/ 调度/ S/ ,/ 层次/ 划分/ 的/ 结/ 输出/ :/ 扩展/ 因子/ f/ 创建/ 一个/ 大小/ 为/ |/ S/ |/ 的/ 数组/ mf/ [/ ]/ ;/ WHILE/ (/ 遍历/ P/ 中/ 的/ CP/ )/ {/ Page9/ }/ // // ENDWHILESortByValueDescending/ (/ mf/ )/ ;/ // // 对/ mf/ 按值/ 递增/ 排序/ 遍历/ mf/ 找出/ 让/ 所有/ 的/ actor/ 在/ 执行/ 时/ 都/ 不会/ 出现/ L1/ 数据/ Cache/ 溢出/ 的/ 值/ lf/ ;/ f/ =/ lf/ ;/ 3.3/ COStream/ 集群/ 节点/ 间/ 通信模型/ 设计/ 集群/ 节点/ 间/ 采用/ 异步/ 流水线/ 调度/ 方式/ ,/ 通信/ 模块/ 设计/ 目的/ 是/ 简化/ 代码生成/ 屏蔽/ 通信/ 细节/ ,/ 为/ 目标/ 代码/ 的/ 执行/ 提供/ 运行/ 时/ 支持/ ./ COStream/ 面向/ 集群/ 后/ 端的/ 节点/ 间通信/ 库是/ 使用/ MPI/ 实现/ 的/ ,/ 利用/ MPI/ 中/ 的/ 非/ 阻塞/ 通信/ 机制/ 使/ 计算/ 与/ 通信/ 尽可能/ 重叠/ ./ 在/ COStream/ 中/ 对于/ 生产者/ 缓冲区/ 双/ 缓存/ 机制/ ,/ 保证/ 在/ 通信/ 时/ 生产者/ 的/ 计算/ 可以/ 与/ 通信/ 重叠/ 执行/ ;/ 对于/ 消费者/ 采用/ 可变/ 长/ 的/ 循环/ 缓冲区/ ,/ 由于/ COStream/ 执行/ 存在/ 初态/ 和/ 稳态/ 状态/ ,/ 在/ 两种/ 执行/ 状态/ 下/ 消息/ 长度/ 并/ 没有/ 必然联系/ ,/ 变/ 长/ 循环/ 缓冲区/ 能够/ 有效/ 的/ 消除/ 在/ 消息/ 长度/ 不/ 确定/ 的/ 情况/ 下/ 接收/ 时/ 将/ 消息/ 存放/ 在/ 不/ 连续/ 空间/ 上/ 的/ 开销/ ./ 图/ 7/ 描述/ 了/ 两个/ actorP/ 和/ C/ 被/ 划分/ 在/ 不同/ 的/ 机器/ 上/ 执行/ 时/ 节点/ 间通信/ 的/ 过程/ ,/ Buffer1/ 和/ Buffer2/ 标识/ actorP/ 的/ 双/ 缓存/ ,/ Buffer/ 表示/ actorP/ 的/ 接收/ 缓存/ ,/ tail/ 和/ head/ 分别/ 表示/ Buffer/ 的/ 头/ 指针/ 和/ 尾/ 指针/ ,/ MaxSize/ 和/ ValidSize/ 分别/ 表示/ 缓冲区/ 有效/ 空间/ 大小/ 和/ 最大/ 空间/ 大小/ ./ 图/ 7/ (/ a/ )/ 中/ actorP/ 运行/ 填满/ 一个/ 缓冲区/ ,/ 将/ 数据/ 发送给/ actorC/ ,/ 设/ 发送/ 的/ 消息/ 的/ 长度/ 为/ length/ ,/ 当/ Buffer/ 的/ 尾/ 指针/ tail/ +/ length/ / MaxSize/ ,/ 消息/ 直接/ 被/ 存放/ 在/ 接收者/ 缓存/ 中且/ ValidSize/ =/ MaxSize/ ./ 但是/ 如果/ 出现/ tail/ +/ length/ >/ MaxSize/ 的/ 情况/ 时/ ,/ 由于/ 缓冲区/ 尾部/ 剩余/ 的/ 连续/ 空间/ 不够/ 容纳/ 一条/ 消息/ ,/ 那么/ Buffer/ 的/ ValidSize/ 被/ 修改/ ,/ 同时/ 置/ tail/ 为/ 0/ ,/ 当/ head/ —/ tail/ / length/ 时才/ 接收/ 消息/ ,/ 在/ 开始/ 接收数据/ 前/ 缓冲区/ 的/ 使用/ 如图/ 7/ (/ b/ )/ 所示/ ./ 为了/ 减少/ 接收/ 消息/ 的/ 等待时间/ ,/ 在/ 实际/ 实现/ 时/ 通常/ Buffer/ 的/ 长度/ 大于/ Buffer1/ 长度/ 的/ 二倍/ ./ 通过/ 双/ 缓存/ 和/ 变长/ 循环/ 缓冲区/ 使得/ 计算/ 能够/ 尽可能/ 与/ 通信/ 重叠/ ./ 4/ 实验/ 结果/ 与/ 分析/ 4.1/ 实验/ 平台/ 与/ 测试方法/ 实验/ 平台/ 由/ 4/ 台/ X86/ -/ 64/ 架构/ 的/ 通用/ 多核/ 服务器/ 作为/ 服务/ 计算/ 节点/ ,/ 采用/ 局域网/ 组成/ 小型/ 集群/ 系统/ ./ 每个/ 计算/ 节点/ 配有/ 2/ 颗/ 4/ 核/ 的/ 2.40/ GHzIntelXeonE5620CPU/ ,/ 最大/ 支持/ 内存/ 48GB/ ,/ 1/ 个/ Gigabit/ 网卡/ ./ 节点/ 上/ Linux/ 操作系统/ 内核/ 版本/ 为/ 2.6/ ./ 18/ ,/ gcc/ 版本/ 为/ 4.1/ ./ 2/ ,/ 编译/ 优化/ 选项/ 采用/ -/ O2/ ,/ MPI/ 版本/ 是/ mpich2/ -/ 1.4/ ./ 1p1/ ./ 为了/ 对/ 层次/ 流水线/ 编译/ 优化/ 进行/ 全面/ 的/ 性能/ 评估/ 和/ 分析/ ,/ 实验/ 选取/ 了/ 9/ 个/ 数字/ 媒体/ 领域/ 典型/ 算法/ 对/ 其/ 进行/ 扩展/ 作为/ 测试程序/ ,/ 用/ COStream/ 数据流/ 编程语言/ 实现/ ./ 各个/ 测试程序/ 的/ 功能/ 、/ 规模/ 和/ 结构/ 描述/ 如表/ 1/ 所示/ ./ 测试程序/ 名/ BeamFormer/ 滤波器/ 程序/ 228286ChannelVocoder/ 频道/ 话/ 路/ 编码器/ 497640DCTFFTFilterbank/ 多/ 速率/ 信号处理/ 滤波/ 9801553SperpentVocoder/ 比特率/ 减低/ 声码/ 90011794.2/ 并行/ 优化/ 系统/ 实验/ 与/ 性能/ 评价/ (/ 1/ )/ 层次性/ 任务/ 划分算法/ 性能/ 评价/ 图/ 8/ 给出/ 了/ 进程/ 级/ 和/ 线程/ 级/ 均/ 用/ 多层/ K/ 路图/ 划分算法/ [/ 11/ ]/ (/ MultilevelK/ -/ wayPartitioning/ ,/ MKP/ )/ 实现/ 的/ 任务/ 划分算法/ 与/ 层次/ 任务/ 划分算法/ 的/ 一个/ 性能/ 比较/ ,/ 实验/ 在/ 4/ 个/ 节点/ 组成/ 的/ 集群/ 下/ 进行/ 的/ ./ 在/ 实验/ 中/ 测试程序/ BeamFormer/ 、/ ChannelVector/ 、/ Serpent/ 和/ Vocoder/ 在/ 采用/ MKP/ 时/ 划分/ 结果/ 出现/ 环路/ ,/ 实际/ 执行/ 时/ 出现/ 死锁/ ,/ 无法/ 统计/ 执行/ 时间/ ;/ 所有/ 测试程序/ 在/ 层次性/ 划分算法/ 下均/ 能够/ 正确/ 执行/ ./ 从图/ 8/ 可以/ 看出/ ,/ 对于/ MKP/ 和/ 层次性/ 划分/ 均/ 能/ 正常/ 执行/ ,/ 程序/ 中/ DCT/ 采用/ MKP/ 划分/ 结果/ 的/ 执行/ 时间/ 是/ 采用/ 层次性/ 划分/ 的/ 1.8/ 倍/ ,/ 分析/ 发现/ 由于/ MKPPage10/ 划分/ 是/ 以/ 负载/ 均衡/ 为/ 目标/ 没有/ 充分考虑/ 节点/ 通信/ 延迟/ ,/ 造成/ MKP/ 划分/ 尽管/ 各个/ 节点/ 有/ 相对/ 均衡/ 的/ 负载/ 但/ 节点/ 间/ 的/ 通信/ 数据量/ 比/ 采用/ 层次性/ 划分/ 要/ 大/ ;/ 对/ tde/ 层次性/ 划分/ 比/ MKP/ 要/ 差/ ,/ 原因/ 是/ 层次性/ 划分/ 考虑/ 了/ 通信/ 开销/ ,/ 程序/ 在/ 进程/ 级/ 划分/ 后/ 划分/ 间/ 的/ 负载/ 没有/ MKP/ 好/ ./ 平均/ 来看/ 层次性/ 划分/ 比/ MKP/ 更/ 能够/ 满足/ 数据流/ 程序/ 在/ 多/ 核/ 集群/ 下/ 的/ 执行/ ./ 图/ 8/ 层次性/ 任务/ 划分算法/ 与/ MKP/ 划分算法/ 对比/ (/ 2/ )/ 加速/ 比图/ 9/ 给出/ 了/ 测试程序/ 经过/ COStream/ 编译/ 后/ 在/ 单/ 节点/ 多核/ 上/ 执行/ 加速/ 比/ 的/ 示意图/ ./ 从图/ 中/ 可以/ 看出/ ,/ 测试程序/ 执行/ 加速/ 比/ 随核/ 数目/ 的/ 增多/ 而/ 增大/ ,/ 基本/ 呈现/ 线性/ 增长/ 趋势/ ./ 图/ 10/ 描述/ 了/ 测试程序/ 分别/ 在/ 1/ 个/ 、/ 2/ 个/ 、/ 3/ 个/ 和/ 4/ 个/ 节点/ 的/ 集群/ 规模/ 上/ 加速/ 比/ 示意图/ ./ 在/ 图/ 中/ 测试程序/ 执行/ 加速/ 比均/ 呈现/ 一个/ 线性/ 增长/ 的/ 趋势/ ./ 测试程序/ 在/ 2/ 个/ 节点/ 的/ 情况/ 下/ 加速/ 比/ 基本/ 能够/ 达到/ 1.5/ x/ 以上/ ,/ 在/ 4/ 个/ 计算/ 节点/ 的/ 情况/ 下/ tde/ 达到/ 3.5/ x/ 且/ 有/ 3/ 个/ 测试程序/ 的/ 加速/ 比/ 在/ 3x/ 以上/ ,/ 加速/ 效果/ 比较/ 理想/ ;/ 但/ 对于/ FilterBank/ 、/ Serpent/ 和/ Vocoder/ 等/ 程序/ 在/ 4/ 个/ 节点/ 上时/ ,/ 加速/ 效果/ 并/ 不是/ 十分/ 理想/ ./ 通过/ 对/ 分析/ 发现/ 由于/ SDF/ 图/ 本身/ 结构复杂/ ,/ 进程/ 级任务/ 划分/ 后/ 进程/ 间通信/ 复杂/ ,/ 使得/ 计算/ 与/ 通信/ 不/ 能够/ 重叠/ ,/ 造成/ 大/ 的/ 通信/ 开销/ ,/ 影响/ 加速/ 效果/ ./ 通过/ 对/ 测试程序/ 在/ 多/ 核/ 节点/ 内部/ 和/ 多/ 核/ 集群/ 上/ 的/ 执行/ 情况/ 分析/ 发现/ 影响/ 加速/ 效果/ 主要/ 有/ 下面/ 4/ 个/ 因素/ :/ (/ 1/ )/ 负载/ 均衡/ ./ 由于/ 线程/ 间/ 采用/ 同步/ 流水线/ 调度/ ,/ 如果/ 计算/ 核上/ 的/ 任务/ 负载/ 不/ 均衡/ ,/ 即使/ 不/ 考虑/ 同步/ 、/ 通信/ 等/ 因素/ ,/ 程序执行/ 受/ 负载/ 最大/ 的/ 那个/ 计算/ 线程/ 的/ 影响/ ,/ 程序执行/ 效果/ 也/ 不/ 可能/ 达到/ 理想/ 要求/ ./ 对于/ 集群/ 节点/ 间/ ,/ 负载/ 均衡/ 能够/ 使/ 各个/ 节点/ 生产/ 和/ 消耗/ 数据/ 速率/ 相匹配/ ,/ 最小化/ 数据/ 等待/ 延迟/ ;/ (/ 2/ )/ 局部性/ (/ locality/ )/ ./ 局部性/ 主要/ 针对/ 线程/ 级任务/ 划分/ ,/ 在线/ 程级/ 划分/ 后/ 如果/ 子图/ 的/ 局部性/ 越差/ ,/ 节点/ 内核/ 间通信/ 边/ 数目/ 就/ 越/ 多/ ,/ 程序运行/ 时/ 核间/ 就/ 需要/ 频繁/ 地/ 进行/ 数据通信/ ,/ 影响/ 数据/ 局部性/ ,/ 增大/ 数据/ 访问/ 延迟/ ;/ (/ 3/ )/ 通信/ 开销/ ./ 通信/ 开销/ 主要/ 针对/ 集群/ 节点/ 间/ ,/ 尽管/ 为了/ 降低/ 节点/ 间/ 数据传输/ 开销/ 采用/ 了/ 非/ 阻塞/ 通信/ 机制/ 和/ 双/ 缓存/ 缓冲区/ 管理策略/ ,/ 但/ 进程/ 级任务/ 划分/ 后/ 如果/ 数据传输/ 时间/ 大于/ 计算/ 单元/ 产生/ 能够/ 填满/ 一个/ 缓冲区/ 数据/ 所/ 需/ 的/ 计算/ 时间/ ,/ 计算/ 不/ 能够/ 与/ 通信/ 重叠/ ,/ 计算/ 单元/ 因为/ 不足/ 而/ 陷入/ 等待/ ./ 另外/ ,/ 如果/ 节点/ 间通信/ 边/ 的/ 数目/ 过多/ ,/ 在/ 节点/ 间通信/ 的/ 软件/ 层面/ 需要/ 切换/ 网络连接/ ,/ 也/ 会/ 产生/ 较大/ 通信/ 延迟/ ;/ (/ 4/ )/ 数据流/ 程序/ 自身/ 特性/ ,/ 主要/ 是/ SDF/ 图中/ 通信/ 边数/ 、/ actor/ 的/ 负载/ 以及/ actor/ 生产/ 和/ 消耗/ 数据/ 速率/ 等/ 因素/ ./ 在/ 图/ 10/ 中/ Vocoder/ 由于/ 自身/ actor/ 负载/ 分布/ 不/ 均匀/ 导致/ 加速/ 效果/ 不/ 理想/ ;/ FilterBank/ 由于/ actor/ 间通信/ 复杂/ 加速/ 效果/ 也/ 不/ 太/ 理想/ ;/ 而/ tde/ 能够/ 达到/ 3.5/ x/ 的/ 加速/ 比是/ 由于/ 图中/ 各个/ actor/ 的/ 负载/ 均衡/ 且/ actor/ 间通信/ 边/ 的/ 数目/ 较/ 少/ ,/ 经过/ 进程/ 级/ 和/ 线程/ 级/ 划分/ 能够/ 得到/ 具有/ 良好/ 负载/ 均衡/ 和/ 低/ 通信/ 的/ 划分/ 结果/ ,/ 有/ 较/ 高/ 加速/ 比/ ./ (/ 3/ )/ 扩展性/ 为了/ 分析/ 层次性/ 流水线/ 优化/ 的/ 扩展性/ ,/ 对/ 部分/ 测试程序/ 的/ 规模/ 进行/ 修改/ ,/ 图/ 11/ 描述/ 了/ 测试程序/ 的/ 不同/ 规模/ 在/ 多/ 核/ 集群/ 下/ 的/ 执行/ 情况/ ./ 从图/ 中/ 可以/ 看出/ ,/ 一般/ 当/ 程序/ 规模较/ 小时/ ,/ 多/ 节点/ 集群/ 环境/ 并/ 不能/ 取得/ 很/ 好/ 的/ 性能/ 收益/ ./ 原因/ 是/ 节点/ 间/ 的/ 通信/ 不能/ 被/ 计算/ 隐藏/ ,/ 在/ 这种/ 情况/ 下单/ 节点/ 多核/ 是/ 较/ 理想/ 的/ 选择/ ,/ 但/ 随着/ 程序/ 规模/ 的/ 增大/ 集群/ 的/ 优势/ 也/ 就/ 越/ 明显/ ./ 从图/ 11/ 可以/ 看出/ SDF/ 图/ 的/ 规模/ 变/ 大/ ,/ 部分/ 测试/ 程/ Page11/ 序/ 的/ 加速/ 比/ 能够/ 达到/ 3x/ 以上/ ,/ 在/ 图/ 中/ FFT/ 和/ DES/ 随着/ 测试程序/ 规模/ 的/ 变化/ ,/ 加速/ 比/ 基本/ 呈现/ 一个/ 线性/ 增长/ 趋势/ ;/ tde/ 和/ BeamFormer/ 加速/ 比/ 并/ 没有/ 随着/ 程序/ 规模/ 的/ 变化/ ,/ 是/ 由于/ 在/ 规模/ 变大时/ tde/ 的/ SDF/ 图中/ actor/ 间/ 的/ 通信/ 量变/ 大而/ BeamFormer/ 的/ SDF/ 图/ 11/ 多核/ 集群/ 环境/ 下/ 测试程序/ 不同/ 规模/ 下/ 执行/ 加速/ 比/ (/ 4/ )/ 基于/ Cache/ 伪/ 共享/ 优化/ 的/ 效率/ 为了/ 提高/ 节点/ 内部/ 程序/ 的/ 执行/ 效率/ ,/ 针对/ Cache/ 存在/ 的/ 伪/ 共享/ 进行/ 了/ 稳态/ 扩展/ 优化/ ,/ 图/ 12/ 描述/ 了/ Cache/ 优化/ 前后/ 程序/ 在/ 单/ 节点/ 8/ 个/ 核上/ 执行/ 性能/ 的/ 比较/ ./ 测试程序/ 中有/ 3/ 个/ 程序执行/ 了/ 稳态/ 扩展/ ,/ 而/ 其他/ 测试程序/ 由于/ actor/ 稳态/ 执行/ 生产/ 的/ 数据量/ 超出/ 了/ 一个/ CacheLine/ 大小/ 不会/ 发生/ 伪/ 共享/ ./ 实验/ 中/ BeamFormer/ 优化/ 后/ 的/ 性能/ 提升/ 达到/ 60/ %/ ,/ 原因/ 是/ 该/ 程序/ 自身/ 的/ 通信/ 比较复杂/ 使得/ 划分/ 完成/ 后/ 核间/ 的/ 通信/ 边过/ 多/ ./ 对/ 经过/ 稳态/ 扩展/ 的/ 程序/ 进行/ 分析/ 发现/ 影响/ Cache/ 优化/ 性能/ 提升/ 的/ 主要/ 因素/ 是/ 核/ 间通信/ 边/ 的/ 数目/ ./ 核/ 间通信/ 边越/ 多/ ,/ Cache/ 伪/ 共享/ 对/ 性能/ 的/ 影响/ 越大/ ,/ 消除/ 伪/ 共享/ 带来/ 的/ 性能/ 提升/ 越大/ ,/ 但/ 在/ 现代/ 图中/ 通信/ 边/ 增多/ ,/ 导致/ 在/ 实际/ 执行/ 时/ 通信/ 不能/ 被/ 计算/ 覆盖/ ,/ 影响/ 加速/ 效果/ ./ 总的来说/ ,/ 由于/ 程序/ 的/ 规模/ 变/ 大/ ,/ 使得/ 编译/ 有/ 更/ 大/ 的/ 优化/ 空间/ ,/ 从而/ 能够/ 取得/ 较/ 好/ 的/ 效果/ ./ 通过/ 图/ 11/ 说明/ 了/ 层次/ 流水线/ 并行/ 优化/ 具有/ 较/ 好/ 的/ 扩展性/ ./ 的/ 处理器/ 结构/ 中/ 由于/ 存在/ L2Cache/ 甚至/ L3Cache/ ,/ 在/ 一定/ 程度/ 上/ 降低/ 了/ Cache/ 伪/ 共享/ 对/ 程序执行/ 性能/ 的/ 影响/ ./ 图/ 12/ 单/ 节点/ 内/ 8/ 个/ 核下/ 测试程序/ 在/ Cache/ 优化/ 前后/ 执行/ Page125/ 相关/ 工作/ 数据流/ 编程/ 模型/ 是/ 针对/ 数据流/ 应用/ 大规模/ 密集型/ 计算/ 特点/ 和/ 多/ 核/ 处理器/ 而/ 设计/ 的/ 一种/ 编程/ 模型/ [/ 12/ ]/ ./ 针对/ 多/ // 众核/ 平台/ 数据流/ 程序/ 的/ 编译/ 优化/ 的/ 研究/ 成为/ 当前/ 研究/ 的/ 热点/ ./ 麻省理工学院/ 的/ Gordon/ 等/ 人/ [/ 9/ ,/ 13/ ]/ 针对/ StreamIt/ 在/ Raw/ 下/ 利用/ 分裂/ 和/ 融合/ 技术/ 挖掘/ stateless/ 类型/ 节点/ 存在/ 的/ 任务/ 和/ 数据/ 并行性/ ,/ 利用软件/ 流水线/ 调度/ 技术/ 挖掘/ stateful/ 类型/ 节点/ 的/ 流水线/ 并行性/ ;/ Sermulins/ 等/ 人/ [/ 14/ ]/ 研究/ StreamIt/ 在/ 带有/ Cache/ 的/ 处理器/ 下/ 的/ 执行/ 情况/ ,/ 提出/ 了/ 采用/ 执行/ 缩放/ 技术/ 、/ 基于/ Cache/ 的/ 融合/ 技术/ 和/ 标量/ 替换/ 技术相结合/ 的/ 方式/ 提高/ 指令和数据/ 的/ 局部性/ ,/ 改善/ 程序执行/ 性能/ ;/ 密歇根/ 大学/ 的/ Kudlur/ 等/ 人/ [/ 15/ ]/ 针对/ 流/ 程序/ 中/ stateless/ 节点/ 存在/ 的/ 并行性/ 提出/ 了/ SGMS/ 调度/ 方法/ (/ StreamGraphModuloScheduling/ )/ ,/ 但是/ 该/ 方法/ 在/ 任务/ 划分/ 时/ 只/ 对/ 计算资源/ 进行/ 形式化/ 建模/ ,/ 没有/ 考虑/ 通信/ 和/ 存储资源/ ;/ 斯坦福大学/ 的/ Park/ 等/ 人/ [/ 16/ ]/ 针对/ SGMS/ 提出/ 了/ Team/ 调度/ 算法/ (/ TeamScheduling/ )/ ,/ Team/ 调度/ 灵活/ 的/ 控制/ 缓冲区/ 大小/ ,/ 适用/ 于/ 局部/ 存储/ 受限/ 的/ 多/ 核/ 机器/ ;/ 华中科技大学/ Wei/ 等/ 人/ [/ 17/ ]/ 在/ 资源/ 受限/ 的/ 多/ 核/ 架构/ 上/ 采用/ 整数/ 线性规划/ 理论/ 对/ 计算/ 、/ 通信/ 、/ 存储/ 等/ 资源/ 和/ 流水线/ 执行/ 阶段/ 进行/ 建模/ ,/ 但/ 该/ 方法/ 并/ 没有/ 考虑/ 分布式/ 环境/ 对流/ 程序执行/ 的/ 影响/ ./ 针对/ 上述/ 问题/ ,/ 本文/ 基于/ 多/ // 众核/ 架构/ 提出/ 一种/ 层次/ 流水线/ 并行/ 优化/ 方法/ ,/ 并/ 结合/ 底层/ 系统结构/ 做/ 优化/ ,/ 提高/ 数据流/ 程序/ 在/ 多/ 核/ 集群/ 下/ 的/ 执行/ 性能/ ./ 6/ 总结/ 本文/ 设计/ 并/ 实现/ 了/ 一个/ 基于/ SDF/ 图/ 的/ 数据流/ 程序/ 层次/ 流水线/ 并行/ 编译/ 优化/ 框架/ ,/ 通过/ 该/ 框架/ 有效/ 提高/ 了/ 数据流/ 程序/ 在/ 多/ 核/ 集群/ 下/ 的/ 执行/ 性能/ ./ 该/ 并行/ 编译/ 优化/ 框架/ 包含/ 3/ 个/ 模块/ :/ 层次性/ 任务/ 划分/ 模块/ 、/ 层次/ 流水线/ 调度/ 模块/ 和/ 与/ 底层/ 结构/ 相关/ 优化/ 模块/ ,/ 最后/ 生成/ 基于/ MPI/ 目标/ 代码/ ./ 该/ 编译/ 优化/ 框架/ 使得/ 数据流/ 程序/ 在/ 多/ 核/ 集群/ 下/ 能够/ 取得/ 较/ 好/ 的/ 执行/ 效果/ ,/ 但/ 当前/ 调度/ 主要/ 针对/ 同构/ 集群/ ,/ 在/ 异构/ 集群/ 平台/ 下/ 如何/ 开展/ 数据流/ 程序/ 的/ 并行/ 编译/ 优化/ ,/ 是/ 数据流/ 程序/ 需要/ 进一步/ 研究/ 的/ 问题/ ./ 

