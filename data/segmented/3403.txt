Page1/ 一种/ 基于/ 耦合/ 度量/ 的/ 类间/ 集成/ 测试/ 序/ 的/ 确定/ 方法/ 姜淑娟/ 张艳梅/ 李海洋/ 王庆坛/ (/ 中国矿业大学/ 计算机科学/ 与/ 技术/ 学院/ 江苏/ 徐州/ 221116/ )/ 摘要/ 类间/ 测试/ 顺序/ 的/ 确定/ 是/ 类/ 集成/ 测试/ 中/ 难以解决/ 的/ 一个/ 关键问题/ ./ 类/ 的/ 测试/ 序列/ 不同/ ,/ 构造/ 相应/ 的/ 测试/ 桩/ 需要/ 花费/ 的/ 代价/ 也/ 会/ 不同/ ./ 每/ 一个/ 测试/ 桩/ 复杂度/ 度量/ 的/ 准确性/ 决定/ 最终/ 打破/ 环路/ 所/ 需/ 构造/ 测试/ 桩/ 的/ 总体/ 复杂度/ ./ 对于/ 类间/ 测试/ 顺序/ 问题/ ,/ 文章/ 提出/ 一种/ 基于/ 耦合/ 度量/ 的/ 类间/ 集成/ 测试/ 序/ 的/ 确定/ 方法/ ./ 采用/ 类间/ 耦合/ 度量/ 与/ 基于/ 图/ 的/ 启发式/ 算法/ 相结合/ 的/ 方法/ ,/ 其中/ ,/ 前者/ 用于/ 度量/ 每/ 一个/ 测试/ 桩/ 的/ 复杂度/ ,/ 后者/ 用于/ 在/ 保证/ 测试/ 桩/ 总体/ 复杂度/ 尽可能/ 小/ 的/ 条件/ 下来/ 打破/ 环路/ ./ 首先/ 提出/ 一种/ 在/ 度量/ 中/ 使用/ 的/ 耦合/ 权重/ 的/ 计算方法/ ,/ 对/ 测试/ 桩/ 的/ 复杂度/ 进行/ 新/ 的/ 耦合/ 度量/ ;/ 然后/ 给出/ 一种/ 有效/ 打破/ 环路/ 的/ 基于/ 图/ 的/ 启发式/ 算法/ ;/ 最后/ 实现/ 了/ 类间/ 测试/ 序列/ 自动/ 生成/ 工具/ —/ —/ —/ TOGOS/ ./ 实验/ 结果表明/ :/ 文中/ 的/ 方法/ 较/ 现有/ 的/ 方法/ 总体/ 复杂度/ 有/ 明显/ 的/ 降低/ ,/ 从而/ 节约/ 了/ 测试/ 成本/ ./ 关键词/ 集成/ 测试/ ;/ 测试/ 序列/ ;/ 测试/ 桩/ 复杂度/ ;/ 耦合/ 度量/ ;/ 启发式/ 算法/ 1/ 引言/ 面向对象/ 程序/ 不像/ 面向/ 过程/ 程序/ 那样/ 有/ 明显/ 的/ 层次化/ 模块/ 结构/ ,/ 对象/ 之间/ 的/ 联系/ 通过/ 消息传递/ 的/ 方式/ ,/ 一条/ 消息/ 会/ 引起/ 连锁反应/ 进而/ 形成/ 一条/ 方法/ 调用/ 链/ ,/ 体现/ 调用/ 关系/ 的/ 静态/ 结构/ 是/ 一个/ 错综复杂/ 的/ 网状结构/ ./ 因此/ ,/ 从/ 哪里/ 开始/ 测试/ 以及/ 如何/ 定义/ 一个/ 集成/ 测试/ 顺序/ 是/ 需要/ 进一步/ 研究/ 的/ 问题/ ./ 面向/ 过程/ 的/ 基于/ 功能/ 分解/ 的/ 集成/ 测试方法/ 不能/ 满足/ 面向对象/ 程序/ 的/ 集成/ 测试/ 的/ 要求/ ,/ 需要/ 研究/ 满足/ 面向对象/ 程序/ 特点/ 的/ 集成/ 测试方法/ ./ 在/ 面向对象/ 软件/ 中/ ,/ 类/ 集成/ 测试/ 顺序/ 问题/ 是/ 指为/ 那些/ 集成/ 测试/ 的/ 类/ 簇/ 确定/ 它们/ 的/ 测试/ 顺序/ ./ 确定/ 类簇/ 的/ 测试/ 顺序/ 时/ ,/ 对于/ 在/ 类间/ 关系/ 不/ 构成/ 环路/ 的/ 情况/ 下/ ,/ 可以/ 通过/ 逆向/ 拓扑/ 排序/ 来/ 确定/ 它们/ 的/ 测试/ 顺序/ ;/ 在/ 类间/ 关系/ 构成/ 环路/ 的/ 情况/ 下/ ,/ 则/ 必须/ 首先/ 打破/ 环路/ 才能/ 确定/ 它们/ 的/ 测试/ 顺序/ ./ 打破/ 环路/ 是/ 指/ 临时/ 删除/ 一条/ 或/ 多条/ 关联/ 边/ 进而/ 将/ 该类/ 簇/ 构成/ 的/ 有/ 环图/ 变成/ 无环图/ 的/ 过程/ ./ 确定/ 类/ 集成/ 测试/ 顺序/ 是/ 在/ 实际/ 的/ 测试/ 中/ 必须/ 要/ 面临/ 的/ 问题/ ,/ 例如/ 单元测试/ 顺序/ 可能/ 受制于/ 那些/ 与/ 其它/ 项目/ 共享/ 的/ 可/ 利用/ 资源/ ,/ 类/ 集成/ 测试/ 顺序/ 对/ 软件开发/ 和/ 单元测试/ 顺序/ 存在/ 一定/ 的/ 影响/ ./ 针对/ 类/ 集成/ 测试/ 顺序/ 的/ 问题/ ,/ 很多/ 学者/ 提出/ 了/ 不同/ 的/ 解决/ 方法/ ,/ 总体/ 可以/ 归为/ 两种/ :/ 第一种/ 是/ 基于/ 遗传算法/ 的/ 方法/ ,/ 即/ 首先/ 确定/ 一个/ 表示/ 类/ 测试/ 顺序/ 的/ 种群/ ,/ 然后/ 通过/ 选择/ 、/ 交叉/ 和/ 变异/ 对/ 这/ 一种/ 群/ 进行/ 处理/ ,/ 并/ 得到/ 满足/ 一定/ 条件/ 的/ 测试/ 顺序/ ./ 第二种/ 是/ 基于/ 图论/ 的/ 方法/ 、/ 类簇/ 以及/ 它们/ 之间/ 的/ 关系/ 可以/ 抽象/ 为类/ 图/ ,/ 一个/ 类图/ 是/ 一个/ 有向图/ ,/ 表示/ 为/ G/ (/ V/ ,/ E/ )/ ,/ 其中/ V/ 表示/ 类/ 节点/ 集合/ ,/ E/ 表示/ 为类/ 之间/ 关系/ 的/ 边集/ ,/ 其中/ 标签/ I/ 、/ Cp/ 、/ Ag/ 、/ As/ 和/ Us/ 分别/ 表示/ 继承/ 、/ 组合/ 、/ 聚集/ 、/ 关联/ 和/ 使用/ 关系/ ./ 类/ 集成/ 测试/ 顺序/ 问题/ 就是/ 对图/ 中/ 表示/ 类/ 的/ 各/ 节点/ 进行/ 排序/ ,/ 通过/ 分析/ 有向图/ 的/ 结构/ 来/ 确定/ 满足条件/ 的/ 测试/ 顺序/ ./ 类/ 集成/ 测试/ 序列/ 的/ 不同/ ,/ 很大/ 程度/ 上/ 影响/ 着/ 构造/ 相应/ 的/ 测试/ 桩/ 需要/ 花费/ 的/ 测试/ 代价/ 的/ 大小/ ./ 测试/ 桩/ 复杂度/ 是/ 用来/ 衡量/ 构造/ 一个/ 测试/ 桩/ 的/ 难易/ 程度/ ,/ 测试/ 桩/ 的/ 总体/ 复杂度/ 则/ 是/ 用来/ 衡量/ 为/ 一个/ 测试/ 序列/ 总体/ 需要/ 构造/ 的/ 相应/ 测试/ 桩/ 的/ 难易/ 程度/ [/ 1/ ]/ ./ 类/ 集成/ 测试/ 顺序/ 问题/ 中/ ,/ 测试/ 代价/ 的/ 衡量/ 方法/ 主要/ 有/ 两类/ ,/ 一是/ 最小化/ 集成/ 测试/ 过程/ 当中/ 需要/ 建立/ 的/ 测试/ 桩/ 的/ 数量/ [/ 2/ -/ 6/ ]/ ;/ 二是/ 最小化/ 测试/ 桩/ 的/ 总体/ 复杂度/ [/ 1/ ,/ 7/ -/ 8/ ]/ ./ 后者/ 的/ 精确度/ 更高/ ,/ 因为/ 不同/ 的/ 测试/ 桩/ 各自/ 复杂度/ 不同/ ./ 因此/ ,/ 测试/ 桩/ 的/ 数量/ 越少/ 并/ 不能/ 表示/ 一个/ 测试/ 序列/ 需要/ 花费/ 的/ 总体/ 代价/ 越低/ ./ 总体/ 来说/ ,/ 为了/ 实现/ 测试/ 桩/ 的/ 复杂度/ (/ SCplx/ )/ (/ 即/ 构成/ 环路/ 的/ 各边/ 权值/ )/ 的/ 精确度/ 量/ ,/ 减少/ 测试/ 成本/ ,/ 我们/ 需要/ 最小化/ 桩/ 的/ 总体/ 复杂度/ 来/ 找到/ 一个/ 最佳/ 的/ 测试/ 顺序/ ./ 因此/ ,/ 需要/ 解决/ 两个/ 关键问题/ :/ 测试/ 桩/ 的/ 复杂度/ 的/ 计算方法/ 以及/ 打破/ 环路/ 的/ 有效/ 算法/ ./ 针对/ 于/ 第一个/ 问题/ ,/ 即/ 在/ 度量/ 测试/ 桩/ 的/ 复杂度/ 时/ ,/ 给出/ 一种/ 新/ 的/ 计算方法/ ,/ 即/ 在/ 进行/ 耦合/ 度量/ 时/ ,/ 根据/ 类间/ 耦合/ 程度/ 分别/ 对/ 属性/ 耦合/ 和/ 方法/ 耦合/ 赋予/ 权值/ ;/ 对于/ 第二个/ 问题/ ,/ 首先/ 找出/ 类图/ 中/ 的/ 强/ 联通/ 组件/ (/ SCCs/ )/ ,/ 然后/ 采用/ 基于/ 图论/ 的/ 启发式/ 算法/ 打破/ 环路/ ,/ 弥补/ 目前/ 断开/ 继承/ 、/ 组合/ 和/ 聚集/ 等/ 强/ 联系/ 关系/ 增加/ 测试/ 桩/ 的/ 复杂度/ 的/ 缺陷/ ,/ 使/ 最终/ 所/ 构造/ 的/ 测试/ 桩/ 的/ 总体/ 复杂度/ 最小/ ./ 2/ 估算/ 测试/ 桩/ 复杂度/ 的/ 耦合/ 度量/ 方法/ 通过/ 最小化/ 测试/ 桩/ 的/ 总体/ 复杂度/ 来/ 找到/ 一个/ 最佳/ 的/ 测试/ 顺序/ ,/ 首先/ 要/ 解决/ 的/ 第一个/ 问题/ 是/ 测试/ 桩/ 的/ 复杂度/ 的/ 计算方法/ ,/ 只有/ 在/ 精确/ 评价/ 测试/ 桩/ 的/ 复杂度/ 的/ 基础/ 上/ 才能/ 准确/ 地/ 判断/ 打破/ 环路/ 时所要/ 删除/ 的/ 边集/ ,/ 进而/ 找到/ 最佳/ 的/ 测试/ 顺序/ ./ Briand/ [/ 8/ ]/ 在/ 计算/ 复杂度/ 时/ ,/ 对于/ 所/ 使用/ 的/ 耦合/ 度量/ 方法/ 中/ 的/ 属性/ 耦合/ 和/ 方法/ 耦合/ 分配/ 的/ 是/ 相同/ 的/ 权值/ ,/ 因此/ ,/ 考虑/ 的/ 是/ 一种/ 特殊/ 的/ 情况/ ;/ 而/ Abduraz/ -/ ik/ 等/ 人/ [/ 1/ ]/ 将/ 耦合/ 分为/ 9/ 种/ 类型/ ,/ 不仅/ 对边/ 的/ 权重/ 进行/ 定量/ 的/ 耦合/ 度量/ ,/ 同时/ 也/ 对/ 节点/ 权重/ 进行/ 了/ 度量/ ,/ 综合/ 考虑/ 边/ 和/ 节点/ 的/ 权重/ ,/ 进一步/ 精确度/ 量/ 结果/ ,/ 但是/ 这样/ 增加/ 了/ 算法/ 的/ 复杂度/ ,/ 提高/ 了/ 测试/ 成本/ ./ 因此/ ,/ 在/ 度量/ 测试/ 桩/ 的/ 复杂度/ 时/ ,/ 对于/ 耦合/ 度量/ 方法/ 中/ 的/ 属性/ 耦合/ 和/ 方法/ 耦合/ 赋予/ 权值/ ,/ 本文/ 给出/ 了/ 一种/ 新/ 的/ 计算方法/ ./ 2.1/ 相关/ 概念/ 测试/ 桩/ 复杂度/ 是/ 用来/ 衡量/ 构造/ 一个/ 测试/ 桩/ 的/ 难易/ 程度/ ,/ 测试/ 桩/ 的/ 总体/ 复杂度/ 则/ 是/ 用来/ 衡量/ 为/ 一个/ 测试/ 序列/ 需要/ 构造/ 的/ 总体/ 测试/ 桩/ 的/ 难易/ 程度/ ./ 在/ 集成/ 测试/ 过程/ 中/ ,/ 我们/ 常常/ 遇到/ 这样/ 的/ 情况/ :/ 当/ 需要/ 对/ 某/ 一个/ 类/ A/ 进行/ 测试/ 时/ ,/ 类/ A/ 所/ 依赖/ 的/ 另/ 一个/ 类/ B/ 并/ 没有/ 经过/ 测试/ ./ 如果/ 很难/ 在/ 短时间/ 内/ 构建/ 类/ B/ ,/ 必定会/ 影响/ 到/ 对/ 类/ A/ 的/ 集成/ 测试/ ./ 此时/ 我们/ 需要/ 模拟/ 的/ 对象/ 来/ 替代/ 类/ B/ ,/ 我们/ 称该/ 模拟/ 的/ 对象/ 为/ 测试/ 桩/ ./ 下面/ 给出/ 具体/ 的/ 定义/ ./ 定义/ 1/ ./ 测试/ 桩/ ./ 如果/ 类/ C1/ 的/ 一个/ 组件/ 使用/ Page3/ 一个/ 或/ 多个/ 类/ C2/ 的/ 服务/ 组件/ ,/ 称为/ C1/ 依赖/ C2/ ./ 增量/ 集成/ 过程/ 中/ ,/ 当/ C1/ 集成/ 时/ ,/ 但/ C2/ 尚未/ 被/ 集成/ ,/ 我们/ 不得不/ 模拟/ C2/ 的/ 服务/ 组件/ ,/ 这个/ 模拟/ 组件/ 通常/ 被/ 称为/ 一个/ 测试/ 桩/ ./ 一个/ 测试/ 桩/ 并/ 不是/ 真正/ 的/ 对象/ ,/ 但是/ 能够/ 为待测/ 对象/ 提供/ 感兴趣/ 的/ 数据/ 或/ 状态/ ,/ 这样/ ,/ 待测/ 对象/ 便/ 能够/ 顺利/ 使用/ 依赖/ 对象/ ,/ 或者/ 模拟/ 事件/ ./ 定义/ 2/ ./ 代价/ 函数/ ./ 计算/ 强/ 连通/ 分量/ 中/ 构成/ 环路/ 的/ 每/ 条边/ 的/ 源类/ 创建/ 的/ 测试/ 桩/ 复杂度/ 的/ 度量/ 函数/ ./ 由于/ 测试/ 桩/ 模拟/ 的/ 是/ 待测/ 对象/ 所/ 依赖/ 的/ 类/ ,/ 需要/ 像/ 所用/ 到/ 的/ 真实/ 类/ 那样/ 为待测/ 对象/ 提供/ 感兴趣/ 的/ 数据/ 或/ 状态/ ,/ 因此/ 构造/ 一个/ 测试/ 桩/ 的/ 代价/ 是/ 相当/ 大/ 的/ ./ 所以/ 应该/ 尽量避免/ 构造/ 过于/ 复杂/ 类/ 的/ 测试/ 桩/ ./ 创建/ 每个/ 测试/ 桩/ 花费/ 一定/ 的/ 代价/ ,/ 用/ 测试/ 桩/ 的/ 总体/ 复杂度/ 衡量/ 创建/ 所有/ 的/ 测试/ 桩/ 花费/ 的/ 总/ 代价/ ./ 特别/ 地/ ,/ 当/ 在/ 系统/ 中/ 组件/ 之间/ 的/ 依赖/ 关系/ 不/ 产生/ 环路/ 时/ 不/ 需要/ 创建/ 测试/ 桩/ ./ 当/ 创建/ 每/ 一个/ 测试/ 桩/ 花费/ 的/ 代价/ 相同/ ,/ 最小化/ 测试/ 桩/ 的/ 复杂度/ 等价/ 于/ 最小化/ 测试/ 桩/ 的/ 数量/ ./ 2.2/ 耦合/ 度量/ 方法/ 我们/ 的/ 目标/ 是/ 确定/ 一个/ 测试/ 顺序/ ,/ 使/ 它/ 满足/ 最小化/ 测试/ 桩/ 的/ 总体/ 复杂度/ ./ 通过/ 删除/ 满足/ 该/ 条件/ 的/ 边/ 集来/ 打破/ 类图/ 中/ 的/ 环路/ ,/ 进而/ 通过/ 逆向/ 拓扑/ 排序/ 找到/ 一个/ 最佳/ 的/ 集成/ 测试/ 顺序/ ./ Briand/ 等/ 人/ [/ 8/ ]/ 的/ 耦合/ 度量/ 方法/ 虽然/ 不/ 允许/ 删除/ 继承/ 关系/ 、/ 组合/ 关系/ 和/ 聚集/ 关系/ 这/ 3/ 类强/ 联系/ 关系/ ,/ 减少/ 了/ 构建/ 测试/ 桩/ 的/ 复杂度/ ,/ 但是/ 他们/ 为/ 属性/ 和/ 方法/ 分配/ 相同/ 的/ 权值/ ,/ 这是/ 一种/ 特殊/ 的/ 情况/ ,/ 存在/ 着/ 局限性/ ;/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 为/ 属性/ 和/ 方法/ 重新分配/ 了/ 权值/ ,/ 但是/ 他们/ 的/ 度量/ 方法/ 中/ 不仅/ 考虑/ 边/ 的/ 权重/ ,/ 而且/ 增加/ 了/ 节点/ 权重/ ,/ 增加/ 了/ 算法/ 的/ 复杂度/ ,/ 提高/ 了/ 测试/ 成本/ ,/ 因此/ ,/ 为了/ 实现/ 测试/ 桩/ 的/ 复杂度/ 的/ 精确度/ 量/ ,/ 减少/ 测试/ 成本/ ,/ 我们/ 提出/ 一种/ 新/ 的/ 耦合/ 度量/ 方法/ ./ 耦合/ 是/ 指/ 两个/ 类/ 相互依赖/ 的/ 一个/ 量度/ ,/ 根据/ 面向对象/ 语言/ 中类/ 间/ 的/ 5/ 种/ 关系/ ,/ 对应/ 5/ 种/ 耦合/ 类型/ :/ 继承/ 耦合/ 、/ 组合/ 耦合/ 、/ 聚集/ 耦合/ 、/ 关联/ 耦合/ 、/ 使用/ 耦合/ ./ 对于/ 每/ 一种/ 耦合/ 类型/ ,/ 类间/ 耦合/ 信息/ 大都/ 包含/ 4/ 部分/ [/ 1/ ]/ :/ (/ 1/ )/ 被/ 访问/ 的/ 属性/ 的/ 个数/ ;/ (/ 2/ )/ 被/ 调用/ 的/ 不同/ 方法/ 的/ 个数/ (/ 包括/ 构造函数/ )/ ;/ (/ 3/ )/ 返回/ 类型/ 的/ 个数/ ;/ (/ 4/ )/ 传递/ 的/ 参数/ 的/ 个数/ ./ 我们/ 依据/ 这/ 4/ 个/ 参数/ 来/ 衡量/ 服务/ 类/ 和/ 客户/ 类/ 之间/ 的/ 依赖/ 关系/ ./ 为/ 简单/ 起/ 见/ ,/ 用/ 符号/ “/ ·/ ”/ 将/ 耦合/ 度量/ 的/ 4/ 个/ 参数/ 集成/ 到/ 一个/ 表达式/ ,/ 用/ 它/ 来/ 表达/ 两个/ 类/ Ci/ 和/ Ci/ 之间/ 的/ 耦合/ 度量/ ./ 式/ (/ 1/ )/ 用于/ 表示/ 两个/ 类/ Ci/ 和/ Cj/ 之间/ 的/ 耦合/ 度量/ (/ CM/ )/ ./ 其中/ ,/ Ci/ 和/ Cj/ 代表/ 耦合/ 的/ 两个/ 类/ ,/ V/ 代表/ 类/ Ci/ 直接/ 使用/ 的/ 类/ Cj/ 的/ 公有/ 变量/ 的/ 个数/ ,/ M/ 代表/ 类/ Ci/ 调用/ 的/ 类/ Cj/ 中/ 方法/ 的/ 个数/ ,/ R/ 代表/ 在/ M/ 中/ 出现/ 的/ 不同/ 返回/ 类型/ 个数/ ,/ P/ 代表/ 在/ M/ 中/ 出现/ 的/ 不同/ 参数/ 个数/ ./ 2.3/ 估算/ 测试/ 桩/ 复杂度/ 为/ 犆/ 狆/ 犾/ 狓/ (/ )/ ./ 我们/ 可以/ 将/ 其/ 标准化/ 形式/ 为式/ (/ 2/ )/ ./ 对于/ 一个/ 复杂度/ 犆/ 狆/ 犾/ 狓/ (/ )/ ,/ 其/ 标准化/ 估算/ 方法/ 记/ 其中/ ,/ 犆/ 狆/ 犾/ 狓/ (/ i/ ,/ j/ )/ 表示/ 测试/ 桩/ 复杂度/ 信息/ 矩阵/ ,/ 其中/ 行和列/ 分别/ 表示/ 每个/ 类/ 以及/ 类/ i/ 对类/ j/ 的/ 依赖/ ,/ 犆/ 狆/ 犾/ 狓/ min/ =/ Min/ {/ 犆/ 狆/ 犾/ 狓/ (/ i/ ,/ j/ )/ ,/ i/ ,/ j/ =/ 1/ ,/ 2/ ,/ …/ }/ ,/ 犆/ 狆/ 犾/ 狓/ max/ =/ Max/ {/ 犆/ 狆/ 犾/ 狓/ (/ i/ ,/ j/ )/ ,/ i/ ,/ j/ =/ 1/ ,/ 2/ ,/ …/ }/ ./ 如式/ (/ 1/ )/ 所示/ ,/ 在/ 计算/ 测试/ 桩/ 的/ 复杂度/ 时/ ,/ 耦合/ 度量/ 方法/ 中/ 使用/ 4/ 个/ 耦合/ 方法/ V/ (/ )/ 、/ M/ (/ )/ 、/ R/ (/ )/ 和/ P/ (/ )/ ,/ 其中/ V/ (/ )/ 代表/ 调用/ 的/ 变量/ 的/ 个数/ ,/ M/ (/ )/ 代表/ 调用/ 的/ 方法/ 的/ 个数/ ,/ R/ (/ )/ 代表/ 返回/ 类型/ 的/ 个数/ ,/ P/ (/ )/ 代表/ 传递/ 的/ 参数/ 的/ 个数/ ,/ 即/ 一个/ 测试/ 桩/ 的/ 复杂度/ 的/ 估算/ 方法/ 如下/ [/ 8/ ]/ :/ SCplx/ (/ i/ ,/ j/ )/ =/ (/ WV/ ×/ V/ (/ i/ ,/ j/ )/ 2/ +/ WM/ ×/ M/ (/ i/ ,/ j/ )/ 2/ +/ WR/ ×/ R/ (/ i/ ,/ j/ )/ 2/ +/ WP/ ×/ P/ (/ i/ ,/ j/ )/ 2/ )/ 1/ // 2/ (/ 3/ )/ 其中/ ,/ WV/ ,/ WM/ ,/ WR/ 和/ WP/ 表示/ 权重/ ,/ 并且/ WV/ +/ WM/ +/ WR/ +/ WP/ =/ 1/ ./ V/ (/ i/ ,/ j/ )/ ,/ M/ (/ i/ ,/ j/ )/ 分别/ 根据/ 式/ (/ 4/ )/ ,/ (/ 5/ )/ 进行/ 计算/ ,/ R/ (/ i/ ,/ j/ )/ 和/ P/ (/ i/ ,/ j/ )/ 分别/ 根据/ 式/ (/ 6/ )/ 和/ (/ 7/ )/ 进行/ 计算/ ./ 其中/ 式/ (/ 4/ )/ ~/ (/ 7/ )/ 的/ 形式/ 如下/ 所示/ ./ 其中/ ,/ V/ (/ i/ ,/ j/ )/ 、/ M/ (/ i/ ,/ j/ )/ 、/ R/ (/ i/ ,/ j/ )/ 和/ P/ (/ i/ ,/ j/ )/ 的/ 值/ 通过/ 开源/ 工具/ SOOT/ ①/ 统计/ 获得/ ./ Vmax/ 、/ Vmin/ ,/ Mmax/ 、/ Mmin/ ,/ Rmax/ 、/ Rmin/ 和/ Pmax/ 、/ Pmin/ 分别/ 表示/ 统计数据/ 构成/ 的/ 属性/ 耦合/ 矩阵/ 、/ 方法/ 耦合/ 矩阵/ 、/ 返回值/ 耦合/ 矩阵/ 、/ 参数/ 耦合/ 矩阵/ 中/ 的/ 最大/ 最小值/ ./ 对于/ 式/ (/ 3/ )/ 中/ 的/ 权重/ WV/ 、/ WM/ 、/ WR/ 和/ WP/ ,/ 我们/ ①/ SOOT/ ./ AJavabytecodeoptimizationframework/ ./ http/ :/ // // Page4/ 给出/ 一种/ 计算方法/ :/ 对于/ 给定/ 的/ 测试/ 顺序/ o/ ,/ 打破/ d/ 条/ 依赖边/ ,/ 则/ 该/ 测试/ 序/ 的/ 总体/ 测试/ 桩/ 的/ 复杂度/ 的/ 计算公式/ 如下/ :/ 3/ 类间/ 测试/ 顺序/ 的/ 确定/ 算法/ 对于/ 面向对象/ 软件/ 集成/ 测试/ 顺序/ 问题/ ,/ 我们/ 利用/ Tarjan/ 等/ 人/ 的/ 算法/ [/ 9/ ]/ 识别/ 出类/ 图/ 中由类/ 以及/ 它们/ 之间/ 的/ 依赖/ 关系/ 形成/ 的/ 强/ 连通/ 分量/ ,/ 通过/ 删除/ 那些/ 至少/ 能够/ 构成/ 一个/ 强/ 连通/ 分量/ 的/ 依赖边/ ,/ 利用/ 基于/ 图/ 的/ 启发式/ 算法/ 打破/ 环路/ ./ 3.1/ 打破/ 环路/ 的/ 启发式/ 算法/ 确定/ 类间/ 测试/ 序/ 的/ 主要/ 问题/ 就是/ 打破/ 环路/ ./ Briand/ 等/ 人/ [/ 8/ ]/ 解决/ 打破/ 环路/ 问题/ 时/ ,/ 采用/ 的/ 是/ 遗传算法/ ,/ 不仅/ 要/ 精心/ 设置/ 参数/ ,/ 而且/ 算法/ 需要/ 被/ 执行/ 多次/ ,/ 而/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 综合/ 考虑/ 边/ 的/ 权重/ 、/ 节点/ 权重/ 以及/ 环路/ 的/ 个数/ 来/ 选择/ 边/ 进行/ 删除/ 进而/ 打破/ 环路/ ,/ 增加/ 了/ 算法/ 的/ 复杂度/ ,/ 提高/ 了/ 测试/ 成本/ ./ 因此/ ,/ 本文/ 针对/ 该/ 问题/ 给出/ 了/ 一种/ 新/ 的/ 打破/ 环图/ 1SCC/ 中以/ 8/ 为根/ 节点/ 的/ 环路/ 查找/ 树/ 然后/ 对/ 查找/ 树/ 进行/ 前序/ 遍历/ ,/ 进而/ 找出/ 所有/ 的/ 环路/ ,/ 最后/ 得到/ SCC/ 中/ 的/ 环路/ 个数/ 、/ 各个/ 环路/ 的/ 路径/ 、/ SCC/ 中/ 各边/ 涉及/ 的/ 环路/ 个数/ ./ 本文/ 所/ 采用/ 的/ 环路/ 消除/ 算法/ 如/ 算法/ 1/ 所示/ ./ 算法/ 1/ ./ EliminateloopsforSCCi/ ./ 输入/ :/ SCCi/ 输出/ :/ 环路/ 路径/ 路/ 的/ 方法/ ,/ 把/ 有/ 向/ 边/ 的/ 权重/ 以及/ 使用/ 相应/ 有/ 向/ 边/ 的/ 环路/ 数目/ 作为/ 打破/ 环路/ 的/ 主要/ 依据/ ,/ 其中/ 把/ 测试/ 桩/ 的/ 复杂度/ 作为/ 有/ 向/ 边/ 的/ 权重/ ./ 针对/ 确定/ 使用/ 有/ 向/ 边/ 的/ 环路/ 数目/ 的/ 问题/ ,/ 我们/ 提出/ 了/ 一种/ “/ 查找/ 树/ ”/ 的/ 方法/ 来/ 查找/ SCCs/ 中/ 所有/ 的/ 环路/ ./ 首先/ 分别/ 将/ SCCs/ 中/ 包含/ 的/ 每/ 一个/ 子强/ 连通/ 分量/ SCCi/ 中/ 所有/ 边以/ 树/ 的/ 形式/ 组织/ 在/ 一起/ ,/ 规则/ 是/ 将/ 由类/ 编号/ 从小到大/ 表示/ 的/ 各个/ 类/ 依次/ 作为/ 根/ 节点/ ,/ SCCi/ 中/ 包含/ 的/ 边/ 作为/ 分支/ 进行/ 构造/ ,/ 每/ 选择/ 一个/ 不同/ 的/ 根/ 节点/ 时/ 构造/ 一棵/ 不同/ 的/ 查找/ 树/ ,/ 构造/ 一棵/ 查找/ 树时/ 在/ 一条/ 路径/ 中/ 避免/ 重复/ 的/ 节点/ ,/ 最后/ 以/ 与/ 根/ 节点/ 相同/ 的/ 节点/ 作为/ 叶子/ 节点/ ,/ 直到/ SCCi/ 中/ 的/ 边/ 不能/ 满足/ 树中/ 叶子/ 节点/ 与/ 根/ 节点/ 相同/ 为止/ ;/ 然后/ 对/ 这些/ 查找/ 树/ 进行/ 前序/ 遍历/ ,/ 去掉/ 重复/ 的/ 路径/ ,/ 最后/ 得到/ SCCi/ 中/ 的/ 环路/ 数目/ 及/ 所有/ 环路/ 及/ 路径/ 、/ SCCi/ 中/ 各边/ 涉及/ 的/ 环路/ 的/ 数目/ ./ 例如/ ,/ 以/ 在/ 第/ 5/ 节中/ 实例/ 分析/ 将要/ 使用/ 的/ ATM/ 系统/ 为例/ ,/ 该/ 实例/ 是/ Abdurazik/ 等/ 人/ 在/ 文献/ [/ 1/ ]/ 以及/ Briand/ 等/ 人/ 在/ 文献/ [/ 8/ ]/ 中/ 所/ 使用/ 的/ ATM/ 系统/ ./ 该/ 系统/ 包含/ 一个/ 强/ 连通/ 分量/ SCC/ {/ 8/ ,/ 9/ ,/ …/ ,/ 15/ }/ ,/ 该/ SCC/ 包含/ 的/ 所有/ 的/ 边/ 如表/ 4/ 第/ 2/ 列/ (/ 由于/ 篇幅/ 所/ 限/ ,/ 在/ 这/ 不/ 单独/ 列出/ )/ 所示/ ./ 构造/ 查找/ 树时/ 首先/ 选择/ SCC/ {/ 8/ ,/ 9/ ,/ …/ ,/ 15/ }/ 中类/ 节点/ 编号/ 最小/ 的/ 8/ 作为/ 根/ 节点/ 进行/ 构造/ ,/ 同理/ 依次/ 选择/ 9/ ,/ 10/ ,/ 11/ ,/ …/ ,/ 15/ 分别/ 作为/ 根/ 节点/ 进行/ 构造/ ./ 以/ 8/ 作为/ 根/ 节点/ 为例/ 所/ 构造/ 的/ 查找/ 树如图/ 1/ 所示/ ./ Begin1/ ./ findallSCCsinclassgraph/ ;/ 2/ ./ for/ (/ eachscci/ (/ Vscci/ ;/ Escci/ )/ ∈/ SCCs/ )/ do3/ ./ searchloops/ (/ …/ )/ ;/ // // 找出/ 所有/ 的/ 环路/ 4/ ./ for/ (/ eachassociationoruseedgee/ ∈/ Escci/ )/ do5/ ./ findthenumberofloopsthatuseedgee/ ;/ Page56/ ./ viewtheSCplxasedgeweightsinSCCs/ ;/ 7/ ./ calculateloop/ -/ weightratio/ ;/ 8/ ./ endfor9/ ./ while/ (/ totalLoop/ !/ =/ 0/ )/ do10/ ./ removetheedgewithhighestloop/ -/ weightratio/ ;/ 11/ ./ totalLoop/ =/ totalLoop/ -/ numberofloopsbroken/ ;/ 12/ ./ modifythenumberofloopsforremainingedge/ ;/ // // 修改/ 使用/ 剩余/ 的/ 边/ 集中/ 的/ 边/ e/ 的/ 环路/ 的/ 数目/ 13/ ./ recalculatetheloop/ -/ weightratioforremainingedge/ ;/ 14/ ./ ifassociationoruseedgeewiththesameloop/ -/ 15/ ./ thenremovetheewithmoreloops/ ;/ 16/ ./ ifthenumberofbrokenloopssame/ ;/ 17/ ./ thenremoveanyedge/ ;/ 18/ ./ endif19/ ./ endif20/ ./ endwhile21/ ./ endforEnd/ 我们/ 的/ 启发式/ 算法/ 的/ 基本/ 思想/ 是/ 首先/ 生成/ 类图/ 中/ 所有/ 的/ SCCs/ (/ 行/ 1/ )/ ,/ 然后/ 针对/ 每/ 一个/ 子/ SCCi/ ,/ 打破/ 其中/ 的/ 环路/ (/ 行/ 2/ ~/ 20/ )/ ./ 在/ 打破/ 环路/ 的/ 过程/ 中/ 首先/ 删除/ 环路/ -/ 权重/ 比/ 最高/ 的/ 关联/ 边/ 或/ 使用/ 边/ (/ 行/ 2/ ~/ 10/ )/ (/ Briand/ 等/ 人/ [/ 8/ ]/ 、/ Kung/ 等/ 人/ [/ 10/ ]/ 、/ Kraft/ 等/ 人/ [/ 11/ ]/ 都/ 认为/ 给/ 不同/ 类型/ 的/ 边/ 创建/ 测试/ 桩/ 的/ 难易/ 程度/ 的/ 高低/ 和/ 代价/ Cost/ (/ C/ )/ 均/ 存在/ 如下/ 关系/ :/ C/ (/ 关联/ 边/ )/ =/ C/ (/ 使用/ 边/ )/ </ C/ (/ 聚集/ 边/ )/ / C/ (/ 继承/ 边/ )/ ./ 因此/ ,/ 称/ 继承/ 关系/ 和/ 聚集/ 关系/ 为强/ 联系/ 关系/ ,/ 使用/ 关系/ 与/ 关联/ 关系/ 均/ 为/ 弱/ 联系/ 关系/ ./ 为了/ 减少/ 测试/ 代价/ ,/ 本文/ 消除/ 环路/ 时/ 避免/ 删除/ 强/ 联系/ 边/ )/ ,/ 当有/ 多条/ 环路/ -/ 权重/ 比/ 相同/ 的/ 关联/ 边/ 或/ 使用/ 边/ ,/ 则/ 删除/ 使得/ 打破/ 环路/ 个数/ 多/ 的/ 那条/ 关联/ 边/ 或/ 使用/ 边/ (/ 行/ 14/ ~/ 15/ )/ ,/ 如/ 使得/ 打破/ 的/ 环路/ 个数/ 相同/ ,/ 删除/ 其中/ 的/ 任意/ 一条/ 边/ (/ 行/ 16/ ~/ 17/ )/ ./ 3.2/ 确定/ 类间/ 测试/ 顺序/ 的/ 算法/ 我们/ 的/ 目标/ 是/ 确定/ 一个/ 测试/ 顺序/ ,/ 使/ 它/ 满足/ 测试/ 桩/ 的/ 总体/ 复杂度/ 最小/ ./ 在/ 类间/ 关系/ 构成/ 环路/ 的/ 情况/ 下/ ,/ 需要/ 根据/ 耦合/ 度量/ 的/ 测试/ 桩/ 复杂度/ ,/ 再/ 结合/ 环路/ 消除/ 算法/ 来/ 打破/ 环路/ ,/ 进一步/ 确定/ 类/ 测试/ 顺序/ ./ 而类/ 测试/ 顺序/ 由类/ 的/ 测试/ 依赖性/ 决定/ [/ 12/ ]/ ./ 测试/ 依赖性/ 表示/ 一个/ 类/ 依赖于/ 其它/ 类/ 的/ 程度/ ./ 为了/ 确定/ 类/ 测试/ 顺序/ ,/ 本文/ 从类/ 测试/ 依赖性/ 入手/ ,/ 提出/ 两个/ 测试/ 依赖性/ 定理/ 作为/ 确定/ 类/ 测试/ 顺序/ 的/ 依据/ ./ 定理/ 1/ ./ 当类/ A/ 是/ 类/ B/ 的/ 一个/ 子类/ ,/ 或者/ 类/ A/ 是/ 类/ B/ 的/ 一个/ 聚合/ 类/ ,/ 或者/ 类/ A/ 是/ 类/ B/ 的/ 一个/ 关联/ 类/ ,/ 则/ 在/ 集成/ 测试/ 时/ ,/ 类/ A/ 依赖于/ 类/ B/ ,/ 类/ A/ 在/ 类/ B/ 之后/ 进行/ 测试/ ./ 证明/ ./ 类/ A/ 继承/ 于类/ B/ 时/ ,/ 类/ A/ 会/ 继承/ 类/ B/ 的/ 部分/ 属性/ ,/ 从而/ 类/ A/ 依赖于/ 类/ B/ ./ 若类/ B/ 中/ 被/ 类/ A/ 继承/ 的/ 成员/ 发生变化/ ,/ 或/ 被/ 类/ A/ 继承/ 的/ 成员/ 有/ 直接/ 或/ 间接/ 影响/ 的/ 成员/ 发生变化/ 时/ ,/ 将会/ 影响/ 类/ A/ 的/ 行为/ ./ 当类/ A/ 是/ 类/ B/ 的/ 一个/ 聚合/ 类/ ,/ 由于/ 聚合/ 是/ 整体/ 和/ 个体/ 的/ 关系/ ,/ 即/ 若干个/ 类/ B/ 聚合/ 成/ 一个/ 类/ A/ ,/ 则/ 类/ B/ 的/ 改变/ 必然/ 会/ 影响/ 类/ A/ ,/ 因此/ 类/ A/ 依赖于/ 类/ B/ ./ 当类/ A/ 是/ 类/ B/ 的/ 一个/ 关联/ 类/ ,/ 则/ 类/ A/ 能够/ 访问/ 类/ B/ 的/ 数据/ 成员/ ,/ 或者/ 类/ A/ 传递/ 一个/ 消息/ 到/ 类/ B/ ./ 因此/ ,/ 如果/ 类/ B/ 的/ 数据/ 成员/ 发生变化/ ,/ 或者/ 当类/ B/ 接收/ 类/ A/ 发送/ 的/ 消息/ ,/ 并且/ 类/ B/ 的/ 成员/ 函数/ 发生变化/ ,/ 则/ 类/ B/ 对/ 消息/ 的/ 响应/ 会/ 有/ 变化/ ,/ 返回/ 给/ 类/ A/ 的/ 结果/ 也/ 会/ 发生变化/ ./ 因此/ ,/ 类/ A/ 依赖于/ 类/ B/ ./ 因此/ ,/ 类/ A/ 在/ 类/ B/ 之后/ 进行/ 测试/ ./ 得出/ 定理/ 1/ 的/ 结论/ ./ 定理/ 2/ ./ 假设/ 3/ 个类/ A/ 、/ B/ 、/ C/ ,/ 当/ A/ 是/ B/ 的/ 一个/ 子类/ ,/ B/ 是/ C/ 的/ 一个/ 服务/ 类/ ,/ 即/ C/ 关联/ 于/ B/ (/ 或者/ 依赖于/ B/ )/ 或者/ C/ 是/ B/ 的/ 一个/ 聚合/ 类/ ,/ 并且/ 当/ C/ 不是/ A/ 的/ 聚合/ 类时/ ,/ 则/ 在/ 集成/ 测试/ 时/ ,/ C/ 依赖于/ B/ ,/ 在/ 不/ 考虑/ 多态性/ 的/ 情况/ 下/ ,/ C/ 在/ B/ 之后/ 测试/ ,/ A/ ,/ C/ 的/ 顺序/ 任意/ ,/ 即/ B/ ,/ C/ ,/ A/ 或者/ B/ ,/ A/ ,/ C/ ./ 证明/ ./ A/ 是/ B/ 的/ 一个/ 子类/ ,/ B/ 是/ C/ 的/ 一个/ 服务/ 类/ ,/ 由/ 测试/ 依赖性/ 定理/ 1/ 得出/ ,/ A/ 在/ B/ 之后/ 测试/ ,/ C/ 在/ B/ 之后/ 测试/ ./ 对于/ A/ 、/ C/ 的/ 测试/ 依赖性/ 关系/ 有/ 如下/ 情况/ :/ (/ 1/ )/ 若/ C/ 关联/ 于/ B/ (/ 或者/ 依赖于/ B/ )/ ./ 如果/ C/ 需要/ 访问/ B/ 中/ 的/ 某个/ 数据/ 成员/ ,/ 而/ A/ 继承/ B/ 的/ 该/ 数据/ 成员/ ./ 由于/ 我们/ 没有/ 考虑/ 多态性/ ,/ C/ 不会/ 访问/ A/ 中/ 的/ 数据/ 成员/ ,/ 则/ C/ 不/ 依赖于/ A/ ./ 如果/ C/ 需要/ 访问/ B/ 中/ 的/ 某个/ 数据/ 成员/ ,/ 而/ A/ 没有/ 继承/ B/ 的/ 该/ 数据/ 成员/ ./ 尽管/ A/ 继承/ B/ ,/ 但/ C/ 不会/ 访问/ A/ 中/ 的/ 数据/ 成员/ ,/ 则/ C/ 不/ 依赖于/ A/ ./ 但/ 由于/ 从/ A/ 到/ C/ 之间/ 没有/ 任何/ 依赖/ 关系/ ,/ 因此/ ,/ A/ 也/ 不/ 依赖于/ C/ ./ Page6/ (/ 2/ )/ 若/ C/ 是/ B/ 的/ 一个/ 聚合/ 类/ ,/ 由于/ A/ 是/ B/ 的/ 子类/ ,/ 而/ C/ 是/ B/ 的/ 聚合/ 类/ ,/ 当/ C/ 不是/ A/ 的/ 聚合/ 类时/ ,/ C/ 不/ 依赖于/ A/ ,/ A/ 也/ 不/ 依赖于/ C/ ./ 由/ 上述/ 分析/ 得出/ ,/ 则/ 在/ 集成/ 测试/ 时/ ,/ C/ 依赖于/ B/ ,/ 在/ 不/ 考虑/ 多态性/ 的/ 情况/ 下/ ,/ C/ 在/ B/ 之后/ 测试/ ,/ 由于/ 从/ A/ 到/ C/ 之间/ 没有/ 任何/ 依赖/ 关系/ ,/ 则/ A/ ,/ C/ 的/ 顺序/ 任意/ ,/ 即/ B/ ,/ C/ ,/ A/ 或者/ B/ ,/ A/ ,/ C/ ./ 得出/ 定理/ 2/ 的/ 结论/ ./ 确定/ 类/ 测试/ 顺序/ 的/ 算法/ 如/ 算法/ 2/ 所示/ ./ 算法/ 2/ ./ ClassIntegrationTestOrder/ ./ 输入/ :/ classcluster/ 输出/ :/ classintegrationtestorderBegin1/ ./ Gen/ _/ classgraphprecedencetable/ (/ )/ ;/ 2/ ./ SearchSCCs/ ;/ // // 找出/ 所有/ 的/ SCCs3/ ./ vieweachSCCiasonenode/ ,/ maketheclassgraph4/ ./ foreachacyclicgraphdo/ // // 简化/ 后/ 的/ 无/ 环图/ 5/ ./ FindReverse/ (/ )/ ;/ // // 找到/ 它/ 的/ 逆向/ 拓扑/ 排序/ 6/ ./ foreachSCCi/ ∈/ SCCsdo7/ ./ EliminateloopsforSCCi/ ;/ 8/ ./ GetAllNodeReverse/ (/ SCCi/ )/ ;/ 9/ ./ endfor10/ ./ endfor11/ ./ outputclassintegrationtestorder/ ;/ End/ 在/ 该/ 算法/ 中/ ,/ 首先/ 产生/ 类图/ 的/ 优先级/ 表/ (/ 行/ 1/ )/ ,/ 并/ 找出/ 所有/ 的/ SCCs/ (/ 行/ 2/ )/ ,/ 然后/ 把/ 每/ 一个/ 子/ SCCi/ 看成/ 一个/ 节点/ ,/ 使得/ 整个/ 类图/ 成为/ 无环图/ (/ 行/ 3/ )/ ,/ 对于/ 简化/ 后/ 的/ 无/ 环图/ ,/ 找到/ 它/ 的/ 逆向/ 拓扑/ 排序/ (/ 行/ 4/ ~/ 5/ )/ ;/ 接下来/ 对于/ 每/ 一个/ 子/ SCCi/ ,/ 根据/ 算法/ 1/ 消除/ SCCi/ 的/ 环路/ ,/ 得到/ SCCi/ 中/ 所有/ 节点/ 的/ 逆向/ 拓扑/ 排序/ (/ 行/ 6/ ~/ 8/ )/ ;/ 最后/ ,/ 对/ 无/ 环图/ 进行/ 逆向/ 拓扑/ 排序/ 进而/ 得到/ 所有/ 类/ 集成/ 测试/ 序列/ (/ 行/ 11/ )/ ./ 3.3/ 类间/ 测试/ 顺序/ 生成/ 工具/ 我们/ 根据上述/ 类间/ 测试/ 顺序/ 确定/ 算法/ 设计/ 并/ 实现/ 了/ 一个/ 工具/ —/ —/ —/ TOGOS/ (/ TestOrderGeneratorforObject/ -/ OrientedSystem/ )/ ,/ 其/ 系统结构/ 如图/ 2/ 所示/ ./ 该/ 工具/ 的/ 输入/ 信息/ 是/ 一个/ 描述/ 面向对象/ 系统/ 中类/ 间/ 关系/ 的/ 三元组/ 列表/ ,/ 其中/ 的/ 三元组/ 列表/ 可以/ 由/ 面向对象/ 系统/ 的/ UML/ 设计/ 文档/ 中/ 的/ 类图/ 获得/ ./ 1/ )/ 环路/ 生成/ 模块/ ./ 如图/ 2/ 中虚/ 线框/ 所示/ ./ 按照/ 3.1/ 节中/ 环路/ 查找/ 方法/ 该/ 模块/ 可以/ 生成/ 所有/ 环路/ ./ 2/ )/ 环路/ 消除/ 模块/ ./ 根据/ 输入/ 的/ 关系/ 三元组/ 描述/ 信息/ 所/ 表示/ 的/ 类图/ ,/ 采用/ Tarjan/ 等/ 人/ [/ 9/ ]/ 的/ 算法/ ,/ 依次/ 找出/ 该类/ 图中/ 的/ SCCi/ ,/ 按照/ 3.1/ 节中/ 的/ 算法/ 1/ ,/ 通过/ 断开/ 一条/ 或/ 多条/ 关联/ 边/ (/ 或者/ 使用/ 边/ )/ ,/ 将/ 每/ 一个/ 子/ SCCi/ 的/ 环路/ 断开/ ,/ 直到/ 类图/ 中/ 所有/ 的/ 环路/ 消除/ 为止/ ,/ 以/ 得到/ 新/ 的/ 无/ 环类/ 图/ ./ 3/ )/ 测试/ 顺序/ 生成/ 模块/ :/ 按照/ 3.2/ 节中/ 的/ 算法/ 2/ ,/ 对/ 无/ 环图/ 进行/ 逆向/ 拓扑/ 排序/ 输出/ 类/ 集成/ 测试/ 序列/ ./ TOGOS/ 能够/ 自动/ 生成/ 一个/ 面向对象/ 系统/ 中/ 的/ 类/ 集成/ 测试/ 序列/ ,/ 可/ 减少/ 测试/ 的/ 工作量/ ./ 4/ 实验/ 在/ 这/ 一节/ 中/ ,/ 我们/ 通过/ 一组/ 基准/ 程序/ 来/ 进行/ 实验/ ,/ 以/ 验证/ 本文/ 方法/ 的/ 有效性/ ./ 4.1/ 实验/ 描述/ 和/ 过程/ 在/ 实验/ 中/ ,/ 我们/ 采用/ 了/ 3/ 个/ 系统/ :/ (/ 1/ )/ 自动/ 取款机/ (/ ATM/ )/ 模拟系统/ ;/ (/ 2/ )/ ANT/ 系统/ ;/ (/ 3/ )/ DNS/ 系统/ ./ 其中/ ,/ ATM/ 系统/ 在/ 许多/ 软件测试/ 研究/ 中/ 被/ 作为/ 一个/ 基准/ 程序/ 来/ 使用/ ,/ 它/ 包含/ 了/ 21/ 个类/ (/ 忽略/ 了/ 与/ 硬件/ 设备/ 相连/ 的/ 类/ )/ ,/ 67/ 条/ 依赖边/ 和/ 大量/ 的/ 依赖/ 环路/ ,/ Page7/ 其中/ ,/ 8/ 个类/ 构成/ 一个/ 包含/ 30/ 个/ 环路/ 的/ SCC/ [/ 1/ ,/ 8/ ]/ ./ ANT/ 系统/ —/ —/ —/ jakarta/ 项目/ V1/ ./ 4/ 版本/ 的/ 一部分/ (/ http/ :/ // // jakarta/ ./ apache/ ./ org/ )/ ./ 实验/ 分析/ 其中/ 构成/ 大量/ 环路/ 的/ 25/ 个类/ ,/ 其中/ ,/ 这/ 25/ 个类/ 之间/ 存在/ 83/ 条/ 依赖边/ ,/ 构成/ 654/ 个/ 依赖/ 环路/ [/ 8/ ]/ ./ DNS/ 系统/ (/ http/ :/ // // www/ ./ xbill/ ./ org/ // dnsjava/ // )/ 可以/ 提供/ 网络/ 域名服务/ ,/ 包含/ 61/ 个类/ 、/ 276/ 条/ 依赖边/ ,/ 其中/ ,/ 10/ 个类/ 构成/ 16/ 个/ 环路/ [/ 8/ ]/ ./ 这/ 3/ 个/ 系统/ 的/ 类图/ 及其/ 它/ 详细信息/ 可以/ 参照/ Briand/ 等/ 人/ 的/ 文献/ [/ 8/ ]/ ./ SOOT/ [/ 9/ ]/ 是/ 一个/ 能/ 准确/ 分析/ Java/ 字节/ 码/ 的/ 开源/ 工具/ ,/ 可以/ 提供/ 基本/ 的/ 程序/ 分析/ 功能/ ,/ 例如/ ,/ 类间/ 调用/ 分析/ ./ 为了/ 统计/ 公式/ (/ 1/ )/ 中/ 4/ 个/ 参数/ 的/ 值/ ,/ 我们/ 首先/ 通过/ SOOT/ 得到/ 类间/ 调用/ 图/ ,/ 再/ 对/ 该/ 调用/ 图/ 进行/ 遍历/ ,/ 分析/ 类间/ 的/ 调用/ 关系/ ,/ 进一步/ 得到/ 目标/ 数据/ ./ 4.1/ ./ 1ATM/ 系统/ 为了/ 说明/ TOGOS/ 工具/ 的/ 工作/ 原理/ ,/ 我们/ 给出/ 类/ 编号/ 811/ 表/ 2/ 犛/ 犆/ 犆/ {/ 8/ ,/ 9/ ,/ 10/ ,/ 11/ ,/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ }/ 各边/ 的/ 犆/ 犕/ 值/ 890.7/ ./ 1.3100/ ./ 7.4/ ./ 40.2/ ./ 1.1110/ ./ 2.1/ ./ 30.1/ ./ 0.00/ ./ 2.1/ ./ 0120.4/ ./ 3.110/ ./ 4.3/ ./ 110.2/ ./ 2.00/ ./ 0.0/ ./ 0130.4/ ./ 3.60/ ./ 4.3/ ./ 140.2/ ./ 2.00/ ./ 0.0/ ./ 0140.3/ ./ 2.60/ ./ 3.3/ ./ 120.2/ ./ 2.00/ ./ 0.0/ ./ 0150.2/ ./ 1.60/ ./ 3.3/ ./ 100.2/ ./ 2.00/ ./ 0.0/ ./ 0/ 然后/ ,/ TOGOS/ 工具/ 中/ 环路/ 生成/ 模块/ 可以/ 自动/ 生成/ SCC/ {/ 8/ ,/ 9/ ,/ 10/ ,/ 11/ ,/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ }/ 中/ 所/ 包含/ 的/ 30/ 个/ 环路/ ,/ 如表/ 3/ 所示/ ./ 表/ 3/ 犛/ 犆/ 犆/ {/ 8/ ,/ 9/ ,/ 10/ ,/ 11/ ,/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ }/ 中/ 的/ 环路/ 序号/ 18/ →/ 9/ →/ 81610/ →/ 14/ →/ 11/ →/ 1028/ →/ 10/ →/ 81710/ →/ 15/ →/ 11/ →/ 10310/ →/ 11/ →/ 10188/ →/ 10/ →/ 11/ →/ 9/ →/ 8410/ →/ 12/ →/ 10198/ →/ 10/ →/ 12/ →/ 9/ →/ 8510/ →/ 13/ →/ 10208/ →/ 10/ →/ 13/ →/ 9/ →/ 8610/ →/ 14/ →/ 10218/ →/ 10/ →/ 14/ →/ 9/ →/ 8710/ →/ 15/ →/ 10228/ →/ 10/ →/ 15/ →/ 9/ →/ 888/ →/ 10/ →/ 9/ →/ 8238/ →/ 10/ →/ 12/ →/ 11/ →/ 898/ →/ 10/ →/ 11/ →/ 8248/ →/ 10/ →/ 13/ →/ 11/ →/ 8108/ →/ 10/ →/ 12/ →/ 8258/ →/ 10/ →/ 14/ →/ 11/ →/ 8118/ →/ 10/ →/ 13/ →/ 8268/ →/ 10/ →/ 15/ →/ 11/ →/ 8128/ →/ 10/ →/ 14/ →/ 8278/ →/ 10/ →/ 12/ →/ 11/ →/ 9/ →/ 8138/ →/ 10/ →/ 15/ →/ 8288/ →/ 10/ →/ 13/ →/ 11/ →/ 9/ →/ 81410/ →/ 12/ →/ 11/ →/ 10298/ →/ 10/ →/ 14/ →/ 11/ →/ 9/ →/ 81510/ →/ 13/ →/ 11/ →/ 10308/ →/ 10/ →/ 15/ →/ 11/ →/ 9/ →/ 8/ 表/ 4/ 给出/ 的/ 是/ 分别/ 采用/ Briand/ 等/ 人/ [/ 8/ ]/ 、/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 以及/ 本文/ 方法/ 对/ SCC/ {/ 8/ ,/ 9/ ,/ 10/ ,/ 11/ ,/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ }/ 中/ 各边/ 的/ 源类/ 创建/ 的/ 测试/ 桩/ 复杂/ 实验/ 的/ 具体/ 过程/ ./ 首先/ 以/ ATM/ 系统/ 为例/ 进行/ 分析/ ,/ 表/ 1/ 是/ ATM/ 系统/ 中/ 包含/ 的/ 所有/ 类/ ./ 类/ 编号/ 1ReceiptPrinter12WithdrawalTransaction2Display3Keyboard4CardReader5OperatorPanel16GUILayout6EnvelopeAcceptor17QuestionDialog7CashDispenser18ATMMain8ATM9Bank10Session11Transaction/ 首先/ ,/ 以式/ (/ 1/ )/ 的/ 形式/ 所/ 表示/ 的/ ATM/ 系统/ 中强/ 连通/ 分量/ SCC/ {/ 8/ ,/ 9/ ,/ 10/ ,/ 11/ ,/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ }/ 的/ 各条/ 边/ 所/ 对应/ 的/ CM/ 值如表/ 2/ 所示/ ./ 每个/ CM/ 中/ 的/ 4/ 个/ 耦合/ 度量/ 参数值/ 是/ 利用/ SOOT/ 统计/ 获得/ 的/ ./ 度/ 的/ 度量/ 结果/ ,/ 即/ 采用/ 耦合/ 度量/ 的/ 方法/ 得到/ 的/ 测试/ 桩/ 复杂度/ ./ 其中/ ,/ 第/ 1/ 列为/ 构成/ SCC/ 的/ 各个/ 类/ 的/ 编号/ ;/ 第/ 2/ 列为/ 通过/ TOGOS/ 工具/ 统计/ 的/ SCC/ 中/ 各边/ ;/ 第/ 3/ 列为/ 统计/ 的/ SCC/ 中/ 各边/ 涉及/ 的/ 环路/ 个数/ ;/ 第/ 4/ 、/ 5/ 两列/ 分别/ 为/ 采用/ Briand/ 等/ 人/ [/ 8/ ]/ 、/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 构造/ 的/ 测试/ 桩/ 复杂度/ ;/ 最后/ 一列/ 是/ 采用/ 本文/ 方法/ ,/ 使用/ 表/ 2/ 中/ 的/ 值/ ,/ 通过/ 式/ (/ 3/ )/ ~/ (/ 7/ )/ 计算/ 的/ 删除/ SCC/ 各边/ 时为/ 各边/ 的/ 源类/ 构造/ 的/ 测试/ 桩/ 复杂度/ ./ 其中/ ,/ 式/ (/ 3/ )/ 的/ WV/ 、/ WM/ 、/ WR/ 和/ WP/ 的/ 值/ 由式/ (/ 8/ )/ ~/ (/ 11/ )/ 进行/ 计算/ ./ 接下来/ 是/ 环路/ 消除/ 模块/ 所/ 完成/ 的/ 工作/ :/ 把/ 测试/ 桩/ 的/ 复杂度/ 作为/ 边/ 的/ 权值/ ,/ 根据/ 算法/ 2/ 对表/ 4/ 中/ 各边/ 进行/ 环路/ -/ 权重/ 比/ 的/ 简单/ 计算/ ,/ 边/ 8/ →/ 10/ 的/ 环路/ -/ 权重/ 比/ 最高/ ,/ 首先/ 删除/ 该边/ ,/ 可以/ 打破/ 20/ 个/ 环路/ ,/ 剩余/ 10/ 个/ 环路/ ./ 然后/ ,/ 再/ 重新/ 计算/ 表/ 4/ 中/ 剩余/ 各边/ 的/ 环路/ -/ 权重/ 比/ ,/ 经过/ 计算/ ,/ 11/ →/ 10/ 环路/ -/ 权重/ 比/ 最高/ ,/ 删除/ ,/ 可以/ 打破/ 5/ 个/ 环路/ ,/ 剩余/ 5/ 个/ 环路/ ./ 同理/ ,/ 以下/ 依次/ 打破/ 的/ 边/ 为/ 8/ →/ 9/ ,/ 10/ →/ 12/ ,/ 10/ →/ 13/ ,/ 10/ →/ 14/ 和/ 10/ →/ 15/ ,/ 至此/ ,/ 所有/ 的/ 环路/ 都/ 被/ 打破/ ,/ 类图/ 成为/ 无环图/ ./ Page8/ 表/ 4/ 犛/ 犆/ 犆/ {/ 8/ ,/ 9/ ,/ 10/ ,/ 11/ ,/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ }/ 中/ 各边/ 的/ 权值/ 序号/ 边/ 涉及/ 的/ 18/ →/ 910.711/ ./ 000.1428/ →/ 10200.531/ ./ 220.3239/ →/ 8111.001/ ./ 170.89410/ →/ 811.001/ ./ 660.81510/ →/ 910.741/ ./ 130.23610/ →/ 1135.000/ ./ 72710/ →/ 1260.231/ ./ 130.23810/ →/ 1360.231/ ./ 130.23910/ →/ 1460.261/ ./ 130.231010/ →/ 1560.211/ ./ 130.231111/ →/ 850.741/ ./ 170.291211/ →/ 950.711/ ./ 000.141311/ →/ 1050.531/ ./ 130.231412/ →/ 810.811/ ./ 600.961512/ →/ 910.812/ ./ 590.961612/ →/ 1010.532/ ./ 010.281712/ →/ 1135.001813/ →/ 810.811/ ./ 500.591913/ →/ 910.812/ ./ 621.282013/ →/ 1010.532/ ./ 010.282113/ →/ 1135.002214/ →/ 810.771/ ./ 390.532314/ →/ 910.772/ ./ 581.082414/ →/ 1010.532/ ./ 010.282514/ →/ 1135.002615/ →/ 810.741/ ./ 290.572715/ →/ 910.772/ ./ 580.862815/ →/ 1010.532/ ./ 010.282915/ →/ 1135.00/ 最后/ 将/ 本文/ 方法/ 与/ 文献/ [/ 1/ ,/ 8/ ]/ 中/ 已有/ 的/ 两种/ 方法/ 进行/ 了/ 比较/ ./ ATM/ 系统/ 度量/ 结果/ 的/ 比较/ 如表/ 5/ 所示/ ./ 其中/ ,/ 第/ 1/ 列为/ 3/ 种/ 不同/ 的/ 方法/ ;/ 第/ 2/ 列为/ 分别/ 采用/ 这/ 3/ 种/ 不同/ 的/ 方法/ 删除/ 的/ 边/ 的/ 个数/ ;/ 第/ 3/ 列为/ 被/ 删除/ 的/ 各条/ 边/ ;/ 第/ 4/ 列为/ 被/ 删除/ 的/ 各条/ 边/ 的/ 复杂度/ ;/ 第/ 5/ 列为/ 打破/ 环路/ 需要/ 构造/ 的/ 测试/ 桩/ 的/ 总体/ 复杂度/ OCplx/ ;/ 第/ 6/ 列为/ 3/ 种/ 不同/ 的/ 算法/ 需要/ 执行/ 的/ 次数/ ./ 其中/ ,/ 采用/ Briand/ 遗传算法/ 中/ 删除/ 边/ 所在/ 的/ 列为/ 趋于稳定/ 状态/ 时所/ 删除/ 的/ 7/ 条边/ ./ 类/ 编号/ 2410161718192021222324/ 表/ 7/ 犛/ 犆/ 犆/ {/ 2/ ,/ 4/ ,/ 10/ ,/ 16/ ,/ 17/ ,/ 18/ ,/ 19/ ,/ 20/ ,/ 21/ ,/ 22/ ,/ 23/ ,/ 24/ }/ 中/ 各边/ 的/ 犆/ 犕/ 值/ 240.3/ ./ 0.610160/ ./ 5.0/ ./ 60.7/ ./ 0.717181920212223240/ ./ 3.0/ ./ 10/ 方法/ 删除/ 边/ Briand/ 等/ 人/ 的/ 方法/ [/ 8/ ]/ 7Abdurazik/ 等/ 人/ 的/ 方法/ [/ 1/ ]/ 7/ 本文/ 方法/ 74.1/ ./ 2ANT/ 系统/ 对于/ ANT/ 系统/ ,/ 我们/ 采用/ 同样/ 的/ 方法/ 进行/ 实验/ ./ 该/ 系统/ 的/ 类图/ 可以/ 参见/ 文献/ [/ 8/ ]/ ,/ 其中/ 所/ 包含/ 的/ 类/ 如表/ 6/ 所示/ ./ 首先/ ,/ 以式/ (/ 1/ )/ 的/ 形式/ 所/ 表示/ 的/ ANT/ 系统/ 中强/ 连通/ 分量/ SCC/ {/ 2/ ,/ 4/ ,/ 10/ ,/ 16/ ,/ 17/ ,/ 18/ ,/ 19/ ,/ 20/ ,/ 21/ ,/ 22/ ,/ 23/ ,/ 24/ }/ 的/ 各条/ 边/ 所/ 对应/ 的/ CM/ 值如表/ 7/ 所示/ ./ 类/ 编号/ 1AntClassLoader2BuildEvent3BuildException4BuildListener5BuildLogger6DefaultLogger7DemuxOutputStream20Target8DirectoryScanner21Task9FileScanner10IntrospectionHelper23TaskContainer11Launcher12Location13Main0/ ./ 4.0/ ./ 30.5/ ./ 3.00/ ./ 6.0/ ./ 00.1/ ./ 1.00/ ./ 1.0/ ./ 00.2/ ./ 0.00/ ./ 2.0/ ./ 10.0/ ./ 2.00/ ./ 3.2/ ./ 2Page9/ 表/ 8/ 给出/ 的/ 是/ 采用/ 本文/ 方法/ 对/ SCC/ {/ 8/ ,/ 9/ ,/ 10/ ,/ 11/ ,/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ }/ 中/ 各边/ 的/ 源类/ 创建/ 的/ 测试/ 桩/ 复杂/ 表/ 8/ 犛/ 犆/ 犆/ {/ 2/ ,/ 4/ ,/ 10/ ,/ 16/ ,/ 17/ ,/ 18/ ,/ 19/ ,/ 20/ ,/ 21/ ,/ 22/ ,/ 23/ ,/ 24/ }/ 中/ 各边/ 的/ 权值/ 序号/ 边/ V/ &/ M/ &/ R/ &/ P12345678910/ 使用/ TOGOS/ 工具/ 打破/ 环路/ 的/ 过程/ 如表/ 9/ 所示/ ./ 其中/ ,/ 第/ 1/ 列/ 和/ 第/ 2/ 列/ 分别/ 表示/ 被/ 处理/ 的/ SCCi/ 的/ 序号/ 以及/ SCCi/ 本身/ ;/ 第/ 3/ 列为/ SCCi/ 中/ 包含/ 的/ 环路/ 的/ 个数/ ;/ 第/ 4/ 列为/ 处理/ SCCi/ 时所/ 删除/ 的/ 边/ ./ 最/ 21222324252627282930/ 后/ ,/ 由于/ Abdurazik/ [/ 1/ ]/ 没有/ 对/ ANT/ 进行/ 分析/ ,/ 这里/ 仅/ 对/ 采用/ 本文/ 方法/ 与/ 文献/ [/ 8/ ]/ 中/ 的/ 方法/ 的/ 度量/ 结果/ 进行/ 了/ 比较/ ./ ANT/ 系统/ 度量/ 结果/ 的/ 比较/ 如表/ 10/ 所示/ ./ 表/ 9/ 打破/ 环路/ 的/ 过程/ 表/ 10ANT/ 系统/ 的/ 度量/ 结果/ 被/ 删除/ 的/ 边/ 17/ →/ 16/ ,/ 21/ →/ 16/ ,/ 21/ →/ 19/ ,/ 21/ →/ 20/ ,/ 20/ →/ 16/ ,/ 20/ →/ 18/ ,/ 20/ →/ 19/ ,/ 20/ →/ 24/ ,/ 4/ →/ 2/ ,/ 16/ →/ 2/ ,/ 16/ →/ 22/ ,/ 19/ →/ 1819/ →/ 18/ ,/ 20/ →/ 18/ ,/ 20/ →/ 24/ ,/ 19/ →/ 16/ ,/ 17/ →/ 16/ ,/ 21/ →/ 16/ ,/ 20/ →/ 16/ ,/ 2/ →/ 16/ ,/ 21/ →/ 20/ ,/ 16/ →/ 22/ 序号/ 12345678910Briand/ 等/ 人/ 的/ 方法/ 被/ 删除/ 的/ 边/ 的/ 个数/ 方法/ [/ 8/ ]/ 本文/ 方法/ 4.1/ ./ 3DNS/ 系统/ 对于/ DNS/ 系统/ ,/ 所/ 采用/ 的/ 方法/ 与/ 前/ 两个/ 实例/ 的/ 方法/ 相同/ ,/ 这里/ 我们/ 不/ 对/ 过程/ 进行/ 重复/ 描述/ ./ 并且/ 对/ 采用/ 本文/ 方法/ 与/ 文献/ [/ 8/ ]/ 中/ 的/ 方法/ 的/ 度量/ 结果/ 进行/ 了/ 比较/ ./ 如表/ 11/ 所示/ ./ 边/ 的/ 个数/ 被/ 删除/ 的/ 边/ 总体/ 复杂度/ 方法/ 被/ 删除/ 的/ Briand/ 方法/ [/ 8/ ]/ 621/ →/ 8/ ,/ 21/ →/ 11/ ,/ 32/ →/ 48/ ,/ 等/ 人/ 的/ 方法/ 633/ →/ 52/ ,/ 21/ →/ 11/ ,/ 33/ →/ 38/ ,/ 本文/ 4.2/ 实验/ 结果/ 和/ 分析/ 由表/ 5/ 可以/ 发现/ ,/ 本文/ 方法/ 与/ 采用/ Briand/ 等度/ 的/ 耦合/ 度量/ 结果/ ,/ 即/ 各边/ 权重/ ./ 18/ →/ 2419/ →/ 1619/ →/ 1820/ →/ 1620/ →/ 1820/ →/ 1920/ →/ 2421/ →/ 1621/ →/ 1921/ →/ 20/ 人/ [/ 8/ ]/ 的/ 遗传算法/ 和/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 的/ 基于/ 图/ 的/ 算法/ 产生/ 不同/ 的/ 结果/ :/ 他们/ 的/ 方法/ 中/ 删除/ 了/ 7/ 条边/ [/ 1/ ,/ 8/ ]/ ,/ 总体/ 测试/ 桩/ 复杂度/ 为/ 2.70/ ,/ 而/ 本文/ 同样/ 也/ 删除/ 了/ 7/ 条边/ ,/ 但/ 总体/ 测试/ 桩/ 复杂度/ 为/ 1.61/ ,/ 那么/ 构造/ 的/ 总体/ 测试/ 桩/ 的/ 复杂度/ 降低/ 了/ (/ 2.70/ -/ 1.61/ )/ // 2.70/ =/ 40.4/ %/ ./ 最后/ ,/ 通过/ TOGOS/ 工具/ 自动/ 生成/ ATM/ 系统/ 的/ 类/ 测试/ 顺序/ ,/ 如表/ 12/ 所示/ ./ 其中/ ,/ 第/ 1/ 列为/ 主/ 测试/ 顺序号/ ,/ 第/ 2/ 列为/ 被/ 测试/ 的/ 类/ ,/ 第/ 3/ 列为/ 被/ 测类/ 所/ 依赖/ 的/ 类/ ,/ 即/ 在/ 被/ 测类/ 之前/ 进行/ 测试/ 的/ 类/ ./ 对于/ 主/ 测试/ 顺序号/ 相同/ 的/ 类/ ,/ 它们/ 之间/ 没有/ 依赖/ 关系/ ,/ 其/ 测试/ 顺序/ 可以/ 是/ 任意/ 的/ ./ 因此/ ,/ 表/ 12/ 中/ 的/ 测试/ 顺序/ 并/ 不是/ 唯一/ 的/ 测试/ 顺序/ ./ Page10/ 主/ 测试/ 顺序号/ 被/ 测类/ 16/ ,/ 16/ ,/ 20/ ,/ 212348598/ ,/ 1/ ,/ 16/ ,/ 20/ ,/ 2/ ,/ 3/ ,/ 4/ ,/ 17/ ,/ 5/ ,/ 6/ ,/ 7/ ,/ 2167108/ ,/ 1/ ,/ 16/ ,/ 20/ ,/ 2/ ,/ 3/ ,/ 4/ ,/ 17/ ,/ 5/ ,/ 6/ ,/ 7/ ,/ 9/ ,/ 21/ ,/ 118Abdurazik/ 等/ 人/ 在/ 文献/ [/ 1/ ]/ 中仅/ 对/ ATM/ 系统/ 进行/ 了/ 分析/ ,/ 而/ 对于/ ANT/ 系统/ 未作/ 任何/ 分析/ ./ 因此/ ,/ 对于/ ANT/ 系统/ ,/ 本文/ 方法/ 仅/ 与/ Briand/ 等/ 人/ [/ 8/ ]/ 的/ 主/ 测试/ 顺序号/ 被/ 测类/ 19/ ,/ 10/ ,/ 13/ ,/ 15/ ,/ 17/ ,/ 27/ ,/ 表/ 13DNS/ 系统/ 类/ 测试/ 顺序/ 234567/ 遗传算法/ 进行/ 比较/ ./ 同理/ ,/ 由表/ 10/ 可以/ 发现/ ,/ 本文/ 方法/ 与/ Briand/ 等/ 人/ [/ 8/ ]/ 的/ 遗传算法/ 产生/ 不同/ 的/ 结果/ :/ 他们/ 的/ 方法/ 中/ 删除/ 了/ 12/ 条边/ [/ 8/ ]/ ,/ 总体/ 测试/ 桩/ 复杂度/ 为/ 3.59/ ,/ 而/ 本文/ 删除/ 了/ 10/ 条边/ ,/ 总体/ 测试/ 桩/ 复杂度/ 为/ 3.28/ ,/ 那么/ 构造/ 的/ 总体/ 测试/ 桩/ 的/ 复杂度/ 降低/ 了/ (/ 3.59/ -/ 3.28/ )/ // 3.59/ =/ 8.6/ %/ ./ 通过/ TOGOS/ 工具/ 自动/ 生成/ ANT/ 系统/ 的/ 类/ 测试/ 顺序/ :/ (/ 9/ ,/ 12/ ,/ 15/ ,/ 17/ )/ ,/ 3/ ,/ (/ 8/ ,/ 19/ )/ ,/ 21/ ,/ 23/ ,/ 20/ ,/ 2/ ,/ 4/ ,/ (/ 5/ ,/ 16/ )/ ,/ (/ 1/ ,/ 6/ ,/ 7/ ,/ 10/ ,/ 22/ ,/ 25/ )/ ,/ (/ 11/ ,/ 14/ ,/ 24/ )/ ,/ 18/ ,/ 13/ ./ 即/ 共/ 13/ 个主/ 测试/ 序/ ./ 其中/ ,/ 括号/ 中/ 的/ 类/ 表示/ 它们/ 的/ 主/ 测试/ 顺序号/ 相同/ ./ 对于/ DNS/ 系统/ ,/ 由表/ 11/ 可以/ 发现/ ,/ 本文/ 方法/ 与/ Briand/ 等/ 人/ [/ 8/ ]/ 的/ 遗传算法/ 产生/ 不同/ 的/ 结果/ :/ 他们/ 的/ 方法/ 中/ 删除/ 了/ 6/ 条边/ ,/ 总体/ 测试/ 桩/ 复杂度/ 为/ 1.47/ ,/ 而/ 本文/ 也/ 删除/ 了/ 6/ 条边/ ,/ 但/ 总体/ 测试/ 桩/ 复杂度/ 为/ 1.36/ ,/ 那么/ 构造/ 的/ 总体/ 测试/ 桩/ 的/ 复杂度/ 降低/ 了/ (/ 1.47/ -/ 1.36/ )/ // 1.47/ =/ 7.5/ %/ ./ TOGOS/ 工具/ 自动/ 生成/ DNS/ 系统/ 的/ 类/ 测试/ 顺序/ 如表/ 13/ 所示/ ./ 被/ 测类/ 所/ 依赖/ 的/ 类/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 46/ ,/ 478/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 17/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 17/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 13/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 31/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 25/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 25/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 4610/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 25/ ,/ 8/ ,/ 32/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 25/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 25/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 4613/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 25/ ,/ 8/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 468/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 31/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44/ ,/ 46/ ,/ 588/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 46/ ,/ 56/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 448/ ,/ 21/ ,/ 5/ ,/ 28/ ,/ 49/ ,/ 46/ ,/ 56/ ,/ 32/ ,/ 10/ ,/ 36/ ,/ 44Page11/ 主/ 测试/ 顺序号/ 被/ 测类/ 89101112/ 接下来/ 需要/ 对/ 生成/ 的/ 类/ 测试/ 顺序/ 的/ 有效性/ 进行/ 验证/ ./ 本文/ 以/ ATM/ 系统/ 为例/ ,/ 其/ 测试/ 序/ 的/ 正确性/ 验证/ 如下/ ./ 证明/ ./ 根据/ 测试/ 依赖性/ 定理/ 1/ 可知/ ,/ 类/ 6/ ,/ 16/ ,/ 20/ ,/ 21/ 不/ 依赖于/ 任何/ 其它/ 类/ ,/ 则/ 它们/ 最先/ 进行/ 测试/ ;/ 类/ 11/ 是/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ 的/ 父类/ ,/ 则/ 类/ 11/ 先于/ 类/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ 的/ 测试/ ,/ 而类/ 12/ ,/ 13/ ,/ 14/ ,/ 15/ 之间/ 没有/ 依赖/ 关系/ ,/ 则/ 它们/ 的/ 测试/ 顺序/ 是/ 任意/ 的/ ;/ 而类/ 11/ 依赖于/ 类/ 8/ ,/ 9/ ,/ 10/ ,/ 20/ ,/ 21/ ,/ 而/ 11/ →/ 10/ 依赖/ 在/ 打破/ 环路/ 时/ 已/ 被/ 删除/ ,/ 则/ 8/ ,/ 9/ ,/ 20/ ,/ 21/ 先于/ 类/ 11/ 的/ 测试/ ;/ 类/ 8/ 是/ 类/ 1/ ~/ 7/ 的/ 聚集/ 类/ ,/ 则/ 类/ 1/ ~/ 7/ 先于/ 类/ 8/ 的/ 测试/ ;/ 同理/ ,/ 类/ 7/ 和/ 9/ 是/ 类/ 20/ 的/ 聚集/ 类/ ,/ 类/ 10/ 是/ 类/ 11/ 的/ 聚集/ 类/ ,/ 类/ 11/ 是/ 类/ 20/ 的/ 聚集/ 类/ ,/ 类/ 18/ 和/ 19/ 是/ 类/ 8/ 和/ 9/ 的/ 聚集/ 类/ ,/ 则/ 类/ 20/ 先于/ 类/ 7/ ,/ 9/ 和/ 11/ 测试/ ,/ 类/ 11/ 先于/ 类/ 10/ 的/ 测试/ ,/ 类/ 8/ 和/ 9/ 先于/ 类/ 18/ 和/ 19/ 的/ 测试/ ;/ 其它/ 剩余/ 的/ 那些/ 弱/ 联系/ 关系/ 的/ 类/ 测试/ 顺序/ 的/ 正确性/ 验证/ 方法/ 同上/ ./ 本文/ 的/ 耦合/ 度量/ 方法/ 以及/ 启发式/ 算法/ 是/ 有效/ 的/ ;/ 同时/ ,/ 从/ 实验/ 结果/ 可以/ 看出/ ,/ 与/ 采用/ Briand/ 等/ 人/ [/ 8/ ]/ 和/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 的/ 方法/ 相比/ ,/ 求解/ 质量/ 有所提高/ ./ 原因/ 如下/ :/ 首先/ ,/ 与/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 的/ 方法/ 相同/ ,/ 本文/ 实验/ 中/ 计算/ WV/ 、/ WM/ 、/ WR/ 和/ WP/ 的/ 值时/ ,/ 一个/ 类/ Ci/ 直接/ 使用/ 的/ 类/ Cj/ 的/ 公有/ 变量/ 的/ 个数/ 均/ 为/ 0/ ,/ 体现/ 了/ 类/ 的/ 封装/ 性/ ./ 然而/ ,/ 计算/ 时所/ 使用/ 的/ 式/ (/ 1/ )/ 中/ 的/ M/ 、/ R/ 、/ P/ 的/ 值/ 则/ 与/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 的/ 不同/ ,/ 我们/ 的/ 方法/ 是/ 直接/ 使用/ 类/ Ci/ 调用/ 的/ 类/ Cj/ 中/ 方法/ 的/ 个数/ ,/ 在/ 被/ 调/ 方法/ 中/ 出现/ 的/ 不同/ 返回/ 类型/ 个数/ 以及/ 在/ 被/ 调/ 方法/ 中/ 出现/ 的/ 不同/ 参数/ 个数/ ,/ 因为/ 它们/ 可以/ 直接/ 反映/ 两个/ 相互作用/ 的/ 类/ 之间/ 的/ 耦合度/ ./ 而/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 首先/ 在/ 软件/ 实现/ 过程中将/ 其/ 分为/ 9/ 种/ 不同/ 的/ 耦合/ 类型/ ,/ 然后/ 对于/ 每/ 一种/ 耦合/ 类型/ ,/ 定义/ 相应/ 的/ 耦合/ 度量/ 来/ 衡量/ 服务/ 类/ 和/ 客户/ 类/ 之间/ 的/ 依赖/ 关系/ ,/ 此外/ ,/ 他们/ 同时/ 对边/ 的/ 权重/ 和/ 节点/ 权重/ 进行/ 被/ 测类/ 所/ 依赖/ 的/ 类/ 定量/ 的/ 耦合/ 度量/ ,/ 增加/ 了/ 算法/ 的/ 复杂度/ ./ 计算/ 式/ (/ 4/ )/ 中/ V/ (/ i/ ,/ j/ )/ 的/ 值时/ ,/ 我们/ 所/ 使用/ 的/ V/ 、/ Vmax/ 和/ Vmin/ 的/ 值/ 可以/ 在/ 文献/ [/ 8/ ]/ 中/ 查找/ ./ 其次/ ,/ 在/ Briand/ 等/ 人/ [/ 8/ ]/ 的/ 方法/ 中/ ,/ 耦合/ 度量/ 方法/ 中/ 的/ 属性/ 耦合/ 和/ 方法/ 耦合/ 分配/ 的/ 是/ 相同/ 的/ 权值/ ,/ 考虑/ 的/ 是/ 一种/ 特殊/ 的/ 情况/ ,/ 此外/ ,/ 他们/ 忽略/ 了/ 返回值/ 和/ 传递/ 的/ 参数/ 对/ 耦合/ 度量/ 的/ 影响/ ,/ 具有/ 一定/ 的/ 局限性/ ./ 我们/ 在/ 克服/ 现有/ 方法/ 存在/ 的/ 问题/ 并/ 结合/ 他们/ 优势/ 的/ 基础/ 上/ 给出/ 了/ 本文/ 方法/ ./ 对/ 测试/ 桩/ 的/ 复杂度/ 进行/ 度量/ 时/ ,/ 我们/ 给出/ 了/ 一种/ 新/ 的/ 方法/ ,/ 在/ 打破/ 环路/ 时/ ,/ 弥补/ 了/ 断开/ 继承/ 、/ 组合/ 和/ 聚集/ 等/ 强/ 联系/ 关系/ 导致/ 的/ 测试/ 桩/ 复杂度/ 提高/ 的/ 缺陷/ ,/ 采用/ 基于/ 图论/ 的/ 启发式/ 算法/ ,/ 只/ 需/ 运行/ 一次/ ,/ 便/ 能够/ 确定/ 类间/ 测试/ 顺序/ ,/ 并/ 满足/ 花费/ 总体/ 测试/ 桩/ 复杂度/ 最小/ ./ 同时/ ,/ 类间/ 测试/ 序列/ 自动/ 生成/ 工具/ TOGOS/ 的/ 开发/ ,/ 实现/ 了/ 自动化/ 测试/ ,/ 减少/ 了/ 测试/ 的/ 工作量/ ,/ 提高/ 了/ 测试/ 效率/ ./ 5/ 相关/ 研究/ 在/ 面向对象/ 程序/ 的/ 测试/ 中/ ,/ Kung/ 等/ 人/ [/ 10/ ]/ 最早/ 提出/ 了/ 解决/ 类/ 测试/ 顺序/ 问题/ 的/ 方法/ ,/ 并/ 证明/ 如果/ 对象/ 关系/ 图中/ 没有/ 环/ ,/ 则/ 可以/ 通过/ 逆向/ 拓扑/ 排序/ 得到/ 类间/ 测试/ 顺序/ ./ 如果/ 类图/ 中/ 有/ 环/ ,/ 则/ 首先/ 识别/ 其中/ 的/ 强/ 联通/ 分量/ ,/ 然后/ 删除/ 部分/ 关联/ 边/ 使/ 之/ 成为/ 无环图/ ,/ 这一/ 过程/ 意味着/ 需要/ 开发/ 测试/ 桩/ ,/ 而/ 开发/ 测试/ 桩/ 是/ 一项/ 成本/ 很/ 高/ 的/ 工作/ [/ 11/ ]/ ./ 减少/ 开发/ 测试/ 桩/ 成本/ 的/ 方法/ 主要/ 有/ 两类/ :/ 一类/ 是/ 最小化/ 所/ 需/ 测试/ 桩/ 的/ 数目/ ,/ 例如/ :/ Tai/ 等/ 人/ [/ 5/ ]/ 提出/ 的/ 测试/ 顺序/ 分配/ 策略/ 导致/ 构造/ 大量/ 多余/ 的/ 测试/ 桩/ ;/ LeTraon/ 等/ 人/ [/ 6/ ]/ 采用/ 了/ 一种/ 基于/ 测试/ 依赖图/ 模型/ 的/ 方法/ 进行/ 集成/ 测试/ ,/ 测试/ 依赖图/ 是/ 由类/ 和/ 方法/ 之间/ 的/ 测试/ 依赖/ 关系/ 构成/ 的/ ,/ 他们/ 的/ 策略/ 最优化/ 了/ 桩/ 的/ 数目/ ,/ 但/ 可能/ 打破/ 继承/ 和/ 聚集/ 关系/ ;/ Briand/ 等/ 人/ [/ 2/ ]/ 在/ 不/ 打破/ 继承/ 、/ 聚集/ 等/ 强/ 联系/ 关/ Page12/ 系/ 的/ 前提/ 下/ ,/ 给出/ 基于/ 图论/ 的/ 测试/ 顺序/ 策略/ ,/ 通过/ 最小化/ 测试/ 桩/ 的/ 数目/ 找到/ 一个/ 最佳/ 测试/ 顺序/ ,/ 减少/ 了/ 所/ 需/ 测试/ 桩/ 数目/ ./ 另一类/ 是/ 最小化/ 总体/ 测试/ 桩/ 的/ 复杂度/ ,/ 例如/ :/ Briand/ 等/ 人/ [/ 8/ ]/ 和/ Abdurazik/ [/ 1/ ]/ 等/ 人/ 以及/ 文献/ [/ 7/ ]/ 分别/ 使用/ 了/ 不同/ 的/ 耦合/ 度量/ 方法/ 估算/ 测试/ 桩/ 的/ 复杂度/ ,/ 其中/ ,/ 文献/ [/ 7/ ]/ 使用/ 的/ 是/ 耦合/ 度量/ 和/ 随机/ 交互/ 算法/ 解决/ 类/ 测试/ 顺序/ 问题/ ,/ 他们/ 允许/ 断开/ 继承/ 和/ 聚集/ 等/ 强/ 关联/ 关系/ ;/ Briand/ 等/ 人/ [/ 8/ ]/ 的/ 方法/ 虽然/ 避免/ 断开/ 继承/ 和/ 聚集/ 等/ 强/ 关联/ 关系/ ,/ 但是/ 在/ 计算/ 测试/ 桩/ 的/ 复杂度/ 时/ ,/ 对于/ 耦合/ 度量/ 方法/ 中/ 的/ 属性/ 耦合/ 和/ 方法/ 耦合/ 分配/ 的/ 是/ 相同/ 的/ 权值/ ,/ 因此/ ,/ 考虑/ 的/ 是/ 一种/ 特殊/ 的/ 情况/ ;/ 而/ Abdurazik/ 等/ 人/ [/ 1/ ]/ 首先/ 对边/ 的/ 权重/ 和/ 节点/ 权重/ 进行/ 定量/ 的/ 耦合/ 度量/ ,/ 进一步/ 精确/ 了/ 度量/ 结果/ ,/ 然后/ 采用/ 基于/ 图论/ 的/ 方法/ ,/ 根据/ 边/ 的/ 权重/ 、/ 节点/ 权重/ 以及/ 环路/ 的/ 个数/ 这/ 3/ 个/ 因素/ 来/ 打破/ 环路/ ,/ 但是/ 增加/ 了/ 算法/ 的/ 复杂度/ ,/ 提高/ 了/ 测试/ 成本/ ./ 因为/ 不同/ 的/ 测试/ 桩/ 各自/ 复杂度/ 不同/ ,/ 因此/ ,/ 测试/ 桩/ 的/ 数量/ 越少/ 并/ 不能/ 表示/ 一个/ 测试/ 序列/ 需要/ 花费/ 的/ 总体/ 代价/ 越低/ ./ 因此/ ,/ 我们/ 采用/ 的/ 是/ 最小化/ 总体/ 测试/ 桩/ 的/ 复杂度/ 的/ 方法/ ./ 总体/ 来看/ ,/ 解决/ 类/ 集成/ 测试/ 顺序/ 问题/ 时/ ,/ 对于/ 测试/ 桩/ 的/ 复杂度/ 的/ 度量/ 方法/ ,/ 现有/ 的/ 方法/ 一部分/ 是/ 采用/ 断开/ 继承/ 和/ 聚集/ 关系/ 的/ 方法/ 所/ 导致/ 测试/ 桩/ 复杂度/ 的/ 增加/ [/ 6/ -/ 7/ ]/ ,/ 而/ 另/ 一部分/ 由于/ 考虑/ 因素/ 过多/ 使/ 度量/ 方法/ 过于/ 繁琐/ [/ 1/ ]/ ;/ 对于/ 打破/ 环路/ 的/ 方法/ ,/ 采用/ GA/ 方法/ 必须/ 执行/ 很/ 多次/ ,/ 使/ 过程/ 复杂化/ ,/ 基于/ 图论/ 的/ 方法/ 一部分/ 是/ 采用/ 断开/ 继承/ 和/ 聚集/ 关系/ [/ 6/ -/ 7/ ]/ 的/ 方法/ ,/ 一部分/ 是/ 由于/ 在/ 测试/ 桩/ 复杂度/ 的/ 度量/ 阶段/ 的/ 不精确性/ 导致/ 最终/ 打破/ 环路/ 所/ 需/ 构造/ 测试/ 桩/ 的/ 总体/ 复杂度/ 的/ 提高/ ./ 因此/ ,/ 我们/ 对/ 测试/ 桩/ 的/ 复杂度/ 进行/ 度量/ 时/ ,/ 给出/ 一种/ 简单/ 普遍/ 的/ 方法/ ,/ 在/ 打破/ 环路/ 时/ ,/ 弥补/ 了/ 断开/ 继承/ 、/ 组合/ 和/ 聚集/ 等/ 强/ 联系/ 关系/ 导致/ 的/ 测试/ 桩/ 复杂度/ 提高/ 的/ 缺陷/ ,/ 采用/ 基于/ 图论/ 的/ 启发式/ 算法/ ,/ 只/ 需/ 运行/ 一次/ ,/ 便/ 能够/ 确定/ 类间/ 测试/ 顺序/ ,/ 并/ 满足/ 测试/ 桩/ 的/ 总体/ 复杂度/ 最小/ ./ 6/ 结束语/ 类间/ 测试/ 序/ 的/ 研究/ 是/ 类/ 簇级/ 测试/ 的/ 一个/ 难点/ ./ 本文/ 通过/ 实验/ 证明/ ,/ 当/ 把/ 测试/ 桩/ 的/ 复杂度/ 作为/ 权值/ ,/ 我们/ 的/ 耦合/ 度量/ 方法/ 以及/ 启发式/ 算法/ 与/ Briand/ 的/ 和/ Abdurazik/ 的/ 耦合/ 度量/ 方法/ 相比/ ,/ 更加/ 精确/ 地/ 度量/ 测试/ 桩/ 复杂性/ ,/ 性能/ 较优/ ,/ 降低/ 了/ 测试/ 桩/ 的/ 总体/ 复杂度/ ,/ 遗传算法/ 需要/ 多次/ 运行/ ,/ 而/ 我们/ 的/ 方法/ 只/ 需/ 运行/ 一次/ ,/ 从而/ 降低/ 了/ 测试/ 代价/ ./ 在/ 此基础/ 上/ 开发/ 的/ TOGOS/ 工具/ ,/ 能够/ 自动/ 生成/ 一个/ 面向对象/ 系统/ 中/ 的/ 类/ 集成/ 测试/ 序列/ ,/ 提高/ 了/ 测试/ 顺序/ 生成/ 的/ 速度/ ,/ 减少/ 了/ 测试/ 的/ 工作量/ ./ 可以/ 发现/ ,/ 本文/ 中/ 我们/ 没有/ 考虑/ 抽象类/ 的/ 特点/ ,/ 实际上/ ,/ 抽象类/ 的/ 特性/ ,/ 将会/ 影响/ 类间/ 的/ 依赖性/ ,/ 进而/ 将/ 影响/ 类间/ 测试/ 顺序/ ./ 这是/ 我们/ 下/ 一步/ 要/ 解决/ 的/ 问题/ 之一/ ./ 此外/ ,/ 现有/ 的/ 类间/ 分析/ 只/ 限于/ 静态/ 依赖/ 分析/ ,/ 而/ 类间/ 的/ 动态/ 依赖/ 关系/ 比较/ 普遍/ ,/ 增加/ 打破/ 动态/ 依赖边/ 的/ 复杂度/ ,/ 但是/ 这样/ 会/ 带来/ 新/ 的/ 问题/ :/ 动态/ 依赖/ 关系/ 是/ 由于/ 静态/ 依赖/ 关系/ 而/ 在/ 执行/ 阶段/ 存在/ 的/ 关系/ ,/ 当/ 打破/ 静态/ 依赖/ 关系/ 时/ ,/ 一些/ 动态/ 依赖/ 关系/ 会/ 随之/ 消失/ ,/ 对于/ 没有/ 消失/ 的/ 动态/ 依赖/ 关系/ ,/ 在/ 何种/ 情况/ 下/ 删除/ 这些/ 动态/ 依赖/ 关系/ 来/ 打破/ 环路/ ,/ 如何/ 为/ 动态/ 依赖/ 关系/ 构造/ 测试/ 桩/ 以及/ 动态/ 依赖边/ 权重/ 的/ 计算方法/ 是/ 我们/ 下/ 一步/ 要/ 解决/ 的/ 主要/ 问题/ ./ 致谢/ 在/ 此/ ,/ 我们/ 向/ 对/ 本文/ 给予/ 建议/ 的/ 同行/ 表示感谢/ ./ 同时/ ,/ 对/ 审稿人/ 提出/ 的/ 有益/ 建议/ 表示感谢/ !/ 

