Page1KFUR/ :/ 一个/ 新型/ 内核/ 扩展/ 安全/ 模型/ 马超/ 1/ )/ 尹杰/ 1/ )/ 刘虎球/ 1/ )/ 李浩/ 2/ )/ 1/ )/ (/ 清华大学/ 计算机科学/ 与/ 技术/ 系/ 北京/ 100084/ )/ 2/ )/ (/ 西安电子科技大学/ 计算机科学/ 与/ 技术/ 学院/ 西安/ 710126/ )/ 摘要/ 保障/ 内核/ 扩展/ 的/ 安全性/ 对/ 操作系统/ 具有/ 重要/ 意义/ ./ 当前/ 存在/ 大量/ 针对/ 内核/ 函数/ 使用/ 规则/ 的/ 攻击/ ,/ 内核/ 扩展/ 中/ 也/ 存在/ 大量/ 违反/ 内核/ 函数/ 使用/ 规则/ 的/ 错误/ ,/ 因此/ 针对/ 内核/ 函数/ 使用/ 规则/ 的/ 安全性/ 检测/ 十分必要/ ./ 虽然/ 存在/ 多种/ 提高/ 内核/ 扩展/ 安全性/ 的/ 方法/ ,/ 但/ 很少/ 有/ 方法/ 对/ 内核/ 函数/ 的/ 使用/ 规则/ 进行/ 安全性/ 检测/ ./ 文中/ 设计/ 了/ KFUR/ (/ KernelFunctionUsageRule/ )/ 内核/ 扩展/ 安全/ 模型/ 系统/ ,/ 用于/ 在/ 运行/ 时/ 检测/ 内核/ 扩展/ 调用/ 内核/ 函数/ 是否/ 遵守/ 内核/ 函数/ 使用/ 规则/ ./ 如果/ 内核/ 扩展/ 调用/ 内核/ 函数/ 满足/ 模型/ 安全/ 运行/ 条件/ ,/ 则/ 允许/ 对/ 该/ 内核/ 函数/ 进行/ 调用/ ,/ 否则/ 将/ 错误报告/ 给/ 操作系统/ 内核/ 并/ 终止/ 该/ 内核/ 扩展/ 的/ 运行/ ./ 文中/ 所述/ 研究/ 在/ Linux/ 操作系统/ 上/ 对/ KFUR/ 安全/ 模型/ 系统/ 进行/ 实现/ ,/ 并/ 将/ 其/ 运用/ 于/ e1000/ 网卡/ 驱动/ 、/ SATA/ 硬盘/ 驱动/ 和/ HDA/ 声卡/ 驱动/ 内核/ 扩展/ ./ 安全性/ 评测/ 表明/ 安全/ 模型/ 系统/ 能够/ 对/ 内核/ 函数/ 使用/ 规则/ 进行/ 安全性/ 检测/ ,/ 性能/ 评测/ 表明/ 安全/ 模型/ 系统/ 带来/ 的/ 开销/ 很小/ ./ 关键词/ 操作系统/ ;/ KFUR/ 安全/ 模型/ ;/ 内核/ 扩展/ ;/ 内核/ 函数/ 使用/ 规则/ 1/ 引言/ 内核/ 扩展/ 是/ 可以/ 在/ 运行/ 时/ 添加/ 到/ 操作系统/ 内核/ 中/ 的/ 功能模块/ ./ 如图/ 1/ 所示/ ,/ 在/ 通用/ 操作系统/ 中/ ,/ 内核/ 扩展/ 运行/ 于/ 内核/ 态/ ,/ 可以/ 访问/ 几乎/ 所有/ 计算机系统/ 的/ 资源/ ,/ 具有/ 很/ 高/ 的/ 特权/ ./ 因此/ ,/ 内核/ 扩展/ 的/ 安全性/ 直接/ 影响/ 操作系统/ 的/ 安全性/ ./ 由于/ 内核/ 扩展/ 可以/ 动态/ 添加/ 和/ 删除/ ,/ 因此/ 操作系统/ 大量/ 使用/ 内核/ 扩展/ 实现/ 各种/ 功能/ ./ 在/ Linux/ 操作系统/ 中/ ,/ 代码/ 量/ 占/ 操作系统/ 代码/ 总量/ 70/ %/ 的/ 设备/ 驱动/ 就是/ 作为/ 内核/ 扩展/ 运行/ 的/ [/ 1/ ]/ ./ 但是/ 内核/ 扩展/ 中/ 存在/ 很大/ 的/ 安全隐患/ ,/ CVE/ (/ CommonVulnerabilitiesandExposures/ )/ ①/ 中/ 报告/ 了/ 大量/ 针对/ 内核/ 扩展/ 的/ 攻击/ ,/ 并且/ 针对/ 内核/ 扩展/ 的/ 攻击/ 仍然/ 在/ 不断/ 出现/ ./ 因此/ ,/ 提高/ 内核/ 扩展/ 的/ 安全性/ 具有/ 重要/ 意义/ ./ CVE/ 报告/ 指出/ ,/ 大量/ 的/ 攻击/ 和/ 内核/ 函数/ 使用/ 规则/ 相关/ ./ 内核/ 函数/ 使用/ 规则/ 是/ 指/ 使用/ 一类/ 相互依赖/ 的/ 内核/ 函数/ 需要/ 遵守/ 的/ 规则/ ./ 例如/ ,/ Linux/ 操作系统/ 中/ 的/ 自旋/ 锁/ 可以/ 用于/ 保证/ 对/ 临界/ 区/ 的/ 互斥/ 访问/ ,/ 接口函数/ 中有/ 加锁/ 和/ 解锁/ 两类/ 操作/ ,/ 其中/ “/ 自旋/ 锁/ 不能/ 在/ 未/ 被/ 加锁/ 之前/ 解锁/ ”/ 是/ 一条/ 关于/ 自旋/ 锁/ 的/ 内核/ 函数/ 使用/ 规则/ ./ 同样/ ,/ 对/ 内存/ 使用/ 相关/ 的/ 函数/ 来说/ ,/ “/ 被/ 释放/ 的/ 内存/ 不能/ 再/ 进行/ 操作/ ,/ 除非/ 重新/ 被/ 分配/ ”/ 是/ 必须/ 要/ 遵守/ 的/ 一条/ 规则/ ./ 违反/ 内核/ 函数/ 使用/ 规则/ 会/ 造成/ 整个/ 操作系统/ 的/ 崩溃/ 、/ 机密信息/ 被/ 窃取/ 等/ 严重后果/ ./ 操作系统/ 的/ 崩溃/ 会/ 带来/ 很大/ 的/ 损失/ ,/ 如表/ 1/ 所示/ 为/ 不同/ 应用/ 1/ 分钟/ 宕机/ 的/ 代价/ ②/ ./ 而/ 在/ Linux/ 操作系统/ 中/ ,/ 作为/ 内核/ 扩展/ 运行/ 的/ 设备/ 驱动/ 失效/ 的/ 频率/ 是/ 其它/ 部分/ 的/ 3/ ~/ 7/ 倍/ [/ 1/ ]/ ,/ 在/ LinuxKernelMailList/ ③/ 中/ 报告/ 了/ 在/ 内核/ 扩展/ 中/ 存在/ 大量/ 内核/ 函数/ 使用/ 规则/ 相关/ 的/ 错误/ ./ 目前/ 已经/ 提出/ 很多/ 方法/ 提高/ 内核/ 扩展/ 的/ 安全性/ ./ Mondrix/ [/ 2/ ]/ 和/ Loki/ [/ 3/ ]/ 等/ 基于/ 特殊/ 硬件/ 对/ 内核/ 扩展/ 进行/ 隔离/ ;/ Minix3/ [/ 4/ ]/ 和/ SUD/ [/ 5/ ]/ 等/ 提出/ 将/ 设备/ 驱动/ 放到/ 用户/ 态/ 执行/ ;/ 也/ 有/ 一些/ 研究者/ 将/ 内核/ 扩展/ 放到/ 隔离/ 的/ 虚拟机/ 中/ 运行/ [/ 6/ -/ 7/ ]/ ;/ SafeDrive/ [/ 8/ ]/ 和/ LXFI/ [/ 9/ ]/ 使用/ 隔离/ 机制/ 来/ 提高/ 在/ 内核/ 态/ 运行/ 的/ 内核/ 扩展/ 的/ 安全性/ ./ SafeDrive/ 主要/ 解决/ 内核/ 扩展/ 违反/ 类型/ 安全/ 的/ 问题/ ,/ LXFI/ 主要/ 针对/ 内核/ 函数/ 完整性/ 进行/ 检测/ ./ 内核/ 函数/ 完整性/ 检测/ 是/ 针对/ 具体/ 的/ 内核/ 函数/ 接口/ 调用/ 进行/ 的/ 检测/ ,/ 但/ 并/ 没有/ 对/ 内核/ 函数/ 使用/ 规则/ 进行/ 检测/ ./ Ball/ 等/ 人/ [/ 10/ ]/ 在/ SDV/ (/ TheStaticDriverVerifiertool/ )/ 中/ 提出/ 了/ 大量/ 需要/ 被/ 检测/ 的/ 内核/ 函数/ 使用/ 规则/ ./ 大量/ 提高/ 内核/ 扩展/ 安全性/ 的/ 方法/ 没有/ 被/ 主流/ 操作系统/ 使用/ 的/ 主要/ 原因/ 之一/ 是/ 性能/ 问题/ ./ 虽然/ 这些/ 方法/ 能够/ 提高/ 内核/ 扩展/ 的/ 安全性/ ,/ 但/ 同时/ 会/ 带来/ 很大/ 的/ 开销/ ./ 本文/ 设计/ 了/ 一种/ 新型/ 安全/ 模型/ 系统/ —/ —/ —/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ ,/ 能以/ 很小/ 的/ 开销/ 对/ 内核/ 函数/ 使用/ 规则/ 进行/ 检测/ ,/ 防止/ 针对/ 内核/ 函数/ 使用/ 规则/ 的/ 攻击/ 和/ 程序员/ 编码/ 错误/ 导致/ 的/ 违反/ 内核/ 函数/ 使用/ 规则/ 对/ 操作系统/ 造成/ 的/ 破坏/ ./ 首先/ ,/ 本文/ 提出/ 了/ 内核/ 函数/ 使用/ 规则/ 的/ KFUR/ 安全/ 模型/ ,/ 用于/ 判断/ 内核/ 扩展/ 调用/ 内核/ 函数/ 是否/ 遵守/ 内核/ 函数/ 使用/ 规则/ ./ 基于/ 内核/ 函数/ 使用/ 规则/ 的/ KFUR/ 安全/ 模型/ ,/ 在/ Linux/ 操作系统/ 上/ 实现/ 了/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ ./ 该/ 安全/ 模型/ 系统/ 由/ 三/ 部分/ 组成/ :/ 内核/ 函数/ 使用/ 规则/ 库/ 、/ 检测/ 标记/ 和/ 动态/ 检测器/ ./ 内核/ 函数/ 使用/ 规则/ 库/ 根据/ KFUR/ 安全/ 模型/ 实现/ 了/ 需要/ 被/ 检查/ 的/ 内核/ 函数/ 使用/ 规则/ ./ 在/ 内核/ 扩展/ 代码/ 中/ 插入/ 少量/ 检测/ 标记/ ,/ 在/ 运行/ 时/ ,/ 插入/ 的/ 标记/ 将/ 触发/ 动态/ 检测器/ 的/ 运行/ ./ 动态/ 检测器/ 根据/ 内核/ 函数/ 使用/ 规则/ 库/ 判断/ 内核/ 扩展/ 对/ 内核/ 函数/ 的/ 调用/ 是否/ 安全/ ./ 为了/ 提高/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ 性能/ ,/ 设计/ 了/ 快速/ Hash/ 算法/ 用于/ 存储/ 数据/ ./ 本文/ 将/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 运用/ 于/ e1000/ 网卡/ 驱动/ 、/ SATA/ 硬盘/ 驱动/ 和/ HDA/ 声卡/ 驱/ ①/ ②/ ③/ Page3/ 动/ 内核/ 扩展/ 并/ 采用/ 错误/ 注入/ 的/ 方法/ 进行/ 安全性/ 评测/ ,/ 评测/ 结果表明/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 能够/ 有效/ 地/ 进行/ 安全性/ 检测/ ./ 分别/ 使用/ netperf/ ①/ 基准/ 测试程序/ 、/ dd/ 命令/ 测试/ 和/ postmark/ 基准/ 测试程序/ 、/ realplayer/ 声音/ 播放/ 和/ soundrecorder/ 声音/ 录制/ 对/ e1000/ 网卡/ 驱动/ 、/ SATA/ 硬盘/ 驱动/ 和/ HDA/ 声卡/ 驱动/ 进行/ 性能/ 评测/ ,/ 评测/ 结果表明/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 仅/ 带来/ 很小/ 的/ 开销/ ./ 本文/ 第/ 2/ 节/ 介绍/ 近年来/ 在/ 提高/ 内核/ 扩展/ 安全性/ 方面/ 的/ 工作/ ;/ 第/ 3/ 节对/ KFUR/ 安全/ 模型/ 进行/ 描述/ ;/ 第/ 4/ 节对/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ 主要/ 组成部分/ 进行/ 详细/ 的/ 描述/ ;/ 第/ 5/ 节/ 给出/ 安全性/ 评测/ 结果/ ;/ 第/ 6/ 节/ 给出/ 性能/ 评测/ 结果/ ;/ 第/ 7/ 节对/ 全文/ 进行/ 简要/ 总结/ ./ 2/ 相关/ 工作/ 目前/ 已经/ 有/ 很多/ 提高/ 内核/ 扩展/ 安全性/ 的/ 方法/ ,/ 下面/ 将/ 分类/ 进行/ 介绍/ ./ 一些/ 对/ 内核/ 扩展/ 进行/ 隔离/ 的/ 方法/ 需要/ 依赖/ 特殊/ 的/ 硬件/ ./ Mondrix/ [/ 2/ ]/ 基于/ Mondriaan/ 内存保护/ 机制/ 实现/ 了/ 对/ 内核/ 扩展/ 的/ 隔离/ ./ Mondriaan/ 内存保护/ 机制/ 采用/ 对/ 中央处理器/ 的/ 流水线/ 进行/ 修改/ ,/ 对/ load/ ,/ store/ 指令/ 进行/ 权限/ 检测/ 等/ 方法/ 实现/ 了/ 对/ 多个/ 受/ 保护/ 的/ 内存/ 域/ 共享/ 同一/ 线性/ 地址/ 空间/ 的/ 细粒度/ 内存保护/ 方法/ ./ 但是/ ,/ Mondriaan/ 内存保护/ 机制/ 所/ 依赖/ 的/ 硬件/ 目前/ 还/ 不/ 存在/ ./ Loki/ [/ 3/ ]/ 基于/ 标签/ 内存/ 机制/ 实现/ 隔离/ ./ 通过/ 使用/ 标签/ 内存/ 机制/ ,/ Loki/ 将/ 安全策略/ 和/ 物理/ 内存/ 予以/ 关联/ ,/ 简化/ 了/ 安全/ 机制/ 的/ 实现/ ./ 但/ Loki/ 依赖于/ HiStar/ 操作系统/ 的/ 特殊/ 结构/ ,/ 不能/ 被/ 应用/ 于/ 主流/ 实用/ 的/ 操作系统/ 中/ ./ 一些/ 研究者/ 采用/ 将/ 内核/ 扩展/ 移/ 到/ 用户/ 态/ 运行/ 的/ 方法/ 来/ 达到/ 提高/ 安全性/ 的/ 目的/ ./ Minix3/ [/ 4/ ]/ 操作系统/ 的/ 设备/ 驱动/ 在/ 用户/ 态/ 运行/ ,/ 但/ 其/ 性能/ 与/ 运行/ 在/ 内核/ 态/ 的/ 设备/ 驱动/ 相比/ 较差/ ./ Leslie/ [/ 11/ ]/ 提出/ 的/ 将/ 设备/ 驱动/ 移/ 到/ 用户/ 态/ 运行/ 的/ 方法/ 可以/ 保证/ 良好/ 的/ 性能/ ,/ 但/ 需要/ 对/ 设备/ 驱动/ 代码/ 进行/ 重写/ ./ SUD/ [/ 5/ ]/ 采用/ 在/ 用户/ 态/ 模拟/ Linux/ 操作系统/ 内核/ 环境/ 的/ 方法/ 将/ Linux/ 操作系统/ 的/ 设备/ 驱动/ 在/ 不/ 进行/ 修改/ 的/ 情况/ 下移/ 到/ 用户/ 态/ 运行/ ./ 有些/ 研究者/ 使用/ 虚拟机/ 提高/ 内核/ 扩展/ 的/ 安全性/ ./ Fraser/ 等/ 人/ [/ 6/ ]/ 把/ 内核/ 扩展/ 放到/ 隔离/ 的/ 虚拟机/ 中/ 运行/ ,/ 在/ 保证/ 了/ 安全性/ 的/ 同时/ 可以/ 实现/ 内核/ 扩展/ 被/ 多个/ 操作系统/ 共享/ ./ LeVasseur/ 等/ 人/ [/ 7/ ]/ 通过/ 将/ 内核/ 扩展/ 和/ 相应/ 的/ 操作系统/ 同时/ 运行/ 于/ 隔离/ 的/ 虚拟机/ 中来/ 提高/ 安全性/ 并/ 实现/ 内核/ 扩展/ 的/ 复用/ ./ 但/ 采用/ 虚拟机/ 技术/ 对/ 内核/ 扩展/ 进行/ 隔离/ 会/ 带来/ 很大/ 的/ 性能/ 开销/ ./ TwinDrivers/ [/ 12/ ]/ 提出/ 将/ 内核/ 扩展/ 中/ 影响/ 性能/ 的/ 部分/ 放到/ 虚拟机/ 虚拟/ 层/ 的/ 方法/ 提高/ 内核/ 扩展/ 的/ 性能/ ./ 有/ 很多/ 使用/ 软件/ 方法/ 实现/ 的/ 隔离/ 机制/ 用于/ 提高/ 内核/ 扩展/ 的/ 安全性/ ./ SFI/ (/ Software/ -/ basedFaultIsolation/ )/ [/ 13/ ]/ 隔离/ 机制/ 实现/ 了/ 一种/ 单一/ 地址/ 空间/ 的/ 隔离/ 机制/ ,/ 它/ 将/ 内核/ 扩展/ 的/ 代码/ 和/ 数据/ 加载/ 到/ 逻辑/ 隔离/ 的/ 内存/ 域/ ./ SFI/ 还/ 对/ 内核/ 扩展/ 的/ 代码/ 进行/ 修改/ ,/ 使/ 内核/ 扩展/ 不能/ 写/ 或者/ 跳转/ 到/ 其/ 所在/ 内存/ 域/ 以外/ 的/ 地址/ ./ XFI/ [/ 14/ ]/ 隔离/ 机制/ 能够/ 提供/ 灵活/ 的/ 访问控制/ 和/ 完整性/ 保证/ ./ SafeDrive/ [/ 8/ ]/ 通过/ 在/ 编写/ 内核/ 扩展/ 时/ 添加/ 标记/ ,/ 对/ 内核/ 扩展/ 违反/ 类型/ 安全/ 的/ 问题/ 进行/ 检测/ 和/ 恢复/ ./ LXFI/ [/ 9/ ]/ 通过/ 在/ 内核/ 扩展/ 代码/ 中/ 添加/ 对象/ 访问/ 权限/ 的/ 授予/ 、/ 回收/ 和/ 检测/ 标记/ ,/ 采用/ 介于/ 操作系统/ 和/ 内核/ 扩展/ 之间/ 的/ 隔离/ 机制/ 实现/ 对/ 内核/ 扩展/ 使用/ 内核/ 函数/ 的/ 完整性/ 检测/ ./ LXFI/ 能够/ 对/ 同一/ 内核/ 扩展/ 的/ 不同/ 实例/ 实现/ 不同/ 的/ 隔离/ ./ 目前/ 很少/ 有/ 能够/ 对/ 内核/ 函数/ 使用/ 规则/ 进行/ 检测/ 的/ 方法/ ,/ 另外/ ,/ 大多数/ 提高/ 内核/ 扩展/ 安全性/ 的/ 方法/ 都/ 会/ 带来/ 较大/ 的/ 开销/ ./ 事实上/ ,/ 在/ 使用/ 内核/ 扩展/ 时/ ,/ 需要/ 对/ 内核/ 函数/ 的/ 访问/ 予以/ 约束/ ,/ 该/ 约束/ 完全/ 可以/ 通过/ 定义/ 规则/ 的/ 形式/ 实现/ 对/ 内核/ 扩展/ 中/ 的/ 函数/ 使用/ 进行/ 检测/ 和/ 约束/ ./ 鉴于/ 此/ ,/ 本文/ 设计/ 和/ 实现/ 了/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ ,/ 用于/ 对/ 内核/ 函数/ 使用/ 规则/ 进行/ 检测/ ./ 在/ 设计/ 安全/ 模型/ 系统/ 时/ 充分考虑/ 了/ 性能/ 问题/ ./ 3/ 内核/ 函数/ 使用/ 规则/ KFUR/ 安全/ 模型/ 这/ 一节/ 首先/ 对/ KFUR/ 安全/ 模型/ 进行/ 描述/ ,/ 然后/ 基于/ 该/ 模型/ 对/ 内核/ 函数/ 使用/ 规则/ 进行/ 建模/ ./ 3.1/ KFUR/ 安全/ 模型/ KFUR/ 安全/ 模型/ 由/ 访问/ 主体/ 、/ 系统/ 状态/ 、/ 访问/ 客体/ 、/ 初始状态/ 、/ 不/ 安全/ 状态/ 、/ 转移/ 条件/ 和/ 转移/ 函数/ 7/ 个/ 部分/ 组成/ ./ 下面/ 将/ 分别/ 对/ 这/ 7/ 个/ 部分/ 进行/ 描述/ ./ 访问/ 主体/ :/ 是/ 指/ 提出/ 访问/ 请求/ 的/ 实体/ ,/ 使用/ 符号/ s/ 表示/ ,/ 访问/ 主体/ 的/ 集合/ 使用/ 符号/ S/ 表示/ ./ 系统/ 状态/ :/ 是/ 指/ KFUR/ 模型/ 在/ 某/ 一/ 时刻/ 的/ 快照/ ,/ 使用/ 符号/ q/ 表示/ ,/ 系统/ 状态/ 的/ 集合/ 使用/ 符号/ Q/ 表示/ ,/ 系统/ 初始状态/ 使用/ 符号/ q0/ 表示/ ,/ 不/ 安全/ 状态/ ①/ Netperf/ :/ Anetworkperformancebenchmark/ ,/ version2/ ./ 50Page4/ 使用/ 符号/ qe/ 表示/ ./ 访问/ 客体/ :/ 是/ 指/ 接受/ 访问/ 主体/ 访问/ 的/ 实体/ ,/ 使用/ 符号/ o/ 表示/ ,/ 访问/ 客体/ 的/ 集合/ 使用/ 符号/ O/ 表示/ ./ 访问/ 客体/ 中/ 包括/ 一个/ 或/ 多个/ 访问/ 属性/ ,/ 访问/ 属性/ 为/ 在/ 某/ 一/ 系统/ 状态/ 下/ 访问/ 客体/ 允许/ 被/ 访问/ 的/ 方式/ ,/ 使用/ 符号/ p/ 表示/ ./ 访问/ 方式/ 用/ 符号/ m/ 表示/ ./ 访问/ 客体/ 的/ 访问/ 属性/ 可以/ 表示/ 为/ p/ (/ o/ )/ =/ {/ (/ q0/ ,/ m0/ )/ ,/ (/ q1/ ,/ m1/ )/ …/ (/ qn/ ,/ mn/ )/ }/ ./ 转移/ 条件/ :/ 是/ 指/ 发生/ 状态/ 转移/ 的/ 条件/ ,/ 使用/ 符号/ a/ 表示/ ,/ 转移/ 条件/ 的/ 集合/ 使用/ 符号/ A/ 表示/ ./ 转移/ 函数/ :/ 是/ 指/ 发生/ 状态/ 转移/ 时/ 模型/ 发生/ 的/ 变化/ ,/ 使用/ 符号/ f/ 表示/ ,/ 转移/ 函数/ 的/ 集合/ 使用/ 符号/ F/ 表示/ ./ 转移/ 函数/ 的/ 输入/ 和/ 输出/ 为/ 访问/ 客体/ 和/ 系统/ 状态/ ,/ 可以/ 描述/ 为/ (/ qn/ ,/ o1/ ,/ …/ ,/ on/ )/ ×/ f/ →/ (/ qn/ +/ 1/ ,/ o1/ ,/ …/ ,/ on/ )/ ,/ 其中/ qn/ 为/ 模型/ 当前/ 处于/ 的/ 状态/ ,/ 当/ 某个/ 转移/ 条件/ 发生/ 时/ ,/ 触发/ 相应/ 的/ 转移/ 函数/ 对模型/ 进行/ 改变/ :/ 一是/ 对模型/ 进行/ 状态/ 转移/ ,/ 即/ 由/ qn/ 转化/ 为/ qn/ +/ 1/ ,/ 二是/ 对/ 访问/ 客体/ 的/ 访问/ 属性/ 进行/ 变更/ ,/ 即/ 由/ o1/ 转化/ 为/ o1/ 等/ ./ 转移/ 函数/ 分为/ 两类/ :/ 满足/ 安全/ 要求/ 的/ 转移/ 函数/ 和/ 不/ 满足/ 安全/ 要求/ 的/ 转移/ 函数/ ./ 满足/ 安全/ 要求/ 的/ 转移/ 函数/ 可以/ 使/ 模型/ 转移/ 到/ 系统/ 的/ 安全/ 状态/ ,/ 不/ 满足/ 安全/ 要求/ 的/ 转移/ 函数/ 将/ 使/ 模型/ 转移/ 到/ 系统/ 的/ 不/ 安全/ 状态/ ./ 这样/ ,/ KFUR/ 模型/ 可以/ 表示/ 为/ 七元/ 组/ :/ KFUR/ 模型/ 安全/ 运行/ 的/ 充分/ 必要条件/ 为/ :/ 不/ 存在/ 状态/ 转移/ 使/ 模型/ 进入/ 不/ 安全/ 状态/ ./ 如果/ 状态/ 转移/ 始终/ 发生/ 在/ 安全/ 状态/ 之间/ ,/ 则/ 该/ 模型/ 安全/ 运行/ ,/ 如果/ 模型/ 状态/ 转移/ 到/ 了/ 不/ 安全/ 状态/ ,/ 则/ 表示/ 有/ 违反/ 安全性/ 的/ 行为/ 发生/ ./ 3.2/ 内核/ 函数/ 使用/ 规则/ 的/ KFUR/ 安全/ 模型/ 内核/ 函数/ 使用/ 规则/ KFUR/ 安全/ 模型/ 的/ 访问/ 主体/ 为/ 所有/ 调用/ 内核/ 函数/ 的/ 内核/ 扩展/ ;/ 访问/ 客体/ 为/ 内核/ 函数/ 使用/ 规则/ 中/ 涉及/ 的/ 内核/ 函数/ 、/ 变量/ 和/ 内存/ 区域/ ,/ 访问/ 方式/ 主要/ 有/ 3/ 种/ :/ 只读/ 、/ 可写/ 和/ 可/ 调用/ ;/ 系统/ 状态/ 为/ 内核/ 函数/ 使用/ 规则/ 中/ 的/ 状态/ ;/ 转移/ 条件/ 为/ 对/ 内核/ 函数/ 使用/ 规则/ 中/ 涉及/ 的/ 内核/ 函数/ 进行/ 调用/ ;/ 转移/ 函数/ 即/ 为/ 内核/ 函数/ 使用/ 规则/ 中/ 的/ 规则/ ,/ 即/ 判断/ 当前/ 状态/ 能否/ 进行/ 相应/ 的/ 操作/ ,/ 如果/ 允许/ ,/ 则/ 转移/ 到/ 另/ 一个/ 安全/ 状态/ ;/ 如果/ 规则/ 不/ 允许/ ,/ 则/ 转移/ 到/ 不/ 安全/ 状态/ ./ 下面/ 以/ 自旋/ 锁为例/ 对/ 内核/ 函数/ 使用/ 规则/ 的/ KFUR/ 安全/ 模型/ 进行/ 描述/ ./ 自旋/ 锁/ 的/ 使用/ 规则/ 有/ :/ (/ 1/ )/ 自旋/ 锁/ 在/ 使用/ 前/ 必须/ 进行/ 初始化/ ;/ (/ 2/ )/ 自旋/ 锁/ 不能/ 在/ 未/ 被/ 加锁/ 之前/ 解锁/ ./ 如图/ 2/ 所示/ 为/ e1000/ _/ read/ _/ eeprom/ 函数/ 的/ 源代码/ ,/ 代码/ 中/ 使用/ 了/ e1000/ _/ eeprom/ _/ lock/ 自旋/ 锁/ ,/ 在/ 调用函数/ e1000/ _/ do/ _/ read/ _/ eeprom/ 之前/ 调用/ spin/ _/ lock/ 加锁/ 函数/ 进行/ 加锁/ ,/ 在/ e1000/ _/ do/ _/ read/ _/ eeprom/ 函数/ 执行/ 完毕/ 后/ 调用/ spin/ _/ unlock/ 解锁/ 函数/ 解锁/ ./ 1/ ./ staticDEFINE/ _/ SPINLOCK/ (/ e1000/ _/ eeprom/ _/ lock/ )/ ;/ 2/ ./ s32e1000/ _/ read/ _/ eeprom/ (/ structe1000/ _/ hw/ / hw/ ,/ u16offset/ ,/ 3/ ./ {/ 4/ ./ s32ret/ ;/ 5/ ./ spin/ _/ lock/ (/ &/ e1000/ _/ eeprom/ _/ lock/ )/ ;/ 6/ ./ ret/ =/ e1000/ _/ do/ _/ read/ _/ eeprom/ (/ hw/ ,/ offset/ ,/ words/ ,/ data/ )/ ;/ 7/ ./ spin/ _/ unlock/ (/ &/ e1000/ _/ eeprom/ _/ lock/ )/ ;/ 8/ ./ returnret/ ;/ 9/ ./ }/ 在/ 第/ 5/ 行/ 代码执行/ 完毕/ 时/ 自旋/ 锁/ e1000/ _/ eeprom/ _/ lock/ 处于/ 加锁/ 状态/ ,/ 自旋/ 锁/ 内核/ 函数/ 使用/ 规则/ 的/ KFUR/ 安全/ 模型/ 如下/ ,/ 其中/ 只读/ 访问/ 方式/ 使用/ 符号/ r/ 表示/ ,/ 可/ 写访问/ 方式/ 使用/ 符号/ w/ 表示/ ,/ 可/ 调用/ 访问/ 方式/ 使用/ 符号/ c/ 表示/ ./ S/ =/ {/ e1000/ 网卡/ 驱动/ }/ ;/ O/ =/ {/ DEFINE/ _/ SPINLOCK/ ,/ spin/ _/ lock/ ,/ Q/ =/ {/ 0/ ,/ 1/ ,/ 2/ ,/ 3/ ,/ 4/ }/ ;/ p/ (/ DEFINE/ _/ SPINLOCK/ )/ =/ {/ (/ 0/ ,/ c/ )/ }/ ;/ p/ (/ spin/ _/ lock/ )/ =/ {/ (/ 1/ ,/ c/ )/ ,/ (/ 2/ ,/ c/ )/ ,/ (/ 3/ ,/ c/ )/ }/ ;/ p/ (/ spin/ _/ unlock/ )/ =/ {/ (/ 2/ ,/ c/ )/ }/ ;/ p/ (/ e1000/ _/ eeprom/ _/ lock/ )/ =/ {/ (/ 2/ ,/ w/ )/ }/ ;/ q0/ =/ {/ 0/ }/ ;/ qe/ =/ {/ 4/ }/ ;/ A/ =/ {/ callDEFINE/ _/ SPINLOCK/ ;/ callspin/ _/ lock/ ;/ F/ =/ {/ (/ 0/ ,/ DEFINE/ _/ SPINLOCK/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 0/ ,/ w/ }/ )/ ×/ f/ →/ (/ 1/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 1/ ,/ w/ }/ )/ ,/ (/ 1/ ,/ spin/ _/ lock/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 1/ ,/ w/ }/ )/ ×/ f/ →/ (/ 2/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 2/ ,/ w/ }/ )/ ,/ (/ 2/ ,/ spin/ _/ lock/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 2/ ,/ w/ }/ )/ ×/ f/ →/ (/ 2/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 2/ ,/ w/ }/ )/ ,/ (/ 2/ ,/ spin/ _/ unlock/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 2/ ,/ w/ }/ )/ ×/ f/ →/ (/ 3/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 3/ ,/ w/ }/ )/ ,/ (/ 3/ ,/ spin/ _/ lock/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 3/ ,/ w/ }/ )/ ×/ f/ →/ (/ 2/ ,/ e1000/ _/ eeprom/ _/ lock/ {/ 2/ ,/ w/ }/ )/ ,/ (/ 0/ ,/ spin/ _/ lock/ ,/ e1000/ _/ eeprom/ _/ lock/ )/ ×/ f/ →/ Page5/ (/ 4/ ,/ e1000/ _/ eeprom/ _/ lock/ )/ ,/ (/ 0/ ,/ spin/ _/ unlock/ ,/ e1000/ _/ eeprom/ _/ lock/ )/ ×/ f/ →/ (/ 4/ ,/ e1000/ _/ eeprom/ _/ lock/ )/ ,/ (/ 1/ ,/ spin/ _/ unlock/ ,/ e1000/ _/ eeprom/ _/ lock/ )/ ×/ f/ →/ (/ 4/ ,/ e1000/ _/ eeprom/ _/ lock/ )/ ,/ (/ 3/ ,/ spin/ _/ unlock/ ,/ e1000/ _/ eeprom/ _/ lock/ )/ ×/ f/ →/ (/ 4/ ,/ e1000/ _/ eeprom/ _/ lock/ )/ }/ ./ 对于/ 如/ 上/ 模型/ 的/ 转移/ 函数/ ,/ 仅/ 标出/ 了/ 访问/ 客体/ 发生变化/ 的/ 访问/ 方式/ ./ 该/ 模型/ 安全/ 运行/ 的/ 条件/ 是/ 不/ 存在/ 某次/ 状态/ 转移/ 使/ 安全/ 模型/ 转移/ 到/ 状态/ 4.4/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 如图/ 3/ 所示/ ,/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 由/ 三/ 部分/ 组成/ :/ 内核/ 函数/ 使用/ 规则/ 库/ 、/ 检测/ 标记/ 和/ 动态/ 检测器/ ./ 内核/ 函数/ 使用/ 规则/ 库中/ 包含/ 被/ 检查/ 内核/ 函数/ 使用/ 规则/ 的/ KFUR/ 安全/ 模型/ 描述/ ,/ 作为/ 动态/ 检测器/ 进行/ 检测/ 的/ 依据/ ./ 检测/ 标记/ 为/ 插入/ 到/ 内核/ 扩展/ 代码/ 中/ 的/ 标记/ ,/ 在/ 运行/ 时/ ,/ 检测/ 标记/ 触发/ 动态/ 检测器/ 进行/ 检测/ ./ 如果/ 发现异常/ ,/ 则/ 通知/ 操作系统/ 内核/ 终止/ 内核/ 扩展/ 的/ 运行/ ./ 本文/ 在/ Linux/ 操作系统/ 上/ 实现/ 了/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ ./ 4.1/ 节对/ 内核/ 函数/ 使用/ 规则/ 库/ 进行/ 介绍/ ,/ 4.2/ 节对/ 检测/ 标记/ 进行/ 介绍/ ,/ 4.3/ 节对/ 动态/ 检测器/ 进行/ 介绍/ ./ 4.1/ 内核/ 函数/ 使用/ 规则/ 库/ 内核/ 函数/ 使用/ 规则/ 库中/ 的/ 内核/ 函数/ 使用/ 规则/ 基于/ KFUR/ 模型/ 实现/ ./ 为了/ 提升/ 访问/ 内核/ 函数/ 使用/ 规则/ KFUR/ 模型/ 中/ 访问/ 方式/ 相关/ 数据/ 的/ 性能/ ,/ 本文/ 设计/ 了/ 快速/ Hash/ 算法/ ,/ 用来/ 存储/ 访问/ 方式/ 相关/ 数据/ ./ 访问/ 客体/ 分为/ 两类/ :/ 一类/ 是/ 变量/ 和/ 函数/ ,/ 另一类/ 是/ 内存/ 区域/ ./ 如果/ 访问/ 客体/ 为/ 变量/ 或/ 函数/ ,/ 则/ 采用/ 一种/ 简单/ 的/ Hash/ 算法/ 存储/ ./ 假定/ 变量/ 或/ 函数/ 的/ 地址/ 为/ A/ ,/ Hash/ 表/ 大小/ 为/ N/ ,/ Hash/ 值为/ K/ ,/ 则/ 该/ Hash/ 算法/ 的/ Hash/ 函数/ 如下/ :/ Hash/ 值/ 即/ 为/ 变量/ 地址/ 或/ 函数/ 地址/ 在/ 哈希/ 表中/ 的/ 位置/ ./ 为了/ 处理/ 发生/ 碰撞/ 即该/ 位置/ 已经/ 存有/ 其它/ 变量/ 地址/ 或/ 函数/ 地址/ 的/ 情况/ ,/ 哈希/ 算法/ 为/ 每个/ 位置/ 开辟/ 了/ 一个/ 小/ 的/ 碰撞/ 处理表/ ,/ 变量/ 地址/ 或/ 函数/ 地址/ 存放/ 在/ 碰撞/ 处理表/ 中/ 的/ 位置/ 采用/ 和/ 如/ 上/ 哈希/ 函数/ 类似/ 的/ 计算方法/ ,/ 即用/ 变量/ 或/ 函数/ 的/ 地址/ 和/ 碰撞/ 处理表/ 的/ 大小/ 做模/ 运算/ ./ 如果/ 该/ 位置/ 仍然/ 存在/ 冲突/ ,/ 从/ 该/ 位置/ 起/ 依次/ 查询/ 是否/ 有/ 空位/ ,/ 直到/ 找到/ 空位/ 为止/ ./ 如果/ 在/ 某/ 一/ 位置/ 的/ 碰撞/ 处理表/ 中/ 没有/ 空位/ ,/ 则/ 到/ 哈希/ 表下/ 一/ 位置/ 的/ 碰撞/ 处理表/ 中/ 寻找/ 空位/ ./ 该/ 算法/ 能够/ 实现/ 对/ 变量/ 或/ 函数/ 地址/ 的/ 快速/ 添加/ 、/ 查询/ 和/ 删除/ ./ 在/ 实际/ 应用/ 中/ ,/ 存在/ 大量/ 查询/ 内存/ 区域/ 子/ 区间/ 的/ 访问/ 方式/ 的/ 情况/ ,/ 比如/ 需要/ 对/ 某个/ 结构/ 体中/ 的/ 某/ 一项/ 是否/ 允许/ 被/ 访问/ 进行/ 查询/ ./ 例如/ 在/ 表/ 2/ 中/ 存放/ 了/ 一些/ 内存/ 区域/ 的/ 信息/ ,/ 内存/ 区域/ 的/ 信息/ 由/ 内存/ 起始/ 地址/ 和/ 内存大小/ 两/ 部分/ 构成/ ./ 在/ 实际/ 应用/ 中/ 存在/ 如表/ 3/ 所示/ 的/ 查询/ ./ 例如/ 表/ 3/ 中/ 第/ 1/ 项为/ 对/ 内存/ 起始/ 地址/ 为/ 2155/ ,/ 内存大小/ 为/ 3/ 的/ 内存/ 区域/ 的/ 访问/ 方式/ 进行/ 查询/ ,/ 可以/ 看到/ 表/ 2/ 的/ 第/ 1/ 项为/ 内存/ 起始/ 地址/ 为/ 2140/ ,/ 内存大小/ 为/ 33/ 的/ 内存/ 区域/ ,/ 因此/ 表/ 3/ 中/ 第/ 1/ 项/ 查询/ 的/ 内存/ 区域/ 应当/ 允许/ 被/ 访问/ ./ 针对/ 这种/ 特定/ 的/ 场景/ ,/ 本文/ 设计/ 了/ 一种/ 新型/ 的/ 快速/ 哈希/ 算法/ 进行/ 存储/ ./ 该/ 哈希/ 算法/ 的/ 哈希/ 函数/ 为/ :/ 首先/ 得到/ 内存/ 区域/ 的/ 大小/ 为/ 几位数/ ,/ 假设/ 为/ n/ 位数/ ,/ 内存/ 起始/ 地址/ 为/ As/ ,/ 然后/ 按照/ 如下/ 公式/ 计算/ 哈希/ 值/ :/ 123/ …/ 123/ …/ 哈希/ 值/ 即/ 为/ 内存/ 区域/ 在/ 哈希/ 表中/ 的/ 位置/ ./ 如果/ 该/ 位置/ 已经/ 存储/ 了/ 其它/ 内存/ 区域/ ,/ 采用/ 如/ 算法/ 1/ 所示/ 方法/ 进行/ 碰撞/ 处理/ ./ Page6/ 算法/ 1/ ./ 内存/ 区域/ 存储/ 碰撞/ 处理/ 算法/ ./ 输入/ :/ 内存/ 区域/ 起始/ 地址/ ,/ 内存/ 区域/ 大小/ 1/ ./ 初始化/ 循环/ 变量/ i/ ←/ 1/ ;/ 2/ ./ 计算/ As/ // 10/ (/ n/ +/ i/ )/ 的/ 值/ ,/ 并/ 判断/ 该值/ 是否/ 为/ 0/ ,/ 如果/ 不为/ 0/ ,/ 执行/ 下/ 一步/ ;/ 如果/ 为/ 0/ ,/ 跳转/ 到步/ 4/ ;/ 3/ ./ 内存/ 区域/ 存储/ 的/ 位置/ 为/ :/ (/ As/ // 10/ (/ n/ +/ i/ )/ )/ %/ N/ ,/ 如果/ Hash/ 表中/ 该/ 位置/ 为空/ ,/ 则/ 将/ 内存/ 区域/ 存储/ 到/ 该/ 位置/ ,/ 算法/ 执行/ 结束/ ;/ 否则/ 跳转/ 到步/ 5/ ;/ 4/ ./ 从/ 位置/ (/ As/ // 10/ (/ n/ +/ i/ -/ 1/ )/ +/ 1/ )/ 开始/ 顺序/ 查找/ Hash/ 表/ ,/ 如果/ Hash/ 表中/ 该/ 位置/ 为空/ ,/ 则/ 将/ 内存/ 区域/ 存储/ 到/ 该/ 位置/ ,/ 算法/ 执行/ 结束/ ,/ 如果/ 找/ 不到/ 空/ 位置/ 说明/ Hash/ 表已/ 满/ 报错/ ;/ 5/ ./ i/ ←/ i/ +/ 1.4/ ./ 2/ 检测/ 标记/ 在/ 内核/ 扩展/ 中/ 需要/ 添加/ 的/ 检测/ 标记/ 主要/ 有/ 两类/ :/ 一类/ 是/ 注册/ 和/ 初始化/ 标记/ ,/ 即/ 在/ 待/ 检测/ 变量/ 定义/ 时/ ,/ 添加/ 的/ 向/ 动态/ 检测器/ 注册/ 和/ 初始化/ 该待/ 检测/ 变量/ 的/ 标记/ ;/ 另一类/ 是/ 检测/ 标记/ ,/ 即/ 在/ 内核/ 扩展/ 调用/ 内核/ 函数/ 前/ ,/ 添加/ 的/ 触发/ 动态/ 检测器/ 进行/ 检测/ 的/ 标记/ ./ 第一类/ 标记/ 需要/ 将/ 待/ 检测/ 变量/ 、/ 待/ 检测/ 变量/ 所/ 要/ 遵守/ 的/ 内核/ 函数/ 使用/ 规则/ 作为/ 参数传递/ 给/ 动态/ 检测器/ ;/ 第二类/ 标记/ 需要/ 将/ 待/ 检测/ 变量/ 、/ 待/ 调用函数/ 、/ 所/ 要/ 遵守/ 的/ 内核/ 函数/ 使用/ 规则/ 作为/ 参数传递/ 给/ 动态/ 检测器/ ./ 检测/ 标记/ 的/ 添加/ 可以/ 由/ 编译器/ 来/ 完成/ ./ 仍然/ 以/ e1000/ 网卡/ 驱动/ e1000/ _/ read/ _/ eeprom/ 函数/ 中/ 使用/ 的/ e1000/ _/ eeprom/ _/ lock/ 自旋/ 锁为例/ 进行/ 说明/ ./ 从图/ 2/ 中/ 可以/ 看到/ ,/ 自旋/ 锁/ e1000/ _/ eeprom/ _/ lock/ 作为/ 全局变量/ 被/ 定义/ 和/ 初始化/ ./ 向/ 动态/ 检测器/ 注册/ 和/ 初始化/ 待/ 检测/ 变量/ e1000/ _/ eeprom/ _/ lock/ 自旋/ 锁/ 的/ 标记/ 被/ 添加/ 到/ e1000/ 网卡/ 驱动/ 的/ 初始化/ 函数/ e1000/ _/ probe/ 中/ ,/ 自旋/ 锁/ e1000/ _/ eeprom/ _/ lock/ 、/ 自旋/ 锁/ 应当/ 遵守/ 的/ 内核/ 函数/ 使用/ 规则/ 作为/ 函数/ 参数传递/ 给/ 动态/ 检测器/ ./ 在/ e1000/ _/ read/ _/ eeprom/ 函数/ 中/ 调用/ spin/ _/ lock/ 加锁/ 函数/ 之前/ 插入/ 检测/ 标记/ ,/ 将/ 自旋/ 锁/ e1000/ _/ eeprom/ _/ lock/ 、/ 函数/ spin/ _/ lock/ 和/ 自旋/ 锁/ 应当/ 遵守/ 的/ 内核/ 函数/ 使用/ 规则/ 作为/ 函数参数/ 进行/ 传递/ ,/ 同样/ 也/ 在/ 调用/ spin/ _/ unlock/ 函数/ 之前/ 插入/ 检测/ 标记/ ./ 4.3/ 动态/ 检测器/ 动态/ 检测器/ 在/ 运行/ 时/ 对/ 内核/ 扩展/ 进行/ 检测/ ./ 注册/ 和/ 初始化/ 标记/ 触发/ 动态/ 检测器/ 完成/ 对/ 需要/ 被/ 检测/ 的/ 变量/ 进行/ 注册/ 和/ 初始化/ ,/ 动态/ 检测器/ 将/ 该/ 变量/ 作为/ 访问/ 客体/ 进行/ 存储/ ./ 例如/ ,/ 在/ 对待/ 检测/ 的/ 自旋/ 锁/ 进行/ 注册/ 和/ 初始化/ 后/ ,/ 该/ 自旋/ 锁/ 作为/ 访问/ 客体/ 具有/ 在/ 状态/ 1/ 可写/ 的/ 访问/ 属性/ ./ 检测/ 标记/ 根据/ 内核/ 函数/ 使用/ 规则/ 对/ 当前/ 函数调用/ 是否/ 正确/ 进行/ 检测/ ./ 如果/ 对/ 内核/ 函数调用/ 正确/ ,/ 则/ 允许/ 该/ 内核/ 函数/ 运行/ ,/ 同时/ 完成/ KFUR/ 模型/ 的/ 状态/ 转移/ ./ 例如/ ,/ 被/ 初始化/ 的/ 自旋/ 锁/ 在/ 调用/ 加锁/ 函数/ spin/ _/ lock/ 后/ ,/ 自旋/ 锁/ 处于/ KFUR/ 模型/ 的/ 状态/ 2/ ,/ 在/ 调用/ 解锁/ 函数/ spin/ _/ unlock/ 后/ ,/ 自旋/ 锁/ 处于/ 内核/ 函数/ 使用/ 规则/ KFUR/ 模型/ 的/ 状态/ 3/ ./ 如果/ 在/ 某/ 状态/ 调用/ 不/ 允许/ 调用/ 的/ 函数/ 或/ 访问/ 不/ 允许/ 访问/ 的/ 内存/ 时/ ,/ 动态/ 检测器/ 会/ 向/ 操作系统/ 内核/ 报错/ ,/ 操作系统/ 内核/ 终止/ 该/ 内核/ 扩展/ 的/ 运行/ ./ 例如/ ,/ 如果/ 在/ 状态/ 3/ 时/ 调用/ spin/ _/ unlock/ 函数/ ,/ 自旋/ 锁/ 将/ 会/ 转移/ 到/ KFUR/ 模型/ 的/ 状态/ 4/ ,/ 即/ 到达/ 了/ 不/ 安全/ 状态/ ,/ 因为/ 这一/ 调用/ 违反/ 了/ “/ 自旋/ 锁/ 不能/ 在/ 未/ 被/ 加锁/ 之前/ 解锁/ ”/ 的/ 自旋/ 锁/ 使用/ 规则/ ./ 5/ 安全性/ 评测/ 本节/ 对/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 进行/ 安全性/ 评测/ ./ 5.1/ 节/ 采用/ 错误/ 注入/ 测试/ 的/ 方法/ 对系统/ 进行/ 评测/ ,/ 5.2/ 节将/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 和/ SDV/ 进行/ 比较/ ./ 5.1/ 错误/ 注入/ 测试/ 为了/ 对/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ 检测/ 能力/ 进行/ 评测/ ,/ 本文/ 采用/ 错误/ 注入/ 测试方法/ ./ 其中/ ,/ Linux/ 内核/ 版本/ 为/ 2.6/ ./ 36.1/ ,/ GCC/ 编译器/ 的/ 版本/ 是/ 4.3/ ,/ 选择/ e1000/ 网卡/ 驱动/ 、/ SATA/ 硬盘/ 驱动/ 和/ HDA/ 声卡/ 驱动/ 内核/ 扩展/ 分别/ 进行/ 测试/ ./ 对于/ e1000/ 网卡/ 驱动/ ,/ 以/ 自旋/ 锁/ 、/ 内存/ 和/ 网络/ 数据包/ 处理/ 三类/ 内核/ 函数/ 使用/ 规则/ 进行/ 测试/ ./ 首先/ 选择/ 自旋/ 锁/ 进行/ 测试/ ./ 如上/ 文/ 所述/ ,/ 函数/ e1000/ _/ read/ _/ eeprom/ 中/ 配对/ 使用/ 了/ 自旋/ 锁/ 加锁/ 函数/ spin/ _/ lock/ 和/ 自旋/ 锁/ 释放/ 函数/ spin/ _/ unlock/ ./ 将/ 函数调用/ spin/ _/ lock/ 删除/ ,/ 这样/ 就/ 违反/ 了/ 自旋/ 锁/ 不能/ 在/ 未/ 被/ 加锁/ 之前/ 解锁/ 的/ 使用/ 规则/ ./ 如果/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 正常/ 运行/ ,/ 应当/ 能够/ 向/ 操作系统/ 内核/ 进行/ 错误报告/ ,/ 并且/ e1000/ 网卡/ 驱动/ 内核/ 扩展/ 的/ 运行/ 将/ 被/ 终止/ ./ 动态/ 检测器/ 采用/ 向/ Linux/ 操作系统/ 的/ 日志/ 记录/ 文件/ 输出/ 错误信息/ 的/ 方式/ 进行/ 报错/ ./ 运行/ e1000/ 网卡/ 驱动/ ,/ 在/ Linux/ 操作系统/ 日志/ 记录/ 文件/ 中/ 找到/ 了/ 动态/ 检测器/ 输出/ 的/ 错误信息/ ,/ 并且/ e1000/ 网卡/ 驱动/ 内核/ 扩展/ 的/ 运行/ 被/ 终止/ ./ Linux/ 操作系统/ 内核/ 提供/ 给/ 内核/ 扩展/ 的/ 内存/ 函数/ 接口/ 有/ 内存/ 分配/ 函数/ malloc/ 、/ 在/ 一段/ 内存/ 中/ 填充/ 某个/ 给定/ 值/ 的/ 函数/ memset/ 、/ 内存/ 区域/ 拷贝/ 函数/ memcpy/ 、/ 内存/ 释放/ 函数/ free/ 等/ ./ 在/ 使用/ 内存/ 函数/ 接口/ 时/ ,/ 被/ free/ 函数/ 释放/ 的/ 内存/ 不能/ 成为/ memset/ 和/ memcpy/ 函数/ 的/ 参数/ ./ Page7e1000/ 网卡/ 驱动/ 函数/ e1000/ _/ setup/ _/ tx/ _/ resources/ 中/ 配对/ 使用/ 了/ 内存/ 分配/ 函数/ vmalloc/ 和/ 内存/ 释放/ 函数/ vfree/ ./ 在/ vfree/ 函数/ 后/ 添加/ memset/ 函数/ 填充/ 被/ 释放/ 的/ 内存/ ./ 运行/ e1000/ 网卡/ 驱动/ ,/ 同样/ 可以/ 在/ Linux/ 操作系统/ 的/ 日志/ 记录/ 文件/ 中/ 找到/ 动态/ 检测器/ 输出/ 的/ 错误信息/ ./ Linux/ 操作系统/ 的/ 网络/ 模块/ 为/ 内核/ 扩展/ 提供/ 了/ 很多/ 接口函数/ ,/ 如图/ 4/ 所示/ ./ 其中/ ,/ 前/ 两个/ 函数/ 用于/ 分配/ sk/ _/ buff/ 结构/ 体/ ,/ 第/ 3/ 个/ 到/ 第/ 6/ 个/ 函数/ 用于/ 释放/ sk/ _/ buff/ 结构/ 体/ ,/ 这/ 4/ 个/ 释放/ 函数/ 在/ 不同/ 情况/ 下/ 被/ 使用/ ./ 其它/ 函数/ 用于/ 对/ sk/ _/ buff/ 结构/ 体/ 进行/ 不同/ 的/ 操作/ ./ 因此/ ,/ 这些/ 函数/ 不能/ 在/ sk/ _/ buff/ 结构/ 体/ 被/ 释放/ 后/ 使用/ ./ 另外/ ,/ 函数/ skb/ _/ pull/ 用于/ 从/ 数据包/ 的/ 头部/ 删除/ 数据/ ./ 因此/ ,/ 这个/ 函数/ 不/ 应当/ 出现/ 在/ e1000/ 网卡/ 驱动/ 内核/ 扩展/ 中/ ./ 1/ ./ structsk/ _/ buff/ / alloc/ _/ skb/ (/ unsignedintlen/ ,/ intpriority/ )/ ;/ 2/ ./ structsk/ _/ buff/ / dev/ _/ alloc/ _/ skb/ (/ unsignedintlen/ )/ ;/ 3/ ./ voidkfree/ _/ skb/ (/ structsk/ _/ buff/ / skb/ )/ ;/ 4/ ./ voiddev/ _/ kfree/ _/ skb/ (/ structsk/ _/ buff/ / skb/ )/ ;/ 5/ ./ voiddev/ _/ kfree/ _/ skb/ _/ irq/ (/ structsk/ _/ buff/ / skb/ )/ ;/ 6/ ./ voiddev/ _/ kfree/ _/ skb/ _/ any/ (/ structsk/ _/ buff/ / skb/ )/ ;/ 7/ ./ void/ / skb/ _/ put/ (/ structsk/ _/ buff/ / skb/ ,/ intlen/ )/ ;/ 8/ ./ unsignedchar/ / skb/ _/ push/ (/ structsk/ _/ buff/ / skb/ ,/ intlen/ )/ ;/ 9/ ./ intskb/ _/ tailroom/ (/ structsk/ _/ buff/ / skb/ )/ ;/ 10/ ./ intskb/ _/ headroom/ (/ structsk/ _/ buff/ / skb/ )/ ;/ 11/ ./ voidskb/ _/ reserve/ (/ structsk/ _/ buff/ / skb/ ,/ intlen/ )/ ;/ 12/ ./ unsignedchar/ / skb/ _/ pull/ (/ structsk/ _/ buff/ / skb/ ,/ intlen/ )/ ;/ 13/ ./ intskb/ _/ is/ _/ nonlinear/ (/ structsk/ _/ buff/ / skb/ )/ ;/ 14/ ./ intskb/ _/ headlen/ (/ structsk/ _/ buff/ / skb/ )/ ;/ 数据包/ 发送/ 函数/ e1000/ _/ xmit/ _/ frame/ 使用/ 了/ sk/ _/ buff/ 结构/ 体/ ./ 在/ 变量/ 定义/ 后/ ,/ 调用/ dev/ _/ kfree/ _/ skb/ _/ any/ 释放/ sk/ _/ buff/ 结构/ 体/ ,/ 然后/ 调用/ skb/ _/ transport/ _/ offset/ 访问/ 被/ 释放/ 的/ sk/ _/ buff/ 结构/ 体/ ./ 在/ 运行/ 时/ 动态/ 检测器/ 成功/ 检测/ 出/ 了/ 异常/ 并/ 报告/ 给/ 了/ linux/ 操作系统/ 内核/ ./ 在/ e1000/ _/ xmit/ _/ frame/ 函数/ 中/ 调用/ skb/ _/ pull/ 函数/ ,/ 同样/ 也/ 被/ 动态/ 检测器/ 成功/ 检测/ ./ 除/ 对/ e1000/ 网卡/ 驱动/ 进行/ 上述/ 针对性/ 注入/ 测试/ 外/ ,/ 还/ 进行/ 了/ 其它/ 一些/ 针对性/ 注入/ 测试/ ,/ 测试/ 结果/ 如表/ 4/ 所示/ ./ 从表/ 4/ 可以/ 看出/ ,/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 能够/ 检测/ 出/ 所有/ 被/ 注入/ 的/ 错误/ ./ 另外/ ,/ 对于/ e1000/ 网卡/ 驱动/ 还/ 进行/ 了/ 随机/ 测试/ ./ 每次/ 测试/ 随机/ 对/ 一些/ 内核/ 函数调用/ 进行/ 删除/ 或/ 随机/ 添加/ 一些/ 内核/ 函数调用/ ,/ 导致/ 内核/ 函数/ 使用/ 规则/ 被/ 违反/ ./ 从表/ 4/ 可以/ 看出/ ,/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 每次/ 都/ 能/ 成功/ 检测/ ./ 设备/ 测试方法/ 测试用例/ 个数/ 成功/ 检测/ 个数/ e1000/ 网卡/ 针对性/ 错误/ 注入/ 30SATA/ 硬盘/ 针对性/ 错误/ 注入/ 20HDA/ 声卡/ 针对性/ 错误/ 注入/ 25SATA/ 硬盘/ 驱动/ 中/ 存在/ 大量/ 自旋/ 锁/ 相关/ 的/ 内核/ 函数调用/ ,/ 采用/ 和/ e1000/ 网卡/ 驱动/ 类似/ 的/ 方法/ 进行/ 了/ 安全性/ 评测/ ./ 对于/ HDA/ 声卡/ 驱动/ ,/ 对/ 自旋/ 锁/ 、/ 内存/ 进行/ 了/ 安全性/ 评测/ ,/ 评测/ 结果/ 如表/ 4/ 所示/ ./ 实验/ 结果表明/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 均/ 能/ 成功/ 检测/ 错误/ ./ 5.2/ 相关/ 技术/ 比较/ SDV/ 采用/ 模型/ 检测/ 方法/ 对/ Windows/ 操作系统/ 的/ 设备/ 驱动/ 是否/ 遵守/ 内核/ 函数/ 使用/ 规则/ 进行/ 检测/ ,/ 并/ 找出/ 了/ 很多/ Windows/ 操作系统/ 设备/ 驱动/ 违反/ 内核/ 函数/ 使用/ 规则/ 的/ 问题/ ./ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 在/ 如下/ 两/ 方面/ 优于/ SDV/ ./ 首先/ ,/ SDV/ 是/ 一种/ 静态/ 检测/ 方法/ 而/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 是/ 动态/ 检测/ 方法/ ./ SDV/ 仅能/ 检测/ 出/ 静态/ 存在/ 于/ 设备/ 驱动/ 中/ 违反/ 内核/ 函数/ 使用/ 规则/ 的/ 情况/ ,/ 而/ 对/ 由于/ 系统/ 运行/ 时/ 的/ 安全/ 攻击/ 造成/ 的/ 违反/ 内核/ 函数/ 使用/ 规则/ 的/ 情况/ 则/ 无法/ 检测/ ./ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 能够/ 动态/ 实时/ 检测/ 违反/ 内核/ 函数/ 使用/ 规则/ 的/ 情况/ 并/ 及时/ 向/ 操作系统/ 内核/ 报告/ ,/ 进行/ 相应/ 的/ 处理/ ,/ 保证/ 了/ 操作系统/ 运行/ 时/ 的/ 安全/ ./ 其次/ ,/ SDV/ 采用/ 模型/ 检测/ 技术/ ./ 现有/ 模型/ 检测/ 技术/ 时间/ 开销/ 较大/ ,/ 对于/ 代码/ 量/ 大/ 的/ 设备/ 驱动/ 无法/ 在/ 有限/ 的/ 时间/ 内/ 进行/ 检测/ ,/ 而/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 仅/ 需要/ 很小/ 的/ 开销/ ./ 6/ 性能/ 评测/ 同样/ 采用/ e1000/ 网卡/ 驱动/ 、/ SATA/ 硬盘/ 驱动/ 和/ HDA/ 声卡/ 驱动/ 内核/ 扩展/ 进行/ 性能/ 评测/ ./ 性能/ 评测/ 用于/ 评价/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统对/ 内核/ 扩展/ 性能/ 的/ 影响/ ./ 本文/ 采用/ netperf/ 基准/ 测试程序/ 对/ e1000/ 网卡/ 驱动/ 的/ 性能/ 进行/ 评测/ ./ 实验/ 环境/ 包括/ 一台/ 客户端/ 计算机/ 和/ 一台/ 服务器/ 计算机/ 及/ 千兆/ 网络/ ./ 客户端/ 计算机/ 和/ 服务器/ 计算机/ 的/ 配置/ 如表/ 5/ 所示/ ,/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 实现/ 在/ 客户端/ 计算机/ 中/ ./ Page8CPUIntel/ (/ R/ )/ Core/ (/ TM/ )/ 2Duo/ 内存/ 2GBDDR2/ 硬盘/ 320GB7200r/ // min1TB7200r/ // min/ 网卡/ Intel82540EMGigabit/ 选择/ netperf/ 基准/ 测试程序/ 中/ 的/ TCP/ _/ STREAM/ 、/ UDP/ _/ STREAM/ 、/ TCP/ _/ RR/ 和/ UDP/ _/ RR/ 四种/ 测试/ 分别/ 对/ 原始/ Linux/ 操作系统/ 和/ 添加/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 后/ 的/ Linux/ 操作系统/ 进行/ 测试/ ./ TCP/ _/ STREAM/ 用于/ 对/ TCP/ 的/ 吞吐量/ 进行/ 测试/ ;/ UDP/ _/ STREAM/ 用于/ 对/ UDP/ 的/ 吞吐量/ 进行/ 测试/ ;/ TCP/ _/ RR/ 和/ UDP/ _/ RR/ 用于/ 测试/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 所/ 带来/ 的/ 延迟/ ./ 测试/ 时间/ 均/ 为/ 10s/ ./ TCP/ _/ STREAM/ 的/ 发送缓冲区/ 大小/ 为/ 16384/ 字节/ ,/ 接收缓冲区/ 大小/ 为/ 87380/ 字节/ ./ 每条/ 消息/ 的/ 大小/ 为/ 16384/ 字节/ ./ 在/ UDP/ _/ STREAM/ 测试/ 中/ ,/ 发送/ 端/ UDP/ 套/ 接字/ 的/ 大小/ 为/ 114688/ 字节/ ,/ 接收端/ UDP/ 套/ 接字/ 的/ 大小/ 为/ 114688/ 字节/ ,/ 每条/ 消息/ 的/ 大小/ 为/ 1024/ 字节/ ./ 图/ 5/ 和/ 图/ 6/ 分别/ 为/ TCP/ _/ STREAM/ 、/ UDP/ _/ STREAM/ 吞吐量/ 和/ CPU/ 占用率/ 的/ 测试/ 结果/ ./ 图中/ “/ Linux/ ”/ 表示/ 原始/ Linux/ 操作系统/ 的/ 测试/ 结果/ ,/ “/ KFUR/ ”/ 表示/ 添加/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 后/ 的/ Linux/ 操作系统/ 的/ 测试/ 结果/ ./ 图/ 5TCP/ _/ STREAM/ 和/ UDP/ _/ STREAM/ 测试/ 的/ 吞吐量/ 图/ 6TCP/ _/ STREAM/ 和/ UDP/ _/ STREAM/ 测试/ 的/ CPU/ 占用率/ 对于/ TCP/ _/ STREAM/ 测试/ ,/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 和/ 不/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ 吞吐量/ 基本相同/ ,/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ CPU/ 占用率/ 仅/ 比/ 不/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 高/ 0.15/ %/ ./ UDP/ _/ STREAM/ 和/ TCP/ _/ STREAM/ 测试/ 的/ 结果/ 类似/ ,/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 和/ 不/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ 吞吐量/ 基本相同/ ,/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ CPU/ 占用率/ 比/ 不/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ CPU/ 占用率/ 高/ 1.04/ %/ ./ 在/ TCP/ _/ RR/ 测试/ 和/ UDP/ _/ RR/ 测试/ 中/ ,/ 发送缓冲区/ 的/ 大小/ 为/ 16384/ 字节/ ,/ 接收缓冲区/ 的/ 大小/ 为/ 87380/ 字节/ ./ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 时/ 吞吐量/ 略低于/ 不/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ ,/ CPU/ 占用率/ 略高于/ 不/ 采用/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ ,/ 测试/ 结果/ 分别/ 如图/ 7/ 和/ 图/ 8/ 所示/ ./ 图/ 8TCP/ _/ RR/ 和/ UDP/ _/ RR/ 测试/ 的/ CPU/ 占用率/ 对/ 添加/ 了/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ 硬盘/ 驱动/ 和/ 未修改/ 的/ 硬盘/ 驱动/ 的/ 性能/ 进行/ 比较/ ,/ 首先/ 使用/ dd/ 命令/ 对/ 硬盘/ 读/ 速度/ 、/ 硬盘/ 写/ 速度/ 和/ 硬盘/ 读写/ 混合/ 速度/ 进行/ 测试/ ,/ 测试/ 结果/ 如表/ 6/ 所示/ ./ 硬盘/ 读/ 速度/ 硬盘/ 写/ 速度/ 硬盘/ 读写/ 速度/ 采用/ postmark/ 基准/ 测试程序/ 对/ 多个/ 文件/ 并发/ 访问/ 进行/ 测试/ ./ 设置/ 文件大小/ 下限/ 为/ 10000/ 字节/ ,/ 文件大小/ 上限/ 为/ 20000/ 字节/ ,/ 事务/ 数为/ 50000/ 次/ ,/ Page9/ 并发/ 文件/ 数从/ 1000/ 到/ 2000/ 次/ ,/ 文件/ 读取/ 速度/ 和/ 写入/ 速度/ 分别/ 如图/ 9/ 和/ 图/ 10/ 所示/ ./ 可以/ 看出/ ,/ 加入/ 了/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ 硬盘/ 驱动/ 和/ 未修改/ 的/ 硬盘/ 驱动/ 相比/ 性能/ 相差/ 不大/ ./ 对/ 添加/ 了/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 的/ 声卡/ 驱动/ 和/ 原始/ 声卡/ 驱动/ 进行/ 性能/ 比较/ ,/ 采用/ realplayer/ 和/ soundrecorder/ 分别/ 进行/ 声音/ 的/ 播放/ 和/ 录制/ ,/ 比较/ 其/ CPU/ 占用率/ ,/ 实验/ 结果/ 如图/ 11/ 所示/ ./ 从/ 网卡/ 驱动/ 、/ 硬盘/ 驱动/ 和/ 声卡/ 驱动/ 的/ 实验/ 结果/ 可以/ 看出/ ,/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 对于/ 内核/ 扩展/ 的/ 性能/ 影响/ 不大/ ./ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ 能/ 在/ 保持/ 性能/ 良好/ 的/ 情况/ 下/ 提高/ 内核/ 扩展/ 的/ 安全性/ ./ 7/ 总结/ 内核/ 扩展/ 的/ 安全性/ 对于/ 操作系统/ 十分/ 重要/ ,/ 不/ 安全/ 的/ 内核/ 扩展/ 导致/ 操作系统/ 内核/ 崩溃/ 、/ 机密/ 数据/ 被/ 窃取/ ,/ 带来/ 了/ 巨大/ 的/ 损失/ ./ 本文/ 提出/ KFUR/ 内核/ 扩展/ 安全/ 模型/ 系统/ ,/ 该/ 安全/ 模型/ 系统/ 能以/ 很小/ 的/ 开销/ 对/ 内核/ 扩展/ 调用/ 内核/ 函数/ 时/ ,/ 是否/ 遵守/ 内核/ 函数/ 使用/ 规则/ 进行/ 检测/ ,/ 从而/ 提高/ 内核/ 扩展/ 的/ 安全性/ ./ 接下来/ 将/ 对/ 内核/ 扩展/ 的/ 其它/ 安全性/ 问题/ 进行/ 研究/ ,/ 提出/ 实用/ 的/ 、/ 高性能/ 的/ 提高/ 内核/ 扩展/ 安全性/ 的/ 方法/ ,/ 进一步提高/ 操作系统/ 的/ 安全性/ ./ 致谢/ 本文/ 作者/ 得到/ 了/ 清华大学/ 计算机科学/ 与/ 技术/ 系/ 操作系统/ 实验室/ 的/ 老师/ 和/ 同学/ 们/ 的/ 许多/ 帮助/ 和/ 建议/ ,/ 在/ 此/ 表示感谢/ ./ 感谢/ 审稿人/ 对/ 本文/ 提出/ 宝贵意见/ 和/ 建议/ !/ 

