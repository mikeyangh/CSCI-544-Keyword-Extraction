Page1/ 面向/ MPI/ 代码生成/ 的/ Open64/ 编译器/ 后端/ 赵捷/ 1/ )/ 赵荣彩/ 1/ )/ 韩林/ 1/ )/ 李宝亮/ 2/ )/ 1/ )/ (/ 解放军信息工程大学/ 数学/ 工程/ 与/ 先进/ 计算/ 国家/ 重点/ 实验室/ 郑州/ 450001/ )/ 2/ )/ (/ 国防科学技术大学/ 计算机/ 学院/ 长沙/ 410073/ )/ 摘要/ 随着/ 计算机/ 体系结构/ 的/ 发展/ ,/ 分布式/ 存储/ 结构/ 以/ 其/ 良好/ 的/ 扩展性/ 逐渐/ 占据/ 了/ 高性能/ 计算机/ 体系结构/ 市场/ 的/ 主导地位/ ./ 为了/ 将/ 现有/ 的/ 串行/ 程序转换/ 为/ 能够/ 在/ 高性能/ 计算机/ 上/ 运行/ 的/ 并行程序/ ,/ 研究/ 人员/ 提出/ 了/ 并行/ 化/ 编译器/ ./ 然而/ ,/ 当前/ 面向/ 分布/ 存储/ 并行/ 系统/ 的/ 编译器/ 发展/ 却/ 相对/ 较慢/ ,/ 而/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ 及其/ 相应/ 技术/ 已/ 逐渐/ 成熟/ ./ 一种/ 开发/ 面向/ 分布/ 存储/ 并行/ 系统/ 编译器/ 的/ 可行/ 方法/ 是/ 改进/ 现有/ 的/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ ,/ 使/ 其/ 自动/ 生成/ 能够/ 在/ 分布/ 存储/ 结构/ 高性能/ 计算机/ 上/ 运行/ 的/ MPI/ (/ MessagePassingInterface/ )/ 并行程序/ ./ 因此/ ,/ 该文/ 为/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ Open64/ 设计/ 并/ 实现/ 了/ 一个/ 支持/ MPI/ 代码生成/ 的/ 后/ 端/ ./ 根据/ 分布式/ 并行/ 化/ 编译/ 的/ 特点/ ,/ 主要/ 从/ 自动/ 生成/ 计算/ 划分/ 、/ 改进/ 循环/ 优化/ 和/ 自动/ 生成/ MPI/ 并行/ 代码/ 3/ 个/ 方面/ 对/ Open64/ 进行/ 了/ 改进/ ,/ 使/ 其/ 能够/ 实现/ 面向/ 分布/ 存储/ 的/ 并行/ 化/ 编译/ ./ 实验/ 测试/ 利用/ 带有/ MPI/ 后/ 端的/ Open64/ 对/ 串行/ 程序/ 进行/ 编译/ ,/ 生成/ 的/ MPI/ 并行/ 代码/ 可/ 直接/ 运行/ 在/ 具有/ 分布/ 存储/ 结构/ 的/ 高性能/ 计算机/ 上/ ./ 通过/ 将/ 该/ MPI/ 并行/ 代码/ 的/ 执行/ 效率/ 与/ 传统/ 面向/ 分布/ 存储/ 并行/ 系统/ 编译器/ 生成/ 的/ MPI/ 代码/ 效率/ 进行/ 比较/ ,/ 并行/ 效率/ 有/ 明显/ 的/ 提升/ ./ 关键词/ 高性能/ 计算/ ;/ 分布/ 存储/ ;/ 并行/ 化/ 编译系统/ ;/ Open64/ 编译器/ ;/ MPI/ 代码/ 1/ 引言/ 从近/ 五年/ TOP500/ 公布/ 的/ 超级计算机/ 的/ 体系结构/ 发展趋势/ 不难看出/ ,/ 分布/ 存储/ 结构/ 已/ 占据/ 了/ 高性能/ 计算机/ 体系结构/ 的/ 绝对/ 主导地位/ ./ 分布/ 存储/ 结构/ 具有/ 良好/ 的/ 可扩展性/ ,/ 能够/ 更好/ 地/ 适应/ 不同/ 用户/ 的/ 需求/ ./ 但/ 相对/ 于/ 并行/ 硬件/ 的/ 发展/ 而言/ ,/ 并行/ 软件/ 的/ 发展/ 相对/ 滞后/ ./ 如何/ 充分利用/ 飞速发展/ 的/ 并行/ 硬件资源/ ,/ 主要/ 面临/ 的/ 一个/ 问题/ 就是/ 如何/ 将/ 现有/ 的/ 串行/ 程序转换/ 为/ 能够/ 在/ 高性能/ 计算机/ 上/ 运行/ 的/ 并行程序/ ./ 目前/ ,/ 解决/ 这一/ 问题/ 最/ 有效/ 的/ 方法/ 就是/ 利用/ 并行/ 化/ 编译系统/ ./ 根据/ 体系结构/ 的/ 特点/ ,/ 并行/ 化/ 编译器/ 可以/ 分为/ 向/ 量化/ 并行/ 编译器/ 、/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ 和/ 面向/ 分布/ 存储/ 并行/ 系统/ 的/ 编译器/ ./ 虽然/ 面向/ 分布/ 存储/ 并行/ 系统/ 的/ 编译器/ 研究/ 也/ 取得/ 了/ 一些/ 成果/ ,/ 但/ 仍/ 有/ 许多/ 问题/ 亟待解决/ ./ 面向/ 分布/ 存储/ 并行/ 系统/ 的/ 编译器/ 开发/ 比较/ 困难/ ,/ 目前/ 大多数/ 研究/ 都/ 是/ 基于/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ 进行/ 改进/ ,/ 使/ 其/ 能够/ 生成/ 适于/ 分布/ 存储/ 结构/ 的/ 并行程序/ ./ Kwon/ 等/ 人/ 基于/ SUIF/ 编译器/ [/ 1/ ]/ 实现/ 了/ 面向/ MPI/ 并行/ 的/ 后/ 端/ [/ 2/ ]/ ,/ 依靠/ 局部/ 插桩/ 技术/ 来/ 分析/ 原来/ SUIF/ 后端/ 生成/ 的/ 代码/ 的/ 信息/ ./ Ferner/ [/ 3/ ]/ 基于/ SUIF/ 编译器/ 设计/ 了/ 分布/ 存储/ 并行/ 编译/ 工具/ Paraguin/ ,/ 实现/ 了/ 在/ 已知/ 计算/ 划分/ 前提/ 下/ MPI/ 通信/ 的/ 求解/ 算法/ ,/ 在/ 后/ 端/ 通过/ 符号/ 不等式/ 系统/ 完成/ 了/ 并行/ 代码/ 的/ 自动/ 生成/ ./ 这两项/ 工作/ 都/ 基于/ SUIF/ 编译器/ 开发/ ,/ 主要/ 缺点/ 在于/ :/ 前者/ 未/ 考虑/ 分布/ 存储/ 与/ 共享/ 存储/ 之间/ 的/ 区别/ ,/ 未/ 实现/ 改进/ 编译器/ 的/ 优化/ ,/ 后者/ 则/ 在/ 处理/ 全局/ 数组/ 时/ 总是/ 收集/ 所有/ 数据/ ,/ 造成/ 冗余/ 通信/ ,/ 生成/ 的/ 代码/ 效率/ 不够/ 理想/ ./ 另外/ ,/ 国内/ 南京大学/ 开发/ 的/ JAPS/ [/ 4/ ]/ 是/ 一个/ 运行/ 于/ NOW/ 环境/ 下/ 的/ Java/ 程序/ 自动/ 并行/ 化/ 系统/ ,/ 实现/ 了/ 从/ 依赖/ 关系/ 分析/ 到/ 程序/ 并行执行/ 的/ 全自动/ 过程/ ,/ 能够/ 进行/ 复杂/ 的/ 任务/ 并行性/ 开发/ ,/ 但/ 由于/ 其/ 针对/ Java/ 程序开发/ ,/ 适用性/ 受到/ 了/ 一定/ 的/ 限制/ ./ 从/ 上述/ 几个/ 关于/ 面向/ 分布/ 存储/ 并行/ 系统/ 的/ 编译器/ 研究/ 不难看出/ ,/ 基于/ 现有/ 的/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ 开发/ 分布式/ 并行/ 的/ 方式/ 具有/ 一定/ 可行性/ ,/ 在/ 一定/ 程度/ 上/ 能够/ 解决/ 分布式/ 并行/ 化/ 编译/ 的/ 需求/ ./ 基于/ 这种/ 思想/ ,/ 本文/ 为/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ Open64/ [/ 5/ ]/ 设计/ 并/ 实现/ 了/ 一个/ 支持/ MPI/ 代码生成/ 的/ 后/ 端/ ./ Open64/ 是/ 当前/ 最/ 先进/ 的/ 产品/ 级/ 优化/ 编译器/ ,/ 能够/ 自动/ 挖掘/ 程序/ 中/ 的/ 并行性/ ,/ 生成/ 面向/ 共享/ 存储/ 结构/ 的/ OpenMP/ 并行/ 代码/ ./ 该/ 优化/ 编译器/ 能够/ 将/ C/ 、/ C++/ 和/ Java/ 多种语言/ 作为/ 输入/ 语言/ ,/ 并且/ 优化/ 效果/ 明显/ ,/ 挖掘/ 并行性/ 的/ 能力/ 强/ ,/ 在/ 多数/ 情况/ 下/ ,/ 生成/ 的/ 并行/ 代码/ 与/ 其他/ 并行/ 编译器/ 相比/ ,/ 能够/ 获得/ 更好/ 的/ 加速/ 比/ 效益/ ./ 因此/ ,/ 基于/ Open64/ 开发/ 面向/ 分布/ 存储/ 的/ 并行/ 编译器/ ,/ 得到/ 的/ MPI/ 代码/ 性能/ 可能/ 会/ 更好/ ./ 根据/ 分布/ 存储/ 结构/ 和/ 消除/ 传递/ 代码/ 编程/ 特点/ ,/ 本文/ 主要/ 从/ 自动/ 生成/ 计算/ 划分/ 、/ 改进/ 循环/ 优化/ 和/ 自动/ 生成/ MPI/ 并行/ 代码/ 3/ 个/ 方面/ 对/ Open64/ 进行/ 了/ 改进/ ,/ 使/ 其/ 成为/ 面向/ 分布/ 存储/ 并行/ 系统/ 的/ 编译器/ ,/ 称为/ SW/ -/ VEC/ ./ 本文/ 的/ 主要/ 贡献/ 有/ :/ (/ 1/ )/ 利用/ 凸/ 多面体/ 结构/ ,/ 自动/ 获得/ 程序/ 的/ 计算/ 划分/ 和/ 数据分布/ 信息/ ,/ 为/ 最大/ 限度/ 挖掘/ 程序/ 的/ 并行性/ 和/ 降低/ MPI/ 程序/ 通信/ 开销/ 奠定/ 了/ 基础/ ./ (/ 2/ )/ 通过/ 在/ 依赖/ 测试阶段/ 添加/ 新/ 的/ 依赖/ 测试方法/ ,/ 提升/ 了/ Open64/ 依赖/ 分析/ 的/ 能力/ ,/ 同时/ 针对/ 分布/ 存储/ 结构/ 改进/ 了/ 循环/ 优化/ 中/ 的/ 并行/ 识别/ 过程/ ,/ 使/ 并行/ 识别/ 的/ 结果/ 更/ 适于/ 分布式/ 并行/ 代码/ 的/ 生成/ ./ (/ 3/ )/ 为/ Open64/ 编译器/ 提供/ 了/ 一个/ MPI/ 代码生成/ 模块/ ,/ 使/ 其/ 能够/ 生成/ 适于/ 在/ 分布/ 存储/ 高性能/ 计算机/ 上/ 运行/ 的/ 并行/ 代码/ ./ 利用/ SW/ -/ VEC/ 系统对/ 串行/ 程序/ 进行/ 编译/ ,/ 生成/ 的/ MPI/ 并行/ 代码/ 可/ 直接/ 运行/ 在/ 具有/ 分布/ 存储/ 结构/ 的/ 高性能/ 计算机/ ./ 将/ 该/ MPI/ 代码/ 的/ 执行/ 效率/ 与/ 传统/ 分布式/ 并行/ 化/ 编译/ 工具/ Paraguin/ 生成/ 的/ MPI/ 代码/ 效率/ 进行/ 比较/ ,/ 并行/ 效率/ 得到/ 了/ 明显/ 的/ 提升/ ./ 2/ 支持/ MPI/ 代码生成/ 的/ 后/ 端/ 对于/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ Open64/ 而言/ ,/ 要/ 为/ 其/ 设计/ 一个/ 能够/ 支持/ MPI/ 代码生成/ 的/ 后/ Page3/ 端/ ,/ 需要/ 添加/ 两个/ 功能模块/ :/ 计算/ 划分/ 模块/ 和/ MPI/ 代码/ 自动/ 生成/ 模块/ ./ 另外/ ,/ 由于/ 目标/ 体系结构/ 的/ 差异/ ,/ 需要/ 对/ Open64/ 优化/ 模块/ 进行/ 调整/ 和/ 改进/ ,/ 从而/ 使后/ 端/ 生成/ 的/ MPI/ 代码/ 更/ 适合/ 于/ 在/ 分布/ 存储/ 结构/ 计算机/ 上/ 运行/ ./ 如图/ 1/ 所示/ 是/ SW/ -/ VEC/ 系统/ 的/ 主要/ 功能模块/ 示意图/ ,/ 虚线/ 连接/ 并/ 带有/ 阴影/ 区域/ 的/ 模块/ 为/ 本文/ 工作/ 研究/ 的/ 部分/ ./ 其中/ ,/ 计算/ 划分/ 模块/ (/ decomposition/ )/ 和/ MPI/ 代码/ 自动/ 生成/ 模块/ (/ MPI/ )/ 是/ 为/ Open64/ 新/ 添加/ 的/ 功能模块/ ,/ 分别/ 用于/ 自动/ 获得/ 串行/ 程序/ 中/ 的/ 计算/ 划分/ 信息/ 和/ 自动/ 生成/ 能够/ 在/ 分布/ 存储/ 结构/ 高性能/ 计算机/ 上/ 直接/ 运行/ 的/ 并行/ MPI/ 程序/ ./ 面向/ 分布/ 存储/ 结构/ 而/ 对/ Open64/ 优化/ 功能/ 进行/ 改进/ 的/ 工作/ 主要/ 集中/ 在/ 循环/ 优化/ 模块/ (/ LoopNestedOptimization/ ,/ LNO/ )/ ,/ 调整/ 和/ 改进/ 该/ 模块/ 功能/ 主要/ 是/ 为了/ 使/ 优化/ 后/ 的/ 代码/ 更/ 适于/ 分布/ 存储/ 结构/ 的/ 特点/ ./ 分布/ 存储/ 并行/ 编译/ 与/ 共享/ 存储/ 并行/ 编译/ 最大/ 的/ 不同/ 在于/ :/ 分布/ 存储/ 除了/ 要/ 考虑/ 共享/ 存储/ 必须/ 考虑/ 的/ 数据分布/ 外/ ,/ 还/ 需要/ 考虑/ 计算/ 划分/ ./ 分布/ 存储/ 体系结构/ 中/ ,/ 各个/ 处理器/ 拥有/ 自己/ 独立/ 的/ 地址/ 空间/ ,/ 处理器/ 在/ 访问/ 远程/ 数据/ 时要/ 通过/ 消息传递/ 的/ 方式/ 进行/ 通信/ ./ 对于/ 一种/ 基于/ 消息传递/ 方式/ 的/ 并行程序/ 而言/ ,/ 通信/ 的/ 开销/ 往往/ 是/ 影响/ 程序/ 并行/ 效率/ 的/ 关键因素/ 之一/ ./ 图/ 2/ 两级/ 映射/ 模型/ 因此/ ,/ 分布式/ 并行/ 化/ 编译/ 需要/ 同时/ 考虑/ 计算/ 划分/ 和/ 数据分布/ ,/ 以期/ 使/ 不同/ 计算/ 之间/ ,/ 即/ 各/ 处理器/ 之间/ 通信/ 降/ 至/ 最少/ ,/ 从而/ 提高/ 并行程序/ 效率/ ./ 计算/ 划分/ 模块/ 就是/ 自动/ 分析程序/ 中/ 的/ 计算/ 划分/ 和/ 数据分布/ 信息/ ,/ 在/ 优化/ 前/ 将/ 这些/ 信息/ 附加/ 到/ 编译器/ 的/ 中间/ 语言/ 中/ ,/ 从而/ 保证/ 后面/ 各个/ 优化/ 都/ 能/ 以/ 这些/ 信息/ 为/ 基础/ 而/ 进行/ ./ 在/ LNO/ 模块/ 中/ ,/ Open64/ 主要/ 以/ 嵌套循环/ 为/ 基本/ 单元/ 对/ 程序实施/ 优化/ ,/ 这些/ 优化/ 包括/ 循环/ 倾斜/ 、/ 循环/ 合并/ [/ 6/ ]/ 等等/ ./ 对/ LNO/ 进行/ 调整/ 和/ 优化/ 的/ 原因/ 具体来讲/ 有/ 以下/ 两个/ 方面/ :/ 首先/ ,/ 由于/ MPI/ 程序/ 通信/ 开销/ 较大/ ,/ 因此/ 更/ 适合/ 于/ 粗粒度/ 并行/ ./ Open64/ 是/ 支持/ OpenMP/ 代码生成/ 的/ 并行/ 化/ 编译器/ ,/ 对于/ 规模较/ 小/ 的/ 循环/ ,/ 只要/ 符合/ 并行/ 循环/ 的/ 条件/ ,/ 也/ 会/ 识别/ 为/ 并行/ 循环/ ./ 然而/ ,/ 只有/ 那些/ 规模/ 较大/ 的/ 循环/ ,/ 采用/ 消息传递/ 并行/ 的/ 方式/ 才/ 更/ 有/ 可能/ 得到/ 较/ 好/ 的/ 收益/ ./ 其次/ ,/ 根据/ 中间/ 语言/ 中/ 附加/ 的/ 计算/ 划分/ 和/ 数据分布/ 信息/ ,/ 需要/ 根据/ 并行/ 识别/ 的/ 结果/ 计算/ 出/ 不同/ 计算/ 之间/ 需要/ 进行/ 通信/ 的/ 数据/ ./ Open64/ 能够/ 自动/ 生成/ OpenMP/ 并行程序/ ,/ 但/ OpenMP/ 并/ 不/ 适合/ 在/ 分布/ 存储/ 结构/ 上/ 直接/ 运行/ ./ 因此/ ,/ 为/ Open64/ 添加/ 一个/ MPI/ 代码/ 自动/ 生成/ 模块/ ./ 在/ 这个/ 模块/ 中/ ,/ 主要/ 根据/ 中间/ 语言/ 中/ 附加/ 的/ 计算/ 划分/ 和/ 数据分布/ 信息/ ,/ 确定/ 计算/ 之间/ 需要/ 生成/ 通信/ 函数/ 的/ 位置/ ./ 在/ 此基础/ 上/ ,/ 将/ LNO/ 阶段/ 中/ 计算/ 出/ 的/ 通信/ 数据/ 正确/ 写入/ 通信/ 函数/ 中/ ,/ 并/ 完成/ MPI/ 代码/ 的/ 自动/ 生成/ ./ 除此之外/ ,/ 还/ 需要/ 根据/ 不同/ 的/ 需求/ ,/ 对/ 生成/ 的/ 并行/ 代码/ 进行/ 优化/ ,/ 从而/ 提升/ 生成/ 并行/ 代码/ 的/ 效率/ ./ 下面/ 分别/ 介绍/ 如何/ 设计/ 和/ 实现/ 这/ 3/ 个/ 模块/ ./ 3/ 计算/ 划分/ 与/ 数据分布/ 计算/ 划分/ 和/ 数据分布/ 采用/ 如图/ 2/ 所示/ 的/ 两级/ 映/ Page4/ 射/ 模型/ [/ 7/ ]/ :/ 第一级/ 映射/ 为/ 虚拟/ 映射/ ,/ 完成/ 将/ 对准/ 的/ 计算/ 和/ 数据/ 映射/ 到/ 一个/ 规模/ 不/ 受限/ 的/ 虚拟/ 处理器/ 阵列/ 上/ ;/ 第二级/ 映射/ 为/ 物理/ 映射/ ,/ 完成/ 虚拟/ 处理器/ 阵列/ 到/ 物理/ 处理器/ 阵列/ 的/ 映射/ ./ 两级/ 映射/ 模型/ 中/ 的/ 虚拟/ 处理器/ 空间/ 为/ 解决/ 自动/ 计算/ 划分/ 与/ 数据分布/ 问题/ 提供/ 了/ 一个/ 中间层/ 的/ 、/ 与/ 硬件平台/ 无关/ 的/ 映射/ 模板/ ,/ 方便/ 开发人员/ 将/ 注意力/ 集中/ 于/ 设计/ 和/ 优化/ 第一级/ 映射/ 算法/ ./ 计算/ 划分/ 和/ 数据分布/ 分别/ 需要/ 对/ 循环/ 迭代/ 空间/ 与/ 处理器/ 空间/ 的/ 映射/ 关系/ 和/ 数据/ 空间/ 与/ 处理器/ 空间/ 的/ 映射/ 关系/ 进行/ 分析/ ./ 可以/ 将/ 这些/ 空间/ 之间/ 的/ 映射/ 关系/ 抽象/ 成/ 多维/ 整数/ 空间/ 的/ 映射/ 关系/ ,/ 从而/ 进行/ 代数/ 分析/ ./ 在/ 实际/ 应用程序/ 中/ ,/ 这些/ 多维/ 整数/ 空间/ 往往/ 呈现出/ 凸/ 多面体/ 的/ 性质/ ,/ 因此/ ,/ 可以/ 以凸/ 多面体/ 来/ 表示/ 迭代/ 、/ 数组/ 下标/ 和/ 处理器/ 空间/ ./ 3.1/ 凸/ 多面体/ 表示/ 以图/ 3/ 为例/ ,/ 迭代/ 空间/ 记为/ I/ ,/ 由/ 深度/ 为/ l/ 的/ 嵌套循环/ 构成/ ,/ 空间/ 中/ 的/ 点/ (/ i0/ ,/ i1/ ,/ …/ ,/ il/ -/ 1/ )/ 代表/ 嵌套循环/ 的/ 一次/ 迭代/ ;/ A/ 代表/ 由/ 一个/ m/ 维/ 数组/ 构成/ 的/ 数据/ 空间/ ,/ 数组/ 的/ 一个/ 元素/ 可以/ 用该/ 空间/ 中/ 的/ 点/ (/ a0/ ,/ a1/ ,/ …/ ,/ am/ -/ 1/ )/ 表示/ ;/ 一个/ n/ 维/ 处理器/ 阵列/ 由/ 处理器/ 空间/ P/ 表示/ ,/ 点/ (/ p0/ ,/ p1/ ,/ …/ ,/ pn/ -/ 1/ )/ 代表/ 一个/ 处理器/ 的/ 位置/ ./ 嵌套循环/ 中/ 存在/ 对/ 数组/ array/ 的/ 访问/ ,/ 数组/ 下标/ 表达式/ 构成/ 了/ 迭代/ 空间/ I/ 到/ 数据/ 空间/ A/ 的/ 映射/ ,/ 即/ 数组/ 访问/ 仿射/ 函数/ ./ 定义/ 1/ ./ 假设/ 在/ 深度/ 为/ l/ 的/ 嵌套循环/ 中/ 存在/ 对/ 某个/ m/ 维/ 数组/ array/ 的/ 访问/ ,/ 其/ 数组/ 访问/ 形式/ 为/ array/ [/ f00i0/ +/ f01i1/ +/ …/ +/ f0/ ,/ l/ -/ 1il/ -/ 1/ +/ f0/ ]/ [/ f10i0/ +/ f11i1/ +/ …/ +/ f1/ ,/ l/ -/ 1il/ -/ 1/ +/ f1/ ]/ …/ [/ fm/ -/ 1/ ,/ 0i0/ +/ fm/ -/ 1/ ,/ 1i1/ +/ …/ +/ fm/ -/ 1/ ,/ l/ -/ 1il/ -/ 1/ +/ fm/ -/ 1/ ]/ ,/ 则/ 数组/ 访问/ 仿射/ 函数/ 被/ 定义/ 为/ 迭代/ 空间/ I/ 到/ 数据/ 空间/ A/ 的/ 一个/ 映射/ ,/ 表示/ 为/ f/ (/ 犻/ n/ )/ =/ 犉/ m/ ×/ l/ ·/ 犻/ n/ +/ 犽/ fn/ ,/ 其中/ 犉/ =/ 是/ 一个/ m/ ×/ l/ 的/ 线性/ 转换/ 矩阵/ ,/ fxy/ ∈/ 犣/ (/ 0/ / x/ / m/ -/ 1/ ,/ 0/ / y/ / l/ -/ 1/ )/ ,/ 犽/ fn/ =/ 在/ 第一级/ 映射/ 中/ ,/ 计算/ 划分/ 描述/ 从/ 迭代/ 空间/ I/ 到/ 处理器/ 空间/ P/ 的/ 映射/ ,/ 记/ 为/ 计算/ 划分/ 仿射/ 函数/ c/ ;/ 数据分布/ 描述/ 从/ 数据/ 空间/ A/ 到/ 处理器/ 空间/ P/ 的/ 映射/ ,/ 记/ 为/ 数据分布/ 仿射/ 函数/ d/ ./ 定义/ 2/ ./ 设/ 嵌套循环/ 深度/ 为/ l/ ,/ 处理器/ 阵列/ 维数/ 为/ n/ ,/ 则/ 计算/ 划分/ 仿射/ 函数/ c/ (/ 犻/ n/ )/ =/ 犆/ n/ ×/ l/ ·/ 犻/ n/ +/ 犽/ cn/ 被/ 定义/ 为/ 从/ 迭代/ 空间/ I/ 到/ 处理器/ 空间/ P/ 的/ 映射/ ,/ 其中/ c00c01/ …/ c0/ ,/ l/ -/ 1/ 熿/ 犆/ =/ cn/ -/ 1/ ,/ 0cn/ -/ 1/ ,/ 1/ …/ cn/ -/ 1/ ,/ l/ 燀/ 性/ 转换/ 矩阵/ ,/ cxy/ ∈/ Ζ/ (/ 0/ / x/ / n/ -/ 1/ ,/ 0/ / y/ / l/ -/ 1/ )/ ,/ 犽/ cn/ =/ 熿/ 燀/ fn/ 定义/ 3/ ./ 设/ 数组/ 维数/ 为/ m/ ,/ 处理器/ 阵列/ 维数/ 为/ n/ ,/ 则/ 数据分布/ 仿射/ 函数/ d/ (/ 犪/ m/ )/ =/ 犇/ n/ ×/ m/ ·/ 犪/ m/ +/ 犽/ dm/ 被/ 定义/ 为/ 从/ 数据/ 空间/ A/ 到/ 处理器/ 空间/ P/ 的/ 映射/ ,/ 其中/ 犇/ =/ 熿/ dn/ -/ 1/ ,/ 0dn/ -/ 1/ ,/ 1/ …/ dn/ -/ 1/ ,/ m/ 燀/ 的/ 线性/ 转换/ 矩阵/ ,/ dxy/ ∈/ Ζ/ (/ 0/ / x/ / n/ -/ 1/ ,/ 0/ / y/ / m/ -/ 1/ )/ ,/ 犽/ dm/ =/ 计算/ 划分/ 、/ 数据分布/ 和/ 数组/ 访问/ 仿射/ 函数/ 三者/ 之间/ 的/ 关系/ 如图/ 4/ 所示/ ./ 计算/ 划分/ 模块/ 就是/ 通过/ 对/ 程序/ 的/ 分析/ ,/ 自动/ 生成/ c/ 和/ d/ 函数/ 中/ 的/ 系数/ 矩阵/ 和/ 常量/ ,/ 即/ 分别/ 给出/ 矩阵/ 犆/ 、/ 犇/ 和/ 对应/ 的/ 常/ 向量/ ./ 第二级/ 映射/ ,/ 即/ 从/ 虚拟/ 处理器/ 到/ 物理/ 处理器/ 空间/ 的/ 映射/ ,/ 可/ 采用/ Block/ 、/ Cyclic/ 和/ Block/ -/ Cyclic/ 这/ 3/ 种/ 方式/ ,/ 采用/ 的/ 方法/ 与/ 课题组/ 前期/ 研究/ 工作/ [/ 7/ ]/ 相/ Page5/ 同/ ,/ 此处/ 不再/ 赘述/ ./ 3.2/ 划分/ 一致性/ 分析/ 计算/ 划分/ 和/ 数据分布/ 的/ 一致性/ 在/ 很大/ 程度/ 上/ 决定/ 了/ 并行/ 效果/ ./ 因为/ 只有/ 计算/ 划分/ 和/ 数据分布/ 一致/ ,/ 处理器/ 对/ 远程/ 数据/ 的/ 访问量/ 才能/ 减少/ ,/ 这样/ 在/ 后/ 端/ 生成/ 的/ MPI/ 消息/ 数量/ 才/ 能够/ 降/ 至/ 最低/ ./ 下面/ 给出/ 判定/ 计算/ 划分/ 和/ 数据分布/ 一致性/ 的/ 理论/ 方法/ ./ 定理/ 1/ ./ 当/ 条件/ 犽/ cn/ =/ 犇/ n/ ×/ m/ ·/ 犽/ fn/ +/ 犽/ dm/ 与/ 条件/ 犆/ n/ ×/ l/ =/ 犇/ n/ ×/ m/ ·/ 犉/ m/ ×/ l/ 同时/ 满足/ 时/ ,/ 称/ 计算/ 划分/ 和/ 数据分布/ 对齐/ 一致/ ./ 证明/ ./ 设/ 程序/ 中/ 某次/ 计算/ 的/ 迭代/ 空间/ 为/ 犻/ n/ ,/ 计算/ 中/ 访问/ 的/ 数据/ 空间/ 为/ 犪/ m/ ,/ 则/ 由/ 定义/ 1/ 可知/ 由/ 定义/ 2/ ,/ 经/ 计算/ 划分/ 仿射/ 函数/ 后/ 的/ 迭代/ 空间/ 为/ 再/ 由/ 定义/ 3/ ,/ 经/ 数据分布/ 仿射/ 函数/ 后/ 的/ 数据/ 空间/ 为/ d/ (/ 犪/ m/ )/ =/ 犇/ n/ ×/ m/ ·/ 犪/ m/ +/ 犽/ dm/ 欲/ 使经/ 仿射/ 后/ 的/ 迭代/ 空间/ 和/ 数据/ 空间/ 完全一致/ ,/ 即/ 那么/ 犆/ n/ ×/ l/ ·/ 犻/ n/ +/ 犽/ cn/ =/ (/ 犇/ n/ ×/ m/ ·/ 犉/ m/ ×/ l/ )/ 犻/ n/ +/ 犇/ n/ ×/ m/ ·/ 犽/ fn/ +/ 犽/ dm/ ,/ 即/ 犆/ n/ ×/ l/ =/ 犇/ n/ ×/ m/ ·/ 犉/ m/ ×/ l/ ,/ 犽/ cn/ =/ 犇/ n/ ×/ m/ ·/ 犽/ fn/ +/ 犽/ dm/ ./ 证毕/ ./ 定理/ 2/ ./ 当/ 条件/ 犆/ n/ ×/ l/ =/ 犇/ n/ ×/ m/ ·/ 犉/ m/ ×/ l/ 满足/ 时/ ,/ 称/ 证明/ ./ 同/ 定理/ 1/ ,/ 非/ 对齐/ 一致/ 即/ 计算/ 划分/ 和/ 数/ 计算/ 划分/ 和/ 数据分布/ 非/ 对齐/ 一致/ ./ 据/ 分布/ 与/ 迭代/ 空间/ 无关/ ,/ 那么/ 只/ 需/ 与/ 迭代/ 空间/ 无关/ ,/ 即/ 在/ MPI/ 并行/ 代码/ 中/ ,/ 通信/ 是/ 影响/ 并行程序/ 效率/ 的/ 一个/ 主要/ 因素/ ,/ 因此/ 自动/ 并行/ 化应/ 尽量/ 高效/ 地/ 保证数据/ 和/ 计算/ 划分/ 映射/ 到/ 一起/ ,/ 来/ 减少/ 通信/ 的/ 次数/ ./ 若要/ 保证/ 划分/ 一致/ ,/ 在/ 进行/ 划分/ 时/ 可以/ 按照/ 定理/ 1/ 提出/ 的/ 条件/ 进行/ 划分/ ,/ 这样/ 就/ 能够/ 保证数据/ 和/ 计算/ 完全/ 映射/ 到/ 一起/ ./ 然而/ ,/ 在/ 实际/ 应用/ 中/ ,/ 很难/ 达到/ 全局/ 的/ 对齐/ 一致/ ,/ 因此/ ,/ 通过/ 定理/ 2/ 证明/ 了/ 非/ 对齐/ 一致/ 的/ 条件/ ./ 按照/ 定理/ 2/ 的/ 条件/ ,/ 数据/ 和/ 计算/ 能够/ 在/ 整体/ 趋势/ 上/ 映射/ 到/ 一起/ ,/ 处理器/ 之间/ 需要/ 通信/ 时/ 只/ 需要/ 通信/ 因/ 偏移/ 产生/ 的/ 非/ 一致/ 数据/ ,/ 这样/ 也/ 远/ 比/ 完全/ 不/ 一致/ 产生/ 的/ 通信/ 代价/ 小得多/ ./ 4LNO/ 调整/ 与/ 优化/ 并行/ 化/ 编译器/ 提高/ 生成/ 代码执行/ 效率/ 的/ 重要/ 手段/ 就是/ 利用/ 重/ 排序/ 变换/ [/ 6/ ]/ ./ 重/ 排序/ 变换/ 是/ 任何/ 这样/ 的/ 程序变换/ ,/ 它/ 仅/ 改变/ 代码/ 的/ 执行/ 序/ ,/ 不/ 增加/ 或/ 取消/ 任何/ 语句/ 的/ 任何/ 执行/ ./ 而/ 根据/ 依赖/ 的/ 基本/ 定理/ 可知/ ,/ 任何/ 一个/ 重/ 排序/ 变换/ 必须/ 保持/ 程序/ 中/ 的/ 每个/ 依赖/ 才/ 是/ 一个/ 合法/ 的/ 变换/ ./ 因此/ ,/ 本/ 节/ 首先/ 分析/ Open64/ 中/ 的/ 依赖/ 测试/ ./ 4.1/ 依赖/ 测试/ 依赖/ 测试/ 是/ 并行/ 化/ 编译器/ 的/ 一个/ 基础/ ,/ 对于/ 任何/ 一个/ 并行/ 化/ 编译器/ 而言/ ,/ 依赖/ 测试/ 的/ 能力/ 直接/ 影响/ 了/ 其/ 挖掘/ 程序/ 并行性/ 的/ 能力/ ./ 这/ 是因为/ :/ 对于/ 一个/ 引用/ 对/ ,/ 并行/ 化/ 编译器/ 如果/ 无法/ 判断/ 他们/ 之间/ 是否/ 有/ 依赖/ ,/ 那么/ 就/ 会/ 保守/ 地/ 认为/ 这/ 对/ 引用/ 之间/ 有/ 依赖/ ,/ 否则/ ,/ 即/ 编译器/ 认为/ 他们/ 之间/ 没有/ 依赖/ 时/ ,/ 如果/ 该/ 引用/ 对/ 之间/ 真的/ 存在/ 依赖/ ,/ 而/ 编译器/ 实施/ 优化/ 时/ 对/ 程序/ 进行/ 了/ 重/ 排序/ 变换/ ,/ 那么/ 就/ 有/ 可能/ 破坏/ 该/ 引用/ 对/ 之间/ 的/ 依赖/ ./ 因此/ ,/ 如果/ 一个/ 并行/ 化/ 编译器/ 的/ 依赖/ 测试/ 强大/ 到/ 能够/ 判断/ 任何/ 一种/ 依赖/ 关系/ ,/ 那么/ 就/ 会/ 消除/ 原有/ 的/ 保守/ 测试/ 带来/ 的/ 伪/ 依赖/ ,/ 从而/ 能够/ 更/ 大限度/ 地/ 实施/ 优化/ ,/ 挖掘/ 程序/ 的/ 并行性/ ./ Open64/ 中/ 使用/ 的/ 依赖/ 测试方法/ 有/ GCD/ 测试/ [/ 8/ ]/ 和/ Omega/ 测试/ [/ 9/ ]/ ./ 由于/ GCD/ 和/ Omega/ 测试/ 都/ 是/ 针对/ 线性/ 数组/ 下/ 标的/ 依赖/ 测试/ ,/ 因此/ ,/ Open64/ 依赖/ 测试/ 主要/ 存在/ 的/ 问题/ 是/ 无法/ 处理/ 非线性/ 数组/ 下标/ ./ 通过/ 对/ SPEC2000/ 和/ Perfect/ 等/ 基准/ 测试/ 集/ 的/ 程序/ 分析/ 发现/ ,/ 在/ 实际/ 应用/ 中/ ,/ 含有/ 二次/ 下/ 标的/ 数组/ 表达式/ 在/ 这些/ 程序/ 中/ 比较/ 常见/ ,/ 而且/ 远比/ 其他/ 更高次/ 非线性/ 下标/ 常见/ ,/ 因此/ ,/ 我们/ 针对/ 二次/ 下标/ 表达式/ 研究/ 了/ 一种/ 相应/ 的/ 依赖/ 测试方法/ ./ 定理/ 3/ ./ 任意/ 二次/ 下标/ 表达式/ 的/ 依赖/ 关系/ 都/ 可以/ 通过/ 二次/ 规划/ 模型/ 判定/ ,/ 其中/ 矩阵/ 犅/ 是/ 由/ n/ 个/ 边界/ 不同/ 的/ 数组/ 系数/ 组成/ 的/ 矩阵/ ./ 证明/ ./ 由于/ 二次/ 规划/ 模型/ 求解/ 要求/ 式/ (/ 1/ )/ 中/ 的/ 矩阵/ 犎/ n/ ×/ n/ 为/ 对称/ 矩阵/ ,/ 因此/ ,/ 先证/ 二次/ 下标/ 表达式/ 的/ 矩阵/ 一定/ 可以/ 写成/ 对称/ 矩阵/ ./ 考虑/ 如图/ 3/ 所示/ 例子/ ,/ 判断/ 数组/ 下标/ 之间/ 是否/ 有/ 依赖/ ,/ 即/ 判断/ Page6f/ (/ i0/ ,/ …/ ,/ in/ -/ 1/ )/ =/ h/ (/ i0/ ,/ …/ ,/ in/ -/ 1/ )/ -/ g/ (/ i0/ ,/ …/ ,/ in/ -/ 1/ )/ =/ 0/ 是否/ 有/ 整数/ 解/ ,/ 将式/ (/ 2/ )/ 中/ 的/ 常数/ 项/ 去掉/ ,/ 即可/ 得到/ 式/ (/ 1/ )/ 中/ 的/ 目标/ 函数/ ./ 式/ (/ 1/ )/ 目标/ 表达式/ 的/ 二次/ 项为/ f2/ (/ i0/ ,/ …/ ,/ in/ -/ 1/ )/ =/ h00i2/ 即/ 矩阵/ 犎/ 为/ 犎/ n/ ×/ n/ =/ 2/ ×/ 此时/ ,/ 对/ 任意/ 0/ / i/ ,/ j/ / n/ -/ 1/ ,/ 都/ 满足/ hij/ =/ hji/ ./ 再证/ 任意/ 下标/ 表达式/ 都/ 可以/ 写成/ 式/ (/ 1/ )/ 的/ 形式/ ./ 显然/ ,/ 当/ h11/ >/ 0/ 时/ ,/ 要/ 判定/ 的/ 二次/ 表达式/ 与/ 式/ (/ 1/ )/ 相同/ ;/ 当/ h11/ </ 0/ 时/ ,/ 依赖/ 测试/ 等价/ 于/ 求解/ 将式/ (/ 4/ )/ 取反/ ,/ 即可/ 得到/ 式/ (/ 1/ )/ 的/ 形式/ ./ 证毕/ ./ 确定/ 了/ 任意/ 二次/ 下标/ 表达式/ 都/ 可以/ 通过/ 二次/ 规划/ 模型/ (/ 1/ )/ 判定/ 后/ ,/ 要/ 解决/ 的/ 问题/ 就是/ 如何/ 求解/ 二次/ 规划/ 模型/ ./ 求解/ 二次/ 规划/ 模型/ 分为/ 两个/ 步骤/ :/ 首先/ ,/ 要/ 判定/ 矩阵/ 犎/ 是否/ 为/ 半/ 正定/ 矩阵/ ,/ 这/ 可以/ 通过/ 判定/ 矩阵/ 犎/ 的/ 主子/ 式/ 是否/ 大于/ 0/ 确定/ ./ 其次/ ,/ 如果/ 犎/ 不是/ 半/ 正定/ 矩阵/ ,/ 那么/ 无法/ 确定/ 二次/ 规划/ 模型/ 的/ 极值/ ,/ 给出/ 保守/ 结果/ ,/ 即/ 认为/ 有/ 依赖/ ./ 如果/ 犎/ 为/ 半/ 正定/ 矩阵/ ,/ 则/ 利用/ Lemke/ 方法/ [/ 10/ ]/ 求解/ 目标/ 函数/ 的/ 极值/ ,/ 来/ 判断/ 目标/ 函数/ 是否/ 有/ 可能/ 等于/ 0/ ,/ 如果/ 不/ 可能/ ,/ 则/ 说明/ 所/ 测试/ 的/ 引用/ 对/ 一定/ 无/ 依赖/ ;/ 否则/ ,/ 再/ 利用/ 分枝/ 定界/ 法/ [/ 11/ ]/ 求解/ 目标/ 函数/ 在/ 整数/ 范围/ 内/ 是否/ 有/ 可能/ 等于/ 0/ 以及/ 等于/ 0/ 时/ 是否是/ 整数/ 解来/ 判定/ 依赖/ 关系/ ./ 在/ 文献/ [/ 12/ ]/ 提出/ 了/ 一种/ 基于/ 整数/ 区间/ 理论/ 的/ 非线性/ 依赖/ 测试方法/ ,/ 该/ 方法/ 的/ 主要/ 缺点/ 是/ 无法/ 处理/ 混合/ 多项式/ ,/ 那么/ 对于/ 二次/ 下标/ ,/ 该/ 方法/ 能够/ 处理/ 的/ 模型/ 为/ 其中/ 犎/ 0n/ ×/ n/ =/ 2/ ×/ hii/ / 0/ 对/ 任意/ 的/ 0/ / i/ / n/ -/ 1/ 成立/ ./ 对于/ 这种/ 模型/ ,/ 判断/ 矩阵/ 犎/ 0/ 是否/ 为/ 半/ 正定/ 矩阵/ ,/ 可以/ 用/ 如下/ 定理/ ./ 定理/ 4/ [/ 13/ ]/ ./ 矩阵/ 犎/ 0/ 是/ 半/ 正定/ 矩阵/ ,/ 当且/ 仅/ 当/ 证明/ ./ 见/ 文献/ [/ 13/ ]/ ./ 4.2/ 并行/ 识别/ 优化/ 在/ 优化/ 依赖/ 测试/ 的/ 基础/ 上/ ,/ 考虑/ 到/ SW/ -/ VEC/ 是/ 面向/ 分布/ 存储/ 体系结构/ 这一/ 目标/ ,/ 需要/ 针对/ 程序/ 的/ 并行/ 识别/ 进行/ 改进/ ./ 如前/ 文/ 所述/ ,/ 只有/ 对/ 一些/ 规模/ 较大/ 的/ 循环/ ,/ 采用/ 消息传递/ 并行/ 的/ 方式/ 才/ 有/ 可能/ 得到/ 较/ 好/ 的/ 收益/ ./ 通过/ 分析程序/ 中/ 嵌套循环/ 结构/ 的/ 特点/ ,/ 我们/ 将/ 程序/ 中/ 的/ 嵌套循环/ 进行/ 了/ 分类/ [/ 14/ ]/ ,/ 分为/ 完美/ 嵌套循环/ (/ PerfectNestedLoop/ ,/ PNL/ )/ 、/ 简单/ 嵌套循环/ (/ SimpleNestedLoop/ ,/ SNL/ )/ 和/ 一般/ 嵌套循环/ (/ OrdinaryNestedLoop/ ,/ ONL/ )/ ./ 三者/ 之间/ 的/ 包含/ 关系/ 如图/ 5/ 所示/ ./ Open64/ 中/ 针对/ 任意/ 嵌套循环/ 均/ 采用/ 了/ 相同/ 的/ 处理/ 方式/ ,/ 我们/ 对/ 嵌套循环/ 进行/ 分类/ ,/ 并/ 分别/ 针对/ 这/ 3/ 种/ 不同/ 的/ 嵌套循环/ 设计/ 了/ 不同/ 的/ 并行/ 识别方法/ ./ 首先/ ,/ 针对/ 完美/ 嵌套循环/ ,/ 可/ 借助/ 中间/ 工具/ WRaP/ -/ IT/ [/ 15/ ]/ 识别/ 其/ 并行性/ ,/ 同时/ ,/ 该/ 工具/ 可以/ 利用/ Polyhedral/ 模型/ 将/ 一些/ 非/ 完美/ 嵌套循环/ 转换/ 为/ 完美/ 嵌套循环/ ;/ 其次/ ,/ 对于/ 简单/ 嵌套循环/ ,/ 如果/ 为/ 完美/ 嵌套循环/ ,/ 或者/ 能够/ 转换/ 为/ 完美/ 嵌套循环/ ,/ 则/ 采用/ 上/ 一/ 方法/ ,/ 否则/ ,/ 再/ 利用/ Open64/ 中/ 的/ 并行/ 识别/ 方式/ 进行/ 识别/ ;/ 最后/ ,/ 对于/ 一般/ 嵌套循环/ ,/ 如果/ 是/ 简单/ 嵌套循环/ ,/ 则/ 按照/ 上/ 一种/ 方法/ 进行/ 识别/ ,/ 否则/ ,/ 由于/ 其/ 结构/ 中/ 可能/ 含有/ 过程/ 调用/ 等/ 复杂/ 结构/ ,/ 需要/ 借助/ Open64/ 的/ IPA/ (/ Inter/ -/ proceduralAnalysis/ )/ 模块/ 进行/ 分析/ ,/ 再/ 通过/ 传递/ 交互/ 文件/ 的/ 方式/ 识别/ 并行性/ ./ 由于/ 采用/ 了/ 交互方式/ 进行/ 识别/ ,/ 这种/ 并行/ 识别/ 方式/ 应该/ 属于/ 半自动/ 并行/ 识别/ ./ 对于/ 非专业/ 人员/ 来讲/ ,/ 如果/ 模型/ 法和遍/ 历法/ 已经/ 识别/ 出/ 足够/ 多/ 的/ 并行/ 循环/ (/ 如/ 一个/ 嵌套循环/ 内/ 至多/ 允许/ 识别/ 出/ 适合/ MPI/ 并行/ 的/ 循环/ 个数/ 为/ n/ ,/ n/ 可以/ 预先/ 进行/ 设定/ ,/ 而/ 模型/ 法和遍/ 历法/ 已经/ 识别/ 出/ n/ 个/ 并行/ 循环/ )/ ,/ 那么/ 无需/ 再/ 调用/ 交互/ 法/ ,/ 因为/ 采用/ MPI/ 函数调用/ 的/ 分布/ 存储/ 并/ Page7/ 行化/ 编译/ ,/ 其/ 通信/ 开销/ 较大/ ,/ 再/ 进行/ 并行/ 识别/ 可能/ 会/ 带来/ 过多/ 的/ 通信/ 开销/ ,/ 导致/ 并行/ 效率/ 降低/ ;/ 否则/ ,/ 再/ 调用/ 交互/ 法/ 进行/ 半自动/ 的/ 并行/ 识别/ ./ 对于/ 专业/ 人员/ ,/ 由于/ 对/ 程序结构/ 和/ 算法/ 特点/ 十分/ 熟悉/ ,/ 可以/ 直接/ 利用/ 交互/ 法/ 进行/ 调优/ 识别/ ,/ 从而/ 获得/ 更/ 高/ 的/ 并行/ 效益/ ./ 4.3/ 通信/ 数据/ 求解/ 在/ LNO/ 阶段/ ,/ 需要/ 为/ 后面/ MPI/ 代码生成/ 模块/ 计算/ 好/ 用于/ MPI/ 消息传递/ 的/ 通信/ 数据/ ./ 在/ 实际/ 应用程序/ 中/ ,/ 两次/ 计算/ 之间/ 只有/ 至少/ 一个/ 循环/ 被/ 识别/ 为/ 并行/ 时/ ,/ 这/ 两次/ 计算/ 之间/ 才/ 有/ 可能/ 发生/ 通信/ ./ 定理/ 5/ ./ 面向/ 分布/ 存储/ 结构/ 的/ 并行/ 化/ 编译/ 中/ ,/ 两个/ 循环/ 之间/ 有/ 可能/ 进行/ 通信/ 的/ 充分条件/ 是/ 两个/ 循环/ 中/ 至少/ 有/ 一个/ 被/ 并行执行/ ./ 证明/ ./ 假设/ 程序/ 并行执行/ 时/ 至少/ 由/ 两个/ 或/ 两个/ 以上/ 进程/ 执行/ ,/ 否则/ 并行/ 无/ 意义/ ./ 设/ L1/ 和/ L2/ 为/ 所/ 考察/ 的/ 循环/ ,/ 要/ 确定/ L1/ 和/ L2/ 之间/ 是否/ 需要/ 通信/ ,/ 须/ 先/ 判断/ L1/ 和/ L2/ 的/ 并行性/ ./ 如果/ L1/ 和/ L2/ 都/ 串行/ 执行/ ,/ 那么/ 由于/ 分布/ 存储/ 并行/ 编译/ 中/ ,/ 串行/ 执行程序/ 时/ 都/ 由主/ 进程/ 处理/ ,/ 因此/ 执行/ 两个/ 循环/ 的/ 进程/ 在/ 同一/ 处理器/ 上/ ,/ 两者之间/ 不/ 需要/ 进行/ 通信/ ;/ 如果/ L1/ 和/ L2/ 中有且/ 仅/ 有/ 一个/ 并行执行/ ,/ 那么/ 两者之间/ 必然/ 要/ 进行/ 通信/ ;/ 如果/ L1/ 和/ L2/ 都/ 并行执行/ ,/ 那么/ 分/ 两种/ 情况/ :/ 一种/ 是/ 各/ 处理器/ 上/ 分配/ 到/ 的/ L1/ 和/ L2/ 计算/ 划分/ 和/ 数据分布/ 对齐/ 一致/ ,/ 即/ 各/ 处理器/ 上/ L1/ 和/ L2/ 计算/ 相关/ 的/ 数据/ 都/ 恰好/ 在/ 当前/ 处理器/ 上/ ,/ 那么/ 此时/ L1/ 和/ L2/ 之间/ 就/ 不/ 需要/ 进行/ 通信/ ;/ 否则/ L1/ 和/ L2/ 之间/ 就/ 需要/ 进行/ 通信/ ./ 因此/ ,/ L1/ 和/ L2/ 之间/ 可能/ 进行/ 通信/ 的/ 充分条件/ 是/ 至少/ 有/ 一个/ 循环/ 并行执行/ ./ 在/ 计算/ 划分/ 模块/ 中/ ,/ 已经/ 将/ 计算/ 划分/ 和/ 数据分布/ 的/ 信息/ 附加/ 到/ 中间/ 语言/ 中/ ,/ 因此/ ,/ 在/ 求解/ 两个/ 计算/ 之间/ 的/ 通信/ 时/ ,/ 可以/ 根据/ 中间/ 语言/ 的/ 附加/ 信息/ 来/ 求解/ 通信/ 数据/ ./ 此时/ ,/ 需要/ 处理/ 的/ 情况/ 可以/ 分为/ 过程/ 间通信/ 数据/ 求解/ 和/ 过程/ 内/ 通信/ 数据/ 求解/ ./ 对于/ Open64/ 而言/ ,/ 编译/ 的/ 基本/ 对象/ 是/ 一个/ PU/ (/ ProgramUnit/ )/ ,/ 如果/ 直接/ 在/ LNO/ 阶段/ 处理过程/ 间/ 信息/ ,/ 无法/ 获得/ 其他/ 过程/ 的/ 信息/ ./ 因此/ ,/ 当/ Open64/ 要/ 注销/ 当前/ PU/ 信息/ 时/ ,/ 将/ 当前/ PU/ 的/ 信息/ 保存/ 下来/ ,/ 在/ 遇到/ 要/ 发送数据/ 的/ 目的/ 地址/ 计算/ 所在/ 的/ PU/ 时/ ,/ 再/ 读取/ 保存/ 的/ PU/ 信息/ ,/ 这样/ 就/ 可以/ 求解/ 过程/ 间/ 的/ 通信/ 数据/ ./ 对于/ 过程/ 内/ 通信/ 数据/ 求解/ ,/ 如果/ 两次/ 计算/ 有且/ 只有/ 一个/ 为/ 并行/ ,/ 那么/ 由于/ 串行/ 循环/ 拥有/ 引用/ 数组/ 的/ 全部/ 数据/ ,/ 而/ 并行/ 循环/ 只/ 拥有/ 一部分/ ,/ 因此/ 按照/ 并行/ 循环/ 所/ 需/ 数据量/ 传递数据/ ./ 如果/ 两个/ 计算/ 都/ 为/ 并行/ ,/ 那么/ 判断/ 计算/ 划分/ ,/ 如果/ 非/ 对齐/ 一致/ ,/ 则/ 只/ 需/ 计算/ 因/ 偏移/ 产生/ 的/ 偏差/ ,/ 按照/ 偏差/ 传递数据/ ;/ 否则/ 将源/ 计算/ 的/ 数据/ 进行/ 全/ 通信/ ./ 最后/ ,/ 将/ 计算/ 好/ 的/ 通信/ 数据/ 信息/ 写入/ 到/ 中间/ 语言/ 结构/ 当中/ ,/ 通过/ 中间/ 语言/ 传递/ 给/ 后/ 端/ 代码生成/ 模块/ ./ 5MPI/ 代码生成/ MPI/ 代码生成/ 模块/ ,/ 是/ 本文/ MPI/ 后端/ 最/ 重要/ 的/ 部分/ ./ 该/ 模块/ 的/ 功能/ 是/ 根据/ 前/ 一部分/ 工作/ 进行/ 由/ 源代码/ 到/ 源代码/ 的/ 翻译/ 工作/ ,/ 包括/ 正确/ 生成/ 含有/ 划分/ 信息/ 的/ 并行/ 循环/ 、/ 生成/ MPI/ 消息/ 和/ 通信/ 代码优化/ 3/ 部分/ ./ 下面/ 重点/ 介绍/ 如何/ 正确/ 生成/ 被/ 划分/ 的/ 循环/ 边界/ ,/ 后/ 两者/ 只/ 介绍/ 基本原理/ 和/ 实现/ 方式/ ,/ 具体/ 结果/ 将/ 在/ 实验/ 部分/ 给出/ ./ 5.1/ 带有/ 划分/ 信息/ 的/ 并行/ 循环/ 自动/ 生成/ 划分/ 信息/ 的/ 并行/ 循环/ 边界/ ./ 对于/ 下面/ 这个/ 例子/ 为/ 便于/ 说明/ ,/ 下面/ 举例说明/ 如何/ 生成/ 带有/ 计算/ for/ (/ i1/ =/ 0/ ;/ i1/ </ =/ 5/ ;/ i1/ ++/ )/ for/ (/ i2/ =/ 0/ ;/ i2/ </ =/ 10/ -/ i1/ ;/ i2/ ++/ )/ 根据/ 第/ 2/ 节中/ 介绍/ 的/ 凸/ 多面体/ 表示/ 方法/ ,/ 其/ 嵌套循环/ 可以/ 表示/ 成/ 如下/ 形式/ :/ 将/ 其/ 写成/ 凸/ 多面体/ 形式/ 即/ 假设/ 计算/ 划分/ 模块/ 中/ 划分/ 外层/ 嵌套循环/ ,/ 由于/ 内层/ 循环/ 没有/ 划分/ ,/ 那么/ 将式/ (/ 6/ )/ 中/ 去掉/ 与/ i2/ 无关/ 的/ 系数/ 后/ 得到/ 矩阵/ Page8/ 即/ 得到/ i2/ 的/ 边界/ 为现/ 假设/ 划分/ 外层/ 循环/ 时/ ,/ 得到/ 的/ 划分/ 结果/ 为/ pid/ ×/ blksz/ / i1/ / pid/ (/ )/ +/ 1/ ×/ blksz/ -/ 1/ ,/ 其中/ ,/ blksz/ 表示/ 划分/ 块/ 大小/ ,/ pid/ 代表/ 处理器/ 的/ 编号/ ./ 此时/ ,/ 将/ blksz/ 和/ (/ pid/ ×/ blksz/ )/ 整体/ ,/ 分别/ 看成/ 是/ 未知/ 符号/ 变量/ ,/ 将/ 这些/ 变量/ 和/ 它们/ 的/ 系数/ ,/ 作为/ 新/ 的/ 元素/ 分别/ 加入/ 式/ (/ 6/ )/ 的/ 矩阵/ 和/ 向量/ 中/ ,/ 再/ 从中/ 去掉/ 式/ (/ 7/ )/ ,/ 就/ 可以/ 得到/ 新/ 的/ 矩阵/ 熿/ 00010500/ -/ 100/ -/ 1010/ 燀/ -/ 111/ -/ 10/ 取式/ (/ 8/ )/ 中/ i1/ 系数/ 为/ 1/ 的/ 部分/ ,/ 得到/ [/ 000100/ -/ 1010/ ·/ 即/ 与/ i1/ 下界/ 有关/ 的/ 不等式/ 为/ 所以/ ,/ i1/ 的/ 下界/ 为/ 同理/ 取式/ (/ 8/ )/ 中/ i1/ 系数/ 为/ -/ 1/ 的/ 部分/ ,/ 得到/ i1/ 的/ 上界/ 为/ 因此/ ,/ 带有/ 计算/ 划分/ 信息/ 的/ 并行/ 循环/ 边界/ 为/ 5.2/ MPI/ 消息/ 代码生成/ 在/ 计算/ 划分/ 模块/ 和/ LNO/ 优化/ 模块/ ,/ 分别/ 将/ 并行/ 循环/ 的/ 信息/ 和/ 通信/ 数据/ 的/ 信息/ 写入/ 到/ 了/ 中间/ 语言/ 中/ ./ 并行/ 循环/ 信息/ 主要/ 是/ 用于/ 确定/ 插入/ MPI/ 消息/ 函数/ 的/ 位置/ ,/ 基于/ 此/ 再/ 根据/ LNO/ 阶段/ 写入/ 的/ 信息/ 生成/ MPI/ 消息/ 函数/ ./ 在/ 中间/ 语言/ 中/ ,/ 信息/ 存放/ 在/ 抽象/ 语法/ 树/ 的/ 结点/ 当中/ ./ 对于/ 计算/ 划分/ 写入/ 的/ 信息/ ,/ 在/ 对应/ 的/ 循环/ 结点/ 上/ 设置/ 了/ 一个/ 是否/ 进行/ 划分/ 的/ 标志/ 位/ ,/ 计算/ 划分/ 模块/ 中/ ,/ 如果/ 对/ 应该/ 结点/ 的/ 循环/ 进行/ 计算/ 划分/ ,/ 那么/ 就/ 改变/ 该/ 标志/ 位/ ./ 在/ 确定/ MPI/ 消息/ 函数/ 的/ 插入/ 位置/ 时/ ,/ 如果/ 两个/ 循环/ 之间/ 存在/ 数据/ 的/ 访问/ ,/ 那么/ 就/ 检查和/ 这/ 两个/ 循环/ 对应/ 的/ 结点/ 的/ 标志/ 位/ 就/ 可以/ 确定/ 是否/ 需要/ 在/ 该处/ 插入/ MPI/ 消息/ 函数/ ./ 根据/ MPI/ 编程/ 规范/ 可知/ ,/ 到/ 目前为止/ ,/ 除了/ MPI/ 通信/ 类型/ 无法/ 确定/ 外/ ,/ 其它/ 参数/ 都/ 可以/ 从/ 计算/ 划分/ 和/ LNO/ 写入/ 中间/ 语言/ 的/ 信息/ 确定/ ./ 对于/ MPI/ 通信/ 类型/ ,/ 主要/ 包括/ 全/ 交换/ (/ alltoallv/ )/ 、/ 点到点/ (/ sendrecv/ )/ 、/ 广播/ (/ bcast/ )/ 、/ 收集/ (/ gatherv/ )/ 、/ 归约/ (/ reduce/ )/ 、/ 全/ 归约/ (/ allreduce/ )/ 等/ ,/ 这些/ 类型/ 可以/ 通过/ 判断/ 两个/ 需要/ 进行/ 消息传递/ 的/ 循环/ 并行性/ 决定/ ./ 如当/ 消息/ 发送/ 循环/ 是/ 并行/ 循环/ 、/ 接受/ 循环/ 是/ 串行/ 循环/ 时/ ,/ 通信/ 类型/ 就是/ 收集/ (/ gatherv/ )/ ./ 5.3/ 通信/ 优化/ 研究/ 表明/ [/ 16/ -/ 17/ ]/ ,/ 许多/ 程序/ 如果/ 不/ 实现/ 通信/ 优化/ 很难/ 得到/ 令人满意/ 的/ 并行/ 效率/ ./ 根据/ 通信/ 优化/ 的/ 类型/ ,/ 通信/ 优化/ 可以/ 分为/ 消除/ 冗余/ 通信/ 数据/ 、/ 通信/ 隐藏/ 、/ 消息/ 合并/ 等/ 几种/ ./ 本文/ 主要/ 对/ 生成/ 的/ 代码/ 实现/ 了/ 通信/ 延迟/ 隐藏/ 和/ 消息/ 合并/ 策略/ ./ (/ 1/ )/ 通信/ 延迟/ 隐藏/ 通信/ 延迟/ 隐藏/ 是/ 指/ 在/ 通信/ 开销/ 不可避免/ 的/ 情况/ 下/ ,/ 通过/ 合理安排/ 通信/ ,/ 使得/ 通信/ 在/ 使用/ 交互/ 网络/ 的/ 同时/ ,/ 处理器/ 可以/ 完成/ 与/ 这个/ 通信/ 无关/ 的/ 计算/ ,/ 即/ 达到/ 计算/ 和/ 通信/ 的/ 互相/ 重叠/ ,/ 实现/ 通信/ 开销/ 的/ 隐藏/ ,/ 提高/ 程序/ 的/ 执行/ 效率/ ./ 根据/ MPI/ 编程/ 规范/ 提供/ 的/ MPI/ 消息/ 函数/ 类型/ ,/ 可以/ 利用/ 非/ 阻塞/ 通信/ 函数/ (/ mpi/ _/ isend/ 、/ mpi/ _/ irecv/ 和/ mpi/ _/ wait/ )/ 实现/ 通信/ 延迟/ 隐藏/ ./ 具体/ 实现/ 方式/ 就是/ 将/ 消息/ 的/ 发送/ 和/ 接收/ 分离/ ,/ 将/ 发送/ 操作/ 前移/ ,/ 使/ 与/ 该/ 通信/ 无关/ 的/ 计算/ 与/ 通信/ 重叠/ ,/ 同时/ 调整/ 接收/ 操作/ ,/ 以/ 保证/ 接收/ 操作/ 与/ 发送/ 操作/ 能够/ 正确/ 匹配/ ,/ 从而/ 达到/ 通信/ 延迟/ 隐藏/ 的/ 目的/ ./ (/ 2/ )/ 消息/ 合并/ MPI/ 消息/ 传递函数/ 通信/ 开销/ 较大/ ,/ 除了/ 将/ 消息/ 从/ 发送/ 方/ 发送到/ 接收/ 方/ 需要/ 耗费/ 时间/ 外/ ,/ 还有/ 一个/ 原因/ 是/ MPI/ 消息/ 存在/ 消息/ 启动/ 开销/ ./ 对于/ 通信/ 本身/ 而言/ ,/ 一次/ 通信/ 的/ 开销/ 可以/ 表示/ 为/ [/ 7/ ,/ 18/ ]/ 其中/ Tcomm/ 是/ 总/ 的/ 通信/ 时间/ ,/ Tstart/ 是/ 通信/ 启动/ 时间/ ,/ 对于/ 一个/ 确定/ 的/ 目标/ 系统/ 而言/ ,/ 是/ 一个/ 常数/ ./ Tcopy/ (/ n/ )/ 是/ 通信/ 的/ 发起方/ 建立/ 一个/ 消息/ 或/ 通信/ 的/ 接收/ 方从/ 一个/ 消息/ 中/ 接收数据/ 的/ 时间/ ,/ 它/ 是/ 消息/ 长度/ n/ 的/ 函数/ ,/ Ttransit/ (/ n/ )/ 是/ 消息/ 的/ 通信/ 传输/ 时间/ ,/ 也/ 是/ 消息/ 长度/ 的/ 函数/ ./ 从/ 这个/ 公式/ 中/ 可以/ 看出/ 优化/ 通信/ 的/ 还有/ 一个/ 方法/ ,/ 即/ 减少/ Tstart/ ./ 对于/ n/ 个/ 消息/ ,/ 需要/ 启动/ n/ 次/ MPI/ 消息/ ,/ 那么/ 就/ 需要/ n/ 个/ Tstart/ ./ 消息/ 合并/ 就是/ 在/ 条件/ 允许/ 的/ 情况/ Page9/ 下/ ,/ 将/ 多个/ 消息/ 进行/ 合并/ ,/ 从而/ 原来/ 的/ n/ 个/ 消息/ 只/ 需要/ 启动/ 1/ 次/ MPI/ 消息/ ,/ 那么/ Tstart/ 就/ 减少/ 了/ ./ 具体/ 实现/ 方法/ 就是/ 将/ n/ 个/ 消息/ 的/ 发送缓冲区/ 进行/ 合并/ ,/ 然后/ 将/ 多个/ 消息/ 的/ 发送数据/ 依次/ 添加/ 到/ 合并/ 后/ 的/ 发送/ 消息/ 缓冲区/ 内/ ,/ 对于/ 接收/ 方/ ,/ 只/ 需/ 建立/ 一次/ 接收/ 消息/ 即可/ ./ 6/ 实验/ 测试/ 实验/ 分为/ 正确性/ 验证/ 、/ 优化/ 效果/ 测试/ 和/ 性能/ 测试/ 3/ 部分/ ./ 正确性/ 验证/ 是/ 验证/ 该/ 优化/ 编译器/ 生成/ 的/ MPI/ 并行/ 代码/ 的/ 正确性/ ,/ 只有/ 保证/ MPI/ 程序运行/ 正确/ ,/ 才能/ 进行/ 优化/ 和/ 性能/ 测试/ ;/ 优化/ 效果/ 测试/ 主要/ 针图/ 6rhs/ ./ f/ 文件/ 生成/ MPI/ 代码/ 前后/ 的/ 代码段/ 用/ SW/ -/ VEC/ 编译器/ 对/ Perfect/ 、/ SPEC2000/ 和/ NPB/ 测试/ 集/ 进行/ MPI/ 源源/ 变换/ ,/ 将/ 生成/ 的/ MPI/ 程序/ 用/ mpich2/ 编译/ 后/ 在/ SunWay/ 集群/ 上/ 运行/ ,/ 运行/ 结果/ 如表/ 1/ 所示/ ./ 表/ 1SW/ -/ VEC/ 生成/ 的/ MPI/ 代码/ 正确性/ 验证/ 结果/ 测试/ 集/ 程序/ 数/ 正确/ 执行/ 正确/ 翻译/ 失败/ 成功率/ // %/ Perfect1268450/ ./ 00SPEC2000261620661/ ./ 54NPB3/ ./ 21189272.73/ 对/ 文中/ 提出/ 的/ 改进/ 方法/ 进行/ 对比/ 测试/ ;/ 性能/ 测试/ 是/ 指/ 将/ MPI/ 并行/ 代码/ 的/ 运行/ 时间/ ,/ 与/ 串行/ 代码/ 时间/ 对比/ 计算/ 加速/ 比/ ,/ 测试/ 性能/ ./ 实验/ 平台/ 建立/ 在/ SunWay/ 集群/ 系统/ 上/ ,/ 配备/ Linux/ 操作系统/ ,/ 版本/ 为/ ReadhatEnterprise5/ ,/ mpich2/ 的/ 版本/ 为/ 1.2/ ./ 5/ ./ 该/ 集群/ 由/ 20/ 个/ 节点/ 组成/ ,/ 每个/ 节点/ 配置/ 4/ 个/ 主频/ 2.8/ GHz/ 的/ 处理器/ ./ 6.1/ 正确性/ 验证/ 将/ 生成/ 的/ 代码/ 用/ mpich2/ 编译/ ,/ 以/ NPB/ 测试/ 集下/ BT/ 程序/ 中/ rhs/ ./ f/ 文件/ 为例/ ,/ 如图/ 6/ 所示/ 为/ 该/ 文件/ 并行/ 化/ 前后/ 的/ 串行/ 和/ 并行/ 代码/ 片段/ ./ 其中/ ,/ 并行/ 化后/ 循环/ 依次/ 执行/ 了/ 循环展开/ 和/ 循环/ 合并/ 操作/ ,/ 因此/ ,/ rhs/ ./ f/ 的/ 并行程序/ 代码段/ 比/ 串行/ 程序/ 更/ 简洁/ ./ 其中/ ,/ 正确/ 翻译/ 表示/ SW/ -/ VEC/ 能够/ 正确/ 转换/ ,/ 但/ 运行/ 结果/ 报错/ 的/ 程序/ 个数/ ,/ 成功率/ 由/ 正确/ 执行/ 个数/ 与/ 程序/ 总数/ 相比/ 求得/ ./ 导致/ 代码运行/ 出错/ 的/ 原因/ 在于/ Open64/ 的/ whirl2f/ // whirl2c/ 模块/ 本身/ 存在/ 问题/ ,/ 因为/ Open64/ 的/ 中间/ 语言/ whirl/ 是/ 一种/ 多层/ 语言/ ,/ 从/ 高到/ 低/ 依次/ 为/ VeryHighwhirl/ ,/ Highwhirl/ ,/ Midwhirl/ ,/ Lowwhirl/ 和/ VeryLowwhirl/ ./ 实施/ 程序/ 优化/ 时/ 所在/ whirl/ 层次/ 越高/ ,/ 从/ 中间/ 语言/ 转换成/ Fortran/ // C语言/ 的/ 正确率/ 越高/ ,/ 出错/ 的/ 概率/ 也/ 就/ Page10/ 越低/ ./ VeryHighwhirl/ 阶段/ 可/ 直接/ 重新/ 翻译成/ Fortran/ // C/ 的/ 程序/ ./ 而/ 在/ LNO/ 阶段/ ,/ 中间/ 语言/ 已降/ 至/ High/ 层/ ./ 程序/ 正确/ 翻译/ 但/ 运行/ 结果/ 出错/ 则/ 是/ 由于/ 部分/ 激进/ 的/ 程序/ 优化/ 和/ 从/ 中间/ 语言/ 到/ 高级/ 语言/ 进行/ 翻译/ 时/ 的/ 错误/ 共同/ 所致/ ./ 这/ 是因为/ ,/ LNO/ 优化/ 必须/ 在/ -/ O3/ 选项/ 下才/ 能够/ 实施/ ,/ 此时/ 在/ 翻译/ 时/ 容易/ 出现/ 全局变量/ 和/ 局部变量/ 的/ 混淆/ 、/ 类型/ 翻译/ 出错/ 等/ 错误/ ,/ 导致/ 翻译/ 通过/ ,/ 但/ 运行/ 失败/ ./ 表/ 1/ 结果/ 说明/ ,/ SW/ -/ VEC/ 能够/ 对/ Perfect/ 、/ SPEC/ -/ 2000/ 和/ NPB/ 测试/ 集中/ 的/ 大部分/ 程序/ 进行/ 面向/ 分布/ 存储/ 的/ MPI/ 并行/ 代码/ 自动/ 生成/ ./ 6.2/ 优化/ 效果/ 测试/ 6.2/ ./ 1/ 依赖/ 测试/ 利用/ 4.1/ 节中/ 提出/ 的/ 二次/ 数组/ 下/ 标的/ 依赖/ 测试方法/ QP/ 测试/ 对/ Perfect/ 测试/ 集中/ 含有/ 二次/ 数组/ 下标/ 引用/ 的/ 程序/ 进行/ 测试/ ,/ 结果/ 如表/ 2/ 所示/ ./ 表/ 2/ 使用/ QP/ 测试/ 前后/ Perfect/ 测试/ 集/ 程序/ 依赖/ 测试/ 结果/ 程序/ 名称/ DYFESM473396OCEAN3502530QCD2448154TRFD7674/ 表/ 2/ 说明/ ,/ 对于/ Perfect/ 程序/ 中/ 含有/ 二次/ 数组/ 下标/ 引用/ 的/ 程序/ ,/ QP/ 测试/ 能够/ 对/ 这些/ 程序/ 中/ 的/ 二次/ 数组/ 下标/ 引用/ 给出/ 正确/ 的/ 依赖/ 测试/ 结果/ ./ 为/ 说明/ QP/ 测试/ 对/ 循环/ 并行/ 识别/ 的/ 影响/ ,/ 针对/ Perfect/ 测试/ 集中/ 其它/ 几个/ 含有/ 二次/ 数组/ 下表/ 引用/ 的/ 程序/ 也/ 使用/ 带有/ QP/ 测试/ 的/ 编译器/ 进行/ 了/ 翻译/ 并/ 运行/ ,/ 结果/ 如图/ 7/ 所示/ ./ 图/ 7/ 使用/ QP/ 测试/ 前后/ 程序/ 并行/ 循环/ 个数/ 对比/ 图/ 其中/ ,/ 带有/ “/ +/ ”/ 号/ 的/ 数据项/ 表示/ 该/ 程序/ 使用/ QP/ 测试/ 之后/ 并行/ 循环/ 和/ 串行/ 循环/ 的/ 个数/ ./ 从图/ 7/ 中/ 可以/ 看出/ ,/ 对/ 这些/ 程序/ 而言/ ,/ 使用/ QP/ 测试/ 之后/ ,/ 并行/ 循环/ 的/ 个数/ 有所增加/ ,/ 仅/ ARC2D/ 程序/ 并行/ 循环/ 个数/ 没有/ 发生变化/ ,/ 这/ 是因为/ ,/ 对于/ 程序/ 中/ 的/ 一些/ 循环/ ,/ 虽然/ 使用/ QP/ 测试/ 之后/ 能够/ 消除/ 部分/ 伪/ 依赖/ ,/ 但/ 还有/ 一些/ QP/ 测试/ 无法/ 处理/ 的/ 数组/ 下标/ 导致/ 其/ 仍/ 无法/ 并行/ ./ 6.2/ ./ 2/ 并行/ 识别/ 将/ 4.2/ 节/ 提出/ 的/ 并行/ 识别方法/ 添加/ 到/ SW/ -/ VEC/ 系统/ 中/ ,/ 对/ NPB/ 测试/ 集中/ 的/ 5/ 个/ 核心/ 程序/ 进行/ 测试/ ,/ 得到/ 并行/ 循环/ 识别/ 结果/ 如表/ 3/ 所示/ ./ 表/ 3/ 并行/ 识别/ 优化/ 前后/ 并行/ 循环/ 识别/ 个数/ 对比/ 程序/ 名称/ CG3799741704/ -/ EP83311400/ -/ FT39661061607/ -/ IS175533801/ -/ MG721414332012013/ -/ 其中/ ,/ “/ 前/ ”/ “/ 后/ ”/ 分别/ 表示/ 优化/ 前/ 和/ 优化/ 后/ 循环/ 的/ 个数/ ./ 表/ 3/ 中仅/ Invalid/ 一列/ 是/ 本文/ 不能/ 识别/ 的/ 循环/ 个数/ ,/ 其/ 不仅/ 包含/ 本文/ 不能/ 进行/ 并行处理/ 的/ 循环/ ,/ 还/ 包括/ 那些/ 包含/ 跳转/ 和/ 过程/ 返回/ 语句/ 的/ 一般/ 嵌套循环/ ,/ 而/ 优化/ 前/ 的/ 并行/ 化/ 编译器/ 只能/ 识别/ PNL/ 和/ 少数/ 的/ SNL/ 循环/ ./ 从中/ 不难/ 发现/ ,/ 优化/ 后/ 的/ 并行/ 识别方法/ 能够/ 识别/ 更/ 多/ 的/ 并行/ 循环/ ./ 6.2/ ./ 3/ 通信/ 优化/ 将/ 生成/ 的/ MPI/ 代码/ 进行/ 通信/ 优化/ ,/ 其中/ 通信/ 优化/ 前/ 阻塞/ 方式/ 的/ 消息/ 传递函数/ 已/ 被/ 非/ 阻塞/ 方式/ 函数/ 替换/ ,/ 并/ 对/ 多个/ 类似/ 消息/ 进行/ 合并/ ./ 将/ NPB/ 和/ SPEC2000/ 中/ 部分/ 程序实施/ 通信/ 优化/ 前后/ 的/ MPI/ 程序运行/ 在/ SunWay/ 集群/ 上/ ,/ 记录/ 4/ 进程/ 下/ 运行/ 时间/ 得到/ 加速/ 比/ 示意图/ 如图/ 8/ 所示/ ./ 图/ 8/ 结果表明/ ,/ 对于/ 被测/ 程序/ 而言/ ,/ 实施/ 通信/ 优化/ 后/ ,/ 生成/ 的/ MPI/ 代码/ 能够/ 获得/ 性能/ 提升/ ./ 在/ 实施/ 优化/ 前/ ,/ 平均/ 并行/ 加速/ 比为/ 2.50/ ,/ 优化/ 后/ 可/ 达到/ 2.74/ ,/ 性能/ 提升/ 约/ 10/ %/ ./ 6.3/ 性能/ 测试/ 将/ 上述/ 部分/ 正确/ 执行/ 的/ 测试/ 集/ 程序/ 在/ 实验/ 平台/ 上/ 运行/ ,/ 同时/ ,/ 为了/ 说明/ 性能/ 提升/ ,/ 记录/ Paraguin/ 编/ Page11/ 译后/ 的/ 程序运行/ 时间/ ,/ 得到/ 4/ 进程/ 下/ 的/ 加速/ 比如/ 图/ 9/ 所示/ ./ 图/ 9Paraguin/ 与/ SW/ -/ VEC/ 的/ MPI/ 程序/ 加速/ 比/ 对比/ 图/ 9/ 结果表明/ ,/ 对/ 这些/ 程序/ 而言/ ,/ 由/ Paraguin/ 生成/ 的/ 并行程序/ 平均/ 加速/ 比可达/ 2.31/ ,/ 而/ SW/ -/ VEC/ 生成/ 的/ 程序/ 平均/ 加速/ 比可达/ 2.74/ ,/ 性能/ 提升/ 18.6/ %/ ./ 结果/ 说明/ ,/ 与/ Paraguin/ 相比/ ,/ 利用/ SW/ -/ VEC/ 编译/ 后/ 生成/ 的/ MPI/ 程序/ 能够/ 在/ SunWay/ 集群/ 上/ 运行/ 时间/ 更/ 短/ ,/ 能够/ 获得/ 更好/ 的/ 性能/ ./ 7/ 结论/ 相对/ 于/ 向/ 量化/ 和/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ 而言/ ,/ 面向/ 分布/ 存储/ 并行/ 系统/ 的/ 编译器/ 发展/ 相对/ 落后/ ./ 为了/ 利用/ 并行/ 化/ 编译器/ 自动/ 生成/ 能够/ 在/ 分布/ 存储/ 结构/ 上/ 运行/ 的/ MPI/ 并行/ 代码/ ,/ 本文/ 为/ 当前/ 最/ 先进/ 的/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ Open64/ 设计/ 并/ 实现/ 了/ 一个/ 支持/ MPI/ 代码生成/ 的/ 后/ 端/ ./ 计算/ 划分/ 模块/ 介绍/ 了/ 如何/ 自动/ 确定/ 计算/ 划分/ 和/ 数据分布/ 信息/ ,/ 对于/ 如何/ 判定/ 计算/ 划分/ 和/ 数据分布/ 的/ 一致性/ 给出/ 了/ 理论依据/ ./ 循环/ 优化/ 模块/ ,/ 为/ Open64/ 依赖/ 测试/ 部分/ 设计/ 了/ 能够/ 测试/ 含有/ 二次/ 下标/ 表达式/ 的/ 依赖/ 测试方法/ ,/ 优化/ 了/ Open64/ 的/ 依赖/ 测试/ 能力/ ,/ 同时/ ,/ 通过/ 改进/ Open64/ 中/ 的/ 并行/ 识别/ 过程/ ,/ 提升/ 了/ Open64/ 的/ 并行/ 识别/ 能力/ ./ 在/ MPI/ 代码生成/ 模块/ ,/ 通过/ 利用/ 中间/ 语言/ 传递信息/ ,/ 确保/ Open64/ 能够/ 正确/ 生成/ MPI/ 并行/ 代码/ ,/ 并/ 对/ 生成/ 后/ 的/ MPI/ 代码/ 进行/ 了/ 优化/ ,/ 提升/ 了/ MPI/ 并行/ 代码/ 的/ 执行/ 效率/ ./ 与/ 文献/ [/ 2/ ]/ 工作/ 相比/ ,/ 本文/ 工作/ 除了/ 注重/ 后端/ MPI/ 代码生成/ 的/ 正确性/ 和/ 代码/ 的/ 执行/ 效率/ ,/ 还/ 对/ 循环/ 优化/ 部分/ 进行/ 了/ 改进/ ,/ 使/ SW/ -/ VEC/ 更/ 适于/ 分布/ 存储/ 结构/ 的/ 并行/ ;/ 与/ 文献/ [/ 3/ ]/ 工作/ 相比/ ,/ SW/ -/ VEC/ 系统/ 能够/ 更好/ 地/ 处理过程/ 间/ 和/ 全局/ 调用/ 时/ 的/ 通信/ 数据/ ,/ 生成/ 的/ MPI/ 代码/ 效率/ 更高/ ;/ 与/ 文献/ [/ 4/ ]/ 工作/ 相比/ ,/ 本文/ 研究/ 平台/ Open64/ 编译系统/ 本身/ 允许/ 多种语言/ 作为/ 输入/ ,/ 在/ 后/ 端/ MPI/ 代码生成/ 时/ 考虑/ 了/ 对/ 这些/ 语言/ 的/ 支持/ ,/ 因此/ 适用范围/ 更广/ ./ 类似/ 的/ 研究/ 工作/ 还有/ MichaelClassen/ 和/ MartinGriebl/ 在/ 凸/ 多面体/ 模型/ 下/ ,/ 针对/ 分布/ 存储/ 结构/ 的/ 代码生成/ [/ 19/ ]/ 和/ Kwon/ 等/ 人/ [/ 20/ ]/ 提出/ 的/ 方法/ ,/ 前者/ 因/ 实验/ 测试环境/ 无法/ 进行/ 对比/ ,/ 适用性/ 受限/ ,/ 而/ 后者/ 是/ 将/ OpenMP/ 程序转换/ 为/ MPI/ 程序/ ,/ 是/ 一个/ 从/ 并行/ 到/ 并行/ 的/ 过程/ ./ 实验/ 测试/ 分别/ 从/ MPI/ 代码/ 的/ 正确性/ 、/ 系统优化/ 效果/ 和/ 性能/ 测试/ 3/ 个/ 方面/ 进行/ 了/ 验证/ ,/ 结果表明/ :/ 本文/ 为/ Open64/ 设计/ 的/ MPI/ 后端/ 能够/ 生成/ 可/ 直接/ 在/ 高性能/ 计算机/ 上/ 运行/ 的/ MPI/ 程序/ ,/ 与/ 传统/ 面向/ 分布/ 存储/ 并行/ 系统/ 的/ 编译器/ 相比/ ,/ 利用/ 本文/ 设计/ 的/ 编译器/ 生成/ 的/ MPI/ 程序执行/ 效率/ 更高/ ./ 由于/ 面向/ 分布/ 存储/ 的/ 并行/ 化/ 编译/ 粒度/ 较/ 粗/ ,/ 而/ Open64/ 是/ 面向/ 共享/ 存储/ 并行/ 系统/ 的/ 编译器/ ,/ 部分/ 优化/ 方法/ 还/ 不/ 完全/ 适合/ 于/ 基于/ 消息传递/ 的/ 并行/ 编程语言/ ,/ 如/ 循环/ 交换/ 过程/ ,/ Open64/ 是/ 将/ 并行/ 循环/ 尽量/ 移动/ 到/ 最/ 内层/ ,/ 而/ 对于/ MPI/ 程序/ 而言/ ,/ 并行/ 循环/ 越/ 靠近/ 外层/ ,/ 生成/ 的/ 并行/ 代码执行/ 效率/ 就/ 越/ 高/ ./ 因此/ ,/ 本文/ 下/ 一步/ 研究/ 工作/ 是/ 调整/ 和/ 改进/ 这些/ 优化/ 方法/ ,/ 使/ 其/ 更/ 适合/ 于/ MPI/ 并行/ 代码/ 的/ 生成/ ./ 致谢/ 在/ 此/ 向/ 在/ 百忙之中/ 抽出/ 时间/ 评阅/ 本文/ 和/ 提出/ 宝贵/ 修改意见/ 的/ 评审/ 专家/ 、/ 同行/ 和/ 编辑部/ 工作人员/ 表示感谢/ ,/ 向/ 为/ 本文/ 提供/ 研究/ 基础/ 的/ 前辈/ 致敬/ !/ 

