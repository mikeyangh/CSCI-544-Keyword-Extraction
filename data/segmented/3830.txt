Page1/ 性能/ 非对称/ 多核/ 处理器/ 上/ 的/ 自/ 适应/ 调度/ 聂/ 鹏程/ 1/ )/ 段振华/ 1/ )/ 田聪/ 1/ )/ 杨孟飞/ 2/ )/ 1/ )/ (/ 西安电子科技大学/ 计算/ 理论/ 与/ 技术/ 研究所/ 西安/ 710071/ )/ 2/ )/ (/ 中国空间技术研究院/ 北京/ 100094/ )/ 摘要/ 现有/ 的/ 性能/ 非对称/ 多核/ 调度/ 算法/ 要么/ 不能/ 充分利用/ 其/ 体系结构/ 而/ 吞吐量/ 低/ ,/ 要么/ 能/ 充分利用/ 其/ 体系结构/ 但/ 扩展性/ 差/ ./ 有些/ 算法/ 即使/ 考虑/ 了/ 扩展性/ ,/ 但/ 也/ 局限于/ CPU/ 核/ 数目/ ,/ 没有/ 考虑/ 到/ 任务/ 数/ 方面/ 的/ 扩展性/ ./ 为了/ 解决/ 这些/ 问题/ ,/ 作者/ 提出/ 了/ 一个/ 自/ 适应/ 调度/ 算法/ (/ 称为/ AS4AMS/ )/ ./ 在/ 任务/ 的/ 每/ 一次/ 调度/ 中/ ,/ AS4AMS/ 首先/ 通过/ 分析/ 任务/ 运行/ 时/ 的/ 平均/ 停驻/ 时间/ 得出/ 任务/ 的/ 计算/ 需求/ ,/ 然后/ 根据/ 这些/ 需求/ 以及/ 各/ CPU/ 核/ 的/ 负载/ 情况/ 将/ 任务分配/ 到/ 合适/ 的/ CPU/ 核上/ 运行/ ./ 另外/ ,/ 该/ 算法/ 任务/ 结束/ 前/ ,/ 会/ 不断/ 重复/ 上述/ 过程/ 以/ 适应/ 任务/ 需求/ 的/ 不断/ 变化/ ./ 实验/ 结果表明/ :/ 与/ 现有/ 方法/ 相比/ ,/ 所/ 提出/ 的/ 方法/ 扩展性/ 更好/ 并且/ 吞吐量/ 也/ 更/ 大/ ./ 关键词/ 多核/ 处理器/ ;/ 性能/ 非对称/ ;/ 操作系统/ ;/ 调度/ 1/ 引言/ 当前/ ,/ 微/ 体系结构/ 的/ 发展/ 已经/ 从/ 过去/ 的/ 单纯/ 提升/ CPU/ 的/ 速度/ 转变/ 为/ 提升/ CPU/ 的/ 并行/ 程度/ [/ 1/ ]/ ./ 与/ 单核/ 处理器/ 相比/ ,/ 采用/ 多核/ 设计/ 的/ 处理器/ 扩展性/ 强/ ,/ 性能/ 高且/ 散热/ 少/ 能耗/ 低/ [/ 2/ -/ 3/ ]/ ./ 现在/ 多核/ 体系结构/ 已/ 成为/ CPU/ 发展/ 的/ 主流/ ./ 著名/ 的/ 处理器/ 设计/ 制造厂商/ AMD/ 、/ ARM/ 、/ Fujitsu/ 、/ IBM/ 、/ Intel/ 和/ Sun/ 的/ 主流产品/ 全是/ 采用/ 多核/ 体系结构/ ,/ 这些/ 产品/ 涵盖/ 了/ 从/ 嵌入/ Page2/ 式/ 、/ PC/ 到/ 服务器/ 的/ 所有/ 计算/ 领域/ ./ 随着/ 多核/ CPU/ 的/ 运用/ 和/ 发展/ ,/ 最近/ 体系结构/ 研究者/ 发现/ ,/ 采用/ 性能/ 非对称/ 设计/ 的/ 多/ 核/ 处理器/ 具有/ 更/ 高/ 的/ 能效/ 比/ [/ 4/ -/ 5/ ]/ ./ 这里/ 需要/ 注意/ 的/ 是/ ,/ 性能/ 非对称/ 多核/ 处理器/ 只是/ 非对称/ 多核/ 处理器/ 中/ 的/ 一种/ [/ 6/ ]/ ./ 根据/ 核/ 的/ 差异/ 类型/ ,/ 非对称/ 多核/ 处理器/ 可以/ 分为/ 性能/ 非对称/ 多核/ 处理器/ 和/ 功能/ 非对称/ 多核/ 处理器/ ./ 功能/ 非对称/ 是/ 指多核/ 处理器/ 中/ 不同/ 类型/ 核能/ 处理/ 的/ 任务/ 不同/ (/ 指令集/ 不同/ )/ ./ 现有/ 的/ 这类/ 处理器/ 当中/ 比较/ 典型/ 的/ 架构/ 是/ 少数/ 用于/ 控制/ 的/ 通用/ 核/ 搭配/ 多个/ 专用/ 计算/ 核/ ./ IBM/ 的/ CellBE/ 、/ LSI/ 的/ AXXIA/ 网络/ 处理器/ 以及/ TI/ 的/ 搭配/ ARM/ 核/ 与/ DSP/ 的/ SOC/ 都/ 属于/ 功能/ 非对称/ 多核/ 处理器/ ./ 在/ 功能/ 非对称/ 多核/ 中/ ,/ 通常/ 同一/ 任务/ 不能/ 在/ 不同/ 类型/ 的/ 核上/ 执行/ ./ 性能/ 非对称/ 则/ 指多核/ 处理器/ 中/ 的/ 核/ 的/ 功能/ 及/ 能够/ 处理/ 的/ 任务/ 相同/ ,/ 但/ 核/ 的/ 性能/ (/ 处理速度/ )/ 不尽相同/ ./ 由于/ 每个/ 核/ 的/ 功能/ 相同/ ,/ 所以/ 同一/ 任务/ 可以/ 在/ 性能/ 非对称/ 多核/ 处理器/ 的/ 各个/ 核间/ 来回/ 迁移/ 并/ 执行/ ./ 我们/ 接下来/ 讨论/ 的/ 调度/ 算法/ 针对/ 的/ 就是/ 这种/ 性能/ 非对称/ 多核/ 处理器/ ./ 性能/ 非对称/ 多核/ 处理器/ 的/ 高/ 能效/ 比是/ 由/ 被/ 调度/ 任务/ (/ 在/ 本文/ 中/ 对/ 任务/ 、/ 线程/ 和/ 进程/ 不/ 做/ 区分/ )/ 的/ 特点/ 决定/ 的/ ,/ 不同/ 的/ 任务/ 通常/ 有/ 不同/ 的/ 计算/ 需求/ ,/ 即便/ 是/ 同一/ 任务/ 的/ 计算/ 需求/ 也/ 会/ 随着/ 执行/ 不断/ 变化/ ./ 性能/ 非对称/ 多核/ 处理器/ (/ 也/ 称为/ 性能/ 异构/ 多核/ 处理器/ )/ 用/ 性能/ 高/ 的/ 核/ (/ 简称/ 快核/ )/ 执行/ 计算/ 密集型/ 任务/ ,/ 用/ 性能/ 低/ 的/ 核/ (/ 简称/ 慢核/ )/ 执行/ 存储/ 密集型/ 任务/ ./ 因此/ ,/ 与/ 全部/ 采用/ 高性能/ 核/ 的/ 对称/ 处理器/ 相比/ ,/ 性能/ 非对称/ 多核/ 处理器/ 具有/ 更/ 低/ 的/ 能耗/ ;/ 与/ 全部/ 采用/ 低/ 性能/ 核/ 的/ 对称/ 多核/ 处理器/ 相比/ ,/ 性能/ 非对称/ 多核/ 处理器/ 具有/ 更/ 高/ 的/ 吞吐量/ ,/ 进一步/ 实现/ 了/ 高性能/ 与/ 低能耗/ 的/ 结合/ ./ 但/ 性能/ 非对称/ 多核/ 处理器/ 的/ 这种/ 能效/ 比/ 建立/ 在/ 操作系统/ 的/ 准确/ 调度/ 之上/ ./ 也就是说/ ,/ 任务/ 所/ 分配/ 的/ CPU/ 核/ 的/ 计算能力/ 应该/ 是/ 与/ 该/ 任务/ 的/ 计算/ 需求/ 相匹配/ 的/ ./ 在/ 性能/ 非对称/ 多核/ 系统/ 中/ ,/ 如果/ 调度/ 器/ 将/ 计算/ 密集/ 任务分配/ 到/ 性能/ 低/ 的/ 核上/ ,/ 将/ 存储/ 密集型/ 任务分配/ 到/ 性能/ 高/ 的/ 核上/ ,/ 那么/ 性能/ 高/ 的/ 核/ 将/ 大部分/ 时间/ 处于/ 等待/ 状态/ ,/ 而/ 性能/ 低/ 的/ 核/ 却/ 忙/ 得/ 不可开交/ ,/ 这样/ 极大/ 地/ 降低/ 了/ 系统/ 的/ 吞吐/ 性能/ ./ 2/ 算法/ 的/ 提出/ 自从/ 性能/ 非对称/ 多核/ 处理器/ 在/ 2003/ 年/ 由/ Kumar/ 等/ 人/ [/ 5/ ]/ 正式/ 提出/ 以来/ ,/ 有/ 不少/ 面向/ 性能/ 非对称/ 多核/ 体系结构/ 的/ 调度/ 算法/ 被/ 提出/ [/ 7/ -/ 12/ ]/ ./ Li/ 等/ 人/ [/ 7/ ]/ 在/ Linux/ 系统/ 上/ 实现/ 了/ 一个/ 性能/ 非对称/ 调度/ 器/ (/ 称为/ AMPS/ )/ ./ 该/ 调度/ 器/ 确保/ 每个/ 核上/ 的/ 负载/ 与/ 各自/ 的/ 性能/ 成正比/ ,/ 并且/ 保证/ 性能/ 高/ 的/ 核/ 的/ 利用率/ 不/ 低于/ 性能/ 低/ 的/ 核/ ./ AMPS/ 简单/ 易于/ 实现/ ,/ 具有/ 很/ 好/ 的/ 扩展性/ ./ 但是/ AMPS/ 在/ 调度/ 时/ 并/ 没有/ 考虑/ 任务/ 的/ 计算/ 特性/ 以及/ 处理器/ 的/ 性能/ 非/ 对称性/ ,/ 所以/ AMPS/ 有/ 可能/ 将/ 存储/ 密集型/ 任务分配/ 到/ 快/ 核/ ,/ 造成/ 系统/ 效率/ 降低/ ./ Kumar/ 等/ 人/ [/ 8/ ]/ 与/ Becchi/ 等/ 人/ [/ 9/ ]/ 分别/ 提出/ 两个/ 相似/ 的/ 在线/ 跟踪/ 方法/ ./ 它们/ 首先/ 将/ 待/ 调度/ 线程/ 在/ 各种/ CPU/ 核/ 类型/ 上/ 试运行/ 一段时间/ 以/ 跟踪/ 线程/ 的/ 运行/ 情况/ ,/ 并/ 计算/ 这些/ 线程/ 在/ 快/ 核上/ 相对/ 在/ 慢核/ 上/ 的/ 性能/ 加速/ 比/ ./ 然后/ ,/ 将/ 具有/ 最高/ 加速/ 比/ 的/ 那些/ 线程/ 真正/ 分配/ 到/ 快/ 核上/ 执行/ ./ 只要/ 线程/ 未/ 结束/ ,/ 这个/ 试运行/ 然后/ 再/ 分配/ 的/ 过程/ 会/ 不断/ 重复/ ./ 尽管/ Kumar/ 等/ 人/ [/ 8/ ]/ 与/ Becchi/ 等/ 人/ [/ 9/ ]/ 的/ 方法/ 相对/ 那些/ 没有/ 考虑/ CPU/ 性能/ 非/ 对称性/ 的/ 调度/ 更/ 准确/ ,/ 但/ 它们/ 的/ 调度/ 开销/ 非常/ 大/ ,/ 扩展性/ 特别/ 差/ ./ 这是/ 由于/ 它们/ 需要/ 在/ 每种/ CPU/ 核上/ 试运行/ 以/ 获取/ 加速/ 比/ ,/ 所以/ 很难/ 适应/ CPU/ 核/ 种类/ 的/ 增长/ ./ 另外/ ,/ 它们/ 总是/ 假设/ 任务/ 是/ 同时/ 到达/ 的/ ,/ 并且/ 加速/ 比/ 的/ 比较/ 是/ 建立/ 在/ 全局/ 同步/ 的/ 基础/ 之上/ 的/ ./ 也就是说/ ,/ 必须/ 只有/ 在/ 所有/ 的/ 线程/ 在/ 各种/ CPU/ 核上试/ 执行/ 一遍/ 后/ 才能/ 比较/ 出/ 加速/ 比/ 最大/ 的/ 线程/ ,/ 这/ 就/ 意味着/ 当/ 系统/ 线程/ 数目/ 多/ 的/ 时候/ ,/ 调度/ 算法/ 的/ 开销/ 将/ 非常/ 大/ ./ 最后/ ,/ 任务/ 在/ 试运行/ 阶段/ 的/ 来回/ 迁移/ 也/ 容易/ 造成/ 负载/ 不/ 均衡/ ./ Shelepov/ 等/ 人/ [/ 10/ ]/ 提出/ 一个/ 离线/ 分析/ 的/ 方法/ (/ 称为/ HASS/ )/ ./ 在/ 运行/ 之前/ ,/ HASS/ 先/ 离线/ 分析程序/ 的/ 体系结构/ 属性/ ,/ 并/ 将/ 这些/ 属性/ 嵌入/ 到/ 程序/ 二进制/ 文件/ 当中/ ./ 调度/ 程序/ 读取/ 这些/ 属性/ 后/ ,/ 将/ 任务分配/ 到/ 合适/ 的/ 核上/ 执行/ ,/ 不/ 需要/ 在/ 真正/ 执行/ 时/ 动态/ 地/ 在/ 各种/ CPU/ 核上/ 试运行/ ./ 与/ 之前/ 的/ 在线/ 动态/ 方法/ 相比/ ,/ HASS/ 确实/ 简单/ 易于/ 实现/ ,/ 有/ 较/ 好/ 的/ 扩展性/ ,/ 但是/ 它/ 获取/ 的/ 属性/ 是/ 根据/ 一个/ 给定/ 输入/ 运行/ 分析/ 所/ 得到/ 的/ 平均值/ ,/ 不适/ 用于/ 任务/ 计算/ 需求/ 变化/ 频繁/ 的/ 任务/ ./ 另外/ ,/ 离线/ 分析/ 时/ 给定/ 的/ 输入/ 的/ 选取/ 也/ 并非易事/ ,/ 因为/ 这个/ 输入/ 必须/ 要/ 有/ 一定/ 的/ 代表性/ 才能/ 使/ 程序/ 表现/ 出来/ 的/ 计算/ 特性/ 反映/ 其它/ 输入/ 的/ 情况/ ./ 所以/ ,/ HASS/ 难以/ 推广/ 及/ 用于/ 实际/ 系统/ 当中/ ./ 在/ 我们/ 前面/ 的/ 工作/ 中/ ,/ 结合/ 已有/ 在线/ 方法/ 和/ 离线/ 方法/ 的/ 优点/ 也/ 提出/ 了/ 一个/ 性能/ 非对称/ 多核/ 调度/ 算法/ [/ 11/ ]/ (/ 称为/ ESHMP/ )/ ./ ESHMP/ 也/ 是/ 一种/ 在线/ 试运行/ 的/ 方法/ ,/ 与/ 之前/ 的/ 在线/ 方法/ 不同/ 的/ 是/ ,/ 它/ 使用/ 单条/ 指令/ 的/ 平均/ 停驻/ 时间/ (/ AverageStallTimePerInstruction/ ,/ ASTPI/ )/ 衡量/ 每个/ 线程/ 的/ 计算/ 需求/ ,/ 而/ 不是/ 加速/ 比/ ./ 一个/ 线程/ 的/ ASTPI/ 是/ 指该/ 线程/ 中/ 的/ Page3/ 单条/ 指令/ 在/ 访存/ 操作/ 上/ 的/ 平均/ 花费/ ,/ 在/ 当前/ 每个/ CPU/ 核/ 具有/ 相同/ 存储/ 体系结构/ 的/ 处理器/ 中/ ,/ 同一/ 线程/ 在/ 同一/ 处理器/ 中/ 的/ 不同/ 核上/ 具有/ 相同/ 的/ ASTPI/ 值/ ./ 如果/ 一个/ 线程/ 的/ ASTPI/ 值越/ 小/ ,/ 则/ 该/ 线程/ 在/ 读写/ 存储/ 操作/ 上/ 的/ 花费/ 越小/ ,/ 加速/ 比/ 也/ 就/ 越/ 大/ ./ 所以/ ,/ ESHMP/ 只/ 需要/ 将/ 待/ 调度/ 线程/ 在/ 一个/ CPU/ 核/ 类型/ 上/ 执行/ 就/ 可以/ 得出/ 该/ 线程/ 的/ 计算/ 需求/ ,/ 计算/ 复杂度/ 与/ 具体/ 平台/ 上/ 的/ CPU/ 核/ 类型/ 数目/ 无关/ ,/ 具有/ 较/ 好/ 的/ 扩展性/ ./ 另外/ ,/ ESHMP/ 吸取/ 以往/ 在线/ 调度/ 周期/ 跟踪/ 的/ 优点/ ,/ 也/ 考虑/ 了/ 任务/ 计算/ 需求/ 的/ 阶段性/ 变化/ ./ 因此/ ,/ ESHMP/ 相对/ HASS/ 能/ 适应/ 多种/ 计算/ 特性/ 的/ 任务/ ,/ 包括/ 计算/ 需求/ 频繁/ 变化/ 的/ 任务/ ./ 虽然/ ESHMP/ 继承/ 了/ 前述/ 算法/ 的/ 优点/ ,/ 具有/ 更好/ 的/ 性能/ ,/ 但是/ ESHMP/ 也/ 没有/ 考虑/ 在/ 任务/ 数/ 方面/ 的/ 扩展性/ ,/ 需要/ 全局/ 同步/ 比较/ 任务/ 的/ 平均/ 停驻/ 时间/ ./ 为了/ 解决/ 上述/ 问题/ ,/ 本文/ 提出/ 一个/ 自适应性/ 能/ 非对称/ 多核/ 调度/ (/ AdaptiveSchedulingforAsym/ -/ metricMulticoreSystems/ ,/ AS4AMS/ )/ ./ AS4AMS/ 采用/ 局部/ 队列/ ,/ 根据/ 系统/ 的/ 负载/ 并/ 结合/ 任务/ 的/ 计算/ 需求/ ,/ 将/ 待/ 调度/ 任务分配/ 到/ 合适/ 的/ 核上/ 执行/ ,/ 没有/ 任务/ 同时/ 到达/ 的/ 限制/ 也/ 无需/ 任务/ 同步/ 并/ 比较/ ./ 实验/ 表明/ :/ 与/ 现有/ 方法/ 相比/ ,/ AS4AMS/ 具有/ 更好/ 的/ 扩展性/ ./ 3AS4AMS/ 调度/ 算法/ AS4AMS/ 算法/ 由/ 计算/ 特性/ 分析/ 和/ 任务调度/ 两/ 部分/ 组成/ ./ 每个/ 任务/ 在/ 执行/ 过程/ 中/ 每/ 一次/ 调度/ 都/ 经历/ 计算/ 需求/ 分析/ 和/ 调度/ 这/ 两个/ 阶段/ ./ 另外/ ,/ AS4AMS/ 还/ 定期/ 进行/ 负载平衡/ 处理/ ,/ 这样/ 可以/ 避免/ 因/ 负载/ 不/ 均衡/ 而/ 影响/ CPU/ 利用率/ ./ 3.1/ 任务/ 计算/ 特性/ 分析/ 一般来说/ ,/ 与/ 在/ 性能/ 低/ 的/ 核上/ 的/ 性能/ 相比/ ,/ 基本上/ 所有/ 的/ 任务/ 在/ 性能/ 高/ 的/ 核上/ 都/ 能/ 获得/ 性能/ 提升/ ./ 但/ 不同/ 的/ 任务/ 获得/ 的/ 提升/ 程度/ 很/ 可能/ 不尽相同/ ,/ 即使/ 是/ 同一/ 任务/ 在/ 不同/ 时刻/ 也/ 会/ 有/ 不同/ 的/ 计算/ 需求/ ./ 因此/ ,/ 为了/ 提高/ 系统/ 吞吐量/ ,/ 在/ 所有/ 待/ 调度/ 任务/ 中/ ,/ 仅/ 将/ 那些/ 在/ 性能/ 高/ 的/ 核上/ 具有/ 较/ 高性能/ 提升/ 的/ 任务分配/ 到/ 性能/ 高/ 的/ 核上/ 执行/ ./ 然而/ ,/ 任务/ 计算/ 需求/ 或/ 特性/ 的/ 度量/ 非常/ 关键/ ,/ 它/ 直接/ 关系/ 到/ 性能/ 非对称/ 多核/ 调度/ 算法/ 的/ 性能/ ./ 这里/ ,/ 用/ 单条/ 指令/ 的/ 平均/ 停驻/ 时间/ ASTPI/ 衡量/ 任务/ 的/ 计算/ 特性/ ./ ASTPI/ 值越/ 大/ ,/ 线程/ 的/ 停驻/ 时间/ 越长/ ,/ 在/ 快/ 核上/ 的/ 性能/ 提升/ 程度/ 越小/ ;/ 反之/ ,/ 提升/ 程度/ 越大/ ./ 并且/ ,/ 同一/ 线程/ 在/ 不同/ CPU/ 核上/ 的/ ASTPI/ 相同/ ,/ 因为/ 每个/ 核/ 都/ 有/ 相同/ 的/ 存储/ 体系结构/ (/ 见图/ 1/ )/ ./ 因此/ ,/ 任务/ 只要/ 在/ 任一/ 核上/ 试运行/ 就/ 可以/ 获得/ 其/ 计算/ 特性/ ./ 下面/ ,/ 给出/ ASTPI/ 的/ 计算方法/ ./ 通常/ ,/ 一个/ 任务/ 的/ 完成/ 时间/ CT/ (/ CompletionTime/ )/ 可以/ 划分/ 成/ 执行/ 时间/ ET/ (/ ExecutionTime/ )/ 和/ 停驻/ 时间/ ST/ (/ StallTime/ )/ 两/ 部分/ ./ ET/ 是/ 任务/ 在/ 得到/ 数据/ 后/ 在/ 核上/ 真正/ 执行/ 的/ 时间/ ,/ 等于/ 指令/ 数/ Ninstr/ 与/ 任务/ 所在/ 核/ A/ 的/ 最大/ 执行/ 速度/ MIPSA/ (/ MaximumInstructionsperSecond/ ,/ 核/ A/ 不/ 需要/ 访存/ 时/ 的/ 速度/ )/ 之/ 比/ ,/ 即/ Ninstr/ // MIPSA/ ./ CT/ 可以/ 用/ 指令/ 数/ Ninstr/ 除以/ 该/ 任务/ 所在/ 核/ A/ 上/ 的/ 实际/ 执行/ 速度/ IPSA/ (/ InstructionsperSecond/ )/ 计算/ 出/ ,/ 即/ Ninstr/ // IPSA/ ./ ST/ 是/ 由于/ 任务/ 访存/ 等/ 事件/ 造成/ 的/ CPU/ 核/ 停驻/ 等待时间/ ,/ 可以/ 通过/ CT/ 减去/ ET/ 求得/ ,/ 即/ Ninstr/ // IPSA/ -/ Ninstr/ // MIPSA/ ./ 综上/ ,/ ASTPI/ =/ ST/ // Ninstr/ =/ 1/ // IPSA/ -/ 1/ // MIPSA/ ./ 其中/ ,/ 核/ A/ 的/ 最大/ 执行/ 速度/ MIPSA/ 是/ 核/ A/ 可以/ 提供/ 的/ 最大/ 速度/ ,/ 可以/ 由/ 公式/ MIPSA/ =/ MIPCA/ ×/ FrequencyA/ (/ 在/ 这里/ MIPCA/ 是/ 核/ A/ 每个/ 周期/ 完成/ 的/ 最大/ 任务/ 数/ ,/ 而/ FrequencyA/ 是/ 核/ A/ 的/ 处理/ 频率/ )/ 求/ 出/ ;/ 而/ IPSA/ 是/ 任务/ 在/ 核/ A/ 上/ 的/ 实际/ 执行/ 速度/ ,/ 通过/ 访问/ CPU/ 的/ 硬件/ 计数器/ (/ HardwarePerformanceCounter/ ,/ 一种/ 用于/ 监视/ 任务/ 执行/ 的/ 寄存器/ )/ 获得/ 已经/ 执行/ 完成/ 的/ 指令/ 数/ ,/ 再/ 除以/ 计算/ 时间/ 得出/ ./ 当/ 任务/ 到达/ 系统/ ,/ 调度/ 器/ 对/ 任务/ 的/ 计算/ 特性/ 一无所知/ ./ 调度/ 器/ 将/ 任务分配/ 到/ 负载/ 最少/ 的/ 核上/ 执行/ 一个/ 时间段/ ,/ 并/ 跟踪/ 任务/ 的/ 执行/ 情况/ 计算/ 出其/ ASTPI/ 值/ ./ 并且/ ,/ 调度/ 器会/ 跟踪/ 任务/ 的/ 每/ 一次/ 执行/ 过程/ ,/ 更新/ 任务/ 的/ 计算/ 特性/ ./ 在/ 每个/ CPU/ 核上/ ,/ 调度/ 器/ 除了/ 按/ 优先级/ 维护/ 所有/ 的/ 任务/ ,/ 还/ 按/ ASTPI/ 大小/ 建立/ 任务/ 的/ 相互/ 关系/ ./ 此外/ ,/ 还/ 记录/ 当前/ 核中/ ASTPI/ 值/ 最小/ 的/ 任务/ 和/ ASTPI/ 值/ 最大/ 的/ 任务/ ./ Page43/ ./ 2/ 任务调度/ 当/ 任务/ 的/ 计算/ 特性/ 信息/ (/ 即/ ASTPI/ 值/ )/ 获取/ 到/ 以后/ ,/ 首先/ 比较/ 该/ 任务/ 与/ 所在/ 核/ 其它/ 任务/ 的/ 计算/ 特性/ 关系/ ,/ 然后/ 决定/ 是否/ 迁移/ 、/ 向/ 更/ 快/ 还是/ 更慢/ 的/ 核/ 迁移/ ;/ 最后/ ,/ 如果/ 需要/ 迁移/ ,/ 则/ 根据/ 当前/ 核/ 的/ 负载/ 与/ 目标/ 核/ 的/ 负载/ 关系/ 采用/ 不同/ 的/ 迁移/ 策略/ ./ 具体/ 流程/ 如/ 算法/ 1/ 所示/ ./ 算法/ 1/ ./ 任务调度/ ./ 定义/ :/ t/ 是/ 待/ 调度/ 任务/ ,/ astpi/ 是/ 它/ 的/ 一个/ 字/ 段/ ,/ 表示/ 当前/ 的/ ASTPI/ 值/ ./ Max/ 与/ Min/ 是/ CPU/ 核/ 的/ 两个/ 字/ 段/ ,/ 分别/ 记录/ 核上/ 任务/ 中/ 最大/ 与/ 最小/ 的/ ASTPI/ 值/ ./ tMax/ 和/ tMin/ 则/ 是/ 与/ Max/ 以及/ Min/ 对应/ 的/ 任务/ ./ load/ 是/ CPU/ 核/ 的/ 字/ 段/ ,/ 保存/ 核/ 的/ 负载/ 信息/ ./ ccur/ 表示/ 当前/ 核/ ./ c/ 表示/ 目标/ 核/ ./ faster/ _/ core/ 与/ slower/ _/ core/ 是/ 两个/ 函数/ ,/ 如果/ 当前/ 核/ 类型/ 存在/ 多个/ 核/ ,/ 则/ 返回/ 下/ 一个/ 同/ 类型/ 核/ ;/ 否则/ ,/ 返回/ 分别/ 比/ 当前/ 核/ 更/ 快/ 或者/ 更慢/ 的/ 核/ ./ 1/ ./ if/ (/ ccur/ -/ >/ Min/ </ t/ -/ >/ astpiandt/ -/ >/ astpi/ </ 2/ ./ return3/ ./ endif4/ ./ if/ (/ t/ =/ =/ ccur/ -/ >/ tMin/ )/ then5/ ./ for/ (/ c/ =/ faster/ _/ core/ (/ ccur/ )/ ;/ c/ ;/ c/ =/ faster/ _/ core/ (/ c/ )/ )/ do6/ ./ if/ (/ c/ -/ >/ Min/ </ t/ -/ >/ astpiandt/ -/ >/ astpi/ </ 7/ ./ if/ (/ ccur/ -/ >/ load/ =/ =/ c/ -/ >/ load/ )/ then8/ ./ t/ 与/ c/ -/ >/ tMax/ 互相/ 迁移/ 到/ 对方/ 的/ 核上/ 执行/ 9/ ./ elseif/ (/ ccur/ -/ >/ load/ >/ c/ -/ >/ load/ )/ then10/ ./ 将/ t/ 迁移/ 到/ 核/ c/ 上/ 执行/ 11/ ./ endif12/ ./ break13/ ./ endif14/ ./ endfor15/ ./ elseif/ (/ t/ =/ =/ ccur/ -/ >/ tMax/ )/ then16/ ./ for/ (/ c/ =/ slower/ _/ core/ (/ ccur/ )/ ;/ c/ ;/ c/ =/ slower/ _/ core/ (/ c/ )/ )/ do17/ ./ if/ (/ c/ -/ >/ Min/ </ t/ -/ >/ astpiandt/ -/ >/ astpi/ </ 18/ ./ if/ (/ ccur/ -/ >/ load/ =/ =/ c/ -/ >/ load/ )/ then19/ ./ t/ 与/ c/ -/ >/ tMin/ 互相/ 迁移/ 到/ 对方/ 的/ 核上/ 执行/ 20/ ./ elseif/ (/ ccur/ -/ >/ load/ >/ c/ -/ >/ load/ )/ then21/ ./ 将/ t/ 迁移/ 到/ 核/ c/ 上/ 执行/ 22/ ./ endif23/ ./ break24/ ./ endif25/ ./ endfor26/ ./ endif/ 从/ 算法/ 1/ 中/ 可以/ 看出/ ,/ 只有/ 在/ 待/ 调度/ 任务/ 的/ 计算/ 特性/ 在/ 当前/ 核中/ 是/ 最大/ 或/ 最/ 小时/ ,/ 才/ 考虑/ 将/ 其/ 从/ 当前/ 核/ 迁移/ 到/ 其它/ 核上/ ./ 如果/ 待/ 调度/ 任务/ 是/ 当前/ 核上/ 计算/ 特性/ 最高/ 的/ 任务/ (/ 即/ ASTPI/ 值/ 最小/ )/ ,/ 则/ 考虑/ 将/ 该/ 任务/ 向/ 更/ 快/ 的/ 核/ 迁移/ (/ 如果/ 当前/ 核/ 类型/ 有/ 多个/ 核时/ ,/ 则/ 会/ 先/ 考虑/ 下/ 一同/ 类型/ 核/ )/ ./ 从/ 当前/ 核/ 出发/ 找到/ 一个/ 性能/ 不/ 低于/ 当前/ 核/ 的/ 核/ c/ ,/ 任务/ t/ 在/ 核/ c/ 上/ 所有/ 的/ 任务/ 当中/ 的/ 计算/ 特性/ 不是/ 最大/ 也/ 不是/ 最小/ ./ 然后/ 比较/ 当前/ 核/ 与/ 目标/ 核/ 的/ 负载/ ./ 如果/ 当前/ 核/ 与/ 目标/ 核/ 的/ 负载/ 相同/ ,/ 则/ 将/ 任务/ t/ 与/ 目标/ 核上/ 性能/ 最小/ (/ 即/ ASTPI/ 最大/ )/ 的/ 任务/ 交换/ 核/ 执行/ ./ 如果/ 目标/ 核/ 的/ 负载/ 比/ 当前/ 核/ 的/ 负载/ 小/ ,/ 则/ 直接/ 迁移/ 到/ 目标/ 核上/ 执行/ ./ 如果/ 待/ 调度/ 任务/ 是/ 当前/ 核中/ 计算/ 特性/ 最低/ 的/ 任务/ (/ 即/ ASTPI/ 最大/ )/ ,/ 则/ 考虑/ 将/ 该/ 任务/ 向/ 更慢/ 的/ 核/ 迁移/ (/ 如果/ 当前/ 核/ 类型/ 有/ 多个/ 核时/ ,/ 则/ 会/ 先/ 考虑/ 下/ 一同/ 类型/ 核/ )/ ./ 从/ 当前/ 核/ 出发/ 找到/ 一个/ 性能/ 不/ 高于/ 当前/ 核/ 的/ 核/ c/ ,/ 任务/ t/ 在/ 核/ c/ 上/ 所有/ 的/ 任务/ 当中/ 的/ 计算/ 特性/ 不是/ 最大/ 也/ 不是/ 最小/ ./ 然后/ 比较/ 当前/ 核/ 与/ 目标/ 核/ 的/ 负载/ ./ 如果/ 当前/ 核/ 与/ 目标/ 核/ 的/ 负载/ 相同/ ,/ 则/ 将/ 任务/ t/ 与/ 目标/ 核上/ 性能/ 最大/ (/ 即/ ASTPI/ 最小/ )/ 的/ 任务/ 交换/ 核/ 执行/ ./ 如果/ 目标/ 核/ 的/ 负载/ 比/ 当前/ 核/ 的/ 负载/ 小/ ,/ 则/ 直接/ 迁移/ 到/ 目标/ 核上/ 执行/ ./ 从/ 上/ 看出/ ,/ AS4AMS/ 在/ 调度/ 过程/ 中/ 不断/ 调整/ 任务/ ,/ 使得/ 当前/ 核中/ 性能/ 最高/ 的/ 任务/ 比/ 更/ 快/ 核中/ 性能/ 最低/ 的/ 任务/ 的/ 性能/ 低/ ,/ 并/ 使得/ 当前/ 核中/ 性能/ 最低/ 的/ 任务/ 比/ 更慢/ 核中/ 性能/ 最高/ 的/ 任务/ 性能/ 高/ ./ 也就是说/ ,/ AS4AMS/ 使得/ 快核/ 中/ 的/ 任务/ 与/ 慢核/ 中/ 的/ 任务/ 相比/ ,/ 具有/ 更/ 高/ 的/ 计算/ 特性/ ./ 另外/ ,/ AS4AMS/ 调度/ 使/ 整个/ 系统/ 负载/ 朝/ 更/ 平衡/ 的/ 方向/ 发展/ ./ 如果/ 目标/ 核/ 的/ 负载/ 高于/ 当前/ 核/ 的/ 负载/ ,/ 则/ 待/ 调度/ 任务/ 不/ 迁移/ ,/ 继续/ 在/ 当前/ 核/ 执行/ ./ 最后/ 值得注意/ 的/ 是/ :/ 每次/ 迁移/ 或是/ 交换/ 操作/ 都/ 包含/ 更新/ 相关/ 核上/ 任务/ 的/ ASTPI/ 关系/ 、/ ASTPI/ 最小/ 与/ 最大/ 的/ 任务/ ./ 3.3/ 负载/ 均衡/ 虽然/ AS4AMS/ 在/ 任务/ 到达/ 时/ 以及/ 任务/ 时间/ 片/ 结束/ 进行/ 下/ 一次/ 调度/ 时/ 都/ 保证系统/ 处于/ 平衡/ 状态/ 或/ 向/ 平衡/ 方向/ 发展/ ,/ 但是/ 任务/ 的/ 结束/ 或/ 挂/ 起/ 等/ 事件/ 都/ 会/ 导致系统/ 负载/ 不/ 均衡/ ./ 因此/ ,/ 为了/ 减少/ 负载/ 均衡/ 操作/ 的/ 开销/ ,/ AS4AMS/ 的/ 负载/ 均衡/ 采取/ 基于/ 事件驱动/ 的/ 机制/ ,/ 而/ 传统/ 调度/ 器/ 基本上/ 都/ 是/ 基于/ 时间/ 驱动/ 的/ ,/ 这/ 也/ 是/ 本文/ 的/ 创新/ 点/ 之一/ ./ 也就是说/ ,/ 只有/ 当/ 任务/ 状态/ 发生变化/ 并/ 影响/ 负载/ 时才/ 考虑/ 进行/ 负载/ 均衡/ 操作/ ./ 并且/ ,/ 只有/ 在/ 所在/ 核/ 的/ 负载/ 处于/ 空闲/ 状态/ 或/ 变化/ 超过/ 一定/ 阈值/ 时/ (/ 在/ 我们/ 的/ 实验/ 中取/ 10/ %/ )/ ,/ 才/ 平衡/ 负载/ ./ 另外/ ,/ 与/ 面向/ 对称/ 多核/ 处理器/ 的/ 负载平衡/ 不同/ Page5/ 的/ 是/ ,/ 性能/ 非对称/ 多核/ 处理器/ 的/ 平衡/ 不是/ 简单/ 地/ 保证/ 每个/ 核上/ 的/ 任务/ 数/ 相同/ 或/ 相差/ 不/ 超过/ 1/ ,/ 而是/ 要/ 保证/ 每个/ 核上/ 的/ 相对/ 负载/ 相同/ 或/ 不/ 超过/ 1/ ./ 这里/ 的/ 相对/ 负载/ 是/ 指/ 每个/ 核以/ 最慢/ 核为/ 单位/ 相对/ 自己/ 性能/ 的/ 负载/ ./ 相对/ 负载/ 的/ 计算公式/ 如下/ :/ 其中/ ,/ Loadrel/ 表示/ 相对/ 负载/ ,/ Nthreads/ 表示/ 任务/ 数/ ,/ Freqsmest/ 和/ Freqcur/ 分别/ 表示/ 最小/ 核/ 与/ 当前/ 核/ 的/ 频率/ ./ 我们/ 在/ 算法/ 1/ 和/ 算法/ 2/ 中/ 用到/ 的/ 负载/ 都/ 是/ 相对/ 负载/ ./ 算法/ 2/ ./ 负载/ 均衡/ ./ 定义/ :/ load/ 和/ nthreads/ 是/ CPU/ 核/ 的/ 字/ 段/ ,/ 分别/ 用来/ 保存/ 核/ 的/ 负载/ 信息/ 和/ 线程/ 数目/ ./ ccur/ 表示/ 当前/ 核/ ./ c/ 表示/ 目标/ 核/ ./ no/ _/ threads/ 用来/ 存储/ 需要/ 迁移/ 的/ 线程/ 数目/ ./ perf/ 是/ CPU/ 核上/ 表示/ 核/ 的/ 性能/ 的/ 字/ 段/ ./ is/ _/ faster/ 是/ 用来/ 比较/ CPU/ 核/ 性能/ 的/ 函数/ ,/ 如果/ 第/ 1/ 个/ 参数/ 对应/ 的/ 核比/ 第/ 2/ 个/ 快/ ,/ 则/ 返回/ 真/ ./ 1/ ./ 找出/ 当前/ 系统/ 负载/ 最大/ 的/ 核/ ,/ 用/ c/ 表示/ 该核/ 2/ ./ if/ (/ c/ -/ >/ load/ -/ ccur/ -/ >/ load/ </ =/ 1/ )/ then3/ ./ return4/ ./ endif5/ ./ no/ _/ threads/ =/ c/ -/ >/ nthreds/ +/ ccur/ -/ >/ nthreads6/ ./ no/ _/ threads/ =/ no/ _/ threads/ // (/ 1/ +/ c/ -/ >/ perf/ // ccur/ -/ >/ 7/ ./ no/ _/ threads/ =/ ccur/ -/ >/ nthreads8/ ./ if/ (/ is/ _/ faster/ (/ ccur/ ,/ c/ )/ )/ then9/ ./ 将/ no/ _/ threads/ 个/ 高性能/ 线程/ 从/ c/ 迁移/ 到/ 核/ ccur/ 上/ 10/ ./ else11/ ./ 将/ no/ _/ threads/ 个/ 低/ 性能/ 线程/ 从/ c/ 迁移/ 到/ 核/ ccur/ 上/ 12/ ./ endif/ 例如/ ,/ 一个/ 系统/ 包含/ 两个/ 核/ A/ 和/ B/ (/ 频率/ 分别/ 为/ 1GHz/ 和/ 2GHz/ )/ ,/ 并/ 有/ 6/ 个/ 线程/ 处于/ 可/ 运行/ 状态/ ./ 如果/ A/ 和/ B/ 上/ 都/ 各有/ 3/ 个/ 线程/ ,/ 则/ 该/ 系统/ 负载/ 就/ 处于/ 不/ 均衡/ 状态/ ,/ 因为/ 它们/ 相对/ 负载/ 分别/ 为/ 3/ 和/ 1.5/ (/ A/ 与/ B/ 的/ 相对/ 负载/ 超出/ 1/ )/ ;/ 而/ 当/ A/ 上/ 有/ 2/ 个/ 线程/ ,/ 且/ B/ 上/ 有/ 4/ 个/ 线程/ 时/ ,/ 该/ 系统/ 负载/ 处于/ 平衡/ 状态/ ,/ 因为/ 此时/ A/ 与/ B/ 的/ 相对/ 负载/ 相同/ ./ 算法/ 2/ 给出/ 了/ AS4AMS/ 的/ 负载/ 均衡/ 算法/ ./ 首先/ ,/ 找出/ 当前/ 负载/ 最大/ 的/ 核/ ,/ 并/ 比较/ 该核/ 与/ 当前/ 核/ 的/ 相对/ 负载/ 是否/ 超过/ 1/ ./ 如果/ 小于/ 1/ ,/ 则/ 无需/ 均衡/ ,/ 算法/ 退出/ ./ 否则/ 根据/ 当前/ 核/ 是否/ 比/ 目标/ 核/ c/ 快/ 还是/ 慢/ ,/ 决定/ 将/ 目标/ 核上/ no/ _/ threads/ 个/ 性能/ 最高/ 的/ 还是/ 最低/ 的/ 线程/ 迁移/ 到/ 当前/ 核上/ ./ 其中/ ,/ no/ _/ threads/ 的/ 计算/ 过程/ 如下/ :/ 1/ ./ 计算/ 出/ 两个/ 核上/ 的/ 总线/ 程数/ (/ 算法/ 2/ 第/ 5/ 行/ )/ ./ 2/ ./ 计算/ 出/ 当前/ 核/ 应该/ 分配/ 的/ 线程/ 数/ ,/ 也/ 就是/ 总/ 的/ 线程/ 数/ 除以/ 核/ 数目/ ./ 注意/ ,/ 这里/ 核/ 的/ 数目/ 是/ 以/ 当前/ 核为/ 单位/ 的/ ,/ 所以/ 是/ 1/ +/ c/ -/ >/ perf/ // ccur/ -/ >/ perf/ (/ 算法/ 2/ 第/ 6/ 行/ )/ ./ 迁移/ 的/ 线程/ 数/ (/ 算法/ 2/ 第/ 7/ 行/ )/ ./ 3/ ./ 应/ 分配/ 的/ 线程/ 数/ 减去/ 已有/ 的/ 线程/ 数/ 得到/ 实际/ 需要/ 最后/ ,/ 需要/ 说明/ 的/ 是/ 在/ 本项/ 研究/ 中/ ,/ 我们/ 总是/ 假定/ 任务/ 迁移/ 到/ 各个/ 核/ 的/ 代价/ 相同/ ,/ 这/ 可能/ 让/ 算法/ 在/ 多/ CPU/ 和/ 多/ 节点/ 系统/ 中/ 有些/ 限制/ ./ 但/ 相信/ 随着/ 单/ CPU/ 中/ 集成/ 的/ 核/ 数目/ 越来越/ 多/ ,/ 现在/ 的/ 做法/ 仍然/ 具有/ 重要/ 意义/ ./ 4/ 实验/ 评估/ 4.1/ 实验/ 方法/ 由于/ 现在/ 还/ 没有/ 商用/ 的/ 性能/ 非对称/ 多核/ 平台/ ,/ 我们/ 通过/ 使用/ DVFS/ (/ DynamicVoltage/ // FrequencyScaling/ ,/ 动态/ 电压/ 频率/ 调节/ )/ 技术/ ,/ 修改/ CPU/ 核/ 的/ 频率/ 和/ 禁用/ CPU/ 核/ 构造/ 出/ 一个/ 性能/ 非对称/ 多核/ 平台/ ./ 实验/ 用到/ 的/ 硬件平台/ 是/ HPZ800/ 工作站/ ,/ 配备/ 有/ IntelXeonX55502/ ./ 66GHz4/ 核对/ 称/ 处理器/ ./ 在/ 实验/ 中/ ,/ 我们/ 用到/ 3/ 种/ 配置/ (/ 见表/ 1/ )/ ./ 这/ 3/ 种/ 配置/ 包含/ 不同/ 的/ 核/ 数目/ ,/ 用于/ 评估/ 算法/ 在/ CPU/ 核/ 数目/ 方面/ 的/ 扩展性/ ./ 配置/ 名称/ 配置/ 11/ 个/ 2.66/ GHz/ 核/ ;/ 1/ 个/ 1.6/ GHz/ 核/ 配置/ 21/ 个/ 2.66/ GHz/ 核/ ;/ 1/ 个/ 2.26/ GHz/ 核/ ;/ 1/ 个/ 1.6/ GHz/ 核/ 配置/ 31/ 个/ 2.66/ GHz/ 核/ ;/ 1/ 个/ 2.26/ GHz/ 核/ ;/ 1/ 个/ 1.86/ GHz/ 核/ ;/ 为了/ 使/ 测试/ 尽可能/ 接近/ 真实/ 的/ 工作/ 负载/ ,/ 我们/ 采用/ 国际标准/ SPECCPU2006/ 程序/ 组中/ 的/ 基准/ 测试程序/ 构成/ 测试/ 用/ 的/ 工作/ 负载/ (/ 见表/ 2/ )/ ./ 选取/ 的/ 程序/ 包括/ :/ 单/ 阶段/ 任务/ (/ Single/ -/ Phased/ ,/ SP/ )/ 以及/ 多/ 阶段/ 任务/ (/ Multiple/ -/ Phased/ ,/ MP/ )/ ./ 单/ 阶段/ 任务/ 是/ 指/ 任务/ 特性/ 在/ 运行/ 过程/ 中/ 不/ 发生变化/ 的/ 任务/ ,/ 要么/ 为/ 计算/ 密集型/ 任务/ (/ CPU/ -/ Intensive/ ,/ CI/ )/ ,/ 要么/ 为/ 存储/ 密集型/ 任务/ (/ Memory/ -/ Intensive/ ,/ MI/ )/ ./ 与/ 之/ 相反/ ,/ 多/ 阶段/ 任务/ 是/ 指/ 任务/ 计算/ 特性/ 在/ 计算/ 过程/ 中/ 会/ 发生变化/ ./ 我们/ 对表/ 2/ 中/ 的/ 负载/ 按/ 其/ 负载/ 构成/ 的/ 对应/ 关系/ 进行/ 命名/ ,/ 如/ 3MP/ -/ 1SP/ 表示/ 右侧/ 构成/ 该/ 负载/ 的/ 基准/ 程序/ 中前/ 3/ 个/ 是/ 多/ 阶段/ 任务/ ,/ 最后/ 1/ 个/ 是/ 单/ 阶段/ 任务/ ./ 而/ 4MP/ _/ A/ 和/ 4MP/ _/ B/ 则/ 分别/ 表示/ 两个/ 负载/ 中/ 的/ 4/ 个/ 基准/ 程序/ 都/ 是/ 多/ 阶段/ 任务/ ./ 在/ 表/ 2/ 中/ 的/ 前/ 5/ 个/ 负载/ 为单/ 阶段/ 负载/ ,/ 后/ 5/ 个/ 负载/ 为/ 多/ 阶段/ 负载/ ./ 另外/ ,/ 我们/ 对/ 每个/ 负载/ 中/ 最长/ 的/ 基准/ 程序/ 加粗/ 表示/ (/ 每个/ 负载/ 的/ 完成/ 时间/ 由/ 最长/ 基准/ 程序/ 决定/ )/ ./ 最后/ ,/ 按/ 负载/ 完成/ 时间/ 的/ 升序/ 关系/ 将/ 负载/ 显示/ 在/ 表/ 2/ 当中/ ./ Page6/ 负载/ 名称/ 3MP/ -/ 1SPbwaves/ ,/ leslie3d/ ,/ astar/ ,/ namd3CI/ -/ 1MIcalculix/ ,/ povray/ ,/ hmmer/ ,/ mcf4CI2CI/ -/ 2MInamd/ ,/ sjeng/ ,/ soplex/ ,/ omnetpp4MIGemsFDTD/ ,/ soplex/ ,/ milc/ ,/ omnetpp1MP/ -/ 3SPastar/ ,/ sjeng/ ,/ milc/ ,/ mcf4MP/ _/ Ah264ref/ ,/ libquantum/ ,/ leslie3d/ ,/ astar4MP/ _/ Bh264ref/ ,/ dealII/ ,/ bwaves/ ,/ astar1CI/ -/ 3MIgamess/ ,/ GemsFDTD/ ,/ milc/ ,/ mcf2MP/ -/ 2SPleslie3d/ ,/ astar/ ,/ namd/ ,/ gamess/ 我们/ 在/ Linux2/ ./ 6.21/ 内核/ 上/ 实现/ 和/ 对比/ 了/ AS4AMS/ 调度/ 算法/ 、/ ESHMP/ 调度/ 算法/ 、/ IPC/ -/ Driven/ 调度/ 算法/ 和/ HASS/ 调度/ 算法/ ./ 在/ 实验/ 过程/ 中/ ,/ 对于/ 表/ 2/ 中/ 的/ 每个/ 工作/ 负载/ ,/ 我们/ 运行/ 负载/ 中/ 的/ 所有/ 实例/ 直到/ 运行/ 最长/ 的/ 基准/ 程序/ 实例/ 完成/ 3/ 遍/ 为止/ ./ 除了/ 比较/ 不同/ 特性/ 的/ 任务/ ,/ 我们/ 对/ 同一/ 负载/ 还/ 选取/ 不同/ 的/ 规模/ 测试/ 算法/ 的/ 扩展性/ (/ 1/ 倍/ 实例/ 、/ 2/ 倍/ 实例/ 和/ 3/ 倍/ 实例/ )/ ,/ 即/ 对/ 同一/ 任务/ 同时/ 执行/ 多个/ 实例/ (/ 1/ 个/ 、/ 2/ 个/ 和/ 3/ 个/ )/ ./ 我们/ 记录/ 并/ 比较/ 同一/ 负载/ 在/ 同一/ 系统配置/ 下/ ,/ 分别/ 在/ AS4AMS/ 调度/ 器/ 、/ ESHMP/ 调度/ 器/ 以及/ IPC/ -/ Driven/ 调度/ 器/ 和/ HASS/ 调度/ 器下/ 的/ 平均/ 完成/ 时间/ ./ 通过/ IPC/ -/ Driven/ 下/ 的/ 完成/ 时间/ 减去/ ES/ -/ HMP/ 下/ 的/ 完成/ 时间/ ,/ 再/ 除以/ IPC/ -/ Driven/ 下/ 的/ 完成/ 时间/ 得到/ ESHMP/ 相对/ IPC/ -/ Driven/ 的/ 性能/ 提升/ 程度/ ./ 用/ 相同/ 的/ 方法/ 也/ 可/ 得到/ AS4AM/ 相对/ IPC/ -/ Driv/ -/ en/ 和/ HASS/ 的/ 性能/ 提升/ 程度/ ./ 4.2/ 实验/ 结果/ 4.2/ ./ 1/ 核/ 扩展性/ 分析/ 图/ 2/ 给出/ 了/ 在/ 核/ 数目/ 不同/ 但/ 负载/ 规模/ 相同/ (/ 1/ 倍/ 实例/ )/ 时/ AS4AMS/ 与/ ESHMP/ 相对/ IPC/ -/ Driven/ 的/ 性能/ 提升/ ./ 因为/ ,/ 在/ 调度/ 算法/ 和/ 负载/ 相同/ 的/ 情况/ 下/ ,/ 任务/ 的/ 完成/ 时间/ 完全/ 由/ 硬件/ 配置/ 决定/ ./ 所以/ ,/ 图/ 2/ 中/ 的/ 结果/ 反映/ 了/ 不同/ 核/ 数目/ 对/ 这/ 3/ 个/ 调度/ 算法/ 的/ 影响/ ./ 首先/ ,/ 可以/ 看出/ 在/ 各种/ 核/ 数目/ 的/ 情况/ 下/ ,/ AS4AMS/ 与/ ESHMP/ 相对/ IPC/ -/ Driven/ 都/ 获得/ 了/ 性能/ 提升/ ./ 并且/ ,/ 我们/ 还/ 发现/ 对于/ 同一/ 负载/ ,/ 核心/ 数目/ 越/ 多/ ,/ AS4AMS/ 和/ ESHMP/ 相对/ IPC/ -/ Driven/ 的/ 性能/ 提升/ 程度/ 越大/ ./ 在/ 配置/ 1/ 时/ ,/ AS4AMS/ 和/ ESHMP/ 相对/ IPC/ -/ Driven/ 的/ 性能/ 提升/ 最大/ 分别/ 达到/ 13.9/ %/ 和/ 8.7/ %/ ./ 在/ 配置/ 2/ 时/ ,/ AS4AMS/ 和/ ESHMP/ 相对/ IPC/ -/ Driven/ 的/ 性能/ 提升/ 最大/ 分别/ 达到/ 26.9/ %/ 和/ 20/ %/ ./ 这/ 是因为/ ,/ IPC/ -/ Driven/ 采用/ 加速/ 比/ 作为/ 任务/ 的/ 性能/ 衡量/ 指标/ ,/ 需要/ 在/ 不同/ 核/ 类型/ 上/ 试运行/ ./ 这种/ 试运行/ 导致/ 任务/ 在/ 不同/ 核间/ 的/ 迁移/ ,/ 带来/ 额外/ 的/ 开销/ ./ 而/ AS4AMS/ 和/ ESHMP/ 采用/ 平均/ 停驻/ 时间/ 作为/ 性能/ 衡量/ 指标/ ,/ 只/ 需要/ 在/ 一个/ 核上/ 运行/ 就/ 可以/ 得到/ 任务/ 的/ 计算/ 特性/ ,/ 与/ 配置/ 中/ 的/ 核/ 类型/ 数目/ 无关/ ./ 其次/ ,/ 我们/ 发现/ 在/ 各种/ 核/ 数目/ 的/ 情况/ 下/ ,/ AS4AMS/ 相对/ ESHMP/ 也/ 获得/ 了/ 性能/ 提升/ ./ 而且/ ,/ 对于/ 相同/ 的/ 负载/ ,/ AS4AMS/ 相对/ ESHMP/ 的/ 性能/ 提升/ 也/ 随着/ 核心/ 数目/ 增长/ 而/ 增长/ ./ 如/ 对于/ 负载/ 4MP/ _/ B/ ,/ 在/ 2/ 个/ 核/ 的/ 情况/ 时/ ,/ AS4AMS/ 相对/ ESHMP/ 的/ 性能/ 提升/ 为/ 5.2/ %/ ,/ 但/ 在/ 4/ 个/ 核/ 的/ 情况/ 时/ ,/ AS4AMS/ 相对/ ESHMP/ 的/ 性能/ 提升/ 达到/ 8.6/ %/ ./ 这/ 主要/ 是/ 由于/ ESHMP/ 采用/ 的/ 全局/ 队列/ ,/ 各个/ 核对/ 全局/ 队列/ 的/ 访问/ 方式/ 是/ 串行/ 的/ ,/ 因此/ 核心/ 数目/ 越/ 多/ ,/ 访问/ 任务/ 队列/ Page7/ 的/ 延迟/ 越大/ ./ 而/ AS4AMS/ 采用/ 局部/ 队列/ ,/ 没有/ 任务/ 同步/ 的/ 限制/ 也/ 没有/ 全局/ 队列/ 的/ 瓶颈/ ./ 4.2/ ./ 2/ 任务/ 扩展性/ 分析/ 图/ 3/ 给出/ 了/ 在/ 核/ 数目/ 相同/ (/ 4/ 个/ 核/ )/ 但/ 负载/ 规模/ 不/ 同时/ AS4AMS/ 与/ ESHMP/ 相对/ IPC/ -/ Driven/ 的/ 性能/ 提升/ ./ 从图/ 3/ 中/ 可以/ 看出/ ,/ 在/ 不同/ 负载/ 规模/ 时/ ,/ AS4AMS/ 与/ ESHMP/ 相对/ IPC/ -/ Driven/ 都/ 获得/ 了/ 性能/ 提升/ ./ 而且/ ,/ 在/ 相同/ 配置/ 下/ ,/ 实例/ 数越/ 多/ ,/ AS4AMS/ 与/ ESHMP/ 相对/ IPC/ -/ Driven/ 获得/ 的/ 性能/ 提升/ 越大/ ./ 如/ 在/ 1/ 倍/ 实例/ 时/ ,/ 对于/ 负载/ 4MI/ ,/ AS4AMS/ 与/ ESHMP/ 相对/ IPC/ -/ Driven/ 获得/ 的/ 性能/ 提升/ 分别/ 达到/ 28.6/ %/ 和/ 21.9/ %/ ./ 而/ 在/ 2/ 倍/ 实例/ 时/ ,/ 对于/ 负载/ 4MI/ ,/ AS4AMS/ 与/ ESHMP/ 相对/ IPC/ -/ Driven/ 获得/ 的/ 性能/ 提升/ 则/ 分别/ 达到/ 39.1/ %/ 和/ 24.1/ %/ ./ 与/ 不同/ 配置/ 时/ 的/ 情况/ 类似/ ,/ 这是/ 由于/ IPC/ -/ Driven/ 为了/ 计算/ 任务/ 的/ 计算/ 特性/ 需要/ 在/ 不同/ 核类/ 图/ 3AS4AMS/ 与/ ESHMP/ 在/ 不同/ 负载/ 规模/ 时型/ 上/ 执行/ 造成/ 的/ ./ 实例/ 数越/ 多/ ,/ IPC/ -/ Driven/ 这种/ 获取/ 计算/ 特性/ 方式/ 造成/ 的/ 开销/ 就/ 会/ 越/ 大/ ./ 现在/ 我们/ 来看/ 不同/ 负载/ 规模/ 时/ ,/ AS4AMS/ 相对/ ESHMP/ 的/ 提升/ ./ 当表/ 1/ 中/ 工作/ 负载/ 只有/ 1/ 倍/ 实例/ 时/ ,/ 从图/ 3/ (/ a/ )/ 中/ 可以/ 看出/ ,/ 由于/ 没有/ 任务/ 同步/ 的/ 限制/ 也/ 没有/ 全局/ 队列/ 的/ 瓶颈/ ,/ AS4AMS/ 相对/ ESHMP/ 获得/ 了/ 性能/ 提升/ ./ 正如/ 我们/ 所/ 预计/ 的/ ,/ 负载/ 的/ 执行/ 时间/ 越长/ ,/ 则/ AS4AMS/ 的/ 提升/ 越大/ ./ 最大/ 达到/ 8.9/ %/ (/ 负载/ 1CI/ -/ 3MI/ )/ ,/ 最小/ 也/ 有/ 4.9/ %/ (/ 负载/ 3CI/ -/ 1MI/ )/ ./ 这/ 是因为/ AS4AMS/ 与/ ESHMP/ 都/ 周期性地/ 检测/ 任务/ 的/ 阶段/ 变化/ ,/ 负载/ 的/ 完成/ 时间/ 越长/ 则/ 调度/ 的/ 次数/ 会越/ 多/ ,/ 因而/ AS4AMS/ 相对/ ESHMP/ 的/ 加速/ 也/ 就/ 会/ 累积/ 得/ 越/ 多/ ./ 当/ 系统/ 中/ 每个/ 工作/ 负载/ 有/ 2/ 倍/ 实例/ 时/ (/ 每个/ 核/ 运行/ 2/ 个/ 任务/ )/ ,/ 从图/ 3/ (/ b/ )/ 中/ 可以/ 看出/ ,/ 对于/ 同一/ 负载/ ,/ 运行/ 2/ 倍/ 实例/ 与/ 运行/ 1/ 倍/ 实例/ 相比/ ,/ AS4AMS/ 相对/ ESHMP/ 的/ 提升/ 程度/ 更大/ (/ 相差/ 5.4/ %/ ~/ 9.3/ %/ )/ ./ 原因/ 是/ ESHMP/ 采用/ 全局/ 调度/ ,/ 需要/ 调度/ 的/ 实例/ 越/ 多/ ,/ 则/ 每次/ 调度/ 需要/ 同步/ 比较/ 的/ 任务/ 也/ 就/ 越/ 多/ ,/ 因此/ 开销/ 也/ 会/ 更/ 大/ ./ 同样/ 地/ ,/ 在/ 图/ 3/ (/ c/ )/ 中/ 可以/ 看出/ ,/ AS4AMS/ 在/ 3/ 倍/ 实例/ 时/ 的/ 提升/ 比/ 在/ 2/ 倍/ 实例/ 时/ 的/ 提升/ 大/ (/ 相差/ 4.9/ %/ ~/ 8.9/ %/ )/ ./ 但是/ ,/ 我们/ 发现/ 对于/ 同一/ 负载/ ,/ AS4AMS/ 在/ 3/ 倍/ 实例/ 相对/ 2/ 倍/ 实例/ 的/ 提升/ 比/ 2/ 倍/ 实例/ 相对/ 1/ 倍/ 实例/ 的/ 提升/ 小/ ,/ 如/ 4MI3/ 倍/ 实例/ 相对/ 2/ 倍/ 实例/ 的/ 提升/ 是/ 6.5/ %/ ,/ 而/ 2/ 倍/ 实例/ 相对/ 1/ 倍/ 实例/ 的/ 提升/ 是/ 8.3/ %/ ./ 也就是说/ ,/ AS4AMS/ 对/ ESHMP/ 的/ 加速/ 并/ 不是/ 随/ 实例/ 数/ 增长/ 而/ 线性/ 增长/ 的/ ./ 通过/ 跟踪/ 分析/ 任务/ 的/ 调度/ 发现/ ,/ 这/ 是因为/ AS4AMS/ 采用/ 局部/ 调度/ ,/ 每个/ 任务/ 从/ 进入/ 系统/ 后/ 的/ 初始/ 分配/ 核到/ 最佳/ 分配/ 核/ 还有/ 个/ 自/ 适应/ 过程/ ,/ 并且/ 这个/ 过程/ 也/ 会/ 随着/ 任务/ 数/ 增长/ 而/ 增长/ ./ 不过/ ,/ 与/ ES/ -/ HMP/ 每次/ 全局/ 同步/ 时/ CPU/ 核/ 空闲/ 的/ 性能/ 损耗/ 相比/ ,/ AS4AMS/ 的/ 开销/ 依然/ 小/ 很多/ ,/ 所以/ AS4AMS/ 能/ 提高/ 系统/ 的/ 吞吐量/ ./ 另外/ ,/ 我们/ 还/ 可以/ 看出/ 负载/ 完成/ 时间/ 越长/ AS4AMS/ 加速/ 越大/ 的/ 结论/ 也/ 适用/ 于/ 负载/ 规模/ 为/ 2/ 倍/ 实例/ 和/ 3/ 倍/ 实例/ 的/ 情况/ ./ 可以/ 看出/ ,/ 负载/ 是/ 计算/ 密集型/ 、/ 存储/ 密集型/ 还是/ 多/ 阶段/ 任务/ 对于/ AS4AMS/ 相对/ ESHMP/ 的/ 提升/ 程度/ 没有/ 关系/ ./ 这/ 主要/ 由于/ 这/ 两个/ 算法/ 都/ 采用/ 相同/ 任务/ 特性/ 获取/ 方法/ 和/ 相同/ 的/ 任务/ 特性/ 衡量/ 指标/ ASTPI/ ,/ 所以/ 二者/ 的/ 差别/ 取决于/ 各自/ 调度/ 阶段/ 采用/ 的/ 方法/ ,/ 而/ 各自/ 调度/ 阶段/ 的/ 开销/ 与/ 任务/ 特性/ 都/ 没有/ 关系/ ./ 4.2/ ./ 3/ 迁移/ 和/ 负载/ 均衡/ 开销/ 分析/ 为了/ 衡量/ AS4AMS/ 与/ ESHMP/ 的/ 算法/ 开销/ ,/ Page8/ 我们/ 将/ 这/ 两个/ 算法/ 同/ HASS/ 进行/ 了/ 比较/ ./ HASS/ 采用/ 离线/ 分析/ 的/ 方法/ 获取/ 任务/ 的/ 计算/ 特性/ ,/ 调度/ 时/ 根据/ 离线/ 分析/ 得到/ 的/ 计算/ 特性/ 将/ 各个/ 任务分配/ 到/ 对应/ 的/ 核上/ 执行/ ,/ 并且/ 各个/ 任务/ 在/ 各自/ 分配/ 的/ 核上/ 运行/ 直到/ 结束/ ,/ 不/ 发生/ 迁移/ ./ 因此/ ,/ 相对/ AS4AMS/ 与/ ESHMP/ ,/ HASS/ 没有/ 运行/ 时/ 获取/ 任务/ 计算/ 特性/ 的/ 开销/ 和/ 迁移/ 以及/ 负载平衡/ 的/ 开销/ ./ 所以/ ,/ 同/ HASS/ 进行/ 比较/ 可以/ 很/ 好/ 地/ 评估/ AS4AMS/ 和/ ESHMP/ ./ 图/ 4/ 给出/ 了/ 在/ 4/ 个/ 核/ 和/ 1/ 倍/ 实例/ 时/ AS4AMS/ 与/ ESHMP/ 相对/ HASS/ 的/ 性能/ 提升/ ./ 可以/ 看到/ ,/ 对于/ 前/ 5/ 个单/ 阶段/ 负载/ ,/ ESHMP/ 相对/ HASS/ 的/ 性能/ 不但/ 没有/ 提升/ ,/ 反而/ 出现/ 了/ 下降/ (/ 不/ 超过/ 2/ %/ )/ ./ 然而/ ,/ AS4AMS/ 相对/ HASS/ 的/ 性能/ 提升/ 没有/ 像/ ESHMP/ 那样/ 出现/ 下降/ ,/ 而是/ 达到/ 了/ 4.8/ %/ ~/ 8.3/ %/ 的/ 增长/ ./ 跟踪/ 任务/ 的/ 执行/ 我们/ 发现/ ,/ 单/ 阶段/ 任务/ 的/ 计算/ 特性/ 虽然/ 整体/ 上/ 为/ 计算/ 密集型/ 或/ 存储/ 密集型/ ,/ 但/ 实际上/ 也/ 存在/ 计算/ 特性/ 的/ 变化/ ,/ 只不过/ 变化/ 相对/ 较/ 小/ ./ AS4AMS/ 动态/ 跟踪/ 任务/ 的/ 计算/ 特性/ 变化/ ,/ 只有/ 任务/ 的/ 计算/ 特性/ 变化/ 到/ 一定/ 程度/ 才/ 会/ 重新/ 调整/ 迁移/ ./ 其中/ 跟踪/ 任务/ 的/ 计算/ 特性/ 属于/ 对/ 寄存器/ 的/ 计算/ 操作/ ./ 另外/ ,/ 我们/ 的/ 算法/ 主要/ 针对/ 单/ CPU/ 的/ 多/ 核/ 系统/ ,/ 而/ 现在/ 主流/ 的/ 多/ 核/ CPU/ 的/ 各个/ 核心/ 之间/ 都/ 共享/ 最后/ 一级/ 缓存/ ,/ 核间/ 迁移/ 造成/ 的/ 开销/ 很小/ ./ 因此/ ,/ AS4AMS/ 利用/ 了/ 任务/ 的/ 阶段/ 变化/ 提高/ 了/ CPU/ 利用率/ ,/ 相对/ HASS/ 获得/ 了/ 性能/ 提升/ ./ 但是/ ,/ ESHMP/ 由于/ 全局/ 同步/ 的/ 开销/ 过大而/ 无法/ 充分利用/ 任务/ 的/ 阶段/ 变化/ ,/ 相对/ HASS/ 出现/ 了/ 性能/ 下降/ ./ 而/ HASS/ 采用/ 离线/ 分析/ 得到/ 整个/ 运行/ 阶段/ 的/ 任务/ 特性/ ,/ 没有/ 考虑/ 到/ 任务/ 的/ 计算/ 特性/ 是/ 不断/ 变化/ 的/ ,/ 不能/ 根据/ 任务/ 特性/ 变化/ 作出/ 调整/ 达到/ 充分利用/ CPU/ 的/ 目的/ ./ 对于/ 多/ 阶段/ 任务/ ,/ AS4AMS/ 与/ ESHMP/ 相对/ HASS/ 都/ 获得/ 了/ 性能/ 提升/ ./ 其中/ ,/ ESHMP/ 相对/ HASS/ 提升/ 了/ 4.4/ %/ ~/ 13.9/ %/ ,/ AS4AMS/ 相对/ HASS/ 提升/ 了/ 12.4/ %/ ~/ 22.5/ %/ ./ 与/ 单/ 阶段/ 任务/ 不同/ 的/ 是/ ,/ 多/ 阶段/ 任务/ 的/ 阶段性/ 变化/ 更大/ 、/ 更/ 频繁/ ./ 因此/ ,/ AS4AMS/ 与/ ESHMP/ 都/ 能/ 更好/ 地/ 利用/ 任务/ 的/ 阶段性/ 变化/ ,/ 使/ 任务/ 每个/ 阶段/ 都/ 能/ 分配/ 到/ 最/ 适合/ 的/ 核上/ 执行/ ,/ 更好/ 地/ 利用/ 了/ CPU/ ./ 并且/ ,/ 动态/ 调整/ 任务/ 得到/ 的/ 性能/ 提升/ 相对/ 调度/ 开销/ 要/ 小/ ,/ 所以/ AS4AMS/ 与/ ESHMP/ 都/ 获得/ 了/ 提升/ ./ 5/ 结束语/ 和/ 下/ 一步/ 工作/ 性能/ 非对称/ 多核/ 体系结构/ 由于/ 其/ 相对/ 对称/ 多核/ 体系结构/ 具有/ 更好/ 的/ 能效/ 比/ ,/ 受到/ 越来越/ 多/ 的/ 关注/ ./ 但是/ ,/ 性能/ 非对称/ 多核/ 体系结构/ 的/ 这种/ 高/ 能效/ 比/ 优势/ 只有/ 通过/ 合理/ 的/ 任务调度/ 才能/ 实现/ ./ 本文/ 提出/ 一个/ 自/ 适应/ 的/ 性能/ 非对称/ 调度/ 算法/ AS4AMS/ ./ AS4AMS/ 调度/ 算法/ 在/ 任务/ 计算/ 特性/ 分析阶段/ 使用/ 平均/ 停驻/ 时间/ (/ ASTPI/ )/ 作为/ 性能指标/ ,/ ASTPI/ 与/ 其它/ 性能指标/ 相比/ 需要/ 的/ 计算/ 开销/ 更/ 小/ 也/ 更/ 准确/ ;/ 在/ 任务调度/ 阶段/ 使用/ 局部/ 队列/ 利用/ 局部/ 信息/ 进行/ 调度/ ,/ 避免/ 了/ 全局/ 调度/ 要求/ 任务/ 同步/ 的/ 瓶颈/ ,/ 也/ 没有/ 要求/ 任务/ 同时/ 到达/ 的/ 假设/ ./ 因此/ ,/ AS4AMS/ 具有/ 更好/ 的/ 扩展性/ ,/ 不仅/ 能/ 适应/ 核/ 数目/ 的/ 增长/ ,/ 而且/ 能/ 更好/ 地/ 适应/ 负载/ 规模/ 的/ 增长/ (/ 包括/ 任务/ 数量/ 的/ 增长/ 和/ 任务/ 完成/ 时间/ 的/ 增长/ )/ ./ 在/ 本项/ 研究/ 中/ ,/ 我们/ 并/ 没有/ 考虑/ 负载/ 均衡/ 时/ 任务/ 迁移/ 到/ 不同/ 核/ 的/ 代价/ 差异/ ./ 下/ 一步/ 工作/ 中/ ,/ 我们/ 将会/ 对/ 这/ 一/ 问题/ 进行/ 研究/ ,/ 让/ 我们/ 的/ 调度/ 算法/ 适应/ 更/ 多/ 的/ 体系结构/ ./ 

