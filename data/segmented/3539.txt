Page1/ 基于/ FPGA/ 的/ 高精度/ 科学计算/ 加速器/ 研究/ 雷元/ 武窦勇/ 郭松/ (/ 国防科学技术大学/ 计算机/ 学院/ 长沙/ 410073/ )/ 摘要/ 探索/ 了/ FPGA/ 平台/ 加速/ 高精度/ 科学计算/ 应用/ 的/ 能力/ 和/ 灵活性/ ./ 首先/ ,/ 研究/ 科学计算/ 中/ 最/ 常用/ 的/ 操作/ —/ —/ —/ 向量/ 内积/ ,/ 提出/ 基于/ 定点/ 操作/ 的/ 精确/ 向量/ 内积/ 算法/ ./ 以/ IEEE754/ -/ 2008/ 标准/ 的/ 四/ 精度/ (/ QuadruplePrecision/ )/ 浮点/ 算术/ 为例/ ,/ 在/ FPGA/ 平台/ 上/ 设计/ 了/ 一个/ 基于/ 全/ 展开/ 方法/ 的/ 全/ 流水/ 四/ 精度/ 浮点/ 乘/ 累加/ 单元/ (/ QPMAC/ )/ :/ 提出/ 两级/ 存储/ 策略/ 精确/ 存储/ 乘/ 累加/ 和/ ;/ 采用/ 保留/ 进位/ 累加/ 策略/ 减少/ 定点/ 加法器/ 位/ 宽/ 、/ 简化/ 进位/ 处理/ 、/ 优化/ 关键/ 路径/ ;/ 引入/ 累加/ 和/ 划分/ 策略/ ,/ 实现/ 流水/ 吞吐/ 率/ ./ 最后/ ,/ 在/ XC5VLX330FPGA/ 芯片/ 上/ 设计/ 一个/ LU/ 分解/ 和/ MGS/ -/ QR/ 分解/ 加速器/ 原型/ 来/ 验证/ QPMAC/ 的/ 性能/ ./ 实验/ 结果表明/ ,/ 与/ 运行/ 在/ Intel/ 四核/ 处理器/ 上/ 的/ 基于/ OpenMP/ 的/ 并行算法/ 相比/ ,/ 集成/ 4/ 个/ QP/ -/ MAC/ 单元/ 的/ 加速器/ 能/ 获得/ 42/ 倍/ 到/ 97/ 倍/ 的/ 性能/ 提升/ ,/ 并且/ 能/ 获得/ 更高/ 结果/ 精度/ 和/ 更/ 低/ 能量消耗/ ./ 关键词/ 四/ 精度/ 浮点/ 算术/ ;/ LU/ 分解/ ;/ MGS/ -/ QR/ 分解/ ;/ FPGA/ ;/ 硬件/ 加速器/ ;/ E/ 量级/ 计算/ 1/ 引言/ 大部分/ 科学计算/ 采用/ 双/ 精度/ 浮点/ 算术/ 实现/ ./ 由于/ 浮点/ 数据/ 是/ 对/ 现实/ 世界/ 中/ 精确/ 数据/ 的/ 近似/ 表示/ ,/ 运算/ 过程/ 中/ 存在/ 舍入/ 误差/ ,/ 这种/ 舍入/ 误差/ 的/ 累积/ 将/ 导致/ 计算结果/ 不/ 精确/ 、/ 不/ 可靠/ 、/ 甚至/ 不/ 正确/ ./ 预测/ 到/ E/ 量级/ (/ ExaScale/ :/ 百万/ 万亿次/ // 秒/ )/ [/ 1/ ]/ 计算/ 时代/ ,/ LU/ 分解/ 的/ 计算结果/ 仅/ 有/ 3/ 位/ 有效/ [/ 2/ ]/ ,/ 这/ 表明/ 双/ 精度/ 浮点/ 算术/ 不能/ 满足/ 未来/ 科学计算/ 的/ 精度/ 要求/ ./ 高精度/ 计算/ 是/ 解决/ 精度/ 问题/ 最/ 直接/ 、/ 有效/ 、/ 可靠/ 的/ 方法/ ,/ 已经/ 广泛应用/ 于/ 各个领域/ ,/ 如/ 天气/ 或/ 气候/ 模拟/ 、/ 超新星/ 模拟/ 、/ 计算/ 几何/ 、/ 数值/ 理论/ 等/ [/ 3/ ]/ ./ 鉴于/ 高精度/ 计算/ 在/ 提高/ 应用/ 结果/ 精度/ 、/ 数值/ 算法/ 稳定性/ 和/ 结果/ 再现/ 性/ 等/ 方面/ 的/ 优势/ ,/ IEEE754/ -/ 2008/ 浮点/ 算术/ 标准/ 中/ 增加/ 了/ 四/ 精度/ (/ QuadruplePrecision/ )/ 浮点/ 格式/ [/ 4/ ]/ 来/ 支持/ 高精度/ 计算/ ./ 目前/ ,/ 四/ 精度/ 浮点/ 算术/ 通常/ 使用/ 软件/ 模拟/ 实现/ ,/ 如/ IntelFortran/ [/ 5/ ]/ 、/ GMP/ 、/ MP/ -/ FR/ [/ 6/ ]/ 、/ QD/ (/ Quad/ -/ Double/ )/ [/ 7/ ]/ 等/ 函数库/ ./ 软件/ 方法/ 的/ 最大/ 缺点/ 是/ 计算/ 性能/ 低/ ,/ 相对/ 于/ 双/ 精度/ 浮点/ 算术/ ,/ 四/ 精度/ 浮点/ 算术/ 的/ 性能/ 降低/ 了/ 一个/ 数量级/ ,/ Linpack/ 测试/ 时间/ 为/ 双/ 精度/ 浮点/ 算术/ 的/ 36/ 倍/ [/ 3/ ,/ 8/ ]/ ./ 有/ 学者/ 设计/ 专用/ 硬件/ 逻辑/ 来/ 支持/ 四/ 精度/ 浮点/ 算术/ ,/ 克服/ 软件/ 方法/ 的/ 性能/ 障碍/ ./ IBMS/ // 390G5/ 处理器/ [/ 9/ ]/ 在/ 硬件/ 上/ 支持/ 四/ 精度/ 浮点/ 基本操作/ ./ Akkas/ 等/ 人/ [/ 10/ ]/ 设计/ 了/ 双模式/ 的/ 四/ 精度/ 加法/ 、/ 乘法/ 和/ 除法/ 单元/ ,/ 支持/ 一个/ 四/ 精度/ 浮点/ 操作/ 或者/ 两个/ 并行/ 双/ 精度/ 浮点/ 操作/ ./ 使用/ 可/ 重构/ 平台/ 加速/ 科学/ 应用/ 已经/ 成为/ 一种/ 主流/ 趋势/ ,/ 在/ 高精度/ 科学/ 应用/ 中/ 具有/ 较/ 高/ 的/ 性能/ 和/ 良好/ 的/ 可扩展性/ [/ 2/ ]/ ./ 可/ 重构/ 计算/ 通过/ 定制/ 逻辑/ 满足/ 应用/ 对/ 计算精度/ 的/ 需求/ ,/ 以/ 达到最佳/ 性能/ ./ 可/ 重构/ 计算/ 的/ 底层/ 技术/ 是/ FPGA/ (/ 现场/ 可编程/ 门阵列/ )/ 技术/ ./ 目前/ ,/ FPGA/ 向/ 更/ 大/ 密度/ 、/ 更/ 高性能/ 和/ 更/ 低功耗/ 发展/ ,/ XilinxVirtex/ -/ 6FPGA/ 具有/ 741K/ 个/ 逻辑/ 单元/ ,/ 37.4/ Mbit/ 嵌入式/ 存储器/ 和/ 2016/ 个/ DSP48E/ 乘法器/ ./ 文献/ [/ 2/ ]/ 在/ FPGA/ 平台/ 上/ 设计/ 了/ Double/ -/ Double/ (/ DD/ )/ 和/ QD/ 类型/ 的/ 科学/ 应用/ 加速器/ ,/ 相对/ 于/ 通用/ CPU/ ,/ 能够/ 取得/ 30/ 倍/ 以上/ 的/ 加速/ 比/ ./ 本文/ 在/ 文献/ [/ 2/ ]/ 的/ 基础/ 上/ ,/ 以/ IEEE754/ -/ 2008/ 标准/ 的/ 四/ 精度/ 浮点/ 算术/ 为例/ ,/ 在/ FPGA/ 平台/ 上/ 设计/ 了/ 一个/ 基于/ 全/ 展开/ 方法/ 的/ 全/ 流水/ 四/ 精度/ 浮点/ 乘/ 累加/ 单元/ (/ QPMAC/ )/ ,/ 采用/ 无/ 误差/ 的/ 定点/ 操作/ 代替/ 浮点/ 操作/ 以/ 获得/ 精确/ 的/ 结果/ ,/ 并/ 提出/ 两级/ 存储/ 策略/ 、/ 保留/ 进位/ 累加/ 策略/ 、/ 累加/ 和/ 划分/ 策略/ ,/ 来/ 提高/ QPMAC/ 性能/ ,/ 实现/ 流水/ 吞吐/ 率/ ./ 最后/ 在/ FPGA/ 芯片/ 上/ 设计/ LU/ 分解/ 和/ MGS/ -/ QR/ (/ ModifiedGram/ -/ SchmidtQR/ )/ 分解/ 加速器/ 原型/ 来/ 验证/ QPMAC/ 的/ 正确性/ 及/ 性能/ ./ 2/ 背景/ 介绍/ 2.1/ 浮点/ 算术/ 一个/ 浮点/ 算术/ 系统/ 可以/ 用/ 四元组/ R/ (/ b/ ,/ r/ ,/ e1/ ,/ e2/ )/ 表示/ ,/ 其中/ b/ 表示/ 基/ (/ 2/ 或/ 10/ )/ ;/ r/ 表示/ 尾数/ 的/ 位数/ ,/ 即/ 精度/ ;/ e1/ 为/ 最小/ 指数/ ,/ e2/ 为/ 最大/ 指数/ ./ 表/ 1/ 列举/ 了/ 部分/ 浮点/ 算术/ 系统/ ./ 格式/ 四/ 精度/ [/ 4/ ]/ R/ {/ 2/ ,/ 113/ ,/ -/ 16382/ ,/ 16383/ }/ 128/ ≈/ 10/ -/ 34DD/ [/ 7/ ]/ ≈/ R/ {/ 2/ ,/ 106/ ,/ -/ 1022/ ,/ 1023/ }/ 128/ ≈/ 10/ -/ 32QD/ [/ 7/ ]/ ≈/ R/ {/ 2/ ,/ 212/ ,/ -/ 1022/ ,/ 1023/ }/ 256/ ≈/ 10/ -/ 64QD/ 函数库/ 采用/ 多个/ 标准/ 的/ 浮点/ 数据/ 和/ 来/ 表示/ 一个/ 高精度/ 数据/ ./ 这类/ 高精度/ 算术/ 充分利用/ 当今/ 处理器/ 提供/ 的/ 高性能/ 浮点/ 处理/ 能力/ ,/ 计算速度/ 较/ 快/ ,/ 但是/ 这种/ 实现/ 方式/ 的/ 精度/ 是/ 确定/ 的/ ,/ 数据/ 的/ 表示/ 范围/ 较/ 小/ ,/ 仅/ 为/ 双/ 精度/ 浮点/ 表示/ 范围/ ./ 2.2/ 浮点/ 算术/ 中/ 的/ 精度/ 损失/ 浮点/ 算术/ 的/ 精度/ 损失/ 来源于/ 截断误差/ 和/ 基本操作/ 的/ 舍入/ 误差/ ./ 截断误差/ 是/ 将/ 精确/ 值/ 转换/ 为/ 确定/ 格式/ 浮点/ 数据/ 时/ 产生/ 的/ 误差/ ./ 基本/ 浮点/ 算术/ 操作/ 中/ ,/ 减法/ 对/ 精度/ 损失/ 影响/ 最大/ ,/ 两个/ 非常/ 相近/ 的/ 数据/ 之间/ 的/ 减法/ 操作/ 存在/ “/ 巨量/ 消失/ ”/ 现象/ [/ 11/ ]/ ,/ 计算结果/ 的/ 相对误差/ 变/ 大/ ,/ 不/ 精确/ 位/ 向前/ 传播/ 多位/ ./ 文献/ [/ 2/ ]/ 以/ LU/ 分解/ 为例/ ,/ 通过/ 大量/ 随机/ 测试/ ,/ 建立/ 精度/ 损失/ 与/ 基本操作/ 数量/ 的/ 关系/ 模型/ ./ LU/ 分解/ 结果/ 的/ 不/ 精确/ 位数/ (/ m/ )/ 是/ 以/ 矩阵/ 规模/ (/ n/ )/ 自然对数/ 的/ 方式/ 增加/ (/ m/ =/ 3.11/ ×/ ln/ (/ n/ )/ -/ 1.499/ )/ ,/ 预测/ 在/ 即将/ 到来/ 的/ E/ 量级/ 计算/ 时代/ ,/ 结果/ 的/ 平均/ 精度/ 仅/ 有/ 3/ 位/ 有效/ (/ 十进制/ )/ ./ 这/ 不能/ 满足/ 科学计算/ 的/ 精度/ 要求/ ,/ 因此/ ,/ 我们/ 必须/ 构建/ 更/ 高精度/ 的/ 算术/ 单元/ ./ 2.3/ 高精度/ 向量/ 内积/ 的/ 相关/ 研究/ 向量/ 内积/ (/ ∑/ n/ 一/ ,/ 也/ 是/ BLAS/ 函数库/ 中/ 的/ 一个/ 基本/ 子程序/ ,/ 几乎/ 在/ 所有/ 科学/ 和/ 工程/ 应用/ 中/ 出现/ ./ 在/ 矩阵/ 类/ 运算/ 、/ Krylov/ 子/ 空间/ 等/ 应用/ 中/ ,/ 对/ 向量/ 内积/ 的/ 计算精度/ 要求/ 较/ 高/ [/ 12/ ]/ ./ 但是/ ,/ 通用/ 处理器/ 没有/ 专用/ 的/ 硬件/ 来/ 实现/ 向量/ 内积/ ,/ 只能/ 通过/ 基本/ 浮点/ 操作/ 模拟/ 实现/ ./ 而基/ Page3/ 本/ 浮点/ 操作/ 的/ 舍入/ 误差/ 可能/ 导致/ 内积/ 结果/ 不/ 精确/ ./ 为了/ 提高/ 计算精度/ ,/ Higham/ [/ 13/ ]/ 引入/ 了/ 重/ 排序/ 方法/ 和/ 补偿/ 累加/ 方法/ ./ 重/ 排序/ 方法/ 首先/ 按/ 升序/ 或/ 降序/ 对/ 累加/ 数据/ 进行/ 排序/ ,/ 然后/ 对/ 有序/ 数组/ 进行/ 累加/ ,/ 这种/ 方法/ 增加/ 排序/ 开销/ ;/ 补偿/ 累加/ 方法/ 记录/ 和/ 累加/ 每次/ 舍入/ 的/ 信息/ ,/ 最后/ 将/ 其/ 补偿/ 到/ 最终/ 结果/ 中/ ,/ 这种/ 方法/ 需要/ 额外/ 开销/ 完成/ 舍入/ 信息/ 的/ 累加/ ./ Rump/ 等/ 人/ [/ 14/ ]/ 提出/ 了/ 精确/ 累加/ 算法/ ,/ 其/ 关键/ 是/ 使用/ 一种/ 无/ 误差/ 划分/ 技术/ ./ 以上/ 方法/ 都/ 是/ 使用/ 软件/ 方法/ 来/ 提高/ 计算精度/ ,/ 不能/ 有效/ 避免/ 累加/ 过程/ 中/ 的/ “/ 巨量/ 消失/ ”/ 现象/ ,/ 而且/ 软件/ 方法/ 的/ 速度/ 较慢/ ./ 还有/ 学者/ 提出/ 高精度/ 向量/ 内积/ 单元/ 的/ 设计/ 方法/ ./ Kulisch/ [/ 15/ ]/ 建议/ 将/ 精确/ 内积/ 单元/ 集成/ 到/ 通用/ 处理器/ 中/ ,/ 作为/ “/ 第/ 5/ 个/ 基本/ 浮点/ 算术/ ”/ ./ He/ 等/ 人/ [/ 16/ ]/ 提出/ 了/ 累加/ 数据/ 分组/ 方法/ ,/ 每组/ 数据/ 移位/ 对齐/ 后/ 再/ 进行/ 定点/ 累加/ ,/ 这种/ 方法/ 在/ 每组/ 计算/ 中/ 需要/ 移位/ 对齐/ 、/ 规格化/ 处理/ ,/ 增加/ 处理/ 开销/ ./ Kulisch/ [/ 17/ ]/ 和/ Knofel/ [/ 18/ ]/ 设计/ 了/ 一个/ 标量/ 内积/ 单元/ (/ SPU/ )/ 协处理器/ 实现/ 32/ 位/ 和/ 64/ 位/ 浮点/ 精确/ 向量/ 内积/ ./ 我们/ 设计/ 了/ DD/ 类型/ 和/ QD/ 类型/ 的/ 高精度/ 乘/ 累加/ 单元/ (/ HPMAC/ )/ [/ 2/ ]/ ./ 从表/ 1/ 可知/ ,/ 相对/ 于/ DD/ 和/ QD/ 类型/ ,/ IEEE754/ -/ 2008/ 标准/ 的/ 四/ 精度/ 浮点/ 格式/ 的/ 数据/ 范围/ 扩大/ 了/ 16/ 倍/ ,/ 这/ 意味着/ QPMAC/ 设计/ 中/ 用于/ 快速/ 进位/ 处理/ 的/ 标志/ 位/ 宽度/ 也/ 需要/ 扩展/ 16/ 倍/ ./ 这/ 将/ 给/ 全/ 流水/ QPMAC/ 设计/ 带来/ 挑战/ —/ —/ —/ 如何/ 快速/ 定位/ 进位/ 终止/ 因子/ (/ CarryTerminateFactor/ )/ 和/ 确定/ 进位/ 传递/ 因子/ (/ CarrySkipFactor/ )/ ./ 本文/ 在/ 文献/ [/ 2/ ]/ 的/ 基础/ 上/ 对/ 基于/ 全/ 展开/ 的/ 全/ 流水/ 高精度/ 乘/ 累加器/ 的/ 设计/ 及/ FPGA/ 加速/ 高精度/ 科学/ 应用/ 的/ 探讨/ 进行/ 完善/ :/ 首先/ ,/ 采用/ 保留/ 进位/ 累加/ 策略/ 来/ 替换/ 快速/ 进位/ 策略/ ,/ 以/ 简化/ 进位/ 处理/ ,/ 支持/ 更大/ 数据/ 范围/ 的/ 浮点/ 格式/ ,/ 并/ 以/ IEEE754/ -/ 2008/ 标准/ 的/ 四/ 精度/ 浮点/ 为例/ 进行/ 验证/ ;/ 其次/ ,/ 增加/ MGS/ -/ QR/ 分解/ 应用/ 来/ 说明/ QPMAC/ 的/ 性能/ 及/ FPGA/ 加速/ 高精度/ 科学/ 应用/ 的/ 能力/ ;/ 最后/ ,/ 使用性能/ 较/ 高/ 的/ 任意/ 精度/ 函数库/ (/ MP/ -/ FR/ )/ 和/ 针对/ Intel/ 处理器/ 进行/ 性能/ 优化/ 的/ IntelFor/ -/ tran/ 函数库/ 来/ 对比/ 基于/ QPMAC/ 单元/ 的/ FPGA/ 加速器/ 的/ 性能/ ./ 为了/ 公平/ 对比/ 多核/ CPU/ 和/ FPGA/ 平台/ 的/ 性能/ ,/ 我们/ 采用/ OpenMP/ 技术/ 对/ LU/ 分解/ 和/ MGS/ -/ QR/ 分解/ 应用/ 进行/ 并行/ 化/ ,/ 充分/ 开发/ 多核/ CPU/ 的/ 性能/ ./ 3/ 高精度/ 浮点/ 乘/ 累加/ 单元/ 的/ FPGA/ 实现/ 高精度/ 浮点/ 乘/ 累加/ 操作/ 首先/ 进行/ 无/ 精度/ 损失/ 的/ 定点/ 乘法/ 和/ 加法/ 得到/ 精确/ 定点/ 乘/ 累加/ 和/ ,/ 然后/ 对/ 其/ 进行/ 规格化/ ./ 该/ 操作/ 仅/ 在/ 规格化/ 过程/ 中/ 进行/ 一次/ 舍入/ 操作/ ,/ 最/ 多/ 引入/ 一位/ 误差/ ./ 3.1/ 精确/ 向量/ 内积/ 算法/ 假定/ sign/ (/ x/ )/ (/ 或/ SX/ )/ ,/ exp/ (/ x/ )/ (/ 或/ EX/ )/ 和/ mant/ (/ x/ )/ (/ 或/ MX/ )/ 分别/ 表示/ 浮点/ 数据/ x/ 的/ 符号/ 、/ 指数/ 和/ 尾数/ ;/ 犃/ =/ (/ Ai/ )/ 和/ 犅/ =/ (/ Bi/ )/ (/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ )/ 表示/ 两个/ 长度/ 为/ n/ 的/ 向量/ ,/ 其中/ x/ ,/ Ai/ ,/ Bi/ ∈/ (/ 2/ ,/ r/ ,/ e1/ ,/ e2/ )/ ./ 向量/ 内积/ 为/ 狊/ =/ ∑/ n/ 度为/ 2r/ 位/ ,/ 指数/ 范围/ 为/ [/ 2e1/ ,/ 2e2/ ]/ ,/ 即/ P/ ∈/ (/ 2/ ,/ 2r/ ,/ 2e1/ ,/ 2e2/ )/ ./ 因此/ ,/ 乘积/ P/ 所有/ 位/ 的/ 信息/ 可以/ 无/ 损失/ 地/ 存储/ 到/ 一个/ 长度/ 为/ L/ =/ |/ 2e1/ |/ +/ 2r/ +/ 2e2/ 的/ 寄存器/ 中/ ./ 图/ 1/ 描述/ 了/ 精确/ 向量/ 内积/ 算法/ ./ 首先/ ,/ 读取/ 浮点/ 数据/ Ai/ 和/ Bi/ ,/ 并/ 将/ 其/ 分解/ 为/ 符号/ 位/ 、/ 指数/ 位/ 、/ 尾数/ 位/ ;/ 然后/ ,/ 执行/ 定点/ 尾数/ 乘法/ 得到/ 宽度/ M/ =/ 2r/ 的/ 乘积/ product/ ;/ 再/ 将/ product/ 累加/ 到/ 寄存器/ sum/ 中/ ;/ 最后/ ,/ 规格化/ L/ 位/ 的/ 累加/ 和/ sum/ 为/ 标准/ 格式/ 数据/ ./ Algorithm/ :/ ExactDotProductInput/ :/ Ai/ ,/ Bi/ (/ i/ =/ 1/ ,/ …/ ,/ n/ )/ Output/ :/ ResultInitialize/ :/ sum/ [/ L/ :/ 1/ ]/ =/ 0/ ;/ 1/ ./ fori/ =/ 1tondo2/ ./ Load/ (/ Ai/ ,/ Bi/ )/ ;/ 3/ ./ s/ =/ sign/ (/ Ai/ )/ / sign/ (/ Bi/ )/ ;/ exp/ =/ exp/ (/ Ai/ )/ +/ exp/ (/ Bi/ )/ ;/ 4/ ./ new/ _/ sum/ [/ 2exp/ -/ 1/ :/ 1/ ]/ =/ sum/ [/ 2exp/ -/ 1/ :/ 1/ ]/ ;/ 5/ ./ if/ (/ s/ =/ =/ 0/ )/ then6/ ./ {/ carry/ ,/ new/ _/ sum/ [/ 2exp/ +/ M/ -/ 1/ :/ 2exp/ ]/ }/ =/ sum/ [/ 2exp/ +/ M/ -/ 1/ :/ 7/ ./ new/ _/ sum/ [/ L/ :/ 2exp/ +/ M/ ]/ =/ sum/ [/ L/ :/ 2exp/ +/ M/ ]/ +/ carry/ ;/ 8/ ./ else9/ ./ {/ carry/ ,/ new/ _/ sum/ [/ 2exp/ +/ M/ -/ 1/ :/ 2exp/ ]/ }/ =/ sum/ [/ 2exp/ +/ M/ -/ 1/ :/ 10/ ./ new/ _/ sum/ [/ L/ :/ 2exp/ +/ M/ ]/ =/ sum/ [/ L/ :/ 2exp/ +/ M/ ]/ -/ carry/ ;/ 11/ ./ endif12/ ./ sum/ [/ L/ :/ 1/ ]/ =/ new/ _/ sum/ [/ L/ :/ 1/ ]/ ;/ 13/ ./ endfor14/ ./ Result/ =/ normalize/ (/ sum/ [/ L/ :/ 1/ ]/ )/ 算法/ 的/ 步/ 4/ ~/ 11/ 将/ 尾数/ 乘积/ product/ 累加/ 到/ L/ 位/ 累加/ 和/ sum/ 中/ ,/ 通常/ ,/ 需要/ 一个/ L/ 位/ 的/ 定点/ 加法器/ ,/ 这会/ 造成/ 较大/ 的/ 延时/ ./ 然而/ ,/ 我们/ 可以/ 根据/ 乘积/ 指数/ exp/ ,/ 将/ sum/ 分为/ 3/ 个/ 部分/ ,/ 定点/ 累加/ 过程/ 只/ 需/ 一个/ M/ 位/ 加法器/ ./ 累加/ 和/ sum/ 的/ 小数点/ 位于/ |/ 2e1/ |/ +/ 2r/ ,/ product/ 对应/ 于/ sum/ 的/ 2exp/ 到/ 2exp/ +/ M/ -/ 1/ 的/ 位置/ ./ 累加/ 和/ sum/ 低位/ 部分/ 保持/ 不变/ (/ 算法/ 的/ 第/ 4/ 行/ )/ ./ 仅/ 需要/ 一个/ M/ 位/ 的/ 定点/ 加法/ 完成/ product/ 对应/ 位置/ 的/ 累加/ (/ 算法/ 的/ 第/ 6/ 行/ 或/ 第/ 9/ 行/ )/ ./ 高位/ 部分/ 的/ 操作/ 取决于/ M/ 位/ 加法/ 的/ 进位/ 信息/ (/ 算法/ 的/ 第/ 7/ 行/ 或/ 第/ 10/ 行/ )/ ./ Page43/ ./ 2/ 四/ 精度/ 浮点/ 乘/ 累加/ 单元/ 设计/ 如图/ 2/ 左边/ 所示/ ,/ 四/ 精度/ 浮点/ 乘/ 累加/ 单元/ (/ QP/ -/ MAC/ )/ 主要/ 由/ 113/ ×/ 113/ 定点/ 尾数/ 乘法器/ ,/ 尾数/ 乘积/ 累加/ 模块/ 和/ 规格化/ 模块/ 组成/ ./ 图/ 2QPMAC/ 结构/ 框图/ 3.2/ ./ 1/ 两级/ 存储/ 策略/ L/ 位/ 定点/ 累加/ 和/ 寄存器/ 组织/ 成/ 一个/ 两级/ 存储/ 结构/ ./ 如图/ 2/ 所示/ ,/ 第/ 1/ 级/ 称为/ 存储体/ (/ SumMem/ 或/ Bank/ )/ ,/ 第/ 2/ 级/ 称为/ 子/ 存储体/ (/ Sub/ -/ bank/ )/ ./ 两级/ 存储体/ 的/ 容量/ 为/ L/ =/ |/ 2e1/ |/ +/ 2r/ +/ 2e2/ =/ 65756/ 位/ ./ 将/ L/ 位/ 存储体/ 组织/ 成/ 一个/ 多子/ 存储体/ 的/ 结构/ ,/ 这能/ 提供/ 多个/ 端口/ ,/ 快速访问/ 与/ 尾数/ 乘积/ product/ 对齐/ 的/ 数据/ ./ 我们/ 为子/ 存储体/ 中/ 每个/ 项/ 设置/ 一个/ 全/ 0/ 标志/ 位/ (/ ZF/ 或/ Zero/ _/ Flag/ )/ 和/ 一个/ 进位/ 标志/ 位/ (/ CF/ 或/ Carry/ _/ Flag/ )/ ./ 当/ 该项/ 的/ 值/ 不/ 为/ 0/ 时/ ,/ 置/ ZF/ 为/ 1/ ,/ 否则/ 置/ 为/ 0/ ./ 全/ 0/ 标志/ 位/ 的/ 作用/ :/ (/ 1/ )/ 初始化/ 存储体/ ,/ 即/ 在/ 累加/ 操作前/ ,/ 设置/ 存储体/ 中/ 对应/ 的/ ZF/ 为/ 0/ ,/ 而/ 不/ 需要/ 对/ 存储体/ 进行/ 初始化/ ;/ (/ 2/ )/ 规格化/ 时/ 快速/ 确定/ L/ 位/ sum/ 中首/ 1/ 位置/ ./ 通过/ ZF/ 可以/ 快速/ 定位/ 首个/ 非全/ 0/ 的/ 字/ ,/ 这样/ 将/ L/ 位/ 的/ 首/ 1/ 查找/ 转换/ 为/ B/ 位/ (/ 子/ 存储体/ 的/ 端口/ 宽度/ )/ 的/ 首/ 1/ 查找/ ./ 进位/ 标志/ 位/ 将/ 在/ 下面/ 进行/ 介绍/ ./ 我们/ 根据/ B/ 来/ 组织/ 两级/ 存储/ 结构/ ./ 通过/ 选择/ 合适/ 的/ 端口/ 宽度/ 以/ 均衡/ 加法/ 长度/ 、/ 选择器/ 数量/ 、/ 标志/ 位/ 的/ 长度/ 等/ 硬件/ 开销/ ./ 设/ :/ B/ 为子/ 存储体/ 的/ 端口/ 宽度/ ,/ 为/ 2/ 的/ 幂/ ;/ M/ 为/ 定点/ 尾数/ 乘积/ product/ 的/ 位/ 宽/ ;/ NS/ 为/ 每个/ 存储体/ 中子/ 存储体/ 的/ 个数/ ,/ 通常/ 为/ 2/ 使用/ XilinxVirtex/ -/ 5/ 系列/ FPGA/ 芯片/ 中/ 的/ DSP48E/ (/ 18/ ×/ 25/ )/ 单元/ 来/ 构建/ 113/ ×/ 113/ 定点/ 尾数/ 乘法/ 模块/ ./ 该/ 模块/ 采用/ 6/ 级/ 流水/ 结构/ ,/ 包括/ 35/ 个/ DSP48E/ 单元/ 和/ 部分/ 积/ 加法/ 树/ ,/ 乘积/ 结果/ 为/ 226/ 位/ ./ 的/ 幂/ ,/ 这/ 样子/ 存储体/ 的/ 访问/ 地址/ 为/ 乘积/ 指数/ exp/ 的/ 低位/ ;/ WC/ 为/ 进位/ 标志/ 位/ 的/ 宽度/ ,/ 后面/ 分析/ 得/ WC/ =/ 3/ ;/ WA/ 为/ 定点/ 加法/ 组中/ 加法器/ 宽度/ ,/ 为/ B/ +/ WC/ ;/ NA/ 为/ 定点/ 加法/ 组中/ WA/ 位/ 加法器/ 的/ 个数/ ;/ NM/ 为/ 两级/ 存储体/ 结构/ 中/ B/ 位/ 选择器/ 的/ 个数/ ;/ LF/ 为/ Zero/ _/ Flag/ 标志/ 位/ 的/ 长度/ ,/ 则/ 有/ :/ NA/ =/ M/ // B/ +/ 1/ ,/ NS/ =/ 2logNA/ (/ NS/ +/ NA/ )/ +/ NA/ ,/ LF/ =/ L/ // B/ ./ 表/ 2/ 可/ 由/ 上述/ 公式/ 推导/ 出来/ ,/ 可以/ 看出/ 情况/ 2/ (/ B/ =/ 128/ )/ 为/ 较优/ 的/ 折中/ 选择/ ,/ 即/ 每个/ 存储体/ 由/ 4/ 个子/ 存储体/ 组成/ ,/ 子/ 存储体/ 的/ 端口/ 宽度/ 为/ 128/ 位/ ,/ 每个/ 周期/ 能够/ 访问/ 4/ 个/ 连续/ 的/ 128/ 位/ 数据/ ./ 情况/ BNSNAWANMLF164866762102821284413136514325643259312573/ ./ 2.2/ 保留/ 进位/ 累加/ 策略/ 本文/ 采用/ 保留/ 进位/ 累加/ 策略/ 实现/ 定点/ 尾数/ 乘积/ 的/ 累加/ (/ 下面/ 简称/ 为/ 乘积/ 累加/ )/ ,/ 每次/ 累加/ 计算/ 选择/ 对应/ 字/ 的/ 进位/ 标志/ 位/ 参与/ 计算/ ,/ 并/ 根据/ 计算结果/ 更新/ 进位/ 标志/ 位/ ./ Page5Algorithm/ :/ ProductAccumulationbasedonCarry/ -/ SaveSchemeInput/ :/ Producti/ ,/ expi/ [/ 15/ :/ 0/ ]/ (/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ )/ Output/ :/ C/ [/ 515/ :/ 0/ ]/ ,/ CF/ [/ 515/ :/ 0/ ]/ ,/ Zero/ _/ Flag/ [/ 515/ :/ 0/ ]/ Initialize/ :/ ZF/ [/ 515/ :/ 0/ ]/ =/ 0/ ;/ 1/ ./ fori/ =/ 1tondo2/ ./ {/ Pi/ [/ 2/ ]/ ,/ Pi/ [/ 1/ ]/ ,/ Pi/ [/ 0/ ]/ }/ =/ Producti/ </ </ expi/ [/ 6/ :/ 0/ ]/ ;/ 3/ ./ Setk/ =/ expi/ [/ 15/ :/ 7/ ]/ ./ LoadC/ [/ k/ ]/ ~/ C/ [/ k/ +/ 3/ ]/ and4/ ./ if/ (/ ZF/ [/ k/ ]/ =/ =/ 0/ )/ then/ {/ CF/ [/ k/ ]/ ,/ C/ [/ k/ ]/ }/ =/ 0/ ;/ 5/ ./ {/ CF/ [/ k/ ]/ ,/ C/ [/ k/ ]/ }/ =/ C/ [/ k/ ]/ +/ Pi/ [/ 0/ ]/ ;/ if/ (/ ZF/ [/ k/ +/ 1/ ]/ =/ =/ 0/ )/ then/ {/ CF/ [/ k/ +/ 1/ ]/ ,/ C/ [/ k/ +/ 1/ ]/ }/ =/ 0/ ;/ if/ (/ ZF/ [/ k/ +/ 2/ ]/ =/ =/ 0/ )/ then/ {/ CF/ [/ k/ +/ 2/ ]/ ,/ C/ [/ k/ +/ 2/ ]/ }/ =/ 0/ ;/ if/ (/ ZF/ [/ k/ +/ 3/ ]/ =/ =/ 0/ )/ then/ {/ CF/ [/ k/ +/ 3/ ]/ ,/ C/ [/ k/ +/ 3/ ]/ }/ =/ 0/ ;/ {/ CF/ [/ k/ +/ 1/ ]/ ,/ C/ [/ k/ +/ 1/ ]/ }/ =/ C/ [/ k/ +/ 1/ ]/ +/ Pi/ [/ 1/ ]/ +/ CF/ [/ k/ ]/ ;/ {/ CF/ [/ k/ +/ 2/ ]/ ,/ C/ [/ k/ +/ 2/ ]/ }/ =/ C/ [/ k/ +/ 2/ ]/ +/ Pi/ [/ 2/ ]/ +/ CF/ [/ k/ +/ 1/ ]/ ;/ {/ CF/ [/ k/ +/ 3/ ]/ ,/ C/ [/ k/ +/ 3/ ]/ }/ =/ {/ CF/ [/ k/ +/ 3/ ]/ ,/ C/ [/ k/ +/ 3/ ]/ }/ +/ CF/ [/ k/ +/ 2/ ]/ ;/ 6/ ./ StoreC/ [/ k/ ]/ ~/ C/ [/ k/ +/ 3/ ]/ andCF/ [/ k/ -/ 1/ ]/ ~/ CF/ [/ k/ +/ 3/ ]/ toSumMem/ ;/ 7/ ./ UpdataZF/ [/ k/ ]/ ~/ ZF/ [/ k/ +/ 3/ ]/ accordingtoC/ [/ k/ ]/ ~/ C/ [/ k/ +/ 3/ ]/ and8/ ./ endfor/ 图/ 3/ 基于/ 进位/ 保留/ 策略/ 的/ 定点/ 尾数/ 乘积/ 的/ 累加/ 算法/ 如图/ 2/ 和/ 如图/ 3/ 所示/ ,/ 基于/ 保留/ 进位/ 策略/ 的/ 乘积/ 累加/ 过程/ 如下/ :/ 步/ 1/ (/ RdC/ )/ :/ 对齐/ sum/ 和/ product/ ,/ 本文/ 采用/ 两级/ 对齐/ 策略/ :/ 步/ 1.1/ ,/ 乘积/ 指数/ 的/ 高/ 9/ 位/ 作为/ sum/ 的/ 访问/ 地址/ (/ 假定/ k/ =/ exp/ [/ 15/ :/ 7/ ]/ )/ ,/ 读出/ 与/ product/ 对齐/ 的/ 连续/ 4/ 个/ 128/ 位/ 的/ 字/ C/ [/ k/ +/ 3/ :/ k/ ]/ 及/ 相应/ 的/ 进位/ 标志/ CF/ [/ k/ +/ 3/ :/ k/ ]/ ,/ 同时/ 根据/ 符号/ 位/ 将/ product/ 转换/ 为/ 补码/ 表示/ ./ 步/ 1.2/ ,/ 然后/ 根据/ 乘积/ 指数/ 的/ 低/ 7/ 位/ 对/ product/ 进行/ 移位/ ,/ 使/ 之/ 与/ C/ [/ k/ +/ 3/ :/ k/ ]/ 对齐/ ,/ 得到/ P/ [/ 2/ :/ 0/ ]/ ;/ 步/ 2/ (/ CalC/ )/ :/ 使用/ 4/ 个/ 128/ 位/ 的/ 定点/ 加法器/ 完成/ 定点/ 尾数/ 乘积/ 的/ 累加/ ,/ 使用/ 1/ 个/ 3/ 位/ 的/ 进位/ 加法/ 完成/ 进位/ 处理/ ,/ 如图/ 2/ 所示/ ./ 步/ 3/ (/ WrC/ )/ :/ 将/ 累加/ 结果/ C/ [/ k/ +/ 3/ :/ k/ ]/ 和/ 更新/ 后/ 的/ 进位/ 标志/ 位/ CF/ [/ k/ +/ 3/ :/ k/ ]/ 写/ 回到/ sum/ 的/ 相应/ 位置/ ./ 步/ 4/ (/ UpF/ )/ :/ 根据/ C/ [/ k/ +/ 3/ :/ k/ ]/ 和/ CF/ [/ k/ +/ 3/ :/ k/ ]/ 更新/ 相应/ 的/ 全/ 0/ 标志/ ./ 定理/ 1/ ./ 采用/ 上述/ 保留/ 进位/ 累加/ 策略/ ,/ 累加/ 次数/ 小于/ 2127/ 次时/ ,/ 每个/ 进位/ 标志/ 的/ 数值/ 不会/ 超过/ 3/ ./ 证明/ ./ 假定/ W/ [/ i/ ]/ =/ {/ CF/ [/ i/ ]/ ,/ C/ [/ i/ ]/ }/ ,/ 采用/ 归纳法/ 证明/ 第/ j/ 次/ 累加/ 后/ ,/ W/ [/ i/ ]/ </ 2129/ +/ 2/ ×/ j/ ,/ 其中/ 0/ / i/ / 515/ ./ (/ 1/ )/ 初始化/ 时/ ,/ W/ [/ i/ ]/ =/ 0/ ,/ 0/ / i/ / 515/ ./ (/ 2/ )/ 第/ j/ +/ 1/ 次/ 累加/ 时/ ,/ 假定/ W/ [/ k/ ]/ 、/ W/ [/ k/ +/ 1/ ]/ 、/ W/ [/ k/ +/ 2/ ]/ 、/ W/ [/ k/ +/ 3/ ]/ 参与/ 累加/ 计算/ ,/ 根据/ 归纳/ 假设/ 有/ :/ W/ [/ k/ ]/ =/ P/ [/ 0/ ]/ +/ C/ [/ k/ ]/ </ 2129/ +/ 2/ ×/ (/ j/ +/ 1/ )/ ;/ W/ [/ k/ +/ 1/ ]/ =/ P/ [/ 1/ ]/ +/ C/ [/ k/ +/ 1/ ]/ +/ CF/ [/ k/ ]/ </ 2129/ +/ W/ [/ k/ +/ 2/ ]/ =/ P/ [/ 2/ ]/ +/ C/ [/ k/ +/ 2/ ]/ +/ CF/ [/ k/ +/ 1/ ]/ </ W/ [/ k/ +/ 3/ ]/ =/ W/ [/ k/ +/ 3/ ]/ +/ CF/ [/ k/ +/ 2/ ]/ </ 2129/ +/ 2/ ×/ 2/ ×/ (/ j/ +/ 1/ )/ ;/ 2129/ +/ 2/ ×/ (/ j/ +/ 1/ )/ ;/ (/ j/ +/ 1/ )/ ./ 其余/ 字/ 和/ 对应/ 的/ 进位/ 标志/ 位/ 保持/ 不变/ ,/ 这/ 可/ 保证/ 第/ j/ +/ 1/ 次/ 累加/ 结果/ 满足/ W/ [/ i/ ]/ </ 2129/ +/ 2/ ×/ (/ j/ +/ 1/ )/ ,/ 0/ / i/ / 515/ ./ 若/ 进位/ 标志/ 数值/ 超过/ 3/ ,/ 则/ 2129/ +/ 2/ ×/ (/ j/ +/ 1/ )/ >/ 3/ ×/ 2128/ ,/ 即/ j/ >/ 2127/ -/ 1/ ./ 因此/ 每个/ 进位/ 标志/ 位仅用/ 三位/ 来/ 表示/ ,/ 高位/ 表示/ 进位/ 符号/ 、/ 低/ 两位/ 表示/ 进位/ 数值/ ./ 位/ 累加/ 策略/ 的/ 优势/ 在于/ :/ 相对/ 于/ 快速/ 进位/ 处理/ 方法/ [/ 2/ ,/ 17/ -/ 18/ ]/ ,/ 这种/ 保留/ 进/ (/ 1/ )/ 将/ 文献/ [/ 2/ ]/ 中/ 的/ 384/ 位/ 加法/ 转化/ 为/ 4/ 个/ 并行执行/ 的/ 三/ 输入/ 128/ 位/ 加法/ ,/ 减少/ 延时/ ./ 同样/ 采用/ 先行/ 进位/ 设计/ 方法/ ,/ 将/ 三/ 输入/ 128/ 位/ 加法/ 分成/ 4/ 段/ ,/ 13/ 个/ 32/ 位/ 的/ 加法/ 操作/ 并发/ 执行/ ,/ 最后/ 根据/ 各段/ 的/ 进位/ 选择/ 最终/ 结果/ ./ 这种/ 设计/ 方法/ 将/ 三/ 输入/ 128/ 位/ 加法/ 延时/ 从/ 6.48/ ns/ 降低/ 到/ 4.35/ ns/ ,/ 且/ 小于/ 384/ 位/ 加法/ 延时/ (/ 6.8/ ns/ )/ [/ 2/ ]/ ./ (/ 2/ )/ 简化/ 进位/ 处理/ 逻辑/ ./ 快速/ 进位/ 方法/ 中/ 传递/ 因子/ 和/ 终止/ 因子/ 处理过程/ :/ 首先/ ,/ 根据/ 乘积/ 指数/ exp/ 对/ all/ _/ one/ _/ flag/ 标志/ 位/ [/ 2/ ]/ 进行/ 左移/ 操作/ ;/ 然后/ ,/ 进行/ 数/ 1/ 操作/ 确定/ 移位/ 后/ 的/ 标志/ 位/ 寄存器/ 中/ 最低/ 的/ 0/ 位/ ,/ 对应/ 的/ 字/ 为/ 终止/ 因子/ ;/ 最后/ ,/ 更新/ 传递/ 因子/ 和/ 终止/ 因子/ ,/ 并/ 进行/ 右移/ 操作/ ,/ 完成/ all/ _/ one/ _/ flag/ 标志/ 位/ 更新/ 操作/ ./ 从/ DD/ 类型/ 扩展/ 到/ 四/ 精度/ 时/ ,/ all/ _/ one/ _/ flag/ 标志/ 位/ 宽度/ 由/ 36/ 位/ 增大/ 到/ 516/ 位/ ,/ 导致/ 快速/ 进位/ 过程/ 中/ 的/ 移位/ 操作/ 和/ 数/ 1/ 操作/ 的/ 延时/ 达到/ 11.0/ ns/ 和/ 10.1/ ns/ ,/ 导致/ HPMAC/ 单元/ 的/ 频率/ 降低/ ./ 保留/ 进位/ 累加/ 策略/ 采用/ 进位/ 标志/ 位/ 替换/ 传递/ 因子/ 、/ 终止/ 因子/ 的/ 确定/ 及/ 进位/ 与/ 终止/ 因子/ 加法/ 逻辑/ ,/ 从而/ 提高/ QPMAC/ 单元/ 的/ 频率/ 和/ 性能/ ./ 3.2/ ./ 3/ 累加/ 和/ 划分/ 策略/ 乘积/ 累加/ 需要/ 进行/ 累加/ 和/ 寄存器/ 访问/ 、/ 定点/ 加法/ 计算/ 、/ 标志/ 位/ 更新/ 等/ 操作/ ./ 整个/ 过程/ 延时/ 较大/ ,/ 需要/ 使用/ 流水线/ 技术/ 来/ 提高/ 运行/ 频率/ ./ 根据/ 保留/ 进位/ 累加/ 策略/ ,/ 将/ 乘积/ 累加/ 模块/ 设计/ 成/ 四级/ 流水线结构/ ,/ 分别/ 为/ RdC/ 、/ CalC/ 、/ WrC/ 和/ UpF/ ./ 同时/ ,/ 本文/ 提出/ 累加/ 和/ 划分/ 策略/ 来/ 实现/ 全/ 流水/ 乘积/ 累加/ 模块/ ,/ 使/ QPMAC/ 获得/ 流水/ 吞吐/ 率/ ./ 该/ 策略/ 将/ 累加/ 和/ sum/ 分为/ 4/ 个/ 部分/ ,/ 分别/ 存储/ 到/ 存储体/ SumMem/ [/ 0/ ]/ ~/ SumMem/ [/ 3/ ]/ 中/ ./ 多/ 存储体/ 流水/ 执行/ 的/ 时空图/ 如图/ 4/ 所示/ ,/ 每个/ 存储体/ 4/ 个/ 周期/ 完成/ 一次/ 乘积/ 累加/ 操作/ ,/ 每个/ 时钟/ 周期/ 各个/ 存储体/ 处于/ 不同/ 流水/ 阶段/ ./ 假如/ product/ 在/ 周期/ j/ 进入/ 乘积/ 累加/ 模块/ ,/ 则/ 将/ 其/ 累加/ 到/ 存储体/ SumMem/ [/ j/ %/ 4/ ]/ 中/ ,/ 其中/ “/ %/ 4/ ”/ 表示/ 模/ 4/ 操作/ ./ 总之/ ,/ 累加/ 和/ 两级/ 存储/ 策略/ 中/ ,/ 第/ 1/ 级/ 由/ 4/ 个存/ Page6/ 储体/ (/ SumMem/ [/ 0/ ~/ 3/ ]/ )/ 组成/ ,/ 这使/ QPMAC/ 单元/ 能够/ 获得/ 流水/ 吞吐/ 率/ ;/ 第/ 2/ 级/ 由/ 4/ 个子/ 存储体/ (/ Sub/ _/ bank/ [/ 0/ ~/ 3/ ]/ )/ 组成/ 一个/ 存储体/ ,/ 这/ 能够/ 提供/ 多个/ 访问/ 端口/ ,/ 每个/ 周期/ 可以/ 访问/ 多个/ 数据/ ,/ 减少/ 数据/ 访问/ 周期/ ./ 3.2/ ./ 4QPMAC/ 实现/ 四/ 精度/ 浮点/ 基本操作/ 四/ 精度/ 浮点/ 加法/ 、/ 乘法/ 及/ 乘加/ 融合/ (/ FMA/ )/ 操作/ 可以/ 视为/ 内积/ 运算/ 的/ 特殊/ 情况/ ./ 浮点/ 加法/ 可/ 视为/ 向量/ 长度/ 为/ 2/ 的/ 内积/ ,/ 且/ 向量/ 犅/ 的/ 元素/ 均/ 为/ 1/ ;/ 浮点/ 乘法/ 可/ 视为/ 向量/ 长度/ 为/ 1/ 的/ 内积/ ;/ FMA/ 操作/ (/ r/ =/ a/ ×/ b/ +/ c/ )/ ,/ 可/ 视为/ 向量/ 长度/ 为/ 2/ 的/ 内积/ ,/ 且/ 向量/ 犃/ =/ {/ a/ ,/ c/ }/ ,/ 向量/ 犅/ =/ {/ b/ ,/ 1/ }/ ./ 4/ 基于/ QPMAC/ 的/ 应用/ 本节/ 以/ DoolittleLU/ 分解/ 和/ MGS/ -/ QR/ 分解/ 应用/ 为/ 例来/ 说明/ QPMAC/ 的/ 性能/ 及/ 高精度/ 科学计算/ FPGA/ 加速器/ 的/ 设计/ 方法/ ./ 加速器/ 结构/ 如图/ 5/ 所示/ ./ 4.1/ 基于/ QPMAC/ 的/ LU/ 分解/ LU/ 分解/ 是/ Linpack/ 测试/ 基准/ 中/ 的/ 核心/ 算法/ ./ 如下/ 所示/ ,/ DoolittleLU/ 分解/ 方法/ [/ 13/ ]/ 由/ 向量/ 内积/ 和/ 除法/ 操作/ 组成/ ,/ 它/ 将/ 非/ 奇异/ 矩阵/ 犃/ 分解/ 为/ 下/ 三角/ 矩阵/ 犔/ 和/ 上/ 三角/ 解/ 矩阵/ 犝/ ,/ 计算/ 复杂度/ 为/ O/ (/ 2n3/ // 3/ )/ ./ fork/ =/ 1tonforj/ =/ ktonendforfori/ =/ k/ +/ 1tonendforendfor/ 图/ 6/ 描述/ 了/ 基于/ QPMAC/ 细粒度/ 流水/ LU/ 分解/ 算法/ ./ 由/ 两个/ 并行算法/ 组成/ ,/ 分别/ 为/ Master/ 算法/ 和/ Slave/ 算法/ ,/ 它们/ 采用/ 基于/ 消息传递/ 接口/ (/ MPI/ )/ 的/ SPMD/ 模式/ 来/ 描述/ ,/ 其中/ ,/ N/ 表示/ 矩阵/ 犃/ 的/ 规模/ ,/ P/ 表示/ 执行/ Slave/ 算法/ 的/ 处理单元/ (/ PE/ )/ 个数/ ./ 如图/ 5/ (/ a/ )/ 所示/ ,/ LU/ 分解/ 加速器/ 主要/ 由/ 接口/ 控制/ 模块/ 、/ 主/ PE/ 和/ 一个/ 计算/ PE/ 阵列/ 组成/ ./ 其中/ ,/ 接口/ 控制/ 模块/ 通过/ PCI/ E通/ 路/ 与/ 主机/ 进行/ 数据/ 和/ 命令/ 交互/ ,/ 同时/ 还/ 控制/ 两个/ DDR2/ 存储/ 条/ 的/ 访问/ ;/ 主/ PE/ 执行/ Master/ 算法/ ,/ 计算/ PE/ 执行/ Slave/ 算法/ ,/ 主/ PE/ 和/ 计算/ PE/ 阵列/ 共同完成/ LU/ 分解/ 的/ 计算/ 任务/ ./ 主/ PE/ 和/ 计算/ PE/ 阵列/ 均/ 运行/ N/ // P/ 次/ ./ 每次/ 运行/ 主/ PE/ 从/ DDR2/ 存储器/ 中/ 读取数据/ ,/ 发送到/ 计算/ PE1/ ,/ 执行/ 发送/ 原语/ 5/ 和/ 6/ ;/ 当/ 所有/ 计算/ PE/ 完成/ 计算/ 后/ ,/ 主/ PE/ 执行/ 写回/ 原语/ 9/ 和/ 10/ ,/ 将/ 犔/ 矩阵/ 的/ P/ 列/ 和/ 犝/ 矩阵/ 的/ P/ 行写/ 回到/ DDR2/ 存储器/ ./ 计算/ PE/ 的/ 结构/ 如图/ 5/ (/ b/ )/ 所示/ ,/ 主要/ 包括/ 两个/ RAM/ 、/ 两个/ FIFO/ 、/ 一个/ QPMAC/ 单元/ 、/ 一个/ 四/ 精度/ 浮点/ 除法/ 模块/ 和/ 控制/ 逻辑/ ./ 两个/ RAM/ (/ RAM/ _/ TL/ 和/ RAM/ _/ TU/ )/ 存储/ 计算结果/ 中/ 犔/ 矩阵/ 的/ 一列/ 和/ 犝/ 矩阵/ 的/ 一行/ ;/ 两个/ FIFO/ (/ FIFO/ _/ L/ 和/ FIFO/ _/ U/ )/ 用于/ 缓冲/ 计算/ PE/ 之间/ 的/ 数据/ ;/ 四/ 精度/ 浮点/ 除法/ 模块/ 采用/ 基/ 4/ -/ SRT/ 除法/ 算法/ [/ 19/ ]/ 实现/ ./ QPMAC/ 单元/ 能够/ 独立/ 计算/ 原语/ Cal/ _/ U/ ,/ 由/ QPMAC/ 和/ 除法/ 模块/ 共同/ 计算/ 原语/ Cal/ _/ L/ ./ 注意/ 到/ :/ 图/ 6/ 算法/ A/ 中原/ 语/ Cal/ _/ L/ (/ Line9/ )/ 执行/ 之前/ ,/ 向量/ 犜/ 犔/ 已经/ 存储/ 在/ RAM/ _/ TL/ 中/ ,/ 因此/ ,/ Cal/ _/ L/ 的/ 计算/ 是/ 由/ 向量/ 犜犇/ 的/ 数据/ 所/ 驱动/ ,/ 接收/ 原语/ (/ Line8/ )/ 、/ Cal/ _/ L/ 原语/ (/ Line9/ )/ 和/ 发送/ 原语/ (/ Line11/ )/ 能够/ 并行执行/ ./ 同理/ ,/ 接收/ 原语/ (/ Line12/ )/ 、/ Cal/ _/ U/ 原语/ (/ Line13/ )/ 和/ 发送/ 原语/ (/ Line15/ )/ 能够/ 并行执行/ ./ 这种/ 计算/ 与/ 数据通信/ 相/ 重叠/ 的/ 方式/ 可以/ 有效/ 掩盖/ 数据/ 传/ Page7/ 递延/ 时/ ,/ 数据/ 以/ 流水/ 方式/ 在/ PE/ 之间/ 传递/ ,/ 这/ 最大/ 限度/ 发挥/ 了/ QPMAC/ 单元/ 的/ 流水/ 吞吐/ 率/ 优势/ ,/ 达到/ 每/ AlgorithmA/ :/ PipelinedLUdecompositionalgorithmMasteralgorithm/ :/ 1/ ./ ifpid/ =/ 0then2/ ./ fork/ =/ 1toNbyP3/ ./ M/ =/ SetLength/ (/ k/ )/ ;/ Setk/ =/ k/ +/ pid/ ;/ 4/ ./ doinparallel5/ ./ Send/ (/ 1/ ,/ A/ [/ k/ :/ N/ ,/ 1/ :/ (/ k/ +/ P/ )/ ]/ )/ ;/ 6/ ./ Send/ (/ 1/ ,/ A/ [/ 1/ :/ (/ k/ +/ P/ )/ ,/ k/ :/ N/ ]/ )/ ;/ 7/ ./ enddo8/ ./ forpid/ =/ 1toP9/ ./ Store/ (/ A/ [/ k/ :/ N/ ,/ (/ k/ -/ 1/ )/ ]/ ,/ pid/ ,/ TL/ [/ k/ :/ N/ ]/ )/ ;/ 10/ ./ Store/ (/ A/ [/ (/ k/ -/ 1/ )/ ,/ (/ k/ -/ 1/ )/ :/ N/ ]/ ,/ pid/ ,/ TU/ [/ (/ k/ -/ 1/ )/ :/ N/ ]/ )/ ;/ 11/ ./ endfor12/ ./ endfor13/ ./ endif/ / Store/ (/ X/ ,/ pid/ ,/ Y/ )/ :/ storeelementsofanarrayYofPEnumberedpidintoX/ / Send/ (/ pid/ ,/ X/ )/ :/ sendelementsofanarrayXtoPEnumberedpid/ ;/ / Rcv/ (/ pid/ ,/ X/ )/ :/ receiveelementsofanarrayXfromPEnumberedpid/ ;/ / 犆/ 犪/ 犾/ _/ 犝/ (/ X/ [/ 1/ :/ n/ -/ 1/ ]/ ,/ Y/ [/ 1/ :/ n/ ]/ ,/ u/ )/ :/ calculateelementsofU/ / 犆/ 犪/ 犾/ _/ 犔/ (/ X/ [/ 1/ :/ n/ -/ 1/ ]/ ,/ Y/ [/ 1/ :/ n/ ]/ ,/ a/ ,/ l/ )/ :/ calculateelementsofLAlgorithmB/ :/ PipelinedMGS/ -/ QRdecompositionalgorithmMasteralgorithm/ :/ 1/ ./ ifpid/ =/ 0then2/ ./ fork/ =/ 1toNbyP3/ ./ M/ =/ Setlength/ (/ k/ )/ ;/ 3/ ./ Send/ (/ 1/ ,/ A/ [/ k/ :/ N/ ,/ 1/ :/ N/ ]/ )/ ;/ 4/ ./ Store/ (/ A/ [/ k/ +/ p/ :/ N/ ,/ 1/ :/ N/ ]/ ,/ P/ ,/ FIFO/ _/ A/ )/ ;/ 5/ ./ forpid/ =/ 1toP6/ ./ Store/ (/ R/ [/ (/ k/ +/ pid/ )/ ,/ (/ k/ +/ pid/ )/ :/ N/ ]/ ,/ pid/ ,/ TR/ [/ (/ k/ +/ pid/ )/ :/ N/ ]/ )/ ;/ 7/ ./ Store/ (/ Q/ [/ (/ k/ +/ pid/ )/ ,/ 1/ :/ N/ ]/ ,/ pid/ ,/ TQ/ [/ 1/ :/ N/ ]/ )/ ;/ 8/ ./ endfor9/ ./ endfor10/ ./ endif/ / 犆/ 犪/ 犾/ _/ 犚/ (/ X/ [/ 1/ :/ n/ ]/ ,/ Y/ [/ 1/ :/ n/ ]/ ,/ u/ )/ :/ executethedotproductuofvector/ 犡/ and/ 犢/ / Cal/ _/ Q/ (/ X/ [/ 1/ :/ n/ ]/ ,/ R/ ,/ Y/ [/ 1/ :/ n/ ]/ )/ :/ executetheoperationY/ [/ i/ ]/ =/ X/ [/ i/ ]/ // R/ / Cal/ _/ A/ (/ X/ [/ 1/ :/ n/ ]/ ,/ R/ ,/ Y/ [/ 1/ :/ n/ ]/ )/ :/ executetheoperationX/ [/ i/ ]/ =/ X/ [/ i/ ]/ -/ R/ / Y/ [/ i/ ]/ ,/ wherei/ =/ 1/ ,/ 2/ ,/ …/ ,/ nSlavealgorithm/ :/ 1/ ./ if1/ / pid/ / Pthen2/ ./ while/ (/ TRUE/ )/ 3/ ./ WaitSetLength/ (/ M/ )/ ;/ SetM/ =/ M/ +/ pid/ -/ 1/ ;/ 4/ ./ Rcv/ (/ pid/ -/ 1/ ,/ TL/ [/ 1/ :/ M/ +/ P/ -/ 1/ ]/ )/ ;/ 5/ ./ Rcv/ (/ pid/ -/ 1/ ,/ TU/ [/ 1/ :/ M/ +/ P/ -/ 1/ ]/ )/ ;/ 6/ ./ Cal/ _/ U/ (/ TL/ [/ 1/ :/ M/ -/ 1/ ]/ ,/ TU/ [/ 1/ :/ M/ ]/ ,/ TU/ [/ M/ ]/ )/ 7/ ./ fori/ =/ M/ +/ pidtoN8/ ./ Rcv/ (/ pid/ -/ 1/ ,/ TD/ [/ 1/ :/ M/ +/ P/ -/ 1/ ]/ )/ ;/ 9/ ./ Cal/ _/ L/ (/ TL/ [/ 1/ :/ M/ -/ 1/ ]/ ,/ TD/ [/ 1/ :/ M/ ]/ ,/ TU/ [/ M/ ]/ ,/ TL/ [/ i/ ]/ )/ ;/ 10/ ./ TD/ [/ M/ ]/ =/ TL/ [/ i/ ]/ ;/ 11/ ./ Send/ (/ pid/ +/ 1/ ,/ TD/ [/ 1/ :/ M/ +/ P/ -/ 1/ ]/ )/ ;/ 12/ ./ Rcv/ (/ pid/ -/ 1/ ,/ TD/ [/ 1/ :/ M/ +/ P/ -/ 1/ ]/ )/ ;/ 13/ ./ Cal/ _/ U/ (/ TU/ [/ 1/ :/ M/ -/ 1/ ]/ ,/ TD/ [/ 1/ :/ M/ ]/ ,/ TU/ [/ i/ ]/ )/ ;/ 14/ ./ TD/ [/ M/ ]/ =/ TU/ [/ i/ ]/ ;/ 15/ ./ Send/ (/ pid/ +/ 1/ ,/ TD/ [/ 1/ :/ M/ +/ P/ -/ 1/ ]/ )/ ;/ 16/ ./ endfor17/ ./ endwhile18/ ./ endifSlavealgorithm/ :/ 1/ ./ if1/ / pid/ / Pthen2/ ./ while/ (/ TRUE/ )/ 3/ ./ WaitSetLength/ (/ M/ )/ ;/ 4/ ./ Rcv/ (/ pid/ -/ 1/ ,/ TA/ [/ 1/ :/ N/ ]/ )/ ;/ 5/ ./ Cal/ _/ R/ (/ TA/ [/ 1/ :/ N/ ]/ ,/ TA/ [/ 1/ :/ N/ ]/ ,/ Temp/ _/ R/ )/ ;/ 6/ ./ TR/ [/ M/ +/ pid/ ]/ =/ sqrt/ (/ Temp/ _/ R/ )/ ;/ 7/ ./ Cal/ _/ Q/ (/ TA/ [/ 1/ :/ N/ ]/ ,/ TR/ [/ M/ +/ pid/ ]/ ,/ TQ/ [/ 1/ :/ N/ ]/ )/ ;/ 8/ ./ fori/ =/ M/ +/ pid/ +/ 1toN9/ ./ 10.11/ ./ 12.13/ ./ endfor14/ ./ endwhile15/ ./ endif/ 图/ 6/ 细粒度/ 流水/ LU/ 分解/ 算法/ 和/ MGS/ -/ QR/ 分解/ 算法/ 4.2/ 基于/ QPMAC/ 的/ MGS/ -/ QR/ 分解/ MGS/ -/ QR/ 分解/ 算法/ [/ 13/ ]/ 如下/ 所示/ ,/ 该/ 算法/ 将/ 非/ 奇异/ 矩阵/ 犃/ 分解/ 为/ 正交/ 矩阵/ 犙/ 和/ 上/ 三角/ 矩阵/ 犚/ ,/ 计算/ 复杂度/ 为/ O/ (/ n3/ )/ ./ fork/ =/ 1toNR/ [/ k/ ,/ k/ ]/ =/ sqrt/ (/ ∑/ i/ =/ 1/ …/ NA/ [/ k/ ,/ i/ ]/ ·/ A/ [/ i/ ,/ k/ ]/ )/ ;/ Q/ [/ k/ ,/ / ]/ =/ A/ [/ k/ ,/ / ]/ // R/ [/ k/ ,/ k/ ]/ ;/ forj/ =/ k/ +/ 1toNR/ [/ k/ ,/ j/ ]/ =/ ∑/ i/ =/ 1/ …/ NQ/ [/ k/ ,/ i/ ]/ ·/ A/ [/ i/ ,/ j/ ]/ ;/ A/ [/ j/ ,/ / ]/ =/ A/ [/ j/ ,/ / ]/ -/ R/ [/ k/ ,/ j/ ]/ ·/ Q/ [/ k/ ,/ / ]/ ;/ endfor/ ▲/ / =/ 1/ ,/ 2/ ,/ …/ ,/ Nendfor/ 基于/ QPMAC/ 流水/ MGS/ -/ QR/ 分解/ 算法/ 及/ 加速/ 个/ 周期/ 完成/ 一次/ 四/ 精度/ 乘/ 累加/ 操作/ ./ ParallelDoParallelDoParallelDoParallelDoParallelDoParallelDo/ 器/ 结构/ 与/ LU/ 分解/ 算法/ 相似/ ,/ 如图/ 5/ 、/ 6/ 所示/ ./ Master/ 算法/ 的/ 主要/ 区别/ 是从/ DDR2/ 存储器/ 中/ 读出/ 的/ 数据/ 和/ 传递/ 到/ 计算/ PE/ 中/ 的/ 数据/ 不同/ ./ LU/ 分解/ 中/ ,/ 每个/ 计算/ PE/ 是/ 对/ 原始/ 矩阵/ 的/ 数据/ 进行/ 操作/ ;/ 而/ MGS/ -/ QR/ 分解/ 中/ ,/ 每个/ 计算/ PE/ 需要/ 更新/ 整个/ 矩阵/ ,/ 下/ 一个/ 计算/ PE/ 的/ 数据/ 是/ 当前/ 计算/ PE/ 的/ 更新/ 结果/ ,/ Master/ 算法/ 和/ Slave/ 算法/ 每/ 执行/ 一次/ ,/ 都/ 需要/ 将/ 最后/ 计算/ PE/ 的/ 更新/ 矩阵/ 写/ 回到/ DDR2/ 存储器/ 中/ ./ 如图/ 5/ (/ c/ )/ 所示/ ,/ MGS/ -/ QR/ 分解/ 加速器/ 中/ 的/ 计算/ PE/ 主要/ 由/ 两个/ RAM/ 、/ 一个/ FIFO/ 、/ 一个/ QPMAC/ 单元/ 、/ 一个/ 四/ 精度/ 浮点/ 除法/ 模块/ 和/ 一个/ 四/ 精度/ 浮点/ 开方/ 模块/ ./ RAM/ _/ A/ 用于/ 存储/ 来自/ 上/ 一个/ PE/ 的/ 更新/ Page8/ 数据/ ,/ RAM/ _/ Q/ 用于/ 存储/ 计算结果/ 中/ 犙/ 矩阵/ 的/ 一行/ ;/ FIFO/ _/ A/ 用于/ 缓冲/ 计算/ PE/ 之间/ 的/ 数据/ ;/ 四/ 精度/ 开方/ 模块/ 采用/ Non/ -/ Restoring/ 开方/ 算法/ [/ 20/ ]/ 实现/ ./ 与/ LU/ 分解/ 相似/ ,/ QPMAC/ 单元/ 能够/ 独立/ 计算/ 原语/ Cal/ _/ R/ 和/ Cal/ _/ A/ ,/ 采用/ 数据/ 传递/ 和/ 计算/ 重叠/ 的/ 方法/ 来/ 隐藏/ 通信/ 延时/ ,/ 提高/ QPMAC/ 单元/ 的/ 利用率/ ./ 但/ 与/ LU/ 分解/ 不同/ 的/ 是/ ,/ 图/ 6/ 算法/ B/ 中/ Slave/ 算法/ 的/ 第/ 11/ 、/ 12/ 行/ 必须/ 在/ 第/ 9/ 、/ 10/ 行/ 完成/ 后/ 才能/ 执行/ ,/ 这/ 就/ 使得/ 数据/ 接收/ 、/ 计算/ 和/ 发送/ 不能/ 并行执行/ ./ 只能/ 通过/ 数据/ 接收/ 与/ 计算/ 重叠/ 和/ 数据/ 发送/ 与/ 计算/ 重叠/ 方式/ 来/ 隐藏/ 数据通信/ 延时/ ./ 5/ 实验/ 结果/ 我们/ 在/ FPGA/ 开发板/ 上/ 验证/ 上述/ 设计/ ./ 开发板/ 上/ 包含/ 一块/ FPGA/ 芯片/ 、/ 2/ ×/ 2GBDDR2/ 存储/ 条/ ./ DDR2/ 控表/ 3FPGA/ 资源/ 使用/ 表/ 基本/ 运算/ 部件/ LU/ 分解/ 加速器/ 4PE68957/ (/ 33/ %/ )/ 143087/ (/ 68/ %/ )/ 134/ (/ 46/ %/ )/ 140/ (/ 72/ %/ )/ 160.81021/ ./ 93MGS/ -/ QR2PE39223/ (/ 18/ %/ )/ 75242/ (/ 36/ %/ )/ 76/ (/ 26/ %/ )/ 70/ (/ 36/ %/ )/ 184.26417/ ./ 04/ 分解/ 加速器/ 4PE67808/ (/ 32/ %/ )/ 142635/ (/ 68/ %/ )/ 134/ (/ 46/ %/ )/ 140/ (/ 72/ %/ )/ 160.30819/ ./ 96/ 从表/ 3/ 中/ 可以/ 看出/ ,/ DSP48E/ 资源/ 已经/ 成为/ 四/ 精度/ 科学计算/ 加速器/ 设计/ 的/ 瓶颈/ ./ 因为/ DSP48E/ 用于/ 完成/ 定点/ 尾数/ 乘法/ ,/ 它/ 的/ 需求量/ 是/ 以/ 尾数/ 宽度/ 的/ 平方/ 速度/ 增长/ ./ 在/ QDHPMAC/ (/ 256/ 位/ )/ 中/ DSP48E/ 的/ 消耗/ 达到/ 了/ 50/ %/ [/ 2/ ]/ ./ 在/ 全/ 流水/ QPMAC/ 设计/ 中/ ,/ 使用/ FPGA/ 片内/ 分布式/ RAM/ 实现/ 两级/ 存储体/ 结构/ 中/ 的/ 子/ 存储体/ ./ 这使/ FPGA/ 的/ 布局/ 布线/ 更加/ 灵活/ ,/ 克服/ FPGA/ 片内块/ RAM/ 位置/ 确定/ ,/ 结构/ 固定/ 的/ 不足/ ,/ 同时/ 这/ 也/ 能/ 提高/ FPGA/ 片/ 内存储器/ 资源/ 的/ 利用率/ ./ 但是/ ,/ 分布式/ RAM/ 占用/ FPGA/ 的/ 逻辑/ 资源/ ./ 因此/ ,/ QPMAC/ 中/ SliceLUT/ 消耗/ 达到/ 13/ %/ ./ 由于/ 在/ QPMAC/ 设计/ 中/ 采用/ 保留/ 进位/ 累加/ 策略/ 来/ 克服/ 数据/ 范围/ 扩大/ 带来/ 的/ 挑战/ ,/ 综合/ 频率/ 相对/ 于/ DDHPMAC/ (/ 170.7/ MHz/ )/ [/ 2/ ]/ 提高/ 了/ 12/ %/ ./ LU/ 和/ MGS/ -/ QR/ 分解/ 加速器/ 的/ 综合/ 频率/ 都/ 超过/ 160MHz/ ./ 而且/ ,/ 计算/ 阵列/ 规模/ 的/ 扩大/ 并/ 没有/ 导致/ 加速器/ 频率/ 出现/ 明显/ 下降/ ,/ 这/ 表明/ LU/ 和/ MGS/ -/ QR/ 分解/ 加速器/ 结构/ 具有/ 良好/ 的/ 可/ 扩展/ ./ 对于/ 4PE/ 的/ LU/ 或/ MGS/ -/ QR/ 分解/ 加速器/ 来说/ ,/ FPGA/ 的/ 峰值/ 性能/ 达到/ 制器/ 的/ 运行/ 频率/ 为/ 200MHz/ ,/ 峰值/ 带宽/ 可达/ 6.4/ GB/ // s/ ./ FPGA/ 芯片/ 为/ XilinxVirtex5XC5VLX330/ -/ 1FF1760/ ,/ 它/ 包含/ 207360/ 个/ LUT/ 、/ 192/ 个/ DSP48E/ 、/ 10368Kb/ 片/ 内存储器/ ./ 主机/ 与/ FPGA/ 通过/ PCIEx8/ 通道/ 进行/ 数据/ 和/ 命令/ 的/ 交互/ ,/ 带宽/ 为/ 900MB/ // s/ ./ 我们/ 使用性能/ 较/ 高/ 的/ 任意/ 精度/ 函数库/ MPFR/ 函数库/ [/ 6/ ]/ (/ MPFR3/ ./ 0.0/ ,/ 精度/ 设为/ 113/ 位/ )/ 和/ 针对/ Intel/ 处理器/ 进行/ 性能/ 优化/ 的/ IntelFortran/ 函数库/ (/ 简称/ Intel/ 函数库/ )/ [/ 5/ ]/ ,/ 来/ 对比/ 性能/ 和/ 结果/ 精度/ ./ 软件平台/ 主要/ 包括/ 四核/ 处理器/ (/ 2.33/ GHzIntelCore2QuadQ8200/ )/ 、/ 4GBDDR3/ 存储/ 条/ ./ FPGA/ 平台/ 的/ 运行/ 时间/ 包含/ 从/ 主机/ 向/ 开发板/ 发送/ 初始/ 数据/ 和/ 主机/ 从/ 开发板/ 接收/ 结果/ 数据/ 的/ 时间/ ./ 5.1/ FPGA/ 资源/ LU/ 分解/ 和/ MGS/ -/ QR/ 分解/ 加速器/ 的/ 综合/ 结果/ ./ 表/ 3/ 描述/ 了/ 基本/ 运算/ 部件/ 及/ 不同/ PE/ 个数/ 的/ 01280MFLOPS/ (/ 128/ -/ bitFloating/ -/ pointOperationsPerSecond/ )/ ./ 下面/ 对于/ 向量/ 内积/ 、/ LU/ 及/ MGS/ -/ QR/ 分解/ 应用/ ,/ FPGA/ 平台/ 均/ 运行/ 于/ 133MHz/ ./ 表/ 3/ 中/ 的/ 功耗/ 是/ 通过/ ISE11/ ./ 3/ 中/ 的/ XPowerAnalyzer/ 工具/ 估计/ 得到/ 的/ ,/ 其中/ 20/ %/ ~/ 30/ %/ 的/ 功耗/ 用于/ IObuffer/ ./ 4PE/ 的/ LU/ 分解/ 加速器/ 的/ 功耗/ 为/ 21.93/ W/ ,/ 它/ 仅/ 为/ 4/ 核/ 处理器/ IntelCore2QuadQ8200/ 功耗/ (/ 95W/ )/ 的/ 1/ // 4.5/ ./ 2/ 向量/ 内积/ 应用/ 的/ 精度/ 和/ 性能/ 图/ 7/ 比较/ 了/ FPGA/ 平台/ 和/ 软件平台/ 实现/ 不同/ 长度/ 向量/ 内积/ 运算/ 的/ 精度/ ./ 在/ 文献/ [/ 2/ ]/ 图/ 14/ (/ d/ )/ 中/ 定义/ 的/ 数据/ 集/ Set1/ ~/ Set6/ 上/ 测试/ 内积/ 运算/ ,/ 选取/ 随机/ Page9/ 测试/ 中/ 最坏/ 情况/ 来/ 说明/ ./ 从图/ 7/ 可以/ 看出/ ,/ 软件平台/ 的/ 内积/ 结果/ 精度/ 会/ 随着/ 向量/ 长度/ 的/ 增加/ 而/ 降低/ ./ 而/ QPMAC/ 计算/ 过程/ 中/ 使用/ 精确/ 的/ 定点/ 运算/ ,/ 不会/ 产生/ 误差/ ,/ 因此/ 能够/ 获得/ 精确/ 的/ 结果/ ./ 两种/ 方法/ 的/ 精度/ 差别/ 达到/ 12/ 位/ ./ 图/ 8/ 比较/ 了/ 软件平台/ (/ MPFR/ 、/ Intel/ 函数库/ )/ 和/ FPGA/ 平台/ 实现/ 向量/ 内积/ 的/ 性能/ ./ MPFR/ 和/ Intel/ 函数库/ 的/ 吞吐/ 率/ 分别/ 为/ 6MFLOPS/ 和/ 21MFLOPS/ ,/ 而/ QPMAC/ 单元/ 采用/ 全/ 流水/ 设计/ ,/ 能够/ 取得/ 流水/ 吞吐/ 率/ ,/ 假定/ 初始/ 数据/ 全部/ 存储/ 于/ DDR2/ 存储/ 条上/ ,/ QPMAC/ 单元/ 以/ 133MHz/ 运行/ 能/ 取得/ 266MFLOPS/ 的/ 性能/ ,/ 加速/ 比/ 分别/ 达到/ 45.9/ 和/ 12.8/ ./ 我们/ 通过/ IntelVTune/ 性能/ 分析/ 工具/ 来/ 分析/ CPU/ 和/ FPGA/ 平台/ 的/ 性能/ ./ 如表/ 4/ 所示/ ,/ 任意/ 精度/ 函数库/ MPFR/ 实现/ 1M/ 的/ 向量/ 内积/ 需要/ 1126M/ 条/ 指令/ ,/ 这/ 是因为/ MPFR/ 函数库/ 中/ ,/ 任意/ 精度/ 浮点/ 操作/ 使用/ 整数/ 操作/ 模拟/ 实现/ ,/ 所/ 需/ 的/ 指令/ 数较/ 多/ ,/ 而且/ 还有/ 部分/ 指令/ 用于/ 函数调用/ 等/ ./ Intel/ 函数库/ 是/ 针对/ IEEE/ 标准/ 的/ 四/ 精度/ 浮点/ 算术/ 进行/ 专门/ 设计/ ,/ 相对/ MPFR/ 来说/ ,/ 其/ 指令/ 数/ 可以/ 减少/ 一半/ 以上/ ,/ 而且/ Intel/ 函数库/ 针对/ Intel/ 处理器/ 的/ 特点/ (/ 如/ SSE/ )/ 进行/ 性能/ 优化/ ,/ 其/ CPI/ 更/ 低/ ,/ 因此/ ,/ Intel/ 函数库/ 的/ 性能比/ MPFR/ 高/ 2.6/ 倍/ ./ FPGA/ 平台/ 能够/ 针对/ 不同/ 的/ 计算精度/ 设计/ 相应/ 的/ 逻辑/ 单元/ ,/ 所/ 需/ 指令/ 数较/ 少/ ,/ 而且/ QPMAC/ 单元/ 采用/ 流水/ 设计/ ,/ 因此/ ,/ FPGA/ 平台/ 能够/ 以/ 133MHz/ 的/ 运行/ 频率/ 取得/ 12/ 倍/ 以上/ 的/ 加速/ 比/ ./ 表/ 4/ 不同/ 平台/ 下/ 长度/ 为/ 1M/ 的/ 向量/ 内积/ 的/ 性能/ 分析/ MPFR/ (/ 113bits/ )/ N/ ./ I/ ./ CPIT/ // ms1126M0/ ./ 7344503M0/ ./ 4495.82/ M7/ ./ 512/ 注/ :/ 表中/ :/ N/ ./ I/ ./ 表示/ 指令/ 数/ ,/ CPI/ 表示/ ClockPerInstruction/ ,/ T/ 表示/ 时间/ ,/ S/ 表示/ 相对/ 于/ Intel/ 函数库/ 的/ 加速/ 比/ ./ 5.3/ LU/ 分解/ 应用/ 的/ 精度/ 和/ 性能/ 如表/ 5/ 所示/ ,/ 基于/ QPMAC/ 的/ LU/ 分解/ 的/ 计算精度/ 比/ 相同/ 精度/ 的/ 软件/ 实现/ 更/ 精确/ ./ 这/ 是因为/ 软件/ 实现/ 向量/ 长度/ n/ 的/ 内积/ 时/ ,/ 需要/ 引入/ 2n/ -/ 1/ 次/ 舍入/ 误差/ ,/ 而/ QPMAC/ 单元/ 仅/ 在/ 规格化/ 时才/ 进行/ 一次/ 舍入/ 操作/ ./ 对于/ 规模/ 为/ 4096/ 的/ LU/ 分解/ ,/ 结果/ 精度/ 提高/ 了/ 5.4/ 位/ ./ LUFPGA100/ ./ 198.897/ ./ 595.794/ ./ 1MGS/ -/ FPGA103/ ./ 6102.3100/ ./ 998.897/ ./ 1QRCPU100/ ./ 899.697/ ./ 193.791/ ./ 2/ 图/ 9/ 比较/ 了/ FPGA/ 平台/ 和/ 软件平台/ 上/ 不同/ 规模/ LU/ 分解/ 的/ 性能/ ./ 在/ Intel/ 四核/ 处理器/ 上/ 实现/ 串行/ LU/ 分解/ 算法/ 和/ 基于/ OpenMP/ 的/ 并行/ LU/ 分解/ 算法/ ./ 对于/ MPFR/ 和/ Intel/ 函数库/ ,/ 并行算法/ 的/ 执行/ 速度/ 分别/ 为/ 串行/ 算法/ 的/ 2.8/ 倍/ 和/ 2.65/ 倍/ ./ 从图/ 9/ (/ a/ )/ 可知/ ,/ 对于/ 给定/ 矩阵/ 规模/ ,/ LU/ 分解/ 加速器/ 的/ 吞吐/ 率/ 随着/ PE/ 个数/ 成/ 线性/ 增长/ ,/ 这/ 是因为/ 随着/ PE/ 个数/ 的/ 增加/ ,/ Master/ 和/ Slaver/ 算法/ 的/ 运行/ 次数/ 线性/ 减少/ ,/ 而/ 每次/ 运行/ 的/ 时间/ 开销/ 基本/ 保持/ 不变/ ./ 对于/ 确定/ PE/ 个数/ ,/ LU/ 分解/ 加速器/ 的/ 吞吐/ 率/ 随着/ 矩阵/ 规模/ 的/ 增大/ 略有/ 提高/ ,/ 这/ 是因为/ 计算/ PE/ 阵列/ 的/ 启动/ 和/ 流水/ 排空/ 开销/ 固定/ 不变/ ,/ 而/ 数据/ 以/ 流水/ 方式/ 在/ 计算/ PE/ 之间/ 传递/ ,/ 随着/ 矩阵/ 规模/ 的/ 增大/ ,/ 启动/ 和/ 流水/ 排空/ 开销/ 在/ 总/ 时间/ 的/ 比重/ 减小/ ./ 当/ 矩阵/ 规模/ 为/ 4096/ 时/ ,/ FPGA/ 平台/ 上/ 4PE/ 的/ LU/ 分解/ 加速器/ 的/ 吞吐/ 率/ 接近/ 1000MFLOPS/ ,/ 而/ MPFR/ 和/ Intel/ 函数库/ 的/ 吞吐/ 率/ 分别/ 为/ 10.1/ MFLOPS/ 和/ 22.7/ MFLOPS/ ,/ 加速/ 比/ 可以/ 达到/ 97/ 倍/ 和/ 43/ 倍/ ./ 图/ 9LU/ 分解/ 的/ 性能/ 比较/ ,/ 其中/ 图/ (/ a/ )/ 中/ M/ 、/ I/ 、/ S/ 、/ O/ 分别/ 表示/ MPFR/ 、/ IntelFortran/ 、/ 串行/ 算法/ 、/ 基于/ OpenMP/ 的/ 并行算法/ ,/ 柱状图/ 表示/ 不同/ 实现/ 方式/ 的/ 吞吐/ 率/ ,/ 从/ 左/ 至/ 右/ 依次/ 为/ :/ 串行/ MPER/ 、/ 并行/ MPER/ 、/ 串行/ InterFortran/ 、/ 并行/ InterFortran/ 及/ 集成/ (/ 1PE/ 、/ 2PE/ 、/ 3PE/ 、/ 4PE/ )/ 的/ FPGA/ 加速器/ Page105/ ./ 4MGS/ -/ QR/ 分解/ 应用/ 的/ 精度/ 和/ 性能/ 与/ LU/ 分解/ 应用/ 相似/ ,/ 基于/ QPMAC/ 单元/ 的/ MGS/ -/ QR/ 分解/ 的/ 计算精度/ 比/ 相同/ 精度/ 的/ 软件/ 实现/ 更/ 精确/ ./ 如表/ 5/ 所示/ ,/ 对于/ 矩阵/ 规模/ 为/ 4096/ 的/ MGS/ -/ QR/ 分解/ ,/ 结果/ 精度/ 提高/ 了/ 5.9/ 位/ ./ 图/ 10/ 比较/ 了/ 不同/ 平台/ 不同/ 规模/ MGS/ -/ QR/ 分解/ 的/ 性能/ ./ 在/ Intel/ 四核/ 处理器/ 上/ ,/ 基于/ OpenMP/ 的/ MGS/ -/ QR/ 并行/ 分解/ 算法/ 的/ 执行/ 速度/ 约/ 为/ 串行/ 算法/ 的/ 1.9/ 倍/ 和/ 1.8/ 倍/ ./ 与/ LU/ 分解/ 相似/ ,/ 对于/ 给定/ 矩阵/ 规模/ ,/ MGS/ -/ QR/ 分解/ 加速器/ 的/ 吞吐/ 率/ 随/ PE/ 个数/ 线性/ 增长/ ./ 但是/ 对于/ 确定/ PE/ 个数/ ,/ MGS/ -/ QR/ 分解/ 加速器/ 的/ 吞吐/ 率/ 不再/ 随着/ 矩阵/ 规模/ 增大/ 而/ 提高/ ,/ 这/ 是因为/ MGS/ -/ QR/ 分解/ 算法/ 中/ 矩阵/ 更新过程/ 的/ 数据/ 接收/ 、/ 计算/ 和/ 发送/ 不能/ 同时/ 执行/ ,/ 数据/ 不能/ 以/ 完全/ 流水/ 的/ 方式/ 在/ 计算/ PE/ 阵列/ 中/ 流动/ ,/ 这/ 导致/ 不同/ 矩阵/ 规模/ ,/ 计算/ PE/ 阵列/ 的/ 启动/ 和/ 流水/ 排空/ 开销/ 在/ 总/ 时间/ 的/ 比重/ 保持/ 不变/ ./ 对应/ 矩阵/ 规模/ 为/ 4096/ 的/ MGS/ -/ QR/ 分解/ ,/ 4PEFPGA/ 实现/ 的/ 吞吐/ 率/ 达到/ 918MFLOPS/ ,/ 而/ MPFR/ 和/ Intel/ 函数库/ 的/ 吞吐/ 率/ 分别/ 为/ 12.5/ M/ 和/ 21.7/ MFLOPS/ ,/ 加速/ 比/ 达到/ 73/ 倍/ 和/ 42/ 倍/ ./ 图/ 10MGS/ -/ QR/ 分解/ 的/ 性能/ 比较/ ,/ 子图/ 中/ M/ 、/ I/ 、/ S/ 、/ O/ 的/ 定/ 5.5/ PCI/ -/ E/ 性能/ 分析/ 由于/ 主机/ 与/ FPGA/ 通过/ PCIEx8/ 通道/ 进行/ 数据/ 交互/ ,/ FPGA/ 平台/ 的/ 性能/ 受到/ PCIE/ 带宽/ 的/ 限制/ ./ 在/ 向量/ 内积/ 应用/ 中/ ,/ QPMAC/ 的/ 计算/ 性能/ 为/ 266.6/ MFLOPS/ ,/ 匹配/ 的/ IO/ 带宽/ 为/ 4.3/ GB/ // s/ ,/ 而/ 实际/ 通信/ 带宽/ 仅为/ 900MB/ // s/ ,/ 这/ 导致/ FPGA/ 平台/ 的/ 计算/ 性能/ 下降/ 4.8/ 倍/ ,/ 相对/ 于/ Intel/ 函数库/ 的/ 加速/ 比仅/ 为/ 2.7/ ./ 在/ LU/ 和/ MGS/ -/ QR/ 分解/ 应用/ 中/ ,/ 由于/ 计算/ 复杂度/ 与/ 通信/ 复杂度/ 的/ 比/ 为/ O/ (/ n/ )/ ,/ 通信/ 开销/ 在/ 总/ 时间/ 中/ 的/ 比重/ 是/ 随着/ 矩阵/ 规模/ 增大/ 而/ 减小/ ,/ 如图/ 11/ 所示/ ./ 因此/ ,/ 使用/ FPGA/ 平台/ 加速/ 高精度/ 科学/ 应用/ 时/ ,/ 需要/ 尽量/ 复用/ 数据/ ,/ 提高/ 计算/ 复杂度/ 与/ 通信/ 复杂度/ 的/ 比值/ ,/ 减少/ IO/ 带宽/ 的/ 需求/ ,/ 从而/ 提高/ 加速/ 性能/ ./ 图/ 11LU/ 和/ MGS/ -/ QR/ 分解/ 中/ PCI/ E通/ 信/ 开销/ 相对/ 于/ 4PE6/ 结论/ 本文/ 定制/ 了/ 一个/ 四/ 精度/ 浮点/ 乘/ 累加/ 单元/ (/ QP/ -/ MAC/ )/ ,/ 采用/ 精确/ 定点/ 乘法/ 和/ 加法/ 操作/ 代替/ 浮点/ 操作/ ,/ 仅/ 在/ 最后/ 规格化/ 时/ 进行/ 一次/ 舍入/ 操作/ ./ 这样/ 能够/ 获得/ 精确/ 的/ 向量/ 内积/ 结果/ ,/ 避免/ 减法/ 操作/ 的/ “/ 巨量/ 相消/ ”/ 现象/ ./ 在/ QPMAC/ 设计/ 中/ ,/ 提出/ 两级/ 存储/ 策略/ 来/ 存储/ 累加/ 和/ 的/ 数据/ ,/ 同时/ 引入/ 保留/ 进位/ 累加/ 策略/ 和/ 累加/ 和/ 划分/ 策略/ ,/ 来/ 最小化/ 关键/ 路径/ 长度/ ,/ 简化/ 进位/ 处理/ ,/ 保证/ 流水/ 吞吐/ 率/ ./ 最后/ ,/ 为了/ 验证/ QPMAC/ 性能/ ,/ 在/ XC5VLX330/ 芯片/ 上/ 设计/ 一个/ LU/ 分解/ 和/ MGS/ -/ QR/ 分解/ 加速器/ 原型/ ,/ 集成/ 4/ 个/ QPMAC/ 单元/ ,/ 与/ Intel/ 四核/ 处理器/ 相比/ 获得/ 42/ 到/ 97/ 倍/ 的/ 性能/ 提升/ ./ 

