Page1/ 一种/ 自动/ 推断/ 复杂/ 系统/ 层次结构/ 任务模型/ 的/ 方法/ 高崇南余/ 宏亮/ 郑纬民/ (/ 清华大学/ 计算机系/ 北京/ 100084/ )/ 摘要/ 支撑/ Internet/ 服务/ 的/ 复杂/ 系统/ 难于/ 调试/ 与/ 分析/ ./ 理解/ 系统/ 运行/ 时/ 行为/ 是/ 调试/ 与/ 分析/ 这些/ 复杂/ 系统/ 的/ 关键/ ./ 现有/ 的/ 技术/ 将/ 系统/ 动态/ 运行/ 时/ 行为/ 用/ 因果/ 执行/ 路径/ 抽象/ 描述/ ,/ 并/ 在/ 此基础/ 上/ 分析/ 系统/ 的/ 行为/ ./ 但是/ 这些/ 方法/ 或者/ 需要/ 手动/ 标注/ 系统/ 代码/ ,/ 或者/ 需要/ 使用者/ 描述/ 系统/ 的/ 执行/ 结构/ ,/ 都/ 需要/ 使用者/ 很多/ 人工/ 辅助/ ./ 文中/ 描述/ 了/ 一种/ 自动/ 推断/ 复杂/ 系统/ 层次结构/ 任务模型/ 的/ 方法/ ./ 通过/ 使用/ 插装/ 技术/ 动态/ 观察/ 系统/ 执行/ 过程/ ,/ 文中/ 的/ 方法/ 能够/ 根据/ 一组/ 启发/ 自动/ 推断出/ 系统/ 运行/ 时/ 的/ 任务模型/ ,/ 包括/ 任务/ 的/ 边界/ 和/ 任务/ 之间/ 的/ 因果/ 依赖/ 关系/ ./ 通过/ 使用/ 聚类/ 方法/ ,/ 能够/ 进一步/ 推断出/ 任务模型/ 的/ 层次结构/ ./ 通过/ 在/ 实际/ 系统/ (/ Apache/ 和/ PacificA/ )/ 上/ 应用/ 推断/ 方法/ ,/ 可以/ 看出/ ,/ 使用/ 得到/ 的/ 模型/ 能够/ 帮助/ 理解/ 系统/ 的/ 动态/ 运行/ 过程/ ,/ 并/ 帮助/ 分析/ 解决/ 系统/ 的/ 性能/ 问题/ ./ 关键词/ 任务模型/ ;/ 系统分析/ ;/ 性能/ 调试/ 1/ 引言/ Internet/ 服务/ 越来越/ 影响/ 着/ 人们/ 生产/ 生活/ 的/ 各个方面/ ,/ 它们/ 的/ 可靠性/ 也/ 变/ 的/ 越来越/ 重要/ ./ 系统/ 设计/ 与/ 实现/ 上/ 的/ 缺陷/ 一直/ 伴随/ 着/ 这些/ 服务/ 而生/ ,/ 导致/ 服/ Page2/ 些/ 系统/ 通常/ 使用/ 分层/ 的/ 体系结构/ ,/ 将/ 其/ 功能/ 抽象/ 表达/ 为/ 不同/ 的/ 层次结构/ ./ 其/ 运行/ 时/ 具有/ 高度/ 的/ 并发/ 性/ ./ 系统/ 在/ 运行/ 时/ ,/ 处理/ 着/ 许多/ 用户/ 层次/ 的/ 任务/ ,/ 例如/ 用户/ 请求/ ,/ 任务/ 被/ 分成/ 许多/ 阶段/ 执行/ ,/ 不同/ 的/ 阶段/ 被/ 分布/ 在/ 多个/ 机器/ 、/ 进程/ 和/ 线程/ 上/ 执行/ ,/ 使用/ 事件/ 或者/ 异步/ 消息/ 作为/ 通知/ 机制/ ./ 验证/ 单独/ 每个/ 任务/ 的/ 行为/ ,/ 是/ 一件/ 具有/ 挑战性/ 的/ 问题/ ,/ 因为/ 开发人员/ 需要/ 重构/ 出/ 任务/ 的/ 执行/ 流/ ,/ 将/ 任务/ 执行/ 过程/ 中/ 的/ 各个/ 阶段/ 重新/ 连接起来/ ./ 从/ 概念/ 上/ 说/ ,/ 开发人员/ 可以/ 把/ 任务/ 执行/ 过程/ 用/ 层次结构/ 的/ 任务/ 模型表示/ ,/ 这/ 与/ 系统/ 的/ 分层/ 体系/ 结图/ 1PacificA/ 的/ 层次结构/ 任务模型/ (/ 包含/ 3/ 个/ 高层/ 任务/ ./ 图上/ 的/ 节点/ 表示/ 叶子/ 任务/ ,/ 边/ 表示/ 叶子/ 任务/ 之间/ 的/ 因果/ 依赖/ 关系/ )/ 然而/ ,/ 目前/ 的/ 工具/ 需要/ 开发人员/ 手动/ 标注/ 任务模型/ ./ 例如/ ,/ Pip/ [/ 3/ ]/ 要求/ 开发人员/ 将/ 系统/ 预期/ 行为/ ,/ 用/ “/ 期望/ (/ expectations/ )/ ”/ 的/ 形式/ 表达/ ,/ “/ 期望/ ”/ 表达/ 了/ 系统/ 正确/ 执行/ 时/ 的/ 任务模型/ ,/ 包括/ 任务/ 的/ 执行/ 顺序/ 与/ 对/ 执行/ 时/ 资源/ 使用/ 的/ 约束/ ./ 通过/ 对比/ 期望/ 与/ 实际/ 执行/ 的/ 区别/ ,/ 可以/ 验证/ 系统/ 运行/ 时/ 行为/ ./ 写出/ 一个/ 全面/ 表达/ 系统/ 高层/ 设计/ 与/ 底层/ 实现/ 的/ 期望/ 是/ 非常/ 困难/ 的/ 并/ 容易/ 出错/ ,/ 特别/ 对/ 那些/ 正在/ 快速/ 演变/ 中/ 的/ 系统/ ./ 基于/ 执行/ 路径/ 的/ 工具/ ,/ 例如/ Magpie/ [/ 4/ ]/ ,/ 可以/ 从/ 包含/ 运行/ 时/ 事件/ 的/ trace/ 推断/ 每个/ 请求/ 的/ 执行/ 路径/ ,/ 但是/ 它/ 仅/ 可以/ 处理/ 一组/ 事前/ 确定/ 的/ 事件/ ,/ 并且/ 需要/ 开发人员/ 指定/ 任务/ 的/ 边界/ 与/ 关联/ 条件/ ./ 本文/ 的/ 目的/ 是/ 研究/ 不/ 需要/ 人工/ 帮助/ 、/ 自动/ 推断/ 层次结构/ 任务模型/ 的/ 方法/ ./ 开发人员/ 不/ 需要/ 手动/ 标注/ 源代码/ 来/ 指定/ 任务/ 边界/ ,/ 并且/ 任务/ 的/ 层次结构/ 也/ 应该/ 能够/ 自动/ 推断/ 得到/ ./ 这是/ 完成/ 自动/ 分析/ 与/ 诊断/ 复杂/ 系统/ 目标/ 的/ 必要条件/ ./ 开发人员/ 和/ 系统管理员/ 可以/ 利用/ 得到/ 的/ 任务模型/ ,/ 以/ 可视化/ 的/ 形式/ 表现/ 系统/ 设计/ 和/ 实现/ ,/ 也/ 可以/ 将/ 任务模型/ 作为/ 输入/ ,/ 使用/ 其构/ 设计/ 一致/ ./ 任务模型/ 中/ 的/ 任务/ 表示/ 在/ 系统/ 不同/ 函数/ 抽象层次/ 的/ 执行/ 过程/ ./ 高层/ 任务/ 的/ 执行/ 被/ 分为/ 若干/ 低层/ 子/ 任务/ ./ 以/ PacificA/ [/ 1/ ]/ 为例/ ,/ PacificA/ 是/ 一个/ 类似/ BigTable/ [/ 2/ ]/ 的/ 分布式/ 存储系统/ ./ 图/ 1/ 显示/ 了/ 用户/ 向/ PacificA/ 提交/ 数据/ 任务/ 的/ 执行/ 层次/ ./ 数据/ 提交/ 任务/ 被/ 分为/ 两步/ (/ 图/ 的/ 右边/ )/ ,/ 分别/ 处理/ 本地/ 数据/ 提交/ 和/ 远程/ 数据/ 提交/ ./ 每个/ 任务/ 分别/ 由/ 若干/ 叶子/ 任务/ 构成/ ,/ 叶子/ 任务/ 的/ 边界/ 由/ 同步/ 点/ 确定/ ./ 基于/ 任务模型/ ,/ 开发人员/ 可以/ 更好/ 地/ 理解/ 系统/ 层次/ 模块/ 间/ 的/ 结构/ 以及/ 不同/ 模块/ 间/ 的/ 依赖/ 关系/ ,/ 并/ 验证/ 处于/ 不同/ 层次/ 任务/ 的/ 行为/ ./ 它/ 工具/ 调试/ 或/ 验证/ 系统/ 设计/ ./ 设计/ 一个/ 自动/ 推断/ 任务模型/ 的/ 工具/ 面临/ 如下/ 几个/ 挑战性/ 问题/ ./ 首先/ ,/ 应该/ 能够/ 确认/ 合理/ 的/ 任务/ 边界/ ,/ 这一/ 过程/ 应该/ 只/ 基于/ 对系统/ 执行/ 过程/ 的/ 监视/ ,/ 而/ 不/ 需要/ 开发人员/ 显式/ 地/ 标注/ ./ 其次/ ,/ 必须/ 能够/ 正确/ 地/ 关联/ 任务/ 之间/ 依赖/ 关系/ ./ 特别/ 是/ ,/ 必须/ 能够/ 辨别/ 任务/ 之间/ 因为/ 共享资源/ (/ 例如/ 共享/ 队列/ 、/ 锁/ 等/ )/ 而/ 产生/ 的/ 依赖/ 关系/ ./ 最后/ ,/ 应该/ 能够/ 自动/ 恢复/ 任务/ 的/ 层次结构/ ./ 任务/ 由/ 许多/ 或者/ 顺序/ 或者/ 并行/ 的/ 子/ 任务/ 构成/ ./ 考虑/ 到/ 复杂/ 系统/ 中/ 任务/ 执行/ 的/ 并行性/ 与非/ 确定性/ ,/ 确定/ 它们/ 的/ 依赖/ 关系/ 与/ 层次结构/ 并/ 不/ 容易/ ./ 在/ 本文/ 中/ ,/ 我们/ 描述/ 了/ 如何/ 自动/ 推断/ 复杂/ 系统/ 层次结构/ 任务模型/ 的/ 方法/ ,/ 并/ 实现/ 了/ 一个/ 推断/ 工具/ Scalpel/ ./ 我们/ 通过/ 使用/ 插装/ (/ instrument/ )/ 技术/ 来/ 透明/ 地/ 观测/ 系统/ 运行/ ,/ 获取/ 系统/ 运行/ 过程/ 的/ trace/ ,/ 包括/ 应用层/ 函数/ 和/ 系统/ 同步/ 函数/ 的/ 调用/ (/ 例如/ signal/ // wait/ )/ ./ 推断/ 方法/ 使用/ trace/ 作为/ 输入/ ,/ 自下而上/ 地/ 推断/ 系统/ 层次结构/ 任务模型/ ,/ 推断/ 的/ 过程/ 分为/ 3/ 步/ ,/ 分别/ 对应/ 上面/ 提到/ 的/ 3/ 个/ 挑战性/ 问题/ ./ Page3/ 首先/ ,/ 我们/ 将/ 运行/ 过程/ 分为/ 一个个/ 叶子/ 任务/ ,/ 它们/ 是/ 层次结构/ 任务模型/ 中/ 最/ 基本/ 的/ 任务/ ./ 叶子/ 任务/ 的/ 边界对应/ 执行/ 过程/ 的/ 同步/ 点/ (/ synchronizationpoint/ )/ ./ 在/ 同步/ 点/ ,/ 线程/ 或/ 进程/ 相互/ 同步/ 从而/ 具有/ 因果/ 依赖/ 关系/ ,/ 因此/ 同步/ 点/ 是/ 推断/ 任务/ 边界/ 的/ 一个/ 合理/ 启发/ (/ heuristic/ )/ ./ 其次/ ,/ 我们/ 按照/ 运行/ 时/ 的/ 因果/ 依赖/ 关系/ ,/ 将/ 叶子/ 任务/ 用/ 有/ 向/ 边/ 连接/ ,/ 形成/ 一个/ 因果关系/ 图/ ./ 叶子/ 任务/ 的/ 因果/ 依赖/ 关系/ 由/ 任务/ 运行/ 时/ 的/ happened/ -/ before/ [/ 5/ ]/ 关系/ 推断/ 得到/ ./ 最后/ ,/ 我们/ 在/ 任务/ 关系/ 图上/ ,/ 推断出/ 层次结构/ ./ 每/ 一个/ 层次/ ,/ 大致/ 对应/ 系统/ 设计/ 与/ 实现/ 上/ 的/ 一个/ 层次/ ./ 我们/ 使用/ 聚类/ 算法/ 寻找/ 任务/ 因果关系/ 图上/ 重复/ 出现/ 的/ 模式/ (/ 频繁/ 子图/ )/ ,/ 以此/ 为/ 依据/ 确认/ 高层/ 任务/ 与/ 构成/ 它/ 的/ 子/ 任务/ ./ 通过/ 递归/ 地/ 使用/ 聚类/ 算法/ ,/ 我们/ 能够/ 进一步/ 寻找/ 更/ 高层次/ 的/ 任务/ ./ 我们/ 分别/ 在/ ApacheWeb/ 服务器/ 和/ PacificA/ 上/ 应用/ Scalpel/ ,/ 结果显示/ ,/ Scalpel/ 的/ 推断/ 方法/ 能够/ 得到/ 具有/ 合理/ 意义/ 的/ 任务模型/ ,/ 并且/ 完全/ 不/ 需要/ 开发者/ 的/ 手工/ 标注/ ./ 进一步/ ,/ Scalpel/ 能够/ 帮助/ 开发者/ 解决/ PacificA/ 中/ 的/ 一个/ 性能/ 问题/ ,/ 该/ 问题/ 导致/ PacificA/ 对/ 网络带宽/ 的/ 利用率/ 只有/ 最大值/ 的/ 70/ %/ ./ 本文/ 第/ 2/ 节/ 描述/ 了/ 推断/ 方法/ 设计/ ;/ 第/ 3/ 节/ 叙述/ 了/ 推断/ 方法/ 的/ 实现/ 细节/ ;/ 第/ 4/ 节/ 描述/ 了/ 对/ 推断/ 方法/ 实现/ 的/ 优化/ ;/ 第/ 5/ 节/ 我们/ 描述/ 了/ 在/ 实际/ 系统/ 上/ 应用/ 推断/ 方法/ 的/ 实例/ ;/ 第/ 6/ 节/ 叙述/ 了/ 相关/ 工作/ ;/ 第/ 7/ 节为/ 本文/ 总结/ ./ 2/ 推断/ 方法/ 设计/ 本/ 节/ 给出/ 自动/ 推断/ 系统/ 层次结构/ 任务模型/ 的/ 方法/ 以及/ 它/ 的/ 原型/ 实现/ —/ —/ —/ Scalpel/ ./ 2.1/ 收集/ 系统/ 运行/ trace/ 我们/ 使用/ 插装/ 技术/ 透明/ 地/ 观测/ 系统/ 运行/ ,/ 收集/ 运行/ 过程/ 的/ 函数调用/ trace/ 以及/ 调用/ 参数/ ,/ 包括/ 应用层/ 函数/ 和/ 系统/ 同步/ 函数/ (/ 例如/ signal/ // wait/ )/ 与/ 系统/ Socket/ 调用/ (/ 例如/ send/ // recv/ )/ ./ 默认/ 所有/ 的/ 函数调用/ 都/ 会/ 被/ 收集/ 到/ trace/ ./ 2.2/ 确定/ 叶子/ 任务/ 在/ 系统/ 运行/ trace/ 的/ 基础/ 上/ ,/ 我们/ 首先/ 需要/ 确定/ 叶子/ 任务/ 的/ 边界/ ./ Scalpel/ 使用/ 同步/ 点/ 作为/ 启发/ 定义/ 任务/ 边界/ ./ 同步/ 点/ 是/ 两个/ 线程/ 同步/ 相互/ 执行/ ,/ 从而/ 具有/ happened/ -/ before/ 关系/ 的/ 地方/ ./ 在/ 同步/ 点/ ,/ 线程/ 可能/ 因为/ 互斥/ 或者/ 相互/ 协同/ 而/ 具有/ happened/ -/ be/ -/ fore/ 关系/ ,/ 前者/ 的/ 例子/ 是/ 线程/ 等待/ 另/ 一个/ 线程/ 释放/ 保护/ 共享资源/ 的/ 锁/ ,/ 后者/ 的/ 例子/ 是/ 线程/ 向/ 另/ 一个/ 等待/ 在/ event/ 上线/ 程发/ signal/ 消息/ ,/ 通知/ 对方/ 继续执行/ ./ 我们/ 定义/ 两个/ 相继/ 的/ 同步/ 点/ 之间/ 的/ 执行/ 为/ 一个/ 叶子/ 任务/ ./ 采用/ 这个/ 定义/ 的/ 原因/ 是/ ,/ 首先/ 两个/ 同步/ 点/ 之间/ 的/ 一段/ 执行/ 是/ 相对/ 独立/ ,/ 并且/ 自/ 包含/ 的/ ,/ 不/ 与/ 其它/ 线程/ 的/ 执行/ 相互依赖/ ./ 因此/ ,/ 它们/ 合理/ 地/ 成为/ 任务模型/ 中/ 最小/ 粒度/ 的/ 一段/ 执行/ ,/ 也/ 是/ 叶子/ 任务/ 的/ 一个/ 自然/ 定义/ ./ 另外/ ,/ 因为/ 采用/ 了/ 同步/ 点/ 定义/ 叶子/ 任务/ 的/ 边界/ ,/ 叶子/ 任务/ 之间/ 的/ 依赖/ 关系/ 也/ 只/ 发生/ 在/ 边界/ 之间/ ./ Scalpel/ 通过/ 插装/ 系统/ 函数库/ 中/ 的/ 同步/ 原语/ (/ 锁/ 、/ 信号/ 、/ 事件/ 等/ )/ 与/ socket/ 操作/ ①/ 记录/ 同步/ 点/ 操作/ ./ 在/ 实际/ 系统/ 中/ 的/ 应用/ 经验/ 表明/ ,/ 插装/ 这些/ 系统/ 操作/ 是/ 足够/ 的/ ./ 如果/ 系统/ 使用/ spin/ -/ lock/ 或者/ lock/ -/ free/ 的/ 数据结构/ ,/ 则/ 仅/ 插装/ 系统/ 调用/ 是/ 不够/ 的/ ./ 这时/ Scalpel/ 会/ 丢失/ 一些/ 同步/ 点/ 从而/ 使/ 任务模型/ 粒度/ 更/ 粗/ ./ 手工/ 标注/ 可以/ 解决/ 这个/ 问题/ ,/ 但是/ 整个/ 推断/ 方法/ 不再/ 是/ 全自动/ 的/ ./ 鉴于/ 多数/ 实际/ 系统/ 还是/ 采用/ 系统/ 调用/ 进行/ 同步/ ,/ 我们/ 将/ 这个/ 问题/ 留/ 作/ 将来/ 的/ 工作/ ./ 2.3/ 任务/ 因果关系/ 图/ 为了/ 推断/ 任务/ 的/ 层次结构/ ,/ 我们/ 首先/ 要/ 连接/ 叶子/ 任务/ 之间/ 的/ 因果关系/ ./ 我们/ 使用/ 有向图/ 表示/ 任务/ 之间/ 的/ 关系/ ./ 这个/ 图中/ ,/ 节点/ 表示/ 叶子/ 任务/ ,/ 有/ 向/ 边/ 表示/ 叶子/ 任务/ 之间/ 的/ 因果/ 依赖/ 关系/ ./ 例如/ 在/ PacificA/ 中/ (/ 图/ 1/ )/ ,/ 当/ 存储/ 的/ 主/ 节点/ 收到/ 用户/ 提交/ 数据/ 的/ 消息/ 后/ ,/ 首先/ 将/ 数据/ 在/ 本地/ 持久/ 化/ 存储/ (/ LogicReplica/ ∷/ Mu/ -/ tate/ )/ ,/ 之后/ 将/ 数据/ 用/ 异步/ RPC/ 的/ 方式/ 发送给/ 次/ 节点/ (/ RpcClient/ ∷/ RpcAsyncCallChain/ }/ )/ ./ 因此/ 这/ 两个/ 叶子/ 任务/ 之间/ 用/ 有/ 向/ 边/ 连接/ ./ Scalpel/ 使用/ happened/ -/ before/ 关系/ 推断/ 任务/ 的/ 因果/ 依赖/ 关系/ ,/ 这/ 包括/ 同一/ 线程/ 内/ 顺序/ 执行/ 的/ 两个/ 叶子/ 任务/ 以及/ 因为/ 同步/ 而/ 依次/ 执行/ 的/ 叶子/ 任务/ ./ 并/ 不是/ 所有/ 因为/ 同步/ 而/ 具有/ happened/ -/ before/ 关系/ 的/ 叶子/ 任务/ 都/ 存在/ 因果关系/ ./ 我们/ 考虑/ 的/ 因果/ 依赖/ 关系/ ,/ 是/ 两个/ 叶子/ 任务/ 相互/ 确定性/ 依赖/ ./ 一个/ “/ 真/ ”/ 的/ 因果/ 依赖/ 关系/ 的/ 例子/ 是/ ,/ 一个/ 从/ 队列/ 里/ 取出/ 并/ 处理事件/ 的/ 任务/ ,/ 在/ 因果关系/ 上/ 依赖于/ 产生/ 那个/ 事件/ 并/ 将/ 其/ 加入/ 队列/ 的/ 任务/ ./ 另一方面/ ,/ 如果/ 两个/ 线程/ 使用/ 互斥/ 锁/ 同步/ 对/ 共享资源/ (/ 例如/ I/ // O/ )/ 的/ 访问/ ,/ 虽然/ 它们/ 的/ 行为/ 构成/ happened/ -/ before/ 关系/ ,/ 但/ 实际上/ ,/ 任务/ ①/ 我们/ 认为/ 通信/ 也/ 是/ 一种/ 同步操作/ ./ Page4/ 之间/ 并/ 不/ 相互依赖/ ,/ 其/ 执行/ 的/ 顺序/ 由/ 调度/ 器/ 随机/ 决定/ ./ Scalpel/ 使用/ 若干/ 启发/ 区分/ 这/ 两种/ 不同/ 的/ 关系/ ./ 如果/ 系统/ 使用/ 操作系统/ 提供/ 的/ 队列/ (/ 例如/ I/ // OCom/ -/ pletionPorts/ ,/ IOCP/ )/ ,/ 或者/ 通知/ 机制/ (/ 例如/ event/ )/ ,/ 则/ 可以/ 使用/ 同步操作/ 使用/ 的/ 句柄/ (/ 保存/ 在/ 插装/ 得到/ 的/ trace/ 中/ ,/ 是/ 同步操作/ 的/ 参数/ )/ ,/ 将/ 生产线/ 程与/ 消费/ 线程/ 联系/ 起来/ ./ 具体/ 地/ ,/ 可以/ 通过/ 分析/ trace/ 中/ 对于/ 同一/ 同步/ 对象/ 句柄/ 的/ 操作/ ,/ 得到/ 不同/ 线程/ 在/ 同步/ 对象/ 上/ 的/ 通知/ —/ —/ —/ 获取/ 通知/ ,/ 或者/ enqueue/ -/ dequeue/ 操作/ ,/ 区分/ 生产线/ 程与/ 消费/ 线程/ ,/ 得到/ 它们/ 的/ 依赖/ 关系/ ./ 操作系统/ 的/ 互斥/ (/ mutex/ )/ 与/ 信号量/ (/ semaphore/ )/ 对象/ ,/ 通常/ 仅仅/ 被/ 用来/ 同步/ 线程/ 对/ 共享资源/ 的/ 访问/ ,/ 生产线/ 程和/ 消费/ 线程/ 之间/ 通常/ 会/ 使用/ 显式/ 的/ 通知/ 机制/ (/ IOCP/ 等/ )/ 协调/ 数据共享/ ,/ 因此/ 不/ 认为/ 它们/ 构成/ 因果/ 依赖/ 关系/ ./ 对于/ 使用/ TCP/ 通信/ 产生/ 的/ 因果关系/ ,/ 由于/ TCP/ 的/ 数据流/ 语意/ 会/ 让/ 消息/ 的/ 边界/ 无法/ 分辨/ ,/ 因而/ 目前/ 只能/ 依赖/ 程序员/ 提供/ 额外/ 信息/ (/ 例如/ 在/ 消息/ 中/ 做/ 标记/ )/ 连接/ 消息/ 的/ 发送者/ 和/ 接受者/ ,/ 否则/ Scalpel/ 无法/ 准确/ 匹配/ ./ 然而/ 这会/ 引入/ 手工/ 干预/ ./ 一些/ 网络协议/ 逆向/ 工程/ 方面/ 的/ 工作/ [/ 6/ -/ 7/ ]/ 可以/ 从/ 数据流/ 中/ 自动/ 推断/ 消息/ 的/ 边界/ 与/ 格式/ ,/ 但是/ 推断/ 的/ 结果/ 存在/ 错误/ 的/ 可能/ ./ 本文/ 工作/ 暂时/ 不/ 考虑/ 将/ TCP/ 消息/ 的/ 发送者/ 和/ 接收者/ 联系/ 起来/ ,/ 但是/ 任务/ 的/ 因果关系/ 图/ 和/ 下面/ 叙述/ 的/ 任务/ 层次结构/ 推断/ 方法/ 同样/ 适用/ 于/ 包含/ TCP/ 通信/ 的/ 情况/ ./ 2.4/ 推断/ 任务/ 层次结构/ 我们/ 通过/ 不断/ 挖掘/ 任务/ 因果关系/ 图上/ 重复/ 出现/ 的/ 模式/ ,/ 来/ 推断/ 任务/ 的/ 层次结构/ ./ 控掘/ 算法/ 受到/ 文献/ [/ 8/ ]/ 的/ 启发/ ,/ 文献/ [/ 8/ ]/ 的/ 工作/ 通过/ 搜寻/ “/ 热点/ 子/ 路径/ ”/ (/ 就是/ 函数调用/ 路径/ 上/ 重复/ 出现/ 的/ 字串/ )/ ,/ 来/ 推断/ 上下文/ 无关/ 文法/ ./ 类似/ 地/ ,/ 我们/ 的/ 算法/ 搜寻/ 任务/ 因果关系/ 图上/ 重复/ 出现/ 的/ 子/ 图/ ./ 我们/ 认为/ 每/ 一个/ 子图/ 都/ 在/ 逻辑/ 上/ 代表/ 了/ 一个/ 更/ 高层/ 的/ 任务/ ,/ 它/ 由子/ 图中/ 的/ 任务/ 集合/ 构成/ ./ 通过/ 递归/ 调用/ 挖掘/ 算法/ ,/ 我们/ 得到/ 了/ 层次结构/ 的/ 任务模型/ ./ 具体/ 地/ ,/ 推断/ 算法/ 首先/ 枚举/ 任务/ 因果关系/ 图上/ 所有/ 的/ 连通/ 子图/ ,/ 并/ 将/ 这些/ 子图/ 按照/ 相似/ 度/ (/ 在下文/ 中/ 定义/ )/ 聚类/ 为/ 多个/ 模式/ ./ 推断/ 算法/ 将/ 每个/ 出现/ 次数/ 超过/ 设定/ 阈值/ 的/ 模式定义/ 为/ 一个/ 高层/ 任务/ ./ 接下来/ ,/ 得到/ 的/ 高层/ 任务/ 被/ 替换/ 为/ 单个/ “/ 超级/ ”/ 节点/ ./ 通过/ 递归/ 应用/ 算法/ ,/ 我们/ 可以/ 得到/ 更/ 高层/ 的/ 任务/ ,/ 直到/ 没有/ 新/ 的/ 高层/ 任务/ 产生/ ./ 这时/ ,/ 因果关系/ 图/ 包括/ 了/ 若干/ 超级/ 节点/ 以及/ 一些/ 未聚类/ 的/ 叶子/ 节点/ ,/ 图/ 可能/ 是/ 连通/ 也/ 可能/ 是/ 不/ 连通/ 的/ ./ Scalpel/ 将/ 那些/ 超级/ 节点/ 输出/ ,/ 每个/ 节点/ 都/ 是/ 一个/ 最高层/ 的/ 任务模型/ ./ 通过/ 将/ 超级/ 节点/ 展开/ 为/ 构成/ 它们/ 的/ 子/ 图/ ,/ 我们/ 可以/ 得到/ 任务/ 的/ 整个/ 层次结构/ ./ 算法/ 中/ 使用/ 相似/ 度/ 将子/ 图聚类/ 为/ 不同/ 的/ 模式/ ,/ 目前/ ,/ 我们/ 使用/ 精确/ 匹配/ 来/ 定义/ 两个/ 子图/ 相似/ ,/ 也/ 就是/ 两个/ 子图/ 完全/ 同构/ ./ 我们/ 使用/ 确定性/ 的/ 序列化/ 算法/ ,/ 将子/ 图/ 编码/ ,/ 并/ 使用/ 编码/ 的/ Hash/ 值将子/ 图聚类/ ./ 这个/ 聚类/ 算法/ 非常/ 有效/ ./ 当/ 编码/ 叶子/ 任务/ 时/ ,/ 我们/ 使用/ 任务/ 两个/ 边界/ 上/ 的/ 函数调用/ 栈/ 作为/ 任务/ 的/ 编码/ ,/ 忽略/ 了/ 任务/ 执行/ 过程/ 中/ 的/ 函数调用/ ./ 对于/ 同一个/ 类中/ 的/ 叶子/ 任务/ ,/ 它们/ 的/ 函数调用/ 栈/ 完全相同/ ./ 这个/ 方法/ 忽略/ 了/ 叶子/ 任务/ 一些/ 不/ 重要/ 的/ 区别/ ,/ 例如/ 函数/ 的/ 参数/ 与/ 线程/ 号/ ./ 从/ 经验/ 来看/ ,/ 这个/ 方法/ 很/ 好/ 地区/ 分/ 了/ 同一/ 类别/ 的/ 叶子/ 任务/ ./ 3/ 实现/ 我们/ 使用/ R2/ [/ 9/ ]/ 在/ Windows/ 平台/ 上/ 实现/ 了/ Scalpel/ ./ R2/ 是/ 一个/ 基于/ 函数库/ 的/ 程序运行/ 记录/ 与/ 回放/ 工具/ ./ 通过/ 插装/ 操作系统/ 调用/ 与/ 应用/ 函数/ ,/ R2/ 记录/ 了/ 系统/ 的/ 运行/ 过程/ ,/ 这/ 包括/ 对/ 同步/ 对象/ (/ 互斥/ 锁/ 和/ 信号/ 等/ )/ 的/ 同步操作/ 和/ socket/ 操作/ ./ 使用/ R2/ ,/ 我们/ 得到/ 系统/ 运行/ 过程/ 的/ trace/ ,/ 并/ 在/ trace/ 基础/ 上/ 分析/ 与/ 推断/ 得到/ 系统/ 的/ 层次结构/ 任务模型/ ./ 在/ 被/ 插装/ 的/ 系统/ 调用/ 与/ 应用/ 函数/ 内/ ,/ 包含/ 输出/ 的/ 函数/ 名称/ 与/ 调用/ 参数/ ./ 这些/ 信息/ 用来/ 推断/ 叶子/ 任务/ 的/ 边界/ ,/ 并/ 给出/ 任务/ 边界/ 的/ 函数调用/ 栈/ ./ 利用/ 函数调用/ 栈/ ,/ 可以/ 给/ 叶子/ 任务/ 提供/ 易于/ 程序员/ 理解/ 的/ 名字/ 标签/ ./ 我们/ 需要/ 保证/ trace/ 中/ 记录/ 的/ 同步操作/ 顺序/ 和/ 实际/ 执行/ 完全一致/ ./ 由于/ 操作系统/ 调度会/ 交叉/ 执行/ 不同/ 线程/ 的/ 代码/ ,/ 因而/ 直接/ 在/ 插装/ 函数/ 内/ 输出/ trace/ 并/ 不能/ 保证/ 同步操作/ 记录/ 的/ 顺序/ 与/ 实际/ 执行/ 顺序/ 一致/ ./ 由于/ 线程/ 被/ 随机/ 调度/ ,/ 可能/ 存在/ 图/ 2/ 显示/ 的/ 执行/ 顺序/ ./ 可以/ 看出/ ,/ 输出/ trace/ 的/ 顺序/ ,/ 和/ event/ 操作/ 的/ 顺序/ 是/ 相反/ 的/ ./ 为了/ 解决/ 这个/ 问题/ ,/ 我们/ 为/ 每个/ 同步/ 对象/ 创建/ 一个/ shadowlock/ ,/ 将/ WaitForSingleObject/ 操作/ 替换/ 为/ SignalObjectAndWait/ ,/ 保证/ 了/ 同步操作/ 与/ 输出/ trace/ 是/ 一个/ 原子/ 操作/ ./ Page54/ 性能/ 优化/ Scalpel/ 使用/ R2/ 获取/ 与/ 记录/ 函数调用/ 事件/ ./ 对系统/ 运行/ 时/ 的/ 每/ 一个/ 线程/ ,/ 都/ 创建/ 一个/ 单独/ 的/ 文件/ ,/ 记录/ 这个/ 线程/ 的/ 运行/ trace/ ./ 在/ 我们/ 之前/ 的/ 工作/ 中/ [/ 10/ ]/ ,/ 采用/ 了/ 基本/ 的/ 方法/ 记录/ 每个/ 线程/ 的/ 运行/ 时/ trace/ ./ 我们/ 使用/ 字典/ 对象/ (/ STLmap/ )/ 保存/ 每个/ 线程/ trace/ 的/ 文件/ 句柄/ ./ 对/ 每/ 一次/ 函数调用/ ,/ 首先/ 通过/ 系统/ 调用/ 得到/ 当前/ 线程/ 号/ ,/ 并/ 使用/ 线程/ 号/ 为/ 键值/ 查询/ 对应/ 线程/ 的/ trace/ 文件/ 句柄/ ,/ 将/ 函数调用/ 事件/ 记录/ 到/ trace/ 中/ ./ 在/ 多线程/ 情况/ 下/ ,/ 这个/ 方法/ 存在/ 性能/ 问题/ ./ 在/ 每/ 一次/ 函数调用/ 时/ ,/ 需要/ 使用/ 互斥/ 锁/ (/ mutex/ )/ 同步/ 多个/ 线程/ 访问/ trace/ 文件/ 字典/ 对象/ 的/ 过程/ ./ 由于/ 实际/ 系统/ 运行/ 时/ 可能/ 会/ 频繁/ 地/ 发生/ 函数调用/ ,/ 这样/ 的/ 实现/ 会/ 对/ 性能/ 产生/ 很大/ 的/ 额外/ 负载/ ./ 这个/ 实现/ 方法/ 不是/ 最优/ 的/ ,/ 因为/ 每个/ 线程/ 的/ trace/ 文件/ 都/ 是/ 相互/ 独立/ 的/ ,/ 并/ 不/ 交叉/ 访问/ ,/ 因而/ 存在/ 改进/ 的/ 空间/ ./ 我们/ 对/ 之前/ 的/ 方法/ 进行/ 了/ 优化/ ,/ 改进/ 了/ 性能/ ./ 具体/ 地/ ,/ 我们/ 使用/ 线程/ 局部/ 存储/ (/ ThreadLocalStor/ -/ age/ ,/ TLS/ )/ 技术/ 保存/ 每个/ 线程/ 的/ trace/ 文件/ 句柄/ ,/ 在/ 记录/ 函数调用/ 事件/ 时/ ,/ 直接/ 从/ 线程/ 局部/ 存储/ 中/ 得到/ trace/ 文件/ 句柄/ 即可/ ./ 这样/ 就/ 不必/ 使用/ 字典/ 对象/ 统一/ 保存/ 所有/ 线程/ 的/ trace/ 文件/ 句柄/ ,/ 在/ 记录/ 函数调用/ 事件/ 时/ ,/ 也/ 就/ 不必要/ 使用/ 互斥/ 锁/ 同步/ 线程/ 的/ 执行/ ./ 通过/ 对比/ 测试/ ,/ 我们/ 能够/ 看到/ 优化/ 后/ 由/ Scalpel/ 给/ 应用/ 带来/ 的/ 额外/ 负载/ 有/ 显著/ 降低/ ./ 在/ 测试/ 中/ ,/ 我们/ 使用/ 多个/ 线程/ ,/ 并行执行/ 一个/ 执行/ 体为/ 空/ 的/ 函数/ (/ empty/ )/ ,/ 对比/ 优化/ 前后/ 执行/ 时间/ 的/ 差别/ ./ 由于/ empty/ 函数/ 的/ 执行/ 体是/ 空/ ,/ 因而/ 可以/ 认为/ ,/ 相比/ 原始/ 代码/ 的/ 执行/ 时间/ ,/ 应用/ Scalpel/ 后/ 增加/ 的/ 执行/ 时间/ 全部/ 是因为/ 输出/ trace/ 所/ 导致/ 的/ ,/ 或者说/ 通过/ 代码/ 可以/ 测试/ 得到/ 输出/ trace/ 产生/ 额外/ 负载/ 的/ 最大值/ ./ 在/ 实际/ 系统/ 执行/ 时/ ,/ 并/ 不会/ 发生/ 如/ 测试/ 中/ “/ 频繁/ ”/ 的/ 函数调用/ ,/ 在/ 函数调用/ 之间/ 还会/ 执行/ 其它/ 代码/ ,/ 因而/ 产生/ 的/ 额外/ 负载/ 远/ 小于/ 本/ 测试/ 的/ 结果/ ./ 在/ 第/ 5/ 节中/ 我们/ 将/ Scalpel/ 应用/ 于/ Apache/ 和/ Pacifi/ -/ cA/ 系统/ ,/ 并/ 测试/ 了/ Scalpel/ 在/ 这/ 两个/ 系统/ 上/ 产生/ 的/ 实际/ 额外/ 负载/ ./ 图/ 3/ 显示/ 了/ 优化/ 前后/ 额外/ 负载/ 的/ 变化/ ./ 测试/ 是/ 在/ 如下/ 机器配置/ 上/ 进行/ 的/ :/ 2.0/ GHzXeon/ 双核/ CPU/ ,/ 4GB/ 内存/ ,/ 运行/ WindowsServer2003SP2/ 操作系统/ ./ 分别/ 测试/ 了/ 采用/ 与/ 不/ 采用/ 优化/ 时/ ,/ 不同/ 数量/ 线程/ 同时/ 执行/ hello/ 函数/ 的/ 时间/ 消耗/ 平均值/ ./ 可以/ 看出/ ,/ 优化/ 带来/ 的/ 性能/ 提升/ 是/ 明显/ 的/ ./ 在/ 单线程/ 时/ ,/ 两种/ 方法/ 并/ 没有/ 明显/ 性能/ 差异/ ./ 在/ 多线程/ 时/ ,/ 优化/ 后/ 性能/ 提升/ 很/ 明显/ ,/ 在/ 5/ 、/ 10/ 、/ 20/ 个/ 并行/ 线程/ 情况/ 下/ ,/ 执行/ 时间/ 分别/ 提高/ 了/ 8.8/ 、/ 7.0/ 和/ 7.7/ 倍/ ./ 图/ 3/ 优化/ 前后/ 输出/ trace/ 的/ 性能/ 额外/ 负载/ 情况/ 5/ 应用/ 实例/ 在/ 本节/ ,/ 我们/ 使用/ Scalpel/ 分析/ 一些/ 复杂/ 系统/ ,/ 以/ 评测/ 任务模型/ 是否/ 有效/ ./ 可以/ 从/ 两个/ 方面/ 来/ 评测/ 任务模型/ ./ 首先/ ,/ 任务模型/ 应该/ 能够/ 表达/ 出/ 系统/ 设计/ 的/ 含义/ ./ 这/ 一点/ 很/ 难用/ 数字/ 测量/ ,/ 因此/ ,/ 我们/ 需要/ 程序员/ 去/ 将/ 推断/ 的/ 任务模型/ 与/ 实际/ 系统/ 设计/ 对比/ ,/ 判断/ 任务模型/ 是否/ 表达/ 了/ 系统/ 设计/ 的/ 某些/ 方面/ ./ 其次/ ,/ 任务模型/ 也/ 是/ 验证/ 系统/ 正确性/ 或者/ 性能/ 的/ 方法/ ,/ 所以/ ,/ 我们/ 也/ 可以/ 评测/ 任务模型/ 在/ 帮助/ 调试/ 系统/ 时/ 的/ 有效性/ ./ 我们/ 同时/ 使用/ 这/ 两种/ 方式/ 评测/ Scalpel/ ,/ 分别/ 将/ Scalpel/ 应用/ 在/ Apache/ 和/ PacificA/ [/ 1/ ]/ 上/ ./ Apache/ 和/ PacificA/ 都/ 使用/ 了/ 典型/ 的/ 配置/ ./ 我们/ 在/ Apache/ 上/ 增加/ 了/ 一个/ Subversion/ (/ SVN/ )/ 模块/ ,/ 并/ 使用/ 客户端/ 执行/ 10/ 次/ Checkout/ ,/ 每次/ Checkout/ 的/ 文件/ 数目/ 是/ Page6377/ 个/ ,/ 文件大小/ 总和/ 是/ 1583KBbytes/ ./ 我们/ 使用/ 两台/ 机器配置/ 了/ 一个/ PacificA/ 的/ 复制/ 组/ (/ ReplicationGroup/ )/ ,/ 一台/ 机器/ 是/ 主/ 节点/ (/ primary/ )/ ,/ 一台/ 是从/ 节点/ (/ backup/ )/ ./ 我们/ 运行/ 一个/ 测试程序/ ,/ 在/ Pacifica/ 中/ 创建/ 一个/ 表/ ,/ 并/ 提交/ 15/ 条/ 随机/ 数据/ ./ 我们/ 使用/ Scalpel/ 追踪/ 每个/ 系统/ 的/ 运行/ ,/ 并/ 推断/ 任务模型/ ./ 两个/ 实验/ 都/ 是/ 在/ 如下/ 机器配置/ 上/ 进行/ 的/ :/ 2.0/ GHzXeon/ 双核/ CPU/ ,/ 4GB/ 内存/ ,/ 运行/ WindowsServer2003SP2/ 操作系统/ ,/ 机器间/ 通过/ 1Gb/ 网络连接/ ./ 图/ 4/ 执行/ SVNCheckout/ 得到/ 的/ Apache/ 任务模型/ 通过/ 仔细阅读/ 理解/ Apache/ 和/ SVN/ 的/ 代码/ ,/ 我们/ 确定/ 推断/ 的/ 模型/ 就是/ Apache/ 服务/ SVNCheck/ -/ out/ 操作/ 时/ 的/ 工作/ 流程/ ./ Apache/ 接受/ 外来/ 的/ 请求/ ,/ 并/ 将/ 请求/ 交给/ 线程/ 池中/ 的/ 一个/ worker/ 线程/ 去/ 完成/ ./ Scalpel/ 推断出/ 5/ 个/ Apache/ 核心/ 执行/ 的/ 叶子/ 任务/ (/ 图/ 4/ 的/ 左边/ 部分/ )/ ./ 每个/ 任务/ 表示/ Apache/ 接受/ 并/ 服务/ 请求/ 的/ 主要/ 步骤/ ./ SVNCheckout/ 过程/ 中/ 的/ 一些/ 叶子/ 任务/ 未/ 在/ 图上/ 完全/ 显示/ ,/ 但是/ 它们/ 都/ 是/ 处理/ 请求/ 过程/ 中/ 的/ 关键步骤/ ./ 因此/ ,/ 这/ 也/ 是/ 使用/ 同步/ 点为/ 启发/ 推断/ 叶子/ 任务/ 边界/ 有效性/ 的/ 一个/ 例证/ ./ 进一步/ ,/ Scalpel/ 还/ 成功/ 地/ 找到/ 了/ 两个/ 有/ 实际/ 含义/ 的/ 高层/ 任务/ ,/ 见图/ 4/ 中/ 方框/ 表示/ 的/ 部分/ ,/ 在/ 图上/ 我们/ 按照/ 两个/ 任务/ 的/ 工作/ 给/ 它们/ 标了/ 名字/ ./ 第一个/ 高层/ 任务/ (/ ContextPool/ )/ 包括/ 了/ 连接/ 上下文/ 被/ 取出/ 用来/ 传递/ 用户/ 请求/ 又/ 被/ 回收/ 的/ 过程/ ./ 另/ 一个/ (/ SVNCheckout/ )/ 包含/ 了/ SVNCheckout/ 被/ 处理/ 的/ 过程/ ./ 因为/ 这/ 两个/ 任务/ 都/ 被/ 频繁/ 执行/ ,/ 因此/ Scalpel/ 可以/ 精确/ 地/ 将/ 他们/ 确认/ 为/ 高层/ 任务/ ./ 5.2/ PacificA/ 图/ 1/ 显示/ 了/ PacificA/ 的/ 任务模型/ ./ PacificA/ 开发者/ 确认/ 了/ 这个/ 模型/ 准确/ 表达/ 了/ 用户/ 提交/ 数据/ 在/ 主/ 节点/ 上/ 执行/ 的/ 过程/ ./ 模型/ 包含/ 了/ 3/ 个/ 高层/ 任务/ ,/ 5.1/ Apache/ 我们/ 首先/ 人工/ 验证/ Scalpel/ 在/ Apache/ 上/ 推断/ 的/ 任务模型/ ./ 图/ 4/ 显示/ 了/ 得到/ 的/ 模型/ ./ 在/ 图上/ ,/ 每个/ 节点/ 都/ 是/ 一个/ 叶子/ 任务/ ,/ 连接/ 任务/ 的/ 实线/ 与/ 虚线/ 表示/ 任务/ 之间/ 的/ 因果关系/ ,/ 实线/ 表示/ 线程/ 内部/ 执行/ 顺序/ 因果关系/ ,/ 虚线/ 表示/ 线程/ 间/ 因果关系/ ./ 叶子/ 任务/ 上/ 标记/ 了/ 任务/ 起始/ 点/ 的/ 调用/ 栈/ ./ 为了/ 易于/ 理解/ ,/ 在/ 本文/ 中/ ,/ 我们/ 只/ 显示/ 了/ 调用/ 栈/ 尾部/ 调用/ 同步/ 函数/ 的/ 那个/ 函数/ 名称/ ./ 分别/ 是/ 提交/ 数据/ 执行/ 过程/ 的/ 3/ 个/ 主要/ 步骤/ :/ 一个/ worker/ 任务/ 、/ 一个/ 本地/ 提交/ 任务/ 和/ 一个/ 确认/ 远程/ 提交/ 的/ 任务/ ./ 在/ worker/ 任务/ 中/ ,/ 一个/ socket/ 监听/ 线程/ 循环/ 的/ 等待/ 用户/ 请求/ (/ Session/ ∷/ RecvPacket/ )/ ,/ 接受/ 来自/ 用户/ 的/ 消息/ ,/ 并/ 将/ 用户/ 请求/ 通过/ IOCP/ 交给/ 线程/ 池中/ 的/ worker/ 线程/ 去/ 执行/ (/ PAThreadPool/ ∷/ ThreadInternal/ ∷/ DoWork/ )/ ./ Worker/ 线程/ 取/ 到/ 用户/ 请求/ 后/ ,/ 立即/ 执行/ 本地/ 提交/ 任务/ ./ 它/ 首先/ 将/ 数据/ 在/ 本地/ 存储/ (/ LogicReplica/ ∷/ Mutate/ )/ ,/ 并/ 将/ 提交/ 请求/ 使用/ 异步/ RPC/ 发送给/ 从/ 节点/ (/ RpcClient/ ∷/ RpcAsync/ -/ CallChain/ )/ ,/ RPC/ 被/ 序列化/ 后/ 通过/ 网络层/ 发送/ 出去/ (/ Session/ ∷/ SendPacket/ )/ ,/ 在/ 主/ 节点/ 确认/ 自己/ 已经/ 持久/ 化/ 存储用户/ 提交/ 数据/ 后/ (/ LogicReplica/ ∷/ Receive/ -/ MutationAck/ )/ ,/ 本地/ 提交/ 任务/ 结束/ ./ 从/ 节点/ 在/ 收到/ 提交/ 请求/ 后/ 将/ 数据/ 存储/ ,/ 并/ 给/ 主/ 节点/ 发/ 确认/ 命令/ (/ acknowledgement/ )/ ./ 确认/ 远程/ 提交/ 任务/ 就是/ 主/ 节点/ 处理/ 从/ 节点/ 确认/ 命令/ 的/ ./ 它/ 首先/ 处理/ 从/ 节点/ 的/ 确认/ 消息/ (/ LogicReplica/ ∷/ ReceiveMutationAck/ )/ ,/ 之后/ 向/ 用户/ 回复/ 数据/ 提交/ 请求/ 的/ 结果/ (/ RpcClient/ ∷/ RpcCallReply/ )/ ,/ RPC/ 被/ 序列化/ 后/ 通过/ 网络层/ 发送/ 出去/ (/ Session/ ∷/ SendPacket/ )/ ./ 值得注意/ 的/ 是/ ,/ Scalpel/ 不仅仅/ 能够/ 推断出/ 用户/ Page7/ 提交/ 数据/ 的/ 过程/ 可以/ 分为/ 3/ 个/ 高层/ 任务/ ,/ 同时/ 能够/ 将/ worker/ 线程/ 执行/ 的/ 本地/ 提交/ 和/ 确认/ 远程/ 提交/ 两个/ 任务/ 区分/ 开来/ ./ 这/ 不是/ 因为/ Scalpel/ 理解/ 了/ 任务/ 执行/ 的/ 语意/ ,/ 而是/ 因为/ ,/ 这/ 两个/ 任务/ 分别/ 被/ 两次/ DoWork/ 任务/ 触发/ 执行/ ,/ 因此/ ,/ 挖掘/ 算法/ 能够/ 将/ 每个/ 任务/ 正确/ 地区/ 分开/ 来/ ./ 接下来/ ,/ 我们/ 评测/ 使用/ Scalpel/ 得到/ 的/ 任务模型/ 对/ 帮助/ 调试/ 系统/ 是否/ 有效/ ./ PacificA/ 的/ 开发者/ 希望/ 我们/ 能够/ 使用/ Scalpel/ 帮助/ 他们/ 解决/ 系统/ 中/ 的/ 一个/ 性能/ 问题/ ./ 开发者/ 注意/ 到/ 了/ 这个/ 问题/ ,/ 并/ 曾经/ 试图/ 使用/ 函数/ 性能/ 概要/ 分析/ (/ profiling/ )/ 的/ 办法/ ,/ 但是/ 没有/ 解决问题/ ./ 我们/ 使用/ 图/ 1/ 的/ 模型/ 分析/ PacificA/ 的/ 性能/ ./ 对/ 每/ 一个/ 叶子/ 任务/ ,/ 我们/ 使用/ Scalpel/ 记录/ 它/ 的/ 执行/ 时间/ 、/ 网络带宽/ 消耗/ 、/ CPU/ 使用/ 等/ 信息/ ./ 对/ 高层/ 任务/ ,/ 我们/ 将/ 它/ 的/ 子/ 任务/ 性能参数/ 聚集/ 得到/ 它/ 的/ 性能参数/ 信息/ ./ 通过/ 在/ 压力/ 测试/ 中/ 执行/ 数据/ 提交/ 操作/ ,/ 我们/ 很快/ 发现/ 了/ 一个/ 性能/ 问题/ :/ 提交/ 任务/ 很难/ 使用/ 所有/ 的/ 网络带宽/ ,/ 同时/ 它/ 的/ CPU/ 使用率/ 也/ 很/ 低/ ,/ 远/ 小于/ 100/ %/ (/ 为/ 70/ %/ )/ ./ 我们/ 通过/ 自上而下/ 的/ 办法/ 找到/ 这个/ 问题/ 的/ 症结/ ,/ 从/ 最高层/ 任务/ 向下/ ,/ 找到/ 执行/ 时间/ 最长/ 的/ 那个/ 任务/ ./ 我们/ 发现/ ,/ 当以/ 很/ 高频率/ 发送数据/ 时/ ,/ 发送/ 线程/ (/ 典型/ 的/ 配置/ 是/ 4/ 个/ 并行/ 线程/ 同时/ 发送/ )/ 会/ 在/ 某/ 一/ 时刻/ 阻塞/ 大约/ 1s/ ,/ 其/ 原因/ 是/ ,/ 在/ PacificA/ 的/ 网络层/ 代码/ ,/ 会/ 对/ 数据/ 发送/ 做/ 流量/ 控制/ ,/ 如果/ 发送/ 消息/ 的/ 缓冲区/ 满/ 了/ 的话/ ,/ 流量/ 控制/ 会/ 引起/ 所有/ 发送/ 线程/ 同步/ Sleep1s/ ,/ 如图/ 5/ 所示/ ./ 这样/ ,/ 4/ 个/ 并发/ 的/ 发送/ 线程/ 就/ 会/ 表现/ 出/ 几乎/ 同步/ 的/ 行为/ 来/ ,/ 如图/ 6/ 所示/ ./ intSession/ ∷/ WSASendPacket/ (/ NetworkStream/ / pkt/ )/ {/ CAutoLockguard/ (/ _/ send/ _/ lock/ )/ ;/ while/ (/ _/ send/ _/ size/ >/ (/ 64/ </ </ 20/ )/ )/ // // 64MBSleep/ (/ 1000/ )/ ;/ …/ intrt/ =/ WSASend/ (/ _/ socket/ ,/ buf/ ,/ buf/ _/ num/ ,/ &/ bytes/ ,/ 0/ ,/ (/ OVERLAPPED/ / )/ ce/ ,/ 0/ )/ ;/ …/ }/ 进一步/ 对/ 代码/ 审查/ 让/ 我们/ 对/ 问题/ 的/ 根本原因/ 有/ 了/ 深刻理解/ ./ 当/ 使用/ 异步/ 方式/ 调用/ RPC/ 时/ ,/ RPC/ 层/ 并/ 没有/ 流量/ 控制/ 机制/ ./ 每个/ 发送/ 线程/ 都/ 会/ 以/ 非/ 阻塞/ 方式/ 独立/ 发送/ RPC/ 消息/ ./ 网络层/ 的/ 消息/ 缓冲区/ 很快/ 就/ 会/ 被/ 填满/ ,/ 导致/ 发送/ 线程/ 被/ 网络层/ 阻塞/ ./ 这/ 就让/ 发送/ 线程/ 表现/ 出/ 了/ 同步/ 的/ 行为/ ,/ 无论/ 使用/ 多少/ RPC/ 发送/ 线程/ ,/ 它们/ 都/ 会/ 在/ 网路/ 层/ 被/ 同步/ 阻塞/ ./ 引起/ 这个/ 问题/ 的/ 根本原因/ 是/ RPC/ 层/ 和/ 网络层/ 没有/ 一致/ 的/ 控制/ 逻辑/ ./ 通过/ 使用/ 层次结构/ 任务模型/ ,/ 我们/ 很快/ 能够/ 找到/ 性能/ 问题/ ,/ 并/ 理解/ 造成/ 它/ 的/ 根本原因/ ./ 我们/ 进一步/ 尝试/ 解决/ 这个/ 性能/ 问题/ ./ 我们/ 将/ 异步/ 发送/ RPC/ 消息/ 改为/ 同步/ 发送/ 方式/ ,/ 也/ 就是/ 每个/ 线程/ 发送/ RPC/ 之后/ ,/ 等待/ RPC/ 结果/ 返回/ ,/ 然后/ 再/ 发送/ 下/ 一个/ RPC/ ./ 使用/ 相同/ 的/ 压力/ 测试/ 参数/ ,/ 我们/ 看到/ 这/ 一次/ 网络带宽/ 的/ 利用率/ 接近/ 100/ %/ (/ 97/ %/ 左右/ )/ ,/ 线程/ 发送/ RPC/ 的/ 行为/ 模式/ 如图/ 7/ 所示/ ./ 这个/ 结果/ 与/ 人们/ 的/ 直观/ 预期/ 不太/ 一致/ ./ 通常/ ,/ 人们/ 会/ 期待/ 异步/ 通信/ 会/ 比/ 同步/ 通信/ 的/ 性能/ 优良/ ./ 针对/ 这个/ 例子/ ,/ 我们/ 认为/ ,/ 造成/ 同步/ 通信/ 的/ 性能/ 更好/ 的/ 原因/ 是/ ,/ 同步/ 发送/ RPC/ 不会/ 触发/ PacificA/ 网路/ 层/ 的/ 流量/ 控制/ ./ 使用/ 同步/ RPC/ ,/ 系统/ 中/ 正在/ 发送/ 的/ RPC/ 数目/ 最/ 多/ 等于/ 发送/ 线程/ 数/ (/ 本例/ 是/ 4/ 个/ )/ ,/ 因而/ 不会/ 因为/ 发送/ 消息/ 缓冲/ 被/ 填满/ 而/ 导致/ 所有/ 线程/ Sleep1s/ 的/ 情况/ ./ 将/ RPC/ 通信/ 模式/ 从/ 异步/ 改为/ 同步/ 并/ 没有/ 完全/ 地/ 解决问题/ ./ 如果/ 网络/ 发生/ 拥塞/ 导致/ 同步/ RPC/ 调用/ 不能/ 很快/ 返回/ ,/ 则/ 系统/ 处理/ 用户/ 请求/ 的/ 速度/ 会受/ 影响/ ,/ 因而/ 需要/ 重新/ 设计/ PacificA/ 中/ RPC/ 层/ 和/ 网路/ 层/ 代码/ ,/ 改变/ 两个/ 函数/ 抽象/ 层/ 的/ 交互方式/ ,/ 才能/ 从根本上/ 提高/ 系统/ 性能/ ./ 5.3/ 性能/ 评测/ Scalpel/ 使用/ 了/ 插装/ 在/ 系统/ 函数/ 和/ 应用/ 函数调用/ 时/ 输出/ trace/ ,/ 这会/ 对系统/ 性能/ 造成/ 一定/ 影响/ ,/ 我们/ 测试/ 了/ Scalpel/ 对系统/ 带来/ 的/ 额外/ 负载/ ./ 具体/ 说/ ,/ 我们/ 测试/ 了/ 相同/ 环境/ 与/ 配置/ 下/ ,/ 应用/ 与/ 不/ 应用/ Scalpel/ 对系统/ 性能/ 造成/ 的/ 影响/ ./ 对/ PacificA/ ,/ 我们/ 测/ Page8/ 试/ 了/ 两种/ 情况/ 下/ 执行/ 一次/ 提交/ 数据/ 花费/ 的/ 时间/ ./ 对/ Apache/ 实验/ ,/ 我们/ 测试/ 了/ 执行/ 一次/ SVNCheckout/ 花费/ 的/ 时间/ ./ 每组/ 测试/ 都/ 运行/ 5/ 次/ ,/ 取/ 平均值/ 作为/ 最终/ 结果/ ./ 结果显示/ 在/ 表/ 1/ 中/ ./ 表/ 1Scalpel/ 对/ Apache/ 和/ PacificA/ 的/ 性能/ 影响/ Apache1/ ./ 564PacificA20/ ./ 792/ 可以/ 看出/ ,/ 对于/ PacificA/ 和/ Apache/ +/ SVN/ ,/ 由于/ 插装/ 输出/ trace/ 对/ 性能/ 的/ 影响/ 在/ 可以/ 接受/ 的/ 范围/ 以内/ ./ 6/ 相关/ 工作/ 已有/ 若干/ 工作/ 使用/ trace/ 构建/ 因果/ 路径/ 来/ 分析/ 多层/ 结构/ 分布式系统/ 的/ 运行/ 时/ 行为/ ,/ trace/ 的/ 来源/ 可能/ 是/ 操作系统/ 、/ 网络/ 或/ 应用层/ ./ Magpie/ [/ 4/ ]/ 通过/ 使用/ 用户/ 提供/ 的/ 模式/ (/ schema/ )/ 将/ 系统/ 事件/ 相关联/ 为/ 一组/ 因果/ 路径/ ./ Pinpoint/ [/ 11/ ]/ 通过/ 对/ 代码/ 加/ 标注/ 传播/ 路径/ 的/ 唯一/ 标识/ ,/ 路径/ 的/ 标识/ 和/ 用户/ 请求/ 一一对应/ ./ X/ -/ trace/ [/ 12/ ]/ 在/ 网络协议/ 扩展/ 上/ 加入/ 了/ 路径/ 相关/ 的/ 元/ 数据/ ,/ 从而/ 维持/ 了/ 网络/ 请求/ 在/ 网络层/ 处理/ 的/ 因果/ 路径/ ./ 这些/ 系统/ 都/ 需要/ 开发者/ 提供/ 应用/ 相关/ 的/ 任务/ 结构/ ,/ 包括/ 任务/ 边界/ 、/ 关联/ 标示/ 符/ 和/ 传播/ 规则/ ./ 本文/ 的/ 方法/ 能够/ 使用/ 一些/ 一般/ 的/ 启发式/ 方法/ 自动/ 推断/ 任务模型/ ,/ 而/ 不/ 需要/ 标注/ ./ Project5/ [/ 13/ ]/ 和/ Sherlock/ [/ 14/ ]/ 将/ 系统/ 看做/ 黑盒/ ,/ 通过/ 分析/ 系统/ 组件/ 之间/ 的/ 网络通信/ ,/ 自动/ 推断/ 系统/ 组件/ 之间/ 的/ 依赖/ 关系/ ./ 我们/ 的/ 方法/ 也/ 使用/ 了/ 统计/ 推断/ 方法/ ,/ 但是/ 并/ 不/ 限于/ 网络/ 组建/ ./ Whodunit/ [/ 15/ ]/ 和/ DataFlowTomography/ [/ 16/ ]/ 的/ 工作/ 通过/ 使用/ 虚拟机/ 追踪/ 函数调用/ 引起/ 的/ 数据流/ 依赖/ 关系/ ./ 这些/ 工作/ 能够/ 给出/ 精确/ 的/ 因果/ 依赖/ 关系/ ,/ 但是/ 监测/ 细粒度/ 的/ 内存/ 操作/ 导致/ 了/ 很大/ 的/ 性能/ 损耗/ ./ 相对/ 比/ 的/ ,/ 我们/ 的/ 方法/ 仅仅/ 追踪/ 了/ 系统/ 的/ 同步操作/ ,/ 并/ 使用/ 启发/ 推断/ 因果/ 依赖/ 关系/ ./ 因此/ 相比/ 更加/ 轻量/ ./ Pip/ [/ 3/ ]/ 和/ D3S/ [/ 17/ ]/ 检查用户/ 提供/ 的/ 谓词/ 来/ 发现/ 软件缺陷/ (/ bug/ )/ ./ Scalpel/ 推断/ 得到/ 任务模型/ 可以/ 应用/ 在/ 这些/ 系统/ 之上/ ,/ 从而/ 更加/ 容易/ 给出/ 与/ 检查/ 谓词/ ./ 7/ 总结/ 本文/ 研究/ 了/ 自动/ 推断/ 系统/ 层次结构/ 任务模型/ 的/ 方法/ ./ 这种/ 方法/ 使用/ 插装/ 技术/ ,/ 透明/ 地/ 监测/ 系统/ 运行/ ,/ 得到/ 系统/ 运行/ trace/ ./ 在/ 运行/ trace/ 基础/ 上/ ,/ 我们/ 能够/ 自动/ 推断出/ 合理/ 的/ 、/ 表达/ 系统/ 设计/ 含义/ 的/ 层次结构/ 任务模型/ 来/ ./ 在/ 一些/ 复杂/ 系统/ 上/ 的/ 应用/ 实例/ 表明/ ,/ 使用/ 得到/ 的/ 任务模型/ ,/ 能够/ 帮助/ 理解/ 系统/ 设计/ ,/ 解决/ 系统/ 已有/ 的/ 性能/ 问题/ ./ 

