Page1/ 增量/ 式/ 迭代/ 计算/ 模型/ 研究/ 与/ 实现/ 1/ )/ (/ 东北大学/ 软件/ 学院/ 沈阳/ 110819/ )/ 2/ )/ (/ 东北大学/ 计算中心/ 沈阳/ 110819/ )/ 3/ )/ (/ 东北大学/ 信息科学/ 与/ 工程学院/ 沈阳/ 110819/ )/ 摘要/ 不动点/ 迭代/ 广泛/ 存在/ 于/ 数据挖掘/ 和/ 机器/ 学习/ 算法/ 中/ ,/ 这些/ 算法/ 已/ 应用/ 到/ 诸如/ 社会/ 网络分析/ 、/ 高性能/ 计算/ 、/ 推荐/ 系统/ 、/ 搜索引擎/ 、/ 模式识别/ 等/ 诸多/ 领域/ 中/ ./ 在/ 云/ 计算环境/ 中/ ,/ 利用/ MapReduce/ 编程/ 模型/ 所/ 带来/ 的/ 便利/ ,/ 通过/ 普通/ 的/ PC/ 集群/ 运行/ 相应/ 的/ 迭代/ 算法/ ,/ 可以/ 提高/ 迭代/ 算法/ 的/ 执行/ 效率/ ./ 但/ 由于/ 数据/ 的/ 快速/ 变化/ ,/ 每当/ 数据/ 发生/ 改变/ ,/ 整个/ 迭代/ 算法/ 也/ 需要/ 重新/ 运行/ ,/ 这/ 将/ 会/ 导致/ 大量/ 的/ 运算/ 资源/ 浪费/ 和/ 性能/ 损失/ ./ 文中/ 研究/ 基于/ 原始/ 迭代/ 结果/ 和/ 新增/ 数据/ 的/ 增量/ 迭代/ 计算/ DELTA/ (/ DeltadatabasedincrEmentaLiTerAtivecomputing/ )/ ,/ 并/ 提出/ DELTA/ 模型/ 以/ 解决/ 上述/ 问题/ ./ 文中/ 理论/ 证明/ 了/ DELTA/ 模型/ 的/ 正确性/ ,/ 阐述/ 了/ 其/ 适用范围/ ,/ 并/ 列举/ 了/ PageRank/ 、/ K/ -/ means/ 和/ DescendantQuery/ 算法/ 在/ DELTA/ 模型/ 中/ 的/ 运用/ ./ 文中/ 还/ 扩展/ HaLoop/ 为/ Δ/ HaLoop/ 框架/ ,/ 使/ 其/ 支持/ 增量/ 式/ 的/ 迭代/ 计算/ ./ 通过/ 一系列/ 的/ 测试用例/ ,/ 对/ DELTA/ 模型/ 功能/ 、/ 性能/ 进行/ 了/ 分析/ 和/ 讨论/ ,/ 实验/ 结果表明/ DELTA/ 模型/ 在/ 获得/ 准确/ 的/ 迭代/ 结果/ 的/ 基础/ 上/ 性能/ 优势/ 明显/ ./ 文中/ 提出/ 的/ DELTA/ 模型/ 能够/ 适应/ 多数/ 迭代/ 算法/ ,/ 对云/ 计算环境/ 下/ 的/ 迭代/ 计算/ 的/ 应用/ 和/ 优化/ 起到/ 推动/ 作用/ ./ 关键词/ 云/ 计算/ ;/ 大/ 数据/ ;/ MapReduce/ ;/ 迭代/ 计算/ ;/ 增量/ 迭代/ 1/ 引言/ 不动点/ 迭代/ 广泛/ 存在/ 于/ 数据挖掘/ 和/ 机器/ 学习/ 算法/ 中/ ,/ 这些/ 算法/ 已/ 应用/ 到/ 诸如/ 社会/ 网络分析/ 、/ 高性能/ 计算/ 、/ 推荐/ 系统/ 、/ 搜索引擎/ 、/ 模式识别/ 等/ 诸多/ 领域/ 中/ ./ 例如/ :/ 著名/ 的/ PageRank/ 算法/ 根据/ 网页/ 之间/ 的/ 链接/ 关系/ ,/ 从/ 任意/ 迭代/ 初始值/ 开始/ ,/ 根据/ 迭代/ 函数/ 更新/ 每个/ 网页/ 的/ PageRank/ 值/ 直至/ 收敛/ [/ 1/ ]/ ;/ 类似/ 迭代/ 算法/ 还/ 包括/ 最大/ 期望/ (/ Expectation/ -/ Maximization/ )/ 算法/ 、/ K/ -/ means/ 算法/ [/ 2/ ]/ 、/ 协同/ 过滤/ (/ CollaborativeFiltering/ )/ 算法/ [/ 3/ ]/ 、/ SVM/ 算法/ [/ 4/ ]/ 等/ ./ 由此可见/ 迭代/ 算法/ 有着/ 非常/ 广泛/ 的/ 应用/ 范围/ ./ 随着/ 人类/ 进入/ 到/ 信息化/ 时代/ ,/ 互联网/ 、/ 传感器/ 和/ 生物/ 信息学/ 等/ 领域/ 的/ 快速/ 发展/ ,/ 数据量/ 呈现/ 爆炸/ 型/ 增长/ ./ 当今/ 时代/ 是/ 一个/ 数据量/ 爆发/ 的/ 时代/ [/ 5/ -/ 6/ ]/ ,/ 在/ 大/ 数据/ 环境/ 下/ ,/ 迭代/ 算法/ 出现/ 诸多/ 不/ 适用性/ ,/ 其中/ 由于/ 普通/ 服务器/ 的/ 计算能力/ 有限/ ,/ 算法/ 运行/ 时间/ 往往/ 令人/ 无法/ 接受/ ./ 大/ 数据/ 上/ 的/ 迭代/ 算法/ 的/ 运行/ 消耗/ 完全/ 超出/ 了/ 单/ 服务器/ 的/ 承受/ 极限/ ,/ 因此/ 学术界/ 开始/ 寻找/ 分布式/ 的/ 迭代/ 算法/ 执行/ 环境/ [/ 7/ ]/ ./ 基于/ Hadoop/ ①/ MapReduce/ [/ 7/ ]/ 的/ HaLoop/ 框架/ [/ 8/ ]/ 是/ 目前为止/ 较为/ 成熟/ 的/ 迭代/ 计算/ 框架/ ./ 利用/ HaLoop/ 框架/ 和/ MapReduce/ 编程/ 模型/ 所/ 带来/ 的/ 便利/ ,/ 可/ 通过/ 廉价/ 的/ PC/ 集群/ 获得/ 强大/ 的/ 计算能力/ ,/ 支持/ 大/ 数据/ 环境/ 下/ 众多/ 迭代/ 算法/ ./ 然而/ ,/ 我们/ 注意/ 到/ ,/ 时/ 变性/ 是/ 大/ 数据/ 的/ 一个/ 特点/ ./ 大/ 数据/ 是/ 数据量/ 庞大/ 且/ 高速/ 增长/ 的/ 数据/ ,/ 当/ 数据量/ 增加/ 后/ ,/ 原始数据/ 的/ 迭代/ 结果/ 将/ 不再/ 适用/ ,/ 整个/ 迭代/ 算法/ 也/ 需要/ 在/ 数据/ 全集/ 上/ 重新/ 运行/ ,/ 这/ 将/ 浪费/ 大量/ 的/ 时间/ 和/ 资源/ ./ 若/ 能够/ 通过/ 新增/ 数据/ 集/ 和/ 已知/ 的/ 迭代/ 结果/ 完成/ 增量/ 式/ 的/ 迭代/ 计算/ ,/ 则/ 可以/ 很大/ 程度/ 上/ 提高/ 迭代/ 计算/ 的/ 效率/ ./ 而/ 就/ 我们/ 目前/ 的/ 知识/ ,/ 现存/ 少量/ 模型/ 和/ 算法/ 层面/ 的/ 增量/ 式/ 迭代/ 计算/ 研究/ ,/ 成熟/ 的/ 增量/ 式/ 迭代/ 框架/ 也/ 屈指可数/ ,/ 文中/ 将/ 在/ 相关/ 工作/ 部分/ 加以分析/ 和/ 比较/ ,/ 此外/ 较/ 相关/ 的/ 工作/ 是/ 以/ 增量/ 的/ 方式/ 更新/ 元/ 数据/ 或/ 维护/ 索引/ 等/ ./ 例如/ Google/ 的/ Percolator/ [/ 9/ ]/ 系统/ 可以/ 以/ 增量/ 的/ 方式/ 更新/ 索引/ ,/ Incoop/ 本文/ 研究/ 增量/ 式/ 的/ 迭代/ 计算/ 模型/ 以及/ 其/ 实现/ 框架/ ,/ 而/ 非/ 迭代/ 算法/ 本身/ ,/ 旨在/ 提出/ 适用/ 于/ 大部分/ 算法/ 的/ ,/ 基于/ 原始/ 迭代/ 结果/ 和/ 新增/ 数据/ 的/ 增量/ 迭代/ 计算/ (/ DeltadatabasedincrEmentaLiTerAtivecomputing/ ,/ DELTA/ )/ 模型/ 和/ 框架/ ./ DELTA/ 模型/ 基于/ 新增/ 数据/ 集/ 和/ 原始/ 迭代/ 结果/ ,/ 进行/ 新一轮/ 迭代/ ,/ 在/ 不/ 损失/ 精度/ 的/ 前提/ 下/ 提升/ 迭代/ 性能/ ./ 本文/ 采用/ 复合/ 函数/ 和/ 集合/ 抽象/ 迭代/ 过程/ ,/ 定义/ 了/ DELTA/ 模型/ ,/ 阐述/ 其/ 适用范围/ ,/ 设计/ 了/ DELTA/ 模型/ 中/ 的/ 关键/ 算法/ ,/ 证明/ 了/ 其/ 性能/ 优势/ 和/ 迭代/ 结果/ 的/ 正确性/ ,/ 并/ 示例/ 性/ 地/ 给出/ 了/ 其/ 在/ PageRank/ 、/ K/ -/ means/ 、/ DescendantQuery/ 迭代/ 算法/ 中/ 的/ 应用/ ;/ 本文/ 还/ 扩展/ HaLoop/ 使/ 其/ 支持/ DELTA/ 模型/ ;/ 最后/ 本文/ 通过/ 实验/ 验证/ DELTA/ 模型/ 的/ 正确性/ 和/ 性能/ 优势/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 3/ 节/ 定义/ DELTA/ 模型/ ,/ 并/ 详述/ 模型/ 的/ 正确性/ 证明/ 和/ 适用范围/ 以及/ 在/ PageRank/ 、/ K/ -/ means/ 和/ DescendantQuery/ 算法/ 上/ 的/ 应用/ ;/ 第/ 4/ 节/ 简要/ 介绍/ 支持/ DELTA/ 模型/ 的/ HaLoop/ 扩展/ 框架/ 的/ 结构/ 以及/ 在/ 其他/ 框架/ 上/ 的/ 实现/ 分析/ ;/ 第/ 5/ 节/ 通过/ 实验/ 验证/ DELTA/ 框架/ 的/ 功能/ 和/ 性能/ ;/ 最后/ ,/ 在/ 第/ 6/ 节对/ 本文/ 的/ 研究/ 进行/ 总结/ 并/ 提出/ 进一步/ 的/ 工作/ ./ 2/ 相关/ 工作/ 迭代/ 算法/ ,/ 例如/ PageRank/ [/ 1/ ]/ 、/ HITS/ [/ 11/ ]/ 、/ 神经网络/ 计算/ [/ 12/ ]/ ,/ 都/ 有/ 一个/ 共同/ 的/ 特点/ :/ 数据/ 的/ 计算/ 过程/ 是/ 迭代/ 的/ ,/ 直至/ 满足/ 一个/ 确切/ 的/ 收敛/ 条件/ ./ 国内外/ 已有/ 较/ 多/ 针对/ 迭代/ 算法/ 的/ 研究成果/ ,/ 相关/ 技术/ 上/ 也/ 比/ ①/ http/ :/ // // hadoop/ ./ apache/ ./ org/ // Page3/ 较/ 成熟/ ./ 部分/ 研究/ 将/ 迭代/ 算法/ 等价/ 于/ 图/ 的/ 相关/ 算法/ ,/ 并/ 给出/ 理论/ 证明/ ./ 部分/ 文献/ 也/ 涉及/ 了/ 增量/ 式/ 的/ 迭代/ 算法/ 研究/ ./ 例如/ ,/ 文献/ [/ 13/ ]/ 给出/ 了/ 增量/ 式/ 的/ 迭代/ 计算/ 的/ 相关/ 条件/ ,/ 同时/ 给出/ 了/ 相关/ 增量/ 式/ 的/ 迭代/ 计算/ 的/ 例子/ 以及/ 反例/ ./ 文献/ [/ 14/ ]/ 研究/ 当/ 迭代/ 结构/ 发生/ 改变/ 时/ ,/ 如何/ 继续/ 进行/ 迭代/ ./ 上述/ 文献/ 虽然/ 对/ 不动点/ 迭代/ 算法/ 进行/ 了/ 深入/ 的/ 研究/ ,/ 但/ 由于/ 发表/ 时间/ 较/ 早/ ,/ 尚未/ 采用/ 分布式计算/ 环境/ ,/ 而且/ 均/ 针对/ 特定/ 算法/ ./ 此外/ ,/ 若/ 使用/ 上述/ 文献/ 中/ 的/ 方法/ 进行/ 大/ 数据/ 迭代/ 计算/ ,/ 会/ 由于/ 数据量/ 以及/ 运算量/ 超过/ 单/ 服务器/ 承受能力/ 而/ 无法/ 即时/ 获得/ 准确/ 的/ 迭代/ 结果/ ./ 然而/ ,/ MapReduce/ 对于/ 迭代/ 计算/ 并/ 没有/ 提供/ 直接/ 的/ 支持/ ./ 一种/ 变通/ 的/ 方法/ 是/ 编程人员/ 通过/ 程序设计/ ,/ 精心/ 地/ 布置/ MapReduce/ 任务/ ,/ 同时/ 编写/ 一些/ 特殊/ 的/ 算法/ 来/ 支持/ 迭代/ 算法/ ,/ 例如/ ,/ 用于/ 检测/ 收敛/ 条件/ 是否/ 满足/ 的/ 相关/ 算法/ ./ 这样/ 做/ 将/ 会/ 导致/ 编写/ 迭代/ 算法/ 的/ 过程/ 异常/ 复杂/ ,/ 一些/ 简单/ 的/ 作业/ 也/ 需要/ 采用/ 多个/ Map/ 和/ Reduce/ 任务/ 来/ 实现/ ,/ 且/ 大量/ 中间/ 结果/ 的/ 存储/ 和/ 传递/ 导致/ I/ // O/ 资源/ 和/ 网络资源/ 的/ 浪费/ ./ Bu/ 等/ 人/ [/ 8/ ]/ 在/ 提出/ 了/ HaLoop/ 框架/ ,/ 基于/ 云/ 计算技术/ 提供/ 迭代/ 算法/ 的/ 运行/ 框架/ ,/ 使得/ 迭代/ 计算/ 更/ 高效/ ./ HaLoop/ 扩展/ 了/ Hadoop/ ,/ 以/ 更/ 适合/ 迭代/ 计算/ ,/ 包括/ :/ (/ 1/ )/ 编程/ 接口/ 更加/ 适用/ 于/ 迭代/ 算法/ ;/ (/ 2/ )/ 框架/ 实现/ 迭代/ 终止/ 条件/ 的/ 检测/ ;/ (/ 3/ )/ 任务/ 尽量/ 满足/ 数据/ 本地/ 计算/ 的/ 特性/ ,/ 两次/ 迭代/ 任务/ 尽量/ 使用/ 相同/ 的/ 数据/ ;/ (/ 4/ )/ 采用/ 缓存/ 和/ 索引/ 两种/ 优化/ 机制/ ./ 但是/ HaLoop/ 的/ 动态/ 和/ 静态数据/ 无法/ 分离/ ,/ 且/ 没有/ 一个/ 客观/ 的/ 停止/ 迭代/ 的/ 标准/ [/ 5/ ]/ ./ 此外/ ,/ 还/ 存在/ 一些/ 迭代/ 计算/ 框架/ 的/ 实现/ ./ Twister/ [/ 15/ ]/ 是/ 一个/ 基于/ 流/ ,/ 支持/ 迭代/ 算法/ 的/ MapReduce/ 框架/ ,/ 它/ 将/ 全部/ 数据/ 存放/ 在/ 分布式/ 缓存/ 中/ ,/ 采用/ 独立/ 模块/ 传递/ 所有/ 的/ 消息/ 和/ 数据/ ./ 但是/ 数据/ 驻留/ 内存/ 的/ 限制/ 使/ 其/ 难以/ 实用/ ,/ 且/ 其/ 计算/ 模型/ 的/ 抽象/ 程度/ 不高/ ,/ 支持/ 的/ 算法/ 也/ 很/ 有限/ ./ iHadoop/ 分配器/ 提供/ 一种/ 数据/ 定位/ 机制/ ,/ 从而/ 减少/ 数据/ 的/ 冗余/ 传输/ 以及/ I/ // O/ 和/ 网络资源/ 的/ 浪费/ ./ PrIter/ [/ 17/ ]/ 是/ 基于/ Hadoop/ 的/ ,/ 支持/ 带/ 优先级/ 的/ 迭代/ 计算/ 框架/ ,/ 能够/ 保证/ 迭代/ 的/ 快速/ 收敛/ ,/ 适合/ 实时/ 查询/ 需求/ ./ iMapReduce/ [/ 18/ ]/ 是/ 一种/ 基于/ MapReduce/ 的/ 迭代/ 计算/ 模型/ ,/ 它/ 尽量/ 地/ 减少/ MapReduce/ 作业/ 的/ 数量/ ,/ 通过/ 缓存/ 的/ 方法/ 除去/ Shuffle/ 阶段/ 中/ 的/ 静态数据/ ,/ 并/ 允许/ Map/ 任务/ 的/ 异步/ 执行/ ,/ 以此/ 优化/ 迭代/ 计算/ 过程/ ./ 但是/ 它/ 的/ 静态/ 调度/ 策略/ 和/ 粗粒度/ 的/ 任务/ 可能/ 会/ 导致/ 资源/ 利用/ 不佳/ 和/ 负载/ 不/ 均衡/ ./ REX/ [/ 19/ ]/ 结合/ 了/ 大/ 数据/ 环境/ 中/ 的/ 计算/ 平台/ 和/ 传统/ 的/ RDBMS/ 技术/ ,/ 提出/ 了/ RQL/ 在/ 大/ 数据/ 环境/ 中/ 模拟/ SQL/ 的/ 特性/ 如/ 连接/ 、/ 聚集/ 、/ 子/ 查询/ 、/ 递归/ 查询/ 等/ ./ 其/ 主要/ 创新/ 点/ 在于/ :/ 对于/ 迭代/ 计算/ 而言/ ,/ 可以/ 仅/ 传递/ 迭代/ 步骤/ 间/ 的/ 变化/ ,/ 从而/ 大幅度/ 的/ 优化/ 迭代/ (/ 递归/ )/ 查询/ ./ 在/ 上述/ 迭代/ 计算/ 框架/ 中均/ 提供/ 基于/ 云/ 计算技术/ 的/ 迭代/ 算法/ 执行/ 环境/ ,/ 但/ 都/ 没有/ 考虑/ 增量/ 数据/ 的/ 迭代/ 问题/ ,/ 当新/ 数据/ 产生/ 时/ ,/ 上述/ 框架/ 均/ 需要/ 重新/ 进行/ 迭代/ ./ 此外/ ,/ 支持/ 迭代/ 计算/ 的/ 分布式/ 框架/ 还有/ HaLoopNaiad/ [/ 21/ ]/ 等/ ,/ 后文会/ 提及/ ./ 本文/ 基于/ HaLoop/ 实现/ 了/ 支持/ DELTA/ 模型/ 的/ Δ/ HaLoop/ ,/ HaLoop/ 又/ 是/ 基于/ Hadoop/ 分布式文件系统/ 的/ ,/ 而/ 其他/ 主流/ 的/ 迭代/ 框架/ ,/ 如/ Spark/ 、/ Twister/ 和/ Naiad/ ,/ 或/ 基于/ 其他/ 文件系统/ ,/ 或/ 基于/ 分布式/ 缓存/ ./ 但/ 理论/ 上/ ,/ 这些/ 框架/ 都/ 可以/ 扩展/ 以/ 支持/ DELTA/ 模型/ ./ 此外/ 我们/ 也/ 参考/ 了/ 特定/ 算法/ 的/ 增量/ 式/ 迭代/ 优化/ ,/ 本节/ 以/ K/ -/ Means/ 算法/ 为例/ ./ 文献/ [/ 22/ ]/ 基于/ FGKA/ (/ FastGeneticK/ -/ meansAlgorithm/ )/ 提出/ 了/ IGKA/ (/ IncrementalGeneticK/ -/ meansAlgorithm/ )/ ,/ 用于/ 基因/ 数据/ 的/ 聚类/ ;/ 文献/ [/ 23/ ]/ 提出/ 基于/ 图割/ 理论/ 的/ KernelK/ -/ means/ 算法/ ,/ 同时/ 进一步/ 提出/ 了/ 增量/ 式/ 加权/ KernelK/ -/ means/ 算法/ ;/ 文献/ [/ 24/ ]/ 研究/ 了/ K/ -/ means/ 收敛/ 的/ 情况/ ,/ 并/ 基于/ DistortionsReduction/ 提出/ 增量/ 式/ K/ -/ means/ 算法/ ,/ 解决/ 了/ K/ -/ means/ 收敛/ 到/ 局部/ 极值/ 问题/ ;/ 文献/ [/ 25/ ]/ 提出/ 了/ 基于/ 手机/ 轨迹/ 数据/ 的/ 紧凑/ 表示法/ 和/ 轨迹/ 相似性/ 度量/ ,/ 基于/ 上述/ 理论/ 该/ 研究/ 又/ 提出/ 了/ 增量/ 式/ 的/ 聚类/ 方法/ 用于/ 发现/ 空间/ 中/ 相似/ 的/ 移动/ 终端/ ;/ 文献/ [/ 26/ ]/ 基于/ 现有/ 的/ 增量/ 式/ 神经网络/ (/ IGNG/ )/ 提出/ 了/ 其/ 改进/ 算法/ I2GNG/ 用于/ 证券/ 分类/ (/ InvoiceClassification/ )/ ;/ 文献/ [/ 27/ ]/ 提出/ 了/ 增量/ 式/ 分类/ 方法/ 用于/ 在线/ 文档/ 分类/ ,/ 但是/ 其/ 研究/ 重点/ 是/ 相似性/ 度量/ 和/ 文档/ 结构/ 的/ 抽取/ ./ 本文/ 提出/ 的/ DELTA/ 模型/ 并非/ 针对/ K/ -/ means/ 算法/ ,/ 并且/ 和/ 上述/ 研究/ 也/ 有/ 较大/ 的/ 区别/ :/ 一部分/ 算法/ 是/ 单机/ 算法/ ,/ 难以/ 扩展/ 到/ 分布式/ 环境/ ,/ 即/ 使用/ MapReduce/ 成功/ 改写/ 这些/ 算法/ ,/ 其/ 执行/ 性能/ 也/ 很/ 低/ ,/ 如/ 文献/ [/ 22/ -/ 23/ ]/ ;/ 另/ 一部分/ 算法/ 采用/ “/ 增量/ 迭代/ ”/ 技术/ ,/ 其/ 目的/ 是/ 为了/ 研究/ 算法/ 收敛性/ ,/ 或/ 特定/ 领域/ 的/ 聚类/ 算法/ ,/ 与/ 本文/ 所/ 定义/ 的/ DELTA/ 目标/ 不同/ ,/ 如/ 文献/ [/ 24/ -/ 27/ ]/ ./ 在/ 相关/ 文献/ 中/ ,/ 文献/ [/ 28/ ]/ 属于/ 增量/ 式/ 的/ K/ -/ means/ 算法/ ,/ 且/ 可以/ 移植/ 到/ MapReduce/ 框架/ 中/ ,/ 且/ 移植/ 后/ 的/ 算法/ 与/ 本文/ 实验/ 中/ 所/ 采用/ 的/ K/ -/ means/ 全量/ 迭代/ 算法/ 是/ 一致/ 的/ ,/ 本文/ 5.4/ 节对/ 其/ 进行/ 性能/ 比较/ ./ 通过/ 分析/ 可以/ 看出/ ,/ 大多数/ 的/ 迭代/ 计算/ 框架/ 都/ Page4/ 优化/ 迭代/ 算法/ 的/ 执行/ 过程/ ,/ 从而/ 提高/ 计算/ 效率/ ./ 具体/ 的/ 措施/ 如下/ :/ (/ 1/ )/ 使用/ 缓存/ 和/ 索引/ 的/ 方法/ ,/ 尽量/ 地/ 减少/ 数据传输/ 过程/ 中/ 本地/ 和/ 网络/ I/ // O/ 代价/ ;/ (/ 2/ )/ 使用/ 内存/ 优化/ 的/ 相关/ 技术/ ,/ 加速/ 迭代/ 算法/ 的/ 执行/ ;/ (/ 3/ )/ 使用/ 缓存/ 技术/ 优化/ 迭代/ 计算/ 中/ 终止/ 条件/ 判定/ 操作/ ,/ 从而/ 减少/ 迭代/ 算法/ 执行/ 时间/ ;/ (/ 4/ )/ 优化/ Map/ 任务/ 和/ Reduce/ 任务/ 之间/ 的/ 通信/ 方法/ ,/ 从而/ 实现/ 异步/ 迭代/ ;/ (/ 5/ )/ 引入/ RDBMS/ 的/ 递归/ 查询/ 技术支持/ 迭代/ 更新/ ./ 在/ 迭代/ 框架/ 的/ 研究/ 方面/ ,/ 当前/ 研究/ 基于/ 算法/ 运行/ 流程/ 角度/ 更新/ 迭代/ 结果/ ,/ 但/ 现有/ 研究/ 均/ 未/ 涉及/ 基于/ 原始/ 迭代/ 结果/ 和/ 新增/ 数据/ 的/ DELTA/ 模型/ 和/ 框架/ ./ DELTA/ 作为/ 迭代/ 计算/ 的/ 一种/ 重要/ 的/ 优化/ 手段/ ,/ 能够/ 利用/ 原始/ 迭代/ 结果/ 以及/ 新增/ 数据/ 在/ 较/ 短时间/ 内/ 得到/ 新/ 的/ 迭代/ 结果/ ./ 本文/ 从/ 算法/ 和/ 迭代/ 框架/ 层面/ 出发/ ,/ 研究/ 内容/ 与/ 现有/ 研究/ 有着/ 本质/ 不同/ ./ 3/ 增量/ 迭代/ 计算/ 模型/ DELTA/ 模型/ 是/ 迭代/ 算法/ 和/ 计算/ 过程/ 的/ 抽象/ ,/ 该/ 模型/ 利用/ 已有/ 迭代/ 结果/ 以及/ 新增/ 数据/ 集/ ,/ 计算/ 新/ 的/ 迭代/ 结果/ ,/ 该/ 模型/ 是/ 增量/ 迭代/ 计算/ 框架/ 的/ 基础/ ./ 在/ 本节/ 中/ ,/ 首先/ 定义/ 迭代/ 、/ 迭代/ 轮/ 、/ 增量/ 迭代/ 等/ 相关/ 概念/ ;/ 随后/ 给出/ DELTA/ 模型/ 的/ 形式化/ 表达/ ;/ 最后/ 介绍/ 模型/ 证明/ 、/ 差集/ 算法/ 和/ 模型/ 应用/ ./ 3.1/ 模型/ 定义/ 定义/ 1/ ./ 迭代/ ./ 迭代/ 是/ 用/ 计算机/ 解决问题/ 的/ 一种/ 基本/ 方法/ ./ 计算机/ 对/ 一组/ 指令/ 或/ 一定/ 步骤/ 重复/ 执行/ ,/ 在/ 每次/ 执行/ 这组/ 指令/ 或/ 步骤/ 时/ ,/ 由/ 变量/ 的/ 原值/ 推出/ 它/ 的/ 新值/ ./ 根据/ 定义/ 1/ ,/ 一个/ 迭代/ 算法/ 实际上/ 是/ 函数/ 的/ 重复/ 执行/ ,/ 在/ 执行/ 过程/ 中/ 对/ 一组/ 变量/ 进行/ 更新/ ,/ 直到/ 达到/ 某种/ 终止/ 条件/ 为止/ ,/ 由此/ 可/ 得/ 迭代/ 算法/ 的/ 3/ 个/ 要素/ 为/ 迭代/ 变量/ 、/ 迭代/ 函数/ 和/ 迭代/ 的/ 终止/ 条件/ ./ (/ 1/ )/ 迭代/ 变量/ ./ 在/ 迭代/ 算法/ 中/ ,/ 至少/ 存在/ 一个/ 直接/ 或/ 间接/ 地/ 不断/ 由/ 旧值/ 递/ 推出/ 新值/ 的/ 变量/ ,/ 这个/ 变量/ 就是/ 迭代/ 变量/ ./ (/ 2/ )/ 迭代/ 函数/ ./ 由/ 迭代/ 变量/ 的/ 前/ 一个/ 值/ 推出/ 其下/ 一个/ 值/ 的/ 函数/ ./ (/ 3/ )/ 迭代/ 终止/ 条件/ ./ 当/ 迭代/ 终止/ 条件/ 满足/ 时/ ,/ 迭代/ 算法/ 运行/ 结束/ ,/ 输出/ 迭代/ 结果/ ,/ 此时/ 也/ 称之为/ 迭代/ 算法/ 收敛/ ./ 定义/ 2/ ./ 迭代/ 轮/ ./ 迭代/ 变量/ 通过/ 迭代/ 函数/ 更新/ 一次/ 的/ 过程/ 称之为/ 一次/ 迭代/ 轮/ ,/ 或/ 一轮/ 迭代/ ./ 整个/ 迭代/ 算法/ 可以/ 由/ n/ (/ n/ / 1/ )/ 个/ 迭代/ 轮/ (/ n/ 轮/ 迭代/ )/ 组成/ ,/ 记作/ t1/ ,/ t2/ ,/ …/ ,/ tn/ ,/ / i/ ∈/ [/ 1/ ,/ n/ -/ 1/ ]/ ,/ ti/ 的/ 输出/ 是/ ti/ +/ 1/ 的/ 输入/ ,/ t1/ 的/ 输入/ 定义/ 为/ 初始化/ 迭代/ 变量/ 以及/ 参与/ 迭代/ 的/ 数据/ ,/ tn/ 的/ 输出/ 即/ 为/ 最终/ 的/ 迭代/ 结果/ ./ 设/ 迭代/ 算法/ x/ =/ fn/ (/ x0/ ,/ L/ )/ :/ 根据/ 某/ 迭代/ 初始/ 变量/ x0/ 和/ 迭代/ 数据/ L/ ,/ 经过/ 迭代/ 计算/ 得到/ 迭代/ 结果/ x/ ./ f/ (/ x/ ,/ L/ )/ 是/ 迭代/ 函数/ ,/ 亦可/ 视为/ 某轮/ 迭代/ ./ f/ (/ x/ ,/ L/ )/ 的/ 参数/ 为/ 迭代/ 变量/ 的/ 初始值/ x0/ 以及/ 迭代/ 数据/ L/ ./ 记/ 函数/ f/ (/ x/ ,/ L/ )/ 的/ n/ 次/ 自身/ 复合/ 函数/ f/ (/ f/ (/ …/ f/ (/ f/ (/ x/ ,/ L/ )/ ,/ L/ )/ …/ ,/ L/ )/ ,/ L/ )/ 为/ fn/ (/ x/ ,/ L/ )/ ./ fn/ (/ x0/ ,/ L/ )/ 表示/ 迭代/ 函数/ 作用/ 于/ 迭代/ 数据/ L/ 上/ ,/ 经过/ n/ 轮/ 达到/ 收敛/ 状态/ ./ 当/ 基于/ 迭代/ 数据/ L/ 的/ 迭代/ 计算/ 完成/ 后/ ,/ 由于/ 业务/ 增长/ 而/ 产生/ 的/ 新/ 的/ 迭代/ 数据/ Δ/ L/ 即为/ 增量/ 数据/ ./ 例如/ ,/ PageRank/ 算法/ 的/ 网页/ 链接/ 关系数据/ 和/ 社会/ 网络/ 的/ 图/ 状态/ 数据/ 每天/ 都/ 会/ 增加/ ,/ 于是/ ,/ 需要/ 根据/ 全量/ 数据/ 更新/ 迭代/ 结果/ ./ 在/ 后文/ 3.2/ 节会/ 详细描述/ ,/ 我们/ 定义/ L/ 为/ 原始数据/ ,/ Δ/ L/ 为/ 增量/ 数据/ ,/ Δ/ L/ -/ L/ 为/ 差集/ 数据/ ,/ Δ/ L/ // L/ 为/ 关联/ 数据/ ,/ Δ/ L/ ∪/ L/ 为/ 全量/ 数据/ ,/ 一般/ 的/ ,/ |/ Δ/ L/ |/ / |/ L/ |/ ./ 在/ 原始数据/ 上/ 的/ 迭代/ 称为/ 原始/ 迭代/ ,/ 在/ 全量/ 数据/ 上/ 的/ 迭代/ 称为/ 全量/ 迭代/ ./ 两者/ 算法/ 相同/ 但/ 针对/ 的/ 数据/ 不同/ ./ 全量/ 迭代/ 能够/ 得到/ 更新/ 后/ 的/ 迭代/ 结果/ 但/ 消耗/ 大量/ 资源/ ./ 本文/ 的/ DELTA/ 模型/ 将/ 依赖/ 定义/ 3/ 中/ “/ 增量/ 迭代/ ”/ 的/ 定义/ ./ 后文/ 将/ 证明/ 增量/ 迭代/ 结果/ 与/ 全量/ 迭代/ 结果/ 相同/ ,/ 但/ 性能/ 优于/ 全量/ 迭代/ ./ 定义/ 3/ ./ 增量/ 迭代/ ./ 增量/ 迭代/ 是/ 根据/ 新增/ 数据/ Δ/ L/ 和/ 原始/ 迭代/ 结果/ 获得/ 新/ 的/ 迭代/ 结果/ 的/ 迭代/ 方法/ ,/ 且/ 可由式/ (/ 4/ )/ 表达/ ./ 所以/ R/ / =/ f/ γ/ [/ f/ α/ (/ R0/ ,/ L/ )/ ∪/ f/ β/ (/ Δ/ R0/ ,/ Δ/ L/ -/ L/ )/ ,/ L/ ∪/ Δ/ L/ ]/ 根据/ 式/ (/ 1/ )/ ~/ (/ 3/ )/ ,/ 增量/ 迭代/ 的/ 步骤/ 定义/ 为/ :/ (/ 1/ )/ 原始/ 步/ ./ 在/ 原始数据/ L/ 上/ 进行/ α/ 轮/ 迭代/ 直至/ 收敛/ ,/ 初始/ 迭代/ 变量/ 集为/ R0/ ,/ 收敛/ 后/ 得到/ 原始数据/ 上/ 的/ 迭代/ 结果/ 集/ R/ ,/ 如式/ (/ 1/ )/ 所示/ ,/ 该/ 步骤/ 在/ 增量/ 数据/ Δ/ L/ 到来/ 时/ 已经/ 完成/ ;/ (/ 2/ )/ 增量/ 步/ ./ 在/ 差集/ 数据/ Δ/ L/ -/ L/ 上/ 进行/ β/ 轮/ 迭代/ 直至/ 收敛/ ,/ 初始/ 迭代/ 变量/ 为/ Δ/ R0/ ,/ 收敛/ 后/ 得到/ 差集/ 数据/ 上/ 的/ 迭代/ 结果/ 集/ Δ/ R/ ,/ 如式/ (/ 2/ )/ 所示/ ;/ (/ 3/ )/ 合并/ 步/ ./ 在/ 全量/ 数据/ L/ ∪/ Δ/ L/ 上/ 继续/ γ/ 轮/ 迭代/ 直至/ 收敛/ ,/ 初始/ 迭代/ 变量/ 集为/ R/ ∪/ Δ/ R/ ,/ 收敛/ 后/ 得到/ 最终/ 迭代/ 结果/ 集/ R/ / ,/ 如式/ (/ 3/ )/ 所示/ ./ 定义/ 3/ 即/ 定义/ 了/ DELTA/ 模型/ 采用/ 的/ 迭代/ 方法/ ,/ 且/ 定义/ 3/ 同样/ 适用/ 于/ 原始/ 迭代/ 的/ 情况/ ./ 按式/ (/ 4/ )/ ,/ Page5/ 在/ 初次/ 迭代/ 时/ ,/ 原始/ 的/ 迭代/ 结果/ R/ =/ / ,/ 原始数据/ L/ =/ / ,/ 这时/ 所有/ 的/ 迭代/ 数据/ 被/ 当作/ 增量/ 数据/ Δ/ L/ 处理/ ,/ α/ =/ γ/ =/ 0.3/ ./ 2/ 迭代/ 数据/ 迭代/ 数据/ 是/ 由/ 数据/ 以及/ 数据/ 间/ 的/ 关系/ 所/ 组成/ 的/ 集合/ ./ 如/ PageRank/ 算法/ 中/ 迭代/ 数据/ 是/ 由/ 页面/ 和/ 页面/ 之间/ 的/ 链接/ 关系/ 所/ 组成/ 的/ 集合/ ./ 设/ 迭代/ 数据/ 符合/ 图/ 关系/ L/ ./ 在/ L/ 中/ 节点/ 的/ 集合/ 为/ V/ (/ L/ )/ ,/ 边/ 的/ 集合/ 为/ E/ (/ L/ )/ ,/ 其中/ E/ (/ L/ )/ 是/ 节点/ 所/ 组成/ 序偶/ 的/ 集合/ ./ 在/ L/ 中/ ,/ / u/ ,/ v/ ∈/ V/ (/ L/ )/ ,/ 如果/ u/ ,/ v/ 是/ 有/ 关系/ 的/ ,/ 则/ 有/ 〈/ u/ ,/ v/ 〉/ ∈/ E/ (/ L/ )/ ./ 图/ 关系/ Δ/ L/ 同理/ ./ 如图/ 1/ 所示/ ,/ 将/ 图/ L/ 和/ Δ/ L/ 使用/ 邻接矩阵/ 的/ 方式/ 表示/ ./ 在/ 图/ 1/ 中/ ,/ V/ (/ L/ )/ =/ {/ A/ ,/ B/ ,/ C/ ,/ D/ }/ ,/ V/ (/ Δ/ L/ )/ =/ {/ E/ ,/ F/ ,/ G/ }/ ./ 如果/ 任意/ 两个/ 节点/ 有/ 关系/ ,/ 则/ 在/ 矩阵/ 中/ 标识/ 为/ 1/ ,/ 否则/ 为/ 0/ ./ 矩阵/ 被/ 分为/ 4/ 个/ 区域/ ,/ 如图所示/ 编号/ 分别/ 是/ M1/ ,/ M2/ ,/ M3/ ,/ M4/ ./ 其中/ ,/ 原始数据/ L/ =/ M1/ ;/ 增量/ 数据/ Δ/ L/ =/ M2/ +/ M3/ +/ M4/ ;/ 全量/ 数据/ Δ/ L/ ∪/ L/ =/ M1/ +/ M2/ +/ M3/ +/ M4/ ;/ 定义/ 差集/ 数据/ (/ Δ/ L/ -/ L/ =/ M4/ )/ 为/ Δ/ L/ 的/ 与/ L/ 无关/ 的/ 最大/ 子图/ ;/ 定义/ 关联/ 数据/ (/ Δ/ L/ // L/ =/ M2/ +/ M3/ )/ 为/ Δ/ L/ 的/ 与/ L/ 关联/ 的/ 最大/ 子图/ ,/ Δ/ L/ =/ (/ Δ/ L/ -/ L/ )/ ∪/ (/ Δ/ L/ // L/ )/ ,/ 差集/ 数据/ 和/ 关联/ 数据/ 计算方法/ 如下/ :/ Δ/ L/ -/ L/ =/ 〈/ V/ (/ Δ/ L/ -/ L/ )/ ,/ E/ (/ Δ/ L/ -/ L/ )/ 〉/ ,/ V/ (/ Δ/ L/ -/ L/ )/ =/ V/ (/ Δ/ L/ )/ -/ V/ (/ L/ )/ ,/ E/ (/ Δ/ L/ -/ L/ )/ =/ {/ 〈/ u/ ,/ v/ 〉/ |/ 〈/ u/ ,/ v/ 〉/ ∈/ E/ (/ Δ/ L/ )/ ∧/ u/ ,/ v/ ∈/ V/ (/ Δ/ L/ -/ L/ )/ }/ (/ 5/ )/ Δ/ L/ // L/ =/ 〈/ V/ (/ Δ/ L/ // L/ )/ ,/ E/ (/ Δ/ L/ // L/ )/ 〉/ ,/ V/ (/ Δ/ L/ // L/ )/ =/ V/ (/ Δ/ L/ )/ ∩/ V/ (/ L/ )/ ∪/ {/ v/ |/ 〈/ u/ ,/ v/ 〉/ ∈/ E/ (/ Δ/ L/ )/ ∧/ u/ ∈/ V/ (/ Δ/ L/ )/ ∩/ V/ (/ L/ )/ }/ ,/ E/ (/ Δ/ L/ // L/ )/ =/ {/ 〈/ u/ ,/ v/ 〉/ |/ 〈/ u/ ,/ v/ 〉/ ∈/ E/ (/ Δ/ L/ )/ ∧/ u/ ,/ v/ ∈/ V/ (/ Δ/ L/ // L/ )/ }/ 本文/ 更多地/ 考虑/ 式/ (/ 5/ )/ 的/ 差集/ 计算/ ,/ 我们/ 称为/ 差集/ 算法/ ./ 在/ 图/ 1/ 中/ ,/ M1/ 和/ M4/ 是/ 相互/ 独立/ 的/ ,/ M4/ 是/ 增量/ 数据/ 中/ 与/ 原始数据/ 独立/ 的/ 部分/ ,/ 增量/ 迭代/ 分别/ 对/ M1/ 和/ M4/ 运行/ 迭代/ 算法/ ,/ 对应/ 式/ (/ 1/ )/ 和/ (/ 2/ )/ ./ 然而/ 还/ 需要/ 考虑/ 增量/ 数据/ 和/ 原始数据/ 的/ 关联/ 部分/ M2/ +/ M3/ ,/ 因此/ 需要/ 将/ M1/ 的/ 迭代/ 结果/ R/ 和/ M4/ 的/ 迭代/ 结果/ Δ/ R/ 合并/ ,/ 并/ 在/ 全量/ 数据/ 上/ 继续/ 迭代/ 直至/ 收敛/ ./ 3.3/ 迭代/ 函数/ 迭代/ 函数/ f/ 的/ 设计/ 取决于/ 迭代/ 算法/ ,/ 且/ f/ 需/ 满足/ 以下/ 条件/ :/ f/ 在/ 迭代/ 轮中/ 保持/ 不变/ ,/ 且/ 可以/ 分解/ 为/ 若干/ 变换/ 函数/ h/ 的/ 代数/ 运算/ ./ 针对/ 某/ 一个/ 迭代/ 变量/ xi/ ,/ 有形/ 如/ :/ f/ (/ xi/ ,/ L/ )/ =/ h1/ (/ x1/ ,/ L/ )/ / h2/ (/ x2/ ,/ L/ )/ / …/ / hn/ (/ xn/ ,/ L/ )/ (/ i/ ∈/ [/ 1/ ,/ n/ ]/ ,/ n/ 为/ 迭代/ 变量/ 个数/ )/ ,/ 其中/ / 为/ 代数/ 运算/ ,/ h/ 函数/ 是/ 某/ 迭代/ 变量/ 对/ 当前/ 迭代/ 变量/ 的/ 变换/ 函数/ ,/ h/ 函数/ 对/ / 运算/ 是/ 分布/ 的/ ,/ h/ (/ a/ / b/ )/ =/ h/ (/ a/ )/ / h/ (/ b/ )/ ./ 为/ 描述/ 简便/ ,/ 我们/ 将/ L/ 视为/ 常量/ ,/ 在/ f/ 函数/ 和/ h/ 函数/ 中/ 省略/ ./ 若仅/ 考察/ 一个/ 迭代/ 变量/ r/ 在/ 整个/ 迭代/ 过程/ 的/ 变化/ ,/ 在/ 一轮/ 迭代/ 中/ ,/ 该/ 迭代/ 变量/ 吸收/ 了/ 其他/ 迭代/ 变量/ 对/ 它/ 的/ 变换/ ,/ 将/ 这些/ 变换/ 聚集/ 起来/ 改变/ 自身/ ./ 如果/ 在/ 某轮/ 迭代/ 中/ 某/ 变量/ 由/ r0/ 变换/ 为/ r/ / ,/ 其他/ 变量/ 为/ r1/ 和/ r2/ ,/ 迭代/ 函数/ 为/ f/ ,/ 而/ 变换/ 函数/ 为/ h/ ,/ 聚集/ 运算/ 为/ / ,/ 那么/ 一轮/ 迭代/ 可以/ 表达/ 成/ r/ / =/ f/ (/ r0/ ,/ r1/ ,/ r2/ )/ =/ h/ (/ r0/ )/ / h/ (/ r1/ )/ / h/ (/ r2/ )/ ,/ 一个/ 变量/ 的/ 多轮/ 迭代/ 可以/ 看/ n/ 作/ ∑/ i/ =/ 1/ / h/ (/ ri/ )/ 递归/ 调用/ ./ 因此/ ,/ 有/ 如下/ 定义/ ./ 定义/ 4/ ./ 迭代/ 计算/ 的/ 分解/ 描述/ ./ 迭代/ 计算/ 可以/ 分解/ 为/ 每/ 一个/ 迭代/ 变量/ 的/ 变化/ ,/ 而/ 一个/ 迭代/ 变量/ 的/ 变化/ 可以/ 分解/ 为/ 该/ 变量/ 每/ 一轮/ 变化/ 的/ 积累/ ,/ 而/ 每/ 一轮/ 变化/ 的/ 积累/ 又/ 可以/ 分解/ 为/ 其他/ 变量/ 对/ 该/ 变量/ 的/ 变换/ 的/ 代数/ 聚集/ ./ 在/ 这种/ 分解/ 描述/ 下/ ,/ 某个/ 迭代/ 变量/ 的/ 收敛/ 条件/ 为/ 变化/ 为/ 零/ ,/ 整个/ 迭代/ 计算/ 的/ 收敛/ 条件/ 为/ 所有/ 的/ 迭代/ 变量/ 均/ 收敛/ ./ 为/ 描述/ 简单/ ,/ 令/ 迭代/ 变量/ 变化/ 为/ 零时/ 仍/ 可以/ 继续/ 迭代/ ,/ 以此/ 保证/ 所有/ 变量/ 同时/ 收敛/ ./ 定义/ 4/ 中/ ,/ “/ 变化/ ”/ 表示/ 某/ 迭代/ 变量/ 自身/ 的/ 改变/ ,/ 这种/ 改变/ 来源于/ 其他/ 迭代/ 变量/ 对/ 该/ 变量/ 的/ “/ 变换/ ”/ ,/ h/ 函数/ 则/ 为/ “/ 变换/ 函数/ ”/ ./ 对于/ 某/ 一轮/ 迭代/ ,/ 设由/ n/ 个/ 迭代/ 变量/ 所/ 组成/ 的/ 集合/ 为/ R/ =/ {/ r1/ ,/ r2/ ,/ …/ ,/ rn/ }/ ./ 其中/ 迭代/ 函数/ 为/ 可以/ 分解/ 为/ f1/ ,/ f2/ ,/ …/ ,/ fn/ ./ 迭代/ 变量/ ri/ 第/ k/ 轮/ (/ k/ 为/ 自然数/ )/ 迭代/ 可以/ 表示/ 为/ rk2/ ,/ …/ ,/ rk/ -/ 1rk/ -/ 1/ 式/ (/ 7/ )/ 形式/ :/ rkPage6/ 式/ (/ 7/ )/ 可以/ 解释/ 为/ 迭代/ 变量/ rki/ (/ rk/ -/ 1/ 量/ 对/ 其/ 的/ 变换/ ,/ 累积/ 这些/ 变换/ ,/ 并/ 变化/ 自身/ 值/ ./ 式/ (/ 7/ )/ 中/ 函数/ hj/ 的/ 初始值/ 为/ {/ r0/ 值/ ,/ 那么/ ,/ 当/ i/ ≠/ j/ 时/ hj/ 时/ ,/ hj/ 迭代/ 变量/ 变换/ 的/ 聚集/ 操作/ ,/ 例如/ 在/ PageRank/ 算法/ 中/ / 为/ 加法/ (/ +/ )/ ,/ K/ -/ means/ 算法/ 中/ / 为/ 集合/ 并/ (/ ∪/ )/ ./ 本文/ 提出/ 的/ DELTA/ 模型/ 要求/ 其/ 迭代/ 函数/ 能/ 按/ 定义/ 4/ 和/ 式/ (/ 5/ )/ 分解/ 描述/ ,/ 且/ / 为/ 代数/ 运算/ ,/ h/ 函数/ 对/ / 运算/ 是/ 分布/ 的/ ./ 3.4/ 理论/ 证明/ 本节/ 将/ 从/ 理论/ 上/ 证明/ DELTA/ 模型/ 在/ 性能/ 上/ 的/ 优势/ ,/ 并/ 证明/ 增量/ 迭代/ 和/ 全量/ 迭代/ 的/ 迭代/ 结果/ 是/ 一致/ 的/ ./ (/ 1/ )/ 性能/ 优势/ 证明/ 我们/ 首先/ 假设/ 迭代/ 算法/ 的/ 执行/ 时间/ 仅/ 与/ 迭代/ 数据/ 大小/ 有关/ ,/ 则/ 原始/ 迭代/ 的/ 执行/ 时间/ 为/ τ/ (/ |/ L/ |/ )/ ;/ 增量/ 迭代/ 的/ 执行/ 时间/ 为/ τ/ (/ |/ Δ/ L/ -/ L/ |/ )/ +/ τ/ (/ |/ Δ/ L/ ∪/ L/ |/ )/ ,/ 而/ 全量/ 迭代/ 的/ 执行/ 时间/ 为/ τ/ (/ |/ Δ/ L/ ∪/ L/ |/ )/ ,/ 显然/ 增量/ 迭代/ 的/ 性能/ 无法/ 优于/ 全量/ 迭代/ ./ 分析/ 知/ 迭代/ 算法/ 的/ 执行/ 时间/ 还/ 与/ 迭代/ 变量/ 初始值/ 和/ 迭代/ 数据/ 有关/ ./ 根据/ 定义/ 4/ ,/ 一个/ 迭代/ 轮/ 可以/ 分解/ “/ 迭代/ 变量/ 吸收/ 其他/ 迭代/ 变量/ 对/ 它/ 的/ 变换/ ,/ 将/ 这些/ 变换/ 聚集/ 起来/ 改变/ 自身/ ”/ 这一/ 过程/ ,/ 因此/ ,/ 若/ 迭代/ 变量/ 初始值/ 越/ 不合理/ ,/ 迭代/ 数据/ 越/ 紊乱/ ,/ 变量/ 间/ 相互/ 变换/ 越/ 多/ ,/ 迭代/ 轮数/ 越大/ ,/ 迭代/ 时间/ 越长/ ./ 增量/ 迭代/ 增量/ 步/ 增量/ 迭代/ 合并/ 步表/ 1/ 迭代/ 的/ 执行/ 定性/ 比较/ 迭代/ 轮数/ n0n1n2n3n2/ </ n0/ ≈/ n1/ ≈/ n3/ 进一步/ 分析/ 知/ ,/ 影响/ 增量/ 迭代/ 性能/ 优势/ 的/ 因素/ 有/ 两个/ :/ ①/ 增量/ 数据/ 更新/ 原始/ 迭代/ 结果/ 的/ 程度/ ,/ 称为/ 更新/ 度/ ./ 更新/ 度/ 影响/ 增量/ 迭代/ 性能/ 优化/ 效果/ ,/ 更新/ 度越/ 小/ ,/ 优化/ 效果/ 越/ 好/ ,/ 反之/ 则/ 反/ ./ 按/ h/ 函数/ 的/ 定义/ h/ (/ r/ ,/ L/ )/ (/ L/ 在/ 前文/ 公式/ 中/ 省略/ )/ ,/ 增量/ 数据/ 对/ 原始/ 迭代/ 结果/ 的/ 更新/ 程度/ 体现/ 在/ 两个/ 方面/ :/ 一是/ 增量/ 数据/ 中/ 的/ 迭代/ 变量/ 对/ 原始数据/ 中/ 的/ 迭代/ 变量/ 的/ 变换/ ,/ 即/ h/ 函数/ 的/ r/ 部分/ ;/ 二是/ 增量/ 数据/ 对/ 原始/ 迭代/ 结果/ 的/ 变换/ ,/ 即/ h/ 函数/ 的/ L/ 部分/ ;/ ②/ 原始数据/ 量/ 大小/ ,/ 由于/ 原始/ 迭代/ ,/ 增量/ 迭代/ 的/ 原始/ 步/ 、/ 增量/ 步/ 、/ 合并/ 步/ ,/ 以及/ 全量/ 迭代/ 都/ 是/ 迭代/ 计算/ ./ 对于/ 迭代/ 计算/ 的/ 性能/ ,/ 取决于/ 迭代/ 轮数/ 和/ 每轮/ 迭代/ 代价/ (/ I/ // O/ 代价/ 和/ 运算量/ )/ ./ 按/ 定义/ 4/ ,/ 我们/ 从/ “/ 迭代/ 轮数/ ”/ 和/ “/ 每轮/ 迭代/ 代价/ ”/ 两个/ 角度/ 定性分析/ 各种/ 迭代/ 方法/ 的/ 执行/ 时间/ ,/ 以/ 原始/ 迭代/ 执行/ 时间/ 为/ 参照/ ,/ 具体分析/ 如下/ :/ ①/ 对于/ 增量/ 迭代/ 的/ 增量/ 步/ ,/ Δ/ L/ -/ L/ 虽然/ 远/ 小于/ L/ ,/ 但/ Δ/ L/ -/ L/ 中/ 迭代/ 变量/ 尚未/ 吸收/ 其他/ 变量/ 对/ 它/ 的/ 变换/ ,/ 因此/ ,/ 增量/ 迭代/ 的/ 增量/ 步/ 迭代/ 轮数/ 与/ 原始/ 迭代/ 的/ 迭代/ 轮数/ 大体/ 相同/ ,/ α/ ≈/ β/ (/ 参见/ 式/ (/ 1/ )/ 和/ (/ 2/ )/ )/ ,/ 但是/ 由于/ 数据量/ 很小/ ,/ 因此/ 增量/ 迭代/ 的/ 增量/ 步/ 的/ 每轮/ 迭代/ 代价/ 要远/ 小于/ 原始/ 迭代/ 的/ 每轮/ 迭代/ 代价/ ,/ 进而/ 增量/ 迭代/ 的/ 增量/ 步/ 执行/ 时间/ 远/ 小于/ 原始/ 迭代/ 时间/ ;/ ②/ 对于/ 增量/ 迭代/ 的/ 合并/ 步/ ,/ 由于/ 迭代/ 数据/ 仅/ 需要/ 收集/ 关联/ 数据/ (/ Δ/ L/ // L/ )/ 对/ 其/ 变换/ ,/ 迭代/ 轮数/ 小于/ 原始/ 迭代/ ,/ γ/ </ α/ (/ 参见/ 式/ (/ 1/ )/ 和/ (/ 3/ )/ )/ ,/ 因此/ 增量/ 迭代/ 合并/ 步/ 迭代/ 时间/ 小于/ 原始/ 迭代/ 时间/ ;/ ③/ 对于/ 全量/ 迭代/ ,/ 由于/ Δ/ L/ -/ L/ 的/ 存在/ ,/ 全量/ 迭代/ 轮数/ 和/ 原始/ 迭代/ 轮数/ 大致相同/ ,/ 但是/ 由于/ 全量/ 数据/ 略大于/ 原始数据/ ,/ 全量/ 迭代/ 的/ 每轮/ 迭代/ 代价/ 略大于/ 增量/ 迭代/ 的/ 每轮/ 迭代/ 代价/ ,/ 因此/ 全量/ 迭代/ 的/ 迭代/ 时间/ 略大于/ 原始/ 迭代/ 的/ 迭代/ 时间/ ;/ 此外/ 还/ 考虑/ 一种/ 特例/ ,/ 增量/ 迭代/ 的/ 迭代/ 变量/ 初始值/ 是/ 原始/ 迭代/ 结果/ ,/ 当/ 迭代/ 算法/ 对/ 初始值/ 敏感/ 时/ ,/ 全量/ 迭代/ 性能/ 会/ 优于/ 原始/ 迭代/ 性能/ ./ 综上所述/ ,/ 增量/ 迭代/ 的/ 迭代/ 时间/ 小于/ 全量/ 迭代/ 的/ 迭代/ 时间/ ./ 表/ 1/ 定性/ 比较/ 了/ 3/ 种/ 迭代/ 的/ 迭代/ 轮数/ 、/ 每轮/ 执行/ 代价/ 和/ 执行/ 时间/ ./ 增量/ 迭代/ 的/ 增量/ 步/ 和/ 全量/ 迭代/ 的/ 迭代/ 轮数/ 相同/ ,/ 但/ 前者/ 是/ 在/ 小/ 数据/ 集上/ 执行/ ,/ 而/ 后者/ 在/ 大/ 数据/ 集上/ 执行/ ,/ 数据量/ 越大/ ,/ 每轮/ 迭代/ 代价/ 就/ 越/ 大/ ./ 全量/ 数据/ 由/ 增量/ 数据/ 和/ 原始数据/ 两/ 部分/ 组成/ ,/ 当/ 增量/ 数据/ 增加/ 时/ ,/ 增量/ 迭代/ 的/ 增量/ 步/ 每轮/ 迭代/ 代价/ 和/ 全量/ 迭代/ 每轮/ 迭代/ 代价/ 都/ 增加/ ,/ 因此/ 相互/ 抵消/ ;/ 当/ 原始数据/ 增加/ 时/ ,/ 增量/ 迭代/ 的/ 增量/ 步/ 每轮/ 迭代/ 代价/ 不变/ ,/ 全量/ 迭代/ 每轮/ 迭代/ 代价/ 增加/ ,/ 因此/ 增量/ 迭代/ 的/ 增量/ 步/ 优势/ 明显/ ,/ 增量/ 迭代/ 的/ 性能/ 优势/ 增大/ ./ Page7/ (/ 2/ )/ 迭代/ 结果/ 一致性/ 证明/ 我们/ 利用/ 定义/ 4/ 迭代/ 计算/ 的/ 分解/ 描述/ 来/ 证明/ 增量/ 迭代/ 和/ 全量/ 迭代/ 的/ 结果/ 一致性/ ,/ 证明/ 思路/ 如下/ :/ 根据/ 迭代/ 的/ 分解/ 表示/ ,/ 由于/ 该/ 迭代/ 变量/ 的/ 初始值/ 是/ 相同/ 的/ ,/ 若/ 证明/ 两种/ 方法/ 迭代/ 结果/ 一致/ ,/ 只要/ 证明/ 任意/ 一个/ 迭代/ 变量/ 在/ 两种/ 方法/ 的/ 所有/ 轮/ 迭代/ 中/ 积累/ (/ / )/ 的/ 变换/ 一致/ ./ 我们/ 可以/ 证明/ :/ ①/ 全量/ 迭代/ 中/ 某/ 迭代/ 变量/ 的/ 积累/ 变换/ 要/ 大于/ 该/ 变量/ 在/ 增量/ 迭代/ 的/ 原始/ 步中/ 的/ 积累/ 变换/ ;/ ②/ 当/ 增量/ 迭代/ 进入/ 合并/ 步/ ,/ 该/ 变量/ 的/ 积累/ 变换/ 逐渐/ 变/ 大/ ,/ 最终/ 会/ 等于/ 全量/ 迭代/ 中该/ 变量/ 的/ 积累/ 变换/ ./ 由/ ①/ 和/ ②/ 可知/ ,/ 采用/ 这/ 两种/ 方法/ 迭代/ ,/ 同一/ 迭代/ 变量/ 会/ 收敛/ 到/ 同一/ 状态/ ./ 在/ 证明/ 过程/ 中/ 增量/ 和/ 全量/ 迭代/ 采用/ 一致/ 的/ 序列/ {/ 1/ ,/ 2/ ,/ …/ ,/ k/ ,/ …/ ,/ n/ }/ 来/ 表示/ 每/ 一轮/ 迭代/ ./ 不失/ 一般性/ ,/ 设/ :/ ①/ 增量/ 迭代/ 和/ 全量/ 迭代/ 同时/ 开始/ ;/ ②/ 增量/ 迭代/ 的/ 原始/ 步/ 和/ 增量/ 步/ 同时/ 开始/ (/ 实际/ 原始/ 步/ 在/ 增量/ 数据/ 到来/ 时/ 已经/ 结束/ )/ ,/ 且/ 当/ 原始/ 步/ 和/ 增量/ 步/ 都/ 收敛/ 后/ 开始/ 合并/ 步/ ,/ 先/ 收敛/ 的/ 迭代/ 变量/ 则/ 执行/ 空轮/ ;/ ③/ 增量/ 迭代/ 原始/ 步/ 收敛/ 于/ k1/ 轮/ ;/ ④/ 增量/ 迭代/ 增量/ 步/ 收敛/ 于/ k2/ 轮/ ;/ ⑤/ 增量/ 迭代/ 合并/ 步/ 开始/ 于/ km/ +/ 1/ 轮/ ,/ 由于/ 无法/ 确定/ k1/ 和/ k2/ 的/ 大小/ ,/ 因此/ 令/ km/ =/ max/ (/ k1/ ,/ k2/ )/ ;/ ⑥/ k3/ 轮/ 是/ 增量/ 迭代/ 合并/ 步中/ 任意/ 一轮/ ,/ 以及/ 对应/ 的/ 全量/ 迭代/ 中/ 迭代/ 轮/ ,/ k3/ >/ km/ ./ k1/ >/ k2/ 时/ 迭代/ 计算/ 的/ 示意图/ 如图/ 2/ 所示/ ,/ 当/ k2/ >/ k1/ 时/ 同理/ ./ 证明/ ./ 若/ / 为/ 代数/ 运算/ ,/ h/ 函数/ 对/ / 运算/ 是/ 分布/ 的/ ,/ 则/ 增量/ 迭代/ 的/ 迭代/ 结果/ 等同/ 与/ 全量/ 迭代/ 的/ 迭代/ 结果/ ./ 因为/ h/ (/ a/ / b/ )/ =/ h/ (/ a/ )/ / h/ (/ b/ )/ 因为/ / 符合/ 交换律/ 、/ 结合律/ 和/ 零律/ ;/ 又/ 因为/ 参照/ 定义/ 4/ 和/ 式/ (/ 7/ )/ ,/ 迭代/ 变量/ ri/ 的/ 第/ k/ 轮/ 迭代/ 可以/ 表示/ 为式/ (/ 8/ )/ ./ rki/ =/ h1/ 所以/ 某一/ 迭代/ 变量/ ri/ 从/ 第/ 1/ 轮/ 迭代/ 至/ k/ 轮/ 的/ 值/ 如式/ (/ 9/ )/ ./ r1i/ =/ ∑/ r2i/ =/ ∑/ r3i/ =/ ∑/ =/ ∑/ …/ rki/ =/ ∑/ =/ H/ 式/ (/ 10/ )/ 中/ xk/ 表示/ 第/ k/ 轮/ 任意/ 一个/ 迭代/ 变量/ 的/ 下标/ ./ 符号/ H/ 表示/ 函数/ 的/ 复合/ ./ 第/ k/ 轮/ 的/ 迭代/ 中/ ,/ 任意/ 一个/ 迭代/ 变量/ 都/ 是/ k/ 轮/ 积累/ 变换/ 的/ 聚集/ ./ 设/ :/ 在/ 原始数据/ L/ 中/ 含有/ m/ 个/ 迭代/ 变量/ ,/ 全量/ 数据/ L/ ∪/ Δ/ L/ 中/ 含有/ n/ 个/ 迭代/ 变量/ ,/ 则/ 差集/ 数据/ Δ/ L/ -/ L/ 中/ 含有/ n/ -/ m/ 个/ 迭代/ 变量/ ./ k1/ ,/ k2/ ,/ k3/ 轮/ 的/ 关系/ 见图/ 2/ ,/ km/ =/ max/ (/ k1/ ,/ k2/ )/ ./ 所以/ 第/ k1/ 轮/ ,/ 全量/ 迭代/ 下/ L/ 中/ 的/ 任意/ 迭代/ 变量/ rp/ ,/ 式/ (/ 11/ )/ 成立/ ./ 因为/ 第/ k1/ 轮/ ,/ 增量/ 迭代/ 原始/ 步中/ L/ 内/ 与/ rp/ 所/ 对应/ 的/ 迭代/ 变量/ rq/ ,/ 式/ (/ 12/ )/ 成立/ ./ 又/ 因为/ n/ >/ m/ ,/ rp/ 每/ 一轮/ 积累/ 变换/ 大于/ 每/ 一轮/ rq/ 积累/ 变换/ ./ 所以/ r/ 又/ 因为/ L/ 中/ 与/ Δ/ L/ 完全/ 没有/ 关联/ 的/ 迭代/ 变量/ 其/ 变换/ 始终/ 为/ 0/ ,/ 即/ h/ =/ 0/ ,/ 所以/ / r/ 所以/ r/ 同理/ ,/ 第/ k2/ 轮/ ,/ 全量/ 迭代/ 下/ L/ 中/ 的/ 任意/ 迭代/ 变量/ rp/ 和/ 增量/ 迭代/ 增量/ 步下/ Δ/ L/ -/ L/ 中/ 与/ rp/ 所/ 对应/ 的/ 迭代/ 变量/ rq/ ,/ 由于/ n/ >/ n/ -/ m/ ,/ rp/ 每/ 一轮/ 积累/ 的/ 变换/ 大于/ 每/ 一轮/ rq/ 积累/ 的/ 变换/ ./ 所以/ r/ 结论/ ①/ ,/ 在/ 增量/ 迭代/ 合并/ 步/ 开始/ 之前/ ,/ r/ 所以/ 第/ k3/ 轮/ ,/ 全量/ 迭代/ 下/ L/ 中/ 的/ 任意/ 迭代/ 变量/ rp/ ,/ 式/ (/ 13/ )/ 成立/ ./ Page8/ 因为/ 1/ 至/ k3/ 轮/ 可以/ 分解/ 为/ 1/ 至/ km/ 轮/ 和/ km/ +/ 1/ 至/ k3/ 轮/ ,/ 且/ 迭代/ 变量/ 仍然/ 为/ n/ 个/ ./ 所以/ 式/ (/ 13/ )/ 可以/ 变换/ 为式/ (/ 14/ )/ k3p/ =/ Hrj/ =/ 1/ ∑/ 因为/ 式/ (/ 14/ )/ 的/ km/ +/ 1/ 至/ k3/ 轮/ (/ 后/ 项/ )/ ,/ 迭代/ 变量/ 的/ rp/ 积累/ 变换/ 又/ 来自/ 于/ 又/ 来自/ 于/ L/ 中/ m/ 个/ 迭代/ 变量/ 和/ Δ/ L/ 中/ n/ -/ m/ 个/ 迭代/ 变量/ ./ 所以/ 式/ (/ 14/ )/ 可以/ 变换/ 为式/ (/ 15/ )/ k3rp/ =/ H/ 式/ (/ 15/ )/ 中/ ,/ 第/ 1/ 行是/ 前/ km/ 轮/ 迭代/ 全量/ 数据/ 中/ 迭代/ 变量/ 对/ rp/ 的/ 积累/ 变换/ ;/ 第/ 2/ 行是/ km/ +/ 1/ 轮至/ k3/ 轮/ 迭代/ 原始数据/ L/ 中/ 迭代/ 变量/ 对/ rp/ 的/ 积累/ 变换/ ;/ 第/ 3/ 行是/ km/ +/ 1/ 轮至/ k3/ 轮/ 迭代/ 增量/ 数据/ Δ/ L/ 中/ 迭代/ 变量/ 对/ rp/ 的/ 积累/ 变换/ ./ 所以/ 第/ k3/ 轮/ ,/ 增量/ 迭代/ 下/ 合并/ 步中/ 与/ rp/ 所/ 对应/ 的/ 迭代/ 变量/ rq/ ,/ 若/ rq/ ∈/ L/ ,/ 则/ 式/ (/ 16/ )/ 成立/ ./ k3rq/ =/ H/ 式/ (/ 16/ )/ 中/ ,/ 第/ 1/ 行是/ 原始/ 步下/ L/ 中/ 各/ 迭代/ 变量/ 对/ rq/ 的/ 积累/ 变换/ ;/ 第/ 2/ 行/ 和/ 第/ 3/ 行是/ 合并/ 步下/ L/ 中/ 各/ 迭代/ 变量/ 对/ rq/ 的/ 积累/ 变换/ ,/ 其中/ 各/ 迭代/ 变量/ 的/ 积累/ 变换/ 又/ 来自/ 于/ L/ 中/ m/ 个/ 迭代/ 变量/ (/ 方/ 括弧/ 中/ 前项/ )/ 和/ Δ/ L/ 中/ n/ -/ m/ 个/ 迭代/ 变量/ (/ 方/ 括弧/ 中后/ 项/ )/ ;/ 第/ 4/ 行/ 和/ 第/ 5/ 行是/ 合并/ 步下/ Δ/ L/ 中/ 各/ 迭代/ 变量/ 对/ rq/ 的/ 积累/ 变换/ ,/ 其中/ 各/ 迭代/ 变量/ 的/ 积累/ 变换/ 又/ 来自/ 于/ Δ/ L/ 中/ n/ -/ m/ 个/ 迭代/ 变量/ (/ 方/ 括弧/ 中/ 前项/ )/ 和/ L/ 中/ m/ 个/ 迭代/ 变量/ (/ 方/ 括弧/ 中后/ 项/ )/ ./ 与/ 式/ (/ 15/ )/ 对比/ ,/ 根据/ 结论/ ①/ ,/ 式/ (/ 15/ )/ 第/ 1/ 行/ 小于/ 式/ (/ 16/ )/ 的/ 第/ 1/ 行/ ;/ 式/ (/ 15/ )/ 第/ 2/ 行/ 等于/ 式/ (/ 16/ )/ 第/ 2/ 行/ 中方/ 括弧/ 中/ 前项/ 部分/ ;/ 式/ (/ 15/ )/ 第/ 3/ 行/ 等于/ 式/ (/ 16/ )/ 第/ 3/ 行/ 中方/ 括弧/ 中/ 前项/ 部分/ ;/ 式/ (/ 16/ )/ 的/ 第/ 2/ 和/ 第/ 3/ 行比式/ (/ 15/ )/ 的/ 第/ 2/ 和/ 第/ 3/ 行均/ 多出/ 了/ 方/ 括弧/ 中后/ 项/ ./ 因此/ ,/ 当/ k3/ 足够/ 大时/ ,/ 式/ (/ 16/ )/ 的/ 值/ 大于/ 等于/ 式/ (/ 15/ )/ 的/ 值/ ./ 结论/ ②/ ,/ 增量/ 迭代/ 合并/ 步下/ ,/ r/ Δ/ L/ -/ L/ ,/ 结论/ ②/ 同理/ 可得/ ./ 所以/ 根据/ 结论/ ①/ 和/ 结论/ ②/ ,/ 在/ 合并/ 步/ 开始/ 后/ ,/ k3p/ 和/ rr/ 那么/ 最终/ 会/ 有/ r/ 终/ 收敛/ 到/ 同/ 一点/ ./ 所以/ 增量/ 迭代/ 的/ 迭代/ 结果/ 等同于/ 全量/ 迭代/ 的/ 迭代/ 结果/ ./ 3.5/ 差集/ 算法/ 根据/ 3.4/ 节/ 分析/ ,/ 增量/ 迭代/ 对比/ 全量/ 迭代/ 的/ 性能/ 优势/ 在于/ 增量/ 迭代/ 的/ 增量/ 步/ 的/ 每轮/ 迭代/ 代价/ 小/ ,/ 而/ 增量/ 迭代/ 的/ 合并/ 步/ 迭代/ 轮数/ 小/ ./ 此外/ ,/ 增量/ 迭代/ 需要/ 求取/ 增量/ 数据/ 和/ 原始数据/ 的/ 差集/ ,/ 差集/ 算法/ 也/ 会/ 引入/ 额外/ 的/ 时间/ 开销/ ./ 对于/ 迭代/ 数据结构/ 较为简单/ 的/ 迭代/ 算法/ 而言/ ,/ 差集/ 算法/ 并/ 不/ 复杂/ ./ 例如/ K/ -/ means/ 算法/ ,/ 所有/ 的/ 数据/ 均/ 为/ 记录/ 的/ 形式/ ,/ 记录/ 是/ 数据/ 点/ 的/ 名称/ 和/ 其/ 坐标/ 所/ 组成/ 的/ 序偶/ ./ 而/ 求取/ 差集/ 的/ 过程/ 则/ 看作/ 是/ 求取/ 在/ 增量/ 数据/ 中距离/ 当前/ 所有/ 中心点/ 最小/ 距离/ 超过/ 阈值/ 的/ 点/ 的/ 集合/ ./ 但是/ 对于/ 关系/ 较为/ 复杂/ 的/ 算法/ 而言/ ,/ 求取/ 的/ 差集/ 和/ 原始数据/ 集应/ 不/ 存在/ 公共/ 的/ 数据/ 和/ 关系/ ,/ 即/ 无论是/ 数据/ 还是/ 关系/ ,/ 差集/ 与/ 原始数据/ 集是/ 相互/ 独立/ 的/ ./ 例如/ PageRank/ 算法/ 中/ ,/ 数据/ 为/ 网页/ ,/ 关系/ 为/ 网页/ 间/ 的/ 连接/ 关系/ ,/ L/ ,/ Δ/ L/ 和/ Δ/ L/ -/ L/ 如图/ 3/ 所示/ ./ 图/ 3/ 中/ 节点/ 表示/ 网页/ ,/ 边/ 表示/ 网页/ 间/ 的/ 连接/ 关系/ ./ 当/ 数据/ 关系/ 较为/ 复杂/ 时候/ ,/ 差集/ 的/ 求取/ 将/ 变得复杂/ ,/ 在/ 本节/ 给出/ 一个/ 包含/ 二元关系/ 的/ 数据/ 集/ 的/ 差/ Page9/ 集/ 算法/ ./ 在/ 算法/ 1/ 中/ ,/ 使用/ 两个/ MapReduce/ 作业/ 完成/ 差集/ 运算/ ./ 算法/ 1/ ./ 差集/ 算法/ 输入/ :/ 〈/ α/ ,/ β/ 〉/ :/ 数据项/ 和/ 数据项/ 所/ 组成/ 的/ 关系/ ,/ 以/ Key/ -/ 输出/ :/ Reduce2/ 输出/ 结果/ :/ 〈/ α/ ,/ β/ 〉/ Map1/ 阶段/ :/ 1/ ./ Init/ β/ ./ Eand/ β/ ./ Δ/ // // 初始化/ 数据/ 的/ E/ 和/ Δ/ 属性/ 2/ ./ out/ ./ collect/ (/ α/ ,/ β/ )/ Reduce1/ 阶段/ :/ 1/ ./ original/ =/ false/ ,/ new/ =/ false/ ;/ 2/ ./ result/ =/ newList/ (/ )/ ;/ 3/ ./ Foreach/ β/ in/ β/ s/ // // 对于/ 同一个/ α/ 的/ 所有/ β/ 4/ ./ If/ β/ ./ E5/ ./ original/ =/ true6/ ./ ElseIf/ β/ ./ Δ/ // // 如果/ β/ 是/ 增量/ 数据/ 7/ ./ new/ =/ true8/ ./ result/ ./ add/ (/ β/ )/ 9/ ./ EndIf10/ ./ Iforiginalandnew11/ ./ Return/ ;/ 12/ ./ EndIf13/ ./ EndFor14/ ./ Foreach/ β/ inresult/ // // 对于/ 结果/ 集中/ 所有/ β/ 15/ ./ β/ ./ R/ =/ true/ ;/ 16/ ./ out/ ./ collect/ (/ α/ ,/ β/ )/ ;/ 17/ ./ EndForMap2/ 阶段/ :/ 1/ ./ out/ ./ collect/ (/ β/ ,/ α/ )/ // // 将/ α/ 和/ β/ 调换/ ,/ 输出/ 给/ Reduce2Reduce2/ 阶段/ :/ 1/ ./ Reduce2/ =/ Reduce1/ // // 重复/ 执行/ Reduce1/ 算法/ 1/ 的/ 核心思想/ 是/ 通过/ 过滤/ 数据项/ 的/ 方式/ ,/ 过滤/ 掉/ 数据/ 间/ 的/ 关系/ ./ 在/ Map1/ 中/ 按照/ 〈/ key/ ,/ value/ 〉/ 序列/ 正常/ 输出/ ,/ 在/ Reduce1/ 的/ values/ 中/ 如果/ 均/ 出现/ 了/ 原始数据/ 和/ 增量/ 数据/ 标记/ ,/ 则/ 表示/ 该/ 数据/ 点/ 重复/ 出现/ 在/ 了/ 两个/ 数据/ 集中/ ,/ 故/ 将/ 其/ 过滤/ 掉/ ./ 而/ Map2/ 将/ 〈/ key/ ,/ value/ 〉/ 序列/ 反向/ 输出/ ,/ 从而/ 使得/ Reduce2/ 过滤/ 掉/ 关联/ 数据/ Δ/ L/ // L/ ./ 3.6/ 模型/ 应用/ 迭代/ 算法/ 均/ 可/ 满足/ 定义/ 4/ 的/ 分解/ 描述/ ,/ 但/ 若/ 适用/ 于/ 本文/ 提出/ 的/ DELTA/ 模型/ ,/ 则/ 要求/ 迭代/ 函数/ f/ 满足/ 3.4/ 节/ 首段/ 的/ 描述/ ;/ 此外/ ,/ 根据/ 3.4/ 节/ 迭代/ 性能/ 定性分析/ ,/ 当/ 数据量/ 越大/ ,/ 或/ 增量/ 数据/ 对/ 原始/ 迭代/ 结果/ 的/ 更新/ 越/ 少/ ,/ 增量/ 迭代/ 较/ 全量/ 迭代/ 的/ 性能/ 优化/ 效果/ 越好/ ./ 在/ 前文/ 形式化/ 表达/ 的/ 基础/ 上/ ,/ 本/ 节/ 举例/ 描述/ 常用/ 的/ 迭代/ 算法/ PageRank/ 、/ K/ -/ means/ 和/ DescendantQuery/ 的/ DELTA/ 模型/ 实现/ ./ (/ 1/ )/ PageRank/ 算法/ PageRank/ 是/ Google/ 用来/ 标识/ 网页/ 等级/ (/ 重要性/ )/ 的/ 一种/ 方法/ ./ 设/ 网络/ 的/ 链接/ 关系/ 存于/ 集合/ 中/ ,/ 该/ 集合/ 每个/ 元素/ 是/ 二元/ 组/ 〈/ url/ _/ source/ ,/ url/ _/ dest/ 〉/ ,/ 表示/ 在/ URL/ 为/ url/ _/ source/ 的/ 页面/ 中/ ,/ 有/ 一个/ 指向/ url/ _/ dest/ 页面/ 的/ 超链接/ ./ 初始化/ 的/ 迭代/ 变量/ 集为/ R0/ ,/ 每个/ 迭代/ 变量/ u/ 为/ 二元/ 组/ 〈/ url/ ,/ rank/ 〉/ ,/ 表示/ 每个/ 页面/ 的/ URL/ 和/ 其/ PageRank/ 值/ ./ 若/ 原始数据/ L/ 中共/ 有/ n/ 个/ 页面/ ,/ 则/ 初始化/ 时/ R0/ 内/ 共有/ n/ 条/ 数据/ ./ PageRank/ 的/ 迭代/ 函数/ 为/ fp/ 如式/ (/ 17/ )/ 所示/ ./ 在/ 式/ (/ 17/ )/ 中/ u/ 指/ 任意/ url/ ,/ i/ ,/ j/ 均/ 为/ 页面/ 下标/ ,/ 其中/ B/ (/ ui/ )/ 为/ 指向/ ui/ 链接/ 的/ 页面/ 的/ 集合/ ,/ |/ B/ (/ ui/ )/ |/ 为/ 集合/ B/ (/ ui/ )/ 的/ 大小/ ,/ R/ (/ uj/ )/ 为/ uj/ 当前/ 的/ PageRank/ 值/ ,/ N/ 为/ 页面/ 总数/ ,/ q/ 为/ 阻尼/ 常数/ ,/ 取值/ 为/ 0.85/ ./ fp/ 的/ 终止/ 条件/ 为/ Ri/ 不/ 发生变化/ ,/ 或者/ Ri/ 和/ Ri/ +/ 1/ 的/ 差值/ 小于/ 某个/ 阈值/ ,/ 算法/ 收敛/ ,/ 通常/ 阈值/ 可以/ 取得/ 0.2/ ./ PageRank/ 算法/ 满足/ DELTA/ 模型/ :/ 当/ uj/ 有/ 指向/ ui/ 的/ 链接/ 时/ h/ 函数/ 为式/ (/ 18/ )/ ,/ 当/ uj/ 没有/ ui/ 的/ 链时/ h/ 为/ 0/ ;/ / 运算/ 为/ 加法/ 运算/ ,/ 表示/ PageRank/ 值/ 的/ 增长/ ,/ 满足/ 代数/ 运算/ 要求/ ;/ h/ 函数/ 在/ “/ +/ ”/ 运算/ 上/ 是/ 分布/ 的/ ,/ 及/ 每个/ 网页/ 对/ 目标/ 网页/ PageRank/ 值/ 的/ 贡献/ 之/ 和/ 等同于/ 网页/ 集对/ 目标/ 网页/ 的/ PageRank/ 值/ 的/ 贡献/ ;/ 采用/ 算法/ 1/ 可/ 与/ 求取/ Δ/ L/ -/ L/ ./ 按式/ (/ 18/ )/ ,/ R/ 和/ Δ/ R/ 中/ 分别/ 包含/ 了/ L/ 以及/ Δ/ L/ -/ L/ 内/ 所有/ 网页/ 的/ PageRank/ 值/ ,/ 显然/ R/ ∩/ Δ/ R/ =/ / ,/ 因为/ 在/ L/ 和/ Δ/ L/ -/ L/ 中/ 并/ 没有/ 公共/ 网页/ 存在/ ./ 若/ 简单/ 的/ 将/ R/ 和/ Δ/ R/ 合并/ ,/ 则/ 丢失/ 了/ 关联/ 数据/ 集/ Δ/ L/ // L/ 对/ PageRank/ 值/ 的/ 贡献/ ,/ 这/ 是因为/ 在/ 背景/ 数据/ Δ/ L/ 有/ 可能/ 包含/ 指向/ L/ 中/ 页面/ 的/ 超链接/ ,/ 但是/ 这些/ 链接/ 在/ Δ/ L/ -/ L/ 中/ 都/ 被/ 过滤/ 掉/ 了/ ./ R/ 和/ Δ/ R/ 分别/ 可以/ 看作/ 背景/ 数据/ L/ 和/ Δ/ L/ -/ L/ 的/ 局部/ 极值/ ,/ 因此/ 增量/ 迭代/ 的/ 合并/ 步/ 可以/ 看作/ 是/ 求/ 全局/ 极值/ 的/ 过程/ ,/ 所以/ 合并/ 步会/ 很快/ 收敛/ ./ (/ 2/ )/ K/ -/ means/ 算法/ K/ -/ means/ 算法/ 是/ 典型/ 的/ 基于/ 距离/ 的/ 聚类/ 算法/ ,/ 采用/ 距离/ 作为/ 相似性/ 的/ 评价/ 指标/ ,/ 即/ 认为/ 两个/ 对象/ Page10/ 的/ 距离/ 越近/ ,/ 其/ 相似/ 度/ 就/ 越/ 大/ ./ 设/ 所有/ 数据/ 经过/ 格式化/ 并/ 转化/ 为/ 坐标/ 的/ 形式/ ,/ 存于/ 集合/ P/ 中/ ,/ P/ 内/ 任意/ 元素/ p/ 是/ 元组/ 〈/ id/ ,/ x/ ,/ y/ 〉/ ,/ id/ 为/ 数据/ 的/ 唯一/ 标识/ ,/ x/ 和/ y/ 为/ 数据/ 经过/ 转换/ 后/ 的/ 坐标/ ./ 初始化/ 的/ 迭代/ 变量/ 为/ k/ 个/ 簇/ S0/ 集有/ 一个/ 中心点/ c/ ./ 通过/ 迭代/ 后/ 求得/ 最终/ 的/ 迭代/ 结果/ {/ S/ / 1/ ,/ S/ / K/ -/ means/ 的/ 迭代/ 函数/ fk/ 如式/ (/ 19/ )/ 所示/ ./ fk/ (/ Si/ ,/ P/ )/ =/ {/ p/ |/ p/ ∈/ P/ ,/ / Sj/ ∈/ R/ ,/ dis/ (/ p/ ,/ ci/ )/ / dis/ (/ p/ ,/ cj/ )/ }/ 在/ 式/ (/ 19/ )/ 中/ ,/ P/ 为/ 所有/ 数据/ 点/ 的/ 集合/ ,/ p/ 为/ 某/ 数据/ 点/ ,/ R/ 是/ 当前/ 迭代/ 结果/ ,/ 包含/ 了/ k/ 个/ 簇/ ,/ 第/ i/ 个/ 簇/ Si/ 的/ 中心点/ 为/ ci/ ,/ dis/ (/ p/ ,/ ci/ )/ 为/ p/ 和/ ci/ 间/ 的/ 距离/ ./ fk/ 的/ 终止/ 条件/ 为/ Si/ 不/ 发生变化/ ,/ 算法/ 收敛/ ./ K/ -/ means/ 算法/ 满足/ DELTA/ 模型/ :/ 对于/ 某轮迭/ i/ 发生/ 移动/ ,/ 对应/ 的/ h/ 为/ 0/ ,/ 当/ Ski/ 重新/ 计算/ ;/ / 运算/ 为/ 集合/ 并/ 运算/ ,/ 表示/ Sk/ 代/ ,/ 原/ 属于/ 簇/ Sk/ -/ 1/ 据点/ ,/ h/ 函数/ 如式/ (/ 20/ )/ 所示/ ,/ 若/ 簇/ Sk/ -/ 1/ 向/ 簇/ Sk/ 据/ Sk/ 充/ ,/ 满足/ 代数/ 运算/ 要求/ ;/ h/ 函数/ 在/ “/ ∪/ ”/ 运算/ 上/ 是/ 分布/ 的/ ,/ 及/ 每/ k/ -/ 1/ 轮/ 每个/ 簇/ 移动/ 到/ 某/ 簇/ 的/ 数据/ 点/ 等同于/ 所有/ 数据/ 点/ 集合/ 移动/ 到/ 该/ 簇/ 的/ 数据/ 点/ ;/ 采用/ 算法/ 1/ 可以/ 求取/ Δ/ L/ -/ L/ ./ i/ (/ Sk/ -/ 1hj/ {/ p/ |/ p/ ∈/ Sk/ -/ 1j/ )/ =/ ∑/ p/ ∈/ Scki/ =/ K/ -/ means/ 算法/ 的/ 增量/ 迭代/ 实现/ 中/ :/ 原始/ 步/ 在/ 原始数据/ 集/ L/ 中/ 初始化/ k/ 个/ 中心点/ 并/ 获得/ k/ 个/ 簇/ ;/ 定义/ 差集/ 为/ 在/ 增量/ 数据/ 中距离/ 这/ k/ 个/ 簇/ 的/ 中心点/ 最小/ 距离/ 均/ 大于/ 某一/ 阈值/ 的/ 数据/ 点/ ;/ 增量/ 步/ 在/ 差集/ 数据/ Δ/ L/ -/ L/ 中/ 初始化/ k/ 个/ 中心点/ 并/ 获得/ k/ 个/ 簇/ (/ k/ / k/ )/ ;/ 合并/ 步/ 之前/ 将/ L/ 中/ k/ 个/ 中心点/ 和/ 差集/ 数据/ Δ/ L/ -/ L/ 中/ k/ 个/ 中心点/ 视为/ 数据/ 点/ ,/ 执行/ 一次/ 微缩/ 的/ K/ -/ means/ 算法/ 并/ 获取/ k/ 个/ 新/ 的/ 中心点/ ;/ 合并/ 步/ 将/ 采用/ 这/ k/ 个/ 新/ 的/ 中心点/ 重新/ 迭代/ ./ R/ 和/ Δ/ R/ 分别/ 可以/ 看作/ 背景/ 数据/ L/ 和/ Δ/ L/ -/ L/ 的/ 预先/ 聚类/ ,/ 因此/ 增量/ 迭代/ 的/ 合并/ 步/ 可以/ 看作/ 是/ 初始/ 点/ 良好/ 的/ 聚类/ 过程/ ,/ 所以/ 合并/ 步会/ 很快/ 收敛/ ./ (/ 3/ )/ DescendantQuery/ 算法/ DescendantQuery/ 算法/ 用于/ 计算/ 社交/ 网络/ 中/ 与/ 某人/ 相识/ 的/ 所有人/ 的/ 列表/ ,/ 用以/ 分析/ 用户/ 的/ 交友/ 信息/ 等/ 情况/ ./ 设/ 社交/ 网络/ 信息/ 存于/ 集合/ F/ 中/ ,/ F/ 即为/ 迭代/ 数据/ ,/ F/ 中/ 每个/ 元素/ 为序/ 偶/ 〈/ px/ ,/ py/ 〉/ ,/ px/ 和/ py/ 均/ 为/ 人名/ ,/ 表示/ 名字/ 为/ px/ 的/ 人/ 与/ 名字/ 为/ py/ 的/ 人/ 是/ 朋友/ 关系/ ./ 迭代/ 变量/ 为/ 集合/ R/ ,/ 初始/ R/ 仅/ 包含/ 一条/ 数据/ ,/ 即/ 查询/ 对象/ ./ 通过/ 迭代/ 计算/ 找出/ 与/ 查询/ 对象/ 相关/ 的/ 所有人/ ./ DescendantQuery/ 的/ 迭代/ 函数/ 为/ fd/ 如式/ (/ 21/ )/ 所示/ ./ fd/ (/ R/ )/ =/ R/ ∪/ {/ py/ |/ / 〈/ px/ ,/ py/ 〉/ ∈/ F/ ,/ px/ ∈/ R/ }/ (/ 21/ )/ 在/ 式/ (/ 21/ )/ 中/ R/ 是/ 唯一/ 的/ 迭代/ 变量/ ,/ fd/ 的/ 终止/ 条件/ 为/ R/ 不/ 发生变化/ ./ DescendantQuery/ 算法/ 满足/ DELTA/ 模型/ :/ 当/ R/ 和/ 对/ R/ 自身/ 的/ h/ 函数/ 为式/ (/ 22/ )/ ;/ / 运算/ 为/ 集合/ 并/ 运算/ ,/ 表示/ R/ 的/ 扩充/ ,/ 满足/ 代数/ 运算/ 要求/ ;/ h/ 函数/ 在/ “/ ∪/ ”/ 运算/ 上/ 是/ 分布/ 的/ ,/ h/ (/ R/ / / )/ =/ h/ (/ R/ )/ / h/ (/ / )/ =/ h/ (/ R/ )/ ./ h/ (/ Rk/ -/ 1/ )/ =/ {/ py/ |/ / 〈/ px/ ,/ py/ 〉/ ∈/ F/ ,/ px/ ∈/ Rk/ -/ 1/ }/ (/ 22/ )/ DescendantQuery/ 算法/ 的/ 特点/ 导致/ 其/ 增量/ 迭代/ 和/ 全量/ 迭代/ 相同/ ,/ 但/ 前者/ 有/ 略微/ 的/ 优势/ ./ 全量/ 迭代/ 会以/ 原始/ 迭代/ 结果/ 作为/ 初始/ 迭代/ 变量/ ,/ 在/ 全量/ 数据/ 上/ 迭代/ ./ 增量/ 迭代/ 实现/ 中/ :/ 原始/ 步/ 在/ 原始数据/ 集/ L/ 查找/ 与/ 当前/ 查询/ 对象/ 有/ 关系/ 的/ 所有人/ ,/ 最终/ 迭代/ 结果/ 集为/ R/ ;/ 定义/ 差集/ 为/ 在/ 增量/ 数据/ 中/ 与/ 原始/ 对象/ 中/ 所有/ 人均/ 没有/ 关系/ 的/ 人/ ,/ 根据/ 算法/ (/ 1/ )/ 可以/ 求得/ Δ/ L/ -/ L/ ,/ 根据/ 该/ 差集/ 定义/ 可以/ 知道/ Δ/ R/ =/ / ,/ 无须/ 增量/ 步/ 迭代/ ;/ 合并/ 步以/ R/ 为/ 初始/ 迭代/ 变量/ ,/ 只/ 需/ 在/ 原始数据/ 集/ 和/ 关联/ 数据/ 上/ 迭代/ ,/ 最终/ 当/ 收敛/ 后/ 得到/ 新/ 的/ 迭代/ 结果/ ./ 增量/ 迭代/ 合并/ 步/ 数据量/ 少于/ 全量/ 迭代/ 数据量/ ,/ 因此/ 增量/ 迭代/ 合并/ 步/ 每轮/ 迭代/ 代价/ 小于/ 全量/ 迭代/ 每轮/ 迭代/ 代价/ ,/ 又/ 因为/ 两者/ 迭代/ 轮数/ 相同/ ,/ 因此/ ,/ DescendantQuery/ 算法/ 增量/ 迭代/ 性能/ 略/ 优于/ 全量/ 迭代/ ./ 4/ 增量/ 迭代/ 计算/ 框架/ 我们/ 对/ HaLoop/ 框架/ 进行/ 修改/ 和/ 扩展/ ,/ 使/ 其/ 支持/ DELTA/ 模型/ ,/ 称为/ Δ/ HaLoop/ 框架/ ./ 本/ 小节/ 将/ 简述/ Δ/ HaLoop/ 框架/ 的/ 系统/ 架构/ ,/ 介绍/ 各个/ 部分/ 的/ 用途/ 和/ 相应/ 的/ 改进/ ./ 我们/ 选择/ Hadoop/ -/ 0.20/ ./ 2/ 版本/ 实现/ Δ/ HaLoop/ ,/ 在/ 该/ 版本/ 仅/ 包含/ 3/ 个/ 模块/ ,/ 即/ MapReduce/ 、/ HDFS/ 和/ Common/ ,/ 代码/ 结构/ 较为简单/ ,/ 且/ 易于/ 扩展/ ./ Δ/ HaLoop/ 系统/ 架构/ 如图/ 4/ 所示/ ./ 图/ 3/ 中/ 的/ 软件/ 模块/ 可以/ 分为/ 4/ 类/ :/ ①/ Hadoop/ 模块/ ,/ 这些/ 模块/ 是/ 与/ HDFS/ 相关/ 的/ 文件系统/ 模块/ 以及/ 任务/ 队列/ 模块/ ;/ ②/ HaLoop/ 模块/ ,/ 这些/ 模块/ 是/ HaLoop/ 对/ 原始/ HadoopPage11/ 图/ 4/ Δ/ HaLoop/ 系统/ 架构图/ 的/ 修改/ 或者/ 扩展/ 部分/ ,/ 主要/ 实现/ 了/ 迭代/ 计算/ 、/ 缓存/ 、/ 任务调度/ 等/ 相关/ 功能/ ;/ ③/ 本文/ 对/ HaLoop/ 的/ 修改/ 模块/ ,/ 这些/ 模块/ 根据/ DELTA/ 模型/ 和/ HaLoop/ 现存/ 缺陷/ ,/ 对/ HaLoop/ 模块/ 进行/ 了/ 修改/ ,/ 主要/ 包括/ LoopControl/ (/ 迭代/ 控制/ )/ 和/ TaskTracker/ 模块/ ;/ ④/ Δ/ HaLoop/ 新增/ 模块/ ,/ 用于/ 支持/ DELTA/ 模型/ ./ Δ/ HaLoop/ 各个/ 模块/ 的/ 简要/ 描述/ 如下/ :/ (/ 1/ )/ FileSystem/ ./ 沿用/ Hadoop/ 的/ 文件系统/ ,/ 支持/ 计算/ 框架/ 对/ 分布式文件系统/ 以及/ 每个/ 节点/ 的/ 本地/ 文件系统/ 的/ 读写操作/ ./ (/ 2/ )/ Cache/ ./ HaLoop/ 支持/ 迭代/ 计算/ 中/ 的/ 缓存/ 策略/ ,/ 并/ 设计/ 了/ 3/ 种/ 缓存/ ,/ 分别/ 为/ Map/ 输入/ 缓存/ 、/ Reduce/ 输入/ 缓存/ 、/ Reduce/ 输出/ 缓存/ ./ 在/ DELTA/ 模型/ 中/ ,/ 缓存/ 信息/ 不仅/ 有益于/ 原始/ 迭代/ ,/ 也/ 有益于/ 增量/ 迭代/ 的/ 差集/ 求取/ 和/ 结果/ 合并/ 过程/ ,/ 且/ 在/ 下/ 一次/ 增量/ 数据/ 到来/ 时/ ,/ 上/ 一次/ 迭代/ 的/ 缓存/ 仍/ 有效/ ,/ 因此/ Δ/ HaLoop/ 新增/ 了/ CacheUpdater/ 模块/ 用于/ 支持/ 在/ 增量/ 迭代/ 中/ 更新/ 缓存/ ,/ 尽量/ 延长/ 缓存/ 的/ 生命周期/ ./ (/ 3/ )/ TaskScheduler/ ./ 沿用/ HaLoop/ 系统/ 任务调度/ 功能/ ,/ 任务调度/ 支持/ 迭代/ 缓存/ 功能/ ./ 为了/ 使用/ 上/ 一轮/ 迭代/ 的/ 缓存数据/ ,/ 任务调度/ 器/ 将/ 当前/ 迭代/ 轮中/ 任务/ 数据/ 调度/ 到/ 上/ 一轮/ 迭代/ 计算/ 所在/ 的/ 节点/ ,/ 以便/ 读取/ 上/ 一轮/ 迭代/ 所/ 缓存/ 的/ 数据/ ,/ 从而/ 解决/ 静态数据/ 的/ 冗余/ 传输/ 问题/ 和/ 重复/ 计算/ 问题/ ./ (/ 4/ )/ TaskTracker/ ./ TaskTracker/ 监督/ 并/ 执行/ 某个/ 任务/ (/ MapTask/ 或/ ReduceTask/ )/ ,/ 同时/ 与/ JobTracker/ 通信/ ,/ 时刻/ 汇报/ 任务/ 的/ 执行/ 情况/ ,/ 并/ 获取/ 新/ 任务/ ./ 在/ HaLoop/ 中/ ,/ TaskTracker/ 根据/ 任务/ 配置/ 创建/ 缓存数据/ 和/ 索引/ ,/ 同时/ 维护/ 缓存数据/ ./ 在/ Δ/ HaLoop/ 中/ 对/ TaskTracker/ 进一步/ 进行/ 了/ 完善/ ,/ 加强/ 了/ TaskTracker/ 缓存数据/ 的/ 能力/ ,/ 使得/ 缓存数据/ 的/ 管理/ 粒度/ 更/ 细致/ ,/ 生命周期/ 更长/ ,/ 适用/ 于/ DELTA/ 模型/ 的/ 要求/ ./ (/ 5/ )/ LoopControl/ ./ 提供/ 迭代/ 控制/ 功能/ ,/ 使得/ 整个/ 迭代/ 算法/ 可以/ 重复/ 地/ 执行/ 直至/ 收敛/ ./ 在/ Δ/ HaLoop/ 系统/ 中/ 对/ HaLoop/ 原有/ 的/ LoopControl/ 功能/ 进行/ 扩展/ ,/ 支持/ “/ 针对/ 于/ 每轮/ 迭代/ 输出/ 数据/ 特点/ ”/ 的/ 迭代/ 收敛/ 条件/ ./ (/ 6/ )/ IncrementalIterativeControl/ ./ 提供/ 增量/ 迭代/ 支持/ ,/ 包括/ 基本/ 的/ 编程/ 接口/ 、/ 执行/ 流程/ 、/ 差集/ 算法/ 、/ 增量/ 迭代/ 流程/ 控制/ 等/ ./ 其中/ :/ ①/ 增量/ 输入/ 模块/ 用以/ 区分/ 增量/ 数据/ ,/ 完成/ 增量/ 输入/ 和/ 原始数据/ 差集/ 的/ 计算/ 过程/ ./ 同时/ 增量/ 输入/ 模块/ 还/ 对/ 当前/ 节点/ 所/ 包含/ 的/ 缓存/ 信息/ 进行/ 扫描/ ,/ 如果/ 可用/ 缓存数据/ ,/ 则/ 使用/ 缓存数据/ 进行/ 求差/ 集/ 操作/ ;/ ②/ 增量/ 控制/ 模块/ 是/ Δ/ HaLoop/ 为了/ 支持/ 增量/ 迭代/ 所/ 引入/ 的/ 独立/ 模块/ ,/ 模块/ 又/ 可以/ 分为/ MapReduce/ 作业/ 的/ 创建/ 和/ 增量/ 迭代/ 的/ 流程/ 控制/ 两个/ 子/ 模块/ ./ 前者/ 完成/ 增量/ 迭代/ 的/ 参数/ 初始化/ 工作/ ,/ 后者/ 则/ 按/ 第/ 3/ 节/ 描述/ 的/ 模型/ 和/ 方法/ 执行/ 迭代/ 算法/ ./ 理论/ 上/ ,/ 本文/ 所/ 提出/ 的/ DELTA/ 模型/ 适用/ 于/ 其他/ 大/ 数据/ 下/ 的/ 计算/ 框架/ ,/ 如/ Spark/ 、/ Naiad/ 等/ ./ 由于/ 本/ 研究/ 没有/ 逐一/ 在/ 这些/ 框架/ 中/ 实现/ DELTA/ 模型/ ,/ 因此/ 本节/ 以/ Spark/ 为例/ 给出/ 实现/ 方法/ 的/ 分析/ ./ 首先/ ,/ 我们/ 将/ DELTA/ 模型/ 的/ 实现/ 划分/ 为/ 3/ 个/ 不同/ 的/ 任务/ ,/ 包括/ 计算/ 差集/ (/ 数据/ 筛选/ )/ 、/ 增量/ 迭代/ (/ 在/ 差集/ 上/ 运行/ Page12/ 迭代/ 算法/ )/ 和/ 迭代/ 合并/ (/ 在/ 全量/ 数据/ 上/ 运行/ 迭代/ 算法/ )/ ./ 计算/ 差集/ 的/ 本质/ 为/ 数据/ 筛选/ 的/ 过程/ ,/ 主要/ 用于/ 删除/ 增量/ 数据/ 和/ 原始数据/ 间/ 的/ 关系/ ,/ 本文/ 所/ 提出/ 的/ 差集/ 算法/ 基于/ 数据/ 连接/ 技术/ ,/ 连接/ 算法/ 也/ 是/ 计算/ 框架/ 中/ 常见/ 算法/ ./ 如/ Spark/ 可以/ 通过/ Map/ 和/ Broadcast/ 的/ 组合/ 实现/ Map/ 端/ 连接/ 算法/ ,/ 也/ 可以/ 通过/ Join/ 算子/ 实现/ Reduce/ 端/ 连接/ 算法/ ./ 增量/ 迭代/ 和/ 迭代/ 合并/ 实质/ 上/ 都/ 是/ 迭代/ 算法/ 的/ 实例/ ./ 现存/ 迭代/ 框架/ 均/ 可以/ 支持/ 迭代/ 算法/ ,/ 只是/ 性能/ 有所/ 差别/ ./ 如/ MapReduce/ 可以/ 通过/ 任务/ 的/ 组合/ ,/ 将/ 迭代/ 算法/ 的/ 迭代/ 步骤/ 拆/ 分成/ 不同/ 的/ Map/ 任务/ 和/ Reduce/ 任务/ ,/ 从而/ 执行/ 迭代/ 算法/ ;/ Spark/ 中/ 可以/ 通过/ 使用/ RDD/ (/ ResilientDistributedDataset/ )/ 的/ 不断/ 变化/ 来/ 实现/ 迭代/ 算法/ ./ 增量/ 迭代/ 和/ 迭代/ 合并/ 区别/ 在于/ 以下/ 两点/ :/ (/ 1/ )/ 增量/ 迭代/ 的/ 数据/ 来源于/ 计算/ 差集/ 步骤/ 所/ 得到/ 的/ 差集/ ,/ 迭代/ 合并/ 的/ 数据/ 为/ 全量/ 数据/ ;/ (/ 2/ )/ 增量/ 迭代/ 的/ 初始/ 点为/ 随机/ 值/ 或/ 符合/ 迭代/ 算法/ 要求/ 初始值/ ,/ 迭代/ 合并/ 的/ 初始/ 点/ 来源于/ 原始/ 的/ 迭代/ 结果/ 和/ 增量/ 迭代/ 的/ 迭代/ 结果/ ./ 能够/ 支持/ 迭代/ 计算/ 的/ 框架/ 均/ 可以/ 灵活/ 的/ 控制/ 迭代/ 数据/ 范围/ 和/ 迭代/ 初始/ 点/ 的/ 选择/ ./ 综上所述/ ,/ DELTA/ 模型/ 适用/ 于/ 常见/ 的/ 分布式计算/ 框架/ ,/ 但/ 仍然/ 需要/ 对/ 框架/ 的/ 部分/ 模块/ 加以/ 扩展/ ./ 表/ 2/ 分析/ 了/ 常见/ 的/ 分布式计算/ 框架/ 实现/ DELTA/ 而/ 需要/ 的/ 扩展/ ./ 表/ 2/ 常见/ 分布式计算/ 框架/ 实现/ DELTA/ 模型/ 的/ 分析/ 框架/ 名称/ YarnSparkPrIterTwister/ 重新/ 定义/ 主/ 节点/ 的/ 流程/ 控制/ 和/ 任务调度/ ,/ 将/ 多个/ MapReduce/ 任务/ 视为/ 一个/ 整体/ ,/ 实现/ 增量/ 迭代/ 流程/ 控制/ 功能/ ./ 增加/ 增量/ 迭代/ 流程/ 控制/ 模块/ ,/ 以/ 控制/ 计算/ 差集/ 、/ 增量/ 迭代/ 和/ 迭代/ 合并/ 任务/ 中/ 的/ 执行/ 顺序/ 切换/ ./ 5/ 实验/ 分析/ 本节/ 对/ Δ/ HaLoop/ 框架/ 进行/ 测试/ 和/ 评价/ ,/ 以/ 证明/ 本文/ 提出/ 的/ DELTA/ 模型/ 的/ 正确性/ ./ 本节/ 首先/ 描述/ 了/ 实验/ 的/ 测试环境/ 以及/ 测试用例/ ./ 随后/ 验证/ 了/ PageRank/ 和/ K/ -/ means/ 两种/ 算法/ 的/ DELTA/ 模型/ 的/ 正确性/ 和/ 性能/ 优势/ ,/ 并/ 加以分析/ ./ 5.1/ 实验/ 环境/ 我们/ 在/ 真实/ 的/ 集群/ 环境/ 中/ 对/ Δ/ HaLoop/ 进行/ 测试/ ,/ 实验/ 集群/ 由/ 同构/ 的/ 13/ 台/ PC机/ 所/ 组成/ ,/ 具体/ 的/ 实验/ 环境/ 如表/ 3/ 所示/ ./ 项/ 集群/ 操作系统/ CentOS6/ ./ 3/ ,/ Linux2/ ./ 6.32/ 节点/ 平台/ 版本/ 基于/ HaLoop/ -/ 1.0/ JVM/ 版本/ Java7/ -/ updated/ -/ u9/ 网络带宽/ 1000Mbps/ 开发/ IDEEclipse4/ ./ 2/ 由于/ Δ/ HaLoop/ 基于/ HaLoop/ 实现/ ,/ 而/ HaLoop/ 是/ 基于/ Hadoop/ -/ 0.20/ ./ 2/ 版本/ 实现/ ./ 所以/ 在/ Δ/ HaLoop/ 运行/ 过程/ 中/ ,/ 其/ 运行/ 参数/ 与/ Hadoop/ -/ 0.20/ ./ 2/ 版本/ 是/ 一致/ 的/ ./ 表/ 4/ 列出/ 部分/ 参数/ ./ HDFSblocksizeHadoopinternalmemory4GBHadoop/ 运行/ 过程/ 中/ 可用内存/ NumberofmapslotNumberofreduceslot2/ 单一/ 节点/ Reduce/ 的/ 任务/ 最大/ 数量/ Heartbeatinterval5/ ./ 2/ 测试用例/ 为/ 简化/ 描述/ ,/ 本/ 节/ 使用/ Si/ (/ i/ ∈/ {/ 1/ ,/ 2/ ,/ 3/ }/ )/ 表示/ 数据/ 集/ 的/ 大小/ ,/ Uj/ (/ j/ ∈/ {/ 1/ ,/ 2/ ,/ 3/ ,/ 4/ }/ )/ 表示/ 增量/ 数据/ 对/ 原始/ 迭代/ 结果/ 的/ 更新/ 度/ ,/ 则/ Si/ 和/ Uj/ 可以/ 组合成/ 多组/ 实验/ 数据/ ./ 我们/ 用/ T1/ (/ SiUj/ )/ 表示/ 原始/ 迭代/ 时间/ ,/ T2/ (/ SiUj/ )/ 表示/ 增量/ 迭代/ 时间/ ,/ T3/ (/ SiUj/ )/ 表示/ 全量/ 迭代/ 时间/ ./ 为了/ 探究/ 增量/ 迭代/ 的/ 性能/ ,/ 将/ 使用/ [/ T3/ (/ SiUj/ )/ -/ T2/ (/ SiUj/ )/ ]/ // T3/ (/ SiUj/ )/ 作为/ 增量/ 迭代/ 优化/ 程度/ 的/ 度量/ ,/ 记/ 作/ 函数/ ω/ (/ SiUj/ )/ ./ PageRank/ 测试数据/ 集/ 采用/ 文献/ [/ 17/ ]/ 的/ 数据/ 集/ ./ 数据/ 集中/ 节点/ 的/ 入度/ 服从/ 对数/ 正态分布/ (/ μ/ =/ -/ 0.5/ ,/ σ/ =/ 2.3/ )/ ,/ 其中/ 参数/ 来自/ 于/ 真实/ 图/ 数据/ 集/ ①/ ./ 设/ 增量/ 数据/ 对/ 原始数据/ 迭代/ 结果/ 的/ 更新/ 程度/ 为/ U/ ./ 在/ 增量/ 数据/ 生成/ 过程/ 中/ ,/ 增量/ 数据/ 中/ 网页/ 链接/ 原始数据/ 中/ 网页/ 的/ 概率/ 为/ U/ ,/ 链接/ 增量/ 数据/ 中/ 网页/ 的/ 概率/ 为/ 1/ -/ U/ ./ PageRank/ 测试数据/ 的/ 相关/ 信息/ 如表/ 5/ 所示/ ./ ①/ http/ :/ // // snap/ ./ stanford/ ./ edu/ // dataPage13/ 名称/ S1U3S2U3S3U3S3U1S3U2S3U4K/ -/ means/ 数据/ 集/ 采用/ DBPedia/ 数据/ 集/ ①/ ./ 从/ DBPedia/ 数据/ 集中/ 抽取/ 其中/ 经度/ 和/ 维度/ 字/ 段/ 组成/ 了/ K/ -/ means/ 基础/ 数据/ 集/ (/ 20MB/ )/ ,/ 并/ 通过/ 随机/ 抽取/ 的/ 方式/ ,/ 将/ 其/ 分解成/ K/ -/ means/ 种子/ 数据/ 集/ (/ 18MB/ )/ 和/ K/ -/ means/ 增量/ 数据/ 集/ (/ 2MB/ )/ ,/ 以上/ 两个/ 数据/ 分别/ 用于/ 生成/ K/ -/ means/ 测试/ 中/ 的/ 原始数据/ 和/ 增量/ 数据/ ./ 为/ 适应/ 大/ 数据/ ,/ 在/ 数据/ 生成/ 过程/ 中/ ,/ 遵循/ 文献/ [/ 29/ ]/ 中/ 数据/ 模拟/ 方法/ ,/ 在/ 基础/ 数据/ 集点/ 周围/ 生成/ 多倍/ 的/ 额外/ 数据/ 点来/ 扩展/ 数据/ 集/ ,/ 其/ 扩展/ 倍数/ 根据/ K/ -/ means/ 测试用例/ 选取/ ./ 设/ 增量/ 数据/ 对/ 原始数据/ 迭代/ 结果/ 的/ 更新/ 程度/ 为/ U/ ./ 由于/ K/ -/ means/ 将/ 数据/ 点/ 分为/ k/ 簇/ ,/ 新增/ 数据/ 若/ 能够/ 归入/ 到/ 原始/ k/ 簇/ ,/ 则/ 更新/ 度/ 小/ ,/ 新增/ 数据/ 全部/ 无法/ 归入/ 到/ 原始/ k/ 簇而/ 需要/ 对/ 原始/ 簇/ 改变/ ,/ 则/ 更新/ 度大/ ./ 数据/ 生成/ 时/ ,/ 设/ 原始数据/ 的/ 值域/ 为/ [/ α/ ,/ β/ ]/ ,/ 在/ 增量/ 数据/ 生成/ 过程/ 中/ ,/ 增量/ 数据/ 中/ 的/ 数据/ 点/ 值域/ 在/ [/ α/ ,/ β/ ]/ 的/ 概率/ 为/ U/ ,/ 在/ [/ α/ +/ 102/ ,/ β/ +/ 102/ ]/ 概率/ 为/ 1/ -/ U/ ./ K/ -/ means/ 测试数据/ 的/ 相关/ 信息/ 如表/ 6/ 所示/ ./ 名称/ S1U1S2U1S3U1S2U2S2U3S2U4/ 需要/ 指出/ 的/ 是/ ,/ 当/ U/ =/ 0/ 时/ ,/ 理论/ 上/ ,/ 增量/ 数据/ 不会/ 对/ 原始/ 聚类/ 产生/ 影响/ 时/ ,/ 可以/ 认为/ 增量/ 数据/ 自成/ k/ 簇/ ,/ 由于/ 全量/ 迭代/ 的/ 初始/ 点/ 是/ 原始数据/ 的/ k/ 簇/ ,/ 因此/ 理论/ 上/ 在/ 全量/ 迭代/ 中/ 这/ k/ 个/ 簇/ 不/ 需要/ 变换/ ,/ 只/ 需要/ 找出/ 增量/ 部分/ 的/ k/ 簇/ 即可/ ./ 但/ 实际上/ 由于/ K/ -/ means/ 算法/ 始终/ 要/ 保持/ 聚类/ 个数/ 为/ k/ ,/ 即使/ U/ =/ 0/ 时/ 全量/ 迭代/ 也/ 需要/ 将/ k/ +/ k/ 个/ 簇聚成/ k/ 个/ 簇/ ./ 因此/ ,/ 尽管/ U/ =/ 0/ ,/ 增量/ 数据/ 对/ 原始/ 迭代/ 结果/ 也/ 会/ 产生/ 更新/ ./ 在/ 本/ 实验/ 用例/ 中/ ,/ 我们/ 取/ k/ =/ 12/ ,/ k/ =/ 2/ ./ 此外/ ,/ 在/ K/ -/ means/ 算法/ 执行/ 过程/ 中/ ,/ 本文/ 使用/ “/ 迭代/ 变量/ 变化/ 小于/ 某/ 阈值/ ”/ 这一/ 条件/ 作为/ 迭代/ 终止/ 条件/ ,/ 且/ 阈值/ 设/ 为/ 极小/ 的/ 10/ -/ 6/ ,/ 确保/ 迭代/ 结果/ 的/ 精确性/ ./ 并且/ 为了/ 对比/ 各用例/ 的/ 迭代/ 结果/ ,/ 各用例/ 初始化/ 的/ k/ 个/ 中心点/ 是/ 相同/ 的/ ,/ 确保/ 迭代/ 结果/ 能够/ 合理/ 地/ 进行/ 比较/ ./ 5.3/ PageRank/ 算法/ 根据/ 3.4/ 节/ 的/ 理论/ 证明/ ,/ 无论是/ 通过/ 增量/ 迭代/ 还是/ 全量/ 迭代/ ,/ 最终/ 的/ 结果/ 数据/ 是/ 一致/ 的/ ./ 由于/ PageRank/ 迭代/ 算法/ 的/ 运行/ 结果/ 本身/ 不/ 具有/ 唯一性/ ,/ 因此/ 即使/ 同样/ 数据/ 下/ 多次/ 计算/ PageRank/ ,/ 其/ 计算结果/ 也/ 会/ 存在/ 微小/ 的/ 差异/ ./ 令/ 每个/ 网页/ 误差/ 为/ 每次/ 迭代/ PageRank/ 值/ 的/ 差距/ ,/ 即/ |/ rank/ -/ rank/ |/ // rank/ ,/ 然后/ 以/ 所有/ 网页/ 的/ 误差/ 均值/ 作为/ 误差/ 评价/ 标准/ ./ 分析/ 实验/ 结果/ 知/ ,/ 多次/ 全量/ 迭代/ 结果/ 的/ 平均误差/ 在/ [/ 0.101/ ,/ 0.201/ ]/ 区间/ 内/ ,/ 而/ 增量/ 迭代/ 和/ 全量/ 迭代/ 之间/ 的/ 误差/ 在/ [/ 0.117/ ,/ 0.209/ ]/ 区间/ 内/ ./ 为/ 进一步/ 证明/ 迭代/ 结果/ 的/ 一致性/ ,/ 我们/ 参考文献/ [/ 30/ ]/ ,/ 计算/ 增量/ 迭代/ 结果/ 和/ 全量/ 迭代/ 结果/ 的/ 均/ 方根/ 误差/ ./ 均/ 方根/ 误差/ 是/ 常用/ 的/ 统计分析/ 方法/ ,/ 用于/ 分析/ 预测值/ 和/ 真实/ 值间/ 的/ 差距/ ,/ 其值/ 越/ 接近/ 于/ 0/ ,/ 差异/ 越小/ ,/ 其/ 计算方法/ 如式/ (/ 23/ )/ 所示/ ,/ S/ 和/ T/ 分别/ 表示/ 增量/ 迭代/ 结果/ 和/ 全量/ 迭代/ 结果/ ,/ si/ 和/ ti/ 分别/ 表示/ 增量/ 迭代/ 结果/ 和/ 全量/ 迭代/ 结果/ 中/ 编号/ 为/ i/ 的/ 页面/ 的/ PageRank/ 值/ ,/ n/ 为/ 页面/ 数量/ ./ 计算/ 得/ 增量/ 迭代/ 和/ 全量/ 迭代/ 结果/ 的/ 均/ 方根/ 误差/ 平均值/ 为/ 4.08/ ×/ 10/ -/ 10/ ,/ 该值/ 小于/ 文献/ [/ 30/ ]/ 的/ 实验/ 结果/ 1.24/ ×/ 10/ -/ 9/ ./ 基于/ 误差/ 对比/ 和/ 均/ 方根/ 误差/ 分析/ ,/ 我们/ 可以/ 认为/ ,/ 对于/ PageRank/ 算法/ 增量/ 迭代/ 和/ 全量/ 迭代/ 的/ 结果/ 是/ 一致/ 的/ ./ 我们/ 首先/ 验证/ 了/ 本文/ 提出/ 的/ 基于/ MapReduce/ 的/ 差集/ 算法/ ,/ 用于/ 求取/ 原始数据/ 和/ 增量/ 数据/ 的/ 差集/ ./ 表/ 7/ 给出/ 了/ 3/ 组/ 实验/ 数据/ 的/ 增量/ 数据/ 集/ 的/ 大小/ ,/ 所求/ 的/ 差集/ 大小/ 以及/ 差集/ 占/ 增量/ 数据/ 的/ 比率/ ./ S3U1S3U2S3U4/ 为了/ 方便/ 表述/ ,/ 差集/ 所/ 占/ 增量/ 数据/ 集/ 的/ 比率/ 使用/ 函数/ p/ 进行/ 表述/ ./ 根据/ 5.2/ 节/ 的/ 数据/ 生成/ 算法/ ,/ 则/ 理论/ 上/ p/ (/ S3U1/ )/ =/ 1/ ,/ p/ (/ S3U2/ )/ =/ 0.6/ ,/ p/ (/ S3U4/ )/ =/ 0.2/ ./ 在/ 表/ 5/ 中/ 的/ 差集/ 比例/ 与/ 更新/ 度/ 定义/ 一致/ ./ 同时/ 按/ 大数/ 定律/ ,/ 随着/ 数据/ 集/ 的/ 增大/ ,/ p/ (/ SiUj/ )/ 的/ 值/ 也/ 越/ ①/ http/ :/ // // dbpedia/ ./ orgPage14/ 接近/ 理论值/ ./ 实际/ 值/ 和/ 理论值/ 的/ 极小/ 差异/ 证明/ 了/ 差集/ 算法/ 的/ 正确性/ ./ 我们/ 测试/ 了/ 相同/ 更新/ 度/ ,/ 不同/ 数据量/ 下/ 的/ 3/ 种/ 迭代/ 计算/ 的/ 性能/ ./ 选用/ 数据/ 集为/ S1U3/ 、/ S2U3/ 和/ S3U3/ ,/ 实验/ 结果/ 如图/ 5/ 所示/ ./ 图/ 5PageRank/ 在/ 不同/ 数据量/ 的/ 数据/ 集下/ 实验/ 结果/ 由图/ 5/ 可知/ ,/ Ti/ (/ SxU3/ )/ </ Ti/ (/ SyU3/ )/ (/ x/ ,/ y/ ,/ i/ ∈/ {/ 1/ ,/ 2/ ,/ 3/ }/ 且/ x/ </ y/ )/ ,/ 即/ 同种/ 迭代/ 方法/ 的/ 迭代/ 时间/ 随/ 迭代/ 数据/ 集/ 大小/ 单调/ 递增/ ./ 文献/ [/ 11/ ]/ 指出/ 大部分/ 数据/ 集上/ 的/ PageRank/ 算法/ 都/ 会/ 在/ 10/ 轮内/ 收敛/ ,/ 但/ 每轮/ 的/ 迭代/ 代价/ 不同/ ,/ 数据量/ 不会/ 影响/ 迭代/ 轮数/ ,/ 但会/ 影响/ 每轮/ 迭代/ 时间/ ./ 此外/ ,/ T2/ (/ SiU3/ )/ </ T1/ (/ SiU3/ )/ </ T3/ (/ SiU3/ )/ ,/ 增量/ 迭代/ 的/ 性能/ 优于/ 原始/ 迭代/ ,/ 而前/ 两者/ 均/ 优于/ 全量/ 迭代/ ./ T2/ (/ SiU3/ )/ </ T3/ (/ SiU3/ )/ 是/ 我们/ 研究/ 的/ 重点/ ,/ 增量/ 迭代/ 对比/ 全量/ 迭代/ 的/ 性能/ 优势/ 在于/ :/ 增量/ 迭代/ 增量/ 步/ 的/ 每轮/ 迭代/ 代价/ 小于/ 全量/ 迭代/ 的/ 每轮/ 迭代/ 代价/ ,/ 而/ 增量/ 迭代/ 的/ 合并/ 步/ 迭代/ 轮数/ 小于/ 全量/ 迭代/ ./ 对于/ 前者/ ,/ 全量/ 迭代/ 和/ 增量/ 迭代/ 增量/ 步/ 的/ 迭代/ 轮数/ 相同/ ,/ 当/ 原始数据/ 量/ 增加/ 时/ ,/ 全量/ 迭代/ 每轮/ 迭代/ 代价/ 增加/ ,/ 而/ 因为/ 增量/ 数据/ 未/ 发生变化/ ,/ 增量/ 迭代/ 的/ 增量/ 步/ 每轮/ 迭代/ 代价/ 不变/ ,/ 性能/ 优化/ 效果/ 增加/ ./ 对于/ 后者/ ,/ 当/ 数据量/ 增加/ 而/ 数据/ 特征/ 不变/ 时/ ,/ 增量/ 迭代/ 和/ 全量/ 迭代/ 的/ 合并/ 步/ 的/ 迭代/ 轮数/ 差距/ 不变/ ,/ 即使/ 每轮/ 迭代/ 代价/ 增加/ ,/ 性能/ 优化/ 效果/ 不变/ ./ 由于/ |/ Δ/ L/ |/ / |/ L/ |/ ,/ 因此/ Δ/ L/ -/ L/ 是/ 一个/ 更/ 小/ 的/ 数据/ ,/ 增量/ 迭代/ 增量/ 步/ 的/ 代价/ 在/ 整个/ 增量/ 迭代/ 代价/ 中所/ 占/ 比例/ 很小/ ,/ 因此/ ,/ 增量/ 步/ 的/ 优化/ 效果/ 很小/ ./ 综上所述/ ,/ 在/ 数据/ 特征/ 不变/ 的/ 情况/ 下/ 增加/ 数据量/ ,/ 增量/ 迭代/ 的/ 优化/ 效果/ 会/ 有/ 较/ 小/ 的/ 提升/ ./ 图/ 5/ 中/ 优化/ 比例/ 折线/ 清晰/ 地/ 展示/ 了/ 上述/ 特征/ ./ ω/ (/ S1U3/ )/ </ ω/ (/ S2U3/ )/ </ ω/ (/ S3U3/ )/ ,/ 折线/ 斜率/ 很小/ ,/ 略有/ 上升/ ./ 随后/ ,/ 我们/ 测试/ 了/ 相同/ 数据量/ ,/ 不同/ 更新/ 度下/ 的/ 3/ 种/ 迭代/ 计算/ 的/ 性能/ ./ 选用/ 数据/ 集为/ S3U1/ 至/ S3U4/ ,/ 实验/ 结果/ 如图/ 6/ 所示/ ./ 图/ 6PageRank/ 在/ 不同/ 更新/ 度/ 的/ 数据/ 集下/ 实验/ 结果/ 由图/ 6/ 可以/ 看出/ ,/ 对于/ 全量/ 迭代/ ,/ 无论/ 更新/ 度/ 如何/ ,/ T3/ (/ S3Ui/ )/ (/ i/ ∈/ {/ 1/ ,/ 2/ ,/ 3/ ,/ 4/ }/ )/ 均/ 相差/ 不/ 大/ ;/ 对于/ 增量/ 迭代/ ,/ 除了/ T2/ (/ S3U1/ )/ 很小/ ,/ 其他/ 均/ 相差/ 不/ 大/ ;/ 对于/ 性能/ 优化/ 比例/ ,/ ω/ (/ S3U1/ )/ >/ ω/ (/ S3U2/ )/ >/ ω/ (/ S3U3/ )/ >/ ω/ (/ S3U4/ )/ ,/ 但/ ω/ (/ S3U1/ )/ 优势/ 明显/ ,/ 其他/ 数据/ 集下/ 增量/ 迭代/ 的/ 优化/ 效果/ 随/ 更新/ 度/ 增大/ 而/ 略微/ 减小/ ,/ 折线/ 下降/ 缓慢/ ./ 增量/ 迭代/ 对比/ 全量/ 迭代/ 的/ 性能/ 优势/ 在于/ 增量/ 迭代/ 的/ 合并/ 步/ 迭代/ 轮数/ 小于/ 全量/ 迭代/ ./ S3U1/ 的/ 更新/ 度为/ 零/ ,/ 因此/ 增量/ 迭代/ 的/ 合并/ 步仅/ 执行/ 了/ 1/ 轮/ ,/ 而/ 全量/ 迭代/ 执行/ 了/ 7/ 轮/ ,/ 因此/ 增量/ 迭代/ 明显/ 优于/ 原始/ 迭代/ ;/ 但/ 由于/ |/ Δ/ L/ |/ / |/ L/ |/ ,/ 无论/ 更新/ 度为/ 多少/ ,/ 关联/ 数据/ 集都/ 很小/ ,/ 不足以/ 影响/ 增量/ 迭代/ 合并/ 步/ 的/ 轮数/ ,/ 因此/ ,/ S3U2/ ,/ S3U3/ 和/ S3U4/ 下/ 增量/ 迭代/ 的/ 合并/ 步/ 迭代/ 轮数/ 均/ 为/ 4/ 轮/ ,/ 因此/ 从/ 合并/ 步/ 迭代/ 轮数/ 角度/ 优化/ 比例/ 不变/ ./ ω/ (/ S3U2/ )/ >/ ω/ (/ S3U3/ )/ >/ ω/ (/ S3U4/ )/ 的/ 原因/ 是/ :/ 当/ 关联/ 数据/ 集/ 增加/ ,/ 增量/ 迭代/ 的/ 合并/ 步/ 的/ 每/ 一轮/ 参与/ 计算/ 的/ 数据/ 增加/ ,/ 因此/ 每轮/ 迭代/ 代价/ 增加/ ,/ 增量/ 迭代/ 执行/ 时间/ 增加/ ,/ 因此/ 优化/ 比例/ 减少/ ./ 综上所述/ ,/ 通过/ 多组/ 数据/ 实验/ ,/ 我们/ 可以/ 认为/ PageRank/ 算法/ 增量/ 迭代/ 较/ 全量/ 迭代/ 的/ 性能/ 优化/ 比例/ 达到/ 15/ %/ ./ 5.4/ 犓/ -/ means/ 算法/ 首先/ ,/ 我们/ 验证/ K/ -/ means/ 算法/ 增量/ 迭代/ 结果/ 和/ 全量/ 迭代/ 结果/ 的/ 一致性/ ./ 实验/ 证明/ ,/ 两者/ 的/ 迭代/ 初始/ 点/ 相同/ ,/ 迭代/ 后/ 的/ k/ 个/ 簇内/ 包含/ 的/ 数据/ 也/ 相同/ ./ 进一步/ 地/ ,/ 我们/ 判断/ 增量/ 迭代/ 后/ k/ 个/ 簇/ 的/ 中心点/ 与/ 全量/ 迭代/ k/ 个/ 簇/ 的/ 中心点/ 是否/ 重合/ ./ 我们/ 对/ k/ 个/ 中心点/ 进行/ 比较/ ,/ 并/ 计算/ 对应/ 簇/ 的/ 中心点/ 间/ 的/ 欧氏/ 距离/ ./ 经过/ 分析/ ,/ 全量/ 迭代/ 聚类/ 结果/ 和/ 增量/ 迭代/ 聚类/ 结果/ 中心点/ 距离/ 均值/ 为/ 2.135/ ×/ 10/ -/ 7/ ,/ 该值/ 小于/ 迭代/ 终止/ 阈值/ 10/ -/ 6/ ,/ 即/ 误差/ 的/ 控制/ 范围/ ./ 因此/ ,/ 可以/ 认/ Page15/ 为/ K/ -/ means/ 算法/ 增量/ 迭代/ 和/ 全量/ 迭代/ 的/ 结果/ 是/ 一致/ 的/ ./ 我们/ 测试/ 了/ 相同/ 更新/ 度/ ,/ 不同/ 数据量/ 下/ 的/ 3/ 种/ 迭代/ 计算/ 的/ 性能/ ./ 选用/ 数据/ 集为/ S1U1/ 、/ S2U1/ 和/ S3U1/ ,/ 实验/ 结果/ 如图/ 7/ 所示/ ./ 图/ 7K/ -/ means/ 在/ 不同/ 数据量/ 的/ 数据/ 集下/ 实验/ 结果/ 可知/ 对于/ 相同/ 更新/ 度且/ 不同/ 数据量/ 的/ 数据/ 集/ ,/ K/ -/ means/ 算法/ (/ 图/ 7/ )/ 和/ PageRank/ 算法/ (/ 图/ 5/ )/ 在/ 3/ 种/ 迭代/ 方法/ 下/ 的/ 迭代/ 时间/ 规律/ 类似/ :/ 同种/ 迭代/ 方法/ 的/ 迭代/ 时间/ 随/ 迭代/ 数据/ 集/ 大小/ 单调/ 递增/ ;/ 增量/ 迭代/ 的/ 性能/ 优于/ 全量/ 迭代/ ;/ 在/ 数据/ 特征/ 不变/ 的/ 情况/ 下/ 数据量/ 增加/ ,/ 增量/ 迭代/ 的/ 优化/ 效果/ 有所/ 提升/ ./ 但/ K/ -/ means/ 算法/ 全量/ 迭代/ 执行/ 时间/ 平均/ 为/ 原始/ 迭代/ 的/ 35/ %/ ./ 增量/ 迭代/ 较/ 全量/ 迭代/ 的/ 优化/ 效果/ 明显提高/ ,/ 在/ 大/ 数据量/ 下/ 性能/ 优化/ 达/ 22/ %/ ,/ 且/ 当/ 原始数据/ 增加/ 时/ ,/ 增量/ 迭代/ 性能/ 有所/ 提升/ ./ 这/ 是因为/ K/ -/ means/ 算法/ 迭代/ 轮数/ 对/ 初始/ 点/ 的/ 选择/ 非常/ 敏感/ ,/ 良好/ 的/ 初始/ 点/ 选择/ 可以/ 极大/ 地/ 减少/ 迭代/ 轮数/ :/ (/ 1/ )/ 原始/ 迭代/ 的/ 初始/ 中心点/ 是/ 随机/ 选取/ ,/ 因此/ 迭代/ 轮数/ 很大/ ;/ (/ 2/ )/ 对于/ 增量/ 迭代/ 的/ 增量/ 步/ ,/ 采用/ 较少/ 的/ 随机/ 初始/ 点/ 进行/ 迭代/ ,/ 且/ 差集/ 数据/ 很小/ ,/ 因此/ 迭代/ 代价/ 较/ 小/ ;/ 对于/ 增量/ 迭代/ 的/ 合并/ 步/ ,/ 由于/ 初始/ 点/ 来自/ 于/ 原始数据/ 的/ k/ 个/ 中心点/ 和/ 差集/ 数据/ 的/ k/ 个/ 中心点/ (/ 求/ k/ +/ k/ 个点/ 的/ k/ 个/ 中心点/ )/ ,/ 因此/ 中心点/ 选择/ 良好/ ,/ 迭代/ 轮数/ 很小/ ;/ (/ 3/ )/ 对于/ 全量/ 数据/ ,/ 采用/ 原始数据/ k/ 个/ 中心点/ 作为/ 初始/ 点/ ,/ 初始/ 点/ 选择/ 较/ 好/ ,/ 迭代/ 轮数/ 少于/ 原始/ 迭代/ 轮数/ ;/ (/ 4/ )/ 当/ 数据量/ 增加/ 时/ ,/ 增量/ 迭代/ 合并/ 步/ 和/ 全量/ 迭代/ 的/ 迭代/ 轮数/ 差距/ 更加/ 明显/ ,/ 优化/ 效果/ 越/ 好/ ;/ (/ 5/ )/ 增量/ 迭代/ 增量/ 步/ 每轮/ 迭代/ 代价/ 的/ 优势/ 对/ 性能/ 的/ 影响/ 不/ 明显/ ,/ 而/ 迭代/ 轮数/ 起/ 决定性/ 影响/ ,/ 迭代/ 轮数/ 则/ 与/ 初始/ 点/ 的/ 选择/ 相关/ ./ 随后/ ,/ 我们/ 测试/ 了/ 相同/ 数据量/ ,/ 不同/ 更新/ 度下/ 的/ 3/ 种/ 迭代/ 计算/ 的/ 性能/ ./ 选用/ 数据/ 集为/ S2U1/ 至/ S2U4/ ,/ 实验/ 结果/ 如图/ 8/ 所示/ ./ 图/ 8K/ -/ means/ 在/ 不同/ 更新/ 度/ 的/ 数据/ 集下/ 实验/ 结果/ 图/ 8/ 的/ 规律/ 和/ 图/ 6/ 基本一致/ :/ ω/ (/ S2U1/ )/ >/ ω/ (/ S2U2/ )/ >/ ω/ (/ S2U3/ )/ >/ ω/ (/ S2U4/ )/ ,/ 但/ ω/ (/ S2U1/ )/ 优势/ 明显/ ,/ 其他/ 数据/ 集下/ 增量/ 迭代/ 的/ 优化/ 效果/ 随/ 更新/ 度/ 增大/ 而/ 减小/ ./ 首先/ ,/ 我们/ 分析/ S2U1/ (/ U/ =/ 0/ )/ 的/ 情况/ ./ 由于/ 全量/ 迭代/ 的/ 初始/ 点/ 是/ 原始/ 迭代/ 结果/ ,/ 理论/ 上/ 其/ 迭代/ 次数/ 也/ 受/ 初始/ 点/ 是否/ 良好/ 的/ 影响/ ./ 当/ U/ =/ 0/ 时/ 是/ 增量/ 迭代/ 最佳/ 情况/ ,/ 却是/ 全量/ 迭代/ 的/ 最坏/ 情况/ ./ 前者/ 会/ 在/ 增量/ 步/ 将/ 增量/ 数据/ (/ 差集/ 数据/ )/ 聚成/ 簇/ ,/ 并/ 在/ 合并/ 步/ 调整/ 原始/ 聚类/ 结果/ ,/ 减少/ 簇/ 个数/ ;/ 后者/ 则/ 要/ 将/ 原始/ 聚类/ 结果/ 不断/ 变化/ 以/ 适应/ 独立/ 成簇/ 的/ 增量/ 数据/ ./ 后者/ 的/ 迭代/ 轮数/ 大于/ 前者/ 的/ 迭代/ 轮数/ ,/ 因此/ ,/ 增量/ 迭代/ 性能/ 优化/ 效果/ 很/ 好/ ./ 其次/ ,/ 我们/ 分析/ S2U4/ (/ U/ =/ 1/ )/ ,/ 此时/ 因为/ 差集/ 数据/ 为空/ ,/ 增量/ 迭代/ 已经/ 退化/ 为/ 全量/ 迭代/ ,/ 两者/ 的/ 性能/ 应该/ 相差无几/ ,/ 图中/ 优化/ 4.8/ %/ 的/ 结果/ 具有/ 偶然性/ ./ 综上所述/ ,/ 通过/ 多组/ 数据/ 实验/ ,/ 我们/ 可以/ 认为/ K/ -/ means/ 算法/ 增量/ 迭代/ 较/ 全量/ 迭代/ 的/ 性能/ 优化/ 比例/ 平均/ 为/ 22/ %/ ./ 6/ 结论/ 和/ 进一步/ 工作/ 本文/ 提出/ 了/ 一种/ 基于/ 新增/ 数据/ 的/ 增量/ 迭代/ 计算/ 模型/ ,/ 又称/ DELTA/ (/ DeltadatabasedincrEmentaLiTerAtivecomputing/ )/ 模型/ ,/ 利用/ 原始/ 迭代/ 结果/ 和/ 增量/ 数据/ 求解/ 新/ 的/ 迭代/ 结果/ ,/ 避免/ 在/ 数据/ 全集/ 上/ 进行/ 全量/ 迭代/ ./ 本文/ 将/ 增量/ 迭代/ 分为/ 3/ 个/ 步骤/ ,/ 即/ “/ 原始/ 步/ (/ 已/ 完成/ )/ ”/ 、/ “/ 增量/ 步/ ”/ 和/ “/ 合并/ 步/ ”/ ./ 本文/ 定义/ 了/ DELTA/ 模型/ 、/ 描述/ 了/ 其/ 计算/ 步骤/ ,/ 证明/ 了/ DELTA/ 模型/ 的/ 性能/ 优势/ 和/ 结果/ 正确性/ ,/ 同时/ 列举/ 了/ PageRank/ 、/ K/ -/ means/ 和/ DescendantQuery/ 算法/ 在/ DELTA/ 模型/ 下/ 的/ 例子/ ./ 本文/ 还/ 描述/ 了/ DELTA/ 框架/ 的/ 实现/ ,/ 重点/ 阐述/ 了/ 迭代/ 框架/ Δ/ HaLoop/ 中/ 对/ HaLoop/ 所/ 作出/ Page16/ 的/ 改进/ ./ 本文/ 对/ DELTA/ 模型/ 进行/ 了/ 评价/ ,/ 分别/ 从/ 功能/ 正确性/ 和/ 性能/ 优势/ 两个/ 角度/ 进行/ 阐述/ ,/ 最终/ 得出/ 如下/ 结论/ :/ DELTA/ 模型/ 及其/ 实现/ 能够/ 很/ 好/ 的/ 适应/ 大/ 数据/ 的/ 迭代/ 分析/ ,/ 当/ 数据/ 发生变化/ 后/ ,/ DELTA/ 模型/ 能够/ 利用/ 已知/ 迭代/ 结果/ 和/ 增量/ 数据/ 快速/ 获得/ 新/ 的/ 迭代/ 结果/ ,/ 迭代/ 结果/ 准确/ ./ 增量/ 迭代/ 明显/ 优于/ 全量/ 迭代/ 性能/ ./ 进一步/ 工作/ 包括/ 研究/ 通过/ 更/ 多/ 的/ 迭代/ 算法/ 来/ 验证/ DELTA/ 模型/ ,/ 以及/ 讨论/ 适用/ 于/ 增量/ 迭代/ 的/ 迭代/ 变量/ 初始化/ 算法/ ./ 此外/ ,/ 目前/ 的/ 增量/ 迭代/ 中/ 还/ 包括/ 一些/ 数据/ 预处理/ 操作/ ,/ 如差集/ 算法/ 以及/ 作业/ 调度/ 时间/ ,/ 我们/ 拟/ 通过/ 提高/ 并行性/ 等/ 方式/ 减少/ 这些/ 操作/ 的/ 时间/ ,/ 探讨/ 是否/ 存在/ “/ 增量/ 迭代/ 和/ 原始/ 迭代/ 的/ 执行/ 时间/ 之/ 和/ 能够/ 接近/ 全量/ 迭代/ 的/ 执行/ 时间/ ”/ 的/ 可能性/ ./ 

