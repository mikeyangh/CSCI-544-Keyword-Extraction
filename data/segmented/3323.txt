Page1/ 分簇/ VLIW/ 结构/ 下/ 利用/ 数据/ 依赖图/ 优化/ 调度/ 的/ 研究/ 杨旭何/ 虎/ 孙义/ 和/ (/ 清华大学/ 微电子/ 研究所/ 北京/ 100084/ )/ 摘要/ 应用/ 的/ 需求/ 促使/ 如今/ 的/ 处理器/ 必须/ 尽可能/ 高地/ 利用/ 程序/ 中/ 所/ 存在/ 的/ 指令/ 级/ 并行度/ ,/ 然而/ ,/ 高/ 指令/ 级/ 并行/ 的/ 硬件/ 和/ 指令/ 调度/ 技术/ 会/ 给/ 寄存器/ 资源/ 带来/ 极大/ 的/ 压力/ ./ 要/ 在/ 单一/ 寄存器/ 堆/ 的/ 情况/ 下/ ,/ 既/ 维持/ 高/ 的/ 指令/ 级/ 并行度/ ,/ 又/ 保持/ 高/ 的/ 运行/ 时钟/ 频率/ 是/ 一件/ 非常/ 困难/ 的/ 事情/ ,/ 这/ 是因为/ ,/ 当/ 指令/ 级/ 并行度/ 足够/ 高时/ ,/ 在/ 单一/ 寄存器/ 堆/ 情况/ 下/ ,/ 寄存器/ 堆/ 访问/ 端口数/ 目的/ 限制/ 会/ 使得/ 对/ 寄存器/ 堆/ 的/ 访问/ 时间/ 成为/ 制约/ 性能/ 提高/ 的/ 关键因素/ ./ 为了/ 在/ 利用/ 高/ 的/ 指令/ 级/ 并行度/ 的/ 同时/ 维持/ 高/ 的/ 运行/ 时钟/ 频率/ ,/ 可以/ 将/ 寄存器/ 堆/ 和/ 功能/ 单元/ 划分/ 到/ 不同/ 的/ 簇/ 中/ ./ 每/ 一个/ 簇中/ 的/ 功能/ 单元/ 可以/ 直接/ 访问/ 簇内/ 的/ 寄存器/ 堆/ ,/ 而/ 簇间/ 的/ 数据/ 交互/ 则/ 需要/ 占用/ 专用/ 的/ 资源/ 来/ 进行/ ./ 因此/ ,/ 分簇/ 结构/ 下/ 的/ 编译器/ 不仅/ 要/ 通过/ 调度/ 实现/ 最大/ 程序/ 的/ 指令/ 级/ 并行度/ ,/ 还/ 应该/ 对/ 指令/ 的/ 分簇/ 进行/ 细致/ 的/ 安排/ 以/ 限制/ 簇间/ 的/ 数据/ 交互/ ./ 该文/ 致力于/ 通过/ 对/ 数据/ 依赖图/ (/ DataDependenceGraph/ )/ 分析/ 和/ 划分/ ,/ 从而/ 在/ 最小化/ 簇间/ 的/ 数据/ 交互/ 的/ 同时/ ,/ 平衡/ 各簇/ 的/ 利用/ 情况/ ,/ 提高/ 能够/ 获得/ 的/ 指令/ 级/ 并行度/ ,/ 从而/ 优化/ 分簇式/ VLIW/ 结构/ 的/ 调度/ 性能/ ./ 实验/ 结果/ 证明/ ,/ 该文/ 所/ 提出/ 的/ 方法/ 可以/ 极大/ 地/ 减少/ 簇间/ 的/ 数据/ 交互/ 量/ ,/ 提高/ 所/ 能/ 获得/ 的/ 指令/ 级/ 并行度/ ,/ 从而/ 对/ 调度/ 结果/ 的/ 性能/ 加以/ 改善/ ./ 关键词/ 分簇/ ;/ VLIW/ 结构/ ;/ 数据/ 依赖图/ ;/ 指令/ 调度/ ;/ 簇间/ 数据/ 交互/ 1/ 引言/ 为了/ 满足/ 应用/ 的/ 需求/ ,/ 特别/ 是/ 多媒体/ 处理/ 应用/ 的/ 需求/ ,/ 当今/ 的/ 处理器/ 结构/ 需要/ 不断/ 地/ 提升/ 性能/ ./ 大部分/ 的/ 处理器/ 结构/ 都/ 选取/ 了/ 尽量/ 利用/ 程序/ 中/ 的/ 指令/ 级/ 并行度/ 的/ 办法/ ,/ 来/ 提高/ 处理/ 能力/ ./ 这些/ 指令/ 级/ 并行/ 的/ 结构/ ,/ 允许/ 在/ 单一/ 周期/ 内/ 执行/ 多个/ 最低/ 层次/ 的/ 诸如/ 内存/ 的/ 读取/ 、/ 定点数/ 加法/ 以及/ 浮点数/ 乘法/ 等/ 机器/ 操作/ ./ 为了/ 有效/ 地/ 利用/ 并行/ 硬件/ ,/ 编译器/ 必须/ 识别/ 出/ 程序/ 中/ 的/ 并行性/ ./ 而/ 对于/ 指令/ 级/ 并行/ 结构/ ,/ 为了/ 有效/ 地/ 利用/ 硬件资源/ ,/ 编译器/ 需要/ 对/ 原始/ 的/ 串行/ 指令流/ 进行/ 处理/ ,/ 使得/ 多于/ 一个/ 的/ 低层次/ 操作/ 可以/ 在/ 硬件资源/ 允许/ 的/ 情况/ 下/ 同时/ 执行/ ./ 这种/ 对/ 机器/ 操作/ 进行/ 处理/ ,/ 以便/ 有效/ 地/ 利用/ 指令/ 级/ 并行/ 结构/ 中/ 的/ 硬件资源/ 的/ 行为/ 就/ 称之为/ 指令/ 调度/ [/ 1/ ]/ ./ 不幸/ 的/ 是/ ,/ 高/ 指令/ 级/ 并行度/ 的/ 硬件资源/ 和/ 指令/ 调度/ 技术/ 会/ 使/ 机器/ 中/ 的/ 寄存器/ 资源/ 承受/ 极大/ 的/ 压力/ ./ 要/ 在/ 单一/ 寄存器/ 堆/ 的/ 情况/ 下/ ,/ 既/ 维持/ 高/ 的/ 指令/ 级/ 并行度/ ,/ 又/ 要/ 保持/ 高/ 的/ 时钟/ 运行/ 频率/ 是/ 非常/ 困难/ 的/ 一件/ 事情/ ./ 这/ 是因为/ ,/ 当/ 指令/ 级/ 并行度/ 足够/ 高时/ ,/ 在/ 单一/ 寄存器/ 堆/ 情况/ 下/ ,/ 寄存器/ 堆/ 访问/ 端口数/ 目的/ 限制/ 会/ 使得/ 对/ 寄存器/ 堆/ 的/ 访问/ 时间/ 成为/ 制约/ 性能/ 提高/ 的/ 关键因素/ [/ 2/ -/ 3/ ]/ ./ 面对/ 这个/ 问题/ ,/ 将/ 寄存器/ 和/ 功能/ 单元/ 划分/ 到/ 不同/ 的/ 簇/ 中/ 是/ 一种/ 可行/ 的/ 解决办法/ [/ 4/ -/ 5/ ]/ ./ 一个/ 簇中/ 的/ 寄存器/ 可以/ 自由/ 地被/ 簇内/ 的/ 功能/ 单元/ 所/ 访问/ ,/ 而/ 簇/ 与/ 簇/ 之间/ 的/ 数据/ 交互/ 则/ 需要/ 专门/ 的/ 簇间/ 拷贝/ 资源/ 来/ 完成/ [/ 6/ ]/ ./ 分簇/ 可能/ 会/ 限制/ 调度/ 所/ 能/ 取得/ 的/ 指令/ 级/ 并行度/ ./ 某条/ 指令/ 原本/ 可能/ 可以/ 被/ 调度/ 到/ 某个/ 周期/ 中/ ,/ 但是/ 假如/ 它/ 所/ 需要/ 的/ 数据/ 不是/ 存放/ 在/ 目前/ 它/ 可以/ 被/ 分配/ 到/ 的/ 功能/ 单元/ 所/ 能够/ 访问/ 的/ 寄存器/ 中/ ,/ 就/ 需要/ 添加/ 额外/ 的/ 操作/ 或者/ 指令/ 来/ 将/ 它/ 所/ 需要/ 的/ 数据/ 移动/ 到/ 它/ 可/ 分配/ 的/ 功能/ 单元/ 所/ 能够/ 访问/ 到/ 的/ 寄存器/ 中/ ,/ 否则/ 该/ 指令/ 就/ 无法/ 执行/ ./ 所以/ ,/ 编译器/ 的/ 工作/ 不单是/ 要/ 通过/ 调度/ 获取/ 最大/ 程度/ 的/ 并行度/ ,/ 还/ 需要/ 兼顾/ 指令/ 的/ 分簇/ 安排/ 来/ 限制/ 簇间/ 的/ 数据/ 交互/ 量/ [/ 1/ ]/ ./ 因此/ ,/ 分簇式/ VLIW/ 结构/ 的/ 编译器/ 不仅/ 需要/ 决定/ 每个/ 操作/ 的/ 执行/ 周期/ ,/ 还/ 需要/ 决定/ 每个/ 操作/ 应该/ 安置/ 在/ 哪个/ 簇中/ 的/ 哪个/ 功能/ 单元/ 上/ 执行/ ./ 要/ 完成/ 这个/ 任务/ 不是/ 一件/ 简单/ 的/ 事情/ ,/ 因为/ 其中/ 牵涉到/ 两个/ 互相矛盾/ 的/ 目标/ ./ 为了/ 获取/ 最高/ 的/ 性能/ 要求/ 将/ 操作/ 尽可能/ 均匀/ 地/ 分散/ 到/ 每个/ 功能/ 单元/ 中/ ,/ 即/ 平衡/ 各个/ 簇/ 的/ 利用/ 情况/ ;/ 同时/ ,/ 编译器/ 还/ 必须/ 最小化/ 由于/ 将/ 指令/ 分散/ 到/ 各/ 簇/ 中/ 执行/ 所/ 带来/ 的/ 簇间/ 的/ 数据/ 交互/ [/ 1/ ]/ ./ 本文/ 中/ ,/ 我们/ 提出/ 了/ 一种/ 方法/ ,/ 利用/ 对/ 数据/ 依赖图/ (/ DataDependenceGraph/ )/ 的/ 分析/ 和/ 划分/ 来/ 平衡/ 簇/ 的/ 利用/ 情况/ 和/ 最小化/ 簇间/ 数据/ 交互/ ,/ 并/ 以此/ 来/ 引导/ 调度/ 的/ 进行/ ,/ 从而/ 提高/ 调度/ 所/ 能/ 得到/ 的/ 指令/ 级/ 并行度/ ./ 接下来/ ,/ 我们/ 在/ 第/ 2/ 节中/ 对/ 现有/ 的/ 一些/ 针对/ 分簇式/ 结构/ 的/ 调度/ 算法/ 进行/ 分析/ ,/ 找出/ 存在/ 的/ 问题/ ;/ 第/ 3/ 节对/ 利用/ 数据/ 依赖图/ 来/ 最小化/ 簇间/ 数据/ 交互/ 的/ 方法/ 进行/ 详细/ 的/ 介绍/ ;/ 第/ 4/ 节/ 说明/ 如何/ 利用/ 数据/ 依赖图/ 来/ 平衡/ 簇/ ;/ 第/ 5/ 节/ 给出/ 调度/ 算法/ 的/ 流程/ ;/ 在/ 第/ 6/ 节中/ ,/ 给出/ 以/ 一款/ 可/ 扩展/ 的/ 分/ 簇式/ VLIW/ 结构/ 为/ 目标/ 结构/ 所/ 得出/ 的/ 实验/ 数据/ ;/ 最后/ 是/ 结论/ 部分/ ./ 2/ 已有/ 分簇式/ 结构/ 调度/ 算法/ 的/ 回顾/ LC/ (/ Limited/ -/ Connectivity/ )/ 调度/ 算法/ [/ 7/ ]/ 首先/ 假设/ 指令/ 调度/ 是/ 在/ 一个/ 与/ 被/ 调度/ 的/ 分/ 簇式/ 结构/ 具有/ 同等/ 资源/ 的/ 全/ 互连/ 结构/ 下/ 进行/ ,/ 然后/ 再/ 分配/ 到/ 不同/ 簇中/ 需要/ 进行/ 簇间/ 数据/ 交互/ 的/ 指令/ 之间/ 插入/ 簇间/ 拷贝/ 指令/ ,/ 并/ 对/ 每个/ 簇中/ 的/ 指令/ 进行/ 局部/ 的/ 代码/ 压缩/ ./ 由于/ 在/ 调度/ 的/ 时候/ 完全/ 不/ 考虑/ 指令/ 的/ 分簇/ 情况/ ,/ 调度/ 结构/ 并/ 不/ 理想/ ,/ 相对/ 于全/ 互连/ 结构/ 性能/ 下降/ 量/ 较大/ [/ 2/ ]/ ./ BUG/ (/ Bottom/ -/ Up/ -/ Greedy/ )/ 算法/ [/ 8/ ]/ 采用/ 递归/ 调度/ 的/ 方法/ ,/ 首先/ 从/ 数据流/ 图/ 的/ 叶子/ 节点/ 开始/ 自/ 底向上/ 的/ 遍历/ 整个/ 数据流/ 图/ ,/ 并/ 根据/ 每个/ 节点/ 之前/ 所分/ Page3/ 配/ 的/ 操作数/ 和/ 目的/ 数/ 的/ 位置/ 来/ 估算/ 其/ 倾向/ 于/ 被/ 分配/ 的/ 功能/ 单元/ 的/ 集合/ ./ 当/ 遍历/ 到达/ 根/ 节点/ 后/ ,/ BUG/ 算法/ 又/ 由/ 顶/ 至/ 下/ 的/ 进行/ 一次/ 遍历/ ,/ 为/ 每个/ 节点/ 分配/ 合适/ 的/ 功能/ 单元/ [/ 6/ ]/ ./ 然而/ ,/ 因为/ 在/ 进行/ 簇/ 分配/ 时/ ,/ BUG/ 算法/ 只/ 关心/ 如何/ 使/ 指令/ 尽可能/ 早地/ 执行/ ,/ 具有/ 明显/ 的/ 局部性/ ,/ 限制/ 了/ 调度/ 的/ 效果/ ./ PCC/ (/ Partial/ -/ Component/ -/ Clustering/ )/ 算法/ 通过/ 将/ 原始数据/ 流图/ 中/ 的/ 部分/ 互连/ 的/ 节点/ 组合/ 成为/ “/ 宏/ 节点/ ”/ 来/ 降低/ 调度/ 的/ 复杂度/ [/ 9/ ]/ ./ 在/ 簇/ 分配/ 的/ 过程/ 中/ ,/ 组成/ 一个/ 宏/ 节点/ 的/ 所有/ 节点/ 被/ 看作/ 是/ 一个/ 节点/ ,/ 从而/ 被/ 分配/ 到/ 同一个/ 簇中/ ./ 虽然/ PCC/ 算法/ 可以/ 通过/ 宏/ 节点/ 来/ 缩小/ 解/ 空间/ 的/ 大小/ ,/ 但/ 在/ 其/ 循环/ 提高/ 过程/ 中/ ,/ 无法/ 准确/ 地/ 找出/ 代价/ 函数/ 迅速/ 下降/ 的/ 方向/ ,/ 因而/ 若宏/ 节点/ 小/ 则/ 计算/ 时间/ 长/ ,/ 若宏/ 节点/ 大则/ 影响/ 调度/ 效果/ ./ UAS/ (/ Unified/ -/ Assign/ -/ and/ -/ Schedule/ )/ 算法/ [/ 10/ ]/ 由/ 两层/ 循环/ 组成/ ./ 外层/ 循环/ 保证/ 所有/ 的/ 指令/ 最后/ 都/ 能/ 被/ 调度/ ,/ 内层/ 循环/ 将/ 尽可能/ 多/ 的/ 指令/ 安排/ 到/ 当前/ 周期/ 中/ ./ UAS/ 算法/ 将/ 簇间/ 的/ 互连/ 总线/ 看作/ 一种/ 资源/ ,/ 并/ 引入/ 多种/ 优先权/ 函数/ 来/ 指导/ 调度/ 和/ 分/ 簇地/ 进行/ ./ 但是/ ,/ UAS/ 算法/ 在/ 调度/ 时仅/ 考虑/ 了/ 前驱/ 指令/ 、/ 完成/ 时间/ 以及/ 关键/ 路径/ 等/ 因素/ ,/ 没有/ 考虑/ 到/ 其它/ 未/ 调度/ 指令/ 对/ 当前/ 指令/ 的/ 调度/ 的/ 影响/ ,/ 具有/ 较强/ 的/ 局部性/ ./ CARS/ (/ CombinedClusterAssignment/ ,/ RegisterAllocationandInstructionScheduling/ )/ 算法/ [/ 17/ ]/ 采用/ 一种/ 类似/ 于/ 列表/ 调度/ 算法/ 的/ 方式/ ./ 它/ 将/ 整个/ 调度/ 过程/ 分为/ 3/ 个/ 阶段/ :/ 在/ 第/ 1/ 阶段/ 中/ ,/ 会/ 初始化/ 和/ 建立/ 一些/ 算法/ 所/ 需要/ 的/ 数据结构/ ;/ 主要/ 的/ 工作/ 是/ 在/ 第/ 2/ 阶段/ 中/ 进行/ ,/ 指令/ 分簇/ 、/ 寄存器/ 分配/ 以及/ 指令/ 调度/ 同时/ 得到/ 结果/ ;/ 最后/ 一个/ 阶段/ 会/ 对/ 第/ 2/ 阶段/ 的/ 结果/ 进行/ 一些/ 优化/ ./ 在/ 第/ 2/ 阶段/ 里/ ,/ CARS/ 在/ 进行/ 分簇/ 和/ 调度/ 时/ ,/ 只/ 考虑/ 了/ 在/ 目前/ 情况/ 下/ ,/ 最优/ 的/ 簇/ 选择/ 方案/ ,/ 缺乏/ 全局/ 考虑/ ./ Intel/ 的/ 巴塞罗那/ 研究/ 中心/ 提出/ 了/ 一种/ 虚拟/ 簇/ 调度/ 算法/ [/ 16/ ]/ ,/ 利用/ 虚拟/ 簇/ 和/ 调度/ 图/ 的/ 概念/ 来/ 引导/ 分簇/ 过程/ ./ 这种/ 算法/ 将/ 簇/ 分配/ 的/ 决定/ 推迟/ 到/ 调度/ 阶段/ 来/ 进行/ ,/ 但/ 又/ 不/ 采取/ 分离/ 的/ 簇/ 分配/ 和/ 指令/ 调度/ 方式/ ./ 它/ 引入/ 调度/ 图/ 的/ 概念/ ,/ 来/ 描述/ 所有/ 可能/ 的/ 调度/ 方式/ ./ 引入/ 虚拟/ 簇/ 的/ 概念/ 来/ 确保/ 在/ 做出/ 单独/ 的/ 簇/ 分配/ 和/ 指令/ 调度/ 的/ 决定/ 的/ 情况/ 下/ ,/ 还/ 可以/ 使得/ 簇/ 分配/ 推迟/ 到/ 调度/ 过程/ 中/ 进行/ ./ 但是/ 这种/ 方式/ 过于/ 复杂/ ,/ 算法/ 执行/ 时间/ 消耗/ 较/ 多/ ./ 综上所述/ ,/ 现有/ 的/ 这些/ 针对/ 分簇式/ 系统/ 的/ 调度/ 算法/ 中/ 存在/ 着/ 以下/ 几个/ 问题/ :/ 性/ 考虑/ ;/ 调度/ 指令/ 的/ 影响/ ;/ (/ 1/ )/ 指令/ 调度/ 和/ 分/ 簇时/ 局部性/ 较强/ ,/ 缺乏/ 全局/ (/ 2/ )/ 无法/ 在/ 调度/ 时/ 考虑/ 到/ 未/ 调度/ 指令/ 对/ 当前/ 待/ (/ 3/ )/ 缺乏/ 对/ 提高/ 指令/ 级/ 并行度/ 与/ 减少/ 簇间/ 数据/ 这/ 也/ 正是/ 本文/ 所/ 提出/ 的/ 方法/ 所/ 要/ 解决/ 的/ 问题/ ,/ 我们/ 将/ 在/ 下面/ 的/ 章节/ 中/ 对此/ 方法/ 作出/ 详细/ 的/ 描述/ ./ 3/ 利用/ 数据/ 依赖图/ 来/ 最小化/ 交互/ 这/ 两者之间/ 的/ 统合/ ./ 簇间/ 数据/ 交互/ 一个/ 指令/ 除非/ 是/ 独立/ 的/ 指令/ ,/ 否则/ 必然/ 与/ 其它/ 指令/ 之间/ 存在/ 着/ 数据/ 交互/ ./ 在/ 调度/ 的/ 过程/ 中/ ,/ 当/ 考虑/ 一个/ 待/ 调度/ 的/ 指令/ 时/ ,/ 与/ 它/ 相关/ 的/ 数据/ 交互/ 可能/ 来自/ 已/ 调度/ 的/ 指令/ ,/ 也/ 可能/ 来自/ 未/ 调度/ 的/ 指令/ ./ 只有/ 将/ 与/ 这个/ 待/ 调度/ 指令/ 相关/ 的/ 所有/ 数据/ 交互/ 的/ 影响/ 都/ 考虑/ 进来/ ,/ 才能/ 作出/ 最合适/ 的/ 调度/ 安排/ ./ 现有/ 的/ 调度/ 算法/ 都/ 欠缺/ 对/ 未/ 调度/ 指令/ 的/ 影响/ 的/ 考虑/ ,/ 而/ 通过/ 数据/ 依赖图/ ,/ 我们/ 可以/ 将/ 这些/ 未/ 调度/ 指令/ 的/ 影响/ 也/ 加以/ 度量/ ./ 在/ 数据/ 依赖图/ 中/ ,/ 每/ 一个/ 节点/ 代表/ 了/ 一个/ 指令/ 操作/ ,/ 而/ 两个/ 节点/ 之间/ 的/ 连线/ 则/ 表示/ 这/ 两个/ 节点/ 之间/ 存在/ 着/ 数据/ 交互/ ./ 数据/ 依赖图/ 是/ 一个/ 有向图/ ,/ 连线/ 的/ 起始/ 节点/ 代表/ 数据/ 的/ 提供/ 方/ ,/ 而/ 终止/ 节点/ 则/ 是/ 数据/ 的/ 接收/ 方/ ./ 数据/ 的/ 接收/ 方/ 称为/ 数据/ 的/ 提供/ 方/ 的/ 后续/ 节点/ ,/ 而/ 数据/ 的/ 提供/ 方/ 称为/ 数据/ 的/ 接收/ 方/ 的/ 前驱/ 节点/ ./ 连线/ 的/ 起始/ 节点/ 和/ 终止/ 节点/ 之间/ 的/ 执行/ 时间/ 之差/ 称为/ 该/ 数据/ 交互/ 的/ 时间跨度/ ./ 当/ 某条/ 指令/ 被/ 调度/ 时/ ,/ 可以/ 将/ 此时/ 的/ 数据/ 依赖图/ 划分/ 为/ 3/ 个/ 部分/ ,/ 即/ 已/ 调度/ 的/ 数据/ 依赖图/ 部分/ (/ 简称/ 为/ 图/ S/ )/ ,/ 未/ 调度/ 的/ 且/ 是/ 当前/ 待/ 调度/ 指令/ 的/ 直接/ 或/ 间接/ 后续/ 节点/ 所/ 组成/ 的/ 数据/ 依赖图/ 部分/ (/ 简称/ 为/ 图/ C/ )/ 以及/ 剩下/ 的/ 未/ 调度/ 指令/ 所/ 组成/ 的/ 数据/ 依赖图/ 部分/ (/ 简称/ 为/ 图/ R/ )/ ./ 需要/ 注意/ 的/ 是/ ,/ 当前/ 待/ 调度/ 的/ 指令/ 也/ 是/ 被/ 划分/ 到/ 图/ C/ 中/ 的/ ./ 图/ 1/ 中/ 给出/ 了/ 一个/ 对/ 数据/ 依赖图/ 进行/ 划分/ 的/ 例子/ ,/ 在/ 这个/ 例子/ 里/ ,/ 指令/ 5/ 是/ 当前/ 待/ 调度/ 的/ 指令/ ,/ 而/ 指令/ 0/ 、/ 1/ 、/ 2/ 、/ 3/ 都/ 是/ 已/ 调度/ 的/ 指令/ ./ 因为/ 图/ C/ 中/ 的/ 指令/ 都/ 是/ 当前/ 待/ 调度/ 指令/ 的/ 直接/ 或者/ 间接/ 后续/ 指令/ ,/ 即/ 是/ 说/ 当前/ 待/ 调度/ 的/ 指令/ 的/ 调度/ 结果/ 会/ 对/ 图/ C/ 中/ 的/ 所有/ 指令/ 产生/ 影响/ ,/ 因而/ 如果/ 单纯/ 地/ 只/ 从/ 最小化/ 簇间/ 数据/ 交互/ 的/ 角度/ 来看/ ,/ 可以/ 假定/ 图/ C/ 中/ 的/ 指令/ 都/ 应该/ 和/ 当前/ 待/ 调度/ 指令/ 具/ Page4/ 有/ 相同/ 的/ 簇/ ./ 而图/ R/ 中/ 的/ 指令/ 都/ 未/ 调度/ ,/ 而且/ 也/ 不会/ 受到/ 当前/ 待/ 调度/ 指令/ 调度/ 结果/ 的/ 影响/ ,/ 所以/ 可以/ 暂/ 不/ 考虑/ ./ 因此/ ,/ 在/ 考虑/ 当前/ 待/ 调度/ 指令/ 时/ ,/ 最小化/ 调度/ 结果/ 中/ 簇间/ 数据/ 交互/ 的/ 问题/ 就/ 转化/ 为了/ 最小化/ 当前/ 待/ 调度/ 指令/ 的/ 图/ S/ 与/ 图/ C/ 之间/ 簇间/ 数据/ 交互/ 的/ 问题/ ./ 于是/ ,/ 通过/ 对/ 数据/ 依赖图/ 的/ 划分/ ,/ 不仅/ 考虑/ 到/ 了/ 未/ 调度/ 指令/ 对/ 当前/ 待/ 调度/ 指令/ 所/ 造成/ 的/ 影响/ ,/ 而且/ 可以/ 从/ 一个/ 较为/ 全局/ 的/ 角度/ 去/ 指导/ 指令/ 的/ 调度/ ./ 为了/ 进一步/ 对图/ S/ 与/ 图/ C/ 之间/ 的/ 数据/ 交互进行/ 分析/ ,/ 需要/ 为/ 每/ 一个/ 待/ 调度/ 的/ 指令/ i/ 引入/ 一个/ 引力/ 矩阵/ 犌/ 狉/ 狏/ 狋/ 狀/ i/ [/ Nc/ ]/ ,/ 这里/ Nc/ 代表/ 目标/ 结构/ 中簇/ 的/ 数目/ ./ 引力/ 矩阵/ 的/ 每/ 一个/ 分量/ 代表/ 了/ 对应/ 簇中/ 由/ 图/ S/ 到/ 图/ C/ 的/ 数据/ 交互/ 的/ 量/ ,/ 需要/ 注意/ 的/ 是/ ,/ 这里/ 的/ 量/ 不单是/ 指/ 数量/ ,/ 还/ 需要/ 把/ 数据/ 交互/ 的/ 时间跨度/ 考虑/ 进来/ ,/ 因为/ 不同/ 时间跨度/ 的/ 数据/ 交互/ 对/ 调度/ 结果/ 的/ 影响/ 也/ 不同/ ./ 从/ 最小化/ 簇间/ 数据/ 交互/ 的/ 出发点/ 来看/ ,/ 待/ 调度/ 的/ 指令/ 都/ 倾向/ 于/ 被/ 调度/ 到/ 具有/ 最大/ 引力/ 分量/ 的/ 簇/ 中/ ./ Grvtni/ [/ p/ ]/ ,/ 它/ 的/ 计算/ 方式/ 如下/ 式/ 所示/ 令待/ 调度/ 指令/ i/ 的/ 引力/ 矩阵/ 在/ 簇/ p/ 中/ 的/ 分量/ 为式/ 中/ e/ 代表/ 所有/ 由图/ S/ 到/ 图/ C/ 的/ 数据/ 交互/ ,/ 而/ Spane/ 则/ 代表/ 数据/ 交互/ e/ 的/ 时间跨度/ ./ 式/ 中/ δ/ e/ ,/ p/ 当/ 数据/ 交互/ e/ 的/ 数据/ 提供/ 方/ 调度/ 于/ 簇/ p/ 时值/ 为/ 1/ ,/ 否则/ 值为/ 0/ ./ 为了/ 计算/ 数据/ 交互/ e/ 的/ 时间跨度/ Spane/ ,/ 需要/ 为/ 每/ 一个/ 指令/ 引入/ 一个/ 参数/ ,/ 称之为/ 指令/ 的/ 高度/ (/ Height/ )/ ,/ 它/ 所/ 描述/ 的/ 是/ 每条/ 指令/ 要/ 达到/ 叶子/ 节点/ 指令/ 所/ 要/ 经过/ 的/ 距离/ 的/ 最大值/ ./ 根据/ 定义/ ,/ 数据/ 依赖图/ 中/ 所有/ 叶子/ 节点/ 指令/ 的/ 高度/ 均/ 为/ 0/ ./ 而/ 其余/ 指令/ 的/ 高度/ 的/ 计算/ 方式/ 如下/ 式/ 所示/ 式/ 中/ Hi/ 和/ Hj/ 分别/ 表示/ 指令/ i/ 和/ 指令/ j/ 的/ 高度/ ,/ 而/ Mi/ 是/ 所有/ 指令/ i/ 的/ 直接/ 后续/ 指令/ 的/ 集合/ ./ 式/ 中/ Max/ (/ )/ 表示/ 取/ 所有/ 指令/ j/ 高度/ 的/ 最大值/ ./ 图/ 2/ 中/ 给出/ 了/ 指令/ 高度/ 计算/ 的/ 一个/ 例子/ ./ 对于/ 待/ 调度/ 指令/ i/ ,/ 若有/ 一条/ 从图/ S/ 中/ 指令/ k/ 到/ 图/ C/ 中/ 指令/ j/ 的/ 数据/ 交互/ e/ ,/ 则/ e/ 的/ 时间跨度/ Spane/ 的/ 计算/ 方式/ 如下/ 式/ 所示/ 式/ 中/ cyck/ 表示/ 指令/ k/ 的/ 调度/ 周期/ ,/ Hi/ 和/ Hj/ 分别/ 表示/ 指令/ i/ 和/ 指令/ j/ 在/ 数据/ 依赖图/ 中/ 的/ 高度/ ,/ 而/ q/ 则/ 表示/ 当前/ 调度/ 周期/ ./ 于是/ 在/ 当前/ 调度/ 周期/ 下/ ,/ 若/ 将/ 待/ 调度/ 指令/ i/ 调度/ 引力/ 矩阵/ 中/ 各/ 分量/ 中/ 引力/ 值/ 最大/ 的/ 分量/ 所/ 对应/ 的/ 簇/ 中/ ,/ 就/ 可以/ 最小化/ 由于/ 指令/ i/ 的/ 调度/ 所/ 带来/ 的/ 簇间/ 数据/ 交互/ ./ 4/ 利用/ 数据/ 依赖图/ 来/ 最大化/ 指令/ 级/ 并行度/ 最大化/ 指令/ 级/ 并行度/ 与/ 最小化/ 簇间/ 数据/ 交互/ 是/ 互相矛盾/ 的/ ./ 最大化/ 指令/ 级/ 并行度/ 要求/ 将/ 指令/ 尽可能/ 平均/ 地/ 压缩/ 到/ 所有/ 簇中/ ,/ 以/ 获得/ 最短/ 的/ 执行/ 时间/ ,/ 但/ 这/ 可能/ 会/ 带来/ 大量/ 的/ 簇间/ 数据/ 交互/ ,/ 即/ 插入/ 大量/ 的/ 簇间/ 拷贝/ 指令/ ,/ 结果/ 导致/ 执行/ 时间/ 大大/ 加长/ ./ 而/ 最小化/ 簇间/ 数据/ 交互/ 则/ 倾向/ 于/ 将/ 所有/ 指令/ 安排/ 到/ 一个/ 簇中/ 执行/ ,/ 这样/ 会/ 让/ 执行/ 时间/ 拉得/ 很长/ ,/ 所/ 能/ 得到/ 的/ 指令/ 级/ 并行度/ 也/ 将/ 很/ 低/ ./ 所以/ 在/ 调度/ 时/ ,/ 必须/ 兼顾/ 两者/ ,/ 将/ 两者/ 有机/ 地/ 结合/ 在/ 一起/ ,/ 才能/ 通过/ 折中/ 得到/ 最/ Page5/ 好/ 的/ 性能/ ./ 最大化/ 指令/ 级/ 并行度/ 要求/ 把/ 指令/ 尽可能/ 平均/ 地/ 安排/ 到/ 所有/ 簇中/ ,/ 因此/ 也/ 可以/ 等同/ 为/ 平衡/ 各簇/ 的/ 利用率/ 情况/ ./ 要/ 平衡/ 各簇/ 的/ 利用率/ ,/ 首先/ 要/ 对/ 各/ 簇/ 的/ 利用率/ 情况/ 进行/ 统计/ ,/ 这/ 就/ 需要/ 对/ 数据/ 依赖图/ 进行/ 划分/ 与/ 分析/ ./ 这里/ 划分/ 数据/ 依赖图/ 的/ 方式/ 与/ 前/ 一节/ 相同/ ,/ 不同/ 的/ 是/ 只/ 需要/ 对图/ S/ 进行/ 分析/ ,/ 因为/ 只有/ 图/ S/ 中/ 的/ 指令/ 是/ 已经/ 调度/ 的/ ./ 为了/ 统计/ 各簇/ 的/ 利用率/ 情况/ ,/ 引入/ 一个/ 斥力/ 矩阵/ 犚/ 狆/ 犾/ q/ [/ Nc/ ]/ ./ 这里/ Nc/ 表示/ 目标/ 结构/ 中/ 的/ 簇/ 的/ 数目/ ,/ 而/ q/ 则/ 代表/ 当前/ 调度/ 周期/ ./ 斥力/ 矩阵/ 的/ 每/ 一个/ 分量/ 表示/ 对应/ 簇/ 的/ 使用/ 情况/ ./ 令/ 在/ 当前/ 调度/ 周期/ 为/ q/ 时/ ,/ 斥力/ 矩阵/ 在/ 簇/ p/ 中/ 的/ 分量/ 为/ Rplq/ [/ p/ ]/ ,/ 则/ 它/ 的/ 计算/ 方式/ 如下/ 式/ 所示/ 式/ 中/ S/ 代表/ 图/ S/ 中/ 的/ 所有/ 指令/ 组成/ 的/ 集合/ ,/ θ/ j/ ,/ p/ 在/ 指令/ j/ 调度/ 于/ 簇/ p/ 中/ 时值/ 为/ 1/ ,/ 否则/ 值为/ 0/ ./ 于是/ 通过/ 对/ 数据/ 依赖图/ 的/ 划分/ 和/ 分析/ ,/ 就/ 可以/ 对/ 当前/ 调度/ 周期/ 下/ 的/ 各/ 簇/ 的/ 利用率/ 情况/ 进行/ 统计/ ./ 如果/ 单从/ 平衡/ 各簇/ 的/ 利用率/ (/ 也/ 即/ 是/ 最大化/ 指令/ 级/ 并行度/ )/ 的/ 角度/ 来看/ ,/ 应该/ 将/ 当前/ 待/ 调度/ 指令/ 分配/ 到/ 斥力/ 矩阵/ 中/ 具有/ 最小/ 分量/ 的/ 对应/ 簇中/ ./ 5/ 调度/ 流程/ 参数/ ./ 在/ 图/ 3/ 中/ 我们/ 给出/ 了/ 利用/ 对/ 数据/ 依赖图/ 的/ 划分/ 和/ 分析/ 而/ 对/ 调度/ 进行/ 引导/ 的/ 调度/ 算法/ 的/ 总体/ 流程图/ ./ 下面/ 介绍/ 其中/ 几个/ 比较/ 重要/ 的/ 环节/ ./ (/ 1/ )/ 调用/ ASAP/ 和/ ALAP/ 调度/ 算法/ 计算所/ 需/ ASAP/ (/ AsSoonAsPossible/ )/ 调度/ 算法/ 为/ 每/ 一条/ 指令/ 所/ 分配/ 的/ 执行/ 周期/ 为/ 该/ 指令/ 最早/ 可/ 执行/ 的/ 周期/ ,/ 而/ ALAP/ (/ AsLateAsPossible/ )/ 调度/ 算法/ 为/ 每/ 一条/ 指令/ 所/ 分配/ 的/ 执行/ 周期/ 则/ 为/ 该/ 指令/ 最迟/ 可/ 执行/ 的/ 周期/ ./ 令/ 指令/ i/ 最早/ 可/ 执行/ 的/ 周期/ 为/ CEi/ ,/ 其/ 最迟/ 可/ 执行/ 的/ 周期/ 为/ CLi/ ,/ 则/ 定义/ 指令/ 的/ 机动性/ Mi/ 为/ 这里/ 一条/ 指令/ 的/ 机动性/ 表征/ 了/ 该/ 指令/ 的/ 调度/ 时间/ 对/ 整体/ 调度/ 执行/ 时间/ 的/ 影响/ 程度/ ./ 显然/ ,/ 机动性/ 为/ 1/ 的/ 指令/ ,/ 即/ 最早/ 可/ 执行/ 时间/ 和/ 最迟/ 可/ 执行/ 时间/ 相等/ 的/ 指令/ 的/ 调度/ 时间/ 对/ 整体/ 调度/ 执行/ 时间/ 的/ 影响/ 是/ 最大/ 的/ ./ (/ 2/ )/ 根据/ 优先权/ 顺序/ 挑选/ 待/ 调度/ 指令/ ./ 在/ 调度/ 过程/ 中/ ,/ 所有/ 当前/ 可/ 调度/ 的/ 指令/ 都/ 被/ 包含/ 在/ 一个/ 可/ 调度/ 指令/ 列表/ 之中/ ./ 为了/ 保证/ 对/ 整体/ 调度/ 执行/ 时间/ 影响/ 最大/ 的/ 指令/ 优先/ 被/ 调度/ ,/ 必须/ 规定/ 一系列/ 的/ 挑选/ 待/ 调度/ 指令/ 的/ 原则/ ,/ 根据/ 这些/ 原则/ 来/ 确定/ 指令/ 之间/ 的/ 优先/ 顺序/ ./ 在/ 本文/ 所/ 提出/ 的/ 算法/ 里/ ,/ 我们/ 规定/ 了/ 4/ 条/ 挑选/ 待/ 调度/ 指令/ 的/ 原则/ ,/ 下面/ 根据/ 这/ 4/ 条/ 原则/ 的/ 优先级/ 高低/ 顺序/ 分别/ 加以/ 阐述/ ./ 节中/ 已经/ 给出/ ,/ 这里/ 不再/ 赘述/ ./ ①/ 机动性/ 为/ 1/ 的/ 指令/ 优先/ 调度/ ./ 其/ 原因/ 在/ 5.1/ ②/ 最迟/ 可/ 执行/ 时间/ 早/ 的/ 指令/ 优先/ 调度/ ./ ALAP/ 调度/ 算法/ 根据/ 数据/ 依赖/ 关系/ 给出/ 每条/ 指令/ 的/ 最迟/ 可/ 执行/ 时间/ ,/ 最迟/ 可/ 执行/ 时间/ 越早/ 的/ 指令/ 说明/ 需要/ 使用/ 它/ 产生/ 的/ 数据/ 的/ 指令/ 的/ 执行/ 时间/ 越/ 早/ ,/ 推迟/ 它/ 的/ 执行/ 将会/ 影响/ 后续/ 指令/ 的/ 执行/ ,/ 从而/ 导致/ 整体/ 调度/ 执行/ 时间/ 延长/ ./ ③/ 指令/ 高度/ 高/ 的/ 指令/ 优先/ 调度/ ./ 指令/ 高度/ 的/ 定义/ 在/ 第/ 3/ 节中/ 已经/ 给出/ ,/ 指令/ 高度/ 越高/ 的/ 指令/ ,/ 说明/ 它/ Page6/ 距离/ 叶子/ 节点/ 的/ 距离/ 越/ 远/ ,/ 也就是说/ 依赖于/ 它/ 的/ 数据/ ,/ 在/ 它/ 之后/ 要/ 执行/ 的/ 指令/ 数越/ 多/ ,/ 因此/ 应该/ 优先/ 调度/ ./ ④/ 指令/ 规模/ 大/ 的/ 指令/ 优先/ 调度/ ./ 定义/ 一条/ 指令/ 的/ 规模/ (/ Scale/ )/ 为/ 数据/ 依赖图/ 中其/ 直接/ 或/ 间接/ 后续/ 指令/ 的/ 数目/ ./ 根据/ 此/ 定义/ ,/ 数据/ 依赖图/ 中/ 的/ 所有/ 叶子/ 节点/ 的/ 规模/ 都/ 为/ 0/ ./ 在/ 图/ 4/ 中/ 给出/ 了/ 一个/ 例子/ 说明/ 指令/ 规模/ 的/ 计算方法/ ./ 方案/ ./ 根据/ 这/ 4/ 条/ 原则/ ,/ 从/ 可/ 调度/ 列表/ 中/ 挑选出/ 指令/ 进行/ 调度/ ,/ 就/ 可以/ 保证/ 对/ 整体/ 调度/ 执行/ 时间/ 影响/ 较大/ 的/ 指令/ 能够/ 优先/ 得以/ 调度/ ./ (/ 3/ )/ 计算/ 引力/ 矩阵/ 和/ 斥力/ 矩阵/ ,/ 决定/ 指令/ 调度/ 在/ 根据/ 优先权/ 顺序/ 挑选出/ 待/ 调度/ 指令/ 之后/ ,/ 就/ 需要/ 计算/ 当前/ 待/ 调度/ 指令/ 的/ 引力/ 矩阵/ 和/ 当前/ 调度/ 周期/ 的/ 斥力/ 矩阵/ ./ 为了/ 综合/ 考虑/ 引力/ 矩阵/ 与/ 斥力/ 矩阵/ 对/ 当前/ 待/ 调度/ 指令/ 的/ 影响/ ,/ 这里/ 引入/ 一个/ 合力/ 矩阵/ 犉/ [/ Nc/ ]/ ,/ Nc/ 代表/ 目标/ 结构/ 中簇/ 的/ 数目/ ./ 假设/ 当前/ 待/ 调度/ 指令/ 为/ i/ ,/ 当前/ 调度/ 周期/ 为/ q/ ,/ 那么/ 引力/ 矩阵/ 和/ 斥力/ 矩阵/ 在/ 簇/ p/ 中所/ 产生/ 的/ 合力/ Fi/ ,/ q/ [/ p/ ]/ 的/ 计算/ 方式/ 如下/ 式/ 所示/ 式/ 中/ c/ 代表/ 目标/ 结构/ 中除/ 簇/ p/ 以外/ 的/ 所有/ 簇/ ./ 通过/ 上式/ 就/ 可以/ 在/ 调度/ 时/ 同时/ 考虑/ 到/ 最小化/ 簇间/ 数据/ 交互/ 和/ 最大化/ 指令/ 级/ 并行度/ ,/ 待/ 调度/ 的/ 指令/ 将会/ 被/ 调度/ 到/ 合力/ 矩阵/ 所有/ 分量/ 中/ 具有/ 最小值/ 的/ 分量/ 所/ 对应/ 的/ 簇/ 中/ ./ (/ 4/ )/ 算法/ 复杂度/ 分析/ ./ 令/ 数据/ 依赖图/ 中/ 的/ 指令/ 个数/ 为/ |/ N/ |/ ,/ 数据/ 依赖图/ 中/ 的/ 边/ 的/ 数目/ 为/ |/ E/ |/ ./ 对于/ 每/ 一条/ 指令/ ,/ 在/ 计算/ 引力/ 矩阵/ 时/ ,/ 最坏/ 情况/ 下/ 的/ 工作量/ 为/ O/ (/ |/ E/ |/ )/ ,/ 而/ 在/ 计算/ 斥力/ 矩阵/ 时/ ,/ 最坏/ 情况/ 下/ 的/ 工作量/ 为/ O/ (/ |/ N/ |/ )/ ./ 因此/ ,/ 算法/ 最多/ 在/ O/ (/ |/ N/ |/ (/ |/ N/ |/ +/ |/ E/ |/ )/ )/ 时间/ 内/ 完成/ ./ 6/ 实验/ 结果/ 为了/ 验证/ 本文/ 所/ 提出/ 的/ 通过/ 对/ 数据/ 依赖图/ 的/ 划分/ 和/ 分析/ 从而/ 最小化/ 簇间/ 数据/ 交互/ 和/ 最大化/ 指令/ 级/ 并行度/ 的/ 方法/ 的/ 有效性/ ,/ 我们/ 以/ 一款/ 可/ 扩展/ 的/ 分簇/ VLIW/ 结构/ [/ 11/ ]/ 作为/ 目标/ 结构/ 进行/ 了/ 实验/ ./ 簇/ 的/ 数目/ 被/ 设置/ 为/ 2/ 簇/ 和/ 4/ 簇/ ,/ 而/ 簇/ 之间/ 的/ 互连/ 则/ 分别/ 采取/ 了/ 总线/ 互连/ 方式/ 与/ 寄存器/ 堆/ 互连/ 方式/ ./ 每个/ 簇中/ 都/ 有/ 3/ 种/ 类型/ 的/ 功能/ 单元/ ,/ 分别/ 为/ AL/ 单元/ 、/ LS/ 单元/ 和/ MP/ 单元/ ./ AL/ 单元/ 可以/ 执行/ 所有/ 的/ 算术/ 操作/ ,/ LS/ 单元/ 负责/ 执行/ 对/ 内存/ 的/ 存取/ 操作/ 、/ 跳转/ 和/ 数据/ 移动/ 操作/ 以及/ 一些/ 算术/ 操作/ ,/ 而/ MP/ 单元/ 则/ 负责/ 进行/ 乘法/ 操作/ [/ 11/ ]/ ./ 实验/ 的/ 输入/ 来自/ 于/ UTDSP/ [/ 12/ ]/ kernel/ 部分/ 的/ 6/ 个/ 测试程序/ ./ 为了/ 更好/ 地/ 做出/ 比较/ ,/ 这里/ 还/ 同时/ 给出/ 了/ 列表/ 调度/ 和/ UAS/ 调度/ 的/ 结果/ ./ 6.1/ 总线/ 互连/ 方式/ 分簇/ 结构/ 的/ 实验/ 结果/ 结构/ 如图/ 5/ 所示/ ,/ 2/ 簇/ 处理器/ 的/ 结构/ 与其/ 类似/ ./ 本/ 实验所/ 采用/ 的/ 总线/ 互连/ 方式/ 的/ 4/ 簇/ 处理器/ 的/ 如图/ 5/ 中/ 所示/ ,/ 各簇/ 的/ 功能/ 单元/ 可以/ 自由/ 地/ 访问/ 簇内/ 的/ 寄存器/ 堆中/ 的/ 数据/ ,/ 而/ 簇间/ 的/ 数据/ 交互/ 必须/ 经由/ 总线/ 通过/ 专门/ 的/ 功能/ 单元/ 执行/ 簇间/ 数据/ 拷贝/ 指令/ 来/ 完成/ ./ 在/ 本/ 结构/ 中/ ,/ 使用/ 每个/ 簇/ 的/ LS/ 单元/ 来/ 执行/ 簇间/ 数据/ 拷贝/ 指令/ ./ 图/ 6/ 中/ 显示/ 了/ 在/ 2/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 调度/ 后/ 簇间/ 数据/ 交互/ 量/ 的/ 比较/ ,/ 4/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 的/ 比较/ 结果/ 见图/ 7/ ./ 从图/ 中/ 可以/ 看出/ ,/ 通过/ 对/ 数据/ 依赖图/ 的/ 划分/ 和/ 分析/ ,/ 可以/ 成功/ 地/ 引导/ 指令/ 调度/ 最小化/ 簇间/ 数据/ 交互/ ./ Page7/ 图/ 62/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 簇间/ 数据/ 交互/ 量/ 的/ 比较/ 图/ 74/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 簇间/ 数据/ 交互/ 量/ 的/ 比较/ 在/ 总线/ 互连/ 式/ 分簇/ 结构/ 中/ ,/ 当有/ 簇间/ 数据/ 交互/ 发生/ 时/ ,/ 需要/ 插入/ 簇间/ 数据/ 拷贝/ 指令/ ,/ 通过/ 总线/ 进行/ 数据/ 的/ 挪动/ ,/ 以/ 保证/ 指令/ 的/ 正常/ 执行/ ./ 因此/ 相比/ 于/ 未/ 调度/ 之前/ 的/ 代码/ 长度/ ,/ 总线/ 互连/ 式/ 结构/ 调度/ 之后/ 的/ 代码/ 长度/ 将会/ 增长/ ./ 令/ 调度/ 之前/ 的/ 代码/ 长度/ 为/ NB/ ,/ 调度/ 之后/ 的/ 代码/ 长度/ 为/ NA/ ,/ 则/ NB/ 与/ NA/ 之间/ 的/ 比较/ 可以/ 作为/ 衡量/ 代码/ 长度/ 增加量/ 的/ 一个/ 标准/ ,/ 称其为/ 代码/ 长度/ 增加率/ CAB/ ,/ 它/ 的/ 计算/ 方式/ 如下/ 式/ 所示/ 代码/ 长度/ 增加率/ 可以/ 作为/ 衡量/ 调度/ 算法/ 效率/ 的/ 一个/ 标准/ [/ 13/ -/ 14/ ]/ ./ 显然/ ,/ 对于/ 全/ 互连/ 结构/ ,/ 因为/ 不/ 需要/ 插入/ 簇间/ 拷贝/ 指令/ ,/ 其/ 调度/ 之后/ 的/ 代码/ 长度/ 应该/ 与/ 调度/ 前/ 相等/ ,/ 所以/ 代码/ 长度/ 增加率/ 应该/ 为/ 0/ ./ 因此/ ,/ 代码/ 长度/ 增加率/ 越小/ ,/ 说明/ 调度/ 算法/ 得出/ 的/ 调度/ 结果/ 的/ 效果/ 越好/ ./ 表/ 1/ 中/ 给出/ 了/ 在/ 2/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 代码/ 长度/ 增加率/ CAB/ 的/ 比较/ 结果/ ,/ 4/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 的/ 比较/ 见表/ 2/ ./ 通过/ 比较/ 可见/ ,/ 由于/ 数据/ 依赖图/ 引导/ 的/ 调度/ 算法/ 极大/ 地/ 减少/ 了/ 簇间/ 数据/ 交互/ ,/ 因此/ 相比/ 于/ 列表/ 调度/ 算法/ 与/ UAS/ 调度/ 算法/ 能够/ 得到/ 一个/ 更/ 小/ 的/ 代码/ 长度/ 增加率/ ./ 由于/ 相比/ 于全/ 互连/ 结构/ ,/ 总线/ 互连/ 式/ 分簇/ 结构/ 的/ 代码/ 长度/ 增加/ 了/ ,/ 因此/ 执行/ 指令/ 序列/ 所/ 需/ 的/ 时间/ 也/ 会/ 相应/ 的/ 增加/ ./ 表/ 12/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 代码/ 长度/ 增加率/ 的/ 比较/ 测试程序/ 名/ fft57/ ./ 4041.30/ fir49/ ./ 3525.32/ iir75/ ./ 6834.89/ latnrm62/ ./ 7332.27/ lmsfir52/ ./ 7329.09/ mult46/ ./ 9729.80/ 平均值/ 57.4832/ ./ 11/ 表/ 24/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 代码/ 长度/ 增加率/ 的/ 比较/ 测试程序/ 名/ fft87/ ./ 8054.55/ fir82/ ./ 4740.26/ iir93/ ./ 1248.65/ latnrm93/ ./ 1852.27/ lmsfir75/ ./ 7646.67/ mult78/ ./ 7936.36/ 平均值/ 85.1946/ ./ 46/ 图/ 8/ 中/ 给出/ 了/ 2/ 簇/ 总线/ 互连/ 式/ 结构/ 下/ 调度/ 后/ 周期/ 数/ 的/ 比较/ ,/ 为了/ 更好/ 地/ 作出/ 比/ 对/ ,/ 同时/ 给出/ 了/ 全/ 互连/ 结构/ 下/ 调度/ 后/ 的/ 周期/ 数/ ./ 图/ 9/ 中/ 给出/ 了/ 4/ 簇/ 总线/ 互连/ 式/ 结构/ 下/ 的/ 比较/ 结果/ ./ 图/ 82/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 调度/ 后/ 执行/ 周期/ 数/ 的/ 比较/ 图/ 94/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 调度/ 后/ 执行/ 周期/ 数/ 的/ 比较/ 由于/ 代码/ 长度/ 增加率/ 较/ 小/ ,/ 因此/ 数据/ 依赖图/ 引导/ 的/ 调度/ 算法/ 的/ 调度/ 结果/ 相比/ 于全/ 互连/ 结构/ 的/ 调度/ 结果/ 在/ 执行/ 周期/ 数/ 的/ 增加量/ 上/ 也/ 较/ 小/ ./ 令/ 调度/ 后/ 的/ 执行/ 周期/ 数为/ L/ ,/ 则/ 通过/ 调度/ 后/ 执行/ 周期/ 数/ L/ 与/ 调度/ 后/ 代码/ 长度/ NA/ 的/ 比较/ 就/ 可以/ 得到/ 调度/ 后/ 的/ 指令/ 级/ 并行度/ ,/ 其/ 计算/ 方式/ 如下/ 式/ 所示/ Page8/ 显然/ ,/ 因为/ 全/ 互连/ 结构/ 的/ 调度/ 后/ 代码/ 长度/ 短于/ 总线/ 互连/ 方式/ 分簇/ 结构/ 的/ 代码/ 长度/ ,/ 而且/ 全/ 互连/ 结构/ 的/ 调度/ 后/ 执行/ 周期/ 数/ 也/ 少于/ 总线/ 互连/ 式/ 分簇/ 结构/ ,/ 所以/ 全/ 互连/ 结构/ 的/ 指令/ 级/ 并行度/ 必然/ 是/ 最高/ 的/ ./ 表/ 3/ 和表/ 4/ 分别/ 给出/ 了/ 2/ 簇/ 与/ 4/ 簇/ 总线/ 互连/ 式/ 结构/ 下/ 调度/ 后/ 指令/ 级/ 并行度/ 的/ 比较/ ,/ 表中/ ILP/ 数值/ 的/ 单位/ 为/ 指令/ 数/ // 周期/ ./ 测试程序/ 名/ fft3/ ./ 053.324/ ./ 394.64/ fir2/ ./ 913.063/ ./ 563.85/ iir3/ ./ 083.814/ ./ 084.47/ latnrm2/ ./ 843.424/ ./ 314.40/ lmsfir2/ ./ 803.043/ ./ 313.75/ mult3/ ./ 033.383/ ./ 894.40/ 平均值/ 2.953/ ./ 343.924/ ./ 25/ 测试程序/ 名/ fft5/ ./ 245.896/ ./ 699.17/ fir4/ ./ 685.846/ ./ 357.33/ iir5/ ./ 316.657/ ./ 828.85/ latnrm4/ ./ 835.788/ ./ 468.80/ lmsfir5/ ./ 095.636/ ./ 217.50/ mult5/ ./ 136.146/ ./ 348.25/ 平均值/ 5.055/ ./ 996.988/ ./ 32/ 从/ 比较/ 可以/ 看出/ ,/ 通过/ 对/ 数据/ 依赖图/ 的/ 划分/ 和/ 分析/ ,/ 可以/ 引导/ 指令/ 调度/ 最大化/ 可/ 取得/ 的/ 指令/ 级/ 并行度/ ./ 令全/ 互连/ 结构/ 的/ 调度/ 后/ 执行/ 周期/ 数为/ LF/ ,/ 总线/ 互连/ 式/ 分簇/ 结构/ 的/ 调度/ 后/ 执行/ 周期/ 数为/ LC/ ,/ 则/ LF/ 与/ LC/ 的/ 比值/ 可以/ 做/ 为/ 两种/ 结构/ 性能/ 之间/ 的/ 一个/ 比较/ ,/ 称为/ 总线/ 式/ 分簇/ 结构/ 相对/ 于全/ 互连/ 结构/ 的/ 性能比/ RCF/ ,/ 其/ 计算/ 方式/ 如下/ 式/ 所示/ RCF/ 可以/ 作为/ 衡量/ 分簇式/ 结构/ 调度/ 算法/ 效果/ 的/ 一个/ 标准/ [/ 13/ -/ 14/ ]/ ./ 显然/ ,/ RCF/ 越大/ ,/ 说明/ 分簇式/ 结构/ 调度/ 后/ 的/ 性能/ 相比/ 于全/ 互连/ 结构/ 的/ 性能/ 下降/ 的/ 比率/ 越小/ ,/ 调度/ 算法/ 的/ 效率/ 越高/ ./ 表/ 5/ 中/ 显示/ 了/ 在/ 2/ 簇/ 总线/ 互连/ 式/ 结构/ 中/ 性能比/ 比较/ 的/ 结果/ ,/ 4/ 簇/ 总线/ 互连/ 式/ 结构/ 的/ 比较/ 结构/ 如表/ 6/ 中/ 所示/ ./ 表/ 52/ 簇/ 总线/ 式/ 互连/ 结构/ 中/ 调度/ 后/ 性能比/ 的/ 比较/ 测试程序/ 名/ fft41/ ./ 7150.61/ fir50/ ./ 6363.49/ iir39/ ./ 2263.19/ latnrm39/ ./ 6858.82/ lmsfir48/ ./ 8962.86/ mult46/ ./ 8859.21/ 平均值/ 44.5059/ ./ 70/ 表/ 64/ 簇/ 总线/ 式/ 互连/ 结构/ 中/ 调度/ 后/ 性能比/ 的/ 比较/ 测试程序/ 名/ fft30/ ./ 4341.58/ fir35/ ./ 0056.76/ iir31/ ./ 0850.55/ latnrm28/ ./ 4143.10/ lmsfir38/ ./ 6051.16/ mult34/ ./ 7854.55/ 平均值/ 33.0549/ ./ 62/ 通过/ 对/ 数据/ 依赖图/ 的/ 划分/ 和/ 分析/ ,/ 可以/ 使得/ 调度/ 结果/ 中所能/ 取得/ 的/ 指令/ 级/ 并行度/ 最大化/ ,/ 因而/ 其/ 调度/ 结果/ 相对/ 于全/ 互连/ 结构/ 的/ 性能比/ 最大/ ./ 6.2/ 寄存器/ 堆/ 互连/ 方式/ 分簇/ 结构/ 的/ 实验/ 结果/ 寄存器/ 堆/ 互连/ 式/ 分簇/ 结构/ 中/ 簇间/ 的/ 互连/ 是/ 通过/ 一个/ 全局/ 寄存器/ 堆来/ 实现/ 的/ [/ 15/ ]/ ./ 在/ 图/ 10/ 中/ 给出/ 了/ 4/ 簇/ 寄存器/ 堆/ 互连/ 结构/ 的/ 结构图/ ,/ 2/ 簇/ 寄存器/ 堆/ 互连/ 结构/ 的/ 结构图/ 与其/ 类似/ ./ 如图/ 10/ 所示/ ,/ 寄存器/ 堆/ 互连/ 方式/ 分簇/ 结构/ 中/ 各/ 簇/ 内部/ 的/ 局部/ 寄存器/ 堆/ 可以/ 被/ 本/ 簇/ 的/ 功能/ 单元/ 自由/ 访问/ ,/ 而/ 全局/ 寄存器/ 堆则/ 可以/ 被/ 任何/ 簇中/ 的/ 功能/ 单元/ 所/ 访问/ ,/ 因此/ 全局/ 寄存器/ 可以/ 作为/ 簇间/ 数据/ 交互/ 的/ 渠道/ ./ 与/ 总线/ 互连/ 方式/ 分簇/ 结构/ 不同/ 的/ 是/ ,/ 在/ 处理/ 簇间/ 数据/ 交互/ 时/ ,/ 寄存器/ 堆/ 互连/ 方式/ 分簇/ 结构/ 不/ 需要/ 增加/ 额外/ 的/ 簇间/ 数据/ 拷贝/ 指令/ ,/ 当/ 需要/ 进行/ 簇间/ 数据/ 交互/ 时/ ,/ 只/ 需/ 把/ 要/ 交互/ 的/ 数据/ 直接/ 存放/ 在/ 全局/ 寄/ Page9/ 存器/ 堆/ 中/ ,/ 需要/ 数据/ 的/ 功能/ 单元/ 可以/ 直接/ 从/ 全局/ 寄存器/ 堆中/ 读取/ 该/ 数据/ ,/ 因此/ 由于/ 簇间/ 拷贝/ 指令/ 的/ 插入/ 所/ 导致/ 的/ 调度/ 执行/ 时间/ 的/ 增加/ 也/ 就/ 可以/ 避免/ ./ 但是/ ,/ 如同/ 在/ 总线/ 互连/ 方式/ 分簇/ 结构/ 中/ ,/ 可以/ 用于/ 执行/ 簇间/ 数据/ 拷贝/ 指令/ 的/ 功能/ 单元/ 的/ 数目/ 会/ 制约/ 簇间/ 数据/ 交互/ ,/ 在/ 寄存器/ 堆/ 互连/ 方式/ 分簇/ 结构/ 中/ ,/ 对/ 全局/ 寄存器/ 堆/ 的/ 访问/ 端口/ 的/ 数目/ 也/ 会/ 制约/ 簇间/ 数据/ 交互/ 的/ 实现/ ./ 实验/ 中/ 所用/ 到/ 的/ 结构/ 里/ ,/ 每个/ 簇/ 访问/ 全局/ 寄存器/ 的/ 端口/ 有/ 两个/ 读/ 端口/ ,/ 一个/ 写/ 端口/ ./ 当/ 在/ 一个/ 周期/ 里/ ,/ 某个/ 簇中/ 对/ 全局/ 寄存器/ 的/ 访问/ 次数/ 超过/ 了/ 端口/ 数目/ 时/ ,/ 就/ 会/ 发生/ 全局/ 寄存器/ 访问/ 冲突/ ./ 全局/ 寄存器/ 访问/ 冲突/ 会/ 导致/ 某些/ 指令/ 的/ 执行/ 必须/ 推迟/ ,/ 从而/ 导致/ 调度/ 后/ 整体/ 执行/ 时间/ 的/ 延长/ ./ 因为/ 实验/ 中/ 所用/ 到/ 的/ 总线/ 互连/ 式/ 分簇/ 结构/ 与/ 寄存器/ 堆/ 互连/ 式/ 分簇/ 结构/ 中/ 的/ 资源/ 的/ 数目/ 是/ 相同/ 的/ ,/ 因此/ 调度/ 后/ 簇间/ 数据/ 交互/ 的/ 量/ 是/ 相同/ 的/ ,/ 这里/ 就/ 不再/ 重复/ 给出/ ./ 而/ 由于/ 在/ 寄存器/ 堆/ 互连/ 方式/ 分簇/ 结构/ 中/ ,/ 簇间/ 数据/ 交互/ 不/ 需要/ 通过/ 额外/ 的/ 簇间/ 拷贝/ 指令/ 来/ 完成/ ,/ 因此/ 调度/ 后/ 的/ 代码/ 长度/ 也/ 就/ 不会/ 增加/ ./ 但/ 由于/ 全局/ 寄存器/ 访问/ 冲突/ 的/ 存在/ ,/ 全局/ 寄存器/ 堆/ 互连/ 方式/ 分簇/ 结构/ 调度/ 后/ 的/ 执行/ 周期/ 相比/ 于全/ 互连/ 结构/ 还是/ 会/ 有所增加/ ./ 图/ 11/ 和/ 图/ 12/ 分别/ 示出/ 了/ 在/ 2/ 簇/ 和/ 4/ 簇/ 寄存器/ 堆/ 互连/ 方式/ 结构/ 中/ 相比/ 于全/ 互连/ 结构/ ,/ 调度/ 后/ 执行/ 周期/ 的/ 增加/ 情况/ ./ 图/ 112/ 簇/ 寄存器/ 堆/ 互连/ 方式/ 结构/ 中/ 调度/ 后/ 可以/ 看出/ 由于/ 对/ 数据/ 依赖图/ 的/ 划分/ 和/ 分析/ ,/ 减少/ 了/ 调度/ 结果/ 中/ 簇间/ 数据/ 交互/ 量/ ,/ 从而/ 减少/ 了/ 对/ 全局/ 寄存器/ 堆/ 的/ 访问量/ ,/ 因此/ 能够/ 有助于/ 减少/ 全局/ 寄存器/ 访问/ 冲突/ 出现/ 的/ 次数/ ,/ 最终/ 导致/ 调度/ 后/ 整体/ 执行/ 周期/ 数/ 的/ 减少/ ./ 这里/ 同样/ 可以/ 通过/ 计算/ 调度/ 后/ 代码/ 长度/ 与/ 调度/ 后/ 执行/ 周期/ 数/ 的/ 比值/ 得到/ 调度/ 后/ 指令/ 级/ 并行度/ 的/ 数值/ ./ 表/ 7/ 中/ 给出/ 了/ 2/ 簇/ 寄存器/ 堆/ 互连/ 方式/ 结构/ 中/ 调度/ 后/ 指令/ 级/ 并行度/ 的/ 比较/ 结果/ ,/ 4/ 簇/ 寄存器/ 堆/ 互连/ 方式/ 结构/ 的/ 比较/ 结构/ 如表/ 8/ 中/ 所示/ ./ 表/ 72/ 簇/ 寄存器/ 堆/ 互连/ 方式/ 结构/ 中/ 调度/ 结果/ 中/ 测试程序/ 名/ fft3/ ./ 033.674/ ./ 644.64/ fir3/ ./ 143.503/ ./ 673.85/ iir2/ ./ 623.994/ ./ 474.47/ latnrm2/ ./ 723.934/ ./ 404.40/ lmsfir2/ ./ 953.593/ ./ 593.75/ mult3/ ./ 253.964/ ./ 134.40/ 平均值/ 2.953/ ./ 774.154/ ./ 25/ 表/ 84/ 簇/ 寄存器/ 堆/ 互连/ 方式/ 结构/ 中/ 调度/ 结果/ 中/ 测试程序/ 名/ fft4/ ./ 876.118/ ./ 199.17/ fir4/ ./ 165.927/ ./ 007.33/ iir4/ ./ 526.077/ ./ 688.85/ latnrm4/ ./ 405.958/ ./ 158.80/ lmsfir4/ ./ 466.116/ ./ 887.50/ mult4/ ./ 607.337/ ./ 928.25/ 平均值/ 4.506/ ./ 257.648/ ./ 32/ 可以/ 看出/ ,/ 由于/ 在/ 对/ 数据/ 依赖图/ 进行/ 划分/ 和/ 分析/ 后/ ,/ 所/ 引导/ 出/ 的/ 调度/ 结果/ 具有/ 较/ 短/ 的/ 整体/ 指令/ 执行/ 周期/ ,/ 因而/ 能够/ 获得/ 最大化/ 的/ 指令/ 级/ 并行度/ ./ 表/ 9/ 和表/ 10/ 中/ 分别/ 给出/ 了/ 在/ 2/ 簇/ 和/ 4/ 簇/ 寄存器/ 堆/ 互连/ 方式/ 结构/ 中/ 相比/ 于全/ 互连/ 结构/ 调度/ 结果/ 性能比/ RCF/ 的/ 比较/ 结果/ ./ 可见/ ,/ 数据/ 依赖图/ 所/ 引导/ 的/ 调度/ 算法/ 能够/ 得到/ 更好/ 的/ 性能比/ ./ 表/ 92/ 簇/ 寄存器/ 堆/ 互连/ 方式/ 结构/ 中/ 调度/ 后/ 性能比/ 的/ 比较/ 测试程序/ 名/ fft65/ ./ 3579.05100/ fir81/ ./ 6390.91/ iir59/ ./ 0989.22100/ latnrm61/ ./ 7389.29100/ lmsfir78/ ./ 5795.65/ mult73/ ./ 7793.75/ 平均值/ 70.0289/ ./ 65Page10/ 表/ 104/ 簇/ 寄存器/ 堆/ 互连/ 方式/ 结构/ 中/ 调度/ 后/ 性能比/ 的/ 比较/ 测试程序/ 名/ fft53/ ./ 1666.67/ fir56/ ./ 7680.77/ iir51/ ./ 1168.66/ latnrm50/ ./ 0067.57/ lmsfir59/ ./ 4681.48/ mult55/ ./ 8188.89/ 平均值/ // %/ 54.3875/ ./ 677/ 结论/ 本文/ 中/ 提出/ 了/ 一种/ 通过/ 对/ 数据/ 依赖图/ 的/ 划分/ 和/ 分析/ ,/ 在/ 最大化/ 指令/ 级/ 并行度/ 的/ 同时/ 最小化/ 簇间/ 数据/ 交互/ 量/ 的/ 方法/ ./ 通过/ 在/ 总线/ 互连/ 方式/ 分簇/ 结构/ 和/ 寄存器/ 堆/ 互连/ 方式/ 分簇/ 结构/ 中/ 的/ 实验/ 表明/ ,/ 利用/ 该/ 方法/ 引导/ 调度/ 过程/ 进行/ ,/ 将/ 可以/ 减少/ 指令/ 调度/ 结果/ 中/ 的/ 簇间/ 数据/ 交互/ ,/ 减少/ 由于/ 簇间/ 数据/ 交互/ 所/ 带来/ 的/ 代码/ 膨胀/ 量/ ,/ 并/ 提高/ 调度/ 结果/ 可/ 获得/ 的/ 指令/ 级/ 并行度/ ,/ 从而/ 缩短/ 整体/ 调度/ 所/ 需/ 执行/ 时间/ ,/ 提高/ 与/ 全/ 互连/ 结构/ 调度/ 结果/ 相比/ 的/ 性能比/ ./ 利用/ 对/ 数据/ 依赖图/ 的/ 划分/ 和/ 分析/ ,/ 可以/ 从/ 更为/ 全局/ 的/ 角度/ 去/ 把握/ 调度/ 的/ 进行/ ,/ 并且/ 可以/ 将/ 未/ 调度/ 指令/ 对/ 当前/ 调度/ 指令/ 的/ 影响/ 涵盖/ 进来/ ,/ 同时/ 把/ 最小化/ 簇间/ 数据/ 交互/ 和/ 最大化/ 指令/ 级/ 并行度/ 两者/ 结合/ 在/ 一起/ ,/ 从而/ 提高/ 调度/ 结果/ 的/ 性能/ ./ 本文/ 所/ 提出/ 的/ 方法/ 在/ 运行/ 时其/ 最坏/ 情况/ 算法/ 复杂度/ 为/ O/ (/ n2/ )/ 量级/ ,/ 这里/ n/ 代表/ 指令/ 个数/ ./ 文献/ [/ 9/ ]/ 中/ 指出/ 列表/ 调度/ 算法/ 的/ 最坏/ 情况/ 运算/ 复杂度/ 为/ O/ (/ n2logn/ )/ 量级/ ,/ 因此/ 本/ 算法/ 的/ 运算/ 复杂度/ 与/ 列表/ 调度/ 算法/ 的/ 复杂度/ 相当/ ./ 

