Page1/ 可/ 重构/ 系统/ 的/ 演化/ 修复/ 机制/ 朱继祥/ 1/ )/ 李元香/ 2/ )/ 邢/ 建国/ 1/ )/ 1/ )/ (/ 浙江/ 工商大学/ 计算机/ 与/ 信息/ 工程学院/ 杭州/ 310018/ )/ 2/ )/ (/ 武汉大学/ 软件工程/ 国家/ 重点/ 实验室/ 武汉/ 430079/ )/ 摘要/ 利用/ 演化/ 算法/ 实现/ 系统/ 自/ 修复/ 是/ 一种/ 新/ 的/ 容错/ 设计/ 思路/ ,/ 但是/ 演化/ 是/ 一个/ 非常/ 耗时/ 的/ 过程/ ./ 已有/ 的/ 演化/ 容错/ 系统/ 多/ 属于/ 静态/ 演化/ ,/ 演化过程/ 仅/ 发生/ 在/ 系统/ 设计阶段/ ,/ 系统/ 在/ 运行/ 过程/ 中/ 不/ 具有/ 演化/ 修复/ 的/ 能力/ ./ 这类/ 演化/ 容错/ 系统/ 虽然/ 可以/ 避免/ 演化/ 耗时/ ,/ 但是/ 只能/ 修复/ 已知/ 错误/ ,/ 无法/ 修复/ 未知/ 错误/ ./ 针对/ 上述/ 问题/ ,/ 文中/ 提出/ 一种/ 基于/ 动态/ 演化/ 的/ 修复/ 机制/ ,/ 容错/ 系统/ 采用/ 可/ 重构/ 系统/ 和/ 被/ 检测/ 系统/ 的/ 耦合/ 设计方案/ ./ 当/ 被/ 检测/ 系统/ 出现/ 故障/ 时/ ,/ 可/ 重构/ 系统/ 通过/ 系统/ 演化/ 实现/ 在线/ 自/ 修复/ ./ 为了/ 减少/ 演化/ 耗时/ ,/ 系统/ 根据/ 错误/ 类型/ 采取/ 不同/ 措施/ :/ 如果/ 出现/ 已知/ 错误/ ,/ 系统/ 直接/ 在/ 预置/ 配置/ 库中/ 搜索/ 修复/ 配置/ ;/ 如果/ 出现/ 未知/ 错误/ ,/ 则/ 通过/ 动态/ 演化/ 在线/ 生成/ 修复/ 配置/ ,/ 并/ 更新/ 预置/ 配置/ 库/ ./ 最后/ ,/ 将/ 该/ 容错/ 设计方案/ 用于/ 典型/ 电路/ 的/ 故障/ 模式/ ./ 实验/ 结果表明/ ,/ 文中/ 提出/ 的/ 演化/ 修复/ 机制/ 提高/ 了/ 系统/ 运行/ 的/ 实时/ 可靠性/ ,/ 预置/ 配置/ 库/ 设计/ 减少/ 了/ 演化/ 耗时/ ./ 关键词/ 演化/ 硬件/ ;/ 演化/ 容错/ ;/ 动态/ 演化/ ;/ 故障/ 模式/ ;/ 预置/ 配置/ 1/ 引言/ 传统/ 的/ 冗余/ 容错/ 技术/ 需要/ 较/ 多/ 的/ 资源/ 开销/ ,/ 而且/ 只能/ 修复/ 已知/ 错误/ ./ 已知/ 错误/ (/ AnticipatedErrors/ )/ 是/ 指/ 在/ 系统/ 设计阶段/ 能够/ 预见/ 并/ 可/ 测试/ 的/ 错误/ ,/ 它们/ 对/ 电路/ 的/ 影响/ 是/ 可以/ 预测/ 的/ ./ 在/ 系统/ 设计/ 时/ 注入/ 这些/ 错误/ 并/ 进行/ 测试/ ,/ 然后/ 通过/ 冗余/ 可以/ 屏蔽/ 故障/ [/ 1/ ]/ ./ 由于/ 故障/ 的/ 诊断/ 和/ 定位/ 存在/ 困难/ ,/ 在/ 系统/ 设计阶段/ 无法/ 进行/ 全面/ 测试/ ,/ 系统/ 在/ 运行/ 过程/ 中/ 更/ 容易/ 出现/ 未知/ 错误/ (/ UnanticipatedErrors/ )/ ./ 未知/ 错误/ 无法/ 用/ 若干个/ 有限/ 模型/ 去/ 描述/ ,/ 难以/ 屏蔽/ 或者/ 修复/ ./ 在/ 这种/ 情况/ 下/ ,/ 系统/ 即使/ 有/ 若干/ 可用/ 的/ 冗余/ 模块/ 也/ 无能为力/ ./ 因此/ ,/ 很难/ 设计/ 出/ 能够/ 容忍/ 未知/ 错误/ 的/ 专用/ 集成电路/ 系统/ (/ ApplicationSpecificIntegratedCircuit/ ,/ ASIC/ )/ ./ 近年来/ ,/ 人们/ 开始/ 探索/ 利用/ 现场/ 可编程/ 逻辑/ 门阵列/ (/ Field/ -/ ProgrammableGateArray/ ,/ FPGA/ )/ 的/ 可/ 重构/ 特性/ 实现/ 容错/ 的/ 新/ 方法/ ,/ 如/ 全局/ 重构/ 容错/ 、/ 局部/ 重构/ 容错/ [/ 2/ -/ 4/ ]/ ./ 重构/ 容错/ 的/ 特点/ 是/ 利用/ FPGA/ 的/ 在/ 系统/ 编程/ (/ In/ -/ SystemProgramming/ ,/ ISP/ )/ 能力/ ,/ 通过/ 备份/ 电路/ 的/ 分时/ 重构/ 实现/ 容错/ ./ 这类/ 容错/ 技术/ 本质/ 上/ 仍/ 属于/ 多模/ 冗余/ 结构/ ,/ 只是/ 冗余/ 资源/ 是/ 备份/ 电路/ 的/ 配置/ 信息/ ,/ 而/ 非/ 硬件/ 逻辑/ ./ 重构/ 容错/ 虽然/ 避免/ 了/ 传统/ 冗余/ 容错/ 资源/ 开销/ 大/ 的/ 问题/ ,/ 也/ 能/ 修复/ 部分/ 随机/ 故障/ ,/ 但是/ 芯片/ 提供/ 的/ 备用/ 电路/ 是/ 有限/ 的/ ,/ 若/ 出现/ 任何/ 备用/ 电路/ 都/ 无法/ 修复/ 的/ 错误/ ,/ 系统/ 将会/ 失效/ ./ 另/ 一种/ 方案/ 是/ 故障/ 模式/ 和/ 效应/ 测试/ (/ FailureModesandEffectsTesting/ ,/ FMET/ )/ ./ Greenwood/ [/ 5/ -/ 6/ ]/ 认为/ 已知/ 错误/ 在/ 设计阶段/ 是/ 可以/ 预测/ 的/ ,/ 可/ 进行/ 建模/ 和/ 测试/ ,/ 将/ 其/ 修复/ 方案/ 存储/ 起来/ ./ 当/ 系统/ 再次出现/ 同样/ 的/ 错误/ 时/ ,/ 只/ 需/ 从/ 存储器/ 中/ 下载/ 相应/ 的/ 电路/ 配置/ 即可/ 实现/ 修复/ ./ 这/ 两种/ 方案/ 的/ 不同之处/ 在于/ ,/ 前者/ 的/ 备份/ 电路/ 采用/ 传统/ 方法/ 设计/ ,/ 后者/ 则/ 采用/ 演化/ 硬件/ (/ EvolvableHardWare/ ,/ EHW/ )/ 技术/ 生成/ 修复/ 配置/ ./ 简单/ 来讲/ ,/ 演化/ 硬件/ 是/ 用/ 演化/ 算法/ 对/ 可编程/ 器件/ 实施/ 重构/ ,/ 使/ 系统/ 在/ 运行/ 时/ 不断改进/ 自身/ 的/ 功能/ 和/ 结构/ [/ 7/ ]/ ./ Greenwood/ 引入/ 演化/ 机制/ 的/ 目的/ 是/ 为了/ 找到/ 最好/ 的/ 修复/ 方案/ ,/ 演化过程/ 发生/ 在/ 系统/ 投入使用/ 之前/ ,/ 属于/ 静态/ 演化/ (/ Off/ -/ SituationEvolution/ )/ ./ 演化/ 硬件/ 的/ 终极目标/ 是/ 在/ FPGA/ 上/ 集成/ 基于/ 演化/ 算法/ 的/ 重/ 配置/ 机制/ ,/ 形成/ 可/ 演化/ 的/ 片/ 上/ 系统/ (/ EvolvableSoC/ )/ ,/ 使/ 系统/ 在/ 运行/ 状态/ 下/ 能够/ 自主/ 演化/ 和/ 修复/ ./ 这种/ 伴随/ 着/ 系统/ 运行/ 的/ 演化过程/ 属于/ 动态/ 演化/ (/ In/ -/ SituationEvolution/ )/ [/ 8/ ]/ ./ 动态/ 演化/ 和/ ISP/ 相结合/ 使/ FPGA/ 具备/ 了/ 在/ 系统/ 演化/ (/ In/ -/ SystemEvolving/ ,/ ISE/ )/ 的/ 能力/ ,/ ISE/ 使/ 系统/ 在/ 运行/ 时/ 通过/ 演化/ 自主/ 修复/ 未知/ 错误/ 成为/ 可能/ ./ 本文/ 提出/ 一种/ 重构/ 容错/ 系统/ 的/ 演化/ 修复/ 机制/ :/ 首先/ 将/ 演化/ 硬件/ 作为/ 容错/ 系统/ 的/ 辅助/ 修复/ 模块/ ,/ 然后/ 通过/ 演化/ 算法/ 对系统/ 进行/ 重构/ ,/ 从而/ 实现/ 在线/ 自/ 修复/ ./ 为了/ 减少/ 演化/ 耗时/ ,/ 在/ 系统/ 中/ 建立/ 预置/ 配置/ 库/ ./ 修复/ 已知/ 错误/ 只/ 需/ 查找/ 预置/ 配置/ 库/ ;/ 修复/ 未知/ 错误/ 则/ 利用/ 演化/ 硬件/ 技术/ 在线/ 生成/ 修复/ 配置/ ,/ 并/ 更新/ 预置/ 配置/ 库/ ./ 2/ 基于/ 演化/ 硬件/ 的/ 容错/ 系统/ 2.1/ 异构/ 冗余/ 容错/ 系统/ 目前/ ,/ 基于/ 演化/ 硬件/ 技术/ 设计/ 的/ 容错/ 系统/ 多/ 采用/ 异构/ 冗余/ 方案/ ,/ 核心思想/ 是/ 利用/ 演化/ 算法/ 设计/ 出/ 多个/ 异构/ 备份/ 电路/ ./ 异构/ 冗余/ 的/ 关键/ 是/ 如何/ 评价/ 异构/ 度/ ,/ 异构/ 度越/ 大/ ,/ 错误/ 覆盖率/ 越高/ ,/ 系统/ 越/ 可靠性/ ./ 有关/ 学者/ 已/ 围绕/ 异构/ 冗余/ 进行/ 了/ 多方面/ 研究/ :/ Schnier/ 和/ Yao/ [/ 9/ ]/ 用/ “/ 无关/ 性/ ”/ (/ NegativeCorrelation/ )/ 评价/ 电路/ 的/ 异构/ 程度/ ,/ 提高/ 了/ 冗余/ 电路/ 的/ 可靠性/ ;/ Shanthi/ 等/ 人/ [/ 10/ ]/ 通过/ 调整/ 已/ 演化/ 电路/ 的/ 结构/ 来/ 提升/ 系统/ 的/ 错误/ 覆盖率/ ;/ Hartmann/ 和/ Haddow/ 等/ 人/ [/ 11/ -/ 12/ ]/ 演化/ 设计/ 容噪/ 容错/ 的/ 异构/ 数字电路/ ./ 林勇/ 等/ 人/ [/ 13/ ]/ 提出/ 一种/ 选择性/ 进化/ 冗余/ 的/ 方法/ ,/ 设计/ 出比/ 同构/ 冗余/ 更/ 可靠/ 的/ 数字/ 系统/ ;/ 高桂军/ 和/ 姚睿/ 等/ 人/ [/ 14/ -/ 16/ ]/ 采用/ 其他/ 异构/ 评价/ 函数/ 也/ 取得/ 不错/ 的/ 效果/ ./ 研究/ 表明/ ,/ 只要/ 选择/ 合理/ 的/ 异构/ 评价/ 函数/ ,/ 演化/ 硬件/ 便/ 能/ 设计/ 出/ 异构/ 度大/ 、/ 错误/ 覆盖率/ 高/ 的/ 冗余/ 系统/ ./ 然而/ ,/ 异构/ 冗余/ 方案/ 是/ 通过/ 在/ 系统/ 中/ 注入/ 若干/ 确定/ 的/ 错误/ ,/ 然后/ 采用/ 静态/ 演化/ ,/ 设计/ 出/ 具有/ 容错/ 能力/ 的/ 电路/ ./ 异构/ 冗余/ 仍/ 处于/ 传统/ 冗余/ 容错/ 的/ 框架/ 之内/ ,/ 只能/ 覆盖/ 可/ 预测/ 故障/ ,/ 不能/ 修复/ 随机/ 故障/ ./ 2.2/ 动态/ 重构/ 容错/ 系统/ 本文/ 设计/ 的/ 动态/ 重构/ 容错/ 系统/ 如图/ 1/ 所示/ ./ 它/ 由/ 检测/ 机制/ 、/ 被/ 检测/ 系统/ 、/ 预置/ 配置/ 库/ 、/ 演化/ 算法/ 、/ 可/ 重构/ 模块/ 、/ 修复/ 模块/ 等/ 部分/ 组成/ ,/ 演化/ 硬件/ 和/ 被/ 检/ 系统/ 通过/ 修复/ 模块/ 耦合/ 形成/ 了/ 整个/ 动态/ 重构/ 容错/ 系统/ ./ 可/ 重构/ 模块/ 是/ 利用/ FPGA/ (/ Virtex/ -/ IIPro20/ )/ 的/ 空余/ 资源/ 设计/ 的/ 虚拟/ 可/ 重构/ 电路/ (/ VirtualConfigu/ -/ rableBlock/ ,/ VCB/ )/ ,/ 其/ 配置/ 信息/ 是/ 演化/ 算法/ 的/ 染色体/ ./ 可/ 重构/ 模块/ 和/ 演化/ 算法/ 一起/ 构成/ 了/ 演化/ 硬件/ ./ 演化/ 算法/ 运行/ 于/ PowerPC/ ,/ 系统/ 适时地/ 启动/ 演化/ 算法/ Page3/ 在线/ 生成/ 修复/ 配置/ ,/ 可/ 重构/ 模块/ 在/ 演化过程/ 中/ 充当/ 评估/ 载体/ ,/ 演化/ 结束/ 后/ 用于/ 映射/ 正确/ 配置/ ./ 修复/ 模块/ 的/ 两个/ 输入/ 信号/ 分别/ 来自/ 于/ 被/ 检/ 电路/ 的/ 输出/ 信号/ F/ 和/ 可/ 重构/ 模块/ 的/ 输出/ 信号/ R/ ,/ 整个/ 系统/ 的/ 输出/ 是/ F/ 和/ R/ 的/ 耦合/ ./ 选择/ 何种/ 运算/ (/ 即/ 耦合/ 规则/ )/ 视/ 具体/ 应用/ 而定/ ./ 预置/ 配置/ 库/ 专为/ 修复/ 已知/ 错误/ 而/ 设计/ ./ 为了/ 减少/ 不必要/ 的/ 演化/ ,/ 节省/ 修复/ 时间/ ,/ 系统/ 修复/ 已知/ 错误/ 时/ 不/ 启动/ 演化/ 硬件/ ./ 通过/ 对/ 被/ 检/ 电路/ 进行/ 预测/ 试/ ,/ 针对/ 不同/ 的/ 故障/ 设计/ 相应/ 的/ 修复/ 电路/ ,/ 并/ 将/ 其/ 配置/ 信息/ 保存/ 在/ 片/ 上/ 存储器/ 中/ ./ 故障/ 和/ 修复/ 电路/ 之间/ 是/ 多/ 对/ 一/ 的/ 关系/ ,/ 一个/ 修复/ 配置/ 可以/ 修复/ 多个/ 故障/ ./ 预置/ 配置/ 库/ 可以/ 是/ 静态/ 的/ 或是/ 动态/ 的/ ./ 检测/ 机制/ 产生/ 被/ 检/ 电路/ 和/ 演化/ 硬件/ 所/ 需/ 的/ 测试/ 输入/ 信号/ ./ 检测/ 机制/ 还/ 需要/ 一块/ 存储/ 区域/ ,/ 用于/ 存放/ 期望/ 输出/ T/ 及/ 错误/ 句柄/ ./ 错误/ 句柄/ 是/ 系统/ 在/ 测试阶段/ 假设/ 出现/ 某一/ 故障/ 后/ 被/ 检/ 电路/ 的/ 实际/ 输出/ 信号/ ,/ 系统/ 将/ 根据/ 错误/ 句柄/ 查找/ 预置/ 配置/ 库/ ./ 3/ 系统/ 实现/ 3.1/ 错误/ 检测/ 机制/ 故障/ 终/ 会/ 表现/ 为/ 输出/ 信号/ 的/ 误差/ ,/ 通过/ 检测/ 被/ 检/ 电路/ 的/ 输出/ 信号/ 是否/ 符合/ 期望值/ 可/ 判断/ 电路/ 是否/ 出错/ ./ 本文/ 通过/ 加载/ 测试/ 输入/ 向量/ ,/ 得到/ 被/ 检/ 电路/ 的/ 实际/ 输出/ 信号/ ,/ 比/ 对/ 检测/ 机制/ 中/ 的/ 期望/ 输出/ 或者/ 预设/ 错误/ 句柄/ ,/ 返回/ 错误模式/ ./ 错误模式/ 分为/ 3/ 个/ 级别/ ,/ 分别/ 执行/ 不同/ 的/ 操作/ :/ (/ 1/ )/ 无/ 错误/ ,/ 模式/ 代码/ ‘/ 0/ ’/ ,/ 不/ 执行/ 任何/ 操作/ ./ (/ 2/ )/ 发生/ 已知/ 错误/ ,/ 模式/ 代码/ ‘/ 1/ ’/ ,/ 查找/ 预置/ 配/ (/ 3/ )/ 发生/ 未知/ 错误/ ,/ 模式/ 代码/ ‘/ -/ 1/ ’/ ,/ 启动/ 演化/ 置库/ ./ 硬件/ ./ 已知/ 错误/ 是/ 在/ 系统/ 设计阶段/ 经过/ 测试/ 了/ 的/ 故障/ 所/ 引起/ 的/ 错误/ ./ 虽然/ 有些/ 故障/ 在/ 理论/ 上/ 是/ 可/ 预测/ 的/ ,/ 但/ 要/ 对/ 所有/ 可能/ 的/ 故障/ 都/ 进行/ 测试/ 是/ 不/ 现实/ 的/ ,/ 我们/ 把/ 未/ 经过/ 测试/ 的/ 故障/ 视为/ 未知/ 错误/ ./ 换言之/ ,/ 不管/ 是/ 何种/ 故障/ 所/ 引起/ 的/ 错误/ ,/ 只要/ 实际/ 输出/ 信号/ 已经/ 存在/ 于/ 预置/ 错误/ 句柄/ 中/ ,/ 就/ 归/ 为/ 已知/ 错误/ ;/ 反之/ ,/ 则/ 为/ 未知/ 错误/ ./ 3.2/ 修复/ 机制/ 系统/ 根据/ 错误代码/ 采取/ 不同/ 的/ 修复/ 机制/ :/ 对于/ 已知/ 错误/ ,/ 在/ 预置/ 配置/ 库中/ 查找/ 能/ 修复/ 该/ 错误/ 的/ 配置/ ,/ 并/ 下载/ 到/ 可/ 重构/ 模块/ ./ 对于/ 未知/ 错误/ ,/ 则/ 启动/ 演化/ 算法/ ,/ 生成/ 新/ 的/ 修复/ 配置/ ./ 未知/ 错误/ 的/ 一个/ 显著特点/ 是/ 具有/ 不确定性/ ,/ 不同/ 的/ 未知/ 错误/ 会/ 产生/ 不同/ 的/ 错误/ 句柄/ ./ 演化/ 算法/ 根据/ 错误/ 句柄/ 不断/ 地/ 更新/ 目标/ 函数/ ,/ 这种/ 在/ 运行/ 时/ 实施/ 目标/ 调整/ 的/ 演化过程/ 被/ 称为/ “/ 动态/ 演化/ ”/ ./ 可/ 演化/ 自/ 修复/ 机制/ 即/ 是/ 基于/ 这种/ 动态/ 特性/ 实现/ 的/ ./ (/ 1/ )/ 确定/ 演化/ 目标/ 演化/ 目标/ 与/ 修复/ 模块/ 所/ 采用/ 的/ 耦合/ 规则/ 有关/ ,/ 结合/ 数字电路/ 的/ 特点/ ,/ 我们/ 选择/ 异或/ 运算/ 作为/ 耦合/ 规则/ ,/ 即/ 异或/ 规则/ 具有/ 可逆性/ ,/ 通过/ 简单/ 运算/ 可/ 得出/ 演化/ 目标/ :/ R/ =/ F/ / T/ [/ 17/ ]/ ./ 显然/ ,/ 如果/ 被/ 检/ 系统/ 在/ 不同/ 时刻/ 出现/ 不同/ 的/ 错误/ ,/ 其/ 输出/ F/ 必然/ 不同/ ,/ 则/ R/ 也/ 发生变化/ ,/ 演化/ 算法/ 则/ 以/ R/ 为/ 目标/ 实施/ 动态/ 演化/ ./ 例如/ :/ 假设/ 被/ 检/ 系统/ 的/ 期望/ 输出/ T/ =/ (/ 0111110110010101/ )/ ./ 在/ T0/ 时刻/ ,/ F/ =/ (/ 0111110110010101/ )/ ,/ 此时/ 系统/ 无/ 错误/ ,/ R/ =/ (/ 0000000000000000/ )/ ./ 若/ 在/ T1/ 时刻/ ,/ 检测/ 到/ F/ =/ (/ 0011110010110101/ )/ ,/ 且/ 预置/ 配置/ 库中/ 无/ 相应/ 的/ 修复/ 配置/ ,/ 则/ 根据/ 异或/ 规则/ 得出/ R/ =/ (/ 0100000100100000/ )/ ./ 为了/ 保证/ 整个/ 系统/ T/ 的/ 正确性/ ,/ 演化/ 算法/ 以新/ 的/ R/ 为/ 目标/ 进行/ 演化/ ./ 如果/ 演化/ 硬件/ 最终/ 成功/ 搜索/ 到/ 能够/ 实现/ 功能/ R/ 的/ 电路/ 配置/ ,/ 则/ 将/ 其/ 下载/ 至/ 可/ 重构/ 模块/ ,/ 并/ 通过/ 修复/ 模块/ 与/ 被/ 检测/ 系统/ 进行/ 耦合/ 即可/ 实现/ 修复/ ./ 否则/ 修复/ 失败/ ,/ 系统/ 发出/ 警告/ ./ (/ 2/ )/ 编码/ 及/ 解码/ 电路/ 染色体/ 编码/ 采用/ 与/ 笛卡尔/ 遗传/ 程序/ (/ Carte/ -/ sianGeneticProgramming/ ,/ CGP/ )/ [/ 18/ ]/ 类似/ 的/ 方法/ ./ 它/ 是/ 一个/ 节点/ 矩阵/ ,/ 每个/ 节点/ 用/ 一个/ 函数/ 编码/ (/ 该/ 节点/ 的/ 逻辑运算/ )/ 和/ 两个/ 连接/ 编码/ (/ 分别/ 表示/ 参与/ 逻辑运算/ 的/ 两个/ 输入/ )/ 来/ 表示/ ./ 染色体/ 由/ 连接/ 编码/ 和/ 函数/ 编/ Page4/ 码/ (/ 图/ 2/ 下划线/ 部分/ )/ 两/ 部分/ 构成/ ,/ 节点/ 的/ 数量/ 决定/ 了/ 染色体/ 的/ 长度/ ./ 染色体/ 的/ 解码/ 是/ 通过/ 将/ 染色体/ 下载/ 至/ FPGA/ 中/ 完成/ 的/ ./ 为了/ 将/ 染色体/ 在/ FPGA/ 中/ 映射/ 成/ 实际/ 电路/ ,/ 我们/ 按照/ 上述/ 编码/ 规则/ ,/ 采用/ 硬件/ 描述语言/ (/ VHDL/ )/ 设计/ 相应/ 的/ 评估/ 电路/ ./ 该/ 模块/ 是/ 一个/ 虚拟/ 可/ 重构/ 电路/ ,/ 它/ 能够/ 接受/ 来自/ 于/ PowerPC/ 的/ 染色体/ ,/ 并/ 将/ 其/ 解码/ 成/ 实际/ 电路/ 等待/ 测试/ 和/ 评估/ ./ (/ 3/ )/ 适应/ 值/ 评估/ 通过/ “/ 在线/ 演化/ ”/ (/ IntrinsicEvolution/ )/ 的/ 方式/ 计算/ 适应/ 值/ ,/ 演化/ 耗时/ 主要/ 来自/ 于/ 评估/ 时间/ ./ 尽管/ 评估/ 单个/ 个体/ 的/ 时耗/ 为/ 毫秒/ 级/ ,/ 但/ 演化过程/ 中/ ,/ 所有/ 染色体/ 都/ 需要/ 映射/ 到/ FPGA/ 中/ 进行/ 评估/ ,/ 大量/ 的/ 映射/ 和/ 评估/ 时间/ 的/ 累积/ 是/ 十分/ 可观/ 的/ ,/ 这/ 不利于/ 实时/ 自/ 修复/ ./ 我们/ 采用/ 多路/ 并行/ 评估/ 策略/ 解决/ 该/ 问题/ ,/ 利用/ FPGA/ 中/ 的/ 空余/ 资源/ 将/ 虚拟/ 可/ 重构/ 电路/ 复制/ 4/ 份/ ,/ 它们/ 分别/ 接收/ 不同/ 的/ 染色体/ ,/ 这/ 4/ 个/ 电路/ 构成/ 了/ 整个/ 可/ 重构/ 模块/ (/ 图/ 1/ )/ ./ 并行/ 评估/ 的/ 好处/ 是/ 可/ 同时/ 解码/ 和/ 评估/ 多个/ 染色体/ ,/ 这样/ 大量/ 地/ 减少/ 了/ 演化/ 耗时/ ./ 完成/ 染色体/ 解码/ 后/ ,/ 测试/ 向量/ 发生器/ 依次/ 产生/ 测试/ 向量/ ,/ 每个/ 评估/ 电路/ 都/ 将/ 得到/ 一个/ 输出/ 向量/ 犆/ i/ (/ i/ =/ 1/ ,/ 2/ ,/ 3/ ,/ 4/ )/ ,/ 它/ 表示/ 当前/ 4/ 个/ 染色体/ 所/ 表达/ 的/ 实际/ 电路/ 功能/ ./ 然后/ 分别/ 计算/ 犆/ i/ 与/ 修复/ 电路/ 的/ 期望/ 输出/ R/ 之间/ 的/ 海明/ 距离/ d/ (/ R/ ,/ Ci/ )/ ,/ 这个/ 值/ 将/ 返回/ PowerPC/ 计算/ 相应/ 染色体/ 的/ 适应/ 值/ ./ 我们/ 以/ 当前/ 电路/ 的/ 修复/ 率/ 作为/ 染色体/ 的/ 评估/ 函数/ [/ 17/ ]/ ,/ 用下式/ 描述/ :/ 其中/ ,/ e/ 是/ 可调/ 因子/ ,/ w/ (/ R/ )/ 是/ R/ 的/ 重量/ ./ 只有/ 当/ d/ (/ R/ ,/ Ci/ )/ </ w/ (/ R/ )/ 时/ ,/ 修复/ 配置/ 才/ 是/ 有效/ 的/ (/ fi/ >/ e/ )/ ./ 当/ d/ (/ R/ ,/ Ci/ )/ =/ 0/ ,/ 实现/ 完全/ 修复/ ./ (/ 4/ )/ 演化/ 算子/ 考虑/ 到片/ 上/ 资源/ 的/ 限制/ 和/ PowerPC/ 的/ 处理/ 能力/ ,/ 本文/ 选择/ 简单/ 遗传算法/ ,/ 选择/ 算子/ 为/ 比例/ 选择/ ./ 由于/ 编码/ 阵列/ 中/ 存在/ 冗余/ 节点/ ,/ 采用/ 均匀/ 交叉/ 算子/ 时/ 演化/ 硬件/ 找到/ 修复/ 配置/ 的/ 概率/ 较大/ ,/ 且/ 迭代/ 次数/ 较少/ ./ 图/ 2/ 是/ 均匀/ 交叉/ 的/ 示意图/ ,/ 染色体/ 中/ 下划线/ 部分/ 是/ 每个/ 节点/ 的/ 函数/ 编码/ (/ 每个/ 数字/ 对应/ 于/ 函数/ 集中/ 的/ 一个/ 操作/ )/ ,/ 前面/ 部分/ 表示/ 连接/ 编码/ (/ 每个/ 节点/ 有/ 连续/ 两个/ 连接/ 编码/ )/ ,/ 交叉/ 算子/ 是/ 以/ 节点/ 为/ 单位/ ./ 变异/ 算子/ 包括/ 结构/ 变异/ 和/ 函数/ 变异/ ./ 前者/ 是/ 对/ 染色体/ 的/ 连接/ 编码/ 实施/ 变异/ ,/ 随机/ 地/ 改变/ 电路/ 中/ 某个/ (/ 些/ )/ 节点/ 的/ 输入/ 连接/ ;/ 后者/ 是/ 对/ 函数/ 编码/ 实施/ 变异/ 操作/ ,/ 从/ 预先/ 定义/ 函数/ 集中/ 随机/ 地/ 选取/ 另/ 一个/ 逻辑/ 门/ 替换/ 发生/ 变异/ 的/ 逻辑/ 门/ ./ 变异/ 算子/ 针对/ 每个/ 基因/ 位/ ,/ 依/ 变异/ 概率/ 发生/ 变异/ ./ 4/ 实验/ 与/ 分析/ 我们/ 进行/ 两组/ 实验/ :/ 实验/ 1/ 以/ 8/ 位/ 奇偶校验/ 器为例/ ,/ 它/ 由/ 7/ 个/ 异或门/ 依次/ 串联/ 而成/ ,/ 采用/ 静态/ 预置/ 配置/ 库/ ./ 这种/ 简单/ 的/ 实验/ 方案/ 是/ 为了/ 更/ 清楚/ 地/ 描述/ 故障/ 建模/ 和/ 演化/ 修复/ 机制/ ;/ 实验/ 2/ 采用/ 门级/ 实现/ 的/ 四位/ 乘法器/ ,/ 内部结构/ 相对/ 复杂/ ,/ 采用/ 动态/ 建库/ 方案/ ./ 通常/ 一个/ 故障/ 不会/ 引起/ 所有/ 输出/ 端口/ 的/ 错误/ ,/ 可/ 重构/ 模块/ 只/ 对/ 出错/ 端口/ 进行/ 耦合/ 运算/ ./ 4.1/ 故障/ 建模/ 在/ 描述/ 被/ 检/ 电路/ 时/ 需要/ 考虑/ 故障/ 建模/ ./ 故障/ 分为/ 可/ 预测/ 故障/ 和/ 不可/ 预测/ 故障/ ./ 可/ 预测/ 故障/ 如/ 晶体管/ 损坏/ 、/ 连线/ 短路/ 或/ 断开/ 等等/ ,/ 建模/ 为/ “/ 固定/ 故障/ ”/ (/ Stuck/ -/ atFault/ )/ ./ 不可/ 预测/ 故障/ 是/ 由/ 某些/ 随机因素/ 干扰/ 引起/ 的/ ,/ 无法/ 进行/ 精确/ 描述/ ,/ 建模/ 为/ “/ 随机/ 翻转/ 故障/ ”/ [/ 11/ -/ 12/ ]/ ,/ 即/ 线路/ 值/ 按/ 概率/ 发生/ 翻转/ ./ 奇偶校验/ 器/ 和/ 乘法器/ 的/ 故障/ 建模/ 类似/ ,/ 假定/ 固定/ 故障/ 和/ 翻转/ 故障/ 都/ 出现/ 在/ 电路/ 内部/ 的/ 连接线/ 上/ ./ 图/ 3/ 是/ 注入/ 故障/ 模型/ 后/ 的/ 奇偶校验/ 器/ 电路/ ./ 有/ 15/ 条/ 连线/ ,/ 依次/ 编号/ 为/ f1/ ,/ f2/ ,/ f3/ ,/ …/ ,/ f14/ ,/ f15/ ./ 每条/ 线路/ 都/ 有/ 可能/ 出现/ 固定/ 0/ 故障/ (/ Stuck/ -/ at/ -/ 0/ )/ 、/ 固定/ 1/ 故障/ (/ Stuck/ -/ at/ -/ 1/ )/ 或者/ 随机/ 翻转/ ./ 被/ 检/ 电路/ 有/ 8/ 个/ 输入/ X1/ ,/ X2/ ,/ X3/ ,/ …/ ,/ X8/ ,/ 其/ 可能/ 的/ 故障/ 电路/ 总数/ 为/ 228/ -/ 1/ 个/ ./ 显然/ ,/ 对/ 所有/ 的/ 故障/ 电路/ 都/ 进行/ 测试/ 是/ 不切实际/ 的/ ./ 我们/ 仅/ 测试/ 线路/ 中/ 出现/ 的/ 单个/ 固定/ 故障/ ,/ 并/ 设计/ 相应/ 的/ 修复/ 电路/ ,/ 一共/ 是/ 30/ 个/ ,/ 把/ 它们/ 放入/ 预置/ 配置/ 库中/ ./ 例如/ :/ f9/ 出现/ 固定/ 0/ 故障/ 时/ ,/ 修复/ 电路/ 为/ X1/ / X2/ ;/ f9/ 出现/ 固定/ 1/ 故障/ 时/ ,/ 修复/ 电路/ 则/ 为/ X1/ / X2/ ./ 不同/ 的/ 故障/ 组合/ 可能/ 导致/ 不同/ 的/ 错误模式/ ,/ 当由/ 多个/ 故障/ 所/ 引起/ 的/ 错误/ 和/ 单个/ 固定/ 故障/ 引起/ 的/ 错误/ 一样/ ,/ 则/ 为/ 已知/ 错误/ ./ 如/ f1/ 和/ f2/ 分别/ 发生/ 固定/ 0/ 故障/ 和/ 固定/ 1/ 故障/ ,/ 和/ f9/ 发生/ 固定/ 1/ 故/ Page5/ 障所/ 产生/ 的/ 错误/ 相同/ ,/ 都/ 可以/ 用/ X1/ / X2/ 修复/ ,/ 故/ 为/ 已知/ 错误模式/ ./ 只有/ 在/ 预置/ 配置/ 库中/ 找/ 不到/ 修复/ 电路/ 时/ ,/ 系统/ 才/ 会/ 启动/ 演化/ 修复/ 机制/ ./ 4.2/ 实验/ 平台/ 及/ 参数设置/ 实验/ 平台/ 选用/ 的/ FPGA/ 是/ XINLIX/ 公司/ 的/ Virtex/ -/ IIPro20/ (/ XC2VP20/ )/ ,/ PowerPC405/ 硬核/ 处理器/ ,/ 母板/ 为/ AMD/ -/ XPL/ ,/ 板载/ 64MDDRSDRAM/ ./ 母板/ 通过/ PCI/ 与/ PC机/ 相连/ ,/ 由/ SDK/ 提供/ 的/ 接口函数/ (/ C语言/ 描述/ )/ 将/ 运行/ 结果/ 返回/ PC/ ./ 函数/ 编码/ 取/ {/ NOT/ ,/ AND/ ,/ OR/ ,/ XOR/ ,/ BUF/ ,/ NAND/ ,/ NOR/ ,/ NXOR/ }/ ,/ 共/ 8/ 类/ 基本/ 逻辑/ 门/ (/ 依次/ 编号/ 0/ ~/ 7/ )/ ./ 选用/ 对称/ 函数/ 集/ 的/ 优势/ 是/ 可以/ 利用/ 组合/ 逻辑/ 的/ 互补/ 律来/ 实施/ 基因/ 改良/ ,/ 改变/ 适应/ 值/ 地形/ ,/ 加快/ 演化/ 速度/ ./ 大/ 种群/ 规模/ 会/ 大幅/ 增加/ 待/ 评估/ 个体/ 的/ 数量/ ,/ 导致/ 演化/ 耗时/ 急剧/ 上升/ ,/ 难以/ 满足/ 实时性/ 要求/ ,/ 本文/ 选取/ 种群/ 规模/ PopSize/ =/ 20/ ./ 变异/ 概率/ 在/ 0.1/ ~/ 0.25/ 之间/ 效果/ 较/ 好/ ,/ 采用/ 自/ 适应/ 变异/ 对/ 演化/ 效率/ 并/ 无/ 显著/ 提高/ ,/ 反而/ 使/ 计算/ 量/ 增加/ ,/ 故/ 选择/ 固定/ 变异/ 概率/ Pm/ =/ 0.1/ ./ 交叉/ 概率/ 在/ 0.8/ ~/ 0.9/ 之间/ 时/ ,/ 平均/ 迭代/ 次数/ 小于/ 其它/ 设定/ ,/ 故/ 选择/ 交叉/ 概率/ Pc/ =/ 0.8/ ./ 终止/ 准则/ :/ 演化/ 达到/ 最大/ 迭代/ 次数/ (/ MaxGen/ =/ 3000/ )/ ,/ 或者/ 找到/ 能/ 实现/ 完全/ 修复/ 的/ 新/ 配置/ ./ 4.3/ 仿真/ 实验/ 假定/ 被/ 检/ 电路/ 中/ 的/ 每条/ 线路/ 都/ 依/ 概率/ 发生/ 故障/ ,/ 线路/ 故障/ 的/ 组合/ 可能/ 引起/ 已知/ 错误/ 、/ 未知/ 错误/ ,/ 或者/ 无/ 错误/ ./ 我们/ 不/ 预告/ 系统/ 将/ 出现/ 何种/ 错误/ ,/ 仅/ 给出/ 若干个/ 不同/ 的/ 故障率/ ,/ 并/ 在/ 系统/ 中/ 建立/ 单个/ 线路/ 出错/ 时/ 的/ 预置/ 修复/ 配置/ 库/ ./ 衡量/ 容错性/ 能/ 的/ 标准/ 是/ 可靠性/ 和/ 可用性/ ,/ 在/ 本文/ 中/ ,/ 可用性/ 通过/ 演化/ 硬件/ 搜索/ 到/ 有效/ 配置/ 所/ 需/ 的/ 时间/ (/ </ 30s/ )/ 来/ 衡量/ ;/ 可靠性/ 则/ 是/ 被/ 检/ 电路/ 出错/ 后/ 找到/ 有效/ 修复/ 配置/ 的/ 概率/ ./ 4.3/ ./ 1/ 奇偶校验/ 器/ 电路/ 规模较/ 小/ ,/ 我们/ 依次/ 设定/ 5/ 个/ 高/ 故障率/ :/ Pf/ =/ 0.1/ 、/ 0.2/ 、/ 0.3/ 、/ 0.4/ 、/ 0.5/ ./ 高/ 故障率/ 可/ 使/ 奇偶/ 器/ 尽量/ 出现/ 不同/ 类型/ 的/ 错误/ ,/ 以/ 描述/ 演化/ 修复/ 机制/ 的/ 执行/ 过程/ ./ 系统生成/ 15/ 个/ 随机数/ 分别/ 对应/ 于/ 被/ 检/ 电路/ 中/ 的/ 15/ 条/ 线路/ ./ 如果/ 某条/ 线路/ 的/ 随机数/ 小于/ 设定值/ ,/ 则/ 该条/ 线路/ 发生/ 故障/ ,/ 并/ 随机/ 选择/ 一个/ 故障/ 类型/ ./ 每个/ 故障率/ 分别独立/ 运行/ 100/ 次/ ,/ 统计/ 系统/ 出错/ 的/ 次数/ (/ Nf/ )/ 、/ 完全/ 修复/ 次数/ (/ Nr/ )/ 、/ 平均/ 迭代/ 次数/ (/ G/ _/ avg/ )/ 以及/ 平均/ 演化/ 修复/ 时间/ (/ Tr/ )/ 、/ 系统可靠性/ (/ Re/ )/ ./ 如表/ 1/ 所示/ ,/ 表中/ ‘/ // ’/ 之前/ 为/ 已知/ 错误/ 的/ 相关/ 统计/ ,/ ‘/ // ’/ 之后/ 为/ 未知/ 错误/ 的/ 相关/ 统计/ ./ 故障率/ NfNrG/ _/ avgTr/ // sRe0/ ./ 164/ // 2364/ // 180/ // 117413.90/ ./ 950.261/ // 3261/ // 200/ // 161020.50/ ./ 880.352/ // 4452/ // 230/ // 206824.40/ ./ 790.444/ // 5644/ // 260/ // 233727.60/ ./ 700.531/ // 6931/ // 330/ // 240529.70/ ./ 64/ 根据/ 表中/ 第/ 2/ 行可得/ ,/ 故障率/ 相对/ 较/ 低时/ ,/ 系统/ 有/ 少量/ 机会/ 不/ 发生/ 错误/ ./ 如/ Pf/ =/ 0.1/ 时/ ,/ 发生/ 已知/ 错误/ 64/ 次/ ,/ 发生/ 未知/ 错误/ 23/ 次/ ,/ 另有/ 13/ 次/ 未/ 出错/ ./ 随着/ 故障率/ 增加/ ,/ 系统/ 检测/ 到/ 已知/ 错误/ 的/ 次数/ 减少/ ,/ 而/ 未知/ 错误/ 的/ 次数/ 增加/ ./ 在/ 5/ 种/ 故障率/ 下/ 系统/ 的/ 错误率/ 依次/ 为/ 87/ %/ ,/ 93/ %/ ,/ 96/ %/ ,/ 100/ %/ ,/ 100/ %/ ,/ 奇偶/ 器/ 本身/ 的/ 可靠性/ 几乎/ 为/ 0/ ./ 系统/ 在/ 每个/ 故障率/ 下/ 都/ 出现/ 了/ 不同/ 的/ 错误/ ,/ 符合/ 我们/ 设定/ 大/ 故障率/ 的/ 初衷/ ./ 可靠性/ 方面/ ,/ 比较/ Nf/ 和/ N/ ,/ 演化/ 机制/ 修复/ 了/ 大多数/ 的/ 未知/ 错误/ ./ 如/ Pf/ =/ 0.2/ 时/ ,/ 出现/ 未知/ 错误/ 32/ 次/ ,/ 20/ 次/ 实现/ 完全/ 修复/ ,/ 仅/ 有/ 12/ 次/ 未能/ 完全/ 修复/ ./ 高/ 故障率/ 使/ 关键/ 线路/ 容易/ 出错/ ,/ 增加/ 了/ 修复/ 电路/ 的/ 复杂度/ ,/ 导致/ 演化/ 算法/ 不能/ 在/ 规定/ 迭代/ 次数/ 内/ 找到/ 符合条件/ 的/ 配置/ ./ 实验/ 发现/ ,/ 在/ Pf/ 为/ 0.4/ 和/ 0.5/ 的/ 情况/ 下/ ,/ 修复/ 失败/ 大多/ 是/ 由于/ f14/ 或者/ f15/ 发生/ 故障/ 导致/ 的/ ./ 显然/ ,/ 增加/ 迭代/ 次数/ 能够/ 提高/ 成功率/ ,/ 但/ 同时/ 会/ 带来/ 修复/ 时间/ 过长/ 的/ 问题/ ./ 可用性/ 方面/ ,/ 我们/ 统计/ 了/ 启动/ 检测/ 机制/ 到/ 实现/ 自/ 修复/ 所/ 需/ 的/ 时间/ ./ 如果/ 被/ 检/ 电路/ 出现/ 已知/ 错误/ ,/ 其/ 修复/ 配置/ 由查库/ 所得/ ,/ 不必/ 启动/ 演化/ ,/ 故/ G/ _/ avg/ =/ 0/ ,/ 系统/ 实现/ 自/ 修复/ 所/ 需/ 的/ 时间/ 主要/ 是/ 检测/ 耗时/ +/ 查库/ 时间/ ,/ 此/ 过程/ 耗时/ 约/ 12ms/ ./ 发生/ 未知/ 错误/ 时/ 启动/ 演化/ 修复/ ,/ G/ _/ avg/ 则/ 是/ 在/ 30s/ 内/ 实现/ 完全/ 修复/ 所/ 需/ 迭代/ 次数/ 的/ 平均值/ ./ Tr/ 是/ 实现/ 演化/ 自/ 修复/ 所/ 需/ 的/ 平均/ 时间/ ,/ 它/ 主要/ 是/ 演化/ 耗时/ ,/ 检测/ 耗时/ 和/ 查库/ 时间/ 可/ 忽略不计/ ./ 演化/ 耗时/ 主要/ 来自/ 于/ 评估/ 时间/ ,/ 实验/ 测/ 得/ 单个/ 个体/ 的/ 在线/ 评估/ 时间/ 约/ 2ms/ ./ 种群/ 规模/ 20/ ,/ 如果/ 不/ 采用/ 并行/ 评估/ ,/ 则/ 每代/ 种群/ 仅/ 评估/ 时间/ 就/ 需/ 40ms/ ,/ 显然/ 不能/ 满足/ 实时性/ 要求/ ;/ 若/ 采用/ 四路/ 并行/ 评估/ 策略/ ,/ 每代/ 种群/ 的/ 评估/ 时间/ 减少/ 为/ 10ms/ ,/ 此时/ 大多数/ 演化/ 自/ 修复/ 都/ 能/ 在/ 30s/ 内/ 完成/ ,/ 可以/ 满足/ 实时性/ 的/ 要求/ (/ 见/ Tr/ )/ ./ 进一步/ 加大/ 并行/ 评估/ 程度/ 可/ 满足/ 更加/ 苛刻/ 的/ 实时性/ 要求/ ,/ 但/ 同时/ 需要/ 更/ 多/ 的/ 芯片/ 资源/ ./ 4.3/ ./ 2/ 四位/ 乘法器/ 上述/ 实验/ 采用/ 静态/ 预置/ 配置/ 库/ ,/ 由/ 演化/ 硬件/ 生成/ 的/ 修复/ 配置/ 没有/ 保存/ ./ 若/ 系统/ 在/ 不同/ 时刻/ 出现/ 相同/ 的/ 错误/ 句柄/ ,/ 需要/ 重复/ 启动/ 演化/ ,/ 造成/ 较大/ 的/ 演化/ Page6/ 耗时/ ./ 乘法器/ 采用/ 动态/ 建库/ 的/ 方案/ ,/ 在/ 初始/ 时/ 预置/ 配置/ 库为/ 空/ ,/ 将/ 由/ 演化/ 硬件/ 生成/ 修复/ 配置/ 存入/ 预置/ 配置/ 库/ ./ 为了/ 模拟/ 这种/ 情况/ ,/ 我们/ 依次/ 设定/ 10/ 个/ 故障率/ :/ 0.005/ 、/ 0.01/ 、/ 0.015/ 、/ 0.02/ 、/ 0.025/ 、/ 0.03/ 、/ 0.035/ 、/ 0.04/ 、/ 0.045/ 、/ 0.05/ ./ 每个/ 故障率/ 下/ 运行/ 100/ 次/ ,/ 运行/ 时/ 更新/ 预置/ 配置/ 库/ ./ 图/ 4/ 统计/ 了/ 系统/ 出现/ 已知/ 错误/ 和/ 未知/ 错误/ (/ 及/ 演化/ 修复/ )/ 的/ 次数/ ./ 将/ 系统/ 在/ 预置/ 配置/ 库中/ 命中/ 修复/ 配置/ 的/ 几率/ 记/ 为/ σ/ ./ 从图/ 4/ 中/ 可/ 看出/ ,/ σ/ 较/ 明显/ 地/ 呈现出/ 两个/ 阶段/ :/ 故障率/ 较/ 低时/ 的/ 上升/ 阶段/ 和/ 故障率/ 较/ 高时/ 的/ 平缓/ 阶段/ ./ 上升/ 阶段/ 可/ 视为/ 系统/ 利用/ 演化/ 算法/ 进行/ 自测试/ 和/ 自/ 学习/ 的/ 阶段/ ,/ 系统/ 在/ 这/ 一/ 阶段/ 发生/ 未知/ 错误/ 的/ 几率/ (/ 记/ 为/ δ/ )/ 几乎/ 不/ 受/ 故障率/ 的/ 影响/ ;/ 尽管/ 平缓/ 阶段/ 的/ 预置/ 配置/ 库/ 更/ 大/ ,/ 但是/ 受高/ 故障率/ 的/ 影响/ ,/ 系统/ 出错/ 后/ 逐渐/ 难以/ 命中/ 修复/ 配置/ ,/ 导致/ δ/ 出现/ 呈上升/ 趋势/ ./ 演化/ 机制/ 修复/ 未知/ 错误/ 的/ 几率/ 记为/ p/ ./ 根据/ 前文/ 对/ 可靠性/ 的/ 定义/ ,/ 修复/ 前/ 系统/ 的/ 可靠性/ r/ =/ 1/ -/ (/ σ/ +/ δ/ )/ ;/ 启用/ 演化/ 修复/ 机制/ 后/ ,/ 可靠性/ R/ =/ r/ +/ σ/ +/ p/ ,/ 得到/ 系统可靠性/ 对比/ 图/ ,/ 如图/ 5/ 所示/ ./ 当/ 故障率/ 较/ 低时/ ,/ 尽管/ 预置/ 配置/ 库/ 尚未/ 完全/ 建立/ ,/ 但是/ 电路/ 受/ 故障/ 影响/ 较/ 小/ ./ 即使/ 出现/ 未知/ 错误/ ,/ 修复/ 电路/ 的/ 规模/ 很小/ ,/ 演化/ 硬件/ 都/ 能/ 在/ 规定/ 时间/ 内/ 搜索/ 到/ 有效/ 的/ 修复/ 配置/ ,/ 使/ 系统/ 具有/ 较/ 高/ 的/ 可靠性/ ./ 当/ 故障率/ 较/ 高时/ ,/ 演化/ 修复/ 机制/ 逐渐/ 失效/ ,/ 但/ 它/ 在/ 预置/ 配置/ 库中/ 已/ 生成/ 了/ 较/ 多/ 的/ 修复/ 配置/ ,/ 系统/ 仍/ 有/ 较/ 高/ 的/ 概率/ 命中/ 修复/ 配置/ ,/ 不至于/ 完全/ 失效/ ./ 由此可见/ ,/ 采用/ 动态/ 建库/ 方案/ 后/ ,/ 演化/ 修复/ 机制/ 和/ 配置/ 库/ 分别/ 在/ 不同/ 情况/ 下/ 发挥作用/ :/ 在/ 低/ 故障率/ 时/ 由/ 演化/ 修复/ 机制/ 生成/ 修复/ 配置/ 以/ 维持/ 系统可靠性/ ,/ 同时/ 动态/ 建库/ ;/ 而/ 高/ 故障率/ 下则/ 由/ 前/ 一/ 阶段/ 建立/ 的/ 配置/ 库来/ 保证系统/ 的/ 可靠性/ ./ 5/ 结论/ 本文/ 通过/ 在/ FPGA/ 中/ 融入/ 演化/ 机制/ 使/ 系统/ 具备/ 在/ 系统/ 演化/ (/ ISE/ )/ 的/ 能力/ ,/ 然后/ 利用/ 动态/ 演化/ 实现/ 系统/ 在/ 运行/ 时/ 的/ 自/ 修复/ ./ 实验/ 表明/ ,/ 演化/ 机制/ 在/ 不同/ 阶段/ 直接/ 或/ 间接/ 起到/ 维持/ 系统可靠性/ 的/ 作用/ ./ 通过/ 动态/ 建立/ 预置/ 配置/ 库/ ,/ 一方面/ 可以/ 保证系统/ 在/ 高/ 故障率/ 下/ 的/ 可靠性/ ,/ 另一方面/ 避免/ 了/ 重复/ 演化/ ,/ 加快/ 了/ 系统/ 的/ 自/ 修复/ 速度/ ,/ 有利于/ 实时/ 自/ 修复/ ./ 本文/ 的/ 研究/ 仅/ 是/ 演化/ 机制/ 在/ 重构/ 容错/ 中/ 的/ 初步/ 探讨/ ,/ 笔者/ 认为/ 未来/ 至少/ 有/ 以下/ 3/ 个/ 方面/ 值得/ 进一步/ 研究/ :/ 首先/ ,/ 本文/ 建立/ 的/ 容错/ 系统/ 是/ 一个/ 简化/ 模型/ ,/ 演化/ 算法/ 用/ 软件/ 实现/ ./ 演化/ 硬件/ 的/ 趋势/ 是/ 将/ 演化/ 机制/ 作为/ 系统/ 物理/ 实现/ 的/ 一部分/ ,/ 保证/ 演化/ 模块/ 自身/ 的/ 可靠性/ 可能/ 仍/ 需/ 借助/ 传统/ 的/ 容错/ 方法/ ./ 其次/ ,/ 本文/ 实验/ 中仅/ 采用/ 基本/ 的/ 逻辑/ 门/ ,/ 这/ 决定/ 了/ 修复/ 电路/ 的/ 规模/ 不会/ 很大/ ./ 采用/ 更/ 高级/ 的/ 模块/ 或/ 可/ 将/ 演化/ 机制/ 应用/ 于/ 更/ 复杂/ 系统/ 的/ 容错/ 中/ ,/ 这/ 取决于/ 函数/ 级/ 演化/ 硬件/ 的/ 研究进展/ ./ 最后/ ,/ 采用/ 虚拟/ 可/ 重构/ 电路/ 在/ 一定/ 程度/ 上/ 增加/ 了/ 评价/ 时间/ ,/ 导致/ 较大/ 的/ 演化/ 耗时/ ,/ 但/ 在/ 现有/ 平台/ 下/ ,/ 它/ 是/ 保护/ FPGA/ 芯片/ 不/ 受/ 损坏/ 的/ 权宜之计/ ./ 研制/ 专用/ 的/ 面向/ 演化/ 的/ 可/ 重构/ 芯片/ 可/ 解决/ 这一/ 问题/ ,/ 使/ 系统/ 修复/ 速度/ 更/ 快/ ,/ 这/ 也/ 是/ 演化/ 硬件/ 的/ 一个/ 发展/ 方向/ ./ 

