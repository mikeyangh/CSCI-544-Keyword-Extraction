Page1/ 提高/ 堆/ 数据/ 局部性/ 的/ 动态/ 池/ 分配/ 技术/ 王振江/ 1/ )/ ,/ 2/ )/ ,/ 3/ )/ 武成/ 岗/ 1/ )/ ,/ 2/ )/ 张兆庆/ 1/ )/ ,/ 2/ )/ 1/ )/ (/ 中国科学院/ 计算机系统/ 结构/ 重点/ 实验室/ 北京/ 100190/ )/ 2/ )/ (/ 中国科学院计算技术研究所/ 北京/ 100190/ )/ 3/ )/ (/ 中国科学院/ 研究生院/ 北京/ 100049/ )/ 摘要/ 动态内存/ 分配/ 在/ 现代/ 程序/ 中/ 被/ 广泛/ 使用/ ./ 通用/ 的/ 内存/ 分配器/ 通常/ 关注/ 于/ 降低/ 运行/ 时/ 开销/ 和/ 内存/ 利用率/ ,/ 而/ 在/ 发掘/ 所/ 分配/ 对象/ 之间/ 的/ 特性/ 方面/ 有所/ 欠缺/ ./ 文中/ 展示/ 了/ 一个/ 低/ 开销/ 的/ 动态/ 优化/ 技术/ “/ 动态/ 池/ 分配/ ”/ ./ 它/ 在/ 运行/ 时/ 构造/ 存储/ 形状/ 图/ ,/ 从中/ 发掘/ 动态分配/ 对象/ 之间/ 的/ 亲缘/ 性/ ,/ 把/ 具有/ 亲缘/ 性/ 的/ 对象/ 聚集/ 到/ 一段/ 内存/ 区域/ (/ 称为/ 内存/ 池/ )/ 里/ ,/ 改善/ 了/ 它们/ 的/ 数据/ 布局/ ./ 作者/ 在/ 实际/ 机器/ 上/ 实现/ 了/ 动态/ 池/ 分配/ 原型/ 系统/ ,/ 并/ 在/ GCC/ -/ -/ O3/ 编译/ 的/ 一些/ 大量/ 使用/ 堆/ 数据/ 的/ SPEC2000/ 和/ 2006/ 程序/ 上/ 进行/ 了/ 测试/ ./ 原型/ 系统/ 在/ 两台/ 实际/ 机器/ 上/ 获得/ 了/ 13.1/ %/ 和/ 11.8/ %/ 的/ 平均/ 加速/ 比/ ,/ 对/ 一些/ 程序/ 的/ 加速/ 高达/ 82.2/ %/ ./ 此外/ ,/ 作者/ 还/ 研究/ 了/ CPU/ 的/ 高速缓存/ 大小/ 对池/ 分配/ 效果/ 的/ 影响/ ./ 关键词/ 池/ 分配/ ;/ 变/ 长/ 调用/ 链/ ;/ 亲缘/ 性/ ;/ 数据/ 布局/ ;/ 动态/ 优化/ 1/ 引言/ 体系结构/ 的/ 发展/ ,/ 处理器/ 的/ 性能/ 以/ 指数/ 级/ 速度/ 增长/ [/ 1/ ]/ ./ 而/ 内存/ 性能/ 的/ 提高/ 则/ 相对/ 缓慢/ ,/ 于是/ 二者之间/ 形成/ 了/ 一个/ 巨大/ 的/ 鸿沟/ ,/ 并且/ 这一/ 鸿沟/ 在/ 可/ 预见/ 的/ 在/ 过去/ 的/ 几十年/ 中/ ,/ 由于/ 半导体/ 工艺/ 的/ 进步/ 和/ 将来/ ,/ 还/ 存在/ 继续/ 扩大/ 的/ 趋势/ ./ 访存/ 速度/ 低/ 已经/ 成为/ Page2/ 阻碍/ 计算机系统/ 性能/ 发挥/ 的/ 主要/ 瓶颈/ ./ 现代/ 处理器/ 主要/ 依靠/ 高速缓存/ 来/ 缓解/ 内存/ 与/ 处理器/ 之间/ 的/ 性能/ 差异/ ,/ 因此/ 如何/ 提高/ 应用程序/ 的/ 数据/ 局部性/ ,/ 使/ 之/ 充分利用/ 处理器/ 缓存/ ,/ 就/ 成为/ 提高/ 计算机系统/ 整体/ 性能/ 的/ 关键问题/ 之一/ ./ 在/ 很多/ 应用程序/ 中/ ,/ 堆中/ 的/ 数据/ 占/ 其/ 数据/ 集/ 的/ 很大/ 一部分/ ,/ 对/ 这些/ 数据/ 局部性/ 的/ 优化/ 具有/ 重要/ 的/ 意义/ ./ 通用/ 堆/ 内存/ 分配器/ (/ 如/ Linux/ 操作系统/ 中/ 广泛/ 使用/ 的/ dlmalloc/ )/ 的/ 关注点/ 集中/ 在/ 降低/ 运行/ 时/ 开销/ 、/ 减少/ 内存/ 碎片/ 和/ 提高/ 并行/ 分配/ 能力/ 等/ ,/ 很少/ 考虑/ 所/ 分配/ 对象/ 之间/ 的/ 局部性/ ./ 另一方面/ ,/ 程序员/ 往往/ 出于/ 方便/ ,/ 根据/ 需求/ 来/ 分配/ 堆/ 上/ 数据/ ,/ 也/ 很少/ 将/ 精力/ 放在/ 维护/ 数据/ 的/ 局部性/ 上/ ./ 图/ 1/ (/ a/ )/ 展示/ 了/ 一个/ 程序/ 通过/ 调用/ 堆/ 分配/ 函数/ ,/ 交叠/ 地为/ 三个/ 独立/ 的/ 数据结构/ 分配/ 节点/ 空间/ 时/ ,/ 所/ 形成/ 的/ 堆/ 数据/ 布局/ ./ 堆/ 分配器/ 按照/ 程序/ 对/ 空间/ 的/ 申请/ 序/ ,/ 在/ 连续/ 空间/ 中为/ 每/ 一个/ 节点/ 分配/ 所/ 需/ 的/ 内存/ ./ 这种/ 策略/ 可以/ 减少/ 碎片/ ,/ 但/ 由于/ 缺少/ 对/ 应用程序/ 的/ 内存/ 分配/ 和/ 访问/ 模式/ 的/ 针对性/ 分析/ ,/ 形成/ 较差/ 的/ 数据/ 布局/ ,/ 如图/ 1/ (/ a/ )/ 中/ 同一个/ 数据结构/ 的/ 对象/ 被/ 分散/ 地/ 摆放/ ./ 图/ 1/ 使用/ dlmalloc/ 和/ 池/ 分配器/ 的/ 内存空间/ 布局/ 如果/ 这些/ 对象/ 的/ 位置/ 符合/ 它们/ 的/ 访问/ 模式/ ,/ 如图/ 1/ (/ b/ )/ 所示/ ,/ 数据/ 局部性/ 就/ 可以/ 得到/ 改善/ ./ 一些/ 编程语言/ (/ 如/ Java/ 和/ C#/ )/ 通过/ 自动/ 内存/ 管理机制/ “/ 垃圾/ 收集器/ ”/ (/ garbagecollector/ )/ ,/ 可以/ 在/ 运行/ 时/ 改变/ 对象/ 的/ 位置/ ./ Huang/ [/ 2/ ]/ 、/ Chilimbi/ [/ 3/ ]/ 和/ Serrano/ [/ 4/ ]/ 等/ 通过/ 在线/ 采样/ 技术/ 收集/ 和/ 分析/ 这些/ 对象/ 的/ 各种/ 特征/ ,/ 把/ 关系/ 紧密/ 的/ 对象/ 移动/ 到/ 相邻/ 的/ 位置/ ,/ 提高/ 了/ 它们/ 的/ 局部性/ ./ 然而/ ,/ 现在/ 有/ 相当/ 多/ 的/ 应用程序/ 在/ 运行/ 时/ 没有/ 垃圾/ 收集器/ 的/ 支持/ (/ 如/ 大量/ 的/ C/ 和/ C++/ 程序/ )/ ,/ 这种/ 环境/ 下/ 移动/ 对象/ 必须/ 显式/ 更新/ 所有/ 对/ 该/ 对象/ 的/ 引用/ ./ 由于/ 程序/ 里/ 潜在/ 的/ 别名/ 指针/ ,/ 运行/ 时/ 系统/ 很难/ 自动更新/ 所有/ 对/ 该/ 对象/ 的/ 引用/ ,/ 而/ 任何/ 遗漏/ 的/ 旧/ 引用/ 都/ 可能/ 会/ 使/ 程序/ 发生/ 错误/ ./ 因此/ ,/ 很多/ 工作/ 转而/ 关注/ 于/ 在/ 对象/ 的/ 分配/ 时/ 就/ 把/ 它/ 放置/ 在/ 适当/ 的/ 位置/ ./ Lattner/ [/ 5/ ]/ 在/ 编译/ 时刻/ 分析程序/ 的/ 源代码/ ,/ 识别/ 对象/ 所属/ 的/ 数据结构/ ,/ 把/ 同一/ 数据结构/ 的/ 对象/ 从/ 一段/ 连续/ 的/ 内存空间/ (/ 称为/ 内存/ 池/ )/ 里/ 分配/ ,/ 遍历/ 数据结构/ 时/ 可以/ 获得/ 更好/ 的/ 局部性/ ./ 但是/ 很多/ 情况/ 下/ ,/ 用户/ 并/ 没有/ 条件/ 得到/ 源代码/ 并/ 进行/ 重新/ 编译/ ,/ 因此/ 更/ 需要/ 一种/ 能够/ 直接/ 对/ 二进制/ 程序/ 进行/ 优化/ 的/ 方法/ ./ Seidl/ [/ 6/ ]/ 和/ Barrett/ [/ 7/ ]/ 通过/ 事前/ 训练/ 获得/ 对象/ 的/ 访存/ 频率/ 或/ 生命周期/ 等/ 信息/ ,/ 在/ 随后/ 的/ 运行/ 中/ 把/ 相似/ 的/ 对象/ 从/ 同一/ 内存/ 池里/ 分配/ ./ 这种/ 方法/ 依赖于/ 有/ 代表性/ 的/ 训练/ 集/ ,/ 但/ 对/ 许多/ 实际/ 应用/ 来讲/ ,/ 很难/ 获得/ 一个/ 有/ 代表性/ 的/ 训练/ 集/ ,/ 并且/ 事先/ 的/ 训练/ 也/ 会/ 成为/ 用户/ 的/ 一个/ 大/ 的/ 负担/ ./ 本文/ 提出/ 了/ 一种/ 对/ 用户/ 透明/ 的/ 、/ 轻量级/ 动态数据/ 分配/ 技术/ ,/ 在/ 用户/ 态/ 直接/ 优化/ 二进制/ 代码/ ./ 它/ 在/ 运行/ 时/ 识别/ 对象/ 之间/ 的/ 亲缘/ 性/ ,/ 把/ 具有/ 亲缘/ 性/ 的/ 对象/ 从/ 同一/ 内存/ 池里/ 分配/ ./ 这种/ 方法/ 不/ 需要/ 用户/ 提供/ 源代码/ ,/ 也/ 不/ 需要/ 寻找/ 特定/ 的/ 训练/ 集/ ./ 在/ 两台/ 实际/ 机器/ 上/ 的/ 测试数据/ 表明/ ,/ 这种/ 技术/ 对/ SPEC/ 中/ 的/ 部分/ 测试用例/ 的/ 平均/ 加速/ 比为/ 13.1/ %/ 和/ 11.8/ %/ ,/ 比/ 现有/ 的/ 动态/ 池/ 分配/ 技术/ 提高/ 3.7/ %/ 和/ 5.6/ %/ ,/ 对/ 某些/ 例子/ 可达/ 82.2/ %/ ./ 本文/ 的/ 主要/ 贡献/ 包括/ :/ (/ 1/ )/ 根据/ 亲缘/ 性/ 进行/ 池/ 分配/ 的/ 方法/ ./ 这种/ 方法/ 识别/ 对象/ 之间/ 的/ 亲缘/ 性/ ,/ 把/ 可能/ 邻近/ 访问/ 的/ 对象/ 从/ 同一/ 内存/ 池中/ 分配/ ,/ 提高/ 了/ 数据/ 局部性/ ;/ (/ 2/ )/ 在/ 运行/ 时/ 构造/ 存储/ 形状/ 图/ 的/ 方法/ ;/ (/ 3/ )/ 研究/ 了/ 影响/ 池/ 分配/ 效果/ 的/ 各种因素/ ,/ 对/ 何种/ 情况/ 下/ 应该/ 使用/ 池/ 分配/ 技术/ 有/ 指导意义/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 3/ 节/ 介绍/ 我们/ 提出/ 的/ 动态/ 池/ 分配/ 技术/ ;/ 第/ 4/ 节/ 介绍/ 动态/ 池/ 分配/ 的/ 原型/ 系统/ ;/ 第/ 5/ 节/ 进行/ 测试/ 和/ 分析/ ;/ 最后/ 一节/ 是/ 结论/ ./ 2/ 相关/ 工作/ 垃圾/ 收集器/ 能够/ 识别/ 对象/ 的/ 所有/ 引用/ ,/ 因此/ 它/ 有/ 能力/ 安全/ 地/ 在/ 运行/ 时/ 移动/ 一个/ 对象/ ./ 在/ 这种/ 机制/ 的/ 帮助/ 下/ ,/ 一些/ 工作/ 利用/ 在线/ 采样/ 技术/ 收集/ 和/ 分析/ 这些/ 对象/ 的/ 访问/ 模式/ [/ 2/ ]/ 、/ 亲缘/ 性/ [/ 3/ ]/ 或/ 其它/ 运行/ 时/ 特征/ [/ 4/ ]/ ,/ 把/ 一些/ 关系/ 紧密/ 的/ 对象/ (/ 如热/ 访存/ 序列/ 里/ 的/ 相关/ 对象/ )/ 移动/ 到/ 相邻/ 的/ 位置/ ,/ 提高/ 它们/ 的/ 局部性/ ./ 对/ 没有/ 垃圾/ 收集器/ 支持/ 的/ 应用程序/ ,/ Chilimbi/ 等/ 人/ [/ 8/ ]/ 设计/ 了/ 半自动/ 工具/ ccmorph/ ./ 在/ 运行/ 时/ 对/ 树结构/ 中/ 的/ 节点/ 进行/ 布局/ 重组/ ./ 这种/ 方法/ 需要/ 程序员/ 指定/ 树/ 的/ 根/ 节点/ ,/ 并且/ 由/ 程序员/ 确保/ 没有/ 从/ 外部/ 指向/ 叶子/ 节点/ 的/ 指针/ ,/ 以/ 保证/ 重组/ 是/ 安全/ 的/ ./ 他们/ 还/ 设计/ 了/ 另/ 一个/ 工具/ ccmalloc/ ,/ 能够/ 接受/ 程序员/ 的/ 提示/ 在/ 指定/ 对象/ 的/ 附近/ 分配/ 新/ 对象/ ./ 这/ 两个/ 工具/ 都/ 需要/ Page3/ 源代码/ 和/ 程序员/ 提供/ 的/ 标注/ ./ Lattner/ 等/ 人/ [/ 5/ ]/ 设计/ 了/ 一个/ 编译/ 框架/ ,/ 在/ 其中/ 通过/ 指针/ 分析/ 的/ 结果/ 进行/ 数据结构/ 分析/ ./ 他们/ 识别/ 程序/ 中/ 用到/ 的/ 数据结构/ ,/ 把/ 属于/ 同一个/ 数据结构/ 的/ 对象/ 从/ 同一个/ 内存/ 池里/ 分配/ ./ 这种/ 方法/ 同样/ 也/ 需要/ 源代码/ ./ 针对/ 那些/ 没有/ 源代码/ 的/ 应用程序/ ,/ 出现/ 了/ 一些/ 基于/ 剖面/ 分析/ (/ profiling/ )/ 的/ 方法/ [/ 6/ -/ 7/ ,/ 9/ ]/ ./ 文献/ [/ 9/ ]/ 用/ 剖面/ 分析/ 得到/ 热/ 的/ 访存/ 序列/ ,/ 把/ 序列/ 中/ 相邻/ 访问/ 的/ 对象/ 尽量/ 分配/ 在/ 同一个/ 缓存/ 行中/ ,/ 增加/ 缓存/ 行/ 的/ 重用/ 概率/ ./ 文献/ [/ 6/ ]/ 收集/ 训练/ 时堆/ 中/ 对象/ 的/ 访问/ 行为/ 和/ 生命周期/ ,/ 结合/ 分配/ 时/ 的/ 栈/ 指针/ 、/ 路径/ 指针/ 和/ 栈/ 内容/ 等/ 信息/ 预测/ 对象/ 在/ 其它/ 运行/ 中/ 的/ 行为/ ./ 不同/ 类别/ 的/ 对象/ 会/ 从/ 不同/ 的/ 区域/ 分配/ ,/ 但/ 由于/ 划分/ 的/ 粒度/ 较/ 粗/ ,/ 只能/ 减少/ 页/ 缺失/ (/ pagefault/ )/ 的/ 数量/ ./ 这些/ 基于/ 剖面/ 分析/ 的/ 方法/ 需要/ 提供/ 有/ 代表性/ 的/ 训练/ 集/ ,/ 但是/ 对/ 一些/ 实际/ 程序/ ,/ 找到/ 这样/ 的/ 训练/ 集/ 并/ 不/ 容易/ ./ Zhao/ 等/ 人/ [/ 10/ ]/ 提出/ 了/ 一种/ 纯/ 动态/ 的/ 优化/ 技术/ ./ 他们/ 给/ 程序/ 中/ 每/ 一个/ 内存/ 分配/ 点/ (/ 即/ 内存/ 分配/ 函数/ 的/ 调用/ 点/ )/ 建立/ 一个/ 专用/ 的/ 内存/ 池/ ./ 当/ 一个/ 内存/ 分配/ 点/ 分配/ 了/ 足够/ 多/ 同样/ 大小/ 的/ 对象/ 后/ ,/ 它/ 随后/ 分配/ 的/ 内存/ 便/ 从/ 对应/ 的/ 内存/ 池中/ 分配/ ./ 这种/ 方法/ 对/ 一些/ 程序/ 有/ 不错/ 的/ 效果/ ,/ 但是/ 不能/ 解决/ 程序/ 中/ 的/ 一些/ 复杂/ 情况/ ./ 这些/ 情况/ 在/ 3.2/ 和/ 3.3/ 节中/ 有/ 介绍/ ./ 3/ 动态/ 池/ 分配程序/ 在/ 访问/ 数据/ 时/ ,/ 一些/ 对象/ 容易/ 被/ 邻近/ 访问/ 到/ ./ 我们/ 用/ 亲缘/ 性/ (/ affinity/ )/ 来/ 识别/ 数据/ 的/ 这种/ 性质/ ,/ 提出/ 了/ 基于/ 这种/ 亲缘/ 性/ 的/ 动态/ 池/ 分配/ 方案/ ./ 这/ 一节/ 将/ 首先/ 介绍/ 我们/ 的/ 亲缘/ 性/ 定义/ ,/ 接着/ 给出/ 我们/ 在/ 运行/ 时/ 构造/ 存储/ 形状/ 图/ ,/ 并/ 在/ 图/ 中/ 进行/ 亲缘/ 性/ 识别/ 的/ 方法/ ,/ 最后/ 介绍/ 内存/ 池/ 的/ 组织/ 形式/ ./ 3.1/ 亲缘/ 性/ 定义/ 很多/ 数据结构/ (/ 如/ 链表/ 和/ 树/ )/ 是/ 由/ 大量/ 节点/ 组成/ 的/ ,/ 每个/ 节点/ 的/ 指针/ 保存/ 在/ 前/ 一/ 节点/ 中/ ./ 程序/ 要/ 访问/ 其中/ 一个/ 特定/ 节点/ (/ 设为/ NODEn/ )/ ,/ 必须/ 从/ NODEn/ -/ 1/ 中/ 获得/ NODEn/ 的/ 地址/ ,/ 而/ 访问/ NODEn/ -/ 1/ 又/ 需要/ 从/ NODEn/ -/ 2/ 中/ 获得/ 地址/ …/ …/ 以此类推/ ./ 图/ 2/ 展示/ 了/ 两个/ 这样/ 的/ 数据结构/ 以及/ 它们/ 典型/ 的/ 访问/ 顺序/ (/ 图中/ 的/ 序号/ 所示/ )/ ,/ 这些/ 节点/ 很/ 容易/ 被/ 邻近/ 访问/ 到/ ./ 由于/ 这些/ 节点/ 对象/ 直接/ 用/ 指针/ 互相/ 连接/ ,/ 我们/ 把/ 它们/ 之间/ 的/ 这种/ 关系/ 定义/ 为/ I/ 类/ 亲缘/ 性/ ./ 定义/ 1/ ./ I/ 类/ 亲缘/ 性/ ./ 两个/ 对象/ 如果/ 具有/ 相同/ 的/ 类型/ ,/ 并且/ 其中/ 一个/ 对象/ 的/ 指针/ 保存/ 在/ 另/ 一个/ 对象/ 中/ ,/ 那么/ 它们/ 具有/ I/ 类/ 亲缘/ 性/ ./ 此外/ ,/ 如果/ 两个/ 对象/ 都/ 和/ 第三个/ 对象/ 具有/ I/ 类/ 亲缘/ 性/ ,/ 那么/ 这/ 两个/ 对象/ 也/ 具有/ I/ 类/ 亲缘/ 性/ (/ 传递性/ )/ ./ 节点/ 对象/ 里/ 一般/ 包含/ 若干个/ 域/ ./ 在/ 遍历/ 这些/ 数据结构/ 时/ ,/ 各个/ 节点/ 中/ 的/ 同一个/ 域/ 通常/ 具有/ 相似/ 的/ 访存/ 行为/ ,/ 即/ 它们/ 要么/ 都/ 被/ 访问/ ,/ 要么/ 都/ 不/ 访问/ ./ 如/ 链表/ 的/ next/ 域/ 一般/ 都/ 会/ 访问/ 到/ ,/ 而/ data1/ 域/ 可能/ 在/ 一个/ 循环/ 中/ 访问/ ,/ 而/ data2/ 域/ 在/ 另/ 一个/ 循环/ 中/ 访问/ ./ 如果/ 一个/ 域/ 是/ 指向/ 另/ 一种/ 对象/ 的/ 指针/ ,/ 那么/ 这些/ 对象/ 也/ 和/ 这个/ 域/ 一样/ ,/ 容易/ 被/ 邻近/ 访问/ 到/ ./ 图/ 3/ 展示/ 了/ 遍历/ 链表/ 和/ 数组/ 时/ 的/ 典型/ 访问/ 序列/ ./ 这些/ 从/ 数据结构/ 中/ 延伸/ 出来/ 的/ 对象/ 之间/ 并/ 没有/ 直接/ 被/ 指针/ 连接/ ,/ 因此/ 我们/ 把/ 它们/ 的/ 这种/ 关系/ 定义/ 为/ II/ 类/ 亲缘/ 性/ ./ 定义/ 2/ ./ II/ 类/ 亲缘/ 性/ ./ 两个/ 对象/ 如果/ 具有/ 相同/ 的/ 类型/ ,/ 并且/ 它们/ 的/ 指针/ 被/ 保存/ 在/ 具有/ I/ 类/ 亲缘/ 性/ 的/ 两个/ 对象/ 的/ 同一个/ 域/ 中/ ,/ 或/ 数组/ 里/ 的/ 两个/ 对象/ 的/ 同一个/ 域/ 中/ ,/ 那么/ 这/ 两个/ 对象/ 具有/ II/ 类/ 亲缘/ 性/ ./ 和/ 数据/ 的/ 其它/ 性质/ (/ 如/ 文献/ [/ 6/ ,/ 9/ ]/ 中/ 使用/ 的/ 性质/ )/ 相比/ ,/ 这/ 两种/ 亲缘/ 性/ 是从/ 数据/ 之间/ 的/ 存储/ 关系/ 入手/ (/ 即/ 这些/ 数据/ 的/ 指针/ 的/ 保存/ 方式/ )/ ,/ 能够/ 直接/ 反映/ 出/ 这些/ 对象/ 容易/ 被/ 邻近/ 访问/ 的/ 特点/ ./ 依据/ 亲缘/ 性/ 把/ 对象/ 分/ 到/ 不同/ 的/ 对象/ 组/ 里/ ,/ 可以/ 更好/ 地/ 适应/ 它们/ 的/ 访存/ 特点/ ,/ 提高/ 数据/ 局部性/ ./ 然而/ 程序/ 在/ 运行/ 时/ 分配/ 的/ 对象/ 数量/ 可能/ 非常/ 多/ ,/ 为/ 所有/ 的/ 对象/ 一一/ 进行/ 亲缘/ 性/ 分析/ 的/ 代价/ 是/ 无法/ 接受/ 的/ ./ 因此/ 我们/ 把/ 相似/ 的/ 对象/ 分/ 到/ 一个/ 对象/ 组中/ ,/ 抽象/ 成/ 存储/ 形状/ 图/ (/ StorageShapeGraph/ ,/ SSG/ )/ 中/ 的/ 一个/ 节点/ ./ 通过/ 对/ SSG/ 中/ 这些/ 节点/ 的/ 亲缘/ 性/ 分析/ 指导/ 池/ 分配/ ./ 3.2/ 存储/ 形状/ 图/ 我们/ 在/ 运行/ 时低/ 开销/ 地/ 构造/ 存储/ 形状/ 图/ ./ 我们/ Page4/ 所用/ 的/ 存储/ 形状/ 图/ 源于/ 文献/ [/ 11/ -/ 12/ ]/ ,/ 它/ 是/ 一个/ 三元组/ (/ V/ ,/ H/ ,/ E/ )/ ./ V/ 是/ 变量/ 节点/ 的/ 集合/ ,/ 代表/ 全局/ 静态/ 变量/ 和/ 栈/ 上/ 变量/ ./ H/ 是/ 堆/ 节点/ 的/ 集合/ ,/ 每个/ 堆/ 节点/ 代表/ 一个/ 对象/ 组/ (/ 具体/ 构造方法/ 将/ 在/ 3.2/ ./ 1/ 节中/ 介绍/ )/ ./ E/ / (/ V/ ∪/ H/ )/ ×/ H/ ×/ O/ 是/ 边/ 的/ 集合/ ,/ 每条/ 边/ 代表/ 了/ 一组/ 指针/ ./ 当/ 指针/ 是/ 结构/ 体/ 对象/ 中/ 的/ 某个/ 域时/ ,/ O/ 是/ 这个/ 域/ 在/ 结构/ 体内/ 的/ 偏移/ ;/ 否则/ O/ 的/ 值/ 为/ 0/ (/ 此时/ 可以/ 把/ 指针/ 变量/ 看成/ 只有/ 一个/ 域/ 的/ 结构/ 体/ ,/ 0/ 正是/ 这个/ 域/ 在/ 结构/ 体里/ 的/ 偏移/ )/ ./ 图/ 4/ 展示/ 了/ 一段/ 构造/ 链表/ 的/ 代码/ 示例/ 和/ 它/ 对应/ 的/ SSG/ ./ 3.2/ ./ 1/ 构造/ SSG/ 中/ 的/ 节点/ 在/ 二进制/ 代码/ 中/ ,/ 全局变量/ 以/ 一个/ 直接/ 地址/ 表示/ ,/ 栈/ 变量/ 以帧/ 指针/ 寄存器/ (/ 如/ x86/ 程序/ 里/ 的/ ebp/ 寄存器/ )/ 和/ 常数/ 偏移量/ 表示/ ./ 通过/ 这些/ 特征/ 可以/ 识别/ 出/ 全局变量/ 和/ 栈/ 上/ 变量/ ,/ 从而/ 在/ SSG/ 中/ 构造/ 对应/ 的/ 变量/ 节点/ ./ 常用/ 的/ 构造/ SSG/ 中堆/ 节点/ 的/ 方法/ 是/ 基于/ 调用/ 点/ 的/ [/ 11/ ]/ ,/ 即/ 把/ 从/ 同一个/ 调用/ 点/ 分配/ 的/ 对象/ 划分/ 到/ 同一个/ 对象/ 组/ 里/ ,/ 形成/ SSG/ 中/ 的/ 一个/ 堆/ 节点/ ./ 这种/ 方法/ 对/ 部分/ 程序/ 有/ 不错/ 的/ 效果/ ,/ 但/ 不能/ 适用/ 那些/ 采用/ 包装/ 函数/ (/ wrapper/ )/ 的/ 应用程序/ ./ 图/ 5/ 是/ SPECCPU2000/ 中/ 的/ 测试用例/ 300/ ./ twolf/ 里/ 的/ 一个/ 典型/ 的/ 包装/ 函数/ safe/ _/ malloc/ ,/ 这个/ 程序/ 里/ 的/ 所有/ 内存/ 分配/ 都/ 是/ 通过/ 调用/ safe/ _/ malloc/ 来/ 实现/ 的/ ./ safe/ _/ malloc/ 函数/ 里/ 的/ malloc/ 调用/ 点会/ 误导/ 基于/ 调用/ 点/ 的/ 策略/ ,/ 使/ 程序/ 中/ 所有/ 的/ 对象/ 都/ 划分/ 到/ 同一个/ 对象/ 组中/ ,/ 从/ 一个/ 内存/ 池里/ 进行/ 空间/ 分配/ ,/ 这/ 和/ 不/ char/ / safe/ _/ malloc/ (/ size/ )/ unsignedsize/ ;/ {/ }/ 使用/ 池/ 分配/ 相比/ 没有/ 改善/ 数据/ 局部性/ ,/ 失去/ 了/ 池/ 分配/ 的/ 作用/ ./ 类似/ 的/ 包装/ 函数/ 在/ 很多/ 程序/ 中/ 都/ 有/ 应用/ ,/ 例如/ 在/ SPECCPU2000/ 测试/ 集/ 的/ 175/ ./ vpr/ 、/ 176/ ./ gcc/ 、/ 253/ ./ perlbmk/ 和/ 300/ ./ twolf/ 等/ ./ 更/ 糟糕/ 的/ 是/ ,/ 有时/ 这些/ 包装/ 函数/ 可以/ 互相/ 包装/ 几层/ ,/ 例如/ 在/ SPECCPU2006/ 的/ 测试用例/ 483/ ./ xalancbmk/ 中/ ,/ 2.3/ %/ 的/ 动态内存/ 分配/ 是/ 通过/ 一层/ 以上/ 的/ 包装/ 函数/ 实现/ 的/ ./ 典型/ 的/ 包装/ 函数/ 的/ 特征/ 是/ :/ 新/ 分配内存/ 的/ 指针/ 由/ 内存/ 分配/ 函数/ 返回/ 包装/ 函数/ 之后/ ,/ 包装/ 函数/ 没有/ 把/ 指针/ 保存/ 到/ 某个/ 全局变量/ 或/ 某个/ 堆中/ 变量/ 里/ ,/ 也/ 没有/ 对/ 新/ 分配/ 的/ 内存/ 进行/ 写/ 操作/ ,/ 而是/ 把/ 这个/ 指针/ 返回/ 该/ 函数/ 的/ 上/ 一层/ 调用/ 点/ ./ 由于/ 包装/ 函数/ 没有/ 对/ 分配/ 的/ 内存/ 进行/ 有/ 意义/ 的/ 操作/ ,/ 不足以/ 说明/ 它/ 分配/ 的/ 对象/ 是否/ 具有/ 相似性/ ,/ 也/ 就/ 不/ 应该/ 简单/ 地/ 把/ 这些/ 对象/ 划分/ 到/ 一个/ 对象/ 组中/ ./ 程序/ 在/ 调用/ 内存/ 分配/ 函数/ 时/ 的/ 调用/ 链/ 包含/ 了/ 上下文/ 信息/ ,/ 可以/ 用来/ 解决/ 包装/ 函数/ 的/ 问题/ ./ 本文/ 所用/ 的/ 调用/ 链/ 第一项/ 是/ 当前/ 所在/ 函数/ 的/ 被/ 调用/ 地址/ ,/ 随后/ 是/ 当前/ 函数/ 的/ 调用者/ 的/ 被/ 调用/ 地址/ ,/ 以此类推/ ,/ 直到/ main/ 函数/ 中/ 的/ 调用/ 地址/ 为止/ ./ 在/ 运行/ 时/ 通过/ “/ 栈回/ 滚/ ”/ (/ stackunwinding/ )/ [/ 13/ ]/ 可以/ 得到/ 程序/ 当前/ 的/ 调用/ 链/ ,/ 但/ 由于/ 每次/ 分配/ 都/ 需要/ 用/ 完整/ 调用/ 链/ 选择/ 内存/ 池/ ,/ 栈回/ 滚/ 的/ 开销/ 有时/ 会/ 很大/ ,/ 尤其/ 是/ 调用/ 链/ 很长/ (/ 例如/ 存在/ 递归函数/ 调用/ )/ 的/ 程序/ ./ 一些/ 工作/ 使用/ 调用/ 链/ 的/ 前/ n/ 项以/ 降低/ 开销/ ,/ n/ 大多/ 采用/ 经验值/ ./ 但/ 在/ 不同/ 的/ 程序/ ,/ 甚至/ 同一/ 程序/ 的/ 不同/ 的/ 调用/ 点/ 需要/ 的/ 最佳/ n/ 值/ 都/ 可能/ 不同/ ./ 例如/ 在/ 483/ ./ xalancbmk/ 中/ ,/ 许多/ 调用/ 点/ 的/ n/ 值/ 只/ 需要/ 1/ 或/ 2/ ,/ 但是/ 有些/ 调用/ 点/ 需要/ n/ >/ 4/ 才能/ 完全/ 消除/ 包装/ 函数/ 的/ 影响/ ./ 我们/ 提出/ 了/ 使用/ 变/ 长/ 调用/ 链来/ 生成/ 堆/ 节点/ 的/ 方法/ ./ 变长/ 调用/ 链/ 的/ 定义/ 如下/ ./ 定义/ 3/ ./ 变长/ 调用/ 链是/ 完整/ 调用/ 链/ 的/ 一个/ 子集/ ,/ 它/ 从/ 完整/ 调用/ 链/ 的/ 第一项/ 开始/ ,/ 到/ 第一个/ 位于/ 非/ 包装/ 函数/ 内/ 或/ main/ 函数/ 内/ 的/ 调用/ 地址/ 结束/ (/ 包含/ 这个/ 调用/ 地址/ )/ ./ 由于/ 变/ 长/ 调用/ 链是/ 完整/ 调用/ 链/ 的/ 一个/ 子集/ ,/ 它/ 的/ 构造方法/ 也/ 类似/ 于/ 完整/ 调用/ 链/ ,/ 只是/ 结束/ 条件/ 不同/ :/ 它/ 还/ 需要/ 判断/ 所在/ 函数/ 是否/ 为/ 包装/ 函数/ ./ 不过/ 每个/ 函数/ 仅/ 需要/ 识别/ 一次/ 包装/ 函数/ 并/ 记录/ ,/ 这部分/ 开销/ 可以/ 被/ 多次/ 分配/ 请求/ 平摊/ ./ 3.2/ ./ 2/ 构造/ SSG/ 中/ 的/ 边/ 从/ 产生/ 堆/ 节点/ hj/ 的/ 调用/ 点/ 开始/ ,/ 我们/ 对/ hj/ 里/ 的/ Page5/ 对象/ 的/ 指针/ 进行/ 数据流/ 传播/ ./ 当/ 一条/ 访存/ 指令/ 把/ 指针/ 的/ 值/ 写入/ 变量/ var/ 时/ ,/ SSG/ 中/ 就/ 产生/ 对应/ 的/ 边/ ./ 依据/ var/ 的/ 变量/ 类别/ ,/ 产生/ 的/ 边/ 分为/ 两种/ 情况/ :/ (/ 1/ )/ var/ 是/ 全局/ 静态/ 变量/ 或栈/ 上/ 变量/ ,/ 对应/ SSG/ 中/ 的/ 变量/ 节点/ vk/ :/ 此时/ SSG/ 中/ 产生/ 从/ vk/ 到/ hj/ 的/ 一条/ 边/ ,/ 其/ O/ 值为/ 0/ ./ (/ 2/ )/ var/ 是/ 堆/ 对象/ obj/ 中/ 的/ 一个/ 域/ ,/ obj/ 对应/ SSG/ 中/ 的/ 堆/ 节点/ hk/ :/ 此时/ SSG/ 中/ 产生/ 从/ hk/ 到/ hj/ 的/ 一条/ 边/ ,/ 其/ O/ 值/ 是/ 该域/ 在/ obj/ 里/ 的/ 偏移/ ./ 全局/ 静态/ 变量/ 或栈/ 上/ 变量/ 的/ 识别/ 相对/ 简单/ ,/ 而/ 识别/ 堆中/ 的/ 对象/ 则/ 需要/ 其它/ 堆/ 节点/ 的/ 信息/ ./ 访存/ 指令/ 的/ 内存/ 操作数/ (/ 通常/ 具有/ 基址/ 寄存器/ +/ 常数/ 偏移量/ 的/ 形式/ )/ 代表/ 了/ 一个/ 内存/ 变量/ ,/ 我们/ 在/ 访存/ 指令/ 的/ IR/ 中/ 创建/ 一个/ belong/ 集合/ ,/ 表示/ 该/ 内存/ 变量/ 可能/ 属于/ 哪/ 一个/ 堆/ 节点/ ./ 在/ 传播/ 堆/ 节点/ hj/ 中/ 对象/ 的/ 指针/ 时/ ,/ 如果/ 该/ 内存/ 变量/ 的/ 基址/ 寄存器/ 的/ 值/ 等于/ 该/ 指针/ ,/ 就/ 表示/ 这个/ 内存/ 变量/ 是/ hj/ 中/ 对象/ 的/ 一个/ 域/ ,/ 域/ 偏移/ 是/ 操作数/ 的/ 常数/ 偏移量/ ,/ 因此/ 我们/ 在/ 该/ belong/ 集合/ 中/ 增加/ hj/ ./ 这样/ 通过/ 检查/ 该/ 内存/ 变量/ 的/ belong/ 集合/ ,/ 即可/ 得知/ 它/ 所属/ 的/ 堆/ 节点/ ./ 图/ 6/ 是/ 在/ x86/ 平台/ 上/ 构造/ 一小/ 段/ 链表/ 的/ 代码/ 示例/ ./ 指令/ 1/ 产生/ 了/ 新/ 的/ 堆/ 节点/ h1/ ,/ 它/ 的/ 指针/ 被/ 指令/ 2/ 写入/ 全局/ 静态/ 变量/ 0x8048234/ 中/ ,/ 因此/ SSG/ 中/ 增加/ 了/ 从/ 节点/ v1/ 到/ h1/ 的/ 边/ ,/ 边/ 的/ O/ 值为/ 0/ ,/ 如图/ 6/ (/ b/ )/ 所示/ ./ 指令/ 7/ 的/ 内存/ 变量/ 的/ 基址/ 寄存器/ ebx/ 是/ 堆/ 节点/ h1/ 的/ 指针/ ,/ 因此/ 在/ 这条/ 指令/ IR/ 的/ belong/ 集合/ 中/ 增加/ h1/ ./ 图/ 6/ 构造/ 链表/ 节点/ 的/ 代码/ 示例/ (/ x86/ 平台/ )/ 以及/ 对应/ 的/ SSG/ 当/ 程序/ 通过/ 指令/ 5/ 分配/ 了/ 新/ 对象/ (/ 对应/ SSG/ 中/ 的/ 堆/ 节点/ h2/ )/ 后/ ,/ 我们/ 把/ 新/ 对象/ 的/ 指针/ 进行/ 传播/ ./ 当/ 传播/ 到/ 指令/ 7/ 时/ ,/ 发现/ 该/ 访存/ 指令/ 把/ 新/ 对象/ 的/ 指针/ 写入/ 内存/ ,/ 且/ 该/ 指令/ IR/ 里/ 的/ belong/ 集合/ 中/ 包含/ h1/ ,/ 因此/ 在/ SSG/ 中/ 增加/ 从/ h1/ 到/ h2/ 的/ 一条/ 边/ ,/ 边/ 的/ O/ 值/ 即/ 为/ 该/ 内存/ 变量/ 的/ 常数/ 偏移量/ 4/ ,/ 如图/ 6/ (/ c/ )/ 所示/ ./ 我们/ 的/ 传播/ 和/ 分析/ 只/ 在/ 过程/ 内/ 进行/ (/ intra/ -/ procedure/ )/ ,/ 这/ 是因为/ 它/ 的/ 开销/ 比/ 过程/ 间/ 分析/ 要少/ ./ 在/ 动态/ 优化/ 系统/ 中/ 必须/ 严格控制/ 额外/ 的/ 开销/ ,/ 如果/ 开销/ 超过/ 了/ 优化/ 的/ 收益/ 则/ 会/ 得不偿失/ ./ 另外/ 通过/ 在/ 源代码/ 中/ 的/ 观察/ ,/ 我们/ 发现/ 程序/ 在/ 分配/ 了/ 一个/ 对象/ 后/ ,/ 通常/ 很快/ 就/ 会/ 把/ 对象/ 指针/ 保存/ 在/ 某个/ 内存/ 位置/ ,/ 类似/ 图/ 6/ (/ a/ )/ 中/ 的/ 程序/ 那样/ ./ 因此/ 过程/ 内/ 的/ 分析/ 通常/ 就/ 能够/ 发现/ 这些/ 操作/ 并/ 相应/ 地/ 更新/ SSG/ ./ 相对/ 于/ 更/ 精确/ 的/ 过程/ 间/ 分析/ ,/ 我们/ 的/ 方法/ 可能/ 会/ 在/ SSG/ 中少/ 一些/ 边/ ,/ 但/ 这/ 只/ 可能/ 影响/ 池/ 分配/ 的/ 决策/ ,/ 而/ 不会/ 影响/ 程序/ 的/ 正确性/ ./ 此外/ 我们/ 还/ 通过/ 一个/ 地址/ 表/ 和/ 解释器/ (/ interpreter/ )/ 来/ 进行/ 补充/ 分析/ ,/ 尽量/ 弥补/ 在/ 精度/ 上/ 的/ 损失/ ./ 地址/ 表中/ 记录/ 了/ 每个/ 堆/ 节点/ 中/ 最先/ 分配/ 的/ 若干个/ 对象/ 的/ 大小/ 和/ 地址/ ,/ 还有/ 创建/ 的/ 内存/ 池/ 的/ 大小/ 和/ 地址/ ./ 在/ 堆/ 节点/ 中/ 的/ 第一个/ 对象/ 分配/ 后/ ,/ 我们/ 使用/ 解释器/ 模拟/ 执行/ 随后/ 的/ 一段/ 指令/ ,/ 直到/ 对象/ 的/ 指针/ 不再/ 保留/ 在/ 寄存器/ 中/ ,/ 从而/ 得到/ 指针/ 被/ 写入/ 的/ 实际/ 内存地址/ (/ 可能/ 有/ 多个/ )/ ./ 通过/ 查询/ 地址/ 表/ ,/ 可以/ 得到/ 写入/ 地址/ 对应/ 哪个/ 堆/ 节点/ 对象/ 里/ 的/ 哪个/ 域/ ,/ 从而/ 相应/ 地/ 更新/ SSG/ ./ 3.3/ 存储/ 形状/ 图上/ 的/ 亲缘/ 性/ 分析/ 在/ SSG/ 中/ ,/ 每个/ 堆/ 节点/ 代表/ 了/ 通过/ 变/ 长/ 调用/ 链/ 生成/ 的/ 对象/ 组/ ./ 但是/ 程序/ 中/ 一些/ 具有/ 亲缘/ 性/ 的/ 对象/ 是从/ 不同/ 的/ 内存/ 分配/ 调用/ 点/ 分配/ 的/ ./ 产生/ 这种/ 情况/ 的/ 原因/ 有/ 两个/ ./ 其一/ 是/ 由/ 程序员/ 产生/ ,/ 例如/ 程序员/ 在/ 程序/ 里/ 的/ 几个/ 片段/ 中/ 都/ 动态分配/ 节点/ ,/ 并/ 把/ 它们/ 插入/ 同一个/ 链表/ ./ 另/ 一个/ 原因/ 是/ 由/ 编译器/ 优化/ 产生/ ,/ 例如/ 循环展开/ (/ loopunrolling/ )/ 优化/ 会/ 把/ 循环/ 体内/ 的/ 一个/ 内存/ 分配/ 点/ 复制/ 若干次/ ,/ 变为/ 多个/ 内存/ 分配/ 点/ ./ 编译器/ 在/ 对/ 函数/ 进行/ 内联/ (/ inlining/ )/ 优化/ 时/ 也/ 会/ 产生/ 同样/ 的/ 问题/ ./ 如果/ 不/ 把/ 这些/ 对象/ 组/ 进行/ 合并/ ,/ 它们/ 的/ 对象/ 会/ 被/ 分散/ 到/ 不同/ 的/ 内存/ 池里/ ,/ 破坏/ 了/ 数据/ 局部性/ ./ 表现形式/ 是/ :/ 两个/ 对象/ 组/ 的/ 对象/ 之间/ 的/ 亲缘/ 性/ 在/ SSG/ 中/ 的/ (/ 1/ )/ 当/ 两个/ 对象/ 组/ 的/ 对象/ 之间/ 具有/ I/ 类/ 亲缘/ 性时/ ,/ 它们/ 的/ 堆/ 节点/ 之间/ 会/ 有/ 一条/ 边/ ./ (/ 2/ )/ 当/ 两个/ 对象/ 组/ 的/ 对象/ 之间/ 具有/ II/ 类/ 亲缘/ 性时/ ,/ 它们/ 具有/ 从/ 同一个/ 节点/ 出发/ 的/ 两条/ 边/ ,/ 或者/ 从/ I/ 类/ 亲缘/ 的/ 两个/ 节点/ 出发/ 的/ 两条/ 边/ ;/ 并且/ 两条/ 边/ 的/ O/ 值/ (/ 边/ 代表/ 的/ 指针/ 在/ 结构/ 体中/ 的/ 域/ 偏移/ )/ 是/ 相同/ 的/ ./ 我们/ 依据/ 上述/ 特征/ ,/ 在/ SSG/ 中/ 进行/ 堆/ 节点/ 之间/ 的/ 亲缘/ 性/ 识别/ ,/ 把/ 具有/ 亲缘/ 性/ 的/ 堆/ 节点/ 合并/ ./ 例如/ 根据/ 上面/ 的/ 形式/ (/ 1/ )/ ,/ 图/ 6/ (/ c/ )/ 中/ 的/ h1/ 和/ h2/ 节点/ 具有/ I/ 类/ 亲缘/ 性/ ,/ 应当/ 被/ 合并/ ./ Page6/ 识别/ 对象/ 之间/ 的/ 亲缘/ 性/ 需要/ 比较/ 这些/ 对象/ 的/ 类型/ ,/ 但是/ 在/ 二进制/ 代码/ 中/ 无法/ 得到/ 类型信息/ ./ 在/ 我们/ 的/ 原型/ 系统/ 中/ ,/ 将/ 判断/ 亲缘/ 性/ 的/ 条件/ 放宽/ ,/ 即将/ “/ 两个/ 对象/ 具有/ 相同/ 的/ 类型/ ”/ 放宽/ 为/ “/ 两个/ 对象/ 具有/ 相同/ 的/ 大小/ ”/ ./ 尽管/ 大小/ 相同/ 的/ 对象/ 不/ 一定/ 是/ 同一/ 类型/ ,/ 但是/ 我们/ 放宽/ 条件/ 的/ 做法/ 在/ 大多数/ 情况/ 下/ 还是/ 有效/ 的/ ./ 只有/ 在/ 两个/ 对象/ 类型/ 不同/ 但/ 大小/ 相同/ ,/ 而且/ 满足/ 其它/ 亲缘/ 性/ 判定/ 条件/ 的/ 情况/ 下/ 才/ 会/ 出现/ 误判/ ./ 即使/ 出现/ 误判/ ,/ 它/ 也/ 只会/ 影响/ 堆中/ 的/ 数据/ 布局/ ,/ 而/ 不会/ 影响/ 程序/ 的/ 正确性/ ./ 通过/ 对/ 本文/ 所用/ 的/ 测试用例/ 的/ 人工/ 检查/ ,/ 只有/ 197/ ./ parser/ 中有/ 19/ %/ 的/ 误判/ 率/ ,/ 而且/ 这些/ 误判/ 最终/ 并/ 没有/ 对/ 程序/ 性能/ 造成/ 负面影响/ ./ 3.4/ 内存/ 池/ 的/ 组织/ 当/ 内存/ 池中/ 的/ 对象/ 数量/ 较/ 少时/ ,/ 对/ 它们/ 进行/ 池/ 分配/ 并/ 不会/ 太/ 多/ 改善/ 局部性/ ,/ 反而/ 会/ 增加/ 管理/ 开销/ 和/ 空间/ 浪费/ ./ 另外/ 内存/ 池中/ 的/ 对象/ 大小/ 较大/ 时/ ,/ 相邻/ 对象/ 的/ 数据/ 很/ 可能/ 不/ 在/ 同一个/ 缓存/ 行中/ ,/ 对/ 这种/ 对象/ 进行/ 池/ 分配/ 也/ 没有/ 太/ 大/ 必要/ ./ 因此/ 我们/ 的/ 原型/ 系统对/ 每个/ 对象/ 组/ 的/ 最早/ 分配/ 的/ 若干个/ 对象/ ,/ 调用/ 系统/ 的/ 分配/ 函数/ 来/ 分配/ ,/ 并/ 统计/ 对象/ 的/ 数量/ 和/ 大小/ ./ 只有/ 当/ 对象/ 组里/ 的/ 对象/ 数量/ 超过/ m/ ,/ 且/ 它们/ 的/ 大小/ 都/ 小于/ n/ 字节/ 时/ ,/ 才/ 开始/ 对/ 该/ 对象/ 组/ 随后/ 的/ 对象/ 进行/ 池/ 分配/ ,/ 否则/ 将/ 一直/ 使用/ 系统/ 的/ 分配/ 函数/ 来/ 分配/ ./ 经过/ 实际/ 测试/ ,/ m/ =/ 100/ 和/ n/ =/ 128/ 是/ 较/ 好/ 的/ 阈值/ ./ 由于/ 无法/ 预测/ 一个/ 内存/ 池/ 需要/ 多大/ 空间/ ,/ 因此/ 固定/ 大小/ 的/ 内存/ 池/ 容易/ 不够/ 用/ 或/ 造成/ 空间/ 浪费/ ./ 我们/ 使用/ 的/ 内存/ 池/ 并/ 不是/ 一整块/ 内存空间/ ,/ 而是/ 由/ 若干个/ 内存/ 池段/ 组成/ 的/ ./ 新创建/ 的/ 内存/ 池/ 只有/ 一个/ 内存/ 池段/ ,/ 其中/ 的/ 空间/ 分配/ 完/ 之后/ 再/ 增加/ 新/ 的/ 内存/ 池段/ ;/ 内存/ 池段/ 中/ 的/ 对象/ 如果/ 都/ 被/ 释放/ ,/ 则/ 回收/ 这个/ 内存/ 池段/ ./ 通过/ 这种/ 组织/ 方式/ ,/ 每个/ 内存/ 池/ 的/ 大小/ 随着/ 需求/ 增长/ ,/ 既/ 不会/ 因为/ 空间/ 不够/ 而/ 无法/ 分配/ ,/ 也/ 不会/ 造成/ 太多/ 的/ 空间/ 浪费/ (/ 每个/ 内存/ 池里/ 最/ 多/ 可能/ 浪费/ 最新/ 分配/ 的/ 一个/ 内存/ 池段/ )/ ./ 内存/ 池段/ 的/ 长度/ 需要/ 仔细/ 选择/ ./ 太大/ 可能/ 造成/ 过多/ 的/ 空间/ 浪费/ ,/ 而/ 太小/ 会/ 产生/ 过多/ 的/ 内存/ 池段/ ,/ 破坏/ 内存/ 池里/ 数据/ 的/ 连续性/ ,/ 并/ 增加/ 内存/ 池段/ 的/ 管理/ 开销/ ./ 我们/ 选择/ 了/ 从/ 1KB/ 到/ 64KB/ 的/ 几种/ 不同/ 的/ 内存/ 池/ 段长度/ ,/ 在/ 不同/ 的/ 平台/ 上/ 进行/ 了/ 测试/ ./ 我们/ 发现/ 虽然/ 这些/ 平台/ 的/ 虚拟/ 页/ 大小/ 并不相同/ ,/ 从/ 4KB/ 到/ 16KB/ 不/ 等/ ,/ 但/ 4KB/ 的/ 内存/ 池/ 段长度/ 在/ 各个/ 平台/ 上/ 都/ 能/ 得到/ 最佳/ 或/ 接近/ 最佳/ 的/ 性能/ ./ 多数/ 内存/ 池/ (/ 本文/ 测试用例/ 里/ 占/ 78.6/ %/ )/ 中/ 的/ 对象/ 具有/ 固定/ 大小/ ,/ 因此/ 我们/ 在/ 内存/ 池段/ 中/ 采用/ 一种/ 轻量级/ 的/ 分配/ 算法/ ./ 该/ 算法/ 在/ 内存/ 池段/ 中/ 维护/ 空闲/ 列表/ (/ freelist/ )/ 和/ 最远/ 已/ 分配/ 对象/ 的/ 指针/ p/ ./ 分配/ 请求/ 优先/ 从/ 空闲/ 列表/ 中/ 满足/ ,/ 当/ 空闲/ 列表/ 为/ 空时/ ,/ 新/ 对象/ 通过/ 移动/ 指针/ p/ 来/ 分配/ ./ 相比/ 需要/ 额外/ 对象/ 头/ (/ objectheader/ )/ 的/ dlmalloc/ ,/ 这种/ 算法/ 产生/ 的/ 布局/ 更为/ 紧凑/ ./ 例如/ 在/ 183/ ./ equake/ 中有/ 超过/ 15/ 万个/ 16/ 字节/ 的/ 小/ 对象/ ./ 去掉/ 4/ 字节/ 的/ 对象/ 头会/ 使/ 其/ 占用/ 的/ 空间/ 减少/ 33/ %/ (/ 对象/ 需要/ 8/ 字节/ 对齐/ )/ ./ 此外/ 该/ 算法/ 在/ 分配/ // 回收/ 时/ 只/ 需要/ 移动/ 指针/ 或/ 修改/ 空闲/ 链表/ 头/ ,/ 需要/ 的/ 操作/ 较/ 少/ ;/ 而/ dlmalloc/ 在/ 释放/ 时会/ 查看/ 前后/ 对象/ 并/ 合并/ 相邻/ 碎片/ ,/ 这/ 需要/ 较/ 多/ 的/ 访存/ 和/ 运算/ 操作/ ./ 因此/ 这种/ 轻量级/ 的/ 算法/ 比/ dlmalloc/ 的/ 时间/ 开销/ 要/ 小/ ./ 图/ 7/ 展示/ 的/ 就是/ 使用/ 这种/ 算法/ 的/ 内存/ 池段/ 分配/ 示例/ ./ 少数/ 内存/ 池里/ 的/ 对象/ 长度/ 不/ 固定/ ,/ 这些/ 对象/ 通常/ 用作/ 数组/ 或/ 字符串/ ./ 在/ 它们/ 的/ 内存/ 池段/ 中/ ,/ 我们/ 采用/ 类似/ dlmalloc/ 的/ 基于/ 空闲/ 链表/ 并且/ 合并/ 相邻/ 碎片/ 的/ 算法/ ./ 这种/ 算法/ 需要/ 一个/ 对象/ 头来/ 保存/ 一些/ 管理/ 信息/ ,/ 以/ 保证/ 能够/ 正确/ 地/ 对/ 各种/ 大小/ 的/ 内存/ 进行/ 回收/ ./ 4/ 动态/ 池/ 分配/ 系统/ 我们/ 在/ x86/ // Linux/ 平台/ 上/ 实现/ 了/ 动态/ 池/ 分配/ 原型/ 系统/ DigitalBridge/ -/ dopt/ ./ 它/ 不/ 需要/ 修改/ 操作系统/ 或/ 可执行程序/ ,/ 而是/ 通过/ 指定/ LD/ _/ PRELOAD/ 环境变量/ [/ 14/ ]/ 的/ 方式/ ,/ 在/ 运行/ 时用/ 动态/ 池/ 分配器/ 替换/ 程序/ 原有/ 的/ 内存/ 分配/ 函数/ ./ 原型/ 系统/ 的/ 框架/ 如图/ 8/ 所示/ ./ 当/ 应用程序/ 从堆/ 中/ 申请/ 内存/ 时/ ,/ 如果/ 是/ 新堆/ 节点/ 的/ 第一个/ 对象/ ,/ 动态/ 池/ 分配器/ 会/ 进行/ 第/ 3/ 节/ 介绍/ 的/ 各种/ 分析/ 并/ 更新/ 存储/ 形状/ 图/ ,/ 确定/ 堆/ 节点/ 所属/ 的/ 内存/ 池/ ,/ 把/ 堆/ 节点/ 到/ 内存/ 池/ 的/ 映射/ 关系/ 写入/ Hash/ 表/ ./ 堆/ 节点/ 中/ 的/ 后续/ 对象/ 可以/ 直接/ 通过/ Hash/ 表查/ 到/ 该/ 内存/ 池/ ,/ 避免/ 了/ 对/ 同一个/ 堆/ 节点/ 中/ 的/ 对象/ 进行/ Page7/ 重复/ 分析/ ./ 为了/ 进一步/ 减少/ 查/ Hash/ 表/ 的/ 开销/ ,/ 我们/ 通过/ 插桩/ 模块/ 在/ 一些/ 堆/ 节点/ 的/ 变长/ 调用/ 链/ 的/ 最上层/ 调用/ 点/ 提供/ 一个/ 额外/ 的/ 参数/ ,/ 指明/ 它/ 所属/ 的/ 内存/ 池/ ./ 这些/ 堆/ 节点/ 的/ 对象/ 分配/ 可以/ 直接/ 使用/ 这个/ 参数/ 从/ 内存/ 池里/ 分配/ ,/ 不再/ 需要/ 查询/ Hash/ 表/ ./ 5/ 性能/ 测试/ 5.1/ 平台/ 配置/ 和/ 测试用例/ 实验/ 平台/ 有/ 4/ 个/ 单核/ 处理器/ (/ IntelNorthwood/ 家族/ ,/ 2.40/ GHz/ 主频/ ,/ 一级/ 缓存/ 32KB/ ,/ 二级缓存/ 512KB/ )/ ,/ 2GB/ 内存/ ./ 操作系统/ 采用/ 的/ 是/ Linux2/ ./ 6.27/ ,/ 其中/ 2.9/ 版本/ 的/ libc/ 所用/ 的/ 内存/ 分配/ 函数/ 是/ dlmalloc/ 的/ 修改版/ ./ 实验/ 所用/ 的/ 11/ 个/ C/ // C++/ 测试用例/ 选自/ SPECCPU2000/ 和/ SPECCPU2006/ 测试/ 集/ ,/ 如表/ 1/ 所示/ ./ 测试用例/ 的/ 选择/ 标准/ 是/ 在/ 内存/ 池中/ 分配/ 的/ 数据/ 超过/ 1MB/ (/ 2/ 倍/ 二级缓存/ 大小/ )/ ,/ 并且/ 超过/ 堆中/ 总/ 数据量/ 的/ 1/ %/ ./ 表/ 1/ 之外/ 的/ 其它/ 例子/ 由于/ 堆/ 数据/ 布局/ 的/ 变化/ 很小/ ,/ 因此/ 它们/ 的/ 运行/ 时间/ 没有/ 明显/ 变化/ ./ 测试/ 名/ 编程语言/ 175/ ./ vpr197/ ./ parser253/ ./ perlbmkC300/ ./ twolf197/ ./ art183/ ./ equake473/ ./ astar483/ ./ xalancbmk/ C++/ XML/ 处理/ 447/ ./ dealII453/ ./ povray482/ ./ sphinx3/ 需要/ 说明/ 的/ 是/ ,/ 197/ ./ parser/ 中/ 使用/ 的/ 是/ 一个/ 定制/ 的/ 内存/ 分配/ 函数/ ,/ 其/ 行为/ 和/ dlmalloc/ 类似/ ./ 由于/ 我们/ 无法/ 截取/ 定制/ 的/ 内存/ 分配/ 函数/ (/ 这/ 需要/ 从/ 语义上/ 判断/ 一个/ 函数/ 是否/ 具有/ 分配内存/ 的/ 功能/ )/ ,/ 为了/ 达到/ 实验/ 的/ 目的/ ,/ 我们/ 把/ 它/ 定制/ 的/ 内存/ 分配/ 函数/ 替换成/ 调用/ 系统/ 默认/ 的/ dlmalloc/ 分配/ 函数/ ,/ 以便/ 我们/ 截取/ 内存/ 分配/ 请求/ ./ 所有/ 测试用例/ 是/ 使用/ GCC4/ ./ 3.2/ 的/ -/ -/ O3/ 优化/ 选项/ 编译/ 生成/ 的/ ,/ 使用/ reference/ 输入/ 集/ ./ 本节/ 所/ 展示/ 的/ 运行/ 时间/ 是/ 程序/ 三次/ 运行/ 时间/ 的/ 平均值/ ./ 5.2/ 动态/ 池/ 分配/ 的/ 效果/ 本文/ 的/ 基于/ 亲缘/ 性/ 的/ 动态/ 池/ 分配/ 技术/ 对/ 测试用例/ 的/ 加速/ 比如/ 图/ 9/ 所示/ ./ 图中/ 也/ 展示/ 了/ 现有/ 的/ 基于/ 调用/ 点/ 的/ 池/ 分配/ 技术/ [/ 10/ ]/ 的/ 性能/ ./ 加速/ 比以/ 没有/ 池/ 分配/ 优化/ 的/ 程序运行/ 时间/ 为/ 基准/ ./ 本文/ 的/ 方法/ 提高/ 了/ 7/ 个/ 例子/ 的/ 性能/ ,/ 提升/ 幅度/ 大多/ 超过/ 了/ 20/ %/ ,/ 剩余/ 的/ 例子/ 也/ 没有/ 明显/ 的/ 性能/ 下降/ ./ 本文/ 的/ 方法/ 对/ 所有/ 例子/ 的/ 平均/ 加速/ 比/ 达到/ 了/ 13.1/ %/ ./ 比/ 已有/ 的/ 基于/ 调用/ 点/ 的/ 池/ 分配/ 方法/ 提高/ 3.7/ %/ ./ 动态/ 池/ 分配/ 的/ 收益/ 来自/ 3/ 个/ 方面/ ,/ 它们/ 在/ 总/ 收益/ 中所/ 占/ 比例/ 如图/ 10/ 所示/ :/ (/ 1/ )/ 改善/ 了/ 数据/ 布局/ ./ 例如/ 483/ ./ xalancbmk/ 中/ 的/ 几个/ 对象/ 组各有/ 188718/ 个/ 小/ 对象/ ,/ 在/ 使用/ 系统/ 的/ 内存/ 分配器/ 时/ ,/ 这些/ 数据/ 会/ 被/ 分散/ 到/ 200MB/ 范围/ 内/ ,/ 遍历/ 它们/ 时会/ 产生/ 很多/ 缓存/ 缺失/ ./ 而/ 这些/ 数据/ 在/ 使用/ 池/ 分配/ 后/ 只/ 占据/ 3MB/ ~/ 6MB/ 的/ 空间/ ,/ 局部性/ 得到/ 了/ 很大/ 改善/ ./ (/ 2/ )/ 减少/ 了/ 数据量/ ./ 在/ 3.4/ 节/ 介绍/ 的/ 内存/ 池段/ 分配/ 算法/ 不/ 需要/ 额外/ 的/ 对象/ 头/ ,/ 因此/ 程序/ 用到/ 的/ 数据/ 排列/ 的/ 更加/ 紧凑/ ,/ 减少/ 了/ 它们/ 所/ 占/ 的/ 空间/ ./ 例如/ 在/ 183/ ./ equake/ 中有/ 超过/ 15/ 万个/ 16/ 字节/ 的/ 小/ 对象/ ./ 去掉/ 4/ 字节/ 的/ 对象/ 头会/ 使/ 其/ 占用/ 的/ 空间/ 减少/ 33/ %/ (/ 需要/ 8/ 字节/ 对齐/ )/ ./ (/ 3/ )/ 内存/ 的/ 分配/ // 回收/ 更快/ ./ 在/ 3.4/ 节/ 介绍/ 的/ 内存/ 池段/ 分配/ 算法/ 比/ dlmalloc/ 要/ 快/ ./ 197/ ./ parser/ 进行/ 了/ 大约/ 10/ 亿次/ 内存/ 分配/ ,/ 因而/ 从中/ 得到/ 了/ 较大/ 收益/ ./ Page8/ 有些/ 例子/ (/ 如/ 253/ ./ perlbmk/ 和/ 453/ ./ povray/ )/ 产生/ 的/ 缓存/ 缺失/ 较/ 少/ ,/ 说明/ 它们/ 已/ 具有/ 较/ 好/ 的/ 数据/ 局部性/ ,/ 再/ 进行/ 局部性/ 优化/ 的/ 改善/ 性能/ 的/ 空间/ 不大/ ./ 有些/ 内存/ 池里/ 的/ 对象/ 不是/ 被/ 程序/ 遍历/ 访问/ ,/ 如/ 175/ ./ vpr/ 中/ 的/ 内存/ 池里/ 的/ 对象/ 是/ 用来/ 构造/ Hash/ 表/ 的/ ,/ 把/ 它们/ 聚集/ 在/ 内存/ 池里/ 也/ 无法/ 改善/ 它们/ 的/ 局部性/ ./ 因此/ 这些/ 例子/ 没有/ 得到/ 性能/ 提高/ ,/ 但/ 也/ 没有/ 降低/ ./ 表/ 2/ 是/ 动态/ 池/ 分配/ 优化/ 前后/ 的/ 二级缓存/ (/ 最末/ 测试用例/ 原/ 缓存/ 175/ ./ vpr197/ ./ parser253/ ./ perlbmk139300/ ./ twolf197/ ./ art183/ ./ equake473/ ./ astar483/ ./ xalancbmk4992447/ ./ dealII453/ ./ povray482/ ./ sphinx31262312840102/ 表/ 3/ 动态/ 池/ 分配/ 前后/ 的/ TLB/ 缺失/ 数量/ 测试用例/ 原/ 缓存/ 缺失/ 数/ // M/ 池/ 分配/ 后/ 的/ 缓存/ 缺失/ 数/ // M/ 比例/ // %/ 原/ TLB/ 缺失/ 数/ // M/ 池/ 分配/ 后/ 的/ TLB/ 缺失/ 数/ // M/ 比例/ // %/ 175/ ./ vpr197/ ./ parser253/ ./ perlbmk300/ ./ twolf197/ ./ art183/ ./ equake473/ ./ astar483/ ./ xalancbmk1671447/ ./ dealII453/ ./ povray482/ ./ sphinx3/ 可以/ 看到/ ,/ 483/ ./ xalancbmk/ 在/ 平台/ #/ 2/ 上/ 有/ 更/ 高/ 的/ 加速/ 比/ (/ 82.2/ %/ )/ ,/ 而/ 300/ ./ twolf/ 和/ 179/ ./ art/ 则/ 没有/ 加速/ (/ 它们/ 在/ #/ 1/ 上/ 有/ 20/ %/ 左右/ 的/ 提高/ )/ ./ 池/ 分配/ 技术/ 在/ 不同/ 机器/ 上/ 的/ 性能/ 差异/ 主要/ 由/ 两个/ 原因/ 引起/ :/ (/ 1/ )/ 缓存/ 的/ 大小/ ./ 假设/ 一个/ 程序/ 重复/ 遍历/ 大量/ 小/ 对象/ ,/ 系统/ 分配/ 函数/ 把/ 它们/ 分布/ 在/ 12MB/ 的/ 空间/ 一级/ 缓存/ )/ 的/ 缺失/ 数量/ ./ 从表中/ 可以/ 看到/ ,/ 动态/ 池/ 分配/ 平均/ 能够/ 减少/ 15/ %/ 的/ 缓存/ 缺失/ ./ 453/ ./ povray/ 的/ 缓存/ 缺失/ 数量/ 有/ 一定/ 增加/ (/ 因为/ 我们/ 的/ 动态/ 池/ 分配/ 模块/ 本身/ 也/ 会/ 产生/ 缓存/ 缺失/ )/ ,/ 但是/ 其/ 绝对/ 数量/ 相对/ 其它/ 测试用例/ 来说/ 相当/ 小/ ,/ 对/ 性能/ 的/ 影响/ 也/ 可以/ 忽略/ ./ 对照表/ 2/ 和/ 图/ 9/ ,/ 可以/ 看到/ 凡是/ 缓存/ 缺失/ 有/ 明显/ 减少/ 的/ 测试用例/ 都/ 得到/ 了/ 性能/ 加速/ ./ 动态/ 池/ 分配/ 技术/ 也/ 可以/ 降低/ 其中/ 一些/ 程序/ 的/ TLB/ 缺失/ ,/ 但/ 该/ 实验/ 平台/ 缺乏/ 统计/ TLB/ 缺失/ 的/ 硬件/ 支持/ ./ 下/ 一/ 小节/ 将会/ 展示/ 另/ 一/ 实验/ 平台/ 的/ TLB/ 缺失/ 数据/ 作为/ 参考/ ./ 5.3/ 缓存/ 大小/ 对/ 动态/ 池/ 分配/ 的/ 影响/ 为了/ 研究/ 动态/ 池/ 分配/ 技术/ 在/ 其它/ 平台/ 上/ ,/ 尤其/ 是/ 缓存/ 大小/ 不同/ 的/ 环境/ 下/ 的/ 效果/ ,/ 我们/ 在/ 另一台/ 服务器/ (/ 称为/ #/ 2/ )/ 上/ 测试/ 了/ 动态/ 池/ 分配/ 技术/ ./ 平台/ #/ 2/ 采用/ 2/ 个/ IntelHarpertown/ 系列/ 4/ 核/ 处理器/ ,/ 有/ 6MB/ 二级缓存/ 和/ 16GB/ 内存/ ./ 动态/ 池/ 分配/ 技术/ 在/ 这个/ 平台/ 上/ 的/ 加速/ 比如/ 图/ 11/ 所示/ ./ 平台/ #/ 2/ 上/ 优化/ 前后/ 的/ 缓存/ 和/ TLB/ 缺失/ 如表/ 3/ 所示/ ./ 1014310686206250393316920956899/ 中/ ,/ 此时/ 6MB/ 和/ 512KB/ 的/ 缓存/ 都/ 会/ 工作/ 得/ 很/ 差/ ./ 池/ 分配/ 后/ 这些/ 对象/ 只/ 占据/ 6MB/ 空间/ ,/ 这时/ 6MB/ 的/ 缓存/ 可以/ 基本/ 装下池/ 分配/ 后/ 的/ 数据/ ,/ 因此/ 可以/ 产生/ 更/ 高/ 的/ 性能/ 提升/ ./ 然而/ 在/ 更/ 大/ 的/ 缓存/ 下/ (/ 例如/ 15MB/ ,/ 足够/ 装下池/ 分配/ 前/ 的/ 数据/ )/ ,/ 池/ 分配/ 通常/ 不会/ 提高/ 性能/ ./ Page9/ (/ 2/ )/ 平台/ #/ 2/ 的/ CPU/ 更/ 先进/ ,/ 所以/ 存储/ 墙/ 的/ 问题/ 在/ 这个/ 平台/ 上/ 会/ 显得/ 更加/ 突出/ ./ 因此/ 存储/ 方面/ 的/ 改善/ 会/ 产生/ 更/ 明显/ 的/ 效果/ ./ 为了/ 研究/ 缓存/ 大小/ 对池/ 分配/ 的/ 影响/ ,/ 我们/ 在/ 平台/ #/ 2/ 上/ 采用/ 了/ 基于/ 操作系统/ 中页/ 着色/ (/ pagecoloring/ )/ [/ 15/ -/ 16/ ]/ 的/ 缓存/ 划分/ (/ cachepartitioning/ )/ 技术/ ./ 这种/ 缓存/ 划分/ 技术/ 利用/ 页表/ ,/ 把/ 程序/ 的/ 虚拟空间/ 映射/ 到/ 特定/ 的/ 一些/ 物理/ 页/ 中/ ./ 这些/ 物理/ 页/ 又/ 映射/ 到/ 特定/ 的/ 一些/ 缓存/ 行中/ ,/ 从而/ 控制/ 了/ 程序/ 可用/ 的/ 缓存/ 大小/ ./ 我们/ 在/ 平台/ #/ 2/ 上用/ 不同/ 缓存/ 大小/ 测试/ 了/ 6/ 个/ 产生/ 加速/ 的/ 测试用例/ ,/ 图/ 12/ 显示/ 了/ 池/ 分配/ 后/ 的/ 缓存/ 缺失/ 数量/ 占/ 原程序/ 的/ 缓存/ 缺失/ 数量/ 的/ 比例/ ,/ 有/ 一些/ 比例/ 被/ 设置/ 成/ 了/ 1.0/ ,/ 因为/ 它们/ 的/ 缓存/ 缺失/ 数量/ 太/ 少/ (/ 小于/ 1/ 亿次/ )/ ./ 图/ 12/ 不同/ 缓存/ 大小/ 的/ 池/ 分配/ 前后/ 缓存/ 缺失/ 基于/ 上/ 面对/ 因素/ (/ 1/ )/ 的/ 分析/ ,/ 当/ 缓存/ 大小/ 和/ 数据量/ 大小/ 相差/ 不大时/ ,/ 随着/ 缓存/ 大小/ 的/ 减小/ ,/ 缺失/ 比例/ (/ 池/ 分配/ 后/ 的/ 缓存/ 缺失/ 数/ // 池/ 分配/ 前/ 的/ 缓存/ 缺失/ 数/ )/ 应该/ 呈现/ 一个/ “/ V/ ”/ 字型/ ,/ 即先/ 下降/ 再/ 上升/ ./ 300/ ./ twolf/ 和/ 179/ ./ art/ 很/ 好/ 地/ 表现/ 了/ 这种/ 趋势/ ,/ 因为/ 它们/ 的/ 访存/ 模式/ 比较简单/ ,/ 而且/ 程序/ 的/ 数据量/ 小于/ 最末/ 一级/ 缓存/ 大小/ (/ 6MB/ )/ ./ 473/ ./ astar/ 有/ 非常/ 大/ 的/ 数据/ 集/ ,/ 所以/ 图中/ 只能/ 表现/ 出/ 这种/ 趋势/ 的/ 上升/ 阶段/ ./ 有/ 一些/ 程序/ 含有/ 很多/ 内存/ 池/ ,/ 改变/ 缓存/ 大小/ 对/ 这些/ 内存/ 池/ 的/ 影响/ 不同/ ,/ 因此/ 程序/ 的/ 总体/ (/ 这些/ 内存/ 池/ 影响/ 的/ 累加/ )/ 并/ 没有/ 表现/ 出/ 明显/ 的/ 趋势/ ./ 图/ 13/ 展示/ 了/ 这些/ 测试用例/ 使用/ 不同/ 缓存/ 大/ 小时/ 的/ 池/ 分配/ 加速/ 比/ ./ 可以/ 看到/ 除了/ 197/ ./ parser/ 和/ 473/ ./ astar/ -/ 2/ 之外/ ,/ 加速/ 比/ 的/ 趋势/ 和/ 缓存/ 缺失/ 减少/ 的/ 比例/ 趋势/ 大多/ 是/ 一致/ 的/ ./ 197/ ./ parser/ 在/ 使用/ 3MB/ 以上/ 缓存/ 时/ ,/ 缓存/ 缺失/ 没有/ 减少/ 但/ 仍然/ 有/ 超过/ 30/ %/ 的/ 加速/ ./ 这/ 是因为/ 它/ 还/ 得益于/ 更快/ 的/ 分配/ // 回收/ ,/ 而且/ 这部分/ 收益/ 是/ 基本/ 稳定/ 的/ ./ 473/ ./ astar/ -/ 2/ 在/ 使用/ 小/ 缓存/ 时/ ,/ 池/ 分配/ 的/ 效果/ 降低/ ,/ 但/ 程序/ 的/ 加速/ 比/ 上升/ ./ 我们/ 用/ 一个/ 简单/ 的/ 模型/ 来/ 说明/ 这个/ 问题/ ./ 假设/ 程序/ 的/ 运行/ 时间/ 包括/ 由/ 缓存/ 缺失/ 引起/ 的/ Tmiss/ 和/ 其它/ 部分/ Tother/ ./ 池/ 分配/ 使/ 缓存/ 缺失/ 数量/ 变为/ 原来/ 的/ ratio/ 倍/ (/ 0/ </ ratio/ </ 1/ ,/ 数值/ 参考/ 图/ 12/ )/ ,/ 也/ 近似/ 把/ Tmiss/ 变为/ 原来/ 的/ ratio/ 倍/ ;/ Tother/ 在/ 池/ 分配/ 前后/ 没有/ 变化/ ./ 程序/ 的/ 加速/ 比/ 由/ 下列/ 公式/ 给出/ :/ Speedup/ =/ TbaseTopt/ -/ 1/ =/ Tother/ +/ TmissTother/ +/ Tmiss/ ×/ ratio/ -/ 1/ 小/ 缓存/ 环境/ 下会/ 产生/ 更/ 多/ 的/ 缓存/ 缺失/ ,/ 因此/ Tmiss/ 会/ 增大/ ,/ 使得/ 总/ 加速/ 比/ 增大/ ;/ 而/ ratio/ 的/ 增加/ (/ 如/ 473/ ./ astar/ -/ 2/ )/ 会/ 使/ 总/ 加速/ 比/ 减小/ ./ 所以/ 最终/ 加速/ 比/ 的/ 变化/ 需要/ 综合/ 这/ 两/ 方面/ 的/ 因素/ ,/ 也/ 因此/ 导致/ 473/ ./ astar/ 的/ 两个/ 输入/ 集/ 产生/ 不同/ 的/ 加速/ 比/ 变化趋势/ ./ 5.4/ 动态/ 池/ 分配/ 的/ 开销/ 分析/ 动态/ 池/ 分配/ 技术/ 的/ 空间/ 开销/ 包括/ :/ (/ 1/ )/ 由于/ 内存/ 池段/ 的/ 大小/ 通常/ 不是/ 其中/ 对象/ 大小/ 的/ 整数倍/ ,/ 因此/ 每个/ 内存/ 池段/ 的/ 末尾/ 可能/ 会/ 浪费/ 一段/ 空间/ ./ 由于/ 我们/ 最大/ 只/ 对/ 128/ 字节/ 的/ 对象/ 进行/ 池/ 分配/ ,/ 在/ 最坏/ 情况/ 下/ ,/ 128/ 字节/ 的/ 空间/ 浪费/ 占/ 4KB/ 内存/ 池段/ 的/ 3/ %/ ./ 在/ 我们/ 的/ 测试程序/ 中/ ,/ 这个/ 比例/ 通常/ 较/ 小/ ./ (/ 2/ )/ 各种/ 元/ 信息/ ,/ 包括/ 从/ 变长/ 调用/ 链到/ 对象/ 组/ 的/ Hash/ 表/ (/ 最大/ 约/ 8KB/ )/ 、/ 二进制/ 代码/ 的/ 中间/ 表示/ (/ 几倍/ 于/ 二进制/ 代码/ 的/ 大小/ )/ 、/ 存储/ 形状/ 图/ (/ 约/ 10KB/ )/ 等/ ./ 动态/ 池/ 分配/ 系统/ 的/ 运行/ 时/ 开销/ 来自/ :/ (/ 1/ )/ 对/ 每个/ 堆/ 节点/ 进行/ 的/ 各种/ 分析/ ,/ (/ 2/ )/ 每次/ 内存/ 分配/ 需要/ 的/ 查/ Hash/ 表/ 或/ 执行/ 插桩/ 代码/ ./ 为了/ 测量/ 这些/ 开销/ ,/ 我们/ 修改/ 了/ 原型/ 系统/ 使/ 其/ 仍然/ 进行/ 正常/ 的/ 分析/ 、/ 查表/ 、/ 插桩/ 等/ 工作/ ./ 在/ 将要/ 从/ 内存/ 池段/ 中/ 分配/ 对象/ 空间/ 时/ ,/ 将/ 分配/ 请求/ 转发给/ 系统/ 的/ 内存/ 分配/ 函数/ ,/ 使/ 数据/ 布局/ 和/ 不/ 使用/ 动态/ 池/ 分配/ 的/ 布局/ 相似/ ./ 图/ 14/ 展示/ 了/ 这些/ 开销/ 在/ 总/ 运行/ 时间/ 中/ 的/ 比例/ ./ 从图/ 中/ 可以/ 看出/ 我们/ 的/ 动态/ 池/ 分配/ 技术/ 在/ 大多数/ 测试用例/ 上/ 的/ 开销/ 很小/ ,/ 平均/ 为/ 0.7/ %/ ./ Page106/ 结论/ 很多/ 程序/ 里/ ,/ 堆中/ 的/ 数据/ 占/ 总/ 数据/ 集/ 的/ 很/ 大部分/ ,/ 提高/ 这些/ 数据/ 的/ 局部性/ 非常/ 关键/ ./ 池/ 分配/ 技术/ 能够/ 把/ 具有/ 亲缘/ 性/ 的/ 对象/ 从/ 内存/ 池里/ 分配/ ,/ 增加/ 它们/ 所在/ 缓存/ 行/ 的/ 重用/ ./ 本文/ 提出/ 了/ 一种/ 动态/ 池/ 分配/ 技术/ ,/ 直接/ 对/ 应用程序/ 进行/ 透明/ 的/ 优化/ 以/ 提高/ 性能/ ,/ 扩展/ 了/ 优化/ 的/ 应用/ 范围/ ./ 本文/ 提出/ 了/ 在/ 运行/ 时低/ 开销/ 构造/ 存储/ 形状/ 图/ ,/ 并/ 在/ 存储/ 形状/ 图上/ 进行/ 亲缘/ 性/ 识别/ 的/ 池/ 分配/ 方法/ ./ 这种/ 方法/ 解决/ 了/ 已有/ 动态/ 池/ 分配/ 方案/ 的/ 两个/ 重要/ 问题/ :/ 广泛/ 使用/ 的/ 包装/ 函数/ 可能/ 把/ 不/ 相关/ 的/ 对象/ 聚集/ 到/ 一个/ 内存/ 池里/ ;/ 不同/ 的/ 调用/ 点/ 可能/ 把/ 相关/ 的/ 对象/ 分散/ 到/ 不同/ 的/ 内存/ 池里/ ./ 我们/ 实现/ 了/ 一个/ 动态/ 池/ 分配/ 的/ 原型/ 系统/ ,/ 在/ 两台/ 实际/ 机器/ 上/ 获得/ 了/ 13.1/ %/ 和/ 11.8/ %/ 的/ 平均/ 加速/ 比/ ,/ 比/ 现有/ 方法/ 好/ 3.7/ %/ 和/ 5.6/ %/ ,/ 对/ 某些/ 测试用例/ 的/ 加速/ 比可达/ 82.2/ %/ ./ 我们/ 还/ 研究/ 了/ 池/ 分配/ 在/ 不同/ 机器/ 上/ 的/ 性能/ 差异/ 的/ 内在/ 原因/ ./ 

