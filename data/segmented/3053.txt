Page1/ 利用/ 虚拟化/ 平台/ 进行/ 内存/ 泄露/ 探测/ 汪/ 小林/ 1/ )/ 王振林/ 2/ )/ 孙逸峰/ 1/ )/ 刘毅/ 1/ )/ 张/ 彬彬/ 1/ )/ 罗英伟/ 1/ )/ 1/ )/ (/ 北京大学/ 信息/ 科学技术/ 学院/ 北京/ 100871/ )/ 2/ )/ (/ 密歇根/ 理工大学/ 计算机科学/ 系/ 霍顿/ 密歇根/ 49931/ 美国/ )/ 摘要/ 文中/ 利用/ 虚拟机/ 管理器/ ,/ 透明/ 地/ 记录/ 应用程序/ 对/ 资源/ 的/ 申请/ 、/ 释放/ 以及/ 使用/ 情况/ ,/ 提供/ 了/ 探测/ 内存/ 泄露/ 的/ 辅助/ 信息/ ./ 此/ 机制/ 首先/ 不/ 需要/ 修改/ 或/ 重新/ 编译/ 源程序/ ;/ 其次/ ,/ 带来/ 的/ 性能/ 损失/ 很小/ ./ 两者/ 结合/ 可以/ 构建/ 在线/ 内存/ 泄露/ 探测/ 和/ 汇报/ 机制/ ./ 不仅如此/ ,/ 基于/ 虚拟机/ 环境/ 的/ 内存/ 泄露/ 探测/ 还/ 具备/ 通用性/ ,/ 且/ 不/ 需要/ 特殊/ 的/ 硬件/ 支持/ ./ 所有/ 这些/ 特性/ ,/ 是/ 已有/ 的/ 解决方案/ 所/ 不能/ 兼有/ 的/ ./ 实验/ 结果表明/ :/ 基于/ 虚拟机/ 环境/ 的/ 内存/ 泄露/ 探测/ 机制/ 具有/ 实用性/ ,/ 性能/ 损失/ 也/ 被/ 控制/ 在/ 10/ %/ 以内/ ,/ 能够/ 运用/ 在/ 实际/ 的/ 生产/ 环境/ 中/ ./ 关键词/ 内存/ 泄露/ 探测/ ;/ 虚拟机/ ;/ 虚拟化/ 平台/ ;/ 虚拟机/ 管理器/ 1/ 引言/ 内存/ 泄露/ 是/ 指/ 被/ 申请/ 的/ 内存/ 资源/ 在/ 程序运行/ 的/ 某/ 一/ 时刻/ 后/ 再也/ 不/ 被/ 使用/ 和/ 释放/ ./ 如果/ 被/ 泄露/ 的/ 是/ 虚拟内存/ ,/ 则/ 此/ 程序/ 本身/ 能够/ 使用/ 的/ 虚拟内存/ 空间/ 因此/ 变/ 少/ ;/ 如果/ 被/ 泄露/ 的/ 是/ 物理/ 内存/ ,/ 则/ 整个/ 系统/ 减少/ 了/ 能够/ 使用/ 的/ 物理地址/ ./ 内存/ 泄露/ 会/ 使/ 应用程序/ 申请/ 动态内存/ 失败/ ,/ 导致/ 服务/ 中止/ ,/ 严重/ 时会/ 导致/ 整个/ 系统/ 因/ 资源/ 耗竭/ 而/ 崩溃/ ./ 对于/ 运行/ 时间/ 很/ 短/ 的/ 程序/ ,/ 内存/ 泄露/ 一般/ 不是/ 问题/ ,/ 但是/ 对于/ 长期/ 运行/ 的/ 程序/ ,/ 例如/ 运行/ 在/ 服务器/ 上/ 的/ 服务/ 和/ 操作系统/ 本身/ ,/ 内存/ 泄露/ 会/ 带来/ 严重/ 的/ 后果/ ,/ 可能/ 会/ 导致系统/ 服务/ 中止/ ./ 一直/ 以来/ ,/ 内存/ 泄露/ 都/ 是/ 造成/ 计算机/ 安全事故/ 的/ 主要/ 原因/ 之一/ ./ 一些/ 编程语言/ ,/ 如/ Java/ ,/ 通过/ 垃圾/ 回收/ 等/ 方式/ ,/ 自身/ 提供/ 了/ 内存/ 回收/ 的/ 机制/ ./ 这种/ 机制/ 不但/ 不能/ 保证/ 消除/ 内存/ 泄露/ ,/ 而且/ 还会/ 带来/ 性能/ 的/ 损失/ ./ 而/ 另外/ 执行/ 效率/ 很/ 高/ 的/ 一些/ 编程语言/ ,/ 如/ C/ 和/ C++/ ,/ 则/ 将/ 内存/ 分配/ 和/ 释放/ 的/ 操作/ 完全/ 交付给/ 程序员/ ./ 在/ 逻辑/ 非常/ 庞大/ 的/ 程序/ 中/ ,/ 内存/ 泄露/ 很难/ 避免/ ./ 因为/ 内存/ 泄露/ 探测/ 的/ 重要性/ ,/ 先前/ 已经/ 有/ 很多/ 这方面/ 的/ 工作/ ./ 这些/ 工作/ 基本/ 分为/ 两类/ :/ 第一类/ 是/ 静态/ 检查程序/ 语义/ ./ 这类/ 方法/ 认为/ ,/ 正确/ 的/ 程序代码/ ,/ 应该/ 符合/ 预定/ 的/ 规则/ ,/ 例如/ ,/ 通过/ malloc/ 函数/ 申请/ 的/ 内存/ ,/ 在/ 接下来/ 运行/ 的/ 所有/ 代码/ 分支/ 都/ 应该/ 有/ 一个/ free/ 函数/ ./ 可/ 将/ 代码/ 的/ 路径/ 抽象/ 为/ 布尔/ 限制/ 路径/ ,/ 对/ 动态内存/ 的/ 指针/ 加以/ 跟踪/ ./ 对于/ 大型/ 的/ 工程/ ,/ 这个/ 方法/ 比较/ 耗时/ ,/ 例如/ 分析/ GNU/ // Linux/ 的/ 内核/ 代码/ 需要/ 一个/ 处理器/ 一整天/ 的/ 时间/ [/ 1/ ]/ ./ 也/ 有/ 将/ 代码/ 抽象/ 为/ 一个/ 变量/ 流通/ 图/ 的/ ,/ 图/ 的/ 边/ 表示/ 代码/ 分支/ [/ 2/ ]/ ./ 这类/ 方法/ 直接/ 对/ 代码/ 进行/ 分析/ ,/ 实现/ 复杂/ ,/ 目前/ 还有/ 一些/ 难点/ 尚未/ 解决/ ,/ 例如/ 循环/ 的/ 处理/ [/ 1/ ]/ ./ 另一类/ 是/ 运行/ 时/ 动态/ 检测法/ ./ 即/ 在/ 程序运行/ 时/ 记录/ 程序/ 动态分配/ 的/ 内存/ 资源/ 和/ 释放/ 信息/ ,/ 然后/ 分析/ 是否/ 存在/ 内存/ 泄露/ ./ 例如/ Purify/ ①/ 和/ SafeMem/ [/ 3/ ]/ ,/ 都/ 属于/ 这/ 一类/ ./ 动态/ 检测法/ 受限于/ 测试程序/ ,/ 因为/ 测试程序/ 所/ 覆盖/ 的/ 代码/ 非常/ 有限/ ,/ 无法/ 激发/ 出/ 所有/ 潜在/ 的/ 问题/ ./ 本文/ 通过/ 虚拟机/ 管理器/ (/ VirtualMachineMo/ -/ nitor/ ,/ VMM/ )/ 平台/ ,/ 在/ 其/ 上/ 虚拟机/ (/ VirtualMachine/ ,/ GuestOS/ ,/ VM/ )/ 运行/ 时/ ,/ 动态/ 截获/ 虚拟机/ 中/ 申请/ 和/ 释放/ 内存/ 的/ 函数/ ,/ 并/ 记录下来/ ,/ 用于/ 辅助/ 甄别/ 内存/ 泄露/ ,/ 是/ 基于/ 第二类/ 的/ 方法/ ./ 通过/ 内存/ 虚拟化/ 技术/ 的/ 协助/ ,/ 我们/ 可以/ 监控/ 应用程序/ 对/ 这些/ 内存/ 资源/ 的/ 应用/ 情况/ ./ 然后/ ,/ 应用/ 一些/ 规则/ ,/ 找出/ 内存/ 泄露/ 的/ 嫌疑/ ./ 例如/ 长时间/ 未/ 被/ 释放/ 且/ 未/ 被/ 访问/ 的/ 内存/ 可能/ 是/ 内存/ 泄露/ ./ 这种/ 方法/ 相对/ 现有/ 的/ 方法/ 有/ 以下/ 优点/ :/ (/ 1/ )/ 既/ 不/ 需要/ 修改/ 被/ 探测/ 程序/ 的/ 源代码/ ,/ 也/ 不/ 需要/ 重新/ 编译/ ,/ 为/ 被/ 测试代码/ 提供/ 了/ 透明性/ ./ 如/ Purify/ 和/ SafeMem/ ,/ 前者/ 通过/ 编译/ 插入/ 指令/ 以/ 获取/ 应用程序/ 访问/ 内存/ 的/ 所有/ 行为/ ,/ 然后/ 这些/ 行为/ 被/ 用于/ 判断/ 内存/ 泄露/ 和/ 内存/ 访问/ 地址/ 越界/ 等/ 问题/ ./ SafeMem/ 则/ 需要/ 重新/ 封装/ 资源/ 申请/ 和/ 释放/ 函数/ ,/ 甚至/ 需要/ 给/ 操作系统/ 添加/ 新/ 的/ 系统/ 调用/ ,/ 这些/ 需求/ 一定/ 程度/ 上/ 不利于/ 它们/ 的/ 应用/ ./ 其次/ ,/ 如果/ 探测/ 内存/ 泄露/ 方法/ 给/ 应用程序/ 带来/ 很多/ 性能/ 损失/ 或者/ 占用/ 很大/ 额外/ 资源/ 的话/ ,/ 其/ 应用/ 只能/ 仅限于/ 程序调试/ 阶段/ ,/ 其/ 可/ 发现/ 的/ 内存/ 泄露/ 受限于/ 测试用例/ ./ Purify/ 虽然/ 能够/ 捕捉到/ 程序/ 中/ 大量/ 的/ 内存/ 访问/ ,/ 但是/ ,/ 因为/ 需要/ 截获/ 应用程序/ 所有/ 的/ 内存/ 操作/ ,/ Purify/ 导致/ 应用程序/ 的/ 性能/ 损失/ 很大/ ,/ 通常/ 应用程序/ 的/ 性能/ 降低/ 达到/ 2/ ~/ 3/ 倍/ ,/ 或者/ 更/ 多/ ①/ ./ 性能/ 的/ 降低/ 限制/ 了/ 其/ 使用/ 范围/ ,/ 而且/ 加重/ 了/ 其/ 对/ 测试程序/ 的/ 依赖/ ./ 本文/ 中/ 的/ 内存/ 泄露/ 探测/ 机制/ 是/ 基于/ 虚拟机/ 来/ 实现/ 的/ ,/ 经/ 测试/ 其/ 性能/ 损失/ 少于/ 10/ %/ ,/ 能够/ 在/ 真实/ 服务/ 中/ 使用/ ./ 这/ 同时/ 带来/ 的/ 另外/ 一个/ 优点/ 在于/ ,/ 在/ 真实/ 使用/ 中/ ,/ 代码/ 的/ 执行/ 覆盖范围/ 更广/ ,/ 能够/ 发现/ 潜在/ 的/ 内存/ 泄露/ ./ (/ 2/ )/ 本文/ 方法/ 不但/ 适用/ 于/ 用户/ 态/ 的/ 应用程序/ ,/ 而且/ 还/ 适用/ 于/ 操作系统/ 内核/ ./ 存在/ 于/ 内核/ 中/ 的/ 内存/ 泄露/ ,/ 比/ 应用程序/ 中/ 的/ 内存/ 泄露/ 带来/ 的/ 危害/ 更大/ ,/ 而且/ 调试/ 更/ 困难/ ./ 尽管/ 有/ 很多/ 工具/ 用于/ 测试/ 用户/ 态/ 程序/ 的/ 内存/ 泄露/ ,/ 但是/ 调试/ 内核/ 代码/ 的/ 工具/ 仍旧/ 比较/ 缺乏/ ./ PinOS/ [/ 4/ ]/ 在/ 虚拟机/ 管理器/ 之上/ ,/ 通过/ 软件/ 动态/ 翻译/ 的/ 方法/ ,/ 提供/ 了/ 调试/ 操作系统/ 内核/ 代码/ 的/ 机制/ ./ 然而/ ,/ 软件/ 动态/ 翻译/ 使得/ 其/ 性能/ 下降/ 很大/ ,/ 大多数/ 情况/ 下/ 降低/ 到/ 50/ ~/ 60/ 倍/ ,/ 这/ 限制/ 了/ 其/ 使用/ 环境/ ,/ 难以/ 在/ 真实/ 环境/ 中/ 使用/ ./ 而且/ ,/ 其/ 运行/ 时/ 需要/ 插入/ 部分/ 代码/ 到/ 虚拟机/ 的/ 内核/ 地址/ 空间/ ,/ 因此/ 占用/ 操作系统/ 的/ 一部分/ 地址/ 空间/ ,/ 这/ 破坏/ 了/ 透明性/ ./ 本文/ 基于/ 虚拟机/ 管理器/ 的/ 实现/ 也/ 提供/ 了/ 平台/ 通用性/ ,/ 其/ 既/ 适用/ 于/ GNU/ // Linux/ 操作系统/ ,/ 也/ 适用/ 于/ Windows/ 操作系统/ ./ 对/ 操作系统/ 的/ 版本/ 也/ 不/ 做/ 要求/ ,/ 只要/ 其/ 代码/ 体系/ 符合/ IntelX86/ 的/ 指令/ 规范/ ./ 而/ SafeMem/ 虽然/ 性能/ 降低/ 很小/ ,/ 但是/ 需要/ 给/ 操作系统/ 添加/ 新/ 的/ 系统/ 调用/ 接口/ 和/ 系统/ 调用/ 处理函数/ ,/ 因此/ 欠/ ①/ RationalPurify/ ./ Purify/ :/ FastDetectionofMemoryLeaksPage3/ 缺/ 了/ 平台/ 的/ 通用性/ ./ 最后/ ,/ 本/ 论文/ 的/ 机制/ 不/ 需要/ 特殊/ 硬件/ 的/ 支持/ ,/ 而/ SafeMem/ 是/ 基于/ ECC/ 控制器/ 实现/ 的/ ./ 接下来/ ,/ 我们/ 首先/ 总体/ 介绍/ 利用/ 虚拟化/ 平台/ 进行/ 内存/ 探测/ 的/ 机制/ ;/ 其次/ 详细/ 介绍/ 对/ 运行/ 在/ 虚拟机/ 中/ 的/ 应用程序/ 申请/ 和/ 释放/ 内存/ 资源/ 的/ 捕获/ 和/ 记录/ ,/ 然后/ 分析/ 应用程序/ 所/ 申请/ 的/ 内存/ 资源/ ,/ 选择/ 出/ 存在/ 内存/ 泄露/ 的/ 嫌疑/ 部分/ 进行/ 监控/ ./ 在/ 实验/ 章节/ 中/ ,/ 本文/ 描述/ 了/ 基于/ 虚拟/ 平台/ 进行/ 内存/ 泄露/ 探测/ 的/ 有效性/ 和/ 性能/ 代价/ ./ 最后/ 是/ 结论/ 和/ 下/ 一步/ 工作/ ./ 2/ 实现/ 原理/ 内存/ 泄露/ 是/ 指/ 已经/ 被/ 申请/ 的/ 内存/ 资源/ 没有/ 被/ 合理/ 地/ 释放/ ,/ 而/ 导致/ 这部分/ 资源/ 不能/ 被/ 系统/ 重新/ 利用/ 的/ 一种/ 现象/ ./ 内存/ 泄露/ 广泛/ 存在/ 或者/ 隐藏/ 于/ 程序/ 之中/ ,/ 被/ 泄漏/ 的/ 内存/ 资源/ 不能/ 被/ 重新/ 利用/ 且/ 不再/ 被/ 访问/ ./ 对于/ 应用程序/ ,/ 内存/ 泄露/ 会/ 使得/ 应用程序/ 的/ 虚拟内存/ 空间/ 耗竭/ ,/ 导致/ 任务/ 的/ 中断/ 和/ 失败/ ./ 对于/ 操作系统/ ,/ 内存/ 泄露/ 不仅/ 会/ 减少/ 可用/ 的/ 内核/ 虚拟内存/ 地址/ 空间/ ,/ 而且/ 还会/ 不断/ 蚕食/ 整个/ 系统/ 可用/ 的/ 物理/ 内存/ 页面/ ,/ 导致/ 整机/ 不得不/ 重新启动/ ./ 内存/ 申请/ 和/ 释放/ 的/ 接口/ 具有/ 统一/ 、/ 简单/ 的/ 特色/ ,/ 例如/ Windows/ 提供/ 的/ 动态内存/ 管理/ 接口/ GlobalAlloc/ 和/ GlobalFree/ 、/ Posix/ 规定/ 的/ malloc/ 和/ free/ 接口/ 、/ Linux/ 内核/ 的/ vmalloc/ 和/ vfree/ 以及/ get/ _/ page/ 和/ put/ _/ page/ 等/ 接口/ ./ 某些/ 应用程序/ 实现/ 了/ 自身/ 的/ 内存/ 管理/ ,/ 但是/ 其/ 接口/ 也/ 是/ 比较/ 统一/ 的/ ./ 这些/ 接口/ 不但/ 统一/ 简单/ ,/ 其/ 数量/ 也/ 非常/ 有限/ ./ 正常/ 情况/ 下/ ,/ 通过/ 某个/ 申请/ 函数/ 获得/ 资源/ 需要/ 通过/ 对应/ 的/ 释放/ 函数/ 来/ 释放/ ./ 本文/ 利用/ 这/ 一点/ ,/ 在/ 虚拟化/ 平台/ 中/ 透明/ 地/ 截取/ 了/ 资源/ 申请/ 和/ 释放/ 的/ 接口/ ,/ 维护/ 一个/ 动态/ 资源/ 使用/ 列表/ ,/ 详尽/ 和/ 全面/ 地/ 掌握/ 被/ 监控/ 对象/ 使用/ 内存/ 资源/ 的/ 情况/ ./ 如果/ 有/ 内存/ 泄露/ 存在/ 的话/ ,/ 这个/ 列表/ 理论/ 上/ 包含/ 了/ 所有/ 被/ 泄漏/ 的/ 内存/ ,/ 但/ 又/ 不仅/ 限于/ 被/ 泄漏/ 的/ 内存/ ,/ 因为/ 被/ 虚拟机/ 正确/ 使用/ 的/ 动态内存/ 资源/ 也/ 包含/ 在/ 这个/ 列表/ 中/ ./ 接下来/ 的/ 工作/ 是从/ 这个/ 列表/ 中/ 选择/ 出/ 最/ 有/ 可能/ 是/ 内存/ 泄露/ 的/ 项/ ./ 选择/ 的/ 主导/ 思想/ 是/ :/ (/ 1/ )/ 某个/ 地址/ 持续/ 地/ 分配/ 长时间/ 不/ 被/ 释放/ 的/ 内存/ ;/ (/ 2/ )/ 选择/ 被/ 占用/ 但/ 长时间/ 未/ 被/ 访问/ 的/ 内存/ ./ 前者/ 可以/ 从/ 记录/ 获取/ ,/ 实现/ 后者/ 需要/ 分/ 两步/ :/ 首先/ 确定/ 被/ 监控/ 的/ 对象/ ,/ 然后/ 通过/ 内存/ 虚拟化/ 技术/ 进行/ 监控/ ./ 设计/ 原理/ 和/ 方案/ ./ 在/ 接下来/ 的/ 几个/ 小节/ 中/ ,/ 详细/ 介绍/ 每个/ 步骤/ 的/ 2.1/ 截获/ 资源/ 申请/ 和/ 释放/ Purify/ 和/ SafeMem/ 等/ 实现/ 方案/ 通过/ 修改/ 源代码/ 或者/ 修改/ 编译器/ 的/ 方式/ ,/ 来/ 截取/ 资源/ 申请/ 和/ 释放/ ;/ 而/ 通过/ 虚拟化/ 平台/ 可以/ 更/ 简单/ 更/ 透明/ 地/ 实现/ 这个/ 功能/ ./ 我们/ 以/ malloc/ 和/ free/ 为/ 例来/ 说明/ ,/ 下面/ 列出/ 了/ 一小/ 段/ 常见/ 的/ 代码/ ./ void/ / PTR/ =/ malloc/ (/ LEN/ )/ ;/ if/ (/ PTR/ =/ =/ NULL/ )/ err/ (/ "/ Outofmemory/ ./ "/ )/ ;/ // / utilizingthememorystartingatPTRofsizeLEN/ / // if/ (/ PTR/ )/ free/ (/ PTR/ )/ ;/ 这/ 段/ C语言/ 代码/ 首先/ 通过/ malloc/ 函数/ 申请/ 长度/ 为/ LEN/ 个/ 字节/ 的/ 动态内存/ ,/ 然后/ 判断/ 是否/ 申请/ 成功/ ./ 如果/ 成功/ ,/ 则/ 使用/ 这些/ 内存/ 资源/ 进行/ 计算/ ./ 最后/ ,/ 当/ 不再/ 需要/ PTR/ 所指/ 的/ 资源/ 时/ ,/ 通过/ free/ 函数/ 释放/ 这些/ 内存/ ./ 在/ 这个/ 场景/ 中/ ,/ 我们/ 不仅/ 需要/ 截获/ malloc/ 函数/ 的/ 调用/ ,/ 获取/ 其/ 参数/ 和/ 返回/ 结果/ ,/ 而且/ 也/ 需要/ 截获/ free/ 函数/ 的/ 调用/ ,/ 获取/ 其/ 参数/ ,/ 也/ 即/ 被/ 释放/ 的/ 动态/ 资源/ ./ 换句话说/ ,/ 应用程序/ 当前/ 正在/ 使用/ 的/ 动态内存/ 信息/ (/ 包括/ 其/ 起始/ 地址/ 、/ 长度/ 、/ 时间/ )/ 和/ 调用/ IP/ (/ InstructionPointer/ )/ 地址/ 都/ 需要/ 在/ 虚拟机/ 管理器/ 中/ 维护/ ./ 在/ 虚拟化/ 平台/ 中/ ,/ 可以/ 通过/ 替换/ 指令/ 的/ 方式/ ,/ 透明/ 地/ 截获/ 申请/ 函数/ 和/ 释放/ 函数/ ./ 为了/ 实现/ 透明/ 的/ 结果/ ,/ 首先/ 分析/ 一下/ 上面/ C语言/ 程序/ 在/ Linux/ 操作系统/ 之上/ 对应/ 的/ 汇编/ 代码/ :/ 8048426/ :/ 8904248048429/ :/ e8defeffffcall804830c/ 〈/ malloc/ @/ plt/ 〉/ 804842e/ :/ 8945fc8048431/ :/ 837dfc00cmpl/ $/ 0x0/ ,/ 0xfffffffc/ (/ %/ ebp/ )/ 8048435/ :/ 75188048437/ :/ c7042454850408movl/ $/ 0x8048554/ ,/ (/ %/ esp/ )/ 804843e/ :/ e8e9feffffcall804832c/ 〈/ printf/ @/ plt/ 〉/ 8048443/ :/ c7042401000000movl/ $/ 0x1/ ,/ (/ %/ esp/ )/ 804844a/ :/ e8edfeffffcall804833c/ 〈/ exit/ @/ plt/ 〉/ 804844f/ :/ 837dfc00cmpl/ $/ 0x0/ ,/ 0xfffffffc/ (/ %/ ebp/ )/ 8048453/ :/ 740b8048455/ :/ 8b45fc8048458/ :/ 890424804845b/ :/ e8ecfeffffcall804834c/ 〈/ free/ @/ plt/ 〉/ 可以/ 看到/ ,/ 在/ 地址/ 为/ 0x8048426/ 的/ 地方/ ,/ 变量/ LEN/ 中/ 保存/ 的/ 数值/ 被/ 压到/ 栈/ 上/ ,/ 接下来/ 的/ 一条/ 指令/ 调用/ 了/ malloc/ 函数/ ,/ 程序/ 的/ 运行/ 跳转/ 到/ malloc/ 函数/ 所在/ 的/ 地址/ 0x804830c/ ./ 在/ malloc/ 函数/ 返回/ 后/ ,/ 程序/ 在/ 地址/ 0x804842e/ 处/ 继续执行/ ./ 如果/ malloc/ 函数/ 申请/ 资源/ 成功/ ,/ 程序/ 最终/ 会/ 在/ 地址/ 0x804845b/ 处/ 调用/ free/ 函数/ ,/ 释放/ 这/ 段/ 内存空间/ ./ 内存/ 资源/ 申请/ 函数/ 和/ 释放/ 函数/ ,/ 例如/ malloc/ 和/ free/ ,/ 作为/ 系统/ 的/ 调用/ 接口/ ,/ 其/ 在/ 内存/ 中/ 的/ 地址/ 很容/ Page4/ 易/ 捕获/ 得到/ ,/ 在/ 上面/ 的/ 示例/ 程序/ 中/ ,/ malloc/ 和/ free/ 的/ 地址/ 分别/ 为/ 0x804830c/ 和/ 0x804834c/ ./ 获得/ 内存/ 申请/ 函数/ 和/ 释放/ 函数/ 的/ 地址/ 之后/ ,/ 截获/ 其/ 执行/ 需要/ 如下/ 几个/ 步骤/ :/ 1/ ./ 在/ 函数/ 地址/ 处/ (/ 例如/ 0x804830c/ 处/ )/ 插入/ 能够/ 使得/ 虚拟机/ 无条件/ 陷入/ 到/ 虚拟机/ 管理器/ 的/ 指令/ ./ 例如/ 非法/ 指令/ ,/ 在/ Intel/ 的/ VT/ 平台/ 中/ 可以/ 插入/ VMCALL/ 指令/ ./ 我们/ 把/ 这种/ 指令/ 称为/ 陷入/ 指令/ ,/ 原/ 位置/ 被/ 替换/ 的/ 指令/ 称为/ 被/ 替换/ 指令/ ,/ 把/ 被/ 植入/ 陷入/ 指令/ 的/ 函数/ 称为/ 受/ 监控/ 函数/ ./ 2/ ./ 运行/ 在/ 虚拟机/ 中/ 的/ 应用程序/ 调用/ 受/ 监控/ 函数/ (/ 如/ malloc/ )/ 之后/ ,/ 虚拟机/ 马上/ 陷入/ 虚拟机/ 管理器/ ./ 3/ ./ 在/ 虚拟机/ 管理器/ 中/ ,/ 分析/ 受/ 监控/ 函数/ 的/ 类别/ ,/ 分析/ 其/ 参数/ ,/ 获取/ 函数调用/ 栈/ ,/ 更新/ 应用程序/ 占用/ 内存/ 资源/ 的/ 信息/ ./ 如果/ 是/ 资源/ 申请/ 函数/ 则/ 增加/ 内存/ 占用/ 信息/ ,/ 而/ 资源/ 释放/ 函数/ 则/ 需要/ 删除/ 相应/ 的/ 内存/ 信息/ ./ 例如/ ,/ 如果/ 陷入/ 的/ 函数/ 是/ mal/ -/ loc/ ,/ 其/ 只有/ 一个/ 参数/ 表明/ 申请/ 内存/ 的/ 长度/ ,/ 我们/ 可以/ 在/ 当前/ 应用程序/ 的/ 堆栈/ 上/ 获得/ ./ 如果/ 陷入/ 的/ 是/ free/ 函数/ ,/ 其/ 参数/ 表明/ 需要/ 释放/ 的/ 内存/ ./ 这里/ 获取/ 函数调用/ 栈/ 的/ 目的/ 是/ 为了/ 程序员/ 调试/ 的/ 方便/ ./ 4/ ./ 在/ 虚拟机/ 管理器/ 中/ 模拟/ 执行/ 被/ 替换/ 指令/ ./ 之所以/ 不/ 恢复/ 被/ 替换/ 指令/ ,/ 原因/ 是/ 为了/ 保证/ 能/ 监控/ 到/ 应用程序/ 并发/ 调用/ 该受/ 监控/ 函数/ ,/ 例如/ 多线程/ 程序/ 中/ 多个/ 线程/ 有/ 可能/ 同时/ 通过/ 调用/ malloc/ 函数/ 申请/ 内存/ 资源/ ./ 5/ ./ 如果/ 该受/ 监控/ 函数/ 在/ 申请/ 资源/ ,/ 在/ 陷入/ 指令/ 的/ 下/ 一条/ 指令/ 处/ (/ 在/ 上述/ 例子/ 中/ ,/ 地址/ 0x804842e/ 处/ )/ ,/ 需要/ 插入/ 陷入/ 指令/ ,/ 以便/ 让/ 我们/ 获悉/ 函数调用/ 结束/ ,/ 分析/ 申请/ 结果/ ./ 6/ ./ 虚拟机/ 管理器/ 命令/ 虚拟机/ 继续执行/ ,/ 虚拟/ 机会/ 执行/ 受/ 监控/ 函数/ 的/ 其它/ 代码/ ,/ 执行/ 结束/ 后/ ,/ 返回/ 到/ 调用/ 处/ ,/ 上例/ 中/ 监控/ malloc/ 的/ 第一次/ 调用/ ,/ 则/ 是/ 地址/ 0x804842e/ 处/ ./ 7/ ./ 返回/ 处/ 陷入/ ,/ 因为/ 步/ 5/ 已经/ 将/ 一个/ 陷入/ 指令/ 插入/ 到/ 返回/ 处/ ;/ 在/ 虚拟机/ 管理器/ 中/ ,/ 分析/ 受/ 监控/ 函数/ 返回/ 的/ 结果/ ./ 对于/ malloc/ 函数/ ,/ 其/ 返回/ 结果/ 是/ 所/ 申请/ 到/ 内存/ 资源/ 的/ 地址/ ,/ 如果/ 申请/ 失败/ ,/ 则/ 返回值/ 是/ NULL/ ./ 通过/ 以上/ 方法/ 获取/ 应用程序/ 的/ 动态内存/ 资源/ 使用/ 情况/ 之后/ ,/ 我们/ 即时/ 地/ 维护/ 应用程序/ 申请/ 动态内存/ 的/ 列表/ ./ 如果/ 应用程序/ 中/ 存在/ 内存/ 泄露/ 的话/ ,/ 被/ 泄露/ 的/ 内存/ 必然/ 在/ 我们/ 所/ 维护/ 的/ 表中/ ./ 从/ 动态内存/ 列表/ 中/ 精确/ 找出/ 被/ 泄露/ 的/ 内存/ 项是/ 一个/ 难点/ ;/ 然而/ ,/ 我们/ 可以/ 先/ 找到/ 疑似/ 泄露/ 的/ 动态内存/ 项/ ,/ 然后/ 将/ 信息/ (/ 函数调用/ 栈/ 、/ 调用/ 地址/ 和/ 申请/ 资源/ 大小/ 等/ )/ 交由/ 程序员/ 处理/ ./ 本/ 论文/ 的/ 目标/ 是/ ,/ 找到/ 内存/ 泄露/ 的/ 嫌疑/ 项/ ,/ 并/ 提高/ 准确率/ ./ 除此之外/ ,/ 通过/ 本文/ 的/ 方法/ ,/ 还/ 可/ 捕捉到/ 程序/ 中/ 多次/ 释放/ 资源/ 的/ 错误操作/ ,/ 例如/ 将/ 一段/ 动态内存/ 调用/ free/ 释放/ 后/ ,/ 又/ 再次/ 调用/ free/ 释放/ ,/ 根据/ free/ 接口/ 的/ 规范/ ,/ 其/ 结果/ 是/ 不可/ 预料/ 的/ ,/ 也/ 会/ 对/ 程序/ 的/ 正常/ 运行/ 带来/ 隐患/ ./ 本/ 小节/ 阐述/ 了/ 截获/ 内存/ 申请/ 和/ 释放/ 的/ 机制/ ,/ 接下来/ 的/ 两个/ 小节/ 中/ ,/ 将/ 着重/ 介绍/ 推选/ 内存/ 泄露/ 嫌疑/ 项/ 的/ 规则/ 和/ 步骤/ 以及/ 提高/ 推选/ 准确率/ 的/ 一些/ 策略/ 和/ 方法/ ./ 2.2/ 判断/ 内存/ 泄露/ 的/ 规则/ 2.1/ 节中/ 介绍/ 了/ 截获/ 应用程序/ 申请/ 和/ 释放/ 动态内存/ 的/ 机制/ ./ 这个/ 机制/ 能够/ 使得/ 虚拟机/ 管理器/ 维护/ 应用程序/ 当前/ 使用/ 的/ 全部/ 动态内存/ 信息/ ,/ 这些/ 信息/ 包括/ 受/ 监控/ 函数/ 的/ 调用/ IP地址/ 、/ 动态内存/ 申请/ 函数/ 的/ 种类/ 、/ 所/ 申请/ 动态内存/ 的/ 地址/ 和/ 大小/ 以及/ 申请/ 时间/ 等/ ./ 如果/ 应用程序/ 存在/ 内存/ 泄露/ 的话/ ,/ 那么/ 被/ 泄露/ 的/ 内存/ 就/ 隐藏/ 在/ 我们/ 维护/ 的/ 列表/ 中/ ./ 我们/ 判断/ 是否/ 存在/ 内存/ 泄露/ 的/ 嫌疑/ 基于/ 如下/ 几条/ 规则/ :/ (/ 1/ )/ 在/ 应用/ 程序运行/ 的/ 过程/ 中/ ,/ 有/ 长时间/ 未/ 被/ 应用程序/ 访问/ 的/ 动态内存/ ;/ 这里/ 的/ 运行/ 是/ 指/ 应用程序/ 实际/ 占用/ 处理器/ 的/ 状态/ ,/ 不/ 包括/ 程序/ 阻塞/ 等待/ 的/ 状态/ ;/ (/ 2/ )/ 应用程序/ 的/ 某/ 一/ 地址/ 持续/ 申请/ 动态内存/ 且/ 部分/ 不/ 释放/ ,/ 导致/ 应用程序/ 占用/ 的/ 动态内存/ 随着/ 运行/ 时间/ 的/ 延续/ 越来越/ 多/ ;/ (/ 3/ )/ 在/ 应用程序/ 退出/ 时/ ,/ 有/ 未/ 被/ 释放/ 的/ 内存/ 段/ ./ 规则/ 1/ 基于/ 被/ 泄漏/ 内存/ 的/ 最/ 基本/ 的/ 特征/ :/ 应用程序/ 在/ 语义/ 层面/ 上/ ,/ 丢弃/ 了/ 内存/ 段/ 并/ 不再/ 访问/ 该/ 内存/ 段/ ./ 规则/ 1/ 需要/ 虚拟机/ 管理器/ 对/ 应用程序/ 的/ 内存/ 的/ 访问/ 情况/ 进行/ 监控/ ./ 这种/ 监控/ 行为/ 是/ 需要/ 虚拟机/ 管理器/ 付出/ 性能/ 代价/ 的/ ,/ 因为/ 在/ 监控/ 中/ ,/ 会/ 导致/ 虚拟机/ 管理器/ 对/ 虚拟机/ 正常/ 运行/ 添加/ 额外/ 的/ 干预/ 和/ 陷入/ ,/ 我们/ 在/ 下/ 一/ 小节/ 中/ 会/ 详细描述/ 监控/ 的/ 步骤/ ./ 监控/ 应用程序/ 所/ 申请/ 的/ 所有/ 内存/ 资源/ 的/ 访问/ 是/ 不/ 太/ 实际/ 的/ ,/ 因为/ 这有/ 可能/ 引起/ 大量/ 的/ 虚拟机/ 陷入/ ,/ 严重/ 影响/ 虚拟机/ 管理器/ 的/ 整体/ 性能/ ./ 为了/ 克服/ 这/ 一点/ ,/ 从而/ 减少/ 虚拟机/ 管理器/ 性能/ 的/ 损失/ ,/ 应当/ 降低/ 被/ 监控/ 内存/ 片断/ 的/ 数目/ ./ 在/ 本文/ 的/ 设计/ 中/ ,/ 监控/ 机制/ 和/ 监控/ 策略/ 是/ 分开/ 的/ ./ 我们/ 在/ 虚拟机/ 管理器/ 中/ 添加/ 了/ 监控/ 机制/ ,/ 而/ 决定/ 谁/ 被/ 监控/ 、/ 谁/ 不/ 被/ 监控/ 、/ 被/ 监控/ 内存/ 片断/ 的/ 数目/ 等/ 策略性/ 决定/ 则/ 在/ 高层/ 动态/ 设定/ ./ 监控/ 策略/ 会/ 根据/ 动态内存/ 的/ 监控/ 历史/ 、/ 分配/ 时间/ 和/ 虚拟机/ 的/ 性能/ 反馈/ 等/ 因素/ 进行/ 判断/ ./ 规则/ 2/ 是/ 基于/ 统计/ 的/ ,/ 不/ 需要/ 监控/ 动态内存/ 的/ 被/ 访问/ 情况/ ,/ 因此/ 开销/ 比/ 规则/ 1/ 少/ ,/ 但是/ 准确性/ 比/ 规则/ 1/ 差/ ./ 此/ 规则/ 基于/ 这样/ 的/ 观察/ ,/ 内存/ 泄露/ 的/ 点/ 具有/ 重复性/ ,/ 在/ 某/ 一/ IP/ 点上/ 如果/ 发生/ 过/ 内存/ 泄露/ ,/ 那么/ 在/ 此点/ 上/ 还/ 会/ 发生/ 内存/ 泄露/ ./ 规则/ 3/ 基于/ 对/ 良好/ 编程/ 原则/ 的/ 考虑/ :/ 程序/ 应该/ 在/ 退出/ 时/ ,/ 已经/ 优雅/ 地/ 释放/ 掉/ 所有/ 申请/ 的/ 资源/ ,/ 而/ 不/ Page5/ 是/ 将/ 这些/ 清理/ 工作/ 托付给/ 操作系统/ ./ 总之/ ,/ 我们/ 根据/ 应用程序/ 对/ 其/ 所/ 申请/ 的/ 资源/ 使用/ 情况/ 的/ 统计/ ,/ 来/ 推测/ 是否/ 有/ 内存/ 泄露/ 发生/ ./ 规则/ 1/ 基于/ 如下/ 考虑/ :/ 因为/ 被/ 泄露/ 的/ 内存/ 的/ 特征/ 之一/ 是/ 不再/ 被/ 应用程序/ 访问/ ,/ 所以/ 最好/ 的/ 嫌疑者/ 是/ 那些/ 在/ 应用程序/ 的/ 运行/ 中/ ,/ 长时间/ 没有/ 被/ 访问/ 的/ 动态内存/ ./ 规则/ 2/ 基于/ 如下/ 考虑/ :/ 程序/ 的/ 执行/ 线/ 随着/ 上下文/ 的/ 不同/ 而/ 不同/ ,/ 在/ 某个/ 执行/ 线上/ 程序员/ 可能/ 会/ 忘记/ 释放/ 资源/ ./ 如果/ 程序/ 不断/ 经过/ 这个/ 忘记/ 释放/ 资源/ 的/ 执行/ 线/ ,/ 则/ 会/ 不断/ 产生/ 内存/ 泄露/ ./ 规则/ 3/ 基于/ 编程/ 习惯/ ./ 2.3/ 监控/ 内存/ 本/ 小节/ 主要/ 描述/ 在/ 虚拟机/ 管理器/ 中/ ,/ 实现/ 对/ 应用程序/ 所/ 申请/ 的/ 动态内存/ 的/ 访问/ 进行/ 监控/ 的/ 机制/ ./ 根据/ 判断/ 内存/ 泄露/ 的/ 规则/ 1/ ,/ 在/ 程序运行/ 期间/ 长时间/ 未/ 被/ 有效/ 利用/ 的/ 动态内存/ 资源/ ,/ 可能/ 是/ 被/ 泄漏/ 的/ 内存/ ./ 为了/ 了解/ 动态内存/ 资源/ 被/ 利用/ 的/ 情况/ ,/ 需要/ 对/ 该/ 动态内存/ 资源/ 进行/ 访问/ 监控/ ./ 监控/ 的/ 基本/ 思想/ 是/ ,/ 在/ 应用程序/ 访问/ 被/ 监控/ 的/ 动态内存/ 时/ ,/ 虚拟机/ 管理器/ 能够/ 获悉/ 这一/ 访问/ 行为/ ./ Safemem/ 利用/ 硬件/ ECC/ 实现/ 了/ 监控/ ,/ 而/ 虚拟机/ 管理器/ 不/ 需要/ 额外/ 的/ 硬件/ 支持/ ,/ 通过/ 内存/ 虚拟化/ 即可/ 实现/ 监控/ ./ 本/ 小节/ 内容/ 首先/ 着重/ 描述/ 基于/ 影子/ 页表/ 的/ 内存/ 虚拟化/ 方法/ ,/ 其次/ 描述/ 在/ 内存/ 虚拟化/ 方法/ 中/ 实现/ 内存/ 监控/ 的/ 原理/ 和/ 方法/ ,/ 最后/ 分析/ 在/ 虚拟机/ 管理器/ 中/ 内存/ 监控/ 的/ 有效性/ ./ 2.3/ ./ 1/ 内存/ 虚拟化/ 方法/ 虚拟机/ 与/ 传统/ 计算机/ 相比/ ,/ 其/ 内存/ 系统/ 多/ 了/ 一种/ 地址/ ,/ 共/ 包括/ 以下/ 3/ 种/ 地址/ :/ 机器/ 地址/ (/ HostPhysicalAddress/ ,/ HPA/ )/ ,/ 指/ 真实/ 硬件/ 的/ 机器/ 地址/ ,/ 即/ 地址总线/ 上/ 应该/ 出现/ 的/ 地址/ 信号/ ;/ 物理地址/ (/ GuestPhysicalAddress/ ,/ GPA/ )/ ,/ 指/ 经过/ VMM/ 抽象/ 的/ 、/ 虚拟机/ 所/ 看到/ 的/ 伪/ 物理地址/ ;/ 虚拟地址/ (/ GuestVirtualAddress/ ,/ GVA/ )/ ,/ 指/ GuestOS/ 提供/ 给/ 其/ 应用程序/ 使用/ 的/ 线性/ 地址/ 空间/ ./ 显然/ ,/ VMM/ 的/ 内存模块/ 负责/ 完成/ 物理地址/ 到/ 机器/ 地址/ 的/ 映射/ ,/ 我们/ 将/ 这个/ 映射/ 记为/ f/ ;/ 同时/ ,/ GuestOS/ 的/ 内存/ 管理/ 模块/ 要/ 完成/ 虚拟地址/ 到/ 物理地址/ 的/ 映射/ ,/ 我们/ 将/ 这个/ 映射/ 记为/ g/ ./ 于是/ ,/ 虚拟地址/ 、/ 物理地址/ 和/ 真实/ 地址/ 之间/ 的/ 关系/ 如图/ 1/ 所示/ ./ 图/ 1/ 机器/ 地址/ 、/ 物理地址/ 和/ 虚拟地址/ 的/ 关系/ 在/ 没有/ 硬件/ 内存/ 虚拟化/ 支持/ 的/ 情况/ 下/ ,/ KVM/ 实现/ 内存/ 虚拟化/ 的/ 方法/ 是/ 影子/ 页表/ 技术/ [/ 5/ -/ 6/ ]/ ./ 影子/ 页表/ 技术/ 为/ GuestOS/ 的/ 每个/ 页表/ 维护/ 一个/ “/ 影子/ 页表/ ”/ ,/ 并/ 将/ 合成/ 后/ 的/ 映射/ 关系/ 写入/ 到/ “/ 影子/ ”/ 中/ ,/ GuestOS/ 的/ 页表/ 内容/ 则/ 保持/ 不变/ ./ 最后/ ,/ VMM/ 将/ 影子/ 页表/ 交给/ 内存/ 管理/ 模块/ (/ MemoryManagementUnit/ ,/ MMU/ )/ 进行/ 地址/ 转换/ ./ 试举/ 一例/ 说明/ :/ 假设/ 一个/ 运行/ 在/ GuestOS/ 中/ 的/ 进程/ ,/ 当其/ 访问/ 0x12345678/ 这个/ 虚拟地址/ 时/ ,/ 因为/ 在/ 影子/ 页表/ 中/ 尚未/ 为/ 其/ 建立/ 页表/ 项/ ,/ 所以/ 会/ 产生/ 缺页/ 异常/ ,/ 使得/ GuestOS/ 陷入/ 到/ 虚拟机/ 管理器/ 中/ ./ 虚拟机/ 管理器/ 首先/ 查看/ GuestOS/ 的/ 页表/ 中/ 是否/ 存在/ 有效/ 的/ 映射/ g/ ./ 如果/ 不/ 存在/ ,/ 则/ 将/ 异常/ 交付给/ GuestOS/ 处理/ ./ 如果/ 存在/ ,/ 虚拟机/ 管理器/ 在/ 影子/ 页表/ 项中/ 直接/ 建立/ 映射/ f/ ·/ g/ ,/ 从/ 虚拟地址/ 页/ 0x12345000/ 转换/ 为/ 物理/ 页/ 的/ 地址/ ./ 当此/ 影子/ 页表/ 项/ 被/ 清除/ 时/ ,/ 虚拟机/ 管理器/ 再/ 负责/ 将/ 影子/ 页表/ 项中/ 的/ Dirty/ 位/ 和/ Access/ 位/ 同步/ 到/ GuestOS/ 的/ 页表/ 中去/ ./ 2.3/ ./ 2/ 内存/ 监控/ 的/ 原理/ 和/ 方法/ 内存/ 监控/ 的/ 一个/ 选择/ 是/ 通过/ 管理/ 虚拟机/ 的/ 影子/ 页表/ 实现/ ./ 在/ 虚拟机/ 运行/ 时/ ,/ 内存/ 管理/ 模块/ 载入/ 影子/ 页表/ ,/ 试图/ 完成/ 从/ GVA/ 到/ HPA/ 的/ 映射/ ./ 如果/ 影子/ 页表/ 中/ 已经/ 存在/ 某个/ GVA/ 到/ 其/ HPA/ 的/ 映射/ ,/ 那么/ 这个/ 转换/ 过程/ 会/ 自动/ 完成/ ;/ 否则/ ,/ 虚拟/ 机会/ 陷入/ 到/ 虚拟机/ 管理器/ 中/ ,/ 由/ 后者/ 完善/ GVA/ 到/ HPA/ 的/ 映射/ ./ 基于/ 影子/ 页表/ 的/ 这种/ 特征/ ,/ 通过/ 如下/ 步骤/ 即可/ 完成/ 对/ 内存/ 的/ 监控/ :/ 首先/ ,/ 计算/ 出/ 内存/ 片断/ 所/ 跨越/ 的/ 所有/ 页面/ ,/ 例如/ 在/ 页面/ 大小/ 为/ 4KB/ 的/ 虚拟机/ 中/ ,/ 首/ 地址/ 为/ 0x80a8400/ ,/ 长度/ 为/ 10KB/ 的/ 内存/ 片断/ ,/ 跨越/ 了/ 3/ 个/ 页面/ :/ 其中/ 占/ 第/ 1/ 个/ 和/ 第/ 3/ 个/ 页面/ 的/ 部分/ ,/ 完全/ 占用/ 第/ 2/ 个/ 页面/ (/ 如图/ 2/ (/ a/ )/ 所示/ )/ ./ 接着/ ,/ 在/ 影子/ 页表/ 中/ 消除/ 对/ 这些/ 页面/ 的/ GVA/ 到/ HPA/ 的/ 映射/ 关系/ ./ 因为/ 这些/ 页面/ 的/ 映射/ 关系/ 被/ 消除/ ,/ 那么/ 只要/ 虚拟机/ 试图/ 访问/ 该/ 内存/ 片断/ ,/ 都/ 会/ 导致/ 虚拟机/ 的/ 陷入/ (/ 如图/ 2/ (/ b/ )/ 所示/ )/ ./ 最后/ ,/ 在/ 虚拟机/ 陷入/ 时/ ,/ 分析/ 陷入/ 指令/ 所/ 访问/ 的/ 内存地址/ 是否/ 属于/ 该/ 内存/ 片断/ ./ 通过/ 内存/ 虚拟化/ 机制/ 实现/ 的/ 内存/ 监控/ ,/ 是/ 基于/ 页面/ 级/ ,/ 即/ 所/ 监控/ 的/ 最小/ 内存/ 单位/ 是/ 内存/ 页/ ./ 内存/ 页/ 通常/ 大小/ 是/ 4KB/ ,/ 也/ 有/ 其它/ 大小/ ,/ 例如/ 2MB/ 和/ 4MB/ ./ 在/ 进行/ 监控/ 时/ ,/ 虚拟机/ 对/ 页面/ 范围/ 内/ 的/ 所有/ 内存地址/ 访问/ 都/ 会/ 导致/ 陷入/ ,/ 因此/ ,/ 监控/ 的/ 单位/ 大小/ 越小越/ 好/ ./ 基于/ 硬件/ ECC/ 的/ 监控/ 是/ 更/ 细粒度/ 的/ 监控/ 机制/ ,/ 被/ SafeMem/ 所/ 采用/ ./ 如果/ 虚拟机/ 管理器/ 存在/ ECCPage6/ 的/ 支持/ ,/ 也/ 能够/ 实现/ Cacheline/ 大小/ 粒度/ 的/ 监控/ ,/ SafeMem/ 所/ 使用/ 的/ 方法/ 同样/ 适用/ 于/ 虚拟机/ 管理器/ ./ 这种/ 内存/ 监控/ 的/ 原理/ ,/ 也/ 适用/ 于/ 其它/ 内存/ 虚拟化/ 方法/ ,/ 例如/ 直接/ 页表/ 访问/ ./ 即使/ 是/ 硬件/ 辅助/ 内存/ 虚拟化/ 技术/ ,/ 例如/ EPT/ (/ ExtendedPageTables/ )/ [/ 7/ ]/ 或者/ NPT/ (/ NestedPageTables/ )/ [/ 8/ ]/ ,/ 在/ 其/ 上/ 实现/ 内存/ 监控/ ,/ 核心思想/ 是/ 通用/ 的/ ,/ 即/ 从/ 虚拟机/ 管理器/ 中/ ,/ 消除/ 虚拟机/ 从/ GVA/ 到/ HPA/ 的/ 内存/ 地址映射/ 关系/ ./ 2.3/ ./ 3/ 虚拟机/ 管理器/ 监控/ 内存/ 的/ 有效性/ 分析/ 虚拟机/ 管理器/ 监控/ 内存/ 引入/ 的/ 性能/ 开销/ 主要/ 源于/ 截获/ 资源/ 申请/ 和/ 释放/ 的/ 函数/ 和/ 影子/ 页表/ 导致/ 的/ 虚拟机/ 陷入/ ./ 每次/ 陷入/ 的/ 开销/ 公式/ 如下/ :/ COST/ [/ 陷入/ ]/ =/ COST/ [/ VM/ 切换/ 到/ VMM/ ]/ +/ 虚拟机/ 和/ 虚拟机/ 管理器/ 之间/ 的/ 切换/ 会/ 引入/ 很大/ 的/ 性能/ 开销/ ./ 首先/ ,/ 切换/ 本身/ 会/ 耗费/ 很多/ 的/ 处理器/ 周期/ ,/ 因为/ 在/ 切换/ 过程/ 中/ ,/ 处理器/ 不仅/ 需要/ 保存/ 原/ 状态/ ,/ 而且/ 需要/ 载入/ 新/ 状态/ ./ 其次/ ,/ 这种/ 切换/ 还会/ 导致/ 额外/ 的/ Cache/ 失效/ ,/ 因为/ 虚拟机/ 管理器/ 和/ 虚拟机/ 共享/ Cache/ 且/ 代码/ 和/ 数据/ 并不相同/ ./ 最后/ ,/ TLB/ (/ TranslateLookasideBuffer/ )/ [/ 7/ ]/ 被/ 刷新/ 的/ 开销/ ./ TLB/ 缓存/ 着/ 虚拟地址/ 到/ 物理地址/ 的/ 映射/ ,/ 避免/ 了/ MMU/ 在/ 地址映射/ 时/ 对/ 存放/ 在/ 内存/ 中/ 的/ 页表/ 的/ 重复/ 遍历/ 访问/ ./ 因为/ 虚拟机/ 管理器/ 和/ 虚拟机/ 使用/ 不同/ 的/ 页表/ ,/ 所以/ 每次/ 切换/ 都/ 会/ 导致/ TLB/ 的/ 刷新/ 操作/ ,/ 这个/ 开销/ 是/ 非常/ 大/ 的/ ./ 然而/ ,/ 随着/ 硬件/ 的/ 不断/ 发展/ ,/ 新/ 的/ 技术/ ,/ 如/ VPID/ (/ VirtualProcessID/ )/ [/ 7/ ]/ ,/ 能够/ 避免/ 或/ 减少/ 在/ 虚拟机/ 管理器/ 和/ 虚拟机/ 之间/ 切换/ 时/ TLB/ 的/ 刷新/ ,/ 从而/ 降低/ TLB/ 刷新/ 的/ 开销/ ./ 截获/ 资源/ 申请/ 和/ 释放/ 的/ 函数/ 的/ 开销/ 与/ 这些/ 函数调用/ 点/ 的/ 次数/ 成正比/ ./ 性能/ 的/ 主要/ 开销/ 在于/ 对/ 内存/ 使用/ 进行/ 监控/ ./ 虚拟机/ 管理器/ 监控/ 动态内存/ 的/ 访问/ 情况/ ,/ 会/ 导致/ 额外/ 的/ 附带/ 开销/ ./ 为了/ 监控/ 占用/ 部分/ 内存/ 页面/ 的/ 动态内存/ ,/ 需要/ 监控/ 整个/ 页面/ 被/ 访问/ 情况/ ./ 如果/ 该/ 页面/ 中/ ,/ 动态内存/ 片断/ 之外/ 的/ 内存/ 页面/ 当前/ 被/ 虚拟机/ 监控器/ 频繁/ 使用/ ,/ 则/ 对/ 该/ 页面/ 的/ 监控/ 因为/ 频繁/ 地/ 陷入/ 会/ 导致/ 虚拟机/ 性能/ 的/ 急剧下降/ ./ 在/ 制定/ 监控/ 策略/ 时/ ,/ 应当/ 避免/ 监控/ 这种/ 页面/ ./ 在/ 实际/ 应用/ 程序运行/ 时/ ,/ 如/ malloc/ 等/ 动态内存/ 申请/ 方法/ 所/ 申请/ 的/ 动态内存/ 一般/ 处在/ 应用程序/ 的/ 堆栈/ 上/ ,/ 该/ 动态内存/ 地址/ 的/ 前后/ 内存/ 很/ 有/ 可能/ 也/ 属于/ 动态内存/ ,/ 因此/ ,/ 对/ 一个/ 动态内存/ 的/ 监控/ ,/ 有/ 可能/ 会/ 附带/ 监控/ 其它/ 多个/ 动态内存/ ,/ 这个/ 特性/ 对/ 我们/ 监控/ 内存/ 的/ 访问/ 是/ 有/ 好处/ 的/ ,/ 因为/ 同样/ 的/ 性能/ 损失/ ,/ 可以/ 完成/ 对/ 多个/ 动态内存/ 的/ 监控/ ./ 为了/ 提高/ 虚拟机/ 管理器/ 监控/ 内存/ 的/ 效率/ ,/ 除了/ 避免/ 对/ 热/ 页面/ 的/ 监控/ ,/ 还/ 应当/ 减小/ 监控/ 粒度/ ./ 对于/ 页面/ 级/ 的/ 监控/ ,/ 4KB/ 大小/ 的/ 页面/ 要/ 优于/ 2MB/ 大小/ 的/ 页面/ ,/ 因为/ 虚拟机/ 对/ 前者/ 的/ 访问/ 次数/ 一般/ 要/ 少于/ 对/ 后者/ 的/ 访问/ 次数/ ./ 如果/ 硬件/ 提供/ 更/ 细粒度/ 的/ 机制/ ,/ 应当/ 优先/ 使用/ 硬件/ 提供/ 的/ 机制/ ./ 3/ 在/ KVM/ 平台/ 上/ 的/ 实现/ 我们/ 在/ KMV/ -/ 84/ 虚拟机/ 管理器/ 之上/ 实现/ 了/ 内存/ 泄露/ 的/ 探测/ ./ KVM/ 是/ 基于/ GNU/ // Linux/ 实现/ 的/ 虚拟机/ 管理器/ ,/ 以/ 模块/ 的/ 形式/ 运行/ 在/ 操作系统/ 中/ ./ 虚拟机/ 表现/ 为/ 操作系统/ 中/ 的/ 一个/ QEMU/ ①/ 进程/ ,/ 该/ 进程/ 通过/ 和/ KVM/ 模块/ 的/ 交互/ ,/ 实现/ 了/ 处理器/ 虚拟化/ 、/ 内存/ 虚拟化/ 以及/ 部分/ 硬件/ 的/ 虚拟化/ ;/ 其它/ 硬件/ 设备/ 如/ 网卡/ 和/ 外存/ 的/ 虚拟化/ ,/ 由/ QEMU/ 实现/ ./ 因为/ KVM/ 是/ 操作系统/ 内部/ 的/ 一个/ 模块/ ,/ 所以/ 其/ 调试/ 和/ 运行/ 非常/ 方便/ ,/ 通过/ 模块/ 的/ 动态/ 加载/ 和/ 卸除/ 即可/ 实现/ 更新/ ,/ 这点/ 是/ Xen/ [/ 6/ ]/ 无法/ 提供/ 的/ ,/ 在/ 其/ 上/ 每次/ 修改/ 都/ 需要/ ①/ http/ :/ // // www/ ./ nongnu/ ./ org/ // qemu/ // Page7/ 重启/ 硬件/ ./ 本/ 实验/ 中/ ,/ 虚拟机/ 使用/ 的/ 操作系统/ 是/ 比较/ 主流/ 的/ Redhat4/ ./ 1.1/ -/ 52/ 版本/ ./ 接下来/ 讨论/ 实现/ 中/ 的/ 各个/ 细节/ 问题/ ./ 申请/ 和/ 释放/ 函数/ 地址/ 的/ 获取/ ./ 存在/ 于/ 用户/ 地址/ 空间/ 的/ 函数/ 例如/ malloc/ 和/ free/ 函数/ ,/ 通过/ 调试程序/ (/ 如/ GDB/ )/ 即可/ 获取/ 其/ 地址/ ./ 将/ 应用程序/ 的/ 可/ 执行/ 代码/ 进行/ 反汇编/ ,/ 也/ 很/ 容易/ 察看/ 到/ 这些/ 函数/ 的/ 地址/ ./ 如/ 在/ 2.3/ ./ 2/ 小节/ 中/ ,/ 截获/ malloc/ 的/ 调用/ ,/ 只/ 需要/ 在/ 地址/ 0x804830c/ 处/ 插入/ VMCALL/ 代码/ 即可/ ./ 内核/ 函数/ 如/ vmalloc/ 和/ vfree/ 等/ 的/ 地址/ ,/ 可/ 在/ GNU/ // Linux/ 的/ sysmap/ 中/ 获取/ ./ 通过/ VMCALL/ 可以/ 将/ 资源/ 申请/ 和/ 释放/ 的/ 函数/ 地址/ 传递/ 到/ 虚拟机/ 管理器/ 中/ ./ 这些/ 地址/ 是/ 有限/ 的/ 、/ 静态/ 的/ ./ 而/ 对/ 这些/ 函数/ 的/ 调用/ 点/ 是/ 在/ 虚拟机/ 运行/ 过程/ 中/ 动态/ 发现/ 的/ ,/ 我们/ 需要/ 截获/ 的/ 调用/ 返回/ 点/ 因此/ 也/ 是/ 动态/ 的/ ./ 因为/ 对/ 这些/ 地址/ (/ 申请/ 和/ 释放/ 资源/ 的/ 函数/ 地址/ 、/ 函数调用/ 返回/ 点/ )/ 的/ 查找/ 操作/ 非常/ 频繁/ ,/ 所以/ 我们/ 将/ 这些/ 地址/ 以及/ 陷入/ 点/ 类型/ 等/ 信息/ 存放/ 在/ 快速/ 查找/ 树中/ ,/ 以/ 提高/ 查找/ 效率/ ./ 对/ 资源/ 函数调用/ 和/ 返回/ 的/ 截获/ ./ 在/ 函数/ 的/ 首/ 地址/ 和/ 返回/ 处/ 插入/ VMCALL/ 指令/ 之后/ ,/ 虚拟/ 机会/ 在/ 这些/ 地址/ 陷入/ 到/ 虚拟机/ 管理器/ 中/ ./ 陷入/ 原因/ 是/ VMCALL/ ./ 我们/ 在/ 处理/ VMCALL/ 时/ ,/ 判断/ 陷入/ 地址/ 是否/ 在/ 快速/ 查找/ 树中/ ,/ 如果/ 在/ ,/ 则/ 查明/ 陷入/ 点/ 的/ 类型/ ./ 有/ 3/ 种/ 类型/ :/ 资源/ 申请/ 函数/ 陷入/ 、/ 资源/ 释放/ 函数/ 陷入/ 和/ 返回/ 点/ 陷入/ ./ 如果/ 陷入/ 点/ 是/ 资源/ 申请/ 函数/ ,/ 则/ 需要/ 分析/ 并/ 记录/ 其/ 参数/ ,/ 另外/ 在/ 返回/ 点处/ 插入/ VM/ -/ CALL/ ./ 如果/ 陷入/ 点/ 是/ 返回/ 点/ ,/ 则/ 需要/ 分析/ 函数/ 返回/ 结果/ ./ 函数/ 的/ 返回/ 结果/ 一般/ 存在/ 堆栈/ 上/ 或者/ 寄存器/ 中/ ,/ 不同/ 类型/ 的/ 函数/ 是/ 不/ 一样/ 的/ ,/ 需要/ 区分/ 对待/ ./ 如果/ 申请/ 成功/ ,/ 需要/ 记录/ 动态内存/ 的/ 信息/ :/ 首/ 地址/ 、/ 大小/ 、/ 时间/ 和/ 类型/ 等/ ./ 如果/ 陷入/ 点/ 的/ 类型/ 是/ 资源/ 释放/ 函数/ ,/ 则/ 需要/ 分析/ 其/ 参数/ ,/ 将/ 该/ 动态内存/ 的/ 分配/ 记录/ 删除/ ./ 完成/ 截获/ 后/ 的/ 分析/ 和/ 记录/ ,/ 调用/ KVM/ 的/ emulate/ _/ instruction/ 函数/ ,/ 模拟/ 执行/ 指令/ ,/ 跳过/ 被/ 插入/ 的/ VMCALL/ 指令/ ./ 这里/ 的/ 额外/ 工作/ 是/ ,/ emulate/ _/ instruction/ 函数/ 会/ 读取/ 虚拟机/ 的/ 指令/ 进行/ 模拟/ ,/ 而/ 当前/ 指令/ 是/ 被/ 替换/ 过/ 的/ VMCALL/ 指令/ ,/ 需要/ 给/ 该/ 函数/ 提供/ 被/ 替换/ 前/ 的/ 指令/ ./ 解决/ 方法/ 是/ 修改/ 虚拟机/ 管理器/ 读取/ 虚拟机/ 指令/ 的/ 函数/ ,/ 对/ 不同/ 情况/ 进行/ 判断/ ,/ 如果/ 读取/ 指令/ 地址/ 是/ 被/ 我们/ 替换/ 过/ 的/ 地址/ ,/ 则/ 需要/ 返回/ 原始/ 指令/ ./ 然后/ 把/ 状态/ 从/ VMM/ 切换/ 到/ VM/ ,/ 截获/ 工作/ 至此/ 完成/ ./ 函数调用/ 栈/ 的/ 获取/ ./ 当/ 一个/ 函数/ 被/ 调用/ 时/ ,/ 返回/ 地址/ 被/ 压到/ 栈/ 上/ ,/ 然后/ 处理器/ 跳转/ 到/ 被/ 调用/ 的/ 函数/ 处/ 开始/ 执行/ ./ 当/ 被/ 调用/ 的/ 函数/ 返回/ 时/ ,/ 处理器/ 从/ 原来/ 被/ 压到/ 栈/ 上/ 的/ 返回/ 地址/ 处/ 继续执行/ ./ 当/ 程序执行/ 的/ 过程/ 中/ 出现/ 多层/ 调用/ 时/ ,/ 栈上/ 就/ 会/ 保存/ 一系列/ 对应/ 的/ 返回/ 地址/ ./ 由/ 这些/ 返回/ 地址/ 很/ 容易/ 获取/ 到/ 其/ 所在/ 的/ 一系列/ 函数/ ./ 这/ 一系列/ 函数/ 被称作/ 调用/ 栈/ ./ 资源分配/ 时/ ,/ 分配/ 函数/ 的/ 调用/ 栈/ 能够/ 辅助/ 程序开发/ 人员/ 分析/ 此/ 函数调用/ 的/ 代码/ 轨迹/ ./ 对于/ 疑似/ 被/ 泄露/ 的/ 内存/ ,/ 通过/ 其/ 分配/ 函数/ 的/ 调用/ 栈/ 可以/ 获悉/ 其/ 分配/ 时/ 程序/ 的/ 上下文/ ,/ 从而/ 排查/ 出其/ 是否/ 真的/ 存在/ 内存/ 泄露/ ./ 监控/ 策略/ 的/ 实现/ ./ 我们/ 将/ 监控/ 策略/ 以/ 进程/ 的/ 方式/ 运行/ ,/ 策略/ 进程/ 和/ 虚拟机/ 模块/ 通过/ 命令/ 进行/ 数据/ 交互/ ,/ 这种/ 实现/ 方式/ 主要/ 基于/ 如下/ 的/ 考虑/ ./ 首先/ ,/ 监控/ 策略/ 的/ 推断/ 是/ 一个/ 复杂/ 且/ 繁琐/ 的/ 过程/ ,/ 不/ 适合/ 实现/ 在/ 内核/ 中/ ,/ 在/ 进程/ 中/ 实现/ 能够/ 更加/ 灵活/ ./ 其次/ ,/ 将/ 高层/ 功能/ 从/ 虚拟机/ 管理器/ 中/ 抽取/ 出来/ ,/ 有利于/ 虚拟机/ 管理器/ 的/ 稳定/ ./ 监控/ 策略/ 的/ 步骤/ 如下/ :/ (/ 1/ )/ 策略/ 程序/ 向/ 虚拟机/ 管理器/ 发送/ 命令/ ,/ 获取/ 当前/ 未/ 被/ 释放/ 的/ 动态内存/ 的/ 信息/ 列表/ ,/ 包括/ 内存/ 起始/ 地址/ 、/ 长度/ 、/ 申/ 获取/ 函数调用/ 栈/ 的/ 难点/ 在于/ 如何/ 从栈/ 上/ 排查/ 出/ 这些/ 返回/ 地址/ ,/ 因为/ IntelX86/ 体系结构/ 中/ ,/ 栈上/ 不仅/ 保存/ 着/ 返回/ 地址/ ,/ 还/ 保存/ 着/ 函数/ 的/ 参数/ ./ 准确/ 地/ 获取/ 函数调用/ 栈/ 需要/ 结合/ 分析/ 应用程序/ 的/ 代码/ 和/ 堆栈/ 上/ 的/ 数据/ ,/ 这种/ 方法/ 比较/ 耗时/ ./ 本文/ 采用/ 的/ 是/ 应用/ 在/ GNU/ // Linux/ 内核/ 中/ 的/ 方法/ ./ 该/ 方法/ 逐条/ 读取/ 堆栈/ 中/ 的/ 数据/ ,/ 如果/ 该/ 数据/ 落/ 在/ 代码/ 地址/ 空间/ 中/ ,/ 则/ 该/ 数据/ 被/ 认为/ 是/ 一个/ 返回/ 地址/ ./ 在/ 实际/ 的/ 运行/ 过程/ 中/ ,/ 该/ 方法/ 不仅/ 快/ ,/ 而且/ 正确率/ 高/ ./ 在/ KVM/ 的/ 影子/ 页表/ 机制/ 中/ 实现/ 对/ 内存/ 的/ 监控/ ./ 实现/ 过程/ 需要/ 两个/ 步骤/ :/ (/ 1/ )/ 对于/ 欲/ 监控/ 内存/ 区域/ 所/ 跨越/ 的/ 每个/ 页/ ,/ 在/ 影子/ 页表/ 中/ 清除/ 其/ PageTableEntry/ (/ PTE/ )/ ,/ 使得/ 以后/ 对/ 这些/ 页面/ 的/ 访问/ 会/ 产生/ PageFault/ ./ 因为/ 我们/ 修改/ 了/ PTE/ ,/ 改变/ 了/ GVA/ 到/ HPA/ 的/ 映射/ 关系/ ,/ 所以/ 还/ 需要/ 清除/ TLB/ ,/ 使/ 原来/ 的/ 映射/ 失效/ ./ (/ 2/ )/ 在/ 虚拟机/ 发生/ PageFault/ 时/ ,/ 判断/ 被/ 访问/ 地址/ 是否/ 在/ 我们/ 保护/ 的/ 范围/ 内/ ,/ 甄别/ 出/ 需要/ 额外/ 处理/ 的/ 部分/ ./ 对于/ 被/ 监控/ 区域/ 的/ 访问/ ,/ 记录/ 被/ 访问/ 时间/ 和/ 类型/ (/ 读/ 或/ 写/ )/ ,/ 解除/ 对此/ 内存/ 区域/ 的/ 监控/ ./ KVM/ 默认/ 的/ 处理程序/ 会为/ 这个/ 页面/ 建立/ 新/ 的/ PTE/ ,/ 至此/ 监控/ 解除/ ./ Page8/ 请/ 时间/ 、/ 最后/ 访问/ 时间/ 、/ 类型/ 以及/ 函数调用/ 栈/ 等/ 信息/ ./ (/ 2/ )/ 策略/ 进程/ 从/ 列表/ 中/ 推选/ 出/ 需要/ 监控/ 的/ 内存/ 段/ ,/ 发送/ 命令/ 给/ 虚拟机/ 管理器/ ./ 最后/ ,/ 策略/ 进程/ 汇总/ 内存/ 段/ 的/ 各种/ 信息/ ,/ 判断/ 其/ 是否/ 存在/ 内存/ 泄露/ 嫌疑/ ./ 4/ 实验/ 评估/ 前面/ 介绍/ 了/ 基于/ 虚拟机/ 管理器/ 探测/ 内存/ 泄露/ 的/ 实现/ ,/ 本/ 节/ 说明/ 探测/ 内存/ 泄露/ 相关/ 实验/ 的/ 结果/ ./ 我们/ 主要/ 关注/ 探测/ 机制/ 对/ 虚拟机/ 带来/ 的/ 性能/ 损失/ 和/ 内存/ 探测/ 有效性/ 两个/ 方面/ ./ 针对/ 各/ 部分/ 实验/ 结果/ ,/ 分析/ 了/ 原因/ ,/ 并/ 指出/ 了/ 可能/ 的/ 改进/ 办法/ ./ 最终/ 实验/ 结果表明/ ,/ 基于/ 虚拟机/ 管理器/ 进行/ 内存/ 泄露/ 的/ 探测/ ,/ 其/ 实现/ 对/ 应用程序/ 造成/ 的/ 性能/ 损失/ 很小/ ,/ 低于/ 10/ %/ ;/ 在/ 公认/ 的/ 存在/ 内存/ 泄露/ 的/ 开源/ 软件/ 中/ ,/ 发现/ 了/ 内存/ 泄露/ 的/ 嫌疑/ ./ 但/ 因为/ 受/ 测试环境/ 的/ 限制/ ,/ 所/ 发现/ 的/ 内存/ 泄露/ 嫌疑/ 比较/ 有限/ ./ 如果/ 能/ 在/ 真实/ 应用环境/ 中/ 进行/ 测试/ ,/ 可能/ 会/ 得到/ 更好/ 的/ 结果/ ./ 4.1/ 实验/ 环境/ 我们/ 使用/ 的/ 测试环境/ 为/ ,/ IntelCoreTM2CPU/ @/ 1.86/ GHz/ ,/ 双核/ CPU/ ,/ 2MBCache/ ,/ 2GB/ 内存/ ;/ KVM/ -/ 84/ 版本/ ,/ 虚拟机/ 中/ 内核/ 版本/ 为/ Linux2/ ./ 6.24/ ./ 3/ ,/ 只/ 配备/ 了/ 一个/ 硬盘分区/ ;/ SATA/ 硬盘/ ,/ 单/ 网卡/ ;/ 编译器/ 为/ GCC4/ ./ 1.1/ ;/ 虚拟机/ 管理器/ 所在/ 的/ 操作系统/ 版本/ 也/ 是/ Linux2/ ./ 6.24/ ./ 3/ ./ 每次/ 测试/ 时/ 除了/ 受/ 测试/ 虚拟机/ 运行/ 外/ ,/ 无/ 其它/ 虚拟机/ 在/ 执行/ ./ 虚拟机/ 只/ 配置/ 了/ 一个/ VCPU/ (/ VirtualCPU/ )/ ./ 首先/ ,/ 我们/ 测试/ 了/ 本/ 实现/ 对/ 虚拟机/ 性能/ 的/ 影响/ ;/ 然后/ ,/ 测试/ 了/ 公认/ 的/ 存在/ 内存/ 泄露/ 的/ 开源/ 软件/ 中/ ,/ 内存/ 分配/ 和/ 释放/ 的/ 情况/ ,/ 并/ 分析/ 了/ 内存/ 泄露/ 的/ 嫌疑/ ./ 4.2/ 性能/ 损失/ 测试/ 我们/ 设计/ 了/ 两个/ 实验/ ,/ 测试/ 了/ 本/ 实现/ 本身/ 对/ 运行/ 在/ KVM/ 之上/ 的/ 应用程序/ 性能/ 的/ 影响/ ./ 实验/ 1/ 测试/ 的/ 程序/ 是/ 常见/ 的/ 编译器/ GCC4/ ./ 1.1/ ,/ 我们/ 截获/ 了/ GCC/ 中/ 的/ 所有/ 的/ 内存/ 申请/ 和/ 释放/ 函数调用/ ,/ 然后/ 分别/ 测试/ 了/ 编译/ proftpd/ -/ 1.3/ ./ 2rc4/ 源代码/ 的/ 时间/ ;/ 实验/ 2/ 是/ 我们/ 设计/ 的/ 程序/ ,/ 该/ 程序/ 调用/ 了/ 6/ 亿次/ 的/ malloc/ 和/ free/ 函数/ ./ 最终/ 结果/ 如表/ 1/ 所示/ ./ GCC4/ ./ 1.1286/ 亿次/ 调用/ malloc/ 和/ free68/ ./ 889/ 由表/ 1/ 可知/ ,/ 具有/ 异常/ 频繁/ 内存/ 申请/ 和/ 释放/ 的/ GCC4/ ./ 1.1/ 程序/ ,/ 在/ 正常/ 的/ KVM/ 虚拟机/ 上/ 编译/ 一个/ 应用程序/ 所/ 需/ 时间/ 为/ 28s/ ,/ 而/ 在/ 添加/ 了/ 内存/ 泄露/ 探测/ 机制/ 的/ KVM/ 虚拟机/ 上/ 编译/ 同一个/ 应用程序/ 所/ 需/ 时间/ 为/ 30s/ ,/ 可见/ 内存/ 泄露/ 探测/ 机制/ 引起/ 的/ 性能/ 损失/ 在/ 10/ %/ 以内/ ./ 而/ 对于/ 我们/ 设计/ 的/ 6/ 亿次/ malloc/ 和/ free/ 函数调用/ 的/ 程序/ ,/ 内存/ 泄露/ 探测/ 机制/ 引起/ 的/ 性能/ 损失/ 则/ 更少/ ,/ 几乎/ 可以/ 忽略不计/ ./ 4.3/ 有效性/ 为了/ 测试/ 基于/ 虚拟机/ 管理器/ 进行/ 内存/ 泄露/ 机制/ 的/ 有效性/ ,/ 我们/ 选择/ 了/ 公认/ 存在/ 内存/ 泄露/ 的/ 两个/ 开源/ 软件/ :/ proftpd/ -/ 1.2/ ./ 9/ 和/ squid/ -/ 2.4/ ,/ 并/ 对/ 其/ 分别/ 进行/ 了/ 测试/ ./ 测试/ proftpd/ -/ 1.2/ ./ 9/ 的/ 实验/ 环境/ 是/ :/ 通过/ 多个/ 客户端程序/ ,/ 向/ 服务器发送/ 1000/ 次/ SIZE/ 命令/ ./ 因为/ SIZE/ 命令/ 会/ 导致/ proftpd/ 发生/ 内存/ 泄露/ ./ 在/ 测试程序/ 完成/ 后/ ,/ 尚未/ 被/ proftpd/ 释放/ 的/ 动态内存/ 详细信息/ 见表/ 2/ ./ 地址/ 申请/ 内存/ 的/ 0x804e559malloc/ (/ )/ 29/ 不/ 统一/ 0x804e778malloc/ (/ )/ 10x8051239malloc/ (/ )/ 35/ 绝大部分/ 是/ 5240x80584f8realloc/ (/ )/ 14097/ 从表/ 2/ 中/ 我们/ 可以/ 看出/ ,/ 在/ 地址/ 0x804e778/ 和/ 0x80584f8/ 处/ 只有/ 一次/ 没有/ 释放/ 的/ malloc/ 内存/ 分配/ ,/ 分配/ 的/ 内存/ 长度/ 分别/ 为/ 8/ 个/ 字节/ 和/ 4097/ 个/ 字节/ ;/ 而/ 在/ 地址/ 0x804e559/ 和/ 0x8051239/ 处/ 没有/ 释放/ 的/ malloc/ 分配/ 记录/ 则/ 有/ 数十次/ ,/ 并且/ 在/ 地址/ 0x8051239/ 处/ 分配/ 的/ 内存/ 长度/ 绝大部分/ 都/ 是/ 相同/ 的/ ,/ 因此/ 我们/ 可以/ 推测/ 此处/ 很/ 有/ 可能/ 是/ 一个/ 内存/ 泄露/ 点/ ./ 测试/ squid/ -/ 2.4/ 的/ 方法/ 是/ 同时/ 启动/ 5/ 个/ 客户端程序/ ,/ 每个/ 程序/ 向/ squid/ 服务/ 连续/ 发送/ 100/ 个/ 请求/ ./ 在/ 5/ 个/ 客户端程序/ 都/ 结束/ 时/ ,/ squid/ 服务/ 未/ 释放/ 的/ 动态内存/ 资源/ 见表/ 3/ ./ 地址/ 申请/ 内存/ 的/ 0x80a8e4acalloc/ (/ )/ 113/ 不/ 统一/ 0x80a8f88malloc/ (/ )/ 14640x80a8edfrealloc/ (/ )/ 2192/ 从表/ 3/ 中/ 我们/ 可以/ 看出/ ,/ 在/ IP地址/ 0x80a8e4aPage9/ 处有/ 上/ 百次/ 的/ calloc/ 分配/ 都/ 没有/ 释放/ ,/ 它/ 很/ 有/ 可能/ 是/ 一个/ 内存/ 泄露/ 点/ ;/ 在/ 地址/ 0x80a8f88/ 处有/ 14/ 次/ mal/ -/ loc/ 内存/ 分配/ 没有/ 释放/ ,/ 且/ 分配/ 的/ 内存/ 长度/ 都/ 是/ 64/ 字节/ ,/ 它/ 也/ 可能/ 是/ 一个/ 内存/ 泄露/ 点/ ;/ 而/ 在/ 地址/ 0x80a8edf/ 处/ 只有/ 两次/ realloc/ 内存/ 分配/ 没有/ 释放/ ./ 如表/ 2/ 和表/ 3/ 所示/ ,/ 存在/ 内存/ 泄露/ 的/ 可能/ 地址/ 是/ 非常/ 有限/ 的/ ,/ 通过/ 函数调用/ 栈/ ,/ 调试/ 人员/ 很/ 容易/ 就/ 能够/ 定位/ 存在/ 内存/ 泄露/ 的/ 点/ ./ 正如/ 上面/ 所说/ ,/ proft/ -/ pd/ 测试/ 中/ ,/ SIZE/ 命令/ 必然/ 会/ 导致/ 内存/ 泄露/ ,/ 所以/ 在/ 表/ 2/ 中/ 的/ 地址/ 中/ ,/ 必然/ 存在/ 内存/ 泄露/ ./ 5/ 结论/ 以及/ 下/ 一步/ 工作/ 虚拟机/ 技术/ 的/ 不断/ 发展/ 使得/ 虚拟化/ 的/ 代价/ 越来越低/ ,/ 同时/ 也/ 推动/ 了/ 虚拟化/ 技术/ 的/ 应用/ ./ 利用/ 虚拟化/ 技术/ 来/ 提高/ 操作系统/ 的/ 安全性/ 近来/ 受到/ 人们/ 越来越/ 多/ 的/ 重视/ ./ 基于/ 虚拟化/ 平台/ 已经/ 有/ 了/ 一系列/ 的/ 研究/ ./ 其中/ 一项/ 是/ 利用/ 虚拟机/ 的/ 可/ 复制/ 性/ 建立/ Honey/ -/ Farm/ [/ 9/ ]/ ,/ 以/ 捕获/ 、/ 记录/ 和/ 分析/ 黑客/ 对系统/ 的/ 攻击行为/ ,/ 从而/ 提高/ 系统/ 的/ 安全性/ ./ 另外/ ,/ Lycosid/ [/ 10/ ]/ 利用/ 虚拟机/ 管理器/ 对/ 资源/ 的/ 绝对/ 控制/ 和/ 对/ 操作系统/ 的/ 透明性/ ,/ 提出/ 了/ 一套/ 检测/ 和/ 标识/ 隐藏/ 进程/ 的/ 机制/ ;/ 有/ 很多/ 病毒程序/ 能够/ 在/ 操作系统/ 中/ 隐藏/ 自己/ ,/ 增加/ 被/ 用户/ 发现/ 的/ 难度/ ./ 本文/ 利用/ 虚拟机/ 管理器/ 对/ 其/ 上/ 虚拟机/ 的/ 掌控/ 性/ 和/ 透明性/ ,/ 提出/ 了/ 探测/ 内存/ 泄露/ 的/ 一种/ 机制/ ,/ 该/ 机制/ 提供/ 了/ 内存/ 探测/ 的/ 平台/ 通用性/ ,/ 不/ 需要/ 修改/ 或者/ 重新/ 编译/ 应用程序/ 的/ 源代码/ ,/ 并且/ ,/ 虚拟机/ 的/ 性能/ 损失/ 在/ 10/ %/ 以内/ ./ 本文/ 的/ 基本思路/ 是/ :/ 在/ 虚拟机/ 平台/ 中/ 通过/ 在/ 虚拟机/ (/ GuestOS/ )/ 中/ 插入/ 指令/ 的/ 方式/ ,/ 透明/ 地/ 拦截/ 应用程序/ 申请/ 和/ 释放/ 内存/ 资源/ 的/ 函数调用/ ,/ 例如/ mal/ -/ loc/ 、/ free/ 等/ 动态内存/ 申请/ 和/ 释放/ 的/ 函数/ ,/ 或者/ Linux/ 内核/ 的/ vmalloc/ 和/ vfree/ 函数/ ,/ 维护/ 应用程序/ 所/ 使用/ 动态内存/ 资源/ 的/ 列表/ ./ 因为/ 被/ 泄露/ 的/ 内存/ 不会/ 被/ 应用程序/ 所/ 访问/ ,/ 所以/ 接下来/ 需要/ 从/ 这个/ 列表/ 中/ 推选/ 出/ 一部分/ ,/ 进行/ 访问/ 的/ 监控/ ./ 那些/ 长时间/ 不/ 被/ 释放/ 且/ 不/ 被/ 访问/ 的/ 内存/ 资源/ ,/ 则/ 是/ 很/ 好/ 的/ 内存/ 泄露/ 的/ 嫌疑/ ./ 为了/ 减少/ 监控/ 内存/ 访问/ 的/ 性能/ 损失/ ,/ 本文/ 做/ 了/ 一些/ 重要/ 的/ 优化/ ,/ 例如/ 放弃/ 对/ 热/ 页面/ 的/ 监控/ ./ 本/ 研究/ 发现/ ,/ 利用/ 虚拟化/ 技术/ 探测/ 内存/ 泄露/ 具有/ 可行性/ ./ 首先/ 是/ 在/ 线性/ ,/ 根据/ 实验/ ,/ 利用/ 虚拟机/ 管理器/ 探测/ 内存/ 泄露/ 给/ 虚拟机/ 带来/ 的/ 性能/ 损失/ 小于/ 10/ %/ ./ 测试程序/ 的/ 逻辑/ 是/ 有限/ 的/ ,/ 有些/ 内存/ 泄露/ 只有/ 在/ 真正/ 应用/ 时/ 才能/ 发现/ ./ 其次/ 是/ 有效性/ ,/ 通过/ 实验/ ,/ 在/ 公认/ 的/ 存在/ 内存/ 泄露/ 的/ 开源/ 软件/ 中/ ,/ 确实/ 能够/ 发现/ 内存/ 泄露/ 的/ 嫌疑/ ./ 另外/ 的/ 优势/ 是/ 通用性/ ,/ 该/ 方法/ 不仅/ 适用/ 于/ GNU/ // Linux/ 操作系统/ ,/ 而且/ 对/ Windows/ 也/ 适用/ ,/ 不仅/ 适用/ 于/ 用户程序/ ,/ 对/ 操作系统/ 内核/ 也/ 同样/ 适用/ ./ 最后/ 是/ 实现/ 的/ 简单/ 性/ ,/ 该/ 方法/ 不/ 需要/ 修改/ 现有/ 的/ 操作系统/ ,/ 只/ 需要/ 对/ 支撑/ 虚拟机/ 运行/ 的/ 虚拟机/ 管理器/ 进行/ 修改/ ./ 我们/ 下/ 一步/ 工作/ 是/ ,/ 在/ 虚拟机/ 之内/ 确认/ 内存/ 泄露/ 之后/ ,/ 通过/ 动态/ 代码/ 修补/ 的/ 技术/ ,/ 动态/ 修正/ 运行/ 在/ 虚拟机/ 中/ 的/ 应用程序/ ,/ 以/ 保证/ 应用程序/ 所/ 提供/ 的/ 服务/ 不会/ 中止/ ./ 

