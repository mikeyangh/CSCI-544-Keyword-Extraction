Page1/ 一种/ 基于/ 虚拟/ 基本块/ 和/ 格式化/ 标签/ 的/ 控制流/ 检测/ 方法/ 李/ 建立/ 1/ )/ ,/ 2/ )/ 谭庆平/ 1/ )/ 谭兰芳/ 1/ )/ 徐/ 建军/ 1/ )/ 1/ )/ (/ 国防科技大学/ 计算机/ 学院/ 长沙/ 410073/ )/ 2/ )/ (/ 中国/ 电子系统/ 设备/ 工程/ 公司/ 研究所/ 北京/ 100141/ )/ 摘要/ 空间/ 辐射/ 环境/ 中/ ,/ 大量/ 的/ 宇宙射线/ 经常/ 导致/ 星载/ 计算机/ 出现/ 瞬时/ 故障/ ,/ 这些/ 故障/ 的/ 主要/ 影响/ 之一/ 是/ 引发/ 程序控制/ 流/ 错误/ ./ 文中/ 提出/ 了/ 一种/ 软件/ 实现/ 的/ 控制流/ 检测/ 方法/ CFCAF/ ./ CFCAF/ 基于/ 插入/ 虚拟/ 基本块/ 后/ 的/ 控制流/ 图对/ 基本块/ 分类/ ,/ 并/ 为/ 基本块/ 设计/ 格式化/ 标签/ ,/ 然后/ 在/ 基本块/ 内/ 插装/ 标签/ 更新/ 、/ 比较/ 指令/ ,/ 实现/ 对/ 基本块/ 之间/ 、/ 基本块/ 内/ 和/ 过程/ 间/ 调用/ 的/ 控制流/ 检测/ ./ CFCAF/ 的/ 特点/ 是/ 可以/ 根据/ 可靠性/ 和/ 性能/ 的/ 需求/ 进行/ 灵活/ 配置/ ./ 对/ CFCAF/ 及/ 目前/ 有/ 代表性/ 的/ 两个/ 同类/ 算法/ 进行/ 的/ 故障注入/ 实验/ 结果表明/ ,/ CFCAF/ 算法/ 以/ 平均/ 41.7/ %/ 的/ 性能/ 代价/ 和/ 平均/ 34/ %/ 的/ 空间/ 代价/ ,/ 使/ 程序/ 的/ 平均/ 失效率/ 降到/ 了/ 5.2/ %/ ,/ 在/ 3/ 个/ 同类/ 算法/ 中/ ,/ CFCAF/ 算法/ 具有/ 较/ 低/ 的/ 时空/ 开销/ 和/ 最高/ 的/ 可靠性/ ./ 关键词/ 瞬时/ 故障/ ;/ 控制流/ 错误/ ;/ 虚拟/ 基本块/ ;/ 格式化/ 标签/ ;/ 故障注入/ 1/ 引言/ 空间/ 环境/ 中/ ,/ 大量/ 的/ 宇宙射线/ 经常/ 导致/ 星载/ 计算机/ 出现/ 瞬时/ 故障/ ./ 瞬时/ 故障/ 虽然/ 持续时间/ 很/ 短/ ,/ 但/ 却/ 有/ 可能/ 导致/ 灾难性/ 后果/ ./ 我国/ 1990/ 年/ 发射/ 的/ “/ 风云/ 一号/ ”/ 气象卫星/ 就是/ 由于/ 瞬时/ 故障/ 造成/ 了/ 姿态控制/ 系统/ 失效/ ,/ 使得/ 卫星/ 提前/ 退役/ [/ 1/ ]/ ./ 瞬时/ 故障/ 出现/ 的/ 概率/ 既/ 与/ 宇宙射线/ 的/ 强度/ 有关/ ,/ 又/ 与/ 芯片/ 晶体管/ 密度/ 、/ 门阀/ 电压/ 等/ 有关/ ./ 近年来/ 随着/ 处理器/ 逐步/ 采用/ 纳米级/ 制造/ 工艺/ ,/ 在/ 处理器/ 性能/ 得到/ 大幅度提高/ 的/ 同时/ ,/ 由于/ 集成电路/ 特征/ 尺寸/ 的/ 减少/ 、/ 晶体管/ 密度/ 的/ 增加/ 、/ 电源/ 电压/ 的/ 降低/ 和/ 频率/ 的/ 升高/ ,/ 使得/ 处理器/ 对于/ 造成/ 瞬时/ 故障/ 的/ 各种/ 噪声/ 干扰/ 变得/ 更加/ 敏感/ [/ 2/ ]/ ./ 针对/ 瞬时/ 故障/ ,/ 现有/ 的/ 故障/ 检测/ 方案/ 可/ 分为/ 硬件/ 方案/ 和/ 软件/ 方案/ ./ 其中/ 硬件/ 方案/ 主要/ 通过/ 重复/ 设置/ 硬件/ 电路/ 来/ 实现/ 检错/ ,/ 如三模/ 冗余技术/ (/ TripleModularRedundancy/ ,/ TMR/ )/ [/ 3/ ]/ ,/ 或者/ 通过/ 设置/ 专门/ 的/ 硬件/ 检错/ 电路/ 来/ 实现/ ,/ 如/ 看门狗/ 技术/ (/ Watchdog/ )/ [/ 4/ -/ 5/ ]/ ./ 传统/ 的/ 硬件/ 方案/ 需要/ 修改/ 硬件/ 体系结构/ ,/ 使/ 成本/ 和/ 开发周期/ 都/ 大大增加/ ./ 斯坦福大学/ 可靠/ 计算中心/ (/ CRC/ )/ 和/ 美国宇航局/ 喷气/ 推进/ 实验室/ (/ JPL/ )/ 合作开发/ 了/ ARGOS/ [/ 6/ -/ 7/ ]/ 项目/ ,/ 该/ 项目/ 提出/ 一种/ 软件/ 实现/ 的/ 硬件/ 故障/ 容忍/ 技术/ (/ SoftwareImplementedHardwareFaultTolerance/ ,/ SIHFT/ )/ [/ 8/ ]/ ,/ 太空/ 实验/ 的/ 结果表明/ ,/ 该/ 技术/ 利用软件/ 的/ 方法/ 使/ 基于/ 商用/ 现货/ (/ CommercialOff/ -/ The/ -/ Shelf/ ,/ COTS/ )/ 的/ 系统/ 达到/ 了/ 与/ 采用/ 硬件/ 容错/ 方案/ 的/ 抗/ 辐照/ 芯片/ 相近/ 的/ 可靠性/ ,/ 同时/ 使/ 系统/ 性能/ 提高/ 了/ 一个/ 数量级/ ./ 相比/ 硬件/ 故障/ 检测/ 技术/ ,/ 基于/ 软件/ 的/ 故障/ 检测/ 技术/ 无需/ 对/ 底层/ 硬件/ 进行/ 修改/ ,/ 可以/ 在/ 现有/ 硬件/ 基础/ 上以/ 尽可能/ 低/ 的/ 成本/ 提高/ 其/ 可靠性/ ,/ 而且/ 还/ 具有/ 低功耗/ 、/ 可/ 灵活/ 配置/ 等/ 优点/ ./ 计算机/ 程序运行/ 是/ 构成/ 程序/ 的/ 指令/ 序列/ 按照/ 预定/ 顺序/ 执行/ 的/ 过程/ ,/ 其中/ 正确/ 的/ 执行/ 顺序/ 即/ 控制流/ 是/ 程序/ 正确/ 执行/ 的/ 基础/ ,/ 如果/ 控制流/ 出现/ 错误/ ,/ 则/ 程序/ 很/ 可能/ 得到/ 错误/ 的/ 结果/ ./ 发生/ 在/ 程序/ 计数器/ (/ PC/ )/ 、/ 存储空间/ 、/ 地址/ 计算/ 单元/ 等/ 位置/ 的/ 瞬时/ 故障/ 可能/ 导致/ 跳转/ 指令/ 的/ 跳转/ 目标/ 错误/ ,/ 还/ 可能/ 破坏/ 指令/ 操作码/ ,/ 将/ 非/ 跳转/ 指令/ 修改/ 为/ 跳转/ 指令/ 或者/ 将/ 跳转/ 指令/ 修改/ 为/ 非/ 跳转/ 指令/ ./ 现有/ 的/ 针对/ 控制流/ 错误/ 的/ 软件/ 检测/ 技术/ 大多/ 是/ 采用/ 标签/ 分析/ 的/ 方法/ ,/ 其/ 基本原理/ 是/ :/ 在/ 编译/ 时/ 将/ 程序/ 划分/ 为/ 基本块/ ,/ 并/ 为/ 每个/ 基本块/ 分配/ 不同/ 的/ 静态/ 标签/ ,/ 程序运行/ 时/ 根据/ 当前/ 控制流/ 计算/ 出/ 一个/ 动态/ 标签/ ,/ 通过/ 比较/ 动态/ 标签/ 和/ 静态/ 标签/ 是否/ 一致/ 来/ 确定/ 控制流/ 是否/ 出错/ ./ 基于/ 标签/ 分析/ 的/ 控制流/ 检测/ 方法/ 在/ 程序/ 内部/ 插装/ 少量/ 的/ 指令/ ,/ 可以/ 检测/ 出/ 绝大部分/ 的/ 控制流/ 错误/ ./ 文献/ [/ 9/ ]/ 中/ 提出/ 的/ CFCSS/ 算法/ 是/ 采用/ 标签/ 分析方法/ 的/ 典型/ 算法/ ./ CFCSS/ 只/ 需/ 在/ 编译/ 时为/ 基本块/ 分配/ 静态/ 标签/ 和/ 标签/ 差量/ ,/ 然后/ 在/ 基本块/ 首部/ 插入/ 少量/ 检测/ 指令/ 即可/ 检测/ 控制流/ 错误/ ,/ 但/ 算法/ 存在/ 不少/ 检测/ 盲点/ :/ 由于/ CFCSS/ 算法/ 只/ 在/ 每个/ 基本块/ 首部/ 插入/ 检测/ 指令/ ,/ 所以/ 算法/ 无法/ 检测/ 出/ 从/ 一个/ 基本块/ 内部/ 到/ 下/ 一个/ 基本块/ 首部/ 的/ 错误/ 跳转/ ;/ 另外/ ,/ 控制流/ 错误/ 不仅/ 可能/ 表现/ 为/ 基本块/ 之间/ 的/ 控制流/ 错误/ ,/ 也/ 可能/ 表现/ 为/ 基本块/ 内/ 和/ 过程/ 间/ 调用/ 的/ 控制流/ 错误/ ,/ CFCSS/ 算法/ 只能/ 检测/ 出/ 基本块/ 之间/ 的/ 控制流/ 错误/ ./ 文献/ [/ 10/ ]/ 中/ 提出/ 的/ RSCFC/ 算法/ 是/ 基于/ 标签/ 分析/ 的/ 另/ 一个/ 典型/ 算法/ ./ RSCFC/ 首先/ 设计/ 了/ 一种/ 特殊/ 格式/ 的/ 关系/ 标签/ ,/ 并/ 将/ 基本块/ 间/ 的/ 控制流/ 关系/ 编码/ 进/ 了/ 关系/ 标签/ 中/ ,/ 然后/ 在/ 基本块/ 的/ 首部/ 和/ 尾部/ 分别/ 插装/ 标签/ 的/ 更新/ 、/ 比较/ 指令/ ./ RSCFC/ 算法/ 相比/ CFCSS/ 算法/ 明显提高/ 了/ 故障/ 检测/ 率/ ,/ 但是/ 算法/ 插装/ 的/ 指令/ 较/ 多/ ,/ 性能/ 开销/ 较大/ ./ 另外/ ,/ RSCFC/ 算法/ 用/ 标签/ 中/ 的/ 1/ 位/ 对应/ 表示/ 1/ 个/ 基本块/ ,/ 标签/ 能够/ 表示/ 的/ 块/ 数/ 受限于/ 机器/ 字长/ ,/ 在/ 32/ 位/ 体系结构/ 下/ ,/ RSCFC/ 算法/ 的/ 关系/ 标签/ 仅能/ 表示/ 31/ 个/ 基本块/ (/ 有/ 1/ 位/ 被/ 算法/ 保留/ 使用/ )/ ./ 尽管/ RSCFC/ 可以/ 在/ 基本块/ 数/ 大于/ 31/ 时/ 将/ 基本块/ 分组/ ,/ 然后/ 在/ 组间/ 和/ 组内/ 嵌套/ 应用/ 算法/ 检测/ 机制/ ,/ 但/ 这/ 无疑/ 会/ 使/ 算法/ 的/ 性能/ 代价/ 增加/ 很多/ ./ 其他/ 控制流/ 检测/ 算法/ [/ 11/ -/ 16/ ]/ 的/ 基本原理/ 与/ CFCSS/ 或/ RSCFC/ 相似/ ,/ 不同/ 算法/ 的/ 区别/ 主要/ 体现/ 在/ 标签/ 设计/ 和/ 插装/ 的/ 指令/ ./ 而且/ 总体/ 上/ 来说/ ,/ 这些/ 控制流/ 检测/ 算法/ 都/ 存在/ 性能/ 和/ 可靠性/ 平衡/ 问题/ ./ 我们/ 此前/ 基于/ 改进/ RSCFC/ 算法/ 提出/ 了/ ECCFS/ [/ 17/ ]/ 算法/ ,/ 该/ 算法/ 基于/ 基本块/ 分类/ 设计/ 格式化/ 标签/ ,/ 使/ 标签/ 所/ 能/ 表示/ 的/ 基本块/ 数目/ 比/ RSCFC/ 有/ 明显/ 增多/ ,/ 算法/ 的/ 检测/ 能力/ 也/ 有所提高/ ./ 但是/ ECCFS/ 在/ 程序/ 基本块/ 分类/ 较多时/ ,/ 标签/ 表达能力/ 有/ 明显降低/ ,/ 算法/ 的/ 性能/ 也/ 需要/ 进一步提高/ ./ 为了/ 克服/ 已有/ 算法/ 的/ 不足/ ,/ 以较/ 低/ 的/ 性能/ 代价/ 获得/ 更好/ 的/ 故障/ 检测/ 能力/ ,/ 本文/ 提出/ 了/ 一种/ 基于/ 虚拟/ 基本块/ 和/ 格式化/ 标签/ 的/ 控制流/ 检测/ 算法/ CFCAF/ (/ ControlFlowCheckingbasedonAbstractbasicblockandFormattedsignature/ )/ ./ 首先/ 通过/ 在/ 控制流/ 图中/ 插入/ 虚拟/ 基本块/ ,/ 并/ 基于/ 新/ 的/ 控制流/ 图为/ 基本块/ 设计/ 格式化/ 标签/ ,/ CFCAF/ 有效/ 解决/ 了/ RSCFC/ 标签/ 表达能力/ 弱/ 的/ 问题/ ./ 然后/ 通过/ 在/ 基本块/ 内/ 插装/ 标签/ 检测/ 指令/ ,/ CFCAF/ 以较/ 小/ 的/ 时空/ 开销/ 实现/ 了/ 对/ 基本块/ 之间/ 、/ 基本块/ 内/ 和/ 过程/ 间/ 调用/ 的/ 控制流/ 检测/ ./ CFCAF/ 的/ 实现/ 还是/ 可/ 配置/ 的/ ,/ 用户/ 可根/ Page3/ 据/ 性能/ 和/ 可靠性/ 的/ 需求/ 灵活/ 调节/ ./ 本文/ 第/ 2/ 节/ 详细/ 介绍/ CFCAF/ 算法/ 的/ 设计/ ,/ 包括/ 基于/ 基本块/ 分类/ 的/ 标签/ 设计/ 、/ 基本块/ 间/ 的/ 控制流/ 检测/ 、/ 基本块/ 内及/ 过程/ 间/ 的/ 控制流/ 检测/ ;/ 第/ 3/ 节对/ CFCAF/ 的/ 故障/ 检测/ 能力/ 进行/ 分析/ ;/ 第/ 4/ 节/ 研究/ CFCAF/ 在/ RISC/ 平台/ 下/ 的/ 实现/ 优化/ 方法/ ;/ 故障注入/ 实验/ 的/ 结果/ 及/ 比较/ 分析/ 则/ 在/ 第/ 5/ 节/ 给出/ ;/ 最后/ 在/ 第/ 6/ 节/ 总结/ 本文/ 工作/ ./ 2CFCAF/ 算法/ 2.1/ 基于/ 基本块/ 分类/ 的/ 标签/ 设计/ 基本块/ 的/ 定义/ 为/ :/ 程序/ 中/ 能够/ 顺序/ 执行/ 的/ 指令/ 序列/ 的/ 最大/ 集合/ ,/ 这组/ 指令/ 只有/ 一个/ 入口/ 和/ 一个/ 出口/ ,/ 入口/ 就是/ 第一条/ 指令/ ,/ 出口/ 就是/ 最后/ 一条/ 指令/ ./ 基本块/ 中/ 除了/ 最后/ 一条/ 指令/ 可能/ 是/ 转移/ 指令/ 外/ ,/ 其他/ 指令/ 都/ 不能/ 是/ 转移/ 指令/ ./ 用/ V/ =/ {/ v1/ ,/ v2/ ,/ …/ ,/ vn/ }/ 表示/ 基本块/ 的/ 集合/ ,/ 用/ E/ =/ {/ brij/ |/ brij/ 代表/ 从/ 结点/ vi/ 到/ 结点/ vj/ 的/ 跳转/ }/ 表示/ 基本块/ 间/ 跳转/ 关系/ 的/ 集合/ ./ 这样/ ,/ 一个/ 程序/ 就/ 可以/ 用/ 一个/ 控制流/ 图/ P/ =/ {/ V/ ,/ E/ }/ 表示/ ./ 如图/ 1/ 所示/ 为/ 一个/ 指令/ 序列/ 及其/ 控制流/ 图/ ./ 在/ 一个/ 控制流/ 图中/ ,/ 若边/ 集/ E/ 中/ 存在/ 一条/ 从/ 结点/ v1/ 到/ v/ 的/ 边/ ,/ 则/ 称/ 结点/ v1/ 为/ 结点/ v/ 的/ 前驱/ 结点/ ./ 若/ 集合/ E/ 中/ 存在/ 一条/ 从/ 结点/ v/ 到/ v2/ 的/ 边/ ,/ 则/ 称/ 结点/ v2/ 为/ 结点/ v/ 的/ 后继/ 结点/ ,/ 并且/ 若/ v2/ 的/ 存储空间/ 同时/ 紧接在/ v/ 后面/ ,/ 则/ 称/ 结点/ v2/ 为/ 结点/ v/ 的/ 直接/ 后继/ 结点/ ,/ 而/ 结点/ v/ 为/ v2/ 的/ 直接/ 前驱/ 结点/ ./ 若/ 程序/ 沿着/ brij/ 表示/ 的/ 控制流/ 方向/ 执行/ ,/ 但/ brij/ 图/ 2/ 基本块/ 分类/ 示例/ 为了/ 分析/ 基本块/ 的/ 这种/ 分类/ 冲突/ 关系/ ,/ 需要/ 基于/ 控制流/ 图/ 导出/ 冲突/ 图/ [/ 17/ ]/ :/ 冲突/ 图是/ 无/ 向/ 图/ ,/ 冲突/ 图中/ 的/ 结点/ 和/ 控制流/ 图/ 相同/ ,/ 若/ 两个/ 结点/ 在/ 控制流/ 图中/ 有/ 共同/ 的/ 前驱/ 结点/ ,/ 则/ 这/ 两个/ 结点/ 在/ 冲突/ 图中/ 有/ 一条/ 边/ 连接/ ./ 图/ 3/ (/ a/ )/ 即/ 为/ 图/ 2/ (/ a/ )/ 中/ 控制流/ 图/ 对应/ 的/ 冲突/ 图/ ./ 冲突/ 图中/ 的/ 边/ 代表/ 了/ 基本块/ 分类/ 时/ 的/ 互斥/ 关系/ ,/ 即/ 一条/ 边/ 连接/ 的/ 两个/ 结点/ 不能/ 分为/ 同/ 一类/ ./ 可以/ 直观/ 地/ 认为/ ,/ 如果/ 冲突/ 图中/ 不/ 含/ 3/ 阶/ 完全/ 子图/ ,/ 则/ 可/ 基于/ 冲突/ 图/ 将/ 基本块/ 分为/ 两类/ ,/ 否则/ 就/ 会/ 出现/ 并/ 不/ 在/ 边集/ E/ 中/ ,/ 则/ 说明/ 程序运行/ 发生/ 了/ 控制流/ 错误/ ,/ brij/ 是/ 非法/ 跳转/ ./ 由/ 程序/ 汇编/ 代码生成/ 的/ 控制流/ 图中/ :/ 若/ 一个/ 基本块/ B/ 最后/ 一条/ 指令/ 是/ 无条件/ 跳转/ 指令/ 或者/ 不是/ 跳转/ 指令/ ,/ 则/ B/ 只有/ 一个/ 后继/ 结点/ ;/ 若/ B/ 最后/ 一条/ 指令/ 是/ 条件/ 跳转/ 指令/ ,/ 则/ B/ 有/ 两个/ 后继/ 结点/ ,/ 且/ 其中/ 一个/ 是/ 其/ 直接/ 后继/ 结点/ ./ 所以/ 在/ 程序/ 不/ 存在/ 过程/ 调用/ 的/ 前提/ 下/ (/ 程序/ 存在/ 过程/ 调用/ 的/ 情形/ 将/ 在/ 2.4/ 节/ 讨论/ )/ ,/ 每个/ 基本块/ 最多/ 有/ 两个/ 后继/ 结点/ ./ 因此/ 可以/ 根据/ 基本块/ 间/ 的/ 前驱/ 后继/ 关系/ 将/ 基本块/ 分为/ 两类/ ,/ 即将/ 拥有/ 共同/ 前驱/ 结点/ 的/ 后继/ 结点/ 分为/ 不同/ 的/ 类别/ ./ 但是/ 在/ 一些/ 特殊/ 情形/ 下/ ,/ 无法/ 直接/ 将/ 基本块/ 分为/ 两类/ ./ 如图/ 2/ (/ a/ )/ 所示/ ,/ v4/ 和/ v5/ 有/ 共同/ 的/ 前驱/ 结点/ v1/ ,/ v5/ 和/ v6/ 有/ 共同/ 的/ 前驱/ 结点/ v2/ ,/ 因此/ 可以/ 将/ v4/ 、/ v5/ 和/ v6/ 分别/ 归为/ 1/ 类/ 、/ 2/ 类/ 和/ 1/ 类/ ,/ 但是/ v4/ 和/ v6/ 又/ 有/ 共同/ 的/ 前驱/ 结点/ v3/ ,/ 此时/ v4/ 和/ v6/ 的/ 分类/ 出现/ 了/ 冲突/ ./ 分类/ 冲突/ ./ 定义/ 不/ 含/ 任何/ 指令/ 的/ 空/ 基本块/ 为/ 虚拟/ 基本块/ ./ CFCAF/ 针对/ 冲突/ 图中/ 的/ 3/ 阶/ 完全/ 子图/ ,/ 任取/ 其中/ 一个/ 结点/ ,/ 并/ 在/ 该/ 结点/ 和/ 其/ 直接/ 前驱/ 结点/ 之间/ 插入/ 虚拟/ 基本块/ ,/ 对/ 加入/ 虚拟/ 基本块/ 后/ 的/ 程序/ 分析/ 可以/ 得到/ 新/ 的/ 控制流/ 图/ ,/ 而/ 新/ 的/ 控制流/ 图中/ 的/ 结点/ 即可/ 分为/ 两类/ ./ 如图/ 2/ (/ b/ )/ 所示/ ,/ 假设/ v4/ 的/ 直接/ 前驱/ 结点/ 是/ v1/ ,/ 则/ 可以/ 在/ v1/ 和/ v4/ 之间/ 插入/ 一个/ 虚拟/ 基本块/ vabb/ ,/ 得到/ 新/ 的/ 控制流/ 图/ ./ 基于/ 新/ 控制流/ 图/ 的/ 冲突/ 图如/ Page4/ 图/ 3/ 冲突/ 图/ 示例/ 图/ 3/ (/ b/ )/ 所示/ ,/ 通过/ 插入/ 一个/ 虚拟/ 基本块/ vabb/ 消除/ 了/ 3/ 阶/ 完全/ 子图/ ./ 基于/ 新/ 的/ 冲突/ 图/ 的/ 标签/ 分类/ 结果/ 如图/ 2/ (/ b/ )/ 中/ 所示/ ./ CFCAF/ 分别/ 为/ 1/ 类/ 和/ 2/ 类/ 结点/ 分配/ 不同/ 格式/ 的/ 静态/ 标签/ Sl/ 和/ Sh/ ./ 静态/ 标签/ 是/ 每个/ 基本块/ 的/ 唯一/ 标识/ ./ 在/ 32/ 位/ 体系结构/ 下/ ,/ 标签/ Sl/ 和/ Sh/ 均/ 设计/ 为/ 16/ 位/ ,/ 其中/ 高/ k/ 位为/ 保留/ 位/ (/ 2/ / k/ </ 16/ )/ ,/ 且/ 保留/ 位/ 的/ 最高/ 位均/ 固定/ 为/ 0/ ,/ Sl/ 的/ 保留/ 位/ 最低/ 位为/ 0/ ,/ Sh/ 的/ 保留/ 位/ 最低/ 位为/ 1/ ./ 保留/ 位/ 的/ 数据/ 取决于/ 检测/ 机制/ 的/ 需要/ 和/ k/ 的/ 取值/ ,/ 我们/ 以/ k/ 值取/ 2/ 为例/ 说明/ 标签/ 设计/ 和/ 算法/ 的/ 原理/ ./ 根据/ 如图/ 4/ 所示/ 的/ 格式/ 设计/ ,/ 当/ k/ 值取/ 2/ 时/ 保留/ 位/ Sk/ 为/ 二进制码/ 00/ ,/ Sk/ 为/ 二进制码/ 01/ ./ CFCAF/ 还要/ 为/ 每个/ 基本块/ 分配/ 一个/ 路由/ 关系/ 标签/ L/ ,/ 保存/ 其/ 后继/ 基本块/ 的/ 信息/ ./ 如图/ 4/ (/ c/ )/ 所示/ ,/ L/ 标签/ 低/ 16/ 位是/ 1/ 类/ 后继/ 基本块/ 的/ 静态/ 标签/ Sl/ ,/ 高/ 16/ 位是/ 2/ 类/ 后继/ 基本块/ 的/ 静态/ 标签/ Sh/ ,/ 因为/ 程序/ 的/ 基本块/ 被/ 分为/ 两类/ ,/ 所以/ 程序/ 的/ 控制流/ 信息/ 都/ 可以/ 嵌入/ 到/ L/ 标签/ 中/ ./ 按照/ 图/ 2/ (/ b/ )/ 中/ 的/ 基本块/ 分类/ ,/ 若/ 保留/ 位数/ k/ =/ 2/ ,/ 静态/ 标签/ Sabb/ 、/ S4/ 、/ S5/ 、/ S6/ 可/ 分别/ 设计/ 为/ 十六进制/ 码/ 0x4007/ 、/ 0x4/ 、/ 0x5/ 、/ 0x4006/ ,/ 则/ v1/ 的/ L/ 标签/ 为/ 0x40070005/ ,/ v2/ 的/ L/ 标签/ 为/ 0x40060005/ ,/ v3/ 图/ 5/ 基本块/ 间/ 控制流/ 检测/ 示例/ 的/ L/ 标签/ 为/ 0x40060004/ ,/ 虚拟/ 基本块/ vabb/ 只有/ 一个/ 1/ 类/ 后继/ 基本块/ ,/ 所以/ 其/ L/ 标签/ 为/ 0x4/ ./ RSCFC/ 算法/ 在/ 32/ 位/ 体系结构/ 下/ ,/ 其/ 标签/ 只能/ 表示/ 31/ 个/ 基本块/ ./ 而/ CFCAF/ 的/ 标签/ 在/ 保留/ 位数/ k/ =/ 2/ 时则/ 可以/ 表示/ (/ 215/ -/ 1/ )/ 个/ 基本块/ ,/ 可以/ 满足/ 大部分/ 应用/ 的/ 需要/ ./ 对于/ 少数/ 超出/ 标签/ 表达能力/ 的/ 程序/ ,/ 可以/ 将/ 程序/ 的/ 基本块/ 分为/ 不同/ 的/ 区域/ ,/ 为/ 每个/ 区域/ 分配/ 区域/ 码后/ ,/ 在/ 区域/ 首部/ 向/ 特定/ 存储空间/ 写入/ 区域/ 码/ ,/ 然后/ 在/ 区域/ 尾部/ 取出/ 该/ 数据/ 和/ 预定/ 的/ 区域/ 码/ 比较/ ,/ 即可/ 实现/ 区域间/ 的/ 控制流/ 检测/ ,/ 在/ 区域/ 内部/ 则/ 可以/ 嵌套/ 应用/ CFCAF/ 方法/ ./ 2.2/ 基本块/ 间/ 的/ 控制流/ 检测/ CFCAF/ 使用/ 通用寄存器/ G/ 和/ P/ 专门/ 保存/ 动态/ 标签/ 和/ 路由/ 关系/ 标签/ ,/ 并/ 利用/ 插装/ 到/ 每个/ 基本块/ 的/ 标签/ 更新/ 指令/ 不断/ 地/ 更新/ 动态/ 标签/ ,/ 然后/ 利用/ 每个/ 基本块/ 中/ 插装/ 的/ 比较/ 检测/ 指令/ 判断/ 动态/ 标签/ 是否/ 和/ 当前/ 基本块/ 的/ 静态/ 标签/ 相同/ ,/ 如果/ 相同/ 则/ 认为/ 程序控制/ 流/ 正常/ ,/ 程序/ 继续执行/ ,/ 否则/ 认定/ 程序控制/ 流/ 遭到/ 破坏/ ,/ 跳转/ 到/ 错误/ 处理程序/ ./ 对图/ 2/ (/ b/ )/ 中/ 的/ 部分/ 基本块/ 插装/ 指令/ 后/ 的/ 结果/ 如图/ 5/ 所示/ ,/ 指令/ #/ 1/ 、/ #/ 2/ 被/ 插入/ 到/ 基本块/ 首部/ ,/ 指令/ #/ 3/ 、/ #/ 4/ 被/ 插入/ 到/ 基本块/ 尾部/ ,/ 如果/ 基本块/ 最后/ 一条/ 指令/ 是/ 跳转/ 指令/ ,/ 那么/ 指令/ #/ 1/ 、/ #/ 2/ 、/ #/ 3/ 、/ #/ 4/ 还要/ 插/ 在/ 跳转/ 指令/ 之前/ ,/ 图中/ 基本块/ 尾部/ 的/ 虚/ 线框/ 表示/ 基本块/ 最后/ 一条/ 指令/ 可能/ 是/ 跳转/ 指令/ ./ Page5/ 指令/ #/ 1/ 和/ #/ 2/ 是/ 动态/ 标签/ 更新/ 指令/ ,/ 在/ 程序/ 正确/ 执行/ 时/ ,/ 可以/ 将/ G/ 中/ 的/ 数据/ 更新/ 为/ 当前/ 块/ 的/ 静态/ 标签/ ./ 指令/ #/ 1/ 通过/ 和/ 掩码/ 0xffff/ 进行/ 按位/ 与/ 操作/ 取出/ 存放/ 在/ P/ 中低/ 16/ 位/ 的/ 静态/ 标签/ ,/ 指令/ #/ 2/ 则/ 通过/ 逻辑/ 右移/ 16/ 位/ 取出/ 存放/ 在/ P/ 中/ 的/ 高/ 16/ 位/ 静态/ 标签/ ,/ 所以/ 指令/ #/ 1/ 和/ #/ 2/ 要/ 分别/ 插入/ 到/ 1/ 类块/ 和/ 2/ 类块/ 的/ 首部/ ./ 指令/ #/ 3/ 将/ P/ 中/ 的/ 值/ 更新/ 为/ 当前/ 块/ 的/ 路由/ 关系/ 标签/ ./ 指令/ #/ 4/ 比较/ 动态/ 标签/ 是否/ 和/ 当前/ 块/ 的/ 静态/ 标签/ 相同/ ,/ 如果/ 相同/ 则/ 程序/ 继续/ 往/ 下/ 执行/ ,/ 否则/ 跳转/ 到/ 错误/ 处理程序/ ./ 图/ 5/ 中/ G/ 和/ P/ 的/ 初始值/ 分别/ 是/ 0/ 和/ 0x1/ ,/ 基本块/ v1/ 执行/ 结束/ 后/ ,/ G/ 和/ P/ 的/ 值/ 分别/ 被/ 更新/ 为/ 0x1/ 和/ 0x40070005/ ./ 如果/ v1/ 沿着/ 合法/ 跳转/ 1/ 继续执行/ ,/ 则/ 在/ v5/ 首部/ G/ 被/ 更新/ 为/ 0x5/ ,/ 指令/ #/ 4/ 判断/ 出/ G/ 的/ 值/ 和/ v5/ 的/ 静态/ 标签/ 相同/ ,/ 因此/ 可以/ 确认/ 程序/ 跳转/ 正确/ ;/ 如果/ v1/ 沿着/ 非法/ 跳转/ 2/ 执行/ ,/ 则/ 在/ v4/ 首部/ G/ 被/ 更新/ 为/ 0x5/ ,/ 指令/ #/ 4/ 判断/ 出/ G/ 的/ 值/ 和/ v4/ 的/ 静态/ 标签/ 不同/ ,/ 因此/ 可以/ 确认/ 程序/ 跳转/ 错误/ ./ 2.3/ 基本块/ 内/ 的/ 控制流/ 检测/ 所谓/ 基本块/ 内/ 的/ 控制流/ 错误/ 是/ 指/ 在/ 同一个/ 基本块/ 内部/ ,/ 控制流/ 从/ 一条/ 指令/ 跳到/ 另/ 一条/ 指令/ ./ 出现/ 这种/ 现象/ 的/ 主要/ 原因/ 是/ PC/ 寄存器/ 遭到/ 破坏/ ,/ 或者/ 指令/ 操作码/ 遭到/ 修改/ ,/ 使得/ 普通/ 指令/ 变成/ 了/ 跳转/ 指令/ ./ 一般/ 情况/ 下/ ,/ 程序/ 出现/ 这种/ 错误/ 的/ 概率/ 很小/ ,/ 但/ 对于/ 一些/ 数据处理/ 程序/ (/ 如/ 矩阵/ 乘法/ )/ ,/ 程序/ 内部/ 的/ 部分/ 基本块/ 可能/ 包含/ 很多/ 条/ 指令/ ,/ 对/ 这种/ 程序/ 进行/ 基本块/ 内/ 控制流/ 检测/ 就/ 十分必要/ ./ 目前/ 能够/ 检测/ 基本块/ 内/ 控制流/ 错误/ 的/ 算法/ 不多/ ./ 文献/ [/ 18/ ]/ 中/ 引入/ 了/ 一个/ 局部/ 标签/ ,/ 并/ 在/ 基本块/ 内部/ 插入/ 一些/ 针对/ 局部/ 标签/ 的/ 加法/ 操作/ ,/ 最后/ 进行/ 比较/ 检测/ ./ 不/ 发生/ 块/ 内/ 控制流/ 错误/ 的/ 情况/ 下/ ,/ 局部/ 标签/ 累加/ 的/ 结果/ 应该/ 为/ 0/ ,/ 否则/ 可以/ 断定/ 存在/ 块/ 内/ 控制流/ 错误/ ./ 这种/ 方法/ 加强/ 了/ 对/ 块/ 内/ 控制流/ 的/ 检测/ ,/ 但/ 插入/ 的/ 指令/ 较/ 多/ ,/ 并且/ 需要/ 专用/ 一个/ 寄存器/ 保存/ 局部/ 标签/ ,/ 这/ 就/ 意味着/ 更/ 高/ 的/ 存储/ 开销/ 和/ 性能/ 开销/ ./ CFCAF/ 结合/ 我们/ 此前/ 在/ 文献/ [/ 19/ ]/ 中/ 提出/ 的/ 方法/ ,/ 以/ 更/ 低/ 的/ 性能/ 代价/ 实现/ 了/ 块/ 内/ 控制流/ 检测/ ./ 为了/ 实现/ 块/ 内/ 控制流/ 检测/ ,/ CFCAF/ 需要/ 为/ 1/ 类/ 和/ 2/ 类/ 基本块/ 新/ 分配/ 一个/ 入口/ 标签/ Sl/ 和/ Sh/ ,/ 除了/ 保留/ 位外/ ,/ 入口/ 标签/ 的/ 其他/ 位/ 和/ 同一/ 基本块/ 的/ 静态/ 标签/ 相同/ ./ 新/ 的/ 基本块/ 路由/ 关系/ 标签/ L/ 中则/ 嵌入/ 后继/ 基本块/ 的/ 入口/ 标签/ ./ 入口/ 标签/ 的/ 保留/ 位/ 设计/ 和/ k/ 的/ 取值/ 有关/ ,/ 我们/ 以/ k/ 取/ 2/ 为例/ 说明/ 标签/ 设计/ 和/ 块/ 内/ 控制流/ 检测/ 的/ 原理/ ./ 如图/ 6/ 所示/ ,/ Sl/ 的/ 保留/ 位/ 设计/ 为/ 二进制码/ 11/ ,/ Sh/ 的/ 保留/ 位/ 设计/ 为/ 二进制码/ 10/ ./ 如图/ 7/ 所示/ ,/ 基于/ 新/ 分配/ 的/ 标签/ ,/ CFCAF/ 在/ 基本块/ 中部/ 新/ 插入/ 指令/ #/ 5/ 、/ #/ 6/ ,/ 指令/ #/ 5/ 利用/ 异或/ 操作/ 将/ G/ 的/ 最高/ 两位/ 取反/ ,/ 指令/ #/ 6/ 通过/ 减法/ 操作/ 将/ 最高/ 两位/ 数值/ 减去/ 1/ ./ 而/ 指令/ #/ 3/ 则/ 修改/ 为/ 将/ 新/ 的/ 路由/ 关系/ 标签/ L/ 存入/ P/ 中/ ./ 基于/ 这些/ 指令/ ,/ 当/ 基本块/ 内/ 控制流/ 正常/ 时/ ,/ 指令/ #/ 1/ 或/ #/ 2/ 将/ 动态/ 标签/ G/ 更新/ 为/ 当前/ 块/ 的/ 入口/ 标签/ ,/ 基本块/ 中部/ 的/ 指令/ #/ 5/ 或/ 指令/ #/ 6/ 则/ 通过/ 修改/ 保留/ 位/ 将/ G/ 值/ 修改/ 为/ 当前/ 块/ 的/ 静态/ 标签/ ,/ 最后/ 指令/ #/ 3/ 和/ #/ 4/ 更新/ 路由/ 关系/ 标签/ ,/ 并/ 将/ G/ 和/ 静态/ 标签/ 比较/ ,/ 从而/ 判断/ 出/ 不/ 存在/ 块/ 内/ 和/ 块/ 间/ 控制流/ 错误/ ./ 当/ 发生/ 跳过/ #/ 5/ 或/ #/ 6/ 的/ 块/ 内/ 控制流/ 错误/ 后/ ,/ 动态/ 标签/ 在/ 基本块/ 尾部/ 的/ 值/ 仍/ 为/ 入口/ 标签/ ,/ 因此/ 可以/ 通过/ 比较/ 判断/ 出/ 控制流/ 错误/ ./ CFCAF/ 在/ 基本块/ 间/ 控制流/ 检测/ 的/ 基础/ 上/ ,/ 通过/ 在/ 标签/ 中/ 保留/ 一些/ 位/ 和/ 在/ 基本块/ 中部/ 插入/ 一些/ 指令/ 即可/ 实现/ 块/ 内/ 控制流/ 检测/ ,/ 这种/ 检测/ 机制/ 不/ 需要/ 额外/ 占用/ 寄存器/ 和/ 插装/ 较/ 多/ 的/ 指令/ ,/ 因此/ 其/ 需要/ 的/ 时空/ 开销/ 比较/ 小/ ./ 另外/ ,/ 这种/ 方法/ 还/ 可以/ 根据/ 性能/ 和/ 可靠性/ 的/ 需要/ 灵活/ 配置/ ./ 首先/ 可以/ 通过/ 设置/ 保留/ 位数/ k/ ,/ 控制/ 可以/ 插入/ 到/ 基本块/ 中部/ 的/ 最大/ 指令/ 数量/ ,/ 进一步/ 增强/ 算法/ 对块/ 内/ 控制流/ 的/ 检测/ 能力/ ,/ 例如/ k/ =/ 3/ 时/ ,/ 可以/ 设置/ 1/ 、/ 2/ 类块/ 的/ 静态/ 标签/ 保留/ 位/ 分别/ 是/ 二进制码/ 010/ 和/ 011/ ,/ 设置/ 1/ 、/ 2/ 类块/ 的/ 入口/ 标签/ 保留/ 位/ 分别/ 是/ 二进制码/ 000/ 和/ 101/ ,/ 并/ 在/ 1/ 类块/ 中部/ 等/ 间距/ 插入/ 两条/ 加法/ 指令/ ,/ 每条/ 指令/ 将/ 保留/ 位加/ 1/ ,/ 在/ 2/ 类块/ 中部/ 等/ 距离/ 插入/ 两条/ 减法/ 指令/ ,/ 每条/ 指令/ 将/ 保留/ 位减/ 1/ ,/ 这样/ 即可/ 加强/ 对块/ 内/ 控制流/ 的/ 检测/ ;/ 另外/ 在/ k/ 值/ 确定/ 的/ 情况/ 下/ ,/ 根据/ 基本块/ 的/ 大小/ 不同/ ,/ 还/ 可以/ 灵活/ 选择/ 在/ 基本块/ 中部/ 插入/ 的/ 指令/ 数量/ ,/ 例如/ 在/ 上述/ k/ =/ 3/ 的/ 情况/ 下/ ,/ 可以/ 将/ 1/ 类块/ 中部/ 的/ 两条/ 减/ 1/ 指令/ 合并/ 为/ 一条/ 减/ 2/ 指令/ ;/ 如果/ 一个/ 基本块/ Page6/ 不/ 需要/ 块/ 内/ 控制流/ 检测/ ,/ 则/ 可以/ 选择/ 不/ 实现/ 块/ 内/ 检测/ 机制/ ,/ 此种/ 情况/ 下/ 只/ 需/ 将/ 其/ 静态/ 标签/ 而/ 不是/ 入口/ 标签/ 嵌入/ 其/ 前驱/ 块/ 的/ 路由/ 关系/ 标签/ 中/ 即可/ ./ 2.4/ 过程/ 间/ 的/ 控制流/ 检测/ 过程/ 间/ 的/ 控制流/ 检测/ 问题/ 较/ 基本块/ 之间/ 的/ 控制流/ 检测/ 更为/ 复杂/ ,/ 现有/ 的/ 大多数/ 控制流/ 检测/ 算法/ 并/ 不/ 将/ 过程/ 间/ 调用/ 作为/ 划分/ 基本块/ 的/ 依据/ ,/ 实际上/ 是/ 忽略/ 了/ 这个/ 问题/ ./ 少数/ 控制流/ 检测/ 算法/ 虽然/ 实现/ 了/ 过程/ 间/ 的/ 控制流/ 检测/ ,/ 但/ 存在/ 不少/ 漏洞/ ,/ 例如/ 文献/ [/ 16/ ]/ 中/ 提出/ 的/ SIED/ 算法/ 在/ 被/ 调用函数/ 头部/ 设置/ 一个/ 函数/ 标签/ ,/ 然后/ 在/ 函数/ 返回/ 后/ 通过/ 比较/ 标签/ 是否/ 一致/ 判断/ 是否/ 存在/ 过程/ 间/ 调用/ 错误/ ./ 但是/ ,/ 当对/ 一个/ 函数/ 存在/ 多次/ 调用/ 时/ ,/ 如果/ 函数/ 返回/ 点/ 出现/ 了/ 混淆/ ,/ 算法/ 则/ 无法/ 检测/ 出/ 错误/ ./ CFCAF/ 算法/ 通过/ 改进/ 基本块/ 分类/ 方法/ 和/ 插装/ 部分/ 新/ 指令/ ,/ 可以/ 有效/ 地/ 检测/ 过程/ 间/ 的/ 控制流/ ./ CFCAF/ 将/ 函数调用/ 也/ 作为/ 划分/ 基本块/ 的/ 依据/ ,/ 并且/ 所有/ 的/ 基本块/ 一起/ 分配/ 标签/ ./ 由于/ 一个/ 函数/ 可能/ 被/ 多次/ 调用/ ,/ 所以/ 函数/ 返回/ 指令/ 所在/ 的/ 块/ 可能/ 会/ 有/ 多个/ 后继/ 基本块/ ./ 因此/ 在/ 进行/ 2.1/ 节/ 的/ 基本块/ 分类/ 时/ ,/ 需要/ 先/ 将/ 控制流/ 图中/ 代表/ 函数/ 返回/ 的/ 边/ 屏蔽/ ,/ 即/ 不/ 考虑/ 函数/ 的/ 返回/ 关系/ ./ CFCAF/ 还/ 需要/ 对/ 部分/ 基本块/ 的/ 插装/ 指令/ 进行/ 改进/ ,/ 如图/ 8/ 所示/ ,/ 除了/ 图中/ 列出/ 的/ 指令/ 外/ ,/ CFCAF/ 在/ 基本块/ 中/ 其他/ 位置/ 插入/ 的/ 指令/ 不变/ ./ CFCAF/ 在/ 函数调用/ 块/ 中/ 新/ 插入/ 1/ 条/ 标签/ 更新/ 指令/ #/ 7/ ,/ 指令/ 中/ 的/ 标签/ Lexit/ 只/ 嵌入/ 了/ 本次/ 函数调用/ 块/ 对应/ 返回/ 块/ 的/ 静态/ 标签/ ./ 被/ 调用函数/ 的/ 入口/ 块/ 中/ 插入/ 了/ 指令/ #/ 8/ ,/ 将/ G/ 中/ 的/ Lexit/ 保存/ 在/ 被/ 调用函数/ 的/ 堆栈/ 空间/ 中/ ./ 被/ 调用函数/ 的/ 出口/ 块/ 则/ 利用/ 指令/ #/ 9/ 从/ 堆栈/ 中弹/ 出/ Lexit/ 到/ P/ 中/ ./ 由于/ 每次/ 函数调用/ 时/ 已经/ 将/ 对应/ 返回/ 块/ 的/ 静态/ 标签/ 信息/ 保存/ ,/ 所以/ CFCAF/ 可以/ 克服/ SIED/ 的/ 问题/ ./ CFCAF/ 也/ 可以/ 处理/ 嵌套/ 、/ 递归/ 等/ 复杂/ 的/ 情况/ ./ CFCAF/ 利用/ 函数/ 的/ 堆栈/ 空间/ 保存信息/ ,/ 不/ 需要/ 额外/ 的/ 寄存器/ ,/ 这种/ 方法/ 不会/ 带来/ 明显/ 的/ 存储/ 压力/ ./ 另外/ 这种/ 方法/ 只/ 多/ 插入/ 了/ 2/ 条/ 指令/ ,/ 所以/ 性能/ 开销/ 也/ 比较/ 小/ ./ 3CFCAF/ 检错/ 能力/ 分析/ 由于/ 空间/ 环境/ 中/ 瞬时/ 故障/ 发生/ 的/ 概率/ 很小/ ,/ 所以/ 可以/ 假设/ 程序/ 一次/ 运行/ 过程/ 中/ 最/ 多只/ 发生/ 一次/ 单/ 粒子/ 翻转/ ,/ 而/ 程序运行/ 时/ 也/ 至多/ 发生/ 一次/ 控制流/ 错误/ ./ 另外/ ,/ CFCAF/ 无法/ 检测/ 数据流/ 错误/ ,/ 因此/ 对于/ 由于/ 条件/ 跳转/ 的/ “/ 条件/ ”/ 数据/ 错误/ 引起/ 的/ 跳转/ 错误/ ,/ 需要/ 结合/ 数据流/ 检错/ 算法/ 检测/ ,/ 这里/ 不/ 加/ 讨论/ ./ 首先/ 分析/ CFCAF/ 对块/ 内/ 和/ 块/ 间/ 的/ 控制流/ 错误/ 检测/ 能力/ ./ 针对/ 不同/ 类别/ 的/ 基本块/ ,/ CFCAF/ 在/ 其/ 不同/ 位置/ 共/ 插入/ 了/ 6/ 条/ 指令/ #/ 1/ ~/ #/ 6/ 实现/ 对块间/ 和/ 块/ 内/ 的/ 控制流/ 检测/ (/ 假设/ 块/ 内/ 检测/ 机制/ 只/ 插入/ 1/ 条/ 指令/ )/ ./ 这/ 6/ 条/ 指令/ 将/ 基本块/ 分成/ 了/ 不同/ 的/ 区域/ ,/ 定义/ r/ (/ #/ n/ )/ 为/ 指令/ #/ n/ 到/ 同一个/ 基本块/ 内/ 的/ 前/ 一条/ 插装/ 指令/ 之后/ 的/ 区域/ ,/ 例如/ r/ (/ #/ 1/ )/ 包含/ 指令/ #/ 1/ ,/ r/ (/ #/ 5/ )/ 包含/ 指令/ #/ 5/ 以及/ 指令/ #/ 1/ 和/ 指令/ #/ 5/ 之间/ 的/ 指令/ ./ 用/ #/ x/ →/ #/ y/ 表示/ 在/ 执行/ 区域/ r/ (/ #/ x/ )/ 的/ 某条/ 指令/ 之前/ ,/ 控制流/ 直接/ 跳转/ 到/ 了/ 区域/ r/ (/ #/ y/ )/ 中/ 的/ 指令/ ,/ 则/ 除了/ 控制流/ 跳转/ 到/ 程序/ 空间/ 之外/ 的/ 情况/ ,/ 所有/ 的/ 控制流/ 跳转/ 都/ 可以/ 表示/ 为/ 一个/ 区域/ 到/ 另/ 一个/ 区域/ 的/ 转移/ ./ 而/ 对于/ 控制流/ 跳转/ 到/ 程序/ 空间/ 之外/ 的/ 情况/ ,/ 底层/ 硬件/ 机制/ 或/ 操作系统/ 一般/ 可以/ 检测/ ,/ 这里/ 不/ 作/ 讨论/ ./ 如表/ 1/ 所示/ ,/ 表中/ 列举/ 了/ 源/ 基本块/ Vsource/ 到/ 目的/ 基本块/ Vsink/ 跳转/ 的/ 不同/ 情形/ ,/ 并/ 分为/ 了/ 源/ 、/ 目的/ 基本块/ 相同/ 和源/ 、/ 目的/ 基本块/ 不同/ 两类/ ,/ 另外/ 表中/ 组合/ 还/ 暗含/ 了/ 目的/ 基本块/ 是/ 合法/ 后继/ 和/ 目的/ 基本块/ 不是/ 合法/ 后继/ 两种/ 情形/ ./ 表/ 1/ 中用/ “/ / ”/ 表示/ 该种/ 控制流/ 错误/ 可以/ 被/ 算法/ 检出/ ./ 如/ Vsource/ ≠/ Vsink/ 时/ 的/ #/ 5/ →/ #/ 3/ 错误/ ,/ 即/ 程序执行/ 完/ #/ 1/ 后/ 跳/ 过/ 了/ #/ 5/ ,/ 因为/ G/ 中/ 保存/ 的/ 入口/ 标签/ 没有/ 被/ 指令/ #/ 5/ 更新/ 为/ 静态/ 标签/ ,/ 所以/ 在/ 执行/ 指令/ #/ 4/ 时/ ,/ 可以/ 检测/ 出/ 控制流/ 错误/ ./ 再/ 如/ Vsource/ =/ Vsink/ 时/ 的/ #/ 2/ →/ #/ 6/ 错误/ ,/ 即/ 控制流/ 从/ 前驱/ 块/ 的/ 尾部/ 直接/ 跳到/ 了/ 指令/ #/ 6/ ,/ 因为/ 此时/ 的/ G/ 中/ 保存/ 的/ 是/ 前驱/ 块/ 的/ 静态/ 标签/ ,/ 其/ 保留/ 位/ 只/ 可能/ 是/ 00/ 或/ 01/ ,/ 因此/ 执行/ 完/ #/ 6/ 后/ ,/ 保留/ 位会/ 变为/ 11/ 或/ 00/ ,/ 而/ 2/ 类块/ 的/ 静态/ 标签/ 保留/ 位是/ 01/ ,/ 所以/ 执行/ 到/ 指令/ #/ 4/ 时/ ,/ 可以/ 检测/ 出/ 这个/ 控制流/ 错误/ ./ Page7/ 表/ 1CFCAF/ 检测/ 能力/ 分析/ source/ #/ 1/ #/ 2/ #/ 3/ #/ 4/ #/ 5/ #/ 6/ #/ 1/ / / ×/ / / / / -/ -/ / -/ / -/ / -/ #/ 2/ / ×/ / / / / / -/ -/ / -/ / -/ -/ / #/ 3/ / ×/ / ×/ / / / / -/ ×/ -/ ×/ ×/ / ×/ / -/ / -/ #/ 4/ / ×/ / ×/ / / / / / ×/ -/ / ×/ -/ -/ -/ / -/ / -/ #/ 5/ / / ×/ / / / / -/ ×/ -/ / / ×/ -/ #/ 6/ / ×/ / / / / / -/ -/ ×/ / / -/ ×/ 表/ 1/ 中用/ “/ ×/ ”/ 表示/ 该种/ 控制流/ 错误/ 会/ 被/ 算法/ 漏检/ ./ 如/ Vsource/ ≠/ Vsink/ 时/ 的/ #/ 4/ →/ #/ 1/ 错误/ ,/ 即源/ 基本块/ 的/ #/ 3/ 执行/ 后/ ,/ 控制流/ 跳转/ 到/ 了/ 目的/ 基本块/ 的/ 首部/ ,/ 当/ 目的/ 基本块/ 是/ 源/ 基本块/ 的/ 合法/ 后继/ 时/ ,/ 由于/ P/ 中/ 含有/ 目的/ 基本块/ 的/ 入口/ 标签/ ,/ 所以/ 目的/ 基本块/ 中/ 的/ 标签/ 更新/ 、/ 检测/ 和/ 控制流/ 正常/ 时/ 一样/ ,/ 算法/ 会/ 误判/ 控制流/ 正常/ ./ 而/ Vsource/ =/ Vsink/ 时/ 的/ #/ 5/ →/ #/ 5/ 错误/ ,/ 即/ #/ 1/ 和/ #/ 5/ 之间/ 小/ 区域/ 内/ 的/ 控制流/ 错误/ ,/ 因为/ 不会/ 影响/ 标签/ 的/ 更新/ ,/ 所以/ 同样/ 无法/ 被/ 算法/ 检出/ ./ 这类/ 错误/ 是/ 算法/ 块/ 内/ 控制流/ 检测/ 机制/ 的/ 主要/ 盲点/ ./ 表/ 1/ 中/ 的/ “/ -/ ”/ 则/ 表示/ 此类/ 控制流/ 错误/ 不/ 可能/ 发生/ 、/ 不会/ 影响/ 程序/ 的/ 结果/ ,/ 或者/ 利用/ 操作系统/ 或/ 底层/ 硬件/ 的/ 超时/ 机制/ 可以/ 检测/ 出来/ ./ 如/ Vsource/ =/ Vsink/ 时/ 的/ #/ 1/ →/ #/ 4/ 错误/ ,/ 当/ 目的/ 基本块/ 是/ 合法/ 后继/ 时/ ,/ 此/ 错误/ 即/ 执行/ 完/ 指令/ #/ 4/ 后/ ,/ 再次/ 重复/ 执行/ 指令/ #/ 4/ ,/ 这种/ 错误/ 不会/ 影响/ 程序/ 结果/ ./ 若/ 基本块/ 内/ 的/ 一个/ 错误/ 跳转/ 是/ 逆向/ 的/ ,/ 而且/ 这个/ 错误/ 是/ 由于/ 静态/ 的/ 代码/ 空间/ 被/ 修改/ 导致/ 的/ ,/ 那么/ 程序运行/ 就/ 会/ 出现/ 死循环/ ,/ 必须/ 利用/ 操作系统/ 或/ 底层/ 硬件/ 的/ 超时/ 机制/ 检测/ ./ 例如/ Vsource/ =/ Vsink/ 时/ 的/ #/ 3/ →/ #/ 6/ 错误/ 就是/ 这/ 类/ 错误/ 的/ 典型/ ./ 从表/ 1/ 中/ 可以/ 看出/ ,/ 算法/ 不能/ 检测/ 到/ 的/ 块/ 内/ 和/ 块/ 间/ 控制流/ 错误/ 只/ 占/ 少数/ ./ 这些/ 错误/ 主要/ 表现/ 为/ :/ (/ 1/ )/ 目的/ 基本块/ 和源/ 基本块/ 有/ 共同/ 的/ 前驱/ 块/ 且/ 源/ 基本块/ 只有/ 一个/ 前驱/ 块/ ;/ (/ 2/ )/ 目的/ 基本块/ 恰好/ 是/ 源/ 基本块/ 的/ 后继/ ;/ (/ 3/ )/ 被/ 插装/ 指令/ 分割/ 出来/ 的/ 小/ 区域/ 内部/ 的/ 控制流/ 错误/ ./ 对于/ 前/ 两类/ 错误/ ,/ 根据/ 直观/ 理解/ ,/ 可以/ 确定/ 其/ 发生/ 的/ 概率/ 是/ 很小/ 的/ ./ 而/ 最后/ 一类/ 错误/ 发生/ 的/ 概率/ 则/ 与/ 算法/ 在/ 基本块/ 中部/ 等/ 间距/ 插入/ 的/ 指令/ 数量/ 有关/ ./ 一般/ 情况/ 下/ ,/ 插入/ 的/ 指令/ 数量/ 越/ 多/ ,/ 这/ 类/ 错误/ 发生/ 的/ 概率/ 就/ 越/ 小/ ,/ 但/ 算法/ 的/ 性能/ 开销/ 也/ 就/ 越/ 大/ ,/ 这/ 就/ 需要/ 充分利用/ 算法/ 的/ 可/ 配置/ 性/ ./ 现在/ 讨论/ CFCAF/ 算法/ 对/ 过程/ 间/ 控制流/ 的/ 检测/ 能力/ ./ CFCAF/ 算法/ 为了/ 检测/ 过程/ 间/ 的/ 控制流/ ,/ 在/ 相关/ 的/ 基本块/ 中/ 新/ 插入/ 了/ 指令/ #/ 7/ 、/ #/ 8/ 、/ #/ 9/ ,/ 这些/ 指令/ 对/ 基本块/ 同样/ 有/ 分割/ 作用/ ,/ 因此/ 这种/ 机制/ 的/ 可靠性/ 分析/ 和/ 前述/ 检测/ 能力/ 分析方法/ 类似/ ./ 分析/ 的/ 结果表明/ ,/ 除了/ 一些/ 极端/ 情况/ 下/ 的/ 控制流/ 错误/ 无法/ 检测/ 外/ ,/ 算法/ 同样/ 能/ 检测/ 出/ 绝大部分/ 的/ 过程/ 间/ 控制流/ 错误/ ./ 出现/ 的/ 检测/ 盲点/ 包括/ :/ 程序执行/ 完/ 函数调用/ 块/ 的/ 指令/ #/ 7/ 后/ ,/ 直接/ 跳到/ 了/ 返回/ 块/ 的/ 指令/ #/ 3/ ,/ 并且/ 返回/ 块/ 是/ 1/ 类块/ ,/ 此时/ 由于/ G/ 中/ 保存/ 的/ 就是/ 返回/ 块/ 的/ 静态/ 标签/ ,/ 所以/ 这种/ 错误/ 无法/ 被/ 算法/ 检出/ ;/ 类似/ 的/ 盲点/ 是/ 控制流/ 在/ 指令/ #/ 8/ 执行/ 后/ 跳转/ 到/ 指令/ #/ 3/ ,/ 发生/ 漏检/ 的/ 原因/ 和/ 上述情况/ 相同/ ./ 假设/ 程序/ 指令/ 数量/ 为/ N/ ,/ 函数/ 返回/ 块/ 划分/ 为/ 1/ 类块/ 的/ 概率/ 为/ 1/ // X/ ,/ X/ / 1/ ,/ 则/ 上述情况/ 发生/ 一次/ 的/ 概率/ 为/ 1/ // (/ X/ ×/ N/ ×/ (/ N/ -/ 1/ )/ )/ ,/ 因此/ 这种/ 错误/ 发生/ 的/ 概率/ 是/ 极小/ 的/ ./ 总结/ 来说/ ,/ CFCAF/ 对/ 过程/ 间/ 控制流/ 的/ 检测/ 机制/ 是/ 可靠/ 的/ ./ 4/ 基于/ RISC/ 的/ 实现/ 优化/ CFCAF/ 作为/ 一种/ 汇编/ 级/ 的/ 检错/ 算法/ ,/ 其/ 性能/ 及/ 可靠性/ 不可避免/ 地会/ 受到/ 底层/ 体系结构/ 的/ 影响/ ./ 目前/ ,/ RISC/ 体系结构/ 因/ 其/ 简单/ 高效/ 而/ 被/ 中/ 、/ 高档/ 服务器/ 和/ 嵌入式/ 平台/ 普遍/ 采用/ ,/ 因此/ 我们/ 重点/ 研究/ 了/ 算法/ 在/ RISC/ 平台/ 下/ 的/ 实现/ ./ 如图/ 9/ 所示/ ,/ 我们/ 以/ RISC/ 家族/ 的/ MIPS32/ 指令集/ 说明/ 算法/ 的/ 基本/ 实现/ ./ 图/ 9/ 中/ 的/ 指令/ 分别/ 是/ 图/ 7/ 中/ 对应/ 位置/ 操作/ 的/ 实现/ ,/ 需要/ 说明/ 的/ 是/ #/ 4/ 是/ 立即/ 数/ 条件/ 陷入/ 指令/ ,/ 实现/ 的/ 功能/ 是/ 比较/ G/ 和/ 静态/ 标签/ S/ ,/ 若/ 不/ 相等/ 则/ 陷入/ 异常/ ,/ 执行/ 用户/ 定义/ 的/ 错误处理/ 操作/ ./ 用/ 这条/ 指令/ 实现/ #/ 4/ 的/ 好处/ 是/ 可以/ 节省/ 1/ 个/ 寄存器/ 和/ 少/ 插入/ 1/ 条/ 指令/ ,/ 并且/ 提高/ 了/ 算法/ 的/ 可靠性/ ./ 原因/ 是/ MIPS/ 下/ 的/ 比/ Page8/ 较/ 指令/ 不/ 支持/ 立即/ 数/ 操作数/ ,/ 需要/ 先/ 把/ 立即/ 数/ 加载/ 到/ 通用寄存器/ 再/ 进行/ 比较/ 操作/ ./ 另外/ 需要/ 指出/ 的/ 是/ ,/ RISC32/ 的/ 大部分/ 立即/ 数/ 操作/ 指令/ 只/ 支持/ 16/ 位/ 立即/ 数/ ,/ 当/ 立即/ 数/ 大于/ 16/ 位时/ ,/ 就/ 需要/ 先用/ 2/ 条/ 指令/ 将/ 立即/ 数/ 加载/ 到/ 寄存器/ 中/ 再/ 进行/ 操作/ ./ 如图/ 9/ 中/ 的/ 指令/ #/ 3/ ,/ li/ 指令/ 是/ 编译器/ 支持/ 的/ 伪指令/ ,/ 当/ 标签/ 数据/ L/ 大于/ 16/ 位时/ ,/ li/ 在/ 程序/ 链接/ 时会/ 转换成/ 2/ 条/ 其他/ 指令/ 来/ 实现/ ,/ 如/ 指令/ “/ liP/ ,/ 0x80012003/ ”/ 就/ 会/ 被/ 转换/ 为/ 指令/ “/ luiP/ ,/ 0x8001/ ”/ 和/ “/ oriP/ ,/ 0x2003/ ”/ ,/ 其中/ ,/ 第/ 1/ 条/ 指令/ 为/ 加载/ 后/ 移位指令/ ,/ 第/ 2/ 条/ 指令/ 为/ 按位/ 或/ 指令/ ./ 因此/ ,/ RISC/ 下/ 的/ 立即/ 数/ 操作数/ 大于/ 半字时/ ,/ 即/ 意味着/ 要/ 额外/ 插入/ 1/ ~/ 2/ 条/ 指令/ 处理/ 立即/ 数/ ,/ 甚至/ 还/ 需要/ 再/ 占用/ 一个/ 寄存器/ ./ CFCAF/ 由于/ 标签/ 设计/ 的/ 特点/ ,/ 在/ RISC/ 下/ 实现/ 时/ ,/ 除了/ 指令/ #/ 3/ 可能/ 会/ 转换成/ 2/ 条/ 指令/ 外/ ,/ 其余/ 指令/ 都/ 不/ 需要/ 再/ 插入/ 指令/ 处理/ 立即/ 数/ ./ 因此/ 在/ 只/ 实现/ 基本块/ 间/ 控制流/ 检测/ 的/ 前提/ 下/ ,/ CFCAF/ 在/ 每个/ 块/ 内/ 只/ 需要/ 插入/ 3/ ~/ 4/ 条/ 指令/ ,/ 且/ 整个/ 算法/ 实现/ 只用/ 到/ 2/ 个/ 通用寄存器/ ./ 由于/ 使用/ 32/ 位/ 标签/ ,/ CFCSS/ 算法/ 则/ 需要/ 插入/ 3/ ~/ 7/ 条/ 指令/ ,/ 并/ 使用/ 2/ ~/ 4/ 个/ 寄存器/ ./ 即便/ 不/ 考虑/ 程序/ 基本块/ 数/ 大于/ 31/ 个/ 时/ 使用/ 嵌套/ 机制/ 额外/ 插入/ 的/ 指令/ ,/ RSCFC/ 算法/ 仍/ 需要/ 在/ 每个/ 块/ 内/ 插入/ 6/ ~/ 9/ 条/ 指令/ ,/ 使用/ 1/ ~/ 2/ 个/ 寄存器/ ./ CFCSS/ 算法/ 同样/ 可以/ 限制/ 标签/ 为/ 16/ 位/ ,/ 降低/ 时空/ 开销/ ,/ 但/ 本身/ 已/ 受限于/ 机器/ 字长/ 的/ RSCFC/ 算法/ 却/ 无法/ 这样/ 优化/ ./ CFCAF/ 虽然/ 因/ 引入/ 虚拟/ 基本块/ 而/ 额外/ 插入/ 一些/ 指令/ ,/ 但/ 绝大部分/ 程序/ 不/ 需要/ 或者/ 只/ 需要/ 插入/ 少量/ 虚拟/ 基本块/ ,/ 综合/ 考虑/ ,/ 仍然/ 可以/ 认为/ CFCAF/ 在/ RISC/ 下/ 是/ 一种/ 比较/ 高效/ 的/ 算法/ ./ 5/ 实验/ 结果/ 及/ 分析/ 我们/ 在/ RedHatLinux9/ ./ 0/ 下/ 使用/ 模拟器/ SimpleScalar/ [/ 20/ ]/ 对/ CFCAF/ 进行/ 故障注入/ 实验/ ./ SimpleScalar/ 是/ 目前/ 学术界/ 最为/ 流行/ 的/ 体系结构/ 模拟器/ ,/ 其/ 开发工具/ 集/ 可以/ 配置/ 成/ 许多/ 不同/ 体系结构/ 的/ 模拟器/ ,/ 如/ PISA/ 、/ Alpha/ 、/ PowerPC/ 和/ x86/ 等/ ./ 其中/ ,/ PISA/ 指令集/ 是/ 一种/ 类似/ MIPS/ 的/ RISC/ 指令集/ ,/ 也/ 是/ 我们/ 实验/ 使用/ 的/ 指令集/ ./ 实验/ 采用/ 了/ 矩阵/ 乘法/ MM/ (/ 20/ ×/ 20/ 的/ 矩阵/ )/ 、/ 冒泡排序/ BS/ (/ 随机/ 选取/ 的/ 20/ 个/ 整数/ )/ 、/ 斐波/ 那契/ FIB/ (/ 计算/ 第/ 20/ 项斐波/ 那/ 契数/ )/ 和/ PI/ 程序/ (/ 蒙特卡罗/ 法求/ π/ 值/ )/ 4/ 个/ 基准/ 测试程序/ 作为/ 测试用例/ ./ 为了/ 比较/ CFCAF/ 和/ 同类/ 算法/ 在/ 开销/ 和/ 检错/ 能力/ 方面/ 的/ 差别/ ,/ 我们/ 还/ 选取/ 了/ CFCSS/ 算法/ 和/ RSCFC/ 算法/ 一同/ 进行/ 故障注入/ 实验/ ./ 5.1/ CFCAF/ 时空/ 开销/ 评估/ 由于/ 程序/ 在/ 不同/ 平台/ 下/ 的/ 执行/ 时间/ 大不相同/ ,/ 况且/ 不同/ 的/ 源程序/ 采用/ 控制流/ 检测/ 技术/ 后/ 的/ 代码/ 大小/ 和/ 执行/ 时间/ 也/ 迥然不同/ ,/ 所以/ 表/ 2/ 中/ 只/ 给出/ 了/ 应用/ 检错/ 算法/ 的/ 程序/ 和/ 源程序/ 时空/ 开销/ 的/ 比值/ ./ 开销/ 程序/ MM1/ ./ 1261.2851/ ./ 1411.3401/ ./ 5201.293/ BS1/ ./ 3101.6611/ ./ 3611.4451/ ./ 6471.387/ PI1/ ./ 2881.6591/ ./ 3471.3051/ ./ 4761.316/ FIB1/ ./ 7272.5901/ ./ 8181.3761/ ./ 4941.365/ 平均/ 1.3631/ ./ 7991.4171/ ./ 3671.5341/ ./ 340/ 从表/ 2/ 中/ 可以/ 看出/ ,/ 相比/ 其他/ 算法/ ,/ CFCSS/ 算法/ 的/ 性能/ 开销/ 是/ 最小/ 的/ ,/ 平均/ 为/ 36.3/ %/ ,/ 这/ 一方面/ 是因为/ CFCSS/ 的/ 检测/ 机制/ 比较简单/ ,/ 插装/ 指令/ 较/ 少/ ,/ 另一方面/ 则/ 是因为/ 测试程序/ 较/ 小/ ,/ 我们/ 将/ 其/ 标签/ 限制/ 在/ 了/ 16/ 位/ ./ CFCAF/ 的/ 性能/ 开销/ 是/ 可/ 调节/ 的/ ,/ 实现/ 时/ 可以/ 根据/ 需要/ 配置/ 是否/ 实现/ 块/ 内/ 或/ 过程/ 间/ 检测/ 机制/ ,/ 对块/ 内/ 检测/ 机制/ ,/ 同样/ 可以/ 根据/ 块/ 的/ 大小/ 进行/ 配置/ ./ 我们/ 对/ CFCAF/ 的/ 基本块/ 内/ 控制流/ 检测/ 机制/ 进行/ 了/ 精密/ 配置/ ,/ 当/ 基本块/ 长度/ Len/ </ 3/ 时/ 不/ 插入/ 块/ 内/ 检测/ 指令/ ,/ 当/ 2/ </ Len/ </ 10/ 时/ 在/ 基本块/ 中部/ 插入/ 1/ 条/ 指令/ ,/ 而/ Len/ >/ 9/ 时则/ 在/ 基本块/ 中部/ 等/ 间距/ 插入/ 两条/ 指令/ ,/ 最终/ 算法/ 的/ 性能/ 开销/ 平均/ 为/ 41.7/ %/ ,/ 只/ 比/ CFCSS/ 算法/ 略有/ 增加/ ./ 尽管/ 因为/ 程序/ 规模/ 小/ ,/ 不/ 需要/ 应用/ 嵌套/ 机制/ ,/ 但/ 由于/ 第/ 4/ 节/ 分析/ 的/ 原因/ ,/ RSCFC/ 算法/ 的/ 性能/ 开销/ 仍然/ 是/ 最大/ 的/ ,/ 平均/ 达到/ 了/ 79.9/ %/ ./ 在/ 3/ 个/ 算法/ 中/ ,/ RSCFC/ 算法/ 的/ 空间/ 开销/ 也/ 是/ 最大/ 的/ ,/ 而/ 由于/ 加载/ 标签/ 数据/ 的/ 指令/ li/ 是/ 伪指令/ ,/ 执行/ 时/ 可能/ 会/ 转换/ 为/ 两条/ 指令/ ,/ 所以/ CFCAF/ 的/ 空间/ 开销/ 比/ CFCSS/ 略/ 小/ ,/ 但/ 其/ 性能/ 开销/ 却/ 比/ CFCSS/ 大/ ./ 5.2/ CFCAF/ 检测/ 能力/ 评估/ 我们/ 通过/ 改造/ SimpleScalar/ 代码/ 实现/ 故障注入/ 的/ 实验/ 结果/ 统计/ ,/ 因为/ 在/ SimpleScalar/ 的/ 程序/ 中/ 可以/ 直接/ 获得/ 或/ 修改/ 系统/ 的/ 状态/ 信息/ ,/ 如/ 寄存器/ 数据/ 、/ 系统/ 时钟/ 、/ 指令/ 地址/ 和/ 操作码/ ,/ 以及/ 系统/ 异常/ 等/ ,/ 所以/ 改造/ SimpleScalar/ 的/ 程序/ 可以/ 使/ 我们/ 方便/ 地/ 注入/ 故障/ (/ 修改/ PC/ 寄存器/ 或者/ 指令/ 操作码/ 等/ )/ ,/ 也/ 可以/ 帮助/ 我们/ 区分/ 出/ 不同/ 的/ 运行/ 结果/ ./ 实验/ 针对/ 每次/ 程序运行/ 注入/ 1/ 位/ 翻转/ ,/ 注入/ 的/ 位置/ 包括/ PC/ 和/ 代码/ 存储空间/ (/ MEM/ )/ ./ PC/ 故障/ 在/ 程序运行/ 时/ 动态/ 注入/ ,/ 即/ 在/ 随机/ 时刻/ 随机/ 翻转/ PC/ 寄存器/ 中/ 的/ 一位/ ./ MEM/ 故障/ 则/ 通过/ 静态/ 注入/ 实现/ ,/ 即/ 在/ 程序运行/ 前向/ 代码/ Page9/ 段/ 注入/ 一位/ 翻转/ 故障/ ,/ 注入/ 这/ 类/ 故障/ 的/ 目标/ 包括/ :/ 修改/ 跳转/ 指令/ 的/ 操作码/ 为/ 非/ 跳转/ 指令/ ;/ 修改/ 非/ 跳转/ 指令/ 的/ 操作码/ 为/ 跳转/ 指令/ ;/ 修改/ 跳转/ 指令/ 的/ 目标/ 地址/ ./ 每个/ 版本/ 程序/ 进行/ 2100/ 次/ 故障注入/ 实验/ ,/ 其中/ 注入/ PC/ 和/ 注入/ MEM/ 的/ 比例/ 为/ 16/ ./ 注入/ 的/ 故障/ 按/ 程序运行/ 结果/ 可以/ 分为/ 5/ 类/ [/ 17/ ]/ :/ (/ 1/ )/ Correct/ ./ 注入/ 的/ 故障/ 未/ 影响/ 程序/ 结果/ ,/ 程序/ 正常/ 结束/ 且/ 结果/ 正确/ ;/ (/ 2/ )/ Wrong/ ./ 故障/ 未被发现/ ,/ 程序/ 正常/ 结束/ 但/ 结果/ 错误/ ;/ (/ 3/ )/ Exception/ ./ 注入/ 的/ 故障/ 导致/ 异常/ 被/ 系统/ 检出/ ,/ 如/ 地址/ 访问/ 越界/ 、/ 指令/ 无法/ 解析/ 等/ ;/ (/ 4/ )/ Timeout/ ./ 故障/ 导致/ 的/ 程序/ 死循环/ 、/ 挂/ 起/ 等/ 引发/ 超时/ ;/ (/ 5/ )/ Detected/ ./ 检错/ 算法/ 检测/ 出/ 注入/ 的/ 故障/ ./ 由于/ 出现/ 第/ 2/ 类/ 故障/ 时/ 危害/ 较大/ ,/ 并且/ 其他/ 几类/ 故障/ 不/ 影响/ 程序运行/ 或者/ 可以/ 靠/ 各种/ 现有/ 机制/ 检测/ 出来/ ,/ 因此/ 控制流/ 检测/ 算法/ 的/ 主要/ 目标/ 是/ 减少/ 第/ 2/ 类/ 故障/ ,/ 定义/ 失效率/ 表/ 3/ 源程序/ 和/ CFCAF/ 程序/ 故障注入/ 结果/ 程序/ 结果/ Correct368567100265633387366294830458621028975891Exception7678715693173182396771764443553463493582Timeout47102023291119201193193154658434093Wrong1411271421213133173892748264571573606812Detected0000000099109154151254206224222/ 表/ 4CFCSS/ 和/ RSCFC/ 程序/ 故障注入/ 结果/ 程序/ 结果/ Correct3553555277692278974547633657721920721686Exception7260463760151255362348545829658532648781Timeout221134762326088152172192485760Wrong1281038052911101056510083783385938721Detected43831061122702242932799098111160244207287252/ 空/ 开销/ 接近/ CFCSS/ 算法/ 的/ 前提/ 下/ ,/ 在/ 3/ 个/ 算法/ 中/ 具有/ 最高/ 的/ 可靠性/ ./ 通过/ 比较/ 可以/ 发现/ ,/ 检错/ 算法/ 的/ 故障/ 检测/ 率/ (/ Detected/ 故障/ 占/ 该类/ 故障/ 总数/ 的/ 比例/ )/ 在/ 注入/ PC/ 故障/ 时要/ 明显/ 高于/ 注入/ MEM/ 故障/ 时/ ,/ 而且/ 注入/ PC/ 故障/ 时/ ,/ 不同/ 算法/ 的/ 故障/ 检测/ 率/ 差别/ 更为/ 明显/ ,/ 这是/ 由于/ 注入/ PC/ 故障/ 可以/ 有效/ 地/ 引发/ 控制流/ 错误/ ,/ 而/ 注入/ MEM/ 故障/ 时/ ,/ 则/ 出现/ 了/ 大量/ 不/ 影响/ 程序运行/ 的/ 故障/ ,/ 因此/ 注入/ PC/ 故障/ 可以/ 更好/ 地/ 检验/ 算法/ 的/ 检测/ 能力/ ./ 在/ 注入/ PC/ 故障/ 时/ ,/ CFCAF/ 的/ 故障/ 检测/ 率/ 平均/ 为/ 42.8/ %/ ,/ 明显/ 高于/ CFCSS/ 的/ 28.7/ %/ 和/ RSCFC/ 的/ 38.3/ %/ ./ 统计/ 2100/ 个/ 故障/ 中/ 各个/ 版本/ 程序/ 的/ 失效率/ 如图/ 10/ 所示/ ,/ 从图/ 中/ 可以/ 看出/ ,/ 实现/ 了/ 检错/ 算法/ 的/ 程序/ 失效率/ 较/ 源程序/ 均/ 有/ 明显降低/ ,/ 证明/ 算法/ 是/ 有效/ 的/ ,/ 而/ 在/ 不同/ 算法/ 分别/ 应用/ 到/ 同一个/ 程序/ 时/ ,/ CFCAF/ 算法/ 的/ 失效率/ 总是/ 最低/ 的/ ,/ 平均/ 为/ 5.2/ %/ ./ 综合/ 5.1/ 节/ 可以/ 得出结论/ ,/ CFCAF/ 算法/ 在/ 时/ (/ FailRate/ )/ 为/ 第/ 2/ 类/ 故障/ 占/ 注入/ 故障/ 总数/ 的/ 比例/ ./ 表/ 3/ 和表/ 4/ 中/ 给出/ 了/ 各个/ 版本/ 程序/ 注入/ PC/ 故障/ 和/ MEM/ 故障/ 的/ 结果/ (/ 表中/ SourceCode/ 指/ 源程序/ )/ ./ 从表中/ 可以/ 看出/ ,/ 注入/ MEM/ 故障/ 时/ ,/ 相对/ 于/ 源程序/ ,/ 实现/ 了/ 检错/ 算法/ 的/ 程序/ 结果/ 正确/ 的/ 次数/ 明显/ 增多/ ./ 结果/ 正确/ 的/ 可能/ 原因/ 包括/ :/ PISA/ 指令/ 集中/ 有/ 大量/ 的/ 保留/ 位/ ,/ 故障注入/ 这些/ 位置/ 不会/ 影响/ 程序运行/ ;/ 注入/ 故障/ 的/ 指令/ 可能/ 在/ 运行/ 时/ 没有/ 被/ 执行/ ;/ 或者/ 注入/ 故障/ 的/ 数据/ 没有/ 被/ 使用/ ,/ 例如/ 修改/ 了/ 条件/ 跳转/ 的/ 目标/ 地址/ ,/ 而/ 实际/ 并未/ 执行/ 跳转/ ./ 因为/ 实现/ 了/ 检错/ 算法/ 的/ 程序/ 使/ 上述/ 几种/ 因素/ 出现/ 的/ 概率/ 都/ 有所增加/ ,/ 因此/ 结果/ 正确/ 的/ 次数/ 明显/ 增多/ ./ 注入/ MEM/ 故障/ 时/ ,/ 实现/ 了/ 检错/ 算法/ 的/ 程序/ 出现异常/ 和/ 超时/ 的/ 次数/ 均/ 有/ 减少/ ,/ 这种/ 现象/ 和/ 结果/ 正确/ 的/ 概率/ 增加/ 有关/ ,/ 也/ 和/ 检错/ 算法/ 在/ 异常/ 、/ 超时/ 前/ 检测/ 出/ 部分/ 故障/ 有关/ ./ MMBSPIFIBMMBSPIFIB6/ 结论/ 硬件/ 瞬时/ 故障/ 可以/ 通过/ 修改/ PC/ 寄存器/ 等/ 方式/ Page10/ 影响/ 程序/ 正常/ 的/ 控制流/ ,/ 高/ 可靠/ 系统/ 必须/ 具备/ 对/ 程序控制/ 流/ 错误/ 进行/ 检测/ 的/ 能力/ ./ 本文/ 针对/ 瞬时/ 故障/ 导致/ 的/ 程序控制/ 流/ 错误/ ,/ 提出/ 了/ 一种/ 新/ 的/ 控制流/ 检测/ 算法/ CFCAF/ ./ CFCAF/ 是/ 一种/ 汇编/ 级/ 的/ 容错/ 算法/ ,/ 算法/ 通过/ 为/ 基本块/ 设计/ 格式化/ 标签/ 和/ 在/ 基本块/ 内/ 插装/ 标签/ 更新/ 、/ 比较/ 指令/ ,/ 实现/ 了/ 对/ 基本块/ 之间/ 、/ 基本块/ 内/ 和/ 过程/ 间/ 调用/ 的/ 控制流/ 检测/ ./ 相比/ 已有/ 算法/ ,/ CFCAF/ 具有/ 标签/ 表达能力/ 强/ 、/ 时空/ 消耗/ 小/ 、/ 检错/ 能力/ 强/ 和/ 可/ 配置/ 的/ 特点/ ./ 与/ 目前/ 两个/ 有/ 代表性/ 的/ 算法/ 进行/ 比较/ 的/ 结果表明/ ,/ CFCAF/ 算法/ 具有/ 较/ 小/ 的/ 时空/ 开销/ 和/ 最高/ 的/ 可靠性/ ./ 

