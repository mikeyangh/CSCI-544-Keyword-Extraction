Page1/ 组合/ 测试/ 故障/ 定位/ 的/ 关系/ 树/ 模型/ 钮鑫涛/ 1/ )/ 聂/ 长海/ 1/ )/ CHANAlvin2/ )/ 1/ )/ (/ 南京大学/ 计算机软件/ 新/ 技术/ 国家/ 重点/ 实验室/ 南京/ 210023/ )/ 2/ )/ (/ 香港理工大学/ 电子计算/ 学系/ 香港/ )/ 摘要/ 组合/ 测试/ 是/ 一种/ 重要/ 的/ 软件测试/ 方法/ ,/ 该/ 方法/ 通常/ 采用/ 覆盖/ 表/ 作为/ 测试用例/ 集/ ,/ 适用/ 于/ 检测/ 系统/ 中/ 由/ 特定/ 配置/ 组合/ 引发/ 的/ 故障/ ./ 覆盖/ 表中/ 的/ 一条/ 引发/ 系统故障/ 的/ 测试用例/ 含有/ 多个/ 配置/ 组合/ ,/ 如何/ 确定/ 其中/ 哪个/ 或/ 哪几个/ 配置/ 组合/ 引发/ 系统故障/ 有助于/ 系统/ 开发人员/ 检测/ 出/ 故障/ 原因/ 并/ 做出/ 改进/ ./ 目前/ 已有/ 一些/ 研究/ 尝试/ 解决/ 上述/ 问题/ ,/ 然而/ 这些/ 方法/ 都/ 没有/ 对/ 待定/ 元组/ 关系/ 进行/ 深入/ 的/ 研究/ 与/ 分析/ ,/ 因此/ 定位/ 过程/ 代价/ 很大/ 并且/ 定位/ 结果/ 也/ 并/ 不/ 完整/ ./ 文中/ 构建/ 了/ 一个/ 待定/ 元组/ 关系/ 树/ (/ TupleRelationshipTree/ ,/ TRT/ )/ 来/ 描述/ 所有/ 待定/ 元组/ 的/ 关系/ ,/ 利用/ TRT/ 可以/ 减少/ 生成/ 附加/ 测试用例/ 的/ 数量/ ,/ 并且/ 由于/ TRT/ 给出/ 全部/ 待定/ 元组/ 的/ 清晰/ 视图/ ,/ 可以/ 避免/ 漏掉/ 分析/ 可能/ 的/ 待定/ 元组/ ,/ 特别/ 是/ 有/ 重叠/ 部分/ 的/ 故障/ 元组/ ./ 基于/ TRT/ ,/ 我们/ 提出/ 了/ 4/ 种/ 选择/ 策略/ 来/ 辅助/ 故障/ 定位/ ./ 系统/ 的/ 实验/ 表明/ :/ 其中/ 的/ 路径/ 方法/ 可以/ 以较/ 高/ 的/ 效率/ 得到/ 一个/ 比/ 已有/ 方法/ 更加/ 完整/ 的/ 故障/ 定位/ 结果/ ./ 关键词/ 组合/ 测试/ ;/ 故障/ 定位/ ;/ 待定/ 元组/ 关系/ 树/ ;/ 有/ 重叠/ 部分/ 元组/ ;/ 选择/ 策略/ ;/ 软件测试/ 1/ 引言/ 组合/ 测试/ 旨在/ 发现/ 由/ 系统配置/ 组合/ ,/ 输入/ 组合/ 等/ 各种/ 参数/ 组合/ 交互/ 引发/ 的/ 故障/ ./ 在/ 该/ 测试方法/ 研究/ 领域/ ,/ 有/ 两个/ 关键问题/ :/ (/ 1/ )/ 如何/ 构造/ 尽可能/ 小/ 的/ 测试用例/ 集来/ 覆盖/ 尽可能/ 多/ 的/ 交互/ 组合/ ;/ (/ 2/ )/ 在/ 一条/ 测试用例/ 触发/ 故障/ 后/ 如何/ 定位/ 出/ 引发/ 故障/ 的/ 配置/ 组合/ ./ 目前/ 已有/ 大量/ 的/ 文献/ 对/ 问题/ 1/ 做出/ 了/ 深入/ 的/ 研究/ 与/ 分析/ ,/ 但/ 对于/ 问题/ 2/ ,/ 现有/ 研究/ 仍/ 有/ 很多/ 不足/ [/ 1/ ]/ ./ 假设/ 系统/ 受到/ n/ 个/ 参数/ 的/ 影响/ ,/ 而/ 1/ 条/ 测试用例/ 就是/ 这/ n/ 个/ 参数/ 的/ 具体/ 配置/ 实例/ ./ 如/ 1/ 个/ 网页/ 应用/ 可能/ 受到/ 操作系统/ 、/ 网络带宽/ 、/ 浏览器/ 、/ 音频/ 解码器/ 的/ 影响/ (/ 每个/ 参数/ 的/ 可/ 选值/ 如表/ 1/ )/ ,/ 那么/ 1/ 条/ 测试用例/ 就是/ 这/ 4/ 个/ 参数/ 的/ 具体/ 取值/ 实例/ ,/ 如/ (/ Windows/ ,/ 200MB/ ,/ Chrome/ ,/ AC3Filter/ )/ ./ 表/ 1/ 一个/ 待/ 测系统/ SUT/ (/ SystemUnderTest/ )/ 配置/ 表/ 实例/ 操作系统/ 网络带宽/ 浏览器/ 解码器/ Windows50MBChromeAC3FilterMacOS200MBFirefoxMPEGUbuntu1GBOperaAC/ -/ 3ACM/ 如果/ 要/ 对/ 该/ 系统/ 进行/ 充分/ 测试/ ,/ 需要/ 34/ =/ 81/ 条/ 测试用例/ ,/ 当/ 参数/ 个数/ n/ 很大/ ,/ 参数/ 可选值/ 很多/ 时/ ,/ 充分/ 测试/ 所/ 需要/ 的/ 测试用例/ 数/ 成/ 几何级数/ 趋势/ 增长/ ,/ 实际/ 应用/ 是/ 不/ 可行/ 的/ ,/ 这种/ 情况/ 下/ 测试用例/ 的/ 选择/ 显得/ 非常/ 重要/ ./ 组合/ 测试/ 追求/ 用/ 最少/ 的/ 测试用例/ 实现/ 对/ 各种/ 参数/ 组合/ 的/ 覆盖/ ,/ 该/ 测试方法/ 使用/ 覆盖/ 表/ 作为/ 测试用例/ 集/ ,/ 能够/ 检测/ 到/ 系统/ 中/ 由/ 特定/ 参数/ 交互/ 而/ 引发/ 的/ 故障/ ./ 然而/ 虽然/ 利用/ 覆盖/ 表/ 测试/ 能够/ 检测/ 系统/ 中/ 是否/ 存在/ 这种/ 类型/ 的/ 故障/ ,/ 但/ 却/ 无法/ 诊断/ 失败/ 测试用例/ 中/ 具体/ 哪/ 一个/ 或/ 哪几个/ 配置/ 组合/ 是/ 引发/ 故障/ 的/ 原因/ ./ 事实上/ ,/ 执行/ 测试/ 时若/ 有/ 一条/ 这样/ 的/ 测试用例/ 出错/ ,/ 将会/ 有/ 2n/ -/ 1/ (/ n/ 是/ 此/ SUT/ 受/ 影响/ 参数/ 的/ 个数/ )/ 个/ 可能/ 的/ 参数/ 配置/ 组合/ 是/ 触发/ 故障/ 的/ 原因/ ./ 比如/ 对于/ 出错/ 的/ 测试用例/ (/ MacOS/ ,/ 50MB/ ,/ Chrome/ ,/ AC/ -/ 3ACM/ )/ ,/ 可能/ 的/ 故障/ 组合/ 有/ :/ [/ MacOS/ ,/ 50MB/ ,/ Chrome/ ,/ AC/ -/ 3ACM/ ]/ 、/ [/ MacOS/ ,/ 50MB/ ,/ Chrome/ ,/ -/ ]/ 、/ [/ MacOS/ ,/ 50MB/ ,/ -/ ,/ AC/ -/ 3ACM/ ]/ 、/ [/ MacOS/ ,/ -/ ,/ Chrome/ ,/ AC/ -/ 3ACM/ ]/ 、/ [/ -/ ,/ 50MB/ ,/ Chrome/ ,/ AC/ -/ 3ACM/ ]/ 、/ [/ MacOS/ ,/ 50MB/ ,/ -/ ,/ -/ ]/ 、/ [/ MacOS/ ,/ -/ ,/ Chrome/ ,/ -/ ]/ 、/ [/ MacOS/ ,/ -/ ,/ -/ ,/ AC/ -/ 3ACM/ ]/ 、/ [/ -/ ,/ 50MB/ ,/ Chrome/ ,/ -/ ]/ 、/ [/ -/ ,/ 50MB/ ,/ -/ ,/ AC/ -/ 3ACM/ ]/ 、/ [/ -/ ,/ -/ ,/ Chrome/ ,/ AC/ -/ 3ACM/ ]/ 、/ [/ MacOS/ ,/ -/ ,/ -/ ,/ -/ ]/ 、/ [/ -/ ,/ 50MB/ ,/ -/ ,/ -/ ]/ 、/ [/ -/ ,/ -/ ,/ Chrome/ ,/ -/ ]/ 、/ [/ -/ ,/ -/ ,/ -/ ,/ AC/ -/ 3ACM/ ]/ ,/ 一共/ 有/ 24/ -/ 1/ =/ 15/ 个/ ./ 诊断/ 出/ 其中/ 哪/ 一个/ 或/ 哪几个/ 配置/ 组合/ 触发/ 了/ 系统故障/ 有利于/ 查出/ 系统/ 的/ 错误/ 原因/ ,/ 因为/ 这/ 将/ 会/ 大大减少/ 待/ 测系统/ 所/ 需要/ 检测/ 的/ 范围/ ./ 解决/ 此/ 问题/ 的/ 最/ 简单/ 的/ 方法/ 是/ 穷举/ ,/ 逐个/ 分析判断/ 2n/ -/ 1/ 中/ 每个/ 组合/ 是否/ 为/ 故障/ 源/ ,/ 很/ 容易/ 知道/ 其/ 算法/ 复杂度/ 为/ O/ (/ 2n/ )/ ,/ 在/ 参数/ 个数/ 很大/ 的/ 情况/ 下/ 是/ 不/ 可行/ 的/ ./ 通过/ 仔细观察/ 1/ 条/ 测试用例/ 对应/ 的/ 配置/ 组合/ ,/ 我们/ 可以/ 发现/ 以下/ 两个/ 规律/ :/ (/ 1/ )/ 如果/ 1/ 个/ 配置/ 组合/ 已/ 确定/ 为/ 故障/ 源/ ,/ 那么/ 所有/ 包含/ 此/ 配置/ 组合/ 的/ 配置/ 组合/ 必然/ 是/ 故障/ 源/ (/ 比如/ 若/ [/ -/ ,/ -/ ,/ Chrome/ ,/ -/ ]/ 是/ 故障/ 源/ ,/ 那么/ [/ -/ ,/ 50MB/ ,/ Chrome/ ,/ -/ ]/ 、/ [/ -/ ,/ -/ ,/ Chrome/ ,/ AC/ -/ 3ACM/ ]/ 等/ 包含/ [/ -/ ,/ -/ ,/ Chrome/ ,/ -/ ]/ 的/ 配置/ 组合/ 必然/ 是/ 故障/ 源/ )/ ;/ (/ 2/ )/ 如果/ 一个/ 配置/ 组合/ 已/ 确定/ 为/ 非/ 故障/ 源/ ,/ 那么/ 此/ 组合/ 包含/ 的/ 所有/ 配置/ 组合/ 必然/ 是非/ 故障/ 源/ (/ 比如/ 若/ [/ -/ ,/ 50MB/ ,/ Chrome/ ,/ -/ ]/ 是非/ 故障/ 源/ ,/ 那么/ [/ -/ ,/ -/ ,/ Chrome/ ,/ -/ ]/ 、/ [/ -/ ,/ 50MB/ ,/ -/ ,/ -/ ]/ 两个/ 配置/ 组合/ 必然/ 是非/ 故障/ 源/ )/ ./ 这/ 意味着/ 我们/ 不必/ 一一/ 检查/ 1/ 条/ 错误/ 测试用例/ 对应/ 的/ 每个/ 配置/ 组合/ 是否是/ 引发/ 故障/ 的/ 根源/ ./ 因为/ 只要/ 找出/ 其中/ 一批/ 配置/ 组合/ ,/ 并且/ 确定/ 这批/ 配置/ 组合/ 中/ 每/ 一个/ 组合/ 是否是/ 引发/ 故障/ 的/ 根源/ ,/ 就/ 可以/ 通过/ 以上/ 两条/ 规律/ 确定/ 相关联/ (/ 即/ 包含/ 和/ 被/ 包含/ 关系/ )/ 的/ 配置/ 组合/ 是否/ 为/ 故障/ 源/ ./ 而/ 只要/ 合理/ 的/ 选择/ 确定/ 其中/ 的/ 一批/ 配置/ 组合/ ,/ 我们/ 就/ 可以/ 确定/ 一条/ 出错/ 测试用例/ 所有/ 的/ 配置/ 组合/ 中/ 的/ 每/ 一个/ 配置/ 组合/ 是否/ 为/ 故障/ 源/ ./ 在此之前/ ,/ 人们/ 已经/ 提出/ 了/ 一些/ 方法/ ,/ 如/ Nie/ 和/ Leung/ [/ 2/ ]/ 逐个/ 替换法/ 、/ Ghandehari/ 等/ 人/ [/ 3/ ]/ 利用/ 元组/ 可疑/ 度/ 排序/ 和/ Zhang/ 和/ Zhang/ [/ 4/ ]/ FIC/ 搜索/ 等/ ,/ 然而/ 这些/ 方法/ 都/ 没有/ 很/ 好/ 的/ 利用/ 组合/ 配置/ 之间/ 的/ 关联/ ,/ 定位/ 代价/ 往往/ 很大/ 且/ 定位/ 结果/ 不是/ 很/ 精确/ ./ 对于/ 一条/ 错误/ 的/ 测试用例/ ,/ 为了/ 能够/ 找到/ 规模/ 尽可能/ 小/ 的/ 一批/ 配置/ 组合/ 并/ 确定/ 这些/ 组合/ 是否是/ 故障/ 源/ ,/ 从而/ 达到/ 能够/ 确定/ 这/ 条/ 测试用例/ 对应/ 的/ 所有/ 配置/ 组合/ 中/ 的/ 每/ 一个/ 配置/ 组合/ 是否/ 为/ 故障/ 源/ ,/ 必须/ 要/ 充分利用/ 配置/ 之间/ 的/ 关联/ ,/ 因此/ 本文/ 提出/ 了/ 一种/ 基于/ 元组/ 关系/ 树/ (/ TRT/ )/ 的/ 方法/ ./ 该/ 方法/ 首先/ 根据/ 配置/ 组合/ 之间/ 的/ 关系/ 来/ 关联/ 所有/ 组合/ 并/ 形成/ 树状/ 结构/ ,/ 然后/ 选择/ 一种/ 策略/ 来/ 挑选/ 未/ 被/ 确定/ 的/ 组合/ 配置/ 中/ 的/ 一个/ 进行/ 分析判断/ 其/ 是否/ 为/ 故障/ 源/ ,/ 此后/ 我们/ 将/ 根据/ 分析/ 的/ 结果/ 和/ 相关/ 理论/ 来/ 确定/ 与/ 此/ 组合/ 相关/ Page3/ 的/ 配置/ 组合/ 是否/ 为/ 故障/ 源/ ./ 这个/ 过程/ 一直/ 持续/ 到/ 没有/ 未/ 被/ 确定/ 的/ 组合/ 为止/ ./ 如何/ 在/ 剩下/ 的/ 未/ 被/ 确定/ 的/ 配置/ 组合/ 中/ 挑选/ 一个/ 进行/ 分析/ 是/ 此/ 方法/ 的/ 一个/ 重点/ ,/ 并且/ 它/ 在/ 很大/ 程度/ 上/ 决定/ 本文/ 方法/ 的/ 性能/ ./ 我们/ 提出/ 了/ 4/ 种/ 不同/ 的/ 挑选/ 策略/ ,/ 并且/ 设计/ 实验/ 来/ 比较/ 这/ 4/ 种/ 策略/ 和/ 随机/ 挑选/ 策略/ 的/ 性能/ ./ 本文/ 还/ 将/ 此/ 方法/ 应用/ 于/ 对/ 真实/ 软件/ TCAS/ 的/ 模块/ 进行/ 故障/ 分析/ ./ 本文/ 的/ 贡献/ 点/ 如下/ :/ (/ 1/ )/ 本文/ 提出/ 的/ 方法/ 可以/ 分析/ 一个/ 出错/ 测试用例/ 的/ 所有/ 可能/ 配置/ 组合/ ,/ 改进/ 了/ 已有/ 研究/ 中/ 定位/ 不/ 准确/ 或/ 只能/ 定位/ t/ -/ way/ 及/ 以下/ 和/ 非/ 重叠/ 故障/ 的/ 不足/ ./ (/ 2/ )/ 提出/ 了/ 元组/ 关系/ 树/ 模型/ 来/ 关联/ 所/ 可能/ 的/ 故障/ 组合/ 从而/ 减少/ 了/ 所/ 需/ 分析/ 的/ 未/ 被/ 确定/ 的/ 配置/ 组合/ 的/ 个数/ ./ (/ 3/ )/ 基于/ 元组/ 关系/ 树/ ,/ 本文/ 提出/ 了/ 4/ 种/ 搜索/ 策略/ ,/ 并/ 给出/ 了/ 这些/ 策略/ 和/ 随机/ 选择/ 策略/ 的/ 性能/ 对比/ ./ (/ 4/ )/ 本文/ 给出/ 了/ 此/ 方法/ 在/ 实际/ 应用/ 中/ 的/ 故障/ 定位/ 分析/ 实例/ ./ 本文/ 第/ 2/ 节/ 给出/ 基本/ 定义/ 和/ 定理/ 的/ 描述/ ;/ 第/ 3/ 节/ 描述/ TRT/ 模型/ 和/ 定位/ 流程/ ;/ 第/ 4/ 节/ 给出/ 4/ 种/ 选择/ 策略/ 的/ 描述/ ;/ 第/ 5/ 节/ 描述/ 实验/ 及/ 结果/ 分析/ ;/ 第/ 6/ 节/ 给出/ 关于/ 算法/ 代价/ 的/ 一些/ 讨论/ ;/ 第/ 7/ 节/ 相关/ 工作/ 和/ 比较/ ;/ 第/ 8/ 节/ 给出/ 总结/ 和/ 未来/ 工作/ ./ 2/ 基础/ 背景/ 假设/ 待测/ 软件/ SUT/ 有/ n/ 个/ 参数/ ci/ (/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ )/ ,/ 每个/ 参数/ ci/ 的/ 可/ 选值/ 是/ 一个/ 有限/ 集/ Vi/ ,/ |/ Vi/ |/ =/ ai/ ./ 不是/ 一般性/ ,/ 我们/ 设/ a1/ >/ a2/ >/ …/ >/ an/ ./ 为了/ 能够/ 清楚/ 的/ 介绍/ 我们/ 的/ 方法/ ,/ 我们/ 需要/ 引入/ 一些/ 定义/ 和/ 定理/ ,/ 其中/ 有/ 部分/ 定义/ 沿用/ 了/ Nie/ 和/ Leung/ [/ 2/ ]/ 中/ 的/ 相关/ 定义/ ./ 2.1/ 定义/ 定义/ 1/ ./ 我们/ 称/ 由/ 系统/ n/ 个/ 参数/ 的/ 具体/ 赋值/ 序列/ (/ v1/ ,/ v2/ ,/ …/ ,/ vn/ )/ (/ v1/ ∈/ V1/ ,/ v2/ ∈/ V2/ ,/ …/ ,/ vn/ ∈/ Vn/ )/ 为/ 待/ 测系统/ SUT/ 的/ 一个/ 测试用例/ ./ 定义/ 2/ ./ 对于/ 待/ 测系统/ SUT/ ,/ 取某/ k/ 个/ 参数/ 赋予/ 特定/ 值/ 而/ 形成/ 的/ 组合/ [/ -/ ,/ …/ ,/ vl1/ ,/ -/ ,/ …/ ,/ vlk/ ,/ …/ ]/ 为/ k/ 值/ 元组/ (/ k/ >/ 0/ )/ ,/ 不/ 引起/ 混淆/ 的/ 情况/ 下/ 简称/ 为/ 元组/ ,/ 其中/ ‘/ -/ ’/ 表示/ 此处/ 参数/ 的/ 取值/ 待定/ ./ 实际上/ ,/ 此处/ 定义/ 的/ 元组/ 和/ 引言/ 中/ 的/ 配置/ 组合/ 是/ 同一个/ 概念/ ./ 例如/ 对于/ 表/ 1/ 中/ SUT/ ,/ [/ MacOS/ ,/ -/ ,/ Chrome/ ,/ -/ ]/ 就是/ 一个/ 2/ 值/ 元组/ ./ 定义/ 3/ ./ 我们/ 称/ 一个/ k/ 值/ 元组/ 为/ 故障/ 元组/ ,/ 当且/ 仅/ 当/ 任何/ 包含/ 此/ 元组/ 的/ 测试用例/ 都/ 会/ 触发/ 故障/ ./ 相反/ ,/ 若/ 存在/ 至少/ 一条/ 测试用例/ 包含/ 此/ 元组/ 且/ 通过/ 测试/ ,/ 就/ 称此/ k/ 值/ 元组/ 为/ 正确/ 元组/ ./ 举个/ 例子/ ,/ 对于/ 元组/ [/ -/ ,/ 200MB/ ,/ -/ ,/ -/ ]/ ,/ 如果/ 所有/ 包含/ 此/ 元组/ 的/ 测试用例/ 都/ 会/ 出错/ ,/ 即/ (/ Windows/ ,/ 200MB/ ,/ Firefox/ ,/ AC3Filter/ )/ 、/ (/ Ubuntu/ ,/ 200MB/ ,/ Chorme/ ,/ MPEGLayer/ -/ 3/ )/ 等等/ 都/ 没有/ 通过/ 测试/ ,/ 那么/ [/ -/ ,/ 200MB/ ,/ -/ ,/ -/ ]/ 就是/ 故障/ 元组/ ./ 同样/ 的/ ,/ 若/ 对于/ 元组/ [/ -/ ,/ 200MB/ ,/ -/ ,/ -/ ]/ ,/ 我们/ 发现/ 了/ 一条/ 测试用例/ 如/ (/ Windows/ ,/ 200MB/ ,/ Chrome/ ,/ AC3Filter/ )/ 通过/ 测试/ 的话/ ,/ 那么/ [/ -/ ,/ 200MB/ ,/ -/ ,/ -/ ]/ 就是/ 正确/ 元组/ ./ 注意/ :/ 正确/ 元组/ 不/ 需要/ 所有/ 包含/ 它/ 的/ 测试用例/ 都/ 正确/ ,/ 只/ 需/ 找到/ 一条/ 包含/ 此/ 元组/ ,/ 且/ 通过/ 的/ 测试用例/ 就/ 能/ 证明/ 待测/ 元组/ 为/ 正确/ 元组/ ,/ 下面/ 的/ 情况/ 是/ 合理/ 的/ :/ [/ -/ ,/ 200MB/ ,/ -/ ,/ -/ ]/ 为/ 正确/ 元组/ ,/ 测试用例/ (/ Windows/ ,/ 200MB/ ,/ Chrome/ ,/ AC3Filter/ )/ 通过/ ,/ 而/ 测试用例/ (/ Ubuntu/ ,/ 200MB/ ,/ Opera/ ,/ AC/ -/ 3ACM/ )/ 出错/ ./ 上述情况/ 意味着/ (/ Ubuntu/ ,/ 200MB/ ,/ Opera/ ,/ AC/ -/ 3ACM/ )/ 包含/ 了/ 引发/ 故障/ 的/ 元组/ ,/ 但/ 这个/ 元组/ 不是/ [/ -/ ,/ 200MB/ ,/ -/ ,/ -/ ]/ ./ 定义/ 4/ ./ 设/ TupleA/ 为/ m/ 值/ 元组/ ,/ TupleB/ 为/ k/ 值/ 元组/ ,/ 有/ m/ >/ k/ ,/ 并且/ 所有/ TupleB/ 中/ 的/ 元素/ 也/ 都/ 在/ TupleA/ 中/ ,/ 那么/ 我们/ 称/ TupleA/ 为/ TupleB/ 的/ 父/ 元组/ ,/ TupleB/ 为/ TupleA/ 的/ 子/ 元组/ ,/ 表示/ 成/ “/ TupleB/ / TupleA/ ”/ ,/ 如果/ m/ =/ k/ +/ 1/ ,/ 那么/ 这/ 两个/ 元组/ 是/ 直系/ 关系/ ./ 如/ 元组/ [/ MacOS/ ,/ 50MB/ ,/ Chrome/ ,/ -/ ]/ 为/ 元组/ [/ MacOS/ ,/ -/ ,/ -/ ,/ -/ ]/ 的/ 父/ 元组/ ,/ 而/ 元组/ [/ MacOS/ ,/ 50MB/ ,/ Chrome/ ,/ -/ ]/ 为/ 元组/ [/ MacOS/ ,/ -/ ,/ Chrome/ ,/ -/ ]/ 的/ 直系/ 父/ 元组/ ./ 定义/ 5/ ./ 一个/ 元组/ 如果/ 是/ 故障/ 元组/ ,/ 并且/ 其/ 所有/ 子/ 元组/ 都/ 是/ 正确/ 元组/ ,/ 那么/ 就/ 称此/ 元组/ 为/ 最小/ 故障/ 元组/ ./ 如/ [/ Windows/ ,/ 200MB/ ,/ -/ ,/ AC3Filter/ ]/ 为/ 最小/ 故障/ 元组/ 的/ 条件/ 为/ :/ 本身/ 为/ 故障/ 元组/ ,/ 而/ 其子/ 元组/ [/ Windows/ ,/ 200MB/ ,/ -/ ,/ -/ ]/ 、/ [/ Windows/ ,/ -/ ,/ -/ ,/ AC3Filter/ ]/ 、/ [/ -/ ,/ 200MB/ ,/ -/ ,/ AC3Filter/ ]/ 、/ [/ Windows/ ,/ -/ ,/ -/ ,/ -/ ]/ 、/ [/ -/ ,/ 200MB/ ,/ -/ ,/ -/ ]/ 、/ [/ -/ ,/ -/ ,/ -/ ,/ AC3Filter/ ]/ 都/ 为/ 正确/ 元组/ ./ 最小/ 故障/ 元组/ 是/ 引起/ 系统故障/ 的/ 最小/ 单元/ ,/ 定位/ 出/ 最小/ 故障/ 元组/ 有助于/ 系统/ 开发人员/ 分析/ 系统/ 的/ 故障/ 所在/ 并/ 做出/ 改进/ ./ Page42/ ./ 2/ 定理/ 定理/ 1/ ./ 一条/ 通过/ 的/ 测试用例/ 所/ 包含/ 的/ 所有/ 元组/ 都/ 是/ 正确/ 元组/ ./ 证明/ ./ 由/ 定义/ 3/ 知/ ,/ 对于/ 一个/ 元组/ ,/ 若能/ 找到/ 一条/ 测试用例/ 含有/ 此/ 元组/ 且/ 没有/ 引发/ 故障/ ,/ 那么/ 此/ 元组/ 为/ 正确/ 元组/ ./ 而/ 对于/ 这/ 条/ 通过/ 的/ 测试用例/ 里/ 包含/ 的/ 任意/ 一个/ 元组/ ,/ 由于/ 这/ 条/ 包含/ 它/ 的/ 测试用例/ 没有/ 引发/ 故障/ ,/ 因而/ 都/ 是/ 正确/ 元组/ ./ 定理/ 2/ ./ 有/ 元组/ TupleA/ ,/ TupleB/ 和/ TupleC/ ,/ 满足/ TupleC/ / TupleB/ ,/ TupleB/ / TupleA/ ,/ 那么/ TupleC/ / TupleA/ ./ 证明/ ./ 由/ 定义/ 4/ 知/ ,/ 对于/ TupleC/ 中/ 任何/ 一个/ 元素/ Vni/ 必在/ TupleB/ 中/ ,/ 而/ 在/ TupleB/ 的/ 元素/ 也/ 必/ 在/ TupleA/ 中/ ,/ 即/ Vni/ 也/ 在/ TupleA/ 中/ ,/ 根据/ 定义/ 3/ ,/ TupleC/ 为/ TupleA/ 的/ 子/ 元组/ ,/ 而/ TupleA/ 为/ TupleC/ 的/ 父/ 元组/ ,/ 即/ TupleC/ / TupleA/ ./ 这条/ 定理/ 表明/ 只/ 需/ 记录/ 元组/ 的/ 直系/ 子/ 元组/ 和/ 直系/ 父/ 元组/ ,/ 即可/ 找/ 其/ 所有/ 的/ 父/ 元组/ 和子/ 元组/ ./ 定理/ 3/ ./ 一个/ 元组/ 若/ 是/ 故障/ 元组/ ,/ 那么/ 其/ 所有/ 父/ 元组/ 都/ 是/ 故障/ 元组/ ./ 证明/ ./ 对于/ 一个/ 故障/ 元组/ ,/ 如果/ 存在/ 此/ 元组/ 的/ 一个/ 父/ 元组/ 是/ 正确/ 元组/ ,/ 根据/ 定义/ 3/ 可知/ ,/ 即/ 我们/ 能/ 找到/ 一条/ 测试用例/ 包含/ 这个/ 父/ 元组/ 且/ 通过/ 测试/ ./ 而/ 根据/ 定义/ 4/ ,/ 这个/ 测试用例/ 显然/ 也/ 包含/ 此/ 元组/ ,/ 即可/ 推出/ 此/ 元组/ 是/ 正确/ 元组/ ,/ 这/ 与/ 此/ 元组/ 是/ 故障/ 元组/ 矛盾/ ,/ 定理/ 成立/ ./ 定理/ 4/ ./ 一个/ 元组/ 若/ 是/ 正确/ 元组/ ,/ 那么/ 其/ 所有/ 的/ 子/ 元组/ 都/ 是/ 正确/ 元组/ ./ 证明/ ./ 对于/ 一个/ 正确/ 元组/ ,/ 根据/ 定义/ 3/ ,/ 我们/ 能够/ 找到/ 一条/ 测试用例/ 包含/ 此/ 元组/ 且/ 通过/ 测试/ ,/ 那么/ 根据/ 定义/ 4/ ,/ 这/ 条/ 通过/ 的/ 测试用例/ 必然/ 也/ 包含/ 这个/ 元组/ 的/ 所有/ 子/ 元组/ ,/ 因此/ 这个/ 元组/ 的/ 所有/ 子/ 元组/ 都/ 是/ 正确/ 元组/ ./ 3/ 故障/ 定位/ 模型/ 根据/ 定理/ 3/ 、/ 4/ ,/ 我们/ 知道/ 在/ 确定/ 了/ 一个/ 元组/ 为/ 正确/ 元组/ 或/ 故障/ 元组/ 后/ 能够/ 推断出/ 其父/ 元组/ 或子/ 元组/ 为/ 正确/ 元组/ 或/ 故障/ 元组/ ,/ 这/ 将/ 大大减少/ 所/ 需/ 分析判断/ 的/ 待定/ 元组/ 个数/ ,/ 从而/ 减少/ 附加/ 测试用例/ 的/ 生成/ ./ 因此/ ,/ 本文/ 的/ 方法/ 首先/ 需要/ 构造/ 一个/ 元组/ 关系/ 树来/ 记录/ 所有/ 待测/ 元组/ 和/ 它们/ 之间/ 的/ 关系/ ,/ 然后/ 基于/ 元组/ 关系/ 树/ 给出/ 完整/ 的/ 定位/ 过程/ ./ 3.1/ 元组/ 关系/ 树/ (/ TRT/ )/ 一棵/ 完整/ 的/ 元组/ 关系/ 树由/ 节点/ 和/ 连接/ 节点/ 之间/ 的/ 有/ 向/ 线段/ 组成/ ./ 其中/ ,/ 节点/ 代表/ 错误/ 测试用例/ 中/ 的/ 元组/ ./ 有/ 向/ 线段/ 连接/ 的/ 两个/ 节点/ 所/ 表示/ 的/ 元组/ 之间/ 存在/ 直系/ 父子关系/ ,/ 从/ 直系/ 父/ 元组/ 指向/ 直系/ 子/ 元组/ ./ 根据/ 定理/ 2/ ,/ 我们/ 可以/ 递归/ 获得/ 所有/ 父子关系/ 元组/ ./ 图/ 1/ 给出/ 了/ 测试用例/ (/ 1/ ,/ 2/ ,/ 3/ )/ 对应/ 的/ 元组/ 关系/ 图/ ./ 3.1/ ./ 1/ 节点/ 状态/ TRT/ 中有/ 3/ 种/ 节点/ 状态/ :/ 深色/ 、/ 浅色/ 和/ 白色/ ,/ 分别/ 表示/ 所/ 对应/ 元组/ 的/ 3/ 种/ 状态/ :/ 故障/ 、/ 正确/ 和/ 未知/ ./ 如图/ 2/ 中/ ,/ 元组/ [/ 1/ ,/ 2/ ,/ 3/ ]/ ,/ [/ 1/ ,/ -/ ,/ 3/ ]/ 为/ 故障/ 元组/ ,/ 元组/ [/ -/ ,/ 2/ ,/ -/ ]/ ,/ [/ 1/ ,/ -/ ,/ -/ ]/ 为/ 正确/ 元组/ ,/ 元组/ [/ 1/ ,/ 2/ ,/ -/ ]/ ,/ [/ -/ ,/ 2/ ,/ 3/ ]/ ,/ [/ -/ ,/ -/ ,/ 3/ ]/ 为/ 未知/ 元组/ ./ 3.2/ 最小/ 故障/ 元组/ 定位/ 模型/ 构造/ 、/ 已知/ 元组/ 状态/ 初始化/ 和/ 定位/ 流程/ ./ 本文/ 的/ 定位/ 模型/ 由/ 4/ 个/ 部分/ 组成/ :/ 输入/ 、/ TRT/ (/ 1/ )/ 输入/ 本文/ 方法/ 接受/ 一个/ 执行/ 过后/ 测试用例/ 集/ 和/ 参数/ 配置/ 为/ 输入/ ./ 根据/ 文献/ [/ 1/ ]/ ,/ 覆盖/ 表/ 对于/ 发现/ 交互故障/ 的/ 作用/ 很/ 明显/ ,/ 对于/ 一个/ k/ 维/ 的/ 覆盖/ 表/ ,/ 可以/ 以/ 100/ %/ 的/ 概率/ 击中/ 值/ 小于/ 等于/ k/ 的/ 元组/ 故障/ ,/ 而/ 以/ 至少/ 1/ // (/ |/ Vk/ +/ 1/ |/ ×/ |/ Vk/ +/ 2/ |/ ×/ …/ ×/ |/ Vm/ |/ )/ 的/ 概率/ 击中/ m/ 值/ 元组/ 故障/ (/ m/ >/ k/ )/ ./ 因此/ ,/ 此/ 模型/ 一般/ 情况/ 下/ 的/ 输入/ 测试用例/ 集/ 为/ 一个/ 覆盖/ 表/ ./ 不失/ 一般性/ ,/ 我们/ 将/ 所有/ 参数/ 的/ 可/ 取值/ 映射/ 到/ 从/ 1/ ~/ Maxi/ (/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ )/ 连续/ 的/ 整数/ 值上/ ,/ 其中/ Maxi/ =/ ai/ ,/ 相应/ 的/ 我们/ 将/ 参数/ 配置/ 设/ 为/ 一个/ Maxi/ (/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ )/ 的/ 数组/ ./ 同样/ 我们/ 将/ 测试用例/ 集中/ 的/ 具体/ 参数/ 配置/ 值/ 映射/ 到/ 整数/ 值上/ ./ 表/ 2/ 和表/ 3/ 分别/ 给出/ 了/ 参数/ 配置/ 和/ 执行/ 过后/ 的/ 测试用例/ 集/ ./ Page5/ 参数/ 1/ 参数/ 2/ 参数/ 3/ 参数/ 43/ 测试/ ID11211/ 通过/ 21322/ 通过/ 31133/ 通过/ 42223/ 通过/ 52331/ 失败/ 62112/ 通过/ 73232/ 通过/ 83313/ 通过/ 93121/ 通过/ (/ 2/ )/ 元组/ 关系/ 树/ 的/ 构造/ 得到/ 模型/ 的/ 输入/ 后/ ,/ 我们/ 对/ 引发/ 故障/ 的/ 测试用例/ 构建/ 一个/ 元组/ 关系/ 树/ ,/ 此树/ 将/ 所有/ 候选/ 元组/ (/ 可能/ 是/ 最小/ 故障/ 元组/ )/ 尽可能/ 联系/ 起来/ ,/ 为/ 接下来/ 的/ 定位/ 提供/ 两个/ 信息/ :/ ①/ 所有/ 需要/ 分析/ 的/ 元组/ ;/ ②/ 这些/ 元组/ 之间/ 的/ 关系/ ./ 对于/ 表/ 3/ 中/ 第/ 5/ 条/ 失败/ 的/ 测试用例/ ,/ 我们/ 构造/ 如图/ 3/ 的/ 元组/ 关系/ 树/ ./ (/ 3/ )/ 初始化/ 已知/ 元组/ 利用/ 已/ 执行/ 的/ 覆盖/ 表/ 和/ 相关/ 定义/ 我们/ 可以/ 确定/ TRT/ 中/ 部分/ 元组/ 为/ 故障/ 元组/ 或/ 正确/ 元组/ ./ 首先/ ,/ 可以/ 得知/ 树中/ 的/ 顶部/ 元组/ 必定/ 是/ 故障/ 元组/ ./ 因为/ 所有/ 包含/ 此/ 元组/ 的/ 测试用例/ 都/ 引发/ 了/ 故障/ ,/ 事实上/ ,/ 所有/ 包含/ 此/ 元组/ 的/ 测试用例/ 只有/ 唯一/ 的/ 一个/ ,/ 就/ 为/ 该/ 元组/ 对应/ 的/ 测试用例/ ./ 初始/ 工作/ 还/ 需要/ 利用/ 到/ 覆盖/ 表中/ 所有/ 通过/ 的/ 测试用例/ ,/ 根据/ 定义/ 3/ ,/ 我们/ 将/ 树/ 中/ 所有/ 出现/ 在/ 通过/ 的/ 测试用例/ 中/ 的/ 元组/ 标记/ 为/ 正确/ 元组/ ./ 此/ 步骤/ 可以/ 减少/ 树中/ 需要/ 分析/ 的/ 元组/ ,/ 从而/ 减少/ 了/ 所/ 需/ 生成/ 附加/ 测试用例/ 的/ 个数/ ./ 对于/ 上述/ 例子/ ,/ 初始化/ 之后/ 可/ 得到/ 图/ 4/ 所/ 表达/ 的/ 元组/ 关系/ 树/ ./ 图中树/ 的/ 根/ 节点/ 所/ 代表/ 的/ 元组/ 标记/ 为/ 故障/ 元组/ ,/ 而/ 由于/ 所有/ 叶子/ 节点/ 所/ 代表/ 的/ 元组/ 都/ 在/ 通过/ 的/ 测试用例/ 中/ 出现/ 过/ ,/ 因此/ 都/ 标记/ 为/ 正确/ 元组/ ./ (/ 4/ )/ 定位/ 流程/ 根据/ 最小/ 故障/ 的/ 定义/ ,/ 要/ 确定/ 一个/ 元组/ 为/ 最小/ 故障/ 元组/ ,/ 我们/ 需要/ 确定/ 此/ 元组/ 是/ 故障/ 元组/ ,/ 并且/ 还要/ 能够/ 确定/ 其/ 所有/ 子/ 元组/ 都/ 为/ 正确/ 元组/ ./ 那么/ 仅/ 有/ 上述/ 3/ 步/ 还/ 不足以/ 定位/ 出/ 最小/ 故障/ 元组/ ,/ 因为/ 上述/ 元组/ 关系/ 树中/ 还有/ 很多/ 元组/ 节点/ 仍/ 是/ 未知/ 节点/ ./ 因此/ 若/ 要/ 实现/ 定位/ 出/ 测试用例/ 中/ 的/ 最小/ 故障/ 元组/ ,/ 就/ 需要/ 通过/ 某种/ 方法/ 来/ 确定/ TRT/ 中/ 所有/ 的/ 未知/ 元组/ 是/ 故障/ 元组/ 还是/ 正确/ 元组/ ./ 为了/ 能够/ 方便/ 确定/ 元组/ 状态/ ,/ 我们/ 将/ 引入/ 如下/ 假设/ ./ 假设/ 1/ ./ 每次/ 生成/ 的/ 附加/ 测试用例/ 不会/ 引入/ 新/ 的/ 最小/ 故障/ ./ 根据/ 这个/ 假设/ ,/ 我们/ 可以/ 得出/ 如下/ 引理/ ./ 引理/ 1/ ./ 对于/ 一个/ 待测/ 元组/ ,/ 生成/ 的/ 含有/ 此/ 元组/ 的/ 附加/ 测试用例/ 如果/ 引发/ 故障/ ,/ 那么/ 此待测/ 元组/ 必为/ 故障/ 元组/ ./ 证明/ ./ 假设/ 如果/ 这个/ 待测/ 元组/ 不是/ 故障/ 元组/ ,/ 根据/ 定理/ 4/ ,/ 其/ 所有/ 子/ 元组/ 也/ 都/ 不是/ 故障/ 元组/ ,/ 由于/ 最小/ 故障/ 的/ 存在/ 性/ [/ 2/ ]/ ,/ 那么/ 这个/ 测试用例/ 必定/ 存在/ 其他/ 新/ 的/ 最小/ 故障/ ./ 这/ 与/ 假设/ 矛盾/ ,/ 因此/ 待测/ 元组/ 必为/ 故障/ 元组/ ./ 有/ 了/ 如/ 上/ 假设/ 和/ 引理/ 之后/ ,/ 我们/ 给出/ 此/ 方法/ 的/ 定位/ 过程/ 的/ 描述/ (/ 过程/ 1/ )/ ./ 此/ 方法/ 首先/ 判断/ 有没有/ 未知/ 元组/ 需要/ 分析/ (/ 行/ 1/ )/ ,/ 然后/ 从/ 这些/ 未知/ 元组/ 中/ 挑选出/ 一个/ (/ 行/ 2/ )/ ./ 之后/ 将/ 生成/ 一个/ 测试用例/ 包含/ 此/ 元组/ (/ 行/ 3/ )/ 并且/ 执行/ (/ 行/ 4/ )/ ./ 如果/ 测试用例/ 引发/ 故障/ ,/ 那么/ 就/ 设此/ 元组/ 和/ 其/ 所有/ 父/ 元组/ 为/ 故障/ 元组/ (/ 行/ 5/ ~/ 9/ )/ 如果/ 测试用例/ 通过/ 就/ 设此/ 元组/ 和/ 其/ 所有/ 子/ 元组/ 为/ 正确/ 元组/ (/ 行/ 10/ ~/ 14/ )/ ./ 过程/ 1/ ./ 定位/ 过程/ ./ 1/ ./ WHILEunknown/ _/ tuples/ ≠/ / Do2/ ./ tuple/ =/ choose/ (/ unknown/ _/ tuples/ )/ 3/ ./ test/ _/ config/ =/ gen/ _/ extra/ (/ tuple/ )/ 4/ ./ result/ =/ exec/ (/ test/ _/ config/ )/ 5/ ./ IFresult/ =/ =/ failTHEN6/ ./ set/ (/ tuple/ ,/ bug/ )/ Page67/ ./ FOReach/ _/ fatheroftupleDO8/ ./ set/ (/ each/ _/ father/ ,/ bug/ )/ 9/ ./ ENDFOR10/ ./ ELSE11/ ./ set/ (/ tuple/ ,/ right/ )/ 12/ ./ FOReach/ _/ childoftupleDO13/ ./ set/ (/ each/ _/ child/ ,/ right/ )/ 14/ ./ ENDFOR15/ ./ ENDIF16/ ./ ENDWHILE/ 假设/ 通过/ 定位/ 流程/ ,/ 我们/ 的/ TRT/ 演变成/ 图/ 5/ 的/ 形式/ ./ 此时/ TRT/ 中/ 所有/ 元组/ 都/ 已经/ 得到/ 确定/ ,/ 根据/ 最小/ 故障/ 元组/ 的/ 定义/ ,/ 对此/ 树/ 遍历/ 后/ 很/ 容易/ 发现/ [/ 2/ ,/ -/ ,/ 3/ ,/ -/ ]/ 和/ [/ -/ ,/ 3/ ,/ 3/ ,/ 1/ ]/ 就是/ 最小/ 故障/ 元组/ ./ 44/ 种/ 选择/ 策略/ 上/ 一节/ 介绍/ 了/ 定位/ 的/ 基本/ 流程/ ,/ 其中/ 在/ 定位/ 方法/ 中有/ 一个/ 非常/ 重要/ 的/ 步骤/ 就/ 是从/ 剩下/ 的/ 未知/ 元组/ 中/ 挑选/ 一个/ 待测/ 元组/ 用于/ 分析/ ./ 如果/ 剩余/ 的/ 未知/ 元组/ 个数/ 很多/ ,/ 那么/ 这个/ 步骤/ 将会/ 很大/ 程度/ 上/ 影响/ 本文/ 算法/ 的/ 性能/ ./ 本节/ 我们/ 将/ 给出/ 4/ 种/ 不同/ 的/ 挑选/ 策略/ ./ 4.1/ 深度/ 优先/ 深度/ 优先/ 算法/ 的/ 伪码/ 如/ 过程/ 2/ 所示/ ./ 深度/ 优先/ 策略/ 首先/ 构造/ 一个/ 具有/ 先后顺序/ 的/ 待测/ 元组/ 列表/ (/ 行/ 3/ ~/ 5/ )/ ,/ 这个/ 列表/ 中/ 所有/ 元组/ 遵循/ 着/ TRT/ 中/ 节点/ 深度/ 优先/ 的/ 顺序/ (/ 后序/ )/ 依次/ 排列/ ./ 选择/ 时/ 挑选/ 列表/ 中/ 的/ 第/ 1/ 个/ 未知/ 元组/ 用于/ 测试/ (/ 行/ 15/ ~/ 21/ )/ ./ 过程/ 2/ ./ 深度/ 优先/ 法/ ./ 1/ ./ list/ =/ [/ ]/ // // 元组/ 集合/ 2/ ./ // / / 构造/ 依/ 深度/ 优先/ 排序/ 的/ 元组/ 集合/ / / // 3/ ./ 方法/ dep/ _/ first/ _/ construct/ :/ 4/ ./ root/ =/ TRT/ ./ root5/ ./ depthFirst/ (/ root/ )/ 6/ ./ // / / 深度/ 优先/ 算法/ (/ 后/ 向/ )/ / / // 7/ ./ 方法/ depthFirst/ (/ tuple/ )/ :/ 8/ ./ IFlist/ ./ contain/ (/ tuple/ )/ THEN9/ ./ RETURN10/ ./ ENDIF11/ ./ FOReach/ _/ direct/ _/ childoftupleDO12/ ./ depthFirst/ (/ each/ _/ direct/ _/ child/ )/ 13/ ./ list/ ./ append/ (/ tuple/ )/ 14/ ./ ENDFOR15/ ./ // / / 挑选/ 方法/ / / // 16/ ./ 方法/ choose/ :/ 17/ ./ tuple/ =/ null/ ;/ 18/ ./ WHILEtuple/ =/ =/ null/ ‖/ !/ tuple/ ./ isUnkownDO19/ ./ tuple/ =/ list/ ./ next/ (/ )/ 20/ ./ ENDWHILE21/ ./ RETURNtuple/ 例如/ ,/ 对于/ 图/ 4/ 中/ 初始化/ 之后/ 的/ TRT/ ,/ 我们/ 按照/ 深度/ 优先/ (/ 后序/ )/ 的/ 顺序排列/ 元组/ ,/ 结果/ 为/ {/ [/ 2/ ,/ -/ ,/ -/ ,/ -/ ]/ ,/ [/ -/ ,/ 3/ ,/ -/ ,/ -/ ]/ ,/ [/ 2/ ,/ 3/ ,/ -/ ,/ -/ ]/ ,/ [/ -/ ,/ -/ ,/ 3/ ,/ -/ ]/ ,/ [/ 2/ ,/ -/ ,/ 3/ ,/ -/ ]/ ,/ [/ -/ ,/ 3/ ,/ 3/ ,/ -/ ]/ ,/ [/ 2/ ,/ 3/ ,/ 3/ ,/ -/ ]/ ,/ [/ -/ ,/ -/ ,/ -/ ,/ 1/ ]/ ,/ [/ 2/ ,/ -/ ,/ -/ ,/ 1/ ]/ ,/ [/ -/ ,/ 3/ ,/ -/ ,/ 1/ ]/ ,/ [/ 2/ ,/ 3/ ,/ -/ ,/ 1/ ]/ ,/ [/ -/ ,/ -/ ,/ 3/ ,/ 1/ ]/ ,/ [/ 2/ ,/ -/ ,/ 3/ ,/ 1/ ]/ ,/ [/ -/ ,/ 3/ ,/ 3/ ,/ 1/ ]/ ,/ [/ 2/ ,/ 3/ ,/ 3/ ,/ 1/ ]/ }/ ,/ 然后/ 选择/ 第/ 1/ 个/ 未/ 被/ 确定/ 的/ 元组/ —/ —/ —/ [/ 2/ ,/ 3/ ,/ -/ ,/ -/ ]/ ./ 选择/ 该/ 元组/ 之后/ ,/ 执行/ 的/ 步骤/ 如/ 过程/ 1/ 所示/ 的/ 流程/ 相同/ ,/ 即先/ 对/ [/ 2/ ,/ 3/ ,/ -/ ,/ -/ ]/ 生成/ 一条/ 附加/ 测试用例/ ,/ 这/ 条/ 附加/ 测试用例/ 应/ 与/ 原/ 测试用例/ 尽量/ 不同/ ,/ 我们/ 不妨/ 设/ 为/ (/ 2/ ,/ 3/ ,/ 2/ ,/ 2/ )/ ,/ 执行/ 这/ 条/ 测试用例/ ,/ 如果/ 执行/ 结果/ 通过/ ,/ 则/ 设此/ 元组/ 和/ 此/ 元组/ 的/ 所有/ 子/ 元组/ —/ —/ —/ [/ 2/ ,/ -/ ,/ -/ ,/ -/ ]/ 、/ [/ -/ ,/ 3/ ,/ -/ ,/ -/ ]/ (/ 这/ 两个/ 元组/ 在/ 初始化/ 时/ 已经/ 被/ 设为/ 正确/ 元组/ ,/ 因此/ 无需/ 重复/ 设置/ )/ 为/ 正确/ 元组/ ,/ 反之/ ,/ 设此/ 元组/ 和/ 此/ 元组/ 的/ 所有/ 父/ 元组/ —/ —/ —/ [/ 2/ ,/ 3/ ,/ 3/ ,/ -/ ]/ 、/ [/ 2/ ,/ 3/ ,/ -/ ,/ 1/ ]/ 、/ [/ 2/ ,/ 3/ ,/ 3/ ,/ 1/ ]/ (/ 其中/ [/ 2/ ,/ 3/ ,/ 3/ ,/ 1/ ]/ 在/ 初始化/ 已/ 被/ 设为/ 故障/ 元组/ ,/ 无需/ 再设/ )/ 为/ 故障/ 元组/ ./ 此后/ 继续/ 选择/ 元组/ 测试/ 直到/ TRT/ 中/ 没有/ 未/ 被/ 确定/ 元组/ 为止/ ./ 4.2/ 广度/ 优先/ 广度/ 优先/ 算法/ 伪码/ 如/ 过程/ 3/ 所示/ ,/ 它/ 的/ 算法/ 流程/ 和/ 深度/ 优先/ 算法/ 很/ 相似/ ,/ 除了/ 构造/ 先后顺序/ 列表/ 时/ ,/ 此/ 方法/ 将/ 所有/ 的/ 元组/ 按照/ 广度/ 优先/ 的/ 策略/ 排列/ ./ 同样/ 对于/ 图/ 4/ 中/ 初始化/ 之后/ 的/ TRT/ ,/ 这里/ 我们/ 按照/ 广度/ 优先/ 的/ 顺序排列/ 元组/ ,/ 结果/ 为/ {/ [/ 2/ ,/ 3/ ,/ 3/ ,/ 1/ ]/ ,/ [/ 2/ ,/ 3/ ,/ 3/ ,/ -/ ]/ ,/ [/ 2/ ,/ 3/ ,/ -/ ,/ 1/ ]/ [/ 2/ ,/ -/ ,/ 3/ ,/ 1/ ]/ ,/ [/ -/ ,/ 3/ ,/ 3/ ,/ 1/ ]/ ,/ [/ 2/ ,/ 3/ ,/ -/ ,/ -/ ]/ ,/ [/ 2/ ,/ -/ ,/ 3/ ,/ -/ ]/ ,/ [/ 2/ ,/ -/ ,/ -/ ,/ 1/ ]/ ,/ [/ -/ ,/ 3/ ,/ 3/ ,/ -/ ]/ ,/ [/ -/ ,/ 3/ ,/ -/ ,/ 1/ ]/ ,/ [/ -/ ,/ -/ ,/ 3/ ,/ 1/ ]/ ,/ [/ 2/ ,/ -/ ,/ -/ ,/ -/ ]/ ,/ [/ -/ ,/ 3/ ,/ -/ ,/ -/ ]/ ,/ [/ -/ ,/ -/ ,/ 3/ ,/ -/ ]/ ,/ [/ -/ ,/ -/ ,/ -/ ,/ 1/ ]/ }/ ,/ 然后/ 选择/ 第/ 1/ 个/ 未/ 被/ 确定/ 的/ 元组/ —/ —/ —/ [/ 2/ ,/ 3/ ,/ 3/ ,/ -/ ]/ ./ 此后/ 步骤/ 与/ 4.1/ 节/ 相同/ ./ 过程/ 3/ ./ 广度/ 优先/ 法/ ./ 1/ ./ list/ =/ [/ ]/ 2/ ./ // / / 构造/ 依/ 广度/ 优先/ 排序/ 的/ 元组/ 集合/ / / // Page73/ ./ 方法/ breadth/ _/ first/ _/ construct/ :/ 4/ ./ queen/ =/ [/ ]/ 5/ ./ queue/ ./ append/ (/ TRT/ ./ root/ )/ 6/ ./ widthFirst/ (/ root/ )/ 7/ ./ // / / 广度/ 优先/ 算法/ / / // 8/ ./ 方法/ breadth/ _/ first/ (/ tuple/ )/ :/ 9/ ./ FOReach/ _/ tupleofqueueDO10/ ./ list/ ./ append/ (/ each/ _/ tuple/ )/ 11/ ./ queue/ _/ next/ =/ [/ ]/ 12/ ./ FOReach/ _/ tupleofqueueDO13/ ./ FOReach/ _/ direct/ _/ childofeach/ _/ tupleDO14/ ./ IF/ !/ list/ ./ contain/ (/ each/ _/ direct/ _/ child/ )/ THEN15/ ./ queue/ ./ append/ (/ each/ _/ direct/ _/ child/ )/ 16/ ./ ENDIF17/ ./ ENDFOR18/ ./ ENDFOR19/ ./ breadth/ _/ first/ (/ queue/ _/ next/ )/ 20/ ./ ENDFOR21/ ./ // / / 挑选/ 方法/ / / // 22/ ./ 方法/ choose/ :/ 23/ ./ tuple/ =/ null/ ;/ 24/ ./ WHILEtuple/ =/ =/ null/ ‖/ !/ tuple/ ./ isUnkownDO25/ ./ tuple/ =/ list/ ./ next/ (/ )/ 26/ ./ ENDWHILE27/ ./ RETURNtuple4/ ./ 3/ 贪心/ 策略/ 贪心/ 策略/ 算法/ 伪码/ 如/ 过程/ 4/ 所示/ ./ 此/ 算法/ 每次/ 挑选/ “/ 贪心/ 值/ ”/ 最大/ 的/ 待测/ 元组/ (/ 行/ 22/ ~/ 29/ )/ ./ 若/ 一个/ 元组/ 不是/ 未知/ 元组/ ,/ 其/ “/ 贪心/ 值/ ”/ 为/ -/ 1/ (/ 行/ 2/ ~/ 3/ ,/ 即/ 只/ 挑选/ 未知/ 元组/ 分析/ )/ ,/ 除此之外/ ,/ “/ 贪心/ 值/ ”/ 是/ 此/ 元组/ 未知/ 子/ 元组/ 数目/ 与/ 未知/ 父/ 元组/ 数目/ 中较/ 小/ 的/ 值/ (/ 行/ 5/ ~/ 21/ )/ ,/ 选择/ 这个/ 值/ 作为/ 贪心/ 值/ 的/ 理由/ 是/ 我们/ 想/ 通过/ 确认/ 一个/ 元组/ 后能/ 达到/ 覆盖/ 确认/ 尽可能/ 多/ 的/ 元组/ ./ 如若/ [/ 2/ ,/ 3/ ,/ -/ ,/ -/ ]/ 有/ 3/ 个/ 未知/ 父/ 元组/ 和/ 两个/ 未知/ 子/ 元组/ ,/ 当/ 此/ 元组/ 被/ 确认/ 之后/ 我们/ 至少/ 可以/ 覆盖/ 确认/ 两个/ 元组/ ./ 同样/ 的/ 对于/ [/ 2/ ,/ 3/ ,/ 2/ ,/ -/ ]/ 若有/ 3/ 个/ 未知/ 子/ 元组/ 和/ 一个/ 未知/ 父/ 元组/ ,/ 在/ 其/ 确认/ 之后/ 我们/ 会/ 至少/ 覆盖/ 确认/ 一个/ 元组/ ./ 因此/ 元组/ [/ 2/ ,/ 3/ ,/ -/ ,/ -/ ]/ 的/ “/ 贪心/ 值/ ”/ 大于/ [/ 2/ ,/ 3/ ,/ 2/ ,/ -/ ]/ ,/ 在/ 挑选/ 时/ 优先/ 挑选/ 元组/ [/ 2/ ,/ 3/ ,/ -/ ,/ -/ ]/ ./ 过程/ 4/ ./ 贪心/ 策略/ ./ 1/ ./ 方法/ gv/ (/ tuple/ )/ :/ // // 元组/ 贪心/ 值/ 定义/ 2/ ./ IF/ !/ tuple/ ./ isUnkownTHEN3/ ./ RETURN/ -/ 14/ ./ ENDIF5/ ./ unkownChildNum/ =/ 06/ ./ unkownFatherNum/ =/ 07/ ./ FOReach/ _/ childoftupleDO8/ ./ IFeach/ _/ child/ ./ isUnknownTHEN9/ ./ unkownChildNum/ ++/ 10/ ./ ENDIF11/ ./ ENDFOR12/ ./ FOReach/ _/ fatheroftupleDO13/ ./ IFeach/ _/ child/ ./ isUnknownTHEN14/ ./ unkownFatherNum/ ++/ 15/ ./ ENDIF16/ ./ ENDFOR17/ ./ IFunkownChildNum/ >/ unkownFatherNum/ :/ 18/ ./ RETURNunkownFatherNum19/ ./ ELSE20/ ./ RETURNunkownChildNum21/ ./ ENDIF22/ ./ 方法/ choose/ :/ 23/ ./ tuple/ =/ TRT/ ./ root24/ ./ FOReach/ _/ tupleofTRT/ :/ 25/ ./ IFgv/ (/ each/ _/ tuple/ )/ >/ gv/ (/ tuple/ )/ :/ 26/ ./ tuple/ =/ each/ _/ tuple27/ ./ ENDIF28/ ./ ENDFOR29/ ./ RETURNtuple/ 事实上/ ,/ 每次/ 迭代/ 后/ 元组/ 的/ “/ 贪心/ 值/ ”/ 都/ 会/ 变化/ ./ 因为/ 一旦/ 我们/ 确认/ 了/ 某个/ 元组/ ,/ 那么/ TRT/ 中/ 某些/ 元组/ 的/ 未知/ 子/ 元组/ 和/ 未知/ 父/ 元组/ 数目/ 会/ 相应/ 的/ 发生变化/ ./ 4.4/ 路径/ 法/ 过程/ 5/ ./ 路径/ 法/ ./ 1/ ./ currentPath/ =/ [/ ]/ // // 当前/ 由/ 元组/ 构成/ 的/ 路径/ 2/ ./ head/ =/ 0/ // // 路径/ 头/ 结点/ 3/ ./ middle/ =/ 0/ // // 路径/ 中间/ 节点/ 为了/ 方便/ 描述/ 路径/ 法/ ,/ 我们/ 先/ 介绍/ 如下/ 3/ 个/ 定义/ ./ 定义/ 6/ ./ 路径/ 是/ TRT/ 中/ 的/ 一个/ 元组/ 序列/ ,/ 这个/ 序列/ 的/ 每/ 两个/ 相邻/ 的/ 元组/ 中/ ,/ 前/ 一个/ 都/ 是/ 后/ 一个/ 的/ 直系/ 父/ 元组/ ,/ 后/ 一个/ 是/ 前/ 一个/ 的/ 直系/ 子/ 元组/ ./ [/ 2/ ,/ -/ ,/ -/ ,/ -/ ]/ 就是/ 一条/ 路径/ ./ 如/ [/ 2/ ,/ 2/ ,/ 3/ ,/ 1/ ]/ →/ [/ 2/ ,/ 2/ ,/ 3/ ,/ -/ ]/ →/ [/ 2/ ,/ -/ ,/ 3/ ,/ -/ ]/ →/ 定义/ 7/ ./ 我们/ 称/ 一条/ 路径/ 为/ 未确定/ 路径/ ,/ 当且/ 仅/ 当/ 这条/ 路径/ 所/ 包含/ 的/ 所有/ 元组/ 都/ 为/ 未确定/ 元组/ ./ 定义/ 8/ ./ 我们/ 把/ 一个/ TRT/ 所有/ 的/ 未确定/ 路径/ 中/ ,/ 拥有/ 元组/ 数最多/ 的/ 那条/ 路径/ 称为/ 此/ TRT/ 的/ 最长/ 未确定/ 路径/ ./ 这个/ 策略/ 的/ 伪码/ 如/ 过程/ 5/ 所示/ ./ “/ currentPath/ ”/ 变量/ 存储/ 着/ 一条/ 路径/ ,/ 而/ head/ ,/ middle/ ,/ tail/ 是/ 指向/ 这/ 条/ 路径/ 中/ 的/ 元组/ 的/ 指针/ ,/ 其中/ head/ 和/ tail/ 之间/ 的/ 所有/ 元组/ 都/ 是/ 未/ 被/ 确定/ 元组/ ./ 在/ 选择/ 元组/ 步骤/ (/ 行/ 20/ ~/ 23/ )/ 此/ 策略/ 需要/ 先要/ 做/ 一个/ 预处理/ (/ 行/ 21/ )/ 然后/ 再/ 挑选/ 路径/ 中/ middle/ 所/ 指向/ 的/ 元组/ (/ 行/ 23/ )/ ./ Page84/ ./ tail/ =/ 05/ ./ lastChosed/ =/ null/ // // 上次/ 挑选/ 的/ 元组/ 6/ ./ 方法/ reset/ :/ 7/ ./ currentPath/ =/ get/ _/ longest/ _/ path/ (/ TRT/ )/ 8/ ./ head/ =/ middle/ =/ 09/ ./ tail/ =/ currentPath/ ./ size10/ ./ 方法/ choosingPreprocess/ :/ 11/ ./ IFlastChosed/ ./ isRightTHEN12/ ./ tail/ =/ middle/ -/ 113/ ./ ELSE14/ ./ head/ =/ middle/ +/ 115/ ./ ENDIF16/ ./ middle/ =/ (/ head/ +/ tail/ )/ // 217/ ./ IFtail/ </ headTHEN18/ ./ reset/ (/ )/ 19/ ./ ENDIF20/ ./ 方法/ choose/ :/ 21/ ./ choosingPreprocess/ (/ )/ 22/ ./ lastChosed/ =/ currentPath/ [/ middle/ ]/ 23/ ./ RETURNlastChosed/ 由于/ deltadebugging/ [/ 5/ ]/ 在/ 搜索/ 故障/ 空间/ 上/ 的/ 高效性/ ,/ 因此/ 在/ 预处理/ 步骤/ (/ 行/ 10/ ~/ 19/ )/ 中/ 我们/ 根据/ 上/ 一次/ 迭代/ 的/ 结果/ 使用/ 二分法/ ,/ 当/ 上/ 一次/ 挑选/ 的/ 元组/ 被/ 确认/ 为/ 正确/ 元组/ ,/ 那么/ 其/ 所有/ 的/ 子/ 元组/ 都/ 为/ 正确/ 元组/ ,/ 对应/ 这/ 条/ 路径/ 中/ 位于/ 此/ 元组/ 后面/ 的/ 元组/ 都/ 将/ 会/ 被/ 标记/ 为/ 正确/ 元组/ ,/ 之后/ 我们/ 将/ tail/ 指向/ 位于/ middle/ 所指/ 元组/ 的/ 前/ 一个/ 元组/ (/ 行/ 11/ ~/ 12/ )/ 以/ 保证/ tail/ 和/ head/ 之间/ 的/ 元组/ 都/ 为/ 未/ 被/ 确定/ 元组/ ,/ 相反/ ,/ 如果/ 上/ 一次/ 所/ 选/ 元组/ 为/ 错误/ 元组/ ,/ 那么/ 我们/ 就/ 设/ 路径/ 中/ 位于/ 此/ 元组/ 前面/ 的/ 元组/ 为/ 故障/ 元组/ ,/ 相应/ 的/ 我们/ 将/ head/ 指向/ 位于/ middle/ 所指/ 元组/ 的/ 后/ 一个/ 元组/ (/ 行/ 13/ ~/ 14/ )/ ./ 然后/ 根据/ 二分法/ 将/ middle/ 指向/ tail/ 和/ head/ 中间/ 的/ 元组/ (/ 行/ 16/ )/ ./ 如果/ 当前/ 路径/ 里/ 所有/ 的/ 元组/ 都/ 已/ 被/ 确认/ ,/ 我们/ 将会/ 重新/ 挑选/ 一条/ 最长/ 未/ 被/ 确定/ 路径/ (/ 行/ 17/ ~/ 19/ )/ ./ 在/ 重新/ 设置/ 步骤/ (/ 行/ 6/ ~/ 9/ )/ 中/ ,/ 我们/ 将会/ 先/ 找到/ 一条/ 最长/ 未/ 被/ 确定/ 路径/ (/ 限于/ 篇幅/ ,/ 这里/ 不/ 给出/ 如何/ 得出/ 最长/ 未/ 被/ 确定/ 路径/ 的/ 算法/ )/ ,/ 然后/ 设/ head/ 指向/ 这/ 条/ 路径/ 的/ 第一个/ 元组/ (/ 行/ 8/ )/ ,/ tail/ 指向/ 这/ 条/ 路径/ 的/ 最后/ 一个/ 元组/ (/ 行/ 9/ )/ ./ middle/ 第一次/ 也/ 指向/ 路径/ 的/ 第一个/ 元组/ (/ 行/ 8/ )/ ,/ 这/ 是因为/ 我们/ 想要/ 尽快/ 得知/ 这/ 条/ 路径/ 中/ 是否/ 含有/ 故障/ 元组/ ./ 如/ 对于/ 一条/ 路径/ {/ [/ 1/ ,/ 2/ ,/ 3/ ,/ 4/ ,/ -/ ]/ ,/ [/ 1/ ,/ 2/ ,/ 3/ ,/ -/ ,/ -/ ]/ [/ 1/ ,/ -/ ,/ 3/ ,/ -/ ,/ -/ ]/ ,/ [/ 1/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ]/ }/ ,/ 我们/ 首先/ 选择/ [/ 1/ ,/ 2/ ,/ 3/ ,/ 4/ ,/ -/ ]/ 作为/ middle/ 指向/ 的/ 元组/ ,/ 如果/ 这个/ 元组/ 是/ 正确/ 元组/ ,/ 那么/ 我们/ 将/ 立即/ 得知/ 这/ 条/ 路径/ 没有/ 故障/ 元组/ ,/ 而/ 若/ 在/ 第一次/ 挑选/ 元组/ 过后/ ,/ 发现/ 此/ 元组/ 为/ 故障/ 元组/ ,/ 那么/ 下面/ 则/ 会/ 使用/ 二分/ 设置/ middle/ 指向/ 中间/ 的/ 元组/ —/ —/ —/ [/ 1/ ,/ -/ ,/ 3/ ,/ -/ ,/ -/ ]/ ./ 5/ 实验/ 我们/ 采用/ 两种/ 类型/ 的/ 实验/ ,/ 模拟实验/ 和/ 真实/ 软件/ 实验/ ./ 5.1/ 模拟实验/ 在/ 模拟实验/ 中/ ,/ 我们/ 假设/ 待/ 测系统/ SUT/ 受/ 8/ 个/ 参数/ 影响/ ,/ 每个/ 参数/ 有/ 3/ 个/ 可选/ 配置/ 值/ ./ 我们/ 做/ 3/ 组/ 模拟实验/ ,/ 分别/ 考虑/ 如下/ 3/ 种/ 故障/ 类型/ ./ 第/ 1/ 组/ 实验/ ./ 假设/ 出错/ 的/ 测试用例/ 中/ 只/ 包含/ 单个/ t/ 值/ 故障/ 元组/ (/ t/ =/ 2/ ,/ 3/ ,/ 4/ ,/ 以下/ 两组/ 实验/ 类似/ )/ ./ 例如/ ,/ (/ 1/ ,/ 2/ ,/ 2/ ,/ 2/ ,/ 1/ ,/ 1/ ,/ 2/ ,/ 3/ )/ 只/ 包含/ [/ 1/ ,/ 2/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ]/ 这/ 一个/ 2/ 值/ 故障/ 元组/ ,/ 其余/ 元组/ 都/ 是/ 正确/ 元组/ ./ 当该/ 错误/ 的/ 测试用例/ 只/ 包含/ 一个/ t/ 值/ 故障/ 元组/ 时/ ,/ 所有/ 可能/ 的/ t/ 值/ 故障/ 元组/ 有/ Ct/ 时/ ,/ C28/ =/ 28/ ,/ t/ =/ 3/ 时/ ,/ C3/ 我们/ 对/ 1/ 个/ 测试用例/ 植入/ 1/ 个/ 单个/ 故障/ 后/ ,/ 用/ 4/ 个/ 选择/ 算法/ 对/ 这个/ 故障/ 测试用例/ 进行/ 定位/ ,/ 将/ 定位/ 所/ 需/ 的/ 额外/ 测试用例/ 个数/ 记录下来/ ./ 此外/ 我们/ 还/ 添加/ 了/ 随机/ 选择/ 这一/ 策略/ 作为/ 一个/ benchmark/ ,/ 对/ 随机/ 选择/ 策略/ (/ 即/ 每次/ 随机/ 挑选/ 一个/ 未知/ 元组/ 测试/ )/ 我们/ 进行/ 了/ 100/ 次/ 实验/ ,/ 取所/ 需/ 额外/ 测试用例/ 数/ 的/ 平均值/ 作为/ 结果/ 记录下来/ ./ 我们/ 依次/ 植入/ 所有/ t/ 值/ 故障/ (/ t/ =/ 2/ ,/ 3/ ,/ 4/ )/ ,/ 每次/ 都/ 按/ 如/ 上/ 方法/ 执行/ 分析/ ,/ 最后/ 我们/ 将/ 所有/ 结果/ 以盒/ 图/ 的/ 形式/ 显示/ ,/ 即/ 对/ 每种/ 算法/ 显示/ 出此/ 算法/ 所/ 需要/ 的/ 额外/ 测试用例/ 数/ 的/ 分布/ 情况/ ./ 实验/ 结果/ 见图/ 6/ (/ a/ )/ ./ 第/ 2/ 组/ 实验/ ./ 假设/ 出错/ 的/ 测试用例/ 中/ 包含/ 两个/ 有/ 重叠/ 的/ t/ 值/ 故障/ 元组/ ./ 此组/ 实验/ 中/ 故障/ 的/ 测试用例/ 包含/ 两个/ t/ 值/ 故障/ 元组/ ,/ 且/ 这/ 两个/ 故障/ 元组/ 至少/ 含有/ 一个/ 重叠/ 元素/ ./ 如/ (/ 1/ ,/ 2/ ,/ 2/ ,/ 2/ ,/ 1/ ,/ 1/ ,/ 2/ ,/ 3/ )/ 包含/ 两个/ 如下/ 故障/ :/ [/ 1/ ,/ 2/ ,/ 2/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ]/ ,/ [/ -/ ,/ -/ ,/ 2/ ,/ 2/ ,/ -/ ,/ 1/ ,/ -/ ,/ -/ ]/ ./ 我们/ 循环/ 取/ 两个/ 单个/ 故障/ 元组/ (/ 没有/ 重复/ )/ ,/ 保留/ 有/ 重叠/ 元素/ 的/ 所有/ 两个/ 故障/ 元组/ 对/ ,/ 并/ 依次/ 植入/ 这样/ 的/ 故障/ 对/ ./ 每次/ 植入/ 故障/ 对后/ ,/ 我们/ 采用/ 如/ 第/ 1/ 组/ 实验/ 中/ 的/ 方法/ 记录/ 4/ 种/ 选择/ 策略/ 和/ 随机/ 策略/ 的/ 所/ 需/ 额外/ 测试用例/ 个数/ ,/ 实验/ 结果/ 见图/ 6/ (/ b/ )/ ./ 第/ 3/ 组/ 实验/ ./ 假设/ 出错/ 测试用例/ 中/ 包含/ 两个/ 没有/ 重叠/ 的/ t/ 值/ 故障/ 元组/ ./ Page9/ 图/ 6/ 模拟实验/ 统计/ 结果/ 此组/ 实验/ 中/ 故障/ 的/ 测试用例/ 包含/ 两个/ t/ 值/ 故障/ 元组/ ,/ 且/ 这/ 两个/ 故障/ 元组/ 没有/ 重叠/ 元素/ ./ 如/ (/ 1/ ,/ 2/ ,/ 2/ ,/ 2/ ,/ 1/ ,/ 1/ ,/ 2/ ,/ 3/ )/ 包含/ 两个/ 如下/ 故障/ 元组/ :/ [/ 1/ ,/ 2/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ]/ ,/ [/ -/ ,/ -/ ,/ 2/ ,/ 2/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ]/ ./ 与/ 第/ 2/ 组/ 实验/ 类似/ ,/ 我们/ 循环/ 取/ 两个/ 故障/ 元组/ (/ 没有/ 重复/ )/ ,/ 不同/ 的/ 是/ ,/ 这/ 一组/ 实验/ 保留/ 的/ 是/ 所有/ 没有/ 重叠/ 元素/ 的/ 元组/ 对/ ,/ 之后/ 步骤/ 和/ 第/ 2/ 组/ 实验/ 相同/ ,/ 实验/ 结果/ 见图/ 6/ (/ c/ )/ ./ 根据/ 以上/ 3/ 组/ 实验/ ,/ 我们/ 可以/ 看出/ 就/ 所/ 需/ 额外/ 测试用例/ 个数/ 而言/ (/ 越少/ 越/ 好/ )/ ,/ 深度/ 优先/ 性能/ 在/ 所有/ 情况/ 下/ 都/ 是/ 最差/ 的/ ,/ 路径/ 法则/ 相反/ ,/ 在/ 所有/ 情况/ 下/ 都/ 是/ 最优/ 的/ ,/ 其余/ 3/ 种/ 算法/ :/ 随机/ 选择/ 、/ 广度/ 优先/ 和/ 贪心/ 则/ 差不多/ ,/ 而/ 就/ 稳定性/ ,/ 即/ 对于/ 1/ 个/ 测试用例/ ,/ 不同/ 故障/ 元组/ (/ 同值/ )/ 对/ 定位/ 结果/ 的/ 影响/ 而言/ ,/ 贪心/ 算法/ 和/ 路径/ 法不太/ 稳定/ ,/ 受此/ 影响/ 较大/ ,/ 而/ 随机/ 选择/ 、/ 深度/ 优先/ 和/ 广度/ 优先/ 则/ 受此/ 影响/ 较/ 小/ ./ 5.2/ 真实/ 软件/ 实验/ 我们/ 使用/ 交通/ 避免/ 碰撞/ 系统/ (/ TCAS/ )/ 作为/ 待测/ 软件/ [/ 6/ ]/ ,/ 这是/ 一个/ 包含/ 多个/ C/ 模块/ 的/ benchmark/ 程序/ ,/ 曾/ 被/ 用作/ 其他/ 软件测试/ 方法/ [/ 7/ -/ 10/ ]/ 的/ 测试/ 对象/ ./ 这个/ 程序/ 有/ 12/ 个/ 输入/ ,/ 文献/ [/ 7/ ]/ 将/ 每个/ 参数/ 的/ 输入/ 空间/ 划分/ 为/ 若干个/ 等价/ 类/ ,/ 我们/ 将/ 采用/ 和/ 文献/ [/ 7/ ]/ 相同/ 的/ 输入/ 配置/ ,/ 如图/ 7/ 所示/ ./ 此/ 程序/ 的/ 输出/ 是/ alt/ _/ sep/ ,/ 有/ 3/ 个/ 取值/ ./ 5.2/ ./ 1/ 实验设计/ 实验/ 中/ ,/ 我们/ 将/ 采用/ 此/ 软件/ 的/ 一个/ 正确/ 的/ 版本/ 和/ 一个/ 故障/ 版本/ (/ 植入/ 和/ 文献/ [/ 10/ ]/ 相同/ 的/ 故障/ )/ 作为/ 实验/ 对象/ ./ 对于/ 一个/ 具体/ 输入/ 我们/ 通过观察/ 故障/ 版本/ 和/ 正确/ 版本/ 的/ 结果/ 是否/ 一致/ 来/ 判断/ 此/ 输入/ 是否/ 引发/ 故障/ ./ 我们/ 将/ 采用/ 本文/ 的/ 定位/ 分析/ 系统对/ TCAS/ 故障/ 版本/ 分析/ 故障/ 原因/ ./ 5.2/ ./ 2/ 实验/ 步骤/ (/ 1/ )/ 对待/ 测/ 系统生成/ 2/ 维/ 覆盖/ 表/ 测试用例/ 集/ ./ (/ 2/ )/ 依次/ 执行/ 测试用例/ 集中/ 的/ 每条/ 测试用例/ ./ (/ 3/ )/ 对/ 这个/ 执行/ 过后/ 的/ 测试用例/ 集/ 采用/ 本文/ 中/ 的/ 定位/ 模型/ 进行/ 最小/ 故障/ 元组/ 定位/ (/ 挑选/ 策略/ 选用/ Page10/ 路径/ 法/ )/ ./ (/ 4/ )/ 分析/ 结果/ ./ 5.2/ ./ 3/ 实验/ 结果/ (/ 1/ )/ 使用/ AETG/ 工具/ [/ 11/ ]/ (/ AETG/ 是/ 一个/ 基于/ 贪心/ 策略/ 的/ 覆盖/ 表/ 生成/ 方法/ ,/ 具有/ 较/ 高/ 的/ 效率/ 和/ 广泛/ 的/ 应用/ )/ ,/ 我们/ 生成/ 了/ 一个/ 12/ ×/ 112/ 的/ 2/ 维/ 覆盖/ 表/ ;/ (/ 2/ )/ 执行/ 这个/ 覆盖/ 表/ ,/ 我们/ 得出/ 了/ 一个/ 如图/ 8/ 所示/ 的/ 错误/ 测试用例/ 和/ 其余/ 111/ 个/ 正确/ 测试用例/ ;/ Cur/ _/ Vertical/ _/ Sep/ =/ 601High/ _/ Confidence/ =/ 1Two/ _/ of/ _/ Three/ _/ Reports/ _/ Valid/ =/ 1Own/ _/ Tracked/ _/ Alt/ =/ 1Own/ _/ Tracked/ _/ Alt/ _/ Rate/ =/ 601Other/ _/ Tracked/ _/ Alt/ =/ 2Alt/ _/ Layer/ _/ Value/ =/ 0Up/ _/ Separation/ =/ 500Down/ _/ Separation/ =/ 0Other/ _/ RAC/ =/ 2Other/ _/ Capability/ =/ 2Climb/ _/ Inhibit/ =/ 1/ (/ 3/ )/ 用/ 定位/ 模型/ 系统对/ 这个/ 执行/ 过后/ 测试用例/ 集/ 进行/ 分析/ 定位/ 出/ 的/ 最小/ 故障/ 元组/ 为/ 以下/ 3/ 个/ ./ (/ a/ )/ [/ Cur/ _/ Vertical/ _/ Sep/ =/ 601/ ,/ High/ _/ Confi/ -/ dence/ =/ 1/ ,/ -/ ,/ -/ ,/ Own/ _/ Tracked/ _/ Alt/ _/ Rate/ =/ 601/ ,/ -/ ,/ Alt/ _/ Layer/ _/ Value/ =/ 0/ ,/ -/ ,/ -/ ,/ -/ ,/ Other/ _/ Capa/ -/ bility/ =/ 2/ ,/ -/ ]/ ;/ (/ b/ )/ [/ Cur/ _/ Vertical/ _/ Sep/ =/ 601/ ,/ High/ _/ Confi/ -/ dence/ =/ 1/ ,/ -/ ,/ -/ ,/ Own/ _/ Tracked/ _/ Alt/ _/ Rate/ =/ 601/ ,/ -/ ,/ -/ ,/ -/ ,/ Down/ _/ Separation/ =/ 0/ ,/ -/ ,/ Other/ _/ Capa/ -/ bility/ =/ 2/ ,/ -/ ]/ ;/ (/ c/ )/ [/ Cur/ _/ Vertical/ _/ Sep/ =/ 601/ ,/ High/ _/ Confi/ -/ dence/ =/ 1/ ,/ -/ ,/ -/ ,/ Own/ _/ Tracked/ _/ Alt/ _/ Rate/ =/ 601/ ,/ -/ ,/ -/ ,/ Up/ _/ Separation/ =/ 500/ ,/ -/ ,/ -/ ,/ Other/ _/ Capa/ -/ bility/ =/ 2/ ,/ -/ ]/ ./ 5.2/ ./ 4/ 结果/ 分析/ 两个/ 元组/ a/ ,/ b/ 相似/ 度/ (/ Sab/ )/ 的/ 计算公式/ :/ 此/ 过程/ 生成/ 了/ 29/ 条/ 额外/ 的/ 测试用例/ ./ 为了/ 评价/ 我们/ 程序/ 的/ 定位/ 结果/ ,/ 我们/ 将/ 先/ 给出/ 其中/ ,/ NumSameab/ 是/ 两个/ 元组/ 固定/ 参数值/ 相同/ 的/ 个数/ ,/ 而/ NumDiffab/ 是/ 元组/ 固定/ 参数值/ 不同/ 的/ 个数/ ,/ NumMaxab/ 为/ 两个/ 元组/ 的/ 固定/ 参数/ 个/ 数最多/ 的/ 元组/ 的/ 固定/ 参数/ 个数/ ./ 如/ 对于/ 元组/ [/ -/ ,/ 1/ ,/ 2/ ,/ -/ ]/ 和/ 元组/ [/ 2/ ,/ 1/ ,/ 1/ ,/ -/ ]/ ,/ 由于/ 他们/ 固定/ 参数值/ 相同/ 的/ 参数/ 只有/ 1/ 个/ ,/ 为/ 第/ 2/ 个/ 参数/ ,/ 都/ 取/ 1/ ,/ 而/ 固定/ 参数值/ 不同/ 的/ 也/ 只有/ 1/ 个/ ,/ 为/ 第/ 3/ 个/ 参数/ ,/ 第/ 1/ 个/ 元组/ 取/ 2/ ,/ 第/ 2/ 个/ 元组/ 取/ 1/ ,/ 而/ 固定/ 参数/ 个/ 数最多/ 的/ 是/ 第/ 2/ 个/ 元组/ ,/ 个数/ 为/ 3/ ./ 因此/ 它们/ 的/ 相似/ 度为/ (/ 1/ -/ 1/ )/ // 3/ ,/ 即/ 0/ // 3/ ./ 我们/ 将/ 实际/ 定位/ 出来/ 的/ 元组/ 和/ 测试用例/ 中/ 包含/ 的/ 真实/ 故障/ 元组/ 的/ 相似/ 度/ 称为/ 故障/ 相关性/ ,/ 也就是说/ ,/ 故障/ 相关性/ 越高/ ,/ 实际/ 定位/ 元组/ 就/ 越/ 接近/ 真实/ 的/ 故障/ 元组/ ,/ 定位/ 结果/ 也/ 就/ 越/ 精确/ ./ 为了/ 得出/ 我们/ 定位/ 结果/ 的/ 故障/ 相关性/ ,/ 我们/ 先/ 通过/ 代码/ 审查/ 分析/ ,/ 得出/ 测试用例/ 中/ 包含/ 的/ 真实/ 故障/ 元组/ 为/ [/ Cur/ _/ Vertical/ _/ Sep/ =/ 601/ ,/ High/ _/ confi/ -/ dence/ =/ 1/ ,/ -/ ,/ Own/ _/ Tracked/ _/ Alt/ =/ 1/ ,/ Own/ _/ Tracked/ _/ Alt/ _/ Rate/ =/ 601/ ,/ Other/ _/ Tracked/ _/ Alt/ =/ 2/ ,/ Alt/ _/ Layer/ _/ Value/ =/ 0/ ,/ Up/ _/ Separation/ =/ 500/ ,/ Down/ _/ Separation/ =/ 0/ ,/ -/ ,/ Other/ _/ Capability/ =/ 2/ ,/ Climb/ _/ Inhibit/ =/ 1/ ]/ ,/ 然后/ 通过/ 式/ (/ 1/ )/ 我们/ 计算/ 出/ 了/ 定位/ 结果/ 故障/ 相关性/ 的/ 值/ ,/ 结果/ 列入/ 表/ 4/ 中/ ./ 而/ 文献/ [/ 10/ ]/ 中/ 最终/ 定位/ 故障/ 元组/ 为/ [/ Cur/ _/ Vertical/ _/ Sep/ =/ 601/ ,/ High/ _/ confidence/ =/ 1/ ,/ -/ ,/ -/ ,/ Own/ _/ Tracked/ _/ Alt/ _/ Rate/ =/ 601/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ]/ ,/ 根据/ 式/ (/ 1/ )/ ,/ 其/ 故障/ 相关性/ 为/ 3/ // 10/ ,/ 即/ 定位精度/ 要/ 小于/ 本文/ 的/ 结果/ ./ 5.2/ ./ 5/ 改进/ 实验/ 仔细分析/ 源代码/ (/ 图/ 9/ )/ ,/ 我们/ 发现/ 此/ 段/ 代码/ 第/ 6/ 行/ 和/ 第/ 12/ 行/ 返回/ 了/ 同样/ 的/ 结果/ :/ alt/ _/ sep/ =/ UNRE/ -/ SOLVED/ ,/ 如果/ 没有/ 进入/ 这/ 段/ 代码段/ (/ 行/ 2/ ~/ 13/ )/ ,/ 结果/ 同样/ 是/ 返回/ alt/ _/ sep/ =/ UNRESOLVED/ ./ 这样/ 的/ 结果/ 会/ 扰乱/ 我们/ 的/ 定位/ 效果/ ,/ 因为/ 如果/ 一个/ 测试用例/ 使得/ 正确/ 版本/ 和/ 错误/ 版本/ 执行/ 不同/ 的/ Page11/ 逻辑/ 段/ ,/ 那么/ 应该/ 认为/ 此/ 测试用例/ 触发/ 故障/ ,/ 但/ 由于/ 两个/ 版本/ 执行/ 结果/ 相同/ ,/ 此/ 故障/ 就/ 被/ 忽略/ ,/ 从而/ 认为/ 此/ 测试用例/ 通过/ ./ 为了/ 克服/ 这一/ 因素/ 引起/ 的/ 扰乱/ ,/ 我们/ 对/ TCAS/ 代码/ 进行/ 改动/ ,/ 将/ 第/ 6/ 行/ 和/ 第/ 8/ 行/ 的/ 代码/ alt/ _/ sep/ =/ UNRESOLVED/ 改为/ 与/ UNRESOLVED/ 不同/ 的/ 值/ ,/ 分别/ 设为/ UNRESOLVED1/ 和/ UNRESOLVED2/ ./ 修改/ 后/ ,/ 我们/ 的/ 错误/ 测试用例/ 包含/ 的/ 真实/ 故障/ 元组/ 变为/ [/ Cur/ _/ Vertical/ _/ Sep/ =/ 601/ ,/ High/ _/ confi/ -/ dence/ =/ 1/ ,/ -/ ,/ -/ ,/ Own/ _/ Tracked/ _/ Alt/ _/ Rate/ =/ 601/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ Other/ _/ Capability/ =/ 2/ ,/ -/ ]/ ,/ 而/ 定位/ 出/ 的/ 最小/ 故障/ 模式/ 为/ [/ Cur/ _/ Vertical/ _/ Sep/ =/ 601/ ,/ High/ _/ confidence/ =/ 1/ ,/ -/ ,/ -/ ,/ Own/ _/ Tracked/ _/ Alt/ _/ Rate/ =/ 601/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ -/ ,/ Other/ _/ Capability/ =/ 2/ ,/ -/ ]/ ./ 故障/ 相关性/ 为/ 4/ // 4/ ,/ 即/ 定位/ 结果/ 和/ 真实/ 故障/ 完全一致/ ./ 6/ 讨论/ TRT/ 方法/ 需要/ 先/ 列出/ 所有/ 可能/ 的/ 配置/ 组合/ ,/ 并/ 构成/ 树形/ 结构/ ./ 此/ 树形/ 结构/ 对于/ 我们/ 的/ 方法/ 有/ 如下/ 3/ 个/ 重要/ 作用/ ./ (/ 1/ )/ 可以/ 快速/ 检索/ 出/ 1/ 个/ 元组/ 的/ 相关/ 子/ 元组/ 和/ 父/ 元组/ ./ (/ 2/ )/ 可以/ 查看/ 当前/ 还有/ 哪些/ 未/ 被/ 检测/ 的/ 元组/ ,/ 为/ 下/ 一次/ 迭代/ 挑选/ 待测/ 元组/ 提供/ 候选/ 对象/ 集/ ./ (/ 3/ )/ 查看/ 是否/ 所有/ 的/ 元组/ 都/ 被/ 检测/ 到/ ,/ 为/ 算法/ 终止/ 提供/ 了/ 依据/ ./ 然而/ ,/ 树形/ 结构/ 需要/ 程序/ 提供/ 空间/ 存储/ ,/ 在/ 参数/ 个数/ 很小/ 的/ 时候/ ,/ 这个/ 树形/ 结构/ 的/ 规模/ 很小/ ,/ 问题/ 不/ 大/ ,/ 但是/ 一旦/ 参数/ 个数/ 增大/ ,/ 树形/ 结构/ 的/ 规模/ 将会/ 很大/ ,/ 程序/ 需要/ 花费/ 很大/ 的/ 空间/ 代价/ 来/ 存储/ 这样/ 一个/ 树形/ 结构/ ,/ 为了/ 解决/ 此/ 问题/ ,/ 实际/ 实现/ 过程/ 中/ 我们/ 可以/ 不必/ 在/ 内存/ 中/ 储存/ 这样/ 的/ 树形/ 结构/ ,/ 取而代之/ 的/ 是/ 我们/ 需要/ 做出/ 如下/ 的/ 措施/ :/ (/ 1/ )/ 动态/ 的/ 计算/ 一个/ 元组/ 的/ 相关/ 子/ 元组/ 和/ 父/ 元组/ ,/ 而/ 不是/ 事先/ 储存/ 其/ 关系/ ./ 这个/ 动态/ 的/ 计算/ 的/ 过程/ 所/ 需/ 的/ 代价/ 很小/ ./ (/ 2/ )/ 由于/ 没有/ 存储/ 未/ 被/ 检测/ 的/ 元组/ ,/ 为了/ 检测/ 一个/ 元组/ 是否是/ 未/ 被/ 检测/ 的/ 元组/ ,/ 我们/ 需要/ 将/ 每/ 一次/ 迭代/ 的/ 元组/ 和/ 其/ 确定/ 后/ 的/ 状态/ (/ 即/ 是否/ 为/ 故障/ 元组/ )/ 存储/ 下来/ ./ 然后/ 对于/ 一个/ 新/ 挑选/ 的/ 元组/ ,/ 我们/ 只/ 需/ 根据/ 通过/ 定理/ 3/ 和/ 4/ ,/ 即/ 判断/ 是否是/ 已测/ 正确/ 元组/ 的/ 子/ 元组/ 或/ 已测/ 故障/ 元组/ 的/ 父/ 元组/ ./ 如果/ 都/ 不是/ ,/ 那么/ 这个/ 新/ 挑选/ 的/ 元组/ 就是/ 未/ 被/ 检测/ 元组/ ,/ 反之/ 就是/ 已/ 被/ 检测/ 元组/ (/ 由于/ 实际/ 需要/ 检测/ 的/ 元组/ 个数/ 并不多/ ,/ 因此/ 这种/ 存储/ 的/ 代价/ 很小/ )/ ./ (/ 3/ )/ 使用/ 一个/ 变量/ 来/ 标记/ 当前/ 未/ 被/ 确定/ 元组/ 的/ 数量/ (/ 初始/ 为/ 所有/ 可能/ 配置/ 元组/ 的/ 个数/ )/ ,/ 每次/ 确定/ 了/ 一个/ 元组/ 为/ 故障/ 元组/ 或非/ 故障/ 元组/ ,/ 这个/ 变量/ 就/ 减/ 1/ ./ 因此/ 程序/ 终止/ 的/ 条件/ 就是/ 这个/ 变量/ 是否/ 为/ 0/ ./ 但是/ 由于/ 没有/ 存储/ 树形/ 结构/ ,/ 虽然/ 我们/ 可以/ 通过/ 策略/ 2/ 判断/ 出/ 一个/ 元组/ 是否/ 为/ 未/ 被/ 检测/ 元组/ ,/ 我们/ 却/ 不能/ 很/ 直观/ 的/ 得到/ 未/ 被/ 测试/ 元组/ 的/ 候选/ 集/ ,/ 因此/ 这会/ 很大/ 程度/ 上/ 影响/ 到/ 算法/ 的/ 挑选/ 策略/ ./ 从而/ 我们/ 需要/ 新/ 的/ 方法/ 来/ 获得/ 未/ 被/ 测试/ 元组/ 候选/ 集/ 或/ 部分/ 未/ 被/ 测试/ 元组/ 候选/ 集/ ./ 目前/ 我们/ 还/ 没有/ 得到/ 在/ 不/ 存储/ 树形/ 结构/ 的/ 情况/ 下/ 高效/ 的/ 挑选/ 候选/ 集/ 的/ 策略/ ./ 这会/ 是/ 我们/ 未来/ 工作/ 的/ 一个/ 重要/ 部分/ ./ 7/ 相关/ 工作/ 和/ 对比/ Nie/ 在/ 文献/ [/ 12/ ]/ 提出/ 一种/ 分析/ 故障/ 元组/ 的/ 方法/ ,/ 该/ 方法/ 将/ 发现错误/ 的/ 测试用例/ 中/ 包含/ 的/ 故障/ 模式/ 与/ 未/ 发现/ 故障/ 的/ 测试用例/ 所/ 包含/ 的/ 故障/ 模式/ 进行/ 比/ 对/ 排除/ ,/ 以/ 缩小/ 可能/ 的/ 故障/ 模式/ 范围/ ,/ 但/ 这种/ 方法/ 效果/ 很差/ ,/ 特别/ 是/ 在/ 使用/ 覆盖/ 表/ 进行/ 测试/ 时/ ,/ 几乎/ 无法/ 缩小/ 这个/ 可疑/ 故障/ 模式/ 范围/ ./ 然后/ 用/ 一些/ 附加/ 测试用例/ 进行/ 补充/ 测试/ ,/ 进一步/ 缩小/ 这个/ 范围/ ./ 在/ 文献/ [/ 13/ ]/ 中/ Nie/ 等/ 人/ 对此/ 方法/ 做出/ 了/ 改进/ ,/ 该/ 方法/ 将/ 一条/ 发现/ 故障/ 的/ 测试用例/ 所/ 包含/ 的/ 可能/ 的/ 故障/ 模式/ 表示/ 成/ 一个/ 偏序/ 集/ ,/ 这样/ 通过/ 发现/ 故障/ 的/ 测试用例/ 和/ 未/ 发现/ 故障/ 的/ 测试用例/ 形成/ 的/ 偏序/ 集/ 的/ 做/ 差/ ,/ 形成/ 的/ 新/ 的/ 偏序/ 集/ ,/ 最后/ 将/ 这个/ 偏序/ 集/ 的/ 极小/ 元/ 看做/ 最大/ 可能/ 的/ 故障/ 模式/ ,/ 虽然/ 此/ 结果/ 比/ 之前/ 的/ 结果/ 改进/ 很多/ ,/ 但/ 该/ 方法/ 找/ 出来/ 的/ 还/ 只是/ 可能/ 的/ 故障/ 模式/ ./ 而/ 在/ 文献/ [/ 2/ ]/ 中/ ,/ Nie/ 对此/ 方法/ 继续/ 完善/ ,/ 提出/ 了/ 组合/ 测试/ 中/ 的/ “/ 最小/ 故障/ 模式/ ”/ 概念/ ,/ 并/ 给出/ 了/ 定位/ 最小/ 故障/ 模式/ 的/ 重要/ 基础理论/ 和/ 方法/ ./ Wang/ 的/ 方法/ [/ 14/ ]/ 是/ Nie/ 的/ 一个/ 迭代/ 改进/ 方法/ ./ 通过/ 多次/ 迭代/ 修改/ 参数/ 达到/ 进一步/ 从/ 可能/ 故障/ 元组/ 中约/ 减/ 正确/ 元组/ ./ 不过/ Wang/ 方法/ 的/ 有效性/ 建立/ 在/ 很多/ 假设/ 之上/ ,/ 如/ 只/ 含有/ 一个/ 最小/ 故障/ 和/ 多个/ 非/ 重叠/ 故障/ 等/ 假设/ ,/ 限制/ 较/ 多/ ./ Zhang/ 在/ 文献/ [/ 4/ ]/ 中/ 提出/ 了/ FIC/ 和/ FIC/ _/ BS/ 两种/ 定位/ 方法/ ,/ 该文/ 采用/ 错误/ 的/ 测试用例/ 作为/ 种子/ 初始化/ ,/ 然后/ 通过/ 自/ 适应/ 修改/ 种子/ 用例/ 的/ 一些/ 对应/ 参数值/ 从而/ 生成/ 附加/ 测试用例/ 并/ 执行/ ,/ 重复/ 此/ 动作/ 直至/ 找到/ 最小/ 故障/ 元组/ 为止/ ,/ 而/ 对于/ 多个/ 故障/ 的/ 情况/ ,/ Zhang/ 实现/ 定位/ 了/ 没有/ 重叠/ 的/ 故障/ 元组/ ./ Zhang/ 的/ Page12/ 方法/ 能够/ 以/ 生成/ 较/ 小/ 的/ 附加/ 测试用例/ 个数/ 达到/ 定位/ 出/ 任意/ 大小/ 的/ 故障/ 元组/ ,/ 但是/ Zhang/ 不能/ 定位/ 出/ 有/ 重叠/ 的/ 故障/ ./ Ghandehari/ 等/ 人/ [/ 3/ ]/ 在/ 其中/ 使用/ t/ -/ way/ 覆盖/ 表/ 作为/ 定位/ 输入/ ,/ 然后/ 按/ 元组/ 的/ 可疑/ 程度/ 输出/ 可能/ 的/ 故障/ 元组/ ./ 该文/ 定义/ 了/ 元组/ 可疑/ 程度/ 、/ 元组/ 环境/ 可疑/ 程度/ ,/ 并/ 根据/ 这/ 两者/ 来/ 对/ 待定/ 元组/ 进行/ 排序/ ,/ 对/ 可疑/ 程度/ 较大/ 元组/ 生成/ 附加/ 测试用例/ ,/ 然后/ 迭代/ 分析/ 排序/ ./ 可知/ Ghandehari/ 的/ 定位/ 需要/ 的/ 限制/ 条件/ 较/ 少/ ,/ 但是/ 只能/ 定位/ 出/ t/ 值/ 或/ 小于/ t/ 值/ 的/ 元组/ ,/ 并且/ 他们/ 的/ 结果/ 并/ 不/ 保证/ 排序/ 靠/ 前/ 的/ 就是/ 故障/ 元组/ ./ Yilmaz/ 等/ 人/ [/ 15/ ]/ 中/ 提出/ 了/ 一个/ 机器/ 学习/ 的/ 方法/ 来/ 实现/ 组合/ 故障/ 定位/ ./ 该/ 方法/ 建立/ 了/ 一种/ 分类/ 树/ ,/ 通过/ 使用/ 覆盖/ 表/ 作为/ 训练/ 集来/ 实现/ 树/ 的/ 划分/ ,/ 并/ 使用/ 该树/ 做/ 故障诊断/ ./ 该/ 方法/ 可以/ 诊断/ 多种/ 错误/ 状态/ ,/ 而/ 不/ 只是/ 文中/ 所/ 约定/ 的/ 只有/ 错误/ 和/ 正确/ 两种/ 状态/ ,/ 但是/ 由于/ 使用/ 机器/ 学习/ ,/ 此/ 方法/ 在/ 定位/ 上/ 不是/ 很/ 准确/ ,/ 会/ 遗漏/ 和/ 错评/ 一些/ 测试用例/ ./ 并且/ 此/ 方法/ 只/ 定位/ 错误/ 频率/ 达到/ 3/ %/ 以上/ 的/ 组合/ ,/ 而/ 对于/ 一些/ 高维/ 的/ 组合/ ,/ 由于/ 出现/ 频率/ 小/ ,/ 不会/ 被/ 此/ 方法/ 侦测/ 到/ ./ 基于/ Yilmaz/ 的/ 方法/ 的/ 一些/ 限制/ 如/ :/ 现实/ 软件测试/ 缺少/ 选择/ 覆盖/ 强度/ 的/ 指导性/ 建议/ 、/ 对/ 先生/ 成/ 的/ 低维/ 覆盖/ 表/ 的/ 利用/ 、/ 非/ 确定性/ 故障/ 的/ 影响/ ,/ Fouch/ é/ 在/ 文献/ [/ 16/ ]/ 提出/ 了/ 利用/ 可/ 增长/ 式/ 的/ 覆盖/ 表对/ 故障/ 进行/ 诊断/ ,/ 即/ 在/ 测试/ 过程/ 中/ 先生/ 成低维/ 覆盖/ 表/ 进行/ 诊断/ ,/ 然后/ 不断/ 增加/ 覆盖/ 强度/ 实现/ 对/ 高维/ 故障/ 的/ 诊断/ ,/ 此/ 方法/ 能够/ 尽早/ 的/ 发现/ 低维/ 的/ 故障/ ,/ 较/ 传统/ 的/ 生成/ 固定/ 的/ 覆盖/ 表/ 定位/ 有所提高/ ,/ 但是/ 定位/ 过程/ 同样/ 忽略/ 了/ 错误/ 频率/ 较/ 低/ 的/ 故障/ ./ 针对/ 前/ 两种/ 机器/ 学习/ 方法/ 的/ 限制/ :/ 对/ 高维/ 强度/ 的/ 组合/ 故障/ 定位/ 不足/ ,/ Shakya/ 等/ 人/ 在/ 文献/ [/ 10/ ]/ 提出/ 了/ 一种/ 扩展/ 方法/ ,/ 此/ 方法/ 在/ 已有/ 的/ 测试用例/ 基础/ 上/ 分析/ 再/ 生成/ 下/ 一批/ 测试用例/ ,/ 确保/ 尽可能/ 生成/ 的/ 测试用例/ 都/ 错误/ ,/ 以/ 提高/ 分类/ 树/ 的/ 分类/ 准确度/ ,/ 同时/ 他们/ 还/ 对/ 不/ 引发/ 故障/ 的/ 参数/ 进行/ 过滤/ 以/ 简化/ 分类/ 树/ ./ 他们/ 的/ 方法/ 目前/ 只有/ 初步/ 结果/ ./ 本文/ 方法/ 的/ 特点/ 在于/ 可以/ 定位/ 出/ 任意/ 维度/ (/ 值/ )/ 的/ 故障/ ,/ 并且/ 对于/ 测试用例/ 多个/ 故障/ 的/ 情况/ ,/ 尤其/ 是/ 重叠/ 的/ 故障/ 都/ 可以/ 很/ 好/ 的/ 定位/ ,/ 其中/ 路径/ 法/ 可以/ 以/ 生成/ 较少/ 的/ 附加/ 测试用例/ 情况/ 下/ 定位/ 出/ 测试用例/ 中/ 的/ 最小/ 故障/ 元组/ ./ 7.1/ 和/ 已有/ 算法/ 的/ 对比/ 我们/ 对/ 定位/ 故障/ 方法/ 中/ 的/ 4/ 个/ 指标/ :/ 能够/ 定位/ 出/ 的/ 故障/ 元组/ 维度/ 的/ 限制/ 、/ 能否/ 定位/ 有/ 重叠/ 的/ 故障/ 、/ 新/ 引入/ 故障/ 对/ 算法/ 是否/ 有/ 影响/ 和/ 定位/ 结果/ 是否/ 精确/ 进行/ 考察/ ./ 对比/ 结果/ 如表/ 5/ 所示/ ./ 可以/ 看出/ 在/ 能够/ 精确定位/ 结果/ 的/ 算法/ 中/ ,/ 只有/ 本文/ 算法/ 可以/ 定位/ 出/ 有/ 重叠/ 的/ 故障/ ./ 算法/ 定位/ 维度/ 重叠/ 故障/ 引入/ 故障/ 结果/ 精确/ 本文/ 算法/ 任意/ √/ ×/ √/ Zhang/ 任意/ ×/ ×/ √/ Wang/ 任意/ ×/ ×/ √/ Nie/ 任意/ √/ √/ ×/ Ghandehari/ / t/ √/ √/ ×/ Shakya/ / t/ √/ √/ ×/ Yilmaz/ / t/ √/ √/ ×/ Fouch/ é/ / t/ √/ √/ ×/ 此外/ ,/ 我们/ 还/ 需要/ 考虑/ 到/ 我们/ 的/ 算法/ 所/ 需/ 成本/ 大小/ ,/ 即/ 所/ 需/ 附加/ 测试用例/ 个数/ 的/ 多少/ ./ 为此/ ,/ 我们/ 取/ 已有/ 工作/ 中/ 需要/ 附加/ 测试用例/ 数/ 最少/ 的/ 算法/ FIC/ _/ BS/ [/ 4/ ]/ 与/ 我们/ 的/ 算法/ 进行/ 对比/ ./ 对比/ 试验/ 中/ 用到/ 的/ 模拟/ 待测/ 模拟系统/ 的/ 配置/ 参数/ 个数/ 分别/ 为/ 8/ 、/ 10/ 、/ 12/ 、/ 14/ 和/ 16/ ,/ 每个/ 配置/ 有/ 3/ 个/ 取值/ ,/ 我们/ 采用/ 第/ 5/ 节中/ 的/ 实验/ 方法/ 来/ 对比/ FIC/ _/ BS/ 和/ 路径/ 法/ 两个/ 算法/ ,/ 只/ 比较/ 单个/ 故障/ 的/ 情况/ (/ FIC/ _/ BS/ 不能/ 定位/ 出/ 有/ 重叠/ 的/ 两个/ 故障/ )/ ./ 对比/ 结果/ 如图/ 10/ 显示/ ./ 图/ 10/ 中/ 我们/ 可以/ 看出/ ,/ 在/ k/ =/ 8/ ,/ t/ =/ 3/ 、/ k/ =/ 8/ ,/ t/ =/ 4/ 、/ k/ =/ 10/ ,/ t/ =/ 4/ 和/ k/ =/ 12/ ,/ t/ =/ 4/ 这/ 4/ 组/ 实验/ 中/ ,/ 我们/ 的/ 结果/ (/ 平均值/ )/ 要/ 比/ Zhang/ 的/ 方法/ 要/ 好/ ,/ 其余/ 结果/ 比/ Zhang/ 差/ ,/ 但是/ 差别/ 不/ 超过/ 4/ 个/ ./ 并且/ 在/ k/ 、/ t/ 相同/ 的/ 情况/ 下/ ,/ 我们/ 的/ 定位/ 结果/ 中/ 所/ 需要/ 的/ 最小/ 附加/ 测试用例/ 往往/ 要/ 比/ Zhang/ 小/ ,/ 但是/ 我们/ 的/ 方法/ 的/ 稳定性/ 不如/ Zhang/ ./ 对比/ 结果表明/ 本文/ 算法/ 在/ 可以/ 定位/ 出/ 有/ 重叠/ 的/ 故障/ 基础/ 上/ 牺牲/ 的/ 效率/ 并/ 不/ 高/ ./ 8/ 总结/ 和/ 未来/ 工作/ 本文/ 提出/ 一种/ 新/ 的/ 定位/ 模型/ 来/ 定位/ 组合/ 测试/ 中/ 的/ 最小/ 故障/ 元组/ ,/ 此/ 方法/ 利用/ 元组/ 关系/ 树/ TRT/ 来/ 记录/ 所有/ 需要/ 分析/ 的/ 元组/ 和/ 它们/ 之间/ 的/ 关联/ ,/ 基于/ TRT/ 我们/ 给出/ 了/ 4/ 种/ 挑选/ 策略/ ./ 通过/ 模拟实验/ 我们/ 得知/ 路径/ 法能/ 以/ 最少/ 的/ 生成/ 附加/ 测试用例/ 数/ 达到/ 定位/ 目标/ ./ 我们/ 的/ 方法/ 可以/ 在/ 保证/ 结果/ 精确/ 的/ 前提/ 上/ 定位/ 出/ 有/ 重叠/ 的/ 故障/ ,/ 这是/ 现有/ 方法/ 所/ 不/ 具备/ 的/ 功能/ ./ 本文/ 还/ 使用/ 此/ 方法/ 对/ 真实/ 软件/ TCAS/ 的/ 模块/ 做/ 了/ 故障/ 分析/ ,/ 实验/ 结果显示/ 我们/ 的/ 方法/ 比/ 以往/ 的/ 方法/ 更能/ 精确/ 的/ 发现/ 故障/ 源/ ./ 然而/ ,/ 本文/ 方法/ 使用/ 了/ 很大/ 的/ 空间/ 来/ 存储/ Page13/ 图/ 10/ 路径/ 法/ (/ PATH/ )/ 与/ FIC/ _/ BS/ 对比/ 图/ TRT/ ,/ 其/ 空间/ 复杂度/ 为/ O/ (/ 2n/ )/ ,/ 虽然/ 我们/ 给出/ 不/ 需要/ 存储/ TRT/ 就/ 可以/ 进行/ 定位/ 的/ 措施/ ,/ 但是/ 目前/ 我们/ 还/ 没有/ 得到/ 高效/ 的/ 得出/ 候选/ 集/ 的/ 策略/ ./ 并且/ 该/ 方法/ 仍/ 基于/ 不/ 引入/ 故障/ 的/ 假设/ 之上/ ,/ 若/ 软件/ 故障/ 较/ 多/ ,/ 在/ 生成/ 附加/ 测试用例/ 引入/ 新/ 的/ 故障/ 可能性/ 很大/ 的/ 情况/ 下/ ,/ 我们/ 的/ 定位/ 结果/ 精度/ 将/ 降低/ ./ 未来/ 我们/ 将/ 对/ 在/ 不/ 存储/ 树形/ 结构/ 的/ 情况/ 下/ 得出/ 候选/ 集/ 的/ 策略/ 做出/ 深入/ 的/ 研究/ ,/ 使/ 其/ 能够/ 动态/ 并/ 高效/ 的/ 返回/ 全部/ 或/ 部分/ 未/ 被/ 测试/ 元组/ 的/ 候选/ 集/ ./ 并且/ 需要/ 改进/ 算法/ 使得/ 本/ 方法/ 对/ 可/ 引入/ 故障/ 的/ SUT/ 也/ 能/ 很/ 好/ 的/ 定位/ 出/ 故障/ 源/ ,/ 从而/ 提高/ 算法/ 的/ 鲁棒性/ ./ 致谢/ 匿名/ 审稿人/ 对/ 本文/ 提出/ 了/ 非常/ 有/ 帮助/ 的/ 修改意见/ ,/ 对/ 改进/ 本文/ 质量/ 起到/ 了/ 非常/ 重要/ 的/ 作用/ ,/ 在/ 此/ 表示感谢/ !/ 

