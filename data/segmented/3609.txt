Page1/ 基于/ 有限/ 约束/ 满足/ 问题/ 的/ 溢出/ 漏洞/ 动态/ 检测/ 方法/ 陈恺/ 1/ )/ ,/ 2/ )/ 冯登国/ 2/ )/ 苏璞/ 睿/ 2/ )/ 1/ )/ (/ 中国科学院/ 信息工程/ 研究所/ 信息安全/ 国家/ 重点/ 实验室/ 北京/ 100195/ )/ 2/ )/ (/ 中国科学院/ 软件/ 研究所/ 北京/ 100190/ )/ 摘要/ 溢出/ 型/ 漏洞/ 是/ 最为/ 普遍/ 且/ 最具/ 危害/ 的/ 漏洞/ 类型/ 之一/ ,/ 溢出/ 漏洞/ 检测/ 也/ 是/ 目前/ 国内外/ 研究/ 的/ 热点问题/ ./ 目前/ 漏洞/ 检测/ 方法/ 主要/ 分为/ 白盒/ 测试/ 和/ 黑盒/ 测试/ 两类/ ./ 前者/ 主要/ 针对/ 程序/ 指令/ 进行/ 漏洞/ 分析/ ,/ 但/ 存在/ 效率/ 较/ 低/ 、/ 检测/ 结果/ 不/ 准确/ 等/ 缺点/ ;/ 后者/ 难以/ 保证/ 程序/ 覆盖/ 的/ 全面性/ 与/ 测试数据/ 的/ 针对性/ ./ 文中/ 提出/ 了/ 一种/ 基于/ 有限/ 约束/ 满足/ 性/ 问题/ (/ ConstraintSatisfactionProblem/ ,/ CSP/ )/ 的/ 溢出/ 漏洞/ 动态/ 检测/ 方法/ ./ 在/ 程序执行/ 过程/ 中/ ,/ 结合/ 动态/ 污点/ 传播/ 和/ 动态/ 循环/ 分析/ ,/ 选取/ 可能/ 产生/ 溢出/ 漏洞/ 的/ 语句/ 并/ 生成/ CSP/ 表达式/ ,/ 表达式/ 包括/ 语句/ 的/ 执行/ 条件/ 和/ 漏洞/ 产生/ 条件/ 两/ 部分/ ;/ 通过/ 对此/ CSP/ 表达式/ 化简/ 求解/ ,/ 验证/ 漏洞/ 的/ 存在/ 性/ 与/ 漏洞/ 的/ 触发/ 条件/ ./ 该/ 方法/ 可/ 直接/ 分析/ 可执行程序/ ,/ 解决/ 了/ 间接/ 跳转/ 、/ 多态/ 代码/ 等/ 静态/ 分析/ 中/ 难以解决/ 的/ 问题/ ./ 为了/ 验证/ 该/ 方法/ 的/ 有效性/ ,/ 作者/ 开发/ 了/ 一套/ 原型/ 系统/ 并/ 进行/ 相关/ 实验/ ,/ 结果表明/ 该/ 方法/ 缩小/ 了/ 漏洞/ 分析/ 范围/ ,/ 提高/ 了/ 分析/ 效率/ ./ 关键词/ 计算机/ 安全/ ;/ 漏洞/ 检测/ ;/ 动态/ 检测/ ;/ CSP/ ;/ 可执行程序/ 1/ 引言/ 未知/ 漏洞/ 是/ 黑客/ 与/ 软件/ 开发者/ 希望/ 率先/ 掌握/ 的/ 第一手/ 资料/ ./ 对于/ 黑客/ ,/ 获取/ 一定/ 数量/ 的/ 未知/ 漏洞/ ,/ 可以/ 进入/ 存在/ 相应/ 漏洞/ 的/ 计算机/ ,/ 进行/ 权限/ 提升/ ,/ 甚至/ 可以/ 进一步/ 产生/ 更大/ 的/ 破坏/ ./ 在/ 2005/ 年/ 6/ 月/ 17/ 日晚/ ,/ 美国/ 万事达/ 信用卡/ 国际/ 公司/ 宣布/ ,/ 一名/ 黑客/ 侵入/ 了/ “/ 信用卡/ 第三方/ 付款/ 处理器/ ”/ 的/ 网络系统/ ,/ 造成/ 包括/ 万事达/ 、/ Visa/ 、/ AmericanExpress/ 和/ Discover/ 在内/ 各种/ 信用卡/ 高达/ 4000/ 多万/ 用户/ 的/ 数据资料/ 被窃/ ,/ 其中/ 万事达/ 信用卡/ 用户/ 高达/ 1390/ 万/ ,/ Visa/ 信用卡/ 的/ 客户/ 则/ 高达/ 2200/ 万/ ./ 随着/ 网络/ 的/ 不断/ 发展/ 以及/ 各种/ 软件/ 数量/ 和/ 种类/ 的/ 不断/ 增多/ ,/ 未知/ 漏洞/ 产生/ 的/ 危害/ 更为/ 明显/ ./ 危害/ 巨大/ 的/ 蠕虫/ 几乎/ 都/ 是/ 未知/ 漏洞/ 的/ 产物/ ./ 例如/ ,/ 众所周知/ 的/ 冲击波/ 利用/ 了/ 微软/ 的/ MS03/ -/ 026/ 漏洞/ ,/ 震荡波/ 利用/ 了/ 微软/ 的/ MS04/ -/ 011/ 漏洞/ ,/ SQL/ 蠕虫/ 王/ 利用/ 了/ 微软/ SQLServer/ 的/ 漏洞/ 等等/ ./ 因此/ ,/ 如何/ 检测/ 未知/ 漏洞/ ,/ 成为/ 软件/ 安全/ 工作/ 的/ 重中之重/ ./ 目前/ 主要/ 的/ 漏洞/ 检测/ 方法/ 分为/ 白盒/ 测试/ 和/ 黑盒/ 测试/ 两类/ ./ 前者/ 多/ 针对/ 源程序/ 进行/ 静态/ 漏洞/ 检测/ ,/ 但/ 由于/ 多数/ 软件/ 不/ 提供/ 源程序/ ,/ 限制/ 了/ 这类/ 分析方法/ 的/ 检测/ 范围/ ./ 人们/ 试图/ 将/ 基于/ 源程序/ 的/ 漏洞/ 检测/ 方法/ 移植/ 到/ 可执行程序/ 上/ ,/ 但/ 可执行程序/ 本身/ 的/ 不确定性/ 降低/ 了/ 分析/ 结果/ 的/ 准确性/ ,/ 例如/ 间接/ 跳转/ 、/ 指针/ 别名/ [/ 1/ -/ 2/ ]/ 等/ 都/ 是/ 目前/ 静态/ 分析/ 中/ 难以解决/ 的/ 问题/ ,/ 软件保护/ 技术/ 亦/ 增加/ 了/ 分析/ 的/ 难度/ ,/ 例如/ 多态/ 、/ 变形/ 、/ 加密/ 等/ 方式/ 迫使/ 静态/ 分析/ 甚至/ 不能/ 反编译/ 出/ 有效/ 的/ 代码/ ./ 后者/ 能够/ 对/ 可执行程序/ 进行/ 直接/ 测试/ ,/ 但/ 难以/ 保证/ 程序/ 覆盖/ 的/ 全面性/ 与/ 测试数据/ 的/ 针对性/ ./ 本文/ 提出/ 了/ 一种/ 面向/ 可执行程序/ 的/ 溢出/ 漏洞/ 动态/ 检测/ 方法/ ./ 在/ 程序/ 的/ 执行/ 过程/ 中/ ,/ 对/ 可能/ 产生/ 溢出/ 漏洞/ 的/ 赋值/ 语句/ 生成/ CSP/ 表达式/ ,/ 表达式/ 包括/ 语句/ 的/ 执行/ 条件/ 和/ 漏洞/ 的/ 产生/ 条件/ 两/ 部分/ ./ 语句/ 的/ 执行/ 条件/ 指/ 程序流程/ 能够/ 到达/ 这/ 条/ 赋值/ 语句/ 及/ 保持/ 其/ 符号/ 表达形式/ 所/ 依赖/ 的/ 条件/ 集合/ ;/ 漏洞/ 的/ 产生/ 条件/ 指/ 漏洞/ 被/ 触发/ 的/ 条件/ ,/ 典型/ 地/ ,/ 例如/ 堆/ 管理/ 结构/ 和/ 栈/ 中/ 存放/ 的/ 子程序/ 返回/ 指针/ 被/ 破坏/ ./ 最后/ 通过/ 对/ CSP/ 表达式/ 的/ 化简/ 求解/ 确认/ 漏洞/ 的/ 存在/ 性/ ./ 本/ 方法/ 采用/ 在/ 虚拟环境/ 下/ 执行/ 的/ 方式/ ,/ 可以/ 准确/ 地/ 提取/ 程序/ 的/ 执行/ 环境/ ,/ 包括/ 内存/ 、/ 寄存器/ 等/ 信息/ ,/ 避免/ 了/ 可执行程序/ 本身/ 的/ 不确定性/ 和/ 软件保护/ 措施/ 带来/ 的/ 反编译/ 问题/ ./ 语句/ 的/ 执行/ 条件/ 仅/ 依赖于/ 当前/ 语句/ 执行/ 路径/ 上/ 的/ 条件/ 集合/ ,/ 可/ 由/ 汇编/ 语义/ 表示/ ,/ 因此/ 避免/ 了/ 源程序/ 的/ 使用/ ./ 结合/ 污点/ 传播/ 和/ 循环/ 分析/ 的/ 方式/ 对/ CSP/ 表达式/ 进行/ 化简/ ,/ 提高/ 了/ 分析/ 效率/ ./ 本文/ 主要/ 做/ 了/ 如下/ 贡献/ :/ (/ 1/ )/ 提出/ 了/ 一种/ 动态/ 的/ 溢出/ 漏洞/ 检测/ 方法/ ./ 在/ 程序/ 的/ 执行/ 过程/ 中/ 对/ 程序/ 可能/ 引发/ 溢出/ 漏洞/ 的/ 程序/ 点/ 建立/ 检测/ 条件/ ,/ 并/ 结合/ 当前/ 语句/ 的/ 执行/ 条件/ 建立/ CSP/ 表达式/ ./ 对/ 表达式/ 进行/ 分析/ 化简/ 并/ 求解/ 验证/ ,/ 验证/ 成功/ 的/ 结果/ 可以/ 直接/ 作为/ 漏洞/ 的/ 触发/ 条件/ ./ 避免/ 了/ 源代码/ 的/ 使用/ 以及/ 静态/ 分析/ 中/ 由/ 软件保护/ 和/ 二进制/ 程序/ 本身/ 不确定性/ 带来/ 的/ 问题/ ./ (/ 2/ )/ 提出/ 了/ 一个/ 检测点/ 筛选/ 算法/ ./ 本/ 算法/ 在/ 建立/ 程序/ 分析树/ 的/ 基础/ 上/ ,/ 结合/ 动态/ 污点/ 传播/ 和/ 动态/ 循环/ 判定/ ,/ 选出/ 数据/ 依赖于/ 外部/ 输入/ 的/ 赋值/ 语句/ 或者/ 循环/ 控制/ 节点/ 依赖于/ 外部/ 输入/ 的/ 循环/ 内/ 赋值/ 语句/ 作为/ 检测点/ ./ 实验/ 表明/ ,/ 此/ 方法/ 有效/ 减少/ 了/ 检测/ 范围/ ,/ 提升/ 了/ 分析/ 效率/ ./ (/ 3/ )/ 建立/ 了/ 一套/ 漏洞/ 分析/ 原型/ 系统/ ./ 本/ 系统/ 采用/ 虚拟环境/ 执行/ 方式/ ,/ 直接/ 对/ 可执行程序/ 进行/ 动态/ 漏洞/ 分析/ ./ 在/ 此/ 原型/ 系统/ 的/ 基础/ 上/ ,/ 我们/ 进行/ 了/ 循环/ 个数/ 、/ 污点/ 传播/ 效率/ 、/ 空间/ 效率/ 、/ 时间/ 效率/ 和/ 检测/ 效果/ 方面/ 的/ 测试/ ./ 实验/ 表明/ 本/ 系统/ 缩小/ 了/ 漏洞/ 分析/ 的/ 范围/ ,/ 提高/ 了/ 分析/ 效率/ ./ 本文/ 第/ 2/ 节/ 介绍/ 漏洞/ 检测/ 的/ 国内外/ 现状/ ;/ 第/ 3/ 节/ 详细/ 介绍/ 污点/ 传播/ 、/ 检测点/ 的/ 选取/ 、/ CSP/ 表达式/ 的/ 构建/ 与/ 化简/ 等/ 内容/ ;/ 第/ 4/ 节/ 针对/ 原型/ 系统/ 进行/ 相关/ 实验/ 并作/ 分析/ ;/ 最后/ 总结/ 全文/ 并/ 讨论/ 未来/ 的/ 研究/ 方向/ ./ 2/ 相关/ 工作/ 漏洞/ 的/ 检测/ 主要/ 分为/ 两类/ :/ 一类/ 是/ 白盒/ 测试/ ,/ 即/ 对/ 程序/ 进行/ 直接/ 分析/ ,/ 从中/ 寻找/ 可能/ 出现/ 漏洞/ 的/ 检测点/ 并/ 进行/ 验证/ ;/ 另一类/ 是/ 黑盒/ 测试/ ./ 此外/ ,/ 对/ 漏洞/ 利用/ 代码/ 进行/ 被动/ 捕获/ 分析/ ,/ 从而/ 有/ 选择地/ 确认/ 程序/ 中/ 的/ 漏洞/ [/ 3/ -/ 4/ ]/ 也/ 是/ 一种/ 漏洞/ 检测/ 方法/ ./ 白盒/ 测试通过/ 对/ 程序/ 进行/ 直接/ 分析/ 进行/ 未知/ 漏洞/ 检测/ ./ 静态/ 缓冲区/ 溢出/ 检测/ 是/ 应用/ 较/ 早/ 也/ 较为/ 普遍/ 的/ 漏洞/ 检测/ 方法/ 之一/ ./ BOON/ [/ 5/ ]/ 在/ C语言/ 源代码/ 的/ 基础/ 上/ 利用/ 整数/ 界限/ 的/ 方法/ 检测/ 未知/ 漏洞/ ./ ARCHER/ [/ 6/ ]/ 在/ Linux/ 源代码/ 以及/ 其它/ 源程序/ 中/ 发现/ 过/ 许多/ 内存/ 访问/ 冲突/ ,/ 但是/ 由于/ 没有/ 对/ 指针/ 进行/ 建模/ ,/ 所以/ 分析/ 范围/ 被/ 限制/ ./ SPLINT/ 和/ LCLINT/ [/ 7/ ]/ 在/ 源代码/ 基础/ 上/ 进行/ 了/ 漏洞/ 检测/ ,/ 为了/ 提高/ 准确性/ ,/ Page3/ 它们/ 需要/ 在/ 源代码/ 上/ 增加/ 注解/ ,/ 而且/ 存在/ 误报率/ 较/ 高/ 的/ 问题/ ./ Nguyen/ 等/ 人/ [/ 8/ ]/ 使用/ 了/ 数据流/ 分析/ 消除/ 程序运行/ 时/ 可能/ 存在/ 的/ 错误/ ,/ 例如/ 数组/ 长度/ 问题/ 等/ ,/ 但是/ 它/ 需要/ 20/ %/ 左右/ 的/ 额外/ 开销/ ./ Rugina/ 等/ 人/ [/ 9/ ]/ 尝试/ 分析程序/ 内存/ 访问/ 时/ 的/ 指针/ 值/ ,/ 但是/ 此/ 方法/ 的/ 分析/ 结果/ 不/ 精确/ ./ Shankar/ 等/ 人/ [/ 10/ ]/ 使用/ 类型/ 的/ 分析方法/ 进行/ 了/ 格式化/ 字符串/ 漏洞/ 的/ 检测/ ,/ 但/ 不能/ 分析/ 整数/ 溢出/ 等/ 其它/ 因素/ 引发/ 的/ 溢出/ 问题/ ./ Cova/ 等/ 人/ [/ 2/ ]/ 将/ 输入/ 标记/ 为/ 污点/ 并/ 进行/ 传递/ ,/ 同时/ 确定/ 可能/ 引发/ 漏洞/ 的/ 点/ ,/ 当/ 两者/ 相遇/ 时/ 标记/ 为/ 漏洞/ ,/ 但/ 这种/ 方法/ 存在/ 大量/ 的/ 误报/ ./ UNO/ [/ 11/ ]/ 使用/ ctree/ 扩展/ 编译器/ ,/ 对/ 每个/ 过程/ 调用/ 产生/ 语法/ 树/ ,/ 从而/ 实现/ 对/ 未知/ 漏洞/ 的/ 检测/ ./ Akritidis/ [/ 12/ ]/ 使用/ 编译器/ 扩展/ 方式/ 对/ 源代码/ 进行/ 标记/ 修改/ 并/ 重新/ 链接/ ,/ 利用/ 运行/ 时/ 信息/ 进行/ 漏洞/ 检测/ ./ 这类/ 方式/ 需要/ 对/ 源代码/ 重新/ 编译/ 才能/ 发现/ 漏洞/ ,/ 不仅/ 方法/ 复杂/ ,/ 而且/ 在/ 多数/ 情况/ 下/ 不/ 具备/ 重新/ 编译程序/ 的/ 条件/ ,/ 通用性/ 不强/ ./ VEX/ [/ 13/ ]/ 使用/ 静态数据/ 流/ 分析方法/ 对流/ 模式/ 进行/ 更/ 细致/ 的/ 定义/ ,/ 从而/ 对/ 浏览器/ 插件/ 进行/ 源代码/ 级别/ 漏洞/ 检测/ ./ Xie/ 等/ 人/ [/ 14/ ]/ 将/ 漏洞/ 挖掘/ 转换/ 为/ SAT/ 可/ 满足/ 性/ 问题/ ,/ 利用/ 已有/ 针对/ 可/ 满足/ 性/ 问题/ 的/ 算法/ 进行/ 求解/ ,/ 但/ 其/ 对/ 循环/ 以及/ 指针/ 指向/ 集/ 的/ 判断/ 不/ 精确/ ,/ 并且/ 依赖于/ 源代码/ 的/ 建模/ 分析/ ./ EXE/ [/ 15/ ]/ 利用/ 动态/ 方法/ 进行/ 了/ 一定/ 改进/ ,/ 但/ 没有/ 对/ 检测点/ 加以/ 选择/ 也/ 没有/ 进行/ 路径/ 条件/ 化简/ ,/ 效率/ 较/ 低/ ./ KLEE/ [/ 16/ ]/ 在/ 其/ 基础/ 上/ 对/ 所有/ 内存/ 进行/ 跟踪/ ,/ 引入/ 表达式/ 重写/ 、/ 约束/ 独立性/ 分析/ 等/ 多种/ 优化/ 算法/ 进行/ 优化/ 求解/ ,/ 提高/ 了/ 检测/ 效率/ 与/ 程序/ 覆盖率/ ./ AEG/ [/ 17/ ]/ 以/ KLEE/ 为/ 基础/ 对/ 文件/ 进行/ 符号化/ ,/ 并/ 对/ 网络/ 等/ 其它/ 资源/ 符号化/ ,/ 使用/ 源代码/ 进行/ 漏洞/ 静态/ 分析/ 并/ 对/ 可执行程序/ 运行/ 时/ 内存/ 结构/ 进行/ 动态分析/ ,/ 利用/ STP/ 进行/ 漏洞/ 检测/ 与/ 自动化/ 地/ 生成/ 利用/ 代码/ ./ IntScope/ [/ 18/ ]/ 将/ 二进制/ 程序转换/ 为/ 一种/ 中间/ 表达形式/ ,/ 使用/ 静态/ 符号执行/ 方法/ 对/ 潜在/ 整数/ 溢出/ 漏洞/ 进行/ 检测/ ./ 夏一民/ 等/ 人/ [/ 19/ ]/ 使用/ 基于/ 条件/ 约束/ 的/ 越界/ 访问/ 检查/ 方法/ ./ 本类/ 方法/ :/ 多/ 基于/ 源代码/ 检测/ ,/ 但是/ 多数/ 商业软件/ 不/ 提供/ 源代码/ ,/ 例如/ Windows/ 、/ Oracle/ 等等/ ,/ 限制/ 了/ 此类/ 方法/ 的/ 适用范围/ ;/ 多为/ 静态/ 检测/ ,/ 在/ 指针/ 别名/ 、/ 间接/ 跳转/ 的/ 处理过程/ 中/ ,/ 或多或少/ 地/ 存在/ 误报率/ 高/ 、/ 漏报/ 率高/ 、/ 效率/ 低下/ 等/ 缺点/ ./ 本文/ 提出/ 的/ 方法/ 针对/ 可执行文件/ ,/ 可以/ 在/ 缺乏/ 源代码/ 的/ 条件/ 下/ 对/ 二进制/ 代码/ 直接/ 分析/ ,/ 解决/ 了/ 指针/ 别名/ 和/ 间接/ 跳转/ 的/ 问题/ ,/ 同时/ 可以/ 避免/ 代码/ 加壳/ 、/ 多态/ 代码/ 等/ 抗/ 反编译/ 手段/ 的/ 影响/ ./ 黑盒/ 测试/ [/ 20/ ]/ 将/ 程序/ 看作/ 是/ 黑盒/ ,/ 通过/ 变换/ 不同/ 的/ 输入/ ,/ 观察/ 程序/ 是否/ 会/ 出现异常/ ,/ 从而/ 进行/ 漏洞/ 检测/ ./ 这类/ 方式/ 由于/ 不/ 需要/ 对/ 程序/ 进行/ 分析/ ,/ 而仅/ 对/ 程序/ 进行/ 运行/ 测试/ ,/ 所以/ 速度/ 较快/ ./ 但是/ 大多数/ 情况/ 下/ ,/ 此类/ 方法/ 仅能/ 穷举/ 有限/ 个/ 输入/ ,/ 并/ 不能/ 对/ 所有/ 的/ 输入/ 都/ 进行/ 测试/ ,/ 因此/ 通过/ 此/ 方法/ 验证/ 程序/ 多/ 存在/ 覆盖率/ 低/ 和/ 输入/ 数据/ 针对性/ 不强/ 等/ 缺点/ ./ Bisht/ 等/ 人/ [/ 21/ ]/ 采用/ 黑盒/ 方式/ 对/ 网络应用/ 程序/ 服务端/ 进行/ 漏洞/ 检测/ ,/ 在/ 测试数据/ 集/ 生成/ 过程/ 中/ 对/ 客户端/ 源代码/ 进行/ 分析/ ,/ 提高/ 输入/ 数据测试/ 的/ 有效性/ ./ Godefroid/ 等/ 人/ [/ 22/ ]/ 通过/ 对/ 路径/ 约束条件/ 逐一/ 反向/ 变化/ 并/ 求解/ 的/ 方式/ 进行/ 路径/ 覆盖/ ,/ 在/ 此基础/ 上/ 进行/ 黑盒/ 测试/ ,/ 增加/ 程序/ 覆盖范围/ ./ Wang/ 等/ 人/ [/ 23/ ]/ 提出/ 校验/ 和/ 感知/ 导向/ 的/ 黑盒/ 测试/ 技术/ ,/ 结合/ 混合/ 符号执行/ 与/ 细粒度/ 动态/ 污点/ 跟踪/ 技术/ ,/ 绕过/ 校验/ 和/ 机制/ 进行/ 漏洞/ 检测/ ,/ 解决/ 了/ 传统/ 方式/ 下/ 遇到/ 校验/ 和/ 防护/ 机制/ 时/ 难以/ 检测/ 的/ 问题/ ,/ 提高/ 了/ 黑盒/ 测试/ 的/ 针对性/ 和/ 有效性/ ./ SmartFuzz/ [/ 24/ ]/ 对多类/ 整数/ 漏洞/ 进行/ 检测/ ,/ 使用/ 白盒/ 方式/ 对/ 程序/ 进行/ 分析/ 指导/ 测试数据/ 生成/ ,/ 结合/ 黑盒/ 方式/ 进行/ 漏洞/ 测试/ ,/ 提高/ 了/ 测试/ 效率/ 与/ 程序/ 覆盖面/ ./ 本文/ 采用/ 对/ 程序/ 本身/ 进行/ 分析/ 的/ 方法/ ,/ 因此/ 很大/ 程度/ 上/ 减小/ 了/ 漏报/ 的/ 可能性/ ./ 通过/ 捕获/ 攻击/ 从而/ 对/ 漏洞/ 进行/ 检测/ 是/ 一种/ 被动/ 的/ 检测/ 方式/ ,/ 这种/ 方式/ 主要/ 用来/ 检测/ 已知/ 但是/ 未公开/ 的/ 漏洞/ ./ Pax/ 、/ LibSafe/ [/ 25/ ]/ 和/ e/ -/ NeXSh/ [/ 26/ ]/ 通过/ 修改/ 操作系统/ ,/ 使得/ 存在/ 漏洞/ 的/ 软件/ 即使/ 在/ 漏洞/ 触发/ 也/ 不会/ 引发/ 危害/ ./ 但/ 其/ 局限于/ 开源/ 的/ 操作系统/ ,/ 并且/ 一旦/ 操作系统/ 版本/ 发生变化/ ,/ 这/ 类/ 软件/ 本身/ 也/ 需要/ 重新/ 修改/ ,/ 通用性/ 不强/ ./ 文献/ [/ 27/ ]/ 中/ 提出/ 了/ 将/ 子程序/ 返回/ 地址/ 保存/ 在/ 处理器/ 而/ 非/ 内存/ 中/ ,/ 这样/ 即使/ 漏洞/ 触发/ ,/ 漏洞/ 利用/ 程序/ 也/ 无法/ 修改/ 处理器/ 中/ 的/ 返回/ 地址/ ./ 这种/ 方法/ 需要/ 硬件/ 的/ 支持/ ,/ 适用范围/ 较/ 小/ ./ 文献/ [/ 28/ ]/ 中/ 提出/ 了/ 一种/ 基于/ 数据流/ 完整性/ 检测/ 的/ 方法/ 对/ 程序/ 进行/ 保护/ ./ 当/ 攻击/ 发生/ 时/ ,/ 程序/ 的/ 完整性/ 被/ 破坏/ ,/ Castro/ 对比/ 前后/ 程序/ 状态/ 从而/ 对/ 攻击/ 进行/ 检测/ ./ 此/ 方法/ 仍然/ 需要/ 对/ 源代码/ 进行/ 分析/ ,/ 且/ 不能/ 解决/ 指针/ 的/ 间接/ 跳转/ 问题/ ./ Kiriansky/ 等/ 人/ [/ 29/ ]/ 提出/ 了/ 程序/ 监管/ 的/ 概念/ ,/ 监视/ 控制流/ 的/ 转移/ ,/ 当/ 发现/ 控制流/ 与/ 安全策略/ 冲突/ 时/ ,/ 确认/ 攻击/ 的/ 存在/ ./ Bhatkar/ 等/ 人/ [/ 30/ ]/ 使用/ 了/ 程序/ 地址/ 随机化/ 的/ 方法/ 改变/ 代码/ 和/ 数据/ 对象/ 的/ 原/ 地址/ ,/ 使/ 漏洞/ 不能/ 被/ 正常/ 利用/ ./ Vigilante/ [/ 3/ ]/ 使用/ 信息流/ 方式/ 检测/ 蠕虫/ 等/ 攻击/ ,/ 同时/ 产生/ SCA/ 通知/ 其它/ 的/ 系统/ ,/ 但是/ 它/ 对系统/ 的/ 保护/ 范围/ 相当/ 有限/ ./ MemSherlock/ [/ 4/ ]/ 使用/ 信息流/ 方法/ ,/ 在/ 攻击/ 发生/ 时/ 确认/ 漏洞/ 可能/ 发生/ 的/ 位置/ ,/ 但/ 它/ 也/ 需要/ 对/ 源代码/ 进行/ Page4/ 预/ 分析/ ./ 值得注意/ 的/ 是/ ,/ Vigilante/ 和/ MemSherlock/ 都/ 不能/ 对系统/ 内核/ 进行/ 分析/ ./ 此类/ 漏洞/ 检测/ 方式/ 为/ 被动/ 方式/ ,/ 仅能/ 发现/ 别人/ 已/ 发现/ 的/ 漏洞/ ,/ 并/ 不能/ 对/ 未知/ 的/ 漏洞/ 进行/ 检测/ ./ 本文/ 所述/ 系统/ 使用/ 虚拟环境/ ,/ 可以/ 在/ 不/ 修改/ 操作系统/ 和/ 计算机硬件/ 的/ 前提/ 下/ ,/ 主动/ 发现/ 指定/ 应用程序/ 和/ 系统/ 内核/ 本身/ 的/ 漏洞/ ./ 3/ 方法/ 与/ 基本原理/ 3.1/ 概述/ 缓冲区/ 溢出/ 指/ 程序/ 向/ 缓冲区/ 内/ 填充/ 的/ 数据/ 超过/ 了/ 缓冲区/ 的/ 容量/ ,/ 从而/ 覆盖/ 了/ 合法/ 数据/ ./ 这/ 主要/ 是/ 在/ 赋值/ 过程/ 中/ ,/ 未/ 考虑/ 缓冲区/ 边界/ 造成/ 的/ ,/ 因此/ 缓冲区/ 边界检测/ 成为/ 了/ 溢出/ 漏洞/ 检测/ 的/ 必要条件/ ./ 传统/ 方式/ 主要/ 从/ 源代码/ 角度/ 进行/ 缓冲区/ 边界检测/ ,/ 但/ 由于/ 多数/ 软件/ 并/ 不/ 提供/ 源代码/ ,/ 因此/ 限制/ 了/ 这种/ 方式/ 的/ 使用/ 范围/ ./ 继而/ 人们/ 以/ 可执行程序/ 为/ 目标/ 直接/ 进行/ 分析/ ,/ 但/ 多/ 延用/ 传统/ 的/ 静态/ 分析方法/ ./ 静态方法/ 难以解决/ 可执行程序/ 本身/ 的/ 不确定性/ 问题/ ,/ 也/ 无法/ 处理/ 软件保护/ 手段/ 所/ 带来/ 的/ 反编译/ 问题/ ,/ 造成/ 了/ 分析/ 结果/ 不/ 准确/ 、/ 效率/ 低下/ 等/ 缺点/ ./ 为了/ 克服/ 上述/ 缺点/ ,/ 我们/ 采用/ 动态/ 方式/ 进行/ 可/ 执行/ 代码/ 的/ 分析/ ./ 图/ 1/ 是/ 漏洞/ 分析/ 结构图/ ,/ 包括/ 虚拟环境/ 和/ 漏洞/ 分析器/ 两/ 大部分/ ./ 漏洞/ 分析器/ 是/ 分析/ 的/ 核心/ 模块/ ,/ 它/ 由/ 污点/ 数据分析/ 器/ 、/ 检测点/ 选择器/ 、/ CSP/ 表达式/ 生成器/ 和/ 循环/ 检测器/ 4/ 个/ 部分/ 组成/ ./ 具体/ 的/ 分析/ 过程/ 如下/ :/ 首先/ 在/ 虚拟环境/ 中/ 加载/ 待/ 分析程序/ ./ 使用/ 虚拟环境/ 进行/ 分析/ ,/ 可/ 有效/ 隔离/ 待/ 分析程序/ 与/ 漏洞/ 分析器/ ,/ 避免/ 了/ 两者/ 处于/ 同一/ 执行/ 环境/ 中/ 带来/ 的/ 相互影响/ ;/ 漏洞/ 分析器/ 也/ 可以/ 透明/ 地/ 从/ 虚拟环境/ 内部/ 提取/ 所/ 需/ 代码/ 和/ 数据/ ,/ 提高/ 分析/ 的/ 可靠性/ ./ 当待/ 分析程序/ 启动/ 时/ ,/ 污点/ 数据分析/ 器为/ 其/ 分配/ 影子/ 内存/ ./ 影子/ 内存/ 是/ 真实/ 内存/ 的/ 镜像/ ,/ 其中/ 每/ 一位/ 表示/ 真实/ 内存/ 是否/ 依赖于/ 外部/ 输入/ ./ 例如/ 图/ 1/ 中/ ,/ 当待/ 分析程序/ 把/ 接收/ 到/ 外部/ 输入/ INPUT/ 放入/ 变量/ var/ 时/ ,/ var/ 对应/ 的/ 影子/ 内存/ 即/ 被/ 置位/ ./ 在/ 程序执行/ 过程/ 中/ ,/ 影子/ 内存/ 是/ 可/ 传递/ 的/ ./ 在/ 图/ 1/ 的/ 分支/ 语句/ 中/ ,/ mem/ 依赖于/ var/ ,/ 所以/ mem/ 对应/ 的/ 影子/ 内存/ 也/ 被/ 置位/ ./ 在/ 待/ 分析程序/ 执行/ 过程/ 中/ ,/ 检测点/ 选择器/ 选择/ 合适/ 的/ 程序/ 检测点/ ,/ 并/ 由/ CSP/ 生成器/ 构造/ CSP/ 表达式/ 进行/ 漏洞/ 验证/ ./ 为了/ 减少/ 漏报/ ,/ 需/ 增加/ 程序/ 检测点/ 的/ 覆盖面/ ;/ 但是/ 过多/ 的/ 检测点/ 又/ 会/ 影响/ 分析/ 效率/ ./ 我们/ 使用/ 污点/ 传播方式/ 和/ 动态/ 循环/ 识别/ 方式/ 减少/ 检测点/ 的/ 选取/ ./ 污点/ 传播/ 由/ 污点/ 数据分析/ 器/ 进行/ 管理/ ,/ 而/ 循环/ 识别/ 由/ 循环/ 识别器/ 在/ 程序/ 的/ 分析/ 过程/ 中/ 自动/ 完成/ ./ 最后/ 进行/ CSP/ 表达式/ 的/ 化简/ 并/ 求解/ ./ 为了/ 减少/ CSP/ 表达式/ 中/ 的/ 条件/ 个数/ ,/ CSP/ 生成器/ 分析/ 条件/ 表达式/ 的/ 组成部分/ ,/ 并/ 选取/ 与/ 检测点/ 直接/ 相关/ 部分/ 进行/ 求解/ (/ 见/ 3.6/ 节/ )/ ./ 利用/ 这种/ 方式/ ,/ 可以/ 避免/ 使用/ 效率/ 低下/ 的/ 切片/ 分析方法/ ./ 由于/ 分析/ 过程/ 是/ 动态/ 的/ ,/ 可以/ 将/ CSP/ 表达式/ 中/ 不/ 依赖于/ 外部/ 输入/ 的/ 变量/ 替换/ 成为/ 立即/ 数/ 进行/ 化简/ ./ 如果/ 表达式/ 可解/ ,/ 则/ 漏洞/ 存在/ ,/ 并且/ 此解/ 可以/ 直接/ 作为/ 漏洞/ 的/ 触发/ 条件/ ./ 3.2/ 污点/ 传播/ 污点/ 传播/ [/ 31/ ]/ 是/ 一种/ 有效/ 确认/ 变量/ 之间/ 是否/ 相关/ 的/ 分析方法/ ./ 由于/ 漏洞/ 检测点/ 的/ 选取/ 过程/ 中仅/ 需要/ 知道/ 变量/ 与/ 输入/ 之间/ 的/ 关系/ ,/ 因此/ 这里/ 选用/ 影子/ 内存/ 进行/ 配合/ 分析/ ./ 当/ 程序/ 变量/ 与/ 输入/ 相关/ 时/ ,/ 在/ 影子/ 内存/ 上/ 增加/ 标记/ ,/ 标明/ 其/ 关系/ 即可/ ./ 传统/ 分析/ 过程/ 中/ 一般/ 使用/ 切片/ 方法/ 进行/ 变量/ 间/ 关系/ 的/ 判别/ ./ 程序/ 切片/ 是/ MarkWeiser/ 在/ 其/ 博士论文/ 中/ 提出/ ,/ 对/ 程序/ 变量/ 之间/ 的/ 依赖/ 关系/ 进行/ 分析/ 的/ 方法/ ./ 典型/ 的/ 有/ 数据流/ 切片/ [/ 32/ ]/ 和/ 基于/ 图/ 可达性/ [/ 33/ ]/ 的/ 切片/ 方法/ ,/ 但/ 方法/ 复杂/ ,/ 效率/ 较/ 低/ ./ 污点/ 传播/ 和/ 影子/ 内存/ 相结合/ 的/ 方式/ 可以/ 避免/ 使用/ 程序/ 切片/ ,/ 适合/ 于/ 动态分析/ ./ 本文/ 中/ ,/ 污点/ 数据/ 包括/ 从/ 网络/ 、/ 硬盘/ 文件/ 或者/ 用户/ 输入/ 等/ 外界/ 获得/ 的/ 数据/ ./ 因此/ 污点/ 源/ 可以/ 是/ 网卡/ 、/ 硬盘/ 或者/ 是/ 键盘/ 等/ ./ 这里/ 我们/ 在/ 虚拟/ 硬件/ 层/ 设置/ 污点/ 源/ ,/ 从/ 操作系统/ 底层/ 直接/ 进行/ 操作/ ,/ 避免/ 污点/ 数据/ 的/ 遗漏/ ./ 影子/ 内存/ 是/ 真实/ 内存/ 的/ 镜像/ ,/ 它/ 的/ 每/ 一/ 字节/ 标志/ 着/ 真实/ 内存/ 对应/ 位置/ 的/ 字节/ 是否/ 依赖于/ 污点/ 数据/ ./ 同时/ 我们/ 在/ 影子/ 内存/ 最/ 前端/ 扩充/ 出/ 若干/ 字节/ ,/ 表/ Page5/ 示/ CPU/ 中/ 的/ 寄存器/ 是否/ 也/ 依赖于/ 污点/ 数据/ ./ 污点/ 数据/ 通过/ 数据/ 传送/ 、/ 算术/ 操作/ 、/ 逻辑/ 操作/ 等/ 指令/ 进行/ 传递/ 的/ 过程/ 称为/ 污点/ 传播/ ./ 不同/ 的/ 指令/ 具有/ 不同/ 的/ 传播方式/ ,/ 针对/ 不同/ 的/ 方式/ ,/ 我们/ 制定/ 了/ 相应/ 的/ 污点/ 传播/ 规则/ ./ 以下/ 是/ 部分/ 有/ 代表性/ 指令/ 的/ 污点/ 传播/ 规则/ ,/ 其它/ 指令/ 类似/ ./ 数据/ 传送/ 指令/ :/ movop1/ ,/ op2/ :/ T/ (/ op1/ )/ ←/ T/ (/ op2/ )/ 算术/ 操作/ 指令/ :/ addop1/ ,/ op2/ :/ T/ (/ op1/ )/ ←/ T/ (/ op1/ )/ ∨/ T/ (/ op2/ )/ ;/ T/ (/ μ/ (/ add/ ,/ PSW/ )/ )/ ←/ T/ (/ op1/ )/ ∨/ T/ (/ op2/ )/ 逻辑/ 操作/ 指令/ :/ andop1/ ,/ op2/ :/ T/ (/ op1/ )/ ←/ T/ (/ op1/ )/ ∨/ T/ (/ op2/ )/ ;/ T/ (/ μ/ (/ and/ ,/ PSW/ )/ )/ ←/ T/ (/ op1/ )/ ∨/ T/ (/ op2/ )/ 栈/ 操作/ 指令/ :/ pushop/ :/ T/ (/ / esp/ )/ ←/ T/ (/ op/ )/ 其中/ T/ (/ op/ )/ →/ BOOL/ ,/ 表示/ op/ 所/ 指向/ 的/ 操作数/ 是否/ 为/ 污点/ 数据/ ;/ PSW/ 表示/ 机器/ 状态字/ ;/ μ/ (/ op/ ,/ PSW/ )/ →/ / ,/ 表示/ op/ 操作/ 引发/ PSW/ 中/ 变化/ 的/ 位置/ ,/ 例如/ add/ 操作/ 会/ 引起/ C/ 、/ P/ 、/ A/ 、/ Z/ 、/ S/ 、/ O/ 等/ 标志/ 位/ 的/ 改变/ ;/ / 表示/ 地址/ 所/ 对应/ 的/ 内存/ ./ 注意/ add/ 、/ and/ 等/ 算术/ 指令/ 会/ 影响/ PSW/ 的/ 值/ ,/ 这里/ 也/ 必须/ 引入/ ,/ 因为/ cmp/ 等/ 比较/ 指令/ 会/ 依赖于/ PSW/ 的/ 值/ ./ 值得注意/ 的/ 是/ ,/ 一些/ 编译器/ 为了/ 增加/ 效率/ ,/ 并/ 不/ 直接/ 使用/ mov/ 指令/ 产生/ 某些/ 常数/ ,/ 而会/ 使用/ 一些/ 效率/ 较/ 高/ 的/ 计算方法/ ./ 例如/ 为了/ 产生/ 常数/ 0/ ,/ 编译器/ 通常/ 会/ 生成/ “/ xoreax/ ,/ eax/ ”/ 指令/ ./ 此时/ 即使/ T/ (/ eax/ )/ =/ 1/ ,/ 也/ 不/ 需要/ 将/ eax/ 再次/ 设置/ 为/ 污点/ 数据/ ./ 相反/ 地/ ,/ 需要/ 设置/ T/ (/ eax/ )/ =/ 0/ ./ 此类/ 语句/ 还有/ “/ subeax/ ,/ eax/ ”/ 、/ “/ andeax/ ,/ 0/ ”/ 、/ “/ oreax/ ,/ 1/ ”/ 等/ ./ 使用/ 上述/ 方法/ 时/ ,/ 依赖于/ 控制/ 依赖/ 关系/ 的/ 赋值/ 操作/ 会/ 阻碍/ 污点/ 数据/ 的/ 传播/ ,/ 例如/ :/ switch/ (/ var1/ )/ {/ case/ ‘/ a/ ’/ :/ var2/ =/ ‘/ a/ ’/ ;/ case/ ‘/ b/ ’/ :/ var2/ =/ ‘/ b/ ’/ ;/ break/ ;/ …/ }/ 假设/ var1/ 是/ 污点/ 数据/ ,/ 以上/ 的/ 赋值/ 操作/ 并/ 不能/ 将/ 污点/ 数据/ 传播/ 到/ var2/ 上/ ./ 对于/ 此类/ 特殊/ 情况/ ,/ 我们/ 判断/ T/ (/ ξ/ (/ op/ ,/ PSW/ )/ )/ 的/ 值/ ,/ 其中/ ξ/ (/ op/ ,/ PSW/ )/ →/ / 表示/ op/ 依赖于/ PSW/ 中/ 的/ 位置/ ./ 在/ 汇编程序/ 中/ ,/ op/ 通常/ 为/ jz/ 等/ 条件/ 跳转/ 语句/ ./ 假设/ T/ (/ ξ/ (/ op/ ,/ PSW/ )/ )/ =/ 1/ ,/ 则/ 所有/ 控制/ 依赖于/ op/ 操作/ 的/ 赋值/ 语句/ 都/ 作为/ 污点/ 数据/ 进行/ 赋值/ ./ 控制/ 依赖/ 具有/ 一定/ 的/ 范围/ ,/ 计算方法/ 如下/ ./ 定义/ 1/ ./ 自然/ 后继/ ./ 语句/ Ii/ 的/ 自然/ 后继/ 表示/ 此/ 语句/ 的/ 下/ 一/ 标号/ 所在/ 语句/ Ii/ +/ 1/ ./ 定义/ 2/ ./ 跳转/ 后继/ ./ 语句/ Ii/ 的/ 跳转/ 后继/ 表示/ 此/ 语句/ 跳转/ 目标/ 所在/ 语句/ Iop/ ./ 这里/ 使用/ S/ :/ / →/ / 表示/ 语句/ 的/ 跳转/ 后继/ ,/ / 表示/ 语句/ 的/ 标号/ ./ 例如/ 下面/ 代码/ 片段/ :/ 1/ :/ jmp32/ :/ addeax/ ,/ 13/ :/ addeax/ ,/ 2/ 语句/ 1/ 的/ 自然/ 后继/ 为/ 2/ ,/ 但是/ 跳转/ 后继/ 为/ 3/ ./ 假设/ op/ 所在/ 语句/ 为/ Im/ ,/ 当/ T/ (/ ξ/ (/ op/ ,/ PSW/ )/ )/ =/ 1/ 时/ ,/ 目前/ 计算/ 的/ 被/ 控制/ 依赖/ 影响/ 的/ 语句/ 标号/ 范围/ 如下/ :/ [/ mini/ (/ P/ (/ m/ ,/ i/ )/ )/ ,/ mini/ (/ i/ >/ m/ ∧/ P/ (/ m/ +/ 1/ ,/ i/ )/ ∧/ P/ (/ S/ (/ m/ )/ ,/ i/ )/ )/ ]/ ,/ P/ (/ i/ ,/ j/ )/ →/ BOOL/ 表示/ 语句/ i/ 和/ j/ 之间/ 是否/ 存在/ 通路/ ./ 通过/ 此/ 方法/ 就/ 可以/ 尽量避免/ 由于/ 控制/ 依赖/ 引起/ 的/ 条件/ 遗漏/ 问题/ ./ 3.3/ CSP/ 表达式/ 的/ 构造/ 在/ 程序/ 的/ 分析/ 过程/ 中/ ,/ 顺序/ 语句/ 具有/ 这样/ 的/ 特性/ :/ 程序流程/ 始终/ 是从/ 顺序/ 语句/ 的/ 第一条/ 进入/ ,/ 最后/ 一条/ 流出/ ,/ 且/ 这些/ 顺序/ 语句/ 具有/ 相同/ 的/ 执行/ 条件/ ./ 因此/ 顺序/ 语句/ 可以/ 当作/ 一个/ 整体/ 看待/ ./ 我们/ 有/ 如下/ 定义/ ./ 定义/ 3/ ./ 程序/ 基本块/ ./ 程序/ 基本块/ 是/ 指/ 由/ 不/ 包含/ 或者/ 仅/ 在/ 基本块/ 末尾/ 包含/ 流程/ 跳转/ 指令/ 的/ 指令/ 序列/ ./ 后面/ 简称/ 为/ 基本块/ ,/ 由/ B/ 表示/ ./ 块/ B/ 分为/ 4/ 种/ 类型/ :/ 基本块/ ,/ 用/ CB/ 表示/ ./ 基本块/ ,/ 为/ J/ 型/ 基本块/ ,/ 用/ JB/ 表示/ ./ 块/ ,/ 为/ R/ 型/ 基本块/ ,/ 用/ RB/ 表示/ ./ (/ 1/ )/ 出口/ 语句/ 为/ 子程序/ 调用/ 的/ 基本块/ ,/ 为/ C/ 型/ (/ 2/ )/ 出口/ 语句/ 为/ 直接/ 跳转/ 或者/ 条件/ 跳转/ 语句/ 的/ (/ 3/ )/ 出口/ 语句/ 为/ 子程序/ 调用/ 返回/ 语句/ 的/ 基本/ 根据/ 基本块/ 出口/ 语句/ 类型/ 的/ 不同/ ,/ 可以/ 将/ 基本/ (/ 4/ )/ 其它/ 基本块/ ,/ 为/ S/ 型/ 基本块/ ,/ 用/ SB/ 表示/ ./ 通过/ 这种/ 方式/ ,/ 基本块/ 中/ 的/ 语句/ 即可/ 共享/ 一个/ 入口/ 条件/ ./ 在/ CSP/ 构建/ 过程/ 中/ ,/ 我们/ 使用/ 动态/ 方式/ 进行/ 循环/ 识别/ ,/ 以/ 增加/ 检测/ 过程/ 对/ 多态/ 等/ 抗/ 反编译/ 手段/ 的/ 分析/ 能力/ ./ 对于/ 程序/ 内不含/ 子程序/ 调用/ 的/ 每个/ 基本块/ ,/ 我们/ 按照/ 其/ 执行/ 顺序/ 进行/ 标记/ ,/ 第/ 1/ 个/ 基本块/ 记为/ B1/ ,/ 并/ 以此类推/ ./ 如果/ 一个/ 基本块/ Bi/ 在/ 同一/ 程序/ 中/ 被/ 执行/ 两次/ ,/ 则/ 第/ 2/ 次/ 仍/ 保持/ 原有/ 标记/ ,/ 同时/ 清除/ 标记/ Bj/ (/ j/ >/ i/ )/ ,/ 并/ 对/ 这些/ 基本块/ 次数/ 重新/ 计数/ ./ 当有/ 子程序/ 调用/ 时/ ,/ 在/ 子程序/ 内部/ ,/ 对/ 基本块/ 重新/ 计数/ ,/ 并/ 增加/ 当前/ 执行/ 环境/ 层次/ ./ 当/ 子程序/ 返回/ 时/ ,/ 继续/ 子程序/ 调用/ 前/ 的/ 基本块/ 序号/ ,/ 同时/ 减少/ 执行/ 环境/ 的/ 层/ Page6/ 次/ ./ 我们/ 使用/ S/ 表示/ 程序/ 中/ 出现/ 的/ 循环/ ,/ t/ :/ B/ →/ n/ 表示/ 基本块/ B/ 执行/ 的/ 次数/ ,/ 在/ 程序执行/ 过程/ 中/ ,/ 有/ 以下/ 定理/ ./ 定理/ 1/ ./ 在/ 同一/ 层次/ 内/ ,/ mini/ (/ t/ (/ Bi/ )/ =/ 2/ )/ →/ Bi/ ∈/ S/ 且/ Bi/ 是/ 循环/ 中/ 的/ 第一个/ 基本块/ ./ 证明/ ./ 假设/ Bi/ 不/ 在/ 循环/ 中/ ,/ 则/ 由于/ t/ (/ Bi/ )/ =/ 2/ 以及/ 标记/ 的/ 顺序/ ,/ 存在/ 两个/ 节点/ j/ 和/ k/ ,/ 使得/ j/ =/ i/ -/ 1/ 且/ k/ =/ i/ -/ 1/ ,/ 因此/ j/ =/ k/ ,/ 则/ j/ 是/ 满足/ t/ (/ Bj/ )/ =/ 2/ 的/ 最小/ 标号/ ,/ 与题/ 设/ 矛盾/ ,/ 因此/ Bi/ 在/ 循环/ 中/ ./ 易知/ ,/ Bi/ 为/ 循环/ 中/ 的/ 第/ 1/ 个/ 基本块/ ./ 按照/ 定理/ 1/ 可以/ 很/ 容易/ 地/ 在/ 程序运行/ 过程/ 中/ 判断/ 某个/ 基本块/ 是否/ 在/ 循环/ S/ 中/ ./ 根据/ S/ 本身/ 的/ 性质/ ,/ 可以/ 将/ S/ 使用/ 如下/ 特性/ 进行/ 表示/ :/ S/ / (/ p/ ,/ sp/ ,/ σ/ ,/ τ/ ,/ χ/ ,/ δ/ )/ ,/ 其中/ p/ 表示/ 将/ 被/ 赋值/ 的/ 起始/ 位置/ ,/ sp/ 表示/ 关键/ 数据/ 域/ 的/ 位置/ ,/ 例如/ 对于/ 栈/ ,/ sp/ 表示/ 子程序/ 栈底/ 的/ 位置/ ;/ 对于/ 堆/ sp/ 表示/ 堆/ 管理/ 结构/ 的/ 位置/ ,/ σ/ 表示/ 循环/ 步长/ ,/ τ/ 表示/ 循环/ 次数/ ,/ χ/ 表示/ 每次/ 循环/ 进行/ 覆盖/ 的/ 字节数/ ,/ δ/ 表示/ 循环/ 方向/ ,/ 如果/ 是/ 向着/ sp/ 方向/ ,/ δ/ =/ 1/ ,/ 否则/ δ/ =/ 0/ ./ 根据/ 这些/ 信息/ ,/ 可以/ 构造/ 基本/ 的/ 溢出/ 型/ CSP/ 表达式/ ./ 栈/ 溢出/ 和/ 堆/ 溢出/ 是/ 缓冲区/ 溢出/ 的/ 两种/ 基本/ 形式/ ,/ 也/ 是/ 主要/ 的/ 漏洞/ 形式/ ./ 现在/ 以/ IntelCPU/ 为例/ ,/ 可以/ 构造/ 栈/ 溢出/ 表达式/ ./ 定理/ 2/ ./ 栈/ 溢出/ 表达式/ :/ pi/ +/ 1/ -/ pi/ >/ 0/ ∧/ (/ χ/ +/ σ/ )/ τ/ </ sp/ -/ p/ ,/ 其中/ pi/ 表示/ 第/ i/ 次/ 被/ 赋值/ 的/ 位置/ ./ 证明/ ./ pi/ +/ 1/ -/ pi/ >/ 0/ / δ/ =/ 1/ ,/ 而/ (/ χ/ +/ σ/ )/ τ/ </ sp/ -/ p/ 保证/ 了/ 赋值/ 操作/ 不会/ 超越/ 栈基/ ./ 因此/ 栈/ 溢出/ 表达式/ 是/ 程序/ 不/ 含/ 漏洞/ 的/ 必要条件/ ./ 证毕/ ./ 这里/ 有/ 两点/ 值得注意/ :/ (/ 1/ )/ 对于/ 栈仅/ 考虑/ 向/ 栈基/ 方向/ 赋值/ ,/ 因为/ 栈基/ 方向/ 存储/ 着/ 返回/ 地址/ 等/ 程序运行/ 过程/ 中/ 的/ 重要/ 信息/ ,/ 而且/ 赋值/ 点/ 与/ 栈基/ 方向/ 的/ 距离/ 较/ 小/ ,/ 更/ 容易/ 产生/ 溢出/ 漏洞/ ;/ 而栈/ 尾/ 方向/ 一般/ 与/ 赋值/ 点/ 距离/ 很大/ ,/ 溢出/ 概率/ 小/ ,/ 即使/ 发生/ 溢出/ ,/ 也/ 难以/ 造成危害/ ./ (/ 2/ )/ 我们/ 观察/ 到/ ,/ 大多数/ 情况/ 下/ 循环/ 赋值/ 的/ 步长/ 具有/ 一致性/ ./ 因此/ ,/ 为了/ 简化/ 分析/ 过程/ ,/ 我们/ 假设/ 每次/ 循环/ 赋值/ 的/ 步长/ 一样/ ./ 如果/ 要/ 进行/ 更/ 精确/ 的/ 分析/ ,/ 仅/ 需/ 对于/ 不/ 一致/ 的/ 循环/ 步长/ 增加/ 一项/ CSP/ 表达式/ 即可/ ./ 对于/ 堆/ 溢出/ ,/ 需要/ 监控/ 待/ 分析/ 程序运行/ 过程/ 中/ 的/ 堆/ 申请/ 函数/ 以/ 确定/ 堆/ H/ 的/ 起始/ 位置/ 和/ 大小/ Hsize/ ./ 由此/ 可以/ 构造/ 堆/ 溢出/ CSP/ 表达式/ ./ 定理/ 3/ ./ 堆/ 溢出/ 表达式/ :/ (/ pi/ -/ pi/ +/ 1/ >/ 0/ ∧/ (/ χ/ +/ σ/ )/ τ/ </ p/ -/ sp/ )/ ∨/ (/ pi/ +/ 1/ -/ pi/ >/ 0/ ∧/ (/ χ/ +/ σ/ )/ τ/ </ Hsize/ -/ p/ )/ ,/ 其中/ pi/ -/ pi/ +/ 1/ >/ 0/ / δ/ =/ 1/ ,/ pi/ +/ 1/ -/ pi/ >/ 0/ / δ/ =/ 0/ ,/ 注意/ 这里/ 和/ 栈/ 溢出/ 的/ 方向/ 区别/ ,/ 栈底/ 一般/ 在/ 高/ 地址/ ,/ 而堆/ 管理/ 结构/ 一般/ 在/ 低/ 地址/ ./ 由于/ 本/ 分析方法/ 是/ 在/ 汇编语言/ 上/ 分析/ ,/ 所以/ 可以/ 避免/ 高级/ 语言/ 中/ 由于/ 整数/ 类型/ 不/ 一致/ 而/ 产生/ 的/ 漏洞/ ./ 例如/ 下例/ 是/ Linux/ 内核/ XDR/ 有/ 符号/ 整数/ 溢出/ 漏洞/ ,/ 第/ 3/ 行/ 代表/ 漏洞/ 引发/ 的/ 原因/ ,/ 由于/ p/ 是/ 无/ 符号/ 数/ 指针/ ,/ 如果/ 其值/ 过/ 大/ ,/ 当/ 将/ 其/ 内容/ 转为/ 有/ 符号/ 数时/ ,/ 会/ 产生/ 负数/ ,/ 自然/ 通过/ 第/ 4/ 行/ 的/ 界限/ 判断/ ,/ 但是/ 在/ 第/ 6/ 行/ 赋值/ 操作/ 时会/ 引发/ 漏洞/ :/ 1/ ./ staticinlineu32/ / decode/ _/ fh/ (/ u32/ / p/ ,/ structsvc/ _/ fh2/ ./ intsize/ ;/ fh/ _/ init/ (/ fhp/ ,/ NFS3/ _/ FHSIZE/ )/ ;/ 3/ ./ size/ =/ ntohl/ (/ / p/ ++/ )/ ;/ 4/ ./ if/ (/ size/ >/ NFS3/ _/ FHSIZE/ )/ 5/ ./ returnNULL/ ;/ 6/ ./ memcpy/ (/ &/ fhp/ -/ >/ fh/ _/ handle/ ./ fh/ _/ base/ ,/ p/ ,/ size/ )/ ;/ …/ …/ }/ 但是/ 由于/ 汇编语言/ 本身/ 就/ 有/ 有/ 符号/ 跳转/ 与/ 无/ 符号/ 跳转/ ,/ 因此/ 仅/ 需要/ 对/ 其/ 跳转/ 指令/ 进行/ 条件/ 判断/ 即可/ ,/ 不/ 需要/ 专门/ 判断/ 整数/ 溢出/ 产生/ 的/ 堆栈/ 溢出/ 问题/ ./ 对于/ 格式化/ 字符串/ 漏洞/ ,/ 当有/ 恶意/ 输入/ 被/ 写入/ 时/ ,/ 本/ 方法/ 也/ 能/ 通过/ 污点/ 传播/ 的/ 方式/ 检测/ 出/ ./ 将/ 程序/ 划分/ 为/ 基本块/ 进行/ 分析/ ,/ 同时/ 保留/ 其/ 分析/ 结果/ ,/ 当/ 再次/ 遇到/ 已/ 分析/ 过/ 的/ 基本块/ 时/ 不用/ 重新/ 计算/ 基本块/ 内/ 条件/ 集合/ ./ 这样/ 每个/ 基本块/ 仅/ 需/ 分析/ 一次/ ,/ 可以/ 显著/ 提高/ 分析/ 效率/ ./ 堆栈/ 表达式/ 仅仅/ 是/ 赋值/ 时所/ 产生/ 的/ 表达式/ ,/ 多数/ 情况/ 下/ ,/ 为了/ 判别/ 此/ 表达式/ 的/ 漏洞/ 信息/ ,/ 还/ 需要/ 将/ 此/ 语句/ 的/ 执行/ 条件/ 加入/ CSP/ 表达式/ ./ 在/ 程序执行/ 过程/ 中/ ,/ 漏洞/ 分析器/ 维持/ 条件/ Sc/ ,/ 每当/ 碰到/ 新/ 的/ 条件/ 语句/ C/ ,/ 即将/ C/ 并入/ Sc/ ,/ 得到/ 新/ 的/ 条件/ Sc/ ∧/ C/ ./ 但是/ 当/ 条件/ 过多/ 的/ 时候/ ,/ Sc/ 会变/ 的/ 很大/ ,/ 因此/ 需要/ 对/ 其/ 进行/ 分析/ 选择/ 合适/ 的/ C/ ,/ 控制/ CSP/ 表达式/ 的/ 长度/ ./ 例如/ 当/ 得到/ CSP/ =/ p1/ ∧/ p2/ ∧/ …/ ∧/ pn/ 时/ ,/ 对于/ pi/ ,/ 如果/ / x/ (/ x/ ∈/ pi/ →/ T/ (/ x/ )/ =/ 0/ )/ ,/ 则/ 可以/ 直接/ 删除/ pi/ ,/ 因为/ pi/ ≡/ true/ ,/ 否则/ 程序/ 不能/ 运行/ 到/ 此处/ ./ 最后/ ,/ 将/ 获得/ 的/ CSP/ 表达式/ 使用/ STP/ [/ 15/ ]/ 求解/ ./ 若有解/ ,/ 则/ 存在/ 漏洞/ ,/ 并且/ 其解/ 可/ 作为/ 漏洞/ 的/ 触发/ 输入/ ./ 为了/ 验证/ 漏洞/ 的/ 有效性/ ,/ 可/ 将/ 此解/ 作为/ 输入/ 重新/ 运行/ 程序/ 观察/ 漏洞/ 触发/ 情况/ ./ 3.4/ 检测点/ 选取/ 在/ 程序/ 中/ 参与/ 赋值/ 运算/ 变量/ 的/ 集合/ U/ 中/ ,/ 仅/ 有/ 小/ 部分/ 变量/ U/ / U/ 可能/ 造成/ 堆栈/ 溢出/ ./ 因此/ 选取/ 合适/ 的/ 范围/ U/ ,/ 使/ U/ / U/ 且/ |/ U/ |/ 尽量/ 小/ 就/ 成为/ 了/ 提/ Page7/ 高/ 分析/ 效率/ 的/ 途径/ 之一/ ./ 为了/ 确定/ U/ 的/ 范围/ ,/ 检测点/ 的/ 选取/ 分为/ 两个/ 步骤/ :/ 首先/ 进行/ 静态/ 分析/ ,/ 选取/ 可能/ 出现/ 漏洞/ 的/ 位置/ 并/ 构造/ 相应/ 的/ 输入/ 使/ 程序/ 能够/ 到达/ 检测点/ ;/ 其次/ 使用/ 这个/ 输入/ 进行/ 动态分析/ ,/ 对/ 其/ 路径/ 上/ 的/ 语句/ 进一步/ 地/ 选取/ 检测点/ ./ 静态/ 分析/ 时/ ,/ 使用/ DJ/ 图/ [/ 34/ ]/ 的/ 方式/ 对/ 程序/ 的/ 循环/ 进行/ 分析/ ,/ 选取/ 循环/ 中/ 的/ 赋值/ 语句/ 作为/ 初始/ 检测点/ 进行/ 测试/ 输入/ 生成/ ./ 多种/ 方法/ 可用/ 来/ 进行/ 检测点/ 选取/ ,/ 文献/ [/ 35/ ]/ 提出/ 可以/ 根据/ 不同/ 版本/ 间/ 的/ 差异/ 进行/ 选取/ ,/ 但/ 由于/ 我们/ 直接/ 分析/ 可执行程序/ 且/ 不易/ 获得/ 版本/ 间/ 差异/ 信息/ ,/ 因此/ 这里/ 我们/ 选用/ 一种/ 启发式/ 的/ 方法/ ,/ 对于/ 最/ 复杂/ 的/ 循环/ 优先/ 检测/ ,/ 循环/ 的/ 复杂性/ 通过/ 循环/ 中/ 的/ 语句/ 数量/ 及/ 子程序/ 调用/ 数量/ 判断/ ,/ 利用/ 文献/ [/ 22/ ]/ 中/ 所述/ 方法/ 产生/ 到达/ 检测点/ 的/ 输入/ 数据/ 并/ 以此/ 为/ 基础/ 进行/ 后续/ 的/ 动态分析/ ./ 动态分析/ 时/ ,/ 我们/ 构建/ 程序/ 分析树/ T/ (/ V/ ,/ E/ )/ ./ 其中/ ,/ V/ 为/ 节点/ ,/ 代表/ 每个/ 基本块/ B/ ;/ E/ 为/ 有/ 向/ 边/ ,/ 当/ E/ (/ Vi/ ,/ Vj/ )/ =/ 1/ 时/ ,/ 表示/ 存在/ Bi/ 到/ Bj/ 的/ 程序流程/ ./ 根据/ 基本块/ 的/ 不同/ ,/ 可以/ 定义/ 3/ 种/ 类型/ 的/ 边/ :/ 调用/ 边/ μ/ :/ / vi/ ,/ vj/ ∈/ V/ ,/ μ/ (/ vi/ ,/ vj/ )/ =/ 1/ / Bi/ ∈/ CB/ ∧/ E/ (/ vi/ ,/ vj/ )/ ;/ 返回/ 边/ ρ/ :/ / vi/ ,/ vj/ ∈/ V/ ,/ ρ/ (/ vi/ ,/ vj/ )/ =/ 1/ / Bi/ ∈/ CR/ ∧/ E/ (/ vi/ ,/ vj/ )/ ;/ 跳转/ 边/ φ/ :/ / vi/ ,/ vj/ ∈/ V/ ,/ φ/ (/ vi/ ,/ vj/ )/ =/ 1/ / (/ Bi/ ∈/ JB/ ∨/ Bi/ ∈/ SB/ )/ ∧/ E/ (/ vi/ ,/ vj/ )/ ./ 算法/ 1/ 是/ 程序/ 分析树/ 的/ 构建/ 算法/ ./ 树/ 的/ 构建/ 过程/ 随着/ 程序/ 的/ 启动/ 开始/ ,/ 当/ 程序/ 结束/ 时/ ,/ 分析/ 过程/ 结束/ ./ 对于/ 每个/ 基本块/ Bi/ ,/ 根据/ 基本块/ 的/ 类型/ 分别/ 建立/ 树/ 节点/ 与/ 不同/ 类别/ 的/ 边/ ./ 由于/ 建立/ 节点/ 的/ 时间/ 为/ 常数/ ,/ 利用/ 建立/ 分析树/ 过程/ 中/ 每/ 增加/ 一个/ 子/ 节点/ 构造/ 一条/ 指向/ 其父/ 节点/ 指针/ 的/ 方式/ ,/ 也/ 可以/ 在/ 常数/ 时间/ 内/ 找出/ 其父/ 节点/ ,/ 因此/ 假设/ 当前/ 程序执行/ 路径/ P/ 的/ 基本块/ 数量/ 为/ nB/ ,/ 则/ 算法/ 1/ 的/ 复杂度/ 为/ O/ (/ nB/ )/ ./ 如果/ 程序/ 的/ 基本块/ 总/ 数量/ 为/ NB/ ,/ 在/ 一般/ 情况/ 下有/ nB/ / NB/ ./ 算法/ 1/ ./ 程序/ 分析树/ 构建/ 算法/ ConsTree/ (/ )/ ./ 输入/ :/ 程序/ P/ 输出/ :/ 程序/ 分析树/ T1/ ./ 创建/ 根/ 节点/ R/ ;/ 2/ ./ 创建/ 子/ 节点/ V0/ ;/ 3/ ./ μ/ (/ R/ ,/ V0/ )/ =/ 1/ ;/ 4/ ./ for/ 基本块/ Bi/ ∈/ Pdo5/ ./ switchBido6/ ./ caseBi/ ∈/ CB7/ ./ 增加/ 子/ 节点/ Vj/ ;/ 8/ ./ μ/ (/ Vi/ ,/ Vj/ )/ =/ 1/ ;/ 9/ ./ end10/ ./ caseBi/ ∈/ RB11/ ./ i/ =/ 当前/ 层次/ ;/ 12/ ./ 在/ i/ -/ 1/ 层/ 找到/ 其父/ 节点/ Vk/ ;/ 13/ ./ 增加/ Vk/ 的/ 兄弟/ 节点/ Vj/ ;/ 14/ ./ ρ/ (/ Vi/ ,/ Vj/ )/ =/ 1/ ;/ 15/ ./ end16/ ./ caseBi/ ∈/ JB/ ‖/ Bi/ ∈/ SB17/ ./ 增加/ 兄弟/ 节点/ Vj/ ;/ 18/ ./ / (/ Vi/ ,/ Vj/ )/ =/ 1/ ;/ 19/ ./ end20/ ./ end21/ ./ end/ 通过/ 程序/ 分析树/ ,/ 可以/ 选取/ 尽量/ 小/ 的/ 程序/ 检测点/ 集合/ 进行/ 分析/ ,/ 提高效率/ ./ 设树中/ 层次/ 使用/ L/ 表示/ ./ 定义/ 函数/ Lo/ :/ V/ →/ 2L/ ,/ 表示/ 包含/ 某/ 节点/ v/ 的/ 循环/ 在/ 树/ 中/ 的/ 层次/ ./ 当/ v/ 属于/ 多个/ 循环/ 时/ ,/ 返回/ 层次/ 集合/ ;/ 当/ Lo/ (/ v/ )/ =/ / 时/ ,/ 表示/ 不/ 存在/ 循环/ ./ 对于/ 树中/ 第/ l/ 层/ 的/ 任意/ 一个/ 节点/ v/ ,/ 对应/ 的/ 基本块/ 中有/ 语句/ I/ :/ α/ ←/ β/ ,/ 则/ 算法/ 2/ 根据/ v/ 所处/ 的/ 循环/ 控制/ 节点/ 所/ 依赖/ 的/ 变量/ p/ 和/ α/ 本身/ 是否/ 为/ 污点/ 数据/ 决定/ I/ 是否/ 成为/ 程序/ 检测点/ ./ 其中/ T/ (/ α/ )/ 函数/ 返回/ 输入/ 参数/ 是否/ 为/ 污点/ 数据/ ,/ 其/ 复杂度/ 为/ 常数/ ;/ Lo/ (/ v/ )/ 函数/ 通过/ 该/ 节点/ 及/ 该/ 节点/ 后续/ 反回边/ 可以/ 向上/ 遍历/ ,/ 其/ 最坏/ 可能性/ 为/ 树/ 的/ 高度/ ,/ 即/ O/ (/ log/ (/ nB/ )/ )/ ,/ 但/ 在/ 实际/ 运算/ 过程/ 中/ ,/ 由于/ 每/ 一层/ 基本块/ 的/ 数量/ 较/ 多/ ,/ 且/ 通过/ 调用/ 方式/ 产生/ 循环/ 的/ 数量/ 更/ 少/ ,/ 因此/ 可假定/ 需要/ 分析/ 的/ 数量/ 基本/ 为/ 常数/ ,/ 不妨/ 设置/ 为/ C/ ,/ 实验/ 表明/ 绝大多数/ 情况/ 下/ C/ </ 5/ ./ 综上/ ,/ 算法/ 2/ 的/ 复杂度/ 为/ O/ (/ C/ )/ ./ 算法/ 2/ ./ 检测点/ 选取/ 算法/ PointerChecker/ (/ )/ ./ 输入/ :/ 程序/ 分析树/ T/ ,/ 程序/ 语句/ I/ :/ α/ ←/ β/ 输出/ :/ 0/ ,/ 11/ ./ ifT/ (/ α/ )/ =/ 1then2/ ./ return1/ ;/ 3/ ./ else4/ ./ ifLo/ (/ v/ )/ =/ / then5/ ./ return0/ ;/ 6/ ./ else7/ ./ foralll/ ∈/ Lo/ (/ v/ )/ do8/ ./ p/ =/ l/ 层/ 循环/ 控制/ 节点/ 依赖/ 的/ 变量/ ;/ 9/ ./ ifT/ (/ p/ )/ =/ 1then10/ ./ return1/ ;/ 11/ ./ else12/ ./ continue/ ;/ 13/ ./ end14/ ./ endPage815/ ./ return0/ ;/ 16/ ./ end17/ ./ end/ 本文/ 所述/ 方法/ 与/ 基于/ 多/ 路径分析/ 的/ 全/ 路径/ 漏洞/ 检测/ 方法/ 相比/ ,/ 本/ 方法/ 可以/ 根据/ 检测点/ 的/ 设定/ 动态/ 地/ 对/ 多条/ 路径/ 进行/ 检测/ ,/ 如果/ 检测点/ 分布/ 在/ 各条/ 路径/ 上/ ,/ 即可/ 对/ 所有/ 路径/ 进行/ 分析/ ./ 该/ 方法/ 避免/ 了/ 对于/ 没有/ 检测点/ 的/ 路径/ 进行/ 分析/ 的/ 过程/ ,/ 减少/ 了/ 分析/ 的/ 路径/ 数量/ ,/ 扩大/ 了/ 应用/ 范围/ ./ 3.5/ 程序/ 间/ 漏洞/ 检测/ 算法/ 由于/ 基本块/ 在/ 程序/ 内/ 经常/ 被/ 共用/ ,/ 所以/ 保存/ 每个/ 基本块/ 的/ 信息/ 以备/ 将来/ 使用/ 可以/ 提高/ 分析/ 效率/ ./ 以上/ CSP/ 表达式/ 构造/ 算法/ 并/ 没有/ 对/ 程序/ 间/ 调用/ 与/ 基本块/ 的/ 信息/ 重/ 利用/ 进行/ 处理/ ./ 本/ 小节/ 将/ 介绍/ 程序/ 间/ 的/ 漏洞/ 检测/ 算法/ ,/ 能够/ 重用/ 已有/ 信息/ ,/ 提高效率/ ./ 相对/ 于/ 高级/ 语言/ ,/ 汇编语言/ 程序/ 间/ 的/ 参数传递/ 具有/ 一定/ 的/ 特殊性/ :/ 传递/ 方式/ 依靠/ 寄存器/ 与/ 内存/ ,/ 没有/ 高级/ 语言/ 中/ 的/ 形参/ 和/ 实参/ ,/ 所以/ 分析/ 过程/ 中仅/ 需要/ 关心/ 寄存器/ 和/ 内存/ 即可/ ./ 算法/ 3/ 随着/ 程序/ 启动/ 开始/ 执行/ ,/ 每次/ 取/ 当前/ 执行/ 的/ 基本块/ B/ ./ 如果/ B/ 未/ 被/ 分析/ ,/ 则/ 先/ 计算/ B/ 本身/ 的/ CSP/ 表达式/ 并/ 保存/ ./ 当/ B/ 中/ 存在/ 函数调用/ 时/ ,/ 需/ 递归/ 地/ 对/ 其子/ 函数/ 进行/ 处理/ ./ 其次/ ,/ 使用/ Pointer/ -/ Checker/ 算法/ 选取/ B/ 中/ 的/ 检测点/ 并/ 结合/ 语句/ 执行/ 条件/ C/ 生成/ CSP/ 表达式/ ./ 最后/ 根据/ B/ 的/ 出口/ 条件/ 修改/ 当前/ 执行/ 条件/ C/ 并/ 传递/ 到/ 下/ 一个/ 基本块/ ./ 初始/ 时/ ,/ C/ =/ NULL/ ./ 虽然/ 算法/ 3/ 在/ 第/ 9/ 行/ 位置/ 进行/ 了/ 递归/ 调用/ ,/ 但/ 每个/ 子函数/ 在/ 分析/ 完成/ 后/ 即将/ 其/ 状态/ 记录/ ,/ 因此/ 每个/ 函数/ 仅/ 分析/ 一次/ ,/ 其/ 复杂度/ 为/ O/ (/ nI/ )/ ,/ 其中/ nI/ 表示/ 路径/ P/ 中/ 的/ 指令/ 数量/ ./ 根据/ 文献/ [/ 36/ ]/ (/ 参考/ 3.6/ 小节/ )/ ,/ 化简/ CSP/ 表达式/ 的/ 复杂度/ 为/ O/ (/ nI/ )/ ./ 设/ nI/ // B/ 表示/ 基本块/ B/ 中/ 的/ 指令/ 数量/ ,/ nCSP/ // B/ 表示/ 基本块/ B/ 中/ 的/ 检测点/ 数量/ ,/ 算法/ 3/ 的/ 复杂度/ 为/ O/ (/ nB/ ×/ (/ nI/ // B/ +/ nCSP/ // B/ ×/ (/ C/ +/ nI/ )/ )/ )/ =/ O/ (/ nI/ +/ nCSP/ ×/ (/ C/ +/ nI/ )/ )/ =/ O/ (/ nCSP/ ×/ nI/ )/ ,/ 其中/ nCSP/ 表示/ 设置/ 的/ 检测点/ 数量/ ./ 算法/ 3/ ./ 程序/ 间/ 漏洞/ 检测/ 算法/ VulFinder/ (/ )/ ./ 输入/ :/ 程序/ P/ ,/ 标记/ mark/ ,/ 基本块/ 信息/ 集合/ Info/ ,/ 入口/ 输出/ :/ CSP/ 表达式/ 集合/ R1/ ./ WhileP/ 未/ 结束/ do2/ ./ 取/ 当前/ 基本块/ B/ ;/ 3/ ./ ifmark/ (/ B/ )/ =/ =/ 0then4/ ./ mark/ (/ B/ )/ =/ 1/ ;/ 5/ ./ ifB/ ∈/ CBthen6/ ./ F/ =/ 目标/ 函数/ ;/ 7/ ./ ifmark/ (/ F/ )/ =/ =/ 0then8/ ./ mark/ (/ F/ )/ =/ 1/ ;/ 9/ ./ VulFinder/ (/ F/ ,/ mark/ ,/ Info/ ,/ C/ )/ ;/ 10/ ./ end11/ ./ CSP2/ =/ F/ 的/ CSP/ 表达式/ ;/ 12/ ./ 将/ CSP2/ 加入/ Info/ (/ B/ )/ ;/ 13/ ./ end14/ ./ forallI/ ∈/ B/ ∧/ kill/ (/ I/ )/ ≠/ / do15/ ./ 使用/ 定理/ 2/ 和/ 定理/ 3/ 建立/ 堆栈/ 溢出/ 表达式/ 16/ ./ 将/ CSP1/ 加入/ Info/ (/ B/ )/ ;/ 17/ ./ end18/ ./ end19/ ./ forallCSP/ ∈/ Info/ (/ B/ )/ ./ CSP1/ ∪/ Info/ (/ B/ )/ ./ CSP2do20/ ./ I/ =/ CSP/ 所在/ 的/ 语句/ ;/ 21/ ./ ifPointerChecker/ (/ I/ )/ =/ =/ 1then22/ ./ CSP/ =/ CSP/ ∧/ C/ ;/ 23/ ./ 化简/ CSP/ 并/ 加入/ R/ ;/ 24/ ./ end25/ ./ end26/ ./ ifB/ ∈/ JBthen27/ ./ C/ =/ B/ 的/ 跳转/ 条件/ ;/ 28/ ./ ifC/ =/ =/ truethen29/ ./ C/ =/ C/ ∧/ C/ ;/ 30/ ./ else31/ ./ C/ =/ C/ ∧/ C/ ;/ 32/ ./ end33/ ./ end34/ ./ 执行/ 基本块/ B/ ;/ 35/ ./ end36/ ./ returnR/ ;/ 3.6/ CSP/ 表达式/ 的/ 消减/ 当/ 程序/ 较大/ 时/ ,/ CSP/ 表达式/ 也/ 会/ 相应/ 增大/ ,/ 此时/ 需要/ 对/ CSP/ 表达式/ 进行/ 化简/ ./ 利用/ 污点/ 传播/ 方法/ 可以/ 仅/ 选取/ 与/ 外部/ 输入/ 相关/ 的/ 条件/ 语句/ 作为/ CSP/ 表达式/ (/ EXE/ [/ 15/ ]/ 方法/ )/ ,/ 但/ 该/ 表达式/ 仍然/ 可以/ 进一步/ 简化/ ./ 例如/ 若/ 节点/ 1/ 是/ 分支/ 语句/ ,/ 节点/ 4/ 是/ 其后/ 必经/ 节点/ ,/ 节点/ 2/ 和/ 节点/ 3/ 是从/ 节点/ 1/ 到/ 4/ 间/ 不同/ 路径/ 上/ 的/ 节点/ ./ 设/ 节点/ 1/ 的/ 入口/ 条件/ 是/ C/ ,/ 两个/ 分支/ 条件/ 为/ e/ 和/ e/ -/ ./ 现有/ 分析方法/ 在/ 程序运行/ 时/ ,/ 会/ 记录/ 程序运行/ 过程/ 中/ 所有/ 不能/ 静态/ 确定/ 分支/ 方向/ 的/ 条件/ 集合/ ,/ 即/ CSP/ 表达式/ 中/ 的/ 条件/ 会/ 变为/ C/ ∧/ e/ 或/ C/ ∧/ e/ -/ ./ 假设/ 检测点/ 在/ 节点/ 2/ 或/ 3/ 时/ ,/ 以上/ 分析/ 过程/ 是/ 没有/ 冗余/ 的/ ,/ 因为/ 条件/ e/ 或/ e/ -/ 保证/ 了/ 检测点/ 的/ 运行/ 条件/ ./ 但/ 若/ 检测点/ 在/ 节点/ 4/ 处/ ,/ 条件/ e/ 和/ e/ -/ 的/ 必要性/ 并/ 不/ 明显/ ,/ 因为/ 它们/ 并未/ 保证/ 此时/ 程序/ 的/ 运行/ 条件/ ./ 这类/ 情况/ 在/ 循环/ 中/ 以及/ 子程序/ 调用/ 过程/ 中/ 也/ 会/ 同样/ 出现/ ./ Page9/ 因此/ 正确/ 选择/ 分支/ 条件/ ,/ 可以/ 减少/ 分支/ 的/ 数目/ 和/ 路径/ 表达式/ 的/ 长度/ ./ 本文/ 参考/ 了/ 文献/ [/ 36/ ]/ ,/ 对/ 路径/ 条件/ 进行/ 分析/ ,/ 确定/ 其/ 基本/ 组成部分/ ,/ 选取/ 运行/ 条件/ 与值/ 依赖/ 条件/ 进行/ 求解/ ,/ 缓解/ 了/ 传统/ 方式/ 下/ 由于/ 路径/ 条件/ 过于/ 复杂/ 而/ 难以/ 求解/ 的/ 问题/ ,/ 提高/ 了/ 漏洞/ 检测/ 的/ 效率/ ./ 4/ 实验/ 与/ 分析/ 为了/ 测试/ 本/ 方法/ 的/ 有效性/ 和/ 性能/ ,/ 我们/ 以/ QEMU0/ ./ 9.0/ 为/ 虚拟环境/ 实现/ 了/ 漏洞/ 分析/ 的/ 原型/ 系统/ ./ 计算机硬件/ 使用/ Dell/ 计算机/ ,/ 配以/ Intel/ 奔腾/ IV3GHzCPU/ ,/ 1.5/ GB/ 内存/ ,/ 安装/ QEMU/ 的/ 操作系统/ 平台/ 为/ Linux2/ ./ 6.11/ ./ 安装/ 的/ 虚拟/ 操作系统/ 为/ WindowsXP/ ./ 目前/ 的/ 原型/ 系统对/ 数据/ 转移/ 类/ 指令/ 、/ 算术/ 操作/ 指令/ 、/ 逻辑/ 操作/ 类/ 指令/ 和/ 堆栈/ 类/ 指令/ 进行/ 了/ 污点/ 传播/ ;/ 实现/ 了/ 栈/ 溢出/ 和/ 堆/ 溢出/ 漏洞/ 的/ 检测/ ;/ 污点/ 源/ 设置/ 为/ 从/ 硬盘/ 读取/ 的/ 文件/ 与/ 网络/ 传递/ 的/ 数据/ ./ 考虑/ 到/ 和/ 黑盒/ 测试方法/ 差别/ 较大/ ,/ 不易/ 比较/ ,/ 本文/ 选用/ 白盒/ 测试方法/ 进行/ 比较/ ./ EXE/ 方法/ 虽然/ 针对/ 源代码/ ,/ 但/ 其/ 思想/ 最/ 接近/ 本文/ 方法/ ,/ 本文/ 选用/ 其/ 方法/ 进行/ 实现/ 并/ 比较/ ./ 首先/ 我们/ 将/ 从/ 循环/ 个数/ 、/ 污点/ 传播/ 的/ 效率/ 、/ 内存/ 的/ 变化/ 、/ 时间/ 效率/ 等/ 方面/ 测试/ 基于/ CSP/ 的/ 动态/ 漏洞/ 分析方法/ 在/ 效率/ 和/ 性能/ 上/ 的/ 提升/ ./ 程序执行/ 过程/ 中/ ,/ 为了/ 判别/ 当前/ 基本块/ 是否/ 处于/ 循环/ 过程/ 中/ ,/ 需要/ 判断/ 当前/ 基本块/ 是否/ 在/ 已知/ 的/ 循环/ 集合/ 内/ ./ 已知/ 循环/ 集/ 可以/ 通过/ 静态/ 和/ 动态/ 两种/ MediaPlayer10223844AcrobatReader7221605Word2003168140Messenger119341Outlook200350985Excel200374482/ 为了/ 更加/ 清楚/ 地/ 认识/ 在/ 污点/ 传播/ 过程/ 中/ 影子/ 内存/ 所/ 占用/ 的/ 空间/ 大小/ ,/ 我们/ 记录/ 了/ IE6/ 等/ 软件/ 在/ 分析/ 过程/ 中/ 影子/ 内存/ 的/ 空间/ 占/ 用量/ ,/ 并/ 与/ EXE/ 方法/ 对比/ ,/ 单位/ 是/ KB/ ,/ 如图/ 3/ 所示/ ./ 图中/ 发现/ 在/ 分析/ 过程/ 中/ ,/ 本/ 方法/ 对/ 应用软件/ 使用/ 影子/ 内存/ 机制/ 所/ 占用/ 的/ 内存空间/ (/ 包括/ 堆栈/ )/ 均/ 不/ 超过/ 10MB/ ,/ 平均/ 内存/ 占用率/ 仅为/ 4.7/ MB/ ./ 由于/ 采用/ 实时/ 的/ 影子/ 内存/ 记录/ 机制/ ,/ 所以/ 原型/ 系统/ 不/ 需要/ 使用/ 整个/ 进程/ 空间/ 的/ 内存/ 表/ 1/ 对比/ 了/ InternetExplorer6/ 等/ 7/ 款/ 软件/ 在/ 执行/ 过程/ 中/ ,/ 内存/ 存储/ 操作/ 的/ 数量/ 和/ 在/ 循环/ 操作/ 下/ 以及/ 引入/ 污点/ 传播/ 模式/ 产生/ 的/ 内存/ 存储/ 操作/ 数量/ ,/ 从表中/ 可以/ 看出/ ,/ 引入/ 污点/ 传播/ 模式/ 下/ 的/ 内存/ 存储/ 操作/ 数量/ 平均/ 仅/ 占/ 内存/ 存储/ 操作/ 总/ 数量/ 的/ 0.969/ %/ ./ 由此/ 说明/ 污点/ 传播/ 过程/ 虽然/ 占用/ 了/ 一些/ 运行/ 时/ 内存/ ,/ 但是/ 极大/ 地/ 缩小/ 了/ 分析/ 范围/ ,/ 提高/ 了/ 整个/ 分析/ 过程/ 的/ 效率/ ./ 表/ 1/ 循环/ // 污点/ 传播/ 效率/ 表/ 程序/ 名称/ 写/ 内存/ 数量/ 循环/ 中/ 的/ 写/ 内存/ 数量/ 含/ 污点/ 数据/ 的/ 循环/ 中写/ 内存/ 数量/ 含/ 污点/ 数据/ 的/ 循环/ 中写/ 内存/ 所/ 占/ 比例/ // %/ IE6/ 方法/ 求/ 出/ ,/ 这个/ 集合/ 越小/ ,/ 对比/ 判别/ 的/ 速度/ 就/ 越/ 快/ ./ 图/ 2/ 对比/ 了/ InternetExplorer6/ 等/ 7/ 款/ 软件/ 在/ 静态/ 分析/ 和/ 动态分析/ 中所/ 需/ 比较/ 的/ 循环/ 个数/ ./ 为了/ 分析/ 静态/ 过程/ 中/ 的/ 循环/ 个数/ ,/ 我们/ 使用/ DJ/ 图/ [/ 34/ ]/ 的/ 方法/ 计算/ ./ 从图/ 中/ 看出/ 动态分析/ 过程/ 中/ 的/ 循环/ 个数/ 少于/ 静态/ 分析/ 中/ 的/ 循环/ 个数/ ,/ 提高/ 了/ 循环/ 分析/ 的/ 效率/ ./ 由于/ 静态/ 循环/ 分析方法/ 依赖于/ 反编译/ 部分/ 的/ 工作/ ,/ 因此/ 还会/ 受到/ 多态/ 代码/ 等/ 方法/ 阻碍/ 反编译/ 的/ 进行/ ,/ 导致/ 正确率/ 下降/ ./ 动态分析/ 方法/ 的/ 使用/ 避免/ 了/ 上述/ 缺点/ ./ 1472682604166321221301770/ 大小/ 作为/ 影子/ 内存/ ,/ 而仅/ 需要/ 维护/ 动态/ 的/ 堆栈/ 内存/ 即可/ ;/ 并且/ 当/ 目标程序/ 退出/ 时/ ,/ 相应/ 的/ 影子/ 内存/ 也/ 会/ 随之/ 释放/ ./ 因此/ ,/ 本/ 原型/ 系统/ 具有/ 较/ 高/ 的/ 空间/ 利用效率/ 和/ 更好/ 的/ 适应性/ ./ 实验/ 发现/ 本文/ 方法/ 和/ EXE/ 方法/ 占用/ 内存/ 数量/ 相同/ ,/ 其/ 原因/ 在于/ 本文/ 方法/ 并不需要/ 增加/ 影子/ 内存/ 的/ 使用量/ 进行/ 额外/ 分析/ ./ 图/ 4/ 是/ 以/ IE6/ 为例/ ,/ 记录/ 了/ 分析/ 过程/ 中/ 影子/ 内存大小/ (/ 包括/ 堆栈/ )/ 随/ 时间/ 变化/ 图/ ./ 从图/ 中/ 可以/ 看出/ ,/ 堆栈/ 变化/ 较为/ Page10/ 平缓/ ,/ 因此/ 可以/ 花费/ 较/ 少/ 时间/ 在/ 影子/ 内存/ 的/ 管理/ 上/ ./ 图/ 5/ 是/ 被/ 检测/ 软件/ 在/ QEMU/ 系统/ 下/ 、/ 本/ 原型/ 系统/ 以及/ EXE/ 方法/ 下/ 的/ 时间/ 对比/ (/ 时间/ 单位/ 为/ s/ )/ ,/ 测试/ 发现/ 应用软件/ 在/ 本/ 原型/ 系统/ 下/ 的/ 执行/ 时间/ 约/ 是/ 在/ QEMU/ 环境/ 下/ 执行/ 时间/ 的/ 3/ ~/ 4/ 倍/ 左右/ ,/ 本文/ 方法/ 与/ EXE/ 方法/ 分析/ 时间/ 相差/ 并不大/ ,/ 由此/ 说明/ 本文/ 方法/ 对/ CSP/ 表达式/ 分析/ 与/ 化简/ 并未/ 占用/ 大量/ 的/ 时间/ ./ 由于/ 本/ 系统/ 运行/ 时间/ 依赖于/ 虚拟环境/ QEMU/ 本身/ 执行/ 时间/ ,/ 任何/ 虚拟环境/ 效率/ 的/ 提升/ 也/ 会/ 提高/ 本/ 系统/ 的/ 效率/ ./ 选用/ 效率/ 更/ 高/ 的/ 虚拟环境/ ,/ 例如/ Xen/ 也/ 是/ 提高/ 分析/ 效率/ 的/ 方法/ 之一/ ./ 为了/ 测试/ 原型/ 系统/ 的/ 实际/ 分析/ 效果/ ,/ 我们/ 选用/ InternetExplorer6/ 、/ MircosoftWord2003/ 等/ 软件/ 作为/ 测试/ 对象/ ,/ 分别/ 测试/ 生成/ CSP/ 表达式/ 的/ 个数/ 、/ 经/ 删减/ 无效/ 条件/ 后/ 的/ 检测/ 表达式/ 平均/ 长度/ 与/ 使用/ EXE/ 方法/ 检测/ 表达式/ 平均/ 长度/ 的/ 比值/ 、/ 检测/ 出/ 漏洞/ 的/ 个数/ 、/ 验证/ 成功/ 漏洞/ 个数/ 和/ 漏洞/ 误报/ 个数/ ./ 测试/ 效果/ 如表/ 2/ 所示/ ./ 程序/ 名称/ CSP/ 长度/ 比/ IE61470/ ./ 27110MediaPlayer2680/ ./ 19110AcrobatReader726040/ ./ 35110Word200316630/ ./ 11220Messenger21220/ ./ 24000Outlook20031300/ ./ 23000Excel200317700/ ./ 12220/ 从表/ 2/ 中/ 可以/ 看出/ ,/ 检测/ 出/ 的/ 漏洞/ 数量/ 均/ 为/ 有效/ 漏洞/ ,/ 没有/ 误报/ ,/ 但是/ 检测/ 出/ 漏洞/ 个数/ 少于/ 公布/ 出/ 的/ 漏洞/ 个数/ ./ 例如/ IE6/ ./ 0/ ,/ 截至/ 2008/ 年/ 4/ 月/ 8/ 日/ ,/ IE6/ 已/ 被/ 发现/ 327/ 个/ 漏洞/ ,/ 这里/ 分析/ 数量/ 较/ 少/ ,/ 原因/ 有/ 如下/ 几个/ :/ (/ 1/ )/ IE6/ 百余/ 漏洞/ 中/ 缓冲区/ 溢出/ 漏洞/ 并不多/ ,/ 即使/ 计入/ 整数/ 溢出/ ,/ 也/ 只有/ 30/ 余个/ ,/ 并且/ 多数/ 并/ 不是/ IE/ 本身/ 的/ 问题/ ,/ 而是/ 其它/ 插件/ 产生/ 的/ 漏洞/ ./ 本/ 原型/ 系统/ 目前/ 仅/ 分析/ 堆栈/ 缓冲区/ 溢出/ 漏洞/ ,/ 在/ 未来/ 的/ 研究/ 过程中将/ 对/ 其它/ 漏洞/ 类型/ 进行/ 分析/ ./ (/ 2/ )/ 在/ 理想/ 状况/ 下/ ,/ 如果/ 所有/ 存在/ 漏洞/ 的/ 路径/ 被/ 执行/ ,/ 所有/ 缓冲区/ 溢出/ 漏洞/ 都/ 将/ 被/ 检测/ 出/ ;/ 但本/ 实验/ 仅/ 选取/ vgx/ ./ dll/ 中/ 可能/ 的/ 漏洞/ 检测点/ 相关/ 路径/ 进行/ 检测/ ,/ 若想/ 进行/ 更/ 全面/ 的/ 分析/ ,/ 可以/ 放宽/ 检测点/ 选取/ 规则/ ,/ 选取/ 尽量/ 多/ 的/ 检测点/ ,/ 例如/ 将/ 各/ 模块/ 中/ 的/ 赋值/ 语句/ 作为/ 检测点/ 进行/ 计算/ ./ 5/ 结论/ 本文/ 在/ 对/ 可执行程序/ 动态分析/ 的/ 基础/ 上/ ,/ 通过/ 将/ 漏洞/ 引发/ 条件/ 转换/ 为/ CSP/ 表达式/ 并/ 求解/ 的/ 方式/ 进行/ 程序/ 的/ 溢出/ 漏洞/ 检测/ ./ 本/ 方法/ 可以/ 在/ 缺乏/ 源代码/ 的/ 情况/ 下/ 进行/ 漏洞/ 分析/ ,/ 解决/ 了/ 静态/ 分析/ 过程/ 中/ 难以/ 处理/ 的/ 多态/ 代码/ 等/ 软件保护/ 手段/ 带来/ 的/ 问题/ 和/ 间接/ 跳转/ 等/ 二进制/ 代码/ 本身/ 的/ 分析/ 问题/ ./ 实现/ 了/ 一个/ 漏洞/ 分析/ 原型/ 系统/ ,/ 对/ InternetExplorer6/ 等/ 7/ 款/ 软件/ 进行/ 了/ 实际/ 分析/ ,/ 发现/ 了/ 其中/ 若干/ 漏洞/ ,/ 且/ 未/ 产生/ 误报/ ,/ 同时/ 对/ 相关/ 性能/ 做/ 了/ 测试/ ,/ 验证/ 了/ 本/ 方法/ 的/ 有效性/ 与/ 高效性/ ./ Page11/ 在/ 今后/ 的/ 工作/ 中/ ,/ 将会/ 对/ 检测点/ 选取/ 规则/ 进一步/ 分析/ 优化/ ,/ 进行/ 更/ 全面/ 、/ 更/ 高效/ 的/ 漏洞/ 检测/ ./ 此外/ ,/ 目前/ 检测/ 的/ 漏洞/ 类型/ 为/ 缓冲区/ 溢出/ 漏洞/ ,/ 今后/ 将会/ 对/ 多次/ // 二次/ 指针/ 释放/ 、/ 空/ 指针/ 读取/ 、/ 格式化/ 字符串/ 等/ 其它/ 类型/ 的/ 漏洞/ 做出/ 处理/ ./ 

