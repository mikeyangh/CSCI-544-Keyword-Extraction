Page1/ 基于/ 数据/ 差异/ 的/ 连续/ 数据保护/ 恢复/ 算法/ 王超/ 李战怀/ 张小芳/ 侯利曼/ (/ 西北工业大学/ 计算机/ 学院/ 西安/ 710072/ )/ 摘要/ 连续/ 数据保护/ 系统/ 在/ 进行/ 数据恢复/ 时/ ,/ 首要任务/ 是从/ 历史/ 时刻/ 中/ 快速/ 识别/ 出/ 可/ 恢复/ 时刻/ 点/ ,/ 总/ 恢复/ 时间/ 通常/ 与/ 恢复/ 时刻/ 点/ 识别/ 过程/ 中/ 所/ 检测/ 的/ 历史数据/ 版本/ 成正比/ ./ 然而/ ,/ 基本/ 数据恢复/ 方法/ 的/ 恢复/ 效率/ 低/ ,/ 无法/ 适应/ 现代/ 存储系统/ 对/ 可用性/ 和/ 可靠性/ 的/ 要求/ ,/ 恢复/ 时间/ 和/ 数据/ 损失/ 之间/ 的/ 矛盾/ 日益突出/ ./ 通过/ 对/ 邻近/ 算法/ 的/ 改进/ 和/ 完善/ ,/ 提出/ 了/ 一种/ 支持/ 多/ 间隙/ 复杂/ 情况/ 的/ 恢复/ 算法/ —/ —/ —/ RM/ -/ CBDD/ ./ RM/ -/ CBDD/ 通过/ 分析/ 并/ 消除/ 恢复/ 起止/ 时刻/ 之间/ 两种/ 类型/ 的/ 差异/ 数据/ 实现/ 恢复/ ./ 实验/ 结果表明/ ,/ 在/ 多/ 间隙/ 复杂/ 情况/ 下/ ,/ RM/ -/ CBDD/ 算法/ 的/ 恢复/ 效率/ 明显/ 优于/ 基本/ 方法/ 和/ WDRS/ 算法/ ,/ 有效/ 降低/ 了/ 二分/ 探查/ 最佳/ 恢复/ 时刻/ 点/ 的/ 时间/ 开销/ ./ 关键词/ 连续/ 数据保护/ ;/ 数据恢复/ ;/ 数据/ 差异/ ;/ 块/ 数据/ ;/ 可用性/ 1/ 引言/ 面对/ 病毒/ 入侵/ 、/ 人为/ 破坏/ [/ 1/ ]/ 、/ 硬件/ 失效/ 以及/ 自然/ Page2/ 保护/ 方法/ 的/ 重要/ 指标/ ./ RPO/ 描述/ 了/ 灾难/ 后/ 可/ 接受/ 的/ 数据/ 丢失/ 量/ ,/ RTO/ 描述/ 了/ 灾难/ 后/ 恢复/ 数据/ 所/ 需要/ 的/ 时间/ ./ 根据/ RPO/ 的/ 不同/ ,/ 将/ 目前/ 常见/ 的/ 块/ 级/ 数据保护/ 技术/ 分为/ 定期/ 备份/ (/ PeriodicalBackup/ )/ [/ 4/ -/ 6/ ]/ 、/ 快照/ (/ Snapshot/ )/ [/ 7/ ]/ 和/ 连续/ 数据保护/ (/ ContinuousDataProtection/ ,/ CDP/ )/ 三类/ ./ 连续/ 数据保护/ (/ ContinuousDataProtection/ ,/ CDP/ )/ 技术/ [/ 3/ ,/ 8/ ]/ ,/ 可以/ 在/ 不/ 影响/ 正常/ 数据业务/ 的/ 前提/ 下/ ,/ 通过/ 实时/ 跟踪/ 并/ 记录/ 所有/ 数据/ 的/ 更新/ ,/ 能够/ 在/ 出现/ 数据/ 损坏/ 或/ 丢失/ 等/ 问题/ 时/ ,/ 将/ 数据恢复/ 到/ 任意/ 历史/ 时刻/ ./ 传统/ 的/ 块/ 级/ 连续/ 数据保护/ 技术/ ,/ 其/ 实现/ 机制/ 通常/ 是/ 按照/ 时间/ 顺序/ 、/ 以/ 单一/ 写/ 请求/ 为/ 单位/ 保存/ 每个/ 数据/ 块/ 的/ 所有/ 更新/ ,/ 在/ 数据恢复/ 时则/ 只/ 需/ 替换/ 所有/ 时间/ 戳/ 在/ 恢复/ 时刻/ 点/ 之前/ 的/ 数据/ 块/ 即可/ ./ 与/ 前/ 两种/ 技术/ 相比/ ,/ 块级/ 连续/ 数据保护/ 技术/ 可以/ 在/ 数据/ 失效/ 后/ 及时/ 恢复/ 至以/ 单一/ 写/ 请求/ 为/ 单位/ 的/ 任意/ 历史/ 时刻/ ,/ 数据/ 丢失/ 量/ 最小/ ./ 在/ 数据/ 失效/ 后/ ,/ 必须/ 在/ 识别/ 出/ 一个/ 可/ 恢复/ 时刻/ 点/ 之后/ ,/ 才能/ 开始/ 执行/ 数据恢复/ 操作/ ./ 虽然/ 连续/ 数据保护/ 技术/ 可以/ 将/ 数据恢复/ 至/ 任意/ 历史/ 时刻/ ,/ 但/ 却/ 不能/ 帮助/ 可/ 恢复/ 目标/ 时刻/ 点/ 的/ 识别/ ,/ 连续/ 的/ 历史/ 时刻/ 反而/ 使得/ 恢复/ 目标/ 时刻/ 点/ 的/ 识别/ 变得/ 更加/ 复杂/ ./ 为了/ 快速/ 识别/ 可/ 恢复/ 时刻/ 点/ ,/ 通常/ 采用/ 二分/ 探查/ 的/ 方式/ ,/ 在/ 初始/ 时刻/ 和/ 发生/ 数据/ 失效/ 的/ 时刻/ 之间/ 进行/ 探查/ ,/ 探查/ 过程中将/ 数据/ 依次/ 恢复/ 至/ 每个/ 探查/ 的/ 时刻/ 点/ ,/ 并/ 对/ 数据/ 的/ 完整性/ 进行/ 检测/ ,/ 然后/ 根据/ 检测/ 结果/ 判断/ 下/ 一次/ 二分/ 探查/ 的/ 方向/ ./ 由于/ 探查/ 过程/ 需要/ 执行/ 多次/ 数据恢复/ ,/ 并/ 进行/ 完整性/ 检测/ ,/ 因此/ ,/ 相比/ 执行/ 数据恢复/ 操作/ 所/ 花费/ 的/ 时间/ ,/ 识别/ 恢复/ 目标/ 时刻/ 点则/ 要/ 耗费/ 更/ 多/ 的/ 时间/ ./ 可见/ ,/ 降低/ 总/ 恢复/ 时间/ 的/ 关键在于/ 降低/ 恢复/ 时刻/ 点/ 识别/ 所/ 需要/ 的/ 时间/ ./ 系统管理员/ 在/ 选择/ 恢复/ 目标/ 时刻/ 点时/ ,/ 需要/ 在/ 总/ 恢复/ 时间/ 和/ 丢失/ 数据量/ 之间/ 进行/ 权衡/ ,/ 探查/ 的/ 时刻/ 点越/ 多/ ,/ 通常/ 意味着/ 消耗/ 更/ 多/ 的/ 时间/ ,/ 但/ 却/ 可以/ 识别/ 出/ 丢失/ 数据/ 更少/ 的/ 恢复/ 时刻/ 点/ ./ 随着/ 现代/ 存储系统/ 对/ 可用性/ 和/ 可靠性/ 要求/ 的/ 不断/ 提高/ ,/ 恢复/ 时间/ 和/ 数据/ 损失/ 之间/ 的/ 矛盾/ 日益突出/ ./ 然而/ ,/ 块级/ 连续/ 数据保护/ 机制/ 的/ 基本/ 恢复/ 方法/ ,/ 在/ 恢复/ 数据/ 时/ 简单/ 地/ 基于/ 初始/ 备份/ 依次/ Redo/ 所有/ 时间/ 戳/ 在/ 恢复/ 目标/ 时刻/ 点/ 之前/ 的/ 历史数据/ ,/ 恢复/ 效率/ 极低/ ,/ 已经/ 无法/ 满足/ 现代/ 存储系统/ 的/ 需求/ ./ 由于/ 连续/ 数据保护/ 系统/ 需要/ 保存/ 各个/ 数据/ 块/ 的/ 所有/ 更新/ ,/ 历史数据/ 需要/ 占用/ 大量/ 的/ 存储空间/ ,/ 限制/ 了/ 块/ 级/ 连续/ 数据保护/ 技术/ 的/ 应用/ ,/ 所以/ ,/ 目前/ 大部分/ 的/ 研究/ [/ 8/ -/ 11/ ]/ 集中/ 于/ 解决/ 传统/ 块级/ 连续/ 数据保护/ 机制/ 的/ 高/ 存储/ 开销/ 问题/ ./ 然而/ ,/ 对于/ 如何/ 快速/ 地/ 识别/ 出/ 数据/ 损坏/ 之前/ 的/ 最后/ 一个/ 可用/ 数据/ 镜像/ 对应/ 的/ 时刻/ 点/ ,/ 即/ 最优/ 恢复/ 时刻/ 点/ ,/ 相关/ 的/ 研究/ 却/ 非常/ 有限/ ./ SWEEPER/ [/ 12/ ]/ 根据/ 对/ 多种/ 系统/ 事件/ 的/ 监控/ 分析/ ,/ 有/ 选择地/ 针对/ 特定/ 时刻/ 点/ 所/ 对应/ 的/ 数据/ 镜像/ 进行/ 完整性/ 检测/ ,/ 在/ 不/ 降低/ 对/ RPO/ 要求/ 的/ 前提/ 下/ ,/ 减少/ 了/ 所/ 需/ 检测/ 的/ 数据/ 镜像/ 个数/ ,/ 从而/ 加快/ 恢复/ 时刻/ 点/ 的/ 识别/ ,/ 最终/ 达到/ 降低/ 恢复/ 时间/ 的/ 目的/ ./ 与/ SWEEPER/ 通过/ 减少/ 探查/ 次数/ 的/ 思路/ 不同/ ,/ 提高/ 数据恢复/ 效率/ ,/ 降低/ 每/ 一次/ 探查/ 中/ 恢复/ 数据/ 的/ 时间/ 开销/ ,/ 则/ 是/ 解决/ 恢复/ 时刻/ 点/ 识别/ 问题/ 的/ 另/ 一/ 途径/ ./ 快照/ 技术/ 中/ 的/ 相关/ 研究/ 结合/ 数据/ 的/ 分布/ 特征/ 提高/ 快照/ 的/ 检索/ 效率/ ./ 如/ THVFS/ [/ 13/ ]/ 利用/ 目录/ 、/ 文件/ 版本/ 之间/ 的/ 相关性/ 提高/ 快照/ 检索/ 效率/ ;/ Skippy/ [/ 14/ ]/ 利用/ 内存/ 快照/ HotData/ 的/ 特性/ ,/ 提出/ 了/ 一种/ 分/ 层次/ 的/ 索引/ 结构/ ,/ 提高/ 长期/ 快照/ 的/ 检索/ 效率/ ;/ 结合/ 数据分布/ 特征/ 和/ 检索/ 模式/ 的/ 分层/ 二维/ 索引/ 结构/ HCSIM/ [/ 15/ ]/ 能够/ 提高/ 高频/ 快照/ 索引/ 的/ 存储/ 效率/ 和/ 检索/ 效率/ ./ 尽管/ 这/ 类/ 技术/ 可以/ 提高/ 快照/ 检索/ 效率/ ,/ 进而/ 提高/ 恢复/ 速度/ ,/ 但/ 却/ 都/ 是/ 基于/ 快照/ 技术/ 的/ 相关/ 研究/ ,/ 并/ 不/ 适合/ 在/ 数据/ 块级/ 的/ 连续/ 数据保护/ 系统/ 中/ 使用/ ./ WDRS/ [/ 16/ ]/ 对块级/ 连续/ 数据保护/ 系统/ 的/ 恢复/ 过程/ 进行/ 了/ 优化/ ,/ 通过/ 位表/ 的/ 方式/ ,/ 保证/ 了/ 在/ 执行/ 数据恢复/ 的/ 过程/ 中/ ,/ 数据/ 卷/ 中/ 的/ 每/ 一个/ 逻辑/ 块/ 均/ 被/ 恢复/ 一次/ ./ 因此/ ,/ WDRS/ 的/ 恢复/ 时间/ 与/ 数据/ 卷/ 的/ 大小/ 关系密切/ ,/ 而/ 恢复/ 起止/ 时刻/ 的/ 位置/ 对/ 其/ 的/ 影响/ 并/ 不/ 明显/ ./ WDRS/ 恢复/ 效率/ 稳定/ ,/ 且/ 优于/ 基本/ 恢复/ 方法/ ,/ 但/ 仍旧/ 无法/ 适应/ 恢复/ 时刻/ 点/ 识别/ 的/ 要求/ ./ 针对/ 可/ 恢复/ 时刻/ 点/ 的/ 快速/ 识别/ 问题/ ,/ 侯利曼/ 等/ 人/ [/ 17/ ]/ 提出/ 了/ “/ 基于/ 数据/ 差异/ 的/ CDP/ 邻近/ 时间/ 点/ 恢复/ ”/ 算法/ ,/ 简称/ “/ 临近/ 算法/ ”/ ./ 临近/ 算法/ 通过/ 分析/ 两/ 相邻/ 时刻/ 的/ 差异/ 数据/ ,/ 采用/ 剔除/ 多余/ 数据/ 、/ 写入/ 缺少/ 数据/ 的/ 方法/ ,/ 消除/ 差异/ 数据/ ,/ 对/ 恢复/ 起止/ 时刻/ 相距/ 较近/ 的/ 情况/ ,/ 数据恢复/ 效率/ 极高/ ./ 在/ 通过/ 二分/ 探查/ 的/ 方式/ 识别/ 恢复/ 时刻/ 点时/ ,/ 随着/ 二分/ 探查/ 次数/ 的/ 增加/ ,/ 相邻/ 两次/ 探查/ 时刻/ 点/ 之间/ 的/ 时间/ 间隔/ 呈/ 指数/ 次/ 幂/ 减少/ ,/ 差异/ 数据量/ 随之/ 骤减/ ,/ 临近/ 算法/ 大幅度提高/ 了/ 单次/ 探查/ 的/ 效率/ ,/ 进而/ 加速/ 恢复/ 时刻/ 点/ 的/ 识别/ ./ 然而/ ,/ 临近/ 算法/ 仅/ 根据/ 时间/ 间隔/ 较/ 小/ 的/ 两个/ 临近/ 时刻/ 点/ 之间/ 的/ 关系/ ,/ 在/ 最/ 多/ 存在/ 一个/ 间隙/ 的/ 情况/ 下/ ,/ 对/ 可能/ 出现/ 的/ 5/ 种/ 简单/ 情况/ 作/ 了/ 分析/ ,/ 然后/ 分别/ 对/ 这/ 5/ 种/ 情况/ 给出/ 了/ 恢复/ 方法/ ./ 在/ 连续/ 数据保护/ 系/ Page3/ 统的/ 实际/ 运行/ 过程/ 中/ ,/ 出现/ 多次/ 无规律/ 数据恢复/ 的/ 情况/ 是/ 很/ 常见/ 的/ ,/ 即/ 多/ 间隙/ 复杂/ 情况/ ,/ 这时/ ,/ 仅/ 支持/ 最/ 多/ 一个/ 间隙/ 的/ 5/ 种/ 简单/ 情况/ 的/ 临近/ 算法/ 就/ 无法/ 适用/ ./ 鉴于/ 临近/ 算法/ 仅/ 支持/ 最/ 多/ 一个/ 间隙/ 的/ 简单/ 情况/ ,/ 而/ 无法/ 在/ 实际/ 环境/ 中/ 应用/ 的/ 问题/ ,/ 本文/ 对/ 临近/ 算法/ 进行/ 了/ 改进/ 与/ 完善/ ,/ 提出/ 了/ 一种/ 支持/ 多/ 间隙/ 复杂/ 情况/ 的/ 恢复/ 算法/ —/ —/ —/ RM/ -/ CBDD/ ,/ 并/ 进行/ 了/ 详细/ 的/ 实验/ 验证/ 及/ 分析/ ,/ 本文/ 的/ 主要/ 贡献/ 如下/ :/ (/ 1/ )/ 通过/ 形式化/ 建模/ ,/ 对/ 临近/ 算法/ 给出/ 的/ 5/ 种/ 时间/ 点/ 划分/ 进行/ 了/ 详细/ 的/ 分析/ 及/ 证明/ ./ (/ 2/ )/ 以/ 消除/ 恢复/ 起止/ 时刻/ 之间/ 差异/ 数据/ 的/ 思想/ 为/ 指导/ ,/ 对/ 临近/ 算法/ 进行/ 了/ 完善/ 及/ 改进/ ,/ 提出/ 了/ 支持/ 多/ 间隙/ 复杂/ 情况/ 的/ RM/ -/ CBDD/ 算法/ ,/ 通过/ 形式化/ 的/ 方式/ 给出/ 了/ RM/ -/ CBDD/ 的/ 数据/ 记录/ 及/ 数据恢复/ 过程/ ,/ 并/ 对/ 算法/ 的/ 复杂度/ 进行/ 了/ 比较/ 分析/ ./ (/ 3/ )/ 设计/ 并/ 实现/ 了/ 同时/ 支持/ 基本/ 方法/ 、/ 临近/ 算法/ 、/ WDRS/ 和/ RM/ -/ CBDD4/ 种/ 恢复/ 算法/ 的/ 原型/ 系统/ ,/ 通过/ 重放/ Trace/ 数据/ 的/ 方式/ ,/ 对/ 4/ 种/ 算法/ 的/ 恢复/ 效率/ 进行/ 了/ 比较/ ,/ 分析/ 了/ 间隙/ 个数/ 对/ 恢复/ 效率/ 的/ 影响/ ./ 最后/ ,/ 通过/ 模拟/ 二分/ 探查/ 寻找/ 可/ 恢复/ 时刻/ 点/ 的/ 方式/ ,/ 比较/ 了/ 除/ 临近/ 算法/ 外/ 的/ 3/ 种/ 恢复/ 方法/ 在/ 恢复/ 时刻/ 点/ 识别/ 中/ 的/ 效率/ ./ 2/ 基本/ 模型/ 2.1/ 基本/ 模型/ 对于/ 由/ 相同/ 大小/ 且/ 相互/ 独立/ 的/ 数据/ 块/ 组成/ 的/ 数据/ 存储/ ,/ 每个/ 数据/ 块/ 都/ 包含/ 相同/ 大小/ 的/ 确定/ 数据/ ,/ 并且/ 由/ 逻辑/ 块/ 地址/ (/ LogicalBlockAddress/ ,/ LBA/ )/ 唯一/ 识别/ ./ 假设/ A/ 是/ 该/ 数据/ 存储/ 中/ 所有/ 逻辑/ 块/ 地址/ 的/ 全集/ ,/ D/ 表示/ 数据/ 块/ 中/ 所有/ 可能/ 的/ 数据/ 的/ 集合/ ./ 定义/ 1/ ./ 设/ St/ 为/ 集合/ A/ 和/ 集合/ D/ 上/ 的/ 二元关系/ ,/ 是/ 由/ 形式/ 为/ 〈/ a/ ,/ d/ 〉/ 的/ 二元/ 序偶/ 所/ 组成/ 的/ 集合/ ./ 对于/ 确定/ 的/ 时刻/ t/ ,/ 逻辑/ 块/ 地址/ a/ 唯一/ 标识/ 了/ 数据/ 块/ 以及/ 保存/ 在/ 该/ 数据/ 块/ 上/ 的/ 确定/ 数据/ d/ ,/ 因此/ 二元关系/ St/ 是/ 一个/ 函数/ ,/ 表示/ 数据/ 存储/ 在/ 时刻/ t/ 的/ 镜像/ ./ 用/ St/ (/ a/ )/ 表示/ 逻辑/ 块/ 地址/ a/ 所/ 标识/ 的/ 数据/ 块/ 在/ 时刻/ t/ 的/ 数据/ 镜像/ ./ 定义/ 2/ ./ 写/ 请求/ 集合/ R/ 是/ 由/ 形式/ 为/ 〈/ t/ ,/ a/ ,/ d/ 〉/ 的/ 三元/ 序偶/ 组成/ 的/ 集合/ ,/ 记录/ 了/ 某一时间/ 区间/ 内/ ,/ 由/ 逻辑/ 块/ 地址/ 和/ 时间/ 戳/ 标识/ 的/ 数据/ 更新/ 的/ 集合/ ./ R/ (/ t1/ ,/ t2/ ]/ 表示/ 时间/ 区间/ (/ t1/ ,/ t2/ ]/ 内/ 数据/ 存储系统/ 所/ 产生/ 的/ 所有/ 写/ 请求/ 的/ 集合/ ./ 定义/ 3/ ./ 逻辑/ 块/ 地址/ 集合/ B/ 记录/ 了/ 某一时间/ 区间/ 内/ 被/ 更新/ 的/ 所有/ 逻辑/ 块/ 地址/ ,/ 用/ B/ (/ t1/ ,/ t2/ ]/ 表示/ 时间/ 区间/ (/ t1/ ,/ t2/ ]/ 内/ 被/ 更新/ 的/ 逻辑/ 块/ 地址/ 集合/ ,/ 即/ 对/ 写/ 请求/ 集合/ R/ (/ t1/ ,/ t2/ ]/ 在/ 逻辑/ 块/ 地址/ 属性/ 上/ 进行/ 投影/ 运算/ B/ (/ t1/ ,/ t2/ ]/ =/ B/ (/ R/ (/ t1/ ,/ t2/ ]/ )/ =/ ∏/ LBA/ 在/ 某一时间/ 区间/ 内/ ,/ 数据/ 存储/ 可能/ 对/ 同一/ 数据/ 块/ 提交/ 多个/ 写/ 请求/ ,/ 但/ 只有/ 最后/ 提交/ 的/ 写/ 请求/ 的/ 结果/ 会/ 反映/ 到/ 最终/ 时刻/ 的/ 镜像/ 中/ ,/ 由/ 这些/ 有效/ 写/ 请求/ 所/ 更新/ 的/ 逻辑/ 块/ 地址/ 及/ 数据/ 所/ 构成/ 的/ 形式/ 为/ 〈/ a/ ,/ d/ 〉/ 的/ 二元/ 组所/ 组成/ 的/ 集合/ ,/ 即/ 为/ 该/ 时间/ 区间/ 上/ 的/ 增量/ ./ 数据/ 存储/ 在/ 时间/ 区间/ (/ t1/ ,/ t2/ ]/ 的/ 增量/ ,/ 可以/ 通过/ 对/ 写/ 请求/ 集合/ R/ (/ t1/ ,/ t2/ ]/ 的/ 运算/ 得到/ ./ 首先/ ,/ 对于/ B/ (/ R/ (/ t1/ ,/ t2/ ]/ )/ 中/ 的/ 每/ 一个/ 逻辑/ 块/ 地址/ ,/ 分别/ 从/ 集合/ R/ (/ t1/ ,/ t2/ ]/ 中/ 选择/ 出/ 时间/ 戳/ 最大/ 的/ 写/ 请求/ ,/ 然后/ 将/ 选出/ 的/ 写/ 请求/ 所/ 组成/ 的/ 集合/ 在/ 逻辑/ 块/ 地址/ 属性/ 和/ 数据/ 属性/ 上/ 执行/ 投影/ 运算/ ,/ 即/ 得到/ 写/ 请求/ 集合/ R/ (/ t1/ ,/ t2/ ]/ 在/ 时间/ 区间/ (/ t1/ ,/ t2/ ]/ 的/ 增量/ ./ 定义/ 4/ ./ 定义数据/ 存储/ 在/ 时间/ 区间/ (/ t1/ ,/ t2/ ]/ 的/ 增量/ I/ (/ t1/ ,/ t2/ ]/ =/ Δ/ S/ =/ St2/ -/ St1/ ,/ 即/ I/ (/ t1/ ,/ t2/ ]/ =/ I/ (/ R/ (/ t1/ ,/ t2/ ]/ )/ 定义/ 5/ ./ 对于/ 逻辑/ 块/ 地址/ 全集/ A/ 的/ 子集/ A/ ,/ 定义/ // 运算/ 为/ St/ // A/ =/ St/ ∩/ (/ A/ ×/ D/ )/ ,/ A/ / A/ ,/ 特殊/ 的/ ,/ 当/ A/ =/ B/ (/ t1/ ,/ t2/ ]/ 时/ ,/ St2/ // B/ (/ t1/ ,/ t2/ ]/ =/ I/ (/ t1/ ,/ t2/ ]/ ./ 为了/ 叙述/ 方便/ ,/ 使/ 公式/ 更加/ 清晰/ ,/ 对于/ 符号/ S/ 、/ B/ 、/ R/ 和/ I/ 以及/ 任意/ 时刻/ Tx/ 和/ 任意/ 时间/ 区间/ (/ Ty/ ,/ Tz/ ]/ ,/ 在下文/ 中/ 采用/ 简写/ Sx/ 来/ 表示/ STx/ ;/ 采用/ 简写/ B/ (/ y/ ,/ z/ ]/ 、/ R/ (/ y/ ,/ z/ ]/ 和/ I/ (/ y/ ,/ z/ ]/ 来/ 分别/ 表示/ B/ (/ Ty/ ,/ Tz/ ]/ 、/ R/ (/ Ty/ ,/ Tz/ ]/ 和/ I/ (/ Ty/ ,/ Tz/ ]/ ./ 2.2/ 临近/ 算法/ 的/ 形式化/ 分析/ 及/ 证明/ 连续/ 数据保护/ 系统/ 在/ 恢复/ 数据/ 时/ ,/ 通常/ 需要/ 通过/ 完整性/ 检测工具/ 对/ 历史/ 时刻/ 的/ 数据/ 镜像/ 进行/ 多次/ 检测/ ,/ 以便/ 确定/ 可/ 恢复/ 时刻/ 点/ ./ 由于/ 每次/ 检测/ 都/ 需要/ 将/ 数据恢复/ 至待/ 检测/ 时刻/ ,/ 多次/ 数据恢复/ 需要/ 耗费/ 大量/ 的/ 时间/ ./ 然而/ ,/ 相邻/ 两次/ 探查/ 时刻/ 点/ 之间/ 通常/ 相隔/ 较/ 小/ ,/ 数据/ 差异/ 并不大/ ,/ 通过/ 对/ 差异/ 数据/ 进行/ 分析/ 及/ 处理/ ,/ 可以/ 有效/ 提高/ 恢复/ 效率/ ./ 定义/ 6/ ./ 任意/ 一次/ 恢复/ 操作/ 之后/ ,/ 如果/ 有/ 写/ 请求/ 产生/ ,/ 则/ 此次/ 恢复/ 的/ 起始/ 时刻/ 与/ 目标/ 时刻/ 之间/ 的/ 写/ 请求/ 就/ 构成/ 了/ 一个/ 间隙/ ./ 由/ 起止/ 时刻/ 为/ 时刻/ 点/ ,/ x/ 和/ y/ 的/ 恢复/ x/ →/ y/ 所/ 形成/ 的/ 间隙/ 称为/ “/ 间隙/ x/ →/ y/ ”/ ./ 如图/ 1/ (/ b/ )/ 所示/ ,/ 连续/ 数据保护/ 系统/ 在/ T2/ 时刻/ Page4/ 执行/ 了/ 目标/ 时刻/ 为/ T1/ 恢复/ ,/ 即/ T2/ →/ T1/ ,/ 并/ 在/ 此次/ 恢复/ 完成/ 之后/ 继续/ 提交/ 写/ 请求/ ,/ 则/ 时间/ 区间/ [/ T1/ ,/ T2/ -/ ]/ 之间/ 的/ 写/ 请求/ 构成/ 了/ 一个/ 间隙/ ,/ 即/ 间隙/ T2/ →/ T1/ ./ 对于/ 恢复/ 路径/ 中/ 包含/ 时刻/ 点/ T2/ +/ 的/ 所有/ 时刻/ 点/ ,/ 即/ 时间/ 区间/ [/ T2/ +/ ,/ T3/ ]/ ,/ 在/ 恢复/ 时/ 都/ 需要/ 剔除/ 该/ 间隙/ 内/ 的/ 无效/ 写/ 请求/ ./ 侯利曼/ 等/ 人/ 提出/ 的/ “/ 临近/ 算法/ ”/ ,/ 根据/ 时间/ 间隔/ 较/ 小/ 的/ 两个/ 临近/ 时刻/ 点/ 之间/ 的/ 关系/ ,/ 在/ 不/ 多于/ 一个/ 间隙/ 的/ 情况/ 下/ ,/ 对/ 可能/ 出现/ 的/ 5/ 种/ 简单/ 情况/ 作/ 了/ 分析/ ,/ 基于/ 这/ 5/ 种/ 特殊/ 情况/ 的/ 临近/ 算法/ 可以/ 大幅度提高/ 连续/ 数据保护/ 系统/ 的/ 恢复/ 效率/ ./ 下面/ 对/ “/ 临近/ 算法/ ”/ 的/ 5/ 种/ 情况/ 分别/ 进行/ 了/ 形式化/ 分析/ ./ (/ 1/ )/ 无/ 间隙/ 后/ 临近/ 时间/ 点/ 恢复/ 对于/ 无/ 间隙/ 后/ 临近/ 时间/ 点/ 恢复/ T1/ →/ Ta/ ,/ 如图/ 1/ (/ a/ )/ 所示/ ,/ 当前/ 数据/ 卷/ 状态/ 所/ 对应/ 的/ 时刻/ 为/ T1/ ,/ 目标/ 时刻/ 为/ Ta/ ,/ T1/ 和/ Ta/ 之间/ 不/ 存在/ 间隙/ 并且/ Ta/ >/ T1/ ,/ 则/ 恢复/ T1/ →/ Ta/ 可/ 按照/ 式/ (/ 1/ )/ 进行/ ./ 证明/ 是/ 简单/ 的/ ,/ 式/ (/ 1/ )/ 用/ 时间/ 点/ T1/ 到/ Ta/ 的/ 增量/ 替换/ 该/ 时间段/ 内/ 发生/ 改变/ 的/ 数据/ 块/ 中/ 的/ 数据/ ,/ 这/ 与/ 典型/ 的/ Redo/ 操作/ 的/ 恢复/ 结果/ 一致/ ./ (/ 2/ )/ 无/ 间隙/ 前/ 临近/ 时间/ 点/ 恢复/ 对于/ 无/ 间隙/ 前/ 临近/ 时间/ 点/ 恢复/ T1/ →/ Tb/ ,/ 如图/ 1/ (/ a/ )/ 所示/ ,/ 当前/ 数据/ 卷/ 状态/ 所/ 对应/ 的/ 时刻/ 为/ T1/ ,/ 目标/ 时刻/ 为/ Tb/ ,/ T1/ 和/ Tb/ 之间/ 不/ 存在/ 间隙/ 并且/ Tb/ </ T1/ ./ 此时/ 首先/ 需要/ 将/ 时间/ 区间/ (/ Tb/ ,/ T1/ ]/ 内/ 被/ 更新/ 的/ 数据/ 剔除/ ,/ 然后/ 将/ 被/ 剔除/ 数据/ 块/ 在/ Tb/ 时刻/ 的/ 数据/ 镜像/ 写入/ 数据/ 卷/ ./ 恢复/ T1/ →/ Tb/ 可/ 按照/ 式/ (/ 2/ )/ 进行/ ./ Sb/ =/ (/ S1/ -/ S1/ // B/ (/ b/ ,/ 1/ ]/ )/ ∪/ (/ I/ (/ 0/ ,/ b/ ]/ // B/ (/ b/ ,/ 1/ ]/ )/ ∪/ 证明/ ./ 通过/ 关系/ 代数/ 可以/ 容易/ 的/ 证明/ ./ T1/ 时刻/ 数据/ 卷/ 的/ 状态/ S1/ ,/ 可以/ 用/ 初始/ 时刻/ 状态/ (/ S1/ -/ S1/ // B/ (/ b/ ,/ 1/ ]/ )/ =/ (/ S0/ -/ S0/ // S/ (/ 0/ ,/ 1/ ]/ )/ ∪/ (/ I/ (/ 0/ ,/ b/ ]/ // (/ B/ (/ 0/ ,/ b/ ]/ -/ B/ (/ b/ ,/ 1/ ]/ )/ )/ (/ 3/ )/ S0/ 表示/ 为/ 将/ 式/ (/ 3/ )/ 代入/ 式/ (/ 2/ )/ 可/ 得到/ Sb/ =/ (/ S0/ -/ S0/ // S/ (/ 0/ ,/ 1/ ]/ )/ ∪/ (/ I/ (/ 0/ ,/ b/ ]/ // (/ B/ (/ 0/ ,/ b/ ]/ -/ B/ (/ b/ ,/ 1/ ]/ )/ )/ ∪/ (/ I/ (/ 0/ ,/ b/ ]/ // B/ (/ b/ ,/ 1/ ]/ )/ ∪/ (/ S0/ // (/ B/ (/ b/ ,/ 1/ ]/ -/ B/ (/ 0/ ,/ b/ ]/ )/ )/ (/ 4/ )/ 对于/ 式/ (/ 4/ )/ 中/ 的/ 第一/ 部分/ 和/ 最后/ 一部分/ ,/ 第二/ 部分/ 和/ 第三/ 部分/ ,/ 分别/ 结合/ 计算/ 后/ 可/ 得出/ 这/ 与/ 采用/ Redo/ 方法/ 的/ 恢复/ 结果/ 一致/ ./ 证毕/ ./ (/ 3/ )/ 有/ 间隙/ 后/ (/ 间隙/ 内/ )/ 临近/ 时间/ 点/ 恢复/ 对于/ 间隙/ 内/ 临近/ 时间/ 点/ 恢复/ T3/ →/ Tc/ ,/ 如图/ 1/ (/ b/ )/ 所示/ ,/ 当前/ 数据/ 卷/ 状态/ 所/ 对应/ 的/ 时刻/ 为/ T3/ ,/ 目标/ 时刻/ 点为/ 时间/ 区间/ (/ T2/ +/ ,/ T3/ ]/ 上/ 的/ Tc/ ./ 首先/ 需要/ 将/ 时间/ 区间/ (/ Tc/ ,/ T3/ ]/ 内/ 被/ 更新/ 的/ 数据/ 剔除/ ,/ 然后/ 将/ 被/ 剔除/ 的/ 数据/ 块/ 在/ Tc/ 时刻/ 的/ 数据/ 镜像/ 写入/ 数据/ 卷/ ./ 恢复/ T3/ →/ Tc/ 可/ 按照/ 式/ (/ 6/ )/ 进行/ ./ Sc/ =/ (/ S3/ -/ S3/ // B/ (/ c/ ,/ 3/ ]/ )/ ∪/ (/ I/ (/ 2/ +/ ,/ c/ ]/ // B/ (/ c/ ,/ 3/ ]/ )/ ∪/ 对于/ 恢复/ T3/ →/ Tc/ ,/ 与/ 无/ 间隙/ 前/ 临近/ 时间/ 点/ 恢复/ 类似/ ,/ 在/ 写入/ 被/ 剔除/ 的/ 数据/ 块/ 镜像/ 时/ ,/ 只/ 需要/ 先/ 从/ 间隙/ 前后/ 的/ 两段/ 时间/ 区间/ (/ (/ T2/ +/ ,/ Tc/ ]/ 和/ (/ T0/ ,/ T1/ ]/ )/ 内/ 构建/ 被/ 剔除/ 的/ 数据/ 块/ 在/ Tc/ 时刻/ 的/ 镜像/ ./ 证明/ 过程/ 与/ 无/ 间隙/ 前/ 临近/ 时间/ 点/ 恢复/ 类似/ ./ (/ 4/ )/ 有/ 间隙/ 后/ (/ 间隙/ 外/ )/ 临近/ 时间/ 点/ 恢复/ 对于/ 间隙/ 外/ 临近/ 时间/ 点/ 恢复/ T3/ →/ Td/ ,/ 如图/ 1/ (/ b/ )/ 所示/ ,/ 数据/ 卷/ 当前/ 状态/ 所/ 对应/ 的/ 时刻/ 点为/ T3/ ,/ 目标/ 时刻/ 点为/ 时间/ 区间/ (/ T1/ ,/ T2/ -/ ]/ 上/ 的/ Td/ ./ 对于/ 该/ 恢复/ ,/ 不仅/ 要/ 将/ 时间/ 区间/ (/ T1/ ,/ Td/ ]/ 内/ 的/ 数据/ 写入/ 数据/ 卷/ ,/ 还要/ 剔除/ 时间/ 区间/ (/ T2/ +/ ,/ T3/ ]/ 内/ 被/ 更新/ 的/ 数据/ ,/ 如式/ (/ 7/ )/ 所示/ ./ Sd/ =/ (/ S3/ -/ S3/ // (/ B/ (/ 2/ +/ ,/ 3/ ]/ ∪/ B/ (/ 1/ ,/ d/ ]/ )/ )/ ∪/ I/ (/ 1/ ,/ d/ ]/ ∪/ 可见/ ,/ 对于/ 间隙/ 外/ 临近/ 时间/ 点/ 恢复/ T3/ →/ Td/ ,/ 是/ 写入/ 数据/ 与/ 剔除/ 数据/ 并存/ 的/ 一种/ 情况/ ,/ 根据/ 无/ 间隙/ 前/ 和/ 无/ 间隙/ 后/ 临近/ 时间/ 点/ 恢复/ 可以/ 容易/ 证明/ ./ (/ 5/ )/ 有/ 间隙/ 前/ 临近/ 时间/ 点/ 恢复/ 对于/ 间隙/ 前/ 临近/ 时间/ 点/ 恢复/ T3/ →/ Te/ ,/ 如图/ 1/ (/ b/ )/ 所示/ ,/ 数据/ 卷/ 当前/ 状态/ 所/ 对应/ 的/ 时刻/ 点为/ T3/ ,/ 目标/ 时刻/ 点为/ 时间/ 区间/ (/ T0/ ,/ T1/ ]/ 上/ 的/ Te/ ,/ 根据/ 式/ (/ 8/ )/ 进行/ 恢复/ ./ 对于/ 恢复/ T3/ →/ Te/ ,/ 与/ 无/ 间隙/ 前/ 临近/ 时间/ 点/ 恢/ Page5/ 复/ 类似/ ,/ 只/ 需要/ 剔除/ 间隙/ 前后/ 的/ 两段/ 时间/ 区间/ (/ (/ T2/ +/ ,/ T3/ ]/ 和/ (/ Te/ ,/ T1/ ]/ )/ 内/ 被/ 更新/ 的/ 数据/ 块/ ./ 因此/ ,/ 根据/ 无/ 间隙/ 前/ 临近/ 时间/ 点/ 恢复/ 可以/ 容易/ 的/ 证明/ ./ 3RM/ -/ CBDD/ 算法/ 在/ 恢复/ 数据/ 时/ ,/ RM/ -/ CBDD/ (/ RecoveryMethodforCDPBasedonDataDiscrepancies/ ,/ RM/ -/ CBDD/ )/ 以/ 快照/ 时刻/ 为/ 基础/ ,/ 首先/ 找到/ 恢复/ 起止/ 时刻/ 的/ 参照/ 时刻/ 点/ ,/ 并/ 通过/ 递归/ 算法/ 剔除/ 由/ 间隙/ 引入/ 的/ 无效/ 写/ 请求/ 之后/ ,/ 得到/ 了/ 参照/ 时刻/ 点/ 与/ 恢复/ 起止/ 时刻/ 之间/ 的/ 两个/ 写/ 请求/ 集合/ ,/ 然后/ 通过/ 对/ 两写/ 请求/ 集合/ 的/ 分析/ ,/ 找出/ 恢复/ 起止/ 时刻/ 之间/ 的/ 差异/ 数据/ ,/ 最后/ 分别/ 以/ 不同/ 的/ 方法/ 对/ “/ 多/ 数据/ ”/ 和/ “/ 少/ 数据/ ”/ 两种/ 类型/ 的/ 差异/ 数据/ 进行/ 处理/ ,/ 即可/ 完成/ 数据恢复/ ./ 3.1/ 数据/ 记录/ 3.1/ ./ 1/ 恢复/ 映射/ 序列/ 虽然/ 临近/ 算法/ 具有/ 很/ 高/ 的/ 恢复/ 效率/ ,/ 然而/ ,/ 临近/ 算法/ 仅/ 支持/ 最多/ 不/ 超过/ 一个/ 间隙/ 情况/ 下/ 的/ 5/ 种/ 简单/ 情况/ ,/ 无法/ 对/ 连续/ 数据保护/ 系统/ 实际/ 应用/ 中/ 常见/ 的/ 多/ 间隙/ 复杂/ 情况/ 进行/ 处理/ ./ 为了/ 实现/ 对/ 多/ 间隙/ 复杂/ 情况/ 的/ 恢复/ ,/ RM/ -/ CBDD/ 通过/ 恢复/ 映射/ 序列/ ,/ 记录/ 连续/ 数据保护/ 系统启动/ 后/ 的/ 每/ 一次/ 恢复/ ./ 图/ 2/ (/ a/ )/ 展示/ 了/ 一个/ 存在/ 3/ 个/ 间隙/ 的/ 恢复/ 过程/ ,/ 从/ 初始/ 时刻/ T0/ 到/ 最终/ 时刻/ T19/ ,/ 依次/ 经历/ 了/ T7/ →/ T3/ 、/ T12/ →/ T1/ 和/ T18/ →/ T9/ 三次/ 恢复/ ,/ 形成/ 了/ 3/ 个/ 间隙/ ./ 由于/ 这种/ 无规律/ 间隙/ 的/ 存在/ ,/ 通过/ 恢复/ 映射/ 序列/ ,/ 如图/ 2/ (/ b/ )/ 所示/ ,/ RM/ -/ CBDD/ 记录/ 了/ 自/ 初始/ 时刻/ T0/ 以来/ 执行/ 过/ 的/ 所有/ 恢复/ 的/ 起止/ 时刻/ ,/ 以便/ 在/ 数据恢复/ 时/ 作为/ 参考/ ./ 3.1/ ./ 2/ 插入/ 快照/ 以/ 初始/ 时刻/ 为/ 共同/ 起点/ ,/ 当前/ 时刻/ 与/ 目标/ 时刻/ 很/ 有/ 可能/ 共同/ 经历/ 一段/ 相同/ 的/ 写/ 请求/ 序列/ ,/ 也就是说/ ,/ 在/ 剔除/ 间隙/ 引入/ 的/ 无效/ 写/ 请求/ 之后/ ,/ 初始/ 时刻/ 与/ 恢复/ 起止/ 时刻/ 的/ 两个/ 写/ 请求/ 集合/ 之间/ ,/ 可能/ 存在/ 交集/ ./ 并且/ ,/ 随着/ 初始/ 时刻/ 与/ 恢复/ 起止/ 时刻/ 之间/ 间隔/ 的/ 增加/ ,/ 两写/ 请求/ 集合/ 之间/ 的/ 交集/ 也/ 随之/ 增大/ ./ RM/ -/ CBDD/ 算法/ 需要/ 遍历/ 历史数据/ ,/ 通过/ 对/ 初始/ 时刻/ 与/ 恢复/ 起止/ 时刻/ 之间/ 的/ 两写/ 请求/ 集合/ 进行/ 分析/ ,/ 以/ 确定/ 两/ 时刻/ 点/ 之间/ 的/ 差异/ 数据/ ./ 而/ 由于/ 两写/ 请求/ 集合/ 交集/ 的/ 存在/ ,/ 使得/ 需要/ 遍历/ 的/ 历史数据/ 增加/ 、/ 对/ 写/ 请求/ 进行/ 分析/ 的/ 复杂度/ 增大/ ./ 为了/ 降低/ 获取/ 差异/ 数据/ 的/ 时间/ 开销/ ,/ RM/ -/ CBDD/ 在/ 历史数据/ 中/ ,/ 按照/ 一定/ 的/ 时间/ 间隔/ ,/ 在/ 日志/ 链条/ 中/ 插入/ 相应/ 时刻/ 的/ 快照/ ,/ 并/ 将/ 恢复/ 起止/ 时刻/ 与/ 初始/ 时刻/ 之间/ 共同/ 经历/ 的/ 写/ 请求/ 序列/ 中/ 时刻/ 最晚/ 的/ 快照/ 时刻/ 作为/ 参照/ 时刻/ 点/ ,/ 以/ 取代/ 初始/ 时刻/ ./ 这样/ ,/ 以/ 参照/ 时刻/ 为/ 基准/ 的/ 两写/ 请求/ 集合/ 的/ 交集/ 减小/ ,/ 并且/ 最大/ 不/ 超过/ 两/ 快照/ 时刻/ 之间/ 的/ 时间/ 间隔/ ,/ 达到/ 降低/ 获取/ 差异/ 数据/ 时间/ 开销/ 的/ 目的/ ./ 并且/ ,/ 在/ 对/ 差异/ 数据/ 中/ 的/ “/ 多/ 数据/ ”/ 进行/ 处理/ 时/ ,/ 参照/ 时刻/ 之前/ 的/ 数据/ 可以/ 直接/ 通过/ 参照/ 时刻/ 的/ 快照/ 获得/ ,/ 所/ 需/ 遍历/ 的/ 写/ 请求/ 集合/ 也/ 随之/ 减小/ ,/ 对/ 提高/ “/ 多/ 数据/ ”/ 的/ 处理/ 效率/ 也/ 起到/ 了/ 一定/ 作用/ ./ 如图/ 2/ (/ a/ )/ 所示/ ,/ 在/ 日志/ 链条/ 中/ ,/ 每隔/ d/ 个/ 写/ 请求/ 就/ 插入/ 相应/ 时刻/ 的/ 快照/ Si/ ,/ 如果/ 被/ 间隙/ 打断/ ,/ 则/ 从/ 间隙/ 之后/ 重新/ 对/ d/ 进行/ 计数/ ./ 为了/ 节约/ 存储空间/ ,/ 在/ 实现/ 时/ ,/ 快照/ 只/ 保存/ 指向/ 相应/ 写/ 请求/ 数据/ 的/ 指针/ ./ 定义/ 7/ ./ 设/ SN/ 和/ SN/ 是/ 由/ 快照/ 时刻/ 点/ 组成/ 的/ 集合/ ,/ SN/ (/ t1/ ,/ t2/ ]/ 记录/ 了/ 不/ 存在/ 间隙/ 的/ 时间/ 区间/ (/ t1/ ,/ t2/ ]/ 内/ 的/ 所有/ 快照/ 时刻/ 点/ ;/ 在/ 剔除/ 时间/ 区间/ (/ t3/ ,/ t4/ ]/ 内/ 由/ 间隙/ 引入/ 的/ 无效/ 写/ 请求/ 后/ ,/ SN/ (/ t3/ ,/ t4/ ]/ 则/ 记录/ 了/ 该/ 时间/ 区间/ 内/ 的/ 所有/ 快照/ 时刻/ 点/ ./ 3.2/ 构建/ 写/ 请求/ 集合/ 3.2/ ./ 1/ 确定/ 参照/ 时刻/ 点/ 参照/ 时刻/ 点/ ,/ 即/ 当前/ 时刻/ Tc/ 和/ 恢复/ 目标/ 时刻/ Tt/ 与/ 初始/ 时刻/ T0/ 之间/ 的/ 两个/ 快照/ 时刻/ 点/ 集合/ 的/ 交/ 集中/ ,/ 时间/ 戳/ 最晚/ 的/ 时刻/ 点/ ,/ 如果/ 交集/ 为空/ ,/ 则/ 取/ 初始/ 时刻/ T0/ 为/ 参照/ 时刻/ 点/ ./ 然而/ ,/ 考虑/ 到/ 多/ 间隙/ 的/ 存在/ ,/ 快照/ 时刻/ 点/ 集合/ 需要/ 剔除/ 间隙/ 中/ 的/ 无效/ 快照/ 时刻/ 点/ ,/ 因此/ 采用/ 递归/ 的/ 方式/ ,/ 分别/ 以/ 当前/ 时刻/ 点/ Tc/ 和/ 恢复/ 目标/ 时刻/ 点/ Tt/ 为/ 起点/ ,/ 向/ 初始/ 时刻/ T0/ 方向/ 遍历/ ,/ 根据/ 恢复/ 映射/ 序列/ ,/ 将/ 间隙/ 逐一/ 剔除/ ,/ 最终/ 获得/ 两个/ 快照/ 时刻/ 点/ 集合/ ./ 具/ Page6/ 体/ 的/ 递归/ 算法/ 如下/ :/ 之间/ 不/ 存在/ 间隙/ 时/ :/ (/ 1/ )/ 基本/ 情况/ ./ 任意/ 时刻/ 点/ t/ 与/ 初始/ 时刻/ 点/ T0/ 间/ 至少/ 存在/ 一个/ 间隙/ 时/ :/ (/ 2/ )/ 递归/ 步骤/ ./ 当/ 时刻/ 点/ t/ 与/ 初始/ 时刻/ 点/ T0/ 之设/ 〈/ x/ →/ y/ 〉/ 为/ 时间/ 区间/ (/ T0/ ,/ t/ ]/ 上/ t/ →/ 0/ 方向/ 的/ 第一个/ 间隙/ ,/ 则/ 在/ 确定/ 了/ 恢复/ 起止/ 时刻/ 与/ 初始/ 时刻/ 之间/ 的/ 快照/ 然后/ ,/ 对/ 时刻/ 点/ y/ 继续/ 过程/ (/ 1/ )/ 、/ (/ 2/ )/ ./ 时刻/ 点/ 集合/ 后/ ,/ 参照/ 时刻/ 点/ Tbase/ 如式/ (/ 9/ )/ 所示/ ./ Tbase/ =/ σ/ max/ (/ timestamp/ )/ (/ (/ SN/ (/ 0/ ,/ t/ ]/ ∩/ SN/ (/ 0/ ,/ c/ ]/ )/ ∪/ {/ T0/ }/ )/ (/ 9/ )/ 3.2/ ./ 2/ 构建/ 写/ 请求/ 集合/ R/ (/ 0/ ,/ t/ ]/ 和/ R/ (/ base/ ,/ t/ ]/ 分别/ 表示/ 从/ 初始/ 时刻/ T0/ 和/ 参考/ 时刻/ Tbase/ 到/ 任意/ 时刻/ t/ 之间/ 的/ 所有/ 写/ 请求/ 构成/ 的/ 集合/ ;/ 由于/ 多/ 间隙/ 的/ 存在/ ,/ 在/ 恢复/ 数据/ 时/ ,/ 需要/ 将/ 时刻/ t/ 的/ 恢复/ 路径/ 中/ 的/ 所有/ 间隙/ 剔除/ ,/ 用/ R/ (/ 0/ ,/ t/ ]/ 和/ R/ (/ base/ ,/ t/ ]/ 表示/ 剔除/ 间隙/ 之后/ 的/ 写/ 请求/ 集合/ ./ 为了/ 获取/ 恢复/ 起止/ 时刻/ 之间/ 的/ 差异/ 数据/ ,/ 以/ 实现/ 数据恢复/ 的/ 目标/ ,/ 需要/ 先/ 分别/ 获得/ 恢复/ 起止/ 时刻/ 与/ 参照/ 时刻/ 之间/ 的/ 写/ 请求/ 集合/ ./ 此时/ 仍然/ 需要/ 剔除/ 由/ 间隙/ 所/ 带来/ 的/ 无效/ 写/ 请求/ ,/ 因此/ 同样/ 采用/ 递归/ 的/ 方式/ ,/ 分别/ 对/ 当前/ 时刻/ 点/ Tc/ 和/ 目标/ 时刻/ 点/ Tt/ ,/ 以/ 恢复/ 映射/ 序列/ 为/ 参照/ ,/ 对/ 历史数据/ 进行/ 遍历/ ,/ 将/ 间隙/ 逐一/ 剔除/ ,/ 最终/ 获得/ 两/ 时刻/ 点/ 分别/ 基于/ 参考/ 时刻/ Tbase/ 的/ 写/ 请求/ 集合/ R/ (/ base/ ,/ c/ ]/ 和/ R/ (/ base/ ,/ t/ ]/ ./ 具体/ 的/ 递归/ 算法/ 如下/ :/ (/ 1/ )/ 基本/ 情况/ ./ 任意/ 时刻/ 点/ t/ 与/ 参照/ 时刻/ 点/ Tbase/ 之间/ 不/ 存在/ 间隙/ 时间/ 至少/ 存在/ 一个/ 间隙/ 时/ :/ (/ 2/ )/ 递归/ 步骤/ ./ 当/ 时刻/ 点/ t/ 与/ 初始/ 时刻/ 点/ T0/ 之设/ 〈/ x/ →/ y/ 〉/ 为/ 时间/ 区间/ (/ Tbase/ ,/ t/ ]/ 上/ t/ →/ 0/ 方向/ 的/ 第一个/ 间隙/ ,/ 则/ 然后/ ,/ 对/ 时刻/ 点/ y/ 继续/ 过程/ (/ 1/ )/ 、/ (/ 2/ )/ ./ 以/ 目标/ 时刻/ 点/ T10/ 为例/ ,/ 如图/ 2/ (/ b/ )/ 所示/ ,/ 以/ 当前/ 时刻/ 点/ T19/ 为/ 起始/ 时刻/ 的/ 恢复/ T19/ →/ T10/ ,/ 其/ 快照/ 时刻/ 集合/ 分别/ 为/ SN/ (/ 0/ ,/ 19/ ]/ =/ {/ Tsn1/ ,/ Tsn2/ ,/ Tsn5/ }/ 和/ SN/ (/ 0/ ,/ 10/ ]/ =/ {/ Tsn1/ ,/ Tsn2/ ,/ Tsn5/ }/ ;/ 恢复/ 起止/ 时刻/ T19/ 和/ T10/ 的/ 参考/ 时刻/ 为/ Tbase/ =/ Tsn5/ ;/ 以/ 参照/ 时刻/ 点/ Tsn5/ 为/ 基准/ 的/ 写/ 请求/ 集合/ 为/ R/ (/ base/ ,/ 19/ ]/ =/ R/ (/ sn5/ ,/ 9/ ]/ ∪/ R/ (/ 18/ ,/ 19/ ]/ 和/ R/ (/ base/ ,/ 10/ ]/ =/ R/ (/ sn5/ ,/ 10/ ]/ ./ 3.3/ 获取/ 差异/ 数据/ RM/ -/ CBDD/ 算法/ 的/ 关键在于/ 找出/ 数据/ 存储/ 在/ 当前/ 时刻/ 的/ 镜像/ Sc/ 与/ 目标/ 时刻/ 的/ 镜像/ St/ 之间/ 的/ 差异/ 数据/ ./ 实际上/ ,/ 差异/ 数据/ 是/ 由/ 时间/ 区间/ (/ Tbase/ ,/ Tt/ ]/ 和/ (/ Tbase/ ,/ Tc/ ]/ 内/ 产生/ 的/ 不同/ 写/ 请求/ 所/ 形成/ 的/ ,/ 差异/ 数据/ 分为/ “/ 少/ 数据/ ”/ 和/ “/ 多/ 数据/ ”/ 两种/ 类型/ ,/ 图/ 3/ 展示/ 了/ 目标/ 时刻/ 和/ 当前/ 时刻/ 写/ 请求/ 集合/ 之间/ 的/ 关系/ ./ 3.3/ ./ 1/ 少/ 数据/ 对于/ 当前/ 时刻/ 镜像/ Sc/ 比/ 目标/ 时刻/ 镜像/ St/ 少/ 的/ 数据/ ,/ 即/ St/ -/ Sc/ ,/ 用/ St/ -/ Sc/ 集合/ 中/ 元素/ 替换/ Sc/ 集合/ 中/ 相应/ 逻辑/ 块/ 地址/ 所/ 标识/ 的/ 元素/ 即可/ ;/ 在/ 执行/ 数据恢复/ 时/ ,/ 则/ 只/ 需要/ 将/ 这/ 一部分/ 增量/ 直接/ 提交/ 至/ 数据/ 卷/ ./ 如图/ 3/ 所示/ ,/ “/ 少/ 数据/ ”/ 是/ 由/ 图/ 中/ ①/ 这部分/ 写/ 请求/ 所/ 引起/ ,/ 这些/ 写/ 请求/ 对/ 逻辑/ 块/ 地址/ 集合/ B/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ 所/ 对应/ 的/ 逻辑/ 块/ 进行/ 了/ 更新/ ,/ 其/ 增量/ 为/ 以图/ 2/ (/ a/ )/ 中/ 的/ 恢复/ T19/ →/ T10/ 为例/ ,/ 其/ “/ 少/ 数据/ ”/ 的/ 增量/ 为/ I/ (/ R/ (/ base/ ,/ 10/ ]/ -/ R/ (/ base/ ,/ 19/ ]/ )/ =/ I/ (/ R/ (/ 9/ ,/ 10/ ]/ )/ ./ 3.3/ ./ 2/ 多/ 数据/ 对于/ 当前/ 时刻/ 镜像/ Sc/ 比/ 目标/ 时刻/ 镜像/ St/ 多出/ 的/ 数据/ ,/ 即/ Sc/ -/ St/ ,/ 首先/ 需要/ 在/ 历史数据/ 及/ 初始/ 镜像/ 中/ 获取/ Sc/ -/ St/ 中/ 数据/ 块/ 在/ 目标/ 时刻/ t/ 的/ 镜像/ ,/ 然后/ 从/ 集合/ Sc/ 中将/ Sc/ -/ St/ 剔除/ ,/ 并/ 将/ 获取/ 到/ 的/ 镜像/ 添加/ 至/ Sc/ 中/ ;/ 执行/ 数据恢复/ 时/ ,/ 在/ 获取/ 到/ 目标/ 时刻/ Tt/ 的/ 镜像/ 后/ ,/ 将/ 这部分/ 数据/ 以/ 增量/ 的/ 形式/ 提交/ 至/ 数据/ 卷/ 即可/ ./ 因为/ 不同/ 的/ 写/ 请求/ 可能/ 会/ 对/ 同一/ 数据/ 块/ 进行/ 更新/ ,/ 所以/ 图/ 3/ 中/ ①/ 和/ ③/ 两/ 部分/ 写/ 请求/ 存在/ 对/ 相同/ 逻辑/ 块/ 进行/ 更新/ 的/ 可能/ ,/ 即/ 存在/ (/ B/ (/ R/ (/ base/ ,/ c/ ]/ -/ R/ (/ base/ ,/ t/ ]/ )/ )/ ∩/ (/ B/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ )/ ≠/ / 的/ 可能/ ./ 注意/ 到/ ,/ 在/ “/ 少/ 数据/ ”/ 中/ 已经/ 对图/ 中/ ③/ 部分/ 的/ 逻辑/ 块/ 进行/ 了/ 处理/ ,/ 因此/ ,/ 在/ “/ 多/ 数据/ ”/ 中/ 并不需要/ 重复/ 处理/ ,/ 即/ 需要/ 剔除/ 的/ 逻辑/ 块/ 地址/ 集合/ 简化/ 为/ B/ (/ R/ (/ base/ ,/ c/ ]/ -/ R/ (/ base/ ,/ t/ ]/ )/ -/ B/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ (/ 11/ )/ 可见/ ,/ 与/ “/ 少/ 数据/ ”/ 不同/ ,/ “/ 多/ 数据/ ”/ 的/ 情况/ 变得复杂/ ,/ 处理/ “/ 多/ 数据/ ”/ 的/ 关键在于/ 获取/ 这部分/ 数据/ 所/ 对/ Page7/ 应/ 数据/ 块/ 在/ 恢复/ 目标/ 时刻/ Tt/ 的/ 镜像/ ./ 简单/ 的/ 方法/ 是/ 按照/ 时间/ 先后顺序/ ,/ 直接/ 将/ 历史/ 写/ 请求/ 集合/ R/ (/ base/ ,/ t/ ]/ 提交/ 至/ 数据/ 卷/ ,/ 即/ 对/ 集合/ R/ (/ base/ ,/ t/ ]/ 中/ 的/ 写/ 请求/ 执行/ Redo/ 操作/ ,/ 但/ 由于/ 存在/ 对/ 同一/ 逻辑/ 块/ 地址/ 的/ 多次/ 写/ 操作/ ,/ 还/ 可能/ 重复/ 处理/ “/ 少/ 数据/ ”/ 中/ 的/ 部分/ 逻辑/ 块/ ,/ 因此/ 效率/ 不高/ ./ 为了/ 获得最佳/ 效率/ ,/ RM/ -/ CBDD/ 按照/ 以下/ 方法/ 获取/ 式/ (/ 11/ )/ 中/ 逻辑/ 块/ 地址/ 在/ 恢复/ 目标/ 时刻/ Tt/ 的/ 镜像/ :/ (/ 1/ )/ 首先/ 按照/ 时间/ 的/ 逆序/ ,/ 即/ Tt/ →/ Tbase/ ,/ 遍历/ 写/ 请求/ 集合/ R/ (/ base/ ,/ t/ ]/ ∩/ R/ (/ base/ ,/ c/ ]/ ,/ 得到/ 部分/ 逻辑/ 块/ 地址/ 在/ 时刻/ Tt/ 的/ 镜像/ :/ I/ (/ R/ (/ base/ ,/ t/ ]/ ∩/ R/ (/ base/ ,/ c/ ]/ )/ // (/ B/ (/ R/ (/ base/ ,/ c/ ]/ -/ R/ (/ base/ ,/ t/ ]/ )/ -/ B/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ )/ (/ 12/ )/ (/ 2/ )/ 对于/ 无法/ 在/ R/ (/ base/ ,/ t/ ]/ ∩/ R/ (/ base/ ,/ c/ ]/ 中/ 获取/ 到/ 的/ 逻辑/ 块/ ,/ 表明/ 时间/ 区间/ (/ Tbase/ ,/ Tt/ ]/ 内/ 并/ 没有/ 写/ 请求/ 对/ 其/ 进行/ 更新/ ./ 因此/ ,/ 参照/ 时刻/ Tbase/ 的/ 数据/ 镜像/ Sbase/ 中/ 相应/ 逻辑/ 块/ 镜像/ 即/ 为/ 剩余/ 逻辑/ 块/ 地址/ 在/ 目标/ 时刻/ Tt/ 的/ 镜像/ :/ Sbase/ // (/ B/ (/ R/ (/ base/ ,/ c/ ]/ -/ R/ (/ base/ ,/ t/ ]/ )/ -/ B/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ -/ B/ (/ R/ (/ base/ ,/ t/ ]/ ∩/ R/ (/ base/ ,/ c/ ]/ )/ )/ 根据/ 式/ (/ 12/ )/ 和/ 式/ (/ 13/ )/ ,/ RM/ -/ CBDD/ 按照/ 式/ (/ 14/ )/ 对/ “/ 多/ 数据/ ”/ 进行/ 处理/ (/ I/ (/ R/ (/ base/ ,/ t/ ]/ ∩/ R/ (/ base/ ,/ c/ ]/ )/ // (/ B/ (/ R/ (/ base/ ,/ c/ ]/ -/ R/ (/ base/ ,/ t/ ]/ )/ -/ B/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ )/ )/ (/ ∪/ Sbase/ // (/ B/ (/ R/ (/ base/ ,/ c/ ]/ -/ R/ (/ base/ ,/ t/ ]/ )/ -/ B/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ -/ B/ (/ R/ (/ base/ ,/ t/ ]/ ∩/ R/ (/ base/ ,/ c/ ]/ )/ )/ )/ (/ 14/ )/ 以图/ 2/ (/ a/ )/ 中/ 的/ 恢复/ T19/ →/ T10/ 为例/ ,/ RM/ -/ CBDD/ 获取/ 的/ “/ 多/ 数据/ ”/ 逻辑/ 块/ 地址/ 在/ 恢复/ 目标/ 时刻/ T10/ 的/ 镜像/ 为/ (/ I/ (/ R/ (/ sn5/ ,/ 9/ ]/ )/ // (/ B/ (/ R/ (/ 18/ ,/ 19/ ]/ )/ -/ B/ (/ R/ (/ 9/ ,/ 10/ ]/ )/ )/ )/ (/ Ssn5/ // (/ B/ (/ R/ (/ 18/ ,/ 19/ ]/ )/ -/ B/ (/ R/ (/ 9/ ,/ 10/ ]/ )/ -/ B/ (/ R/ (/ sn5/ ,/ 9/ ]/ )/ )/ )/ ./ 3.4/ RM/ -/ CBDD/ 算法/ 综合/ 3.3/ 节中/ 对/ “/ 少/ 数据/ ”/ 和/ “/ 多/ 数据/ ”/ 的/ 处理过程/ ,/ RM/ -/ CBDD/ 从/ 当前/ 时刻/ 对应/ 镜像/ Sc/ 恢复/ 到/ 目标/ 时刻/ 镜像/ St/ 的/ 过程/ 可以/ 形式化/ 地/ 表示/ 为/ St/ (/ =/ Sc/ -/ Sc/ // (/ B/ (/ R/ (/ base/ ,/ c/ ]/ -/ R/ (/ base/ ,/ t/ ]/ )/ ∪/ B/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ )/ )/ ∪/ I/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ (/ I/ (/ R/ (/ base/ ,/ t/ ]/ ∩/ R/ (/ base/ ,/ c/ ]/ )/ // (/ B/ (/ R/ (/ base/ ,/ c/ ]/ -/ R/ (/ base/ ,/ t/ ]/ )/ -/ B/ (/ R/ (/ base/ ,/ t/ ]/ -/ R/ (/ base/ ,/ c/ ]/ )/ )/ )/ (/ Sbase/ // (/ B/ (/ R/ (/ base/ ,/ c/ ]/ )/ -/ B/ (/ R/ (/ base/ ,/ t/ ]/ )/ )/ )/ (/ 15/ )/ 如图/ 4/ 所示/ ,/ RM/ -/ CBDD/ 的/ 恢复/ 过程/ 如下/ :/ 请求/ 集合/ R/ (/ base/ ,/ c/ ]/ 和/ R/ (/ base/ ,/ t/ ]/ ;/ 类型/ 的/ 差异/ 数据/ ;/ ①/ 根据/ 3.2/ 节/ 找到/ 参照/ 时刻/ 点/ Tbase/ ,/ 并/ 获得/ 写/ ②/ 根据/ 3.3/ 节/ 获取/ “/ 少/ 数据/ ”/ 和/ “/ 多/ 数据/ ”/ 两种/ ③/ 根据/ 式/ (/ 10/ )/ ,/ 将/ “/ 少/ 数据/ ”/ 直接/ 写入/ 数据/ 卷/ ;/ ④/ 根据/ 式/ (/ 14/ )/ ,/ 将/ 获取/ 到/ 的/ “/ 多/ 数据/ ”/ 数据/ 块/ 在/ 目标/ 时刻/ Tt/ 的/ 镜像/ 提交/ 至/ 数据/ 卷/ ./ 3.5/ 恢复/ 性能/ 分析/ 对于/ RM/ -/ CBDD/ 算法/ ,/ 其/ 恢复/ 时间/ 由/ 读取/ 元/ 数据/ 、/ 根据/ 元/ 数据/ 获取/ 写/ 请求/ 集合/ 及/ 差异/ 数据/ 、/ 读取/ 历史数据/ 并/ 写入/ 数据/ 卷/ 几/ 部分/ 组成/ ./ 其中/ ,/ 需要/ 读取/ 的/ 元/ 数据/ 包括/ 恢复/ 映射/ 序列/ 以及/ 与/ 恢复/ 相关/ 的/ 时间/ 区间/ 的/ 写/ 请求/ 描述符/ ,/ 这些/ 与/ 真正/ 需要/ 恢复/ 的/ 数据/ 相比/ ,/ 数据量/ 要/ 小/ 很多/ ;/ 另外/ ,/ 获取/ 写/ 请求/ 集合/ 以及/ 差异/ 数据/ 的/ 过程/ 都/ 是/ 在/ 内存/ 中/ 完成/ ,/ 与/ 大量/ 的/ 磁盘/ I/ // O/ 操作/ 相比/ ,/ 是/ 可以/ 容忍/ 的/ ./ 因此/ ,/ 影响/ 数据恢复/ 时间/ 的/ 主要/ 因素/ 是/ 读取/ 历史/ 卷/ 以及/ 写/ 数据/ 卷/ 这/ 两/ 部分/ 开销/ ./ 类似/ 的/ ,/ 基本/ 方法/ 和/ WDRS/ 的/ 恢复/ 时间/ 也/ 主要/ 由/ 这/ 两/ 部分/ 组成/ ./ 对于/ 基本/ 方法/ 、/ WDRS/ 和/ RM/ -/ CBDD3/ 种/ 算法/ ,/ 表/ 1/ 列出/ 了/ 在/ 恢复/ 数据/ 时/ 需要/ 读取/ 和/ 写入/ 的/ 数据量/ ./ 恢复/ 方法/ 基本/ 方法/ WDRSRM/ -/ CBDD/ |/ B/ (/ R/ (/ 0/ ,/ c/ ]/ -/ R/ (/ 0/ ,/ t/ ]/ )/ ∪/ B/ (/ R/ (/ 0/ ,/ t/ ]/ -/ R/ (/ 0/ ,/ c/ ]/ )/ |/ RM/ -/ CBDD/ 算法/ 需要/ 从/ 历史数据/ 读取/ 和/ 向/ 数据/ 卷/ 写入/ 的/ 数据/ 块/ 个数/ ,/ 实际上/ 就是/ 当前/ 时刻/ 与/ 恢复/ 目标/ 时刻/ 的/ 数据/ 镜像/ 之间/ 存在/ 差异/ 的/ 数据/ 块/ 个数/ ;/ 基本/ 恢复/ 方法/ 在/ 恢复/ 数据/ 时/ ,/ 首先/ 需要/ 将/ 初始/ 备份/ 数据恢复/ 至/ 数据/ 卷/ 中/ ,/ 然后/ 按照/ 写/ 请求/ 所/ 产生/ 的/ 时间/ 先后顺序/ ,/ 将/ 初始/ 时刻/ 与/ 目标/ 时刻/ 之间/ 的/ 所有/ 写/ 请求/ 依次/ 提交/ 至/ 数据/ 卷/ 中/ ./ 因此/ ,/ 基本/ 恢复/ 方法/ 需要/ 读写/ 的/ 数据/ 块/ 个数/ 为/ 数据/ 卷/ 的/ 数据/ 块/ 个数/ 与/ 目标/ 时刻/ 之前/ 所有/ 写/ 请求/ 个数/ 之/ 和/ ;/ WDRS/ 方法/ 则/ 是/ 按照/ 时间/ 的/ 逆序/ ,/ 通过/ 位表/ 标记/ 已/ 处理/ 的/ 数据/ 块/ ,/ 使得/ Page8/ 数据/ 卷/ 中/ 的/ 所有/ 数据/ 块/ 在/ 恢复/ 时均/ 只/ 被/ 处理/ 一次/ ,/ 因此/ 所/ 需要/ 读写/ 的/ 数据/ 块/ 个数/ 始终保持/ 为/ 数据/ 卷/ 的/ 数据/ 块/ 个数/ ./ 在/ 最差/ 的/ 情况/ 下/ ,/ 当前/ 时刻/ 点/ 与/ 恢复/ 目标/ 时刻/ 点/ 的/ 间隔/ 足够/ 远/ ,/ 使得/ 两/ 时刻/ 点/ 的/ 镜像/ 中/ 所有/ 数据/ 块/ 都/ 存在/ 差异/ ./ 这时/ ,/ RM/ -/ CBDD/ 算法/ 所/ 需要/ 读写/ 的/ 数据/ 块/ 个数/ 达到/ 最大/ ,/ 即/ 数据/ 卷/ 的/ 数据/ 块/ 个数/ ,/ 但/ 仍然/ 不/ 超过/ WDRS/ ./ 通常/ 情况/ 下/ ,/ 恢复/ 起止/ 时刻/ 之间/ 的/ 间隔/ 并/ 不会/ 很/ 远/ ,/ 尤其/ 是/ 在/ 二分/ 探查/ 最佳/ 恢复/ 时刻/ 点时/ ,/ 随着/ 探查/ 次数/ 的/ 不断/ 增加/ ,/ 恢复/ 起止/ 时刻/ 之间/ 的/ 间隔/ 呈/ 指数/ 次/ 幂/ 减小/ ,/ RM/ -/ CBDD/ 算法/ 的/ 所/ 需/ 读写/ 的/ 数据/ 块/ 个数/ 随之/ 锐减/ ./ 4/ 实验/ 评估/ 4.1/ 实验/ 环境/ 为了/ 对/ RM/ -/ CBDD/ 的/ 恢复/ 性能/ 进行/ 评估/ ,/ 我们/ 在/ Windows/ 平台/ 下/ ,/ 利用/ 磁盘/ 过滤/ 驱动/ 技术/ ,/ 在/ 逻辑/ 卷层/ 实现/ 了/ 支持/ 基本/ 方法/ 、/ 临近/ 算法/ 、/ WDRS/ 和/ RM/ -/ CBDD4/ 种/ 恢复/ 算法/ 的/ 块/ 级/ 连续/ 数据保护/ 原型/ 系统/ ./ 原型/ 系统/ 在/ 逻辑/ 卷层/ 截获/ 上层/ 应用/ 的/ 写/ 请求/ ,/ 并/ 在/ 历史数据/ 卷/ 中/ 按照/ 写/ 请求/ 产生/ 的/ 时间/ 先后顺序/ 进行/ 记录/ ./ 为了/ 获得/ 更加/ 客观/ 的/ 实验/ 数据/ ,/ 操作系统/ 、/ 日志/ 卷/ 、/ 数据/ 卷/ 和/ 历史/ 卷/ 都/ 分别/ 绑定/ 不同/ 的/ 硬盘/ ,/ 实验/ 在/ 浪潮/ AS300N/ 存储/ 服务器上进行/ ,/ 具体/ 的/ 实验/ 环境/ 如表/ 2/ 所示/ ./ 部件/ CPUIntelXeon5504/ ×/ 2/ 内存/ DDRIII16GB/ 硬盘/ 操作系统/ Windows2003R2EnterpriseX64Edition/ 实验/ 采用/ 存储/ 性能/ 理事会/ 发布/ 的/ Trace/ 数据/ ,/ 该/ Trace/ 数据/ 采集/ 自某/ 大型/ 金融机构/ 的/ OLTP/ 应用/ ,/ 数据/ 块/ 大小/ 为/ 512/ 字节/ ,/ 平均/ 每分钟/ 提交/ 写/ 请求/ 70000/ 次/ 左右/ ,/ 约/ 34MB/ ,/ 每/ 小时/ 更新/ 数据/ 约/ 2GB/ ./ 根据/ 以下/ 实验/ 的/ 不同/ 要求/ ,/ 按照/ 不同/ 的/ 策略/ 将/ Trace/ 数据/ 通过/ Replay/ 的/ 方式/ 在/ 数据/ 卷上/ 进行/ 重/ 放/ ,/ 然后/ 分别/ 采用/ 基本/ 恢复/ 方法/ 、/ WDRS/ 和/ RM/ -/ CBDD3/ 种/ 算法/ ,/ 按照/ 特定/ 的/ 恢复/ 序列/ 执行/ 恢复/ 操作/ ,/ 同时/ 记录/ 下/ 每次/ 恢复/ 的/ 恢复/ 时间/ ./ 4.2/ 恢复/ 效率/ 比较/ 为了/ 评估/ RM/ -/ CBDD/ 的/ 恢复/ 性能/ ,/ 首先/ 构造/ 实验/ 环境/ ./ 如图/ 5/ 所示/ ,/ 以/ 初始/ 时刻/ 0min/ 为/ 起点/ ,/ 按照/ 每次/ Replay60min/ 数据/ ,/ 紧接着/ 向前/ 恢复/ 30min/ 的/ 策略/ ,/ 重复/ 5/ 次后/ 形成/ 了/ 4/ 个/ 间隙/ ,/ 间隙/ 将/ 整个/ 时间轴/ 划分/ 为/ [/ 240/ +/ ,/ 300/ ]/ 、/ [/ 180/ +/ ,/ 240/ ]/ 、/ [/ 120/ +/ ,/ 180/ ]/ 、/ [/ 60/ +/ ,/ 120/ ]/ 和/ [/ 0/ ,/ 60/ ]/ 5/ 个/ 时间/ 区间/ ,/ 数据/ 卷/ 的/ 最终/ 状态/ 所/ 对应/ 的/ 时刻/ 为/ 270min/ ./ 在/ 该/ 实验/ 环境/ 下/ ,/ 分别/ 采用/ 基本/ 方法/ 、/ 临近/ 算法/ 、/ WDRS/ 和/ RM/ -/ CBDD4/ 种/ 算法/ ,/ 以/ 270min/ 作为/ 恢复/ 的/ 起始/ 时刻/ ,/ 时间/ 区间/ [/ 240/ +/ ,/ 300/ ]/ 、/ [/ 180/ +/ ,/ 240/ ]/ 、/ [/ 120/ +/ ,/ 180/ ]/ 、/ [/ 60/ +/ ,/ 120/ ]/ 、/ [/ 0/ ,/ 60/ ]/ 上以/ 5min/ 为/ 间隔/ 的/ 65/ 个/ 时刻/ 点为/ 目标/ 时刻/ (/ 以/ 时间/ 区间/ [/ 240/ +/ ,/ 300/ ]/ 为例/ ,/ 有/ 240/ +/ ,/ 245/ ,/ 250/ ,/ …/ ,/ 300/ 共计/ 13/ 个/ 目标/ 时刻/ )/ ,/ 分别/ 执行/ 恢复/ 操作/ (/ 每次/ 恢复/ 操作前/ ,/ 都/ 需要/ 将/ 数据/ 卷/ 恢复/ 至/ 时刻/ 270min/ 所/ 对应/ 的/ 状态/ )/ ,/ 记录/ 下/ 每次/ 恢复/ 操作/ 的/ 恢复/ 时间/ ,/ 结果/ 如图/ 6/ 所示/ ,/ 其中/ (/ a/ )/ 、/ (/ b/ )/ 、/ (/ c/ )/ 、/ (/ d/ )/ 、/ (/ e/ )/ 依次/ 对应/ 于/ 以上/ 5/ 个/ 时间/ 区间/ ./ 特殊/ 的/ ,/ 临近/ 算法/ 最/ 多/ 支持/ 一个/ 间隙/ ,/ 但/ 其/ 所/ 关注/ 的/ 是/ 恢复/ 起始/ 时刻/ 和/ 目标/ 时刻/ 之间/ 差异/ 数据/ 内/ 的/ 间隙/ ,/ 虽然/ 历史数据/ 中共/ 存在/ 四个/ 间隙/ ,/ 但/ 由于/ 恢复/ 起始/ 时刻/ 270min/ ,/ 与/ 时间/ 区间/ [/ 240/ +/ ,/ 300/ ]/ 和/ [/ 180/ +/ ,/ 240/ ]/ 上/ 的/ 恢复/ 目标/ 时刻/ 之间/ ,/ 最/ 多只/ 存在/ 一个/ 间隙/ ,/ 因此/ 临近/ 算法/ 在/ 这/ 两个/ 时间/ 区间/ 上/ 依然/ 适用/ ./ 从/ 结果/ 中/ 可以/ 看出/ ,/ 不论/ 哪/ 一个/ 时间/ 区间/ ,/ RM/ -/ CBDD/ 算法/ 的/ 恢复/ 效率/ 最高/ ,/ 恢复/ 时间/ 均/ 远/ 低于/ 基本/ 恢复/ 方法/ 和/ WDRS/ ./ 与/ RM/ -/ CBDD/ 方法/ 相比/ ,/ WDRS/ 的/ 恢复/ 时间/ 最高/ 为/ RM/ -/ CBDD/ 的/ 12.7/ 倍/ ,/ 平均/ 1.83/ 倍/ ;/ 基本/ 方法/ 则/ 差距/ 更大/ ,/ 最差/ 时/ 恢复/ 时间/ 为/ RM/ -/ CBDD/ 的/ 66.4/ 倍/ ,/ 平均/ 6.5/ 倍/ ./ RM/ -/ CBDD/ 算法/ 在/ 恢复/ 数据/ 时/ ,/ 通过/ 分析/ 当前/ 时刻/ 与/ 目标/ 时刻/ 数据/ 卷/ 之间/ 的/ 数据/ 差异/ ,/ 分别/ 对/ “/ 少/ 数据/ ”/ 和/ “/ 多/ 数据/ ”/ 两种/ 类型/ 的/ 差异/ 数据/ 进行/ 处理/ ,/ 消/ Page9/ 图/ 64/ 种/ 算法/ 的/ 恢复/ 效率/ 比较/ 除/ 恢复/ 起止/ 时刻/ 之间/ 的/ 数据/ 差异/ 达到/ 恢复/ 数据/ 的/ 目的/ ./ 因此/ ,/ 恢复/ 起始/ 时刻/ 与/ 目标/ 时刻/ 之间/ 写/ 请求/ 的/ 多少/ ,/ 直接/ 关系/ 到/ 差异/ 数据/ 的/ 多少/ ,/ 进而/ 影响/ 到/ 恢复/ 时间/ ./ 从图/ 6/ 中/ 可以/ 看出/ ,/ 从/ [/ 240/ +/ ,/ 300/ ]/ 至/ [/ 0/ ,/ 60/ ]/ 的/ 5/ 个/ 时间/ 区间/ ,/ 恢复/ 起始/ 时刻/ 与/ 目标/ 时刻/ 之间/ 的/ 时间跨度/ 依次/ 增大/ ,/ 导致/ 差异/ 数据/ 的/ 增加/ ,/ 进而/ 使得/ 恢复/ 时间/ 增加/ ./ 其中/ ,/ 时间/ 区间/ [/ 240/ +/ ,/ 300/ ]/ 中/ 目标/ 时刻/ 点/ 265min/ 和/ 275min/ 与/ 恢复/ 起始/ 时刻/ 时间跨度/ 最小/ ,/ 恢复/ 时间/ 也/ 最小/ ;/ 而/ 时间/ 区间/ [/ 0/ ,/ 60/ ]/ 中/ 的/ 目标/ 时刻/ 0min/ 和/ 60min/ 则/ 时间跨度/ 最大/ ,/ 恢复/ 时间/ 也/ 最大/ ./ 特殊/ 的/ ,/ 由于/ 临近/ 算法/ 与/ RM/ -/ CBDD/ 都/ 是/ 通过/ 分析/ 处理/ 差异/ 数据/ 进行/ 恢复/ ,/ 所以/ ,/ 在/ 恢复/ 目标/ 时刻/ 在/ 时间/ 区间/ [/ 240/ +/ ,/ 300/ ]/ 和/ [/ 180/ +/ ,/ 240/ ]/ 上时/ ,/ 两种/ 方法/ 的/ 恢复/ 时间/ 几乎/ 相同/ ,/ 曲线/ 则/ 近似/ 重合/ ./ WDRS/ 在/ 恢复/ 数据/ 时/ ,/ 并/ 不/ 关注/ 当前/ 时刻/ 数据/ 卷/ 的/ 状态/ ,/ 通过/ 位表/ 标记/ 已/ 处理/ 的/ 数据/ 块/ ,/ 使得/ 数据/ 卷/ 中/ 的/ 所有/ 数据/ 块/ 在/ 恢复/ 时均/ 只/ 处理/ 一次/ ./ 因此/ ,/ 在/ 图/ 6/ 中/ 可以/ 看出/ ,/ 不论/ 哪/ 一时间/ 区间/ ,/ WDRS/ 每次/ 恢复/ 的/ 恢复/ 时间/ 都/ 保持/ 在/ 40s/ 上下/ ,/ 曲线/ 近似/ 水平/ ./ 而/ 对于/ 基本/ 方法/ ,/ 在/ 恢复/ 数据/ 时/ 不仅/ 需要/ 首先/ 将/ 初始/ 镜像/ 恢复/ 至/ 数据/ 卷/ ,/ 然后/ 还要/ 按照/ 先后顺序/ 对/ 初始/ 时刻/ 至/ 目标/ 时刻/ 的/ 写/ 请求/ 依次/ 执行/ Redo/ 操作/ ,/ 因此/ ,/ 目标/ 时刻/ 距/ 初始/ 时刻/ 越/ 远/ ,/ 需要/ 执行/ Redo/ 操作/ 的/ 写/ 请求/ 越/ 多/ ,/ 恢复/ 时间/ 越长/ ./ 从/ 结果/ 中/ 可以/ 看出/ ,/ 图/ 6/ (/ a/ )/ 中/ 时间/ 区间/ [/ 240/ +/ ,/ 300/ ]/ 与/ 初始/ 时刻/ 0min/ 的/ 时间跨度/ 最大/ ,/ 恢复/ 时间/ 大多/ 在/ 200s/ 以上/ ;/ Page10/ 而图/ 6/ (/ e/ )/ 中/ 时间/ 区间/ [/ 0/ ,/ 60/ ]/ 与/ 初始/ 时刻/ 0min/ 的/ 时间跨度/ 最小/ ,/ 恢复/ 时间/ 最高/ 未/ 超过/ 110s/ ./ 特殊/ 的/ ,/ 恢复/ 至/ 目标/ 时刻/ 0min/ ,/ 只/ 需要/ 恢复/ 初始/ 镜像/ 即可/ ,/ 然而/ 此时/ 恢复/ 起止/ 时刻/ 之间/ 的/ 间隔/ 最大/ ,/ RM/ -/ CBDD/ 所需/ 处理/ 的/ 差异/ 数据量/ 最/ 多/ ,/ 所以/ 此时/ 基本/ 方法/ 的/ 恢复/ 效率/ 略/ 好/ 于/ RM/ -/ CBDD/ ./ 4.3/ 间隙/ 对/ 恢复/ 效率/ 的/ 影响/ 为了/ 分析/ 间隙/ 对/ 恢复/ 效率/ 的/ 影响/ ,/ 首先/ 构造/ 实验/ 环境/ ./ 如图/ 7/ 所示/ ,/ 以/ 初始/ 时刻/ 0min/ 为/ 起点/ ,/ 首先/ Replay80min/ 数据/ ,/ 再/ 向前/ 恢复/ 40min/ ;/ 然后/ Replay40min/ 数据/ ,/ 向前/ 恢复/ 20min/ ,/ 依次/ 类推/ ,/ Replay/ 至/ 155min/ 时/ 结束/ ./ 为了/ 排除/ 数据分布/ 对/ 实验/ 结果/ 的/ 影响/ ,/ 在/ Replay/ 数据/ 时/ ,/ 对/ 时间/ 区间/ [/ 40/ ,/ 80/ ]/ 与/ [/ 80/ +/ ,/ 120/ ]/ 、/ [/ 100/ ,/ 120/ ]/ 与/ [/ 120/ +/ ,/ 140/ ]/ 、/ [/ 130/ ,/ 140/ ]/ 与/ [/ 140/ +/ ,/ 150/ ]/ 、/ [/ 145/ ,/ 150/ ]/ 与/ [/ 150/ +/ ,/ 155/ ]/ ,/ 两/ 两重/ 放/ 相同/ 的/ 数据/ ./ 在/ 该/ 实验/ 环境/ 下/ ,/ 分别/ 采用/ 基本/ 方法/ 、/ WDRS/ 和/ RM/ -/ CBDD3/ 种/ 算法/ ,/ 以/ 155min/ 作为/ 恢复/ 的/ 起始/ 时刻/ ,/ 时间/ 区间/ [/ 0/ ,/ 40/ ]/ 上以/ 5min/ 为/ 间隔/ 的/ 9/ 个/ 时刻/ 点为/ 目标/ 时刻/ ,/ 执行/ 恢复/ 操作/ (/ 每次/ 恢复/ 操作前/ ,/ 都/ 需要/ 将/ 数据/ 卷/ 恢复/ 至/ 恢复/ 起始/ 时刻/ 155min/ 所/ 对应/ 的/ 状态/ )/ ,/ 分别/ 记录/ 下/ 每次/ 恢复/ 操作/ 的/ 恢复/ 时间/ ./ 类似/ 的/ ,/ 再/ 分别/ 以/ 150min/ 、/ 140min/ 、/ 120min/ 和/ 80min/ 作为/ 恢复/ 的/ 起始/ 时刻/ ,/ 执行/ 上述/ 恢复/ 操作/ 并/ 记录/ 恢复/ 时间/ ./ 从图/ 7/ 中/ 可以/ 看出/ ,/ 以/ 155min/ 作为/ 恢复/ 起始/ 时刻/ ,/ 它/ 与/ 初始/ 时刻/ 0min/ 之间/ 存在/ 4/ 个/ 间隙/ ,/ 因此/ 每次/ 恢复/ 都/ 经历/ 了/ 4/ 个/ 间隙/ ;/ 依次/ 类推/ ,/ 以/ 150min/ 、/ 140min/ 、/ 120min/ 和/ 80min/ 作为/ 恢复/ 起始/ 时刻/ 的/ 恢复/ ,/ 则/ 依次/ 经历/ 了/ 3/ 个/ 、/ 2/ 个/ 、/ 1/ 个/ 和/ 0/ 个/ 间隙/ ./ 因为/ 不同/ 的/ 数据分布/ 会/ 对/ 恢复/ 起止/ 时刻/ 对应/ 镜像/ 之间/ 的/ 数据/ 差异/ 产生/ 影响/ ,/ 所以/ 为了/ 观察/ 不同/ 间隙/ 个数/ 对/ 恢复/ 效率/ 的/ 影响/ ,/ 在/ 以上/ 构建/ 实验/ 环境/ 的/ 过程/ 中/ ,/ 对/ Replay/ 数据/ 进行/ 了/ 特殊/ 处理/ ./ 这样/ ,/ 即便/ 恢复/ 起始/ 时刻/ 不同/ ,/ 但/ 对于/ 相同/ 的/ 目标/ 时刻/ ,/ 恢复/ 过程/ 中/ 所/ 处理/ 的/ 数据/ 都/ 是/ 相同/ 的/ ,/ 进而/ 可以/ 更好/ 地/ 观察/ 间隙/ 个数/ 对/ 恢复/ 效率/ 的/ 影响/ ./ 实验/ 结果/ 如图/ 8/ 所示/ ./ 根据/ 间隙/ 个数/ 的/ 不同/ ,/ 基本/ 方法/ 、/ WDRS/ 和/ RM/ -/ CBDD3/ 种/ 恢复/ 算法/ 在/ 图/ 8/ 中/ 都/ 分别/ 有/ 5/ 条/ 曲线/ 与/ 之/ 对应/ ./ 从图/ 中/ 可以/ 明显/ 看出/ ,/ 每种/ 恢复/ 算法/ 的/ 5/ 条/ 曲线/ 都/ 近似/ 重合/ ,/ 由于/ 排除/ 了/ 数据分布/ 可能/ 对/ 实验/ 结果/ 造成/ 的/ 影响/ ,/ 可见/ 间隙/ 的/ 个数/ 对/ 恢复/ 效率/ 并/ 没有/ 显著/ 影响/ ./ RM/ -/ CBDD/ 算法/ 的/ 恢复/ 过程/ 也/ 印证/ 了/ 这/ 一点/ :/ 通过/ 读取/ 恢复/ 映射/ 序列/ 等/ 元/ 数据/ ,/ 在/ 内存/ 中/ 进行/ 一定/ 的/ 运算/ 后/ ,/ 便/ 得到/ 了/ 写/ 请求/ 集合/ ,/ 即/ 消除/ 了/ 间隙/ 的/ 影响/ ,/ 并且/ 与/ 需要/ 消除/ 的/ 差异/ 数据/ 相比/ ,/ 读取/ 元/ 数据/ 和/ 内存/ 操作/ 所/ 消耗/ 的/ 时间/ 则/ 要/ 少/ 得/ 多/ ,/ 表现/ 在/ 整个/ 恢复/ 时间/ 中/ 就/ 不/ 明显/ 了/ ./ 4.4/ 寻找/ 最优/ 恢复/ 时刻/ 点/ 一旦/ 系统管理员/ 发现/ 数据/ 发生/ 了/ 损坏/ ,/ 就/ 需要/ 寻找/ 并/ 确定/ 一个/ 能够/ 获得/ 干净/ 数据/ 的/ 恢复/ 时刻/ 点/ ./ 通常/ ,/ 系统管理员/ 在/ 选择/ 恢复/ 时刻/ 点时/ ,/ 需要/ 在/ 恢复/ 时间/ (/ 进行/ 一致性/ 检测/ 的/ 数据/ 版本/ 的/ 个数/ )/ 和/ 数据/ 损失量/ 之间/ 进行/ 权衡/ ./ 由于/ 肩负着/ 尽快恢复/ 数据/ 的/ 使命/ ,/ 对于/ 系统管理员/ ,/ 可/ 恢复/ 时刻/ 点/ 的/ 识别/ 通常/ 是/ 一个/ 手工/ 的/ 、/ 易错/ 的/ 、/ 耗时/ 繁琐/ 的/ 过程/ ./ 虽然/ 连续/ 数据保护/ 系统/ 提供/ 了/ 以/ 写/ 请求/ 为/ 精度/ 向前/ 恢复/ 的/ 能力/ ,/ 但/ 仍旧/ 无法/ 解决/ 识别/ 恢复/ 时刻/ 点/ 所/ 面临/ 的/ 矛盾/ ./ 只有/ 在/ 恢复/ 时刻/ 点/ 确定/ 之后/ ,/ 才能/ 用/ 一致/ 的/ 干净/ 数据/ 替换/ 损坏/ 的/ 数据/ ,/ 整个/ 恢复/ 过程/ 才/ 得以/ 完成/ ./ 通常/ ,/ 在/ 寻找/ 恢复/ 时刻/ 点时/ ,/ 系统管理员/ 会/ 在/ 连续/ 数据保护/ 的/ 初始/ 时刻/ 与/ 发生/ 数据/ 损坏/ 的/ 时刻/ 之间/ 进行/ 二分/ 探查/ ,/ 对于/ 每/ 一个/ 二分/ 探查/ 的/ 时刻/ 点/ ,/ 都/ 需要/ 通过/ 完整性/ 检测工具/ 对/ 该/ 时刻/ 点/ 的/ 数据/ 镜像/ 进行/ 检测/ ,/ 以/ 判断/ 下/ 一个/ 探查/ 时刻/ 点/ ,/ 在/ 找到/ 满足/ RPO/ 的/ 时刻/ 点时/ 完成/ 探查/ ./ 为了/ 评估/ RM/ -/ CBDD/ 在/ 可/ 恢复/ 时刻/ 点/ 识别/ 中/ 的/ 效率/ ,/ 我们/ 重新/ 根据/ 图/ 5/ 构造/ 了/ 实验/ 环境/ ,/ 然后/ 分别/ 采用/ 基本/ 方法/ 、/ WDRS/ 和/ RM/ -/ CBDD3/ 种/ 恢复/ 算法/ ,/ 以/ 300min/ 作为/ 恢复/ 的/ 起始/ 时刻/ ,/ 在/ 5/ 个/ 连续/ 的/ Page11/ 时间/ 区间/ [/ 0/ ,/ 300/ ]/ 、/ [/ 0/ ,/ 200/ ]/ 、/ [/ 0/ ,/ 100/ ]/ 、/ [/ 0/ ,/ 50/ ]/ 和/ [/ 0/ ,/ 25/ ]/ 上/ ,/ 通过/ 二分/ 探查/ 的/ 方式/ 分别/ 对/ 可/ 恢复/ 时刻/ 点/ 进行/ 探查/ ./ 与/ 4.2/ 节中/ 的/ 实验/ 不同/ ,/ 在/ 同一时间/ 区间/ 内/ 的/ 每次/ 探查/ 之前/ ,/ 数据/ 卷/ 保持/ 上次/ 探查/ 结束/ 的/ 状态/ 即可/ ,/ 只/ 在/ 对/ 下/ 一个/ 时间/ 区间/ 开始/ 探查/ 之前/ ,/ 才/ 需要/ 将/ 数据/ 卷/ 恢复/ 至/ 起始/ 时刻/ 300min/ 所/ 对应/ 的/ 状态/ ./ 实验/ 中/ 并/ 没有/ 采用/ 真实/ 的/ 完整性/ 检测工具/ ,/ 因此/ ,/ 对于/ 以上/ 5/ 个/ 探查/ 区间/ ,/ 每次/ 二分/ 探查/ 之后/ 的/ 下/ 一个/ 探查/ 时刻/ 点/ ,/ 分别/ 采用/ 一直/ 向前/ 探查/ 、/ 一直/ 向/ 后/ 探查/ 和/ 前后/ 交替/ 探查/ 3/ 种/ 方式/ 进行/ 模拟/ ./ 此外/ ,/ 实验/ 中/ 所/ 找到/ 的/ 恢复/ 时刻/ 点/ ,/ 要求/ 与/ 最佳/ 恢复/ 时刻/ 点/ 之间/ 的/ 时间/ 间隔/ 不/ 超过/ 1min/ ,/ 在/ 对/ 每个/ 时间/ 区间/ 的/ 二分/ 探查/ 过程/ 结束/ 后/ ,/ 数据/ 卷/ 的/ 状态/ 即/ 为/ 所/ 找到/ 的/ 恢复/ 时刻/ 点/ 所/ 对应/ 的/ 状态/ ,/ 探查/ 恢复/ 过程/ 结束/ ./ 实验/ 中/ 记录/ 下/ 探查/ 每个/ 时间/ 区间/ 所/ 花费/ 的/ 总/ 恢复/ 时间/ (/ 不/ 包含/ 对/ 各/ 探查/ 时刻/ 对应/ 数据/ 镜像/ 进行/ 完整性检查/ 的/ 时间/ )/ ,/ 结果/ 如图/ 9/ 所示/ ./ 如图/ 9/ 所示/ ,/ 不论/ 向前/ 探查/ 、/ 向/ 后/ 探查/ ,/ 还是/ 前后/ 交替/ 探查/ ,/ RM/ -/ CBDD/ 所/ 消耗/ 的/ 总/ 恢复/ 时间/ 都/ 远远/ 小于/ 其他/ 两种/ 算法/ ./ 其中/ ,/ 探查/ 8/ 次/ 的/ 平均/ 总/ 恢复/ 时间/ 为/ 78.03/ s/ ,/ 探查/ 6/ 次/ 的/ 平均/ 总/ 恢复/ 时间/ 仅为/ 33.15/ s/ ,/ WDRS/ 所/ 消耗/ 时间/ 分别/ 是/ RM/ -/ CBDD/ 的/ 4.32/ 倍/ 和/ 7.56/ 倍/ ,/ 基本/ 方法/ 分别/ 是/ 13.47/ 倍/ 和/ 13.48/ 倍/ ./ 由于/ WDRS/ 的/ 恢复/ 时间/ 非常/ 稳定/ ,/ 每次/ 恢复/ 所/ 消耗/ 时间/ 均/ 在/ 40s/ 上下/ ./ 因此/ ,/ 如图/ 9/ 所示/ ,/ 不论/ 向前/ 、/ 向/ 后/ 还是/ 前后/ 交替/ 探查/ ,/ WDRS/ 的/ 总/ 恢复/ 时间/ 根据/ 探查/ 次数/ 的/ 不同/ 而/ 随之/ 增减/ ,/ 与/ 每次/ 恢复/ 起止/ 时刻/ 之间/ 的/ 数据量/ 以及/ 初始/ 时刻/ 与/ 目标/ 时刻/ 之间/ 的/ 时间/ 间隔/ 均/ 无关/ ./ 对于/ 基本/ 恢复/ 方法/ ,/ 在/ 向前/ 探查/ 时/ ,/ 时间/ 区间/ [/ 0/ ,/ 300/ ]/ 的/ 总/ 恢复/ 时间/ 为/ 482s/ ,/ 而/ 向/ 后/ 探查/ 竟高达/ 2184s/ ,/ 前后/ 交替/ 探查/ 则/ 以/ 1426s/ 介于/ 两者之间/ ./ 这/ 是因为/ ,/ 随着/ 探查/ 次数/ 的/ 不断/ 增加/ ,/ 向前/ 探查/ 使得/ 探查/ 的/ 时刻/ 点/ 不断/ 向前/ 移动/ ,/ 与/ 初始/ 时刻/ 0min/ 的/ 间隔/ 不断/ 减小/ ;/ 而/ 向/ 后/ 恢复/ 则/ 恰恰相反/ ,/ 每次/ 探查/ 的/ 时刻/ 点/ 不断/ 向/ 后/ 移动/ ,/ 与/ 初始/ 时刻/ 0min/ 的/ 间隔/ 不断/ 增大/ ;/ 由于/ 基本/ 方法/ 的/ 恢复/ 时间/ 是/ 由/ 恢复/ 初始/ 镜像/ 和/ 执行/ Redo/ 操作/ 两/ 部分/ 组成/ 的/ ,/ 向前/ 探查/ 使得/ 每次/ 需要/ Redo/ 的/ 写/ 请求/ 不断/ 减少/ ,/ 而/ 向/ 后/ 探查/ 则/ 不断/ 增多/ ,/ 前后/ 交替/ 探查/ 介于/ 两者之间/ ;/ 由此/ 形成/ 了/ 图/ 9/ 所示/ 的/ 结果/ ./ 与/ 基本/ 方法/ 不同/ ,/ 探查/ 方向/ 的/ 变化/ 并/ 不会/ 对/ RM/ -/ CBDD/ 的/ 恢复/ 时间/ 造成/ 明显/ 影响/ ./ 根据/ 二分/ 查找/ 的/ 性质/ ,/ 随着/ 探查/ 次数/ 的/ 不断/ 增加/ ,/ 相邻/ 两次/ 探查/ 时刻/ 点/ 之间/ 的/ 时间/ 间隔/ 呈/ 指数/ 次/ 幂/ 不断/ 减小/ ,/ 两/ 时刻/ 点/ 之间/ 的/ 历史/ 写/ 请求/ 随之/ 骤减/ ,/ 使得/ RM/ -/ CBDD/ 所/ 需要/ 处理/ 的/ 差异/ 数据/ 骤减/ ,/ 进而/ 恢复/ 时间/ 骤减/ ,/ 效率/ 提高/ 非常明显/ ./ 实验/ 中/ ,/ RM/ -/ CBDD/ 在/ 时间/ 区间/ [/ 0/ ,/ 300/ ]/ 上/ 进行/ 了/ 9/ 次/ 探查/ 之后/ ,/ 找到/ 了/ 与/ 最佳/ 恢复/ 时刻/ 点/ 之间/ 间隔/ 小于/ 1min/ 的/ 恢复/ 时刻/ 点/ ,/ 其中/ 每次/ 探查/ 所/ 消耗/ 的/ 恢复/ 时间/ 如图/ 10/ 所示/ ./ 可以/ 明显/ 看出/ ,/ 随着/ 探查/ 次数/ 的/ 增加/ ,/ 恢复/ 时间/ 随之/ 骤减/ ,/ 并且/ 在/ 第/ 8/ 次/ 探查/ 时/ 已经/ 低于/ 1s/ ./ 注意/ 到/ ,/ 构建/ 实验/ 环境/ 所/ Replay/ 的/ 数据/ ,/ 平均/ 每分钟/ 产生/ 70000/ 个/ 写/ 请求/ ,/ 如果/ 要/ 寻找/ 到/ 最佳/ 恢复/ 点/ ,/ 只/ 需要/ 继续/ 进行/ 不/ 超过/ 17/ 次/ 的/ Page12/ 探查/ ,/ 消耗/ 不/ 超过/ 17s/ 的/ 时间/ ./ 而/ 如果/ 采用/ WDRS/ 或者/ 基本/ 方法/ 继续/ 寻找/ 最佳/ 恢复/ 时刻/ 点/ ,/ 所/ 消耗/ 的/ 时间/ 则/ 是/ 不可/ 忍受/ 的/ ./ 图/ 10RM/ -/ CBDD/ 在/ 时间/ 区间/ [/ 0/ ,/ 300/ ]/ 上/ 每次/ 5/ 总结/ 以/ 在/ 元/ 数据/ 中/ 增加/ 恢复/ 映射/ 序列/ 以及/ 在/ 历史/ 写/ 请求/ 中/ 插入/ 快照/ 为/ 基础/ ,/ RM/ -/ CBDD/ 算法/ 采用/ 递归/ 算法/ 获取/ 恢复/ 起止/ 时刻/ 基于/ 参照/ 时刻/ 的/ 两个/ 写/ 请求/ 集合/ ,/ 然后/ 通过/ 对/ 两个/ 写/ 请求/ 集合/ 的/ 分析/ 处理/ ,/ 找出/ 了/ 恢复/ 起止/ 时刻/ 之间/ 两种/ 类型/ 的/ 差异/ 数据/ ,/ 即/ “/ 少/ 数据/ ”/ 和/ “/ 多/ 数据/ ”/ ,/ 最后/ 针对/ 两种/ 类型/ 差异/ 数据/ 的/ 特点/ 分别/ 进行/ 了/ 处理/ ,/ 消除/ 了/ 恢复/ 起止/ 时刻/ 之间/ 的/ 数据/ 差异/ ,/ 实现/ 了/ 数据恢复/ ./ 通过/ 对/ “/ 临近/ 算法/ ”/ 的/ 完善/ 与/ 改进/ ,/ RM/ -/ CBDD/ 不仅/ 支持/ 存在/ 多/ 间隙/ 的/ 复杂/ 实际/ 应用环境/ ,/ 并且/ 继承/ 了/ “/ 临近/ 算法/ ”/ 的/ 高/ 恢复/ 效率/ ./ 实验/ 数据/ 表明/ ,/ 在/ 多/ 间隙/ 复杂/ 情况/ 下/ ,/ RM/ -/ CBDD/ 的/ 恢复/ 效率/ 明显/ 高于/ 基本/ 方法/ 和/ WDRS/ ,/ 有效/ 降低/ 了/ 二分/ 探查/ 最佳/ 恢复/ 时刻/ 点/ 的/ 时间/ 开销/ ./ 

