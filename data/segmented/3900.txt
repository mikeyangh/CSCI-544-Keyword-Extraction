Page1/ 基于/ 替换/ 概率/ 的/ 闪存/ 数据库/ 缓冲区/ 替换算法/ 林子/ 雨赖/ 明星/ 邹权/ 薛/ 永生/ 杨思颖/ (/ 厦门大学/ 计算机科学/ 系/ 福建厦门/ 361005/ )/ 摘要/ 闪存/ 具有/ 和/ 传统/ 磁盘/ 不同/ 的/ 特性/ ,/ 包括/ 写前/ 擦除/ 、/ 异地/ 更新/ 、/ 读写/ 延迟/ 非对称/ 等/ ./ 传统/ 的/ 面向/ 磁盘/ 的/ 缓冲区/ 替换算法/ 无法/ 在/ 闪存/ 数据库系统/ 中/ 获得/ 较/ 好/ 的/ 性能/ ./ 文中/ 提出/ 了/ 一种/ 新/ 的/ 面向/ 闪存/ 数据库/ 的/ 缓冲区/ 替换算法/ —/ —/ —/ APB/ -/ LRU/ ,/ 其/ 特点/ :/ (/ 1/ )/ 该/ 算法/ 将/ 缓冲区/ 分为/ 冷区/ 和/ 热区/ ,/ 用来/ 捕获/ 数据/ 访问/ 频度/ ,/ 前者/ 用于/ 存放/ 只/ 访问/ 过/ 一次/ 的/ 数据/ 页/ ,/ 后者/ 用于/ 存放/ 至少/ 访问/ 过/ 两次/ 的/ 数据/ 页/ ;/ (/ 2/ )/ 采用/ 了/ 其它/ 研究所/ 没有/ 的/ 概率/ 替换/ 机制/ ,/ 即以/ 较大/ 的/ 概率/ 替换/ 冷区/ 中/ 的/ 干净/ 页/ ,/ 以较/ 小/ 的/ 概率/ 替换/ 冷区/ 中/ 的/ 脏页/ ,/ 从而/ 避免/ 了/ 冷脏页/ 长期/ 驻留/ 缓冲区/ 的/ 情况/ ,/ 提高/ 了/ 命中率/ ,/ 获得/ 了/ 较/ 好/ 的/ 整体/ 性能/ ;/ (/ 3/ )/ 设计/ 了/ 冷/ 、/ 热区/ 比例/ 动态变化/ 机制/ ,/ 可以/ 根据/ 工作/ 负载/ 的/ 变化/ 动态/ 调整/ 冷/ 、/ 热区/ 所/ 占/ 缓冲区/ 的/ 比例/ ,/ 从而/ 使得/ 替换算法/ 在/ 不同/ 的/ 负载/ 模式/ 下/ 都/ 可以/ 取得/ 较/ 好/ 的/ 性能/ ./ 基于/ 不同/ 测试数据/ 集/ 的/ 大量/ 实验/ 结果表明/ ,/ APB/ -/ LRU/ 算法/ 具有/ 比/ 其它/ 已有/ 的/ 算法/ 更好/ 的/ 性能/ ./ 关键词/ 闪存/ ;/ 数据库/ ;/ 缓冲区/ 替换算法/ ;/ 概率/ 1/ 引言/ 闪存/ 是/ 一种/ 典型/ 的/ 电/ 可/ 擦除/ 可编程/ 只/ 读存储器/ (/ ElectricallyErasableProgrammableReadOnlyMemory/ ,/ EEPROM/ )/ ,/ 属于/ 非易/ 失性/ 存储/ ,/ 断电/ 后/ 数据/ 也/ 不会/ 丢失/ ./ 基于/ 闪存/ 的/ 存储设备/ ,/ 具有/ 速度/ 快/ 、/ 延迟/ 小/ 、/ 能耗/ 低/ 、/ 体积小/ 和/ 可/ 抗震/ 等/ 优良/ 特性/ ,/ 已经/ 广泛/ 地/ 应用/ 于/ 数码相机/ 、/ 移动电话/ 、/ 笔记本/ 等/ 消费类/ 电子设备/ 和/ 企业/ 数据/ 存储/ 产品/ 中/ [/ 1/ ]/ ./ 随着/ 闪存/ 的/ 容量/ 的/ 增加/ 和/ 价格/ 的/ 降低/ ,/ 闪存/ 相对/ 于/ 磁盘/ 的/ 竞争/ 优势/ 变得/ 更加/ 明显/ ,/ 已经/ 大量/ 应用/ 于/ 企业/ 级别/ 的/ 数据/ 存储系统/ 中/ ,/ 比如/ 许多/ 企业/ 的/ 数据库系统/ 已经/ 开始/ 使用/ 闪存/ 固态/ 盘来/ 替换/ 磁盘/ 作为/ 底层/ 的/ 存储介质/ ./ 闪存/ 比/ 磁盘/ 具有/ 更/ 高/ 的/ 读写/ 速度/ ,/ 因此/ 闪存/ 数据库系统/ 可以/ 比/ 基于/ 磁盘/ 的/ 数据库系统/ 获得/ 更好/ 的/ 性能/ ./ 但是/ ,/ 传统/ 的/ 数据库系统/ 中/ 的/ 各类/ 数据结构/ 和/ 算法/ (/ 比如/ 索引/ 和/ 缓冲区/ 替换算法/ )/ ,/ 都/ 是/ 专门/ 针对/ 磁盘/ 开发/ 的/ ,/ 没有/ 考虑/ 闪存/ 的/ 自身/ 特性/ ,/ 因此/ 无法/ 充分发挥/ 闪存/ 的/ 独有/ 特性/ 来/ 最大/ 程度/ 地/ 提升/ 数据库/ 的/ 整体/ 性能/ ,/ 甚至/ 在/ 某些/ 特殊/ 的/ 负载/ 下/ ,/ 会/ 表现/ 出比/ 基于/ 磁盘/ 的/ 数据库/ 更差/ 的/ 性能/ ./ 因此/ ,/ 必须/ 重新/ 设计/ 针对/ 闪存/ 数据库/ 的/ 数据结构/ 和/ 算法/ ./ 目前/ ,/ 在/ 这个/ 方面/ 已经/ 存在/ 大量/ 相关/ 的/ 研究/ 工作/ [/ 2/ -/ 5/ ]/ ,/ 其中/ 一个/ 比较/ 热门/ 的/ 研究/ 问题/ 就是/ 设计/ 面向/ 闪存/ 数据库系统/ 的/ 缓冲区/ 替换算法/ ./ 缓冲区/ 替换算法/ ,/ 可以/ 优化/ I/ // O/ 序列/ ,/ 减少/ 磁盘/ 的/ 访问/ 次数/ ,/ 从而/ 提高/ 存储系统/ 的/ 整体/ 效率/ ./ 但是/ ,/ 已有/ 的/ 面向/ 磁盘/ 的/ 缓冲区/ 替换算法/ [/ 6/ -/ 8/ ]/ 通常/ 假设/ 底层/ 的/ 存储设备/ 具有/ 相同/ 的/ 读写操作/ 延迟/ ,/ 在/ 设计/ 算法/ 时/ ,/ 只是/ 简单/ 地以/ 最大化/ 命中率/ 为/ 目标/ ,/ 从而/ 达到/ 减少/ 磁盘/ 读写操作/ 次数/ 的/ 目的/ ./ 但是/ ,/ 这种/ 读写/ 延迟/ 一致性/ 的/ 假设/ 在/ 闪存/ 中是/ 不/ 成立/ 的/ ,/ 闪存/ 的/ 读/ 操作速度/ 要/ 比/ 写/ 操作速度/ 快/ 一个/ 数量级/ ./ 缓冲区/ 替换算法/ 必须/ 对/ 写/ 操作/ 和/ 读/ 操作/ 进行/ 区分/ ,/ 才能/ 获得/ 更好/ 的/ 性能/ ./ 例如/ ,/ 在/ 缓存/ 中/ 保留/ 一个/ 写/ 操作/ 比较/ 集中/ 的/ 脏页/ 所能/ 带来/ 的/ 收益/ ,/ 要/ 比/ 保留/ 一个/ 读/ 操作/ 集中/ 的/ 干净/ 页/ 的/ 收益/ 大/ ./ 而/ 在/ 传统/ 的/ 替换算法/ 中/ ,/ 往往/ 会/ 把/ 很多/ 脏页/ 替换/ 出去/ ./ 替换/ 脏页/ 会/ 带来/ 大量/ 的/ I/ // O/ 开销/ ,/ 这/ 就/ 恶化/ 了/ 基于/ 闪存/ 的/ 数据库/ 的/ 性能/ ./ 为了/ 减少/ 脏页/ 回写/ 的/ 代价/ ,/ 在/ 设计/ 面向/ 闪存/ 的/ 缓冲区/ 替换算法/ 时/ ,/ 可以/ 以/ 适当/ 增加/ 读/ 操作/ 为/ 代价/ ,/ 来/ 减少/ 写/ 操作/ 的/ 次数/ ,/ 从而/ 获得/ 整体/ 性能/ 的/ 提升/ ./ CCF/ -/ LRU/ [/ 9/ ]/ 和/ AD/ -/ LRU/ [/ 10/ ]/ 是/ 两个/ 面向/ 闪存/ 的/ 缓冲区/ 替换算法/ ,/ 它们/ 都/ 将/ 缓冲区/ 分成/ 两个/ 区/ ,/ 分别/ 存放/ 不同/ 替换/ 代价/ 的/ 数据/ 页/ ,/ 以此/ 来/ 捕获/ 数据/ 访问/ 的/ 频度/ ,/ 并且/ 它们/ 都/ 在/ 替换/ 区中/ 无条件/ 优先/ 替换/ 干净/ 页/ ,/ 以/ 达到/ 增加/ 读/ 操作/ 次数/ ,/ 减少/ 写/ 操作/ 次数/ 的/ 目的/ ,/ 所以/ 在/ 使用/ 固态/ 盘/ 作为/ 底层/ 存储设备/ 的/ 数据库系统/ 中/ 获得/ 了/ 较/ 好/ 的/ 性能/ ,/ 但是/ 它们/ 都/ 有/ 两个/ 严重/ 的/ 缺陷/ :/ (/ 1/ )/ 在/ 替换/ 区中/ 无条件/ 优先/ 替换/ 干净/ 页/ ,/ 这种/ 替换/ 方式/ 会/ 导致/ 脏页/ 完全/ 占据/ 缓冲区/ ,/ 从/ 引起/ 干净/ 页/ 刚/ 读入/ 缓冲区/ 就/ 立即/ 被/ 选择/ 作为/ 驱逐/ 页/ 的/ 情况/ ,/ 这种/ 替换/ 方式/ 在/ 某些/ 负载/ 下会/ 严重/ 恶化/ 命中率/ ,/ 增加/ 大量/ 的/ 读/ 操作/ ,/ 这/ 在/ 读写/ 代价/ 差异/ 较/ 小/ 的/ 固态/ 盘/ 上/ 尤为/ 不利/ ;/ (/ 2/ )/ 冷脏页/ 长期/ 驻留/ 缓冲区/ ,/ 浪费/ 了/ 宝贵/ 的/ 缓冲区/ 资源/ ./ 为了/ 解决/ 上述/ 问题/ ,/ 本文/ 首先/ 提出/ 了/ 一种/ 朴素/ 算法/ PB/ -/ LRU/ ,/ 该/ 算法/ 将/ 缓冲区/ 分为/ 两个/ LRU/ 队列/ —/ —/ —/ 冷区/ 和/ 热区/ ,/ 分别/ 存放/ 不同/ 访问/ 频度/ 的/ 数据/ 页/ ,/ 其中/ 在/ 冷区/ 队列/ 中/ 存放/ 那些/ 只/ 访问/ 过/ 一次/ 的/ 数据/ 页/ ,/ 在/ 热区/ 队列/ 中/ 存放/ 那些/ 至少/ 访问/ 过/ 两次/ 的/ 数据/ 页/ ,/ 冷区/ 和/ 热区/ 的/ 大小/ 是/ 固定/ 的/ ./ 对于/ 冷区/ 队列/ ,/ PB/ -/ LRU/ 算法/ 采用/ 了/ 完全/ 不同于/ 其它/ 研究/ 的/ 替换/ 策略/ ,/ 即以/ 不同/ 的/ 概率/ 替换/ 不同/ 的/ 数据/ 页/ ,/ 采用/ 这种/ 策略/ 有/ 如下/ 好处/ ;/ (/ 1/ )/ 以/ 较大/ 概率/ 替换/ 干净/ 页/ ,/ 以较/ 小/ 的/ 概率/ 替换/ 脏页/ ,/ 虽然/ 增加/ 了/ 读/ 操作/ 次数/ ,/ 却/ 减少/ 了/ 写/ 操作/ 的/ 次数/ ,/ 从而/ 有效/ 提升/ 了/ 算法/ 总体/ 性能/ ;/ (/ 2/ )/ 能够/ 有效/ 避免/ 冷脏页/ 长期/ 驻留/ 缓冲区/ ,/ 浪费/ 宝贵/ 的/ 缓冲区/ 资源/ ;/ (/ 3/ )/ 避免/ 了/ 脏页/ 完全/ 占据/ 缓冲区/ 而/ 导致/ 的/ “/ 干净/ 页/ 刚/ 读入/ 缓存/ 就/ 立即/ 被/ 选择/ 为/ 驱逐/ 页/ ”/ 的/ 情况/ ./ 在/ 此基础/ 之上/ ,/ 我们/ 进一步/ 将/ 冷/ 区分/ 为/ 干净/ 页/ 队列/ 和/ 脏页/ 队列/ ,/ 以此/ 加快/ 驱逐/ 页/ 的/ 查找/ 速度/ ;/ 此外/ ,/ 通过/ 实验/ 我们/ 还/ 发现/ ,/ 对于/ 访问/ 局部性/ 较/ 高/ 的/ 工作/ 负载/ ,/ 热区/ 所/ 占/ 缓冲区/ 比例/ 较大/ 时能/ 获得/ 较/ 好/ 的/ 性能/ ,/ 对于/ 访问/ 局部性/ 较/ 低/ 的/ 工作/ 负载/ ,/ 热区/ Page3/ 所/ 占/ 比例/ 适当/ 减少/ 时能/ 获得/ 较/ 好/ 的/ 性能/ ./ 由此/ ,/ 本文/ 在/ 朴素/ 算法/ PB/ -/ LRU/ 的/ 基础/ 上/ ,/ 进一步/ 提出/ 了/ 一种/ 自/ 适应/ 的/ 、/ 基于/ 替换/ 概率/ 的/ 缓冲区/ 置换/ 算法/ —/ —/ —/ APB/ -/ LRU/ ,/ 该/ 算法/ 能够/ 根据/ 数据/ 访问/ 模式/ 动态/ 调整/ 冷/ 、/ 热区/ 所/ 占/ 的/ 比例/ ./ 实验/ 结果表明/ ,/ APB/ -/ LRU/ 算法/ 能够/ 明显提高/ 缓冲区/ 的/ 命中率/ ,/ 且/ 在/ 不同/ 访问/ 模式/ 的/ 工作/ 负载/ 下/ ,/ 都/ 能够/ 取得/ 比/ 其它/ 已有/ 算法/ 更好/ 的/ 性能/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 工作/ 并/ 对/ 几种/ 代表性/ 研究成果/ 的/ 优缺点/ 进行/ 分析/ ;/ 第/ 3/ 节/ 介绍/ 本文/ 提出/ 的/ 基于/ 替换/ 概率/ 的/ 朴素/ 算法/ —/ —/ —/ PB/ -/ LRU/ 算法/ ;/ 第/ 4/ 节/ 给出/ 朴素/ 算法/ 的/ 改进/ 版本/ ,/ 即/ 一种/ 自/ 适应/ 的/ 、/ 基于/ 替换/ 概率/ 的/ 算法/ —/ —/ —/ APB/ -/ LRU/ 算法/ ;/ 第/ 5/ 节/ 给出/ 实验设计/ 和/ 结果/ 分析/ ;/ 第/ 6/ 节/ 总结/ 全文/ 并/ 展望未来/ 工作/ ./ 2/ 相关/ 工作/ LRU/ 是/ 经典/ 的/ 缓冲区/ 替换算法/ ,/ 在/ 现有/ 的/ 系统/ 中/ ,/ 基本上/ 都/ 采用/ LRU/ 算法/ 或类/ LRU/ 算法/ ./ LRU/ 根据/ 页面/ 的/ 新颖/ 度/ (/ recency/ )/ 信息/ 进行/ 缓冲区/ 管理/ ./ 在/ 实现/ 时/ ,/ 它会/ 构造/ 一个/ 链表/ ,/ 每个/ 链表/ 元素/ 代表/ 一个/ 缓存/ 页面/ ./ 当/ 发生/ 缓冲区/ “/ 脱靶/ ”/ (/ 访问/ 的/ 页面/ 不/ 在/ 缓冲区/ 中/ ,/ 需要/ 到/ 外部/ 存储/ 中/ 读取/ 该页/ )/ 且/ 缓冲区/ 未满/ 时/ ,/ 则/ 把/ 该页/ 插入/ 到/ 链表/ 的/ MRU/ (/ MostRecentlyUsed/ )/ 位置/ ;/ 如果/ 缓冲区/ 已满/ ,/ 则/ 替换/ 链表/ 的/ LRU/ 位置/ 上/ 的/ 页/ ,/ 并/ 把/ 新页/ 插入/ 到/ MRU/ 位置/ ;/ 若/ 访问/ 的/ 页面/ 在/ 缓冲区/ 中/ “/ 命中/ ”/ (/ 访问/ 的/ 数据/ 已经/ 在/ 缓冲区/ 中/ ,/ 不/ 需要/ 到/ 外部/ 存储/ 中/ 去/ 读取/ )/ ,/ 则/ 把/ 该/ 页面/ 移/ 到/ 链表/ 的/ MRU/ 位置/ ./ LRU/ 算法/ 在/ 访问/ 局部性/ 较/ 高/ 的/ 时候/ ,/ 能够/ 获得/ 较/ 好/ 的/ 性能/ ,/ 而且/ LRU/ 的/ 各个/ 操作/ 都/ 是/ 常量/ 时间/ 复杂度/ ./ 但是/ ,/ LRU/ 算法/ 存在/ 如下/ 缺点/ :/ (/ 1/ )/ 没有/ 捕获/ 数据/ 访问/ 的/ 频度/ (/ frequency/ )/ 特征/ ;/ (/ 2/ )/ 缓冲区/ 中/ 的/ 数据/ 容易/ 被/ 一次/ 扫描/ 应用/ 污染/ ./ 包括/ LRU/ 在内/ 的/ 传统/ 的/ 缓冲区/ 替换算法/ ,/ 通常/ 假设/ 底层/ 存储介质/ 的/ 读/ 操作/ 和/ 写/ 操作/ 代价/ 相同/ ,/ 但是/ 对于/ 闪存/ 而言/ ,/ 写入/ 一个/ 页/ 的/ 代价/ 比/ 读取/ 一个/ 页/ 的/ 代价/ 高/ 很多/ ,/ 因此/ 直接/ 将/ 传统/ 的/ 缓冲区/ 替换算法/ 应用/ 于/ 固态/ 盘中/ ,/ 是/ 无法/ 获得/ 较/ 好/ 的/ 数据库/ 整体/ 性能/ 的/ ./ CFLRU/ [/ 11/ ]/ 是/ 第一个/ 面向/ 闪存/ 的/ 缓冲区/ 替换算法/ ,/ 它/ 利用/ 闪存/ 读写/ 延迟/ 的/ 非/ 对称性/ ,/ 提出/ 了/ 一种/ 优先/ 替换/ 干净/ 页/ 的/ 缓冲区/ 替换/ 策略/ ,/ 主要/ 思想/ 是/ :/ (/ 1/ )/ 将/ LRU/ 链表/ 逻辑/ 上/ 分为/ 工作/ 区/ 和/ 替换/ 区/ 两/ 部分/ ;/ (/ 2/ )/ 替换/ 操作/ 总是/ 发生/ 在/ 替换/ 区/ ,/ 并且/ 总是/ 优先/ 替换/ 替换/ 区中/ 的/ 干净/ 页/ ,/ 如果/ 替换/ 区中/ 没有/ 干净/ 页/ ,/ 则/ 采用/ 和/ LRU/ 算法/ 一样/ 的/ 顺序/ 替换/ 其它/ 页/ ./ CFLRU/ 在/ 替换/ 区中/ 总是/ 优先/ 替换/ 干净/ 页/ ,/ 导致/ 算法/ 命中率/ 有所/ 降低/ ,/ 但是/ 它/ 减少/ 了/ 闪存/ 的/ 写/ 操作/ 和/ 擦除/ 操作/ 的/ 次数/ ,/ 因此/ 可以/ 获得/ 整体/ 性能/ 的/ 提升/ ./ CFLRU/ 算法/ 的/ 缺陷/ 主要/ 表现/ 在/ 4/ 个/ 方面/ :/ (/ 1/ )/ 该/ 算法/ 需要/ 人为/ 确定/ 替换/ 区/ 的/ 大小/ (/ w/ )/ ,/ 而/ 一个/ 固定/ 的/ w/ 值/ 很/ 难/ 适应/ 不同/ 的/ 工作/ 负载/ ;/ (/ 2/ )/ 在/ 某些/ 情况/ 下/ 查找/ 代价/ 较/ 高/ ,/ 因为/ 该/ 算法/ 在/ 每次/ 选择/ 驱逐/ 页/ 时/ ,/ 都/ 需要/ 沿着/ LRU/ 链表/ 反向/ 查找/ 干净/ 页/ 驱逐/ 页/ ,/ 当/ 链表/ 较长/ 时/ ,/ 就/ 会/ 需要/ 较/ 高/ 的/ 查找/ 代价/ ;/ (/ 3/ )/ 和/ LRU/ 算法/ 一样/ ,/ 没有/ 充分利用/ 数据/ 页/ 的/ 访问/ 频度/ 特征/ ,/ 从而/ 无法/ 获得/ 较/ 好/ 的/ 性能/ ;/ (/ 4/ )/ 不能/ 阻止/ 顺序/ 扫描/ 操作/ 对/ 缓冲区/ 的/ 污染/ ./ LRU/ -/ WSR/ [/ 12/ ]/ 算法/ 是/ 对/ CFLRU/ 算法/ 的/ 一种/ 改进/ ,/ 该/ 算法/ 捕获/ 了/ 脏页/ 的/ 频度/ 特征/ ,/ 能够/ 有效/ 地/ 避免/ 冷脏页/ 长期/ 驻留/ 内存/ ./ LRU/ -/ WSR/ 算法/ 为/ 每个/ 链表/ 元素/ 添加/ 一个/ 冷/ 标识/ 位/ ,/ 用于/ 标识/ 该页/ 是否/ 为/ 冷页/ ./ LRU/ -/ WSR/ 算法/ 在/ 选择/ 驱逐/ 页/ 时/ ,/ 首先/ 检查/ LRU/ 位置/ 上/ 的/ 页/ 是否/ 为脏页/ ,/ 如果/ 是/ 脏页/ ,/ 并且/ 冷/ 标识/ 位为/ 0/ ,/ 则/ 认为/ 该页/ 是非/ 冷/ 的/ 脏页/ ,/ 那么/ 就/ 将/ 其/ 冷/ 标识/ 位/ 设置/ 为/ 1/ ,/ 并/ 将/ 该页/ 移到/ MRU/ 位置/ ,/ 然后/ ,/ 再/ 一次/ 选择/ LRU/ 位置/ 上/ 的/ 页/ 进行/ 下/ 一次/ 判断/ ./ 如果/ 当前/ 选择/ 的/ 页/ 是/ 干净/ 页/ ,/ 或者/ 是/ 冷/ 标识/ 位为/ 1/ 的/ 脏页/ ,/ 则/ 替换/ 该页/ ./ 此外/ ,/ 在/ 任何/ 时候/ 引用/ 脏页/ ,/ 都/ 会/ 将/ 它/ 的/ 冷/ 标识/ 位/ 设置/ 为/ 0/ ./ LRU/ -/ WSR/ 算法/ 的/ 不足/ 是/ ,/ 虽然/ 考虑/ 了/ 脏页/ 的/ 冷热/ 属性/ ,/ 但是/ 没有/ 考虑/ 干净/ 页/ 的/ 冷热/ 属性/ ,/ 而且/ 该/ 算法/ 不能/ 阻止/ 一次/ 扫描/ 操作/ 对/ 缓冲区/ 的/ 污染/ ./ CCF/ -/ LRU/ (/ Cold/ -/ Clean/ -/ FirstLRU/ )/ [/ 9/ ]/ 算法/ 捕获/ 了/ 干净/ 页/ 和/ 脏页/ 的/ 频度/ 特征/ ,/ 它/ 将/ 缓冲区/ 分为/ 两个/ LRU/ 链表/ ,/ 即/ L1/ (/ MixedLRUList/ )/ 和/ L2/ (/ ColdCleanLRUList/ )/ ,/ 前者/ 用于/ 存放/ 脏页/ 和/ 热/ 干净/ 页/ ,/ 后者/ 用于/ 存放/ 冷/ 干净/ 页/ ./ CCF/ -/ LRU/ 算法/ 总是/ 优先/ 替换/ L2/ 链表/ 中/ 的/ 数据/ 页/ ,/ 当/ L2/ 链表/ 为/ 空时/ ,/ 才/ 在/ L1/ 链表/ 中用/ LRU/ -/ WSR/ 算法/ 选择/ 驱逐/ 页/ ./ CCF/ -/ LRU/ 算法/ 的/ 优点/ 是/ :/ (/ 1/ )/ 捕获/ 了/ 干净/ 页/ 和/ 脏页/ 的/ 频度/ 特征/ ;/ (/ 2/ )/ 将/ 缓冲区/ 分为/ 两个/ 队列/ ,/ 能够/ 有效/ 地/ 阻止/ 一次/ 扫描/ 操作/ 对/ 缓冲区/ 的/ 污染/ ;/ (/ 3/ )/ 在/ 访问/ 局部性/ 很/ 高/ 的/ 时候/ 非常/ 有效/ ./ 但是/ ,/ CCF/ -/ LRU/ 算法/ 也/ 存在/ 明显/ 的/ 不足/ ,/ 它/ 无法控制/ L2/ 链表/ 的/ 长度/ ,/ 在/ 某些/ 情形/ 下/ ,/ 可能/ 导致/ 刚/ 读入/ 缓冲区/ 的/ 干净/ 页/ 马上/ 被/ 替换/ 出去/ ,/ 严重/ 降低/ 命中率/ ./ Page4AD/ -/ LRU/ (/ AdaptiveDoubleLRU/ )/ [/ 10/ ]/ 算法/ 是/ 对/ CCF/ -/ LRU/ 算法/ 的/ 改进/ ,/ 主要/ 思想/ 如下/ :/ (/ 1/ )/ 将/ 缓冲区/ 分为/ 热区/ 和/ 冷区/ ,/ 热区/ 中/ 存放/ 那些/ 至少/ 访问/ 过/ 两次/ 的/ 页/ ,/ 冷区/ 中/ 存放/ 那些/ 只/ 访问/ 过/ 一次/ 的/ 页/ ;/ (/ 2/ )/ 冷/ 、/ 热区/ 的/ 大小/ 是/ 动态/ 调整/ 的/ ;/ (/ 3/ )/ 冷区/ 容量/ 有/ 一个/ 下界/ (/ min/ _/ lc/ )/ ,/ 当冷区/ 的/ 容量/ 大于/ 等于/ min/ _/ lc/ 时/ ,/ 替换/ 操作/ 发生/ 在/ 冷区/ ,/ 当冷区/ 的/ 容量/ 小于/ min/ _/ lc/ 时/ ,/ 替换/ 操作/ 发生/ 在/ 热区/ ./ 相对/ 于/ CCF/ -/ LRU/ 算法/ ,/ AD/ -/ LRU/ 算法/ 有/ 了/ 进一步/ 的/ 提升/ ,/ 在/ 读写/ 局部性/ 较/ 低/ 的/ 情况/ 下/ ,/ 也/ 能/ 表现/ 出较/ 好/ 的/ 性能/ ./ 但是/ ,/ 它/ 并/ 没有/ 彻底解决/ CCF/ -/ LRU/ 算法/ 中/ 的/ 问题/ ./ 首先/ ,/ AD/ -/ LRU/ 在/ 冷区/ 中/ 总是/ 优先/ 替换/ 干净/ 页/ ,/ 这种/ 替换/ 策略/ 依然/ 无法/ 避免/ 干净/ 页/ 刚/ 读入/ 缓冲区/ 就/ 被/ 替换/ 的/ 情况/ ;/ 其次/ ,/ 优先/ 替换/ 干净/ 页/ 将/ 导致/ 冷脏页/ 长期/ 驻留/ 缓冲区/ ,/ 浪费/ 了/ 宝贵/ 的/ 缓冲区/ 资源/ ,/ 降低/ 了/ 命中率/ ,/ 在/ 干净/ 页/ 较/ 多/ 的/ 访问/ 序列/ 中/ 尤为/ 不利/ ./ 相反/ ,/ 本文/ 提出/ 的/ PB/ -/ LRU/ 算法/ 能够/ 有效/ 地/ 解决/ CCF/ -/ LRU/ 算法/ 和/ AD/ -/ LRU/ 算法/ 中/ 存在/ 的/ 各种/ 问题/ ,/ 避免/ 干净/ 页/ 刚/ 读入/ 缓冲区/ 就/ 被/ 替换/ 的/ 情况/ 发生/ ,/ 防止/ 冷脏页/ 长期/ 驻留/ 缓冲区/ ./ 3/ 基于/ 替换/ 概率/ 的/ 缓冲区/ 替换算法/ 本/ 节/ 首先/ 论述/ PB/ -/ LRU/ 算法/ 的/ 基本/ 思想/ (/ 3.1/ 节/ )/ ,/ 然后/ 给出/ 算法/ 的/ 设计/ 细节/ ,/ 并/ 列举/ 一个/ 实例/ 来/ 演示/ PB/ -/ LRU/ 算法/ 的/ 执行/ 过程/ (/ 3.2/ 节/ )/ ,/ 最后/ 将/ 对/ PB/ -/ LRU/ 算法/ 与/ 其它/ 算法/ 进行/ 比较/ (/ 3.3/ 节/ )/ ./ 3.1/ 基本/ 思想/ PB/ -/ LRU/ 算法/ 采用/ 与/ LRU/ -/ WSR/ 算法/ 类似/ 的/ 冷/ 数据/ 判断/ 机制/ ,/ 将/ 缓冲区/ 中/ 的/ 数据/ 页/ 依据/ 其/ 访问/ 特点/ ,/ 划分/ 为/ 冷/ 干净/ 页/ 、/ 冷脏页/ 、/ 热/ 干净/ 页/ 和/ 热脏页/ ./ 在/ 这种/ 冷/ 数据/ 检测/ 方法/ 中/ ,/ 缓冲区/ 中/ 的/ 每个/ 数据/ 页/ 都/ 被/ 赋予/ 一个/ 冷/ 标识/ 位/ ,/ 当冷/ 标识/ 位为/ 1/ 时/ ,/ 表明/ 该/ 数据/ 页/ 为/ 冷页/ ,/ 当冷/ 标识/ 位为/ 0/ 时/ ,/ 表明/ 该/ 数据/ 页/ 为/ 热页/ ./ 此外/ ,/ 当/ 缓冲区/ 中/ 的/ 冷页/ 被/ 再次/ 访问/ 时/ ,/ 需要/ 将/ 其/ 标记/ 为/ 热/ 数据/ ,/ 即将/ 冷/ 标识/ 位/ 设置/ 为/ 0/ ./ 由于/ 闪存/ 的/ 写/ 操作/ 的/ 代价/ 高于/ 读/ 操作/ 的/ 代价/ ,/ 因此/ 在/ 4/ 种/ 数据/ 页/ 中/ ,/ 热脏页/ 替换/ 代价/ 最高/ ,/ 冷/ 干净/ 页/ 替换/ 代价/ 最低/ ,/ 热/ 干净/ 页/ 的/ 替换/ 代价/ 要/ 高于/ 冷脏页/ 的/ 替换/ 代价/ ./ 基于/ 以上/ 分析/ ,/ 可以/ 得到/ 4/ 种/ 数据/ 页/ 替换/ 代价/ 的/ 关系/ 表达式/ :/ 其中/ ,/ Ccc/ 表示/ 冷/ 干净/ 页/ 替换/ 代价/ ,/ Ccd/ 表示/ 冷脏页/ 替换/ 代价/ ,/ Chc/ 表示/ 热/ 干净/ 页/ 的/ 替换/ 代价/ ,/ Chd/ 表示/ 热脏页/ 的/ 替换/ 代价/ ./ 从式/ (/ 1/ )/ 可知/ ,/ 若想/ 提高/ 闪存/ 的/ 整体/ I/ // O/ 性能/ ,/ 必须/ 尽可能减少/ 替换/ 出热脏页/ 和/ 热/ 干净/ 页/ ./ 为了/ 达到/ 这个/ 目的/ ,/ 替换算法/ 应该/ 对/ 冷页/ 和/ 热页/ 进行/ 区分/ ,/ 从而/ 让/ 热页/ 在/ 缓冲区/ 驻留/ 更长/ 的/ 时间/ ./ 然而/ ,/ 一些/ 已有/ 的/ 替换算法/ (/ 比如/ CFLRU/ 和/ LRU/ -/ WSR/ )/ 都/ 没有/ 考虑/ 数据/ 的/ 访问/ 频度/ ,/ 不/ 对/ 冷页/ 和/ 热页/ 做/ 任何/ 区分/ ,/ 因此/ 不能/ 获得/ 较/ 好/ 的/ 性能/ ./ 另外/ 一些/ 替换算法/ (/ 比如/ CCF/ -/ LRU/ 和/ AD/ -/ LRU/ )/ ,/ 虽然/ 考虑/ 了/ 数据/ 的/ 访问/ 频度/ ,/ 但是/ 它们/ 都/ 无法/ 避免/ “/ 干净/ 页/ 刚/ 读入/ 缓冲区/ 就/ 立刻/ 被/ 选择/ 作为/ 驱逐/ 页/ ”/ 的/ 情况/ ,/ 也/ 无法/ 避免/ 冷脏页/ 长期/ 驻留/ 缓冲区/ 的/ 情况/ ,/ 因此/ 降低/ 了/ 缓冲区/ 的/ 命中率/ ,/ 也/ 降低/ 了/ 闪存/ 的/ 整体/ I/ // O/ 性能/ ./ 我们/ 提出/ 的/ 基于/ 替换/ 概率/ 的/ 缓冲区/ 替换算法/ PB/ -/ LRU/ ,/ 可以/ 有效/ 克服/ 上述/ 缺陷/ ,/ 其/ 主要/ 思想/ 如下/ :/ (/ 1/ )/ 将/ 缓冲区/ 分为/ 冷区/ 和/ 热区/ ,/ 冷/ 、/ 热区/ 的/ 大小/ 是/ 固定/ 的/ ,/ 热区/ 中/ 存放/ 至少/ 访问/ 过/ 两次/ 的/ 页/ ,/ 冷区/ 中/ 存放/ 只/ 访问/ 过/ 一次/ 的/ 页/ 或/ 已经/ 很久没/ 有/ 再/ 访问/ 的/ 热页/ ;/ (/ 2/ )/ 所有/ 替换/ 操作/ 都/ 发生/ 在/ 冷区/ ,/ 采用/ 较大/ 的/ 概率/ 替换/ 冷区/ 中/ 的/ 干净/ 页/ ,/ 较/ 小/ 的/ 概率/ 替换/ 冷区/ 中/ 的/ 脏页/ ,/ 以此/ 来/ 避免/ 冷脏页/ 长期/ 驻留/ 缓冲区/ 的/ 情况/ ;/ (/ 3/ )/ 刚/ 读入/ 缓冲区/ 的/ 数据/ 页/ 存放/ 在/ 冷区/ 的/ MRU/ 位置/ ,/ 冷区/ 中/ 的/ 一个/ 页/ 命中/ 时/ ,/ 将/ 该页/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ,/ 并/ 使用/ LRU/ -/ WSR/ 算法/ 选中/ 热区/ 中/ 的/ 一个/ 页/ ,/ 转移/ 到/ 冷区/ 的/ MRU/ 位置/ ;/ 如果/ 热区/ 中/ 的/ 某个/ 页/ 被/ 命中/ ,/ 则/ 将/ 其/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ;/ (/ 4/ )/ 使用/ LRU/ -/ WSR/ 选择/ 热区/ 中/ 的/ 一个/ 页/ 时/ ,/ 需要/ 使用/ 到/ 冷/ 标识/ 位来/ 判断/ 一个/ 页/ 属于/ 冷页/ 还是/ 热页/ ,/ 因此/ PB/ -/ LRU/ 算法/ 会为/ 热区/ 中/ 的/ 每个/ 数据/ 页/ 设置/ 冷/ 标识/ 位/ (/ 冷区/ 中/ 的/ 数据/ 页/ 不/ 需要/ 冷/ 标识/ 位/ )/ ./ 标识/ 位为/ “/ 0/ ”/ 表示/ 该页/ 是/ 热页/ ,/ 标识/ 位为/ “/ 1/ ”/ 表示/ 该页/ 为/ 冷页/ ./ 使用/ LRU/ -/ WSR/ 算法/ 将/ 热区/ 中/ 的/ 数据/ 页/ 转移/ 到/ 冷区/ 时/ ,/ 首先/ 获取/ 热区/ 中/ LRU/ 位置/ 的/ 数据/ 页/ ,/ 如果/ 该页/ 是/ 干净/ 页/ 或/ 冷/ 标识/ 位为/ 1/ 的/ 脏页/ ,/ 就/ 直接/ 将/ 该页/ 转移/ 到/ 冷区/ 的/ MRU/ 位置/ ;/ 如果/ 该页/ 是/ 冷/ 标识/ 位为/ 0/ 的/ 脏页/ ,/ 则/ 给/ 该页/ 第/ 2/ 次/ 机会/ ,/ 将/ 该页/ 的/ 冷/ 标识/ 位/ 设置/ 为/ 1/ ,/ 并/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ,/ 然后/ 再次/ 选择/ 热区/ 中/ LRU/ 位置/ 的/ 数据/ 页/ ,/ 重复/ 上述/ 判断/ 过程/ ./ 为了/ 更好/ 地/ 理解/ PB/ -/ LRU/ 算法/ 的/ 思想/ ,/ 例/ 1/ 演例/ 1/ ./ 假设/ 缓冲区/ 最/ 多/ 只能/ 同时/ 容纳/ 6/ 个页/ ./ 示了/ 该/ 算法/ 命中/ 和/ 脱靶/ 的/ 情况/ ./ Page5/ 在/ 初始/ 阶段/ (/ 见图/ 1/ (/ a/ )/ )/ ,/ 缓冲区/ 中/ 包含/ 了/ P1/ ,/ P2/ ,/ P3/ ,/ P4/ ,/ P5/ ,/ P6/ ,/ 其中/ ,/ P1/ 是/ 冷脏页/ ,/ P2/ 和/ P3/ 是/ 冷/ 干净/ 页/ ,/ P4/ 是/ 冷/ 标识/ 位为/ 0/ 的/ 热脏页/ ,/ P5/ 是/ 冷/ 标识/ 位为/ 1/ 的/ 热脏页/ ,/ P6/ 是/ 热/ 干净/ 页/ ./ 命中/ 的/ 情况/ ./ 在/ 某个/ 时刻/ ,/ 一个/ 针对/ 页/ P2/ 的/ 读/ 操作/ 到达/ ,/ PB/ -/ LRU/ 算法/ 检查/ 缓冲区/ 后/ 发现/ P2/ 已经/ 在/ 缓冲区/ 中/ (/ 在/ 冷区/ 中/ )/ ,/ 就/ 直接/ 从/ 缓冲区/ 读取/ P2/ ;/ P2/ 被/ 访问/ 后/ ,/ PB/ -/ LRU/ 算法/ 会/ 将/ 其/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ,/ 并/ 将/ 其/ 冷/ 标识/ 位/ 设置/ 为/ 0/ ./ 由于/ 冷/ 、/ 热区/ 的/ 大小/ 是/ 固定/ 的/ ,/ 而/ 此时/ 热区/ 已满/ ,/ 为了/ 将/ 冷区/ 中/ 的/ P2/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ,/ 需要/ 使用/ LRU/ -/ WSR/ 算法/ 将/ 热区/ 中/ 的/ 一个/ 页/ 转移/ 到/ 冷区/ 的/ MRU/ 位置/ ,/ 从而/ 在/ 热区/ 中/ 腾出/ 空间/ 存放/ P2/ ,/ P2/ 被/ 转移/ 到/ 热区/ 以后/ ,/ 冷区/ 就/ 腾出/ 了/ 一个/ 页/ 的/ 空间/ ,/ 此时/ ,/ 可以/ 把/ 热区/ 中/ 被/ 转移/ 出来/ 的/ 页/ ,/ 存放/ 到/ 冷区/ 的/ MRU/ 位置/ ./ 使用/ LRU/ -/ WSR/ 算法/ 在/ 热区/ 选择/ 一个/ 被/ 转移/ 页/ 的/ 方法/ 是/ :/ 首先/ ,/ 获取/ 热区/ 中/ LRU/ 位置/ 的/ 页/ P4/ ,/ 由于/ P4/ 是/ 冷/ 标识/ 位为/ 0/ 的/ 脏页/ ,/ 说明/ P4/ 是/ 热脏页/ ,/ 不会/ 被/ 马上/ 转移/ ,/ 而是/ 给/ 它/ 第/ 2/ 次/ 机会/ ,/ 因此/ 将/ P4/ 的/ 冷/ 标识/ 位/ 设置/ 为/ 1/ ,/ 并/ 将/ P4/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ;/ 接下来/ ,/ 再次/ 获取/ 热区/ 中/ LRU/ 位置/ 的/ 数据/ 页/ P5/ 作/ 判断/ ,/ 因为/ P5/ 是/ 冷/ 标识/ 位为/ 1/ 的/ 脏页/ ,/ 所以/ LRU/ -/ WSR/ 算法/ 不会/ 给/ 它/ 第/ 2/ 次/ 机会/ ,/ 直接/ 将/ P5/ 确定/ 为/ 转移/ 页/ ./ 采用/ 上述/ 方法/ 确定/ P5/ 为/ 转移/ 页/ 后/ ,/ 就/ 可以/ 将/ P5/ 转移/ 以/ 腾出/ 一个/ 页/ 空间/ ,/ 从而/ 将/ 冷区/ 中/ 的/ P2/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ,/ 最后/ ,/ 把/ P5/ 放入/ 冷区/ 的/ MRU/ 位置/ ./ 上述/ 过程/ 完成/ 以后/ ,/ 缓冲区/ 的/ 当前/ 状态/ 如图/ 1/ (/ b/ )/ 所示/ ./ 脱靶/ 的/ 情况/ ./ 在/ 上面/ 的/ 针对/ P2/ 读/ 操作/ 完成/ 以后/ ,/ 一个/ 新/ 的/ 针对/ 页/ P7/ 的/ 读/ 操作/ 到达/ ,/ PB/ -/ LRU/ 算法/ 检查/ 缓冲区/ 后/ 发现/ P7/ 不/ 在/ 缓冲区/ 中/ ,/ 需要/ 到/ 外部/ 存储/ 中/ 读取/ P7/ 放入/ 冷区/ ./ 但是/ ,/ 此时/ 缓冲区/ 已满/ ,/ 需要/ 替换/ 冷区/ 中/ 的/ 一个/ 页/ 以/ 腾出/ 空间/ 存放/ P7/ ./ PB/ -/ LRU/ 算法/ 在/ 选择/ 驱逐/ 页/ 时/ ,/ 以/ 较大/ 的/ 概率/ 选择/ 干净/ 页/ ,/ 以较/ 小/ 的/ 概率/ 选择/ 脏页/ ,/ 因此/ 在/ 大多数/ 情况/ 下/ ,/ PB/ -/ LRU/ 算法/ 将会/ 选择/ 冷/ 干净/ 页/ P3/ 为/ 驱逐/ 页/ ./ 然后/ 从/ 外部/ 存储/ 中/ 读取/ P7/ 放入/ 到/ 冷区/ 的/ MRU/ 位置/ ./ 上述/ 过程/ 完成/ 以后/ ,/ 缓冲区/ 的/ 当前/ 状态/ 如图/ 1/ (/ c/ )/ 所示/ ./ 3.2/ 算法/ 设计/ 算法/ 1/ ./ PB/ -/ LRU/ 算法/ ./ 输入/ :/ 当前/ 请求/ 页/ (/ r/ )/ ,/ 冷/ 队列/ (/ Lc/ )/ ,/ 热/ 队列/ (/ Lh/ )/ 输出/ :/ 请求/ 页/ 1/ ./ IFpisinLhTHEN/ // // 如果/ p/ 在/ 热/ 队列/ 2/ ./ moveptotheMRUpositionofLh/ ;/ 3/ ./ cleancold/ -/ flagofp/ ;/ // // 清除/ p/ 的/ 冷/ 标识/ 位/ 4/ ./ RETURNareferenceofpinLh/ ;/ 5/ ./ ELSEIFpisinLcTHEN/ // // 如果/ p/ 在/ 冷/ 队列/ 6/ ./ IFthereisnotfreespaceintheLhTHEN7/ ./ moveapagetotheMRUpositionofLcfrom8/ ./ moveptotheMRUpositionofLh/ ;/ 9/ ./ RETURNareferenceofp/ ;/ 10/ ./ ELSE/ // // 如果/ p/ 不/ 在/ 缓冲区/ 中/ 11/ ./ IFthereisfreespaceinLcTHEN12/ ./ insertpintoMRUpositionofLc/ ;/ 13/ ./ RETURNareferencetopofLc/ ;/ 14/ ./ ELSEIFthereisfreespaceinLhTHEN15/ ./ insertpintoMRUpositionofLh/ ;/ 16/ ./ RETURNareferencetopofLh/ ;/ 17/ ./ ELSE18/ ./ victim/ ←/ SelectVictim/ (/ Lc/ )/ ;/ 19/ ./ IFvictimisdirtyTHEN20/ ./ writepageptoflashmemory/ ;/ 21/ ./ insertpintoMRUpositionofLc/ ;/ 22/ ./ RETURNareferencetopinLc/ ./ PB/ -/ LRU/ 算法/ 的/ 具体/ 执行/ 过程/ 如/ 算法/ 1/ 所示/ ./ 如果/ 热区/ 中/ 的/ 某个/ 页/ 被/ 命中/ ,/ 就/ 将/ 该页/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ,/ 并/ 清除/ 它/ 的/ 冷/ 标识/ 位/ (/ 第/ 1/ ~/ 4/ 行/ )/ ./ 如果/ 冷区/ 中/ 的/ 某个/ 页/ 被/ 命中/ ,/ 就/ 将/ 该页/ 移/ 到/ 热区/ 的/ Page6MRU/ 位置/ ,/ 如果/ 此时/ 热区/ 已满/ ,/ 则/ 使用/ LRU/ -/ WSR/ 算法/ 将/ 热区/ 中/ 的/ 一页/ 转移/ 到/ 冷区/ 的/ MRU/ 位置/ ,/ 然后/ 再/ 将/ 命中/ 的/ 数据/ 页/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ (/ 第/ 5/ ~/ 9/ 行/ )/ ./ 如果/ 访问/ 的/ 数据/ 页/ 不/ 在/ 缓冲区/ 中/ ,/ 则/ 我们/ 需要/ 判断/ 缓冲区/ 是否/ 已满/ ,/ 如果/ 缓冲区/ 未满/ ,/ 则/ 直接/ 读入/ 数据/ 页/ 到/ 缓冲区/ 中/ (/ 第/ 11/ ~/ 16/ 行/ )/ ,/ 如果/ 缓冲区/ 已满/ ,/ 则/ 需要/ 调用/ SelectVictim/ 函数/ ,/ 从/ 冷区/ 中/ 选择/ 一个/ 驱逐/ 页/ ,/ 替换/ 出/ 缓冲区/ (/ 第/ 18/ 行/ )/ ./ 驱逐/ 一页/ 时/ ,/ 还/ 需要/ 判断/ 该页/ 是否/ 脏页/ ,/ 如果/ 是/ 脏页/ ,/ 还/ 需要/ 回写/ 到/ 外部/ 存储/ (/ 第/ 19/ ~/ 20/ 行/ )/ ./ SelectVictim/ 函数/ 用来/ 在/ 冷区/ 中/ 选择/ 一个/ 驱逐/ 页/ ,/ 该/ 函数/ 采用/ 不同/ 的/ 概率/ 替换/ 干净/ 页/ 和/ 脏页/ ,/ 以/ 较大/ 的/ 概率/ 替换/ 干净/ 页/ ,/ 以较/ 小/ 的/ 概率/ 替换/ 脏页/ ./ 为了/ 达到/ 以/ 不同/ 概率/ 替换/ 干净/ 页/ 和/ 脏页/ 的/ 目的/ ,/ SelectVictim/ 首先/ 会/ 生成/ 一个/ 0/ ~/ N/ 的/ 随机数/ ,/ 其中/ ,/ N/ 是/ 闪存/ 读/ 代价/ (/ Costread/ )/ 与/ 闪存/ 写/ 代价/ (/ Costwrite/ )/ 之/ 和/ ,/ 然后/ 判断/ 生成/ 的/ 随机数/ 落入/ [/ 0/ ,/ Costread/ )/ 区间/ 还是/ [/ Costread/ ,/ N/ )/ 区间/ ./ 由于/ 闪存/ 的/ 读/ 代价/ 小于/ 闪存/ 的/ 写/ 代价/ ,/ 即/ Costread/ </ Costwrite/ ,/ 这/ 意味着/ 随机数/ 落入/ [/ Costread/ ,/ N/ )/ 区间/ 的/ 概率/ 更大/ ./ 由此/ ,/ 当/ 随机数/ 落入/ [/ Costread/ ,/ N/ )/ 区间/ 时/ ,/ 令/ 变量/ replacePage/ 为/ 0/ ,/ 用以/ 表示/ 算法/ 本次/ 将/ 选择/ 干净/ 页/ 为/ 驱逐/ 页/ ;/ 当/ 随机数/ 落入/ [/ 0/ ,/ Costread/ )/ 区间/ 时/ ,/ 令/ 变量/ replacePage/ 为/ 1/ ,/ 用以/ 表示/ 算法/ 本次/ 将/ 选择/ 脏页/ 为/ 驱逐/ 页/ ./ 这/ 就/ 实现/ 了/ 以/ 较大/ 的/ 概率/ 替换/ 干净/ 页/ 和/ 以/ 较/ 小/ 的/ 概率/ 替换/ 脏页/ 的/ 目的/ ./ SelectVictim/ 函数/ 通过/ 上面/ 的/ 方法/ 确定/ 需要/ 被/ 替换/ 的/ 页/ 后/ ,/ 如果/ 确定/ 替换/ 干净/ 页/ ,/ 则/ 还/ 需要/ 判断/ 冷区/ 中/ 是否/ 存在/ 干净/ 页/ ,/ 如果/ 不/ 存在/ ,/ 则/ 替换/ 脏页/ ;/ 如果/ 确定/ 替换/ 脏页/ ,/ 则/ 需要/ 判断/ 冷区/ 中/ 是否/ 存在/ 脏页/ ,/ 如果/ 不/ 存在/ ,/ 则/ 替换/ 干净/ 页/ ./ 算法/ 2/ ./ SelectVictim/ 函数/ ./ 输入/ :/ 冷/ 队列/ (/ Lc/ )/ 输出/ :/ 驱逐/ 页/ 1/ ./ replacePage/ ←/ rand/ (/ )/ %/ (/ Costread/ +/ Costwrite/ )/ </ // // replacePage/ 决定/ 了/ 替换/ 干净/ 页/ 还是/ 替换/ 脏页/ 2/ ./ IF/ (/ replacePage/ =/ =/ 0ANDthereexistscleanpage3/ ./ selectacleanpagefromLcasvictim/ ;/ 4/ ./ ELSE5/ ./ selectadirtypagefromLcasvictim/ ;/ 6/ ./ removethevictimpagefromLc/ ;/ 7/ ./ RETURNareferencetothevictimpage/ ./ 下面/ 通过/ 两个/ 实例/ 来/ 阐释/ PB/ -/ LRU/ 算法/ 相对/ 3.3/ 与/ 其它/ 算法/ 的/ 比较/ 于/ 已有/ 的/ 其它/ 算法/ 的/ 优点/ ./ 例/ 2/ ./ 假设/ 缓冲区/ 最/ 多/ 只能/ 同时/ 容纳/ 6/ 个页/ ,/ 并且/ 缓冲区/ 已满/ ,/ 缓冲区/ 中/ 当前/ 包含/ 的/ 数据/ 页/ (/ 图/ 2/ 所示/ )/ 包括/ P1/ ,/ P2/ ,/ P3/ ,/ P4/ ,/ P5/ ,/ P6/ ,/ 其中/ ,/ P1/ 和/ P6/ 是/ 冷脏页/ ,/ P2/ 和/ P3/ 是/ 热/ 干净/ 页/ ,/ P4/ 是/ 冷/ 干净/ 页/ ,/ P5/ 是/ 热脏页/ ./ 假设/ 此时/ 一个/ 访问/ P7/ 的/ 请求/ 到达/ ,/ 由于/ 缓冲区/ 已满/ ,/ 所以/ 需要/ 将/ 缓冲区/ 中/ 的/ 一个/ 页/ 驱逐/ 出去/ ,/ 以/ 腾出/ 空间/ 存放/ P7/ ./ 在/ 选择/ 驱逐/ 页/ 时/ ,/ PB/ -/ LRU/ 算法/ 和/ AD/ -/ LRU/ 算法/ 都/ 选择/ P4/ 作为/ 驱逐/ 页/ (/ 如图/ 2/ 所示/ )/ ;/ 而/ 对于/ CFLRU/ 和/ LRU/ -/ WSR/ 算法/ 而言/ ,/ 如图/ 3/ 所示/ ,/ 前者/ 则/ 会/ 选择/ 热/ 干净/ 页/ P2/ 作为/ 驱逐/ 页/ ,/ 后者/ 会/ 选择/ 冷脏页/ P1/ 作为/ 驱逐/ 页/ ./ 根据/ 前面/ 第/ 3.1/ 节/ 的/ 分析/ ,/ 一个/ 好/ 的/ 缓冲区/ 替换算法/ 应该/ 优先/ 替换/ 冷/ 干净/ 页/ ,/ 在/ 不/ 存在/ 冷/ 干净/ 页/ 时/ ,/ 再/ 替换/ 冷脏页/ ,/ 并/ 尽可能/ 让/ 热/ 数据/ 页/ 驻留/ 内存/ ./ 根据/ 这个/ 判断/ 标准/ ,/ 在/ 本例/ 中/ ,/ 数据/ 页/ 被/ 替换/ 的/ 先后顺序/ 依次/ 是/ P4/ ,/ P1/ ,/ P6/ ,/ P2/ ,/ P3/ 和/ P5/ ,/ 即/ P4/ 应该/ 最先/ 被/ 替换/ ,/ P5/ 应该/ 最后/ 被/ 替换/ ./ 由此/ 可以/ 看出/ ,/ CFLRU/ 做出/ 了/ 最差/ 的/ 选择/ ,/ 而/ PB/ -/ LRU/ 算法/ 和/ AD/ -/ LRU/ 算法/ 做出/ 了/ 最优/ 的/ 选择/ ./ 图/ 2AD/ -/ LRU/ 和/ PB/ -/ LRU/ 算法/ 选择/ 驱逐/ 页/ 实例/ 图/ 3CFLRU/ 和/ LRU/ -/ WSR/ 算法/ 选择/ 驱逐/ 页/ 实例/ 通过/ 例/ 2/ 可以/ 看出/ ,/ 没有/ 考虑/ 数据/ 访问/ 频度/ 的/ 替换算法/ (/ 如/ CFLRU/ 和/ LRU/ -/ WSR/ )/ 选择/ 驱逐/ 页/ 时/ ,/ 可能/ 选择/ 热/ 数据/ 页/ 为/ 驱逐/ 页/ ,/ 所以/ 降低/ 了/ 缓冲区/ 的/ 命中率/ ,/ 而/ 考虑/ 了/ 数据/ 访问/ 频度/ 的/ 替换算法/ (/ 如/ AD/ -/ LRU/ 和/ PB/ -/ LRU/ )/ 总是/ 会/ 优先/ 替换/ 冷/ 的/ 数据/ 页/ ,/ 所以/ 总体/ 表现/ 比/ 没有/ 考虑/ 数据/ 访问/ 频度/ 的/ 算法/ 更好/ ./ AD/ -/ LRU/ 算法/ 虽然/ 考虑/ 了/ 数据/ 的/ 访问/ 频度/ ,/ 但是/ 无法/ 避免/ “/ 干净/ 页/ 刚/ 读入/ 缓冲区/ 就/ 立刻/ 被/ 选择/ 作为/ 驱逐/ 页/ ”/ 的/ 情况/ ,/ 从而/ 导致/ 缓冲区/ 的/ 脱靶/ 率/ 的/ 增加/ ,/ 而/ PB/ -/ LRU/ 算法/ ,/ 通过/ 使用/ 基于/ 概率/ 的/ 替换/ 机/ Page7/ 制/ ,/ 不仅/ 能够/ 有效/ 地/ 避免/ 了/ 干净/ 页/ 刚/ 读入/ 缓冲区/ 就/ 被选为/ 驱逐/ 页/ 的/ 情况/ ,/ 而且/ 还/ 能/ 避免/ 冷脏页/ 长期/ 驻留/ 内存/ ,/ 从而/ 充分利用/ 了/ 宝贵/ 的/ 缓冲区/ 资源/ ,/ 显著/ 提升/ 了/ 缓冲区/ 命中率/ ./ 下面/ 将/ 通过/ 例/ 3/ 来/ 演示/ PB/ -/ LRU/ 算法/ 相对/ 于/ AD/ -/ LRU/ 算法/ 的/ 优势/ ./ 例/ 3/ ./ 在/ 例/ 2/ 中/ ,/ AD/ -/ LRU/ 和/ PB/ -/ LRU/ 算法/ 都/ 选择/ P4/ 为/ 驱逐/ 页/ ,/ 然后/ 读入/ P7/ ,/ 此时/ ,/ 缓冲区/ 中/ 的/ 数据/ 是/ P1/ ,/ P2/ ,/ P3/ ,/ P5/ ,/ P6/ ,/ P7/ ,/ 其中/ ,/ P1/ 和/ P6/ 是/ 冷脏页/ ,/ P2/ 和/ P3/ 是/ 热/ 干净/ 页/ ,/ P5/ 是/ 热脏页/ ,/ P7/ 是/ 冷/ 干净/ 页/ ./ 假设/ 现在/ 有/ 一个/ 新/ 的/ 请求/ 访问/ P8/ ,/ 由于/ 此时/ P8/ 不/ 在/ 缓冲区/ 中/ ,/ 因此/ 会/ 发生/ 缓存/ 脱靶/ ./ 此时/ ,/ AD/ -/ LRU/ 算法/ 会/ 选择/ 刚/ 进入/ 缓冲区/ 的/ 数据/ 页/ P7/ 作为/ 驱逐/ 页/ ,/ 然后/ 将/ P8/ 存放/ 到/ 冷区/ 的/ MRU/ 位置/ ./ 假设/ 接下来/ 又/ 有/ 一个/ 新/ 的/ 请求/ 访问/ P7/ ,/ 此时/ ,/ P7/ 不/ 在/ 缓存/ 中/ ,/ AD/ -/ LRU/ 算法/ 又/ 会/ 出现/ 缓存/ 脱靶/ 的/ 情况/ ,/ 这时/ AD/ -/ LRU/ 算法/ 会/ 选择/ P8/ 作为/ 驱逐/ 页/ ,/ 并/ 将/ P7/ 存放/ 到/ 冷区/ 的/ MRU/ 位置/ ./ 图/ 4/ 显示/ 了/ 当/ 采用/ AD/ -/ LRU/ 算法/ 时/ ,/ 在/ 经过/ 上述/ 对/ P7/ ,/ P8/ ,/ P7/ 的/ 访问/ 以后/ 缓冲区/ 的/ 当前/ 状态/ ./ 可以/ 看出/ ,/ 在/ 上述/ 过程/ 中/ ,/ AD/ -/ LRU/ 算法/ 共/ 出现/ 了/ 3/ 次/ 脱靶/ 的/ 情况/ ,/ 即/ 第/ 1/ 次访问/ P7/ 时/ ,/ 发生/ 一次/ 脱靶/ ,/ 访问/ P8/ 时/ ,/ 发生/ 一次/ 脱靶/ ,/ 第/ 2/ 次访问/ P7/ 时/ ,/ 发生/ 一次/ 脱靶/ ./ 相/ 比较而言/ ,/ 我们/ 的/ PB/ -/ LRU/ 算法/ 在/ 整个/ 过程/ 中/ 只会/ 出现/ 两次/ 脱靶/ 的/ 情况/ ./ 在/ 第/ 1/ 次/ 请求/ P7/ 时/ ,/ 此时/ P7/ 不/ 在/ 缓冲区/ 中/ ,/ 发生/ 第/ 1/ 次/ 脱靶/ ,/ 由于/ 缓冲区/ 已满/ ,/ PB/ -/ LRU/ 算法/ 会/ 选择/ P4/ 作为/ 驱逐/ 页/ ,/ 并/ 将/ P7/ 存放/ 到/ 冷区/ 的/ MRU/ 位置/ ./ 当/ 一个/ 新/ 的/ 请求/ 访问/ P8/ 时/ ,/ 由于/ P8/ 不/ 在/ 缓冲区/ 中/ ,/ 此时/ 发生/ 第/ 2/ 次/ 脱靶/ ,/ 与/ AD/ -/ LRU/ 算法/ 不同/ 的/ 是/ ,/ PB/ -/ LRU/ 此时/ 会/ 选择/ 冷脏页/ P6/ 作为/ 驱逐/ 页/ ,/ 而/ 不会/ 把/ 刚刚/ 进入/ 缓存/ 的/ P7/ 作为/ 驱逐/ 页/ ./ 当/ 第/ 2/ 次访问/ P7/ 时/ ,/ P7/ 命中/ 并/ 成为/ 热页/ ,/ 算法/ 将/ P7/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ,/ 并/ 将/ 热区/ 中/ 的/ P2/ 转移/ 到/ 冷区/ 的/ MRU/ 位置/ ./ 图/ 5/ 显示/ 了/ 采用/ PB/ -/ LRU/ 算法/ 时/ ,/ 在/ 经过/ 上述/ 对/ P7/ ,/ P8/ ,/ P7/ 的/ 访问/ 以后/ 缓冲区/ 的/ 当前/ 状态/ ./ 可以/ 看出/ ,/ 在/ 上述/ 过程/ 中/ ,/ PB/ -/ LRU/ 算法/ 只/ 发生/ 了/ 两次/ 脱靶/ 的/ 情况/ ,/ 性能/ 要/ 优于/ AD/ -/ LRU/ 算法/ ./ 缓冲区/ 替换算法/ PB/ -/ LRU/ 算法/ 是/ 一种/ 朴素/ 算法/ ,/ 它/ 虽然/ 通过/ 基于/ 概率/ 的/ 替换/ 机制/ ,/ 解决/ 了/ CCF/ -/ LRU/ 和/ AD/ -/ LRU/ 算法/ 中/ 存在/ 的/ “/ 干净/ 页/ 刚/ 读入/ 缓冲区/ 就/ 被/ 选择/ 为/ 驱逐/ 页/ ”/ 的/ 情况/ ,/ 但是/ ,/ PB/ -/ LRU/ 算法/ 也/ 存在/ 如下/ 缺陷/ :/ (/ 1/ )/ 寻找/ 干净/ 页/ 的/ 开销/ 较大/ ,/ 该/ 算法/ 在/ 冷区/ 中/ 替换/ 干净/ 页/ 时/ ,/ 必须/ 反向/ 搜索/ 冷区/ 的/ LRU/ 链表/ 来/ 获得/ 一个/ 干净/ 页/ ,/ 当/ LRU/ 链表/ 较长/ 时/ ,/ 时间/ 开销/ 就/ 会/ 比较/ 大/ ;/ (/ 2/ )/ 冷/ 、/ 热区/ 的/ 大小/ 固定/ ,/ 难以/ 适应/ 不同/ 访问/ 模式/ 的/ 工作/ 负载/ ./ 因此/ ,/ 我们/ 提出/ 了/ 针对/ PB/ -/ LRU/ 的/ 改进/ 算法/ —/ —/ —/ 自/ 适应/ 的/ PB/ -/ LRU/ 算法/ ,/ 简称/ APB/ -/ LRU/ (/ AdaptivePB/ -/ LRU/ )/ ./ APB/ -/ LRU/ 针对/ PB/ -/ LRU/ 的/ 改进/ 主要/ 体现/ 在/ 两个/ 方面/ :/ (/ 1/ )/ PB/ -/ LRU/ 在/ 冷区/ 只有/ 一个/ LRU/ 链表/ ,/ 与/ PB/ -/ LRU/ 不同/ 的/ 是/ ,/ APB/ -/ LRU/ 将/ 冷/ 区分/ 为/ 两个/ 链表/ ,/ 即/ 干净/ 页/ 链表/ 和/ 脏页/ 链表/ ,/ 替换/ 干净/ 页/ 时/ 直接/ 获取/ 干净/ 页/ 链表/ 中/ LRU/ 位置/ 的/ 页/ ,/ 避免/ 了/ PB/ -/ LRU/ 算法/ 中/ 反向/ 搜索/ 冷区/ LRU/ 链表/ 的/ 开销/ ,/ 从而/ 加快/ 了/ 驱逐/ 页/ 的/ 查找/ 速度/ ;/ (/ 2/ )/ APB/ -/ LRU/ 能够/ 动态/ 调整/ 冷/ 、/ 热区/ 大小/ 比例/ ,/ 从而/ 可以/ 适应/ 不同/ 访问/ 模式/ 的/ 工作/ 负载/ ./ 4/ 自/ 适应/ 的/ 基于/ 概率/ 的/ 本节/ 内容/ 首先/ 介绍/ APB/ -/ LRU/ 算法/ 的/ 基本/ 思想/ (/ 4.1/ 节/ )/ ,/ 然后/ 详细/ 阐述/ 算法/ 的/ 设计/ (/ 4.2/ 节/ )/ ,/ 最后/ 分析/ 了/ 算法/ 的/ 时间/ 复杂度/ (/ 4.3/ 节/ )/ ./ 4.1/ 改进/ 策略/ PB/ -/ LRU/ 算法/ 存在/ 两个/ 问题/ :/ (/ 1/ )/ 反向/ 搜索/ 冷区/ 的/ LRU/ 链表/ 获取/ 干净/ 页/ 的/ 时间/ 开销/ 较大/ ;/ (/ 2/ )/ 冷/ 、/ 热区/ 大小/ 固定/ ,/ 难以/ 适应/ 不同/ 访问/ 模式/ 的/ 工作/ 负载/ ./ 针对/ 这/ 两个/ 问题/ ,/ 我们/ 提出/ 了/ PB/ -/ LRU/ 算法/ 的/ 改进/ 算法/ ,/ 即/ APB/ -/ LRU/ ./ 针对/ 第/ 1/ 个/ 问题/ ,/ APB/ -/ LRU/ 算法/ 将/ 冷/ 区分/ 成/ 两个/ 链表/ ,/ 即/ 干净/ 页/ 链表/ 和/ 脏页/ 链表/ ,/ 分别/ 存储/ 干净/ 页/ 和/ 脏页/ ./ 当/ 将/ 热区/ 中/ 的/ 一个/ 数据/ 页/ 转移/ 到/ 冷区/ 时/ ,/ 需要/ 先/ 判断/ 该页/ 是/ 脏页/ 还是/ 干净/ 页/ ,/ 如果/ 是/ 干净/ 页/ ,/ Page8/ 就/ 转移/ 到/ 冷区/ 的/ 干净/ 页/ 链表/ 中/ ,/ 如果/ 是/ 脏页/ 就/ 转移/ 到/ 冷区/ 的/ 脏页/ 链表/ 中/ ./ 当/ 发生/ 脱靶/ 要/ 选择/ 一个/ 驱逐/ 页/ 时/ ,/ 需要/ 先/ 通过/ 概率/ 机制/ 来/ 确定/ 替换/ 干净/ 页/ 还是/ 替换/ 脏页/ ,/ 如果/ 确定/ 替换/ 干净/ 页/ (/ 脏页/ )/ ,/ 就/ 直接/ 替换/ 处于/ 干净/ 页/ 链表/ (/ 脏页/ 链表/ )/ 的/ LRU/ 位置/ 的/ 页/ ,/ 从而/ 从根本上/ 避免/ 了/ 反向/ 搜索/ LRU/ 链表/ 的/ 开销/ ,/ 降低/ 了/ 算法/ 的/ 时间/ 复杂度/ ./ 针对/ 第/ 2/ 个/ 问题/ ,/ 我们/ 通过/ 大量/ 实验/ 观察/ 发现/ :/ 当/ 数据/ 访问/ 的/ 局部性/ 较/ 高时/ ,/ 让/ 热区/ 在/ 缓冲区/ 中/ 占据/ 更大/ 的/ 比例/ ,/ 可以/ 使得/ PB/ -/ LRU/ 算法/ 获得/ 更好/ 的/ 性能/ ;/ 当/ 数据/ 访问/ 局部性/ 较/ 低时/ ,/ 让/ 热区/ 在/ 缓冲区/ 中所/ 占/ 比例/ 适当/ 减少/ ,/ 可以/ 使得/ PB/ -/ LRU/ 算法/ 获得/ 更好/ 的/ 性能/ ./ 由此/ ,/ 我们/ 在/ APB/ -/ LRU/ 算法/ 中/ 设计/ 了/ 冷/ 、/ 热区/ 比例/ 动态变化/ 机制/ ,/ 可以/ 根据/ 工作/ 负载/ 的/ 变化/ 动态/ 调整/ 冷/ 、/ 热区/ 所/ 占/ 缓冲区/ 的/ 比例/ ./ 冷/ 、/ 热区/ 所/ 占/ 缓冲区/ 比例/ 动态/ 调整/ 的/ 方法/ 如下/ :/ 事先/ 为/ 冷区/ 和/ 热区/ 设置/ 下界/ ,/ 当冷区/ 中/ 的/ 页/ 命中/ ,/ 就/ 将/ 命中/ 的/ 数据/ 页/ 转移/ 到/ 热区/ ,/ 此时/ 热区/ 的/ 容量/ 增加/ ,/ 冷区/ 的/ 容量/ 减少/ ;/ 当冷区/ 的/ 容量/ 达到/ 了/ 下界/ ,/ 就/ 开始/ 扩展/ 冷区/ ,/ 即将/ 热区/ 中/ 的/ 部分/ 数据/ 页/ 转移/ 到/ 冷区/ ,/ 使得/ 冷区/ 的/ 容量/ 增加/ ,/ 热区/ 的/ 容量/ 减少/ ,/ 如果/ 热区/ 的/ 容量/ 持续/ 减少/ ,/ 最后/ 达到/ 热区/ 的/ 下界/ ,/ 则/ 停止/ 此次/ 扩展/ 过程/ ./ 上面/ 扩展/ 冷区/ 的/ 过程/ ,/ 与/ PB/ -/ LRU/ 算法/ 中/ 热区/ 中/ 的/ 数据/ 转移/ 到/ 冷区/ 的/ 过程/ 类似/ ,/ 具体/ 如下/ :/ 首先/ ,/ 获取/ 热区/ 中/ LRU/ 位置/ 的/ 数据/ 页/ ,/ 如果/ 该页/ 是/ 干净/ 页/ ,/ 就/ 直接/ 将/ 该页/ 转移/ 到/ 冷区/ 的/ MRU/ 位置/ ,/ 如果/ 该页/ 是/ 冷/ 标识/ 位为/ 0/ 的/ 脏页/ ,/ 则/ 给/ 该页/ 第/ 2/ 次/ 机会/ ,/ 将/ 该页/ 的/ 冷/ 标识/ 位/ 设置/ 为/ 1/ ,/ 并/ 转移/ 到/ 热区/ 的/ MRU/ 位置/ ;/ 然后/ ,/ 再次/ 选择/ 热区/ 中/ LRU/ 位置/ 的/ 数据/ 页/ ,/ 如果/ 该页/ 是/ 干净/ 页/ ,/ 或者/ 是/ 冷/ 标识/ 位为/ 0/ 的/ 脏页/ ,/ 就/ 重复/ 上述/ 过程/ ,/ 否则/ ,/ 停止/ 扩展/ ./ 4.2/ 算法/ 设计/ APB/ -/ LRU/ 算法/ 细节/ 如/ 算法/ 3/ 所示/ ./ 在/ APB/ -/ LRU/ 算法/ 中/ ,/ 首先/ 判断/ 冷区/ 容量/ 是否/ 达到/ 下界/ (/ 第/ 1/ 行/ )/ ,/ 如果/ 已经/ 达到/ 下界/ ,/ 则/ 扩展/ 冷区/ 的/ 容量/ (/ 第/ 2/ ~/ 11/ 行/ )/ ./ 在/ 选择/ 驱逐/ 页/ 时/ ,/ 与/ PB/ -/ LRU/ 算法/ 一样/ ,/ 首先/ 生成/ 一个/ 0/ ~/ N/ 的/ 随机数/ ,/ 然后/ 根据/ 该/ 随机数/ 落入/ 的/ 区间/ 确定/ 替换/ 干净/ 页/ 还是/ 脏页/ (/ 第/ 12/ 行/ )/ ,/ 在/ 确定/ 替换/ 脏页/ 或是/ 干净/ 页/ 以后/ ,/ 在/ 相应/ 的/ 链表/ 中/ 进行/ 替换/ (/ 第/ 13/ ~/ 16/ 行/ )/ ./ 算法/ 3/ ./ APB/ -/ LRU/ 算法/ 的/ 伪/ 代码/ ./ 输入/ :/ 当前/ 请求/ 页/ (/ r/ )/ ,/ 冷脏页/ 队列/ (/ Lcd/ )/ ,/ 冷/ 干净/ 页/ 队/ 输出/ :/ 请求/ 页/ 1/ ./ IFLcc/ ./ size/ +/ Lcd/ ./ size/ </ LowerBoundOfColdRegion2/ ./ WHILELh/ ./ size/ >/ LowerBoundOfHotRegionDO3/ ./ p/ ←/ theLRUpageinLh/ ;/ 4/ ./ IFcoldflagofpissetto1THEN5/ ./ moveptotheMRUpositionofLccifpisa6/ ./ BREAK/ ;/ 7/ ./ ELSEIFpiscleanpageTHEN8/ ./ moveptotheMRUpositionofLccifpisa9/ ./ ELSE10/ ./ setthecoldflagofvictim/ ;/ 11/ ./ movevictimtotheMRUpositionofLh/ ;/ 12/ ./ replacePage/ ←/ rand/ (/ )/ %/ (/ Costread/ +/ Costwrite/ )/ </ // // replacePage/ 决定/ 替换/ 一个/ 干净/ 页/ 还是/ 替换/ 一个/ 脏页/ 13/ ./ IF/ (/ replacePage/ =/ =/ 0ANDthereexistscleanpage14/ ./ selectacleanpageasvictiminLcc/ ;/ 15/ ./ ELSE16/ ./ selectadirtypagefromLcdasvictim/ ;/ 17/ ./ removevictimfromLccorLcd/ ;/ 18/ ./ RETURNreferencetovictim/ ./ 4.3/ 算法/ 时间/ 复杂度/ 分析/ 本文/ 的/ PB/ -/ LRU/ 算法/ 每次/ 选择/ 驱逐/ 页/ 时/ 都/ 需要/ 反向/ 搜索/ LRU/ 链表/ ,/ 搜索/ 驱逐/ 页/ 的/ 时间/ 复杂度/ 为/ O/ (/ n/ )/ ,/ 当冷区/ 中/ 的/ 数据/ 页/ 命中/ 时/ ,/ PB/ -/ LRU/ 算法/ 需要/ 使用/ LRU/ -/ WSR/ 算法/ 将/ 热区/ 中/ 的/ 一个/ 数据/ 页/ 转移/ 到/ 冷区/ ,/ 因为/ LRU/ -/ WSR/ 算法/ 的/ 时间/ 复杂度/ 为/ O/ (/ n/ )/ ,/ 所以/ 该/ 转移/ 操作/ 的/ 时间/ 复杂度/ 也/ 为/ O/ (/ n/ )/ ./ 本文/ 的/ 改进/ 算法/ APB/ -/ LRU/ 对/ PB/ -/ LRU/ 算法/ 进行/ 了/ 改进/ ,/ 不/ 需要/ 反向/ 搜索/ LRU/ 链表/ 来/ 获得/ 驱逐/ 页/ ,/ 而是/ 直接/ 选取/ 处于/ 脏页/ 链表/ 或/ 干净/ 页/ 链表/ 的/ LRU/ 位置/ 的/ 页/ 作为/ 驱逐/ 页/ ,/ 所以/ ,/ 选择/ 驱逐/ 页/ 的/ 代价/ 为/ O/ (/ 1/ )/ ./ APB/ -/ LRU/ 算法/ 除了/ 选择/ 驱逐/ 页/ 的/ 开销/ 以外/ ,/ 还/ 存在/ 扩展/ 冷区/ 的/ 开销/ ,/ 即将/ 热区/ 中/ 的/ 数据/ 转移/ 到/ 冷区/ 的/ 开销/ ./ 由于/ APB/ -/ LRU/ 算法/ 使用/ LRU/ -/ WSR/ 算法/ 扩展/ 冷区/ ,/ 所以/ 扩展/ 操作/ 的/ 时间/ 复杂度/ 为/ O/ (/ n/ )/ ./ 但是/ ,/ 扩展/ 操作/ 只有/ 在/ 冷区/ 容量/ 达到/ 下界/ 时才/ 会/ 发生/ ,/ 假设/ 上/ 一次/ 扩展/ 冷区/ 后/ ,/ 冷区/ 的/ 容量/ 比/ 下界/ 大/ N/ ,/ 那么/ 只有/ 在/ 冷区/ 中/ 的/ 数据/ 页/ 命中/ N/ 次后/ (/ 每次/ 命中/ 都/ 会/ 把/ 冷区/ 中/ 命中/ 页/ 转移/ 到/ 热区/ ,/ 使得/ 冷/ Page9/ 区/ 的/ 容量/ 减少/ )/ ,/ 冷区/ 的/ 容量/ 才/ 会/ 再次/ 达到/ 下界/ ,/ 并/ 触发/ 扩展/ 操作/ ,/ 所以/ APB/ -/ LRU/ 算法/ 的/ 平均/ 时间/ 复杂度/ 仍为/ O/ (/ 1/ )/ ./ 5/ 实验设计/ 与/ 结果/ 本/ 节/ 首先/ 介绍/ 了/ 实验/ 的/ 设计/ (/ 5.1/ 节/ )/ ;/ 然后/ 通过/ 实验/ 得到/ 了/ APB/ -/ LRU/ 获得/ 最优性/ 能时/ 的/ 参数/ 配置/ (/ 5.2/ 节/ )/ ;/ 最后/ ,/ 对/ LRU/ 、/ CFLRU/ 、/ LRU/ -/ WSR/ 、/ CCF/ -/ LRU/ 、/ AD/ -/ LRU/ 和/ 本文/ 的/ APB/ -/ LRU/ 算法/ 进行/ 全面/ 详尽/ 的/ 性能/ 比较/ (/ 5.3/ ~/ 5.6/ 节/ )/ ./ 5.1/ 实验设计/ 实验/ 使用/ Flash/ -/ DBSim/ [/ 13/ ]/ ①/ 平台/ 模拟/ 闪存/ 存储系统/ ./ Flash/ -/ DBSim/ 是/ 一种/ 高效/ 的/ 、/ 可/ 重用/ 和/ 可/ 配置/ 的/ 闪存/ 存储系统/ 仿真/ 平台/ ,/ 可以/ 根据/ 上层/ 应用/ 的/ 需要/ 模拟出/ 不同/ 特性/ 的/ 固态/ 盘/ ,/ 从而/ 可以/ 方便/ 地为/ 上层/ 应用/ 提供/ 测试环境/ ,/ 很多/ 已有/ 的/ 研究/ (/ 比如/ 文献/ [/ 11/ -/ 12/ ]/ )/ 都/ 采用/ 了/ 该/ 模拟器/ 进行/ 算法/ 性能/ 的/ 比较/ ./ 我们/ 采用/ 与/ 文献/ [/ 11/ ]/ 一样/ 的/ 参数/ 配置/ 模拟器/ ,/ 即/ 模拟/ 一个/ 128MB/ 的/ NAND/ 闪存/ 固态/ 盘/ ,/ 该/ 固态/ 盘/ 所/ 采用/ 的/ NAND/ 闪存/ 的/ 数据/ 页/ 大小/ 是/ 2KB/ ,/ 每个/ 数据/ 块/ 包含/ 64/ 个/ 数据/ 页/ ,/ 详细/ 设备/ 参数/ 请见表/ 1/ ./ 在/ 进行/ 算法/ 性能/ 比较/ 时/ ,/ 各个/ 缓冲区/ 替换算法/ 的/ 命中率/ 与/ 算法/ 自身/ 的/ 参数设置/ 密切相关/ ./ 本文/ 中/ ,/ CFLRU/ 中/ 的/ 参数/ w/ 取值/ 为/ 0.5/ (/ 即/ 采用/ 文献/ [/ 12/ ]/ 在/ 比较/ AD/ -/ LRU/ 和/ CFLRU/ 时/ 的/ w/ 值/ )/ ,/ AD/ -/ LRU/ 算法/ 中/ 的/ min/ _/ lc/ 取值/ 为/ 0.1/ (/ 与/ 文献/ [/ 12/ ]/ 的/ 取值/ 相同/ )/ ./ 在/ 具体/ 实现/ 时/ ,/ 对于/ 区分/ 冷页/ 和/ 热页/ 的/ 算法/ (/ LRU/ -/ WSR/ 、/ CCF/ -/ LRU/ 和/ AD/ -/ LRU/ )/ ,/ 通过/ 在/ 相关/ 数据结构/ 中/ 添加/ 一个/ 标识/ 位/ ,/ 用于/ 标识/ 该页/ 是/ 热页/ 还是/ 冷页/ ;/ 对于/ 将/ 缓冲区/ 分为/ 多个/ 区/ 的/ 算法/ (/ CCF/ -/ LRU/ 和/ AD/ -/ LRU/ )/ ,/ 在/ 缓冲区/ 链表/ 中/ 插入/ 一个/ 哑/ 节点/ (/ dummynode/ )/ ,/ 用以/ 区分/ 冷区/ 和/ 热区/ ./ Flash/ -/ DBSim/ 通过/ 统计/ 闪存/ 的/ 读/ 次数/ 、/ 写/ 次数/ 和/ 擦除/ 次数/ 以及/ 这些/ 操作/ 所/ 需要/ 的/ 时间/ ,/ 得到/ 总/ 的/ 运行/ 时间/ ,/ 实现/ 了/ 算法/ 间/ 公平/ 的/ 比较/ ./ 每个/ 算法/ 的/ 具体/ 实现/ ,/ 可以/ 参考/ 相关/ 论文/ ./ 通过/ 实验/ 发现/ ,/ 在/ PB/ -/ LRU/ 算法/ 中/ ,/ 对于/ 所有/ 的/ 测试数据/ 集/ ,/ 热区/ 所/ 占/ 比例/ 多于/ 0.99/ 时/ (/ 即/ 冷区/ 所/ 占/ 比例/ 小于/ 0.01/ )/ ,/ 算法/ 性能/ 会/ 明显/ 下降/ ,/ 因此/ APB/ -/ LRU/ 算法/ 将/ 冷区/ 的/ 下界/ 设置/ 为/ 0.01/ ;/ 同时/ ,/ 对于/ 所有/ 的/ 测试数据/ 集/ ,/ 热区/ 所/ 占/ 比例/ 少于/ 0.8/ 时/ ,/ 算法/ 的/ 整体/ 性能/ 也/ 会/ 明显降低/ ,/ 所以/ APB/ -/ LRU/ 算法/ 将/ 热区/ 的/ 下界/ 设置/ 为/ 0.8/ ./ 为了/ 尽可能/ 真实/ 地/ 模拟/ 实际/ 数据库系统/ 运行/ 时/ 的/ 数据/ 页/ 访问/ 模式/ ,/ 我们/ 采用/ 文献/ [/ 14/ ]/ 所用/ 的/ 测试/ 方式/ 进行/ 测试/ ,/ 生成/ 了/ 4/ 种/ 符合/ Zipf/ 分布/ 的/ 测试数据/ ,/ 其/ 统计/ 信息/ 见表/ 2/ ./ 其中/ “/ 读/ // 写/ 比例/ ”/ 这/ 一列/ 中/ 的/ “/ x/ %/ // y/ %/ ”/ 表示/ ,/ 对于/ 某种/ 测试数据/ 集/ 而言/ ,/ 读/ 操作/ 占/ 所有/ 操作/ 的/ x/ %/ ,/ 写/ 操作/ 占/ 所有/ 操作/ 的/ y/ %/ ;/ “/ 局部性/ ”/ 列中/ 的/ “/ x/ %/ // y/ %/ ”/ 表示/ 对/ 某种/ 测试数据/ 而言/ ,/ x/ %/ 的/ 读写操作/ 集中/ 在/ y/ %/ 的/ 数据/ 页/ 上/ [/ 15/ -/ 16/ ]/ ./ 我们/ 采用/ 以下/ 标准/ 来/ 评价/ 缓冲区/ 替换算法/ 的/ 性能/ :/ (/ 1/ )/ 命中率/ ;/ (/ 2/ )/ 物理/ 读/ 操作/ (/ 读/ 闪存/ )/ 的/ 次数/ ;/ (/ 3/ )/ 物理/ 写/ 操作/ (/ 写/ 闪存/ )/ 的/ 次数/ ;/ (/ 4/ )/ 运行/ 时间/ ./ 这里/ 不/ 对/ 擦除/ 操作/ 的/ 次数/ 进行/ 比较/ ,/ 因为/ 擦除/ 操作/ 总是/ 与/ 写/ 操作/ 成正比/ ,/ 通过/ 比较/ 各/ 算法/ 写/ 操作/ 的/ 次数/ 就/ 可以/ 反映/ 出/ 各个/ 算法/ 擦除/ 操作/ 的/ 情况/ ./ 数据/ 集/ 请求/ 次数/ 读写/ 比例/ 局部性/ T1300000090/ %/ // 10/ %/ 60/ %/ // 40/ %/ T2300000030/ %/ // 70/ %/ 70/ %/ // 30/ %/ T3300000060/ %/ // 40/ %/ 60/ %/ // 40/ %/ T4300000080/ %/ // 20/ %/ 80/ %/ // 20/ %/ 5.2/ APB/ -/ LRU/ 算法/ 最佳/ 替换/ 概率/ 的/ 选择/ 本/ 实验/ 测试/ 不同/ 的/ 替换/ 概率/ 对/ APB/ -/ LRU/ 算法/ 性能/ 的/ 影响/ ,/ 从而/ 用来/ 确定/ 算法/ 获得/ 最优性/ 能时/ 的/ 替换/ 概率/ ./ 我们/ 设计/ 了/ 4/ 种/ 不同/ 的/ 情形/ (/ 即/ 情形/ A/ 、/ B/ 、/ C/ 和/ D/ )/ ,/ 表/ 3/ 给出/ 了/ 每种/ 情形/ 下/ 的/ 干净/ 页/ 和/ 脏页/ 的/ 替换/ 概率/ ./ 情形/ AB/ 写/ 代价/ 读/ 代价/ 干净/ 页/ 与/ 脏页/ 的/ 替换/ 概率/ C/ (/ 写/ 代价/ +/ 擦除/ 代价/ )/ 读/ 代价/ 以/ 更/ 大/ 的/ 概率/ 替换/ 干净/ 页/ D/ ①/ Flash/ -/ DBSim/ ./ http/ :/ // // kdelab/ ./ ustc/ ./ edu/ ./ cn/ // flash/ -/ dbsim/ // index/ _/ en/ ./ html/ ,/ retrieved/ ,/ May2009Page10/ 图/ 6/ 展示/ 了/ 缓冲区/ 容量/ 为/ 3MB/ 时/ ,/ 4/ 个/ 测试数据/ 集在/ 不同/ 情形/ 下/ 的/ 运行/ 时间/ ./ 可以/ 看出/ ,/ 对于/ 4/ 个/ 测试数据/ 集/ 而言/ ,/ 采用/ 情形/ C/ 的/ 替换/ 概率/ 设置/ 时/ ,/ APB/ -/ LRU/ 算法/ 在/ 其中/ 的/ 3/ 个/ 数据/ 集/ (/ 即/ T1/ 、/ T2/ 和/ T3/ )/ 都/ 表现/ 出/ 了/ 较/ 好/ 的/ 性能/ ,/ 其中/ ,/ 在/ 数据/ 集/ T1/ 和/ 图/ 6/ 不同/ 替换/ 概率/ 对/ 性能/ 的/ 影响/ 需要/ 强调指出/ 的/ 是/ ,/ 本文/ 后面/ 所有/ 的/ 实验/ 中/ ,/ APB/ -/ LRU/ 算法/ 都/ 采用/ 了/ 情形/ C/ 的/ 替换/ 概率/ 设置/ ./ 5.3/ 命中率/ 图/ 7/ 展示/ 了/ 各个/ 缓冲区/ 替换算法/ 在/ 运行/ 不同/ 的/ 测试数据/ 集时/ 的/ 命中率/ 情况/ ./ 从图/ 中/ 可以/ 看出/ ,/ 在/ 不同/ 的/ 测试数据/ 集/ 和/ 不同/ 的/ 缓冲区/ 容量/ 下/ ,/ 充分考虑/ 数据/ 访问/ 频度/ 的/ 算法/ (/ CCF/ -/ LRU/ 、/ AD/ -/ LRU/ 、/ PB/ -/ LRU/ 和/ APB/ -/ LRU/ )/ ,/ 其/ 命中率/ 明显/ 高于/ 没有/ 考虑/ 数据/ 访问/ 频度/ 的/ 算法/ (/ LRU/ 、/ CFLRU/ 和/ LRU/ -/ WSR/ )/ ,/ 而/ 本文/ 提出/ 的/ PB/ -/ LRU/ 算法/ 命中率/ 在/ 大多数/ 情况/ 下/ 都/ 比/ CCF/ -/ LRU/ 和/ AD/ -/ LRU/ 高/ ,/ 这/ 充分说明/ 基于/ 概率/ 的/ 替换/ 机制/ 是/ 一种/ 行之有效/ 的/ 方法/ ./ 本文/ 提出/ 的/ APB/ -/ LRU/ 算法/ 在/ 所有/ 测试数据/ 集/ 和/ 缓冲区/ 容量/ 下/ ,/ 都/ 取得/ 了/ 最好/ 的/ 命中率/ ./ 例如/ ,/ 在/ 缓冲区/ 容量/ 为/ 5MB/ ,/ 测试数据/ 集为/ T2/ 时/ ,/ 没有/ 考虑/ 数据/ 访问/ 频度/ 的/ 算法/ 命中率/ 在/ 42/ %/ 左右/ ,/ 考虑/ 了/ 数据/ 访问/ 频度/ 的/ 算法/ 命中率/ 达到/ 了/ 53/ %/ ,/ 而/ 本文/ 提出/ 的/ APB/ -/ LRU/ 算法/ 命中率/ 为/ 58/ %/ ,/ 高于/ 其它/ 算法/ ./ 对/ T2/ 中/ ,/ 算法/ 在/ 情形/ C/ 下/ 表现/ 最优/ ,/ 在/ 数据/ 集/ T3/ 中/ ,/ 算法/ 在/ 情形/ C/ 下/ 表现/ 次优/ ./ 相反/ ,/ 采用/ 其它/ 情形/ (/ 即/ 情形/ A/ 、/ B/ 和/ D/ )/ 的/ 概率/ 设置/ 时/ ,/ 算法/ 都/ 不能/ 很/ 好/ 地/ 适应/ 不同/ 的/ 数据/ 集/ ./ 因此/ ,/ 本文/ 采用/ 情形/ C/ 的/ 替换/ 概率/ 来/ 运行/ APB/ -/ LRU/ 算法/ ./ 于/ 考虑/ 了/ 数据/ 访问/ 频度/ 的/ 算法/ ,/ 命中率/ 高于/ 其它/ 算法/ 是因为/ 它们/ 在/ 选择/ 驱逐/ 页/ 时/ ,/ 总是/ 会/ 优先选择/ 冷页/ ,/ 使得/ 热页/ 可以/ 在/ 缓冲区/ 中/ 停留/ 更长/ 的/ 时间/ ,/ 所以/ 提高/ 了/ 命中率/ ./ APB/ -/ LRU/ 算法/ 能够/ 获得/ 更好/ 的/ 命中率/ 是因为/ 它/ 不仅/ 充分考虑/ 了/ 数据/ 访问/ 的/ 频度/ ,/ 而且/ 使用/ 了/ 基于/ 概率/ 的/ 替换/ 机制/ ,/ 能够/ 做到/ 优先/ 替换/ 冷页/ ,/ 让/ 热页/ 有/ 更/ 多/ 的/ 时间/ 驻留/ 缓冲区/ ,/ 同时/ 避免/ 了/ “/ 干净/ 页/ 刚/ 读入/ 缓冲区/ 就/ 被/ 选择/ 为/ 驱逐/ 页/ ”/ 和/ “/ 冷脏页/ 长期/ 驻留/ 缓冲区/ ”/ 的/ 情况/ ,/ 充分利用/ 了/ 缓冲区/ 资源/ ,/ 所以/ 获得/ 了/ 较/ 高/ 的/ 命中率/ ./ 5.4/ 物理/ 读/ 操作/ 次数/ 图/ 8/ 展示/ 了/ 各个/ 缓冲区/ 替换算法/ 在/ 运行/ 不同/ 的/ 测试数据/ 集时/ 的/ 物理/ 读/ 操作/ 次数/ ./ 从图/ 中/ 可以/ 看出/ ,/ 考虑/ 了/ 数据/ 访问/ 频度/ 的/ 算法/ ,/ 其读/ 操作/ 次数/ 远/ 少于/ 没有/ 考虑/ 数据/ 访问/ 频度/ 的/ 算法/ ./ 本文/ 提出/ 的/ 基于/ 概率/ 的/ 替换算法/ (/ PB/ -/ LRU/ 和/ APB/ -/ LRU/ )/ 的/ 读/ 操作/ 次数/ 也/ 少于/ 总是/ 优先/ 替换/ 干净/ 页/ 的/ 算法/ (/ CCF/ -/ LRU/ 和/ AD/ -/ LRU/ )/ ./ 从/ 结果/ 中/ 还/ 可以/ 看出/ ,/ 本文/ 提出/ 的/ 改/ Page11/ 图/ 7/ 在/ 不同/ 测试数据/ 集上/ 的/ 命中率/ 比较/ 图/ 8/ 在/ 不同/ 测试数据/ 集上/ 的/ 物理/ 读/ 操作/ 比较/ 进/ 算法/ (/ APB/ -/ LRU/ )/ 总是/ 优于/ 朴素/ 算法/ (/ PB/ -/ LRU/ )/ ./ 本文/ 提出/ 的/ 采用/ 了/ 自/ 适应/ 机制/ 的/ APB/ -/ LRU/ 算法/ 不仅/ 明显/ 减少/ 了/ 物理/ 读/ 操作/ 的/ 次数/ ,/ 而且/ 在/ 所有/ 测试数据/ 集上/ 都/ 表现/ 出/ 了/ 比较稳定/ 的/ 性能/ ./ 相反/ 地/ ,/ Page12AD/ -/ LRU/ 和/ CCF/ -/ LRU/ 算法/ 在/ 不同/ 的/ 测试数据/ 集上/ 的/ 性能/ 表现/ 不够/ 稳定/ ./ 例如/ ,/ AD/ -/ LRU/ 在/ 测试数据/ 集/ T4/ 上/ 的/ 物理/ 读/ 操作/ 次数/ 明显/ 多于/ CCF/ -/ LRU/ 和/ APB/ -/ LRU/ ,/ 在/ 缓冲区/ 容量/ 为/ 4MB/ ,/ 测试数据/ 集为/ T4/ 时/ ,/ CCF/ -/ LRU/ 和/ APB/ -/ LRU/ 只/ 需要/ 61/ 万次/ 读/ 操作/ ,/ 而/ AD/ -/ LRU/ 需要/ 79/ 万次/ 读/ 操作/ ./ CCF/ -/ LRU/ 也/ 存在/ 表现/ 不/ 稳定/ 的/ 情况/ ,/ 例如/ 在/ 缓冲区/ 容量/ 为/ 4MB/ ,/ 测试数据/ 集为/ T3/ 时/ ,/ APB/ -/ LRU/ 算法/ 只/ 需要/ 214/ 万次/ 读/ 操作/ ,/ AD/ -/ LRU/ 需要/ 217/ 万次/ 读/ 操作/ ,/ 而/ CCF/ -/ LRU/ 需要/ 220/ 万次/ 读/ 操作/ ,/ 多于/ AD/ -/ LRU/ 和/ APB/ -/ LRU/ ./ 5.5/ 物理/ 写/ 操作/ 次数/ 图/ 9/ 展示/ 了/ 各个/ 缓冲区/ 替换算法/ 在/ 执行/ 不同/ 的/ 图/ 9/ 不同/ 测试数据/ 集上/ 的/ 物理/ 写/ 操作/ 比较/ 5.6/ 运行/ 时间/ 图/ 10/ 展示/ 了/ 各个/ 缓冲区/ 替换/ 算/ 在/ 执行/ 不同/ 的/ 测试数据/ 集时/ 的/ 运行/ 时间/ 的/ 比较/ ,/ 包括/ 物理/ 读/ 操作/ 时间/ 、/ 物理/ 写/ 操作/ 时间/ 和/ 闪存/ 中/ 擦除/ 操作/ 的/ 时间/ ./ 本/ 实验/ 中/ 采用/ 了/ 1/ 种/ 面向/ 磁盘/ 的/ 缓冲区/ 替换算法/ (/ LRU/ )/ 和/ 6/ 种/ 面向/ 闪存/ 的/ 缓冲区/ 替换算法/ (/ CFLRU/ 、/ LRU/ -/ WSR/ 、/ CCF/ -/ LRU/ 、/ AD/ -/ LRU/ 、/ PB/ -/ LRU/ 和/ APB/ -/ LRU/ )/ ./ 从图/ 中/ 可以/ 看出/ ,/ 面向/ 闪存/ 的/ 缓冲区/ 替换算法/ 所/ 需要/ 的/ 运行/ 时间/ 远/ 少于/ 面向/ 磁盘/ 的/ 缓冲区/ 替换算法/ LRU/ ,/ 这/ 是因为/ ,/ 面向/ 闪存/ 的/ 缓冲区/ 替换算法/ 会/ 赋予/ 干净/ 页/ 更/ 高/ 的/ 替换/ 优先级/ ,/ 这样/ 做/ 虽然/ 增加/ 闪存/ 读操/ 测试数据/ 集时/ 物理/ 写/ 操作/ 的/ 次数/ ./ 从图/ 中/ 可以/ 看出/ ,/ 考虑/ 了/ 数据/ 访问/ 频度/ 的/ 算法/ (/ CCF/ -/ LRU/ 、/ AD/ -/ LRU/ 、/ PB/ -/ LRU/ 和/ APB/ -/ LRU/ )/ ,/ 其/ 物理/ 写/ 操作/ 的/ 次数/ 明显/ 少于/ 没有/ 考虑/ 数据/ 访问/ 频度/ 的/ 算法/ (/ LRU/ 、/ CFLRU/ 和/ LRU/ -/ WSR/ )/ ./ 此外/ ,/ 本文/ 的/ APB/ -/ LRU/ 算法/ 在/ 所有/ 测试数据/ 集上/ 的/ 物理/ 写/ 操作/ 次数/ 都/ 比/ 其它/ 算法/ 少/ ./ 这/ 是因为/ ,/ 虽然/ APB/ -/ LRU/ 相对/ 于/ 其它/ 算法/ (/ CF/ -/ LRU/ 、/ CCF/ -/ LRU/ 和/ AD/ -/ LRU/ )/ 而言/ ,/ 脏页/ 有/ 更/ 大/ 的/ 机会/ 被/ 选择/ 为/ 驱逐/ 页/ ,/ 但是/ APB/ -/ LRU/ 替换/ 的/ 是/ 冷脏页/ ,/ 将/ 冷脏页/ 尽早/ 替换/ 出/ 缓冲区/ ,/ 充分利用/ 了/ 宝贵/ 的/ 缓冲区/ 资源/ ,/ 从而/ 使得/ APB/ -/ LRU/ 在/ 提高/ 命中率/ 的/ 同时/ ,/ 没有/ 增加/ 物理/ 写/ 操作/ 的/ 次数/ ./ 作/ 的/ 次数/ ,/ 但是/ 减少/ 了/ 闪存/ 的/ 写/ 操作/ 和/ 擦除/ 操作/ 的/ 次数/ ,/ 而/ 闪存/ 的/ 读/ 代价/ 要/ 小于/ 写/ 代价/ ,/ 因此/ 可以/ 获得/ 整体/ 性能/ 的/ 提升/ ./ 在/ 所有/ 的/ 面向/ 闪存/ 的/ 缓冲区/ 替换算法/ 中/ ,/ 考虑/ 了/ 数据/ 访问/ 频度/ 的/ 算法/ (/ CCF/ -/ LRU/ 、/ AD/ -/ LRU/ 、/ PB/ -/ LRU/ 和/ APB/ -/ LRU/ )/ 的/ 运行/ 时间/ ,/ 明显/ 少于/ 没有/ 考虑/ 数据/ 访问/ 频度/ 的/ 算法/ (/ CFLRU/ 和/ LRU/ -/ WSR/ )/ ,/ 其中/ 本文/ 的/ APB/ -/ LRU/ 算法/ 性能/ 表现/ 最好/ ./ 这/ 是因为/ :/ (/ 1/ )/ 该/ 算法/ 使用/ 了/ 基于/ 概率/ 的/ 替换/ 机制/ ,/ 提高/ 了/ 命中率/ ,/ 减少/ 了/ 物理/ 读/ 操作/ 的/ 次数/ 和/ 物理/ 写/ 操作/ 的/ 次数/ ;/ (/ 2/ )/ 该/ 算法/ 使用/ 了/ 冷/ 、/ 热区/ 所/ 占/ 缓冲区/ 比例/ 动态/ 调整机制/ ,/ 能够/ 适应/ 不同/ 访问/ 模式/ 的/ 工作/ 负载/ ./ Page13/ 图/ 10/ 不同/ 测试数据/ 集上/ 的/ 运行/ 时间/ 比较/ 6/ 总结/ 随着/ 闪存/ 技术/ 的/ 发展/ ,/ 闪存/ 数据库系统/ 会/ 越来越/ 普及/ ./ 采用/ 面向/ 闪存/ 的/ 缓冲区/ 替换算法/ 可以/ 有效/ 提高/ 闪存/ 数据库系统/ 的/ 整体/ 性能/ ./ 已有/ 的/ 面向/ 闪存/ 数据库系统/ 的/ 缓冲区/ 替换算法/ ,/ 或者/ 没有/ 充分考虑/ 闪存/ 的/ 特性/ ,/ 或者/ 没有/ 充分利用/ 数据/ 访问/ 的/ 局部性/ 等/ 特征/ ,/ 因此/ 还/ 存在/ 较大/ 的/ 性能/ 提升/ 空间/ ./ 本文/ 首先/ 提出/ 了/ 一种/ 朴素/ 的/ 缓冲区/ 替换算法/ ,/ 即/ PB/ -/ LRU/ 算法/ ,/ 该/ 算法/ 不仅/ 考虑/ 了/ 闪存/ 读写/ 非对称/ 的/ 特性/ ,/ 而且/ 充分利用/ 了/ 数据/ 访问/ 的/ 频度/ 特征/ ,/ 通过/ 以/ 较大/ 的/ 概率/ 替换/ 缓冲区/ 中/ 的/ 干净/ 页/ ,/ 以较/ 小/ 的/ 概率/ 替换/ 缓冲区/ 中/ 的/ 脏页/ ,/ 避免/ 了/ 冷脏页/ 长期/ 驻留/ 缓冲区/ 的/ 情况/ ,/ 从而/ 提高/ 了/ 命中率/ ,/ 获得/ 了/ 较/ 好/ 的/ 整体/ 性能/ ./ 此外/ ,/ 我们/ 通过/ 大量/ 实验/ 发现/ ,/ 对于/ 局部性/ 较/ 高/ 的/ 工作/ 负载/ ,/ 应该/ 赋予/ 热区/ 更大/ 的/ 空间/ ,/ 对于/ 局部性/ 较/ 低/ 的/ 工作/ 负载/ ,/ 热区/ 所/ 占/ 缓冲区/ 比例/ 应该/ 地/ 相应/ 减少/ ,/ 才/ 能够/ 获得/ 更好/ 的/ 性能/ ./ 因此/ ,/ 我们/ 提出/ 了/ 针对/ 朴素/ 算法/ PB/ -/ LRU/ 的/ 改进/ 算法/ APB/ -/ LRU/ ,/ 它/ 能够/ 根据/ 不同/ 的/ 工作/ 负载/ 模式/ ,/ 动态/ 调整/ 冷/ 、/ 热区/ 大小/ ,/ 从而/ 使得/ 替换算法/ 在/ 不同/ 的/ 负载/ 模式/ 下/ 都/ 可以/ 取得/ 较/ 好/ 的/ 性能/ ./ 我们/ 进行/ 了/ 大量/ 的/ 实验/ ,/ 实验/ 结果显示/ APB/ -/ LRU/ 算法/ 具有/ 比/ 其它/ 已有/ 的/ 算法/ 更好/ 的/ 性能/ ./ 本文/ 在/ 研究/ 过程/ 中/ ,/ 和/ 其它/ 已有/ 的/ 替换算法/ (/ 比如/ CFLRU/ 和/ AD/ -/ LRU/ )/ 类似/ ,/ 采用/ 了/ 固定/ 的/ 闪存/ 读写/ 代价/ 比/ ./ 然而/ ,/ 不同/ 的/ 闪存/ 设备/ 的/ 读写/ 代价/ 比是/ 不/ 一样/ 的/ ,/ 我们/ 将/ 在/ 未来/ 的/ 研究/ 工作/ 中/ ,/ 在/ 不同/ 闪存/ 设备/ 上/ 充分/ 测试/ APB/ -/ LRU/ 算法/ 的/ 不同/ 性能/ 表现/ ,/ 从而/ 为/ 不同/ 读写/ 代价/ 比/ 的/ 设备/ 确定/ 最优/ 的/ 参数/ 组合/ ./ 

