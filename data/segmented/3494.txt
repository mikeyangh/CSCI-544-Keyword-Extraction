Page1T/ -/ NBC/ :/ 透明/ 的/ MPI/ 非/ 阻塞/ 集合/ 操作/ 李强/ 1/ )/ ,/ 2/ )/ ,/ 3/ )/ 孙凝晖/ 1/ )/ ,/ 2/ )/ 霍志刚/ 1/ )/ 马捷/ 1/ )/ 1/ )/ (/ 中国科学院计算技术研究所/ 高性能/ 计算机/ 研究/ 中心/ 北京/ 100190/ )/ 2/ )/ (/ 中国科学院/ 计算机系统/ 结构/ 重点/ 实验室/ 北京/ 100190/ )/ 3/ )/ (/ 中国科学院/ 研究生院/ 北京/ 100049/ )/ 摘要/ 在/ 不/ 修改/ 应用程序/ 的/ 前提/ 下/ ,/ 在/ MPI/ 通信/ 库/ 中将/ 阻塞/ 的/ 集合/ 操作/ 转化/ 为/ 非/ 阻塞/ 的/ 实现/ 可以/ 将/ 集合/ 通信/ 与/ 紧跟/ 在/ 集合/ 操作/ 之后/ 的/ 计算/ 重叠/ 起来/ ,/ 从而/ 提高/ 应用/ 的/ 性能/ ./ 在/ 应用/ 中/ ,/ 集合/ 操作/ 之后/ 的/ 计算/ 包括/ 集合/ 通信/ 无关/ 的/ 计算/ 和/ 集合/ 通信/ 相关/ 的/ 计算/ 两类/ ./ 集合/ 通信/ 可以/ 与/ 前者/ 很/ 好/ 地/ 重叠/ ;/ 由于/ 后者/ 需要/ 访问/ 通信/ 数据/ ,/ 与/ 后者/ 的/ 重叠/ 和/ 集合/ 通信/ 中/ 多个/ 集合/ 子/ 消息/ 的/ 通信/ 顺序/ 密切相关/ ./ 在/ 该文/ 中/ ,/ 我们/ 实现/ 了/ 对/ 应用/ 透明/ 的/ 非/ 阻塞/ 集合/ 操作/ T/ -/ NBC/ (/ TransparentNon/ -/ BlockingCollectiveoperations/ )/ ./ T/ -/ NBC/ 不但/ 将/ 集合/ 通信/ 与/ 集合/ 通信/ 无关/ 的/ 计算/ 充分/ 重叠/ 起来/ ,/ 而且/ 为了/ 进一步/ 增大/ 集合/ 通信/ 与/ 集合/ 通信/ 相关/ 计算/ 的/ 重叠/ ,/ 它/ 可/ 根据/ 应用/ 访问/ 多个/ 集合/ 子/ 消息/ 的/ 顺序/ 赋予/ 这些/ 子/ 消息/ 不同/ 的/ 通信/ 优先级/ ./ 微/ 基准/ 测试/ 显示/ ,/ T/ -/ NBC/ 可以/ 将/ 绝大部分/ 的/ 集合/ 通信/ 与/ 集合/ 操作/ 之后/ 的/ 计算/ 重叠/ 起来/ ./ 在/ NPB/ (/ NASParallelBenchmarks/ )/ 测试/ FT/ (/ FourierTransform/ )/ 和/ IS/ (/ IntegerSort/ )/ 中/ ,/ 尽管/ 集合/ 操作/ 之后/ 的/ 计算/ 主要/ 为/ 集合/ 通信/ 相关/ 的/ 计算/ ,/ 但/ 很/ 大部分/ 的/ 集合/ 通信/ 时间/ 被/ 重叠/ ,/ 它们/ 的/ 性能/ 分别/ 提高/ 了/ 5/ %/ 和/ 36/ %/ ./ 关键词/ 透明/ ;/ 非/ 阻塞/ ;/ 集合/ 操作/ ;/ 重叠/ ;/ 优先级/ 1/ 引言/ 在/ 高性能/ 计算/ 应用/ 中/ ,/ MPI/ 已经/ 成为/ 事实上/ 的/ 并行/ 编程/ 标准/ ,/ 它/ 支持/ 多种/ 集合/ 操作/ ./ 基于/ 当前/ 的/ MPI/ 标准/ ,/ 所有/ 参与/ 集合/ 操作/ 的/ 进程/ 都/ 必须/ 阻塞/ 等待/ 集合/ 通信/ 的/ 完成/ ./ 随着/ 系统/ 规模/ 的/ 不断/ 变/ 大/ ,/ 集合/ 通信/ 需要/ 花费/ 越来越/ 多/ 的/ 时间/ ,/ 阻塞/ 的/ 集合/ 操作/ 逐渐/ 成为/ 阻碍/ 应用/ 扩展/ 运行/ 规模/ 的/ 瓶颈/ ./ 为了/ 解决/ 这些/ 问题/ ,/ 未来/ 的/ MPI/ 新/ 标准/ MPI/ -/ 3/ 引入/ 了/ 非/ 阻塞/ 的/ 集合/ 操作/ ①/ ./ 通过/ 非/ 阻塞/ 集合/ 操作/ 的/ 支持/ ,/ 应用/ 开发人员/ 可以/ 显式/ 地/ 将/ 集合/ 通信/ 与/ 计算/ 重叠/ 起来/ ,/ 从而/ 达到/ “/ 隐藏/ ”/ 集合/ 通信/ 时间/ 的/ 目的/ ./ 然而/ ,/ 当前/ 的/ 并行/ 应用/ 都/ 是/ 基于/ MPI/ -/ 1/ 和/ MPI/ -/ 2/ 标准/ 中/ 阻塞/ 的/ 集合/ 操作/ 开发/ 的/ ./ 为了/ 使用/ 非/ 阻塞/ 的/ 集合/ 操作/ ,/ 这些/ 应用/ 必须/ 重新/ 修改/ 它们/ 的/ 程序/ ./ 修改/ 程序/ 首先/ 需要/ 重新/ 设计/ 并行/ 代码/ ,/ 其次/ 需要/ 在/ 大规模/ 系统/ 上/ 对/ 修改/ 的/ 程序/ 进行/ 调试/ ./ 对/ 大多数/ 应用/ 来说/ ,/ 这/ 将/ 是/ 非常/ 巨大/ 的/ 工作量/ ./ 特别/ 是/ ,/ 某些/ 应用/ 很早以前/ 就/ 被/ 开发/ 出来/ ,/ 并且/ 已经/ 运行/ 了/ 很多年/ ./ 因此/ ,/ 在/ 不/ 修改/ 应用/ 的/ 前提/ 下/ ,/ 在/ 通信/ 库中/ 实现/ 透明/ 的/ 非/ 阻塞/ 操作/ T/ -/ NBC/ (/ TransparentNon/ -/ BlockingCollectiveoperations/ )/ 是/ 十分/ 有/ 意义/ 的/ ./ 通过/ T/ -/ NBC/ ,/ 进程/ 在/ 调用/ 集合/ 操作/ 后/ 立即/ 返回/ ,/ 此时/ 集合/ 通信/ 并/ 没有/ 完成/ 或者/ 只是/ 部分/ 完成/ ./ 由于/ 当前/ 的/ 高性能/ 网卡/ 如/ Infiniband/ 网卡/ 支持/ DMA/ (/ DirectMemoryAccess/ )/ ②/ ,/ 通信/ 过程/ 不/ 需要/ CPU/ 的/ 参与/ ,/ 因此/ 剩余/ 的/ 集合/ 通信/ 可以/ 与/ 紧跟/ 在/ 集合/ 操作/ 之后/ 的/ 计算/ 重叠/ 执行/ ,/ 从而/ 达到/ “/ 隐藏/ ”/ 集合/ 通信/ 时间/ 的/ 目的/ ./ 为了/ 实现/ T/ -/ NBC/ ,/ 两/ 方面/ 的/ 问题/ 需要/ 解决/ ./ 一方面/ ,/ 需要/ 保证/ 应用/ 的/ 正确性/ ./ 由于/ 尚未/ 完成/ 的/ 集合/ 通信/ 与/ 集合/ 操作/ 之后/ 的/ 计算/ 并行执行/ ,/ 集合/ 通信/ 缓冲区/ 同时/ “/ 暴露/ ”/ 给/ 集合/ 通信/ 和/ 集合/ 操作/ 之后/ 计算/ ,/ T/ -/ NBC/ 需要/ 保证/ :/ 在/ 要/ 发送/ 的/ 集合/ 消息/ 尚未/ 完成/ 发送/ 之前/ ,/ 集合/ 操作/ 之后/ 计算/ 不会/ 写/ 它/ 的/ 发送缓冲区/ ;/ 或者/ 在/ 要/ 接收/ 的/ 集合/ 消息/ 尚未/ 完成/ 接收/ 之前/ ,/ 集合/ 操作/ 之后/ 的/ 计算/ 不会/ 读写/ 它/ 的/ 接收缓冲区/ ./ 同时/ ,/ 由于/ MPI/ 不/ 支持/ 独立/ 的/ 推动/ (/ IndependentProgress/ )/ ,/ 当/ 集合/ 之后/ 的/ 计算/ 占用/ CPU/ 资源/ 时/ ,/ 集合/ 通信/ 需要/ 获得/ 及时/ 的/ 推动/ ./ 与/ 点到点/ 通信/ 相比/ ,/ 集合/ 通信/ 的/ 推动/ 有/ 很大/ 不同/ ./ 点到点/ 通信/ 只/ 对应/ 一个/ 消息/ ./ 这个/ 消息/ 通信/ 的/ 推动/ ,/ 可以/ 很/ 容易/ 地/ 通过/ 异步/ 线程/ 或者/ 硬件/ 卸载/ (/ Offload/ )/ 技术/ 实现/ ./ 而/ 集合/ 通信/ 对应/ 多个/ 消息/ ./ 比如/ MPI/ _/ Alltoall/ 通信/ ③/ ,/ 假定/ N/ 个/ 进程/ 参与/ 通信/ ,/ 每个/ 进程/ 要/ 发送/ N/ 个/ 不同/ 的/ 消息/ 到/ 所有/ 进程/ ,/ 同时/ 接收/ 来自/ 所有/ 进程/ 的/ N/ 个/ 消息/ ./ 为了/ 方便/ 起/ 见/ ,/ 本文/ 将/ 这些/ 消息/ 称为/ “/ 集合/ 子/ 消息/ ”/ ./ 多个/ 集合/ 子/ 消息/ 通信/ 的/ 推动/ 很难/ 通过/ 简单/ 的/ 异步/ 线程/ 或者/ 硬件/ 卸载/ 技术/ 实现/ ,/ 它们/ 的/ 通信/ 需要/ 合理/ 的/ 管理/ 和/ 调度/ ./ 另一方面/ ,/ 需要/ 提高/ 应用/ 的/ 性能/ ./ 通过/ T/ -/ NBC/ ,/ 可以/ 获得/ 的/ 集合/ 通信/ 与/ 计算/ 的/ 重叠/ 主要/ 取决于/ 集合/ 操作/ 之后/ 的/ 计算/ ./ 它/ 包括/ 集合/ 通信/ 无关/ 的/ 计算/ CURC/ (/ Communication/ -/ UnrelatedComputation/ )/ 和/ 集合/ 通信/ 相关/ 的/ 计算/ CRC/ (/ Communication/ -/ RelatedComputation/ )/ ./ 两者/ 相比/ ,/ CURC/ 不/ 需要/ 访问/ 集合/ 通信/ 缓冲区/ 中/ 的/ 数据/ ,/ 因此/ T/ -/ NBC/ 可以/ 很/ 容易/ 地/ 获得/ 集合/ 通信/ 与/ 它/ 的/ 重叠/ 并/ 带来/ 性能/ 的/ 提升/ ;/ 而/ CRC/ 需要/ 访问/ 集合/ 通信/ 缓冲区/ 中/ 的/ 数据/ ,/ 并且/ 只有/ 在/ 集合/ 通信/ 缓冲区/ 对应/ 的/ 集合/ 子/ 消息/ 完成/ 通信/ 后/ 才能/ 访问/ 相关/ 数据/ ,/ 因此/ T/ -/ NBC/ 可以/ 获得/ 的/ 集合/ 通信/ 与/ 它/ 的/ 重叠/ 是/ 十分复杂/ 的/ ./ 当前/ ,/ 由于/ 通信/ 库/ 与/ 应用/ 实现/ 的/ 不同/ ,/ T/ -/ NBC/ 可以/ 获得/ 的/ 集合/ 通信/ 与/ CRC/ 的/ 重叠/ 是/ 有限/ 的/ ./ 一方面/ ,/ 通信/ 库/ 不/ 清楚/ 应用/ 在/ 集合/ 操作/ 之后/ 对/ 多个/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ ,/ 只能/ 按照/ 既定/ 的/ 集合/ 通信/ 算法/ 进行/ 通信/ ./ 另一方面/ ,/ 应用/ 编写/ 一般/ 独立/ 于/ 具体/ 的/ 通信/ 库/ 实现/ ,/ 应用/ 开发人员/ 不/ 应该/ 对/ 集合/ 通信/ 中/ 多个/ 集合/ 子/ 消息/ 的/ 通信/ 顺序/ 做/ 任何/ 假设/ ./ 因此/ ,/ 集合/ 通信/ 中/ 集合/ 子/ 消息/ 的/ 通信/ 顺序/ 与/ 应用/ 对/ 它们/ 的/ 访问/ 顺序/ 可能/ 会/ 有/ 很大/ 不同/ ./ 在/ 这种/ 情况/ 下/ ,/ 虽然/ 部分/ 集合/ 子/ 消息/ 已经/ 完成/ 通信/ ,/ 但/ 它们/ 可能/ 不是/ CRC/ 当前/ 最/ 期望/ 完成/ 的/ 集合/ 子/ 消息/ ./ 因而/ CRC/ 不能/ 继续/ 往/ 下/ 执行/ ,/ T/ -/ NBC/ 实际/ 获得/ 的/ 集合/ 通信/ 与/ CRC/ 的/ 重叠/ 是/ 有限/ 的/ ./ 在/ 本文/ 中/ ,/ 我们/ 在/ 不/ 修改/ 应用/ 的/ 前提/ 下/ 实现/ 了/ T/ -/ NBC/ ,/ 它/ 包括/ 以下/ 两个/ 方面/ :/ (/ 1/ )/ 关于/ 应用/ 的/ 正确性/ ,/ T/ -/ NBC/ 基于/ 虚拟内存/ 机制/ 实现/ 了/ 对/ 通信/ 缓冲区/ 访问/ 的/ 保护/ ,/ 并且/ 基于/ 集合/ 通信/ 调度表/ ,/ 采用/ 异步/ 线程/ 推动/ 多个/ 集合/ 子/ 消息/ 的/ 通信/ ./ (/ 2/ )/ 关于/ 应用/ 性能/ 的/ 提高/ ,/ 除了/ 较/ 容易/ 获得/ 的/ 集合/ 通信/ 与/ CURC/ 的/ 重叠/ ,/ 为了/ 进一步提高/ 应用/ 的/ 性能/ ,/ T/ -/ NBC/ 对/ 集合/ 通信/ 与/ CRC/ 的/ 重叠/ 进行/ 了/ 优化/ ./ 根据/ 基于/ trace/ 的/ 方法/ (/ Trace/ -/ based/ )/ 获取/ 的/ 应/ ①/ ②/ ③/ Page3/ 用/ 对/ 多个/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ ,/ T/ -/ NBC/ 在/ 集合/ 通信/ 中/ 赋予/ 这些/ 子/ 消息/ 不同/ 的/ 通信/ 优先级/ ,/ 较/ 先/ 被/ 访问/ 的/ 集合/ 子/ 消息/ 被/ 赋予/ 较/ 高/ 的/ 通信/ 优先级/ ./ 因此/ ,/ T/ -/ NBC/ 可以/ 使/ CRC/ 期待/ 的/ 集合/ 子/ 消息/ 较/ 早/ 地/ 完成/ 通信/ ,/ 从而/ 提高/ 了/ 集合/ 通信/ 与/ 它/ 的/ 重叠/ ./ 通过/ 以上/ 措施/ ,/ T/ -/ NBC/ 在/ 不/ 修改/ MPI/ 应用程序/ 的/ 前提/ 下/ ,/ 在/ MPI/ 通信/ 库/ 中将/ 阻塞/ 的/ 集合/ 操作/ 转化/ 为/ 非/ 阻塞/ 的/ 实现/ ./ 它/ 在/ 保证/ 应用/ 的/ 正确/ 执行/ 的/ 前提/ 下/ ,/ 将/ 集合/ 通信/ 与其/ 后面/ 的/ 计算/ 重叠/ 起来/ ,/ 从而/ 很/ 好/ 地/ 提高/ 了/ 应用/ 的/ 性能/ ./ 微/ 基准/ 测试用例/ (/ Micro/ -/ benchmark/ )/ 显示/ ,/ T/ -/ NBC/ 可以/ 将/ 绝大部分/ 的/ 集合/ 通信/ 与/ 集合/ 操作/ 之后/ 的/ 计算/ 重叠/ 起来/ ./ 在/ NPB/ 测试用例/ FT/ (/ FourierTransform/ )/ 和/ IS/ (/ IntegerSort/ )/ 中/ ,/ 尽管/ 集合/ 操作/ 之后/ 的/ 计算/ 主要/ 是/ 集合/ 通信/ 相关/ 的/ 计算/ ,/ 在/ ft/ ./ 64/ ./ C/ ①/ 中/ ,/ 18/ %/ 的/ Alltoall/ 通信/ 时间/ 被/ 重叠/ ,/ 而/ 在/ is/ ./ D/ ./ 128/ ②/ 中/ ,/ 45/ %/ 的/ Alltoallv/ ③/ 通信/ 时间/ 被/ 重叠/ ;/ 它们/ 的/ 性能/ 分别/ 被/ 提高/ 了/ 5/ %/ 和/ 36/ %/ ./ 本文/ 第/ 2/ 节/ 主要/ 介绍/ 相关/ 工作/ ;/ 第/ 3/ 节/ 分析/ T/ -/ NBC/ 带来/ 的/ 集合/ 通信/ 与/ 计算/ 的/ 重叠/ ;/ 第/ 4/ 节/ 阐述/ T/ -/ NBC/ 保证/ 应用/ 正确/ 执行/ 的/ 工作/ 机制/ ;/ 第/ 5/ 节/ 介绍/ T/ -/ NBC/ 提高/ 集合/ 通信/ 与/ CRC/ 重叠/ 的/ 方法/ ;/ 第/ 6/ 节/ 给出/ 实验/ 结果/ ;/ 最后/ 一节/ 总结/ 全文/ 并/ 展望未来/ 工作/ ./ 2/ 相关/ 工作/ 许多/ 研究/ 表明/ ,/ 通过/ 通信/ 与/ 计算/ 重叠/ 的/ 方法/ 可以/ 很/ 好/ 地/ 提高/ 并行/ 应用/ 性能/ [/ 1/ -/ 3/ ]/ ./ 尽管/ 非/ 阻塞/ 集合/ 操作/ 没有/ 包含/ 在/ 当前/ 的/ MPI/ 标准/ 中/ ,/ 文献/ [/ 4/ -/ 7/ ]/ 已经/ 对/ 它们/ 进行/ 了/ 深入研究/ ,/ 并且/ 证明/ 使用/ 非/ 阻塞/ 集合/ 操作/ 可以/ 将/ 集合/ 通信/ 与/ 计算/ 很/ 好/ 地/ 重叠/ 起来/ ./ 由于/ 非/ 阻塞/ 集合/ 操作/ 的/ 性能/ 优势/ ,/ 它/ 将/ 被/ 包含/ 在/ 未来/ 的/ MPI/ -/ 3/ 标准/ 中/ ./ 然而/ ,/ 当前/ 应用/ 都/ 是/ 基于/ MPI/ -/ 1/ [/ 8/ ]/ 和/ MPI/ -/ 2/ [/ 9/ ]/ 编写/ 的/ ,/ 它们/ 必须/ 修改/ 代码/ 才能/ 使用/ 非/ 阻塞/ 集合/ 操作/ ./ 在/ 本文/ 中/ ,/ 我们/ 在/ 不/ 修改/ 代码/ 的/ 前提/ 下/ ,/ 通过/ T/ -/ NBC/ 努力/ 获得/ 非/ 阻塞/ 集合/ 操作/ 所/ 带来/ 的/ 重叠/ 的/ 好处/ ./ 此外/ ,/ T/ -/ NBC/ 所/ 带来/ 的/ 性能/ 提高/ 也/ 可以/ 作为/ 应用/ 采用/ 未来/ MPI/ -/ 3/ 中/ 的/ 非/ 阻塞/ 集合/ 操作/ (/ 通过/ 修改/ 代码/ 的/ 方式/ )/ 所/ 带来/ 的/ 性能/ 提高/ 的/ 一个/ 下界/ ./ 在/ 分布式/ 共享内存/ 的/ 实现/ 中/ ,/ 虚拟内存/ 机制/ 被/ 用来/ 识别/ 和/ 保护/ 对/ 远端/ 内存/ (/ remotememory/ )/ 的/ 访问/ [/ 10/ -/ 11/ ]/ ./ 通过/ 虚拟内存/ 支持/ ,/ 文献/ [/ 12/ ]/ 在/ 消息/ 还/ 没/ 完成/ 接收/ 前/ 就/ 释放/ 了/ 阻塞/ 的/ MPI/ 接收/ 调用/ ,/ 并且/ 采用/ 虚页/ 保护/ 的/ 机制/ 保证/ 程序/ 的/ 正确/ 执行/ ./ 同样/ 借助/ 虚拟内存/ 的/ 支持/ ,/ 文献/ [/ 13/ ]/ 在/ UPC/ 应用/ 中/ 挖掘/ 运行/ 时/ 计算/ 与/ 通信/ 的/ 重叠/ ./ 这些/ 工作/ 主要/ 针对/ 点到点/ 通信/ ,/ 与/ 它们/ 不同/ ,/ 我们/ 的/ 研究/ 对象/ 是/ MPI/ 集合/ 通信/ ./ 与/ 点到点/ 通信/ 相比/ ,/ 集合/ 通信/ 需要/ 处理/ 多个/ 集合/ 子/ 消息/ ,/ 更为/ 复杂/ ./ 一个/ 集合/ 操作/ 包含/ 多个/ 集合/ 子/ 消息/ 的/ 收发/ 操作/ ./ 在/ T/ -/ NBC/ 中/ ,/ 我们/ 借鉴/ 了/ LibNBC/ [/ 4/ ]/ 中/ 的/ 集合/ 通信/ 调度表/ 来/ 管理/ 和/ 调度/ 这些/ 集合/ 子/ 消息/ 的/ 通信/ ,/ 在/ 调度表/ 中/ ,/ 包含/ 所有/ 待/ 推动/ 的/ 集合/ 子/ 消息/ 通信/ ./ 与/ LibNBC/ 不同/ 的/ 是/ ,/ T/ -/ NBC/ 不/ 需要/ 修改/ 应用/ ,/ 并且/ 它/ 根据/ 应用/ 对/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ 赋予/ 这些/ 子/ 消息/ 不同/ 的/ 通信/ 优先级/ ./ 在/ 文献/ [/ 14/ ]/ 中/ ,/ 为了/ 获得/ 更/ 小/ 的/ 延迟/ ,/ 小/ 消息/ 被/ 赋予/ 很/ 高/ 的/ 优先级/ ./ 在/ 本文/ 中/ ,/ 我们/ 根据/ 应用/ 对/ 消息/ 的/ 访问/ 顺序/ ,/ 赋予/ 较/ 先/ 被/ 访问/ 的/ 消息/ 较/ 高/ 的/ 通信/ 优先级/ ,/ 从而/ 使/ 较/ 先/ 被/ 访问/ 的/ 消息/ 可以/ 较/ 早/ 地/ 完成/ 通信/ ./ 3T/ -/ NBC/ 下/ 集合/ 通信/ 与/ 计算/ 的/ 重叠/ 通过/ T/ -/ NBC/ ,/ 应用/ 可以/ 将/ 集合/ 通信/ 与/ 紧跟/ 在/ 集合/ 操作/ 之后/ 的/ 计算/ 重叠/ 起来/ ./ 如/ 引言/ 部分/ 所/ 提到/ 的/ ,/ 集合/ 操作/ 之后/ 的/ 计算/ 包括/ CURC/ 和/ CRC/ ./ CURC/ 可以/ 与/ 集合/ 通信/ 充分/ 重叠/ ;/ 而/ CRC/ 与/ 集合/ 通信/ 的/ 重叠/ 十分复杂/ ./ 在/ 这部分/ 中/ ,/ 我们/ 着重/ 分析/ T/ -/ NBC/ 在/ 不同/ 的/ 场景/ 下/ 带来/ 的/ 重叠/ ,/ 因此/ 为了/ 简化/ 分析/ ,/ 我们/ 分别/ 对/ 计算/ 和/ 集合/ 通信/ 进行/ 了/ 简化/ 的/ 抽象/ ./ 对于/ 计算/ ,/ 假定/ CURC/ 存在/ 于/ CRC/ 之前/ ,/ CURC/ 花费/ 的/ 时间/ 为/ TCURC/ (/ 0/ / TCURC/ )/ ,/ 显然/ 如果/ 没有/ CURC/ 存在/ 于/ CRC/ 之前/ ,/ TCURC/ 等于/ 0/ ./ 针对/ CRC/ ,/ 假定/ CRC/ 以/ 速率/ RCRC/ (/ 0/ / RCRC/ )/ 消费/ 集合/ 通信/ 中/ 的/ 数据/ ./ 对于/ 集合/ 通信/ ,/ 假定/ 集合/ 通信/ 数据/ 的/ 总量/ 为/ Dcomm/ (/ 0/ </ Dcomm/ )/ ,/ 集合/ 通信/ 需要/ 花费/ 的/ 总/ 时间/ 为/ Tcomm/ (/ 0/ </ Tcomm/ )/ ,/ 并且/ 集合/ 通信/ 以/ 速率/ Rcomm/ (/ 0/ </ Rcomm/ )/ 传输/ (/ 生产/ )/ 通信/ 数据/ ,/ 其中/ 通信/ 数据/ 的/ 生产/ 顺序/ 与/ CRC/ 对/ 这些/ 数据/ 的/ 访问/ 顺序/ 一致/ ,/ 它们/ 满足/ 关系/ Dcomm/ =/ Rcomm/ ×/ Tcomm/ ./ 如图/ 1/ 的/ 5/ 个子/ 图/ 所示/ ,/ 在/ 集合/ 通信/ 确定/ 的/ 情况/ 下/ ,/ 即/ Rcomm/ 和/ Tcomm/ 一定/ 的/ 条件/ 下/ ,/ 存在/ 五种/ 不同/ 的/ 场景/ ./ 在/ 所有/ 子图/ 中/ ,/ 集合/ 通信/ 通过/ 固定/ 斜率/ 的/ 线/ ①/ ②/ ③/ Page4/ 段/ 表示/ ./ 对于/ 计算/ ,/ 由于/ CURC/ 部分/ 并/ 不/ 消费/ 通信/ 数据/ ,/ 它/ 通过/ 与/ 时间轴/ 并行/ 的/ 线段/ 表示/ ;/ 而/ CRC/ 部分/ 需要/ 消费/ 通信/ 数据/ ,/ 它/ 通过/ 不同/ 斜率/ 的/ 线段/ 表示/ ./ 在/ 场景/ (/ a/ )/ 、/ (/ d/ )/ 和/ (/ e/ )/ 中/ ,/ 由于/ CURC/ 消费/ 的/ 集合/ 通图/ 1/ (/ 1/ )/ 在/ 场景/ (/ a/ )/ 中/ ,/ 由于/ CURC/ 足够/ 大/ ,/ 并且/ TCURC/ / Tcomm/ ,/ 因此/ 可以/ 获得/ 重叠/ 时间/ Toverlap/ =/ Tcomm/ ./ (/ 2/ )/ 在/ 场景/ (/ b/ )/ 中/ ,/ 由于/ 没有/ CURC/ 存在/ ,/ 并且/ RCRC/ </ Rcomm/ ,/ 因此/ 可以/ 获得/ 的/ 重叠/ 时间/ Toverlap/ =/ Tcomm/ ./ (/ 3/ )/ 在/ 场景/ (/ c/ )/ 中/ ,/ 由于/ 没有/ CURC/ 存在/ ,/ 并且/ RCRC/ >/ Rcomm/ ,/ CRC/ 需要/ 等待/ 通信/ 数据/ 的/ 到达/ ,/ 只有/ 在/ 要/ 访问/ 的/ 数据/ 到达/ 后/ ,/ 它/ 才/ 可以/ 继续执行/ ,/ 这个/ 过程/ 可能/ 重复/ 多次/ ,/ 因此/ 可以/ 获得/ 的/ 重叠/ 时间/ Toverlap/ =/ Tcomm/ ×/ Rcomm/ // RCRC/ ./ (/ 4/ )/ 在/ 场景/ (/ d/ )/ 中/ ,/ 由于/ 0/ </ TCURC/ </ Tcomm/ ,/ 并且/ RCRC/ </ Rcomm/ ,/ 因此/ 可以/ 获得/ 的/ 重叠/ 时间/ Toverlap/ =/ Tcomm/ ./ (/ 5/ )/ 在/ 场景/ (/ e/ )/ 中/ ,/ 由于/ 0/ </ TCURC/ </ Tcomm/ ,/ 并且/ RCRC/ >/ Rcomm/ ,/ 结合/ (/ c/ )/ 中/ 所/ 提到/ 的/ 分析/ ,/ 因此/ 可以/ 获得/ 的/ 重叠/ 时间/ 为/ Toverlap/ =/ TCURC/ +/ Tcomm/ ×/ Rcomm/ // RCRC/ ./ 综合/ 不同/ 场景/ 下/ 所/ 获/ 的/ 重叠/ ,/ 当/ 集合/ 通信/ 的/ 数据/ 按照/ 应用/ 对/ 通信/ 数据/ 的/ 访问/ 顺序/ 进行/ 通信/ 时/ ,/ T/ -/ NBC/ 下/ 集合/ 通信/ 与/ 计算/ 的/ 重叠/ 可以/ 用式/ (/ 1/ )/ 表示/ ./ 根据/ 式/ (/ 1/ )/ ,/ T/ -/ NBC/ 最大/ 可以/ 将/ 整个/ 集合/ 通信/ 重叠/ 起来/ ,/ 最小/ 与/ 应用/ 对/ 通信/ 数据/ 的/ 使用/ 密切相关/ ./ 同时/ ,/ 虽然/ 式/ (/ 1/ )/ 只是/ 基于/ 对/ 应用/ 的/ 简化/ 抽象/ ,/ 但/ 它/ 暗信/ 数据/ 都/ 为/ 0/ ,/ 为了/ 更好/ 区分/ 它们/ ,/ 在/ 图/ (/ a/ )/ 、/ (/ d/ )/ 和/ (/ e/ )/ 中/ 用/ 置于/ 时间轴/ 下方/ 的/ 线段/ 表示/ 它们/ (/ 这些/ 线段/ 只是/ 用来/ 表明/ 它们/ 并/ 不/ 消费/ 通信/ 数据/ )/ ./ 在/ 各种/ 的/ 场景/ 下/ ,/ 集合/ 通信/ 与/ 计算/ 的/ 重叠/ 如下/ 所示/ :/ 示在/ 不同/ 的/ 应用/ 场景/ 中/ ,/ T/ -/ NBC/ 都/ 可以/ 带来/ 潜在/ 的/ 重叠/ 和/ 性能/ 提升/ ./ Toverlap/ =/ Min/ (/ Tcomm/ ,/ TCURC/ +/ Tcomm/ ×/ Rcomm/ // RCRC/ )/ 4T/ -/ NBC/ 保证/ 应用/ 正确/ 执行/ 的/ 工作/ 机制/ 图/ 2/ 显示/ 了/ 应用/ 在/ 采用/ T/ -/ NBC/ 后/ 的/ 执行/ 流程/ ./ 与/ 原来/ 阻塞/ 的/ 集合/ 操作/ 相比/ ,/ 通过/ T/ -/ NBC/ ,/ 集合/ 操作/ 调用/ 在/ 集合/ 通信/ 尚未/ 完成/ 之前/ 就/ 返回/ ,/ 从而/ 剩余/ 的/ 集合/ 通信/ 与/ 集合/ 操作/ 之后/ 的/ 计算/ 并行执行/ ./ 在/ 这/ Page5/ 种/ 情况/ 下/ ,/ 集合/ 通信/ 缓冲区/ 同时/ “/ 暴露/ ”/ 给/ 集合/ 通信/ 和/ 集合/ 操作/ 之后/ 的/ 计算/ ,/ 因此/ 为了/ 保证/ 应用/ 的/ 正确性/ ,/ 在/ 某/ 一/ 通信/ 缓冲区/ 对应/ 的/ 集合/ 子/ 消息/ 尚未/ 完成/ 通信/ 前/ ,/ 需要/ 保护/ 这个/ 通信/ 缓冲区/ 不/ 被/ 集合/ 操作/ 之后/ 的/ 计算错误/ 地/ 访问/ ./ 同时/ ,/ 如图/ 2/ 所示/ ,/ 集合/ 操作/ 之后/ 的/ 计算/ 会/ 占用/ CPU/ ,/ 由于/ MPI/ 没有/ 独立/ 的/ 推动/ ,/ 集合/ 通信/ 需要/ 借助/ 异步/ 线程/ 获得/ 及时/ 的/ 推动/ ./ 4.1/ 基于/ 虚拟内存/ 机制/ 的/ 通信/ 缓冲区/ 保护/ 4.1/ ./ 1/ 基本/ 工作/ 机制/ 由于/ 集合/ 通信/ 缓冲区/ 同时/ “/ 暴露/ ”/ 给/ 集合/ 通信/ 和/ 集合/ 操作/ 之后/ 的/ 计算/ ,/ T/ -/ NBC/ 需要/ 保证/ :/ 在/ 与/ 发送缓冲区/ 对应/ 的/ 集合/ 子/ 消息/ 尚未/ 完成/ 发送/ 之前/ ,/ 集合/ 操作/ 之后/ 的/ 计算/ 不会/ 写/ 这个/ 缓冲区/ ;/ 或者/ 在/ 与/ 接收缓冲区/ 对应/ 的/ 集合/ 子/ 消息/ 尚未/ 完成/ 接收/ 之前/ ,/ 集合/ 操作/ 之后/ 的/ 计算/ 不会/ 读写/ 这个/ 缓冲区/ ./ 在/ 本文/ 中/ ,/ 我们/ 采用/ 虚拟内存/ 机制/ 保护/ 对/ 通信/ 缓冲区/ 的/ 访问/ ./ 操作系统/ 支持/ 进程/ 通过/ mprotect/ 系统/ 调用/ 来/ 控制/ 对/ 虚拟内存/ 页面/ 的/ 访问/ 权限/ ./ 针对/ 某个/ 虚拟内存/ 页面/ ,/ 它/ 的/ 访问/ 权限/ 不是/ NONE/ ,/ 就是/ READ/ 、/ WRITE/ 、/ EXEC/ 这/ 三者/ 中/ 的/ 某些/ 组合/ ./ 当/ 进程/ 执行/ 指令/ 访问/ 某个/ 虚拟/ 页面/ 内/ 的/ 内存地址/ 时/ ,/ 如果/ 指令/ 与/ 虚拟/ 页面/ 的/ 访问/ 权限/ 不/ 匹配/ ,/ CPU/ 就/ 会/ 产生/ 一个/ 保护/ 异常/ ,/ 最终/ 操作系统/ 向/ 进程/ 发送/ 一个/ SIGSEGV/ 信号/ ./ 在/ 初始化/ 阶段/ ,/ T/ -/ NBC/ 通过/ mprotect/ 系统/ 调用/ 分别/ 赋予/ 发送/ 和/ 接收缓冲区/ 不同/ 的/ 权限/ ./ 对于/ 发送缓冲区/ ,/ 它/ 被/ 赋予/ 只读/ (/ READ/ )/ 权限/ ;/ 对于/ 接收缓冲区/ ,/ 它/ 被/ 赋予/ 不可/ 读/ 不可/ 写/ (/ NONE/ )/ 权限/ ./ 由于/ 一个/ 集合/ 操作/ 包含/ 多个/ 集合/ 子/ 消息/ ,/ 为了/ 快速/ 查找/ 某个/ 虚拟地址/ 所/ 对应/ 的/ 子/ 消息/ ,/ 红黑树/ 被/ 用来/ 记录/ 每个/ 子/ 消息/ 地址/ 范围/ (/ 用/ 起始/ 地址/ 和/ 长度/ 表示/ )/ 与子/ 消息/ 的/ 对应/ 关系/ ./ 进程/ 在/ 完成/ T/ -/ NBC/ 初始化/ 后/ ,/ 从/ 通信/ 库/ 返回/ ,/ 并/ 执行/ 集合/ 操作/ 之后/ 的/ 计算/ ./ 当/ 进程/ 接收/ 到/ SIGSEGV/ 信号/ 后/ ,/ 它/ 将/ 调用/ 注册/ 的/ SIGSEGV/ 信号处理/ 函数/ ./ 信号处理/ 函数/ 根据/ 异常/ 的/ 地址/ 查找/ 红黑树/ ,/ 并/ 找到/ 相应/ 的/ 集合/ 子/ 消息/ ./ 如果/ 这个/ 子/ 消息/ 对应/ 的/ 通信/ 已经/ 完成/ ,/ 则/ 重新/ 赋予/ 这个/ 子/ 消息/ 所/ 对应/ 的/ 缓冲区/ 读写/ 权限/ ;/ 否则/ ,/ 信号处理/ 函数/ 需要/ 一直/ 等待/ ,/ 直到/ 这个/ 子/ 消息/ 通信/ 的/ 完成/ ./ 4.1/ ./ 2/ 页面/ 保护/ 粒度/ 存在/ 的/ 问题/ 由于/ mprotect/ 基于/ 页表/ 实现/ ,/ 缓冲区/ 的/ 最小/ 保护/ 粒度/ 是/ 页面/ ./ 当/ 通信/ 缓冲区/ 并/ 不/ 按照/ 页面/ 严格/ 对齐/ 时/ ,/ 在/ 不/ 对齐/ 的/ 页面/ 上/ ,/ 不/ 在/ 缓冲区/ 地址/ 范围/ 的/ 内存空间/ 也/ 被/ 赋予/ 了/ 只读/ READ/ 或者/ NONE/ 权限/ ./ 在/ 这种/ 情况/ 下/ ,/ 如果/ 进程/ 后续/ 的/ 执行/ 需要/ 访问/ 这部分/ 的/ 空间/ ,/ 特别/ 是/ 当/ 这部分/ 空间/ 在/ 进程/ 数据/ 栈上/ 时/ ,/ 进程/ 将/ 不能/ 正常/ 执行/ ./ 为了/ 避免/ 这样/ 的/ 问题/ ,/ 在/ T/ -/ NBC/ 初始化/ 阶段/ ,/ 需要/ 首先/ 完成/ 不/ 对齐/ 的/ 页面/ 所/ 对应/ 的/ 通信/ ,/ 从而/ 在/ 相关/ 通信/ 完成/ 后/ ,/ 可以/ 不/ 对/ 这些/ 页面/ 进行/ 保护/ ./ 在/ 连续/ 的/ 缓冲区/ 中/ ,/ 不/ 对齐/ 的/ 页面/ 只/ 可能/ 存在/ 于/ 起始页/ 和/ 结束/ 页/ ,/ 因此/ 最多/ 有/ 两个/ 页面/ 所/ 对应/ 的/ 通信/ 需要/ 在/ 初始化/ 阶段/ 完成/ ./ 随着/ 集合/ 通信/ 的/ 规模/ 扩大/ ,/ 集合/ 通信/ 的/ 数据/ 增多/ ,/ 两个/ 页面/ 所/ 对应/ 的/ 通信/ 只/ 占/ 整个/ 集合/ 通信/ 的/ 很小/ 一部分/ ./ 4.2/ 基于/ 调度表/ 的/ 异步/ 线程/ 推动/ T/ -/ NBC/ 中/ 集合/ 通信/ 的/ 推动/ 十分复杂/ ./ 它/ 不但/ 需要/ 处理/ 多个/ 集合/ 子/ 消息/ 的/ 收发/ ,/ 还/ 需要/ 处理/ 它们/ 之间/ 的/ 先后/ 依赖/ 关系/ ,/ 例如/ 在/ MPI/ _/ Bcast/ 基于/ 树/ 算法/ 的/ 广播/ 中/ ,/ 中间/ 节点/ 必须/ 在/ 接收/ 到/ 其父/ 节点/ 的/ 集合/ 子/ 消息/ 后/ 才能/ 向/ 其子/ 节点/ 发送/ 集合/ 子/ 消息/ ,/ 因此/ 需要/ 合理/ 地/ 管理/ 和/ 组织/ 这些/ 子/ 消息/ 的/ 通信/ ./ 与此同时/ ,/ MPI/ 没有/ 独立/ 的/ 推动/ ,/ 需要/ 借助/ 异步/ 线程/ 对/ 这些/ 子/ 消息/ 的/ 通信/ 进行/ 及时/ 地/ 推动/ ./ 与/ LibNBC/ [/ 4/ ]/ 类似/ ,/ T/ -/ NBC/ 也/ 采用/ 了/ 集合/ 通信/ 调度表/ 来/ 管理/ 多个/ 集合/ 子/ 消息/ 的/ 通信/ ./ 每/ 一个/ 集合/ 子/ 消息/ 对应/ 调度表/ 中/ 的/ 一个/ 消息/ 项/ ,/ 消息/ 项/ 包含/ 与/ 集合/ 子/ 消息/ 通信/ 相关/ 的/ 所有/ 信息/ :/ {/ 通信/ 缓冲区/ ,/ 消息/ 长度/ ,/ 源/ ,/ 目的地/ ,/ 发送/ 或/ 接收/ ,/ 通信/ 优先级/ }/ ./ 与/ LibNBC/ 不同/ ,/ T/ -/ NBC/ 中/ 的/ 消息/ 项/ 增加/ 了/ 调度/ 优先级/ ,/ 它/ 的/ 作用/ 将/ 在/ 第/ 5/ 节/ 阐明/ ./ 为了/ 保证/ 集合/ 子/ 消息/ 间/ 的/ 先后/ 依赖/ 关系/ ,/ 相应/ 的/ {/ 等待/ }/ 项/ 被/ 插入/ 到/ 调度表/ 中/ ./ {/ 等待/ }/ 项/ 用来/ 确保/ 它/ 前面/ 消息/ 项中/ 的/ 集合/ 子/ 消息/ 通信/ 的/ 完成/ ,/ 只有/ 这些/ 集合/ 子/ 消息/ 的/ 通信/ 完成/ 后/ ,/ 它/ 后面/ 的/ 消息/ 项中/ 的/ 集合/ 子/ 消息/ 通信/ 才/ 能够/ 获得/ 执行/ ./ 通过/ 这种/ 方式/ ,/ 调度表/ 可以/ 保证/ 集合/ 子/ 消息/ 间/ 正确/ 的/ 先后/ 依赖/ 关系/ ./ 基于/ 调度表/ ,/ T/ -/ NBC/ 采用/ 异步/ 线程/ 推动/ 集合/ 子/ 消息/ 通信/ 的/ 执行/ ./ 异步/ 线程/ 被/ 周期性地/ 唤醒/ 并/ 按照/ 调度表/ 执行/ 相应/ 的/ 通信/ 操作/ ,/ 其中/ 通信/ 操作/ 的/ 执行/ 采用/ 非/ 阻塞/ 的/ MPI/ 点到点/ 通信/ 函数/ MPI/ _/ Isend/ 或/ MPI/ _/ Irecv/ ,/ 通过/ 这种/ 方式/ ,/ 异步/ 线程/ 在/ 调用/ 这些/ 函数/ 后/ 可以/ 迅速/ 地/ 释放/ CPU/ ,/ 从而/ 达到/ 通信/ 与/ 计算/ 重叠/ 的/ 目的/ ./ 5T/ -/ NBC/ 提高/ 集合/ 通信/ 与/ CRC/ 重叠/ 的/ 方法/ 由于/ T/ -/ NBC/ 可以/ 很/ 容易/ 地/ 获得/ 集合/ 通信/ 与/ Page6CURC/ 的/ 重叠/ ,/ 为了/ 进一步提高/ 性能/ ,/ 它/ 需要/ 对/ 集合/ 通信/ 与/ CRC/ 的/ 重叠/ 进行/ 优化/ ./ 由于/ CRC/ 需要/ 访问/ 集合/ 通信/ 缓冲区/ 中/ 的/ 数据/ ,/ 如/ 4.1/ 节/ 提到/ 的/ ,/ 为了/ 保护/ 对/ 通信/ 缓冲区/ 的/ 访问/ ,/ 在/ 通信/ 缓冲区/ 所/ 对应/ 集合/ 子/ 消息/ 没有/ 完成/ 通信/ 之前/ ,/ SIGSEGV/ 信号处理/ 函数/ 会/ 一直/ 等待/ ./ 因此/ ,/ 为了/ 使/ 信号处理/ 函数/ 尽快/ 返回/ ,/ 较/ 先/ 被/ CRC/ 访问/ 的/ 缓冲区/ 所/ 对应/ 的/ 集合/ 子/ 消息/ 应该/ 较/ 早/ 地/ 完成/ 通信/ ./ 然而/ ,/ 由于/ 通信/ 库/ 和/ 应用/ 实现/ 的/ 差异/ ,/ 集合/ 通信/ 中/ 多个/ 集合/ 子/ 消息/ 的/ 通信/ 完成/ 顺序/ 与/ 应用/ 对/ 这些/ 子/ 消息/ 的/ 访问/ 顺序/ (/ 即/ CRC/ 的/ 访问/ 集合/ 子/ 消息/ 的/ 顺序/ )/ 并/ 不/ 一致/ ./ 为了/ 解决/ 这个/ 问题/ ,/ 我们/ 首先/ 基于/ trace/ (/ Trace/ -/ based/ )/ 的/ 方法/ 获得/ 应用/ 对/ 多个/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ ,/ 然后/ 在/ T/ -/ NBC/ 中/ 根据/ 获取/ 的/ 访问/ 顺序/ 赋予/ 这些/ 子/ 消息/ 不同/ 的/ 通信/ 优先级/ ,/ 较/ 先/ 被/ 应用/ 访问/ 的/ 消息/ 被/ 赋予/ 较/ 高/ 的/ 通信/ 优先级/ ./ 因此/ ,/ 较/ 先/ 被/ 应用/ 访问/ 的/ 消息/ 可以/ 较/ 早/ 地/ 完成/ 通信/ ,/ 进程/ 可以/ 较/ 早/ 地/ 从/ 信号处理/ 函数/ 返回/ 并/ 继续执行/ CRC/ ,/ 这/ 增加/ 了/ 集合/ 通信/ 与/ CRC/ 的/ 重叠/ ./ 5.1/ 应用/ 对/ 集合/ 子/ 消息/ 访问/ 顺序/ 的/ 获取/ 5.1/ ./ 1/ 基于/ trace/ 的/ 方法/ 我们/ 采用/ 基于/ trace/ 的/ 方法/ 获取/ 应用/ 对/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ ,/ 并/ 将/ 获取/ 的/ 顺序/ 作为/ T/ -/ NBC/ 进一步/ 优化/ 的/ 依据/ ./ 在/ trace/ 的/ 抓取/ 中/ ,/ 应用/ 采用/ 修改/ 过/ 的/ 阻塞/ 集合/ 操作/ 执行/ ./ 在/ 修改/ 过/ 的/ 实现/ 中/ ,/ 在/ 对应/ 的/ 集合/ 通信/ 完成/ 后/ ,/ 集合/ 操作/ 函数/ 并/ 不/ 立即/ 返回/ ./ 在/ 返回/ 前/ ,/ 它/ 首先/ 通过/ mprotect/ 系统/ 调用/ 修改/ 发送缓冲区/ 的/ 权限/ ,/ 赋予/ 它/ 只读/ (/ READ/ )/ 权限/ ,/ 修改/ 接收缓冲区/ 的/ 权限/ ,/ 赋予/ 它/ (/ NONE/ )/ 权限/ ,/ 然后/ 将/ 地址/ 范围/ 与/ 各个/ 集合/ 子/ 消息/ 的/ 对应/ 关系/ 记录/ 在/ 红/ 黑树中/ ,/ 最后/ 记录/ 调用/ 结束/ 的/ 时间/ ,/ 为了/ 减少/ 获取/ 时间/ 的/ 代价/ ,/ 相应/ 的/ 时间/ 通过/ 读取/ 处理器/ TSC/ (/ TimeStampCounter/ )/ 寄存器/ 获取/ ./ 在/ 从/ 集合/ 操作/ 调用/ 返回/ 后/ ,/ 进程/ 继续执行/ ./ 一旦/ 进程/ 接收/ 到/ SIGSEGV/ 信号/ 后/ ,/ 相应/ 的/ 信号处理/ 函数/ 即/ 被/ 调用/ ./ 在/ 信号处理/ 函数/ 中/ ,/ 根据/ 异常/ 地址/ 可以/ 在/ 红/ 黑树中/ 查找/ 到/ 对应/ 的/ 集合/ 子/ 消息/ 并/ 记录/ 它/ 的/ 访问/ 次序/ ,/ 同时/ 可以/ 获得/ 这个/ 子/ 消息/ 的/ 访问/ 时间/ ./ 在/ 这些/ 操作/ 完成/ 之后/ ,/ 信号处理/ 函数/ 重新/ 赋予/ 子/ 消息/ 所/ 对应/ 的/ 缓冲区/ 读写/ 权限/ 并/ 返回/ ./ 值得注意/ 的/ 是/ ,/ trace/ 只/ 记录/ 进程/ 对/ 每个/ 集合/ 子/ 消息/ 的/ 第一次/ 访问/ ./ 在/ 进程/ 结束/ 后/ ,/ 基于/ trace/ 记录/ ,/ 可以/ 得到/ 所有/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ ./ 同时/ ,/ 通过/ 集合/ 调用/ 结束/ 的/ 时间/ 以及/ 每个/ 集合/ 子/ 消息/ 的/ 访问/ 时间/ ,/ 也/ 可以/ 获得/ 集合/ 操作/ 之后/ 的/ 计算/ (/ 即/ CRC/ )/ 访问/ 集合/ 子/ 消息/ 的/ 时间/ 间隔/ ./ 5.1/ ./ 2/ 访问/ 顺序/ 的/ 选择/ 集合/ 操作/ 中/ 的/ 发送缓冲区/ 和/ 接收缓冲区/ 各自/ 有/ 不同/ 的/ 访问/ 顺序/ ,/ 需要/ 选择/ 唯一/ 的/ 一组/ 访问/ 顺序/ 作为/ T/ -/ NBC/ 中/ 赋予/ 集合/ 子/ 消息/ 不同/ 通信/ 优先级/ 的/ 依据/ ./ 为了/ 解决/ 这个/ 问题/ ,/ T/ -/ NBC/ 在/ 初始化/ 阶段/ 对/ 发送缓冲区/ 的/ 保护/ 采用/ 其他/ 的/ 方法/ ./ T/ -/ NBC/ 在/ 初始化/ 阶段/ 分配/ 临时/ 的/ 缓冲区/ ,/ 并/ 将/ 原/ 发送缓冲区/ 的/ 数据/ 拷贝到/ 临时/ 的/ 缓冲区/ 中/ ./ 在/ 拷贝/ 完成/ 后/ ,/ T/ -/ NBC/ 初始化/ 阶段/ 结束/ ,/ 临时/ 的/ 缓冲区/ 作为/ 发送缓冲区/ 参与/ 剩余/ 的/ 集合/ 通信/ ,/ 因此/ 原来/ 的/ 缓冲区/ 可以/ 被/ 集合/ 操作/ 之后/ 的/ 计算/ 正常/ 访问/ ./ 由于/ 拷贝/ 过程/ 与/ 部分/ 集合/ 子/ 消息/ 的/ 通信/ 重叠/ 执行/ (/ 见/ 5.2/ ./ 3/ 节/ )/ ,/ 拷贝/ 过程/ 并/ 没有/ 增加/ 整个/ 集合/ 通信/ 的/ 时间/ ,/ 并且/ 内存/ 的/ 性能/ 很/ 高/ ,/ 初始化/ 阶段/ 的/ 拷贝/ 时间/ 只/ 占/ 整个/ 集合/ 通信/ 时间/ 的/ 很小/ 一部分/ ,/ 在/ 初始化/ 阶段/ 结束/ 之后/ ,/ 仍然/ 有/ 很大/ 比例/ 的/ 集合/ 通信/ 时间/ 可以/ 重叠/ ./ 通过/ 这种/ 方法/ ,/ T/ -/ NBC/ 不再/ 使用/ 虚拟内存/ 机制/ 对原/ 发送缓冲区/ 进行/ 保护/ ,/ 从而/ 也/ 就/ 没有/ 必要/ 获取/ 发送缓冲区/ 对应/ 的/ 访问/ 顺序/ ./ 因此/ ,/ T/ -/ NBC/ 中/ 赋予/ 集合/ 子/ 消息/ 不同/ 通信/ 优先级/ 的/ 依据/ 是/ 接收缓冲区/ 中/ 集合/ 接收/ 子/ 消息/ 的/ 访问/ 顺序/ ./ 5.1/ ./ 3/ 多个/ 进程/ 对/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ 由于/ 多个/ 进程/ 参与/ 集合/ 操作/ ,/ 每个/ 进程/ 都/ 拥有/ 一组/ 对/ 各自/ 接收缓冲区/ 中/ 集合/ 接收/ 子/ 消息/ 的/ 访问/ 顺序/ ./ 假定/ N/ 个/ 进程/ 参与/ 通信/ ,/ 在/ MPI/ 集合/ 操作/ 中/ ,/ 接收缓冲区/ 中/ 集合/ 接收/ 子/ 消息/ 的/ 数目/ 分为/ 两类/ ./ 一类/ 如/ MPI/ _/ Bcast/ ,/ 每个/ 进程/ 只/ 需要/ 接收/ 来自/ 一个/ 进程/ (/ 根/ 进程/ )/ 消息/ ,/ 相应/ 地/ ,/ 它/ 的/ 接收缓冲区/ 只/ 包含/ 一个/ 集合/ 接收/ 子/ 消息/ ,/ 关于/ 这/ 类/ 集合/ 接收/ 子/ 消息/ 访问/ 顺序/ 的/ 处理/ 将/ 在/ 5.2/ ./ 1/ 节/ 阐述/ ./ 另一类/ 如/ MPI/ _/ Alltoall/ ,/ 每个/ 进程/ 需要/ 接收/ 来自/ N/ 个/ 进程/ 的/ 消息/ ./ 对于/ 任意/ 进程/ Pi/ (/ / i/ (/ 0/ / i/ </ N/ )/ ,/ 它/ 的/ 接收缓冲区/ 包含/ N/ 个/ 集合/ 接收/ 子/ 消息/ ,/ 缓冲区/ 中/ 的/ 第/ j/ (/ / j/ (/ 0/ / j/ </ N/ )/ 个/ 集合/ 接收/ 子/ 消息/ 来自/ 于/ 进程/ Pj/ ./ 基于/ trace/ 的/ 方法/ 可以/ 获取/ 进程/ Pi/ 对/ N/ 个/ 集合/ 接收/ 子/ 消息/ 的/ 访问/ 顺序/ 如式/ (/ 2/ )/ 所示/ ./ 该/ 公式/ 表示/ 进程/ Pi/ 依次/ 访问/ 缓冲区/ 中/ 第/ i0/ 个/ 、/ 第/ i1/ 个/ ,/ 依次/ 类推/ ,/ 直到/ 第/ i/ (/ N/ -/ 1/ )/ 个/ 集合/ 接收/ 子/ 消息/ ./ 其中/ ,/ ik/ ∈/ {/ m/ |/ 0/ / m/ </ N/ }/ ,/ 并且/ 如果/ k1/ ≠/ k2/ ,/ 则/ ik1/ ≠/ ik2/ ./ Page7/ 由于/ MPI/ 应用/ 多/ 采用/ 单/ 程序/ 多数据流/ (/ SPMD/ )/ 的/ 模式/ ,/ 在/ 许多/ 应用/ 中/ ,/ 每个/ 进程/ 会/ 使用/ 相同/ 的/ 顺序/ 访问/ N/ 个/ 集合/ 接收/ 子/ 消息/ ,/ 即/ 对于/ 任意/ 的/ 进程/ Pi/ 和/ Pj/ (/ / j/ (/ 0/ / j/ </ N/ )/ ,/ 在/ 它们/ 的/ 访问/ 顺序/ 满足/ ik/ =/ jk/ (/ / k/ (/ 0/ / k/ </ N/ )/ ./ 在/ 本文/ 中/ ,/ 基于/ 访问/ 顺序/ 的/ 优化/ 主要/ 针对/ 所有/ 进程/ 采取/ 相同/ 的/ 顺序/ 访问/ 集合/ 接收/ 子/ 消息/ 的/ 应用/ ./ 5.2/ 赋予/ 集合/ 子/ 消息/ 不同/ 的/ 通信/ 优先级/ 基于/ 应用/ 对/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ ,/ 在/ T/ -/ NBC/ 中/ 不同/ 的/ 集合/ 子/ 消息/ 被/ 赋予/ 不同/ 的/ 通信/ 优先级/ ,/ 较/ 先/ 被/ 应用/ 访问/ 的/ 集合/ 子/ 消息/ 被/ 赋予/ 较/ 高/ 的/ 通信/ 优先级/ ./ 有/ 差别/ 的/ 通信/ 优先级/ 不仅/ 存在/ 于/ 同一/ 进程/ 的/ 多个/ 集合/ 子/ 消息/ 间/ ,/ 而且/ 存在/ 于/ 同一/ 结点/ 上/ 不同/ 进程/ 的/ 集合/ 子/ 消息/ 间/ ./ 5.2/ ./ 1/ 同一/ 进程/ 的/ 集合/ 子/ 消息/ 的/ 通信/ 优先级/ 在/ 同一/ 进程/ 的/ 多个/ 集合/ 子/ 消息/ 间/ ,/ 根据/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ ,/ 赋予/ 较/ 先/ 被/ 应用/ 访问/ 的/ 集合/ 子/ 消息/ 较/ 高/ 的/ 通信/ 优先级/ 相对/ 比较简单/ ./ 这里/ 以/ MPI/ _/ Bcast/ 为例/ ./ 在/ MPI/ _/ Bcast/ 操作/ 中/ ,/ 根/ 进程/ 负责/ 广播/ 消息/ ,/ 非根/ 进程/ 接收/ 来自/ 根/ 进程/ 的/ 广播/ 消息/ ./ 为了/ 获得/ 更好/ 的/ 集合/ 通信/ 与/ 计算/ 的/ 重叠/ ,/ 根/ 进程/ 和/ 非根/ 进程/ 将/ 广播/ 消息/ 需要/ 切/ 分为/ 几个/ 较/ 小/ 的/ 集合/ 子/ 消息/ ./ 如图/ 3/ 所示/ ,/ 广播/ 消息/ 被/ 切分/ 为了/ 4/ 个/ 集合/ 子/ 消息/ ./ 然后/ ,/ 通过/ 基于/ trace/ 的/ 方法/ ,/ 可以/ 获得/ 非根/ 进程/ 对/ 集合/ 接收/ 子/ 消息/ 的/ 访问/ 顺序/ ./ 在/ 图/ 3/ 中/ ,/ 4/ 个集/ 接收/ 子/ 消息/ 的/ 访问/ 顺序/ 为/ {/ 3/ ,/ 1/ ,/ 2/ ,/ 0/ }/ ./ 针对/ 所有/ 非根/ 进程/ 采用/ 相同/ 的/ 顺序/ 访问/ 集合/ 接收/ 子/ 消息/ 的/ 情况/ ,/ 较/ 早/ 被/ 访问/ 的/ 集合/ 接收/ 子/ 消息/ 应该/ 赋予/ 较/ 高/ 的/ 通信/ 优先级/ ,/ 同时/ ,/ 在/ 根/ 进程/ 上/ ,/ 与/ 这些/ 集合/ 接收/ 消息/ 所/ 对应/ 的/ 集合/ 发送/ 子/ 消息/ 也/ 应/ 赋予/ 较/ 高/ 的/ 通信/ 优先级/ ./ 图/ 3/ 分别/ 显示/ 了/ 根/ 进程/ 和/ 非根/ 进程/ 上/ 集合/ 子/ 消息/ 的/ 通信/ 优先级/ ./ 基于/ 不同/ 的/ 通信/ 优先级/ ,/ 较/ 先/ 被/ 访问/ 的/ 集合/ 子/ 消息/ 可以/ 较/ 早/ 地/ 完成/ 广播/ ,/ 非根/ 进程/ 接收/ 到/ 这些/ 子/ 消息/ 后/ ,/ 可以/ 继续执行/ MPI/ _/ Bcast/ 之后/ 的/ CRC/ ;/ 与此同时/ ,/ 较/ 低优先级/ 的/ 集合/ 子/ 消息/ 的/ 广播/ 并行执行/ ./ 在/ 根/ 进程/ 上/ ,/ 由于/ T/ -/ NBC/ 在/ 初始化/ 阶段/ 将/ 发送缓冲区/ 的/ 数据/ 被/ 拷贝到/ 临时/ 的/ 缓冲区/ 中/ ,/ MPI/ _/ Bcast/ 之后/ 的/ CRC/ 可以/ 访问/ 原来/ 的/ 发送缓冲区/ ,/ 它/ 也/ 与/ 集合/ 子/ 消息/ 的/ 广播/ 并行执行/ ./ 当/ 集合/ 消息/ 比较/ 小时/ ,/ 基于/ 切分/ 获得/ 集合/ 子/ 消息/ 的/ 方法/ 并/ 不/ 适用/ ./ 然而/ ,/ 随着/ GPU/ 等/ 加速/ 部件/ 的/ 使用/ ,/ 进程/ 的/ 计算能力/ 增强/ ,/ 进程/ 间/ 需要/ 通信/ 的/ 数据/ 越来越/ 大/ ,/ 因此/ 参与/ 集合/ 通信/ 的/ 消息/ 也/ 会/ 越来越/ 大/ ./ 针对/ 集合/ 消息/ 较大/ 的/ 情况/ ,/ 倘如/ 切分/ 获得/ 的/ 集合/ 子/ 消息/ 的/ 数目/ 为/ m/ (/ m/ >/ 1/ )/ ,/ CRC/ 最大/ 可以/ 重叠/ (/ m/ -/ 1/ )/ 个/ 集合/ 子/ 消息/ 的/ 通信/ 时间/ ,/ 因此/ 最大/ 的/ 重叠/ 比例/ 为/ (/ m/ -/ 1/ )/ // m/ ./ 在/ 图/ 3/ 中/ ,/ 当/ m/ 为/ 4/ 时/ ,/ 最大/ 的/ 重叠/ 比例/ 为/ 75/ %/ ./ 显然/ ,/ 当/ (/ m/ >/ 5/ )/ 后/ ,/ 随着/ m/ 的/ 增大/ ,/ 最大/ 重叠/ 比例/ 的/ 增加/ 并/ 不/ 明显/ ,/ 同时/ ,/ 过多/ 的/ 集合/ 子/ 消息/ 导致/ 消息/ 长度/ 变小/ ,/ 消息/ 传输/ 的/ 代价/ 增大/ ./ 因此/ ,/ 基于/ 切分/ 获得/ 集合/ 子/ 消息/ 的/ 方法/ 适宜/ 采用/ 较/ 小/ 的/ 切分/ 数目/ ./ 5.2/ ./ 2/ 同一/ 结点/ 上/ 不同/ 进程/ 的/ 集合/ 子/ 消息/ 的/ 通信/ 在/ 同一/ 结点/ 上/ 不同/ 进程/ 的/ 集合/ 子/ 消息/ 间/ ,/ 根据/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ ,/ 赋予/ 较/ 先/ 被/ 应用/ 访问/ 的/ 集合/ 子/ 消息/ 较/ 高/ 的/ 通信/ 优先级/ 相对/ 比较复杂/ ./ 当前/ 的/ HPC/ (/ HighPerformanceComputing/ )/ 平台/ 大都/ 采用/ 多核/ 处理器/ ,/ 一个/ 结点/ 上/ 运行/ 多个/ 进程/ ./ 在/ 集合/ 操作/ 中/ ,/ 同一/ 结点/ 内/ 多个/ 进程/ 同时/ 使用/ 网络/ ,/ 每个/ 进程/ 实际/ 获得/ 均分/ 的/ 网络带宽/ ./ 假定/ 每个/ 结点/ 包含/ M/ 个/ 进程/ ,/ 根据/ LogGP/ [/ 15/ ]/ 模型/ ,/ 与/ 只有/ 一个/ 进程/ 独享/ 网络资源/ 相比/ ,/ M/ 个/ 进程/ 均分/ 网络带宽/ 导致/ 一个/ 消息/ 的/ 延迟/ 增加/ 了/ 将近/ M/ 倍/ ./ 为了/ 方便/ 下文/ 的/ 说明/ ,/ 我们/ 假定/ 一个/ 进程/ 独享/ 网络/ 时/ ,/ 一个/ 消息/ 的/ 通信/ 时间/ 为/ T/ ;/ M/ 个/ 进程/ 共享/ 网络/ 时/ ,/ 通信/ 时间/ 为/ (/ M/ ×/ T/ )/ ./ 因此/ ,/ 通过/ 赋予/ M/ 个/ 进程/ 的/ 集合/ 子/ 消息/ 不同/ 的/ 通信/ 优先级/ ,/ 同一/ 时刻/ 同一/ 节点/ 内/ 只有/ 一个/ 集合/ 子/ 消息/ 进行/ 通信/ 并且/ 独享/ 网络带宽/ ,/ 从而/ 使/ 较/ 先/ 被/ 应用/ 访问/ 的/ 集合/ 子/ 消息/ 可以/ 较/ 早/ 的/ 完成/ 通信/ ./ 这里/ 以/ MPI/ _/ Alltoall/ 为例/ ./ 针对/ 所有/ 进程/ 都/ 采用/ 相同/ 的/ 顺序/ 访问/ 接收缓冲区/ 中/ 的/ 集合/ 接收/ 子/ 消息/ 的/ 情况/ ,/ 它们/ 的/ 访问/ 顺序/ 如式/ (/ 2/ )/ 所示/ ,/ 所有/ 进程/ 首先/ 访问/ 各自/ 接收缓冲区/ 中/ 的/ 第/ i0/ 个/ 集合/ 接收/ 子消/ Page8/ 息/ ,/ 这些/ 集合/ 接收/ 子/ 消息/ 与/ 进程/ Pi0/ 上/ 的/ N/ 个/ 集合/ 发送/ 子/ 消息/ 相对/ 应/ ./ 这/ 意味着/ ,/ 每个/ 进程/ 只有/ 在/ 接收/ 到/ 来自/ 进程/ Pi0/ 的/ 集合/ 发送/ 子/ 消息/ 后/ ,/ 才能/ 继续执行/ Alltoall/ 之后/ 的/ CRC/ ./ 因此/ ,/ 进程/ Pi0/ 需要/ 尽快/ 地/ 将/ 它/ 的/ N/ 个/ 集合/ 发送/ 子/ 消息/ 发送到/ 所有/ 进程/ ./ 无论/ Pi0/ 采用/ 何种/ 顺序/ 发送/ N/ 个/ 集合/ 发送/ 子/ 消息/ ,/ 总有/ 一个/ 集合/ 发送/ 子/ 消息/ 被/ 最后/ 发送/ ,/ 假定/ 最后/ 一个/ 集合/ 发送/ 子/ 消息/ 发/ 往/ 进程/ Pj/ ./ 在/ 不/ 采用/ 优化/ 的/ 情况/ 下/ ,/ 同一/ 结点/ 上/ 的/ M/ 个/ 进程/ 的/ 集合/ 子/ 消息/ 没有/ 优先级/ 差别/ ,/ M/ 个/ 进程/ 同时/ 进行/ 消息/ 通信/ 并/ 均分/ 网络带宽/ ./ 进程/ Pi0/ 从/ 调用/ 集合/ 操作/ 到/ 发送/ 完成/ 最后/ 一个/ 集合/ 发送/ 子/ 消息/ 到/ 进程/ Pj/ 需要/ 花费/ 的/ 时间/ 为/ (/ N/ ×/ M/ ×/ T/ )/ ./ 基于/ T/ -/ NBC/ 对/ 缓冲区/ 的/ 保护/ ,/ 进程/ Pj/ 上/ 的/ CRC/ 需要/ 一直/ 等待/ ,/ 直到/ 这个/ 集合/ 发送/ 子/ 消息/ 的/ 到达/ 进程/ Pj/ ./ 然而/ ,/ 在/ 这/ 段时间/ 内/ ,/ Pj/ 上/ 的/ 集合/ 通信/ 并行执行/ ,/ 并且/ 在/ (/ N/ ×/ M/ ×/ T/ )/ 时间/ 后/ ,/ 执行/ 完成/ (/ 发送/ 完成/ 了/ N/ 个/ 集合/ 子/ 消息/ 并/ 同时/ 接收/ 到/ 了/ 来自/ 所有/ 进程/ 的/ N/ 个/ 集合/ 子/ 消息/ )/ ./ 因此/ ,/ 在/ 进程/ Pj/ 上/ ,/ Alltoall/ 通信/ 与/ Alltoall/ 之后/ 的/ CRC/ 实际上/ 并/ 没有/ 获得/ 重叠/ ./ 由于/ 并行/ 应用/ 的/ 性能/ 取决于/ 最慢/ 的/ 进程/ ,/ 在/ 这种/ 情况/ 下/ ,/ 性能/ 由图/ 4Alltoall/ 中/ 集合/ 子/ 消息/ 的/ 优先级/ 5.2/ ./ 3/ 初始化/ 阶段/ 发送缓冲区/ 拷贝/ 与/ 通信/ 的/ 重叠/ 上述/ 的/ 两种/ 基于/ 集合/ 子/ 消息/ 访问/ 顺序/ 的/ 优化/ 方法/ 都/ 需要/ 在/ 初始化/ 阶段/ 将/ 发送缓冲区/ 的/ 数据/ 拷贝到/ 临时/ 的/ 发送缓冲区/ ./ 为了/ 减少/ 拷贝/ 的/ 代价/ ,/ 需要/ 将/ 拷贝/ 过程/ 与/ 部分/ 集合/ 子/ 消息/ 的/ 通信/ 重叠/ 起来/ ./ 在/ T/ -/ NBC/ 初始化/ 阶段/ ,/ 可以/ 将/ 发送缓冲区/ 数据/ 的/ 拷贝/ Pj/ 决定/ ,/ 对于/ 整个/ 应用/ 来说/ ,/ T/ -/ NBC/ 并/ 没有/ 带来/ 应用/ 性能/ 的/ 提升/ ./ 在/ 采用/ 优化/ 的/ 情况/ 下/ ,/ 进程/ 的/ 集合/ 子/ 消息/ 被/ 赋予/ 不同/ 的/ 优先级/ ./ 如图/ 4/ 所示/ ,/ 在/ 同一个/ 结点/ 0/ 上/ ,/ 进程/ Pi0/ 的/ 集合/ 发送/ 子/ 消息/ 被/ 赋予/ 最高/ 的/ 通信/ 优先级/ ,/ 它们/ 首先/ 被/ 传输/ ,/ 并且/ 在/ 传输/ 过程/ 中/ 独占/ 网络/ ./ 因此/ 它/ 发送/ N/ 个/ 集合/ 发送/ 子/ 消息/ 的/ 时间/ 为/ (/ N/ ×/ T/ )/ ,/ 从而/ 进程/ Pj/ 从/ 调用/ 集合/ 操作/ 到/ 接收/ 到/ 来自/ Pi0/ 的/ 集合/ 发送/ 子/ 消息/ 的/ 时间/ 为/ (/ N/ ×/ T/ )/ ./ 为了/ 使/ 其它/ 的/ 结点/ 并行执行/ 通信/ 操作/ (/ 进程/ 分配/ 拓扑/ 如图/ 4/ 所示/ )/ ,/ 并且/ 进程/ Pi1/ ,/ Pi2/ ,/ …/ ,/ Pi/ (/ N/ // M/ -/ 1/ )/ 的/ 集合/ 发送/ 子/ 消息/ 在/ 各自/ 的/ 结点/ 上/ 分别/ 被/ 赋予/ 最高/ 的/ 通信/ 优先级/ ,/ 它们/ 与/ Pi0/ 的/ 集合/ 发送/ 子/ 消息/ 同时/ 被/ 传输/ ./ 通过/ 这种/ 方式/ ,/ 在/ 经过/ (/ N/ ×/ T/ )/ 的/ 时间/ 后/ ,/ 每个/ 进程/ 都/ 获得/ 了/ (/ N/ // M/ )/ 个/ 消息/ ,/ 它们/ 分别/ 是/ 接收缓冲区/ 中/ 的/ 第/ i0/ ,/ i1/ ,/ i2/ ,/ …/ ,/ i/ (/ N/ // M/ -/ 1/ )/ 个/ 消息/ ,/ 这/ 与/ 应用/ 的/ 访问/ 集合/ 接收/ 子/ 消息/ 的/ 顺序/ 一致/ ./ 因此/ ,/ 在/ 接收/ 到/ 这些/ 集合/ 接收/ 子/ 消息/ 后/ ,/ Alltoall/ 之后/ 的/ CRC/ 可以/ 继续执行/ ./ 与此同时/ ,/ 低优先级/ 的/ 集合/ 子/ 消息/ 并行执行/ 它们/ 的/ 通信/ ,/ 它们/ 需要/ 花费/ 的/ 时间/ 为/ (/ (/ M/ -/ 1/ )/ ×/ N/ ×/ T/ )/ ,/ 因此/ CRC/ 最大/ 可以/ 重叠/ (/ (/ M/ -/ 1/ )/ // M/ )/ 的/ 集合/ 通信/ 时间/ ./ 过程/ 与/ 较/ 高/ 优先级/ 的/ 集合/ 子/ 消息/ 的/ 通信/ 相/ 重叠/ ./ 在/ 拷贝/ 过程/ 完成/ 后/ ,/ 初始化/ 阶段/ 结束/ ,/ 集合/ 调用/ 返回/ ./ 通过/ 这种/ 方法/ ,/ 拷贝/ 过程/ 并/ 没有/ 增加/ 集合/ 通信/ 的/ 时间/ ,/ 并且/ 由于/ 内存/ 拷贝/ 的/ 性能/ 高于/ 网络/ 的/ 性能/ ,/ 拷贝/ 的/ 时间/ 只/ 占用/ 集合/ 通信/ 时间/ 的/ 很小/ 一部分/ ./ 因此/ ,/ 在/ 集合/ 调用/ 返回/ 后/ ,/ 绝大部分/ 的/ 集合/ 通信/ 仍然/ 可以/ 与/ Page9/ 计算/ 重叠/ ./ 6/ 性能/ 评测/ T/ -/ NBC/ 基于/ Mvapich/ 库/ ①/ 实现/ ./ 实验/ 平台/ 是/ 拥有/ 16/ 个/ 结点/ 的/ Infiniband/ 网络/ 机群/ ./ 每个/ 节点/ 使用/ 2/ 路/ 6/ 核/ 的/ 2666MHzIntel/ (/ R/ )/ Xeon/ (/ R/ )/ X5650/ 处理器/ ,/ 并且/ 拥有/ 一块/ 40Gb/ // s/ 的/ MellanoxCon/ -/ nectXMT26428HCA/ 网卡/ ./ 它们/ 通过/ 曙光/ QDRHSSM36/ 端口/ 的/ 交换机/ ②/ 连接起来/ ./ 操作系统/ 为/ centos5/ ./ 3/ ,/ 内核/ 版本/ 为/ 2.6/ ./ 18/ -/ 128/ ./ e15/ ./ 6.1/ T/ -/ NBC/ 消息/ 缓冲区/ 保护/ 开销/ 6.1/ ./ 1/ 基于/ 虚拟内存/ 机制/ 的/ 消息/ 缓冲区/ 保护/ 开销/ 基于/ 虚拟内存/ 机制/ 的/ 消息/ 缓冲区/ 保护/ 开销/ 主要/ 与/ mprotect/ 系统/ 调用/ 和/ CPU/ 的/ 段/ 保护/ 异常/ 处理/ 有关/ ./ mprotect/ 系统/ 调用/ 需要/ 修改/ 页表/ ,/ 并且/ 会/ 刷新/ TLB/ 相应/ 的/ 表项/ ;/ 而段/ 保护/ 异常/ 的/ 处理/ 需要/ 调用/ 中断/ 处理程序/ ./ 图/ 5/ (/ a/ )/ 显示/ 这/ 两个/ 操作/ 的/ 时间/ 以及/ 消息/ 通信/ 的/ 时间/ ,/ 其中/ 由于/ Infiniband/ 网络/ 支持/ RDMA/ (/ RemoteMemoryDirectAccess/ )/ ,/ 消息/ 通信/ 采用/ RDMA/ 完成/ ./ 在/ 现代/ 的/ CPU/ 处理器/ 和/ 操作系统/ 中/ ,/ mprotect/ 系统/ 调用/ 和/ 中断/ 处理/ 都/ 花费/ 很小/ 的/ 时间/ ./ 如图/ 5/ (/ a/ )/ 所示/ ,/ 在/ 消息/ 小于/ 256KB/ 时/ ,/ mprotect/ 需要/ 修改/ 的/ 页表/ 项/ 数目/ 小于/ 64/ (/ 页面/ 大小/ 为/ 4KB/ )/ ,/ 它/ 所/ 花费/ 的/ 时间/ 小于/ 1/ μ/ s/ ./ 同时/ ,/ 中断/ 处理/ 的/ 时间/ 为/ 2/ μ/ s/ ./ 当/ 消息/ 长度/ 小于/ 256/ 字节/ 时/ ,/ mprotect/ 系统/ 调用/ 和/ 中断/ 处理/ 的/ 时间/ 之/ 和/ 大于/ 消息/ 通信/ 的/ 时间/ ./ 在/ 这种/ 情况/ 下/ ,/ 由于/ 消息/ 缓冲区/ 的/ 保护/ 开销/ 大于/ 消息/ 的/ 通信/ 时间/ ,/ 因此/ 不/ 适宜/ 采用/ T/ -/ NBC/ ./ 然而/ ,/ 当/ 消息/ 长度/ 大于/ 256B/ 时/ ,/ 消息/ 缓冲区/ 的/ 保护/ 开销/ 小于/ 消息/ 的/ 通信/ 时间/ ./ 随着/ 消息/ 长度/ 的/ 增加/ ,/ 它们/ 之间/ 的/ 差距/ 越来越/ 大/ ,/ 并且/ 当/ 消息/ 长度/ 大于/ 4KB/ 时/ ,/ 采用/ T/ -/ NBC/ 最大/ 可以/ 重叠/ 绝大部分/ 消息/ 通信/ 时间/ ./ 6.1/ ./ 2/ 基于/ 内存/ 拷贝/ 的/ 发送缓冲区/ 保护/ 开销/ 针对/ 优化/ 集合/ 通信/ 与/ CRC/ 重叠/ 的/ 情况/ ,/ T/ -/ NBC/ 在/ 初始化/ 阶段/ 需要/ 将/ 发送缓冲区/ 的/ 数据/ 拷贝到/ 临时/ 的/ 发送缓冲区/ ./ 图/ 5/ (/ b/ )/ 分别/ 显示/ 了/ 消息/ 拷贝/ 与/ RDMA/ 通信/ 所/ 花费/ 的/ 时间/ ./ 从图/ 5/ (/ b/ )/ 中/ 可以/ 看出/ ,/ 消息/ 拷贝/ 所/ 花费/ 的/ 时间/ 占/ 相应/ 消息/ 通信/ 时间/ 的/ 比例/ 不/ 超过/ 40/ %/ ./ 由于/ 本/ 实验/ 平台/ 中/ 的/ 每个/ 结点/ 采用/ 双路/ CPU/ ,/ 两个/ CPU/ 上/ 的/ 进程/ 可以/ 并行/ 进行/ 拷贝/ ;/ 与此同时/ ,/ 每个/ 结点/ 只/ 拥有/ 一个/ 网卡/ ,/ 两个/ CPU/ 上/ 的/ 进程/ 需要/ 共享/ 网络带宽/ ,/ 因此/ 集合/ 通信/ 中/ 所有/ 消息/ 的/ 拷贝/ 时间/ 占/ 它们/ 通信/ 总/ 时间/ 的/ 比例/ 不/ 超过/ 20/ %/ ./ 这/ 意味着/ ,/ 即使/ 采用/ 发送缓冲区/ 拷贝/ 的/ 方法/ ,/ 仍然/ 有/ 接近/ 80/ %/ 的/ 集合/ 通信/ 时间/ 可以/ 重叠/ ./ 结合/ 接收缓冲区/ 基于/ 虚拟内存/ 机制/ 的/ 保护/ 开销/ ,/ 在/ 消息/ 大于/ 4KB/ 时/ ,/ 采用/ 优化/ 的/ 方法/ 的/ T/ -/ NBC/ 仍然/ 可以/ 重叠/ 绝大部分/ 集合/ 通信/ 时间/ ./ 6.2/ 微/ 基准/ 测试通过/ 微/ 基准/ 测试用例/ ,/ 我们/ 验证/ T/ -/ NBC/ 在/ 不同/ 的/ 场景/ 下/ 可以/ 获得/ 的/ 集合/ 通信/ 与/ 计算/ 的/ 重叠/ ./ 微/ 基准/ 测试用例/ 的/ 伪/ 代码/ 如图/ 6/ 所示/ ./ 基准/ 测试用例/ 中/ 的/ MPI/ 集合/ 操作/ 采用/ 固定/ 的/ 进程/ 数目/ 执行/ ,/ 并且/ 采用/ 固定/ 大小/ 的/ 消息/ ,/ 这样/ 可以/ 保证/ 集合/ 操作/ 的/ 时间/ Tcomm/ 和/ 集合/ 通信/ 的/ 总/ 数据量/ Dcomm/ 是/ 固定/ 的/ ./ 然后/ 通过/ 调整/ CURC/ 和/ CRC/ 的/ 计算/ 量/ ,/ 就/ 可以/ 获得/ 如图/ 1/ 所示/ 的/ 不同/ 的/ 场景/ ./ 在/ 本文/ 中/ ,/ 微/ 基准/ 测试用例/ 重点/ 测试/ 相对/ 比较复杂/ 的/ ①/ ②/ Page10MPI/ _/ Alltoall/ 操作/ ./ 它/ 采用/ 64/ 个/ 进程/ 执行/ ,/ 每个/ 结点/ 上/ 运行/ 8/ 个/ 进程/ ,/ 消息/ 的/ 大小/ 为/ 1MB/ 字节/ ./ 通过/ 测试/ 可以/ 得到/ Tcomm/ 为/ 268ms/ ,/ Dcomm/ 为/ 64MB/ 字节/ ,/ 而/ 集表/ 1/ 不同/ 场景/ 下/ T/ -/ NBC/ 获得/ 的/ 重叠/ 时间/ TCURC/ / Tcomm/ ;/ TCURC/ =/ 445msTCURC/ =/ 0/ ,/ RCRC/ </ Rcomm/ ;/ RCRC/ =/ 64MB/ // 350ms617TCURC/ =/ 0/ ,/ RCRC/ >/ Rcomm/ ;/ RCRC/ =/ 64MB/ // 175ms4390/ </ TCURC/ </ Tcomm/ ,/ RCRC/ </ RcommTCURC/ =/ 177ms/ ,/ RCRC/ =/ 64MB/ // 350ms0/ </ TCURC/ </ Tcomm/ ,/ RCRC/ >/ Rcomm/ ;/ TCURC/ =/ 177ms/ ,/ RCRC/ =/ 64MB/ // 175ms/ 在/ 实际/ 的/ T/ -/ NBC/ 实现/ 中/ ,/ T/ -/ NBC/ 必须/ 在/ 完成/ 初始化/ 阶段/ 对/ 集合/ 通信/ 缓冲区/ 的/ 保护/ 后/ 才能/ 返回/ ./ 对于/ Alltoall/ 操作/ ,/ 如/ 6.1/ 节所/ 提到/ 的/ ,/ T/ -/ NBC/ 缓冲区/ 的/ 保护/ 开销/ 主要/ 来自/ 于/ 发送缓冲区/ 数据/ 的/ 拷贝/ ./ 当/ 消息/ 长度/ 为/ 1MB/ 时/ ,/ 拷贝/ 时间/ 约/ 占/ 集合/ 通信/ 总/ 时间/ 的/ 20/ %/ ./ 在/ 微/ 基准/ 测试用例/ 中/ ,/ 通过/ 统计/ MPI/ 集合/ 操作/ 返回/ 的/ 时间/ ,/ 可以/ 得出/ 初始化/ 阶段/ 花费/ 的/ 时间/ 为/ 60ms/ ,/ 占/ 总/ 的/ 集合/ 通信/ 时间/ 的/ 22/ %/ ,/ 稍/ 大于/ 拷贝/ 开销/ ,/ 再/ 考虑/ 到/ 基于/ 虚拟内存/ 机制/ 的/ 接收缓冲区/ 保护/ 开销/ ,/ 初始化/ 阶段/ 开销/ 与/ 6.1/ 节/ 的/ 分析/ 基本一致/ ./ 只有/ T/ -/ NBC/ 完成/ 初始化/ 返回/ 后/ ,/ 所有/ 进程/ 才/ 会/ 执行/ 紧跟/ 在/ 集合/ 操作/ 后面/ 的/ 计算/ ,/ 因此/ T/ -/ NBC/ 可以/ 获得/ 最大/ 重叠/ 时间/ 需要/ 减去/ 初始化/ 阶段/ 的/ 开销/ Tinit/ ./ 在/ 本/ 实验/ 中/ ,/ Tinit/ 等于/ 60ms/ ./ 同时/ ,/ 在/ 初始化/ 阶段/ ,/ 发送缓冲区/ 的/ 拷贝/ 过程/ 与/ 较/ 高/ 优先级/ 的/ 集合/ 子/ 消息/ 通信/ 并行执行/ ,/ 而/ 最高/ 优先级/ 的/ 集合/ 子/ 消息/ 完成/ 通信/ 时间/ 为/ 268ms/ // 8/ 等于/ 33.5/ ms/ ,/ 小于/ Tinit/ ./ 在/ T/ -/ NBC/ 初始化/ 阶段/ 返回/ 后/ ,/ 所有/ 的/ 进程/ 都/ 获得/ 了/ 最先/ 访问/ 的/ 集合/ 子/ 消息/ ,/ 可以/ 执行/ 后面/ 的/ 计算/ ./ 通过/ 分析/ 表/ 1/ 所/ 给出/ 的/ 不同/ 场景/ ,/ 它们/ 都/ 满足/ 式/ (/ 3/ )/ ,/ 与/ 式/ (/ 1/ )/ 相比/ ,/ 实际/ 的/ T/ -/ NBC/ 实现/ 所/ 获得/ 的/ 重叠/ 需要/ 减去/ 缓冲区/ 保护/ 的/ 开销/ ./ 对于/ Bcast/ ,/ 其/ T/ -/ NBC/ 实现/ 与/ Alltoall/ 类似/ ,/ 也/ 需要/ 在/ 初始化/ 阶段/ 对/ 集合/ 通信/ 缓冲区/ 进行/ 保护/ ./ 因此/ ,/ 在/ 采用/ T/ -/ NBC/ 后/ ,/ 通过/ 测试/ 发现/ ,/ 其/ 获得/ 的/ 重叠/ 也/ 符合/ 式/ (/ 3/ )/ ,/ 为了/ 简明/ 起/ 见/ ,/ 我们/ 没有/ 在/ 本文/ 中/ 罗列/ 类似/ 结果/ ./ Toverlap/ =/ min/ (/ Tcomm/ -/ Tinit/ ,/ TCURC/ +/ Tcomm/ ×/ Rcomm/ // RCRC/ )/ 6.3/ NPB/ 测试/ 在/ NPB/ 测试用例/ 中/ ,/ FT/ 和/ IS/ 的/ 性能/ 在/ 很大/ 程度/ 上/ 取决于/ 它们/ 中/ 的/ 集合/ 操作/ 性能/ ,/ 因此/ T/ -/ NBC/ 合/ 通信/ 速率/ Rcomm/ 为/ (/ Dcomm/ // Rcomm/ )/ ,/ 即/ 64MB/ // 268ms/ ./ 表/ 1/ 显示/ 了/ 采用/ 不同/ 的/ CURC/ 和/ CRC/ 情况/ 下/ ,/ T/ -/ NBC/ 可以/ 获得/ 的/ 重叠/ ./ 856411332588414/ 可以/ 提高/ 它们/ 的/ 性能/ ./ 在/ FT/ 中/ ,/ MPIAlltoall/ 集合/ 操作/ 被/ 使用/ ./ 通过/ 基于/ trace/ 的/ 方法/ 发现/ ,/ 所有/ 进程/ 在/ Alltoall/ 调用/ 返回/ 后/ 采用/ 相同/ 的/ 访问/ 顺序/ 访问/ 接收缓冲区/ 中/ 集合/ 接收/ 子/ 消息/ ,/ 访问/ 顺序/ 为/ {/ 0/ ,/ 1/ ,/ 2/ ,/ 3/ …/ (/ N/ -/ 1/ )/ }/ ,/ 即/ 每个/ 进程/ 首先/ 访问/ 各自/ 接收缓冲区/ 中/ 的/ 0/ 号/ 集合/ 接收/ 子/ 消息/ ,/ 然后/ 是/ 1/ 号/ 集合/ 接收/ 子/ 消息/ ,/ 依次/ 类推/ ,/ 最后/ 为/ (/ N/ -/ 1/ )/ 号/ 集合/ 接收/ 子/ 消息/ ./ 同时/ ,/ 基于/ trace/ 的/ 方法/ 可以/ 获得/ 每个/ 集合/ 接收/ 子/ 消息/ 的/ 第一次/ 被/ 访问/ 的/ 时间/ ,/ 图/ 7/ 显示/ 了/ ft/ ./ C/ ./ 32/ 中/ 阻塞/ 的/ Alltoall/ 返回/ 后/ ,/ 所有/ 进程/ 中/ 32/ 个/ 集合/ 接收/ 子/ 消息/ 第一次/ 被/ 访问/ 的/ 平均/ 时间/ ./ 如图/ 7/ 所示/ ,/ 相对/ 于/ Alltoall/ 集合/ 通信/ 时间/ ,/ 集合/ 接收/ 子/ 消息/ 会/ 在/ Alltoall/ 返回/ 后/ 的/ 很/ 短时间/ 内/ 被/ Alltoall/ 之后/ 的/ 计算所/ 访问/ ,/ 并且/ 访问/ 集合/ 接收/ 子/ 消息/ 的/ 时间/ 间隔/ 很/ 短/ ,/ 这/ 说明/ Alltoall/ 之后/ 的/ 计算/ 主要/ 是/ 与/ 集合/ 通信/ 相关/ 的/ 计算/ (/ CRC/ )/ ./ 与/ ft/ ./ C/ ./ 32/ 类似/ ,/ 在/ ft/ ./ C/ ./ 64/ 和/ ft/ ./ D/ ./ 128/ 中/ ,/ Alltoall/ 之后/ 的/ 计算/ 也/ 主要/ 是/ CRC/ ./ 因此/ 针对/ 这些/ 应用/ ,/ T/ -/ NBC/ 按照/ 集合/ 接收/ 子/ 消息/ 的/ 访问/ 顺序/ 赋予/ 集合/ 子/ 消息/ 不同/ 的/ 通信/ 优先级/ ./ 图/ 7/ 集合/ 接收/ 子/ 消息/ 的/ 第一次/ 被/ 访问/ 的/ 时间/ 如图/ 8/ 所示/ ,/ 与/ 原来/ 的/ 阻塞/ Alltoall/ 相比/ ,/ T/ -/ NBC/ 实现/ 了/ 集合/ 通信/ 与/ 集合/ 操作/ 之后/ 的/ 计算/ 的/ Page11/ 重叠/ ,/ 其中/ 图/ 8/ 中所/ 给出/ 的/ 时间/ 为/ 相应/ 操作/ 在/ FT/ 中/ 的/ 总/ 执行/ 时间/ ./ 如图/ 8/ 所示/ ,/ 在/ 不同/ 的/ 测试/ 规模/ 和/ 进程/ 数下/ ,/ 通过/ T/ -/ NBC/ ,/ Alltoall/ 调用/ 的/ 总/ 时间/ 不/ 超过/ 原来/ 阻塞/ Alltoall/ 调用/ 时间/ 的/ 20/ %/ ,/ 这部分/ 时间/ 主要/ 用来/ 进行/ T/ -/ NBC/ 初始化/ ,/ 剩余/ 80/ %/ 的/ 集合/ 通信/ 可以/ 与/ 集合/ 操作/ 之后/ 的/ 计算/ 重叠/ ./ 在/ 采用/ T/ -/ NBC/ 后/ ,/ Alltoall/ 调用/ 时间/ 和/ Alltoall/ 之后/ 的/ 计算/ 的/ 时间/ 比/ 原来/ 的/ 阻塞/ Alltoall/ 调用/ 时间/ 和/ 计算/ 的/ 执行/ 时间/ 减少/ 了/ 10/ %/ ./ 这/ 证明/ 采用/ T/ -/ NBC/ 后/ ,/ 集合/ 通信/ 与/ 集合/ 操作/ 之后/ 计算/ 重叠/ 执行/ ,/ 部分/ 集合/ 通信/ 时间/ 被/ “/ 隐藏/ ”/ ./ 在/ ft/ ./ C/ ./ 32/ 和/ ft/ ./ C/ ./ 64/ 中/ ,/ 被/ “/ 隐藏/ ”/ 的/ 集合/ 通信/ 时间/ 占/ 集合/ 通信/ 总/ 时间/ 的/ 比例/ 超过/ 18/ %/ ./ 如图/ 10/ 所示/ ,/ 由于/ 集合/ 通信/ 时间/ 的/ “/ 隐藏/ ”/ ,/ 不同/ 规模/ 和/ 进程/ 数下/ 的/ FT/ 测试/ 的/ 性能/ 都/ 获得/ 了/ 提高/ ./ 其中/ ,/ ft/ ./ C/ ./ 64/ 的/ 性能/ 被/ 提高/ 了/ 5/ %/ ./ 在/ IS/ 中/ ,/ 通过/ 基于/ trace/ 的/ 方法/ 发现/ ,/ 所有/ 进程/ 在/ Alltoallv/ 调用/ 返回/ 后/ 也/ 采用/ 相同/ 的/ 访问/ 顺序/ 访问/ 接收缓冲区/ 中/ 的/ 集合/ 接收/ 子/ 消息/ ,/ 访问/ 顺序/ 为/ {/ 0/ ,/ 1/ ,/ 2/ ,/ 3/ …/ (/ N/ -/ 1/ )/ }/ ./ 同时/ ,/ 图/ 7/ 显示/ 了/ is/ ./ B/ ./ 32/ 中/ 阻塞/ Alltoallv/ 返回/ 后/ ,/ 所有/ 进程/ 中/ 32/ 个/ 集合/ 接收/ 子/ 消息/ 第一次/ 被/ 访问/ 的/ 平均/ 时间/ ./ 如图/ 7/ 所示/ ,/ 与/ FT/ 类似/ ,/ IS/ 中/ Alltoallv/ 集合/ 调用/ 之后/ 的/ 计算/ 也/ 主要/ 是/ CRC/ ./ 图/ 9/ 显示/ 了/ IS/ 采用/ T/ -/ NBC/ 所/ 获得/ 的/ 集合/ 通信/ 与/ 计算/ 的/ 重叠/ ./ 如图/ 9/ 所示/ ,/ 在/ 不同/ 的/ 测试/ 规模/ 和/ 进程/ 数下/ ,/ Alltoallv/ 调用/ 的/ 总/ 时间/ 不/ 超过/ 原来/ 阻塞/ Alltoall/ 调用/ 时间/ 的/ 25/ %/ ./ 在/ is/ ./ B/ ./ 32/ 中/ ,/ 超过/ 19/ %/ 的/ Alltoallv/ 时间/ 被/ 计算/ 重叠/ ;/ 在/ is/ ./ C/ ./ 64/ 和/ is/ ./ D/ ./ 128/ 中/ ,/ 重叠/ 比例/ 分别/ 为/ 25/ %/ 和/ 45/ %/ ./ 由于/ T/ -/ NBC/ “/ 隐藏/ ”/ 了/ 部分/ 集合/ 通信/ 时间/ ,/ 不同/ IS/ 测试/ 的/ 性能/ 都/ 获得/ 了/ 提高/ ./ 如图/ 10/ 所示/ ,/ is/ ./ D/ ./ 128/ 的/ 性能/ 提高/ 了/ 36/ %/ ./ 7/ 结论/ 和/ 未来/ 工作/ 在/ 本文/ 中/ ,/ 我们/ 在/ 不/ 修改/ 应用程序/ 的/ 前提/ 下/ 实现/ 了/ T/ -/ NBC/ ./ T/ -/ NBC/ 通过/ 基于/ 虚拟内存/ 机制/ 的/ 缓冲区/ 保护/ 方法/ 和/ 基于/ 调度表/ 的/ 异步/ 线程/ 推动/ 来/ 保证/ 应用/ 的/ 正确/ 执行/ ./ 同时/ ,/ T/ -/ NBC/ 可以/ 将/ 集合/ 通信/ 与/ 集合/ 操作/ 之后/ 的/ 计算/ 重叠/ 起来/ ,/ 从而/ 提高/ 了/ 应用/ 的/ 性能/ ./ 它/ 不但/ 可以/ 获得/ 集合/ 通信/ 与/ CURC/ 的/ 重叠/ ,/ 而且/ 为了/ 进一步提高/ 集合/ 通信/ 与/ CRC/ 的/ 重叠/ ,/ 它/ 根据/ 应用/ 对/ 多个/ 集合/ 子/ 消息/ 的/ 访问/ 顺序/ 赋予/ 这些/ 子/ 消息/ 不同/ 的/ 通信/ 优先级/ ./ 微/ 基准/ 测试/ 证明/ ,/ T/ -/ NBC/ 可以/ 重叠/ 绝大部分/ 集合/ 通信/ 时间/ ./ 在/ NPB/ 测试/ FT/ 和/ IS/ 中/ ,/ 尽管/ 集合/ 操作/ 之后/ 的/ 计算/ 主要/ 是/ CRC/ ,/ 在/ ft/ ./ 64/ ./ C/ 中/ ,/ 18/ %/ 的/ Alltoall/ 通信/ 时间/ 被/ 重叠/ ,/ 而/ 在/ is/ ./ D/ ./ 128/ 中/ ,/ 45/ %/ 的/ Alltoallv/ 通信/ 时间/ 被/ 重叠/ ;/ 它们/ 的/ 性能/ 分别/ 被/ 提高/ 了/ 5/ %/ 和/ 36/ %/ ./ 在/ 下/ 一步/ 工作/ 中/ ,/ 我们/ 将/ 评估/ T/ -/ NBC/ 在/ 更/ 多/ 应用/ 中/ 的/ 性能/ ./ Mellanox/ ①/ 最近/ 提出/ 了/ 基于/ Infiniband/ 网络/ 的/ 集合/ 通信/ 硬件/ 卸载/ (/ Offload/ )/ 技术/ ,/ 这/ 有利于/ 非/ 阻塞/ 集合/ 操作/ 的/ 实现/ ,/ 我们/ 将/ 基于/ 这项/ 技术/ 对/ T/ -/ NBC/ 进行/ 研究/ ./ 致谢/ 感谢/ 张攀勇/ 和/ 张翔/ 在/ 各/ 方面/ 给予/ 的/ 帮助/ !/ 

