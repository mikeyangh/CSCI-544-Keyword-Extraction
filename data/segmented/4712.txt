Page1/ 基于/ 路径/ 约束/ 求解/ 的/ 多/ 目标/ 状态/ 激励/ 生成/ 方法/ 李华伟/ 1/ )/ 1/ )/ (/ 中国科学院计算技术研究所/ 计算机/ 体系结构/ 国家/ 重点/ 实验室/ 北京/ 100190/ )/ 2/ )/ (/ 中国科学院/ 大学/ 北京/ 100049/ )/ 摘要/ 该文/ 提出/ 了/ 一种/ 针对/ 多个/ 难达/ 目标/ 状态/ 的/ 激励/ 生成/ 方法/ ,/ 该/ 方法/ 基于/ 抽象/ 引导/ 的/ 半/ 形式化/ 方法/ 框架/ ./ 采用/ 一个/ 评估/ 函数/ 对/ 候选/ 状态/ 进行/ 评价/ ,/ 该/ 评估/ 函数/ 综合/ 考虑/ 了/ 从/ 一个/ 状态/ 到/ 不同/ 目标/ 状态/ 的/ 全局/ 抽象/ 距离/ 信息/ ,/ 评价/ 出/ 从/ 各个/ 状态/ 到达/ 某个/ 目标/ 状态/ 或者/ 同时/ 到达/ 多个/ 目标/ 状态/ 的/ 潜能/ ,/ 并/ 以此/ 指导/ 模拟/ 过程/ 直到/ 最终/ 搜索/ 到/ 一条/ 能/ 同时/ 覆盖/ 多个/ 目标/ 状态/ 的/ 状态/ 序列/ ./ 此外/ ,/ 该文/ 采用/ 了/ 基于/ 路径/ 约束/ 求解/ 的/ 激励/ 生成/ 方式/ ,/ 这种/ 方式/ 结合/ 了/ 具体/ 模拟/ 和/ 符号/ 模拟/ 技术/ ,/ 符号/ 模拟/ 沿着/ 具体/ 执行/ 路径/ 提取/ 分支/ 条件/ 构成/ 路径/ 约束/ ,/ 通过/ 约束条件/ 的/ 翻转/ 与/ 求解/ 能够/ 有效/ 地/ 产生/ 输入/ 向量/ ,/ 以/ 一种/ 较/ 均衡/ 的/ 模式/ 遍历/ 设计/ 的/ 状态/ 空间/ ,/ 帮助/ 验证/ 快速/ 覆盖/ 到/ 目标/ ./ 实验/ 结果表明/ ,/ 该文/ 方法/ 能够/ 有效/ 地/ 同时/ 验证/ 设计/ 中/ 的/ 多个/ 目标/ 状态/ ./ 关键词/ 激励/ 生成/ ;/ 难达/ 状态/ ;/ 抽象/ 引导/ 模拟/ ;/ 路径/ 约束/ 求解/ 1/ 引言/ 随着/ 集成电路/ 设计/ 规模/ 与/ 复杂度/ 的/ 增加/ ,/ 功能/ 验证/ 已经/ 成为/ 设计/ 周期/ 中/ 的/ 一个/ 重要环节/ ./ 其中/ ,/ 如何/ 高效/ 地/ 产生/ 测试/ 向量/ 来/ 覆盖/ 难达/ 状态/ 是/ 一个/ 相当/ 有/ 难度/ 的/ 问题/ ./ 目前/ ,/ 在/ 工业/ 设计/ 验证/ 中/ 占/ 主导地位/ 的/ 验证/ 方法/ 仍然/ 是/ 传统/ 的/ 模拟/ 方法/ ,/ 因为/ 模拟/ 验证/ 方法/ 可扩展性/ 好/ ,/ 能够/ 处理/ 大规模/ 的/ 设计/ 并且/ 快速/ 、/ 易用/ ,/ 但是/ 其/ 缺点/ 是/ 不能/ 保证/ 验证/ 的/ 完备/ 性/ ,/ 通常/ 难以/ 覆盖/ 到/ 设计/ 中/ 的/ 难达/ 边缘/ 属性/ (/ 难达/ 状态/ )/ ./ 形式化/ 的/ 方法/ 是/ 一种/ 完备/ 的/ 验证/ 方法/ ,/ 理论/ 上/ 可以/ 高效/ 地/ 验证/ 所有/ 的/ 难达/ 状态/ ,/ 但/ 其/ 处理/ 规模/ 有限/ ,/ 可扩展性/ 差/ ,/ 难以/ 应用/ 到/ 大规模/ 的/ 工业/ 设计/ 中/ ./ 为了/ 结合/ 模拟/ 方法/ 的/ 可扩展性/ 以及/ 形式化/ 方法/ 的/ 完备/ 性/ ,/ 避免/ 各自/ 的/ 缺陷/ ,/ 研究者/ 们/ 提出/ 了/ 半/ 形式化/ 验证/ 方法/ ./ 在/ 已有/ 的/ 半/ 形式化/ 验证/ 方法/ 中/ ,/ 抽象/ 引导/ 的/ 模拟/ 验证/ 方法/ 是/ 一个/ 很/ 有/ 前景/ 的/ 研究/ 方向/ [/ 1/ -/ 7/ ]/ ./ 在/ 这种/ 方法/ 里/ ,/ 首先/ 从/ 原始/ 设计/ 上/ 提取/ 出/ 一个/ 较/ 小/ 的/ 抽象/ 模型/ ,/ 然后/ 在/ 这个/ 抽象/ 模型/ 上/ 进行/ 形式化/ 计算/ ,/ 用/ 所得/ 信息/ 来/ 指导/ 模拟/ 的/ 过程/ ./ 文献/ [/ 1/ ]/ 是/ 抽象/ 信息/ 引导/ 的/ 半/ 形式化/ 验证/ 方法/ 的/ 先驱/ ./ 在/ 这种/ 方法/ 中/ ,/ 作者/ 将/ 与/ 目标/ 状态/ 寄存器/ 紧密/ 相关/ 的/ 模块/ (/ module/ )/ 提取/ 出来/ 构成/ 抽象/ 模型/ ,/ 并/ 在/ 此/ 模型/ 上/ 应用/ 形式化/ 的/ 前/ 像/ 计算/ 获得/ 抽象/ 距离/ 信息/ ./ 在/ 模拟/ 过程/ 中/ ,/ 从/ 当前/ 状态/ 开始/ ,/ 随机/ 产生/ N/ 组/ 长度/ 为/ M/ 的/ 输入/ 向量/ 进行/ 模拟/ ,/ 并且/ 利用/ 抽象/ 距离/ 信息/ 对/ 模拟/ 过程/ 中/ 访问/ 到/ 的/ 状态/ 进行/ 评估/ ,/ 从中/ 选择/ 抽象/ 距离/ 最小/ 的/ 状态/ 作为/ 下/ 一个/ 模拟/ 的/ 当前/ 状态/ ,/ 循环/ 这个/ 过程/ 直到/ 覆盖/ 到/ 目标/ ./ 这种/ 方法/ 采用/ 随机/ 生成/ 激励/ 的/ 策略/ ,/ 工作效率/ 不高/ ,/ 而且/ 抽象/ 的/ 粒度/ 较/ 粗/ ,/ 所得/ 的/ 抽象/ 距离/ 信息/ 不够/ 准确/ ,/ 容易/ 陷入/ 死胡同/ 状态/ (/ dead/ -/ endstates/ )/ ./ 为了/ 缓解/ 由/ 抽象/ 误差/ 导致/ 的/ 死胡同/ 问题/ ,/ 文献/ [/ 2/ ]/ 引入/ 了/ 抽象/ 细化/ 技术/ ,/ 这种/ 方法/ 首先/ 通过/ 前后/ 像/ 的/ 计算/ 获得/ 一条/ 抽象/ 状态/ 序列/ ,/ 相对/ 于/ 其中/ 的/ 每/ 一步/ ,/ 进行/ 随机/ 激励/ 生成/ ,/ 将/ 抽象/ 序列/ 具体化/ 到/ 真实/ 序列/ ;/ 如果/ 随机/ 无法/ 满足/ ,/ 则/ 进行/ 抽象/ 细化/ ,/ 重新/ 选取/ 更加/ 精细/ 的/ 抽象/ 模型/ ,/ 重复/ 整个/ 过程/ ./ 这种/ 方法/ 在/ 一定/ 程度/ 上/ 提高/ 了/ 验证/ 效率/ ,/ 但/ 反复/ 抽象/ 细化/ 的/ 计算成本/ 太高/ ,/ 方法/ 的/ 适用性/ 受限/ ./ 因此/ ,/ 文献/ [/ 3/ -/ 7/ ]/ 主要/ 从/ 抽象/ 方法/ 、/ 抽象/ 引导/ 策略/ 以及/ 激励/ 生成/ 方法/ 3/ 个/ 方面/ 进行/ 改进/ ,/ 以/ 提高/ 验证/ 工作效率/ ./ 本文/ 的/ 目标/ 是/ 针对/ 设计/ 中/ 多个/ 难达/ 状态/ 产生/ 输入/ 激励/ ,/ 通过/ 多/ 目标/ 同时/ 覆盖/ 的/ 方式/ 来/ 提高/ 验证/ 效率/ ./ 首先/ ,/ 本文/ 通过/ 构建/ 一个/ 评估/ 函数/ 来/ 对/ 验证/ 过程/ 中/ 的/ 状态/ 进行/ 评价/ ,/ 该/ 评估/ 函数/ 同时/ 考虑/ 了/ 从/ 一个/ 状态/ 到/ 不同/ 目标/ 状态/ 的/ 抽象/ 距离/ 值/ ,/ 用来/ 指导/ 状态/ 的/ 选择/ 及/ 模拟/ 过程/ ,/ 直到/ 最终/ 搜索/ 到/ 一条/ 能/ 同时/ 覆盖/ 多个/ 目标/ 状态/ 的/ 状态/ 序列/ ./ 其次/ ,/ 本文/ 采用/ 基于/ 路径/ 约束/ 求解/ 的/ 策略/ 产生/ 输入/ 激励/ ,/ 这种/ 激励/ 生成/ 引擎/ 结合/ 了/ 具体/ 模拟/ 和/ 符号/ 模拟/ 技术/ ,/ 能够/ 产生/ 有效/ 地/ 测试/ 向量/ 沿着/ 具体/ 路径/ 遍历/ 设计/ 的/ 状态/ 空间/ ./ 此外/ ,/ 本文/ 采取/ 了/ 一种/ 较/ 细粒度/ 的/ 电路/ 抽象/ 方法/ 针对/ 每/ 一个/ 目标/ 状态/ 来/ 构建/ 抽象/ 模型/ ,/ 在/ 这些/ 抽象/ 模型/ 上/ 进行/ 形式化/ 计算/ 能/ 获得/ 较/ 准确/ 的/ 抽象/ 距离/ 信息/ 来/ 计算/ 评估/ 函数/ 值/ ./ 本文/ 第/ 2/ 节/ 介绍/ 抽象/ 引导/ 的/ 半/ 形式化/ 方法/ 及/ 相关/ 工作/ ;/ 第/ 3/ 节/ 描述/ 本文/ 方法/ 的/ 框架/ 及/ 相关/ 细节/ ;/ 第/ 4/ 节/ 给出/ 本文/ 方法/ 的/ 实验/ 结果/ ;/ 第/ 5/ 节对/ 本文/ 方法/ 的/ 局限性/ 进行/ 说明/ ;/ 最后/ 一节/ 对/ 本文/ 进行/ 总结/ ./ 2/ 相关/ 工作/ 2.1/ 抽象/ 引导/ 的/ 半/ 形式化/ 方法/ 简介/ 抽象/ 引导/ 的/ 半/ 形式化/ 验证/ 方法/ 被/ 认为/ 是/ 众多/ 的/ 半/ 形式化/ 验证/ 方法/ 中/ 最具/ 潜力/ 的/ 方法/ 之一/ ./ 在/ 这种/ 方法/ 里/ ,/ 通常/ 从/ 具体/ 设计/ 中/ 抽象/ 出/ 一个/ 较/ 小/ 的/ 抽象/ 模型/ ,/ 以便/ 能够/ 在/ 这个/ 抽象/ 模型/ 中/ 进行/ 完全/ 的/ 形式化/ 计算/ ,/ 并用/ 所得/ 的/ 抽象/ 距离/ 信息/ 来/ 评估/ 具体/ 设计/ 状态/ ,/ 指导/ 模拟/ 过程/ 趋向/ 验证/ 目标/ ,/ 示意图/ 如图/ 1/ 所示/ [/ 8/ ]/ ./ 图/ 1/ 抽象/ 信息/ 引导/ 的/ 半/ 形式化/ 方法/ 示意图/ [/ 8/ ]/ 在/ 形式化/ 分析/ 引擎/ 中/ ,/ 通过/ 对/ 抽象/ 设计/ 进行/ 形式化/ 的/ 前/ 像/ 计算/ 可以/ 将/ 抽象/ 状态/ 划分/ 到/ 不同/ 的/ “/ 洋葱/ 环/ ”/ 中/ ,/ 其中/ 第/ i/ 个/ 环中/ 的/ 状态/ 在/ 第/ i/ 个/ 模拟/ 周期/ 时能/ 到达/ 抽象/ 目标/ (/ 即/ 其/ 抽象/ 距离/ 为/ i/ )/ ./ 一个/ 抽象/ 状态/ 对应/ 多个/ 具体/ 状态/ ,/ 相应/ 地/ ,/ 每/ 一个/ 具体/ 设计/ 状态/ 对应/ 一个/ 抽象/ 状态/ 并/ 有/ 一个/ 特定/ 的/ 抽象/ 距离/ 值/ ./ 如图/ 1/ 中/ 所示/ ,/ 原始/ 设计/ 状态/ 空间/ 中/ 不同/ 灰度/ 区域/ 内/ 的/ 状态/ 对应/ 不同/ 的/ 抽象/ 距离/ 值/ ./ 在/ 模拟/ 过程/ 中/ ,/ 从/ Page3/ 初始状态/ 开始/ ,/ 向前/ 搜索/ 一步/ 或/ 几步/ ,/ 模拟/ 引擎/ 将/ 模拟/ 过程/ 中/ 的/ 具体/ 设计/ 状态/ 送入/ 形式化/ 分析/ 引擎/ 中/ ,/ 利用/ 抽象/ 距离/ 信息/ 对/ 这些/ 状态/ 进行/ 评估/ ,/ 从中/ 选出/ 对应/ 抽象/ 距离/ 最小/ 的/ 状态/ 作为/ 下/ 一步/ 模拟/ 的/ 开始/ 状态/ ,/ 向前/ 进行/ 搜索/ ,/ 直到/ 到达/ 目标/ ./ 2.2/ 各种/ 抽象/ 引导/ 的/ 半/ 形式化/ 方法/ 由于/ 抽象/ 设计/ 和/ 原始/ 设计/ 之间/ 存在/ 抽象/ 误差/ ,/ 即/ 在/ 抽象/ 过程/ 中/ 损失/ 了/ 许多/ 原始/ 设计/ 的/ 信息/ ,/ 因此/ 不可避免/ 地会/ 产生/ 死胡同/ 状态/ ./ 死胡同/ 状态/ 是/ 指/ 那些/ 在/ 抽象/ 模型/ 上/ 评估/ 为/ 距离/ 目标/ 很近/ ,/ 但/ 实际上/ 却/ 距离/ 目标/ 很/ 远/ 甚至/ 完全/ 不能到达/ 目标/ 的/ 状态/ [/ 5/ ]/ ./ 为了/ 缓解/ 死胡同/ 问题/ ,/ 文献/ [/ 3/ ]/ 从/ 抽象/ 引导/ 策略/ 方面/ 进行/ 改进/ ./ 该/ 方法/ 以/ “/ 桶/ ”/ 的/ 形式/ 将/ 模拟/ 过程/ 中/ 访问/ 过/ 的/ 所有/ 状态/ 按照/ 抽象/ 距离/ 远近/ 顺序/ 保存起来/ ,/ 其中/ 一个/ “/ 桶/ ”/ 对应/ 一个/ 抽象/ 距离/ ./ 在/ 每个/ 模拟/ 周期/ 中/ ,/ 从/ 最近/ 的/ “/ 桶/ ”/ (/ 最小/ 抽象/ 距离/ )/ 开始/ ,/ 按照/ 抽象/ 距离/ 从小到大/ 概率/ 指数/ 衰减/ 的/ 原则/ ,/ 选择/ 一个/ 已达/ 的/ 历史/ 状态/ 作为/ 新/ 的/ 模拟/ 当前/ 态/ ./ 这种/ 方法/ 能/ 较/ 好/ 地/ 避免/ 死胡同/ 问题/ ,/ 提高/ 验证/ 效率/ ,/ 但是/ 随机/ 的/ 激励/ 生成/ 策略/ 使得/ 其/ 仍然/ 难以/ 覆盖/ 到/ 难达/ 状态/ ./ 针对/ 这个/ 问题/ ,/ 文献/ [/ 4/ ]/ 引入/ 了/ 文化/ 算法/ (/ CulturalAlgorithm/ )/ 来/ 实现/ 激励/ 生成/ ./ 该/ 方法/ 利用/ 数据挖掘/ 技术/ 提取/ 抽象/ 电路/ ,/ 将/ 获得/ 的/ 抽象/ 设计/ 信息/ 作为/ 文化/ 算法/ 中/ 的/ 适应度/ 函数/ ,/ 通过/ 交叉/ 、/ 遗传/ 、/ 变异/ 、/ 继承/ 等/ 操作/ ,/ 不断/ 提高/ 激励/ 的/ 适应度/ 值/ ,/ 生成/ 能够/ 快速/ 覆盖/ 到/ 目标/ 的/ 输入/ 激励/ ./ 这种/ 方法/ 能够/ 自动/ 演进/ 覆盖/ 目标/ 状态/ ,/ 进一步提高/ 验证/ 的/ 效率/ ,/ 其/ 缺点/ 是/ 需要/ 进行/ 大量/ 的/ 随机/ 以/ 积累/ 数据挖掘/ 所/ 需/ 的/ 信息/ ,/ 并且/ 这种/ 数据挖掘/ 是/ 基于/ 位/ (/ bit/ )/ 级/ 的/ 操作/ ,/ 所/ 提供/ 的/ 抽象/ 信息/ 很难/ 用来/ 处理/ 宽位/ 宽/ 的/ 复杂/ 设计/ ./ 为了/ 进一步提高/ 抽象/ 引导/ 的/ 半/ 形式化/ 验证/ 方法/ 的/ 效率/ ,/ 文献/ [/ 5/ ]/ 利用/ 机器/ 学习/ 中/ 的/ Markov/ 模型/ 建立/ 激励/ 生成/ 引擎/ ./ 这种/ 方法/ 首先/ 建立/ 设计/ 的/ 数据/ 依赖图/ (/ DataDependenceGraph/ ,/ DDG/ )/ ,/ 然后/ 基于/ 数据/ 依赖图/ 进行/ 设计/ 抽象/ ,/ 获取/ 抽象/ 信息/ ;/ 根据/ 设计规范/ (/ Specification/ )/ 建立/ Markov/ 模型/ ,/ 自动化/ 的/ 为/ 每个/ 模拟/ 周期/ 生成/ 合法/ 的/ 输入/ 向量/ ;/ 利用/ 抽象/ 信息/ 对/ Markov/ 模型/ 进行/ 调整/ ,/ 提高/ 激励/ 生成/ 质量/ ./ 这种/ 方法/ 能够/ 产生/ 高质量/ 的/ 测试/ 激励/ ,/ 加速/ 验证/ 收敛/ 速度/ ,/ 但/ Markov/ 模型/ 是/ 一种/ 随机/ 的/ 概率模型/ ,/ 因此/ 仍/ 面临/ 死胡同/ 状态/ 问题/ ./ 文献/ [/ 6/ ]/ 则/ 通过/ 在/ 抽象/ 设计/ 上/ 构建/ 一个/ Markov/ 模型/ ,/ 在/ 此/ 模型/ 上/ 计算/ 各个/ 状态/ 之间/ 相互/ 到达/ 的/ 稳态/ 概率分布/ ,/ 并/ 以此/ 来/ 判断/ 状态/ 的/ 难达/ 程度/ 及/ 引导/ 激励/ 生成/ 的/ 过程/ ,/ 这种/ 方法/ 需要/ 显式/ 的/ 建立/ 抽象/ 设计/ 的/ 状态/ 转移/ 图/ ,/ 因此/ 能/ 处理/ 的/ 设计/ 规模/ 有限/ ./ 在/ 抽象/ 引导/ 的/ 半/ 形式化/ 方法/ 中/ ,/ 随机/ 产生/ 输入/ 向量/ 是/ 在/ 设计/ 的/ 输入/ 空间/ 内/ 搜索/ ,/ 对应/ 到/ 设计/ 的/ 状态/ 空间/ 中/ ,/ 每个/ 状态/ 被/ 遍历/ 到/ 的/ 概率/ 相差/ 较大/ ./ 例如/ ,/ 在/ 设计/ 中有/ 一个/ 分支/ 为/ :/ if/ (/ a/ )/ state/ =/ A/ ;/ elsestate/ =/ B/ ,/ 其中/ a/ 是/ 一个/ 四位/ 的/ 原始/ 输入/ ,/ 那么/ 在/ 输入/ 空间/ 内/ ,/ a/ 的/ 每/ 一种/ 取值/ 被/ 随机/ 到/ 的/ 概率/ 都/ 是/ 1/ // 16/ ,/ 但/ 从/ 状态/ 空间/ 来看/ ,/ 状态/ A/ 和/ B/ 被/ 遍历/ 到/ 的/ 概率/ 分别/ 是/ 15/ // 16/ 和/ 1/ // 16/ ,/ 如果/ B/ 是/ 离/ 目标/ 较近/ 的/ 状态/ ,/ 那么/ 随机/ 产生/ 激励/ 的/ 方法/ 将/ 比较/ 难/ 达到目标/ ./ 针对/ 这一/ 问题/ ,/ 文献/ [/ 7/ ]/ 提出/ 了/ 一种/ 基于/ 路径/ 约束/ 求解/ 的/ 难达/ 状态/ 激励/ 生成/ 方法/ —/ —/ —/ PACOST/ ./ PACOST/ 在/ 抽象/ 引导/ 的/ 模拟/ 验证/ 方法/ 的/ 激励/ 生成/ 中/ 使用/ 形式化/ 的/ 约束/ 求解/ 来/ 产生/ 激励/ ,/ 在/ 每/ 一个/ 模拟/ 步骤/ 内/ ,/ 在/ 动态/ 模拟/ 开辟/ 的/ 状态/ 空间/ 内/ ,/ 进行/ 静态/ 的/ 符号/ 模拟/ 以/ 提取/ 路径/ 约束/ ,/ 通过/ 路径/ 约束条件/ 的/ 翻转/ 求解/ 产生/ 输入/ 激励/ ,/ 在/ 状态/ 空间/ 内/ 搜索/ 抽象/ 距离/ 最近/ 的/ 状态/ 作为/ 下/ 一/ 当前/ 态/ ,/ 重复/ 这个/ 过程/ 直到/ 覆盖/ 到/ 目标/ 状态/ ./ 这种/ 方法/ 能够/ 以/ 一种/ 较/ 均衡/ 的/ 方式/ 遍历/ 设计/ 的/ 内部/ 状态/ 空间/ ,/ 在/ 抽象/ 距离/ 的/ 引导/ 下/ 快速/ 地/ 覆盖/ 到/ 目标/ 状态/ ,/ 提高/ 验证/ 的/ 效率/ ./ 上述/ 已有/ 的/ 抽象/ 引导/ 的/ 半/ 形式化/ 方法/ 基本上/ 都/ 是/ 针对/ 单个/ 目标/ 状态/ 来/ 产生/ 激励/ ./ 目前/ ,/ 在/ 国内外/ 针对/ 多个/ 难达/ 目标/ 状态/ 进行/ 激励/ 生成/ 的/ 研究/ 工作/ 较少/ ./ 文献/ [/ 9/ ]/ 提出/ 了/ 一种/ 利用/ 抽象/ 模型/ 上/ 的/ 后验/ 概率/ 值来/ 指导/ 多/ 目标/ 状态/ 激励/ 生成/ 的/ 方法/ ./ 这种/ 方法/ 首先/ 从/ 原始/ 设计/ 中/ 抽取/ 一个/ 抽象/ 模型/ ,/ 然后/ 在/ 抽象/ 模型/ 对应/ 的/ 显式/ 状态/ 机上/ 计算/ 稳态/ 概率分布/ 矩阵/ ,/ 该/ 矩阵/ 记录/ 了/ 抽象/ 模型/ 上/ 各个/ 状态/ 之间/ 跳转/ 转移/ 的/ 概率/ 值/ ,/ 然后/ 通过/ 矩阵/ 的/ 逆运算/ 计算/ 出/ 各个/ 状态/ 到达/ 目标/ 状态/ 的/ 后验/ 概率/ 值/ ,/ 后验/ 概率/ 值越/ 大/ 表示/ 相应/ 的/ 抽象/ 状态/ 到/ 目标/ 状态/ 越近/ ./ 对于/ 多个/ 目标/ 状态/ 的/ 情况/ ,/ 通过/ 计算/ 各个/ 状态/ 到达/ 不同/ 目标/ 状态/ 的/ 后验/ 概率/ 值/ 的/ 几何/ 平均值/ 来/ 评估/ 候选/ 状态/ ./ 由于/ 这个/ 方法/ 的/ 后验/ 概率/ 值/ 是/ 在/ 显式/ 的/ 抽象/ 状态/ 机上/ 计算/ 的/ ,/ 因此/ 能/ 处理/ 的/ 抽象/ 模型/ 的/ 规模/ 有限/ ,/ 而且/ 当/ 原始/ 设计/ 规模/ 较大/ ,/ 抽象/ 模型/ 与/ 原始/ 设计/ 差异/ 较大/ 时/ ,/ 计算出来/ 的/ 后验/ 概率/ 值/ 存在/ 误差/ ,/ 不能/ 提供/ 很/ 好/ 的/ 指导/ ./ 专利/ ①/ 提出/ 了/ 一种/ 利用/ 符号/ 约束/ 求解/ 为/ 多个/ 覆盖率/ 漏洞/ 目标/ 产生/ 确定性/ 的/ 输入/ 激励/ ./ 在/ 每个/ 模拟/ 步骤/ 中/ ,/ 该/ 方法/ 通过/ 分析/ 覆盖率/ 信息/ 来/ 确定/ 一个/ 覆/ ①/ http/ :/ // // www/ ./ google/ ./ com/ // patents/ // US20120266118Page4/ 盖率/ 漏洞/ 作为/ 目标/ ./ 对于/ 每个/ 目标/ ,/ 通过/ 具体/ 模拟/ 路径/ 中/ 符号/ 变量/ 和/ 表达式/ 的/ 传播/ 获取/ 符号/ 约束/ ,/ 约束/ 求解/ 产生/ 激励/ 覆盖/ 相应/ 目标/ ./ 该/ 方法/ 的/ 覆盖/ 目标/ 是/ 在/ 模拟/ 的/ 过程/ 中/ 确定/ 的/ ,/ 一次/ 只能/ 覆盖/ 一个/ 目标/ ,/ 并且/ 这个/ 方法/ 中/ 所/ 收集/ 的/ 符号/ 约束/ 取决于/ 随机/ 模拟/ 遍历/ 到/ 的/ 路径/ ,/ 如果/ 覆盖/ 目标/ 所/ 需/ 激发/ 的/ 条件/ 与/ 所/ 收集/ 的/ 符号/ 约束/ 关系不大/ ,/ 则/ 这种/ 方法/ 难以/ 产生/ 出/ 覆盖/ 目标/ 的/ 输入/ 激励/ ./ 本文/ 方法/ 是/ 针对/ 确定性/ 的/ 多个/ 目标/ ,/ 在/ PACOST/ 基础/ 上/ 进行/ 扩展/ ,/ 目的/ 是/ 同时/ 覆盖/ 设计/ 中/ 的/ 多个/ 难达/ 目标/ 状态/ ./ 在/ 每/ 一步/ 模拟/ 中/ ,/ 提取/ 一个/ 周期/ 的/ 路径/ 约束/ ,/ 通过/ 约束条件/ 的/ 翻转/ 与/ 求解/ 产生/ 新/ 的/ 输入/ 激励/ ,/ 遍历/ 不同/ 的/ 分支/ 路径/ 并/ 相应/ 获得/ 不同/ 的/ 候选/ 状态/ ,/ 利用/ 一个/ 评估/ 函数/ 综合/ 考虑/ 各个/ 候选/ 状态/ 到/ 不同/ 目标/ 状态/ 的/ 全局/ 抽象/ 距离/ 信息/ ,/ 逐步/ 地/ 指导/ 模拟/ 过程/ ,/ 最终/ 同时/ 覆盖/ 到/ 时序/ 深度/ 较/ 深/ 的/ 多个/ 难达/ 状态/ ./ 3/ 本文/ 方法/ 本文/ 所/ 提出/ 的/ 针对/ 多个/ 目标/ 状态/ 的/ 激励/ 生成/ 方法/ 的/ 整体/ 工作/ 框架/ 如图/ 2/ 所示/ ,/ 本文/ 方法/ 基于/ 抽象/ 引导/ 的/ 半/ 形式化/ 方法/ 框架/ ,/ 包括/ 4/ 个/ 主要/ 的/ 模块/ :/ 抽象/ 引擎/ ,/ 评估/ 函数/ ,/ 基于/ 路径/ 约束/ 求解/ 的/ 激励/ 生成器/ 以及/ 状态/ 选择器/ ./ 抽象/ 引擎/ 从/ 原始/ 设计/ 中/ 提取/ 出/ 规模较/ 小/ 的/ 抽象/ 模型/ 并/ 在/ 此/ 模型/ 上/ 应用/ 形式化/ 方法/ 获取/ 抽象/ 距离/ 信息/ ,/ 由于/ 本文/ 是/ 针对/ 多个/ 目标/ 状态/ ,/ 如果/ 各/ 目标/ 状态/ 所/ 涉及/ 的/ 寄存器/ 不同/ ,/ 则/ 相对/ 于/ 每/ 一个/ 目标/ 状态/ 提取/ 出/ 一个/ 抽象/ 模型/ 并/ 获得/ 一个/ 抽象/ 距离/ 信息/ 表/ ,/ 该表中/ 记录/ 了/ 在/ 此/ 抽象/ 模型/ 上/ 每个/ 抽象/ 状态/ 到/ 该/ 目标/ 状态/ 的/ 抽象/ 距离/ 值/ ;/ 评估/ 函数/ 同时/ 考虑/ 了/ 从/ 一个/ 具体/ 设计/ 状态/ 到/ 不同/ 目标/ 状态/ 的/ 抽象/ 距离/ 值/ ,/ 为/ 每/ 一个/ 状态/ 计算/ 一个/ 综合/ 的/ 抽象/ 距离/ 值来/ 评价/ 该/ 状态/ 到达某/ 一个/ 或/ 多个/ 目标/ 状态/ 的/ 潜能/ ,/ 用来/ 指导/ 状态/ 的/ 选择/ ;/ 基于/ 路径/ 约束/ 求解/ 的/ 激励/ 生成器/ 结合/ 具体/ 模拟/ 和/ 符号/ 模拟/ 方法/ 来/ 产生/ 有效/ 的/ 输入/ 激励/ ,/ 其中/ 每个/ 激励/ 对应/ 于/ 一个/ 候选/ 状态/ ;/ 状态/ 选择器/ 则/ 利用/ 评估/ 函数/ 计算出来/ 的/ 综合/ 抽象/ 距离/ 信息/ 来/ 指导/ 整个/ 状态/ 搜索/ 过程/ 的/ 方向/ ,/ 在/ 每/ 一个/ 模拟/ 步骤/ 中/ ,/ 从/ 路径/ 约束/ 求解/ 产生/ 的/ 一组/ 候选/ 状态/ 中/ 选择/ 一个/ 评估/ 函数/ 值/ 最大/ 的/ 作为/ 下/ 一步/ 模拟/ 的/ 当前/ 态/ ./ 下面/ 将/ 对/ 各个/ 模块/ 进行/ 更/ 详细/ 的/ 描述/ ./ 3.1/ 抽象/ 引擎/ 抽象/ 引擎/ 的/ 功能/ 是/ 实现/ 设计/ 抽象/ 、/ 获取/ 抽象/ 距离/ 信息/ ./ 在/ 原始/ 设计/ 上/ 提取/ 出/ 的/ 规模较/ 小/ 的/ 抽象/ 模型/ 上/ ,/ 运用/ 可达性/ 分析方法/ 计算/ 抽象/ 距离/ ,/ 用来/ 指导/ 具体/ 的/ 模拟/ 过程/ ./ 因此/ 抽象/ 模型/ 的/ 质量/ 至关重要/ ,/ 如果/ 抽象/ 模型/ 过于/ 粗糙/ ,/ 则/ 不能/ 很/ 好/ 地/ 指导/ 模拟/ ./ 模型/ 越细越/ 好/ ,/ 但/ 如果/ 模型/ 过于/ 精细/ ,/ 则/ 其/ 规模/ 会/ 超出/ 形式化/ 方法/ 能够/ 处理/ 的/ 范围/ ./ 本文/ 中/ ,/ 我们/ 采用/ 类似/ 于/ 文献/ [/ 5/ ]/ 中所提/ 的/ 基于/ DDG/ 的/ 较/ 细粒度/ 的/ 电路/ 抽象/ 方法/ ./ DDG/ 描述/ 了/ 数据/ 在/ 设计/ 中/ 的/ 寄存器/ 之间/ 的/ 流向/ 关系/ ,/ 其中/ 节点/ 表示/ 设计/ 中/ 的/ 寄存器/ ,/ 边/ 表示/ 从/ 目的/ 节点/ 到源/ 节点/ 存在/ 的/ 数据/ 依赖/ 关系/ ./ 基于/ DDG/ 的/ 抽象/ 方法/ 的/ 示意图/ 如图/ 3/ 所示/ ,/ 图中/ R1/ 、/ R2/ 、/ R3/ 表示/ 目标/ 状态/ 寄存器/ ./ 不同于/ 文献/ [/ 5/ ]/ 中/ 的/ 抽象/ 方法/ ,/ 本文/ 抽象/ 过程/ 中/ 更/ 关注/ 控制/ 逻辑/ 中/ 的/ 寄存器/ ./ DDG/ 中/ 的/ 寄存器/ 可以/ 分为/ 控制/ 寄存器/ 和/ 数据/ 寄存器/ ,/ 控制/ 寄存器/ 是/ 指/ 位于/ 控制/ 逻辑/ 中/ 的/ 寄存器/ (/ 控制/ 逻辑/ 通常/ 包括/ 设计/ 中/ 的/ 显式/ 状态机/ 、/ 分支/ 、/ 条件/ 等/ ,/ 在/ 设计/ 中起/ 着/ 关键作用/ )/ ,/ 数据/ 寄存器/ 是/ 指/ 位于/ 数据通路/ (/ 数据流/ 相关/ 的/ 逻辑/ ,/ 如/ b12/ 中/ 的/ 存储单元/ ,/ 浮点运算/ 单元/ 的/ 操作数/ 和/ 结果/ 等/ )/ 中/ 的/ 寄存器/ ./ 控制/ 寄存器/ 与/ 数据/ 寄存器/ 的/ 区分/ 在/ 大多数/ 硬件/ 设计/ 中/ 都/ 比较/ 明显/ ./ Page5/ 在/ 抽象/ 的/ 过程/ 中/ ,/ 首先/ 需要/ 确定/ 目标/ 状态/ 寄存器/ ./ 本文/ 方法/ 中/ ,/ 目标/ 状态/ 寄存器/ 是/ 与/ 难达/ 分支/ (/ 时序/ 深度/ 较/ 深/ 的/ 分支/ )/ 相对/ 应/ 的/ 设计/ 状态/ 的/ 寄存器/ 变量/ ./ 然后/ 从/ 原始/ 设计/ 建立/ 与/ 目标/ 状态变量/ 相关/ 的/ 数据/ 依赖图/ ./ 抽象/ 从/ 目标/ 状态/ 寄存器/ 开始/ ,/ 基于/ 设计/ 的/ 数据/ 依赖图/ 逆向/ 地/ 选取/ 控制/ 寄存器/ ,/ 也/ 就是/ 按照/ 距离/ 目标/ 状态/ 寄存器/ 远近/ 程度/ 由近及远/ 地/ 按照/ 宽度/ 优先/ 的/ 方法/ 进行/ 选取/ ./ 由于/ 目标/ 状态/ 寄存器/ 的/ 逻辑/ 是/ 由/ 从/ 原始/ 输入/ 到/ 目标/ 状态/ 寄存器/ 之间/ 的/ 逻辑/ 构成/ ,/ 如果/ 从/ 目标/ 状态/ 寄存器/ 往前/ 抽取/ 的/ 逻辑/ 越/ 多/ ,/ 获得/ 的/ 抽象/ 模型/ 越/ 复杂/ ,/ 则/ 抽象/ 模型/ 和/ 原始/ 设计/ 之间/ 存在/ 的/ 差异/ 越小/ ,/ 但是/ 由于/ 状态/ 爆炸/ 的/ 问题/ ,/ 抽象/ 模型/ 的/ 规模/ 最终/ 受限于/ 形式化/ 工具/ 的/ 处理/ 能力/ ./ 本文/ 的/ 抽象/ 方法/ 是/ 按照/ 基于/ DDG/ 的/ 抽象/ 原则/ 抽取/ 出/ 与/ 目标/ 寄存器/ 相关/ 的/ 扇入/ 锥/ 中/ 的/ 控制/ 寄存器/ ,/ 而/ 数据/ 寄存器/ 则/ 考虑/ 作为/ 抽象/ 模型/ 的/ 输入/ 或/ 输出/ ./ 当/ 抽象/ 模型/ 的/ 规模/ 超过/ 形式化/ 工具/ 处理/ 的/ 上限/ 时/ ,/ 原始/ 设计/ DDG/ 中离/ 目标/ 状态/ 寄存器/ 较远/ 的/ 控制/ 寄存器/ 将/ 优先/ 从/ 抽象/ 模型/ 中/ 移除/ ./ 当/ 抽象/ 模型/ 建立/ 后/ ,/ 在/ 此/ 模型/ 上/ 应用/ 形式化/ 工具/ 来/ 计算/ 抽象/ 距离/ 信息/ ,/ 并/ 保存/ 为/ 抽象/ 距离/ 信息/ 表/ ./ 本文/ 所/ 采用/ 的/ 形式化/ 工具/ 为/ VIS/ ①/ ./ 本文/ 抽象/ 方法/ 能够/ 抽取/ 出对/ 路径/ 约束/ 而言/ 重要/ 的/ 寄存器/ ,/ 因为/ 路径/ 约束/ 是/ 由/ 设计/ 中/ 的/ 分支/ 条件/ 表达式/ 构成/ 的/ ,/ 而/ 分支/ 条件/ 是/ 控制/ 逻辑/ 的/ 一部分/ ,/ 本文/ 的/ 抽象/ 方法/ 是从/ 与/ 目标/ 属性/ 相关/ 的/ 寄存器/ 开始/ ,/ 往前/ 抽取/ 控制/ 逻辑/ 的/ 寄存器/ ,/ 这样/ ,/ 与/ 目标/ 属性/ 相关/ 的/ 路径/ 约束/ 涉及/ 的/ 寄存器/ 基本上/ 包括/ 在/ 了/ 抽象/ 模型/ 里/ ./ 由于/ 抽取/ 出/ 了/ 与/ 待/ 验证/ 目标/ 属性/ 最/ 相关/ 的/ 那/ 一部分/ 控制/ 逻辑/ ,/ 因此/ 可以/ 得到/ 比较/ 精确/ 的/ 抽象/ 模型/ 从而/ 为/ 模拟/ 过程/ 提供/ 精确/ 的/ 指导/ ./ 由于/ 本文/ 的/ 目的/ 是/ 同时/ 覆盖/ 设计/ 中/ 的/ 多个/ 目标/ 状态/ ,/ 如果/ 各/ 目标/ 状态/ 所/ 涉及/ 的/ 寄存器/ 变量/ 不同/ ,/ 则/ 会/ 提取/ 出/ 多个/ 抽象/ 模型/ ,/ 相应/ 会/ 获得/ 多个/ 抽象/ 距离/ 信息/ 表/ ,/ 即/ 一个/ 具体/ 状态/ 在/ 每个/ 抽象/ 模型/ 上/ 都/ 有/ 一个/ 抽象/ 距离/ 值/ ,/ 表示/ 该/ 状态/ 到/ 此/ 抽象/ 模型/ 上/ 的/ 目标/ 状态/ 的/ 距离/ 信息/ ./ 如果/ 各/ 目标/ 状态/ 所/ 涉及/ 的/ 寄存器/ 变量/ 相同/ ,/ 则/ 可以/ 共用/ 一个/ 抽象/ 模型/ ./ 用/ 一个/ 简单/ 的/ 例子/ 来/ 说明/ ,/ 原始/ 设计/ 的/ Verilog/ 描述/ 及其/ 对应/ 的/ DDG/ 如图/ 4/ 所示/ ./ 首先/ ,/ 对/ 设计/ 进行/ 分析/ 以/ 确定/ 目标/ 状态/ ./ 此处/ ,/ 我们/ 选择/ 该/ 设计/ 中/ 时序/ 深度/ 较/ 深/ 的/ 两个/ 状态/ state/ =/ S3/ 和/ state/ =/ S4/ 为/ 目标/ 状态/ 加以/ 说明/ ./ 由于/ 这/ 两个/ 目标/ 状态/ 涉及/ 的/ 寄存器/ 变量/ 相同/ ,/ 都/ 是/ state/ ,/ 因此/ 提取/ 出来/ 的/ 抽象/ 模型/ 也/ 相同/ ,/ 所/ 提取/ 的/ 抽象/ 模型/ 及/ 相应/ 的/ 抽象/ 距离/ 信息/ 如图/ 5/ 所示/ ./ 由图/ 中/ 可以/ 看出/ ,/ 针对/ 不同/ 的/ 目标/ 状态/ ,/ 每/ 一个/ 抽象/ 状态/ 都/ 具有/ 不同/ 的/ 抽象/ 距离/ 值/ ./ 图/ 4/ 一个/ RTL/ 设计/ 示例/ (/ a/ )/ 及/ 相应/ DDG/ (/ b/ )/ 3.2/ 评估/ 函数/ 本文/ 多/ 目标/ 覆盖/ 方法/ 的/ 动机/ 之一/ 是/ 我们/ 在/ 实验/ 中/ 观察/ 到/ 多个/ 难达/ 状态/ 是/ 很/ 可能/ 位于/ 同/ 一条/ 路径/ 中/ 的/ ./ 难达/ 状态/ 的/ 量化/ 定义/ 是/ 功能/ 验证/ 中/ 的/ 另/ 一个/ 难题/ ./ 随着/ 集成电路/ 设计/ 复杂度/ 的/ 提高/ ,/ 对/ 设计/ 进行/ 功能/ 验证/ 的/ 难度/ 也/ 不断/ 提高/ ./ 在/ 功能/ 验证/ 中/ ,/ 通常/ 很难/ 达到/ 100/ %/ 的/ 分支/ 覆盖率/ ,/ 因此/ 会/ 存在/ 分支/ 覆盖/ 漏洞/ (/ 未/ 被/ 覆盖/ 到/ 的/ 分支/ )/ ./ 覆盖/ 漏洞/ 对应/ 的/ 状态/ 要/ 被/ 遍历/ 到/ 通常/ 需要/ 激发/ 一些/ 难以/ 覆盖/ 到/ 的/ 分支/ 条件/ ./ 这些/ 分支/ 条件/ 一般/ 具有/ “/ 低/ 概率/ 到达/ ”/ 或者/ “/ 较/ 深/ 的/ 时序/ 深度/ (/ 需要/ 很长/ 的/ 输入/ 激励/ 序列/ )/ ”/ 的/ 特点/ ./ 本文/ ①/ VISHomepage/ ./ http/ :/ // // vlsi/ ./ colorado/ ./ edu/ // ~/ vis/ // Page6/ 将/ 这些/ 分支/ 条件/ 下/ 对应/ 的/ 状态/ 作为/ 待/ 验证/ 的/ 难达/ 目标/ 状态/ ./ 因此/ ,/ 如果/ 一个/ 状态/ 被/ 确定/ 为难/ 达/ 状态/ ,/ 那么/ 它/ 的/ 后继/ 状态/ 或/ 邻近/ 的/ 同等/ 时序/ 深度/ 的/ 状态/ 也/ 同样/ 可以/ 认为/ 是/ 难达/ 状态/ ./ 以图/ 4/ (/ a/ )/ 所/ 给/ 的/ 示例/ 设计/ 为例/ ,/ 假定/ 认为/ 分支/ 条件/ if/ (/ inp/ =/ =/ 1/ )/ 是/ 一种/ 低/ 概率/ 到达/ 条件/ ,/ 那么/ 其/ 对应/ 的/ 状态/ S2/ 被/ 认为/ 是/ 难达/ 状态/ ,/ 相应/ 的/ S2/ 的/ 后继/ 状态/ S3/ 和/ S4/ 同样/ 也/ 被/ 认为/ 是/ 难达/ 状态/ ./ 从/ 这个/ 角度/ 来说/ ,/ 难达/ 状态/ 是/ 很/ 可能/ 相互/ 靠近/ 或/ 处于/ 同/ 一条/ 路径/ 上/ ./ 因此/ ,/ 本文/ 定义/ 了/ 以下/ 评估/ 函数/ 来/ 量化/ 地/ 引导/ 激励/ 生成/ 能够/ 更/ 有效/ 地/ 同时/ 覆盖/ 多个/ 目标/ 状态/ ./ 对于/ 每/ 一个/ 设计/ 状态/ ,/ 评估/ 函数/ 根据/ 其/ 对应/ 到/ 不同/ 目标/ 状态/ 的/ 抽象/ 距离/ 定义/ 一个/ 综合/ 的/ 抽象/ 距离/ 值/ ,/ 命名/ 为/ “/ merge/ _/ dis/ ”/ ./ merge/ _/ dis/ 的/ 计算公式/ 为/ 其中/ :/ n/ 表示/ 目标/ 状态/ 的/ 数目/ ;/ di/ 表示/ 从/ 当前/ 状态/ 到/ 目标/ 状态/ i/ 的/ 抽象/ 距离/ ./ 如果/ 目标/ 状态/ i/ 还/ 没有/ 被/ 覆盖/ 到/ ,/ 则/ Ci/ =/ 1/ ,/ 否则/ Ci/ =/ 0/ ./ merge/ _/ dis/ 的/ 值/ 度量/ 了/ 每个/ 状态/ 到/ 各个/ 目标/ 状态/ 的/ 潜在/ 距离/ 信息/ ,/ 如果/ 该/ 状态/ 距离/ 目标/ 状态/ i/ 越近/ ,/ 则/ 对应/ 的/ di/ 值越/ 小/ ,/ 在/ 其他/ 项/ 保持/ 不变/ 的/ 情况/ 下/ ,/ 所/ 计算/ 出/ 的/ merge/ _/ dis/ 的/ 值/ 越/ 大/ ,/ 表示/ 从/ 该/ 状态/ 继续/ 向前/ 模拟/ 将/ 更/ 可能/ 快速/ 地/ 到达/ 其中/ 一个/ 或/ 多个/ 目标/ 状态/ ./ 简而言之/ ,/ merge/ _/ dis/ 的/ 值/ 越/ 大/ ,/ 则/ 表示/ 相应/ 的/ 状态/ 距离/ 某个/ (/ 或/ 某/ 几个/ )/ 目标/ 状态/ 越近/ ./ merge/ _/ dis/ 的/ 值/ 将/ 在/ 状态/ 选择器/ 中/ 用来/ 评估/ 模拟/ 过程/ 中/ 的/ 状态/ ,/ 试图/ 最终/ 能/ 搜索/ 出/ 一条/ 同时/ 覆盖/ 多个/ 目标/ 状态/ 的/ 路径/ 序列/ ./ 本文/ 提出/ 评估/ 函数/ 的/ 宗旨/ 是/ 综合/ 考虑/ 各个/ 状态/ 到/ 不同/ 目标/ 状态/ 的/ 全局/ 抽象/ 距离/ 信息/ ,/ 来/ 评估/ 各个/ 状态/ 到/ 目标/ 状态/ 的/ 难易/ 程度/ ./ 在/ 当前/ 状态/ 的/ 各个/ 后继/ 状态/ 中/ ,/ 如果/ 其中/ 一个/ 后继/ 状态/ 离/ 某个/ 目标/ 很近/ 或者/ 离/ 各个/ 目标/ 状态/ 都/ 比较/ 近时/ ,/ 我们/ 认为/ 选择/ 这个/ 状态/ 更/ 容易/ 到达/ 目标/ ,/ 因此/ 更/ 倾向/ 于/ 选择/ 这个/ 状态/ 继续/ 向前/ 模拟/ ./ 评估/ 函数/ 的/ 计算/ 式/ (/ 1/ )/ 给出/ 的/ 是/ 一个/ 经验/ 公式/ ,/ 其值/ 可以/ 反映/ 一个/ 状态/ 到/ 不同/ 目标/ 状态/ 的/ 难易/ 程度/ 的/ 趋势/ ./ 如果/ 一个/ 状态/ 到/ 目标/ 状态/ 越/ 远/ ,/ 则/ 这个/ 状态/ 相应/ 于/ 该/ 目标/ 的/ 抽象/ 距离/ 值/ di/ 越大/ ,/ 那么/ 可以/ 认为/ 从/ 这个/ 状态/ 到/ 该/ 目标/ 的/ 概率/ 越小/ ,/ 这种/ 趋势/ 可以/ 用/ 2/ -/ di/ 表示/ 出来/ ,/ 其中/ 2/ 是/ 一个/ 可变/ 的/ 值/ (/ 可以/ 取/ 大于/ 1/ 的/ 其他/ 数/ )/ ./ 当有/ 多个/ 目标/ 状态/ 时/ ,/ 我们/ 更/ 倾向/ 于/ 从/ 后继/ 状态/ 中/ 选择/ 离/ 各个/ 目标/ 状态/ 相对/ 都/ 比较/ 近/ 或者/ 离/ 其中/ 一个/ 目标/ 状态/ 最近/ 的/ 状态/ 向前/ 模拟/ ./ 当/ 目标/ 状态/ i/ 到达/ 后/ ,/ 通过/ 设置/ 其/ 对应/ 参数/ Ci/ =/ 0/ 来/ 屏蔽/ 该/ 目标/ 相应/ 的/ 抽象/ 距离/ 信息/ 对/ 后续/ 模拟/ 过程/ 的/ 指导/ 产生/ 干扰/ 作用/ ./ 式/ (/ 1/ )/ 中/ 的/ 评估/ 函数/ 能/ 较/ 好/ 地区/ 分出/ 多/ 目标/ 情况/ 下/ 不同/ 后继/ 状态/ 的/ “/ 优劣/ ”/ 程度/ ./ 举例说明/ 如下/ :/ 假设/ 两个/ 目标/ 状态/ 为/ t1/ 和/ t2/ ,/ 当前/ 状态/ 的/ 两个/ 后继/ 状态/ 为/ A/ 和/ B/ ,/ 考虑/ 以下/ 3/ 种/ 情况/ :/ (/ 1/ )/ 假定/ A/ 相对/ 于/ 目标/ 状态/ t1/ 和/ t2/ 的/ 抽象/ 距离/ 分别/ 为/ 2/ 、/ 3/ ;/ B/ 相对/ 于/ 目标/ t1/ 和/ t2/ 的/ 抽象/ 距离/ 分别/ 为/ 3/ 、/ 4/ ,/ 即/ 状态/ A/ 离/ 两个/ 目标/ 状态/ 的/ 距离/ 都/ 比/ B/ 近/ ,/ 那么/ 这种/ 情况/ 下/ 我们/ 认为/ 状态/ A/ 优于/ B/ ,/ 应/ 优先选择/ A/ 状态/ 作为/ 下/ 一步/ 模拟/ 的/ 开始/ 状态/ ;/ (/ 2/ )/ 假定/ A/ 相对/ 于/ 目标/ 状态/ t1/ 和/ t2/ 的/ 抽象/ 距离/ 分别/ 为/ 2/ 、/ 2/ ;/ B/ 相对/ 于/ 目标/ t1/ 和/ t2/ 的/ 抽象/ 距离/ 分别/ 为/ 2/ 、/ 3/ ,/ 那么/ 这种/ 情况/ 下/ 我们/ 认为/ 状态/ A/ 优于/ B/ ,/ 选择/ A/ 状态/ 将/ 更/ 有/ 潜力/ 快速/ 覆盖/ 两个/ 目标/ 状态/ ;/ (/ 3/ )/ 假定/ A/ 相对/ 于/ 目标/ 状态/ t1/ 和/ t2/ 的/ 抽象/ 距离/ 分别/ 为/ 1/ 、/ 4/ ;/ B/ 相对/ 于/ 目标/ t1/ 和/ t2/ 的/ 抽象/ 距离/ 分别/ 为/ 2/ 、/ 3/ ,/ 那么/ 这种/ 情况/ 下/ 我们/ 也/ 认为/ 状态/ A/ 优于/ B/ ,/ 能/ 更/ 快/ 到达/ 其中/ 一个/ 目标/ ./ 在/ 式/ (/ 1/ )/ 中/ ,/ 我们/ 可以/ 用/ 2/ -/ di/ 表示/ 出/ 从/ 各个/ 状态/ 到达/ 目标/ 状态/ i/ 的/ 难易/ 程度/ (/ 概率/ 趋势/ )/ ,/ 那么/ 当有/ 多个/ 目标/ 状态/ 时/ 可以/ 用/ 这个/ 概率/ 趋势/ 的/ 算术/ 求和/ 方式/ 来/ 评估/ 全局/ 的/ 情况/ ,/ 这种/ 方式/ 也/ 能/ 较/ 好/ 地区/ 分/ 上述/ 几种/ 情况/ 下/ 各个/ 后继/ 状态/ 的/ 优劣/ ,/ 指导/ 状态/ 的/ 选择/ ./ 尤其/ 当/ 目标/ 状态/ 在/ 同/ 一条/ 路径/ 上时/ 这种/ 方式/ 效果/ 很/ 明显/ ,/ 即/ t1/ 和/ t2/ 在/ 同/ 一条/ 路径/ 上时/ ,/ 如果/ 状态/ A/ 到/ 目标/ t1/ 的/ 距离/ 比/ 状态/ B/ 到/ t1/ 的/ 距离/ 近/ ,/ 那么/ A/ 离/ 目标/ t2/ 也/ 会/ 比/ B/ 近/ ,/ 也/ 就是/ 对应/ 上述/ 3/ 种/ 情况/ 中/ 的/ 第/ 1/ 种/ 情况/ ,/ 这种/ 情况/ 下/ 显然/ 应该/ 优先选择/ A/ 状态/ 继续/ 向前/ 模拟/ ./ 综上所述/ ,/ 本文/ 提出/ 的/ 评估/ 函数/ 能够/ 对/ 多/ 目标/ 覆盖/ 方法/ 提供/ 合理/ 的/ 评估/ 与/ 指导/ ./ 3.3/ 基于/ 路径/ 约束/ 求解/ 的/ 激励/ 生成器/ 本文/ 采用/ PACOST/ 中/ 提出/ 的/ 基于/ 路径/ 约束/ 求解/ 的/ 激励/ 生成/ 方式/ ,/ 这种/ 方式/ 结合/ 了/ 具体/ 模拟/ 和/ 符号/ 模拟/ 技术/ ,/ 能够/ 有效/ 地/ 产生/ 输入/ 向量/ ./ 符号/ 模拟/ 方法/ 是/ 一种/ 典型/ 的/ 半/ 形式化/ 验证/ 方法/ ,/ 主要/ 被/ 应用/ 于门级/ 的/ 测试/ 验证/ 中/ ./ 其/ 基本/ 思想/ 是/ 用/ 输入/ 的/ 布尔/ 变量/ 代替/ 布尔/ 常量/ 对/ 电路设计/ 进行/ 模拟/ ,/ 将/ 模拟/ 验证/ 从/ 布尔值/ 扩展/ 到/ 符号/ 领域/ ./ 由于/ 采用/ 变量/ 的/ 符号/ 值/ 代替/ 具体/ 值/ 进行/ 模拟/ ,/ 因此/ 一次/ 符号/ 模拟/ 相当于/ 模拟/ 了/ 一个/ 很大/ 的/ 测试/ 集/ ,/ 可以/ 在/ 一个/ 模拟/ 周期/ 内/ 完成/ 传统/ 模拟/ 方法/ 多个/ 周期/ 才能/ 完/ Page7/ 成/ 的/ 任务/ ./ 寄存器/ 传输/ 级/ (/ RegisterTransferLevel/ ,/ RTL/ )/ 的/ 符号/ 模拟/ 是/ 通过/ 对/ 设计/ 代码/ 进行/ 静态/ 分析/ 来/ 实现/ ./ 文献/ [/ 10/ -/ 11/ ]/ 中/ 成功/ 地/ 将/ 符号/ 模拟/ 和/ 具体/ 模拟/ 相结合/ ,/ 为/ RTL/ 设计/ 验证/ 产生/ 有效/ 的/ 输入/ 向量/ ,/ 从而/ 达到/ 较/ 高/ 的/ 覆盖率/ ./ 本文/ 方法/ 中/ ,/ 符号/ 模拟/ 将/ 沿着/ 具体/ 模拟/ 路径/ ,/ 提取/ 其中/ 分支/ 结点/ 的/ 符号/ 表达式/ 组成/ 路径/ 约束/ ./ 路径/ 约束/ 是/ 一个/ 布尔/ 表达式/ ,/ 由/ 分支/ 条件/ 的/ 符号/ 表达式/ 的/ 逻辑/ 合取/ 构成/ ./ 设计/ 的/ 控制/ 流程图/ (/ ControlFlowGraph/ ,/ CFG/ )/ 被/ 建立/ 以/ 辅助/ 约束/ 提取/ 的/ 过程/ ./ 在/ 每个/ 模拟/ 步骤/ 内/ ,/ 首先/ 应用/ 一组/ 随机/ 的/ 输入/ 向量/ 对/ 设计/ 进行/ 模拟/ ,/ 在/ CFG/ 中/ 记录/ 相应/ 的/ 具体/ 路径/ ./ 符号/ 模拟/ 沿着/ CFG/ 中/ 的/ 这条/ 具体/ 路径/ 将/ 每个/ 分支/ 结点/ 的/ 符号/ 表达式/ 提取/ 出来/ 作为/ 约束条件/ (/ guard/ )/ ,/ 此/ 路径/ 上/ 所有/ 的/ 约束条件/ 的/ 合取/ 构成/ 相应/ 的/ 路径/ 约束/ ./ HYBRO/ [/ 11/ ]/ 是/ 一次性/ 将/ 设计/ 展开/ 固定/ 的/ 拍数/ ,/ 首先/ 对/ 设计/ 进行/ 特定/ 周期/ 数目/ 的/ 随机/ 模拟/ ,/ 从中/ 提取/ 出/ 路径/ 约束/ ,/ 通过/ 约束条件/ 的/ 翻转/ 来/ 覆盖/ 新/ 的/ 分支/ ./ 它/ 使用/ 分支/ 覆盖率/ 作为/ 度量/ ./ 由于/ 路径/ 爆炸/ 的/ 问题/ ,/ HYBRO/ 能够/ 展开/ 的/ 周期/ 数目/ 很/ 有限/ ,/ 不能/ 覆盖/ 时序/ 深度/ 较/ 深/ 的/ 难达/ 状态/ ./ 针对/ 这个/ 问题/ ,/ PACOST/ 提出/ 了/ 结合/ 具体/ 模拟/ 和/ 符号/ 模拟/ 的/ 基于/ 路径/ 约束/ 求解/ 的/ 难达/ 状态/ 激励/ 生成/ 方法/ ,/ 在/ 每/ 一个/ 模拟/ 步骤/ 中/ 只/ 提取/ 一个/ 周期/ 的/ 路径/ 约束/ ,/ 利用/ 抽象/ 距离/ 信息/ 逐步/ 地/ 指导/ 模拟/ 过程/ ,/ 通过/ 连续/ 的/ 模拟/ 步骤/ 在/ 更/ 大/ 的/ 周期/ 数目/ 上/ 对/ 设计/ 的/ 状态/ 空间/ 进行/ 探索/ ,/ 最终/ 覆盖/ 到/ 时序/ 深度/ 较/ 深/ 的/ 难达/ 状态/ ./ 本文/ 采用/ 的/ 激励/ 产生/ 方法/ 与/ PACOST/ 中/ 的/ 一致/ ,/ 但/ 目标/ 是/ 同时/ 覆盖/ 设计/ 中/ 的/ 多个/ 难达/ 状态/ ./ 在/ 每/ 一步/ 模拟/ 中/ ,/ 本文/ 也/ 只/ 提取/ 一个/ 周期/ 的/ 路径/ 约束/ ,/ 通过/ 约束条件/ 的/ 翻转/ 与/ 求解/ 产生/ 新/ 的/ 候选/ 状态/ ,/ 然后/ 利用/ 评估/ 函数/ 对/ 各个/ 候选/ 状态/ 进行/ 评价/ ,/ 指导/ 状态/ 的/ 选择/ 及/ 模拟/ 过程/ ,/ 直到/ 最终/ 同时/ 覆盖/ 到/ 时序/ 深度/ 较/ 深/ 的/ 多个/ 难达/ 状态/ ./ 路径/ 约束/ 是/ 由/ 具体/ 路径/ 上/ 所有/ 控制/ 条件/ (/ 约束条件/ )/ 表达式/ 的/ 合取/ 构成/ ./ 与/ PACOST/ 中/ 一致/ ,/ 本文/ 方法/ 中/ ,/ 路径/ 约束/ 主要/ 包括/ 与/ 原始/ 输入/ 直接/ 相关/ 的/ 分支/ 控制/ 条件/ ./ 路径/ 约束/ 的/ 提取/ 包括/ 以下/ 3/ 个/ 步骤/ :/ ①/ 在/ 设计/ 中/ 添加/ 计数器/ 并/ 构建/ CFG/ ;/ ②/ 单/ 周期/ 的/ 具体/ 模拟/ ;/ ③/ 符号/ 模拟/ 提取/ 路径/ 约束/ ./ 下面/ 我们/ 将/ 分别/ 具体/ 介绍/ 这/ 几个/ 步骤/ ./ (/ 1/ )/ 在/ 设计/ 中/ 添加/ 计数器/ 并/ 构建/ CFGRTL/ 的/ 符号/ 模拟/ 是/ 通过/ 对/ 设计/ 代码/ 进行/ 分析/ ,/ 构建/ 设计/ 的/ CFG/ 来/ 实现/ 的/ ./ CFG/ 从/ 设计/ 的/ VRM/ 模型/ (/ verilogRTLmodel/ )/ 中/ 提取/ ,/ 其中/ ,/ 一个/ 结点/ 对应/ 一条/ 设计/ 语句/ ./ 对应/ 每/ 一个/ CFG/ 结点/ ,/ 用/ 一个/ 链表/ 来/ 保存/ 其/ 数据流/ 图/ (/ DataFlowGraph/ ,/ DFG/ )/ 信息/ ,/ 表尾/ 节点/ 对应/ 语句/ 表达式/ ./ 计数器/ 的/ 赋值/ 语句/ 也/ 作为/ CFG/ 的/ 一部分/ ./ 为了/ 在/ CFG/ 中/ 记录/ 具体/ 路径/ ,/ 我们/ 使用/ perl/ 脚本/ 在/ 设计/ 中/ 的/ 每/ 一个/ 分支/ 条件/ 语句/ 后面/ 加入/ 计数器/ ,/ 作为/ 具体/ 模拟/ 和/ 符号/ 模拟/ 的/ 通道/ ./ 每个/ 计数器/ 变量/ 维持/ 一个/ 数组/ ,/ 该/ 数组/ 以/ 时钟/ 周期/ 数为/ 下标/ ./ 在/ 一/ 拍/ 随机/ 模拟/ 后/ ,/ 将/ 计数器/ 的/ 值/ 与/ 上/ 一/ 拍/ 的/ 值/ 进行/ 对比/ ,/ 如果/ 值有/ 增加/ ,/ 表示/ 相应/ 的/ 分支/ 被/ 执行/ 了/ ,/ 符号/ 模拟/ 则/ 提取/ 出该/ 分支/ 条件/ ,/ 否则/ 将/ 该/ 分支/ 条件/ 取反/ 后/ 加入/ 路径/ 约束/ 中/ ./ 图/ 4/ (/ a/ )/ 所/ 给/ 示例/ 设计/ 添加/ 计数器/ 后/ 的/ 设计/ 及/ 相应/ CFG/ 如图/ 6/ 所示/ ./ 图/ 6/ (/ a/ )/ 中带/ 下划线/ 的/ 赋值/ 语句/ 表示/ 所/ 添加/ 的/ 计数器/ ,/ 对应/ 于图/ 6/ (/ b/ )/ 中/ 的/ 节点/ i/ [/ n/ ]/ ./ 图/ 6/ 添加/ 计数器/ 后/ 的/ 示例/ 设计/ (/ 图/ (/ a/ )/ )/ 及/ 相应/ CFG/ (/ 图/ (/ b/ )/ )/ (/ 2/ )/ 单/ 周期/ 的/ 具体/ 模拟/ 在/ 每个/ 模拟/ 步骤/ 中/ ,/ 首先/ 产生/ 一拍/ 随机/ 输入/ 向量/ ,/ 经过/ 具体/ 设计/ 上/ 的/ 模拟/ 之后/ ,/ 在/ CFG/ 上/ 标记/ 出/ 相应/ 的/ 具体/ 执行/ 路径/ ./ 对于/ 图/ 4/ (/ a/ )/ 中/ 的/ 设计/ ,/ 假设/ 当前/ 状态/ 为/ state/ =/ S0/ ,/ 随机/ 产生/ 的/ 输入/ 激励/ 为/ reset/ =/ 0/ ,/ inp/ =/ 101/ ,/ 那么/ 模拟/ 后/ 得到/ 的/ 具体/ 执行/ 路径/ 如图/ 7/ (/ a/ )/ 中加/ 粗线条/ 所示/ ./ (/ 3/ )/ 符号/ 模拟/ 提取/ 路径/ 约束/ CFG/ 中/ 标记/ 出来/ 的/ 具体/ 路径/ 被/ 符号/ 模拟/ 并/ 提取/ 出/ 路径/ 中/ 相应/ 的/ 控制/ 条件/ 的/ 表达式/ 作为/ 路径/ 约束条件/ ./ 这些/ 约束条件/ 被/ 存入/ 一个/ 约束/ 栈中/ ,/ 路径/ 上/ 所有/ 约束条件/ 表达式/ 的/ 合取/ 构成/ 了/ 路径/ 约束/ ./ 对于/ 图/ 7/ (/ a/ )/ 中/ 所示/ 的/ 具体/ 路径/ ,/ 从中/ 提取/ 出/ 的/ 符号/ 表达/ Page8/ 式/ 为/ reset/ =/ 0/ ∧/ state/ =/ S0/ ∧/ !/ (/ inp/ =/ =/ 1/ )/ ./ 每次/ 改变/ (/ 或/ 取反/ )/ 一个/ 约束条件/ ,/ 可以/ 获得/ 一条/ 新/ 的/ 路径/ 约束/ ,/ 然后/ 用/ 约束/ 求解/ 器/ 进行/ 求解/ ,/ 如果/ 该/ 约束/ 是/ 可/ 满足/ 的/ ,/ 则/ 能/ 求解/ 得到/ 一拍/ 输入/ 向量/ (/ 不/ 在/ 约束条件/ 中/ 的/ 原始/ 输入/ 变量/ 的/ 值/ 随机/ 生成/ )/ ,/ 回到/ 当前/ 状态/ 进行/ 模拟/ 后/ 得到/ 一个/ 候选/ 状态/ ./ 已经/ 取反/ 过/ 的/ 约束条件/ 将/ 从/ 约束/ 栈中/ 移除/ ,/ 其/ 对应/ 变量/ 的/ 值/ 将/ 随机/ 产生/ ./ 候选/ 状态/ 的/ 数目/ 与/ 约束/ 栈中/ 约束条件/ 的/ 数目/ 相同/ ./ 通过/ 约束/ 求解/ 产生/ 的/ 候选/ 状态/ 通常/ 能/ 对应/ 设计/ 状态/ 空间/ 中/ 的/ 不同/ 状态/ ./ 需要/ 注意/ 的/ 是/ 本文/ 方法/ 在/ 每/ 一个/ 模拟/ 步骤/ 中/ 只/ 提取/ 了/ 单个/ 周期/ 内/ 的/ 路径/ 约束/ ,/ 如果/ 一个/ 约束条件/ 是/ 由/ 中间/ 寄存器/ 定义/ 的/ ,/ 则/ 放弃/ 对/ 这个/ 约束条件/ 的/ 取反/ 并/ 保持/ 它/ 在/ 上/ 一个/ 模拟/ 周期/ 中/ 的/ 值/ ./ 事实上/ 这些/ 约束条件/ 仍然/ 是/ 有/ 机会/ 改变/ 的/ ,/ 通过/ 回退/ 到/ 其中/ 间/ 寄存器/ 定义/ 的/ 地方/ ,/ 回退/ 策略/ 将/ 在/ 3.4/ 节中/ 详细/ 介绍/ ./ 目前/ 商业界/ 应用/ 中/ 比较/ 先进/ 的/ 约束/ 随机/ 模拟/ 验证/ 是/ 在/ 随机/ 模拟/ 过程/ 中/ 施加/ 一定/ 的/ 约束/ ,/ 使/ 其/ 按照/ 约束/ 生成/ 随机化/ 的/ 激励/ ,/ 即/ 让/ 它/ 生成/ 的/ 随机化/ 的/ 激励/ 更多/ 地落/ 在/ 我们/ 感兴趣/ 的/ 区域/ 或者/ 边界/ 内/ ,/ 以/ 更/ 快/ 地/ 达到/ 功能/ 覆盖率/ 的/ 要求/ [/ 12/ ]/ ./ 随机/ 种子/ 值/ 和/ 约束/ 被/ 送入/ 约束/ 求解/ 器/ (/ 集成/ 在/ 模拟器/ 中/ )/ 求解/ 产生/ 合法/ 的/ 输入/ 激励/ ./ 在/ 约束/ 随机/ 模拟/ 方法/ 中/ ,/ 约束/ 通常/ 是/ 对/ 输入/ 变量/ 取值/ 范围/ 或/ 区间/ 分布/ 概率/ 的/ 约束/ ,/ 或者/ 以/ 断言/ (/ SystemVerilogAssertion/ ,/ SVA/ )/ 或/ 属性/ (/ PropertySpecificationLanguage/ ,/ PSL/ )/ 的/ 形式/ 定义/ 对/ 某些/ 中间/ 变量/ 的/ 约束/ ,/ 这些/ 约束/ 需要/ 验证/ 人员/ 对/ 设计/ 非常/ 了解/ 之后/ ,/ 以/ 人工/ 提取/ 功能/ 约束/ 的/ 方式/ 添加/ 到/ 测试/ 平台/ 中/ ,/ 作为/ 测试/ 平台/ 的/ 一部分/ ./ 不同于/ 约束/ 随机/ 模拟/ 的/ 方法/ ,/ 本文/ 方法/ 是/ 一种/ 抽象/ 引导/ 的/ 半/ 形式化/ 方法/ ,/ 可以/ 自动/ 生成/ 确定性/ 的/ 输入/ 激励/ 以/ 覆盖/ 设计/ 中/ 的/ 难达/ 状态/ ./ 本文/ 中/ 的/ 约束/ 是/ 由/ 具体/ 执行/ 路径/ 上/ 所有/ 控制/ 条件/ (/ 约束条件/ )/ 表达式/ 的/ 合取/ 构成/ ,/ 是/ 在/ 模拟/ 的/ 过程/ 中/ 自动/ 提取/ 的/ ,/ 并/ 不是/ 测试/ 平台/ 的/ 一部分/ ,/ 测试/ 平台/ 只是/ 接受/ 约束/ 求解/ (/ 约束/ 求解/ 器/ 独立/ 于/ 模拟器/ )/ 产生/ 的/ 输入/ 激励/ 到/ 待/ 验证/ 设计/ (/ DesignUnderVerification/ ,/ DUV/ )/ 中/ 进行/ 模拟/ ./ 约束/ 提取/ 的/ 过程/ 如前所述/ ,/ 首先/ 在/ DUV/ 上/ 进行/ 随机/ 模拟/ ,/ 在/ CFG/ 中/ 记录/ 具体/ 的/ 执行/ 路径/ ,/ 符号/ 模拟/ 沿着/ 具体/ 路径/ 提取/ 分支/ 条件/ 构成/ 路径/ 约束/ ./ 通过/ 约束条件/ 的/ 翻转/ 与/ 求解/ 产生/ 新/ 的/ 输入/ 激励/ ,/ 传递/ 给/ 测试/ 平台/ 进行/ 模拟/ 后/ 遍历/ 到/ 新/ 的/ 路径/ 分支/ ,/ 提供/ 更/ 多/ 更/ 优秀/ 的/ 候选/ 状态/ ./ 然后/ 利用/ 抽象/ 距离/ 信息/ 对/ 这些/ 状态/ 进行/ 评估/ 选择/ ,/ 指导/ 模拟/ 过程/ ./ 3.4/ 状态/ 选择器/ 状态/ 选择器/ 利用/ 评估/ 函数/ 计算/ 出/ 的/ 综合/ 抽象/ 距离/ 值/ merge/ _/ dis/ 来/ 评估/ 候选/ 状态/ ,/ 并/ 以此/ 来/ 逐步/ 引导/ 搜索/ 过程/ 到达/ 所有/ 目标/ ./ 评估/ 函数/ 同时/ 考虑/ 了/ 从/ 一个/ 状态/ 到/ 不同/ 目标/ 状态/ 的/ 抽象/ 距离/ 值/ ,/ 评价/ 出/ 从/ 各个/ 状态/ 到达/ 某个/ 目标/ 状态/ 或者/ 同时/ 到达/ 多个/ 目标/ 状态/ 的/ 潜能/ ./ 在/ 当前/ 状态/ 的/ 各个/ 后继/ 状态/ 中/ ,/ 如果/ 其中/ 一个/ 后继/ 状态/ 离/ 各个/ 目标/ 状态/ 都/ 比较/ 近/ 或者/ 离/ 某个/ 目标/ 很近/ 时/ ,/ 评估/ 函数/ 计算/ 出/ 的/ 该/ 状态/ 对应/ 的/ merge/ _/ dis/ 值会/ 比/ 其他/ 后继/ 状态/ 的/ 大/ ,/ 表示/ 从/ 该/ 状态/ 出发/ 继续/ 模拟/ 会/ 更/ 容易/ 到达/ 目标/ ./ 因此/ ,/ 在/ 每/ 一个/ 模拟/ 步骤/ 中/ ,/ 状态/ 选择器/ 从/ 约束/ 求解/ 产生/ 的/ 几个/ 候选/ 状态/ 中/ 选择/ 一个/ 评估/ 函数/ 值/ 最大/ 的/ 作为/ 下/ 一步/ 模拟/ 的/ 当前/ 态/ ./ 在/ 每/ 一步/ 模拟/ 开始/ 时/ ,/ 选定/ 当前/ 状态/ (/ 第一/ 拍为/ reset/ 之后/ 的/ 状态/ )/ ,/ 产生/ 一拍/ 随机/ 向量/ ,/ 在/ 具体/ 设计/ 上/ 模拟/ 后/ 得到/ 一个/ 候选/ 状态/ ,/ 并/ 在/ 设计/ 的/ CFG/ 中/ 记录/ 具体/ 执行/ 路径/ ,/ 然后/ 采用/ 符号/ 模拟/ 方法/ 从/ 具体/ 路径/ 中/ 提取/ 路径/ 约束/ ./ 每次/ 改变/ 一个/ 约束条件/ ,/ 通过/ 求解/ 器/ 求解/ 之后/ 得出/ 一拍/ 输入/ 向量/ ;/ 设计/ 状态/ 回到/ 当前/ 状态/ ,/ 模拟/ 后/ 产生/ 一个/ 新/ 的/ 候选/ 状态/ ,/ 如果/ 有/ N/ 个/ 约束条件/ 则/ 循环/ N/ 次/ ,/ 共/ 得到/ N/ +/ 1/ 个/ 候选/ 状态/ ./ 然后/ 利用/ merge/ _/ dis/ 值/ 对/ 这些/ 候选/ 状态/ 进行/ 评估/ ,/ 从中/ 选择/ merge/ _/ dis/ 值/ 最大/ 并未/ 被/ 访问/ 过/ 的/ 状态/ 作为/ 下/ 一/ 当前/ 态/ ./ 当/ 某个/ 目标/ 状态/ 被/ 覆盖/ 到/ 后/ ,/ 如果/ 这个/ 目标/ 状态/ 的/ merge/ _/ dis/ 值/ 大于/ 初始状态/ 的/ (/ 说明/ 从/ 已/ 到达/ 的/ 目标/ 状态/ 到/ 下/ 一个/ 目标/ 状态/ 之间/ 有/ 比/ 从/ 初始状态/ 开始/ 的/ 一条/ 更/ 短/ 的/ 路径/ ,/ 即/ 这/ 两个/ 目标/ 状态/ 位于/ 同/ 路径/ 中/ ,/ 或者/ 存在/ 从/ 已/ 到达/ 的/ 目标/ Page9/ 状态/ 返回/ 某个/ 中间状态/ 的/ 转移/ 边/ ,/ 而/ 从/ 该/ 中间状态/ 到/ 下/ 一个/ 目标/ 会/ 比/ 从/ 初始状态/ 到/ 目标/ 的/ 路径/ 更/ 短/ )/ ,/ 则/ 模拟/ 过程/ 将/ 从/ 这个/ 已/ 到达/ 的/ 目标/ 状态/ 继续/ 进行/ ;/ 否则/ 说明/ 当前/ 已/ 到达/ 的/ 目标/ 状态/ 与/ 其他/ 未/ 到达/ 的/ 目标/ 状态/ 是/ 处于/ 从/ 初始状态/ 开始/ 分叉/ 的/ 不同/ 路径/ 上/ ,/ 因此/ ,/ 将/ 从/ 初始状态/ 重新/ 开始/ 模拟/ 一条/ 新/ 的/ 路径/ 以/ 覆盖/ 未/ 被/ 覆盖/ 的/ 其他/ 目标/ 状态/ ./ 重复/ 整个/ 过程/ 直到/ 覆盖/ 到/ 所有/ 的/ 目标/ 状态/ 或/ 到达/ 设定/ 的/ 模拟/ 时间/ 上限/ ./ 模拟/ 步骤/ 1234/ 表/ 1/ 示例/ 设计图/ 4/ (/ a/ )/ 的/ 激励/ 生成/ 过程/ 路径/ 约束/ NullNullNull/ 从表/ 1/ 中/ 可以/ 看出/ ,/ 通过/ 对/ 路径/ 约束/ 中/ 的/ 条件/ 取反/ ,/ 求解/ 后/ 可以/ 获得/ 一个/ 新/ 的/ 输入/ 激励/ ,/ 回到/ 当前/ 态/ 模拟/ 后能/ 遍历/ 到/ 一个/ 之前/ 没有/ 遍历/ 到/ 的/ 新/ 状态/ ./ 在/ 这个/ 例子/ 中/ ,/ 只/ 在/ 第/ ②/ 个/ 模拟/ 步骤/ 中有/ 提取/ 出/ 路径/ 约束/ ./ 该/ 模拟/ 步/ 的/ 开始/ 状态/ 是/ S0/ ,/ 首先/ 随机/ 产生/ 一拍/ 输入/ 向量/ (/ 101/ )/ ,/ 模拟/ 后/ 获得/ 一个/ 候选/ 状态/ S1/ ,/ 并/ 在/ CFG/ 图中/ 记录/ 具体/ 执行/ 路径/ i1/ -/ i2/ -/ i4/ ,/ 如图/ 7/ (/ a/ )/ 中/ 所示/ ./ 符号/ 模拟/ 沿着/ 具体/ 路径/ 提取/ 出/ 路径/ 约束/ !/ (/ inp/ =/ =/ 1/ )/ ,/ 然后/ 通过/ 约束条件/ 的/ 翻转/ (/ 取反/ )/ 可以/ 获得/ 新/ 的/ 路径/ 约束/ (/ inp/ =/ =/ 1/ )/ ,/ 调用/ SMT/ (/ SatisfiabilityModuloTheory/ )/ 约束/ 求解/ 器/ 求解/ 后/ 获得/ 新/ 的/ 输入/ 激励/ (/ 001/ )/ ,/ 最后/ 回到/ 该/ 模拟/ 步/ 的/ 开始/ 状态/ S0/ 重新/ 用/ 新/ 的/ 激励/ 模拟/ 后/ 得到/ 另/ 一个/ 候选/ 状态/ S2/ ./ 在/ 每/ 一个/ 模拟/ 步骤/ 中/ ,/ 用图/ 5/ (/ b/ )/ 中/ 的/ 抽象/ 距离/ 信息/ 及式/ (/ 1/ )/ 所示/ 的/ merge/ _/ dis/ 值/ 计算方法/ 来/ 评估/ 候选/ 状态/ ,/ 从中/ 选择/ merge/ _/ dis/ 值/ 最大/ 的/ 候选/ 状态/ 作为/ 次态/ (/ 即下/ 一步/ 模拟/ 的/ 当前/ 态/ )/ ./ 在/ 第/ ②/ 步/ 模拟/ 获得/ 的/ 两个/ 候选/ 状态/ S1/ 和/ S2/ 中/ ,/ S2/ 的/ merge/ _/ dis/ 值/ 更/ 大/ ,/ 说明/ 选择/ S2/ 作为/ 下/ 一步/ 模拟/ 的/ 开始/ 状态/ 将/ 能/ 更/ 快/ 的/ 到达/ 目标/ 状态/ ,/ 因此/ ,/ S2/ 被选为/ 第/ ③/ 步/ 模拟/ 的/ 开始/ 状态/ ./ 在/ 第/ ③/ 个/ 模拟/ 步骤/ 中/ ,/ 目标/ 状态/ S3/ 到达/ ,/ 因此/ 需要/ 比较/ S3/ 与/ reset/ 状态/ S0/ 的/ merge/ _/ dis/ 值/ ,/ 其中/ 值/ 较大/ 的/ 表示/ 相应/ 状态/ 离下/ 一个/ 目标/ 状态/ 较近/ ,/ 被选为/ 下/ 一步/ 模拟/ 的/ 当前/ 态/ ./ 最终/ 获得/ 的/ 能/ 同时/ 覆盖/ 目标/ 状态/ S3/ 和/ S4/ 的/ 状态/ 序列/ 为/ S0/ -/ S2/ -/ S3/ -/ S4/ ,/ 对应/ 产生/ 的/ 激励/ 序列/ 为/ {/ 010/ ,/ 001/ ,/ 011/ ,/ 000/ }/ ./ 在/ 这个/ 例子/ 中/ ,/ 纯/ 随机/ 的/ 方法/ 很/ 容易/ 陷入/ 由/ 状态/ S0/ 和/ S1/ 构成/ 的/ 循环/ 之中/ ,/ 因为/ 在/ 模拟/ 步/ ②/ 中/ 从/ 状态/ S0/ 到/ 状态/ S1/ 的/ 转移/ 概率/ 很大/ (/ 7/ // 8/ )/ ./ 从/ 这个/ 例/ 3.4/ ./ 1/ 示例/ :/ 图/ 4/ (/ a/ )/ 的/ 多/ 目标/ 激励/ 生成/ 过程/ 我们/ 利用/ 图/ 4/ (/ a/ )/ 中所/ 给/ 的/ 设计/ 来/ 说明/ 本文/ 方法/ 的/ 激励/ 生成/ 过程/ ,/ 如表/ 1/ 所示/ ./ 简单/ 起/ 见/ ,/ 此处/ 只/ 考虑/ 两个/ 目标/ 状态/ state/ =/ S3/ 和/ state/ =/ S4/ 作为/ 示例/ ./ 假定/ 设计/ 的/ 初始状态/ 为/ state/ =/ 0/ ,/ reset/ 信号/ 在/ 第一个/ 模拟/ 周期/ 中/ 取值/ 为/ 1/ ,/ 在/ 后续/ 的/ 模拟/ 周期/ 中/ 取值/ 为/ 0/ ./ 为/ 避免/ 约束/ 求解/ 冲突/ ,/ 我们/ 没有/ 提取/ case/ 语句/ 中/ 的/ 条件/ 作为/ 约束条件/ ,/ 此外/ ,/ reset/ 信号/ 也/ 未/ 被/ 提取/ 为/ 约束条件/ ./ 新/ 的/ 约束/ 新/ 的/ 输入/ 子/ 可以/ 看出/ ,/ 当/ 目标/ 状态/ 相互/ 靠近/ 或/ 在/ 同/ 一条/ 路径/ (/ trace/ )/ 中/ 时/ ,/ 采用/ 本文/ 多/ 目标/ 同时/ 覆盖/ 的/ 方法/ 可以/ 很快/ 覆盖/ 到/ 多个/ 目标/ 状态/ ./ 3.4/ ./ 2/ 死胡同/ 状态/ 的/ 回避/ 策略/ 与/ 其他/ 抽象/ 引导/ 的/ 半/ 形式/ 方法/ 一样/ ,/ 本文/ 方法/ 面临/ 的/ 一个/ 重要/ 问题/ 是/ 死胡同/ 状态/ 问题/ ./ 由于/ 要/ 对/ 设计/ 进行/ 抽象/ ,/ 抽象/ 模型/ 与/ 原始/ 设计/ 之间/ 存在/ 抽象/ 误差/ ,/ 因此/ 死胡同/ 问题/ 不可避免/ ./ 抽象/ 实际上/ 是/ 对/ 设计/ 状态/ 进行/ 合并/ ,/ 原始/ 设计/ 中/ 的/ 多个/ 状态/ 在/ 抽象/ 模型/ 上/ 被/ 合并/ 为/ 一个/ 状态/ ,/ 原始/ 设计/ 中/ 原本/ 不/ 存在/ 转移/ 关系/ 的/ 两个/ 状态/ 在/ 抽象/ 模型/ 中/ 可能/ 会/ 引入/ 对应/ 的/ 转移/ 关系/ ,/ 因此/ 导致/ 了/ 死胡同/ 问题/ 的/ 出现/ ./ 由于/ 抽象/ 模型/ 上/ 虚假/ 边/ 的/ 引入/ ,/ 使得/ 具体/ 设计/ 中离/ 目标/ 很远/ 的/ 某些/ 状态/ 在/ 抽象/ 模型/ 上/ 被/ 评估/ 为/ 距离/ 目标/ 很近/ ,/ 从而/ 在/ 模拟/ 的/ 过程/ 中/ 提供/ 不/ 正确/ 的/ 指导/ ,/ 导致/ 最终/ 不能/ 搜索/ 出/ 一条/ 到达/ 目标/ 状态/ 的/ 路径/ ./ 为了/ 避免/ 搜索/ 过程/ 陷入/ 死胡同/ 状态/ 或者/ 局部/ 循环/ 中/ ,/ 我们/ 采用/ 了/ 两种/ 回退/ 策略/ ,/ 通过/ 在/ 每个/ 模拟/ 步骤/ 内/ 尝试/ 不同/ 的/ 新/ 状态/ 来/ 缓解/ 死胡同/ 问题/ :/ (/ 1/ )/ 回退/ 策略/ 1/ ./ 不/ 对比/ 当前/ 状态/ 与/ 候选/ 状态/ 的/ merge/ _/ dis/ 值/ ,/ 在/ 候选/ 状态/ 中/ 选择/ 具有/ 最大/ merge/ _/ dis/ 值/ 并且/ 没有/ 被/ 访问/ 过/ 的/ 状态/ 作为/ 下/ 一步/ 模拟/ 的/ 开始/ 状态/ ,/ 如果/ 其中/ merge/ _/ dis/ 值/ 最大/ 的/ 状态/ 有/ 多个/ 则/ 随机/ 选择/ 其中/ 一个/ ;/ (/ 2/ )/ 回退/ 策略/ 2/ ./ 比较/ 当前/ 状态/ 的/ merge/ _/ dis/ 值/ 与/ 候选/ 状态/ 中/ 的/ 最大/ merge/ _/ dis/ 值/ ,/ 如果/ 候选/ 状态/ 中/ 最大/ 的/ merge/ _/ dis/ 值/ 都/ 不/ 比/ 当前/ 状态/ 的/ 大/ ,/ 则/ 返回/ 到/ 当前/ 状态/ 重新/ 生成/ 候选/ 状态/ (/ 本文/ 方法/ 中/ 设定/ 重复/ 次数/ 最多为/ 5/ 次/ )/ ./ Page10/ 本文/ 中/ 的/ 回退/ 策略/ 与/ PACOST/ 中/ 的/ 类似/ ,/ 但/ 也/ 有/ 不同之处/ ,/ 本文/ 中/ 比较/ 的/ 是/ 当前/ 状态/ 与/ 候选/ 状态/ 的/ merge/ _/ dis/ 值/ ,/ 而/ PACOST/ 中/ 比较/ 的/ 是/ 抽象/ 距离/ 值/ ./ 4/ 实验/ 和/ 分析/ 为了/ 验证/ 本文/ 提出/ 的/ 多/ 目标/ 覆盖/ 方法/ 的/ 效果/ ,/ 作者/ 使用/ C++/ 编程语言/ 、/ 直接/ 编程/ 接口/ (/ DirectPro/ -/ grammingInterface/ ,/ DPI/ )/ 、/ VCS/ 模拟器/ 以及/ CVC3/ ①/ 约束/ 求解/ 器/ 进行/ 实验/ ./ 实验/ 对象/ 包括/ :/ (/ 1/ )/ ITC99/ 基准/ 测试/ 集/ ②/ 中/ 的/ 部分/ 电路/ ;/ (/ 2/ )/ NandFlash/ ③/ ,/ 一款/ 开源/ SoC/ 芯片/ 中/ 的/ NAND/ 型/ 闪存/ 控制器/ 模块/ ,/ 其/ 功能/ 是/ 完成/ 对/ NandFlash/ 的/ 基本/ 读写操作/ ;/ (/ 3/ )/ write/ _/ controller/ ,/ 来自/ 工业界/ 工程设计/ 中/ 的/ 一个/ 写/ 控制/ 模块/ ,/ 其/ 主要/ 功能/ 是/ 按照/ 串行/ 高级/ 技术/ 附件/ 协议/ (/ SerialAdvancedTechnologyAttachment/ ,/ SATA/ )/ 控制/ 设备/ 进行/ 写入/ ,/ 在/ SATA/ 协议/ 中/ 应用层/ 的/ 基础/ 上/ 实现/ 数据/ 存储/ 和/ 地址/ 记录/ 的/ 功能/ ,/ 并/ 支持/ 编程/ 输入输出/ (/ ProgrammingInput/ // Output/ ,/ PIO/ )/ 与/ 直接/ 内存/ 访问/ (/ DirectMemoryAccess/ ,/ DMA/ )/ 两种/ 工作/ 模式/ ,/ 按照/ 数据/ 流量/ 的/ 大小/ 自动/ 选择/ 不同/ 工作/ 模式/ ./ 所有/ 实验/ 是/ 远程/ 登录/ 计算机/ 服务器/ 完成/ 的/ ,/ 服务器/ 的/ 硬件/ 配置/ 是/ CPU/ 为/ 4/ 核/ IntelXeon/ 、/ 主频/ 为/ 3.00/ GHz/ ,/ 内存/ 为/ 6GB/ ,/ 操作系统/ 为/ RedhatEnterprise4/ ./ 实验/ 电路/ 的/ 特征描述/ 如表/ 2/ 所示/ ,/ 包括/ 电路/ 名称/ 、/ 输入/ 数目/ 、/ 输出/ 数目/ 、/ 原始/ 设计/ 中/ 的/ 寄存器/ 位数/ 以及/ 抽象/ 模型/ 中/ 的/ 寄存器/ 位数/ ./ 其中/ b12word/ 是/ 将/ ITC99/ 中/ 的/ b12/ 设计/ 的/ 一个/ 原始/ 输入/ 由/ 4/ 位/ 扩展/ 为/ 12/ 位/ ,/ 增加/ 了/ 猜/ 数字/ 游戏/ 的/ 难度/ ,/ 即/ 增大/ 了/ 难达/ 状态/ 的/ 难达/ 程度/ ,/ 同理/ b13word/ 是/ 将/ b13/ 的/ 一个/ 原始/ 电路/ 名称/ b01b02b03b06b08b10b11b12b12wordb13b13wordb15b17NandFlashwrite/ _/ controller153/ 输入/ 由/ 一位/ 扩展/ 为/ 16/ 位/ ,/ 增大/ 了/ 难达/ 状态/ 的/ 时序/ 深度/ ./ NandFlash/ 和/ write/ _/ controller/ 中/ 都/ 有位/ 宽/ 为/ 32/ 位/ 的/ 输入/ 变量/ 位于/ 控制/ 条件/ 中/ ./ 实验/ 中/ ,/ 我们/ 从/ 设计/ 中/ 选择/ 时序/ 深度/ 较/ 深/ 的/ 难达/ 分支/ 对应/ 的/ 状态/ 作为/ 难达/ 目标/ 状态/ ./ 在/ 本文/ 中/ ,/ 将/ 随机/ 模拟/ 在/ 500/ 万拍/ 之内/ 不能/ 覆盖/ 到/ 的/ 分支/ 识别/ 为难/ 达/ 分支/ ./ 4.1/ 与/ 其他/ 方法/ 的/ 性能/ 比较/ 为了/ 与/ 其他/ 方法/ 进行/ 比较/ ,/ 此/ 小节/ 中/ 的/ 实验/ 场景/ 设定/ 为/ 单个/ 目标/ 覆盖/ ,/ 即/ 每/ 一次/ 模拟/ 中/ 只有/ 一个/ 目标/ 状态/ ./ 实验/ 中将/ 本文/ 方法/ 与/ 基于/ 随机/ 的/ 抽象/ 引导/ 半/ 形式化/ 方法/ (/ “/ 随机/ AGS/ ”/ )/ 、/ 约束/ 随机/ 模拟/ 方法/ 以及/ 形式化/ 方法/ —/ —/ —/ 限界/ 模型/ 检测/ (/ BoundedModelChecking/ ,/ BMC/ )/ 进行/ 对比/ ,/ 对比/ 项/ 包括/ 最终/ 搜索/ 到/ 的/ 从/ 初始状态/ 到达/ 目标/ 状态/ 的/ 激励/ 序列/ 长度/ 以及/ 所用/ 的/ 时间/ ./ 实验/ 结果/ 如表/ 3/ 所示/ ,/ 每/ 一行/ 的/ 模拟/ 结果/ 取/ 10/ 次/ 的/ 平均/ 结果/ ,/ 每次/ 使用/ 不同/ 的/ 随机/ 种子/ ./ 随机/ AGS/ 是/ 我们/ 对/ 参考文献/ [/ 1/ ]/ 的/ 基本/ 思想/ 框架/ 的/ 实现/ ./ 文献/ [/ 1/ ]/ 中/ 使用/ 了/ 一种/ 较/ 粗粒度/ 的/ 模块/ 级/ 的/ 抽象/ 方法/ ,/ 该/ 方法/ 将/ 与/ 目标/ 状态/ 寄存器/ 紧密/ 相关/ 的/ 模块/ 提取/ 出来/ 构成/ 抽象/ 模型/ ,/ 并/ 在/ 此/ 模型/ 上/ 应用/ 形式化/ 的/ 前/ 像/ 计算/ 获得/ 抽象/ 距离/ 信息/ ./ 在/ 模拟/ 过程/ 中/ ,/ 从/ 当前/ 状态/ 开始/ ,/ 随机/ 产生/ 一组/ 输入/ 向量/ 进行/ 模拟/ ,/ 然后/ 利用/ 抽象/ 距离/ 信息/ 对/ 模拟/ 过程/ 中/ 访问/ 到/ 的/ 状态/ 进行/ 评估/ ,/ 选择/ 其中/ 抽象/ 距离/ 最小/ 的/ 状态/ 作为/ 下/ 一步/ 模拟/ 的/ 当前/ 状态/ ,/ 循环/ 这个/ 过程/ 直到/ 覆盖/ 到/ 目标/ ./ 为了/ 公平/ 起/ 见/ ,/ 本文/ 对比/ 实验/ 中/ 实现/ 的/ 随机/ AGS/ 方法/ 采用/ 本文/ 中/ 使用/ 的/ 寄存器/ 级/ 的/ 抽象/ 方法/ ,/ 相比/ 于/ 文献/ [/ 1/ ]/ 中/ 模块/ 级/ 的/ 抽象/ 方法/ ,/ 寄存器/ 级/ 的/ 抽象/ 粒度/ 更细/ ,/ 能够/ 获得/ 更/ 精确/ 的/ 抽象/ 模型/ 从而/ 为/ 模拟/ 过程/ 提供/ 更/ 精确/ 的/ 引导/ ./ 对比/ 项中/ 的/ 约束/ 随机/ 模拟/ 方法/ 是/ 工业界/ 通用/ 的/ 模拟/ 验证/ 方法/ ,/ BMC/ 的/ 结果/ 是/ 学术界/ 的/ 开源/ 形式化/ 验证/ 工具/ VIS/ 的/ 实验/ 结果/ ./ 表/ 3/ 中/ 第/ 1/ 列/ 表示/ 目标/ 设计/ 及其/ 中/ 的/ 目标/ 状态/ 编号/ (/ 在/ 括号/ 内/ 显示/ )/ ,/ 第/ 2/ 列/ 和/ 第/ 3/ 列/ 表示/ 本文/ 方法/ 的/ 实验/ 结果/ ,/ 第/ 4/ 列/ 和/ 第/ 5/ 列/ 表示/ 随机/ AGS/ 方法/ 的/ 实验/ 结果/ ,/ 第/ 6/ 列/ 和/ 第/ 7/ 列是/ 约束/ 随机/ 模拟/ 方法/ 的/ 结果/ ,/ 最后/ 两列/ 是/ BMC/ 的/ 实验/ 结果/ ./ 左边/ (/ “/ 序列/ 长度/ ”/ )/ 是/ 最终/ 找到/ 的/ 激励/ 序列/ 的/ 长度/ ,/ 右边/ (/ “/ 时/ ①/ ②/ ③/ Page11/ 表/ 3/ 与/ 其他/ 方法/ 的/ 结果/ 比较/ 随机/ AGS/ [/ 1/ ]/ b01/ (/ p1/ )/ b02/ (/ p1/ )/ b03/ (/ p1/ )/ b06/ (/ p1/ )/ b08/ (/ p1/ )/ b10/ (/ p1/ )/ b11/ (/ p1/ )/ b11/ (/ p2/ )/ b12/ (/ p1/ )/ b12/ (/ p2/ )/ b12word/ (/ p1/ )/ b13/ (/ p1/ )/ b13/ (/ p2/ )/ b13word/ (/ p1/ )/ b13word/ (/ p2/ )/ b15/ (/ p1/ )/ b15/ (/ p2/ )/ b17/ (/ p1/ )/ b17/ (/ p2/ )/ NandFlash/ (/ p1/ )/ NandFlash/ (/ p2/ )/ write/ _/ controller/ (/ p1/ )/ write/ _/ controller/ (/ p2/ )/ 注/ :/ Time/ -/ out/ (/ TO/ )/ :/ 表示/ 五百万/ 拍/ 之内/ 无法/ 产生/ 出/ 结果/ ;/ “/ —/ ”/ :/ 表示/ 形式化/ 工具/ VIS/ 的/ BMC/ 无法/ 处理/ ./ 间/ ”/ )/ 是/ 总/ 模拟/ 时间/ ,/ TO/ 表示/ 在/ 500/ 万拍/ (/ 约/ 1000s/ )/ 之内/ 无法/ 产生/ 出/ 结果/ (/ 目前/ 国际/ 上/ 发表/ 的/ 抽象/ 引导/ 的/ 难达/ 状态/ 激励/ 生成/ 方法/ 大多/ 采用/ 了/ 这个/ 数值/ 作为/ TO/ 标准/ )/ ./ 难达/ 状态/ 激励/ 生成/ 的/ 最终目标/ 是/ 产生/ 出/ 一条/ 从/ 初始状态/ 到/ 目标/ 状态/ 的/ 激励/ 序列/ ,/ 设计/ 中/ 存在/ 时序/ 深度/ 上万/ 拍/ 的/ 状态/ (/ 如/ b12/ 的/ 目标/ p2/ )/ 已经/ 算是/ 比较/ 深/ 的/ 时序/ 深度/ 了/ ./ 如果/ 在/ 500/ 万拍/ 之内/ 不能到达/ 目标/ 状态/ ,/ 则/ 可以/ 认为/ 很难/ 找到/ 一条/ 到达/ 目标/ 的/ 路径/ 了/ ./ 表/ 3/ 中/ 本文/ 方法/ 及/ 随机/ AGS/ 方法/ 的/ 结果/ 都/ 是/ 采用/ 回退/ 策略/ 1/ 的/ 实验/ 结果/ ./ 实验/ 结果表明/ ,/ 本文/ 方法/ 可以/ 覆盖/ 到/ 所有/ 被/ 选/ 的/ 目标/ 状态/ ,/ 而/ 其他/ 方法/ 都/ 有/ 一些/ 目标/ 不能/ 覆盖/ 到/ ./ 通过/ 对/ b12/ 、/ b12word/ 、/ b13word/ 以及/ NandFlash/ 和/ write/ _/ controller/ 的/ 实验/ 结果/ 进行/ 分析/ ,/ 我们/ 发现/ ,/ 当/ 控制/ 条件/ 较/ 复杂/ 或是/ 字级/ 时/ ,/ 采用/ 约束/ 求解/ 产生/ 候选/ 状态/ 的/ 方法/ 效果/ 明显/ 优于/ 随机/ 产生/ 候选/ 状态/ 的/ 方法/ ,/ 原因/ 是/ 当/ 控制/ 条件/ 较/ 复杂/ 或是/ 字级/ 时/ ,/ 某些/ 分支/ 采用/ 随机/ 的/ 方法/ 很难/ 覆盖/ 到/ ,/ 而/ 这些/ 分支/ 对应/ 的/ 很/ 可能/ 是/ 离/ 目标/ 状态/ 较近/ 的/ 状态/ ./ 随着/ 这些/ 分支/ 变量/ 位/ 宽/ 的/ 增长/ ,/ 随机/ 方法/ 覆盖/ 这些/ 分支/ 的/ 概率/ 呈/ 指数/ 降低/ ./ 而/ 本文/ 方法/ 可以/ 通过/ 约束/ 改变/ 和/ 求解/ 的/ 方式/ 很/ 容易/ 覆盖/ 到/ 这些/ 分支/ ./ 从/ BMC/ 的/ 实验/ 结果/ 中/ 可以/ 看出/ ,/ 对于/ 规模较/ 小/ 的/ 设计/ 以及/ 时序/ 深度/ 不深/ 的/ 目标/ 属性/ ,/ BMC/ 方法/ 时间/ // s/ </ 0.01/ </ 0.010/ ./ 01/ </ 0.010/ ./ 010.060/ ./ 010.01/ TOTOTO1/ ./ 162.683/ ./ 539.640/ ./ 020.040/ ./ 12TOTOTOTOTO/ 能够/ 快速/ 到达/ 目标/ 状态/ 并/ 产生/ 较/ 短/ 的/ 路径/ 序列/ ./ 然而/ 对于/ 时序/ 深度/ 较/ 深/ 的/ 设计/ ,/ BMC/ 则/ 由于/ 形式化/ 方法/ 面临/ 的/ 状态/ 空间/ 爆炸/ 的/ 问题/ 而/ 无法/ 处理/ (/ 如/ b12/ 、/ b13/ 以及/ write/ _/ controller/ 的/ 目标/ 属性/ )/ ,/ 而/ 本文/ 方法/ 可以/ 快速/ 验证/ 这些/ 目标/ 状态/ ./ 本文/ 方法/ 在/ b01/ 、/ b02/ 、/ b06/ 和/ b08/ 上/ 的/ 实验/ 效果/ 不/ 明显/ ,/ 因为/ 这些/ 设计/ 规模较/ 小/ ,/ 控制/ 条件/ 很/ 简单/ ./ 由于/ 约束/ 求解/ 器/ 的/ 调用/ ,/ 本文/ 方法/ 的/ 运行/ 时间/ 长于/ 随机/ AGS/ ,/ 但/ 能/ 产生/ 较/ 短/ 的/ 激励/ 序列/ ./ b13/ 的/ 原始/ 设计/ 虽然/ 比较复杂/ ,/ 但/ 本文/ 方法/ 产生/ 的/ 序列/ 长度/ 和/ 随机/ AGS/ 一样/ ,/ 原因/ 是/ 控制/ 条件/ 中/ 约束/ 是/ 简单/ 的/ 单个/ bit/ 位/ ,/ 随机/ 次数/ 较多时/ 也/ 能/ 较/ 快/ 地/ 覆盖/ 到/ 不同/ 分支/ ./ 4.2/ 回退/ 策略/ 之间/ 的/ 比较/ 图/ 8/ 和/ 图/ 9/ 记录/ 了/ 本文/ 方法/ 和/ 随机/ AGS/ 采用/ 不同/ 回退/ 策略/ 的/ 实验/ 结果/ ,/ 图中/ 回/ 1/ 和/ 回/ 2/ 分别/ 表示/ 回退/ 策略/ 1/ 和/ 回退/ 策略/ 2/ ,/ TO/ 与表/ 3/ 中/ 的/ 意义/ 一致/ ,/ 表示/ 在/ 五百万/ 拍/ 之内/ 无法/ 产生/ 出/ 结果/ ./ 回退/ 策略/ 1/ 不/ 对比/ 当前/ 状态/ 与/ 候选/ 状态/ 的/ merge/ _/ dis/ 值/ 而/ 回退/ 策略/ 2/ 则/ 比较/ ./ 实验/ 结果表明/ ,/ 采用/ 回退/ 策略/ 2/ 可以/ 产生/ 更/ 短/ 的/ 路径/ 序列/ ,/ 但是/ 花费/ 的/ 时间/ 可能/ 较长/ ,/ 原因/ 是/ 当/ 搜索/ 过程/ 没有/ 前进/ 时/ ,/ 回退/ 策略/ 2/ 的/ 方式/ 会/ 产生/ 更/ 多/ 的/ 候选/ 状态/ 以/ 供选择/ ,/ 这样/ 可以/ 增大/ 更/ 靠近/ 目标/ 状态/ 的/ 概率/ ./ 实验/ 结果/ 还/ 表明/ ,/ 不管/ 是/ 采用/ 回/ Page12/ 退/ 策略/ 1/ 还是/ 回退/ 策略/ 2/ ,/ 本文/ 方法/ 都/ 可以/ 覆盖/ 所有/ 被/ 选/ 的/ 目标/ ./ 而/ 随机/ AGS/ 方法/ 采用/ 回退/ 策略/ 1/ 时/ 只能/ 覆盖/ 到/ 部分/ 目标/ 状态/ ,/ 原因/ 是/ 某些/ 目标/ 状态/ 必经/ 的/ 分支/ 采用/ 随机/ 的/ 方式/ 很难/ 覆盖/ 到/ ;/ 即使/ 采用/ 回退/ 策略/ 2/ ,/ 随机/ AGS/ 仍然/ 无法/ 覆盖/ 到/ b12word/ 中/ 的/ 目标/ ,/ 原因/ 是/ 当/ 控制/ 条件/ 较/ 复杂/ 或是/ 字级/ 时/ ,/ 采用/ 随机/ 的/ 方式/ ,/ 即便/ 每/ 一步/ 中/ 产生/ 多个/ 候选/ 状态/ 也/ 依旧/ 难以/ 满足/ 覆盖/ 目标/ 所/ 需/ 的/ 条件/ ./ 4.3/ 多/ 目标/ 覆盖/ 与/ 单/ 目标/ 覆盖/ 的/ 效果/ 对比/ 为了/ 验证/ 本文/ 多/ 目标/ 同时/ 覆盖/ 的/ 效果/ ,/ 我们/ 从/ 每个/ 待/ 验证/ 设计/ 中/ 选择/ 多个/ 目标/ 状态/ (/ 两至/ 三个/ )/ 同时/ 模拟/ ./ 表/ 4/ 中/ 记录/ 了/ PACOST/ 单/ 目标/ 覆盖/ 和/ 本文/ 多/ 目标/ 覆盖/ 的/ 对比/ 实验/ 结果/ ,/ 对比/ 是/ 在/ 采用/ 回退/ 策略/ 2/ 的/ 情况/ 下/ ./ 单/ 目标/ 覆盖/ 是/ 采用/ PACOST/ 方法/ ,/ 每次/ 只/ 针对/ 一个/ 目标/ 状态/ 做/ 激励/ 生成/ ,/ 而/ 多/ 目标/ 覆盖/ 是/ 采用/ 本文/ 方法/ ,/ 每次/ 同时/ 针对/ 多个/ 目标/ 状态/ 来/ 产生/ 激励/ 序列/ ./ 实验/ 结果表明/ ,/ 在/ 大多数/ 情况/ 下/ ,/ 多/ 目标/ 覆盖/ 产生/ 的/ 激励/ 序列/ 长度/ 比/ 各个/ 目标/ 单独/ 覆盖/ 所/ 产生/ 的/ 序列/ 长度/ 之/ 和/ 要/ 小/ ,/ 所用/ 时间/ 也/ 较/ 短/ ./ b11/ 中多/ 目标/ 覆盖/ 所/ 产生/ 的/ 序列/ 长度/ 之所以/ 大于/ 单/ 目标/ 覆盖/ 所/ 产生/ 的/ 序列/ 长度/ 之/ 和/ ,/ 是因为/ b11/ 中/ 的/ 两个/ 目标/ 状态/ 不/ 在/ 同/ 一条/ 路径/ 上/ ,/ 当/ 其中/ 一个/ 目标/ 状态/ 到达/ 之后/ 需要/ 回到/ 初始状态/ 重新/ 模拟/ 一条/ 新/ 的/ 路径/ 来/ 覆盖/ 另/ 一个/ 目标/ 状态/ ./ 同理/ ,/ NandFlash/ 中多/ 目标/ 同时/ 覆盖/ 产生/ 的/ 激励/ 序列/ 长度/ 基本上/ 是/ 各个/ 目标/ 单独/ 覆盖/ 所/ 产生/ 的/ 序列/ 长度/ 之/ 和/ ,/ 也/ 是因为/ 所选/ 的/ 两个/ 目标/ 状态/ 分别/ 位于/ 从/ 初始状态/ 开始/ 的/ 两条/ 不同/ 路径/ 中/ ./ 而/ 通常/ 在/ 设计/ 中/ ,/ 难达/ 状态/ 是/ 很/ 可能/ 相互/ 靠近/ 或/ 处于/ 同/ 一条/ 路径/ 上/ ,/ 采用/ 多/ 目标/ 覆盖/ 的/ 方法/ 能够/ 较/ 快/ 地/ 产生/ 一条/ 较/ 短/ 的/ 路径/ 同时/ 覆盖/ 到/ 多个/ 目标/ 状态/ ./ 比如/ ,/ write/ _/ controller/ 的/ 两个/ 目标/ 状态/ 位于/ 同/ 路径/ 中/ ,/ 因此/ 多/ 目标/ 同时/ 覆盖/ 的/ 效果/ 要/ 明显/ 优于/ 单个/ 目标/ 覆盖/ ./ b06/ (/ t1/ )/ b06/ (/ t2/ )/ b06/ (/ t3/ )/ b08/ (/ t1/ )/ b08/ (/ t2/ )/ b08/ (/ t3/ )/ b11/ (/ t1/ )/ b11/ (/ t2/ )/ b12/ (/ t1/ )/ b12/ (/ t2/ )/ b12/ (/ t3/ )/ b13/ (/ t1/ )/ b13/ (/ t2/ )/ b13/ (/ t3/ )/ b15/ (/ t1/ )/ b15/ (/ t2/ )/ b15/ (/ t3/ )/ NandFlash/ (/ p1/ )/ NandFlash/ (/ p2/ )/ write/ _/ controller/ (/ p1/ )/ 1114write/ _/ controller/ (/ p2/ )/ 12155/ 局限性/ 说明/ 本文/ 方法/ 的/ 局限性/ 在于/ 抽象/ 的/ 过程/ 需要/ 一定/ 的/ 人工干预/ ,/ 并且/ 能/ 处理/ 的/ 抽象/ 模型/ 的/ 规模/ 依赖于/ 现有/ 形式化/ 工具/ 的/ 处理/ 能力/ ./ 目前/ 形式化/ 工具/ 能够/ 处理/ 的/ 抽象/ 模型/ 规模/ 有限/ ,/ 如果/ 原始/ 设计/ 的/ 规模/ 与/ 抽象/ 模型/ 的/ 规模/ 之间/ 差异/ 较大/ ,/ 会/ 由于/ 抽象/ 误差/ 导致/ 死胡同/ 问题/ ,/ 从而/ 找/ 不到/ 具体/ 的/ 路径/ 覆盖/ 目标/ 状态/ ,/ 这/ 也/ 是/ 所有/ 抽象/ 距离/ 引导/ 的/ 半/ 形式化/ 方法/ 共同/ 面临/ 的/ 问题/ ./ 尽管如此/ ,/ 本文/ 提出/ 的/ 回退/ 策略/ 能够/ 一定/ 程度/ 上/ 缓解/ 死胡同/ 问题/ ./ 此外/ ,/ 本文/ 方法/ 在/ 每个/ 模拟/ 步骤/ 中/ 只/ 展开/ 一拍/ ,/ Page13/ 即/ 只/ 提取/ 一拍/ 的/ 路径/ 约束/ ,/ 因此/ 对于/ 那些/ 位于/ 控制/ 条件/ 中/ 的/ 中间/ 寄存器/ 的/ 值/ 无法控制/ ,/ 实验/ 效果/ 有限/ ./ 在/ 后续/ 工作/ 中/ ,/ 将/ 考虑/ 在/ 控制流/ 图/ 的/ 基础/ 上/ 构建/ 数据流/ 图/ ,/ 通过/ 时序/ 展开/ 的/ 方式/ ,/ 在/ 数据流/ 图中/ 提取/ 变量/ 之间/ 的/ 依赖/ 关系/ 来/ 控制/ 中间/ 寄存器/ 的/ 值/ ./ 6/ 总结/ 本文/ 提出/ 了/ 一种/ 抽象/ 引导/ 的/ 半/ 形式化/ 激励/ 生成/ 方法/ ,/ 目标/ 是/ 同时/ 覆盖/ 设计/ 中/ 多个/ 难达/ 状态/ ./ 本文/ 采用/ 了/ 基于/ 路径/ 约束/ 求解/ 的/ 激励/ 生成/ 方法/ ,/ 这种/ 方法/ 将/ 动态/ 模拟/ 和/ 对/ RTL/ 代码/ 的/ 静态/ 分析/ 相结合/ ,/ 能够/ 有效/ 地/ 产生/ 输入/ 向量/ ,/ 遍历/ 设计/ 的/ 不同/ 分支/ ,/ 对应/ 产生/ 不同/ 的/ 候选/ 状态/ ./ 在/ 每/ 一步/ 模拟/ 中/ ,/ 综合/ 考虑/ 从/ 各个/ 候选/ 状态/ 到/ 不同/ 目标/ 状态/ 的/ 全局/ 抽象/ 距离/ 值/ ,/ 从中/ 选择/ 一个/ 最优/ 的/ 状态/ 继续/ 模拟/ ,/ 最终/ 搜索/ 到/ 一条/ 能/ 同时/ 覆盖/ 多个/ 目标/ 状态/ 的/ 状态/ 序列/ ./ 此外/ ,/ 本文/ 使用/ 了/ 两种/ 回退/ 策略/ ,/ 通过/ 尽量/ 尝试/ 不同/ 的/ 新/ 状态/ 来/ 缓解/ 死胡同/ 问题/ ./ 实验/ 结果表明/ ,/ 与/ 一种/ 已有/ 的/ 抽象/ 引导/ 半/ 形式化/ 方法/ 以及/ 形式化/ 的/ BMC/ 方法/ 比较/ ,/ 本文/ 方法/ 可以/ 覆盖/ 到/ 更/ 多/ 的/ 目标/ 状态/ ./ 当有/ 多个/ 目标/ 位于/ 同/ 路径/ 中/ 时/ ,/ 相比/ 于单/ 目标/ 覆盖/ ,/ 本文/ 多/ 目标/ 覆盖/ 方法/ 能够/ 在/ 更/ 短/ 的/ 时间/ 内/ 产生/ 较/ 短/ 的/ 激励/ 序列/ 同时/ 覆盖/ 到/ 多个/ 目标/ 状态/ ./ 

