Page1/ 多核/ 处理器/ 下/ 事务/ 型/ 数据库/ 性能/ 优化/ 技术/ 综述/ 朱/ 阅岸/ 1/ )/ ,/ 2/ )/ 1/ )/ (/ 中国人民大学/ 信息/ 学院/ 北京/ 100872/ )/ 2/ )/ (/ 数据/ 工程/ 与/ 知识/ 工程/ 教育部/ 重点/ 实验室/ (/ 中国人民大学/ )/ 北京/ 100872/ )/ 3/ )/ (/ 中国人民大学/ 中国/ 调查/ 与/ 数据中心/ 北京/ 100872/ )/ 摘要/ 传统/ 数据库/ 的/ 设计/ 假设/ 磁盘/ 为/ 主要/ 存储设备/ ,/ 其/ 性能/ 取决于/ 基于/ I/ // O/ 代价/ 模型/ 的/ 优化/ ./ 然而/ ,/ 当前/ 数据库/ 运行/ 的/ 平台/ 已/ 逐渐/ 转移/ 到/ 由/ 多/ 核/ 处理器/ 、/ 大/ 内存/ 和/ 以/ 闪存/ 为/ 代表/ 的/ 低/ 延迟/ 存储/ 所/ 构成/ 的/ 新型/ 硬件平台/ 上/ ./ 在/ 大多数/ 情况/ 下/ ,/ 工作/ 数据/ 集/ 能够/ 全部/ 加载/ 到/ 内存/ 或者/ 闪存/ 等/ 高速/ 存储器/ 中/ ./ 这样/ ,/ 数据库/ 的/ 性能/ 瓶颈/ 由/ 传统/ 的/ I/ // O/ 转移/ 到/ CPU/ 上/ ./ 而/ 传统/ 数据库/ 的/ 加锁/ 操作/ 、/ 闩/ 锁/ 竞争/ 、/ 日志/ 管理/ 以及/ 缓冲区/ 管理/ 在/ 设计/ 时均/ 未/ 考虑/ 到/ 多/ 核/ 处理器/ 的/ 使用/ ,/ 因而/ 成为/ 了/ 限制/ CPU/ 利用率/ 的/ 明显/ 瓶颈/ ./ 改变传统/ 数据库/ 的/ 优化/ 重点/ 以/ 适应/ 硬件/ 的/ 发展/ 对/ 应用/ 而言/ 是/ 十分必要/ 的/ ./ 该文/ 针对/ 当前/ 新/ 的/ 应用/ 背景/ ,/ 主要/ 围绕/ 数据库系统/ 中锁/ 管理/ 、/ 日志/ 管理/ 、/ 缓冲区/ 管理/ 以及/ B/ 树/ 索引/ 等/ 核心/ 模块/ 在/ 多/ 核/ 平台/ 下/ 已有/ 的/ 优化/ 技术/ 进行/ 详细/ 介绍/ 和/ 归纳/ 总结/ ./ 同时/ 介绍/ 了/ 中国人民大学/ 在/ 数据库系统/ 的/ 多/ 核/ 处理器/ 优化/ 方面/ 所/ 做/ 的/ 一些/ 工作/ ./ 关键词/ 数据库系统/ 优化/ ;/ 锁/ ;/ 日志/ ;/ 缓冲区/ 管理/ ;/ B/ 树/ 1/ 引言/ 摩尔定律/ 揭示/ 了/ 集成电路/ 上/ 晶体管/ 集成度/ 的/ 增长/ 规律/ ,/ 摩尔定律/ 首先/ 表现/ 为/ CPU/ 主频/ 的/ 持续增长/ ,/ 然后/ 又/ 表现/ 为/ CPU/ 核心/ 数量/ 的/ 持续增长/ ./ CPU/ 的/ 频率/ 持续/ 逐年/ 增长/ ,/ 加上/ 其/ 指令/ 执行/ 的/ 并行度/ 也/ 在/ 增加/ ,/ 使得/ 单线程/ 的/ 工作/ 性能/ 不断/ 提高/ [/ 1/ ,/ 2/ ]/ ./ 早/ 在/ 2002/ 年/ ,/ CPU/ 的/ 频率/ 就/ 已经/ 达到/ 3GHz/ ./ 然而/ ,/ 高频率/ 的/ CPU/ 带来/ 的/ 是/ 更/ 多/ 的/ 能耗/ ,/ 现实/ 应用/ 中/ 不/ 一定/ 会/ 带来/ 高/ 的/ 性价比/ ,/ 因而/ 阻止/ CPU/ 主频/ 的/ 进一步/ 发展/ ./ 这个/ 问题/ 使得/ 近年来/ CPU/ 的/ 发展/ 方向/ 产生/ 了/ 转变/ ./ 为了/ 进一步/ 优化/ CPU/ 的/ 性能/ ,/ 生产商/ 倾向/ 于/ 在/ 单个/ CPU/ 上/ 增加/ 更/ 多/ 的/ 处理/ 核心/ ./ CPU/ 开始/ 转向/ 使用/ 并行/ 多线程/ 和/ 片/ 上/ 多处理器/ 技术/ ,/ 以/ 替代/ 单/ 处理/ 流/ 的/ 高度/ 复杂/ CPU/ 技术/ ./ 生产商/ 不再/ 竞争/ 速度/ 而是/ 转向/ 提高/ 并行度/ ./ 按照/ 最近/ 多核/ 的/ 发展趋势/ ,/ 单个/ CPU/ 上/ 的/ 核数/ 基本/ 每/ 两年/ 翻/ 一倍/ ./ 大部分/ 研究/ 人员/ 预测/ ,/ CPU/ 的/ 核数会/ 继续/ 增长/ 一段时间/ ./ 为了/ 更好/ 地/ 利用/ 新/ CPU/ 的/ 并行处理/ 能力/ ,/ 工程师/ 需要/ 修改/ 或/ 重新/ 设计/ 软件系统/ ./ 而/ 基础/ 软件/ ,/ 包括/ 操作系统/ 、/ Web/ 服务器/ 和/ 数据库/ 等/ ,/ 则/ 会/ 最先/ 遇到/ 复杂/ 的/ 多/ 核/ 架构/ 带来/ 的/ 扩展性/ 问题/ ./ 操作系统/ 社区/ 对/ Unix/ 类型/ 操作系统/ 在/ 共享内存/ 多处理器/ 上/ 的/ 扩展性/ 研究/ 已经/ 进行/ 了/ 很长/ 一段时间/ ./ 大家/ 公认/ 粗粒度/ 的/ 锁/ 是/ 导致系统/ 扩展性/ 差/ 的/ 主要/ 原因/ ./ 现有/ 的/ 研究成果/ 均/ 建议/ 将/ 多/ 核/ 架构/ 看作/ 分布式系统/ ,/ 利用/ 共享内存/ 进行/ 快速/ 消息传递/ [/ 3/ ]/ ,/ 而/ 系统/ 设计/ 的/ 主要/ 思想/ 集中/ 在/ 增加/ 数据/ 局部性/ 和/ 均衡/ 处理/ 核心/ 之间/ 的/ 负载/ [/ 3/ -/ 4/ ]/ ./ 诸多/ 实用/ 的/ 研究成果/ ,/ 如/ 分布式/ 内存/ 管理/ 、/ 可/ 扩展/ 的/ 封锁/ 技术/ 、/ 避免/ 等待/ 的/ 同步/ 技术/ 和/ 针对/ 多处理器/ 调度/ 技术/ ,/ 都/ 已经/ 被/ 工业界/ 采纳/ ,/ 并/ 被/ 植入/ 了/ 新/ 的/ Linux/ 内核/ [/ 4/ ]/ ./ 从/ 一/ 开始/ ,/ 数据库/ 存储/ 引擎/ 的/ 研究/ 就是/ 定位/ 在/ 高/ 负载/ 下/ 的/ 高性能/ 和/ 可靠性/ ./ 一方面/ ,/ 数据/ 的/ 可靠性/ 和/ 一致性/ 大都/ 通过/ 在/ 共享/ 数据结构/ 上/ 的/ 封锁/ 机制/ 实现/ ;/ 另一方面/ ,/ 在/ 现代/ 多核/ 架构/ 下/ ,/ 性能/ 的/ 提升/ 必须/ 通过/ 利用/ 更高/ 程度/ 的/ 并行性/ ./ 如何/ 解决/ 这/ 两者之间/ 的/ 矛盾/ 是/ 一个/ 很大/ 的/ 挑战/ ./ 现实/ 中/ ,/ 关系/ 数据库系统/ 大部分/ 是/ 基于/ 优化/ I/ // O/ 和/ 面向/ 单/ 处理器/ 的/ 陈旧/ 设计/ 思想/ ,/ 并/ 不/ 适合/ 多核/ 处理器/ 的/ 架构/ ./ 以/ 事务处理/ 为主/ 的/ 数据库系统/ 多数/ 依赖/ 并发/ 取得/ 高/ 吞吐/ 率/ ./ 并发/ 是/ 通过/ 多线程/ 或者/ 多/ 进程/ 实现/ 的/ ./ 理想/ 情况/ 下/ ,/ 随着/ 硬件/ 上下文/ 的/ 增加/ ,/ 他们/ 应该/ 具备/ 良好/ 的/ 扩展性/ ,/ 特别/ 是/ 针对/ 以读/ 为主/ 工作/ 负载/ ./ 实际上/ ,/ 为了/ 维护/ 一致性/ 和/ 持久性/ ,/ 数据库系统/ 大量/ 使用/ 共享/ 数据结构/ 和/ 同步/ 原语/ ./ 在/ 高度/ 并行/ 的/ 环境/ 下/ ,/ 对/ 共享/ 数据/ 进行/ 频繁/ 的/ 原子/ 更新/ 不得不/ 由/ 线程/ 串行/ 地/ 执行/ [/ 5/ ]/ ./ 因此/ ,/ 用于/ 保护/ 共享/ 数据结构/ 的/ 同步/ 原语/ 会/ 导致/ 很大/ 的/ 同步/ 开销/ ./ 这些/ 同步/ 原语/ 大量/ 存在/ 于/ 共享内存/ 缓冲区/ 、/ 锁表/ 、/ 索引/ 与/ 日志/ 管理器/ 中/ ./ 此外/ ,/ 丰富/ 的/ 硬件/ 上下文/ 使得/ 并行/ 线程/ 竞争/ 硬件资源/ ,/ 例如/ ,/ 高速缓存/ 的/ 争用/ 将/ 降低/ 缓存/ 命中率/ 从而/ 增加/ 内存/ 访问/ 延迟/ ./ 另外/ ,/ 传统/ 的/ 封锁/ 方式/ 例如/ 阻塞/ 和/ 忙/ 等待/ 策略/ 在/ 多/ 核/ 环境/ 下/ 效率/ 低下/ [/ 6/ ]/ ./ 增加/ 的/ 并行度/ 还会/ 导致/ 更大/ 异构/ 的/ 工作/ 负载/ ,/ 这/ 给/ 索引/ 数据结构/ 里/ 的/ 读写/ 同步控制/ 原语/ 也/ 造成/ 更大/ 的/ 压力/ [/ 7/ ]/ ./ 总之/ ,/ 所有/ 这些/ 原因/ 导致/ 了/ 运行/ 在/ 多/ 核/ 架构/ 上/ 的/ 数据库系统/ 的/ 性能/ 瓶颈/ ./ 近年来/ ,/ 学者/ 们/ 提出/ 许多/ 不同/ 的/ 思想/ 和/ 方法/ ,/ 用于/ 重新/ 构建/ 多核/ 环境/ 下/ 的/ 数据库系统/ ./ 本文/ 的/ 目的/ 是/ 对/ 已有/ 的/ 多/ 核/ 数据库/ 优化/ 技术/ 进行/ 总结/ 和/ 讨论/ ./ 同时/ 介绍/ 了/ 中国人民大学/ 在/ 数据库/ 多核/ 优化/ 所/ 做/ 的/ 一些/ 努力/ ./ 纵观/ 整个/ 数据库系统/ 内核/ ,/ 多核/ 扩展/ 的/ 瓶颈/ 突出表现/ 于锁/ 管理/ 、/ 日志/ 管理器/ 、/ 缓冲区/ 管理/ 和/ 索引/ (/ 主要/ 是/ B/ -/ tree/ )/ 四大/ 部件/ ./ 本文/ 依次/ 对/ 这/ 四大/ 部件/ 的/ 多/ 核/ 优化/ 技术/ 做/ 整理/ 归纳/ ./ 2/ 锁/ 管理器/ 的/ 多/ 核/ 优化/ 几乎/ 所有/ 的/ 数据库/ 都/ 利用/ 某种/ 形式/ 的/ 多/ 粒度/ 封锁/ 机制/ ,/ 允许/ 应用程序/ 在/ 并发/ 度/ 和/ 系统/ 开销/ 之间/ 进行/ 一个/ 折中/ ./ 多/ 粒度/ 锁/ 机制/ 将/ 数据库/ 视为/ 嵌套/ 的/ 数据结构/ ./ 数据库/ 中/ 包含/ 表/ ,/ 表/ 又/ 由/ 一系列/ 页面/ 组成/ ,/ 页面/ 包含/ 元组/ ./ 每个/ 层次/ 的/ 数据结构/ 都/ 有/ 一个/ 锁/ 与/ 之/ 相对/ 应/ ./ 例如/ ,/ 访问/ 大量/ 数据/ 的/ 请求/ 可以/ 申请/ 大/ 粒度/ 的/ 锁/ 对表/ 进行/ 封锁/ ,/ 牺牲/ 并发/ 度以/ 减少/ 系统/ 开销/ ./ 对于/ 访问/ 少量/ 数据/ 的/ 请求/ 可以/ 只/ 对/ 它们/ 需要/ 访问/ 的/ 数据/ 加锁/ ,/ 以/ 最大化/ 系统/ 并发/ 度/ ./ 多/ 粒度/ 锁/ 机制/ 对于/ 系统/ 的/ 扩展性/ 至关重要/ ,/ 因为/ 它/ 在/ 逻辑/ 层面/ 上/ 实现/ 高效/ 的/ 细粒度/ 并发/ 控制/ ./ 这种/ 多/ 粒度/ 的/ 锁/ 机制/ 可以/ 有效/ 控制系统/ 的/ 并发/ 度/ ,/ 然而/ 也/ 给/ 系统/ 扩展性/ 带来/ 新/ 的/ 问题/ ./ 单/ 节点/ 的/ 数据库系统/ 在/ 处理器/ 数目/ 较少/ 的/ 时候/ 利用/ 分/ 时/ 机制/ 处理/ 请求/ ,/ 对/ 资源/ 的/ 竞争/ 不/ 明显/ ./ 随着/ 处理器/ 上/ 核数/ 的/ 不断/ 增加/ ,/ 硬件/ 并发/ 度/ 的/ 增大/ ,/ 集中式/ 的/ 锁/ 管理器/ 遇到/ 了/ 瓶颈/ ,/ 尤其/ 是/ 当多/ 粒度/ 锁/ 强制/ 许多/ 线程/ 不断/ 地/ 更新/ 某些/ 频繁/ 访问/ 的/ 锁/ 的/ 状态/ 时/ ./ 为了/ 访问/ 数据库系统/ 的/ 某个/ 元素/ ,/ 所有/ 的/ 事务/ 都/ 必须/ 获得/ 高层次/ 上/ 的/ 意向锁/ ,/ 使得/ 这些/ 意向锁/ 的/ 访问/ 异常/ 频繁/ ./ 对锁/ 的/ 访问/ 必须/ 具备/ 原子/ 性/ ,/ 导致/ 临界/ 区/ 资源/ 竞争/ ./ 对于/ 具有/ 良好/ 扩展性/ 的/ 数据库/ 程序/ Page3/ 而言/ 也/ 会/ 遇到/ 与/ 锁/ 相关/ 的/ 瓶颈/ ,/ 即使/ 它们/ 几乎/ 不会/ 引起/ 逻辑/ 上/ 的/ 冲突/ ./ 为了/ 降低/ 锁/ 管理器/ 的/ 资源/ 竞争/ ,/ 要么/ 降低/ 加锁/ 的/ 次数/ ,/ 要么/ 减轻/ 加锁/ 过程/ 中/ 原子/ 操作/ 的/ 排他性/ ,/ 要么/ 进一步/ 分布/ 化/ 并行/ 化锁/ 管理器/ 从而/ 缓解/ 对锁/ 资源/ 的/ 争夺/ ./ 以下/ 逐一/ 介绍/ 现有/ 的/ 3/ 种锁/ 管理器/ 多核/ 优化/ 策略/ ./ 2.1/ 锁/ 的/ 传递/ 与/ 继承/ Rdb/ // VMS/ [/ 8/ ]/ 利用/ 投机/ 锁/ 继承/ 机制/ 减少/ 网络/ 传输/ 代价/ ./ 在/ 这个/ 分布式/ 数据库/ 中/ ,/ 系统/ 的/ 任意/ 一个/ 节点/ 可/ 将/ 锁/ 传递/ 到/ 请求/ 该锁/ 的/ 另外/ 一个/ 节点/ 上/ ./ 文献/ [/ 1/ ]/ 简要地/ 描述/ 了/ “/ 锁/ 传递/ ”/ 的/ 思想/ :/ 只要/ 没有/ 冲突/ 的/ 锁/ 请求/ 到来/ ,/ 可以/ 将/ 锁/ 缓存/ 在/ 本地/ ,/ 而/ 不用/ 在/ 事务/ 结束/ 的/ 时候/ 将/ 锁/ 返回/ 给/ 主/ 节点/ ./ 这种/ 方式/ 避免/ 了/ 将/ 锁/ 返回/ 给/ 主/ 节点/ 的/ 开销/ ./ 如果/ 锁/ 可以/ 被/ 后面/ 的/ 事务/ 重用/ ,/ 那么/ 每/ 一次/ 锁/ 传递/ 可以/ 省略/ 一趟/ 网络/ 传输/ ./ 对于/ 两/ 节点/ 的/ 系统/ 而言/ ,/ 性能/ 可以/ 提高/ 60/ %/ 以上/ ./ Johnson/ 等/ 人/ [/ 9/ ]/ 将/ 锁/ 传递/ 思想/ 应用/ 在/ 单/ 节点/ 的/ 数据库系统/ 上以/ 解决/ 锁/ 状态/ 上/ 的/ 竞争/ ./ 不同于/ Rdb/ // VMS/ 的/ 高/ 网络/ 传输/ 代价/ 和/ 较/ 少/ 的/ 节点/ 数目/ ,/ 文献/ [/ 9/ ]/ 在/ 共享/ 高速缓存/ 和/ 内存/ 的/ 多/ 核/ 平台/ 上/ 利用/ 单/ 节点/ Shore/ -/ MT/ 数据库系统/ [/ 10/ ]/ 实现/ 投机/ 锁/ 继承/ 算法/ SLI/ (/ SpeculativeLockInheritance/ ,/ SLI/ )/ ./ SLI/ 将/ 锁/ 管理器/ 上/ 的/ 封锁/ 请求/ 分发/ 到/ 不同/ 的/ 线程/ ,/ 以/ 减少/ 冲突/ ./ SLI/ 思想/ 主要/ 基于/ 以下/ 观察/ :/ 应用程序/ 几乎/ 总是/ 以/ 相容/ 模式/ 申请/ 某些/ 热锁/ ;/ 否则/ ,/ 若/ 某/ 一/ 时刻/ 系统/ 的/ 大部分/ 事务/ 被/ 阻塞/ 在/ 某个/ 排它/ 锁上/ ,/ 不会/ 为/ 更新/ 锁/ 的/ 状态/ 而/ 造成/ 竞争/ ./ 如果/ 大部分/ 事务/ 以/ 相容/ 模式/ 申请/ 热锁/ ,/ 那么/ 事务/ 可以/ 较长时间/ 持有/ 该锁/ 而/ 不会/ 降低/ 系统/ 并发/ 度/ ./ 这个/ 锁/ 只/ 需/ 保证/ 少数/ 更新/ 事务/ 可以/ 正确/ 地/ 隔离/ 其他/ 事务/ ./ SLI/ 利用/ 被/ 频繁/ 访问/ 的/ 共享/ 锁/ 无/ 逻辑/ 上/ 的/ 竞争/ ,/ 消除/ 在/ 锁/ 内部/ 临界/ 区/ 的/ 物理/ 竞争/ ./ SLI/ 允许/ 事务/ 结束/ 的/ 时候/ 将/ 它/ 所/ 持有/ 的/ 锁/ 传递/ 给/ 下/ 一个/ 事务/ ./ 这种/ 策略/ 避免/ 了/ 对/ 每/ 一个/ 传递/ 的/ 锁/ 申请/ 和/ 释放/ 时/ 都/ 需要/ 调用/ 锁/ 管理器/ ./ 在/ 事务/ 提交/ 的/ 时候/ ,/ 事务/ 的/ 代理/ 线程/ 挑选/ 候选/ 传递/ 锁/ ,/ 然后/ 将/ 这些/ 锁/ 存放/ 于/ 线程/ 的/ 局部/ 锁/ 列表/ ,/ 并用/ 局部/ 锁/ 列表/ 初始化/ 下/ 一个/ 事务/ 的/ 锁/ 列表/ ./ SLI/ 机制/ 利用/ 以下/ 5/ 条/ 准则/ 选取/ 锁/ 作为/ 候选/ 继承/ 锁/ :/ (/ 1/ )/ 这个/ 锁/ 是/ 页面/ 上/ 或者/ 是/ 更/ 高层次/ 上/ 的/ 锁/ ;/ (/ 2/ )/ 这个/ 锁/ 被/ 频繁/ 访问/ ;/ (/ 3/ )/ 这个/ 锁以/ 共享/ 模式/ (/ S/ 、/ IS/ 、/ IX/ )/ 为/ 某个/ 事务所/ 持有/ ;/ (/ 4/ )/ 没有/ 别的/ 事务/ 等待/ 这个/ 锁/ ;/ (/ 5/ )/ 如果/ 该/ 锁上/ 存在/ 更/ 高层次/ 上/ 的/ 锁/ ,/ 上述/ 条件/ 仍然/ 成立/ ./ SLI/ 通过/ 以下/ 两个/ 途径/ 优化/ 性能/ :/ (/ 1/ )/ 减少/ 事务/ 的/ 锁/ 申请/ 和/ 释放/ 的/ 次数/ ,/ 从而/ 取得/ 较/ 快/ 的/ 响应/ 时间/ ,/ 多个/ 短/ 事务/ 可以/ 分摊/ 锁/ 申请/ 开销/ ;/ (/ 2/ )/ 申请/ 锁/ 的/ 其他/ 事务/ 面临/ 较少/ 的/ 锁/ 管理器/ 内部/ 临界/ 区/ 的/ 竞争/ ,/ 这种/ 方法/ 适用/ 于/ 短/ 事务/ ,/ 以便/ 分摊/ 锁/ 申请/ 和/ 释放/ 的/ 开销/ ./ 另外/ ,/ 投机/ 锁/ 继承/ 也/ 仅限于/ 共享/ 锁/ 和/ 页/ 级/ 以上/ 的/ 锁/ ,/ 并且/ 没有/ 其他/ 事务/ 等待/ 该锁/ ./ 文献/ [/ 11/ ]/ 利用/ 消除/ 闩/ 锁/ (/ latch/ -/ free/ )/ 的/ 数据结构/ 取代/ 传统/ 的/ 锁/ 和/ 缓冲区/ 哈希/ 表/ ,/ 降低/ 了/ 事务/ 申请/ 锁/ 和/ 释放/ 锁/ 的/ 开销/ ./ 这种/ 方法/ 能够/ 取得/ 与/ 投机/ 锁/ 继承/ 方法/ 接近/ 的/ 性能/ ,/ 但是/ 不会/ 受到/ 事务/ 特性/ 限制/ ./ IBMDB2/ 数据库系统/ 也/ 提供/ 了/ 一个/ 参数/ DB2/ _/ KEEPTABLELOCK/ ①/ ,/ 允许/ 事务/ 甚至/ 是/ 会/ 话/ 持有/ 只读/ 模式/ 的/ 表级/ 锁/ ,/ 直到/ 必要/ 才/ 释放/ 锁/ ./ 然而/ ,/ 只有/ 当/ 事务/ 不断/ 地/ 释放/ 然后/ 又/ 重新/ 申请/ 相同/ 的/ 锁/ 的/ 情况/ 下/ ,/ 这种/ 策略/ 才/ 会/ 有/ 收益/ ./ IBMDB2/ 文档/ 提示/ 在/ 一个/ 会话/ 的/ 生命周期/ 内/ 一直/ 持有/ 表级/ 锁会/ 导致/ 较差/ 的/ 并发/ 性能/ ,/ 因为/ 其他/ 事务/ 不能/ 执行/ 更新/ 操作/ ./ 这个/ 设置/ 在/ DB2/ 默认/ 是/ 禁用/ 的/ ./ 2.2/ 轻量级/ 并发/ 原语/ 现代/ CPU/ 提供/ 多种/ 并发/ 控制/ 原语/ ,/ 其中/ 在/ 数据库/ 常用/ 的/ 两种/ 为/ :/ 原子/ 读后/ 写/ (/ AtomicWriteAfterRead/ ,/ AWAR/ )/ 和/ 写/ 后/ 读/ (/ ReadAfterWrite/ ,/ RAW/ )/ ./ 在/ AWAR/ 中/ ,/ 线程/ // 进程/ 以/ 原子/ 操作/ 的/ 方式/ 读取/ 一个/ 公共/ 变量/ 然后/ 写回/ ./ AWAR/ 的/ 原子/ 性是/ 通过/ 闩/ 锁/ (/ 例如/ 旋转/ 锁/ ,/ spinlock/ )/ 而/ 获得/ 的/ ./ 闩/ 锁/ 的/ 实现/ 依赖/ 机器/ 的/ 原子/ 指令/ 例如/ compare/ -/ and/ -/ swap/ 或/ test/ -/ and/ -/ set/ ./ 在/ 基于/ 探测/ 方式/ 保持/ 高速缓存/ 一致性/ 的/ 现代/ 多处理器/ 体系结构/ 上/ ,/ AWAR/ 会/ 导致/ 高速缓存/ 失效/ ,/ 占用/ 系统总线/ 带宽/ ./ 这/ 是因为/ 当某/ 一个/ 进程/ 释放/ 闩/ 锁/ 以后/ ,/ 它/ 需要/ 将/ false/ 写入/ 锁/ 变量/ ./ 这会/ 使得/ 其他/ 竞争者/ 的/ 相应/ 的/ 高速缓存/ 内/ 的/ 锁/ 变量/ 失效/ ./ 其他/ 竞争者/ 各/ 承受/ 一次/ 高速缓存/ 未/ 命中/ ,/ 重新/ 读入/ 新值/ ,/ 接着/ 调用/ test/ -/ and/ -/ set/ 指令/ 获取/ 锁/ ./ 第一个/ 成功/ 获得/ 锁/ 的/ 进程/ 又/ 会/ 使得/ 其他/ 竞争者/ 的/ 高速缓存/ 的/ 锁/ 变量/ 副本/ 失效/ ,/ 从而/ 又/ 需要/ 再次/ 读取/ 内存/ 导致/ 总线/ 拥挤/ ./ 另外/ 一个/ 可/ 替代/ 的/ 编程/ 方式/ 是/ RAW/ ./ 具体/ 的/ 方式/ 是/ 进程/ P1/ 写/ 某/ 一/ 公共/ 变量/ A/ ,/ 接着/ 该/ 进程/ 读取/ 另外/ 一个/ 不同/ 的/ 公共/ 变量/ B/ ./ 若/ 在/ 这/ 之间/ 没有/ 别的/ 进程/ 写/ 公共/ 变量/ B/ ,/ RAW/ 可以/ 保证/ 并发/ 进程/ 看到/ 共享/ 变量/ 的/ 顺序/ 一致性/ 状态/ ./ 利用/ RAW/ 编程/ 方式/ 必须/ 确保/ 并发/ 进程/ 只能/ 看到/ 共享/ 变量/ 的/ 可/ 串行化/ 的/ 一致性/ 状态/ ./ 图/ 1/ (/ a/ )/ 展示/ 了/ 可能/ 出现/ 的/ 问题/ ./ ①/ http/ :/ // // publib/ ./ boulder/ ./ ibm/ ./ com/ // infocenter/ // db2luw/ // v9r5/ // index/ ./ jspPage4/ 进程/ P/ 和/ Q/ 根据/ RAW/ 模式/ 访问/ 公共/ 变量/ A/ 和/ B/ ./ 在/ 没有/ 限制/ 的/ 情形/ 下/ ,/ 如图/ 1/ (/ a/ )/ ,/ 数据/ 的/ 竞争/ 可能/ 导致/ 进程/ P/ 看见/ B/ =/ 0/ 和/ 进程/ Q/ 看见/ A/ =/ 0/ (/ 由于/ 高速缓存/ 内容/ 的/ 改变/ 没有/ 及时/ 反映/ 到/ 内存/ 上/ )/ ./ 这/ 违背/ 了/ 可/ 串行化/ 原则/ ./ 图/ 1/ (/ b/ )/ 展示/ 了/ 利用/ 内存/ 栅障/ (/ memorybarrier/ )/ 协调/ 进程/ 访问/ 内存/ 的/ 顺序/ 以/ 保证/ 程序执行/ 的/ 正确性/ ,/ 实现/ 可/ 串行化/ ,/ 也/ 就是/ 保证/ 进程/ P/ 和/ Q/ 能够/ 看到/ 这些/ 写/ 操作/ ./ 虽然/ 执行/ 内存/ 栅障/ 会/ 带来/ 一定/ 的/ 开销/ ,/ 但是/ 每/ 一个/ 进程/ 只/ 需/ 付出/ 一次/ 硬件/ 代价/ ./ 相比而言/ ,/ AWAR/ 会/ 导致/ 高速缓存/ 块/ 在/ 进程/ 之间/ 频繁/ 切换/ ,/ 造成/ 系统/ 颠簸/ ./ Jung/ 等/ 人/ [/ 5/ ]/ 认为/ 在/ 多/ 核/ 平台/ 上/ RAW/ 编程/ 模式/ 更/ 具有/ 扩展性/ ./ 利用/ RAW/ ,/ 他们/ 将/ 锁/ 管理器/ 修改/ 为/ 几乎/ 不用/ 闩/ 锁表/ 1MySQL/ 中锁/ 的/ 申请/ 和/ 释放/ 的/ 实现/ (/ 左边/ 的/ 代表/ 原来/ 的/ 实现/ ,/ 右边/ 的/ 代表/ 减少/ 闩/ 锁/ 的/ 实现/ ./ 增长/ 阶段/ 的/ 锁/ 请求/ 收缩/ 阶段/ 的/ 锁/ 请求/ 的/ 方式/ ./ 修改/ 后/ 的/ 锁/ 申请/ 和/ 释放/ 的/ 伪/ 代码/ 如表/ 1/ 所示/ ./ 传统/ 的/ 锁/ 管理器/ 中/ ,/ 事务/ 首先/ 在/ 数项/ 上/ 创建/ 一个/ 锁/ ./ 然后/ 将/ 这个/ 锁/ 插入/ 这个/ 数据项/ 上/ 的/ 锁/ 列表/ (/ 这时候/ 需要/ 对锁表/ 进行/ 封锁/ )/ ./ 然后/ ,/ 这个/ 事务/ 遍历/ 该/ 数据项/ 上/ 的/ 锁/ 列表/ ,/ 检测/ 是否/ 存在/ 不相容/ 的/ 锁/ ./ 如果/ 存在/ ,/ 则/ 标记/ 这个/ 锁为/ 等待/ 状态/ ,/ 接着/ 进行/ 死锁/ 检测/ ./ 利用/ 原子/ 操作/ 可以/ 去除/ 哈希/ 表上/ 的/ 闩/ 锁/ ./ 右侧/ 是/ 改写/ 后/ 去除/ 闩/ 锁/ 的/ 代码/ ,/ 它用/ 函数/ atomic/ _/ lock/ _/ insert/ (/ )/ 将/ 锁/ 以/ 原子/ 操作/ 的/ 方式/ 加入/ 哈希/ 表/ ./ 与/ 安全/ 的/ RAW/ 一致/ ,/ 每次/ 写/ 一个/ 共享/ 变量/ ,/ 接着/ 读/ 另外/ 一个/ 不同/ 的/ 共享/ 变量/ 都/ 要/ 有/ 内存/ 栅障/ 的/ 保护/ ./ 修改/ 后/ 的/ 代码/ 中/ 增加/ 了/ 一个/ 新/ 的/ 锁/ 状态/ OBSELETE/ ./ 这个/ 新/ 的/ 状态/ 是/ 为了/ 批量/ 回收/ 锁/ 的/ 内存/ 而/ 设计/ 的/ ,/ 表示/ n/ _/ lock/ =/ lock/ _/ creat/ (/ )/ ;/ n/ _/ lock/ →/ state/ =/ ACTIVE/ ;/ 犪/ 狋/ 狅/ 犿/ 犻/ 犮/ _/ 犾/ 狅/ 犮/ 犽/ _/ 犻/ 狀/ 狊/ 犲/ 狉/ 狋/ (/ 狀/ _/ 犾/ 狅/ 犮/ 犽/ )/ ;/ // // S1FORalllocks/ (/ lock/ )/ inthehash/ _/ bucketBEGINIF/ (/ lockisincompatiblewithn/ _/ lock/ )/ ENDFORIF/ (/ n/ _/ lock/ →/ state/ =/ =/ WAIT/ )/ atomic/ _/ synchronize/ (/ )/ ;/ IF/ (/ n/ _/ lockhastowait/ )/ ENDIFFORalllocks/ (/ lock1/ )/ inTxBEGIN/ 犾/ 狅/ 犮/ 犽/ 1/ →/ state/ =/ OBSELETE/ ;/ // // S6atomic/ _/ synchronize/ (/ )/ ENDFORPage5/ 这个/ 锁/ 不再/ 有效/ ./ 同时/ ,/ 需要/ 设计/ 新/ 的/ 死锁/ 检测/ 算法/ ,/ 以/ 避免/ 竞争/ ./ 修改/ 后/ 的/ 锁/ 释放/ 代码/ 也/ 去/ 除了/ 闩/ 锁/ ,/ 根据/ 安全/ 的/ RAW/ 模式/ 增加/ 内存/ 栅障/ ./ 注意/ 到/ 修改/ 后/ 的/ 锁/ 管理器/ 只是/ 将/ 锁/ 标记/ 为/ OBSELETE/ 而/ 没有/ 释放/ 结构/ 体/ 的/ 内存/ ./ 这个/ 阶段/ 不会/ 产生/ 悬挂/ 指针/ ./ 实际/ 的/ 锁/ 内存/ 释放/ 以/ 批量/ 的/ 方式/ 异步/ 进行/ ./ 重要/ 的/ 是/ ,/ 锁/ 释放/ 代码/ 需要/ 检查/ 在/ 这个/ 锁/ 之后/ 申请/ 的/ 其他/ 锁/ ,/ 唤醒/ 因为/ 申请/ 与/ 当前/ 锁/ 不相容/ 的/ 锁/ 而/ 被/ 阻塞/ 的/ 事务/ ./ 文献/ [/ 12/ ]/ 的/ 核心思想/ 是/ 将/ 锁/ 数据结构/ 的/ 内存/ 分配/ 和/ 释放/ 与/ 事务/ 对锁/ 的/ 申请/ 和/ 释放/ 解/ 耦合/ ./ 对锁/ 数据结构/ 的/ 内存/ 分配/ 和/ 释放/ 以/ 批量/ 的/ 方式/ 进行/ ,/ 与/ 事务处理/ 异步/ ./ 批量/ 方式/ 进行/ 锁/ 分配/ 和/ 回收/ 的/ 方法/ 的/ 潜在/ 问题/ 是/ 过时/ 的/ 锁/ 存在/ 于锁/ 管理器/ 的/ 哈希/ 链表/ 中/ ,/ 从而/ 使得/ 链表/ 较长/ ./ 2.3/ 分散/ 锁/ 管理器/ 功能/ Ren/ 等/ 人/ [/ 13/ ]/ 提出/ 的/ 技术/ 彻底/ 更改/ 了/ 传统/ 的/ 集中式/ 锁/ 管理策略/ ./ 一是/ VLL/ (/ VeryLightweightLocking/ )/ ./ 该/ 技术/ 对锁/ 管理器/ 作/ 了/ 两点/ 主要/ 改变/ :/ 不再/ 将/ 锁/ 信息/ 集中/ 存储/ ,/ 而/ 将/ 锁/ 的/ 信息/ 与/ 数据/ 一起/ 存储/ ,/ 例如/ 行级/ 锁/ ,/ 在/ 表/ 的/ 属性/ 中/ 增加/ 一个/ 隐藏/ 属性/ ,/ 来/ 记录/ 每/ 一行/ 记录/ 的/ 锁/ 信息/ ,/ 这样/ 数据/ 和/ 锁/ 信息/ 位于/ 同一个/ 高速缓存/ 块/ 里/ ,/ 可以/ 提高/ 高速缓存/ 命中率/ ;/ 另/ 一点/ 是/ 用/ 信号量/ (/ 整数/ )/ 来/ 取代/ 请求/ 列表/ ,/ 并且/ 给/ 事务/ 排序/ ,/ 事务/ 按照/ 到达/ 顺序/ 请求/ 锁/ ,/ 且/ 在/ 事务/ 开始/ 执行/ 前/ 一次性/ 请求/ 全部/ 锁/ ./ 另/ 一种/ 技术/ 是/ SCA/ (/ SelectiveContentionAnalysis/ )/ ,/ 该/ 技术/ 用来/ 解决/ VLL/ 并发/ 性差/ 、/ CPU/ 利用率/ 低/ 的/ 问题/ ./ VLL/ 技术/ 取消/ 了/ 传统/ 锁/ 管理器/ 使用/ 的/ 列表/ ,/ 改而为/ 每/ 一个/ 加锁/ 对象/ 维护/ 一个/ 整数/ 对/ (/ Cx/ ,/ Cs/ )/ ,/ 分别/ 代表/ 请求/ 该/ 对象/ 的/ 排/ 它/ 锁/ 、/ 共享/ 锁/ 的/ 事务/ 数/ ./ 每个/ 请求/ 锁/ 的/ 操作/ ,/ 只用/ 简单/ 地/ 将/ 对应/ 的/ Cx/ 或/ Cs/ 加一/ ,/ 与/ 之/ 相对/ 应/ ,/ 每个/ 释放/ 锁/ 的/ 操作/ ,/ 只用/ 简单/ 地/ 将/ 对应/ 的/ Cx/ 或/ Cs/ 减一/ ./ 显然/ ,/ 当/ 事务/ 请求/ 某个/ 对象/ 的/ 排/ 它/ 锁/ 时/ ,/ 将/ 该/ 锁/ 对应/ 的/ Cx/ 加一/ ,/ 当且/ 仅/ 当/ 此时/ Cx/ =/ 1/ ,/ Cs/ =/ 0/ ,/ 事务/ 获得/ 该排/ 它/ 锁/ ;/ 当/ 事务/ 请求/ 某个/ 对象/ 的/ 共享/ 锁时/ ,/ 将/ 该/ 锁/ 对应/ 的/ Cs/ 加一/ ,/ 当且/ 仅/ 当/ 此时/ Cx/ =/ 0/ ,/ 事务/ 获得/ 该/ 共享/ 锁/ ./ 除此之外/ ,/ 在/ 每个/ partition/ ,/ 都/ 有/ 一个/ 事务/ 请求/ 序列/ TxnQueue/ ./ 当新/ 事务/ 到达/ 时/ ,/ 它/ 一次性/ 请求/ 所有/ 锁/ (/ 即将/ 对应/ 的/ Cx/ 和/ Cs/ 加一/ )/ 后/ 加入/ 请求/ 队列/ ./ 在/ 事务/ 请求/ 锁/ 之后/ ,/ 系统/ 检查/ 它/ 请求/ 的/ 所有/ 锁/ ,/ 如果/ 事务/ 可以/ 顺利/ 获得/ 请求/ 的/ 所有/ 锁/ ,/ 该/ 事务/ 加入/ 请求/ 队列/ TxnQueue/ 时/ 被/ 标记/ 为/ Free/ ,/ 且/ 立即/ 执行/ ;/ 反之/ ,/ 事务/ 被/ 标记/ 为/ 阻塞/ ,/ 直到/ 被/ 系统/ 判定/ 为/ 可以/ 解除/ 阻塞/ 后/ 再/ 执行/ ./ 事务/ 提交/ 时/ ,/ 释放/ 所有/ 锁/ (/ 即将/ 对应/ 的/ Cx/ 和/ Cs/ 减一/ )/ ,/ 然后/ 从/ TxnQueue/ 移除/ ./ 在/ 传统/ 的/ 锁/ 管理器/ 中/ ,/ 当锁/ 释放/ 时/ ,/ 通过/ 遍历/ 锁/ 的/ 请求/ 列表/ 来/ 决定/ 继承/ 锁/ 的/ 事务/ ,/ 而/ VLL/ 里/ 没有/ 请求/ 锁/ 的/ 事务/ 的/ 信息/ ,/ 它/ 只是/ 简单/ 的/ 根据/ 以下/ 的/ 理由/ 选择/ 队列/ 中排/ 在/ 最/ 靠/ 前/ 的/ 阻塞/ 事务/ 来/ 解除/ 阻塞/ 然后/ 执行/ :/ 排/ 在/ 队列/ 头部/ 的/ 事务/ ,/ 之前/ 使得/ 它/ 阻塞/ 的/ 事务/ 已经/ 全部/ 提交/ 且/ 从/ 队列/ 中移/ 除了/ ,/ 所以/ 这个/ 事务/ 肯定/ 可以/ 获得/ 所有/ 锁/ ./ 这样一来/ ,/ 系统/ 中/ 每个/ 时刻/ 最/ 多/ 只有/ 一个/ 阻塞/ 的/ 事务/ 可以/ 被/ 解除/ 阻塞/ 并/ 执行/ ./ 随着/ 事务/ 的/ 执行/ 、/ 提交/ ,/ 其他/ 很多/ 在/ 传统/ 锁/ 管理/ 情况/ 下/ 已经/ 可以/ 被/ 解除/ 阻塞/ (/ 使/ 它/ 阻塞/ 的/ 事务/ 已经/ 提交/ 了/ )/ 的/ 事务/ ,/ 也/ 只能/ 等待/ 排在/ 它/ 前面/ 所有/ 的/ 事务/ 都/ 提交/ 才能/ 被/ 解除/ 阻塞/ 后/ 执行/ ,/ 这/ 大大降低/ 了/ 竞争/ 激烈/ 时/ 系统/ 的/ 并发/ 性/ ./ 为了/ 解决/ 以上/ 问题/ ,/ 提高/ 并发/ 度/ ,/ 提高/ 系统/ 的/ CPU/ 利用率/ ,/ 文献/ [/ 13/ ]/ 提出/ 了/ SCA/ 技术/ ./ SCA/ 指在/ 需要/ 的/ 时候/ (/ CPU/ 有/ 空闲/ 时/ ,/ 例如/ 队列/ 满/ )/ 进行/ 竞争/ 分析/ ,/ 在/ TxnQueue/ 中/ 寻找/ 可以/ 被/ 提前/ 唤醒/ 的/ 事务/ ./ 在/ TxnQueue/ 中/ ,/ 排在/ 第/ i/ 个/ 位置/ 的/ 事务/ ,/ 只有/ 可能/ 被/ 前/ i/ -/ 1/ 个/ 事务/ 阻塞/ ,/ 所以/ 越靠/ 前/ 的/ 事务/ ,/ 被/ 唤醒/ 提前/ 执行/ 的/ 可能性/ 就/ 越/ 大/ ./ SCA/ 维护/ 两个/ 大小/ 为/ 100KB/ 的/ 数组/ Dx/ 和/ Ds/ ,/ SCA/ 从/ TxnQueue/ 头/ 开始/ 逐一/ 扫描/ 事务/ ,/ 对于/ 每个/ 事务/ T/ :/ 对于/ T/ 的/ ReadSet/ 中/ 所有/ key/ ,/ 将/ Ds/ [/ hash/ (/ key/ )/ ]/ 置/ 1/ ,/ 对于/ T/ 的/ WriteSet/ 中/ 的/ 所有/ key/ ,/ 将/ Dx/ [/ hash/ (/ key/ )/ ]/ 置/ 1/ ./ 在/ 扫描/ 事务/ 的/ 同时/ ,/ 如果/ 事务/ 是/ 阻塞/ 的/ ,/ 将/ Dx/ 和/ Ds/ 置位/ 之前/ ,/ 检查/ T/ 的/ 读/ 集合/ 的/ 每/ 一个/ key/ 对应/ 的/ Dx/ 是否/ 为/ 0/ ,/ 检查/ T/ 的/ 写/ 集合/ 的/ 每/ 一个/ key/ 对应/ 的/ Ds/ 和/ Dx/ 是否/ 都/ 为/ 0/ ,/ 如果/ 全部/ 满足/ ,/ 则/ 代表/ T/ 与/ 前面/ 的/ 事务所/ 请求/ 的/ Page6/ 对象/ 没有/ 锁/ 冲突/ ,/ 即/ T/ 可以/ 被/ unblock/ 并/ 执行/ ,/ 此时/ SCA/ 返回/ T/ ./ 这样/ 在/ 系统/ CPU/ 空闲/ 时/ ,/ SCA/ 算法/ 能/ 找到/ 另外/ 的/ 不/ 在/ 队列/ 头部/ 但/ 可以/ 被/ 解除/ 阻塞/ 并/ 执行/ 的/ 事务/ ./ SCA/ 方法/ 的/ 缺点/ 是/ 为了/ 提高/ 系统/ 并发/ 度/ 必须/ 维护/ 一个/ 全局/ 的/ 读锁/ 集合/ 与/ 写/ 锁/ 集合/ ./ 所有/ 事务/ 的/ 读锁/ 集合/ 与/ 写/ 锁/ 集合/ 都/ 会/ 被/ 映射/ 到/ 这/ 两个/ 集合/ ./ 确定/ 在/ 事务/ 队列/ 是否/ 存在/ 可以/ 提前/ 执行/ 的/ 事务/ 需要/ 在/ CPU/ 空闲/ 的/ 时候/ 不断/ 扫描/ 这/ 两个/ 集合/ ./ 如果/ 某个/ 事务/ 持有/ 的/ 锁/ 不会/ 与/ 事务/ 队列/ 中/ 位于/ 该/ 事务/ 之前/ 的/ 事务/ 持有/ 的/ 锁/ 冲突/ (/ 通过/ 扫描/ 全局/ 读锁/ 集合/ 与/ 写集/ 集合/ )/ 则/ 该/ 事务/ 可以/ 提前/ 执行/ ./ 如果/ 是/ 计算/ 密集型/ 的/ 事务/ 类型/ ,/ SCA/ 退化/ 为/ VLL/ ./ 当/ 竞争/ 因子/ 小于/ 0.01/ 的/ 时候/ (/ 竞争/ 因子/ =/ 的/ 系统/ 执行/ 时间/ ,/ 而/ 传统/ 的/ 锁/ 管理器/ 占/ 系统/ 执行/ 时间/ 的/ 比重/ 大约/ 为/ 21/ %/ ./ 相比之下/ ,/ VLL/ 性能/ 提升/ 很大/ ;/ 当/ 竞争/ 因子/ 大于/ 0.08/ 的/ 时候/ ,/ VLL/ 的/ 性能/ 不如/ 传统/ 的/ 集中式/ 锁/ 管理策略/ ./ 3/ 日志/ 管理/ 的/ 多/ 核/ 优化/ 日志/ 管理器/ 是/ 数据库系统/ 的/ 一个/ 重要/ 部件/ ./ 几乎/ 所有/ 的/ 数据库系统/ 都/ 使用/ 集中式/ 的/ 预先/ 写/ 日志/ 策略/ 避免/ 在/ 系统/ 崩溃/ 的/ 时候/ 带来/ 的/ 数据/ 的/ 损坏/ 和/ 丢失/ 已/ 提交/ 工作/ ,/ 以/ 保证/ 事务/ 的/ 持久性/ ①/ [/ 14/ -/ 15/ ]/ ./ 由于/ 其/ 集中式/ 的/ 设计/ 和/ 对/ I/ // O/ 的/ 依赖/ 使得/ 它/ 很/ 容易/ 成为/ 性能/ 瓶颈/ ./ 较长/ 的/ 日志/ 刷新/ 时间/ 、/ 由/ 日志/ 带来/ 的/ 锁/ 竞争/ 、/ 日志/ 缓冲区/ 上/ 的/ 竞争/ 都/ 会/ 影响/ 系统/ 的/ 扩展性/ ./ 日志/ 操作/ 给/ 系统/ 带来/ 的/ 延迟/ 主要/ 是/ 4/ 类/ [/ 16/ ]/ :/ (/ 1/ )/ 系统/ 必须/ 保证/ 事务/ 提交/ 之前/ 日志/ 必须/ 写到/ 非易/ 失性/ 存储介质/ ;/ 因为/ 磁盘/ 的/ 访问/ 时间/ 是/ 毫秒/ 级别/ 的/ ,/ 刷新/ 日志/ 通常/ 为/ 事务/ 中/ 执行/ 时间/ 最长/ 的/ 部分/ ;/ 此外/ ,/ 当/ 很多/ 小/ 的/ I/ // O/ 请求/ 使得/ 记录/ 日志/ 的/ 设备/ 例如/ SSD/ 上/ 达到/ 饱和状态/ 时/ ,/ 记录/ 日志/ 的/ 延迟/ 变为/ 串行/ ;/ (/ 2/ )/ 在/ 刷新/ 日志/ 的/ 过程/ 中/ ,/ 事务/ 一直/ 持有/ 写锁/ ,/ 直到/ I/ // O/ 结束/ ;/ 在/ 很多/ 工作/ 负载/ 中/ ,/ 这/ 都/ 会/ 造成/ 瓶颈/ ,/ 特别/ 是/ 锁/ 竞争/ 激烈/ 的/ 场景/ ;/ (/ 3/ )/ 刷新/ 日志/ 除了/ I/ // O/ 延迟/ 以外/ 还有/ 其他/ 开销/ ;/ 在/ 等待/ I/ // O/ 完成/ 的/ 过程/ 中/ ,/ 事务/ 不能/ 继续执行/ ,/ 代理/ 线程/ 必须/ 被/ 挂/ 起/ ,/ 直到/ I/ // O/ 完成/ ;/ 与/ I/ // O/ 延迟/ 不同/ ,/ 上下文/ 切换/ 和/ 调度/ 决策/ 会/ 消耗/ CPU/ 时间/ ,/ 不能/ 重叠/ 执行/ 其他/ 任务/ ;/ 多核/ 硬件/ 环境/ 下/ 同时/ 运行/ 的/ 线程/ 很多/ ,/ 这/ 使得/ 操作系统/ 调度/ 器会/ 负载/ 过重/ ;/ (/ 4/ )/ 除了/ 逻辑/ 上锁/ 的/ 竞争/ 和/ 上下文/ 切换/ 的/ 开销/ ,/ 许多/ 线程/ 同时/ 想要/ 执行/ 日志/ 插入/ 操作/ ;/ 集中式/ 的/ 日志/ 缓冲区/ 有/ 明显/ 的/ 临界/ 区/ ,/ 其上/ 的/ 竞争/ 显然/ 也/ 会/ 影响/ 系统/ 的/ 扩展性/ ./ 为了/ 提高/ 日志/ 管理器/ 的/ 扩展性/ ,/ 必须/ 设法/ 提高/ 日志/ 的/ I/ // O/ 效率/ ,/ 并且/ 减少/ 日志/ 临界/ 区/ 的/ 数量/ 和/ 缩短/ 关键/ 路径/ 的/ 长度/ ./ 成组/ 提交/ 技术/ [/ 17/ ]/ 通过/ 将/ 许多/ 小/ 的/ 刷新/ 日志/ 的/ 请求/ 组合/ 到/ 单个/ I/ // O/ 操作/ 减缓/ 磁盘/ 的/ 压力/ ,/ 减少/ I/ // O/ 等待时间/ ./ 成组/ 提交/ 技术/ 能够/ 减少/ 磁盘/ 访问/ 次数/ 和/ 增大/ 读取/ 的/ 磁盘/ 块/ ,/ 进而/ 减少/ 磁头/ 转动/ 获得/ 更好/ 的/ 响应/ 时间/ ./ 但是/ 成组/ 提交/ 技术/ 不能/ 消除/ 不必要/ 的/ 上下文/ 切换/ 开销/ ,/ 因为/ 过多/ 的/ 事务/ 会/ 阻塞/ 来自/ 日志/ 管理器/ 的/ 挂/ 起/ 通知/ ./ 异步/ 提交/ 技术/ ②/ 结合/ 了/ 成组/ 提交/ 技术/ 的/ 优点/ ,/ 将/ 许多/ 刷新/ 日志/ 的/ 请求/ 组合/ 到/ 一起/ ,/ 并且/ 允许/ 事务/ 结束/ 而/ 不用/ 等待/ 刷新/ 日志/ 操作/ 完成/ ./ 这个/ 优化/ 将/ 日志/ 刷新/ 操作/ 从/ 关键/ 路径/ 上/ 完全/ 移除/ ,/ 但是/ 牺牲/ 了/ 事务/ 持久性/ 这个/ 特性/ ,/ 也就是说/ ,/ 已/ 提交/ 工作/ 有/ 可能/ 由于/ 系统/ 崩溃/ 而/ 丢失/ ./ Johnson/ 等/ 人/ [/ 16/ ]/ 针对/ 多核/ 平台/ 优化/ 了/ 的/ 写/ 日志/ 操作/ ./ 他们/ 重新/ 审视/ 了/ 提前/ 锁/ 释放/ 技术/ (/ EarlyLockRelease/ ,/ ELR/ )/ [/ 18/ ]/ ,/ 并/ 在/ 4/ 个/ 不同/ 延迟/ 的/ 非易/ 失性/ 设备/ 上/ 测试/ 了/ ELR/ 的/ 有效性/ ./ ELR/ 技术/ 是/ 指/ 事务/ 在/ commit/ 记录/ 到达/ 磁盘/ 之前/ 可以/ 释放/ 锁/ ,/ 减少/ 持有/ 锁/ 的/ 时间/ ./ 在/ ELR/ 技术/ 下/ ,/ 只有/ 提交/ 事务/ 需要/ 等待/ I/ // O/ 结束/ ./ 不/ 存在/ 其他/ 事务/ 需要/ 等待/ 提交/ 事务/ 的/ 锁/ 而/ 与/ 提交/ 事务/ 一起/ 等待/ I/ // O/ 结束/ ./ 文献/ [/ 16/ ]/ 的/ 实验/ 结果表明/ 在/ 越慢/ 的/ 设备/ 上/ ,/ ELR/ 获得/ 的/ 收益/ 越好/ ./ 即使/ 是/ 在/ 像/ SSD/ 上/ 的/ 快速/ 磁盘/ 设备/ ,/ ELR/ 也/ 可以/ 获得/ 比较/ 好/ 的/ 收益/ (/ 短/ 事务/ 的/ 执行/ 时间/ 比/ I/ // O/ 要/ 短/ 得/ 多/ )/ ./ 另外/ ,/ 数据/ 的/ 偏斜/ 程度/ 也/ 对/ ELR/ 造成/ 影响/ ./ 如果/ 数据偏斜/ 度/ 小/ ,/ 对锁/ 的/ 竞争/ 不/ 激烈/ ,/ ELR/ 减缓/ 锁/ 的/ 竞争/ 效果/ 不大/ ./ 如果/ 数据/ 的/ 偏斜/ 度大/ ,/ 锁/ 的/ 竞争/ 很/ 激烈/ ,/ 即使/ 在/ 没有/ 等待/ 日志/ 刷新/ 的/ 情况/ 下/ ,/ ELR/ 效果/ 也/ 不好/ ./ 按照/ 80/ %/ 的/ 访问/ 都/ 是/ 集中/ 在/ 20/ %/ 的/ 数据/ 上/ 的/ 原则/ ,/ 对应/ 数据/ 的/ 偏斜/ 度为/ 0.85/ 左右/ ,/ 这时候/ 锁/ 的/ 竞争/ 程度/ 刚好/ 是/ ELR/ 的/ 优化/ 点/ ./ 针对/ 多核/ 平台/ 上过/ 多/ 的/ 调度/ 而/ 导致/ 的/ 系统/ 瓶颈/ 和/ 上下文/ 切换/ 带来/ 的/ 开销/ ,/ 文献/ [/ 16/ ]/ 提出/ 一种/ 新/ 的/ 刷新/ 日志/ 的/ 方法/ :/ 流水线/ 方式/ 刷新/ 日志/ (/ flushpipelining/ )/ ./ 流水线/ 刷/ ①/ ②/ Page7/ 新/ 日志/ 类似/ 异步/ 提交/ 方式/ 不用/ 在/ 等待/ I/ // O/ 的/ 时候/ 将/ 线程/ 挂/ 起/ ,/ 从而/ 不会/ 有/ 上下文/ 切换/ 的/ 开销/ ./ 但是/ 不同于/ 异步/ 提交/ 方式/ ,/ 流水线/ 刷新/ 不/ 将/ 结果/ 返回/ 给/ 客户端/ ,/ 而是/ 转而/ 执行/ 其他/ 事务/ ./ 守护/ 进程/ 在/ 完成/ 刷新/ 日志/ 以后/ ,/ 通知/ 代理/ 线程/ // 进程/ 返回/ 继续执行/ 后续/ 事务/ ./ 实验/ 表明/ ,/ 流水线/ 刷新/ 和/ ELR/ 组合/ 的/ 效果/ 能够/ 达到/ 异步/ 提交/ 的/ 性能/ ,/ 而且/ 在/ 系统/ 崩溃/ 的/ 时候/ 具有/ 可/ 恢复性/ ./ 为/ 减缓/ 多核/ 情况/ 下/ 日志/ 缓冲区/ 上/ 的/ 竞争/ ,/ 文献/ [/ 16/ ]/ 设计/ 了/ 3/ 种新/ 的/ 日志/ 缓冲区/ 管理/ 方法/ ./ 传统/ 的/ 写/ 日志/ 缓冲区/ 需要/ 以下/ 3/ 个/ 步骤/ :/ (/ 1/ )/ 首先/ 获取/ 写/ 日志/ 缓冲区/ 上/ 的/ 排/ 它/ 锁/ ./ 如果/ 当时/ 正好/ 有/ 其他/ 的/ 服务/ 子/ 线程/ 在/ 写/ 日志/ 缓冲区/ ,/ 则/ 此子/ 线程/ 必须/ 等待/ 直到/ 获得/ 写/ 日志/ 缓冲区/ 上/ 的/ 写/ 锁/ ;/ (/ 2/ )/ 线程/ 将/ 日志/ 记录/ 复制到/ 相应/ 的/ 日志/ 缓冲区/ ;/ (/ 3/ )/ 释放/ 缓冲区/ 上/ 的/ 锁/ ./ 由于/ 它/ 的/ 简单/ 性/ ,/ 这种/ 方法/ 具有/ 吸引力/ ./ 这个/ 方法/ 的/ 缺点/ 是/ :/ 即使/ 是/ 缓冲区/ 从来不/ 会/ 重叠/ 的/ 情况/ 下/ ,/ 填充/ 日志/ 缓冲区/ 的/ 操作/ 也/ 是/ 串行化/ 执行/ ./ 图/ 2/ (/ B/ )/ 展示/ 了/ 由于/ 单一/ 的/ 长/ 日志/ 记录/ 会/ 给/ 后续/ 的/ 线程/ 造成/ 比较/ 大/ 的/ 延迟/ ./ 日志/ 记录/ 由/ 一个/ 头部/ 加上/ 任意/ 长度/ 的/ 值/ 组成/ ./ 日志/ 记录/ 结构/ 体/ 空间/ 的/ 申请/ 是/ 可/ 复合/ 的/ ,/ 也/ 就是/ 两个/ 连续/ 的/ 日志/ 记录/ 的/ 缓冲区/ 申请/ 也/ 可以/ 由/ 一个/ 头部/ 加上/ 任意/ 长度/ 的/ 属性/ 值/ 组成/ ./ 文献/ [/ 16/ ]/ 利用/ 这种/ 空间/ 的/ 可/ 复合性/ 将/ 线程/ 对/ 日志/ 缓冲区/ 的/ 填充/ 按组/ 进行/ ./ 每/ 一个组/ 都/ 有/ 一个/ 组织者/ ./ 一个组/ 只有/ 组织者/ 才/ 要/ 竞争/ 缓冲区/ 上/ 的/ 锁/ ,/ 且/ 一个组/ 只有/ 最后/ 离开/ 的/ 线程/ 需要/ 等待/ 锁/ 的/ 释放/ ./ 组织者/ 在/ 等待/ 互斥/ 变量/ 的/ 时候/ ,/ 后面/ 到来/ 的/ 请求/ 可以/ “/ 回退/ ”/ 到/ 一个/ 数组/ 将/ 他们/ 的/ 请求/ 组合/ 到/ 一起/ ./ 如图/ 2/ (/ C/ )/ 所示/ ,/ 组内/ 日志/ 缓冲区/ 的/ 填充/ 可以/ 并行执行/ ,/ 但组/ 之间/ 仍然/ 串行/ 执行/ ./ 由于/ 日志/ 缓冲/ 的/ 填充/ 不/ 具有/ 串行/ 特征/ ,/ 只要/ 满足/ 以/ LSN/ 的/ 顺序/ 将/ 日志/ 写回/ 即可/ ./ 文献/ [/ 16/ ]/ 修改/ 了/ 原来/ 的/ 日志/ 缓冲区/ 填充/ 算法/ ,/ 线程/ 申请/ 的/ 锁/ 可以/ 在/ 获得/ 缓冲区/ 以后/ 马上/ 释放/ ./ 因此/ 将/ 缓冲区/ 填充/ 与/ 锁/ 的/ 持有/ 解/ 耦合/ ./ 缓冲区/ 的/ 填充/ 可以/ 按/ 流水线/ 的/ 方式/ 进行/ :/ 下/ 一个/ 缓冲区/ 的/ 填充/ 可以/ 立刻/ 开始/ ,/ 只要/ 线程/ 获得/ 日志/ 缓冲区/ 空间/ ./ 如图/ 2/ (/ D/ )/ 所示/ ,/ 将/ 锁/ 的/ 持有/ 与/ 缓冲区/ 的/ 填充/ 解/ 耦合/ 可以/ 消除/ 长/ 日志/ 记录/ 对/ 缓冲区/ 填充/ 的/ 影响/ ./ 前面/ 讨论/ 的/ 两张/ 方法/ 具有/ 互补性/ ,/ 因此/ 将/ 两种/ 方法/ 组合/ 在/ 一起/ ,/ 把/ 日志/ 缓冲区/ 上/ 的/ 竞争/ 限制/ 在/ 某/ 一个/ 常数/ 下/ ,/ 同时/ 也/ 消除/ 日志/ 记录/ 的/ 大小/ 对/ 刷新/ 日志/ 的/ 影响/ ./ 3.1/ PostgresQL/ -/ MC/ 的/ 日志/ 多核/ 优化/ 虽然/ 相对/ 传统/ 的/ 日志/ 插入/ 算法/ ,/ 文献/ [/ 16/ ]/ 提出/ 将/ 锁/ 的/ 持有/ 与/ 日志/ 缓冲区/ 的/ 填充/ 解/ 耦合/ 的/ 方法/ 具有/ 很大/ 优势/ ,/ 但是/ 计算/ 日志/ 记录/ 在/ 日志/ 缓冲区/ 所/ 占/ 长度/ 的/ 操作/ 仍/ 不可避免/ 的/ 需要/ 串行化/ 执行/ ./ 在/ 竞争/ 激烈/ 的/ 应用/ 中/ ,/ 这/ 也/ 会/ 给/ 系统/ 的/ 响应/ 时间/ 造成/ 很大/ 延迟/ ./ 中国人民大学/ 开发/ 的/ PostgreSQL/ -/ MC/ ,/ 即/ 针对/ 多核/ 处理器/ 优化/ 的/ PostgreSQL/ ,/ 使用/ 了/ 并行/ 化/ 的/ 日志/ 填充/ 方案/ ./ PostgreSQL/ -/ MC/ 将/ 日志/ 缓冲区/ 分成/ 若干/ 不/ 相交/ 区域/ ,/ 日志/ 填充/ 分别/ 在/ 不同/ 的/ 区域/ 并行执行/ ./ 每个/ 日志/ 记录/ 在/ 插入/ 到/ 某个/ 日志/ 缓冲区/ 之前/ 需要/ 获取/ 一个/ 时间/ 戳/ ./ 这个/ 时间/ 戳/ 保证/ 了/ 日志/ 重/ 放/ 顺序/ 与/ 对/ 数据库/ 操作/ 的/ 顺序/ 一致/ ./ PostgreSQL/ -/ MC/ 中/ 系统日志/ 检查点/ 需/ 遵循/ 完整性/ 原则/ ./ 现在/ 给出/ 完整/ 系统/ 检查点/ 的/ 定义/ ./ 定义/ 1/ ./ 多路/ 日志/ 系统/ S/ 具有/ n/ 个/ 日志/ 缓冲区/ :/ L1/ ,/ L2/ ,/ …/ ,/ Ln/ ,/ ck/ 刻/ 创建/ 的/ 检查点/ ./ 如果/ 存在/ cktu/ =/ tv/ =/ …/ =/ tw/ ,/ 则/ 称/ 这/ 是/ 一个/ 完整/ 系统/ 检查点/ ./ 如图/ 3/ 所示/ ,/ 由/ 虚线/ 包围/ 的/ 3/ 个/ 检查点/ 是/ 同一/ 逻辑/ 时刻/ 创建/ ,/ 属于/ 一个/ 完整/ 的/ 系统/ 检查点/ ./ 系统/ 在/ 某/ 时间/ 点/ t/ 崩溃/ ,/ 而/ 第/ 2/ 路/ 日志/ 缓冲/ 的/ 检查点/ 没/ 来得及/ 创建/ ,/ 那么/ 这个/ 系统/ 检查点/ 是/ 不/ 完整/ 的/ ./ 故障/ 恢复/ 系统/ 需要/ 反向/ 扫描/ 日志/ 文件/ 寻找/ 最近/ 完整/ 系统/ 检查点/ SCK/ ./ PostgreSQL/ -/ MC/ 重做/ (/ redo/ )/ 例程/ 从/ SCK/ 上/ 每个/ 日志/ 检查点/ cki/ 开始/ 挑选/ 具有/ 最小/ 时间/ 戳/ 的/ 日志/ 记录/ 进行/ 重放/ ./ 为了/ 避免/ 日志/ 空洞/ ,/ 进行/ 重放/ 的/ Page8/ 连续/ 两个/ 日志/ 记录/ r/ 我们/ 将/ PostgreSQL/ -/ MC/ 与/ PostgreSQL9/ ./ 2/ 、/ Postgre/ -/ SQL9/ ./ 4/ 开发/ 版/ 进行/ 比较/ (/ PostgreSQL9/ ./ 4/ 还/ 没有/ 正式版/ ,/ 之所以/ 选择/ PostgreSQL9/ ./ 4/ 是因为/ 这个/ 版本/ 的/ PostgreSQL/ 对/ 日志/ 系统/ 进行/ 了/ 优化/ )/ ./ 实验/ 所用/ 的/ 硬件平台/ 参数/ 如表/ 2/ 所示/ ./ 实验/ 平台/ 的/ 操作系统/ 为/ Linux3/ ./ 2.0/ ./ 利用/ TPC/ -/ B/ 以及/ 我们/ 开发/ 的/ Micro/ -/ benchmark/ 对系统/ 进行/ 测试/ ./ 为了/ 消除/ 磁盘/ I/ // O/ 的/ 瓶颈/ ,/ 数据/ 集/ 全部/ 放入/ 内存/ 文件系统/ tempfs/ ./ Micro/ -/ benchmark/ 由/ 一张/ 表/ 构成/ ,/ 表/ 模式/ 为/ (/ Id/ :/ intprimarykey/ ;/ Info/ :/ text/ )/ ./ 为了/ 增加/ 日志/ 子系统/ 临界/ 区/ 的/ 压力/ ,/ Micro/ -/ benchmark/ 的/ 测试/ 语句/ 为/ 100/ %/ 更新/ 类型/ ./ 数据库/ 的/ 连接数/ 为/ CPU/ 核数/ 的/ 两倍/ ./ 硬件/ 名称/ CPUSocketsHardwareThreadClockSpeedL1D/ -/ CacheL1I/ -/ CacheL2CacheL3CacheMemoryPostgreSQL9/ ./ 2/ 的/ 日志/ 填充/ 技术/ 如图/ 2/ (/ B/ )/ 所示/ ./ 日志/ 记录/ 的/ 插入/ 需要/ 串行化/ 进行/ ./ 本文/ 测试/ 所用/ PostgreSQL9/ ./ 4/ 是/ 开发/ 版/ 的/ ./ PostgreSQL9/ ./ 4/ 的/ 日志/ 填充/ 技术/ 如图/ 2/ (/ D/ )/ 所示/ ./ 将/ 日志/ 的/ 填充/ 与/ 获取/ 临界/ 区/ 的/ 锁/ 并行/ 化/ ./ PostgreSQL9/ ./ 4/ 将/ 日志/ 填充/ 的/ 临界/ 区/ 代码/ 量/ 从/ PostgreSQL9/ ./ 2/ 的/ 几百/ 行/ 缩减到/ 只有/ 5/ 行/ ,/ 即/ 获取/ 临界/ 区/ 互斥/ 变量/ 以后/ 只是/ 简单/ 地/ 计算/ 该/ 日志/ 记录/ 所/ 占/ 的/ 空间/ ,/ 然后/ 即可/ 释放/ 互斥/ 变量/ ./ 实验/ 结果/ 如图/ 4/ 、/ 图/ 5/ 所示/ ./ 在/ 一个/ CPU/ 核数/ 的/ 情况/ 下/ ,/ 3/ 个/ 系统/ 的/ 吞吐/ 率/ 差别/ 不大/ ./ 在/ 16/ 个/ CPU/ 核数/ 的/ 情况/ 下/ ,/ PostgreSQL9/ ./ 4/ 的/ 吞吐/ 率/ 在/ 不同/ 的/ 测试/ 标准/ 上要/ 比/ PostgreSQL9/ ./ 2/ 的/ 吞吐/ 率/ 分别/ 高/ 6/ %/ (/ TPC/ -/ B/ )/ 与/ 30/ %/ (/ Micro/ -/ benchmark/ )/ ;/ 在/ 32/ 核/ 的/ 情况/ 下/ PostgreSQL9/ ./ 4/ 的/ 吞吐/ 率要/ 比/ PostgreSQL9/ ./ 2/ 的/ 吞吐/ 率/ 分别/ 高/ 67/ %/ (/ TPC/ -/ B/ )/ 与/ 40/ %/ (/ Micro/ -/ benchmark/ )/ ./ 在/ TPC/ -/ B/ 的/ 测试/ 下/ ,/ PostgreSQL/ -/ MC/ 的/ 吞吐/ 率/ 在/ 16/ 核/ 与/ 32/ 核/ 的/ 情况/ 下比/ PostgreSQL9/ ./ 2/ 的/ 吞吐/ 率/ 分别/ 高/ 12/ %/ 与/ 100/ %/ ;/ 在/ Micro/ -/ benchmark/ 的/ 测试/ 下/ ,/ PostgreSQL/ -/ MC/ 的/ 吞吐/ 率/ 在/ 16/ 核/ 与/ 32/ 核/ 的/ 情况/ 下比/ PostgreSQL9/ ./ 2/ 的/ 吞吐/ 率/ 分别/ 高/ 40/ %/ 与/ 60/ %/ ./ PostgreSQL/ -/ MC/ 的/ 优化/ 效果/ 比/ PostgreSQL9/ ./ 4/ 开发/ 版好/ ./ 图/ 4/ 不同/ 核/ 数下/ ,/ 利用/ TPC/ -/ B/ 测试/ 3/ 个/ 系统/ 的/ 吞吐/ 率图/ 5/ 不同/ 核/ 数下/ ,/ 利用/ Micro/ -/ benchmark/ 测试/ 值得一提的是/ 随着/ 像/ 固态/ 硬盘/ 的/ 新/ 闪存/ 产品/ 开始/ 进入/ 主流/ 的/ 计算机/ 市场/ ,/ 闪存/ 技术/ 被/ 认为/ 是/ 磁盘/ 技术/ 的/ 替代/ ./ 最近/ 也/ 有/ 相关/ 研究/ 利用/ 闪存/ 技术/ 提高/ 数据库系统/ 性能/ [/ 19/ -/ 25/ ]/ ./ 文献/ [/ 24/ ]/ 的/ 研究/ 表明/ 固态/ 硬盘/ 可以/ 显著/ 提高/ 事务/ 写/ 日志/ 的/ 性能/ ./ Chen/ [/ 25/ ]/ 则/ 主要/ 关注/ 以下/ 4/ 点/ :/ (/ 1/ )/ 突破/ 带宽/ 限制/ ,/ 利用/ 多/ 闪存/ 设备/ ,/ 并行/ 化/ I/ // O/ 提高/ 刷新/ 日志/ 操作/ 性能/ ;/ (/ 2/ )/ 解决/ 由于/ 设备/ 擦除/ 操作/ 而/ 引起/ 的/ 不同/ 的/ 写/ 延迟/ ;/ (/ 3/ )/ 高效/ 的/ 系统/ 恢复/ 处理/ ;/ (/ 4/ )/ 将/ 闪存/ 设备/ 与/ 磁盘/ 设备/ 结合/ 起来/ 获得/ 更好/ 的/ 日志/ 操作/ 和/ 系统/ 恢复/ 性能/ ./ 文献/ [/ 25/ ]/ 的/ 目标/ 是/ 廉价/ 、/ 高效/ 和/ 简单/ 的/ 日志/ 处理/ 方法/ ./ 利用/ 闪存/ 技术/ 提升/ DBMS/ 日志/ 的/ 性能/ 主要/ 是/ 加快/ 刷新/ 日志/ 的/ 性能/ ,/ 而/ 不是/ 减缓/ 日志/ 模块/ 临界/ 区/ 的/ 竞争/ ./ 4/ 多/ 核下/ 的/ 缓冲区/ 管理/ 在/ 数据库系统/ 的/ 缓冲区/ 管理器/ 中/ ,/ 存在/ 缓冲/ 块/ 索引/ (/ 通常/ 由/ 哈希/ 表/ 构成/ )/ 和/ LRU/ 链/ 等/ 关键/ 数据结构/ ./ 这些/ 数据结构/ 的/ 访问/ 具有/ 排他性/ ./ 即便/ 在/ I/ // O/ 带宽/ 无限大/ 的/ 情况/ 下/ ,/ 多核/ 处理器/ 对/ 这些/ 数据结构/ 的/ 访问/ 也/ 必须/ 是/ 串行/ 的/ ,/ 这/ 造成/ 了/ 严重/ 的/ 扩展性/ 瓶颈/ ./ 因此/ ,/ 缓冲区/ 管理器/ 是/ 多/ 核/ 扩展/ 优化/ 的/ 重点对象/ ./ 已有/ 的/ 关于/ 数据库系统/ 缓冲区/ 研究/ 都/ 集中/ 在/ 如何/ 提高/ 缓冲区/ 命中率/ [/ 26/ -/ 27/ ]/ ./ Tsuei/ 等/ 人/ [/ 28/ ]/ 在/ 对称/ 多处理机/ 上/ 设计/ 实验/ 以/ 探讨/ 数据库/ 大小/ 、/ 缓冲区/ 大小/ 和/ Page9/ 处理器/ 数目/ 对/ 数据库/ 性能/ 造成/ 的/ 影响/ ,/ 尤其/ 是/ 对/ 缓冲区/ 命中率/ 和/ 系统/ 吞吐/ 率/ 的/ 影响/ ./ 他们/ 用/ TPC/ -/ C/ 负载/ 研究/ 缓冲区/ 大小/ 与/ 性能/ 的/ 关系/ ,/ 发现/ 比/ 数据库/ 稍/ 小/ 的/ 缓冲区/ 大小/ 就/ 已经/ 足够/ ./ 同时/ ,/ 他们/ 也/ 给出/ 规则/ :/ 10/ %/ ~/ 15/ %/ 的/ 数据库/ 大小/ 就/ 已经/ 贡献/ 了/ 80/ %/ 的/ 缓冲区/ 命中率/ ./ 实际上/ OSDL/ 的/ 6.8/ GBDBT/ -/ 1/ 和/ 5.6/ GBDBT/ -/ 2/ 测试数据/ 集/ (/ 分别/ 由/ TPC/ -/ W/ 和/ TPC/ -/ C/ 演变/ 而/ 来/ )/ 在/ 装备/ 256MB/ 缓冲区/ 的/ PostgreSQL8/ ./ 2/ 上/ 可以/ 产生/ 95/ %/ 的/ 缓冲区/ 命中率/ ./ 为了/ 减少/ LRU/ 链上/ 的/ 竞争/ ,/ ADABAS/ [/ 29/ ]/ 将/ 缓冲区/ 池/ 划分/ 成/ 几个/ 物理/ 区域/ ,/ 每个/ 物理/ 区域/ 都/ 有/ 自己/ 的/ LRU/ 链/ ./ 这种/ 方法/ 会/ 减少/ 缓冲区/ 命中率/ ,/ 尤其/ 是/ 数据偏斜/ 比较严重/ 的/ 时候/ ./ 同时/ ,/ 这种/ 方法/ 也/ 不/ 适合/ 大规模/ 多线程/ 并发/ 的/ 环境/ ./ 因为/ 在/ 这种/ 场景/ 下/ ,/ 它/ 按照/ 处理器/ 数目/ 细分/ 缓冲区/ 会/ 造成/ 缓冲区/ 命中率/ 下降/ ,/ 同时/ 竞争/ 的/ 减少/ 却/ 不/ 明显/ ./ 另外/ ,/ 文献/ [/ 29/ ]/ 没有/ 讨论/ 缓冲区/ 的/ 划分/ 与/ 缓冲区/ 命中率/ 的/ 变化/ 的/ 关系/ ./ Bp/ -/ wrapper/ [/ 30/ ]/ 在/ 缓冲区/ 管理/ 上/ 应用/ 批量/ 处理/ 技术/ ./ 这种/ 批量/ 处理/ 技术/ 可以/ 归类/ 为/ 延迟/ 同步/ 技术/ ,/ 即刻/ 返回/ 逻辑/ 操作/ 结果/ ./ 这种/ 批量/ 处理/ 技术/ 可以/ 分摊/ 申请/ 锁/ 而/ 带来/ 的/ 开销/ ./ Bp/ -/ Wrapper/ [/ 30/ ]/ 可以/ 工作/ 在/ 任何/ 置换/ 算法/ 中/ ,/ 并且/ 在/ 缓冲/ 命中/ 的/ 时候/ 消除/ 竞争/ ./ 但是/ ,/ 根据/ 文献/ [/ 30/ ]/ 的/ 实验/ 结果/ ,/ Bp/ -/ Wrapper/ 的/ 优点/ 在/ LRU/ 算法/ 族/ 不能/ 充分发挥/ ,/ 并且/ 提高/ CLOCK/ 算法/ 类/ 的/ 吞吐/ 率上/ 效果/ 不/ 明显/ ,/ 因为/ Bp/ -/ Wrapper/ 不能/ 消除/ 缓冲区/ 未/ 命中/ 的/ 时候/ 锁/ 的/ 竞争/ ./ 如果/ 其中/ 一个/ 并发/ 访问/ 线程/ 遇到/ 缓冲区/ 未/ 命中/ ,/ 需要/ 申请/ 加锁/ ,/ Bp/ -/ wrapper/ 必须/ 对/ 阻塞/ 操作/ 进行/ 排序/ ./ 在/ 缓冲区/ 命中/ 的/ 情况/ 下/ ,/ CLOCK/ 算法/ 也/ 不/ 需要/ 申请/ 加锁/ ./ 因此/ ,/ Bp/ -/ wrapper/ 不能/ 改善/ 当前/ PostgreSQL/ 的/ 缓冲区/ 管理策略/ ./ 大部分/ 缓冲区/ 并发/ 控制/ 问题/ 的/ 解决/ 都/ 是/ 依赖/ 个人/ 开发者/ 的/ 经验/ 知识/ ./ 关于/ 缓冲区/ 的/ 并发/ 控制/ 还/ 没有/ 被/ 密集/ 地/ 讨论/ 的/ 一个/ 原因/ 是/ 大规模/ 的/ 多处理器/ 还/ 未/ 普及/ ,/ 而且/ 目前/ 的/ 主要/ 关注点/ 仍/ 在/ 如何/ 提高/ 缓冲区/ 命中率/ 以/ 减少/ I/ // O/ ./ 然而/ ,/ 为/ 请求/ 的/ 磁盘/ 页面/ 钉住/ 缓冲区/ 页面/ 的/ bufferfix/ 操作/ 却/ 不/ 受限于/ I/ // O/ [/ 31/ ]/ ./ 尽管/ bufferfix/ 操作/ 导致/ 页面/ 置换/ 时/ 将/ 脏页/ 写出/ 会/ 发生/ 磁盘/ I/ // O/ ,/ 但是/ 现代/ DBMS/ 通过/ 预先/ 刷新/ 脏/ 页面/ 和/ 选择/ 非脏/ 页面/ 作为/ 置换/ 页/ 来/ 减少/ 此类/ I/ // O/ ./ 这/ 就/ 意味着/ 如果/ 内存空间/ 足够/ 且/ 有/ 大量/ 的/ 缓冲区/ 池/ 可用/ ,/ 那么/ 就/ 可以/ 最大/ 程度/ 地/ 减少/ 由/ bufferfix/ 操作/ 带来/ 的/ 页面/ 置换/ 次数/ ./ 在/ 这种/ 情况/ 下/ bufferfix/ 操作/ 就/ 变成/ 受限于/ CPU/ 的/ 任务/ ./ 因此/ ,/ 缓冲区/ 管理/ 中/ 针对/ CPU/ 上/ 的/ 可扩展性/ 就/ 成为/ 多核/ 处理/ 时代/ 的/ 主要/ 问题/ ./ 实际上/ ,/ fix/ 和/ unfix/ 操作/ 是/ 数据库/ 中/ 调用/ 最/ 频繁/ 的/ 基本操作/ ./ 高效/ 的/ fix/ 和/ unfix/ 操作/ 尤其/ 重要/ ,/ 因为/ 它们/ 频繁/ 导致/ 临界/ 区上/ 的/ 竞争/ [/ 31/ ]/ ./ 数据库/ 每/ 访问/ 一次/ 缓冲区/ 管理器/ 模块/ ,/ 临界/ 区上/ 的/ 操作/ 都/ 需要/ 获得/ 互斥/ 变量/ ,/ 在/ 多处理器/ 环境/ 下/ 有/ 可能/ 出现/ “/ 互斥/ 变量/ 抖动/ ”/ 现象/ [/ 32/ ]/ ./ 此外/ ,/ 对锁/ 的/ 大量/ 访问/ 请求/ 有/ 可能/ 导致/ 护卫/ 现象/ ,/ 它/ 出现/ 在/ 当/ 持有/ 锁/ 的/ 线程/ 由于/ 某种/ 中断/ 例如/ 缺页/ 而/ 被/ 挂/ 起/ 的/ 时候/ ./ 然后/ ,/ 申请/ 锁/ 的/ 其他/ 线程/ 就/ 会/ 排队/ ,/ 不能/ 继续执行/ ./ 即使/ 锁/ 在/ 后面/ 被/ 释放/ ,/ 清空/ 队列/ 也/ 需要/ 花费/ 一定/ 的/ 时间/ ./ PostgreSQL8/ ./ 2/ 和/ MySQL5/ ./ 0/ 通过/ 使用/ 细粒度/ 的/ 锁/ 来/ 减缓/ 在/ 缓冲/ 池上/ 的/ 锁/ 竞争/ 问题/ ./ 它们/ 采用/ 称为/ “/ 锁/ 分段/ ”/ 的/ 传统/ 方法/ 来/ 提高/ 哈希/ 表上/ 的/ 并发/ ./ Yui/ 等/ 人/ [/ 31/ ]/ 采用/ 更/ 激进/ 的/ 方法/ 在/ 多/ 核/ 环境/ 下/ 进行/ 同步/ ./ 他们/ 利用/ 现有/ 的/ 非/ 阻塞/ 哈希/ 表/ ①/ 设计/ 非/ 阻塞/ 的/ 置换/ 算法/ Nb/ -/ GCLOCK/ ./ 因此/ ,/ 缓冲区/ 页面/ 的/ 查找/ 和/ 分配/ 都/ 不/ 需要/ 申请/ 锁/ 因而/ 也/ 就/ 避免/ 了/ 旋转/ 锁/ 带来/ 的/ 问题/ ②/ [/ 33/ ]/ ./ Nb/ -/ GCLOCK/ 置换/ 算法/ 是/ GeneralizedClock/ [/ 34/ ]/ 置换/ 算法/ 的/ 变种/ ./ 因此/ 它/ 具有/ GeneralizedClock/ 置换/ 算法/ 的/ 以下/ 优点/ :/ (/ 1/ )/ 低/ 开销/ 和/ 高/ 并发/ ;/ (/ 2/ )/ 由/ 并发/ 访问共享/ 变量/ 而/ 引起/ 竞争/ 的/ 概率/ 很/ 低/ ;/ 这些/ 良好/ 的/ 性质/ 和/ 性能/ 已经/ 被/ 规范/ 地/ 证明/ 和/ 确定/ [/ 34/ -/ 35/ ]/ ./ 文献/ [/ 31/ ]/ 的/ 作者/ 在/ Apache/ 的/ 开源/ 数据系统/ Derby/ 上/ 实现/ 了/ Nb/ -/ GClock/ 算法/ ./ 在/ 实验/ 中/ ,/ Nb/ -/ GClock/ 的/ 扩展性/ 可以/ 达到/ 64/ 核/ ,/ 消除/ 了/ 由/ bufferfix/ 操作/ 时/ 需要/ 加锁/ 而/ 引起/ 的/ 扩展性/ 差/ 等/ 问题/ ./ 4.1/ PostgreSQL/ -/ MC/ 的/ 缓冲区/ 多核/ 优化/ 探索/ 为了/ 消除/ 其他/ 模块/ ,/ 例如/ 锁/ 管理器/ 、/ 恢复/ 子系统/ 等/ 对/ 查找/ 数据库/ 缓冲区/ 的/ 瓶颈/ 带来/ 的/ 干扰/ ,/ 我们/ 选取/ 了/ 只读/ 事务/ 对系统/ 进行/ 测试/ ./ 通过/ 大量/ 的/ 实验/ 分析/ 以及/ 源码/ 的/ 阅读/ ,/ 我们/ 发现/ 缓冲区/ 管理器/ 的/ 扩展/ 瓶颈/ 集中/ 在/ 缓冲区/ 空闲/ 链表/ (/ BufferFreeList/ )/ 以及/ 哈希/ 表/ 管理/ ./ PostgreSQL/ 的/ 数据/ 页/ 访问/ 算法/ 如图/ 6/ 所示/ :/ 每当/ 事务/ 需要/ 访问/ 一个/ 数据/ 页/ ,/ 首先/ 在/ 哈希/ 表中/ 查找/ ./ 若/ 找到/ ,/ 说明/ 要/ 访问/ 的/ 数据/ 块/ 已经/ 在/ 缓冲/ 池中/ ,/ 直接/ 返回/ ;/ 若/ 没有/ 找到/ ,/ 则/ 需要/ 从/ 缓冲/ 池中/ 寻找/ 一个/ 空闲/ 页面/ 来/ 装入/ 要/ 访问/ 的/ 数据/ 块/ ./ 系统/ 在/ 缓冲区/ 空闲/ 链表/ 中/ 查找/ 是否/ 存在/ 空闲/ 页面/ ;/ 如果/ 存在/ ,/ 那么/ 直接/ 返回/ 该/ 空闲/ 页面/ 即可/ ;/ 若/ 不/ 存在/ ,/ 则/ 需要/ 采用/ 时钟/ 算法/ 为/ 需要/ 访问/ 的/ 数据/ 块/ 淘汰/ 页面/ ./ 这个/ 过程/ ①/ ②/ Page10/ 中有/ 两个/ 需要/ 串行化/ 执行/ 的/ 点/ :/ (/ 1/ )/ 缓冲区/ 空闲/ 链表/ 的/ 访问/ ;/ (/ 2/ )/ 将/ 新/ 的/ 数据/ 块/ 插入/ 到/ 哈希/ 表/ 过程/ 中/ 哈希/ 表/ 空闲/ 结点/ 的/ 获取/ ./ 中国人民大学/ PostgreSQL/ -/ MC/ 研究/ 团队/ 探索/ 了/ 以下/ 优化/ :/ (/ 1/ )/ 缓冲区/ 空闲/ 链表/ 的/ 访问/ ./ 通过/ 去除/ 缓冲区/ 空闲/ 链表/ 上/ 的/ 轻量级/ 锁/ ,/ 减少/ 事务/ 获取/ 空闲/ 页面/ 的/ 等待时间/ ,/ 增大/ 系统/ 并发/ 度/ ./ 竞争/ 空闲/ 数据/ 页/ 的/ 事务/ 需要/ 获得/ 旋转/ 锁/ ,/ 第一个/ 获得/ 旋转/ 锁/ 的/ 事务/ 会/ 标记/ 空闲/ 数据/ 页/ 的/ 引用/ 计数器/ ,/ 防止/ 其他/ 事务/ 使用/ 该/ 页面/ ./ 因此/ 去除/ 缓冲区/ 空闲/ 链表/ 上/ 的/ 轻量级/ 锁/ 不会/ 导致/ 出现/ 一个/ 空闲/ 页/ 被/ 多个/ 事务/ 使用/ 情况/ ./ 此外/ ,/ 通过/ 检测/ 缓冲区/ 空闲/ 链表/ 是否/ 由于/ 并发/ 而/ 遭受/ 破坏/ ,/ 我们/ 保证/ 每次/ 测试/ 不会/ 受到/ 缓冲区/ 空闲/ 链表/ 的/ 干扰/ ./ (/ 2/ )/ 时钟/ 置换/ 算法/ 的/ 修改/ ./ 每个/ 事务/ 随机/ 挑选/ 起始/ 位置/ 开始/ 时钟/ 置换/ 算法/ ,/ 事务/ 之间/ 并行执行/ 各自/ 的/ 时钟/ 算法/ ./ (/ 3/ )/ 哈希/ 表/ 空闲/ 节点/ 的/ 获取/ ./ 虽然/ PostgreSQL8/ ./ 2/ 以后/ 采用/ 称为/ “/ 锁/ 分段/ ”/ 的/ 方法/ 来/ 提高/ 哈希/ 表上/ 的/ 并发/ ,/ 但是/ 哈希/ 表/ 空闲/ 结点/ 的/ 获取/ 还是/ 只有/ 一个/ 入口/ ,/ 从而/ 成为/ 系统/ 的/ 瓶颈/ ./ 我们/ 采取/ 与/ “/ 锁/ 分段/ ”/ 类似/ 的/ 做法/ ,/ 将/ 哈希/ 表/ 的/ 空闲/ 结点/ 的/ 入口/ 分为/ 多个/ ,/ 分别/ 管理/ ./ 以下/ 的/ 实验/ 依次/ 采取/ 这些/ 优化/ ./ 实验/ 的/ 硬件/ 配置/ 见/ 3.1/ 节/ ./ 图/ 7/ 给出/ 不同/ 核/ 数下/ 系统/ 的/ 吞吐/ 率/ ./ 数据库/ 的/ 连接数/ 固定/ 在/ 100/ ,/ 测试/ 时间/ 为/ 2min/ ./ 我们/ 利用/ 数据仓库/ 星型/ 模型/ 测试/ 基准/ SSBM/ (/ StarSchemeBenchmark/ )/ 生成/ 测试数据/ (/ 扩展/ 因子/ SF/ =/ 1/ )/ ,/ 只/ 保留/ 事实/ 表/ Lineorder/ 的/ 整型/ 字段/ ./ 事实/ 表/ Lineorder/ 的/ 大小/ 约/ 为/ 300MB/ ,/ PostgreSQL9/ ./ 2/ 的/ 缓冲区/ 为/ 32MB/ ./ 查询/ 语句/ 为/ 在/ 事实/ 表上/ 简单/ 的/ SELECT/ -/ FROM/ -/ WHERE/ 点/ 查询/ ./ PostgreSQL9/ ./ 2/ 系统/ 吞吐/ 率/ 的/ 最大值/ 出现/ 在/ 8/ 核/ 左右/ ./ 随着/ 核数/ 的/ 增加/ 数据库系统/ 不能/ 再/ 利用/ 多余/ 的/ 硬件资源/ ./ 不管/ 在/ PostgreSQL/ 的/ 基础/ 上/ 去除/ 缓冲区/ 空闲/ 链表/ 的/ 轻量级/ 锁/ 以及/ 并行/ 化/ 时钟/ 置换/ 算法/ 还是/ 调节/ 哈希/ 表/ 分段/ 锁/ 的/ 个数/ ,/ 系统/ 的/ 扩展性/ 基本/ 都/ 停留/ 在/ 8/ 核/ 左右/ ./ 随着/ 核数/ 的/ 增加/ ,/ 系统/ 的/ 性能/ 反而/ 有所/ 下降/ ./ 利用/ VTune/ (/ Intel/ 公司/ 一个/ 性能/ 分析/ 软件/ )/ 观测/ ,/ 此时/ 系统/ 的/ 瓶颈/ 出现/ 在/ 哈希/ 表/ 的/ 插入/ 以及/ 删除/ 上/ ./ 接着/ ,/ 我们/ 将/ 哈希/ 表/ 空闲/ 结点/ 的/ 获取/ 入口/ 由/ 一个/ 扩展/ 为/ 多个/ ./ 此时/ 系统/ 的/ 扩展性/ 可以/ 达到/ 32/ 核/ ./ 从/ 以上/ 实验/ 结果/ 可以/ 得到/ 如下/ 结论/ :/ 缓冲区/ 的/ 瓶颈/ 出现/ 在/ 缓冲/ 池/ 空闲/ 页面/ 的/ 管理/ 和/ 哈希/ 表上/ ./ PostgreSQL/ -/ MC/ 研究/ 团队/ 未来/ 的/ 工作/ 方向/ 是/ 开发/ 面向/ 多核/ 的/ 生产者/ -/ 消费者/ 算法/ 管理/ 缓冲/ 池/ 以及/ 适合/ 多核/ 多/ CPU/ 平台/ 的/ 哈希/ 表/ ./ 图/ 7/ 不同/ 的/ 缓冲区/ 管理策略/ 下/ ,/ 系统/ 的/ 扩展性/ 不同于/ DBMS/ 的/ 缓冲区/ 研究/ ,/ OS/ 中/ 内存/ 管理/ 的/ 研究/ 较/ 早前/ 就/ 关注/ 多核/ 环境/ 下/ 的/ 优化/ 问题/ [/ 36/ -/ 42/ ]/ ./ 文献/ [/ 36/ -/ 39/ ]/ 利用/ 页面/ 染色/ 的/ 方法/ 划分/ 高速缓存/ 以/ 解决/ 高速缓存/ 争用/ 的/ 问题/ ,/ 从而/ 更好/ 地/ 管理/ OS/ 缓冲区/ 页面/ 的/ 分配/ ./ 文献/ [/ 40/ ]/ 认为/ 对/ 内存/ 控制器/ 的/ 竞争/ 对系统/ 的/ 性能/ 造成/ 很大/ 影响/ ,/ 改善/ 内存/ 子系统/ 性能/ 需要/ 设计/ 公平/ 的/ 内存/ 器/ ./ 文献/ [/ 41/ -/ 42/ ]/ 则/ 设计/ 了/ 高速缓存/ 竞争/ 敏感/ 的/ 调度/ 器以/ 最小化/ 资源/ 竞争/ ./ 以上/ 关于/ DBMS/ 的/ 缓冲区/ 在/ 多/ 核/ 环境/ 下/ 的/ 研究/ 仅仅/ 局限于/ DBMS/ 缓冲区/ 层面/ 算法/ 上/ 的/ 修改/ ./ 而/ 现实/ DBMS/ 系统/ 的/ 缓冲区/ 管理/ 大多/ 是/ 在/ 操作系统/ 的/ 缓冲区/ 基础/ 上/ 进行/ 定制/ ./ 因此/ ,/ 研究/ 多核/ 处理器/ 下/ DBMS/ 的/ 缓冲区/ 的/ 优化/ 需要/ 考虑/ 操作系统/ 的/ 缓冲区/ 修改/ ,/ 例如/ 文献/ [/ 43/ ]/ ./ 我们/ 认为/ DBMS/ 可以/ 借鉴/ 这些/ 思想/ 结合/ 硬件/ 特性/ 优化/ 其/ 缓冲区/ 的/ 设计/ ,/ 提出/ 更好/ 的/ 缓冲区/ 管理/ 算法/ ./ Page115/ 多/ 核下/ 索引/ 并发/ 控制/ B/ 树/ [/ 44/ -/ 45/ ]/ 作为/ 数据库/ 管理系统/ 中/ 的/ 默认/ 索引/ ,/ 广泛/ 用于/ 数据库/ 应用/ ./ 在/ 事务处理/ 方面/ 作出/ 过/ 杰出贡献/ 的/ JimGray/ 曾经/ 说/ :/ “/ B/ 树是/ 迄今为止/ 在/ 数据库/ 和/ 文件系统/ 中/ 最/ 重要/ 的/ 存取/ 路径/ 数据结构/ ”/ ./ 与/ 其他/ 索引/ 相同/ ,/ B/ 树/ 的/ 功能/ 是/ 将/ 搜索/ 关键字/ 映射/ 到/ 其/ 相关/ 信息/ ./ 除了/ 提供/ 精确/ 匹配/ 查找/ ,/ B/ 树/ 也/ 支持/ 范围/ 查询/ ,/ 并且/ 为/ 基于/ 排序/ 的/ 查询/ 执行/ 算法/ ,/ 例如/ 合并/ 连接/ 算法/ ,/ 省略/ 了/ 显式/ 的/ 排序/ 操作/ ./ 然而/ ,/ B/ 树上/ 的/ 并发/ 控制/ 在/ 多/ 核/ 扩展/ 上/ 表现/ 为/ 明显/ 的/ 瓶颈/ ./ B/ 树/ 利用/ 两种/ 不同/ 形式/ 锁/ ,/ 也/ 就是/ 闩/ 与/ 锁/ ,/ 分别/ 保护/ B/ 的/ 物理/ 结构/ 和/ 逻辑/ 内容/ ./ 闩/ 与/ 锁/ 的/ 区别/ 如表/ 3/ 所示/ ./ 由于/ B/ 树/ 节点/ 与/ 数据/ 呈/ 一对/ 多/ 的/ 关系/ ,/ 对/ B/ 树/ 节点/ 加锁/ 往往/ 是/ 粗粒度/ 的/ ,/ 会/ 导致/ 并发/ 度/ 降低/ ./ 此外/ ,/ 闩/ 锁/ 对应/ 的/ 临界/ 区/ 也/ 是/ 阻碍/ 多核/ 扩展/ 的/ 一个/ 因素/ ./ 隔离/ 内容/ 保护/ 内容/ 存在/ 方式/ 模式/ 死锁/ 死锁/ 处理/ 存放/ 位置/ 5.1/ B/ 树/ 物理/ 结构/ 的/ 保护/ Blink/ [/ 46/ ]/ 树是/ 一种/ 放宽/ B/ 树/ 结构限制/ 的/ 访问/ 方法/ ./ 它/ 将/ 结点/ 分裂/ 划分/ 成/ 两个/ 独立/ 的/ 阶段/ ./ 每/ 一个/ 结点/ 都/ 可以/ 有/ 一个/ 高位/ 保护/ 值/ 和/ 指向/ 其右/ 邻居/ 的/ 指针/ ./ 从/ 根到/ 叶子/ 节点/ 的/ 遍历/ 中/ ,/ 每/ 到达/ 一个/ 结点/ 就/ 必须/ 将/ 搜索/ 值/ 和/ 该/ 结点/ 的/ 高位/ 保护/ 值相/ 比较/ ./ 如果/ 高位/ 保护/ 值/ 小于/ 搜索/ 值/ ,/ 必须/ 沿着/ 该/ 结点/ 指向/ 右/ 邻居/ 的/ 指针/ 继续/ 查找/ ./ 分裂/ 节点/ 的/ 第/ 1/ 步是/ 创建/ 结点/ 的/ 高位/ 保护/ 值/ 和/ 右/ 邻居/ 结点/ ;/ 第/ 2/ 步是/ 独立/ 的/ 步骤/ ,/ 将/ 高位/ 保护/ 值/ 放置/ 在/ 父/ 节点/ ./ 第/ 2/ 个/ 步骤/ 可以/ 作为/ 其后/ 从根/ 结点/ 到/ 叶子/ 节点/ 遍历/ 的/ 附加/ 操作/ ,/ 应该/ 尽早/ 完成/ ./ 这个/ 操作/ 也/ 有/ 可能/ 被/ 系统/ 重启/ 或/ 系统/ 崩溃/ 所/ 推迟/ ,/ 但是/ 它们/ 不会/ 造成/ Blink/ 树/ 出现/ 数据/ 丢失/ 和/ 不一致性/ 情况/ ./ Blink/ 树/ 的/ 优点/ 是/ 结点/ 的/ 分配/ 和/ 引进/ 是/ 一个/ 局部/ 操作/ ,/ 只/ 对/ 溢出/ 结点/ 有/ 影响/ ,/ 因此/ 并发/ 度高/ ;/ 缺点/ 是/ 搜索/ 不够/ 高效/ ,/ 并且/ Blink/ 树/ 的/ 一致性/ 验证/ 会/ 变得/ 更/ 复杂/ ./ 在/ 值/ 频繁/ 插入/ 的/ 情况/ 下/ ,/ 需要/ 措施/ 保证/ 指向/ 邻居/ 结点/ 的/ 链表/ 不会/ 过长/ ./ B/ 树/ 结点/ 的/ 移除/ 也/ 可以/ 借鉴/ 这个/ 方法/ 以/ 提高/ 并发/ 度/ [/ 47/ ]/ ./ 第/ 1/ 步是/ 创建/ 指向/ 邻居/ 结点/ 的/ 指针/ ./ 第/ 2/ 步在父/ 节点/ 中将/ 指向/ 删除/ 结点/ 的/ 指针/ 擦除/ ./ 第/ 3/ 步/ 合并/ 结点/ ./ Jaluta/ 等/ 人/ [/ 48/ ]/ 通对/ Blink/ 做/ 了/ 进一步/ 改进/ ,/ 将/ 分裂/ 操作/ 限制/ 在/ 由/ 合适/ 的/ 父/ 结点/ 指向/ 的/ 结点/ 避免/ 了/ 频繁/ 插入/ 带来/ 的/ 长/ 链表/ ./ 文献/ [/ 49/ ]/ 提出/ 避免/ 闩/ 锁/ 的/ 一种/ B/ 树/ —/ —/ —/ Bw/ -/ tree/ ./ Bw/ -/ tree/ 针对/ 多核/ 和/ SSD/ 硬盘/ 的/ 新/ 硬件平台/ 而/ 设计/ 的/ ./ Bw/ -/ tree/ 利用/ Blink/ 树/ 的/ 原子/ 分裂/ 技术/ ,/ 结点/ 分裂/ 由/ 两个/ 独立/ 部分/ 组成/ ./ Bw/ -/ tree/ 树中/ 状态/ 的/ 改变/ 都/ 是/ 利用/ 原子/ 交换/ 指令/ 完成/ ,/ 因此/ 可以/ 避免/ 闩/ 锁/ ,/ 而且/ 不会/ 阻塞/ ./ 唯一/ 使得/ Bw/ -/ tree/ 阻塞/ 的/ 情况/ 就是/ 缺页/ ./ 由于/ Bw/ -/ tree/ 消除/ 闩/ 锁/ 的/ 特性/ ,/ 因此/ 一些/ 事务/ 不可避免/ 地会/ 遇到/ 竞争/ 而/ 导致/ 更新/ 页面/ 状态/ 失败/ ./ 此外/ ,/ Bw/ -/ tree/ 中/ 页面/ 的/ 概念/ 是/ 虚拟/ 的/ ,/ 任何/ 对/ 页面/ 的/ 更新/ 都/ 首先/ 必须/ 创建/ 一个/ Δ/ 记录/ ,/ 然后/ 附加/ 在/ 虚拟/ 页面/ 上/ ./ 过长/ 的/ Δ/ 记录/ 链表/ 会/ 降低/ 搜索/ 的/ 性能/ ,/ 需要/ 额外/ 的/ 开销/ 处理/ 这些/ 链表/ ./ FosterB/ -/ tree/ [/ 50/ ]/ 是/ 针对/ 多核/ 平台/ 和/ 类似/ SSD/ 等/ 非易失/ 存储器/ 而/ 提出/ 的/ 另/ 一/ B/ -/ tree/ 变种/ ./ FosterB/ -/ tree/ 设计者/ 们/ 的/ 目标/ 是/ :/ (/ 1/ )/ 设计/ 最小化/ 并发/ 控制/ 需求/ 的/ 数据结构/ ;/ (/ 2/ )/ 方便/ 数据/ 节点/ 往新/ 的/ 存储/ 上/ 迁移/ ;/ (/ 3/ )/ 支持/ 连续/ 和/ 复杂/ 的/ 自我/ 检测/ 功能/ ./ FosterB/ -/ tree/ 在/ 处理/ 更新/ 操作/ 时/ 采用/ 类似/ B/ -/ link/ 树/ 的/ 方法/ ,/ 每次/ 只/ 需/ 对/ 两个/ 索引/ 节点/ 加闩/ 锁/ ,/ 以/ 最大化/ 并发/ 操作/ ./ FosterB/ -/ tree/ 与/ B/ -/ link/ 树/ 的/ 不同/ 在于/ 为了/ 方便/ 数据/ 的/ 迁移/ FosterB/ -/ tree/ 的/ 索引/ 节点/ 最终/ 只有/ 一个/ 指向/ 它/ 的/ 指针/ ,/ 也/ 就是/ 消除/ 了/ 同/ 一层/ 节点/ 之间/ 的/ 指针/ ,/ 只/ 保留/ 指向/ 它/ 的/ 父/ 节点/ 指针/ ./ FosterB/ -/ tree/ 采用/ 对称/ 保护/ 码/ 允许/ 在/ 从/ 根到/ 叶子/ 节点/ 的/ 遍历/ 过程/ 中/ 进行/ 有效性/ 验证/ ./ 设计/ 上/ ,/ FosterB/ -/ tree/ 集合/ 了/ B/ -/ link/ 树/ [/ 46/ ]/ 、/ 对称/ 保护/ 码/ 以及/ 写/ 优化/ B/ -/ tree/ [/ 51/ ]/ 的/ 特点/ ,/ 最大/ 程度/ 地/ 避免/ 它们/ 的/ 缺点/ ./ 5.2/ B/ 树/ 逻辑/ 内容/ 的/ 保护/ 锁/ 将/ 读/ 事务/ 与/ 写/ 事务/ 隔离开/ ./ 为了/ 保证/ 一致性/ ,/ 事务/ 持有/ 读锁/ 直到/ 结束/ ./ 为了/ 保证/ 事务/ 终止/ 时/ 能够/ 撤销/ 所有/ 对/ 数据库/ 的/ 修改/ ,/ 事务/ 总是/ 持有/ 写锁/ 直到/ 结束/ ./ 此外/ ,/ 可/ 串行化/ 不仅/ 要求/ 对/ 存在/ 的/ 数据/ 加锁/ ,/ 也/ 要求/ 对/ 不/ 存在/ 的/ 数据/ 加锁/ ./ 例如/ 对于/ 一个/ top/ -/ k/ 查询/ ,/ 第二/ 执行/ 的/ 相同/ 的/ top/ -/ k/ 查询/ 必须/ 得到/ 相同/ 的/ 结果/ ,/ 而且/ 任何/ 影响/ 结果/ 集/ 的/ 插入/ 操作/ 都/ 应该/ 被/ 阻止/ ./ 对/ B/ 树/ 而言/ ,/ 这/ 通常/ 由/ 关键字/ 范围/ 封锁/ 来/ 实现/ ./ Mohan/ 的/ ARIES/ // KVL/ [/ 52/ ]/ 直接/ 区分/ 了/ 锁/ 与/ 闩/ 的/ 区别/ (/ 见表/ 3/ )/ ,/ 采用/ 一个/ 关键字/ -/ 值锁/ (/ KeyValueLock/ ,/ KVL/ )/ 覆盖/ 一个/ 区间/ 和/ 区间/ 上界/ 的/ 关键/ ./ 对非/ 单一/ 索引/ 而言/ ,/ 作用/ 在/ 某个/ 关键字/ 上/ 的/ 意向锁/ 对/ Page12/ 具有/ 相同/ 值/ 的/ 所有/ 行都/ 有效/ ./ 然而/ 将行/ ID/ 包含/ 在/ 锁/ ID/ 上/ 的/ 设计/ 却/ 不用/ 区分/ 单一/ 和/ 非/ 单一/ 索引/ ./ [/ 15/ ]/ 描述/ B/ 树上/ 的/ 行级/ 锁/ 就是/ 基于/ 关键字/ -/ 值/ Gray/ 锁/ ./ Lomet/ 的/ 关键字/ 范围/ 锁/ [/ 53/ ]/ 尝试/ 将/ 层次/ 锁/ 与/ 多/ 粒度/ 锁/ 应用/ 在/ 值/ 和/ 半开/ 闭/ 区间/ ,/ 但是/ 需要/ 额外/ 的/ 锁/ 模式/ ,/ 范围/ 插入/ 模式/ ,/ 以/ 获得/ 满意/ 的/ 并发/ 度/ ./ Graefe/ [/ 54/ ]/ 将/ 传统/ 的/ 层次/ 锁/ 更/ 严格/ 地/ 应用/ 在/ 关键字/ 和/ 关键字/ 的/ 区间/ ,/ 并且/ 在/ 插入/ 和/ 删除/ 操作/ 上/ 使用/ 了/ 伪/ 删除/ 记录/ ./ 这种/ 设计/ 可以/ 减少/ 特例/ 情况/ ,/ 取得/ 更高/ 并发/ 度/ ./ 最近/ 也/ 有/ 研究/ 将/ 增量/ 锁/ 与/ B/ 树上/ 的/ 关键字/ 范围/ 锁/ 结合/ 起来/ 以/ 取得/ 最大/ 并发/ 度/ [/ 49/ ]/ ./ 锁/ 的/ 设计/ 不仅/ 考虑/ 保护/ 数据库/ 一致性/ 与/ 隔离/ 性/ ,/ 还/ 需要/ 考虑/ 锁/ 协议/ 的/ 简单/ 性/ 与/ 最大化/ 系统/ 的/ 并发/ 度/ ./ 相关/ 的/ 研究者/ 一直/ 在/ 努力/ 设计/ 简单/ 的/ 锁/ 协议/ ,/ 同时/ 最大化/ 系统/ 并发/ 度/ ./ 然而/ ,/ 锁/ 的/ 维护/ 、/ 申请/ 和/ 释放/ 都/ 会/ 给/ 系统/ 造成/ 不小/ 的/ 开销/ ./ 随着/ 虚拟/ 技术/ 的/ 发展/ 使得/ 在/ 多/ 核/ 处理器/ 部署/ 无/ 共享/ 系统/ 成为/ 了/ 可能/ [/ 55/ ]/ ./ 无/ 共享/ 系统/ 从/ 物理/ 上/ 划分/ 数据库/ ,/ 一个/ 极端/ 的/ 例子/ H/ -/ Store/ [/ 56/ ]/ ./ 它/ 通过/ 嵌入/ 多个/ 单线程/ 的/ 执行/ 引擎/ ./ 各个/ 执行/ 引擎/ 之间/ 并行执行/ ,/ 互不/ 干扰/ ,/ 单个/ 执行/ 引擎/ 的/ 事务/ 串行/ 执行/ 从而/ 避免/ 并发/ 控制/ ./ 6/ 研究/ 展望/ 现在/ ,/ 数据库/ 研究/ 社区/ 已经/ 开始/ 重视/ 多核/ 架构/ 对/ 数据库系统/ 产生/ 的/ 影响/ [/ 57/ -/ 58/ ]/ ./ 为了/ 克服/ 当前/ 数据库系统/ 共同/ 的/ 弱点/ ,/ 也/ 就是/ 系统/ 随着/ 处理器/ 个数/ 或/ 核数/ 的/ 增长/ 其/ 性能/ 难以/ 提升/ ,/ 许多/ 学者/ 提出/ 了/ 不同/ 的/ 解决方案/ ./ 针对/ 上述/ 多核/ 环境/ 下/ 数据库/ 中/ 的/ 锁/ 管理器/ 、/ 缓冲区/ 管理器/ 、/ 日志/ 以及/ 索引/ 遇到/ 的/ 问题/ 总结/ 起来/ ,/ 解决方案/ 可以/ 分成/ 两类/ :/ 分布式/ 与/ 共享/ ./ 在/ 分布式/ 架构/ 下/ ,/ 将/ 多/ 核/ 与/ 多处理器/ 当做/ 分布式系统/ 对待/ ;/ 而/ 共享/ 系统/ 下/ ,/ 则/ 需要/ 解决/ 通信/ 和/ 资源/ 竞争/ 的/ 问题/ ./ 分布式系统/ 解决方案/ ./ 对/ 分布式/ 数据库/ 的/ 研究/ 在/ 20/ 世纪/ 80/ 年代/ 末/ 90/ 年代/ 初/ 就/ 已经/ 开展/ [/ 59/ -/ 60/ ]/ ./ 早期/ 分布式/ 数据库系统/ 的/ 许多/ 技术/ 可以/ 用于/ 改善/ 集中式/ 数据库系统/ 在/ 多/ 核/ 平台/ 下/ 的/ 扩展性/ ./ Salomie/ 等/ 人/ [/ 61/ ]/ 开发/ 的/ Multimed/ 系统/ 将/ 多个/ 数据库/ 实例/ (/ PostgreSQL/ 或者/ MySQL/ )/ 部署/ 在/ 多/ 核/ 平台/ 上/ ./ 运行/ 这些/ 数据库/ 实例/ 的/ 核/ 不/ 相交/ ./ 主/ 节点/ 负责/ 接收/ 并/ 分发/ 只读/ 查询/ 请求/ ,/ 同时/ 执行/ 更新/ 请求/ ./ 然后/ 主/ 节点/ 将/ 更新/ 结果/ 按/ 异步/ 方式/ 分发/ 到/ 卫星/ 节点/ ./ H/ -/ Store/ [/ 56/ ]/ 将/ 数据/ 在/ 多个/ 节点/ 和/ 核上/ 水平/ 划分/ ,/ 然后/ 事务/ 在/ 每个/ 核上/ 以/ 单线程/ 的/ 方式/ 串行/ 执行/ ./ 因此/ ,/ 每个/ 数据/ 划分/ 上/ 都/ 不/ 需要/ 同步/ 访问/ ./ 类似/ 传统/ 分布式/ 数据库/ ,/ 这些/ 系统/ 需要/ 工作/ 负载/ 感知/ 的/ 数据/ 划分/ 策略/ 以/ 减少/ 划分/ 间/ 的/ 通信/ ./ 数据偏斜/ 或者/ 是/ 数据/ 访问/ 与/ 数据/ 划分/ 的/ 模式/ 不/ 对应/ 都/ 会/ 造成/ 此类/ 系统/ 性能/ 上/ 的/ 问题/ ./ 共享/ 系统/ ./ 一个/ 共享/ 系统/ 的/ 例子/ 是/ 由/ Johnson/ 等/ 人/ [/ 10/ ]/ 开发/ 的/ shore/ -/ MT/ ./ 在/ 分析/ 了/ 现有/ 数据/ 存储系统/ 的/ 瓶颈/ 之后/ ,/ 他们/ 通过/ 优化/ 锁/ 、/ 闩/ 锁/ 和/ 同步/ 机制/ 从而/ 减少/ 竞争/ 得到/ 一个/ 多线程/ 的/ 、/ 可/ 扩展/ 的/ 系统/ ./ 物理/ 逻辑/ 组合/ 划分/ 是/ 介于/ 分布式系统/ 和/ 共享/ 系统/ 之间/ 的/ 一个/ 解决方案/ [/ 62/ -/ 63/ ]/ :/ 数据/ 仍然/ 是/ 共享/ 的/ ,/ 但是/ 利用/ 一个/ 多根/ B/ -/ tree/ 划分/ 数据/ ,/ 避免/ 昂贵/ 的/ 对/ 数据/ 页/ 加闩/ 锁/ 的/ 操作/ ./ DORA/ 系统/ [/ 62/ ]/ 将/ 各个/ 线程/ 绑定/ 到/ 不/ 相交/ 的/ 数据/ 集/ ,/ 根据/ 事务/ 访问/ 的/ 数据/ 把/ 事务/ 划分/ 成/ 更/ 小/ 的/ 动作/ 序列/ ./ 其中/ ,/ 每个/ 线程/ 都/ 拥有/ 各自/ 的/ 锁/ 机制/ 来/ 控制/ 对/ 所属/ 数据/ 的/ 访问/ ,/ 减轻/ 集中式/ 锁/ 管理/ 带来/ 的/ 弊端/ ./ 此外/ ,/ 近年来/ 涌现/ 的/ 一些/ 优秀/ 的/ 内存/ 数据库/ 例如/ 微软/ 的/ Hekaton/ [/ 64/ ]/ 和/ SAP/ 的/ HANA/ [/ 65/ ]/ 也/ 极力/ 优化/ 其/ 查询处理/ 引擎/ 以及/ 主要/ 模块/ 的/ 临界/ 区/ 以便/ 能/ 充分利用/ 多核/ 平台/ 的/ 优势/ ./ 7/ 总结/ 在/ 这篇/ 综述/ 中/ ,/ 我们/ 主要/ 讨论/ 新/ 的/ CPU/ 架构/ 下/ 的/ 数据库系统/ 优化/ 技术/ 以及/ 中国人民大学/ 在/ 开源/ 数据库/ PostgreSQL/ 上/ 提出/ 的/ 多/ 核/ 处理器/ 优化/ 技术/ ./ 现在/ ,/ 多核/ 处理器/ 提供/ 的/ 更/ 高/ 的/ 并行性/ 对/ 数据库系统/ 带来/ 的/ 挑战/ 是/ 明显/ 的/ ./ 数据库系统/ 必须/ 经过/ 彻底/ 的/ 改进/ ,/ 才能/ 利用/ 不断/ 增长/ 的/ 硬件/ 上下文/ 和/ 可用/ 的/ 资源/ ,/ 从而/ 进一步/ 改善/ 性能/ ./ 

