Page1/ 面向/ 无线/ 传感器/ 网络应用/ 的/ 自/ 适应/ 调试/ 方法/ 李丰/ 霍玮/ 冯晓兵/ (/ 中国科学院计算技术研究所/ 系统结构/ 重点/ 实验室/ 北京/ 100190/ )/ 摘要/ 传感/ 网/ 技术/ 是/ 物/ 联网/ 得以/ 实现/ 的/ 重要/ 基础/ ./ 然而/ ,/ 受到/ 资源/ 有限/ 以及/ 程序/ 行为/ 不/ 确定/ 等/ 因素/ 的/ 影响/ ,/ 无线/ 传感器/ 网络/ 上/ 编程/ 和/ 调试/ 的/ 难度/ 尤甚/ 于/ 普通/ 的/ 分布式/ 程序/ ./ 文中/ 提出/ 了/ 一种/ 面向/ 无线/ 传感器/ 网络/ 程序/ 的/ 源码/ 级/ 错误诊断/ 方法/ ./ 该/ 方法/ 采用/ 基于/ 全局/ 量/ 计数器/ 的/ 方法/ 进行/ 程序/ 追踪/ ,/ 然后/ 根据/ 追踪/ 日志/ 重/ 放/ 错误/ 执行/ 轨迹/ ,/ 支持/ 属性/ 违反/ 错误/ 的/ 分析/ 和/ 调试/ ./ 同时/ ,/ 通过/ 依赖/ 分析/ 确定/ 与/ 属性/ 相关/ 的/ 程序/ 片段/ ,/ 并/ 根据/ 系统资源/ 约束/ 以及/ 用户/ 反馈/ ,/ 自/ 适应/ 调整/ 追踪/ 这些/ 程序/ 片段/ 的/ 代码/ ,/ 以/ 满足/ 系统资源/ 的/ 限制/ ,/ 支持/ 错误/ 定位/ ./ 文中/ 以/ Open64/ 编译器/ 为/ 基础/ ,/ 实现/ 了/ 一个/ 针对/ TinyOS/ 操作系统/ 中/ nesC/ 程序/ 错误诊断/ 的/ 原型/ 系统/ ./ 实验/ 数据/ 表明/ ,/ 此/ 方法/ 能够/ 有效/ 地/ 控制/ 确定性/ 重/ 放/ 技术/ 的/ 时空/ 开销/ ,/ 有力/ 地/ 支持/ 了/ 无线/ 传感器/ 网络/ 程序/ 中/ 属性/ 违反/ 类型/ 错误/ 的/ 诊断/ ./ 关键词/ 物/ 联网/ ;/ 无线/ 传感器/ 网络/ ;/ 依赖/ 分析/ ;/ 确定性/ 重/ 放/ ;/ 调试/ 1/ 引言/ 无线/ 传感器/ 网络/ 能够/ 广泛/ 获取/ 客观/ 物理/ 信息/ ,/ Page2/ 中/ 错误/ 的/ 诊断/ 是/ 阻碍/ 其/ 发展/ 的/ 重要/ 因素/ 之一/ ./ 由于/ 受自/ 组织/ 特性/ 、/ 资源/ 受限/ 以及/ 通信/ 不/ 可靠/ 等/ 因素/ 的/ 影响/ ,/ 无线/ 传感器/ 网络/ 上/ 编程/ 和/ 调试/ 的/ 难度/ 更/ 甚于/ 普通/ 的/ 分布式/ 程序/ ./ 分布式系统/ 中/ ,/ 程序调试/ 工作/ 面临/ 的/ 主要/ 难题/ 是/ 如何/ 解决/ 由/ 程序执行/ 的/ 不确定性/ 带来/ 的/ 错误/ 难以/ 复现/ 的/ 问题/ ./ 确定性/ 重/ 放/ 技术/ 是/ 一种/ 公认/ 的/ 解决/ 方法/ ./ 该/ 技术/ 通过/ 动态/ 插桩/ 或/ 特殊/ 硬件/ 辅助/ ,/ 在/ 程序执行/ 的/ 过程/ 中/ ,/ 追踪/ 程序/ 的/ 不确定性/ 行为/ ,/ 构成/ 追踪/ 日志/ ./ 一旦/ 程序/ 失效/ ,/ 或/ 出现/ 执行/ 结果/ 不/ 符合/ 预期/ 的/ 情况/ ,/ 该/ 技术/ 将/ 根据/ 追踪/ 日志/ 重现/ 错误/ 执行/ 轨迹/ ,/ 为/ 错误/ 根源/ 的/ 定位/ 提供/ 支持/ ./ 确定性/ 重/ 放/ 技术/ 的/ 难点/ 在于/ 如何/ 缩减/ 技术/ 应用/ 时/ 的/ 时空/ 开销/ ./ 尽管/ 近十年/ 间/ ,/ 相关/ 研究/ 工作/ 收效/ 颇丰/ ,/ 但/ 对/ 无线/ 传感器/ 网络应用/ 而言/ ,/ 受/ 传感器/ 结点/ 上/ 计算/ 、/ 存储/ 以及/ 通信/ 资源/ 的/ 限制/ ,/ 该/ 技术/ 仍/ 无法/ 直接/ 用于/ 无线/ 传感器/ 网络/ 中/ 程序/ 的/ 调试/ ./ 以/ TelosB/ 传感器/ 结点/ 为例/ ,/ 其上/ 只/ 提供/ 48KB/ 的/ 闪存/ 空间/ (/ programflashmemory/ )/ ,/ 10KB/ 的/ RAM/ 和/ 1MB/ 的/ 额外/ 数据/ 空间/ (/ externalflash/ )/ ,/ 这/ 就/ 极大/ 地/ 限制/ 了/ 插/ 桩/ 的/ 粒度/ 以及/ 追踪/ 日志/ 的/ 规模/ ./ 但/ 如果/ 为了/ 满足/ 上述/ 约束/ 而仅/ 记录/ 粗粒度/ 、/ 无/ 针对性/ 且/ 不/ 完整/ 的/ 程序执行/ 信息/ ,/ 又/ 不利于/ 减轻/ 用户/ 诊断/ 错误/ 的/ 负担/ ./ 为/ 解决/ 上述/ 问题/ ,/ 本文/ 提出/ 一种/ 以/ 依赖/ 分析/ 为/ 基础/ ,/ 采用/ 自/ 适应/ 的/ 源码/ 级/ 追踪/ 和/ 重放/ 技术/ 进行/ 错误诊断/ 的/ 机制/ ,/ 在/ 无线/ 传感器/ 网络/ 部署/ 后/ 辅助/ 对/ 程序/ 行为/ 的/ 监控/ 和/ 错误/ 调试/ ./ 该/ 机制/ 简称/ 为/ ADA/ (/ Adap/ -/ tiveDiagnosisAssistant/ )/ ./ 本文/ 还/ 基于/ Open64/ 开源/ 编译器/ ①/ ,/ 实现/ 了/ 一个/ 面向/ TinyOS/ ②/ 操作系统/ 上/ 程序/ 错误诊断/ 的/ 原型/ ./ 给定/ 一个/ 无线/ 传感器/ 网络/ 程序/ P/ ,/ 该/ 方法/ 首先/ 为/ 用户/ 提供/ 一套/ 描述/ 机制/ ,/ 供其/ 描述/ 希望/ 在/ P/ 的/ 运行/ 过程/ 中/ 监控/ 的/ 属性/ ,/ 该/ 属性/ 的/ 违反/ 表示/ 产生/ 一种/ 程序/ 错误/ ;/ 而后/ ,/ 依次/ 采用/ 以下/ 步骤/ 进行/ 属性/ 监控/ 和/ 错误诊断/ :/ (/ 1/ )/ 编译/ 分析/ ./ 针对/ 程序/ 中/ 的/ 不确定性/ 行为/ ,/ 通过/ 插桩/ 技术/ ,/ 分别/ 生成/ 两套/ 源程序/ 副本/ :/ 追踪/ 控制程序/ Ptrace/ 和/ 重放/ 控制程序/ Preplay/ ./ 同时/ ,/ 通过/ 依赖/ 分析/ [/ 1/ ]/ ,/ 提取/ 程序/ 中/ 可能/ 影响/ 所/ 监控/ 属性/ 的/ 片段/ ,/ 记作/ S/ ;/ 在/ 此基础/ 上/ ,/ 以自/ 适应/ 规则/ 为/ 指导/ ,/ 根据/ 存储资源/ 的/ 充足/ 程度/ ,/ 自动/ 选择/ 对/ S/ 中/ 不确定性/ 行为/ 的/ 追踪/ 范围/ 和/ 粒度/ ,/ 以/ 控制/ 追踪/ 和/ 重放/ 的/ 时空/ 开销/ ;/ (/ 2/ )/ 日志/ 收集/ ./ 追踪/ 信息/ 随/ 追踪/ 控制程序/ Ptrace/ 的/ 执行/ 陆续/ 生成/ ,/ 构成/ 追踪/ 日志/ ./ 当/ 出现/ 程序执行/ 状态/ 违反/ 预期/ 属性/ 的/ 情况/ 时/ ,/ 各/ 传感器/ 结点/ 上/ 追踪/ 日志/ 将/ 回/ 传到/ 汇聚/ 结点/ ,/ 作为/ 复现/ 错误/ 执行/ 轨迹/ 的/ 依据/ ./ (/ 3/ )/ 重/ 放/ 诊断/ ./ 重放/ 控制程序/ Preplay/ 根据/ 追踪/ 日志/ 在/ PC机/ 上/ 复现/ 程序/ 的/ 错误/ 执行/ 轨迹/ ,/ 供/ 调试/ 工具/ 使用/ ./ 如果/ 第一轮/ 重放/ 的/ 粒度/ 或/ 范围/ 不足以/ 辅助/ 用户/ 定位/ 到/ 错误/ 根源/ ,/ ADA/ 将/ 根据/ 用户/ 反馈/ ,/ 自动/ 调整/ 追踪/ 范围/ ,/ 精化/ 追踪/ 粒度/ ,/ 并/ 进行/ 新一轮/ 的/ 追踪/ 日志/ 收集/ 和/ 错误/ 轨迹/ 重/ 放/ ,/ 直到/ 定位/ 错误/ 根源/ ./ 本文/ 将/ 上述/ 迭代/ 称为/ 自/ 适应/ 迭代/ ./ 为/ 确保/ 重放/ 的/ 平台/ 无关/ 性/ 和/ 机器/ 无关/ 性/ ,/ 追踪/ 和/ 重放/ 控制代码/ 的/ 插入/ 均/ 在/ 源码/ 级/ 完成/ ./ 本文/ 的/ 贡献/ 在于/ :/ (/ 1/ )/ 提出/ 一种/ 面向/ 无线/ 传感器/ 网络/ 中/ 程序/ 的/ 自/ 适应/ 追踪/ 策略/ ,/ 有效/ 地/ 控制/ 错误/ 追踪/ 的/ 时空/ 开销/ ./ 该/ 策略/ 可/ 依据/ 程序/ 特征/ 以及/ 资源/ 可用/ 状况/ ,/ 自动/ 生成/ 用于/ 追踪/ 、/ 重/ 放/ 程序执行/ 轨迹/ 的/ 源代码/ ,/ 并/ 根据/ 用户/ 诊断/ 的/ 反馈/ 自动/ 调整/ 追踪/ 和/ 重放/ 的/ 粒度/ 和/ 范围/ ./ (/ 2/ )/ 提出/ 一套/ 在/ 无线/ 传感器/ 网络/ 部署/ 后/ 进行/ 错误/ 调试/ 的/ 解决方案/ ,/ 该/ 方案/ 以/ 程序/ 错误/ 的/ 离线/ 重/ 放/ 技术/ 为/ 基础/ ,/ 能够/ 有效/ 地/ 提高/ 错误诊断/ 效率/ ./ 本文/ 第/ 2/ 节/ 介绍/ 依赖/ 关系/ 分析/ 与/ 确定性/ 重放/ 等/ 相关/ 概念/ ;/ 第/ 3/ 节/ 简要/ 介绍/ 本文/ 方法/ 的/ 处理/ 流程/ ;/ 第/ 4/ 节/ 具体/ 描述/ 该/ 方法/ 的/ 设计/ 与/ 实现/ ;/ 第/ 5/ 节/ 介绍/ 并/ 分析/ 实验/ 结果/ ;/ 第/ 6/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 7/ 节/ 总结/ 全文/ 工作/ 并/ 提出/ 展望/ ./ 2/ 背景/ 介绍/ 2.1/ 依赖/ 关系/ 分析/ 与/ 程序/ 切片/ 程序/ 切片/ [/ 2/ ]/ 是/ 一项/ 程序/ 提取/ 技术/ ,/ 由/ MarkWeiser/ 最先/ 提出/ ./ 该/ 技术/ 能够/ 从/ 整个/ 程序/ 中/ 提取/ 出/ 可能/ 影响/ 某个/ 变量/ 在/ 程序/ 中/ 某个/ 位置/ 上/ 的/ 取值/ 的/ 程序/ 片段/ ./ 由/ 程序/ 点/ P/ 和/ 变量/ V/ 构成/ 的/ 二元/ 组/ 〈/ P/ ,/ V/ 〉/ 称为/ 切片/ 标准/ ,/ 由/ 提取/ 出/ 的/ 程序/ 片段/ 构成/ 的/ 语句/ 集合/ 称为/ 切片/ ./ 切片/ 程序执行/ 后/ 得到/ 的/ 变量/ V/ 的/ 值/ 应/ 与/ 源程序/ 执行/ 到/ 程序/ 点/ P/ 处时/ 变量/ V/ 的/ 值/ 一致/ ./ 依赖/ 关系/ 分析/ [/ 1/ ]/ 是/ 程序/ 切片/ 的/ 基础/ ./ 程序/ 语句/ 间/ 的/ 依赖/ 关系/ 是/ 由/ 语句/ 间/ 数据流/ 或/ 控制流/ 形成/ 的/ 一种/ 约束/ ,/ 分别/ 称为/ 数据/ 依赖/ 和/ 控制/ 依赖/ ./ 此处/ 的/ 数据/ ①/ ②/ Page3/ 依赖/ 专指/ 流/ 依赖/ (/ 也/ 称为/ 真/ 依赖/ )/ ./ 语句/ S2/ 数据/ 依赖于/ S1/ ,/ 当且/ 仅/ 当/ ,/ S1/ 中/ 定义/ 了/ 变量/ x/ ,/ S2/ 中/ 使用/ 变量/ x/ ,/ 并且/ 存在/ 一条/ 从/ S1/ 到/ S2/ 的/ 非空/ 路径/ ,/ 该/ 路径/ 上/ 没有/ 对/ x/ 的/ 定值/ ./ 如果/ 存在/ 一条/ 从/ S1/ 到/ S2/ 的/ 非空/ 路径/ ,/ S2/ 后/ 控制/ 该/ 路径/ 上除/ S1/ 之外/ 的/ 所有/ 结点/ ,/ 但/ 不后/ 控制/ S1/ ,/ 则/ 称/ 语句/ S2/ 控制/ 依赖于/ S1/ ./ 一组/ 语句/ 之间/ 的/ 依赖/ 关系/ 可以/ 用/ 有向图/ 来/ 表示/ ,/ 其中/ ,/ 结点/ 代表/ 语句/ ,/ 边/ 代表/ 依赖/ 关系/ ,/ 构成/ 的/ 有向图/ 称为/ 依赖图/ ./ 目前/ 主流/ 的/ 程序/ 切片/ 算法/ 可/ 分为/ 两类/ :/ 基于/ 控制流/ 图/ 的/ 数据流/ 迭代/ 方法/ [/ 2/ ]/ 和/ 基于/ 系统/ 依赖图/ (/ SystemDependenceGraph/ ,/ SDG/ )/ [/ 3/ ]/ 的/ 图/ 可达/ 算法/ ./ SDG/ 是/ 对/ 程序/ 依赖图/ (/ ProgramDependenceGraph/ ,/ PDG/ )/ 的/ 扩展/ ./ SDG/ 在/ PDG/ 基础/ 上/ 加入/ 了/ 对/ 过程/ 间/ 依赖/ 关系/ 的/ 描述/ ,/ 如/ :/ 输入/ // 输出/ 参数/ 、/ 函数/ 副作用/ 等/ ./ 相对而言/ ,/ PDG/ 上/ 的/ 依赖/ 关系/ 也/ 称为/ 过程/ 内/ 依赖/ 关系/ ./ 2.2/ 确定性/ 重/ 放/ 串行/ 程序/ 在/ 输入/ 确定/ 的/ 前提/ 下/ ,/ 总是/ 执行/ 确定/ 的/ 路径/ ,/ 获得/ 确定/ 的/ 输出/ ./ 然而/ ,/ 受/ 线程/ 交替/ 、/ 进程/ 通信/ 等/ 不确定性/ 行为/ 的/ 影响/ ,/ 同一/ 并行程序/ 即便/ 在/ 输入/ 数据/ 确定/ 的/ 前提/ 下/ ,/ 执行/ 行为/ 也/ 可能/ 不同/ ./ 以/ 复现/ 并行程序/ 的/ 执行/ 轨迹/ 为/ 目的/ ,/ 分析/ 并/ 追踪/ 程序执行/ 过程/ 中/ 的/ 不确定性/ 行为/ 的/ 技术/ ,/ 称为/ 确定性/ 重/ 放/ 技术/ [/ 4/ -/ 6/ ]/ ./ 确定性/ 重放/ 可/ 分为/ 两类/ :/ (/ 1/ )/ 强调/ 值/ 的/ 确定性/ (/ valuedeterminism/ )/ ,/ 即/ 在/ 重放/ 过程/ 中/ ,/ 当/ 执行/ 到/ 内存/ 读写操作/ 时/ ,/ 所/ 读写/ 的/ 内存/ 值/ ,/ 与/ 程序/ 实际/ 执行/ 到/ 该/ 位置/ 时/ 读写/ 的/ 值/ 相同/ ;/ (/ 2/ )/ 仅/ 强调/ 输出/ 的/ 确定性/ (/ outputdeterminism/ )/ 即仅/ 要求/ 重/ 放/ 能够/ 获得/ 与/ 实际/ 执行/ 相同/ 的/ 输出/ [/ 4/ ]/ ./ 本文/ 实现/ 的/ 确定性/ 重/ 放/ 策略/ 本文/ 后续/ 章节/ 将/ 以/ 一个/ 用/ nes/ C语言/ 编写/ 的/ TinyOS/ 简单/ 应用程序/ 为例/ ,/ 介绍/ ADA/ 的/ 工作/ 原图/ 1ADA/ 框架/ 概貌/ 属于/ 第一类/ ./ 3/ 方法/ 概述/ 本文/ 处理/ 的/ 对象/ 是/ 用/ nes/ C语言/ 编写/ 的/ 运行/ 在/ TinyOS/ 操作系统/ 上/ 的/ 程序/ (/ 下文/ 简称/ TinyOS/ 程序/ )/ ./ TinyOS/ 是/ 由/ 加州大学/ 伯克利分校/ 开发/ 的/ 一个/ 针对/ 无线/ 传感器/ 网络/ 的/ 嵌入式/ 开源/ 操作系统/ ./ 一个/ TinyOS/ 程序/ 可/ 分为/ 两/ 部分/ :/ (/ 1/ )/ 仅/ 由/ 任务/ (/ task/ )/ 可达/ 的/ 代码/ ,/ 也/ 称/ 同步/ 代码/ (/ SC/ )/ ;/ (/ 2/ )/ 至少/ 可/ 由/ 一个/ 中断/ 服务/ 函数/ 到达/ 的/ 代码/ ,/ 也/ 称/ 异步/ 代码/ (/ AC/ )/ ./ 异步/ 代码/ 的/ 执行/ 只能/ 通过/ 中断/ 响应/ 实现/ ./ 图/ 1/ 所示/ 为/ ADA/ 机制/ 的/ 迭代/ 处理/ 流程/ ./ 按照/ 约定/ 形式/ 添加/ 了/ 属性/ 描述/ 后/ 的/ nesC/ 程序/ ,/ 首先/ 经过/ 扩展/ 后/ 的/ nesC/ 编译器/ 分析/ 和/ 源源/ 变换/ ,/ 生成/ 具有/ 等价/ 语义/ 的/ C/ 程序/ ,/ 其中/ ,/ 对/ 所/ 监控/ 的/ 属性/ 的/ 判定/ 被/ 转化成/ C语言/ 中/ 的/ 函数/ ,/ 并/ 在/ 相应/ 的/ 判定/ 位置/ 插入/ 对/ 该/ 函数/ 的/ 调用/ ./ 生成/ 的/ C/ 程序/ 经/ 扩展/ 的/ Open64/ 编译器/ 上/ 的/ 依赖/ 分析/ 后/ 进入/ 自/ 适应/ 迭代/ 流程/ ./ 首次/ 迭代/ 中/ ,/ 根据/ 得到/ 的/ 依赖/ 信息/ ,/ 由/ nesC/ 编译器/ 生成/ 的/ C/ 程序/ 经自/ 适应/ 插桩/ 模块/ 处理/ ,/ 再/ 由/ 源源/ 变换/ ,/ 分别/ 生成/ 用于/ 控制/ 对/ 错误/ 轨迹/ 进行/ 追踪/ 的/ C/ 程序/ Ptrace/ 和/ 包含/ 重/ 放/ 控制/ 的/ C/ 程序/ Preplay/ ./ 前者/ 经/ 交叉/ 编译/ (/ 譬如/ :/ 使用/ msp430/ -/ gcc/ 交叉/ 编译器/ ①/ )/ ,/ 产生/ 可/ 在/ 传感器/ 结点/ 上/ 执行/ 的/ 二进制码/ ,/ 并/ 在/ 执行/ 过程/ 中/ 生成/ 作为/ 重/ 放/ 输入/ 的/ 追踪/ 日志/ ./ 后者/ 则/ 由/ 本地/ 编译器/ 编译/ ,/ 生成/ 可/ 离线/ 执行/ 的/ 二进制码/ ,/ 并/ 在/ 执行/ 过程/ 中/ 读取/ 追踪/ 日志/ ,/ 重现/ 错误/ 轨迹/ ,/ 供/ 用户/ 诊断/ ./ 自/ 适应/ 插桩/ 模块/ 将/ 根据/ 用户/ 提供/ 的/ 反馈/ 信息/ (/ 譬如/ :/ 错误/ 根源/ 所在/ 的/ 范围/ 、/ 定值/ 不/ 符合/ 预期/ 的/ 可疑/ 变量/ 等/ )/ ,/ 指导/ 新一轮/ 迭代/ ,/ 直到/ 发现错误/ 根源/ ./ 理/ ./ 该/ 程序/ 使用/ TinyOS/ -/ 2/ ./ x/ 自带/ 的/ 汇聚/ 树/ 协议/ ①/ http/ :/ // // mspgcc/ ./ sourceforge/ ./ net/ // Page4/ (/ CTP/ )/ ,/ 控制/ 远程/ 传感器/ 结点/ 周期性地/ 向/ 基站/ 发送数据/ ./ 所/ 发送/ 的/ 数据/ 是/ 连续/ 的/ (/ 0/ ~/ 127/ )/ ./ 图/ 2/ 为/ 该/ 收集/ 程序/ 的/ 部分/ 代码/ 片段/ (/ 暂时/ 忽略/ 字母/ N/ 标注/ 的/ 语句/ )/ ./ 程序/ 中/ ,/ 传感器/ 结点/ 在/ 消息/ 发送/ 前/ ,/ 首先/ 检查/ sendBusy/ 标志/ (/ 第/ 17/ 行/ )/ ,/ 只有/ 当/ sendBusy/ 为/ 图/ 2/ 带/ 属性/ 描述/ 的/ nesC/ 程序/ 片段/ 我们/ 向/ 图/ 2/ 所示/ 程序/ 注入/ 错误/ ,/ 注销/ 消息/ 发送/ 之前/ 对/ sendBusy/ 标志/ 位/ 的/ 检查/ (/ 第/ 17/ 行/ )/ ./ 注销/ 上述/ 检查/ 语句/ 后/ ,/ 每当/ 计数器/ Timer/ 到/ 时/ ,/ 新/ 生成/ 的/ 消息/ 就/ 会/ 直接/ 进入/ 发送缓冲区/ ,/ 取代/ 缓冲区/ 中/ 尚未/ 成功/ 发送/ 的/ 消息/ ,/ 从而/ 导致/ 消息/ 丢失/ ./ 当然/ ,/ 如果/ 消息/ 发送/ 频率/ 太低/ ,/ 缓冲区/ 在/ 大多数/ 时间/ 内/ 都/ 是/ 空闲/ 的/ ,/ 那么/ 即使/ 不/ 检查/ sendBusy/ 标志/ ,/ 程序/ 的/ 行为/ 也/ 可能/ 符合/ 预期/ ./ 为此/ ,/ 我们/ 提高/ 消息/ 发送/ 的/ 频率/ ,/ 指定/ 传感器/ 结点/ 每隔/ 50ms/ 向/ 基站/ 发送/ 一条/ 消息/ ./ 为/ 捕获/ 注入/ 的/ 错误/ 对/ 程序/ 行为/ 的/ 影响/ ,/ 首先/ 需要/ 向/ 程序/ 中/ 插入/ 不变/ 属性/ ,/ 监控/ 程序/ 行为/ ./ 对于/ 发送/ 方/ 结点/ 而言/ ,/ 成功/ 发送/ 的/ 数据/ 应当/ 是/ 连续/ 的/ ./ 而/ 基站/ 结点/ 应当/ 能/ 在/ 指定/ 时间/ 内/ (/ 譬如/ ,/ 每隔/ 60ms/ )/ 收到/ 来自/ 所有/ 消息/ 发送/ 结点/ (/ 假定/ 共有/ 10/ 个/ 消息/ 发送/ 结点/ )/ 发出/ 的/ 消息/ ./ 图/ 2/ 中/ 字母/ N/ 标注/ 的/ 语句/ 代表/ 用户/ 添加/ 的/ 属性/ 描述/ 语句/ ./ 属性/ 描述/ 语句/ 分/ 两类/ :/ (/ 1/ )/ 属性/ 监控/ 语句/ ;/ (/ 2/ )/ 辅助/ 描述/ 语句/ ./ 其中/ ,/ 由/ 特殊/ 字符串/ “/ // / @/ ”/ 和/ “/ @/ / // ”/ 标注/ 的/ 语句/ 或/ 函数/ 定义/ 统称/ 属性/ 监控/ 语句/ ,/ 如/ :/ 发送/ 方/ 属性/ 由/ 语句/ assert/ =/ FALSE/ (/ 发送缓冲区/ 空闲/ )/ 时/ ,/ 待/ 发送/ 的/ 消息/ 才能/ 进入/ 发送缓冲区/ ,/ 并/ 将/ sendBusy/ 设为/ TRUE/ (/ 7/ ~/ 10/ 行/ )/ ,/ 缓冲区/ 中/ 的/ 消息/ 成功/ 发送/ 后/ ,/ sendBusy/ 标志/ 复位/ (/ 第/ 14/ 行/ )/ ./ 15/ ./ eventvoidTimer/ ./ fired/ (/ )/ {/ 16/ ./ callLeds/ ./ led2Toggle/ (/ )/ ;/ 17/ ./ if/ (/ !/ sendBusy/ )/ 18/ ./ sendMessage/ (/ )/ ;/ 19/ ./ eventvoidRadioControl/ ./ startDone/ (/ …/ )/ {/ NcallAssertTimer/ ./ startPeriodic/ (/ 60/ )/ ;/ 20/ ./ eventmessage/ _/ t/ / Receive/ ./ receiveNcounter/ ++/ ;/ N/ // / @/ assertfunc/ / @/ // NeventvoidAssertTimer/ ./ fired/ (/ )/ {/ Nif/ (/ counter/ </ 10/ )/ Nfprintf/ (/ “/ EasyCollectionErr/ \/ n/ ”/ )/ ;/ NelseNcounter/ =/ 0/ ;/ N/ }/ (/ old/ _/ data/ +/ 1/ =/ =/ msg/ -/ >/ data/ )/ 监控/ ,/ 基站/ 属性/ 的/ 监控/ 则/ 由/ 函数/ AssertTimer/ ./ fired/ 实现/ ./ 属性/ 监控/ 语句/ 经/ 扩展/ 的/ nesC/ 编译器/ 源源/ 转换/ 后/ ,/ 将/ 生成/ 作为/ 依赖/ 分析/ 模块/ 的/ 初始/ 输入/ 的/ 属性/ 函数/ (/ FInv/ )/ ./ 为/ 维护/ 属性/ 监控/ 语句/ 中/ 新/ 出现/ 的/ 变量/ ,/ 如/ :/ old/ _/ data/ 、/ counter/ ,/ 用户/ 还/ 需/ 额外/ 添加/ 用于/ 初始化/ 或/ 更新/ 这些/ 变量/ 的/ 辅助/ 描述/ 语句/ ./ 添加/ 属性/ 描述/ 后/ 的/ 程序/ 经/ nesC/ 编译器/ 源源/ 变换/ 后/ ,/ 将/ 生成/ 具有/ 等价/ 语义/ 的/ C/ 程序/ ,/ 作为/ 后续/ 分析/ 的/ 输入/ ./ 4ADA/ 的/ 设计/ 与/ 实现/ ADA/ 的/ 基本思路/ 是/ 利用/ 确定性/ 重/ 放/ 技术/ 辅助/ 程序员/ 诊断/ TinyOS/ 程序/ 错误/ ./ 需要/ 解决/ 的/ 关键问题/ 是/ :/ (/ 1/ )/ 如何/ 保证/ 重放/ 的/ 确定性/ ,/ 包括/ 确定/ 重放/ 的/ (/ 2/ )/ 如何/ 降低/ 错误/ 追踪/ 和/ 重放/ 的/ 代价/ 以/ 满足/ 资/ 起点/ 和/ 需要/ 追踪/ 不确定性/ 行为/ ;/ Page5/ 源/ 的/ 限制/ ./ 对于/ 问题/ 1/ ,/ 由于/ 无线/ 传感器/ 网上/ 运行/ 的/ Tiny/ -/ OS/ 程序/ 往往/ 是/ 无穷/ 迭代/ 程序/ ,/ 并/ 通过/ 中断/ 服务/ 函数/ 异步/ 地/ 完成/ 系统/ 功能/ ./ 这/ 就/ 意味着/ :/ (/ 1/ )/ 需要/ 追踪/ 外部/ 输入/ 和/ 中断/ 响应/ 等/ 不确定性/ 行为/ ,/ 以/ 支持/ 确定性/ 的/ 重放/ ;/ (/ 2/ )/ 由于/ 对/ 无穷/ 迭代/ 循环/ 的/ 追踪/ 日志/ 可能/ 会/ 无限/ 增长/ ,/ 所以/ 重/ 放/ 完整/ 的/ 无穷/ 迭代/ 并/ 不合理/ ,/ 需要/ 选择/ 一个/ 合理/ 的/ 重放/ 起点/ ,/ 即/ 检查点/ ./ 对于/ 问题/ (/ 2/ )/ ,/ 为/ 使/ 基于/ 确定性/ 重放/ 的/ 离线/ 调试/ 技术/ 能够/ 沿用/ 在/ 资源/ 极端/ 受限/ 的/ 无线/ 传感器/ 网络/ 程序/ 的/ 错误诊断/ 中/ ,/ 本文/ 采用/ 以/ 依赖/ 关系/ 分析/ 为/ 基础/ 的/ 自/ 适应/ 迭代/ 方法/ ,/ 降低/ 错误/ 追踪/ 和/ 重放/ 的/ 代价/ ./ 同时/ ,/ 通过/ 剔除/ 与/ 监控/ 的/ 属性/ 无关/ 的/ 代码/ ,/ 减少/ 用户/ 在/ 诊断/ 错误/ 时/ 需要/ 关注/ 的/ 程序/ 轨迹/ 的/ 规模/ ,/ 减轻/ 用户/ 负担/ ./ 用户/ 既/ 可以/ 从/ 所/ 监控/ 的/ 属性/ 的/ 最近/ 一次/ 被/ 违反/ 的/ 位置/ 出发/ ,/ 根据/ 引用/ -/ 定值/ 关系/ 以及/ 关键/ 位置/ 上/ 的/ 程序/ 状态/ ,/ 从重/ 放/ 轨迹/ 中/ 找寻/ 错误/ 定值/ 的/ 来源/ ,/ 也/ 可以/ 将/ 重放/ 轨迹/ 作为/ 调试器/ 的/ 输入/ ,/ 进而/ 使用/ 设置/ 断点/ 等/ 调试/ 方法/ 定位/ 错误/ 根源/ ./ 4.1/ 确定性/ 重放/ 4.1/ ./ 1/ 不确定性/ 行为/ 追踪/ 为了/ 确定性/ 地/ 重放/ TinyOS/ 程序/ 的/ 错误/ 轨迹/ ,/ 必须/ 对/ 与/ 所/ 监控/ 的/ 属性/ 相关/ 的/ 不确定性/ 程序/ 行为/ 进行/ 追踪/ ,/ 追踪/ 对象/ 包括/ :/ (/ 1/ )/ 非/ 确定性/ 输入/ ,/ (/ 2/ )/ 中断/ 响应/ 位置/ ./ 同时/ ,/ 为了/ 尽可能/ 地/ 控制/ 追踪/ 开销/ ,/ 我们/ 仅/ 对/ 与/ 所/ 监控/ 的/ 属性/ 相关/ 的/ 不确定性/ 程序/ 行为/ 进行/ 追踪/ ./ 本节/ 具体/ 讨论/ 确定性/ 重/ 放/ 方法/ (/ 对/ 本文/ 重/ 放/ 策略/ 的/ 证明/ 详见/ 附录/ 2/ 的/ 确定性/ 重/ 放/ 证明/ )/ ,/ 分析/ 与/ 属性/ 相关/ 的/ 程序/ 行为/ 的/ 方法/ 详见/ 第/ 4.2/ 节/ ./ 由于/ 本文/ 采用/ 的/ 是/ 多/ 结点/ 独立/ 追踪/ 、/ 并行/ 重放/ 的/ 方法/ ,/ 故而/ 从/ 其它/ 结点/ 接收/ 到/ 的/ 信息/ 对于/ 接收/ 方/ 结点/ 而言/ 也/ 属于/ 非/ 确定性/ 输入/ ./ 非/ 确定性/ 输入/ 包括/ 由/ 传感器/ 收集/ 到/ 的/ 数据/ 以及/ 结点/ 间/ 通过/ 无线通信/ 收发/ 的/ 数据/ ./ 因为/ 上述/ 数据/ 的/ 收发/ 均/ 由/ TinyOS/ 提供/ 的/ 系统/ 库函数/ 完成/ ,/ 我们/ 仅/ 需/ 追踪/ 消息/ 收发/ 函数/ 中/ message/ _/ t/ 类型/ 的/ 参数/ ,/ 即可/ 支持/ 对非/ 确定/ 输入/ 的/ 重放/ ./ 在/ 此基础/ 上/ ,/ 下文/ 仅/ 考虑/ 程序/ 中/ 的/ 不确定性/ 行为/ 是/ 中断/ 的/ 确定性/ 重/ 放/ 方法/ ./ 当前/ 知名/ 的/ 确定性/ 重/ 放/ 工具/ 在/ 处理/ 中断/ 时/ 大多/ 采用/ 追踪/ 中断/ 响应/ 副作用/ 的/ 策略/ ,/ 在/ 重放时/ 用/ 记录/ 的/ 副作用/ 替代/ 实际/ 应该/ 响应/ 的/ 中断/ ./ 然而/ 该/ 处理/ 策略/ 不足以/ 支持/ 错误诊断/ ,/ 特别/ 是/ 对/ 通过/ 中断/ 响应/ 为/ 主要/ 功能/ 实现/ 的/ TinyOS/ 程序/ 而言/ ,/ 中断/ 处理函数/ 的/ 内部/ 执行/ 行为/ 很/ 可能/ 是/ 错误/ 传播/ 路径/ 的/ 重要/ 组成部分/ ,/ 不/ 重放/ 这些/ 行为/ 就/ 不能/ 有效/ 地/ 进行/ 诊断/ ./ 针对/ 上述/ 问题/ ,/ 本文/ 提出/ 了/ 一种/ 对/ 中断/ 响应/ 位置/ 的/ 追踪/ // 重/ 放/ 策略/ ,/ 以/ 确保/ 对/ TinyOS/ 程序/ 的/ 确定性/ 重放/ ./ TinyOS/ 程序/ 可/ 分为/ 同步/ 代码/ 和/ 异步/ 代码/ 两/ 部分/ ./ 其中/ ,/ 异步/ 代码/ 只能/ 通过/ 中断/ 响应/ 被/ 执行/ ./ 中断/ 响应函数/ 对/ 其/ 外部/ 的/ 同步/ 代码/ 和/ 异步/ 代码/ 的/ 影响/ 包含/ 两个/ 方面/ :/ (/ 1/ )/ 修改/ 外部/ 代码/ 中/ 可能/ 使用/ 的/ 全局变量/ ,/ (/ 2/ )/ 向/ 任务/ 队列/ 中/ 添加/ 新/ 任务/ ./ 如果/ 任务/ 队列/ 是/ 先入/ 先出/ (/ FIFO/ )/ 队列/ ,/ 则/ 一旦/ 确定/ 了/ 中断/ 响应/ 的/ 位置/ 和/ 顺序/ ,/ 即可/ 保证/ 重放时/ 的/ 任务/ 队列/ 与/ 追踪/ 程序执行/ 过程/ 中/ 的/ 任务/ 队列/ 一致/ ;/ 否则/ ,/ 也/ 可以/ 通过/ 追踪/ 任务/ 派生/ 函数/ 复现/ 任务/ 队列/ ./ 给定/ 中断/ 处理函数/ Intri/ 、/ Intrj/ 和/ 函数/ F/ (/ F/ 也/ 可以/ 是/ 中断/ 处理函数/ )/ ,/ 将/ Intri/ 、/ Intrj/ 和/ F/ 三者/ 之间/ 可能/ 共享/ 的/ 全局/ 量/ 集合/ 记作/ G/ ./ 对/ 任意/ f/ ,/ g/ ∈/ G/ 以及/ F/ 的/ 执行/ 语句/ 序列/ S/ =/ {/ s1/ ,/ s2/ ,/ …/ ,/ sn/ -/ 1/ ,/ sn/ }/ ,/ 如果/ S/ 满足/ :/ s1/ 是/ 对/ f/ 的/ 读/ // 写/ 操作/ ,/ sn/ 是/ 对/ g/ 的/ 读/ // 写/ 操作/ ,/ s2/ ,/ …/ ,/ sn/ -/ 1/ 均/ 没有/ 对/ G/ 中/ 变量/ 的/ 读/ // 写/ 操作/ ,/ 则/ 在/ 开区间/ (/ s1/ ,/ sn/ )/ 中/ 任意/ 位置/ 分别/ 执行/ 一次/ Intri/ 和/ Intrj/ ,/ 且/ Intri/ 和/ Intrj/ 的/ 前后/ 顺序/ 固定/ ,/ 在/ sn/ 执行/ 前/ G/ 中/ 变量/ 的/ 值/ 都/ 是/ 相同/ 的/ ./ 基于/ 以上/ 观察/ ,/ 只要/ 能够/ 记录/ 序列/ S/ 的/ 开始/ 和/ 终止/ 位置/ 以及/ 该/ 区间/ 内/ 中断/ 的/ 响应/ 顺序/ ,/ 就/ 能/ 重放/ 函数/ F/ 中/ 的/ 语句/ 序列/ S/ 及/ sn/ 处/ 对/ g/ 的/ 读/ // 写/ 操作/ 的/ 值/ ./ 基于/ 上述/ 分析/ ,/ 我们/ 采用/ 记录/ 全局/ 量/ 操作数/ 目的/ 方法/ 追踪/ 中断/ 响应/ 位置/ ./ 该/ 方案/ 维护/ 一个/ 全局/ 量/ 操作/ 计数器/ C/ ,/ C/ 在/ 每个/ 函数/ (/ 包括/ 中断/ 处理函数/ )/ 的/ 每个/ 执行/ 实例/ 的/ 入口处/ 被/ 保护/ 并/ 重置/ ,/ 出口处/ 恢复/ ;/ 每/ 执行/ 一个/ 全局变量/ 读/ // 写/ 操作/ ,/ C/ 的/ 值加/ 1/ ./ 这样/ ,/ 我们/ 可以/ 根据/ C/ 的/ 值/ ,/ 将/ 任意/ 函数/ (/ 包含/ 中断/ 处理函数/ )/ 的/ 任意/ 执行/ 实例/ 中除/ 全局变量/ 读/ // 写/ 操作/ 之外/ 的/ 部分/ 划分/ 成/ 若干个/ 互不/ 重叠/ 的/ 执行/ 区段/ ,/ 其中/ 每个/ 执行/ 区段/ 都/ 不/ 包含/ 显式/ 的/ 全局变量/ 操作/ (/ 通过/ 响应/ 中断/ 或/ 函数调用/ 修改/ // 使用/ 的/ 全局变量/ 除外/ )/ ,/ 如图/ 3/ 所示/ ./ 由/ 函数/ 名/ (/ F/ )/ 、/ 该/ 函数/ 的/ 某次/ 执行/ 实例/ (/ E/ )/ 以及/ 全局/ 量/ 计数器/ 的/ 值/ (/ C/ )/ 构成/ 的/ 三元组/ 可以/ 唯一/ 确定/ 一个/ 区段/ ./ 对/ 中断/ 响应/ 顺序/ 的/ 追踪/ 是/ 通过/ 在/ 追踪/ 日志/ 中/ 顺序/ 记录/ 各/ 执行/ 区段/ 中/ 被/ 响应/ 的/ 中断/ 对应/ 的/ 处理函数/ 来/ 实现/ 的/ ;/ 重放时/ ,/ 当/ 执行/ 到/ 对应/ 区段/ 时/ 可/ 依次/ 调用/ 所/ 记录/ 的/ 中断/ 处理函数/ ,/ 复现/ 程序/ 的/ 执行/ ./ 该/ 方案/ 可以/ 处理/ 带/ 中断/ 嵌套/ 的/ 程序/ ./ Page6/ 图/ 3/ 全局/ 量/ 计数器/ 方案/ 示例/ 4.1/ ./ 2/ 检查点/ 设置/ 受到/ 传感器/ 结点/ 上/ 存储/ 和/ 通信/ 资源/ 的/ 限制/ ,/ 能/ 追踪/ 并重/ 放/ 的/ 往往/ 只是/ 错误/ 发生/ 之前/ 的/ 一部分/ 执行/ 轨迹/ ./ 为/ 保证/ 机制/ 的/ 正常/ 运转/ ,/ ADA/ 在/ 追踪/ 不确定性/ 行为/ 的/ 同时/ ,/ 也/ 在/ 程序/ 中/ 关键/ 位置/ 插入/ 检查点/ ./ 检查点/ 既/ 是/ 重放/ 的/ 候选/ 起始/ 位置/ ,/ 也/ 是/ 辅助/ 用户/ 诊断/ 错误/ 根源/ 的/ 依据/ 之一/ ./ 因此/ ,/ 所/ 选择/ 的/ 检查点/ 应当/ 能够/ 代表/ 程序/ 中/ 一个/ 相对/ 独立/ 且/ 完整/ 的/ 部分/ 的/ 初始/ 或/ 终结状态/ ,/ 譬如/ ,/ 最/ 外层/ 循环/ 的/ 迭代/ 入口/ 、/ 函数/ 入口/ 、/ 函数/ 出口/ 等/ ./ 最/ 外层/ 循环/ 的/ 迭代/ 入口/ 检查点/ 记录/ 从/ 该/ 位置/ 到/ 属性/ 违反/ 点/ 之间/ 可能/ 与/ 属性/ 相关/ 且/ 向前/ 暴露/ 的/ 变量/ ./ 函数/ 入口/ 检查点/ 的/ 状态/ ,/ 包含/ 了/ 本/ 函数/ 所/ 使用/ 的/ 且/ 可能/ 影响/ 所/ 监控/ 的/ 属性/ 的/ 参数/ 和/ 全局/ 量/ 的/ 值/ ;/ 出口/ 检查点/ 的/ 状态/ ,/ 包含/ 了/ 本/ 函数/ 所/ 修改/ 的/ 且/ 可能/ 影响/ 所/ 监控/ 的/ 属性/ 的/ 参数/ 和/ 全局/ 量/ 的/ 值/ ./ 用户/ 通过/ 分析/ 上述/ 状态/ ,/ 可以/ 初步/ 判定/ 函数/ 的/ 执行/ 行为/ 是否/ 符合/ 预期/ ,/ 中断/ 响应/ 是否/ 对/ 当前/ 函数/ 造成/ 了/ 非/ 预期/ 影响/ 等/ ./ 此外/ ,/ 检查点/ 的/ 选择/ 也/ 使/ 重放/ 的/ 起始/ 点/ 和/ 范围/ 更加/ 灵活/ ,/ 进而/ 更好/ 地/ 辅助/ 用户/ 调试/ 和/ 对/ 错误/ 根源/ 的/ 诊断/ ./ 检查点/ 的/ 设置/ 还应/ 结合/ 传感器/ 结点/ 上/ 存储资源/ 的/ 限制/ ,/ 设置/ 依据/ 将/ 在/ 4.2/ 节/ 介绍/ ./ 4.1/ ./ 3/ 代码/ 示例/ 图/ 2/ 所示/ 的/ 程序/ 经/ nesC/ 编译器/ 源源/ 变换/ 后/ ,/ 生成/ 的/ C/ 程序/ 与/ nesC/ 程序/ 中/ 命名/ 的/ 映射/ 关系/ 如下/ :/ nesC/ 程序/ 中/ 模块/ M/ 中/ 的/ 函数/ F/ 、/ 变量/ X/ 、/ 事件/ 或/ 命令/ E/ 分别/ 对应/ C/ 程序/ 中/ M/ $/ F/ 、/ M/ $/ X/ 和/ M/ $/ E/ ,/ 模块/ M/ 中/ 接口/ I/ 的/ 事件/ 或/ 命令/ E/ 被/ 映射/ 成/ M/ $/ I/ $/ E/ ,/ 依此类推/ ./ 譬如/ ,/ C/ 函数/ EasyCollectionC/ $/ AssertTimer/ $/ fired/ 对应/ EasyCollectionC/ 模块/ 的/ AssertTimer/ ./ fired/ 事件/ ./ C/ 程序/ 经/ 依赖/ 分析/ 和/ 自/ 适应/ 插桩/ 模块/ 的/ 依次/ 处理/ ,/ 分别/ 生成/ 包含/ 追踪/ 和/ 重放/ 控制代码/ 的/ C/ 程序/ ,/ 程序/ 片段/ 分别/ 如图/ 4/ 、/ 图/ 5/ 所示/ ./ 图中/ 加粗/ 的/ 语句/ 为/ 插/ 桩/ 库函数/ 的/ 调用/ 语句/ (/ 对/ 插/ 桩/ 库函数/ 的/ 介绍/ 详见/ 附录/ 1/ 中/ 插/ 桩/ 库/ 介绍/ )/ ./ 图中/ 加粗/ 语句/ 是/ 对/ 完成/ 追踪/ 或/ 重放/ 功能/ 的/ 插/ 桩/ 库函数/ 的/ 调用/ ./ 图中/ 的/ 虚框/ 代表/ 追踪/ 和/ 重放/ 过程/ 中/ 的/ 不/ 安全/ 因素/ ,/ 处理/ 方案/ 留待/ 4.3/ 节/ 讨论/ ./ / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / }/ 4.2/ 依赖/ 分析/ 与/ 自/ 适应/ 迭代/ 追踪/ 和/ 重放/ 对/ 存储/ 和/ 通信/ 的/ 压力/ 来自/ 两个/ 方面/ :/ (/ 1/ )/ 向/ 源程序/ 中/ 插入/ 用于/ 追踪/ 的/ 代码/ ,/ 可能/ 造成/ 可/ 执行/ 码/ 的/ 规模/ 超过/ 传感器/ 结点/ 的/ 代码/ 存储/ 上限/ ;/ (/ 2/ )/ 追踪/ 过程/ 中/ 记录/ 检查点/ 状态/ 和/ 不确定性/ 行为/ 的/ Page7/ / / / / / / / / / / / / / / / / / / / / / / / / / / CheckFunc/ (/ …/ )/ ;/ // // 函数/ 实例/ 检查/ 日志/ 可能/ 远大于/ 传感器/ 结点/ 上/ 的/ RAM/ 空间/ ,/ 需要/ 频繁/ 地/ 将/ RAM/ 中/ 的/ 数据/ 写入/ 额外/ 存储空间/ ,/ 并/ 最终/ 传向/ 基站/ ./ 此外/ ,/ 插桩/ 代码/ 的/ 执行/ 以及/ 频繁/ 的/ 日志/ 数据/ 写入/ 、/ 传输/ 都/ 可能/ 提高/ 程序/ 的/ 执行/ 时间/ 和/ 系统/ 的/ 功耗/ ./ 为/ 解决/ 上述/ 问题/ ,/ 本文/ 借助/ 依赖/ 关系/ 分析/ ,/ 图/ 6/ 函数/ 级/ 依赖图/ (/ 部分/ )/ 剔除/ 对/ 与/ 所/ 监控/ 的/ 属性/ 之间/ 不/ 存在/ 直接/ 或/ 传递/ 依赖/ 关系/ 的/ 程序/ 行为/ 的/ 追踪/ ,/ 并/ 采用/ 自/ 适应/ 的/ 插/ 桩/ 策略/ 限制/ 代码/ 规模/ ,/ 以/ 缓解/ 由此/ 引发/ 的/ 存储/ 和/ 通信/ 压力/ ./ 4.2/ ./ 1/ 函数/ 级/ 依赖图/ 为/ 实现/ 对/ 需要/ 追踪/ 的/ 信息/ 的/ 自/ 适应/ 选择/ ,/ 本/ 节/ 首先/ 引入/ 一种/ 新/ 的/ 依赖图/ 表示/ 方法/ :/ 函数/ 级/ 依赖图/ ./ 如前所述/ ,/ 程序/ 语句/ 之间/ 的/ 依赖/ 关系/ 可以/ 分为/ 数据/ 依赖/ 和/ 控制/ 依赖/ 两类/ ,/ 且/ 程序/ 内部/ 的/ 依赖/ 关系/ 可以/ 表示/ 成以/ 程序/ 语句/ 为/ 结点/ ,/ 依赖/ 关系/ 为边/ 的/ 依赖图/ 的/ 形式/ ./ 如果/ 依赖图/ 上/ 存在/ 一条/ 从/ 结点/ u/ 到/ 结点/ v/ 的/ 依赖边/ ,/ 则/ 结点/ v/ 直接/ 依赖于/ 节点/ u/ ;/ 如果/ 结点/ u/ 又/ 直接/ 依赖于/ 结点/ w/ ,/ 则/ 结点/ v/ 传递/ 依赖于/ 结点/ w/ ./ 传递/ 依赖/ 关系/ 反映/ 了/ 程序/ 中/ 某个/ 子/ 部分/ 的/ 输入/ 与/ 输出/ 之间/ 的/ 关联/ ./ 如果/ 将/ 系统/ 依赖图/ 上/ 的/ 过程/ 内/ 数据/ 和/ 控制/ 依赖边/ ,/ 用/ 过程/ 间/ 结点/ (/ 函数调用/ 点处/ 的/ 实参/ 结点/ 、/ 函数/ 入口/ 出口处/ 的/ 形参/ 结点/ 以及/ 函数/ 对外/ 暴露/ 的/ 副作用/ 结点/ )/ 之间/ 的/ 传递/ 依赖边/ 代替/ ,/ 则/ 程序/ 的/ 系统/ 依赖图/ 可以/ 塌缩/ 成以/ 函数/ 为/ 结点/ 的/ 函数/ 级/ 依赖图/ ./ 函数/ 级/ 依赖图/ 仅/ 刻画/ 各/ 函数/ 对外/ 暴露/ 的/ 依赖/ 关系/ ,/ 其所/ 包含/ 的/ 信息/ 既/ 指明/ 了/ 检查点/ 需要/ 追踪/ 的/ 内容/ ,/ 又/ 对/ 纷繁复杂/ 的/ 语句/ 级/ 依赖/ 进行/ 了/ 整合/ 与/ 压缩/ ,/ 为/ 后续/ 分析/ 提供/ 了/ 便利/ ./ 以图/ 2/ 所示/ 的/ 程序/ 为例/ ,/ 翻译/ 生成/ 的/ C/ 程序/ ,/ 经/ 依赖/ 分析/ 生成/ 的/ 函数/ 级/ 依赖图/ 如图/ 6/ 所示/ ./ 图中/ ,/ Page8FInv/ 代表/ 所/ 监控/ 的/ 属性/ 对应/ 的/ 函数/ ,/ 下文/ 简称/ 属性/ 函数/ ;/ 实线/ 有/ 向/ 边/ 代表/ 传递/ 依赖/ ;/ 虚线/ 有/ 向/ 边/ 代表/ 函数/ 过程/ 间/ 映射/ 关系/ ,/ 包括/ :/ 从/ 函数调用/ 点到/ 被/ 调用函数/ 入口/ 的/ 映射/ 关系/ ,/ 形参/ 和/ 实参/ 之间/ 的/ 映射/ 关系/ ;/ 加粗/ 的/ 实线/ 有/ 向/ 边/ 代表/ 函数/ 的/ 形式参数/ ,/ 包括/ 输入/ 形参/ 、/ 输出/ 形参/ 和/ 返回值/ ;/ 虚点/ 有/ 向/ 边/ 则/ 代表/ 函数调用/ ./ 图中/ 从/ 函数/ VirtualizeTimerC/ $/ 0/ $/ TimerFrom/ $/ getNow/ 的/ 返回值/ 结点/ return/ _/ val/ 到/ 函数调用/ 结点/ CallTransformCounter/ $/ 0/ $/ Counter/ $/ get/ 的/ 实线/ 有/ 向/ 边上/ 的/ “/ / ”/ 符号/ ,/ 代表/ 经/ 内联/ 优化/ 后/ 的/ 函数/ 级/ 依赖边/ ./ 虽然/ ,/ 该/ 程序/ 的/ 函数调用/ 图上/ ,/ 从/ Virtuali/ -/ zeTimerC/ $/ 0/ $/ TimerFrom/ $/ getNow/ 到/ Transform/ -/ Counter/ $/ 0/ $/ Counter/ $/ get/ 的/ 函数调用/ 链/ 的/ 实际/ 长度/ 为/ 4/ ,/ 但/ 由于/ 调用/ 链上/ 的/ 每个/ 函数/ 都/ 只/ 包含/ 一条/ 函数调用/ 语句/ ,/ 且/ 该/ 函数/ 的/ 返回值/ 就是/ 这个/ 函数调用/ 语句/ 的/ 返回值/ ;/ 即/ :/ 调用/ 链上/ 除/ TransformCounter/ $/ 0/ $/ Counter/ $/ get/ 之外/ 的/ 其它/ 3/ 个/ 函数/ 都/ 相当于/ 包装/ 函数/ ,/ 故/ 在/ 构建/ 函数/ 级/ 依赖图/ 时/ 可/ 不予考虑/ ./ 实现/ 过程/ 中/ ,/ 待/ 监控/ 的/ 属性/ ,/ 经过/ nesC/ 编译器/ 的/ 源源/ 翻译/ 后/ ,/ 转化成/ C语言/ 函数/ 定义/ 的/ 形式/ (/ FInv/ )/ ./ 依赖/ 分析/ 模块/ 首先/ 为/ 同步/ 代码/ 构造/ 系统/ 依赖图/ ,/ 并/ 在/ 其/ 上/ 对/ 由/ FInv/ 的/ 调用/ 位置/ 以及/ 其中/ 使用/ 的/ 全局变量/ 构成/ 的/ 二元/ 组为/ 切片/ 标准/ 对/ 同步/ 代码/ 切片/ ,/ 切片/ 结果/ 表示/ 成/ 系统/ 依赖图/ 的/ 子/ 图/ 的/ 形式/ ;/ 然后/ ,/ 将/ 上述/ 子图/ 塌缩/ 成/ 函数/ 级/ 依赖图/ 的/ 形式/ ,/ 其中/ ,/ 各个/ 函数/ 的/ 输入/ 、/ 输出/ 形参/ 、/ 对外/ 暴露/ 的/ 变量/ 以及/ 返回值/ ,/ 就是/ 在/ 该/ 位置/ 设置/ 检查点/ 时/ 需要/ 追踪/ 的/ 内容/ ./ 由于/ 静态/ 无法/ 确定/ 中断/ 的/ 响应/ 位置/ ,/ 故而/ 只能/ 保守/ 地/ 认为/ 中断/ 可能/ 在/ 程序/ 中/ 的/ 任意/ 非/ 临界/ 区域/ 内/ 被/ 响应/ ./ 实现/ 时/ ,/ 如果/ 某/ 中断/ 服务/ 函数/ 的/ 副作用/ 与/ 选定/ 的/ 追踪/ 区域/ 内/ 可能/ 访问/ 到/ 的/ 全局变量/ 之间/ 存在/ 交集/ ,/ 则/ 该/ 中断/ 服务/ 函数/ 的/ 行为/ 也/ 必须/ 包含/ 在/ 追踪/ 范围/ 内/ ./ 静态/ 依赖/ 分析/ 无法/ 确定/ 的/ 另/ 一个/ 问题/ 是/ 通信/ 匹配/ ./ 目前/ ,/ 依赖/ 分析/ 模块/ 只能/ 根据/ 消息/ 长度/ 和/ 数据类型/ 判断/ 通信/ 匹配/ 关系/ ./ 此外/ ,/ 虽然/ 本文/ 采用/ 的/ 是/ 各/ 传感器/ 结点/ 独立/ 记录/ 追踪/ 日志/ 的/ 方法/ ,/ 但/ 由于/ 追踪/ 日志/ 中/ 包含/ 了/ 可能/ 影响/ 所/ 监控/ 的/ 属性/ 的/ 外部/ 输入/ ,/ 故而/ 用户/ 诊断/ 时/ 还/ 可以/ 通过/ 分析/ 消息/ 头/ ,/ 进一步/ 判断/ 通信/ 操作/ 之间/ 的/ 匹配/ 关系/ ,/ 以/ 确定/ 消息/ 的/ 来源/ ./ 4.2/ ./ 2/ 依赖/ 属性/ 在/ 函数/ 级/ 依赖图/ 的/ 基础/ 上/ ,/ 我们/ 引入/ 两个/ 新/ 的/ 属性/ :/ 依赖/ 的/ 层次/ 和/ 密度/ ,/ 作为/ 依赖/ 分析/ 时/ 选择/ 检查点/ 以及/ 限制/ 追踪/ 、/ 重放/ 的/ 范围/ 和/ 粒度/ 的/ 依据/ ./ 设/ 属性/ 监控/ 函数/ 结点/ FInv/ 为/ 基准/ 层次/ (/ 0/ 层/ )/ ,/ 若/ 将/ 函数/ 级/ 依赖图/ 上/ 任意/ 结点/ v/ 所在/ 的/ 依赖/ 层次/ ,/ 定义/ 为/ 从/ 该/ 结点/ 到/ FInv/ 结点/ 之间/ 的/ 所有/ 路径/ 上/ 函数调用/ 边/ 的/ 数目/ 的/ 最小值/ ,/ 可得/ 图/ 6/ 中/ 部分/ 结点/ 所在/ 的/ 依赖/ 层次/ 如下/ :/ 结点/ EntryVirtualizeTimerC/ $/ 0/ $/ fireTimers/ 所在/ 的/ 依赖/ 层次/ 为/ 2/ ,/ 结点/ EntryVirtu/ -/ alizeTimerC/ $/ 0/ $/ updateFromTimer/ $/ runTask/ 以及/ 结点/ EntryVirtualizeTimer/ $/ 0/ $/ TimersFrom/ $/ getNow/ 所在/ 的/ 依赖/ 层次/ 均/ 为/ 3/ ./ 上述/ 依赖/ 层次/ 定义/ 的/ 缺陷/ 在于/ :/ 无法/ 区分/ 程序/ 的/ 函数调用/ 图上/ 来自/ 父亲/ 结点/ 和/ 兄弟/ 结点/ 的/ 依赖/ 关系/ ./ 以图/ 6/ 中带/ 边框/ 的/ VirtualizeTimerC/ $/ 0/ $/ fireTimers/ 函数调用/ 结点/ 为例/ ,/ 该/ 函数/ 的/ 外部/ 依赖/ 关系/ 可/ 分为/ 两类/ :/ (/ 1/ )/ 父子/ 依赖/ ./ 调用者/ 函数/ VirtualizeTimerC/ $/ 0/ $/ updateFromTimer/ $/ runTask/ 中/ 的/ 局部变量/ 以及/ 所/ 传递/ 的/ 全局变量/ 决定/ 了/ VirtualizeTimerC/ $/ 0/ $/ fireTimers/ 是否/ 被/ 调用/ ;/ (/ 2/ )/ 兄弟/ 依赖/ ./ 输入/ 参数/ now/ 的/ 值/ 取决于/ VirtualizeTimerC/ $/ 0/ $/ fireTimers/ 在/ 调用/ 图上/ 的/ 兄弟/ 函数/ VirtualizeTimer/ $/ 0/ $/ TimersFrom/ $/ getNow/ 的/ 返回值/ ./ 当/ 存储资源/ 受限/ 时/ ,/ 除了/ 限定/ 追踪/ 范围/ 外/ ,/ 还/ 必须/ 对/ 不同/ 类型/ 的/ 依赖/ 在/ 追踪/ 粒度/ 上/ 进行/ 取舍/ ,/ 譬如/ ,/ 优先/ 追踪/ 父子/ 依赖/ ,/ 并/ 由/ 用户/ 依据/ 检查点/ 状态/ 和/ 重放/ 轨迹/ ,/ 逐步/ 缩小/ 错误/ 根源/ 所在/ 的/ 范围/ ,/ 并/ 逐步/ 精化/ 对此/ 范围/ 内/ 兄弟/ 依赖/ 的/ 追踪/ ,/ 直至/ 发现错误/ 根源/ ./ 为此/ ,/ 我们/ 对/ 依赖/ 层次/ 的/ 定义/ 进行/ 修订/ ,/ 用主/ 层次/ 表示/ 父子/ 依赖/ 关系/ ,/ 用/ 副/ 层次/ 表示/ 兄弟/ 依赖/ ,/ 称为/ 一级/ 副/ 层次/ ,/ 一级/ 副/ 层次/ 又/ 可/ 分为/ 若干/ 二级/ 副/ 层次/ ,/ 依此类推/ ./ 层次/ 间/ 的/ 分界线/ 将/ 作为/ 候选/ 的/ 追踪/ 检查点/ 和/ 重放/ 起始/ 点/ ./ 根据/ 修订/ 后/ 的/ 依赖/ 层次/ 定义/ ,/ 图/ 6/ 中/ 的/ 加粗/ 水平线/ 代表/ 依赖/ 主/ 层次/ 之间/ 的/ 分界线/ ,/ 除/ 0/ 层外/ ,/ 每/ 两条/ 分界线/ 之间/ 代表/ 一个/ 主/ 层次/ ./ 主/ 层次/ 的/ 编号/ 为/ 该主/ 层次/ 与/ 基准/ 层次/ 之间/ 包含/ 的/ 主/ 层次/ 的/ 数目/ 加/ 1/ ./ 根据/ 新/ 定义/ ,/ 结点/ EntryVirtualizeTimerC/ $/ 0/ $/ fireTimers/ 位于/ 编号/ 为/ 2/ 的/ 主/ 层次/ 上/ ,/ 简称/ 第/ 2/ 主层/ ;/ 结点/ EntryVirtualizeTimerC/ $/ 0/ $/ updateFromTimer/ $/ run/ -/ Task/ 位于/ 编号/ 为/ 3/ 的/ 主/ 层次/ 上/ ,/ 简称/ 第/ 3/ 主层/ ;/ 结点/ EntryVirtualizeTimer/ $/ 0/ $/ TimersFrom/ $/ getNow/ 则/ 位于/ 第/ 3/ 主层/ 的/ 一级/ 副/ 层/ 的/ 第/ 1/ 层上/ ,/ 记作/ 3/ -/ 1/ 层/ ,/ 代表/ 该/ 结点/ 与/ 属性/ 函数/ 之间/ 既有/ 父子/ 依赖/ 关系/ ,/ Page9/ 其中/ ,/ 插桩/ 选择/ 规则/ 指导/ 插桩/ 位置/ 的/ 选择/ 顺序/ ,/ 调整/ 规则/ ./ 包括/ 3/ 条子/ 规则/ :/ MR/ )/ ;/ HR/ )/ ;/ LR/ )/ ./ 括/ 两条/ 子/ 规则/ :/ (/ 1/ )/ 主/ 层次/ 优先/ 规则/ (/ Main/ -/ level/ -/ firstRule/ ,/ (/ 2/ )/ 高密度/ 优先/ 规则/ (/ High/ -/ density/ -/ firstRule/ ,/ (/ 3/ )/ 低层次/ 优先/ 规则/ (/ Low/ -/ level/ -/ firstRule/ ,/ 插桩/ 调整/ 规则/ 根据/ 用户/ 反馈/ 调整/ 插桩/ 位置/ ,/ 包/ 又/ 有/ 兄弟/ 依赖/ 关系/ ./ 同理/ ,/ 结点/ EntryTransform/ -/ CounterC/ $/ 0/ $/ Counter/ $/ get/ 在/ 第/ 3/ 主层/ 一级/ 副/ 层/ 的/ 第/ 2/ 层上/ ,/ 记作/ 3/ -/ 2/ 层/ ./ 每个/ 依赖/ 层次/ 的/ 依赖/ 密度/ 定义/ 为/ 各级/ 副/ 层次/ 中/ 函数/ 结点/ (/ 图/ 6/ 中以/ Entry/ 为/ 前缀/ 的/ 结点/ )/ 的/ 总和/ ,/ 总和/ 越大/ ,/ 密度/ 越高/ ./ 依赖/ 密度/ 是/ 也/ 是/ 选择/ 检查点/ 的/ 依据/ 之一/ ./ 4.2/ ./ 3/ 自/ 适应/ 迭代/ 算法/ 自/ 适应/ 插桩/ 模块/ 将/ 根据/ 依赖/ 属性/ 和/ 系统资源/ 指导/ 追踪/ 和/ 重放/ 代码/ 的/ 生成/ ./ 受到/ 存储/ 和/ 通信/ 资源/ 的/ 限制/ ,/ 每次/ 追踪/ 的/ 范围/ 和/ 精度/ 都/ 是/ 有限/ 的/ ./ 因此/ ,/ 在/ 定位/ 到/ 错误/ 根源/ 之前/ ,/ 可能/ 需要/ 对/ 自/ 适应/ 插桩/ 、/ 追踪/ 以及/ 重/ 放/ 进行/ 多次/ 迭代/ ./ 本文/ 将/ 这个/ 迭代/ 过程/ 称为/ 自/ 适应/ 迭代/ ./ 自/ 适应/ 迭代/ 规则/ 分/ 两类/ :/ 插桩/ 选择/ 规则/ 和/ 插/ 桩/ GR/ )/ ;/ (/ 1/ )/ 粒度/ 调整/ 规则/ (/ Granularity/ -/ adjustRule/ ,/ (/ 2/ )/ 范围/ 调整/ 规则/ (/ Scope/ -/ adjustRule/ ,/ SR/ )/ ./ 为/ 描述/ 自/ 适应/ 迭代/ 算法/ ,/ 本/ 节/ 定义/ 了/ 插/ 桩/ 状态/ 和/ 4/ 个/ 新/ 函数/ :/ 插桩/ 状态/ 是/ 一个二元/ 组/ 〈/ instr/ _/ level/ ,/ instr/ _/ type/ 〉/ ,/ 其中/ ,/ instr/ _/ level/ 代表/ 插桩/ 的/ 层次/ (/ 如/ :/ 主/ 层次/ 、/ 一级/ 副/ 层次/ 、/ 1/ -/ 2/ 层/ 等/ )/ ,/ 当/ 基准/ 层次/ 发生变化/ 后/ ,/ 函数/ 依赖图/ 上/ 的/ 依赖/ 层次/ 划分/ 及/ 各层/ 的/ 编号/ 也/ 将/ 根据/ 定义/ 重新/ 计算/ ;/ instr/ _/ type/ 代表/ 插桩/ 的/ 类型/ ,/ 包括/ :/ 仅/ 对/ 非/ 确定/ 性行为/ 插桩/ (/ NOND/ )/ 、/ 仅/ 插入/ 检查点/ (/ CKPT/ )/ ,/ 或/ 两者/ 兼备/ (/ BOTH/ )/ ./ 〈/ null/ ,/ null/ 〉/ 代表/ 空/ 状态/ ./ 函数/ Next/ _/ instr/ _/ level/ :/ (/ State/ ,/ Rule/ )/ →/ State/ 在/ 程序/ 存储空间/ 尚有/ 剩余/ 的/ 前提/ 下/ ,/ 根据/ 当前/ 插桩/ 状态/ 〈/ level/ ,/ type/ 〉/ (/ 可以/ 是/ 空/ 状态/ )/ 和/ 优先级/ 最高/ 的/ 自/ 适应/ 插桩/ 规则/ (/ MR/ 、/ HR/ 和/ LR/ )/ ,/ 选择/ 下/ 一个/ 插桩/ 备选/ 状态/ 〈/ new/ _/ level/ ,/ type/ 〉/ ./ 其中/ ,/ MR/ 规则/ 将/ 选择/ level/ 的/ 下/ 一级/ 副/ 层次/ 作为/ new/ _/ level/ ,/ HR/ 规则/ 将/ 选择/ 与/ level/ 同级/ 且/ 密度/ 仅次于/ level/ 的/ 层/ 作为/ new/ _/ level/ ,/ LR/ 规则/ 选择/ 与/ level/ 同级/ 且/ 编号/ 仅/ 高于/ level/ 的/ 层/ 作为/ new/ _/ level/ ./ 如果/ new/ _/ level/ 不/ 存在/ 或/ 不/ 唯一/ ,/ 则/ 返回/ 空/ 状态/ ./ 函数/ Next/ _/ instr/ _/ type/ :/ State/ →/ State/ 在/ 程序/ 存储空间/ 不足以/ 支持/ 当前/ 插桩/ 状态/ 〈/ level/ ,/ type/ 〉/ 的/ 前提/ 下/ ,/ 调整/ 插桩/ 类型/ ,/ 生成/ 新/ 的/ 备选/ 插桩/ 状态/ 〈/ level/ ,/ new/ _/ type/ 〉/ ./ 如果/ type/ 的/ 类型/ 为/ BOTH/ ,/ 则/ 选择/ CKPT/ 作为/ new/ _/ type/ ;/ 如果/ type/ 的/ 类型/ 为/ CKPT/ ,/ 则/ 将/ 新/ 的/ 插/ 桩/ 状态/ 设为/ 空/ 状态/ ./ 函数/ Instr/ _/ pre/ :/ (/ Resource/ ,/ State/ )/ →/ (/ Resource/ ,/ Instr/ _/ state/ )/ 评估/ State/ 对应/ 的/ 备选/ 插桩/ 状态/ 是否/ 能够/ 在/ 当前/ 剩余/ 的/ 程序/ 存储空间/ Resource/ 内/ 顺利完成/ 以及/ 完成/ 后/ 程序/ 存储空间/ 的/ 余量/ ./ 输出/ 参数/ Instr/ _/ state/ 代表/ 程序/ 存储空间/ 对/ 插/ 桩/ 状态/ 的/ 支持/ 情况/ :/ 支持/ (/ SUCC/ )/ 、/ 不/ 支持/ (/ FAIL/ )/ ./ 输出/ 参数/ Resource/ 代表/ 完成/ 上述/ 插桩/ 状态/ 后/ ,/ 程序/ 存储空间/ 的/ 余量/ ./ 初始状态/ 下/ ,/ 插桩/ 代码/ 规模/ 上界/ 即/ 传感器/ 节点/ 上/ 程序/ 存储空间/ 的/ 大小/ 减去/ 原始/ 程序/ 与/ 插/ 桩/ 库/ 共同/ 编译/ 生成/ 的/ 代码/ 规模/ ./ 由于/ 插桩/ 插入/ 的/ 语句/ 都/ 是/ 对/ 插/ 桩/ 库函数/ 的/ 调用/ 语句/ ,/ 因此/ ,/ 根据/ 函数参数/ 的/ 数目/ 可以/ 估算/ 出该/ 语句/ 对/ 代码/ 规模/ 的/ 影响/ (/ 根据/ msp430/ 手册/ ,/ 每条/ call/ 指令/ 和/ mov/ 指令/ 均/ 占/ 4/ 个/ 字节/ )/ ./ 函数/ Instr/ _/ exec/ :/ (/ P/ ,/ State/ [/ ]/ )/ →/ (/ T/ ,/ R/ )/ 根据/ 程序/ P/ 和/ 插/ 桩/ 状态/ 数组/ State/ [/ ]/ ,/ 生成/ 追踪/ 程序/ T/ 和/ 重/ 放程序/ R/ ./ 自/ 适应/ 迭代/ 算法/ Adptive/ _/ Iter/ 如/ 算法/ 1/ 所示/ ./ 算法/ 1/ 首先/ 以/ 属性/ 函数/ 为/ 基准/ 层次/ ,/ 计算/ FPDG/ 的/ 依赖/ 层次/ 和/ 依赖/ 密度/ ,/ 然后/ 根据/ 用户/ 反馈/ (/ 首轮/ 迭代/ 用户/ 反馈/ 为空/ )/ ,/ 开始/ 新一轮/ 自/ 适应/ 插桩/ ,/ 插桩/ 输出/ 的/ 追踪/ 和/ 重/ 放程序/ 将/ 生成/ 可/ 供/ 用户/ 分析/ 、/ 调试/ 的/ 程序执行/ 轨迹/ ,/ 辅助/ 用户/ 定位/ 错误/ 根源/ (/ 第/ 1/ ~/ 7/ 行/ )/ ./ 算法/ 1/ ./ 自/ 适应/ 迭代/ 算法/ Adptive/ _/ Iter/ ./ 输入/ :/ 属性/ 函数/ Inv/ 输出/ :/ 用户/ 诊断/ 反馈/ F1/ ./ 以/ Inv/ 为/ 基准/ 层次/ ,/ 计算/ FPDG/ 的/ 依赖/ 层次/ 和/ 依赖/ 2/ ./ 读取/ 用户/ 反馈/ F3/ ./ {/ 4/ ./ 〈/ T/ ,/ R/ 〉/ =/ callInstr/ _/ Iter/ (/ FPDG/ ,/ R/ _/ set/ ,/ Resource/ ,/ F/ )/ ;/ 5/ ./ 执行/ T/ ,/ 生成/ 追踪/ 日志/ LogPage106/ ./ 执行/ R/ ,/ 用户/ 根据/ R/ 所/ 复现/ 的/ 执行/ 轨迹/ 分析/ 错误/ 7/ ./ }/ while/ (/ F/ !/ =/ null/ )/ // // 自/ 适应/ 插/ 桩子/ 函数/ // // 输入/ :/ 函数/ 级/ 依赖图/ FPDG/ ,/ 规则/ 优先级/ 组合/ set/ ,/ 插/ // // 输出/ :/ 追踪/ 插桩/ 程序/ T/ ,/ 重放/ 插/ 桩/ 程序/ RSubRoutine/ 〈/ T/ ,/ R/ 〉/ Instr/ _/ Iter/ (/ FPDG/ ,/ set/ ,/ r/ ,/ f/ )/ {/ 8/ ./ if/ (/ f/ 提示/ 精化/ 对/ new/ _/ level/ 层/ 的/ 插/ 桩/ )/ 9/ ./ cur/ _/ state/ ./ instr/ _/ level/ =/ new/ _/ level/ ;/ 10/ ./ if/ (/ f/ 提示/ 新/ 的/ 基准/ 层次/ )/ 11/ ./ 更新/ FPDG/ 的/ 依赖/ 层次/ 和/ 依赖/ 密度/ 12/ ./ while/ (/ r/ !/ =/ nullrule/ !/ =/ null/ )/ {/ 13/ ./ cur/ _/ state/ =/ Next/ _/ instr/ _/ level/ (/ cur/ _/ state/ ,/ rule/ )/ ;/ 14/ ./ while/ (/ cur/ _/ state/ !/ =/ 〈/ null/ ,/ null/ 〉/ )/ {/ 15/ ./ 〈/ tmp/ _/ r/ ,/ instr/ _/ state/ 〉/ =/ Instr/ _/ pre/ (/ r/ ,/ cur/ _/ state/ )/ ;/ 16/ ./ if/ (/ instr/ _/ state/ =/ =/ SUCC/ }/ {/ 17/ ./ state/ [/ i/ ++/ ]/ =/ cur/ _/ state/ ;/ 18/ ./ r/ =/ tmp/ _/ r/ ;/ 19/ ./ rule/ =/ Next/ _/ rule/ (/ R/ _/ set/ ,/ rule/ )/ ;/ 20/ ./ if/ (/ rule/ !/ =/ null/ )/ 21/ ./ cur/ _/ state/ =/ Next/ _/ instr/ _/ level/ (/ cur/ _/ state/ ,/ rule/ )/ ;/ 22/ ./ cur/ _/ state/ =/ Next/ _/ instr/ _/ type/ (/ cur/ _/ state/ )/ ;/ 23/ ./ if/ (/ rule/ !/ =/ null/ )/ 24/ ./ rule/ =/ Next/ _/ rule/ (/ R/ _/ set/ ,/ rule/ )/ ;/ 25/ ./ 〈/ T/ ,/ R/ 〉/ =/ Instr/ _/ exec/ (/ S/ ,/ state/ [/ ]/ )/ ;/ 26/ ./ return/ 〈/ T/ ,/ R/ 〉/ ;/ }/ 自/ 适应/ 插桩/ 由/ 子函数/ Instr/ _/ Iter/ 完成/ ./ 该/ 函数/ 首先/ 分析/ 用户/ 反馈/ ,/ 精化/ 本轮/ 插桩/ 所/ 关注/ 的/ 层次/ 范围/ (/ 粒度/ 调整/ )/ ,/ 或/ 根据/ 用户/ 反馈/ 的/ 新/ 基准/ 层次/ 重新/ 计算/ FPDG/ 上/ 的/ 依赖/ 层次/ 和/ 依赖/ 密度/ (/ 范围/ 调整/ )/ (/ 第/ 8/ ~/ 11/ 行/ )/ ./ 如果/ 当前/ 的/ 插/ 桩/ 空间/ 仍/ 有/ 剩余/ (/ 第/ 12/ 行/ )/ ,/ 则/ 根据/ 优先级/ 最高/ 的/ 规则/ ,/ 决定/ 下/ 一个/ 备选/ 插桩/ 状态/ (/ 第/ 13/ 行/ )/ ./ 如果/ 该/ 状态/ 并非/ 空/ 状态/ ,/ 则/ 评估/ 当前/ 的/ 插/ 桩/ 空间/ 余量/ 是否/ 足以/ 支持/ 该/ 插/ 桩/ 状态/ (/ 第/ 14/ ~/ 15/ 行/ )/ ,/ 如果/ 支持/ ,/ 则/ 将/ 该/ 备选/ 状态/ 存入/ 数组/ state/ [/ ]/ ,/ 并/ 更新/ 插桩/ 空间/ 的/ 余量/ (/ 第/ 16/ ~/ 18/ 行/ )/ ,/ 否则/ ,/ 读取/ 优先级/ 仅次于/ 当前/ 规则/ 的/ 下/ 一条/ 规则/ (/ 第/ 19/ 行/ )/ ,/ 并/ 根据/ 该/ 规则/ 生成/ 新/ 的/ 插/ 桩/ 状态/ ,/ 并/ 再度/ 进行/ 评估/ (/ 第/ 20/ ~/ 21/ 行/ )/ ,/ 如果/ 已/ 无/ 可用/ 规则/ ,/ 则/ 调整/ 当前/ 插桩/ 状态/ 的/ 插/ 桩/ 类型/ ,/ 并/ 再度/ 进行/ 评估/ (/ 第/ 22/ 行/ )/ ,/ 直到/ 当前/ 剩余/ 的/ 插/ 桩/ 空间/ 能够/ 支持/ 调整/ 后/ 的/ 插/ 桩/ 状态/ ,/ 或/ 调整/ 后/ 的/ 状态/ 为空/ 状态/ ./ 而后/ ,/ 按照/ 优先级/ 递减/ 顺序/ 继续/ 分析/ 下/ 一条/ 规则/ ,/ 如果/ 下/ 一条/ 规则/ 不/ 存在/ ,/ 则/ 预估/ 分析/ 结束/ (/ 第/ 23/ ~/ 24/ 行/ )/ ,/ Instr/ _/ Iter/ 根据/ 存放/ 在/ state/ [/ ]/ 中/ 的/ 插/ 桩/ 操作/ ,/ 生成/ 追踪/ 程序/ T/ 和/ 重/ 放程序/ R/ (/ 第/ 25/ ~/ 26/ 行/ )/ ,/ 本轮/ 插桩/ 结束/ ./ 自/ 适应/ 插桩/ 规则/ 依据/ 用户/ 的/ 调试/ 经验/ 以及/ 对/ 所/ 诊断/ 的/ 程序/ 的/ 熟悉/ 程度/ ,/ 可以/ 有/ 两种/ 组合/ 方法/ ./ 规则/ 组合/ I/ 以/ 追踪/ 粒度/ 的/ 逐步/ 精/ 化为/ 主导/ ,/ 在/ 代码/ 存储空间/ 受限/ 的/ 前提/ 下/ ,/ 优先/ 强调/ 追踪/ 程序/ 的/ 整体/ 行为/ (/ 比如/ :/ 关键/ 位置/ 上/ 的/ 变量/ 状态/ )/ ./ 构成/ 该/ 组合/ 的/ 子/ 规则/ 的/ 优先级/ 按/ MR/ →/ HR/ →/ LR/ 的/ 次序/ 递减/ ./ 依据/ 上述/ 规则/ 优先/ 顺序/ ,/ 自/ 适应/ 迭代/ 算法/ 首先/ 对主/ 层次/ 上非/ 确定/ 性行为/ 以及/ 检查点/ 插桩/ ;/ 然后/ 根据/ 各层/ 的/ 密度/ ,/ 优先/ 对/ 密度/ 最高/ (/ 即/ 依赖/ 关系/ 最/ 复杂/ ,/ 人工/ 分析/ 负担/ 最大/ )/ 的/ 主层/ 中/ 的/ 所有/ 一级/ 副/ 层次/ 上/ 的/ 非/ 确定/ 性行为/ 以及/ 检查点/ 插桩/ ;/ 如果/ 出现/ 两个/ 主/ 层次/ 的/ 密度/ 相当/ ,/ 且/ 没有/ 用户/ 反馈/ 的/ 情况/ ,/ 则/ 优先/ 处理/ 层次/ 编号/ 较/ 低/ (/ 最靠近/ 基准/ 层次/ )/ 的/ 主/ 层次/ 中/ 的/ 所有/ 一级/ 副/ 层次/ ;/ 依此类推/ ,/ 直到/ 完成/ 对/ 函数/ 依赖图/ 上/ 各级/ 副/ 层次/ 的/ 处理/ ./ 规则/ 组合/ I/ 适合/ 于/ 经验/ 较/ 丰富/ ,/ 或者/ 对/ 所/ 诊断/ 的/ 程序/ 较为/ 熟悉/ 的/ 用户/ ./ 粒度/ 调整/ 规则/ (/ GR/ )/ 常/ 与/ 规则/ 组合/ I/ 联用/ ./ 当/ 用户/ 判断/ 错误/ 根源/ 可能/ 在/ 某个/ 层次/ 内/ ,/ 但/ 本次/ 迭代/ 的/ 追踪/ 和/ 重放/ 粒度/ 不足以/ 证明/ 这个/ 判断/ 时/ ,/ 自/ 适应/ 插桩/ 模块/ 将/ 针对/ 用户/ 所/ 反馈/ 的/ 范围/ 以及/ 有/ 嫌疑/ 的/ 变量/ ,/ 生成/ 粒度/ 更细/ 的/ 追踪/ 代码/ ./ 规则/ 组合/ II/ 以/ 追踪/ 范围/ 的/ 逐步/ 扩大/ 为/ 主导/ ,/ 在/ 代码/ 存储空间/ 受限/ 的/ 前提/ 下/ ,/ 优先/ 强调/ 追踪/ 靠近/ 基准/ 层次/ 的/ 程序/ 行为/ 细节/ ;/ 子/ 规则/ 的/ 优先/ 级别/ 按/ LR/ →/ MR/ →/ HR/ 的/ 次序/ 递减/ ./ 依据/ 上述/ 规则/ 优先/ 顺序/ ,/ 自/ 适应/ 迭代/ 算法/ 首先/ 对/ 层次/ 编号/ 最低/ 的/ 主/ 层次/ 以及/ 其中/ 的/ 各级/ 副/ 层次/ 上/ 的/ 非/ 确定/ 性行为/ 插桩/ ,/ 并/ 在/ 该主/ 层次/ 的/ 边界/ 上/ 插入/ 检查点/ ;/ 如果/ 完成/ 对/ 所有主/ 层次/ 的/ 处理/ 后/ ,/ 代码/ 存储资源/ 仍/ 有/ 富余/ ,/ 则/ 设置/ 更/ 多/ 的/ 检查点/ ,/ 以/ 提高/ 重/ 放/ 范围/ 选择/ 的/ 灵活性/ ./ 检查点/ 的/ 设置/ 遵循/ 先主/ 层后/ 副/ 层/ ,/ 先/ 高密度/ 后/ 低密度/ 的/ 顺/ Page11/ 序/ ./ 规则/ 组合/ II/ 更/ 适合/ 经验不足/ 或者/ 对/ 程序/ 不/ 甚/ 熟悉/ 的/ 调试/ 用户/ ,/ 用户/ 可/ 根据/ 追踪/ 日志/ ,/ 从属性/ 违反/ 位置/ 出发/ ,/ 逆向/ 查找/ 错误/ 的/ 传播/ 路径/ ,/ 定位/ 错误/ 根源/ ./ 范围/ 调整/ 规则/ (/ SR/ )/ 常/ 与/ 规则/ 组合/ II/ 联用/ ./ 当/ 用户/ 确定/ 错误/ 根源/ 不/ 在/ 当前/ 所/ 重放/ 的/ 若干/ 层次/ 中/ ,/ 自/ 适应/ 插桩/ 模块/ 将/ 上/ 一轮/ 迭代/ 的/ 追踪/ 边界/ 以及/ 其上/ 与/ 属性/ 相关/ 的/ 变量/ (/ 也/ 可以/ 由/ 用户/ 指定/ 有/ 嫌疑/ 的/ 变量/ )/ 封装/ 成新/ 的/ 基准/ 层次/ ,/ 重新/ 生成/ 插桩/ 代码/ ./ 考虑/ 到/ 结点/ 功耗/ 以及/ 轨迹/ 日志/ 记录/ 的/ 时空/ 开销/ ,/ ADA/ 的/ 默认/ 插桩/ 范围/ 仅/ 包括/ 主/ 层次/ 和/ 第一副/ 层次/ ,/ 用户/ 可以/ 自主/ 选择/ 是否/ 遵循/ 该/ 范围/ 限制/ ./ 此外/ ,/ 为/ 提高/ 原型/ 系统/ 的/ 灵活性/ 和/ 易用性/ ,/ 我们/ 还/ 为/ 用户/ 提供/ 了/ 追踪/ 范围/ 和/ 粒度/ 的/ 选择/ 接口/ ./ 4.2/ ./ 4/ 迭代/ 与/ 错误/ 定位/ 自/ 适应/ 迭代/ 将/ 对/ 程序/ 行为/ 进行/ 多次/ 追踪/ 和/ 重放/ ,/ 这/ 就/ 引入/ 了/ 一个/ 新/ 问题/ ./ 即便/ 程序/ 中/ 只有/ 单个/ 错误/ 根源/ ,/ 不同/ 次/ 追踪/ 迭代/ 也/ 可能/ 通过/ 不同/ 执行/ 路径/ 到达/ 属性/ 被/ 违反/ 的/ 位置/ ./ 当/ 出现/ 上述情况/ 时/ ,/ 错误/ 根源/ 只/ 可能/ 位于/ 不同/ 执行/ 路径/ 的/ 公共/ 部分/ ./ 如图/ 7/ 所示/ ,/ 用户/ 诊断/ 时/ 可以/ 忽略/ 非/ 公共/ 部分/ 中/ 函数/ 执行/ 实例/ 的/ 重放/ 轨迹/ ./ 对于/ 存在/ 多个/ 错误/ 根源/ 的/ 情况/ ,/ 不同/ 次/ 迭代/ 追踪/ 并重/ 放/ 的/ 可能/ 是/ 由/ 不同/ 错误/ 根源/ 引发/ 的/ 不同/ 错误/ 执行/ 路径/ ./ 遇到/ 上述情况/ 时/ ,/ 自/ 适应/ 迭代/ 将/ 同时/ 维护/ 用于/ 追踪/ 不同/ 错误/ 根源/ 的/ 插/ 桩/ 代码/ ,/ 但/ 每次/ 迭代/ 生成/ 的/ 追踪/ 日志/ 是否/ 由/ 同一个/ 错误/ 根源/ 引发/ 需由/ 用户/ 判别/ ./ 在/ 源码/ 级/ 通过/ 插桩/ 的/ 方式/ 对/ 中断/ 和/ 检查点/ 进行/ 4.3/ 安全性/ 与/ 代价/ 追踪/ 和/ 重放/ 可能/ 会/ 导致/ 不/ 安全/ 因素/ ./ 图/ 4/ 、/ 图/ 5/ 所示/ 的/ 追踪/ 和/ 重放/ 代码/ 采用/ 全局/ 量/ 操作/ 计数/ 方案/ 追踪/ 并重/ 放/ 中断/ 的/ 响应/ 位置/ ./ 其中/ ,/ 语句/ T1/ ~/ T3/ 、/ R1/ ~/ R3/ 均/ 由/ if/ (/ EasyCollectionC/ $/ counter/ =/ =/ 0/ )/ 经插/ 桩/ 转化/ 而来/ ./ 如果/ ,/ 在/ 追踪/ 程序/ 的/ 执行/ 过程/ 中/ ,/ 中断/ 响应/ 发生/ 在/ 语句/ T1/ 和/ T2/ 之间/ ,/ 且/ 该/ 中断/ (/ 记作/ I/ )/ 修改/ 了/ 全局/ 量/ EasyCollec/ -/ tionC/ $/ counter/ ,/ 追踪/ 日志/ 将/ 记载/ 当前/ 函数/ 本次/ 实例/ 在/ 全局/ 量/ 操作/ 计数器/ 为/ 1/ 的/ 区间/ 内/ 响应/ 了/ 中断/ I/ ./ 但/ 由于/ T1/ 在/ 中断/ 服务/ 函数/ 执行/ 之前/ 已经/ 将/ Easy/ -/ CollectionC/ $/ counter/ 的/ 值/ 存入/ 寄存器/ _/ load/ _/ cnt/ ,/ 因此/ ,/ T3/ 使用/ 的/ 依然/ 是/ 未经/ 中断/ 服务/ 函数/ 修改/ 的/ 旧值/ ./ 当重/ 放/ 程序执行/ 到/ 追踪/ 日志/ 记录/ 的/ 函数/ 执行/ 实例/ 时/ ,/ 根据/ 追踪/ 日志/ ,/ 可以/ 选择/ 在/ 图/ 5/ 中虚/ 框内/ 任意/ 语句/ 的/ 前后/ 响应/ 中断/ I/ ./ 如果/ ,/ 在/ 以上/ 区域/ 内/ 随机/ 选择/ 的/ 中断/ 响应/ 位置/ 恰好/ 在/ 语句/ R1/ 之前/ ,/ 那么/ 当重/ 放/ 程序执行/ 到/ 语句/ R3/ 时/ ,/ 该/ 语句/ 使用/ 的/ 就/ 将/ 是/ 经/ 中断/ 服务/ 函数/ 更新/ 后/ 的/ EasyCollectionC/ $/ counter/ 的/ 值/ ,/ 由此/ 引起/ 的/ 重放/ 执行/ 轨迹/ 与/ 追踪/ 执行/ 轨迹/ 之间/ 的/ 偏差/ ,/ 可能/ 导致/ 重/ 放/ 轨迹/ 与/ 追踪/ 的/ 行为/ 不/ 一致/ ,/ 甚至/ 造成/ 重/ 放/ 失败/ ./ 为/ 解决/ 上述/ 问题/ ,/ 生成/ 追踪/ 代码/ 时/ ,/ 必须/ 对/ 类似/ 图/ 4/ 中/ T1/ 至/ T3/ 的/ 区间/ 加锁/ (/ AtomicStart/ 和/ AtomicEnd/ )/ ,/ 屏蔽/ 上述/ 区间/ 内/ 的/ 中断/ 响应/ ,/ 但/ 这/ 势必/ 将/ 增加/ 插桩/ 代码/ 的/ 规模/ 以及/ 追踪/ 代码/ 的/ 执行/ 时间/ ./ 为/ 降低/ 时空/ 代价/ ,/ 我们/ 对/ 中断/ 分析/ 进行/ 优化/ ./ 以图/ 8/ 所示/ 的/ C/ 程序/ 片段/ 为例/ ,/ 假定/ :/ 所/ 监控/ 的/ 属性/ 为/ (/ a/ =/ =/ b/ )/ ,/ 且/ 运行/ 时/ ,/ 中断/ I1/ 、/ I2/ 均/ 在/ 全局/ 量/ b/ 的/ 定值/ 之后/ 被/ 响应/ ./ 函数/ foo/ 中/ 语句/ S1/ 和/ S2/ 都/ 可能/ 影响/ 属性/ (/ a/ =/ =/ b/ )/ 的/ 真值/ ./ 追踪/ 代码生成/ 模块/ 必须/ 在/ 这/ 两条/ 语句/ 之后/ 插入/ 带锁/ 保护/ 的/ 全局/ 量/ 操作/ 计数/ ./ 但/ 由于/ 中断/ 服务/ 函数/ Intr/ _/ 2/ 仅/ 修改/ 全局/ 量/ b/ 的/ 值/ ,/ 故仅/ I2/ 的/ 响应/ 位置/ 与/ S2/ 之间/ 的/ 先后顺序/ ,/ 就/ 可以/ 决定/ Intr/ _/ 2/ 对/ b/ 的/ 定值/ 是否/ 可以/ 到达/ P/ ./ 因此/ ,/ 不/ 需要/ 对/ 语句/ S1/ 进行/ 全局/ 量/ 计数/ 插桩/ ./ 基于/ 以上/ 事实/ ,/ 我们/ 对/ 中断/ 分析/ 进行/ 优化/ ./ 首先/ ,/ 按照/ 所/ 完成/ 的/ 功能/ ,/ 将/ TinyOS/ 程序/ 中/ 的/ 中断/ 服务/ 函/ Page12/ 数/ 分为/ 3/ 类/ :/ (/ 1/ )/ 仅/ 向/ 任务/ 队列/ 里/ 添加/ 新/ 任务/ (/ 更新/ 存放/ 任务/ 队列/ 的/ 全局/ 数组/ SchedulerBasicP/ $/ m/ _/ next/ )/ ;/ (/ 2/ )/ 使用/ 与/ 所/ 监控/ 属性/ 相关/ 的/ 全局变量/ ;/ (/ 3/ )/ 修改/ 除/ 任务/ 队列/ 外/ 与/ 所/ 监控/ 属性/ 相关/ 的/ 全局变量/ ./ 对于/ 第/ (/ 1/ )/ 类/ 中断/ 服务/ 函数/ ,/ 4.1/ ./ 1/ 节/ 已经/ 进行/ 了/ 单独/ 处理/ ./ 第/ (/ 2/ )/ 类/ 中断/ 服务/ 函数/ 并/ 不/ 对/ 程序/ 中除/ 其/ 本身/ 以外/ 的/ 任何/ 部分/ 带来/ 副作用/ ,/ 追踪/ 时/ 也/ 可以/ 忽略/ ./ 事实上/ ,/ 追踪/ 和/ 重放/ 模块/ 需要/ 关注/ 的/ 仅/ 为/ 第/ (/ 3/ )/ 类/ 中断/ 服务/ 函数/ ./ 这类/ 函数/ 与/ 同步/ 代码/ 之间/ 的/ 相互依赖/ 可以/ 通过/ 依赖/ 分析/ 获得/ ,/ 分析/ 结果/ 可以/ 精确/ 到/ 它们/ 各自/ 与/ 同步/ 代码/ 中/ 的/ 哪些/ 函数/ 的/ 哪些/ 语句/ 中/ 所/ 使用/ 或者/ 修改/ 的/ 哪些/ 变量/ 有/ 交集/ ./ 在/ 对/ 全局/ 量/ 操作/ 进行/ 插桩/ 计数/ 和/ 锁/ 保护/ 时/ ,/ 仅/ 考虑/ 出现/ 在/ 上述/ 交集/ 区域/ 中/ 的/ 操作/ ./ 譬如/ ,/ 图/ 2/ 中/ 的/ AssertTimer/ ./ fired/ 函数/ 与/ 该/ 程序/ 中/ 所有/ 8/ 个/ 中断/ 服务/ 函数/ 之间/ 依赖/ 分析/ 的/ 交集/ 均/ 为/ 空/ ,/ 因此/ ,/ 图/ 4/ 、/ 图/ 5/ 中/ 对/ 该/ 函数/ 内部/ 全局/ 量/ 操作/ 计数/ 的/ 插/ 桩/ 均/ 可/ 被/ 优化/ ./ 类似/ 的/ 问题/ 也/ 会/ 出现/ 表/ 1/ 测试用例/ 描述/ 测试用例/ 名称/ BlinkCTestSerialCO2EasyCollectionC/ 我们/ 基于/ Open64/ 编译器/ ,/ 在/ 精确/ 指针/ 分析/ [/ 7/ ]/ 的/ 基础/ 上/ 计算/ 依赖/ 信息/ ,/ 构建/ 函数/ 依赖图/ ./ 基于/ 以上/ 信息/ ,/ 建立/ 本文/ 提出/ 的/ 自/ 适应/ 诊断系统/ 原型/ ,/ 并/ 对/ 上述/ 测试用例/ ,/ (/ 1/ )/ 评估/ 确定性/ 重放/ 的/ 开销/ ,/ 包括/ 依赖/ 分析/ 和/ 自/ 适应/ 插桩/ 方法/ 对/ 空间/ 开销/ 以及/ 整体/ 的/ 追踪/ 时间/ 开销/ 的/ 控制/ 效果/ ;/ (/ 2/ )/ 分析/ 自/ 适应/ 插桩/ 方法/ 对/ 错误/ 根源/ 定位/ 的/ 支持/ 效果/ ./ 5.1/ 依赖/ 分析/ 与/ 空间/ 优化/ 为了/ 评价/ 依赖/ 分析/ 对/ 本文/ 重/ 放/ 方案/ 的/ 空间/ 优化/ 效果/ ,/ 本/ 节/ 选取/ 检查点/ 设置/ 的/ 2/ 种/ 极限/ 情况/ :/ (/ 1/ )/ 仅/ 设置/ 单一/ 的/ 检查点/ ;/ (/ 2/ )/ 将/ 所有/ 可能/ 影响/ 所/ 监控/ 属性/ 的/ 函数/ 入口/ 状态/ 设/ 为/ 检查点/ ./ 对于/ 第/ 1/ 种/ 情况/ ,/ 选择/ 最/ 外层/ 循环/ 的/ 迭代/ 入口/ 位置/ 为/ 检查点/ ./ 表/ 2/ 展示/ 了/ 依赖/ 分析/ 对/ 追踪/ 程序/ 规模/ 的/ 优化/ 效果/ ./ 其中/ ,/ Orig/ +/ Instr/ _/ lib/ 代表/ 将/ 测试程序/ 与/ 插/ 桩/ 库/ 一起/ 编译/ 生成/ 的/ 可/ 执行/ 码/ 的/ 规模/ ;/ Base/ -/ line/ 代表/ 不/ 经/ 依赖/ 分析/ 得到/ 的/ 追踪/ 程序/ 规模/ ;/ Dep/ 代表/ 基于/ 依赖/ 分析/ 得到/ 的/ 追踪/ 程序/ 规模/ ;/ Dep/ _/ Opt/ 代表/ 通过/ 依赖/ 分析/ 以及/ 包装/ 函数/ 内联/ 优化/ 得到/ 的/ 追踪/ 程序/ 的/ 规模/ ./ 上述/ 追踪/ 插桩/ 均/ 仅/ 选择/ 最/ 外层/ 循环/ 的/ 迭代/ 入口/ 位置/ 为/ 检查点/ ./ 可/ 执行/ 码均/ 由/ msp430/ -/ 在/ 对/ 检查点/ 的/ 追踪/ 与/ 重放中/ ./ 加锁/ 的/ 方式/ 以及/ 上述/ 优化/ 同样/ 适用/ 于/ 此类/ 区域/ ./ 此外/ ,/ 对于/ 用/ nes/ C语言/ 编写/ 的/ TinyOS/ 程序/ ,/ 经由/ nesC/ 编译器/ 翻译成/ C/ 程序/ 后/ ,/ 程序/ 中/ 的/ 临界/ 区/ 的/ 首尾/ 分别/ 由/ _/ nesc/ _/ atomic/ _/ start/ 和/ _/ nesc/ _/ atomic/ _/ end/ 标识/ ./ 对/ 上述/ 区域/ 的/ 识别/ 可/ 进一步/ 筛选/ 需要/ 追踪/ 的/ 中断/ 服务/ 函数/ ./ 5/ 实验/ 结果/ 分析/ 本文/ 选择/ 用/ nes/ C语言/ 编写/ 的/ TinyOS/ 程序/ 作为/ 实验/ 程序/ ,/ 并/ 选用/ 由/ TelosB/ 传感器/ 结点/ 搭建/ 的/ 传感/ 网/ 作为/ 实验/ 程序/ 的/ 运行/ 环境/ ./ 每个/ TelosB/ 传感器/ 结点/ 拥有/ 48KB/ 的/ 程序/ 存储空间/ ,/ 10KB/ 的/ RAM/ 空间/ ,/ 和/ 1MB/ 的/ 外部/ 存储空间/ ./ 测试用例/ 以及/ 所/ 监控/ 的/ 属性/ 如表/ 1/ 所示/ ./ gcc/ 交叉/ 编译器/ (/ 版本号/ :/ 3.2/ ./ 3/ )/ 编译/ 生成/ ,/ 编译/ 选项/ :/ “/ -/ mmcu/ =/ msp430x1611/ -/ Os/ -/ O/ -/ mdisable/ -/ hwmul/ -/ Wall/ -/ Wshadow/ ”/ ,/ 生成/ 的/ 代码/ 存放/ 在/ 传感器/ 结点/ 的/ ROM/ 空间/ ./ 由表/ 2/ 可知/ ,/ 对于/ EasyCollectionC/ 和/ TestSerial/ 这/ 两个/ 程序/ ,/ 如果/ 不/ 借助/ 依赖/ 分析/ ,/ 其/ 生成/ 的/ 追踪/ 程序/ 规模/ 将/ 远超过/ TelosB/ 结点/ 上/ 的/ 程序/ 存储空间/ 的/ 上限/ ./ 而/ 基于/ 依赖/ 分析/ 的/ 追踪/ 插桩/ 可以/ 将/ 追踪/ 程序/ 规模/ 限定/ 在/ 48KB/ 以内/ ,/ 对/ 追踪/ 程序/ 规模/ 的/ 平均/ 优化/ 效果/ 为/ 无/ 优化/ 时/ 的/ 57.7/ %/ ./ 对/ 包装/ 函数/ 的/ 内联/ 优化/ 进一步/ 缩减/ 了/ 插/ 桩/ 规模/ ,/ 可/ 用于/ 设置/ 更/ 多/ 的/ 检查点/ ,/ 提高/ 重放/ 的/ 灵活/ 程度/ 和/ 错误诊断/ 的/ 效率/ ./ 测试用例/ Orig/ +/ Instr/ _/ lib/ // BlinkCEasyCollectionC25550732144250239954TestSerialCO230646800584737844794/ 表/ 3/ 说明/ 了/ 依赖/ 分析/ 对/ 追踪/ 程序/ 规模/ 优化/ 的/ 主要/ 原因/ :/ 对/ 追踪/ 范围/ 的/ 优化/ ./ 如果/ 不/ 利用/ 依赖/ 分析/ ,/ 则/ 需要/ 追踪/ 程序/ 中/ 的/ 所有/ 函数/ ./ 表/ 3/ 的/ Fun/ c#/ 代表/ Page13/ 测试用例/ 中/ 函数/ 的/ 数量/ ;/ Dp/ _/ Fun/ c#/ 表示/ 经过/ 依赖/ 分析/ 后/ ,/ 确定/ 需要/ 追踪/ 的/ 函数/ 数量/ ;/ Dp/ %/ 是/ Dp/ _/ Fun/ c#/ 和/ Fun/ c#/ 的/ 百分比/ ,/ 表示/ 经/ 依赖/ 分析/ 后/ 的/ 追踪/ 范围/ 在/ 程序/ 中所/ 占/ 的/ 比例/ (/ 依赖/ 分析/ 输出/ 的/ 是/ 函数/ 级/ 依赖图/ ,/ 因此/ ,/ 该/ 比例/ 也/ 表示/ 为/ 函数/ 数目/ 之间/ 的/ 百分比/ )/ ;/ Opt/ _/ Fun/ c#/ 代表/ 经过/ 依赖/ 分析/ 和/ 包装/ 函数/ 内联/ 优化/ 后/ 需要/ 追踪/ 的/ 函数/ 数量/ ;/ Opt/ %/ 为/ Opt/ _/ Fun/ c#/ 和/ Fun/ c#/ 的/ 百分比/ ./ 由表/ 3/ 可知/ ,/ 经过/ 依赖/ 分析/ 和/ 包装/ 函数/ 内联/ 优化/ 后/ ,/ 需要/ 追踪/ 的/ 函数/ 数量/ 约/ 为/ 全/ 程序/ 中/ 函数/ 数量/ 的/ 1/ // 4/ ./ 测试用例/ Fun/ c#/ Dp/ _/ Fun/ c#/ Dp/ %/ Opt/ _/ Fun/ c#/ Opt/ %/ BlinkCEasyCollectionC144761442/ ./ 4340127.71/ TestSerialCO2149961240/ ./ 8339626.42/ 依赖/ 分析/ 对/ 追踪/ 程序/ 规模/ 的/ 优化/ 为/ 检查点/ 的/ 选择/ 提供/ 了/ 空间/ ./ 表/ 4/ 考虑/ 第/ (/ 2/ )/ 种/ 极限/ 情况/ ,/ 选择/ 所有/ 可能/ 影响/ 属性/ 的/ 函数/ 入口/ 为/ 检查点/ ,/ 以/ 检验/ 依赖/ 分析/ 、/ 包装/ 函数/ 优化/ 以及/ 中断/ 分析/ 优化/ 对/ 追踪/ 程序/ 规模/ 的/ 控制/ 效果/ ./ 其中/ ,/ Dep/ _/ All/ 列/ 表示/ 基于/ 依赖/ 分析/ 并/ 选择/ 所有/ 函数/ 入口/ 作为/ 检查点/ 得到/ 的/ 追踪/ 程序/ 规模/ ;/ Dep/ _/ All/ _/ Opt/ 列/ 在/ Dep/ _/ All/ 的/ 基础/ 上/ 增加/ 了/ 对/ 包装/ 函数/ 的/ 内联/ 优化/ ;/ Intr/ _/ Opt/ 指在/ Dep/ _/ All/ _/ Opt/ 的/ 基础/ 上/ 增加/ 对/ 中断/ 分析/ 的/ 优化/ (/ 详见/ 4.3/ 节/ )/ ./ 测试用例/ 原始/ 规模/ // BlinkCEasyCollectionC18670661825413847282TestSerialCO224002709305886652138/ 数据/ 表明/ ,/ 对/ 测试用例/ EasyCollectionC/ ,/ 仅/ 借助/ 依赖/ 分析/ 和/ 包装/ 函数/ 内联/ 优化/ ,/ 并/ 不足以/ 将/ 追踪/ 代码/ 规模/ 控制/ 在/ 48KB/ 的/ 阈值/ 以内/ ,/ 需要/ 通过/ 对/ 中断/ 分析/ 的/ 优化/ 解决/ 代码/ 存储空间/ 问题/ ./ 该/ 优化/ 方案/ 可/ 在/ 依赖/ 分析/ 和/ 包装/ 函数/ 内联/ 的/ 基础/ 上/ ,/ 进一步/ 降低/ 追踪/ 程序/ 规模/ ,/ 最大/ 减少/ 12.7/ %/ ,/ 平均/ 减少/ 9.4/ %/ ./ 表/ 5/ 罗列/ 了/ 上述/ 3/ 种/ 优化/ 对/ 插/ 桩/ 语句/ 数/ 的/ 控制/ 效果/ ./ 其中/ ,/ Total/ #/ 表示/ 插桩/ 语句/ 总数/ ,/ InOut/ #/ 测试用例/ EasyCollectionC33134TestSerialCO2/ 表/ 6/ 自/ 适应/ 插桩/ 效果/ 分析/ 4401447966/ 代表/ 追踪/ 函数/ 实例/ 的/ 插/ 桩/ 语句/ 的/ 数目/ ,/ Ckpt/ #/ 代表/ 追踪/ 检查点/ 的/ 插/ 桩/ 语句/ 的/ 数目/ ,/ Cnt/ #/ 则/ 是/ 与/ 全局/ 量/ 操作/ 计数器/ 相关/ 的/ 插/ 桩/ 语句/ 的/ 数目/ ./ 由表/ 4/ 可知/ ,/ 随/ 以上/ 3/ 种/ 优化/ 的/ 依次/ 进行/ ,/ 插桩/ 语句/ 数量/ 不断/ 减少/ ./ 遗憾/ 的/ 是/ ,/ 表/ 4/ 中/ 的/ 测试用例/ TestSerialCO2/ 即便/ 使用/ 了/ 上述/ 3/ 种/ 优化/ ,/ 其/ 追踪/ 控制程序/ 规模/ 仍然/ 高于/ 阈值/ ./ 因此/ ,/ 必须/ 引入/ 自/ 适应/ 迭代/ 规则/ ,/ 根据/ 资源/ 情况/ ,/ 自动/ 选择/ 检查点/ ./ Dep/ _/ All4352137312731706Dep/ _/ All/ _/ Opt32909488361506Intr/ _/ Opt1982946835201/ 本节/ 分析/ 了/ 检查点/ 设置/ 的/ 两种/ 极限/ 情况/ ./ 实验/ 表明/ ,/ 无论怎样/ 设置/ 检查点/ ,/ 依赖/ 分析/ 和/ 包装/ 函数/ 优化/ 都/ 能/ 有效/ 地/ 控制/ 追踪/ 代码/ 的/ 规模/ ,/ 部分/ 满足/ 传感器/ 结点/ 上/ 的/ 资源/ 限制/ ./ 同时/ ,/ 对/ 中断/ 的/ 优化/ 能/ 进一步/ 降低/ 追踪/ 代码/ 规模/ ,/ 即使/ 在/ 设置/ 所有/ 可能/ 检查点/ 的/ 情况/ 下/ ,/ 也/ 能令/ EasyCollectionC/ 的/ 追踪/ 控制代码/ 符合/ 空间/ 要求/ ./ 但/ 对于/ TestSerialCO2/ ,/ 即便/ 使用/ 了/ 上述/ 3/ 种/ 优化/ ,/ 追踪/ 代码/ 规模/ 依旧/ 不能/ 满足/ 空间/ 限制/ ./ 可见/ ,/ 这种/ 盲目/ 的/ 检查点/ 选择/ 策略/ 并/ 不/ 可取/ ./ 为此/ ,/ 我们/ 需要/ 自/ 适应/ 的/ 检查点/ 选择/ 和/ 插/ 桩/ 策略/ ./ 5.2/ 自/ 适应/ 插桩/ 与/ 诊断/ 效率/ 表/ 6/ 记录/ 了/ 自/ 适应/ 插桩/ 模块/ 根据/ 规则/ 组合/ I/ 、/ II/ 分别/ 为/ EasyCollectionC/ 和/ TestSerialCO2/ 生成/ 的/ 追踪/ 代码/ 规模/ ./ 规则/ 组合/ I/ 默认/ 只/ 处理/ 主/ 层次/ 以及/ 其上/ 的/ 一级/ 副/ 层次/ ,/ 生成/ 的/ 追踪/ 程序/ 规模/ 都/ 低于/ 阈值/ ;/ 规则/ 组合/ II/ 优先/ 处理/ 编号/ 最低/ 的/ 主/ 层次/ 及其/ 内部/ 的/ 各级/ 副/ 层次/ ./ 对于/ 测试用例/ TestSerialCO2/ ,/ 与/ 所/ 监控/ 属性/ 相关/ 的/ 程序/ 片段/ 可以/ 划分/ 成/ 6/ 个主/ 层次/ ,/ 但/ 自/ 适应/ 插桩/ 模块/ 完成/ 对前/ 5/ 个主/ 层次/ 的/ 追踪/ 插桩/ 后/ ,/ 剩余/ 的/ 代码/ 空间/ 已/ 不/ 支持/ 对/ 任何/ 完整/ 结构/ (/ 如/ :/ 检查点/ )/ 的/ 追踪/ ./ 表中/ ,/ Adp/ _/ size/ 和/ trace/ _/ fun/ c#/ 分别/ 表示/ 生成/ 的/ 追踪/ 代码/ 的/ 规模/ 以及/ 追踪/ 的/ 函数/ 数目/ ./ Main/ _/ level/ #/ 和/ trace/ _/ level/ #/ 分别/ 表示/ 程序/ 中/ 与/ 所/ 监控/ 属性/ 相关/ 的/ 部分/ 被/ 划分/ 成/ 的/ 主/ 层次/ 的/ 数量/ 以及/ 规则/ 组合/ II/ 选择/ 追踪/ 的/ 主/ 层次/ 数量/ ./ Page14/ 检查点/ 的/ 设置/ 能够/ 有效/ 地/ 提高/ 错误诊断/ 的/ 效率/ ./ 以/ EasyCollectionC/ 为例/ ,/ 消息/ 发送/ 结点/ 从/ 程序/ 开始/ 执行/ 到/ 发送/ 方/ 属性/ 被/ 违反/ ,/ 记录/ 的/ 轨迹/ 日志/ 将近/ 28KB/ (/ 不/ 包含/ 检查点/ )/ ./ 如果/ 没有/ 设置/ 检查点/ ,/ 则/ 用户/ 调试/ 时/ 只能/ 从/ 程序/ 入口/ 位置/ 开始/ 重/ 放/ ,/ 但/ 他们/ 需要/ 关注/ 的/ 实际上/ 只有/ 从/ 触发/ 属性/ 违反/ 的/ 错误/ 根源/ 语句/ 执行/ 实例/ 到/ 属性/ 被/ 违反/ 位置/ 之前/ 的/ 追踪/ 日志/ ./ 表/ 7/ 记录/ 了/ EasyCollectionC/ 程序执行/ 过程/ 中/ 5/ 次/ 从/ 错误/ 根源/ 语句/ 到/ 属性/ 违反/ 位置/ 之间/ 的/ 轨迹/ 日志/ 规模/ ,/ 其/ 平均/ 大小/ 仅/ 为/ 以/ 程序/ 入口/ 点为/ 起始/ 的/ 日志/ 的/ 8.36/ %/ ./ 一旦/ 设置/ 了/ 检查点/ ,/ 用户/ 就/ 可以/ 灵活/ 地/ 选择/ 需要/ 重放/ 的/ 程序/ 区段/ ,/ 从而/ 避免/ 不必要/ 的/ 重放/ 和/ 诊断/ 开销/ ./ 12345/ 百分比/ // %/ 228223462732233023328.36/ 实验/ 表明/ ,/ 自/ 适应/ 规则/ 能够/ 依据/ 可用/ 资源/ ,/ 选择/ 适当/ 的/ 检查点/ 数量/ 和/ 插入/ 位置/ ,/ 生成/ 规模/ 符合/ 空间/ 要求/ 的/ 追踪/ 控制程序/ ./ 检查点/ 的/ 设置/ 使得/ 用户/ 在/ 基于/ 重放/ 对/ 错误/ 进行/ 诊断/ 过程/ 中/ ,/ 既/ 能/ 自主/ 地/ 选择/ 轨迹/ 片段/ ,/ 又/ 可以/ 避免/ 对/ 执行/ 轨迹/ 中/ 位于/ 错误/ 根源/ 之前/ 的/ 部分/ 的/ 重放/ ,/ 降低/ 诊断/ 的/ 时间/ 开销/ ./ 5.3/ 追踪/ 时间/ 开销/ 本/ 节/ 分析/ 了/ 追踪/ 对/ 程序执行/ 时间/ 的/ 影响/ 程度/ 以及/ 关键/ 影响/ 因素/ ./ 追踪/ 程序/ 的/ 额外/ 执行/ 时间/ 开销/ 源于/ 3/ 个/ 部分/ :/ (/ 1/ )/ 插桩/ 库函数/ 的/ 执行/ ;/ (/ 2/ )/ 轨迹/ 数据/ 从/ 数据/ 缓冲区/ 写入/ 外部/ 存储空间/ ;/ (/ 3/ )/ 向/ 基站/ 传输/ 轨迹/ 记录/ ./ 本文/ 分别/ 测量/ 了/ 3/ 个/ 测试用例/ 由/ 追踪/ 带来/ 的/ 额表/ 8/ 追踪/ 的/ 时间/ 开销/ -/ 1693014790BlinkCTestSerialCO2EasyCollectionC/ 表/ 9/ 在/ 自/ 适应/ 插桩/ 的/ 前提/ 下/ ,/ 重新/ 统计/ 了/ 测试用例/ EasyCollectionC/ 从/ 开始/ 发送/ 消息/ ,/ 到/ 消息/ 发送/ 成功/ 之间/ 的/ 追踪/ 开销/ ,/ 以/ 测量/ 将/ 轨迹/ 数据/ 从/ 日志/ 缓冲区/ 写入/ 外部/ 存储空间/ 对/ 执行/ 时间/ 的/ 影响/ ,/ 实验/ 中将/ 日志/ 缓冲区/ (/ 即表/ 9/ 中/ trace/ _/ buffer/ 列/ )/ 分别/ 设为/ 1KB/ 和/ 3KB/ ./ 由表/ 9/ 可知/ ,/ 当/ 日志/ 缓冲区/ 大小/ 为/ 1KB/ ,/ 将/ 发生/ 两次/ 对外部/ 存储空间/ 的/ 写/ 操作/ ,/ 而/ 当/ 日志/ 缓冲区/ 大小/ 为/ 3KB/ 时/ ,/ 足以/ 存放/ 2404/ 字节/ 的/ 轨外/ 开销/ ./ 其中/ ,/ 对于/ BlinkC/ ,/ 测量/ 对象/ 是从/ 程序/ 开始/ 执行/ 到/ 断言/ 违反/ 位置/ 之间/ 的/ 追踪/ 开销/ ;/ 对于/ Test/ -/ SerialCO2/ ,/ 测量/ 对象/ 是/ 每个/ 抽样/ 周期/ 内/ 的/ 追踪/ 开销/ ;/ 而/ 对于/ 测试用例/ EasyCollectionC/ ,/ 我们/ 测量/ 了/ 一个/ 发送/ 方/ 结点/ 从/ 开始/ 发送/ 消息/ ,/ 到/ 消息/ 发送/ 成功/ 之间/ 的/ 轨迹/ 追踪/ 对/ 执行/ 时间/ 的/ 影响/ ./ 具体/ 测量方法/ 如下/ :/ 首先/ ,/ 在/ 测量/ 的/ 开始/ 位置/ 插入/ 一条/ 将/ 传感器/ 结点/ 第/ 3/ 针脚/ 的/ 电压/ 置/ 为/ 高/ 电压/ 的/ 指令/ ,/ 在/ 测量/ 的/ 结束/ 位置/ 插入/ 一条/ 将/ 传感器/ 结点/ 第/ 3/ 针脚/ 的/ 电压/ 置/ 为/ 低电压/ 的/ 指令/ ;/ 然后/ 使用/ NILabVIEW/ 软件/ 观测/ 高低/ 电压/ 变化/ 的/ 时间/ 间隔/ ,/ 即可/ 获得/ 从/ 测量/ 开始/ 位置/ 到/ 结束/ 位置/ 的/ 执行/ 时间/ ./ 测量/ 过程/ 中/ ,/ 默认/ 将/ RAM/ 中/ 1KB/ 的/ 空间/ 作为/ 存储/ 轨迹/ 数据/ 的/ 缓冲区/ (/ 以下/ 简称/ 日志/ 缓冲区/ )/ ,/ 仅当/ 记录/ 的/ 轨迹/ 数据/ 规模/ 到达/ 日志/ 缓冲区/ 上限/ 时/ ,/ 将/ 数据/ 写入/ 外部/ 存储空间/ ,/ 并/ 清空/ 日志/ 缓冲区/ ./ 表/ 8/ 在/ 仅/ 设置/ 单一/ 检查点/ 的/ 前提/ 下/ ,/ 测量/ 3/ 个/ 测试/ 对象/ 的/ 额外/ 追踪/ 开销/ ./ 其中/ ,/ trace/ _/ size/ 代表/ 轨迹/ 日志/ 规模/ ;/ orig/ _/ exe/ _/ time/ 和/ tracing/ _/ exe/ _/ time/ 分别/ 表示/ 插入/ 追踪/ 代码/ 前后/ 的/ 执行/ 时间/ ;/ overhead/ %/ 代表/ 追踪/ 引入/ 的/ 额外/ 时间/ 开销/ 占/ 原始/ 程序执行/ 时间/ 的/ 比例/ ./ 由于/ TestSerialCO2/ 的/ 每/ 两次/ 抽样/ 之间/ 有/ 较/ 长/ 的/ 空闲/ 周期/ ,/ 这些/ 空闲/ 周期/ 掩盖/ 了/ 追踪/ 的/ 额外/ 开销/ ,/ 故而/ 可以/ 忽略/ 轨迹/ 追踪/ 对/ 该/ 程序执行/ 时间/ 的/ 影响/ ./ 而/ 对于/ 测试用例/ BlinkC/ 和/ EasyCollectionC/ ,/ 追踪/ 带来/ 的/ 额外/ 执行/ 开销/ 分别/ 仅/ 占/ 原始/ 执行/ 时间/ 的/ 1.01/ %/ 和/ 13.32/ %/ ./ 此外/ ,/ 由于/ 针对/ 这/ 两个/ 程序/ 测量/ 得到/ 的/ 追踪/ 日志/ 规模/ 均/ 未/ 超过/ 日志/ 缓冲区/ 的/ 规模/ 上限/ ,/ 故表/ 8/ 所/ 测量/ 的/ 数据/ 并/ 不/ 包含/ 将/ 轨迹/ 数据/ 写入/ 外部/ 存储空间/ 的/ 开销/ ./ 迹/ 数据/ ,/ 故/ 不必/ 将/ 其/ 写入/ 外部/ 存储空间/ ./ 由表/ 9/ 可知/ ,/ 将/ 数据/ 写入/ 外部/ 存储空间/ 的/ 频率/ 是/ 影响/ 追踪/ 程序执行/ 时间/ 的/ 关键/ ,/ 频率/ 越高/ ,/ 开销/ 越大/ ;/ 而/ 提高/ 预设/ 的/ 日志/ 缓冲区/ 的/ 规模/ 是/ 减少/ 追踪/ 开销/ 的/ 方法/ 之一/ ./ 但/ 另一方面/ ,/ 提高/ 日志/ 缓冲区/ 的/ 规模/ ,/ 势必会/ 降低/ 存储/ 静态数据/ 和/ 运行/ 栈/ 的/ 空间/ ,/ 甚至/ 可能/ 出现/ 运行/ 栈/ 与/ 日志/ 缓冲区/ 或/ 静态数据/ 区相/ 重叠/ 的/ 问题/ ./ 为/ 预防/ 上述/ 问题/ ,/ 可以/ 在/ 链接/ 时/ 调整/ RAM/ 的/ 布局/ 和/ Page15/ 重/ 定位/ 的/ 目标/ 地址/ [/ 8/ ]/ ,/ 将/ 日志/ 缓冲区/ 和/ 静态数据/ 区/ 依次/ 放置/ 在/ RAM/ 的/ 最高/ 端/ ,/ 追踪/ 过程/ 中/ ,/ 一旦/ 检测/ 测试用例/ trace/ _/ size/ // Bytetrace/ _/ buffer/ // Byteorig/ _/ exe/ _/ time/ // μ/ stracing/ _/ exe/ _/ time/ // μ/ soverhead/ // %/ 表/ 9/ 追踪/ 的/ 时间/ 开销/ -/ 2EasyColectionC/ 本节/ 实验/ 数据/ 表明/ ,/ ADA/ 机制/ 通过/ 依赖/ 分析/ 和/ 自/ 适应/ 迭代/ 技术/ ,/ 不仅/ 能够/ 根据/ 系统资源/ 的/ 可用/ 情况/ 调整/ 追踪/ 的/ 空间/ 需求/ ,/ 使/ 基于/ 确定性/ 重放/ 的/ 调试/ 方法/ 能够/ 沿用/ 于/ 无线/ 传感器/ 网络/ 程序/ 的/ 错误诊断/ 中/ ,/ 还/ 有效/ 地/ 提高/ 了/ 错误诊断/ 的/ 效率/ ./ 6/ 相关/ 工作/ 面向/ 无线/ 传感器/ 网络应用/ 的/ 错误诊断/ 技术/ 可以/ 分为/ 3/ 类/ :/ 基于/ 模拟器/ 的/ 调试/ 技术/ 、/ 交互式/ 调试/ 技术/ 以及/ 通过/ 运行/ 时/ 监控/ 辅助/ 的/ 错误诊断/ 技术/ ./ 基于/ 模拟器/ 的/ 调试/ 平台/ 以/ Emstar/ [/ 9/ ]/ 、/ TOSSIM/ [/ 10/ ]/ 、/ S2DB/ [/ 11/ ]/ 等/ 为/ 代表/ ,/ 此类/ 方法/ 的/ 优势/ 在于/ 可以/ 在/ 系统/ 部署/ 之前/ 对/ 大规模/ 网络/ 环境/ 下/ 程序执行/ 情况/ 进行/ 模拟/ ,/ 但/ 缺点/ 是/ 无法/ 模拟/ 复杂多变/ 的/ 物理/ 环境/ ,/ 故而/ 并/ 不能/ 完全/ 替代/ 实际/ 设备/ 上/ 的/ 调试/ ./ 交互式/ 调试/ 技术/ 则/ 通过/ 远程/ 控制/ ,/ 使/ 传感器/ 结点/ 进入/ 调试/ 状态/ ,/ 而后/ ,/ 采用/ 由/ 用户/ 设置/ 断点/ 、/ 观察点/ 或/ 进行/ 单步/ 调试/ 的/ 方法/ 发掘/ 错误/ 源/ ./ 此类/ 技术/ 以/ Clairvoyant/ [/ 12/ ]/ 和/ Marionette/ [/ 13/ ]/ 为/ 代表/ ./ 前者/ 是/ 一个/ 面向/ 无线/ 、/ 嵌入式/ 网络/ 的/ 源代码/ 级/ 调试/ 环境/ ,/ 提供/ 诸如/ step/ 、/ break/ 、/ watch/ 、/ traceback/ 等/ 常用/ 调试/ 命令/ ;/ 后者/ 实现/ 了/ 一组/ 交互式/ 开发/ 、/ 调试/ 工具/ ,/ 提供/ 丰富/ 的/ 接口/ ,/ 允许/ 用户/ 使用/ PC/ 上/ 的/ 编程/ 、/ 调试/ 环境/ ,/ 如/ JavaGUI/ 、/ ./ NET/ ,/ 访问/ 无线/ 嵌入式/ 设备/ 上/ 运行/ 的/ 程序/ 的/ 函数调用/ 、/ 变量/ 读写/ 等/ 操作/ ./ 此类/ 技术/ 的/ 优势/ 是/ 贴近/ 传统/ 调试/ ,/ 适用/ 于/ 用户/ 对/ 错误/ 类型/ 以及/ 需要/ 关注/ 的/ 位置/ 有/ 明确/ 认识/ 的/ 情况/ ,/ 但/ 缺陷/ 在于/ ,/ 当/ 用户/ 对/ 错误/ 类型/ 及/ 相关/ 位置/ 毫无/ 头绪/ 时/ ,/ 此类/ 调试/ 方法/ 缺乏/ 效率/ ,/ 且/ 由于/ 并行程序/ 执行/ 过程/ 和/ 结果/ 的/ 不确定性/ ,/ 实际/ 运行/ 时/ 发生/ 的/ 错误/ 可能/ 在/ 调试/ 过程/ 中/ 不再/ 重现/ ./ 通过/ 运行/ 时/ 监控/ 辅助/ 错误诊断/ 的/ 方法/ 能够/ 提供/ 实际/ 设备/ 上/ 与/ 错误/ 相关/ 的/ 信息/ ,/ 但/ 缺点/ 在于/ :/ 需要/ 由/ 用户/ 设定/ 监控/ 的/ 位置/ 和/ 记录/ 的/ 日志/ 内容/ ,/ 且/ 无法/ 确保/ 记录/ 的/ 信息/ 与/ 错误/ 相关/ 或/ 足以/ 帮助/ 用户/ 定位/ 到/ 错误/ 根源/ ./ 其中/ ,/ Sympathy/ [/ 14/ ]/ 是/ 由/ 传感器/ 结点/ 定时/ 向/ 到/ 运行/ 栈/ 向下/ 溢出/ 或/ 即将/ 溢出/ 的/ 情况/ ,/ 则/ 提示/ 用户/ 调整/ 日志/ 缓冲区/ 的/ 大小/ ./ 14790/ 数据/ 汇聚/ 结点/ 主动/ 发送/ 选定/ 的/ 执行/ 信息/ ,/ 当/ 错误/ 出现/ 时/ ,/ 根据/ 基站/ 收集/ 到/ 的/ 执行/ 信息/ ,/ 使用/ 基于/ 决策树/ 的/ 方法/ 诊断/ 错误/ 源/ ./ PAD/ [/ 15/ ]/ 是/ 一个/ 轻量级/ 的/ 无线/ 传感器/ 网络/ 诊断/ 工具/ ,/ 采用/ 分组/ 标记/ 算法/ 收集/ 并/ 维护/ 一个/ 概率/ 推论/ 模型/ ,/ 推演/ 导致/ 程序/ 不/ 正常/ 行为/ 的/ 原因/ ./ DT/ [/ 16/ ]/ 设计/ 了/ 一种/ traceSQL/ 语言/ 来/ 描述/ 调试/ 行为/ ,/ 这些/ 称作/ “/ tracepoint/ ”/ 的/ 调试/ 行为/ 可以/ 在/ 程序运行/ 时热/ 插入/ 或/ 热/ 删除/ ./ PD2/ [/ 17/ ]/ 关注/ 导致/ 性能/ 不佳/ 的/ 原因/ ,/ 比如/ 重要/ 数据/ 丢失/ 、/ 数据流/ 延迟/ 等/ ./ InterfacecontractsforTinyOS/ [/ 18/ ]/ 通过/ 为/ 函数调用/ 插入/ 前置/ 、/ 后置/ 断言/ 的/ 方法/ 实现/ 静态/ 检测/ ./ PDA/ [/ 19/ ]/ 则/ 为/ 用户/ 提供/ 了/ 一种/ 形式化/ 地/ 描述/ 结点/ 状态/ 的/ 简单/ 语言/ ,/ 并/ 采用/ 主动/ 抓包/ (/ packetsniffing/ )/ 方法/ 收集/ 信息/ ,/ 判断/ 用户/ 书写/ 的/ 断言/ 是否/ 得到/ 满足/ ./ T/ -/ check/ [/ 20/ ]/ 使用/ 基于/ TOSSIM/ 模拟器/ 的/ 静态/ 空间/ 搜索/ 方法/ 检测/ 程序/ 错误/ ,/ 但/ 由于/ TOSSIM/ 模拟器/ 不/ 提供/ 对/ 中断/ 的/ 模拟/ ,/ 该/ 工具/ 无法/ 检测/ 以下/ 几类/ 错误/ :/ 时序/ 错误/ 、/ 并发/ 错误/ 以及/ 底层/ 设备/ 中/ 存在/ 的/ 错误/ ./ 确定性/ 重/ 放/ 技术/ 是/ 并行/ 程序调试/ 的/ 基础/ ./ 在/ 过去/ 20/ 年间/ ,/ 如何/ 以/ 尽可能/ 小/ 的/ 时空/ 开销/ 来/ 记录/ 并/ 重现/ 并行程序/ 的/ 执行/ 轨迹/ ,/ 一直/ 是/ 研究/ 人员/ 和/ 工业界/ 关注/ 的/ 热点/ ,/ 一些/ 国内外/ 知名/ 的/ 公司/ 也/ 分别/ 设计/ 了/ 各自/ 的/ 确定性/ 重/ 放/ 框架/ ,/ 如/ :/ 微软/ 基于/ Nirvana/ 模拟器/ 以及/ iDNA/ 轨迹/ 读写/ 工具/ 开发/ 的/ 确定性/ 重/ 放/ 框架/ [/ 5/ ]/ 、/ 英特尔/ 以/ 二进制/ 插装库/ PIN/ 为/ 基础/ 设计/ 并/ 实现/ 的/ 重放/ 工具/ Pinplay/ [/ 6/ ]/ ./ 迄今为止/ ,/ 关于/ 确定性/ 重/ 放/ 领域/ 的/ 研究/ 大致/ 可/ 分为/ 两类/ :/ 纯/ 软件/ 插桩/ 方法/ 和/ 借助/ 硬件/ 辅助/ 的/ 方法/ ./ 前者/ 具备/ 跨/ 机器/ 和/ 跨平台/ 重放/ 的/ 优势/ ,/ 但/ 时空/ 开销/ 高昂/ ;/ 后者/ 强调/ 通过/ 少量/ 的/ 额外/ 硬件/ 支持/ ,/ 可以/ 显著/ 地/ 降低/ 追踪/ 和/ 重放/ 的/ 时空/ 开销/ ,/ 但/ 不/ 便于/ 推广/ ./ 受到/ 有限/ 的/ 存储/ 和/ 通信/ 资源/ 以及/ 传感器/ 结点/ 对/ 硬件/ 设计/ 及/ 功耗/ 的/ 限制/ ,/ 上述/ 方法/ 均/ 不适/ 用于/ 无线/ 传感器/ 网络/ 程序/ 的/ 调试/ ./ 7/ 结论/ 无线/ 传感器/ 网络/ 是/ 物/ 联网/ 得以/ 实现/ 的/ 重要/ 基/ Page16/ 础/ ./ 然而/ ,/ 无线/ 传感器/ 网络/ 的/ 大规模/ 部署/ 和/ 管理/ 迄今/ 仍/ 面临/ 诸多/ 挑战/ ,/ 其中/ 重要/ 的/ 阻碍/ 因素/ 是/ 无线/ 传感器/ 网络/ 上/ 的/ 程序/ 错误/ 难以/ 诊断/ ./ 针对/ 上述/ 问题/ ,/ 本文/ 提出/ 一种/ 以/ 依赖/ 分析/ 为/ 基础/ ,/ 采用/ 自/ 适应/ 的/ 源码/ 级/ 追踪/ 和/ 重放/ 技术/ 辅助/ 无线/ 传感器/ 网络/ 程序/ 错误诊断/ 的/ 机制/ ADA/ ,/ 并/ 在/ open64/ 编译器/ 上/ 实现/ 了/ 一个/ 面向/ TinyOS/ 程序/ 的/ 原型/ ./ 实验/ 数据/ 表明/ ,/ 该/ 机制/ 能够/ 有效/ 地/ 减轻/ 程序员/ 的/ 错误诊断/ 负担/ ,/ 提高/ 无线/ 传感器/ 网络/ 中/ 错误诊断/ 的/ 效率/ ./ 本文/ 的/ 后续/ 工作/ 将/ 以/ 自动化/ 调试/ 为/ 重点/ ,/ 进一步/ 辅助/ 程序员/ 高效/ 定位/ 错误/ 根源/ ./ 

