Page1/ 一种/ 基于/ 动态/ 依赖/ 关系/ 的/ 类/ 集成/ 测试方法/ 张艳梅/ 姜淑娟/ 张红昌/ (/ 中国矿业大学/ 计算机科学/ 与/ 技术/ 学院/ 江苏/ 徐州/ 221116/ )/ 摘要/ 类间/ 集成/ 测试/ 是/ 面向对象/ 软件测试/ 的/ 重要/ 组成部分/ ,/ 合适/ 的/ 测试/ 顺序/ 能够/ 极大/ 地/ 节省/ 测试/ 成本/ ./ 类间/ 依赖/ 关系/ 构成/ 环路/ 的/ 情况/ 下/ ,/ 需要/ 删除/ 某些/ 依赖/ 关系/ 以/ 消除/ 环路/ ,/ 同时/ 需要/ 引进/ 测试/ 桩/ ./ 忽略/ 类间/ 动态/ 依赖/ 关系/ 导致/ 测试/ 桩/ 的/ 数目/ 不足/ ,/ 难以完成/ 测试/ ./ 文中/ 提出/ 一种/ 基于/ 动态/ 依赖/ 关系/ 的/ 类/ 集成/ 测试方法/ ./ 首先/ 分析/ 了/ 类/ 之间/ 的/ 静态/ 依赖/ 和/ 动态/ 依赖/ 关系/ ;/ 然后/ 在/ 保证/ 测试/ 桩/ 的/ 数目/ 尽可能少/ 的/ 前提/ 下/ ,/ 给出/ 了/ 边/ 的/ 删除/ 规则/ 以及/ 消除/ 由/ 静态/ 依赖/ 关系/ 和/ 动态/ 依赖/ 关系/ 形成/ 的/ 环路/ 的/ 算法/ ,/ 在/ 此基础/ 上/ ,/ 进一步/ 提出/ 测试/ 顺序/ 分配/ 策略/ 和/ 算法/ ;/ 最后/ 针对/ 提出/ 的/ 方法/ 开发/ 了/ 基于/ 测试/ 级/ 的/ 类/ 测试/ 序列/ 自动/ 生成/ 工具/ —/ —/ —/ TLOG/ ./ 实验/ 结果表明/ :/ 该/ 方法/ 较/ 其它/ 方法/ 需要/ 较少/ 的/ 测试/ 桩/ ,/ 测试/ 效率/ 有/ 明显提高/ ./ 关键词/ 集成/ 测试/ ;/ 测试/ 顺序/ ;/ 测试/ 桩/ ;/ 动态/ 依赖/ ;/ 测试/ 级/ 1/ 引言/ 集成/ 测试/ 中/ 最/ 重要/ 的/ 问题/ [/ 1/ ]/ ./ 不同/ 的/ 类/ 测试/ 序列/ ,/ 需要/ 不同/ 的/ 测试/ 代价/ ,/ 所以/ ,/ 尽可能减少/ 测试/ 代价/ 是/ 确定/ 类间/ 测试/ 顺序/ 的/ 重要/ 目标/ ./ 如果/ 类/ 的/ 静态/ 依赖/ 关/ 面向对象/ 程序/ 中/ ,/ 类间/ 测试/ 顺序/ 的/ 确定/ 是/ 类间/ 系中/ 不/ 存在/ 环路/ ,/ 类间/ 测试/ 顺序/ 问题/ 可以/ 通过/ 简单/ Page2/ 的/ 逆向/ 拓扑/ 排序/ 来/ 解决/ ,/ 而/ 对于/ 存在/ 环路/ 的/ 情况/ ,/ 测试人员/ 必须/ 从/ 对象/ 关系/ 图中/ 删除/ 某些/ 依赖/ 关系/ ,/ 以/ 打破/ 其中/ 的/ 环路/ ./ 在/ 删除/ 依赖/ 关系/ 时/ ,/ 需要/ 引进/ 测试/ 桩/ ./ 测试/ 桩/ 指/ 的/ 是/ 当/ C1/ 依赖/ C2/ ,/ 增量/ 集成/ 过程/ 中/ ,/ C1/ 集成/ 时/ ,/ 但/ C2/ 尚未/ 被/ 集成/ ,/ 用来/ 模拟/ C2/ 的/ 服务/ 组件/ ./ 节省/ 测试/ 成本/ 是/ 选择/ 测试/ 顺序/ 的/ 一个/ 重要/ 目标/ ,/ 而/ 在/ 面向对象/ 程序/ 的/ 测试/ 中/ ,/ 开发/ 测试/ 桩/ 是/ 一项/ 成本/ 很/ 高/ 的/ 工作/ ,/ 这/ 是因为/ 根据/ 测试/ 桩/ 的/ 定义/ 可知/ ,/ 测试/ 桩/ 需要/ 模拟/ 的/ 是/ 待/ 测试/ 对象/ 所/ 依赖/ 的/ 类/ 的/ 服务/ 组件/ ,/ 而/ 由于/ 一个/ 类/ 的/ 对象/ 行为/ 依赖于/ 对象/ 当前/ 状态/ ,/ 并且/ 一个/ 行为/ 需要/ 涉及/ 到/ 多个/ 对象/ ,/ 因此/ 要/ 准确/ 地/ 模拟/ 一个/ 类/ 的/ 对象/ 行为/ 需要/ 理解/ 所有/ 与/ 之/ 相关/ 的/ 类/ 的/ 对象/ 行为/ ,/ 所以/ 节省/ 开发/ 测试/ 桩/ 的/ 开销/ 是/ 确定/ 类间/ 测试/ 顺序/ 的/ 一个/ 重要/ 任务/ ./ 减少/ 开发/ 测试/ 桩/ 成本/ 的/ 方法/ 主要/ 有/ 两类/ :/ 一类/ 是/ 最小化/ 所/ 需/ 测试/ 桩/ 的/ 数目/ ,/ 另一类/ 是/ 最小化/ 测试/ 桩/ 的/ 复杂度/ ./ 测试/ 桩/ 复杂度/ 是/ 用来/ 衡量/ 构造/ 一个/ 测试/ 桩/ 的/ 难易/ 程度/ ./ 测试/ 桩/ 的/ 复杂度/ 不易控制/ ,/ 因为/ :/ (/ 1/ )/ 测试/ 桩/ 的/ 复杂度/ 标准/ 难以/ 制定/ ,/ Kraft/ 等/ 人/ [/ 2/ ]/ 提出/ 了/ 一套/ 测试/ 桩/ 的/ 复杂性/ 标准/ ,/ 但/ 根据/ 案例/ 研究/ 表明/ ,/ 他们/ 的/ 标准/ 在/ 某些/ 情况/ 下/ 并/ 不/ 可行/ ;/ (/ 2/ )/ 测试/ 桩/ 的/ 复杂度/ 在/ 某种程度/ 上/ 取决于/ 开发人员/ 的/ 编程/ 能力/ ,/ 由于/ 面向对象编程/ 具有/ 极大/ 的/ 灵活性/ ,/ 不同/ 开发/ 背景/ 的/ 程序员/ 开发/ 同一个/ 类/ 的/ 测试/ 桩/ ,/ 完全/ 有/ 可能/ 生成/ 复杂度/ 相差/ 很大/ 的/ 测试/ 桩/ ;/ (/ 3/ )/ Tai/ 等/ 人/ [/ 3/ ]/ 将/ 测试/ 顺序/ 应用/ 到/ 集成/ 测试/ 中/ ,/ 他们/ 证明/ 先/ 构造/ 类/ 的/ 测试/ 顺序/ ,/ 然后/ 按照/ 类/ 的/ 测试/ 顺序/ 来/ 进行/ 集成/ 测试/ 的/ 方法/ ,/ 可以/ 在/ 一定/ 程度/ 上/ 减少/ 测试/ 桩/ 的/ 数量/ ./ 因此/ ,/ 我们/ 采用/ 的/ 是/ 最小化/ 测试/ 桩/ 数目/ 的/ 方法/ ./ 现有/ 类间/ 测试/ 顺序/ 研究/ 方法/ 大多/ 只/ 限于/ 静态/ 分析/ [/ 1/ ,/ 4/ -/ 6/ ]/ ,/ 而/ 类间/ 的/ 动态/ 依赖/ 关系/ 比较/ 普遍/ ,/ 动态/ 依赖/ 关系/ 同样/ 会/ 导致/ 类/ 关系/ 图/ 中环/ 的/ 形成/ ,/ 对/ 类间/ 测试/ 序列/ 产生/ 影响/ ,/ 在/ 删除/ 动态/ 依赖/ 关系/ 时/ ,/ 需要/ 引进/ 动态/ 依赖/ 关系/ 测试/ 桩/ ./ 忽略/ 类间/ 动态/ 依赖/ 关系/ 将/ 导致/ 测试/ 桩/ 的/ 数目/ 不足/ ,/ 使得/ 测试/ 不/ 充分/ ./ 本文/ 主要/ 研究/ 基于/ 动态/ 依赖/ 关系/ 的/ 类/ 测试/ 顺序/ 的/ 确定/ 方法/ ,/ 解决/ 忽略/ 类间/ 动态/ 依赖/ 关系/ 所/ 导致/ 的/ 测试/ 桩/ 的/ 数目/ 不足/ 而/ 难以完成/ 测试/ 的/ 问题/ ,/ 通过/ 花费/ 尽可能少/ 的/ 测试/ 桩/ 找到/ 一个/ 最佳/ 的/ 测试/ 顺序/ ./ 需要/ 解决/ 两个/ 问题/ :/ 静态/ 依赖/ 关系/ 和/ 动态/ 依赖/ 关系/ 构成/ 的/ 环路/ 中边/ 的/ 删除/ 规则/ 以及/ 类/ 测试/ 顺序/ 分配/ 策略/ ./ 针对/ 要/ 解决/ 的/ 问题/ ,/ 为/ 测试/ 提供/ 足够/ 的/ 测试/ 桩/ ,/ 同时/ 遵循/ 满足/ 构造/ 的/ 测试/ 桩/ 最少/ 的/ 原则/ ,/ 本文/ 首先/ 提出/ 一组/ 由/ 静态/ 依赖/ 关系/ 和/ 动态/ 依赖/ 关系/ 构成/ 的/ 环路/ 中边/ 的/ 删除/ 规则/ ,/ 通过/ 删除/ 弱/ 联系/ 边/ ,/ 解决/ 已有/ 方法/ 中断/ 开/ 继承/ 、/ 组合/ 和/ 聚集/ 等/ 强/ 联系/ 关系/ 增加/ 测试/ 成本/ 的/ 问题/ ;/ 然后/ 在/ 消除/ 环路/ 的/ 基础/ 上/ 给出/ 基于/ 测试/ 级/ 的/ 测试/ 顺序/ 分配/ 策略/ ./ 2/ 类间/ 的/ 依赖/ 关系/ 面向对象/ 程序/ 类间/ 的/ 依赖/ 关系/ 主要/ 包括/ 两类/ :/ 一类/ 是/ 静态/ 依赖/ 关系/ ,/ 一类/ 是/ 动态/ 依赖/ 关系/ ./ 静态/ 依赖/ 关系/ 指/ 的/ 是/ 整个/ 程序代码/ 的/ 静态/ 结构/ 中/ 反映/ 出来/ 的/ 类/ 与/ 类/ 之间/ 的/ 关系/ ./ 动态/ 依赖/ 关系/ 是/ 指类/ 在/ 程序运行/ 期间/ 形成/ 的/ 一种/ 依赖/ 关系/ ./ 2.1/ 类间/ 的/ 静态/ 依赖/ 关系/ 静态/ 依赖/ 关系/ 指/ 的/ 是/ 整个/ 程序代码/ 的/ 静态/ 结构/ 中/ 反映/ 出来/ 的/ 类/ 与/ 类/ 之间/ 的/ 关系/ ./ 面向对象/ 程序/ 中/ ,/ 类间/ 的/ 静态/ 关系/ 主要/ 有/ 继承/ 关系/ 、/ 聚集/ 关系/ 和/ 关联/ 关系/ ./ (/ 1/ )/ 继承/ 指/ 的/ 是/ 子类/ 可以/ 共享/ 父类/ (/ 或/ 祖先/ 类/ )/ 属性/ 和/ 操作/ ./ 父类/ 中/ 定义/ 了/ 其/ 所有/ 子类/ 的/ 公共/ 属性/ 和/ 操作/ ,/ 在/ 子类/ 中/ 除了/ 定义/ 自己/ 特有/ 的/ 属性/ 和/ 操作/ 外/ ,/ 还/ 可以/ 对/ 父类/ (/ 或/ 祖先/ 类/ )/ 中/ 的/ 操作/ 重新/ 定义/ 其/ 实现/ 方法/ ./ 如果/ 类/ A/ 继承/ 类/ B/ ,/ 则/ 类/ A/ 称为/ 类/ B/ 的/ 子类/ ,/ 并且/ 类/ A/ 能/ 继承/ 类/ B/ 的/ 成员/ (/ 数据/ 成员/ 和/ 成员/ 方法/ )/ ./ (/ 2/ )/ 如果/ 类/ A/ 聚集/ 类/ B/ ,/ 则/ 说明/ 类/ A/ 的/ 数据/ 成员/ 具有/ 一个/ 或/ 多个/ 类/ B/ 的/ 实例/ ./ (/ 3/ )/ 关联/ 表示/ 类/ 的/ 实例/ 之间/ 存在/ 的/ 某种/ 关系/ ,/ A/ 的/ 实例/ 映射/ 到/ B/ 的/ 实例/ ,/ 这种/ 关系/ 叫/ 关联/ ./ 如果/ 类/ A/ 关联/ 类/ B/ ,/ 则/ 说明/ 类/ A/ 的/ 成员/ 方法/ 使用/ 了/ 类/ B/ 的/ 实例/ (/ 如/ ,/ 类/ A/ 的/ 成员/ 方法/ 包含/ B/ 类型/ 的/ 参数/ 或/ 成员/ 方法/ 内部/ 包含/ B/ 类型/ 的/ 局部变量/ )/ ./ 对于/ 基于/ 图论/ 的/ 方法/ ,/ 类簇/ 以及/ 它们/ 之间/ 的/ 关系/ 可以/ 抽象/ 为/ 对象/ 关系/ 图/ (/ ORD/ )/ [/ 1/ ]/ ,/ ORD/ 用/ 一个/ 有向图/ G/ (/ V/ ,/ E/ )/ 表示/ ,/ 其中/ ,/ V/ 是/ 由/ 一组/ 代表/ 类/ 的/ 节点/ 构成/ 的/ 集合/ ,/ E/ 是/ 由/ 一组/ 代表/ 类间/ 关系/ 的/ 有/ 向/ 边/ 构成/ 的/ 集合/ ./ 图/ 1/ 显示/ 了/ 一个/ 典型/ 的/ ORD/ ./ 图/ 1/ 是/ 对象/ 关系/ 图/ (/ ORD/ )/ 示例/ ./ 图中/ 节点/ 表示/ 程序/ 中/ 的/ 类/ ,/ 实心/ 有/ 向/ 边/ 表示/ 类/ 之间/ 的/ 继承/ 、/ 聚集/ 和/ 关联/ 关系/ ./ 对于/ 任何/ 类/ C1/ 到/ C2/ 之间/ 的/ 有/ 向/ 边/ :/ (/ 1/ )/ 标有/ I/ 的/ 边/ 表示/ C1/ 是/ C2/ 的/ 子类/ ;/ (/ 2/ )/ 标有/ Ag/ 的/ 边/ 表示/ C1/ 是/ C2/ 的/ 一个/ 聚集/ 类/ (/ C1/ 包含/ 一个/ 或/ 多个/ C2/ 对象/ )/ ;/ Page3/ (/ 3/ )/ 标有/ As/ 的/ 边/ 表示/ C1/ 与/ C2/ 关联/ ./ 类/ 之间/ 的/ 继承/ 、/ 聚集/ 和/ 关联/ 关系/ 使得/ 在/ 整个/ ORD/ 中/ 存在/ 着/ 依赖/ 关系/ ./ 准确/ 地说/ ,/ ORD/ 描述/ 的/ 是/ 类/ 之间/ 的/ 静态/ 依赖/ 关系/ ./ 我们/ 可以/ 依据/ 文献/ [/ 7/ ]/ 中对类/ 之间/ 静态/ 依赖/ 关系/ 的/ 定义/ 来/ 进行/ 判断/ ./ 定义/ 1/ ./ 对于/ 一个/ ORD/ 中/ 的/ 类/ X/ 和/ Y/ ,/ X/ 静态/ 依赖/ Y/ ,/ 当且/ 仅/ 当/ 在/ ORD/ 中/ 存在/ 一条/ 从/ X/ 到/ Y/ 的/ 有/ 向/ 路径/ ./ 令/ Rs/ 表示/ ORD/ 中/ 一条/ 有/ 向/ 边/ 的/ 二元关系/ :/ Rs/ =/ {/ (/ C1/ ,/ C2/ )/ |/ 在/ ORD/ 中/ 存在/ 一条/ 从/ C1/ 到/ C2/ 边/ }/ ,/ 则/ 类/ X/ 静态/ 依赖/ 的/ 类/ 的/ 集合/ S/ (/ X/ )/ =/ {/ Y/ |/ 〈/ X/ ,/ Y/ 〉/ ∈/ Rs/ +/ }/ ,/ 其中/ ,/ Rs/ +/ 表示/ Rs/ 的/ 传递/ 闭包/ ./ 例如/ ,/ 图/ 1/ 所示/ 为/ 一个/ 面向对象/ 程序/ P/ 中/ 的/ 5/ 个类/ {/ 教师/ ,/ 学生/ ,/ 课程/ ,/ 本科生/ ,/ 成绩/ }/ 构成/ 的/ ORD/ ./ 其中/ ,/ 本科生/ 是/ 学生/ 的/ 一个/ 子类/ ,/ 学生/ 和/ 课程/ 是/ 成绩/ 的/ 聚集/ 类/ 以及/ 学生/ 关联/ 课程/ 、/ 课程/ 关联/ 教师/ 等/ ./ 对于/ 面向对象/ 集成/ 测试/ 中/ 的/ 每/ 一个/ 类/ ,/ 可用/ 一个/ 类/ 的/ 集合/ S/ (/ X/ )/ 对类/ 的/ 静态/ 依赖/ 关系/ 进行/ 描述/ ./ S/ (/ X/ )/ 表示/ X/ 在/ 编译/ 阶段/ 静态/ 依赖/ 的/ 类/ 的/ 集合/ ./ 2.2/ 类/ 之间/ 的/ 动态/ 依赖/ 关系/ 动态/ 依赖/ 关系/ 是/ 指类/ 在/ 程序运行/ 时期/ 形成/ 的/ 一种/ 依赖/ 关系/ ./ 若类/ A/ 继承/ 于类/ B/ ,/ 且/ 重写/ 了/ 类/ B/ 的/ 虚/ 方法/ ;/ 类/ B/ 是/ 类/ C/ 的/ 服务/ 类/ ,/ 即/ C/ 要么/ 和/ B/ 相关联/ 要么/ 是/ B/ 的/ 聚集/ 类/ ,/ 且/ 调用/ 了/ 类/ B/ 中/ 被/ 类/ A/ 重写/ 的/ 虚/ 方法/ ,/ 则/ 在/ 程序运行/ 时期/ ,/ C/ 和/ B/ 的/ 子类/ A/ 动态/ 绑定/ ,/ 类/ C/ 动态/ 依赖于/ 类/ A/ ./ 如果/ 类/ A/ 继承/ 于类/ B/ ,/ 类/ B/ 是/ 类/ C/ 的/ 服务/ 类/ ,/ 即/ C/ 要么/ 和/ B/ 相关联/ 要么/ 是/ B/ 的/ 聚集/ 类/ ,/ 则/ 在/ 程序运行/ 时期/ ,/ C/ 可能/ 会/ 和/ B/ 的/ 子类/ A/ 动态/ 绑定/ ,/ 类/ C/ 可能/ 会/ 动态/ 依赖于/ 类/ A/ ./ 本文/ 是/ 在/ ORD/ 的/ 基础/ 上/ 进行/ 类间/ 分析/ 的/ ,/ 因此/ 我们/ 将/ 可能/ 存在/ 的/ 动态/ 依赖/ 关系/ 都/ 标记/ 在/ ORD/ 中/ ./ 下面/ 给出/ 动态/ 依赖/ 关系/ 的/ 定义/ ./ 定义/ 2/ [/ 7/ ]/ ./ 类间/ 的/ 动态/ 依赖/ 关系/ 用/ Rd/ 表示/ ,/ 令/ Rd/ =/ {/ 〈/ C1/ ,/ C3/ 〉/ |/ 存在/ 一个/ 类/ C2/ ,/ 它/ 是/ C3/ 的/ 父类/ ,/ 且/ C2/ 被/ C1/ 调用/ }/ ,/ 则/ 类/ X/ 动态/ 依赖/ 的/ 类/ 的/ 集合/ D/ (/ X/ )/ =/ {/ Z/ |/ 〈/ X/ ,/ Z/ 〉/ ∈/ Rd/ +/ }/ ,/ 其中/ ,/ Rd/ +/ 表示/ Rd/ 的/ 传递/ 闭包/ ./ 我们/ 可以/ 从类/ 之间/ 的/ 静态/ 依赖/ 关系/ 得出/ 动态/ 依赖/ 关系/ ,/ 例如/ :/ 图/ 2/ 中/ ,/ 教师/ 关联/ 学生/ ,/ 学生/ 是/ 本科生/ 的/ 父类/ ,/ 在/ 执行/ 阶段/ ,/ 教师/ 可能/ 动态/ 依赖于/ 本科生/ ./ 动态/ 依赖边/ Dy/ 用/ 虚线/ 有/ 向/ 边/ 表示/ ./ 推论/ 1/ ./ 由/ 定义/ 1/ 和/ 定义/ 2/ 我们/ 可以/ 推导/ 出类/ X/ 在/ 编译/ 阶段/ 静态/ 依赖/ 和/ 在/ 执行/ 阶段/ 动态/ 依赖/ 的/ 类/ 的/ 集合/ SD/ (/ X/ )/ =/ {/ Ck/ |/ 〈/ X/ ,/ Ck/ 〉/ ∈/ (/ Rs/ +/ ∪/ Rd/ +/ )/ }/ ./ 证明/ ./ 由/ SD/ (/ X/ )/ 的/ 定义/ 可知/ ,/ SD/ (/ X/ )/ =/ S/ (/ X/ )/ ∪/ D/ (/ X/ )/ ./ 由/ S/ (/ X/ )/ 和/ D/ (/ X/ )/ 的/ 定义/ 可知/ ,/ S/ (/ X/ )/ =/ {/ Y/ |/ 〈/ X/ ,/ Y/ 〉/ ∈/ Rs/ +/ }/ ,/ D/ (/ X/ )/ =/ {/ Z/ |/ 〈/ X/ ,/ Z/ 〉/ ∈/ Rd/ +/ }/ ,/ 则/ SD/ (/ X/ )/ =/ {/ Y/ ∪/ Z/ |/ 〈/ X/ ,/ Y/ 〉/ ∈/ Rs/ +/ ,/ 〈/ X/ ,/ Z/ 〉/ ∈/ Rd/ +/ }/ 成立/ ,/ 令/ Ck/ =/ Y/ ∪/ Z/ ./ 由于/ 二元关系/ 可以/ 用/ 笛卡尔/ 积来/ 表示/ ,/ 因此/ ,/ X/ 与/ Y/ 的/ 二元关系/ X/ →/ Y/ 可以/ 记为/ X/ ×/ Y/ ∈/ Rs/ +/ ,/ X/ 与/ Z/ 的/ 二元关系/ X/ →/ Z/ 可以/ 记为/ X/ ×/ Z/ ∈/ Rd/ +./ 因此/ ,/ X/ 与/ Ck/ 的/ 二元关系/ X/ →/ Ck/ (/ 即/ X/ →/ (/ Y/ ∪/ Z/ )/ )/ 可以/ 记为/ X/ ×/ Ck/ =/ X/ ×/ (/ Y/ ∪/ Z/ )/ =/ (/ X/ ×/ Y/ )/ ∪/ (/ X/ ×/ Z/ )/ =/ Rs/ +/ ∪/ Rd/ +./ 因此/ ,/ SD/ (/ X/ )/ =/ {/ Ck/ |/ 〈/ X/ ,/ Ck/ 〉/ ∈/ (/ Rs/ +/ ∪/ Rd/ +/ )/ }/ ./ 定义/ 3/ ./ 扩展/ 的/ 对象/ 关系/ 图/ (/ EORD/ )/ ./ 在/ 对象/ 关系/ 图/ ORD/ 中/ 增加/ 表示/ 动态/ 依赖/ 关系/ 的/ 边/ ,/ 用/ 标有/ Dy/ 的/ 虚线/ 边/ 表示/ ,/ 可/ 得到/ 扩展/ 的/ 对象/ 关系/ 图/ ,/ 记为/ EORD/ =/ {/ V/ ,/ E/ }/ ,/ 其中/ ,/ V/ 为/ 表示/ 程序/ 中/ 的/ 各个/ 类/ 节点/ ,/ E/ =/ {/ EI/ ∪/ EAg/ ∪/ EAs/ ∪/ EDy/ }/ ,/ EI/ 、/ EAg/ 、/ EAs/ 分别/ 表示/ 类间/ 继承/ 边/ 、/ 聚集/ 边/ 和/ 关联/ 边/ ./ 图/ 1/ 的/ ORD/ 中/ 没有/ 包含/ 动态/ 依赖/ 信息/ ,/ 图/ 2/ 是/ 扩展/ 后/ 的/ 对象/ 关系/ 图/ (/ EORD/ )/ ,/ 其中/ 动态/ 依赖/ 用/ 虚线/ 箭头/ 表示/ ,/ 如类/ 教师/ 与/ 类/ 本科生/ 之间/ 存在/ 动态/ 依赖/ ./ 图/ 1/ 中/ 存在/ 一个/ 环路/ :/ 教师/ →/ 学生/ →/ 课程/ →/ 教师/ ./ 但是/ ,/ 由于/ 动态/ 绑定/ 特性/ ,/ 当/ 测试/ 类/ 教师/ 时/ ,/ 类/ 本科生/ 中/ 的/ 方法/ 可能/ 被/ 执行/ ./ 也就是说/ ,/ 在/ 程序执行/ 阶段/ ,/ 类/ 教师/ 可能/ 依赖/ 类/ 本科生/ ,/ 类/ 成绩/ 可能/ 依赖/ 类/ 本科生/ ./ 所以/ ,/ 正确/ 的/ 依赖/ 如图/ 2/ 所示/ ./ 图/ 2/ 中/ 存在/ 两个/ 环路/ ,/ 使/ 原来/ 的/ ORD/ 的/ 环路/ 增加/ ./ 为了/ 确定/ 类/ 测试/ 序/ ,/ 需要/ 消除/ 在/ 图/ 1/ 和/ 图/ 2/ 两种/ 情况/ 下/ 的/ 环路/ ./ 由于/ 动态/ 依赖边/ 的/ 引入/ 对/ 环路/ 产生/ 影响/ ,/ 因此/ 消除/ Page4/ 环路/ 时所/ 删除/ 的/ 边/ 也/ 需要/ 随之/ 变化/ ./ 3/ 消除/ 环路/ 算法/ 对于/ 存在/ 环路/ 的/ EORD/ ,/ 需要/ 消除/ 环路/ 进而/ 给出/ 类间/ 测试/ 序列/ ./ 因此/ ,/ 确定/ 类间/ 测试/ 顺序/ 的/ 核心/ 问题/ 就是/ 打破/ 环路/ ./ Kung/ 等/ 人/ [/ 1/ ]/ 、/ Kraft/ 等/ 人/ [/ 2/ ]/ 、/ Bri/ -/ and/ 等/ 人/ [/ 8/ ]/ 都/ 认为/ 给/ 不同/ 类型/ 的/ 边/ 创建/ 测试/ 桩/ 的/ 难易/ 程度/ 的/ 高低/ 和/ 代价/ Cost/ (/ C/ )/ 均/ 存在/ 如下/ 关系/ :/ C/ (/ 关联/ 边/ )/ =/ C/ (/ 动态/ 依赖边/ )/ </ C/ (/ 聚集/ 边/ )/ / C/ (/ 继承/ 边/ )/ ./ 因此/ ,/ 他们/ 称/ 继承/ 关系/ 和/ 聚集/ 关系/ 为强/ 联系/ 关系/ ,/ 动态/ 依赖/ 关系/ 与/ 关联/ 关系/ 均/ 为/ 弱/ 联系/ 关系/ ./ 为了/ 减少/ 测试/ 代价/ ,/ 本文/ 消除/ 环路/ 时/ 避免/ 删除/ 强/ 联系/ 边/ ;/ 同时/ ,/ 由于/ 本文/ 的/ 解决方案/ 旨在/ 降低/ 测试/ 桩/ 的/ 数目/ ,/ 因此/ ,/ 我们/ 在/ 打破/ 环路/ 的/ 过程/ 中/ 遵循/ 删除/ 涉及/ 环路/ 最多/ 的/ 关联/ 边/ 或者/ 动态/ 依赖边/ 的/ 规则/ ./ 其中/ 关键问题/ 是/ 首先/ 需要/ 识别/ 出/ EORD/ 中由类/ 以及/ 它们/ 之间/ 的/ 依赖/ 关系/ 形成/ 的/ 强/ 连通/ 分量/ (/ SCCs/ )/ ,/ 然后/ 查找/ 每/ 一个/ 子强/ 连通/ 分量/ (/ SCCi/ )/ 中/ 所有/ 的/ 环路/ ,/ 统计/ SCCi/ 中/ 每条/ 动态/ 依赖边/ 和/ 关联/ 边/ 所/ 涉及/ 的/ 环路/ 数目/ ,/ 进而/ 将/ 一个/ 有/ 环图/ 消除/ 环路/ 成为/ 一个/ 无环图/ ./ 3.1/ EORD/ 中/ 的/ 环路/ 对于/ EORD/ 中由类/ 以及/ 它们/ 之间/ 的/ 依赖/ 关系/ 形成/ 的/ SCCs/ ,/ 我们/ 可以/ 通过/ Tarjan/ 等/ 人/ [/ 9/ ]/ 的/ 算法/ 进行/ 识别/ ./ 本节/ 以/ 一个/ EORD/ 为例/ 介绍/ 子强/ 连通/ 分量/ (/ SCCi/ )/ 中/ 每条/ 动态/ 依赖边/ 和/ 关联/ 边/ 所/ 涉及/ 的/ 环路/ 数目/ 的/ 计算方法/ ./ 每/ 一个/ SCCi/ 中/ 的/ 环路/ 查找/ 方法/ 将/ 在/ 4.3/ 节/ 的/ 环路/ 生成/ 模块/ 中/ 再作/ 具体/ 介绍/ ./ 假设/ CP/ (/ P/ ,/ Q/ )/ 表示/ 边/ P/ →/ Q/ 涉及/ 的/ 环路/ 数目/ ./ 如图/ 3/ 中/ ,/ CP/ (/ G/ ,/ C/ )/ =/ 2/ ,/ 环路/ 分别/ 为/ G/ →/ C/ →/ D/ ,/ G/ →/ C/ →/ F/ ./ 在/ 图/ 3/ 中/ ,/ 不/ 考虑/ 动态/ 依赖/ 关系/ 的/ 情况/ 下/ ,/ 类/ C/ 、/ D/ 、/ F/ 、/ G/ 构成/ 一个/ SCC/ {/ C/ ,/ D/ ,/ F/ ,/ G/ }/ ,/ 其中/ 各/ 关联/ 边/ 的/ 环路/ 数目/ :/ CP/ (/ C/ ,/ F/ )/ =/ 2/ ,/ CP/ (/ D/ ,/ G/ )/ =/ 2/ ,/ CP/ (/ F/ ,/ G/ )/ =/ 2/ ,/ CP/ (/ G/ ,/ F/ )/ =/ 2/ ./ 考虑/ 动态/ 依赖/ 关系/ 后/ ,/ B/ →/ E/ 使/ ORD/ 构成/ 了/ SCC/ {/ B/ ,/ E/ }/ ,/ 增加/ 了/ 环路/ B/ →/ E/ →/ B/ ./ 因此/ ,/ 对于/ SCC/ {/ B/ ,/ E/ }/ ,/ CP/ (/ B/ ,/ E/ )/ =/ 1/ ,/ CP/ (/ E/ ,/ B/ )/ =/ 1.3/ ./ 2/ 消除/ EORD/ 中/ 环路/ 的/ 方法/ 3.2/ ./ 1/ 边/ 的/ 删除/ 规则/ 对于/ 存在/ 环路/ 的/ EORD/ ,/ 首先/ 需要/ 消除/ 环路/ ./ 删除/ 哪些/ 边/ 消除/ 环路/ 将/ 直接/ 影响/ 到/ 构造/ 测试/ 桩/ 的/ 数量/ ./ 为了/ 解决/ 已有/ 的/ 方法/ 忽略/ 动态/ 依赖/ 关系/ 的/ 问题/ ,/ 为/ 测试/ 提供/ 足够/ 的/ 测试/ 桩/ ,/ 需要/ 考虑/ 动态/ 依赖边/ 对/ 打破/ 环路/ 的/ 影响/ ./ 同时/ 为了/ 满足/ 构造/ 的/ 测试/ 桩/ 最少/ ,/ 我们/ 应该/ 遵循/ 删除/ 最少/ 的/ 边/ 打破/ 尽量/ 多/ 的/ 环路/ 的/ 原则/ ./ 下面/ 给出/ 相关/ 的/ 删除/ 规则/ ./ 定理/ 1/ ./ B/ 是/ C/ 的/ 父类/ ,/ 又/ 是/ A/ 的/ 服务/ 类/ ,/ 即/ A/ 要么/ 和/ B/ 相关联/ 要么/ 是/ B/ 的/ 聚集/ 类/ ./ 如果/ A/ 在/ B/ 和/ C/ 之前/ 进行/ 测试/ ./ 如果/ B/ 是非/ 抽象类/ ,/ 不/ 需要/ 为/ C/ 构造/ 测试/ 桩/ ,/ 只/ 需为/ B/ 构造/ 测试/ 桩/ ./ 证明/ ./ 已知/ B/ 是/ C/ 的/ 父类/ ,/ 又/ 是/ A/ 的/ 服务/ 类/ ,/ 根据/ 动态/ 依赖/ 关系/ 的/ 定义/ 可知/ ,/ 在/ 程序运行/ 时期/ ,/ A/ 可能/ 会/ 和/ B/ 的/ 子类/ C/ 动态/ 绑定/ ,/ 即/ A/ 可能/ 会/ 动态/ 依赖于/ C/ ,/ 因此/ ,/ 当/ 测试/ A/ 时/ ,/ 需要/ 依赖/ B/ 和/ C/ ./ 如果/ B/ 是非/ 抽象类/ ,/ B/ 能/ 实例/ 化/ ,/ 它/ 作为/ 服务/ 类/ 的/ 作用/ 不/ 需要/ 通过/ 其子/ 类/ C/ 实例/ 化来/ 提供/ ,/ 在/ 这种/ 情况/ 下/ ,/ 不/ 需要/ 为/ C/ 构造/ 测试/ 桩/ ,/ 因此/ ,/ B/ 是非/ 抽象类/ 时/ ,/ 只/ 需为/ B/ 构造/ 测试/ 桩/ ./ 推论/ 2/ ./ 假设/ λ/ 是/ 无环/ 的/ ORD/ ,/ 节点/ A/ ,/ B/ ,/ C/ ∈/ λ/ ,/ B/ 是/ C/ 的/ 父类/ ,/ 又/ 是/ A/ 的/ 服务/ 类/ ,/ 且/ A/ →/ B/ 是/ 关联/ 边/ ,/ 动态/ 依赖边/ A/ →/ C/ 使得/ EORD/ 产生/ 了/ 环路/ A/ →/ C/ →/ A/ ,/ 边/ A/ →/ C/ 和/ 边/ C/ →/ A/ 没有/ 与/ 其它/ 节点/ 构成/ 新/ 的/ 环路/ ,/ 为了/ 构造/ 尽可能少/ 的/ 测试/ 桩/ ,/ 如果/ B/ 是非/ 抽象类/ ,/ 且/ C/ →/ A/ 是非/ 关联/ 边/ ,/ 则/ 直接/ 删除/ 动态/ 依赖边/ A/ →/ C/ ;/ 当/ C/ →/ A/ 是/ 关联/ 边/ ,/ 则/ 可以/ 删除/ 边/ A/ →/ C/ 或边/ C/ →/ A/ ./ 证明/ ./ 由/ 定理/ 1/ 我们/ 可以/ 推断/ ,/ 如果/ B/ 是非/ 抽象类/ ,/ 删除/ 关联/ 边/ A/ →/ B/ 时/ ,/ 动态/ 依赖边/ A/ →/ C/ 随之/ 消失/ ,/ 由于/ 动态/ 依赖边/ A/ →/ C/ 使得/ EORD/ 产生/ 了/ 环路/ A/ →/ C/ →/ A/ ,/ 则/ 此时/ 已经/ 消除/ 了/ 该/ 环路/ ./ 如果/ A/ 在/ B/ 和/ C/ 之前/ 进行/ 测试/ ,/ 需要/ 为/ B/ 和/ C/ 构造/ 测试/ 桩/ ./ 事实上/ ,/ 直接/ 删除/ 边/ A/ →/ C/ 可以/ 消除/ 环路/ ,/ 只/ 需要/ 为/ C/ 构造/ 测试/ 桩/ ,/ 此时/ ,/ 我们/ 选择/ 直接/ 删除/ 边/ A/ →/ C/ ./ 如果/ C/ →/ A/ 是/ 关联/ 边/ ,/ 也/ 可以/ 通过/ 删除/ 边/ C/ →/ A/ (/ 由于/ 关联/ 边为/ 弱/ 联系/ 边/ )/ 来/ 消除/ 环路/ ,/ 否则/ ,/ 只能/ 删除/ 边/ A/ →/ C/ ./ 推论/ 3/ ./ 假设/ λ/ 是/ 无环/ 的/ ORD/ ,/ 节点/ A/ ,/ B/ ,/ C/ ∈/ λ/ ./ B/ 是/ C/ 的/ 父类/ ,/ 又/ 是/ A/ 的/ 服务/ 类/ ,/ 且/ A/ →/ B/ 是/ 聚集/ 边/ ,/ 同时/ 动态/ 依赖边/ A/ →/ C/ 使得/ EORD/ 产生/ 了/ 环路/ A/ →/ C/ →/ A/ ,/ 边/ A/ →/ C/ 和/ 边/ C/ →/ A/ 没有/ 与/ 其它/ 节点/ Page5/ 构成/ 新/ 的/ 环路/ ./ 为了/ 构造/ 尽可能少/ 的/ 测试/ 桩/ ,/ 如果/ C/ →/ A/ 是/ 关联/ 边/ ,/ 则/ 可以/ 删除/ 边/ C/ →/ A/ 或者/ A/ →/ C/ ,/ 相应/ 地为/ A/ 或/ C/ 构造/ 测试/ 桩/ ;/ 否则/ ,/ 只能/ 删除/ 边/ A/ →/ C/ ,/ 为/ C/ 构造/ 测试/ 桩/ ./ 证明/ ./ 已知/ B/ 是/ C/ 的/ 父类/ ,/ 又/ 是/ A/ 的/ 服务/ 类/ ,/ 根据/ 动态/ 依赖/ 关系/ 的/ 定义/ 可知/ ,/ 则/ 在/ 程序运行/ 时期/ ,/ A/ 可能/ 会/ 动态/ 依赖于/ C/ ./ 由于/ 动态/ 依赖边/ A/ →/ C/ 使得/ EORD/ 产生/ 了/ 环路/ A/ →/ C/ →/ A/ ,/ 可以/ 删除/ 边/ C/ →/ A/ 或者/ A/ →/ C/ 或者/ A/ →/ B/ ,/ 已知/ A/ →/ B/ 是/ 聚集/ 边/ ,/ 将/ 其/ 排除/ (/ Kraft/ 等/ 人/ [/ 2/ ]/ 已经/ 证明/ 聚集/ 是/ 强/ 联系/ 边/ ,/ 本文/ 避免/ 删除/ 该/ 类型/ 的/ 边/ )/ ;/ 因此/ ,/ 当/ C/ →/ A/ 是/ 关联/ 边/ ,/ 则/ 可以/ 删除/ 边/ C/ →/ A/ ,/ 为/ A/ 构造/ 测试/ 桩/ ,/ 测试/ 顺序/ 为/ BCA/ ,/ 或者/ 删除/ A/ →/ C/ ,/ 测试/ 顺序/ 为/ BAC/ ,/ 为/ C/ 构造/ 测试/ 桩/ ;/ 否则/ ,/ 只能/ 删除/ 边/ A/ →/ C/ ,/ 为/ C/ 构造/ 测试/ 桩/ ./ 例如/ ,/ 由于/ 考虑/ 了/ 动态/ 关系/ ,/ 图/ 2/ 中/ 生成/ 了/ 一个/ 新/ 的/ 环路/ :/ 教师/ →/ 本科生/ →/ 学生/ →/ 课程/ →/ 教师/ ./ 根据/ 推论/ 1/ ,/ 删除/ 关联/ 边/ 教师/ →/ 学生/ ,/ 可以/ 打破/ 该/ 环路/ ./ 此外/ ,/ 删除/ 关联/ 边/ 教师/ →/ 学生/ 还/ 可以/ 打破/ 图中/ 的/ 另/ 一个/ 环路/ :/ 教师/ →/ 学生/ →/ 课程/ →/ 教师/ ./ 满足/ 了/ 删除/ 最少/ 的/ 边/ 打破/ 尽量/ 多/ 的/ 环路/ 原则/ ./ 因此/ ,/ 我们/ 选择/ 删除/ 动态/ 依赖边/ 教师/ →/ 学生/ ./ 3.2/ ./ 2EORD/ 中/ 的/ 环路/ 消除/ 算法/ 如/ 前面/ 所/ 提到/ 的/ ,/ 消除/ 环路/ 是/ 确定/ 类间/ 测试/ 序/ 的/ 关键步骤/ ./ 根据/ 3.2/ ./ 1/ 节/ 提出/ 的/ 边/ 的/ 删除/ 规则/ ,/ 我们/ 给出/ 相应/ 的/ 环路/ 消除/ 算法/ :/ 首先/ 统计/ 动态/ 依赖边/ 和/ 关联/ 边/ 所/ 涉及/ 的/ 环路/ 数目/ (/ 行/ 1/ ~/ 5/ )/ ,/ 然后/ 判断/ 涉及/ 环路/ 数目/ 最多/ 的/ 边/ 的/ 类型/ :/ 如果/ 涉及/ 环路/ 数目/ 最多/ 的/ 边/ 为/ 动态/ 依赖边/ ,/ 或者/ 动态/ 依赖边/ 和/ 关联/ 边/ 涉及/ 相同/ 的/ 环路/ 个数/ (/ 包括/ 由/ 一条/ 动态/ 依赖边/ 和/ 一条/ 关联/ 边/ 构成/ 一个/ 最/ 简单/ 的/ 环路/ 的/ 情况/ )/ ,/ 判断/ 导致/ 动态/ 依赖边/ 形成/ 的/ 边/ 的/ 类型/ (/ 行/ 6/ ~/ 8/ )/ :/ 如果/ 是/ 关联/ 边/ ,/ 删除/ 动态/ 依赖边/ ;/ 如果/ 是/ 聚集/ 边/ ,/ 也/ 删除/ 动态/ 依赖边/ (/ 行/ 9/ ~/ 14/ )/ ./ 如果/ 两个/ 类/ 之间/ 同时/ 存在/ 一条/ 关联/ 边/ 和/ 一条/ 动态/ 依赖边/ (/ 同/ 向/ )/ ,/ 且/ 它们/ 涉及/ 的/ 环路/ 数目/ 相同/ 且/ 最/ 多/ ,/ 则/ 同时/ 删除/ 这/ 两条/ 边/ (/ 行/ 15/ ~/ 17/ )/ ;/ 如果/ 两个/ 类/ 之间/ 同时/ 存在/ 一条/ 聚集/ 边/ (/ 或/ 继承/ 边/ )/ 和/ 一条/ 动态/ 依赖边/ (/ 同/ 向/ )/ ,/ 且/ 它们/ 涉及/ 的/ 环路/ 数目/ 相同/ 且/ 最/ 多/ ,/ 则/ 删除/ 环路/ 中/ 的/ 关联/ 边/ (/ 行/ 18/ ~/ 20/ )/ (/ 由于/ Kung/ 等/ 人/ [/ 1/ ]/ 已经/ 证明/ ORD/ 中/ 的/ 任意/ 一个/ SCC/ 中/ 至少/ 包含/ 一条/ 关联/ 边/ )/ ./ 如果/ 涉及/ 环路/ 数目/ 最多/ 的/ 边/ 为/ 一条/ 关联/ 边/ ,/ 则/ 删除/ 该/ 关联/ 边/ (/ 行/ 21/ ~/ 23/ )/ ./ 如果/ 多条/ 关联/ 边/ (/ 或/ 动态/ 依赖边/ )/ 的/ 环路/ 数目/ 相同/ 且/ 最/ 多/ ,/ 则/ 删除/ 其中/ 任意/ 一条/ 关联/ 边/ (/ 或/ 动态/ 依赖边/ )/ (/ 行/ 24/ ~/ 26/ )/ ./ 环路/ 消除/ 算法/ 如/ 算法/ 1/ 所示/ ./ 算法/ 1/ ./ EORD/ (/ V/ ,/ E/ )/ 的/ 环路/ 消除/ 算法/ ./ 输入/ :/ EORD/ (/ V/ ,/ E/ )/ 输出/ :/ 无环/ 的/ EORDBegin1/ ./ findallSCCsinEORD/ ;/ 2/ ./ for/ (/ eachSCCi/ (/ Vscci/ ;/ Escci/ )/ ∈/ SCCs/ )/ do3/ ./ searchcycles/ (/ …/ )/ ;/ 4/ ./ for/ (/ eachassociationedgeAsanddynamicdepend/ -/ 5/ ./ calculatethenumberofcyclesthatinvolveAsandDy/ ;/ 6/ ./ while/ (/ totalCycle/ !/ =/ 0/ )/ do7/ ./ ifDyhasthemostcyclesorDyandAshavethe8/ ./ judgeifDyisleadbyanotherassociationedgeAs/ ;/ 9/ ./ ifleadbyAsthen10/ ./ removethedynamicdependencyedgeDy/ ;/ 11/ ./ elseleadbyaggregationedgeAg12/ ./ removethedynamicdependencyedgeDyor13/ ./ endif14/ ./ endif15/ ./ iftwoclasseshaveanAsandaDyinthesame16/ ./ removetheAsandDysimultaneously/ ;/ 17/ ./ endif18/ ./ iftwoclasseshaveanAg/ (/ orI/ )/ andaDyinthe19/ ./ removetheotherassociationedgeofthecycle/ ;/ 20/ ./ endif21/ ./ ifanassociationedgeAshasthemostcyclesthen22/ ./ removetheassociationedgeAs/ ;/ 23/ ./ endif24/ ./ ifmorethanoneassociation/ (/ dynamicdependen/ -/ 25/ ./ removeanyassociation/ (/ dynamicdependency/ )/ edge/ ;/ 26/ ./ endif27/ ./ totalCycle/ =/ totalCycle/ -/ numberofcyclesbroken/ ;/ 28/ ./ recalculatethenumberofcyclesforremaining29/ ./ endwhile30/ ./ endfor31/ ./ endforEnd/ 下面/ 把/ 图/ 3/ 中/ 示例/ 应用/ 到/ 该/ 算法/ 中/ ,/ 对/ 算法/ 的/ 执行/ 第/ 2/ ~/ 3/ 行/ 能够/ 在/ SCC/ {/ C/ ,/ D/ ,/ F/ ,/ G/ }/ 中/ 找出/ 具体步骤/ 作/ 如下/ 说明/ :/ 5/ 个/ 循环/ ,/ 如表/ 1/ 所示/ ./ Page6No/ ./ 12345/ 表/ 2/ 犛/ 犆/ 犆/ {/ 犆/ ,/ 犇/ ,/ 犉/ ,/ 犌/ }/ 中/ 各/ 关联/ 边/ 涉及/ 的/ 环路/ No/ ./ EdgesCyclesinvolvedNC1234/ 根据/ 算法/ 1/ 中/ 的/ 第/ 4/ ~/ 5/ 行/ 计算/ SCC/ {/ C/ ,/ D/ ,/ F/ ,/ G/ }/ 中/ 各条/ 关联/ 边/ 和/ 动态/ 依赖边/ 涉及/ 的/ 环路/ 数目/ ,/ 结果/ 如表/ 2/ 所示/ ./ 其中/ ,/ NC/ 表示/ 环路/ 的/ 数目/ ./ 由/ 算法/ 6/ ~/ 17/ 行/ 可以/ 得出/ 边/ 1/ :/ C/ →/ F/ ,/ 边/ 2/ :/ D/ →/ G/ ,/ 边/ 3/ :/ F/ →/ G/ 和/ 边/ 4/ :/ G/ →/ F/ 涉及/ 环路/ 数目/ 相同/ ,/ 均/ 为/ 2/ ,/ 我们/ 任意/ 删除/ 其中/ 的/ 一条/ 关联/ 边/ ,/ 此处/ ,/ 假如/ 删除/ 关联/ 边/ 2/ ,/ D/ →/ G/ ,/ 可以/ 打破/ 两个/ 环路/ {/ 3/ ,/ 5/ }/ ,/ 剩余/ 环路/ 1/ ,/ 2/ ,/ 4/ ./ 接下来/ ,/ 应用/ 算法/ 的/ 第/ 28/ 行对/ 剩余/ 的/ 边/ 重新/ 计算/ 涉及/ 环路/ 数目/ ,/ 可以/ 得出/ 两条/ 拥有/ 最/ 多/ 环路/ 数目/ 的/ 关联/ 边/ 分别/ 为/ C/ →/ F/ 和/ F/ →/ G/ ,/ 且/ 删除/ 这/ 两条/ 边中/ 任意/ 一条/ 打破/ 的/ 环路/ 数目/ 相同/ ,/ 所以/ 可以/ 任意/ 选择/ 一条/ 边/ ,/ 这里/ ,/ 我们/ 选择/ 删除/ 边/ C/ →/ F/ ,/ 打破/ 环路/ 1/ ,/ 2/ ,/ 此时/ ,/ 只/ 剩下/ 环路/ 4/ ,/ 该/ 环路/ 由边/ F/ →/ G/ 和/ G/ →/ F/ 构成/ ,/ 这/ 两条/ 边为/ 具有/ 相同/ 环路/ 的/ 关联/ 边/ ,/ 可以/ 任意/ 删除/ 其中/ 的/ 一条/ 边/ ,/ 我们/ 选择/ 删除/ F/ →/ G/ ,/ 则/ 消除/ 了/ SCC/ {/ C/ ,/ D/ ,/ F/ ,/ G/ }/ 中/ 环路/ ./ 对于/ SCC/ {/ B/ ,/ E/ }/ ,/ 根据/ 算法/ 1/ ,/ 需要/ 删除/ 边/ E/ →/ B/ 打破/ 环路/ ./ 此时/ ,/ EORD/ 成为/ 了/ 无/ 环图/ ,/ 如图/ 4/ 所示/ ./ 图/ 4/ 消除/ 环路/ 后/ 扩展/ 的/ 对象/ 关系/ 图/ (/ EORD/ )/ 打破/ EORD/ 中/ 所有/ 环路/ 需要/ 删除/ D/ →/ G/ ,/ C/ →/ F/ ,/ F/ →/ G/ ,/ E/ →/ B/ 这/ 4/ 条边/ ,/ 分别/ 为/ 这/ 4/ 条边/ 的/ 源类/ G/ 、/ F/ 和/ B/ 各自/ 创建/ 1/ 个/ 测试/ 桩/ ,/ 共/ 需要/ 3/ 个/ 测试/ 桩/ ./ 4/ 测试/ 顺序/ 分配/ 策略/ 在/ 程序/ 的/ 执行/ 过程/ 中/ ,/ 消除/ EORD/ 中/ 的/ 环路/ 以后/ ,/ 程序/ 中/ 仍/ 存在/ 动态/ 依赖/ 关系/ ,/ 但/ 这些/ 动态/ 依赖/ 关系/ 并/ 没有/ 使得/ EORD/ 构成/ 环路/ ,/ 即无环/ 的/ EORD/ 中/ 既/ 包含/ 静态/ 依赖/ 关系/ 又/ 包含/ 动态/ 依赖/ 关系/ ./ 由于/ 动态/ 依赖/ 关系/ 在/ 程序运行/ 时期/ 才/ 会/ 存在/ ,/ 同时/ ,/ 传统/ 的/ 逆向/ 拓扑/ 排序/ 只能/ 在/ 程序/ 静态/ 状态/ 下/ 确定/ 类/ 测试/ 顺序/ ,/ 因此/ 不能/ 通过/ 简单/ 的/ 逆向/ 拓扑/ 排序/ 为/ 存在/ 两种/ 依赖/ 关系/ 类簇/ 确定/ 测试/ 顺序/ ./ 因此/ ,/ 为了/ 解决/ 无环/ 的/ EORD/ 中/ 的/ 动态/ 依赖/ 关系/ 带来/ 的/ 新/ 的/ 测试/ 问题/ ,/ 我们/ 给出/ 基于/ 测试/ 级/ 的/ 测试/ 顺序/ 分配/ 策略/ ./ 4.1/ 测试/ 级/ 的/ 定义/ 测试/ 级/ 是/ 指/ 根据/ 静态/ 依赖/ 和/ 动态/ 依赖/ 关系/ 为/ 被/ 测类/ 分配/ 的/ 两个/ 测试/ 级别/ :/ 静态/ 测试/ 级/ 和/ 动态/ 测试/ 级/ ./ 其中/ ,/ 静态/ 测试/ 级/ 是/ 指/ 不/ 运行/ 被测/ 程序/ 本身/ ,/ 对/ 程序/ 进行/ 静态/ 分析/ ,/ 仅/ 通过/ 分析/ 或/ 检查/ 源程序/ 中/ 的/ 待测/ 目标/ 类来/ 检查/ 其/ 正确性/ ./ 静态/ 测试/ 的/ 结果/ 可/ 用于/ 进一步/ 查错/ ,/ 并/ 为/ 测试用例/ 选取/ 提供/ 指导/ ./ 动态/ 测试/ 级/ 是/ 指/ 需要/ 通过/ 运行/ 被测/ 程序/ ,/ 来/ 检查程序/ 的/ 正确性/ ,/ 该/ 方法/ 由/ 三/ 部分/ 组成/ :/ 构造/ 测试/ 实例/ 、/ 执行程序/ 、/ 分析程序/ 的/ 输出/ 结果/ ./ 一个/ 测试/ 级/ T/ 可以/ 表示/ 为/ 一个/ 三元组/ T/ =/ (/ T/ / need/ ,/ T/ / all/ ,/ T/ / type/ )/ [/ 7/ ]/ ./ 其中/ ,/ T/ / need/ 为/ 被/ 测试/ 类/ 的/ 集合/ ;/ T/ / all/ 为/ 被/ 测类/ 与/ 被/ 测类/ 所/ 依赖/ 的/ 类/ 构成/ 的/ 并/ 集/ ;/ T/ / type/ 为/ 测试/ 的/ 类型/ ./ 其中/ ,/ 测试/ 类型/ 包括/ 两种/ ,/ 一种/ 是/ 静态/ 测试/ ,/ 用/ S/ 表示/ ;/ 另/ 一种/ 是/ 动态/ 测试/ ,/ 用/ Dy/ 表示/ ./ 下面/ 具体/ 介绍/ 如何/ 为/ 消除/ 环路/ 后/ 的/ EORD/ 的/ 每/ 一个/ 类/ 确定/ 测试/ 级/ ,/ 即/ 如何/ 划分/ 被/ 测类/ 的/ 测试/ 级别/ ./ (/ 1/ )/ 为了/ 程序/ 的/ 精确/ 测试/ ,/ 对于/ EORD/ 中/ 的/ 每/ 一个/ 类/ X/ ,/ 为/ 每个/ 类/ 定义/ 一个/ 静态/ 测试/ 级/ T/ =/ (/ {/ X/ }/ ,/ {/ X/ }/ ∪/ S/ (/ X/ )/ ,/ S/ )/ ;/ (/ 2/ )/ 对/ 满足/ D/ (/ X/ )/ ≠/ / 的/ 类/ X/ ,/ 定义/ 一个/ 动态/ 测试/ 级/ T/ =/ (/ T/ / need/ ,/ T/ / all/ ,/ Dy/ )/ =/ (/ {/ X/ }/ ,/ {/ X/ }/ ∪/ D/ (/ X/ )/ ,/ Dy/ )/ ./ 表/ 3/ 所示/ 为/ 图/ 4/ 中无环/ EORD/ 的/ S/ (/ X/ )/ 和/ D/ (/ X/ )/ ,/ 首先/ 为/ 每/ 一个/ 类/ 各自/ 定义/ 一个/ 静态/ 测试/ 级/ ,/ 其中/ 类/ B/ 满足/ D/ (/ X/ )/ ≠/ / ,/ 那么/ 为/ B/ 定义/ 动态/ 测试/ 类/ XS/ (/ X/ )/ ABCDEFGHPage7/ 级/ ,/ 因此/ 类/ B/ 有/ 两个/ 测试/ 级/ ./ 按/ 上述/ 方式/ ,/ 可定义/ 图/ 4/ 中/ EORD/ 的/ 所有/ 测试/ 级/ 如表/ 4/ 所示/ ./ T/ / need/ {/ A/ }/ {/ B/ }/ {/ C/ }/ {/ D/ }/ {/ E/ }/ {/ F/ }/ {/ G/ }/ {/ H/ }/ {/ B/ }/ 4.2/ 测试/ 级/ 顺序/ 分配/ 策略/ 每/ 一个/ 类/ 的/ 测试/ 级/ 确定/ 之后/ ,/ 需要/ 为/ 它们/ 分配/ 一定/ 的/ 测试/ 顺序/ ./ 类/ 测试/ 顺序/ 由类/ 的/ 测试/ 依赖性/ 决定/ [/ 10/ ]/ ./ 测试/ 依赖性/ 表示/ 一个/ 类/ 依赖于/ 其它/ 类/ 的/ 程度/ ./ 为了/ 确定/ 类/ 测试/ 顺序/ ,/ 本文/ 从类/ 测试/ 依赖性/ 入手/ ,/ 提出/ 两个/ 测试/ 依赖性/ 定理/ 作为/ 确定/ 类/ 测试/ 顺序/ 的/ 依据/ ./ 定理/ 2/ ./ 当类/ A/ 是/ 类/ B/ 的/ 一个/ 子类/ ,/ 或者/ 类/ A/ 是/ 类/ B/ 的/ 一个/ 聚合/ 类/ ,/ 或者/ 类/ A/ 是/ 类/ B/ 的/ 一个/ 关联/ 类/ ,/ 则/ 在/ 集成/ 测试/ 时/ ,/ 类/ A/ 依赖于/ 类/ B/ ,/ 类/ A/ 在/ 类/ B/ 之后/ 进行/ 测试/ ./ 证明/ ./ 类/ A/ 继承/ 于类/ B/ 时/ ,/ 类/ A/ 会/ 继承/ 类/ B/ 的/ 部分/ 属性/ ,/ 从而/ 类/ A/ 依赖于/ 类/ B/ ./ 若类/ B/ 中/ 被/ 类/ A/ 继承/ 的/ 成员/ 发生变化/ ,/ 或/ 被/ 类/ A/ 继承/ 的/ 成员/ 有/ 直接/ 或/ 间接/ 影响/ 的/ 成员/ 发生变化/ 时/ ,/ 将会/ 影响/ 类/ A/ 的/ 行为/ ./ 当类/ A/ 是/ 类/ B/ 的/ 一个/ 聚合/ 类/ ,/ 由于/ 聚合/ 是/ 整体/ 和/ 个体/ 的/ 关系/ ,/ 即/ 若干个/ 类/ B/ 聚合/ 成/ 一个/ 类/ A/ ,/ 则/ 类/ B/ 的/ 改变/ 必然/ 会/ 影响/ 类/ A/ ,/ 因此/ 类/ A/ 依赖于/ 类/ B/ ./ 当类/ A/ 是/ 类/ B/ 的/ 一个/ 关联/ 类/ ,/ 则/ 类/ A/ 能够/ 访问/ 类/ B/ 的/ 数据/ 成员/ ,/ 或者/ 类/ A/ 传递/ 一个/ 消息/ 到/ 类/ B/ ./ 因此/ ,/ 如果/ 类/ B/ 的/ 数据/ 成员/ 发生变化/ ,/ 或者/ 当类/ B/ 接收/ 类/ A/ 发送/ 的/ 消息/ ,/ 并且/ 类/ B/ 的/ 成员/ 函数/ 发生变化/ ,/ 则/ 类/ B/ 对/ 消息/ 的/ 响应/ 会/ 有/ 变化/ ,/ 返回/ 给/ 类/ A/ 的/ 结果/ 也/ 会/ 发生变化/ ./ 因此/ ,/ 类/ A/ 依赖于/ 类/ B/ ./ 因此/ ,/ 类/ A/ 在/ 类/ B/ 之后/ 进行/ 测试/ ./ 得出/ 定理/ 2/ 的/ 结论/ ./ 定理/ 3/ [/ 11/ ]/ ./ 假设/ 3/ 个类/ A/ 、/ B/ 、/ C/ ,/ 当/ A/ 是/ B/ 的/ 一个/ 子类/ ,/ B/ 是/ C/ 的/ 一个/ 服务/ 类/ ,/ 即/ C/ 关联/ 于/ B/ (/ 或者/ 依赖于/ B/ )/ 或者/ C/ 是/ B/ 的/ 一个/ 聚合/ 类/ ,/ 则/ 在/ 考虑/ 多态性/ 的/ 情况/ 下/ ,/ 集成/ 测试/ 时/ ,/ C/ 依赖于/ B/ ,/ 也/ 依赖于/ B/ 的/ 子类/ A/ ./ 测试/ 顺序/ 为/ B/ ,/ A/ ,/ C/ ./ 证明/ ./ A/ 是/ B/ 的/ 一个/ 子类/ ,/ B/ 是/ C/ 的/ 一个/ 服务/ 类/ ,/ 由/ 测试/ 依赖性/ 定理/ 2/ 得出/ ,/ A/ 在/ B/ 之后/ 测试/ ,/ C/ 在/ B/ 之后/ 测试/ ./ 对于/ A/ 、/ C/ 的/ 测试/ 依赖性/ 关系/ 有/ 如下/ 情况/ :/ (/ 1/ )/ 若/ C/ 关联/ 于/ B/ (/ 或者/ 依赖于/ B/ )/ ./ 如果/ C/ 需要/ 访问/ B/ 中/ 的/ 某个/ 数据/ 成员/ ,/ 而/ A/ 继承/ B/ 的/ 该/ 数据/ 成员/ ./ 由于/ 继承/ 和/ 多态性/ ,/ 在/ 程序运行/ 时/ C/ 可能/ 访问/ 到/ 的/ 实际上/ 是/ A/ 中/ 的/ 该/ 数据/ 成员/ ./ 因此/ C/ 依赖于/ A/ ./ 但/ 由于/ 从/ A/ 到/ C/ 之间/ 没有/ 任何/ 依赖/ 关系/ ,/ 因此/ ,/ A/ 不/ 依赖于/ C/ ./ (/ 2/ )/ 若/ C/ 是/ B/ 的/ 一个/ 聚合/ 类/ ,/ 由于/ A/ 是/ B/ 的/ 子类/ ,/ 而/ C/ 是/ B/ 的/ 聚合/ 类/ ,/ 因此/ C/ 也/ 可以/ 作为/ A/ 的/ 聚合/ 类/ ./ 该/ 情况/ 下/ C/ 依赖于/ A/ ./ (/ 3/ )/ 如果/ C/ 传递/ 一个/ 消息/ 到/ B/ ,/ 而/ B/ 负责/ 具体/ 处理/ 消息/ ./ 由于/ 继承/ 和/ 多态性/ ,/ 继承/ 了/ B/ 类/ 处理/ 方法/ 的/ A/ 也/ 能够/ 处理/ 该/ 消息/ ,/ C/ 也/ 能够/ 将/ 消息传递/ 到/ A/ ,/ 由/ A/ 负责/ 具体/ 处理/ ./ 该/ 情况/ 下/ C/ 依赖于/ A/ ./ 由/ 上述/ 分析/ 得出/ ,/ 测试/ 顺序/ 为/ B/ ,/ A/ ,/ C/ ./ 得出/ 定理/ 3/ 的/ 结论/ ./ 因此/ ,/ 对于/ 消除/ 环路/ 以后/ 的/ ORD/ 或者/ EORD/ ,/ 根据/ 定理/ 2/ 和/ 定理/ 3/ ,/ 测试/ 级/ 顺序/ 需要/ 满足/ :/ 首先/ 考虑/ 静态/ 依赖/ ,/ 因为/ 动态/ 依赖/ 只是/ 潜在/ 的/ 运行/ 期间/ 的/ 动态/ 绑定/ 依赖/ 关系/ ,/ 弱于/ 静态/ 依赖/ 关系/ ,/ 即/ 在/ 测试/ 一个/ 类/ 之前/ ,/ 该类/ 所/ 依赖/ 的/ 所有/ 类/ 都/ 已/ 被/ 测试/ ,/ 且/ 在/ 对/ 一个/ 类/ 进行/ 动态/ 测试/ 之前/ ,/ 已/ 完成/ 了/ 对/ 所有/ 类/ 的/ 静态/ 测试/ ./ 这样/ ,/ 满足/ 测试/ 类/ 所/ 需要/ 的/ 类/ 都/ 已经/ 被/ 测试/ ,/ 可以/ 保证/ 测试/ 桩/ 的/ 数量/ 尽可能少/ ./ 根据/ 这一/ 要求/ ,/ 应该/ 遵循/ 以下/ 测试/ 级/ 顺序/ 分配/ 规则/ ./ (/ 1/ )/ 若类/ C1/ 和/ 类/ C2/ 有/ 两个/ 不同/ 的/ 静态/ 测试/ 级/ TC1/ 和/ TC2/ ,/ 且/ TC1/ 静态/ 依赖/ TC2/ ,/ 则/ C2/ 的/ 静态/ 测试/ 级/ TC2/ 先于/ C1/ 的/ 静态/ 测试/ 级/ TC1/ ./ (/ 2/ )/ 若类/ C1/ 和/ 类/ C2/ 有/ 两个/ 不同/ 的/ 动态/ 测试/ 级/ TC1/ 和/ TC2/ ,/ 且/ TC1/ 动态/ 依赖/ TC2/ ,/ 则/ TC2/ 先于/ TC1/ ./ (/ 3/ )/ 若类/ C/ 有/ 2/ 个/ 测试/ 级/ ,/ 静态/ 测试/ 级/ Ts/ =/ (/ {/ X/ }/ ,/ X/ ∪/ S/ (/ X/ )/ )/ 和/ 动态/ 测试/ 级/ Td/ =/ (/ X/ ,/ X/ ∪/ SD/ (/ X/ )/ )/ ,/ 其中/ ,/ X/ ∈/ T/ / all/ ,/ 则/ Ts/ 先于/ Td/ ./ (/ 4/ )/ 若类/ C1/ 的/ 一个/ 动态/ 测试/ 级/ 是/ TC1/ =/ (/ TC1/ / need/ ,/ TC1/ / all/ )/ ,/ 并且/ C2/ ∈/ TC1/ / all/ ,/ C1/ ≠/ C2/ ,/ 则/ 对/ C2/ 的/ 静态/ 测试/ 级/ TC2/ =/ (/ {/ C2/ }/ ,/ C2/ ∪/ S/ (/ C2/ )/ )/ 先于/ TC1/ ./ 无环/ 的/ EORD/ 中类/ 测试/ 顺序/ 分配/ 算法/ 如/ 算法/ 2/ 算法/ 2/ ./ 无环/ 的/ EORD/ 中类/ 测试/ 顺序/ 分配/ 算法/ ./ 输入/ :/ 无环/ 的/ EORD/ 输出/ :/ 无环/ 的/ EORD/ 中类/ 测试/ 顺序/ 分配/ 算法/ 所示/ ./ Page8Begin1/ ./ foreachclassXofacyclicEORDdo2/ ./ findXstaticdependencysetXs/ ,/ addXstoS/ (/ X/ )/ ;/ 3/ ./ SetStaTstLvl/ (/ X/ ,/ S/ (/ X/ )/ )/ ;/ // // 为/ X/ 建立/ 静态/ 测试/ 级/ 4/ ./ findXdynamicdependencysetXd/ ,/ addXdtoD/ (/ X/ )/ ;/ 5/ ./ SD/ (/ X/ )/ =/ (/ S/ (/ X/ )/ ∪/ D/ (/ X/ )/ )/ +/ 6/ ./ ifS/ (/ X/ )/ / SD/ (/ X/ )/ then7/ ./ SetDynTstLvl/ (/ X/ ,/ D/ (/ X/ )/ )/ ;/ 8/ ./ endif/ // // 为/ X/ 建立/ 动态/ 测试/ 级/ 图/ 5TLOG/ 功能/ 结构图/ 该/ 工具/ 的/ 输入/ 信息/ 是/ 一个/ 描述/ 面向对象/ 系统/ 中类/ 间/ 关系/ 的/ 三元组/ 列表/ ,/ 其中/ 的/ 三元组/ 列表/ 可以/ 由/ 面向对象/ 系统/ 的/ 统一/ 建模语言/ (/ UML/ )/ 设计/ 文档/ 中/ 的/ 类图/ 获得/ ./ 下面/ 介绍/ TLOG/ 的/ 几个/ 主要/ 功能模块/ ./ (/ 1/ )/ 环路/ 生成/ 模块/ ./ 如图/ 5/ 中虚/ 线框/ 所示/ ,/ 其/ 输入/ 信息/ 是/ UML/ 设计/ 文档/ 中/ 的/ 类图/ 或/ ORD/ 所/ 包含/ 的/ SCCs/ 中/ 的/ 各条/ 边/ ,/ 查找/ SCCs/ 中/ 所有/ 的/ 环路/ 时/ ,/ 首先/ 将/ 每/ 一个/ SCCi/ 中/ 的/ 边/ 以树/ 的/ 形式/ 组织/ 在/ 一起/ ,/ 总共/ 构造/ i/ 棵/ 树/ ,/ 每棵/ 树/ 的/ 特点/ 是/ 叶/ 节点/ 与/ 根/ 节点/ 相同/ ,/ 然后/ 对/ 所/ 构造/ 的/ 树/ 进行/ 前序/ 遍历/ ,/ 进而/ 找出/ 所有/ 环路/ ,/ 最后/ 自动/ 输出/ SCCi/ 中/ 的/ 环路/ 数目/ 及/ 所有/ 环路/ 路径/ 、/ SCCi/ 中/ 各/ 关联/ 边/ 和/ 动态/ 依赖边/ 涉及/ 的/ 环路/ 的/ 数目/ ./ (/ 2/ )/ 环路/ 消除/ 模块/ ./ 首先/ 对/ 输入/ 的/ 三元组/ 描述/ 信息/ 所/ 表示/ 的/ 类图/ 或/ ORD/ ,/ 增加/ 动态/ 依赖/ 关系/ ,/ 然后/ 采用/ Tarjan/ 等/ 人/ [/ 9/ ]/ 的/ 算法/ ,/ 依次/ 识别/ SCCi/ ,/ 最后/ 按照/ 3.2/ ./ 2/ 节中/ 的/ 算法/ 1/ ,/ 通过/ 断开/ 一条/ 或/ 多条/ 关联/ 边/ 或者/ 动态/ 依赖边/ ,/ 将/ 每/ 一个/ 子/ SCCi/ 的/ 环路/ 断开/ ,/ 直到/ 消除/ 所有/ 环路/ ./ (/ 3/ )/ 测试/ 级/ 排序/ 模块/ :/ 由/ 4.1/ 节/ 的/ 方法/ 定义/ 测/ 9/ ./ endfor10/ ./ determinetotalnumberoftestlevelN/ ;/ 11/ ./ orderthetestlevelNaccordingtointegrationEnd4/ ./ 3/ 测试/ 序列/ 生成器/ TLOG/ 我们/ 根据上述/ 基于/ 测试/ 级/ 的/ 类/ 集成/ 测试方法/ 设计/ 并/ 实现/ 了/ 一个/ 工具/ —/ —/ —/ TLOG/ (/ TestLevelOrderGenerator/ )/ ,/ 其/ 功能/ 结构/ 如图/ 5/ 所示/ ./ 试级/ 以后/ ,/ 根据/ 测试/ 级/ 的/ 顺序/ 分配/ 的/ 四条/ 规则/ 以及/ 4.2/ 节中/ 的/ 算法/ 2/ ,/ 得到/ 基于/ 测试/ 级/ 的/ 类/ 集成/ 测试/ 顺序/ ./ TLOG/ 能够/ 自动/ 生成/ 基于/ 动态/ 依赖/ 关系/ 的/ 类/ 集成/ 测试/ 序列/ ,/ 可/ 减少/ 测试/ 的/ 工作量/ ./ 5/ 实验/ 在/ 这/ 一节/ 中/ ,/ 我们/ 将/ 前面/ 介绍/ 的/ 方法/ 应用/ 到/ 一组/ 基准/ 程序/ 中/ ,/ 通过/ 实验/ 验证/ 本文/ 方法/ 的/ 有效性/ ./ 5.1/ 实验/ 描述/ 和/ 过程/ 在/ 实验/ 中/ ,/ 我们/ 采用/ 了/ 在/ 许多/ 软件测试/ 研究/ 中/ 被/ 作为/ 基准/ 程序/ 来/ 使用/ 的/ 3/ 个/ 系统/ :/ (/ 1/ )/ ANT/ 系统/ ;/ (/ 2/ )/ DNS/ 系统/ ;/ (/ 3/ )/ BCEL/ 系统/ ./ 其中/ ,/ ANT/ [/ 5/ ]/ 系统/ (/ http/ :/ // // jakarta/ ./ apache/ ./ org/ )/ 包含/ 25/ 个类/ ,/ 83/ 条/ 依赖边/ 和/ 654/ 个/ 依赖/ 环路/ ./ DNS/ [/ 5/ ]/ 系统/ (/ http/ :/ // // www/ ./ xbill/ ./ org/ // dnsjava/ // )/ 可以/ 提供/ 网络/ 域名服务/ ,/ 包含/ 61/ 个类/ ,/ 276/ 条/ 依赖边/ ,/ 其中/ ,/ 10/ 个类/ 构成/ 16/ 个/ 环路/ ./ BCEL/ [/ 5/ ]/ 系统/ (/ http/ :/ // // jakarta/ ./ apache/ ./ org/ // bcel/ // index/ ./ html/ )/ 包含/ 45/ 个类/ ,/ 294/ 条/ 依赖边/ ,/ 其中/ ,/ 41/ 个类/ 构成/ 416091/ 个/ 环路/ ./ 实例/ 的/ 详细信息/ 如/ Page9/ 表/ 5/ 所示/ ./ 其中/ 2/ ~/ 8/ 列为/ 仅/ 考虑/ 类间/ 静态/ 依赖/ 关系/ 时/ 系统/ 的/ 统计/ 信息/ ,/ 当/ 考虑/ 动态/ 依赖/ 关系/ 时/ ,/ 类间/ 关系/ 更加/ 错综/ ,/ 类间/ 测试/ 过程/ 也/ 变得复杂/ 很多/ ,/ 表中/ 最后/ 一列/ 是/ 我们/ 考虑/ 动态/ 依赖/ 关系/ 时/ 统计/ 的/ 环路/ 数目/ ./ 这/ 3/ 个/ 系统/ 的/ 类图/ 可以/ 参照/ Briand/ 等/ 人/ 的/ 文表/ 5/ 系统/ 的/ 详细/ 信息系统/ 名类/ 的/ 数目/ use/ 边数/ As/ 和/ Ag/ 边数/ composition/ 边数/ inheritance/ 边数/ 静态/ 边/ 构成/ 环路/ 数/ 代码/ 行/ 数/ 所有/ 边/ 构成/ 环路/ 数/ ANT2554DNS61211BCEL45182265/ ./ 2/ 实验/ 过程/ 5.2/ ./ 1ANT/ 系统/ 为了/ 说明/ TLOG/ 工具/ 的/ 工作/ 原理/ ,/ 我们/ 给出/ 实验/ 的/ 具体/ 过程/ ./ 首先/ 以/ ANT/ 系统/ 为例/ 进行/ 分析/ ./ 该/ 系统/ 的/ 类图/ 可以/ 参见/ 文献/ [/ 5/ ]/ ,/ 其中/ 所/ 包含/ 的/ 类/ 如表/ 6/ 所示/ ./ 根据/ 本文/ 算法/ 1/ ,/ 当/ 多条/ 关联/ 边/ 的/ 环路/ 数目/ 相同/ ,/ 删除/ 其中/ 任意/ 一条/ 关联/ 边/ ,/ 导致/ 测试/ 顺序/ 的/ 不确定性/ ,/ 同时/ 为了/ 与/ 已有/ 方法/ [/ 6/ ,/ 12/ ]/ 进行/ 比较/ ,/ 我们/ 在/ 实验/ 时/ 运行/ 100/ 次/ ./ 表/ 7/ 首先/ 给出/ 我们/ 的/ 方法/ 打破/ 静态/ 依赖/ 关系/ 构成/ 的/ 环路/ 过程/ (/ 此时/ 假设/ 不/ 考虑/ 动态/ 依赖/ )/ ./ 表/ 7/ 说明/ 采用/ 本文/ 方法/ ,/ 如果/ 只/ 考虑/ 类间/ 静态/ 依赖/ 关系/ ,/ 打破/ 环路/ 共/ 删除/ 10/ 条边/ ./ 因为/ 需要/ 为/ 构表/ 7/ 打破/ ANT/ 系统/ 静态/ 依赖/ 关系/ 构成/ 的/ 环路/ 过程/ 次序/ 12345678910/ 表/ 8/ 增加/ 动态/ 依赖/ 关系/ 后/ 打破/ 环路/ 过程/ 次序/ 环路/ 数目/ 1SCC/ {/ 1/ ,/ 16/ ,/ 2/ ,/ 4/ ,/ 5/ ,/ 10/ ,/ 18/ ,/ 19/ ,/ 20/ ,/ 21/ ,/ 22/ ,/ 23/ ,/ 24/ ,/ 25/ ,/ 17/ }/ 88942SCC/ {/ 1/ ,/ 16/ ,/ 2/ ,/ 4/ ,/ 5/ ,/ 10/ ,/ 18/ ,/ 20/ ,/ 21/ ,/ 22/ ,/ 23/ ,/ 24/ ,/ 25/ ,/ 17/ ,/ 19/ }/ 40173SCC/ {/ 1/ ,/ 16/ ,/ 2/ ,/ 4/ ,/ 5/ ,/ 10/ ,/ 24/ ,/ 20/ ,/ 21/ ,/ 22/ ,/ 23/ ,/ 25/ ,/ 17/ ,/ 19/ }/ 184189716/ →/ 4/ (/ 16/ →/ 1/ )/ (/ 16/ →/ 5/ )/ (/ 16/ →/ 10/ )/ (/ 16/ →/ 25/ )/ 453856204710056891210117125313214115160/ 注/ :/ 表/ 8/ 中/ 最后/ 一列/ 括号/ 中/ 的/ 边/ 表示/ 随/ 关联/ 边/ 的/ 删除/ 而/ 消失/ 的/ 动态/ 依赖边/ ./ 献/ [/ 5/ -/ 6/ ]/ ./ 对象/ 关系/ 图/ (/ ORD/ )/ 的/ 表示/ 方法/ 类似/ 于类/ 图/ ./ 类图/ 比/ ORD/ 多/ 了/ use/ 和/ composition/ 关系/ ,/ 但/ 由于/ use/ 关系/ 和/ association/ 关系/ 同为/ 弱/ 联系/ 关系/ ,/ 因此/ 在/ 计算/ 类间/ 动态/ 依赖/ 关系/ 时/ ,/ 可/ 将/ use/ 视为/ association/ 关系/ ,/ 同理/ ,/ composition/ 关系/ 视为/ aggregation/ 关系/ ./ 113046/ 成/ 这/ 10/ 条边/ 的/ 源类/ 创建/ 测试/ 桩/ ,/ 因此/ ,/ 打破/ ORD/ 中/ 所有/ 环路/ 需要/ 为类/ 18/ ,/ 24/ ,/ 16/ ,/ 20/ ,/ 22/ 构造/ 测试/ 桩/ ,/ 总共/ 需要/ 构造/ 5/ 个/ 测试/ 桩/ ./ 类/ 编号/ 类/ 编号/ 1AntClassLoader14NoBannerLogger2BuildEvent15PathTokenizer3BuildException164BuildListener17ProjectComponent5BuildLogger18ProjectHelper6DefaultLogger19RuntimeConfigurable7DemuxOutputStream208DirectoryScanner219FileScanner22TaskAdapter10IntrospectionHelper23TaskContainer11Launcher24UnknownElement1213/ 环路/ 数目/ 65430613550332212103/ &&/ 21/ &&/ 18Page10/ 本文/ 考虑/ 动态/ 依赖/ 关系/ ,/ 增加/ 20/ 个/ 动态/ 依赖/ 关系/ ,/ 环路/ 数目/ 由/ 654/ 增至/ 8894/ ./ 表/ 8/ 给出/ 了/ SCCs/ 中/ 环路/ 的/ 打破/ 过程/ ./ 从表/ 8/ 可以/ 看出/ ,/ 增加/ 类间/ 动态/ 依赖/ 关系/ 时/ ,/ 打破/ EORD/ 中/ 环路/ 共/ 删除/ 23/ 条边/ ,/ 其中/ ,/ 随/ 关联/ 边/ 的/ 删除/ 而/ 消失/ 的/ 动态/ 依赖边/ 有/ 7/ 条/ ./ 由于/ 需要/ 为/ 删除/ 的/ 这/ 23/ 条边/ 的/ 源类/ 创建/ 测试/ 桩/ ,/ 因此/ ,/ 打破/ EORD/ 中/ 所有/ 环路/ 需要/ 为类/ 18/ ,/ 2/ ,/ 4/ ,/ 1/ ,/ 5/ ,/ 10/ ,/ 25/ ,/ 21/ ,/ 24/ ,/ 22/ ,/ 16/ ,/ 20/ 构造/ 测试/ 桩/ ,/ 总共/ 需要/ 构造/ 12/ 个/ 测试/ 桩/ ./ 最后/ ,/ 利用/ 本文/ 的/ TLOG/ 工具/ 自动/ 生成/ ANT/ 系统/ 的/ 类/ 测试/ 顺序/ ,/ 共/ 13/ 个/ 测试/ 级/ ,/ 其中/ 10/ 个/ 静态/ 测试/ 级/ (/ S/ )/ ,/ 3/ 个/ 动态/ 测试/ 级/ (/ Dy/ )/ ./ 如表/ 9/ 所示/ ./ 其中/ :/ 第/ 1/ 列为/ 主/ 测试/ 顺序号/ ,/ 第/ 2/ 列为/ 被/ 测试/ 的/ 类/ ,/ 第/ 3/ 列为/ 被/ 测类/ 所/ 依赖/ 的/ 类/ ,/ 即/ 在/ 被/ 测类/ 之前/ 进行/ 测试/ 的/ 类/ ./ 第/ 4/ 列为/ 被/ 测类/ 所属/ 测试/ 类型/ ./ 对于/ 主/ 测试/ 顺序号/ 相同/ 的/ 类/ ,/ 它们/ 之间/ 没有/ 依赖/ 关系/ ,/ 其/ 测试/ 顺序/ 可以/ 是/ 任意/ 的/ ./ 因此/ ,/ 表/ 9/ 中/ 的/ 测试/ 顺序/ 并/ 不是/ 唯一/ 的/ 测试/ 顺序/ ./ 5.2/ ./ 2DNS/ 系统/ 对于/ DNS/ 系统/ ,/ 我们/ 采用/ 同样/ 的/ 方法/ 进行/ 实验/ ./ 表/ 10/ 首先/ 给出/ 我们/ 的/ 方法/ 打破/ 静态/ 依赖/ 关系/ 构表/ 10/ 打破/ DNS/ 系统/ 静态/ 依赖/ 关系/ 构成/ 的/ 环路/ 过程/ 次序/ 环路/ 数目/ 1SCC/ {/ 33/ ,/ 38/ ,/ 52/ }/ &&/ SCC/ {/ 8/ ,/ 11/ ,/ 21/ ,/ 25/ ,/ 32/ ,/ 48/ ,/ 58/ }/ 3/ &&/ 132SCC/ {/ 33/ ,/ 38/ }/ &&/ SCC/ {/ 32/ ,/ 48/ ,/ 58/ }/ &&/ SCC/ {/ 8/ ,/ 21/ }/ 1/ &&/ 2/ &&/ 133/ →/ 38/ &&/ 32/ →/ 48/ &&/ 21/ →/ 834/ 表/ 10/ 说明/ 采用/ 本文/ 方法/ ,/ 如果/ 只/ 考虑/ 类间/ 静态/ 依赖/ 关系/ 时/ ,/ 打破/ 环路/ 共/ 删除/ 6/ 条边/ ./ 打破/ ORD/ 中/ 所有/ 环路/ 需要/ 为类/ 52/ ,/ 11/ ,/ 38/ ,/ 48/ ,/ 8/ ,/ 58/ 构造/ 测试/ 桩/ ,/ 总共/ 需要/ 构造/ 6/ 个/ 测试/ 桩/ ./ 本文/ 考虑/ 动态/ 依赖/ 关系/ ,/ 增加/ 175/ 个/ 动态/ 依赖/ 关系/ ,/ 但/ 环路/ 数目/ 不变/ ./ 表/ 11/ 给出/ 了/ SCCs/ 中/ 环路/ 的/ 打破/ 过程/ ./ 表/ 11/ 增加/ 动态/ 依赖/ 关系/ 后/ 打破/ 环路/ 过程/ 次序/ 环路/ 数目/ 1SCC/ {/ 38/ ,/ 33/ ,/ 52/ }/ &&/ SCC/ {/ 8/ ,/ 11/ ,/ 21/ ,/ 25/ ,/ 32/ ,/ 48/ ,/ 58/ }/ 3/ &&/ 132SCC/ {/ 52/ ,/ 33/ }/ &&/ SCC/ {/ 32/ ,/ 48/ ,/ 58/ }/ &&/ SCC/ {/ 8/ ,/ 21/ }/ 1/ &&/ 2/ &&/ 152/ →/ 33/ &&/ 32/ →/ 48/ &&/ 21/ →/ 834/ 表/ 12DNS/ 系统/ 基于/ 测试/ 级/ 的/ 测试/ 顺序/ 类型/ 主/ 测试/ 级主/ 测试/ 级/ 19/ ,/ 10/ ,/ 13/ ,/ 15/ ,/ 17/ ,/ 27/ ,/ 28/ ,/ 31/ ,/ 36/ ,/ 44/ ,/ 46/ ,/ 49S11S122S1334S145S15/ 成/ 的/ 环路/ 过程/ (/ 此时/ 假设/ 不/ 考虑/ 动态/ 依赖/ )/ ./ 主/ 测试/ 级/ 被/ 测类/ X/ 依赖/ 的/ 类/ SD/ (/ X/ )/ 14/ ,/ 9/ ,/ 12/ ,/ 23384215206163/ ,/ 12/ ,/ 15/ ,/ 17/ ,/ 20/ ,/ 19/ ,/ 21/ ,/ 23S7891410131121261310/ 从表/ 11/ 可以/ 看出/ ,/ 增加/ 类间/ 动态/ 依赖/ 关系/ 时/ ,/ 打破/ EORD/ 中/ 环路/ 共/ 删除/ 6/ 条边/ ./ 打破/ EORD/ 中/ 所有/ 环路/ 需要/ 为类/ 33/ ,/ 11/ ,/ 48/ ,/ 8/ ,/ 58/ 构造/ 测试/ 桩/ ,/ 总共/ 需要/ 构造/ 5/ 个/ 测试/ 桩/ ./ 针对/ DNS/ 系统/ ,/ 利用/ 本文/ 的/ TLOG/ 工具/ ,/ 我们/ 最后/ 得到/ 19/ 个/ 测试/ 级/ ,/ 其中/ 12/ 个/ 静态/ 测试/ 级/ (/ S/ )/ 、/ 7/ 个/ 动态/ 测试/ 级/ (/ Dy/ )/ ./ 最终/ 的/ 具体/ 测试/ 顺序/ 如表/ 12/ 所示/ ./ 10Page11/ 主/ 测试/ 级/ 类型/ 主/ 测试/ 级/ 677/ ,/ 11/ ,/ 20/ ,/ 24/ ,/ 30/ ,/ 35/ ,/ 41/ ,/ 54/ ,/ 55/ ,/ 57S178S189S19105/ ./ 2.3/ BCEL/ 系统/ BCEL/ 系统/ 包含/ 416091/ 个/ 环路/ (/ 不/ 考虑/ 动态/ 依赖/ )/ ,/ 由于/ 篇幅/ 有限/ ,/ 只/ 简单/ 给出/ 采用/ 本文/ 方法/ 打破/ 静态/ 依赖/ 关系/ 构成/ 的/ 环路/ 过程/ ,/ 如表/ 13/ 所示/ ./ 打破/ 环路/ 共/ 删除/ 73/ 条边/ ,/ 总共/ 需要/ 构造/ 56/ 个/ 测试/ 桩/ ./ 考虑/ 动态/ 依赖/ 关系/ 后/ ,/ 增加/ 138/ 个/ 动态/ 依赖/ 关系/ ,/ 环路/ 数目/ 增加/ 至/ 626826/ 个/ ./ 表/ 14/ 简单/ 给出/ 了/ 表/ 13/ 打破/ BCEL/ 系统/ 静态/ 依赖/ 关系/ 构成/ 的/ 环路/ 过程/ 次序/ 1SCC/ {/ 2/ ,/ 4/ ,/ 35/ ,/ 30/ ,/ 45/ ,/ 5/ ,/ 6/ ,/ 7/ ,/ 18/ ,/ 8/ ,/ 10/ ,/ 13/ ,/ 21/ ,/ 26/ ,/ 15/ ,/ 9/ ,/ 11/ ,/ 12/ ,/ 14/ ,/ 16/ ,/ 17/ ,/ 19/ ,/ 2SCC/ {/ 2/ ,/ 4/ ,/ 35/ ,/ 45/ ,/ 5/ ,/ 6/ ,/ 7/ ,/ 18/ ,/ 8/ ,/ 10/ ,/ 13/ ,/ 21/ ,/ 26/ ,/ 15/ ,/ 9/ ,/ 11/ ,/ 12/ ,/ 14/ ,/ 16/ ,/ 17/ ,/ 19/ ,/ 22/ ,/ 25/ ,/ 3SCC/ {/ 2/ ,/ 4/ ,/ 45/ ,/ 5/ ,/ 6/ ,/ 7/ ,/ 18/ ,/ 8/ ,/ 10/ ,/ 13/ ,/ 21/ ,/ 26/ ,/ 15/ ,/ 9/ ,/ 11/ ,/ 12/ ,/ 14/ ,/ 16/ ,/ 17/ ,/ 19/ ,/ 22/ ,/ 25/ ,/ 27/ ,/ …/ 7374/ 表/ 14/ 增加/ 动态/ 依赖/ 关系/ 后/ 打破/ 环路/ 过程/ 次序/ 1SCC/ {/ 2/ ,/ 3/ ,/ 4/ ,/ 35/ ,/ 30/ ,/ 45/ ,/ 5/ ,/ 6/ ,/ 7/ ,/ 9/ ,/ 18/ ,/ 8/ ,/ 10/ ,/ 13/ ,/ 21/ ,/ 26/ ,/ 15/ ,/ 9/ ,/ 11/ ,/ 12/ ,/ 14/ ,/ 16/ ,/ 17/ ,/ 2SCC/ {/ 2/ ,/ 3/ ,/ 4/ ,/ 35/ ,/ 30/ ,/ 45/ ,/ 5/ ,/ 6/ ,/ 7/ ,/ 9/ ,/ 18/ ,/ 8/ ,/ 10/ ,/ 13/ ,/ 21/ ,/ 15/ ,/ 9/ ,/ 11/ ,/ 12/ ,/ 14/ ,/ 16/ ,/ 17/ ,/ 19/ ,/ 3SCC/ {/ 2/ ,/ 3/ ,/ 4/ ,/ 35/ ,/ 30/ ,/ 45/ ,/ 5/ ,/ 6/ ,/ 7/ ,/ 9/ ,/ 18/ ,/ 8/ ,/ 10/ ,/ 13/ ,/ 21/ ,/ 15/ ,/ 9/ ,/ 11/ ,/ 12/ ,/ 14/ ,/ 16/ ,/ 17/ ,/ 19/ ,/ …/ 8788/ 表/ 15BCEL/ 系统/ 基于/ 测试/ 级/ 的/ 测试/ 顺序/ 主/ 测试/ 级/ 类型/ 主/ 测试/ 级/ 1S10238/ ,/ 9/ ,/ 11/ ,/ 12/ ,/ 14/ ,/ 16/ ,/ 20/ ,/ 22/ ,/ 25/ ,/ 32/ ,/ 34/ ,/ 39/ ,/ 40/ ,/ 43/ ,/ 44S12S134S145S1567S168S1795/ ./ 3/ 实验/ 结果/ 及/ 分析/ 这/ 一节/ 中/ ,/ 我们/ 就/ 打破/ 环路/ 所/ 需/ 构造/ 测试/ 桩/ 的/ 数目/ ,/ 分别/ 与/ 文献/ [/ 6/ ]/ 中/ Briand/ 、/ Traon/ 和/ Tai/ 等/ 人/ 的/ 3/ 种/ 只/ 考虑/ 静态/ 依赖/ 关系/ 的/ 测试方法/ 、/ 文献/ [/ 13/ ]/ SCCs/ 中/ 环路/ 的/ 打破/ 过程/ ./ 打破/ EORD/ 中/ 环路/ 共/ 删除/ 87/ 条边/ ,/ 总共/ 需要/ 构造/ 70/ 个/ 测试/ 桩/ ./ 针对/ BCEL/ 系统/ ,/ 利用/ 本文/ 的/ TLOG/ 工具/ ,/ 我们/ 最后/ 得到/ 17/ 个/ 测试/ 级/ ,/ 其中/ 10/ 个/ 静态/ 测试/ 级/ (/ S/ )/ 、/ 7/ 个/ 动态/ 测试/ 级/ (/ Dy/ )/ ./ 最终/ 的/ 具体/ 测试/ 顺序/ 如表/ 15/ 所示/ ./ 中/ Li/ 的/ 增加/ 动态/ 依赖/ 关系/ 的/ 类/ 集成/ 测试方法/ 进行/ 比较/ ,/ 比较/ 结果/ 如表/ 16/ ~/ 18/ 所示/ ./ 其中/ 横坐标/ 表示/ 在/ 算法/ 执行/ 中/ 所/ 花费/ 测试/ 桩/ 的/ 个数/ ,/ 纵坐标/ 表示/ 在/ 100/ 次/ 算法/ 执行/ 中/ 与/ 测试/ 桩/ 的/ 个数/ 相对/ 应/ 的/ 次数/ ./ Page12/ 表/ 16ANT/ 系统/ 结果/ 表/ 17DNS/ 系统/ 结果/ 表/ 18BCEL/ 系统/ 结果/ 算法/ 执行/ 次数/ 算法/ 执行/ 次数/ 算法/ 执行/ 次数/ 算法/ 执行/ 次数/ 算法/ 执行/ 次数/ 算法/ 执行/ 次数/ Page13/ 通过/ 表/ 16/ ~/ 18/ 中/ 的/ 结果/ 可以/ 发现/ :/ 对于/ ANT/ 系统/ ,/ 如果/ 仅/ 考虑/ 类间/ 的/ 静态/ 依赖/ 关系/ ,/ 采用/ 本文/ 方法/ 执行/ 算法/ 100/ 次/ ,/ 均/ 需要/ 构造/ 5/ 个/ 测试/ 桩/ ,/ 而/ 采用/ Briand/ 等/ 人/ [/ 6/ ]/ 、/ Le/ 等/ 人/ [/ 4/ ]/ 和/ Tai/ 等/ 人/ [/ 3/ ]/ 的/ 3/ 种/ 方法/ 均/ 构造/ 多于/ 10/ 个/ 测试/ 桩/ ;/ 如果/ 增加/ 类间/ 的/ 动态/ 依赖/ 关系/ ,/ 采用/ 本文/ 方法/ 需要/ 构造/ 12/ 个/ 测试/ 桩/ ,/ Li/ 的/ 方法/ [/ 13/ ]/ 同样/ 需/ 构造/ 12/ 个/ 测试/ 桩/ ./ 对于/ DNS/ 系统/ ,/ 如果/ 仅/ 考虑/ 类间/ 的/ 静态/ 依赖/ 关系/ ,/ 采用/ 本文/ 方法/ 需要/ 构造/ 6/ 个/ 测试/ 桩/ ,/ 与/ 采用/ Briand/ 等/ 人/ [/ 6/ ]/ 的/ 方法/ 构造/ 相同/ 个数/ 的/ 测试/ 桩/ ,/ 而/ 采用/ Le/ 等/ 人/ [/ 4/ ]/ 和/ Tai/ 等/ 人/ [/ 3/ ]/ 的/ 3/ 种/ 方法/ 均/ 构造/ 多于/ 6/ 个/ 测试/ 桩/ ;/ 如果/ 增加/ 类间/ 的/ 动态/ 依赖/ 关系/ ,/ 采用/ 本文/ 方法/ 需要/ 构造/ 5/ 个/ 测试/ 桩/ ,/ Li/ 的/ 方法/ [/ 13/ ]/ 同样/ 需/ 构造/ 5/ 个/ 测试/ 桩/ ./ 对于/ BCEL/ 系统/ ,/ 如果/ 仅/ 考虑/ 类间/ 的/ 静态/ 依赖/ 关系/ ,/ 采用/ 本文/ 方法/ 需要/ 构造/ 56/ 个/ 测试/ 桩/ ,/ 而/ 采用/ Briand/ 等/ 人/ [/ 6/ ]/ 、/ Le/ 等/ 人/ [/ 4/ ]/ 和/ Tai/ 等/ 人/ [/ 3/ ]/ 的/ 3/ 种/ 方法/ 均/ 构造/ 多于/ 67/ 个/ 测试/ 桩/ ;/ 如果/ 增加/ 类间/ 的/ 动态/ 依赖/ 关系/ ,/ 采用/ 本文/ 方法/ 需要/ 构造/ 70/ 个/ 测试/ 桩/ ,/ Li/ 的/ 方法/ [/ 13/ ]/ 同样/ 需/ 构造/ 70/ 个/ 测试/ 桩/ ./ 实验/ 结果/ 证明/ :/ 从/ 这/ 两个/ 方面/ 与/ 已有/ 的/ 集成/ 测试方法/ 相比/ ,/ 如果/ 仅/ 考虑/ 类间/ 的/ 静态/ 依赖/ 关系/ ,/ 本文/ 方法/ 与/ Briand/ 、/ Le/ 和/ Tai/ 等/ 人/ 的/ 3/ 种/ 方法/ 相比/ ,/ 构造/ 的/ 测试/ 桩/ 的/ 个数/ 最少/ ;/ 如果/ 增加/ 类间/ 的/ 动态/ 依赖/ 关系/ ,/ 采用/ 本文/ 方法/ 需要/ 构造/ 的/ 测试/ 桩/ 个数/ 与/ 采用/ Li/ 的/ 方法/ [/ 13/ ]/ 相等/ ,/ 但是/ ,/ 他/ 的/ 方法/ 存在/ 缺陷/ :/ 允许/ 断开/ 继承/ 边/ 和/ 聚集/ 边/ 等/ 强/ 联系/ 边来/ 打破/ 环路/ ,/ 导致/ 测试/ 桩/ 复杂度/ 的/ 提高/ ,/ 因此/ ,/ 如果/ 在/ 不/ 允许/ 断开/ 强/ 联系/ 边/ 的/ 情况/ 下/ ,/ Li/ 的/ 方法/ 将会/ 大大增加/ 测试/ 桩/ 的/ 个数/ ./ 因此/ ,/ 体现/ 了/ 本文/ 方法/ 的/ 有效性/ ./ 6/ 相关/ 工作/ 讨论/ 现有/ 的/ 类间/ 测试/ 顺序/ 研究/ 方法/ 大多/ 仅限于/ 静态/ 分析/ :/ Kung/ 等/ 人/ [/ 1/ ]/ 最早/ 提出/ 解决/ 类间/ 测试/ 顺序/ 问题/ 的/ 方法/ ,/ 并/ 证明/ 如果/ 对象/ 关系/ 图中/ 没有/ 环/ ,/ 则/ 可以/ 通过/ 逆向/ 拓扑/ 排序/ 得到/ 类间/ 测试/ 顺序/ ./ 如果/ 类图/ 中/ 有/ 环/ ,/ 则/ 首先/ 识别/ 其中/ 的/ 强/ 联通/ 分量/ ,/ 然后/ 删除/ 部分/ 关联/ 边/ 使/ 之/ 成为/ 无环图/ ./ Tai/ 等/ 人/ [/ 3/ ]/ 提出/ 的/ 测试/ 顺序/ 分配/ 策略/ 将/ ORD/ 中/ 的/ 3/ 种/ 关系/ 分为/ 两个/ 层次/ :/ 继承/ 关系/ 和/ 聚集/ 关系/ 位于/ 一个/ 层次/ ,/ 关联/ 关系/ 处于/ 一个/ 层次/ ./ 当/ 穿越/ 主层/ 的/ 关联/ 关系/ 没有/ 形成/ 环路/ 时/ ,/ 该/ 策略/ 导致/ 构造/ 不必要/ 的/ 测试/ 桩/ ./ Le/ 等/ 人/ [/ 4/ ]/ 采用/ 了/ 一种/ 基于/ 测试/ 依赖图/ 模型/ 的/ 方法/ 进行/ 集成/ 测试/ ,/ 测试/ 依赖图/ 是/ 由类/ 和/ 方法/ 之间/ 的/ 测试/ 依赖/ 关系/ 构成/ 的/ ,/ 他们/ 的/ 策略/ 减少/ 了/ 桩/ 的/ 数量/ ,/ 但/ 可能/ 断开/ 继承/ 和/ 聚集/ 关系/ ./ 之后/ ,/ Briand/ 等/ 人/ [/ 6/ ]/ 在/ 不/ 打破/ 继承/ 、/ 聚集/ 等/ 强/ 联系/ 关系/ 的/ 前提/ 下/ ,/ 给出/ 基于/ 图论/ 的/ 测试/ 顺序/ 策略/ ,/ 通过/ 最小化/ 测试/ 桩/ 的/ 数目/ 找到/ 一个/ 最佳/ 测试/ 顺序/ ,/ 与/ Le/ 和/ Tai/ 的/ 方法/ 相比/ ,/ 所/ 需/ 测试/ 桩/ 数目/ 最少/ ./ Jaroenpiboonkit/ 等/ 人/ [/ 12/ ]/ 提出/ 了/ 一种/ 使用/ 测试/ 依赖图/ 和/ 面向对象/ 切片/ 技术/ 找到/ 一个/ 满足/ 最小化/ 测试/ 桩/ 的/ 数目/ 的/ 最佳/ 测试/ 顺序/ 的/ 方法/ ./ 以上/ 方法/ 均/ 未/ 考虑/ 类间/ 的/ 动态/ 依赖/ 关系/ ./ 考虑/ 类间/ 的/ 动态/ 依赖/ 关系/ 的/ 文献/ 相对/ 较/ 少/ :/ La/ -/ biche/ 等/ 人/ [/ 7/ ]/ 给出/ 了/ 基于/ 测试/ 级/ 的/ 类间/ 测试/ 序列/ 生成/ 方法/ ,/ Kraft/ 等/ 人/ [/ 2/ ]/ 和/ Paradkar/ [/ 14/ ]/ 在/ 类/ 集成/ 测试/ 中/ 考虑/ 了/ 动态/ 依赖/ 关系/ ,/ 但是/ 以上/ 4/ 种/ 方法/ 均/ 没有/ 考虑/ 动态/ 依赖/ 关系/ 对/ 构成/ 的/ 环路/ 的/ 影响/ ,/ 因此/ 也/ 没有/ 给出/ 相关/ 的/ 边/ 的/ 删除/ 规则/ ;/ 就/ 我们/ 所知/ ,/ 目前/ 只有/ Li/ 等/ 人/ [/ 13/ ]/ 提出/ 了/ 考虑/ 动态/ 依赖/ 关系/ 时/ 的/ 环路/ 中边/ 的/ 删除/ 规则/ ,/ 解决/ 了/ 忽略/ 类间/ 动态/ 依赖/ 关系/ 所/ 导致/ 的/ 测试/ 桩/ 的/ 数目/ 不足以/ 完成/ 测试/ 的/ 问题/ ,/ 但是/ 他/ 的/ 方法/ 允许/ 断开/ 聚集/ 依赖/ 关系/ ,/ 引起/ 构造/ 复杂/ 测试/ 桩/ 的/ 问题/ ,/ 并且/ 在/ 某些/ 情况/ 下/ 可能/ 产生/ 多余/ 测试/ 桩/ ./ 将/ 本文/ 方法/ 与/ 已有/ 的/ 算法/ 所得/ 的/ 类/ 测试/ 顺序/ 进行/ 比较/ ,/ 可以/ 得出/ 如下/ 结论/ :/ (/ 1/ )/ 动态/ 测试/ 级/ 的/ 引入/ 是/ 本文/ 的/ 一大/ 特点/ ./ 我们/ 的/ 方法/ 解决/ 了/ 测试/ 桩/ 的/ 数量/ 不能/ 满足/ 被/ 测类/ 充分/ 测试/ 的/ 问题/ ./ (/ 2/ )/ 本文/ 对/ 存在/ 环路/ 的/ 类/ 簇/ 进行/ 集成/ 测试/ ,/ 打破/ 环路/ 时仅/ 允许/ 删除/ 关联/ 边/ 和/ 动态/ 依赖边/ ,/ 遵循/ 以/ 最少/ 的/ 边/ 打破/ 更/ 多/ 环路/ 的/ 原则/ ,/ 花费/ 较/ 低/ 的/ 测试/ 代价/ ./ (/ 3/ )/ 本文/ 的/ 测试/ 级/ 表示/ 方法/ 可以/ 获得/ 更/ 多/ 的/ 信息量/ ,/ 能够/ 更加/ 清晰/ 、/ 充分/ 地/ 表示/ 类簇/ 的/ 测试/ 序列/ ./ 其中/ ,/ 相同/ 测试/ 级/ 中/ 的/ 类/ 的/ 测试/ 顺序/ 可以/ 交换/ ./ 该/ 方法/ 不仅/ 能够/ 灵活/ 体现/ 出/ 各/ 测试/ 级/ 的/ 序列/ ,/ 也/ 能够/ 反映/ 出当/ 测试/ 某/ 一个/ 类时/ ,/ 该类/ 所/ 依赖/ 的/ 类/ 以及/ 一个/ 测试/ 级/ 相对/ 于/ 上/ 一级/ 所/ 增加/ 的/ 类/ ./ 因此/ ,/ 根据/ 测试/ 级/ 可以/ 得到/ 一种/ 增量/ 测试/ ,/ 能够/ 达到/ 测试用例/ 的/ 高度/ 重用/ ,/ 而/ 测试用例/ 的/ 重用/ 使/ 派生类/ 测试/ 中所/ 需/ 重新/ 设计/ 的/ 测试用例/ 减少/ ,/ 加快/ 测试/ 的/ 进度/ ./ 7/ 结束语/ 类间/ 测试/ 顺序/ 的/ 确定/ 是/ 类间/ 集成/ 测试/ 中/ 最/ 重要/ 的/ 问题/ ./ 测试/ 桩/ 的/ 复杂性/ 标准/ 目前/ 国内外/ 大多/ 只/ 针对/ 类间/ 静态/ 依赖/ 关系/ 进行/ 分析/ ,/ 而/ 忽略/ 了/ 类间/ 动态/ 依赖/ 关系/ ,/ 虽然/ 一些/ 相关/ 研究/ 中/ 已经/ 考虑/ 类间/ 动态/ Page14/ 依赖/ 关系/ ,/ 但是/ 并/ 没有/ 进行/ 定量分析/ ,/ 因此/ 基于/ 类间/ 动态/ 依赖/ 关系/ 建立/ 测试/ 桩/ 的/ 方法/ 是/ 一个/ 新/ 的/ 研究/ 领域/ ./ 为了/ 解决/ 已有/ 的/ 方法/ 忽略/ 动态/ 依赖/ 关系/ 的/ 问题/ ,/ 为/ 测试/ 提供/ 足够/ 的/ 测试/ 桩/ ,/ 本文/ 不仅/ 分析/ 了/ 类/ 之间/ 的/ 静态/ 依赖/ 关系/ ,/ 更/ 重点/ 分析/ 了/ 类间/ 的/ 动态/ 依赖/ 关系/ ,/ 并/ 考虑/ 了/ 动态/ 依赖边/ 对/ 消除/ 环路/ 的/ 影响/ ,/ 给出/ 了/ 环路/ 消除/ 算法/ ./ 由于/ 本文/ 增加/ 了/ 动态/ 依赖/ 关系/ 的/ 分析/ ,/ 对于/ 动态/ 依赖/ 关系/ 的/ 测试/ 桩/ 的/ 复杂性/ 标准/ 难以确定/ ,/ 因此/ ,/ 我们/ 从/ 构造/ 测试/ 桩/ 数目/ 的/ 角度/ 与/ 已有/ 方法/ 进行/ 比较/ ,/ 结果/ 证明/ 本文/ 方法/ 能够/ 以/ 相对/ 较少/ 的/ 测试/ 桩/ 满足/ 类/ 的/ 静态/ 测试/ 和/ 动态/ 测试/ ./ 对于/ 大型/ 面向对象/ 程序/ 来说/ ,/ 被测/ 程序/ 中类/ 的/ 数量/ 很多/ ,/ 工作量/ 相当/ 庞大/ ./ 在/ 此基础/ 上/ 我们/ 开发/ 了/ 测试/ 级/ 生成器/ TLOG/ ,/ 能够/ 自动/ 生成/ 基于/ 测试/ 级/ 的/ 类/ 集成/ 测试/ 序列/ ,/ 减少/ 测试/ 的/ 工作量/ ,/ 提高/ 测试/ 效率/ ./ 本文/ 通过/ 最小化/ 测试/ 桩/ 的/ 数量/ 来/ 确定/ 类间/ 测试/ 顺序/ ,/ 一方面/ 是/ 由于/ 目前/ 针对/ 动态/ 依赖边/ 的/ 复杂度/ 还/ 没有/ 一个/ 度量/ 标准/ ;/ 另一方面/ 是/ 由于/ 现有/ 已/ 考虑/ 动态/ 依赖边/ 的/ 文献/ 中/ ,/ 均/ 采用/ 构造/ 测试/ 桩/ 的/ 数量/ 作为/ 衡量标准/ ,/ 而/ 没有/ 从/ 测试/ 桩/ 复杂度/ 的/ 角度/ 进行/ 研究/ ,/ 为了/ 与/ 已有/ 的/ 方法/ 进行/ 比较/ ,/ 我们/ 也/ 将/ 构造/ 测试/ 桩/ 的/ 数量/ 作为/ 衡量标准/ ./ 在/ 满足/ 最小化/ 测试/ 桩/ 复杂度/ 的/ 前提/ 下/ ,/ 确定/ 包含/ 动态/ 依赖/ 关系/ 的/ 类间/ 测试/ 顺序/ ,/ 作为/ 我们/ 下/ 一步/ 要/ 研究/ 的/ 内容/ 之一/ ./ 此外/ ,/ 可以/ 发现/ ,/ 本文/ 中/ 我们/ 没有/ 考虑/ 抽象类/ 的/ 特点/ ,/ 实际上/ ,/ 抽象类/ 的/ 特性/ ,/ 将会/ 影响/ 类间/ 的/ 依赖性/ ,/ 进而/ 将/ 影响/ 类间/ 测试/ 序/ ./ 这是/ 我们/ 目前/ 正在/ 解决/ 的/ 主要/ 问题/ 之一/ ./ 致谢/ 在/ 此/ ,/ 我们/ 向/ 对/ 本文/ 给予/ 建议/ 的/ 同行/ 表示感谢/ ./ 同时/ ,/ 对/ 审稿人/ 提出/ 的/ 有益/ 建议/ 表示感谢/ ./ 

