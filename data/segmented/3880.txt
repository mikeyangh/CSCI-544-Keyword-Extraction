Page1/ 一种/ 有效/ 的/ GLR/ 分析器/ 错误/ 恢复/ 方法/ 许福/ 1/ )/ 刘辉/ 2/ )/ 孙俏/ 1/ )/ 陈志泊/ 1/ )/ 王春玲/ 1/ )/ 1/ )/ (/ 北京林业大学/ 信息/ 学院/ 北京/ 100083/ )/ 2/ )/ (/ 北京航空航天大学/ 计算机/ 学院/ 北京/ 100191/ )/ 摘要/ 传统/ 的/ 分析器/ 生成器/ 多/ 采用/ LALR/ (/ 1/ )/ 、/ LL/ (/ 1/ )/ 等/ 确定性/ 分析方法/ ./ 近年来/ ,/ 随着/ 软件/ 再/ (/ 逆向/ )/ 工程/ 的/ 发展/ ,/ GLR/ 等/ 非/ 确定性/ 的/ 分析方法/ 逐渐/ 应用/ 到/ 分析器/ 生成器/ 中/ ,/ 但/ 目前/ 尚未/ 有/ 公开/ 发表/ 的/ 文献/ 提出/ 并/ 解决/ 了/ 自动/ 生成/ 的/ GLR/ 分析器/ 的/ 错误处理/ 和/ 恢复/ 问题/ ./ 文中/ 提出/ 了/ 一种/ 基于/ 子串/ 分析/ 的/ 错误/ 恢复/ 方法/ ,/ 实验/ 结果表明/ ,/ 该/ 方法/ 可以/ 有效/ 侦测/ 和/ 恢复/ 输入/ 串中/ 的/ 语法错误/ ,/ 具有/ 较/ 高/ 的/ 错误处理/ 效率/ ,/ 有望/ 应用/ 到/ 以/ GLR/ 为/ 核心/ 算法/ 的/ 分析器/ 生成器/ 中/ ./ 关键词/ GLR/ ;/ 语法分析/ 器/ ;/ 分析器/ 生成器/ ;/ 错误处理/ ;/ 错误/ 恢复/ 1/ 引言/ LALR/ (/ 1/ )/ 、/ LL/ (/ 1/ )/ 等/ 确定性/ 方法/ 长期/ 统治/ 计算机/ 语言/ 的/ 语法分析/ ./ 进入/ 21/ 世纪/ 以来/ ,/ 语法分析/ 技术/ 正/ 经历/ 确定性/ 分析/ 向/ 非/ 确定性/ 分析/ 的/ 转型/ 过程/ [/ 1/ -/ 2/ ]/ ./ 作为/ 非/ 确定性/ 分析方法/ 中/ 的/ 典型/ 代表/ —/ —/ —/ GLR/ [/ 3/ ]/ ,/ 也/ Page2/ 分析/ 错误/ 主要/ 包括/ 词法/ 错误/ 、/ 语法错误/ 、/ 语义/ 错误/ 和/ 逻辑/ 错误/ 4/ 类/ ./ 词法/ 错误/ 的/ 处理/ 比较简单/ ,/ 不再/ 赘述/ ./ 语义/ 错误/ 和/ 逻辑/ 错误/ ,/ 与/ 语言/ 语义/ 和/ 执行/ 模型/ 密切相关/ ,/ 难以实现/ 通用/ 的/ 、/ 语言/ 无关/ 的/ 语义/ 错误/ 和/ 逻辑/ 错误处理/ ./ 无/ 特殊/ 说明/ ,/ 本文/ 提及/ 的/ 错误处理/ 和/ 恢复/ 专指/ 语法错误/ 的/ 处理/ 和/ 恢复/ ./ GLR/ 是/ 由/ LR/ 扩展/ 而来/ 的/ 一种/ 分析方法/ ,/ LR/ 错误处理/ 方面/ 的/ 研究/ 结果/ 较/ 多/ ,/ 对/ GLR/ 的/ 错误处理/ 策略/ 具有/ 借鉴/ 作用/ ./ 本文/ 首先/ 介绍/ LR/ 常用/ 的/ 错误处理/ 和/ 恢复/ 策略/ ,/ 在/ 此基础/ 上/ ,/ 讨论/ GLR/ 的/ 错误处理/ 和/ 恢复/ 方法/ ./ 2LR/ 错误处理/ 和/ 恢复/ 骤/ :/ 错误/ 侦测/ 、/ 错误报告/ 和/ 错误/ 恢复/ [/ 5/ ]/ ./ LR/ 分析器/ 的/ 错误/ 处理过程/ 包括/ 3/ 个/ 典型/ 步/ (/ 1/ )/ 错误/ 侦测/ ./ 错误/ 侦测/ 是/ 指/ 侦测/ 文法/ 或/ 输入/ 串中/ 存在/ 的/ 错误/ ./ 通常/ 文法/ 出错/ 的/ 概率/ 较/ 小/ ,/ 大都/ 是/ 输入/ 串/ 出错/ ./ 本文/ 讨论/ 的/ 错误处理/ 和/ 恢复/ 专指/ 输入/ 串/ 的/ 错误处理/ 和/ 恢复/ ./ “/ 正确/ 前缀/ 性质/ ”/ [/ 6/ ]/ ,/ 是/ LR/ 错误/ 侦测/ 的/ 基础/ ,/ 可/ 保证/ 总能/ 侦测/ 到/ 输入/ 串中/ 的/ 非法/ 符号/ ,/ 且/ 已/ 移入/ 的/ 符号/ 总是/ 文法/ 中/ 某/ 句子/ 的/ 合法/ 前缀/ ./ 为/ 行文/ 简洁/ ,/ 本文/ 用/ “/ 非法/ 符号/ ”/ 泛指/ 输入/ 串中/ 的/ 错误/ ,/ 用/ “/ 错误/ 符号/ ”/ 专指/ 输入/ 串中/ 的/ 第一个/ 非法/ 符号/ ./ 有限/ 状态机/ 和/ LR/ (/ 1/ )/ 分析器/ 具备/ “/ 立即/ 错误/ 侦测/ 性质/ ”/ [/ 7/ ]/ ,/ 当/ 首次/ 扫描/ 到/ 错误/ 符号/ 时/ ,/ 就/ 可以/ 立即/ 侦测/ 到/ 错误/ ./ 与/ 此/ 不同/ ,/ 满足/ “/ 正确/ 前缀/ 性质/ ”/ 的/ LR/ 分析器/ 在/ 执行/ 移进/ 动作/ 时/ 才能/ 检测/ 到/ 错误/ ,/ 在/ 这/ 之前/ 可能/ 已/ 额外/ 执行/ 了/ 多步/ 归约/ 动作/ ./ LALR/ (/ 1/ )/ 和/ SLR/ (/ 1/ )/ 分析器/ 不/ 具备/ 立即/ 错误/ 侦测/ 性质/ [/ 7/ ]/ ,/ 但/ 所有/ LR/ 类/ 分析器/ 都/ 满足/ 正确/ 前缀/ 性质/ ./ (/ 2/ )/ 错误报告/ ./ 分析器/ 需要/ 以/ 恰当/ 的/ 形式/ 报告/ 侦测/ 到/ 的/ 错误/ ./ 文献/ [/ 8/ ]/ 总结/ 了/ 良好/ 的/ 错误报告/ 应/ 满足/ 的/ 几个/ 指标/ :/ ①/ 正确/ 报告/ 错误/ ,/ 不/ 误报/ 、/ 漏报/ 错误/ ;/ ②/ 尽早/ 报告/ 错误/ ;/ ③/ 错误报告/ 友好/ ,/ 应/ 基于/ 直观/ 的/ 文法/ 和/ 输入/ 串/ ,/ 而/ 不是/ 抽象/ 的/ 分析/ 状态/ 和/ 分析/ 动作/ ;/ ④/ 避免/ 重复/ 报告/ 相同/ 错误/ ;/ ⑤/ 分析器/ 应能/ 从/ 错误/ 中/ 恢复/ ,/ 从而/ 可以/ 侦测/ 后续/ 的/ 更/ 多/ 错误/ ./ (/ 3/ )/ 错误/ 恢复/ ./ 错误/ 恢复/ 是/ 指/ ,/ 遇到/ 非法/ 符号/ 时/ ,/ 适当/ 调整/ 分析/ 栈/ 和/ 输入/ 串/ ,/ 使/ 分析/ 过程/ 可以/ 继续/ 进行/ ./ 包括/ 更正/ 性/ 、/ 非/ 更正/ 性/ 两类/ 错误/ 恢复/ 方法/ ./ 其中/ ,/ 前者/ 修改/ 分析/ 栈/ 或/ 输入/ 串/ ;/ 后者/ 不/ 修改/ ,/ 而是/ 跳过/ 一个/ 或/ 多个/ 符号/ ,/ 从/ 输入/ 串/ 某个/ 位置/ 继续/ 分析/ ./ Error/ 产生/ 式/ [/ 9/ ]/ 是/ 应用/ 较/ 多/ 的/ 一种/ 更正/ 性/ 错误/ 恢复/ 方法/ ,/ 通过/ 插入/ 形/ 如/ “/ A/ →/ α/ error/ β/ ”/ 的/ 产生/ 式/ 执行/ 恢复/ ./ 其中/ ,/ error/ 被/ 当作/ 特殊/ 的/ 终结符/ ,/ 遇到/ 错误/ 后/ ,/ Follow/ (/ error/ )/ [/ 8/ ]/ 成为/ 同步/ 符号/ ./ error/ 产生/ 式/ 恢复/ 效果/ 较/ 好/ ,/ 但/ 依赖于/ 开发者/ 的/ 个人/ 技巧/ ,/ 无法/ 实现/ 自动/ 的/ 错误处理/ 和/ 恢复/ ./ 除/ error/ 产生/ 式/ 外/ ,/ 也/ 存在/ 基于/ 短语/ 的/ 错误/ 恢复/ [/ 7/ ]/ 、/ 局部/ 错误/ 恢复/ [/ 10/ ]/ 、/ 全局/ 错误/ 恢复/ [/ 11/ ]/ 等/ 其它/ 更正/ 性/ 错误/ 恢复/ 方法/ ./ 其中/ ,/ 基于/ 短语/ 的/ 错误/ 恢复/ 方法/ 恢复能力/ 较强/ ,/ 但/ 处理/ 效率/ 较/ 低/ ,/ 有时/ 不得不/ 借助/ 其它/ 的/ 恢复/ 策略/ (/ 如后/ 文/ 提及/ 的/ 恐慌/ 式/ 错误/ 恢复/ )/ 执行/ 二次/ 恢复/ ./ 局部/ 错误/ 恢复/ 效率/ 较/ 高/ ,/ 但/ 有时/ 也/ 不得不/ 二次/ 恢复/ ./ 全局/ 错误/ 恢复/ 理论/ 上/ 效果/ 最好/ ,/ 但/ 时空/ 复杂度/ 太高/ ./ 非/ 更正/ 性/ 错误/ 恢复/ 中/ 最/ 常用/ 的/ 是/ “/ 恐慌/ 式/ 错误/ 恢复/ ”/ (/ panicmoderecovery/ )/ [/ 8/ ]/ ./ 其/ 恢复/ 策略/ 是/ ,/ 从/ 错误/ 符号/ 开始/ ,/ 跳过/ 若干个/ 输入/ 符号/ ,/ 直至/ 遇到/ 某个/ 可/ 接受/ 的/ 同步/ 符号/ ./ 该/ 方法/ 的/ 优点/ 是/ 实现/ 容易/ ;/ 缺点/ 是/ 恢复/ 效果/ 依赖于/ 同步/ 符号/ 定义/ 的/ 优劣/ ,/ 且/ 跳/ 过/ 的/ 部分/ 未/ 做/ 检查/ ,/ 可能/ 包含/ 语法错误/ ./ Richter/ [/ 12/ ]/ 提出/ 了/ 另外/ 一种/ 非/ 更正/ 性/ 的/ 错误/ 恢复/ 方法/ (/ 后文/ 简称/ Richter/ 算法/ )/ ./ 其/ 算法/ 依据/ 是/ ,/ 错误/ 符号/ 后/ 的/ 字符串/ 可能/ 是/ 文法/ 中/ 某个/ 句子/ 的/ 子串/ 或/ 后缀/ ./ 在/ 介绍/ 该/ 算法/ 前/ ,/ 先/ 介绍/ 几个/ 相关/ 概念/ ./ 定义/ 1/ ./ 后缀/ 语言/ 、/ 后缀/ 文法/ 、/ 后缀/ 分析器/ ./ 令/ 上下文/ 无关/ 语言/ L/ 对应/ 的/ 文法/ 为/ G/ ,/ 文法/ G/ 对应/ 的/ 分析器/ 为/ M/ ./ 如果/ 语言/ L/ 的/ 所有/ 句子/ 由且/ 仅/ 由/ 语言/ L/ 句子/ 的/ 后缀/ 组成/ ,/ 则/ 称/ L/ 为/ L/ 的/ 后缀/ 语言/ ;/ L/ 对应/ 的/ 文法/ G/ 称为/ G/ 的/ 后缀/ 文法/ ;/ 文法/ G/ 对应/ 的/ 分析器/ M/ 称为/ M/ 的/ 后缀/ 分析器/ [/ 12/ ]/ ./ 基于/ 定义/ 1/ 的/ 表述/ ,/ 标准/ Richter/ 算法/ 的/ 分析/ 过程/ 如下/ :/ 启动/ 分析器/ M/ 分析/ 输入/ 串/ ,/ 遇到/ 错误/ 符号/ 时/ ,/ M/ 报告/ 错误/ ,/ 并/ 启动/ 后缀/ 分析器/ M/ 继续/ 分析/ ./ 若/ M/ 又/ 遇到/ 语法错误/ ,/ 则/ M/ 报告/ 错误/ ,/ 同时/ 将/ M/ 重置/ 到/ 初始状态/ ,/ 继续/ 对/ 剩余/ 串/ 执行/ 分析/ ./ Richter/ 算法/ 具有/ 不/ 重复/ 报告/ 错误/ 、/ 不/ 报告/ 虚假/ 错误/ 、/ 能/ 一次/ 侦测/ 多个/ 错误/ 的/ 优点/ ,/ 但/ 也/ 存在/ 明显/ 缺点/ :/ (/ 1/ )/ 后缀/ 文法/ 可能/ 引入/ 分析/ 冲突/ ./ 即使/ 原始/ 文法/ 是/ 确定性/ 文法/ ,/ 其/ 后缀/ 文法/ 往往/ 也/ 不是/ 确定性/ 文法/ ./ 采用/ 传统/ 的/ LL/ (/ k/ )/ 、/ LR/ (/ k/ )/ 方法/ 难以/ 分析/ 该类/ 后缀/ 文法/ ;/ (/ 2/ )/ 标准/ Richter/ 算法/ 在/ 后缀/ 文法/ 中/ 增加/ 了/ 大量/ 产生/ 式/ ,/ 分析/ 性能/ 低/ ./ Page3/ 也/ 存在/ 其它/ LR/ 错误/ 恢复/ 方法/ [/ 13/ -/ 15/ ]/ ./ 这些/ 方法/ 针对/ 特定/ 对象/ 有/ 比较/ 好/ 的/ 恢复/ 效果/ ,/ 但/ 依赖于/ 分析/ 对象/ 特点/ 和/ 设计者/ 的/ 个人/ 技巧/ ,/ 不/ 适合/ 作为/ 通用/ 分析器/ 生成器/ 的/ 自动/ 错误处理/ 和/ 恢复/ 方法/ ./ 3GLR/ 错误/ 侦测/ GLR/ 分析/ 栈/ 相当于/ 多个/ 并行/ 的/ LR/ 分析/ 栈/ ,/ 只要/ 存在/ 语法错误/ ,/ 各个/ 分析/ 栈/ 总能/ 侦测/ 到/ ,/ 满足/ “/ 正确/ 侦测/ 错误/ ”/ 这一/ 指标/ ./ GLR/ 错误/ 侦测/ 的/ 效果/ 与/ 底层/ 采用/ 的/ 分析/ 表/ 密切相关/ ./ 首先/ 考察/ 采用/ LR/ (/ 1/ )/ 分析/ 表/ 的/ 情形/ ./ LR/ (/ 1/ )/ 具有/ 立即/ 错误/ 侦测/ 性质/ ,/ 从/ 单一/ 分析/ 栈上/ 看/ ,/ 采用/ LR/ (/ 1/ )/ 分析/ 表/ 的/ GLR/ 分析器/ 也/ 具有/ 立即/ 错误/ 侦测/ 性质/ ./ 但/ 与/ LR/ 分析器/ 不同/ ,/ GLR/ 并行/ 试探/ 所有/ 可能/ 的/ 分析/ 分支/ ,/ 因此/ ,/ 当/ 一条/ LR/ 分析/ 栈/ 侦测/ 到/ 错误/ 时/ ,/ 还/ 不能/ 立即/ 认定/ 为/ 语法错误/ ,/ 还/ 需要/ 试探/ 其它/ 分析/ 分支/ ./ 只有/ 所有/ 的/ LR/ 分析/ 栈/ 都/ 遇到/ 语法错误/ ,/ 才能/ 真正/ 报告/ 错误/ ./ 因此/ ,/ 即使/ 采用/ LR/ (/ 1/ )/ 分析/ 表/ ,/ GLR/ 也/ 不/ 具备/ 立即/ 错误/ 侦测/ 性质/ ./ 对于/ 采用/ LALR/ (/ 1/ )/ 或/ SLR/ (/ 1/ )/ 分析/ 表/ 的/ GLR/ 分析器/ ,/ 由于/ 每条/ 分析/ 栈/ 本身/ 就/ 不/ 具备/ 立即/ 错误/ 侦测/ 性质/ ,/ GLR/ 分析器/ 也/ 不/ 具备/ 该/ 性质/ ./ 综上/ ,/ 不管/ 采用/ 哪种/ LR/ 分析/ 表/ ,/ GLR/ 方法/ 都/ 不/ 满足/ 立即/ 错误/ 侦测/ 性质/ ,/ 但/ 满足/ 正确/ 前缀/ 性质/ ./ 4GLR/ 错误/ 恢复/ 本文/ 认为/ ,/ Richter/ 算法/ 适合/ 作为/ GLR/ 分析器/ 的/ 错误处理/ 和/ 恢复/ 方法/ ./ 除/ 上文/ 提及/ 的/ 不/ 重复/ 报告/ 错误/ 、/ 不/ 报告/ 虚假/ 错误/ 、/ 能/ 一次/ 侦测/ 多个/ 错误/ 等/ 原因/ 外/ ,/ 选择/ 该/ 算法/ 还有/ 其它/ 几个/ 原因/ :/ (/ 1/ )/ 该/ 算法/ 具备/ 语言/ 无关/ 性/ ,/ 能/ 满足/ 通用/ GLR/ 错误/ 恢复/ 方法/ 的/ 语言/ 无关/ 性/ 要求/ ;/ (/ 2/ )/ 不/ 更改/ 输入/ 串/ 和/ 分析/ 栈/ ,/ 避免/ 了/ 修改/ GLR/ 图栈/ 带来/ 的/ 复杂性/ ;/ (/ 3/ )/ 无需/ 手工/ 修改/ 文法/ ,/ 对/ 开发者/ 的/ 个人/ 技巧/ 依赖/ 较/ 少/ ;/ (/ 4/ )/ GLR/ 算法/ 能/ 容忍/ 后缀/ 文法/ 的/ 二义性/ ,/ 可/ 弥补/ Richter/ 算法/ 应用/ 于/ 确定性/ 分析器/ 生成器/ 的/ 不足/ ;/ (/ 5/ )/ 后缀/ 文法/ 和/ 后缀/ 分析器/ 可/ 自动/ 构造/ ,/ 便于/ 实现/ 自动化/ 的/ 错误处理/ 和/ 恢复/ ./ 原始/ Richter/ 算法/ 没有/ 给出/ 子串/ 分析器/ 的/ 构造/ 算法/ ,/ 且/ 后缀/ 分析器/ 规模/ 过大/ ./ Rekers/ 给出/ 了/ 一个/ 实用/ 的/ 子串/ 分析器/ 构造/ 算法/ ,/ 优化/ 了/ 后缀/ 文法/ 构造/ ,/ 避免/ 了/ 文法/ 规模/ 过大/ 问题/ [/ 16/ ]/ ./ 本文/ 选择/ 以/ Richter/ 算法/ 和/ Rekers/ 的/ 子串/ 构造方法/ 为/ 基础/ ,/ 对/ 其/ 进行/ 优化/ 和/ 改进/ ,/ 使之能/ 应用/ 于/ GLR/ 的/ 错误处理/ 和/ 恢复/ ./ Richter/ 算法/ 和/ Rekers/ 算法/ 应用/ 于/ GLR/ 分析器/ 的/ 自动/ 错误处理/ 和/ 恢复/ 时/ ,/ 存在/ 4/ 个/ 方面/ 不足/ ,/ 下面/ 针对/ 这/ 4/ 个/ 方面/ 的/ 问题/ 给出/ 相应/ 的/ 解决方案/ ./ 1/ )/ 前面/ 的/ 语法错误/ 可能/ 掩盖/ 后续/ 的/ 语法错误/ ./ 不仅/ Rekers/ 算法/ 如此/ ,/ 所有/ 基于/ Richter/ 方法/ 的/ 子串/ 构造/ 算法/ 都/ 存在/ 该/ 问题/ ,/ 看/ 一个/ 具体/ 例子/ ./ 例/ 1/ ./ 多行/ 注释/ 是/ 常见/ 的/ 语法结构/ ,/ 通常/ 把/ 它/ 当作/ 无效/ 语法/ 成分/ ,/ 在/ 词法/ 分析阶段/ 滤除/ ./ 但/ 在/ 优质/ 打印/ (/ prettyprinter/ )/ 程序/ 中/ ,/ 多行/ 注释/ 却是/ 有效/ 语法/ 成分/ ./ 对于/ 图/ 1/ 所示/ 实例/ ,/ 若/ 遗漏/ 了/ “/ // / ”/ ,/ 后续/ 的/ 输入/ 串会/ 被/ 子串/ 分析器/ 正常/ 识别/ ,/ 直至/ 遇到/ “/ / // ”/ ./ 在/ 这种/ 情况/ 下/ ,/ 遗漏/ 了/ “/ // / ”/ 会/ 掩盖/ 后续/ 所有/ 错误/ ,/ 导致/ 错误/ 侦测/ 失效/ ./ 为/ 解决/ 错误/ 掩盖/ 问题/ ,/ 本文/ 引入/ 了/ 一个/ 特殊/ 属性/ “/ disable/ _/ substring/ ”/ ./ 在/ 文法/ 描述/ 时/ ,/ 可以/ 附着/ 在/ 产生/ 式/ 后/ ,/ 禁止/ 对/ 该/ 产生/ 式/ 进行/ 子串/ 匹配/ ./ 比如/ ,/ 对于/ 例/ 1/ ,/ 可/ 添加/ 图/ 2/ 所示/ 的/ disable/ _/ substring/ 属性/ 声明/ ,/ 以/ 解决/ 错误/ 掩盖/ 问题/ ./ 多行/ 注释/ →/ // / 不/ 含/ / // 的/ 任意/ 字符串/ / // {/ disable/ _/ substring/ }/ 2/ )/ 可能/ 导致/ 无限/ 死循环/ ./ 对于/ 形如/ A/ →/ α/ A/ β/ 的/ 产生/ 式/ (/ 其中/ ,/ α/ 、/ β/ 代表/ 任意/ 终结符/ 、/ 非/ 终结符/ 的/ 组合/ ,/ 但/ 不能/ 同时/ 为/ 空串/ ,/ 否则/ 该/ 规则/ 为/ 有害/ 规则/ [/ 8/ ]/ )/ ,/ 若/ 子串/ 分析器/ 只/ 识别/ 了/ 右侧/ 的/ 结构/ A/ ,/ 这种/ 情况/ 下/ 执行/ 归约/ 可能/ 使/ 算法/ 陷入/ 死循环/ ./ Rekers/ 算法/ 对/ 此类情况/ 没有/ 进行/ 判别/ ,/ 本文/ 对此/ 进行/ 了/ 修正/ ,/ 禁止/ 对/ 此类/ 表达式/ 归约/ ./ 3/ )/ 分析/ 效率/ 低/ ./ Rekers/ 算法/ 的/ 设计/ 目的/ 是/ 支持/ 语法/ 制导/ 编辑器/ 的/ 字符串/ 自动/ 补全/ ,/ 其/ 分析/ 的/ 输入/ 串/ 通常/ 很/ 短/ ,/ 性能/ 方面/ 能/ 满足/ 设计/ 用途/ ,/ 但/ 将/ 其/ 应用/ 到/ GLR/ 的/ 错误处理/ 和/ 恢复/ ,/ 却/ 存在/ 严重/ 的/ 性能/ 瓶颈/ ,/ 主要/ 表现/ 在/ 以下/ 几/ 方面/ :/ 从/ 错误/ 符号/ 开始/ 的/ 输入/ 串/ ,/ 可能/ 是/ 多个/ 句子/ 的/ 子串/ ,/ 算法/ 会/ 并行/ 试探/ 所有/ 可能/ 的/ 分支/ ;/ 分析/ 过程/ 中/ 遇到/ 冲突/ 将/ 导致/ 图栈/ 裂变/ ,/ 降低/ GLR/ 的/ 分析/ 速度/ ;/ 标准/ 的/ GLR/ 移进/ 和/ 归约/ 动作/ 执行/ 复杂/ ,/ 执行/ 性能/ 低/ ./ 严格/ 来讲/ ,/ 后/ 两项/ 不/ 属于/ Rekers/ 算法/ 的/ 固有/ 缺陷/ ,/ 而是/ GLR/ 方法/ 的/ 缺陷/ ./ 但/ 一个/ 实用/ 的/ 错误/ 恢复/ 方法/ ,/ 必须/ 能/ 同时/ 处理/ 合法/ 输入/ 串/ 和/ 非法/ 输入/ 串/ ,/ 二/ Page4/ 者/ 的/ 分析/ 性能/ 都/ 很/ 重要/ ./ 本文/ 从/ 以下/ 3/ 方面/ 对/ 上述/ 性能/ 瓶颈/ 进行/ 了/ 优化/ ./ (/ 1/ )/ 缩减/ 恢复/ 分支/ 数量/ 错误/ 符号/ 后/ 的/ 子串/ 可能/ 匹配/ 多个/ 恢复/ 分支/ ,/ 标准/ Richter/ 算法/ 会为/ 每个/ 分支/ 启动/ 一个/ 子串/ 分析器/ ./ 如果/ 分支/ 数很多/ ,/ 将/ 严重/ 影响/ 算法/ 性能/ ./ 为/ 解决/ 该/ 问题/ ,/ 本文/ 设计/ 了/ 交互式/ 的/ 分支/ 选择/ 算法/ ,/ 图/ 3/ 给出/ 了/ 算法/ 的/ 执行/ 流程/ ./ 分析器/ 开发者/ 可/ 根据/ 已/ 分析/ 的/ 前文/ ,/ 筛选/ 出/ 可行/ 的/ 恢复/ 分支/ ,/ 减少/ 并行执行/ 的/ 子串/ 分析器/ 数量/ ,/ 进而/ 提高/ 执行/ 速度/ ./ if/ (/ PARSING/ _/ ERRORorACTION/ [/ topstat/ ,/ lookahead/ ]/ >/ 1/ )/ {/ selected/ =/ UsrSolvingRoutine/ (/ )/ ;/ // / 回调/ 用户/ 的/ 错误处理/ 例程/ 或/ switch/ (/ selected/ )/ {/ caseRi/ :/ DoReduce/ (/ ruleRi/ )/ ;/ // / 按照/ 产生/ 式/ Ri/ 归约/ / // break/ ;/ caseSi/ :/ DoShift/ (/ statei/ )/ ;/ break/ ;/ default/ :/ DoAll/ (/ topstat/ ,/ lookahead/ )/ ;/ // / 执行/ 所有/ 可能/ 的/ 分析/ 动作/ / // }/ }/ (/ 2/ )/ 减少/ 图栈/ 裂变/ 分析/ 冲突/ 会/ 造成/ 图栈/ 裂变/ ,/ 导致/ GLR/ 执行/ 速度/ 变慢/ ./ 本文/ 采用/ 两种/ 手段/ 减少/ 图栈/ 裂变/ :/ 一是/ 采用/ 图/ 3/ 的/ 交互式/ 分支/ 选择/ 算法/ ,/ 对/ 多个/ 冲突/ 分支/ 进行/ 剪枝/ ;/ 二是/ 采用/ 更强/ 能力/ 的/ 分析/ 表/ ./ 显然/ ,/ 采用/ LALR/ (/ 1/ )/ 、/ LR/ (/ 1/ )/ 等/ 强/ 能力/ 分析/ 表比/ 采用/ LR/ (/ 0/ )/ 表/ 遇到/ 的/ 冲突/ 少/ ./ 此外/ ,/ 增大/ 向前/ 看/ 符号/ k/ ,/ 也/ 可以/ 减少/ 冲突/ ./ 理论/ 上/ 讲/ ,/ GLR/ 分析器/ 可以/ 使用/ 任何/ 类型/ 的/ LR/ 分析/ 表/ ./ 采用/ 哪/ 种/ 类型/ 的/ 分析/ 表/ ,/ 采用/ 多大/ 的/ 向前/ 看/ 符号/ 长度/ ,/ 分析/ 效率/ 最高/ 呢/ ?/ 对于/ 第/ 1/ 个/ 问题/ “/ 采用/ 什么/ 类型/ 的/ 分析/ 表/ ”/ ,/ 文献/ 中/ 提及/ 的/ GLR/ 算法/ 多/ 采用/ LR/ (/ 0/ )/ 表/ ,/ 主要/ 用于/ 自然语言/ 分析/ ./ 自然语言/ 文法/ 规则/ 众多/ ,/ 并且/ 高度/ 歧义/ ,/ 这/ 两个/ 特征/ 决定/ 了/ LR/ (/ 0/ )/ 表更/ 适合/ 作为/ 其/ GLR/ 分析器/ 的/ 分析/ 表/ ./ 因为/ LR/ (/ 0/ )/ 表在/ LR/ 类/ 分析/ 表中/ 状态/ 数/ 最少/ ,/ 构造/ 和/ 查询/ 效率/ 最高/ ./ 自然语言/ 是/ 典型/ 的/ 高度/ 二义性/ 文法/ ,/ 大多数/ 冲突/ 为/ 全局/ 二义性/ 冲突/ ,/ 不能/ 通过/ 展望/ 更/ 多/ 向前/ 看/ 符号/ 予以/ 解决/ ./ 应用/ 于/ 自然语言/ 处理/ 的/ GLR/ 分析器/ ,/ 采用/ LALR/ (/ 1/ )/ 等/ 强/ 能力/ 分析/ 表比/ 采用/ LR/ (/ 0/ )/ 表/ 分析/ 效率/ 并/ 无/ 明显/ 提升/ [/ 17/ ]/ ./ 程序设计/ 语言/ 文法/ 与/ 自然语言/ 文法/ 不同/ ./ 首先/ ,/ 文法/ 规模/ 小/ ,/ 远/ 低于/ 自然语言/ 文法/ [/ 18/ ]/ ,/ 分析/ 表/ 构造/ 和/ 查询/ 效率/ 较/ 高/ ./ 其次/ ,/ 文法/ 歧义/ 较/ 少/ ,/ 且/ 大部分/ 属于/ 局部/ 二义性/ ,/ 一般/ 可/ 通过/ 向前/ 展望/ 一个/ 或/ 多个/ 符号/ 予以/ 解决/ ./ 对于/ 程序设计/ 语言/ 文法/ ,/ 采用/ LALR/ (/ 1/ )/ 等/ 强/ 能力/ 分析/ 算法/ ,/ 一般/ 可/ 明显增强/ 算法/ 的/ 识别/ 能力/ ./ 对于/ 第/ 2/ 个/ 问题/ “/ 采用/ 多大/ 的/ 向前/ 看/ 符号/ 长度/ ”/ ,/ Parr/ [/ 19/ ]/ 对/ 22/ 种/ 程序设计/ 语言/ 分析器/ 的/ 向前/ 看/ 符号/ 长度/ 进行/ 了/ 研究/ ,/ 约/ 有/ 98.8/ %/ 的/ 分析/ 决策/ 只/ 需/ 展望/ 一个/ 向前/ 看/ 符号/ (/ k/ =/ 1/ )/ ./ 如果/ k/ =/ n/ (/ n/ >/ 1/ )/ 不能/ 确定/ 分析/ 决策/ ,/ 那么/ k/ >/ n/ 通常/ 也/ 不能/ 确定/ [/ 17/ ]/ ,/ 即/ k/ 值/ 的/ 增大/ 并/ 不能/ 显著/ 增强/ 分析器/ 的/ 识别/ 能力/ ./ 这/ 说明/ ,/ 对于/ 程序设计/ 语言/ 的/ 语法分析/ ,/ k/ =/ 1/ 是/ 最/ 实用/ 的/ 向前/ 看/ 长度/ ./ 综上/ ,/ 应用/ 于/ 程序设计/ 语言/ 分析/ 的/ GLR/ 分析器/ ,/ 采用/ SLR/ (/ 1/ )/ 、/ LALR/ (/ 1/ )/ 、/ LR/ (/ 1/ )/ 等/ 强/ 能力/ 分析/ 表比/ 采用/ LR/ (/ 0/ )/ 分析/ 表/ 理应/ 获得/ 更好/ 的/ 分析/ 性能/ ./ SLR/ (/ 1/ )/ 、/ LALR/ (/ 1/ )/ 、/ LR/ (/ 1/ )/ 3/ 种/ 分析/ 表/ 哪种/ 更/ 合适/ 呢/ ?/ 进行/ 一下/ 定性分析/ ./ SLR/ (/ 1/ )/ 通过/ 计算/ 非/ 终结符/ 的/ Follow/ 集/ ,/ 可以/ 处理/ 部分/ LR/ (/ 0/ )/ 无法/ 分析/ 的/ 文法/ ,/ 分析/ 能力/ 略/ 强于/ LR/ (/ 0/ )/ ./ LR/ (/ 1/ )/ 是/ 3/ 种/ 分析/ 表中/ 能力/ 最强/ 的/ ,/ 但/ 构造/ 分析/ 表/ 的/ 时空/ 代价/ 很/ 高/ ./ LALR/ (/ 1/ )/ 分析/ 能力/ 介于/ SLR/ (/ 1/ )/ 和/ LR/ (/ 1/ )/ 之间/ ,/ 其/ 分析/ 表/ 规模/ 和/ LR/ (/ 0/ )/ 相同/ ,/ 远/ 小于/ LR/ (/ 1/ )/ 的/ 分析/ 表/ 规模/ ,/ 但/ 和/ LR/ (/ 1/ )/ 分析/ 能力/ 接近/ ./ 本文/ 选择/ LALR/ (/ 1/ )/ 作为/ GLR/ 分析器/ 的/ 分析/ 表/ ,/ 尽管/ 其/ 存储/ 和/ 查询/ 效率/ 低于/ LR/ (/ 0/ )/ ,/ 但/ 程序设计/ 语言/ 的/ 文法/ 冲突/ 较/ 少/ ,/ 且/ 绝大多数/ 为/ 局部/ 二义性/ 冲突/ ,/ 可以/ 通过/ 向前/ 展望/ 一个/ 或/ 多个/ 符号/ 予以/ 解决/ ,/ 采用/ LALR/ (/ 1/ )/ 分析/ 表可/ 有效/ 减少/ GLR/ 的/ 图栈/ 裂变/ ,/ 理应/ 使/ 算法/ 获得/ 更好/ 的/ 总体/ 性能/ ./ 对于/ LALR/ (/ 1/ )/ 分析/ 表/ 的/ 自动/ 构造/ ,/ 教科书/ [/ 7/ -/ 8/ ]/ 介绍/ 的/ 方法/ 是/ 合并/ LR/ (/ 1/ )/ 自动机/ 中/ 的/ 同心/ 项目/ 集/ ./ 这种/ 方法/ 易于/ 理解/ ,/ 但/ 效率/ 很/ 低/ ./ 在实践中/ ,/ 人们/ 之所以/ 使用/ LALR/ (/ 1/ )/ 分析/ 表而/ 不用/ LR/ (/ 1/ )/ 分析/ 表/ ,/ 主要/ 原因/ 就是/ 构造/ LR/ (/ 1/ )/ 分析/ 表/ 的/ 时空/ 代价/ 较大/ ./ 显然/ ,/ 合并/ 同心/ 项目/ 集/ 方法/ 存在/ 同样/ 问题/ ./ YACC/ [/ 20/ ]/ 、/ Bison/ ①/ 等/ LALR/ (/ 1/ )/ 分析器/ 生成/ 系统/ 采用/ 的/ 是/ 另外/ 一种/ 方法/ ./ 该/ 方法/ 包含/ 两个/ 步骤/ :/ 首先/ ,/ 根据/ 文法/ 构造/ 其/ LR/ (/ 0/ )/ 自动机/ ;/ 其次/ ,/ 以/ LR/ (/ 0/ )/ 自动机/ 和/ 文法/ 为/ 输入/ ,/ 计算/ LR/ (/ 0/ )/ 项目/ 的/ LALR/ (/ 1/ )/ 向前/ 看/ 符号/ 集/ ./ 本文/ 研究/ 小组/ 采用/ 了/ 类似/ 的/ 方法/ ,/ 自行设计/ 实现/ 了/ LALR/ (/ 1/ )/ 分析/ 表/ 的/ 快速/ 生成/ 算法/ [/ 21/ ]/ ./ 采用/ LALR/ (/ 1/ )/ 分析/ 表/ 可以/ 自动/ 消除/ 程序设计/ ①/ FreeSoftwareFoundation/ ./ Bison/ -/ GNUparsergeneratorPage5/ 语言/ 文法/ 中/ 的/ 常见/ 二义性/ 冲突/ ./ 对于/ 其它/ 的/ 分析/ 冲突/ ,/ GLR/ 算法/ 将/ 模拟/ 多个/ LR/ 分析器/ ,/ 沿着/ 所有/ 可能/ 的/ 冲突/ 分支/ 执行/ 分析/ ,/ 最终/ 可能/ 出现/ 两种/ 不同/ 性质/ 的/ 冲突/ :/ (/ a/ )/ 局部/ 二义性/ 冲突/ ./ 这种/ 冲突/ 是/ 由于/ 向前/ 看/ 符号/ 长度/ 不够/ 引起/ 的/ ,/ 会/ 导致/ 图栈/ 的/ 暂时/ 分裂/ ,/ 读入/ 足够/ 多/ 的/ 符号/ 后/ ,/ GLR/ 会/ 自动/ 选择/ 正确/ 分支/ ,/ 废弃/ 错误/ 分支/ ;/ (/ b/ )/ 全局/ 二义性/ 冲突/ ./ 这种/ 冲突/ 是/ 由于/ 文法/ 的/ 全局/ 二义性/ 引起/ 的/ ,/ 会/ 导致/ 图栈/ 的/ 永久/ 分裂/ ,/ 用户/ 需要/ 进一步/ 对/ 其/ 剪枝/ 消歧/ ./ (/ 3/ )/ 优化/ 移进/ 和/ 归约/ 执行/ 动作/ GLR/ 分析/ 的/ 实质/ 是/ ,/ 模拟/ 多个/ 并行/ 的/ LR/ 分析/ 栈/ ./ 即使/ 分析/ 栈/ 并未/ 裂变/ ,/ 是/ 简单/ 的/ 线性/ 栈/ ,/ GLR/ 仍要/ 执行/ 复杂/ 的/ 移进/ 、/ 归约/ 检查/ ./ 这是/ 造成/ 其/ 性能/ 瓶颈/ 的/ 重要/ 原因/ ./ 本文/ 根据/ 图栈/ 的/ 结构特征/ 对/ 移进/ 和/ 归约/ 这/ 两种/ 主要/ 的/ 分析/ 动作/ 进行/ 了/ 优化/ ,/ 让/ GLR/ 分析器/ 在/ 不同/ 条件/ 下/ 执行/ 不同/ 类型/ 的/ 分析/ 动作/ ./ 动/ 的/ 栈顶/ 状态/ ;/ (/ a/ )/ 图栈/ 是/ 一条/ 线性/ 栈/ ,/ 尚未/ 分裂/ ,/ 只有/ 一个/ 活/ (/ b/ )/ 对于/ 某个/ 活动/ 栈顶/ 状态/ n/ 和/ 输入/ 符号/ t/ ,/ 只/ 存在/ 一个/ 归约/ 动作/ :/ ACTION/ [/ n/ ,/ t/ ]/ =/ RA/ →/ α/ ,/ 其中/ ,/ 产生/ 式/ A/ →/ α/ 的/ 右部/ 符号/ 长度/ |/ α/ |/ / j/ -/ i/ ,/ j/ 是/ 栈顶/ 状态/ n/ 所在/ 结点/ 的/ 同步/ 位置/ ,/ i/ 是/ 距离/ 该/ 结点/ 最近/ 的/ 分支/ 结点/ 的/ 同步/ 位置/ ./ 本文/ 将/ GLR/ 算法/ 在/ 每/ 一个/ 分析/ 步/ 累计/ 读入/ 的/ 符号/ 数/ 称为/ 同步/ 位置/ ,/ 并/ 在/ 算法/ 中/ 增加/ 了/ 同步/ 位置/ 的/ 计数器/ ./ 同步/ 位置/ 的/ 概念/ 可用/ 图/ 4/ 说明/ ,/ 各个/ 结点/ 的/ 同步/ 位置/ 已/ 在/ 顶部/ 用/ 虚线/ 标出/ ./ 图栈/ 的/ 分支/ 结点/ 是/ 指入度/ 或/ 出度/ 大于/ 1/ 的/ 状态/ 结点/ ./ 比如/ ,/ 图/ 4/ 中/ 结点/ 0/ 、/ 4/ 、/ 5/ 均/ 为/ 分支/ 结点/ ./ 针对/ 移进/ 动作/ 的/ 操作/ 优化/ GLR/ 移进/ 动作/ 的/ 主要/ 开销/ 是/ ,/ 每次/ 移进/ 后/ 均/ 要/ 比较/ 新增/ 状态/ 是否/ 存在/ 于/ 活动/ 栈顶/ 状态/ 集中/ ,/ 并/ 检查/ 是否/ 需要/ 合并/ 分析/ 栈/ ./ 在/ 很多/ 情况/ 下/ ,/ GLR/ 图栈/ 并未/ 分裂/ ,/ 是/ 一个/ 简单/ 的/ 线性/ 栈/ ,/ 此时/ 只/ 需/ 直接/ 移进/ ,/ 无需/ 进行/ 上述/ 比较/ 和/ 检查/ ./ 根据/ 图栈/ 是否/ 已/ 分裂/ ,/ 本文/ 把/ 移进/ 动作/ 分为/ 两类/ :/ (/ a/ )/ 直接/ 移进/ ./ 执行/ 直接/ 移进/ 动作/ ,/ 此时/ 不/ 进行/ (/ b/ )/ 标准/ 移进/ ./ 执行/ 标准/ GLR/ 移进/ 动作/ ,/ 此时/ 需要/ 跟/ 活动/ 栈顶/ 状态/ 集/ 比较/ ,/ 若栈/ 顶/ 状态/ 有/ 重复/ ,/ 执行/ 分析/ 栈/ 合并/ ./ 活动/ 栈顶/ 状态/ 集/ 比较/ 和/ 分支/ 合并/ 检查/ ;/ 针对/ 归约/ 动作/ 的/ 操作/ 优化/ 程序设计/ 语言/ 语法/ 冲突/ 较/ 少/ ,/ 图栈/ 在/ 大多数/ 情况/ 下/ 为/ 线性/ 栈/ 或/ 近/ 线性/ 栈/ ./ 因此/ ,/ 在/ 算法/ 运行/ 的/ 绝大部分/ 时间/ ,/ 图栈/ 的/ 结构特征/ 满足/ 下列/ 两个/ 条件/ 中/ 的/ 一个/ 或/ 两个/ :/ 在/ 一个/ 活动/ 栈顶/ 状态/ ,/ 按/ 某/ 一/ 产生/ 式/ A/ →/ α/ 的/ 归约/ 动作/ 可/ 分为/ 3/ 类/ :/ (/ i/ )/ 直接/ 归约/ ./ 若/ 图栈/ 的/ 结构特征/ 满足/ 上述/ 条件/ (/ a/ )/ ,/ 则/ 执行/ 直接/ 归约/ 动作/ ,/ 此时/ ,/ 只/ 需/ 从/ 栈顶/ 弹出/ |/ α/ |/ 个/ 状态/ ,/ 然后/ 压入/ 新栈/ 顶/ ,/ 无需/ 在/ 活动/ 栈顶/ 结点/ 集中/ 搜索/ 和/ 判断/ 新增/ 状态/ 是否/ 存在/ ,/ 无需/ 搜索/ 和/ 维护/ 归约/ 路径/ ./ (/ ii/ )/ 简单/ 归约/ ./ 若/ 图栈/ 的/ 结构特征/ 不/ 满足/ 上述/ 条件/ (/ a/ )/ 而/ 满足条件/ (/ b/ )/ ,/ 则/ 执行/ 简单/ 归约/ ,/ 执行/ 流程/ 跟/ 直接/ 归约/ 相同/ ./ (/ iii/ )/ 标准/ 归约/ ./ 若/ 图栈/ 的/ 结构特征/ 既/ 不/ 满足条件/ (/ a/ )/ ,/ 也/ 不/ 满足/ (/ b/ )/ ,/ 则/ 执行/ 标准/ GLR/ 归约/ ./ 采用/ 上述/ 优化/ 策略/ 后/ ,/ 分析/ 程序设计/ 语言/ 语法/ 时/ ,/ 大部分/ 情况/ 下/ 分析/ 栈/ 处于/ 线性/ 结构/ ,/ GLR/ 主要/ 执行/ 直接/ 移进/ 和/ 直接/ 归约/ 两种/ 动作/ ./ 即使/ 分析/ 过程/ 中/ 遇到/ 少量/ 冲突/ ,/ 图栈/ 的/ 结构特征/ 在/ 大部分/ 时间/ 内/ 也/ 满足条件/ (/ a/ )/ 或/ 条件/ (/ b/ )/ ,/ 算法/ 执行/ 的/ 主要/ 动作/ 仍然/ 是/ 时空/ 开销/ 较/ 小/ 的/ 直接/ 移进/ 、/ 直接/ 归约/ 或/ 简单/ 归约/ 动作/ ./ 4/ )/ 缺少/ 必要/ 的/ 错误处理/ 和/ 控制/ 机制/ ./ Rekers/ 算法/ 虽然/ 给出/ 了/ 子串/ 分析器/ 的/ 构造/ 算法/ ,/ 但/ 设计/ 意图/ 不是/ 用于/ 分析器/ 的/ 错误处理/ ,/ 缺少/ 必要/ 的/ 运行/ 时/ 控制/ 机制/ ./ 因此/ ,/ 需要/ 对/ 其/ 进行/ 调整/ ,/ 使/ 其/ 支持/ GLR/ 分析器/ 的/ 自动/ 错误处理/ 和/ 恢复/ ./ 算法/ 1/ 和/ 算法/ 2/ 给出/ 了/ 本文/ 设计/ 的/ 错误处理/ 和/ 恢复/ 算法/ 伪/ 代码/ ./ 算法/ 1/ 中/ 的/ 步/ 1/ 和/ 2/ 直观/ 易懂/ ,/ 不再/ 赘述/ ;/ 步/ 3/ 可/ 采用/ 算法/ 2/ 执行/ 分析/ ./ 算法/ 1/ ./ GLR/ 错误处理/ 和/ 恢复/ 算法/ ./ 输入/ :/ 文法/ G/ =/ (/ N/ ,/ T/ ,/ P/ ,/ S/ )/ ,/ 输入/ 串/ 输出/ :/ 输入/ 串/ 的/ 分析/ 结果/ (/ 分析树/ 或/ 分析/ 森林/ )/ 步骤/ :/ 1/ ./ 为/ 文法/ G/ 生成/ LALR/ (/ 1/ )/ 分析/ 表/ M/ 、/ GLR/ 分析器/ 和/ 子串/ 分析器/ ;/ Page62/ ./ 利用/ GLR/ 分析器/ 分析/ 输入/ 串/ ./ 若/ 无/ 语法错误/ ,/ 分析/ 结束/ ;/ 若有/ 语法错误/ ,/ 启动/ 子串/ 分析器/ 对/ 剩余/ 输入/ 串/ serr/ 执行/ 分析/ ./ 若/ 定义/ 了/ 交互式/ 错误/ 恢复/ 例程/ ,/ 利用/ 该/ 例程/ 对/ 可用/ 恢复/ 分支/ 剪枝/ ;/ 3/ ./ 利用/ 算法/ 2/ 对/ 剩余/ 输入/ 串/ serr/ 执行/ 分析/ ./ 算法/ 2/ ./ GLR/ 子串/ 分析/ 算法/ ./ 输入/ :/ 文法/ G/ =/ (/ N/ ,/ T/ ,/ P/ ,/ S/ )/ ,/ 文法/ G/ 的/ LALR/ (/ 1/ )/ 分析/ 输出/ :/ 输入/ 串/ serr/ 的/ 分析/ 结果/ (/ 分析树/ 或/ 分析/ 森林/ )/ 1/ ./ voidSubstringRecognize/ (/ )/ 2/ ./ {/ 3/ ./ IntegerShiftCount/ =/ 0/ // // 移入/ 符号/ 数目/ 置/ 04/ ./ TokencurrentToken/ =/ serr/ 的/ 第一个/ 符号/ 5.6/ ./ // // 查询/ 分析/ 表/ M/ 中/ 可以/ 移入/ 当前/ 符号/ 的/ 所有/ 状态/ 7/ ./ ArrayInitialShiftStates/ =/ LookupShiftState/ (/ currentToken/ )/ 8/ ./ while/ (/ currentToken/ !/ =/ EOSand/ // // 尚未/ 达到/ 输入/ 串/ 结尾/ 9/ ./ InitialShiftStates/ =/ =/ / )/ // // 任何/ 一个/ 状态/ 都/ 不能/ 10/ ./ {/ 11/ ./ // // 创建/ 新/ 的/ 分析/ 栈/ ,/ 栈顶/ 标记/ 为/ 错误/ 状态/ 结点/ 12/ ./ StackNodenewNode/ =/ 13/ ./ 从/ 新/ 分析/ 栈/ newNode/ 栈顶/ 到/ 原/ 分析/ 栈/ target/ 添加/ 一条/ 14/ ./ 当前/ 的/ 错误/ 符号/ 作为/ 有/ 向/ 边/ 的/ 语义/ 值/ 15/ ./ ShiftCount/ ++/ // // 移入/ 符号/ 数目/ 加/ 116/ ./ currentToken/ =/ serr/ 的/ 下/ 一个/ 符号/ 17/ ./ target/ =/ newNode/ // // 保存/ 当前/ 的/ 分析/ 栈/ 18/ ./ // // 重新/ 查询/ 分析/ 表中/ 可以/ 移入/ 当前/ 符号/ 的/ 所有/ 状态/ 19/ ./ InitialShiftStates/ =/ LookupShiftState/ (/ currentToken/ )/ 20/ ./ }/ 21/ ./ // // 对/ 所有/ 的/ 错误/ 符号执行/ 归约/ 22/ ./ ReduceNotParsed/ (/ target/ ,/ ShiftCount/ )/ 23.24/ ./ // // 若/ 输入/ 串中/ 的/ 每个/ 符号/ 都/ 是/ 错误/ 符号/ ,/ 或/ M/ 中/ 不/ 存在/ 25/ ./ // // 移入/ 输入/ 串中/ 的/ 下/ 一个/ 符号/ ,/ 直接/ 返回/ 26/ ./ if/ (/ currentToken/ =/ =/ EOSorInitialShiftStates/ =/ =/ / )/ 27/ ./ return28/ ./ 29/ ./ // // 若/ 找到/ 了/ 可以/ 移入/ 当前/ 符号/ 的/ 一组/ 状态/ ,/ 30/ ./ // // 取出/ 其中/ 的/ 每个/ 状态/ ,/ 令该/ 状态/ 为/ m31/ ./ foreachstateminInitialShiftStates32/ ./ {/ 33/ ./ 创建/ 一条/ 独立/ 的/ 分析/ 栈/ L/ ,/ m/ 为/ 栈底/ ,/ 标记/ m/ 为/ L/ 的/ 初/ 34/ ./ 利用/ L/ 对/ 剩余/ 输入/ 串/ (/ 即/ currentToken/ 以后/ 的/ 输入/ 串/ )/ 35/ ./ }/ 36/ ./ }/ 37.38/ ./ ArrayLookupShiftState/ (/ Tokent/ )/ 39/ ./ {/ 40/ ./ 查找/ 分析/ 表/ M/ 中/ 的/ 所有/ 状态/ ,/ 找出/ 可以/ 移入/ 符号/ t/ 的/ 41/ ./ returnS42/ ./ }/ 算法/ 2/ 中/ ,/ 行首/ 数字/ 为/ 语句/ 行/ ,/ “/ // // ”/ 开头/ 的/ 为/ 程序/ 注释/ ,/ 其它/ 自然语言/ 或/ 伪/ 代码/ 均/ 为/ 有效/ 代码/ ./ 算法/ 2/ 的/ 执行/ 流程/ 如下/ :/ 首先/ ,/ 查询/ 分析/ 表/ M/ ,/ 找到/ 可/ 移入/ 当前/ 符号/ 的/ 所有/ 状态/ (/ 第/ 7/ 行/ )/ ./ 如果/ 所有/ 状态/ 都/ 不能/ 移入/ 当前/ 符号/ ,/ 说明/ 该/ 符号/ 为/ 错误/ 符号/ ,/ 跳到/ 下/ 一个/ 输入/ 符号/ 继续/ 检测/ ./ 这样/ ,/ 可以/ 找出/ 所有/ 连续/ 的/ 错误/ 符号/ (/ 第/ 8/ ~/ 20/ 行/ )/ ./ 之后/ ,/ 执行/ 归约/ 把/ 这些/ 错误/ 符号/ 挂/ 接到/ 最终/ 的/ 分析树/ (/ 分析/ 森林/ )/ 中/ (/ 第/ 22/ 行/ )/ ./ 经上述/ 分析/ 后/ ,/ 如果/ 已/ 到达/ 输入/ 串/ 结尾/ 或者/ 未找到/ 任何/ 状态/ 可/ 移入/ 当前/ 符号/ ,/ 则/ 直接/ 返回/ (/ 第/ 26/ ~/ 27/ 行/ )/ ;/ 否则/ ,/ 为/ 每个/ 状态/ 创建/ 一条/ 分析/ 栈/ ,/ 对/ 剩余/ 的/ 输入/ 串/ 进行/ 分析/ (/ 第/ 31/ ~/ 35/ 行/ )/ ./ 除/ 33/ ~/ 34/ 行/ 语句/ 外/ ,/ 算法/ 2/ 的/ 其它/ 语句/ 均/ 直观/ 易懂/ ./ 下面/ 介绍/ 一下/ 33/ ~/ 34/ 行/ 代码/ 的/ 处理/ 逻辑/ ./ 为/ 便于/ 理解/ ,/ 假定/ 执行/ 到/ 33/ 行时/ 剩余/ 的/ 未/ 分析/ 串为/ t1t2/ …/ tn/ -/ 1tn/ ,/ 则/ 当前/ 符号/ 为/ t1/ ./ 若有/ 多个/ 可/ 移入/ t1/ 的/ 状态/ 或/ 遇到/ 了/ 分析/ 冲突/ ,/ GLR/ 会/ 创建/ 多条/ 分析/ 栈/ 并行处理/ ./ 为/ 讨论/ 简单/ ,/ 对/ 其中/ 的/ 一条/ 进行/ 考察/ ,/ 令该/ 分析/ 栈为/ L1/ ,/ 栈顶/ 状态/ 为/ m/ ./ 初始/ 时/ ,/ L1/ 移入/ t1/ ,/ 然后/ 对/ 输入/ 串/ t2/ …/ tn/ -/ 1tn/ 执行/ 分析/ ./ 在/ 分析/ 过程/ 的/ 某/ 一/ 时刻/ ,/ 面临/ 输入/ 符号/ ti/ (/ 2/ / i/ / n/ -/ 1/ )/ 时/ ,/ L1/ 有/ 如下/ 可能/ 的/ 分析/ 动作/ :/ (/ 1/ )/ shiftS/ ./ 移入/ ti/ ,/ 将/ 状态/ S/ 压入/ 分析/ 栈/ L1/ ,/ 准备/ 处理/ 下/ 一个/ 输入/ 符/ ti/ +/ 1/ ;/ (/ 2/ )/ error/ ./ 从/ 活动/ 栈顶/ 状态/ 中/ 删除/ 分析/ 栈/ L1/ 的/ 栈顶/ ,/ 废弃/ 分析/ 栈/ L1/ ;/ (/ 3/ )/ reduce/ :/ A/ →/ α/ β/ ,/ 其中/ α/ 、/ β/ 为/ 任意/ 终结符/ 或非/ 终结符/ 的/ 组合/ ./ 根据/ 分析/ 栈/ 长度/ |/ L1/ |/ 和/ 产生/ 式/ 右部/ 符号串/ |/ α/ β/ |/ 长度/ 关系/ 的/ 不同/ ,/ 有/ 3/ 种/ 情况/ :/ (/ 3.1/ )/ |/ L1/ |/ >/ |/ α/ β/ |/ ./ 这/ 说明/ 产生/ 式/ A/ →/ α/ β/ 右部/ 的/ 所有/ 结构/ 完全/ 在/ 分析/ 栈/ L1/ 中/ ,/ 且/ L1/ 中/ 某个/ 状态/ n/ 存在/ 针对/ A/ 的/ 转移/ (/ GOTO/ 关系/ )/ 状态/ ngoto/ ./ 此时/ 按/ 标准/ 的/ GLR/ 算法/ 归约/ ,/ 从/ L1/ 弹出/ |/ α/ β/ |/ 个/ 元素/ 后/ ,/ 状态/ n/ 应/ 位于/ L1/ 栈顶/ ,/ 将/ ngoto/ 压入/ L1/ ,/ 分析器/ 准备/ 处理/ 符号/ ti/ ./ (/ 3.2/ )/ |/ L1/ |/ =/ |/ α/ β/ |/ ./ 这/ 说明/ 产生/ 式/ A/ →/ α/ β/ 右部/ 的/ 所有/ 结构/ 恰好/ 在/ L1/ 中/ ./ 执行/ 归约/ 动作/ ,/ 从/ L1/ 弹出/ |/ α/ β/ |/ 后/ 将/ 清空/ 分析/ 栈/ L1/ ,/ 此时/ 不/ 清楚/ 哪些/ 状态/ y/ 满足/ GOTO/ (/ y/ ,/ A/ )/ =/ z/ ,/ 需/ 查询/ 分析/ 表/ M/ ,/ 找出/ 所有/ 满足条件/ 的/ 状态/ y/ ./ Rekers/ 算法/ 在/ 该/ 步骤/ 会为/ 每个/ 可能/ 的/ 状态/ 都/ 创建/ 一条/ 新/ 分析/ 栈/ ,/ 这/ 可能/ 导致/ 分支/ 数量/ 急剧/ 增长/ ,/ 分析/ 性能/ 显著/ 下降/ ./ 本文/ 通过/ 两种/ 措施/ 修正/ :/ ①/ 若/ 产生/ 式/ 右部/ 包含/ A/ ,/ 检查/ α/ β/ 中除/ A/ 外/ 的/ 其它/ 结构/ 是否/ 能/ 推导/ 出/ 空串/ ./ 若能/ 推导/ 出/ 空串/ ,/ 执行/ 归/ 约会/ 令/ 算法/ 陷入/ 死循环/ ,/ 因此/ 应/ 停止/ 归约/ ./ 若/ 不/ 满足/ 上述/ 关系/ ,/ 则/ 执行/ 第/ ②/ 步骤/ ;/ ②/ 检查/ 是否/ 定义/ 了/ 错误处理/ 回调/ 函数/ ./ 若/ 存在/ ,/ 利用/ 剪裁/ 的/ 分支/ 继续/ 分析/ ./ 若/ 未定义/ 回调/ 函数/ ,/ 为/ 每/ Page7/ 个/ 状态/ y/ 新建/ 一条/ 分析/ 栈/ ,/ 栈底/ 为/ y/ ,/ 将/ y/ 标记/ 为/ 子串/ 分析器/ 的/ 初始状态/ ,/ 利用/ 算法/ 2/ 分析/ 后续/ 子串/ ti/ …/ tn/ -/ 1tn/ ./ (/ 3.3/ )/ |/ L1/ |/ </ |/ α/ β/ |/ ./ 这/ 说明/ 产生/ 式/ A/ →/ α/ β/ 右部/ 只有/ 部分/ 结构/ 在/ L1/ 中/ ./ 包括/ 3/ 种/ 细分/ 情况/ :/ ①/ L1/ 只/ 识别/ 了/ β/ ,/ 执行/ 归/ 约会/ 识别/ 输入/ 串/ 的/ 前缀/ ,/ 即/ a1/ …/ akt1/ …/ ti/ -/ 1/ (/ 其中/ a1/ …/ ak/ 为/ 缺失/ 的/ 输入/ 串/ )/ ;/ ②/ L1/ 只/ 识别/ 了/ α/ ,/ 执行/ 归/ 约会/ 识别/ 输入/ 串/ 的/ 后缀/ ,/ 即/ t1/ …/ ti/ -/ 1a1/ …/ ak/ (/ 其中/ a1/ …/ ak/ 为/ 缺失/ 的/ 输入/ 串/ )/ ;/ ③/ L1/ 只/ 识别/ 了/ 产生/ 式/ 的/ 中间/ 部分/ ,/ 执行/ 归/ 约会/ 识别/ 输入/ 串/ 的/ 前缀/ 和/ 后缀/ ,/ 即/ a1/ …/ akt1/ …/ ti/ -/ 1b1/ …/ bp/ (/ 其中/ a1/ …/ ak/ 和/ b1/ …/ bp/ 为/ 缺失/ 的/ 输入/ 串/ )/ ./ 步骤/ (/ 3.3/ )/ 中/ L1/ 仅/ 识别/ 了/ 部分/ 子串/ ,/ 可能/ 导致/ 例/ 1/ 提及/ 的/ 错误/ 掩盖/ 问题/ ./ 需/ 检查/ A/ →/ α/ β/ 是否/ 具有/ disable/ _/ substring/ 属性/ ./ 若有/ ,/ 则/ 不/ 执行/ 此/ 归约/ ./ 步骤/ (/ 3.3/ )/ 中/ 执行/ 归约/ 后/ 将/ 清空/ 分析/ 栈/ L1/ ./ 此时/ ,/ Rekers/ 算法/ 会/ 导致/ 步骤/ (/ 3.2/ )/ 类似/ 的/ 问题/ ./ 可以/ 通过/ 以下/ 措施/ 修正/ :/ 检查/ α/ β/ 是否/ 包含/ 符号/ A/ ,/ 若/ 包含/ A/ 且/ 分析/ 栈/ L1/ 只/ 识别/ 了/ A/ ,/ 执行/ 归约/ 将令/ 算法/ 陷入/ 死循环/ ,/ 应/ 停止/ 归约/ ./ 如/ 不/ 满足/ 上述/ 条件/ ,/ 则/ 执行/ 步骤/ (/ 3.2/ )/ 第/ ②/ 步/ 相同/ 的/ 检查/ 处理/ ./ 步骤/ (/ 3/ )/ 的/ 归约/ 动作/ 的/ 伪/ 代码/ 如下/ 所示/ ./ boolSubstringReduce/ (/ Productionprod/ ,/ Stackstack/ )/ {/ if/ (/ |/ stack/ |/ >/ |/ prod/ |/ )/ // // prod/ 结构/ 完全/ 在/ stack/ 中/ {/ return/ 执行/ 标准/ GLR/ 归约/ 过程/ }/ elseif/ (/ |/ stack/ |/ / |/ prod/ |/ )/ {/ if/ (/ |/ stack/ |/ </ |/ prod/ |/ )/ {/ if/ (/ prod/ 具有/ disable/ _/ substring/ 属性/ )/ }/ NonterminalA/ =/ prod/ 左侧/ 非/ 终结符/ if/ (/ |/ stack/ |/ =/ =/ |/ prod/ |/ andprod/ 右侧/ 包含/ A/ )/ {/ // // 若/ prod/ 右侧/ A/ 的/ 左右/ 符号/ 均/ 可/ 推出/ 空串/ ,/ 停止/ 归约/ if/ (/ Nullable/ (/ LeftA/ )/ andNullable/ (/ RightA/ )/ )/ returnfalse/ // // 拒绝/ 归约/ }/ if/ (/ |/ stack/ |/ </ |/ prod/ |/ andprod/ 右侧/ 包含/ A/ 且/ stack/ 上仅识/ returnfalse/ // // 该/ 归约/ 可能/ 陷入/ 无限/ 死循环/ ,/ 拒绝/ 归约/ // // 从/ 分析/ 表/ 查找/ 可以/ 移入/ (/ GOTO/ 关系/ )/ A/ 的/ 所有/ 状态/ StateSetallStates/ =/ LookupGOTO/ (/ A/ )/ // // 调用/ 用户/ 自定义/ 的/ 错误处理/ 回调/ 函数/ StateSetfilterStates/ =/ UserFilterCallBack/ (/ prod/ ,/ stack/ ,/ emptystack/ // // 清空/ 现有/ 分析/ 栈/ // // 取出/ 集合/ filterStates/ 中/ 的/ 每/ 一个/ 状态/ ,/ 令该/ 状态/ 为/ mforeachstateminfilterStates/ {/ 新建/ 分析/ 栈/ L/ ,/ 其中/ m/ 为/ 栈底/ ,/ 标记/ m/ 为/ L/ 的/ 初始/ 结点/ ,/ 利用/ L/ 对/ 剩余/ 字符串/ 进行/ 分析/ }/ returntrue/ // // 返回/ true/ 表示/ 接受/ 并/ 处理/ 了/ 归约/ }/ }/ 5/ 实验/ 结果/ 为/ 验证/ 算法/ 的/ 有效性/ 和/ 性能/ ,/ 本文/ 设计/ 了/ 两组/ 实验/ ./ 第/ 1/ 组/ (/ 5.1/ 节/ )/ ,/ 通过/ 实例/ 剖析/ 算法/ 的/ 执行/ 过程/ ,/ 评价/ 算法/ 的/ 错误报告/ 效果/ ./ 第/ 2/ 组/ (/ 5.2/ 节/ )/ ,/ 通过/ 构造/ Java/ 分析器/ ,/ 评价/ 算法/ 性能/ ./ 5.1/ 算法/ 运行/ 剖析/ 及/ 错误报告/ 评价/ 例/ 2/ ./ 图/ 5/ 给出/ 了/ 一个/ 文法/ G/ [/ S/ ]/ ,/ 表/ 1/ 是/ 该/ 文法/ 对应/ 的/ LALR/ (/ 1/ )/ 分析/ 表/ ./ 从表/ 1/ 可/ 看出/ ,/ 状态/ 5/ 包含/ reduce/ -/ reduce/ 冲突/ ./ G/ [/ S/ ]/ 可/ 接受/ 的/ 符号/ 为/ i/ 、/ j/ 、/ k/ ./ 输入/ 串/ iij/ 是/ 文法/ 的/ 合法/ 句子/ ,/ 给/ 其/ 植入/ 两类/ 典型/ 错误/ :/ 一类/ 是/ 文法/ 不/ 识别/ 的/ 输入/ 串/ ;/ 另一类/ 是/ 文法/ 可/ 识别/ 但/ 非法/ 的/ 输入/ 串/ (/ 图/ 6/ )/ ./ 算法/ 的/ 执行/ 步骤/ 如下/ 所示/ ./ 1/ ./ 初始/ 时/ 执行/ 正常/ GLR/ 分析/ ,/ 得到/ 的/ 分析/ 栈如图/ 7/ 所示/ ./ 其中/ ,/ 方块/ 表示/ 状态/ ,/ 状态/ 间/ 的/ 箭头/ 表示/ 状态/ 的/ 构造/ 关/ Page8/ 系/ ,/ 箭头/ 上/ 的/ 连线/ 表示/ 语义/ 值/ ;/ 2/ ./ 执行/ 归约/ 检查/ :/ 活动/ 栈顶/ 为/ 状态/ 13/ ,/ 向前/ 看/ 符号/ 为/ m/ ,/ 不能/ 执行/ 任何/ 归约/ 动作/ ./ 执行/ 移进/ 检查/ :/ 活动/ 栈顶/ 为/ 状态/ 13/ ,/ 不能/ 移入/ 符号/ m/ ,/ GLR/ 分析器/ 报错/ ,/ 启动/ 子串/ 分析器/ 进行/ 错误处理/ ;/ 3/ ./ 子串/ 分析器/ 的/ 输入/ 符号串/ 为/ mnik/ ./ 表/ 1/ 中/ 不/ 存在/ 能/ 移入/ 符号/ m/ 、/ n/ 的/ 任何/ 状态/ ,/ 循环/ 执行/ 算法/ 2/ 中/ 第/ 8/ ~/ 20/ 行处/ 的/ 代码/ 两次/ ,/ 子串/ 分析器/ 报错/ ,/ 把/ 错误/ 符号串/ 挂/ 接到/ 最终/ 的/ 分析/ 结果/ 中/ (/ 图/ 8/ )/ ;/ 图/ 8/ 执行/ 错误处理/ :/ 把/ 非法/ 符号/ mn/ 挂/ 接到/ 结果/ 中/ 4/ ./ 执行/ 算法/ 2/ 中/ 第/ 8/ ~/ 20/ 行/ 代码/ ,/ currentToken/ =/ i/ ./ 执行/ 19/ 行处/ 的/ 语句/ ,/ InitialShiftStates/ =/ {/ 0/ ,/ 2/ ,/ 10/ ,/ 12/ ,/ 15/ }/ ,/ 可移/ 符号/ i/ 的/ 状态/ 共有/ 5/ 个/ ./ 为/ 展示/ 错误处理/ 算法/ 的/ 完整/ 运行/ 效果/ ,/ 此处/ 不/ 执行/ 交互式/ 剪枝/ ./ 执行/ 算法/ 2/ 中/ 31/ ~/ 35/ 行处/ 的/ 代码/ ,/ 为/ 5/ 个/ 状态/ 分别/ 创建/ 分析/ 栈/ (/ a/ )/ 、/ (/ b/ )/ 、/ (/ c/ )/ 、/ (/ d/ )/ 、/ (/ e/ )/ (/ 图/ 9/ )/ ;/ 5/ ./ 子串/ 分析器/ 移入/ i/ (/ 图/ 10/ )/ ./ 注意/ :/ 5/ 条栈/ 对应/ 5/ 种/ 不同/ 的/ 错误/ 恢复/ 决策/ ,/ 不能/ 执行/ 栈/ 合并/ ;/ 图/ 10/ 执行/ 错误处理/ :/ 5/ 条/ 分析/ 栈均/ 移入/ 符号/ i6/ ./ 对/ 5/ 条栈/ 分别/ 执行/ 子串/ 分析/ ./ 以/ 分析/ 栈/ (/ a/ )/ 为例/ ./ ①/ 执行/ 归约/ 检查/ ./ 活动/ 栈顶/ 为/ 状态/ 5/ ,/ 面临/ 的/ 向前/ 看/ 符号/ 为/ k/ ,/ 应/ 执行/ 归约/ 动作/ R8/ ,/ 即用/ 产生/ 式/ G/ →/ i/ 归约/ ./ 此时/ ,/ 分析/ 栈/ 长度/ 为/ 2/ ,/ 归约/ 产生/ 式/ 长度/ |/ G/ →/ i/ |/ =/ 1/ ,/ 执行/ GLR/ 标准/ 归约/ ,/ 分析器/ 到达/ 状态/ 6/ ./ 状态/ 6/ 在/ 输入/ 符号/ 为/ k/ 时/ 执行/ 动作/ R9/ ,/ 即用/ 产生/ 式/ E/ →/ G/ 归约/ ,/ 此时/ ,/ 分析/ 栈/ 长度/ 为/ 2/ ,/ 归约/ 产生/ 式/ 长度/ |/ E/ →/ G/ |/ =/ 1/ ,/ 执行/ GLR/ 标准/ 归约/ ,/ 分析器/ 到达/ 状态/ 4/ ;/ ②/ 执行/ 移进/ 检查/ ./ 活动/ 栈顶/ 为/ 状态/ 5/ 、/ 6/ 、/ 4/ ./ 状态/ 5/ 、/ 6/ 不能/ 移入/ 符号/ k/ ,/ 这/ 两条/ 分支/ 被/ 废止/ ./ 状态/ 4/ 执行/ 动作/ S11/ 转移/ 到/ 状态/ 11/ (/ 图/ 11/ )/ ;/ ③/ 执行/ 归约/ 检查/ ./ 活动/ 栈顶/ 为/ 状态/ 11/ ,/ 面临/ 的/ 向前/ 看/ 符号/ 为/ $/ ,/ 不能/ 执行/ 归约/ ;/ ④/ 执行/ 移进/ 检查/ ./ 活动/ 栈顶/ 为/ 状态/ 11/ ,/ 输入/ 串/ 已/ 读取/ 完毕/ ,/ 不能/ 移入/ 符号/ $/ ,/ 且/ 分析器/ 不/ 处于/ 接受/ 状态/ ,/ 分析/ 栈/ (/ a/ )/ 分析/ 完毕/ ,/ 报错/ 退出/ (/ 图/ 12/ )/ ;/ 图/ 11/ 执行/ 错误处理/ :/ 分析/ 栈/ (/ a/ )/ 执行/ 第一次/ 归约/ -/ 移进/ 图/ 12/ 执行/ 错误处理/ :/ 分析/ 栈/ (/ a/ )/ 分析/ 完毕/ ,/ 发现错误/ 对/ 分析/ 栈/ (/ b/ )/ 、/ (/ c/ )/ 、/ (/ d/ )/ 、/ (/ e/ )/ 执行/ 子串/ 分析/ 后/ ,/ 最后/ 得到/ 的/ 分析/ 结果/ 如图/ 13/ ~/ 图/ 16/ 所示/ ./ 图/ 13/ 执行/ 错误处理/ :/ 分析/ 栈/ (/ b/ )/ 分析/ 完毕/ ,/ 发现错误/ 图/ 15/ 执行/ 错误处理/ :/ 分析/ 栈/ (/ d/ )/ 分析/ 完毕/ ,/ 发现错误/ Page97/ ./ 步/ 6/ 的/ 5/ 条栈/ 都/ 分析/ 完后/ ,/ 需要/ 把/ 子串/ 分析器/ 的/ 分析/ 结果/ 合并/ 到/ 最终/ 结果/ 中/ ./ 其中/ ,/ 分析/ 栈/ (/ a/ )/ 、/ (/ b/ )/ 、/ (/ d/ )/ 可以/ 分析/ 完全/ 部/ 输入/ 串/ ;/ 分析/ 栈/ (/ c/ )/ 和/ (/ e/ )/ 不能/ 分析/ 完/ 输入/ 串/ ,/ 中途/ 报错/ 停止/ ./ 错误/ 恢复/ 的/ 本质/ 是从/ 多个/ 可能/ 的/ 恢复/ 决策/ 中/ 选择/ “/ 最/ 合理/ ”/ 的/ 决策/ ./ 如果/ 用户/ 知道/ 如何/ 处理错误/ ,/ 可/ 利用/ 图/ 3/ 的/ 交互式/ 算法/ 剪枝/ ./ 否则/ ,/ 算法/ 自动/ 选择/ “/ 最/ 合理/ ”/ 的/ 决策/ ./ 本文/ 算法/ 判断/ 分支/ 是否/ 合理/ 的/ 依据/ 是/ 看/ 输入/ 串/ 的/ 分析/ 程度/ ,/ 能/ 分析/ 越/ 多/ 输入/ 串/ 的/ 分支/ ,/ 算法/ 认为/ 其/ 恢复/ 效果/ 越好/ ./ 如果/ 两个/ 恢复/ 分支/ 能/ 分析/ 的/ 输入/ 串/ 符号/ 数量/ 相同/ ,/ 选择/ 其中/ 的/ 第一个/ ./ 本例/ 中/ 用户/ 没有/ 交互式/ 剪枝/ ,/ 按/ 上述/ 逻辑/ ,/ 分析/ 栈/ (/ a/ )/ 的/ 结果/ 应/ 作为/ 最终/ 分析/ 结果/ ,/ 最后/ 得到/ 的/ 完整/ 的/ 分析树/ (/ 分析/ 森林/ )/ 如图/ 17/ 所示/ ./ 以上/ 对/ 本文/ 设计/ 的/ GLR/ 错误处理/ 和/ 恢复/ 算法/ 进行/ 了/ 详细/ 剖析/ ./ 下面/ 针对/ 错误报告/ 的/ 主要/ 指标/ ,/ 结合/ 例/ 2/ ,/ 评价/ 算法/ 的/ 错误报告/ 效果/ ./ (/ 1/ )/ 正确/ 报告/ 错误/ ./ 对于/ 植入/ 的/ 两类/ 典型/ 错误/ ,/ 算法/ 都/ 能/ 有效/ 侦测/ ,/ 没有/ 错报/ 和/ 漏报/ 错误/ ,/ 符合/ 该/ 指标/ ;/ (/ 2/ )/ 能/ 尽早/ 报告/ 实验/ 编号/ 源文件/ 行/ 数/ 单词/ 数/ VPGE/ (/ tree/ )/ VPGE/ (/ notree/ )/ Bison/ (/ notree/ )/ 表/ 2VPGE/ 和/ Bison/ 生成/ 的/ 分析器/ 性能/ 对比/ 执行/ 时间/ // clock309346143103183268648474862321115525327132569829632181310295746169815220452823765607906324398177512855410136864838620881128831957742662278403799165349515238818843035259938160078894322585963694617221659329281283975175397757969437820/ 错误/ ./ 从例/ 2/ 可/ 看出/ ,/ 错误/ 的/ 侦测/ 点/ 和/ 错误/ 的/ 产生/ 点/ 并/ 不/ 一致/ ,/ 不/ 满足/ 立即/ 错误/ 侦测/ 性质/ ,/ 但/ 满足/ 正确/ 前缀/ 性质/ ,/ 部分/ 符合/ 该/ 指标/ ;/ (/ 3/ )/ 错误报告/ 友好/ ./ 从例/ 2/ 可/ 看出/ ,/ 算法/ 能/ 获知/ 错误/ 发生/ 时/ 的/ 产生/ 式/ 和/ 输入/ 串/ 的/ 处理/ 位置/ ,/ 符合/ 该/ 指标/ ;/ (/ 4/ )/ 避免/ 重复/ 报告/ 相同/ 错误/ ./ 符合/ 该/ 指标/ ;/ (/ 5/ )/ 能/ 一次/ 侦测/ 尽可能/ 多/ 的/ 错误/ ./ 从例/ 2/ 可/ 看出/ ,/ 算法/ 可以/ 从/ 两类/ 典型/ 语法错误/ 中/ 恢复/ ,/ 能/ 侦测/ 后续/ 错误/ ,/ 符合/ 该/ 指标/ ./ 5.2/ 算法/ 性能/ 评价/ 本文/ 给出/ 4/ 组/ 实验/ 结果/ 以/ 评估/ 算法/ 性能/ ./ 实验/ 1/ 评估/ 正常/ GLR/ 分析/ 时/ 的/ 分析/ 性能/ ;/ 实验/ 2/ 考察/ 正常/ GLR/ 分析/ 切换/ 到/ 子串/ 分析/ 时/ 的/ 性能/ ;/ 实验/ 3/ 考察/ 输入/ 串中/ 的/ 错误/ 数量/ 对/ 算法/ 性能/ 的/ 影响/ ;/ 实验/ 4/ 考察/ 子串/ 分析/ 和/ 正常/ GLR/ 分析/ 的/ 性能/ 对比/ ./ 实验/ 1/ ./ 正常/ GLR/ 分析/ 性能/ ./ 为/ 验证/ 正常/ GLR/ 分析/ 的/ 性能/ ,/ 本文/ 用/ 项目/ 小组/ 研制/ 的/ VPGE/ 分析器/ 生成器/ 和/ 目前/ 公认/ 的/ 应用/ 最广/ 、/ 速度/ 最快/ 的/ LALR/ (/ 1/ )/ 分析器/ 生成器/ Bison/ 各/ 生成/ 了/ 一个/ Java1/ ./ 4/ 版/ 分析器/ ./ Java1/ ./ 4/ 的/ 官方/ 文法/ 采用/ EBNF/ 范式/ 定义/ ,/ 本文/ 将/ 其/ 改写/ 为/ BNF/ 范式/ ,/ 共/ 包含/ 216/ 条/ 产生/ 式/ ./ 对于/ 该/ 文法/ ,/ Bison/ 报告/ 235/ 个/ 语法/ 冲突/ ,/ 共/ 317/ 个/ LALR/ (/ 1/ )/ 自动机/ 状态/ ./ 由于/ LALR/ (/ 1/ )/ 分析器/ 不能/ 分析/ 冲突/ 文法/ ,/ 本文/ 对/ 文法/ 进行/ 了/ 改写/ ,/ 改写/ 后/ 包括/ 278/ 条/ 产生/ 式/ ,/ Bison/ 报告/ 0/ 个/ 冲突/ ,/ 448/ 个/ LALR/ (/ 1/ )/ 自动机/ 状态/ ./ 选择/ Java/ 文法/ 的/ 原因/ 有/ 两/ 方面/ ./ 一方面/ ,/ Bison/ 生成/ 的/ LALR/ (/ 1/ )/ 分析器/ 不/ 允许/ 分析/ 表中/ 存在/ 冲突/ ,/ 而/ Java1/ ./ 4/ 文法/ 恰好/ 可以/ 改写/ 为/ LALR/ (/ 1/ )/ 文法/ ;/ 另一方面/ ,/ Java/ 文法/ 在/ 程序设计/ 语言/ 文法/ 中/ 属于/ 中等/ 规模/ 复杂度/ 文法/ ,/ 具备/ 了/ 命令式/ 程序设计/ 语言/ 的/ 各种/ 典型/ 语法/ 特征/ ./ 利用/ 改写/ 后/ 的/ Java/ 文法/ ,/ 笔者/ 用/ VPGE/ 生成/ 了/ GLR/ 分析器/ ,/ 用/ Bison/ 生成/ 了/ LALR/ (/ 1/ )/ 分析器/ ./ 两个/ 分析器/ 都/ 由/ C语言/ 实现/ ,/ 只/ 执行/ 语法分析/ ,/ 不/ 执行/ 用户/ 自定义/ 的/ 语义/ 动作/ ,/ 表/ 2/ 是/ 两者/ 的/ 时间性/ Page10/ 能/ 对比/ ①/ ./ 从表/ 2/ 可/ 看出/ ,/ VPGE/ 生成/ 的/ GLR/ 分析器/ 比/ Bison/ 生成/ 的/ LALR/ (/ 1/ )/ 分析器/ 执行/ 语法分析/ 慢/ 2/ ~/ 5/ 倍/ ./ 考虑/ 到/ 实际/ 分析器/ 中/ 语法分析/ 所/ 占/ 的/ 时间/ 比重/ 很小/ (/ 参见/ 表/ 3/ )/ ,/ 大部分/ 时间/ 都/ 消耗/ 在/ 语义/ 动作/ 等/ 其它/ 开销/ 上/ ,/ 而/ 语义/ 动作/ 等/ 其它/ 代码/ 是/ 用户/ 编写/ 的/ ,/ 可/ 认为/ 两个/ 分析器/ 执行/ 这部分/ 代码/ 的/ 时间/ 相同/ ./ 因此/ ,/ 即使/ VPGE/ 生成/ 的/ 分析器/ 语法分析/ 速度/ 比/ Bison/ 生成/ 的/ 分析器/ 慢些/ ,/ 并/ 不会/ 显著/ 影响/ 总/ 分析/ 速度/ ./ 得出/ 该/ 结论/ 的/ 前提/ 是/ ,/ 纯/ 语法分析/ 时间/ 占/ 总/ 分析/ 时间/ 的/ 比/ 重要/ 足够/ 小/ ./ 为/ 考察/ 这/ 一点/ ,/ 看/ 一下/ 例/ 3/ ./ 例/ 3/ ./ 上文/ Bison/ 生成/ 的/ Java/ 分析器/ 只/ 执行/ 语法分析/ ,/ 不/ 执行/ 任何/ 语义/ 动作/ ./ GNU/ 的/ Java/ 编译器/ 使用/ 了/ 同样/ 的/ 文法/ ,/ 它/ 执行/ 语法分析/ 、/ 语义/ 动作/ 、/ 代码优化/ 、/ 代码生成/ 、/ 程序/ 链接/ 等/ 各个/ 过程/ ./ 本文/ 用/ Bison/ 生成/ 的/ Java/ 分析器/ 和/ GNU/ 的/ Java/ 编译器/ 对同/ 一组/ 测试/ 文件/ 分析/ ,/ 这样/ 就/ 可/ 估算/ 出/ 一个/ 实际/ 应用/ 中纯/ 语法分析/ 时间/ 的/ 比重/ ,/ 表/ 3/ 给出/ 了/ 实验/ 数据/ ./ 源文件/ 实验/ 编号/ 1224545814129803881800.01522201058125533748433510090/ ./ 02534111772188637630311656180.062410674908439815635557382980/ ./ 12454636215481793087973563332250.244686324026833088567116804859550/ ./ 2837137386418852520276171585565470.3068180988498869854687224669178380/ ./ 31192251810578887535785274146975720.3191038152178588146215954444131565040/ ./ 329/ 从表/ 3/ 可/ 看出/ ,/ 在/ 源文件/ 规模较/ 小时/ ,/ 语法分析/ 时间/ 的/ 比重/ 很小/ ./ 随着/ 源文件/ 规模/ 的/ 增大/ ,/ 语法分析/ 时间/ 比重/ 逐渐/ 增大/ ,/ 最后/ 稳定/ 在/ 0.320/ %/ 左右/ ./ 基于/ 上述/ 数据/ ,/ 考察/ 一下/ VPGEGLR/ 分析器/ 和/ BisonLALR/ (/ 1/ )/ 分析器/ 的/ 总/ 分析/ 速度/ 对比/ ./ 令/ Bison/ 生成/ 的/ LALR/ (/ 1/ )/ 分析器/ 总/ 执行/ 时间/ 为/ Tb/ ,/ 语法分析/ 时间/ 占/ 总/ 执行/ 时间/ 的/ 百分比/ 为/ m/ ;/ VPGE/ 生成/ 的/ GLR/ 分析器/ 总/ 执行/ 时间/ 为/ Tv/ ,/ 对/ 同样/ 的/ 文法/ 进行/ 纯/ 语法分析/ 时/ (/ 不/ 执行/ 任何/ 其它/ 动作/ )/ 比/ Bison/ 的/ LALR/ (/ 1/ )/ 分析器/ 慢/ k/ -/ 1/ 倍/ (/ k/ >/ 1/ )/ ,/ 则/ Tb/ 和/ Tv/ 满足/ 根据/ 表/ 3/ 数据/ ,/ m/ 值约/ 为/ 0.320/ %/ ,/ k/ 的/ 值/ 为/ 3/ ~/ 6/ ,/ 给/ k/ 取/ 平均值/ 4.5/ ,/ 可/ 得到/ Tb/ // Tv/ =/ 98.89/ %/ ./ 这/ 说明/ ,/ 若/ Bison/ 生成/ 的/ LALR/ (/ 1/ )/ 分析器/ 执行/ 语法分析/ 时间/ 占/ 总/ 执行/ 时间/ 的/ 0.320/ %/ ,/ VPGE/ 生成/ 的/ GLR/ 分析器/ 执行/ 纯/ 语法分析/ 比/ Bison/ 生成/ 的/ LALR/ (/ 1/ )/ 分析器/ 慢/ 3.5/ 倍/ (/ k/ =/ 4.5/ )/ ,/ 则/ VPGE/ 生成/ 的/ GLR/ 分析器/ 总/ 速度/ 大约/ 是/ Bison/ 生成/ 的/ LALR/ (/ 1/ )/ 分析器/ 总/ 速度/ 的/ 98.89/ %/ ./ 综合/ 上述/ 分析/ ,/ 可/ 推论/ :/ 若/ 文法/ 为/ 无/ 二义性/ 的/ LALR/ (/ 1/ )/ 文法/ 或者/ 包含/ 少量/ 冲突/ 的/ 近/ LALR/ (/ 1/ )/ 文法/ ,/ VPGE/ 生成/ 的/ GLR/ 分析器/ 和/ Bison/ 生成/ 的/ LALR/ (/ 1/ )/ 分析器/ 总/ 执行/ 速度/ 具有/ 可比性/ ./ GLR/ 算法/ 历史/ 上/ 经历/ 过/ 多次/ 改进/ ,/ Rekers/ [/ 22/ ]/ 做出/ 了/ 最后/ 一次/ 重要/ 修正/ ,/ 使/ 其能/ 处理/ 文法/ 中/ 的/ 循环/ 产生/ 式/ 和/ ε/ -/ 产生/ 式/ ,/ 并且/ 在/ ASF/ +/ SDF/ 元/ 环境/ 中/ 进行/ 了/ 实现/ 验证/ ./ 文献/ [/ 22/ ]/ 中/ 报告/ Rekers/ 生成/ 的/ GLR/ 分析器/ 比/ YACC/ 生成/ 的/ LALR/ (/ 1/ )/ 分析器/ 慢/ 10/ 至/ 20/ 倍/ ,/ 该/ 文献/ 没有/ 说明/ 使用/ 的/ YACC/ 版本/ ,/ 事实上/ ,/ 作为/ YACC/ 的/ 升级/ 软件/ —/ —/ —/ Bison/ 在/ 性能/ 方面/ 已/ 优于/ YACC/ ./ 由此/ 可以/ 推断/ ,/ 本文/ 实现/ 的/ GLR/ 算法/ 性能/ 优于/ Rekers/ 实现/ 的/ GLR/ 算法/ ./ 从表/ 2/ 还/ 可/ 看出/ ,/ 构造/ 分析树/ (/ 分析/ 森林/ )/ 消耗/ 了/ 大量/ 时间/ ./ Bison/ 不/ 构造/ 分析树/ (/ 分析/ 森林/ )/ ,/ 不/ 支持/ 语法分析/ 后/ 的/ 剪枝/ 消歧/ ,/ 限制/ 了/ 分析器/ 调试/ 和/ 语义/ 处理/ 的/ 灵活性/ ./ VPGE/ 中/ 是否/ 构造/ 分析树/ (/ 分析/ 森林/ )/ 可/ 通过/ 开关/ 控制/ ./ 调试/ 过程/ 中/ ,/ 可/ 构造/ 分析树/ (/ 分析/ 森林/ )/ ,/ 这样/ 尽管/ 分析/ 时间/ 较长/ ,/ 却/ 给/ 调试/ 带来/ 了/ 方便/ ./ 调试/ 完毕/ 后/ ,/ 可/ 禁用/ 分析树/ 构造/ ,/ 以/ 提高/ 分析/ 性能/ ./ 实验/ 2/ ./ 正常/ GLR/ 分析/ 切换/ 到/ 子串/ 分析/ 的/ 性能/ ./ 本例/ 在/ 测试/ 源文件/ 中/ 植入/ 一个/ 错误/ ,/ 通过/ 插入/ 探针/ 确定/ 执行/ 时间/ ,/ 表/ 4/ 给出/ 了/ 实验/ 结果/ ./ 从中/ 可/ 看出/ ,/ 不同/ 规模/ (/ 行/ 数/ )/ 的/ 源文件/ ,/ 从/ 正常/ GLR/ 分析/ 切换/ 到/ 子串/ 分析/ 的/ 时间/ 开销/ 基本一致/ ./ 实验/ 编号/ 源文件/ 行/ 数/ 单词/ 数/ 执行/ 时间/ // ms123456781600788942932928128396/ ①/ 实验机/ 配置/ :/ AMDAthlon/ (/ TM/ )/ XP2500/ +/ 、/ 1GRAM/ 、/ Page11/ 实验/ 3/ ./ 输入/ 串/ 的/ 错误/ 数量/ 与/ 算法/ 性能/ 关系/ ./ 本例/ 测试/ 源文件/ 约/ 16000/ 行/ ,/ 给/ 其/ 随机/ 植入/ 不同/ 数量/ 的/ 错误/ ,/ 表/ 5/ 给出/ 了/ 实验/ 结果/ ./ 从中/ 可/ 看出/ ,/ 子串/ 分析器/ 的/ 执行/ 速度/ 跟/ 输入/ 串/ 的/ 错误/ 数量/ 密切相关/ ,/ 错误/ 越/ 多/ ,/ 执行/ 时间/ 越长/ ./ 表/ 5/ 还/ 给出/ 了/ 植入/ 错误/ 和/ 检出/ 错误/ 的/ 对比/ ,/ 从中/ 可以/ 看出/ ,/ 算法/ 具有/ 良好/ 的/ 错误/ 侦测/ 能力/ ./ 实验/ 编号/ 单词/ 数/ 植入/ 的/ 188941128893210388918204889034058887070688828110107189007887811601582445688872322021727904/ 实验/ 4/ ./ 子串/ 分析/ 与/ 正常/ GLR/ 分析/ 的/ 性能/ 对比/ ./ 本例/ 采用/ 实验/ 2/ 相同/ 的/ 测试/ 文件/ ,/ 表/ 6/ 给出/ 了/ 错误/ 植入/ 前后/ 的/ 执行/ 时间/ 对比/ ./ 从中/ 可/ 看出/ ,/ 子串/ 分析/ 的/ 性能/ 跟/ 输入/ 串/ 规模/ 正/ 相关/ ,/ 输入/ 串/ 越长/ ,/ 算法/ 执行/ 时间/ 越长/ ./ 从表/ 6/ 还/ 可/ 看出/ ,/ 子串/ 分析/ 的/ 性能/ 较/ 正常/ GLR/ 分析/ 性能/ 低/ ,/ 比/ 后者/ 慢/ 2/ ~/ 3/ 倍/ 左右/ ./ 表/ 6/ 子串/ 分析器/ 跟/ 标准/ GLR/ 分析器/ 性能/ 对比/ 实验/ 编号/ 14310210232111543218130945282375512855409620881128717579916534948338160078894212349329281283962828Rekers/ 算法/ 主要/ 用于/ 可视化/ 编辑器/ 的/ 字符串/ 自动/ 补全/ ,/ 缺少/ 本文/ 算法/ 的/ 运行/ 时/ 错误处理/ 和/ 恢复/ 机制/ ./ 文献/ [/ 16/ ]/ 中/ 给出/ 的/ 输入/ 串/ 长度/ 都/ 很/ 短/ ,/ 最长/ 包含/ 500/ 个/ 符号/ ,/ 植入/ 一个/ 错误/ 时/ 执行/ 时间/ 约/ 为/ 0.4/ s/ ./ 从表/ 6/ 可/ 看出/ ,/ 本文/ 算法/ 分析/ 1154/ 个/ 符号/ (/ 植入/ 一个/ 错误/ )/ 耗时/ 约/ 22ms/ ./ 文献/ [/ 16/ ]/ 只/ 提及/ 测试/ 机/ 环境/ 是/ SUNSPARC/ 工作站/ ,/ 无从/ 确知/ 其/ 速度/ 与/ 笔者/ 计算机/ 速度/ 的/ 关系/ ,/ 单纯/ 从/ 执行/ 时间/ 上/ 不能/ 判断/ 出/ 两者/ 的/ 绝对速度/ 关系/ ./ 6/ 结论/ 本文/ 以/ Richter/ 算法/ 和/ Rekers/ 算法/ 为/ 基础/ ,/ 借鉴/ LR/ 的/ 错误处理/ 策略/ ,/ 设计/ 实现/ 了/ GLR/ 的/ 错误/ 恢复/ 算法/ ./ 分析/ 了/ Richter/ 算法/ 和/ Rekers/ 算法/ 存在/ 的/ 问题/ ,/ 从/ 4/ 个/ 方面/ 进行/ 了/ 优化/ :/ (/ 1/ )/ 解决/ 了/ 原/ 算法/ 存在/ 的/ 错误/ 掩盖/ 问题/ ;/ (/ 2/ )/ 修正/ 了/ 原/ 算法/ 可能/ 的/ 死循环/ 问题/ ;/ (/ 3/ )/ 优化/ 了/ 算法/ 的/ 执行/ 速度/ ;/ (/ 4/ )/ 添加/ 了/ 必要/ 的/ 运行/ 时/ 错误处理/ 和/ 恢复/ 机制/ ./ 实验/ 部分/ 通过/ 一个/ 完整/ 实例/ ,/ 剖析/ 了/ 算法/ 的/ 执行/ 过程/ ,/ 评价/ 了/ 错误报告/ 效果/ ./ 通过/ Java/ 程序设计/ 语言/ 的/ 系列/ 实验/ ,/ 评价/ 了/ 算法/ 在/ GLR/ 错误处理/ 和/ 恢复/ 时/ 的/ 性能/ ./ 通过/ 表/ 6/ 可以/ 看出/ ,/ 子串/ 分析/ 比/ 正常/ GLR/ 分析/ 慢/ 2/ ~/ 3/ 倍/ ,/ 后续/ 需/ 进一步/ 优化/ 子串/ 分析/ 性能/ ./ 实际/ 分析/ 场景/ 中/ ,/ 正确/ 串/ 一般/ 占/ 绝大多数/ ,/ 错误/ 串/ 只/ 占/ 少数/ ./ 在/ 这种/ 情况/ 下/ ,/ 主要/ 执行/ 正常/ GLR/ 分析/ ./ 本文/ 算法/ 对此/ 已/ 做/ 过/ 多层次/ 优化/ ,/ 分析/ 效率/ 较/ 高/ ./ 此外/ ,/ 用户/ 也/ 可以/ 通过/ 交互式/ 的/ 分支/ 选择/ 例程/ ,/ 进一步/ 提升/ 算法/ 性能/ ./ 综合/ 上述/ 分析/ ,/ 可以/ 得出结论/ ,/ 本文/ 算法/ 可/ 用于/ 程序设计/ 语言/ GLR/ 分析/ 时/ 的/ 自动/ 错误处理/ 和/ 恢复/ ,/ 具备/ 实际/ 推广应用/ 价值/ ./ 

