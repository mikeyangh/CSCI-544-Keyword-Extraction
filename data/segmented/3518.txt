Page1/ 基于/ ChunkFolding/ 的/ 多/ 租户/ 数据库/ 缓存/ 管理机制/ 姚金成/ 张世栋/ 史玉良/ 李庆忠/ (/ 山东大学/ 计算机科学/ 与/ 技术/ 学院/ 济南/ 250101/ )/ 摘要/ ChunkFolding/ 是/ SaaS/ 模式/ 下/ 常用/ 的/ 存储/ 架构/ 之一/ ,/ 通过/ 共享/ 数据库/ 共享/ 架构/ 来/ 存储/ 租户/ 的/ 数据/ 以/ 获取/ 规模/ 经济效益/ ,/ 但/ 基于/ 传统/ 数据库/ 搭建/ 的/ ChunkFolding/ 共享/ 存储/ 架构/ ,/ 其/ 缓存/ 管理机制/ 缺乏/ 良好/ 的/ 多/ 租户/ 特性/ ,/ 导致/ 数据库/ 性能/ 恶化/ ,/ 租户/ 的/ SLA/ 得不到/ 保障/ ./ 为此/ ,/ 提出/ 了/ 基于/ ChunkFolding/ 的/ 自/ 适应/ 多/ 租户/ 缓存/ 管理机制/ ,/ 该/ 机制/ 以/ 租户/ 的/ SLA/ 需求/ 作为/ 驱动/ ,/ 依据/ 租户/ 当前/ 访问/ 模式/ ,/ 动态/ 生成/ 缓存/ 单元/ 集/ 并/ 计算/ 缓存/ 单元/ 集/ 的/ I/ // O/ 效益/ ,/ 通过/ 贪婪/ 算法/ 来/ 选择/ 缓存/ 单元/ 集/ ,/ 使得/ 租户/ SLA/ 得到/ 满足/ 的/ 同时/ 最小化/ 缓存/ 资源/ 的/ 消耗/ ./ 通过/ 实验/ 分析/ 证明/ 了/ 该/ 缓存/ 管理机制/ 的/ 有效性/ ./ 关键词/ 共享/ 存储/ 架构/ ;/ 多/ 租户/ ;/ 缓存/ 管理/ ;/ SLA1/ 引言/ 软件/ 即/ 服务/ (/ SoftwareasaService/ ,/ SaaS/ )/ 是/ 一种/ 基于/ 互联网/ 的/ 服务/ 提供/ 模式/ 、/ 企业/ 或/ 个人/ 租赁/ 服务/ ,/ 并/ 通过/ Web/ 浏览器/ 或/ Web/ 客户端/ 访问/ 这个/ 服务/ ./ 在/ SaaS/ 模式/ 下/ ,/ 数据/ 存储/ 通常/ 采用/ 共享/ 数据库/ 共享/ 存储/ 架构/ [/ 1/ ]/ ,/ 从而/ 获取/ 规模/ 经济效益/ ,/ 如/ UniversalTable/ [/ 2/ -/ 3/ ]/ 、/ PivotTable/ 、/ ChunkFolding/ [/ 4/ ]/ 等/ ./ 这些/ 共享/ 存储/ 架构/ 各有/ 其/ 优缺点/ ,/ ChunkFolding/ 相比/ 于/ Page2UniversalTable/ 无/ 存储空间/ 的/ 大量/ 浪费/ ,/ 可/ 更好/ 地/ 支持/ 索引/ ,/ 查询/ 时/ 不/ 需要/ 处理/ 大量/ 的/ null/ 值/ 以及/ 数据类型/ 的/ 转换/ ;/ ChunkFolding/ 相比/ 于/ PivotTable/ 减少/ 了/ 存储/ 元/ 数据/ 和/ 业务/ 数据/ 的/ 比例/ ,/ 也/ 降低/ 了/ 重构/ 租户/ 逻辑/ 表/ 的/ 代价/ ./ 尽管/ ChunkFolding/ 对比/ 其它/ 共享/ 架构/ 具有/ 明显/ 的/ 优势/ ,/ 但/ 基于/ 传统/ 数据库/ 搭建/ 的/ 共享/ 存储/ 架构/ ,/ 仍然/ 存在/ 着/ 很多/ 的/ 不足/ ,/ 如/ 额外/ 的/ I/ // O/ 和/ 自然/ 连接/ [/ 4/ ]/ ,/ 而/ 文献/ [/ 4/ ]/ 指出/ I/ // O/ 是/ 主要/ 因素/ ./ 因此/ ,/ 如何/ 缓解/ I/ // O/ 导致/ 的/ 性能/ 下降/ 就/ 成为/ 改善/ ChunkFolding/ 共享/ 存储/ 架构/ 性能/ 的/ 关键/ ;/ 对于/ I/ // O/ 的/ 优化/ ,/ 传统/ 数据库/ 通常/ 采用/ 缓存数据/ 块/ 的/ 方式/ ,/ 但是/ 在/ 多/ 租户/ 共享/ 存储/ 架构/ 下/ ,/ 传统/ 数据库/ 的/ 缓存/ 管理机制/ 存在/ 以下/ 两点/ 不足之处/ :/ (/ 1/ )/ 传统/ 数据库/ 缓存/ 机制/ 以/ 数据/ 块/ 作为/ 缓存/ 单元/ ,/ 而/ 多/ 租户/ 共享/ 存储/ 架构/ 下/ ,/ 任一/ 数据/ 块/ 均/ 包含/ 了/ 大量/ 其他/ 租户/ 的/ 无关/ 数据/ ,/ 采用/ 数据/ 块/ 作为/ 缓存/ 单元/ 导致/ 大量/ 缓存/ 资源/ 的/ 浪费/ ./ (/ 2/ )/ 传统/ 数据库/ 缓存/ 机制/ 缺乏/ 多/ 租户/ 的/ 概念/ ,/ 对于/ 来自/ 租户/ 的/ 请求/ ,/ 传统/ 缓存/ 机制/ 会/ 从/ 提高/ 数据库/ 整体/ 性能/ 的/ 角度/ 进行/ 缓存/ 管理/ ,/ 这/ 就/ 会/ 导致/ 租户/ 间/ 资源分配/ 的/ 极为/ 不合理/ ,/ 如/ 高频/ 访问/ 租户/ 抢占/ 低频/ 访问/ 租户/ 的/ 资源/ ,/ 使得/ 低频/ 访问/ 租户/ 的/ SLA/ 响应/ 时间/ 需求/ 得不到/ 保障/ ./ 针对/ 以上/ 问题/ ,/ 本文/ 提出/ 了/ 一种/ 基于/ ChunkFolding/ 的/ 自/ 适应/ 的/ 多/ 租户/ 缓存/ 机制/ (/ Self/ -/ AdaptiveMulti/ -/ TenantMemoryManagement/ ,/ SAMTMM/ )/ ./ 对/ 每/ 一个/ 租户/ ,/ SAMTMM/ 适应/ 当前/ 的/ 租户/ 访问/ 模式/ ,/ 动态/ 生成/ 合理/ 的/ 候选/ 缓存/ 单元/ ,/ 并/ 计算/ 其/ 对应/ 的/ I/ // O/ 效益/ ,/ 然后/ 具备/ 最高/ 效益/ 率/ (/ 缓存/ 单元/ 的/ I/ // O/ 效益/ 与/ 缓存/ 单元/ 占据/ 内存大小/ 的/ 比值/ )/ 的/ 缓存/ 单元/ 被/ 选中/ 放入/ 缓存/ ,/ 重复/ 上述/ 过程/ 直到/ 满足/ 租户/ 的/ SLA/ 响应/ 时间/ 需求/ ./ 本文/ 将/ 上述/ 过程/ 形式化/ 定义/ 为/ 变种/ 的/ 背包/ 问题/ ,/ 并/ 采用/ 贪婪/ 算法/ 来/ 选择/ 缓存数据/ 集/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 3/ 节/ 基于/ ChunkFolding/ 共享/ 存储/ 架构/ 的/ 特性/ ,/ 给出/ 相应/ 的/ 代价/ 估计/ 模型/ ;/ 第/ 4/ 节/ 给出/ 多/ 租户/ 的/ 缓存/ 机制/ ;/ 第/ 5/ 节是/ 相应/ 的/ 实验/ 环境/ 和/ 实验/ 结果/ ;/ 最后/ 是/ 本文/ 的/ 总结/ ./ 2/ 相关/ 工作/ 数据库/ 缓存/ 作为/ 改善/ 数据库/ 性能/ 的/ 主要/ 因素/ ,/ 已经/ 被/ 广泛/ 的/ 研究/ [/ 5/ -/ 7/ ]/ ./ 文献/ [/ 5/ ]/ 给出/ 了/ 一种/ 自/ 调节/ 的/ 缓存/ 管理机制/ STMM/ ,/ 通过/ 为/ 不同/ 缓存/ 使用者/ (/ 如/ 排序/ 缓存/ 、/ Hash/ 连接/ 缓存/ 、/ 锁/ 缓存/ 、/ 缓冲/ 池等/ )/ 建立/ 缓存/ 消耗/ 和/ 时间/ 产出/ 效益/ 的/ 模型/ ,/ 从而/ 使得/ 不同/ 使用者/ 之间/ 有/ 了/ 统一/ 的/ 衡量标准/ ,/ 并/ 将/ 缓存/ 分配/ 给/ 产出/ 效益/ 大/ 的/ 使用者/ ,/ 以/ 达到/ 提高/ 系统/ 整体/ 性能/ 的/ 目的/ ;/ 与/ STMM/ 类似/ ,/ 文献/ [/ 6/ ]/ 通过/ 对/ 每/ 一/ 缓存/ 对象/ 定义/ BYHR/ ,/ 即/ 单位/ 字节/ 命中/ 产出率/ ,/ 选择/ 缓存/ 那些/ 高产出/ 的/ 缓存/ 对象/ 从而/ 利用/ 有限/ 的/ 缓存/ 资源/ 使得/ 网络/ 传输/ 代价/ 大幅度/ 减少/ ./ 文献/ [/ 7/ ]/ 提出/ 了/ Fragmentfencing/ 用于/ 解决/ 具有/ 明确/ QoS/ 需求/ 的/ 不同/ 类型/ 请求/ 的/ 缓存/ 分配/ 问题/ ,/ 以/ 达到/ 最小化/ 缓存/ 消耗/ 的/ 目的/ ./ 该/ 方案/ 假设/ 数据库/ 磁盘/ 块/ 有/ 统一/ 的/ 访问/ 频率/ ,/ 并/ 基于/ 简化/ 的/ 事务/ 模型/ :/ (/ 1/ )/ 事务/ 响应/ 时间/ 直接/ 与/ I/ // O/ 数目/ 相关/ ;/ (/ 2/ )/ 命中率/ 与/ 缓存/ 的/ 磁盘/ 块/ 的/ 数目/ 成正比/ ./ 如果/ 某/ 一类/ 请求/ 的/ 响应/ 时间/ 不/ 满足/ QoS/ 所/ 指定/ 的/ 响应/ 时间/ ,/ 则/ 通过/ 当前/ 已/ 分配/ 的/ 缓存/ 、/ 当前/ 响应/ 时间/ 与/ QoS/ 响应/ 时间/ 之间/ 的/ 线性/ 对应/ 关系/ 就/ 可以/ 计算/ 出为/ 满足/ QoS/ 响应/ 时间/ 所/ 需/ 分配/ 的/ 缓存/ 大小/ ./ 但是/ 在/ 多/ 租户/ 共享/ 存储/ 模式/ 下/ ,/ 不同/ 租户/ 的/ 数据共享/ 存储/ 在/ 某/ 一/ 磁盘/ 块/ 中/ ,/ 这/ 就/ 导致/ 单纯/ 以/ 磁盘/ 块/ 数目/ 而/ 不/ 考虑/ 磁盘/ 块/ 的/ 数据/ 内容/ 作为/ 衡量/ 缓存/ 命中率/ 指标/ 的/ 假设/ 存在/ 着/ 不合理性/ ./ 随着/ 云/ 计算/ 的/ 兴起/ ,/ 传统/ 数据库/ 的/ 缓存/ 管理机制/ 存在/ 着/ 不足之处/ [/ 8/ ]/ ./ 首先/ ,/ 租户/ 间/ 对/ 共享/ 缓存/ 资源/ 的/ 竞争/ 会/ 导致/ 每一/ 租户/ 获取/ 的/ 缓存/ 资源/ 不足以/ 缓存/ 其/ 数据/ ,/ 从而/ 导致/ 低/ 的/ 缓存/ 命中率/ 和/ 不好/ 的/ 用户/ 体验/ ./ 其次/ ,/ 对于/ 缺乏/ 多/ 租户/ 特性/ 的/ 共享/ 缓存/ 管理策略/ (/ LFU/ 、/ LRU/ )/ 将会/ 倾向/ 于/ 将/ 缓存/ 分配/ 给/ 具备/ 更高/ 请求/ 速率/ 的/ 租户/ ,/ 从而/ 导致/ 低/ 请求/ 速率/ 租户/ 的/ 缓存/ 命中率/ 极低/ ./ 据此/ ,/ 文献/ [/ 8/ ]/ 指出/ 在/ 云/ 计算环境/ 下/ 将/ 缓存/ 作为/ 云/ 服务/ 的/ 重要性/ 并/ 讨论/ 了/ 云/ 缓存/ 服务/ 的/ 系统/ 原型/ Blaze/ ,/ Blaze/ 迭代/ 地/ 将/ 缓存/ 分配/ 给/ 具有/ 最大/ 收益/ 的/ 租户/ 并/ 采用/ 基于/ CLOCK/ 的/ 多/ 租户/ 缓存/ 替换/ 策略/ ,/ 保证/ 租户/ 的/ SLA/ 同时/ 最大化/ 系统/ 性能/ ./ 针对/ 共享/ 存储/ 模式/ 下/ ,/ 传统/ 磁盘/ 和/ 缓存/ 管理策略/ 在/ 处理/ 不同/ 服务/ 访问/ 模式/ 时/ 显著/ 的/ 性能/ 下降/ 问题/ ,/ Argon/ [/ 9/ ]/ 采用/ 预取/ // 回写/ 技术/ 、/ 缓存/ 划分/ 和/ 量化/ 磁盘/ 时间/ 调度/ 3/ 种/ 机制/ 使得/ 每一/ 服务/ 达到/ 预期/ 的/ 有效性/ 指标/ (/ 相对/ 于/ 独立/ 运行/ 时/ 的/ 效率/ 比值/ )/ ,/ 使得/ 磁盘/ 服务/ 的/ 有效性/ 得到/ 显著/ 提高/ ,/ 其中/ 预取/ // 回写/ 技术/ 以及/ 量化/ 磁盘/ 时间/ 调度/ 与/ 本文/ 的/ 研究/ 互补/ ,/ 可以/ 很/ 好/ 的/ 与/ 本文/ 的/ 多/ 租户/ 缓存/ 管理策略/ 相结合/ ./ 在/ 服务/ 间/ 的/ 缓存/ 划分/ 上/ ,/ Argon/ 需要/ 建立/ 独立/ 执行/ 模式/ 下/ 缓存/ 空间/ 与/ I/ // O/ 产出/ 效益/ 间/ 的/ 对应/ 函数/ 关系/ ,/ 其建/ Page3/ 立/ 过程/ 时间/ 较长/ ,/ 而/ 本文/ 的/ SAMTMM/ 不/ 需要/ 建立/ 此/ 函数/ 关系/ ,/ 因此/ 没有/ 准备/ 阶段/ 的/ 资源/ 消耗/ ,/ 可以/ 更好/ 地/ 适应/ 在线/ 调整/ ;/ 此外/ ,/ Argon/ 关注/ 的/ 是/ 服务/ 间/ 的/ 存储/ 共享/ ,/ 而/ 本文/ 关注/ 的/ 是/ 服务/ 内/ 租户/ 间/ 的/ 存储/ 共享/ ,/ 共享/ 粒度/ 的/ 不同/ 导致/ 磁盘/ 数据组织/ 形式/ 的/ 不同/ ,/ 因此/ Argon/ 并/ 不/ 直接/ 适用/ 于/ SaaS/ 模式/ 下/ 的/ 多/ 租户/ 数据库/ 缓存/ 管理/ ./ 与/ Argon/ 不同/ ,/ 文献/ [/ 10/ ]/ 采用/ 曲线拟合/ 建立/ 每一/ 服务/ 缓存/ 与/ 命中率/ (/ I/ // O/ 产出/ 效益/ )/ 之间/ 的/ 函数/ 关系/ ,/ 动态/ 地为/ 每/ 一/ 服务/ 分配/ 缓存/ 空间/ ,/ 满足/ 每一/ 服务/ QoS/ 的/ 同时/ 尽可能/ 地/ 提高/ 系统/ 的/ 整体/ 缓存/ 命中率/ ;/ 文献/ [/ 11/ ]/ 提出/ 了/ 相对/ 分化/ 缓存/ 服务/ 模型/ ,/ 采用/ 基于/ 回馈/ 的/ 启发式/ 缓存/ 分配/ 策略/ 动态/ 调整/ 每/ 一类/ 请求/ 所/ 获取/ 的/ 缓存/ 大小/ 从而/ 实现/ 不同/ 类别/ 请求/ 的/ 缓存/ 命中/ 相对/ 比/ ./ 它们/ 均/ 不/ 需要/ Argon/ 中/ 建立/ 缓存/ 空间/ 与/ I/ // O/ 产出/ 效益/ 函数/ 的/ 准备/ 阶段/ 的/ 资源/ 消耗/ ,/ 因而/ 能够/ 快速/ 地/ 适应/ 访问/ 模式/ 的/ 变化/ 并/ 进行/ 在线/ 调整/ ./ 但是/ 与/ 本文/ 不同/ ,/ 文献/ [/ 10/ ]/ 关注/ 的/ 是/ 软/ QoS/ ,/ 而/ 文献/ [/ 11/ ]/ 中/ 缓存/ 分配/ 的/ 最终/ 优化/ 目标/ 是/ 满足/ 不同/ 类型/ 请求/ 所/ 指定/ 的/ QoS/ 比值/ ,/ 而/ 不是/ 满足/ 其/ QoS/ ,/ 这/ 与/ 本文/ 多/ 租户/ 缓存/ 管理机制/ 中/ 的/ SLA/ 响应/ 时间/ 存在/ 着/ 需求/ 上/ 的/ 差异/ ./ 在/ 缓存/ 替换/ 策略/ 方面/ ,/ 常用/ 的/ 缓存/ 替换算法/ 有/ LRU/ 、/ LFU/ 和/ LRU/ -/ K/ [/ 12/ ]/ 等/ ./ 这些/ 算法/ 通常/ 以/ 页面/ 作为/ 替换/ 单元/ ,/ 并/ 采用/ 引用/ 流/ 作为/ 单一/ 的/ 评价/ 页面/ 缓存/ 的/ 标准/ ,/ 从而/ 最小化/ 页面/ 缺失/ 率/ ;/ 其中/ 最为/ 常用/ 的/ 为/ LRU/ ,/ 因为/ 它/ 易于/ 实现/ 并且/ 时间/ 复杂度/ 不高/ ,/ 但是/ 其/ 存在/ 许多/ 不足/ ,/ 如/ 读取/ 一系列/ 的/ 不/ 经常/ 使用/ 的/ 页面/ ,/ 则/ 经常/ 被/ 引用/ 的/ 页面/ 就/ 会/ 从/ 缓存/ 中/ 驱逐/ 出去/ ,/ 这/ 就/ 导致/ 了/ 缓冲/ 池/ 污染/ ./ 针对/ 这一/ 问题/ ,/ 许多/ 基于/ LRU/ 改进/ 的/ 算法/ 被/ 提出/ ,/ 如/ LRU/ -/ K/ 算法/ ,/ 该/ 算法/ 跟踪/ 最后/ 一次/ 对/ 页面/ 进行/ K/ 引用/ 的/ 时间/ ,/ 并/ 按/ 该/ 信息/ 对/ 页面/ 进行/ 排序/ ;/ 当/ 需要/ 读进/ 新/ 的/ 页面/ 时/ ,/ 则/ 根据/ 缓存/ 页面/ 的/ 等级/ 剔除/ 等级/ 低/ 的/ 页面/ 从而/ 防止/ 缓存/ 池/ 被/ 污染/ ;/ 与/ LRU/ -/ K/ 极为/ 类似/ ,/ MySQL/ // InnoDB/ 采用/ 带有/ 中/ 点/ 策略/ 的/ LRU/ 替换/ 策略/ [/ 13/ ]/ ,/ 该/ 策略/ 的/ LRU/ 缓冲/ 池/ 链表/ 中/ 包括/ 新/ 链表/ 和/ 旧/ 链表/ ,/ 对/ 每/ 一个/ 读进/ 缓存/ 的/ 新页面/ ,/ 他们/ 均/ 被/ 放在/ 新/ 链表/ 中/ ,/ 当且/ 仅/ 当/ 规定/ 的/ 时间/ 内该/ 页面/ 再次/ 被/ 访问/ ,/ 那么/ 该/ 数据/ 块/ 才/ 会/ 被/ 放入/ 旧/ 链表/ 中/ ;/ 目前/ 这些/ 成熟/ 的/ 缓存/ 替换算法/ 均/ 采用/ 页面/ 作为/ 缓存/ 单元/ ,/ 但是/ 未/ 考虑/ SaaS/ 共享/ 存储/ 架构/ 下以/ 页面/ 作为/ 替换/ 单元/ 存在/ 着/ 缓存/ 浪费/ ,/ 而/ 如何/ 给出/ 适应/ 共享/ 架构/ 的/ 缓存/ 单元/ 也/ 并未/ 被/ 深入研究/ ./ 3/ 多/ 租户/ 缓存/ 管理/ 的/ 理论/ 基础/ 本节/ 将/ 介绍/ 与/ 多/ 租户/ 缓存/ 管理/ 相关/ 的/ 理论/ 基础/ ,/ 为/ 下/ 一节/ 基于/ I/ // O/ 价值/ 的/ 动态/ 缓存/ 单元/ 的/ 多/ 租户/ 缓存/ 管理机制/ 做/ 铺垫/ ./ 首先/ 给出/ ChunkFolding/ 和/ 租户/ 访问/ 模式/ 的/ 简化/ 模型/ ,/ 然后/ 结合/ ChunkFolding/ 共享/ 存储/ 架构/ 的/ 特性/ 及/ MySQL/ 的/ 查询/ 优化/ 器/ 给出/ 其/ 执行/ 计划/ 模型/ ;/ 最后/ 结合/ 该/ 执行/ 计划/ 模型/ 给出/ 计算/ 任意/ 请求/ 的/ I/ // O/ 次数/ 的/ 公式化/ 定义/ ./ 3.1/ ChunkFolding/ 及/ 租户/ 访问/ 模式/ ChunkFolding/ 预定/ 义/ 一系列/ 适当/ 模式/ 的/ Chunk/ 表/ ,/ 其中/ 预定/ 义/ 的/ Chunk/ 表/ 的/ 每/ 一/ 属性/ 列均/ 有/ 明确/ 的/ 数据类型/ ./ 对/ 租户/ 个性化/ 定制/ 后/ 的/ 逻辑/ 表/ ,/ ChunkFolding/ 采用/ 列/ 划分/ 技术/ ,/ 将/ 其/ 存储/ 到/ 与其/ 结构/ 最为/ 相近/ 的/ 若干/ Chunk/ 表中/ ./ 其中/ ,/ 基本/ 表/ 的/ 两个/ 元/ 数据/ 列/ (/ Tenant/ ,/ Row/ )/ 和/ Chunk/ 表/ 的/ 4/ 个元/ 数据/ 列/ (/ Tenant/ ,/ Table/ ,/ Chunk/ ,/ Row/ )/ 用于/ 还原/ 租户/ 的/ 逻辑/ 表/ ,/ 此外/ 为了/ 加速/ 查询/ 速度/ ,/ 在/ 元/ 数据/ 列/ 上/ 建立/ 组合/ 索引/ TR/ 和/ TTCR/ ./ 例/ 1/ ./ 设有/ 一个/ CRM/ 管理系统/ ,/ 其/ 基本/ 表/ 信息/ 包括/ 身份证/ 和/ 姓名/ ,/ 即/ CRM/ (/ id/ ,/ name/ )/ ,/ 设有/ 3/ 个/ 租户/ 其/ ID/ 为/ 1/ 、/ 2/ 、/ 3/ ,/ 租户/ 1/ 未/ 定制/ 字/ 段/ ,/ 租户/ 2/ 定制/ 了/ 邮编/ 字/ 段/ ,/ 租户/ 3/ 定制/ 了/ 年龄/ 和/ 家庭/ 住址/ 字段/ ./ 3/ 个/ 租户/ 的/ 逻辑/ 模式/ 如图/ 1/ (/ a/ )/ 所示/ ,/ 预定/ 义/ 的/ ChunkFolding/ 表/ 模式/ 为/ CRMbase/ 和/ CRMchunk/ 模式/ ,/ 其/ 对应/ 的/ 共享/ 存储/ 架构/ 如图/ 1/ (/ b/ )/ 所示/ ,/ 其中/ 灰色/ 的/ 属性/ 列是/ 元/ 数据/ 列/ ./ 为/ 方便/ 问题/ 阐述/ ,/ 我们/ 将/ 不再/ 区分/ 基本/ 表与/ Chunk/ 表/ ,/ 即/ 基本/ 表与/ Chunk/ 表均/ 包含/ 4/ 个元/ 数据/ 列/ (/ Tenant/ ,/ Table/ ,/ Chunk/ ,/ Row/ )/ 和/ 组合/ 索引/ TTCR/ ./ 图/ 1/ 租户/ 逻辑/ 模式/ 与/ ChunkFolding/ 映射/ 关系/ 为/ 方便/ 我们/ 接下来/ 的/ 问题/ 描述/ ,/ 我们/ 将/ 给出/ ChunkFolding/ 的/ 形式化/ 定义/ ./ 设/ 逻辑/ 表/ R/ ,/ 其/ 属性/ 集/ A/ =/ {/ A1/ ,/ A2/ ,/ …/ ,/ An/ }/ ,/ C/ =/ {/ C1/ ,/ C2/ ,/ …/ ,/ Cm/ }/ 是/ 采用/ ChunkFolding/ 共享/ 存储/ 架构/ 后台/ 预定/ 义/ 的/ ChunkPage4/ 表/ ,/ 则/ 逻辑/ 表/ R/ 与/ 后台/ ChunkFolding/ 的/ 对应/ 模式/ 映射/ 信息/ 定义/ 如下/ ./ 定义/ 1/ ./ 映射/ 关系/ ./ 逻辑/ 到/ 物理/ α/ :/ Ai/ →/ (/ Cj/ ,/ k/ )/ ./ 表示/ 关系/ R/ 的/ 属性/ Ai/ 位于/ 后台/ Cj/ 块/ 内/ ,/ 且/ 为/ 其/ 分配/ 的/ 全局/ 唯一/ 编号/ 为/ k/ ./ 物理/ 到/ 逻辑/ β/ :/ (/ Cj/ ,/ k/ )/ →/ {/ Ai/ ,/ …/ ,/ Ai/ +/ p/ }/ 用于/ 获取/ 编号/ 为/ k/ 的/ 数据/ 块/ Cj/ 所/ 包含/ 的/ 属性/ 集合/ ./ 服务/ 运营商/ 可以/ 跟踪/ 一段时间/ 内/ 租户/ 发起/ 的/ 数据库/ 访问/ 来/ 获取/ 租户/ 访问/ 模式/ ,/ 我们/ 将/ 其/ 建模/ 为/ 一个/ 有序/ 对/ (/ q/ ,/ wq/ )/ ,/ q/ =/ 1/ ,/ …/ ,/ Q/ ./ 其中/ q/ 代表/ 第/ q/ 个/ 请求/ ,/ wq/ 是/ 第/ q/ 个/ 请求/ 的/ 频率/ ./ 需要/ 注意/ 的/ 是/ 这里/ 的/ Q/ 个/ 请求/ 都/ 是非/ 事务/ 型/ 的/ ,/ 但/ SaaS/ 是/ 面向/ 事务/ 型/ 的/ 应用/ ,/ 所以/ 会/ 包括/ 事务/ 型/ 的/ 请求/ ./ 对于/ 事务/ 型/ 请求/ 我们/ 采用/ 重写/ 逻辑/ [/ 4/ ]/ ,/ 将/ 其/ 分为/ 两个/ 阶段/ :/ (/ a/ )/ 查询/ 阶段/ ./ 收集/ 所有/ 满足/ 更新/ 条件/ 的/ 行号/ (/ 即元/ 数据/ 列/ ,/ Tenant/ ,/ Table/ ,/ Chunk/ ,/ Row/ )/ ./ (/ b/ )/ 更新/ 阶段/ ./ 更新/ 满足/ 更新/ 条件/ 的/ 行所/ 对应/ 的/ 更新/ 列/ ./ 由于/ 数据库/ 缓存/ 机制/ 只会/ 减少/ 读/ 操作/ 的/ I/ // O/ 次数/ ,/ 而/ 并/ 不能/ 减少/ 写/ 操作/ 的/ I/ // O/ 次数/ (/ 可/ 通过/ 延迟/ 写/ ,/ 日志/ 记录/ )/ ,/ 所以/ 本文/ 将/ 只/ 考虑/ 事务/ 型/ 请求/ 的/ 阶段/ (/ a/ )/ 的/ I/ // O/ 代价/ ,/ 而/ 通过/ 减少/ 阶段/ (/ a/ )/ 的/ I/ // O/ 代价/ 也/ 可以/ 显著/ 提高/ 事务/ 型/ 请求/ 的/ 处理/ 效率/ ./ 简单/ 起/ 见/ ,/ 本文/ 剩下/ 的/ 部分/ 所有/ 的/ 请求/ 集/ 除非/ 特别/ 说明/ ,/ 将/ 都/ 是非/ 事务/ 型/ 的/ ./ 3.2/ 执行/ 计划/ 为/ 执行/ 一个/ 请求/ ,/ 查询/ 优化/ 器/ 需要/ 生成/ 所有/ 的/ 图/ 2MySQL/ 基于/ 嵌套/ 索引/ 的/ 左/ 深树/ 执行/ 计划/ 验证/ 执行/ 计划/ ,/ 然后/ 选择/ 代价/ 最小/ 的/ 执行/ 表/ 访问/ ./ 主要/ 有/ 两种/ 表/ 扫描/ 方式/ :/ 顺序/ 扫描/ 和/ 索引/ 扫描/ ./ 索引/ 扫描/ 不/ 需要/ 扫描/ 整个/ 表/ ,/ 而/ 只/ 需要/ 访问/ 满足条件/ 的/ 元组/ 所属/ 的/ 磁盘/ 块/ 即可/ ./ 使用/ 索引/ 扫描/ 需要/ 满足/ 两个/ 条件/ :/ (/ 1/ )/ 在/ 对应/ 的/ 查询/ 中有/ 索引/ 可用/ ,/ (/ 2/ )/ 满足条件/ 的/ 元组/ 的/ 数目/ 远/ 小于/ 表中/ 所有/ 元组/ 的/ 数目/ [/ 14/ -/ 15/ ]/ ./ 本文/ 的/ 代价/ 估计/ 是/ 基于/ 嵌套/ 索引/ 的/ 左/ 深树/ 执行/ 计划/ 来/ 进行/ 计算/ 的/ ,/ 理由/ 如下/ :/ (/ 1/ )/ ChunkFolding/ 共享/ 架构/ 下/ 的/ 所有/ 请求/ 都/ 需要/ 被/ 重写/ 添加/ 上/ 元/ 数据/ 列/ [/ 4/ ]/ ,/ 而元/ 数据/ 列上/ 均/ 建立/ 了/ 组合/ 索引/ TTCR/ ,/ 因此/ 有/ 索引/ 可用/ ./ (/ 2/ )/ ChunkFolding/ 共享/ 架构/ 下/ Chunk/ 表中/ 存储/ 了/ 成千上万/ 租户/ 的/ 数据/ ,/ 对于/ 特定/ 租户/ 特定/ 表/ 的/ 查询/ ,/ 满足条件/ 的/ 元组/ 的/ 数目/ 相对/ 于/ Chunk/ 表中/ 的/ 元组/ 的/ 总/ 数目/ 而言/ 很少/ ./ (/ 3/ )/ MySQL/ 的/ 查询/ 优化/ 器/ 的/ 执行/ 计划/ 都/ 是/ 基于/ 左深树/ 的/ 代价/ 估计/ [/ 16/ ]/ ,/ 对于/ 其它/ 数据库/ 的/ 代价/ 估计/ 则/ 需要/ 配合/ 与/ 对应/ 的/ 查询/ 优化/ 器/ 相结合/ 从而/ 得出/ 相应/ 的/ I/ // O/ 代价/ 估计/ ./ (/ 4/ )/ 本文/ 关注/ 的/ 重点/ 是/ 缓存/ 管理机制/ ,/ 所以/ 我们/ 尽量避免/ 由/ 执行/ 计划/ 选择/ 上/ 的/ 不确定性/ 因素/ 导致/ 的/ 缓存/ 单元/ I/ // O/ 代价/ 估计/ 的/ 不/ 准确/ ./ 因此/ ,/ 本文/ 中/ 的/ 所有/ 请求/ 均/ 事先/ 经过/ MySQL/ 的/ analyze/ // explain/ 命令/ 进行/ 执行/ 计划/ 的/ 验证/ ,/ 从而/ 保证/ 了/ 代价/ 估计/ 的/ 准确性/ ,/ 其/ 验证/ 过程/ 如图/ 2/ 所示/ ./ Page5/ 图/ 2/ 中/ 我们/ 以/ 典型/ 的/ TPC/ -/ W/ 中/ 的/ 查看/ 产品/ 信息/ 请求/ 作为/ 示例/ ,/ 其中/ 的/ 逻辑/ 模式/ 与/ 后台/ ChunkFolding/ 物理模式/ 的/ 映射/ 关系/ 见/ 5.2/ 节/ ./ 从图/ 2/ 中/ MySQL/ 查询/ 优化/ 器/ 的/ 执行/ 过程/ 我们/ 可以/ 得出/ ,/ Chunk/ 表/ 的/ 访问/ 以及/ 表/ 间连接/ 是/ 基于/ 索引/ 的/ (/ 对应/ table/ ,/ type/ 列/ )/ ,/ 而且/ 每一/ Chunk/ 表/ 的/ 访问/ 均/ 采用/ TTCR/ 索引/ (/ 对应/ key/ 列/ )/ ,/ 并/ 利用/ 过滤/ 后/ 的/ TTCR/ 作为/ 访问/ 下/ 一/ Chunk/ 表/ 的/ 条件/ (/ 对应/ ref/ 列/ )/ ,/ 依次/ 类推/ ,/ 该/ 过程/ 是/ 一个/ 典型/ 的/ 基于/ 嵌套/ 索引/ 扫描/ 的/ 左/ 深树/ 执行/ 计划/ ./ 为/ 进一步/ 验证/ 对/ 执行/ 计划/ 假设/ 的/ 正确性/ ,/ 我们/ 分别/ 测试/ 了/ 相同/ 租户/ 数目/ 不同/ 规模/ (/ 租户/ )/ 数据/ 集下/ 查询/ 优化/ 器/ 的/ 执行/ 过程/ ,/ 结果显示/ 与/ 图/ 2/ 类似/ ./ 图/ 3/ 给出/ 了/ 基于/ 嵌套/ 索引/ 扫描/ 的/ 左/ 深树/ 的/ MySQL/ 执行/ 计划/ 图/ ,/ 该/ 执行/ 计划/ 共/ 涉及/ 到/ 3/ 个/ Chunk/ 表/ ./ 图中/ IXSCAN/ 表示/ Chunk/ 表/ 的/ 访问/ 采用/ 索引/ 扫描/ 的/ 方式/ ,/ TTCR/ 代表/ 使用/ 的/ 索引/ (/ Tenant/ ,/ Table/ ,/ Chunk/ ,/ Row/ )/ ,/ Fetch/ 操作/ 用于/ 访问/ Chunk/ 表/ 从而/ 取得/ 对应/ 元组/ 的/ 相关/ 的/ 属性/ 列/ ,/ NLJOIN/ 表示/ 采用/ 嵌套/ 索引/ 扫描/ 的/ 方式/ ./ 对于/ 每/ 一个/ 请求/ ,/ 本文/ 中/ 我们/ 主要/ 考虑/ I/ // O/ 代价/ ,/ 也/ 即/ 每/ 一个/ 虚线/ 框内/ 的/ I/ // O/ 代价/ 之/ 和/ ,/ 其中/ 一个/ 虚/ 线框/ 代表/ 的/ 是/ 访问/ 一个/ Chunk/ 的/ 代价/ ./ 图/ 3MySQL/ 基于/ 嵌套/ 索引/ 的/ 左/ 深树/ 执行/ 计划/ 示意图/ 3.3/ I/ // O/ 代价/ 估计/ 从图/ 3/ 所示/ 的/ 执行/ 计划/ 示意图/ 我们/ 可以/ 得出/ ,/ 对于/ 一个/ 请求/ ,/ 其/ I/ // O/ 代价/ 为/ 所有/ 虚线/ 框内/ 的/ FETCH/ 操作/ 磁盘/ I/ // O/ 次数/ 与/ 每/ 一次/ I/ // O/ 花费/ 时间/ 乘积/ 之/ 和/ ;/ 对于/ 索引/ 扫描/ ,/ FETCH/ 操作/ 的/ I/ // O/ 次数/ 与/ 这个/ 数据/ 块/ 被/ 访问/ 时/ 满足条件/ 的/ 元组/ 数目/ 关系/ 很/ 密切/ ,/ 我们/ 设/ 第/ i/ 个/ Chunk/ 被/ 扫描/ 时/ ,/ 符合条件/ 的/ 元组/ 的/ 数目/ 为/ ki/ ,/ 基于/ 文献/ [/ 14/ -/ 15/ ]/ 给出/ 的/ 公式/ 有/ 第/ i/ 个/ Chunk/ 被/ 扫描/ 时/ 需要/ 的/ I/ // O/ 次数/ 即为/ E/ (/ IOi/ )/ =/ mi/ ×/ 1/ -/ Ckinid/ 在/ 函数/ (/ 1/ )/ 中/ ,/ mi/ 表示/ 第/ i/ 个/ Chunk/ 占据/ 的/ 磁盘空间/ 对应/ 的/ 数据库/ 逻辑/ 页面/ 的/ 数目/ ,/ ni/ 表示/ 第/ i/ 个/ Chunk/ 中/ 的/ 元组/ 的/ 数目/ ./ 对于/ 一个/ 请求/ ,/ 如果/ 没有/ 任何/ 数据/ 被/ 缓存/ ,/ 则/ 其/ 需要/ 的/ 磁盘/ I/ // O/ 次数/ 为/ 所有/ Chunk/ 的/ I/ // O/ 次数/ 之/ 和/ ,/ 即/ 其中/ d/ 是/ 查询/ 中/ 涉及/ 到/ 的/ Chunk/ 的/ 数目/ ;/ 如果/ 某一/ FETCH/ 操作/ 所/ 涉及/ 的/ 属性/ 集/ 刚好/ 全在/ 缓存/ 中/ ,/ 则/ 对应/ 的/ FETCH/ 操作/ 的/ I/ // O/ 次数/ 为/ 0/ ./ 通过/ 式/ (/ 1/ )/ 和/ (/ 2/ )/ 我们/ 可以/ 计算/ 出/ 任意/ 一个/ 请求/ 所/ 需/ 的/ I/ // O/ 次数/ ,/ 接下来/ 我们/ 将/ 给出/ 如何/ 计算/ 每/ 一次/ I/ // O/ 的/ 时间/ ./ 本文/ 将/ 借鉴/ 文献/ [/ 17/ ]/ 给出/ 的/ 在/ 随机/ 请求/ 情况/ 下/ 的/ 磁盘/ 驱动/ 模型/ 来/ 计算/ 一次/ I/ // O/ 的/ 时间/ ,/ 其/ 对应/ 的/ 所/ 需要/ 的/ 设备/ 参数/ 和/ 数据库/ 参数/ 如表/ 1/ 所示/ ./ 采用/ 随机/ 请求/ 下/ 的/ I/ // O/ 时间/ 估计/ 是/ 由于/ 在/ 共享/ 存储/ 模式/ 下/ ,/ 租户/ 间/ 的/ 数据/ 相互/ 交叉/ 存储/ ,/ 因此/ 每一/ 租户/ 的/ 数据/ 在/ 磁盘/ 上/ 的/ 分布/ 是/ 分散/ 的/ ,/ 查询/ 中/ 所/ 涉及/ 的/ 元组/ 在/ 磁盘/ 上/ 的/ 位置/ 呈现出/ 随机/ 分布/ 的/ 状况/ ./ 表/ 1/ 计算/ 一次/ I/ // O/ 平均/ 时间/ 所/ 需/ 的/ 设备/ 参数/ 单面/ 磁盘/ 磁道/ 数/ L/ 磁道/ i/ 的/ 扇区/ 数/ Ci/ 单/ 盘面/ 的/ 扇区/ 数/ M/ 磁盘/ 转速/ 短寻道/ 磁道/ 上界/ Q/ 扇区/ 大小/ DB/ 数据/ 块/ 大小/ P/ 一次/ I/ // O/ 所/ 需要/ 的/ 时间/ 主要/ 包括/ 寻/ 道/ 时间/ 、/ 旋转/ 等待/ 和/ 传输/ 时间/ 3/ 个/ 部分/ ,/ 因此/ 一次/ I/ // O/ 的/ 平均/ 时间/ 等于/ 平均/ 寻/ 道/ 时间/ 、/ 平均/ 旋转/ 等待/ 和/ 平均/ 传输/ 时间/ 之/ 和/ ,/ 即/ 寻道/ 时间/ 与/ 寻道/ 长度/ d/ 有关/ ,/ 其/ 对应/ 的/ 计算公式/ 如下/ :/ 式/ (/ 4/ )/ 给出/ 了/ 寻道/ 距离/ 为/ d/ 的/ 寻道/ 时间/ ,/ 平均/ 寻/ 道/ 时间/ 则/ 假设/ 磁头/ 以/ 相同/ 的/ 概率/ 位于/ 每一/ 磁道/ 上/ ,/ 也/ 即/ 1/ // L/ ,/ 那么/ 以/ 任意/ 磁道/ 作为/ 起点/ 的/ 平均/ 寻/ 道/ 时间/ 之/ 和/ 为/ 平均/ 寻/ 道/ 时间/ ./ 因此/ ,/ Costseek/ =/ ∑/ LPage6/ 平均/ 旋转/ 等待时间/ 是/ 磁盘/ 旋转/ 半周/ 的/ 时间/ ,/ 因此/ ,/ 平均/ 传输/ 时间/ 等于/ 磁道/ 被/ 访问/ 的/ 概率/ 与/ 对应/ 磁道/ 读取/ 单个/ 数据库/ 数据/ 块/ 所/ 需/ 时间/ 代价/ 的/ 乘积/ 之/ 和/ ,/ 因此/ ,/ Costtransfer/ =/ ∑/ L4/ 多/ 租户/ 缓存/ 管理机制/ 在/ 多/ 租户/ 环境/ 下/ ,/ 分配/ 较/ 多/ 的/ 缓存/ 给/ 一个/ 租户/ 可以/ 减少/ 该/ 租户/ 的/ I/ // O/ 次数/ ,/ 但是/ 留给/ 其他/ 租户/ 的/ 缓存/ 就/ 会/ 不足/ ;/ 分配/ 较/ 少/ 缓存/ 给/ 一个/ 租户/ 则/ 会/ 导致/ 该/ 租户/ 的/ I/ // O/ 次数/ 增多/ ,/ 留给/ 其他/ 租户/ 的/ 缓存/ 量会/ 相对/ 充裕/ ./ 在/ 本节/ 我们/ 将/ 给出/ 适应/ 租户/ 访问/ 模式/ 的/ 多/ 租户/ 缓存/ 分配/ 策略/ ,/ 该/ 策略/ 为/ 每/ 一个/ 租户/ 分配/ 保障/ 其/ SLA/ 响应/ 时间/ 需求/ 的/ 尽量少/ 的/ 缓存/ ,/ 从而/ 尽可能/ 多/ 的/ 缓存/ 可/ 被/ 留给/ 其他/ 租户/ ./ 4.1/ 基于/ 租户/ 访问/ 模式/ 的/ 缓存/ 单元/ 及/ 犚/ 犗/ 犆/ 值/ 计算/ 传统/ 数据库/ 的/ 缓存/ 单元/ 通常/ 是/ 一个/ 数据库/ 逻辑/ 页/ ,/ 但是/ 在/ SaaS/ 多/ 租户/ 共享/ 存储/ 架构/ 中/ ,/ 以/ 数据库/ 逻辑/ 页/ 作为/ 缓存/ 单元/ 存在/ 诸多/ 的/ 不合理性/ ,/ 如/ :/ (/ 1/ )/ 多个/ 租户/ 的/ 数据/ 分散/ 存储/ 在/ 一个/ 共享/ 架构/ 中/ ,/ 一个/ 数据库/ 逻辑/ 页/ 中会/ 包含/ 大量/ 其他/ 租户/ 的/ 无用/ 数据/ ,/ 仅仅/ 出于/ 一个/ 租户/ 的/ 性能/ 考虑/ 而/ 缓存/ 整个/ 数据库/ 逻辑/ 页/ ,/ 导致/ 大量/ 缓存/ 空间/ 的/ 浪费/ ;/ (/ 2/ )/ 在/ SaaS/ 中/ 的/ 服务/ 请求/ 均/ 是/ 基于/ Web/ 提交/ 的/ ,/ 而/ Web/ 页面/ 的/ 访问/ 遵从/ Zipf/ 分布/ ,/ 即仅/ 有/ 20/ %/ 的/ 请求/ 是/ 经常/ 被/ 使用/ 的/ ,/ 而/ 这些/ 请求/ 都/ 是/ 基于/ HTML/ 模板/ 提交/ 的/ ,/ 变化/ 的/ 只有/ 参数/ ,/ 这/ 就/ 说明/ 某/ 几个/ 属性/ 列/ 被/ 经常/ 使用/ [/ 18/ ]/ ,/ 也/ 就/ 意味着/ 采用/ 元组/ 作为/ 缓存/ 单元/ 同样/ 有/ 其/ 不合理性/ ./ 出于/ 上述/ 两点/ 问题/ 的/ 考虑/ ,/ 本文/ 采用/ 列/ 缓存/ 代替/ 传统/ 数据库/ 的/ 页/ 缓存/ ;/ 传统/ 数据库/ 的/ 页/ 缓存/ 机制/ 中以/ 固定/ 页/ 作为/ 缓存/ 单元/ ,/ 而/ 在/ 我们/ 的/ 列/ 缓存/ 中/ ,/ 我们/ 采用/ 动态/ 生成/ 的/ 列/ 属性/ 集/ 作为/ 缓存/ 单元/ ,/ 我们/ 称为/ 列/ 缓存/ 单元/ ./ 对于/ 一个/ 涉及/ n/ 个/ 属性/ 的/ 请求/ 集/ ,/ 则/ 其/ 备选/ 列/ 缓存/ 单元/ 数目/ 为/ 2n/ ,/ 如果/ 考虑/ 所有/ 的/ 备选/ 列/ 缓存/ 单元/ ,/ 则/ 代价/ 很/ 高/ ./ 文献/ [/ 19/ ]/ 提出/ 了/ 基于/ 访问/ 模式/ 驱动/ 的/ 缓存/ 单元/ 生成/ 策略/ ,/ 以/ 当前/ 的/ 访问/ 模式/ 作为/ 输入/ ,/ 输出/ 一系列/ 缓存/ 单元/ ./ QueryAccessSet/ (/ QAS/ )/ 这个/ 概念/ 在/ 文献/ [/ 19/ ]/ 中/ 被/ 使用/ ,/ 它/ 被/ 定义/ 为/ 一个/ 关系/ 中/ 被/ 某个/ 请求/ 访问/ 的/ 属性/ 的/ 集合/ ./ 借鉴/ 该/ 思路/ ,/ 结合/ ChunkFolding/ 特性/ ,/ 我们/ 给出/ QAS/ 的/ 重新/ 定义/ ,/ 并/ 将/ QAS/ 作为/ 初始/ 候选/ 缓存/ 单元/ 从而/ 大幅/ 减少/ 备选/ 缓存/ 单元/ 的/ 数量/ ./ 定义/ 2/ ./ QueryAccessSet/ (/ QAS/ )/ ./ QAS/ 或者/ 是/ 一个/ 查询/ 中/ 的/ 谓词/ 集/ (/ PredicateSet/ ,/ PS/ )/ ,/ 或者/ 是/ 一个/ 查询/ 中/ 所/ 涉及/ 的/ 位于/ 同一/ Chunk/ 编号/ 的/ 普通/ 属性/ 集/ (/ OrdinaryAttributeSet/ ,/ OAS/ )/ ./ 将/ QAS/ 作为/ 初始/ 候选/ 缓存/ 单元/ 的/ 理由/ ,/ 如图/ 3/ 中/ 所示/ ,/ 对于/ 一个/ 查询/ ,/ 将/ 其/ 谓词/ 存放/ 在/ 缓存/ 中/ 可以/ 过滤/ 掉/ 不/ 满足条件/ 的/ 元/ 数据/ 索引/ 项/ ,/ 这样/ 在/ 进行/ 下/ 一个/ 基于/ 索引/ 的/ FETCH/ 操作/ 时/ 需要/ 读取/ 的/ 元组/ 数目/ 会/ 减少/ ,/ 从而/ I/ // O/ 次数/ 会/ 减少/ ;/ 而/ 查询/ 中/ 涉及/ 到/ 的/ 位于/ 同一/ Chunk/ 编号/ 的/ 属性/ 集/ 作为/ 替换/ 单元/ 是因为/ 对于/ 任意/ 一次/ FETCH/ 操作/ ,/ 当且/ 仅/ 当该/ 查询/ 所/ 涉及/ 位于/ 一个/ Chunk/ 编号/ 的/ 属性/ 集/ 作为/ 一个/ 整体/ 同时/ 被/ 缓存/ 才/ 会/ 减少/ I/ // O/ ,/ 而/ 将/ 其/ 子集/ 进行/ 缓存/ 不会/ 达到/ 减少/ I/ // O/ 的/ 效果/ ./ 生成/ 初始/ 候选/ 缓存/ 单元/ 的/ 算法/ 如/ 算法/ 1/ 所示/ ./ 算法/ 1/ ./ 生成/ 初始/ 候选/ 替换/ 单元/ (/ GenerateInitialCandidateReplacementUnits/ ,/ GICRU/ )/ ./ 1/ ./ IN/ :/ D/ ,/ Tenant/ ’/ sdatamappinginformation2/ ./ IN/ :/ Q/ ,/ QueryAccessModel3/ ./ OUT/ :/ CRU/ ,/ GeneratedCandidateReplacementUnits4/ ./ BEGIN5/ ./ SETCRU/ ·/ ·/ =/ / Page76/ ./ fortheithqueryqiinQ7/ ./ foreachpredicatepofqueryqi8/ ./ CRU/ ·/ ·/ =/ QAS/ (/ qi/ ,/ α/ (/ p/ )/ )/ ∪/ CRU9/ ./ endfor10/ ./ forthejthchunkoftenantT/ ’/ sphysicalchunk11/ ./ CRU/ ·/ ·/ =/ {/ β/ (/ CTj/ ,/ k/ )/ ∩/ OASi/ }/ ∪/ CRU12/ ./ endfor13/ ./ endfor14/ ./ returnCRU15/ ./ END/ 算法/ 1/ 以/ 租户/ 的/ 访问/ 模式/ 信息/ 及/ 租户/ 逻辑/ 模式/ 与/ 物理模式/ 之间/ 的/ 映射/ 信息/ 作为/ 输入/ ,/ 输出/ 对应/ 初始/ 候选/ 缓存/ 单元/ ./ 对/ 访问/ 模式/ 中/ 的/ 每/ 一个/ 请求/ (/ 对应/ 第/ 6/ ~/ 13/ 行/ )/ ,/ 首先/ 将/ 其/ 谓词/ 添加/ 到/ 候选/ 缓存/ 单元/ CRU/ 中/ (/ 对应/ 第/ 7/ ~/ 9/ 行/ )/ ,/ 然后/ 对于/ 其它/ 普通/ 属性/ 集则/ 按/ 租户/ 的/ 物理模式/ 的/ 分块/ 信息/ 进行/ 划分/ ,/ 将/ 属于/ 同一/ Chunk/ 中/ 的/ 属性/ 作为/ 缓存/ 单元/ 添加/ 到/ 初始/ 候选/ 缓存/ 单元/ CRU/ 中/ (/ 对应/ 第/ 10/ ~/ 12/ 行/ )/ ./ 为/ 更/ 形式化/ 地/ 描述/ 我们/ 的/ 缓存/ 单元/ 生成/ 算法/ ,/ 我们/ 通过/ 具体/ 的/ 例子/ 来/ 查看/ 如何/ 生成/ 初始/ 候选/ 缓存/ 单元/ ./ 例/ 2/ ./ 逻辑/ 表/ R/ (/ A1/ ,/ A2/ ,/ A3/ ,/ A4/ ,/ A5/ )/ ,/ 逻辑/ 模式/ 与/ 后台/ Chunk/ 表/ 的/ 映射函数/ :/ α/ (/ A1/ ,/ A2/ )/ =/ (/ C1/ ,/ 0/ )/ ,/ α/ (/ A3/ )/ =/ (/ C2/ ,/ 0/ )/ ,/ α/ (/ A4/ ,/ A5/ )/ =/ (/ C3/ ,/ 0/ )/ ,/ 也/ 即/ {/ A1/ ,/ A2/ }/ 被/ 映射/ 到/ Chunk/ 表/ C1/ ,/ 并/ 赋予/ 其/ 编号/ 0/ ;/ {/ A3/ }/ 被/ 映射/ 到/ Chunk/ 表/ C2/ ,/ 并/ 赋予/ 其/ 编号/ 0/ ;/ {/ A4/ ,/ A5/ }/ 被/ 映射/ 到/ Chunk/ 表/ C3/ ,/ 并/ 赋予/ 其/ 编号/ 0/ ./ 访问/ 模式/ 统计/ 信息/ 及/ 生成/ 的/ 初始/ 候选/ 缓存/ 单元/ 如表/ 2/ 所示/ ,/ 对于/ 每/ 一个/ 访问/ 所/ 涉及/ 的/ 属性/ 分为/ 谓词/ 属性/ 集/ (/ Predi/ -/ cateSet/ ,/ PS/ )/ 和/ 除/ 谓词/ 外/ 的/ 普通/ 属性/ 集/ (/ OrdinaryAttributeSet/ ,/ OAS/ )/ ./ 访问/ 模式/ 信息/ 候选/ 缓存/ 单元/ 算法/ 1/ 给出/ 了/ 如何/ 计算/ 候选/ 缓存/ 单元/ ,/ 而/ 对于/ 每/ 一个/ 缓存/ 单元/ 必须/ 定义/ 其/ 对应/ 的/ I/ // O/ 效益/ 率/ ,/ 也/ 即/ 放入/ 缓存/ 后/ 减少/ 的/ I/ // O/ 次数/ 和/ 占用/ 的/ 缓存/ 空间/ 大小/ 的/ 比值/ ,/ 我们/ 将/ 该值/ 定义/ 为/ ROC/ (/ ReturnonConsumption/ )/ ,/ ROC/ 的/ 计算/ 需要/ 两个/ 参数/ ,/ (/ 1/ )/ 缓存/ 单元/ 放入/ 缓存/ 后/ 占据/ 的/ 缓存/ 大小/ M/ 和/ (/ 2/ )/ 减少/ 的/ I/ // O/ 次数/ D/ ,/ 因此/ 对/ 缓存/ 单元/ i/ ,/ 有/ Mi/ 可以/ 利用/ QAS/ 内/ 属性/ 类型/ 大小/ 之/ 和/ 与/ 元组/ 数目/ 的/ 乘积/ 来/ 获得/ ;/ Di/ 可以/ 结合/ 式/ (/ 2/ )/ ,/ 利用/ 缓存/ 单元/ i/ 不/ 在/ 缓存/ 时/ 所有/ 请求/ 的/ I/ // O/ 次数/ 减去/ 缓存/ 单元/ i/ 在/ 缓存/ 时/ 的/ 所有/ 请求/ 的/ I/ // O/ 次数/ :/ Di/ =/ ∑/ Q/ 其中/ S/ 表示/ 已经/ 贮存/ 在/ 缓存/ 中/ 的/ 属性/ 集/ ,/ S/ ∪/ Ui/ 表示/ 将/ 缓存/ 单元/ Ui/ 放入/ 缓存/ ;/ q/ 为/ S/ 时/ 第/ q/ 个/ 请求/ 的/ I/ // O/ 次数/ ./ 4.2/ 基于/ 贪婪/ 算法/ 的/ 缓存/ 策略/ 上/ 一节/ 给出/ 了/ 如何/ 计算/ 初始/ 候选/ 缓存/ 单元/ 及其/ ROC/ 值/ ,/ 接下来/ 我们/ 将/ 给出/ 如何/ 选择/ 缓存/ 单元/ 放入/ 缓存/ 以及/ 如何/ 动态/ 更新/ 候选/ 缓存/ 单元/ 集/ 和/ 对应/ 的/ ROC/ 值/ ./ 首先/ ,/ 选择/ ROC/ 值/ 最高/ 的/ 缓存/ 单元/ 放入/ 缓存/ ,/ 并/ 将/ 该/ 缓存/ 单元/ 从/ 候选/ 缓存/ 单元/ 集中/ 去掉/ ;/ 其次/ ,/ 更新/ 与/ 刚/ 被/ 选中/ 放入/ 缓存/ 的/ 缓存/ 单元/ 有/ 交集/ 的/ 那些/ 候选/ 缓存/ 单元/ ,/ 将/ 其/ 交集/ 部分/ 去掉/ 从而/ 生成/ 新/ 的/ 候选/ 缓存/ 单元/ ;/ 最后/ ,/ 计算/ 更新/ 后/ 的/ 候选/ 缓存/ 单元/ 集/ 的/ ROC/ 值/ ,/ 其/ 计算/ 过程/ 同样/ 采用/ 式/ (/ 9/ )/ ./ 重复/ 上述/ 过程/ 直到/ 满足/ 租户/ 的/ SLA/ 响应/ 时间/ ,/ 也/ 即/ 其中/ I/ // O/ (/ qi/ )/ 代表/ 第/ i/ 个/ 请求/ 的/ I/ // O/ 次数/ ,/ 可以/ 通过/ 式/ (/ 2/ )/ 计算/ 得出/ ;/ Tsla/ 代表/ 租户/ 的/ SLA/ 响应/ 时间/ 需求/ ./ 表/ 3/ 将/ QAS/ (/ 狇/ 1/ ,/ (/ 犆/ 3/ ,/ 0/ )/ )/ =/ {/ 犃/ 4/ }/ 放入/ 缓存/ 后/ 的/ 初始/ 候选/ 缓存/ 单元/ 更新/ 候选/ 缓存/ 单元/ 继续/ 例/ 2/ 所示/ 的/ 例子/ ,/ 现在/ 我们/ 假设/ 经过/ 计算/ QAS/ (/ q1/ ,/ (/ C3/ ,/ 0/ )/ )/ =/ {/ A4/ }/ 的/ ROC/ 值/ 最高/ ,/ 因此/ 其/ 被/ 选中/ 进入/ 缓存/ ;/ 由于/ 剩下/ 的/ 候选/ 缓存/ 单元/ 中/ QAS/ (/ q3/ ,/ (/ C3/ ,/ 0/ )/ )/ =/ {/ A4/ ,/ A5/ }/ 与/ QAS/ (/ q1/ ,/ (/ C3/ ,/ 0/ )/ )/ =/ {/ A4/ }/ 的/ 交集/ 为/ {/ A4/ }/ ,/ 所以/ 不是/ 空集/ ,/ 因此/ QAS/ (/ q3/ ,/ (/ C3/ ,/ 0/ )/ )/ =/ {/ A4/ ,/ A5/ }/ 将会/ 更新/ 成/ QAS/ (/ q3/ ,/ (/ C3/ ,/ 0/ )/ )/ =/ {/ A5/ }/ ,/ 更/ Page8/ 新后/ 的/ 候选/ 缓存/ 单元/ 如表/ 3/ 所示/ ./ SetSelecting/ ,/ BASS/ )/ ./ 算法/ 2/ ./ 最优/ 属性/ 集/ 选择/ 算法/ (/ BestAttribute1/ ./ IN/ :/ D/ ,/ tenant/ ’/ sdatastatistics2/ ./ IN/ :/ W/ ,/ workloadstatistics3/ ./ IN/ :/ SLA/ ,/ tenant/ ’/ sSLArequirement4/ ./ OUT/ :/ AS/ ,/ AttributeSetshouldbeplacedinmemory5/ ./ BEGIN6/ ./ SETAS/ ·/ ·/ =/ / 7/ ./ SETCRU8/ ./ SETROC9/ ./ CRU/ ·/ ·/ =/ GICRU/ (/ W/ ,/ D/ )/ 10/ ./ ROC/ ·/ ·/ =/ ComputeROC/ (/ CRU/ ,/ D/ ,/ W/ )/ 11/ ./ while/ (/ TAS/ >/ TSLA/ )/ 12/ ./ AppCRU/ ·/ ·/ =/ CRUwithMax/ (/ ROC/ )/ 13/ ./ AS/ ·/ ·/ =/ AS/ ∪/ AppCRU14/ ./ CRU/ ·/ ·/ =/ UpdateCRU/ (/ CRU/ ,/ AppCRU/ )/ 15/ ./ ROC/ ·/ ·/ =/ UpdateROC/ (/ CRU/ ,/ D/ ,/ W/ ,/ AS/ )/ 16/ ./ TAS/ ·/ ·/ =/ AverageI/ // Os/ (/ W/ ,/ D/ ,/ AS/ )/ ×/ Costdisk17/ ./ endwhile18/ ./ returnAS19/ ./ END/ 上述/ 的/ 缓存/ 单元/ 选择/ 过程/ 类似/ 于/ 经典/ 的/ 背包/ 问题/ ,/ 唯一/ 不同/ 的/ 地方/ 在于/ 物品/ 和/ 物品/ 的/ 价值/ 会因/ 放入/ 背包/ 的/ 物品/ 的/ 不同/ 而/ 改变/ ,/ 我们/ 称之为/ 变种/ 的/ 背包/ 问题/ ,/ 并/ 采用/ 贪婪/ 算法/ 来/ 选择/ 属性/ 集/ ,/ 具体/ 实现/ 如/ 算法/ 2/ 所示/ ./ 算法/ 以/ 租户/ 的/ 访问/ 模式/ 信息/ 、/ 租户/ 数据/ 的/ 统计/ 信息/ 以及/ 租户/ 的/ SLA/ 响应/ 时间/ 需求/ 作为/ 输入/ ,/ 输出/ 最终/ 的/ 缓存/ 属性/ 集/ ./ 该/ 算法/ 首先/ 计算/ 初始/ 候选/ 缓存/ 单元/ 及其/ ROC/ 值/ (/ 对应/ 第/ 9/ ~/ 10/ 行/ )/ ,/ 然后/ 重复/ 选择/ ROC/ 值/ 最高/ 的/ 候选/ 缓存/ 单元/ 并/ 更新/ 剩余/ 候选/ 缓存/ 单元/ 及其/ ROC/ 值/ (/ 对应/ 第/ 11/ ~/ 17/ 行/ )/ ,/ 其中/ 第/ 12/ 行/ 选择/ ROC/ 值/ 最高/ 的/ 作为/ 此次/ 应用/ 的/ 候选/ 缓存/ 单元/ ,/ 并/ 将/ 其/ 添加/ 到/ 最终/ 缓存/ 属性/ 集/ AS/ 中/ (/ 对应/ 第/ 13/ 行/ )/ ,/ 接着/ 更新/ 剩余/ 缓存/ 单元/ 及其/ ROC/ 值/ (/ 对应/ 第/ 14/ ~/ 15/ 行/ )/ ,/ 第/ 16/ 行/ 计算/ 了/ 针对/ 当前/ 访问/ 模式/ 下/ 租户/ 的/ 平均/ 响应/ 时间/ 并/ 与/ 租户/ SLA/ 响应/ 时间/ 进行/ 比较/ 作为/ 循环/ 终止/ 条件/ ./ 为/ 便于/ 我们/ 更好/ 地/ 对/ 算法/ 2/ 进行/ 时间/ 复杂性/ 分析/ ,/ 我们/ 先/ 定义/ 3/ 个/ 参数/ :/ 请求/ 模板/ 数目/ m/ 、/ 模板/ 的/ 实例/ 化/ 数目/ n/ (/ m/ / n/ )/ 和/ 模板/ 的/ 平均/ 属性/ 数目/ A/ ;/ 所谓/ 请求/ 模板/ 指/ 的/ 是/ SaaS/ 应用/ 中/ 所/ 包含/ 的/ SQL/ 模板/ ,/ 模板/ 中/ 包含/ 若干个/ 需要/ 用户/ 填充/ 即/ 时值/ 的/ 属性/ ,/ 对于/ 给定/ 的/ SaaS/ 应用/ 来说/ ,/ 模板/ 数目/ 是/ 个/ 常量/ ./ 实际/ 运行/ 时/ 用户/ 填充/ 即/ 时值/ 到/ 对应/ 的/ SQL/ 模板/ 中/ 称为/ 模板/ 的/ 实例/ 化/ ,/ 实例/ 化/ 出来/ 的/ 不同/ 的/ SQL/ 数目/ 称为/ 模板/ 的/ 实例/ 化/ 数目/ ;/ 模板/ 的/ 平均/ 属性/ 数目/ 是/ 指/ 每/ 一个/ 模板/ 所/ 包含/ 的/ 属性/ 数目/ 的/ 平均值/ ./ 通过/ 分析/ 算法/ 2/ 我们/ 可以/ 发现/ ,/ 该/ 算法/ 主要/ 包含/ 3/ 部分/ :/ 17/ 行/ )/ ./ (/ 1/ )/ 计算/ 候选/ 缓存/ 单元/ (/ 第/ 9/ 行/ )/ ;/ (/ 2/ )/ 计算/ 候选/ 缓存/ 单元/ 的/ ROC/ 值/ (/ 第/ 10/ 行/ )/ ;/ (/ 3/ )/ 候选/ 缓存/ 单元/ 的/ 迭代/ 选择/ 过程/ (/ 第/ 11/ ~/ 对于/ 第/ 1/ 部分/ 计算/ 候选/ 缓存/ 单元/ (/ 对应/ 算法/ 1/ )/ ,/ 其/ 时间/ 复杂性/ 与/ 请求/ 模板/ 数目/ 和/ 模板/ 属性/ 集在/ 后台/ 的/ 数据/ 分块/ 的/ 分布/ 有关/ ,/ 最坏/ 情况/ 下/ 假设/ 一个/ 数据/ 分块/ 只/ 含有/ 一个/ 属性/ ,/ 故其/ 时间/ 复杂性/ 为/ O/ (/ mA/ )/ ./ 对于/ 第/ 2/ 部分/ 计算/ 候选/ 缓存/ 单元/ 的/ ROC/ 值/ ,/ 其/ 时间/ 复杂性/ 与/ 候选/ 缓存/ 单元/ 的/ 数目/ 以及/ 每/ 一个/ 候选/ 缓存/ 单元/ 涉及/ 到/ 的/ 实例/ 化/ 模板/ 数目/ 有关/ ,/ 最坏/ 情况/ 下有/ mA/ 个/ 候选/ 缓存/ 单元/ ,/ 并且/ 每一/ 候选/ 缓存/ 单元/ 与/ 所有/ 的/ 实例/ 化/ 模板/ 均/ 有关/ ,/ 故其/ 时间/ 复杂性/ 为/ O/ (/ mnA/ )/ ./ 对于/ 第/ 3/ 部分/ 候选/ 缓存/ 单元/ 的/ 迭代/ 过程/ ,/ 其/ 时间/ 复杂性/ 与/ 迭代/ 次数/ 以及/ 每/ 一次/ 迭代/ 所/ 需要/ 的/ 计算/ 量/ 有关/ ,/ 由于/ 我们/ 最多/ 有/ mA/ 个/ 候选/ 缓存/ 单元/ ,/ 因此/ 迭代/ 次数/ 最坏/ 情况/ 下为/ mA/ 次/ ,/ 而/ 每/ 一次/ 迭代/ 中/ 所/ 需要/ 的/ 计算/ (/ 对应/ 第/ 12/ ~/ 16/ 行/ )/ 只有/ 第/ 15/ 行是/ 耗时/ 最多/ 的/ ,/ 其它/ 均/ 为/ O/ (/ 1/ )/ 的/ ,/ 其中/ 第/ 15/ 行/ 事实上/ 是/ 第/ 2/ 部分/ 的/ 重复/ 执行/ ,/ 其/ 时间/ 复杂性/ 也/ 为/ O/ (/ mnA/ )/ ,/ 故该/ 部分/ 的/ 时间/ 复杂性/ 为/ O/ (/ nm2A2/ )/ ./ 通过/ 上述/ 分析/ 我们/ 可以/ 看出/ 该/ 算法/ 的/ 时间/ 复杂性/ 为/ O/ (/ nm2A2/ )/ ,/ 故其/ 时间/ 复杂性/ 是/ 多项式/ 的/ ,/ 因此/ 该/ 算法/ 可以/ 高效/ 的/ 运行/ ./ 4.3/ 自/ 适应/ 缓存/ 机制/ 的/ 实现/ 上/ 一节/ 给出/ 了/ 缓存/ 替换/ 单元/ 的/ 生成/ 和/ 选择/ 过程/ ,/ 本/ 节/ 我们/ 将/ 给/ 出自/ 适应/ 缓存/ 机制/ 的/ 完整/ 实现/ 过程/ ,/ 主要/ 包括/ 两个/ 阶段/ :/ (/ 1/ )/ 监测/ 阶段/ ./ 统计/ 最近/ 一段时间/ 内/ 租户/ 访问/ 模式/ 的/ 统计/ 信息/ 和/ 每/ 一/ 请求/ 的/ 响应/ 时间/ ./ 为了/ 预防/ 随机噪声/ 产生/ 严重/ 的/ 震荡/ ,/ 我们/ 将/ 记录/ 足够/ 长/ 的/ 时间/ 间隔/ 内/ 的/ 平均/ 响应/ 时间/ ,/ 并/ 将/ 该/ 时间/ 和/ 租户/ SLA/ 响应/ 时间/ 进行/ 比较/ ./ 由于/ 响应/ 时间/ 的/ 统计/ 差异/ ,/ 我们/ 认为/ 租户/ SLA/ 没有/ 满足/ 当且/ 仅/ 当/ 当前/ 平均/ 响应/ 时间/ 超过/ 了/ 容忍/ 范围/ δ/ ./ 如果/ 目标/ SLA/ 没有/ 满足/ ,/ 那么/ 我们/ 将/ 进入/ 阶段/ (/ b/ )/ ,/ 否则/ 我们/ 将/ 结束/ 当前/ 监测/ 并/ 进入/ 下/ 一轮/ 监测/ ./ (/ 2/ )/ 微调/ 阶段/ ./ 在/ 这/ 一/ 阶段/ 我们/ 将/ 采用/ 阶段/ (/ 1/ )/ Page9/ 收集/ 的/ 相关/ 信息/ 并/ 结合/ 4.2/ 节/ 给出/ 的/ 缓存/ 单元/ 的/ 选择/ 过程/ ,/ 计算/ 当前/ 访问/ 模式/ 下/ 的/ 缓存/ 属性/ 集/ ,/ 剔除/ 不应/ 在/ 缓存/ 的/ 属性/ 集/ ,/ 添加/ 尚/ 不/ 在/ 缓存/ 的/ 属性/ 集/ ,/ 并/ 进入/ 阶段/ (/ 1/ )/ ./ 算法/ 3/ ./ 自/ 适应/ 多/ 租户/ 缓存/ 管理/ 算法/ (/ Self/ -/ AdaptMulti/ -/ TenantMemoryManagment/ ,/ SAMTMM/ )/ ./ 1/ ./ BEGIN2/ ./ foreachtenantT3/ ./ IN/ :/ D/ ,/ tenantT/ ’/ sdatastatistics4/ ./ IN/ :/ AS/ ,/ AttributeSethasbeenplacedinmemory5/ ./ SETQS/ ·/ ·/ =/ / 6/ ./ while/ (/ thecurrenttimeslotisnotelapsed/ )/ 7/ ./ if/ (/ thereisarequestQ/ )/ 8/ ./ QS/ ·/ ·/ =/ QS/ ∪/ Q9/ ./ Time/ ·/ ·/ =/ Time/ +/ Qt10/ ./ counter/ ++/ 11/ ./ endif12/ ./ endwhile13/ ./ TOBS/ ·/ ·/ =/ Time/ // counter14/ ./ if/ (/ |/ TOBS/ -/ TSLA/ |/ // TSLA/ </ δ/ )/ 15/ ./ Discardcollectedinformationandstartthenext16/ ./ else17/ ./ TmpAS/ ·/ ·/ =/ BASS/ (/ QS/ ,/ D/ ,/ TSLA/ )/ 18/ ./ KickoutAS/ -/ TmpAS19/ ./ ReadinTmpAS/ -/ AS20/ ./ AS/ ·/ ·/ =/ TmpAS21/ ./ endif22/ ./ endfor23/ ./ END/ 算法/ 3/ 中/ 第/ 6/ ~/ 12/ 行/ 对应/ 监测/ 阶段/ ,/ 第/ 13/ 行/ 计算/ 对应/ 时间段/ 内/ 观察/ 到/ 的/ 平均/ 响应/ 时间/ ,/ 第/ 14/ 行/ 判断/ 该/ 时间段/ 内/ 的/ 响应/ 时间/ 是否/ 满足/ 租户/ SLA/ 需求/ ,/ 不/ 满足/ 租户/ SLA/ 需求/ 时/ ,/ 则/ 进入/ 微调/ 阶段/ 对应/ 第/ 16/ ~/ 21/ 行/ ./ 5/ 性能/ 测试/ 5.1/ 实验/ 环境/ 的/ 搭配/ 本文/ 采用/ TPC/ -/ W/ [/ 20/ ]/ 作为/ 我们/ 的/ 测试/ 基准/ 平台/ ,/ 采用/ ApacheTomcat/ 作为/ 应用服务器/ ,/ 后台/ 采用/ MySQL/ // InnoDB/ 作为/ 数据/ 存储/ 引擎/ ,/ 之所以/ 选择/ InnoDB/ 作为/ 存储/ 引擎/ ,/ 是/ 由于/ InnoDB/ 对于/ 事务/ 型/ 请求/ 的/ 加锁/ 粒度/ 基于/ 行/ 的/ ,/ 因此/ 租户/ 可以/ 并行/ 地/ 访问/ 对应/ 的/ 共享/ 架构/ 中/ 的/ 数据/ 而/ 不/ 影响/ 其他/ 租户/ 的/ 执行/ ./ Apache/ 服务器/ 和/ MySQL/ 数据库/ 部署/ 在/ PC机/ 上/ ,/ 采用/ Intel/ 酷睿/ 2/ 双核/ 处理器/ ,/ 主频/ 为/ 2.33/ GHz/ ,/ 拥有/ 2GB/ 大小/ 的/ 内存/ 和/ 250G/ 硬盘/ ./ 硬盘/ 具体/ 参数/ 如表/ 4/ 所示/ ,/ 由于/ 希捷/ 官网/ 并/ 没有/ 公布/ 短寻道/ 磁道/ 上/ 界/ ,/ 而仅/ 公布/ 了/ 平均/ 寻/ 道/ 时间/ ,/ 所以/ 这里/ 的/ 平均/ 寻/ 道/ 时间/ 取/ 8ms/ ,/ 而/ 平均/ 旋转/ 延迟/ 和/ 平均/ 传输/ 时间/ 均/ 可/ 由/ 第/ 3/ 节/ 公式/ 求得/ ./ 参数/ 单面/ 磁盘/ 磁道/ 数/ 3876168/ 磁道/ 扇区/ 数/ 63/ 单/ 盘面/ 的/ 扇区/ 数/ 2390311315/ 磁盘/ 转速/ 7200/ 短寻道/ 磁道/ 上界/ #/ 扇区/ 大小/ 512BDB/ 数据/ 块/ 大小/ 16KB/ 平均/ 传输/ 时间/ 0.43/ ms/ 平均/ 寻/ 道/ 时间/ </ 8.15/ ms/ 平均/ 旋转/ 延迟/ 4.16/ ms/ 在/ 我们/ 的/ 实验/ 中共/ 有/ 120/ 个/ 租户/ ,/ 也/ 即/ 120/ 个/ 零售/ 书店/ ,/ 每/ 一个/ 零售/ 书店/ 允许/ 同时在线/ 的/ 用户数/ 最大/ 为/ 100/ ./ 我们/ 采用/ 10/ 个/ 相同/ 配置/ 的/ 终端/ 来/ 模拟/ 外部/ 顾客/ 的/ 访问/ 请求/ ,/ 每/ 一个/ 终端/ 可/ 被/ 配置/ 用来/ 模拟/ 1200/ 个/ 顾客/ 的/ 针对/ 不同/ 零售/ 书店/ 的/ 请求/ ./ 每一/ 顾客/ 提交/ 请求/ (/ 请求/ 均/ 是/ 经/ MySQL/ 执行/ 计划/ 事先/ 验证/ 处理/ 过/ 的/ )/ 并/ 等待/ 一个/ 响应/ ;/ 在/ 提交/ 另/ 一个/ 请求/ 之前/ ,/ 我们/ 采用/ 平均值/ 分别/ 为/ 7s/ ,/ 14s/ ,/ 21s/ 的/ 负/ 指数分布/ 来/ 模拟/ 高频/ 、/ 中频/ 和/ 低频/ 顾客/ 的/ 思考/ 时间/ ./ 5.2/ 实验/ 数据/ 集/ 我们/ 采用/ TPC/ -/ W/ 基准/ 测试/ 平台/ 中/ 的/ 数据库/ 模式/ 作为/ 我们/ 的/ 测试/ 模式/ (/ 即/ 租户/ 逻辑/ 模式/ )/ ,/ 如图/ 4/ 所示/ ,/ 括号/ 中/ 列出/ 了/ 每/ 一个/ 属性/ 的/ 数据类型/ ,/ 通过观察/ 我们/ 发现/ 该/ 模式/ 共有/ 4/ 种/ 数据类型/ (/ INT/ ,/ DOUBLE/ ,/ DATE/ ,/ VARCHAR/ )/ ,/ 因此/ 我们/ 后台/ 的/ 基于/ ChunkFolding/ 共享/ 存储/ 架构/ 的/ 设计/ 如图/ 5/ 所示/ ,/ 其中/ Chunk0/ 包含/ 4/ 个/ 业务/ 数据/ 属性/ 列/ A1/ ,/ A2/ ,/ A3/ ,/ A4/ ,/ 分别/ 对应/ 数据类型/ INT/ ,/ DOUBLE/ ,/ DATE/ ,/ VARCHAR/ ;/ Chunk1/ 包含/ 两个/ 业务/ 数据/ 属性/ 列/ A1/ ,/ A2/ ,/ 其/ 数据类型/ 均/ 为/ INT/ ;/ Chunk2/ 包含/ 3/ 个/ 业务/ 数据/ 属性/ 列/ A1/ ,/ A2/ ,/ A3/ ,/ 其/ 对应/ 的/ 数据类型/ 均/ 为/ VARCHAR/ ;/ 这/ 3/ 个/ Chunk/ 表/ 的/ 前/ 4/ 个/ 属性/ 列为/ 元/ 数据/ 列/ ,/ 用于/ 还原/ 租户/ 的/ 逻辑/ 模式/ ,/ 其中/ Tenant/ 属性/ 用于/ 标记/ 不同/ 的/ 零售/ 书店/ ,/ 并且/ 在/ 这/ 4/ 个/ 属性/ 列/ 上/ 建立/ 组合/ 索引/ TTCR/ ./ 需要/ 注意/ 的/ 是/ 由于/ 文献/ [/ 4/ ]/ 并未/ 给出/ 如何/ 设计/ 一个/ 最优/ 的/ 基于/ ChunkFolding/ 的/ 共享/ 存储/ 架构/ ,/ 因此/ 图/ 5/ 中/ 的/ 基于/ ChunkFolding/ 的/ 共享/ 存储/ 架构/ 并/ 不是/ 一个/ 针对/ 该/ 逻辑/ 模式/ 的/ 最优/ 的/ 共享/ 存储/ 架构/ ;/ 同样/ 本/ 实验/ 中/ 采用/ 的/ 逻辑/ 模式/ 和/ 共享/ 存储/ 模式/ 之间/ 的/ 映射/ 关系/ 也/ 并不一定/ 是/ 最优/ 的/ ,/ 而/ 只是/ 我们/ 目前/ 能/ 找到/ 的/ 比较/ 紧凑/ 的/ 映射/ 关系/ ,/ 其/ 对应/ 的/ 映射/ 关系/ 如表/ 5/ 所示/ ./ Page10/ 图/ 4/ 测试/ 中/ 采用/ 的/ TPC/ -/ W/ 中/ 的/ 逻辑/ 模式/ 表/ 5TPC/ -/ W/ 的/ 逻辑/ 模式/ 与/ ChunkFolding/ 共享/ 存储/ 逻辑/ 表名/ CUSTOMERORDERSORDER/ _/ LINEADDRESSSTOCK/ α/ (/ S/ _/ I/ _/ ID/ ,/ S/ _/ QTY/ )/ =/ (/ Chunk1/ ,/ 4/ )/ ITEMCOUNTRY/ α/ (/ CO/ _/ ID/ ,/ #/ ,/ #/ ,/ CO/ _/ NAME/ )/ =/ (/ Chunk0/ ,/ 10/ )/ AUTHOR/ α/ (/ A/ _/ ID/ ,/ #/ )/ =/ (/ Chunk1/ ,/ 6/ )/ 图/ 5/ 测试/ 中/ 采用/ 的/ ChunkFolding/ 共享/ 存储/ 架构/ 实验/ 中/ 数据/ 集/ ,/ 其中/ AUTHOR/ 表中/ 的/ A/ _/ LNAME/ 和/ ITEM/ 表/ 的/ I/ _/ TITLE/ 字段/ 是/ 整个/ 模式/ 的/ 基本/ 字/ 段/ ,/ 采用/ TPC/ -/ W/ 提供/ 的/ 工具/ 程序/ WGEN/ 生成/ ,/ 其它/ 字/ 段/ 按照/ TPC/ -/ W/ 规范/ 随机/ 产生/ ./ 对于/ 每/ 一个/ 租户/ 我们/ 生成/ 大约/ 20M/ 左右/ 的/ 数据/ ,/ 不同/ 租户/ 的/ 数据/ 是/ 随机/ 交错/ 的/ 插入/ 数据库/ 的/ ,/ 也/ 即/ 每/ 一个/ 租户/ 的/ 数据/ 在/ 磁盘/ 上/ 是/ 分散/ 存储/ 的/ ./ 需要/ 提及/ 一点/ 的/ 是/ 对于/ 逻辑/ 模式/ 中/ 的/ 主键/ 和/ 外键/ 约束/ ,/ 在/ 我们/ 的/ ChunkFolding/ 共享/ 架构/ 中均/ 被/ 删除/ ,/ 这样/ 可以/ 方便/ 我们/ 的/ I/ // O/ 代价/ 估计/ ,/ 同时/ 也/ 使得/ 影响/ 实验/ 的/ 其它/ 不确定性/ 因素/ 减少/ ,/ 从而/ 使得/ 我们/ 能够/ 更加/ 专注/ 于/ 缓存/ 机制/ 对/ 查询/ 性能/ 的/ 影响/ ./ 5.3/ 实验/ 结果/ 第/ 1/ 个/ 实验/ 中/ 我们/ 通过/ 变换/ 租户/ 的/ SLA/ 响应/ 时间/ 需求/ ,/ 对比/ 采用/ 传统/ MySQL/ // InnoDB/ 带有/ 中/ 点/ 策略/ 的/ LRU/ 缓存/ 策略/ 以及/ 本文/ 提出/ 的/ 多/ 租户/ 缓存/ 策略/ 下/ 的/ 缓存/ 消耗/ ,/ 图/ 6/ 给出/ 了/ 单/ 租户/ 条件/ 下/ 的/ 实验/ 结果/ ./ Page11/ 图/ 6/ 不同/ 响应/ 时间/ 需求/ ,/ 采用/ LRU/ 与/ SAMTMM/ 时/ 的/ 缓存/ 消耗/ 从图/ 6/ 中/ 我们/ 可以/ 看出/ 不同/ 响应/ 时间/ 需求/ 下/ ,/ SAMTMM/ 所/ 需要/ 的/ 缓存/ 明显/ 低于/ LRU/ 所/ 需要/ 的/ 缓存/ ./ 上/ 一节/ 我们/ 指出/ 每一/ 租户/ 的/ 数据/ 大小/ 为/ 20M/ ,/ 这/ 就/ 意味着/ 理想/ 情况/ 下/ 缓存/ 单个/ 租户/ 的/ 全部/ 数据/ 至多/ 需要/ 20M/ 左右/ 的/ 缓存/ ./ 从图/ 6/ 所示/ 的/ 实验/ 结果/ 来看/ ,/ 在/ 响应/ 时间/ 需求/ 为/ 10ms/ 时/ ,/ SAMTMM/ 使用/ 了/ 约/ 16M/ 左右/ 的/ 缓存/ 从而/ 达到/ 了/ 这/ 一/ 目标/ 需求/ ,/ 其/ 大小/ 十分/ 接近/ 租户/ 数据/ 的/ 实际/ 大小/ ,/ 然而/ 采用/ LRU/ 缓存/ 策略/ 却/ 花费/ 了/ 大约/ 100M/ 左右/ 的/ 缓存/ ,/ 造成/ 这一/ 现象/ 的/ 根本原因/ 在于/ LRU/ 缓存/ 策略/ 是/ 以/ 数据/ 块/ 作为/ 缓存/ 单元/ 的/ ,/ 而/ 在/ 多/ 租户/ 共享/ 存储/ 架构/ 下/ ,/ 数据/ 块/ 中/ 存储/ 了/ 大量/ 其他/ 租户/ 的/ 无关/ 数据/ ,/ 浪费/ 了/ 缓存/ 空间/ ./ 第/ 2/ 个/ 实验/ 中/ 我们/ 设置/ MySQL/ 的/ 缓存/ 大小/ 为/ 图/ 7/ 采用/ LRU/ 和/ SAMTMM/ 策略/ 时/ 3/ 种/ 访问/ 频率/ 租户/ 的/ 平均/ 响应/ 时间/ 以及/ 对应/ 的/ 整体/ 缓存/ 消耗/ 700M/ ,/ 并设/ 租户/ 的/ SLA/ 响应/ 时间/ 需求/ 均/ 为/ 100ms/ ,/ 从图/ 6/ 可以/ 看出/ 为/ 满足/ 这一/ 需求/ ,/ SAMTMM/ 为/ 每/ 一/ 租户/ 分配/ 大约/ 5M/ 缓存/ (/ 该值/ 不/ 随/ 活跃/ 租户/ 数目/ 改变/ )/ ,/ 而/ LRU/ 为/ 每/ 一/ 租户/ 分配/ 大约/ 50M/ 缓存/ (/ 该值/ 随/ 活跃/ 租户/ 数目/ 的/ 增多/ 会/ 逐渐/ 减少/ )/ ;/ 依据/ 租户/ 的/ 访问/ 频率/ 将/ 其/ 分为/ 3/ 个/ 类别/ :/ 高频/ 访问/ 、/ 中频/ 访问/ 和/ 低频/ 访问/ (/ 通过/ 设置/ 不同/ 零售商/ 的/ 顾客/ 平均/ 思考/ 时间/ 来/ 模拟/ 实现/ )/ ./ 通过/ 等/ 比例/ 地/ 增加/ 不同/ 类别/ 租户/ 的/ 数目/ (/ 一次/ 增加/ 6/ 个/ ,/ 低频/ 、/ 中频/ 和/ 高频/ 各/ 2/ 个/ )/ ,/ 对比/ LRU/ 缓存/ 机制/ 与/ SAMTMM/ 缓存/ 机制/ 下/ 不同/ 类别/ 租户/ 平均/ 响应/ 时间/ ./ 从图/ 7/ (/ a/ )/ 中/ 可以/ 看出/ ,/ LRU/ 缓存/ 策略/ 下/ 高频/ 租户/ 的/ 响应/ 时间/ 明显/ 低于/ 租户/ SLA/ 响应/ 时间/ 需求/ ;/ 从图/ 7/ (/ b/ )/ 和/ (/ c/ )/ 中/ 可以/ 看出/ 在/ 租户/ 数目/ 较/ 少时/ ,/ 中频/ 和/ 低频/ 的/ 响应/ 时间/ 均/ 比较/ 快/ ,/ 当/ 租户/ 数目/ 增多/ 的/ 时候/ ,/ 中频/ 和/ 低频/ 的/ 响应/ 时间/ 都/ 会/ 明显/ 变慢/ ,/ 并且/ 远远/ 高于/ 租户/ SLA/ 响应/ 时间/ 需求/ ,/ 此外/ 低频/ 租户/ 的/ 响应/ 时间/ 增长/ 的/ 明显/ 比/ 中频/ 租户/ 的/ 要/ 快/ 很多/ ,/ 出现/ 这种/ 现象/ 的/ 原因/ 在于/ ,/ LRU/ 缓存/ 机制/ 从/ 数据库/ 整体/ 性能/ 考虑/ ,/ 在/ 初始/ 租户/ 数目/ 较少/ 的/ 时候/ ,/ 缓存/ 相对/ 多/ ,/ 所以/ 采用/ LRU/ 缓存/ 策略/ 就/ 将/ 大量/ 缓存/ 分配/ 给/ 了/ 这些/ 租户/ ,/ 使得/ 其/ 响应/ 时间/ 很快/ (/ 均/ 低于/ SLA/ 需求/ )/ ;/ 而/ 当/ 租户/ 数目/ 逐渐/ 增多/ 时/ ,/ 缓存/ 就/ 变得/ 紧张/ ,/ 采用/ LRU/ 缓存/ 策略/ 就/ 会/ 将/ 更/ 多/ 的/ 缓存/ 分配/ 给/ 了/ 高频/ 访问/ 的/ 租户/ ,/ 所以/ 中频/ 和/ 低频/ 访问/ 的/ 租户/ 大量/ 的/ 缓存/ 被/ 抢占/ 了/ ,/ 从而/ 响应/ 时间/ 会/ Page12/ 明显/ 变慢/ ;/ 对于/ 采用/ SAMTMM/ 缓存/ 机制/ 时/ ,/ 高频/ 、/ 中频/ 和/ 低频/ 租户/ 的/ 响应/ 时间/ 均/ 在/ 租户/ SLA/ 响应/ 时间/ 附近/ 波动/ ,/ 而/ 并/ 没有/ 出现/ 缓存/ 资源分配/ 的/ 不合理/ 现象/ ./ 从图/ 7/ (/ d/ )/ 中/ 可以/ 看出/ 采用/ SAMTMM/ 缓存/ 机制/ ,/ 分配/ 的/ 缓存/ 数量/ 与/ 租户/ 数目/ 成/ 线性/ 增长/ ,/ 这/ 是因为/ 我们/ 这里/ 的/ 租户/ 除了/ 访问/ 频率/ 不/ 一样/ 以外/ ,/ 其它/ 各/ 方面/ 都/ 是/ 完全/ 一样/ 的/ ,/ 因此/ 每一/ 租户/ 为/ 满足/ 其/ SLA/ 所/ 需要/ 的/ 缓存/ 就/ 基本相同/ ;/ 而/ 对于/ LRU/ 缓存/ 机制/ 来说/ ,/ 开始/ 一段时间/ 分配/ 的/ 缓存/ 数量/ 随/ 租户/ 数目/ 成/ 线性/ 增长/ ,/ 而/ 后期/ 保持/ 700M/ 不变/ ,/ 这是/ 由于/ 起始/ 租户/ 数目/ 不多时/ ,/ 每一/ 租户/ 的/ 数据/ 都/ 被/ 完全/ 缓存/ ,/ 而/ 采用/ 块/ 缓存/ 导致/ 缓存/ 被/ 快速/ 消耗/ ,/ 随/ 租户/ 数目/ 的/ 进一步/ 增多/ ,/ LRU/ 会/ 替换/ 掉/ 低频/ 和/ 中频/ 租户/ 的/ 缓存/ 以/ 留给/ 高频/ 租户/ ./ 6/ 总结/ 本文/ 我们/ 给出/ 了/ 基于/ ChunkFolding/ 的/ 多/ 租户/ 共享/ 架构/ 下/ 的/ 缓存/ 管理机制/ ,/ 通过/ 采用/ 自/ 适应/ 的/ 缓存/ 单元/ 可以/ 大幅/ 减少/ 由于/ 共享/ 架构/ 导致/ 的/ 以/ 数据/ 块/ 作为/ 缓存/ 单元/ 导致/ 的/ 资源/ 浪费/ ;/ 通过/ 租户/ SLA/ 作为/ 驱动/ 为/ 每/ 一个/ 租户/ 分配/ 缓存/ 可以/ 防止/ 租户/ 间/ 资源分配/ 的/ 不合理/ ,/ 如/ 高频/ 租户/ 抢占/ 大量/ 缓存/ ,/ 最终/ 使得/ 每一/ 租户/ 获得/ 满足/ 其/ SLA/ 需求/ 的/ 尽量少/ 的/ 缓存/ ./ 本文/ 假设/ 租户/ 进入/ 系统/ 后/ 保持/ 在/ 一定/ 的/ 活跃/ 状态/ ,/ 而/ 如何/ 监测/ 租户/ 的/ 活跃/ 程度/ 并/ 设定/ 一个/ 合理/ 的/ 阈值/ ,/ 驱逐/ 不/ 活跃/ 租户/ 的/ 缓存/ 空间/ ,/ 保证/ 每一/ 租户/ 的/ SLA/ 需求/ 的/ 同时/ 提高/ 整体/ 利用率/ 是/ 下/ 一步/ 需要/ 解决/ 的/ 问题/ ./ 另外/ 本文/ 目前/ 给出/ 的/ 是/ 单/ 节点/ 下/ 的/ 缓存/ 策略/ ,/ 如何/ 考虑/ 多/ 数据/ 节点/ 下/ 的/ 数据分布/ 并/ 将/ 其/ 拓展/ 到/ 多/ 节点/ 上以/ 满足/ 多/ 租户/ SLA/ 需求/ 是/ 下/ 一步/ 需要/ 解决/ 的/ 问题/ ./ 

