Page1EasiSNP/ :/ 一种/ 基于/ 时空/ 属性/ 的/ 传感器/ 网络/ 编程/ 方法/ 邱杰/ 凡/ 1/ )/ ,/ 2/ )/ 李栋/ 1/ )/ 石/ 海龙/ 1/ )/ ,/ 2/ )/ 崔莉/ 1/ )/ 1/ )/ (/ 中国科学院计算技术研究所/ 北京/ 100190/ )/ 2/ )/ (/ 中国科学院/ 大学/ 北京/ 100049/ )/ 摘要/ 由于/ 资源/ 受限/ 的/ 传感器/ 节点/ 易/ 受到/ 外界/ 环境因素/ 的/ 干扰/ ,/ 造成/ 传感器/ 网络/ 具有/ 较强/ 的/ 动态性/ ;/ 而/ 移动/ 节点/ 的/ 引入/ ,/ 会/ 加剧/ 网络/ 的/ 动态性/ ./ 为了/ 消除/ 网络/ 动态性/ 的/ 影响/ ,/ 需要/ 在/ 每个/ 节点/ 上/ 设计/ 复杂/ 的/ 冗余/ 机制/ ,/ 增加/ 了/ 开发/ 难度/ ./ 为此/ ,/ 作者/ 提出/ 了/ 一种/ 基于/ 时空/ 属性/ 的/ 编程/ 方法/ —/ —/ —/ EasiSNP/ ./ 通过/ 编写/ EasiSNP/ 顶层/ 应用程序/ ,/ 可以/ 直接/ 对接口/ 进行/ 编程/ ,/ 由/ 计算机/ 根据/ 接口/ 绑定/ 的/ 时空/ 属性/ 生成/ 任务/ 块/ ,/ 并/ 通过/ 任务/ 块/ 迁移/ 机制/ ,/ 由/ 网络/ 动态/ 选择/ 合适/ 的/ 节点/ 执行/ 任务/ 块/ ./ 此外/ ,/ 作者/ 设计/ 了/ 相应/ 的/ EasiSNP/ 程序/ 解释/ 系统/ 和/ 运行/ 时/ 系统/ ,/ 前者/ 实现/ 了/ EasiSNP/ 顶层/ 应用程序/ 的/ 正确/ 解释/ 以及/ 任务/ 块/ 的/ 生成/ ,/ 后者/ 保证/ 了/ 任务/ 块/ 能够/ 被/ 顺利/ 迁移/ 和/ 执行/ ./ 实验/ 表明/ 基于/ 时空/ 属性/ 的/ 编程/ 方法/ EasiSNP/ 在/ 提高/ 网络/ 健壮性/ 的/ 同时/ ,/ 能够/ 以较/ 少/ 的/ 开销/ 构建/ 复杂/ 的/ 应用/ ./ 关键词/ 传感器/ 网络/ ;/ 编程/ 方法/ ;/ 时空/ 属性/ ;/ 任务/ 块/ 迁移/ 机制/ 1/ 引言/ 当前/ 无线/ 传感器/ 网络/ 主要/ 是/ 由/ 低功耗/ 节点/ 构成/ ./ 节点/ 在/ 通信/ 资源/ 和/ 能耗/ 方面/ 受到/ 严格/ 的/ 限制/ ,/ 容易/ 受到/ 外部环境/ 因素/ 的/ 干扰/ ,/ 造成/ 传感器/ 网络/ 本身/ 具有/ 较强/ 的/ 动态性/ ./ 特别/ 是/ 在/ 一些/ 应用/ 场景/ 中/ ,/ 需要/ 引入/ 移动/ 节点/ 协助/ 静态/ 节点/ 完成/ 感知/ 任务/ ./ 移动/ 节点/ 在/ 空间/ 位置/ 上/ 的/ 不断/ 变化/ ,/ 很难/ 保证/ 其/ 通信/ 的/ 可靠性/ ,/ 因而/ 进一步/ 加剧/ 了/ 传感器/ 网络/ 的/ 动态性/ ./ 针对/ 这种/ 网络/ 动态性/ ,/ 编程/ 者/ 需要/ 设计/ 相应/ 的/ 冗余/ 机制/ ,/ 确保/ 节点/ 失效/ 或者/ 节点/ 位置/ 改变/ 时/ ,/ 不会/ 对/ 传感器/ 网络/ 的/ 正常/ 工作/ 造成/ 影响/ [/ 1/ ]/ ./ 然而/ 冗余/ 机制/ 的/ 引入/ 会/ 使/ 针对/ 传感器/ 网络/ 的/ 应用/ 程序开发/ 变得/ 异常/ 复杂/ ,/ 为了/ 提高/ 网络/ 的/ 健壮性/ ,/ 编程/ 者/ 不得不/ 考虑/ 各种/ 突发/ 情况/ 并/ 为/ 每个/ 节点/ 编写/ 专门/ 的/ 代码/ ,/ 势必/ 减少/ 对/ 整体/ 编程/ 逻辑/ 的/ 思考/ [/ 2/ ]/ ./ 进而/ ,/ 在/ 一个/ 由/ “/ 人/ -/ 机/ -/ 物/ ”/ 组成/ 的/ 物/ 联网/ 环境/ 中/ ,/ 传感器/ 网络/ 将/ 不再/ 仅仅/ 作为/ 物/ 联网/ 中/ 面向/ “/ 物/ ”/ 的/ 感知/ 前端/ ,/ 局限于/ 感知/ 周围环境/ 信息/ 等/ 简单/ 任务/ ,/ 而是/ 可以/ 根据/ “/ 人/ ”/ 的/ 动态/ 需求/ ,/ 执行/ 相应/ 的/ 任务/ [/ 3/ ]/ ./ 需求/ 的/ 动态性/ 表现/ 为/ 需求/ 的/ 发起/ 在/ 时间/ 和/ 空间/ 上/ 具有/ 不确定性/ 以及/ 需求/ 的/ 内容/ 具有/ 不确定性/ ./ 因此/ 需要/ 感知/ 层/ 网络/ 具备/ 和/ “/ 人/ ”/ 直接/ 进行/ 交互/ 的/ 能力/ ,/ 甚至/ 在/ 某些/ 情况/ 下/ 将/ “/ 人/ ”/ 的/ 行为/ 融入/ 感知/ 层/ 网络/ 的/ 任务/ 执行/ [/ 4/ -/ 5/ ]/ ./ 以/ 我们/ 在/ 太湖/ 上/ 部署/ 的/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ (/ Cyber/ -/ PhysicalSystem/ ,/ CPS/ )/ 为例/ [/ 6/ ]/ ,/ 传感器/ 节点/ 将/ 采集/ 到/ 的/ 感知/ 数据/ 发送给/ 云端/ 进行/ 处理/ 后/ ,/ 再/ 由/ 云端/ 向/ 执行/ 单元/ 指派/ 打捞/ 任务/ ./ 形成/ 一个/ 由/ 传感器/ 网络/ 感知/ 到/ 云端/ 处理/ ,/ 再/ 到/ 执行/ 单元/ 执行/ 的/ 闭环/ 系统/ ,/ 如图/ 1/ 所示/ ./ 然而/ 由于/ 节点/ 间通信/ 受到/ 天气/ 、/ 湿度/ 等/ 外界/ 环境因素/ 的/ 影响/ ,/ 感知/ 节点/ 可能/ 暂时性/ 的/ 脱离/ 网络/ ,/ 导致/ 感知/ 数据/ 的/ 延时/ 甚至/ 丢失/ ./ 另一方面/ ,/ 由于/ 太湖/ 的/ 特殊性/ ,/ 执行/ 单元/ 只能/ 依据/ 云端/ 早先/ 提供/ 的/ 策略/ 进行/ 打捞/ ,/ 即使/ 进入/ 传感器/ 网络/ 的/ 感知/ 区域/ 之后/ ,/ 也/ 无法/ 通过/ 与/ 传感器/ 网络/ 实时/ 交互/ 了解/ 当前/ 蓝藻/ 的/ 爆发/ 情况/ ./ 针对/ 这些/ 问题/ ,/ 我们/ 提出/ 了/ 一种/ 基于/ 时空/ 属性/ 的/ 传感器/ 网络/ 编程/ 方法/ —/ —/ —/ EasiSNP/ ./ 它/ 继承/ 了/ Nes/ C语言/ 中/ 接口/ (/ interface/ )/ 的/ 概念/ [/ 7/ ]/ ,/ 可以/ 通过/ 编写/ 顶层/ 应用程序/ (/ topapplication/ )/ 直接/ 描述/ 节点/ 上/ 不同/ 接口/ 的/ 相互作用/ 关系/ ,/ 而/ 不再/ 针对/ 具体/ 某个/ 节点/ 进行/ 编程/ ,/ 以较/ 低/ 的/ 编程/ 开销/ ,/ 描述/ 复杂/ 的/ 节点/ 间/ 图/ 1/ 太湖/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ (/ ①/ 传感器/ 节点/ 感知/ 环境/ 信息/ ,/ 通过/ 多/ 跳/ 方式/ 向/ 汇聚/ 节点/ 传输/ 感知/ 数据/ ;/ ②/ 汇聚/ 节点/ 通过/ 3G/ 网络/ 将/ 感知/ 数据/ 发/ 往/ 云端/ ;/ ③/ 云端/ 处理/ 数据/ 并/ 制定/ 相应/ 打捞/ 策略/ ;/ ④/ 告知/ 执行/ 单元/ 打捞/ 策略/ ;/ ⑤/ 执行/ 单元/ 依据/ 打捞/ 策略/ 前往/ 指定/ 域/ 作业/ )/ 协同/ ./ 同时/ ,/ 该/ 方法/ 允许/ 编程/ 者/ 定义/ 接口/ 和/ 节点/ 的/ 时空/ 属性/ ,/ 通过/ 一套/ 轻量级/ 的/ 任务/ 块/ 迁移/ (/ taskblockmigration/ )/ 机制/ ,/ 由/ 网络/ 根据/ 编程/ 者/ 定义/ 的/ 时空/ 属性/ 动态/ 地/ 选择/ 能够/ 执行/ 任务/ 的/ 节点/ ./ 为了/ 实现/ 基于/ 时空/ 属性/ 的/ 编程/ ,/ 我们/ 还/ 设计/ 了/ EasiSNP/ 的/ 程序/ 解释/ 系统/ 和/ 运行/ 时/ 系统/ ./ 程序/ 解释/ 系统/ 负责/ 将/ EasiSNP/ 顶层/ 应用程序/ 解释/ 为/ 具有/ 时空/ 属性/ 的/ NesC/ 程序/ ,/ 并/ 根据/ 满足/ 时空/ 属性/ 的/ 节点/ 进一步/ 生成/ 对应/ 的/ 任务/ 块/ (/ taskblock/ )/ ./ 运行/ 时/ 系统/ 负责/ 将/ 任务/ 块/ 迁移/ 并/ 加载/ 执行/ ,/ 它/ 包含/ 了/ 节点/ 运行/ 时/ 系统/ 和/ 后台/ 运行/ 时/ 系统/ ./ 前者/ 主要/ 维护/ 本地/ 节点/ 的/ 信息/ 以及/ 任务/ 块/ 的/ 加载/ ,/ 后者/ 主要/ 负责/ 维护/ 当前/ 全网/ 节点/ 的/ 信息/ 并/ 提供/ 查询/ 功能/ ./ 生成/ 任务/ 块/ 时/ ,/ 程序/ 解释/ 系统/ 可以/ 通过/ 后台/ 运行/ 时/ 系统/ 查询/ 节点/ 的/ 相关/ 信息/ ./ 最后/ ,/ 我们/ 针对/ 第一代/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ 的/ 不足/ ,/ 编写/ 了/ 针对/ 蓝藻/ 打捞/ 的/ EasiSNP/ 顶层/ 应用程序/ ./ 新/ 的/ 顶层/ 应用程序/ 实现/ 了/ 根据/ 打捞/ 执行/ 单元/ 的/ 空间/ 位置/ 动态/ 对/ 周围/ 蓝藻/ 信息/ 的/ 实时/ 访问/ ./ 并且/ 通过/ 基于/ 时空/ 属性/ 的/ 编程/ 方法/ 将/ 具有/ 移动/ 特性/ 的/ 打捞/ 执行/ 单元/ 抽象/ 为/ 移动/ 节点/ (/ Mobile/ )/ ,/ 协助/ 失效节点/ 完成/ 阻塞/ 数据/ 的/ 传输/ ./ 仿真/ 实验/ 表明/ ,/ 新/ 的/ 顶层/ 应用/ 可以/ 有效/ 降低/ 由于/ 节点/ 失效/ 导致/ 的/ 数据/ 延时/ ./ 本文/ 的/ 贡献/ 主要/ 集中/ 在/ 以下/ 3/ 个/ 方面/ :/ (/ 1/ )/ 为了/ 降低/ 针对/ 传感器/ 网络/ 编程/ 的/ 复杂度/ ,/ 提出/ 了/ 一种/ 基于/ 时空/ 属性/ 的/ 接口/ 编程/ 方法/ ,/ 设计/ 了/ 时空/ 属性/ 的/ 定义方法/ 以及/ 绑定/ 操作/ ,/ 并且/ 通过/ 程序/ Page3/ 解释/ 系统/ 实现/ 顶层/ 应用程序/ 到/ 任务/ 块/ 的/ 转化/ ./ (/ 2/ )/ 为了/ 消除/ 传感器/ 网络/ 动态性/ 影响/ ,/ 提出/ 一种/ 轻量级/ 的/ 任务/ 块/ 迁移/ 机制/ ,/ 以/ 替换/ 的/ 思想动态/ 调整/ 任务/ 块/ 的/ 执行/ 节点/ ,/ 并/ 通过/ 运行/ 时/ 系统/ 实现/ 任务/ 块/ 的/ 动态/ 加载/ 和/ 执行/ ./ (/ 3/ )/ 以/ 当前/ 的/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ 作为/ 应用/ 背景/ ,/ 编写/ EasiSNP/ 顶层/ 应用程序/ ./ 并且/ 通过/ 仿真/ 实验/ 验证/ 了/ 顶层/ 应用程序/ 在/ 降低/ 数据/ 延时/ 方面/ 的/ 有效性/ ./ 本文/ 第/ 2/ 节/ 简要地/ 介绍/ 相关/ 研究/ 背景/ ;/ 第/ 3/ 节/ 简述/ EasiSNP/ 组成/ 以及/ 执行/ 流程/ ;/ 第/ 4/ 节将/ 给出/ EasiSNP/ 的/ 具体/ 实现/ ;/ 第/ 5/ 节/ 针对/ 具体/ 应用/ 场景/ 验证/ EasiSNP/ 的/ 有效性/ ,/ 并/ 对/ 实验/ 结果/ 进行/ 分析/ ;/ 第/ 6/ 节/ 介绍/ 相关/ 工作/ ;/ 最后/ 在/ 第/ 7/ 节/ 给出/ 结论/ 和/ 未来/ 的/ 工作/ ./ 2/ 研究/ 背景/ EasiSNP/ 继承/ 了/ Nes/ C语言/ 中/ 接口/ (/ interface/ )/ 的/ 概念/ ,/ 并且/ 将/ 传感器/ 网络操作系统/ TinyOS/ 作为/ 实现/ 平台/ ./ NesC/ [/ 7/ ]/ 是/ 一种/ 基于/ 组件/ 的/ 编程语言/ ,/ 它/ 体现/ 了/ 一种/ 面向/ 事件驱动/ 的/ 编程/ 思想/ ./ NesC/ 组件/ 的/ 行为/ 由/ 接口/ 进行/ 定义/ ./ 接口/ 可以/ 分为/ 命令/ 接口/ (/ commandinterface/ )/ 和/ 事件/ 接口/ (/ eventinterface/ )/ ./ 命令/ 接口/ 是/ 由/ 组件/ 提供/ 给/ 编程/ 者/ 的/ 功能/ 实现/ ;/ 事件/ 接口/ 是/ 编程/ 者/ 提供/ 组件/ 的/ 执行/ 实现/ ./ 命令/ 接口/ 的/ 实现/ 通常/ 由/ 底层/ TinyOS/ 系统/ 提供/ ./ 上层/ 应用/ 通过/ 命令/ 接口/ 调用/ 实现/ 对/ 底层/ 系统/ 函数/ 的/ 向下/ 调用/ ./ 我们/ 称/ 这些/ 底层/ 系统/ 函数/ 为/ 命令/ 函数/ (/ commandfunction/ )/ ./ 事件/ 接口/ 的/ 实现/ 通常/ 由/ 上层/ 应用/ 提供/ ./ 底层/ TinyOS/ 系统/ 通过/ 事件/ 接口/ 调用/ 实现/ 对/ 应用层/ 函数/ 的/ 向上/ 触发/ ./ 我们/ 称/ 这些/ 应用层/ 函数/ 为/ 事件/ 函数/ (/ eventfunction/ )/ ./ NesC/ 程序/ (/ ./ nc/ 文件/ )/ 的/ 编译/ 可/ 分为/ 两个/ 阶段/ ./ (/ 1/ )/ NesC/ 编译器/ 根据/ 输入/ 的/ 节点/ 类型/ 将/ NesC/ 程序/ 翻译/ 为/ 标准/ C/ 程序/ (/ App/ ./ c/ )/ ./ App/ ./ c/ 包含/ 了/ 一个/ 被/ 裁剪/ 过/ 的/ TinyOS/ 操作系统/ 以及/ 编程/ 者/ 自定义/ 的/ 应用程序/ ./ 在/ App/ ./ c/ 中/ ,/ 命令/ 函数/ 和/ 事件/ 函数/ 都/ 被/ 转化/ 为/ 标准/ C/ 函数/ ./ (/ 2/ )/ 根据/ 节点/ 处理器/ 的/ 类型/ 选择/ 合适/ 的/ 交叉/ 编译器/ (/ 如/ msp430/ -/ gcc/ )/ ,/ 生成/ 处理器/ 可以/ 直接/ 运行/ 的/ 二进制/ 可执行文件/ ./ 在/ 一个/ 动态/ 网络/ 中/ ,/ 编程/ 者/ 无法/ 预知/ 当前/ 符合/ 时空/ 属性/ 的/ 节点/ ,/ 因此/ 需要/ 节点/ 提供/ 相应/ 的/ 时空/ 信息/ ,/ 以/ 进一步/ 确定/ 编译/ 参数/ ./ EasiSNP/ 默认/ 采用/ DV/ -/ Hop/ [/ 8/ ]/ 和/ FTSP/ [/ 9/ ]/ 作为/ 获取/ 绝对空间/ 位置/ 和/ 全局/ 时间/ 的/ 手段/ ./ DV/ -/ Hop/ 是/ 一种/ 基于/ 节点/ 连通/ 度/ (/ connectivitydegree/ )/ 的/ 非/ 测距/ 节点/ 自/ 定位/ 算法/ ./ 通过/ 测定/ 当前/ 节点/ 与/ 多个/ 位置/ 已知/ 节点/ 的/ 最少/ 跳数/ (/ smallesthops/ )/ 信息/ 来/ 计算/ 当前/ 节点/ 所处/ 的/ 位置/ ./ 这种/ 定位/ 算法/ 对/ 节点/ 的/ 资源/ 要求/ 不高/ ,/ 不/ 需要/ 添加/ 额外/ 的/ 定位/ 设备/ ,/ 且/ 定位精度/ 与/ 节点/ 密度/ 密切相关/ ./ 因此/ 在/ 低密度/ 感知/ 节点/ 的/ 应用/ 场景/ 中/ ,/ 编程/ 者/ 也/ 可以/ 通过/ 描述/ 相对/ 空间/ 位置/ 和/ 信号/ 覆盖范围/ 来/ 定义/ 空间/ 属性/ ,/ 不/ 强制/ 所有/ 节点/ 具备/ 自/ 定位/ 能力/ ./ FTSP/ 是/ 一种/ 全局/ 时间/ 同步/ 协议/ ,/ 它/ 能够/ 以较/ 低/ 的/ 通信/ 开销/ 建立/ 整个/ 网络/ 的/ 全局/ 时间/ ./ 每个/ 被/ 同步/ 的/ 节点/ 都/ 会/ 维护/ 一张/ 来自/ 于/ 已经/ 被/ 同步/ 节点/ 的/ 列表/ ./ 通过/ 线性/ 回归/ 的/ 方法/ 推理/ 节点/ 局部/ 时间/ 与/ 全局/ 时间/ 的/ 关系/ ,/ 并/ 做出/ 调整/ ./ 3EasiSNP/ 概述/ 图/ 2/ 给出/ 了/ EasiSNP/ 的/ 系统结构/ 框架/ ./ 它/ 由/ 程序/ 解释/ 系统/ 、/ 后台/ 运行/ 时/ 系统/ 和/ 节点/ 运行/ 时/ 系统/ 3/ 部分/ 组成/ ./ 程序/ 解释/ 系统/ 在/ 计算机/ 端/ 运行/ ,/ 主要/ 负责/ 将/ 顶层/ 应用程序/ 解释/ 为/ NesC/ 程序/ ,/ 并/ 调用/ NesC/ 编译器/ 生成/ 节点/ 可/ 执行/ 的/ 任务/ 块/ ./ 后台/ 运行/ 时/ 系统/ 在/ 计算机/ 端/ 运行/ ,/ 它/ 主要/ 负责/ 维护/ 全/ 网络/ 的/ 节点/ 状态/ 信息/ ,/ 同时/ 为/ 程序/ 解释/ 系统/ 提供/ 查询/ 服务/ ./ 节点/ 运行/ 时/ 系统/ 运行/ 在/ 节点/ 端/ ,/ 主要/ 负责/ 维护/ 本地/ 节点/ 状态/ 信息/ 以及/ 任务/ 块/ 的/ 迁移/ 和/ 加载/ ./ 在/ 向/ 传感器/ 网络/ 部署/ 顶层/ 应用程序/ 之前/ ,/ 网络/ 中/ 的/ 节点/ 需要/ 向/ 后台/ 运行/ 时/ 系统/ 进行/ 注册/ ./ 后台/ 运行/ 时/ 系统/ 需要/ 维护/ 全局/ 节点/ 信息/ 表/ (/ 详见/ 表/ 1/ )/ 用于/ 保存/ 注册/ 节点/ 的/ 信息/ ./ 图/ 3/ 给出/ 了/ 部署/ 一个/ 顶层/ 应用程序/ 的/ 执行/ 流程/ ./ 首先/ ,/ 程序/ 解释/ 系统/ 将/ 顶层/ 应用程序/ 翻译/ 为/ 多个/ 独立/ 的/ NesC/ 程序/ ./ 每个/ NesC/ 程序/ 都/ 具有/ 独立/ 的/ 时空/ 属性/ ./ 程序/ 解释/ 系统/ 向/ 后台/ 运行/ 时/ 系统/ 发出/ 查询/ 请求/ ,/ 后台/ 运行/ 时/ 系统/ 需要/ 对/ 全局/ 节点/ 信息/ 表/ 进行/ 检索/ ,/ 搜索/ 能够/ 满足/ NesC/ 程序/ 时空/ 属性/ 的/ 节点/ ,/ 并/ 返回/ 节点/ 类型信息/ ./ Page4/ 图/ 3EasiSNP/ 执行/ 流程/ 节点/ 号/ 节点/ 类型/ 空间/ 位置/ 信息/ 邻居/ 节点/ 信息/ 开放/ 接口/ 列表/ 事件/ 接口/ 状态表/ 已/ 保存/ 任务/ 块/ 程序/ 解释/ 系统/ 根据/ 返回/ 的/ 节点/ 类型信息/ ,/ 选择/ 合适/ 的/ 编译/ 参数/ 和/ 交叉/ 编译器/ ,/ 对/ NesC/ 程序/ 进行/ 编译/ ,/ 生成/ 节点/ 可/ 执行/ 的/ 任务/ 块/ ./ NesC/ 程序/ 的/ 空间/ 属性/ 也/ 作为/ 任务/ 块/ 的/ 空间/ 属性/ 被/ 添加/ 到/ 相应/ 的/ 任务/ 块/ 管理/ 列表/ (/ 详见/ 表/ 2/ )/ 中/ ./ 程序/ 解释/ 系统/ 需要/ 修改/ 全局/ 节点/ 信息/ 表中/ 对应/ 节点/ 的/ 信息/ 表项/ ./ 后台/ 运行/ 时/ 系统/ 通过/ 任务/ 块/ 迁移/ 机制/ ,/ 将/ 新/ 任务/ 块/ 迁移/ 到/ 对应/ 的/ 节点/ 上/ ./ 任务/ 块/ 编号/ 任务/ 块/ 保存/ 地址/ 接口/ 调用/ 列表/ 空间/ 属性/ 当前/ 绑定/ 节点/ ID/ 备用/ 绑定/ 节点/ ID/ 序列/ 在/ 节点/ 端/ ,/ 任务/ 块/ 被/ 下载/ 到/ 指定/ 位置/ 后/ ,/ 节点/ 运行/ 时/ 系统/ 会/ 判断/ 主/ 内存/ 中/ 预设/ 的/ 任务/ 块/ 存储空间/ 是否/ 够用/ ./ 如果/ 任务/ 块/ 的/ 存储空间/ 即将/ 被/ 耗尽/ ,/ 则/ 需要/ 节点/ 运行/ 时/ 系统/ 将/ 部分/ 失效/ 任务/ 块/ 从/ 节点/ 主/ 内存/ 中/ 迁移/ 到/ 节点/ 的/ 外部/ 扩展/ 存储器/ 中/ ./ 然后/ ,/ 节点/ 运行/ 时/ 系统/ 修改/ 节点/ 上/ 相关/ 的/ 函数/ 管理/ 列表/ ,/ 将/ 新/ 的/ 任务/ 块/ 与/ 底层/ TinyOS/ 系统/ 进行/ 链接/ ./ 最后/ ,/ 重启/ 节点/ ,/ 开始/ 执行/ 新/ 的/ 任务/ 块/ ./ 4EasiSNP/ 的/ 实现/ 本节/ 将/ 介绍/ EasiSNP/ 的/ 具体/ 实现/ ./ 4.1/ 节/ 和/ 4.2/ 节将/ 重点/ 介绍/ 在/ EasiSNP/ 顶层/ 应用程序/ 中/ 如何/ 定义/ 时空/ 属性/ 以及/ 如何/ 对接口/ 编程/ ./ 4.3/ 节/ 以及/ 4.4/ 节/ 介绍/ 顶层/ 应用程序/ 分解/ 以及/ 任务/ 块/ 生成/ ./ 4.5/ 节/ 介绍/ 如何/ 加载/ 任务/ 块/ 到/ 节点/ 上/ ./ 4.6/ 节/ 介绍/ 任务/ 块/ 迁移/ 机制/ ,/ 并/ 对/ 任务/ 块/ 迁移/ 机制/ 的/ 适用/ 情况/ 进行/ 说明/ ./ 4.1/ 时间/ // 空间/ 属性/ 的/ 定义/ 任务/ 块/ 的/ 空间/ 属性/ 可以/ 通过/ 绝对空间/ 位置/ 、/ 相对/ 空间/ 位置/ 以及/ 通信/ 覆盖范围/ 3/ 种/ 方式/ 进行/ 定义/ ./ 绝对空间/ 位置/ 需要/ 指定/ 一个/ 具体/ 空间/ 坐标/ ,/ 后台/ 运行/ 时/ 系统/ 将/ 搜索/ 位于/ 这个/ 坐标/ 附近/ 的/ 节点/ ,/ 其/ 定义/ 方式/ 如式/ (/ 1/ )/ 所示/ :/ [/ x/ ,/ y/ ]/ 表示/ 一个/ 具体/ 的/ 二维/ 平面坐标/ (/ 当然/ 可以/ 推广/ 到/ 三维空间/ 坐标/ [/ x/ ,/ y/ ,/ z/ ]/ )/ ./ Dist/ 是/ 容忍/ 距离/ ,/ 当/ 节点/ 与/ 设定/ 坐标/ 点/ [/ x/ ,/ y/ ]/ 的/ 距离/ 小于/ Dist/ 时/ ,/ 可以/ 认为/ 节点/ 满足/ 所/ 定义/ 的/ 空间/ 属性/ ./ 如果/ Dist/ 设置/ 为/ 0/ ,/ 则/ 认为/ 只有/ 距离/ 坐标/ 点/ 最近/ 的/ 节点/ 满足/ 所/ 定义/ 的/ 空间/ 属性/ ./ 设定/ 容忍/ 距离/ 可以/ 形成/ 一个/ 搜索/ 圆面/ ,/ 如果/ 在/ 这个/ 范围/ 内/ 存在/ 合适/ 的/ 节点/ ,/ 则/ 后台/ 运行/ 时/ 系统/ 会/ 记录/ 对应/ 的/ 节点/ 号/ ;/ 反之/ ,/ 如果/ 没有/ 满足/ 定义/ 的/ 节点/ ,/ 返回/ 编程/ 失败/ 的/ 信息/ ./ 相对/ 空间/ 位置/ 是/ 在/ 相对/ 于/ 某个/ 已知/ 节点/ 的/ 空间/ 范围/ 内/ 进行/ 空间/ 位置/ 的/ 定义/ ,/ 其/ 定义/ 方式/ 如式/ (/ 2/ )/ 所示/ :/ ReltLoc/ (/ Node/ _/ ID/ ,/ Direction/ // Angle/ ,/ Dist/ )/ (/ 2/ )/ Node/ _/ ID/ 是/ 已知/ 节点/ A/ 的/ ID/ 号/ ,/ 并且/ 假设/ 节点/ A/ 的/ 空间/ 坐标/ 也/ 是/ 已知/ 的/ ./ Direction/ // Angle/ 分别/ 表示/ 方向/ 和/ 角度/ ./ 可选/ 的/ 方向/ (/ direction/ )/ 包括/ :/ [/ East/ // West/ // North/ // South/ // Left/ // Right/ ]/ ./ 编程/ 者/ 也/ 可以/ 设定/ 一个/ 具体/ 的/ 角度/ (/ Angle/ )/ 范围/ ,/ 例如/ :/ [/ 45/ ,/ 75/ ]/ ./ 通过/ 设定/ 搜索/ 的/ 方向/ // 角度/ 以及/ 容忍/ 距离/ ,/ 可以/ 形成/ 一个/ 搜索/ 扇面/ ./ 位于/ 这个/ 扇面/ 内/ 的/ 节点/ 是/ 满足/ 相对/ 空间/ 属性/ 定义/ 的/ 节点/ ;/ 如果/ 没有/ 节点/ 位于/ 这个/ 搜索/ 扇面/ 中/ ,/ 则/ 返回/ 编程/ 失败/ 的/ 信息/ ./ 编程/ 者/ 也/ 可以/ 通过/ 若干个/ 节点/ 的/ 通信/ 覆盖范围/ 来/ 刻画/ 一个/ 模糊/ 的/ 覆盖/ 空间/ 范围/ ,/ 其/ 定义/ 方式/ 如式/ (/ 3/ )/ 所示/ :/ [/ Node1/ ,/ Node2/ ,/ …/ ,/ Noden/ ]/ 表示/ 若干/ 节点/ 的/ ID/ 的/ 集合/ ./ 通过/ 检索/ 这个/ 集合/ 内/ 节点/ 一跳/ (/ hop/ )/ 范围/ 内/ 的/ 节点/ ,/ 可以/ 得到/ 若干个/ 被/ 集合/ 内/ 节点/ 共同/ 覆盖/ 的/ 节点/ ./ 这些/ 被/ 覆盖/ 到/ 的/ 节点/ 位于/ 一个/ 不规则/ 的/ 几何图形/ 内/ ./ 任务/ 块/ 的/ 时间/ 属性/ 可以/ 通过/ 绝对/ 时间/ 和/ 相对/ 时间/ 进行/ 定义/ ./ 绝对/ 时间/ 一般/ 需要/ 使用/ 全局/ 时间/ 同步/ 协议/ (/ 如/ FTSP/ )/ 获得/ ,/ 其/ 定义/ 方式/ 如式/ (/ 4/ )/ 所示/ :/ AbsTime/ (/ StartTime/ ,/ TimeOut/ ,/ Shot/ // Peri/ ,/ Interval/ )/ StartTime/ 表示/ 任务/ 开始/ 执行/ 的/ 绝对/ 时间/ ./ TimeOutPage5/ 是/ 容忍/ 时/ 长/ ,/ 如果/ 任务/ 开始/ 时间/ 之后/ 没有/ 被/ 立即/ 执行/ ,/ 那么/ 可以/ 等待/ 的/ 容忍/ 时长/ 为/ TimeOut/ ;/ 如果/ 在/ 这个/ 时间段/ 内/ 任务/ 还是/ 没有/ 被/ 执行/ ,/ 则/ 认为/ 任务/ 执行/ 失败/ ./ 在/ 对/ 时间/ 不/ 敏感/ 的/ 应用/ 场景/ 中/ ,/ 编程/ 者/ 可以/ 通过/ 设定/ 一个/ 较大/ 的/ TimeOut/ 值/ ,/ 尽可能/ 让/ 任务/ 被/ 执行/ ./ Shot/ 和/ Peri/ 用于/ 区分/ 单次/ 触发/ 模式/ 和/ 周期/ 触发/ 模式/ ./ 单次/ 触发/ 模式/ 表示/ 被/ 触发/ 的/ 任务/ 在/ 执行/ 完毕/ 后/ ,/ 将/ 不再/ 执行/ ,/ 直到/ 下/ 一次/ 被/ 触发/ ./ 周期/ 触发/ 表示/ 任务/ 被/ 触发/ 后/ ,/ 将/ 由/ 运行/ 时/ 系统/ 每/ 间隔/ 一段时间/ 触发/ 任务/ ,/ 除非/ 显式/ 地/ 取消/ 触发/ ,/ 否则/ 周期性/ 触发/ 将/ 一直/ 保持/ 下去/ ./ Interval/ 是/ 周期/ 触发/ 的/ 时间/ 间隔/ ,/ 如果/ 选择/ 单次/ 触发/ (/ Shot/ )/ ,/ 则/ 该/ 参数/ 为/ Null/ ./ 相对/ 时间/ 是/ 以/ 事件/ 的/ 发生/ 作为/ 开始/ 标志/ ,/ 其/ 定义/ 方式/ 如式/ (/ 5/ )/ 所示/ :/ ReltTime/ (/ Event/ ,/ TimeOut/ ,/ Shot/ // Peri/ ,/ Interva/ )/ Event/ 是/ 触发/ 任务/ 的/ 具体/ 事件/ ./ 由于/ 事件/ 的/ 发生/ 具有/ 不确定性/ ,/ 因此/ 任务/ 的/ 触发/ 具有/ 一定/ 的/ 不确定性/ ./ 由于/ TinyOS/ 采用/ 了/ 事件驱动/ (/ event/ -/ driven/ )/ 的/ 编程/ 模式/ ,/ 事件/ 接口/ 调用/ 可以/ 用于/ 表示/ 某个/ 事件/ 的/ 发生/ ./ 因此/ 如果/ 被/ 绑定/ 的/ 事件/ 位于/ 节点/ 本地/ ,/ 可以/ 直接/ 利用/ TinyOS/ 提供/ 的/ 事件/ 接口/ 调用/ 进行/ 触发/ ;/ 否则/ ,/ 事件/ 的/ 发生/ 位于/ 其它/ 节点/ 上/ ,/ 需要/ 通过/ 节点/ 运行/ 时/ 系统/ 进行/ 触发/ ./ 我们/ 将/ 在/ 4.3/ 节/ 详细/ 讨论/ 这个/ 问题/ ./ 4.2/ 接口/ 编程/ 实现/ EasiSNP/ 继承/ 了/ Nes/ C语言/ 中/ 接口/ 的/ 概念/ ./ 在/ 编写/ 顶层/ 应用程序/ 时/ ,/ 可以/ 在/ 不/ 指定/ 具体/ 节点/ 的/ 情况/ 下/ ,/ 直接/ 对接口/ 进行/ 编程/ ./ 程序/ 解释/ 系统/ 将/ 自动/ 寻找/ 能够/ 提供/ 接口/ 的/ 节点/ ./ 顶层/ 应用程序/ 主要/ 包含/ 以下/ 3/ 种/ 要素/ :/ (/ 1/ )/ 接口/ 提供者/ (/ InterfaceProvider/ )/ ./ 接口/ 提供者/ 是/ 一种/ 特殊/ 的/ 变量/ ,/ 它/ 声明/ 了/ 需要/ 提供/ 的/ 接口/ 调用/ ./ 每个/ 接口/ 提供者/ 需要/ 和/ 一个/ 能够/ 提供/ 接口/ 的/ 具体/ 节点/ 进行/ 绑定/ ./ 对/ 节点/ 的/ 绑定/ 将/ 由/ 后台/ 运行/ 时/ 系统/ 和/ 程序/ 解释/ 系统/ 协同/ 完成/ ,/ 对/ 编程/ 者/ 不/ 可见/ ./ (/ 2/ )/ 接口/ 调用/ (/ InterfaceCall/ )/ ./ 接口/ 调用/ 分为/ 命/ L7TimeBind/ (/ Leds/ [/ i/ ]/ ./ leds/ ./ TurnOn/ (/ )/ ,/ ReltTime/ (/ Leds/ [/ i/ -/ 1/ ]/ ./ leds/ ./ On/ ,/ Shot/ ,/ Null/ )/ )/ ;/ L8TimeBind/ (/ Leds/ [/ i/ -/ 1/ ]/ ./ leds/ ./ TurnOff/ (/ )/ ,/ ReltTime/ (/ Leds/ [/ i/ ]/ ./ leds/ ./ On/ ,/ Shot/ ,/ Null/ )/ )/ ;/ }/ 图/ 4/ 跑马灯/ 的/ 顶层/ 应用程序/ 令/ 接口/ 调用/ 和/ 事件/ 接口/ 调用/ ./ 其中/ TinyOS/ 实现/ 的/ 命令/ 函数/ 由/ 上层/ 应用/ 通过/ 命令/ 接口/ 调用/ 进行/ 触发/ ;/ 编程/ 者/ 定义/ 的/ 事件/ 函数/ 由/ 底层/ TinyOS/ 通过/ 事件/ 接口/ 调用/ 进行/ 触发/ ./ 节点/ 上/ 具体/ 接口/ 调用/ 的/ 信息/ 可以/ 从/ 全局/ 节点/ 信息/ 表中/ 获得/ ./ 当/ 节点/ 进入/ 网络/ 时/ ,/ 需要/ 向/ 后台/ 运行/ 时/ 系统/ 进行/ 注册/ ./ 后台/ 运行/ 时/ 系统/ 在/ 接受/ 节点/ 注册/ 信息/ 后/ ,/ 会/ 在/ 全局/ 节点/ 信息/ 表中/ 增加/ 一个/ 节点/ 信息/ 表项/ ,/ 如表/ 1/ 所示/ ./ 出于/ 对/ 节点/ 安全性/ 的/ 考虑/ ,/ 节点/ 并未/ 开放/ 所有/ 的/ 接口/ 调用/ ./ 未/ 开放/ 接口/ 调用/ 的/ 信息/ 不会/ 被/ 放入/ 节点/ 注册/ 信息/ 中/ ,/ 也/ 是/ 无法/ 被/ 访问/ ./ 此外/ ,/ 由于/ TinyOS/ 对/ 事件/ 函数/ 的/ 触发/ 固定/ 的/ ,/ 每个/ 事件/ 接口/ 调用/ 只能/ 对应/ 于/ 一个/ 事件/ 函数/ ,/ 因此/ 需要/ 记录/ 当前/ 开放/ 的/ 事件/ 接口/ 调用/ 是否/ 已经/ 被/ 占用/ ./ (/ 3/ )/ 绑定/ 操作/ (/ BindOperation/ )/ ./ 利用/ 绑定/ 操作/ 可以/ 将/ 时间/ 属性/ 和/ 空间/ 属性/ 与/ 具体/ 对象/ 进行/ 绑定/ ./ 空间/ 属性/ 绑定/ 操作/ 如式/ (/ 6/ )/ 所示/ :/ SpaceBind/ (/ InterfaceProvider/ ,/ SpaceAttribute/ )/ 其中/ ,/ InterfaceProvider/ 是/ 接口/ 提供者/ ,/ 可以/ 通过/ 后台/ 运行/ 时/ 系统/ 获得/ ;/ SpaceAttribute/ 是/ 空间/ 属性/ ,/ 它/ 可以/ 由/ 4.1/ 节中/ 的/ 3/ 种/ 方式/ 进行/ 定义/ ./ 与/ 空间/ 属性/ 类似/ ,/ 时间/ 属性/ 的/ 绑定/ 操作/ 如式/ (/ 7/ )/ 所示/ :/ TimeBind/ (/ InterfaceCall/ ,/ TimeAttribute/ )/ (/ 7/ )/ 其中/ ,/ TimeAttribute/ 是/ 时间/ 属性/ ,/ 可以/ 通过/ 相对/ 时间/ 和/ 绝对/ 时间/ 进行/ 定义/ ;/ InterfaceCall/ 是/ 具体/ 接口/ 提供者/ 能够/ 提供/ 的/ 接口/ 调用/ ./ 很/ 明显/ ,/ 时间/ 绑定/ 操作/ 与/ 空间/ 绑定/ 操作/ 的/ 被/ 绑定/ 对象/ 是/ 不同/ 的/ ./ 这是/ 由于/ 接口/ 提供者/ 是/ 与/ 具体/ 节点/ 绑定/ ;/ 而/ 接口/ 调用/ 的/ 空间/ 属性/ 是/ 由/ 具体/ 节点/ 的/ 空间/ 属性/ 决定/ ./ 将/ 空间/ 属性/ 与/ 接口/ 提供者/ 进行/ 绑定/ ,/ 也/ 就/ 确定/ 了/ 接口/ 调用/ 的/ 空间/ 属性/ ./ 另一方面/ ,/ 接口/ 调用/ 与/ 代码/ 开始/ 执行/ 的/ 时间/ 密切相关/ ,/ 因此/ 接口/ 调用/ 需要/ 直接/ 与/ 时间/ 属性/ 进行/ 绑定/ ./ 图/ 4/ 展示/ 了/ 一个/ 具有/ 跑马灯/ 效果/ 的/ EasiSNP/ 顶层/ 应用程序/ ./ 它/ 实现/ 了/ 多个/ 节点/ 上/ LED/ 灯/ 的/ 协同/ Page6/ 循环/ 闪烁/ ./ 简要/ 说明/ 如下/ :/ 首先/ 在/ L2/ 中/ 定义/ 了/ Cont/ 个/ 接口/ 提供者/ Leds/ ./ 通过/ 查询/ 后台/ 运行/ 时/ 系统/ ,/ 程序/ 解释/ 系统/ 将/ 获得/ 至少/ Cont/ 个/ 能够/ 提供/ 接口/ leds/ 的/ 节点/ 作为/ 备用/ 节点/ (/ 接口/ leds/ 中/ 实际上/ 包含/ 了/ 若干/ 接口/ 调用/ ./ 如果/ 不做声/ 明/ ,/ 直接/ 定义/ 接口/ leds/ 则/ 表明/ 需要/ 包含/ leds/ 中/ 的/ 所有/ 接口/ 调用/ )/ ./ 如果/ 能够/ 提供/ 所/ 需/ 接口/ 调用/ 的/ 节点/ 数量/ 少于/ Cont/ 个/ ,/ EasiSNP/ 系统/ 可能/ 无法/ 完成/ 编程/ ./ 接下来/ ,/ Leds/ [/ 0/ ]/ 将/ 作为/ 跑马灯/ 的/ 起始/ 点/ 被/ 初始化/ (/ L3/ ~/ L4/ )/ ./ 通过/ SpaceBind/ 操作/ 要求/ 接口/ 提供者/ Leds/ [/ 0/ ]/ 与/ 距离/ 原点/ [/ 0/ ,/ 0/ ]/ 最近/ 的/ 节点/ 进行/ 绑定/ ;/ 并且/ 通过/ TimeBind/ 操作/ 将/ Leds/ [/ 0/ ]/ 的/ 命令/ 接口/ 调用/ leds/ ./ TurnOn/ (/ )/ 与/ 一个/ 绝对/ 时间/ 属性/ 进行/ 绑定/ ,/ 即/ 在/ 10/ :/ 00pm/ 打开/ 一个/ 距离/ 原点/ 最近/ 节点/ 上/ 的/ LED/ ,/ 并且/ 以/ 2s/ 作为/ 时间/ 间隔/ 周期/ 触发/ 接口/ 提供者/ Leds/ [/ 0/ ]/ 上/ 的/ 命令/ 接口/ 调用/ leds/ ./ TurnOn/ (/ )/ ./ 在/ 循环体/ 中/ ,/ Leds/ [/ i/ ]/ 将/ 通过/ SpaceBind/ 操作/ 和/ 某个/ 在/ 空间/ 位置/ 上/ 位于/ Leds/ [/ i/ -/ 1/ ]/ 左面/ 的/ 节点/ 进行/ 绑定/ (/ L5/ ~/ L8/ )/ ./ 然后/ 将/ Leds/ [/ i/ ]/ 的/ 命令/ 接口/ 调用/ leds/ ./ TurnOn/ (/ )/ 与/ 事件/ 接口/ 调用/ Leds/ [/ i/ -/ 1/ ]/ ./ leds/ ./ On/ (/ )/ 定义/ 的/ 相对/ 时间/ 属性/ 进行/ 绑定/ ./ 将/ Leds/ [/ i/ -/ 1/ ]/ 的/ 命令/ 接口/ 调用/ leds/ ./ TurnOff/ (/ )/ 与/ 事件/ 接口/ 调用/ Leds/ [/ i/ ]/ ./ leds/ ./ On/ (/ )/ 定义/ 的/ 相对/ 时间/ 属性/ 进行/ 绑定/ ./ 其/ 最终/ 效果/ 是/ 当前/ 节点/ LED/ 的/ 开启/ 状态/ 将/ 触发/ 位于/ 它/ 左边/ 的/ 下/ 一个/ 节点/ LED/ 的/ 开启/ 操作/ ,/ 同时/ 下/ 一个/ 节点/ LED/ 的/ 开启/ 状态/ 将/ 触发/ 位于/ 它/ 右边/ 节点/ LED/ 的/ 关闭/ 操作/ ./ 4.3/ 顶层/ 应用程序/ 分解/ EasiSMP/ 顶层/ 应用程序/ 不能/ 直接/ 被/ 传感器/ 节点/ 执行/ ,/ 需要/ 程序/ 解释/ 系统/ 将/ 顶层/ 应用程序/ 分解/ 为/ 节点/ 可/ 执行/ 的/ 任务/ 块/ (/ taskblock/ )/ ,/ 过程/ 如图/ 5/ 所示/ ./ 程序/ 解释/ 系统/ 首先/ 会/ 对/ 顶层/ 应用程序/ 中/ 定义/ 的/ 接口/ 提供者/ 进行/ 一次/ 检索/ ,/ 并/ 建立/ 检索/ 表/ ./ 由于/ 每个/ 接口/ 提供者/ 将/ 对应/ 于/ 一个/ 节点/ ,/ 因此/ 它/ 所/ 提供/ 的/ 接口/ 调用/ 将/ 被/ 放入/ 同一个/ ./ nc/ 文件/ 中/ ./ 同时/ ,/ 程序/ 解释/ 系统/ 会/ 向/ 后台/ 运行/ 时/ 系统/ 查询/ 当前/ 哪些/ 节点/ 能够/ 提供/ 这些/ 接口/ 调用/ ./ 如果/ 没有/ 找到/ 合适/ 节点/ ,/ 程序/ 解释/ 系统/ 会/ 向/ 编程/ 者/ 反馈/ 没有/ 节点/ 可以/ 提供/ 这些/ 接口/ 调用/ ./ 考虑/ 到/ 网络/ 的/ 动态性/ ,/ 未来/ 新/ 加入/ 的/ 节点/ 可能/ 具备/ 所/ 需/ 的/ 接口/ 调用/ ,/ 因此/ 编程/ 者/ 也/ 可以/ 通过/ 设定/ 较大/ TimeOut/ ,/ 在/ 当前/ 执行/ 顶层/ 应用程序/ 的/ 条件/ 不/ 具备/ 时/ ,/ 忽略/ 程序/ 解释/ 系统/ 的/ 反馈/ ./ 网络/ 会/ 在/ 条件/ 满足/ 时/ ,/ 以/ best/ -/ effort/ 的/ 方式/ 执行/ 顶层/ 应用程序/ [/ 10/ ]/ ./ 接下来/ ,/ 程序/ 解释/ 系统/ 将/ 继续/ 检索/ 顶层/ 应用程序/ 中/ 的/ SpaceBind/ 和/ TimeBind/ 操作/ ./ SpaceBind/ 操作/ 将/ 接口/ 提供者/ 与/ 编程/ 者/ 定义/ 的/ 空间/ 属性/ 进行/ 绑定/ ./ 由于/ 每个/ 接口/ 提供者/ 都/ 会/ 对应/ 独立/ 的/ ./ nc/ 文件/ ,/ 因此/ 每个/ ./ nc/ 文件/ 都/ 将/ 附加/ 一个/ 空间/ 属性/ ,/ 如图/ 5/ 所示/ ./ TimeBind/ 操作/ 将/ 接口/ 调用/ 与/ 编程/ 者/ 定义/ 的/ 时间/ 属性/ 进行/ 绑定/ ./ 如图/ 6/ (/ a/ )/ 所示/ ,/ 与/ 绝对/ 时间/ 绑定/ 的/ 接口/ 调用/ 可以/ 通过/ 节点/ 运行/ 时/ 系统/ 提供/ 的/ 全局/ 时间/ 事件/ 接口/ 调用/ 进行/ 触发/ ./ 被/ 绑定/ 的/ 接口/ 调用/ 将/ 转化/ 为/ 全局/ 时间/ 事件/ 函数/ (/ FTSPTimerFired/ )/ 的/ 内容/ ./ 如果/ 全局/ 时间/ 事件/ 函数/ 直接/ 由/ 底层/ TinyOS/ 进行/ 触发/ ,/ 由于/ 底层/ TinyOS/ 的/ 代码/ 不能/ 被/ 修改/ ,/ 实际上/ 只能/ 提供/ 有限/ 个数/ 的/ 对/ 全局/ 时间/ 事件/ 函数/ 的/ 触发/ ./ 当/ 多个/ 任务/ 块/ 部署/ 到/ 节点/ 上时/ ,/ 可能/ 需要/ 对/ 多个/ 全局/ 时间/ 事件/ 函数/ 进行/ 触发/ ./ 在/ 这里/ 需要/ 节点/ 运行/ 时/ 系统对/ 多个/ 全局/ 时间/ 事件/ 接口/ 进行/ 协调/ ,/ 即/ 由/ TinyOS/ 触发/ 节点/ 运行/ 时/ 系统/ ,/ 然后/ 由/ 节点/ 运行/ 时/ 系统/ 触发/ 对应/ 的/ 全局/ 时间/ 事件/ 函数/ ./ 与/ 相对/ 时间/ 绑定/ 的/ 接口/ 调用/ 可以/ 通过/ 具体/ 的/ 事件/ 接口/ 调用/ 进行/ 触发/ ./ 但是/ 具体/ 到/ 每/ 一个/ 事件/ ,/ 需要/ 区分/ 事件/ 本身/ 是否/ 发生/ 在/ 节点/ 本地/ ,/ 换/ 而言/ 之/ ,/ 需要/ 判断/ 事件/ 接口/ 调用/ 的/ 提供者/ 与/ 接口/ 调用/ 的/ 提供者/ 是否/ 相同/ ./ 如图/ 6/ (/ b/ )/ 所示/ ,/ 如果/ 事件/ 发生/ 在/ 节点/ 本地/ ,/ 即/ 事件/ 接口/ 调用/ 的/ 提供者/ 和/ 接口/ 调用/ 的/ 提供者/ 均/ 为/ 接口/ 提供者/ B/ ,/ 则/ 可以/ 由/ 本地/ 节点/ 的/ 底层/ TinyOS/ 提供/ 的/ 事件/ 接口/ 调用/ 直接/ 触发/ ./ 如果/ 事件/ 本身/ 不是/ 发生/ 在/ 节点/ 本地/ ,/ 即/ 需要/ 由/ 接口/ 提供者/ A/ 提供/ 事件/ 接口/ 调用/ ./ 如图/ 6/ (/ c/ )/ 所示/ ,/ 接口/ 提供者/ A/ 提供/ 的/ 事件/ 接口/ 调用/ 需要/ 触发/ 一个/ 特殊/ 的/ 事件/ 函数/ ,/ 其/ 内容/ 是/ 告知/ 当前/ 接口/ 提供者/ A/ 所/ 绑定/ 节点/ 的/ 运行/ 时/ 系统/ 事件/ 已经/ 发生/ ,/ 由/ 这个/ 节/ Page7/ 图/ 6/ 绑定/ 时间/ 属性/ 转化/ 示意图/ 点/ 运行/ 时/ 系统/ 向/ 接口/ 提供者/ B/ 所/ 绑定/ 节点/ 的/ 运行/ 时/ 系统/ 传递/ 事件/ 发生/ 的/ 消息/ ./ 而/ 接口/ 提供者/ B/ 所/ 绑定/ 节点/ 的/ 运行/ 时/ 系统/ 在/ 接受/ 到/ 这个/ 消息/ 后/ ,/ 会/ 触发/ 相应/ 的/ 事件/ 函数/ ,/ 其/ 内容/ 是/ 执行/ 被/ 绑定/ 的/ 接口/ 调用/ ./ 由于/ 接口/ 调用/ 的/ 时间/ 属性/ 是/ 由/ 事件/ 接口/ 调用/ 转化/ 而来/ ./ 如果/ 当前/ 节点/ 不能/ 提供/ 这个/ 事件/ 接口/ 调用/ 或者/ 开放/ 的/ 事件/ 接口/ 调用/ 已经/ 被/ 占用/ ,/ 则/ 意味着/ 当前/ 的/ 节点/ 不/ 能够/ 满足/ 接口/ 调用/ 绑定/ 的/ 时间/ 属性/ ./ 4.4/ 任务/ 块/ 生成/ 从图/ 5/ 中/ 可以/ 看出/ ,/ 任务/ 块/ 是/ 由/ NesC/ 程序/ 生成/ 的/ 可/ 执行/ 代码/ 以及/ 相关/ 函数/ 管理/ 列表/ 组成/ ,/ 其中/ 可/ 执行/ 代码/ 的/ 生成/ 与/ 节点/ 类型/ 密切相关/ ./ 在/ 程序/ 解释/ 系统生成/ 附加/ 有/ 空间/ 属性/ 的/ ./ nc/ 文件/ 后/ ,/ 需要/ 第/ 2/ 次/ 向/ 后台/ 运行/ 时/ 系统/ 发起/ 查询/ 请求/ ./ 查询/ 的/ 范围/ 是/ 首次/ 查询/ 中/ 可以/ 充当/ 接口/ 提供者/ 的/ 节点/ ;/ 查询/ 内容/ 是/ 这些/ 节点/ 当前/ 的/ 空间/ 位置/ 是否/ 满足/ ./ nc/ 附加/ 的/ 空间/ 属性/ ,/ 以及/ 是否/ 能够/ 提供/ 时间/ 属性/ 转化/ 来/ 的/ 事件/ 表/ 3/ 函数/ 管理/ 描述/ (/ CalledCommandFunctionList/ ,/ CCFL/ )/ (/ FunctionIndirectCallList/ ,/ FICL/ )/ (/ FunctionAddressVectorList/ ,/ FAVL/ )/ 4.5/ 任务/ 块/ 加载/ 命令/ 函数/ 是/ 节点/ 底层/ 操作系统/ TinyOS/ 的/ 一部分/ ./ 它们/ 在/ 任务/ 块/ 迁移/ 之前/ ,/ 已经/ 保存/ 在/ 节点/ 上/ ,/ 其/ 函数/ 地址/ 是/ 固定/ 的/ ./ 当/ 任务/ 块/ 迁移/ 到/ 节点/ 上时/ ,/ 任务/ 块/ 中/ 对/ 命令/ 函数/ 的/ 调用/ 指令/ 需要/ 根据/ 命令/ 函数/ 的/ 实际/ 地址/ 进行/ 修改/ ./ 但是/ ,/ 为了/ 使/ 任务/ 块/ 能够/ 在/ 节点/ 之间/ 进行/ 迁移/ ,/ 又/ 不/ 可能/ 频繁/ 修改/ 任务/ 块/ 中/ 所有/ 对/ 命令/ 函数/ 的/ 调用/ 指令/ ,/ 我们/ 使用/ 寄存器/ 间接/ 寻址/ 的/ 方/ 接口/ 调用/ ./ 程序/ 解释/ 系统/ 会/ 根据/ 反馈/ 回来/ 的/ 节点/ 信息/ ,/ 选择/ 合适/ 的/ 编译/ 参数/ 和/ 交叉/ 编译器/ ,/ 对/ ./ nc/ 文件/ 中/ 的/ NesC/ 程序/ 进行/ 编译/ ,/ 生成/ 节点/ 可/ 执行/ 代码/ ./ 如果/ 满足/ 任务/ 块/ 时空/ 属性/ 的/ 节点/ 数量/ 仍然/ 超过/ 所/ 需/ ,/ 由于/ 任务/ 块/ 可以/ 通过/ 内部/ 迁移/ 保存/ 在/ 节点/ 的/ 外部/ 扩展/ 存储器/ 中/ (/ 详见/ 4.5/ 节/ )/ ,/ 程序/ 解释/ 系统/ 会/ 优先选择/ 已/ 保存/ 有/ 当前任务/ 块/ 的/ 节点/ ,/ 并/ 将/ 剩余/ 节点/ 作为/ 备用/ 节点/ ./ 最终/ ,/ 任务/ 块/ 的/ 相关/ 信息/ 被/ 记录/ 到/ 任务/ 块/ 管理/ 列表/ 中/ ,/ 方便/ 以后/ 对/ 该/ 任务/ 块/ 的/ 迁移/ ./ 表/ 2/ 显示/ 了/ 一个/ 任务/ 块/ 管理/ 列表/ 中/ 的/ 表项/ ./ 此外/ ,/ 为了/ 使/ 任务/ 块/ 能够/ 在/ 节点/ 上/ 顺利/ 加载/ 和/ 执行/ ,/ 需要/ 在/ 任务/ 块/ 中/ 附加/ 两个/ 函数/ 管理/ 列表/ :/ 被/ 调用/ 命令/ 函数/ 列表/ (/ CalledCommandFunctionList/ ,/ CCFL/ )/ 和/ 事件/ 函数/ 列表/ (/ EventFunctionList/ ,/ EFL/ )/ ,/ 如表/ 3/ 所示/ ./ 两个/ 函数/ 列表/ 分别/ 用于/ 任务/ 块/ 对/ 命令/ 函数/ 的/ 调用/ 和/ 底层/ TinyOS/ 对/ 事件/ 函数/ 的/ 调用/ ,/ 如图/ 7/ 所示/ ./ 法/ 实现/ 对/ 节点/ 上/ 的/ 命令/ 函数/ 进行/ 调用/ ,/ 具体方法/ 如下/ 所述/ ./ 在/ 生成/ 任务/ 块/ 时/ ,/ 任务/ 块/ 中/ 每/ 一条/ 对/ 命令/ 函数/ 的/ 调用/ 指令/ 都/ 被/ 修改/ 为/ 寄存器/ 间接/ 寻址/ 模式/ ,/ 如式/ (/ 8/ )/ 所示/ :/ 与/ 传统/ 寄存器/ 间接/ 寻址/ 不同/ ,/ 我们/ 在/ 这里/ 通过/ 对/ 二进制/ 代码/ 的/ 修改/ ,/ 实际上/ 使用/ 寄存器/ Rx/ 保存/ 了/ 基/ Page8/ 图/ 7/ 命令/ 函数/ 与/ 事件/ 函数/ 的/ 链接/ 与/ 调用/ (/ 其中/ :/ (/ 1/ )/ 任务/ 块/ 与/ 命令/ 函数/ 的/ 链接/ ;/ (/ 2/ )/ TinyOS/ 系统/ 与/ 事件/ 函数/ 的/ 链接/ ;/ 地址/ ,/ 而/ cont/ 的/ 值/ 将/ 由/ 程序/ 解释/ 系统/ 根据/ 对/ 命令/ 函数/ 进行/ 调用/ 的/ 指令/ 在/ 任务/ 块/ 中/ 的/ 地址/ 顺序/ 决定/ ./ 相同/ 的/ 调用/ 指令/ 可能/ 出现/ 在/ 任务/ 块/ 的/ 不同/ 地址/ 上/ ,/ 以低/ 地址/ 的/ 调用/ 指令/ 为准/ ./ 同时/ ,/ 任务/ 块/ 中/ 附加/ 的/ CCFL/ 包含/ 了/ 任务/ 块/ 中/ 所有/ 被/ 调用/ 命令/ 函数/ 的/ 编号/ ,/ 并且/ 编号/ 的/ 存储/ 顺序/ 按照/ 调用/ 指令/ 在/ 任务/ 块/ 中/ 的/ 保存/ 地址/ 以/ 由/ 低/ 到/ 高/ 的/ 顺序/ 进行/ 排列/ ./ 节点/ 运行/ 时/ 系统/ 需要/ 维护/ 两个/ 关于/ 命令/ 函数/ 的/ 列表/ :/ 命令/ 函数/ 列表/ (/ CommandFunctionList/ ,/ CFL/ )/ 和/ 函数/ 地址/ 向量/ 表/ (/ FunctionAddressVectorList/ ,/ FAVL/ )/ ./ CFL/ 保存/ 了/ 当前/ 节点/ 上/ 所有/ 命令/ 函数/ 的/ 入口/ 地址/ ./ FAVL/ 是/ 根据/ 每个/ 加载/ 到/ 节点/ 上/ 的/ 任务/ 块/ 动态/ 生成/ 的/ ,/ 它/ 记录/ 了/ 在/ 任务/ 块/ 中/ 调用/ 的/ 命令/ 函数/ 真实/ 入口/ 地址/ ./ 由于/ 使用/ 了/ 寄存器/ 间接/ 寻址/ 的/ 方式/ 对/ 命令/ 函数/ 进行/ 调用/ ,/ FAVL/ 函数/ 入口/ 地址/ 的/ 顺序/ 与/ CCFL/ 中/ 的/ 函数/ 排列/ 顺序/ 保持一致/ ./ 考虑/ 到/ 可能/ 存在/ 多个/ 任务/ 块/ 在/ 节点/ 上/ 运行/ ,/ 可以/ 通过/ 对/ 寄存器/ (/ Rx/ )/ 进行/ 初始化/ ,/ 给/ 每个/ 任务/ 块/ 的/ FAVL/ 分配/ 独立/ 的/ 存储空间/ ,/ 如式/ (/ 9/ )/ 所示/ :/ 其中/ FAVL/ _/ addr/ 是/ 任务/ 块/ 对应/ 的/ FAVL/ 首/ 地址/ ./ 这条/ 初始化/ 语句/ 必须/ 放置/ 在/ 任务/ 块/ 的/ 起始/ 位置/ ./ 当/ 任务/ 块/ 加载/ 到/ 节点/ 中/ 时/ ,/ 节点/ 运行/ 时/ 系统/ 需要/ 根据/ 当前/ 已/ 存储/ FAVL/ 的/ 情况/ 修改/ 这/ 条/ 语句/ ./ 图/ 7/ 中/ (/ 1/ )/ 所/ 标识/ 的/ 路径/ 显示/ 了/ 任务/ 块/ 的/ 调用/ 指令/ 与/ 命令/ 函数/ 的/ 链接/ 过程/ ./ 首先/ 节点/ 运行/ 时/ 系统/ 获得/ 当前任务/ 块/ 对应/ FAVL/ 的/ 首/ 地址/ ,/ 并/ 通过/ 式/ (/ 9/ )/ 中/ 的/ 赋值/ 命令/ 将/ 这个/ 首/ 地址/ 赋值/ 给/ 寄存器/ Rx/ ./ 然后/ 运行/ 时/ 系统/ 会/ 读取/ CCFL/ ,/ 并/ 在/ CFL/ 中/ 查找/ 对应/ 函数/ 的/ 真实/ 入口/ 地址/ ./ 这些/ 真实/ 入口/ 地址/ 将/ 按照/ CCFL/ 中/ 函数/ 的/ 排列/ 顺序/ 生成/ FAVL/ ./ 最终/ ,/ 节点/ 运行/ 时/ 系统/ 会/ 将/ 任务/ 块/ 的/ FAVL/ 保存/ 在/ 节点/ 主/ 内存/ 中/ ./ 图/ 7/ 中/ (/ 3/ )/ 所/ 标识/ 的/ 路径/ 显示/ 了/ 一个/ 任务/ 块/ 中/ 的/ 调用/ 指令/ (/ call32/ (/ Rx/ )/ )/ 对/ TinyOS/ 中/ 的/ 命令/ 函数/ (/ Led0/ ./ TurnOn/ (/ )/ )/ 进行/ 调用/ 的/ 过程/ ./ 任务/ 块/ 中/ 对/ 命令/ 函数/ 进行/ 调用/ 的/ 指令/ 需要/ 从/ FAVL/ 中/ 获得/ 命令/ 函数/ 的/ 真实/ 地址/ (/ 0x4100/ )/ ./ 另一方面/ ,/ 事件/ 函数/ 在/ 任务/ 块/ 中/ 定义/ ,/ 由/ 底层/ TinyOS/ 进行/ 调用/ ./ TinyOS/ 对/ 事件/ 函数/ 的/ 调用/ 指令/ 已经/ 在/ 主程序/ 中/ 固定/ ,/ 不能/ 被/ 修改/ ./ 而/ 事件/ 函数/ 的/ 真实/ 地址/ 只有/ 任务/ 块/ 在/ 迁移/ 到/ 节点/ 上/ 之后/ 才能/ 被/ 确定/ ./ EasiSNP/ 采用/ 函数/ 的/ 间接/ 调用/ 解决/ 这个/ 问题/ [/ 11/ ]/ ./ 如图/ 7/ 所示/ ,/ 节点/ 运行/ 时/ 系统/ 需要/ 维护/ 一个/ 函/ Page9/ 数/ 间接/ 调用/ 表/ (/ FunctionIndirectCallList/ ,/ FICL/ )/ ./ 如果/ 节点/ 开放/ 了/ 某个/ 事件/ 接口/ 调用/ ,/ 则/ 对应/ 事件/ 函数/ 的/ 调用/ 指令/ 需要/ 指向/ FICL/ 中/ 的/ 某个/ 表项/ ./ FICL/ 每个/ 表项/ 保存/ 一条/ 对/ 事件/ 函数/ 的/ 调用/ 指令/ 以及/ 一条/ 返回/ 指令/ ./ 由于/ 任务/ 块/ 对于/ 事件/ 接口/ 调用/ 具有/ 独占性/ ,/ 因此/ 所有/ 加载/ 到/ 节点/ 上/ 的/ 任务/ 块/ 将/ 共享/ 同一个/ FICL/ ./ 当/ 节点/ 运行/ 时/ 系统/ 发现/ 当前/ 事件/ 接口/ 调用/ 已经/ 被/ 某个/ 任务/ 块/ 占用/ ,/ 在/ 这个/ 任务/ 块/ 失效/ 之前/ ,/ 节点/ 将/ 不能/ 再/ 提供/ 对应/ 的/ 事件/ 接口/ 调用/ ./ 任务/ 块/ 中/ 附加/ 的/ EFL/ 包含/ 了/ 任务/ 块/ 中/ 所有/ 事件/ 函数/ 的/ 相对/ 地址/ (/ 相对/ 于/ 任务/ 块首/ 地址/ )/ ./ 当/ 任务/ 块/ 加载/ 到/ 节点/ 上时/ ,/ 需要/ 根据/ 这/ 条/ 相对/ 地址/ 实时/ 计算/ 出/ 事件/ 函数/ 的/ 真实/ 入口/ 地址/ ,/ 并/ 修改/ 相应/ 的/ FICL/ 表项/ ./ 图/ 7/ 中/ (/ 2/ )/ 所/ 标识/ 的/ 路径/ 显示/ 了/ 一个/ 主程序/ (/ TinyOS/ )/ 中/ 的/ 调用/ 指令/ 与/ 事件/ 函数/ Time1/ ./ fired/ (/ )/ 的/ 链接/ 过程/ ./ 首先/ 节点/ 运行/ 时/ 系统/ 获得/ 任务/ 块/ 在/ 节点/ 主/ 内存/ 中/ 的/ 起始/ 地址/ (/ 0x8000/ )/ ./ 然后/ 在/ 这个/ 起始/ 地址/ 的/ 基础/ 上/ ,/ 根据/ EFL/ 中/ 的/ 事件/ 函数/ 的/ 相对/ 地址/ (/ $/ +/ 0x124/ )/ 计算/ 出/ 事件/ 函数/ 真实/ 入口/ 地址/ (/ 0x8124/ )/ ./ 最终/ ,/ 根据/ 事件/ 函数/ 的/ 真实/ 入口/ 地址/ 修改/ FICL/ 中/ 对应/ 的/ 表项/ ./ 图/ 7/ 中/ (/ 4/ )/ 显示/ 了/ 主/ 函数/ 中/ 的/ 调用/ 指令/ 对/ 任务/ 块/ 中/ 的/ 事件/ 函数/ 进行/ 调用/ 的/ 过程/ ./ 调用/ 指令/ 并/ 没有/ 直接/ 跳转/ 到/ 事件/ 函数/ Timer1/ ./ fired/ (/ )/ 上/ ,/ 而是/ 先/ 跳转/ 到/ FICL/ 中/ 的/ 对应/ 表项/ ./ 该/ 表项/ 中/ 包含/ 了/ 函数/ Timer1/ ./ fired/ (/ )/ 的/ 真实/ 地址/ ,/ 并/ 由/ 表项/ 中/ 的/ 调用/ 指令/ 完成/ 对/ Timer1/ ./ fired/ (/ )/ 的/ 调用/ ./ 4.6/ 任务/ 块/ 迁移/ 传感器/ 网络/ 的/ 动态性/ 决定/ 了/ 任务/ 的/ 执行/ 存在/ 不可/ 预知/ 性/ ./ 特别/ 是/ 基于/ 时空/ 属性/ 进行/ 编程/ 时/ ,/ 由于/ 存在/ 多种/ 影响/ 时空/ 属性/ 的/ 外部/ 因素/ ,/ 即使/ 任务/ 块/ 已经/ 被/ 加载/ 到/ 各个/ 节点/ 上/ ,/ 也/ 不能/ 保证/ 顶层/ 应用程序/ 能够/ 顺利/ 执行/ ./ 为此/ 我们/ 提出/ 了/ 任务/ 块/ 迁移/ 机制/ ,/ 其/ 核心思想/ 是/ 如果/ 节点/ 不能/ 满足/ 任务/ 块/ 的/ 时空/ 属性/ 或者/ 节点/ 失效/ 时/ ,/ 任务/ 块/ 将/ 被/ 迁移/ ./ 任务/ 块/ 迁移/ 机制/ 包含/ 节点/ 内/ 迁移/ 和/ 节点/ 间/ 迁移/ ,/ 前者/ 主要/ 降低/ 了/ 节点/ 重复/ 加载/ 相同/ 任务/ 块/ 带来/ 的/ 额外/ 开销/ ,/ 后者/ 实现/ 了/ 任务/ 块/ 在/ 节点/ 之间/ 的/ 动态/ 部署/ ./ 节点/ 内/ 迁移/ 是/ 将/ 主/ 内存/ 中/ 保存/ 的/ 任务/ 块/ 转存/ 到/ 节点/ 外部/ 扩展/ 存储器/ 上/ ./ 当前/ 主/ 内存/ 中/ 可能/ 保存/ 了/ 若干/ 失效/ 任务/ 块/ ,/ 例如/ 由/ 时间/ 属性/ 定义/ 的/ 单次/ 触发/ (/ shot/ )/ 任务/ 块/ 在/ 被/ 执行/ 后/ ,/ 可能/ 很长/ 一段时间/ 不再/ 被/ 执行/ ;/ 或者/ ,/ 节点/ 离开/ 了/ 当前/ 位置/ ,/ 新/ 的/ 空间/ 位置/ 不能/ 满足/ 任务/ 块/ 的/ 空间/ 属性/ ,/ 此时/ 任务/ 块/ 将/ 不再/ 有效/ ./ 在/ 节点/ 主/ 内存容量/ 有限/ 的/ 情况/ 下/ ,/ 节点/ 运行/ 时/ 系统/ 需要/ 动态/ 使用/ 新/ 加载/ 任务/ 块/ 覆盖/ 失效/ 任务/ 块/ ./ 但是/ 如果/ 未来/ 部署/ 的/ 顶层/ 应用程序/ ,/ 仍/ 需要/ 节点/ 执行/ 这部分/ 失效/ 任务/ 块/ 时/ ,/ 不得不/ 将/ 它们/ 重新/ 传输/ 到/ 节点/ 上/ ./ 特别/ 当/ 需要/ 频繁/ 重复/ 部署/ 多个/ 顶层/ 应用程序/ 时/ ,/ 相同/ 任务/ 块/ 在/ 网络/ 中/ 的/ 重复/ 传输/ 会/ 造成/ 较大/ 的/ 额外/ 开销/ ./ 因此/ 将/ 失效/ 任务/ 块/ 迁移/ 到/ 节点/ 的/ 外部/ 存储器/ 中/ ,/ 可以/ 在/ 很大/ 程度/ 上/ 节省/ 由于/ 重传/ 任务/ 块/ 带来/ 的/ 能量/ 开销/ ,/ 同时/ 也/ 缩短/ 了/ 部署/ 时间/ ./ 节点/ 间/ 迁移/ 是/ 指/ 将/ 任务/ 块/ 由源/ 节点/ 传输/ 并/ 加载/ 目标/ 节点/ 上/ ./ 按照/ 源/ 节点/ 的/ 不同/ ,/ 可以/ 分为/ 计算机/ 端到/ 节点/ 端的/ 迁移/ 和/ 节点/ 端到/ 节点/ 端的/ 迁移/ ./ 节点/ 端到/ 节点/ 端的/ 迁移/ 主要/ 适用/ 于/ 当前/ 节点/ 的/ 空间/ 位置/ 无法/ 满足/ 任务/ 块/ 的/ 空间/ 属性/ 时/ ,/ 将/ 任务/ 块/ 迁移/ 到/ 备用/ 节点/ 上/ ./ 节点/ 运行/ 时/ 系统/ 发现/ 节点/ 位置/ 发生变化/ 后/ ,/ 会/ 发出/ 位置/ 变更/ 消息/ 给/ 后台/ 运行/ 时/ 系统/ ./ 后台/ 运行/ 时/ 系统/ 将/ 完成/ 3/ 步/ 工作/ :/ (/ 1/ )/ 通过/ 检索/ 任务/ 块/ 列表/ ,/ 检查/ 新/ 的/ 空间/ 位置/ 是否/ 满足/ 任务/ 块/ 绑定/ 的/ 空间/ 属性/ ./ (/ 2/ )/ 如果/ 有/ 任务/ 块/ 在/ 节点/ 位置/ 改变/ 后/ 失效/ ,/ 检查/ 是否/ 有/ 备用/ 节点/ 满足/ 当前/ 失效/ 任务/ 块/ 的/ 空间/ 属性/ ./ (/ 3/ )/ 选择/ 合适/ 的/ 备用/ 绑定/ 节点/ 作为/ 替换/ 节点/ ./ 在/ 位置/ 改变/ 节点/ 与/ 替换/ 节点/ 之间/ 建立/ 传输/ 管道/ ,/ 将/ 任务/ 块/ 发往/ 替换/ 节点/ ./ 计算机/ 端到/ 节点/ 端的/ 迁移/ 是/ 指/ 计算机/ 端/ 重新/ 将/ 任务/ 块/ 迁移/ 到/ 备用/ 节点/ 之上/ ./ 当/ 节点/ 失效/ (/ 如/ 信道/ 不/ 稳定/ 、/ 电池/ 耗尽/ 等/ )/ 时/ ,/ 已经/ 无法/ 将/ 其/ 保存/ 的/ 任务/ 块/ 进行/ 传输/ ,/ 这些/ 任务/ 块/ 由/ 计算机/ 端/ 重新部署/ 到/ 备用/ 节点/ 之上/ ./ 实际上/ ,/ 根据/ 具体/ 节点/ 是否/ 永久性/ 脱离/ 网络/ ,/ 需要/ 进行/ 分别/ 处理/ ./ 如果/ 节点/ 是/ 永久性/ 脱离/ ,/ 则/ 部署/ 到/ 备用/ 节点/ 之上/ 的/ 任务/ 块/ 不会/ 再/ 发生变化/ ./ 否则/ ,/ 如果/ 当前/ 节点/ 只是/ 暂时性/ 脱离/ ,/ 因为/ 当前/ 节点/ 可能/ 是/ 满足/ 任务/ 块/ 时空/ 属性/ 的/ 最优/ 节点/ ,/ 我们/ 仍然/ 希望/ 当/ 它/ 恢复/ 时够/ 继续执行/ 任务/ 块/ ./ 因此/ 部署/ 到/ 备用/ 节点/ 之上/ 的/ 任务/ 块/ 需要/ 通过/ 节点/ 内部/ 迁移/ 保存/ 到/ 外部/ 扩展/ 存储器/ 中/ ./ 当/ 最优/ 节点/ 再次/ 失效/ 时/ ,/ 不再/ 需要/ 从/ 计算机/ 端/ 向/ 备用/ 节点/ 加载/ 任务/ 块/ ,/ 而/ 直接/ 进行/ 任务/ 块/ 切换/ ./ Page105/ 实验/ 结果/ 与/ 分析/ 在/ 本节/ 中将/ 通过/ 实验/ 验证/ EasiSNP/ 的/ 有效性/ ./ 5.1/ 节/ 介绍/ 分析/ 了/ 两个/ 应用/ 于/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ 的/ 顶层/ 应用程序/ ./ 5.2/ 节/ 将/ 从/ 编程/ 开销/ 、/ 通信/ 开销/ 和/ 存储/ 开销/ 3/ 个/ 方面/ 对/ EasiSNP/ 的/ 性能/ 进行/ 分析/ ./ 最后/ 在/ 5.3/ 节/ 通过/ 仿真/ 实验/ 测试/ EasiSNP/ 在/ 减少/ 数据/ 延时/ 方面/ 的/ 有效性/ ./ 5.1/ 实验/ 场景/ 介绍/ 当前/ ,/ 我们/ 在/ 太湖/ 部署/ 的/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ 采用/ 了/ TD/ -/ CDMA/ (/ 3G/ )/ 和/ 802.15/ ./ 4/ 两种/ 网络/ ./ 感知/ 层/ 网络/ 采用/ 树状/ 拓扑/ 结构/ ,/ 传感器/ 节点/ 通过/ 802.15/ ./ 4/ 网络/ ,/ 以多/ 跳/ 传输/ 的/ 方式/ 将/ 感知/ 数据/ 发/ 往/ 汇聚/ 节点/ (/ sink/ )/ ./ 汇聚/ 节点/ 将/ 各个/ 节点/ 的/ 数据/ 进行/ 简单/ 处理/ 后/ ,/ 通过/ 3G/ 数据网络/ 发/ 往/ 云端/ ./ 由于/ 802.15/ ./ 4/ 网络/ 是/ 一种/ 低功耗/ 低/ 速率/ 的/ 个人/ 局域网络/ ,/ 其/ 通信/ 链路/ 易/ 受到/ 天气/ 等/ 环境因素/ 的/ 影响/ ./ 在/ 采用/ 树形/ 拓扑/ 的/ 感知/ 层/ 网络/ 中/ ,/ 单个/ 转发/ 节点/ 的/ 信道/ 阻塞/ ,/ 可能/ 导致/ 大量/ 需要/ 转发/ 的/ 数据/ 被/ 阻塞/ ,/ 不利于/ 对/ 蓝藻/ 爆发/ 的/ 实时/ 监控/ ./ 通过/ 编写/ EasiSNPRealTime/ (/ Sensor/ [/ i/ ]/ ./ CheckChanel/ ./ Jam/ ,/ 30min/ ,/ Peri/ ,/ 1min/ )/ ;/ }/ L15TimeBind/ (/ ExecUnit/ ./ DataProcess/ ./ Forward/ ,/ ReltTime/ (/ ExecUnit/ ./ DataProcess/ ./ SaveDone/ &/ // L16TimeBind/ (/ Sink/ ./ Send/ _/ 3G/ ./ send/ ,/ ReltTime/ (/ Sink/ ./ DataProcess/ ./ Savedone/ ,/ 100ms/ ,/ Shot/ ,/ Null/ )/ )/ ;/ 图/ 8/ 协助/ 数据/ 转发/ 的/ 顶层/ 应用程序/ 另一方面/ ,/ 移动/ 的/ 执行/ 单元/ 可能/ 在/ 打捞/ 的/ 过程/ 中/ ,/ 希望/ 实时/ 获得/ 当前/ 局部/ 的/ 蓝藻/ 信息/ ./ 为此/ ,/ 我们/ 设计/ 了/ 图/ 9/ 所示/ 的/ EasiSNP/ 顶层/ 应用程序/ ,/ ExecUnit/ 动态/ 地/ 与/ 距离/ 其/ 4/ 跳/ 范围/ 内/ 的/ Sensor/ 进行/ 绑定/ (/ L8/ )/ ./ 4/ 跳/ 范围/ 内/ 的/ Sensor/ 对/ 水质/ 的/ 温度/ 和/ 酸碱度/ 进行/ 周期/ 采样/ ,/ 并/ 将/ 采样/ 数据/ 发/ 往/ 执行/ 单元/ (/ L7/ ~/ L10/ )/ ./ 基于/ 以上/ 两个/ 例子/ 程序/ 以及/ 图/ 4/ 所示/ 的/ 跑马/ 顶层/ 应用程序/ ,/ 可以/ 要求/ 网络/ 本身/ 寻找/ 位于/ 失效节点/ 附近/ 的/ 有效/ 节点/ ,/ 协助/ 数据/ 的/ 转发/ ./ 根据/ 太湖/ 监测/ 环境/ 的/ 特殊性/ ,/ 协助/ 数据/ 转发/ 的/ 节点/ 可以/ 由/ 执行/ 打捞/ 任务/ 的/ 移动/ 执行/ 单元/ 充当/ ./ 图/ 8/ 给出/ 了/ 协助/ 数据/ 转发/ 的/ 顶层/ 应用程序/ ./ 在/ 这个/ 顶层/ 应用程序/ 中/ ,/ 首先/ 声明/ 4/ 种/ 接口/ 提供者/ (/ L1/ ~/ L10/ )/ :/ Sink/ 、/ Sensor/ 、/ Forwarder/ 和/ ExecUnit/ ./ 首先/ ,/ Sensor/ 在/ 一/ 跳/ 范围/ 内/ 绑定/ 一个/ ExecUnit/ ,/ 并且/ 测试/ 能否/ 得到/ 下/ 一/ 跳/ Forwarder/ 的/ 回应/ ./ 如果/ 没有/ 回应/ ,/ 则/ 说明/ 到/ 下/ 一/ 跳/ Forwarder/ 的/ 信道/ 可能/ 阻塞/ ,/ 事件/ Jam/ 发生/ ./ Sensor/ 把/ 数据/ 发送给/ ExecUnit/ (/ L11/ ~/ L13/ )/ ./ ExecUnit/ 在/ 保存/ 完整/ 的/ 数据/ 之后/ ,/ 会/ 触发/ SaveDone/ 接口/ 调用/ ,/ 表示/ 数据/ 可以/ 被/ 转发/ 出去/ ./ 这时/ 如果/ ExecUnit/ 能够/ 到达/ Forwarder/ 的/ 一/ 跳/ 范围/ 内/ ,/ 则/ 将/ 数据/ 发送/ 出去/ (/ L14/ ~/ L15/ )/ ./ 同时/ ,/ 如果/ 这些/ 数据/ 被/ 转发/ 到/ Sink/ ,/ 则/ 会/ 触发/ Sink/ 上/ 的/ SaveDone/ 接口/ 调用/ ./ 由/ L16/ 可知/ ,/ Sink/ 立即/ 会/ 调用/ Send/ _/ 3G/ ./ Send/ 向/ 云端/ 传输/ 这些/ 数据/ ./ 值得注意/ 的/ 是/ 由于/ 充当/ 接口/ 提供者/ Forward/ 和/ Sink/ 的/ 节点/ 将/ 由/ 网络/ 动态/ 指定/ ,/ 因此/ 汇聚/ 节点/ 可能/ 同时/ 充当/ 这/ 两个/ 接口/ 提供者/ 的/ 角色/ ./ 灯/ 顶层/ 应用程序/ ,/ 我们/ 设计/ 了/ 3/ 个/ 实验/ 场景/ 测试/ EasiSNP/ 的/ 各项/ 性能/ :/ Case1/ ./ 编写/ 跑马灯/ 的/ 顶层/ 应用程序/ ,/ 并/ 部署/ 到/ 网络/ 中/ ./ 跑马灯/ 仅/ 是/ 通过/ 邻/ 节点/ LED/ 状态/ 对/ 当前/ 节点/ 上/ LED/ 灯/ 进行/ 控制/ ,/ 控制/ 逻辑/ 较为简单/ ,/ 编写/ 和/ 传输/ 的/ 代码/ 量/ 较/ 小/ ./ Case2/ ./ 编写/ 实时/ 采集/ 数据/ 的/ 顶层/ 应用程序/ ,/ 并/ Page11/ 部署/ 到/ 网络/ 中/ ./ 实时/ 采集/ 数据/ 主要/ 是/ 对/ 普通/ 感知/ 节点/ 的/ 温度/ 和/ 湿度/ 传感/ 进行/ 数据/ 采集/ 和/ 传输/ ./ 普通/ 节点/ 的/ 空间/ 属性/ 需要/ 通过/ 跳数/ (/ hop/ )/ 定义/ ,/ 且/ 移动/ 节点/ 的/ 位置/ 是/ 不断/ 变化/ 的/ ,/ 因此/ 需要/ 向/ 节点/ 加载/ 一个/ 能够/ 动态分析/ 距离/ 移动/ 节点/ 跳数/ 的/ 代码段/ ./ ReltTime/ (/ Sensor/ ./ WaterTempra/ ./ StartDone/ &/ Sensor/ ./ WaterPH/ ./ StartDone/ ,/ 100ms/ ,/ Shot/ ,/ Null/ )/ )/ ;/ 图/ 9/ 实时/ 采集/ 感知/ 数据/ 的/ 顶层/ 应用程序/ 5.2/ EasiSNP/ 的/ 开销/ 3/ 个/ 方面/ 对/ EasiSNP/ 的/ 性能/ 进行/ 测试/ ./ 本/ 小节/ 将/ 从/ 编程/ 开销/ 、/ 传输/ 开销/ 和/ 存储/ 开销/ 编程/ 开销/ 是/ 指/ 为了/ 完成/ 某个/ 特定/ 目标/ ,/ 所/ 需/ 编写程序/ 的/ 代码/ 量/ ./ EasiSNP/ 以/ 接口/ 与/ 时空/ 属性/ 进行/ 绑定/ 的/ 方式/ 直接/ 对/ 节点/ 上/ 的/ 接口/ 进行/ 编程/ ,/ 可以/ 使/ 编程/ 者/ 在/ 编写/ 代码/ 时较/ 少/ 考虑/ 具体/ 细节/ ,/ 将/ 大量/ 的/ 解释/ 工作/ 留给/ 程序/ 解释/ 系统/ ,/ 从而/ 降低/ 了/ 编程/ 开销/ ./ 我们/ 以/ Nes/ C语言/ 作为/ 比较/ 对象/ ,/ 并且/ 将/ 编写/ 代码/ 的/ 行数/ 作为/ 衡量/ 编程/ 开销/ 的/ 指标/ [/ 12/ ]/ ./ 表/ 4/ 给出/ 了/ 直接/ 使用/ Nes/ C语言/ 实现/ Case1/ ~/ Case3/ 中/ 的/ 顶层/ 应用程序/ 所/ 需/ 编写/ 代码/ 量/ ./ EasiSNP/ 顶层/ 应用/ 的/ 代码/ 量/ 明显/ 少于/ NesC/ 程序/ 的/ 代码/ 量/ ./ 以/ Case1/ 中/ 的/ 跑马灯/ 程序/ 为例/ ,/ 编程/ 者/ 直接/ 使用/ NesC/ 进行/ 编程/ 时/ ,/ 需要/ 编写/ 相应/ 的/ 配线/ 文件/ (/ configuration/ )/ 和/ 模块/ 文件/ (/ module/ )/ [/ 7/ ]/ ./ 其中/ 配线/ 文件/ 约/ 为/ 32/ 行/ ,/ 模块/ 文件/ 约/ 为/ 198/ 行/ ./ 而/ 在/ EasiSNP/ 中/ ,/ 只/ 需要/ 编写/ 8/ 行/ 代码/ ,/ 所/ 需要/ 编写/ 的/ 代码/ 行/ 数/ 相差/ 将近/ 25/ 倍/ ./ NesCEasiSNP8EasiSNP/ 的/ 通信/ 开销/ 主要/ 来自/ 于/ 对/ 任务/ 块/ 的/ 传输/ ./ 图/ 10/ 给出/ 了/ 在/ 使用/ NesC/ 直接/ 编程/ 后/ ,/ 将/ 产生/ 的/ 节点/ 可/ 执行/ 代码/ 通过/ 两种/ 代码/ 更新/ 方法/ Stream/ [/ 13/ ]/ 和/ EasiCache/ [/ 11/ ]/ 产生/ 的/ 通信/ 开销/ ./ 可以/ 看出/ ,/ EasiSNPCase3/ ./ 编写/ 协助/ 数据/ 转发/ 的/ 顶层/ 应用程序/ ,/ 并/ 部署/ 到/ 网络/ 中/ ./ 在/ 协助/ 数据/ 转发/ 的/ 场景/ 中/ ,/ 普通/ 节点/ 除了/ 要/ 分析/ 当前/ 距离/ 移动/ 节点/ 跳数/ 之外/ ,/ 还/ 需要/ 对/ 信道/ 是否/ 阻塞/ 进行/ 判断/ ./ 同时/ ,/ 由于/ 汇聚/ 节点/ 与/ 普通/ 感知/ 节点/ 存在/ 差异性/ ,/ 需要/ 根据/ 汇聚/ 节点/ 的/ 具体/ 类型/ ,/ 生成/ 专门/ 的/ 可/ 执行/ 代码/ ,/ 因此/ 传输/ 代码/ 量/ 较大/ ./ 的/ 通信/ 开销/ 明显/ 少于/ Stream/ ,/ 但是/ 高于/ EasiCache/ ./ 这是/ 由于/ EasiCache/ 是/ 一种/ 增量/ 式/ 的/ 代码/ 更新/ 方法/ ,/ 它/ 通过/ 仅仅/ 传输/ 原有/ 旧/ 程序/ 与/ 更新/ 程序/ 的/ 差异/ 部分/ ,/ 极大/ 地/ 降低/ 了/ 代码/ 更新/ 的/ 通信/ 开销/ ./ Stream/ 需要/ 将/ 整个/ 更新/ 程序/ 进行/ 传输/ ,/ 通信/ 开销/ 较大/ ./ 尽管/ EasiSNP/ 没有/ 采用/ 增量/ 式/ 代码/ 更新/ 方法/ ,/ 但是/ 由于/ 任务/ 块/ 的/ 代码/ 量/ 要/ 远/ 小于/ 主程序/ ,/ 因此/ 仍然/ 可以/ 保持/ 较/ 低/ 的/ 通信/ 开销/ ./ 表/ 5/ 给出/ 了/ 4/ 轮/ 重复/ 部署/ Case1/ ~/ Case3/ 中/ 的/ 顶层/ 应用程序/ 后/ ,/ EasiSNP/ 和/ EasiCache/ 产生/ 的/ 通信/ 开销/ ./ 在/ 每/ 一轮/ 中/ ,/ 需要/ 将/ 3/ 个/ 例程/ 全部/ 重新部署/ 一遍/ ./ 在/ 第/ 1/ 轮/ 部署/ 中/ ,/ EasiSNP/ 需要/ 传输/ 不同/ 的/ 任务/ 块/ ,/ 其/ 传输/ 开销/ 明显/ 高于/ 采用/ 增量/ 式/ 代码/ 更新/ 方法/ 的/ EasiCache/ ./ 但是/ 在/ 随后/ 的/ 3/ 轮/ 部署/ 中/ ,/ EasiSNP/ 仅仅/ 传输/ 少量/ 的/ 控制/ 命令/ (/ 8Bytes/ )/ 就/ 可以/ 完成/ 重复/ 部署/ ,/ 这/ 主要/ 得益于/ 通过/ 节点/ 内部/ 迁移/ 将/ 失效/ 的/ 任/ Page12/ 务块/ 保存/ 到/ 节点/ 的/ 外部/ 扩展/ 存储器/ 中/ ./ 当/ 部署/ 过/ 的/ 顶层/ 应用程序/ 再次/ 被/ 重新部署/ 到/ 网络/ 中/ 时/ ,/ 可以/ 直接/ 将/ 所/ 需/ 的/ 任务/ 块/ 放入/ 处理器/ 的/ 主/ 内存/ 中/ ,/ 而/ 无需/ 再次/ 传输/ ./ EasiSNP8122242424EasiCache490617201124916EasiCache/ 也/ 采用/ 了/ 类似/ 的/ 缓存/ 思想/ ,/ 它/ 通过/ 将/ 频繁/ 更新/ 的/ 代码/ 缓存/ 在/ RAM/ 中/ ,/ 也/ 可以/ 在/ 一定/ 程度/ 上/ 消除/ 重复/ 升级/ 带来/ 的/ 冗余/ 传输/ ./ 但是/ 受到/ RAM/ 容量/ 的/ 限制/ ,/ 能够/ 缓存/ 在/ RAM/ 中/ 的/ 代码/ 远远/ 少于/ EasiSNP/ 放入/ 外部/ 扩展/ 存储器/ 中/ 的/ 任务/ 块/ ./ 因此/ 使用/ EasiCache/ 尽管/ 每次/ 需要/ 传输/ 的/ 代码/ 量/ 较/ 前/ 一轮/ 都/ 在/ 逐渐/ 减少/ ,/ 但是/ 仍然/ 超过/ EasiSNP/ 的/ 传输/ 代码/ 量/ ./ 由于/ 节点/ 上/ 存储资源/ 较为/ 有限/ ,/ 需要/ 考虑/ EasiSNP/ 对/ 节点/ 存储资源/ 的/ 影响/ ./ EasiSNP/ 的/ 存储/ 开销/ 主要/ 来自/ 于/ 3/ 部分/ :/ 任务/ 块/ 、/ 节点/ 运行/ 时/ 系统/ 以及/ 各种/ 函数/ 管理/ 列表/ ,/ 如图/ 11/ 所示/ ./ 图/ 11EasiSNP/ 各/ 部分/ 的/ 内存/ 开销/ (/ 以/ msp430f1611/ 为例/ ,/ 节点/ 运行/ 时/ 系统/ 需要/ 8KB/ 左右/ 的/ 存储空间/ ./ 函数/ 管理/ 列表/ 总共/ 大约/ 需要/ 5KB/ 的/ 存储空间/ ./ 其中/ 命令/ 函数/ 列表/ 是/ 由/ 主程序/ 中所能/ 提供/ 的/ 命令/ 接口/ 数量/ 决定/ 的/ ,/ 大小/ 相对/ 固定/ ./ 命令/ 函数/ 列表/ 中/ 单个/ 表项/ 需要/ 3Bytes/ 的/ 空间/ ,/ 通常/ 节点/ 能够/ 存储/ 的/ 命令/ 函数/ 在/ 大约/ 在/ 150/ ~/ 200/ 个/ 之间/ ,/ 因此/ 需要/ 1KB/ 的/ 空间/ 存放/ 命令/ 函数/ 列表/ ./ 而/ 函数/ 地址/ 向量/ 表是/ 由/ 节点/ 运行/ 时/ 系统/ 根据/ 当前/ 加载/ 的/ 任务/ 块/ 生成/ 的/ ,/ 它/ 的/ 大小/ 也/ 是/ 与/ 任务/ 块/ 中/ 需要/ 调用/ 的/ 命令/ 函数/ 数量/ 密切相关/ ./ 当/ 存在/ 多个/ 任务/ 块/ 是/ ,/ 通常/ 需要/ 分配/ 1.2/ KB/ ~/ 1.5/ KB/ 的/ 存储空间/ ./ 最后/ ,/ 函数/ 间接/ 调用/ 表/ 保存/ 了/ 底层/ TinyOS/ 对/ 任务/ 块/ 中/ 的/ 事件/ 函数/ 的/ 间接/ 调用/ 命令/ ,/ 其/ 大小/ 是/ 由/ TinyOS/ 所能/ 提供/ 的/ 事件/ 接口/ 的/ 数量/ 决定/ ./ 一般/ 事件/ 接口/ 数量/ 在/ 100/ ~/ 200/ 个/ 之间/ ./ 由图/ 7/ 可知/ ,/ 每个/ 函数/ 间接/ 调用/ 表/ 的/ 表项/ 大约/ 需要/ 8Bytes/ ,/ 分配/ 2KB/ ~/ 2.5/ KB/ 可以/ 满足/ 需求/ ./ 整个/ EasiSNP/ 节点/ 运行/ 时/ 系统/ 需要/ 占用/ 11KB/ ~/ 12KB/ 的/ 空间/ ./ 对于/ 资源/ 有限/ 的/ 节点/ 来说/ 还是/ 可以/ 承受/ 的/ ./ 这/ 主要/ 是因为/ 程序/ 的/ 核心/ 功能/ 被/ 放到/ 了/ 任务/ 块/ 中/ 执行/ ,/ 主程序/ 中/ 更/ 多/ 的/ 是/ 一些/ 针对/ 底层/ 硬件/ 的/ 驱动程序/ ./ 并且/ 任务/ 块/ 可以/ 动态/ 迁移/ 到/ 不同/ 节点/ 上/ 提高/ 了/ 节点/ 间/ 的/ 协同/ 能力/ ,/ 可以/ 进一步/ 消减/ 单个/ 节点/ 上/ 主程序/ 所/ 需/ 存储空间/ ./ 通常/ 任务/ 块/ 的/ 大小/ 在/ 1KB/ ~/ 4KB/ 之间/ ,/ 在/ 充分考虑/ 存储/ 安全/ 的/ 基础/ 上/ ,/ 保留/ 7KB/ ~/ 8KB/ 的/ 空间/ 作为/ 任务/ 块/ 的/ 存储/ 区域/ ./ 当/ 多次/ 对/ 节点/ 加载/ 任务/ 块/ 后/ ,/ 主/ 内存/ 可能/ 无法/ 对/ 所有/ 的/ 任务/ 块/ 进行/ 保存/ ,/ 因此/ 需要/ 通过/ 节点/ 内/ 迁移/ 将/ 失效/ 的/ 任务/ 块/ 保存/ 到/ 节点/ 的/ 外部/ 扩展/ 存储器/ 上/ ./ 由于/ 外部/ 扩展/ 存储器/ 拥有/ 较大/ 的/ 存储空间/ 因此/ 可以/ 同时/ 存储/ 多个/ 任务/ 块/ ./ 图/ 12/ 显示/ 了/ 分别/ 经过/ 30/ 次/ 不/ 重复/ 更新/ 时/ ,/ 存储/ 失效/ 任务/ 块/ 所/ 需要/ 空间/ 占/ 外部/ 扩展/ 存储器/ 总/ 空间/ (/ >/ 512KB/ )/ 的/ 比例/ ./ 我们/ 发现/ 保存/ 这些/ 失效/ 任务/ 块/ 不会/ 对/ 扩展/ 存储器/ 造成/ 很大/ 影响/ ./ 图/ 12/ 保存/ 失效/ 任务/ 块/ 所/ 需/ 的/ 外部/ 扩展/ 存储空间/ 5.3/ EasiSNP/ 的/ 动态性/ 分析/ 我们/ 使用/ NS/ -/ 3/ ①/ 网络/ 仿真/ 工具/ 模拟/ 了/ 一个/ 拥有/ 60/ 个/ 传感器/ 节点/ 的/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ ,/ 如图/ 13/ 所示/ ./ 60/ 个/ 节点/ 被/ 分为/ 3/ 簇/ ,/ 部署/ 在/ 2km/ ×/ 2km/ 的/ 水域/ 内/ ./ 簇内/ 采用/ 树形/ 拓扑/ 结构/ ,/ 簇头/ 节点/ 即/ 为/ 汇聚/ 节点/ ,/ 汇聚/ 节点/ 通过/ 3G/ 数据网络/ 将/ 感知/ 数据/ 传回/ ./ 传感器/ 节点/ 每隔/ 1min/ 进行/ 一次/ 数据/ 采样/ ,/ 并/ 通过/ 802.15/ ./ 4/ 网络/ 将/ 数据/ 发/ 往/ 汇聚/ 节点/ ./ 受/ 环境因素/ 影响/ ,/ 802.15/ ./ 4/ 网络/ 的/ 无线/ 信道/ 存在/ 不稳定性/ ./ 通过/ NS/ -/ 3/ 随机/ 产生/ 了/ 4/ 个/ 失效节点/ (/ a3/ ,/ b2/ ,/ c2/ ,/ d3/ )/ ./ ①/ NS/ -/ 3/ ./ http/ :/ // // www/ ./ nsnam/ ./ org/ // documentation/ // Page13/ 数据/ 被/ 阻塞/ 在/ 失效节点/ 的/ 邻/ 节点/ (/ a4/ ,/ b3/ ,/ c3/ ,/ d4/ )/ ./ 假设/ 每个/ 失效节点/ 的/ 失效/ 时间/ 均/ 为/ 30min/ ./ 我们/ 通过/ 式/ (/ 10/ )/ 定义/ 被/ 阻塞/ 数据/ 在/ 这/ 段时间/ 内/ 的/ 平均/ 延时/ :/ 其中/ Amoutsample/ 是/ 失效/ 时间/ 内/ 的/ 采样/ 次数/ ,/ Delaysum/ 是/ 数据/ 的/ 总/ 延时/ ./ 在/ 没有/ 其它/ 节点/ 帮助/ 失效节点/ 进行/ 传输/ 的/ 情况/ 下/ ,/ 30min/ 内/ 数据/ 的/ 总/ 延时/ 如式/ (/ 11/ )/ 所示/ :/ Delaysum/ =/ (/ Delaymax/ +/ Delaymin/ )/ ×/ AmoutsampleDelaymax/ 和/ Delaymin/ 是/ 在/ 节点/ 失效/ 时间/ 内/ ,/ 采样/ 数据/ 的/ 最大/ 和/ 最小/ 延时/ ./ 由/ 设定/ 可知/ ,/ 在/ 30min/ 内/ ,/ 感知/ 节点/ 共/ 进行/ 了/ 30/ 次/ 采样/ ,/ 数据/ 的/ 最大/ 延时/ 和/ 最小/ 延时/ 分为/ 为/ 30min/ 和/ 1min/ ,/ 在/ 节点/ 失效/ 的/ 30min/ 内/ 的/ 数据/ 平均/ 延时/ 为/ 15.5/ min/ ./ 图/ 13/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执行/ 系统/ 部署/ 示意图/ 引入/ 打捞/ 执行/ 单元/ (/ ExecUnit/ )/ 以/ 12/ 节/ (/ 22km/ // h/ )/ 的/ 平均速度/ 在/ 这片/ 水域/ 随机/ 游走/ ,/ 并且/ 假定/ 执行/ 单元/ 上/ 具备/ 与/ 传感器/ 节点/ 进行/ 通信/ 的/ 能力/ ./ 将/ Case2/ 中/ 协助/ 数据传输/ 的/ 顶层/ 应用程序/ 部署/ 到/ 网络/ 上/ ./ 顶层/ 应用程序/ 首先/ 在/ 计算机/ 端/ 被/ 分解/ 为/ 若干/ 任务/ 块/ ,/ 这些/ 任务/ 块/ 通过/ 3G/ 数据网络/ 被/ 下载/ 到/ 汇聚/ 节点/ 上/ ,/ 然后/ 这些/ 任务/ 块/ 被/ 分发/ 到/ 失效节点/ 附近/ 的/ 节点/ 上/ ./ 当/ 移动/ 的/ 打捞/ 执行/ 单元/ 接近/ 汇聚/ 节点/ 或者/ 失效节点/ 附近/ 水域/ 时/ ,/ 这些/ 任务/ 块/ 被/ 下载/ 到/ 执行/ 单元/ 上/ ./ 随后/ ,/ 当/ 执行/ 单元/ 移动/ 到/ 失效节点/ 附近/ 时/ ,/ 将/ 代替/ 失效节点/ 完成/ 数据/ 的/ 转发/ ./ 表/ 6/ 给出/ 了/ 执行/ 单元/ 到达/ 失效节点/ 附近/ 的/ 时间/ ./ 相对/ 于/ 执行/ 单元/ 的/ 运动/ 时间/ ,/ 执行/ 单元/ 与/ 感知/ 节点/ 之间/ 的/ 通信/ 时间/ 几乎/ 可以/ 忽略不计/ ./ 执行/ 单元/ 将/ 转发/ 其/ 到达/ 之前/ 被/ 阻塞/ 的/ 采样/ 数据/ ,/ 因此/ 可以/ 将/ 这个/ 时间/ 作为/ 这部分/ 阻塞/ 数据/ 的/ 延迟时间/ ,/ 新/ 的/ Delaysum/ 重新/ 表述/ 为式/ (/ 12/ )/ :/ Delaysum/ =/ Tarive/ ×/ Amoutsample/ +/ Delaymax/ +/ Delay/ 其中/ ,/ Tarive/ 是/ 执行/ 单元/ 的/ 到达/ 时间/ ;/ Amountsample/ 是/ 执行/ 单元/ 到达/ 之前/ 执行/ 采样/ 的/ 次数/ ;/ Delaymax/ 、/ Delaymin/ 和/ Amountsample/ 分别/ 是/ 在/ 执行/ 单元/ 离开/ 之后/ ,/ 采样/ 数据/ 的/ 最小/ 延时/ 、/ 最大/ 延时/ 以及/ 执行/ 采样/ 的/ 次数/ ./ 以/ 节点/ b2/ 失效/ 为例/ ,/ 由于/ 节点/ b2/ 无法/ 转发/ 数据/ ,/ 数据/ 被/ 阻塞/ 在/ 了/ 节点/ b3/ ./ 从图/ 13/ 中/ 可以/ 看到/ ,/ 执行/ 单元/ 在/ 3.18/ min/ 到达/ sink1/ 附近/ 并/ 下载/ 到/ 任务/ 块/ ./ 在/ 0.34/ min/ 后/ ,/ 执行/ 单元/ 到达/ 失效节点/ b2/ 附近/ ./ 根据/ 顶层/ 应用程序/ ,/ 执行/ 单元/ 作为/ (/ ExecUnit/ )/ 会/ 在/ 节点/ b3/ 和/ 转发/ 节点/ b1/ (/ Forwarder/ )/ 之间/ 重新/ 建立/ 连接/ ,/ 帮助/ 阻塞/ 在/ b3/ 节点/ 上/ 的/ 采样/ 数据/ (/ 包含/ [/ b3/ ,/ b4/ ,/ b5/ ]/ 的/ 采样/ 数据/ )/ 完成/ 传输/ ./ 在/ Tarive/ =/ 3.52/ 这个/ 时间/ 点/ 之前/ 进行/ 了/ 3/ 次/ 采样/ ,/ 而/ 执行/ 单元/ 离开/ 后/ 又/ 发生/ 了/ 27/ 次/ 采样/ ,/ 其/ 平均/ 数据/ 延时/ 为/ 12.16/ min/ ./ 图/ 14/ 给出/ 了/ 通过/ 执行/ 单元/ 协助/ 传输/ 后/ ,/ 如图/ 13/ 所示/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ 中/ 失效节点/ 附近/ 被/ 阻塞/ 数据/ 的/ 平均/ 延时/ ./ 可以/ 看到/ 4/ 个/ 失效节点/ 附近/ 的/ 图/ 14/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ 中/ 失效节点/ 附/ Page14/ 数据/ 延时/ 都/ 有所/ 降低/ ./ 比较/ 特殊/ 的/ 是/ 失效节点/ a3/ 附近/ 被/ 延时/ 的/ 数据/ ./ 当/ 执行/ 单元/ 经过/ a3/ 附近/ 时/ ,/ 其/ 行驶路线/ 远离/ 可以/ 作为/ 转发/ 节点/ 的/ a2/ ,/ 因此/ 没有/ 把/ 节点/ a2/ 作为/ 接口/ 提供者/ Forwarder/ ./ 而是/ 将/ 执行/ 单元/ 路径/ 上/ 的/ 节点/ e7/ 作为/ 转发/ 节点/ ,/ 完成/ 了/ 数据/ 的/ 转发/ ./ 实际/ 中/ ,/ 由于/ 很难/ 预先/ 估计/ 到/ 执行/ 单元/ 会/ 移动/ 到/ 什么/ 位置/ ,/ 也/ 无法/ 确定/ 哪些/ 节点/ 能够/ 充当/ 转发/ 节点/ ./ 通过/ 设定/ 较大/ 的/ 触发/ 延时/ (/ TimeOut/ )/ ,/ 并/ 将/ Forwarder/ 对应/ 的/ 任务/ 块/ 暂时/ 保存/ 在/ 执行/ 单元/ 上/ ./ 一旦/ 执行/ 单元/ 发现/ 了/ 满足/ 任务/ 块/ 时空/ 属性/ 的/ 节点/ ,/ 即/ 把/ 这个/ 任务/ 块/ 加载/ 到/ 节点/ 上/ ,/ 完成/ 数据/ 转发/ ./ 6/ 相关/ 工作/ 早期/ 的/ 研究/ 已经/ 提出/ 了/ 若干种/ 针对/ 传感器/ 网络/ 的/ 编程/ 方法/ [/ 7/ ,/ 14/ -/ 16/ ]/ ./ 这些/ 编程/ 方法/ 大多数/ 是/ 针对/ 具体/ 节点/ 的/ 编程/ ,/ 可以/ 归为/ 节点/ 级/ (/ node/ -/ level/ )/ 编程/ ./ 例如/ ,/ TinyOS/ 需要/ 使用/ 一种/ 事件驱动/ 的/ 编程语言/ NesC/ 进行/ 编程/ [/ 7/ ]/ ./ 由于/ NesC/ 编写/ 的/ 应用程序/ 主要/ 是/ 针对/ 传感器/ 节点/ ,/ 需要/ 编程/ 者/ 对/ 顶层/ 硬件/ 有/ 一定/ 了解/ ,/ 开发/ 难度/ 较大/ ,/ 也/ 不/ 易于/ 对/ 节点/ 进行/ 动态/ 配置/ ./ 为了/ 方便/ 对/ 节点/ 进行/ 动态/ 配置/ ,/ Levis/ 等/ 人/ [/ 14/ ]/ 提出/ 了/ 一种/ 基于/ 虚拟机/ 的/ 编程/ 方法/ ASVM/ ./ 这种/ 编程/ 方法/ 通过/ 提供/ 少量/ 针对/ 特殊/ 应用/ 的/ 指令/ ,/ 可以/ 极大/ 地/ 降低/ 更新/ 代码/ 的/ 代码/ 量/ ./ 但是/ 由于/ ASVM/ 只能/ 采用/ 紧凑型/ 代码/ 进行/ 编程/ ,/ 导致/ 编程/ 灵活性/ 不佳/ ,/ 表达能力/ 有限/ ./ SensorWare/ [/ 15/ ]/ 采用/ 了/ 一种/ 基于/ Tcl/ 控制/ 脚本语言/ ,/ 主要/ 应用/ 于/ 网络/ 重/ 编程/ ,/ 但是/ 其/ 应用/ 对象/ 是/ 资源/ 丰富/ 的/ 硬件平台/ ,/ 对于/ 资源/ 受限/ 的/ 传感器/ 节点/ 并/ 不/ 适用/ ./ 因此/ ,/ 如何/ 高效/ 地/ 对/ 传感器/ 网络/ 进行/ 编程/ 是/ 当前/ 亟待解决/ 的/ 问题/ ./ 目前/ 的/ 研究/ 普遍认为/ 利用/ 高度/ 抽象/ 的/ 网络/ 级/ (/ network/ -/ level/ )/ 宏/ 编程/ (/ macropro/ -/ gramming/ )/ 可以/ 在/ 一定/ 程度/ 上/ 解决/ 这些/ 问题/ [/ 17/ -/ 21/ ]/ ./ 宏/ 编程/ 方法/ 的/ 核心思想/ 是/ 不/ 明确/ 指定/ 编程/ 的/ 节点/ ,/ 而是/ 通过/ 描述/ 网络/ 的/ 行为/ 以及/ 网络/ 中/ 实体/ (/ entity/ )/ 的/ 相互作用/ 关系/ ,/ 由/ 网络/ 自/ 适应/ 地/ 选择/ 合适/ 节点/ 完成/ 相应/ 任务/ ./ 例如/ ,/ 为了/ 尽量/ 消除/ 移动/ 节点/ 给/ 网络/ 带来/ 的/ 动态性/ ,/ 在/ 文献/ [/ 19/ ]/ 中/ 提到/ 一种/ 空间/ 编程/ (/ SpatialProgramming/ )/ 方法/ ,/ 它/ 将/ 节点/ 动态/ 地/ 与/ 空间/ 地理位置/ 进行/ 绑定/ ./ 当/ 节点/ 位置/ 移动/ 时/ ,/ 网络/ 在/ 指定/ 的/ 空间/ 位置/ 上/ 自动/ 绑定/ 新/ 的/ 节点/ ./ 这种/ 方法/ 的/ 缺点/ 在于/ 资源/ 有限/ 的/ 传感器/ 网络/ 节点/ 缺乏/ 有效/ 的/ 定位/ 手段/ ,/ 很难/ 将/ 节点/ 定位/ 到/ 一个/ 绝对空间/ 位置/ 上去/ ./ 基于/ Agent/ 的/ 中间件/ Agilla/ [/ 20/ ]/ 能够/ 在/ 运行/ 时/ 将/ 应用/ 动态/ 部署/ 到/ 传感器/ 网络/ 上/ ./ 但是/ Agent/ 之间/ 只能/ 通过/ 元组/ 空间/ (/ tuplespace/ )/ 实现/ 数据交换/ ,/ 缺乏/ 有效/ 地/ 协同/ ./ 文献/ [/ 21/ ]/ 将/ 手机/ 网络/ 作为/ 感知/ 层/ 网络/ ,/ 通过/ 编程/ 的/ 方法/ 实现/ 了/ 由/ “/ 人/ ”/ 到/ “/ 人/ ”/ 的/ 参与/ 感知/ [/ 5/ ]/ ,/ 但/ 没有/ 考虑/ 如何/ 与/ 传感器/ 网络/ 进行/ 协同/ ,/ 以/ 实现/ “/ 物/ ”/ 与/ “/ 人/ ”/ 的/ 交互/ ./ 7/ 结束语/ 当前/ 作为/ 感知/ 层/ 的/ 传感器/ 网络/ 通常/ 是/ 由/ 资源/ 受限/ 的/ 传感器/ 节点/ 组成/ ,/ 传感器/ 节点/ 的/ 正常/ 工作/ 经常/ 受到/ 外界/ 环境因素/ 的/ 影响/ ,/ 造成/ 传感器/ 网络/ 具有/ 较强/ 的/ 动态性/ ./ 同时/ ,/ 移动/ 节点/ 的/ 引入/ 会/ 加剧/ 网络/ 的/ 动态性/ ./ 为了/ 增强/ 网络/ 的/ 健壮性/ ,/ 编程/ 者/ 不得不/ 预先/ 设计/ 各种/ 冗余/ 机制/ ,/ 加大/ 了/ 对/ 传感器/ 网络/ 的/ 编程/ 难度/ ./ 本文/ 提出/ 了/ 一种/ 基于/ 时空/ 属性/ 的/ 网络/ 编程/ 方法/ —/ —/ —/ EasiSNP/ ./ 它/ 通过/ 定义/ 接口/ 和/ 节点/ 的/ 时空/ 属性/ ,/ 使用/ 接口/ 描述/ 网络/ 的/ 行为/ ,/ 从而/ 不/ 需要/ 再/ 对/ 具体/ 节点/ 进行/ 编程/ ,/ 降低/ 了/ 编程/ 的/ 复杂度/ ./ 并且/ 采用/ 替换/ 的/ 思想/ ,/ 通过/ 任务/ 块/ 迁移/ 机制/ 自主/ 地/ 选择/ 最优/ 的/ 节点/ 执行/ 任务/ ,/ 尽量/ 消除/ 外界/ 环境因素/ 和/ 移动/ 节点/ 给/ 网络/ 带来/ 的/ 影响/ ./ 在/ 未来/ 的/ 工作/ 中/ ,/ 我们/ 将/ 继续/ 研究/ 如何/ 把/ 这种/ 基于/ 时空/ 属性/ 的/ 编程/ 方法/ 应用/ 到/ 更/ 具有/ 普遍性/ 的/ 移动/ 终端/ ./ 通过/ 移动/ 终端/ 与/ 传感器/ 网络/ 的/ 融合/ ,/ 在/ 真正/ 意义/ 上/ 使/ “/ 人/ ”/ 成为/ 物/ 联网/ 的/ 一部分/ ./ 

