Page1/ 基于/ GCL/ 语言/ 的/ 测试用例/ 生成/ 方法/ 丁佐华/ 1/ )/ JeffSanders2/ )/ 江/ 明月/ 1/ )/ 张娜/ 1/ )/ 蒲戈光/ 3/ )/ 1/ )/ (/ 浙江/ 理工大学/ 智能/ 计算/ 与/ 软件工程/ 实验室/ 杭州/ 310018/ )/ 2/ )/ (/ 联合国/ 大学/ 国际/ 软件技术/ 研究所/ P/ ./ O/ ./ Box3058/ 澳门/ )/ 3/ )/ (/ 华东师范大学/ 软件/ 学院/ 上海/ 200062/ )/ 摘要/ 提出/ 一种/ 基于/ GCL/ 语言/ 生成/ 程序/ 测试用例/ 的/ 形式化/ 方法/ ./ 程序/ 的/ 语义/ 为/ 测试用例/ 的/ 生成/ 提供/ 了/ 基本/ 框架/ ,/ 而/ 由/ Hoare/ 等/ 人/ 提供/ 的/ 规则/ 保证/ 了/ 用例/ 的/ 正确性/ ./ 作者/ 的/ 这种/ 方法/ 可/ 被/ 认为/ 是/ 一种/ 严格/ 的/ ,/ 自动/ 生成/ 测试用例/ 的/ 方法/ ./ 这种/ 方法/ 的/ 优点/ 在于/ :/ 所/ 获得/ 的/ 测试用例/ 都/ 是/ 可行/ 的/ ,/ 在/ 测试用例/ 生成/ 过程/ 中/ 可以/ 避免/ 状态/ 爆炸/ 问题/ ,/ 而且/ 该/ 方法/ 可以/ 延拓/ 到/ 任何/ 目标语言/ ./ 据此/ 开发/ 了/ 一个/ 基于/ Haskell/ 语言/ 的/ 原型/ 工具/ 来/ 支持/ 作者/ 的/ 方法/ ./ 关键词/ 测试用例/ ;/ Guarded/ -/ Command/ -/ Language/ ;/ 执行/ 树/ ;/ 条件/ 计算/ ;/ 软件测试/ 1/ 引言/ 软件测试/ 是/ 一种/ 检查/ 软件系统/ 实现/ 正确性/ 的/ 可/ 操作/ 的/ 方法/ ./ 测试/ 通常/ 分为/ 两个/ 阶段/ :/ 生成/ 测试用例/ 和/ 运行/ 测试用例/ ./ 本文/ 主要/ 讨论/ 生成/ 测试用例/ ./ 目前/ 有/ 很/ 多种/ 生成/ 测试用例/ 的/ 方法/ 和/ 和/ 技巧/ ./ 例如/ ,/ 基于/ 控制流/ 图/ [/ 1/ ]/ 、/ 基于/ 模型/ 检测/ [/ 2/ ]/ 、/ 基于/ 符号化/ 执行/ [/ 3/ ]/ 、/ 基于/ 可达图/ [/ 4/ ]/ 、/ 基于/ 状态/ 变迁/ 系统/ [/ 5/ ]/ 等/ ./ 如果/ 根据/ 具体/ 的/ 应用程序/ 产生/ 测试用例/ ,/ 我们/ 常常/ 会/ 碰到/ 一些/ 困难/ ./ 如/ :/ 在/ 处理/ 动态/ 数据结构/ 、/ 数组/ 及/ 过程/ 时常/ 需要/ 复杂/ 的/ 代数/ 操作/ ;/ 对于/ 己/ 被/ 选择/ 的/ 路径/ ,/ 不易/ 找到/ 使得/ 这/ 条/ 路径/ 被/ 遍历/ 的/ 输入/ 数据/ ./ 因此/ 当/ 这类/ 方法/ 用于/ 为/ 大型/ 、/ 复杂/ 的/ 软件系统/ 生成/ Page2/ 测试用例/ 时会/ 显示/ 出/ 不足/ ./ 通常/ 的/ 解决办法/ 是/ :/ 对/ 具体/ 的/ 应用程序/ 建立/ 相应/ 的/ 高层/ 模型/ ,/ 然后/ 再/ 根据/ 高层/ 模型/ 生成/ 测试用例/ ./ 但/ 这种/ 方式/ 也/ 存在/ 一些/ 问题/ ./ 比较/ 常见/ 的/ 是/ 以下/ 两个/ 问题/ :/ (/ 1/ )/ 所/ 获得/ 的/ 测试用例/ 可能/ 是/ 不/ 可行/ (/ infeasible/ )/ 的/ ,/ 即/ 所/ 生成/ 的/ 测试用例/ 在/ 测试/ 过程/ 中/ 无法/ 正常/ 执行/ 和/ 完成/ [/ 6/ -/ 7/ ]/ ./ 其/ 原因/ 在/ 很大/ 程度/ 上/ 是/ 由于/ 产生/ 测试用例/ 的/ 高层/ 模型/ 缺少/ 语义/ ,/ 例如/ 基于/ 有向图/ 路径/ 模型/ 生成/ 测试用例/ 方法/ ;/ (/ 2/ )/ 状态/ 爆炸/ 问题/ ,/ 即/ 为了/ 获得/ 测试用例/ ,/ 遍历/ 程序/ 状态/ 空间/ 中/ 所有/ 的/ 状态/ ,/ 而/ 这些/ 状态/ 会/ 随着/ 程序/ 中/ 任务/ 个数/ 增长/ 呈/ 指数/ 增长/ ./ 如/ 基于/ 模型/ 检查/ 方法/ 生成/ 测试用例/ ,/ 模型/ 检测工具/ 为了/ 找到/ 违反/ 相关/ 属性/ 的/ 路径/ ,/ 将会/ 穷尽/ 搜索/ 系统/ 的/ 状态/ 空间/ [/ 2/ ]/ ./ 即便/ 在/ 忽略/ 数据/ 的/ 情况/ 下/ ,/ 系统/ 的/ 状态/ 空间/ 还是/ 会/ 随着/ 任务/ 个数/ 的/ 增长/ 呈/ 指数/ 增长/ ./ 本文/ 提出/ 一种/ 新/ 的/ 生成/ 测试用例/ 的/ 方法/ 以/ 试图/ 避免/ 上述/ 问题/ ./ 首先/ 我们/ 用/ 一种/ 符号语言/ 来/ 表示/ 程序/ ,/ 该/ 语言/ 扩展/ 了/ 由/ Dijkstra/ [/ 8/ ]/ 所/ 提出/ 的/ GCL/ (/ Guarded/ -/ Command/ -/ Language/ )/ 语言/ ,/ 对应/ 的/ 规则/ (/ law/ )/ 来自/ 于/ Hoare/ [/ 9/ ]/ ./ 这种/ 语言/ 被/ 认为/ 是/ 对/ 实际/ 程序/ 的/ 一种/ 抽象/ ./ 生成/ 用例/ 的/ 过程/ 大致/ 描述/ 如下/ :/ 第/ 1/ 步/ :/ 通过/ 静态/ 检查/ GCL/ ,/ 构造程序/ 的/ 执行/ 树/ ,/ 然后/ 对/ 执行/ 树中/ 结点/ 的/ 条件/ 进行/ 处理/ (/ 使得/ 一个/ 结点/ 的/ 条件/ 为/ 从/ 根/ 结点/ 至/ 这个/ 结点/ 上/ 所有/ 结点/ 条件/ 的/ 聚合/ )/ ,/ 并且/ 去掉/ 条件/ 中值/ 为/ 假/ 的/ 布尔/ 型/ 的/ 结点/ 及其/ 子树/ (/ 条件/ 为/ 假/ 的/ 结点/ 以及/ 它/ 的/ 子树/ ,/ 不能/ 生成/ 测试用例/ )/ ,/ 这样/ 可以/ 保证/ 修改/ 后/ 得到/ 的/ 树/ 中/ 所有/ 路径/ 都/ 是/ 可行/ 的/ ./ 第/ 2/ 步/ :/ 基于/ 修改/ 过/ 的/ 执行/ 树/ 生成/ 测试/ 序列/ 集/ ./ 本文/ 中/ 一个/ 测试/ 序列/ 是/ 由/ 一条/ 路径/ 上/ 的/ 输入/ 、/ 输出/ 结点/ 组成/ ./ 本文/ 的/ 方法/ 有/ 如下/ 特点/ :/ (/ 1/ )/ 由于/ 用例/ 的/ 生成/ 过程/ 是/ 基于/ 程序/ 语义/ 的/ ,/ 故所/ 生成/ 的/ 测试用例/ 都/ 是/ 可行/ 的/ ;/ (/ 2/ )/ Hoare/ 法则/ 保证/ 了/ 用例/ 的/ 正确性/ ,/ 即用例/ 符合/ 程序执行/ 的/ 动态/ 情况/ ,/ 是/ 正确/ 的/ 测试用例/ ;/ (/ 3/ )/ 对/ 算法/ 复杂度/ 的/ 分析表明/ 这种/ 方法/ 不会/ 导致/ 状态/ 爆炸/ 问题/ ;/ (/ 4/ )/ 通过/ 写出/ 一个/ 前端/ ,/ 我们/ 的/ 方法/ 可以/ 延拓/ 到/ 任何/ 目标语言/ ./ 本文/ 第/ 2/ 节/ 通过/ 定义/ 语法/ 规则/ ,/ 将/ 过程/ 式/ 程序转换/ 为/ GCL/ 符号化/ 表示/ 形式/ ,/ 并/ 给出/ 程序执行/ 所/ 满足/ 的/ 规则/ ;/ 第/ 3/ 节/ 描述/ 程序/ 生成/ 测试用例/ 集/ 的/ 方法/ :/ 包括/ 构造程序/ 的/ 可/ 执行/ 树/ 、/ 去除/ 不/ 可行/ 路径/ 、/ 生成/ 测试/ 序列/ 、/ 获得/ 最终/ 的/ 测试用例/ 集等/ ;/ 第/ 4/ 节/ 介绍/ 我们/ 开发/ 的/ 生成/ 测试用例/ 的/ 模型/ 工具/ ;/ 第/ 5/ 节是/ 一个/ 实验/ ,/ 对/ 一个/ 具体/ 的/ 应用程序/ 生成/ 测试用例/ ;/ 第/ 6/ 节/ 讨论/ 了/ 相关/ 工作/ ;/ 第/ 7/ 节对/ 本文/ 工作/ 进行/ 总结/ ,/ 并/ 探讨/ 下/ 一步/ 研究/ 方向/ ./ 2/ 过程/ 式/ 程序/ (/ ProceduralProgram/ )/ 在/ 这/ 一部分/ ,/ 我们/ 将/ ?/ 用/ 一种/ 简单/ 但/ 表示/ 性强/ 的/ 符号语言/ (/ 即/ 具有/ 规则/ 的/ 语言/ )/ 来/ 描述/ 过程/ 反应式/ 程序/ (/ ProceduralReactivePrograms/ )/ ./ 这种/ 符号语言/ 扩展/ 了/ Dijkstra/ [/ 8/ ]/ 所/ 提出/ 的/ GCL/ (/ Guarded/ -/ CommandLanguage/ )/ 语言/ ,/ 语言/ 的/ 规则/ 由/ Hoare/ [/ 9/ ]/ 提供/ ./ 2.1/ 语法/ 本文/ 中/ 所/ 提到/ 的/ 程序/ 指/ 的/ 是/ 过程/ 反应式/ 程序/ ,/ 即/ 在/ 程序执行/ 过程/ 中/ 会/ 涉及/ 到/ 输入/ 操作/ 的/ 程序/ ./ 一个/ 过程/ 反应式/ 程序/ 最终/ 执行/ 状态/ 为/ 终止/ 状态/ ./ 为了/ 用/ 符号语言/ 来/ 描述/ 过程/ 反应式/ 程序/ ,/ 定义/ 以下/ 语法/ ./ prog/ ∷/ =/ skip/ (/ 没有/ 任何/ 影响/ 的/ 活动/ )/ 其中/ ,/ e/ 代表/ 一个/ 表达式/ ,/ c/ 表示/ 一个/ 条件/ ,/ 且/ 前面/ 5/ 项/ 称为/ 原子/ 程序/ (/ atomicprogram/ )/ ,/ p/ 是/ 5/ 类/ 原子/ 程序/ 中/ 的/ 一种/ ./ 一个/ 程序/ 通常/ 由/ 以下/ 部分/ 组成/ :/ 无/ 操作/ 活动/ skip/ ,/ 失败/ 活动/ abort/ ,/ 赋值/ 语句/ x/ ·/ ·/ =/ e/ ,/ 输入/ 语句/ ?/ x/ ,/ 输出/ 语句/ !/ e/ ,/ 顺序/ 组合/ ,/ 由/ 状态/ 空间/ 中/ 断言/ 的/ 值/ 决定/ 的/ 两个/ 程序/ 间/ 的/ 二元/ 选择/ ,/ 由/ 状态/ 空间/ 断言/ 控制/ 的/ 循环/ ./ 上述/ 所有/ 程序/ 的/ 状态/ 空间/ 用/ / (/ X/ )/ 来/ 表示/ ,/ 并且/ 声明/ x/ :/ x/ 表示/ 一个/ 值为/ 类型/ X/ 的/ 变量/ ./ 通常/ ,/ 局部变量/ 在/ 本地/ 程序/ 块/ 中/ 被/ 声明/ ./ 程序/ 的/ 输入/ 和/ 输出/ ,/ 通常/ 被/ 隐含/ 的/ 表示/ 为/ 赋值/ 给/ 一个/ 全局变量/ 或者/ 从/ 一个/ 全局变量/ 中取/ 一个/ 值/ ,/ 但/ 在/ 本文/ 中/ ,/ 必须/ 显式/ 的/ 表示/ 出/ 程序/ 的/ 输入/ 与/ 输出/ ,/ 因为/ 我们/ 针对/ 的/ 是/ 反应式/ 的/ 程序/ ,/ 程序/ 的/ 任何/ 反应/ 都/ 需要/ 被/ 描述/ ./ 我们/ 将/ 通过/ 使用/ 一组/ 全局变量/ 来/ 达到/ 这个/ 目的/ ,/ 这/ 一点/ 将/ 在/ 后面/ 阐述/ ./ 为了/ 简单/ 起/ 见/ ,/ 假定/ 输入/ 和/ 输出/ 的/ 数据类型/ 均/ 为/ X/ ./ 同时/ ,/ 为了/ 避免/ 这个/ 假设/ 造成/ 对/ 程序/ 的/ 约束/ ,/ 我们/ 仅仅/ 允许/ x/ 的/ 某些/ 部分/ 可以/ 通过/ 输入/ 语句/ 进行/ 输入/ ,/ 并且/ 如果/ 输出/ 的/ 类型/ 不是/ x/ 的/ 某/ 一部分/ ,/ 需要/ 将/ 相应/ 的/ 类型转换/ 为/ 类型/ X/ (/ 注/ :/ 由于/ 本文/ 是/ 基于/ 对/ 条件/ 的/ 演算/ 来/ 生成/ Page3/ 测试用例/ ,/ 所以/ 如果/ 输入/ 数据/ 是/ 多个/ 类型/ ,/ 本文/ 的/ 算法/ 同样/ 适用/ ./ 与/ 单个/ 类型/ 不同/ 处/ 在于/ 对/ 多维/ 输入/ 域/ 的/ 划分/ ./ 输出/ 数据/ 的/ 类型/ 可以/ 与/ 输入/ 类型/ 不同/ ,/ 但/ 不会/ 影响/ 到/ 测试用例/ 的/ 生成/ )/ ./ 假定/ 在/ 必要/ 的/ 时候/ 可以/ 复制/ 变量/ ,/ 且/ 不/ 存在/ 值/ -/ 结果/ 型/ 参数/ (/ value/ -/ resultparameter/ )/ ./ 定义/ g/ (/ g/ :/ seqX/ )/ 与/ h/ (/ h/ :/ seqX/ )/ 为/ 两个/ X/ 类型/ 的/ 序列/ ./ 则/ 每/ 一个/ 输入/ ?/ x/ 被/ 当作/ 是/ 一个/ 值/ 参数/ (/ valueparameter/ )/ ,/ 它/ 来自/ 于/ 序列/ g/ ./ 每/ 一个/ 输出/ 被/ 当作/ 是/ 一个/ 结果/ 参数/ (/ resultparameter/ )/ ,/ 它/ 将/ 被/ 指派/ 到/ 序列/ h/ 的/ 头部/ ./ 在/ 任何/ 情况/ 下/ ,/ 无论/ 序列/ g/ 与/ h/ 被/ 操作/ 多少/ 次/ ,/ 我们/ 假定/ g/ 只/ 被/ 读取/ ,/ 而/ h/ 只/ 被/ 写入/ ./ 则/ 从/ g/ 中/ 取出/ 一个/ 输入/ x/ ,/ 这个/ 过程/ 可/ 通过/ 式/ (/ 1/ )/ 中/ 的/ 多个/ 赋值/ 来/ 实现/ ./ 式/ (/ 1/ )/ 利用/ 序列/ 处理函数/ head/ 与/ tail/ 来/ 描述/ 取值/ 的/ 过程/ ./ 通过/ 式/ (/ 1/ )/ 可以/ 看出/ 检验/ g/ 是否/ 为空/ 是/ 很/ 有/ 必要/ 的/ ./ 可以/ 通过/ 使用/ 一个/ 输入/ 守卫/ 来/ 检查/ g/ 是否/ 为空/ ./ 类似/ 的/ ,/ 将/ 表达式/ e/ :/ X/ 输出/ 至/ h/ 被/ 定义/ 为/ 将/ e/ 添加/ 到/ 序列/ h/ 的/ 头部/ ,/ 如式/ (/ 2/ )/ 所示/ ./ 条件/ c/ 与/ 表示/ 式/ e/ 依照/ 常用/ 的/ 方式/ 定义/ ,/ 我们/ 将/ 在/ 3.1/ 节/ 给出/ 具体/ 的/ 说明/ ./ 2.2/ 运行/ 规则/ 序/ 运行/ 所/ 满足/ 的/ 规则/ ./ 为了/ 说明/ 测试用例/ 的/ 预期/ 效果/ ,/ 我们/ 定义/ 了程/ 序列化/ 操作/ 与/ skip/ 和/ abort/ 遵循/ 的/ 规则/ 如下/ :/ P/ ;/ (/ Q/ ;/ R/ )/ =/ (/ P/ ;/ Q/ )/ ;/ R/ 对于/ 非/ 反应式/ 的/ 序列化/ 程序/ ,/ 规则/ P/ ;/ abort/ =/ abort/ 成立/ ./ 由于/ 我们/ 针对/ 的/ 是/ 反应式/ 的/ 程序/ ,/ 若/ P/ 中/ 包含/ 输出/ 语句/ ,/ 则/ 序列/ 变量/ h/ 将/ 被/ 改变/ ,/ 所以/ 这/ 条/ 规则/ 对于/ 反应式/ 程序/ 不/ 一定/ 成立/ ./ 二元/ 选择/ 遵守/ 下列/ 规则/ (/ b/ ,/ c/ 表示/ 条件/ 变量/ 或/ 条件/ 表达式/ )/ :/ PiftrueelseQ/ =/ PPifcelseQ/ =/ Qif/ / celsePPifcelseP/ =/ P/ (/ PifbelseQ/ )/ ifcelseR/ =/ Pifb/ ∧/ celse/ (/ QifcelseR/ )/ (/ 10/ )/ Pifbelse/ (/ QifcelseR/ )/ =/ (/ PifbelseQ/ )/ ifcelse/ (/ PifbelseR/ )/ (/ 11/ )/ 顺序/ 组合/ 与/ 赋值/ 存在/ 如下/ 关系/ (/ e/ ,/ f/ 表示/ 表达式/ )/ :/ x/ ·/ ·/ =/ x/ =/ skipx/ ·/ ·/ =/ e/ =/ (/ x/ ·/ ·/ =/ e/ )/ if/ / (/ e/ )/ elseabort/ (/ 13/ )/ // / / (/ e/ )/ 代表/ 定义/ e/ 所/ 需/ 的/ 条件/ ,/ 即/ e/ 成立/ 的/ 条件/ / // (/ x/ ·/ ·/ =/ e/ )/ ;/ (/ x/ ·/ ·/ =/ f/ )/ =/ x/ ·/ ·/ =/ f/ / e/ (/ x/ ·/ ·/ =/ e/ )/ ifcelse/ (/ x/ ·/ ·/ =/ f/ )/ =/ x/ ·/ ·/ =/ (/ eifcelsef/ )/ (/ PifcelseQ/ )/ ;/ R/ =/ (/ P/ ;/ R/ )/ ifcelse/ (/ Q/ ;/ R/ )/ (/ 16/ )/ x/ ·/ ·/ =/ e/ ;/ (/ PifcelseQ/ )/ =/ (/ x/ ·/ ·/ =/ e/ )/ ;/ Pifc/ / eelse/ (/ x/ ·/ ·/ =/ e/ )/ ;/ Q/ (/ 17/ )/ 与/ 规则/ (/ 14/ )/ 相反/ 的/ 是/ ,/ 全局/ 输入/ 变量/ g/ 的/ 值/ 并/ 没有/ 被/ 局部变量/ 的/ 改变/ 所/ 影响/ ,/ 故/ 输入/ 的/ 数据/ 覆盖/ 了/ 原本/ 的/ 值/ :/ 一个/ 循环/ 可/ 通过/ 普通/ 递归/ 的/ 方式/ 来/ 定义/ 为/ whilecdoP/ =/ μ/ X/ ·/ (/ (/ P/ ;/ X/ )/ ifcelseskip/ )/ 从/ 上式/ 可以/ 推导/ 出/ :/ 如果/ 循环/ 执行/ 了/ 至多/ 一次/ ,/ 则/ 上式/ 等同于/ 一个二元/ 选择/ ,/ 即/ 一个/ 循环/ 与/ 它/ 的/ 一个/ 单步/ 执行/ 之间/ 是/ 有/ 区别/ 的/ ./ 如/ 在/ 程序/ n/ ·/ ·/ =/ 0/ ;/ whilen/ </ 8do/ (/ n/ ·/ ·/ =/ n/ +/ 1/ )/ ifn/ / 4else/ (/ n/ ·/ ·/ =/ n/ +/ 2/ )/ ifeven/ (/ n/ )/ else/ (/ n/ ·/ ·/ =/ n/ +/ 1/ )/ 中/ ,/ n/ 的/ 奇偶性/ 在/ 单步/ 执行/ 中是/ 不能/ 被/ 测试/ 到/ 的/ :/ 故将式/ (/ 18/ )/ 简化/ 为式/ (/ 19/ )/ 的/ 代价/ 是/ ,/ 测试/ 不能/ 覆盖/ 所有/ 的/ 条件/ ./ 由于/ 这个/ 原因/ ,/ 我们/ 允许/ 测试者/ 将/ 循环展开/ 到/ 任意/ 的/ 深度/ ,/ 以便/ 满足需要/ ./ 3/ 生成/ 测试用例/ 为了/ 基于/ 程序/ 生成/ 测试用例/ ,/ 我们/ 在/ 程序/ 的/ 符号化/ 表示/ 的/ 基础/ 上/ ,/ 生成/ 程序/ 所/ 对应/ 的/ 可/ 执行/ 树/ ,/ 然后/ 基于/ 程序/ 的/ 可/ 执行/ 树/ 生成/ 测试用例/ ./ 生成/ 测试用例/ 的/ 覆盖/ 准则/ 为/ :/ 所有/ 的/ 条件/ 至少/ 被/ 执行/ 一次/ ./ 3.1/ 条件/ 、/ 表达式/ 、/ 域/ 条件/ 语句/ 与/ 表达式/ 的/ 定义/ 与/ 普通/ 程序语言/ 所/ 规定/ 的/ 一样/ ./ 条件/ 语句/ 一般/ 出现/ 在/ 二元/ 选择/ 与/ 循环/ 中/ ,/ 表达式/ 可/ 位于/ 赋值/ 语句/ ,/ 输入输出/ 语句/ 中/ ./ 条件/ 语句/ 的/ 类型/ 是/ 布尔/ 型/ (/ / 表示/ 非/ 操作/ ,/ ∧/ 表示/ 与/ 操作/ ,/ ∨/ 表示/ 或/ 操作/ )/ ,/ 而/ 表达式/ 包含/ 同种/ 类型/ 数据/ 的/ 算术/ 操作/ ./ 假定/ 条件/ 语句/ 可以/ 定义/ 在/ 任何/ 地方/ ,/ 而/ 表达式/ 却/ Page4/ 不/ 一样/ ./ 下面/ ,/ 我们/ 引进/ 一个/ 表达式/ 的/ 域/ 的/ 概念/ ./ 首先/ ,/ 我们/ 用/ BB/ ·/ ·/ =/ ff/ |/ tt/ (/ tt/ 代表/ true/ ,/ ff/ 代表/ false/ )/ 来/ 表示/ 布尔/ 类型/ ./ 定义/ 1/ ./ 条件/ ./ 一个/ 条件/ (/ 或/ 断言/ )/ 指/ 一个/ 具有/ 布尔/ 类型/ 返回值/ 的/ 函数/ ./ 所有/ 类型/ 为/ X/ 的/ 条件/ 的/ 状态/ 空间/ 被/ 定义/ 为/ 将/ X/ 映射/ 到/ BB/ 的/ 函数/ / (/ X/ )/ =/ X/ →/ BB/ ./ 例如/ ,/ 对于/ f/ ,/ g/ :/ / (/ X/ )/ ,/ f/ 与/ g/ 的/ 与/ 操作/ f/ ∧/ g/ 定义/ 为/ (/ f/ ∧/ g/ )/ (/ t/ )/ =/ f/ (/ t/ )/ ∧/ g/ (/ t/ )/ ./ 类型/ 为/ X/ 的/ 表达式/ 的/ 定义/ 也/ 与/ 普通/ 程序语言/ 中/ 的/ 定义/ 相同/ ./ 我们/ 使用/ ε/ (/ X/ )/ 表示/ 类型/ 为/ X/ 的/ 表达式/ 的/ 种类/ ,/ 表达式/ 的/ 操作/ 取决于/ 类型/ X/ ./ 例如/ ,/ 如果/ X/ 是/ 数值/ 类型/ ,/ 则/ 表达式/ 包含/ 常用/ 的/ 算术/ 操作/ :/ 加/ (/ 二元/ )/ 和/ 自减/ 1/ (/ 一元/ )/ ;/ 如果/ X/ 是/ 序列/ 类型/ ,/ 则/ 表达式/ 包含/ 序列/ 操作/ :/ 如/ ,/ 连接/ (/ 二元/ )/ ,/ 取/ 序列/ 头部/ (/ 一元/ )/ 操作/ 等等/ ./ 定义/ 2/ ./ 域/ ./ 犇/ (/ e/ )/ 表示/ 表达式/ e/ 的/ 域/ ,/ 它/ 是/ 一个/ 条件/ ,/ 它/ 只/ 对/ 那些/ 使/ e/ 被良/ 定义/ 了/ 的/ 值/ 才/ 成立/ ./ 比如说/ ,/ 如果/ 表达式/ 是/ 自然数/ 类型/ ,/ 式/ m/ -/ n/ 当且/ 仅/ 当/ m/ / n/ 时才/ 可以/ 被/ 定义/ ;/ 如果/ 表达式/ 是/ 序列/ 类型/ ,/ 式/ tailxs/ 只有/ 序列/ xs/ 不空/ (/ xs/ ≠/ [/ ]/ )/ 时才/ 可以/ 被/ 定义/ ./ 因此/ ,/ 犇/ (/ e/ )/ 的/ 类型/ 由/ e/ 的/ 操作/ 元素/ a/ 决定/ ./ 犇/ (/ e/ )/ :/ / (/ Xa/ )/ 犇/ (/ e/ )/ (/ t1/ ,/ …/ ,/ ta/ )/ =/ (/ e/ (/ t1/ ,/ …/ ,/ ta/ )/ ./ 对于/ 一个/ 复杂/ 的/ 表达式/ ,/ 要/ 通过/ 表达式/ 的/ 组成部分/ 来/ 评价/ 这个/ 表达式/ 的/ 域/ ,/ 完全/ 取决于/ 表达式/ 的/ 类型/ ./ 例如/ ,/ 对于/ 布尔/ 类型/ ,/ 函数/ 犇/ 不是/ 一个/ 简单/ 的/ 映射/ ./ 比如/ 形如犇/ (/ b/ ∨/ c/ )/ =/ 犇/ (/ b/ )/ ∨/ 犇/ (/ c/ )/ 的/ 规则/ 太弱/ ,/ 而/ 形如犇/ (/ b/ ∨/ c/ )/ =/ 犇/ (/ b/ )/ ∧/ 犇/ (/ c/ )/ 的/ 规则/ 太强/ ,/ 我们/ 希望/ 的/ 是/ 可以/ 应用/ 到/ 布尔/ 型/ 的/ 子/ 表达式/ 上/ 的/ 规则/ ./ 因此/ ,/ 对于/ 布尔/ 型/ 的/ 表达式/ b/ ,/ c/ ,/ d/ 及/ 条件/ p/ ,/ 犇/ (/ b/ ∧/ c/ )/ =/ 犇/ (/ b/ )/ ∧/ 犇/ (/ c/ )/ 犇/ (/ b/ ∨/ c/ )/ =/ (/ b/ ∧/ 犇/ (/ b/ )/ )/ ∨/ (/ c/ ∧/ 犇/ (/ c/ )/ )/ 犇/ (/ bifcelsed/ )/ =/ 犇/ (/ c/ )/ ∧/ (/ 犇/ (/ b/ )/ ifcelse/ 犇/ (/ d/ )/ )/ 犇/ (/ / c/ )/ =/ 犇/ (/ c/ )/ 犇/ (/ p/ )/ =/ tt/ 例如/ ,/ 犇/ (/ (/ x/ -/ 3/ :/ NN/ )/ if/ (/ x/ >/ 4/ )/ else/ (/ x/ -/ 2/ :/ NN/ )/ )/ =/ 犇/ (/ x/ >/ 4/ )/ ∧/ (/ 犇/ (/ x/ -/ 3/ :/ NN/ )/ ifx/ >/ 4else/ 犇/ (/ x/ -/ 2/ :/ NN/ )/ )/ =/ tt/ ∧/ (/ (/ x/ >/ 4/ ∧/ x/ -/ 3/ / 0/ )/ ∨/ (/ x/ / 4/ ∧/ x/ -/ 2/ / 0/ )/ )/ =/ (/ x/ >/ 4/ )/ ∨/ (/ 2/ / x/ / 4/ )/ =/ 2/ / x/ 一个/ 表达式/ 的/ 域/ 最终/ 取决于/ 它/ 的/ 类型/ ./ 由于/ 这/ 一点/ 很/ 重要/ ,/ 我们/ 用/ / 来/ 表示/ 表达式/ 成立/ 的/ 条件/ ,/ 并/ 将/ 表达式/ 及其/ 类型/ 作为/ / 的/ 下标/ ./ 比如说/ ,/ 对于/ 自然数/ 类型/ NN/ ,/ 如果/ 表达式/ n/ -/ 1/ 被/ 定义/ ,/ 则/ n/ 必须/ 大于/ 等于/ 1/ ,/ 即/ / NN/ (/ n/ -/ 1/ )/ =/ n/ / 1/ ./ 然而/ ,/ 若/ 上述/ 表达式/ 的/ 类型/ 是/ 整数/ Ζ/ ,/ 则/ / ZZ/ (/ n/ -/ 1/ )/ =/ true/ ./ 3.2/ 结点/ (/ Node/ )/ 我们/ 使用/ 执行/ 树/ (/ ExecutionTree/ )/ 来/ 表示/ 每/ 一个/ 程序/ ,/ 每/ 一棵/ 执行/ 树/ 的/ 形状/ 与/ 程序/ 的/ 语法/ 相关/ ,/ 并且/ 树中/ 的/ 结点/ 所/ 记录/ 的/ 信息/ 包括/ 当前/ 语句/ 与/ 在/ 循环/ 及/ 选择/ 情况/ 下/ 所/ 伴随/ 的/ 条件/ 的/ 结合/ ,/ 以及/ 在/ 赋值/ 、/ 输入/ 、/ 输出/ 情况/ 下/ 这个/ 伴随/ 条件/ 表达式/ 的/ 域/ ,/ 这些/ 信息/ 将/ 用于/ 测试/ ./ 定义/ 3/ ./ 结点/ ./ 一个/ 结点/ 由/ 一个/ 标记/ (/ label/ )/ 和/ 一个/ 条件/ 组成/ ./ 标记/ (/ label/ )/ 通常/ 是/ 对/ 结点/ 本身/ 的/ 一个/ 说明/ ,/ 但是/ 顺序/ 组合/ 的/ 情况/ 除外/ ,/ 因为/ 顺序/ 组合/ 被/ 禁止/ 反复/ 执行/ (/ 同样/ 的/ ,/ 循环/ whilecdoP/ 被/ 替代/ 为/ 它/ 的/ 第一次/ 执行/ 的/ 情况/ )/ ./ 其中/ ,/ in/ 、/ out/ 用来/ 标识/ 输入/ 、/ 输出/ 结点/ ,/ ass/ 代表/ 赋值/ 结点/ ,/ ch/ 表示/ 选择/ 控制/ 结点/ ./ 条件/ 包含/ 两种/ ,/ 一种/ 是/ 表达式/ 定义/ 所/ 需/ 满足/ 的/ 条件/ ,/ 另/ 一种/ 是/ 二元/ 分支/ 选择/ 的/ 控制/ 谓词/ ./ 故/ 结点/ 的/ 定义/ 可/ 被/ 描述/ 为/ 3.3/ 执行/ 树/ (/ ExecutionTree/ )/ 我们/ 将/ 一个/ 程序/ 表示/ 为/ 一棵/ 执行/ 树/ ,/ 假定/ 树中/ 结点/ 的/ 类型/ 为/ N/ =/ Nodes/ ,/ 则/ 树/ 含有/ 以下/ 几种/ 类型/ ./ / N/ ∷/ =/ leafN/ |/ linkN/ (/ / N/ )/ |/ forkN/ (/ / N/ )/ (/ / N/ )/ (/ 1/ )/ 仅/ 含有/ 一个/ 叶子/ 结点/ 的/ 树/ (/ leafN/ )/ ;/ (/ 2/ )/ 含有/ 一个/ 根/ 结点/ ,/ 及根/ 结点/ 的/ 子树/ (/ 子树/ 可能/ 为/ (/ 1/ )/ 、/ (/ 2/ )/ 、/ (/ 3/ )/ 中/ 的/ 任一/ 类型/ )/ 的/ 树/ (/ linkN/ (/ / N/ )/ )/ ;/ (/ 3/ )/ 含有/ 一个/ 分支/ 控制/ 结点/ ,/ 及其/ 子树/ 的/ 树/ (/ forkN/ (/ / N/ )/ (/ / N/ )/ )/ ./ 为了/ 表示/ 的/ 方便性/ ,/ 我们/ 使用/ / (/ X/ )/ 来/ 表示/ / Node/ ./ 不难/ 发现/ ,/ 一棵树/ 的/ 形状/ 取决于/ 每/ 一个/ 非/ 叶子/ 结点/ 是/ fork/ (/ 二元/ )/ 还是/ link/ (/ 一元/ )/ ./ 为了/ 将/ 一个/ 程序转换/ 成/ 相应/ 的/ 可/ 执行/ 树/ 的/ ,/ 我们/ 定义/ 了/ 相应/ 的/ 转换规则/ ./ 首先/ 对于/ 原子/ 程序/ ,/ 它们/ 将/ 被/ 转换成/ 树中/ 相应/ Page5/ 类型/ 的/ 结点/ ,/ 转换规则/ 如式/ (/ 20/ )/ 所示/ ./ 从式/ (/ 20/ )/ 可以/ 看出/ ,/ 每/ 一个/ 原子/ 程序/ 都/ 被/ 转换成/ 一个/ 结点/ (/ 即/ 只/ 包含/ 一个/ 结点/ 的/ 树/ )/ ,/ 结点/ 标识/ 即/ 为/ 对应/ 的/ 语句/ 类型/ ,/ 如/ skip/ ,/ abort/ ,/ ass/ 等/ ,/ 而/ 结点/ 的/ 条件/ 即/ 为/ 表达式/ 成立/ 的/ 条件/ ./ 对于/ 更/ 普遍/ 的/ 情况/ :/ 假定/ α/ 是/ 一个/ 原子/ 程序/ ,/ P/ 、/ Q/ 分别/ 是/ 两段/ 程序/ ,/ 且/ c/ 是/ X/ 上/ 的/ 一个/ 条件/ ,/ 转换规则/ 如式/ (/ 21/ )/ 所示/ ./ tr/ :/ / (/ X/ )/ →/ / (/ X/ )/ 烄/ tr/ (/ α/ )/ =/ leafn/ (/ α/ )/ // / 一个/ 原子/ 程序/ 被/ 转换成/ 一个/ 叶子/ 结点/ ,/ 即/ 只/ 含/ 一个/ 结点/ 的/ 树/ / // tr/ (/ α/ ;/ P/ )/ =/ linkn/ (/ α/ )/ tr/ (/ P/ )/ // / linkn/ (/ α/ )/ 为/ 一个/ 连接/ 结点/ ,/ tr/ (/ P/ )/ 是/ 此/ 结点/ 的/ 烅/ 子/ 树/ / // tr/ (/ PifcelseQ/ )/ =/ fork/ (/ ch/ ,/ c/ )/ tr/ (/ P/ )/ tr/ (/ Q/ )/ // / fork/ (/ ch/ ,/ c/ )/ 是/ 一个/ 分支/ 控制/ 结点/ ,/ tr/ (/ P/ )/ ,/ tr/ (/ Q/ )/ 为/ 它/ 的/ 两棵/ 子树/ / // tr/ (/ whilecdoP/ )/ =/ linkn/ (/ pl/ )/ tr/ (/ Pifcelseskip/ )/ // / 循环/ 的/ 表示/ ,/ pl/ 为/ 程序段/ P/ 中/ 最后/ 一条/ 语句/ / 烆/ 一个/ 程序/ 的/ 执行/ 树是/ 由/ 程序/ 语法/ (/ 而/ 不是/ 基于/ // / 函数/ td/ 的/ 输出/ 为/ 一棵树/ ,/ 输出/ 为/ 修改/ 后/ 的/ 树/ ,/ C/ (/ n/ )/ 表示/ 结点/ n/ 上/ 的/ 条件/ / // // / 含有/ 一个/ 根/ 结点/ n/ ,/ 及其/ 子/ 结点/ (/ n/ )/ 的/ 树/ ,/ 经过/ 修改/ ,/ C/ (/ n/ )/ =/ C/ (/ n/ )/ ∧/ C/ (/ n/ )/ / // // / 树/ 的/ 根/ 结点/ 为/ n/ ,/ 且/ n/ 的/ 子树/ 的/ 根/ 结点/ 为/ n/ ,/ 经/ 修改/ 后/ ,/ C/ (/ n/ )/ =/ C/ (/ n/ )/ ∧/ C/ (/ n/ )/ / // // / 树/ 的/ 根/ 结点/ 为/ n/ ,/ 且/ n/ 的/ 子树/ 的/ 根/ 结点/ 是/ 一个/ 分支/ 控制/ 结点/ (/ n/ )/ ,/ 修改/ 后/ ,/ // / 树/ 的/ 根/ 结点/ 为/ 分支/ 控制/ 结点/ (/ n/ )/ ,/ 设/ 其子/ 树/ 的/ 根/ 结点/ 分别/ 为/ n1/ ,/ n2/ ,/ 则/ 修改/ 后/ ,/ 其中/ ,/ // / tdd/ 的/ 输入/ 为/ 一个/ 结点/ 和/ 一棵树/ ,/ 输出/ 为/ 修改/ 后/ 的/ 树/ / // tdd/ (/ (/ ch/ ,/ c/ )/ (/ fork/ (/ m/ ,/ d/ )/ T0T1/ )/ )/ =/ td/ (/ fork/ (/ m/ ,/ c/ ∧/ d/ )/ T0T1/ (/ 2/ )/ 我们/ 将/ 进一步/ 修改/ 函数/ td/ ,/ 计算/ 出/ 每个/ 结点/ 的/ 条件/ ,/ 并/ 去/ 除根/ 结点/ 带有/ 条件/ ff/ 的/ 子树/ (/ 注/ :/ 程序/ 语义/ )/ 来/ 定义/ 的/ ./ 故/ tr/ (/ skip/ ;/ P/ )/ ≠/ tr/ (/ P/ )/ (/ tr/ 为/ 程序转换/ 为/ 执行/ 树/ 的/ 规则/ ,/ 见式/ (/ 21/ )/ )/ ,/ 因为/ tr/ (/ skip/ ;/ P/ )/ 中/ 包含/ 一条/ 额外/ 的/ 边/ ./ 3.4/ 修改/ 程序/ 的/ 可/ 执行/ 树/ 基于/ 一棵/ 执行/ 树/ 生成/ 测试用例/ 时/ ,/ 是/ 通过/ 在/ 输出/ 结点/ 处/ 得到/ 树中/ 从/ 输入/ 到/ 输出/ 这/ 条/ 路径/ 上/ 所有/ 域/ 及/ 条件/ 的/ 聚合/ (/ 一个/ 布尔/ 表达式/ )/ ./ 在/ 使用/ 这种/ 方法/ 时/ ,/ 从未/ 被/ 执行/ 的/ 路径/ (/ 比如/ ,/ 由于/ 路径/ 上/ 条件/ 的/ 不/ 一致/ ,/ 或者/ 条件/ 与/ 路径/ 上/ 的/ 某个/ 域/ 的/ 不/ 一致/ 所/ 导致/ 的/ 路径/ 无法/ 被/ 执行/ )/ 将/ 被/ 忽略/ ./ 为了/ 去掉/ 执行/ 树中/ 从不/ 被/ 执行/ 的/ 路径/ ,/ 我们/ ?/ 用/ 下述/ 方法/ ./ (/ 1/ )/ 定义/ 函数/ td/ ./ 函数/ td/ 的/ 作用/ 是/ 修改/ 一棵树/ 以/ 使得/ 其/ 具有/ 如下/ 属性/ :/ 每/ 一个/ 结点/ 包含/ 的/ 条件/ 的/ 强度/ 高于/ 或/ 等于/ 处于/ 此/ 结点/ 上层/ 的/ 结点/ 条件/ 的/ 强度/ ./ 为了/ 实现/ 这个/ 功能/ ,/ td/ 只是/ 简单/ 的/ 将/ 支/ 路上/ 的/ 域/ 和/ 条件/ 联合/ 起来/ 并/ 顺着/ 支路/ 传递/ 下去/ ,/ 对于/ 支/ 路上/ 的/ fork/ 结点/ ,/ 结点/ 上/ 的/ 条件/ 或/ 条件/ 的/ 否定/ 形式/ (/ 适合/ 于/ 当前/ 支路/ 的/ 一种/ )/ 将/ 被/ 联合/ 起来/ ./ 故/ 通过/ 递归/ 的/ 定义/ 可以/ 匹配/ 路径/ 上/ 的/ 一连串/ 的/ 结点/ ./ 这里/ 通过/ 使用/ 另/ 一个/ 函数/ tdd/ 来/ 实现/ 相互/ 递归/ 定义/ ,/ 这样/ 可以/ 避免/ 不同/ 情况/ 的/ 重复/ ./ 如式/ (/ 22/ )/ 所示/ ./ 基于/ 一棵/ 执行/ 树/ 生成/ 测试用例/ ,/ 是/ 基于/ 输出/ 结点/ 处/ 得到/ 的/ 从/ 输入/ 到/ 输出/ 这/ 条/ 路径/ 上/ 所有/ 域/ 及/ 条件/ 的/ 聚/ Page6/ 合/ :/ 一个/ 布尔/ 型/ 表达式/ ./ 当/ 结点/ 上/ 条件/ 表达式/ 值为/ 真时/ ,/ 包含/ 此/ 结点/ 从/ 输入/ 至/ 输出/ 的/ 路径/ 上/ 所有/ 条件/ 的/ 聚合/ 才/ 有/ 可能/ 为/ 真/ ,/ 从而/ 可以/ 选择/ 满足/ 此/ 聚合/ 条件/ 的/ 测试用例/ ./ 如果/ 一个/ 结点/ 的/ 条件/ 为/ 假/ ,/ 包含/ 此/ 结点/ 的/ 任意/ 一条/ 路径/ 的/ 条件/ 聚合/ 必定/ 为/ 假/ ,/ 即/ 不能/ 找到/ 满足条件/ 的/ 测试用例/ ./ 例如/ ,/ 结点/ 中/ 包含/ x/ </ 3x/ >/ 4/ ,/ 我们/ 找/ 不到/ 使得/ 此/ 条件/ 为/ 真的/ x/ ,/ 因此/ 该/ 条件/ 所/ 对应/ 的/ 测试用例/ 集为/ 空/ ./ 在/ 生成/ 测试用例/ 时/ ,/ 条件/ 为/ 假/ 的/ 结点/ 以及/ 它/ 的/ 子树/ ,/ 不能/ 生成/ 测试用例/ ,/ 故/ 可以/ 删去/ )/ ./ 过程/ 描述/ 为/ 通过/ 定义/ 函数/ td/ ,/ 将/ 一个/ 程序转换/ 成/ 一棵树/ 的/ 经过/ 上述/ 处理/ 后/ ,/ 最后/ 获得/ 的/ 执行/ 树中/ 的/ 所有/ 路径/ 都/ 是/ 可行/ 的/ ./ 3.5/ 对/ 循环/ 的/ 处理/ 在/ 不同/ 的/ 情况/ 下/ ,/ 需要/ 将/ 循环展开/ 到/ 不同/ 的/ 深度/ ./ 为了/ 使/ 测试者/ 将/ 循环展开/ 到/ 任意/ 的/ 深度/ ,/ 以便/ 满足/ 各种/ 不同/ 的/ 需要/ ,/ 我们/ 定义/ 了/ 函数/ trn/ ./ 根据/ 用户/ 需要/ 的/ 循环展开/ 深度/ ,/ 函数/ trn/ 为/ 程序/ 生成/ 执行/ 树/ ,/ 它/ 的/ 输入/ 是/ 一个/ 数/ n/ (/ 循环/ 的/ 展开/ 深度/ )/ 和/ 一个/ 程序/ P/ ,/ 输出/ 是/ 程序/ 的/ 执行/ 树/ (/ 程序/ P/ 中/ 的/ 所有/ 循环/ 都/ 展开/ 至/ n/ 次/ )/ ./ Trn/ 的/ 定义/ 如式/ (/ 25/ )/ 所示/ ./ trn/ :/ N/ →/ / (/ X/ )/ →/ / (/ X/ )/ 烄/ trn0/ (/ whilecdoP/ )/ =/ skiptrn/ (/ n/ +/ 1/ )/ (/ whilecdoP/ )/ =/ (/ Pifcelseskip/ )/ ;/ 烅/ 烆/ trnnP/ =/ trP3/ ./ 6/ 测试用例/ 既然/ 我们/ 己/ 经为/ 一个/ 程序/ 生成/ 了/ 一棵/ 执行/ 树/ ,/ 一个/ 测试/ 序列/ (/ 测试用例/ )/ 可以/ 被/ 定义/ 为/ 由/ 执行/ 树中/ 一条/ 路径/ 上/ 的/ 输入/ 和/ 输出/ 组成/ ./ 一个/ 输出/ 可能/ 依赖于/ 它/ 前面/ 的/ 某个/ 输入/ ,/ 但是/ 想要/ 确定/ 是/ 哪/ 一个/ 是/ 很/ 困难/ 的/ ,/ 因此/ 在/ 此/ 输出/ 前面/ 的/ 所有/ 输入/ 都/ 将/ 被/ 记录下来/ ./ 值得注意/ 的/ 是/ ,/ 输入/ 与/ 输出/ 有/ 可能/ 是/ 交叉/ 的/ ,/ 甚至/ 会/ 出现/ 在/ 一个/ 输入/ 后面/ 没有/ 任何/ 输出/ 的/ 情况/ (/ 这是/ 一种/ 异常情况/ ,/ 但是/ 我们/ 不想/ 对/ 程序/ 有/ 更/ 多/ 的/ 约束/ ,/ 特别/ 是从/ 式/ (/ 19/ )/ 的/ 角度/ )/ ./ 每/ 一个/ 输出/ 取决于/ 从/ 树根/ 开始/ 的/ 一条/ 唯一/ 的/ 路径/ ,/ 并且/ 依赖于/ 一组/ 被/ 定义/ 好/ 顺序/ 的/ 输入/ ./ 就/ 同/ 在/ 前面/ 几/ 部分/ 所/ 预期/ 的/ 一样/ ,/ 我们/ 只/ 考虑/ 实际上/ 可以/ 执行/ 的/ 路径/ ./ 换句话说/ ,/ 对于/ 程序/ P/ ,/ 我们/ 只/ 考虑/ 执行/ 树/ t/ (/ P/ )/ 中/ 的/ 路径/ ./ 例/ :/ 状态/ 空间/ X/ =/ N/ ,/ 程序/ 如下/ 所示/ ?/ x/ ;/ (/ x/ ·/ ·/ =/ x/ -/ 3/ )/ ifodd/ (/ x/ )/ else/ (/ x/ ·/ ·/ =/ x/ -/ 2/ )/ ;/ !/ (/ x/ +/ 1/ )/ 上述/ 程序/ 有/ 两个/ 测试用例/ ,/ 每/ 一个/ 分别/ 对应/ 二元/ 选择/ 中/ 的/ 一条/ 分支/ ./ 在/ if/ 对应/ 的/ 分支/ 中/ ,/ 条件/ 是/ odd/ (/ x/ )/ 以及/ 定义/ 语句/ x/ ·/ ·/ =/ x/ -/ 3/ 所/ 需要/ 的/ x/ / 3/ ./ 而/ 在/ else/ 对应/ 的/ 分支/ 中/ ,/ 条件/ 是/ even/ (/ x/ )/ ,/ 以及/ 定义/ 语句/ x/ ·/ ·/ =/ x/ -/ 2/ 所/ 需要/ 的/ x/ / 2/ ./ 测试用例/ 包含/ 从/ 输出/ 至/ 输出/ 路径/ 上/ 的/ 所有/ 输入/ 、/ 输出/ 结点/ ,/ 如下/ 所示/ :/ 这里/ 我们/ 不/ 关心/ 测试用例/ 生成/ 的/ 顺序/ ,/ 而/ 只/ 考虑/ 这/ 两个/ 用例/ 是/ 用/ 例集/ 的/ 两个/ 成员/ ./ 为了/ 基于/ 执行/ 树/ 生成/ 测试用例/ ,/ 我们/ 定义/ 了/ 一个/ 函数/ testd/ ,/ 它/ 将/ 基于/ 一棵/ 执行/ 树/ 生成/ 一个/ 测试用例/ 的/ 集合/ (/ 即/ 路径/ 的/ 集合/ ,/ 在/ 实现/ 中是/ 一个/ 序列/ ,/ 并且/ 序列/ 的/ 连接/ 操作/ 将/ 替代/ 合并/ 操作/ )/ ./ 主要/ 思想/ 如下/ :/ 的/ 结点/ ./ 即/ 我们/ 只/ 考虑/ 标记/ 为/ in/ 或者/ out/ ,/ 且/ 条件/ 不为/ 假/ 对于/ 一棵/ 叶子/ 树/ (/ leaftree/ )/ ,/ 如果/ 它/ 满足条件/ (/ 26/ )/ ,/ 则/ 这个/ 结点/ 将/ 被/ 当作/ 一个/ 单独/ 的/ 序列/ 返回/ ,/ 且/ 测试/ 集中/ 只/ 包含/ 这/ 一个/ 序列/ ;/ 否则/ ,/ 测试/ 集中/ 只/ 包含/ 所/ 返回/ 的/ 空/ 序列/ ./ 对于/ 一棵/ 没有/ 分支/ 的/ 树/ (/ linktree/ )/ ,/ 如果/ 它/ 满足条件/ (/ 26/ )/ ,/ 则/ 从/ 树根/ 至/ 输出/ 结点/ 这/ 条/ 路径/ 上/ 的/ 所有/ 结点/ 所/ 组成/ 的/ 序列/ 将会/ 被/ 返回/ ;/ 否则/ ,/ 对/ 除根/ 结点/ 外/ 的/ 子树/ 的/ 递归/ 调用/ 的/ 集合/ 将会/ 被/ 返回/ ./ 对于/ 一棵/ 分叉/ 树/ (/ forktree/ )/ ,/ 如果/ 它/ 满足条件/ (/ 26/ )/ ,/ 由树/ 中/ 每/ 一条/ 路径/ 上/ 的/ 结点/ 所/ 组成/ 的/ 序列/ 都/ 会/ 被/ 返回/ ;/ 否则/ ,/ 对/ 其中/ 所有/ 子树/ 的/ 递归/ 调用/ 的/ 集合/ 将/ 被/ 返回/ ./ 为了/ 方便/ 描述/ ,/ 使用/ map/ (/ n/ :/ )/ 表示/ 一个/ 序列/ 的/ 集合/ ,/ 且/ 每个/ 序列/ 都/ 被/ 加上/ 前缀/ n/ ./ 则/ 有/ map/ (/ 0/ :/ )/ {/ [/ 1/ ,/ 2/ ]/ ,/ [/ ]/ ,/ [/ 0/ ]/ }/ =/ {/ [/ 0/ ,/ 1/ ,/ 2/ ]/ ,/ [/ 0/ ]/ ,/ [/ 0/ ,/ 0/ ]/ }/ 这样/ ,/ testd/ 可以/ 被/ 描述/ 为式/ (/ 27/ )/ ./ testd/ :/ / (/ X/ )/ →/ PP/ (/ seqNode/ )/ 烄/ testd/ (/ leafn/ )/ =/ {/ [/ n/ ]/ }/ ifcondition/ (/ 26/ )/ else/ {/ [/ ]/ }/ testd/ (/ linknT/ )/ =/ map/ (/ n/ :/ )/ (/ testdT/ )/ 烅/ testd/ (/ forknT0T1/ )/ =/ (/ map/ (/ n/ :/ )/ (/ testdT0/ )/ )/ ∪/ (/ map/ (/ n/ :/ )/ (/ testdT1/ )/ )/ ifcondition/ (/ 26/ )/ else/ (/ testdT0/ )/ ∪/ (/ testdT1/ 烆/ Page7/ 因为/ 我们/ 没有/ 考虑/ 测试/ 序列/ 生成/ 的/ 顺序/ ,/ 故/ 函数/ 的/ 执行/ 结果/ 为/ 一个/ 测试/ 序列/ 的/ 集合/ ,/ 且/ 每/ 一个/ 测试/ 序列/ 中/ 可能/ 含有/ 多个/ 输入/ 和/ 输出/ ./ 如果/ 想要/ 基于/ 执行/ 树所/ 生成/ 的/ 测试用例/ 集/ ,/ 进一步/ 生成/ 包含/ 单/ 输出/ 的/ 测试用例/ ,/ 对于/ 这种/ 情况/ ,/ 每/ 一条/ 包含/ 多个/ 输出/ 的/ 路径/ 将/ 生成/ 多个/ 单/ 输出/ 的/ 测试用例/ ,/ 并且/ 如果/ 两种/ 测试用例/ 同时/ 生成/ ,/ 将会/ 提高效率/ ./ 假设/ 所有/ 的/ 输出/ 都/ 将/ 被/ 测试/ ,/ 并且/ 有/ 多种/ 测试方法/ ,/ 那么/ 可以/ 进行/ 一些/ 选择/ ./ 例如/ ,/ 可以/ 基于/ 优先权/ 进行/ 选择/ ,/ 设定/ 优先权/ 为/ 覆盖/ 所有/ 的/ 条件/ ./ 所有/ 上述/ 的/ 特殊/ 情况/ ,/ 都/ 可以/ 从/ 前面/ 所/ 给/ 的/ 定义/ 中/ 得到/ ./ 测试用例/ 生成/ 过程/ 的/ 特点/ 如下/ :/ 首先/ ,/ 测试用例/ 是/ 由/ 可行/ 的/ 执行/ 路径/ (/ 由/ 条件/ 不为/ 假/ 的/ 输入/ 、/ 输出/ 结点/ 构成/ )/ 产生/ ;/ 其次/ ,/ 在/ 单条/ 路径/ 里/ 没有/ 分支/ ,/ 但是/ 所有/ 的/ 执行/ 路径/ 覆盖/ 了/ 程序/ 的/ 所有/ 分支/ 结构/ ;/ 再次/ ,/ 原型/ 工具/ 最终/ 输出/ 的/ 测试用例/ 是/ 用/ 结点/ 上/ 的/ 条件/ 的/ 聚合/ 来/ 表示/ 的/ ./ 3.7/ 测试用例/ 的/ 正确性/ 分析/ 正确/ 的/ 测试用例/ ,/ 即/ 满足/ 程序/ 语义/ 的/ ,/ 能够/ 反应/ 程序/ 的/ 真实/ 执行/ 情况/ 的/ 测试用例/ ./ 本文/ 以/ Hoare/ 规则/ 为/ 基础/ 生成/ 测试用例/ ,/ 故所/ 生成/ 测试用例/ 都/ 是/ 正确/ 的/ ./ Hoare/ 规则/ 在/ 文中/ 用/ 在/ 以下/ 几个/ 方面/ :/ (/ 1/ )/ 建立/ 程序/ 的/ 符号化/ 表示/ ./ 基于/ Hoare/ 规则/ 获得/ 程序/ 的/ 符号/ 表示/ 使得/ 程序/ 的/ 语义/ 信息/ 被/ 保留/ ,/ 所/ 获得/ 的/ GCL/ 程序/ 可以/ 完整/ 的/ 描述/ 源程序/ 的/ 执行/ 特性/ ./ (/ 2/ )/ 构建/ 程序/ 的/ 执行/ 树/ ./ 执行/ 树/ 的/ 构建/ 基于/ GCL/ 程序/ 的/ 语法/ ,/ 因此/ 执行/ 树/ 反映/ 了/ 程序/ 的/ 结构/ 信息/ ;/ 同时/ ,/ 执行/ 树/ 的/ 构建/ 依照/ Hoare/ 所/ 提供/ 的/ GCL/ 运行/ 规则/ ,/ 从而/ 执行/ 树中/ 隐含/ 了/ 程序/ 的/ 执行/ 语义/ ./ (/ 3/ )/ 结点/ 的/ 条件/ 计算/ ./ 结点/ 条件/ 的/ 计算/ 过程/ 符合/ Hoare/ 所/ 提供/ 的/ 规则/ ,/ 经过/ 处理/ 后/ 的/ 结点/ 条件/ ,/ 即/ 为/ 该/ 结点/ 所/ 对应/ 程序/ 语句/ 能/ 被/ 执行/ 的/ 条件/ ./ 综上所述/ ,/ 本文/ 方法/ 所/ 生成/ 的/ 测试用例/ ,/ 符合/ 程序执行/ 的/ 动态/ 情况/ ,/ 是/ 正确/ 的/ 测试用例/ ./ 3.8/ 算法/ 复杂度/ 描述/ 为/ 对于/ 一个/ 程序/ ,/ 为/ 其/ 生成/ 测试用例/ 的/ 过程/ 可以/ 假定/ 程序/ 中有/ n/ 个/ 条件/ (/ 其中/ ,/ n1/ 个/ 分支/ 控制/ 条件/ ,/ n2/ 个/ 循环/ 控制/ 条件/ )/ ,/ s/ 条/ 语句/ ,/ 则/ 可以/ 通过/ 以下/ 方法/ 来/ 分析/ 算法/ 复杂度/ (/ 时间/ 复杂度/ )/ ./ (/ 1/ )/ 函数/ tr/ 对于/ 函数/ tr/ ,/ 其/ 算法/ 复杂度/ 只/ 与/ 执行/ 树/ 的/ 结点/ 个数/ 有/ 关系/ ,/ 故/ 循环/ 的/ 嵌套/ 或者/ 展开/ 深度/ 不会/ 影响/ tr/ 的/ 复杂度/ ,/ 同样/ ,/ 分支/ 的/ 嵌套/ 也/ 不会/ 影响/ tr/ 的/ 复杂度/ ./ 故/ 函数/ tr/ 的/ 复杂度/ 为/ O/ (/ n/ +/ s/ )/ ./ (/ 2/ )/ 函数/ tdtd/ 包含/ 两/ 部分/ 工作/ :/ 一是/ 依据/ 规则/ 修改/ 每个/ 结点/ 的/ 条件/ ;/ 二是/ 计算/ 每个/ 结点/ 的/ 条件/ ,/ 并/ 去除/ 树中根/ 结点/ 含有/ 条件/ ff/ 的/ 子树/ (/ 标记/ 为/ 不可/ 执行/ )/ ./ 对于/ 前者/ ,/ 时间/ 复杂度/ 为/ O/ (/ s/ +/ n/ )/ ./ 对于/ 后者/ ,/ 由/ 文献/ [/ 10/ ]/ 可知/ ,/ 对于/ 一个/ 包含/ n/ 个/ 条件/ 的/ 集合/ ,/ 如果/ 其中/ 有/ k/ 对/ 条件/ 不相容/ ,/ 则/ 需要/ O/ (/ nlogn/ +/ k/ )/ 的/ 时间/ 去/ 找到/ 这些/ 不相容/ 的/ 条件/ ./ 嵌套循环/ 或/ 分支/ 对/ 函数/ td/ 的/ 算法/ 复杂度/ 没有/ 影响/ ./ 函数/ td/ 的/ 复杂度/ 为/ O/ (/ s/ +/ n/ )/ +/ O/ (/ nlogn/ +/ k/ )/ ./ (/ 3/ )/ 函数/ testd/ 利用/ td/ ,/ 我们/ 对树中/ 结点/ 的/ 条件/ 进行/ 演算/ ,/ 去掉/ 条件/ 为/ 假/ 的/ 结点/ 以及/ 其子/ 树/ ,/ 故/ 在/ 生成/ 测试用例/ 时/ 所用/ 到/ 的/ 执行/ 树/ 的/ 规模/ 已经/ 减小/ ,/ 从而/ 算法/ 的/ 复杂度/ 也/ 会/ 降低/ ./ 假定/ td/ 所/ 删去/ 的/ 结点/ 数为/ x/ ,/ 其中/ 分支/ 条件/ 结点/ 为/ x1/ 个/ ,/ 循环/ 条件/ 结点/ 为/ x2/ 个/ ./ 因此/ 在/ 生成/ 执行/ 路径/ 时/ ,/ 所/ 使用/ 的/ 执行/ 树中/ 含有/ (/ n/ +/ s/ -/ x/ )/ 个/ 结点/ ,/ 其中/ 分支/ 条件/ 结点/ 为/ (/ n1/ -/ x1/ )/ 个/ ,/ 循环/ 条件/ 结点/ 为/ (/ n2/ -/ x2/ )/ 个/ ./ 在/ 生成/ 可/ 执行/ 的/ 执行/ 路径/ 时/ ,/ 路径/ 的/ 数目/ 与/ 条件/ 结点/ 的/ 个数/ 以及/ 位置/ 有/ 关系/ ./ 对于/ (/ n1/ -/ x1/ )/ 个/ 分支/ 条件/ 结点/ ,/ 最多/ 可/ 生成/ 2n1/ -/ x1/ 条/ 路径/ ,/ 复杂度/ 为/ O/ (/ 2n1/ -/ x1/ )/ ./ 对于/ (/ n2/ -/ x2/ )/ 个/ 循环/ 条件/ 结点/ ,/ 若/ 把/ 循环/ 当作/ 一个/ 分支/ 结构/ 来/ 处理/ ,/ 则/ 最坏/ 的/ 复杂度/ 为/ O/ (/ 2n2/ -/ x2/ )/ ;/ 若/ 考虑/ 循环/ 的/ 展开/ 深度/ ,/ 假定/ 每个/ 循环/ 的/ 展开/ 深度/ 为/ y/ ,/ 则/ 复杂度/ 最大/ 为/ O/ (/ 2y/ (/ n2/ -/ x2/ )/ )/ ./ 综上所述/ ,/ 函数/ testd/ 最大/ 的/ 时间/ 复杂度/ 为/ O/ (/ 2n2/ -/ x1/ )/ +/ O/ (/ 2y/ (/ n2/ -/ x2/ )/ )/ ./ 文献/ [/ 1/ ]/ 中/ 生成/ 所有/ 测试/ 路径/ 算法/ 的/ 时间/ 为/ O/ (/ |/ E/ |/ |/ UE/ |/ 2/ )/ ,/ 其中/ E/ 是/ ddgraph/ 中边/ 的/ 条数/ ,/ |/ UE/ |/ 是/ 不/ 受约束/ 边/ 的/ 总数/ ./ 如果/ 程序/ 中/ 所有/ 的/ 条件/ 都/ 是/ 分开/ 的/ ,/ 并且/ n/ 的/ 值/ 很大/ 时/ ,/ O/ (/ |/ UE/ |/ )/ 接近/ 于/ O/ (/ n/ )/ ./ 故/ 文献/ [/ 1/ ]/ 中/ 的/ 复杂度/ 近似于/ O/ (/ n3/ )/ ./ 但/ 文献/ [/ 1/ ]/ 中/ 没有/ 考虑/ 循环/ 和/ 分支/ 嵌套/ 的/ 情况/ ./ 若/ 在/ 同样/ 的/ 条件/ 下/ 与/ 之/ 相比/ ,/ 本文/ 所/ 提出/ 的/ 方法/ 的/ 算法/ 复杂度/ 要/ 小得多/ ./ 注/ :/ 需要/ 对/ 上述/ 的/ 算法/ 复杂度/ 作/ 几点/ 说明/ :/ (/ 1/ )/ 尽/ Page8/ 管从/ 表达式/ 看/ 算法/ 复杂度/ 是/ 指数/ 增长/ 的/ 形式/ ,/ 但是/ 我们/ 可以/ 根据/ 软件/ 需求/ 和/ 具体/ 程序控制/ 循环/ 的/ 展开/ 深度/ ;/ (/ 2/ )/ 实验/ 结果/ 说明/ 此/ 方法/ 的/ 效果/ 良好/ ;/ (/ 3/ )/ 如果/ 进一步/ 考虑/ 循环/ 不/ 变量/ (/ loopinvariant/ )/ [/ 11/ ]/ ,/ 则/ 循环/ 的/ 深度/ 对/ 算法/ 复杂度/ 的/ 影响/ 不会/ 很大/ ./ 4/ 原型/ 工具/ 我们/ 用/ Haskell/ 语言/ 开发/ 了/ 一个/ 模型/ 工具/ ./ Haskell/ ①/ 是/ 一个/ 高层/ 应用/ 语言/ ./ 它/ 提供/ 了/ 很/ 好/ 的/ 抽象/ 机制/ 、/ 复杂/ 的/ 类型/ 系统/ 、/ 高层/ 计算/ 语言/ 及/ 高层/ 合作/ ./ 我们/ 对/ 以上/ 描述/ 的/ 算法/ 经过/ 简单/ 的/ 修改/ ,/ 然后/ 结合/ 输入输出/ 的/ 处理/ ,/ 就/ 可以/ 成为/ 一个/ 可以/ 执行/ 的/ Haskell/ 程序/ ./ 输入/ 规则/ 如下/ :/ (/ 1/ )/ 赋值/ 语句/ 用/ assign/ 表示/ ,/ 如/ i/ =/ 1/ 表示/ 为/ as/ -/ (/ 2/ )/ 输入/ 用/ input/ 表示/ ,/ 如/ c/ =/ getchar/ (/ )/ 表示/ 为/ (/ 3/ )/ 分支/ 语句/ 用/ if/ 表示/ ,/ 如/ if/ (/ cond/ )/ s1/ ;/ elsesign/ “/ i/ ”/ (/ Equ1/ )/ ./ input/ “/ c/ ”/ ./ s2/ ;/ 表示/ 为/ ifconds1s2/ ./ (/ 4/ )/ 循环/ 语句/ 用/ while/ 表示/ ,/ 如/ while/ (/ cond/ )/ s/ ;/ 表示/ 为/ whileconds/ ./ 模型/ 工具/ 的/ 输入/ 语言/ 是/ GCL/ ./ 如果/ 我们/ 选择/ C语言/ 作为/ 目标语言/ ,/ 那么/ 我们/ 需要/ 把/ C语言/ 描述/ 的/ 程序转换/ 为/ 由/ GCL/ 语言/ 描述/ 的/ 程序/ ./ 这里/ 我们/ 不/ 给出/ 详细/ 的/ 转化/ 细节/ ,/ 只/ 给出/ 几个/ 注意/ 点/ :/ 注意/ 点/ 1/ ./ 在/ 控制/ 条件/ 中/ 包含/ 输入/ 操作/ ,/ 即/ 转换成/ 我们/ 的/ 基于/ 序列化/ 程序/ 的/ 符号语言/ 为/ 注意/ 点/ 2/ ./ 如果/ 程序/ 是/ 反应式/ 的/ ,/ 那么/ 一个/ 新/ 的/ 输入/ 值/ 可能/ 是/ 不可/ 用/ 的/ ,/ 故/ 转换/ 后/ 的/ 代码/ 还要/ 使用/ 一个/ 布尔/ 型/ 表达式/ g/ ?/ 来/ 测试/ 从/ g/ 中/ 获得/ 的/ 输入/ 是否是/ 有/ 可用/ 的/ ./ 添加/ 了/ 对/ 输入/ 值/ 的/ 判断/ 后/ 的/ 程序/ 为/ 显然/ ,/ 如果/ 输入/ 一直/ 是/ 可用/ 的/ (/ g/ ?/ 一直/ 为/ 真/ )/ ,/ 则/ 上面/ 两个/ 程序/ 是/ 相符/ 的/ (/ 变量/ d/ 是/ 局部/ 的/ )/ ./ 注意/ 点/ 3/ ./ C语言/ 中/ 另/ 一种/ 表示/ 循环/ 的/ 方式/ 是/ 使用/ for/ 循环/ ,/ 如下/ 所示/ 它/ 可以/ 被/ 翻译成/ 如下/ 形式/ 我们/ ?/ 用/ 计算器/ 程序/ 中/ 的/ 一个/ 函数/ getop/ [/ 12/ ]/ 作为/ 我们/ 的/ 实例/ 来/ 生成/ 测试用例/ ./ 函数/ getop/ 的/ 作用/ 是/ 为/ 后面/ 的/ 计算器/ 程序/ 取得/ 算子/ 与/ 操作数/ ./ 函数/ 等待/ 输入/ 数据/ ,/ 一旦/ 接收/ 到/ 数据/ ,/ 便/ 开始/ 执行/ ./ 由于/ getop/ 函数/ 具有/ 丰富/ 的/ 控制结构/ ,/ 它/ 适合/ 于/ 用来/ 作为/ 测试/ 或者/ 路径/ 选择/ 的/ 实例/ ,/ 而且/ 己经/ 被/ 作为/ 实例/ 来/ 说明/ 相似/ 的/ 问题/ [/ 1/ ]/ ./ getop/ 函数/ 的/ C语言/ 代码/ 如图/ 1/ 所示/ ./ getop/ 函数/ 的/ C语言/ 代码/ :/ 1/ ./ getop/ (/ s/ ,/ lim/ )/ {/ // / getnextoperatororoperand/ / // 2/ ./ // / wewillstartfromhere/ / // 3/ ./ inti/ (/ =/ 0/ )/ ,/ c/ (/ =/ 0/ )/ ;/ 4/ ./ while/ (/ (/ c/ =/ getchar/ (/ )/ )/ =/ =/ ’/ ’/ ‖/ c/ =/ =/ ’/ \/ t/ ’/ ‖/ c/ =/ =/ ’/ \/ n/ ’/ )/ ;/ 5/ ./ if/ (/ c/ !/ =/ ’/ ./ ’/ &&/ (/ c/ </ ’/ 0/ ’/ ‖/ c/ >/ ’/ 9/ ’/ )/ )/ 6/ ./ return/ (/ c/ )/ ;/ 7/ ./ s/ [/ 0/ ]/ =/ c/ ;/ 8/ ./ for/ (/ i/ =/ 1/ ;/ (/ c/ =/ getchar/ (/ )/ )/ >/ =/ ’/ 0/ ’/ &&/ c/ </ =/ ’/ 9/ ’/ ;/ i/ ++/ )/ {/ 9/ ./ if/ (/ i/ </ lim/ )/ 10/ ./ s/ [/ i/ ]/ =/ c/ ;/ 11/ ./ }/ 12/ ./ if/ (/ c/ =/ =/ ’/ ./ ’/ )/ // / collectfraction/ / // {/ 13/ ./ if/ (/ i/ </ lim/ )/ 14/ ./ s/ [/ i/ ]/ =/ c/ ;/ 15/ ./ for/ (/ i/ ++/ ;/ c/ =/ getchar/ (/ )/ )/ >/ =/ ’/ 0/ ’/ &&/ c/ </ =/ ’/ 9/ ’/ ;/ i/ ++/ )/ {/ 16/ ./ if/ (/ i/ </ lim/ )/ 17/ ./ s/ [/ i/ ]/ =/ c/ ;/ 18/ ./ }/ 19/ ./ }/ 20/ ./ if/ (/ i/ </ lim/ )/ // / numberisOK/ / // {/ 21/ ./ ungetchar/ (/ c/ )/ ;/ 22/ ./ s/ [/ i/ ]/ =/ ’/ \/ 0/ ’/ ;/ 23/ ./ return/ (/ NUMBER/ )/ ;/ 24/ ./ }/ 25/ ./ else/ {/ 26/ ./ while/ (/ c/ !/ =/ ’/ \/ n/ ’/ &&/ c/ !/ =/ EOF/ )/ 27/ ./ c/ =/ getchar/ (/ )/ ;/ 28/ ./ s/ [/ lim/ ./ 1/ ]/ =/ ’/ \/ 0/ ’/ ;/ 29/ ./ return/ (/ TOOBIG/ )/ ;/ 30/ ./ }/ 31/ ./ }/ 32/ ./ }/ ①/ TheHaskellTeam/ ./ Haskell/ ./ http/ :/ // // www/ ./ haskell/ ./ orgPage9/ 通过/ 模型/ 工具/ 中/ 的/ GCL/ 翻译器/ 把/ 这/ 段程序/ 翻译成/ 由/ GCL/ 描述/ 的/ 程序/ ./ 翻译/ 过程/ 如图/ 2/ 所示/ ./ 根据/ 输出/ 结果/ ,/ getop/ 函数/ 的/ GCL/ 符号化/ 表示/ 如图/ 3/ 所示/ ./ getop/ 函数/ 的/ 符号化/ 表示/ :/ 1/ ./ Prog/ =/ i/ ,/ c/ ·/ ·/ =/ …/ ;/ 2/ ./ While/ (/ cond1/ ∧/ c/ ?/ )/ doskip/ ;/ 3/ ./ (/ return/ ·/ ·/ =/ c/ )/ ifcond2elseskip/ ;/ 4/ ./ s/ (/ 0/ )/ ,/ i/ ·/ ·/ =/ c/ ,/ 1/ ;/ 5/ ./ while/ (/ cond3/ ∧/ c/ ?/ )/ do6/ ./ (/ s/ [/ i/ ]/ ,/ i/ ·/ ·/ =/ c/ ,/ i/ +/ 1/ )/ ifcond4elseskip/ ;/ 7/ ./ Aifcond5elseskip/ ;/ 8/ ./ Bifcond6elseC/ ;/ 9/ ./ where10/ ./ A/ =/ (/ s/ [/ i/ ]/ ·/ ·/ =/ c/ )/ ifcondA1elseskip/ ;/ 11/ ./ whilecondA2/ ∧/ c/ ?/ do12/ ./ (/ s/ [/ i/ ]/ ,/ i/ ·/ ·/ =/ c/ ,/ i/ +/ 1/ )/ ifcondA3elseskip13/ ./ B/ =/ ungetchar/ (/ c/ )/ ;/ 14/ ./ s/ [/ i/ ]/ ·/ ·/ =/ ’/ \/ 0/ ’/ ;/ 15/ ./ return/ ·/ ·/ =/ NUBMER16/ ./ C/ =/ whilecondC1do/ ?/ c/ ;/ 17/ ./ s/ [/ lim/ ]/ ·/ ·/ =/ ’/ \/ 0/ ’/ ;/ 18/ ./ return/ ·/ ·/ =/ TOOBIG/ ;/ 19/ ./ andwhere20/ ./ cond1/ =/ (/ c/ =/ _/ )/ ∨/ (/ c/ =/ \/ t/ )/ ∨/ (/ c/ =/ \/ n/ )/ 21/ ./ cond2/ =/ (/ c/ ≠/ ./ )/ ∧/ (/ c/ </ 0/ ∨/ c/ >/ 9/ )/ 22/ ./ cond3/ =/ (/ c/ / 0/ )/ ∧/ (/ c/ / 9/ )/ 23/ ./ cond4/ =/ (/ i/ </ lim/ )/ 24/ ./ cond5/ =/ (/ c/ =/ ./ )/ 25/ ./ cond6/ =/ (/ i/ </ lim/ )/ 26/ ./ condA1/ =/ (/ i/ </ lim/ )/ 27/ ./ condA2/ =/ (/ c/ / 0/ )/ ∧/ (/ c/ / 9/ )/ 28/ ./ condA3/ =/ (/ i/ </ lim/ )/ 29/ ./ condC1/ =/ (/ c/ ≠/ \/ n/ )/ ∧/ (/ c/ ≠/ EOF/ )/ 这样/ ,/ 该/ 例子/ 对于/ 模型/ 工具/ 的/ 输入/ 可/ 表示/ 为/ s1/ =/ assign/ "/ i/ "/ (/ equ0/ )/ s2/ =/ input/ "/ c/ "/ s3/ =/ whilecond1ss1s4/ =/ ifcond2ss2ss3s5/ =/ assign/ "/ i/ "/ (/ equ1/ )/ s6/ =/ input/ "/ c/ "/ s7/ =/ whilecond3ss4s8/ =/ ifcond5ss5ss6s9/ =/ ifcond6ss7ss8program/ =/ [/ s1/ ,/ s2/ ,/ s3/ ,/ s4/ ,/ s5/ ,/ s6/ ,/ s7/ ,/ s8/ ,/ s9/ ]/ program/ 就是/ 我们/ 的/ 程序/ ,/ 式/ 中/ 的/ ss1/ ,/ ss2/ 也/ 是/ 按照/ 以上/ 规则/ 书写/ 的/ 程序/ 语句/ ./ 通过/ 运行/ Haskell/ 程序/ ,/ 我们/ 得到/ 如图/ 4/ 所示/ 的/ 输出/ ./ 的/ 输出/ ,/ 也/ 即/ 是/ getop/ 函数/ 的/ 测试/ 路径/ :/ 图/ 4/ 中/ 显示/ 的/ 是/ 对/ program/ 进行/ t/ 操作/ 后/ 得到/ (/ t1/ )/ c/ ∧/ cond11/ ;/ c/ ∧/ / cond11/ ∧/ cond12/ ∧/ O/ (/ ·/ )/ ./ (/ t2/ )/ (/ c/ ∧/ cond11/ )/ ∧/ (/ lim/ ∧/ cond21/ ∧/ cond22/ ∧/ cond31/ ∧/ cond15/ )/ ;/ c/ ∧/ / cond11/ ∧/ / cond12/ ;/ c/ ∧/ cond13/ ;/ c/ ∧/ / cond13/ ∧/ cond14/ ;/ c/ ∧/ cond23/ ;/ c/ ∧/ / cond23/ ∧/ ·/ ./ (/ t3/ )/ (/ c/ ∧/ cond11/ )/ ∧/ (/ lim/ ∧/ / cond21/ ∧/ / cond22/ / cond31/ / cond15/ )/ ;/ c/ ∧/ / cond11/ ∧/ / cond12/ ;/ c/ ∧/ cond13/ ;/ c/ ∧/ / cond13/ ∧/ / cond14/ ∧/ ·/ ./ (/ t4/ )/ (/ c/ ∧/ cond11/ )/ ∧/ (/ lim/ ∧/ / cond21/ ∧/ / cond22/ ∧/ / cond31/ ∧/ / cond15/ )/ ;/ c/ ∧/ / cond11/ ∧/ / cond12/ ;/ c/ ∧/ cond13/ ;/ c/ ∧/ / cond13/ ∧/ cond14/ ;/ c/ ∧/ / cond23/ ;/ ·/ ./ c/ ∧/ / cond24/ ∧/ ·/ ./ 经/ 分析/ ,/ 得到/ 的/ 路径/ 能够/ 覆盖/ 所有/ 的/ 条件/ 和/ 语句/ ,/ 并且/ 所/ 获得/ 的/ 路径/ 都/ 是/ 可行/ 的/ ./ 选取/ 一些/ c/ 和/ lim/ ,/ 我们/ 得到/ 如下/ 测试用例/ (/ 表/ 1/ )/ ./ Page105/ 实验/ 根据/ 原型/ 工具/ ,/ 我们/ 可以/ 把/ 嵌入式/ C/ // C++/ (/ 支持/ Queue/ ,/ semaphore/ 和/ Mailbox/ )/ 映射/ 到/ GCL/ 表达式/ ,/ 并/ 对此/ 采用/ 我们/ 的/ 算法/ 生成/ 测试用例/ ./ 实验/ 部分/ ,/ 我们/ 针对/ IntegratedAccessAdvice/ (/ IAD/ )/ 系统软件/ 的/ 一部分/ 来/ 生成/ 测试用例/ ./ IAD/ 是/ 一个/ 在/ DSL/ 上/ 运行/ 数据/ 和/ 声音/ 的/ 嵌入式/ 系统/ ./ 被测/ 部分/ 称为/ PPPoverATM/ ,/ 其/ 架构/ 显示/ 在/ 图/ 5/ 中/ ./ ip/ // tcppktpppatm/ 我们/ 的/ 原型/ 工具/ 首先/ 把/ C/ 程序/ 翻译成/ GCL/ 表达式/ ,/ 在/ 此/ 过程/ 中/ 我们/ 注意/ 到/ 原型/ 工具/ 还/ 不/ 具备/ 充分/ 的/ 规则/ 去/ 转换/ 程序/ 的/ 所有/ 部分/ ,/ 但是/ 已/ 足够/ 去/ 翻译/ 与/ 控制/ 和/ 数据/ 相关/ 的/ 部分/ ./ 然后/ 对/ 每个/ 任务/ 产生/ 测试用例/ ./ 原型/ 工具/ 运行/ 在/ DELL1900/ 上/ ,/ 具有/ 内存/ 4MB/ 和/ 速度/ 2/ ×/ 1.60/ GHz/ ./ 表/ 3/ 列出/ 了/ 对/ 每个/ 序列/ 程序/ 产生/ 的/ 测试用例/ 以及/ 所花/ 的/ 时间/ ./ 被测/ 程序/ ip/ -/ taskpkt/ -/ taskppp/ -/ task6/ 相关/ 工作/ 目前/ ,/ 有/ 不少/ 生成/ 测试用例/ 的/ 方法/ ,/ 下面/ 是/ 一些/ 比较/ 典型/ 的/ 工作/ ./ 基于/ 控制流/ 图/ (/ ControlFlowGraph/ )/ ./ Bertolino/ 等/ 人/ [/ 1/ ]/ 提出/ 一种/ 算法/ 及/ 多种/ 规则/ 来/ 选择/ 路径/ ,/ 这样/ 使得/ 不/ 可行/ 的/ 用/ 例数/ 大/ 减少/ ./ 但是/ ,/ 由于/ 这种/ 方法/ 基于/ 对/ 程序控制/ 流/ 的/ 分析/ ,/ 不能/ 完全/ 实现/ 获取/ 可/ 执行/ 路径/ 的/ 目标/ ./ 此/ 方法/ 比较/ 适合/ 于/ 序列化/ 程序/ ./ Katayama/ 等/ 人/ [/ 13/ ]/ 从/ 程序/ 源代码/ 中/ 推导/ 出/ 描述/ 并行程序/ 行为/ 的/ 事件/ 交互/ 图/ (/ EventInteractionGraph/ )/ ,/ 但/ 这种/ 方法/ 不能/ 保证/ 所/ 获得/ 的/ 路径/ 都/ 是/ 可行/ 的/ ./ 基于/ 可达图/ (/ ReachabilityGraph/ )/ ./ 在/ 文献/ [/ 4/ ]/ 中/ ,/ 并行程序/ 的/ 执行/ 行为/ 是/ 基于/ 并发/ 状态/ 的/ ./ 一旦/ 并发/ 状态图/ 被/ 创建/ ,/ 并发/ 历史/ (/ 即/ 并发/ 状态图/ 中/ 某条/ 路径/ 上/ 的/ 并发/ 状态/ 所/ 组成/ 的/ 序列/ )/ 为/ 生成/ 测试用例/ 提供/ 了/ 指导/ ./ 利用/ 这种/ 方法/ ,/ 被/ 选择/ 的/ 路径/ 都/ 是/ 可行/ 的/ ,/ 但是/ 这种/ 方法/ 存在/ 状态/ 爆炸/ 问题/ ./ 基于/ 状态/ 变迁/ 系统/ (/ LabeledTransitionSystem/ )/ ./ Tretmans/ 和/ Belinfante/ [/ 5/ ]/ 定义/ 了/ 一类/ 特殊/ 的/ 带/ 标记/ 的/ 变迁/ 系统/ (/ LabeledTransitionSystem/ )/ ,/ 称为/ Input/ -/ OutputTransitionSystem/ ,/ 来/ 为/ 用/ Promela/ 所/ 描述/ 的/ 系统生成/ 测试用例/ ./ 文中/ 提出/ 一种/ 称为/ ioco/ 的/ 测试/ 理论/ 来/ 生成/ 测试用例/ ,/ 并/ 描述/ 了/ 测试工具/ TorX/ ./ 但是/ 这种/ 测试方法/ 会/ 导致/ 状态/ 爆炸/ 问题/ ./ Muccini/ 等/ 人/ [/ 14/ ]/ 用/ LTS/ 来/ 为/ 系统结构/ 上/ 的/ 行为/ 建模/ ,/ 然后/ 基于/ 覆盖/ LTS/ 模型/ 的/ 路径/ 的/ 集合/ 获得/ 合适/ 的/ 测试用例/ 集合/ ,/ 最后/ ,/ 这些/ 结构/ 上/ 的/ 测试用例/ 被/ 细化/ 为/ 代码/ 级/ 的/ 用例/ ,/ 从而/ 用于/ 执行/ ./ 对于/ 这种/ 方法/ 来说/ ,/ 要/ 获得/ 系统/ 整体/ 的/ 结构/ 模型/ 是/ 比较/ 困难/ 的/ ./ 基于/ 模型/ 检测/ (/ ModelChecking/ )/ ./ 模型/ 检测工具/ 建立/ 了/ 一个/ 有限/ 状态/ 变迁/ 系统/ ,/ 并/ 穷尽/ 搜索/ 状态/ 空间/ 以便/ 找到/ 违反/ 属性/ 的/ 反例/ [/ 2/ ]/ ./ 基于/ 模型/ 检测/ 进行/ 测试/ 的/ 思想/ 是/ 将/ 反例/ 视为/ 测试用例/ ./ 模型/ 检测/ 中/ 所/ 使用/ 的/ 模型/ 是/ 反映/ 系统/ 行为/ 的/ 模型/ ,/ 它们/ 可以/ 从/ 需求/ 用例/ ,/ 系统/ 的/ 设计说明/ 中/ 获得/ ,/ 而且/ 模型/ 也/ 可以/ 基于/ 程序代码/ 进行/ 创建/ [/ 15/ ]/ ./ 人们/ 研究/ 了/ 大量/ 基于/ 模/ Page11/ 型/ 检测/ 生成/ 测试用例/ 的/ 方法/ ./ 例如/ ,/ 文献/ [/ 16/ ]/ 使用/ 模型/ 检测工具/ 生成/ 违反/ 己知/ 属性/ (/ 针对/ SRC/ 描述/ 的/ 需求/ )/ 的/ 测试用例/ ./ Hong/ 等/ 人/ [/ 17/ ]/ 提出/ 一种/ 理论/ 框架/ ,/ 采用/ 时序/ 逻辑/ 来/ 说明/ 基于/ 数据流/ 的/ 测试用例/ 的/ 覆盖率/ ./ 基于/ 符号执行/ (/ SymbolicExecution/ )/ ./ 符号执行/ 是/ 一种/ 基于/ 符号/ 输入/ 值/ 生成/ 代数/ 表达式/ 的/ 程序/ 分析方法/ ./ 静态/ 并发/ 分析方法/ 可能/ 会/ 丢失/ 一部分/ 数据/ 的/ 值/ ,/ 与/ 之/ 不同/ 的/ 是/ ,/ 符号执行/ 将会/ 保留/ 与/ 这些/ 数据/ 值/ 有关/ 的/ 信息/ ./ 这些/ 信息/ 可以/ 用来/ 检测/ 不/ 可行/ 的/ 执行/ 路径/ ,/ 也/ 可以/ 用于/ 生成/ 测试数据/ [/ 3/ ]/ ./ 尽管/ 符号执行/ 的/ 方法/ 可以/ 缓解/ 测试用例/ 不/ 可行/ 的/ 问题/ ,/ 但是/ 它/ 也/ 存在/ 一些/ 缺点/ ,/ 如/ 处理/ 动态/ 数据结构/ ,/ 数组/ ,/ 过程/ 比较/ 困难/ ;/ 对于/ 己/ 被/ 选择/ 的/ 路径/ ,/ 测试用例/ 生成器/ 不易/ 找到/ 使得/ 这/ 条/ 路径/ 被/ 遍历/ 的/ 输入/ 数据/ ./ 文献/ [/ 18/ ]/ 也/ 指出/ 符号执行/ 方法/ 需要/ 复杂/ 的/ 代数/ 操作/ ,/ 且/ 处理/ 数组/ 和/ 指针/ 比较/ 困难/ ./ 在/ 某些/ 情况/ 下/ ,/ 人们/ 将/ 符号执行/ 与/ 状态/ 分析/ 技术/ 结合/ 起来/ ./ 例如/ ,/ 文献/ [/ 19/ ]/ 将/ 并发/ 状态图/ 与/ 符号执行/ 结合/ 起来/ 确定/ 可能/ 的/ 同步/ 模式/ ./ 文献/ [/ 20/ ]/ 通过/ 使用/ 根据/ 符号执行/ 而/ 扩展/ 的/ 模型/ 检测工具/ 来/ 研究/ 程序/ 的/ 输入/ 域/ ./ 文献/ [/ 21/ ]/ 描述/ 了/ 一个/ 名为/ SimC/ 的/ 原型/ 工具/ ,/ SimC/ 可以/ 为/ C/ 程序/ 的/ 单元测试/ 自动/ 生成/ 测试用例/ ./ 这种/ 方法/ 可以/ 为/ 包含/ 指针/ 及/ 结构化/ 操作/ 的/ C/ 程序/ 生成/ 测试数据/ ,/ 但/ 如/ 文中/ 所说/ ,/ 对/ 一些/ 复杂/ 的/ 情况/ ,/ 如/ 函数指针/ ,/ 复杂/ 的/ 输入/ 等/ ,/ 暂时/ 还/ 不能/ 处理/ ./ 测试方法/ 大体/ 有/ 下面/ 一些/ 工作/ :/ 随机/ 测试/ (/ RandomTesting/ )/ ./ 随机/ 测试/ 所/ 使用/ 的/ 测试/ 是/ 在/ 生成/ 好/ 的/ 测试用例/ 基础/ 上/ 选择/ [/ 22/ ]/ ./ 这种/ 方法/ 简单/ ,/ 没有/ 太多/ 的/ 限制/ ./ 有人/ 认为/ 这种/ 方法/ 测试/ 的/ 结果/ 与/ 有/ 目的/ 选取/ 测试用例/ 的/ 测试/ 结果/ 差不多/ ./ 但是/ ,/ 实际上/ 随机/ 测试用例/ 集/ 不能/ 保证/ 满足/ 覆盖/ 标准/ ,/ 而且/ ,/ 没有/ 被/ 测试/ 覆盖/ 的/ 部分/ 将/ 导致/ 测试/ 效率/ 降低/ ./ 分解/ 测试/ (/ PartitionTesting/ )/ ./ 分解/ 测试/ 的/ 目标/ 是/ 覆盖/ 所有/ 的/ 语句/ ,/ 控制流/ ,/ 数据流/ 或/ 临界/ 的/ 路径/ [/ 23/ ]/ ./ 在/ 这/ 一方面/ ,/ 到/ 目前为止/ 己/ 有/ 大量/ 的/ 研究/ 工作/ ./ 基于/ 约束/ 的/ 测试/ (/ ConstraintBasedTesting/ )/ ./ 这种/ 测试方法/ 是/ 由/ Millo/ 与/ Offutt/ [/ 24/ ]/ 提出/ 来/ 的/ ./ 代数/ 约束/ 被/ 用来/ 描述/ 特殊/ 类型/ 的/ 故障/ ./ 文献/ [/ 25/ ]/ 提出/ 了/ 一种/ 约束/ 符号/ CSPE/ (/ ConstraintsonSucceedingandPrecedingEvents/ )/ ,/ 并/ 基于/ 这种/ 约束/ 来/ 为/ 分布式/ 程序/ 生成/ 测试/ 序列/ ./ CSPE/ 直接/ 从/ 程序/ 抽象/ 中/ 获得/ ,/ 而/ 测试/ 序列/ 将/ 依据/ 这些/ 约束/ 从/ 程序/ 抽象/ 中/ 选择/ ./ 然而/ ,/ 利用/ 这种/ 方法/ 所/ 获得/ 的/ 测试/ 序列/ 个数/ 很多/ ,/ 甚至/ 是/ 无限/ 的/ ./ 文献/ [/ 26/ ]/ 提高/ 了/ 测试用例/ 集/ 的/ 效率/ ,/ 因为/ 他们/ 的/ 实验/ 表明/ 基于/ 标准/ 的/ 策略/ 所/ 需/ 的/ 代价/ 太高/ ,/ 并且/ 需要/ 花/ 更/ 多/ 的/ 工作/ 来/ 确定/ 不/ 可行/ 的/ 元素/ ./ 适应性/ 测试/ (/ AdaptiveSoftwareTesting/ )/ ./ 文献/ [/ 27/ ]/ 提出/ 一种/ 可/ 适应性/ 软件测试/ ./ 用/ 可/ 控制/ 的/ 马尔可夫/ 链为/ 软件系统/ 建模/ ./ 测试/ 策略/ 基于/ 控制/ 准则/ ,/ 理论/ 及/ 方法/ ./ 选择/ 测试用例/ 的/ 过程/ 由/ 反馈/ 信息/ 来/ 指导/ ,/ 并且/ 测试数据/ 将/ 用于/ 指导/ 选择/ 下/ 一次/ 被/ 执行/ 的/ 测试用例/ ./ 组合/ 测试/ ./ 文献/ [/ 28/ ]/ 针对/ 组合/ 测试/ ,/ 介绍/ 了/ 目前/ 人们/ 在/ 组合/ 测试用例/ 生成/ 领域/ 所/ 取得/ 的/ 研究成果/ ,/ 并/ 对/ 现有/ 的/ 组合/ 测试用例/ 生成/ 方法/ 进行/ 了/ 分类/ 和/ 总结/ ./ 而且/ 介绍/ 了/ 一些/ 组合/ 测试用例/ 生成/ 技术/ ,/ 并/ 对/ 该/ 领域/ 未来/ 的/ 研究/ 方向/ 进行/ 了/ 分析/ ./ 同样/ ,/ 文献/ [/ 29/ ]/ 中/ 总结/ 了/ 近年来/ 在/ 组合/ 测试/ 方面/ 的/ 研究进展/ ,/ 包括/ 组合/ 测试/ 准则/ 研究/ ,/ 组合/ 测试/ 生成/ 问题/ 与/ 其他/ NP/ 完全/ 问题/ 的/ 联系/ ,/ 和/ 组合/ 测试用例/ 的/ 数学/ 构造方法/ 等/ ./ 此外/ ,/ 文献/ [/ 30/ ]/ 提出/ 一种/ 形式化/ 的/ 基于/ TTCN/ 的/ 测试/ 执行/ 方法/ ,/ 利行/ 标号/ 变迁/ 系统/ 描述/ 了/ 解释/ 执行/ 的/ 过程/ ./ 这种/ 方法/ 为/ 进行/ 协议/ 一致性/ 测试/ 活动/ 提供/ 了/ 有力/ 的/ 支持/ ./ 文献/ [/ 31/ ]/ 通过/ 考虑/ 测试/ 与/ 需求/ 间/ 的/ 相互/ 关系/ ,/ 将/ 满足/ 需求/ 的/ 测试用例/ 进行/ 划分/ ,/ 根据/ 划分/ 结果/ 成生/ 一个/ 测试用例/ ,/ 然后/ 利用/ 一些/ 选择/ 算法/ 对/ 所/ 生成/ 的/ 测试用例/ 进行/ 进一步/ 简化/ ,/ 通过/ 这种/ 方法/ 可以/ 获得/ 满足/ 所有/ 测试/ 需求/ 的/ 最小/ 测试用例/ 集/ ./ 文献/ [/ 32/ ]/ 分析/ 和/ 比较/ 了/ 面向/ 路径/ 的/ 测试数据/ 生成/ 方法/ ,/ 将/ 现有/ 的/ 一些/ 方法/ 进行/ 分类/ ,/ 讨论/ 了/ 各种/ 方法/ 的/ 特点/ 和/ 原理/ ./ 文献/ [/ 33/ ]/ 利用/ 静态/ 测试/ 的/ 方法/ ,/ 给出/ 了/ 内存/ 汇漏/ 的/ 静态/ 检测/ 模型/ ,/ 并/ 根据/ 模型/ 实现/ 了/ 一个/ 自动/ 测试工具/ ./ 文献/ [/ 34/ ]/ 提了/ 指针/ 映射/ 代数/ 的/ 概念/ ,/ 全面/ 反映/ 了/ 指针/ 与/ 内存/ 之间/ 的/ 映射/ 关系/ ,/ 以此/ 为/ 基础/ 建立/ 了/ 动态内存/ 故障/ 模型/ ./ 文献/ [/ 35/ ]/ 提出/ 基于/ 相似/ 度量/ 的/ 适应/ 值/ 函数/ 构造方法/ ,/ 用于/ 生成/ 覆盖/ 指定/ 路径/ 的/ 测试用例/ ./ 该/ 方法/ 在/ 针对/ 复杂/ 路径/ 的/ 情况/ 下/ 具有/ 一定/ 的/ 优势/ ./ 7/ 结束语/ 我们/ 提出/ 了/ 一种/ 生成/ 测试用例/ 的/ 形式化/ 方法/ ./ 由于/ 用例/ 的/ 导出/ 过程/ 是/ 基于/ 形式化/ 的/ 语言/ ,/ 所以/ 测试/ 过程/ 可以/ 自动化/ ./ 由于/ 我们/ 生成/ 用例/ 的/ 过程/ 实际上/ 是/ 对/ GCL/ 表达式/ ,/ 借助于/ Hoare/ 规则/ 对/ 条件/ 分/ Page12/ 解/ 的/ 过程/ ,/ 因此/ 所/ 生成/ 的/ 用例/ 是/ 正确/ 的/ ./ 算法/ 的/ 复杂度/ 依赖于/ 程序/ 自身/ 的/ 特点/ ,/ 例如/ 程序/ 的/ 输出/ 个数/ ,/ 条件/ 个数/ 和/ 内嵌/ 的/ 分支/ 个数/ ./ 这种/ 方法/ 的/ 优点/ 在于/ 所/ 获得/ 的/ 测试用例/ 都/ 是/ 可行/ 的/ ,/ 在/ 测试用例/ 生成/ 过程/ 中/ 可以/ 避免/ 状态/ 爆炸/ 问题/ ,/ 且/ 该/ 方法/ 可以/ 延拓/ 到/ 任何/ 目标语言/ ./ 该/ 方法/ 理论/ 上/ 可以/ 应用/ 在/ 任何/ 规模/ 的/ 软件系统/ 中/ ,/ 目前/ 我们/ 已能/ 对/ 小型/ 软件系统/ 生成/ 测试用例/ ./ 把/ 大型/ 软件系统/ 的/ 程序/ 转化/ 为/ 本文/ 中/ 的/ 高层/ 描述语言/ 需要/ 较/ 多/ 的/ 预处理/ ,/ 以及/ 应用程序/ 中/ 特定/ 语法结构/ 到/ GCL/ 的/ 转化/ ,/ 这些/ 都/ 是/ 今后/ 研究/ 中/ 需要/ 解决/ 的/ 问题/ ./ 致谢/ 审稿/ 专家/ 提出/ 了/ 很/ 有/ 价值/ 的/ 意见/ ,/ 在/ 此/ 表示感谢/ !/ 

