Page1/ 基于/ 结构/ 体/ 随机化/ 的/ 内核/ Rootkit/ 防御/ 技术/ 辛知/ 陈惠宇/ 韩浩茅兵/ 谢立/ (/ 南京大学/ 软件/ 新/ 技术/ 国家/ 重点/ 实验室/ 南京/ 210093/ )/ (/ 南京大学/ 计算机科学/ 与/ 技术/ 系/ 南京/ 210093/ )/ 摘要/ 内核/ Rootkit/ 对于/ 操作系统/ 来说/ 是/ 个/ 严重/ 的/ 威胁/ ./ 入侵者/ 通过/ 植入/ 内核/ Rootkit/ ,/ 修改/ 一些/ 关键/ 的/ 内核/ 结构/ 体/ ,/ 实现/ 恶意/ 进程/ 隐藏/ 、/ 日志/ 文件/ 删除/ 、/ 私密/ 信息/ 窃取/ 等/ 恶意/ 行为/ ./ 由于/ Rootkit/ 主要/ 通过/ 篡改/ 内核/ 结构/ 体/ 对象/ 来/ 实现/ 控制流/ 截取/ ,/ 因此/ 我们/ 试图/ 通过/ 结构/ 体/ 随机化/ 来/ 防御/ 这些/ 入侵/ ./ 在/ 文中/ ,/ 作者/ 提出/ 了/ 一种/ 基于/ 编译器/ 的/ 自动/ 结构/ 体/ 随机化/ 技术/ ,/ 解决/ 了/ 包括/ 结构/ 体/ 的/ 可/ 随机化/ 识别/ ,/ 随机化/ 语义/ 不变/ 保护/ 以及/ 自动/ 随机化/ 等/ 多个/ 技术难题/ ,/ 最终/ 利用/ 随机/ 环境/ 下/ 攻击者/ 无法/ 预知/ 结构/ 体域/ 排列/ 的/ 特点/ ,/ 实现/ 对/ 内核/ Rootkit/ 的/ 防御/ ./ 在/ 实验/ 环节/ ,/ 我们/ 在/ 被/ 随机化/ 的/ Linux/ 系统/ 中/ 测试/ 了/ 已知/ 的/ 5/ 种/ 不同/ 原理/ 的/ 8/ 个/ 真实/ 的/ Rootkit/ ,/ 结果/ 展示/ 了/ 我们/ 的/ 方法/ 以/ 几乎/ 零/ 负荷/ 的/ 代价/ 防御/ 了/ 全部/ 的/ Rootkit/ 加载/ ./ 关键词/ 计算机/ 安全/ ;/ 内核/ Rootkit/ ;/ 随机化/ ;/ 结构/ 体/ ;/ 操作系统/ ;/ 网络安全/ ;/ 信息安全/ 1/ 引言/ Rootkit/ 是/ 入侵者/ 隐藏/ 对/ 系统资源/ 访问/ 与/ 窜改/ Page2/ 威胁/ ①/ ./ 早期/ 的/ Rootkit/ 以/ 应用/ 级别/ 和/ 库/ 级别/ 为主/ ,/ 为了/ 掩人耳目/ ,/ 常常/ 篡改/ 一些/ 系统/ 已有/ 的/ 常用/ 审计/ 工具/ [/ 1/ ]/ ,/ 如/ ls/ 、/ ps/ 、/ netstat/ 等/ ,/ 或者/ 作为/ 系统/ 中/ 动态链接库/ 而/ 存在/ ./ 因而/ ,/ 如果/ 系统管理员/ 使用/ 了/ 一些/ 具有/ 高级/ 权限/ 的/ 工具/ ,/ 例如/ ,/ 通过/ 比较/ 用户/ 空间/ 和/ 内/ 空间/ 状态/ 的/ 不/ 一致/ ,/ 将/ 很/ 容易/ 检测/ 到/ 这/ 两种/ Rootkit/ ./ 然而/ 这种/ 方法/ 却/ 对/ 内核/ Rootkit/ 无能为力/ ,/ 因为/ 它/ 篡改/ 的/ 就是/ 信息/ 的/ 源头/ ,/ 并/ 不/ 存在/ 状态/ 不/ 一致/ 的/ 问题/ ./ 本文/ 针对/ 的/ 就是/ 内核/ Rootkit/ ./ 首先/ ,/ 由于/ C语言/ 贴近/ 底层/ 并且/ 代码/ 效率高/ ,/ 大部分/ 操作系统/ 内核/ 都/ 由/ 其/ 编写/ 完成/ ,/ 包括/ Linux/ 、/ Windows/ 等/ ./ 以/ Linux/ 内核/ 源代码/ 为例/ ,/ 它/ 通过/ 定义/ C语言/ 中/ 的/ 结构/ 体/ (/ Struct/ )/ 来/ 实现/ 面向对象/ 风格/ 的/ 编程/ ②/ ,/ 实现/ 包括/ 内存/ 管理/ 、/ API/ 调用/ 等/ 多种/ 重要/ 功能/ ,/ 内核/ 结构/ 体是/ 内核/ 中/ 控制/ 控制流/ 的/ 关键/ 对象/ ./ LinuxRootkit/ 的/ 作者/ 同样/ 观察/ 到/ 了/ 这/ 一点/ ,/ 采用/ 两种/ 方式/ 篡改/ 内核/ 结构/ 体/ ,/ 一种/ 是/ 运行/ 时/ 的/ 代码/ 重写/ ,/ 另/ 一种/ 是/ 可/ 加载/ 的/ 内核模块/ (/ LoadableKernelModule/ ,/ LKM/ )/ ./ 第一种/ 方式/ 在/ 最新/ 的/ 内核/ (/ 如/ Linux2/ ./ 6/ )/ 中/ 已经/ 被/ 禁止/ 而/ 基本/ 杜绝/ ,/ 因此/ 现有/ 的/ 可行/ 的/ 注入/ 方式/ 只有/ LKM/ ,/ 这是/ Linux/ 内核/ 为/ 以后/ 方便/ 添加/ 驱动/ 级别/ 程序/ 而/ 预留/ 的/ 接口/ ,/ 其它/ 操作系统/ 中/ 也/ 有/ 类似/ 的/ 机制/ ./ 从/ 构造/ 原理/ 来看/ ,/ 可以/ 将/ 它们/ 分为/ 以下/ 5/ 类/ ③/ :/ Proc/ 文件系统/ 、/ 系统/ 调用/ 表/ (/ SystemCallTable/ )/ 、/ 中断向量/ 表/ (/ InterruptDescriptorTable/ )/ 、/ DKOM/ (/ DirectKernelObjectModify/ )/ 以及/ 硬件/ 寄存器/ 中断/ (/ registerbreakpoint/ )/ ./ 它们/ 的/ 根本/ 区别/ 在于/ 试图/ 篡改/ 不同/ 类型/ 的/ 内核/ 结构/ 体/ ./ 以/ Proc/ 文件系统/ 为例/ ,/ 它/ 是/ 内核/ 向/ 用户/ 空间/ 集中/ 发布/ 信息/ 的/ 平台/ ,/ Linux/ 平台/ 上/ 的/ 很多/ 工具/ 都/ 是/ 在/ 这里/ 读取/ 内核/ 的/ 信息/ ,/ 比如/ ls/ 从/ proc/ _/ root/ 中/ 读取/ 当前/ 正在/ 运行/ 的/ 进程/ 的/ 信息/ ,/ netstat/ 从/ proc/ _/ net/ 中/ 读取/ 关于/ 网络/ 链接/ 的/ 信息/ ./ 一旦/ Proc/ 文件系统/ 相关/ 的/ 结构/ 体/ 遭到/ 篡改/ ,/ 这些/ 信息流/ 也/ 会/ 遭到/ 劫持/ 和/ 篡改/ ./ 现有/ 的/ 针对/ 内核/ Rootkit/ 的/ 检测/ 方法/ 主要/ 有/ :/ (/ 1/ )/ 加载/ 时/ 进行/ 二进制/ 分析/ ,/ 匹配/ 已有/ 的/ 签名/ [/ 2/ ]/ ;/ (/ 2/ )/ 各种/ 重要/ 结构/ 体/ 的/ 完整性检查/ [/ 3/ -/ 5/ ]/ ,/ 其中/ 一些/ 针对/ 内核/ 启动/ 后/ 就/ 不再/ 改变/ 的/ 静态/ 的/ 全局/ 数据/ [/ 5/ ]/ ,/ 如/ 系统/ 调用/ 表与/ 中断/ 调用/ 表/ ;/ 另/ 一些/ 主要/ 针对/ 内核/ 在/ 运行/ 过程/ 中/ 生成/ 的/ 动态数据/ [/ 4/ ]/ ,/ 如/ 时时刻刻/ 都/ 在/ 变化/ 的/ 与/ 进程/ 有关/ 的/ task/ _/ struct/ ;/ 还有/ 针对/ 内核/ 数据结构/ 不/ 变量/ 的/ 检测/ [/ 3/ ]/ ./ 其/ 不足之处/ 在于/ ,/ 这些/ 检测/ 方法/ 大多/ 基于/ 重型/ 的/ 虚拟机/ ,/ 需要/ 巨大/ 的/ 额外/ 性能/ ,/ 而且/ 往往/ 只能/ 检测/ 针对/ 某一/ 类别/ 结构/ 体/ 的/ Rootkit/ ,/ 但/ 事实上/ 内核/ 中/ 还有/ 许多/ 其它/ 的/ 结构/ 体会/ 影响/ 到/ 内核/ 安全/ [/ 6/ ]/ ./ 基于/ 内核/ 结构/ 体在/ 内核/ Rootkit/ 防御/ 方面/ 的/ 重要性/ ,/ 本文/ 提出/ 了/ 一种/ 基于/ 编译器/ 的/ 自动/ 内核/ 结构/ 体/ 随机化/ 技术/ ,/ 提供/ 一个/ 针对/ 内核/ 级别/ Rootkit/ 的/ 全面/ 的/ 、/ 高效/ 的/ 防御/ 解决方案/ ./ 简单/ 来说/ ,/ 结构/ 体/ 随机化/ 就是/ 在/ 编译/ 时/ 随机/ 调整结构/ 体中/ 各个/ 域/ (/ field/ )/ 的/ 排列/ 顺序/ ./ 与/ 之前/ 的/ 其它/ 随机化/ 方法/ [/ 3/ ,/ 7/ -/ 8/ ]/ 相/ 比较/ ,/ 结构/ 体/ 随机化/ 的/ 难点/ 在于/ 结构/ 体/ 本身/ 是/ 程序/ 语义/ 的/ 一部分/ ,/ 直接/ 的/ 结构/ 体/ 随机化/ 可能/ 会/ 引起/ 原有/ 程序/ 的/ 语义/ 错误/ ./ 在/ 之前/ 的/ 工作/ 中/ ,/ Lin/ 等/ 人/ [/ 9/ ]/ 首先/ 研究/ 了/ 结构/ 体/ 随机化/ 防御/ 内核/ Rootkit/ 的/ 方法/ ,/ 但/ 他们/ 的/ 方法/ 存在/ 两个/ 明显/ 地/ 缺陷/ :/ (/ 1/ )/ 依赖于/ 关键字/ 来/ 定义/ 需要/ 被/ 随机化/ 的/ 结构/ 体/ 对象/ ,/ 无法/ 做到/ 自动化/ ;/ (/ 2/ )/ 他们/ 的/ 方法/ 无法/ 保证/ 被/ 随机化/ 的/ 结构/ 体/ 不会/ 破坏/ 原有/ 的/ 语义/ ./ 为此/ ,/ 我们/ 设计/ 了/ 一整套/ 结构/ 体可/ 随机性/ 化/ 分析/ 的/ 方案/ ,/ 保证/ 我们/ 的/ 随机化/ 不会/ 干扰/ 程序/ 原有/ 的/ 语义/ ,/ 并且/ 完全/ 实现/ 了/ 自动化/ 的/ 结构/ 体/ 随机化/ ./ 我们/ 之前/ 的/ 工作/ [/ 10/ ]/ 探讨/ 了/ 这种/ 技术/ 在/ 恶意代码/ 分析/ 领域/ 的/ 应用/ ,/ 在/ 这里/ 我们/ 将/ 一步/ 探讨/ 针对/ 内核/ Rootkit/ 防御/ 的/ 情况/ ./ 首先/ ,/ 我们/ 收集/ 内核/ 中/ Rootkit/ 可以/ 篡改/ 的/ 结构/ 体/ 对象/ 的/ 集合/ ./ 然后/ 利用/ 我们/ 的/ 分析/ 工具/ 分别/ 对/ 操作系统/ 内核/ 以及/ 不同/ 原理/ 的/ Rootkit/ 进行/ 分析/ ,/ 找出/ 它们/ 共同/ 使用/ 的/ 结构/ 体/ 集合/ 作为/ 需要/ 随机化/ 的/ 目标/ 集合/ ,/ 在/ 编译/ 过程/ 中/ 对/ 其/ 随机化/ ./ 这些/ 域/ 的/ 随机化/ 方案/ 是/ 入侵者/ 所/ 不/ 知道/ 的/ ,/ 因此/ 当/ 入侵者/ 编译/ 生成/ 自己/ 的/ Rootkit/ 时/ 通常/ 只能/ 按照/ 源代码/ 中/ 结构/ 体/ 已有/ 的/ 定义/ 或/ 自行/ 挑选/ 的/ 任意/ 域/ 分布/ ./ 然而/ 在/ 整个/ 结构/ 体域/ 排列/ 的/ 随机化/ 空间/ 中/ ,/ 只有/ 一种/ 排列/ 是/ 正确/ 的/ ,/ 因此/ 当/ 这样/ 的/ Rootkit/ 被/ 注入/ 到/ 内核/ 中/ 并/ 进行/ 加载/ 时/ ,/ 绝大多数/ 情况/ 下/ 将/ 以/ 失败/ 告终/ ,/ 并/ 产生/ 警告/ 引起/ 系统管理员/ 的/ 注意/ ,/ 以后/ 的/ 尝试/ 也/ 很/ 难/ 继续/ 进行/ ./ 经过/ 实验/ 证实/ ,/ 我们/ 的/ 方法/ 成功/ 地/ 阻止/ 了/ Linux2/ ./ 6.15/ 内核/ 上/ 的/ 8/ 个/ 基于/ 5/ 种/ 不同/ 原理/ 的/ Rootkit/ 加载/ ,/ 并/ 几乎/ 没有/ 增加/ 任何/ 额外/ 的/ 负荷/ ,/ 展/ ①/ ②/ ③/ Page3/ 示出/ 了/ 良好/ 的/ 防御能力/ 与/ 性能/ 上/ 的/ 极大/ 优势/ ./ 另外/ ,/ 由于/ 我们/ 的/ 方法/ 基于/ 通用/ 的/ GCC/ 编译器/ ,/ 因此/ 原则上/ 可以/ 被/ 应用/ 到/ 所有/ 具有/ 源代码/ 的/ 操作系统/ 上/ ,/ 包括/ 各种/ Unix/ 系统/ 以及/ 移动/ 平台/ ./ 本文/ 第/ 2/ 节/ 将/ 对/ 结构/ 体/ 随机化/ 系统/ 做/ 一个/ 概述/ ,/ 概括/ 描述/ 各个/ 部分/ 的/ 功能/ ;/ 第/ 3/ 节/ 细致/ 地/ 讲述/ 了/ 可/ 随机化/ 分析/ 的/ 策略/ 与/ 实现/ ,/ 并/ 重点/ 说明/ 了/ 映射/ 机制/ 的/ 建立/ 与/ 有/ 技巧/ 的/ 随机化/ 的/ 原理/ ;/ 第/ 4/ 节/ 通过/ 实验/ 结果/ 展示/ 了/ 我们/ 的/ 工具/ 在/ 有效性/ 以及/ 性能/ 上/ 的/ 优势/ ;/ 第/ 5/ 节/ 系统地/ 描述/ 了/ 相关/ 工作/ ;/ 第/ 6/ 节/ 讨论/ 我们/ 工作/ 的/ 局限性/ 与/ 未来/ 的/ 工作/ ;/ 最后/ 一节/ 给出/ 了/ 本文/ 的/ 结论/ ./ 2/ 系统/ 描述/ 我们/ 的/ 系统/ 是/ 编译器/ 的/ 一个/ 扩展/ ./ 图/ 1/ 是/ 结构/ 体/ 随机化/ 系统/ 的/ 框架/ ,/ 从/ 随机化/ 的/ 工作/ 流程/ 上将/ 系统/ 分为/ 3/ 个/ 部分/ :/ (/ 1/ )/ 目标/ 集合/ TargetStructList/ 的/ 分析/ 与/ 生成/ ;/ (/ 2/ )/ 可/ 随机化/ 的/ 分析/ ;/ (/ 3/ )/ 结构/ 体/ 的/ 自动/ 随机化/ ./ 首先/ ,/ 假设/ 所有/ Rootkit/ 能/ 篡改/ 的/ 内核/ 结构/ 体/ 的/ 集合/ 为/ (/ R/ )/ ,/ 因为/ 新/ 的/ 攻击/ 方法/ 层出不穷/ ,/ 所以/ 这个/ 集合/ 无法/ 精确/ 确定/ ,/ 但/ 我们/ 会/ 从/ 两个/ 角度/ 来/ 构建/ 这个/ 集合/ ,/ 以求/ 在/ 已有/ 条件/ 下/ 最大/ 限度/ 地/ 解决/ 这个/ 问题/ :/ 首先/ ,/ 我们/ 会/ 总结/ 出/ 已有/ 的/ 、/ 已经/ 非常/ 普遍/ 的/ 5/ 类/ 内核/ Rootkit/ 作为/ 这个/ 集合/ 必备/ 的/ 一部分/ ;/ 另外/ ,/ 我们/ 确保/ 接口/ 开放/ ,/ 任何/ 新/ 发现/ 的/ 、/ 不同/ 原理/ 的/ Rootkit/ 都/ 可以/ 通过/ 我们/ 的/ 工具/ 方便/ 地/ 提取/ 所/ 使用/ 的/ 结构/ 体/ ,/ 并/ 加入/ 到/ 候选/ 集合/ 中/ ./ 我们/ 利用/ StructAnalyzer/ 这个/ 组件/ 对/ 所/ 针对/ Rootkit/ 的/ 源代码/ 进行/ 分析/ ,/ 提取/ 出/ 他们/ 使用/ 的/ 结构/ 体/ 的/ 集合/ 为/ RootkitStructList/ (/ Q/ )/ ,/ 同样/ 对/ 操作系统/ 源代码/ 进行/ 分析/ 提取/ 出/ 结构/ 体/ 的/ 集合/ KernelStructList/ (/ W/ )/ 然后/ 我们/ 提取/ 这/ 两个/ 集合/ 的/ 交集/ (/ S/ )/ ,/ 且/ 满足/ R/ / S/ =/ Q/ ∩/ W/ ,/ (/ S/ )/ 就是/ 那些/ Rootkit/ 所/ 使用/ 的/ 内核/ 中/ 的/ 结构/ 体/ 的/ 集合/ ,/ 即/ 我们/ 所/ 针对/ 的/ 目标/ 集合/ TargetStructList/ ./ 接下来/ ,/ 基于/ 这个/ 集合/ ,/ 我们/ 仍然/ 需要/ 对/ 结构/ 体/ 的/ 可/ 随机化/ 进行/ 判断/ ,/ 即/ 根据/ 结构/ 体在/ 内核/ 源代码/ 中/ 被/ 声明/ 、/ 定义/ 以及/ 使用/ 的/ 情况/ ,/ 评估/ 随机化/ 会/ 对/ 语义/ 造成/ 的/ 潜在/ 的/ 影响/ ,/ 我们/ 将/ 这些/ 影响/ 的/ 情况/ 分为/ 3/ 类/ :/ (/ 1/ )/ 顺序/ 依赖/ 访问/ ;/ (/ 2/ )/ 链接/ 一致性/ ;/ (/ 3/ )/ 特殊/ 语法/ ./ 第/ 1/ 类/ 问题/ 由/ C语言/ 特殊/ 的/ 结构/ 体/ 初始化/ 以及/ 指针/ 算术/ 引起/ ,/ 我们/ 通过/ 映射/ 组件/ (/ Mapping/ )/ 调整/ 值与域/ 的/ 对应/ 关系/ ,/ 保证/ 初始化/ 的/ 正确性/ ,/ 但/ 不/ 对/ 指针/ 算术/ 做/ 随机化/ ;/ 第/ 2/ 类/ 问题/ 由/ 多/ 文件/ 中/ 的/ 同一个/ 结构/ 体/ ,/ 以/ 不同/ 方式/ 随机化/ 引起/ ,/ 我们/ 通过/ 中间/ 文件/ 传导/ 同一个/ 结构/ 体/ 被/ 随机化/ 时/ 的/ 域/ 排列/ 来/ 实现/ 统一/ ;/ 针对/ 最后/ 一个/ 特殊/ 语法/ ,/ 我们/ 不/ 对/ 其/ 进行/ 随机化/ ,/ 详细/ 的/ 解释/ 见/ 第/ 3/ 节/ ./ 另外/ ,/ 被/ 随机化/ 的/ 结构/ 体的域/ 分布/ 将/ 被/ 存储/ 在/ 随机化/ 排列/ 池/ (/ RandomizationSchemePool/ )/ 组件/ 中/ ,/ 它/ 主要/ 有/ 两/ 方面/ 的/ 作用/ ,/ 一方面/ 可以/ 辅助/ 自动/ 随机化/ 组件/ (/ Randomization/ )/ 进行/ 随机化/ ;/ 另一方面/ ,/ 作为/ 所有/ 结构/ 体域/ 排列/ 的/ 记录/ ,/ 它/ 将/ 成为/ 以后/ 内核/ 中/ 正常/ 加载/ LKM/ 驱动/ 级别/ 程序/ 的/ 不可/ 缺少/ 的/ 组成部分/ ./ 最后/ ,/ 这些/ 分析/ 结果/ 将/ 被/ 传递/ 给/ 系统/ 的/ 自动/ 随机化/ 组件/ (/ Randomization/ )/ ,/ 按照/ 各自/ 的/ 情况/ 分别/ 进行/ 处理/ ,/ 最大/ 限度/ 地/ 完成/ 各个/ 结构/ 体/ 随机化/ ./ 3/ 设计/ 与/ 实现/ 我们/ 的/ 所有/ 代码/ 均/ 在/ GCC4/ ./ 2.4/ 中/ 完成/ ,/ 整个/ GCC/ 主要/ 可以/ 分为/ GENERIC/ 、/ GIMPLE/ 、/ SSA/ 以及/ RTL/ 四种/ 中间/ 语言/ ./ 我们/ 的/ 代码/ 大部分/ 是/ 基于/ GENERIC/ 层/ ,/ 另有/ 一些/ 关于/ 指针/ 算术/ 的/ 分析/ 是/ 基于/ GIMPLE/ ,/ 整个/ 工程量/ 为/ 大致/ 2500/ 行/ 的/ C语言/ 代码/ 以及/ 500/ 行/ 左右/ 的/ Perl/ 脚本/ ./ 在/ 后续/ 部分/ ,/ 我们/ 将/ 就/ 如何/ 实现目标/ 集合/ 的/ 提取/ 、/ 结构/ 体/ 的/ 可/ 随机化/ 分析/ 以及/ 如何/ 自动/ 地/ 进行/ 结构/ 体/ 随机化/ 展开讨论/ ./ 3.1/ 目标/ 集合/ 的/ 提取/ 为/ 实现/ 集合/ 的/ 提取/ ,/ 我们/ 修改/ GCC/ 中/ 负责/ 处理/ 结构/ 体/ 生成/ 的/ GENERIC/ 函数/ c/ _/ parser/ _/ struct/ _/ or/ _/ union/ _/ specifier/ ,/ 通过/ 它/ 提取/ 在/ 编译/ 中/ 遇到/ 的/ 各种/ 结构/ 体/ ,/ 并/ 写入/ 到/ 独立/ 的/ 文件/ 中/ ./ 将/ 从/ 内核/ 与/ Rootkit/ 中/ 提取/ 的/ 集合/ 做/ 交集/ 作为/ 我们/ 的/ 目标/ 集合/ ./ 3.2/ 可/ 随机化/ 分析/ 3.2/ ./ 1/ 顺序/ 依赖/ 访问/ 之/ 结构/ 体/ 初始化/ 这部分/ 主要/ 针对/ 那些/ 操作/ 与/ 结构/ 体域/ 的/ 顺序/ 紧/ Page4/ 密/ 相关/ 的/ 情况/ ./ 在/ 这些/ 情况/ 下/ ,/ 任何/ 域/ 的/ 潜在/ 的/ 重新/ 排序/ 都/ 可能/ 引起/ 语义/ 错误/ ,/ 这样/ 的/ 情况/ 包括/ 结构/ 体/ 初始化/ 与/ 指针/ 算术/ ./ 初始化/ 如图/ 2/ 情况/ (/ a/ )/ ,/ 结构/ 体/ 变量/ foo1/ 的/ 各个/ 域/ ,/ 按照/ 声明/ 的/ 顺序/ 依次/ 赋值/ 为/ a/ =/ 10/ ,/ b/ =/ 20/ ,/ c/ =/ 30/ ,/ 在域/ 随机化/ 的/ 情况/ 下/ a/ 可能/ 图/ 2/ 随机化/ 在/ 结构/ 体/ 初始化/ 中/ 带来/ 的/ 问题/ 以及/ 解决/ 方法/ 图/ 2/ (/ b/ )/ 给出/ 了/ 这种/ 映射/ 的/ 示意图/ ,/ ac/ 意味着/ 在/ a/ 原来/ 的/ 内存/ 位置/ 上/ 现在/ 实际/ 存储/ 的/ 是/ c/ ,/ 根据/ 箭头/ 的/ 格式/ 可以/ 同时/ 对照/ 右边/ 的/ 内存/ 分布/ ./ 从图/ 2/ (/ c/ )/ 的/ 第/ 3/ 种/ 情况/ 可以/ 看出/ ,/ 尽管/ 在/ 内存/ 的/ 分布/ 上/ 已经/ 被/ 随机化/ ,/ 但/ a/ ,/ b/ ,/ c/ 仍然/ 得到/ 了/ 正确/ 的/ 初始化/ 值/ ./ 这种/ 映射/ 的/ 提供/ 是/ 本/ 系统/ 所/ 面对/ 的/ 技术/ 挑战/ 之一/ ,/ 因为/ 在/ 具体/ 的/ 程序/ 中/ 可能/ 会/ 面对/ 非常复杂/ 的/ 多层/ 嵌套/ 的/ 情况/ ,/ 如图/ 2/ (/ d/ )/ 例子/ 所示/ ,/ 结构/ 体/ exa8/ 嵌套/ 了/ exa6/ 以及/ exa7/ ./ 为了/ 应对/ 这种/ 复杂/ 的/ 情况/ ,/ 在/ 设计/ 上/ 我们/ 有/ 两个/ 选择/ :/ (/ 1/ )/ 构建/ 一个/ 影子/ 栈/ ,/ 伴随/ 着/ GCC/ 内部/ 对/ 嵌套/ 的/ 压弹/ 栈/ 处理/ ,/ 添加/ 自己/ 的/ 数据结构/ 来/ 跟踪/ 随机化/ 在/ 多个/ 栈帧/ 中/ 的/ 调整/ ;/ (/ 2/ )/ 转化/ 多层/ 嵌套/ 到/ 一个/ 简单/ 的/ 值/ 的/ 序列/ ./ 最终/ ,/ 我们/ 实现/ 了/ 第/ 2/ 个/ 方法/ ./ 如图/ 2/ (/ d/ )/ 所示/ ,/ 我们/ 的/ 映射/ 机制/ 将/ 1/ -/ (/ 2/ -/ 3/ )/ -/ (/ 4/ -/ 5/ -/ 6/ )/ 自动/ 调整/ 为/ 1/ -/ 3/ -/ 2/ -/ 5/ -/ 6/ -/ 4/ 的/ 序列/ ,/ 实现/ 机制/ 如/ 算法/ 1/ 所示/ ./ 算法/ 1/ ./ 域/ 的/ 映射/ ./ 1/ ./ CreateTempSeq/ (/ sfield/ )/ 输入/ :/ sfield/ 为/ 结构/ 体/ 2/ ./ fieldsNum/ =/ calculateFieldNum/ (/ )/ ;/ 3/ ./ Bitmap/ =/ findBitmapScheme/ (/ field/ ./ name/ ,/ 被/ 赋予/ 10/ ,/ 20/ ,/ 30/ 中/ 的/ 任意/ 一个/ 值/ ,/ 图/ 2/ (/ c/ )/ 的/ 第/ 2/ 种/ 情况/ 展示/ 了/ 随机化/ 可能/ 引起/ 的/ 语义/ 错误/ ,/ 在/ 这个/ 例子/ 中/ a/ 被/ 初始化/ 为/ 30/ ,/ 针对/ 这种/ 情况/ ,/ 我们/ 提供/ 域/ 映射/ 机制/ ,/ 将/ 正确/ 的/ 初始化/ 值/ 映射/ 到/ 对应/ 的/ 域/ ,/ 保证/ 语义/ 正确/ ./ 4/ ./ curNode/ =/ linkHead5/ ./ FOREACHcurNode/ -/ >/ next/ &/ curNode/ -/ >/ 6/ ./ indexNode/ =/ curNode/ ;/ 7/ ./ curNode/ =/ curNode/ -/ >/ next8/ ./ ENDFOREACH9/ ./ i/ =/ 0/ ;/ 10/ ./ FOREACHi/ </ fieldsNum/ ;/ DO11/ ./ tempField/ =/ field/ ;/ 12/ ./ j/ =/ 0/ ;/ 13/ ./ FOREACHBitmap/ [/ j/ ]/ !/ =/ ido14/ ./ tempField/ =/ TREE/ _/ CHAIN/ (/ tempField/ )/ ;/ 15/ ./ j/ =/ j/ +/ 1/ ;/ 16/ ./ ENDFOREACH17/ ./ newLinkNode/ =/ newlinkNode/ (/ tempField/ )/ ;/ 18/ ./ insertLinkNode/ (/ curNode/ ,/ newlinkNode/ )/ ;/ 19/ ./ i/ =/ i/ +/ 1/ ;/ 20/ ./ ENDFOREACH21/ ./ indexNode/ =/ indexNode/ -/ >/ next/ ;/ 22/ ./ FOREACHindexNode/ &&/ indexNode/ !/ =/ 23/ ./ IFTREE/ _/ TYPE/ (/ indexNode/ -/ >/ field/ )/ =/ =/ 24/ ./ THENCreateTempSeq/ (/ indexNode/ -/ >/ field/ )/ ;/ Page525/ ./ ENDIF/ // // 递归/ 子结构/ 体/ 算法/ 1/ 以/ 随机化/ 后/ 结构/ 体/ 的/ 第一个/ 域/ field/ 作为/ 输入/ ./ 首先/ ,/ 根据/ 编译器/ 提供/ 的/ field/ 类型/ 名/ 从/ 随机化/ 排列/ 池/ (/ RandomizationSchemePool/ )/ 中/ 读出/ 随机化/ 方案/ Bitmap/ ./ 接着/ 根据/ field/ 的/ chain/ 信息/ 可以/ 顺序/ 地/ 找到/ 该/ 结构/ 体下/ 的/ 所有/ 的/ 域/ ,/ 结合/ Bitmap/ 信息/ ,/ 就/ 可以/ 对/ 随机化/ 后/ 的/ 域/ 序列/ 进行/ 逆/ 处理/ ,/ 将/ 各个/ 域/ 随机化/ 之前/ 的/ 顺序存储/ 在/ 以/ linkHead/ 为头/ 结点/ 的/ 单向/ 链表/ 中/ ./ 最后/ ,/ 还/ 需要/ 对/ 存在/ 嵌套/ 结构/ 体/ 的/ 情形/ 进行/ 递归/ 处理/ ,/ 将/ 代表/ 子结构/ 体的域/ 作为/ 新/ 的/ 节点/ 插入/ 到/ 嵌套/ 子结构/ 体/ 之前/ ./ 3.2/ ./ 2/ 顺序/ 依赖/ 访问/ 之/ 指针/ 算术/ 还有/ 一类/ 顺序/ 依赖/ 的/ 情形/ 是/ 指针/ 算术/ ./ 结构/ 体图/ 3/ 指针/ 算术/ 、/ 链接/ 一致性/ 以及/ 特殊/ 语法/ 可能/ 造成/ 的/ 问题/ 3.2/ ./ 3/ 链接/ 一致性/ 链接/ 不/ 一致/ 的/ 问题/ 主要/ 是/ 由于/ 同一个/ 结构/ 体/ 变量/ 可以/ 被/ 定义/ 在/ 不同/ 模块/ 或/ 不同/ 文件/ 中/ ,/ 而/ 编译/ 时/ 由于/ 不/ 在/ 一个/ 处理/ 周期/ (/ compilingunit/ )/ 中/ ,/ 所以/ 很/ 有/ 可能/ 被/ 随机化/ 为/ 不同/ 的/ 域/ 排列/ 形式/ ,/ 当/ 这些/ 文件/ 、/ 模块/ 链接/ 到/ 一起/ 时/ 就/ 会/ 发生/ 错误/ ./ 这个/ 问题/ 主要/ 以/ 2/ 种/ 形式/ 出现/ :/ 全局变量/ 和/ 全局/ 函数参数/ (/ extern/ )/ ./ 如图/ 3/ (/ d/ )/ 中/ 所示/ ,/ 我们/ 随机化/ 编译/ Bar1/ ./ c/ ,/ 同时/ 正常/ 编译/ Bar2/ ./ c/ ./ 从/ 呈现/ 增长/ 的/ 内存地址/ 可以/ 看出/ ,/ 全局变量/ foo1/ 的/ 域/ 排列/ 正常/ ,/ 但是/ 域值/ 匹配/ 错误/ ,/ 如/ b/ 被/ 赋予/ 了/ 1/ 而/ 不是/ 2/ ,/ a/ 被/ 赋予/ 了/ 3/ ./ 为了/ 避免/ 这种/ 错误/ 的/ 发生/ ,/ 我们/ 对/ 这些/ 类型/ 的/ 结构/ 体/ 进行/ 有/ 技巧/ 的/ 随机化/ :/ 不同/ 文件/ 、/ 模块/ 中/ 同一个/ 结构/ 体/ 全局变量/ 或者/ 参数/ 按照/ 同/ 一种/ 随机化/ 排列/ 进行/ 编译/ ./ 我们/ 指针/ 可以/ 被/ 强制/ 类型/ 转化/ ,/ 并/ 赋/ 给/ 一个/ 基本/ 类型/ 的/ 指针/ ,/ 如/ (/ int/ / )/ ,/ 然后/ 基于/ 这个/ 指针/ 的/ 偏移/ 运算/ 可以/ 被/ 用于/ 索引/ 这个/ 结构/ 体中/ 的/ 域/ ,/ 如图/ 3/ (/ a/ )/ 中/ 的/ foo2/ 所示/ ,/ int/ / 类型/ 的/ 指针/ smallp/ 得到/ 了/ 它/ 的/ 地址/ ,/ 希望/ 去/ 索引/ a/ 域/ ./ 从图/ 3/ (/ b/ )/ 来看/ ,/ 在/ 正常/ 的/ 情况/ 下/ ,/ 表达式/ / smallp/ =/ 1/ 应该/ 会/ 让/ a/ 被/ 赋值/ 为/ 1/ ,/ 但/ 在/ 这个/ 随机化/ 例子/ 中/ c/ 被/ 错误/ 的/ 赋予/ 了/ 1/ ./ 这个/ 问题/ 与/ 前面/ 初始化/ 的/ 问题/ 类似/ ,/ 但/ 却/ 不/ 可以/ 用/ 同样/ 的/ 域/ 映射/ 来/ 解决/ ,/ 因为/ 当前/ 问题/ 本质/ 上/ 是/ 别名/ 分析/ (/ AliasAnalysis/ )/ ,/ 一个/ 不可判定/ 问题/ ,/ 根据/ 相关/ 的/ 程序/ 分析/ 理论/ ,/ 现有/ 的/ 分析/ 技术/ 只能/ 提供/ 一个/ 候选/ 集合/ ,/ 不能/ 精确/ 到/ 某个/ 具体/ 的/ 域/ ./ 因此/ 我们/ 不/ 对/ 涉及/ 了/ 指针/ 操作/ 的/ 结构/ 体/ 进行/ 随机化/ ./ 通过/ 保持/ 唯一/ 一个/ 中间/ 文件/ 记录/ 每/ 一种/ 结构/ 体/ 第一次/ 被/ 随机化/ 时/ 的/ 域/ 排列/ 来/ 告知/ 编译器/ ,/ 以后/ 采用/ 同样/ 的/ 排列/ ./ 3.2/ ./ 4/ 特殊/ 语法/ C99/ 标准/ 的/ 一个/ 特殊/ 语法/ —/ —/ —/ 可/ 变数/ 组成员/ ,/ 允许/ 且/ 只/ 允许/ 结构/ 体/ 的/ 最后/ 一个/ 域/ 是/ 可变/ 长/ 数组/ ,/ 如图/ 3/ (/ c/ )/ 中/ 的/ charc/ [/ ]/ ./ 如果/ 我们/ 不/ 加/ 处理/ 的/ 进行/ 随机化/ ,/ 就/ 可能/ 把/ 这个/ 只能/ 位于/ 末端/ 的/ 变长/ 数组/ 移动/ 到/ 其它/ 位置/ ,/ 从而/ 造成/ 编译/ 错误/ “/ error/ :/ flexiblearraymembernotatendofstruct/ ”/ ./ 因此/ ,/ 我们/ 选择/ 进行/ 有/ 技巧/ 的/ 随机化/ :/ 固定/ 最后/ 一个/ 域/ 的/ 位置/ 且/ 只/ 对/ 除/ 之/ 以外/ 的/ 域/ 进行/ 随机化/ ./ 3.2/ ./ 5/ 可/ 随机化/ 分析/ 总结/ 表/ 1/ 是/ 根据/ 以上/ 分析/ 总结/ 出/ 的/ 结构/ 体可/ 随机化/ Page6/ 分析/ 规则/ ./ 在/ 实际/ 分析/ 过程/ 中/ ,/ 一些/ 结构/ 体/ 可能/ 同时/ 属于/ 表中/ 几个/ 类型/ 的/ 集合/ ,/ 我们/ 在/ 判断/ 一个/ 结构/ 体/ 是否/ 可以/ 随机化/ 时/ 按照/ 如下/ 的/ 函数/ 来/ 进行/ 判断/ :/ RandA/ (/ x/ )/ =/ 其中/ RandA/ (/ x/ )/ 表示/ 对/ 一个/ 结构/ 体/ x/ 进行/ 可/ 随机化/ 判断/ ,/ 根据/ x/ 属于/ 的/ 不同/ 集合/ ,/ RandA/ (/ x/ )/ 函数/ 返回/ Y/ (/ 直接/ 随机化/ )/ 、/ M/ (/ 伴随/ 着/ 映射/ 的/ 随机化/ )/ 、/ S/ (/ 有/ 技巧/ 的/ 随机化/ )/ 或/ N/ (/ 不/ 可以/ 随机化/ )/ ./ 顺序/ 依赖/ 访问/ (/ A/ )/ 1/ ./ 结构/ 体/ 初始化/ 链接/ 一致性/ (/ B/ )/ 1/ ./ 不同/ 文件/ 分布/ 的/ 符号/ 有/ 技巧/ 随机化/ (/ S/ )/ 特殊/ 语法/ (/ C/ )/ 变/ 长/ 数组/ 成员/ 有/ 技巧/ 随机化/ (/ S/ )/ 3.3/ 自动/ 结构/ 体/ 随机化/ 结构/ 体内/ 存/ 的/ 分配/ 方式/ 主要/ 有堆/ 分配/ 、/ 栈/ 分配/ 和/ 静态/ 存储/ 区/ 分配/ 3/ 种/ ,/ 但是/ 不管/ 是/ 哪种/ 分配/ 方式/ ,/ 内存/ 分配/ 都/ 发生/ 在/ 变量/ 的/ 声明/ 阶段/ ,/ 也就是说/ ,/ 直观/ 上/ 我们/ 看到/ 的/ 随机化/ 是/ 结构/ 体域/ 顺序/ 的/ 变化/ ,/ 本质/ 上/ 是/ 内存/ 上/ 各个/ 域/ 所/ 占/ 的/ 空间/ 的/ 重新/ 调整/ ./ 这种/ 调整/ 可以/ 进一步/ 被/ 理解/ 为域/ 起始/ 位置/ 的/ 互换/ ./ 当/ 各个/ 域/ 的/ 长度/ 不/ 同时/ ,/ 就/ 可能/ 造成/ 互相/ 覆盖/ ./ 假设/ 现在/ 存在/ 一个/ 结构/ 体/ ,/ 它/ 包含/ 3/ 个域/ 依次/ 为/ char/ 、/ int/ 和/ double3/ 种/ 类型/ ,/ 未/ 进行/ 随机化/ 时/ 这个/ 结构/ 体/ 的/ 内存/ 布局/ 如图/ 4/ (/ a/ )/ 所示/ ,/ 在/ 这/ 一/ 内存/ 区域/ 中/ 它们/ 分别/ 占/ 1/ 字节/ 、/ 4/ 字节/ 和/ 8/ 字节/ ./ 对/ 这个/ 结构/ 体/ 进行/ 随机化/ ,/ 假设/ 随机化/ 之后/ 域/ 的/ 顺序/ 变成/ int/ 、/ double/ 、/ char/ ,/ 此时/ 的/ 内存/ 实际/ 为/ 图/ 4/ (/ b/ )/ ,/ int/ 域/ 位于/ 0/ 到/ 4/ 内存/ 段/ ,/ 而/ double/ 位于/ 1/ 到/ 9/ 内存/ 段/ ,/ 这/ 两个/ 域/ 已经/ 发生/ 了/ 覆盖/ ,/ 同样/ double/ 和/ char/ 两个/ 域/ 也/ 发生/ 了/ 覆盖/ ./ 我们/ 可以/ 看到/ ,/ 仅仅/ 顺序/ 上/ 的/ 调整/ 并/ 不能/ 解决/ 域/ 之间/ 的/ 互相/ 覆盖/ 问题/ ./ 鉴于/ 以上/ 分析/ ,/ 我们/ 在/ 随机化/ 的/ 过程/ 中/ 采用/ 有/ 选择/ 的/ 随机化/ 方案/ ,/ 只/ 对/ 占有/ 相同/ 大小/ 内存空间/ 的/ 域/ 进行/ 随机化/ ./ 在/ 此/ ,/ 我们/ 要/ 对/ 可能/ 出现/ 的/ 数据类型/ 所/ 占/ 的/ 内存空间/ 有/ 一个/ 全面/ 的/ 了解/ ./ GCC/ 将/ C语言/ 中/ 的/ 类型/ 分为/ 5/ 类/ :/ int/ 、/ char/ 、/ long/ 等/ 基本/ 类型/ 归为/ INTEGER/ _/ TYPE/ ,/ 结构/ 体/ 类型/ 为/ RECORD/ _/ TYPE/ ,/ 指针/ 类型/ 归为/ POINTER/ _/ TYPE/ ,/ 数组/ 类型/ 为/ ARRAY/ _/ TYPE/ ,/ 最后/ Union/ 类型/ 为/ UNION/ _/ TYPE/ ./ 由于/ 指针/ 类型/ 、/ 数组/ 以及/ Union/ 类型/ 的/ 大小/ 难以确定/ ,/ 因此/ 我们/ 随机化/ 的/ 时候/ 主要/ 考虑/ 除/ 这/ 三者/ 之外/ 的/ INTEGER/ _/ TYPE/ 、/ RECORD/ _/ TYPE/ 的/ 两种/ 类型/ 的/ 域/ ,/ 大部分/ 结构/ 体/ 属于/ 这个/ 范畴/ ./ INTEGER/ _/ TYPE/ 代表/ 的/ 类型/ 涵盖/ 了/ 几个/ 不同/ 的/ 基本/ 类型/ ,/ 而/ 这些/ 基本/ 类型/ 所/ 占/ 的/ 内存空间/ 大小/ 也/ 是/ 各不相同/ 的/ ,/ 我们/ 在/ 比较/ 2/ 个/ INTEGER/ _/ TYPE/ 时/ 再/ 引入/ 该/ 类型/ 的/ 一个/ 属性/ TYPE/ _/ SIZE/ ,/ TYPE/ _/ SIZE/ 标识/ 着/ 该/ 类型/ 在/ 内存/ 中所/ 占/ 的/ 空间/ 大小/ ./ 另外/ ,/ 对于/ 同/ 是/ 结构/ 体/ 类型/ RECORD/ _/ TYPE/ ,/ 我们/ 引入/ 另外/ 2/ 个/ 属性/ 来/ 进一步/ 确定/ :/ 一个/ 是/ 结构/ 体/ 类型/ 的/ 类型/ 名字/ TYPE/ _/ NAME/ ;/ 另/ 一个/ 是/ 结构/ 体/ 类型/ 所/ 含有/ 域/ 的/ 数目/ fieldsNum/ ./ 只有/ 类型/ 名/ 相同/ 而且/ 拥有/ 的/ 域/ 数目/ 也/ 相同/ 的/ 结构/ 体/ 才能/ 进行/ 随机化/ ./ 算法/ 2/ 展示/ 了/ 对/ 一个/ 结构/ 体/ 进行/ 随机化/ 的/ 处理过程/ ./ 首先/ ,/ 算法/ 根据/ 结构/ 体/ 第一个/ 域/ 顺序/ 将/ 找到/ 其他/ 域/ 并/ 存储/ 在/ 一个/ tree/ 类型/ 的/ 数组/ fieldArray/ 中/ ,/ 同时/ 计算/ 域/ 的/ 数目/ fieldsNum/ ./ 接着/ ,/ createAdjList/ 遍历/ fieldArray/ ,/ 构造/ 一个/ 邻接/ 表/ ,/ 表头/ 为/ listHead/ ./ 邻接/ 表/ 的/ 横向/ 链/ 节点/ 保存/ 的/ 是/ fieldArray/ 数组/ 中/ 具有/ 相同/ 类型/ (/ 占/ 内存空间/ 相同/ )/ 的/ 域/ ,/ 纵向/ 链表/ 邻接/ 的/ 是/ 每个/ 横向/ 链表/ 的/ 第一个/ 节点/ ./ 邻接/ 表/ 构造/ 完成/ 后/ ,/ 算法/ 分别/ 遍历/ 邻接/ 表/ 的/ 每个/ 横向/ 链表/ ,/ 计算/ 出/ 相同/ 类型/ 域/ 的/ 数目/ rowFieldsNum/ ,/ 随机数/ 序列/ 生成/ 函数/ 根据/ rowFieldsNum/ 产生/ 随机/ 排列/ 的/ 0/ 到/ rowFieldsNum/ -/ 1/ 的/ 自然数/ ,/ 作为/ 横向/ 链表/ 上域/ 的/ 随机/ 策略/ rowBitmap/ ,/ 并/ 结合/ 邻接/ 表/ 节点/ 的/ 属性/ index/ 将子/ 随机化/ 策略/ 反映/ 到/ 整个/ 域/ 的/ 随机化/ 策略/ bitmap/ 上/ ,/ 所有/ 横向/ 链表/ 遍历/ 完成/ 后/ ,/ bitmap/ 也/ 构造/ 完成/ 了/ ,/ 算法/ 根据/ bitmap/ 随机化/ 策略/ 对/ 结构/ 体的域/ 进行/ 中/ 排序/ ,/ 即/ 完成/ 随机化/ ./ Page7/ 算法/ 2/ ./ 自动/ 随机化/ ./ ReverseBySet/ (/ name/ ,/ field/ )/ 输入/ :/ name/ 是/ 结构/ 体/ 的/ 名称/ 1/ ./ fieldsNum/ =/ 0/ ;/ 2/ ./ FOREACHt/ =/ fieldDO3/ ./ fieldArray/ [/ fieldsNum/ ]/ =/ t/ ;/ 4/ ./ t/ =/ TREE/ _/ CHAIN/ (/ t/ )/ ;/ 5/ ./ ENDFOREACH6/ ./ IFreadSameType/ (/ schemeFile/ ,/ name/ )/ !/ =/ 1THEN7/ ./ createAdjList/ (/ fieldArray/ ,/ listHead/ )/ ;/ 8/ ./ t/ =/ listHead/ ;/ 9/ ./ FOREACHt/ !/ =/ NULLDO10/ ./ tNode/ =/ t/ ;/ 11/ ./ FOREACHtNode/ =/ tNode/ -/ >/ rowNext/ ;/ DO12/ ./ nodeArray/ [/ rowFieldsNum/ ]/ =/ tNode/ ;/ 13/ ./ rowFieldsNum/ =/ rowFieldsNum/ +/ 1/ ;/ 14/ ./ ENDFOREACH/ // // 生成/ 随机化/ 排列/ rowBitmap15/ ./ rowBitmap/ =/ bitmapGen/ (/ rowFieldsNum/ )/ ;/ 16/ ./ i/ =/ 0/ ;/ 17/ ./ FOREACHi/ </ rowFieldsNumDO18/ ./ // // 根据/ 随机化/ 排列/ 调整/ 各个/ 域/ 的/ 排列/ 进行/ 19/ ./ bitmap/ [/ nodeArray/ [/ rowBitmap/ [/ i/ ]/ ]/ -/ >/ 20/ ./ i/ =/ i/ +/ 1/ ;/ 21/ ./ ENDFOREACH22/ ./ ENDFOREACH23/ ./ ENDIF24/ ./ j/ =/ 0/ ;/ 25/ ./ FOREACHj/ </ fieldsNum/ -/ 1do/ 表/ 2/ 可/ 随机化/ 分析/ 目标/ 集合/ 7845Rootkit/ 结构/ 体/ 类型/ 总数/ 防御/ 效果/ Adore/ -/ ng0/ ./ 56/ 表/ 3Rootkit/ 测试/ 结果/ Int3HookEnyelkm/ -/ 1.3/ KbdvSynapsys/ -/ 0.4/ TaskigtDRProc/ 文件系统/ 26/ ./ TREE/ _/ CHAIN/ (/ fieldArray/ [/ bitmap/ [/ j/ ]/ ]/ )/ =/ 27/ ./ j/ =/ j/ +/ 1/ ;/ 28/ ./ ENDFOREACH4/ 实验/ 我们/ 使用/ 8/ 个/ 具有/ 代表性/ 的/ Rootkit/ 来/ 验证/ 系统/ 的/ 有效性/ 与/ 性能/ ,/ 它们/ 分别/ 基于/ 5/ 种/ 不同/ 的/ 原理/ ,/ 包括/ 修改/ Proc/ 文件系统/ [/ 8/ ,/ 11/ ]/ 、/ DKOM/ [/ 15/ ]/ 、/ 基于/ 硬件/ 断点/ [/ 12/ ]/ 、/ 系统/ 调用/ 表/ [/ 13/ ]/ 以及/ 修改/ 中断/ 描述符/ 表/ [/ 10/ ]/ ./ 实验/ 结果显示/ 这些/ Rootkit/ 在/ 随机化/ 的/ 内核/ 上/ 都/ 无法/ 正常/ 加载/ 和/ 运行/ ,/ 成功/ 实现/ 了/ 防御/ ./ 实验/ 的/ 平台/ 配置/ 为/ Ubuntu6/ ./ 06/ ,/ 测试/ Linux/ 内核/ 为/ 2.6/ ./ 15/ ,/ 运行/ 的/ 平台/ 是/ Inter/ (/ R/ )/ Core/ (/ M/ )/ 2DuoCPUE84003/ ./ 00GHz/ 以及/ 512MBRAM/ ./ 我们/ 将分/ 3/ 个/ 部分/ 展示/ 实现/ 结果/ ,/ 首先/ 是/ 可/ 随机性/ 分析/ ,/ 然后/ 是/ Rootkit/ 防御/ 的/ 有效性/ ,/ 最后/ 是/ 系统/ 性能/ ./ 4.1/ Rootkit/ 可/ 随机化/ 分析测试/ 根据/ 前面/ 的/ 可/ 随机化/ 分析/ 的/ 规则/ ,/ 我们/ 总结/ 了/ 实验/ 过程/ 中/ 的/ 目标/ 集合/ 的/ 数量/ 以及/ 经过/ 可/ 随机化/ 分析/ 筛选/ 后/ ,/ 仍然/ 被/ 随机化/ 的/ 数量/ ./ 经/ 统计/ ,/ Linux2/ ./ 6.15/ 内核/ 中/ 结构/ 体/ 类型/ ,/ 即/ KernelStructList/ (/ W/ )/ ,/ 共为/ 8850/ 种/ ./ 另外/ ,/ 5/ 个/ 类型/ 8/ 个/ Rootkit/ 分别/ 含有/ 的/ 结构/ 体/ 的/ 类型/ 数/ 可以/ 在/ 表/ 3/ 第/ 2/ 列/ “/ 结构/ 体/ 类型/ 总数/ ”/ 中查/ 到/ ,/ 我们/ 将/ 这些/ 结构/ 体做/ 一个/ 并集/ 一共/ 得到/ 462/ 种/ 结构/ 体/ ,/ 即/ RootkitStructList/ (/ Q/ )/ ./ 最后/ 我们/ 通过/ 计算/ S/ =/ Q/ ∩/ W/ ,/ 得到/ 的/ 目标/ 集合/ (/ TargetStructList/ (/ S/ )/ )/ 共为/ 78/ 种/ ,/ 亦/ 表明/ 其中/ 有/ 384/ 种/ 结构/ 体是/ Rootkit/ 自定义/ 的/ ,/ 对/ 篡改/ 内核/ 制流/ 没有/ 影响/ ./ 如表/ 2/ 有/ 45/ 种/ 类型/ 有/ 结构/ 体/ 初始化/ 的/ 情况/ ,/ 需要/ 做/ 映射/ ;/ 有/ 68/ 种/ 链接/ 一致性/ (/ B/ )/ DKOMDKOMPage8/ 结构/ 体/ 出现/ 类型转换/ 与/ 指针/ 算术/ 问题/ ,/ 无法/ 被/ 随机化/ ./ 套用/ 我们/ 在/ 前面/ 3.2/ ./ 5/ 小节/ 定义/ 出来/ 的/ 筛选/ 规律/ ,/ 最后/ 我们/ 得到/ 结论/ ,/ 有/ 10/ 种/ 结构/ 体/ 可以/ 被/ 安全/ 地/ 编译/ 用于/ 防御/ Rootkit/ 的/ Linux/ 内核/ ./ 4.2/ Rootkit/ 防御/ 有效性/ 测试/ 基于/ 前面/ 的/ 分析/ ,/ 我们/ 安全/ 地/ 随机化/ 了/ Linux/ 内核/ ,/ 并用/ 这个/ 内核/ 进行/ 了/ 防御/ Rootkit/ 的/ 有效性/ 实验/ ./ 表/ 3/ 展示/ 了/ 防御/ 效果/ ,/ 并且/ 进一步/ 给出/ 了/ 引起/ 这些/ Rootkit/ 失败/ 的/ 关键/ 结构/ 体名/ 以及/ 关键/ 的/ 变量名/ ./ 下面/ 我们/ 就/ 这/ 几个/ 例子/ 做/ 一些/ 深入/ 的/ 探讨/ ./ Adore/ -/ ng0/ ./ 56/ ①/ 是/ 一个/ 具有/ 代表性/ 的/ VirtualFileSystem/ 相关/ 的/ Rootkit/ ./ Proc/ 文件系统/ 中/ 包含/ 了/ 很多/ 系统/ 信息/ ,/ 比如说/ proc/ 目录/ 下/ 可以/ 看到/ pid/ 信息/ ,/ 子目录/ net/ 下/ 可以/ 看到/ 系统/ 当前/ 的/ 网络连接/ 状态/ 等等/ ./ 一些/ 管理员/ 工具/ (/ 如/ ps/ 、/ netstat/ 等/ )/ 都/ 是/ 直接/ 从/ 该/ 目录/ 下/ 查看/ 系统/ 实时/ 运行状况/ 的/ ./ Linux2/ ./ 6.15/ 内核/ 是/ 通过/ 结构/ 体/ 变量/ proc/ _/ root/ 来/ 访问/ 该/ 目录/ 的/ ,/ 因而/ Adore/ -/ ng/ 通过/ 篡改/ proc/ _/ root/ 中/ 的/ 文件/ 操作/ 函数/ 集/ proc/ _/ iops/ 达到/ 隐藏/ 指定/ 进程/ 、/ 网络/ 端口/ 等/ 目的/ ./ 但是/ ,/ 经过/ 随机化/ 处理/ 后/ ,/ 我们/ 内核/ 中/ proc/ _/ root/ 结构/ 体/ 类型/ 对象/ proc/ _/ dir/ _/ entry/ 中域/ 的/ 排列/ 已经/ 发生/ 了/ 变化/ ,/ 引发/ Adore/ -/ ng/ 加载/ 失败/ ,/ 不仅/ 防止/ 了/ 这次/ 攻击/ ,/ 还/ 通过/ 触发/ syslog/ 的/ 记录/ 通知/ 了/ 管理员/ ./ Taskigt/ ②/ 的/ 情况/ 同理/ ./ 与/ Adore/ -/ ng/ 不同/ ,/ Enyelkm/ ③/ 是/ 通过/ 对系统/ 调用/ 进行/ 篡改/ 来/ 劫持/ 系统控制/ 流/ 的/ ./ Enyelkm/ 通过/ 在/ 系统/ 符号表/ 中/ 匹配/ 特殊/ 的/ 字符串/ 来/ 定位系统/ 调用/ 表在/ 内存/ 中/ 的/ 地址/ ./ 一些/ 系统/ 调用/ 常常/ 是/ 实现/ ls/ 、/ ps/ 等/ 命令/ 的/ 关键/ ,/ 如/ getdents64/ 、/ read/ 、/ write/ 等/ ,/ Enyelkm/ 正是/ 通过/ 篡改/ 这些/ 系统/ 调用/ 来/ 执行/ 恶意代码/ 的/ ./ 由于/ 系统/ 调用/ 表是/ 以/ 数组/ 的/ 形式/ 存在/ 于/ 内存/ 中/ 的/ ,/ 而/ 我们/ 的/ 随机化/ 目前/ 还/ 不能/ 直接/ 针对/ 系统/ 调用/ 表/ 这样/ 的/ 数组/ 类型/ 进行/ 随机化/ ./ 但/ 特别/ 要/ 指出/ 的/ 是/ ,/ 我们/ 的/ 方法/ 对/ Enyelkm/ 仍然/ 有效/ ,/ 虽然/ 我们/ 的/ 方法/ 目前/ 并/ 不能/ 随机化/ 系统/ 调用/ 表/ 这样/ 的/ 数组/ ,/ 但/ 经过/ 实验/ 我们/ 发现/ Enyelkm/ 用到/ 了/ 一个/ 名为/ mod/ -/ ule/ 的/ 结构/ 体/ ,/ 这个/ 结构/ 体/ 与/ 加载/ 直接/ 相关/ ,/ 攻击者/ 不/ 可以/ 省略/ ,/ 而/ 我们/ 正是/ 通过/ 随机化/ 这个/ 结构/ 体/ 最终/ 达到/ 了/ 防御/ 系统/ 调用/ 表型/ Rootkit/ 的/ 目的/ ./ 这/ 也/ 是/ Synapsys0/ ./ 4/ ④/ 、/ Int3Hook/ ⑤/ (/ 中断/ 描述符/ 类型/ )/ 以及/ DR/ ⑥/ (/ 硬件/ 断点/ 类型/ )/ 加载/ 失败/ 的/ 原因/ ./ HP/ ⑦/ (/ hideprocess/ )/ 是/ 一类/ DKOMRootkit/ 的/ 代表/ ,/ 在/ Linux/ 系统/ 中/ ,/ 各个/ 进程/ 的/ 进程/ 描述符/ 是/ 通过/ 一个/ 双向/ 链表/ 组织/ 起来/ 的/ ,/ 每个/ 节点/ 都/ 是/ task/ _/ struct/ 类型/ 的/ 描述符/ 变量/ ,/ 该/ 结构/ 体中/ 包含/ 一个/ list/ _/ head/ 类型/ 的/ tasks/ 字段/ ,/ 这个/ 类型/ 的/ prev/ 和/ next/ 分别/ 指向/ 前面/ 和/ 后面/ 的/ task/ _/ strcut/ 节点/ ./ HP/ 正是/ 利用/ 这个/ 宏在/ 加载/ 模块/ 时/ 将/ 指定/ 进程/ 描述符/ 从/ 链表/ 中/ 删除/ ,/ 从而/ 达到/ 隐藏/ 进程/ 的/ 效果/ ./ 而/ 我们/ 的/ 系统/ 能够/ 对/ task/ _/ struct/ 结构/ 体/ 进行/ 随机化/ ,/ 调用/ 宏时/ 将/ 索引/ 到/ 不可/ 预知/ 的/ 域/ 中/ ,/ 从而/ 起到/ 防御/ 这种/ Rootkit/ 的/ 功能/ ./ Kbdv/ 的/ 情况/ 与/ 之/ 类似/ ./ 4.3/ 性能/ 测试/ 我们/ 使用/ UnixBench/ -/ 4/ ⑧/ 作为/ Benchmark/ 全面/ 地/ 测试/ 内核/ 的/ 性能/ ,/ 以/ 观察/ 结构/ 体/ 随机化/ 对/ 内核/ 运行/ 产生/ 的/ 性能/ 影响/ ./ 如表/ 4/ 所示/ ,/ UnixBench/ 进行/ 了/ 包括/ 算术/ 运算/ 、/ 进程/ 创建/ 、/ 文件/ 拷贝/ 、/ 系统/ 调用/ 负荷/ 等/ 11/ 项/ 测试/ 任务/ ,/ 并/ 最终/ 给出/ 一个/ 得分/ (/ FinalScore/ )/ 做/ 了/ 对/ 性能/ 的/ 整体/ 评价/ ,/ 得分/ 越高/ 说明/ 系统/ 性能/ 越好/ ./ 我们/ 分别/ 3/ 次/ 编译/ 了/ 正常/ 与/ 随机化/ Linux2/ ./ 6.15/ 内核/ ,/ 并/ 在/ 每个/ 内核/ 上/ 都/ 进行/ 了/ 3/ 次/ 性能/ 测试/ ./ 就/ 实验/ 数据/ 的/ 平均值/ 来看/ ,/ 正常/ 的/ 内核/ 的/ 性能/ 与/ 随机化/ 内核/ 性能/ 基本一致/ ./ 从/ 原理/ 上/ 来说/ ,/ 结构/ 体/ 的/ 随机化/ 只是/ 调整/ 了/ 各个/ 域/ 在/ 内存/ 中/ 的/ 分布/ ,/ 改变/ 了/ 相关/ 指令/ 的/ 偏移/ ,/ 几乎/ 不会/ 为/ 系统/ 运行/ 带来/ 任何/ 额外/ 的/ 性能/ 损耗/ ,/ 实验/ 结果/ 符合/ 这种/ 判断/ ./ 另外/ ,/ 虽然/ 我们/ 的/ 方法/ 在/ 编译/ 上会/ 多花/ 少许/ 时间/ ,/ 但/ 针对/ 这个/ 问题/ 来说/ ,/ 编译/ 的/ 时间/ 并/ 不/ 重要/ ./ 因此/ 可以/ 说/ 我们/ 的/ 方法/ 是/ 极其/ 高效/ 的/ ./ 5/ 相关/ 工作/ 5.1/ Rootkit/ 防御/ Rootkit/ 的/ 防御/ 工作/ 主要/ 从/ 分析/ 、/ 检测/ 以及/ 预防/ 3/ 个/ 方面/ 展开/ ./ Rootkit/ 分析/ 专注/ 于/ 理解/ 其/ 运作/ 机制/ ,/ 包括/ 恶意/ 操作/ 指令/ [/ 11/ ]/ ,/ 钩子/ 函数/ [/ 14/ ]/ 以及/ 对/ 内核/ 数据/ 的/ 修改/ 操作/ [/ 15/ ]/ ./ Rootkit/ 检测/ 的/ 方法/ 主要/ 包括/ :/ (/ 1/ )/ 加载/ 时/ 的/ 二进制/ 分析/ [/ 2/ ]/ ;/ (/ 2/ )/ 完整性检查/ ,/ 包括/ ①/ ②/ ③/ ④/ ⑤/ ⑥/ ⑦/ ⑧/ Page9/ 表/ 4UnixBench/ 性能/ 测试/ 内核/ 类别/ 第/ 1/ 次/ 编译/ 645.3642/ ./ 6640.3642/ ./ 7627.9650/ ./ 2640.1639/ ./ 4/ 第/ 2/ 次/ 编译/ 644.2646/ ./ 1643.4644/ ./ 5642.5641/ ./ 1646.0643/ ./ 2/ 第/ 3/ 次/ 编译/ 638.7639/ ./ 8641.2639/ ./ 9640.4638/ ./ 6643.5640/ ./ 8/ 最终/ 平均/ 静态/ 数据完整性/ [/ 4/ ,/ 16/ -/ 17/ ]/ 、/ 动态/ 数据完整性/ [/ 5/ ,/ 12/ ]/ 或/ 针对/ 一些/ 关键/ 的/ 内核/ 数据结构/ 不/ 变量/ 的/ 检测/ [/ 3/ ]/ ./ Rootkit/ 预防/ 方法/ 有/ 监控/ 执行/ 中/ 的/ 异常情况/ [/ 18/ -/ 20/ ]/ ,/ 防止/ Rootkit/ 代码/ 在/ 内核/ 态中/ 执行/ ./ 然而/ ,/ 上面/ 提及/ 的/ 方法/ 都/ 有/ 其/ 自身/ 的/ 缺陷/ :/ 分析/ 的/ 方法/ 有助于/ 更好/ 地/ 理解/ Rootkit/ 但/ 不能/ 起到/ 防御/ 的/ 作用/ ;/ 检测/ 方法/ 需要/ 巨大/ 的/ 系统/ 额外/ 损耗/ ,/ 而且/ 只能/ 检测/ 已知/ 的/ 、/ 针对/ 特定/ 结构/ 体/ 的/ Rootkit/ ;/ 预防/ 的/ 方法/ 也/ 存在/ 监控/ 系统/ 负荷/ 过大/ 的/ 问题/ ,/ 另外/ 采用/ 代码/ 重用/ 技术/ 的/ Rootkit/ [/ 21/ ]/ 甚至/ 可以/ 避开/ 这种/ 预防/ ./ 与/ 这些/ 方法/ 相比/ ,/ 我们/ 的/ 工作/ 不/ 针对/ 特定/ 方法/ 入侵/ 的/ Rootkit/ ,/ 对/ 所有/ 篡改/ 内核/ 结构/ 体/ 的/ Rootkit/ 都/ 具有/ 良好/ 的/ 防御/ 效果/ ,/ 并且/ 在/ 性能/ 上/ 存在/ 优势/ ./ 5.2/ 随机化/ 技术/ 随机化/ 技术/ 是/ 一种/ 增加/ 程序/ 可靠性/ 的/ 可行/ 方案/ ,/ Collberg/ [/ 22/ ]/ 已经/ 描述/ 过/ 各种/ 不同/ 的/ 随机化/ 方案/ ,/ 地址/ 随机化/ [/ 8/ ]/ 引入/ 了/ 内存地址/ 空间布局/ 的/ 多样性/ ,/ 破除/ 了/ 内存/ 侵蚀/ 攻击/ 所/ 需/ 的/ 内存/ 先验/ 知识/ ;/ 指令/ 随机化/ [/ 7/ ]/ 首先/ 对/ 指令/ 进行/ 加密/ 并/ 在/ 指令/ 执行/ 之前/ 对/ 其/ 进行/ 解密/ ,/ 因此/ 外来/ 注入/ 的/ 指令/ 由于/ 没有/ 经过/ 加密/ ,/ 将/ 在/ 解密/ 时/ 出现/ 错误/ ;/ 操作系统/ 随机化/ [/ 13/ ]/ 对系统/ API/ 和/ 库函数/ 的/ 位置/ 进行/ 重新/ 分布/ ,/ 攻击者/ 如果/ 希望/ 通过/ return/ -/ to/ -/ libc/ 攻击/ 来/ 重用/ 这些/ 库函数/ 时/ 将/ 会/ 发生/ 错误/ ./ Lin/ 等/ 人/ [/ 9/ ]/ 在/ 结构/ 体/ 随机化/ 方面/ 做出/ 了/ 第一个/ 尝试/ ,/ 但是/ 这个/ 工作/ 的/ 不足/ 也/ 很/ 明显/ :/ 必须/ 对要/ 随机化/ 的/ 结构/ 体/ 进行/ 手动/ 标注/ ,/ 而且/ 不能/ 解决/ 那些/ 可能/ 出现/ 语义/ 错误/ 的/ 情况/ ,/ 而/ 我们/ 的/ 工作/ 很/ 好/ 的/ 解决/ 了/ 这/ 两个/ 问题/ ./ 6/ 局限性/ 与/ 未来/ 的/ 工作/ 我们/ 的/ 工作/ 仍然/ 存在/ 一定/ 的/ 局限性/ ,/ 主要/ 表现/ 在/ 随机化/ 的/ 粒度/ 与/ 随机化/ 集合/ 的/ 大小/ ./ 目前/ 我们/ 只/ 采用/ 的/ 是/ “/ 域重/ 排序/ ”/ 的/ 随机化/ 方法/ ,/ 下一阶段/ 我们/ 可以/ 继续/ 探索/ 垃圾/ 域/ 的/ 插入/ 、/ 结构/ 体/ 拆分/ 等/ 手段/ 进一步/ 增强/ 随机化/ 的/ 空间/ ,/ 使/ 猜测/ 攻击/ 更加/ 难以/ 奏效/ ;/ 另外/ ,/ 我们/ 当前/ 进行/ 随机化/ 的/ 目标/ 集合/ 仍然/ 是/ 全部/ 内核/ 结构/ 体/ 的/ 一个/ 子集/ ,/ 但/ Rootkit/ 作者/ 正/ 不断/ 地/ 尝试/ 着/ 利用/ 新/ 的/ 结构/ 体对/ 内核/ 造成/ 伤害/ [/ 6/ ]/ ,/ 因而/ 我们/ 希望/ 能够/ 让/ 被/ 随机化/ 的/ 结构/ 体/ 空间/ 扩大/ 到/ 全体/ 内核/ 结构/ 体/ ,/ 实现/ 对/ 已知/ 和/ 未知/ 结构/ 体/ 的/ 全面/ 防御/ ./ 7/ 结论/ 本文/ 中/ ,/ 我们/ 提出/ 了/ 一个/ 新/ 的/ 基于/ 结构/ 体/ 随机化/ 的/ 内核/ Rootkit/ 防御/ 技术/ ,/ 作为/ 常用/ 编译器/ GCC/ 的/ 一个/ 扩展/ 而/ 实现/ ./ 我们/ 的/ 系统/ 可以/ 自动/ 地/ 完成/ 可/ 随机化/ 分析/ ,/ 区分/ 哪些/ 适合/ 直接/ 做/ 随机化/ ,/ 哪些/ 适合/ 做/ 有/ 技巧/ 的/ 随机化/ ,/ 哪些/ 需要/ 域/ 的/ 映射/ 以及/ 哪些/ 根本/ 不/ 适合/ 做/ 随机化/ ,/ 在/ 这样/ 完善/ 的/ 可/ 随机/ 分析/ 的/ 基础/ 上/ 自动/ 完成/ 结构/ 体/ 随机化/ ./ 实验/ 表明/ ,/ 随机化/ 后/ 的/ Linux/ 内核/ 对/ 8/ 个/ 基于/ 5/ 种/ 不同/ 原理/ 的/ Rootkit/ 进行/ 了/ 有效/ 的/ 防御/ ,/ 并/ 几乎/ 没有/ 为/ 内核/ 的/ 运行/ 增加/ 额外/ 的/ 损耗/ ./ 致谢/ 我/ 的/ 老师/ 茅兵/ 教授/ 对/ 我/ 进行/ 了/ 指导/ ,/ 在/ 此/ 表示感谢/ !/ 

