Page1Java/ 程序/ 混淆/ 技术/ 综述/ 王建民/ 1/ )/ ,/ 2/ )/ ,/ 3/ )/ 余志伟/ 1/ )/ ,/ 2/ )/ ,/ 3/ )/ ,/ 4/ )/ 王朝/ 坤/ 1/ )/ ,/ 2/ )/ ,/ 3/ )/ 付军宁/ 1/ )/ ,/ 2/ )/ ,/ 3/ )/ 1/ )/ (/ 清华大学/ 软件/ 学院/ 北京/ 100084/ )/ 2/ )/ (/ 清华/ 信息科学/ 与/ 技术/ 重点/ 实验室/ 北京/ 100084/ )/ 3/ )/ (/ 信息系统/ 安全/ 教育部/ 重点/ 实验室/ 北京/ 100084/ )/ 4/ )/ (/ 清华大学/ 计算机科学/ 与/ 技术/ 系/ 北京/ 100084/ )/ 摘要/ 软件/ 混淆/ 技术/ 已经/ 广泛应用/ 于/ 抵制/ 逆向/ 工程/ 和/ 重组/ 工程/ ./ 文中/ 从/ 混淆/ 技术/ 的/ 历史/ 发展/ 角度/ 对/ 现有/ 的/ 混淆/ 技术/ 理论/ 、/ 算法/ 、/ 攻击/ 模式/ 和/ 评估/ 进行/ 了/ 综述/ ,/ 将/ Java/ 程序/ 混淆/ 算法/ 分为/ 类内/ 混淆/ 和/ 类间/ 混淆/ 两个/ 类别/ ,/ 并/ 对/ 其中/ 的/ 各类/ 算法/ 进行/ 详尽/ 的/ 阐释/ ./ 最后/ 在/ 现有/ 工作/ 的/ 基础/ 上/ ,/ 展望/ 了/ 软件/ 混淆/ 技术/ 未来/ 的/ 发展/ 与/ 研究/ 方向/ ./ 关键词/ 程序/ 混淆/ ;/ 软件/ 水印/ ;/ 防/ 篡改/ ;/ 软件/ 版权保护/ 1/ 引言/ 随着/ 计算机软件/ 的/ 广泛/ 使用/ ,/ 软件/ 的/ 安全/ 问题/ 严重威胁/ 着/ 软件产业/ 的/ 发展/ ,/ 主要/ 表现/ 为/ :/ 软件/ 攻击者/ 获得/ 试图/ 攻击/ 的/ 软件/ 备份/ 之后/ ,/ 成功/ 地/ 破解/ 软件/ ./ 现有/ 的/ 调试/ 和/ 编辑/ 工具/ ,/ 使/ 直接/ 检查/ 或/ 修改/ 二进制/ 程序代码/ 变得/ 更加/ 容易/ ./ 因此/ ,/ 通常/ 情况/ 下/ 攻击者/ 会/ 重组/ 或/ 破解/ 软件/ ,/ 导致/ 软件/ 的/ 使用/ 控制/ 机制/ 失效/ ./ 破解/ 后/ 的/ 软件/ 可以/ 非法/ 向/ 大众/ 分发/ ,/ 更加/ 助长/ 了/ 软件/ 盗版/ 问题/ ./ Java/ 程序/ 由于/ 平台/ 无关/ 性/ 得以/ 在/ Internet/ 上/ 迅速/ 传播/ 和/ 使用/ ./ 但/ 同时/ ,/ Java/ 语言/ 的/ 这/ 一/ 特性/ 也/ 带来/ 了/ 保护/ 知识产权/ 方面/ 的/ 新/ 问题/ ./ Java/ 语言/ 为了/ 支/ Page2/ 持/ 平台/ 无关/ 性/ ,/ 采用/ 了/ Class/ 这种/ 字节/ 码/ 文件格式/ ①/ ./ 经过/ 预/ 编译/ 之后/ ,/ Java/ 源代码/ 指令/ 转化/ 为/ 字节/ 码/ ,/ 而后/ 在/ 虚拟机/ 上/ 解释/ 执行/ ./ 由于/ Java/ 字节/ 码/ 的/ 设计/ 是/ 为了/ 使/ 语言/ 更/ 简洁/ 、/ 更/ 具有/ 平台/ 独立性/ 和/ 网络/ 灵活性/ ,/ 它/ 的/ 指令集/ 相对/ 简单/ 通用/ ,/ 每/ 一个/ 类/ 编译成/ 一个/ 单独/ 的/ 文件/ ,/ Class/ 文件/ 保留/ 方法/ 变量/ 名称/ 等/ 大量/ 语义/ 信息/ ./ 这些/ 特点/ 都/ 导致/ Java/ 字节/ 码/ 更/ 容易/ 被/ 反编译/ 为/ Java/ 源代码/ ./ 攻击者/ 通过/ 反编译/ 和/ 反汇编/ 技术/ ,/ 获得/ 软件/ 的/ 全部/ 或/ 部分/ 源代码/ ,/ 从而/ 获取/ 关键/ 信息/ 如/ 核心/ 算法/ 、/ 秘密/ 信息/ 等/ 为/ 自己/ 所用/ ./ 目前/ 已图/ 1/ 软件/ 混淆/ 技术/ 应用/ 本文/ 从/ 混淆/ 技术/ 的/ 发展/ 过程/ 角度/ ,/ 对/ 现有/ 的/ 混淆/ 技术/ 进行/ 综述/ ./ 首先/ ,/ 在/ 第/ 2/ 节/ 介绍/ Collberg/ 和/ Thomborson/ 等/ 人/ [/ 2/ ]/ 最早/ 提出/ 的/ 混淆/ 技术/ 的/ 形式化/ 定义/ ;/ 第/ 3/ 节/ 介绍/ 混淆/ 算法/ 的/ 分类/ 、/ 各类/ 算法/ 的/ 原理/ 及其/ 实现/ 方法/ ;/ 第/ 4/ 节/ 介绍/ 针对/ 混淆/ 算法/ 的/ 理论/ 研究/ 以及/ 攻击/ 模式/ ;/ 第/ 5/ 节/ 阐述/ 针对/ 混淆/ 算法/ 的/ 评估/ 度量/ ;/ 最后/ 总结/ 并/ 展望/ 混淆/ 技术/ 的/ 前景/ ./ 2/ 软件/ 混淆/ 技术/ 基本原理/ 软件/ ③/ 混淆/ 技术/ 是/ 在/ 1997/ 年/ 由/ 新西兰/ Auck/ -/ land/ 大学/ 的/ Collberg/ 和/ Thomborson/ 等/ 人/ [/ 2/ ]/ 首先/ 提出/ 的/ ./ 混淆/ 技术/ 属于/ 一种/ 重要/ 的/ 软件保护/ 技术/ ,/ 其本质/ 是/ 利用/ 程序/ 等价/ 变换/ 的/ 方法/ ,/ 将/ 原始/ 程序/ 转变/ 为/ 语义/ 等价/ 、/ 难以/ 被/ 理解/ 或/ 反编译/ 的/ 程序/ ./ 同时/ ,/ 他们/ 还/ 阐述/ 了/ 对于/ 混淆/ 算法/ 的/ 分类/ 及其/ 评估/ 方法/ ,/ 并/ 分别/ 就/ 每/ 一类/ 混淆/ 技术/ 提出/ 了/ 若干/ 算法/ ./ 这些/ 理论/ 及/ 算法/ 对/ 混淆/ 技术/ 的/ 发展/ 起到/ 了/ 提纲挈领/ 的/ 作用/ ./ 在/ Collberg/ 和/ Thomborson/ 提出/ 的/ 理论/ 中/ ,/ 混淆/ 技术/ 可以/ 视为/ 一种/ 高效/ 的/ 程序变换/ 技术/ ,/ 它/ 将/ 原始/ 程序/ P/ 转换成/ 新/ 的/ 程序/ P/ ./ P/ 与/ P/ 相比/ 具有/ 相同/ 的/ 外部/ 行为/ ,/ 并且/ 代码/ 安全/ 性能/ 更强/ ./ 其/ 形式化/ 定义/ 如下/ :/ 设/ T/ 是从/ 原始/ 程序/ P/ 到/ 目标程序/ P/ 的/ 一个/ 变换/ ,/ P/ =/ T/ (/ P/ )/ ./ 如果/ 该/ 变换/ 满足/ 下列/ 条件/ ,/ 就/ 称/ P/ =/ T/ (/ P/ )/ 为/ 一个/ 软件/ 混淆/ 变换/ :/ 有/ 许多/ Java/ 的/ 反编译/ 工具/ ,/ 如/ Jad/ ②/ 、/ Mocha/ [/ 1/ ]/ 等/ ,/ 都/ 是/ 常用/ 的/ 针对/ Java/ 字节/ 码/ 文件/ 的/ 反编译器/ ./ 因此/ ,/ 防止/ 针对/ Java/ 字节/ 码/ 文件/ 的/ 静态/ 分析/ 和/ 反编译/ 攻击/ 的/ 要求/ ,/ 显得/ 更加/ 迫切/ ./ 混淆/ 技术/ 可以/ 被/ 理解/ 成为/ 是/ 一种/ 特殊/ 的/ 编码/ 技术/ ,/ 目前/ 被/ 广泛/ 地/ 应用/ 于/ 软件/ 知识产权/ 保护/ 领域/ ./ 通常/ 所说/ 的/ 混淆/ 是/ 指/ 对/ 拟/ 发布/ 的/ 应用程序/ 进行/ 保持/ 语义/ 的/ 混淆/ 变换/ ,/ 使得/ 变换/ 后/ 的/ 程序/ 和/ 原来/ 的/ 程序/ 在/ 功能/ 上/ 相同/ 或/ 相近/ ,/ 但是/ 更/ 难以/ 被/ 静态/ 分析/ 和/ 逆向/ 工程/ 所/ 攻击/ ,/ 如图/ 1/ 所示/ ./ 可/ 结束/ 也/ 可不/ 结束/ ;/ 相同/ 的/ 输出/ 结果/ ;/ 的/ 运行/ 时间/ 在/ 一个/ 有限/ 的/ 范围/ 内/ ;/ ①/ 若/ P/ 无法/ 结束/ 或者/ 以/ 错误/ 的/ 状态/ 结束/ ,/ 则/ P/ ②/ 若/ P/ 结束/ ,/ 则/ P/ 也/ 必须/ 结束/ 并且/ 产生/ 和/ P/ ③/ 对于/ 完成/ 某/ 特定/ 的/ 计算/ 任务/ ,/ P/ 比/ P/ 多/ 消耗/ ④/ 攻击者/ 将/ P/ 恢复/ 为/ P/ 所/ 耗费/ 的/ 时间/ 大于/ 将/ P/ 转换/ 至/ P/ 的/ 时间/ ./ 其中/ ,/ P/ 为/ 未经/ 混淆/ 的/ 程序/ ,/ 即/ 原始/ 程序/ ,/ 而/ P/ 为/ 混淆/ 后/ 的/ 程序/ ./ 对于/ 任意/ 的/ 合法/ 输入/ ,/ P/ 与/ P/ 输出/ 相同/ 的/ 处理结果/ ,/ 即/ 满足/ 程序/ 语义/ 等价/ 性/ ./ 3/ 软件/ 混淆/ 技术/ 的/ 分类/ Java/ 文件/ 经过/ 编译/ 生成/ 类/ 文件/ ./ 类/ 文件/ 分为/ 不同/ 的/ 字/ 段/ ,/ 包括/ 魔数/ (/ magic/ )/ 、/ 版本/ (/ version/ )/ 、/ 常量/ 池/ (/ constantpool/ )/ 、/ 访问/ 标识/ (/ accessflags/ )/ 、/ (/ this/ )/ 类/ 、/ (/ super/ )/ 类/ 、/ 接口/ (/ interfaces/ )/ 、/ 域/ (/ fields/ )/ 、/ 方法/ (/ methods/ )/ 和/ 属性/ (/ attributes/ )/ ./ 根据/ 混淆/ 算法/ 针对/ 的/ 对象/ 不同/ ,/ 可以/ 将/ 混淆/ 分为/ 类内/ 混淆/ 和/ 类间/ 混淆/ ./ 类内/ 混淆/ 指/ 混淆/ 的/ 作用/ 范围/ 在/ 某个/ 类/ 文件/ 内部/ ,/ 基于/ 字节/ 码/ 的/ 类/ 内/ 混淆/ 作用/ 对象/ 主要/ 是/ 上述/ 类/ ①/ ②/ ③/ Page3/ 文件/ 结构/ 方法/ (/ methods/ )/ 中/ 的/ code/ 字段/ ./ 类间/ 混淆/ 指/ 混淆/ 作用/ 于/ 两个/ 或者/ 两个/ 以上/ 的/ 类/ 文件/ ,/ 实现/ 的/ 方式/ 主要/ 包括/ 类/ 合并/ 以及/ 类/ 拆分/ 等/ ./ 3.1/ 类内/ 混淆/ 类内/ 混淆/ 实现/ 的/ 方式/ 主要/ 包括/ 数据/ 混淆/ 、/ 控制流/ 混淆/ 、/ 切片/ 混淆/ 和/ 针对/ 特定/ 工具/ 的/ 混淆/ ./ 3.1/ ./ 1/ 数据/ 混淆/ 数据/ 混淆/ 的/ 原理/ 是/ 通过/ 对/ 常量/ 、/ 变量/ 和/ 数据结构/ 这些/ 程序/ 的/ 基本/ 组成/ 元素/ 进行/ 修改/ 的/ 方式/ ,/ 增大/ 攻击者/ 进行/ 逆向/ 工程/ 的/ 难度/ ./ 数据/ 混淆/ 包括/ :/ 变量/ 存储/ 和/ 编码/ 混淆/ 、/ 变量/ 聚合/ 混淆/ 、/ 顺序/ 调整/ 混淆/ 、/ 词法/ 混淆/ 以及/ 移除/ 注释/ 和/ 调试信息/ 混淆/ ./ 3.1/ ./ 1.1/ 变量/ 存储/ 和/ 编码/ 混淆/ (/ 1/ )/ 分裂/ 变量/ 混淆/ 分裂/ 变量/ 混淆/ [/ 2/ -/ 3/ ]/ 将/ 较为简单/ 的/ 数据结构/ 或/ 数据类型/ (/ 例如/ int/ 、/ boolean/ 等/ )/ 分解/ 为/ 一些/ 变量/ 的/ 组合/ ,/ 从而/ 达到/ 隐藏/ 原始数据/ 的/ 效果/ ./ (/ 2/ )/ 将/ 静态数据/ 转换/ 为/ 与/ 程序/ 相关/ 的/ 数据/ 以/ 一个/ 静态/ 的/ 字符串/ 为例/ ,/ 可以/ 通过/ 混淆/ 变换/ 将/ 其/ 转化/ 为/ 一个/ 函数/ 或/ 一段/ 子程序/ ,/ 从而/ 在/ 程序执行/ 的/ 过程/ 中/ 通过/ 调用/ 生成/ 相应/ 的/ 字符串/ [/ 2/ ]/ ./ 这种/ 变换/ 的/ 实现/ 并/ 不/ 困难/ ,/ 但/ 应用/ 时/ 需要/ 考虑/ 以下/ 这/ 对/ 矛盾/ 的/ 制约/ 因素/ :/ ①/ 在/ 常见/ 的/ 应用程序/ 中/ 都/ 包含/ 大量/ 的/ 静态数据/ ,/ 如果/ 对/ 所有/ 的/ 静态数据/ 都/ 进行/ 混淆/ ,/ 将/ 导致/ 代码/ 的/ 执行/ 代价/ 和/ 传输/ 代价/ 显著/ 增加/ ;/ ②/ 如果/ 仅/ 对/ 关键/ 的/ 静态数据/ 进行/ 混淆/ ,/ 则/ 为/ 反/ 混淆/ 者/ 寻找/ 关键/ 数据/ 提供/ 明显/ 的/ 提示/ ./ 所以/ ,/ 如何/ 把握/ ①/ 和/ ②/ 的/ 平衡点/ ,/ 是/ 需要/ 在实践中/ 解决/ 的/ 问题/ ./ (/ 3/ )/ 改变/ 编码方式/ 混淆/ 和/ 改变/ 变量/ 生命周期/ 混淆/ 改变/ 编码方式/ 混淆/ 隐藏/ 了/ 真实/ 的/ 数据/ ,/ 使/ 原程序/ 更加/ 复杂/ [/ 2/ ]/ ./ 下面/ 是/ 一个/ 改变/ 编码方式/ 混淆/ 的/ 例子/ :/ 用/ 表达式/ i/ =/ c/ ×/ i/ +/ u/ 替代/ 整型/ 变量/ i/ ,/ 其中/ c/ 和/ u/ 为/ 整型/ 常数/ ./ 原程序/ :/ inti/ =/ 1/ ;/ while/ (/ i/ </ 1000/ )/ {/ …/ A/ [/ i/ ]/ …/ i/ ++/ }/ ./ 混淆/ 后/ 的/ 程序/ :/ inti/ =/ 11/ ;/ while/ (/ i/ </ 8003/ )/ {/ …/ A/ [/ (/ i/ -/ 3/ )/ // 8/ ]/ …/ i/ =/ i/ +/ 8/ }/ ./ 此外/ ,/ 也/ 可以/ 把/ 局部变量/ 改变/ 为/ 全局变量/ ,/ 从而/ 改变/ 变量/ 的/ 生命周期/ ./ (/ 4/ )/ 变量/ 替换/ 改变/ 变量/ 的/ 类型/ ,/ 例如/ 将/ 一个/ 整型/ 变量/ 更/ 改为/ 一个/ 整型/ 对象/ ./ 这种/ 操作/ 的/ 目的/ 在于/ ,/ 利用/ Java/ 的/ 自动/ 回收/ 垃圾/ 机制/ 及时/ 清理/ 一些/ 变量/ 的/ 使用/ 信息/ ,/ 从而/ 增大/ 逆向/ 工程/ 的/ 难度/ [/ 2/ ]/ ./ 3.1/ ./ 1.2/ 变量/ 聚合/ 混淆/ (/ 1/ )/ 合并/ 变量/ 混淆/ 合并/ 变量/ 混淆/ 算法/ 的/ 原理/ 是/ :/ 在/ 保持/ 程序/ 语义/ 等价/ 的/ 前提/ 下/ ,/ 将/ 两个/ 或/ 两个/ 以上/ 的/ 数值/ 变量/ V1/ ,/ V2/ ,/ …/ ,/ Vn/ 合并/ 为/ 一个/ 变量/ Vm/ 整型/ 变量/ 可/ 被/ 合并/ 为/ 一个/ 64/ 位/ 整型/ 变量/ ./ 为了/ 增加/ 混淆/ 变换/ 的/ 弹性/ ,/ 可以/ 考虑/ 在/ 程序/ 中/ 添加/ 不/ 影响/ 原始/ 变量值/ 的/ 伪/ 操作/ ./ (/ 2/ )/ 数组/ 重构/ 混淆/ 数组/ 重构/ 混淆/ 有/ 多种/ 实现/ 方式/ ,/ 主要/ 包括/ 数组/ 分裂/ 变换/ (/ 将/ 一个/ 数组/ 拆/ 分为/ 两个/ 子/ 数组/ )/ 、/ 数组/ 合并/ 变换/ 、/ 数组/ 折叠/ 变换/ 和/ 数组/ 辗平/ 变换/ [/ 2/ ]/ ./ 为了/ 获得/ 更好/ 的/ 效果/ ,/ 可以/ 将/ 某些/ 上述/ 变换/ 组合/ 使用/ ./ 3.1/ ./ 1.3/ 顺序/ 调整/ 混淆/ 程序员/ 在/ 进行/ 程序设计/ 时/ ,/ 通常/ 会/ 把/ 逻辑/ 上/ 相关/ 的/ 数据/ 放在/ 物理/ 上/ 相邻/ 的/ 位置/ ./ 因此/ 可以/ 通过/ 顺序/ 调整/ 把/ 逻辑/ 上/ 相关/ 的/ 数据/ 分散/ 在/ 物理/ 上/ 不/ 相邻/ 的/ 位置/ ,/ 从而/ 增大/ 攻击者/ 分析程序/ 的/ 难度/ ./ 顺序/ 调整/ 混淆/ 主要/ 有/ 重新/ 调整/ 实例/ 变量/ 顺序/ 混淆/ 、/ 重新/ 调整/ 方法/ 顺序/ 混淆/ 、/ 重新/ 调整/ 数组/ 顺序/ 混淆/ [/ 2/ ]/ ./ 3.1/ ./ 1.4/ 词法/ 混淆/ 词法/ 混淆/ 的/ 原理/ 是/ 通过/ 对/ 函数/ 和/ 变量/ 的/ 名称/ 进行/ 扰乱/ ,/ 使/ 其/ 违背/ 见名/ 知义/ 的/ 软件工程/ 原则/ [/ 4/ ]/ ./ 这类/ 混淆/ 变换/ 大多/ 针对/ Java/ 语言/ 设计/ ,/ 其/ 原理/ 是/ 依照/ Java/ 虚拟机/ 规范/ (/ TheJavaVirtualMachineSpeci/ -/ fication/ )/ 中/ 有关/ 类/ 文件/ 结构/ 的/ 规定/ ,/ 对/ 常量/ 池中/ 存储/ 类/ 、/ 域/ 、/ 方法/ 和/ 变量/ 名字/ 的/ “/ CONSTANT/ -/ Utf8/ -/ info/ ”/ 类型/ 数据项/ 加以/ 混淆/ ./ 词法/ 变换/ 混淆/ 具有/ 单向/ 的/ 性质/ ,/ 且/ 无/ 额外/ 的/ 执行/ 代价/ ,/ 在/ 保护/ 知识产权/ 的/ 实践/ 中/ 得到/ 了/ 广泛/ 的/ 应用/ ./ 目前/ 的/ Java/ 字节/ 码/ 混淆/ 器/ 和/ 混淆/ 编译器/ 大多/ 支持/ 这一/ 功能/ ,/ 可见/ 词法/ 变换/ 具有/ 良好/ 的/ 可行性/ ./ 为了/ 提高/ 混淆/ 算法/ 的/ 隐蔽性/ ,/ DeAR/ 和/ VanLO/ [/ 5/ ]/ 提出/ 了/ 使用/ 标识符/ 交换/ 来/ 进行/ 词法/ 变换/ 的/ 方法/ ,/ 其/ 思想/ 是/ 将/ 标识符/ 作/ 交换/ ,/ 而/ 不是/ 将/ 其/ 更/ 改成/ 毫无意义/ 的/ 名字/ ./ 标识符/ 交换/ 包括/ 交换/ 变量名/ 、/ 交换/ 函数/ 名/ 和/ 交换/ 类名/ 3/ 个/ 步骤/ ./ 使用/ 标识符/ 交换/ 进行/ 词法/ 变换/ 提高/ 了/ 算法/ 的/ 隐蔽性/ ,/ 同时/ 也/ 保留/ 了/ 标识符/ ,/ 这/ 使得/ 该/ 混淆/ 算法/ 不再/ 具有/ 单向性/ ,/ 为/ 反/ 混淆/ 提供/ 了/ 可能性/ ./ Chan/ 等/ 人/ [/ 4/ ]/ 在/ 2002/ 年/ 提出/ 了/ 一种/ 具体/ 的/ 基于/ 修改/ 和/ 重用/ 标识符/ 的/ 词法/ 混淆/ 算法/ ./ 其/ 基本/ 的/ 思想/ 是/ 尽可能/ 多地/ 对/ 标识符/ 进行/ 重用/ ,/ 通过/ 对/ 标识符/ 的/ 多次重/ 用来/ 迷惑/ 攻击者/ ./ 此外/ ,/ 这种/ 算法/ 将/ 复杂/ 的/ 标识符/ 用/ 简单/ 的/ 标识符/ 代替/ ,/ 因此/ 具有/ 减小/ 字节/ 码/ 文件/ 体/ Page4/ 积/ 的/ 作用/ ./ 3.1/ ./ 1.5/ 移除/ 注释/ 和/ 调试信息/ 混淆/ 程序/ 的/ 注释/ 和/ 调试信息/ 在/ 一定/ 程度/ 上/ 为/ 攻击者/ 理解/ 程序/ 语义/ 提供/ 了/ 便利/ ,/ 去除/ 此类/ 信息/ 可以/ 有效/ 阻碍/ 攻击者/ 对/ 程序/ 的/ 理解/ ./ 移除/ 注释/ 和/ 调试信息/ 混淆/ 的/ 主要/ 实现/ 方法/ 是/ 去除/ 注释/ 和/ 调试信息/ 等/ 源代码/ 格式化/ 信息/ ,/ 以及/ 将/ 原有/ 标识符/ 替换/ 为/ 无/ 意义/ 的/ 标识符/ ./ 这是/ 一种/ 单向/ 的/ 变换/ ,/ 源文件/ 在/ 经过/ 混淆/ 之后/ 无法/ 恢复/ [/ 3/ ]/ ./ 该/ 混淆/ 方法/ 操作/ 简单/ ,/ 但是/ 强度/ 较差/ ,/ 因为/ 移除/ 的/ 调试信息/ 量/ 较/ 小/ ./ 这种/ 移除/ 信息/ 的/ 混淆/ 方法/ 对/ 程序运行/ 的/ 时间/ 和/ 空间/ 复杂度/ 几乎/ 没有/ 影响/ [/ 2/ ]/ ./ 混淆/ 器/ Crema/ ①/ 是/ 一个/ 典型/ 的/ 应用/ 实例/ ./ 3.1/ ./ 2/ 控制流/ 混淆/ 程序/ 的/ 控制/ 转换/ 过程/ 的/ 信息/ 是/ 追踪/ 定位/ 程序/ 状态/ 的/ 重要/ 线索/ ,/ 如何/ 保护/ 这部分/ 信息/ 也/ 是/ 软件保护/ 中/ 很/ 重要/ 的/ 一个/ 环节/ ./ 控制流/ 图/ (/ ControlFlowGraph/ ,/ CFG/ )/ 是/ 程序/ 可能/ 执行/ 流程/ 的/ 图形化/ 表示/ ,/ 它/ 可以/ 用来/ 描述/ 程序/ 的/ 控制/ 转换/ ./ 一个/ 程序/ 可以/ 被/ 分成/ 由/ 一系列/ 无/ 分支/ 的/ 代码/ 组成/ 的/ 基本/ 代码/ 块/ ,/ 这些/ 基本块/ 作为/ 控制流/ 图/ 的/ 结点/ ,/ 而图/ 的/ 边/ 即/ 为/ 各个/ 基本块/ 之间/ 可能/ 的/ 跳转/ 关系/ ./ 控制流/ 混淆/ 的/ 目的/ 就是/ 改变/ 或/ 复杂化/ 程序/ 的/ 控制流/ ,/ 使/ 程序/ 更/ 难以/ 破译/ ./ 控制/ 混淆/ 可/ 采用/ 的/ 手段/ 很多/ ,/ 比如/ 应用/ 不/ 透明/ 谓词/ 增加/ 伪造/ 分支/ 、/ 加入/ 可/ 导致/ 反编译/ 错误/ 的/ 指令/ (/ 例如/ 在/ Java/ 字节/ 码中/ 添加/ goto/ 语句/ 等/ )/ 、/ 将/ 一段/ 代码/ 转换/ 为/ 内联/ 函数调用/ 等/ [/ 2/ ]/ ./ 3.1/ ./ 2.1/ 控制/ 计算/ 混淆/ (/ 1/ )/ 通过/ 不/ 透明/ 谓词/ 加入/ 不会/ 被/ 执行/ 的/ 分支/ 语句/ 对于/ 一串/ 语句/ S/ ,/ 利用/ 不/ 透明/ 谓词/ 可以/ 构造/ 出/ 两种/ 变换/ [/ 6/ ]/ ./ 第/ 1/ 种/ 是/ 增加/ 恒真/ 或/ 恒假/ 的/ 不/ 透明/ 谓词/ ,/ 构造/ 出/ 一条/ 不会/ 被/ 执行/ 的/ 分支/ ,/ 该/ 分支/ 上/ 可以/ 没有/ 语句/ ,/ 也/ 可以/ 有/ 和/ S/ 不同/ 的/ 语句/ ;/ 第/ 2/ 种/ 是/ 利用/ 时为/ 真时/ 为/ 假/ 的/ 不/ 透明/ 谓词/ ,/ 令/ 它/ 的/ 两个/ 分支/ 上/ 的/ 语句/ 都/ 与/ 原/ 语句/ S/ 相同/ ./ 其中/ 第/ 2/ 种/ 混淆/ 变换/ 能够/ 较/ 好/ 地/ 抵抗/ 动态分析/ ./ (/ 2/ )/ 循环/ 条件/ 插入/ 变换/ 通过/ 不/ 透明/ 谓词/ 使/ 一个/ 循环/ 的/ 终止/ 条件/ 变得/ 更为/ 复杂/ ,/ 可以/ 达到/ 对/ 循环/ 进行/ 混淆/ 的/ 目的/ [/ 2/ ]/ ./ 两种/ 可能/ 的/ 变换/ 原理/ 如图/ 2/ 所示/ ./ 其中/ f/ 和/ g/ 是/ 判断/ 谓词/ k/ ,/ j/ 的/ 表达式/ ./ (/ 3/ )/ 将/ 可/ 化简/ 的/ 控制流/ 转换/ 为/ 不可/ 化简/ 的/ 控制流/ 通过/ 将/ 一个/ 结构化/ 的/ 循环/ 变换/ 为/ 含有/ 多个/ 入口/ 的/ 循环/ ,/ 可以/ 将/ 可/ 化简/ 的/ 控制流/ 转换/ 为/ 不可/ 化简/ 的/ 控制流/ [/ 2/ ]/ ./ 其/ 原理/ 如图/ 3/ 所示/ ,/ 主要/ 是/ 利用/ 不/ 透明/ 谓词/ 加入/ 的/ 假/ 分支/ ,/ 生成/ 循环/ 交叉/ ,/ 从而/ 使/ 控制流/ 图/ 难以/ 被/ 反编译/ ./ 图/ 3/ 可/ 化简/ 的/ 控制流/ 图/ 转换/ 为/ 不可/ 化简/ 的/ 控制流/ 图/ 示意/ (/ 4/ )/ 并行/ 化/ 代码/ 并行/ 化/ 代码/ 是/ 编译器/ 优化/ 程序/ 性能/ 的/ 重要/ 方法/ 之一/ [/ 2/ ]/ ./ 这一/ 技术/ 可以/ 用于/ 混淆/ 程序控制/ 流/ ,/ 从而/ 增大/ 攻击者/ 理解/ 程序/ 的/ 难度/ ./ 具体/ 地/ ,/ 有/ 两种/ 实现/ 方式/ :/ ①/ 在/ 程序/ 中/ 添加/ 伪造/ 的/ 进程/ 代码/ (/ dummyprocess/ )/ ;/ ②/ 将/ 一组/ 串行/ 程序/ 并行/ 化/ ./ 使用/ 并行/ 化/ 代码/ 算法/ ,/ 需要/ 注意/ 代码/ 中/ 的/ 数据/ 依赖/ 关系/ ,/ 否则/ 可能/ 破坏/ 程序/ 的/ 语义/ 等价/ 性/ ./ 3.1/ ./ 2.2/ 控制/ 聚合/ 混淆/ 通过/ 方法/ 内联/ 变换/ 和/ 将/ 某些/ 代码/ 片段/ 转换/ 成为/ ①/ VanVH/ ./ Crema/ -/ TheJavaobfuscator/ ./ http/ :/ // // web/ ./ inter/ ./ Page5/ 子程序/ ,/ 可以/ 改变程序/ 自身/ 的/ 控制流/ 图/ ./ 这种/ 混淆/ 方法/ 是/ 单向/ 的/ ,/ 具有/ 较/ 好/ 的/ 鲁棒性/ [/ 2/ ]/ ./ (/ 1/ )/ 方法/ 交叉/ 调用/ 和/ 方法/ 克隆/ 其/ 主要/ 思想/ 如图/ 4/ 所示/ ,/ 合并/ 两个/ 调用/ 方法/ 的/ 参数/ 列表/ 和/ 主体/ ,/ 并/ 增加/ 一个/ 参数/ 或/ 全局变量/ (/ 图/ 4/ 中/ 的/ intV/ )/ ,/ 用以/ 声明/ 执行/ 时/ 具体/ 应当/ 调用/ 哪/ 一个/ 方法/ ./ 方法/ 克隆/ 的/ 目的/ 是/ 混淆/ 程序/ 的/ 方法/ 调用/ 关系/ ,/ 克隆/ 的/ 方法/ 应/ 与/ 原/ 方法/ 看似/ 区别/ 但/ 又/ 具有/ 相同/ 的/ 语义/ [/ 2/ ]/ ./ 图/ 4/ 方法/ 交叉/ 调用/ 对于/ 控制/ 混淆/ 如何/ 抵抗/ 自动化/ 分析/ 工具/ 的/ 攻击/ ,/ 也/ 有/ 不少/ 研究/ ./ Wang/ [/ 7/ ]/ 提出/ 了/ 通过/ 更改/ 跳转/ 指令/ 实现/ 控制/ 混淆/ 的/ 一种/ 方法/ ,/ 使得/ 编译/ 时候/ 每/ 一个/ 跳转/ 指令/ 的/ 目标/ 都/ 是/ 未知/ 的/ ./ Chow/ 等/ 人/ [/ 8/ ]/ 提出/ 了/ 一种/ 相似/ 的/ 方法/ ,/ 通过/ 一个/ 有限/ 状态/ 自动机/ 来/ 控制程序/ 的/ 跳转/ 语句/ ./ 根据/ 以上/ 的/ 控制/ 混淆/ 算法/ 理论/ ,/ Low/ [/ 9/ ]/ 在/ 1998/ 年/ 提出/ 了/ 针对/ Java/ 代码/ 的/ 控制/ 混淆/ 算法/ 实现/ ./ 对于/ 不/ 透明/ 谓词/ 的/ 设计/ ,/ Majumdar/ 等/ 人/ [/ 6/ ]/ 在/ 2006/ 年/ 为/ 分布式系统/ 的/ 混淆/ 补充/ 了/ 一种/ 分布式/ 不/ 透明/ 谓词/ ./ 应用/ 该/ 不/ 透明/ 谓词/ 可以/ 有效/ 地/ 抵抗/ 多种/ 自动/ 静态/ 分析/ 的/ 攻击/ ./ 3.1/ ./ 3/ 切片/ 混淆/ 切片/ 通常/ 是/ 用来/ 帮助/ 理解/ 程序/ 的/ ,/ 而/ 混淆/ 的/ 目的/ 是/ 使/ 程序/ 更/ 难以/ 被/ 理解/ ./ Drape/ 等/ 人/ [/ 10/ -/ 11/ ]/ 提出/ 了/ 切片/ 混淆/ 算法/ ,/ 使得/ 混淆/ 过/ 的/ 程序/ 能够/ 更好/ 地/ 对抗/ 切片/ 分析攻击/ ./ 定义/ Slice/ (/ P/ ,/ S/ ,/ V/ )/ 用来/ 标记/ 程序/ P/ 在/ 状态/ S/ 时/ ,/ 对应/ 的/ 变量/ 集/ V/ 的/ 一个/ 后/ 向/ 切片/ (/ backwardsslice/ )/ ,/ 指令/ out/ 表明/ V/ 中/ 变量/ 的/ 输出/ ./ 图/ 5/ 中/ 显示/ 了/ 一个/ 包含/ 有/ 变量/ i/ ,/ x/ ,/ y/ 的/ 程序/ ,/ 当/ 输出/ 为/ y/ 时/ 的/ 程序/ 切片/ :/ 黑体/ 部分/ 为/ 切片/ 时/ 可/ 观测/ 到/ 的/ 变量值/ ./ 此时/ 变量/ x/ 不/ 在/ 观测/ 范围/ 内/ ./ 切片/ 混淆/ (/ slicingobfuscation/ )/ 算法/ 的/ 主要/ 思想/ 就是/ 尽可能/ 多地/ 将/ 多个/ 变量/ 的/ 值/ 放入/ 到/ 切片/ 的/ 观察/ 范围/ 之内/ ,/ 增加/ 使用/ 切片/ 分析程序/ 的/ 攻击者/ 的/ 困难/ (/ 2/ )/ 循环/ 变换/ 循环/ 变换/ 可以/ 采用/ 循环/ 模块化/ (/ 将/ 循环/ 区间/ 划分/ 为/ 多个/ 模块/ )/ 、/ 循环展开/ (/ 拓宽/ 循环/ 的/ 步频/ )/ 和/ 循环/ 切割/ (/ 将/ 一个/ 循环/ 转换/ 为/ 多个/ 循环/ )/ 等/ 方法/ 实现/ ./ 3.1/ ./ 2.3/ 控制/ 顺序/ 混淆/ 控制/ 顺序/ 混淆/ 的/ 实现/ 原理/ 为/ :/ 随机/ 打乱/ 表达式/ 、/ 基本块/ 、/ 方法/ 和/ 类/ 的/ 顺序/ ,/ 使/ 攻击者/ 难以/ 理解/ 程序/ 的/ 正确/ 意图/ ./ 使用/ 该/ 方法/ 要/ 注意/ 一些/ 有/ 依赖/ 关系/ 的/ 数据/ 在/ 重新/ 排序/ 之后/ 是否/ 合法/ ./ 程度/ [/ 11/ ]/ ./ 切片/ 混淆/ 的/ 主要/ 方法/ 有/ :/ 增加/ 恒假/ 谓词/ 、/ 变量/ 编码/ 和/ 增加/ 循环/ 变量/ ./ 增加/ 恒假/ 谓词/ 是/ 在/ 恒假/ 谓词/ 的/ 假/ 分支/ 上/ 增加/ 令/ x/ 与/ y/ 相关/ 的/ 函数/ ;/ 变量/ 编码/ 是/ 在/ 不/ 改变/ 语义/ 的/ 情况/ 下/ 将/ y/ 的/ 表达式/ 重新/ 编码/ 为/ 与/ x/ 相关/ 的/ 表达式/ ;/ 增加/ 循环/ 变量/ 是/ 在/ 循环/ 变量/ 中/ 添加/ 与/ x/ ,/ y/ 相关/ 的/ 变量/ ./ 图/ 6/ 至图/ 8/ 分别/ 描述/ 了/ 这/ 几种/ 方法/ 的/ 实现/ ./ intbogus/ (/ intn/ )/ {/ inti/ =/ 0/ ;/ intx/ =/ 0/ ;/ inty/ =/ 1/ ;/ while/ (/ i/ </ n/ )/ {/ i/ ++/ ;/ if/ (/ i/ </ 5/ |/ |/ x/ </ y/ )/ x/ =/ x/ +/ i/ ;/ elsey/ =/ x/ / i/ ;/ y/ =/ y/ / i/ ;/ }/ out/ (/ x/ )/ ;/ out/ (/ y/ )/ ;/ }/ 图/ 6/ 增加/ 伪造/ 分支/ Page6Majumdar/ 等/ 人/ [/ 12/ ]/ 从/ 单词/ 计量/ 、/ 结果/ 求和/ 、/ 定位/ 时间/ 等/ 角度/ 验证/ 了/ 切片/ 混淆/ 的/ 方法/ 能够/ 增强/ 程序/ 抵抗/ 切片/ 分析攻击/ 的/ 能力/ ./ 3.1/ ./ 4/ 针对/ 特定/ 工具/ 的/ 混淆/ 针对/ 特定/ 工具/ 的/ 混淆/ 是/ 针对/ 自动化/ 的/ 反编译/ 和/ 反/ 混淆/ 工具/ 提出/ 的/ 混淆/ 方法/ ,/ 旨在/ 阻止/ 这/ 类/ 自动化/ 工具/ 的/ 使用/ ,/ 或者/ 增加/ 其/ 使用/ 难度/ 和/ 代价/ [/ 2/ ]/ ./ 该类/ 混淆/ 方法/ 与/ 前面/ 提到/ 的/ 3/ 种类/ 别的/ 混淆/ ,/ 最大/ 的/ 不同之处/ 在于/ ,/ 前/ 3/ 种/ 混淆/ 技术/ 主要/ 是/ 针对/ 程序/ 的/ 阅读者/ ,/ 即/ 针对/ 的/ 是/ 人/ ;/ 而/ 后者/ 针对/ 的/ 是/ 自动化/ 的/ 反/ 混淆/ 以及/ 反编译/ 工具/ ./ 针对/ 特定/ 工具/ 的/ 混淆/ 可以/ 通过/ 与/ 其他/ 的/ 混淆/ 技术/ 综合/ 使用/ 从而/ 达到/ 更好/ 的/ 鲁棒性/ [/ 2/ ]/ ./ 在/ 实际操作/ 中/ ,/ 可以/ 在/ 循环体/ 内部/ 加上/ 伪造/ 的/ 无用/ 变量/ ,/ 形成/ 数据/ 依赖/ ,/ 增加/ 反/ 混淆/ 的/ 自动/ 工具/ 分析/ 难度/ ./ 例如/ 在/ 程序/ 的/ 某处/ 使用/ 了/ 反向/ 循环/ 的/ 混淆/ ,/ 为了/ 防止/ 这一/ 变换/ 被/ 反编译器/ 分析/ 破解/ ,/ 可以/ 采用/ 图/ 9/ 所示/ 方法/ :/ 在/ 这个/ 例子/ 中/ ,/ 增加/ 了/ B/ 数组/ ,/ for/ 循环/ 的/ 前后/ 向/ 顺序/ 会/ 对/ B/ 数组/ 的/ 各个/ 元素/ 产生/ 影响/ ,/ 从而/ 形成/ 数据/ 依赖/ ,/ 阻止/ 反编译器/ 变换/ 循环/ 的/ 方向/ ./ 这一/ 混淆/ 方法/ 的/ 弹性/ ,/ 取决于/ 添加/ 伪造/ 数据/ 的/ 复杂度/ ./ For/ (/ i/ =/ 0/ ;/ i/ </ =/ 10/ ;/ i/ ++/ )/ {/ A/ [/ i/ ]/ =/ i/ ;/ }/ 例如/ ,/ 针对/ Mocha/ [/ 1/ ]/ 这一/ 反编译/ 工具/ ,/ 我们/ 可以/ 采用/ 这样/ 的/ 措施/ 造成/ 它/ 反编译/ 失败/ :/ 在/ 每个/ 方法/ 的/ 每/ 一条/ 返回/ 语句/ 之后/ 增加/ 额外/ 的/ 指令/ ./ 在/ 不/ 影响/ 程序/ 行为/ 的/ 前提/ 下/ ,/ 造成/ Mocha/ 的/ 崩溃/ ./ Batchelder/ 等/ 人/ [/ 13/ ]/ 在/ 2007/ 年/ 较为/ 详细/ 地/ 阐述/ 了/ 如何/ 利用/ Java/ 字节/ 码/ 与/ Java/ 源代码/ 之间/ 指令/ 规范/ 的/ 不同/ ,/ 在/ 字节/ 码/ 的/ 级别/ 进行/ 可以/ 导致/ 反编译/ 失败/ 的/ 控制流/ 混淆/ ./ 例如/ 利用/ jsr/ -/ ret/ 指令/ 取代/ 普通/ 的/ if/ -/ goto/ ;/ 针对/ 模式匹配/ 的/ 反编译器/ ,/ 将/ load/ 指令/ 提到/ if/ 指令/ 之前/ ;/ 在/ 子类/ 构造函数/ 中/ 对/ 父类/ 的/ 调用/ 进行/ 外/ 包/ 等等/ ./ 3.2/ 类间/ 混淆/ Sosonkin/ 等/ 人/ [/ 3/ ]/ 在/ 2003/ 年/ 提出/ 了/ 3/ 种/ 分别/ 基于/ 类/ 的/ 合并/ 、/ 类/ 的/ 拆分/ 以及/ 类型/ 隐藏/ 的/ 类间/ 混淆/ 算法/ ./ 3.2/ ./ 1/ 类/ 合并/ 类/ 合并/ 算法/ 的/ 主要/ 思想/ 是/ 合并/ 两个/ 或/ 多个/ 类/ 各自/ 包含/ 的/ 变量/ 和/ 函数/ ,/ 根据/ 需要/ 重命名/ 变量/ 或/ 函数/ 标识符/ [/ 3/ ]/ ./ 若待/ 合并/ 的/ 类/ 中/ 有/ 标识符/ 相同/ 的/ 变量/ 或非/ 构造函数/ ,/ 则/ 将/ 其/ 改为/ 不/ 重复/ 的/ 新/ 标识符/ ;/ 若待/ 合并/ 的/ 类/ 中/ 有/ 标识符/ 及/ 参数/ 都/ 相同/ 的/ 构造函数/ ,/ 无法/ 随意/ 更改/ 标识符/ ,/ 则/ 合并/ 后/ 为/ 其中/ 一个/ 增加/ 伪造/ 的/ 参数/ ;/ 若待/ 合并/ 的/ 两个/ 类/ 之间/ 有/ 继承/ 关系/ ,/ 则/ 合并/ 后/ 增加/ 一个/ 布尔/ 型/ 的/ 私有/ 变量/ 用于/ 区分/ 标识符/ 相同/ 的/ 函数/ ,/ 图/ 10/ 是/ 类/ 合并/ 的/ 一个/ 例子/ ./ Originalclasses/ :/ classA/ {/ privateinti/ ;/ publicA/ (/ )/ {/ i/ =/ 5/ ;/ }/ publicbooleanm/ (/ )/ {/ returni/ </ 0/ ;/ }/ }/ classBextendsA/ {/ publicB/ (/ )/ {/ super/ (/ )/ ;/ i/ =/ 10/ ;/ }/ publicbooleanm/ (/ )/ {/ returni/ </ 10/ ;/ }/ }/ classC/ {/ voidn/ (/ )/ {/ Aa/ ;/ if/ (/ …/ )/ {/ a/ =/ newA/ (/ )/ ;/ }/ else/ {/ a/ =/ newB/ (/ )/ ;/ }/ a/ / m/ (/ )/ ;/ }/ }/ 3.2/ ./ 2/ 类/ 拆/ 分类/ 的/ 拆分/ 算法/ 首先/ 分析判断/ 待/ 拆分/ 的/ 类/ 内部/ 的/ 继承/ 和/ 方法/ 调用/ 关系/ [/ 14/ ]/ ,/ 观察/ 它们/ 是否/ 能够/ 进行/ 拆/ Page7/ 分/ ./ 对于/ 可/ 拆分/ 的/ 类/ ,/ 主要/ 方法/ 是/ 将/ 一个/ 类/ C/ 拆/ 分为/ C1/ ,/ C2/ 两个/ 类/ ,/ 且/ C2/ 是/ C1/ 的/ 子类/ ,/ 并/ 确保/ C/ 中/ 的/ 每个/ 方法/ 和/ 变量/ ,/ 在/ C2/ 中均/ 包含/ 或/ 由/ C1/ 继承/ ,/ 图/ 11/ 是/ 类/ 拆分/ 的/ 一个/ 例子/ [/ 3/ ]/ ./ Originalclasses/ :/ classC/ {/ privateinti/ ;/ privatedoubled/ ;/ protectedObjecto/ ;/ publicC/ (/ )/ {/ i/ =/ 5/ ;/ d/ =/ 1.0/ ;/ o/ =/ newObject/ (/ )/ ;/ }/ publicC/ (/ intiarg/ ,/ doubledarg/ )/ {/ i/ =/ iarg/ ;/ d/ =/ darg/ ;/ o/ =/ newObject/ (/ )/ ;/ }/ publicbooleanm1/ (/ )/ {/ returni/ </ 0/ ;/ }/ publicvoidm2/ (/ )/ {/ d/ =/ 3.0/ ;/ m3/ (/ 3/ )/ ;/ }/ protectedvoidm3/ (/ intiarg/ )/ {/ i/ =/ iarg/ ;/ m4/ (/ newObject/ (/ )/ )/ ;/ }/ publicvoidm4/ (/ Objectobj/ )/ {/ o/ =/ obj/ ;/ }/ }/ classD/ {/ voidn/ (/ )/ {/ Cc/ =/ newC/ (/ )/ ;/ if/ (/ c/ / m1/ )/ {/ …/ }/ c/ / m2/ ;/ c/ / m4/ ;/ }/ }/ 3.2/ ./ 3/ 类型/ 隐藏/ 类型/ 隐藏/ 算法/ 是/ 利用/ Java/ 中/ 的/ 接口/ 来/ 声明/ 待/ 混淆/ 类/ 的/ 变量/ 和/ 方法/ ,/ 而/ 原先/ 的/ 类/ 则/ 实现/ 这些/ 接口/ ,/ 具体/ 实现/ 无需/ 改动/ [/ 3/ ]/ ./ 算法/ 的/ 关键/ 部分/ 是/ 每/ 一个/ 接口/ 只/ 随机/ 包含/ 一个/ 待/ 混淆/ 类中/ 公开/ 的/ 方法/ 的/ 子集/ ./ 除类/ 合并/ 算法/ 之外/ ,/ 另外/ 两种/ 混淆/ 算法/ 对/ 程序运行/ 时间/ 的/ 影响/ 较/ 小/ ./ 4/ 软件/ 混淆/ 算法/ 的/ 攻击/ 模式/ 4.1/ 混淆/ 算法/ 的/ 理论/ 研究/ Barak/ 等/ 人/ [/ 15/ ]/ 曾经/ 证明/ ,/ 如果/ 把/ 混淆/ 的/ 过程/ 看作/ 是/ 一个/ “/ 虚拟/ 黑箱/ ”/ (/ virtualblackbox/ )/ ,/ 即/ 要求/ 被/ 混淆/ 过/ 的/ 程序/ 的/ 输入输出/ 应当/ 完全相同/ 于/ 原程序/ ./ 满足/ 这一/ 性质/ 的/ 混淆/ 器/ 是/ 不/ 可能/ 实现/ 的/ ./ 然而/ “/ 虚拟/ 黑箱/ ”/ 的/ 要求/ 过于/ 严格/ ,/ 在/ 较/ 宽泛/ 的/ 限制/ 中/ ,/ 混淆/ 器是/ 可以/ 实现/ 的/ ./ Lynn/ 等/ 人/ [/ 16/ ]/ 在/ Barak/ 的/ 证明/ 基础/ 上/ 给出/ 关于/ 程序/ 混淆/ 第一个/ “/ 积极/ 的/ ”/ 结果/ :/ 提出/ 了/ 几种/ 针对/ 复杂/ 的/ 访问控制/ 函数/ 的/ 混淆/ 方法/ ,/ 并/ 进行/ 了/ 验证/ ./ Wee/ 等/ 人/ [/ 17/ ]/ 也/ 针对/ “/ 虚拟/ 黑箱/ ”/ 理论/ ,/ 阐述/ 了/ 关于/ 点函数/ 的/ 混淆/ ,/ 证明/ 在/ 黑箱/ 条件/ 下/ 对/ 点函数/ 混淆/ 的/ 存在/ 性/ ./ 关于/ 混淆/ 技术/ 理论/ ,/ 还/ 存在/ 较大/ 的/ 研究/ 空间/ ./ 4.2/ 混淆/ 算法/ 的/ 攻击/ 模式/ 4.2/ ./ 1/ 针对/ 数据/ 混淆/ 算法/ 的/ 攻击/ 假定/ T/ 是/ 对/ 程序/ P/ 的/ 一个/ 单向/ 的/ 混淆/ 变换/ ,/ 当且/ 仅/ 当/ 从/ 原始/ 程序/ P/ 除去/ 某些/ 信息/ 后/ ,/ 无法/ 通过/ 混淆/ 后/ 的/ 程序/ P/ 恢复/ 出/ P/ [/ 18/ ]/ ./ 词法/ 变换/ 是/ 最/ 典型/ 的/ 不/ 可逆/ 混淆/ 算法/ ./ 虽然/ 对于/ 经过/ 词法/ 变换/ 的/ 程序/ 进行/ 攻击/ 不/ 可能/ 恢复程序/ 的/ 原貌/ ,/ 但/ 只要/ 理解/ 程序/ 各个/ 模块/ 的/ 含义/ 就/ 可能/ 对/ 程序/ 产生/ 威胁/ ./ 例如/ 根据/ 无法/ 被/ 混淆/ 的/ 系统/ API/ 名称/ 等/ 关键字/ ,/ 攻击者/ 可以/ 推测/ 出该/ 模块/ 的/ 大致/ 功能/ ./ Cimato/ 等/ 人/ [/ 19/ ]/ 提出/ 基于/ 字节/ 码中/ 的/ 标识符/ 修正/ 的/ 反/ 混淆/ 方法/ ./ 该/ 方法/ 可以/ 用于/ 攻击/ 标识符/ 重命名/ 的/ 混淆/ 算法/ ./ 4.2/ ./ 2/ 针对/ 控制流/ 混淆/ 算法/ 的/ 攻击/ 目前/ ,/ 针对/ 控制流/ 混淆/ 算法/ 的/ 主要/ 攻击/ 方法/ 是/ 动态分析/ ./ Udupa/ 等/ 人/ [/ 20/ ]/ 指出/ 了/ 动态分析/ 对/ 大部分/ 混淆/ 算法/ 的/ 攻击/ 作用/ ,/ 并/ 阐述/ 攻击/ 模型/ ./ 对于/ 控制流/ 混淆/ 而言/ ,/ 变换/ 后/ 生成/ 的/ 程序/ 中若/ 存在/ 始终/ 不/ 执行/ 的/ 分支/ ,/ 通过/ 动态分析/ 就/ 能/ 找到/ 对/ 破解/ 程序/ 有用/ 的/ 信息/ ./ 针对/ 控制流/ 混淆/ ,/ 还有/ 黑盒/ 测试/ 攻击/ [/ 21/ ]/ ,/ 该/ 方法/ 通过/ 对/ 程序/ 进行/ 黑盒/ 测试/ ,/ 了解/ 各个/ 类/ 及其/ 函数/ 的/ 功能/ ,/ 从而/ 获取/ 攻击者/ 需要/ 的/ 信息/ ./ 这种/ 方法/ 对/ 大多数/ 的/ 混淆/ 变换/ 均/ 能/ 加以/ 攻击/ ./ 同时/ ,/ 该/ 方法/ 也/ 存在/ 着/ 一定/ 的/ 局限性/ :/ 黑盒/ 测试/ 缺乏/ 自动/ 分析/ 工具/ ,/ 需要/ 依靠/ 大量/ 的/ 人力/ 来/ 完成/ 分析/ 工作/ ./ 同时/ ,/ Udupa/ 等/ Page8/ 人/ [/ 22/ ]/ 还/ 提出/ 将/ 静态/ 分析/ 与/ 动态分析/ 相结合/ 的/ 反/ 混淆/ 方法/ ./ Lakhotia/ 等/ 人/ [/ 23/ ]/ 提出/ 可以/ 用/ 抽象/ 栈图/ 的/ 方法/ 检测/ 混淆/ 后/ 程序/ 中/ 的/ 调用/ 关系/ ./ Chen/ 等/ 人/ [/ 24/ ]/ 提出/ 使用/ 面向/ 方向/ 的/ 语言/ AspectJ/ 的/ 字节/ 码/ 工具/ 破解/ 混淆/ 算法/ ,/ 该/ 方案/ 可以/ 修正/ 混淆/ 后/ 的/ 程序/ 的/ 方法/ ./ 表/ 1/ 是/ 对/ 上述/ 典型/ 攻击方式/ 的/ 简单/ 阐释/ ./ 基于/ 字节/ 码中/ 的/ 标识符/ 修正/ 方法/ 数据/ 混淆/ (/ 标识符/ 重命名/ )/ 动态分析/ ;/ 静态/ 分析/ ;/ 静态/ 和/ 动态分析/ 结合/ 使用/ AspectJ/ 分析/ 5/ 混淆/ 算法/ 的/ 评估/ 上述/ 混淆/ 算法/ 的/ 效用/ 如何/ ,/ 需要/ 一个/ 对/ 混淆/ 算法/ 进行/ 评价/ 的/ 标准/ ./ 文献/ [/ 2/ ]/ 中/ 提出/ 了/ 3/ 个/ 评估/ 混淆/ 算法/ 的/ 指标/ ,/ 分别/ 为/ 程序/ 增加/ 的/ 复杂度/ 即/ 强度/ (/ potency/ )/ 、/ 算法/ 抵抗/ 机器/ 攻击/ 的/ 能力/ 即/ 弹性/ (/ resili/ -/ ence/ )/ 以及/ 由于/ 对/ 代码/ 转换/ 而/ 带来/ 的/ 额外/ 开销/ (/ cost/ )/ ./ 强度/ (/ potency/ )/ 表征/ 混淆/ 算法/ 为/ 程序/ 所/ 增加/ 的/ 良好/ 的/ 混淆/ 算法/ 应当/ 使/ 其/ 强度/ 和/ 弹性/ 最大化/ ,/ 同时/ 最小化/ 开销/ ./ 表/ 2/ 对/ 上述/ 混淆/ 算法/ 做/ 了/ 一个/ 综合/ 的/ 评估/ ./ 表/ 2/ 混淆/ 算法/ 3/ 项/ 指标/ 评估/ 作用/ 范围/ 类内/ 类间/ 基于/ 类/ 变换/ 的/ 混淆/ 基于/ 上述/ 评估/ 指标/ ,/ Naeem/ 等/ [/ 25/ ]/ 对/ 现有/ 的/ 一些/ 反编译器/ 和/ 混淆/ 器/ 的/ 性能/ 进行/ 了/ 评估/ ,/ 针对/ 前者/ 有/ Jad/ 、/ SourceAgain/ ①/ ,/ 针对/ 后者/ 则/ 主要/ 包括/ JBCO/ [/ 26/ ]/ 以及/ KlassMaster/ ②/ ./ 2007/ 年/ ,/ Anckaert/ 等/ 人/ [/ 27/ ]/ 提出/ 了/ 基于/ 软件/ 复杂度/ 的/ 度量/ 方法/ 用以/ 评估/ 混淆/ 和/ 反/ 混淆/ 的/ 质量/ ./ 这里/ 的/ 度量/ 指标/ 包括/ 4/ 个/ :/ 程序代码/ 、/ 控制流/ 、/ 数据/ 和/ 数据流/ ./ 2008/ 年/ ,/ Ceccato/ 等/ 人/ [/ 28/ ]/ 提出/ 一种/ 新/ 的/ 评估/ 方/ 复杂度/ 以及/ 理解/ 的/ 困难/ 程度/ ./ 程序/ 主要/ 有/ 7/ 类/ 属性/ 决定/ 它/ 的/ 复杂程度/ ,/ 分别/ 是/ 程序/ 长度/ 、/ 循环/ 复杂度/ 、/ 嵌套/ 复杂度/ 、/ 入度/ 出度/ 复杂性/ 、/ 数据流/ 复杂度/ 、/ 数据结构/ 复杂度/ 和/ 面向对象/ 的/ 特性/ (/ 包括/ 方法/ 个数/ 、/ 继承/ 树/ 深度/ 等/ 指标/ )/ ./ 混淆/ 算法/ 对/ 程序/ 这些/ 属性/ 的/ 值/ 提升/ 越/ 多/ ,/ 它/ 的/ 强度/ 性能/ 越好/ ./ 弹性/ (/ resilience/ )/ 表征/ 混淆/ 算法/ 抵抗/ 攻击/ 的/ 能力/ ./ 弹性/ 由/ 两个/ 部分/ 组成/ :/ 一部分/ 是/ 攻击者/ 为了/ 攻克/ 算法/ ,/ 设计/ 并/ 实现/ 一个/ 相应/ 反/ 混淆/ 器所/ 需/ 花费/ 的/ 时间/ ;/ 另/ 一部分/ 是/ 反/ 混淆/ 器/ 对/ 混淆/ 算法/ 进行/ 反/ 混淆/ 所/ 花费/ 的/ 开销/ [/ 24/ ]/ ./ 弹性/ 区别/ 于/ 强度/ 的/ 主要/ 特点/ 是/ 针对/ 自动化/ 的/ 反/ 混淆/ 工具/ ,/ 而/ 强度/ 针对/ 的/ 是/ 程序/ 的/ 阅读者/ ./ 开销/ (/ cost/ )/ 衡量/ 的/ 是/ 混淆/ 算法/ 给/ 程序/ 带来/ 的/ 额外/ 开销/ ./ 开销/ 包括/ 有/ 两个/ 方面/ :/ 一方面/ 是/ 在/ 对/ 程序/ 混淆/ 时所/ 花费/ 的/ 开销/ ;/ 另一方面/ 是/ 混淆/ 后/ 的/ 程序/ 相对/ 于/ 原始/ 程序执行/ 时所/ 增加/ 的/ 时间/ 复杂度/ 以及/ 空间/ 复杂度/ ./ 强度/ (/ 高/ // 中/ // 低/ )/ 弹性/ (/ 好/ // 中/ // 弱/ )/ 开销/ (/ 高/ // 中/ // 低/ )/ 法/ :/ 根据/ 攻击者/ 理解/ 和/ 更改/ 混淆/ 后/ 代码/ 的/ 难易/ 程度/ 来/ 度量/ 混淆/ 算法/ 的/ 质量/ ./ 这种/ 方式/ 与/ 上述/ 方式/ 最大/ 的/ 不同之处/ 在于/ 考虑/ 了/ 攻击者/ 这一/ 因素/ ,/ 通过/ 比较/ 测试者/ (/ 程序员/ )/ 对/ 混淆/ 和/ 未/ 混淆/ 的/ 代码/ 进行/ 攻击/ 时/ 的/ 表现/ ,/ 来/ 经验性/ 地/ 评估/ 混淆/ 算法/ ./ 实验/ 得到/ 的/ 结果/ 是/ ,/ 混淆/ 以后/ 的/ 代码/ 与/ 未/ 混淆/ 代码/ 相比/ ,/ 前者/ 被/ 攻击/ ①/ ②/ tor/ ./ http/ :/ // // www/ ./ zelix/ ./ com/ // klassmasterPage9/ 成功/ 的/ 概率/ 是/ 后者/ 的/ 1/ // 7/ ./ 可见/ ,/ 混淆/ 算法/ 可以/ 显著/ 增加/ 测试者/ 理解/ 代码/ 的/ 难度/ ./ 2009/ 年/ ,/ Tsai/ 等/ 人/ [/ 29/ ]/ 提出/ 了/ 用于/ 评估/ 和/ 分析/ 控制流/ 混淆/ 算法/ 的/ 框架/ ./ 借助/ 基于/ 图/ 的/ 表示/ 方法/ ,/ 许多/ 现有/ 的/ 控制流/ 变换/ 都/ 可以/ 转化/ 为/ 原子/ 操作/ 表示/ ./ 同时/ ,/ 他们/ 还/ 提出/ 了/ 一种/ 对/ 混淆/ 变换/ 效果/ 定量分析/ 度量/ 方法/ ,/ 帮助/ 评估/ 控制流/ 混淆/ 的/ 弹性/ 以及/ 开销/ 代价/ ./ 6/ 总结/ 与/ 展望/ 混淆/ 技术/ 是/ 一种/ 可/ 用于/ 抵制/ 逆向/ 工程/ 和/ 重组/ 工程/ 、/ 对/ 软件/ 知识产权/ 进行/ 保护/ 的/ 程序变换/ 技术/ ./ 使用/ 混淆/ 技术/ 虽然/ 会/ 使/ 代码/ 的/ 效率/ 有/ 一定/ 程度/ 的/ 降低/ ,/ 但是/ 它/ 的/ 实现/ 代价/ 相对/ 较/ 小/ ,/ 因而/ 在/ 近年/ 引起/ 了/ 广泛/ 的/ 关注/ [/ 2/ ,/ 25/ ,/ 30/ -/ 33/ ]/ ./ 由于/ 混淆/ 技术/ 不/ 改变程序/ 功能/ 的/ 特性/ ,/ 并且/ 有些/ 词法/ 混淆/ 算法/ 甚至/ 可以/ 减小/ 原程序/ 的/ 体积/ ,/ 因此/ 混淆/ 技术/ 得以/ 在/ 保护/ 移动/ 代码/ 方面/ 得到/ 广泛/ 的/ 应用/ ./ 受/ 移动/ 平台/ 资源/ 的/ 限制/ ,/ 今后/ 混淆/ 技术/ 的/ 研究/ 方向/ 一方面/ 要/ 加大/ 混淆/ 的/ 力度/ ,/ 增加/ 攻击者/ 反编译/ 的/ 难度/ ,/ 另一方面/ 也/ 要/ 考虑/ 降低/ 混淆/ 算法/ 对/ 目标程序/ 的/ 运行/ 负担/ ./ 文献/ [/ 26/ ,/ 32/ ]/ 探讨/ 了/ 混淆/ 技术/ 在/ 移动/ 代理/ 上/ 的/ 应用/ ./ 目前/ 保护/ 软件/ 知识产权/ 的/ 新/ 技术/ 主要/ 有/ 3/ 种/ :/ 混淆/ 技术/ 、/ 软件/ 水印/ 技术/ 和/ 防/ 篡改/ 技术/ [/ 25/ ]/ ./ 这/ 3/ 种/ 技术/ 各有/ 特长/ ,/ 将/ 它们/ 互相/ 结合/ 使用/ ,/ 可以/ 给予/ 目标软件/ 更为/ 可靠/ 的/ 保护/ ,/ 这/ 也/ 是/ 目前/ 研究/ 的/ 一个/ 重要/ 方向/ ./ 混淆/ 技术/ 的/ 主要/ 目的/ 是/ 增加/ 攻击者/ 对/ 程序/ 进行/ 反编译/ 的/ 难度/ 和/ 代价/ ,/ 因而/ 可以/ 用于/ 提高/ 防/ 篡改/ 技术/ 的/ 保护/ 力度/ [/ 8/ ,/ 34/ -/ 36/ ]/ ./ 此外/ ,/ 混淆/ 技术/ 可以/ 增强/ 软件/ 水印/ 的/ 鲁棒性/ ,/ 使/ 软件系统/ 的/ 安全性/ 更强/ ./ 例如/ 不/ 透明/ 谓词/ 除了/ 上文/ 提到/ 的/ 用于/ 控制流/ 混淆/ 之外/ ,/ 也/ 经常/ 用于/ 在/ 程序/ 中/ 添加/ 软件/ 水印/ [/ 37/ -/ 38/ ]/ ./ 孙光/ 等/ 人/ [/ 39/ ]/ 提出/ 将/ 程序/ 的/ 编译/ 混淆/ ,/ 而/ 不是/ 混淆/ 程序/ 本身/ ./ 但是/ 该/ 方法/ 还有/ 若干/ 问题/ 需要/ 考虑/ ,/ 比如/ 加入/ 水印/ 后/ 的/ 软件/ 执行/ 效率/ 问题/ ,/ 不同/ 水印/ 算法/ 与/ 混淆/ 算法/ 结合/ 的/ 顺序/ 等/ ./ 最后/ ,/ 对于/ 混淆/ 算法/ 的/ 评估/ 、/ 正确性/ 验证/ 以及/ 如何/ 研制/ 高效/ 可靠/ 的/ 混淆/ 算法/ ,/ 也/ 是/ 将来/ 的/ 发展/ 方向/ 之一/ ./ 致谢/ 在/ 此/ ,/ 我们/ 向/ 对/ 本文/ 的/ 工作/ 给予/ 支持/ 和/ 建议/ 的/ 同行/ ,/ 尤其/ 是/ 奥克兰/ 大学/ 的/ Thomborson/ 教授/ 给予/ 的/ 指导/ 和/ 帮助/ 表示感谢/ !/ 

