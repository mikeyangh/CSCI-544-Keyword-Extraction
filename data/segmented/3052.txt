Page1/ 一种/ 开放/ 环境/ 下/ 的/ 软件可靠性/ 评估/ 方法/ 陆文/ 1/ )/ ,/ 2/ )/ 徐锋/ 1/ )/ ,/ 2/ )/ 吕建/ 1/ )/ ,/ 2/ )/ 1/ )/ (/ 南京大学/ 计算机软件/ 新/ 技术/ 国家/ 重点/ 实验室/ 南京/ 210093/ )/ 2/ )/ (/ 南京大学/ 计算机软件/ 研究所/ 南京/ 210093/ )/ 摘要/ 目前/ ,/ 软件系统/ 运行/ 环境/ 日益/ 增强/ 的/ 开放性/ 对/ 原有/ 的/ 软件开发/ 技术/ (/ 包括/ 软件可靠性/ 评估/ 方法/ )/ 提出/ 了/ 挑战/ ./ 一些/ 基于/ 软件测试/ 和/ 模拟/ 的/ 方法/ 由于/ 效率/ 上/ 的/ 不足/ 而/ 不再/ 适用/ ;/ 而/ 另/ 一些/ 方法/ ,/ 例如/ 基于/ 状态/ 的/ 可靠性/ 评估/ 方法/ ,/ 虽然/ 在/ 效率/ 上/ 有/ 了/ 很大/ 的/ 提高/ ,/ 但/ 在/ 适用范围/ 上/ 又/ 存在/ 着/ 不足/ ,/ 比如/ 不能/ 很/ 好/ 地/ 处理/ 含/ 并行/ 结构/ 的/ 系统/ ./ 为此/ ,/ 在/ 基于/ 状态/ 的/ 可靠性/ 评估/ 方法/ 的/ 基础/ 上/ ,/ 文中/ 提出/ 一种/ 改进/ 的/ 可靠性/ 评估/ 方法/ ,/ 以/ 兼顾/ 效率/ 和/ 适用范围/ 两个/ 方面/ ./ 首先/ 介绍/ 如何/ 用/ Petri/ 网来/ 描述/ 各种/ 复杂/ 结构/ 的/ 系统/ ,/ 接着/ 介绍/ 一种/ 自/ 底向上/ 的/ 可靠性/ 计算/ 过程/ ,/ 该/ 过程/ 能/ 对/ 并行/ 结构/ 进行/ 分解/ 和/ 综合/ 计算/ ,/ 高效/ 、/ 准确/ 地/ 计算/ 出/ 系统/ 的/ 可靠性/ ./ 该/ 方法/ 还/ 可以/ 估算/ 出/ 组件/ 对系统/ 的/ 重要性/ ,/ 从而/ 大大/ 地/ 增强/ 了/ 可靠性/ 评估/ 在/ 软件开发/ 中/ 的/ 作用/ ./ 关键词/ 软件可靠性/ ;/ 开放/ 环境/ ;/ 体系结构/ ;/ 组件/ 重要性/ 1/ 引言/ 在/ 过去/ 的/ 20/ 年里/ ,/ Internet/ 的/ 迅猛发展/ 大大/ 影响/ 了/ 我们/ 生活/ 的/ 各个方面/ ,/ 这/ 其中/ 也/ 包括/ 了/ 计算机软件/ 的/ 开发/ 和/ 使用/ ./ 随着/ 计算机技术/ ,/ 尤其/ 是/ 分布式/ 面向对象/ 技术/ 的/ 发展/ ,/ 如/ EJB/ ,/ ./ NET/ 和/ WebServices/ 等/ [/ 1/ ]/ ,/ 各种/ 软件/ 实体/ 开始/ 以/ 开放/ 、/ 自主/ 的/ 软件/ 服务/ 形式/ 存在/ 于/ Internet/ 的/ 各个/ 节点/ 上/ ,/ 并/ 通过/ 协同/ 机制/ 进行/ 跨/ 网络/ 的/ 互连/ 、/ 互通/ 、/ 协作/ 和/ 联盟/ [/ 2/ ]/ ,/ 这样/ ,/ Internet/ 就/ 逐渐/ 成为/ 一个/ 软件开发/ 、/ 运行/ 和/ 维护/ 的/ 环境/ 和/ 基础/ ./ 由于/ Internet/ 本身/ 的/ 开放性/ 和/ 分布/ 性/ ,/ 使得/ 建立/ 在/ 其/ 基础/ 上/ 的/ 软件系统/ 与/ 传统/ 的/ 有所不同/ ,/ 因此/ 会/ 引发/ 一些/ 问题/ ./ 其中/ 一个/ 就是/ :/ 由于/ 对/ 整个/ 环境/ 只有/ 部分/ 的/ 信息/ 并且/ 无法/ 对/ 其/ 进行/ 控制/ ,/ 因而/ 很难/ 确保/ 组合而成/ 的/ 系统/ 具有/ 较/ 高/ 的/ 可靠性/ ,/ 从而/ 很难/ 得到/ 用户/ 的/ 信任/ ./ 类似/ 的/ 问题/ 也/ 出现/ 在/ 了/ WebServices/ 的/ 发展/ 与/ 普及/ 过程/ 中/ ,/ 因此/ ,/ 很多/ 工作/ 在/ 这方面/ 展开/ ./ Ran/ 用/ QoS/ 扩展/ 了/ 服务/ 发现/ 来/ 选择/ 具有/ 较/ 高质量/ 的/ 服务/ [/ 3/ ]/ ;/ Sahai/ 等/ 人/ 利用/ SLA/ 的/ 规约/ 来/ 保证/ 服务/ 的/ 质量/ [/ 4/ ]/ ;/ Liu/ 提出/ 了/ 利用/ 信任/ 评估/ 和/ 信任/ 传递/ 来/ 进行/ 服务/ 选择/ 和/ 组装/ 的/ 框架/ [/ 5/ ]/ ./ 然而/ ,/ 这些/ 方法/ 主要/ 涉及/ 的/ 是/ 如何/ 对/ 构成/ 系统/ 的/ 组件/ 进行/ 评估/ ,/ 而/ 对于/ 组合而成/ 的/ 系统/ 的/ 可靠性/ 则/ 鲜有/ 涉及/ ./ 而/ 在/ 传统/ 的/ 方法/ 中/ ,/ 基于/ 测试/ 和/ 模拟/ 的/ 方法/ 由于/ 要/ 进行/ 详尽/ 的/ 分析/ 和/ 计算/ ,/ 因而/ 其/ 效率/ 比较/ 低下/ ,/ 很难/ 适应/ 动态/ 多变/ 的/ 开放/ 环境/ ;/ 基于/ 体系结构/ 的/ 可靠性/ 评估/ 方法/ [/ 6/ -/ 9/ ]/ 虽然/ 在/ 效率/ 上/ 有所/ 进步/ ,/ 然而/ 它们/ 在/ Internet/ 这种/ 环境/ 下/ 还/ 存在/ 着/ 缺陷/ ,/ 一方面/ 这些/ 方法/ 很难/ 处理/ 带/ 并行/ 结构/ 的/ 系统/ [/ 10/ ]/ ,/ 其所/ 采用/ 的/ 软件体系结构/ 描述/ 方法/ 也/ 不能/ 很/ 好/ 地/ 描述/ 这种/ 结构/ ,/ 因而/ 在/ 适用范围/ 上/ 还/ 存在/ 着/ 缺陷/ ;/ 另一方面/ 它们/ 的/ 效率/ 还/ 需要/ 进一步提高/ ,/ 尤其/ 是/ 在/ 增量/ 更新/ 方面/ ;/ 同时/ ,/ 这些/ 方法/ 主要/ 侧重于/ 对系统/ 的/ 评估/ 结果/ ,/ 很少/ 能/ 产生/ 关于/ 组件/ 的/ 评估/ 信息/ ,/ 因而/ 在/ 软件开发/ 过程/ 中/ 只能/ 提供/ 有限/ 的/ 信息/ ./ 为了/ 解决/ 上述/ 问题/ ,/ 本文/ 试图/ 对/ 一种/ 特殊/ 的/ 基于/ 体系结构/ 的/ 可靠性/ 评估/ 方法/ (/ 即/ 基于/ 状态/ 的/ 方法/ )/ 进行/ 改进/ ./ 一方面/ ,/ 利用/ 开放/ 环境/ 下/ 的/ 软件系统/ 结构/ 简单明了/ 的/ 特征/ ,/ 通过/ 一种/ 自/ 底向上/ 的/ 方式/ 来/ 计算/ 可靠性/ ,/ 以/ 进一步/ 增强/ 效率/ 和/ 增量/ 计算/ 的/ 能力/ ;/ 另一方面/ ,/ 通过/ 对系统/ 中/ 的/ 并行/ 结构/ 进行/ 分解/ 、/ 并/ 分别/ 加以/ 计算/ 、/ 最后/ 再/ 综合/ 的/ 方式/ 来/ 增强/ 方法/ 的/ 适用范围/ ;/ 同时/ ,/ 在/ 整个/ 计算/ 过程/ 中/ ,/ 还/ 利用/ 计算出来/ 的/ 各/ 部分/ 的/ 可靠性/ 信息/ 来/ 计算/ 每个/ 组件/ 的/ 重要性/ ,/ 来/ 增强/ 方法/ 的/ 作用/ ./ 通过/ 这/ 3/ 个/ 方面/ 的/ 改进/ ,/ 可以/ 使得/ 开发/ 并/ 运行/ 在/ Internet/ 上/ 的/ 软件系统/ 的/ 可靠性/ 可以/ 被/ 准确/ 快速/ 地/ 计算出来/ ,/ 并/ 能/ 随着/ 环境/ 和/ 软件系统/ 本身/ 的/ 变化/ 而/ 变化/ ,/ 同时/ 组件/ 重要性/ 这一/ 参数/ 还/ 能/ 为/ 系统/ 的/ 演化过程/ 提供/ 有效/ 的/ 参考/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 工作/ ,/ 并/ 阐述/ 传统/ 方法/ 的/ 不足/ 以及/ 对/ 改进/ 方法/ 的/ 要求/ ;/ 第/ 3/ 节/ 给出/ 一个/ 利用/ PetriNet/ 来/ 描述/ 软件体系结构/ 的/ 方法/ ;/ 第/ 4/ 节/ 介绍/ 详细/ 的/ 可靠性/ 评估/ 过程/ ;/ 第/ 5/ 节/ 给出/ 一个/ 简单/ 的/ 例子/ 来/ 进一步/ 展现/ 这个/ 评估/ 过程/ ,/ 并/ 验证/ 方法/ 的/ 有效性/ 和/ 正确性/ ;/ 最后/ ,/ 对/ 本文/ 进行/ 总结/ 并/ 对/ 后期/ 工作/ 进行/ 展望/ ./ 2/ 开放/ 环境/ 下/ 现有/ 软件可靠性/ 评估/ 技术/ 的/ 分析/ 过去/ 的/ 30/ 年里/ ,/ 在/ 软件可靠性/ 评估/ 这一/ 领域/ 已经/ 有/ 了/ 很多/ 的/ 方法/ 和/ 技术/ ./ 其中/ 一种/ 是/ 黑盒/ 的/ 方式/ ,/ 这种/ 方式/ 将/ 整个/ 系统/ 看作/ 一个/ 单一/ 的/ 个体/ 并且/ 不/ 考虑/ 其/ 内部结构/ ,/ 例如/ 各种/ 软件可靠性/ 增长/ 模型/ [/ 11/ -/ 12/ ]/ ,/ 这些/ 模型/ 通过/ 软件测试/ 中/ 得到/ 的/ 一些/ 统计数据/ 来/ 预测/ 软件/ 的/ 可靠性/ ,/ 由于/ 对/ 软件测试/ 的/ 依赖/ ,/ 使得/ 其/ 在/ 效率/ 上/ 和/ 可操作性/ 方面/ 都/ 不/ 适合/ 开放/ 环境/ 的/ 需要/ ;/ 另/ 一种/ 是/ 白盒/ 的/ 方式/ ,/ 这种/ 方式/ 会/ 根据/ 软件系统/ 的/ 体系结构/ 信息/ 来/ 将/ 各个/ 组件/ 的/ 可靠性/ 进行/ 综合/ 计算/ ,/ 以/ 得到/ 系统/ 的/ 可靠性/ [/ 6/ -/ 9/ ]/ ./ 白盒/ 的/ 方式/ 又/ 可以/ 进一步/ 地/ 分为/ 两类/ :/ 基于/ 路径/ 的/ 方法/ 和/ 基于/ 状态/ 的/ 方法/ [/ 6/ ]/ ./ 基于/ 路径/ 的/ 方法/ 通过/ 计算/ 软件/ 所有/ 可能/ 执行/ 路径/ 的/ 可靠性/ ,/ 然后/ 加以/ 综合/ 来/ 得到/ 整个/ 软件/ 的/ 可靠性/ ,/ 但/ 这种/ 方法/ 不/ 适合/ 于/ 具有/ 无限/ 路径/ 的/ 系统/ ,/ 因而/ 存在/ 着/ 一定/ 的/ 局限性/ ,/ 尽管/ Dolbec/ 和/ Shepard/ 试图/ 采取/ 用/ 组件/ 的/ 使用率/ 来/ 计算/ 可靠性/ 这一/ 方法/ 来/ 解决/ 这个/ 问题/ ,/ 但会/ 带来/ 精度/ 上/ 的/ 损失/ [/ 9/ ]/ ./ 相对来说/ ,/ 基于/ 状态/ 的/ 方法/ 则/ 更优越/ 并且/ 更加/ 流行/ 一些/ ,/ 它们/ 利用/ 控制/ 流程图/ 来/ 表示/ 软件系统/ 的/ 内部结构/ ,/ 并用/ 分析/ 的/ 方式/ 来/ 计算/ 整个/ 系统/ 的/ 可靠性/ [/ 7/ ]/ ./ 这些/ 方法/ 通常/ 有/ 两个/ 假设/ :/ 组件/ 间/ 的/ 独立性/ 和/ 组件/ 间/ 控制/ 转移/ 的/ Markov/ 性/ ,/ 前者/ 表示/ 组件/ 间/ 的/ 失效/ 行为/ 是/ 相互/ 独立/ 的/ ,/ 而/ 后者/ 则/ 表示/ 控制/ 的/ 转移/ 只/ 取决于/ 当前/ 的/ 状态/ ,/ 而/ 不受/ 历史/ 行为/ 的/ 影响/ ./ 这/ 两个/ 假设/ 在/ 大部分/ 情况/ 中/ 都/ 很/ 难/ 满足/ ,/ 因而/ 在/ 适用范围/ 上/ 有着/ 局限性/ ./ 幸运/ 的/ 是/ ,/ 这些/ 假设/ 在/ 开放/ 环境/ 下/ 是/ 常常/ 得到/ 保证/ 的/ ,/ 因为/ 开放/ 环境/ 下/ 的/ 组件/ 是/ 松/ 耦合/ 的/ ,/ 因而/ 具有/ 较/ 高/ 的/ 独立性/ ./ 因此/ ,/ 和/ Page3/ 其它/ 的/ 方法/ 相比/ ,/ 基于/ 状态/ 的/ 方法/ 更加/ 适合/ 用来/ 解决/ 开放/ 环境/ 下/ 软件可靠性/ 的/ 评估/ 问题/ ./ 然而/ ,/ 基于/ 状态/ 的/ 方法/ 实际上/ 还/ 存在/ 着/ 一些/ 不足/ ./ 由于/ 这些/ 方法/ 最初/ 是/ 在/ 过程/ 化/ 的/ 程序设计/ 时代/ 产生/ 的/ ,/ 因而/ 常常/ 假设/ 在/ 任一/ 给定/ 的/ 时刻/ ,/ 只有/ 一个/ 组件/ 正在/ 执行/ ,/ 因此/ 这些/ 方法/ 无法/ 适用/ 于/ 多个/ 组件/ 同时/ 运行/ 的/ 情况/ [/ 10/ ]/ ,/ 而/ 这些/ 情况/ 在/ 开放/ 环境/ 下/ 是/ 经常出现/ 且/ 不可避免/ 的/ ;/ 更/ 糟糕/ 的/ 是/ ,/ 它们/ 常常/ 使用/ 控制/ 流程图/ 来/ 表示/ 程序/ 的/ 结构/ ,/ 这/ 就/ 使得/ 对/ 并行/ 结构/ 的/ 描述/ 很/ 不/ 方便/ ,/ 就/ 更/ 不用说/ 在/ 此基础/ 上/ 进行/ 进一步/ 的/ 分析/ 了/ ./ 因此/ 从/ 适用范围/ 来说/ ,/ 基于/ 状态/ 的/ 方法/ 无法/ 完美/ 地/ 适应/ 开放/ 环境/ ./ 除此之外/ ,/ 开放/ 环境/ 还/ 在/ 其它/ 方面/ 带来/ 了/ 一些/ 新/ 的/ 需求/ :/ (/ 1/ )/ 较/ 高/ 的/ 效率/ ./ 在/ 开放/ 环境/ 中/ ,/ 软件系统/ 是/ 由/ 不同/ 的/ 组件/ 动态/ 并/ 临时/ 的/ 组合而成/ ,/ 因此/ 对/ 其/ 进行/ 详细/ 彻底/ 的/ 分析/ 是/ 不/ 实际/ 、/ 不/ 经济/ 的/ ;/ 同时/ ,/ 环境/ 的/ 多变性/ 也/ 要求/ 评估/ 方法/ 能/ 尽快/ 完成/ ,/ 以/ 保证/ 所得/ 结果/ 依然/ 是/ 有效/ 的/ ./ 因此/ ,/ 效率/ 是/ 最/ 重要/ 的/ ./ (/ 2/ )/ 足够/ 的/ 精确度/ ./ 高效率/ 的/ 要求/ 必然/ 对/ 评估/ 结果/ 的/ 精确度/ 带来/ 了/ 影响/ ,/ 但/ 评估/ 方法/ 仍然/ 要/ 给出/ 足够/ 精确/ 的/ 结果/ ,/ 不然/ 会/ 使得/ 用户/ 得到/ 错误/ 的/ 信息/ ,/ 做出/ 错误/ 的/ 判断/ ./ (/ 3/ )/ 能/ 产生/ 关于/ 组件/ 的/ 评估/ 结果/ ./ 开放/ 环境/ 下/ 的/ 系统/ 的/ 典型/ 特征/ 是/ ,/ 整个/ 系统/ 的/ 功能/ 是/ 要/ 靠/ 各个/ 独立/ 组件/ 之间/ 的/ 协作/ 和/ 联盟/ 来/ 实现/ 的/ ,/ 因而/ 组件/ 所/ 占据/ 的/ 地位/ 越来越/ 重要/ ./ 因此/ ,/ 开放/ 环境/ 下/ 的/ 可靠性/ 评估/ 方法/ 还/ 应该/ 提供/ 关于/ 组件/ 的/ 信息/ 来/ 帮助/ 系统/ 的/ 优化/ 和/ 改进/ ,/ 从而/ 在/ 多变/ 的/ 环境/ 中/ 保持/ 较/ 高/ 的/ 质量/ ./ 然而/ 现有/ 的/ 方法/ 通常/ 通过/ 一个/ 详细/ 的/ 分析/ 来/ 得到/ 非常/ 精确/ 的/ 结果/ ,/ 因此/ 在/ 效率/ 上/ 比较/ 低下/ ,/ 这/ 与/ 开放/ 环境/ 下/ 更加/ 看重/ 效率/ 的/ 要求/ 正好/ 相反/ ./ 同时/ ,/ 它们/ 图/ 1/ 体系结构/ 描述/ 示例/ 往往/ 只/ 得到/ 关于/ 系统可靠性/ 的/ 信息/ ,/ 而/ 很少/ 产生/ 关于/ 组件/ 的/ 信息/ ./ 本文/ 将/ 试图/ 解决/ 这些/ 问题/ ./ 3/ 软件体系结构/ 的/ 描述/ 软件/ 的/ 体系结构/ 包含/ 了/ 对/ 构成/ 软件系统/ 的/ 组件/ 的/ 描述/ ,/ 组件/ 间/ 的/ 交互/ 、/ 组件/ 间/ 组合/ 的/ 模式/ 以及/ 对/ 这些/ 组合/ 模式/ 的/ 约束/ [/ 13/ ]/ ,/ 这些/ 都/ 为/ 针对/ 整个/ 软件系统/ 的/ 可靠性/ 评估/ 提供/ 了/ 有益/ 和/ 必需/ 的/ 信息/ ./ 一方面/ ,/ 它/ 包含/ 了/ 整个/ 系统/ 的/ 结构/ 信息/ ,/ 而/ 系统/ 的/ 结构/ 是/ 软件可靠性/ 的/ 一个/ 重要/ 影响/ 因素/ [/ 14/ -/ 15/ ]/ ;/ 另一方面/ ,/ 它/ 还/ 展示/ 了/ 系统/ 在/ 运行/ 时刻/ 是/ 如何/ 活动/ 的/ 动态/ 信息/ ,/ 这是/ 我们/ 用来/ 预测/ 软件/ 运行/ 时刻/ 行为/ (/ 包括/ 软件可靠性/ )/ 的/ 重要依据/ ./ 要/ 想/ 充分/ 并/ 有效/ 地/ 利用/ 体系结构/ 信息/ ,/ 就/ 需要/ 使用/ 一种/ 合理/ 并/ 方便/ 的/ 描述/ 手段/ ./ 一般来说/ ,/ 体系结构/ 的/ 描述/ 能力/ 会/ 影响/ 到/ 基于/ 其/ 的/ 评估/ 方法/ 的/ 适用范围/ 和/ 易用/ 程度/ ./ 例如/ ,/ Wang/ 等/ 人用/ 状态图/ 来/ 表示/ 体系结构/ [/ 8/ ]/ ,/ 它们/ 的/ 方法/ 只/ 适用/ 于/ 一些/ 预定/ 义/ 的/ 经典/ 的/ 结构/ 风格/ ;/ Gokhale/ 提出/ 的/ 可靠性/ 评估/ 方法/ 无法/ 处理/ 带/ 并行/ 结构/ 的/ 系统/ ,/ 其/ 使用/ 的/ 带/ 概率/ 的/ 控制/ 流程图/ [/ 7/ ]/ 也/ 很/ 难/ 对/ 并行/ 这种/ 结构/ 进行/ 描述/ ;/ OWL/ -/ S/ 使用/ 了/ 几种/ 基本/ 的/ 控制结构/ 来/ 描述/ 组合/ 服务/ 的/ 过程/ 模型/ ,/ 这种/ 方法/ 可以/ 描述/ 绝大部分/ 系统/ 的/ 结构/ [/ 16/ ]/ ,/ 但/ 对/ 一些/ 复杂/ 结构/ (/ 例如/ 递归/ 、/ 嵌套循环/ 的/ 跳出/ )/ 却/ 束手无策/ ./ 考虑/ 到/ 传统/ 方法/ 的/ 不足/ ,/ 本文/ 借鉴/ 了/ Aalst/ 在/ 工作/ 流/ 方面/ 的/ 工作/ [/ 17/ ]/ ,/ 决定/ 尝试/ 用/ Petri/ 网来/ 作为/ 体系结构/ 的/ 描述/ 工具/ ./ Petri/ 网/ 看起来/ 与/ 流程/ 控制/ 图/ 很/ 像/ ,/ 但/ 它/ 能/ 处理/ 包括/ 并行/ 结构/ 在内/ 的/ 各种/ 复杂/ 结构/ ,/ 并且/ 是/ 一种/ 被/ 广为/ 研究/ 和/ 使用/ 的/ 工具/ ./ 图/ 1/ 是/ 一个/ 用/ Petri/ 网来/ 描述/ 软件体系结构/ 的/ Page4/ 例子/ ./ 其中/ Petri/ 网中/ 的/ 绝大部分/ 变迁/ 用来/ 描述/ 软件/ 的/ 各个/ 组件/ (/ 还有/ 一部分/ 变迁/ 用作/ 控制结构/ ,/ 如后/ 文/ 所述/ )/ ,/ 在/ 这里/ ,/ 变迁/ 也/ 可以/ 代表/ 一个/ 子系统/ ,/ 当/ 需要/ 查看/ 系统/ 的/ 简化/ 模型/ 时/ ,/ 可以/ 将/ 代表/ 子系统/ 的/ 图形/ 部分/ 化归为/ 一个/ 变迁/ ;/ 反之/ ,/ 当要/ 查看/ 某个/ 子系统/ 的/ 细节/ 内容/ 时/ ,/ 可以/ 用/ 更/ 细节/ 的/ 内容/ 代替/ 相应/ 的/ 变迁/ ./ 在/ 体系结构/ 的/ Petri/ 网/ 描述/ 中/ ,/ 库所/ 表示/ 了/ 不同/ 组件/ 之间/ 控制/ 转移/ 的/ 中间状态/ ,/ 在/ 某个/ 库所里/ 有/ 一个/ 令牌/ 表示/ 控制/ 将/ 转移/ 到/ 后续/ 的/ 组件/ ,/ 显然/ ,/ 令牌/ 在/ 图/ 中/ 的/ 传递/ 过程/ 代表/ 了/ 运行/ 时刻/ 软件/ 的/ 执行/ 路径/ ./ 在/ 实际/ 使用/ 中/ ,/ 体系结构/ 的/ Petri/ 网/ 表示/ 形式/ 可以/ 利用/ 几种/ 典型/ 的/ 结构/ 通过/ 自/ 底向上/ 的/ 方式/ 构造/ 而成/ :/ (/ 1/ )/ 顺序/ 顺序/ 是/ 最/ 常用/ 的/ 一种/ 结构/ ,/ 它/ 代表/ 了/ 各个/ 组件/ 依次/ 执行/ ,/ 图/ 2/ (/ a/ )/ 是/ 顺序/ 结构/ 的/ 表示/ 方式/ ./ (/ 2/ )/ 分支/ 分支/ 表明/ 程序/ 将/ 从/ 几条/ 候选/ 路径/ 中/ 选出/ 一条/ 来/ 执行/ ,/ 而/ 具体/ 选择/ 哪一条/ ,/ 取决于/ 运行/ 时刻/ 的/ 程序/ 上下文/ 信息/ ./ 显然/ 这种/ 软件系统/ 运行/ 时刻/ 的/ 行为/ 会/ 对/ 整个/ 系统/ 运行/ 的/ 成功/ 与否/ 有着/ 明显/ 的/ 影响/ ,/ 但是/ 我们/ 却/ 无法/ 预测/ 到/ 这种/ 行为/ ,/ 不过/ 我们/ 可以/ 估计/ 每个/ 分支/ 被/ 执行/ 的/ 概率/ ,/ 这些/ 概率/ 足以/ 让/ 我们/ 对系统/ 的/ 可靠性/ 进行/ 评估/ ./ 图/ 2/ (/ b/ )/ 是/ 分支/ 的/ 描述/ 形式/ ,/ 每个/ 分支/ 的/ 概率/ 都/ 标注/ 在/ 相应/ 的/ 弧/ 上/ ./ (/ 3/ )/ 循环/ 循环/ 常常/ 被/ 用来/ 表示/ 某个/ 组件/ 将/ 被/ 重复/ 的/ 执行/ ./ 图/ 2/ (/ c/ )/ 描述/ 了/ 循环/ 结构/ ./ 在/ 这里/ ,/ 也/ 有/ 一些/ 概率/ 信息/ ,/ 这些/ 信息/ 表示/ 控制流/ 离开/ 和/ 回到/ 循环体/ 的/ 概率/ ./ (/ 4/ )/ 并行/ 并行/ 表示/ 几个/ 组件/ 都/ 会/ 被/ 执行/ ./ 在/ 图/ 2/ (/ d/ )/ 中/ ,/ 变迁/ B/ 和/ C/ 表示/ 两个/ 会/ 被/ 一起/ 执行/ 的/ 组件/ ;/ 而/ 变迁/ A/ 和/ D/ 则/ 用来/ 描述/ 程序执行/ 路径/ 的/ 分裂/ 和/ 合并/ ,/ 其中/ D/ 不是/ 必须/ 的/ ,/ 这/ 表示/ 所有/ 的/ 路径/ 一直/ 延续/ 到/ 结束/ ,/ 这种/ 情况/ 也/ 是/ 比较/ 常见/ 的/ ,/ 例如/ Unix/ 类/ 系统/ 中/ 的/ fork/ 调用/ 会/ 造成/ 这种/ 结果/ ./ (/ 5/ )/ 调用/ 调用/ 也/ 是/ 一种/ 经典/ 的/ 结构/ ,/ 它/ 出现/ 在/ 各种/ 程序开发/ 方法/ 中/ ,/ 如/ 过程/ 式/ 编程/ 中/ 的/ 函数/ ,/ 面向对象/ 中/ 的/ 方法/ 等/ ,/ 并且/ 是/ 分布式/ 环境/ 中/ 组件/ 间/ 相互/ 交互/ 的/ 一种/ 主要/ 手段/ ./ 而/ 对/ 调用/ 的/ 描述/ 也/ 比较复杂/ ,/ 假设/ 组件/ A/ 调用/ 了/ 组件/ B/ ,/ 如果/ 知道/ A/ 的/ 内部结构/ ,/ 那么/ 我们/ 可以/ 用/ 这个/ 内部结构/ 的/ Petri/ 图/ 表示/ 替代/ 对应/ A/ 的/ 变迁/ ;/ 否则/ ,/ 我们/ 可以/ 简单/ 地/ 把/ A/ 和/ B/ 看成/ 是/ 顺序/ 执行/ 的/ ,/ 这/ 将/ 不会/ 影响/ 到/ 后面/ 对/ 可靠性/ 的/ 评估/ 结果/ ./ (/ 6/ )/ goto/ 虽然/ goto/ 是/ 一种/ 不/ 推荐/ 的/ 控制结构/ ,/ 但/ 其/ 仍/ 有/ 一定/ 的/ 价值/ ./ 因为/ 有/ 一些/ 复杂/ 结构/ ,/ 例如/ 递归/ 、/ 异常/ 处理/ 等/ ,/ 很/ 难用/ 上面/ 的/ 5/ 种/ 结构/ 来/ 表示/ ,/ 而用/ goto/ 来/ 表示/ 就/ 比较简单/ 和/ 方便/ ./ goto/ 的/ Petri/ 网/ 表示/ 也/ 比较简单/ ,/ 只是/ 将/ 跳转/ 的/ 组件/ 之间/ 用/ 一个/ 库所/ 连接起来/ 即可/ ,/ 因此/ 可由图/ 2/ (/ a/ )/ 来/ 表示/ ./ 通过/ 这/ 几种/ 控制结构/ ,/ 我们/ 便/ 可以/ 绘制/ 出/ 描述/ 整个/ 软件系统/ 的/ Petri/ 网来/ ,/ 通常/ ,/ 我们/ 在/ 最/ 前端/ 和/ 最后/ 端/ 各/ 增加/ 一个/ 库所/ ,/ 分别/ 来/ 表示/ 软件系统/ 的/ 开始/ 和/ 结束/ 状态/ ./ 图/ 1/ 便/ 描述/ 了/ 由/ 8/ 个/ 组件/ 组成/ 的/ 软件系统/ ./ 从图/ 1/ 可以/ 发现/ ,/ Petri/ 网/ 描述/ 在/ 图形/ 上/ 与/ 控制/ 流程图/ 很/ 相似/ ,/ 因此/ 一些/ 基于/ 流程图/ 的/ 方法/ 可以/ 很/ 容易/ 地/ 转移/ 到/ Petri/ 网/ 上面/ 来/ ;/ 而/ 在/ Petri/ 网/ 方面/ ,/ 已经/ 有/ 很多/ 工作/ 用于/ 系统/ 行为/ 属性/ 的/ 分析/ 与/ 验证/ [/ 17/ -/ 18/ ]/ ,/ 这些/ 工作/ 可以/ 作为/ 系统/ 评估/ 的/ 一部分/ 来/ 提供/ 更/ 多/ 关于/ 系统/ 的/ 信息/ ,/ 因而/ 可以/ 使得/ 我们/ 的/ 方法/ 和/ 这些/ 工作/ 能/ 很/ 好/ 地/ 共存/ ,/ 并/ 作为/ 对/ 软件系统/ 进行/ 全面/ 分析/ 的/ 一部分/ ./ 同时/ ,/ 这种/ 图形化/ 表示/ 方法/ 也/ 能/ 很/ 容易/ 地/ 从/ 实际/ 的/ 系统/ 中/ 得到/ ,/ 以及/ 与/ 其它/ 表示/ 方法/ 相互/ 转换/ ,/ 如/ OWL/ -/ S/ [/ 18/ ]/ ./ 而/ 在/ 体系结构/ 的/ 提取/ 方面/ ,/ 由于/ 开放/ 环境/ 下/ 的/ 软件系统/ 中/ ,/ 组件/ 具有/ 较/ 高/ 的/ 独立性/ ,/ 它们/ 之间/ 的/ 关系/ 也/ 呈现出/ 松散/ 耦合/ 的/ 特性/ ,/ 因而/ 我们/ 能/ 很/ 容易/ 地/ 从/ 软件系统/ 的/ 实现/ 或者/ 规约/ 说明/ 中/ 分辨/ 出/ 不同/ 的/ 组件/ ,/ 并/ 分析/ 出/ 它们/ 之间/ 的/ 关系/ ,/ 从而/ 得到/ 类似/ 图/ 1/ 那样/ 的/ Petri/ 表示/ ,/ 但/ 其中/ 的/ 分支/ 概率/ 这/ 类/ 体现/ 软件/ 运行/ 时刻/ 行为/ 的/ 动态/ 信息/ ,/ 则/ 很/ 难/ 直接/ 获取/ ./ 在/ 传统/ 的/ 软件开发/ 中/ ,/ 这些/ 概率/ 信息/ 可/ 由/ 软件测试/ 来/ 得到/ ,/ 而/ 在/ 开放/ 环境/ 的/ 软件系统/ 中/ ,/ 测试/ 往往/ 是/ 不/ 可行/ 的/ ./ 这时候/ ,/ 我们/ 可以/ 在/ 系统/ 运行/ 的/ 初期/ 设置/ 一个/ 初始/ Page5/ 值/ ,/ 这些/ 初始值/ 可以/ 由/ 专家/ 来/ 指定/ ,/ 或者/ 是/ 一个/ 预定/ 的/ 值/ ./ 在/ 程序/ 的/ 运行/ 阶段/ ,/ 我们/ 可以/ 监控/ 并/ 统计/ 系统/ 的/ 运行/ 行为/ ./ 当/ 积累/ 的/ 信息/ 达到/ 一定/ 程度/ 时/ ,/ 可以/ 利用/ 这些/ 充足/ 的/ 、/ 准确/ 的/ 信息/ 对系统/ 进行/ 重新/ 评估/ 以/ 获得/ 更/ 准确/ 、/ 更/ 实时/ 的/ 结果/ ,/ 因此/ 可以/ 说/ ,/ 本文/ 提出/ 的/ 可靠性/ 评估/ 方法/ 在/ 软件系统/ 的/ 运行/ 时刻/ 会/ 产生/ 出/ 更加/ 准确/ 、/ 有/ 意义/ 的/ 结果/ ./ 4/ 软件可靠性/ 评估/ 方法/ 在/ 本节/ ,/ 我们/ 将/ 首先/ 介绍/ 可靠性/ 评估/ 方法/ 所/ 生成/ 的/ 各种/ 结果/ ,/ 然后/ 再/ 详细/ 介绍/ 如何/ 来/ 得到/ 这些/ 评估/ 结果/ ./ 4.1/ 评估/ 结果/ 4.1/ ./ 1/ 对系统/ 的/ 评估/ 结果/ 首先/ ,/ 评估/ 方法/ 必须/ 给出/ 关于/ 系统/ 的/ 可靠性/ ./ 在/ 我们/ 的/ 方法/ 中/ ,/ 采用/ 了/ 悲观/ 估计/ 的/ 方式/ 来/ 估计/ 软件/ 的/ 可靠性/ ./ 定义/ 1/ ./ 软件系统/ 的/ 可靠性/ 是/ 对/ 整个/ 系统/ 成功/ 执行/ 的/ 期望/ ,/ 而/ 系统/ 的/ 成功/ 执行/ 意味着/ 所/ 执行/ 的/ 所有/ 组件/ 必须/ 全部/ 按/ 用户/ 的/ 期望/ 执行/ (/ 需要/ 注意/ 的/ 是/ ,/ 冗余/ 备份/ 中/ 的/ 组件/ 可以/ 允许/ 部分/ 失效/ ,/ 这时/ 可/ 把/ 整个/ 冗余/ 备份/ 结构/ 看成/ 一个/ 组件/ )/ ./ 假设/ 系统/ 由/ Ω/ 来/ 表示/ ,/ 组件/ 为/ C1/ ,/ C2/ ,/ …/ ,/ Cn/ ,/ 各个/ 组件/ 在/ 系统/ 一次/ 运行/ 过程/ 中/ 的/ 运行/ 次数/ 为/ 变量/ t1/ ,/ t2/ ,/ …/ ,/ tn/ ,/ 则/ 系统/ 的/ 可靠性/ R/ (/ Ω/ )/ 可由式/ (/ 1/ )/ 给出/ :/ 由于/ 开放/ 环境/ 中/ 各个/ 组件/ 之间/ 往往/ 是/ 相互/ 独立/ 的/ ,/ 因此/ 可以/ 对/ 公式/ 进行/ 简化/ 来/ 得到/ 式/ (/ 2/ )/ ,/ 以/ 使得/ 在/ 整个/ 计算/ 过程/ 中/ 可以/ 对/ 各个/ 组件/ 分别/ 进行/ 计算/ ,/ 这样/ 就/ 大大降低/ 了/ 计算/ 的/ 复杂程度/ ./ 由/ 该式/ (/ 2/ )/ 可以/ 看出/ ,/ 系统/ 的/ 可靠性/ 取决于/ 各个/ 组件/ 的/ 可靠性/ 和/ 它们/ 的/ 平均/ 运行/ 次数/ ,/ 而/ 平均/ 次数/ 的/ 获取/ 是/ 比较/ 麻烦/ 的/ ,/ 下面/ 将/ 介绍/ 如何/ 将/ 这部分/ 工作/ 进行/ 简化/ ./ 4.1/ ./ 2/ 对/ 组件/ 的/ 评估/ 结果/ 开放/ 环境/ 下/ 的/ 可靠性/ 评估/ 还/ 需要/ 考虑/ 各个/ 组件/ 对/ 系统可靠性/ 的/ 影响/ ,/ 即/ 组件/ 的/ 重要性/ ./ 文献/ [/ 19/ ]/ 对此/ 进行/ 了/ 简单/ 的/ 分析/ ,/ 可以/ 看出/ 组件/ 的/ 重要性/ 主要/ 取决于/ 组件/ 自身/ 的/ 可靠性/ 和/ 运行剖面/ (/ 主要/ 是/ 组件/ 的/ 运行/ 次数/ )/ ,/ 但/ 该文/ 并/ 没有/ 给出/ 系统/ 的/ 计算方法/ ./ 文献/ [/ 20/ ]/ 通过/ 方差/ 来/ 计算/ 组件/ 的/ 重要性/ ,/ 但/ 系统/ 的/ 成功失败/ 是/ 一个/ 伯努利/ 随机变量/ ,/ 这/ 一类/ 变量/ 的/ 方差/ 是/ 由/ 期望/ 决定/ 的/ ,/ 因此/ 方差/ 这种/ 指标/ 只/ 侧重于/ 组件/ 可靠性/ 大小/ 对/ 系统可靠性/ 的/ 影响/ ./ Siegrist/ 提出/ 了/ 用/ 偏/ 导数/ 来/ 表示/ 组件/ 的/ 重要性/ [/ 21/ ]/ ,/ 但/ 其/ 采用/ 的/ 计算方法/ 仅仅/ 考虑/ 了/ 每个/ 组件/ 的/ 平均/ 运行/ 次数/ ,/ 而/ 不/ 考虑/ 它/ 自身/ 的/ 可靠性/ 大小/ ,/ 因而/ 无法/ 给出/ 全面/ 的/ 结果/ ./ 在/ 本文/ 提出/ 的/ 方法/ 中/ ,/ 依然/ 采用/ 了/ 偏/ 导数/ 来/ 描述/ 组件/ 的/ 重要性/ ,/ 其/ 定义/ 如下/ ./ 定义/ 2/ ./ 软件系统/ 中/ 组件/ 的/ 重要性/ 是/ 指/ 系统可靠性/ 相对/ 于/ 该/ 组件/ 可靠性/ 的/ 变化率/ ,/ 其值/ 越大/ ,/ 则/ 说明/ 该/ 组件/ 对系统/ 的/ 影响/ 越大/ ,/ 因而/ 具有/ 较/ 高/ 的/ 重要/ 程度/ ./ 假设/ 系统/ 由/ Ω/ 来/ 表示/ ,/ 则/ 组件/ A/ 相对/ 于/ 该/ 系统/ 的/ 重要性/ D/ (/ Ω/ ,/ A/ )/ 可由式/ (/ 3/ )/ 得出/ :/ 从/ 该式/ (/ 3/ )/ 可以/ 看出/ ,/ 所/ 产生/ 的/ 重要性/ 首先/ 是/ 依赖于/ 组件/ 的/ 运行/ 次数/ 的/ ,/ 因为/ 软件/ 的/ 可靠性/ 是/ 由/ 组件/ 可靠性/ 作为/ 变量/ 的/ 函数/ ,/ 其/ 具体/ 的/ 计算/ 是/ 依赖于/ 其/ 运行/ 次数/ 的/ ,/ 因而/ 最后/ 得到/ 的/ 偏导值/ 也/ 受/ 其/ 影响/ ;/ 另一方面/ ,/ 组件/ 可靠性/ 的/ 改变/ 虽然/ 不会/ 使得/ 自身/ 重要性/ 产生/ 变化/ ,/ 但会/ 影响/ 到/ 其它/ 组件/ 的/ 重要性/ 计算/ ,/ 因而/ 在/ 组件/ 之间/ 的/ 比较/ 中/ 仍会/ 产生/ 影响/ ,/ 因此/ 可以/ 说/ 组件/ 可靠性/ 大小/ 会/ 间接/ 影响/ 其/ 在/ 整个/ 系统/ 中/ 的/ 重要/ 程度/ ./ 在/ 下/ 一节/ ,/ 我们/ 将/ 通过/ 对/ 实验/ 结果/ 的/ 分析/ 来/ 验证/ 这/ 一点/ ./ 4.2/ 评估/ 过程/ 4.2/ ./ 1/ 系统/ 的/ 分解/ 众所周知/ ,/ 现有/ 的/ 软件系统/ 是/ 以/ 一种/ 自/ 底向上/ 的/ 方式/ 逐层/ 地/ 构造/ 而成/ ,/ 而/ 每/ 一层/ 的/ 构造/ 方式/ 都/ 比较简单/ ,/ 呈现出/ 几种/ 典型/ 的/ 模式/ ./ 直观/ 上/ 来看/ ,/ 可以/ 按照/ 软件系统/ 的/ 构造/ 方式/ 来/ 逐层/ 的/ 计算/ 系统/ 的/ 可靠性/ ,/ 这样/ 能/ 大大减少/ 了/ 计算/ 规模/ 和/ 计算/ 复杂度/ ./ 假设/ 系统/ Ω/ 包含/ 组件/ C1/ ,/ C2/ ,/ …/ ,/ Cn/ ,/ 各个/ 组件/ 的/ 运行/ 次数/ 变量/ 为/ t1/ ,/ t2/ ,/ …/ ,/ tn/ ,/ 而/ 这/ n/ 个/ 组件/ 又/ 可/ 分别/ 组成/ m/ 个/ 子系统/ S1/ ,/ S2/ ,/ …/ ,/ Sm/ ,/ 这/ m/ 个/ 子系统/ 的/ 运行/ 次数/ 变量/ 为/ u1/ ,/ u2/ ,/ …/ ,/ um/ ,/ 则/ 根据/ 式/ (/ 1/ )/ ,/ 我们/ 可以/ 得到/ 子系统/ Si/ 的/ 可靠性/ 为/ 同时/ ,/ 整个/ 系统/ 的/ 可靠性/ 可用/ 如下/ 方式/ 进行/ 计算/ :/ R/ (/ Ω/ )/ =/ E/ ∏/ nPage6/ 其中/ (/ / )/ 的/ 推导/ 可/ 参考文献/ [/ 20/ ]/ 的/ 附录/ ./ 同时/ ,/ 式/ (/ 3/ )/ 也/ 可/ 写/ 为/ D/ (/ Ω/ ,/ Ci/ )/ =/ / R/ (/ Ω/ )/ 4.2/ ./ 2/ 简单/ 子系统/ 的/ 计算/ 在/ 软件/ 的/ 构造/ 过程/ 中/ ,/ 最/ 常见/ 的/ 是/ 几种/ 典型/ 的/ 构造/ 方式/ ,/ 可以/ 对/ 这/ 几种/ 构造/ 方式/ 分别/ 进行/ 讨论/ 以/ 得到/ 对式/ (/ 2/ )/ 和/ 式/ (/ 3/ )/ 进行/ 特化/ 后/ 的/ 结果/ ./ (/ 1/ )/ 顺序/ 结构/ 在/ 顺序/ 结构/ 的/ 子系统/ ,/ 各个/ 组件/ 依次/ 执行/ ,/ 因此/ ,/ 每个/ 组件/ 都/ 执行/ 一次/ ./ 假设/ 子系统/ S/ 由/ 组件/ C1/ ,/ C2/ ,/ …/ ,/ Cn/ 构成/ ,/ 则/ 运用/ 公式/ (/ 2/ )/ 和/ (/ 3/ )/ 可/ 得到/ R/ (/ S/ )/ =/ ∏/ n/ 烄/ 烅/ D/ (/ S/ ,/ Ci/ )/ =/ ∑/ n/ 烆/ (/ 2/ )/ 分支/ 结构/ 在/ 分支/ 结构/ 中/ ,/ 每次/ 运行/ 时/ ,/ 会以/ 一定/ 的/ 概率/ 选择/ 其中/ 一个/ 分支/ 来/ 运行/ ,/ 假设/ 子系统/ S/ 由/ 组件/ C1/ ,/ C2/ ,/ …/ ,/ Cn/ 构成/ ,/ 各/ 组件/ 执行/ 的/ 概率/ 为/ P/ (/ C1/ )/ ,/ P/ (/ C2/ )/ ,/ …/ ,/ P/ (/ Cn/ )/ ,/ 而/ 这些/ 概率/ 信息/ 又/ 代表/ 了/ 每个/ 组件/ 平均/ 被/ 运行/ 的/ 次数/ ,/ 因而/ 可/ 得/ 烄/ 烅/ 烆/ (/ 3/ )/ 循环/ 循环/ 可/ 分为/ 两种/ :/ 一种/ 是/ 固定/ 次数/ 的/ 循环/ ,/ 表示/ 循环体/ 执行/ 的/ 次数/ 是/ 确定/ 的/ ,/ 假设/ 循环体/ A/ 会/ 被/ 执行/ n/ 次/ ,/ 则/ 可以/ 得到/ 还有/ 一种/ 循环/ 是/ 基于/ 条件/ 控制/ 的/ 循环/ ,/ 循环/ 体会/ 一直/ 被/ 执行/ 直到/ 某个/ 终止/ 条件/ 被/ 满足/ ./ 假设/ 循环体/ 为/ A/ ,/ 控制流/ 返回/ A/ 的/ 概率/ 为/ P/ (/ A/ )/ ,/ 则/ 我们/ 得到/ 整个/ 子系统/ S/ 的/ 可靠性/ 以及/ A/ 的/ 重要性/ 为/ R/ (/ S/ )/ =/ 1/ 烄/ 烅/ D/ (/ S/ ,/ A/ )/ =/ 1/ -/ P/ (/ A/ )/ 烆/ (/ 4/ )/ 并行/ 并行/ 结构/ 的/ 可靠性/ 很难/ 判断/ ,/ 因为/ 这个/ 结构/ 本身/ 并/ 没有/ 明确/ 的/ 定义/ ,/ 有/ 的/ 情况/ 下/ 并行/ 结构/ 要求/ 所有/ 的/ 组件/ 都/ 要/ 成功/ 完成/ ,/ 而/ 有/ 的/ 情况/ 下/ 只/ 要求/ 其中/ 的/ 几个/ 组件/ 成功/ 完成/ ./ 鉴于/ 这个/ 原因/ ,/ 本文/ 仅/ 对/ 其中/ 两种/ 基本/ 的/ 种类/ 进行/ 讨论/ ./ 第/ 1/ 种/ 是/ 与/ 并行/ ,/ 其/ 含义/ 是/ 只有/ 当/ 并行/ 结构/ 的/ 所有/ 组件/ 都/ 成功/ 运行/ 时/ ,/ 整个/ 并行/ 结构/ 才能/ 称为/ 是/ 成功/ 的/ ,/ 这/ 经常出现/ 在/ 为/ 提高/ 性能/ 而/ 采取/ 并发/ 操作/ 的/ 情况/ 下/ ./ 假设/ 系统/ S/ 由/ 组件/ C1/ ,/ C2/ ,/ …/ ,/ Cn/ 构成/ ,/ 则/ 可用/ 式/ (/ 6/ )/ 计算/ 出/ 与/ 并行/ 的/ 可靠性/ 和/ 其中/ 组件/ 的/ 重要性/ ./ 第/ 2/ 种/ 是/ 或/ 并行/ ,/ 它/ 要求/ 只要/ 有/ 一个/ 组件/ 能/ 成功/ 运行/ 即可/ ./ 假设/ 子系统/ S/ 由/ 组件/ C1/ ,/ C2/ ,/ …/ ,/ Cn/ 构成/ ,/ 则/ 可由式/ (/ 10/ )/ 计算/ 出/ 或/ 并行/ 的/ 可靠性/ 和/ 其中/ 组件/ 的/ 重要性/ :/ R/ (/ S/ )/ =/ 1/ -/ ∏/ n/ 烄/ 烅/ D/ (/ S/ ,/ Ci/ )/ =/ ∑/ n/ 烆/ 与/ 并行/ 和/ 或/ 并行/ 是/ 两个/ 基本/ 的/ 并行/ 结构/ ,/ 其它/ 的/ 复杂/ 的/ 情况/ ,/ 例如/ “/ 至少/ 两个/ 组件/ 成功/ ”/ 等/ ,/ 都/ 可以/ 通过/ 与/ 并行/ 和/ 或/ 并行/ 的/ 复合/ 来/ 得到/ ./ 4.2/ ./ 3/ 复杂/ 子系统/ 的/ 计算/ 在/ 大多数/ 的/ 情况/ 下/ ,/ 软件系统/ 每层/ 的/ 构造/ 方式/ 可以/ 由/ 上述/ 几种/ 模式/ 来/ 描述/ ./ 然而/ 还/ 存在/ 其它/ 一些/ 复杂/ 的/ 结构/ 难以/ 应付/ ,/ 主要/ 是/ 一些/ “/ goto/ ”/ 类型/ 的/ 控制结构/ ,/ 例如/ 嵌套循环/ 的/ 跳出/ 、/ 异常/ 处理/ 等/ ./ 在/ 这种/ 情况/ 下/ ,/ 我们/ 可以/ 利用/ 传统/ 的/ 基于/ 状态/ 的/ 可靠性/ 评估/ 方法/ 来/ 处理/ ,/ 当然/ 还/ 需/ 进行/ 一些/ 改进/ 来/ 应对/ 传统/ 方法/ 无法/ 处理/ 带/ 并行/ 结构/ 系统/ 的/ 问题/ ./ 总的说来/ ,/ 这部分/ 计算/ 包括/ 了/ 3/ 个/ 部分/ :/ (/ 1/ )/ 将/ 系统/ 分解/ 为/ 一系列/ 的/ “/ 进程/ ”/ ./ 为了/ 使用/ 基于/ 状态/ 的/ 方法/ ,/ 首先/ 应该/ 把/ 系统/ 里/ 的/ 并行/ 部分/ 分离出来/ ,/ 单独/ 计算/ ./ 为了/ 达到/ 这个/ 目的/ ,/ 我们/ 可以/ 把/ 每个/ 最/ 外层/ 的/ 并行/ 结构/ (/ 意指/ 不/ 包含/ 在/ 其它/ 并行/ 结构/ 里/ )/ 用/ 一个/ 虚/ 组件/ 来/ 替代/ ,/ 这样/ 我们/ 就/ 得到/ 了/ 一个/ 不/ 含/ 并行/ 结构/ 的/ 系统/ ,/ 称之为/ “/ 进程/ ”/ ./ Page7/ 而/ 对/ 每个/ 虚/ 组件/ 来说/ ,/ 其/ 并行/ 结构/ 的/ 每个/ 部分/ 都/ 是/ 相互/ 独立/ 的/ ,/ 可以/ 递归/ 的/ 转化/ 为/ 一系列/ 的/ 进程/ ./ 详细/ 的/ 过程/ 如下/ :/ 1/ ./ 对系统/ 的/ Petri/ 网图/ 进行/ 处理/ ,/ 首先/ 找到/ 最/ 外层/ 的/ 并行/ 结构/ ,/ 这/ 可以/ 通过/ 首先/ 找到/ 从/ 起始/ 库所/ 出发/ 所/ 遇到/ 的/ 第一个/ 分裂/ 变迁/ (/ 可能/ 有/ 多个/ ,/ 可/ 对/ 每个/ 分别/ 处理/ )/ 和/ 其/ 对应/ 的/ 合并/ 变迁/ (/ 如果/ 没有/ ,/ 则/ 以/ 结束/ 库所/ 代替/ )/ ,/ 例如/ 图/ 2/ (/ d/ )/ 中/ 的/ A/ 和/ D/ ,/ 然后/ 找到/ 所有/ 源自/ 于/ 分裂/ 变迁/ 但/ 又/ 出现/ 在/ 合并/ 变迁/ 前面/ 的/ 各个/ 库所/ 、/ 变迁/ 和/ 弧/ ,/ 这些/ 便是/ 最/ 外层/ 并行/ 结构/ 所/ 包含/ 的/ 部分/ ,/ 例如/ 在/ 图/ 1/ 中/ ,/ 所有/ 在/ 变迁/ t4/ 和/ 变迁/ t7/ 之间/ 的/ 部分/ ./ 用/ 一个/ 变迁/ 来/ 代替/ 这个/ 并行/ 结构/ ,/ 用来/ 表示/ 虚/ 组件/ ./ 这样/ ,/ 我们/ 就/ 得到/ 了/ 一个/ 不/ 含/ 并行/ 结构/ 的/ Petri/ 网图/ ,/ 可/ 称为/ 进程/ ,/ 可以/ 对/ 这个/ 进程/ 中/ 的/ 所有/ 成分/ 加以/ 标记/ ,/ 以/ 表明/ 这些/ 部分/ 已经/ 出现/ 在/ 一个/ 生成/ 的/ 进程/ 中/ 了/ ./ 然后/ 进入/ 步/ 2.2/ ./ 虚/ 组件/ 的/ 内部结构/ 可以/ 被/ 分为/ 几条/ 独立/ 的/ 路径/ ,/ 对/ 每条/ 路径/ ,/ 我们/ 可以/ 识别/ 出/ 与其/ 相关/ 的/ 库/ 所/ 、/ 变迁/ 和/ 弧/ ,/ 这些/ 内容/ 便是/ 该/ 路径/ 的/ Petri/ 网/ 表示/ ,/ 通过/ 步/ 3/ 来/ 对/ 每条/ 路径/ 进行/ 处理/ ./ 图/ 3/ 生成/ 的/ 虚/ 组件/ 和/ 进程/ (/ 2/ )/ 计算/ 每/ 一个/ 进程/ 的/ 可靠性/ ./ 这/ 一步/ 将/ 利用/ 基于/ 状态/ 的/ 方法/ 来/ 计算/ 每个/ 进程/ 的/ 可靠性/ ./ 假设/ 进程/ S/ 由/ 组件/ C1/ ,/ C2/ ,/ …/ ,/ Cn/ 构成/ ,/ 可以/ 得到/ 组件/ 之间/ 的/ 转移/ 概率/ 矩阵/ 犙/ ,/ 其中/ Qij/ 表示/ 组件/ Cj/ 在/ 组件/ Ci/ 之后/ 紧接着/ 执行/ 的/ 概率/ ./ 可以/ 看出/ 犙/ k/ 为/ 执行/ k/ 步/ 之后/ 的/ 转移/ 概率/ ./ 可以/ 证明/ 当/ t/ 趋于/ 无穷大/ 时/ ∑/ t/ 犕/ =/ (/ 犐/ -/ 犙/ )/ -/ 1/ =/ 犐/ +/ 犙/ +/ 犙/ 2/ +/ …/ =/ ∑/ 假设/ 组件/ C1/ 是/ 代表/ 起始/ 状态/ 的/ 组件/ ,/ 而/ Cn/ 是/ 代表/ 终止/ 状态/ 的/ 组件/ ,/ 则/ 元素/ M1i/ 表示/ 组件/ Ci/ 的/ 平均/ 执行/ 次数/ ,/ 利用/ 这个/ 信息/ ,/ 我们/ 可以/ 计算/ 进程/ 的/ 可靠性/ :/ 3/ ./ 此步/ 所/ 做/ 的/ 工作/ 与步/ 1/ 相同/ ,/ 只是/ 稍微/ 有点/ 差别/ ,/ 因为/ 在/ 处理过程/ 中/ 可能/ 会/ 碰到/ 一些/ 已经/ 出现/ 在/ 其它/ 进程/ 里/ 的/ 变迁/ 或库/ 所/ ./ 假设/ 我们/ 在/ 试图/ 构造/ 进程/ Pi/ ,/ 在/ 构造/ 过程/ 中/ 遇见/ 了/ 一个/ 库所/ p/ (/ 也/ 可能/ 是/ 一个/ 变迁/ ,/ 在/ 这种/ 情况/ 下/ ,/ 我们/ 可以/ 在/ 这个/ 变迁/ 前面/ 加/ 一个/ 辅助/ 的/ 库/ 所/ p/ )/ ,/ 而/ p/ 已经/ 出现/ 在/ 了/ 先前/ 生成/ 的/ 进程/ Pj/ 中/ ./ 这时/ ,/ 我们/ 对/ Pj/ 的/ 内容/ 进行/ 分析/ ,/ 找出/ 所有/ 源自/ 于且/ 仅/ 源自/ 于/ p/ 的/ 变迁/ 、/ 库所/ 和/ 弧/ ,/ 这/ 一部分/ 可以/ 被/ 单独/ 地/ 作为/ 一个/ 进程/ ,/ 记作/ Pk/ ,/ 同时/ p/ 出现/ 在/ Pi/ 和/ Pj/ 的/ 部分/ 也/ 可以/ 用/ Pk/ 来/ 代替/ ./ 通过/ 以上/ 的/ 工作/ ,/ 我们/ 可以/ 从/ 原始/ 的/ 系统/ 表示/ 中/ 得到/ 一系列/ 的/ 进程/ 和/ 虚/ 组件/ ,/ 这些/ 进程/ 和/ 虚/ 组件/ 也/ 有/ 相应/ 的/ Petri/ 网/ 表示/ ./ 图/ 3/ 表示/ 了/ 对/ 图/ 1/ 进行/ 分析/ 后/ 的/ 结果/ ,/ 可以/ 看出/ 所/ 做/ 的/ 工作/ 仅仅/ 是/ 对/ 原图/ 进行/ 了/ 划分/ ,/ 分成/ 几个/ 相对/ 独立/ 的/ 部分/ (/ 当然/ 还要/ 添加/ 一些/ 额外/ 的/ 库/ 所/ 和/ 变迁/ 来/ 保证/ 每/ 部分/ 是/ 正确/ 的/ Petri/ 图/ )/ ./ 在/ 图/ 3/ 中/ ,/ 生成/ 的/ 进程/ 在/ 左边/ ,/ 而/ 虚/ 组件/ 的/ 表示/ 在/ 右边/ ./ R/ (/ process/ )/ =/ E/ ∏/ nD/ (/ process/ ,/ Ci/ )/ =/ ∑/ n/ 这里/ (/ / / )/ 的/ 推导/ 可/ 参考文献/ [/ 20/ ]/ ./ (/ 3/ )/ 利用/ 进程/ 的/ 可靠性/ 来/ 计算/ 整个/ 系统/ 的/ 可靠性/ ./ Page8/ 在/ 大多数/ 情况/ 下/ ,/ 进程/ 之间/ 的/ 关系/ 比较简单/ ,/ 可以/ 用/ 一棵树/ 来/ 表示/ ,/ 在/ 这种/ 情况/ 下/ ,/ 系统/ 的/ 可靠性/ 可以/ 利用/ 前面/ 的/ 方法/ ,/ 按照/ 树/ 的/ 结构/ 自/ 底向上/ 的/ 计算/ 来/ 得到/ ./ 然而/ 在/ 极少数/ 情况/ 下/ ,/ 进程/ 之间/ 的/ 关系/ 比较复杂/ ,/ 很/ 难用/ 一棵树/ 来/ 表示/ ,/ 例如/ ,/ 在/ 图/ 3/ 中/ ,/ 可以/ 看出/ 对/ P1/ 可靠性/ 的/ 计算/ 依赖于/ V2/ 的/ 可靠性/ ,/ 而/ V2/ 可靠性/ 的/ 计算/ 依赖于/ P1/ 的/ 可靠性/ ,/ 这种/ 互相/ 包含/ 以及/ 可能/ 出现/ 的/ 自/ 包含/ 的/ 关系/ 将/ 使得/ 逐层/ 的/ 计算方法/ 束手无策/ ./ 在/ 这种/ 情况/ 下/ ,/ 假设/ 我们/ 用/ Vi/ 来/ 代表/ 虚/ 组件/ ,/ 用/ Pi/ 来/ 表示/ 进程/ ,/ Ci/ 表示/ 各个/ 原子/ 组件/ ,/ 则/ 进程/ 的/ 可靠性/ 计算/ 可以/ 由式/ (/ 11/ )/ 来/ 表示/ ,/ 而/ 虚/ 组件/ 的/ 可靠性/ 可由式/ (/ 6/ )/ 和/ 式/ (/ 10/ )/ 来/ 表示/ ,/ 这样/ ,/ 我们/ 就/ 得到/ 了/ 一个/ 方程组/ :/ R/ (/ P1/ )/ =/ f1/ [/ R/ (/ V1/ )/ ,/ …/ ,/ R/ (/ Vn/ )/ ,/ R/ (/ C1/ )/ ,/ …/ ,/ R/ (/ Cn/ )/ ,/ 烄/ R/ (/ P1/ )/ ,/ …/ ,/ R/ (/ Pn/ )/ ]/ R/ (/ P2/ )/ =/ f2/ [/ R/ (/ V1/ )/ ,/ …/ ,/ R/ (/ Vn/ )/ ,/ R/ (/ C1/ )/ ,/ …/ ,/ R/ (/ Cn/ )/ ,/ R/ (/ P1/ )/ ,/ …/ ,/ R/ (/ Pn/ )/ ]/ R/ (/ Pn/ )/ =/ fn/ [/ R/ (/ V1/ )/ ,/ …/ ,/ R/ (/ Vn/ )/ ,/ R/ (/ C1/ )/ ,/ …/ ,/ R/ (/ Cn/ )/ ,/ 烅/ R/ (/ P1/ )/ ,/ …/ ,/ R/ (/ Pn/ )/ ]/ R/ (/ V1/ )/ =/ g1/ [/ R/ (/ P1/ )/ ,/ …/ ,/ R/ (/ Pn/ )/ ]/ R/ (/ V2/ )/ =/ g2/ [/ R/ (/ P1/ )/ ,/ …/ ,/ R/ (/ Pn/ )/ ]/ R/ (/ Vn/ )/ =/ gn/ [/ R/ (/ P1/ )/ ,/ …/ ,/ R/ (/ Pn/ 烆/ 通过/ 解/ 这个/ 方程组/ ,/ 就/ 可以/ 得到/ 各个/ 虚/ 组件/ 以及/ 进程/ 的/ 信任/ 值/ 了/ ./ 而/ 对/ 重要性/ 的/ 计算/ 也/ 可以/ 采用/ 这种/ 列/ 方程组/ 求解/ 的/ 方式/ ./ 4.2/ ./ 4/ 综合/ 计算/ 前面/ 描述/ 了/ 对/ 各种/ 控制结构/ 进行/ 计算/ 的/ 方法/ ./ 这样/ ,/ 当/ 我们/ 把/ 整个/ 软件/ 的/ 结构/ 用/ 一棵树/ 来/ 表示/ (/ 其中/ 根/ 节点/ 代表/ 整个/ 系统/ ,/ 中间/ 节点/ 表示/ 具有/ 以上/ 各种/ 控制结构/ 的/ 子系统/ ,/ 而叶/ 节点/ 是/ 各个/ 原子/ 组件/ )/ ,/ 就/ 可以/ 按照/ 公式/ 很/ 容易/ 地自/ 底向上/ 计算/ 出/ 整个/ 软件系统/ 的/ 可靠性/ R/ (/ Ω/ )/ ./ 而/ 每个/ 组件/ 的/ 重要性/ 也/ 能/ 很/ 容易/ 地/ 计算出来/ ,/ 假设/ a/ 是/ 一个/ 原子/ 组件/ ,/ 整个/ 系统/ Ω/ 在/ 最上层/ 是/ 由/ 组件/ C1/ ,/ C2/ ,/ …/ ,/ Cn/ 构成/ 的/ ,/ 那么/ 可以/ 利用/ 式/ (/ 12/ )/ 来/ 计算/ a/ 在/ 整个/ 系统/ 中/ 的/ 重要性/ D/ (/ Ω/ ,/ a/ )/ ,/ 这里/ D/ (/ Ci/ ,/ a/ )/ 可以/ 被/ 递归/ 地/ 计算出来/ ./ 4.2/ ./ 5/ 可靠性/ 计算方法/ 小结/ 从/ 上面/ 的/ 分析/ 可以/ 看出/ ,/ 通过/ 对/ 并行/ 结构/ 以先/ 分解/ 再/ 综合/ 的/ 方式/ 进行/ 处理/ ,/ 使得/ 传统/ 的/ 基于/ 状态/ 的/ 评估/ 方法/ 在/ 适用范围/ 上/ 得到/ 了/ 增强/ ./ 而/ 效率/ 方面/ ,/ 对/ 简单/ 子系统/ 的/ 处理/ 中/ ,/ 由于/ 有效/ 地/ 利用/ 了/ 开放/ 环境/ 下/ 系统结构/ 简单/ 清晰/ 的/ 特点/ ,/ 计算/ 复杂度/ 是/ O/ (/ n/ )/ (/ n/ 是/ 组件/ 的/ 个数/ )/ ;/ 而/ 对/ 复杂/ 子系统/ 处理/ 中/ ,/ 采用/ 的/ 是/ 基于/ 状态/ 的/ 评估/ 方法/ ,/ 因而/ 计算/ 复杂度/ 依然/ 是/ O/ (/ n3/ )/ ,/ 这是/ 由于/ 主要/ 的/ 资源/ 会/ 被/ 消耗/ 在/ 逆/ 矩阵/ 的/ 计算/ 上/ ./ 由于/ 在/ 整个/ 系统/ 中/ ,/ 复杂/ 子系统/ 出现/ 的/ 概率/ 比较/ 低/ ,/ 因此/ 可以/ 近似/ 地/ 认为/ 整个/ 方法/ 的/ 复杂度/ 是/ 线性/ 的/ ,/ 这样/ ,/ 就/ 比/ 单纯/ 地/ 采用/ 基于/ 状态/ 的/ 方法/ 要/ 高效/ 得/ 多/ ./ 这个/ 方法/ 同时/ 也/ 非常适合/ 于/ 多变/ 的/ 开放/ 环境/ 所/ 要求/ 的/ 增量/ 更新/ ./ 当/ 某个/ 组件/ 的/ 可靠性/ 发生/ 了/ 变化/ ,/ 这时/ 只/ 需要/ 对/ 代表/ 那个/ 组件/ 的/ 叶/ 节点/ 到/ 根/ 的/ 路径/ 进行/ 重新/ 计算/ ,/ 因而/ 计算/ 复杂度/ 是/ O/ (/ logn/ )/ ,/ 而/ 在/ 传统/ 的/ 方法/ 中/ ,/ 则/ 往往/ 需要/ 从头开始/ 计算/ ;/ 同时/ ,/ 我们/ 可以/ 忽视/ 那些/ 重要性/ 较/ 低/ 的/ 节点/ 的/ 变化/ ,/ 因为/ 它们/ 的/ 改变/ 不会/ 对系统/ 造成/ 实质性/ 的/ 影响/ ,/ 这/ 一点/ 在/ 我们/ 的/ 实验/ 结果/ 中/ 可以/ 看出/ ,/ 通过/ 这种/ 集中/ 注意力/ 在/ 少数/ 组件/ 上/ 的/ 方式/ ,/ 可以/ 进一步/ 增强/ 增量/ 更新/ 的/ 效率/ ./ 而/ 当/ 系统/ 的/ 结构/ 发生/ 了/ 改变/ ,/ 如果/ 这个/ 变动/ 较/ 小/ ,/ 那么/ 只/ 需要/ 对/ 包含/ 这部分/ 结构/ 的/ 子树/ 进行/ 重新/ 估算/ 即可/ ,/ 这样/ 只/ 需要/ 做/ 少量/ 的/ 工作/ ./ 而/ 最差/ 情况/ 下/ ,/ 系统/ 的/ 结构/ 变动/ 非常/ 大/ ,/ 这时/ 就/ 必须/ 要/ 对/ 整个/ 系统/ 进行/ 重新/ 评估/ ./ 5/ 实验/ 与/ 分析/ 本节/ 将/ 针对/ 图/ 1/ 所/ 表示/ 的/ 系统/ 给出/ 可靠性/ 评估/ 的/ 示例/ ,/ 计算/ 出/ 系统/ 的/ 可靠性/ 和/ 各个/ 组件/ 的/ 重要性/ ,/ 并/ 对/ 结果/ 加以分析/ ,/ 以/ 考察/ 本文/ 所/ 提出/ 方法/ 的/ 正确性/ 和/ 有效性/ ./ 在/ 这个/ 例子/ 中/ ,/ 位于/ 上面/ 部分/ 的/ 并行/ 定义/ 为/ 一个/ 与/ 并行/ ,/ 而/ 下面/ 一个/ 定义/ 为/ 或/ 并行/ ,/ 这样/ 这个/ 例子/ 就/ 包括/ 了/ 各种/ 控制结构/ ./ 可以/ 看出/ ,/ 该/ 系统/ 最/ 顶层/ 的/ 结构/ 是/ 非常复杂/ 的/ ,/ 所以/ 我们/ 对/ 其/ 采用/ 复杂/ 子系统/ 的/ 计算方法/ ./ 在/ 进行/ 了/ 第/ 1/ 步/ 的/ 工作/ 后/ ,/ 我们/ 可以/ 得到/ 如图/ 3/ 所示/ 的/ 一些/ 进程/ 和/ 虚/ 组件/ ,/ 其中/ P1/ ,/ P2/ ,/ P3/ 和/ V1/ 的/ 结构/ 都/ 比较/ 清晰/ ,/ 可以/ 用/ 简单/ 子系统/ 的/ 计算方法/ 来/ 处理/ ;/ 而/ P4/ 的/ 结构/ 并/ 不/ 清晰/ ,/ 但/ 其/ 没有/ 并行/ 部分/ ,/ 因此/ 可以/ 直接/ 采用/ 复杂/ 子系统/ 计算方法/ 中/ 的/ 第/ 2/ 部分/ 来/ 进行/ 计算/ ./ 假设/ 每个/ 组件/ 的/ 可靠性/ 为/ 0.9/ ,/ 那么/ 我们/ 可以/ 构造/ 出/ 代表/ P1/ (/ 即/ 整个/ 系统/ )/ 的/ 一棵树/ 来/ ,/ 如图/ 4/ 所示/ ./ 通过/ 自/ 底向上/ 的/ 计算/ ,/ 我们/ 得到/ 树中/ 各个/ 内/ 节点/ 的/ 可靠性/ 表示/ ,/ 并标/ 在/ 每个/ 节点/ 的/ 旁边/ ./ 最后/ ,/ 我们/ Page9/ 可以/ 得到/ P1/ 的/ 可靠性/ ,/ 即/ 接下来/ 对/ P4/ 进行/ 处理/ ,/ 通过/ 计算/ 我们/ 可以/ 得到/ t4/ ,/ t5/ ,/ t6/ 和/ t7/ 的/ 平均/ 执行/ 次数/ 分别/ 为/ 1.9375/ ,/ 3.125/ ,/ 1.25/ ,/ 1/ ./ 这样/ ,/ P4/ 的/ 可靠性/ 可以/ 用式/ (/ 11/ )/ 来/ 计算/ ,/ 结果/ 为/ 0.4628/ ./ 同时/ ,/ V2/ 的/ 可靠性/ 可以/ 用式/ (/ 10/ )/ 计算/ ,/ 结果/ 为/ R/ (/ V2/ )/ =/ 1/ -/ (/ 1/ -/ 0.4628/ )/ ×/ (/ 1/ -/ R/ (/ P1/ )/ )/ 式/ (/ 13/ )/ 和/ 式/ (/ 14/ )/ 构成/ 了/ 一个/ 方程组/ ,/ 通过/ 简单/ 的/ 计算/ ,/ 我们/ 可以/ 得到/ 最终/ 系统/ 的/ 可靠性/ 为/ 0.6326/ ,/ 这/ 与/ 模拟实验/ 中/ 得到/ 的/ 结果/ 0.6393/ 非常/ 接近/ ,/ 这/ 说明/ 整个/ 方法/ 在/ 提高/ 了/ 效率/ 的/ 同时/ ,/ 只会/ 引起/ 很小/ 幅度/ 的/ 精确度/ 下降/ ./ 而/ 组件/ 重要性/ 也/ 可以/ 用/ 类似/ 的/ 方法/ 计算出来/ ,/ 表/ 1/ 列出/ 了/ 计算/ 得出/ 的/ 每个/ 组件/ 的/ 重要性/ ./ 可以/ 发现/ ,/ 这些/ 结果/ 与/ 我们/ 的/ 直观/ 感觉/ 保持一致/ ,/ t2/ 比/ t3/ 执行/ 得/ 更加/ 频繁/ ,/ 因而/ 具有/ 较/ 高/ 的/ 重要性/ ;/ t6/ 是/ 在/ 一个/ or/ 并行/ 结构/ 里面/ ,/ 而/ 这个/ 结构/ 通常/ 是/ 用作/ 冗余/ 备份/ 的/ ,/ 从而/ 可以/ 减轻/ 其/ 组件/ 失效/ 的/ 影响/ ,/ 可以/ 从表/ 1/ 中/ 看出/ ,/ t6/ 的/ 重要性/ 要/ 相对/ 于/ 其它/ 组件/ 低得/ 多/ ;/ 在/ 表格/ 的/ 第/ 3/ 行/ 描述/ 了/ 当/ 某个/ 组件/ 的/ 可靠性/ 改善/ 5/ %/ 之后/ 整个/ 系统可靠性/ 的/ 提升/ 幅度/ ,/ 可以/ 看出/ 对/ 重要性/ 高/ 的/ 组件/ 的/ 改进/ 会/ 给/ 系统可靠性/ 带来/ 更大/ 的/ 提高/ ,/ 同/ 组件/ t1t2t3t4t5t6t7t8/ 时/ 那些/ 重要性/ 比较/ 低/ 的/ 一些/ 组件/ (/ 如/ t6/ 和/ t7/ )/ 对系统/ 的/ 影响/ 很/ 微小/ ,/ 因而/ 可以/ 在/ 更新/ 计算/ 中/ 省略/ ,/ 这能/ 减轻/ 系统监控/ 的/ 负担/ ,/ 并/ 节省/ 计算资源/ ./ 图/ 5/ 和/ 图/ 6/ 进一步/ 分析/ 了/ 重要性/ 这一/ 参数/ ./ 图/ 5/ 表示/ 了/ 当/ t2/ 的/ 可靠性/ 增加/ 时/ ,/ 其/ 与/ t3/ 的/ 重要性/ 比值/ 会/ 不断/ 下降/ ,/ 这/ 反映/ 了/ 较/ 低/ 可靠性/ 的/ 组件/ 会/ 拥有/ 较/ 高/ 的/ 相对/ 重要性/ 的/ 事实/ ,/ 因为/ 这种/ 组件/ 比较/ 容易/ 成为/ 整个/ 系统/ 的/ 瓶颈/ ;/ 图/ 6/ 则/ 显示/ 了/ 在/ t2/ 的/ 执行/ 次数/ 增加/ 时/ ,/ 其/ 与/ t3/ 的/ 重要性/ 比值/ 会/ 不断/ 上升/ ,/ 这/ 就/ 进一步/ 验证/ 了/ 组件/ 重要性/ 与其/ 执行/ 次数/ 的/ 关系/ ./ 从/ 这/ 两张/ 图/ 可以/ 看出/ ,/ 我们/ 的/ 组件/ 重要性/ 这一/ 评估/ 结果/ 是/ 综合/ 考虑/ 了/ 组件/ 可靠性/ 和/ 其/ 运行/ 次数/ 这/ 两个/ 方面/ 的/ ./ 6/ 总结/ 与/ 展望/ 现有/ 软件系统/ 的/ 运行/ 环境/ 逐渐/ 朝着/ 更加/ 开放/ 的/ 方向/ 发展/ ,/ 在/ 这种/ 情况/ 下/ 如何/ 对/ 软件/ 的/ 可靠性/ 进行/ 快速/ 有效/ 的/ 衡量/ 成为/ 一个/ 急需解决/ 的/ 问题/ ./ 本文/ 首先/ 对/ 传统/ 软件可靠性/ 评估/ 方法/ 的/ 应用/ 范围/ 和/ 效率/ 等/ 方面/ 在/ 新形势下/ 的/ 不足/ 进行/ 了/ 分析/ ,/ 然后/ 提出/ 了/ 利用/ Petri/ 网来/ 作为/ 软件体系结构/ 描述/ 的/ 工具/ ,/ 并/ 对/ 传统/ 的/ 基于/ 状态/ 的/ 可靠性/ 评估/ 方法/ 加以改进/ 的/ 思路/ ,/ 最终/ 得到/ 了/ 一个/ 能/ 处理/ 具有/ 各种/ 控制结构/ 的/ 软件系统/ 的/ 方法/ ,/ 该/ 方法/ 不但/ 能/ 快速/ 并/ 准确/ 地/ 得到/ 评估/ 结果/ ,/ 同时/ 还/ 能/ 产生/ 对/ 组件/ 重要性/ 的/ 衡量/ ,/ 来/ 为/ 系统/ 的/ 分析/ 和/ 优化/ 提供/ 更/ 多/ 的/ 参考/ ./ Page10/ 在/ 今后/ 的/ 工作/ 中/ ,/ 还/ 需要/ 通过/ 实际/ 项目/ 中/ 的/ 应用/ 来/ 进一步/ 检验/ 该/ 方法/ 的/ 有效性/ 和/ 可操作性/ ;/ 同时/ ,/ 还/ 需要/ 研究/ 如何/ 获取/ 软件/ 运行/ 行为/ 的/ 动态/ 信息/ ,/ 从而/ 对系统/ 的/ 评估/ 结果/ 进行/ 实时/ 更新/ ,/ 使/ 其/ 能够/ 及时/ 地/ 反映/ 组件/ 和/ 体系结构/ 的/ 变化/ ;/ 此外/ ,/ 本文/ 给出/ 了/ 组件/ 重要性/ 这一/ 评估/ 结果/ ,/ 如何/ 利用/ 其来/ 对系统/ 进行/ 优化/ 和/ 改进/ 也/ 是/ 一个/ 可以/ 深入研究/ 的/ 方向/ ./ 

