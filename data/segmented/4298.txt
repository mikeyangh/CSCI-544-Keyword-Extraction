Page1/ 基于/ 页/ 着色/ 的/ 多/ 核/ 处理器/ 共享/ Cache/ 动态/ 分区/ 张栌/ 丹/ 1/ )/ 王锐/ 1/ )/ ,/ 2/ )/ 刘轶/ 1/ )/ ,/ 2/ )/ 钱德沛/ 1/ )/ ,/ 2/ )/ 1/ )/ (/ 北京航空航天大学/ 计算机/ 学院/ 中/ 德/ 联合/ 软件技术/ 研究所/ 北京/ 100091/ )/ 2/ )/ (/ 北京航空航天大学/ 计算机/ 学院/ 北京市/ 网络/ 技术/ 重点/ 实验室/ 北京/ 100091/ )/ 摘要/ 随着/ 多核/ // 众核/ 成为/ 处理器/ 结构/ 发展/ 的/ 主流/ ,/ 并行任务/ 间/ 共享/ 地/ 使用/ Cache/ 而/ 导致/ 的/ 冲突/ 越来越/ 成为/ 性能/ 提升/ 的/ 瓶颈/ ./ 利用/ 页/ 着色/ 可以/ 实现/ 对/ Cache/ 的/ 分区/ 管理/ ,/ 减少/ 共享/ Cache/ 导致/ 的/ 冲突/ ./ 页/ 着色/ 的/ 原理/ 是/ 利用/ 内存/ 与/ Cache/ 之间/ 的/ 组/ 相联/ 映射/ 关系/ ,/ 通过/ 控制/ 分配/ 固定/ 区域/ 的/ 内存/ 而/ 达到/ 分配/ 固定/ 区域/ Cache/ 的/ 目的/ ,/ 这/ 一方面/ 限制/ 了/ 任务/ 能够/ 请求/ 的/ 物理/ 内存/ 范围/ ,/ 另一方面/ 调整/ 程序/ 使用/ 的/ Cache/ 空间/ 需要/ 做/ 大量/ 的/ 内存/ 拷贝/ ,/ 带来/ 了/ 不可/ 忽视/ 的/ 开销/ ./ 为了/ 克服/ 页/ 着色/ 的/ 缺点/ ,/ 文中/ 通过/ 动态内存/ 分配/ 的/ 方式/ ,/ 只/ 对/ 动态分配/ 的/ 页/ 进行/ 着色/ ,/ 在/ 不/ 修改/ 内核/ 和/ 程序/ 源码/ 的/ 前提/ 下/ 实现/ 了/ 动态/ Cache/ 分区/ ./ 文中/ 提出/ 的/ 动态内存/ 分配/ 策略/ (/ CachePM/ )/ 会/ 根据/ 运行/ 时/ 环境/ 为/ 任务/ 分配内存/ ,/ 避免/ 不同/ 任务/ 间/ 共享/ Cache/ 的/ 冲突/ 和/ 同一/ 任务/ 内/ 出现/ Cache/ 的/ 访问/ 热点/ ,/ 通过/ 合理/ 划分/ 程序运行/ 时/ 动态分配/ 的/ 内存/ 达到/ Cache/ 分区/ 的/ 目的/ ./ 当/ 任务/ 的/ 运行/ 环境/ 改变/ 时/ ,/ CachePM/ 自/ 适应/ 地/ 改变/ 已经/ 分配/ 的/ 堆/ 中/ 数据/ 在/ 物理/ 内存/ 中/ 的/ 布局/ ,/ 以/ 实现/ Cache/ 分区/ 的/ 动态/ 调节/ ./ 为/ 进一步/ 降低/ 动态/ 页/ 着色/ 的/ 开销/ ,/ 作者/ 采用/ 了/ 减少/ 和/ 延迟/ 内存/ 拷贝/ 的/ 策略/ ./ 实验/ 表明/ ,/ 该/ 方法/ 能够/ 有效/ 实现/ 动态/ Cache/ 分区/ ,/ 从而/ 提高/ 并行/ 运行/ 的/ 任务/ 的/ 性能/ ;/ 同时/ 由于/ 动态内存/ 分配/ 策略/ 避免/ 了/ 同一/ 任务/ 内/ 出现/ Cache/ 访问/ 热点/ ,/ 单独/ 运行/ 的/ 任务/ 的/ 性能/ 也/ 较/ 在/ libc/ 下/ 运行/ 有所/ 提升/ ./ 关键词/ Cache/ 分区/ ;/ 动态/ 页/ 着色/ ;/ 动态内存/ 分配/ 1/ 引言/ 近年来/ ,/ 在/ 一个/ 芯片/ 内/ 集成/ 多个/ 处理器/ 核已/ 成为/ 处理器/ 发展/ 的/ 主要/ 趋势/ ./ 在/ 这种/ 多核/ 处理器/ 中/ ,/ 多种/ 应用/ 会/ 同时/ 运行/ ,/ 共享/ 芯片/ 内/ 的/ Cache/ 、/ 片上/ 网络/ 、/ I/ // O/ 通道/ 等/ 资源/ ./ 多个/ 同时/ 运行/ 的/ 任务/ 在/ 访问共享/ 资源/ 时会/ 相互/ 干扰/ ,/ 可能/ 导致/ 资源/ 不能/ 被/ 充分利用/ ,/ 而/ 使/ 任务/ 性能/ 下降/ ./ Cache/ 是/ 片/ 内/ 的/ 主要/ 共享资源/ 之一/ ,/ 对/ Cache/ 的/ 使用/ 效率/ 直接/ 影响/ 应用程序/ 的/ 性能/ ./ 例如/ ,/ 不同/ 进程/ // 线程/ 访问/ 不同/ 的/ 数据/ 集合/ ,/ 可能/ 导致/ 共享/ Cache/ 中/ 的/ 数据/ 频繁/ 换入/ // 换/ 出/ ,/ 这/ 将/ 降低/ Cache/ 命中率/ ,/ 进而/ 导致/ 它们/ 对/ 内存/ 带宽/ 和/ 总线/ 带宽/ 的/ 争抢/ ,/ 使得/ 系统/ 性能/ 下降/ ./ 因此/ 高效/ 管理/ 片上/ 共享/ Cache/ 资源/ 是/ 提高/ 多核/ 处理器/ 系统/ 性能/ 的/ 关键点/ 之一/ ./ 由于/ Cache/ 对/ 软件/ 是/ 不/ 可见/ 的/ ,/ 所以/ 一些/ 研究/ 开始/ 利用/ 物理/ 内存/ 到/ Cache/ 之间/ 的/ 组/ 相联/ 映射/ 关系/ ,/ 通过/ 操作系统/ 的/ 页/ 着色/ 来/ 间接/ 地/ 实现/ Cache/ 分区/ [/ 1/ -/ 2/ ]/ ./ 页/ 着色/ 是/ 利用/ 存储器/ 与/ Cache/ 的/ 组/ 相联/ 映射/ 关系/ ,/ 把/ 操作系统/ 的/ 页/ 划分/ 为/ 多种/ 颜色/ ,/ 同种/ 颜色/ 的/ 内存/ 页/ 将/ 会/ 映射/ 到/ 相同/ 的/ Cache/ 区域/ 中/ ,/ 而/ 不同/ 颜色/ 的/ 内存/ 页/ 对/ Cache/ 的/ 使用/ 没有/ 重叠/ ./ 通过/ 给/ 应用程序/ 分配/ 特定/ 颜色/ 的/ 页/ ,/ 使得/ 操作系统/ 可以/ 控制/ 应用/ 访问/ 的/ Cache/ 区域/ ./ 然而/ 利用/ 页/ 着色/ 来/ 管理/ 共享/ Cache/ 有/ 不可/ 忽视/ 的/ 缺点/ [/ 3/ ]/ ./ 一方面/ ,/ 页/ 着色/ 限制/ 了/ 任务/ 能够/ 请求/ 的/ 物理/ 内存/ 范围/ ,/ 即/ 限制/ 了/ 任务/ 可以/ 请求/ 的/ 页/ 帧/ 的/ 数量/ ./ 如果/ 任务/ 的/ 物理/ 内存不足/ ,/ 因为/ Cache/ 分区/ 大小/ 的/ 限制/ ,/ 即使/ 还有/ 可用/ 的/ 内存/ ,/ 也/ 不能/ 被/ 分配/ 给/ 其它/ 颜色/ 的/ 物理/ 页/ ,/ 使/ 应用/ 性能/ 下降/ ./ 另一方面/ ,/ 调整/ 任务/ Cache/ 分区/ 的/ 大小/ 是/ 通过/ 改变/ 已经/ 分配/ 的/ 页面/ 颜色/ 实现/ ,/ 需要/ 将/ 应用/ 的/ 数据/ 拷贝到/ 另/ 一部分/ 颜色/ 集合/ 的/ 物理/ 页/ 上/ ,/ 涉及/ 到/ 大量/ 的/ 数据/ 移动/ 操作/ ,/ 如果/ 频繁/ 改变/ Cache/ 分区/ 会/ 带来/ 很大/ 的/ 开销/ ,/ Cache/ 分区/ 所/ 带来/ 的/ 性能/ 提升/ 将/ 不足以/ 抵消/ 这/ 一部分/ 开销/ ,/ 因而/ 利用/ 页/ 着色/ 实现/ 的/ Cache/ 分区/ 制约/ 了/ Cache/ 分区/ 策略/ 的/ 灵活性/ ./ 利用/ 页/ 着色/ 修改/ 内核/ 以/ 改变/ 操作系统/ 默认/ 的/ 内存/ 管理/ 方式/ 来/ 实现/ Cache/ 分区/ 可能/ 反而/ 会/ 影响/ 普通/ 程序/ 的/ 性能/ ,/ 仅/ 适应/ 于/ 研究/ 目的/ ./ 目前/ 很多/ 相关/ 研究/ 都/ 是/ 通过/ 修改/ 操作系统/ 内核/ 实现/ ,/ 文献/ [/ 1/ ]/ 引入/ 页/ 着色/ ,/ 提供/ 了/ 一种/ 在/ 实际/ 硬件/ 上/ 研究/ 和/ 验证/ Cache/ 分区/ 算法/ 的/ 方式/ ,/ 在/ 验证/ 时/ ,/ 需要/ 在/ 计算/ 分区/ 效果/ 时/ 把/ 页/ 着色/ 的/ 开销/ 忽略/ 掉/ ./ 目前/ 的/ 软件/ Cache/ 分区/ 方法/ 还/ 不/ 具备/ 通用性/ ./ 实现/ Cache/ 动态/ 分区/ 的/ 主要/ 难点/ 在于/ ,/ 如何/ 不/ 修改/ 操作系统/ 内核/ 及/ 应用程序/ 源代码/ 就/ 能/ 实现/ 分区/ 以及/ 如何/ 降低/ 动态/ 页/ 着色/ 带来/ 的/ 开销/ ./ 应用程序/ 在/ 运行/ 时/ 分配/ 的/ 动态内存/ (/ 堆/ )/ 中/ 的/ 数据/ 是/ 造成/ 共享/ Cache/ 冲突/ 的/ 重要/ 来源/ 之一/ ./ 目前/ 通用/ 的/ 动态内存/ 分配/ 库/ (/ libc/ )/ ,/ 主要/ 关注/ 的/ 是/ 分配器/ 本身/ 的/ 性能/ ,/ 而/ 忽略/ 了/ 动态分配/ 的/ 内存/ 对/ 任务/ Cache/ 性能/ 的/ 影响/ ./ 对/ 单个/ 任务/ 来说/ ,/ 由于/ Cache/ 的/ 组/ 相联/ 映射/ ,/ 所/ 分配/ 的/ 数据/ 可能/ 都/ 被/ 映射/ 到/ Cache/ 的/ 一小部分/ 区域/ ,/ 导致/ 这个/ Cache/ 区域/ 成为/ 热点/ ,/ 而/ 别的/ 区域/ 没有/ 被/ 充分利用/ ,/ 因而/ 大量/ 的/ 缓存/ 扑空/ (/ CacheMiss/ )/ 发生/ 在/ 这个/ 热点/ Cache/ 区域/ 中/ ./ 当/ 多个/ 任务/ 共享/ Cache/ 运行/ 时/ ,/ 它们/ 动态/ 请求/ 的/ 内存/ 可能/ 被/ 映射/ 到/ 相同/ 的/ Cache/ 区域/ 中/ ,/ 也/ 会/ 导致/ 冲突/ 缓存/ 扑空/ ./ 因此/ ,/ 通过/ 设计/ 合理/ 的/ 动态内存/ 分配/ 策略/ ,/ 能够/ 达到/ 降低/ Cache/ 冲突/ 的/ 目的/ ./ 因此/ ,/ 本文/ 通过/ 动态内存/ 分配/ 的/ 方式/ ,/ 只/ 对/ 动态分配/ 的/ 页/ 进行/ 着色/ ,/ 实现/ 了/ 动态/ Cache/ 分区/ ./ 只/ 对/ 运行/ 时/ 动态/ 请求/ 的/ 内存/ 进行/ 着色/ 能够/ 缓解/ 可/ 分配/ 的/ 内存/ 数量/ 限制/ ,/ 并/ 减少/ 改变/ Cache/ 分区/ 时/ 内存/ 拷贝/ 的/ 开销/ ./ 本文/ 提出/ 的/ 动态内存/ 分配/ 策略/ (/ CachePM/ )/ 会/ 根据/ 运行/ 时/ 环境/ 为/ 任务/ 分配内存/ ,/ 避免/ 不同/ 任务/ 间/ 共享/ Cache/ 的/ 冲突/ 和/ 同一/ 任务/ 内/ 出现/ Cache/ 的/ 访问/ 热点/ ,/ 通过/ 合理/ 划分/ 程序运行/ 时/ 动态分配/ 的/ 内存/ 区域/ 达到/ Cache/ 分区/ 的/ 目的/ ./ 当/ 任务/ 的/ 运行/ 环境/ 改变/ 时/ ,/ CachePM/ 自/ 适应/ 地/ 改变/ 已经/ 分配/ 的/ 堆/ 中/ 数据/ 在/ 物理/ 内存/ 中/ 的/ 布局/ ,/ 以/ 实现/ Cache/ 分区/ 的/ 动态/ 调节/ ./ 为了/ 进一步/ 降低/ 动态/ 页/ 着色/ 的/ 开销/ ,/ 本文/ 通过/ 最小/ 距离/ 数据/ 移动/ 策略/ 来/ 减少/ 内存/ 拷贝/ 次数/ ,/ 利用/ 延迟/ 数据/ 移动/ 的/ 策略/ 避免/ 不必要/ 的/ 数据/ 移动/ ./ 实验/ 表明/ ,/ CachePM/ 能够/ 有效/ 实现/ 共享/ Cache/ 的/ 分区/ 和/ 动态/ 调整/ ,/ 从而/ 提高/ 并行任务/ 的/ 性能/ ;/ 对/ 单个/ 任务/ 由于/ 使/ 其/ 数据分布/ 到/ 整个/ Cache/ 区域/ ,/ 避免/ 了/ 局部/ Cache/ 区域/ 成为/ 热点/ ,/ 提高/ 了/ Cache/ 利用率/ ,/ 单独/ 运行/ 时/ 的/ 性能/ 也/ 较/ 在/ libc/ 下/ 运行/ 有所/ 提升/ ./ 本文/ 第/ 2/ 节/ 介绍/ 本文/ 的/ 相关/ 工作/ 和/ 背景/ ;/ 第/ 3/ 节/ 详细/ 介绍/ 动态内存/ 分配/ 策略/ ,/ Cache/ 分区/ 动态/ 调整/ 策略/ 以及/ 降低/ 重/ 着色/ 开销/ 的/ 策略/ ;/ 第/ 4/ 节/ 通过/ 实验/ 评估/ CachePM/ 对/ 程序/ 性能/ 提升/ 的/ 效果/ ;/ 最后/ 在/ 第/ 5/ 节/ 进行/ 总结/ ./ 2/ 相关/ 工作/ 2.1/ 页/ 着色/ 在/ 组/ 相联/ 映射/ 的/ Cache/ 中/ ,/ 根据/ 物理地址/ 中间/ Page3/ 的/ 一些/ 位/ 确定/ 映射/ 到/ 的/ Cache/ 组/ ,/ 这些/ 物理/ 页/ 号/ 和/ Cache/ 组号/ 之间/ 的/ 公共/ 位所/ 代表/ 的/ 就是/ 页面/ 的/ 颜色/ (/ 图/ 1/ )/ ./ 页/ 着色/ 利用/ 页面/ 的/ 颜色/ 来/ 控制/ 虚拟内存/ 页/ 到/ 处理器/ Cache/ 块/ 的/ 映射/ ./ 通过/ 控制/ 分配/ 给/ 进程/ 的/ 物理/ 页/ 的/ 颜色/ ,/ 就/ 能够/ 以页/ 为/ 粒度/ 来/ 控制/ 进程/ 的/ 数据/ 映射/ 到/ Cache/ 中/ 的/ 具体位置/ ./ 页/ 着色/ 技术/ 最早/ 被/ 用来/ 保证/ 程序/ 的/ 性能/ 稳定性/ ,/ 文献/ [/ 4/ -/ 6/ ]/ 利用/ 页/ 着色/ 提高/ 单个/ 程序/ 的/ 性能/ ,/ 近年来/ 页/ 着色/ 技术/ 开始/ 被/ 应用/ 到/ Cache/ 分区/ 中/ [/ 1/ -/ 2/ ]/ ./ 与/ 页/ 着色/ 相关/ 的/ 是/ 动态/ 重/ 着色/ ,/ 即/ 为/ 页面/ 分配/ 新/ 的/ 颜色/ ./ 动态/ 重/ 着色/ 可以/ 改变/ 进程/ 在/ 内存/ 中/ 的/ 存储/ 位置/ ,/ 进而/ 改变/ 进程/ 访问/ 的/ Cache/ 区域/ ,/ 实现/ 动态/ Cache/ 分区/ ./ 但是/ 这一/ 操作/ 涉及/ 到/ 了/ 内存/ 拷贝/ (/ 数据/ 移动/ )/ ,/ 其/ 带来/ 的/ 开销/ 不可/ 忽视/ ./ 2.2/ 软件/ Cache/ 分区/ 软件/ Cache/ 分区/ 即/ 利用/ 页/ 着色/ 原理/ 来/ 降低/ 共享/ Cache/ 的/ 冲突/ ./ 张晓东/ 等/ 人/ [/ 1/ ]/ 提出/ ,/ 尽管/ 用页/ 着色/ 实现/ 的/ 动态/ Cache/ 分区/ 的/ 开销/ 不可/ 忽略/ ,/ 但是/ 软件/ Cache/ 分区/ 使得/ 在/ 实际/ 机器/ 上/ 研究/ Cache/ 分区/ 策略/ 成为/ 可能/ ,/ 这比/ 在/ 模拟器/ 上/ 研究/ 更/ 有/ 参考价值/ ./ ULCC/ [/ 7/ ]/ 则/ 是/ 一个/ 软件/ 库/ ,/ 程序员/ 可以/ 利用/ ULCC/ 提供/ 的/ 库函数/ 来/ 管理/ 和/ 优化/ 对多核/ 的/ 共享/ Cache/ 的/ 使用/ ./ 然而/ 利用/ ULCC/ 管理/ 多核/ Cache/ 一方面/ 需要/ 修改/ 代码/ ,/ 对/ 程序员/ 提出/ 了/ 较/ 高/ 的/ 要求/ ,/ 另一方面/ 分区/ 是/ 静态/ 的/ ./ Soft/ -/ OLP/ [/ 8/ ]/ 则/ 是/ 一个/ 对象/ 级/ 的/ Cache/ 分区/ 工具/ ,/ 它/ 利用/ 二进制/ 插桩/ 来/ 计算/ 对象/ 的/ 重用/ 距离/ ,/ 并/ 以此/ 作为/ 分区/ 的/ 依据/ ./ 然而/ 二进制/ 插桩/ 会/ 使得/ 程序/ 变慢/ 很多/ ,/ Soft/ -/ OLP/ 依然/ 不/ 具有/ 通用性/ ./ 文献/ [/ 3/ ]/ 则/ 针对/ 页/ 着色/ 本身/ 的/ 缺点/ 对/ 软件/ Cache/ 分区/ 的/ 实现/ 进行/ 了/ 优化/ ,/ 当/ 需要/ 重/ 着色/ 时/ ,/ 他们/ 通过/ 遍历/ 页表/ ,/ 来/ 确定/ 经常/ 被/ 访问/ 的/ 页/ ,/ 然后/ 只/ 对/ 最常/ 被/ 访问/ 的/ N/ 个页/ 进行/ 重/ 着色/ ,/ 这样/ 能够/ 减少/ 重/ 着色/ 的/ 开销/ ./ 然而/ 这/ 也/ 需要/ 修改/ 内核/ 和/ 页表/ 项/ ,/ 且/ 遍历/ 页表/ 的/ 开销/ 也/ 不可/ 忽视/ ./ 因此/ 他/ 的/ 重点/ 是/ 确定/ 页/ 的/ 热度/ 以及/ 降低/ 遍历/ 页表/ 的/ 开销/ ./ 与/ 本文/ 工作/ 在/ 实现/ 方式/ 上/ 比较/ 接近/ 的/ 是/ Swann/ 的/ Ccontrol/ [/ 9/ ]/ ,/ Ccontrol/ 提供/ 了/ 静态/ Cache/ 分区/ 的/ 功能/ ,/ 但是/ 不/ 支持/ 动态/ 分区/ 且/ 需要/ 用户/ 指定/ 分配/ Cache/ 大小/ 以及/ 分配/ 的/ 内存/ 的/ 大小/ ,/ 这个/ 软件/ 本身/ 没有/ 包括/ 任何/ 分区/ 策略/ ./ CachePM/ 相对/ 于/ Ccontrol/ 的/ 优势/ 主要/ 包括/ 了/ :/ (/ 1/ )/ CachePM/ 支持/ 自/ 适应/ 的/ 动态/ 分区/ ;/ (/ 2/ )/ Ccontrol/ 需要/ 预先/ 为/ 任务/ 预留/ 足够/ 的/ 内存/ ,/ 在/ 运行/ 时/ 内存/ 不够/ 用/ 也/ 不能/ 扩展/ 内存/ ,/ 而/ CachePM/ 不必/ 事先/ 预留/ ,/ 能够/ 动态/ 按需分配/ ,/ 这样/ 资源/ 利用率/ 高/ ,/ 灵活性/ 好/ ;/ (/ 3/ )/ CachePM/ 分配/ 的/ 内存/ 是/ 与/ 8/ 字节/ 对齐/ 的/ ,/ 而/ Ccontrol/ 分配/ 的/ 内存/ 是/ 4/ 字节/ 对齐/ 的/ ,/ 8/ 字节/ 对齐/ 能够/ 提高/ 读取数据/ 的/ 效率/ ./ 与/ 现有/ 工作/ 相比/ ,/ 本/ 论文/ 工作/ 的/ 特点/ 在于/ ,/ 首先/ ,/ 在/ 不/ 修改/ 内核/ 和/ 程序/ 源码/ 的/ 前提/ 下/ 实现/ 了/ 动态/ Cache/ 分区/ ;/ 其次/ ,/ 为了/ 克服/ 页/ 着色/ 的/ 缺点/ ,/ 通过/ 动态内存/ 分配/ 的/ 方式/ ,/ 只/ 对/ 部分/ 经常/ 访问/ 的/ 页/ 进行/ 着色/ ;/ 再次/ ,/ 提出/ 了/ 降低/ 动态/ 重/ 着色/ 开销/ 的/ 策略/ ,/ 使得/ 基于/ 页/ 着色/ 的/ Cache/ 分区/ 更/ 有/ 实用价值/ ./ 3/ 运行/ 时/ 共享/ Cache/ 管理/ CachePM/ 主要/ 包括/ 了/ 动态内存/ 分配/ 策略/ 和/ Cache/ 分区/ 动态/ 调整/ 策略/ ./ 首先/ ,/ CachePM/ 会/ 根据/ 运行/ 时/ 环境/ 为/ 任务/ 分配内存/ ,/ 避免/ 不同/ 任务/ 间/ 共享/ Cache/ 导致/ 的/ 冲突/ 和/ 同一/ 任务/ 内/ 出现/ Cache/ 的/ 访问/ 热点/ ./ 在/ 需要/ 调整/ Cache/ 分区/ 时/ ,/ 自/ 适应/ 地/ 改变/ 已经/ 分配/ 的/ 堆/ 中/ 数据/ 在/ 物理/ 内存/ 中/ 的/ 布局/ ./ 为了/ 不/ 修改/ 内核/ ,/ 我们/ 首先/ 通过/ 可/ 加载/ 的/ 内核模块/ 将/ 物理/ 页/ 按/ 不同/ 颜色/ 来/ 管理/ ,/ 并/ 为/ 用户/ 态/ 提供/ 了/ 实现/ 动态/ 页/ 着色/ 的/ 接口/ ./ 为了/ 不/ 修改/ 程序/ 源代码/ ,/ 我们/ 利用/ LD/ _/ PRELOAD/ 环境变量/ ,/ 改变程序/ 的/ 动态链接库/ ,/ 这样/ 任务/ 在/ 动态/ 请求/ 内存/ 的/ 时候/ ,/ 就/ 能够/ 调用/ CachePM/ 提供/ 的/ 内存/ 分配/ 函数/ (/ 代替/ malloc/ 等/ )/ ./ 本节/ 详细/ 介绍/ 了/ CachePM/ 动态内存/ 分配/ 和/ Cache/ 分区/ 动态/ 调整/ 策略/ 以及/ 降低/ 重/ 着色/ 开销/ 的/ 策略/ ./ 3.1/ 运行/ 时/ 动态内存/ 分配/ 策略/ 为了/ 通过/ 动态内存/ 分配/ 实现/ Cache/ 分区/ ,/ 为/ 不同/ 的/ 任务分配/ 的/ 物理/ 页/ 的/ 颜色/ 集合/ 应该/ 是/ 不/ 相交/ 的/ ;/ 为了/ 避免/ 同一个/ 任务/ 内/ 出现/ Cache/ 访问/ 热点/ 区域/ ,/ 应该/ 使/ 分配/ 的/ 物理/ 页/ 分散/ 到/ 该/ 任务/ 的/ 颜色/ 集/ 的/ 所有/ 可用/ 颜色/ 上/ ;/ 内存/ 的/ 分配/ 还/ 涉及/ 到/ 了/ 线性/ 地址/ 的/ 分配/ 和/ 管理策略/ ,/ 本节/ 将/ 详细/ 介绍/ 这些/ 策略/ ./ 3.1/ ./ 1/ 感知/ 任务/ Cache/ 敏感度/ 的/ 颜色/ 选择/ 策略/ CachePM/ 为/ 任务/ 分配内存/ 的/ 时候/ ,/ 首先/ 会/ 确定/ 可以/ 为/ 其/ 分配/ 的/ 页面/ 颜色/ 的/ 集合/ ./ 当/ 多个/ 任务/ 共享/ Cache/ 运行/ 的/ 时候/ ,/ 分配/ 给/ 它们/ 的/ 物理/ 页/ 的/ 颜色/ 集/ Page4/ 合/ 应该/ 是/ 不/ 相交/ 的/ ,/ 这样/ 才能/ 保证/ 在/ 共享/ Cache/ 中/ 不同/ 任务/ 的/ 数据/ 不会/ 互相/ 干扰/ ,/ 本文/ 采用/ 的/ 页面/ 颜色/ 选择/ 策略/ 基于/ 对/ 最后/ 一级/ 缓存/ 扑空/ 率/ 随着/ Cache/ 容量/ 的/ 变化/ 而/ 变化/ 的/ 曲线/ (/ MissRatioCurve/ ,/ MRC/ )/ 进行/ 的/ 观察/ ./ 从图/ 2/ 的/ MRC/ 曲线/ 可以/ 看到/ ,/ 当/ 两个/ 任务/ 的/ Cache/ 容量/ 逐渐/ 增加/ 时/ ,/ 刚/ 开始/ 容量/ miss/ 占/ 总/ 缓存/ 扑空/ 的/ 大部分/ ,/ 因此/ 缓存/ 扑空/ 不断/ 下降/ ,/ 然而/ 再/ 继续/ 增加/ 容量/ 对/ 其/ 影响/ 不大/ ./ 因此/ 可以/ 给/ 对/ Cache/ 大小/ 敏感/ 的/ 任务分配/ 较/ 多/ 的/ 颜色/ ,/ 将/ 剩下/ 的/ 颜色/ 分配/ 给/ 对/ Cache/ 大小/ 不/ 敏感/ 的/ 任务/ ,/ 使/ 它们/ 各取所需/ ,/ 互不/ 干扰/ ./ MRC/ 曲线/ miss/ 率/ 变化/ 最大/ 的/ 点/ 对应/ 的/ Cache/ 大小/ 是/ 应用/ 的/ Cache/ 大小/ 最优/ 配额/ ./ 有/ 的/ 任务/ 的/ MRC/ 几乎/ 不会/ 随着/ Cache/ 容量/ 而/ 变化/ ,/ 当对/ Cache/ 容量/ 变化/ 敏感/ 的/ 任务/ 与/ 这类/ 任务/ 并行/ 运行/ 时/ ,/ 优先/ 为/ Cache/ 敏感/ 的/ 任务分配/ 颜色/ ,/ 满足/ 其/ 最优/ Cache/ 配额/ ./ 图/ 2/ 所示/ 的/ 两个/ 应用/ 共享/ Cache/ 时/ ,/ 设/ 系统/ 一共/ 有/ 64/ 种颜色/ ,/ 则/ 可以/ 为/ mcf/ 分配/ 56/ 种颜色/ ,/ 而/ 把/ 剩下/ 的/ 8/ 种颜色/ 都/ 分配/ 给/ gromacs/ ./ 确定/ 好/ 每个/ 任务/ 可以/ 使用/ 的/ 颜色/ 数量/ 之后/ ,/ 还/ 需要/ 进一步/ 确定/ 具体/ 使用/ 哪些/ 颜色/ ,/ 选择/ 颜色/ 的/ 时候/ 需要/ 考虑/ 颜色/ 的/ 连续性/ ,/ 一方面/ 是/ 为了/ 减少/ 选择/ 颜色/ 的/ 开销/ ,/ 另一方面/ ,/ 若/ 所/ 分配/ 的/ 颜色/ 连续/ ,/ 则/ 分配/ 给/ 应用/ 的/ 物理地址/ 空间/ 也/ 可能/ 是/ 连续/ 的/ ./ 3.1/ ./ 2/ 线性/ 地址/ 的/ 管理/ 和/ 分配/ 策略/ CachePM/ 为/ 每个/ 进程/ 维护/ 一个/ 全局/ 链表/ 来/ 管理/ 空闲/ 线性/ 地址/ 空间/ ./ 每/ 一个/ 链表/ 项所/ 代表/ 线性/ 地址/ 空间/ 是/ 连续/ 的/ ,/ 低/ 地址/ 在/ 前/ ,/ 高/ 地址/ 在/ 后/ ,/ 每/ 一个/ 链表/ 项/ 的/ 首/ 地址/ 存储/ 了/ 该/ 线性/ 地址/ 空间/ 的/ 大小/ ./ 当/ 任务/ 动态/ 请求/ 内存/ 的/ 时候/ ,/ 首先/ 会/ 调整/ 请求/ 的/ 大小/ (/ 加上/ 元/ 数据/ 的/ 开销/ )/ ,/ 然后/ 从/ 全局/ 链表/ 中/ 选择/ 满足/ 请求/ 大小/ 的/ 线性/ 地址/ 区间/ 并/ 返回/ 给/ 任务/ ,/ 并/ 更新/ 该/ 线性/ 地址/ 区间/ 的/ 大小/ (/ 减去/ 刚刚/ 分配/ 的/ 大小/ )/ ,/ 返回/ 的/ 线性/ 地址/ 需/ 与/ 8/ 字节/ 对齐/ ./ 若/ 在/ 链表/ 中/ 没有/ 找到/ 足够/ 大/ 的/ 区域/ 以/ 满足/ 请求/ ,/ 则/ 需要/ 扩展/ 全局/ 线性/ 地址/ 链表/ ./ 首先/ 以页/ 为/ 单位/ 扩展/ 堆/ ,/ 然后/ 将/ 扩展/ 的/ 线性/ 地址/ 空间/ 插入/ 到/ 全局/ 链表/ 中/ ,/ 由于/ 堆/ 是从/ 高/ 地址/ 向/ 低/ 地址/ 扩展/ ,/ 故新/ 插入/ 的/ 线性/ 地址/ 一定/ 是/ 在/ 链表/ 的/ 前面/ ,/ 这样/ 保证/ 了/ 实际/ 分配/ 时/ 能够/ 很快/ 找到/ 合适/ 大小/ 的/ 链表/ 项/ ./ 由于/ 进程/ 在/ 分配内存/ 的/ 时候/ ,/ 往往/ 会/ 连续/ 分配/ ,/ 因此/ 扩展/ 的/ 堆/ 的/ 大小/ 应/ 大于/ 请求/ 大小/ ,/ 以/ 满足/ 接下来/ 几次/ 的/ 分配/ ./ 这样/ 能/ 减少/ 接下来/ 内存/ 分配/ 的/ 时候/ 扩展/ 堆/ 的/ 开销/ ,/ 扩展/ 的/ 大小/ 如果/ 太小/ 容易/ 造成/ 内存/ 碎片/ ,/ 如果/ 太/ 大/ 可能/ 实际/ 分配/ 不到/ 那么/ 多/ 内存/ 而/ 造成/ 浪费/ ./ 当/ 任务/ 释放/ 内存/ 的/ 时候/ ,/ 会/ 首先/ 将/ 这段/ 线性/ 地址/ 空间/ 重新/ 插入/ 到/ 全局/ 链表/ 中/ ,/ 并/ 根据/ 这/ 段/ 线性/ 地址/ 头部/ 记录/ 的/ 大小/ 来/ 更新/ 链表/ ,/ 若/ 这段/ 地址/ 空间/ 与/ 下/ 一段/ 或者/ 上/ 一段/ 正好/ 邻接/ ,/ 则/ 将/ 它们/ 合并/ 为/ 一个/ 链表/ 项/ ,/ 并/ 更新/ 其/ 大小/ 为/ 合并/ 段/ 的/ 总/ 大小/ ./ 在/ 程序/ 结束/ 时/ 将/ 全局/ 链表/ 的/ 每个/ 线性/ 地址/ 空间/ 释放/ ./ 3.1/ ./ 3/ 感知/ Cache/ 的/ 物理/ 页/ 的/ 分配/ 策略/ CachePM/ 通过/ 可/ 加载/ 的/ 内核模块/ 按照/ 颜色/ 管理/ 物理/ 页/ ,/ 在/ 应用/ 第一次/ 访问/ malloc/ 返回/ 的/ 线性/ 地址/ 时/ ,/ 会/ 通过/ CachePM/ 内核模块/ 的/ 缺页/ 处理函数/ 将/ 线性/ 地址/ 与/ 物理地址/ 通过/ 建立/ 页表/ 项/ 关联/ 起来/ ./ 设由/ 颜色/ 选择/ 策略/ 为/ 当前任务/ 确定/ 的/ 可用/ 颜色/ 集为/ Scolor/ ,/ 在/ 缺页/ 处理函数/ 选择/ 物理/ 页/ 的/ 时候/ 则/ 需要/ 以/ 颜色/ 平衡/ 作为/ 原则/ ,/ 使/ 分配/ 的/ 物理/ 页/ 分散/ 到/ Scolor/ 里/ 的/ 每种/ 颜色/ 上/ ,/ 且/ 每种/ 颜色/ 的/ 物理/ 页/ 数量/ 基本一致/ ./ 同时/ 连续/ 分配/ 的/ 物理/ 页/ 的/ 颜色/ 不能/ 相同/ ,/ 因为/ 局部性/ 原理/ ,/ 在/ 空间/ 上/ 连续/ 的/ 页/ 往往/ 在/ 时间/ 访问/ 上/ 也/ 是/ 连续/ 的/ ,/ 若/ 连续/ 分配/ 的/ 页/ 颜色/ 相同/ ,/ 则/ 很/ 有/ 可能/ 导致/ Cache/ 局部/ 区域/ 成为/ 热点/ ./ 3.2/ Cache/ 分区/ 动态/ 调整/ 策略/ 当/ 动态/ 请求/ 的/ 内存/ 通过/ CachePM/ 分配/ 好/ 以后/ ,/ 任务/ 的/ 运行/ 环境/ 可能/ 会/ 发生变化/ (/ 有/ 新/ 的/ 任务/ 到来/ 或者/ 有/ 任务/ 结束/ )/ ,/ 我们/ 通过/ 动态/ 重/ 着色/ 调整/ 任务/ Cache/ 分区/ 的/ 大小/ ./ 在/ 重/ 着色/ 的/ 时候/ ,/ 首先/ 需要/ 根据/ 并行/ 运行/ 的/ 任务/ 确定/ 新/ 的/ 颜色/ 集/ ,/ 颜色/ 选择/ 策略/ 同/ 3.1/ ./ 1/ 节/ ,/ 然后/ 将/ 数据/ 从/ 原来/ 的/ 物理/ 页/ 拷贝到/ 新/ 的/ 颜色/ 集/ 的/ 物理/ 页/ 中/ ./ 若/ 改变/ Cache/ 分区/ 的/ 频率/ 较/ 低/ 则/ 按照/ 3.1/ ./ 3/ 节/ 的/ 策略/ 重新分配/ 页/ 帧/ ,/ 否则/ 为了/ 降低/ 数据/ 移动/ 的/ 开销/ ,/ 就要/ 尽量减少/ 数据/ 移动/ 次数/ 以及/ 推迟/ 数据/ 移动/ ./ Page53/ ./ 2.1/ 最小/ 距离/ 数据/ 移动/ 策略/ 在/ 内存/ 颜色/ 集/ 需要/ 改变/ 时/ ,/ 仍然/ 要/ 保证/ 新/ 的/ 颜色/ 集中/ 各个/ 颜色/ 的/ 平衡/ ,/ 所以/ 并/ 不能/ 随意/ 将/ 某个/ 页/ 的/ 颜色/ 改变/ ./ 为了/ 保证/ 颜色/ 平衡/ ,/ 我们/ 首先/ 确定/ 每种/ 目标/ 颜色/ 的/ 物理/ 页/ 的/ 数量/ (/ 基本/ 相等/ )/ ./ 为了/ 减少/ 数据/ 移动/ 的/ 次数/ ,/ 我们/ 通过/ 维护/ 一个/ current/ _/ map/ 数组/ 记录/ 当前/ 每个/ 页面/ 的/ 颜色/ ,/ 计算/ 每个/ 页面/ 的/ 目标/ 颜色/ 并/ 存储/ 在/ 数组/ target/ _/ map/ 中/ ./ 在/ 物理/ 页/ 数量/ 确定/ 的/ 着色/ 方案/ 中/ ,/ target/ _/ map/ 数组/ 和/ current/ _/ map/ 数组/ 的/ 距离/ (/ 两个/ 数组/ 间/ 的/ 距离/ 指/ 两个/ 数组/ 不同/ 项/ 的/ 个数/ )/ 是/ 最小/ 的/ ,/ 伪/ 代码/ 如/ 算法/ 1/ 所示/ ./ (/ 1/ )/ 懒惰/ 页/ 拷贝/ 策略/ 将/ 数据/ 移动/ 推迟/ 到/ 当/ 它/ 被/ 访问/ 的/ 时候/ ,/ 一方面/ 能够/ 防止/ 内存/ 分配/ 成为/ 性能/ 瓶颈/ ./ 另一方面/ ,/ 有/ 的/ 数据/ 不会/ 被/ 再次/ 访问/ ,/ 或/ 实际/ 访问/ 的/ 时候/ 运行/ 环境/ 又/ 发生/ 了/ 变化/ ,/ 因此/ 移动/ 这些/ 数据/ 是/ 无/ 意义/ 的/ ./ 若要/ 将/ 某个/ 页/ 的/ 颜色/ 从/ A/ 改为/ B/ ,/ 则/ 首先/ 设置/ 该页/ 的/ 目标/ 颜色/ 为/ B/ ;/ 然后/ 清除/ 该页/ 的/ 页表/ 项/ ;/ 页表/ 项/ 被/ 清除/ 后/ ,/ 再次/ 访问/ 该页/ 会/ 发生/ 缺页/ 异常/ ,/ 在/ 缺页/ 处理/ 例程/ 中/ ,/ 将/ 数据/ 从/ 原始/ 物理/ 页/ 拷贝到/ 颜色/ 为/ B/ 的/ 物理/ 页/ ,/ 并/ 释放/ 掉/ 原/ 物理/ 页/ ./ 算法/ 1/ ./ 最小/ 距离/ 数据/ 移动/ ./ 输入/ :/ current/ _/ map/ 数组/ ,/ 物理/ 页数/ n/ ,/ 目标/ 颜色/ 数/ cn/ 输出/ :/ target/ _/ map/ 数组/ 1/ ./ // // count/ [/ 1/ …/ cn/ ]/ 记录/ 移动/ 后/ 每种/ 目标/ 颜色/ 的/ 物理/ 页数/ 2/ ./ count/ [/ 1/ …/ cn/ ]/ =/ n/ // cn/ ;/ count/ [/ 1/ …/ n/ %/ cn/ ]/ ++/ 3/ ./ Forifrom1tonDO/ // // 计算/ count/ 数组/ 4/ ./ c/ =/ current/ _/ map/ [/ i/ ]/ // // 偏移/ 为/ i/ 的/ 页/ 当前/ 的/ 颜色/ 5/ ./ IFcount/ [/ c/ ]/ >/ 0THEN/ // // 颜色/ c/ 的/ 可/ 分配/ 物理/ 页/ 6/ ./ target/ _/ map/ [/ i/ ]/ =/ c/ ;/ // // 保持/ 当前/ 物理/ 页/ 颜色/ 不变/ 7/ ./ count/ [/ c/ ]/ -/ -/ ;/ // // 更新/ 颜色/ c/ 的/ 可/ 分配/ 物理/ 页/ 数量/ 8/ ./ ELSE/ // // 若/ 颜色/ c/ 的/ 可/ 分配/ 物理/ 页/ 数量/ 为/ 09/ ./ 循环/ 选择/ 可/ 分配/ 物理/ 页/ 数量/ 大于/ 0/ 的/ 颜色/ cnew10/ ./ target/ _/ map/ [/ i/ ]/ =/ cnew/ ;/ // // 更新/ 当前/ 物理/ 页/ 的/ 颜色/ 11/ ./ count/ [/ cnew/ ]/ -/ -/ ;/ // // 更新/ 可/ 分配/ 的/ 物理/ 页/ 数量/ 12/ ./ ENDIF13/ ./ ENDFOR/ 确定/ 好/ 了/ target/ _/ map/ 数组/ 之后/ ,/ 若/ 某/ 一页/ 的/ target/ _/ map/ 与/ current/ _/ map/ 的/ 颜色/ 不/ 一致/ ,/ 则/ 说明/ 需要/ 修改/ 它/ 的/ 颜色/ ./ 由于/ target/ _/ map/ 到/ current/ _/ map/ 的/ 距离/ 是/ 最小/ 的/ ,/ 故/ 需要/ 修改/ 的/ 页面/ 颜色/ 数量/ 是/ 最少/ 的/ ,/ 即/ 需要/ 移动/ 的/ 页面/ 数量/ 最少/ ./ 3.2/ ./ 2/ 数据/ 移动/ 延迟/ 策略/ 和/ 懒惰/ 刷新/ 策略/ ./ 为了/ 推迟/ 数据/ 移动/ ,/ 本文/ 采用/ 懒惰/ 页/ 拷贝/ 策略/ [/ 1/ ]/ (/ 2/ )/ 懒惰/ 刷新/ 策略/ 该/ 策略/ 作为/ 懒惰/ 页/ 拷贝/ 策略/ 的/ 增强/ ./ 页表/ 项/ 被/ 清零/ 之后/ ,/ Cache/ 中/ 仍然/ 有/ 原始/ 页/ 的/ 缓存/ ,/ 在/ TLB/ (/ TranslationLookasideBuffer/ )/ 中/ 也/ 仍然/ 缓存/ 着/ 当前页/ 表项/ 在/ 被/ 清零/ 之前/ 的/ 值/ ./ 故/ 需要/ 对/ 数据/ Cache/ 和/ TLB/ 进行/ 刷新/ 操作/ ,/ 而/ 刷新/ 操作/ 必然/ 导致/ com/ -/ pulsorymiss/ (/ 强制/ 缺失/ )/ ,/ 因此/ 需要/ 尽量减少/ 刷新/ 次数/ ./ 我们/ 采取/ 的/ 是/ 懒惰/ 刷新/ 策略/ ,/ 即/ 确定/ target/ _/ map/ 数组/ 后/ ,/ 遍历/ target/ _/ map/ 和/ current/ _/ map/ 数组/ ,/ 若/ 当前页/ 的/ current/ _/ map/ 的/ 值/ 不/ 等于/ target/ _/ map/ 的/ 值/ ,/ 说明/ 该页/ 的/ 颜色/ 需要/ 被/ 改变/ ,/ 则/ 清除/ 该页/ 的/ 页表/ 项值/ ,/ 直到/ 所有/ 页面/ 被/ 处理/ 完/ 之后/ 再/ 刷新/ Cache/ 和/ TLB/ ./ 然而/ ,/ 动态/ 重/ 着色/ 的/ 开销/ 不可/ 完全避免/ ,/ 因此/ 不能/ 太/ 频繁/ 地/ 改变/ Cache/ 分区/ ,/ 分区/ 策略/ 需在/ 动态/ 迁移/ 带来/ 的/ 性能/ 提高/ 和/ 迁移/ 本身/ 的/ 开销/ 之间/ 权衡/ ./ 4/ 实验/ 结果/ 与/ 分析/ 实验/ 测试/ 平台/ 为/ IntelCoreTM2DuoCPU/ ,/ 详细/ 配置/ 参数/ 见表/ 1/ ./ 由于/ L2Cache/ 的/ 容量/ 是/ 6MB/ ,/ 页面/ 大小/ 是/ 4KB/ ,/ 相联/ 度为/ 24/ 路/ ,/ 则/ 页面/ 的/ 颜色/ 一共/ 被/ 分为/ 了/ 6144KB/ // (/ 4KB/ ×/ 24/ )/ =/ 64/ 种/ ,/ 操作系统/ 的/ 内核/ 是/ Linux2/ ./ 6.32/ ,/ 采样/ 工具/ 为/ perf/ ①/ ./ 测试程序/ 集为/ SPECCPU2006/ ②/ ,/ 我们/ 从中/ 选择/ 了/ 12/ 个/ 测试程序/ ./ 处理器/ 核数/ 双核/ 页面/ 大小/ 4KB/ 页面/ 颜色/ 数量/ 64L1Cach/ 容量/ 32KBCache/ 相联/ 度/ 8/ 路/ L2Cach/ 容量/ 6MBCache/ 相联/ 度/ 24/ 路/ 4.1/ 程序/ 的/ Cache/ 访问/ 特征分析/ CachePM/ 提供/ 了/ 通过/ 参数/ 指定/ 可用/ Cache/ 大小/ 的/ 功能/ ,/ 因此/ 可以/ 利用/ CachePM/ 得到/ 程序/ 的/ MRC/ 曲线/ ,/ 进而/ 分析程序/ 的/ Cache/ 访问/ 特征/ ./ 通过/ 为/ 每个/ 测试程序/ 递增/ 地/ 分配/ Cache/ 大小/ ,/ 利用/ perf/ 统计/ 各/ 次/ 执行/ 中/ 的/ 最后/ 一级/ 缓存/ 扑空/ ,/ 得到/ 它们/ 的/ MRC/ 曲线/ ,/ 通过/ 分析/ MRC/ 曲线/ 可以/ 将/ 这些/ 测试程序/ 分为/ 4/ 类/ ,/ 分类/ 结果/ 如表/ 2/ 所示/ ./ A/ 类/ ,/ 缓存/ 扑空/ 对/ Cache/ 容量/ 变化/ 很/ 敏感/ ;/ B/ 类/ ,/ 缓存/ 扑空/ 对/ Cache/ 容量/ 变化/ 较/ 敏感/ ;/ ①/ ②/ Page6/ 存/ 扑空/ 率/ 一直/ 较/ 高/ ;/ C/ 类/ ,/ 缓存/ 扑空/ 对/ Cache/ 容量/ 变化/ 不/ 敏感/ ,/ 但缓/ D/ 类/ ,/ 缓存/ 扑空/ 对/ Cache/ 容量/ 变化/ 不/ 敏感/ ,/ 且/ 缓存/ 扑空/ 率/ 一直/ 很/ 低/ ./ 类型/ Abzip2/ 、/ mcf/ 、/ sphinx/ (/ sph/ )/ BH264ref/ (/ h264/ )/ 、/ GemsFDTD/ (/ Gem/ )/ 、/ libquantum/ (/ libq/ )/ Czeusmp/ (/ zeu/ )/ 、/ bwaves/ (/ bwa/ )/ 、/ lbm/ ./ SjengDgromacs/ 、/ namd/ 由于/ 篇幅/ 限制/ ,/ 这里/ 只/ 列出/ 4/ 个/ 程序/ 的/ MRC/ (/ 图/ 3/ ~/ 图/ 6/ )/ ,/ 它们/ 分别/ 属于/ 4/ 种/ 不同/ 的/ 类型/ ./ 4.2/ 单个/ 任务/ 的/ Cache/ 性能/ 优化/ 每次/ 只/ 运行/ 一个/ 任务/ ,/ 比较/ 在/ 默认/ 的/ 动态内存/ 分配/ 策略/ (/ libc/ )/ 、/ CachePM/ 提供/ 的/ 动态内存/ 分配/ 策略/ 以及/ 在/ Ccontrol/ 下/ 运行/ 的/ 程序/ 性能/ ./ 利用/ LD/ _/ PRELOAD/ 环境变量/ ,/ 可以/ 修改/ 程序/ 的/ 动态链接库/ ,/ 首先/ 在/ 默认/ 情况/ 下/ ,/ 任务/ 的/ 动态链接库/ 是/ libc/ ,/ 在/ 此/ 情况/ 下/ 运行/ 一个/ 任务/ ,/ 接着/ 分别/ 将/ 动态链接库/ 修改/ 为/ CachePM/ 和/ Control/ ,/ 并/ 运行/ 同一个/ 程序/ ,/ 分别/ 采样/ 这/ 3/ 种/ 策略/ 下/ 任务/ 的/ 运行/ 时间/ ,/ 计算/ CachePM/ 和/ Control/ 下/ 的/ 运行/ 时间/ 较/ libc/ 下/ 运行/ 时间/ 的/ 百分比/ ,/ 得到/ 图/ 7/ ./ 图/ 7/ 单个/ 程序/ 的/ 运行/ 时间/ 较/ 默认/ 情况/ 的/ 百分比/ 可以/ 发现/ 在/ CachePM/ 的/ 管理/ 下/ ,/ 单个/ 任务/ 的/ 性能/ 较/ 默认/ 的/ libc/ 有所提高/ ,/ 总体/ 上/ CachePM/ 比/ Control/ 的/ 性能/ 略/ 高/ ,/ 而/ 在/ Control/ 下有/ 几个/ 测试程序/ 的/ 运行/ 时间/ 超过/ 了/ 默认/ 情况/ 的/ 10/ %/ ./ 主要/ 原因/ 一方面/ 是因为/ 字节/ 对齐/ 提高/ 了/ 数据/ 读取/ 效率/ ;/ 另一方面/ Control/ 预留/ 的/ 空闲/ 内/ 存在/ 运行/ 时/ 被/ 划分/ 成/ 了/ 很多/ 不/ 连续/ 的/ 空闲/ 内存/ ,/ 在/ 内存/ 分配/ 时/ 寻找/ 合适/ 大小/ 的/ 空闲/ 内存空间/ 的/ 开销/ 较大/ ./ 4.3/ 并行任务/ 的/ Cache/ 性能/ 优化/ 在/ 共享/ Cache/ 的/ 处理器/ 上/ 同时/ 运行/ 两个/ 程序/ ,/ 由于/ 共享/ Cache/ 冲突/ ,/ 这/ 两个/ 程序/ 的/ 性能/ 较/ 单独/ 运/ Page7/ 行时/ 都/ 会/ 受到/ 影响/ ./ 而/ CachePM/ 会/ 在/ 两个/ 任务/ 运行/ 时/ ,/ 根据/ Cache/ 分区/ 的/ 决策/ 进行/ 内存/ 分配/ ./ 由于/ 两个/ 任务/ 运行/ 时间/ 不同/ ,/ 静态/ 分区/ 会/ 导致/ 一个/ 任务/ 运行/ 结束/ 后/ ,/ 它/ 所/ 使用/ 的/ Cache/ 区域/ 闲置/ ,/ 可能/ 反而/ 降低/ 系统/ 性能/ ./ 而/ CachePM/ 会/ 在/ 一个/ 程序运行/ 结束/ 时/ ,/ 改变/ 分区/ 决策/ 并/ 据此/ 调整/ 还/ 在/ 运行/ 的/ 任务/ 的/ 内存/ 布局/ ,/ 使得/ 它/ 能/ 使用/ 全部/ 的/ Cache/ 区域/ ,/ 从而/ 提高/ 系统/ 性能/ ./ 为了/ 分析/ 比较/ 并行任务/ 在/ 默认/ 情况/ 下/ (/ 不/ 进行/ 分区/ )/ 和/ 在/ CachePM/ 实现/ Cache/ 分区/ 并/ 动态/ 调节/ Cache/ 分区/ 后/ 的/ 程序/ 性能/ ./ 我们/ 在/ 默认/ 情况/ 和/ CachePM/ 下/ 分别/ 运行/ 两个/ 程序/ ,/ 计算/ 其/ 性能/ ./ 设/ 程序/ 1/ 、/ 程序/ 2/ 单独/ 运行/ 的/ 时间/ 为/ 分别/ 为/ ts1/ ,/ ts2/ ,/ 它们/ 并行/ 运行/ 的/ 时间/ 分别/ 为/ tp1/ ,/ tp2/ ,/ 则/ 系统/ 性能/ 定义/ 为/ 则/ 理想/ 情况/ 下/ ,/ 两个/ 任务/ 运行/ 时/ 没有/ 任何/ 干扰/ 的/ 系统/ 性能/ 为/ 1.0/ ./ 我们/ 从/ 上述/ 的/ 12/ 个/ 测试程序/ 中/ 选出/ 10/ 个/ ,/ 其中/ 9/ 个/ 来自/ 类型/ A/ ,/ B/ ,/ C/ ,/ 有/ 一个/ 来自/ 类型/ D/ ,/ D/ 类型/ 的/ 程序/ 对/ 别的/ 程序/ 几乎/ 不会/ 造成/ 什么/ 影响/ ,/ 自身/ 也/ 受/ Cache/ 冲突/ 的/ 影响/ 小/ ,/ Cache/ 分区/ 提升/ 其/ 性能/ 的/ 程度/ 也/ 有限/ ,/ 所以/ 本文/ 只/ 选择/ 了/ 一个/ D/ 类/ 程序/ 作为/ 示例/ ./ 接着/ 将/ 这/ 10/ 个/ 测试程序/ 分为/ 两组/ :/ 组/ 1/ =/ {/ mcf/ ,/ GemsFDTD/ ,/ libquantum/ ,/ lbm/ }/ ;/ 组/ 2/ =/ {/ bzip2/ ,/ mcf/ ,/ sphinx/ ,/ h264ref/ ,/ GemsFDTD/ ,/ libquantum/ ,/ zeusmp/ ,/ bwaves/ ,/ lbm/ ,/ gromacs/ }/ ;/ 这样/ 划分/ 是因为/ 组/ 1/ 中/ 的/ 程序/ 攻击性/ 较强/ ,/ 对/ 别的/ 程序/ 性能/ 影响/ 较大/ ,/ 为了/ 在/ 较大/ 的/ 冲突/ 下/ 评估/ Cache/ 分区/ 的/ 效果/ ,/ 我们/ 每次/ 从组/ 1/ 和/ 组/ 2/ 中/ 分别/ 选择/ 一个/ 程序/ (/ 选择/ 的/ 两个/ 程序/ 不/ 相同/ )/ ,/ 绑定/ 到/ 共享/ Cache/ 的/ 核上/ 运行/ ./ 图/ 8/ ~/ 图/ 11/ 说明/ 了/ 两种/ 策略/ 下/ 的/ 系统/ 性能/ ./ 图/ 8/ 各/ 程序/ 与/ lbm/ 组合/ 运行/ 的/ 系统/ 性能/ 对比/ 图/ 9/ 各/ 程序/ 与/ mcf/ 组合/ 运行/ 的/ 系统/ 性能/ 对比/ 图/ 10/ 各/ 程序/ 与/ Gem/ 组合/ 运行/ 的/ 系统/ 性能/ 对比/ 图/ 11/ 各/ 程序/ 与/ libq/ 组合/ 运行/ 的/ 系统/ 性能/ 对比/ 图/ 8/ ~/ 图/ 11/ 说明/ 并行任务/ 的/ 性能/ 较/ 默认/ 情况/ 提升/ 了/ ,/ 这/ 也/ 说明/ 动态/ 调整/ 分区/ 的/ 代价/ 被/ 抵消/ 了/ ./ 总体/ 来说/ ,/ libq/ 、/ lbm/ 、/ Gems/ 、/ mcf/ 、/ sphinx/ 对系统/ 性能/ 影响/ 较大/ ,/ 且/ 性能/ 容易/ 受/ 冲突/ 影响/ ,/ 性能/ 都/ 较/ 低/ ,/ h264ref/ 、/ gromacs/ 对系统/ 性能/ 的/ 影响/ 很小/ ,/ 系统/ 性能/ 最/ 接近/ 1/ ,/ 这/ 与/ 文献/ [/ 10/ ]/ 得到/ 的/ 结论/ 也/ 是/ 一致/ 的/ ./ 由于/ h264ref/ 和/ gromacs/ 对系统/ 性能/ 影响/ 较/ 小/ ,/ 故/ CachePM/ 对/ 其/ 性能/ 的/ 提升/ 程度/ 也/ 较/ 小/ ./ 值得注意/ 的/ 是/ ,/ 其中/ 有/ 两组/ 数据/ 的/ 性能/ 较/ 默认/ 情况/ 有所/ 下降/ ,/ 这/ 两组/ 数据/ 分别/ 是/ mcfvs/ ./ bzip/ 和/ mcfvs/ ./ sphinx/ ,/ 主要/ Page8/ 是因为/ mcf/ ,/ bzip/ 和/ sphinx/ 都/ 是/ A/ 类/ 任务/ ,/ 其/ 缓存/ 扑空/ 对/ Cache/ 的/ 容量/ 都/ 非常/ 敏感/ ,/ 两个/ A/ 类/ 任务/ 并行/ 运行/ 时/ ,/ 由于/ Cache/ 的/ 总/ 大小/ 是/ 有限/ 的/ ,/ Cache/ 分区/ 不能/ 同时/ 使/ 它们/ 使用/ 的/ Cache/ 大小/ 满足/ 需求/ ,/ 虽然/ 分区/ 使得/ 任务/ 间/ 的/ 冲突/ 降低/ 了/ ,/ 但是/ 容量/ miss/ 却/ 大量/ 增加/ ,/ 此时/ 容量/ miss/ 导致/ 的/ 性能/ 损失/ 大于/ 了/ 降低/ 冲突/ miss/ 带来/ 的/ 性能/ 提升/ ,/ 因此/ 分区/ 策略/ 需要/ 在/ 容量/ miss/ 和/ 冲突/ miss/ 之间/ 权衡/ ./ 5/ 结论/ 现有/ 的/ 动态内存/ 分配/ 策略/ 在/ 多/ 核/ 环境/ 中/ 越来越/ 显出/ 不足/ ,/ 对/ 应用/ 的/ Cache/ 性能/ 造成/ 了/ 不可/ 忽视/ 的/ 负面影响/ ./ 本文/ 通过/ 设计/ 适用/ 于/ 多/ 核/ 环境/ 的/ 动态内存/ 分配/ 策略/ ,/ 利用/ 基于/ 页/ 着色/ 的/ 动态内存/ 分配/ 实现/ Cache/ 分区/ ,/ 这种/ 方式/ 一方面/ 比较/ 灵活/ ,/ 只/ 需要/ 控制/ 一部分/ 数据/ 的/ 分布/ ;/ 另一方面/ ,/ 动态分配/ 的/ 数据/ 往往/ 是/ 程序/ 中/ 被/ 频繁/ 访问/ 的/ ,/ 因此/ 同样/ 能够/ 达到/ 降低/ 共享/ Cache/ 冲突/ 的/ 目的/ ./ 更/ 重要/ 的/ 是/ ,/ 在/ 现有/ 硬件平台/ 上/ 为/ 页面/ 重/ 着色/ ,/ 有着/ 不可/ 忽视/ 的/ 数据/ 移动/ 的/ 开销/ ,/ 所以/ 只/ 对/ 部分/ 频繁/ 访问/ 的/ 页面/ 进行/ 着色/ 更加/ 有效/ ./ 我们/ 首先/ 介绍/ 了/ 如何/ 根据/ 数据/ 的/ Cache/ 分布/ 以及/ 共享/ Cache/ 运行/ 的/ 任务/ ,/ 为/ 任务/ 动态/ 分配内存/ ,/ 实现/ Cache/ 分区/ ;/ 接着/ 讨论/ 了/ ,/ 如何/ 通过/ 动态/ 重/ 着色/ 改变/ 数据/ 的/ 物理/ 内存/ 分布/ ,/ 以/ 实现/ Cache/ 分区/ 的/ 动态/ 调整/ ;/ 同时/ 还/ 提出/ 了/ 降低/ 重/ 着色/ 开销/ 的/ 策略/ ./ 实验/ 结果/ 说明/ CachePM/ 能/ 通过/ 动态/ Cache/ 分区/ 提高/ 多核/ 并行程序/ 的/ 性能/ ;/ 同时/ 由于/ 提高/ 了/ 程序/ 的/ Cache/ 利用率/ ,/ 也/ 使/ 单独/ 运行/ 的/ 任务/ 的/ 性能/ 有所/ 提升/ ./ 

