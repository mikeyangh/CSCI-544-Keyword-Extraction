Page1/ 一种/ 基于/ 加权/ 软件/ 行为/ 图/ 挖掘/ 的/ 软件/ 错误/ 定位/ 方法/ 苏小红王/ 甜甜/ 杨劭君/ 马培军/ (/ 哈尔滨工业大学/ 计算机科学/ 与/ 技术/ 学院/ 哈尔滨/ 150001/ )/ 摘要/ 已有/ 错误/ 定位/ 方法/ 通常/ 仅/ 给出/ 可疑/ 语句/ 排序/ 而/ 缺少/ 必要/ 的/ 上下文/ 信息/ ,/ 导致/ 难于/ 理解/ 软件/ 失效/ 的/ 产生/ 原因/ ./ 为了/ 解决/ 该/ 问题/ ,/ 定义/ 了/ 加权/ 软件/ 行为/ 图来/ 表示/ 成功/ 和/ 失败/ 的/ 程序执行/ 路径/ ,/ 由于/ 图中边/ 的/ 权重/ 表示/ 了/ 路径/ 的/ 执行/ 频率/ ,/ 因此/ 与/ LEAP/ 方法/ 相比/ ,/ 可以/ 较/ 好/ 地/ 分析/ 与/ 循环/ 和/ 递归/ 等/ 结构/ 相关/ 的/ 软件/ 错误/ ./ 在/ 此基础/ 上/ ,/ 执行/ 基于/ 分支/ 限界/ 搜索/ 的/ 加权/ 软件/ 行为/ 图/ 挖掘/ 算法/ ,/ 识别/ 成功/ 和/ 失败/ 执行/ 之间/ 最有/ 差异/ 的/ 子/ 图来/ 获得/ 错误/ 签名/ ,/ 不但/ 可以/ 有效/ 定位/ 错误/ 位置/ ,/ 还/ 能/ 输出/ 缺陷/ 语句/ 相关/ 的/ 执行/ 路径/ ,/ 从而/ 提供/ 失效/ 产生/ 的/ 上下文/ ./ 分析/ Siemens/ 基准/ 测试/ 集/ 和/ flex/ 程序/ 的/ 结果表明/ ,/ 在/ 检查/ 相同/ 百分比/ 的/ 语句/ 的/ 情况/ 下/ ,/ 文中/ 方法/ 可以/ 比/ Tarantula/ 方法/ 和/ LEAP/ 方法/ 定位/ 到/ 更/ 多/ 的/ 错误/ ./ 特别/ 是/ 对于/ 冗余/ 代码/ 、/ 缺失/ 代码/ 和/ 变量/ 替换/ ,/ 以及/ 会/ 直接/ 改变/ 执行/ 路径/ 类/ 的/ 错误/ ,/ 文中/ 方法/ 具有/ 较/ 高/ 的/ 定位精度/ ./ 关键词/ 错误/ 定位/ ;/ 软件/ 行为/ 图/ ;/ 图/ 挖掘/ ;/ 错误/ 签名/ ;/ 分支/ 限界/ 搜索/ 1/ 引言/ 随着/ 计算机行业/ 的/ 不断/ 发展/ ,/ 软件/ 也/ 日趋/ 庞大/ 和/ 复杂/ ,/ 软件/ 失效/ 发生/ 的/ 概率/ 也/ 随之/ 增高/ ,/ 这/ 使得/ 软件/ 的/ 质量/ 越来越/ 难以/ 保证/ ./ 在/ 软件/ 失效/ 发生/ 以后/ ,/ 调试/ 软件/ (/ 定位/ 导致/ 错误/ 产生/ 的/ 代码/ 语句/ 并且/ 修复/ 错误/ )/ 往往/ 需要/ 消耗/ 大量/ 的/ 时间/ 和/ 人力/ ./ 而/ 自动化/ 错误/ 定位/ 技术/ ,/ 可以/ 显著/ 减少/ 其中/ 的/ 人力/ 和/ 时间/ 消耗/ ,/ 从而/ 提高/ 软件/ 的/ 质量/ ./ 目前/ 已/ 存在/ 很多/ 不同/ 的/ 软件/ 错误/ 定位/ 方法/ ,/ 例如/ 基于/ 程序/ 状态/ 修改/ 的/ 方法/ [/ 1/ -/ 2/ ]/ 、/ 基于/ 程序/ 行为/ 特征/ 对比/ 的/ 方法/ [/ 3/ -/ 6/ ]/ 以及/ 基于/ 程序/ 依赖/ 关系/ 的/ 方法/ [/ 7/ -/ 9/ ]/ 等/ ./ 这些/ 错误/ 定位/ 方法/ 的/ 结果/ 大多数/ 都/ 是/ 一个/ 语句/ 的/ 可疑/ 值/ 序列/ ,/ 其中/ 按照/ 可疑/ 值/ 降序/ 的/ 顺序/ 列出/ 了/ 不同/ 语句/ 的/ 可疑/ 值/ ,/ 以/ 指导/ 开发者/ 对/ 错误/ 进行/ 修改/ ./ 但是/ ,/ 单独/ 检查/ 给出/ 的/ 可疑/ 语句/ ,/ 通常/ 并/ 不足以/ 令/ 开发者/ 判断/ 该/ 语句/ 是否是/ 正确/ 的/ ./ 开发者/ 往往/ 需要/ 更/ 多/ 的/ 上下文/ 信息/ ,/ 才/ 能够/ 理解/ 错误/ 是/ 如何/ 产生/ 的/ ,/ 并/ 修正/ 程序/ ./ 因此/ ,/ Hsu/ 等/ 人/ [/ 10/ ]/ 提出/ 了/ 能够/ 从/ 成功/ 和/ 失败/ 的/ 程序执行/ 路径/ 中/ 识别/ 错误/ 签名/ 的/ RAPID/ 方法/ ./ 错误/ 签名/ 是/ 一个/ 程序/ 实体/ 序列/ ,/ 当/ 按/ 顺序/ 执行/ 其中/ 的/ 程序/ 实体/ 时/ ,/ 就/ 很/ 可能/ 会/ 导致/ 错误/ 产生/ ./ 错误/ 签名/ 不但/ 可以/ 指示/ 错误/ 的/ 所在/ ,/ 还/ 能够/ 提供/ 错误/ 产生/ 的/ 上下文/ ./ Cheng/ 等/ 人/ [/ 11/ ]/ 根据/ 程序执行/ 路径/ 构造/ 软件/ 行为/ 图/ ,/ 提出/ 了/ 利用/ 图/ 挖掘/ 算法/ 来/ 识别/ 错误/ 签名/ 的/ LEAP/ 方法/ ./ 本文/ 则/ 进一步/ 改进/ 了/ 软件/ 行为/ 图/ ,/ 考虑/ 了/ 语句/ 的/ 执行/ 频率/ 对/ 错误/ 定位/ 效果/ 的/ 影响/ ,/ 提出/ 了/ 加权/ 软件/ 行为/ 图/ ,/ 以及/ 适用/ 于/ 挖掘/ 加权/ 图/ 的/ 新/ 函数/ ,/ 得到/ 了/ 错误/ 定位精度/ 更/ 高/ 的/ 错误/ 签名/ ./ 最后/ 与/ Tarantula/ 方法/ [/ 3/ ]/ 和/ LEAP/ 方法/ [/ 11/ ]/ 进行/ 了/ 实验/ 比较/ ,/ 讨论/ 了/ 不同/ 错误/ 类型/ 对/ 错误/ 定位精度/ 的/ 影响/ ./ 本文/ 第/ 2/ 节/ 介绍/ 目前/ 的/ 相关/ 工作/ 和/ 本文/ 的/ 研究/ 动机/ ;/ 第/ 3/ 节/ 介绍/ 本文/ 方法/ 的/ 总体/ 思想/ ;/ 第/ 4/ 节/ 介绍/ 加权/ 软件/ 行为/ 图/ 的/ 构造/ 以及/ 相应/ 的/ 图/ 挖掘/ 算法/ ;/ 第/ 5/ 节/ 通过/ 实验/ 分析/ 本文/ 的/ 方法/ ;/ 第/ 6/ 节/ 讨论/ 本文/ 方法/ 的/ 局限性/ 和/ 可/ 改进/ 之/ 处/ ;/ 最后/ 总结/ 全文/ ./ 2/ 相关/ 工作/ 及/ 研究/ 动机/ 目前/ 的/ 软件/ 错误/ 定位/ 方法/ 大致/ 可以/ 分为/ :/ 程序/ 状态/ 修改/ 、/ 程序/ 行为/ 特征/ 对比/ 、/ 程序/ 依赖/ 关系/ 分析/ [/ 12/ ]/ 和/ 错误/ 签名/ 方法/ 等/ ./ 程序/ 状态/ 修改/ 方法/ ,/ 通常/ 在/ 程序执行/ 时/ 收集/ 程序/ 状态/ 信息/ ,/ 并/ 对/ 程序/ 状态/ 进行/ 修改/ ,/ 然后/ 观察/ 修改/ 后/ 的/ 执行/ 结果/ 是否/ 发生变化/ ,/ 据此/ 找到/ 与/ 错误/ 相关/ 的/ 关键/ 语句/ ./ Cleve/ 和/ Zeller/ [/ 1/ ]/ 提出/ 的/ DeltaDebugging/ 方法/ ,/ 采用/ 分治/ 的/ 思想/ 找到/ 成功/ 的/ 测试/ 输入/ 和/ 失败/ 的/ 测试/ 输入/ 间/ 的/ 最小/ 差别/ ,/ 再/ 跟踪/ 成功/ 和/ 失败/ 执行/ 之间/ 的/ 状态/ 差异/ ,/ 找到/ 错误/ 语句/ ./ Zhang/ 等/ 人/ [/ 2/ ]/ 通过/ 在/ 运行/ 时/ 强制/ 修改/ 谓词/ 的/ 取值/ 结果/ ,/ 使得/ 失败/ 的/ 执行/ 变为/ 成功/ 的/ 执行/ ,/ 并/ 依此/ 识别/ 错误/ 所在/ ./ 这类/ 方法/ 的/ 算法/ 复杂度/ 一般/ 都/ 较大/ ,/ 对/ 小规模/ 程序/ 效果/ 比较/ 理想/ ,/ 但/ 处理/ 复杂/ 程序/ 时/ 效率/ 会/ 大大降低/ ./ 程序/ 行为/ 特征/ 对比/ 方法/ ,/ 一般/ 认为/ 成功/ 执行/ 和/ 失败/ 执行/ 的/ 程序/ 行为/ 特征/ 是/ 不同/ 的/ ,/ 它们/ 之间/ 的/ 差异/ 可以/ 用于/ 指导/ 错误/ 定位/ ./ 这些/ 方法/ 通常/ 统计/ 语句/ 和/ 谓词/ 被/ 每个/ 测试用例/ 覆盖/ 的/ 信息/ 来/ 衡量/ 每条/ 语句/ 出错/ 的/ 可能/ ./ Jones/ 和/ Harrold/ [/ 3/ ]/ 提出/ 的/ 基于/ 语句/ 覆盖/ 的/ 方法/ Tarantula/ ,/ 认为/ 错误/ 语句/ 应该/ 在/ 失败/ 的/ 执行/ 中/ 大量/ 的/ 出现/ ,/ 而/ 在/ 成功/ 的/ 执行/ 中/ 少量/ 出现/ ./ 之后/ 研究/ 人员/ 提出/ 了/ 大量/ 的/ 覆盖/ 分析方法/ ,/ 文献/ [/ 4/ -/ 5/ ]/ 对/ 这些/ 方法/ 的/ 等价/ 性/ 和/ 精度/ 进行/ 了/ 理论/ 上/ 的/ 分析/ 比较/ ,/ 文献/ [/ 6/ ]/ 提出/ 了/ 利用/ 机器/ 学习/ 方法/ 结合/ 多种/ 覆盖/ 分析/ 错误/ 定位/ 方法/ ,/ 期望/ 取得/ 更/ 准确/ 的/ 定位/ 结果/ ./ 然而/ 此类/ 方法/ 往往/ 只/ 考虑/ 了/ 语句/ 或/ 谓词/ 的/ 覆盖/ 信息/ ,/ 缺少/ 对/ 程序结构/ 和/ 执行/ 信息/ 的/ 分析/ ,/ 会/ 影响/ 错误/ 定位精度/ ,/ 而且/ 难以/ 给出/ 与/ 错误/ 相关/ 的/ 上下文/ 信息/ ,/ 开发者/ 仍然/ 需要/ 做/ 许多/ 工作/ 才/ 能够/ 修复/ 错误/ ./ 程序/ 依赖/ 关系/ 分析方法/ ,/ 侧重于/ 根据/ 程序/ 实体/ 间/ 的/ 控制/ 依赖/ 关系/ 或/ 数据/ 依赖/ 关系/ ,/ 给出/ 语句/ 的/ 可疑/ 值/ ,/ 还/ 能/ 提供/ 额外/ 的/ 上下文/ 信息/ ,/ 供/ 开发者/ 理解/ 错误/ 的/ 产生/ ./ Baah/ 等/ 人/ [/ 7/ ]/ 分析/ 了/ 程序/ 的/ 控制/ 依赖/ 和/ 数据/ 依赖/ ,/ 产生/ 程序/ 依赖图/ ./ 再/ 通过/ 执行/ 测试/ ,/ 计算/ 节点/ 间/ 的/ 条件/ 概率/ ,/ 建立/ 了/ 概率/ 程序/ 依赖图/ ,/ 可以/ 有效/ 的/ 应用/ 于/ 错误/ 定位/ 和/ 错误/ 理解/ ./ 苏小红/ 、/ 龚/ 丹丹/ 等/ 人/ [/ 8/ -/ 9/ ]/ 定义/ 了/ 联合/ 依赖/ 概率模型/ ,/ 在/ 定位/ 过程/ 中/ 分析程序/ 元素/ 间/ 的/ 控制/ 依赖/ 、/ 数据/ 依赖/ 以及/ 语句/ 执行/ 状态/ ./ 这类/ 方法/ 的/ 结果/ 仍/ 可能/ 包含/ 大量/ 信息/ ,/ 这些/ 冗余/ 信息/ 会/ 造成/ 难以/ 找到/ 与/ 错误/ 相关/ 的/ 信息/ ./ Hsu/ 等/ 人/ [/ 10/ ]/ 提出/ 了/ 识别/ 错误/ 签名/ 的/ RAPID/ 方法/ ,/ 通过/ 增量/ 的/ 分析/ 失败/ 的/ 程序执行/ 路径/ 的/ 公共/ 序列/ ,/ 将/ 挖掘/ 得到/ 可疑/ 语句/ 序列/ 作为/ 错误/ 签名/ ,/ 辅助/ 开发人员/ 定位/ 和/ 理解/ 软件/ 错误/ ./ Cheng/ 等/ 人/ [/ 11/ ]/ 对/ 错误/ 签名/ 方法/ 进行/ 了/ 改进/ ,/ 本文/ 将/ 其/ 称为/ LEAP/ 方法/ ,/ 首先/ 利用/ 程序执行/ 路径/ 构/ Page3/ 造/ 软件/ 行为/ 图/ ,/ 再/ 通过/ LEAP/ 图/ 挖掘/ 算法/ ,/ 利用/ 信息/ 增益/ 作为/ 目标/ 函数/ ,/ 从/ 成功/ 测试用例/ 和/ 失败/ 测试用例/ 的/ 软件/ 行为/ 图/ 集合/ 中/ 挖掘出/ Top/ -/ K/ 个/ 在/ 失败/ 的/ 执行/ 中/ 出现/ 很/ 频繁/ ,/ 而/ 在/ 正确/ 的/ 执行/ 中/ 比较/ 少见/ 的/ 最优/ 局部/ 软件/ 行为/ 图/ 作为/ 可疑/ 语句/ 序列/ ./ 该/ 方法/ 能够/ 给出/ 失效/ 产生/ 的/ 上下文/ 且/ 避免/ 了/ 冗余/ 信息/ ,/ 因此/ 有助于/ 定位/ 和/ 理解/ 软件/ 错误/ ./ 然而/ 存在/ 的/ 一个/ 不足之处/ 是/ 软件/ 行为/ 图中/ 所有/ 的/ 控制流/ 路径/ 具有/ 相同/ 的/ 重要/ 程度/ ,/ 而/ 没有/ 考虑/ 语句/ 执行/ 频率/ 与/ 软件/ 失效/ 之间/ 的/ 关联/ ./ 例如/ 错误/ 的/ 条件/ 表达式/ 或/ 循环/ 体内/ 的/ 某些/ 缺陷/ 语句/ ,/ 可能/ 导致/ 循环/ 执行/ 路径/ 和/ 次数/ 的/ 改变/ ,/ 进而/ 导致/ 软件/ 失效/ ./ 对于/ 这种/ 情况/ 如果/ 采用/ LEAP/ 方法/ 进行/ 分析/ ,/ 那么/ 执行/ 了/ 多次/ 循环/ 的/ 测试用例/ 和/ 只/ 执行/ 1/ 次/ 循环/ 的/ 测试用例/ 可能/ 具有/ 相同/ 或/ 相似/ 的/ 软件/ 行为/ 图/ ,/ 如果/ 这/ 两个/ 软件/ 行为/ 图/ 分别/ 对应/ 于/ 成功/ 和/ 失败/ 测试用例/ 的/ 软件/ 行为/ 图/ ,/ 则/ 图/ 挖掘/ 算法/ 将/ 因/ 无法/ 在/ 这/ 两个/ 软件/ 行为/ 图中/ 区分/ 成功/ 执行/ 和/ 失败/ 执行/ 的/ 差异/ 而/ 失效/ ,/ 从而/ 不能/ 有效/ 定位/ 到/ 软件/ 错误/ ./ 类似/ 地/ ,/ 错误/ 的/ 递归/ 也/ 可能/ 导致/ 函数/ 执行/ 路径/ 的/ 改变/ ./ 由于/ 循环/ 和/ 递归/ 是/ 编程语言/ 的/ 基本/ 元素/ ,/ 需要/ 提供/ 一种/ 机制/ 来/ 表示/ 程序执行/ 路径/ 的/ 转移/ 概率/ ,/ 使/ 之/ 可以/ 有效/ 区分/ 成功/ 和/ 失败/ 执行/ 路径/ ./ 本文/ 第/ 4/ 节中用/ 实图/ 1/ 基于/ 加权/ 软件/ 行为/ 图/ 挖掘/ 的/ 错误/ 定位/ 方法/ 的/ 基本/ 流程/ 软件测试/ 和/ 调试/ 过程/ 通常/ 协作/ 来/ 检测/ 和/ 定位/ 软件缺陷/ ,/ 如果/ 在/ 测试/ 过程/ 中/ 获得/ 了/ 测试用例/ 的/ 路径/ 信息/ ,/ 则/ 可/ 直接/ 执行/ 构造/ 加权/ 软件/ 行为/ 图/ 和/ 挖掘/ 错误/ 签名/ ./ 同/ 大多数/ 错误/ 定位/ 方法/ 一样/ ,/ 本文/ 假设/ 测试用例/ 集/ 提供/ 了/ 充分/ 的/ 用以/ 错误/ 定位/ 的/ 测试/ 覆盖/ 信息/ ,/ 能够/ 保证/ 测试/ 覆盖率/ ,/ 错误/ 定位/ 方法/ 的/ 研究/ 重点/ 例/ 进行/ 了/ 详细分析/ ./ 综上所述/ ,/ 目前/ 大多数/ 方法/ 在/ 错误/ 理解/ 方面/ 做/ 的/ 还/ 不够/ 完善/ ,/ 要么/ 只/ 提供/ 可疑/ 语句/ 的/ 列表/ ,/ 缺少/ 可以/ 用于/ 理解/ 错误/ 产生/ 原因/ 的/ 有效/ 上下文/ 信息/ ,/ 要么/ 提供/ 了/ 过/ 多/ 的/ 信息/ ,/ 开发者/ 难以/ 从中/ 找到/ 与/ 错误/ 相关/ 的/ 信息/ ,/ 都/ 不利于/ 开发者/ 理解/ 错误/ 是/ 如何/ 产生/ 的/ ./ 错误/ 签名/ 能够/ 较/ 好/ 的/ 平衡/ 过多/ 和/ 过少/ 的/ 信息/ ,/ 但/ 仍/ 需要/ 考虑/ 程序执行/ 路径/ 的/ 统计学/ 意义/ ,/ 而/ 不仅仅/ 是/ 频繁/ 图/ 的/ 挖掘/ ./ 本文/ 的/ 研究/ 动机/ 就是/ 如何/ 结合/ 统计/ 信息/ 和/ 图/ 挖掘/ 方法/ 进一步提高/ 错误/ 签名/ 的/ 错误/ 定位精度/ ./ 3/ 方法/ 概述/ 3.1/ 方法/ 框架/ 输入/ 是/ 待测/ 程序/ P/ ,/ 以及/ 相应/ 的/ 测试用例/ 集合/ ./ 根据/ 程序/ P/ 执行/ 测试用例/ 的/ 实际/ 输出/ 结果/ ,/ 可以/ 将/ 测试用例/ 分为/ 两类/ :/ 成功/ 的/ 测试用例/ (/ P/ 的/ 实际/ 输出/ 结果/ 与/ 预期/ 输出/ 结果/ 相同/ )/ 和/ 失败/ 的/ 测试用例/ (/ P/ 的/ 实际/ 输出/ 结果/ 与/ 预期/ 输出/ 结果/ 不同/ )/ ./ 本文/ 方法/ 主要/ 包含/ 3/ 个/ 步骤/ :/ 获取/ 程序执行/ 路径/ 、/ 构造/ 加权/ 软件/ 行为/ 图/ 和/ 挖掘/ 错误/ 签名/ ,/ 其/ 流程/ 如图/ 1/ 所示/ ./ 主要/ 放在/ 如何/ 在/ 这/ 一/ 前提条件/ 下/ 快速/ 准确/ 地/ 定位/ 错误/ 所在/ 的/ 语句/ ./ 3.2/ 本文/ 方法/ 与/ LEAP/ 方法/ 的/ 差异/ LEAP/ 方法/ 将/ 测试用例/ 的/ 执行/ 路径/ 表示/ 为/ 软件/ 行为/ 图/ ,/ 不/ 区分/ 路径/ 的/ 执行/ 频率/ ,/ 因此/ 对应/ 的/ 图/ 挖掘/ 算法/ 仅/ 是/ 挖掘/ 成功/ 和/ 失败/ 测试用例/ 集合/ 执行/ 路径/ 中/ Page4/ 的/ 频繁/ 子图/ ./ 方法/ 是/ 采用/ 信息/ 增益/ 作为/ 目标/ 函数/ ,/ 用/ LEAP/ 算法/ 挖掘出/ 区分/ 失败/ 执行/ 和/ 正确/ 执行/ 差异/ 的/ 频繁/ 子图/ ./ 而/ 本文/ 定义/ 的/ 加权/ 软件/ 行为/ 图/ 不但/ 表示/ 了/ 程序/ 软件/ 执行/ 路径/ ,/ 还用/ 边/ 的/ 权重/ 表示/ 了/ 程序/ 路径/ 的/ 执行/ 频率/ ,/ 表示/ 了/ 程序执行/ 的/ 统计/ 信息/ ,/ 在/ 本质/ 上/ 区别/ 于/ 软件/ 行为/ 图/ ./ 此外/ ,/ 本文/ 方法/ 在/ 基于/ 图/ 挖掘/ 定位/ 软件缺陷/ 时/ ,/ 需要/ 考虑/ 路径/ 的/ 权重/ ,/ 即/ 路径/ 执行/ 的/ 统计/ 信息/ ,/ 因此/ ,/ 采用/ 了/ 不同于/ LEAP/ 的/ 目标/ 函数/ 和/ 图/ 挖掘/ 算法/ ./ 具体方法/ 如图/ 1/ 所示/ ,/ 用/ Fisher/ 得分/ 作为/ 目标/ 函数/ ,/ 用/ 分支/ 界限/ 搜索/ 方法/ 挖掘/ 错误/ 签名/ ,/ 并且/ 提出/ 了/ 一系列/ 用来/ 提高/ 挖掘/ 效率/ 和/ 准确率/ 的/ 剪枝/ 和/ 去/ 冗余/ 等/ 算法/ ./ 4/ 关键技术/ 4.1/ 获取/ 程序执行/ 路径/ 为了/ 得到/ 程序/ 的/ 执行/ 路径/ ,/ 需要/ 对待/ 测/ 程序/ 的/ 源代码/ 进行/ 插桩/ ./ 插桩/ 是/ 在/ 保证/ 待测/ 程序/ 原有/ 逻辑/ 和/ 功能/ 不变/ 的/ 条件/ 下/ ,/ 向/ 程序/ 源代码/ 中/ 插入/ 探针/ 语句/ ,/ 用来/ 在/ 程序/ 被/ 执行/ 时/ 输出/ 程序执行/ 信息/ ./ 本文/ 实现/ 语句/ 级别/ 的/ 程序/ 插桩/ ,/ 即/ 跟踪/ 程序/ 中/ 语句/ 的/ 执行/ 信息/ ,/ 每当/ 执行/ 到/ 一条/ 语句/ ,/ 就/ 将/ 被/ 执行/ 语句/ 的/ 行号/ 作为/ 执行/ 路径/ 输出/ ./ 首先/ ,/ 需要/ 对待/ 测/ 程序/ 进行/ 词法/ 分析/ 和/ 语法分析/ ,/ 将/ 源代码/ 转换/ 为/ 等价/ 的/ 抽象/ 语法/ 树/ ,/ 然后/ 对/ 抽象/ 语法/ 树/ 进行/ 分析/ ,/ 找到/ 适合/ 插入/ 探针/ 语句/ 的/ 位置/ ,/ 以/ 保证/ 额外/ 的/ 语句/ 不会/ 影响/ 到/ 现有/ 的/ 程序逻辑/ 和/ 功能/ ./ 例如/ 对于/ C语言/ 中/ 的/ 条件/ 语句/ 和/ 循环/ 语句/ ,/ 由于/ 它们/ 需要/ 在/ 每次/ 执行/ 条件/ 判断/ 时/ 输出/ 行号/ 信息/ ,/ 因此/ 利用/ 逗号/ 表达式/ 直接/ 将/ 探针/ 语句/ 插入/ 到/ 条件/ 表达式/ 中/ ;/ 对于/ 跳转/ 语句/ ,/ 由于/ 它们/ 会/ 立即/ 改变程序/ 的/ 表/ 1findmaxIndex/ 程序/ 的/ 测试用例/ 以及/ 其/ 执行/ 路径/ 序号/ 1234.2/ 构造/ 加权/ 软件/ 行为/ 图表/ 1/ 中/ 的/ 测试用例/ 2/ 执行/ 了/ 两次/ 循环/ 结构/ ,/ 因此/ 路径/ 中/ 包含/ 了/ 两组/ 语句/ 序列/ 3/ ,/ 4/ ,/ 6/ ,/ 7/ ,/ 9/ ,/ 导致/ 其/ 执行/ 路径/ 长于/ 测试用例/ 1/ 的/ 执行/ 路径/ ./ 实际/ 程序/ 中/ ,/ 循环/ 可能/ 会/ 执行/ 若干次/ ,/ 且/ 如果/ 循环/ 结构/ 中/ 包含/ 较/ 多/ 的/ 执行/ 语句/ ,/ 则/ 会/ 导致/ 过长/ 的/ 执行/ 路径/ ./ 特别/ 是/ 当/ 程序/ 中/ 包含/ 大量/ 循环/ 结构/ 的/ 时候/ ,/ 分析/ 起来/ 会/ 非常/ 执行/ 路径/ ,/ 因此/ 必须/ 在/ 其/ 之前/ 插入/ 探针/ 语句/ ./ 接下来/ 将/ 插入/ 探针/ 的/ 抽象/ 语法/ 树/ 反向/ 生成/ 相应/ 的/ 程序代码/ ,/ 即可/ 得到/ 插桩/ 后/ 的/ 程序/ ./ 最后/ ,/ 当/ 执行/ 插桩/ 完毕/ 的/ 待测/ 程序/ 时/ ,/ 插入/ 的/ 探针/ 语句/ 也/ 会/ 被/ 执行/ ,/ 从而/ 输出/ 程序/ 的/ 执行/ 路径/ ./ 如果/ 探针/ 语句/ 将/ 当前/ 正在/ 执行/ 语句/ 的/ 行号/ 输出/ ,/ 那么/ 得到/ 的/ 程序执行/ 路径/ 中/ ,/ 每个/ 节点/ 就/ 表示/ 待测/ 程序/ 中/ 的/ 一条/ 语句/ ./ 以图/ 2/ 所示/ 的/ findmaxIndex/ 程序/ 为例/ ,/ 它/ 是/ 在/ 数字/ 数组/ 中/ 找到/ 最大值/ 首次/ 出现/ 的/ 位置/ ./ main/ 函数/ 中/ 调用/ 了/ findmaxIndex/ 函数/ ./ 为了/ 避免/ 冗余/ 说明/ ,/ 本文/ 将/ main/ 函数/ 中/ 的/ n/ 和/ nums/ 的/ 读取/ 用/ 了/ 伪/ 代码/ 描述/ ./ 3/ 组/ 不同/ 的/ 测试用例/ 及其/ 相应/ 的/ 程序执行/ 路径/ 如表/ 1/ 所示/ ./ 当/ 执行/ 到/ main/ 函数/ 中/ 的/ 函数调用/ 语句/ findmaxIndex/ (/ n/ ,/ nums/ )/ ;/ 时/ ,/ 程序/ 的/ 执行/ 路径/ 发生/ 转移/ ,/ 执行/ findmaxIndex/ 函数/ 中/ 的/ 语句/ ,/ 执行/ 完/ findmaxIndex/ 后/ ,/ 返回/ 到/ main/ 函数/ 中/ 第/ 19/ 行/ ./ 1/ ./ voidfindmaxIndex/ (/ intn/ ,/ int/ / nums/ )/ {/ 2/ ./ inti/ =/ 0/ ,/ maxIdx/ =/ -/ 1/ ;/ 3/ ./ while/ (/ i/ </ n/ )/ {/ 4/ ./ if/ (/ maxIdx/ =/ =/ -/ 1/ )/ {/ 5/ ./ maxIdx/ =/ i/ ;/ 6/ ./ }/ elseif/ (/ nums/ [/ i/ ]/ >/ =/ nums/ [/ maxIdx/ ]/ )/ {/ 7/ ./ maxIdx/ =/ i/ ;/ 8/ ./ }/ 9/ ./ i/ ++/ ;/ 10/ ./ }/ 11/ ./ printf/ (/ "/ %/ d/ "/ ,/ maxIdx/ )/ ;/ 12/ ./ }/ 13/ ./ voidmain/ (/ )/ 14/ ./ {/ 15/ ./ intn/ ,/ / nums/ ;/ 16/ ./ read/ (/ n/ )/ ;/ 17/ ./ read/ (/ nums/ )/ ;/ 18/ ./ findmaxIndex/ (/ n/ ,/ nums/ )/ ;/ 19/ ./ }/ 困难/ ,/ 需要/ 消耗/ 大量/ 的/ 空间/ 和/ 时间/ ./ 而且/ ,/ 由于/ 其中/ 包含/ 的/ 信息/ 过多/ ,/ 很难/ 从中/ 提取/ 关键/ 信息/ ,/ 因此/ 很/ 有/ 必要/ 对/ 程序执行/ 路径/ 进行/ 进一步/ 处理/ ./ 为了/ 解决/ 这一/ 问题/ ,/ Cheng/ 等/ 人/ [/ 11/ ]/ 提出/ 了/ 软件/ 行为/ 图/ ./ 软件/ 行为/ 图是/ 一幅/ 有向图/ ,/ 图中/ 的/ 顶点/ 对应/ 于/ 程序执行/ 路径/ 中/ 包含/ 的/ 语句/ ,/ 顶点/ 间/ 的/ 边/ 对应/ 于/ 程序/ 语句/ 执行/ 时/ 的/ 顺序/ 关系/ ./ 软件/ 行为/ 图/ 有效/ 地压/ Page5/ 缩/ 了/ 程序执行/ 路径/ ,/ 在/ 保留/ 了/ 程序执行/ 路径/ 的/ 特征/ 信息/ 的/ 同时/ ,/ 去/ 除了/ 很多/ 冗余/ 信息/ ,/ 可以/ 有效/ 减少/ 数据量/ ,/ 节省时间/ 和/ 空间/ ,/ 而且/ 更/ 有利于/ 进一步/ 的/ 处理/ ./ 例如/ 表/ 1/ 语句/ 3/ ,/ 4/ ,/ 6/ ,/ 7/ ,/ 9/ ,/ 在/ 测试用例/ 2/ 中/ 被/ 循环/ 执行/ 了/ 2/ 遍/ ,/ 但是/ 行为/ 图中/ 通过/ 将/ 其/ 表示/ 为/ 控制流/ 图/ 的/ 循环/ 结构/ 形式/ ,/ 使/ 这些/ 节点/ 只/ 出现/ 一次/ ,/ 有效/ 压缩/ 了/ 该/ 路径/ 的/ 表示/ ,/ 如图/ 3/ (/ b/ )/ 所示/ ./ 同理/ 如果/ 其他/ 测试用例/ 执行/ 多次/ 该/ 循环/ 结构/ ,/ 节点/ 3/ ,/ 4/ ,/ 6/ ,/ 7/ ,/ 9/ ,/ 仍/ 只/ 需/ 表示/ 一次/ ./ 图/ 3findmaxIndex/ 程序/ 各个/ 执行/ 路径/ 的/ 软件/ 行为/ 图/ 软件/ 行为/ 图/ 可以/ 认为/ 是/ 与/ 特定/ 执行/ 相关/ 的/ 控制流/ 图/ ./ 如果/ 执行/ 路径/ 覆盖/ 到/ 了/ 所有/ 的/ 语句/ 和/ 所有/ 可能/ 的/ 语句/ 执行/ 顺序/ ,/ 那么/ 软件/ 行为/ 图/ 就/ 与/ 控制流/ 图是/ 相同/ 的/ ;/ 如果/ 执行/ 路径/ 仅/ 覆盖/ 到/ 了/ 部分/ 语句/ ,/ 或者/ 未能/ 包含/ 全部/ 可能/ 的/ 语句/ 执行/ 顺序/ ,/ 那么/ 就/ 只/ 包含/ 控制流/ 图/ 的/ 一部分/ ./ 当/ 存在/ 函数调用/ 时/ 控制流/ 图可/ 通过/ 增加/ 函数调用/ 边/ 和/ 返回/ 边来/ 表示/ 为/ 过程/ 间/ 控制流/ 图/ ,/ 同样/ 软件/ 行为/ 图/ 也/ 可以/ 类似/ 地/ 表示/ 函数调用/ 关系/ [/ 11/ ]/ ./ 但是/ ,/ 软件/ 行为/ 图中/ 只/ 包含/ 了/ 语句/ 是否/ 被/ 执行/ 以及/ 语句/ 执行/ 顺序/ 的/ 信息/ ,/ 而/ 没有/ 考虑/ 到/ 语句/ 执行/ 频率/ 对/ 错误/ 定位/ 结果/ 的/ 影响/ ,/ 不能/ 很/ 好/ 的/ 处理/ 循环/ 和/ 递归/ 等/ 结构/ ./ 例如/ ,/ 对于/ 表/ 1/ ,/ 成功/ 测试用例/ 1/ 和/ 失败/ 测试用例/ 3/ 的/ 执行/ 路径/ 是/ 不同/ 的/ ,/ 但是/ 却/ 具有/ 相同/ 软件/ 行为/ 图/ 表示/ ,/ 如图/ 3/ (/ a/ )/ 所示/ ./ 如果/ 比较/ 测试用例/ 1/ 和/ 3/ 的/ 软件/ 行为/ 图则/ 因/ 无法/ 区分/ 成功/ 执行/ 与/ 失败/ 执行/ 之间/ 的/ 差异/ 而/ 无法/ 有效/ 定位/ 缺陷/ 语句/ ./ 基于/ 以上/ 分析/ ,/ 本文/ 提出/ 了/ 加权/ 软件/ 行为/ 图/ ./ 定义/ 1/ (/ 加权/ 软件/ 行为/ 图/ )/ ./ 加权/ 软件/ 行为/ 图是/ 一个/ 四元组/ (/ V/ ,/ E/ ,/ L/ ,/ W/ )/ ,/ 其中/ V/ 是/ 顶点/ 集合/ ,/ 包含/ 程序执行/ 路径/ 中/ 出现/ 的/ 所有/ 程序/ 实体/ ,/ E/ / V/ ×/ V/ 是/ 有/ 向/ 边/ 的/ 集合/ ,/ L/ 是/ 边/ 与其/ 标签/ 的/ 映射/ ,/ W/ 是/ 边/ 与其/ 权重/ 的/ 映射/ ./ 边/ 〈/ vi/ ,/ vj/ 〉/ ∈/ E/ 的/ 标签/ ,/ 可能/ 是/ “/ 调用/ ”/ 、/ “/ 转移/ ”/ 或/ “/ 返回/ ”/ 之一/ :/ 如果/ vi/ 调用/ 了/ vj/ ,/ 〈/ vi/ ,/ vj/ 〉/ 就/ 被/ 标记/ 为/ “/ 调用/ ”/ ./ 如果/ 从/ vi/ 返回/ 到/ 了/ vj/ ,/ 则/ 将/ 〈/ vi/ ,/ vj/ 〉/ 标记/ 为/ “/ 返回/ ”/ ./ 否则/ 将/ 〈/ vi/ ,/ vj/ 〉/ 标记/ 为/ “/ 转移/ ”/ ,/ 表示/ vj/ 紧跟/ 在/ vi/ 之后/ 执行/ ./ 这/ 3/ 种/ 标签/ 表示/ 了/ 程序/ 实体/ 间/ 的/ 3/ 种/ 可能/ 的/ 控制流/ 关系/ ./ 每条/ 边/ 还/ 附加/ 有/ 一个/ 权重/ w/ ./ 由于/ 在/ 待测/ 程序/ 的/ 不同/ 执行/ 中/ ,/ 同/ 一条/ 语句/ 的/ 执行/ 次数/ 可能/ 会/ 有/ 很大/ 区别/ ,/ 因此/ 直接/ 将/ 语句/ 执行/ 次数/ 作为/ 权重/ 并/ 不/ 合适/ ,/ 而是/ 采用/ 语句/ 的/ 执行/ 概率/ 作为/ 权重/ ./ 若图/ 中/ 某/ 条边/ ei/ 的/ 起始/ 顶点/ 和/ 结束/ 顶点/ 分别/ 为/ pk/ 和/ pj/ ,/ pk/ 的/ 出边/ (/ 以/ pk/ 为/ 起始/ 顶点/ 的/ 边/ )/ 集合/ E/ =/ {/ e1/ ,/ e2/ ,/ …/ ,/ en/ }/ ,/ 其中/ 每条/ 边/ 在/ 执行/ 路径/ 中/ 出现/ 的/ 次数/ 分别/ 为/ ci/ ,/ 则/ 边/ ei/ 的/ 权重/ 计算公式/ 为/ 权重/ wi/ 表示/ 了/ 在/ 此次/ 执行/ 中/ ,/ 顶点/ pk/ 被/ 执行/ 后/ ,/ 顶点/ pj/ 会/ 被/ 执行/ 的/ 概率/ ./ 对于/ 同一个/ 顶点/ 的/ 出边/ ,/ 它们/ 的/ 权重/ 和/ 为/ 1/ ,/ 即/ 有/ 含有/ 条件/ 判定/ 的/ 语句/ 可能/ 有/ 多条/ 执行/ 路径/ 分支/ ,/ 边/ 的/ 权重/ 代表/ 了/ 各个/ 路径/ 的/ 执行/ 频率/ ./ 如图/ 4/ (/ a/ )/ 所示/ ,/ 对于/ 测试用例/ 1/ 的/ 路径/ 1/ ,/ 其/ 语句/ 3/ 有/ 两个/ 分支/ 3/ →/ 4/ 和/ 3/ →/ 11/ ,/ 它们/ 在/ 循环/ 中/ 的/ 执行/ 次数/ 分别/ 为/ 3/ 和/ 1/ ,/ 因此/ 边/ 3/ →/ 4/ 的/ 权重/ 为/ 3/ // (/ 3/ +/ 1/ )/ =/ 0.75/ ,/ 边/ 3/ →/ 11/ 的/ 权重/ 为/ 0.25/ ./ 不同/ 执行/ 频率/ 的/ 路径/ 意味着/ 不同/ 的/ 执行/ 上下文/ ,/ 也/ 可能/ 导致/ 不同/ 的/ 执行/ 结果/ (/ 成功/ // 失败/ )/ ./ 图/ 4/ (/ a/ )/ 成功/ 测试用例/ 1/ 和/ 图/ 4/ (/ c/ )/ 失败/ 测试用例/ 3/ 的/ 加权/ 行为/ 图中/ 的/ 边/ 3/ →/ 4/ ,/ 3/ →/ 11/ ,/ 4/ →/ 6/ ,/ 4/ →/ 5/ ,/ 6/ →/ 9/ ,/ 6/ →/ 7/ 的/ 权重/ 不同/ ,/ 有效/ 区分/ 了/ 成功/ 测试用例/ 和/ 失败/ 测试用例/ 的/ 软件/ 行为/ 图/ ,/ 尤其/ 是/ 对/ 与/ 缺陷/ 语句/ 相关/ 的/ 执行/ 路径/ 做出/ 了/ 很/ 好/ 的/ 区分/ ./ 有/ 了/ 程序执行/ 路径/ ,/ 只要/ 不断/ 的/ 将/ 执行/ 路径/ 中/ 出现/ 的/ 边/ 添加/ 到/ 有向图/ 中/ ,/ 就/ 可以/ 得到/ 软件/ 行为/ 图/ ./ 按照/ 式/ (/ 1/ )/ 计算/ 边/ 的/ 权重/ ,/ 就/ 得到/ 了/ 加权/ 软件/ 行为/ 图/ ./ 其/ 算法/ 如/ 算法/ 1/ 所示/ ,/ 使用/ V/ (/ G/ )/ 表示/ 加权/ 软件/ 行为/ 图/ G/ 的/ 顶点/ 集/ ,/ 使用/ E/ (/ G/ )/ 表示/ 加权/ 软件/ 行为/ Page6/ 图/ 4findmaxIndex/ 程序/ 各个/ 执行/ 路径/ 的/ 加权/ 软件/ 行为/ 图图/ G/ 的/ 边集/ ./ 算法/ 1/ ./ 构造/ 加权/ 软件/ 行为/ 图/ ./ 输入/ :/ 待测/ 程序/ 的/ 执行/ 路径/ 输出/ :/ 相应/ 的/ 加权/ 软件/ 行为/ 图/ G1/ ./ G/ =/ / ;/ 2/ ./ last/ =/ NULL/ ;/ 3/ ./ FOR/ 执行/ 路径/ 中/ 的/ 每条/ 语句/ s4/ ./ IFlast/ 不为/ NULL5/ ./ V/ (/ G/ )/ =/ V/ (/ G/ )/ ∪/ {/ s/ }/ ;/ 6/ ./ E/ (/ G/ )/ =/ E/ (/ G/ )/ ∪/ {/ 〈/ last/ ,/ s/ 〉/ }/ ;/ 7/ ./ Count/ 〈/ last/ ,/ s/ 〉/ =/ Count/ 〈/ last/ ,/ s/ 〉/ +/ 1/ ;/ 8/ ./ Sumlast/ =/ Sumlast/ ++/ ;/ 9/ ./ ENDIF10/ ./ last/ =/ s/ ;/ 11/ ./ ENDFOR12/ ./ FORG/ 中/ 的/ 每个/ 顶点/ v13/ ./ FOR/ 以/ v/ 为/ 起始/ 顶点/ 的/ 每/ 条边/ 〈/ v/ ,/ k/ 〉/ 14/ ./ 〈/ v/ ,/ k/ 〉/ 的/ 权重/ 为/ Count/ 〈/ last/ ,/ s/ 〉/ // Sumlast15/ ./ ENDFOR16/ ./ ENDFOR17/ ./ RETURNG/ ;/ 4.3/ 识别/ 错误/ 签名/ 使用/ 不同/ 的/ 测试用例/ 多次/ 执行/ 待测/ 程序/ ,/ 可以/ 得到/ 一个/ 加权/ 软件/ 行为/ 图/ 的/ 集合/ G/ ./ 根据/ 执行/ 的/ 测试用例/ 是/ 成功/ 的/ 还是/ 失败/ 的/ ,/ 可以/ 将/ G/ 划分/ 为/ 两个/ 子集/ ,/ 一个/ 包含/ 与/ 成功/ 的/ 测试用例/ 对应/ 的/ 加权/ 软件/ 行为/ 图/ ,/ 记为/ Gpass/ ;/ 另/ 一个/ 包含/ 与/ 失败/ 的/ 测试用例/ 对应/ 的/ 加权/ 软件/ 行为/ 图/ ,/ 记为/ Gfail/ ,/ G/ =/ Gpass/ ∪/ Gfail/ ./ 在/ 理想/ 情况/ 下/ ,/ 有/ 在/ 理想/ 情况/ 下/ ,/ Gfail/ 即为/ 需要/ 分析/ 的/ 可能/ 包含/ 缺陷/ 语句/ 的/ 子/ 图/ ,/ 然而/ ,/ 现实情况/ 下/ ,/ 失败/ 测试用例/ 和/ 成功/ 用例/ 常常/ 执行/ 一些/ 公共/ 的/ 程序/ 语句/ (/ 既/ 可能/ 包含/ 正确/ 也/ 可能/ 包含/ 缺陷/ 语句/ )/ ./ 因此/ ,/ Gpass/ 与/ Gfail/ 的/ 交集/ 不/ 一定/ 为空/ ./ 例如/ 图/ 4/ 例子/ 中/ Gpass/ =/ {/ 子图/ (/ a/ )/ }/ ,/ Gfail/ =/ {/ 子图/ (/ b/ )/ ,/ 子图/ (/ c/ )/ }/ ,/ Gpass/ ∩/ Gfail/ ≠/ / 包含/ 了/ 图/ 4/ 中/ 所有/ 语句/ 节点/ ./ 加权/ 软件/ 行为/ 图/ 的/ 挖掘/ 目标/ ,/ 是/ 在/ G/ 中/ 找到/ 一个/ 最优/ 的/ 子/ 图/ g/ ,/ 使得/ g/ 可以/ 指出/ 错误/ 所在/ ,/ 并/ 提供/ 与/ 错误/ 相关/ 的/ 上下文/ 信息/ ./ 而/ 这个/ 最优/ 的/ 子/ 图/ g/ ,/ 就/ 被/ 称为/ 错误/ 签名/ ./ 例如/ 图/ 4/ 例子/ 中/ 的/ 最优/ 子图/ 即/ 错误/ 签名/ 为/ 6/ →/ 7/ ./ 通常/ 认为/ ,/ 错误/ 语句/ 应该/ 被/ 失败/ 测试用例/ 大量/ 的/ 执行/ ,/ 而/ 被/ 成功/ 测试用例/ 少量/ 的/ 执行/ ,/ 即/ 错误/ 语句/ 在/ Gfail/ 和/ Gpass/ 中/ 的/ 出现/ 频率/ 应当/ 有/ 显著/ 的/ 区别/ ./ 那么/ ,/ 可以/ 设计/ 一个/ 目标/ 函数/ F/ (/ g/ )/ ,/ 来/ 评价/ 子图/ g/ 对/ 成功/ 的/ 执行/ 和/ 失败/ 的/ 执行/ 间/ 差异/ 的/ 辨别/ 能力/ ./ 该/ 问题/ 就/ 转化/ 为/ 在/ G/ 中/ ,/ 寻找/ 一个/ 最优/ 子图/ g/ ,/ 使得/ F/ (/ g/ )/ 最大/ 的/ 优化/ 问题/ ./ 本文/ 采用/ Fisher/ 得分/ 作为/ 目标/ 函数/ F/ (/ g/ )/ 的/ 判据/ ,/ Fisher/ 得分/ 以/ 最大化/ 类间/ 离散/ 度/ 和/ 最小化/ 类内/ 离散/ 度为/ 目标/ 准则/ [/ 13/ ]/ ./ 在/ Gfail/ 中/ 出现/ 频率/ 普遍/ 较/ 高/ ,/ 而/ 在/ Gpass/ 中/ 出现/ 频率/ 普遍/ 较/ 低/ 的/ 子/ 图/ ,/ 会/ 具有/ 更/ 高/ 的/ Fisher/ 得分/ ,/ 它/ 也/ 可以/ 更好/ 的/ 指出/ 成功/ 和/ 失败/ 的/ 执行/ 间/ 的/ 差异/ ./ 令/ G1/ ,/ G2/ ,/ …/ ,/ Gm/ 表示/ m/ 次/ 不同/ 的/ 执行/ 对应/ 的/ 加权/ 软件/ 行为/ 图/ ,/ 对于/ 特定/ 的/ 子/ 图/ g/ ,/ 其边/ 集/ E/ =/ {/ e1/ ,/ e2/ ,/ …/ ,/ en/ }/ ,/ 使用/ fj/ 率/ ,/ 其/ 定义/ 为/ Page7/ 其中/ ,/ wj/ 和/ 结束/ 顶点/ 的/ 边/ 的/ 权重/ ./ 使用/ μ/ 频率/ 的/ 均值/ :/ 使用/ (/ σ/ pass/ 出现/ 频率/ 的/ 方差/ :/ 运用/ Fisher/ 准则/ ,/ 得到/ 边/ ei/ 的/ Fisher/ 得/ 分为/ 最后/ ,/ 将/ g/ 中/ 所有/ 边/ 的/ Fisher/ 得分/ 求/ 平均数/ ,/ 得到/ 目标/ 函数/ F/ (/ g/ )/ 的/ 计算公式/ 为/ 4.3/ ./ 1/ 剪枝/ 策略/ 由于/ G/ 中/ 可能/ 包含/ 指数/ 级别/ 的/ 子/ 图/ ,/ 因此/ 直接/ 进行/ 搜索/ 会/ 消耗/ 大量/ 的/ 时间/ ,/ 需要/ 对/ 搜索/ 过程/ 运用/ 剪枝/ 策略/ ./ 对于/ 某一子/ 图/ g/ ,/ 它/ 在/ Gpass/ 和/ Gfail/ 中/ 出现/ 的/ 频率/ 一定/ 不/ 小于/ 其/ 超图/ 的/ 出现/ 次数/ ./ 即/ g/ 的/ 超图/ 在/ Gpass/ 中/ 出现/ 的/ 次数/ 大于/ 等于零/ ,/ 且/ 小于/ 等于/ g/ 在/ Gpass/ 中/ 出现/ 的/ 次数/ ;/ 在/ Gfail/ 中/ 出现/ 的/ 次数/ 大于/ 等于零/ ,/ 且/ 小于/ 等于/ g/ 在/ Gfail/ 中/ 出现/ 的/ 次数/ ./ 因此/ ,/ g/ 的/ 超图/ 的/ 得分/ 具有/ 一个/ 上/ 限值/ ,/ 可以/ 通过/ 判断/ 该/ 上限/ 来/ 进行/ 剪枝/ ./ 边/ ei/ 的/ Fisher/ 得分/ 上限/ 为/ g/ 的/ 超图/ 的/ 目标/ 函数/ 值/ 上限/ 为/ 4.3/ ./ 2/ 子图/ 的/ 选择/ 和/ 去/ 冗余/ 在/ 加权/ 软件/ 行为/ 图中/ ,/ 并/ 不是/ 所有/ 子图/ 都/ 可能/ 是/ 错误/ 签名/ ./ 首先/ ,/ 错误/ 签名/ 应当/ 是/ 有/ 一定/ 实际意义/ 的/ 子/ 图/ ,/ 能够/ 表示/ 错误/ 的/ 上下文/ ,/ 即/ 如果/ 按照/ 子图/ 给出/ 的/ 顺序/ 执行程序/ ,/ 就/ 很/ 可能/ 导致/ 错误/ 产生/ ./ 包含/ 复杂/ 分支/ 的/ 子/ 图/ ,/ 如图/ 5/ 所示/ ,/ 反而/ 会/ 让/ 开发者/ 难以/ 理解/ 其/ 表示/ 的/ 意义/ ,/ 不利于/ 理解/ 错误/ 产生/ 的/ 原因/ ./ 因此/ ,/ 可以/ 作为/ 错误/ 签名/ 的/ 子/ 图/ ,/ 应当/ 具有/ 执行/ 顺序/ ,/ 需要/ 在/ 选择/ 子图/ 时/ 予以/ 保证/ ./ 其次/ ,/ 方法/ 的/ 调用/ 与/ 方法/ 的/ 返回/ 是/ 一一对应/ 的/ ,/ 即/ 如果/ 方法/ a/ 调用/ 了/ 方法/ b/ ,/ 那么/ 一定/ 会/ 从/ 方法/ b/ 中/ 返回/ 到/ a/ ./ 如果/ 方法/ c/ 也/ 调用/ 了/ 方法/ b/ ,/ 那么/ 也/ 一定/ 会/ 从/ b/ 中/ 返回/ 到/ c/ ./ 将/ 该/ 执行/ 过程/ 转换/ 为/ 软件/ 行为/ 图/ ,/ 结果/ 如图/ 6/ 所示/ ./ 这里/ 有效/ 的/ 子/ 图/ 只有/ a/ →/ b/ →/ a/ 和/ c/ →/ b/ →/ c/ ,/ 而子/ 图/ a/ →/ b/ →/ c/ 和/ c/ →/ b/ →/ a/ 都/ 是/ 无效/ 的/ 子/ 图/ ,/ 不/ 可能/ 在/ 实际/ 运行/ 中/ 出现/ ./ 在/ 选择/ 子图/ 的/ 时候/ 必须/ 将/ 无效/ 的/ 子/ 图/ 去除/ ,/ 否则/ 可能/ 会/ 影响/ 错误/ 定位/ 的/ 结果/ ./ 过滤/ 子图/ 的/ 算法/ 如/ 算法/ 2/ 所示/ ,/ 使用/ 堆栈/ 来/ 检查/ 调用/ 边/ 是否/ 与/ 返回/ 边/ 一一对应/ ./ 例如/ 对于/ 有效/ 的/ 方法/ 调用/ 返回/ 序列/ a/ →/ b/ →/ c/ →/ b/ →/ a/ 而言/ ,/ 首先/ 调用/ 边/ a/ →/ b/ 入栈/ ,/ 调用/ 边/ b/ →/ c/ 入栈/ ,/ 接下来/ 分析/ 返回/ 边/ c/ →/ b/ ,/ 此时/ 栈顶/ 是/ b/ →/ c/ 与/ c/ →/ b/ 对应/ ,/ 为/ 有效/ 路径/ ,/ 栈顶/ b/ →/ c/ 出栈/ ,/ a/ →/ b/ 变为/ 栈顶/ ,/ 此时/ 分析/ b/ →/ a/ 与/ 栈顶/ 对应/ ,/ a/ →/ b/ 出栈/ ,/ 判定/ 路径/ 有效/ ./ 如果/ 当前/ 分析/ 的/ 返回/ 边/ e/ 与/ 栈顶/ 对应/ ,/ 则/ 栈顶/ 出栈/ ,/ 否则/ 说明/ 所/ 分析/ 的/ 路径/ 为/ 无效/ 路径/ ,/ 于是/ 在/ 清空/ 堆栈/ 后/ 返回/ ./ 算法/ 2/ ./ 过滤/ 无效/ 子图/ ./ 输入/ :/ 需要/ 检测/ 是否/ 有效/ 的/ 子/ 图/ g/ 输出/ :/ 子图/ 是/ 有效/ 的/ 还是/ 无效/ 的/ 1/ ./ stack/ =/ / ;/ 2/ ./ FORg/ 中/ 的/ 每/ 条边/ e3/ ./ IFe/ 为/ 调用/ 边/ 4/ ./ stack/ ./ push/ (/ e/ )/ ;/ 5/ ./ ELSEIFe/ 为/ 返回/ 边/ 6/ ./ IFstack/ ./ top/ 与/ e/ 不/ 对应/ 7/ ./ stack/ =/ / ;/ 8/ ./ RETURN/ 无效/ ;/ 9/ ./ ELSEPage810/ ./ stack/ ./ pop/ (/ )/ ;/ 11/ ./ ENDIF12/ ./ ENDIF13/ ./ ENDFOR14/ ./ RETURN/ 有效/ ;/ 最后/ ,/ 在/ 挖掘/ 得到/ 的/ 多个/ 错误/ 签名/ 之间/ ,/ 可能/ 具有/ 包含/ 关系/ ,/ 因此/ 定义/ 下列/ 规则/ ,/ 来/ 合并/ 相互/ 包含/ 的/ 错误/ 签名/ ,/ 减少/ 冗余/ ./ 对于/ 两个/ 存在/ 包含/ 关系/ 的/ 错误/ 签名/ M/ 和/ N/ (/ 无论/ M/ / N/ 还是/ M/ / N/ )/ :/ 若/ F/ (/ M/ )/ / F/ (/ N/ )/ ,/ 则/ 删去/ N/ ./ 这样/ ,/ 存在/ 包含/ 关系/ 的/ 错误/ 签名/ 中/ ,/ 只会/ 保留/ 得分/ 更/ 高/ 的/ 错误/ 签名/ ,/ 可以/ 有效/ 地/ 减少/ 冗余/ 信息/ ./ 4.4/ 基于/ 分支/ 限界/ 搜索/ 的/ 加权/ 软件/ 行为/ 图/ 挖掘/ 本文/ 采用/ 如/ 算法/ 3/ 所示/ 的/ 分支/ 限界/ 搜索算法/ 来/ 挖掘/ 错误/ 签名/ ./ 在/ 错误/ 定位/ 中/ ,/ 仅仅/ 报告/ 唯一/ 的/ 最佳/ 错误/ 签名/ ,/ 往往/ 并/ 不足以/ 提供/ 足够/ 的/ 信息/ ./ 按照/ 可疑/ 度/ 降序/ 给出/ 多个/ 不同/ 的/ 错误/ 签名/ ,/ 更/ 有助于/ 开发者/ 理解/ 错误/ ,/ 因此/ 算法/ 3/ 会/ 返回/ Top/ -/ K/ 个/ 错误/ 签名/ ./ 算法/ 3/ ./ 挖掘/ Top/ -/ K/ 错误/ 签名/ ./ 输入/ :/ 加权/ 软件/ 行为/ 图/ 集合/ G/ ,/ 结果/ 数/ K/ 输出/ :/ Top/ -/ K/ 错误/ 签名/ g/ / 1/ ./ S/ =/ {/ G/ 中/ 只/ 包含/ 一条/ 边/ 的/ 子/ 图/ }/ ;/ 2/ ./ g/ / =/ / ;/ 3/ ./ WHILES/ ≠/ / 4/ ./ 从/ S/ 中/ 选择/ g/ ,/ S/ =/ S/ \/ {/ g/ }/ ;/ 5/ ./ IFg/ 未/ 检查/ 过且/ 有效/ 6/ ./ 用式/ (/ 8/ )/ 和/ (/ 10/ )/ 计算/ F/ (/ g/ )/ 和/ Fmax/ (/ g/ )/ ;/ 7/ ./ IFF/ (/ g/ )/ >/ min8/ ./ g/ / =/ g/ / ∪/ {/ g/ }/ ;/ 9/ ./ 移除/ g/ / 中/ 的/ 冗余/ 结果/ ./ 10/ ./ IFg/ / 包含/ 的/ 错误/ 签名/ 数量/ 大于/ K11/ ./ 移除/ g/ / 中/ 得分/ 最小/ 的/ 错误/ 签名/ 12/ ./ ENDIF13/ ./ ENDIF14/ ./ IFFmax/ (/ g/ )/ >/ min15/ ./ 扩展/ g/ 的/ 最后/ 一个/ 节点/ 并/ 将/ 其/ 加入/ S/ ;/ 16/ ./ ENDIF17/ ./ ENDIF18/ ./ ENDWHILE19/ ./ RETURNg/ / ;/ 为了/ 选择/ 具有/ 执行/ 顺序/ 的/ 子/ 图/ ,/ 算法/ 3/ 每次/ 只会/ 扩展/ 子图/ 的/ 最后/ 一个/ 节点/ ,/ 而/ 不是/ 在/ 任意/ 位置/ 进行/ 扩展/ ./ 该/ 策略/ 在/ 提高/ 了/ 执行/ 效率/ 的/ 同时/ ,/ 也/ 保证/ 了/ 子/ 图/ 能够/ 具有/ 执行/ 顺序/ ./ 最后/ 得到/ 的/ Top/ -/ K/ 错误/ 签名/ ,/ 就/ 可以/ 作为/ 错误/ 定位/ 的/ 依据/ ,/ 错误/ 签名/ 中/ 包含/ 的/ 节点/ 对应/ 于/ 可能/ 导致/ 错误/ 发生/ 的/ 语句/ ,/ 可以/ 用于/ 进行/ 错误/ 理解/ ./ 4.5/ 错误/ 签名/ 实例/ 以/ SiemensSuite/ [/ 14/ ]/ 中/ 的/ replace/ 程序/ 版本/ 9/ 为例/ 展示/ 本文/ 方法/ 挖掘/ 得到/ 的/ 错误/ 签名/ ./ 该/ 程序/ 的/ dodash/ 函数/ 中/ ,/ 存在/ 如图/ 7/ (/ a/ )/ 所示/ 的/ 缺失/ 代码/ 错误/ :/ 第/ 3/ 行/ 代码/ 中/ 包含/ 一个/ 缺失/ 代码/ 错误/ ,/ if/ 语句/ 的/ 条件/ 中/ 缺失/ 了/ 一个/ 条件/ ,/ 导致/ 在/ 某些/ 情况/ 下/ ,/ 本应/ 执行/ 第/ 10/ 行/ else/ 语句/ 块/ 内/ 的/ 代码/ ,/ 但/ 实际/ 执行/ 的/ 却是/ 第/ 5/ 行/ 的/ for/ 循环/ ,/ 从而/ 产生/ 错误/ ./ 图/ 7replace/ 程序/ 版本/ 9/ 的/ 代码/ 片段/ 及其/ 得到/ 的/ 错误/ 签名/ 本文/ 定位/ 方法/ 得到/ 的/ 错误/ 签名/ 如图/ 7/ (/ b/ )/ 所示/ ,/ 错误/ 签名/ 中/ 的/ 每个/ 数字/ 都/ 与/ 图/ 7/ (/ a/ )/ 所示/ 代码/ 片段/ 的/ 语句/ 行号/ 对应/ ./ 该/ 错误/ 签名/ 表示/ 错误/ 语句/ 就/ 在/ 第/ 2/ 、/ 5/ 、/ 9/ 和/ 12/ 这/ 4/ 行/ 代码/ 之中/ ,/ 而且/ 如果/ 按照/ 语句/ 2/ 、/ 5/ 、/ 9/ 、/ 12/ 的/ 顺序/ 执行/ 代码/ ,/ 就/ 很/ 可能/ 会/ 导致/ 错误/ ./ 开发者/ 就/ 可以/ 根据/ 错误/ 签名/ 给出/ 的/ 执行/ 顺序/ ,/ 去/ 理解/ 为什么/ 会/ 产生/ 错误/ ,/ 找到/ 并/ 修正/ 真正/ 引起/ 错误/ 的/ 语句/ ./ 注意/ 到/ 产生/ 错误/ 的/ 原因/ ,/ 是因为/ 没有/ 满足条件/ src/ [/ / i/ -/ 1/ ]/ </ =/ src/ [/ / i/ +/ 1/ ]/ ,/ 因该/ 条件/ 缺失/ 导致/ 改变/ 了/ 程序/ 的/ 执行/ 路径/ ,/ 即本应/ 执行/ 语句/ 10/ 却/ 执行/ 了/ 语句/ 5/ ./ 而/ 此时/ ,/ 必有/ src/ [/ / i/ -/ 1/ ]/ >/ src/ [/ / i/ +/ 1/ ]/ (/ 因/ 缺失/ 的/ 条件/ src/ [/ / i/ -/ 1/ ]/ </ =/ src/ [/ / i/ +/ 1/ ]/ 未/ 被/ 满足/ )/ ,/ 所以/ 有/ k/ =/ src/ [/ / i/ -/ 1/ ]/ +/ 1/ >/ src/ [/ / i/ +/ 1/ ]/ ,/ 这样/ for/ 循环/ 的/ 条件/ k/ </ =/ src/ [/ / i/ +/ 1/ ]/ 一定/ 为/ 假/ ,/ 因此/ 会/ 跳/ 过/ 循环体/ 直接/ 执行/ 语句/ 9/ ,/ 最后/ 执行/ 语句/ 12/ ./ 因此/ ,/ 实际/ 产生/ 错误/ 的/ 执行/ 路径/ 是/ 2/ →/ 5/ →/ 9/ →/ 12/ ,/ 与/ 图/ 7/ (/ b/ )/ 所示/ 的/ 错误/ 签名/ 是/ 相同/ 的/ ./ 这个/ 例子/ 说明/ ,/ 错误/ 签名/ 与/ 实际/ 产生/ 错误/ 的/ 执行/ 路径/ 是/ 相同/ 的/ ,/ 因此/ 错误/ 签名/ 相当于/ 指出/ 了/ 错误/ 的/ 执行/ 路径/ ,/ 有/ 了/ 这样/ 的/ 错误/ 上下文/ 信息/ ,/ 我们/ 就/ 可/ Page9/ 以/ 通过/ 分析/ 为什么/ 会/ 执行/ 这个/ 错误/ 的/ 路径/ ,/ 原因/ 一定/ 是/ 分支/ 的/ 判断/ 条件/ 限制/ 不够/ 严格/ ,/ 从而/ 发现/ 真正/ 产生/ 错误/ 的/ 语句/ 是/ 语句/ 2/ ./ 显然/ 这比/ 单纯/ 地/ 给出/ 最/ 可疑/ 的/ 语句/ 是/ 语句/ 2/ 更/ 有助于/ 开发者/ 理解/ 错误/ 产生/ 的/ 原因/ ,/ 也/ 更/ 有利于/ 开发者/ 修正/ 错误/ ./ 5/ 实验/ 采用/ C#/ 语言/ 实现/ 了/ C语言/ 词法/ 语法分析/ 工具/ CParser/ 、/ 程序/ 插桩/ 工具/ 和/ 本文/ 方法/ 、/ LEAP/ 、/ Tarantula/ 方法/ ./ 5.1/ 实验/ 建立/ 本文/ 方法/ 采用/ 被/ 广泛应用/ 于/ 评价/ 软件/ 错误/ 定位/ 方法/ 有效性/ 的/ SiemensSuite/ [/ 13/ ]/ 和/ UNIX/ 程序/ 集/ flex/ (/ 下载/ 于/ http/ :/ // // sir/ ./ unl/ ./ edu/ )/ 作为/ 测试数据/ ./ Siemens/ 测试/ 集/ 全部/ 采用/ C语言/ 编写/ ,/ 程序/ 规模较/ 小/ ,/ 并且/ 由/ 人工/ 注入/ 错误/ ,/ 每个/ 程序/ 都/ 包含/ 了/ 数千个/ 测试用例/ ./ flex/ 是/ UNIX/ 系统/ 下/ 的/ 一个/ 真实/ 的/ C语言/ 程序/ ,/ 其/ 规模/ 较大/ ,/ 而且/ 其中/ 包含/ 的/ 错误/ 都/ 是/ 生产/ 过程/ 中/ 真实/ 产生/ 的/ ,/ 但/ 测试用例/ 数量/ 较少/ ./ 表/ 2/ 描述/ 了/ Siemens/ 测试/ 集/ 和/ flex/ 的/ 程序/ 信息/ ,/ 包括/ 程序/ 名称/ 、/ 错误/ 版本/ 数/ 、/ 代码/ 行/ 数/ 、/ 测试用例/ 数/ 及其/ 描述/ ./ 程序/ print/ _/ tokensprint/ _/ tokens210replacescheduleschedule2tcastot/ _/ infoflex/ 表中/ 列出/ 了/ 132/ 个/ Siemens/ 错误/ 版本/ ,/ 但/ 由于/ 其中/ 一些/ 版本/ 没有/ 错误/ 测试用例/ ,/ 或者/ 错误/ 位于/ 头文件/ 中/ ,/ 或者/ 运行/ 时/ 产生/ 了/ 段/ 错误/ ,/ 因此/ 只/ 采用/ 了/ 其中/ 的/ 121/ 个/ 错误/ 版本/ ./ 再/ 加上/ flex/ 程序/ 的/ 23/ 个/ 错误/ 版本/ ,/ 本文/ 实验/ 最终/ 使用/ 144/ 个/ 错误/ 版本/ 进行/ 实验/ ./ 实验/ 的/ 运行/ 环境/ 是/ CPUInter/ ?/ Pentium/ ?/ Dua4/ -/ Core3/ ./ 2GHz/ ;/ 内存/ 2GB/ ./ 5.2/ 评价/ 指标/ 实验/ 选择/ 与/ Tarantula/ [/ 3/ ]/ 方法/ 和/ LEAP/ [/ 11/ ]/ 方法/ 进行/ 比较/ ./ Tarantula/ 是/ 一种/ 实现/ 比较简单/ 的/ 基于/ 覆盖/ 的/ 错误/ 定位/ 方法/ ,/ 它/ 的/ 错误/ 定位/ 效果/ 较/ 好/ ,/ 常/ 被/ 用来/ 作为/ 错误/ 定位/ 方法/ 的/ 比较/ 对象/ ./ LEAP/ 则/ 是/ 一种/ 基于/ 图/ 挖掘/ 的/ 错误/ 定位/ 方法/ ./ 由于/ Tarantula/ 方法/ 会/ 产生/ 语句/ 的/ 可疑/ 值/ 列表/ ,/ 因此/ 采用/ 文献/ [/ 3/ ]/ 使用/ 的/ 错误/ 定位/ 方法/ 精度/ 评价/ 指标/ Score/ ./ 如果/ 开发者/ 从/ 可疑/ 值/ 最高/ 的/ 语句/ 开始/ ,/ 按照/ 可疑/ 值/ 降序/ 的/ 顺序/ 检查/ ,/ 直到/ 找到/ 了/ 错误/ 所在/ 的/ 语句/ 为止/ ,/ 那么/ Score/ 就/ 表示/ 了/ 在/ 找到/ 错误/ 之前/ 需要/ 检查/ 的/ 代码/ 百分比/ ./ 它/ 的/ 计算方法/ 如式/ (/ 11/ )/ 所示/ ./ 其中/ ,/ N/ 表示/ 在/ 找到/ 错误/ 之前/ 需要/ 检查/ 的/ 语句/ 行/ 数/ ,/ Lines/ 表示/ 可/ 执行/ 语句/ 的/ 行数/ ./ 由于/ 本文/ 方法/ 和/ LEAP/ 方法/ 产生/ 的/ 是/ Top/ -/ K/ 错误/ 签名/ ,/ 因此/ 按照/ 前/ K/ 个/ 可疑/ 值/ 降序/ 的/ 顺序/ 检查/ 每个/ 错误/ 签名/ ,/ 将/ 找到/ 错误/ 语句/ 前/ 需要/ 检查/ 的/ 语句/ 百分比/ 作为/ Score/ ./ 代码/ 检查/ 率/ 的/ 计算/ 类似/ 于/ Score/ ,/ 是/ 按照/ 定位/ 结果/ 可疑/ 度/ 排序/ 从/ 高到/ 低/ 检查/ 的/ 代码/ 行数/ 占/ 程序/ 中/ 可/ 执行/ 语句/ 行数/ 的/ 百分比/ ./ 两者/ 的/ 区别/ 是/ :/ 在/ 计算/ 代码/ 检查/ 率时/ 可能/ 定位/ 到/ 也/ 可能/ 没有/ 定位/ 到/ 缺陷/ 语句/ ,/ 而/ Score/ 是/ 在/ 定位/ 到/ 缺陷/ 语句/ 的/ 情况/ 下/ 计算/ 的/ ./ 5.3/ 实验/ 结果/ 总体/ 分析/ 图/ 8/ 展示/ 了/ Siemens/ 测试/ 集上/ ,/ 本文/ 方法/ 与/ Tarantula/ 方法/ 和/ LEAP/ 方法/ 的/ 总体/ 错误/ 定位精度/ 折线图/ ,/ 横轴/ 表示/ 需要/ 检查/ 的/ 语句/ 百分比/ ,/ 纵轴/ 表示/ 检查/ 相应/ 百分比/ 的/ 语句/ 时/ ,/ 能够/ 找到/ 错误/ 的/ 错误/ 版本/ 百分比/ ./ 横轴/ 是从/ 1/ %/ 开始/ 的/ ,/ 表示/ 只/ 检查/ 1/ %/ 的/ 语句/ ,/ 可以/ 找到/ 错误/ 的/ 错误/ 版本/ 百分比/ ./ 可以/ 看到/ ,/ 在/ 检查/ 相同/ 百分比/ 的/ 语句/ 时/ ,/ 本文/ 方法/ 总是/ 可以/ 比/ Tarantula/ 方法/ 和/ LEAP/ 方法/ 定位/ 到/ 更/ 多/ 的/ 错误/ ,/ 而且/ 至多/ 只/ 需要/ 检查/ 65/ %/ 的/ 代码/ ,/ 本文/ 方法/ 就/ 可以/ 定位/ 到/ 所有/ 的/ 错误/ ./ 图/ 9/ 是/ Siemens/ 测试/ 集中/ 单个/ 程序/ 的/ 错误/ 定位/ 结果/ ./ 可以/ 很/ 明显/ 的/ 看到/ ,/ 对于/ 不同/ 的/ 程序/ ,/ 错误/ 定位/ 的/ 精度/ 有/ 较大/ 的/ 差异/ ./ Page10/ 图/ 9/ 单个/ 程序/ 的/ 错误/ 定位精度/ 比较/ 对于/ print/ _/ tokens/ 、/ print/ _/ tokens2/ 和/ replace/ 程序/ ,/ 所有/ 错误/ 定位/ 方法/ 的/ 效果/ 都/ 较/ 好/ ,/ 而/ 本文/ 方法/ 效果/ 最好/ ;/ 对于/ schedule/ 程序/ ,/ 错误/ 定位/ 效果/ 也/ 比较/ 好/ ,/ 但是/ LEAP/ 方法/ 表现/ 较差/ ;/ 对于/ schedule2/ 和/ tot/ _/ info/ 程序/ ,/ 仍然/ 是/ 本文/ 方法/ 的/ 错误/ 定位精度/ 最高/ ,/ 但/ 明显/ 无法/ 与/ 前/ 4/ 个/ 程序/ 的/ 错误/ 定位精度/ 相比/ ;/ Page11/ 而/ 对于/ tcas/ 程序/ ,/ 则/ 是/ Tarantula/ 方法/ 的/ 错误/ 定位/ 的/ 精度/ 要/ 更/ 高些/ ,/ 本文/ 方法/ 的/ 错误/ 定位精度/ 略高于/ LEAP/ 方法/ ./ 图/ 10/ 则/ 是/ flex/ 程序/ 的/ 错误/ 定位精度/ 比较/ ,/ 可以/ 看到/ 3/ 种/ 方法/ 的/ 错误/ 定位精度/ 都/ 较/ 高/ ,/ 而且/ 仍然/ 是/ 本文/ 方法/ 效果/ 最好/ ,/ 其次/ 是/ LEAP/ 方法/ ,/ 最后/ 是/ Tarantula/ 方法/ ./ 为了/ 找到/ 不同/ 程序/ 上/ 的/ 错误/ 定位精度/ 差异/ 较大/ 的/ 原因/ ,/ 我们/ 在/ 下面/ 的/ 实验/ 中/ 进一步/ 按照/ 不同/ 的/ 错误/ 类型/ 分别/ 对/ 错误/ 定位/ 结果/ 进行/ 分析/ ./ 5.4/ 针对/ 不同/ 错误/ 的/ 结果/ 分析/ 实验/ 使用/ 的/ 144/ 个/ 错误/ 版本/ ,/ 按照/ 错误/ 类型/ 进行/ 分类/ ,/ 总计/ 包含/ 14/ 个/ 冗余/ 代码/ 错误/ (/ 添加/ 了/ 多余/ 的/ 代码/ )/ ,/ 32/ 个/ 缺失/ 代码/ 错误/ (/ 删除/ 了/ 部分/ 代码/ )/ ,/ 34/ 个/ 运算符/ 变异/ 错误/ (/ 运算符/ 发生/ 了/ 改变/ )/ ,/ 46/ 个/ 常量/ 变异/ 错误/ (/ 常量/ 值/ 发生/ 了/ 变化/ )/ ,/ 11/ 个/ 变量/ 替换/ (/ 使用/ 的/ 变量/ 发生/ 了/ 改变/ )/ 和/ 7/ 个/ 其他/ 错误/ ./ 采用/ 箱式/ 图/ 显示/ 每种/ 错误/ 类型/ 的/ 错误/ 定位/ 结果/ ./ 箱式/ 图/ 描述/ 了/ 数据/ 的/ 统计/ 结果/ ,/ 它/ 由/ 数据/ 样本/ 的/ 五个/ 重要/ 数据/ 统计/ 点/ 组成/ :/ 最大值/ ,/ 最小值/ ,/ 四分之一/ 位数/ ,/ 四分之三/ 位数/ 和/ 中位数/ ./ 这里/ 以/ Tarantula/ 方法/ 作为/ 比较/ 的/ 基准/ ,/ 将/ Tarantula/ 方法/ 与/ 本文/ 方法/ 的/ Score/ 之差/ 作为/ 纵轴/ ,/ 记为/ ScoreChange/ ,/ 如式/ (/ 12/ )/ 所示/ ./ ScoreChange/ =/ ScoreTarantula/ -/ Score/ 本文/ 方法/ (/ 12/ )/ 若/ ScoreChange/ 大于/ 零/ ,/ 表示/ 本文/ 方法/ 检查/ 更少/ 的/ 代码/ 就/ 能/ 定位/ 到/ 错误/ ,/ 定位精度/ 优于/ Tarantula/ 方法/ ;/ 若/ ScoreChange/ 小于/ 零/ ,/ 则/ 表示/ 本文/ 方法/ 需要/ 检查/ 更/ 多/ 的/ 语句/ 才能/ 定位/ 到/ 错误/ ,/ 定位精度/ 比/ Tarantula/ 方法/ 要/ 差/ ./ 从图/ 11/ 可以/ 看到/ ,/ 对于/ 冗余/ 代码/ 、/ 缺失/ 代码/ 和/ 变量/ 替换/ 错误/ ,/ 本文/ 方法/ 大多/ 都/ 只/ 需要/ 检查/ 更少/ 的/ 语句/ ,/ 就/ 能够/ 定位/ 到/ 错误/ ,/ 而/ 少部分/ 精度/ 变差/ 的/ ,/ 也/ 小于/ 9/ %/ ./ 而/ 对于/ 运算符/ 变异/ 、/ 常量/ 变异/ 和/ 其他/ 错误/ ,/ 本文/ 方法/ 则/ 有/ 优有劣/ ,/ 约/ 有/ 47/ %/ 的/ 错误/ 定位精度/ 变差/ 了/ ,/ 但/ 变差/ 幅度/ 大于/ 10/ %/ 的/ 只/ 占/ 9/ %/ ./ 再/ 考虑/ 另/ 一种/ 错误/ 分类/ 方式/ ./ 部分/ 错误/ 可能/ 会/ 直接/ 导致/ 程序/ 的/ 执行/ 路径/ 发生/ 改变/ ,/ 例如/ if/ 语句/ 中/ 的/ 条件/ 发生/ 了/ 错误/ ,/ 会/ 直接/ 令/ 程序执行/ 路径/ 发生变化/ ./ 而/ 另/ 一些/ 错误/ 则/ 不会/ 直接/ 导致/ 程序执行/ 路径/ 发生/ 改变/ ,/ 例如/ 变量/ 赋值/ 中/ 发生/ 了/ 错误/ ,/ 程序执行/ 路径/ 并未/ 立刻/ 发生变化/ ,/ 只有/ 之后/ 再/ 用到/ 该/ 变量/ 时/ ,/ 程序执行/ 路径/ 才/ 可能/ 发生变化/ ./ 按照/ 这一/ 方式/ 来/ 分类/ ,/ 实验/ 使用/ 的/ 144/ 个/ 错误/ 版本/ ,/ 包含/ 59/ 个会/ 直接/ 导致/ 程序执行/ 路径/ 发生/ 改变/ 的/ 错误/ ,/ 85/ 个/ 不会/ 直接/ 导致/ 程序执行/ 路径/ 改变/ 的/ 错误/ ,/ 同样/ 使用/ 箱式/ 图/ 显示/ 两类/ 错误/ 的/ 定位/ 结果/ ,/ 如图/ 12/ 所示/ ./ 可以/ 发现/ ,/ 对于/ 会/ 直接/ 改变/ 程序执行/ 路径/ 的/ 错误/ ,/ 本文/ 方法/ 基本/ 都/ 是/ 优于/ Tarantula/ 方法/ 的/ ,/ 而/ 对于/ 不会/ 直接/ 导致/ 程序执行/ 路径/ 发生变化/ 的/ 错误/ ,/ 本文/ 方法/ 同样/ 是/ 有/ 优有劣/ ,/ 约/ 有/ 47/ %/ 的/ 错误/ 定位精度/ 变差/ 了/ ,/ 而/ 变差/ 幅度/ 大于/ 10/ %/ 的/ 约/ 占/ 7/ %/ ./ 图/ 12/ 是否/ 直接/ 改变/ 执行/ 路径/ 的/ 错误/ 的/ ScoreChange/ 分布/ 综合/ 分析/ 以上/ 两个/ 实验/ ,/ 可以/ 发现/ 本文/ 方法/ 对/ 不同/ 的/ 错误/ 类型/ ,/ 定位精度/ 有/ 比较/ 明显/ 的/ 不同/ :/ 对于/ 冗余/ 代码/ 、/ 缺失/ 代码/ 和/ 变量/ 替换/ 错误/ ,/ 以及/ 会/ 直接/ 改变/ 执行/ 路径/ 的/ 错误/ 的/ 定位精度/ 明显/ 更高/ ./ 如果/ 将/ 这/ Page12/ 些/ 错误/ 类型/ 记/ 为/ 优势/ 错误/ ,/ 将/ 剩余/ 的/ 错误/ 类型/ (/ 不会/ 直接/ 改变/ 执行/ 路径/ 的/ 运算符/ 变异/ 、/ 常量/ 变异/ 和/ 其他/ 错误/ )/ 记/ 为/ 劣势/ 错误/ ,/ 那么/ 优势/ 错误/ 有/ 92/ 个/ ,/ 劣势/ 错误/ 有/ 52/ 个/ ,/ 优势/ 错误/ 和/ 劣势/ 错误/ 的/ ScoreChange/ 对比/ 结果/ 如图/ 13/ 所示/ ./ 可以/ 看到/ ,/ 对于/ 优势/ 错误/ ,/ 本文/ 方法/ 的/ 定位精度/ 大多/ 都/ 优于/ Tarantula/ 方法/ ,/ 而/ 对于/ 劣势/ 错误/ ,/ 本文/ 的/ 定位精度/ 则/ 普遍/ 要略/ 差于/ Tarantula/ 方法/ ./ 图/ 14/ 所示/ 的/ 优势/ 错误/ 和/ 劣势/ 错误/ 的/ 错误/ 定位精度/ 比较/ 也/ 证明/ 了/ 这/ 一点/ ,/ 而且/ LEAP/ 图/ 13/ 优势/ 错误/ 和/ 劣势/ 错误/ 的/ ScoreChange/ 分布图/ 14/ 优势/ 错误/ 和/ 劣势/ 错误/ 的/ 错误/ 定位精度/ 比较/ 方法/ 也/ 具有/ 相同/ 趋势/ ,/ 并且/ 无论是/ 对/ 优势/ 错误/ 还是/ 劣势/ 错误/ ,/ 本文/ 方法/ 都/ 比/ LEAP/ 方法/ 的/ 错误/ 定位精度/ 高/ ./ 5.5/ 性能/ 分析/ 表/ 3/ 给出/ 了/ 3/ 种/ 方法/ 定位/ 分析/ 每个/ 错误/ 版本/ 的/ 平均/ 时间/ ./ Tarantula/ 是/ 基于/ 语句/ 覆盖/ 的/ 分析/ 因此/ 具有/ 较/ 高/ 的/ 时间/ 效率/ ,/ 本文/ 方法/ 和/ LEAP/ 方法/ 均/ 涉及/ 到/ 图/ 的/ 分析/ ,/ 两者/ 时间/ 开销/ 相近/ ./ 程序/ print/ _/ tokensprint/ _/ tokens2replacescheduleschedule2tcastot/ _/ infoflex6/ 讨论/ 6.1/ 本文/ 方法/ 的/ 不足/ 根据/ 本文/ 方法/ 与/ Tarantula/ 方法/ 对比/ 实验/ 的/ 结果/ ,/ 可以/ 得到/ 以下/ 结论/ :/ 本文/ 的/ 错误/ 定位/ 方法/ 对/ 冗余/ 代码/ 、/ 缺失/ 代码/ 和/ 变量/ 替换/ 错误/ ,/ 以及/ 会/ 直接/ 改变/ 执行/ 路径/ 的/ 错误/ 的/ 定位精度/ 明显提高/ ,/ 而/ 对/ 不会/ 直接/ 改变/ 执行/ 路径/ 的/ 运算符/ 变异/ 、/ 常量/ 变异/ 错误/ 的/ 定位精度/ 的/ 提高/ 则/ 不/ 明显/ ./ 分析/ 产生/ 这种/ 情况/ 的/ 原因/ ,/ 是/ 由于/ 本文/ 方法/ 会/ 在/ 成功/ 的/ 执行/ 和/ 失败/ 的/ 执行/ 之间/ 找到/ 加权/ 软件/ 行为/ 图/ 差异/ 最大/ 的/ 子/ 图/ ,/ 即当/ 程序/ 的/ 执行/ 路径/ 出现/ 明显/ 差异/ 时/ ,/ 本文/ 方法/ 比较/ 有效/ ./ 反之/ ,/ 因/ 本文/ 方法/ 的/ 特点/ 不能/ 被/ 有效/ 利用/ ,/ 而/ 使得/ 其/ 错误/ 定位/ 的/ 优势/ 不/ 明显/ ./ 文献/ [/ 15/ ]/ 的/ 研究/ 表明/ ,/ 一条/ 语句/ 的/ 错误/ 可能/ 会/ 影响/ 到/ 程序/ 状态/ ,/ 而/ 随着/ 程序/ 的/ 继续执行/ ,/ 被/ 影响/ 的/ 程序/ 状态/ 可能/ 会/ 被/ 进一步/ 传播/ ./ 也就是说/ ,/ 程序/ 的/ 执行/ 路径/ 发生变化/ 的/ 位置/ ,/ 并不一定/ 是/ 真正/ 导致/ 错误/ 的/ 语句/ ,/ 而/ 可能/ 是/ 其他/ 语句/ 的/ 错误/ ,/ 通过/ 程序/ 状态/ 不断/ 传播/ ,/ 直到/ 导致/ 程序/ 的/ 执行/ 路径/ 发生/ 改变/ ./ 也就是说/ ,/ 本文/ 方法/ 对于/ 在/ 错误/ 语句/ 附近/ 就/ 能够/ 观察/ 到/ 程序执行/ 路径/ 发生/ 改变/ 的/ 错误/ ,/ 一般/ 都/ 能/ 具有/ 比较/ 好/ 的/ 定位精度/ ./ 而/ 对于/ 会/ 将/ 错误/ 传播/ 出去/ 很远/ 才/ 发生/ 执行/ 路径/ 变化/ 的/ 错误/ ,/ 往往/ 只能/ 定位/ 到/ 执行/ 路径/ 发生变化/ 的/ 位置/ ,/ 虽然/ 该/ 位置/ 与/ 实际/ 的/ 错/ Page13/ 误/ 语句/ 也/ 具有/ 一定/ 的/ 相关性/ ,/ 但/ 因/ 其/ 并/ 不是/ 真正/ 产生/ 错误/ 的/ 语句/ ,/ 从而/ 导致/ 错误/ 定位/ 的/ 精度/ 下降/ ./ 6.2/ 可/ 改进/ 之/ 处/ 针对/ 5.1/ 节中/ 本文/ 方法/ 的/ 适应性/ 问题/ ,/ 可以/ 尝试/ 捕获/ 更/ 多/ 的/ 程序/ 状态/ ,/ 如/ 谓词/ 的/ 真假/ 等/ 信息/ ,/ 而/ 不仅仅/ 是/ 程序/ 的/ 执行/ 路径/ ./ 在/ 进行/ 图/ 挖掘/ 时/ ,/ 可以/ 综合/ 考虑/ 更/ 多/ 的/ 信息/ 或/ 融合/ 其他/ 的/ 错误/ 定位/ 算法/ ,/ 来/ 提高/ 对/ 劣势/ 错误/ 的/ 定位精度/ ./ 对于/ 错误/ 传播/ 对/ 错误/ 定位精度/ 的/ 影响/ ,/ 单独/ 的/ 应用/ 图/ 挖掘/ 算法/ 可能/ 难以解决/ 这一/ 问题/ ,/ 因此/ 可以/ 尝试/ 分析程序/ 的/ 控制/ 依赖/ 或/ 数据/ 依赖/ ,/ 并/ 依此/ 对/ 错误/ 的/ 传播/ 进行/ 分析/ ,/ 进而/ 可能/ 减少/ 错误/ 传播/ 带来/ 的/ 影响/ ./ 7/ 讨论/ 本文/ 提出/ 了/ 一种/ 新/ 的/ 基于/ 加权/ 软件/ 行为/ 图/ 挖掘/ 的/ 错误/ 定位/ 方法/ ./ 与/ Tarantula/ 方法/ 和/ LEAP/ 方法/ 相比/ ,/ 本文/ 方法/ 具有/ 更/ 高/ 的/ 错误/ 定位精度/ ,/ 而且/ 更/ 适合/ 于/ 定位/ 冗余/ 代码/ 、/ 缺失/ 代码/ 和/ 变量/ 替换/ 错误/ ,/ 以及/ 会/ 直接/ 改变/ 执行/ 路径/ 的/ 错误/ ./ 本文/ 的/ 主要/ 贡献/ 是/ :/ (/ 1/ )/ 提出/ 了/ 加权/ 软件/ 行为/ 图/ 的/ 概念/ 和/ 构造方法/ ,/ 并/ 将/ 其/ 用于/ 错误/ 定位/ ./ 与/ 软件/ 行为/ 图/ 相比/ ,/ 加权/ 软件/ 行为/ 图/ 使用/ 语句/ 执行/ 概率/ 作为/ 边/ 的/ 权重/ ,/ 有效/ 地/ 利用/ 了/ 路径/ 执行/ 的/ 统计/ 信息/ ,/ 因此/ 可以/ 更好/ 地/ 分析/ 与/ 循环/ 和/ 递归/ 等/ 结构/ 相关/ 的/ 软件/ 错误/ ./ (/ 2/ )/ 提出/ 一种/ 基于/ 分支/ 限界/ 搜索/ 的/ 加权/ 软件/ 行为/ 图/ 挖掘/ 算法/ ,/ 识别/ 成功/ 和/ 失败/ 执行/ 之间/ 最有/ 差异/ 的/ 子/ 图来/ 获得/ 错误/ 签名/ ,/ 不但/ 可以/ 有效/ 定位/ 错误/ 位置/ ,/ 还/ 能/ 输出/ 缺陷/ 语句/ 相关/ 的/ 执行/ 路径/ ,/ 从而/ 提供/ 失效/ 产生/ 的/ 上下文/ ,/ 有助于/ 错误/ 理解/ ./ (/ 3/ )/ 从/ 理论/ 和/ 实验/ 两个/ 方面/ 分析/ 了/ 基于/ 加权/ 软件/ 行为/ 图/ 挖掘/ 的/ 错误/ 定位/ 方法/ 的/ 适应性/ ,/ 通过/ 对/ 错误/ 进行/ 分类/ ,/ 讨论/ 了/ 本文/ 方法/ 对/ 不同/ 错误/ 类型/ 的/ 错误/ 定位精度/ 的/ 影响/ ./ 

