Page1/ 一种/ 目标/ 制导/ 的/ 混合/ 执行/ 测试方法/ 崔展/ 齐/ 王林章/ 李宣东/ (/ 南京大学/ 软件/ 新/ 技术/ 国家/ 重点/ 实验室/ 南京/ 210093/ )/ (/ 南京大学/ 计算机科学/ 与/ 技术/ 系/ 南京/ 210093/ )/ 摘要/ 混合/ 执行/ 测试/ (/ concolictesting/ )/ 是/ 一种/ 将/ 具体/ 执行/ 与/ 符号执行/ 相结合/ 的/ 自动化/ 测试方法/ ./ 由于/ 混合/ 执行/ 测试/ 从/ 程序/ 本身/ 出发/ ,/ 未/ 将/ 目标/ 缺陷/ 的/ 先验/ 知识/ 作为/ 指导/ ,/ 会/ 导致/ 生成/ 和/ 执行/ 大量/ 不能/ 发现/ 缺陷/ 的/ 测试/ 输入/ ,/ 从/ 发现/ 缺陷/ 的/ 角度看/ 浪费/ 了/ 时间/ 和/ 计算资源/ 开销/ ./ 这个/ 问题/ 在/ 具有/ 时间/ 、/ 成本/ 及/ 资源/ 约束/ 的/ 实际/ 测试/ 任务/ 中/ 更加/ 突出/ ./ 为/ 解决/ 这一/ 问题/ ,/ 文中/ 提出/ 了/ 一种/ 结合/ 静态/ 分析/ 和/ 混合/ 执行/ 测试/ 技术/ 的/ 目标/ 制导/ 的/ 混合/ 执行/ 测试方法/ :/ 使用/ 静态/ 分析/ 工具/ 分析/ 待测/ 程序/ 中/ 可能/ 含有/ 缺陷/ 的/ 可疑/ 语句/ 及其/ 缺陷/ 类型/ ,/ 并/ 将/ 静态/ 分析/ 所/ 报告/ 的/ 可疑/ 语句/ 作为/ 目标/ 指导/ 测试/ ./ 目标/ 制导/ 的/ 混合/ 执行/ 测试/ 技术/ 分为/ 3/ 个/ 步骤/ :/ 首先/ ,/ 计算/ 从/ 程序/ 各/ 分支/ 到/ 待/ 检测/ 缺陷/ 语句/ 的/ 可达性/ ;/ 其次/ ,/ 对待/ 测试程序/ 进行/ 插装以/ 支持/ 混合/ 执行/ 测试/ ;/ 第三/ ,/ 使用/ 静态/ 分析/ 的/ 结果/ 和/ 可达性/ 信息/ 作为/ 指导/ ,/ 只/ 生成/ 和/ 执行/ 可能/ 会/ 覆盖/ 待/ 检测/ 缺陷/ 语句/ 的/ 测试/ 输入/ ,/ 以/ 避免/ 生成/ 和/ 执行/ 不能/ 发现/ 缺陷/ 的/ 测试/ 输入/ ./ 基于/ 此/ 方法/ ,/ 作者/ 实现/ 了/ 一个/ 测试/ 缓冲区/ 溢出/ 缺陷/ 的/ 原型/ 工具/ :/ TARGET/ ,/ 并/ 在/ 一组/ C语言/ 基准/ 程序/ 上/ 进行/ 了/ 对比/ 实验/ ./ 实验/ 结果表明/ 与/ 原有/ 的/ 混合/ 执行/ 测试/ 技术/ 相/ 比较/ ,/ TARGET/ 能/ 在/ 更/ 短/ 的/ 时间/ 内/ 发现/ 程序/ 中/ 更/ 多/ 的/ 缺陷/ ./ 关键词/ 目标/ 制导/ 测试/ ;/ 缺陷/ 触发/ ;/ 静态/ 分析/ ;/ 混合/ 执行/ 测试/ 1/ 引言/ 为/ 提高/ 软件/ 质量/ ,/ 软件测试/ 和/ 静态/ 分析/ 是/ 两类/ 使用/ 最为/ 广泛/ 的/ 缺陷/ 检测/ 技术/ [/ 1/ -/ 2/ ]/ ./ 其中/ ,/ 软件测试/ 是/ 目前/ 工业界/ 使用/ 最多/ 的/ 软件/ 质量/ 保障/ 手段/ ,/ 而/ 静态/ 分析/ 近年来/ 开始/ 逐渐/ 得到/ 工业界/ 的/ 重视/ 和/ 应用/ ./ 静态/ 分析/ 技术/ 能/ 在/ 软件/ 生命周期/ 的/ 较/ 早/ 阶段/ 发现/ 程序/ 缺陷/ [/ 3/ -/ 4/ ]/ ./ 此外/ ,/ 静态/ 分析/ 能/ 在/ 很大/ 程度/ 上/ 实现/ 自动化/ ,/ 具有/ 人力/ 成本/ 开销/ 较/ 小/ 的/ 优势/ ./ 软件测试/ 技术/ 通过/ 测试用例/ 来/ 触发/ 和/ 确认/ 程序/ 缺陷/ ,/ 能/ 发现/ 程序/ 中/ 的/ 真实/ 缺陷/ [/ 5/ ]/ ./ 同时/ ,/ 具体/ 的/ 测试用例/ 还/ 能够/ 为/ 软件/ 工程师/ 调试/ 和/ 排错/ 提供/ 有效/ 帮助/ ./ 但是/ ,/ 软件测试/ 工具/ 通常/ 需要/ 一个/ 较为/ 充分/ 的/ 测试用例/ 集/ ,/ 这/ 在/ 大多数/ 情况/ 下/ 是/ 难以/ 获取/ 的/ ./ 混合/ 执行/ 测试/ [/ 6/ -/ 7/ ]/ 是/ 一种/ 有效/ 的/ 提高/ 测试/ 自动化/ 程度/ 的/ 技术/ ,/ 其/ 目标/ 是/ 通过/ 自动/ 生成/ 测试/ 输入/ 来/ 执行程序/ 中/ 的/ 所有/ 可行/ 路径/ ,/ 从而/ 发现/ 程序/ 缺陷/ ./ 混合/ 执行/ 测试/ 技术/ 在/ 待/ 测试程序/ 上/ 执行/ 具体/ 输入/ 的/ 同时/ 进行/ 符号执行/ ./ 首先/ 通过/ 插装/ 的/ 方式/ 在/ 程序执行/ 过程/ 中/ 收集/ 路径/ 条件/ 的/ 符号/ 表达式/ ,/ 然后/ 通过/ 约束/ 求解/ 器/ 求解/ 所/ 收集/ 到/ 的/ 路径/ 条件/ ,/ 以/ 生成/ 执行/ 新/ 路径/ 的/ 测试/ 输入/ ./ 当/ 不能/ 求解/ 所/ 收集/ 到/ 的/ 路径/ 条件/ 时/ ,/ 混合/ 执行/ 测试/ 使用/ 具体/ 的/ 值来/ 简化/ 符号/ 表达式/ ./ 混合/ 执行/ 测试/ 在/ 一定/ 程度/ 上/ 解决/ 了/ 缺乏/ 测试用例/ 集/ 的/ 问题/ ,/ 但/ 由于/ 该/ 方法/ 从/ 程序/ 本身/ 出发/ ,/ 未/ 将/ 目标/ 缺陷/ 的/ 先验/ 知识/ 作为/ 指导/ ,/ 导致/ 生成/ 和/ 执行/ 了/ 大量/ 不能/ 覆盖/ 缺陷/ 语句/ 的/ 测试/ 输入/ ,/ 从/ 发现/ 缺陷/ 的/ 角度看/ ,/ 浪费/ 了/ 时间/ 和/ 计算资源/ 开销/ ./ 由于/ 只有/ 能/ 覆盖/ 缺陷/ 所在/ 语句/ 的/ 测试/ 输入/ 才/ 有/ 可能/ 触发/ 缺陷/ ,/ 不能/ 覆盖/ 缺陷/ 语句/ 的/ 测试/ 输入/ 对/ 发现/ 缺陷/ 是/ 毫无/ 贡献/ 的/ ./ 如能/ 获取/ 程序/ 中/ 潜在/ 缺陷/ 的/ 类型/ 和/ 位置/ ,/ 就/ 能/ 在/ 不/ 损害/ 缺陷/ 发现/ 能力/ 的/ 前提/ 下/ ,/ 通过/ 避免/ 生成/ 和/ 执行/ 不能/ 覆盖/ 缺陷/ 语句/ 的/ 测试/ 输入/ 来/ 降低/ 测试/ 开销/ ./ 而/ 一些/ 静态/ 分析/ 工具/ ,/ 则/ 能/ 报告/ 程序/ 中/ 潜在/ 缺陷/ 语句/ 的/ 位置/ 和/ 缺陷/ 类型信息/ ,/ 但/ 由于/ 静态/ 分析/ 在/ 分析/ 过程/ 中/ 使用/ 了/ 一些/ 保守/ 的/ 假设/ ,/ 因而/ 具有/ 较/ 高/ 的/ 误报率/ ./ 从/ 含有/ 大量/ 误报/ 的/ 缺陷/ 警报/ 中/ 识别/ 出/ 真正/ 的/ 缺陷/ 仍/ 需要/ 大量/ 的/ 人力/ 和/ 时间/ 开销/ ./ 软件测试/ 和/ 静态/ 分析/ 在/ 很大/ 程度/ 上/ 具有/ 互补性/ ,/ 如果/ 能/ 有效/ 地/ 利用/ 静态/ 分析/ 的/ 结果/ 来/ 指导/ 软件测试/ ,/ 将/ 带来/ 两/ 方面/ 的/ 好处/ :/ 一方面/ ,/ 静态/ 分析/ 工具/ 所/ 提供/ 的/ 信息/ 能为/ 软件测试/ 提供/ 测试/ 的/ 目标/ ,/ 从而/ 降低/ 软件测试/ 的/ 开销/ ;/ 另一方面/ ,/ 软件测试/ 提供/ 的/ 运行/ 时/ 信息/ 能/ 用于/ 确认/ 和/ 精化/ 静态/ 分析/ 工具/ 所/ 报告/ 的/ 缺陷/ 警报/ ./ 基于/ 上述/ 思路/ ,/ 本文/ 提出/ 了/ 一种/ 静/ 动态/ 结合/ 的/ 目标/ 制导/ 的/ 混合/ 执行/ 测试方法/ :/ 使用/ 静态/ 分析/ 工具/ 分析/ 待测/ 程序/ ,/ 检测/ 程序/ 中/ 可能/ 会/ 含有/ 缺陷/ 的/ 可疑/ 语句/ 及其/ 缺陷/ 类型/ ,/ 并/ 将/ 静态/ 分析/ 所/ 报告/ 的/ 可疑/ 语句/ 作为/ 待/ 检测/ 缺陷/ 语句/ ,/ 指导/ 测试/ 输入/ 的/ 生成/ 和/ 执行/ ./ 目标/ 制导/ 的/ 混合/ 执行/ 测试方法/ 分为/ 3/ 个/ 步骤/ :/ 首先/ ,/ 使用/ 程序控制/ 流程图/ 分别/ 计算/ 从/ 程序/ 各/ 分支/ 语句/ 到/ 待/ 检测/ 缺陷/ 语句/ 的/ 可达性/ ;/ 其次/ ,/ 对待/ 测试程序/ 进行/ 插装以/ 支持/ 混合/ 执行/ 测试/ ;/ 第三/ ,/ 使用/ 静态/ 分析/ 的/ 结果/ 和/ 可达性/ 信息/ 作为/ 指导/ ,/ 只/ 生成/ 和/ 执行/ 可能/ 会/ 覆盖/ 待/ 检测/ 缺陷/ 语句/ 的/ 测试/ 输入/ ,/ 以/ 避免/ 生成/ 不能/ 发现/ 缺陷/ 的/ 测试/ 输入/ ./ 我们/ 在/ 一组/ C语言/ 基准/ 程序/ 上/ 就/ 缓冲区/ 溢出/ 缺陷/ 进行/ 了/ 对比/ 实验/ ./ 实验/ 结果表明/ ,/ 与/ 原有/ 的/ 混合/ 执行/ 测试/ 技术/ 相/ 比较/ ,/ 本/ 方法/ 能/ 在/ 更/ 短/ 的/ 时间/ 内/ 发现/ 更/ 多/ 的/ 程序/ 缺陷/ ./ 本文/ 的/ 主要/ 贡献/ 在于/ :/ (/ 1/ )/ 提出/ 了/ 一种/ 结合/ 静态/ 分析/ 和/ 混合/ 执行/ 测试/ 的/ 缺陷/ 检测/ 方法/ ,/ 使用/ 静态/ 分析/ 报告/ 的/ 潜在/ 缺陷/ 的/ 位置/ 和/ 类型信息/ 指导/ 混合/ 执行/ 测试/ ,/ 从而/ 降低/ 测试/ 开销/ ;/ (/ 2/ )/ 基于/ 该/ 方法/ 实现/ 了/ 一个/ 用于/ 检测/ C语言/ 中/ 缓冲区/ 溢出/ 的/ 原型/ 测试工具/ ,/ 并/ 在/ 一组/ C语言/ 基准/ 程序/ 上/ 进行/ 了/ 实例/ 研究/ 以/ 评估/ 本/ 方法/ 的/ 有效性/ ./ 本文/ 第/ 2/ 节/ 给出/ 混合/ 执行/ 测试/ 和/ 静态/ 分析/ 的/ 相关/ 背景/ 知识/ ;/ 第/ 3/ 节/ 通过/ 一个/ 例子/ 来/ 引出/ 使用/ 静态/ 分析/ 结果/ 作为/ 目标/ 指导/ 测试/ 的/ 动因/ ;/ 第/ 4/ 节/ 详细描述/ 目标/ 制导/ 的/ 混合/ 执行/ 测试/ 技术/ ;/ 第/ 5/ 节/ 介绍/ 原型/ 工具/ 的/ 实现/ 并/ 进行/ 实验/ 和/ 评估/ ;/ 第/ 6/ 节/ 介绍/ 相关/ 的/ 工作/ ;/ 第/ 7/ 节/ 总结/ 本文/ 的/ 工作/ 并/ 进行/ 展望/ ./ 2/ 背景/ 介绍/ 2.1/ 混合/ 执行/ 测试/ 混合/ 执行/ 测试/ [/ 6/ -/ 7/ ]/ 是/ 一种/ 将/ 具体/ 执行/ 与/ 符号/ 执/ Page3/ 行/ 相结合/ 的/ 自动化/ 测试方法/ ,/ 其/ 目标/ 是/ 通过/ 生成/ 测试/ 输入/ 来/ 执行程序/ 中/ 的/ 所有/ 可行/ 路径/ ,/ 以/ 发现/ 程序/ 缺陷/ ./ 其中/ ,/ concolic/ 是/ 将/ 具体/ (/ CONCrete/ )/ 和/ 符号/ (/ symbOLIC/ )/ 两个/ 词/ 结合/ 在/ 一起/ 所/ 构成/ 的/ 一个/ 新词/ ./ 具体/ 执行/ 是/ 以/ 具体/ 的/ 输入/ 值/ 执行程序/ ;/ 符号执行/ 使用/ 变量/ 符号/ 代替/ 具体/ 的/ 输入/ 值/ ,/ 模拟/ 执行程序/ ,/ 得到/ 程序/ 各/ 路径/ 条件/ 的/ 符号化/ 表达式/ ,/ 然后/ 对/ 符号/ 表达式/ 进行/ 约束/ 求解/ ,/ 以/ 得到/ 能够/ 执行/ 指定/ 程序/ 路径/ 的/ 具体/ 输入/ 值/ ./ 而/ 混合/ 执行/ 测试/ 则/ 是/ 将/ 具体/ 执行/ 与/ 符号执行/ 相结合/ 的/ 测试/ 技术/ ,/ 其/ 思想/ 是/ 在/ 具体/ 执行/ 过程/ 中/ 收集/ 路径/ 条件/ 的/ 符号/ 表达式/ ,/ 并/ 按照/ 深度/ 优先/ 的/ 策略/ 将/ 路径/ 条件/ 逐一/ 取反/ ,/ 然后/ 通过/ 约束/ 求解/ 的/ 方式/ 求解/ 取反/ 后/ 的/ 路径/ 条件/ ,/ 以/ 获得/ 执行/ 新/ 路径/ 的/ 测试/ 输入/ ./ 当/ 不能/ 求解/ 路径/ 条件/ 时/ ,/ 使用/ 具体/ 的/ 值来/ 代替/ 符号/ 表达式/ ,/ 以/ 简化/ 路径/ 条件/ ./ 在/ 混合/ 执行/ 测试/ 技术/ 的/ 基础/ 上/ ,/ 有/ 一些/ 相关/ 的/ 扩展/ 工作/ ./ Sen/ 等/ 提出/ 的/ CUTE/ [/ 7/ ]/ 将/ 混合/ 执行/ 测试/ 技术/ 扩展/ 到/ 支持/ 含有/ 指针/ 和/ 数组/ 等/ 复杂/ 数据结构/ 的/ 程序/ ,/ JCUTE/ [/ 8/ ]/ 将/ 混合/ 执行/ 测试/ 技术/ 用于/ 自动化/ 测试/ 多线程/ 程序/ 的/ 竞争/ 问题/ ./ 为/ 解决/ 混合/ 执行/ 测试/ 中/ 分支/ 覆盖率/ 较/ 低/ 和/ 可扩展性/ 不强/ 的/ 问题/ ,/ CREST/ [/ 9/ ]/ 提出/ 了/ 几种/ 基于/ 程序/ 静态/ 控制流/ 图/ 的/ 路径/ 搜索/ 策略/ ,/ 尽量/ 生成/ 执行/ 尚未/ 覆盖/ 分支/ 的/ 测试/ 输入/ ./ SPLAT/ [/ 10/ ]/ 则/ 将/ 缓冲区/ 的/ 一段/ 前缀/ 和/ 缓冲区/ 的/ 长度/ 进行/ 符号化/ 建模/ ,/ 用于/ 检测/ 程序/ 中/ 的/ 缓冲区/ 溢出/ 缺陷/ ./ 2.2/ 静态/ 分析/ 静态/ 分析/ 是/ 指/ 在/ 不/ 运行/ 软件/ 的/ 前提/ 下/ 对/ 软件/ 的/ 各种/ 性质/ 进行/ 分析/ 的/ 过程/ ,/ 其/ 对象/ 可以/ 是/ 设计/ 模型/ 、/ 源程序/ 、/ 字节/ 码/ 等/ 软件/ 生命周期/ 中/ 的/ 各种/ 产物/ [/ 2/ ]/ ./ 静态/ 代码/ 分析/ 技术/ 最/ 常见/ 的/ 用途/ 是/ 检查/ 源程序/ 中/ 的/ 缺陷/ ,/ 可以/ 按/ 是否/ 流/ 敏感/ 、/ 是否/ 路径/ 敏感/ 、/ 是否/ 支持/ 过程/ 间/ 分析/ 等/ 维度/ 进行/ 分类/ [/ 4/ ]/ ./ 静态/ 分析/ 技术/ 的/ 优势/ 在于/ 自动化/ 程度/ 高/ 、/ 可扩展性/ 好/ ,/ 能/ 处理/ 规模/ 较大/ 的/ 程序/ ,/ 其/ 缺点/ 在于/ 精度/ 不高/ ,/ 可能/ 会/ 出现/ 误报/ (/ falsepositive/ )/ 和/ 漏报/ (/ falsenegative/ )/ 的/ 情况/ ./ 误报/ 是/ 指/ 分析/ 工具/ 所/ 报告/ 的/ 缺陷/ 实际上/ 并/ 不/ 存在/ ,/ 而/ 漏报/ 则/ 是/ 指/ 分析/ 工具/ 未能/ 检测/ 出/ 程序/ 中/ 存在/ 的/ 某些/ 缺陷/ ./ 另外/ ,/ 如何/ 从/ 静态/ 分析/ 的/ 结果/ 中/ 识别/ 出/ 真实/ 的/ 缺陷/ ,/ 并/ 设计/ 测试用例/ 以/ 确认/ 该/ 缺陷/ 仍然/ 具有/ 很大/ 的/ 挑战性/ ./ Splint/ [/ 11/ ]/ 、/ ARCHER/ [/ 12/ ]/ 、/ BOON/ [/ 13/ ]/ 等/ 静态/ 分析/ 工具/ 能够/ 报告/ 程序/ 中/ 缺陷/ 语句/ 或/ 变量/ 的/ 位置/ ./ Prefix/ [/ 14/ ]/ 、/ PREfast/ ①/ 、/ Marple/ [/ 15/ ]/ 等/ 静态/ 分析/ 工具/ 对/ 识别/ 出/ 的/ 缺陷/ 还/ 提供/ 了/ 相应/ 的/ 路径/ 信息/ ./ 3/ 示例/ 图/ 1/ 是/ 将/ WuFTP/ -/ 1/ [/ 16/ ]/ 中/ 的/ 一个/ 缺陷/ 进行/ 简化/ 后/ 的/ 示例/ 程序/ ,/ 其中/ path/ 是/ 一个/ 输入/ 字符串/ ,/ Example/ 函数/ 的/ 功能/ 是/ 将/ path/ 中/ 字符串/ 拷贝到/ 数组/ mapped/ _/ path/ 中/ ,/ 若/ path/ 的/ 第/ 1/ 位不为/ ‘/ // ’/ ,/ 则/ 需要/ 在/ 前面/ 加上/ ‘/ // ’/ 后/ 再/ 进行/ 拷贝/ ./ 如该/ 程序/ 的/ 控制/ 流程图/ 所示/ ,/ 该/ 程序/ 共/ 包含/ 4/ 条/ 路径/ ,/ 第/ 8/ 、/ 9/ 行/ 修改/ 了/ mapped/ _/ path/ 中/ 的/ 内容/ ,/ 是/ 可能/ 引发/ 缓冲区/ 溢出/ 错误/ 的/ 语句/ ,/ 其中/ 当/ path/ 的/ 第一位/ 不/ 为/ ‘/ // ’/ 且/ 长度/ 为/ 9/ 时/ ,/ 将会/ 在/ 第/ 9/ 行/ 触发/ 缓冲区/ 溢出/ 错误/ ./ 使用/ 支持/ 缓冲区/ 建模/ 的/ 混合/ 执行/ 测试工具/ ,/ 如/ SPLAT/ [/ 10/ ]/ ,/ 将会/ 尝试/ 覆盖/ 程序/ 中/ 的/ 所有/ 路径/ ,/ 并/ 在/ 每次/ 修改/ 缓冲区/ 时/ 检查/ 是否/ 可能/ 溢出/ ./ 第一/ ,/ 将空/ 字符串/ 作为/ path/ 的/ 默认/ 输入/ 并/ 运行/ 程序/ ,/ 覆盖/ 语句/ 2/ ,/ 3/ (/ T/ )/ ,/ 4/ (/ T/ ,/ F/ 分别/ 表示/ 条件/ 判断/ 语句/ 的/ true/ 和/ false/ 分支/ )/ ;/ 第二/ ,/ 转置/ 3/ (/ T/ )/ 所/ 对应/ 的/ 路径/ 条件/ 以/ 生成/ 非空/ 字符串/ 作为/ 下/ 一次/ 程序运行/ 的/ 输入/ ,/ 假设/ 为/ “/ a/ ”/ ,/ 该/ 测试/ 输入/ 将/ 覆盖/ 语句/ 2/ ,/ 3/ (/ F/ )/ ,/ 5/ (/ F/ )/ ,/ 7/ (/ T/ )/ ,/ 8/ ,/ 9/ ,/ 并/ 分别/ 在/ 第/ 8/ 、/ 9/ 行/ 检查/ 缓冲区/ 是否/ 可能/ 会/ 溢出/ ,/ 结果/ 为/ 第/ 8/ 行在/ 当前/ 路径/ 条件/ 下/ 不能/ 溢出/ ,/ 第/ 9/ 行/ 可能/ 会/ 溢出/ ,/ 生成/ 长度/ 为/ 9/ 且/ 第/ 1/ 位不为/ ‘/ // ’/ 的/ 字符串/ 作为/ 测试/ 输入/ 并/ 执行/ ,/ 以/ 确认/ 该/ 缺陷/ ;/ 第三/ ,/ 转置/ 7/ (/ T/ )/ 所/ 对应/ 的/ 路径/ 条件/ ,/ 生成/ 第/ 1/ 位/ 内容/ 为/ ‘/ // ’/ 的/ 测试/ 输入/ ,/ 假设/ 为/ ‘/ // ’/ ,/ 覆盖/ 语句/ 2/ ,/ 3/ (/ F/ )/ ,/ ①/ https/ :/ // // www/ ./ microsoft/ ./ com/ // china/ // whdc/ // devtools/ // tools/ // Page45/ (/ F/ )/ ,/ 7/ (/ F/ )/ ,/ 9/ ;/ 第四/ ,/ 转置/ 5/ (/ F/ )/ 所/ 对应/ 的/ 路径/ 条件/ ,/ 生成/ 长度/ 为/ 10/ 的/ 字符串/ ,/ 覆盖/ 语句/ 2/ ,/ 3/ (/ F/ )/ ,/ 5/ (/ T/ )/ ,/ 6/ ,/ 测试/ 结束/ ./ 在/ 测试/ 过程/ 中共/ 生成/ 了/ 5/ 个/ 测试用例/ 以/ 覆盖/ 所有/ 程序/ 路径/ 和/ 确认/ 缺陷/ ,/ 并/ 对/ 可疑/ 语句/ 检查/ 了/ 2/ 次/ ./ 若/ 使用/ Marple/ 进行/ 静态/ 分析/ ,/ 将/ 报告/ 第/ 8/ 行是/ 安全/ 的/ 缓冲区/ 修改/ 操作/ ,/ 而/ 第/ 9/ 行则/ 是/ 存在/ 缺陷/ 的/ ./ 但/ 第/ 9/ 行/ 的/ 缺陷/ 是否/ 为/ 真实/ 的/ 缺陷/ 以及/ 将会/ 如何/ 被/ 触发/ 仍/ 是/ 未知/ 的/ ./ 观察/ 上述/ 结果/ 发现/ ,/ 程序/ 中/ 可能/ 存在/ 缺陷/ 语句/ 的/ 可疑/ 程度/ 是/ 不同/ 的/ ,/ 使用/ 静态/ 分析/ 对待/ 测试程序/ 进行/ 分析/ 可/ 排除/ 部分/ 不/ 需要/ 动态/ 检测/ 的/ 安全/ 语句/ ./ 而/ 程序/ 中/ 也/ 只有/ 部分/ 分支/ 能够/ 到达/ 需要/ 动态/ 检查/ 的/ 可疑/ 语句/ ,/ 如/ 分支/ 3/ (/ T/ )/ 、/ 5/ (/ T/ )/ 均/ 不能到达/ 第/ 9/ 行/ ./ 运行/ 不能/ 覆盖/ 待/ 检测/ 语句/ 的/ 测试/ 输入/ ,/ 如/ 路径/ 2/ ,/ 3/ (/ T/ )/ ,/ 4/ ,/ 不能/ 对/ 检测/ 程序/ 缺陷/ 做出/ 贡献/ ./ 因此/ ,/ 若能/ 有效/ 地/ 使用/ 静态/ 分析/ 的/ 结果/ 指导/ 测试/ ,/ 并不需要/ 覆盖/ 程序/ 的/ 所有/ 路径/ 来/ 检测/ 程序/ 中/ 所/ 包含/ 的/ 缺陷/ ./ 在/ 测试/ 过程/ 中/ ,/ 若能/ 避免/ 生成/ 和/ 执行/ 不能/ 覆盖/ 待/ 检测/ 缺陷/ 语句/ 的/ 测试/ 输入/ ,/ 将会/ 降低/ 测试/ 开销/ ./ 4/ 目标/ 制导/ 的/ 混合/ 执行/ 测试/ 如图/ 2/ 所示/ ,/ 本文/ 提出/ 的/ 目标/ 制导/ 的/ 混合/ 执行/ 测试方法/ 首先/ 使用/ 静态/ 分析/ 工具/ 对待/ 测试程序/ 进行/ 分析/ ,/ 获取/ 程序/ 中/ 可能/ 存在/ 缺陷/ 的/ 可疑/ 语句/ 的/ 类型/ 及其/ 所在位置/ ,/ 并/ 将/ 可疑/ 语句/ 作为/ 待/ 检测/ 缺陷/ 语句/ 指导/ 混合/ 执行/ 测试/ ./ 目标/ 制导/ 的/ 混合/ 执行/ 测试/ 分为/ 3/ 个/ 步骤/ :/ 可达性/ 分析/ 、/ 程序/ 插装/ 、/ 动态/ 测试/ ./ 首先/ ,/ 计算/ 程序/ 中/ 各/ 分支/ 语句/ 与/ 静态/ 分析/ 所/ 报告/ 的/ 待/ 检测/ 语句/ 间/ 的/ 可达性/ ;/ 其次/ ,/ 插装待/ 测试程序/ ,/ 以/ 支持/ 在/ 具体/ 执行程序/ 时/ 收集/ 路径/ 条件/ 和/ 各/ 变量/ 的/ 符号化/ 表达式/ ;/ 第三/ ,/ 根据/ 静态/ 分析/ 和/ 可达性/ 分析/ 的/ 信息/ 判断/ 需要/ 覆盖/ 的/ 路径/ ,/ 求解/ 路径/ 条件/ 生成/ 测试/ 输入/ ,/ 驱动程序/ 执行/ 测试/ 输入/ ,/ 同时/ 进行/ 符号执行/ 并/ 对待/ 检测/ 语句/ 进行/ 符号化/ 检测/ ./ 4.1/ 程序/ 模型/ 在/ 详细/ 介绍/ 各/ 步骤/ 之前/ ,/ 我们/ 先/ 给出/ 待/ 测试程序/ 的/ 模型/ ./ 基于/ CREST/ [/ 9/ ]/ 所/ 使用/ 的/ 程序/ 模型/ ,/ 我们/ 定义/ 了/ 如下/ 与/ C语言/ 类似/ 的/ 程序/ 模型/ ,/ 用于/ 描述/ 目标/ 制导/ 的/ 混合/ 执行/ 测试/ 技术/ ./ 待/ 测试程序/ 是/ 由/ n/ 个/ 函数/ 所/ 构成/ 的/ 一个/ 集合/ :/ {/ f1/ ,/ f2/ ,/ …/ ,/ fn/ }/ ,/ 其中/ 包含/ 一个/ 程序执行/ 的/ 入口/ 函数/ main/ ./ 一个/ 函数/ fi/ 由/ mi/ 条带/ 标签/ 的/ 语句/ 序列/ li/ ,/ 1/ :/ si/ ,/ 1/ ,/ li/ ,/ 2/ :/ si/ ,/ 2/ ,/ …/ ,/ li/ ,/ mi/ :/ si/ ,/ mi/ 所/ 组成/ ./ 组成/ 函数/ 的/ 语句/ 可/ 分为/ 5/ 类/ :/ (/ 1/ )/ 输入/ 语句/ ,/ 其/ 形式/ 为/ Input/ (/ var/ ,/ t/ )/ ,/ 为/ 变量/ var/ 输入/ t/ 字节/ 的/ 值/ ;/ (/ 2/ )/ 函数调用/ 语句/ ,/ 其/ 形式/ 为/ fi/ (/ var1/ ,/ var2/ ,/ …/ )/ ,/ 以/ var1/ ,/ var2/ ,/ …/ 为/ 参数/ 调用函数/ fi/ ;/ (/ 3/ )/ 赋值/ 语句/ ,/ 其/ 形式/ 为/ Assign/ (/ vard/ ,/ vars/ ,/ t/ )/ ,/ 将/ vars/ 中/ t/ 字节/ 的/ 值/ 拷贝到/ vard/ 中/ ;/ (/ 4/ )/ 条件/ 判断/ 语句/ ,/ 其/ 形式/ 为/ ifcgotol/ ;/ (/ 5/ )/ 终止/ 语句/ ,/ 包含/ 正常/ 终止/ halt/ 和/ 异常/ 终止/ abort/ 两种/ 形式/ ./ 对于/ 一条/ 条件/ 判断/ 语句/ li/ ,/ j/ :/ ifcgotoli/ ,/ k/ ,/ li/ ,/ k/ 和/ li/ ,/ j/ +/ 1/ 分别/ 为/ 条件/ c/ 为/ true/ 和/ false/ 时/ 执行/ 的/ 下/ 一条/ 语句/ ./ 我们/ 称/ 这样/ 的/ 两条/ 语句/ 为/ 分支/ 语句/ ,/ 且/ 互为/ 对应/ 分支/ ,/ 将/ 其/ 表示/ 为/ Pair/ (/ li/ ,/ k/ )/ =/ li/ ,/ j/ +/ 1/ 和/ li/ ,/ k/ =/ Pair/ (/ li/ ,/ j/ +/ 1/ )/ ./ 程序/ 的/ 一条/ 路径/ 可/ 表示/ 为/ 一个/ 语句/ 序列/ ,/ 其/ 形式/ 为/ (/ entry/ ,/ B/ ,/ exit/ )/ ,/ 其中/ entry/ 是/ 程序/ 入口/ 语句/ ,/ exit/ 是/ 该次/ 执行/ 的/ 终止/ 语句/ ,/ B/ 是/ 该次/ 执行/ 过程/ 中/ 顺序/ 经过/ 的/ 分支/ 语句/ 所/ 组成/ 的/ 一个/ 序列/ :/ b1/ ,/ b2/ ,/ …/ ,/ bw/ ./ 4.2/ 静态/ 分析/ 为/ 使用/ 静态/ 分析/ 的/ 结果/ 来/ 指导/ 动态/ 测试/ ,/ 降低/ 测试/ 开销/ ,/ 我们/ 首先/ 使用/ 静态/ 分析/ 工具/ 对待/ 测试程序/ 进行/ 分析/ ,/ 并/ 获取/ 程序/ 中/ 可疑/ 语句/ 的/ 缺陷/ 类型/ 及其/ 所在位置/ ./ 将/ 可疑/ 语句/ 作为/ 待/ 检测/ 缺陷/ 语句/ 指导/ 测试/ ,/ 其中/ 缺陷/ 的/ 类型/ 将/ 用于/ 构造/ 缺陷/ 模型/ ,/ 用于/ 动态/ 运行/ 时/ 进行/ 相应/ 检查/ ,/ 位置/ 信息/ 则/ 用于/ 计算/ 程序/ 各/ 分支/ 语句/ 到/ 待/ 检测/ 缺陷/ 语句/ 的/ 可达性/ ./ 静态/ 分析/ 的/ 结果/ 需要/ 具有/ 尽可能/ 高/ 的/ 精确度/ ,/ 因为/ 误报/ 会/ 给/ 动态/ 测试/ 带来/ 额外/ 的/ 检测/ 开销/ ,/ 而/ 漏报/ 则/ 会/ 导致/ 动态/ 测试/ 时/ 不/ 对/ 漏报/ 的/ 语句/ 进行/ 检测/ ,/ 从而/ 将/ 漏报/ 传递/ 给/ 动态/ 测试/ ./ 一些/ 静态/ 分析/ 工具/ 支持/ 将/ 所/ 报告/ 的/ 缺陷/ 根据/ 重要性/ 进行/ 排序/ ,/ 我们/ 可/ 按照/ 测试/ 预算/ 从/ 重要性/ 较/ 高/ 的/ 缺陷/ 开始/ ,/ 依次/ 选取/ 需要/ 动态/ 检测/ 的/ 缺陷/ ,/ 并/ 作为/ 目标/ 指导/ 混合/ 执行/ 测试/ ./ 4.3/ 可达性/ 分析/ 并非/ 所有/ 的/ 程序/ 路径/ 都/ 能够/ 覆盖/ 待/ 检测/ 缺陷/ 语句/ ,/ 触发/ 静态/ 分析/ 所/ 识别/ 出/ 的/ 待/ 检测/ 缺陷/ 更/ 需要/ 满足/ 特定/ 的/ 条件/ ./ 使用/ 程序/ 的/ 结构/ 信息/ 能够/ 部分/ 避免/ Page5/ 生成/ 和/ 执行/ 不可/ 达待/ 检测/ 缺陷/ 语句/ 的/ 测试/ 输入/ ,/ 从而/ 将/ 测试/ 的/ 重点/ 尽量/ 集中/ 在/ 能/ 覆盖/ 待/ 检测/ 缺陷/ 语句/ 的/ 测试/ 输入/ 上/ ,/ 降低/ 测试/ 开销/ ./ 本文/ 中/ 我们/ 所/ 使用/ 的/ 程序结构/ 信息/ 是/ 基于/ 过程/ 间/ 控制流/ 图/ (/ Inter/ -/ proceduralControlFlowGraph/ ,/ ICFG/ )/ 所/ 计算/ 出/ 的/ 程序/ 中/ 各/ 分支/ 语句/ 到/ 可疑/ 语句/ 的/ 可达性/ 关系/ ./ ICFG/ 是/ 一个/ 由/ 节点/ 和/ 边/ 所/ 组成/ 的/ 有向图/ ,/ 一个/ 节点/ 对应/ 于/ 程序/ 中/ 的/ 一条/ 语句/ ,/ 而/ 一条/ 边则/ 从/ 一个/ 节点/ 指向/ 该/ 节点/ 对应/ 程序/ 语句/ 的/ 直接/ 后续/ 语句/ 所/ 对应/ 的/ 节点/ ./ 一个/ 由/ n/ 个/ 函数/ {/ f1/ ,/ f2/ ,/ …/ ,/ fn/ }/ 所/ 构成/ 的/ 程序/ ,/ 语句/ li/ ,/ j/ :/ si/ ,/ j/ 的/ 直接/ 后继/ 语句/ 为/ 如下/ 的/ 一个/ 集合/ :/ ·/ 空集/ / ,/ 若/ li/ ,/ j/ :/ si/ ,/ j/ 为/ 一条/ 终止/ 语句/ ;/ ·/ {/ li/ ,/ j/ +/ 1/ :/ si/ ,/ j/ +/ 1/ ,/ li/ ,/ k/ :/ si/ ,/ k/ }/ ,/ 若/ li/ ,/ j/ :/ si/ ,/ j/ 为/ 一条/ 条件/ 判断/ 语句/ :/ ifcgotoli/ ,/ k/ ;/ 若/ li/ ,/ j/ :/ si/ ,/ j/ 为/ 函数/ fi/ 的/ 返回/ 语句/ ;/ fr/ (/ …/ )/ ;/ ·/ {/ lr/ ,/ t/ +/ 1/ :/ sr/ ,/ t/ +/ 1/ |/ 函数/ fr/ 中/ 的/ 语句/ lr/ ,/ t/ 为/ fi/ (/ …/ )/ }/ ,/ ·/ {/ lr/ ,/ 1/ :/ sr/ ,/ 1/ }/ ,/ 若/ li/ ,/ j/ :/ si/ ,/ j/ 为/ 一条/ 函数调用/ 语句/ :/ ·/ {/ li/ ,/ j/ +/ 1/ :/ si/ ,/ j/ +/ 1/ }/ ,/ 其它/ 情况/ ./ 基于/ ICFG/ ,/ 在/ 转置/ 分支/ b/ 所/ 对应/ 的/ 路径/ 条件/ 前/ ,/ 先/ 判断/ b/ 对应/ 分支/ Pair/ (/ b/ )/ 的/ 可达性/ 关系/ ,/ 若/ Pair/ (/ b/ )/ 能/ 达到/ 某待/ 检测/ 缺陷/ 语句/ ,/ 则/ 进行/ 约束/ 求解/ 并/ 生成/ 相应/ 测试/ 输入/ ,/ 否则/ ,/ 跳过/ 该/ 分支/ ,/ 继续/ 转置/ 其它/ 路径/ 条件/ ./ 算法/ 1/ 描述/ 了/ 计算/ 程序/ 分支/ 语句/ 与/ 可疑/ 语句/ 间/ 可达性/ 关系/ 的/ 算法/ ./ 该/ 算法/ 将/ 程序/ 的/ ICFG/ 和/ 静态/ 分析/ 所/ 提供/ 的/ 待/ 检测/ 缺陷/ 语句/ 集合/ V/ 作为/ 输入/ ./ 输出/ mapreachability/ 存放/ 从/ 各/ 分支/ 语句/ 到/ 该/ 分支/ 可达待/ 检测/ 缺陷/ 语句/ 集合/ 的/ 映射/ ./ 第/ 1/ ~/ 5/ 行/ 调用/ Reach/ 过程/ 计算/ 分支/ 语句/ 到/ 各待/ 检测/ 缺陷/ 语句/ 的/ 可达性/ ./ Reach/ 过程/ (/ 8/ ~/ 15/ 行/ )/ 中/ 第/ 9/ 行/ 获取/ 当前/ 语句/ l/ 的/ 直接/ 后继/ 语句/ 集合/ successors/ ,/ 第/ 10/ 行/ 逐一/ 检查/ successors/ 中/ 的/ 语句/ li/ 是否/ 为/ 待/ 检测/ 缺陷/ 语句/ ,/ 若/ 是/ ,/ 将/ li/ 加入/ 当前/ 遍历/ 分支/ 的/ 可达待/ 检测/ 缺陷/ 语句/ 集合/ reachable/ 中/ ./ 第/ 13/ 行/ 迭代/ 调用/ Reach/ 过程/ 遍历/ li/ 的/ 可达/ 语句/ ./ 算法/ 1/ ./ 分支/ 可达性/ 计算/ 算法/ ./ 输入/ :/ ICFG/ :/ icfg/ // // 程序/ ICFG/ 图/ 输出/ :/ mapreachability/ // // 从/ 分支/ 到/ 可达待/ 检测/ 缺陷/ 语/ 1/ ./ foreachbranchstatementbinicfg/ {/ 2/ ./ setreachable3/ ./ Reach/ (/ b/ ,/ reachable/ )/ 4/ ./ reachability/ [/ b/ ]/ ·/ ·/ =/ reachable5/ ./ }/ 6/ ./ returnreachability7/ ./ 8/ ./ Procedure/ :/ Reach/ (/ statementl/ ,/ set/ / reachable/ )/ {/ 9/ ./ setsuccessors/ ·/ ·/ =/ Successors/ (/ l/ )/ 10/ ./ foreachstatementliinsuccessors/ {/ 11/ ./ ifli/ ∈/ V12/ ./ reachable/ ./ push/ (/ li/ )/ 13/ ./ Reach/ (/ li/ ,/ reachable/ )/ 14/ ./ }/ 15/ ./ }/ 4.4/ 程序/ 插装/ 为了/ 在/ 执行/ 具体/ 测试/ 输入/ 的/ 同时/ 进行/ 符号执行/ ,/ 需要/ 对/ 源程序/ 进行/ 插装以/ 收集/ 执行/ 过程/ 中/ 对/ 各个/ 基本/ 类型/ 变量/ 、/ 指针/ 变量/ 和/ 缓冲区/ 的/ 赋值/ 、/ 修改/ 等/ 操作/ 及/ 路径/ 条件/ 的/ 符号/ 表达式/ ./ 我们/ 将/ 符号执行/ 的/ 功能/ 封装/ 为/ 一个/ 函数库/ ,/ 该/ 函数库/ 包含/ 了/ 4/ 种/ 类型/ 的/ 函数/ :/ 输入/ 声明/ 、/ 赋值/ 修改/ 跟踪/ 、/ 路径/ 条件/ 跟踪/ 和/ 缺陷/ 检测/ ./ 算法/ 2/ 描述/ 了/ 程序/ 插装/ 的/ 算法/ ./ 该/ 算法/ 将/ 源程序/ 和/ 静态/ 分析/ 所/ 提供/ 的/ 待/ 检测/ 语句/ 集合/ V/ 作为/ 输入/ ,/ 输出/ 插装后/ 的/ 程序/ ./ 第/ 1/ 行/ 逐一/ 遍历/ 程序/ 中/ 的/ 函数/ ,/ 第/ 2/ 行/ 遍历/ 函数/ 中/ 各条/ 语句/ li/ :/ 若/ li/ 为/ 输入/ 语句/ ,/ 则/ 在/ li/ 前/ 插装/ 输入/ 声明/ 库函数/ ,/ 用于/ 声明/ 输入/ 变量/ 的/ 符号/ 表达式/ (/ 3/ ~/ 4/ 行/ )/ ;/ 若/ li/ 为/ 赋值/ 修改/ 语句/ ,/ 则/ 在/ li/ 前/ 插装/ 赋值/ 修改/ 跟踪/ 库函数/ ,/ 用于/ 符号化/ 表示/ 该/ 操作/ ,/ 以/ 对/ 程序/ 中/ 的/ 所有/ 变量/ 建立/ 一个/ 由/ 输入/ 变量/ 和/ 常量/ 所/ 构成/ 的/ 符号/ 表示/ 式/ (/ 5/ ~/ 6/ 行/ )/ ;/ 若/ li/ 为/ 条件/ 判断/ 语句/ ,/ 则/ 在/ 条件/ 判断/ 语句/ 及其/ 所/ 对应/ 的/ 分支/ 语句/ 处/ 插装/ 路径/ 条件/ 跟踪/ 库函数/ ,/ 用于/ 收集/ 路径/ 条件/ 的/ 符号/ 表达式/ (/ 7/ ~/ 13/ 行/ )/ ;/ 若/ li/ 为/ 静态/ 分析/ 所/ 报告/ 的/ 待/ 检测/ 缺陷/ 语句/ ,/ 则/ 在/ li/ 前/ 插装/ 缺陷/ 检测/ 库函数/ ,/ 用于/ 符号化/ 检查/ 在/ 当前/ 执行/ 路径/ 条件/ 下/ ,/ 该/ 缺陷/ 被/ 触发/ 的/ 可能性/ (/ 14/ ~/ 15/ 行/ )/ ./ 算法/ 2/ ./ 程序/ 插装/ 算法/ ./ 输入/ :/ set/ :/ F/ // // 源程序/ 输出/ :/ setF/ // // 插装后/ 程序/ 1/ ./ foreachfunctionfiinF/ {/ 2/ ./ foreachstatementliinfi/ {/ 3/ ./ ifliisainputstatementPage64/ ./ instrumentlibfunctionAddInput/ (/ )/ before5/ ./ elseifliisaassignorupdatestatement6/ ./ instrumentlibfunctionOperation/ (/ )/ before7/ ./ elseifliisaconditionalstatement/ {/ 8/ ./ instrumentlibfunctionConditional/ (/ )/ before9/ ./ bt/ ·/ ·/ =/ truebranchofli10/ ./ instrumentlibfunctionTrueBranch/ (/ )/ after11/ ./ bf/ ·/ ·/ =/ falsebranchofli12/ ./ instrumentlibfunctionFalseBranch/ (/ )/ after13/ ./ }/ 14/ ./ elseifli/ ∈/ V15/ ./ instrumentlibfunctionChecking/ (/ )/ before16/ ./ }/ 17/ ./ }/ 4.5/ 动态/ 测试/ 动态/ 测试/ 包括/ 测试/ 生成/ 和/ 测试/ 执行/ 两个/ 部分/ ./ 测试/ 输入/ 的/ 生成/ 过程/ 中/ ,/ 在/ 按照/ 深度/ 优先/ 规则/ 转置/ 各/ 分支/ 的/ 路径/ 条件/ 前/ ,/ 首先/ 检查/ 对应/ 分支/ 是否/ 可/ 达/ 至少/ 一条/ 待/ 检测/ 缺陷/ 语句/ ,/ 若/ 可达/ 则/ 对/ 转置/ 后/ 的/ 路径/ 条件/ 进行/ 约束/ 求解/ ,/ 生成/ 覆盖/ 新/ 路径/ 的/ 测试/ 输入/ ,/ 否则/ 跳过/ 该/ 分支/ ,/ 继续/ 遍历/ ./ 测试/ 执行/ 过程/ 则/ 运行/ 所/ 生成/ 的/ 测试/ 输入/ ,/ 并/ 在/ 运行/ 时/ 收集/ 路径/ 条件/ 的/ 符号化/ 表达式/ ./ 在/ 测试/ 执行/ 过程/ 中/ ,/ 检查/ 当前/ 分支/ 对/ 各待/ 检测/ 缺陷/ 语句/ 的/ 可达性/ ,/ 若均/ 不可/ 达/ ,/ 则/ 终止/ 测试/ 执行/ ./ 此外/ ,/ 在/ 测试/ 执行/ 过程/ 中/ 还/ 需要/ 检查/ 各待/ 检测/ 缺陷/ 是否/ 会/ 被/ 触发/ ./ 算法/ 3/ 描述/ 了/ 目标/ 制导/ 的/ 混合/ 执行/ 测试/ 技术/ 的/ 测试/ 输入/ 生成/ 算法/ ./ 第/ 2/ 行为/ 待/ 测试程序/ 准备/ 初始/ 输入/ 值/ ,/ 基本/ 类型/ 输入/ 变量/ 的/ 初始值/ 默认/ 为/ 0/ ,/ 字符串/ 输入/ 变量/ 的/ 初始值/ 默认/ 为空/ 字符串/ ./ 若/ 输入/ 变量/ 的/ 范围/ 可知/ ,/ 基本/ 类型/ 输入/ 变量/ 可/ 初始化/ 为/ 最大值/ 和/ 最小值/ ,/ 字符串/ 输入/ 变量/ 可/ 初始化/ 为/ 所/ 允许/ 的/ 最大/ 长度/ 和/ 最小/ 长度/ ./ 算法/ 3/ ./ 目标/ 制导/ 的/ 混合/ 执行/ 测试/ 输入/ 生成/ 算法/ ./ 输入/ :/ set/ :/ V/ // // 待/ 检测/ 缺陷/ 语句/ 集合/ 1/ ./ list/ :/ B/ // / 存放/ 分支/ 语句/ / // ,/ 2/ ./ listI/ =/ InitInput/ (/ )/ // // 初始化/ 输入/ 3/ ./ Run/ _/ Program/ (/ I/ ,/ B/ ,/ C/ )/ // // 以/ I/ 为/ 输入/ 运行/ 程序/ 4/ ./ Target/ _/ Guided/ _/ Search/ (/ 1/ ,/ B/ ,/ C/ )/ 5.6/ ./ Procedure/ :/ Target/ _/ Guided/ _/ Search/ (/ intdepth/ ,/ 7/ ./ boolpairedReachable/ ·/ ·/ =/ false8/ ./ for/ (/ inti/ ·/ ·/ =/ sizeOf/ (/ B/ )/ ;/ i/ >/ =/ depth/ ;/ i/ -/ -/ )/ {/ 9/ ./ branchpairedBranch/ ·/ ·/ =/ Pair/ (/ B/ [/ i/ ]/ )/ 10/ ./ ifreachability/ [/ pairedBranch/ ]/ ∩/ V/ ≠/ null/ {/ 11/ ./ pairedReachable/ ·/ ·/ =/ true12/ ./ }/ 13/ ./ if/ (/ pairedReachable/ =/ true/ )/ {/ 14/ ./ listI/ ·/ ·/ =/ solve/ (/ C/ [/ 1/ ]/ ∩/ …/ ∩/ C/ [/ i/ -/ 1/ ]/ ∩/ 15/ ./ list/ :/ B/ // / 存放/ 分支/ 语句/ / // ,/ 16/ ./ Run/ _/ Program/ (/ I/ ,/ B/ ,/ C/ )/ 17/ ./ Target/ _/ Guided/ _/ Search/ (/ ++/ depth/ ,/ B/ ,/ C/ )/ 18/ ./ }/ 19/ ./ }/ 20/ ./ }/ 第/ 3/ 行/ 使用/ 初始/ 输入/ 值/ 驱动程序/ 运行/ ,/ 并/ 在/ 链表/ B/ ,/ C/ 中/ 分别/ 顺序/ 记录/ 所/ 覆盖/ 的/ 分支/ 语句/ 及/ 所/ 对应/ 路径/ 条件/ 的/ 符号/ 表达式/ ./ 在/ 程序/ 的/ 执行/ 过程/ 中/ ,/ 若/ 执行/ 到/ 静态/ 分析/ 所/ 报告/ 的/ 待/ 检测/ 缺陷/ 语句/ ,/ 则/ 检测/ 该/ 语句/ 的/ 缺陷/ 是否/ 会/ 发生/ ./ 若会/ 发生/ ,/ 确认/ 该/ 缺陷/ 并/ 从/ V/ 中/ 删除/ ;/ 若/ 不会/ 发生/ ,/ 结合/ 路径/ 条件/ 对/ 该/ 语句/ 的/ 缺陷/ 触发/ 条件/ 进行/ 约束/ 求解/ ,/ 若/ 可解/ ,/ 生成/ 并/ 执行/ 满足/ 上述/ 条件/ 的/ 测试/ 输入/ 以/ 确认/ 该/ 缺陷/ ./ 当/ 检测/ 到/ 缺陷/ 将会/ 发生/ 时/ ,/ 修改/ 程序/ 状态/ ,/ 避免/ 错误/ 实际/ 发生/ (/ 如/ :/ 检测/ 到/ 缓冲区/ 溢出/ 缺陷/ 会/ 发生/ 时/ ,/ 为/ 该/ 缓冲区/ 分配/ 新/ 的/ 地址/ 空间/ ,/ 以/ 避免/ 实际/ 发生/ 缓冲区/ 溢出/ )/ ,/ 并/ 继续/ 运行/ 程序/ 以/ 发现/ 隐藏/ 在/ 程序/ 路径/ 中/ 更深/ 位置/ 的/ 缺陷/ ./ 程序/ 的/ 可达性/ 信息/ 还/ 被/ 用于/ 降低/ 执行/ 测试/ 输入/ 的/ 开销/ ,/ 当/ 执行/ 到/ 的/ 分支/ 语句/ 对/ 所有/ 待/ 检测/ 缺陷/ 语句/ 均/ 不可/ 达时/ ,/ 提前/ 终止/ 程序运行/ ./ Target/ _/ Guided/ _/ Search/ 过程/ (/ 6/ ~/ 20/ 行/ )/ 描述/ 了/ 目标/ 制导/ 的/ 搜索算法/ ./ 第/ 8/ 行对/ 所/ 收集/ 到/ 的/ 分支/ 链表/ B/ 进行/ 深度/ 优先/ 遍历/ ,/ 对/ 分支/ B/ [/ i/ ]/ ,/ 第/ 10/ 行/ 根据/ 程序/ 的/ 可达性/ 信息/ 判断/ 该/ 分支/ 的/ 对应/ 分支/ Pair/ (/ B/ [/ i/ ]/ )/ 是否/ 可/ 达/ 至少/ 一条/ 待/ 检测/ 缺陷/ 语句/ ./ 若/ 可达/ ,/ 第/ 14/ 行/ 求解/ 路径/ 条件/ C/ [/ 1/ ]/ ∩/ …/ ∩/ C/ [/ i/ -/ 1/ ]/ ∩/ / (/ C/ [/ i/ ]/ )/ ,/ Page7/ 生成/ 的/ 测试/ 输入/ 将/ 沿/ 路径/ (/ entry/ ,/ B/ [/ 1/ ]/ ,/ B/ [/ 2/ ]/ ,/ …/ ,/ Pair/ (/ B/ [/ i/ ]/ )/ ,/ …/ ,/ exit/ )/ 运行/ ./ 第/ 16/ 行/ 使用/ 生成/ 的/ 输入/ 值/ 驱动程序/ 运行/ ,/ 并/ 在/ 链表/ B/ ,/ C/ 中/ 分别/ 顺序/ 记录/ 所/ 覆盖/ 的/ 分支/ 语句/ 及/ 所/ 对应/ 路径/ 条件/ 的/ 符号/ 表达式/ ./ 当/ 所有/ 待/ 检测/ 缺陷/ 都/ 已/ 得到/ 确认/ ,/ 或/ 所有/ 可达待/ 检测/ 缺陷/ 语句/ 的/ 路径/ 都/ 已/ 被/ 覆盖/ 后/ ,/ 终止/ 测试/ ./ 5/ 实现/ 和/ 评估/ 5.1/ 原型/ 工具/ 实现/ 为了/ 使/ 本文/ 所/ 提出/ 的/ 方法/ 不失/ 一般性/ ,/ 也/ 具有/ 针对性/ ,/ 基于/ 上述/ 目标/ 制导/ 的/ 混合/ 执行/ 测试/ 技术/ ,/ 我们/ 面向/ 一类/ 典型/ 的/ 程序/ 缺陷/ :/ 缓冲区/ 溢出/ ,/ 实现/ 了/ 一项/ 原型/ 测试工具/ :/ TARGET/ (/ TARget/ -/ GuidEdTesting/ )/ ①/ ,/ 以/ 检测/ C语言/ 程序/ 中/ 的/ 缓冲区/ 溢出/ 缺陷/ ./ TARGET/ 的/ 主页/ 上/ 提供/ 了/ 详细/ 的/ 使用/ 说明/ 及/ 下载/ ./ 为了/ 检测/ 缓冲区/ 溢出/ 缺陷/ ,/ 除了/ 对/ 缓冲区/ 的/ 内容/ 进行/ 符号化/ 建模/ 外/ ,/ 我们/ 还/ 对/ 缓冲区/ 的/ 大小/ (/ size/ )/ 和/ 已/ 使用/ 长度/ (/ length/ )/ 提供/ 了/ 符号化/ 表示/ ./ 在/ 混合/ 执行/ 测试/ 技术/ 的/ 基础/ 上/ ,/ 我们/ 为/ 指针/ 变量/ 和/ 缓冲区/ 也/ 建立/ 了/ 映射/ 关系/ ./ 在/ TARGET/ 的/ 符号/ 映射/ 关系/ δ/ 中/ ,/ 将/ 一个/ 指针/ 变量/ 从/ 其/ 具体地址/ addr/ 映射/ 到/ 一个/ 三元组/ (/ size/ ,/ len/ ,/ C/ )/ 表示/ 的/ 缓冲区/ ,/ 其中/ size/ 是/ 一个/ 符号/ 表达式/ ,/ 表示/ 该/ 缓冲区/ 变量/ 分配/ 空间/ 的/ 大小/ ,/ len/ 是/ 一个/ 符号/ 表达式/ ,/ 表示/ 该/ 缓冲区/ 变量/ 已/ 使用/ 的/ 长度/ ,/ 即该/ 缓冲区/ 变量/ 中/ 终结符/ ‘/ \/ 0/ ’/ 所在位置/ ,/ C/ =/ c1/ ,/ c2/ ,/ …/ ,/ cv/ 为/ 一个/ 序列/ ,/ 是/ 该/ 缓冲区/ 所/ 存放/ 内容/ 的/ 符号/ 表达式/ ./ 我们/ 借鉴/ 了/ SPLAT/ [/ 10/ ]/ 的/ 思想/ ,/ 仅为/ 缓冲区/ 变量/ 前/ v/ 个/ 位置/ 进行/ 符号化/ 建模/ 以/ 提高/ 系统/ 的/ 可扩展性/ ./ 我们/ 将/ 一个/ 指针/ 变量/ p/ 表示/ 为/ 一个二元/ 组/ (/ addr/ ,/ off/ )/ ,/ 其中/ addr/ 是/ 一个/ 无/ 符号长/ 整形/ 数/ ,/ 是/ 该/ 指针/ 变量/ 的/ 地址/ ,/ off/ 则/ 是/ p/ 所/ 指向/ 缓冲区/ 中/ 的/ 位置/ 距离/ 该/ 缓冲区/ 起始/ 位置/ 偏移量/ 的/ 符号/ 表达式/ ,/ δ/ (/ addr/ )/ 返回/ p/ 所/ 指向/ 的/ 缓冲区/ b/ (/ size/ ,/ len/ ,/ C/ )/ ./ 图/ 3/ 描述/ 了/ TARGET/ 中/ 缓冲区/ 的/ 符号化/ 表示/ 方式/ ./ 为了/ 在/ 测试/ 过程/ 中/ 通过/ 符号化/ 的/ 方式/ 来/ 检测/ 缓冲区/ 溢出/ 缺陷/ ,/ 需要/ 对/ 该类/ 缺陷/ 定义/ 相应/ 的/ 缺陷/ 模型/ ./ 表/ 1/ 描述/ 了/ 缓冲区/ 溢出/ 缺陷/ 的/ 缺陷/ 模型/ ./ strcpy/ (/ pd/ ,/ ps/ )/ lens/ -/ offs/ >/ =/ sized/ -/ offdstrcat/ (/ pd/ ,/ ps/ )/ lens/ -/ offs/ +/ lend/ >/ =/ sized/ / pd/ ·/ ·/ =/ var/ 注/ :/ 表格/ 中/ pd/ =/ (/ addrd/ ,/ offd/ )/ ,/ bd/ =/ (/ sized/ ,/ lend/ ,/ Cd/ )/ =/ δ/ (/ addrd/ )/ ≠/ null/ ,/ ps/ =/ (/ addrs/ ,/ offs/ )/ ,/ bs/ =/ (/ sizes/ ,/ lens/ ,/ Cs/ )/ =/ δ/ (/ addrs/ )/ ≠/ null/ ./ TARGET/ 的/ 动态/ 测试/ 部分/ 是/ 基于/ 混合/ 执行/ 测试工具/ CREST/ ②/ 实现/ 的/ ,/ 采用/ 的/ 约束/ 求解/ 器为/ Yices/ ③/ ./ TARGET/ 的/ 开发/ 环境/ 是/ Window7Ulti/ -/ mate/ 、/ VisualStudio2008/ 及/ MicrosoftPhoenixSDK2008/ ④/ ./ 其中/ TARGET/ 的/ 插/ 装器/ 是/ 作为/ Phoenix/ 的/ 一个/ 插件/ 来/ 实现/ 的/ ./ 待测/ 程序/ 仅/ 需/ 在/ Phoenix/ 平台/ 下/ 使用/ 该/ 插件/ 进行/ 编译/ 即可/ 生成/ 包含/ 符号执行/ 所/ 需/ 库函数/ 的/ 可执行程序/ ,/ 该/ 程序/ 可/ 在/ 执行/ 具体/ 输入/ 的/ 同时/ 进行/ 符号执行/ ./ 表/ 2/ 描述/ 了/ 部分/ 函数/ 的/ 符号化/ 执行/ 语义/ ./ pd/ ·/ ·/ =/ input/ (/ size/ )/ 创建/ size/ 大小/ 的/ 缓冲区/ b/ ,/ 其中/ len/ ·/ ·/ =/ size/ ,/ pd/ ·/ ·/ =/ malloc/ (/ size/ )/ 创建/ size/ 大小/ 的/ 缓冲区/ b/ ,/ 其中/ offd/ ·/ ·/ =/ 0/ ,/ pd/ ·/ ·/ =/ ps/ ±/ v/ δ/ (/ addd/ )/ ·/ ·/ =/ δ/ (/ adds/ )/ ,/ offd/ ·/ ·/ =/ offs/ ±/ v/ / pd/ ·/ ·/ =/ ‘/ \/ 0/ ’/ b/ ·/ ·/ =/ δ/ (/ addrd/ )/ ,/ len/ ·/ ·/ =/ offd/ 注/ :/ 表格/ 中/ pd/ =/ (/ addrd/ ,/ offd/ )/ ,/ ps/ =/ (/ addrs/ ,/ offs/ )/ ,/ b/ =/ (/ size/ ,/ len/ ,/ C/ )/ ./ 5.2/ 实验设计/ 为/ 评估/ 目标/ 制导/ 的/ 混合/ 执行/ 测试/ 技术/ 的/ 有效性/ ,/ 我们/ 在/ 同样/ 的/ 开发/ 平台/ 上/ 实现/ 了/ SPLAT/ 技术/ [/ 10/ ]/ ,/ 并/ 使用/ 上述/ 两个/ 工具/ 分别/ 对/ 一组/ 基准/ 程序/ 进行/ 了/ 测试/ ,/ 从/ 缺陷/ 检测/ 能力/ 、/ 测试/ 输入/ 生成/ 开销/ 和/ 动态/ 检测/ 开销/ 3/ 个/ 方面/ 进行/ 了/ 度量/ ./ 测试/ 的/ 基准/ 程序/ 包括/ WuFTP/ -/ 1/ 、/ Sendmail/ -/ 2/ 和/ gzip/ -/ 1.2/ ./ 4/ ,/ 其中/ WuFTP/ -/ 1/ 和/ Sendmail/ -/ 2/ 取自/ 文献/ [/ 16/ ]/ 中/ 的/ 一组/ 含有/ 代表性/ 缓冲区/ 溢出/ 缺陷/ 的/ 基准/ 程序/ ,/ gzip/ -/ 1.2/ ./ 4/ ⑤/ 是/ 一个/ 开源/ 的/ 文件/ 压缩/ 程序/ ./ 由于/ 原有/ 的/ SPLAT/ 技术/ 发现/ 一个/ 缺陷/ 后/ 就/ 会/ 报告/ 错误/ 并/ 停止/ 测试/ ,/ 为/ 便于/ 比较/ ,/ 我们/ 采取/ 的/ 方式/ 是/ 立即/ 修正/ 所/ 发现/ 的/ 缺陷/ 并/ 继续/ 进行/ 测试/ ,/ 直到/ 不再/ 发现/ 新/ 的/ 缺陷/ 为止/ ./ 实验/ 运行/ 的/ 硬件/ 环境/ 为/ IntelDuoCore2/ ./ 26GHz/ 处理器/ 和/ 2GB/ 内存/ 的/ 计算机/ ./ ①/ ②/ ③/ ④/ ⑤/ Page8/ 在/ 本/ 实验/ 中/ ,/ TARGET/ 工具/ 所/ 需/ 的/ 待/ 检测/ 缺陷/ 信息/ 由/ 静态/ 分析/ 工具/ Marple/ [/ 15/ ]/ 提供/ ./ Marple/ 将/ 可能/ 存在/ 缺陷/ 的/ 语句/ 分为/ 安全/ 的/ (/ safe/ )/ 、/ 有/ 缺陷/ 的/ (/ vulnerable/ )/ 、/ 不/ 确定/ 的/ (/ don/ ’/ tknow/ )/ 几类/ ./ 安全/ 的/ 语句/ 在/ 任何/ 输入/ 条件/ 下均/ 不会/ 被/ 触发/ 缺陷/ ;/ 有/ 缺陷/ 的/ 语句/ 在/ 一定/ 条件/ 下/ 可能/ 会/ 被/ 触发/ 缺陷/ ;/ 不/ 确定/ 类型/ 的/ 语句/ 则/ 是/ Marple/ 不能/ 判断/ 缺陷/ 是否/ 能/ 被/ 触发/ 的/ 语句/ ./ 库/ 函数调用/ 、/ 非线性/ 操作/ 及/ 复杂/ 的/ 指针/ 运算/ 都/ 可能/ 导致/ 缺陷/ 是否/ 会/ 被/ 触发/ 不能/ 确定/ ./ 在/ 本/ 实验/ 中/ ,/ 我们/ 将/ Marple/ 报告/ 为/ 有/ 缺陷/ 的/ 语句/ 作为/ 待/ 检测/ 缺陷/ 语句/ 指导/ 动态/ 测试/ ./ Marple/ 对/ 3/ 个/ 基准/ 程序/ 的/ 静态/ 分析/ 结果/ 如表/ 3/ 所示/ ./ 基准/ 程序/ 报告/ 缺陷/ 数/ [/ 15/ ]/ 漏报/ 缺陷/ 数/ 误报/ 缺陷/ 数/ / WuFTP/ -/ 14Sendmail/ -/ 24gzip/ -/ 1.2/ ./ 49/ / / 注/ :/ / Marple/ 分析/ 过程/ 中/ 所/ 考虑/ 的/ 是/ 可能/ 的/ 最坏/ 情况/ ,/ 但/ 由于/ 操作系统/ 等/ 环境因素/ 的/ 限制/ ,/ 如/ 系统/ 所/ 支持/ 的/ 最长/ 文件/ 长度/ 有限/ ,/ 部分/ 缺陷/ 在/ 实际/ 的/ 系统/ 中/ 不能/ 被/ 触发/ ,/ 本文/ 将/ 这类/ 缺陷/ 也/ 暂归为/ 误报/ ./ / / 原文中/ gzip/ -/ 1.2/ ./ 4/ 程序/ 所/ 报告/ 的/ 缺陷/ 数为/ 10/ ./ 在/ 论文/ 发表/ 后/ ,/ 原文/ 作者/ 对/ Marple/ 进行/ 了/ 改进/ ,/ 减少/ 了/ 一处/ 误报/ ./ 5.3/ 实验/ 结果/ 分析/ 5.3/ ./ 1/ 缺陷/ 检测/ 能力表/ 4/ 中/ 比较/ 了/ 两个/ 工具/ 检测/ 缺陷/ 的/ 能力/ ,/ 其中/ 表/ 4/ 测试/ 时间/ 和/ 缺陷/ 检测/ 能力/ 比较/ 基准/ 程序/ 规模/ // kWuFTP/ -/ 10.2/ Sendmail/ -/ 20.3/ gzip/ -/ 1.2/ ./ 44.55/ ./ 3.2/ 测试/ 输入/ 生成/ 开销/ 表/ 5/ 中/ 比较/ 了/ 两种/ 工具/ 在/ 生成/ 测试/ 输入/ 上/ 的/ 开销/ ./ 尝试/ 生成/ 次数/ 列/ 给出/ 了/ 两个/ 工具/ 尝试/ 生成/ 测试/ 输入/ 的/ 次数/ ,/ 即/ 调用/ 约束/ 求解/ 器/ 求解/ 路径/ 条件/ 的/ 次表/ 5/ 测试/ 输入/ 生成/ 的/ 开销/ 基准/ 程序/ WuFTP/ -/ 1Sendmail/ -/ 2gzip/ -/ 1.2/ ./ 4/ 从表/ 5/ 中/ 可以/ 看出/ ,/ TARGET/ 降低/ 了/ 生成/ 测试用例/ 的/ 次数/ 和/ 所/ 耗费/ 的/ 时间/ ,/ TARGET/ 尝试/ 生成/ 测试/ 输入/ 的/ 总/ 次数/ 约/ 为/ SPLAT/ 技术/ 的/ 1/ // 3/ ,/ 成功/ 生/ 25651528778711/ 第/ 1/ 、/ 2/ 列/ 给出/ 了/ 基准/ 程序/ 的/ 名称/ 及/ 该/ 程序/ 的/ 代码/ 行/ 数/ (/ 不/ 含/ 注释/ 和/ 空行/ )/ ,/ 第/ 3/ 、/ 4/ 列/ 分别/ 给出/ 了/ 两个/ 工具/ 检测/ 到/ 的/ 缺陷/ 数/ 、/ 漏报/ 的/ 缺陷/ 数及/ 消耗/ 的/ 时间/ ./ 其中/ TARGET/ 所/ 消耗/ 的/ 时间/ 由/ 使用/ Marple/ 进行/ 静态/ 分析/ 的/ 时间/ 和/ 测试/ 的/ 时间/ 两/ 部分/ 所/ 组成/ ./ 从表/ 4/ 中/ 可以/ 看出/ ,/ TARGET/ 在/ WuFTP/ -/ 1/ 和/ Sendmail/ -/ 2/ 中均/ 检测/ 到/ 了/ 更/ 多/ 的/ 缺陷/ ./ 其中/ ,/ TAR/ -/ GET/ 在/ 基准/ 程序/ WuFTP/ -/ 1/ 中所/ 漏报/ 的/ 缺陷/ 是/ 由于/ 静态/ 分析/ 工具/ 未/ 将/ 该/ 缺陷/ 作为/ 有/ 缺陷/ 的/ 语句/ 报告/ ,/ 因而/ 未/ 在/ 测试/ 时/ 进行/ 检测/ ./ 总体/ 上/ 看/ ,/ TARGET/ 所/ 检测/ 到/ 的/ 缺陷/ 数比/ SPLAT/ 技术/ 多/ 5/ 个/ ,/ 其/ 原因/ 主要/ 有/ 如下/ 两个/ 方面/ :/ 一方面/ ,/ 当/ 发现/ 会/ 发生/ 缓冲区/ 溢出/ 时/ ,/ TARGET/ 为/ 缓冲区/ 分配/ 新/ 的/ 空间/ ,/ 继续/ 安全/ 地/ 运行/ 程序/ ,/ 从而/ 能/ 覆盖/ 更深/ 的/ 程序/ 路径/ ,/ 识别/ 出/ 更/ 多/ 的/ 缺陷/ ,/ 而/ SPLAT/ 技术/ 则/ 立即/ 报告/ 错误/ 并/ 停止/ 测试/ ,/ 为/ 继续/ 测试/ 而/ 修正/ 所/ 发现/ 的/ 缺陷/ 可能/ 会/ 隐藏/ 其它/ 的/ 潜在/ 缺陷/ ;/ 另一方面/ ,/ 除了/ 将/ 默认/ 输入/ 作为/ 测试/ 的/ 初始/ 输入/ 外/ ,/ TARGET/ 还/ 支持/ 将/ 变量/ 的/ 边界值/ 作为/ 测试/ 的/ 初始/ 输入/ ,/ 从而/ 能/ 更/ 覆盖/ 更/ 多/ 的/ 程序/ 路径/ ./ 从表中/ 还/ 可以/ 看出/ ,/ TARGET/ 所/ 花费/ 的/ 总/ 时间/ 大为/ 降低/ ,/ 所/ 消耗/ 的/ 总/ 时间/ 约/ 为/ SPLAT/ 技术/ 消耗/ 总/ 时间/ 的/ 1/ // 6/ ./ 其/ 原因/ 是/ 通过/ 使用/ 静态/ 分析/ 的/ 结果/ 和/ 可达性/ 信息/ ,/ 程序/ 中/ 的/ 部分/ 路径/ 不再/ 需要/ 进行/ 测试/ ,/ 从而/ 节省/ 了/ 测试/ 时间/ ./ 600485/ 数/ ;/ 成功/ 生成/ 次数/ 列/ 给出/ 了/ 两个/ 工具/ 成功/ 生成/ 测试/ 输入/ 的/ 次数/ ,/ 即/ 约束/ 求解/ 器/ 成功/ 解/ 出/ 路径/ 条件/ 的/ 次数/ ,/ 也/ 即/ 是/ 运行/ 待/ 测试程序/ 的/ 次数/ ;/ 时间/ 列/ 给出/ 了/ 测试/ 过程/ 中/ 在/ 生成/ 测试/ 输入/ 上/ 所/ 消耗/ 的/ 时间/ ./ 成/ 测试/ 输入/ 的/ 次数/ 不到/ SPLAT/ 技术/ 的/ 1/ // 6/ ,/ 所/ 消耗/ 的/ 时间/ 约/ 为/ SPLAT/ 技术/ 的/ 1/ // 40/ ./ 其/ 原因/ 是/ 通过/ 使用/ 静态/ 分析/ 的/ 结果/ 和/ 程序/ 的/ 结构/ 信息/ ,/ 程序/ 中/ 的/ 部/ Page9/ 分/ 路径/ 不再/ 需要/ 动态/ 检查/ ,/ 也/ 就/ 不/ 需要/ 生成/ 相应/ 的/ 测试/ 输入/ ,/ 从而/ 极大/ 地/ 节省/ 了/ 生成/ 测试/ 输入/ 的/ 时间/ ./ 值得注意/ 的/ 是/ 在/ Sendmail/ -/ 2/ 基准/ 程序/ 中/ ,/ TARGET/ 尝试/ 生成/ 测试/ 输入/ 的/ 次数/ 更/ 多/ ./ 这是/ 由于/ 错误/ 的/ 关联性/ 所/ 引起/ 的/ ,/ 对/ 一个/ 错误/ 的/ 修正/ 可能/ 会/ 导致/ 程序/ 路径/ 的/ 减少/ 、/ 其它/ 错误/ 被/ 隐藏/ 等/ 情况/ 发生/ ./ 该/ 实例/ 中/ 正是/ 出现/ 了/ 这样/ 的/ 情况/ ,/ 对/ 其中/ 一个/ 错误/ 的/ 修改/ 导致/ 路径/ 大量/ 缩减/ ,/ 而/ TARGET/ 是/ 在/ 原来/ 未经/ 修改/ 的/ 程序/ 上/ 进行/ 测试/ 的/ ,/ 所/ 需要/ 覆盖/ 的/ 路径/ 数/ 更/ 多/ ,/ 所以/ 尝试/ 生成/ 覆盖/ 这些/ 路径/ 的/ 测试/ 输入/ 表/ 6/ 动态/ 缺陷/ 检测/ 开销/ 89932951913653/ 基准/ 程序/ WuFTP/ -/ 1Sendmail/ -/ 2gzip/ -/ 1.2/ ./ 4/ 从表/ 6/ 中/ 可以/ 看出/ ,/ TARGET/ 测试/ 过程/ 中/ 需要/ 进行/ 检测/ 的/ 可疑/ 语句/ 数约/ 为/ SPLAT/ 技术/ 的/ 1/ // 3/ ,/ 动态/ 检查/ 的/ 次数/ 不到/ SPLAT/ 技术/ 的/ 1/ // 20/ ,/ 所/ 消耗/ 的/ 时间/ 不到/ SPLAT/ 技术/ 的/ 1/ // 40/ ./ 其/ 原因/ 是/ 由于/ SPLAT/ 技术/ 未/ 使用/ 静态/ 分析/ 的/ 信息/ ,/ 因此/ 需要/ 检查程序/ 中/ 所有/ 涉及/ 缓冲区/ 修改/ 的/ 语句/ ,/ 而/ TARGET/ 仅/ 需/ 检查/ 静态/ 分析/ 工具/ 所/ 报告/ 的/ 待/ 检测/ 缺陷/ 所在/ 语句/ ,/ 因而/ SPLAT/ 技术/ 动态/ 检测/ 缺陷/ 的/ 次数/ 和/ 时间/ 开销/ 均/ 远高于/ TARGET/ ./ 5.4/ 讨论/ 从/ 上面/ 3/ 个/ 表格/ 中/ 可以/ 看出/ ,/ 与/ 原有/ 的/ 混合/ 执行/ 测试/ 技术/ 相/ 比较/ ,/ TARGET/ 有效/ 降低/ 了/ 测试/ 生成/ 、/ 缺陷/ 检测/ 及/ 总/ 测试/ 时间/ 的/ 开销/ ,/ 并/ 能/ 发现/ 程序/ 中/ 的/ 更/ 多/ 缺陷/ ./ 目前/ TARGET/ 仅/ 支持/ 检测/ C语言/ 中/ 的/ 缓冲区/ 溢出/ 缺陷/ ,/ 但本/ 方法/ 能/ 通过/ 增加/ 缺陷/ 模型/ 和/ 扩充/ 插装/ 函数库/ 的/ 方式/ ,/ 方便/ 地/ 扩展/ 到/ 支持/ 检测/ 多种/ 程序/ 缺陷/ ,/ 如/ 整形/ 数/ 溢出/ 、/ 内存/ 溢出/ 等/ ./ 另外/ ,/ 静态/ 分析/ 结果/ 的/ 精确度/ 将会/ 对/ 本/ 方法/ 产生/ 影响/ :/ 误报/ 会/ 增加/ 动态/ 测试/ 的/ 开销/ ,/ 而/ 漏报/ 则/ 会/ 导致/ 动态/ 测试/ 时/ 不/ 对/ 漏报/ 的/ 可疑/ 语句/ 进行/ 检测/ ,/ 从而/ 不能/ 检测/ 到/ 缺陷/ ./ 因此/ ,/ 高精度/ 的/ 静态/ 分析/ 结果/ 能/ 进一步提高/ 本/ 方法/ 的/ 效果/ ./ 6/ 相关/ 工作/ 讨论/ 软件缺陷/ 的/ 检测/ 技术/ 一般/ 可/ 分为/ 静态/ 和/ 动态/ 两类/ ,/ 部分/ 动态/ 缺陷/ 检测/ 技术/ ,/ 如/ ProPolice/ ①/ 和/ 的/ 次数/ 更/ 多/ ./ 从表/ 5/ 中/ 我们/ 还/ 可以/ 看出/ ,/ 测试/ 输入/ 生成/ 开销/ 的/ 主要/ 因素/ 是/ 成功/ 生成/ 测试/ 输入/ 的/ 次数/ ,/ 而/ 不是/ 尝试/ 生成/ 测试/ 输入/ 的/ 次数/ ./ 5.3/ ./ 3/ 缺陷/ 检测/ 开销/ 表/ 6/ 中/ 比较/ 了/ 动态/ 检测/ 待/ 确认/ 缺陷/ 的/ 开销/ ./ 可疑/ 语句/ 数列/ 给出/ 了/ 动态/ 测试/ 过程/ 中/ 需要/ 进行/ 检测/ 的/ 语句/ 数/ ;/ 动态/ 检查/ 次数/ 列/ 给出/ 了/ 在/ 测试/ 过程/ 中/ 检查/ 可疑/ 语句/ 中/ 缺陷/ 是否/ 可能/ 会/ 被/ 触发/ 的/ 次数/ ;/ 时间/ 列则/ 给出/ 了/ 测试/ 过程/ 中/ 在/ 检查/ 可疑/ 语句/ 中/ 缺陷/ 是否/ 会/ 被/ 触发/ 所/ 消耗/ 的/ 时间/ ./ CRED/ [/ 17/ ]/ 采用/ 的/ 方法/ 不是/ 生成/ 触发/ 软件缺陷/ 的/ 测试用例/ ,/ 而是/ 致力于/ 如何/ 有效/ 地/ 插装/ 源程序/ 以/ 通过/ 运行/ 时/ 监控/ 的/ 方式/ 检测/ 错误/ 的/ 发生/ ./ 在/ 本节/ 中/ ,/ 我们/ 主要/ 讨论/ 缓冲区/ 溢出/ 的/ 测试/ 生成/ 技术/ 和/ 静/ 动态/ 结合/ 的/ 软件缺陷/ 检测/ 技术/ ./ 首先/ 讨论/ 缓冲区/ 溢出/ 的/ 测试/ 生成/ 技术/ ./ Grosso/ 等/ [/ 18/ ]/ 使用/ 遗传算法/ 为/ 函数调用/ 生成/ 输入/ 来/ 发现/ 缓冲区/ 溢出/ ./ Shahriar/ 等/ [/ 19/ ]/ 针对/ 缓冲区/ 溢出/ 这/ 类/ 缺陷/ 提出/ 了/ 一组/ 变异/ 操作符/ ,/ 其/ 主要用途/ 是/ 评估/ 测试/ 集/ 的/ 充分/ 度/ ./ 基于/ DART/ [/ 6/ ]/ ,/ Xu/ 等/ [/ 10/ ]/ 提出/ 了/ 一种/ 缓冲区/ 溢出/ 测试/ 技术/ :/ SPLAT/ ,/ 其/ 主要/ 贡献/ 是/ 提出/ 仅为/ 缓冲区/ 的/ 一段/ 前缀/ 而/ 不是/ 整个/ 缓冲区/ 进行/ 符号化/ 建模/ ,/ 从而/ 提高/ 该/ 方法/ 的/ 可扩展性/ ./ 该/ 方法/ 与/ 其它/ 的/ 混合/ 执行/ 测试/ 技术/ 一样/ ,/ 无差别/ 地/ 对待/ 程序/ 中/ 的/ 所有/ 路径/ ,/ 并/ 尽可能/ 多地/ 遍历/ 程序/ 路径/ ./ 与/ 之/ 相比/ ,/ 我们/ 的/ 方法/ 利用/ 静态/ 分析/ 的/ 结果/ 来/ 减少/ 测试/ 过程/ 中/ 需要/ 遍历/ 的/ 路径/ ,/ 并/ 减少/ 需要/ 在/ 运行/ 时/ 检查/ 的/ 可疑/ 语句/ ,/ 从而/ 降低/ 了/ 测试/ 的/ 开销/ ,/ 提高/ 了/ 可扩展性/ ./ 同时/ ,/ 我们/ 的/ 方法/ 也/ 借鉴/ 了/ SPLAT/ 仅为/ 缓冲区/ 的/ 一段/ 前缀/ 进行/ 符号化/ 建模/ 的/ 思想/ ,/ 进一步提高/ 了/ 可扩展性/ ./ 另/ 一个/ 相关/ 的/ 领域/ 是/ 静/ 动态/ 结合/ 的/ 测试/ 技术/ ./ Aggarwal/ 等/ [/ 20/ ]/ 使用/ BOON/ [/ 13/ ]/ 的/ 静态/ 分析/ 结果/ ,/ 减少/ 了/ 需要/ 测试/ 的/ 缓冲区/ 溢出/ 的/ 数量/ ,/ 从而/ 减少/ 了/ 生成/ 的/ 测试用例/ ./ 与/ 我们/ 的/ 方法/ 最为/ 相似/ 的/ 是/ Christoph/ 等/ 提出/ 的/ Check/ ‘/ n/ ’/ Crash/ [/ 21/ ]/ 和/ DSD/ -/ Crasher/ [/ 22/ ]/ ./ ①/ Gccextensionforprotectingapplicationsfromstacksmash/ -/ ingattacks/ ,/ http/ :/ // // www/ ./ trl/ ./ ibm/ ./ com/ // projects/ // security/ // Page10Check/ ‘/ n/ ’/ Crash/ 使用/ ESC/ // JAVA/ [/ 23/ ]/ 分析/ JAVA/ 程序/ 中/ 函数/ 的/ 前置条件/ ,/ 并/ 在/ 所/ 计算/ 出/ 的/ 前置条件/ 的/ 基础/ 上/ 生成/ 测试用例/ ./ 由于/ 该/ 技术/ 中/ 所/ 使用/ 的/ 静态/ 分析/ 是/ 过程/ 内/ 的/ ,/ 因此/ 所/ 检测/ 到/ 的/ 程序/ 缺陷/ 很/ 有/ 可能/ 为/ 误报/ ./ 为/ 解决/ 这一/ 问题/ ,/ DSD/ -/ Crasher/ 提出/ 首先/ 执行/ 测试用例/ 并/ 通过/ Daikon/ [/ 24/ ]/ 收集/ 程序/ 中/ 的/ 不变式/ ,/ 获取/ 过程/ 间/ 的/ 约束条件/ ,/ 从而/ 在/ 一定/ 程度/ 上/ 降低/ 误报率/ ./ 然而/ ,/ Daikon/ 所/ 收集/ 到/ 的/ 不变式/ 所/ 描述/ 的/ 是/ 系统/ 在/ 正常/ 使用/ 的/ 情况/ 下/ 可能/ 满足/ 的/ 不变式/ ,/ 而/ 安全/ 缺陷/ 往往/ 是/ 系统/ 在/ 异常/ 的/ 使用/ 方式/ 下/ 才/ 会/ 被/ 触发/ 的/ ,/ 另外/ ,/ Daikon/ 所/ 生成/ 的/ 不变式/ 是/ 不/ 精确/ 的/ ,/ 所以/ 该/ 方法/ 仍然/ 会/ 有/ 一定/ 的/ 误报率/ ./ 同时/ ,/ 该/ 方法/ 还/ 需要/ 一组/ 较为/ 充分/ 的/ 测试用例/ 集/ ,/ 这/ 在/ 大多数/ 情况/ 下/ 是/ 难以/ 获取/ 的/ ./ 与/ 之/ 相比/ ,/ 我们/ 的/ 方法/ 使用/ 静态/ 分析/ 结果/ 和/ 程序结构/ 信息/ 指导/ 自动/ 地/ 生成/ 测试/ 输入/ ,/ 触发/ 并/ 确认/ 真正/ 的/ 缺陷/ ,/ 从而/ 避免/ 产生/ 误报/ ./ 7/ 结论/ 针对/ 现有/ 的/ 混合/ 执行/ 测试/ 技术/ 在/ 遍历/ 程序/ 路径/ 和/ 输入/ 空间/ 时/ 缺乏/ 指导/ ,/ 导致/ 生成/ 和/ 执行/ 不能/ 覆盖/ 潜在/ 缺陷/ 语句/ 的/ 测试/ 输入/ 耗费/ 了/ 大量/ 测试/ 开销/ 的/ 问题/ ,/ 本文/ 提出/ 了/ 一种/ 基于/ 静态/ 分析/ 结果/ 的/ 目标/ 制导/ 的/ 混合/ 执行/ 测试方法/ :/ 使用/ 静态/ 分析/ 工具/ 分析/ 待测/ 程序/ 中/ 可能/ 含有/ 缺陷/ 的/ 可疑/ 语句/ 及其/ 缺陷/ 类型/ ,/ 并/ 作为/ 目标/ 指导/ 测试/ ./ 混合/ 执行/ 测试方法/ 由/ 3/ 个/ 步骤/ 组成/ :/ 可达性/ 分析/ 、/ 程序/ 插装/ 和/ 动态/ 测试/ ./ 基于/ 该/ 方法/ 我们/ 实现/ 了/ 一项/ 针对/ C语言/ 缓冲区/ 溢出/ 缺陷/ 的/ 原型/ 测试工具/ :/ TARGET/ ,/ 并/ 在/ 一组/ C语言/ 基准/ 程序/ 上/ 进行/ 了/ 实例/ 研究/ ./ 实验/ 结果表明/ 与/ 原有/ 的/ 混合/ 执行/ 测试方法/ 相/ 比较/ ,/ 使用/ 静态/ 分析/ 信息/ 能/ 有效/ 地/ 降低/ 测试/ 开销/ ./ 在/ 本文/ 研究/ 的/ 基础/ 上/ ,/ 我们/ 计划/ 将/ 该/ 方法/ 用于/ 测试/ 更/ 多/ 类型/ 的/ 程序/ 缺陷/ ,/ 同时/ ,/ 我们/ 还/ 计划/ 使用/ 更/ 多/ 的/ 静态/ 分析/ 信息/ 来/ 进一步/ 降低/ 测试/ 开销/ ./ 致谢/ 本文/ 的/ 部分/ 工作/ 是/ 第一/ 作者/ 在/ ComputerScienceDepartment/ ,/ UniversityofVirginia/ ,/ USA/ 进行/ 学术/ 访问期间/ 完成/ 的/ ./ MaryLouSoffa/ 教授/ 和/ WeiLe/ 博士/ 为/ 本项/ 工作/ 的/ 完成/ 提供/ 了/ 宝贵/ 的/ 意见/ ,/ 特别/ 是/ 对/ 静态/ 分析/ 工具/ Marple/ 的/ 使用/ 提供/ 了/ 大量/ 的/ 帮助/ ,/ 在/ 此/ 表示/ 衷心/ 的/ 感谢/ !/ 

