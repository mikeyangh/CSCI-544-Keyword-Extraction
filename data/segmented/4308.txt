Page1/ 一个/ 支持/ 访存/ 带宽/ 敏感/ 调度/ 的/ 跨/ 执行/ 优化/ 方法/ 徐地/ 武成/ 岗/ 冯晓兵/ (/ 中国科学院计算技术研究所/ 计算机/ 体系结构/ 国家/ 重点/ 实验室/ 北京/ 100190/ )/ 摘要/ 片/ 外访/ 存/ 带宽/ 是/ 共享/ 存储/ 多核/ 系统/ 的/ 主要/ 性能/ 瓶颈/ ./ 访存/ 带宽/ 敏感/ 的/ 任务调度/ 可以/ 有效/ 缓解/ 并发程序/ 间/ 的/ 访存/ 竞争/ ,/ 提高/ 系统/ 吞吐/ 率/ ./ 然而/ 调度/ 策略/ 的/ 实施/ 需要/ 关于/ 程序执行/ 的/ 先验/ 知识/ ,/ 给/ 系统/ 用户/ 增加/ 了/ 额外负担/ ;/ 另一方面/ ,/ 并发程序/ 间/ 的/ 带宽/ 竞争/ 使得/ 运行/ 时/ 收集/ 的/ 程序/ 带宽/ 需求/ 信息/ 不/ 精确/ ,/ 影响/ 了/ 调度/ 效果/ ./ 在/ 该文/ 中/ ,/ 作者/ 提出/ 了/ 一个/ 低/ 开销/ 、/ 对/ 用户/ 透明/ 的/ 跨/ 执行/ 优化/ 方法/ 解决/ 上述/ 问题/ ./ 它/ 在/ 运行/ 时/ 识别/ 程序/ 的/ 阶段性/ (/ phase/ )/ 行为/ ,/ 并/ 估算/ 每个/ phase/ 的/ 独占/ 执行/ 性能/ ;/ 上述/ 信息/ 被/ 存储/ 到/ 数据库/ 中/ ,/ 在/ 程序/ 未来/ 的/ 执行/ 中/ 指导/ 调度/ ,/ 并且/ 信息/ 精度/ 随着/ 程序/ 的/ 多次/ 执行/ 持续/ 增加/ ./ 上述/ 过程/ 使得/ 带宽/ 敏感/ 调度/ 策略/ 的/ 进行/ 不再/ 需要/ 任何/ 用户/ 信息/ 制导/ ,/ 并且/ 优化/ 了/ 调度/ 效果/ ./ 作者/ 在/ 基于/ IntelXeon/ 处理器/ 的/ 8/ 核/ 系统/ 上/ 实现/ 并/ 评估/ 了/ 该/ 系统/ ,/ 测试/ 结果表明/ :/ 相对/ 于/ Linux/ 操作系统/ (/ OS/ )/ 默认/ 的/ 调度/ 策略/ ,/ 该文/ 的/ 方法/ 能/ 平均/ 提高/ 系统/ 吞吐/ 率/ 3.7/ %/ ,/ 对于/ 某些/ 特定/ 程序/ 组达/ 8.5/ %/ ./ 关键词/ 进程/ 调度/ ;/ 访存/ 带宽/ ;/ 总线/ 竞争/ ;/ 跨/ 执行/ 优化/ 1/ 引言/ 随着/ 制造/ 工艺/ 、/ 功能/ 复杂度/ 、/ 散热/ 、/ 能耗/ 等/ 因素/ 限制/ ,/ 计算机/ 已经/ 转入/ 了/ 多处理器/ 、/ 多核/ 的/ 时代/ ./ 共享/ 存储/ 的/ 多/ 核/ 系统/ 作为/ 一种/ 高效/ 的/ 构建/ 并行计算/ 系统/ ,/ 在/ 高端/ 服务器/ 、/ 个人电脑/ 、/ 嵌入式/ 系统/ ,/ 甚至/ 移动/ 计算/ 设备/ 中/ 都/ 有/ 广泛/ 的/ 应用/ ①/ ./ 在/ 这类/ 系统/ 上/ ,/ 片/ 外访/ 存/ 总线/ 被/ 多个/ 处理器/ // 处理器/ 核/ 共享/ 争用/ ,/ 导致/ 访存/ 延迟/ 增大/ ,/ 从而/ 成为/ 一个/ 重大/ 的/ 性能/ 瓶颈/ [/ 1/ ]/ ./ 目前/ 工业界/ 的/ 趋势/ 是/ 将/ 越来越/ 多/ 的/ 处理/ 核/ 集成/ 到/ 一个/ 处理器/ 上/ [/ 2/ ]/ ,/ 而/ 总线/ 带宽/ 由于/ 受到/ 封装/ 和/ 工作频率/ 限制/ ,/ 已经/ 接近/ 了/ 实际/ 极限/ [/ 3/ ]/ ./ 因此/ ,/ 访存/ 带宽/ 将/ 持续/ 成为/ 制约/ 并行/ 系统/ 性能/ 的/ 重要/ 因素/ ./ 当/ 系统/ 中/ 并发程序/ 数/ 超过/ 可用/ 的/ 处理器/ 核数/ 时/ ,/ 相关/ 工作/ 提出/ 了/ 访存/ 带宽/ 敏感/ 的/ 调度/ 策略/ [/ 4/ -/ 8/ ]/ ,/ 它/ 根据/ 每个/ 程序/ 各自/ 的/ 带宽/ 需求/ 选择/ 合适/ 的/ 程序/ 并发/ ,/ 以/ 缓解/ 它们/ 对/ 访存/ 带宽/ 的/ 竞争/ ./ 作者/ 本人/ 已/ 在/ 先前/ 的/ 工作/ [/ 9/ ]/ 中/ 定量/ 研究/ 了/ 程序/ 带宽/ 需求/ 波动/ 对/ 并发程序/ 性能/ 的/ 影响/ ,/ 并/ 提出/ 了/ 一个/ 新/ 的/ 带宽/ 敏感/ 调度/ 原则/ :/ 如果/ 每个/ 调度/ 时间/ 片内/ 并发程序/ 的/ 总/ 带宽/ 需求/ 都/ 保持/ 为/ 程序/ 组/ 的/ 平均/ 带宽/ 需求/ ,/ 那么/ 程序/ 组所/ 遭受/ 到/ 的/ 性能/ 下降/ 幅度/ 将/ 最小/ ./ 上述/ 策略/ 能/ 更/ 有效/ 的/ 提高/ 系统/ 吞吐/ 率/ ,/ 然而/ 它/ 需要/ 用户/ 提供/ 程序执行/ 的/ 先验/ 知识/ ,/ 以便/ 在/ 程序/ 组/ 执行/ 前/ 估算/ 其/ 平均/ 带宽/ 需求/ ,/ 这/ 给/ 系统/ 用户/ 提出/ 了/ 额外/ 的/ 要求/ ,/ 影响/ 了/ 策略/ 的/ 实用性/ ./ 另一方面/ ,/ 大多数/ 策略/ 使用/ 处理器/ 的/ 性能/ 计数器/ (/ PerformanceMonitoringUnit/ ,/ PMU/ )/ ,/ 在/ 运行/ 时/ 监测/ 程序/ 的/ 带宽/ 使用量/ 变化/ ,/ 然后/ 预测出/ 它/ 在/ 未来/ 时间/ 片内/ 的/ 带宽/ 需求/ ./ 然而/ 由于/ 带宽/ 竞争/ 的/ 存在/ ,/ 在/ 运行/ 时/ 直接/ 获得/ 的/ 程序/ 带宽/ 使用量/ 通常/ 会/ 小于/ 它/ 的/ 实际/ 需求/ ,/ 并且/ 下降/ 比率/ 不可/ 预测/ ./ 这/ 使得/ 程序/ 带宽/ 需求预测/ 的/ 精度/ 较/ 低/ ,/ 影响/ 了/ 调度/ 效果/ ./ 针对/ 上述/ 问题/ ,/ 本文/ 提出/ 了/ 一个/ 基于/ 跨/ 执行/ 的/ 优化/ 方法/ ,/ 用以/ 支持/ 带宽/ 敏感/ 调度/ 策略/ 的/ 进行/ ./ 该/ 方法/ 利用/ 了/ 程序执行/ 过程/ 中/ 的/ 阶段性/ 行为/ (/ 称为/ 程序/ phase/ )/ ,/ 在/ 程序/ 的/ 多次/ 执行/ 中/ 不断/ 收集/ 其/ 包含/ 的/ phase/ ,/ 并/ 估算/ 每个/ phase/ 的/ 独占/ 执行/ 信息/ ,/ 存放/ 到/ 数据库/ 中/ ./ 在/ 程序/ 的/ 未来/ 执行/ 中/ ,/ 使用/ 数据库/ 中/ 的/ 信息/ 能/ 更/ 准确/ 的/ 预测/ 程序/ 的/ 带宽/ 需求/ ;/ 同时/ ,/ 我们/ 结合/ phase/ 出现/ 的/ 频度/ ,/ 估算/ 出/ 程序/ 在/ 特定/ 输入/ 集下/ 的/ 整体/ 独占/ 执行/ 时间/ 和/ 主存/ 访问量/ ,/ 最终/ 能/ 在/ 一个/ 程序/ 组/ 执行/ 前/ 估算/ 出/ 它/ 的/ 平均/ 带宽/ 需求/ 指导/ 调度/ ./ 上述/ 步骤/ 无需/ 用户/ 干预/ ,/ 能够/ 自动/ 进行/ ./ 本文/ 的/ 实验/ 在/ 基于/ Intel/ 处理器/ 的/ 8/ 核/ 系统/ 上/ 进行/ ,/ 测试/ 结果表明/ ,/ 相对/ 于/ 操作系统/ (/ OS/ )/ 默认/ 的/ 调度/ 策略/ ,/ 本文/ 提出/ 的/ 方法/ 可以/ 获得/ 平均/ 3.7/ %/ 的/ 系统/ 吞吐/ 率/ 提升/ ,/ 对/ 某些/ 程序/ 组可达/ 8.5/ %/ ./ 与/ 文献/ [/ 9/ ]/ 提出/ 的/ 方法/ 相比/ ,/ 本文/ 的/ 工作/ 使得/ 带宽/ 敏感/ 调度/ 不再/ 需要/ 任何/ 用户/ 制导/ 信息/ 和/ 离线/ 训练/ ,/ 并且/ 调度/ 效果/ 也/ 获得/ 了/ 提升/ ./ 本文/ 的/ 贡献/ 包括/ :/ (/ 1/ )/ 提出/ 了/ 一个/ 支持/ 带宽/ 敏感/ 调度/ 的/ 跨/ 执行/ 持续/ 优化/ 方案/ ,/ 对/ 用户/ 透明/ ,/ 并且/ 提升/ 了/ 带宽/ 调度/ 策略/ 的/ 效果/ ./ (/ 2/ )/ 使用/ 运行/ 时/ 独占/ 性能/ 估算/ 技术/ ,/ 解决/ 了/ 带宽/ 需求预测/ 以及/ 程序/ 整体/ 执行/ 时间/ 估算/ 的/ 问题/ ./ (/ 3/ )/ 通过/ 实验/ 讨论/ 了/ 共享/ cache/ 竞争/ 对/ 带宽/ 敏感/ 调度/ 策略/ 的/ 影响/ ./ 比较/ 了/ 不同/ 信息/ 获取/ 方法/ 对/ 调度/ 性能/ 的/ 影响/ ./ 本文/ 第/ 2/ 节/ 介绍/ 研究/ 背景/ 和/ 动机/ ;/ 第/ 3/ 节/ 介绍/ 跨/ 执行/ 优化/ 方法/ 设计/ 以及/ 其中/ 关键问题/ 和/ 解决/ 方法/ ;/ 第/ 4/ 节/ 介绍/ 系统/ 实现/ ;/ 在/ 第/ 5/ 节/ 进行/ 测试/ 和/ 结果/ 分析/ ;/ 第/ 6/ 节/ 总结/ 全文/ ./ 2/ 研究/ 背景/ 和/ 相关/ 工作/ 2.1/ 访存/ 带宽/ 敏感/ 的/ 任务调度/ 带宽/ 敏感/ 调度/ 策略/ 可以/ 有效/ 缓解/ 访存/ 带宽/ 竞争/ ,/ 且/ 相对/ 容易/ 实现/ ,/ 不/ 需要/ 特殊/ 硬件/ 支持/ ,/ 已有/ 很多/ 相关/ 工作/ 对/ 其/ 做/ 了/ 研究/ [/ 4/ -/ 8/ ]/ ./ 这些/ 策略/ 的/ 共同/ 基本/ 思想/ 是/ ,/ 在/ 每个/ 调度/ 时间/ 片内/ 选择/ 合适/ 的/ 程序/ 并发/ ,/ 使得/ 它们/ 的/ 带宽/ 需求/ 之/ 和/ 恰好/ 等于/ 系统/ 的/ 实际/ 峰值/ ,/ 其/ 动机/ 是/ 既/ 不/ 造成/ 总线/ 饱和/ 也/ 不/ 浪费/ 可用/ 带宽/ ,/ 提高/ 系统/ 吞吐/ 率/ ./ 然而/ 我们/ 在/ 工作/ [/ 9/ ]/ 中/ 发现/ ,/ 实际/ 程序/ 的/ 访存/ 带宽/ 需求/ 在/ 远/ 小于/ 调度/ 时间/ 片/ 的/ 粒度/ 上/ 剧烈/ 波动/ ,/ 即使/ 并发程序/ 在/ 时间/ 片内/ 的/ 平均/ 带宽/ 需求/ 之/ 和/ 小于/ 系统/ 峰值/ ,/ 它们/ 内部/ 仍然/ 会/ 造成/ 明显/ 的/ 带宽/ 竞争/ ,/ 导致/ 性能/ 下降/ ./ 通过/ 进一步/ 的/ 测试/ ,/ 作者/ 发现/ 了/ 一个/ 带宽/ 竞争/ 的/ 基本规律/ :/ 当/ 并发程序/ 总/ 的/ 带宽/ 使用量/ 线性/ 提高/ 时/ ,/ 竞争/ 导致/ 的/ 性能/ 下降/ 会超/ 线性/ 增加/ ./ 最后/ 通过/ 数学/ 证明/ 得到/ 了/ 新/ 的/ 带宽/ 调度/ 原则/ :/ 对/ 一个/ 程序/ 组/ ,/ 如果/ 它/ 的/ 每个/ 执行/ 时间/ 片内/ 并发程序/ 的/ 带宽/ 需求/ 之/ 和/ ①/ TheNVIDIATegra2mobileprocessor/ ./ http/ :/ // // www/ ./ Page3/ 都/ 等于/ 程序/ 组/ 的/ 平均/ 带宽/ 需求/ ,/ 或者说/ ,/ 程序/ 组/ 造成/ 的/ 访存/ 带宽/ 压力/ 在/ 所有/ 时间/ 片中/ 均匀分布/ ,/ 那么/ 该/ 程序/ 组所/ 遭受/ 的/ 性能/ 损失/ 将/ 最小/ ./ 为了/ 实现/ 上述/ 调度/ 思想/ ,/ 需要/ 在/ 程序/ 组/ 执行/ 前/ 估算/ 它/ 的/ 平均/ 带宽/ 需求/ ./ 假设/ 系统/ 中有/ C/ 个/ 处理器/ 核/ ,/ 有/ N/ 个/ 程序/ 并行执行/ (/ N/ >/ C/ )/ ./ 对/ 一个/ 程序/ j/ ,/ 它/ 的/ 独占/ 执行/ 时间/ 为/ Tj/ ,/ 主存/ 访问/ 数为/ Mj/ ./ 则/ 该/ 程序/ 组/ 的/ 主存/ 访问/ 总数/ 为/ 然后/ ,/ 我们/ 假设/ 该/ 程序/ 组/ 的/ 执行/ 不会/ 因为/ 带宽/ 竞争/ 带来/ 任何/ 性能/ 下降/ ,/ 从而/ 估算/ 出/ 它/ 的/ 理想/ 执行/ 时间/ IdealTurnaroundTime/ =/ ∑/ N/ -/ C/ 其中/ Tni/ (/ 1/ / i/ / N/ )/ 是/ 把/ 所有/ 程序/ 按照/ 执行/ 时间/ 从/ 短/ 到/ 长/ 重新排列/ 后/ 获得/ 的/ 序列/ ./ 上述/ 公式/ 模拟/ 了/ 程序/ 组在/ 时间/ 片/ 轮训/ 策略/ 下/ 的/ 理想/ 执行/ 时间/ ./ 最后/ ,/ 程序/ 组/ 的/ 平均/ 带宽/ 需求/ (/ IdealAverageBandwidth/ ,/ IABW/ )/ 定义/ 为/ 程序/ 组中/ 包含/ 的/ 所有/ 主存/ 访问/ 数/ 除以/ 它/ 的/ 理想/ 执行/ 时间/ ./ 换句话说/ ,/ IABW/ 是/ 让/ 该/ 程序/ 组/ 达到/ 理想/ 执行/ 时间/ 所/ 需要/ 的/ 最小/ 带宽/ ,/ 因此/ 它/ 能/ 刻画/ 一个/ 程序/ 组对/ 访存/ 带宽/ 的/ 需求/ ./ IdealAverageBandwidth/ =/ TotalMemoryRequest/ 在/ 运行/ 时/ ,/ 调度/ 策略/ 会/ 预测出/ 程序/ 在/ 下/ 一个/ 时间/ 片/ 的/ 带宽/ 需求/ ,/ 在/ 调度/ 时/ 选择/ 合适/ 的/ 程序/ 并发/ ,/ 使得/ 它们/ 的/ 总/ 带宽/ 需求/ 恰好/ 等于/ 程序/ 组/ 的/ IABW/ ./ 2.2/ 新/ 带宽/ 敏感/ 调度/ 策略/ 引入/ 的/ 问题/ 需要/ 解决/ :/ 为了/ 实现/ 上述/ 调度/ 策略/ ,/ 有/ 两个/ 重要/ 的/ 问题/ 仍/ (/ 1/ )/ 为了/ 在/ 执行/ 前/ 计算/ 程序/ 组/ 的/ IABW/ ,/ 需要/ 获得/ 每个/ 程序/ 独占/ 执行/ 时间/ 和/ 平均/ 带宽/ 需求/ ,/ 这/ 需要/ 实现/ 对/ 程序/ 进行/ 独占/ 测试/ ,/ 或者/ 对/ 程序/ 的/ 执行/ 行为/ 有/ 较为/ 精确/ 的/ 预测/ ,/ 而且/ 程序/ 输入/ 集/ 的/ 变化/ 也/ 使/ 上述/ 信息/ 的/ 获取/ 更加/ 困难/ ./ 另一方面/ ,/ 受到/ 共享/ cache/ 的/ 影响/ ,/ 主存/ 访问/ 数量/ 和/ 独占/ 执行/ 相比/ 也/ 会/ 不可/ 预测/ 地/ 增多/ ./ (/ 2/ )/ 为了/ 预测/ 程序/ 在/ 下/ 一时间/ 片/ 的/ 带宽/ 需求/ ,/ 我们/ 需要/ 获得/ 程序/ 的/ 带宽/ 需求/ 历史/ ./ 然而/ 由于/ 程序/ 并发/ 时/ 存在/ 带宽/ 竞争/ ,/ 通过/ PMU/ 直接/ 获得/ 的/ 带宽/ 使用量/ 可能/ 远/ 小于/ 它/ 的/ 实际/ 需求/ (/ 即/ 程序/ 在/ 独占/ 执行/ 时/ 的/ 带宽/ )/ ./ 历史/ 信息/ 的/ 偏差/ 导致/ 程序/ 带宽/ 需求预测/ 误差/ 较大/ ,/ 误导/ 调度/ ./ 本文/ 提出/ 了/ 一个/ 对/ 用户/ 透明/ 的/ 跨/ 执行/ 优化/ 方法/ ,/ 来/ 解决/ 上述/ 问题/ ,/ 支持/ 带宽/ 敏感/ 调度/ 策略/ 的/ 进行/ ./ 2.3/ 相关/ 工作/ Tian/ 等/ 人/ 对/ 单线程/ 程序/ 跨/ 执行/ 优化/ 技术/ 进行/ 了/ 一系列/ 研究/ ./ 在/ 文献/ [/ 10/ ]/ 中/ 首先/ 讨论/ 了/ 如何/ 从/ 不同/ 的/ 程序/ 输入/ 集中/ 抽取/ 特征/ ,/ 使得/ 程序/ 在/ 同一个/ 特征/ 的/ 输入/ 集下/ 行为/ 相似/ ,/ 因此/ 可以/ 收集/ 程序/ 的/ 执行/ 历史/ 决定/ 较/ 好/ 的/ 动态/ 优化/ 选项/ ./ 但/ 该/ 工作/ 需要/ 为/ 程序/ 收集/ 多个/ 代表性/ 的/ 输入/ ,/ 并/ 通过/ 离线/ 学习/ 的/ 方法/ 获得/ 程序/ 输入/ 特征/ 和/ 优化/ 选项/ 之间/ 的/ 关系/ ./ 在/ 后续/ 工作/ [/ 11/ ]/ 中/ ,/ 他们/ 设计/ 了/ 一个/ 对/ 用户/ 透明/ 的/ 跨/ 执行/ 优化/ 框架/ ,/ 自动/ 进行/ 上面/ 的/ 工作/ ,/ 并/ 主要/ 讨论/ 了/ 开销/ 控制/ 、/ 学习/ 算法/ 改进/ 等/ 关键问题/ ./ 上述/ 工作/ 针对/ 单个/ 程序/ 的/ 跨/ 执行/ 优化/ ,/ 收集/ 的/ 信息/ 是/ 程序/ 的/ 输入/ 特征/ ,/ 用来/ 指导/ 其/ 动态/ 优化/ 选项/ 的/ 确定/ ;/ 而/ 本文/ 针对/ 并发程序/ 的/ 优化/ ,/ 因此/ 收集/ 的/ 信息/ 是/ 程序/ 在/ 时间/ 片/ 粒度/ 上/ 的/ 阶段性/ 行为/ (/ phase/ )/ 和/ 性能/ 信息/ ,/ 优化/ 手段/ 是/ 程序/ 调度/ ,/ 提高/ 吞吐/ 率/ ./ 在/ 本文/ 的/ 跨/ 执行/ 优化/ 方法/ 中/ ,/ 需要/ 在/ 程序/ 并发/ 执行/ 时/ ,/ 估算/ 出/ 它/ 的/ 独占/ 执行/ 性能/ ./ 并发程序/ 对/ 共享/ 存储资源/ 的/ 竞争/ 使得/ 它们/ 的/ 并发/ 性能/ 变化/ 不可/ 预测/ ./ Mutlu/ 等/ 人/ 在/ 文献/ [/ 12/ -/ 13/ ]/ 中/ 对/ 内存/ 控制器/ 做出/ 改动/ ,/ 设计/ 了/ 复杂/ 的/ 硬件/ 计数器/ 和/ 触发/ 条件/ 来/ 估算/ 程序/ 独占/ 执行/ 时/ 的/ 内存/ 阻塞/ 时间/ ./ 然而/ 存储设备/ 的/ 工作/ 机制/ 非常复杂/ ,/ 并且/ 和/ 处理器/ 的/ 流水线/ 之间/ 存在/ 交互/ ,/ 因此/ 构建/ 一个/ 精确/ 的/ 性能/ 分析模型/ 仍然/ 是/ 非常/ 困难/ 的/ ./ 在/ 本文/ 中/ ,/ 我们/ 使用/ 了/ 一个/ 基于/ 程序/ 阶段性/ 行为/ (/ phase/ )/ 的/ 估算/ 方法/ ,/ 它/ 不/ 需要/ 特殊/ 硬件/ 支持/ ,/ 并且/ 实验/ 结果表明/ 具有/ 较/ 高/ 的/ 精度/ ./ 3/ 支持/ 带宽/ 敏感/ 调度/ 的/ 跨/ 执行/ 优化/ 图/ 1/ 给出/ 了/ 本文/ 的/ 跨/ 执行/ 优化/ 系统/ 总体设计/ ./ 为了/ 预测/ 程序/ 带宽/ 需求/ 以及/ 估算/ 程序/ 整体/ 独占/ 执行/ 时间/ ,/ 都/ 需要/ 在/ 程序/ 并发/ 执行/ 时反/ 推出/ 它/ 的/ 独占/ 执行/ 性能/ ./ 相关/ 研究/ 表明/ ,/ 程序/ 在/ 执行/ 过程/ 中/ ,/ 其/ 行为/ 会/ 发生/ 阶段性/ 的/ 变化/ 并且/ 重复/ 出现/ [/ 14/ -/ 15/ ]/ ,/ 表现/ 在/ 片/ 上/ cache/ 缺失/ 率/ 、/ 主存/ 访问/ 密度/ 以及/ IPC/ 等/ 多个/ 指标/ 上/ ./ 本文/ 利用/ 这一/ 规律/ ,/ 提出/ 了/ 一个/ 基于/ 程序/ 阶段性/ 行为/ (/ phase/ )/ 的/ 估算/ 方法/ ./ 首先/ 在/ 运行/ 时/ 通过/ phase/ 划分/ 技术/ 把/ 程序/ 在/ 一个/ 时间/ 片内/ 的/ 执行/ 识别/ 为/ 一个/ phase/ (/ 赋予/ 它/ 一个/ 唯一/ 的/ PhaseID/ )/ ,/ 而/ 不/ Page4/ 同/ 时间/ 片/ 的/ 执行/ 可能/ 属于/ 同一个/ phase/ ,/ 并且/ 它们/ 的/ 独占/ 执行/ 性能/ 相同/ 或/ 足够/ 相似/ ./ 只要/ 我们/ 知道/ 一个/ phase/ 中/ 某个/ 时间/ 片/ 的/ 独占/ 执行/ 性能/ ,/ 我们/ 就/ 获得/ 了/ 该/ phase/ 的/ 独占/ 执行/ 性能/ ./ 再/ 结合/ phase/ 预测/ 技术/ ,/ 就/ 可以/ 预测出/ 程序/ 在/ 下/ 一个/ 时间/ 片/ 的/ 带宽/ 需求/ ./ 怎样/ 获得/ 属于/ 某/ 特定/ phase/ 的/ 一个/ 时间/ 片/ 的/ 独占/ 执行/ 性能/ ?/ 直接/ 的/ 方法/ 是/ 通过/ 预测/ 得知/ 该/ phase/ 即将/ 出现/ (/ 即/ 程序/ 下/ 一个/ 时间/ 片/ 的/ 执行/ 会/ 是/ 该/ phase/ )/ ,/ 然后/ 临时/ 修正/ 调度/ 策略/ 让/ 该/ 程序/ 在/ 下个/ 时间/ 片中/ 独占/ 执行/ ,/ 然后/ 通过/ PMU/ 信息/ 获得/ 它/ 的/ 执行/ 性能/ ./ 然而/ ,/ 这个/ 方法/ 会/ 造成/ 处理器/ 空闲/ 和/ 开销/ ./ 实际上/ 我们/ 发现/ ,/ 即使/ 通常/ 情况/ 下/ 共享资源/ 竞争/ 带来/ 的/ 并发/ 性能/ 变化/ 是/ 不可/ 预测/ 的/ ,/ 但/ 至少/ 在/ 3/ 种/ “/ 低/ 竞争/ ”/ 执行/ 状态/ 下/ ,/ 一个/ 程序/ 的/ 并发/ 执行/ 性能/ 和/ 独占/ 执行/ 性能/ 相同/ (/ 或/ 足够/ 接近/ )/ ,/ 因此/ 我们/ 可以/ 在/ 避免/ 处理器/ 浪费/ 的/ 前提/ 下/ 获得/ 一个/ 时间/ 片/ 的/ 独占/ 执行/ 性能/ ./ 基于/ 上述/ 思想/ ,/ 在/ 程序运行/ 时/ ,/ 我们/ 根据/ PMU/ 获得/ 的/ 基本/ 信息/ ,/ 进行/ phase/ 识别/ 及其/ 独占/ 执行/ 性能/ 估算/ 工作/ ,/ 并/ 在/ 程序/ 结束/ 时/ 将/ 该/ 信息/ 更新/ 到/ 一个/ 数据库/ 中/ ./ 同时/ 我们/ 根据/ 程序/ 中/ 每个/ phase/ 的/ 出现/ 频度/ 及其/ 性能/ 信息/ 估算/ 出/ 整个/ 程序/ 的/ 独占/ 执行/ 时间/ ;/ 而/ 程序/ 的/ 主存/ 访问/ 数/ 也/ 可以/ 在/ 程序执行/ 结果/ 后/ 直接/ 获得/ ,/ 同时/ 还/ 包含/ 了/ 共享/ cache/ 的/ 影响/ ./ 对于/ 一个/ 未知/ 的/ 程序/ 组/ ,/ 如果/ 它/ 包含/ 的/ 每个/ 程序/ 在/ 数据库/ 中/ 都/ 有/ 相应/ 的/ 独占/ 执行/ 时间/ 和/ 主存/ 访问量/ 估算/ ,/ 那么/ 就/ 可以/ 估算/ 出/ 程序/ 组/ 的/ IABW/ ,/ 指导/ 调度/ ./ 上述/ 几个/ 步骤/ 互相支持/ ,/ 形成/ 了/ 一个/ 持续/ 进化/ 的/ 过程/ :/ 在/ 数据库/ 中/ 信息/ 的/ 帮助/ 下/ ,/ 带宽/ 敏感/ 调度/ 算法/ 可以/ 更/ 有效/ 的/ 缓解/ 带宽/ 竞争/ ,/ 加速/ 程序/ 组/ 的/ 执行/ ;/ 另一方面/ ,/ 通过/ 程序/ 组/ 的/ 多次/ 执行/ ,/ 更/ 精确/ 的/ 信息/ 被/ 收集/ 到/ 数据库/ 中/ ,/ 从而/ 服务/ 这些/ 程序/ 将来/ 的/ 执行/ ./ 在/ 下面/ 的/ 章节/ 中/ ,/ 我们/ 分别/ 介绍/ 上述/ 几个/ 关键技术/ ./ 3.1/ 访存/ 带宽/ 敏感/ 的/ 任务调度/ 在/ 作者/ 本人/ 尚未/ 发表/ 的/ 工作/ 中/ ,/ 我们/ 发现/ 了/ 并发程序/ 的/ 3/ 种/ “/ 低/ 竞争/ ”/ 执行/ 状态/ ,/ 并/ 利用/ 它/ 估算/ 程序/ 的/ 执行/ 进度/ ,/ 保证系统/ 的/ 性能/ 公平性/ 和/ 服务质量/ (/ QoS/ )/ ./ 在/ 本文/ 中/ ,/ 我们/ 提出/ 了/ 这个/ 观察/ 结论/ 的/ 另/ 一个/ 重要/ 用途/ :/ 程序/ 的/ 带宽/ 需求预测/ 以及/ 程序/ 整体/ 独占/ 时间/ 估算/ ,/ 以/ 支持/ 带宽/ 敏感/ 调度/ 策略/ 的/ 进行/ ,/ 提高/ 系统/ 吞吐/ 率/ ./ 在/ 本节/ 中/ ,/ 我们/ 结合实际/ 系统/ 测试/ 对/ “/ 低/ 竞争/ ”/ 执行/ 状态/ 做/ 简要/ 说明/ ./ 图/ 2/ 给出/ 了/ 测试/ 系统/ 的/ 框架图/ ,/ 该/ 系统/ 包含/ 两个/ IntelXeonE5410/ 四核/ 处理器/ ,/ 其中/ 每/ 两个/ 处理器/ 核/ 共享/ 最/ 外层/ 数据/ cache/ (/ LLC/ )/ ./ 我们/ 使用/ 总线/ 事务/ 速率/ (/ BusTransactionRate/ ,/ BTR/ )/ 来/ 度量/ 带宽/ ,/ 它/ 指/ 每/ 微秒/ 能够/ 传输/ 的/ cache/ 行/ 总数/ ./ 该/ 系统/ 可/ 提供/ 的/ 峰值/ 带宽/ 为/ 120trans/ ./ // usec/ ./ 我们/ 使用/ SPECCPU2006/ 测试/ 集在/ 该/ 系统/ 上/ 进行/ 了/ 随机/ 并发/ 测试/ ./ 我们/ 称/ 一个/ 程序/ 在/ 一个/ 时间/ 片内/ 的/ 执行/ 部分/ 为/ 一个/ 程序段/ ./ 测试/ 使用/ 的/ 观察/ 粒度/ 为/ 100ms/ ,/ 和/ Linux/ 默认/ 的/ 调度/ 时间/ 片/ 长度/ 相同/ ./ 对于/ 一个/ 程序段/ q/ ,/ 我们/ 使用/ PMU/ 获得/ 它/ 的/ 并发/ 执行/ 性能/ IPCq/ 及/ 它/ 所在/ 时间/ 片/ 的/ 系统/ 级/ 带宽/ 利用率/ (/ 即/ 所有/ 并发程序/ 的/ 带宽/ 利用率/ 之/ 和/ )/ ,/ 记为/ BTRq/ 程序段/ 并发/ 执行/ 性能/ 和/ BTRq/ 关系/ ,/ 我们/ 通过/ 事先/ 的/ profiling/ 工作/ ,/ 获得/ 该/ 程序段/ 的/ 独占/ 执行/ 性能/ IPCq/ 相对/ 性能/ :/ Speedq/ =/ IPCq/ 需要/ 注意/ 的/ 是/ ,/ 上述/ 基于/ profiling/ 获得/ 程序/ 独占/ 性能/ 的/ 方法/ 只是/ 为了/ 验证/ 3/ 个/ “/ 低/ 竞争/ ”/ 执行/ 状态/ 的/ 正确性/ ,/ 它/ 不是/ 本文/ 跨/ 执行/ 优化/ 方法/ 中/ 的/ 一部分/ ./ 在/ 本文/ 的/ 方法/ 中/ ,/ “/ 低/ 竞争/ ”/ 执行/ 态/ 的/ 识别/ 能/ 在/ 程序/ 并发/ 执行/ 时/ 自动/ 进行/ ,/ 无需/ 任何/ 事先/ 提供/ 的/ 信息/ 制导/ 或/ 其它/ 用户/ 干预/ ./ 图/ 3/ 给出/ 了/ 在/ 处理器/ 核/ 0/ ,/ 1/ ,/ 4/ ,/ 5/ 私有/ cache/ 模式/ 下/ 的/ 并发/ 测试/ 结果/ ,/ 数据/ 为/ 随机/ 选择/ 的/ 1000/ 个/ 程序段/ ,/ 具有/ 代表性/ ./ 实线/ 为/ 这些/ 数据/ 点/ 的/ 趋势/ 线/ ./ 上面/ 3/ 个子/ 图/ 分别/ 对应/ 了/ 3/ 种/ “/ 低/ 竞争/ ”/ 状态/ :/ Page5/ (/ 1/ )/ 一个/ 程序段/ 的/ 自身/ 带宽/ 需求/ 非常低/ ./ 图/ 3/ (/ a/ )/ 显示/ 出/ ,/ 随着/ 程序段/ 主存/ 访问/ 密度/ 的/ 增加/ ,/ 它/ 的/ 相对/ 性能/ 下降/ 幅度/ 也/ 慢慢/ 增大/ ./ 在/ 本文/ 中/ ,/ 我们/ 设置/ 一个/ 阈值/ BTRSelfLow/ 为/ 峰值/ 带宽/ 的/ 4/ %/ ,/ 如果/ 一个/ 程序段/ 的/ 带宽/ 使用/ 低于/ 这个/ 阈值/ ,/ 我们/ 就/ 可以/ 假设/ 它/ 的/ 并发/ 执行/ 性能/ 和/ 独占/ 执行/ 性能/ 非常/ 相似/ ./ (/ 2/ )/ 一个/ 程序段/ 的/ 自身/ 带宽/ 使用/ 超过/ 了/ BTRSelfLow/ ,/ 但是/ 它/ 执行/ 过程/ 中/ 的/ 系统/ 级/ 带宽/ 利用率/ 较/ 低/ ,/ 这/ 说明/ 它/ 所处/ 的/ 带宽/ 竞争/ 环境/ 相对/ 宽松/ ./ 图/ 3/ (/ b/ )/ 表明/ 当/ 系统/ 级/ 带宽/ 利用率/ 上升时/ ,/ 一个/ 程序段/ 遭受/ 的/ 性能/ 下降/ 也/ 有/ 增大/ 的/ 趋势/ ./ 如果/ 一个/ 时间/ 片/ 的/ 系统/ 带宽/ 利用率/ 小于/ 预设/ 的/ 阈值/ BTRSyswideLow/ (/ 实验/ 中/ 设置/ 为/ 峰值/ 带宽/ 的/ 1/ // 3/ )/ ,/ 那么/ 所有/ 并发程序/ 段/ 都/ 满足/ “/ 低/ 竞争/ ”/ 执行/ 状态/ ./ (/ 3/ )/ 系统/ 级/ 带宽/ 使用/ 超过/ 了/ BTRSyswideLow/ ,/ 但是/ 在/ 所有/ 并发程序/ 中/ ,/ 最/ 多/ 只有/ 一个/ 程序/ 是/ 访存/ 密集型/ 的/ (/ 即/ 它/ 的/ 带宽/ 使用/ 超过/ BTRSelfLow/ )/ ./ 其/ 动机/ 是/ ,/ 只有/ 当/ 系统/ 中/ 至少/ 存在/ 两个/ 访存/ 密集型/ 程序/ 时/ ,/ 他们/ 之间/ 才/ 会/ 发生/ 激烈/ 的/ 带宽/ 竞争/ ,/ 造成/ 严重/ 的/ 性能/ 下降/ ./ 图/ 3/ (/ c/ )/ 从/ 所有/ 测试数据/ 点中/ 筛选/ 出/ 了/ 属于/ 这种/ 情况/ 的/ 子集/ ,/ 可以/ 看到/ ,/ 使用/ 这个/ 规则/ 可以/ 有效/ 的/ 选择/ 出/ 那些/ 自身/ 带宽/ 需求/ 很/ 高/ 但是/ 仍然/ 没有/ 遭受/ 严重/ 性能/ 下降/ 的/ 执行/ 情况/ ./ 在/ 处理器/ 核/ 0/ ,/ 1/ ,/ 2/ ,/ 3/ 上/ 进行/ 的/ 四核/ 共享/ cache/ 测试/ 也/ 显示/ 了/ 同样/ 的/ 趋势/ ./ 相关/ 工作/ [/ 16/ ]/ 也/ 提出/ 共享/ cache/ 竞争/ 并/ 不是/ 造成/ 并发程序/ 性能/ 下降/ 的/ 主要/ 因素/ ;/ 主存/ 系统/ 部件/ ,/ 如访存/ 总线/ 、/ 预取/ 等/ 竞争/ 才/ 是/ 主要/ 的/ 因素/ ,/ 因此/ 在/ 共享/ cache/ 条件/ 下/ 上述/ 结论/ 仍然/ 成立/ ./ 3.2/ 程序/ phase/ 识别/ 和/ phase/ 性能/ 信息/ 维护/ 相关/ 工作/ 指出/ 程序/ 的/ 阶段性/ 变化/ 和/ 它/ 所/ 执行/ 的/ 代码/ 区间/ 密切相关/ [/ 15/ ,/ 17/ -/ 19/ ]/ ,/ 基于/ 基本块/ 向量/ (/ BasicBlockVector/ ,/ BBV/ )/ 的/ 方法/ 是/ 一种/ 很/ 有效/ 的/ phase/ 识别方法/ [/ 14/ ,/ 20/ -/ 21/ ]/ ./ 在/ 本文/ 中/ ,/ 我们/ 设计/ 和/ 实现/ 了/ 一个/ 基于/ BBV/ 的/ 运行/ 时/ phase/ 识别/ 技术/ ./ 我们/ 把/ 程序/ 的/ 一个/ 执行/ 时间/ 片/ 识别/ 为/ 一个/ phase/ ./ 在/ 程序/ 的/ 执行/ 过程/ 中/ ,/ 我们/ 使用/ PMU/ 对/ 程序执行/ 的/ 指令/ 地址/ (/ InstructionPointer/ ,/ IP/ )/ 进行/ 采样/ ./ BBV/ 的/ 每/ 一个/ 元素/ 对应/ 一个/ 程序/ 基本块/ ./ 每当/ 一个/ IP/ 采样/ 落到/ 一个/ 基本块/ 的/ 地址/ 范围/ 中/ ,/ 它/ 在/ BBV/ 中/ 对应/ 的/ 元素/ 自加/ 1/ ,/ 最后/ 对/ BBV/ 进行/ 归一化/ ./ 如果/ 两个/ 时间/ 片/ 形成/ 的/ BBV/ 的/ 曼哈顿/ 距离/ 小于/ BBV/ 相似/ 度/ 阈值/ ,/ 则/ 这/ 两个/ 时间/ 片/ 就/ 属于/ 同一个/ phase/ ./ 对/ 每/ 一个/ 程序/ ,/ 我们/ 维护/ 一个/ phase/ 信息/ 表来/ 记录/ 其/ 出现/ 的/ phase/ 及其/ 历史/ 执行/ 信息/ ./ 信息/ 表/ 的/ 最终/ 的/ 目的/ 是/ 估算/ 出/ 每个/ phase/ 的/ 独占/ 执行/ 性能/ ,/ 包括/ IPCphase/ 和/ 带宽/ BTRphase/ ./ 当/ 一个/ 程序/ 在/ 时间/ 片/ q/ 中/ 执行/ 结束/ ,/ 首先/ 根据/ 其/ IP/ 采样/ 进行/ phase/ 识别/ ,/ 同时/ 根据/ PMU/ 数据/ 计算/ 出/ 它/ 的/ 基本/ 性能/ 信息/ ,/ 包括/ 总线/ 事务/ 速率/ BTRq/ 以及/ 系统/ 级/ 带宽/ 使用率/ ./ 然后/ 我们/ 检查/ 该/ 程序段/ 的/ 执行/ 是否/ 满足/ 3/ 种/ “/ 低/ 竞争/ ”/ 的/ 情况/ 之一/ ./ 如果/ 满足/ ,/ 则/ 我们/ 称/ 它/ 的/ 执行/ 性能/ 信息/ 为/ 有效/ ,/ 否则/ 称为/ 无效/ ./ 最后/ 我们/ 把/ 当前/ 时间/ 片内/ 的/ 执行/ 信息/ 更新/ 到/ phase/ 信息/ 表中/ ./ IPCphase/ 和/ BTRphase/ 的/ 更新/ 方法/ 相同/ ,/ 我们/ 以/ 前者/ 为例/ ./ 在/ 一个/ phase/ 得到/ 它/ 第一个/ 有效/ 的/ 执行/ 历史/ 之前/ ,/ 它/ 的/ IPCphase/ 被/ 估算/ 为/ 所有/ 无效/ 历史/ 的/ 平均值/ ./ 在/ 该/ phase/ 获得/ 第一个/ 有效/ 历史/ 信息/ 时/ ,/ 所有/ 旧/ Page6/ 的/ 信息/ 被/ 抛弃/ ,/ 随后/ 它/ 的/ IPCphase/ 被/ 估算/ 为/ 所有/ 有效/ 历史/ 的/ 平均值/ ,/ 获得/ 的/ 有效/ 历史/ 信息/ 越/ 多/ ,/ 该/ 阶段/ 的/ IPCphase/ 估算/ 准确率/ 越高/ ./ 由此可见/ ,/ 3/ 种/ “/ 低/ 竞争/ ”/ 执行/ 情况/ 的/ 作用/ 是/ 过滤/ 掉/ 无效/ 的/ 数据/ ,/ 只/ 让/ 有效/ 的/ 历史/ 信息/ 参与/ 到/ IPCphase/ 的/ 估算/ 过程/ 中来/ ./ 上述/ phase/ 信息/ 表在/ 程序执行/ 结束/ 之后/ 更新/ 到/ 数据库/ 中/ ,/ 并/ 在/ 该/ 程序/ 未来/ 的/ 执行/ 中/ 重新/ 载入/ ,/ 持续/ 更新/ ./ 可以/ 发现/ ,/ 上述/ 过程/ 需要/ 的/ 数据/ 都/ 可以/ 在/ 程序/ 并发/ 时/ 通过/ PMU/ 实时/ 获得/ ,/ 无需/ 用户/ 干预/ 或/ 事先/ 准备/ 的/ 用户/ 制导/ 信息/ ./ 3.3/ 数据库/ 信息/ 精度/ 自/ 评价/ 数据库/ 中/ 的/ 信息/ 随着/ 程序/ 的/ 多次/ 执行/ 不断/ 积累/ 和/ 强化/ ./ 但/ 在/ 程序/ 的/ 前几次/ 执行/ 中/ ,/ 有/ 可能/ 并发程序/ 竞争/ 激烈/ ,/ “/ 低/ 竞争/ ”/ 执行/ 状态/ 数量/ 有限/ ,/ 导致/ 数据库/ 中/ 信息/ 精度/ 较/ 低/ ./ 如果/ 此时/ 启动/ 调度/ 优化/ ,/ 这些/ 不/ 精确/ 的/ 信息/ 可能/ 会/ 错误/ 的/ 指导/ 调度/ ,/ 损害/ 系统/ 吞吐/ 率/ ./ 为了/ 避免/ 上述情况/ 发生/ ,/ 我们/ 制定/ 了/ 数据库/ 信息/ 精度/ 自/ 评价/ 的/ 机制/ ./ 首先/ 我们/ 定义/ 程序/ 的/ 有效/ 信息/ 覆盖率/ (/ 或/ 简称/ 为/ 覆盖率/ )/ 为/ 其/ 获得/ 了/ 有效/ 独占/ 性能/ 估算/ 的/ 时间/ 片/ 数量/ 和/ 它/ 总/ 的/ 执行/ 时间/ 片/ 数量/ 的/ 比率/ ,/ 该值/ 在/ 运行/ 时/ 自动/ 维护/ ./ 一个/ 程序/ 在/ 多次/ 执行/ 中/ 不断/ 收集/ 有效/ 性能/ 信息/ ,/ 覆盖率/ 不断/ 提高/ ./ 当/ 一个/ 程序/ 组中/ 包含/ 的/ 所有/ 程序/ 的/ 覆盖率/ 超过/ 一个/ 设定/ 的/ 阈值/ ,/ 我们/ 才/ 会/ 进行/ 调度/ 优化/ ,/ 否则/ 将/ 使用/ 系统/ 原有/ 调度/ 策略/ ./ 我们/ 称/ 一个/ 程序/ 有效/ 信息/ 覆盖率/ 提高/ 至/ 阈值/ 的/ 过程/ 为/ 数据库/ 的/ 初始化/ ./ 数据库/ 初始化/ 在/ 该/ 程序/ 的/ 历史/ 执行/ 中/ 自动/ 进行/ ,/ 无需/ 用户/ 干预/ ./ 同时/ 我们/ 希望/ 该/ 过程/ 越短/ 越/ 好/ ,/ 以/ 尽早/ 地/ 启动/ 调度/ 优化/ ./ 初始化/ 所/ 要/ 经历/ 的/ 执行/ 次数/ 和/ 程序执行/ 环境/ 密切相关/ ,/ 相关/ 测试/ 将/ 在/ 5.2/ 节中/ 给出/ ./ 3.4/ 使用/ 数据库/ 信息/ 数据库/ 中/ 收集/ 的/ 信息/ 有/ 两个/ 作用/ :/ 在/ 执行/ 前/ 估算/ 程序/ 组/ 的/ 平均/ 带宽/ 需求/ IABW/ 以及/ 在/ 运行/ 时/ 估算/ 下/ 一个/ 时间/ 片/ 程序/ 的/ 带宽/ 需求/ ./ 程序/ 组/ IABW/ 估算/ :/ 为了/ 估算/ 一个/ 给定/ 程序/ 组/ 的/ 平均/ 带宽/ 需求/ ,/ 我们/ 需要/ 知道/ 其中/ 每个/ 程序/ 的/ 独占/ 执行/ 时间/ 以及/ 主存/ 访问/ 数/ ./ 程序/ 的/ 主存/ 访问/ 数/ 可以/ 在/ 它/ 执行/ 一次/ 后/ 直接/ 由/ PMU/ 获得/ ,/ 我们/ 使用/ 程序/ 多次/ 执行/ 的/ 平均值/ 进行/ 估计/ ./ 图/ 4/ 给出/ 了/ 每个/ SPECCPU2006/ 程序/ 在/ 本文/ 的/ 测试/ 系统/ 上/ ,/ 独占/ cache/ 执行/ 以及/ 和/ 随机/ 程序/ 共享/ cache/ 并发/ 执行/ 时/ 的/ 主存/ 访问/ 密度/ 的/ 变化/ 情况/ (/ 相对/ 于/ 独占/ 执行/ 时间/ 进行/ 了/ 归一化/ )/ ,/ 可以/ 看到/ ,/ 程序/ 在/ 共享/ cache/ 执行/ 时/ 主存/ 访问/ 密度/ 增大/ ,/ 但/ 和/ 不同/ 程序/ 并发/ 时/ 增加量/ 的/ 变化/ 范围/ 相对/ 较/ 小/ ,/ 因此/ 使用/ 多次/ 执行/ 的/ 平均值/ 可以/ 容忍/ 这种/ 波动/ ,/ 取得/ 较为/ 准确/ 的/ 估算/ ./ 程序/ 的/ 独占/ 执行/ 时间/ 估算/ 方法/ 如式/ (/ 4/ )/ 所示/ ,/ 它/ 由/ 该/ 程序/ 的/ 每个/ 执行/ 时间/ 片/ (/ 从/ 1/ ~/ Q/ )/ 的/ 独占/ 执行/ 时间/ 累加/ 得到/ ,/ 其中/ Iq/ 是/ 指/ 程序/ 在/ 时间/ 片/ q/ 内/ 执行/ 的/ 指令/ 数/ ,/ 由/ PMU/ 模块/ 直接/ 获得/ ;/ IPCqq/ 的/ 独占/ 执行/ IPC/ ,/ 它/ 通过/ 所属/ 的/ phase/ 到/ 数据库/ 中/ 索引/ 获得/ ./ Calone/ =/ ∑/ Q/ 对于/ 一个/ 给定/ 的/ 程序/ 组/ ,/ 当/ 它/ 所/ 包含/ 的/ 所有/ 程序/ 都/ 获得/ 独占/ 执行/ 时间/ 和/ 主存/ 访问/ 数/ 估算/ 之后/ ,/ 就/ 可以/ 使用/ 我们/ 在/ 2.1/ 节中/ 介绍/ 的/ 方法/ 计算/ 程序/ 组/ 的/ IABW/ ./ 运行/ 时/ 程序/ 带宽/ 需求预测/ :/ 我们/ 使用/ 马尔科夫/ 预测器/ 来/ 预测/ 每个/ 程序/ 在/ 下/ 一个/ 时间/ 片/ 即将/ 出现/ 的/ 阶段/ ./ 我们/ 把/ 一个/ 阶段/ 看成/ 一个/ 状态/ ,/ 根据/ 程序/ 本次/ 的/ 执行/ 历史/ 维护/ 一个/ 状态/ 转移/ 矩阵/ ./ 如果/ 马尔科夫/ 预测器/ 没有/ 足够/ 的/ 历史/ 信息/ 而/ 不能/ 产生/ 预测/ 结果/ (/ 尤其/ 是/ 程序执行/ 的/ 开始/ 阶段/ )/ ,/ 我们/ 推测/ 下/ 一个/ phase/ 和/ 当前/ phase/ 相同/ ./ 最后/ 我们/ 使用/ 预测出/ 的/ phaseID/ 到/ 数据库/ 中/ 进行/ 索引/ ,/ 获得/ 该/ phase/ 的/ 带宽/ 需求/ ./ 3.5/ 不同/ 输入/ 集/ 的/ 影响/ 程序/ 输入/ 集/ 的/ 变化/ 会/ 使/ 程序/ 行为/ 发生/ 改变/ ./ 和/ 输入/ 密切相关/ 的/ 指标/ 是/ 程序/ 独占/ 执行/ 时间/ 和/ 访存数/ ,/ 因此/ 需要/ 将/ 它们/ 的/ 值/ 和/ 程序/ 输入/ 对应/ ,/ 分开/ 记录/ ./ 程序/ 的/ 输入/ 包括/ 命令行/ 、/ 输入/ 文件/ 的/ 内容/ 等/ ,/ 最/ 直接/ 的/ 区分/ 方法/ 是/ 对/ 输入/ 内容/ 进行/ 严格/ 匹配/ ,/ 但/ 该/ 方法/ 降低/ 了/ 信息/ 的/ 重用/ 性/ ./ Tian/ 等/ 人/ [/ 10/ ]/ 在/ 相关/ 工作/ 中/ 利用/ 了/ 程序/ 在/ 相似/ 输入/ 集下/ 行为/ 相似/ 的/ 特点/ ,/ 提出/ 了/ 使用/ “/ 种子/ 特征/ 集合/ ”/ (/ seminalbehaviorset/ )/ 的/ Page7/ 方法/ 来/ 刻画/ 输入/ 集/ ./ 种子/ 特征/ 是/ 在/ 程序/ 中/ 挑选/ 出来/ 的/ 执行/ 信息/ ,/ 例如/ 一个/ 循环/ 迭代/ 次数/ 、/ 一个/ 变量/ 的/ 值/ 等/ ,/ 具有/ 相同/ 种子/ 特征/ 集合/ 的/ 输入/ 会/ 产生/ 相似/ 的/ 程序/ 行为/ ./ 本文/ 主要/ 讨论/ 了/ 跨/ 执行/ 调度/ 优化/ 方法/ 的/ 设计/ 以及/ 信息/ 获取/ 、/ 估算/ 等/ 关键问题/ ,/ 对/ 程序/ 输入/ 特征/ 的/ 刻画/ 在/ 本文/ 的/ 讨论/ 范围/ 之外/ ,/ 但/ 我们/ 可以/ 利用/ 上述/ 方法/ 进行/ 进一步/ 探索/ ,/ 这是/ 我们/ 的/ 未来/ 工作/ 之一/ ./ 而/ 程序/ phase/ 的/ 性能/ 信息/ 是/ 可以/ 跨/ 输入/ 部分/ 重用/ 的/ ./ 这/ 是因为/ 程序/ 的/ phase/ 代表/ 了/ 程序/ 在/ 特定/ 代码/ 区域/ 的/ 执行/ ,/ 而/ 程序/ 的/ 执行/ 存在/ 和/ 输入/ 无关/ 的/ 路径/ ,/ 或者/ 在/ 不同/ 输入/ 下/ 共有/ 的/ 执行/ 路径/ ./ 4/ 系统/ 实现/ 为了/ 验证/ 本文/ 方法/ 的/ 有效性/ ,/ 我们/ 在/ Linux/ 系统/ 上/ 实现/ 了/ 一个/ 用户/ 级/ 的/ 进程/ 调度/ 器/ ./ 对/ 每/ 一个/ 提交/ 到/ 系统/ 中/ 的/ 程序/ ,/ 调度/ 器/ 通过/ fork/ 创建/ 出该/ 进程/ ,/ 同时/ 使用/ perfmon/ 库/ ①/ 为/ 其/ 绑定/ 一个/ PMU/ 采样/ 上下文/ ,/ 然后/ 读取/ 数据库/ 中该/ 程序/ 的/ 历史/ 信息/ ,/ 并/ 估算/ 当前/ 程序/ 组/ 的/ IABW/ ./ 调度/ 器/ 设置/ 了/ 一个/ 计数器/ 来/ 测量/ 调度/ 时间/ 片/ ,/ 当/ 计数器/ 被/ 触发/ 时/ ,/ 调度/ 器/ 将/ 接收/ 到/ SIGALRM/ 信号/ ,/ 并/ 在/ 信号处理/ 程序/ 中/ 完成/ 下列/ 调度/ 工作/ :/ (/ 1/ )/ 使用/ ptrace/ _/ attach/ 系统/ 调用/ 让/ 程序/ 暂停/ 执行/ ./ (/ 2/ )/ 读取/ 和/ 处理/ PMU/ 数据/ ,/ 识别/ phase/ 并/ 进行/ 信息/ 更新/ ,/ 预测/ 程序/ 在/ 下/ 一个/ 时间/ 片/ 的/ 带宽/ 需求/ ./ (/ 3/ )/ 选择/ 程序/ 并发/ 执行/ ,/ 使/ 总/ 带宽/ 需求/ 等于/ 程序/ 组/ 的/ IABW/ ./ (/ 4/ )/ 对/ 每/ 一个/ 选定/ 的/ 程序/ ,/ 使用/ ptrace/ _/ detach/ (/ 5/ )/ 重置/ 调度/ 器/ 的/ 时间/ 片/ 计数器/ ,/ 等待/ 下/ 一个/ 为了/ 验证/ 跨/ 执行/ 优化/ 的/ 效果/ ,/ 我们/ 设计/ 了/ 自定义/ 的/ 文件格式/ 作为/ 数据库/ 存储/ 程序/ 的/ 历史/ 执行/ 信息/ ./ 5/ 实验/ 评价/ 5.1/ 测试/ 平台/ 和/ 程序/ 组/ 构建/ 测试/ 平台/ 和/ 3.1/ 节中/ 介绍/ 的/ 相同/ ,/ 我们/ 进行/ 8/ 核/ 调度/ 实验/ ./ 表/ 1/ 给出/ 了/ 系统/ 使用/ 的/ 默认/ 参数/ ./ 我们/ 使用/ SPECCPU2006/ 程序/ 构建/ 程序/ 组/ ./ 为了/ 排除/ 负载平衡/ 对/ 测量/ 的/ 影响/ ,/ 首先/ 要/ 对/ 程序/ 进行/ 长度/ 归一化/ :/ 我们/ 让/ 每个/ 程序/ 在/ 系统/ 中/ 独立/ 执行/ 10/ 秒/ ,/ 并/ 系统调度/ 使/ 之/ 继续执行/ ./ 时间/ 片/ 的/ 到来/ ./ 记录/ 它/ 完成/ 的/ 动态/ 指令/ 数/ ./ 每当/ 一个/ 程序/ 被/ 选择/ 加入/ 到/ 一个/ 程序/ 组中/ ,/ 与/ 这/ 10/ 秒钟/ 等价/ 的/ 部分/ 将/ 被/ 执行/ ./ 这部分/ 执行/ 包含/ 了/ 程序/ 的/ 初始化/ ,/ 会/ 产生/ 不规则/ 的/ 阶段/ 变化/ ,/ 这/ 给/ 本文/ 的/ 性能/ 估算/ 和/ 预测/ 技术/ 提出/ 了/ 更/ 大/ 的/ 挑战/ ;/ 同时/ 其/ 长度/ 也/ 可以/ 容忍/ 误差/ ./ 程序/ 有效/ 信息/ 覆盖率/ 可信/ 阈值/ 为了/ 验证/ 本文/ 方法/ 的/ 通用性/ ,/ 使用/ 的/ 程序/ 组都/ 随机/ 生成/ ./ 我们/ 定义/ 程序/ 组/ 的/ 并发/ 度为/ 其/ 所/ 包含/ 的/ 程序/ 个数/ 与/ CPU/ 核数/ 的/ 比值/ ./ 为了/ 测试/ 调度/ 效果/ ,/ 我们/ 生成/ 了/ 10/ 个/ 并发/ 度/ 在/ 2/ ~/ 4/ 之间/ 的/ 程序/ 组/ ,/ 且/ 具体/ 组成/ 也/ 通过/ 随机数/ 决定/ ./ 它们/ 的/ 组成/ 和/ 统计/ 特征/ 将/ 在/ 使用/ 时/ 给出/ ./ 我们/ 测量/ 程序/ 组/ 的/ 执行/ 时间/ 以/ 显示/ 系统/ 吞吐/ 率/ 的/ 变化/ ./ 对比/ 的/ 对象/ 是/ Linux2/ ./ 6/ 默认/ 的/ 调度/ 策略/ ./ 在/ 该/ 策略/ 下/ ,/ 不同/ 权重/ 的/ 非/ 实时/ 程序/ 被/ 赋予/ 不同/ 长度/ 的/ 时间/ 片/ ,/ 而/ 上述/ 程序/ 组中/ 的/ 程序/ 在/ 系统/ 中/ 默认/ 具有/ 相同/ 的/ 权重/ ,/ 因此/ 该/ 策略/ 和/ 时间/ 片/ 轮训/ (/ Round/ -/ Robin/ )/ 策略/ 具有/ 等价/ 的/ 效果/ ./ 另外/ ,/ 本文/ 的/ 工作/ 是/ 一个/ 为/ 带宽/ 敏感/ 调度/ 策略/ 提供/ 性能/ 数据/ 的/ 方法/ ,/ 因此/ 我们/ 也/ 对比/ 了/ 在/ 相同/ 带宽/ 敏感/ 调度/ 算法/ 下/ ,/ 通过/ 其它/ 方式/ 获取/ 和/ 处理/ 性能/ 数据/ 时/ 的/ 效果/ ./ 5.2/ 程序/ phase/ 执行/ 信息/ 收集/ 效率/ 和/ 开销/ (/ 1/ )/ 时间/ 开销/ 和/ 默认/ 的/ Linux/ 调度/ 策略/ 相比/ ,/ 我们/ 的/ 策略/ 需要/ 额外/ 的/ 数据/ 收集/ 和/ 处理/ 工作/ ,/ 时间/ 开销/ 主要/ 包括/ PMU/ 采样/ 和/ 调度/ 策略/ 本身/ (/ 包括/ 处理/ PMU/ 数据/ 、/ Phase/ 相关/ 工作/ 以及/ 调度/ 算法/ )/ 两个/ 方面/ ,/ 它们/ 进一步/ 由/ PMU/ 采样/ 频率/ 和/ 程序/ 静态/ phase/ 数/ 决定/ ,/ 是/ 程序/ 相关/ 的/ ./ 我们/ 测试/ 每/ 一个/ SPEC/ 程序/ 在/ 8/ 个/ 实例/ 并发/ 时/ 在/ 本文/ 方法/ 下/ 的/ 开销/ ,/ 测试/ 结果/ 如图/ 5/ 所示/ ./ 相比之下/ ,/ 每个/ 程序/ 组在/ 本文/ 方法/ 中/ 的/ 执行/ 时间/ 平均/ 增加/ 了/ 3.19/ %/ ./ 其中/ 来自/ 于/ 调度/ 策略/ 的/ 开销/ 可以/ 直接/ 在/ 系统/ 中/ 插入/ 计时/ 函数/ 获得/ ,/ 为/ 2.21/ %/ ,/ 这部分/ 开销/ 主要/ 来源于/ PMU/ 数据处理/ 和/ 程序/ Phase/ 相关/ 处理/ ,/ 这些/ 工作/ 可以/ 很/ 自然/ 地/ 分布/ 在/ 相应/ 的/ 处理器/ 核上/ ,/ 因此/ 随着/ 核数/ 增加/ 而/ 具有/ 扩展性/ ./ ①/ ThePerfmon2website/ ./ http/ :/ // // perfmon2/ ./ sourceforge/ ./ net/ // Page8/ 调度/ 算法/ 本身/ 的/ 开销/ 小于/ 0.2/ %/ ,/ 它/ 的/ 时间/ 复杂度/ 为/ O/ (/ NC/ )/ ,/ 其中/ N/ 为/ 并发/ 任务/ 数/ ,/ C/ 为/ CPU/ 核数/ ./ 剩余/ 的/ 时间/ 开销/ 来自/ 于/ PMU/ 采样/ ,/ 平均/ 为/ 0.98/ %/ ./ 表/ 2/ 数据库/ 初始化/ 效率/ 和/ 精度/ (/ a/ )/ 数据库/ 初始化/ 效率/ 和/ 精度/ (/ 低/ 、/ 中负载/ )/ 系统/ 负载/ 测量/ 指标/ BTRphase/ 数/ 437/ ./ leslie3d52/ ./ 1301459/ ./ GemsFDTD49/ ./ 9322433/ ./ milc49/ ./ 6351462/ ./ libquantum49/ ./ 0181410/ ./ bwaves47/ ./ 3272482/ ./ sphinx328/ ./ 0141470/ ./ lbm434/ ./ zeusmp24/ ./ 52134450/ ./ soplex20/ ./ 4504429/ ./ mcf17/ ./ 3241436/ ./ cactusADM15/ ./ 7111483/ ./ xalancbmk14/ ./ 1111403/ ./ gcc473/ ./ astar9/ ./ 2381471/ ./ omnetpp9/ ./ 1241481/ ./ wrf/ (/ b/ )/ 数据库/ 初始化/ 效率/ 和/ 精度/ (/ 高/ 负载/ )/ 系统/ 负载/ 测量/ 指标/ BTRphase/ 数/ 437/ ./ leslie3d52/ ./ 130459/ ./ GemsFDTD49/ ./ 932433/ ./ milc462/ ./ libquantum49/ ./ 018410/ ./ bwaves47/ ./ 327482/ ./ sphinx328/ ./ 014470/ ./ lbm434/ ./ zeusmp24/ ./ 521337450/ ./ soplex20/ ./ 450429/ ./ mcf436/ ./ cactusADM15/ ./ 711483/ ./ xalancbmk14/ ./ 111403/ ./ gcc473/ ./ astar471/ ./ omnetpp9/ ./ 124481/ ./ wrf/ 表/ 2/ 中/ “/ 执行/ 次数/ ”/ 表示/ 在/ 相应/ 的/ 系统/ 负载/ 下/ ,/ 数据库/ 初始化/ 所/ 需要/ 的/ 执行/ 次数/ ;/ “/ 估算/ 精度/ ”/ 是/ 数据库/ 初始化/ 完成/ 后/ ,/ 实际/ 独占/ 执行/ 时间/ 和/ 估算/ 独占/ 这部分/ 开销/ 天然/ 分布/ 在/ 不同/ 的/ 程序/ 中/ ,/ 因此/ 也/ 是/ 具有/ 扩展性/ 的/ ./ (/ 2/ )/ 数据库/ 信息/ 收集/ 效率/ 根据/ 3.3/ 节/ 的/ 描述/ ,/ 只有/ 数据库/ 完成/ 初始化/ (/ 即/ 程序/ 的/ 有效/ 信息/ 覆盖率/ 达到/ 80/ %/ )/ 之后/ ,/ 才能/ 在/ 后续/ 的/ 执行/ 中/ 对/ 它/ 进行/ 调度/ 优化/ ./ 数据库/ 的/ 初始化/ 在/ 该/ 程序/ 的/ 前几次/ 正常/ 执行/ 中/ 自动/ 进行/ ,/ 我们/ 希望/ 该/ 过程/ 越短/ 越好/ ./ 程序/ 有效/ 执行/ 信息/ 的/ 收集/ 速度/ 和/ 它/ 所处/ 的/ 执行/ 环境/ 密切相关/ ,/ 在/ 本节/ 中/ ,/ 我们/ 通过/ 在/ 不同/ 系统/ 负载/ (/ 即/ 程序/ 组/ 并发/ 度/ )/ 下/ 随机/ 向/ 系统/ 提交/ 程序/ 的/ 实验/ 方法/ 来/ 模拟/ 评测/ 数据库/ 的/ 初始化/ 速度/ ./ 测试/ 结果/ 如表/ 2/ 所示/ ./ 9799979298989698979193869698999985939586869348978983949699949792/ 执行/ 时间/ 的/ 比值/ ,/ 它/ 是/ 程序/ 每个/ phase/ 性能/ 估算/ 精度/ 的/ 综合/ 体现/ ./ 表中/ 的/ 程序/ 按照/ 自身/ BTR/ 从/ 高到/ 低/ 排列/ ,/ 比/ 481/ ./ wrf/ 带宽/ 需求/ 更/ 小/ 的/ 程序/ 没有/ 列出/ ,/ 因/ Page9/ 为/ 无论/ 在/ 什么/ 负载/ 下/ ,/ 它们/ 仅/ 需要/ 一次/ 执行/ 就/ 可以/ 获得/ 95/ %/ 以上/ 的/ 覆盖率/ 和/ 信息/ 精度/ ./ 作为/ 示例/ ,/ 图/ 6/ 给出/ 了/ 在/ 中负载/ 下/ 每个/ 程序/ 的/ 有效/ 数据/ 来源/ 分布/ (/ 3/ 种/ “/ 低/ 竞争/ ”/ 状态/ 之一/ 或者/ 没有/ 获得/ 有效/ 数据/ )/ ,/ 它表/ 3/ 测试程序/ 组/ 特征/ 和/ 组成/ 程序/ 组/ IABW/ 程序/ 数量/ WL/ #/ 0110428leslie3d/ (/ 2/ )/ ,/ bwaves/ (/ 2/ )/ ,/ sphinx3/ (/ 2/ )/ ,/ lbm/ (/ 2/ )/ ,/ soplex/ (/ 2/ )/ ,/ wrf/ (/ 2/ )/ ,/ dealII/ (/ 2/ )/ ,/ namd/ (/ 8/ )/ ,/ gamess/ (/ 4/ )/ ,/ WL/ #/ 029716GemsFDTD/ (/ 2/ )/ ,/ soplex/ (/ 2/ )/ ,/ astar/ (/ 2/ )/ ,/ omnetpp/ (/ 4/ )/ ,/ hmmer/ (/ 2/ )/ ,/ gromacs/ (/ 2/ )/ ,/ namd/ (/ 2/ )/ WL/ #/ 0312230leslie3d/ (/ 2/ )/ ,/ GemsFDTD/ (/ 2/ )/ ,/ sphinx3/ (/ 4/ )/ ,/ mcf/ (/ 2/ )/ ,/ gcc/ (/ 6/ )/ ,/ astar/ (/ 2/ )/ ,/ omnetpp/ (/ 2/ )/ ,/ calculix/ (/ 2/ )/ ,/ WL/ #/ 0411526GemsFDTD/ (/ 4/ )/ ,/ milc/ (/ 2/ )/ ,/ mcf/ (/ 2/ )/ ,/ gcc/ (/ 4/ )/ ,/ bzip2/ (/ 2/ )/ ,/ hmmer/ (/ 2/ )/ ,/ perlbench/ (/ 2/ )/ ,/ h264ref/ (/ 4/ )/ ,/ gamess/ (/ 4/ )/ WL/ #/ 059932leslie3d/ (/ 2/ )/ ,/ libquantum/ (/ 2/ )/ ,/ sphinx3/ (/ 2/ )/ ,/ lbm/ (/ 2/ )/ ,/ soplex/ (/ 2/ )/ ,/ wrf/ (/ 4/ )/ ,/ sjeng/ (/ 4/ )/ ,/ gobmk/ (/ 2/ )/ ,/ dealIIWL/ #/ 0613118leslie3d/ (/ 2/ )/ ,/ GemsFDTD/ (/ 2/ )/ ,/ milc/ (/ 2/ )/ ,/ calculix/ (/ 4/ )/ ,/ sjeng/ (/ 2/ )/ ,/ dealII/ (/ 4/ )/ ,/ povray/ (/ 2/ )/ WL/ #/ 0712030leslie3d/ (/ 2/ )/ ,/ sphinx3/ (/ 4/ )/ ,/ lbm/ (/ 4/ )/ ,/ soplex/ (/ 2/ )/ ,/ mcf/ (/ 2/ )/ ,/ gcc/ (/ 2/ )/ ,/ omnetpp/ (/ 2/ )/ ,/ wrf/ (/ 2/ )/ ,/ gobmk/ (/ 2/ )/ ,/ WL/ #/ 0814228GemsFDTD/ (/ 4/ )/ ,/ milc/ (/ 2/ )/ ,/ libquantum/ (/ 2/ )/ ,/ cactusADM/ (/ 2/ )/ ,/ gcc/ (/ 2/ )/ ,/ astar/ (/ 4/ )/ ,/ sjeng/ (/ 4/ )/ ,/ hmmer/ (/ 2/ )/ ,/ WL/ #/ 099729leslie3d/ (/ 1/ )/ ,/ GemsFDTD/ (/ 3/ )/ ,/ bwaves/ (/ 1/ )/ ,/ sphinx3/ (/ 1/ )/ ,/ soplex/ (/ 1/ )/ ,/ mcf/ (/ 1/ )/ ,/ omnetpp/ (/ 1/ )/ ,/ wrf/ (/ 3/ )/ ,/ WL/ #/ 1013027/ 图/ 7/ 给出/ 了/ 在/ 数据库/ 初始化/ 结束/ 之后/ ,/ 每个/ 程序/ 组在/ 带宽/ 敏感/ 调度/ 策略/ 下/ 连续/ 40/ 次/ 的/ 执行/ 性能/ 变化/ 情况/ ,/ 包括/ 程序/ 组中/ 所有/ 程序/ 的/ 平均/ 有效/ 信息/ 覆盖率/ 、/ 独占/ 执行/ 时间/ 的/ 平均/ 估算/ 精度/ 和/ 相对/ 于/ OS/ 默认/ 调度/ 策略/ 的/ 加速/ 比/ ./ 测试/ 结果表明/ ,/ 每个/ 程序/ 组/ 的/ 平均/ 有效/ 信息/ 覆盖率/ 和/ 估算/ 精度/ 保持稳定/ ,/ 并且/ 有/ 小幅度/ 上升/ ,/ 这/ 显示/ 了/ 本文/ 的/ 跨/ 执行/ 优化/ 方法/ 能/ 在/ 程序执行/ 过程/ 中/ 不断/ 优化/ 获得/ 更/ 精确/ 的/ 数据/ ;/ 信息/ 精度/ 提升/ 幅度/ 不大/ 的/ 原因/ 是/ ,/ 程序/ 组/ 并发/ 度/ 较/ 高/ ,/ 而且/ 其/ 组成/ 固定/ ,/ 因此/ 在/ 每次/ 执行/ 中/ 获得/ 的/ 新/ 的/ “/ 低/ 竞争/ ”/ 数量/ 有限/ ./ 在/ 某些/ 执行/ 下/ ,/ 程序/ 组/ 的/ 有效/ 信息/ 覆盖率/ 比上/ 一次/ 执行/ 略有/ 下降/ ,/ 这/ 是因为/ 在/ 该次/ 执行/ 中/ 检测/ 到/ 了/ 新/ 的/ 程序/ phase/ ./ 总体/ 来看/ ,/ 每个/ 程序/ 组在/ 40/ 次/ 执行/ 过程/ 中/ 的/ 吞吐/ 率/ 获得/ 了/ 持续/ 稳定/ 的/ 提升/ ,/ 对/ 某些/ 程序/ 显示/ 出/ 计算/ 密集型/ 程序/ 的/ 大部分/ 执行/ 时间/ 片/ 满足/ “/ 自身/ BTR/ 低/ ”/ 的/ 条件/ ./ 而/ 随着/ 程序/ 的/ 带宽/ 需求/ 逐渐/ 增加/ ,/ 它/ 的/ 执行/ 所/ 经历/ 的/ “/ 低/ 竞争/ ”/ 执行/ 态变少/ ,/ 因此/ 数据库/ 初始化/ 需要/ 更/ 多/ 的/ 执行/ ,/ 并且/ 有效/ 数据/ 的/ 主要/ 来源/ 也/ 变成/ “/ 系统/ 级/ BTR/ 低/ ”/ 以及/ “/ 1/ 访存/ 密集/ +/ 多/ 计算/ 密集/ ”/ ./ 而/ 对于/ 同一个/ 程序/ ,/ 随着/ 系统/ 负载/ 增加/ ,/ 他们/ 之间/ 的/ 带宽/ 竞争/ 也/ 更加/ 激烈/ ,/ 因此/ 所/ 需/ 的/ 执行/ 次数/ 也/ 更/ 多/ ./ 5.3/ 程序/ 组/ 调度/ 效果/ 为了/ 评测/ 本文/ 提出/ 的/ 跨/ 执行/ 调度/ 优化/ 的/ 效果/ ,/ 我们/ 随机/ 生成/ 了/ 10/ 个/ 并发/ 度为/ 2/ ~/ 4/ 的/ 程序/ 组/ ,/ 表/ 3/ 给出/ 了/ 它们/ 的/ 组成/ 和/ 平均/ 带宽/ 需求/ ./ app1/ (/ x/ )/ 表示/ 程序/ 组中/ 包含/ x/ 个/ 并发/ 的/ app1/ ./ 组/ 最大/ 加速/ 比可达/ 8.5/ %/ ,/ 平均/ 最大/ 加速/ 比为/ 5.5/ %/ ./ 程序/ 组/ 2/ (/ WL/ #/ 02/ )/ 在/ 第/ 9/ 次/ 执行/ 时/ 的/ 性能/ 发生/ 了/ 明显/ 波动/ ,/ 加速/ 比/ 从/ 8.10/ %/ 减小/ 到/ 3.17/ %/ ./ 通过/ 统计/ 我们/ 发现/ 前/ 8/ 次/ 执行/ 的/ 程序/ 组/ 主存/ 访问/ 总量/ 变化率/ 在/ 0.76/ %/ 以内/ ,/ 程序/ 估算/ 精度/ 的/ 累积/ 变化/ 使得/ 在/ 第/ 9/ 次/ 执行/ 时/ 的/ 调度/ 决策/ 发生/ 了/ 变化/ ,/ 由于/ 共享/ cache/ 竞争/ 度/ 改变/ ,/ 使得/ 程序/ 组/ 的/ 主存/ 访/ 存量/ 比前/ 8/ 次/ 的/ 平均值/ 突增/ 了/ 2.88/ %/ ,/ 增大/ 了/ 估算/ 的/ IABW/ 和/ 实际/ 值/ 的/ 差距/ ;/ 在/ 后续/ 5/ 次/ 执行/ 中/ 维持/ 了/ 类似/ 的/ 调度/ 决策/ ,/ 之后/ 由于/ 性能/ 数据/ 的/ 进一步/ 积累/ 以及/ 程序/ 组/ 主存/ 访问量/ 估算/ 对/ 波动/ 的/ 适应/ ,/ 最终/ 程序/ 组/ 获得/ 的/ 加速/ 比/ 趋于稳定/ ./ 5.4/ 与/ 已有/ 方法/ 效果/ 的/ 比较/ 在/ 本节/ 中/ 我们/ 将/ 本文/ 的/ 方法/ 和/ 其它/ 两种/ 方法/ 进行/ 对比/ ,/ 这些/ 方法/ 都/ 使用/ 了/ 作者/ 在/ 工作/ [/ 9/ ]/ 中/ 提出/ 的/ Page10/ 图/ 7/ 程序/ 组/ 40/ 次/ 执行/ 的/ 性能/ 带宽/ 敏感/ 调度/ 算法/ ,/ 区别/ 是/ 程序/ 性能/ 信息/ 的/ 获取/ 和/ 处理/ 方法/ 不同/ ./ 第/ 1/ 个/ 方法/ 是/ 作者/ 在/ 工作/ [/ 9/ ]/ 中/ 提出/ 的/ 离线/ 训练/ 的/ 方法/ ,/ 其/ 基本/ 思想/ 是/ :/ 由于/ 带宽/ 竞争/ ,/ 在/ 运行/ 时/ 通过/ PMU/ 收集/ 到/ 的/ 程序/ 带宽/ 使用/ 总是/ 比/ 它/ 实际/ 需求/ 低/ ,/ 因此/ ,/ 我们/ 可以/ 将/ 程序/ 组/ 的/ IABW/ 修正/ 得/ 比/ 实际/ 值低/ ,/ 以/ 维持/ 同样/ 的/ 调度/ 决策/ ./ 为了/ 确定/ 程序/ 组/ 实际/ IABW/ 和/ 修正/ 值/ 之间/ 的/ 关系/ ,/ 我们/ 需要/ 事先/ 生成/ 一些/ 具有/ 代表性/ 的/ 程序/ 组/ ,/ 并/ 通过/ 多次/ 测试/ 分别/ 找出/ 其/ 取得/ 最佳/ 性能/ 的/ 修正/ 值/ ,/ 并/ 记录/ 下/ 它/ 和/ IABW/ 的/ 对应/ 关系/ ,/ 最后/ 通过/ 多项式/ 拟合/ 的/ 方法/ 获得/ IABW/ 和/ 修正/ 值/ 之间/ 的/ 函数/ 关系式/ ./ 对于/ 一个/ 新/ 的/ 程序/ 组/ ,/ 我们/ 首先/ 计算/ 出/ 它/ 的/ IABW/ ,/ 并/ 根据上述/ 关系式/ 计算/ 出/ 修正/ 值/ ./ 而/ 程序/ 组/ IABW/ 估算/ 所/ 需/ 的/ 信息/ 仍要/ 由/ 用户/ 提供/ ./ 第/ 2/ 个/ 对比/ 方法/ 是/ 让/ 每/ 一个/ 程序/ 独立/ 执行/ 并/ 收集/ 详细/ 的/ profiling/ 信息/ ,/ 由此/ 计算/ 出/ 精确/ 的/ 程序/ 组/ IABW/ ,/ 并/ 在/ 动态/ 运行/ 时/ 索引/ profiling/ 取得/ 精确/ 的/ 程序段/ 带宽/ 需求/ ./ 该/ 方法/ 需要/ 事先/ 进行/ 独占/ profiling/ 工作/ ,/ 并且/ 不能/ 适应/ 输入/ 集/ 变化/ ,/ 因此/ 不/ 具有/ 实用性/ ,/ 本文/ 只是/ 通过/ 该/ 方法/ 显示/ 出/ 带宽/ 敏感/ 调度/ 策略/ 在/ 信息/ 完全/ 精确/ 时/ 的/ 性能/ 潜力/ ./ 图/ 8/ 给出/ 在/ 上述/ 方法/ 下/ 多次/ 执行/ 相对/ 于/ OS/ 默认/ 策略/ 的/ 最大/ 、/ 最小/ 和/ 平均/ 加速/ 比/ ./ 基于/ 离线/ 训练/ 的/ 方法/ 在/ 一定/ 程度/ 上/ 修正/ 了/ 动态/ 性能/ 信息/ 的/ 偏差/ 问/ Page11/ 题/ ,/ 因此/ 获得/ 了/ 平均/ 2.89/ %/ 的/ 加速/ ,/ 最大/ 平均/ 加速/ 为/ 4.08/ %/ ./ 对于/ WL/ #/ 10/ ,/ 程序/ 组/ 执行/ 性能/ 反而/ 下降/ ,/ 这/ 是因为/ 基于/ 离线/ 训练/ 获得/ 的/ IABW/ 和/ 修正/ 值/ 的/ 关系/ 是/ 多个/ 数据/ 的/ 拟合/ 结果/ ,/ 并/ 不能/ 对/ 任意/ 程序/ 组都/ 具有/ 最佳/ 效果/ ./ 对/ 10/ 个/ 程序/ 组中/ 的/ 6/ 个/ ,/ 本文/ 方法/ 的/ 效果/ 超过/ 了/ 基于/ 离线/ 训练/ 的/ 方法/ ,/ 原因/ 是/ 前者/ 能/ 在/ 程序/ 多次/ 执行/ 中/ 获得/ 足够/ 精确/ 的/ 信息/ ,/ 并且/ 容忍/ 了/ 共享/ cache/ 竞争/ 带来/ 的/ 影响/ ;/ 对于/ WL/ #/ 02/ 、/ WL/ #/ 05/ 、/ WL/ #/ 07/ 和/ WL/ #/ 08/ ,/ 本文/ 方法/ 的/ 平均/ 加速/ 比/ 低于/ 基于/ 离线/ 训练/ 的/ 方法/ ,/ 这/ 是因为/ 本文/ 程序/ 独占/ 执行/ 性能/ 估算/ 不能/ 做到/ 100/ %/ 精确/ ,/ 其/ 误差/ 来源于/ “/ 低/ 竞争/ ”/ 执行/ 性能/ 的/ 获取/ 和/ phase/ 识别/ 的/ 步骤/ ;/ 而/ 基于/ 离线/ 训练/ 的/ 方法/ 通过/ 事先/ 训练/ 学习/ 来/ 确定/ 程序/ 共享/ 执行/ 性能/ 和/ 独占/ 执行/ 性能/ 的/ 关系/ ,/ 是/ 另/ 一种/ 容忍/ 性能/ 数据误差/ 的/ 方式/ ./ 最终/ 本文/ 的/ 方法/ 获得/ 了/ 平均/ 3.73/ %/ 的/ 性能/ 提升/ ,/ 最大/ 性能/ 提升/ 为/ 8.46/ %/ ,/ 平均/ 最大/ 提升/ 为/ 5.50/ %/ ,/ 其/ 效果/ 超越/ 了/ 基于/ 离线/ 训练/ 的/ 方法/ ,/ 更/ 重要/ 的/ 是/ 使得/ 调度/ 策略/ 的/ 进行/ 不再/ 需要/ 任何/ 额外/ 的/ 离线/ 训练/ 过程/ 和/ 用户/ 提供/ 的/ 制导/ 信息/ ./ 基于/ 精确/ profiling/ 的/ 方法/ 能/ 获得/ 最/ 精确/ 的/ 程序/ 性能/ 信息/ ,/ 因此/ 获得/ 了/ 最好/ 的/ 性能/ 提升/ ,/ 平均/ 为/ 7.42/ %/ ,/ 最大/ 平均/ 为/ 7.96/ %/ ./ 对于/ WL/ #/ 02/ ,/ 基于/ profiling/ 数据/ 在/ 某次/ 执行/ 下/ 的/ 最大/ 加速/ 比/ 略低于/ 基于/ 跨/ 执行/ 优化/ 的/ 方法/ ,/ 这/ 是因为/ 前者/ 即使/ 获得/ 了/ 精确/ 的/ 性能/ 信息/ ,/ 但/ 在/ 程序/ phase/ 预测/ (/ 也/ 就是/ 程序/ 带宽/ 需求预测/ )/ 过程/ 中/ 仍/ 存在/ 误差/ ,/ 而/ 后者/ 在/ 数据/ 精确/ 略低/ 的/ 情况/ 下/ 仍然/ 有/ 概率/ 在/ 某次/ 执行/ 中/ 产生/ 接近/ 于/ 最佳/ 的/ 调度/ 决策/ ./ 图/ 8/ 基于/ profiling/ 、/ 离线/ 训练方法/ 和/ 跨/ 执行/ 优化/ 支持/ 下/ 的/ 6/ 总结/ 和/ 展望/ 访存/ 带宽/ 竞争/ 是/ 共享/ 存储/ 多核/ 系统/ 的/ 重要/ 性能/ 瓶颈/ ./ 带宽/ 敏感/ 的/ 任务调度/ 可以/ 有效/ 地/ 缓解/ 访存/ 带宽/ 竞争/ ,/ 提高/ 系统/ 吞吐/ 率/ ,/ 但/ 它/ 的/ 进行/ 需要/ 程序/ 性能/ 先验/ 知识/ ,/ 和/ 较为/ 准确/ 的/ 带宽/ 需求预测/ ./ 在/ 本文/ 中/ ,/ 我们/ 提出/ 了/ 一个/ 低/ 开销/ 、/ 对/ 用户/ 透明/ 的/ 跨/ 执行/ 优化/ 方法/ ,/ 该/ 方法/ 利用/ 了/ 程序执行/ 的/ 阶段性/ (/ phase/ )/ 特点/ ,/ 能/ 在/ 历史/ 执行/ 中/ 识别/ 程序/ phase/ ,/ 并/ 估算/ 它/ 的/ 执行/ 性能/ ,/ 这些/ 信息/ 又/ 能/ 在/ 程序/ 未来/ 的/ 执行/ 中/ 不断/ 强化/ ,/ 指导/ 调度/ ./ 基于/ Intel/ 多核/ 处理器/ 的/ 测试/ 结果表明/ ,/ 本文/ 的/ 方法/ 可以/ 使/ 系统/ 吞吐/ 率/ 平均/ 提升/ 3.7/ %/ ,/ 对/ 某些/ 程序/ 组可达/ 8.5/ %/ ./ 它/ 使得/ 带宽/ 敏感/ 调度/ 策略/ 的/ 进行/ 不再/ 需要/ 任何/ 用户/ 信息/ 制导/ ,/ 同时/ 改善/ 调度/ 效果/ ./ 本文/ 的/ 工作/ 对于/ 在/ 操作系统/ 中/ 透明/ 的/ 集成/ 带宽/ 敏感/ 调度/ 策略/ 具有/ 重要/ 的/ 意义/ ./ 作为/ 未来/ 工作/ ,/ 我们/ 准备/ 进一步/ 研究/ 输入/ 特征/ 及其/ 对/ 程序/ 性能/ 的/ 影响/ ,/ 我们/ 还/ 准备/ 使用/ 跨/ 执行/ 优化/ 方法/ 支持/ 更/ 多/ 的/ 动态/ 优化/ ./ 致谢/ 在/ 此/ ,/ 我们/ 向/ 对/ 本文/ 的/ 工作/ 给予/ 支持/ 和/ 建议/ 的/ 老师/ 和/ 同学/ 表示感谢/ !/ 美国明尼苏达大学/ 的/ 游本/ 中/ 和/ 中国台湾/ 交通/ 大学/ 的/ 徐慰/ 中/ 教授/ 对/ 本文/ 研究/ 内容/ 给予/ 了/ 启发/ 和/ 指导/ ,/ 研究/ 小组/ 同学/ 对/ 本文/ 提出/ 了/ 宝贵意见/ ,/ 在/ 此/ 一并/ 感谢/ !/ 

