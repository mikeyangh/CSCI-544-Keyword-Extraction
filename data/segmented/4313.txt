Page1/ 多核/ 环境/ 下/ 编译器/ 辅助/ 消息/ 驱动/ 的/ 动态/ 调度/ 于俊清/ 1/ )/ ,/ 2/ )/ 余华飞/ 1/ )/ 魏/ 海涛/ 1/ )/ 秦明康/ 1/ )/ 1/ )/ (/ 华中科技大学/ 计算机科学/ 与/ 技术/ 学院/ 武汉/ 430074/ )/ 2/ )/ (/ 华中科技大学/ 网络/ 与/ 计算中心/ 武汉/ 430074/ )/ 摘要/ 计算/ 密集型/ 应用/ 中/ 存在/ 大量/ 的/ 并行性/ ,/ 如何/ 优化/ 并行处理/ 任务/ ,/ 充分利用/ 多核/ 处理器/ 的/ 并行/ 资源/ 是/ 当前/ 多核/ 编程/ 领域/ 亟待解决/ 的/ 重要/ 问题/ ./ 针对/ 此/ 问题/ ,/ 文中/ 提出/ 编译器/ 辅助/ 消息/ 驱动/ 的/ 动态/ 调度/ 模型/ 来/ 优化/ 任务调度/ ;/ 设计/ 出新/ 的/ 编程/ 模型/ DFBrook/ ,/ 以便/ 更好/ 地/ 支持/ 数据/ 级/ 和/ 任务/ 级/ 的/ 并行/ ;/ 采用/ 编译器/ 辅助/ 的/ 方式/ ,/ 由/ 编译器/ 产生/ 将/ 在/ 运行/ 时/ 创建/ 数据流/ 图/ 的/ 代码/ ;/ 调度/ 器/ 对/ 数据流/ 图/ 进行/ 分析/ 和/ 解除/ 任务/ 依赖/ ,/ 并/ 将/ 任务/ 分发/ 到/ 各/ 处理/ 核/ ,/ 处理/ 核/ 执行/ 完/ 任务/ 后/ 提供/ 反馈/ 信息/ 给/ 主控/ 核/ 进行/ 调度/ 决策/ ./ 实验/ 结果表明/ ,/ 调度/ 模型/ 具有/ 较/ 好/ 的/ 扩展性/ ,/ 并/ 保持/ 了/ 较/ 高/ 的/ 负载/ 均衡/ 效率/ 和/ 较/ 低/ 的/ 通信/ 开销/ ./ 关键词/ 多核/ 处理器/ ;/ 单/ 程序/ 多/ 数据/ ;/ 动态/ 调度/ ;/ 消息/ 驱动/ 1/ 引言/ 多核/ 处理器/ 给/ 数字/ 信号处理/ 、/ 多媒体/ 处理/ 和/ 科学计算/ 等/ 数据/ 和/ 计算/ 密集型/ 应用/ 提供/ 了/ 大量/ 的/ 并行计算/ 资源/ ./ 如何/ 充分/ 有效/ 地/ 利用/ 这些/ 并行/ 资源/ ,/ 以/ 提高/ 程序/ 的/ 性能/ 已经/ 成为/ 并行程序/ 设计/ 领域/ 的/ 研究/ 热点/ 和/ 难点/ ./ 流/ 编程/ 模型/ 作为/ 一种/ 高效/ 的/ 并行/ 编程/ 模型/ 将/ 程序/ 的/ 并行性/ 显示/ 地/ 展现/ 出来/ ,/ 它/ 最初/ 是/ 为/ 特定/ 的/ 流/ 体系结构/ 设计/ 的/ ,/ 当前/ 有/ 一些/ 研究者/ 利用/ 流/ 编程/ 模型/ 对多核/ 处理器/ 上/ 的/ 流/ 程序/ 调度/ 问题/ 开展/ 了/ 一系列/ 研究/ ./ 流/ 程序/ 的/ 调度/ 可以/ 分为/ 静态/ [/ 1/ -/ 3/ ]/ 和/ 动态/ 调度/ [/ 4/ -/ 6/ ]/ 两种/ ./ 静态/ 调度/ 是/ 由/ 编译器/ 依据/ 任务/ 的/ 计算/ 量/ 和/ 数据通信/ 时间/ 对/ 任务/ 进行/ 分配/ ,/ 给/ 每个/ 核/ 生成/ 任务/ 代码/ ;/ 由于/ 多数/ 情况/ 下/ 任务/ 的/ 计算/ 量/ 和/ 数据通信/ 时间/ 很难/ 精确/ 估计/ ,/ 从而/ 会/ 导致/ 程序/ 的/ 性能/ 下降/ ./ 动态/ 调度/ 是/ 程序/ 在/ 运行/ 时/ ,/ 由/ 调度/ 器/ 采用/ 特定/ 的/ 调度/ 策略/ 将/ 任务分配/ 到/ 处理/ 核上/ ;/ 动态/ 调度/ 的/ 缺陷/ 在于/ ,/ 它会/ 产生/ 任务调度/ 和/ 运行/ 时/ 内存/ 管理/ 等/ 开销/ ./ 针对/ 以上/ 研究/ 中/ 存在/ 的/ 问题/ ,/ 本文/ 提出/ 一种/ 静态/ 和/ 动态/ 相结合/ 的/ 方式/ 来/ 实现/ 任务调度/ —/ —/ —/ 编译器/ 辅助/ 消息/ 驱动/ 的/ 动态/ 调度/ (/ Compiler/ -/ AssistedMessage/ -/ DrivenDynamicScheduling/ ,/ CAMDDS/ )/ ./ CAMDDS/ 实现/ 了/ 任务/ 的/ 优化/ 执行/ ,/ 使/ 任务/ 最大/ 并行/ 化/ 调度/ ,/ 减缓/ 了/ 存储器/ 和/ 网络带宽/ 压力/ ./ 实验/ 表明/ ,/ CAMDDS/ 获得/ 了/ 接近/ 线性/ 的/ 加速/ 比/ ,/ 各/ 处理/ 核/ 任务/ 负载/ 基本/ 达到/ 均衡/ ,/ 调度/ 开销/ 较/ 低/ ./ 2DFBrook/ 流/ 编程语言/ Brook/ [/ 7/ ]/ 流/ 编程/ 是/ 斯坦福大学/ 为/ Merrimac/ 流/ 体系结构/ 设计/ 的/ 数据/ 级/ 并行/ 编程/ 模型/ ,/ 它/ 含有/ 一套/ 完整/ 的/ 编程语言/ 、/ 编译器/ 和/ 运行/ 时/ 系统/ ./ DFBrook/ 语言/ 在/ Brook/ 语言/ 的/ 基础/ 上/ ,/ 加入/ 数据流/ 模型/ ,/ 将流/ 程序/ 以/ DFG/ 的/ 形式/ 表示/ ./ 此外/ ,/ DFBrook/ 语言/ 提供/ 了/ 一组/ 常用/ 的/ 流/ 操作/ 实现/ ./ DFBrook/ 程序/ 由/ 传统/ 的/ C/ 代码/ 和/ 流/ 代码/ 组成/ ,/ 流/ 代码/ 包括/ 流/ 变量/ 声明/ 、/ 流/ 操作/ 调用/ 和/ kernel/ 操作/ 定义/ ./ 2.1/ 流/ (/ Streams/ )/ 及流/ 操作/ 流是/ 一连串/ 的/ 数据/ 序列/ ,/ 是/ 主存/ 、/ kernel/ 操作/ 和/ 流/ 操作/ 进行/ 数据通信/ 的/ 载体/ ./ 数据/ 对象/ 的/ 集合/ 称为/ 流/ ,/ 而/ 每/ 一个/ 数据/ 对象/ 称为/ 流/ 元素/ ./ 流/ 变量/ 的/ 类型/ 决定/ 了/ 流/ 元素/ 的/ 数据类型/ ,/ 其/ 类型/ 可以/ 是/ 传统/ 的/ C语言/ 内置/ 类型/ ,/ 如/ char/ ,/ int/ ,/ float/ 等/ ./ 流/ 变量/ 通过/ Stream/ 、/ Istream/ 和/ Ostream/ 等/ 关键字/ 声明/ ./ Istream/ 声明/ 输入/ 流/ ,/ 输入/ 流/ 变量/ 只读/ ;/ Ostream/ 声明/ 输出/ 流/ ,/ 输出/ 流/ 变量/ 只/ 写/ ;/ Stream/ 声明/ 输入输出/ 流/ ,/ 输入输出/ 流/ 变量/ 可读/ 可/ 写/ ./ 流/ 变量/ 的/ 声明/ 与/ C/ 中/ 变量/ 的/ 声明/ 类似/ ,/ 流在/ 进行/ 声明/ 时/ ,/ 流/ 的/ 相关/ 信息/ 如流/ 元素/ 的/ 类型/ 、/ 流/ 的/ 维数/ 、/ 每/ 一维/ 的/ 长度/ 等/ 是/ 未知/ 的/ ./ 通过/ 流/ 操作/ streamRead/ (/ )/ 可以/ 对流/ 信息/ 进行/ 初始化/ ./ 流/ 操作/ 是/ 对/ 数据/ 的/ 重新/ 布局/ ,/ 如流/ 的/ 读入/ // 写出/ 以及/ 流/ 的/ 分裂/ // 融合/ 等/ 操作/ ./ DFBrook/ 采用/ 简短/ 高效/ 的/ 代码/ 实现/ 这些/ 流/ 操作/ ,/ 以/ API/ 形式/ 供/ 编程人员/ 使用/ ,/ 方便/ 他们/ 对流/ 进行/ 管理/ ./ 2.2/ kernel/ 操作/ kernel/ 操作/ 是/ 用户/ 自定义/ 的/ 单/ 程序/ 多/ 数据/ (/ SingleProgramMultipleData/ ,/ SPMD/ )/ 函数/ ,/ 功能/ 相对/ 简单/ ,/ 作用/ 于/ 一系列/ 输入/ 流/ ,/ 并/ 产生/ 一系列/ 输出/ 流/ ./ kernel/ 操作/ 是/ 普通/ C/ 函数/ 的/ 扩展/ ,/ 加入/ 了/ kernel/ 和/ out/ 关键字/ ./ 函数/ 说明符/ kernel/ 指明/ 函数/ 为/ kernel/ 函数/ 而/ 有别于/ 普通/ 的/ C/ 函数/ ,/ 是/ 可以/ 并行执行/ 的/ 代码/ 片段/ ./ 类型/ 说明符/ out/ 指明/ 流为/ 输出/ 流/ ,/ 没有/ out/ 修饰/ 的/ 流为/ 输入/ 流/ ./ DFBrook/ 编译器/ 在/ 编译/ 时/ 采用/ 弱/ 类型/ 检查/ ,/ 即/ 只/ 检查/ 参数/ 的/ 个数/ 是否/ 一致/ ,/ 而/ 不/ 检查/ 参数/ 的/ 类型/ ./ 在/ kernel/ 函数/ 体里/ 输入/ 流在/ 使用/ 完后/ 就/ 会/ 被/ 销毁/ ,/ 输出/ 流/ 存放/ 的/ 是/ kernel/ 函数/ 体对/ 输入/ 流/ 的/ 计算结果/ ./ 3CAMDDS/ 调度/ 模型/ CAMDDS/ 调度/ 模型/ 不同于/ 单纯/ 的/ 静态/ 或/ 动态/ 调度/ 模型/ ,/ 它/ 首先/ 利用/ 编译器/ 产生/ 的/ 任务/ 信息/ ,/ 在/ 程序运行/ 时/ 将/ 这些/ 信息/ DFG/ ,/ 然后/ 启动/ 任务调度/ 器/ 分析/ DFG/ ,/ 动态/ 地/ 将/ 任务/ 映射/ 到/ 处理/ 核/ ./ 调度/ 方式/ 采用/ 集中/ 式调度/ :/ 控制/ 核/ (/ ControlCore/ ,/ CC/ )/ 负责/ 任务调度/ ,/ 多个/ 加速/ 核/ (/ AcceleratedCores/ ,/ ACs/ )/ 对/ 数据/ 进行/ 处理/ ,/ 核间/ 采用/ 消息/ 进行/ 通讯/ ./ 图/ 1/ 给出/ 了/ CAMDDS/ 调度/ 模型/ 的/ 调度/ 过程/ 示意图/ ./ 3.1/ DFG/ 生成器/ DFBrook/ 编译器/ 输出/ 的/ DFG/ 生成/ 代码/ 专门/ 用来/ 在/ 运行/ 时/ 构建/ DFG/ ./ DFG/ 的/ 构建/ 使用/ 了/ 库函数/ StreamOP/ (/ )/ 和/ Kernel/ (/ )/ ./ StreamOP/ (/ )/ 负责/ 向/ DFG/ 中/ 添加/ 流/ 操作/ 节点/ ,/ Kernel/ (/ )/ 负责/ 向/ DFG/ 中/ 添加/ kernel/ 操作/ 节点/ ./ DFG/ 生成器/ 每/ 执行/ 一次/ Kernel/ (/ )/ 或/ StreamOP/ (/ )/ ,/ 就/ 先/ 构建/ 出头/ 结点/ ,/ 再/ 分析/ 当前/ 节/ Page3/ 图/ 1CAMDDS/ 调度/ 模型/ 示意图/ 点/ 与/ 已有/ 节点/ 间/ 的/ 依赖/ 关系/ ./ 并/ 根据/ 输出/ 结果/ 进行/ 适当/ 更新/ 操作/ ,/ 保证/ 所/ 记录/ 的/ 是/ 活跃/ 变量/ 最新/ 的/ 活跃/ 点/ ./ 3.2/ CC/ 端/ 运行/ 时/ 实现/ CC/ 上/ 的/ 任务调度/ 工作/ 由/ helperthread/ 和/ mainthread/ 协同/ 完成/ ./ helperthread/ 使用/ scoreboard/ 记录/ 和/ 更新/ 处理器/ 状态/ 、/ 任务/ 状态/ 、/ 数据/ 位置/ 等/ 信息/ ;/ mainthread/ 建立/ DFG/ 并/ 负责/ 调度/ 决策/ 工作/ ,/ 由于/ 流/ 操作/ 会/ 调度/ 到/ CC/ 上/ 执行/ ,/ 所以/ mainthread/ 也/ 会/ 执行/ 流/ 操作/ 任务/ ./ 调度/ 器/ 的/ 实现/ 算法/ 首先/ 获取/ 应用程序/ 指定/ 启用/ AC/ 的/ 个数/ ,/ 然后/ 在/ 每个/ AC/ 上/ 启动/ 一个/ 功能/ 相同/ 的/ 守候/ 线程/ ,/ 守候/ 线程/ 循环/ 在/ LTU/ 中取/ 任务/ ./ 在/ 选定/ 好要/ 进行/ 调度/ 的/ 任务/ 后/ ,/ 就要/ 设计/ 如何/ 存放/ 输入/ 和/ 输出/ 数据/ ./ 文献/ [/ 6/ ]/ 和/ CellSs/ [/ 8/ ]/ 的/ 处理/ 方法/ 是/ 将/ 所有/ 的/ 数据/ 都/ 存放/ 在/ GM/ ,/ 计算/ 开始/ 前/ ,/ 输入/ 数据/ 从/ GM/ 传输/ 到/ LM/ ,/ 计算/ 结束/ 后/ ,/ 输出/ 数据/ 传回/ GM/ ,/ AC/ 上/ 的/ LM/ 只是/ 计算/ 数据/ 的/ 暂存/ 点/ ./ CAMDDS/ 调度/ 模型/ 采用/ 与/ 之/ 不同/ 的/ 策略/ :/ LM/ 不/ 但是/ 计算/ 数据/ 的/ 暂存/ 点/ ,/ 也/ 是/ 中间/ 结果/ 的/ 存放/ 点/ ,/ 后续/ 任务/ 可以/ 从此/ 存放/ 点取/ 数据/ 进行/ 后续/ 处理/ ./ 关于/ kernel/ 任务/ 的/ 调度/ ,/ 本文/ 提出/ 一种/ 混合/ 调度/ (/ HybridScheduling/ ,/ HS/ )/ 策略/ ,/ 实现/ 了/ 目标/ 核选择/ 算法/ ./ HS/ 的/ 目标/ 是/ 在/ 减小/ 数据通信/ 开销/ 的/ 同时/ ,/ 保证/ 任务/ 的/ 快速/ 完成/ ,/ 并/ 兼顾/ 处理/ 核上/ 的/ 任务/ 负载/ 均衡/ ./ 算法/ 对/ 处理/ 核/ 的/ 选择/ 分为/ 3/ 个/ 优先级/ :/ (/ 1/ )/ 高/ 优先级/ ./ 选择/ 任务/ 队/ 列为/ 空且/ 含有/ 当前任务/ 所/ 需/ 输入/ 数据/ 的/ 处理/ 核/ 作为/ 目标/ 核/ ,/ 满足/ 该/ 条件/ 的/ 处理/ 核/ 多于/ 一个/ ,/ 则/ 从/ 这些/ 候选/ 核中/ 选择/ 完成/ 的/ 任务/ 总量/ 最小/ 的/ 处理/ 核/ ./ (/ 2/ )/ 中/ 优先级/ ./ 选择/ 空闲/ 的/ 处理/ 核/ 作为/ 候选/ 核/ ,/ 再/ 从/ 这些/ 候选/ 核中/ 选择/ 完成/ 的/ 任务/ 总量/ 最小/ 的/ 处理/ 核/ ./ (/ 3/ )/ 低优先级/ ./ 选择/ 任务/ 队列/ 最小/ 的/ 处理/ 核/ 作为/ 候选/ 核/ ,/ 再/ 从/ 这些/ 候选/ 核中/ 选择/ 完成/ 的/ 任务/ 总量/ 最小/ 的/ 处理/ 核/ ./ 目标/ 核选择/ 算法/ 按/ 优先级/ 由高到/ 低/ 顺序/ 找出/ 候选/ 处理/ 核/ ,/ 然后/ 从/ 这些/ 候选/ 核中/ 选择/ 完成/ 的/ 任务/ 总量/ 最小/ 的/ 处理/ 核/ 作为/ 目标/ 核/ ,/ 以/ 维持/ 核间/ 的/ 负载/ 均衡/ ./ 任务/ 中/ 的/ 输入/ 数据/ 在/ 任务/ 完成/ 后/ ,/ 就/ 成/ 了/ 垃圾/ 数据/ ,/ CC/ 会/ 查明/ 这些/ 数据/ 的/ 位置/ ,/ 并/ 以/ 消息/ 的/ 形式/ 通知/ 相应/ 的/ ACs/ 释放/ 掉/ 这些/ 空间/ ./ 3.3/ AC/ 端/ 运行/ 时/ 实现/ 每个/ AC/ 上/ 的/ 线程/ 间/ 相互/ 独立/ ,/ 并/ 拥有/ 各自/ 的/ 栈/ 空间/ 和/ 堆/ 空间/ ,/ ACs/ 线程/ 间/ 采用/ DMA/ 方式/ 进行/ 数据传输/ ./ ACs/ 线程/ 启动/ 后/ ,/ 循环/ 地/ 从/ 各自/ 的/ LTU/ 中/ 获取/ 任务/ 消息/ 并/ 调用/ 相应/ 的/ 任务/ 函数/ 进行/ 处理/ ./ 任务/ 线程/ 取/ 到/ 消息/ 后/ ,/ 立即/ 对/ 消息/ 进行/ 解析/ ,/ 获取/ 任务/ 信息/ 并存/ 放在/ 本地/ 的/ 任务/ 结构/ 中/ ./ 任务/ 中/ 的/ 输入/ 参数/ 数据/ 可能/ 在/ GM/ 或/ 其它/ ACs/ 上/ ,/ 也/ 可能/ 在/ 本地/ ,/ 若/ 不/ 在/ 本地/ ,/ 需要/ 启动/ DMA/ 进行/ 数据传输/ ./ 输出/ 数据/ 根据/ 不同/ 情况/ 有/ 两种/ 处理/ 方式/ ,/ 一种/ 是/ 通过/ DMA/ 回/ 传到/ GM/ ,/ 另/ 一种/ 是/ 暂存/ 本地/ ./ 如果/ 输出/ 参数/ 中/ 数据/ 地址/ 非空/ ,/ 则/ 说明/ 数据/ 需/ DMA/ 回/ 传到/ 指定/ 的/ 数据/ 地址/ ;/ 否则/ 暂/ 存在/ 本地/ ,/ 供/ 其它/ ACs/ 线程/ 使用/ ./ 对于/ 需要/ 暂/ 存在/ LM/ 上/ 的/ 中间/ 结果/ ,/ ACs/ 线程/ 会/ 在/ 本地/ 内存/ 开辟/ 相应/ 的/ 存储单元/ ,/ 并/ 以/ 消息/ 的/ 形/ Page4/ 式/ 通知/ CC/ 数据/ 的/ 存放/ 位置/ ./ 这些/ 暂存/ 的/ 数据/ 被/ 其它/ ACs/ 使用/ 完后/ 就/ 成为/ 无用/ 数据/ ./ CC/ 在/ 每/ 收到/ 一条/ ACs/ 反馈/ 信息/ 后/ 会/ 查看/ 哪些/ ACs/ 上/ 的/ 暂存/ 数据/ 需要/ 清理/ ,/ 并/ 通知/ 相应/ 的/ ACs/ 进行/ 垃圾/ 清理/ ./ ACs/ 线程/ 在/ 完成/ 分配/ 的/ 任务/ 后/ ,/ 会/ 给/ CC/ 提供/ 反馈/ 信息/ ,/ 这些/ 信息/ 有助于/ 调度/ 器/ 对/ 后续/ 任务/ 的/ 调度/ 选择/ ./ 一个/ 任务/ 的/ 结束/ 信息/ 解除/ 了/ 任务/ 间/ 的/ 依赖/ ,/ 使/ 后续/ 任务/ 得以/ 调度/ ./ ACs/ 尽早/ 提供/ 这些/ 反馈/ 信息/ 可以/ 减少/ 调度/ 器/ 的/ 调度/ 等待时间/ ./ ACs/ 上/ 的/ 计算/ 任务/ 完成/ 后/ ,/ ACs/ 线程/ 立即/ 给/ CC/ 发送/ 反馈/ 消息/ ,/ 然后/ 再/ 进行/ 数据/ 的/ 暂存/ 或/ 回传/ 工作/ ./ 4/ 实验/ 结果/ 本/ 节/ 给出/ 了/ CAMDDS/ 调度/ 模型/ 在/ Cell/ 和/ Godson/ -/ T/ 处理器/ 上/ 的/ 性能/ 测试/ 结果/ ./ 分别/ 从/ 模型/ 的/ 可扩展性/ 和/ 动态/ 负载/ 均衡/ 两/ 方面/ 对模型/ 的/ 性能/ 进行/ 分析/ 与/ 评价/ ./ 4.1/ 模型/ 的/ 可扩展性/ 图/ 2/ 给出/ 了/ 测试程序/ 集在/ Cell/ 和/ Godson/ -/ T/ 上/ 配置/ 有/ 不同/ AC/ 数量/ 的/ 处理器/ 上/ 的/ 加速/ 比/ ./ 实验/ 分别/ 对/ 1/ ~/ 6/ 个/ ACs/ 配置/ 的/ 处理器/ 进行/ 测试/ ./ 结果显示/ 大部分/ 测试程序/ 获得/ 了/ 接近/ 线性/ 的/ 加速/ 比/ ./ 4.2/ 动态/ 负载/ 均衡/ 图/ 3/ 给出/ 了/ Cell/ 处理器/ 配置/ 有/ 6/ 个/ SPE/ 和/ Godson/ -/ T/ 处理器/ 配置/ 有/ 6/ 个/ 从/ 核时/ ,/ 测试程序/ 集在/ 不同/ 的/ 调度/ 策略/ 下/ 对应/ 的/ 负载/ 均衡/ 效率/ ./ 从图/ 中/ 可以/ 看出/ ,/ HS/ 策略/ 保持/ 了/ 高/ 的/ 负载/ 均衡/ ,/ 各/ 测试程序/ 的/ 负载/ 均衡/ 率/ 都/ 超过/ 了/ 80/ %/ ./ 在/ Godson/ -/ T/ 处理器/ 上/ ,/ 取得/ 了/ 与/ Cell/ 处理器/ 相同/ 的/ 实验/ 结果/ ./ 5/ 结束语/ CAMDDS/ 调度/ 模型/ 能/ 将/ DFBrook/ 语言/ 编写/ 的/ 流/ 程序/ 有效/ 地/ 调度/ 到/ 多/ 核/ 处理器/ 上/ ,/ 并/ 保证/ 流/ 程序/ 最大化/ 并行执行/ ;/ 它/ 实现/ 了/ 任务/ 的/ 粗粒度/ 调度/ ,/ 充分/ 开发/ 了/ 应用程序/ 的/ 任务/ 级/ 和/ 数据/ 级/ 并行/ ./ 在/ 两种/ 实验/ 平台/ Cell/ 和/ Godson/ -/ T/ 处理器/ 上/ ,/ CAMDDS/ 调度/ 模型/ 显示/ 了/ 良好/ 的/ 平台/ 可扩展性/ ,/ 获得/ 了/ 接近/ 线性/ 的/ 加速/ 比/ ,/ 平均/ 的/ 负载/ 均衡/ 率/ 在/ 85/ %/ 以上/ ./ 但/ CAMDDS/ 没有/ 考虑/ 容错/ 问题/ ./ 对于/ 无/ 容错/ 机制/ 的/ 多/ 核/ 平台/ 下/ 的/ 动态/ 调度/ 中/ ,/ 运行/ 时/ 依赖/ 子/ 任务/ 间/ 的/ 容错/ 问题/ 是/ 下/ 一步/ 需要/ 解决/ 的/ 主要/ 问题/ ./ 

