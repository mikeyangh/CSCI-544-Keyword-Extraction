Page1/ 一种/ 适用/ 于/ 具有/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 的/ 动态/ 故障/ 树/ 独立/ 模块/ 识别方法/ 张红林/ 1/ )/ 张春元/ 1/ )/ 刘东/ 2/ )/ 1/ )/ (/ 国防科学技术大学/ 计算机/ 学院/ 长沙/ 410073/ )/ 2/ )/ (/ 装备/ 指挥/ 技术/ 学院/ 国防科技/ 重点/ 实验室/ 北京/ 101416/ )/ 摘要/ 为/ 减小/ 时间/ 开销/ ,/ 动态/ 故障/ 树/ 经常/ 被/ 模块化/ 分解/ 为/ 独立/ 的/ 静态/ 子树/ 和/ 独立/ 的/ 动态/ 子树/ ,/ 然后/ 分别/ 使用/ 二叉/ 决策/ 图/ 和/ 马尔卡/ 夫/ 模型/ 求解/ ;/ 其中/ 的/ 一个/ 关键问题/ 便是/ 识别/ 具有/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 的/ 动态/ 故障/ 树中/ 所有/ 的/ 独立/ 模块/ 和/ 最小/ 独立/ 模块/ ./ 文中/ 提出/ 了/ 一个/ 基于/ 亲戚/ 依赖/ 关系/ 的/ 独立/ 模块/ 识别方法/ IIMKDR/ ,/ 该/ 方法/ 将/ 故障/ 树/ 按照/ 其/ 事件/ 之间/ 的/ 依赖/ 关系/ 转换/ 为/ 依赖/ 树/ ;/ 基于/ 面向对象/ 思想/ ,/ 为/ 依赖/ 树/ 及其/ 节点/ 构建/ 对象/ ;/ 通过/ 对/ 各/ 节点/ 对象/ 属性/ 的/ 分析/ ,/ 得出/ 独立/ 模块/ 集/ 并/ 进而/ 求/ 出/ 最小/ 独立/ 模块/ 集/ ./ 最后/ 对/ IIMKDR/ 方法/ 进行/ 了/ 理论/ 分析/ 和/ 实验/ 验证/ ,/ 分析表明/ 该/ 方法/ 适用/ 于/ 具有/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 的/ 动态/ 故障/ 树/ 独立/ 模块/ 识别/ ./ 与/ 其它/ 方法/ 从/ 多个/ 角度/ 所/ 进行/ 的/ 实验/ 对比/ 显示/ ,/ 当/ 故障/ 树/ 没有/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 时/ ,/ 该/ 方法/ 的/ 开销/ 略高于/ 其它/ 方法/ ;/ 当/ 故障/ 树/ 具有/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 时/ ,/ 该/ 方法/ 能够/ 正确/ 识别/ 其中/ 所有/ 的/ 独立/ 模块/ ,/ 而/ 其它/ 方法/ 不/ 具备/ 这样/ 的/ 功能/ ./ 关键词/ 动态/ 故障/ 树/ ;/ 独立/ 模块/ 识别/ ;/ 相互依赖/ 基本/ 事件/ ;/ 重复/ 事件/ ;/ 可靠性/ 分析/ 1/ 引言/ 故障/ 树/ (/ FaultTree/ ,/ FT/ )/ 被/ 广泛应用/ 在/ 系统可靠性/ 分析/ 中/ ,/ 为/ 系统/ 的/ 失效/ 行为/ 提供/ 了/ 一个/ 简单/ 直观/ 的/ 描述/ 方式/ ./ 传统/ 的/ 静态/ 故障/ 树/ (/ StaticFaultTree/ ,/ SFT/ )/ 通过/ 对/ 各/ 基本/ 事件/ 失效/ 的/ 布尔/ 组合/ 逻辑/ 可/ 得到/ 系统/ 的/ 失效/ 函数/ ./ 静态/ 故障/ 树/ 一般/ 包括/ AND/ 、/ OR/ 、/ VOTE/ 等/ 布尔/ 逻辑/ 门/ ,/ 通常/ 可以/ 使用/ 二值/ 决策/ 图/ (/ BinaryDecisionDiagram/ ,/ BDD/ )/ 方法/ 求解/ ./ 随着/ 实践/ 中/ 对/ 可靠性/ 要求/ 的/ 提高/ 以及/ 一些/ 可靠性/ 设计/ 技术/ 的/ 应用/ ,/ 出现/ 了/ 越来越/ 多/ 的/ 动态/ 系统/ ,/ 这些/ 系统/ 中/ 各/ 元件/ 之间/ 具有/ 一定/ 的/ 动态/ 顺序/ 依赖/ 关系/ ./ 静态/ 故障/ 树/ 无法/ 对/ 动态/ 系统/ 进行/ 建模/ 分析/ ,/ 文献/ [/ 1/ ]/ 通过/ 引入/ 动态/ 逻辑/ 门将/ 故障/ 树/ 扩展/ 为/ 动态/ 故障/ 树/ (/ DynamicFaultTree/ ,/ DFT/ )/ ,/ 从而/ 使/ 其/ 具有/ 对/ 动态/ 系统/ 进行/ 建模/ 分析/ 的/ 能力/ ./ 由于/ 动态/ 故障/ 树中/ 各/ 事件/ 之间/ 具有/ 时序/ 依赖/ 关系/ ,/ 因此/ 无法/ 使用/ 数值/ 组合/ 逻辑/ 进行/ 求解/ ,/ 一般/ 使用/ 马尔卡/ 夫/ 模型/ 进行/ 求解/ [/ 2/ ]/ ./ 然而/ 马尔卡/ 夫/ 模型/ 具有/ 固有/ 的/ 局限性/ ,/ 其所/ 涉及/ 到/ 的/ 系统/ 状态/ 数/ 与/ 系统/ 基本/ 事件/ 数/ 呈/ 指数/ 级/ 关系/ ,/ 当/ 系统/ 的/ 规模/ 比较/ 大时/ (/ 实际/ 应用/ 的/ 系统/ 大都/ 属于/ 此类/ )/ ,/ 为/ 马尔卡/ 夫/ 模型/ 建立/ 状态/ 转移/ 矩阵/ 将/ 变成/ 一个/ 不可/ 完成/ 的/ 任务/ ,/ 即/ 所谓/ 的/ 状态/ 空间/ 爆炸/ 问题/ ./ 状态/ 空间/ 爆炸/ 问题/ 大大/ 限制/ 了/ 马尔卡/ 夫/ 模型/ 的/ 应用/ ./ 为/ 解决/ 状态/ 空间/ 爆炸/ 问题/ ,/ 业界/ 进行/ 了/ 许多/ 研究/ ./ 文献/ [/ 3/ ]/ 给出/ 了/ 一种/ 数值/ 分析方法/ (/ DigitalNumericalAnalysis/ ,/ DNA/ )/ 来/ 对/ 动态/ 故障/ 树/ 进行/ 分析/ ,/ 该/ 方法/ 具有/ 简单/ 、/ 直观/ 、/ 快速/ 和/ 准确/ 的/ 优点/ ./ 针对/ 现在/ 许多/ 系统/ 包含/ 大量/ 冗余/ 和/ 备份/ 部件/ ,/ 这些/ 部件/ 或/ 模块/ 可靠性/ 特征/ 完全相同/ ,/ 文献/ [/ 4/ ]/ 提出/ 了/ 一种/ 参数/ 化/ 故障/ 树/ (/ ParametricFaultTree/ ,/ PFT/ )/ 模型/ ,/ 利用/ BDD/ 方法/ 的/ 简单/ 快捷/ 特性/ ,/ 给出/ 了/ 一种/ 参数/ 化/ 二叉/ 决策/ 图/ (/ ParametricBDD/ ,/ PBDD/ )/ 方法/ ./ 文献/ [/ 5/ ]/ 使用/ 一个/ 混合/ 贝叶斯/ 网络/ 框架/ 来/ 分析/ 求解/ 动态/ 故障/ 树/ ,/ 该/ 框架/ 并不需要/ 数值积分/ 和/ 模拟/ ./ 文献/ [/ 6/ ]/ 提出/ 了/ 一种/ 对/ 动态/ 故障/ 树/ 优先/ 与/ 门/ 进行/ 定量分析/ 的/ 方法/ ./ 文献/ [/ 2/ ]/ 将/ 马尔卡/ 夫/ 模型/ 中/ 的/ 状态/ 转移/ 图/ 分解/ 为/ 几个/ 状态/ 转移/ 链/ ,/ 根据/ 每个/ 链/ 的/ 长度/ 获得/ 该链/ 的/ 概率/ 公式/ ./ 文献/ [/ 7/ ]/ 把/ 动态/ 逻辑/ 门/ 转化/ 为/ 相应/ 的/ 动态/ 贝叶斯/ 网络/ ,/ 以/ 计算/ 节点/ 失效/ 概率/ 和/ 进行/ 重要/ 度/ 分析/ ./ 以上/ 方法/ 都/ 需要/ 识别/ 出/ 故障/ 树中/ 的/ 独立/ 模块/ 、/ 尤其/ 是/ 最小/ 独立/ 模块/ ;/ 模块化/ [/ 8/ ]/ 是/ 解决/ 状态/ 空间/ 爆炸/ 问题/ 最/ 根本/ 的/ 途径/ ,/ 其/ 通过/ 将/ 整个/ 故障/ 树/ 分解/ 为/ 多个/ 独立/ 模块/ ,/ 静态/ 模块/ 使用/ 数值/ 组合/ 或/ BDD/ 方法/ 进行/ 求解/ ,/ 动态/ 模块/ 使用/ 马尔卡/ 夫/ 模型/ 进行/ 求解/ ,/ 最后/ 再/ 综合/ 求/ 出/ 故障/ 树顶/ 层/ 的/ 可靠性/ 参数/ ,/ 从而/ 将/ 求解/ 时间/ 开销/ 从/ 指数/ 级/ 降低/ 为/ 多项式/ 级/ ./ 另外/ ,/ 包括/ 灵敏性/ 分析/ 在内/ 的/ 许多/ 可靠性/ 分析/ 领域/ 也/ 依赖于/ 故障/ 树中/ 独立/ 模块/ 的/ 识别/ ./ 故障/ 树中/ 独立/ 模块/ 的/ 识别方法/ 研究/ 在/ 可靠性/ 分析/ 领域/ 具有/ 极其重要/ 的/ 意义/ ./ 静态/ 故障/ 树仅/ 包含/ 表征/ 组合/ 逻辑关系/ 的/ 静态/ 逻辑/ 门/ ,/ 文献/ [/ 9/ ]/ 给出/ 了/ 一个/ 识别/ 静态/ 故障/ 树中/ 独立/ 模块/ 的/ 方法/ ,/ 它/ 对/ 故障/ 树/ 进行/ 一次/ 深度/ 遍历/ ,/ 并/ 为/ 每个/ 节点/ 标注/ 首次/ 访问/ 时间/ 和/ 末/ 次访问/ 时间/ ,/ 若/ 某个/ 节点/ 的/ 所有/ 子/ 节点/ 的/ 最先/ 首次/ 访问/ 时间/ 和/ 最后/ 末/ 次访问/ 时间/ 分别/ 大于/ 该/ 节点/ 的/ 首次/ 访问/ 时间/ 和/ 小于/ 该/ 节点/ 的/ 末/ 次访问/ 时间/ ,/ 则/ 该/ 节点/ 及其/ 子孙/ 节点/ 构成/ 一个/ 独立/ 模块/ ./ 使用/ 深度/ 遍历/ 算法/ ,/ 其/ 计算/ 复杂度/ 为/ O/ (/ N/ )/ ,/ 其中/ N/ 为/ 故障/ 树/ 的/ 节点/ 个数/ ./ 该/ 方法/ 的/ 缺点/ 有/ :/ 只能/ 应用/ 于/ 静态/ 故障/ 树/ ,/ 在/ 遍历/ 过程/ 中/ ,/ 一旦/ 发现/ 动态/ 逻辑/ 门/ 就/ 会/ 停止/ 遍历/ ;/ 故障/ 树中/ 各/ 基本/ 事件/ 相互/ 独立/ ,/ 不/ 含/ 重复/ 事件/ ./ 文献/ [/ 10/ ]/ 在/ 文献/ [/ 9/ ]/ 的/ 基础/ 上/ ,/ 提出/ 了/ 故障/ 树中/ 含有/ 相互依赖/ 基本/ 事件/ 的/ 模块/ 识别方法/ ./ 它/ 为/ 每个/ 事件/ 建立/ 依赖/ 信息/ ,/ 并/ 根据/ 故障/ 树/ 的/ 结构/ 使/ 依赖/ 信息/ 在/ 各/ 事件/ 中/ 传递/ ,/ 各/ 事件/ 的/ 依赖/ 信息/ 结合/ 访问/ 时间/ 确定/ 故障/ 树/ 的/ 独立/ 模块/ ./ 其/ 缺点/ 在于/ :/ 若/ 故障/ 树/ 含有/ 重复/ 事件/ 或/ 动态/ 逻辑/ 门/ ,/ 则/ 该/ 方法/ 仍然/ 无能为力/ ./ 该/ 方法/ 本质/ 上/ 是/ 属于/ 构建/ 独立/ 模块/ ,/ 而/ 不是/ 识别/ 独立/ 模块/ ,/ 而/ 如何/ 构建/ 仅仅/ 通过/ 一个/ 实例/ 说明/ ,/ 并未/ 形成/ 一个/ 严谨/ 的/ 形式化/ 算法/ ./ 动态/ 故障/ 树/ 不仅/ 包含/ 表征/ 组合/ 逻辑关系/ 的/ 静态/ 逻辑/ 门/ ,/ 还/ 包含/ 表征/ 顺序/ 依赖/ 关系/ 的/ 动态/ 逻辑/ 门/ ,/ 另外/ 动态/ 故障/ 树/ 可能/ 还/ 含有/ 重复/ 事件/ ,/ 基本/ 事件/ 间/ 可能/ 还/ 存在/ 依赖/ 关系/ ,/ 识别/ 动态/ 故障/ 树中/ 的/ 独立/ 模块/ 因此/ 变得/ 非常/ 困难/ ./ 文献/ [/ 11/ -/ 12/ ]/ 在/ 文献/ [/ 9/ ]/ 的/ 基础/ 上/ ,/ 虽然/ 提出/ 了/ 一个/ 适用/ 于/ 动态/ 故障/ 树/ 的/ 独立/ 模块/ 识别/ 算法/ ,/ 但/ 其/ 并未/ 考虑/ 动态/ 故障/ 树中/ 包含/ 相互/ 依/ Page3/ 赖/ 基本/ 事件/ 和/ 重复/ 事件/ 的/ 情形/ ,/ 无法/ 在/ 这种/ 情形/ 下/ 应用/ ./ 本文/ 在/ 以上/ 研究/ 的/ 基础/ 上/ ,/ 提出/ 了/ 一个/ 适用/ 于/ 动态/ 故障/ 树/ 的/ 基于/ 亲戚/ 依赖/ 关系/ 的/ 独立/ 模块/ 识别方法/ (/ IdentificationofIndependentModulebasedonKinshipDependencyRelation/ ,/ IIMKDR/ )/ ,/ 其/ 与/ 以上/ 研究/ 不同之处/ 在于/ :/ 将/ 动态/ 故障/ 树/ 转化/ 为/ 依赖/ 树/ ,/ 依赖/ 树/ 只/ 包含/ 事件/ 之间/ 的/ 依赖/ 信息/ ,/ 去/ 除了/ 故障/ 树中/ 各/ 逻辑/ 门/ 的/ 逻辑/ 含义/ ;/ 改进/ 深度/ 优先/ 遍历/ 算法/ ,/ 使/ 其/ 适用/ 于/ 含有/ 重复/ 事件/ 的/ 情况/ ;/ 为/ 每个/ 节点/ 加入/ 祖先/ 集/ 属性/ 和/ 依赖/ 集/ 属性/ ,/ 当/ 进行/ 深度/ 优先/ 遍/ 历时/ 填充/ 祖先/ 集/ 属性/ ,/ 将/ 所有/ 基本/ 事件/ 划分/ 为/ 不同/ 的/ 依赖/ 类型/ ,/ 根据/ 各/ 基本/ 事件/ 的/ 祖先/ 集/ 属性/ 更新/ 所有/ 节点/ 的/ 依赖/ 集/ 属性/ ./ 本/ 方法/ 抛弃/ 了/ 以前/ 研究/ 中以/ 深度/ 遍历/ 访问/ 顺序/ 进行/ 独立/ 模块/ 识别/ 的/ 思想/ ,/ 改以/ 各/ 节点/ 的/ 祖先/ 集/ 属性/ 和/ 依赖/ 集/ 属性/ 进行/ 识别/ ,/ 其/ 与/ 相互依赖/ 基本/ 事件/ 、/ 重复/ 事件/ 、/ 动态/ 逻辑/ 门/ 无关/ ,/ 适用/ 于/ 具有/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 的/ 动态/ 故障/ 树/ ./ 为了/ 便于/ 说明/ ,/ 在/ 不/ 引起/ 混淆/ 的/ 情况/ 下/ ,/ 后文/ 对于/ 文献/ [/ 9/ -/ 11/ ]/ 所/ 给出/ 的/ 方法/ 与/ 利用/ 其/ 方法/ 得出/ 的/ 数据/ 分别/ 用/ 其/ 作者/ 姓氏/ Dutuit/ 、/ Sun/ 和/ Huang/ 标示/ ./ 本文/ 第/ 2/ 节/ 介绍/ 本文/ 用到/ 的/ 基本概念/ ;/ 第/ 3/ 节/ 简要/ 概括/ IIMKDR/ 方法/ 的/ 识别/ 流程/ ;/ 第/ 4/ ~/ 6/ 节/ 详细描述/ 识别/ 流程/ 的/ 各个/ 步骤/ ,/ 分别/ 是/ 预处理/ 、/ 构建/ 依赖/ 树/ 、/ 识别/ 等/ ;/ 第/ 7/ 节对/ IIMKDR/ 方法/ 进行/ 详细/ 的/ 时间/ 复杂性/ 分析/ ,/ 并/ 与/ 其它/ 方法/ 在/ 性能/ 上/ 进行/ 理论/ 分析/ 和/ 对比/ ;/ 第/ 8/ 节/ 分别/ 使用/ 实际/ 案例/ 和/ 仿真/ 模拟/ 对/ IIMKDR/ 方法/ 从/ 多个/ 角度/ 进行/ 验证/ ,/ 并/ 将/ IIMK/ -/ DR/ 方法/ 和/ 其它/ 方法/ 的/ 实验/ 结果/ 进行/ 对比/ 分析/ ;/ 最后/ 得出/ 本文/ 的/ 结论/ ./ 2/ 基本概念/ 动态/ 故障/ 树/ 的/ 构建/ 是/ 在/ 静态/ 故障/ 树/ 的/ 基础/ 上/ ,/ 通过/ 引入/ 多个/ 动态/ 逻辑/ 门/ 使得/ 故障/ 树/ 具有/ 了/ 描述/ 动态/ 行为/ 的/ 能力/ ./ 本节/ 首先/ 介绍/ 各/ 动态/ 逻辑/ 门/ ,/ 然后/ 阐述/ 本文/ 所/ 提出/ 的/ 相关/ 概念/ ./ 2.1/ 动态/ 逻辑/ 门/ (/ 1/ )/ PAND/ 门/ 优先/ 与/ 门/ (/ Priority/ -/ ANDGate/ ,/ PAND/ )/ 是/ AND/ 门/ 的/ 拓展/ ,/ 它/ 在/ AND/ 门/ 的/ 基础/ 上/ 增加/ 一个/ 附加条件/ ,/ 这个/ 条件/ 规定/ 了/ 输入/ 事件/ 的/ 发生/ 次序/ ./ 例如/ ,/ 对于/ 具有/ 一个/ 输出/ 事件/ 和/ 两个/ 输入/ 事件/ (/ A/ 和/ B/ )/ 的/ PAND/ 门/ ,/ 当且/ 仅/ 当/ 下列/ 两个/ 条件/ 同时/ 满足/ 时/ ,/ 输出/ 事件/ 发生/ :/ ①/ 事件/ A/ 和/ B/ 都/ 发生/ ;/ ②/ 事件/ A/ 先于/ 事件/ B/ 发生/ ./ PAND/ 门/ 的/ 图形符号/ 如图/ 1/ (/ a/ )/ 所示/ ./ 如果/ A/ 或/ B/ 没有/ 发生/ 或者/ B/ 在/ A/ 之前/ 发生/ ,/ 则/ 输出/ 事件/ 不会/ 发生/ ./ (/ 2/ )/ WSP/ 门/ 温备/ 门/ (/ Warm/ -/ SpareGate/ ,/ WSP/ )/ 具有/ 一个/ 初始/ 输入/ 和/ 若干/ 替补/ 输入/ ./ 初始/ 输入/ 是/ 指/ 在/ 系统/ 开始/ 工作/ 时/ 就/ 处于/ 工作/ 状态/ 的/ 部件/ ,/ 替补/ 输入/ 作为/ 温/ 储备/ ,/ 在/ 工作/ 部件/ 失效/ 前/ ,/ 替补/ 处于/ 温备/ 状态/ ,/ 工作/ 部件/ 失效/ 后/ ,/ 逐个/ 依次/ 替补/ ./ WSP/ 门/ 具有/ 一个/ 输出/ 事件/ ,/ 仅当/ 所有/ 输入/ 事件/ (/ 初始/ 输入/ 和/ 替补/ 输入/ )/ 发生/ 后/ ,/ 输出/ 事件/ 才/ 会/ 发生/ ./ WSP/ 门/ 的/ 图形符号/ 如图/ 1/ (/ b/ )/ 所示/ ./ FDEP/ )/ 由/ 以下/ 3/ 种/ 事件/ 构成/ :/ 本/ 事件/ ,/ 也/ 可以/ 是/ 故障/ 树中/ 其它/ 门/ 的/ 输出/ ;/ (/ 3/ )/ FDEP/ 门/ 功能/ 相关/ 门/ (/ Functional/ -/ DependencyGate/ ,/ ①/ 触发/ 输入/ 事件/ ./ 触发/ 输入/ 事件/ 可以/ 是/ 一个/ 基/ ②/ 非/ 相关/ 输出/ 事件/ ./ 主要/ 反映/ 触发/ 事件/ 的/ 状态/ ;/ ③/ 若干/ 相关/ 基本/ 事件/ ./ 相关/ 基本/ 事件/ 在/ 功能/ 上/ 依赖于/ 触发/ 事件/ ,/ 当/ 触发/ 事件/ 发生/ 时/ ,/ 相关/ 基本/ 事件/ 强制/ 发生/ ./ FDEP/ 门/ 的/ 图形符号/ 如图/ 1/ (/ c/ )/ 所示/ ./ FDEP/ 门/ 的/ 特征/ 是/ :/ 当/ 触发/ 事件/ 发生/ 时/ ,/ 直接/ 产生/ 输出/ ,/ 而/ 所有/ 相关/ 事件/ 随即/ 成为/ 不可/ 达/ 或/ 无法/ 使用/ ./ FDEP/ 门/ 的/ 非/ 相关/ 输出/ 事件/ 并/ 不/ 对/ DFT/ 中/ 的/ 其它/ 结构/ 产生/ 影响/ ,/ FDEP/ 门/ 主要/ 通过/ 约束/ 相关/ 基本/ 事件/ 的/ 行为/ 达到/ 控制系统/ 工作/ 过程/ 的/ 目的/ ./ 2.2/ 其它/ 相关/ 概念/ (/ 1/ )/ 重复/ 事件/ 若/ 某个/ 事件/ 同时/ 是/ 两个/ 或/ 两个/ 以上/ 逻辑/ 门/ 的/ 输入/ 事件/ ,/ 则/ 该/ 事件/ 为/ 重复/ 事件/ ./ (/ 2/ )/ 依赖/ 关系/ 有/ 两个/ 事件/ a/ 、/ b/ ,/ 若/ a/ 的/ 失效/ 影响/ b/ 的/ 失效/ 概率/ 或/ b/ 的/ 失效/ 影响/ a/ 的/ 失效/ 概率/ ,/ 则/ 称/ a/ 和/ b/ 具有/ 依赖/ 关系/ ./ 基本/ 事件/ 间/ 相互依赖/ 的/ 原因/ 来自/ 于/ 基本/ 事件/ 间共因/ 故障/ 的/ 存在/ ./ 设/ p/ (/ a/ )/ 和/ p/ (/ b/ )/ 分别/ 表示/ 基本/ 事/ Page4/ 件/ a/ 和/ b/ 的/ 失效/ 概率/ ,/ p/ (/ a/ |/ b/ )/ 表示/ 在/ b/ 失效/ 的/ 条件/ 下/ a/ 的/ 失效/ 概率/ ,/ 则/ a/ 和/ b/ 相互依赖/ 用/ 数学公式/ 可以/ 表示/ 为/ p/ (/ a/ |/ b/ )/ ≠/ p/ (/ a/ )/ 或/ p/ (/ b/ |/ a/ )/ ≠/ p/ (/ b/ )/ ./ (/ 3/ )/ 依赖/ 类型/ 共因/ 故障/ 可以/ 抽象/ 为/ 依赖/ 类型/ ,/ 若/ 某个/ 共因/ 故障/ i/ 影响/ 事件/ a/ 的/ 失效/ 概率/ ,/ 则/ 称/ a/ 依赖于/ 依赖/ 类型/ i/ ./ (/ 4/ )/ 节点/ 称/ A/ 为/ 节点/ ,/ 当且/ 仅/ 当/ A/ 具有/ 以下/ 属性/ :/ 祖先/ 集/ ancestor/ _/ set/ ,/ 父亲/ 集/ parent/ _/ set/ ,/ parent/ _/ set/ / an/ -/ cestor/ _/ set/ ,/ 依赖/ 类型/ 集/ (/ 简称/ 依赖/ 集/ )/ depend/ _/ set/ ,/ 遍历/ 深度/ depth/ ,/ 标号/ ID/ ./ 考虑/ 到/ 故障/ 树中/ 可能/ 含有/ 重复/ 事件/ ,/ 给/ 节点/ 定义/ 属性/ ancestor/ _/ set/ 后/ ,/ 便/ 可/ 从/ 一个/ 节点/ 直接/ 找到/ 该/ 节点/ 的/ 所有/ 祖先/ 节点/ ./ 属性/ depend/ _/ set/ 为/ 节点/ 的/ 依赖/ 类型/ 集合/ ,/ 依赖/ 类型/ 由/ 基本/ 事件/ 之间/ 的/ 依赖/ 关系/ 给定/ ./ 属性/ depth/ 指/ 的/ 是/ 构建/ 依赖/ 树时/ ,/ 该/ 节点/ 的/ 遍历/ 深度/ ,/ 使用/ 该/ 属性/ 以便/ 从/ 独立/ 模块/ 集中/ 找出/ 最小/ 独立/ 模块/ 集/ ./ 属性/ ID/ 指/ 的/ 是/ 该/ 节点/ 的/ 代号/ ,/ 实际上/ 本文/ 在/ 算法/ 实现/ 中/ ,/ 将/ 节点/ 的/ 深度/ 优先/ 遍历/ 次序/ 赋予/ 属性/ ID/ ./ 顶/ 节点/ 的/ 父亲/ 集/ 属性/ 为空/ ;/ 中间/ 节点/ 的/ 父亲/ 集/ 属性/ 不为/ 空/ ,/ 同时/ 还/ 属于/ 其它/ 某个/ 节点/ 的/ 父亲/ 集/ ;/ 叶/ 节点/ 不/ 属于/ 任何/ 其它/ 节点/ 的/ 父亲/ 集/ ./ / ,/ 则/ 称/ a/ 和/ b/ 具有/ 亲戚/ 依赖/ 关系/ ./ a/ ./ ancestor/ _/ set/ ,/ 则/ 称/ a/ 和/ b/ 具有/ 直系/ 血亲/ 关系/ ./ (/ 5/ )/ 直系/ 血亲/ 关系/ 两个/ 节点/ a/ 、/ b/ ,/ 若/ a/ ∈/ b/ ./ ancestor/ _/ set/ 或/ b/ ∈/ (/ 6/ )/ 亲戚/ 依赖/ 关系/ 两个/ 节点/ a/ 、/ b/ ,/ 若/ a/ ./ depend/ _/ set/ ∩/ b/ ./ depend/ _/ set/ ≠/ (/ 7/ )/ 依赖/ 树/ 依赖/ 树/ 具有/ 与其/ 对应/ 故障/ 树/ 完全/ 等价/ 的/ 依赖/ 关系/ ,/ 含有/ 一个顶/ 节点/ 、/ 一个/ 中间/ 节点/ 集合/ 、/ 一个/ 叶/ 节点/ 集合/ ./ 3/ 识别/ 流程/ IIMKDR/ 方法/ 包括/ 依赖/ 树/ 构建/ 算法/ 、/ 独立/ 模块/ 识别/ 算法/ 、/ 最小/ 独立/ 模块/ 识别/ 算法/ 等/ ,/ 这些/ 算法/ 会/ 在/ 后面/ 详细/ 阐述/ ./ IIMKDR/ 方法/ 的/ 识别/ 流程/ 可以/ 分为/ 以下/ 几个/ 步骤/ :/ (/ 1/ )/ 故障/ 树/ 预处理/ 负责/ 对/ 故障/ 树/ 进行/ 一些/ 预先/ 处理/ ,/ 比如/ 化简/ 、/ 变形/ 等/ ,/ 以/ 方便/ 后续/ 处理/ ./ (/ 2/ )/ 构建/ 依赖/ 树/ 动态/ 故障/ 树/ 含有/ 不同/ 类型/ 的/ 逻辑/ 门/ ,/ 各/ 逻辑/ 门/ 的/ 逻辑/ 意义/ 互不/ 相同/ ;/ 然而/ 在/ 识别/ 独立/ 模块/ 时/ ,/ 关注/ 的/ 是/ 各/ 事件/ 之间/ 是否/ 相互依赖/ ,/ 并/ 不/ 关心/ 各/ 事件/ 之间/ 的/ 逻辑关系/ ;/ 因此/ 可/ 从/ 动态/ 故障/ 树中/ 抽取/ 各/ 事件/ 之间/ 的/ 依赖/ 关系/ ,/ 剔除/ 各/ 事件/ 之间/ 的/ 逻辑关系/ ,/ 构建/ 依赖/ 树/ ./ 依赖/ 树/ 完全/ 保持/ 了/ 对应/ 动态/ 故障/ 树/ 的/ 依赖/ 信息/ ,/ 动态/ 故障/ 树/ 的/ 独立/ 模块/ 识别/ 可/ 转化/ 为/ 依赖/ 树/ 的/ 独立/ 模块/ 识别/ ./ 在/ 构建/ 依赖/ 树时/ 填充/ 各/ 节点/ 依赖/ 集/ 属性/ 之外/ 的/ 所有/ 其它/ 相关/ 属性/ ,/ 包括/ 祖先/ 集/ 属性/ 、/ 父亲/ 集/ 、/ 遍历/ 深度/ 等/ ./ (/ 3/ )/ 独立/ 模块/ 识别/ 叶/ 节点/ 的/ 依赖/ 集/ 属性/ 可/ 从/ 系统/ 基本/ 元件/ 间/ 的/ 依赖/ 关系/ 获得/ ,/ 根据/ 叶/ 节点/ 的/ 依赖/ 集/ 属性/ 、/ 祖先/ 集/ 属性/ ,/ 填充/ 其它/ 各/ 节点/ 的/ 依赖/ 集/ 属性/ ./ 然后/ 利用/ 各/ 节点/ 的/ 依赖/ 集/ 属性/ 、/ 祖先/ 集/ 属性/ ,/ 识别/ 出/ 独立/ 模块/ 集/ 和/ 最小/ 独立/ 模块/ 集/ ./ 4/ 故障/ 树/ 预处理/ 故障/ 树结构/ 的/ 预处理/ 旨在/ 不/ 改变/ 其/ 代表/ 的/ 逻辑/ 函数/ 情况/ 下/ ,/ 将/ 其/ 形式/ 简化/ ,/ 删减/ 不必要/ 的/ 逻辑/ 门/ 和/ 事件/ ,/ 以便/ 后续/ 处理/ ./ 本文/ 提出/ 的/ 预处理/ 方法/ 包括/ 以下/ 阶段/ :/ (/ 1/ )/ 收缩/ 串接/ 的/ 同/ 类型/ 逻辑/ 门/ 可以/ 收缩/ 为/ 一个/ 逻辑/ 门/ ./ 这些/ 逻辑/ 门/ 包括/ AND/ 门/ 、/ OR/ 门/ 、/ PAND/ 门/ 和/ SPARE/ 门/ 等/ ,/ 如图/ 2/ 所示/ ./ 同/ 类型/ 串接/ 的/ 静态/ 逻辑/ 门/ 都/ 可以/ 收缩/ 为/ 一个/ 静态/ 逻辑/ 门/ ,/ 如图/ 2/ (/ a/ )/ 和/ 图/ 2/ (/ b/ )/ 所示/ ./ 这样/ 的/ 结论/ 对于/ 动态/ 逻辑/ 门则/ 不/ 一定/ 成立/ ,/ 如图/ 2/ (/ e/ )/ 所示/ ,/ PAND/ 门/ 要求/ 输入/ 的/ 事件/ 按照/ 规定/ 的/ 顺序/ 失效/ 才/ 会/ 导致/ 输出/ 失效/ ,/ 假如/ 事件/ a/ 、/ b/ 、/ c/ 的/ 失效/ 顺序/ 为/ b/ →/ a/ →/ c/ ,/ 则/ 左边/ 会/ 导致/ 输出/ 失效/ ,/ 而/ 右边/ 则/ 不会/ 导致/ 输出/ 失效/ ;/ 对于/ 图/ 2/ (/ c/ )/ 和/ 图/ 2/ (/ d/ )/ 两种/ 形式/ ,/ 收缩/ 结论/ 还是/ 成立/ 的/ ./ 因此/ 同/ 类型/ 串接/ 的/ 动态/ 逻辑/ 门/ 是否/ 能够/ 进行/ 收缩/ 需要/ 进行/ 专门/ 的/ 分析/ ./ (/ 2/ )/ 结合/ 故障/ 树中/ 符合/ 图/ 3/ 和/ 图/ 4/ 所示/ 结构/ 类型/ 的/ (/ 包括/ 但/ 并/ 不/ 限于/ )/ ,/ 可以/ 进行/ 结合/ 处理/ ,/ 以/ 消除/ 一个/ 逻辑/ 门/ ,/ 同时/ 尽可能/ 地/ 消除/ 重复/ 事件/ ,/ 简化/ 后续/ 处理/ ./ 需要/ 注意/ 的/ 是/ ,/ 图/ 4/ (/ b/ )/ 并/ 不能/ 成立/ ,/ 理由/ 同上/ 文/ 收缩/ 阶段/ ./ (/ 3/ )/ 消/ 去/ 根据/ 故障/ 树所/ 表达/ 的/ 静态/ 或/ 动态/ 逻辑/ 意义/ ,/ 消/ Page5/ 图/ 3/ 故障/ 树/ 预处理/ 结合/ 阶段/ (/ 仅/ 含/ 静态/ 逻辑/ 门/ )/ 去/ 一些/ 冗余/ 的/ 逻辑/ 门/ 或/ 事件/ ,/ 以/ 简化/ 处理/ ./ 比如/ 符合/ 图/ 5/ 所示/ 结构/ 类型/ 的/ (/ 包括/ 但/ 并/ 不/ 限于/ )/ ,/ 便/ 可以/ 进行/ 消/ 去/ 处理/ ./ (/ 4/ )/ 宏/ 事件/ 始终/ 成组/ 以/ 固定/ 逻辑/ 出现/ 的/ 基本/ 事件/ 可以/ 看做/ 是/ 一个/ 宏/ 事件/ ,/ 在/ 后续/ 处理/ 中/ ,/ 以此/ 宏/ 事件/ 代替/ 该组/ 基本/ 事件/ ,/ 减少/ 事件/ 数目/ ./ 图/ 4/ 故障/ 树/ 预处理/ 结合/ 阶段/ (/ 含/ 动态/ 逻辑/ 门/ )/ (/ 5/ )/ FDEP/ 门/ FDEP/ 决定/ 了/ 触发/ 输入/ 事件/ 与/ 其它/ 输入/ 事件/ 之间/ 的/ 依赖/ 关系/ ,/ 因/ 其/ 没有/ 输出/ 事件/ 外联/ ,/ 此/ FDEP/ 等效于/ 多个/ OR/ 门/ 串接/ ,/ 如图/ 6/ 所示/ ./ 在/ 故障/ 树中/ 可/ 分别/ 以/ I1/ 、/ I2/ 代替/ I1/ 、/ I2/ ./ Page65/ 依赖/ 树/ 构建/ 故障/ 树/ 刻画/ 了/ 事件/ 之间/ 的/ 各种/ 关系/ ,/ 包括/ 静态/ 组合/ 逻辑关系/ 和/ 动态/ 时序/ 关系/ ,/ 但是/ 当/ 进行/ 独立/ 模块/ 识别/ 时/ ,/ 关注/ 的/ 仅仅/ 是/ 节点/ 之间/ 是否/ 具有/ 依赖/ 关系/ ./ 为了/ 提高/ 识别/ 效率/ ,/ 有/ 必要/ 从/ 故障/ 树中/ 提取/ 节点/ 之间/ 的/ 依赖/ 关系/ 构建/ 依赖/ 树/ ,/ 之后/ 进行/ 的/ 独立/ 模块/ 识别/ 都/ 是/ 建立/ 在/ 依赖/ 树/ 的/ 基础/ 上/ ./ 基于/ 面向对象/ 思想/ 为/ 节点/ 和/ 依赖/ 树/ 构建/ 对象/ ,/ 节点/ 对象/ 具有/ 以下/ 属性/ :/ 祖先/ 集/ ancestor/ _/ set/ ,/ 父亲/ 集/ parent/ _/ set/ ,/ 依赖/ 集/ depend/ _/ set/ ,/ 遍历/ 深度/ depth/ ,/ 标号/ ID/ ;/ 依赖/ 树/ 对象/ 具有/ 以下/ 属性/ :/ 顶/ 节点/ s/ ,/ 中间/ 节点/ 集/ MNS/ ,/ 叶/ 节点/ 集/ LNS/ ./ 通过/ 对/ 故障/ 树/ 进行/ 深度/ 优先/ 遍/ 历来/ 构建/ 依赖/ 树/ ./ 算法/ 1/ 为/ 依赖/ 树/ 构建/ 算法/ DTC/ :/ 前/ 2/ 行/ 构建/ 着色/ 数组/ color/ ;/ 第/ 4/ 行/ 的/ count/ 变量/ 表征/ 各/ 节点/ 的/ 遍历/ 次序/ ,/ 此值/ 将/ 赋/ 给/ 相应/ 节点/ 的/ ID/ 属性/ ;/ 依赖/ 树/ 节点/ 构建/ 算法/ CreateDTNode/ ,/ 如/ 算法/ 2/ 所示/ ,/ 根据/ 依赖/ 树/ 节点/ 的/ 对象/ 大小/ ,/ 在/ 内存/ 中/ 分配/ 相应/ 的/ 空间/ ,/ 并/ 将/ 所有/ 属性/ 值设/ 为/ 空集/ 或/ 0/ ,/ 这些/ 属性/ 值/ 在/ 后续/ 遍/ 历时/ 进行/ 填充/ ;/ 在/ 开始/ 遍历/ 前/ ,/ 依赖/ 树/ 的/ LNS/ 和/ MNS/ 属性/ 为空/ ,/ 然后/ 调用/ 深度/ 遍历/ 算法/ DFS/ _/ VISIT/ ./ 算法/ 1/ ./ 依赖/ 树/ 构建/ 算法/ DTC/ ./ DTC/ (/ FT/ ,/ DT/ )/ 功能/ :/ 从/ 故障/ 树/ 构建/ 依赖/ 树/ 对象/ 输入/ :/ 故障/ 树/ FT/ (/ V/ ,/ E/ )/ ,/ s/ 为/ 顶/ 事件/ ;/ 输出/ :/ 依赖/ 树/ 对象/ DT/ ;/ 1/ ./ foreacheventu/ ∈/ V2/ ./ docolor/ [/ u/ ]/ ←/ WHITE/ ;/ 3/ ./ u/ ←/ s/ ;/ 4/ ./ count/ ←/ 0/ ;/ 5/ ./ time/ ←/ 0/ ;/ 6/ ./ u0/ ←/ CreateDTNode/ (/ )/ ;/ 7/ ./ DT/ ./ s/ ←/ u0/ ;/ 8/ ./ DT/ ./ LNS/ ←/ / ;/ DT/ ./ MNS/ ←/ / ;/ 9/ ./ DFS/ _/ VISIT/ (/ u/ ,/ u0/ )/ ;/ 10/ ./ returnDT/ ./ 算法/ 2/ ./ 依赖/ 树/ 节点/ 构建/ 函数/ CreateDTNode/ ./ CreateDTNode/ (/ )/ 功能/ :/ 构建/ 依赖/ 树/ 节点/ 输入/ :/ 无/ 输出/ :/ 依赖/ 树/ 节点/ 1/ ./ u0/ =/ newDTNode/ (/ )/ ;/ 2/ ./ u0/ ./ parent/ _/ set/ ←/ / ;/ 3/ ./ u0/ ./ ID/ ←/ 0/ ;/ 4/ ./ u0/ ./ depend/ _/ set/ ←/ / ;/ 5/ ./ u0/ ./ depth/ ←/ 0/ ./ 算法/ 3/ 深度/ 优先/ 遍历/ 函数/ DFS/ _/ VISIT/ 为/ 一个/ 递归/ 算法/ ,/ 对/ 故障/ 树/ 从/ 事件/ u/ 开始/ 遍历/ ,/ 并/ 相应/ 从/ 依赖/ 树中/ 节点/ u0/ 开始/ 构建/ 依赖/ 树/ 节点/ ,/ 填写/ 各/ 节点/ 的/ 有关/ 属性/ 值/ ./ 在/ 遍历/ 过程/ 中/ ,/ 通过/ 对/ 事件/ 进行/ 着色/ 来/ 表示/ 事件/ 的/ 状态/ ./ 开始/ 时/ ,/ 每个/ 事件/ 均/ 为/ 白色/ ,/ 搜索/ 中/ 被/ 发现/ 时即/ 置/ 为/ 灰色/ ./ 每次/ 调用/ DFS/ _/ VISIT/ (/ u/ ,/ u0/ )/ 时/ ,/ 事件/ u/ 和/ 节点/ u0/ 分别/ 成为/ 故障/ 树/ 和/ 依赖/ 树中/ 深度/ 优先/ 森林/ 中/ 一颗/ 新树/ 的/ 根/ ,/ 事件/ u/ 开始/ 为/ 白色/ ,/ 第/ 2/ 行置/ u/ 为/ 灰色/ ,/ 表示/ 开始/ 对/ 事件/ u/ 进行/ 遍历/ ;/ 当/ 事件/ u/ 的/ 邻接/ 表/ adj/ 为/ 空时/ ,/ 表示/ 该/ 事件/ 为/ 故障/ 树/ 的/ 基本/ 事件/ ,/ 第/ 7/ 行将/ 相应/ 节点/ 加入/ 依赖/ 树/ 的/ 叶/ 节点/ 集合/ ;/ 第/ 9/ ~/ 25/ 行/ 检查和/ u/ 相邻/ 接/ 的/ 每个/ 节点/ v/ ,/ 如果/ v/ 为/ 白色/ 节点/ ,/ 表示/ 该/ 节点/ 还/ 未/ 被/ 访问/ ,/ 需/ 构建/ 相对/ 应/ 的/ 依赖/ 树/ 节点/ v0/ ,/ 设置/ v0/ 相关/ 属性/ ,/ 并/ 从/ 节点/ v/ 递归/ 遍历/ ;/ 否则/ ,/ 仅/ 需/ 填充/ v0/ 相关/ 属性/ 并/ 从/ 节点/ v/ 递归/ 遍历/ 即可/ ./ 传统/ 的/ 深度/ 遍历/ 算法/ 没有/ 第/ 20/ ~/ 25/ 行/ 代码/ ,/ 为了/ 支持/ 含有/ 重复/ 事件/ 的/ 故障/ 树/ ,/ 特/ 加入/ 这/ 5/ 行/ 代码/ :/ 即/ 如果/ v/ 并非/ 白色/ ,/ 则/ 表示/ 该/ 事件/ 已/ 被/ 访问/ 且/ v/ 有/ 两个/ 或/ 多个/ 父/ 事件/ ,/ 相应/ 的/ 依赖/ 树/ 节点/ v0/ 也/ 已/ 被/ 创建/ ,/ 但/ 需/ 将/ v0/ 的/ 属性/ parent/ _/ set/ 和/ ancestor/ _/ set/ 进行/ 相应/ 的/ 更新/ ,/ 其/ 子孙/ 节点/ 的/ 相应/ 属性/ 也/ 应/ 进行/ 相应/ 的/ 更新/ ,/ 故/ 仍/ 需/ 递归/ 遍历/ 事件/ v/ ./ 第/ 18/ 行为/ 故障/ 树/ 事件/ 和/ 相应/ 的/ 依赖/ 树/ 节点/ 映射/ 表/ ,/ 第/ 21/ 行/ 根据/ 故障/ 树/ 事件/ 获取/ 依赖/ 树/ 节点/ 对象/ ./ 算法/ 3/ ./ 深度/ 优先/ 遍历/ 算法/ DFS/ _/ VISIT/ ./ DFS/ _/ VISIT/ (/ u/ ,/ u0/ )/ 功能/ :/ 对/ 故障/ 树/ 进行/ 遍历/ ,/ 并/ 相应/ 构建/ 依赖/ 树/ 节点/ 输入/ :/ 故障/ 树/ 事件/ u/ ,/ 邻接矩阵/ adj/ ,/ 依赖/ 树/ 节点/ u0/ 输出/ :/ 从/ 节点/ u0/ 开始/ 构建/ 的/ 各/ 依赖/ 树/ 节点/ 1/ ./ if/ (/ color/ [/ u/ ]/ =/ =/ WHITE/ )/ 2/ ./ color/ [/ u/ ]/ ←/ GRAY/ ;/ 3/ ./ time/ ←/ time/ +/ 1/ ;/ 4/ ./ d/ [/ u/ ]/ ←/ time5/ ./ ifadj/ [/ u/ ]/ =/ =/ NULL6/ ./ then7/ ./ DT/ ./ LNS/ ←/ DT/ ./ LNS/ ∪/ {/ u0/ }/ ;/ 8/ ./ else9/ ./ foreachv/ ∈/ adj/ [/ u/ ]/ 10/ ./ doifcolor/ [/ v/ ]/ =/ WHITEPage711/ ./ then12/ ./ v0/ ←/ CreateDTNode/ (/ )/ ;/ 13/ ./ count/ ←/ count/ +/ 1/ ;/ 14/ ./ v0/ ./ parent/ _/ set/ ←/ {/ u0/ }/ 15/ ./ v0/ ./ ancestor/ _/ set/ ←/ v0/ ./ ancestor/ _/ set/ ∪/ 16/ ./ v0/ ./ ID/ ←/ count/ ;/ 17/ ./ v0/ ./ depth/ ←/ u0/ ./ depth/ +/ 1/ ;/ 18/ ./ FTMapDT/ (/ v/ ,/ v0/ )/ ;/ 19/ ./ DFS/ _/ VISIT/ (/ v/ ,/ v0/ )/ ;/ 20/ ./ else21/ ./ v0/ ←/ MapToDTNode/ (/ v/ )/ ;/ 22/ ./ v0/ ./ parent/ _/ set/ ←/ v0/ ./ parent/ _/ set/ ∪/ {/ u0/ }/ 23/ ./ v0/ ./ ancestor/ _/ set/ ←/ v0/ ./ ancestor/ _/ set/ ∪/ 24/ ./ time/ ←/ time/ +/ 2/ ;/ 25/ ./ DFS/ _/ VISIT/ (/ v/ ,/ v0/ )/ ;/ 26/ ./ if/ (/ color/ [/ u/ ]/ =/ =/ GRAY/ )/ 27/ ./ color/ [/ u/ ]/ ←/ BLACK/ ;/ 28/ ./ time/ ←/ time/ +/ 1/ ./ 图/ 7/ 为/ 一个/ 简单/ 故障/ 树/ 示例/ ,/ 图/ 8/ 说明/ 了/ 函数/ DFS/ _/ VISIT/ 在/ 图/ 7/ 上/ 的/ 工作/ 过程/ ./ 执行/ 完毕/ 后/ ,/ 每个/ 节点/ 除去/ 依赖/ 集/ 属性/ 外/ 其它/ 属性/ (/ 图/ 8/ 仅/ 显示/ parent/ _/ set/ 和/ ancestor/ _/ set/ 属性/ )/ 都/ 已经/ 得到/ 填充/ ,/ 图/ 8/ 深度/ 优先/ 遍历/ 函数/ DFS/ _/ VISIT/ 在/ 故障/ 树上/ 的/ 工作/ 过程/ ./ 每个/ 事件/ u/ 旁有/ 三元组/ 向量/ (/ v1/ ,/ v2/ ,/ v3/ )/ ,/ 其中/ v1/ 表示/ 对应/ 故障/ 树/ 事件/ u/ 的/ 依赖/ 树/ 节点/ 是否/ 为叶/ 节点/ ,/ 值/ T/ 为/ 是/ ,/ 值/ F/ 为否/ ;/ v2/ =/ parent/ _/ set/ [/ u0/ ]/ ,/ 表示/ 对应/ 故障/ 树/ 事件/ u/ 的/ 并且/ 得到/ 了/ 依赖/ 树/ 的/ 叶/ 节点/ 集合/ ./ 各/ 节点/ 的/ 依赖/ 集/ 属性/ 在/ 独立/ 模块/ 识别/ 算法/ 中/ 进行/ 填充/ ./ 6/ 独立/ 模块/ 识别/ 随着/ 故障/ 树/ 研究/ 的/ 深入/ ,/ 模块/ 的/ 定义/ 也/ 相应/ 的/ 发生变化/ ./ 文献/ [/ 13/ ]/ 将/ 模块/ 定义/ 为/ 至少/ 两个/ 基本/ 事件/ 的/ 集合/ ,/ 这些/ 基本/ 事件/ 向上/ 可/ 到达/ 同一/ 逻辑/ 门/ ,/ 并且/ 必须/ 通过/ 此门/ 才能/ 达到/ 顶/ 事件/ ,/ 故障/ 树/ 的/ 所有/ 其它/ 基本/ 事件/ 向上/ 均/ 不能到达/ 该/ 逻辑/ 门/ ;/ Dutuit/ 将/ 模块/ 定义/ 为/ 一个/ 内部/ 节点/ ,/ 其/ 基本/ 事件/ 不会/ 出现/ 在/ 故障/ 树/ 的/ 任何/ 其它/ 地方/ ./ 以上/ 两个/ 定义/ 适用/ 于/ 基本/ 事件/ 相互/ 独立/ 的/ 故障/ 树/ ./ Page8/ 无论/ 模块/ 如何/ 定义/ ,/ 其/ 基本/ 思想/ 是/ 一脉相承/ 的/ :/ 将/ 故障/ 树/ 分解成/ 互不/ 相关/ 的/ 部分/ 分别/ 进行/ 处理/ ,/ 然后/ 再/ 对/ 结果/ 综合/ 分析/ ,/ 从而/ 降低/ 故障/ 树/ 求解/ 的/ 代价/ ./ 考虑/ 到/ 动态/ 故障/ 树所/ 具有/ 的/ 动态/ 依赖/ 特性/ ,/ 本/ 节/ 给出/ 一种/ 更/ 通用/ 的/ 独立/ 模块/ 定义/ 和/ 相应/ 的/ 独立/ 模块/ 识别/ 算法/ ,/ 其中/ events/ (/ x/ )/ 为/ 以/ x/ 和/ 所有/ x/ 的/ 子孙/ 事件/ 所/ 组成/ 子树/ 的/ 基本/ 事件/ 集合/ ./ 定义/ 1/ ./ 设/ u/ 和/ v/ 是/ 故障/ 树/ FT/ 的/ 两个/ 事件/ ,/ 称/ u/ 和/ v/ 相互/ 独立/ 且/ 记作/ u/ ⊥/ v/ ,/ 当且/ 仅/ 当/ :/ / u/ ∈/ events/ (/ u/ )/ ,/ / v/ ∈/ events/ (/ v/ )/ ,/ 则/ prob/ (/ uv/ )/ =/ prob/ (/ u/ )/ ×/ prob/ (/ v/ )/ ,/ 其中/ prob/ (/ x/ )/ 为/ x/ 的/ 失效/ 概率/ ./ 定义/ 2/ ./ 设/ u/ 为/ 故障/ 树/ FT/ 的/ 一个/ 中间/ 事件/ ,/ 称/ u/ 为/ FT/ 的/ 一个/ 独立/ 模块/ 当且/ 仅/ 当任/ 给/ FT/ 的/ 一个/ 事件/ v/ ,/ 必有/ 下列/ 一/ 式/ 成立/ :/ (/ 1/ )/ events/ (/ u/ )/ / events/ (/ v/ )/ ;/ (/ 2/ )/ events/ (/ v/ )/ / events/ (/ u/ )/ ;/ (/ 3/ )/ u/ ⊥/ v/ ./ 定义/ 3/ ./ 设/ L/ 是/ 故障/ 树/ FT/ 的/ 基本/ 事件/ 集/ ,/ Li/ (/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ )/ 是/ L/ 的/ 完全/ 不/ 相交/ 子集/ ,/ 而且/ 满足/ 以下/ 两个/ 条件/ :/ (/ i/ )/ / u/ ,/ v/ ∈/ Li/ ,/ 则/ prob/ (/ uv/ )/ ≠/ prob/ (/ u/ )/ ×/ (/ ii/ )/ / u/ ∈/ Li/ ,/ / v/ ∈/ Lj/ 且/ i/ ≠/ j/ ,/ 则/ prob/ (/ uv/ )/ =/ prob/ (/ v/ )/ ;/ prob/ (/ u/ )/ ×/ prob/ (/ v/ )/ ,/ 则/ (/ 1/ )/ 称/ L1/ ,/ L2/ ,/ …/ ,/ Ln/ 是/ L/ 的/ 完全/ 独立/ 划分/ ;/ (/ 2/ )/ 若/ u/ ∈/ Li/ ,/ 则/ 称/ u/ 依赖于/ 依赖/ 类型/ i/ ;/ (/ 3/ )/ v/ 是/ FT/ 的/ 一个/ 事件/ ,/ 若/ / u/ ∈/ Li/ 且/ u/ !/ ⊥/ v/ ,/ 则/ 称/ v/ 依赖于/ 依赖/ 类型/ i/ ;/ (/ 4/ )/ v/ 是/ FT/ 的/ 一个/ 事件/ ,/ / =/ {/ p1/ ,/ p2/ ,/ …/ ,/ pm/ }/ 是/ 依赖/ 类型/ 集/ ,/ 若/ / i/ ∈/ / 都/ 有/ v/ 依赖于/ 类型/ i/ ,/ 并且/ / j/ / / 都/ 有/ v/ 不/ 依赖于/ 依赖/ 类型/ j/ ,/ 则/ 称/ / 为/ v/ 的/ 完全/ 依赖/ 集/ ./ 定理/ 1/ ./ 设/ u/ 、/ v/ 是/ 故障/ 树/ FT/ 的/ 任意/ 两个/ 事件/ ,/ u/ _/ set/ 和/ v/ _/ set/ 分别/ 是/ u/ 和/ v/ 的/ 完全/ 依赖/ 集/ ,/ 且/ u/ _/ set/ ∩/ v/ _/ set/ =/ / ,/ 则/ u/ ⊥/ v/ ./ 证明/ ./ 假设/ 命题/ 不/ 成立/ ,/ 根据/ 定义/ 1/ ,/ 存在/ 基本/ 事件/ u0/ ∈/ events/ (/ u/ )/ 和/ v0/ ∈/ events/ (/ v/ )/ ,/ 且/ prob/ (/ u0v0/ )/ ≠/ prob/ (/ u0/ )/ ×/ prob/ (/ v0/ )/ ;/ 根据/ 定义/ 3/ ,/ u0/ 和/ v0/ 都/ 依赖于/ 同一个/ 依赖/ 类型/ ,/ 假设/ u0/ ,/ v0/ ∈/ Li/ ;/ 因为/ u0/ ∈/ events/ (/ u/ )/ 和/ v0/ ∈/ events/ (/ v/ )/ ,/ 所以/ u0/ !/ ⊥/ u/ 且/ v0/ !/ ⊥/ v/ ,/ 根据/ 定义/ 3/ (/ 3/ )/ ,/ u/ 和/ v/ 都/ 依赖于/ 依赖/ 类型/ i/ ;/ 又/ 因为/ u/ _/ set/ 和/ v/ _/ set/ 分别/ 是/ u/ 和/ v/ 的/ 完全/ 依赖/ 集/ ,/ 故而/ i/ ∈/ u/ _/ set/ 且/ i/ ∈/ v/ _/ set/ ,/ 这/ 与/ 题设/ u/ _/ set/ ∩/ v/ _/ set/ =/ / 矛盾/ ./ 命题/ 得证/ ./ 故障/ 树/ 转变/ 为/ 与其/ 依赖/ 关系/ 等价/ 的/ 依赖/ 树后/ ,/ 故障/ 树/ 的/ 每/ 一个/ 事件/ 对应/ 依赖/ 树/ 的/ 一个/ 相应/ 节点/ ./ 本节/ 前面/ 的/ 定义/ 和/ 命题/ 同样/ 适用/ 于/ 依赖/ 树/ ,/ 故障/ 树/ 的/ 独立/ 模块/ 识别/ 也/ 转化/ 为/ 相应/ 依赖/ 树/ 的/ 独立/ 模块/ 识别/ ./ 通过/ 对/ 依赖/ 树/ 各/ 节点/ 的/ 相关/ 属性/ 进行/ 分析/ ,/ 可/ 识别/ 出/ 依赖/ 树/ 的/ 独立/ 模块/ ,/ 从而/ 得到/ 相应/ 故障/ 树/ 的/ 独立/ 模块/ ,/ 以便/ 进行/ 其它/ 可靠性/ 分析/ ./ 6.1/ 独立/ 模块/ 识别/ 算法/ 经过/ 预处理/ 、/ 构建/ 依赖/ 树后/ ,/ 依赖/ 树/ 各/ 节点/ 除去/ 依赖/ 集/ 属性/ 外/ 其它/ 属性/ 都/ 已/ 填充/ ,/ 独立/ 模块/ 识别/ 算法/ IIM/ (/ IdentificationofIndependentModule/ )/ 根据/ 依赖/ 树/ 各/ 节点/ 的/ 祖先/ 集/ 属性/ 和/ 依赖/ 集/ 属性/ 进行/ 识别/ ./ 其/ 中心思想/ 为/ :/ 填充/ 每个/ 节点/ 的/ 依赖/ 集/ 属性/ ,/ 然后/ 每个/ 内部/ 节点/ 分别/ 同/ 与其/ 非/ 直系/ 血亲/ 的/ 所有/ 其它/ 节点/ 比/ 对/ 依赖/ 集/ 属性/ ,/ 若/ 都/ 不/ 存在/ 交集/ ,/ 则/ 该/ 内部/ 节点/ 即/ 为/ 独立/ 模块/ ,/ 算法/ 如/ 算法/ 4/ 所示/ ./ 算法/ 4/ ./ 独立/ 模块/ 识别/ 算法/ IIM/ ./ IdentificationIndependentModule/ (/ DT/ ,/ inputdep/ )/ 功能/ :/ 识别/ 依赖/ 树中/ 的/ 独立/ 模块/ 输入/ :/ 依赖/ 树/ DT/ (/ s/ ,/ MNS/ ,/ LNS/ )/ ,/ 各叶/ 节点/ 的/ 依赖/ 集/ 输出/ :/ 独立/ 模块/ 集/ IM1/ ./ IM/ ←/ / ;/ 2/ ./ SetLeafSetDep/ (/ DT/ ./ LNS/ ,/ inputdep/ )/ ;/ 3/ ./ foreachu/ ∈/ DT/ ./ LNS4/ ./ foreachv/ ∈/ u/ ./ ancestor/ _/ set5/ ./ v/ ./ depend/ _/ set/ ←/ v/ ./ depend/ _/ set/ ∪/ u/ ./ depend/ _/ set/ ;/ 6/ ./ foreachu/ ∈/ DT/ ./ MNS7/ ./ bIM/ =/ TRUE/ ;/ 8/ ./ foreachv/ ∈/ DT/ ./ MNS/ ∪/ DT/ ./ LNS/ // u/ ./ ancestor/ _/ set9/ ./ ifu/ / v/ ./ ancestor/ _/ set10/ ./ ifu/ ./ depend/ _/ set/ ∩/ v/ ./ depend/ _/ set/ ≠/ / 11/ ./ bIM/ =/ FALSE/ ;/ 12/ ./ break/ ;/ 13/ ./ ifbIM/ =/ =/ TRUE14/ ./ IM/ ←/ IM/ ∪/ {/ u/ }/ ;/ 15/ ./ returnIM/ ./ IIM/ 算法/ 执行/ 前/ ,/ 各/ 节点/ 的/ 依赖/ 集/ 属性/ 还/ 未/ 填充/ ,/ 因此/ 第/ 1/ 行/ 首先/ 将/ 独立/ 模块/ 集设/ 为/ 空/ ,/ 第/ 2/ 行将/ 已知/ 的/ 故障/ 树/ 各/ 基本/ 事件/ 依赖/ 类型/ 赋值/ 给/ 依赖/ 树/ 相应/ 叶/ 节点/ 的/ 依赖/ 集/ 属性/ ./ 第/ 3/ ~/ 5/ 行/ 根据/ 每个/ 叶/ 节点/ 的/ 依赖/ 集/ 属性/ ,/ 更新/ 该叶/ 节点/ 所有/ 祖先/ 的/ 依赖/ 集/ 属性/ ;/ 这/ 段/ 代码执行/ 完毕/ 后/ ,/ 依赖/ 树/ 所有/ 节点/ 的/ 依赖/ 集/ 属性/ 完全/ 确定/ ./ 第/ 6/ ~/ 15/ 行将/ 任/ 一个/ 内部/ 节点/ 的/ 依赖/ 集/ 属性/ 与/ 它/ 的/ 所有/ 非/ 直系/ 血亲/ 节点/ 的/ 依赖/ 集/ 属性/ 进行/ 比较/ ,/ 如果/ 没有/ 交集/ ,/ 根据/ 定理/ 1/ ,/ 该/ 节点/ 为/ 独/ Page9/ 立/ 模块/ ./ 点/ 所得/ 的/ 依赖/ 集/ 属性/ 为/ 完全/ 依赖/ 集/ ./ 定理/ 2/ ./ IIM/ 算法/ 3/ ~/ 5/ 行/ 执行/ 完毕/ 后/ ,/ 各节/ 证明/ ./ (/ 1/ )/ 设/ v/ 是/ 依赖/ 树/ 的/ 任一/ 节点/ ,/ 若/ v/ ∈/ DT/ ./ LNS/ ,/ 由于/ 叶/ 节点/ 的/ 依赖/ 集/ 属性/ 是/ 根据/ 系统/ 各/ 基本/ 元件/ 间/ 的/ 共/ 因/ 故障/ 类型/ 设置/ 的/ ,/ 每个/ 叶/ 节点/ 的/ 依赖/ 集/ 包括/ 了/ 所有/ 该叶/ 节点/ 所/ 依赖/ 的/ 依赖/ 类型/ ,/ 并且/ 所有/ 该叶/ 节点/ 所/ 依赖/ 的/ 依赖/ 类型/ 都/ 包括/ 在/ 该/ 叶/ 节点/ 的/ 依赖/ 集中/ ,/ 根据/ 定义/ 3/ (/ 4/ )/ ,/ 很/ 明显/ v/ ./ depend/ _/ set/ 是/ v/ 的/ 完全/ 依赖/ 集/ ./ v/ 的/ 依赖/ 类型/ ./ 于/ i/ ./ (/ 2/ )/ 若/ v/ / DT/ ./ LNS/ ,/ 下面/ 分/ 两步/ 进行/ 证明/ :/ (/ 2.1/ )/ 本步/ 证明/ v/ ./ depend/ _/ set/ 的/ 每个/ 元素/ 都/ 是/ 反证法/ ,/ 假设/ / i/ ∈/ v/ ./ depend/ _/ set/ 且/ v/ 并/ 不/ 依赖/ 则/ / u/ ∈/ Li/ ,/ 由/ 定义/ 3/ (/ 3/ )/ 可知/ ,/ u/ ⊥/ v/ ;/ ①/ 因为/ v/ ./ depend/ _/ set/ 初始/ 为空/ ,/ 由/ 3/ ~/ 5/ 行/ 可知/ ,/ 依赖/ 类型/ i/ 必由/ 某个/ 基本/ 事件/ u0/ 主导/ 加入/ ,/ 即/ / u0/ ∈/ Li/ 使得/ v/ ∈/ u0/ ./ ancestor/ _/ set/ ,/ 故而/ u0/ !/ ⊥/ v/ ./ ②/ ①/ 和/ ②/ 互相矛盾/ ,/ 本步/ 得证/ ./ (/ 2.2/ )/ 本步/ 证明/ v/ 的/ 所有/ 依赖/ 类型/ 都/ 在/ v/ ./ depend/ _/ set/ 中/ ./ 反证法/ ./ 假设/ / i/ 使得/ v/ 依赖于/ i/ 而/ i/ / v/ ./ depend/ _/ set/ ./ 由/ 3/ ~/ 4/ 行知/ ,/ events/ (/ v/ )/ ∩/ Li/ =/ / ;/ 否则/ 假设/ u0/ ∈/ events/ (/ v/ )/ ∩/ Li/ ,/ 则/ v/ ∈/ u0/ ./ ancestor/ _/ set/ ,/ i/ ∈/ u0/ ./ depend/ _/ set/ ,/ 于是/ i/ ∈/ v/ ./ depend/ _/ set/ ,/ 与/ 先前/ 题设/ 矛盾/ ./ 所以/ events/ (/ v/ )/ ∩/ Li/ =/ / ./ 因为/ v/ 依赖于/ i/ ,/ 则/ / u1/ ∈/ events/ (/ v/ )/ ,/ u2/ ∈/ Li/ 且/ prob/ (/ u1u2/ )/ ≠/ prob/ (/ u1/ )/ ×/ prob/ (/ u2/ )/ ,/ 由/ 定义/ 3/ 可知/ ,/ u1/ ∈/ Li/ ,/ 于是/ u1/ ∈/ Li/ ∩/ events/ (/ v/ )/ ./ ③/ 和/ ④/ 互相矛盾/ ,/ 本步/ 得证/ ./ 由/ (/ 1/ )/ 和/ (/ 2/ )/ 可得/ v/ ./ depend/ _/ set/ 是/ v/ 的/ 完全/ 依/ 命题/ 得证/ ./ 定理/ 3/ ./ IIM/ 算法/ 执行/ 完毕/ 后/ ,/ 所得/ 的/ IM/ 为/ 完全/ 独立/ 模块/ 集/ ./ 证明/ ./ 分/ 两步/ 进行/ ,/ 第/ 1/ 步/ 证明/ IM/ 中/ 的/ 所有/ 模块/ 都/ 是/ 独立/ 模块/ ,/ 第/ 2/ 部/ 证明/ 依赖/ 树/ 的/ 所有/ 独立/ 模块/ 都/ 在/ IM/ 中/ ./ (/ 1/ )/ 本步/ 证明/ IM/ 中/ 的/ 所有/ 模块/ 都/ 是/ 独立/ 模块/ ./ / u/ ∈/ IM/ ,/ 由/ 第/ 6/ 行/ 可知/ ,/ u/ 不是/ 依赖/ 树/ 的/ 顶节/ 若/ v/ ∈/ u/ ./ ancesor/ _/ set/ ,/ 则/ events/ (/ u/ )/ / events/ (/ v/ )/ ;/ 赖集/ ./ 点/ 或/ 叶/ 节点/ ;/ 任一/ 节点/ v/ ,/ 若/ u/ ∈/ v/ ./ ancesor/ _/ set/ ,/ 则/ events/ (/ v/ )/ / events/ (/ u/ )/ ;/ 若/ v/ / u/ ./ ancesor/ _/ set/ 且/ u/ / v/ ./ ancesor/ _/ set/ ,/ 则/ 由/ 第/ 10/ ~/ 14/ 行/ 可知/ ,/ u/ ./ depend/ _/ set/ ∩/ v/ ./ depend/ _/ set/ =/ / ,/ 由/ 定理/ 1/ 可得/ u/ ⊥/ v/ ;/ 由/ 定义/ 2/ 可知/ u/ 是/ 依赖/ 树/ 的/ 一个/ 独立/ 模块/ ./ 本步/ 得证/ ./ (/ 2/ )/ 本步/ 证明/ 依赖/ 树/ 的/ 所有/ 独立/ 模块/ 都/ 在/ IM/ 中/ ./ 反证法/ ,/ 假设/ 依赖/ 树/ 存在/ 独立/ 模块/ u/ ,/ 但是/ u/ / IM/ ./ 由/ 定义/ 2/ 可知/ ,/ u/ 既/ 不是/ 顶/ 节点/ 也/ 不是/ 叶/ 节点/ ;/ 由/ 第/ 8/ ~/ 12/ 行/ 可知/ ,/ 存在/ 一个/ 节点/ v/ ,/ 且/ v/ / u/ ./ ancestor/ _/ set/ 和/ u/ / v/ ./ ancestor/ _/ set/ ,/ 有/ u/ ./ depend/ _/ set/ ∩/ v/ ./ depend/ _/ set/ ≠/ / ,/ 使得/ 变量/ bIM/ =/ FALSE/ ,/ 以至于/ u/ 未/ 被/ 加入/ IM/ 中/ ./ 这/ 又/ 与/ u/ 是/ 独立/ 模块/ 相/ 矛盾/ ./ 本步/ 得证/ ./ 由/ (/ 1/ )/ 和/ (/ 2/ )/ ,/ 命题/ 得证/ ./ 6.2/ 最小/ 独立/ 模块/ 识别/ 算法/ 识别/ 出/ 独立/ 模块/ 集/ IM/ 后/ ,/ 还要/ 从中/ 识别/ 出/ 最小/ 独立/ 模块/ ./ 最小/ 动态/ 独立/ 模块/ 是/ 必须/ 用/ Markov/ 链/ 求解/ 的/ 模块/ ,/ 识别/ 出/ 最小/ 独立/ 模块/ ,/ 能够/ 显著/ 缩减/ 状态/ 空间/ ,/ 降低/ 求解/ 开销/ ./ 定义/ 4/ ./ 设/ u/ 是/ 依赖/ 树/ DT/ 的/ 一个/ 独立/ 模块/ ,/ 称/ u/ 是/ 一个/ 最小/ 独立/ 模块/ 当且/ 仅/ 当/ :/ 任给/ 另外/ 一个/ 独立/ 模块/ v/ ,/ 则/ u/ / v/ ./ ancestor/ _/ set/ ./ 最小/ 独立/ 模块/ 识别/ 算法/ IMIM/ (/ IdentificationofMinimumIndependentModule/ )/ 如/ 算法/ 5/ 所示/ ,/ 第/ 1/ 行/ 首先/ 将/ 最小/ 独立/ 模块/ 集/ MIM/ 设为/ 空集/ ,/ 第/ 2/ 行对/ IM/ 集中/ 各/ 节点/ 的/ 遍历/ 深度/ 属性/ depth/ 进行/ 降序/ 排序/ 并/ 赋值/ 给/ IM0/ ./ 排在/ IM0/ 的/ 首位/ 模块/ 必定/ 为/ 最小/ 独立/ 模块/ ,/ 第/ 4/ ~/ 8/ 行将/ 首位/ 模块/ u/ 加入/ MIM/ 的/ 后面/ ,/ 并/ 从/ IM0/ 中/ 去除/ u/ 及/ u/ 的/ 祖先/ 节点/ ,/ 如此/ 反复/ ,/ 直至/ IM0/ 为空/ ,/ 此时/ MIM/ 即为/ 最小/ 独立/ 模块/ 集/ ./ 算法/ 5/ ./ 最小/ 独立/ 模块/ 识别/ 算法/ IMIM/ ./ IdentificationMinimizeIM/ (/ IM/ )/ 功能/ :/ 识别/ 最小/ 独立/ 模块/ 输入/ :/ 独立/ 模块/ 集/ IM/ 输出/ :/ 最小/ 独立/ 模块/ 集/ MIM1/ ./ MIM/ ←/ / ;/ 2/ ./ IM0/ ←/ SortIM/ (/ IM/ )/ ;/ 3/ ./ whileIM0/ ≠/ / 4/ ./ u/ ←/ FirstNode/ (/ IM0/ )/ ;/ 5/ ./ IM0/ ←/ RemoveFirstNode/ (/ IM0/ )/ ;/ 6/ ./ MIM/ ←/ AddLast/ (/ MIM/ ,/ u/ )/ ;/ 7/ ./ AncestorSet/ ←/ u/ ./ ancestor/ _/ set/ ∩/ IM0/ ;/ 8/ ./ IM0/ ←/ RemoveSet/ (/ IM0/ ,/ AncestorSet/ )/ ;/ 9/ ./ returnMIM/ ./ Page10/ 定理/ 4/ ./ IMIM/ 算法/ 执行/ 完毕/ 后/ ,/ 所得/ 的/ MIM/ 为/ 完全/ 最小/ 独立/ 模块/ 集/ ./ 证明/ ./ 由/ 第/ 4/ ~/ 6/ 行/ 代码/ 可知/ ,/ MIM/ / IM/ ,/ 故而/ MIM/ 是/ 独立/ 模块/ 集/ ./ 下面/ 分/ 两步/ 进行/ ,/ 第/ 1/ 步/ 证明/ MIM/ 的/ 所有/ 元素/ 都/ 是/ 最小/ 独立/ 模块/ ,/ 第/ 2/ 步/ 证明/ 所有/ 最小/ 独立/ 模块/ 都/ 是/ MIM/ 中/ 的/ 元素/ ./ (/ 1/ )/ 反证法/ ./ 假设/ / u/ ∈/ MIM/ ,/ 但/ u/ 不是/ 最小/ 独立/ 模块/ ,/ 也/ 就/ 意味着/ / v/ ∈/ IM/ ,/ 使得/ u/ ∈/ v/ ./ ancestor/ _/ set/ ./ 若/ v/ 在/ 第/ 6/ 行/ 被/ 加入/ MIM/ ,/ 因为/ v/ ./ depth/ >/ u/ ./ depth/ 且/ IM0/ 为/ IM/ 的/ depth/ 属性/ 的/ 降序/ 排列/ ,/ 此时/ u/ 必然/ 还/ 未/ 被/ 加入/ MIM/ ./ 在/ 第/ 7/ 行/ 执行/ 前/ ,/ 若/ u/ ∈/ IM0/ ,/ 第/ 7/ 行/ 执行/ 后/ u/ ∈/ AncestorSet/ ,/ 则/ 第/ 8/ 行/ 执行/ 后/ u/ / IM0/ ,/ 故而/ 在/ 后面/ 的/ 处理/ 中/ u/ 不/ 可能/ 被/ 加入/ MIM/ ,/ 这/ 与/ 题设/ 矛盾/ ,/ 本步/ 得证/ ./ (/ 2/ )/ 反证法/ ./ 假设/ 存在/ u/ 是/ 最小/ 独立/ 模块/ ,/ 但/ u/ / MIM/ ./ 因为/ IM/ 是/ 完全/ 独立/ 模块/ 集/ ,/ 故而/ u/ ∈/ IM/ ./ 由/ 第/ 4/ ~/ 8/ 行/ 可知/ ,/ 必/ 存在/ 一次/ 循环/ ,/ 在/ 此次/ 循环/ 中/ u/ ∈/ AncestorSet/ ,/ 被/ 从/ IM0/ 中/ 去除/ ;/ 假设/ 在/ 此次/ 循环/ 中/ 被/ 加入/ MIM/ 的/ 是/ v/ ,/ 则/ 由/ 第/ 7/ 行/ 可知/ ,/ u/ ∈/ v/ ./ ancestor/ _/ set/ ,/ 而/ 这/ 又/ 与/ u/ 是/ 最小/ 独立/ 模块/ 相/ 矛盾/ ./ 本步/ 得证/ ./ 由/ (/ 1/ )/ 和/ (/ 2/ )/ ,/ 命题/ 得证/ ./ 7/ 算法/ 分析/ 设/ 故障/ 树/ FT/ =/ (/ V/ ,/ E/ )/ ,/ 其中/ V/ 为/ 事件/ 集/ ,/ E/ 为/ 本节/ 对/ IIMKDR/ 方法/ 的/ 各/ 算法/ 进行/ 时间/ 复杂性/ 理论/ 分析/ ,/ 并/ 将/ 其/ 与/ 其它/ 方法/ 在/ 性能/ 上/ 进行/ 理论/ 对比/ 分析/ ./ 7.1/ 时间/ 复杂性/ 分析/ 有/ 向/ 边集/ ./ 算法/ 1/ 构建/ 依赖/ 树/ 算法/ DTC/ 中/ 第/ 1/ 行/ 的/ 循环/ 占用/ 的/ 时间/ 为/ Θ/ (/ V/ )/ ./ 与/ 传统/ 深度/ 优先/ 遍历/ 算法/ 不同/ ,/ 需对/ 依赖/ 树中/ 的/ 重复/ 节点/ 及其/ 子/ 节点/ 更新/ 祖先/ 集/ 属性/ ,/ 对于/ 故障/ 树中/ 任一/ 事件/ v/ ,/ 过程/ DFS/ _/ VISIT/ 可能/ 被/ 调用/ 多次/ ./ 下面/ 详细分析/ 之/ :/ (/ 1/ )/ 故障/ 树中/ 不/ 含有/ 重复/ 事件/ ./ 在/ 这种/ 情况/ 下/ ,/ 每个/ 事件/ 至多/ 仅/ 有/ 一个/ 父/ 事件/ ./ 对于/ 任一/ 事件/ v/ ,/ 过程/ DFS/ _/ VISIT/ 仅/ 被/ 调用/ 一次/ ./ 在/ DFS/ _/ VISIT/ (/ u/ ,/ u0/ )/ 的/ 一次/ 执行/ 过程/ 中/ ,/ 第/ 12/ ~/ 19/ 行/ 被/ 执行/ 了/ |/ adj/ [/ u/ ]/ |/ 次/ ,/ 而/ 第/ 21/ ~/ 25/ 行/ 从不/ 执行/ ./ ∑/ v/ ∈/ V/ |/ adj/ [/ v/ ]/ |/ =/ Θ/ (/ E/ )/ ,/ 执行/ DTC/ 函数/ 中/ 第/ 9/ 行/ 的/ 总/ 代价/ 为/ Θ/ (/ E/ )/ ./ 因此/ DTC/ 的/ 时间/ 开销/ 为/ Θ/ (/ V/ +/ E/ )/ ./ (/ 2/ )/ 故障/ 树中/ 含有/ 重复/ 事件/ ./ 在/ 这种/ 情况/ 下/ ,/ 有/ 多个/ 事件/ 含有/ 多个/ 父/ 事件/ ,/ 情况/ 稍显/ 复杂/ ./ 假设/ 故障/ 树中/ 含有/ i/ 个/ 重复/ 事件/ ,/ 分别/ 为/ m1/ ,/ m2/ ,/ …/ ,/ mi/ ./ 任给/ 一个/ 事件/ mj/ (/ 1/ / j/ / i/ )/ ,/ 则/ 其父/ 事件/ 个数/ pnum/ [/ mj/ ]/ =/ |/ mj/ ./ parent/ _/ set/ |/ ./ 另外/ 对/ 每/ 一个/ 事件/ u/ ,/ 都/ 对应/ 一个/ 发现/ 时间/ 和/ 一个/ 完成/ 时间/ ,/ 其/ 对应/ 的/ 时间/ 戳/ 分别/ 为/ d/ [/ u/ ]/ 和/ f/ [/ u/ ]/ ,/ 事件/ u/ 在/ 时刻/ d/ [/ u/ ]/ 之前/ 为/ 白色/ ,/ 在/ 时刻/ d/ [/ u/ ]/ 和/ f/ [/ u/ ]/ 之间/ 为/ 灰色/ ,/ 之后/ 为/ 黑色/ ;/ 同时/ 也/ 意味着/ 以/ 事件/ u/ 开始/ 的/ 深度/ 优先/ 遍历/ 共/ 执行/ 了/ (/ f/ [/ u/ ]/ -/ d/ [/ u/ ]/ +/ 1/ )/ // 2/ 次/ DFS/ _/ VISIT/ 算法/ ,/ (/ f/ [/ u/ ]/ -/ d/ [/ u/ ]/ +/ 1/ )/ // 2/ 也/ 等于/ 以/ u/ 为/ 根所/ 组成/ 的/ 子树/ 中/ 的/ 节点/ 数/ ./ 故而/ 由于/ 故障/ 树中/ 含有/ 重复/ 事件/ ,/ DFS/ _/ VISIT/ 中/ 第/ 20/ ~/ 25/ 行/ 被/ 多/ 执行/ 了/ ∑/ i/ (/ pnum/ [/ mj/ ]/ -/ 1/ )/ ×/ (/ f/ [/ mj/ ]/ -/ d/ [/ mj/ ]/ +/ 1/ )/ // 2j/ =/ 1/ 次/ ./ 设/ p/ 为/ 所有/ 重复/ 事件/ 中父/ 事件/ 个数/ 的/ 最大值/ ,/ q/ 为/ 所有/ 以/ 重复/ 事件/ 为根/ 的/ 子树中/ 事件/ 个数/ 的/ 最大值/ ,/ 则/ DFS/ _/ VISIT/ 中/ 第/ 20/ ~/ 25/ 行/ 最/ 多/ 被/ 执行/ 了/ ipq/ 次/ ./ 因此/ ,/ DTC/ 的/ 时间/ 开销/ 为/ Θ/ (/ V/ +/ E/ +/ ipq/ )/ ./ 算法/ 4/ 独立/ 模块/ 识别/ 算法/ IIM/ 的/ 第/ 3/ ~/ 5/ 行/ 时间/ 开销/ 小于/ Θ/ (/ V2/ )/ ,/ 第/ 6/ ~/ 14/ 行/ 执行/ 代价/ 也/ 小于/ Θ/ (/ V2/ )/ ,/ 于是/ IIM/ 算法/ 的/ 时间/ 复杂度/ 最坏/ 情况/ 下/ 为/ Θ/ (/ V2/ )/ ;/ 算法/ 5/ 最小/ 独立/ 模块/ 识别/ 算法/ IMIM/ 的/ 第/ 2/ 行/ 根据/ 节点/ 的/ 深度/ 属性/ 进行/ 降序/ 排序/ ,/ 最优/ 排序/ 算法/ 时间/ 复杂度/ 为/ Θ/ (/ |/ IM/ |/ log2/ |/ IM/ |/ )/ ,/ 第/ 4/ ~/ 8/ 行/ 最/ 多/ 执行/ 了/ |/ IM/ |/ 次/ ./ 故而/ 识别/ 阶段/ 时间/ 复杂度/ 最坏/ 情况/ 下/ 为/ Θ/ (/ V2/ )/ ./ 综合/ 构建/ 依赖/ 树/ 算法/ DTC/ 、/ 独立/ 模块/ 识别/ 算法/ IIM/ 、/ 最小/ 独立/ 模块/ 识别/ 算法/ IMIM/ 等/ 的/ 时间/ 复杂性/ 分析/ ,/ IIMKDR/ 方法/ 的/ 时间/ 复杂度/ 最坏/ 情况/ 下/ 为/ Θ/ (/ V2/ )/ ./ 7.2/ 性能/ 分析/ 由于/ IIMKDR/ 方法/ 在/ 构建/ 依赖/ 树/ 阶段/ 将/ 故障/ 树/ 转化/ 为/ 依赖/ 树/ ,/ 然后/ 在/ 依赖/ 树/ 的/ 基础/ 上/ 进行/ 处理/ ,/ 从而/ 使/ 其/ 具有/ 处理/ 动态/ 故障/ 树/ 的/ 能力/ ;/ 由于/ 算法/ 3/ 深度/ 优先/ 遍历/ 函数/ DFS/ _/ VISIT/ 增加/ 了/ 20/ ~/ 25/ 行/ ,/ 从而/ 使得/ IIMKDR/ 方法/ 能够/ 对/ 具有/ 重复/ 事件/ 的/ 故障/ 树/ 进行/ 独立/ 模块/ 识别/ ;/ 又/ 由于/ IIMKDR/ 方法/ 基于/ 各/ 节点/ 的/ 依赖/ 集/ 属性/ 进行/ 识别/ ,/ 从而/ 可/ 对/ 具有/ 互相/ 依赖/ 基本/ 事件/ 的/ 故障/ 树/ 进行/ 独立/ 模块/ 识别/ ./ 因此/ ,/ IIMKDR/ 方法/ 不仅/ 可/ 对/ 传统/ 故障/ 树/ 进行/ 独立/ 模块/ 识别/ ,/ 还/ 可/ 对/ 具有/ 互相/ 依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 的/ 动态/ 故障/ 树/ 进行/ 识别/ ./ Sun/ 方法/ 也/ 使用/ 了/ 依赖/ 属性/ 的/ 思想/ ,/ 也/ 可/ 对/ 具有/ 互相/ 依赖/ 基本/ 事件/ 的/ 故障/ 树/ 进行/ 独立/ 模块/ 识别/ ;/ Page11/ 其/ 基于/ 静态/ 故障/ 树/ 进行/ 分析/ ,/ 没有/ 针对/ 动态/ 逻辑/ 门/ 进行/ 专门/ 的/ 预处理/ ,/ 不/ 适合/ 处理/ 动态/ 故障/ 树/ ;/ 其/ 独立/ 模块/ 识别/ 的/ 核心/ 算法/ 仍/ 是/ 基于/ Dutuit/ 方法/ ,/ 无法/ 处理/ 具有/ 重复/ 事件/ 的/ 故障/ 树/ ./ Huang/ 方法/ 仅/ 对/ 动态/ 故障/ 树/ 进行/ 了/ 一定/ 的/ 预处理/ ,/ 其/ 独立/ 模块/ 识别/ 的/ 核心/ 算法/ 也/ 是/ 基于/ Dutuit/ 方法/ ,/ 无法/ 处理/ 具有/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 的/ 故障/ 树/ ./ 由/ 上节/ 可知/ ,/ IIMKDR/ 方法/ 的/ 时间/ 复杂度/ 最坏/ 情况/ 下/ 为/ Θ/ (/ V2/ )/ ./ Dutuit/ 方法/ 的/ 时间/ 开销/ 为/ Θ/ (/ V/ +/ E/ )/ ./ Sun/ 方法/ 在/ 其/ “/ 模块化/ ”/ 步骤/ 中/ 完全/ 采用/ Dutuit/ 方法/ ,/ 但/ 为了/ 找出/ 最小/ 独立/ 模块/ ,/ 又/ 另加/ 了/ “/ 更新/ 依赖/ 信息/ ”/ 步骤/ 和/ “/ 为/ 每个/ 依赖/ 信息/ 重新/ 模块化/ ”/ 步骤/ ,/ 时间/ 总开销/ 为/ Θ/ (/ V2/ )/ ./ Huang/ 方法/ 识别/ 核心/ 算法/ 完全/ 同/ Dutuit/ 方法/ 一样/ ,/ 时间/ 开销/ 为/ Θ/ (/ V/ +/ E/ )/ ./ 8/ 实验/ 验证/ 本/ 节/ 使用/ 两种/ 方法/ 对/ IIMKDR/ 方法/ 进行/ 验证/ ,/ 首先/ 将/ IIMKDR/ 应用/ 于/ 我们/ 所/ 设计/ 的/ 一个/ 星载/ 计算机系统/ ,/ 由于/ 该/ 系统/ 是/ 一个/ 动态/ 系统/ ,/ 而且/ 其/ 基本/ 元件/ 并/ 不/ 完全/ 独立/ ,/ 故而/ Sun/ 方法/ 和/ Huang/ 方法/ 无法/ 对/ 其/ 识别/ ;/ 然后/ 采用/ 模拟/ 仿真/ 方法/ 对/ IIMKDR/ 方法/ 、/ Sun/ 方法/ 和/ Huang/ 方法/ 进行/ 详细/ 的/ 求解/ 开销/ 、/ 错误率/ 的/ 对比/ ./ 8.1/ 实际/ 案例/ 验证/ 图/ 9/ 和/ 图/ 10/ 分别/ 为/ 一个/ 星载/ 计算机/ 的/ 系统/ 结构图/ 和/ 动态/ 故障/ 树/ ,/ 星载/ 计算机系统/ 包括/ 4/ 个/ 模块/ :/ 处理/ 模块/ 、/ 电源模块/ 、/ 存储模块/ 和/ 总线/ 模块/ ./ 处理/ 模块/ 中/ 含有/ 3/ 个/ 处理单元/ A1/ 、/ A2/ 和/ A3/ ,/ A3/ 为/ A1/ 和/ A2/ 的/ 冷/ 备份/ ,/ 只要/ 3/ 个/ 处理器/ 全部/ 失效/ 就/ 会/ 导致系统/ 失效/ ./ 电源模块/ 包括/ 3/ 个/ 功能/ 单元/ P1/ 、/ P2/ 和/ C/ ,/ 其中/ P1/ 和/ P2/ 为/ 两个/ 供电/ 单元/ ,/ C/ 为/ 切换/ 控制/ 单元/ ,/ 电源模块/ 为/ 3/ 个/ 处理单元/ 供电/ ,/ 只要/ P1/ 或/ P2/ 有/ 一个/ 正常/ 运作/ 并且/ C/ 正常/ 运作/ ,/ 便/ 能/ 给/ 3/ 个/ 处理单元/ 正常/ 供电/ ./ 存储模块/ 包括/ 5/ 个/ 存储单元/ ,/ 若/ 其中/ 3/ 个/ 单元/ 失效/ ,/ 则/ 存储模块/ 失效/ ;/ 存储单元/ M1/ 和/ M2/ 连接/ 存储/ 接口/ MIU0/ ,/ M4/ 和/ M5/ 连接/ MIU1/ ,/ M3/ 即/ 连接/ MIU0/ 又/ 连接/ MIU1/ ./ 总线/ 模块/ 包括/ 两个/ 系统总线/ B1/ 和/ B2/ ,/ 只要/ 两条/ 总线/ 全部/ 失效/ 就/ 会/ 导致系统/ 失效/ ./ 另外/ 假设/ 基本/ 元件/ A1/ 和/ A2/ 因为/ 共因/ 故障/ 原因/ 相互/ 关联/ ,/ 设/ 这/ 两个/ 元件/ 依赖于/ 依赖/ 类型/ 1/ ;/ A3/ 单独/ 依赖于/ 依赖/ 类型/ 2/ ;/ P1/ 和/ P2/ 依赖于/ 依赖/ 类型/ 3/ ,/ C/ 依赖于/ 依赖/ 类型/ 4/ ;/ M1/ 、/ M3/ 和/ M5/ 依赖于/ 依赖/ 类型/ 5/ ,/ M2/ 和/ M4/ 依赖于/ 依赖/ 类型/ 6/ ;/ MIU0/ 和/ MIU1/ 依赖于/ 依赖/ 类型/ 7/ ;/ B1/ 和/ B2/ 依赖于/ 依赖/ 类型/ 8/ ./ 经过/ 预处理/ ,/ 图/ 10/ 可/ 转变/ 为/ 图/ 11/ ./ 图/ 11/ 中/ 粗线/ 边框/ 的/ 事件/ 为宏/ 事件/ ,/ 因为/ P1/ 和/ P2/ 经/ AND/ 门/ 的/ 组合/ 事件/ 在/ 故障/ 树中仅/ 出现/ 一次/ ,/ 因此/ 可/ 将/ 此/ 两/ 基本/ 事件/ (/ 包括/ 与其/ 相连/ 的/ AND/ 门/ )/ 以宏/ 事件/ P/ 代替/ ,/ 同理/ 也/ 可/ 得到/ 宏/ 事件/ bus/ ./ 原/ 故障/ 树中/ 含有/ FDEP/ 门/ ,/ 根据/ 预处理/ 中/ 关于/ FDEP/ 门/ 的/ 处理/ ,/ 将/ 其/ 转换/ 为/ OR/ 门/ 并/ 外联/ 之/ 公共/ 父/ 事件/ ./ 输入/ 预处理/ 后/ 的/ 星载/ 计算机/ 故障/ 树/ ,/ 经过/ 依赖/ 树/ 构建/ 算法/ 处理/ 后/ ,/ 输出/ 如图/ 12/ 所示/ 的/ 星载/ 计算机/ 依赖/ 树/ ;/ 为了/ 节省/ 篇幅/ ,/ 仅/ 显示/ PW/ 、/ A/ 、/ M/ 、/ bus4/ 个/ Page12/ 节点/ 的/ 各/ 属性/ 、/ 首次/ 遍历/ 发现/ 时间/ 、/ 首次/ 遍历/ 结束/ 事件/ ,/ 如表/ 1/ 所示/ ./ IDparent/ _/ setancestor/ _/ setdepthd/ [/ u/ ]/ f/ [/ u/ ]/ PW1SA4SM10Sbus24S/ 经过/ 独立/ 模块/ 识别/ 算法/ IIM/ 和/ 最小/ 独立/ 模块/ 识别/ 算法/ IMIM/ 处理/ 后/ ,/ 星载/ 计算机系统/ 的/ 独立/ 模块/ 集/ 和/ 最小/ 独立/ 模块/ 集/ 分别/ 为/ IM/ =/ {/ PW/ ,/ A/ ,/ M/ ,/ bus/ }/ ,/ MIM/ =/ {/ PW/ ,/ A/ ,/ M/ ,/ bus/ }/ ,/ 直观/ 上/ 很/ 容易/ 看出/ 这是/ 正确/ 的/ 答案/ ./ Sun/ 方法/ 和/ Huang/ 方法/ ,/ 由于/ 其/ 应用/ 局限性/ ,/ 无法/ 求解/ 本/ 案例/ ./ 8.2/ 仿真/ 验证/ 独立/ 模块/ 识别/ 的/ 时间/ 开销/ 与/ 许多/ 因素/ 都/ 有/ 关系/ ,/ 这些/ 因素/ 包括/ 故障/ 树结构/ 、/ 事件/ 个数/ 、/ 重复/ 事件/ 位置/ 及/ 个数/ 、/ 依赖/ 类型/ 个数/ 等/ ./ 每次/ 实验/ 都/ 可/ 看做/ 是/ 个/ 特例/ ,/ 无法说明/ 某个/ 方法/ 的/ 优劣/ ./ 为了/ 尽可能/ 地/ 与/ Sun/ 方法/ 、/ Huang/ 方法/ 进行/ 对比/ ,/ 将/ 它们/ 都/ 在/ Matlab/ 平台/ 上/ 使用/ 相同/ 的/ 编程/ 风格/ 和/ 库函数/ 实现/ ./ 由于/ Sun/ 方法/ 仅/ 应用/ 于/ 静态/ 故障/ 树/ ,/ 故而/ 在/ 本组/ 实验/ 中/ ,/ 剔除/ 动态/ 逻辑/ 门/ 在/ 识别/ 过程/ 中/ 的/ 影响/ ,/ 求解/ 的/ 对象/ 实际/ 是/ 静态/ 故障/ 树/ (/ 也/ 可/ 看作/ IIMKDR/ 方法/ 中/ 的/ 依赖/ 树/ )/ ,/ 对比/ 3/ 种/ 方法/ 的/ 核心/ 算法/ 在/ 具有/ 重复/ 事件/ 、/ 具有/ 相互依赖/ 基本/ 事件/ 的/ 故障/ 树上/ 的/ 适用性/ 、/ 求解/ 开销/ ./ 静态/ 故障/ 树/ (/ 亦可/ 理解/ 为/ 依赖/ 树/ )/ 随机/ 仿真/ 生成/ 过程/ 如下/ :/ (/ 1/ )/ 若/ 无/ 指定/ 总结/ 点数/ ,/ 随机/ 生成/ 总结/ 点数/ ;/ (/ 2/ )/ 随机/ 生成/ 叶/ 节点/ 个数/ ,/ 叶/ 节点/ 个数/ 要/ 大于/ 总结/ 点数/ 的/ 一半/ ;/ (/ 3/ )/ 随机/ 生成/ 依赖/ 类型/ 个数/ ,/ 依赖/ 类型/ 个数/ 要/ 小于/ 叶/ 节点/ 个数/ ;/ (/ 4/ )/ 随机/ 生成/ 最小/ 独立/ 模块/ ,/ 其/ 个数/ 要/ 小于/ 依赖/ 类型/ 个数/ ,/ 若/ 依赖于/ 同一个/ 依赖/ 类型/ 的/ 叶/ 节点/ 个数/ 大于/ 1/ ,/ 则/ 这些/ 叶/ 节点/ 属于/ 且/ 仅/ 属于/ 某个/ 最小/ 独立/ 模块/ ;/ (/ 5/ )/ 若/ 依赖于/ 某个/ 依赖/ 类型/ 的/ 叶/ 节点/ 只有/ 一个/ ,/ 则/ 该/ 叶/ 节点/ 称为/ 独立/ 叶/ 节点/ ,/ 以/ 所有/ 最小/ 独立/ 模块/ 、/ 独立/ 叶/ 节点/ 为/ 基本/ 单位/ ,/ 随机/ 生成/ 上层/ 节点/ (/ 包括/ 独立/ 模块/ )/ ,/ 直至/ 根/ 节点/ ./ 由此/ 仿真/ 过程/ 可知/ ,/ 当/ 故障/ 树/ 随机/ 生成/ 完毕/ ,/ 故障/ 树中/ 含有/ 的/ 最小/ 独立/ 模块/ 和/ 独立/ 模块/ 皆/ 是/ 已知/ ,/ 将/ 其/ 与/ 3/ 种/ 方法/ 识别/ 所得/ 的/ 结果/ 进行/ 比较/ ,/ 便/ 可/ 得到/ 识别/ 准确率/ ./ 仿真/ 程序/ 使得/ 故障/ 树/ 的/ 生成/ 尽可能/ 具有/ 随机性/ ,/ 但是/ 真正/ 的/ 随机数/ 是/ 不/ 存在/ 的/ ,/ 生成/ 的/ 过程/ 中/ 也/ 有/ 一定/ 的/ 条件/ 限制/ ,/ 因此/ 生成/ 的/ 故障/ 树/ 还/ 不能/ 称为/ 完全/ 随机/ ,/ 某个/ 或/ 多个/ 故障/ 树/ 可能/ 会/ 更加/ 倾向/ 于/ 适用/ 某种/ 方法/ ,/ 从而/ 对/ 实验/ 结果/ 造成/ 误差/ ,/ 我们/ 采用/ 生成/ 求解/ 很/ 多次/ 并取/ 平均值/ 的/ 方法/ 来/ 尽量/ 减小/ 这种/ 误差/ ./ 为了/ 对比/ 的/ 公平性/ ,/ 3/ 个/ 方法/ 识别/ 的/ 对象/ 都/ 是/ 同一个/ 随机/ 仿真/ 生成/ 的/ 故障/ 树/ ,/ 正如/ 前面/ 所述/ ,/ 该/ 故障/ 树/ 实际上/ 仅/ 含/ 依赖/ 信息/ ,/ 因此/ 3/ 种/ 方法/ 针对/ 逻辑/ 结构/ 所/ 采取/ 的/ 预处理/ 过程/ 可以/ 忽略/ ,/ 本节/ 仅/ 是/ 比较/ 3/ 个/ 方法/ 核心/ 算法/ 的/ 优劣/ ./ 虽然/ Sun/ 方法/ 和/ Huang/ 方法/ 都/ 比较复杂/ ,/ 但是/ 其/ 核心/ 算法/ 都/ 还是/ 比较/ 直观/ 简洁/ ,/ 而且/ 核心/ 算法/ 在/ 方法/ 的/ 正确性/ 和/ 效率/ 上起/ 着/ 绝对/ 主要/ 的/ 作用/ ;/ 所以/ 尽管/ 我们/ 的/ 实现/ 不可避免/ 会/ 引入/ 误差/ ,/ 但是/ 我们/ 仅/ 是/ 对比/ 其/ 核心/ 算法/ ,/ 这些/ 误差/ 是/ 可以/ 容忍/ 的/ ./ 将/ 实验/ 分成/ 以下/ 3/ 组/ ,/ 为了/ 克服/ 每次/ 实验/ 的/ 偶然性/ ,/ 每个/ 实验/ 数据/ 都/ 是/ 多次/ 随机/ 取/ 平均值/ 得到/ ./ 其中/ 遗漏/ 率/ (/ NegativeErrorRate/ )/ 是/ 指本应/ 识别/ 而/ 未能/ 识别/ 为/ 独立/ 模块/ 的/ 数目/ 所/ 占/ 的/ 比重/ ,/ 错加率/ (/ PositiveErrorRate/ )/ 是/ 指本/ 非/ 而/ 被/ 识别/ 为/ 独立/ 模块/ 的/ 数目/ 所/ 占/ 的/ 比重/ ,/ IMS/ (/ IndependentModuleSet/ )/ 和/ MIMS/ (/ MinimalIndependentModuleSet/ )/ 分别/ 指/ 独立/ 模块/ 集/ 和/ 最小/ 独立/ 模块/ 集/ ./ 实验/ 1/ ./ 仅/ 含/ 重复/ 事件/ 的/ 故障/ 树/ ./ 每次/ 故障/ 树/ 生成/ 时/ ,/ 总/ 事件/ 个数/ 设定/ 为/ 600/ ,/ 重复/ 事件/ 的/ 个数/ 及/ 位置/ 随机/ 生成/ ,/ 重复/ 10000/ 次/ ./ 当/ 含有/ 某/ 重复/ 事件/ 数目/ 的/ 案例/ 大于/ 20/ 次时/ ,/ 再求/ 此/ 重复/ 事件/ 数目/ 下/ 的/ 时间/ 开销/ 、/ 错加率/ 和/ 遗漏/ 率/ 等/ 的/ 平均值/ ./ 实验/ 结果/ 如图/ 13/ 、/ 图/ 14/ 和/ 图/ 15/ ./ 含有/ 重复/ 事件/ 的/ 故障/ 树中/ 所有/ 的/ 独立/ 模块/ 都/ 能/ 被/ 3/ 种/ 算法/ 识别/ 出来/ ,/ 故而/ 3/ 种/ 算法/ 的/ 独立/ 模块/ 识别/ 遗漏/ 率/ 都/ 为/ 零/ ,/ 为/ 节省/ 篇幅/ 没有/ 列入/ 文中/ ./ 由图/ 13/ 、/ 图/ 14/ 和/ 图/ 15/ 可知/ ,/ IIMKDR/ 方法/ 对于/ 含有/ 重复/ 事件/ 的/ 故障/ 树/ ,/ 其/ 独立/ 模块/ 和/ 最小/ 独立/ 模块/ 的/ Page13/ 错加率/ 和/ 遗漏/ 率/ 都/ 为/ 零/ ,/ 也就是说/ 该/ 方法/ 能够/ 准确/ 识别/ 含有/ 重复/ 事件/ 故障/ 树/ 的/ 独立/ 模块/ 和/ 最小/ 独立/ 模块/ ./ 而/ Sun/ 方法/ 和/ Huang/ 方法/ 对于/ 独立/ 模块/ 的/ 识别/ 虽然/ 遗漏/ 率为/ 零/ ,/ 但/ 仍/ 有/ 错加率/ ;/ 且/ 对/ 最小/ 独立/ 模块/ 的/ 识别/ 既有/ 错加率/ 又/ 有/ 遗漏/ 率/ ,/ 也就是说/ 这/ 两种/ 方法/ 不/ 适用/ 含有/ 重复/ 事件/ 故障/ 树/ 的/ 模块/ 识别/ ./ 实验/ 2/ ./ 仅/ 含/ 相互依赖/ 基本/ 事件/ 的/ 故障/ 树/ ./ 每次/ 故障/ 树/ 生成/ 时/ ,/ 总/ 事件/ 个数/ 设定/ 为/ 600/ ,/ 依赖/ 类型/ 组合/ 随机/ 生成/ ,/ 重复/ 10000/ 次/ ,/ 仅/ 保留/ 每种/ 依赖/ 类型/ 数目/ 的/ 案例/ 数/ 大于/ 20/ 的/ 情况/ ,/ 并/ 按照/ 不同/ 的/ 依赖/ 类型/ 数目/ 求/ 识别/ 时间/ 、/ 遗漏/ 率/ 、/ 错加率/ 等/ 平均值/ ./ 实验/ 结果/ 如图/ 16/ 、/ 图/ 17/ 所示/ ./ 图/ 17Huang/ 方法/ 对/ 含有/ 相互依赖/ 基本/ 事件/ 在/ IIMKDR/ 方法/ 的/ 实现/ 中/ ,/ 每个/ 基本/ 事件/ 都/ 归属于/ 且/ 仅/ 归属于/ 一个/ 依赖/ 类型/ ,/ 而/ 平时/ 所称/ 的/ 相互依赖/ 基本/ 事件/ 是/ 指/ 多个/ 基本/ 事件/ 归属于/ 同一个/ 依赖/ 类型/ ./ 图/ 16/ 和/ 图/ 17/ 中/ 所指/ 的/ 依赖/ 类型/ 数目/ 等价/ 于/ IIMKDR/ 方法/ 中/ 所/ 关联/ 基本/ 事件/ 数/ 大于/ 1/ 的/ 依赖/ 类型/ 数目/ ./ 在/ 本次/ 实验/ 中/ ,/ 总结/ 点数/ 是/ 一定/ 的/ ,/ 当/ 依赖/ 类型/ 数/ 增加/ 时/ ,/ 则/ IIMKDR/ 实现/ 中仅/ 含/ 一个/ 基本/ 节点/ 的/ 依赖/ 类型/ 数目/ 会/ 有/ 相应/ 减少/ 的/ 趋势/ ,/ 正如/ 图/ 16/ 所示/ ,/ 在/ 依赖/ 类型/ 数目/ 处于/ 区间/ (/ 102/ ~/ 142/ )/ 时/ ,/ 时间/ 开销/ 呈/ 下降/ 的/ 态势/ ./ 当然/ 该种/ 下降/ 态势/ 并非/ 是/ 绝对/ 的/ ,/ 但是/ 足以/ 说明/ IIMKDR/ 方法/ 的/ 时间/ 开销/ 与/ 依赖/ 类型/ 数目/ 之间/ 并/ 没有/ 递增/ 的/ 关系/ ./ Huang/ 方法/ 并/ 不/ 区分/ 相互依赖/ 基本/ 事件/ 和/ 一般/ 事件/ ,/ 故而/ 其/ 时间/ 开销/ 基本/ 保持/ 不变/ ./ 而/ 当/ 依赖/ 类型/ 增加/ 时/ ,/ Sun/ 方法/ 处理/ 依赖/ 信息/ 及/ 有关/ 寻觅/ 最小/ 模块/ 所/ 花费/ 的/ 开销/ 就/ 会/ 增加/ ,/ 从而/ 导致/ 其/ 与/ 依赖/ 类型/ 数目/ 有/ 递增/ 的/ 关系/ ./ 对于/ 仅/ 含/ 相互依赖/ 基本/ 事件/ 的/ 故障/ 树/ ,/ IIMKDR/ 方法/ 和/ Sun/ 方法/ 均/ 能/ 正确/ 识别/ ,/ 而/ Huang/ 方法/ 则/ 会/ 产生/ 独立/ 模块/ 识别/ 错加率/ 和/ 最小/ 独立/ 模块/ 识别/ 错加率/ 及/ 遗漏/ 率/ ./ 也就是说/ 只有/ IIMKDR/ 方法/ 和/ Sun/ 方法/ 可以/ 对仅/ 含/ 相互依赖/ 基本/ 事件/ 的/ 故障/ 树/ 进行/ 模块/ 识别/ ./ Page14/ 的/ 故障/ 树/ 实验/ 3/ ./ 不含/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 每次/ 故障/ 树/ 生成/ 时/ ,/ 总/ 事件/ 个数/ 随机/ 从/ 100/ 到/ 300/ 取值/ ,/ 每个/ 实验/ 数据/ 都/ 是/ 重复/ 70/ 次/ 的/ 平均值/ ./ 实验/ 结果/ 如图/ 18/ 所示/ ./ 图/ 183/ 种/ 算法/ 对/ 不/ 含/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 3/ 种/ 算法/ 都/ 能够/ 正确/ 识别/ 不/ 含/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 故障/ 树/ 的/ 独立/ 模块/ 和/ 最小/ 独立/ 模块/ ,/ 由于/ 错误率/ 都/ 是/ 0/ ,/ 为/ 节省/ 篇幅/ 就/ 不列图/ 了/ ./ 由图/ 18/ 可/ 看出/ ,/ 3/ 种/ 算法/ 中/ ,/ IIMKDR/ 方法/ 时间/ 开销/ 略高于/ Sun/ 和/ Huang/ ,/ Sun/ 的/ 时间/ 开销/ 又/ 略高于/ Huang/ ./ 实验/ 4/ ./ 既含/ 重复/ 事件/ 又/ 含/ 相互依赖/ 基本/ 事件/ 的/ 故障/ 树/ ./ 因变量/ :/ 识别/ 时间/ 、/ 遗漏/ 率/ 、/ 错加率/ ;/ 实验/ 参数/ :/ 节点/ 个数/ :/ 600/ ;/ 重复/ 事件/ 数/ :/ 100/ ;/ 依赖/ 类型/ 数/ :/ 100/ ;/ 实验/ 方法/ :/ 故障/ 树/ 生成/ 时/ ,/ 总/ 事件/ 个数/ 、/ 重复/ 事件/ 个数/ 、/ 依赖/ 类型/ 数/ 分别/ 设置/ 为/ 600/ 、/ 100/ 、/ 100/ ,/ 重复/ 事件/ 的/ 位置/ 和/ 相互依赖/ 基本/ 事件/ 的/ 位置/ 皆/ 随机/ 生成/ ,/ 重复/ 10000/ 次/ ,/ 并/ 求解/ 时间/ 开销/ 、/ 错加率/ 和/ 遗漏/ 率/ 等/ 的/ 平均值/ ./ 实验/ 结果/ 如表/ 2/ 所示/ ,/ 其中/ IMSPE/ 、/ IMSNE/ 、/ MIMSPE/ 和/ MIMSNE/ 分别/ 为/ 独立/ 模块/ 错加率/ 、/ 独立/ 模块/ 遗漏/ 率/ 、/ 最小/ 独立/ 模块/ 错加率/ 和/ 最小/ 独立/ 模块/ 遗漏/ 率/ ./ 表/ 2/ 既含/ 重复/ 事件/ 又/ 含/ 相互依赖/ 基本/ 事件/ 的/ IIMKDR11/ ./ 9930000Sun10/ ./ 8730.37100/ ./ 3660.343/ Huang10/ ./ 3630.68200/ ./ 7130.707/ 若/ 一个/ 故障/ 树中/ 既/ 含/ 重复/ 事件/ 又/ 含/ 相互依赖/ 基本/ 事件/ ,/ 则/ IIMKDR/ 方法/ 能够/ 正确/ 识别/ 出/ 独立/ 模块/ 和/ 最小/ 独立/ 模块/ ;/ Sun/ 方法/ 和/ Huang/ 方法/ 在/ 独立/ 模块/ 的/ 识别/ 过程/ 中/ ,/ 虽然/ 其/ 遗漏/ 率为/ 0/ ,/ 但是/ 其错/ 加率/ 大于/ 0/ ,/ 也就是说/ 会/ 将/ 一些/ 不是/ 独立/ 模块/ 的/ 节点/ 识别/ 为/ 独立/ 模块/ ./ 由于/ Sun/ 方法/ 能够/ 处理/ 相互依赖/ 的/ 基本/ 事件/ ,/ 故而/ 其错/ 加率/ 要/ 明显/ 低于/ Huang/ 方法/ ./ 从表/ 2/ 也/ 可/ 看出/ ,/ IIMKDR/ 方法/ 的/ 识别/ 时间/ 要/ 略高于/ Sun/ 方法/ 和/ Huang/ 方法/ ./ 9/ 结论/ 独立/ 模块/ 的/ 识别/ 在/ 动态/ 故障/ 树/ 研究/ 中/ 具有/ 极其重要/ 的/ 意义/ ,/ 它/ 是/ 灵敏性/ 分析/ 、/ 可靠性/ 的/ 定性/ 和/ 定量分析/ 的/ 基础/ ./ 本文/ 提出/ 了/ 一种/ 基于/ 亲戚/ 依赖/ 关系/ 的/ 独立/ 模块/ 识别方法/ IIMKDR/ ,/ 并/ 将/ 之/ 与/ 其它/ 两种/ 方法/ 进行/ 了/ 对比/ ,/ 理论/ 分析/ 及/ 实验/ 结果/ 均/ 表明/ :/ 它/ 可以/ 对/ 具有/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 的/ 动态/ 故障/ 树/ 进行/ 处理/ ,/ 而/ 其它/ 两种/ 方法/ 都/ 不/ 具备/ 这样/ 的/ 功能/ ;/ 对于/ 不/ 含/ 相互依赖/ 基本/ 事件/ 和/ 重复/ 事件/ 的/ 故障/ 树/ ,/ 处理/ 开销/ 略高于/ Sun/ 和/ Huang/ ./ 下/ 一步/ 我们/ 将/ 把/ IIMKDR/ 方法/ 应用/ 到/ 动态/ 故障/ 树/ 的/ 重要/ 度/ 分析/ 研究/ 中/ ,/ 使/ 其能/ 显著/ 降低/ 问题/ 求解/ 的/ 代价/ ./ 

