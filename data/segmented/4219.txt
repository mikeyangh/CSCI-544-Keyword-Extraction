Page1/ 基于/ 模糊/ 聚类/ 的/ 推测/ 多线程/ 划分算法/ 李远成/ 阴培培/ 赵/ 银亮/ (/ 西安交通大学/ 计算机科学/ 与/ 技术/ 系/ 西安/ 710049/ )/ 摘要/ 推测/ 多线程/ (/ SpeculativeMultithreading/ ,/ SpMT/ )/ 技术/ 是/ 一种/ 实现/ 非/ 规则/ 程序/ 自动/ 并行/ 化/ 的/ 有效途径/ ./ 然而/ ,/ 如何/ 有效/ 评估/ 由/ 诸如/ 控制/ 、/ 数据/ 依赖/ 等/ 因素/ 导致/ 的/ 多种/ 并行/ 开销/ 并/ 实现/ 最优/ 线程/ 划分/ 一直/ 是/ 制约/ 加速/ 比/ 性能/ 提升/ 的/ 关键问题/ ./ 基于/ 启发式/ 规则/ 的/ 传统/ 划分/ 方法/ 虽然/ 可以/ 取得/ 一定/ 的/ 加速/ 效果/ ,/ 但/ 由于/ 启发式/ 规则/ 只能/ 对/ 多种/ 并行/ 开销/ 进行/ 定性/ 评估/ ,/ 因而/ 导致/ 只能/ 得到/ 经验/ 上/ 较优/ 的/ 线程/ 划分/ ./ 针对/ 传统/ 划分/ 方法/ 的/ 局限性/ ,/ 文中/ 首次/ 提出/ 并/ 实现/ 了/ 一种/ 基于/ 模糊/ 聚类/ 的/ 线程/ 划分/ 方法/ ./ 在/ 该/ 方法/ 中/ ,/ 作者/ 首先/ 提出/ 一种/ 评估/ 模型/ 来/ 定量/ 评估/ 各种/ 并行/ 开销/ ,/ 然后/ 通过/ 深入分析/ 各种/ 并行/ 开销/ 来/ 确定/ 最佳/ 的/ 线程/ 解/ 搜索/ 空间/ ,/ 最终/ 利用/ 聚类/ 方法/ 实现/ 有效/ 线程/ 解/ 空间/ 搜索/ 以求/ 取/ 更优/ 的/ 线程/ 划分/ ./ 基于/ Olden/ 程序/ 集/ 的/ 测试/ 结果表明/ ,/ 文中/ 提出/ 的/ 线程/ 划分/ 方法/ 可以/ 有效/ 地/ 对/ 非/ 规则/ 程序/ 进行/ 划分/ ,/ 其/ 平均/ 加速/ 比/ 可/ 达到/ 1.85/ ./ 关键词/ 推测/ 多线程/ ;/ 线程/ 划分/ ;/ 模糊/ 聚类/ ;/ 自动/ 并行/ 化/ ;/ 代价/ 评估/ 1/ 引言/ 挖掘/ 并行性/ 是/ 提高/ 串行/ 程序执行/ 性能/ 的/ 有效/ 方法/ 之一/ ./ 随着/ 超标/ 量/ (/ Superscalar/ )/ 和/ 指令/ 级/ 并行/ (/ ILP/ )/ 等/ 技术/ 遇到/ 越来越/ 多/ 的/ 瓶颈/ 以及/ 片上/ 多处理器/ (/ CMP/ )/ 的/ 迅速/ 发展/ ,/ 线程/ 级/ 并行/ (/ TLP/ )/ 逐渐/ 成为/ 一个/ 更佳/ 的/ 选择/ ./ 近年来/ ,/ 推测/ 多线程/ (/ SpMT/ )/ 技术/ [/ 1/ -/ 3/ ]/ 作为/ 一个/ 能/ 有效/ 开发/ 非/ 规则/ 程序/ 并行性/ 的/ 线程/ 级/ 并行/ 技术/ ,/ 已经/ 得到/ 了/ 迅速/ 发展/ ./ SpMT/ 技术/ 一般/ 采用/ 软硬件/ 协同/ 设计/ 的/ 方法/ 实现/ 串行/ 程序/ 的/ 并行执行/ ./ 在/ SpMT/ 系统/ 中/ ,/ 编译器/ 通过/ 在/ 程序/ 中/ 插入/ 边界/ 指令/ 和/ 推测/ 指令/ 将/ 程序/ 划分/ 成/ 多个/ 推测/ 线程/ ,/ 并/ 在/ 存在/ 大量/ 控制/ 和/ 数据/ 等/ 依赖/ 的/ 情况/ 下/ ,/ 以/ 激进/ 的/ 方式/ 挖掘/ 线程/ 级/ 并行性/ ./ 在/ 推测/ 执行/ 过程/ 中/ ,/ 由/ 执行/ 模型/ 检测/ 控制/ 和/ 数据/ 等/ 依赖/ 的/ 发生/ ,/ 并/ 采取/ 撤销/ 和/ 重新/ 运行/ 等/ 硬件/ 手段/ 来/ 保证/ 程序执行/ 的/ 正确性/ ./ SpMT/ 技术/ 在/ 有效/ 提升/ 程序执行/ 性能/ 的/ 同时/ ,/ 诸如/ 控制/ 、/ 数据/ 依赖/ 等/ 导致/ 的/ 多种/ 并行/ 开销/ 成为/ 制约/ 程序/ 加速/ 比/ 进一步提高/ 的/ 重要/ 因素/ ./ 在/ SpMT/ 系统/ 中/ ,/ 线程/ 划分/ 是/ SpMT/ 编译器/ 的/ 核心/ ,/ 线程/ 划分/ 的/ 结果/ 直接/ 决定/ 了/ 推测/ 多线程/ 编译器/ 的/ 最终/ 性能/ ./ 因此/ ,/ 有效/ 评估/ 诸如/ 控制/ 、/ 数据/ 依赖/ 等/ 因素/ 导致/ 的/ 多种/ 并行/ 开销/ 并/ 实现/ 最优/ 推测/ 多线程/ 划分/ 将/ 是/ 提升/ 加速/ 比/ 性能/ 的/ 主要/ 途径/ 之一/ ./ 目前/ ,/ 研究者/ 已经/ 提出/ 了/ 多种/ 推测/ 多线程/ 划分/ 方法/ [/ 4/ -/ 5/ ]/ ./ 同时/ ,/ 诸多/ 优化/ 技术/ 如值/ 预测/ [/ 6/ ]/ 和/ 分支/ 预测/ [/ 7/ ]/ 等/ 技术/ 也/ 被/ 大量/ 提出/ 用以/ 进一步/ 消减/ 线程/ 间/ 的/ 数据/ 和/ 控制/ 等/ 依赖/ 造成/ 的/ 开销/ ./ 从/ 整体/ 上/ 看/ ,/ 这些/ 划分/ 方法/ 都/ 取得/ 了/ 一定/ 的/ 加速/ 效果/ ,/ 但/ 却/ 存在/ 以下/ 局限性/ :/ (/ 1/ )/ 现有/ 线程/ 划分/ 方法/ 的/ 核心/ 都/ 是/ 基于/ 启发式/ 规则/ ,/ 而/ 这些/ 基于/ 经验性/ 的/ 启发式/ 规则/ 只能/ 对/ 多种/ 并行/ 开销/ 进行/ 定性/ 评估/ ,/ 这/ 将/ 导致/ 现有/ 的/ 划分/ 方法/ 只能/ 得到/ 经验/ 上/ 较优/ 的/ 线程/ 划分/ 解/ ;/ (/ 2/ )/ 虽然/ 有些/ 方法/ 通过/ 建立/ 动态/ 评估/ 模型/ 在/ 一定/ 程度/ 上/ 克服/ 了/ 定性/ 评估/ 的/ 不足/ ,/ 但是/ 其/ 低效/ 的/ 评估/ 方法/ 严重/ 限制/ 了/ 此类/ 方法/ 的/ 进一步/ 应用/ ./ 针对/ 现有/ 线程/ 划分/ 方法/ 存在/ 的/ 局限/ ,/ 为了/ 更加/ 深入/ 探索/ 线程/ 划分/ 影响/ 程序/ 加速/ 比/ 的/ 内在/ 规律/ ,/ 本文/ 首次/ 提出/ 一种/ 可以/ 有效/ 搜索/ 线程/ 划分/ 解/ 空间/ 以/ 寻求/ 更优/ 解/ 的/ 线程/ 划分/ 方法/ ,/ 即/ 基于/ 模糊/ 聚类/ (/ FuzzyClusteringMethod/ ,/ FCM/ )/ 的/ 线程/ 划分/ 方法/ ./ 该/ 方法/ 首先/ 通过/ 深入分析/ 各种/ 影响/ 加速/ 比/ 性能/ 的/ 并行/ 开销/ ,/ 并/ 结合/ 启发式/ 规则/ 确定/ 有效/ 的/ 线程/ 划分/ 解/ 的/ 搜索/ 空间/ ./ 然后/ ,/ 基于/ 对/ 多种/ 并行/ 开销/ 的/ 分析/ ,/ 提出/ 一种/ 定量/ 评估/ 多种/ 并行/ 开销/ 的/ 评估/ 模型/ 来/ 判定/ 聚类/ 结果/ 的/ 有效性/ ./ 在/ 此基础/ 上/ ,/ 利用/ FCM/ 算法/ 对/ 线程/ 解/ 空间/ 进行/ 搜索/ ,/ 进而/ 求取/ 更优/ 的/ 线程/ 划分/ ./ 最后/ ,/ 本文/ 将/ 提出/ 的/ 划分/ 方法/ 在/ 项目组/ 开发/ 的/ Prophet/ 编译系统/ 平台/ [/ 8/ ]/ 上/ 进行/ 了/ 实现/ ./ 基于/ Olden/ 测试程序/ 集/ [/ 9/ ]/ 的/ 实验/ 结果表明/ ,/ 本文/ 提出/ 的/ 线程/ 划分/ 方法/ 可以/ 有效/ 地/ 对/ 非/ 规则/ 程序/ 进行/ 推测/ 多线程/ 划分/ ,/ 相对/ 于/ 传统/ 的/ 基于/ 启发式/ 规则/ 的/ 线程/ 划分/ 方法/ ,/ 本文/ 方法/ 可以/ 取得/ 平均/ 9.9/ %/ 加速/ 比/ 性能/ 提升/ ,/ 其/ 平均/ 加速/ 比值/ 达到/ 了/ 1.85/ ./ 2/ 推测/ 多线程/ 技术/ 2.1/ SpMT/ 执行/ 模型/ 在/ Prophet/ 并行/ 编译器/ 中/ ,/ 串行/ 程序/ 被/ 划分/ 成为/ 多个/ 推测/ 线程/ 进行/ 执行/ ,/ 每个/ 推测/ 线程/ 执行程序/ 的/ 不同/ 部分/ ,/ 程序/ 的/ 串行/ 语义/ 用以/ 保证/ 推测/ 线程/ 的/ 提交/ 顺序/ ./ 在/ 并行/ 推测/ 执行/ 中/ ,/ 有且/ 只有/ 一个/ 是非/ 推测/ 线程/ ,/ 该/ 线程/ 可以/ 提交/ 其/ 执行/ 结果/ ,/ 代表/ 程序/ 当前/ 确定/ 执行/ 的/ 状态/ ./ 其它/ 线程/ 为/ 推测/ 线程/ ,/ 由/ 串行/ 程序代码/ 片段/ 及其/ 预计/ 算/ 片段/ (/ pre/ -/ computationslice/ ,/ p/ -/ slice/ )/ 构成/ ,/ 线程/ 间/ 以/ 前驱/ 和/ 后继/ 的/ 形式/ 保持/ 串行/ 程序/ 的/ 语义/ ./ p/ -/ slice/ 是/ 由/ 编译器/ 根据/ 程序/ 切片/ 技术/ 生成/ 的/ 一小/ 段/ 代码/ ,/ 用来/ 对/ 推测/ 线程/ 使用/ 的/ live/ -/ ins/ 变量/ (/ 指/ 线程/ 体/ 使用/ 但/ 并非/ 由该/ 线程/ 定义/ 的/ 值/ )/ 进行/ 值/ 预测/ ./ 如图/ 1/ 所示/ ./ 激发/ 点/ (/ SpawnPoint/ ,/ SP/ )/ 和准/ 控制/ 无关/ 点/ (/ ControlQuasi/ -/ IndependentPoint/ ,/ CQIP/ )/ 指令/ 对/ 唯一/ 确定/ 一个/ 激发/ 线程/ 对/ ./ 串行/ 程序/ 中/ 插入/ SP/ -/ CQIP/ 点/ 就/ 被/ 映射/ 为/ 推测/ 多线程/ 程序/ ,/ SpMT/ 程序/ 中/ 忽略/ SP/ -/ CQIP/ 就/ 得到/ 串行/ 程序/ (/ 图/ 1/ (/ a/ )/ )/ ./ CQIP/ 点/ 把/ 程序/ 分成/ 一些/ 代码段/ ,/ 当/ 程序执行/ 到/ SP/ 点/ 的/ 时候/ ,/ 会/ 发起/ 一个/ 新/ 的/ 线程/ 并/ 推测/ 执行/ CQIP/ 点/ 之后/ 的/ 那个/ 代码段/ ./ 执行/ 过程/ 中/ 使用/ 执行/ 模型/ 检测线/ 程/ 的/ 运行/ Page3/ 情况/ ,/ 如果/ 线程/ 推测/ 执行/ 成功/ ,/ 那么/ 推测/ 线程/ 一直/ 执行/ 直到/ 自身/ 的/ CQIP/ 点/ ,/ 如图/ 1/ (/ b/ )/ 所示/ ./ 验证/ 失败/ 或/ 读后/ 写/ (/ ReadAfterWrite/ ,/ RAW/ )/ 内存/ 依赖/ 违规/ 等/ 导致/ 推测/ 执行/ 失败/ ./ 若/ 验证/ 失败/ 则/ 由父/ 线程/ 串行/ 执行/ 验证/ 失败/ 的/ 代码段/ ,/ 如图/ 1/ (/ c/ )/ 所示/ ,/ 否则/ ,/ 在/ 当前/ 的/ 状态/ 下/ 重新启动/ 该/ 线程/ ,/ 再次/ 谋求/ 推测/ 执行/ 成功/ ,/ 如图/ 1/ (/ d/ )/ 所示/ ./ 2.2/ 推测/ 并行/ 开销/ 在/ SpMT/ 并行执行/ 模式/ 下/ ,/ 主要/ 有/ 5/ 种/ 开销/ 影响/ 推测/ 多线程/ 的/ 并行/ 性能/ ./ 这/ 5/ 种/ 开销/ 分别/ 为/ :/ 线程/ 分发/ 和/ 提交/ 开销/ 、/ 线程/ 间通信/ 开销/ 、/ 缓冲区/ 溢出/ 开销/ 、/ 线程/ 撤销/ 和/ 重启/ 开销/ 以及/ 线程/ 负载/ 不/ 平衡/ 开销/ 等/ ./ 在/ 这/ 5/ 种/ 开销/ 中/ ,/ 缓冲区/ 溢出/ 开销/ 、/ 线程/ 撤销/ 和/ 重启/ 开销/ 以及/ 线程/ 负载/ 不/ 平衡/ 开销/ 是/ 影响/ 并行/ 性能/ 最大/ 的/ 3/ 种/ 开销/ [/ 10/ ]/ ./ 线程/ 分发/ 和/ 提交/ 开销/ 主要/ 是/ 由/ 调度/ 一个/ 新/ 线程/ 到/ 处理单元/ 和/ 将/ 推测/ 缓冲区/ 数据/ 向/ 安全/ 存储器/ 传输/ 并/ 更新/ 等/ 时间/ 组成/ ./ 此/ 开销/ 主要/ 取决于/ 硬件/ 总线/ 带宽/ 以及/ 线程/ 需要/ 处理/ 的/ 数据量/ 的/ 大小/ 等/ 因素/ ./ 线程/ 间通信/ 开销/ 主要/ 由/ 处理单元/ 等待/ 前驱/ 线程/ 进行/ 值/ 传递/ 的/ 时间/ 构成/ ./ 此/ 开销/ 主要/ 依赖于/ 体系结构/ 对/ 同步/ 寄存器/ 或者/ 内存/ 通信/ 的/ 支持/ ,/ 同时/ 也/ 受到/ 线程/ 间通信/ 点/ 位置/ 以及/ 通信/ 频率/ 的/ 影响/ ./ 推测/ 缓冲区/ 溢出/ 开销/ 则/ 主要/ 是/ 由于/ 推测/ 缓冲区/ 溢出/ 处理单元/ 保持/ 等待/ 状态/ 直至/ 成为/ 非/ 推测/ 或者/ 被/ 撤销/ 所/ 引起/ 的/ 时间/ 组成/ ./ 此/ 开销/ 主要/ 和/ 缓冲区/ 物理/ 大小/ 、/ 缓冲区/ 的/ 组织/ 结构/ 以及/ 线程/ 体/ 大小/ 有关/ ./ 对于/ 以上/ 3/ 种/ 开销/ 来说/ ,/ 尽管/ 开销/ 的/ 大小/ 在/ 一定/ 程度/ 上/ 会/ 受到/ 不同/ 划分/ 策略/ 的/ 影响/ ,/ 但/ 其/ 共同/ 特点/ 就是/ 更多地/ 受到/ 硬件/ 体系结构/ 因素/ 的/ 影响/ ,/ 例如/ 总线/ 互联/ 机制/ 、/ 缓冲区/ 大小/ 、/ 高速缓存/ 以及/ 内存/ 的/ 访问/ 机制/ 等等/ ./ 线程/ 撤销/ 和/ 重启/ 开销/ 主要/ 由于/ 发生/ 控制/ 和/ 数据/ 依赖/ 推测/ 失败/ 所/ 导致/ ./ 如图/ 2/ 所示/ ,/ 当/ 线程/ 0/ 验证/ 线程/ 1/ 时/ ,/ 发现/ 线程/ 0/ 实际/ 执行/ 时/ 的/ 直接/ 后继/ 不是/ 线程/ 1/ 或者/ 线程/ 1/ 所/ 使用/ 的/ 预测/ 数据/ 是/ 错误/ 的/ ,/ 此时/ 将/ 发生/ 控制/ 或/ 数据/ 依赖/ 违规/ ./ 因此/ ,/ 线程/ 1/ 将会/ 被/ 撤销/ 并/ 重启/ 执行/ ,/ 同时/ ,/ 线程/ 1/ 的/ 所有/ 子/ 线程/ 将/ 全部/ 被/ 撤销/ ,/ 同时/ 处理单元/ 2/ 和/ 处理单元/ 3/ 被/ 释放/ ,/ 并/ 重新分配/ 给/ 新/ 激发/ 的/ 推测/ 线程/ (/ 2/ 和/ 3/ 可能/ 是/ 线程/ 2/ 和/ 3/ ,/ 也/ 可能/ 是/ 其它/ 的/ 推测/ 线程/ )/ ./ 这些/ 回滚/ 线程/ 的/ 执行/ 时间/ 就/ 构成/ 了/ 线程/ 撤销/ 和/ 重启/ 的/ 时间/ 开销/ ./ 负载/ 不/ 平衡/ 开销/ 则/ 主要/ 是/ 由于/ 线程/ 粒度/ 大小不一/ 造成/ 的/ ./ 如图/ 2/ 所示/ ,/ 线程/ 1/ 的/ 粒度/ 小于/ 线程/ 0/ ,/ 因此/ 在线/ 程/ 0/ 执行/ 完/ 并/ 验证/ 线程/ 1/ 之前/ ,/ 处理单元/ 1/ 将/ 处于/ 等待/ 状态/ ./ 这些/ 等待时间/ 就/ 构成/ 了/ 负载/ 不/ 平衡/ 开销/ ./ 此/ 两种/ 开销/ 的/ 一个/ 共同/ 特点/ 就是/ 严重/ 依赖于/ 线程/ 划分/ 策略/ ,/ 合理/ 的/ 线程/ 划分/ 策略/ 能够/ 有效/ 地/ 减少/ 这/ 两种/ 开销/ 所/ 造成/ 的/ 影响/ ./ 图/ 2/ 控制/ 、/ 数据/ 依赖/ 和/ 负载/ 不/ 平衡/ 开销/ 示意图/ 在/ 本文/ 中/ ,/ 假设/ 硬件/ 体系结构/ 是/ 基于/ 良好/ 设计/ 的/ ,/ 可以/ 有效/ 地/ 减少/ 前/ 3/ 种/ 开销/ ./ 本文/ 主要/ 关注/ 于/ 如何/ 有效/ 定量/ 评估/ 这/ 2/ 种/ 并行/ 开销/ ,/ 并/ 提出/ 一种/ 高效/ 的/ 线程/ 划分/ 方法/ 来/ 实现/ 更加/ 合理/ 的/ 线程/ 划分/ ./ 2.3/ 基于/ 预计/ 算/ 的/ 值/ 预测/ 在/ 推测/ 并行执行/ 中/ ,/ 值/ 预测/ 技术/ 作为/ 一种/ 有效/ 减少/ 数据/ 依赖/ 开销/ 的/ 技术/ 得到/ 了/ 研究者/ 的/ 广泛/ 研究/ ./ 目前/ ,/ 预计/ 算/ 片段/ 技术/ 作为/ 一种/ 有效/ 的/ 值/ 预测/ 技术/ 已经/ 得到/ 了/ 广泛/ 的/ 应用/ ./ 预计/ 算/ 片段/ 技术/ 是/ 一种/ 基于/ 程序/ 切片/ 技术/ [/ 11/ -/ 12/ ]/ 的/ 值/ 预测/ 方法/ ,/ 它/ 通过/ 对/ 推测/ 线程/ 的/ live/ -/ ins/ 变量/ 构建/ 预计/ 算/ 片段/ ,/ 并/ 在/ 推测/ 线程/ 执行/ 前/ 预先/ 执行/ 此/ 代码/ 片段/ 实现/ 推测/ 值/ 的/ 预测/ ./ 构建/ 预计/ 算/ 片段/ 主要/ 分为/ 3/ 个/ 步骤/ :/ (/ 1/ )/ 构建/ 基于/ 程序控制/ 流图/ 的/ 数据/ 依赖图/ ;/ (/ 2/ )/ 确定/ 推测/ 线程/ 的/ live/ -/ ins/ 变量/ ;/ (/ 3/ )/ 构建/ 基于/ live/ -/ ins/ 变量/ 的/ 程序/ 片段/ ./ 在/ Prophet/ 中/ ,/ 为了/ 有效/ 减少/ 预计/ 算/ 开销/ ,/ 编译器/ 只是/ 从/ CQIP/ 到/ SP/ 沿/ 推测/ 路径/ 前向/ 遍历/ ,/ 构建/ 推测/ 线程/ 的/ 预计/ 算/ 片段/ ,/ 因此/ 预计/ 算/ 片段/ 不/ 正确/ 的/ 可能/ 原因/ 或者/ 是/ 发生/ 需要/ 的/ live/ -/ ins/ 位于/ 非/ 推测/ 路径/ 上/ ,/ 或者/ 产生/ 该/ live/ -/ ins/ 的/ 指令/ 来自/ 于/ 非/ 推测/ 路径/ ./ 另外/ ,/ 当/ 构建/ 预计/ 算/ 片段/ 过程/ 中/ 遇到/ 函数调用/ 指令/ 时/ ,/ 如果/ 将/ 函数调用/ 指令/ 调用/ 的/ 子程序/ 全部/ 包含/ 进/ 预计/ 算/ 片段/ ,/ 这/ 就/ 可能/ 导致/ 预计/ 算/ 片段/ 非常/ 庞大/ ,/ 而/ 一般/ 情况/ 下/ ,/ 子程序/ 中/ 很多/ 代码/ 可能/ 根本/ 是/ 不/ 需要/ 的/ ./ 因此/ ,/ 本文/ 采取/ 了/ 比较/ 保守/ 的/ 方案/ ,/ 即/ 在/ 产生/ 的/ 预计/ 算/ 片段/ 中/ 裁剪/ 函数调用/ 指令/ ./ 3/ 基于/ FCM/ 的/ 线程/ 划分/ 框架/ 3.1/ 基本/ 思想/ SpMT/ 技术/ 在/ 允许/ 存在/ 大量/ 控制/ 和/ 数据/ 依赖/ 的/ Page4/ 情况/ 下/ ,/ 试图/ 以/ 激进/ 的/ 方式/ 挖掘/ 线程/ 级/ 并行性/ ./ 研究/ 结果表明/ ,/ 如果/ 线程/ 选择/ 合理/ ,/ 并/ 采用/ 合适/ 的/ 值/ 预测/ 技术/ ,/ 推测/ 并行/ 能/ 获得/ 远远/ 高于/ 超标/ 量/ 获得/ 的/ 加速/ 比/ ,/ 极大地提高/ 系统/ 性能/ ./ 在/ SpMT/ 系统/ 中/ ,/ 编译器/ 一般/ 是/ 基于/ 程序/ CFG/ ,/ 按照/ 某一/ 选定/ 的/ 推测/ 路径/ 进行/ 线程/ 划分/ ./ 线程/ 划分/ 的/ 本质/ 就是/ 将/ 推测/ 路径/ 上/ 的/ 代码/ 以/ 基本块/ 为/ 单位/ 划分/ 成/ 多个/ 线程/ 组合/ (/ 即/ 线程/ 解/ )/ ./ 如果/ 将/ 推测/ 路径/ 所/ 包含/ 的/ 基本块/ 看作/ 若干个/ 有序/ 对象/ xi/ ,/ 构建/ 一个/ 由/ 这些/ 对象/ 组成/ 的/ 样本/ 集/ ,/ 则/ 针对/ 每个/ 过程/ 的/ 线程/ 划分/ 可以/ 看作/ 是/ 将/ 此/ 样本/ 集/ 按照/ 一定/ 的/ 划分/ 策略/ 进行/ 分类/ 的/ 过程/ ,/ 所有/ 的/ 分类/ 结果/ 构成/ 线程/ 划分/ 的/ 解集/ ./ 直观/ 地/ ,/ 样本/ 集/ 分类/ 的/ 类别/ 数目/ c/ 的/ 范围/ 为/ [/ 1/ ,/ 对象/ 个数/ ]/ ./ 基于/ 2.2/ 节对/ 并行/ 开销/ 的/ 分析/ 可知/ ,/ 线程/ 负载/ 不/ 平衡/ 是/ 影响/ 加速/ 比/ 性能/ 最/ 重要/ 的/ 因素/ 之一/ ,/ 在线/ 程/ 划分/ 时/ 如何/ 尽可能/ 使/ 线程/ 负载/ 趋于/ 平衡/ 至关重要/ ./ 因此/ ,/ 对/ 每个/ 分类/ 数/ c/ 所/ 对应/ 的/ 划分/ 解/ 子集/ ,/ 可以/ 近似/ 认为/ 线程/ 负载/ 最/ 平衡/ 的/ 划分/ 解将/ 具有/ 最佳/ 的/ 加速/ 比/ 性能/ ./ 对于/ 一个/ 串行/ 程序/ ,/ 由于/ 将/ 其/ 代码/ 划分/ 为/ 多个/ 线程/ 单元/ 本质/ 上/ 可以/ 看作/ 是/ 一个/ 分类/ 问题/ ,/ 因此/ 这使/ 引入/ 现有/ 的/ 基于/ 搜索/ 的/ 分类/ 技术/ 应用/ 于/ 线程/ 划分/ 成为/ 可能/ ./ 同时/ ,/ 由于/ 在/ CMP/ 上将/ 线程/ 划分/ 为/ 执行/ 时间/ 最优/ 的/ 多个/ 推测/ 线程/ 是/ NP/ 完全/ 问题/ [/ 13/ ]/ ,/ 对/ 线程/ 划分/ 解/ 空间/ 的/ 完全/ 搜索/ 将/ 可能/ 会/ 导致/ 无法/ 承担/ 的/ 巨大/ 开销/ ./ 因此/ ,/ 需要/ 一种/ 折中/ 的/ 方案/ 来/ 平衡/ 搜索/ 所/ 引发/ 的/ 开销/ 和/ 搜索/ 所求/ 取/ 的/ 线程/ 划分/ 解/ 的/ 加速/ 比/ 性能/ ,/ 即/ 基于/ 搜索/ 的/ 线程/ 划分/ 方法/ 结合/ 一定/ 的/ 启发式/ 规则/ 进行/ ./ 通过/ 结合/ 启发式/ 规则/ 将/ 可以/ 大大简化/ 需要/ 搜索/ 的/ 线程/ 划分/ 解/ 空间/ ,/ 同时/ 也/ 可以/ 进一步/ 降低/ 搜索/ 过程/ 的/ 复杂性/ 并/ 加速/ 更优/ 线程/ 划分/ 解/ 的/ 求解/ 过程/ ./ 另外/ ,/ FCM/ 方法/ 作为/ 一种/ 有效/ 的/ 聚类/ 划分/ 技术/ ,/ 目前/ ,/ 已/ 被/ 大量/ 研究/ ./ 和/ 通常/ 将/ 数据/ 进行/ 硬性/ 划分/ 的/ 一般/ 划分/ 方法/ 不同/ ,/ FCM/ 方法/ 实现/ 了/ 一种/ 软/ 划分/ ,/ 其聚类/ 结果/ 描述/ 了/ 样本/ 属于/ 各个/ 类别/ 的/ 不确定性/ 程度/ ./ 这种/ 聚类/ 结果/ 的/ 模糊性/ 将/ 非常适合/ 应用/ 于/ 推测/ 多线程/ 的/ 划分/ ,/ 即/ 通过/ FCM/ 确定/ 各个/ 不同/ 基本块/ 隶属于/ 不同/ 线程/ 单元/ 的/ 隶属/ 度/ ,/ 然后/ 利用/ 基于/ 经验/ 得来/ 的/ 启发式/ 规则/ 来/ 确定/ 最终/ 的/ 线程/ 划分/ ./ 正/ 基于/ 以上/ 分析/ ,/ 本文/ 自然/ 地/ 提出/ 一种/ 基于/ 模糊/ 聚类/ 的/ 线程/ 划分/ 方法/ ./ 该/ 方法/ 首先/ 对/ 分类/ 数目/ c/ 构成/ 的/ 划分/ 解/ 空间/ 进行/ 搜索/ ,/ 然后/ 根据/ 聚类/ 结果/ 描述/ 的/ 样本/ 属于/ 类别/ 的/ 隶属/ 度/ ,/ 并/ 结合/ 启发式/ 规则/ 来/ 确定/ 最佳/ 的/ 划分/ ./ 显然/ ,/ 每个/ 类别/ 包含/ 的/ 对象/ 所/ 代表/ 的/ 基本块/ 就/ 自然/ 地/ 构成/ 了/ 一个/ 推测/ 线程/ ./ 3.2/ 基于/ 模糊/ 聚类/ 的/ 线程/ 划分/ 3.2/ ./ 1/ 模糊/ 聚类/ 算法/ FCM/ 算法/ 是/ 一种/ 基于/ 划分/ 的/ 聚类/ 算法/ ./ 给定/ 一/ 含有/ N/ 个/ 向量/ 的/ 样本/ 集/ S/ =/ {/ xj/ ,/ j/ =/ 1/ ,/ …/ ,/ N/ }/ ,/ xj/ ∈/ RP/ ,/ 算法/ 的/ 目标/ 就是/ 将/ 样本/ 集/ S/ 划分/ 到/ c/ 个/ 类别/ 集/ {/ 1/ ,/ 2/ ,/ …/ ,/ c/ }/ ,/ 使得/ 被/ 划分/ 到/ 同/ 一类/ 的/ 对象/ 之间/ 相似/ 度/ 最大/ ,/ 而/ 不同/ 类/ 之间/ 的/ 相似/ 度/ 最小/ ./ FCM/ 的/ 目标/ 函数/ 的/ 一般/ 形式/ 为/ 其/ 约束条件/ 为式/ 中/ ,/ 犝/ 为/ 模糊/ 隶属/ 度/ 矩阵/ ,/ 犞/ 为/ 聚类/ 中心/ 矩阵/ ,/ X/ 为/ 样本/ 集合/ ,/ c/ 为/ 聚类/ 数/ ,/ xj/ ∈/ RP/ 为/ 第/ j/ 个/ 数据/ ,/ uij/ 为/ xj/ 属于/ 第/ i/ 类/ 的/ 隶属/ 度/ ,/ m/ ∈/ [/ 1/ ,/ +/ ]/ 是/ 一个/ 加权指数/ ./ 对式/ (/ 1/ )/ 用/ 拉格朗/ 日/ 乘法/ 构造/ 最小化/ 的/ 目标/ 函数/ ,/ 可得求/ 其/ 最优/ 解/ 的/ 必要条件/ :/ FCM/ 算法/ 的/ 输出/ 是/ c/ 个/ 聚类/ 中心点/ 向量/ 和/ 一个/ c/ ×/ N/ (/ N/ 为/ 样本/ 个数/ )/ 的/ 模糊/ 划分/ 矩阵/ ,/ 这个/ 矩阵/ 表示/ 的/ 是/ 每个/ 样本/ 属于/ 每个/ 类/ 的/ 隶属/ 度/ ./ 根据/ 这个/ 划分/ 矩阵/ 按照/ 模糊/ 集合/ 中/ 的/ 最大/ 隶属/ 原则/ 就/ 能够/ 确定/ 每个/ 样本/ 归为/ 哪个/ 类/ ./ 本文/ 提出/ 的/ 模糊/ 聚类/ 划分/ 方法/ 正是/ 通过/ 将/ 线程/ 划分/ 问题/ 转化/ 为/ 聚类/ 划分/ 问题/ ,/ 然后/ 通过/ 判定/ 聚类/ 结果/ 的/ 有效性/ 来/ 求得/ 最佳/ 线程/ 划分/ 解/ ./ 在/ 本文/ 提出/ 的/ 线程/ 划分/ 方法/ 中/ ,/ FCM/ 过程/ 是/ 作为/ 划分/ 过程/ 的/ 其中/ 一个/ 处理/ 环节/ ,/ FCM/ 算法/ 处理/ 的/ 是/ 每/ 一个/ 对象/ 程序/ 的/ 结构化/ 和/ 归一化/ 结果/ ,/ 输出/ 结果/ 给出/ 的/ 是/ 不同/ 程序/ 块/ 对/ 不同/ 线程/ 单元/ 的/ 隶属/ 程度/ 描述/ ./ 对于/ 给定/ 的/ 某/ 一聚/ 类数/ ,/ 其/ 线程/ 划分/ 解是/ 根据/ 启发式/ 规则/ 来/ 最终/ 确定/ ./ 和/ 经典/ 的/ 人工智能/ 、/ 统计/ 学习/ 理论/ 以及/ 专家系统/ 等/ 领域/ 使用/ 的/ 模糊/ 理论/ 相比/ ,/ 其/ 主要/ 区别/ 在于/ 确定/ 最终/ 线程/ 划分/ 解/ 的/ 知识/ 并非/ 来源于/ 聚类分析/ ,/ 而是/ 来源于/ 程序/ 行为/ 分析/ 的/ 结果/ ;/ 某一/ 程序/ 对象/ 的/ FCM/ 过程/ 输出/ 的/ 不同/ 程序/ 块/ 对/ 不同/ 线程/ 单元/ 的/ 隶属/ 程度/ 知识/ 并/ 不能/ 被/ 用以/ 和/ 启发式/ 规则/ 结合/ ,/ 并/ 指导/ 其它/ 程序/ 对象/ 的/ 聚类分析/ 过程/ ./ Page53/ ./ 2.2/ 形式化/ 预处理/ (/ 1/ )/ 结构化分析/ 本文/ 提出/ 的/ 线程/ 方法/ 是/ 基于/ 程序/ CFG/ 进行/ 推测/ 多线程/ 划分/ ./ 因此/ ,/ 为了/ 便于/ 对/ 推测/ 路径/ 上/ 的/ 代码/ 构建/ 样本/ 集/ ,/ 需要/ 对/ 程序/ CFG/ 进行/ 结构化/ 预处理/ ./ 首先/ ,/ 利用/ 程序/ 剖析/ 技术/ 提取/ 包括/ 分支/ 概率/ 、/ 循环/ 和/ 过程/ 调用/ 的/ 动态/ 指令/ 数目/ 、/ 循环/ 迭代/ 次数/ 等/ 信息/ ,/ 建立/ 基本块/ 层级/ 的/ 加权/ 控制流/ 图/ WCFG/ ./ 然后/ ,/ 在/ WCFG/ 基础/ 上/ ,/ 进行/ 结构化分析/ 并/ 建立/ 超级/ 控制流/ 图/ SCFG/ ./ 在/ SCFG/ 中/ ,/ 过程/ 调用/ 和/ 循环/ 区域/ 均/ 被/ 归结为/ 类似/ 于/ 基本块/ 的/ 形式/ ,/ 即/ 超级/ 块/ ./ 对于/ 过程/ 调用/ ,/ 其/ 指令/ 数目/ 大小/ 可/ 采用/ 如下/ 表达式/ 计算/ :/ 对于/ 循环/ 区域/ ,/ 处理/ 方式/ 如图/ 3/ 例子/ 所示/ ./ 首先/ ,/ 通过/ 对/ 循环/ 区域/ 控制流/ 图/ 进行/ 剖析/ ,/ 构造/ 一个/ 循环/ 路径/ 集合/ ./ 每个/ 循环/ 路径/ 由/ 循环体/ 中/ 从/ 循环/ 入口/ 节点/ 到/ 循环/ 出口/ 点/ 的/ 一个/ 串行/ 节点/ 集/ 组成/ ./ 在/ 循环/ 区域/ 控制流/ 图中/ ,/ 一个/ 循环/ 出口/ 节点/ 可能/ 有/ 3/ 种/ 类型/ :/ (/ 1/ )/ 指向/ 循环/ 头/ 节点/ ;/ (/ 2/ )/ 指向/ 循环/ 区域/ 外部/ 节点/ ;/ (/ 3/ )/ 节点/ 调用/ 了/ 包含/ 结束/ 指令/ 的/ 过程/ 调用/ ./ 一个/ 循环/ 路径/ 可以/ 用/ 如下/ 式子/ 表示/ :/ 循环/ 路径/ =/ 路径/ 上/ 节点/ 集/ +/ 路径/ 类型/ +/ 路径/ 类型/ =/ {/ 循环/ 外/ 节点/ |/ 循环/ 头/ 节点/ |/ 退出/ 节点/ }/ ./ 然后/ ,/ 通过/ 计算/ 此/ 循环/ 路径/ 集合/ 计算/ 出/ 循环/ 区域/ 的/ 动态/ 指令/ 数目/ 大小/ ./ 其/ 具体/ 计算/ 方式/ 可用/ 如下/ 方式/ 表示/ :/ 循环/ 例程/ =/ 循环/ 体内/ 路径/ 的/ 集合/ ./ (/ 2/ )/ 归一化/ 处理/ 进一步/ ,/ 为了/ 应用/ FCM/ 算法/ ,/ 首先/ 利用/ 结构化分析/ 的/ 结果/ 来/ 构造/ 以/ 基本块/ (/ 或者/ 超级/ 块/ )/ 为/ 对象/ 的/ 样本/ 集/ S/ =/ {/ xj/ ,/ j/ =/ 1/ ,/ …/ ,/ N/ }/ ,/ 然后/ ,/ 根据/ CFG/ 中/ 的/ 控制流/ 关系/ ,/ 构造/ 所有/ 样本/ 的/ 邻接矩阵/ 犕/ adjacent/ ./ 此/ 矩阵/ 中/ 的/ 每个/ 元素/ 表示/ 对应/ 的/ 两个/ 样本/ 之间/ 的/ 控制流/ 关系/ :/ Mij/ =/ 1/ ,/ i/ →/ j/ 有/ 控制流/ 接下来/ ,/ 根据/ 犕/ adjacent/ 和/ 下述/ 规则/ ,/ 求取/ 任意/ 样本/ 之间/ 的/ 距离/ Dij/ :/ ①/ 如果/ Mij/ 值为/ 1/ ,/ 则/ Dij/ 为/ 两个/ 样本/ 所/ 代表/ 的/ 基本块/ 包含/ 的/ 动态/ 指令/ 数/ 之/ 和/ 的/ 1/ // 2/ ;/ ②/ 如果/ Mij/ 值为/ 0/ ,/ 则/ Dij/ 为/ 两个/ 样本/ 之间/ 所/ 包含/ 的/ 路径/ 的/ 距离/ ./ Dij/ 值/ 描述/ 了/ 样本/ 之间/ 的/ 距离/ ,/ 经过/ 归一化/ 处理/ ,/ 可以/ 得到/ 样本/ 集/ 的/ 距离/ 矩阵/ 犇/ distance/ :/ 显然/ ,/ 根据/ 犇/ distance/ 可以/ 很/ 容易/ 计算/ 式/ (/ 4/ )/ 和/ 式/ (/ 5/ )/ ./ 3.2/ ./ 3/ 确定/ 有效性/ 函数/ 在/ 利用/ FCM/ 算法/ 进行/ 线程/ 划分/ 时/ ,/ 如何/ 判定/ 某/ 一个/ 聚类/ 结果/ 的/ 有效性/ 是/ 一个/ 关键问题/ ./ 针对/ 这一/ 问题/ ,/ 本文/ 提出/ 了/ 一个/ 可以/ 有效/ 评估/ 各种/ 并行/ 开销/ 的/ 评估/ 模型/ ,/ 并/ 利用/ 该/ 模型/ 来/ 判定/ 聚类/ 划分/ 的/ 有效性/ ./ 图/ 4/ 给出/ 了/ 一个/ 基于/ SCFG/ 的/ 线程/ 划分/ 的/ 实例/ ,/ 图中/ 实体/ 粗线/ 表示/ 推测/ 路径/ ,/ 实体/ 细线/ 表示/ 线程/ 划分/ 的/ 边界/ ./ 图/ 4/ 中/ ,/ 在/ 最/ 可能/ 路径/ 上/ 划分/ 了/ 3/ 个/ 线程/ ,/ 分别/ 为/ 线程/ 1/ ,/ 线程/ 2/ 和/ 线程/ 3/ ./ 线程/ 1/ 包含/ 了/ 超级/ 块/ A/ 和/ B/ ,/ 线程/ 2/ 包含/ 了/ 超级/ 块/ C/ 和/ E/ ,/ 线程/ 3/ 包含/ 了/ 超级/ 块/ G/ 和/ I/ ./ 根据/ 2.1/ 节/ 描述/ 的/ Prophet/ 执行/ 模型/ 可知/ ,/ 这些/ 线程/ 将会/ 被/ 推测/ 执行/ ;/ 当/ 成功/ 执行/ 时/ 这些/ 线程/ 可以/ 对/ 并行/ 做出/ 贡献/ ,/ 其/ 执行/ 时间/ 将会/ 等价/ 成/ 并行/ 时间/ ./ 由于/ 线程/ 是/ 依据/ 推测/ 路径/ 进行/ 划分/ ,/ 推测/ 路径/ 上/ 所有/ 基本块/ (/ 或者/ 超级/ 块/ )/ 将/ 以/ 一定/ 的/ 概率/ 参与/ 并行/ ,/ 而/ 不/ 在/ 推测/ 路径/ 上/ 的/ 基本块/ (/ 或者/ 超级/ 块/ )/ 则/ 由于/ 没有/ 被/ 推测/ (/ 即使/ 实际/ 中/ 被/ 推测/ 执行/ ,/ 由于/ 在/ Prophet/ 中/ p/ -/ slice/ 只是/ 沿/ 推测/ 路径/ 进行/ 提取/ ,/ 因此/ 没有/ 进行/ 值/ 预测/ ,/ 通常/ 也/ 会/ 由于/ 数据/ 依赖/ 而/ 撤销/ ,/ 最终/ 被/ 串行/ 执行/ )/ 而/ 只能/ 串行/ 执行/ ./ 根据/ Page6Amdahl/ 定律/ ,/ 一个/ 程序/ 的/ 加速/ 比是/ 由/ 程序/ 串行/ 部分/ 的/ 运行/ 时间/ 和/ 并行/ 部分/ 的/ 运行/ 时间/ 决定/ 的/ ./ 假设/ T/ _/ Time/ 是/ 串行/ 程序执行/ 时间/ ,/ T/ _/ Seq/ 是/ 程序/ 中/ 串行/ 部分/ 的/ 执行/ 时间/ ,/ T/ _/ Par/ 是/ 程序/ 中/ 并行/ 部分/ 的/ 执行/ 时间/ ,/ 那么/ 加速/ 比/ 可以/ 用/ 如下/ 的/ 公式/ 计算/ :/ 设/ 推测/ 路径/ 上/ 有/ n/ 个/ 节点/ ,/ 则/ 可/ 构造/ 由/ 这/ n/ 个/ 节点/ 组成/ 的/ 集合/ N/ =/ {/ nt/ ,/ 1/ / t/ / n/ }/ ,/ 同时/ ,/ 假设/ Probt/ 为/ 节点/ nt/ 沿/ 推测/ 路径/ 的/ 分支/ 概率/ ./ 图/ 5/ 构建/ 线程/ 激发/ 树/ 的/ 例子/ 对于/ 线程/ 结点/ Tl/ ,/ 假设/ Wl/ 是/ 线程/ Tl/ 的/ 执行/ 时间/ ,/ 并且/ 假设/ 当/ 推测/ 成功/ 时/ ,/ Wl/ 是/ 此/ 线程/ 相对/ 于/ 其父/ 线程/ 结点/ 的/ 等价/ 并行/ 时间/ ./ 进一步/ 假设/ T/ _/ equ/ _/ Tl/ 是/ 以/ Tl/ 为根/ 结点/ 的/ 线程/ 激发子/ 树/ 的/ 等价/ 并行执行/ 时间/ ./ 以图/ 6/ 为例/ ,/ 对于/ 线程/ 结点/ Tl/ ,/ 如果/ 线程/ 结点/ Tl/ 是/ 一个/ 根/ 结点/ ,/ 则/ Wl/ 等于/ T/ _/ equ/ _/ Tl/ ./ 如果/ Tl/ 不是/ 根/ 结点/ ,/ 假设/ P/ _/ Sl/ 是/ Tl/ 的/ 预计/ 算/ 片段/ 的/ 执行/ 时间/ ./ 对于/ Tl/ 的/ 父/ 线程/ Tpar/ ,/ SPpar/ 是/ 线程/ 的/ 发起/ 代价/ ,/ (/ 1/ )/ 计算/ T/ _/ Par/ 接下来/ ,/ 本文/ 详细/ 说明/ 如何/ 评估/ 各种/ 并行/ 开销/ 并/ 最终/ 求取/ 某一/ 划分/ 的/ 理论/ 加速/ 比/ ./ 对/ 某/ 一/ 过程/ ,/ 假设/ 共/ 划分/ 为/ L/ 个/ 线程/ ,/ 则/ 对/ 每个/ 线程/ Tl/ ,/ 1/ / l/ / L/ ,/ 根据/ 集合/ N/ 构建/ 集合/ Tl/ _/ path/ =/ {/ nm/ ,/ 1/ / t/ / M/ }/ ,/ nm/ 为/ 所有/ 位于/ 从/ 线程/ l/ 开始/ 的/ 节点/ 到/ 线程/ l/ 的/ 末尾/ 节点/ 路径/ 上/ 的/ 节点/ ./ 则/ 线程/ l/ 被/ 推测/ 执行/ 的/ 概率/ 可以/ 由/ 下面/ 式子/ 来/ 计算/ :/ 下面/ ,/ 我们/ 通过/ 构建/ 并/ 遍历/ 线程/ 激发/ 树来/ 计算/ 程序/ 的/ 并行执行/ 等价/ 时间/ T/ _/ Par/ ./ 图/ 5/ 给出/ 了/ 1/ 个/ 激发/ 树/ 构造/ 的/ 例子/ ./ 图/ 5/ (/ a/ )/ 中/ ,/ 最/ 左边/ 的/ 线程/ 是/ 确定/ 线程/ ,/ 其它/ 的/ 都/ 是/ 推测/ 线程/ ./ 1/ 个/ 线程/ 的/ 推测/ 级/ 越/ 高/ ,/ 则/ 它/ 越/ 具有/ 推测/ 性/ ,/ 也/ 越/ 靠近/ 右边/ ./ 线程/ 发起/ 的/ 顺序/ 为/ ①/ →/ ②/ →/ ③/ →/ ④/ →/ ⑤/ →/ ⑥/ →/ ⑦/ ,/ 串行/ 执行/ 顺序/ 为/ ①/ →/ ⑥/ →/ ⑦/ →/ ④/ →/ ③/ →/ ⑤/ →/ ②/ ./ 图/ 5/ (/ b/ )/ 中是/ 程序/ 对应/ 的/ 线程/ 激发/ 树/ ,/ 激发/ 树中/ 推测/ 级别/ 高/ 的/ 线程/ 处于/ 树/ 的/ 右侧/ ./ Cp/ 是/ 线程/ 的/ 验证/ 代价/ ,/ 而/ Cl/ 是/ 线程/ 的/ 提交/ 代价/ ./ 则/ 对于/ Tl/ ,/ 我们/ 可以/ 按照/ 下面/ 式子/ 计算/ 它/ 的/ Wl/ :/ Wl/ =/ T/ _/ equ/ _/ Tl/ ,/ ifTlisroot/ 烄/ (/ P/ _/ Sl/ +/ T/ _/ equ/ _/ Tl/ )/ -/ (/ Wpar/ -/ SPpar/ +/ Cp/ )/ 烅/ Cl/ ,/ if/ (/ P/ _/ Sl/ +/ T/ _/ equ/ _/ Tl/ )/ -/ (/ Wpar/ -/ SPpar/ +/ Cp/ )/ / 烆/ Page7/ 根据/ 式/ (/ 10/ )/ ,/ 我们/ 通过/ 广度/ 遍历/ 激发/ 树来/ 计算/ T/ _/ equ/ _/ Tl/ ./ 假设/ 它/ 的/ 孩子/ 结点/ 为/ Tli/ ,/ i/ =/ 0/ ,/ 1/ ,/ …/ ,/ k/ (/ k/ =/ 1/ ,/ 2/ ,/ …/ )/ ./ 为了/ 模拟/ 撤销/ 和/ 重启/ 代价/ ,/ 假设/ α/ l/ 是/ 在/ Tl/ 的/ 执行/ 过程/ 中/ 发生/ 数据/ 违规/ 的/ 概率/ ./ 那么/ 我们/ 可以/ 用/ 算法/ 1/ 的/ 函数/ T/ _/ equ/ (/ Tl/ )/ 来/ 计算/ T/ _/ equ/ _/ Tl/ ./ 显然/ T/ _/ Par/ 可以/ 通过/ 如式/ (/ 11/ )/ 来/ 确定/ :/ 算法/ 1/ ./ 计算/ 每个/ 激发/ 树/ 的/ 等价/ 执行/ 时间/ ./ 输入/ :/ 激发/ 树/ T/ 输出/ :/ T/ _/ equ/ (/ Tl/ )/ 1/ ./ T/ _/ equ/ (/ threadnodeTl/ )/ {/ 2/ ./ T/ _/ equ/ _/ Tl/ =/ 0/ ;/ 3/ ./ IF/ (/ Tlisleafnode/ )/ 4/ ./ T/ _/ equ/ _/ Tl/ =/ PlWl/ ;/ 5/ ./ ELSE/ {/ foreachchildnodeTli6/ ./ T/ _/ equ/ _/ Tl/ =/ PlWl/ +/ 7/ ./ Pli/ ∑/ k8/ ./ returnT/ _/ equ/ _/ Tl/ ;/ }/ 在/ 本文/ ,/ 我们/ 利用/ 程序/ 切片/ 技术/ 对/ 推测/ 线程/ 进行/ 了/ 值/ 预测/ ,/ 因此/ ,/ 当/ 线程/ l/ 以/ 概率/ Pl/ 被/ 推测/ 时/ ,/ 我们/ 近似/ 认为/ 线程/ 将会/ 成功/ 执行/ 而/ 不会/ 由于/ 数据/ 依赖/ 发生/ 撤销/ (/ 此时/ α/ =/ 0/ )/ ./ 另外/ ,/ 由于/ 我们/ 采取/ 了/ 保守/ 的/ 预计/ 算/ 片段/ 策略/ ,/ 对/ 子程序/ 和/ 循环体/ 等/ 超级/ 块/ 没有/ 进行/ 值/ 预测/ ,/ 因此/ ,/ 我们/ 保守/ 地/ 认为/ 由于/ 复杂/ 的/ 数据/ 依赖/ ,/ 对于/ 包含/ 超级/ 块/ 线程/ 的/ 推测/ 始终/ 是/ 失败/ 的/ (/ 此时/ α/ =/ 1/ )/ ./ (/ 2/ )/ 计算/ T/ _/ Seq/ 在/ 推测/ 执行/ 模式/ 下/ ,/ 所有/ 的/ 线程/ Tl/ 都/ 在/ 概率/ Pl/ 下/ 被/ 推测/ 并行执行/ ./ 设/ T/ _/ Time/ 是/ 程序/ 串行/ 的/ 执行/ 时间/ ,/ 则/ 推测/ 执行/ 模式/ 下/ 的/ 程序/ 串行/ 部分/ 的/ 执行/ 时间/ 可以/ 通过/ 如下/ 的/ 式子/ 进行/ 计算/ :/ 根据/ 式/ (/ 9/ )/ 、/ (/ 11/ )/ 、/ (/ 12/ )/ ,/ 对于/ 任意/ 一种/ 线程/ 划分/ ,/ 我们/ 都/ 可以/ 计算/ 出其/ 理论/ 加速/ 比值/ ./ 即/ 对/ 某/ 一个/ 聚类/ 划分/ ci/ ,/ 其聚类/ 有效性/ 函数/ 可以/ 由下式/ 来/ 定义/ :/ 3.2/ ./ 4/ 基于/ FCM/ 的/ 线程/ 划分/ 在/ 本节/ ,/ 本文/ 给出/ 详细/ 的/ 基于/ FCM/ 算法/ 的/ 线程/ 划分/ 方法/ ./ 首先/ ,/ 为了/ 进一步/ 缩小/ 搜索/ 范围/ 并/ 减少/ 搜索/ 开销/ ,/ 基于/ 3.1/ 节/ 的/ 分析/ ,/ 我们/ 可以/ 摈弃/ 一些/ 显然/ 会/ 导致/ 严重/ 负载/ 不/ 平衡/ 的/ 线程/ 划分/ ,/ 最终/ 确定/ 聚类/ 数/ 范围/ 为/ [/ 1/ ,/ c/ ]/ ,/ 其中/ c/ 由下式/ 来/ 确定/ :/ 式/ (/ 14/ )/ 中/ ,/ xt/ 表示/ 其/ 代表/ 的/ 基本块/ 的/ 动态/ 指令/ 数目/ ./ 然后/ ,/ 对/ 某/ 一/ 确定/ 的/ ci/ ,/ 应用/ FCM/ 算法/ 对/ 样本/ 集/ S/ 进行/ 划分/ ./ 根据/ 算法/ 输出/ 的/ 隶属/ 度/ 矩阵/ ,/ 我们/ 依据/ 算法/ 2/ 来/ 确定/ 具体/ 的/ 推测/ 线程/ ,/ 即/ 确定/ 线程/ 边界/ CQIP/ 点/ 位置/ ./ 在/ 算法/ 2/ 中/ ,/ 我们/ 设定/ 阈值/ ε/ =/ 10/ -/ 4/ ,/ 即/ 当/ 某/ 一/ 基本块/ 对/ 不同/ 的/ 线程/ 中心/ 隶属/ 度/ 相差/ 在/ 此/ 阈值/ 范围/ 之内/ 时/ ,/ 结合/ 启发式/ 规则/ ,/ 将/ 按照/ 更/ 有利于/ 减少/ 控制/ 依赖/ 发生/ 的/ 原则/ 来/ 判定/ 此/ 基本块/ 的/ 归属/ 类别/ ./ 算法/ 2/ ./ 确定/ 候选/ 推测/ 线程/ ./ 输入/ :/ 关系/ 矩阵/ 犝/ ,/ 聚类/ 中心/ 矩阵/ 犞/ ,/ 阈值/ ε/ 输出/ :/ 二维/ 矩阵/ 犚/ [/ n/ ,/ ci/ ]/ ,/ 每个/ 候选/ 推测/ 线程/ Tci1/ ./ Determine/ _/ Threads/ (/ 犝/ ,/ 犞/ ,/ ε/ ,/ 犚/ [/ n/ ,/ ci/ ]/ )/ 2/ ./ FOR/ (/ 1/ =/ </ j/ ;/ j/ ++/ ;/ j/ </ =/ n/ )/ 3/ ./ {/ temp/ =/ thefirstcolumnnumberofthemax/ (/ 犝/ (/ j/ )/ )/ ;/ 4/ ./ 犚/ [/ j/ ,/ temp/ ]/ =/ temp/ ;/ }/ 5/ ./ FOR/ (/ 1/ =/ </ j/ ;/ j/ ++/ ;/ j/ </ =/ n/ )/ 6/ ./ FOR/ (/ 1/ =/ </ k/ ,/ k/ ++/ ,/ k/ </ =/ ci/ )/ 7/ ./ {/ IF/ (/ 犚/ [/ j/ ,/ k/ ]/ !/ =/ 犚/ [/ j/ +/ 1/ ,/ k/ ]/ )/ &/ 8/ ./ {/ ifnodejisthepost/ -/ dominatorofthestartnode9/ ./ 犚/ [/ j/ ,/ k/ ]/ =/ k/ +/ 1/ ;/ }/ }/ 接下来/ ,/ 对于/ 已经/ 确定/ 的/ 候选/ 推测/ 线程/ ,/ 分别/ 在/ 适当/ 的/ 位置/ 插入/ 其/ 相应/ 的/ 激发/ 点/ ./ 同时/ ,/ 由于/ 线程/ 划分/ 的/ NP/ 特性/ ,/ 即使/ 在/ 使用/ 了/ 前述/ 一些/ 典型/ 启发式/ 规则/ 情况/ 下/ ,/ 此/ 插入/ 过程/ 仍然/ 会/ 导致/ 很大/ 的/ 开销/ ./ 因此/ ,/ 为了/ 进一步/ 降低/ 复杂性/ 以/ 减少/ 开销/ ,/ 本文/ 进一步/ 引入/ 几个/ 典型/ 的/ 启发/ 规则/ 指导/ 最终/ 的/ 线程/ 划分/ ,/ 以/ 达到/ 更好/ 地/ 搜索/ 开销/ 和/ 搜索/ 精度/ 的/ 折中/ 效果/ ./ 这些/ 启发式/ 规则/ 主要/ 包括/ :/ (/ 1/ )/ 激发/ 点/ SP/ 可以/ 在/ 激发/ 线程/ 的/ 任意/ 位置/ ;/ (/ 2/ )/ 激发/ 点/ SP/ 和/ 相应/ 的/ CQIP/ 点/ 必须/ 位于/ 同一/ 过程/ 体/ 或者/ 循环/ 体内/ ;/ Page8/ (/ 3/ )/ 为了/ 减少/ 发生/ 数据/ 依赖/ 的/ 概率/ ,/ 数据/ 依赖/ 数目/ [/ 14/ ]/ (/ 用/ 两个/ 线程/ 之间/ 的/ 数据/ 依赖/ 弧/ 个数/ 来/ 量度/ )/ 必须/ 小于/ 某/ 一个/ 阈值/ ./ 算法/ 3/ 给出/ 了/ 详细/ 的/ 激发/ 点/ SP/ 插入/ 算法/ 的/ 描述/ ./ 算法/ 3/ 中/ ,/ get/ _/ candidate/ _/ thread/ (/ )/ 函数/ 用来/ 获取/ 下/ 一个/ 有/ 可能/ 被/ 激发/ 的/ 候选/ 线程/ ,/ data/ _/ depend/ -/ ence/ _/ count/ (/ )/ 则/ 用来/ 计算/ 在/ 当前/ 激发/ 点/ 位置/ 到/ 候选/ 线程/ 之间/ 的/ 数据/ 依赖/ 数/ ./ 算法/ 3/ ./ 确定/ SP/ 的/ 位置/ ./ 输入/ :/ curr/ _/ thread/ ,/ future/ _/ thread/ ,/ spawn/ _/ pos/ 输出/ :/ spawn/ _/ pos1/ ./ insert/ _/ spawn/ _/ point/ (/ curr/ _/ thread/ ,/ future/ _/ thread/ ,/ 2/ ./ future/ _/ thread/ ·/ ·/ =/ get/ _/ candidate/ _/ thread/ (/ )/ ;/ 3/ ./ IF/ (/ curr/ _/ thread/ ./ spawn/ _/ count/ (/ )/ =/ =/ 0/ )/ 4/ ./ spawn/ _/ pos/ ·/ ·/ =/ thepositionoffirstinstruction5/ ./ WHILE/ (/ spawn/ _/ posisnotthelastinstruction/ )/ 6/ ./ opt/ _/ ddc/ =/ data/ _/ dependence/ _/ count/ (/ curr/ _/ thread/ ,/ 7/ ./ IF/ (/ opt/ _/ ddc/ </ DEP/ _/ THRESHOLD/ )/ THEN8/ ./ curr/ _/ thread/ =/ future/ _/ thread/ ;/ 9/ ./ Insert/ _/ spawn/ _/ point/ (/ curr/ _/ thread/ ,/ future/ _/ thread/ ,/ 10/ ./ ENDIF11/ ./ spawn/ _/ pos/ ·/ ·/ =/ thepositionofthenextinstruction12/ ./ ENDWHILE13/ ./ ELSE14/ ./ curr/ _/ thread/ =/ future/ _/ thread/ ;/ 15/ ./ spawn/ _/ pos/ ·/ ·/ =/ thepositionoffirstinstruction16/ ./ Insert/ _/ spawn/ _/ point/ (/ curr/ _/ thread/ ,/ future/ _/ thread/ ,/ 17/ ./ ENDIF/ }/ 下面/ ,/ 利用/ 3.2/ ./ 3/ 节/ 确定/ 的/ 有效性/ 函数/ f/ (/ ci/ )/ 对/ 每/ 一个/ ci/ 所/ 对应/ 线程/ 划分/ 进行/ 有效性/ 计算/ ./ 基于/ FCM/ 的/ 线程/ 划分算法/ 描述/ 如下/ :/ 1/ ./ 确定/ 聚类/ 分类/ 数/ 的/ 范围/ [/ cmin/ ,/ cmax/ ]/ ./ 2/ ./ 对于/ 聚类/ 分类/ 数/ c/ 从/ cmin/ 到/ cmax/ 依次/ 应用/ 如下/ 步骤/ :/ 2.1/ ./ 初始化/ 聚类/ 中心/ 犞/ (/ 0/ )/ ;/ 2.2/ ./ 应用/ 基本/ 的/ FCM/ 算法/ 更新/ 模糊/ 分类/ 矩阵/ 犝/ 和/ 聚/ 2.3/ ./ 判断/ 是否/ 收敛/ ,/ 如果/ 没有/ ,/ 转/ 步骤/ 2.2/ ;/ 否则/ 转/ 步骤/ 2.4/ ./ 通过/ 有效性/ 指标/ 函数/ 计算/ 有效性/ 指标值/ f/ (/ ci/ )/ ./ 3/ ./ 比较/ 对应/ 每个/ c/ 的/ 有效性/ 指标值/ ,/ 最大/ 指标值/ f/ (/ ci/ )/ 所/ 对应/ 的/ 线程/ 划分/ 解即/ 为/ 所求/ 的/ 最优/ 解/ ./ 3.3/ 算法/ 复杂度/ 分析/ 本文/ 提出/ 的/ 基于/ FCM/ 算法/ 的/ 线程/ 划分/ 方法/ 时间/ 复杂度/ 主要/ 包括/ 3/ 个/ 方面/ :/ FCM/ 算法/ 、/ 聚类/ 有效性/ 函数/ 计算/ 和/ 插入/ 激发/ 点/ 算法/ ./ 假设/ 样本/ 集中/ 有/ n/ 个/ 节点/ ,/ 则/ 插入/ 处理/ 激发/ 点/ 算法/ 的/ 时间/ 复杂度/ 不/ 超过/ O/ (/ n/ )/ ./ FCM/ 算法/ 包括/ 2/ 个/ 部分/ ,/ 即/ 计算/ 迭代/ 计算/ 隶属/ 度/ 矩阵/ 和/ 确定/ 候选/ 线程/ ./ 其/ 时间/ 复杂度/ 为/ O/ (/ n2/ +/ Lnp/ )/ ,/ 其中/ L/ 为/ FCM/ 的/ 迭代/ 次数/ ,/ 在/ 本文/ 中/ ,/ 由于/ 样本/ 集中/ 的/ 基本块/ 只有/ 一维/ 距离/ 属性/ ,/ 因此/ ,/ 其维数/ p/ 的/ 值/ 为/ 1/ ./ 根据/ 3.2/ ./ 3/ 节/ 的/ 分析/ ,/ 聚类/ 有效性/ 函数/ 计算/ 的/ 时间/ 复杂度/ 主要/ 由式/ (/ 9/ )/ 和/ 算法/ 1/ 组成/ ,/ 其/ 复杂度/ 为/ O/ (/ nlogn/ )/ ./ 因此/ ,/ 算法/ 总/ 的/ 时间/ 复杂度/ 为/ O/ (/ n2/ +/ Ln/ +/ nlogn/ )/ ./ 另外/ ,/ 基于/ 启发式/ 规则/ 进行/ 线程/ 划分/ 的/ 算法/ 时间/ 复杂度/ 通常/ 为/ O/ (/ nlogn/ )/ [/ 14/ -/ 15/ ]/ ,/ 但是/ 某些/ 基于/ 启发式/ 规则/ 进行/ 动态/ 评估/ 进行/ 线程/ 划分/ 的/ 算法/ 时间/ 复杂度/ 则/ 通常/ 达到/ O/ (/ n3/ )/ [/ 13/ ]/ ,/ 甚至/ 更/ 高/ 的/ 复杂度/ [/ 16/ ]/ (/ 由于/ 需要/ 通过/ 模拟器/ 模拟/ 执行/ ,/ 因此/ 将/ 依赖于/ 划分/ 对象/ 程序/ 本身/ 的/ 复杂度/ )/ ./ 本文/ 算法/ 由于/ 增加/ 了/ FCM/ 过程/ 处理/ ,/ 因此/ 时间/ 开销/ 将/ 比/ 基于/ 传统/ 启发式/ 规则/ 进行/ 划分/ 的/ 算法/ 大/ ,/ 但/ 却/ 明显/ 小于/ 利用/ 动态/ 评估/ 进行/ 线程/ 划分/ 的/ 时间/ 开销/ ./ 4/ 实验/ 评估/ 4.1/ 模拟/ 环境/ 本文/ 提出/ 的/ 基于/ FCM/ 的/ 线程/ 划分/ 方法/ 已经/ 在/ Prophet/ 编译系统/ 平台/ 上/ 进行/ 了/ 实现/ ./ Prophet/ 模拟器/ 采用/ MIPS/ 指令集/ ,/ 通过/ 扩展/ 指令集/ 实现/ 对/ SpMT/ 处理器/ 模拟/ ./ 每个/ 处理单元/ PE/ 有/ 自己/ 的/ 程序/ 计数器/ 、/ 取指令/ 单元/ 、/ 解释/ 指令/ 单元/ 和/ 执行/ 单元/ ,/ 用来/ 从/ 线程/ 中/ 取出/ 指令/ 并/ 执行/ ./ 同时/ ,/ Prophet/ 模拟器/ 包含/ 了/ ALU/ 、/ Cache/ 、/ 流水线/ 等/ 部件/ ,/ 实现/ 了/ 超标/ 量/ 流水/ 多核/ 处理器/ 的/ 模拟/ ./ 具体/ 的/ 配置/ 信息/ 见表/ 1/ ./ 取指/ 、/ 发射/ 和/ 提交/ 宽度/ 多/ 版本/ 一级/ Cache4/ 路组/ 相联/ 、/ 64KB/ ,/ 命中/ 延迟/ :/ 2/ 个/ 时钟/ 周期/ 处理单元/ 数/ 激发/ 开销/ 验证/ 开销/ 本地/ 寄存器/ 访问/ 内存/ 提交/ 开销/ 本文/ 选择/ Olden/ 测试程序/ 集/ 的/ 子集/ 对/ 论文/ 提出/ Page9/ 的/ 划分/ 方法/ 进行/ 性能/ 测试/ ./ Olden/ 基准/ 程序/ 是/ 由/ Princeton/ 大学/ 提供/ 的/ 一个/ 测试/ 集/ ,/ 具有/ 复杂/ 的/ 数据结构/ 以及/ 对/ 这些/ 数据结构/ 的/ 操作/ ,/ 例如/ 都/ 是/ 对/ 树/ 和/ 链表/ 进行/ 合并/ 、/ 遍历/ 等/ 操作/ ;/ 另外/ ,/ Olden/ 程序结构/ 大多/ 为/ 递归/ ,/ 具有/ 复杂/ 的/ 线程/ 间/ 依赖/ 关系/ ./ 因此/ ,/ Olden/ 基准/ 程序/ 测试/ 集/ 这些/ 复杂/ 的/ 控制/ 和/ 数据/ 依赖/ 的/ 特性/ ,/ 非常/ 有利于/ 测试/ 本文/ 提出/ 的/ 划分算法/ 的/ 性能/ ./ 同时/ ,/ 为了/ 获取/ 程序/ 动态/ 执行/ 的/ 信息/ ,/ 我们/ 设计/ 了/ 一个/ 训练/ 集/ ,/ 并/ 根据/ 训练/ 集/ 的/ 不同/ 输入/ ,/ 对/ 每个/ 测试程序/ 模拟/ 执行/ 大约/ 10M/ 条/ 指令/ ./ 4.2/ 实验/ 及/ 结果/ 分析/ 为了/ 展示/ 本文/ 方法/ 的/ 有效性/ ,/ 我们/ 选择/ 和/ 基于/ 一些/ 典型/ 的/ 启发式/ 规则/ 的/ 线程/ 划分/ 方法/ 进行/ 性能/ 比较/ [/ 14/ -/ 16/ ]/ ./ 这些/ 启发式/ 规则/ 除/ 本文/ 使用/ 的/ 启发式/ 规则/ (/ 如/ 3.2/ ./ 4/ 节/ 描述/ )/ 外/ ,/ 还有/ 诸如/ 线程/ 划分/ 点应/ 尽可能/ 位于/ 程序/ 的/ 控制/ 无关/ 点处/ ,/ 人为/ 设置/ 线程/ 粒度/ 大小/ 的/ 范围/ 等/ ./ 本文/ 方法/ 是/ 一种/ 结合/ 启发式/ 规则/ 和/ 搜索/ 方法/ 的/ 线程/ 划分/ 方法/ ,/ 其/ 具有/ 的/ 解/ 空间/ 搜索/ 功能/ 将/ 可以/ 有效/ 地/ 摒弃/ 单纯/ 基于/ 启发式/ 规则/ 带来/ 的/ 自上而下/ 或/ 自下而上/ 的/ 顺序/ 划分/ 的/ 局限/ ,/ 并/ 进而/ 求取/ 更优/ 的/ 线程/ 划分/ 解/ ./ 另外/ ,/ 为了/ 与/ 基于/ 这些/ 启发式/ 方法/ 进行/ 线程/ 划分/ 进行/ 对比/ ,/ 我们/ 已经/ 在/ Prophet/ 平台/ 将/ 基于/ 这些/ 启发式/ 规则/ 的/ 划分算法/ 进行/ 了/ 实现/ [/ 15/ ]/ ./ 下面/ 我们/ 首先/ 给出/ 相比/ 基于/ 启发式/ 规则/ [/ 15/ ]/ 方法/ ,/ 本文/ 方法/ 在/ 减少/ 并行执行/ 负载/ 不/ 平衡/ 开销/ 的/ 信息/ 统计/ ,/ 如表/ 2/ 所示/ ./ Olden/ 程序/ 基于/ 启发式/ MstBhPowerVoronoi7/ ./ 2Perimeter59/ ./ 034.3072/ ./ 0Em3dH/ ./ mean18/ ./ 610.1084/ ./ 2/ 表/ 2/ 中/ 第/ 2/ 列/ 和/ 第/ 3/ 列/ 分别/ 给出/ 的/ 是/ 基于/ 两种/ 方法/ 生成/ 的/ 线程/ 在/ 并行执行/ 过程/ 中/ ,/ 由于/ 负载/ 不/ 平衡/ 导致/ 的/ 处理器/ 处于/ 等待/ 状态/ 占/ 总/ 处理器/ 执行/ 时间/ 的/ 比例/ ./ 从表/ 2/ 可以/ 看出/ ,/ 负载/ 不/ 平衡/ 所/ 引起/ 的/ 开销/ 占用/ 相当/ 大/ 比例/ 的/ 处理器/ 执行/ 时间/ ,/ 尤其/ 是/ Mst/ 和/ Perimeter/ 程序/ ,/ 其/ 处理器/ 等待/ 状态/ 所/ 占/ 比例/ 分别/ 达到/ 了/ 31.4/ %/ 和/ 59.0/ %/ ,/ 严重/ 影响/ 了/ 并行执行/ 的/ 加速/ 比/ 性能/ ./ 同时/ ,/ 从/ 第/ 3/ 列/ 可以/ 看出/ ,/ 基于/ 本文/ 方法/ 生成/ 的/ 线程/ 相比/ 于/ 基于/ 启发式/ 规则/ 生成/ 的/ 线程/ 所/ 引起/ 的/ 负载/ 不/ 平衡/ 开销/ 均/ 有/ 明显/ 的/ 降低/ ,/ 特别/ 是/ Mst/ 程序/ ,/ 其/ 负载/ 不/ 平衡/ 开销/ 减少/ 比例/ 高达/ 217.2/ %/ ./ 总体/ 上/ ,/ 我们/ 可以/ 平均/ 减少/ 84.2/ %/ 负载/ 不/ 平衡/ 开销/ ,/ 这/ 说明/ 本文/ 方法/ 可以/ 有效/ 地/ 减少/ 负载/ 不/ 平衡/ 的/ 影响/ ./ 表/ 3/ 给出/ 了/ 应用/ FCM/ 算法/ 时/ ,/ Olden/ 程序/ 聚类/ 迭代/ 次数/ 的/ 统计/ 信息/ ./ 从表/ 3/ 中/ 可以/ 看出/ ,/ 所有/ 程序/ 的/ 迭代/ 次数/ 都/ 比较/ 小/ ,/ Olden/ 程序/ 的/ 平均/ 迭代/ 次数/ 仅为/ 262.7/ 次/ ./ 这/ 一方面/ 说明/ ,/ 启发式/ 规则/ 的/ 使用/ 大大简化/ 了/ 搜索/ 的/ 复杂性/ ,/ 本文/ 通过/ 结合/ 启发式/ 规则/ 来/ 确定/ 线程/ 的/ 解/ 搜索/ 空间/ 是/ 可行/ 的/ ;/ 同时/ ,/ 这/ 也/ 说明/ 了/ 由于/ 非/ 规则/ 程序/ 包含/ 的/ 过程/ 体/ 通常/ 较/ 小/ [/ 17/ ]/ ,/ 因此/ 需要/ 划分/ 的/ 样本/ 集/ 规模/ 不/ 大/ ,/ FCM/ 算法/ 可以/ 被/ 用来/ 有效/ 地/ 进行/ 推测/ 多线程/ 划分/ ./ 另外/ ,/ 由于/ FCM/ 过程/ 只是/ 作为/ 划分/ 过程/ 的/ 其中/ 一个/ 处理/ 环节/ ,/ FCM/ 算法/ 独立/ 地/ 处理/ 的/ 是/ 每/ 一个/ 对象/ 程序/ ./ 相较/ 于/ 经典/ 的/ 人工智能/ 、/ 统计/ 学习/ 理论/ 以及/ 专家系统/ 等/ 领域/ 使用/ 的/ 模糊/ 理论/ ,/ 本文/ 方法/ 中/ 的/ FCM/ 过程/ 输出/ 结果/ 仅仅/ 给出/ 了/ 不同/ 程序/ 块/ 对/ 不同/ 线程/ 单元/ 的/ 隶属/ 程度/ 描述/ ,/ 其聚类/ 所得/ 的/ 知识/ 并/ 不能/ 被/ 用以/ 和/ 启发式/ 规则/ 结合/ 以/ 指导/ 其它/ 程序/ 对象/ 的/ 聚类分析/ 过程/ ./ 因此/ ,/ 表/ 3/ 同时/ 也/ 说明/ 了/ 进一步/ 的/ 工作/ 应该/ 着重于/ 探索/ 如何/ 更好/ 地/ 结合/ FCM/ 算法/ 和/ 启发式/ 规则/ ,/ 并/ 进而/ 有效/ 利用/ FCM/ 聚类/ 知识/ 用于/ 指导/ 更好/ 地/ 进行/ 线程/ 划分/ ./ 图/ 7/ 给出/ 基于/ 本文/ 方法/ 和/ 基于/ 启发式/ 规则/ 方法/ 生成/ 的/ 推测/ 线程/ 的/ 加速/ 比/ 性能/ 对比/ ./ 从图/ 7/ 可以/ 看到/ ,/ 本文/ 方法/ 在/ 测试程序/ 集上/ 的/ 加速/ 比/ 相比/ 基于/ 启发式/ 规则/ 方法/ 均/ 有/ 不同/ 程度/ 的/ 提高/ ,/ 特别/ 是/ Peri/ -/ meter/ 、/ Bh/ 、/ Em3d/ 、/ Mst/ 等/ 程序/ 提升/ 相当/ 明显/ ./ 同时/ ,/ 从图/ 7/ 可以/ 看到/ ,/ 不同/ 程序/ 性能/ 提升/ 的/ 幅度/ 有/ 较为/ 明显/ 的/ 差距/ ./ 首先/ ,/ 这/ 说明/ 基于/ 启发式/ 规则/ 方法/ 对/ 某些/ 程序/ 确实/ 可以/ 产生/ 性能/ 很/ 好/ 的/ 推测/ 线程/ ;/ 其次/ ,/ 这/ 间接/ 说明/ 了/ 本文/ 提出/ 的/ 评估/ 方法/ 尚/ 不够/ 精确/ ,/ 导致/ 某些/ 潜在/ 的/ 开销/ 信息/ 不能/ 被/ 完全/ 提取/ ,/ 致使/ 对/ 多种/ 开销/ 的/ 评估/ 出现/ 一定/ 程度/ 的/ 偏差/ ,/ 进而/ 导致/ 聚类/ 有效性/ 函数/ 存在/ 一定/ 程度/ 的/ 不精确性/ ./ 但/ 这种/ 评估/ 偏差/ 可以/ 通过/ 提高/ 评估/ 模型/ 的/ 精确度/ 来/ 有效/ 地/ 消除/ 或/ Page10/ 者/ 降低/ 到/ 可以/ 接受/ 的/ 范围/ ./ 最后/ ,/ 这/ 也/ 说明/ 根据/ 启发式/ 规则/ 来/ 确定/ 的/ 线程/ 解/ 空间/ 存在/ 一定/ 程度/ 的/ 局限性/ ,/ 有/ 可能/ 不/ 包含/ 全局/ 最优/ 解/ ./ 另外/ ,/ 根据/ 3.3/ 节对/ 算法/ 复杂度/ 分析/ 可知/ ,/ 较/ 启发式/ 规则/ 方法/ ,/ 在/ 取得/ 更好/ 的/ 加速/ 比/ 性能/ 的/ 同时/ ,/ 本文/ 方法/ 的/ 不足之处/ 在于/ 其/ 开销/ 明显/ 增大/ ;/ 另一方面/ ,/ 结合/ 3.3/ 节/ 的/ 分析/ 可知/ ,/ 本文/ 算法/ 有效/ 解决/ 了/ 线程/ 划分/ 的/ NP/ 难题/ ,/ 算法/ 开销/ 被/ 保持/ 在/ 一定/ 的/ 范围/ 之内/ ,/ 这/ 也/ 说明/ 了/ 本文/ 提出/ 的/ 通过/ 结合/ 使用/ 启发式/ 规则/ 来/ 寻求/ 算法/ 开销/ 和/ 最终/ 线程/ 划分/ 解/ 性能/ 的/ 折中/ 方法/ 是/ 合理/ 的/ ./ 同时/ ,/ 从图/ 7/ 还/ 可以/ 看出/ ,/ Perimeter/ 程序/ 的/ 加速/ 比/ 性能/ 较/ 低/ ,/ Em3d/ 程序/ 则/ 具有/ 较/ 高/ 的/ 加速/ 比/ ,/ 这/ 主要/ 是/ 是因为/ Em3d/ 程序/ 比/ Perimeter/ 程序/ 含有/ 更/ 多/ 的/ 适合/ 推测/ 并行/ 的/ 循环体/ ./ 表/ 4/ 基于/ 两种/ 方法/ 的/ 推测/ 线程/ 动态/ 执行/ 统计/ 信息/ 激发/ 成功率/ 基于/ 启发式/ 规则/ 方法/ 基于/ FCM/ 方法/ Olden/ 程序/ Mst639Bh120275Power129359Voronoi111907perimeter9677Em3d/ 在/ 表/ 4/ 的/ 最后/ 一列/ 我们/ 给出/ 所有/ 的/ Olden/ 程序/ 加速/ 比/ 性能/ 的/ 提升/ 率/ ./ 从表/ 4/ 可以/ 看出/ ,/ 所有/ 的/ Olden/ 程序/ 都/ 有/ 从/ 1.8/ %/ 到/ 25.3/ %/ 范围/ 内/ 不同/ 程度/ 的/ 加速/ 比/ 性能/ 提升/ ./ 总之/ ,/ 上述/ 结果表明/ ,/ 本文/ 针对/ 传统/ 的/ 基于/ 启发式/ 规则/ 的/ 线程/ 划分/ 方法/ 所/ 提出/ 的/ 基于/ FCM/ 的/ 线程/ 划分/ 方法/ 可以/ 有效/ 地/ 对/ 非/ 规则/ 程序/ 进行/ 划分/ ./ 首先/ ,/ FCM/ 方法/ 可以/ 在/ 一定/ 程度/ 上/ 克服/ 单纯/ 依靠/ 具有/ 经验性/ 的/ 启发式/ 规则/ 进行/ 划分/ 的/ 局限/ ,/ 通过/ 对/ 线程/ 划分/ 解/ 空间/ 进行/ 搜索/ 将/ 可以/ 有效/ 地/ 寻求/ 更优/ 线程/ 划分/ 解/ ./ 其次/ ,/ 为了/ 有效/ 减少/ FCM/ 过程/ 的/ 开销/ ,/ 本文/ 方法/ 在/ 算法/ 开销/ 和/ 获取/ 程序/ 加速/ 比/ 之间/ 实现/ 了/ 一种/ 折中/ 方法/ ,/ 通过/ 结合/ 一些/ 典型/ 的/ 启发式/ 规则/ 将/ 复杂度/ 限制/ 在/ 了/ 一定/ 的/ 范围/ 之内/ ./ 同时/ ,/ 由于/ 本文/ 提出/ 的/ 线程/ 划分/ 方法/ 的/ 划分/ 对象/ 是/ 以/ 过程/ 为/ 单位/ 的/ 非/ 规则/ 程/ 为了/ 进一步/ 分析/ 算法/ 的/ 有效性/ ,/ 在/ 表/ 4/ ,/ 我们/ 给出/ 了/ 基于/ 本文/ 方法/ 和/ 基于/ 启发式/ 规则/ 方法/ 生成/ 的/ 推测/ 线程/ 在/ 编译器/ 并行执行/ 过程/ 中/ 的/ 动态/ 统计/ 信息/ ./ 从表/ 4/ 可以/ 看出/ ,/ 对于/ Mst/ 、/ Bh/ 、/ Power/ 、/ Em3d/ 、/ Perimeter/ 等/ 程序/ ,/ 基于/ FCM/ 方法/ 所/ 激发/ 的/ 线程/ 数目/ 均/ 有/ 较为/ 明显/ 的/ 增加/ ;/ 同时/ ,/ 虽然/ 线程/ 激发/ 成功率/ 有/ 一定/ 程度/ 的/ 下降/ ,/ 但是/ 成功/ 激发/ 的/ 线程/ 数目/ 都/ 有/ 较为/ 明显/ 的/ 增加/ ,/ 特别/ 是/ Em3d/ 程序/ ,/ 激发/ 的/ 线程/ 总数/ 增加/ 了/ 近/ 2.2/ 倍/ ,/ 但/ 激发/ 成功率/ 仅仅/ 下降/ 了/ 10/ %/ ./ 同时/ ,/ 从表/ 4/ 还/ 可以/ 看出/ ,/ 对于/ Voronoi/ 程序/ ,/ 和/ 其它/ 测试程序/ 不同/ ,/ 基于/ FCM/ 方法/ 所/ 激发/ 的/ 线程/ 数目/ 有/ 0.8/ %/ 的/ 减少/ ,/ 但/ 其/ 激发/ 成功率/ 却/ 有/ 2/ %/ 的/ 提升/ ,/ 且/ 总/ 的/ 成功/ 激发/ 线程/ 数目/ 仍/ 有/ 一定/ 程度/ 的/ 增加/ ./ 这/ 说明/ ,/ 基于/ FCM/ 方法/ 产生/ 的/ 推测/ 线程/ 可以/ 通过/ 激发/ 更/ 多/ 成功/ 的/ 推测/ 线程/ 来/ 挖掘/ 程序/ 的/ 并行性/ ,/ 并/ 因此/ 带来/ 加速/ 比/ 性能/ 提升/ ./ 进一步/ ,/ 定义/ 加速/ 比/ 性能/ 提升/ 率为/ 性能/ 提升/ 率/ =/ 基于/ FCM/ 加速/ 比/ -/ 基于/ 启发式/ 规则/ 加速/ 比/ 0.74050/ ./ 93830.74100/ ./ 93800.57090/ ./ 6486/ 序/ ,/ 而/ 非/ 规则/ 程序/ 的/ 过程/ 体/ 大都/ 规模较/ 小/ ,/ 因此/ 对以/ 过程/ 体/ 构成/ 的/ 小/ 样本/ 集/ 进行/ 划分/ 也/ 非常/ 适用/ 于/ 应用/ FCM/ 算法/ ./ 总体/ 上/ ,/ 相对/ 于/ 基于/ 典型/ 的/ 启发式/ 规则/ 的/ 划分/ 方法/ ,/ 本文/ 方法/ 取得/ 了/ 平均/ 9.9/ %/ 加速/ 比/ 性能/ 提升/ ./ 5/ 相关/ 工作/ SpMT/ 技术/ 作为/ 一个/ 能/ 有效/ 挖掘/ 非/ 规则/ 程序/ 并行性/ 的/ 线程/ 级/ 并行/ 方法/ ,/ 目前/ 已经/ 得到/ 了/ 迅速/ 发展/ ./ 在/ SpMT/ 系统/ 中/ ,/ 线程/ 划分/ 技术/ 是/ 最为/ 关键/ 的/ 技术/ ,/ 其/ 线程/ 划分/ 结果/ 将/ 直接/ 决定/ SpMT/ 编译器/ 的/ 最终/ 性能/ ./ Bhowmik/ 等/ 人/ [/ 14/ ]/ 通过/ 构建/ 基于/ SUIF/ -/ MachSUIF/ 编译/ 框架/ 的/ 推测/ 多线程/ 方案/ ,/ 利用/ 控制流/ 图/ 和/ 数据流/ 图/ 关联/ 关系/ ,/ 提出/ 一个/ 基于/ 相对/ 最/ 可/ Page11/ 能/ 路径/ 的/ 线程/ 划分算法/ ./ Wang/ 等/ 人/ [/ 18/ ]/ 采用/ 编译/ 时/ 的/ 静态/ 程序/ 剖分/ 技术/ 提取/ 程序/ 的/ 代码/ 特征/ ,/ 评估/ 循环/ 结构/ 的/ 并行/ 代价/ 开销/ ,/ 寻找/ 出/ 最优/ 线程/ 边界/ 和/ 激发/ 点/ 位置/ ,/ 最终/ 将/ 整个/ 程序/ 分解/ 为/ 多个/ 线程/ ./ 从/ 整体/ 上/ 看/ ,/ 这些/ 单纯/ 基于/ 启发式/ 规则/ 方法/ 的/ 划分算法/ 都/ 取得/ 了/ 一定/ 的/ 加速/ 效果/ ,/ 但是/ 由于/ 启发式/ 规则/ 只能/ 对/ 多种/ 并行/ 开销/ 进行/ 定性/ 评估/ ,/ 因而/ 这些/ 方法/ 只能/ 得到/ 经验/ 上/ 较优/ 的/ 线程/ 划分/ ./ 为了/ 克服/ 启发式/ 规则/ 只能/ 定性/ 评估/ 多种/ 并行/ 开销/ 的/ 局限/ ,/ Carlos/ 等/ 人/ [/ 16/ ]/ 提出/ 一种/ 通过/ 实际/ 动态/ 执行/ 模式/ 来/ 评估/ 并行/ 开销/ 的/ 评估/ 模型/ ,/ 最终/ 选取/ 并行/ 性能/ 最佳/ 的/ 推测/ 线程/ ,/ 实现/ 程序/ 的/ 线程/ 划分/ ./ 类似/ 地/ ,/ Luo/ 等/ 人/ [/ 19/ ]/ 通过/ 引入/ 硬件/ 性能/ 计数器/ ,/ 建立/ 了/ 一个/ 软硬件/ 评估/ 模型/ 来/ 动态/ 评估/ 程序运行/ 时/ 的/ 性能/ ,/ 并/ 从中/ 选取/ 性能/ 较/ 好/ 的/ 线程/ 作为/ 推测/ 线程/ ,/ 进而/ 确定/ 线程/ 划分/ 解/ ./ 这些/ 基于/ 动态/ 评估/ 的/ 方法/ 虽然/ 取得/ 了/ 较/ 好/ 的/ 效果/ ,/ 但是/ 其/ 低效/ 的/ 评估/ 方法/ 严重/ 限制/ 了/ 算法/ 的/ 进一步/ 应用/ ./ 为了/ 克服/ 上述/ 划分/ 方法/ 的/ 不足/ ,/ 一些/ 人/ 试图/ 引入/ 机器/ 学习/ 技术/ 指导/ 线程/ 划分/ ./ Wang/ 等/ 人/ [/ 20/ ]/ 采用/ 程序/ 剖分/ 技术/ 提取/ 循环/ 结构特征/ ,/ 构建/ 基于/ 推测/ 线程/ 映射/ 的/ 性能/ 调整/ 模型/ ,/ 从/ 推测/ 线程/ 执行/ 的/ 调度/ 角度/ 探讨/ 如何/ 进一步提高/ 加速/ 比/ 性能/ ./ Tournavitis/ 等/ 人/ [/ 21/ ]/ 则/ 试图/ 通过/ 收集/ 运行/ 时/ 的/ 信息/ 作为/ 训练样本/ ,/ 抽取/ 控制/ 和/ 依赖/ 的/ 特征/ ,/ 建立/ 一种/ 分析模型/ 来/ 计算/ 数据/ 依赖/ 值/ 并/ 进而/ 指导/ 线程/ 划分/ ./ 和/ 前述/ 方法/ 中/ 仅仅/ 应用/ 机器/ 学习/ 方法/ 间接/ 用于/ 提高/ 加速/ 比/ 性能/ 不同/ ,/ 在/ 本文/ ,/ 我们/ 通过/ 引入/ 模糊/ 聚类/ 方法/ ,/ 首次/ 提出/ 了/ 一种/ 基于/ 对/ 线程/ 解/ 空间/ 进行/ 搜索/ 的/ 线程/ 划分/ 方法/ ./ 该/ 方法/ 可以/ 有效/ 地/ 克服/ 传统/ 的/ 仅仅/ 基于/ 经验性/ 的/ 划分/ 思想/ ,/ 更加/ 深入/ 探索/ 线程/ 划分/ 影响/ 程序/ 加速/ 比/ 的/ 内在/ 规律/ ./ 这/ 对于/ 多核/ 处理器/ 研发/ 、/ 加速/ 现有/ 串行/ 应用程序/ 都/ 将/ 有着/ 重要/ 的/ 理论意义/ 和/ 应用/ 价值/ ./ 6/ 结论/ 及下/ 一步/ 的/ 工作/ 线程/ 划分/ 是/ SpMT/ 技术/ 的/ 关键因素/ 之一/ ./ 因此/ ,/ 有效/ 评估/ 诸如/ 控制/ 、/ 数据/ 依赖/ 等/ 因素/ 导致/ 的/ 多种/ 并行/ 开销/ 并/ 实现/ 最优/ 线程/ 划分/ 是/ 加速/ 比/ 性能/ 提升/ 的/ 关键/ ./ 针对/ 现有/ 线程/ 划分/ 方法/ 存在/ 的/ 不足/ ,/ 本文/ 首次/ 提出/ 一种/ 可以/ 有效/ 搜索/ 线程/ 划分/ 解/ 空间/ 以/ 寻求/ 更优/ 解/ 的/ 线程/ 划分算法/ ,/ 即/ 基于/ FCM/ 的/ 线程/ 划分算法/ ./ 该/ 算法/ 首先/ 通过/ 深入分析/ 各种/ 影响/ 加速/ 比/ 性能/ 的/ 并行/ 开销/ ,/ 并/ 结合/ 启发式/ 规则/ 确定/ 了/ 有效/ 的/ 线程/ 划分/ 解/ 的/ 搜索/ 空间/ ./ 然后/ ,/ 提出/ 一种/ 评估/ 模型/ 对/ 各种/ 并行/ 开销/ 进行/ 定量/ 评估/ ,/ 进而/ 确定/ 了/ 聚类/ 算法/ 的/ 有效性/ 指标/ 函数/ ./ 在/ 此基础/ 上/ ,/ 利用/ 模糊/ 聚类/ 的/ 方法/ 对/ 线程/ 解/ 空间/ 进行/ 搜索/ 以求/ 取/ 更优/ 的/ 线程/ 划分/ ./ 该/ 线程/ 划分/ 方法/ 的/ 主要/ 创新/ 在于/ :/ (/ 1/ )/ 深入分析/ 多种/ 并行/ 开销/ ,/ 并/ 结合/ 启发式/ 规则/ 有效/ 地/ 确立/ 了/ 推测/ 线程/ 划分/ 解/ 的/ 搜索/ 空间/ ;/ (/ 2/ )/ 首次/ 提出/ 一种/ 能/ 定量/ 评估/ 各种/ 并行/ 开销/ 的/ 评估/ 模型/ ,/ 并/ 根据/ 此/ 模型/ 求取/ 任意/ 线程/ 划分/ 解/ 的/ 理论/ 加速/ 比/ 来/ 判定/ 聚类/ 的/ 有效性/ ;/ (/ 3/ )/ 首次/ 提出/ 一种/ 基于/ FCM/ 算法/ 的/ 推测/ 多线程/ 划分/ 方法/ ,/ 实现/ 对/ 线程/ 划分/ 解/ 空间/ 的/ 有效/ 搜索/ 以求/ 取/ 更优/ 的/ 线程/ 划分/ 解/ ./ 基于/ Olden/ 测试程序/ 集/ 的/ 实验/ 结果表明/ ,/ 本文/ 提出/ 的/ 基于/ FCM/ 方法/ 的/ 线程/ 划分/ 方法/ 的/ 平均/ 加速/ 比/ 达到/ 1.85/ ;/ 相对/ 于/ 传统/ 的/ 基于/ 启发式/ 规则/ 的/ 线程/ 划分/ 方法/ ,/ 本文/ 方法/ 可以/ 取得/ 平均/ 9.9/ %/ 加速/ 比/ 性能/ 提升/ ./ 这/ 说明/ ,/ 本文/ 提出/ 的/ 线程/ 划分算法/ 可以/ 有效/ 地/ 对/ 非/ 规则/ 程序/ 进行/ 推测/ 多线程/ 划分/ ./ 进一步/ 地/ ,/ 由于/ 本文/ 中/ 的/ 线程/ 解/ 空间/ 是/ 结合/ 启发式/ 规则/ 确定/ 的/ 一维/ 解/ 搜索/ 空间/ ,/ 存在/ 一定/ 程度/ 的/ 局限性/ ,/ 有/ 可能/ 不/ 包含/ 全局/ 最优/ 解/ ;/ 同时/ ,/ 本文/ 提出/ 的/ 评估/ 模型/ 尚/ 不够/ 精确/ ,/ 会/ 导致/ 某些/ 潜在/ 的/ 并行/ 开销/ 信息/ 不能/ 被/ 完全/ 提取/ ,/ 致使/ 对/ 多种/ 开销/ 的/ 评估/ 出现/ 一定/ 程度/ 的/ 偏差/ ,/ 进而/ 影响/ 聚类/ 有效性/ 函数/ 的/ 精确性/ ./ 另外/ 在/ 划分/ 过程/ 中/ ,/ 某一/ 程序/ 对象/ 的/ FCM/ 过程/ 输出/ 的/ 不同/ 程序/ 块/ 对/ 不同/ 线程/ 单元/ 的/ 隶属/ 程度/ 知识/ 并/ 不能/ 被/ 用以/ 和/ 启发式/ 规则/ 结合/ 并/ 指导/ 其它/ 程序/ 对象/ 的/ 聚类分析/ 过程/ ,/ 而/ 这些/ 聚类/ 结果/ 中/ 蕴含/ 的/ 线程/ 划分/ 的/ 规律性/ 知识/ 将/ 对/ 提升/ 加速/ 比/ 性能/ 有着/ 重要/ 意义/ ./ 因此/ ,/ 下/ 一步/ 的/ 工作/ 将/ 从/ 以下/ 3/ 个/ 方面/ 进行/ :/ (/ 1/ )/ 更/ 深入分析/ 影响/ 线程/ 划分/ 的/ 多种/ 因素/ ,/ 以/ 确定/ 包含/ 数据/ 和/ 控制/ 依赖/ 等/ 因素/ 在内/ 的/ 多维/ 线程/ 解/ 搜索/ 空间/ ;/ (/ 2/ )/ 进一步/ 完善/ 评估/ 模型/ ,/ 提高/ 评估/ 模型/ 的/ 精度/ ,/ 并/ 设计/ 更加/ 精确/ 的/ 聚类/ 有效性/ 函数/ ;/ (/ 3/ )/ 进一步/ 探索/ 如何/ 更好/ 地/ 结合/ FCM/ 算法/ 和/ 启发式/ 规则/ ,/ 并/ 进而/ 有效/ 利用/ FCM/ 聚类/ 知识/ 用于/ 指导/ 更好/ 地/ 进行/ 线程/ 划分/ ./ 另外/ ,/ 由于/ 本文/ 提出/ 的/ 划分算法/ 仅/ 在/ Prophet/ 编译系统/ 平台/ 上/ 进行/ 了/ 相应/ 的/ 实现/ ,/ 因此/ ,/ 当/ 将/ 该/ 算法/ 与/ 其它/ 的/ 并行/ 体系结构/ 建立/ 的/ 平台/ 相结合/ 应用/ 时/ ,/ 尚/ 需要/ 注意/ 以下/ 问题/ :/ (/ 1/ )/ 针对/ 不同/ 的/ 并行/ 应用/ 平台/ ,/ 分析/ 和/ 评估/ 其/ 影响/ 并行/ 性能/ 的/ 具体/ 因素/ 以/ 确立/ 相应/ 的/ 线程/ 划分/ 解/ 的/ 搜索/ 空间/ ;/ (/ 2/ )/ 针对/ 不同/ 的/ 并行/ 应用/ 平台/ ,/ 也/ 需要/ 根据/ 相应/ 的/ 影响/ 并行/ 性能/ 的/ 具体/ 因素/ 来/ 建立/ 相应/ 的/ 评估/ 模型/ ,/ 并/ 结合/ FCM/ 算法/ 来/ 探索/ 线程/ 划分/ 的/ 更优/ 解/ ./ Page12/ 

