Page1/ 一种/ 面向/ 数据流/ 程序/ 的/ 软件/ 流水/ 并行/ 化/ 方法/ 魏/ 海涛/ 1/ )/ 于俊清/ 1/ )/ ,/ 2/ )/ 余华飞/ 1/ )/ 秦明康/ 1/ )/ 1/ )/ (/ 华中科技大学/ 计算机科学/ 与/ 技术/ 学院/ 武汉/ 430074/ )/ 2/ )/ (/ 华中科技大学/ 网络/ 与/ 计算中心/ 武汉/ 430074/ )/ 摘要/ 数据流/ 编程/ 被/ 广泛应用/ 于/ 多媒体/ 、/ 图像处理/ 和/ 信号处理/ 等/ 领域/ ./ 多核/ 处理器/ 为/ 数据流/ 程序/ 提供/ 了/ 强大/ 并行计算/ 资源/ ,/ 如何/ 利用/ 多核/ 处理器/ 的/ 并行性/ 以/ 提高/ 数据流/ 程序/ 性能/ ,/ 对/ 满足/ 媒体/ 处理/ 等/ 实时性/ 需求/ 具有/ 重要/ 意义/ ./ 基于/ 多核/ 处理器/ 提出/ 了/ 一种/ 面向/ 数据流/ 程序/ 的/ 软件/ 流水/ 并行/ 化/ 方法/ ,/ 利用/ 整数/ 线性规划/ 理论/ 对/ 软件/ 流水/ 中/ 的/ 计算/ 、/ 通信/ 资源/ 和/ 流水线/ 执行/ 阶段/ 等/ 进行/ 统一/ 的/ 形式化/ 建模/ ,/ 在/ 最大化/ 流水线/ 计算/ 速率/ 的/ 同时/ 最小化/ 通信/ 开销/ ;/ 同时/ 对/ 存储资源/ 进行/ 了/ 形式化/ 建模/ ,/ 提高/ 存储/ 访问/ 的/ 性能/ ./ 通过/ 设计/ 数据流/ 编程语言/ DFBrook/ ,/ 在/ Cell/ 处理器/ 实现/ 了/ 上述/ 方法/ ./ 实验/ 结果表明/ ,/ 该软件/ 流水/ 并行/ 方法/ 比/ 其它/ 方法/ 在/ 提高/ 数据流/ 程序/ 性能/ 的/ 同时/ ,/ 降低/ 了/ 通信/ 开销/ ./ 关键词/ 数据流/ 程序/ ;/ 多核/ 处理器/ ;/ 软件/ 流水/ ;/ 并行/ 1/ 引言/ 多核/ 处理器/ 已经/ 成为/ 主流/ 和/ 工业/ 标准/ ,/ 如/ Sony/ 、/ Toshiba/ 和/ IBM/ 联合开发/ 的/ Cell/ [/ 1/ ]/ 多核/ 处理器/ 集成/ 9/ 个/ 核/ ;/ Nvidia/ 公司/ 开发/ 的/ GeForce8800GPU/ [/ 2/ ]/ 集成/ 16/ 个流/ 处理器/ ,/ 每个/ 流/ 处理器/ 包含/ 8/ 个/ 处理单元/ ;/ Sun/ 公司/ 开发/ 的/ Niagara/ [/ 3/ ]/ 集成/ 8/ 个/ 核/ ;/ Intel/ 公司/ 和/ AMD/ 公司/ 将/ 推出/ 16/ 核/ 的/ x86/ 多核/ 处理器/ ./ 多核/ 处理器/ 为/ 应用/ 提供/ 了/ 强大/ 的/ 并行计算/ 能力/ ,/ 但同/ Page2/ 时/ 将/ 其/ 复杂/ 的/ 数据/ 划分/ 、/ 存储/ 结构/ 和/ 通信/ 机制/ 等/ 底层/ 设计/ 暴露/ 给/ 了/ 编程人员/ ,/ 从而/ 给/ 编程/ 带来/ 了/ 巨大/ 的/ 挑战/ ./ 传统/ 的/ 编程/ 模型/ ,/ 如/ C/ 、/ C++/ 和/ FOR/ -/ TRAN/ 已经/ 无法/ 很/ 好/ 地/ 适应/ 多核/ 处理器/ 的/ 架构/ ./ 数据流/ 编程/ (/ DataFlowProgramming/ )/ 模型/ 将/ 媒体/ 应用/ 特性/ 与/ 程序设计/ 语言/ 相结合/ ,/ 在/ 简化/ 编程/ 的/ 同时/ ,/ 为/ 编译器/ 在/ 多/ 核/ 处理器/ 下/ 的/ 优化/ 提供/ 了/ 大量/ 的/ 并行性/ ,/ 目前/ 受到/ 广泛/ 的/ 关注/ ./ 数据流/ 编程语言/ 如/ StreamIt/ [/ 4/ ]/ 、/ CUDA/ [/ 2/ ]/ 和/ SPUR/ [/ 5/ ]/ 等/ 一般/ 都/ 是/ 基于/ 同步/ 数据流/ 模型/ (/ Syn/ -/ chronousDataFlow/ ,/ SDF/ )/ [/ 6/ ]/ ./ 在/ 该/ 模型/ 中/ ,/ 每个/ actor/ 是/ 一个/ 运算/ 过程/ ,/ 代表/ 一系列/ 的/ 指令/ ,/ 数据/ 从/ 输入/ 队列/ 进入/ ,/ 经过/ actor/ 的/ 处理/ 后/ 到/ 输出/ 队列/ ./ actor/ 的/ 每次/ 运行/ 由/ 输入/ 队列/ 上/ 的/ 数据/ 到达/ 速率/ 来/ 决定/ ,/ 只要/ 输入/ 数据/ 队列/ 中有/ 数据/ ,/ 且/ 输出/ 队列/ 有/ 空闲/ 的/ 存储/ ,/ actor/ 就/ 可以/ 运行/ ./ 一般来说/ ,/ 一个/ 数据流/ 程序/ 由/ 多个/ actor/ 和/ 连接/ actor/ 的/ 数据/ 队列/ 组成/ ./ actor/ 一般/ 被/ 表示/ 为/ 一个/ 函数/ ,/ 数据/ 队列/ 采用/ 先进先出/ 方式/ 组织/ ./ 每个/ actor/ 有/ 相应/ 的/ 触发/ 规则/ ,/ 当/ 规则/ 满足/ 时/ ,/ 该/ actor/ 被/ 触发/ ,/ 读取/ 输入/ 队列/ 上/ 的/ 数据/ ,/ 产生/ 输出/ 数据/ ./ 同步/ 数据流/ 模型/ 的/ 这种/ 机制/ 为/ 编译器/ 提供/ 了/ 并行/ 优化/ 的/ 机会/ ./ 软件/ 流水/ 是/ 一种/ 开发/ 数据流/ 程序/ 并行性/ 的/ 有效/ 方法/ ./ 通过/ 将/ 数据流/ 程序/ 看作/ 一个/ 循环/ ,/ 不同/ 迭代/ 中/ 的/ actor/ 能够/ 在/ 流水线/ 中/ 实现/ 重叠/ 执行/ ./ 然而/ ,/ 获得/ 的/ 性能/ 常会/ 被/ 处理器/ 核间/ 的/ 通信/ 和/ 同步/ 开销/ 所/ 抵消/ ./ 同时/ ,/ 处理器/ 核/ 、/ 通信/ 带宽/ 和/ 片/ 上/ 存储/ 等/ 系统资源/ 限制/ 将会/ 带来/ 流水线/ 的/ 停滞/ ./ 软件/ 流水/ 的/ 性能/ 由/ 每次/ 启动/ 迭代/ 的/ 时间/ 来/ 衡量/ ,/ 一个/ 具有/ 最小/ 启动/ 时间/ 的/ 调度/ 称为/ 最优/ 计算/ 速率/ 的/ 软件/ 流水/ 调度/ ./ 因此/ ,/ 如何/ 设计/ 软件/ 流水/ 调度/ 方法/ ,/ 在/ 满足/ 系统资源/ 受限/ 的/ 情况/ 下/ ,/ 获得/ 最优/ 计算/ 速率/ 的/ 同时/ 最小化/ 通信/ 开销/ 是/ 本文/ 研究/ 的/ 主要/ 问题/ ./ 本文/ 基于/ 多核/ 处理器/ 提出/ 了/ 一种/ 面向/ 数据流/ 程序/ 的/ 软件/ 流水/ 并行/ 化/ 方法/ ,/ 利用/ 整数/ 线性规划/ 理论/ 对/ 软件/ 流水/ 中/ 的/ 计算/ 、/ 通信/ 资源/ 、/ 存储资源/ 以及/ 流水线/ 执行/ 的/ 阶段/ 等/ 进行/ 统一/ 的/ 形式化/ 建模/ ,/ 在/ 满足/ 最大化/ 流水线/ 计算/ 速率/ 的/ 同时/ 最小化/ 通信/ 开销/ ./ 通过/ 设计/ 数据流/ 编程语言/ DFBrook/ ,/ 在/ Cell/ 处理器/ 上现/ 了/ 上述/ 方法/ ./ 实验/ 结果表明/ ,/ 本文/ 提出/ 的/ 方法/ 比/ 现有/ 的/ 其他/ 方法/ 在/ 较大/ 地/ 提高/ 性能/ 的/ 同时/ 减小/ 了/ 开销/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关性/ 研究/ 工作/ ;/ 第/ 3/ 节/ 介绍/ DFBrook/ 数据流/ 编程语言/ ;/ 第/ 4/ 节/ 详细/ 讨论/ 数据流/ 程序/ 的/ 软件/ 流水/ 调度/ 方法/ ;/ 第/ 5/ 节/ 给出/ 相应/ 的/ 实验/ 结果/ ;/ 第/ 6/ 节对/ 论文/ 进行/ 总结/ ./ 2/ 相关/ 工作/ 软件/ 流水/ 最初/ 在/ 超标/ 量/ 和/ 超长/ 指令/ 字/ 计算机/ 中/ 被/ 提出/ 来/ ,/ 用于/ 开发/ 指令/ 级/ 的/ 并行/ [/ 7/ -/ 8/ ]/ ./ 作为/ 一种/ 开发/ 并行性/ 的/ 方法/ ,/ 软件/ 流水/ 开始/ 逐渐/ 被/ 用于/ 开发/ 数据流/ 程序/ 的/ 并行性/ ./ Kudlur/ 等/ 人/ 采用/ 了/ 的/ 软件/ 流水线/ 调度/ 方法/ 实现/ 了/ StreamIt/ 在/ 多/ 核/ 处理器/ 下/ 的/ 并行/ 优化/ [/ 9/ ]/ ./ 该/ 方法/ 首先/ 对/ 计算/ 节点/ 进行/ 划分/ ,/ 然后/ 采用/ 阶段/ 赋值/ 算法/ 来/ 实现/ 流水线/ 阶段/ 调度/ ,/ 但是/ 该/ 方法/ 只/ 对/ 计算资源/ 的/ 调度/ 进行/ 了/ 研究/ ,/ 没有/ 考虑/ 到/ 通信/ 和/ 存储资源/ ./ Choi/ 等/ 人/ 在/ Kudlur/ 的/ 基础/ 上/ 提出/ 了/ 在/ 嵌入式/ 系统/ 下/ 的/ 存储/ 受限/ 软件/ 流水/ 调度/ [/ 10/ ]/ ,/ 但是/ 该/ 方法/ 对解/ 的/ 集合/ 采用/ 保守/ 估计/ ,/ 即/ 假设/ 了/ 所有/ 相连/ 的/ 计算/ 节点/ 都/ 被/ 调度/ 到/ 不同/ 的/ 处理器/ ,/ 因此/ 过多地/ 计算/ 量/ 存储/ 的/ 开销/ ,/ 同时/ ,/ 该/ 方法/ 也/ 没有/ 考虑/ 通信/ 开销/ ./ Govindarajan/ 等/ 人/ 采用/ 线性规划/ 研究/ 了/ 数据流/ 程序/ 在/ GPU/ 上/ 的/ 调度/ 框架/ [/ 11/ ]/ ,/ 但是/ 该/ 模型/ 只是/ 针对/ 共享/ 存储/ 结构/ 的/ 处理器/ ,/ 针对/ 分布式/ 存储/ 结构/ 无法/ 使用/ ./ 针对/ 上述/ 问题/ ,/ 本文/ 基于/ 多核/ 处理器/ 提出/ 了/ 一种/ 面向/ 数据流/ 程序/ 的/ 软件/ 流水/ 并行/ 化/ 方法/ ,/ 利用/ 整数/ 线性规划/ 理论/ 对/ 软件/ 流水/ 中/ 的/ 计算/ 、/ 通信/ 资源/ 、/ 存储资源/ 以及/ 流水线/ 执行/ 的/ 阶段/ 等/ 进行/ 统一/ 的/ 形式化/ 建模/ ,/ 在/ 取得/ 最优化/ 流水线/ 计算/ 速率/ 的/ 同时/ 最小化/ 处理器/ 间/ 的/ 通信/ 开销/ ./ 同时/ 对/ 存储/ 受限/ 的/ 多/ 核/ 处理器/ 进行/ 了/ 形式化/ 建模/ ,/ 以/ 提高/ 存储/ 访问/ 的/ 性能/ ./ 3DFBrook/ 数据流/ 语言/ 与/ 编译/ DFBrook/ 在/ 语义上/ 对/ Brook/ [/ 12/ ]/ 语言/ 进行/ 了/ 数据流/ 扩展/ ./ DFBrook/ 程序/ 由/ 普通/ 的/ C/ 代码/ 和/ 数据流/ 代码/ 组成/ 新/ 的/ 数据类型/ ,/ 表达/ 了/ 数据流/ 模型/ 中/ 的/ 数据/ 队列/ 的/ 语义/ ./ 数据流/ 类型/ 只能/ 限制/ 在/ 核/ 函数/ 中/ 使用/ ./ 流/ 操作符/ 则/ 是/ 一组/ 对流/ 类型/ 数据/ 进行/ 特定/ 运算/ 操作/ 的/ 集合/ ,/ 用于/ 与/ 其它/ 数据类型/ 之间/ 的/ 转换/ ./ 图/ 1/ 给出/ 了/ 一个/ DFBrook/ 的/ 例子/ 程序/ 和/ 相应/ 的/ SDF/ 图/ ./ 核/ 函数/ KA/ 具有/ 2/ 个/ 输入/ 流/ 和/ 1/ 个/ 输出/ 流/ ,/ 每次/ 执行/ 消耗/ 从/ 输入/ 流/ vec/ _/ a/ 和/ vec/ _/ b/ 中/ 各/ 消耗/ 8/ 个/ 数据/ 单位/ ,/ 向/ 输出/ 流/ vec/ _/ result/ 中/ 生成/ 8/ 个/ 数据/ 单位/ ,/ 其中/ vec/ _/ a/ 和/ vec/ _/ b/ 是/ 只读/ 的/ ,/ vec/ _/ result/ 是/ 只/ 写/ 的/ ./ 在/ main/ 函数/ 中/ ,/ streamfor/ 语句/ 块/ 对应/ DFBrook/ 程序/ 的/ 数据流/ 代码/ ,/ 流/ 类型/ 数据/ 由/ 引用/ 参/ Page3/ 数从/ 一个/ kernel/ 函数/ 传递/ 到/ 另/ 一个/ kernel/ 函数/ ./ streamRead/ 和/ streamWrite/ 操作符/ 是/ 两个/ 特殊/ 的/ 流/ 操作符/ ,/ streamRead/ 用于/ 将/ 外部/ C/ 代码/ 的/ 数据/ “/ 读入/ ”/ 流/ ,/ 指明/ 一个/ 流/ 的/ 起始/ 点/ ,/ 因此/ streamRead/ 只有/ 第/ 3/ 个/ 参数/ 用于/ 指定/ 输出/ 码率/ ;/ streamWrite/ 将流/ “/ 写回/ ”/ 外部/ C/ 代码/ ,/ 指明/ 流/ 的/ 终止/ ,/ 因此/ stre/ -/ amWrite/ 只有/ 输入/ 数据流/ ./ 在/ 例子/ 中/ ,/ streamRead/ 将/ 数据/ 从/ 外部/ 数组/ data/ _/ matrix/ 和/ data/ _/ vector/ 读入/ 数据流/ 中/ ,/ 该/ 数据流/ 作为/ kernel/ 函数/ KA/ 的/ 输入/ 进行/ 处理/ 后/ 结果/ 输出/ 到/ tempmv/ 流/ ,/ tempmv/ 流/ 被/ kernel/ 函数/ KB/ 消耗/ 产生/ result/ 流/ ,/ 最后/ result/ 流/ 被/ 写/ 回到/ 数组/ data/ _/ result/ 中/ ./ 这些/ 流在/ kernel/ 函数/ 间/ 以/ 队列/ 的/ 方式/ 进行/ 传输/ ,/ 队列/ 的/ 长度/ 由/ 编译器/ 指定/ ./ kernelvoidKA/ (/ streamfloatvec/ _/ a/ 〈/ 8/ 〉/ ,/ streamfloatvec/ _/ b/ 〈/ 8/ 〉/ ,/ outstreamfloatvec/ _/ result/ 〈/ 8/ 〉/ )/ {/ …/ }/ kernelvoidKB/ (/ streamfloatvec/ 〈/ 8/ 〉/ ,/ outstreamfloatresult/ 〈/ 1/ 〉/ )/ {/ …/ }/ main/ (/ )/ {/ …/ floatdata/ _/ matrix/ [/ 64/ ]/ ;/ floatdata/ _/ vector/ [/ 8/ ]/ ;/ streamfloatmatrix/ 〈/ 〉/ ,/ vector/ 〈/ 〉/ ;/ streamfloattempmv/ 〈/ 〉/ ,/ result/ 〈/ 〉/ ;/ streamfor/ (/ …/ )/ {/ streamRead/ (/ matrix/ ,/ data/ _/ matrix/ ,/ 64/ )/ ;/ streamRead/ (/ vector/ ,/ data/ _/ vector/ ,/ 8/ )/ ;/ KA/ (/ matrix/ ,/ vector/ ,/ tempmv/ )/ ;/ KB/ (/ tempmv/ ,/ result/ )/ ;/ streamWrite/ (/ result/ ,/ data/ _/ result/ ,/ 8/ )/ ;/ }/ }/ 图/ 1/ 数据流/ 编程语言/ DFBrook/ 及其/ 对应/ 的/ SDF/ 编译器/ 首先/ 对/ DFBrook/ 程序/ 进行/ 语法/ 和/ 语义/ 检查/ ,/ 然后/ 采用/ 数据流/ 分析/ 理论/ ,/ 建立/ 各个/ 核/ 函数/ 和/ 流/ 操作符/ 之间/ 的/ 依赖/ 关系/ ,/ 构造/ 中间/ 表示/ —/ —/ —/ SDF/ ;/ 同步/ 数据流/ 图/ 的/ 每个/ 节点/ 代表/ 一个/ 核/ 函数/ 或者/ 流/ 操作符/ ,/ 图/ 的/ 每条/ 有/ 向/ 边/ 代表/ 核/ 函数/ 之间/ 的/ 数据/ 流通/ 路/ ,/ 边上/ 的/ 两个/ 权值/ 代表/ 起点/ 核/ 函数/ 的/ 输出/ 流/ 速率/ 和/ 终点/ 的/ 输入/ 流/ 速率/ ,/ 即/ 生产/ 和/ 消耗/ 数据/ 的/ 速率/ ;/ 流水线/ 调度/ 模块/ 对/ 同步/ 数据流/ 图/ 进行/ 分析/ ,/ 将/ 图/ 中/ 的/ 节点/ 调度/ 到/ 目标/ 处理器/ 上/ 的/ 处理/ 核上/ ,/ 同时/ 为/ 调度/ 到/ 不同/ 处理器/ 核上/ 的/ 节点/ 间/ 生产/ DMA/ (/ DirectedMemoryAccess/ )/ ,/ 实现/ 软件/ 流水/ 调度/ ;/ 最后/ 生成/ 多线程/ 目标/ 代码/ ./ 本文/ 采用/ 的/ 目标/ 结构/ 为/ 基于/ 加速器/ 的/ 多/ 核/ 处理器/ 结构/ 如/ Cell/ ,/ 每个/ 处理器/ 核/ 只能/ 访问/ 自己/ 私有/ 的/ 片/ 上/ 局部/ 存储/ ,/ 通过/ 异步/ DMA/ 来/ 实现/ 数据/ 的/ 通信/ ./ 4/ 数据流/ 程序/ 的/ 软件/ 流水/ 并行/ 4.1/ 多核/ 处理器/ 下/ 的/ 软件/ 流水/ 调度/ 在/ 基于/ 多核/ 处理器/ 的/ 软件/ 流水/ 中/ ,/ 一次/ 循环/ 迭代/ 作为/ 一个/ 任务/ ,/ 被/ 分成/ 若干/ 阶段/ ,/ 各个/ 阶段/ 在/ 不同/ 的/ 处理器/ 上/ 执行/ ,/ 当/ 一个/ 处理器/ 完成/ 了/ 它/ 负责/ 的/ 阶段/ 后/ ,/ 结果/ 就/ 作为/ 输入/ 传送/ 到/ 流水线/ 中/ 的/ 下/ 一个/ 处理器/ ./ 图/ 2/ 给出/ 了/ 一个/ 基于/ 多核/ 处理器/ 的/ 软件/ 流水/ 调度/ 的/ 例子/ ,/ 图/ 左边/ 为/ 一个/ 数据/ 依赖图/ ,/ K1/ 执行/ 后/ 利用/ DMA/ ,/ 将/ 数据/ 传给/ K2/ 执行/ ,/ 图/ 右边/ 为/ 对应/ 的/ 流水线/ 的/ 调度表/ ./ 计算/ 任务/ 被/ 分为/ 3/ 个/ 阶段/ ,/ 第/ 0/ 位置/ 的/ 处理器/ 核/ 完成/ 处理/ 后/ ,/ 结果/ 用/ DMA/ 传输/ 到/ 第/ 1/ 位置/ 的/ 处理器/ 核/ ,/ 同时/ 第/ 0/ 位置/ 的/ 处理器/ 核/ 开始/ 处理/ 第/ 2/ 个/ 任务/ ,/ 即下/ 一次/ 循环/ 迭代/ ./ 按照/ 这种/ 方式/ ,/ 流水线/ 被/ 逐渐/ 填满/ ,/ 处理器/ 逐渐/ 进入/ 忙/ 状态/ ./ 在/ 流水线/ 满/ 的/ 状态/ 下/ ,/ 不同/ 的/ 循环/ 迭代/ 在/ 流水线/ 中/ 并行执行/ ./ 在/ 软件/ 流水线/ 中/ ,/ 相邻/ 两次/ 循环/ 迭代/ (/ 任务/ )/ 开始/ 进入/ 流水线/ 的/ 时间/ 间隔/ 称为/ 启动/ 间隔/ (/ InitiationInterval/ ,/ II/ )/ ,/ 启动/ 间隔/ 的/ 长短/ 代表/ 了/ 流水线/ 的/ 速度/ ,/ 启动/ 间隔/ 越小/ ,/ 流水线/ 的/ 执行/ 速度/ 越快/ ./ 流水线/ 进入/ 充满/ 状态/ 后/ ,/ 单位/ 时间/ 内/ 流水线/ 完成/ 循环/ 迭代/ (/ 任务/ )/ 的/ 次数/ 称为/ 吞吐/ 率/ (/ Throughput/ ,/ T/ )/ ,/ 吞吐/ 率/ 代表/ 了/ 流水线/ 的/ 响应/ 速率/ ,/ 吞吐/ 率越/ 大/ ,/ 流水线/ 的/ 响应/ 时间/ 越短/ ,/ 吞吐/ 率/ T/ 和/ 启动/ 间隔/ II/ 满足/ 以下/ 公式/ :/ II/ =/ 1/ // T/ ./ 4.2/ 通信/ 最小化/ 的/ 最优化/ 软件/ 流水/ 调度/ 本/ 节/ 设计/ 的/ 软件/ 流水/ 调度/ 的/ 目的/ 是/ 根据/ 任务/ 的/ 依赖/ 关系/ 和/ 当前/ 系统/ 中/ 资源/ 的/ 情况/ ,/ 构造/ 一个/ 软件/ 流水/ 调度/ ,/ 在/ 最小化/ 启动/ 间隔/ II/ 的/ 基础/ 上/ ,/ 最小化/ 通信/ 开销/ ./ 图/ 3/ 给出/ 了/ 两种/ 调度/ 方法/ ,/ 方法/ 1/ 不/ 考虑/ 通信/ Page4/ 开销/ ,/ 首先/ 将/ 节点/ A0/ 和/ A1/ 分别/ 调度/ 到/ 处理器/ SPE0/ 和/ SPE1/ ,/ 节点/ B0/ 、/ B1/ 和/ B2/ 被/ 调度/ 到/ 处理器/ SPE2/ ;/ 然后/ 检查/ 每/ 一条/ 边/ ,/ 如果/ 边/ 的/ 两个/ 节点/ 被/ 调度/ 到/ 不同/ 处理器/ ,/ 那么/ 将/ 该/ 边/ 调度/ 到/ 对应/ 的/ DMA/ ;/ 最后/ 对/ 每个/ 实例/ 和/ 边/ 赋值/ 阶段/ (/ Stage/ )/ ,/ 节点/ A0/ 和/ A1/ 被/ 赋值/ 阶段/ Stage0/ ,/ 节点/ B0/ 、/ B1/ 和/ B2/ 被/ 赋值/ 阶段/ Stage2/ ,/ 4/ 个/ DMA/ 被/ 赋值/ 阶段/ Stage1/ ./ 低/ 通信/ 开销/ 软件/ 流水/ 调度/ 方法/ 将/ 处理器/ 调度/ 、/ DMA/ 和/ 阶段/ 赋值/ 作为/ 一个/ 整体/ 来/ 考虑/ ./ 如图/ 3/ (/ b/ )/ 所示/ ,/ A0/ 和/ B0/ 被/ 调度/ 到/ 处理器/ SPE0/ ,/ B1/ 被/ 调度/ 到/ 处理器/ SPE1/ ,/ A1/ 和/ B2/ 被/ 调度/ 到/ 处理器/ SPE2/ ./ 由于/ 调度/ 到/ 相同/ 的/ 处理器/ 上/ 的/ 实例/ 共享/ 存储/ ,/ 无需/ 通信/ 开销/ ,/ 因此/ ,/ A0/ 和/ B0/ 之间/ 以及/ A1/ 和/ B2/ 之间/ 的/ 通信/ 开销/ 被/ 消除/ ./ 图/ 3/ (/ c/ )/ 和/ (/ d/ )/ 比较/ 了/ 以上/ 两种/ 软件/ 流水/ 调度/ 方法/ 的/ 执行/ 结果/ ./ 方法/ 1/ 得到/ 的/ 启动/ 间隔/ II/ 为/ 46/ 个/ 单位/ ,/ 总/ 通信/ 开销/ 为/ 46/ 个/ 单位/ ;/ 低/ 通信/ 开销/ 软件/ 流水/ 调度/ 方法/ 得到/ 的/ 启动/ 间隔/ II/ 为/ 30/ 个/ 单位/ ,/ 总/ 通信/ 开销/ 为/ 22/ 个/ 单位/ ,/ 因此/ ,/ 该/ 方法/ 在/ 取得/ 高/ 计算速度/ 的/ 同时/ 降低/ 了/ 通信/ 的/ 开销/ ./ 以上/ 例子/ 阐述/ 的/ 软件/ 流水/ 调度/ 问题/ 可以/ 被/ 形式化/ 为/ 一个/ 整数/ 线性规划/ 问题/ ./ 考虑/ 一个/ 数据流/ 程序/ 的/ 数据流/ 图/ 中间/ 表达/ G/ =/ (/ V/ ,/ E/ )/ ,/ V/ 为/ 节点/ 集/ ,/ E/ 为/ 边集/ ./ 对于/ 每条/ 边/ ,/ 为了/ 满足/ 产生/ 的/ 数据/ 个数/ 与/ 消耗/ 的/ 数据/ 个数/ 相等/ ,/ 起点/ 和/ 终点/ 所/ 需要/ 执行/ 的/ 最小/ 次数/ ,/ 称为/ 该/ 节点/ 的/ 重复/ 运行/ 次数/ ,/ 所有/ 节点/ 的/ 重复/ 执行/ 次数/ 构成/ 了/ 重复/ 执行/ 向量/ 狉/ G/ ./ 通过/ 将/ G/ 中/ 的/ 节点/ 进行/ 狉/ G/ 次/ 展开/ ,/ 可以/ 得到/ 数据流/ 图/ 对应/ 的/ 数据/ 依赖图/ Gd/ =/ (/ Vd/ ,/ Ed/ )/ ,/ 具体方法/ 可/ 参见/ 文献/ [/ 13/ ]/ ./ 以下/ 将/ 对/ 数据/ 依赖图/ Gd/ 进行/ 形式化/ 建模/ ,/ Gd/ 中/ 的/ 每个/ 节点/ 由/ v/ ∈/ Vd/ 表示/ ,/ 每条/ 边/ 由/ (/ u/ ,/ v/ )/ ∈/ Ed/ 表示/ ,/ 其中/ u/ ∈/ Vd/ ./ 令/ P/ 为/ 数据/ 处理器/ 的/ 集合/ ,/ P/ =/ {/ 0/ ,/ 1/ ,/ …/ ,/ Pmax/ -/ 1/ }/ ,/ Pmax/ 为/ 数据/ 处理器/ 的/ 个数/ ./ 为/ 每个/ 节点/ v/ 定义/ 0/ -/ 1/ 变量/ av/ ,/ p/ ,/ 表示/ 节点/ v/ 是否/ 被/ 调度/ 到/ 处理器/ p/ 上/ ./ 处理器/ 资源/ 的/ 限制/ 被/ 形式化/ 为/ 等式/ (/ 1/ )/ ,/ 该/ 限制/ 条件/ 确保/ 了/ 每个/ 节点/ 只能/ 被/ 调度/ 到/ 一个/ 处理器/ 上/ ./ 令/ (/ )/ workv/ 表示/ 函数/ 节点/ v/ 的/ 执行/ 时间/ ,/ II/ 表示/ 软件/ 流水/ 的/ 启动/ 间隔/ ,/ 不等式/ (/ 2/ )/ 形式化/ 给出/ 了/ 以下/ 限制/ 条件/ :/ 调度/ 到/ 一个/ 处理器/ 上/ 的/ 总/ 工作/ 负载/ 必须/ 在/ 给定/ 的/ 启动/ 间隔/ II/ 内/ 完成/ ./ ∑/ v/ ∈/ Vd/ 以上/ 两个/ 限制/ 条件/ 给出/ 了/ 处理器/ 的/ 调度/ 限制/ ,/ 没有/ 考虑/ 数据/ 的/ 依赖/ 限制/ ,/ 即/ 没有/ 考虑/ 图中边/ 的/ 限制/ 条件/ ./ 如果/ 两个/ 相连接/ 的/ 节点/ 被/ 调度/ 到/ 不同/ 的/ 处理器/ 上/ ,/ 将/ 需要/ DMA/ 传输数据/ 的/ 操作/ ./ DMA/ 传输/ 是/ 双向/ 的/ ,/ 既/ 可以/ 由源/ 处理器/ 发起/ ,/ 也/ 可以/ 由/ 目的/ 处理器/ 发起/ ./ 考虑/ 大多/ 系统/ 处理器/ 的/ 性能/ 设计/ ,/ 采用/ 由/ 目的/ 处理器/ 发起/ DMA/ ./ 对于/ 边/ (/ u/ ,/ v/ )/ ∈/ Ed/ ,/ 定义/ 0/ -/ 1/ 变量/ du/ ,/ v/ ,/ p/ 来/ 表示/ 边/ (/ u/ ,/ v/ )/ ∈/ Ed/ 是否/ 被/ 调度/ 到/ DMAp/ 上/ ./ 变量/ du/ ,/ v/ ,/ p/ 为/ 1/ 当且/ 仅/ 当/ v/ 被/ 调度/ 到/ 处理器/ DPp/ ,/ 同时/ u/ 被/ 调度/ 到/ 其他/ 不同/ 的/ 处理器/ 上/ ./ 不等式/ 组/ (/ 3/ )/ 确保/ 了/ 当/ 两个/ 相互连接/ 的/ 节点/ 被/ 调度/ 到/ 同一个/ 处理器/ 上/ ,/ 将/ 不/ 需要/ DMA/ 进行/ 数据传输/ ./ 此处/ 约定/ 一对/ 相连接/ 的/ 节点/ 之间/ 的/ DMA/ 传/ Page5/ 输/ 总是/ 由/ 目的/ 节点/ 所/ 调度/ 到/ 的/ 处理器/ 发起/ ./ 令/ Commun/ (/ u/ ,/ v/ )/ 表示/ 两个/ 节点/ u/ 和/ v/ 之间/ 的/ 数据传输/ 负载/ ,/ 流水线/ 的/ 计算/ 速率/ 同样/ 也/ 受/ 所有/ 的/ DMA/ 的/ 数据传输/ 负载/ 的/ 限制/ ./ 限制/ 不等式/ (/ 4/ )/ 确保/ 了/ 在/ 给定/ 一个/ DMA/ 上/ 的/ 数据传输/ 总/ 负载/ 不/ 大于/ 给定/ 的/ 启动/ 间隔/ II/ ./ 不等式/ (/ 1/ )/ ~/ (/ 4/ )/ 只/ 对/ 节点/ 在/ 各个/ 处理器/ 上/ 的/ 调度/ 以及/ 相应/ 的/ 数据传输/ 在/ DMA/ 的/ 调度/ 给出/ 了/ 限制/ 条件/ ,/ 即/ 只/ 在/ 空间/ 维上/ 对/ 软件/ 流水/ 调度/ 进行/ 了/ 形式化/ 限制/ ./ 为了/ 在/ 时间/ 维上/ 调度/ 节点/ 和/ 边/ ,/ 引入/ Stage/ 概念/ 来/ 描述/ 节点/ 和/ 边/ 在/ 时间/ 上/ 的/ 调度/ ./ 定义/ 整数/ 变量/ svv/ 表示/ 节点/ v/ 被/ 赋值/ 的/ 阶段/ 号/ ;/ 定义/ 整数/ 变量/ seu/ ,/ v/ 表示/ 边/ (/ u/ ,/ v/ )/ ∈/ Ed/ 被/ 赋值/ 的/ 阶段/ 号/ ./ 不等式/ (/ 5/ )/ 和/ (/ 6/ )/ 给出/ 了/ 软件/ 流水/ 调度/ 在/ 时间/ 上/ 的/ 限制/ 条件/ ./ 对于/ 给定/ 的/ 边/ (/ u/ ,/ v/ )/ ,/ 目的/ 节点/ 的/ 阶段/ 号/ 应该/ 在/ 源/ 节点/ 后面/ ,/ 因为/ 在/ 时间/ 上/ ,/ 目的/ 节点/ 必须/ 在/ 源/ 节点/ 运行/ 后/ 运行/ ,/ 即/ svv/ / svu/ 表示/ 了/ 源/ 节点/ 和/ 目的/ 节点/ 之间/ 的/ 数据/ 依赖/ 关系/ ./ 如果/ u/ 和/ v/ 被/ 调度/ 到/ 不同/ 处理器/ 上/ ,/ 两者/ 需要/ DMA/ 操作/ 进行/ 数据传输/ ,/ 那么/ 从/ u/ 到/ v/ 的/ 数据传输/ 必须/ 分配/ 一个/ 单独/ 的/ 阶段/ 号/ seu/ ,/ v/ ,/ 节点/ u/ 、/ v/ 和/ DMA/ 必须/ 满足/ 不等式/ svu/ </ seu/ ,/ v/ </ svv/ ./ 由于/ 每个/ 节点/ 只能/ 调度/ 到/ 一个/ 处理器/ ,/ 即/ av/ ,/ p/ 只能/ 对于/ 某/ 一个/ 处理器/ p/ 取到/ 1/ ,/ 从/ 不等式/ (/ 3/ )/ 可以/ 得知/ :/ 对于/ 给定/ 的/ 一条/ 边/ ,/ 要么/ 只/ 被/ 赋值/ 给/ 一个/ DMA/ ,/ 要么/ 不/ 被/ 赋值/ 给/ 任何/ DMA/ ./ 当/ u/ 和/ v/ 被/ 调度/ 到/ 不同/ 处理器/ 上/ ,/ 求和/ 式/ ∑/ Pmax/ -/ 1v/ 被/ 调度/ 到/ 相同/ 处理器/ 上/ ,/ 值为/ 0/ ./ 当源/ 节点/ u/ 和/ 目的/ 节点/ v/ 被/ 调度/ 到/ 不同/ 处理器/ 上时/ ,/ 不等式/ (/ 5/ )/ 确保/ 了/ DMA/ 传输/ 的/ 阶段/ 号/ 至少/ 在/ 源/ 节点/ u/ 后面/ 一个/ 阶段/ ;/ 类似/ 的/ ,/ 不等式/ (/ 6/ )/ 确保/ 了/ 目的/ 节点/ v/ 的/ 阶段/ 号/ 至少/ 在/ DMA/ 后面/ 一个/ 阶段/ ./ 当/ 节点/ u/ 和/ 节点/ v/ 被/ 调度/ 到/ 相同/ 处理器/ 上时/ ,/ 不等式/ svv/ / svu/ 保持/ ,/ 此时/ du/ ,/ v/ ,/ p/ 无/ 意义/ ./ min/ ∑/ Pmax/ -/ 1/ 函数/ (/ 7/ )/ 描述/ 了/ 所有/ 节点/ 之间/ 的/ 总/ 通信/ 开销/ ,/ 规划/ 的/ 目标/ 函数/ 是/ 最小化/ 通信/ 开销/ ./ 式/ (/ 1/ )/ ~/ 式/ (/ 7/ )/ 为/ 通信/ 最小化/ 的/ 最优化/ 流水/ 调度/ (/ CommunicationMinimizedRate/ -/ Optimalscheduling/ ,/ CMRO/ )/ 问题/ 提供/ 了/ 精确/ 的/ 整数/ 线性规划/ 形式化/ 描述/ ./ 该/ 模型/ 精确/ 描述/ 了/ 软件/ 流水/ 调度/ 中/ 的/ 计算资源/ 和/ 通信/ 资源/ ,/ 在/ 保证/ 高/ 计算/ 速率/ 的/ 同时/ ,/ 最小化/ 通信/ 开销/ ,/ 提高/ 软件/ 流水/ 的/ 性能/ ./ 因为/ 最小化/ 通信/ 是/ 在/ 最优化/ 流水/ 的/ 前提/ 下/ ,/ 因此/ 首先/ 必须/ 求得/ 满足/ 限制/ 条件/ (/ 1/ )/ ~/ (/ 6/ )/ 的/ 最小化/ IImin/ ,/ 将式/ (/ 7/ )/ 用/ minII/ 代替/ ,/ 可以/ 得到/ 最优化/ 流水/ 调度/ RO/ (/ RateOptimal/ )/ ./ 通过/ 求解/ RO/ 问题/ ,/ 可以/ 得到/ IImin/ ,/ 以此/ 作为/ CMRO/ 问题/ 的/ 输入/ ,/ 从而/ 求/ 出/ 最小化/ 通信/ 开销/ ./ 4.3/ 内存/ 限制/ 的/ 流水/ 调度/ 4.3/ ./ 1/ 存储/ 分配机制/ 这里/ 采用/ 文献/ [/ 10/ ]/ 的/ 方法/ 来/ 阐述/ 节点/ 对/ (/ u/ ,/ v/ )/ 的/ 两种/ 缓存/ 分配机制/ ./ 如图/ 4/ (/ a/ )/ 所示/ ,/ u/ ,/ v/ 两个/ 节点/ 被/ 调度/ 到/ 同一/ 处理器/ P0/ 上/ ,/ 被/ 赋值/ 的/ 阶段/ 分别/ 为/ 0/ 和/ 1/ ,/ 为了/ 保证/ 流水线/ 的/ 重叠/ 执行/ ,/ 此时/ 分配/ 的/ 缓存/ 个数/ 为/ 3/ ;/ 在/ 图/ 4/ (/ b/ )/ 中/ ,/ u/ ,/ v/ 两个/ 节/ 调度/ 不同/ 处理器/ 上/ ,/ 被/ 赋值/ 的/ 阶段/ 分别/ 为/ 0/ 和/ 4/ ,/ 此时/ ,/ u/ 所在/ 的/ 处理器/ P0/ 和/ v/ 所在/ 的/ 处理器/ P1/ 分别/ 分配/ 3/ 个/ 缓存/ ./ 这/ 是因为/ 调度/ 到/ 不同/ 处理器/ 上/ 的/ 节点/ 对/ 需要/ DMA/ 进行/ 数据传输/ ,/ 在/ 软件/ 流水/ 的/ 执行/ 中/ ,/ u/ ,/ v/ 的/ 执行/ 以及/ 两者/ 间/ DMA/ 的/ 传输/ 在/ 时间/ 上/ 是/ 重叠/ 的/ ,/ 因此/ 都/ 需要/ 缓存/ 进行/ 保存/ 中间/ 结果/ ./ 4.3/ ./ 2/ 形式化/ 建模/ 定义/ 生产者/ -/ 消费者/ 对/ 为/ 普通/ 的/ 相连/ 的/ 计算/ 节点/ 对/ 或者/ DMA/ -/ 计算/ 节点/ 对/ ;/ 定义/ 缓存/ 组为/ 在/ 软件/ 流水/ 调度/ 中/ ,/ 生产者/ -/ 消费者/ 对/ 所/ 分配/ 的/ 缓存/ 队列/ ./ 针对/ 以上/ 两种/ 缓存/ 分配机制/ 有/ :/ (/ 1/ )/ 当/ 两个/ 相连/ 计算/ 节点/ 对/ (/ u/ ,/ v/ )/ 被/ 调度/ 到/ 同一/ 处理器/ 上/ ,/ 缓存/ 组/ 被/ 共享/ ,/ 节点/ u/ 的/ 输出/ 数据/ 存入/ 缓存/ 组/ 作为/ 节点/ v/ 的/ 输入/ 数据/ ,/ 缓存/ 组/ 的/ 大小/ 计算/ 如下/ :/ svv/ -/ svu/ +/ 1/ ;/ Page6/ (/ 2/ )/ 当/ 两个/ 相连/ 计算/ 节点/ 对/ (/ u/ ,/ v/ )/ 被/ 调度/ 到/ 不同/ 处理器/ P0/ 和/ P1/ 上/ ,/ 分配/ 在/ 处理器/ P0/ 的/ 存储/ 上/ u/ 的/ 输出/ 数据/ ,/ 需要/ DMA/ 传输/ 到/ 处理器/ DP1/ 的/ 存储/ 上/ ,/ 作为/ v/ 的/ 输入/ 数据/ ./ 在/ DP0/ 上/ 用于/ 缓存/ u/ 输出/ 数据/ 的/ 缓存/ 组/ 大小/ 由/ seu/ ,/ v/ -/ svu/ +/ 1/ 计算/ ;/ 在/ P1/ 上/ 用于/ 缓存/ v/ 输入/ 数据/ 的/ 缓存/ 组/ 的/ 大小/ 由/ svv/ -/ seu/ ,/ v/ +/ 1/ 计算/ ./ 不等式/ (/ 8/ )/ 给出/ 了/ 处理器/ p/ 的/ 内存/ 限制/ 的/ 形式化/ 描述/ ,/ 不等式/ 左边/ 是/ 处理器/ p/ 上/ 的/ 存储/ 消耗/ 总和/ ./ 其中/ ,/ Buffer/ (/ u/ ,/ v/ )/ 为/ 程序/ 在/ 一次/ 迭代/ 执行/ 中/ ,/ 边/ (/ u/ ,/ v/ )/ 所/ 需要/ 的/ 缓存/ 大小/ ,/ 可以/ 由/ 边上/ 的/ 数据传输/ 个数/ 和/ 相应/ 的/ 数据类型/ 大小/ 的/ 乘积/ 得到/ ./ 其中/ ,/ M1/ =/ seu/ ,/ v/ -/ svu/ +/ 1/ ,/ M2/ =/ svv/ -/ seu/ ,/ v/ +/ 1/ ,/ M3/ =/ svv/ -/ svu/ +/ 1/ ,/ 表示/ 各种/ 缓存/ 组/ 大小/ 所/ 关联/ 的/ 阶段/ 差/ ./ ∑/ (/ u/ ,/ v/ )/ ∈/ EdM3/ )/ du/ ,/ v/ ,/ p/ ]/ ×/ Buffer/ (/ u/ ,/ v/ )/ / Memp/ ,/ 通过/ 把/ 式/ (/ 8/ )/ 中/ 的/ M1/ 、/ M2/ 和/ M3/ 用/ 数值/ 常量/ 替换/ ,/ 限制/ 条件/ 则/ 从/ 非线性/ 转换/ 为/ 线性/ ./ 从/ 3.2/ 节/ 可知/ 当/ 相连/ 两个/ 节点/ u/ 和/ v/ 被/ 调度/ 到/ 不同/ 的/ 处理器/ 上/ ,/ 那么/ DMA/ 和/ u/ 的/ 阶段/ 差/ 至少/ 为/ 1/ ,/ 同样/ ,/ v/ 和/ DMA/ 的/ 阶段/ 差/ 至少/ 也/ 为/ 1/ ,/ 即/ seu/ ,/ v/ -/ svu/ 和/ svv/ -/ seu/ ,/ v/ 的/ 最小值/ 都/ 为/ 1/ ;/ 如果/ 节点/ u/ 和/ v/ 被/ 调度/ 到/ 相同/ 的/ 处理器/ 上/ ,/ 那么/ 两者/ 至少/ 是/ 在/ 同一个/ 阶段/ ,/ 即/ svv/ -/ svu/ 的/ 最小值/ 为/ 0/ ./ 因此/ ,/ 得到/ 估计值/ :/ M1/ =/ 2/ ,/ M2/ =/ 2/ ,/ M3/ =/ 1/ ,/ 限制/ 条件/ (/ 8/ )/ 可以/ 被/ 简化/ 为/ (/ 9/ )/ ./ ∑/ (/ u/ ,/ v/ )/ ∈/ Ed/ 模型/ 的/ 目标/ 函数/ 为/ 最优化/ 流水线/ 吞吐/ 率/ ,/ 即/ 最小化/ 启动/ 时间/ ,/ 如/ 式子/ (/ 10/ )/ 所示/ ./ [/ 2au/ ,/ p/ -/ av/ ,/ p/ +/ 3du/ ,/ v/ ,/ p/ ]/ ×/ Buffer/ (/ u/ ,/ v/ )/ / Memp/ ,/ 限制/ 条件/ (/ 1/ )/ ~/ (/ 7/ )/ 、/ (/ 9/ )/ 和/ 目标/ 函数/ (/ 10/ )/ 给出/ 了/ 数据流/ 程序/ 在/ 内存/ 限制/ 多核/ 处理器/ 下/ 的/ 软件/ 流水/ 调度/ 模型/ 的/ 整数/ 规划/ 问题/ 形式化/ 表达/ ./ 因此/ 可以/ 采用/ 经典/ 的/ 分支/ 界定/ 法/ 或/ 割/ 平面/ 法/ 进行/ 求解/ ./ 虽然/ 整数/ 线性规划/ 求解/ 是/ NP/ 的/ ,/ 但是/ 当前/ 已经/ 有/ 许多/ 高效/ 的/ 产品/ 级/ 的/ 求解/ 器/ ,/ 如/ CPLEX/ [/ 14/ ]/ 混合/ 整数/ 规划/ 求解/ 器/ (/ MixedIntegerProgrammingSolver/ ,/ MIPSolver/ )/ 可以/ 较/ 快/ 地/ 求解/ 整数/ 线性规划/ 问题/ ,/ 该/ MIP/ 采用/ 分支/ 界定/ 算法/ 来/ 求解/ ,/ 并且/ 可以/ 通过/ 设定/ 最优/ 解/ 的/ 精度/ 和/ 求解/ 的/ 时间/ 限制/ 来/ 加速/ 求解/ 的/ 过程/ ./ 由于/ 限制/ 条件/ (/ 9/ )/ 是/ 对/ 内存/ 消耗/ 的/ 一个/ 最小/ 估计/ ,/ 因此/ ,/ 真实/ 的/ 内存/ 消耗/ 可能/ 会/ 大于/ 限制/ 条件/ ./ 我们/ 通过/ 对/ DMA/ 的/ 阶段/ 号/ 进行/ 动态/ 调整/ ,/ 从而/ 平衡/ 各个/ 存储/ 之间/ 的/ 内存/ 使用量/ ,/ 以/ 消除/ 内存/ 溢出/ ./ 首先/ ,/ 计算/ 每个/ 处理器/ 的/ 真实/ 存储/ 消耗/ ,/ 针对/ 存储/ 是否/ 溢出/ 将/ 处理器/ 分为/ 溢出/ 和/ 非/ 溢出/ 两类/ ;/ 其次/ 对/ 调度/ 到/ 溢出/ 处理器/ 上/ 的/ 节点/ 的/ DMA/ 进行/ 查询/ ,/ 如果/ 有/ DMA/ 可以/ 调整/ ,/ 使得/ 该/ 处理器/ 的/ 存储/ 消耗/ 减小/ ,/ 则/ 调整/ DMA/ 阶段/ ,/ 直到/ 消除/ 所有/ 存储/ 溢出/ 或者/ 没有/ 可以/ 调整/ 的/ DMA/ ./ 5/ 实验/ 结果/ 与/ 分析/ 在/ 第/ 3/ 节中/ 描述/ 的/ DFBrook/ 数据流/ 编译系统/ 中/ ,/ 实现/ 了/ 上述/ 的/ 软件/ 流水/ 调度/ 方法/ ./ 本节/ 通过/ 实验/ 对/ 该软件/ 流水/ 调度/ 方法/ 进行/ 性能/ 评价/ ,/ 同时/ 通过/ 与/ 其它/ 方法/ 的/ 比较/ 来/ 验证/ 方法/ 的/ 有效性/ ./ 5.1/ 测试/ 平台/ 和/ 实验/ 方法/ 编译/ 前端/ 对/ DFBrook/ 语言/ 进行/ 语法/ 和/ 语义/ 分析/ 后/ ,/ 采用/ 数据流/ 分析/ ,/ 生成/ 数据流/ 图/ ,/ 调度/ 程序/ 以/ 数据流/ 图为/ 输入/ ,/ 按照/ 上述/ 的/ 模型/ 进行/ 建模/ ,/ 求解/ 出/ 调度/ 结果/ ,/ 用于/ 进一步/ 的/ 优化/ 和/ 代码生成/ ./ 实验/ 的/ 硬件/ 测试/ 平台/ 为/ PlayStation3/ ,/ 配有/ 一个/ Cell/ 处理器/ (/ 6/ 个/ SPE/ 可用/ )/ 和/ 256MB/ 的/ 主存/ ./ Cell/ 处理器/ 采用/ 主从/ 式/ 的/ 组织/ 结构/ ,/ 集成/ 了/ 一个/ 控制/ 处理器/ 单元/ (/ PowerPCProcessorElement/ ,/ PPE/ )/ 和/ 8/ 个/ 数据/ 处理器/ 单元/ (/ SynergisticProcessorElement/ ,/ SPE/ )/ ,/ 每个/ SPE/ 都/ 配有/ 一个/ 256K/ 的/ 局部/ 存储器/ LS/ 和/ DMA/ 数据传输/ 引擎/ ,/ PPE/ 和/ SP/ E通/ 过片/ 上/ 环形/ 网络/ 互连/ ,/ 共享/ 片外/ 存储/ ,/ PPE/ 和/ SPE/ 可以/ 通过/ 消息/ 同步/ ./ 实验/ 采用/ IBM/ 的/ CellSDK3/ ./ 0/ 作为/ DFBrook/ 编译器/ 软件/ 支持/ ,/ 采用/ 的/ 本地/ 编译器/ 为/ ppe/ -/ gcc/ 和/ spe/ -/ gcc/ ./ 整数/ 线性规划/ 采用/ 的/ 是/ CPLEX/ 的/ 混合/ 整数/ 规划/ 求解/ 器/ MIPSolver/ ./ DFBrook/ 程序/ 中/ 存在/ 3/ 种/ 通信/ 模式/ :/ streamRead/ 到/ kernel/ 函数/ 、/ kernel/ 函数/ 之间/ 以及/ kernel/ 函数/ 到/ streamWrite/ ,/ 为了/ 测试/ 模型/ 中/ 的/ 通信量/ 参数/ ,/ 使用/ 1/ 个/ PPE/ 和/ 2/ 个/ SPE/ 测量/ 每个/ kernel/ 函数/ 、/ 数据流/ 操作符/ 以及/ 每个/ DMA/ 传输/ 量/ ./ 实验/ 采用/ 表/ 1/ 中/ 的/ 测试程序/ 集来/ 评价/ 调度/ 模型/ 的/ 性能/ ./ 表中/ 对/ 各个/ 测试程序/ 的/ 特征/ :/ 如/ kernel/ 节点/ 个数/ 、/ 读写/ 节点/ 个数/ 以及/ 通信/ 的/ 边/ 条数/ 进行/ 了/ 详细描述/ ./ 大多数/ 的/ 测试程序/ 来自/ 于/ 多媒体/ 处理/ 领域/ ,/ 如/ :/ Gausslap/ 测试程序/ 实现/ 了/ 高斯/ -/ 拉普拉斯/ 算子/ 进/ Page7/ 行/ 边缘/ 检测/ 算法/ ;/ histogram/ 实现/ 了/ 并行/ 化/ 的/ 直方图/ 算法/ ;/ shortEnergy/ 实现/ 了/ 声音/ 短时/ 能量/ 特征/ 算法/ 的/ DFBrook/ 程序/ ;/ averageMotion/ 实现/ 了/ 视频/ 处理/ 中/ 的/ 运动/ 向量/ 提取/ 算法/ ./ 测试程序/ DCTFFTGausslap28654/ 高斯/ 拉普拉斯/ 算子/ histogram11215/ 图像/ 直方图/ imagesmooth28654/ 图像/ 平滑/ MatrixMult24337/ 分块/ 矩阵/ 乘/ mergesort17224/ 归并/ 排序/ shortEnergy20226/ 音频/ 短时/ 能量/ averageMotion28343/ 视频/ 平均/ 运动/ 向量/ 5.2/ 可扩展性/ 实验/ 首先/ 通过/ 加速/ 比/ 来/ 评价/ 模型/ 的/ 可扩展性/ ,/ 加速/ 比/ 采用/ 以下/ 方法/ 计算/ :/ 当前/ 程序/ Programi/ 在/ p/ 个/ SPE/ 下/ 取得/ 的/ 加速/ 比/ 由/ 当前/ 程序/ 在/ 1/ 个/ SPE/ 调度/ 获得/ 的/ 启动/ 间隔/ II/ 与/ 当前/ p/ 个/ SPE/ 调度/ 获得/ 的/ 启动/ 间隔/ II/ 相比/ 得到/ ./ 图/ 5/ 给出/ 了/ 表/ 1/ 各个/ 测试程序/ 在/ 不同/ 个数/ SPE/ 下/ 的/ 加速/ 比/ ./ 结果显示/ ,/ 调度/ 方法/ 对/ 绝大多数/ 程序/ 取得/ 了/ 近似/ 线性/ 加速/ 比/ ./ FFT/ 和/ histogram/ 在/ SPE/ 个数/ 大于/ 4/ 和/ 5/ 时/ ,/ 程序/ 的/ 加速/ 比不随/ 处理器/ 增加/ 而/ 提高/ ,/ 这是/ 由于/ 这/ 两个/ 程序/ 只有/ 有限/ 个数/ 的/ kernel/ 函数/ ,/ 即/ 问题/ 的/ 规模较/ 小/ ,/ 无法/ 带来/ 更/ 多/ 的/ 加速/ 比/ 提升/ ./ 如表/ 1/ 所示/ ,/ FFT/ 只有/ 10/ 个/ kernel/ 节点/ (/ 表中/ kernel/ 节点/ 数/ +/ 读写/ 节点/ 数/ =/ 总/ 节点/ 数/ )/ ,/ histo/ -/ gram/ 只有/ 9/ 个/ kernel/ 节点/ ./ 通过/ 循环展开/ 数据流/ 图来/ 增加/ 并行性/ (/ 问题/ 的/ 规模/ )/ 可以/ 进一步/ 地/ 提高/ 加速/ 比/ ./ 与/ 上述/ 两个/ 程序/ 相比/ ,/ DCT/ 和/ MatrixMult/ 程序/ 分别/ 有/ 33/ 个/ 和/ 21/ 个/ kernel/ 节点/ ,/ 因此/ ,/ 取得/ 了/ 近似/ 线性/ 的/ 加速/ 比/ ./ 同理/ ,/ Gausslap/ 、/ imagesmooth/ 和/ av/ -/ erageMotion/ 也/ 取得/ 近似/ 线性/ 加速/ 比/ ./ 图/ 5/ 表/ 1/ 中/ 测试程序/ 的/ 加速/ 比/ (/ 以/ II/ 的/ 比率/ 计算/ )/ 5.3/ 性能/ 比较/ 与/ 分析/ 本节/ 将/ 本文/ 的/ 通信/ 最小化/ 的/ 最优化/ 流水/ 调度/ 方法/ CMRO/ 与/ 经典/ 的/ List/ 表/ 调度/ 方法/ [/ 7/ -/ 8/ ]/ 、/ 周期/ 可行/ 的/ 并行/ 调度/ 算法/ [/ 6/ ]/ (/ PeriodicAdmissibleParallelSchedule/ ,/ PAPS/ )/ 和/ 最优/ 计算/ 速率/ 调度/ [/ 9/ ]/ 3/ 种/ 方法/ (/ Rate/ -/ OptimalSchedule/ ,/ RO/ )/ 进行/ 比较/ ./ 表/ 调度/ 算法/ 是/ 广泛应用/ 于/ 传统/ 指令/ 级/ 软件/ 流水/ 调度/ 中/ 的/ 一种/ 方法/ [/ 7/ -/ 8/ ]/ ./ 实验/ 中/ ,/ 通过/ 修改/ 经典/ 的/ 基于/ 优先级/ 的/ 表/ 调度/ 算法/ [/ 15/ ]/ ,/ 实现/ 了/ 基于/ List/ 方法/ 的/ 软件/ 流水/ 调度/ ./ 具体方法/ 如下/ :/ 首先/ 采用/ List/ 调度/ 构造/ 节点/ 到/ 处理器/ 上/ 的/ 调度/ ,/ 实现/ 空间/ 上/ 的/ 调度/ ;/ 然后/ 采用/ Kudlur/ 和/ Mahlke/ 提出/ 的/ 阶段/ 赋值/ 算法/ [/ 9/ ]/ ,/ 对/ 每个/ 节点/ 和/ 数据传输/ 进行/ 阶段/ 赋值/ ./ PAPS/ 算法/ 不/ 考虑/ 实例/ 在/ 不同/ 迭代/ 中/ 的/ 重叠/ 执行/ ,/ 循环/ 的/ 每次/ 迭代/ 为/ 一个/ 基本/ 调度/ 块/ ,/ 一旦/ 调度/ 结果/ 确定/ 以后/ ,/ 后面/ 的/ 迭代/ 采用/ 相同/ 的/ 调度/ 方法/ ./ RO/ 的/ 目标/ 函数/ 是/ 最优化/ 计算/ 速率/ ,/ 即/ 最小化/ II/ ./ 实验/ 中/ ,/ 通过/ 修改/ MCRO/ 整数/ 线性规划/ 调度/ 模型/ 中/ 的/ 目标/ 函数/ 来/ 实现/ RO/ 调度/ ./ 图/ 6/ 给出/ 了/ 本文/ 的/ 通信/ 最小化/ 的/ 最优化/ 软件/ 流水/ 调度/ 方法/ 和表/ 调度/ 及/ PAPS/ 调度/ 在/ 启动/ 间隔/ II/ 上/ 的/ 比较/ 结果/ ./ 从图/ 中/ 可以/ 看出/ ,/ 低/ 通信/ 开销/ 调度/ 方法/ 比表/ 调度/ 算法/ 有/ 较大/ 的/ 性能/ 提高/ ./ 对于/ 具有/ 大/ 计算/ 量/ 的/ 测试程序/ ,/ 如/ DCT/ 、/ shortEnergy/ 和/ average/ -/ Motion/ ,/ MCRO/ 调度/ 方法/ 比表/ 调度/ 在/ 软件/ 流水线/ 的/ 计算/ 速率/ 上/ 取得/ 了/ 17.8/ %/ ~/ 24.7/ %/ 的/ 提高/ ./ MCRO/ 调度/ 方法/ 比/ PAPS/ 调度/ 算法/ 在/ 软件/ 流水/ 计算/ 速率/ 上/ ,/ 平均/ 有/ 47/ %/ 较大/ 的/ 性能/ 提高/ ./ 特别/ ,/ 对于/ FFT/ 和/ mergesort/ 两个/ 程序/ ,/ MCRO/ 调度/ 比/ PAPS/ 调度/ 在/ 流水线/ 计算/ 速率/ 上/ ,/ 分别/ 提高/ 了/ 58.9/ %/ 和/ 53.9/ %/ ./ 对于/ 计算/ 速率/ 提高/ 最小/ 的/ imagesmooth/ 程序/ ./ MCRO/ 调度/ 的/ 解是/ 通过/ 逐步/ 增加/ II/ ,/ 求解/ 规划/ 问题/ ,/ 直到/ 使得/ 模型/ 具有/ 最优/ 解/ 停止/ ,/ MCRO/ 方法/ 得到/ 的/ II/ 是/ 最小/ 的/ II/ ./ 因此/ ,/ MCRO/ 调度/ 和/ RO/ 调度/ 具有/ 相同/ 的/ 计算/ 速率/ ./ 图/ 6/ 本文/ 调度/ 方法/ 与/ 其它/ 方法/ 在/ II/ 上/ 的/ 比较/ Page8/ 图/ 7/ 给出/ 了/ 本文/ 的/ 通信/ 最小化/ 的/ 最优化/ 软件/ 流水/ 调度/ 与表/ 调度/ 、/ PAPS/ 调度/ 和/ RO/ 调度/ 在/ 通信/ 开销/ 上/ 的/ 比较/ ./ MCRO/ 调度/ 比/ List/ 调度/ 在/ 通信/ 开销/ 上/ 平均/ 降低/ 了/ 约/ 23/ %/ ,/ 而/ 对于/ 具有/ 高/ 通信量/ 的/ 程序/ 如/ FFT/ 和/ mergesort/ ,/ MCRO/ 调度/ 方法/ 比/ List/ 调度/ 在/ 通信/ 开销/ 上/ 降低/ 了/ 31.8/ %/ ~/ 40.7/ %/ ;/ MCRO/ 调度/ 对于/ 大部分/ 程序/ 比/ PAPS/ 调度/ 减小/ 了/ 10/ %/ ~/ 20/ %/ ;/ MCRO/ 调度/ 方法/ 比/ RO/ 调度/ 算法/ 在/ 通信/ 开销/ 上/ ,/ 有/ 7/ %/ ~/ 40.9/ %/ 的/ 较大/ 降低/ ,/ 平均/ 减小/ 了/ 21.7/ %/ 的/ 通信/ 开销/ ./ 图/ 7/ 本文/ 调度/ 与/ 其它/ 方法/ 在/ 通信/ 开销/ 上/ 的/ 比较/ 5.4/ 存储/ 性能/ 分析/ 与/ 比较/ 以下/ 将/ 分析/ 存储/ 限制/ 对/ 流水线/ 性能/ 的/ 影响/ ./ 存储/ 限制/ 软件/ 流水/ 调度/ 的/ 目的/ 是/ 最大化/ 地/ 利用/ 片上/ 局表/ 2/ 本文/ 的/ 存储/ 限制/ 调度/ 与/ 文献/ [/ 10/ ]/ 在/ 求得/ 解上/ 的/ 比较/ 测试程序/ DCTFFTGausslap/ √/ histogram/ √/ imagesmooth/ √/ MatrixMult/ √/ mergesort/ √/ shortEnergy/ √/ averageMotion/ √/ 另一方面/ ,/ 将/ 从/ 求得/ 解/ 上来/ 说明/ 本文/ 的/ 存储/ 限制/ 软件/ 流水/ 调度/ 的/ 有效性/ ./ 表/ 2/ 给出/ 了/ 本文/ 的/ 存储/ 限制/ 调度/ 与/ 文献/ [/ 10/ ]/ 在/ 每个/ 不同/ 的/ 片/ 上/ 存储/ 大小/ 情况/ 下/ 求得/ 解/ 的/ 情况/ 比较/ ./ 在/ 表中/ ,/ 符号/ “/ / ”/ 表示/ 本文/ 的/ 调度/ 方法/ 与/ 文献/ [/ 10/ ]/ 的/ 方法/ 都/ 能/ 得到/ 解/ ;/ 符号/ “/ √/ ”/ 表示/ 本文/ 的/ 调度/ 方法/ 可以/ 求得/ 解/ ,/ 但/ 文献/ [/ 10/ ]/ 的/ 方法/ 无法/ 求得/ 解/ ./ 从表中/ 可以/ 看出/ ,/ 文本/ 的/ 调度/ 方法/ 可以/ 求得/ 文献/ [/ 10/ ]/ 无法/ 求得/ 的/ 解/ ./ 这/ 是因为/ 文献/ [/ 10/ ]/ 做/ 了/ 假设/ :/ 数据流/ 图中/ 相连/ 的/ 节点/ 调度/ 到/ 不同/ 的/ 处理器/ 上/ ,/ 因此/ 过多/ 的/ 计算/ 了/ 存储/ 的/ 开销/ ./ 本文/ 的/ 部/ 存储/ 来/ 减小/ 程序/ 对/ 主存/ 的/ 访问/ 延迟/ ./ 对图/ 8/ 给出/ 了/ 本文/ 4.3/ 节中/ 存储/ 限制/ 的/ 软件/ 流水/ 调度/ 对/ 程序/ 性能/ 的/ 改进/ ./ 这里/ ,/ 处理器/ 的/ 个数/ 为/ 固定值/ ,/ 通过/ 逐渐/ 减小/ 片上/ 存储/ 的/ 容量/ 来/ 记录/ 流水线/ 的/ 启动/ 时间/ ./ 片上/ 存储/ 从/ 能够/ 容纳/ 全部/ 程序/ 数据/ 的/ MaxMem/ 开始/ ,/ 逐渐/ 减小/ ,/ 程序/ 的/ 性能/ 也/ 随之/ 下降/ ./ 这/ 是因为/ 随着/ 存储/ 减小/ ,/ 调度/ 器/ 将/ 尽可能/ 地/ 把/ 节点/ 调度/ 到/ 相同/ 的/ 处理器/ 上来/ 减小/ 存储/ 开销/ ,/ 从而/ 导致/ 处理器/ 上/ 的/ 工作/ 负载/ 加大/ ./ 另一方面/ 当片/ 上/ 存储/ 耗尽/ ,/ 将/ 引入/ 新/ 的/ DMA/ 将/ 数据/ 放到/ 主存/ ,/ 从而/ 带来/ DMA/ 的/ 开销/ ./ 图/ 8/ 本文/ 的/ 存储/ 限制/ 调度/ 对/ 程序/ 性能/ 的/ 改进/ 片上/ 存储容量/ MinMem/ +/ 3/ (/ MaxMem/ -/ 方法/ 避免/ 了/ 这个/ 问题/ ,/ 从而/ 能/ 求得/ 更/ 有效/ 的/ 解/ ./ 6/ 总结/ 数据流/ 程序/ 为/ 多/ 核/ 处理器/ 提供/ 了/ 并行/ 优化/ 的/ 机会/ ,/ 但/ 处理器/ 间/ 的/ 通信/ 和/ 同步/ 给/ 程序/ 带来/ 较大/ 的/ 性能/ 开销/ ./ 本文/ 基于/ 多核/ 处理器/ 提出/ 了/ 一种/ 面向/ 数据流/ 程序/ 的/ 软件/ 流水/ 并行/ 方法/ ,/ 在/ 实现/ 最大化/ 流水线/ 吞吐/ 率/ 最小化/ 通信/ 开销/ ,/ 同时/ 针对/ 内存/ 受限/ 系统/ 提出/ 了/ 存储/ 限制/ 的/ 流水线/ 调度/ 方法/ 来/ 改进/ 内存/ 的/ 访问/ Page9/ 性能/ ./ 实验/ 结果表明/ 了/ 方法/ 的/ 有效性/ ./ 本文/ 提出/ 的/ 方法/ 主要/ 针对/ 分布式/ 存储/ 结构/ 的/ 多/ 核/ 处理器/ 架构/ ,/ 如何/ 设计/ 面向/ 共享/ 和/ 层次性/ 存储/ 结构/ 的/ 软件/ 流水/ 并行/ 方法/ 是/ 将来/ 需要/ 进一步/ 研究/ 的/ 工作/ ./ 

