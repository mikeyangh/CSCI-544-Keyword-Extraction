Page1/ 一个/ 可/ 半自动化/ 扩展/ 的/ 静态/ 代码/ 缺陷/ 分析/ 工具/ 梁广泰/ 孟娜/ 李进辉/ 钟浩/ 张路/ 王千祥/ (/ 北京大学/ 信息/ 科学技术/ 学院/ 高/ 可信/ 软件技术/ 教育部/ 重点/ 实验室/ 北京/ 100871/ )/ 摘要/ 基于/ 缺陷/ 模式/ 的/ 代码/ 缺陷/ 分析/ 技术/ 根据/ 预先/ 设定/ 的/ 缺陷/ 模式/ 知识/ 对/ 受检/ 代码/ 进行/ 缺陷/ 分析/ ./ 这种/ 分析/ 技术/ 具有/ 使用/ 简单/ 、/ 查找/ 速度/ 快/ 等/ 优点/ ,/ 是/ 近年来/ 静态/ 代码/ 缺陷/ 分析方法/ 中/ 发展/ 比较/ 迅速/ 的/ 新/ 技术/ ./ 但是/ 目前/ 基于/ 这种/ 分析/ 技术/ 的/ 大多数/ 工具/ 并/ 没有/ 为/ 用户/ 提供/ 足够/ 易用/ 、/ 高效/ 的/ 扩展/ 方式/ 以/ 扩充/ 其/ 缺陷/ 检测/ 能力/ ./ 针对/ 这一/ 问题/ ,/ 作者/ 提出/ 了/ 一个/ “/ 可/ 半自动化/ 扩展/ ”/ 的/ 代码/ 缺陷/ 静态/ 分析方法/ ,/ 设计/ 并/ 实现/ 了/ 一个/ 支持/ 该/ 方法/ 的/ 工具/ —/ —/ —/ CODA/ (/ COdeDefectAnalysistool/ )/ ./ CODA/ 不仅/ 提供/ 了/ “/ 缺陷/ 模式/ 描述/ 模板/ ”/ 以/ 帮助/ 用户/ 快速/ 地/ 手工/ 扩充/ 缺陷/ 模式/ 库/ ,/ 还/ 能/ 在/ 用户/ 的/ 指导/ 下/ 半自动化/ 地/ 挖掘/ 新/ 缺陷/ 模式/ 以/ 快速/ 扩充/ 其/ 缺陷/ 模式/ 库/ ./ 一旦/ 新/ 的/ 缺陷/ 模式/ 被/ 定义/ 并/ 添加/ 至/ 缺陷/ 模式/ 库中/ ,/ CODA/ 便/ 能/ 自动/ 具有/ 针对/ 该类/ 缺陷/ 的/ 检测/ 能力/ ./ 关键词/ 静态/ 分析/ ;/ 缺陷/ 分析/ ;/ 半自动化/ 扩展/ ;/ 缺陷/ 模式/ 1/ 引言/ 静态/ 代码/ 缺陷/ 分析/ 技术/ 通过/ 对/ 代码/ 进行/ 静态/ 分析/ 来/ 推测/ 程序运行/ 时/ 的/ 表现/ 行为/ ,/ 从而/ 发现/ 代码/ 中/ 可能/ 存在/ 的/ 缺陷/ [/ 1/ ]/ ./ 这类/ 技术/ 主要/ 包括/ 自动/ 抽象/ 解释/ [/ 2/ ]/ 、/ 定理/ 证明/ [/ 3/ ]/ 、/ 模型/ 检测/ [/ 4/ ]/ 、/ 符号执行/ [/ 5/ ]/ 和/ 基于/ 缺陷/ 模式/ 的/ 代码/ 检查/ [/ 6/ ]/ 等/ ./ 本文/ 主要/ 考虑/ 基于/ 缺陷/ 模式匹配/ 的/ 代码/ 缺陷/ 查找/ 方法/ ./ 基于/ 模式匹配/ 的/ 代码/ 缺陷/ 查找/ 方法/ 主要/ 包括/ 如下/ 两大/ 步骤/ :/ 首先/ ,/ 对/ 已有/ 代码/ 中/ 出现/ 过/ 的/ 缺陷/ 进行/ 总结/ 并/ 提炼出/ “/ 缺陷/ 模式/ 知识/ ”/ ;/ 然后/ ,/ 采用/ 静态/ 分析/ 的/ 方法/ 对/ 受检/ 代码/ 进行/ “/ 缺陷/ 模式匹配/ ”/ 以/ 确定/ 受检/ 代码/ 是否/ 包含/ 相应/ 缺陷/ ,/ 并/ 把/ 匹配/ 结果/ 以/ 缺陷/ 检测/ 报告/ 的/ 形式/ 呈现/ 给/ 用户/ [/ 7/ ]/ ./ 采用/ 这种/ 方法/ 的/ 代表性/ 缺陷/ 查找/ 工具/ 包括/ FindBugs/ [/ 7/ ]/ 、/ PMD/ ①/ 、/ Jlint/ ②/ 、/ Lint4j/ ③/ 、/ Hammurapi/ ④/ 、/ Matacompilation/ [/ 6/ ]/ 、/ SABER/ [/ 8/ ]/ 、/ DTS/ [/ 9/ ]/ 等/ ./ 这类/ 工具/ 的/ 基本/ 工作/ 原理/ 如图/ 1/ 所示/ :/ 在/ 接收/ 受检/ 程序/ 之后/ ,/ 分析/ 工具/ 的/ 分析/ 引擎/ 根据/ 已有/ 的/ 缺陷/ 模式/ 知识/ ,/ 应用/ 分析/ 技术/ 对/ 受检/ 程序/ 进行/ 相应/ 缺陷/ 的/ 检测/ ,/ 并/ 将/ 分析/ 结果/ 报告/ 给/ 用户/ ./ 在/ 对/ 现有/ 的/ 若干/ 基于/ 模式匹配/ 的/ 代码/ 缺陷/ 静态/ 分析/ 工具/ 研究/ 之后/ ,/ 我们/ 发现/ :/ 在/ 使用/ 这些/ 工具/ 的/ 过程/ 中/ ,/ 用户/ 往往/ 希望/ 能够/ 扩充/ “/ 缺陷/ 模式/ 知识/ ”/ ,/ 以/ 使/ 工具/ 能够/ 支持/ 对/ 自己/ 所/ 关注/ 的/ “/ 代码/ 缺陷/ ”/ 进行/ 检测/ ./ 但/ 目前/ 的/ 大多数/ 工具/ 并/ 没有/ 为/ 用户/ “/ 添加/ 新/ 缺陷/ 模式/ ”/ 提供/ 有力/ 的/ 支持/ ./ 部分/ 工具/ 虽然/ 支持/ 用户/ 扩充/ 缺陷/ 模式/ 知识/ ,/ 但/ 其/ 具体/ 的/ 扩展/ 方式/ 在/ 易用性/ 方面/ 还/ 存在/ 很大/ 不足/ ./ 以/ 其中/ 最/ 具有/ 代表性/ 的/ FindBugs/ 为例/ :/ FindBugs/ 所/ 关注/ 的/ 缺陷/ 模式/ 都/ 被/ 硬/ 编码/ 到/ 工具/ 的/ 若干/ 缺陷/ 模式/ 检查/ 器中/ ./ 当/ 需要/ 使用/ Find/ -/ Bugs/ 检查/ 新/ 的/ 缺陷/ 模式/ 时/ ,/ 用户/ 必须/ 手动/ 修改/ 工具/ 程序/ ,/ 甚至/ 自行/ 编写/ 缺陷/ 模式/ 检查/ 器/ 的/ 代码/ 以/ 检查/ 新/ 的/ 缺陷/ 模式/ ./ PMD/ 借鉴/ 了/ FindBugs/ 依靠/ “/ 用户/ 手工/ 编写/ 检测/ 代码/ ”/ 的/ 方式/ 扩展/ 工具/ 能力/ 的/ 思想/ ,/ 并/ 同时/ 引入/ 了/ XPath/ 表达式/ 来/ 减少/ 用户/ 的/ 编码/ 量/ ,/ 但/ 这种/ 扩展/ 方式/ 依然/ 需要/ 用户/ 花/ 时间/ 学习/ 如何/ 使用/ XPath/ ./ 与/ PMD/ 类似/ ,/ Metacompilation/ 也/ 同样/ 要求/ 用户/ 在/ 描述/ 缺陷/ 之前/ 学习/ 如何/ 使用/ 描述语言/ Metal/ ./ Hammurapi/ 也/ 是/ 一个/ 基于/ 缺陷/ 模式/ 的/ Java/ 代码/ 缺陷/ 查找/ 工具/ ,/ 当/ 用户/ 需要/ 扩展/ 其/ 缺陷/ 模式/ 时/ ,/ 需要/ 基于/ 其/ 提供/ 的/ API/ 进行/ 硬/ 编码/ 得以/ 扩展/ ./ 而/ Jlint/ 、/ Lint4j/ 和/ DTS/ 都/ 未/ 提供/ 缺陷/ 模式/ 知识/ 的/ 扩充/ 机制/ ./ SABER/ 通过/ 提供/ “/ 缺陷/ 模式/ 描述/ 模板/ ”/ 在/ 一定/ 程度/ 上/ 简化/ 了/ 缺陷/ 模式/ 描述/ 方式/ ,/ 但/ 其/ 提供/ 的/ 模板/ 数量/ 与/ 缺陷/ 模式/ 描述/ 能力/ 非常/ 有限/ ./ 为了/ 探索/ 高效/ 易用/ 的/ 扩展/ 方式/ ,/ 从而/ 降低/ 用户/ 的/ 学习/ 成本/ 、/ 快速/ 增强/ 工具/ 的/ 错误/ 查找/ 能力/ ,/ 我们/ 提出/ 了/ 一个/ 支持/ “/ 半自动化/ 扩展/ ”/ 的/ 代码/ 缺陷/ 静态/ 分析方法/ ,/ 设计/ 并/ 实现/ 了/ 支持/ 该/ 方法/ 的/ 工具/ —/ —/ —/ CODA/ (/ COdeDefectAnalysistool/ )/ ./ CODA/ 的/ 主要/ 特点/ 包括/ :/ (/ 1/ )/ 提供/ 了/ 若干/ 不同/ 类型/ 的/ “/ 缺陷/ 模式/ 描述/ 模板/ ”/ ./ 用户/ 可以/ 根据/ 自身/ 需要/ ,/ 选择/ 适当/ 的/ 模板/ 来/ 快速/ 增加/ 缺陷/ 模式/ ./ 工具/ 能够/ 依据/ 用户/ 选择/ 的/ 模板/ 和/ 填入/ 的/ 必要/ 信息/ ,/ 自动/ 生成/ 符合/ CODA/ 格式/ 要求/ 的/ “/ 缺陷/ 模式/ 描述/ 文件/ ”/ ./ CODA/ 在/ 缺陷/ 检测/ 过程/ 中/ 会/ 自动/ 载入/ 这些/ 新加/ 的/ 缺陷/ 模式/ 并/ 在/ 代码/ 中/ 检测/ 相应/ 缺陷/ ./ 这种/ 扩展/ 方式/ 使/ 用户/ 不再/ 需要/ 手工/ 编写/ 代码/ ,/ 也/ 不/ 需要/ 为/ 描述/ 缺陷/ 模式/ 而/ 花费/ 太多/ 的/ 精力/ 学习/ 某种/ 语言/ ./ (/ 2/ )/ 提供/ 了/ 缺陷/ 模式/ 库/ 的/ “/ 半自动化/ 扩展/ ”/ 机制/ ./ 利用/ 规则/ 挖掘/ 器/ ,/ CODA/ 能够/ 从/ 特定/ 的/ 库函数/ 源代码/ 、/ 使用/ 这些/ 库函数/ 的/ 客户/ 代码/ 和/ 库函数/ 的/ API/ 文档/ 中/ 挖掘出/ 该/ 库函数/ 相关/ 的/ 使用/ 规则/ ./ 利用/ 规则/ 转化/ 器/ ,/ CODA/ 能够/ 将/ 过滤/ 后/ 的/ 有用/ 规则/ 转换成/ 对应/ 的/ 缺陷/ 模式/ 并/ 自动/ 添加/ 至/ 缺陷/ 模式/ 库中/ ./ 缺陷/ 模式/ 库/ 的/ 半自动/ 扩展/ 机制/ 不仅/ 减轻/ 了/ 用户/ 手工/ 添加/ 缺陷/ 的/ 工作/ 负担/ ,/ 还/ 为/ 用户/ 省去/ 了/ 手工/ 收集/ 缺陷/ 模式/ 的/ 繁琐/ 劳动/ ,/ 从而/ 支持/ 用户/ 更快/ 地/ 增强/ CODA/ 的/ 缺陷/ 检测/ 能力/ ./ 本文/ 第/ 2/ 节/ 通过/ 一个/ 示例/ 来/ 展示/ CODA/ 的/ 研究/ 动因/ 以及/ CODA/ 的/ 特点/ 与/ 优势/ ;/ 第/ 3/ 节/ 进一步/ 阐述/ CODA/ 的/ 设计/ 和/ 实现/ ,/ 论述/ CODA/ 如何/ 实现/ 上述/ 特点/ ;/ 第/ 4/ 节在/ 实验/ 数据/ 的/ 基础/ 上/ ,/ 讨论/ 缺陷/ 模式/ 库/ 的/ 半自动化/ 扩展/ 机制/ 如何/ 帮助/ CODA/ 快速/ 增强/ ①/ ②/ ③/ ④/ Page3/ 查错/ 能力/ ;/ 第/ 5/ 节/ 总结/ 全文/ ,/ 并/ 提出/ 对/ 未来/ 工作/ 的/ 一些/ 设想/ ./ 2/ 动因/ 本/ 节/ 首先/ 描述/ FindBugs/ 、/ PMD/ 、/ Hammurapi/ 和/ SABER/ 等/ 4/ 个/ 典型/ 工具/ 各自/ 的/ 缺陷/ 模式/ 扩展/ 方式/ ,/ 然后/ ,/ 概要/ 地/ 介绍/ 本文/ 的/ 解决方案/ ./ 描述/ 过程/ 结合/ 一个/ 具体/ 的/ 缺陷/ 模式/ 例子/ 进行/ :/ “/ 代码/ 中/ 错误/ 地/ 调用/ 了/ Thread/ ./ run/ (/ )/ 方法/ ”/ :/ 在/ Java/ 程序/ 中/ ,/ 只能/ 调用/ Thread/ ./ start/ (/ )/ 方法/ ,/ 而/ 不能/ 直接/ 调用/ Thread/ ./ run/ (/ )/ StringclassNameCalled/ =/ getDottedClassConstantOperand/ (/ )/ ;/ 图/ 2/ 在/ FindBugs/ 中/ 需要/ 添加/ 的/ 用于/ 查找/ 缺陷/ “/ 错误/ 地/ 调用/ 了/ Thread/ ./ run/ (/ )/ 方法/ ”/ 的/ 代码/ (/ 2/ )/ 向/ PMD/ 中/ 添加/ 缺陷/ 模式/ PMD/ 提供/ 了/ 两种/ 方式/ 来/ 添加/ 新/ 的/ 缺陷/ 模式/ :/ 编写/ 检查/ 代码/ 的/ 方式/ 和/ 定义/ XPath/ 表达式/ 的/ 方式/ ./ 但/ 受制于/ XPath/ 的/ 表达能力/ ,/ 上面/ 提到/ 的/ 具体/ 缺陷/ 模式/ 只能/ 利用/ 编写/ 代码/ 的/ 方式/ 添加/ 到/ 工具/ 中/ ./ 具体地说/ ,/ 首先/ 需要/ 编写/ 如图/ 3/ 所示/ 的/ “/ 规则/ ”/ 代码/ 实现/ 该类/ 缺陷/ 的/ 查找/ 过程/ ,/ 然后/ ,/ 为了/ 让/ 新/ 添加/ 的/ 规则/ 能够/ 被/ 工具/ 自动/ 加载/ ,/ 同样/ 需要/ 修改/ PMD/ 的/ 配置文件/ 信息/ ./ (/ 3/ )/ 向/ Hammurapi/ 中/ 添加/ 缺陷/ Hammurapi/ 支持/ 用户/ 使用/ 其/ 提供/ 的/ API/ 来/ 扩展/ Inspectors/ ,/ 每/ 一个/ Inspector/ 就是/ 一种/ 类型/ 的/ 缺陷/ 检查/ 器/ ./ 在/ Hammurapi/ 中/ 添加/ 这/ 一新/ 的/ 缺陷/ 模式/ ,/ 也/ 需要/ 通过/ 硬/ 编码方式/ 实现/ ./ 编码/ 过程/ 基本/ 同于/ FindBugs/ ,/ 不同/ 的/ 是/ ,/ 需要/ 基于/ Hammurapi/ 提供/ 的/ API/ 进行/ 扩展/ (/ 继承/ Hammurapi/ 的/ 检查/ 器/ 基类/ biz/ ./ hammurapi/ ./ review/ ./ Inspector/ )/ ./ (/ 4/ )/ 本文/ 方法/ 概述/ 与/ SABER/ 类似/ ,/ CODA/ 也/ 提供/ 了/ 若干/ 模板/ 供/ 方法/ ,/ 因为/ Thread/ ./ start/ (/ )/ 会/ 自动/ 调用/ Thread/ ./ run/ (/ )/ 方法/ ./ (/ 1/ )/ 向/ FindBugs/ 中/ 添加/ 缺陷/ 模式/ FindBugs/ 只/ 支持/ 用户/ 通过/ 自行/ 编码/ 的/ 方式/ 来/ 扩充/ 工具/ 的/ 错误/ 查找/ 能力/ ./ 为/ 添加/ 上述/ 缺陷/ 模式/ ,/ 首先/ 需要/ 编写/ 如图/ 2/ 所示/ 的/ 缺陷/ 检查/ 器/ (/ Detector/ )/ 代码/ ;/ 然后/ ,/ 需要/ 在/ FindBugs/ 的/ 配置文件/ 中/ 定义/ 该/ 新添/ 缺陷/ 模式/ 的/ 相关/ 描述/ 信息/ ,/ 以便/ 于/ 工具/ 在/ 检测/ 到/ 该/ 类型/ 缺陷/ 时向/ 用户/ 进行/ 报告/ ;/ 最后/ ,/ 还/ 需要/ 修改/ FindBugs/ 中/ 关于/ 检查/ 器/ 的/ 配置文件/ ,/ 以便/ 工具/ 在/ 启动/ 时/ 自动/ 载入/ 这个/ 新加/ 的/ 检查/ 器/ ../ addClassAndMethod/ (/ this/ )/ ./ addCalledMethod/ (/ this/ )/ ./ addSourceLine/ (/ this/ )/ )/ ;/ 用户/ 在/ 描述/ 缺陷/ 时/ 使用/ ./ 但/ 不同/ 的/ 是/ ,/ CODA/ 提供/ 的/ 模板/ 要/ 丰富/ 得/ 多/ ,/ 几乎/ 涵盖/ 了/ 大部分/ 常见/ 的/ 缺陷/ 模式/ 类型/ (/ 详见/ 3.2/ 节/ )/ ./ 为了/ 支持/ 用户/ 更加/ 快捷/ 地/ 添加/ 符合/ 模板/ 的/ 缺陷/ 模式/ ,/ CODA/ 提供/ 了/ 图形化/ 界面/ 输入/ 方式/ ./ 用户/ 在/ 添加/ 缺陷/ 模式/ 时/ ,/ 只/ 需要/ 在/ 选择/ 相应/ 模板/ 后/ 填入/ 必要/ 的/ 信息/ ,/ CODA/ 便/ 能够/ 自动/ 生成/ 该/ 缺陷/ 模式/ 的/ XML/ 描述/ 文件/ ./ 例如/ ,/ 对于/ 上述/ 例子/ ,/ 由于/ CODA/ 提供/ 了/ “/ 代码/ 中/ 错误/ 地/ 调用/ X/ 方法/ ”/ 的/ 模板/ ,/ 用户/ 在/ 添加/ 缺陷/ 模式/ 时/ 只/ 需要/ 打开/ “/ 图形化/ 界面/ ”/ ,/ 选中/ 相应/ 模板/ 并/ 指明/ 模板/ 里/ 的/ X/ 为/ Thread/ ./ run/ (/ )/ 即可/ ./ 当新/ 缺陷/ 模式/ 不能/ 通过/ 我们/ 提供/ 的/ 模板/ 进行/ 描述/ 的/ 时候/ ,/ 可以/ 通过/ 直接/ 撰写/ 该/ 缺陷/ 模式/ 对应/ 的/ “/ 有限/ 状态/ 自动机/ XML/ 描述/ 文件/ ”/ 方式/ 进行/ 扩展/ (/ 详见/ 3.2/ 节/ )/ ./ 另外/ ,/ 为了/ 方便/ 用户/ 快速/ 添加/ 更为/ 丰富/ 的/ 缺陷/ 模式/ ,/ CODA/ 还/ 提供/ 了/ 一个/ 半自动/ 的/ 缺陷/ 模式/ 挖掘/ 器/ ./ 这个/ 缺陷/ 模式/ 挖掘/ 器/ 可以/ 通过/ 多种/ 方式/ 挖掘出/ 大量/ 方法/ 调用/ 序列/ 相关/ 的/ 缺陷/ 模式/ ,/ 从而/ 支持/ 快速/ 扩展/ CODA/ 的/ 缺陷/ 检测/ 能力/ (/ 详见/ 3.3/ 节/ )/ ./ Page422for/ (/ NameOccurrenceocc/ :/ declars/ )/ {/ // // iterateallinvocationofthethreadsmethods23if/ (/ !/ isTargetMethod/ (/ occ/ )/ )/ {/ // // iftheinvokedmethodisnot/ "/ run/ (/ )/ "/ ,/ ignoreit36/ &&/ (/ occ/ ./ getNameForWhichThisIsAQualifier/ (/ )/ ./ getImage/ (/ )/ ./ indexOf/ (/ "/ run/ "/ )/ !/ =/ -/ 1/ )/ )/ {/ 图/ 3/ 在/ PMD/ 中/ 需要/ 添加/ 的/ 用于/ 查找/ 缺陷/ “/ 错误/ 地/ 调用/ 了/ Thread/ ./ run/ (/ )/ 方法/ ”/ 的/ 代码/ 通过/ 上述/ 介绍/ ,/ 我们/ 可以/ 发现/ :/ 无论是/ “/ 自行/ 编写/ 缺陷/ 检测/ 代码/ ”/ 的/ 方式/ 还是/ “/ 使用/ 特殊/ 语言/ 描述/ 缺陷/ ”/ 的/ 方式/ ,/ 都/ 对/ 工具/ 使用者/ 的/ 学习/ 能力/ 及/ 应用/ 能力/ 提出/ 了/ 很/ 高/ 的/ 要求/ ./ 这种/ 来自/ 于/ 工具/ 本身/ 的/ 实现/ 方式/ 妨碍/ 了/ 使用者/ 根据/ 个性/ 需求/ 自定义/ 地/ 扩展/ 工具/ 缺陷/ 查找/ 能力/ ,/ 降低/ 了/ 使用者/ 扩充/ 缺陷/ 模式/ 的/ 效率/ ./ 与/ 代码/ 和/ 描述语言/ 相比/ ,/ CODA/ 内置/ 的/ “/ 图形化/ 的/ 模板/ ”/ 更/ 利于/ 工具/ 使用者/ 扩充/ 缺陷/ 模式/ 知识/ :/ 一方面/ ,/ 使用/ 自然语言/ 定义/ 的/ 缺陷/ 描述/ 模板/ 符合/ 人/ 的/ 思维习惯/ ,/ 人们/ 不/ 需要/ 像/ 学习/ 一门/ 编程语言/ 那样/ 额外/ 花/ 时间/ 来/ 学习/ 模板/ 的/ 使用/ 方法/ ;/ 另一方面/ ,/ 由于/ 每个/ 模板/ 含有/ 的/ 参数/ 个数/ 较/ 少/ ,/ 人们/ 在/ 描述/ 缺陷/ 时/ 需要/ 输入/ 的/ 信息/ 也/ 较/ 少/ ,/ 因此/ 工具/ 使用者/ 可以/ 较/ 快/ 地/ 扩充/ 缺陷/ 模式/ 知识/ ./ 除此之外/ ,/ CODA/ 所/ 提供/ 的/ 半自动化/ 的/ 缺陷/ 模式/ 扩展/ 方式/ 能/ 帮助/ 工具/ 的/ 使用者/ 批量/ 添加/ 缺陷/ 模式/ ,/ 从而/ 加速/ 扩展/ CODA/ 的/ 缺陷/ 查找/ 能力/ ./ CODA/ 的/ 主要/ 优势/ 在于/ 其/ 良好/ 的/ 易/ 扩展性/ ./ 用户/ 既/ 可以/ 使用/ 工具/ 提供/ 的/ 各种/ 模板/ 以/ “/ 图形化/ 方式/ ”/ 添加/ 新/ 的/ 缺陷/ 模式/ ,/ 也/ 可以/ 直接/ 以/ “/ 编写/ XML/ 描述/ 文件/ ”/ 的/ 方式/ 添加/ 复杂/ 的/ 缺陷/ 模式/ ,/ 还/ 可以/ 使用/ CODA/ 的/ 半自动化/ 扩展/ 方式/ 批量/ 发现/ 、/ 整理/ 、/ 添加/ 新/ 的/ 缺陷/ 模式/ ./ 3CODA/ 的/ 设计/ 与/ 实现/ CODA/ 主要/ 由/ 缺陷/ 查找/ 引擎/ 、/ 缺陷/ 模式/ 库/ 和/ 缺陷/ 模式/ 挖掘/ 器三/ 部分/ 组成/ ,/ 如图/ 4/ 所示/ ./ 缺陷/ 查找/ 引擎/ 负责/ 在/ 受检/ 程序/ 中/ 逐一/ 应用/ 不同/ 类型/ 的/ 缺陷/ 检查/ 器/ 进行/ 缺陷/ 检测/ ,/ 并/ 将/ 检测/ 报告/ 呈现/ 给/ 用户/ ;/ 缺陷/ 模/ Page5/ 式/ 库/ 用于/ 集中/ 保存/ 和/ 管理/ 各种/ 缺陷/ 模式/ 信息/ ;/ 缺陷/ 模式/ 挖掘/ 器/ 负责/ “/ 半自动化/ ”/ 地/ 挖掘/ 并/ 生成/ 新/ 的/ 缺陷/ 模式/ 信息/ ./ 3.1/ 缺陷/ 查找/ 引擎/ 缺陷/ 查找/ 引擎/ 中/ 包含/ 大量/ 检查/ 器/ 和/ 分析器/ ./ “/ 检查/ 器/ ”/ 是/ 指/ CODA/ 中/ 用于/ 查找/ 各种/ 具体/ 缺陷/ 的/ 程序模块/ ,/ 例如/ 用于/ 查找/ “/ 文件/ 流/ 是否/ 及时/ 关闭/ ”/ 缺陷/ 的/ 图/ 5/ 缺陷/ 查找/ 引擎/ 结构图/ 3.1/ ./ 1/ 分析器/ 工厂/ 在/ 缺陷/ 模式/ 的/ 匹配/ 过程/ 中/ ,/ 检查/ 器/ 往往/ 需要/ 利用/ 各种/ 底层/ 分析/ 技术/ 的/ 分析/ 结果/ 来/ 完成/ 匹配/ 过程/ 或/ 提高/ 匹配/ 精度/ ,/ 例如/ 在/ 检测/ “/ 文件/ 流/ 是否/ 及时/ 关闭/ ”/ 的/ 缺陷/ 时/ ,/ 需要/ 使用/ 到/ “/ 别名/ 分析/ 技术/ ”/ 以/ 准确/ 判断/ 某/ 一个/ 文件/ 流/ 对象/ 是否/ 被/ 及时/ 关闭/ ./ CODA/ 中/ 的/ 分析器/ 有/ 多个/ ,/ 它们/ 是/ 对/ 不同/ 的/ 静态/ 分析/ 技术/ 的/ 实现/ ,/ 所有/ 的/ 分析器/ 组成/ “/ 分析器/ 工厂/ ”/ ./ 当/ 某个/ 检查/ 器/ 需要/ 某个/ 分析器/ 的/ 分析/ 结果/ 时/ ,/ 检查/ 器会/ 通过/ “/ 分析器/ 工厂/ ”/ 向/ 这个/ 分析器/ 发出/ 数据/ 请求/ ;/ 分析器/ 根据/ 请求/ 在/ 自己/ 的/ 缓存/ 中/ 查找/ 相应/ 的/ 分析/ 结果/ :/ 如果/ 存在/ ,/ 则/ 直接/ 做出/ 回应/ ;/ 否则/ 启动/ 分析/ 过程/ 生成/ 所/ 需/ 结果/ ,/ 在/ 结果/ 产生/ 后/ 做出/ 回应/ ,/ 并/ 缓存/ 该/ 结果/ 以待/ 后续/ 使用/ ./ 目前/ ,/ CODA/ 中/ 已经/ 实现/ 的/ 分析器/ 包括/ 控制流/ 图/ 分析器/ 、/ 类型/ 分析器/ 、/ 类/ 层次结构/ 分析/ 、/ 常量/ 传播/ 分析器/ 、/ 空/ 指针/ 分析器/ 、/ 锁/ 计数/ 分析器/ 、/ 活性/ 变量/ 分析器/ 、/ 调用/ 图/ 分析器/ 和/ 指向/ (/ 别名/ )/ 分析器/ ./ 其中/ 常量/ 传播/ 分析器/ 、/ 空/ 指针/ 分析器/ 、/ 锁/ 计数/ 分析器/ 和/ 活性/ 变量/ 表/ 1CODA/ 中/ “/ 内置/ 缺陷/ 模式/ 检查/ 器/ ”/ 一览表/ 检查/ 的/ 缺陷/ 内容/ FindNullDerefFindSleepWithLockHeldFindWaitOrNotifyWithMultiLocks/ 持有/ 多个/ 锁/ 的/ 情况/ 下/ 调用/ wait/ (/ )/ 方法/ 或者/ notify/ (/ )/ 方法/ LockDataflowAnalysisFindWaitOrNotifyWithoutLock/ 不/ 持有/ 锁/ 的/ 情况/ 下/ 调用/ wait/ (/ )/ 方法/ 或者/ notify/ (/ )/ 方法/ LockDataflowAnalysisFindUnusedDefFindWeakLoopController/ 在/ 持有/ 任何/ 锁/ 的/ 情况/ 下/ 调用/ Thread/ ./ sleep/ (/ )/ 方法/ 程序模块/ 等/ ./ “/ 分析器/ ”/ 是/ 指/ CODA/ 中/ 用于/ 为/ 检查/ 器/ 提供/ 基础/ 分析/ 结果/ 的/ 各种/ 静态/ 分析/ 技术/ ,/ 例如/ “/ 控制流/ 分析器/ ”/ 和/ “/ 别名/ 分析器/ ”/ 等/ ./ 当/ 用户/ 提交/ 受检/ 程序/ 给/ CODA/ 时/ ,/ 缺陷/ 查找/ 引擎/ 会/ 逐一/ 调用/ 各/ 检查/ 器/ 对/ 代码/ 进行/ 缺陷/ 检查/ ,/ 然后/ 向/ 用户/ 报出/ 所有/ 的/ 缺陷/ 检测/ 结果/ ,/ 如图/ 5/ 所示/ ./ 缺陷/ 查找/ 引擎/ 包括/ 两/ 大部分/ :/ 分析器/ 工厂/ 和/ 检查/ 器/ 集合/ ./ 分析器/ 的/ 实现/ 属于/ “/ 过程/ 内/ 数据流/ 分析/ ”/ ,/ 而/ 调用/ 图/ 分析器/ 和/ 指向/ 分析器/ 则/ 属于/ “/ 过程/ 间/ 数据流/ 分析/ ”/ ./ 3.1/ ./ 2/ 检查/ 器/ 集合/ 检查/ 器是/ CODA/ 中/ 直接/ 用于/ 检查/ 某种/ 特定/ 缺陷/ 的/ 模块/ ./ 依据/ 检查/ 器/ 的/ 组织/ 方式/ ,/ 我们/ 把/ 检查/ 器/ 集合/ 中/ 所有/ 的/ 检查/ 器/ 分成/ 两大类/ :/ “/ 内置/ 缺陷/ 模式/ 的/ 检查/ 器/ ”/ 和/ “/ 外置/ 缺陷/ 模式/ 的/ 检查/ 器/ ”/ ./ (/ 1/ )/ 内置/ 缺陷/ 模式/ 的/ 检查/ 器/ 很多/ 现有/ 工具/ ,/ 如/ FindBugs/ 和/ PMD/ ,/ 通常/ 只/ 包含/ 内置/ 缺陷/ 模式/ 的/ 检查/ 器/ ./ 这类/ 检查/ 器/ 把/ 待/ 检测/ 的/ 缺陷/ 模式/ 信息/ 硬/ 编码/ 在/ 检查/ 器/ 代码/ 中/ ,/ 这样/ 使得/ 缺陷/ 模式/ 信息/ 与/ 检查/ 器/ 的/ 业务/ 逻辑/ 紧密/ 关联/ ./ 如果/ 想/ 增强/ 该类/ 检查/ 器/ 的/ 检测/ 能力/ ,/ 必须/ 修改/ 其/ 源代码/ ,/ 或者/ 添加/ 自行/ 编写/ 的/ 新/ 检查/ 器/ ./ 检查/ 器/ 的/ 这种/ 实现/ 方法/ 大大/ 影响/ 了/ 工具/ 的/ 可扩展性/ ./ CODA/ 中/ 的/ 内置/ 检查/ 器较/ 少/ ,/ 主要/ 包括/ FindNullDeref/ 、/ Find/ -/ SleepWithLockHeld/ 、/ FindWaitOrNotifyWithMulti/ -/ LocksHeld/ 、/ FindWaitOrNotifyWithoutLock/ 、/ Find/ -/ UnusedDef/ 和/ FindWeakLoopController/ (/ 参看/ 表/ 1/ )/ ./ Page6/ (/ 2/ )/ 外置/ 缺陷/ 模式/ 的/ 检查/ 器/ 外置/ 缺陷/ 模式/ 的/ 检查/ 器/ 是/ 指/ CODA/ 中/ 那些/ 将/ 待/ 检测/ 的/ 缺陷/ 模式/ 信息/ 从/ 错误/ 查找/ 逻辑/ 中/ 剥离/ 出来/ ,/ 并/ 集中/ 存放/ 在/ 缺陷/ 模式/ 库中/ 的/ 检查/ 器/ ./ 由于/ 这/ 类/ 检查/ 器/ 将/ 缺陷/ 模式/ 信息/ 与/ 错误/ 查找/ 逻辑/ 进行/ 了/ 很/ 好/ 的/ 剥离/ ,/ 我们/ 可以/ 在/ 不/ 修改/ 工具/ 代码/ 的/ 前提/ 下/ ,/ 通过/ 向/ 缺陷/ 模式/ 库中/ 添加/ 新/ 缺陷/ 模式/ ,/ 达到/ 扩展/ 工具/ 错误/ 查找/ 能力/ 的/ 目的/ ./ CODA/ 中/ 实现/ 了/ 三类/ 外置/ 缺陷/ 模式/ 的/ 检查/ 器/ :/ “/ 时序/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ ”/ 、/ “/ 值/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ ”/ 和/ “/ 继承/ // 实现/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ ”/ ./ ①/ 时序/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ “/ 时序/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ ”/ 主要/ 负责/ 查找/ “/ 方法/ 调用/ 顺序/ ”/ 相关/ 的/ 缺陷/ 模式/ ./ 这类/ 缺陷/ 模式/ 的/ 共同点/ 在于/ 它们/ 几乎/ 都/ 可以/ 表示/ 成/ 有限/ 状态/ 自动机/ 的/ 形式/ ./ 例如/ 缺陷/ 模式/ “/ FileInputStream/ 对象/ 在/ 使用/ 完后/ 需要/ 执行/ FileInputStream/ ./ close/ (/ )/ 方法/ 进行/ 销毁/ ”/ ,/ 其/ 对应/ 的/ 有限/ 状态/ 自动机/ 如图/ 6/ 所示/ :/ 状态/ 2/ 为/ 错误/ 状态/ ,/ 状态/ 1/ 和/ 3/ 为/ 正确/ 状态/ ./ 在/ 分析/ 结束/ 时/ ,/ 如果/ 该/ 状态机/ 处于/ 状态/ 2/ ,/ 则/ 程序/ 存在/ 该类/ 缺陷/ ;/ 如果/ 处于/ 状态/ 1/ 和/ 3/ ,/ 则/ 说明/ 程序/ 未/ 包含/ 此类/ 缺陷/ ./ CODA/ 使用/ XML/ 描述/ 文件/ 对/ 此类/ 缺陷/ 模式/ 所/ 对应/ 的/ 有限/ 状态/ 自动机/ 进行/ 描述/ (/ 详见/ 3.2/ 节/ 介绍/ )/ ./ 图/ 6/ 用于/ 检查/ “/ FileInputStream/ 对象/ 在/ 使用/ 完后/ CODA/ 运行/ 时/ ,/ “/ 时序/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ ”/ 会/ 动态/ 地/ 根据/ 这些/ “/ XML/ 描述/ ”/ 实例/ 化/ 有限/ 状态/ 自动机/ ,/ 并/ 根据/ 受检/ 程序/ 的/ 实际/ “/ 方法/ 调用/ 情况/ ”/ 适时/ 驱动/ 各个/ 有限/ 状态机/ 进行/ 状态/ 转换/ ./ 在/ 分析/ 完/ 受检/ 程序/ 后/ ,/ 若/ 某/ 一/ 状态机/ 处于/ 错误/ 状态/ ,/ 则/ 说明/ 受检/ 程序/ 中/ 存在/ 相应/ 的/ 缺陷/ ,/ CODA/ 会/ 将/ 该/ 状态机/ 对应/ 的/ “/ 缺陷/ 描述/ 信息/ ”/ 报告/ 给/ 用户/ ./ 该类/ 检查/ 器/ 的/ 主要/ 实现/ 流程/ 为/ :/ 首先/ 对/ 程序/ 中/ 的/ 每个/ 方法/ 构造/ 控制流/ 图/ ,/ 然后/ 在/ 控制流/ 图上/ 做/ “/ 自动机/ 状态/ ”/ 的/ 数据流/ 分析/ ,/ 最后/ 根据/ 自动机/ 的/ 所处/ “/ 状态/ ”/ 来/ 判断/ 受检/ 程序/ 中/ 是否/ 存在/ 相应/ 缺陷/ ./ 下面/ 对/ 该/ 数据流/ 分析/ 的/ 要点/ 进行/ 介绍/ :/ (/ i/ )/ 该/ 数据流/ 分析/ 的/ 对象/ 为/ “/ 不同/ 自动机/ 在/ 受检/ 程序/ 中/ 的/ 所处/ 状态/ ”/ ./ 分析/ 过程/ 中/ ,/ CODA/ 会为/ 同一/ 类型/ 的/ 不同/ 对象/ 分别/ 创建/ 其/ 各自/ 对应/ 的/ 自动机/ ./ 这/ 使得/ 本/ 数据流/ 分析/ 是/ 对象/ 敏感/ 的/ ./ 例如/ 一个/ 方法/ 内/ 创建/ 了/ 两个/ 文件/ 输入/ 流/ fin1/ 和/ fin2/ ,/ CODA/ 会为/ 每个/ 输入/ 流/ 创建/ 其/ 对应/ 的/ 有限/ 状态机/ 并/ 跟踪/ 各个/ 状态机/ 的/ 状态/ 变化/ ,/ 这样/ 当某/ 一/ 对象/ 的/ close/ (/ )/ 方法/ 未/ 被/ 调用/ 时/ ,/ CODA/ 能够/ 定位/ 出/ 具体/ 哪个/ 对象/ 触犯/ 了/ 该/ 缺陷/ ./ (/ ii/ )/ 转换/ 函数/ (/ Transform/ )/ 的/ 定义/ ./ 为/ 便于/ 叙述/ ,/ 假设/ 控制流/ 图/ 的/ 每个/ 块/ 仅/ 包含/ 一条/ 语句/ ./ 当/ 遇到/ 某一/ 方法/ 调用/ 语句/ 时/ ,/ 首先/ 获得/ 调用/ 这个/ 方法/ 的/ 对象/ ,/ 将/ 这个/ 方法/ 调用/ 作为/ 转移/ 条件/ ,/ 推进/ 这个/ 对象/ 上/ 的/ 所有/ 自动机/ 的/ 状态/ 迁移/ ./ 例如/ ,/ 假设/ 本/ 方法/ 关注/ 的/ 是/ “/ java/ ./ io/ ./ FileInputStream/ 对象/ 上/ 的/ 流/ 打开/ 之后/ 未/ 关闭/ ”/ 的/ 时序/ 约束/ ./ 那么/ 当/ 遇到/ 语句/ “/ FileInput/ -/ Streamfin/ =/ newFileInputStream/ (/ )/ ”/ 时/ ,/ 就/ 需要/ 将/ “/ newFileInputStream/ (/ )/ ”/ 作为/ 状态/ 转移/ 条件/ ,/ 推进/ 对象/ “/ fin/ ”/ 上/ 的/ 自动机/ 到/ 下/ 一个/ 状态/ ./ 同样/ 的/ ,/ 如果/ 遇到/ “/ fin/ ./ close/ (/ )/ ”/ 语句/ ,/ 就/ 将/ “/ close/ (/ )/ ”/ 作为/ 转移/ 条件/ ,/ 推进/ 对象/ “/ fin/ ”/ 上/ 的/ 自动机/ 进行/ 状态/ 转移/ ./ 转换/ 函数/ 的/ 输入/ 是/ 当前/ 所有/ 自动机/ 的/ 状态/ 集合/ ,/ 输出/ 是/ 改变/ 后/ 的/ 自动机/ 状态/ 集合/ ./ (/ iii/ )/ 汇合/ 函数/ (/ Merge/ )/ 的/ 定义/ ./ 汇合/ 函数/ 要/ 决定/ 当/ 一个/ 块/ 存在/ 多个/ 前驱/ 时/ ,/ 如何/ 从/ 这些/ 前驱/ 的/ “/ 数据流/ 输出/ 值/ ”/ 得到/ 这个/ 块/ 的/ “/ 数据流/ 输入/ 值/ ”/ ./ 在/ 该/ 分析/ 中/ ,/ 所有/ 前驱/ 的/ “/ 数据流/ 输出/ 值/ ”/ 取/ 并/ 集后/ 的/ 自动机/ 状态/ 集合/ ,/ 会/ 作为/ 这个/ 块/ 的/ “/ 数据流/ 输入/ 值/ ”/ ./ 采取/ 这种/ 策略/ ,/ 本/ 检查/ 器/ 能够/ 检测/ 出/ 特定/ 路径/ 上/ 存在/ 的/ 缺陷/ ./ 如图/ 7/ 所示/ ,/ EXIT/ 存在/ 多个/ 前驱/ B2/ 、/ B3/ ,/ 汇合/ 后/ EXIT/ 入口处/ 对象/ Fin/ 存在/ 两个/ 自动机/ 状态/ ,/ 其中/ 一个/ 状态/ 对应/ 着/ 路径/ (/ B1/ -/ >/ B2/ -/ >/ EXIT/ )/ ,/ 这个/ 自动机/ 状态/ 是/ 正确/ 的/ ,/ 说明/ 该/ 路径/ 不/ 存在/ 缺陷/ ;/ 另/ 一个/ 自动机/ 状态/ 对应/ 路径/ (/ B1/ -/ >/ B3/ -/ >/ EXIT/ )/ ,/ 而/ 该/ 状态/ 是/ 错误/ 状态/ ,/ 可以/ 知道/ 该/ 路径/ 触犯/ 了/ 该/ 缺陷/ ./ (/ iv/ )/ 拷贝/ 函数/ (/ Copy/ )/ 的/ 定义/ ./ 拷贝/ 函数/ 的/ 功能/ 就是/ 实现/ 从/ 一个/ 块/ 的/ 前驱/ 的/ 输出/ 数据流/ 值到/ 这个/ 块/ 的/ 输入/ 数据流/ 值/ 的/ 转换/ ./ 本/ 方法/ 中/ ,/ 直接/ 将/ 前驱/ 的/ 输出/ 值/ 复制到/ 这个/ 块/ 的/ 输入/ 值/ 即可/ ./ Page7/ ②/ 值/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ “/ 值/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ ”/ 主要/ 负责/ 查找/ 方法/ 调用/ 的/ 传入/ 传出/ 参数值/ 相关/ 的/ 缺陷/ 模式/ ,/ 例如/ 缺陷/ 模式/ “/ java/ ./ sql/ ./ ResultSet/ 的/ getArray/ (/ )/ 方法/ 传入/ 参数/ 不能/ 为/ 0/ ”/ ./ CODA/ 中有/ 多个/ 检查/ 器/ 属于/ 此类/ ,/ 每个/ 检查/ 器/ 负责/ 对/ 多个/ 缺陷/ 模式/ 进行/ 查找/ ,/ 该类/ 的/ 检查/ 器/ 一览表/ 2CODA/ 中/ “/ 值/ 相关/ 的/ 外置/ 缺陷/ 模式/ 检查/ 器/ ”/ 一览表/ FindInvalidTypeInMethodArgumentFindInvalidValueInMethodArgumentFindVacuousComputation/ 举例来说/ ,/ 缺陷/ 模式/ “/ java/ ./ sql/ ./ ResultSet/ 的/ getArray/ (/ )/ 方法/ 传入/ 参数/ 不能/ 为/ 0/ ”/ 与/ “/ java/ ./ sql/ ./ Pre/ -/ paredStatement/ 的/ setArray/ (/ )/ 方法/ 传入/ 参数/ 不能/ 为/ 0/ ”/ 都/ 可以/ 表述/ 成/ “/ A/ 类/ 的/ B/ 方法/ 传入/ 参数/ 不能/ 为/ M/ 值/ ”/ 的/ 形式/ ,/ CODA/ 在/ 查找/ 它们/ 时/ 使用/ 同样/ 的/ 匹配/ 算法/ ./ 因此/ 我们/ 把/ 匹配/ 算法/ 编写/ 到/ 检查/ 器中/ ,/ 而/ 把/ 缺陷/ 模式/ 对/ “/ A/ ”/ 、/ “/ B/ ”/ 、/ “/ C/ ”/ 实例/ 化/ 的/ 个性/ 信息/ 添加/ 到/ 相应/ 的/ 配置文件/ 中/ ./ 在/ 缺陷/ 匹配/ 过程/ 中/ ,/ 该类/ 检查/ 器/ 使用/ 常量/ 传播/ 分析器/ 和/ 空/ 指针/ 分析器/ 提供/ 的/ 分析/ 结果/ 来/ 确定/ 调用/ 方法/ 的/ 输入输出/ 值/ 是否/ 合法/ ,/ 使用/ 类型/ 分析器/ 来/ 确定/ 调用/ 方法/ 的/ 输入输出/ 值/ 的/ 类型/ 是否/ 合法/ ./ 表/ 2/ 中/ 列出/ 了/ CODA/ 中/ 已经/ 实现/ 的/ “/ 值/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ ”/ 以及/ 它们/ 各自/ 使用/ 到/ 的/ 分析器/ 名称/ ./ ③/ 继承/ // 实现/ 相关/ 的/ 缺陷/ 模式/ 检查/ 器/ 这些/ 检查/ 器/ 主要/ 负责/ 查找/ 在/ 继承/ 某个/ 类/ 或者/ 实现/ 某个/ 接口/ 时/ ,/ 类/ 的/ 定义/ 、/ 方法/ 的/ 定义/ 等/ 相关/ 的/ 缺陷/ 模式/ ,/ 例如/ 缺陷/ 模式/ “/ 实现/ Cloneable/ 接口/ 的/ 类/ 没/ 重写/ 方法/ clone/ (/ )/ ”/ ./ CODA/ 中/ 属于/ 此种/ 检查/ 器/ 的/ 是/ FindImplClassNoDefOrUseMethod/ ,/ 该/ 检查/ 器/ 用于/ 查找/ 实现/ 某/ 接口/ 或类/ 时/ ,/ 未/ 按照/ 规范/ 要求/ 定义/ 或/ 使用/ 某些/ 方法/ ./ 该/ 检查/ 器/ 在/ 查找/ 缺陷/ 时未/ 使用/ 任何/ 分析/ 技术/ 提供/ 的/ 分析/ 结果/ ,/ 只/ 使用/ 了/ 从/ 字节/ 码中/ 提取/ 出来/ 的/ 程序/ 信息/ ./ 3.2/ 缺陷/ 模式/ 库/ 缺陷/ 模式/ 库/ 负责/ 保存/ 和/ 管理/ 缺陷/ 模式/ 信息/ ./ 这些/ 缺陷/ 模式/ 信息/ 根据/ 其所/ 对应/ 的/ 检查/ 器/ 种类/ ,/ 被/ 分为/ “/ 时序/ 相关/ 的/ 缺陷/ 模式/ 信息/ ”/ 、/ “/ 值/ 相关/ 的/ 缺陷/ 模式/ 信息/ ”/ 和/ “/ 继承/ // 实现/ 相关/ 的/ 缺陷/ 模式/ 信息/ ”/ ./ 它们/ 被/ 分别/ 存放/ 在/ 不同/ 的/ 信息/ 集中/ (/ 如图/ 8/ 所示/ )/ ./ 将/ 缺陷/ 查找/ 能力/ 和/ 缺陷/ 模式/ 信息/ 相/ 分离/ ,/ 不仅/ 有利于/ 我们/ 表/ 详见/ 表/ 2/ ./ 由于/ 对应/ 于/ 同一/ 检查/ 器/ 的/ 所有/ 缺陷/ 模式/ 具有/ 相同/ 的/ 检测/ 逻辑/ ,/ 所以/ 我们/ 只/ 把/ 能/ 被/ 共享/ 的/ 检测/ 逻辑/ 编写/ 到/ 检查/ 器/ 代码/ 中/ ,/ 而/ 把/ 不能/ 被/ 共享/ 的/ 各/ 缺陷/ 模式/ 信息/ 独立/ 定义/ 在/ 缺陷/ 模式/ 库中/ ./ CODA/ 会/ 在/ 运行/ 时/ 自动/ 从/ 缺陷/ 模式/ 库/ 将/ 这些/ 信息/ 加载/ 到/ 对应/ 的/ 检查/ 器中/ ,/ 并/ 使用/ 同一/ 检查/ 器/ 完成/ 多个/ 缺陷/ 模式/ 的/ 并发/ 匹配/ ./ 清晰/ 的/ 划分/ 出/ 各/ 检查/ 器/ 的/ 工作/ 职能/ ,/ 还/ 有助于/ 用户/ 更好/ 地/ 理解/ 甚至/ 扩展/ 工具/ 的/ 缺陷/ 模式/ 知识/ ./ 例如/ ,/ 在/ 用户/ 发现/ 新/ 的/ 缺陷/ 模式/ 之后/ ,/ 他们/ 只/ 需/ 根据/ 需要/ 选用/ 合适/ 的/ 模板/ 来/ 添加/ 信息/ 到/ 缺陷/ 模式/ 库中/ ,/ 而无须/ 关心/ 缺陷/ 查找/ 的/ 技术细节/ ./ CODA/ 为/ 每/ 一类/ 的/ 缺陷/ 模式/ 信息/ 分别/ 提供/ 了/ 若干/ 模板/ 供/ 用户/ 在/ 描述/ 缺陷/ 时/ 使用/ ,/ 这些/ 模板/ 几乎/ 涵盖/ 了/ 大部分/ 常见/ 的/ 缺陷/ 模式/ 类型/ (/ 如表/ 3/ )/ ./ 所属/ 类别/ 时序/ 相关/ 调用/ 方法/ B/ 之前/ 必须/ 调用/ 方法/ A/ 值/ 相关/ 继承/ // 实现/ 相关/ 实现/ 接口/ (/ 或类/ )/ A/ 的/ 类/ 必须/ 实现/ B/ 方法/ 为了/ 方便/ 用户/ 添加/ ,/ 对于/ “/ 时序/ 相关/ ”/ 的/ 缺陷/ 模式/ ,/ 缺陷/ 模式/ 库/ 还/ 提供/ “/ 图形化/ 界面/ ”/ 输入/ 方式/ ./ 用户/ 在/ 添加/ 缺陷/ 模式/ 时/ ,/ 只/ 需要/ 在/ 选择/ 相应/ 模板/ 后/ 填入/ Page8/ 必要/ 的/ 信息/ 并/ 点击/ “/ 添加/ ”/ 按钮/ ,/ CODA/ 便/ 能够/ 自动/ 生成/ 该/ 缺陷/ 模式/ 对应/ 的/ 自动机/ XML/ 描述/ 文件/ 并/ 存入/ 缺陷/ 模式/ 库中/ ./ 对于/ “/ 值/ 相关/ ”/ 和/ “/ 继承/ // 实现/ 相关/ ”/ 的/ 缺陷/ 模式/ ,/ 用户/ 可以/ 通过/ 直接/ 改写/ 描述/ 模板/ 添加/ 新/ 的/ 缺陷/ 模式/ ./ 当新/ 缺陷/ 模式/ 不能/ 通过/ 我们/ 提供/ 的/ 模板/ 进行/ 描述/ 的/ 时候/ ,/ 可以/ 通过/ 直接/ 撰写/ 该/ 缺陷/ 模式/ 对应/ 的/ “/ 有限/ 状态/ 自动机/ XML/ 描述/ 文件/ ”/ 方式/ 进行/ 扩展/ ./ 例如/ ,/ 缺陷/ 模式/ “/ FileOutputStream/ 对象/ 在/ 使用/ 完后/ 需要/ 执行/ FileOutputStream/ ./ close/ (/ )/ 方法/ 进行/ 销毁/ ;/ 调用/ FileOutputStream/ ./ close/ (/ )/ 方法/ 之后/ 不能/ 调用/ FileOutputStream/ ./ write/ (/ )/ 方法/ ”/ ./ 这个/ 缺陷/ 模式/ 不/ 能够/ 直接/ 使用/ 上述/ 模板/ 进行/ 描述/ (/ 当然/ 可以/ 将/ 该/ 缺陷/ 首先/ 拆/ 分成/ 两个/ 子/ 缺陷/ “/ FileOutputStream/ 对象/ 在/ 使用/ 完后/ 需要/ 执行/ FileOutputStream/ ./ close/ (/ )/ 方图/ 9/ 用于/ 检查/ FileOutputStream/ 相关/ “/ 复合式/ ”/ 缺陷/ 的/ 有限/ 状态/ 自动机/ 〈/ stateDescription/ 〉/ AFileOutputStreamcreatedandnotreleased/ 〈/ // stateDescription/ 〉/ 〈/ invokeMethod/ 〉/ java/ ./ io/ ./ FileInputStream/ :/ voidclose/ (/ )/ 〈/ // invokeMethod/ 〉/ 〈/ invokeMethod/ 〉/ java/ ./ io/ ./ FileInputStream/ :/ voidwrite/ (/ )/ 〈/ // invokeMethod/ 〉/ 图/ 10FileOutputStream/ 相关/ “/ 复合式/ ”/ 缺陷/ 对应/ 的/ 有限/ 状态/ 自动机/ 描述/ 文件/ 法/ 进行/ 销毁/ ”/ 和/ “/ 调用/ FileOutputStream/ ./ close/ (/ )/ 方法/ 之后/ 不能/ 调用/ FileOutputStream/ ./ write/ (/ )/ 方法/ ”/ ,/ 然后/ 分别/ 使用/ 模板/ 进行/ 描述/ )/ ,/ 而/ CODA/ 所/ 提供/ 的/ 有限/ 状态机/ 描述/ 方式/ 支持/ 对/ 该类/ “/ 复合式/ ”/ 缺陷/ 模式/ 直接/ 进行/ XML/ 描述/ ./ 该/ 复合式/ 缺陷/ 模式/ 对应/ 的/ “/ 有限/ 状态/ 自动机/ ”/ 和/ “/ 自动机/ 描述/ 文件/ ”/ 如图/ 9/ 、/ 图/ 10/ 所示/ ./ 自动机/ XML/ 描述/ 文件/ 中/ 包括/ 了/ 对/ 这个/ 缺陷/ 模式/ 的/ 描述/ 信息/ (/ description/ 节点/ )/ 、/ 自动机/ 的/ 各个/ 状态/ 的/ 描述/ (/ state/ 节点/ )/ 、/ 各个/ 状态/ 之间/ 的/ 转移/ 条件/ (/ edge/ 节点/ )/ 以及/ 各个/ 状态/ 的/ 正确/ 与否/ (/ status/ 节点/ )/ ./ 受检/ 程序/ 被/ 分析/ 后/ ,/ 若该/ 状态机/ 处于/ 正确/ 状态/ (/ status/ =/ right/ )/ ,/ 说明/ 受检/ 程序/ 未/ 存在/ 该类/ 缺陷/ ;/ 若当/ 状态机/ 处于/ 某一/ 错误/ 状态/ (/ status/ =/ error/ )/ 时/ ,/ 说明/ 受检/ 程序/ 中/ 存在/ 相应/ 的/ 缺陷/ ,/ CODA/ 会/ 将/ 该/ 状态/ 对应/ 的/ 缺陷/ 描述/ 信息/ (/ stateDescription/ 节点/ )/ 报告/ 给/ 用户/ ./ Page93/ ./ 3/ 缺陷/ 模式/ 挖掘/ 器/ CODA/ 的/ 缺陷/ 模式/ 库/ 扩展/ 工作/ 可以/ 是/ 人工/ 进行/ 的/ ,/ 也/ 可以/ 是/ 半自动/ 进行/ 的/ ./ 以/ 人工/ 的/ 方式/ 扩展/ 新/ 缺陷/ 模式/ ,/ 不仅/ 对/ 用户/ 有/ 较/ 高/ 的/ 要求/ ,/ 而且/ 效率/ 较/ 低/ ./ 为了/ 提高/ 缺陷/ 模式/ 库/ 的/ 扩展/ 效率/ ,/ CODA/ 实现/ 了/ 缺陷/ 模式/ 挖掘/ 器/ ,/ 从而/ 支持/ 以/ 半自动化/ 的/ 方式/ 扩展/ 其/ 缺陷/ 模式/ 库/ ./ 缺陷/ 模式/ 挖掘/ 器/ 包括/ 三/ 部分/ :/ 规则/ 挖掘/ 器/ 、/ 规则/ 精化/ 器/ 和/ 规则/ 转换器/ ,/ 如图/ 11/ 所示/ ./ (/ 1/ )/ 规则/ 挖掘/ 器/ 规则/ 挖掘/ 器/ 用于/ 自动/ 生成/ 客户/ 代码/ 调用/ 软件/ 库函数/ 时所应/ 遵循/ 的/ 规则/ ./ 目前/ ,/ 我们/ 已经/ 实现/ 了/ 3/ 个/ 规则/ 挖掘/ 器/ [/ 10/ -/ 12/ ]/ ./ 其中/ ,/ 第/ 1/ 个/ 规则/ 挖掘/ 器/ MATS/ [/ 10/ ]/ 从/ 客户/ 代码/ 挖掘/ 调用/ 软件/ 库函数/ 的/ 规则/ ,/ 适用/ 于/ 存在/ 大量/ 客户/ 的/ 情况/ ;/ 第/ 2/ 个/ 规则/ 挖掘/ 器/ JRF/ [/ 11/ ]/ 从/ 软件/ 库/ 的/ 源代码/ 推导/ 出/ 调用/ 软件/ 库函数/ 的/ 规则/ ,/ 适用/ 于/ 能/ 获取/ 软件/ 库/ 代码/ 的/ 情况/ ;/ 第/ 3/ 个/ 规则/ 挖掘/ 器/ Doc2Spec/ [/ 12/ ]/ 从/ 软件/ 库/ 的/ API/ 文档/ 中/ 推导/ 出/ 调用/ 该软件/ 库函数/ 的/ 规则/ ,/ 适用/ 于/ 客户端/ 代码/ 和/ 库函数/ 代码/ 都/ 不能/ 获取/ 到/ 时/ ./ 以/ 生成/ “/ 打开/ 的/ FileInputStream/ 实例/ 要/ 在/ 使用/ 完后/ 调用/ close/ (/ )/ 方法/ 关闭/ ”/ 这个/ 规则/ 为例/ ,/ MATS/ 需要/ 先对/ 调用/ FileInputStream/ 有关/ 的/ 函数/ 插桩/ 并/ 收集/ 跟踪/ 数据/ ,/ 然后/ 再/ 从/ 跟踪/ 数据/ 里/ 挖掘出/ 这/ 条/ 规则/ ;/ JRF/ 需要/ 分析/ FileInputStream/ 的/ 源代码/ ,/ 然后/ 根据/ 这个/ 类/ 提供/ 的/ 各个/ 函数/ 之间/ 的/ 关系/ 推导/ 出/ 这条/ 规则/ ;/ Doc2Spec/ 使用/ 自然语言/ 处理/ 相关/ 技术/ 对/ API/ 文档/ 中/ 关于/ FileInputStream/ 的/ 描述/ 进行/ 剖析/ ,/ 从而/ 推导/ 出/ 该类/ 相关/ 的/ 一系列/ 使用/ 规则/ ./ (/ 2/ )/ 规则/ 精化/ 器/ 规则/ 精化/ 器/ 用于/ 对/ 规则/ 挖掘/ 器/ 产生/ 的/ 初始/ 规则/ 进行/ 筛选/ ,/ 以/ 挑出/ 可靠/ 的/ 库函数/ 使用/ 规则/ 留待/ 进一步/ 处理/ ./ 已有/ 的/ 方法/ [/ 13/ -/ 14/ ]/ 基本上/ 是/ 在/ 规则/ 生成/ 之后/ 才/ 进行/ 筛选/ ,/ 例如/ Yang/ 等/ 人/ [/ 14/ ]/ 开发/ 的/ Perracotta/ 采用/ 了/ 两个/ 启发式/ 的/ 方法/ 过滤/ 不/ 可靠/ 的/ 规则/ ./ 这/ 两个/ 过滤/ 方法/ 参考/ 了/ 函数/ 名字/ 的/ 相似性/ 和/ 调用/ 关系/ ./ 而/ 我们/ 的/ 过滤/ 方法/ 则/ 尽量/ 在/ 跟踪/ 数据/ 生成/ 时期/ 就/ 过滤/ 掉/ 对/ 挖掘/ 规则/ 有/ 负面/ 作用/ 的/ 函数调用/ ./ 由于/ 滤掉/ 了/ 那些/ 有/ 负面/ 作用/ 的/ 函数调用/ ,/ 我们/ 的/ 方法/ 能/ 有效/ 地/ 提高/ 挖掘/ 规则/ 的/ 准确度/ ./ 并且/ ,/ 由于/ 我们/ 提出/ 的/ 方法/ 在/ 跟踪/ 数据/ 生成/ 时期/ 就/ 过滤/ 掉/ 了/ 很多/ 有/ 负面/ 作用/ 的/ 函数调用/ ,/ 因而/ 记录/ 的/ 跟踪/ 数据/ 较/ 小/ ,/ 从而/ 大大/ 节省/ 了/ 挖掘/ 规则/ 所/ 需要/ 的/ 时间/ ./ 虽然/ 我们/ 提出/ 的/ 过滤/ 方法/ 能/ 有效/ 地/ 帮助/ 提高/ 生成/ 的/ 规则/ 的/ 准确度/ ,/ 但/ 正如/ 我们/ 的/ 实验/ 结果/ 所示/ [/ 11/ ]/ :/ 即使/ 引入/ 了/ 我们/ 提出/ 的/ 过滤/ 技术/ ,/ 生成/ 的/ 规则/ 准确度/ 仍然/ 不够/ 高/ ./ 为了/ 得到/ 准确/ 的/ 缺陷/ 模式/ 知识/ ,/ CODA/ 在/ 这个/ 环节/ 还/ 需要/ 一定/ 的/ 人工/ 参与/ ,/ 因此/ 我们/ 称/ CODA/ 为/ 具有/ “/ 半自动化/ 扩展/ ”/ 能力/ 的/ 静态/ 缺陷/ 分析/ 工具/ ./ (/ 3/ )/ 规则/ 转换器/ 规则/ 转换器/ 的/ 作用/ 在于/ 把/ 精化/ 后/ 的/ 规则/ 转换成/ 时序/ 相关/ 的/ 缺陷/ 模式/ 信息/ ,/ 并/ 自动/ 添加/ 至/ 缺陷/ 模式/ 库中/ ./ CODA/ 所/ 提供/ 的/ 缺陷/ 模式/ 库/ 的/ 半自动化/ 扩展/ 机制/ 的/ 突出/ 特点/ 在于/ :/ 它/ 可以/ 帮助/ 用户/ 以/ 多种/ 方式/ 批量/ 发现/ 库函数/ 的/ 使用/ 规则/ ,/ 并/ 在/ 用户/ 的/ 指导/ 下/ 自动/ 将/ 有效/ 规则/ 转换成/ 缺陷/ 模式/ 信息/ 并/ 添加/ 到/ 缺陷/ 模式/ 库中/ ./ 这种/ 半自动化/ 的/ 扩展/ 机制/ 不仅/ 省去/ 了/ 用户/ 通过/ 阅读/ 大量/ 代码/ 搜集整理/ 缺陷/ 模式/ 的/ 繁琐/ 劳动/ ,/ 还/ 可以/ 提高/ 添加/ 缺陷/ 模式/ 信息/ 的/ 工作效率/ ./ 有关/ 缺陷/ 模式/ 挖掘/ 器/ 的/ 更/ 多/ 信息/ 可以/ 参考文献/ [/ 10/ -/ 12/ ]/ ./ 4/ 实验/ 4.1/ 实验/ 目的/ 对于/ 共性/ 缺陷/ 比较/ 确定/ 的/ 领域/ ,/ 例如/ 某个/ 特定/ 的/ 操作系统/ 或/ 开发/ 环境/ ,/ 传统/ 的/ 缺陷/ 分析/ 工具/ 能够/ 基本/ 满足要求/ ./ 本文/ 提出/ 的/ 方法/ 主要/ 适用/ 于/ 共性/ 缺陷/ 不断/ 扩展/ 的/ 领域/ ./ 中间件/ 就是/ 一个/ 共性/ 缺陷/ 不断/ 扩展/ 的/ 领域/ :/ 随着/ 中间件/ 的/ 日益/ 增多/ ,/ 越来越/ 多/ 的/ 企业级/ 应用软件/ 都/ 是/ 基于/ 中间件/ 开发/ 得到/ 的/ ./ 随之而来/ 的/ 问题/ 是/ ,/ 程序员/ 往往/ 因为/ 对/ 中间件/ 的/ 了解/ 不够/ 深入/ 而/ 错误/ 地/ 使用/ 了/ 其/ 提供/ 的/ 接口/ ,/ 从而/ 导致/ 编写出/ 的/ 程序/ 存在/ 缺陷/ ./ 因此/ ,/ 从/ 基于/ 中间件/ 开发/ 的/ 应用程序/ 角度/ 来看/ ,/ 一个/ 能够/ 检查程序/ 中/ 是否/ 存在/ 中间件/ 相关/ 缺陷/ 的/ 工具/ 是/ 非常/ 重要/ 的/ ./ 但/ 就/ 现有/ 的/ 各/ 缺陷/ 分析/ 工具/ 而言/ ,/ 它们/ 对/ 中间件/ 相关/ 的/ 缺陷/ 模式/ 还/ 基本上/ 涉猎/ 不/ 多/ ,/ 原因/ 主要/ 有/ 两个/ 方面/ :/ (/ 1/ )/ 很多/ 缺/ Page10/ 陷/ 分析/ 工具/ 只/ 关注/ 那些/ 普遍存在/ 于/ 各/ 软件/ 中/ 的/ 基础性/ 、/ 常见/ 性/ 缺陷/ ,/ 例如/ 空/ 指针/ 引用/ 、/ 声明/ 的/ 变量/ 未/ 被/ 使用/ 等等/ ,/ 以/ 确保/ 工具/ 可以/ 被/ 广泛/ 使用/ ;/ (/ 2/ )/ 绝大多数/ 工具/ 并/ 没有/ 提供/ 足够/ 方便/ 的/ 扩展/ 机制/ 以/ 添加/ 新/ 的/ 缺陷/ 模式/ ,/ 当新/ 的/ 中间件/ 不断/ 出现/ 时/ ,/ 这些/ 工具/ 无法/ 及时/ 地/ 扩展/ 这些/ 中间件/ 相关/ 的/ 缺陷/ 模式/ ,/ 因此/ 很难/ 查出/ 这些/ 中间件/ 相关/ 的/ 缺陷/ ./ 在/ 本/ 实验/ 中/ ,/ 我们/ 分别/ 使用/ CODA/ 、/ FindBugs/ 、/ PMD/ 和/ Hammurapi/ 对/ J2EE/ 和/ JBoss/ 的/ 一些/ 客户/ 代码/ 进行/ 缺陷/ 检测/ ,/ 以/ 确认/ CODA/ 在/ 查找/ 中间件/ 相关/ 的/ 缺陷/ 上/ 是否/ 存在/ 优势/ ./ 4.2/ 实验/ 过程/ 为了/ 展示/ 半自动化/ 扩展/ 机制/ 对/ 缺陷/ 模式/ 库/ 内容/ 的/ 扩充/ 以及/ 缺陷/ 查找/ 能力/ 的/ 提升/ 所/ 发挥/ 的/ 作用/ ,/ 我们/ 设计/ 了/ 如下/ 实验/ :/ (/ 1/ )/ 首先/ 利用/ CODA/ 的/ 半自动化/ 扩展/ 机制/ 将/ J2EE/ 、/ JBoss/ 的/ 时序/ 相关/ 的/ 缺陷/ 模式/ 添加/ 到/ CODA/ 的/ 缺陷/ 模式/ 库中/ ;/ (/ 2/ )/ 选择/ J2EE/ 客户/ 代码/ (/ wsmg/ -/ 1.76/ ./ 1/ 和/ jonas/ -/ 3.0/ ./ 6/ )/ 和/ JBOSS/ 客户/ 代码/ (/ jboss/ -/ remoting/ -/ 2.2/ ./ 2/ )/ 作为/ 实验/ 过程/ 的/ 受检/ 程序/ ;/ (/ 3/ )/ 分别/ 运行/ CODA/ 、/ FindBugs/ (/ 1.3/ ./ 8/ )/ 、/ PMD/ (/ 4.2/ ./ 5/ )/ 和/ Hammurapi/ (/ 5.7/ ./ 0/ )/ 以/ 检测/ J2EE/ 客户/ 代码/ 中/ 的/ 缺陷/ ;/ (/ 4/ )/ 分别/ 运行/ CODA/ 、/ FindBugs/ (/ 1.3/ ./ 8/ )/ 、/ PMD/ (/ 4.2/ ./ 5/ )/ 和/ Hammurapi/ (/ 5.7/ ./ 0/ )/ 以/ 检测/ JBOSS/ 客户/ 代码/ 中/ 的/ 缺陷/ ;/ (/ 5/ )/ 对/ 4/ 个/ 工具/ 报出/ 的/ J2EE/ 、/ JBOSS/ 平台/ 相关/ 的/ 缺陷/ 报告/ 进行/ 对比/ 分析/ ./ 4.3/ 实验/ 结果/ 在/ 应用/ 4/ 种/ 工具/ 检测/ J2EE/ 客户/ 代码/ 时/ ,/ Find/ -/ Bugs/ 、/ PMD/ 和/ Hammurapi/ 因为/ 缺少/ J2EE/ 相关/ 的/ 缺陷/ 检测器/ 而/ 都/ 未能/ 报出/ J2EE/ 相关/ 的/ 缺陷/ ./ 而/ CODA/ 则/ 得益于/ 半自动化/ 扩展/ 机制/ 报出/ 了/ 一些/ 与/ J2EE/ 相关/ 的/ 缺陷/ ./ CODA/ 在/ 检测/ wsmg/ -/ 1.76/ ./ 1/ 时报/ 出/ 了/ “/ javax/ ./ jms/ ./ MessageConsumer/ 实例/ 在/ 使用/ 之后/ 没有/ 调用/ close/ (/ )/ 方法/ ”/ 的/ 缺陷/ ./ 该/ 缺陷/ 发生/ 于类/ “/ wsmg/ ./ proces/ -/ sors/ ./ PublisherThread/ ”/ 中/ ./ 经/ 分析/ 发现/ ,/ 该类/ 的/ 私有/ 属性/ consumer/ 属于/ MessageConsumer/ 类型/ ,/ 该类/ 的/ 构造函数/ 通过/ “/ session/ ./ createConsumer/ (/ destination/ )/ ”/ 语句/ 创建/ 了/ consumer/ 对象/ ,/ 但/ 该类/ 的/ run/ (/ )/ 等/ 其它/ 方法/ 中/ 都/ 没有/ 对/ 该/ consumer/ 执行/ close/ (/ )/ 方法/ ./ 这/ 说明/ CODA/ 报出/ 的/ 该/ 缺陷/ 是/ 准确/ 的/ ./ 除此之外/ ,/ wsmg/ -/ 1.76/ ./ 1/ 中/ 还有/ 另外/ 两处/ 对/ MessageConsumer/ 进行/ 了/ 使用/ ,/ 分别/ 位于/ 类/ “/ wsmg/ ./ jms/ ./ TestActiveMQ40/ ”/ 和/ “/ wsmg/ ./ jms/ ./ DeliveryThread/ ”/ 中/ ./ 经/ 分析/ ,/ TestAc/ -/ tiveMQ40/ 类/ 文件/ 的/ 第/ 154/ 行/ 通过/ “/ MessageCon/ -/ sumerconsumer/ =/ session/ ./ createConsumer/ (/ desti/ -/ nation/ )/ ”/ 语句/ 创建/ 了/ MessageConsumer/ 对象/ ,/ 在/ 第/ 167/ 行/ 通过/ “/ consumer/ ./ close/ (/ )/ ”/ 语句/ 对/ 该/ 对象/ 进行/ 了/ 即时/ 关闭/ ,/ 该处/ 对/ MessageConsumer/ 的/ 使用/ 属于/ 正确/ 使用/ ./ DeliveryThread/ 类/ 的/ 构造方法/ 中/ 依然/ 使用/ “/ session/ ./ createConsumer/ (/ destination/ )/ ”/ 语句/ 创建/ 了/ consumer/ 对象/ ,/ 但/ 该/ 语句/ 处于/ 一个/ “/ 永假/ ”/ 分支/ 中/ ./ 在/ 该/ 源文件/ 被/ 编译成/ class/ 文件/ 时/ ,/ 编译器/ 会/ 自动/ 将/ 该/ 分支/ 代码/ 作为/ deadcode/ 剔除/ 掉/ ./ 而/ CODA/ 分析/ 的/ 是/ bytecode/ 文件/ ,/ 因此/ 并未/ 报出/ 这一/ 缺陷/ ./ CODA/ 在/ 检测/ jonas/ -/ 3.0/ ./ 6/ 时报/ 出/ 了/ “/ javax/ ./ jms/ ./ QueueSender/ 实例/ 在/ 使用/ 之后/ 没有/ 调用/ close/ (/ )/ 方法/ ”/ 的/ 缺陷/ ./ 该/ 缺陷/ 发生/ 于/ “/ sampleappli/ ./ Stock/ -/ HandlerBean/ ”/ 类/ 文件/ 中/ ./ 经/ 分析/ ,/ 该项/ 目的/ Java/ 代码/ 中/ 只有/ 这/ 一处/ 对/ QueueSender/ 进行/ 了/ 使用/ 而且/ CODA/ 报出/ 的/ 该/ 缺陷/ 是/ 准确/ 的/ ./ 在/ 应用/ 4/ 种/ 工具/ 检测/ JBoss/ 客户/ 代码/ (/ jboss/ -/ remoting/ -/ 2.2/ ./ 2/ )/ 时/ ,/ FindBugs/ 、/ PMD/ 和/ Hammurapi/ 也/ 都/ 因为/ 缺少/ JBOSS/ 相关/ 的/ 缺陷/ 检测器/ 而/ 都/ 未能/ 报出/ 与/ Jboss/ 相关/ 的/ 缺陷/ ./ 而/ CODA/ 却/ 得益于/ 半自动化/ 扩展/ 的/ 方式/ 报出/ 了/ 一些/ 与/ JBOSS/ 相关/ 的/ 缺陷/ ./ CODA/ 在/ 检测/ jboss/ -/ remoting/ -/ 2.2/ ./ 2/ 时报/ 出/ 了/ 缺陷/ “/ org/ ./ jboss/ ./ remoting/ ./ detection/ ./ Detector/ 实例/ 在/ 使用/ 之后/ 没有/ 调用/ stop/ (/ )/ ”/ ./ 该/ 缺陷/ 发生/ 于/ “/ org/ ./ jboss/ ./ remoting/ ./ detection/ ./ util/ ./ DetectorUtil/ ”/ 类中/ ./ 经/ 分析/ 发现/ ,/ 该类/ 的/ start/ (/ )/ 方法/ 中/ 通过/ 第/ 128/ 行/ 的/ “/ MulticastDetectormdet/ =/ newMulticast/ -/ Detector/ (/ )/ ”/ 和/ 第/ 130/ 行/ 的/ “/ detector/ =/ mdet/ ”/ 等/ 语句/ 新建/ 了/ 一个/ Detector/ 对象/ ,/ 然后/ 在/ 第/ 145/ 行/ 执行/ 了/ “/ detector/ ./ start/ (/ )/ ”/ 方法/ ,/ 但/ 在/ 该/ 方法/ 结束/ 前/ 并未/ 执行/ stop/ 方法/ ./ 这/ 说明/ ,/ CODA/ 报出/ 的/ 这/ 一/ 缺陷/ 是/ 准确/ 的/ ./ 除此之外/ ,/ CODA/ 还/ 报出/ 了/ 缺陷/ “/ org/ ./ jboss/ ./ remoting/ ./ transport/ ./ ClientInvoker/ 的/ 实例/ 在/ 使用/ 之后/ 没有/ 调用/ disconnect/ (/ )/ ”/ ,/ 该/ 缺陷/ 发生/ 于/ “/ org/ ./ jboss/ ./ remoting/ ./ Client/ ”/ 类中/ ./ 经/ 人工/ 核实/ ,/ 发现/ 该类/ 的/ disconnect/ (/ )/ 方法/ 中/ 调用/ 了/ 静态/ 类/ InvokerRegistry/ 的/ destroyClientInvoker/ (/ )/ 方法/ ,/ 而/ destroyClientInvoker/ (/ )/ 方法/ 中/ 调用/ 了/ ClientInvoker/ 的/ disconnect/ (/ )/ 方法/ ./ 该类/ 通过/ 跨类/ 调用/ 的/ 方式/ “/ 隐式/ 地/ ”/ 对/ ClientInvoker/ 实例/ 进行/ 了/ disconnect/ ./ 由于/ Page11CODA/ 在/ 跨类/ 的/ 方法/ 间/ 分析/ 上/ 不够/ 完善/ ,/ 导致/ 其/ 报出/ 的/ 该/ 缺陷/ 为/ 误报/ ./ 通过/ 人工/ 核实/ ,/ 我们/ 发现/ :/ CODA/ 所/ 报出/ 的/ 上述/ 4/ 种/ 中间件/ 相关/ 的/ 缺陷/ 的/ 准确率/ 为/ 75/ %/ ,/ 漏报/ 率约/ 为/ 20/ %/ ./ 由于/ 现有/ 的/ 分析/ 技术/ 、/ 规则/ 挖掘/ 技术/ 都/ 不够/ 成熟/ ,/ 我们/ 的/ 工具/ CODA/ 还有/ 很多/ 需要/ 完善/ 的/ 地方/ ./ 但/ 借助/ 缺陷/ 模式/ 库/ 的/ 半自动化/ 扩展/ 机制/ ,/ CODA/ 的/ 缺陷/ 检测/ 能力/ 能够/ 在/ 短时间/ 内/ 得到/ 迅速/ 扩展/ 和/ 提升/ ./ 通过/ 上述/ 实验/ 结果/ 我们/ 可以/ 确认/ :/ 与/ 其它/ 工具/ 相比/ ,/ CODA/ 在/ 对/ 中间件/ 相关/ 的/ 缺陷/ 检测/ 方面/ 具有/ 较大/ 的/ 优势/ ./ 5/ 结语/ 针对/ 大多数/ 现有/ 静态/ 代码/ 缺陷/ 查找/ 工具/ 都/ 没有/ 为/ 用户/ 提供/ 足够/ 易用/ 的/ 缺陷/ 模式/ 扩展/ 机制/ ,/ 本文/ 提出/ 了/ 一个/ 支持/ 半自动化/ 扩展/ 的/ 基于/ 缺陷/ 模式匹配/ 的/ 静态/ 缺陷/ 分析方法/ ,/ 并/ 开发/ 了/ 基于/ 该/ 方法/ 的/ 工具/ CODA/ ./ CODA/ 不仅/ 提供/ 了/ 很多/ 缺陷/ 模式/ 描述/ 模板/ ,/ 以/ 方便/ 用户/ 根据/ 自身/ 需要/ ,/ 选择/ 适当/ 模板/ 来/ 描述/ 所/ 感兴趣/ 的/ 缺陷/ 模式/ ,/ 还/ 提供/ 了/ 缺陷/ 模式/ 库/ 的/ 半自动化/ 扩展/ 机制/ ,/ 该/ 机制/ 可以/ 帮助/ 用户/ 半自动化/ 地/ 快速/ 地/ 发现/ 、/ 整理/ 、/ 添加/ 新/ 的/ 缺陷/ 模式/ ./ 特别/ 地/ ,/ 经/ 实验/ 表明/ ,/ 与/ 同类/ 工具/ FindBugs/ 、/ PMD/ 、/ Hammurapi/ 相比/ ,/ 在/ 查找/ J2EE/ 和/ JBoss/ 的/ 客户程序/ 中/ 特定/ 于/ 中间件/ 的/ 方法/ 调用/ 序列/ 相关/ 的/ 缺陷/ 时/ ,/ CODA/ 表现/ 出/ 了/ 较/ 明显/ 的/ 优势/ ./ 在/ 未来/ 工作/ 中/ ,/ 我们/ 将/ 提供/ 描述/ 能力/ 更强/ 的/ 缺陷/ 描述/ 语法/ ,/ 并/ 尽可能/ 地/ 探索/ 更加/ 方便/ 易用/ 的/ 描述/ 方式/ 以/ 帮助/ 用户/ 更加/ 快捷/ 地/ 添加/ 缺陷/ 模式/ ./ 此外/ ,/ 我们/ 还/ 将/ 努力/ 优化/ 和/ 改进/ 工具/ 所/ 使用/ 的/ 各种/ 分析/ 技术/ ,/ 因为/ 分析/ 技术/ 的/ 优劣/ 直接/ 决定/ 了/ 工具/ 所/ 产生/ 的/ 缺陷/ 检测/ 结果/ 的/ 可信度/ 和/ 准确度/ ./ 最后/ ,/ 我们/ 还/ 将/ 继续/ 改进/ 规则/ 挖掘/ 器/ 和/ 规则/ 精化/ 器所/ 使用/ 的/ 算法/ ,/ 从而/ 挖掘出/ 更/ 多/ 更/ 准确/ 的/ API/ 使用/ 规则/ 给/ 用户/ ,/ 以/ 进一步/ 减少/ 用户/ 筛选/ 规则/ 的/ 工作量/ ./ 

