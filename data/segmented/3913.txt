Page1TDTMS/ :/ 一种/ 面向/ XML/ 数据/ 的/ 结果/ 子树/ 构建/ 算法/ 周军锋/ 王博田/ 姗姗/ 陈子阳/ 郭景峰/ (/ 燕山大学/ 信息科学/ 与/ 工程学院/ 河北/ 秦皇岛/ 066004/ )/ (/ 河北省/ 计算机/ 虚拟/ 技术/ 与/ 系统集成/ 重点/ 实验室/ 河北/ 秦皇岛/ 066004/ )/ 摘要/ 构建/ 结果/ 子树/ 是/ XML/ 关键字/ 查询/ 得以/ 完成/ 的/ 关键步骤/ 之一/ ./ 针对/ 已有/ 方法/ 求解/ 子树/ 效率/ 低/ 的/ 问题/ ,/ 文中/ 提出/ 一种/ 自顶向下/ 的/ 子树/ 构建/ 算法/ —/ —/ —/ TDTMS/ ./ TDTMS/ 以/ 自顶向下/ 、/ 深度/ 优先/ 的/ 方式/ 求解/ 满足条件/ 的/ 子/ 树根/ 结点/ ,/ 避免/ 了/ 已有/ 方法/ 求解/ SLCA/ 结点/ 时/ 存在/ 的/ 公共/ 祖先/ 重复/ 处理/ 问题/ ./ 对于/ 给定/ 的/ 子/ 树根/ 结点/ ,/ TDTMS/ 以/ 自顶向下/ 、/ 广度/ 优先/ 的/ 方式/ 构建/ 子树/ ,/ 可以/ 在/ 建树/ 过程/ 中/ 快速/ 裁剪/ 无用/ 结点/ ,/ 从而/ 获得/ 了/ 最小/ 的/ 时间/ 和/ 空间/ 复杂度/ ./ 最后/ 通过/ 实验/ 验证/ 了/ TDTMS/ 在/ 时间/ 和/ 空间/ 两/ 方面/ 的/ 性能/ 优势/ ./ 关键词/ 可/ 扩展/ 标记/ 语言/ ;/ 关键字/ 查询/ ;/ 结果/ 子树/ ;/ 自顶向下/ 处理/ 策略/ ;/ 最低/ 最小/ 公共/ 祖先/ 1/ 引言/ 随着/ 可/ 扩展/ 标记/ 语言/ (/ eXtensibleMarkupLan/ -/ guage/ ,/ XML/ )/ 应用领域/ 的/ 不断/ 扩展/ ,/ 以/ XML/ 格式/ 表示/ 和/ 存储/ 的/ 数据量/ 不断/ 增大/ ./ 作为/ 一种/ 简单/ 易用/ 的/ 信息检索/ 机制/ ,/ 基于/ XML/ 数据/ 的/ 关键字/ 检索/ 技术/ 得到/ 了/ 研究者/ 的/ 广泛/ 关注/ [/ 1/ -/ 16/ ]/ ./ 通常/ 情况/ 下/ ,/ 一个/ XML/ 文档/ 可以/ 看成/ 一棵/ 带有/ 结点/ 标注/ 信息/ 的/ 文档/ 树/ T/ ./ 对于/ 给定/ 的/ 关键字/ 查/ Page2/ 询/ Q/ ,/ 每个/ 满足条件/ 的/ 查询/ 结果/ Tv/ 是/ T/ 的/ 一棵/ 子树/ ,/ Tv/ 应/ 包含/ Q/ 的/ 所有/ 关键字/ 且/ Tv/ 的/ 根/ 结点/ v/ 需/ 满足/ 特定/ 的/ 语义/ ,/ 如/ SLCA/ [/ 4/ ,/ 6/ ]/ 、/ ELCA/ [/ 2/ ,/ 9/ ]/ 、/ VL/ -/ CA/ [/ 11/ ]/ 以及/ MLCA/ [/ 5/ ]/ 等/ ./ 假设/ v/ 是/ 满足/ 某种/ 语义/ 的/ 一个/ 结点/ ,/ 现有/ 方法/ 主要/ 考虑/ 3/ 种/ 结果/ 子树/ :/ (/ 1/ )/ 完全/ 子树/ (/ CompleteSubtree/ ,/ CSubtree/ )/ ,/ 指从/ T/ 中/ 抽取/ 的/ 以/ v/ 为/ 根且/ 未经/ 修剪/ 的/ 原始/ 子树/ [/ 2/ ,/ 4/ ]/ ;/ (/ 2/ )/ 路径/ 子树/ (/ PathSubtree/ ,/ PSubtree/ )/ ,/ 指以/ v/ 为根/ ,/ 由/ v/ 到/ 全部/ 关键字/ 结点/ 的/ 路径/ 组成/ 的/ 子树/ [/ 15/ ]/ ;/ (/ 3/ )/ 匹配/ 子树/ (/ MatchedSubtree/ ,/ MSubtree/ )/ ,/ 指以/ v/ 为根/ ,/ 满足/ 一致性/ 和/ 单调/ 性/ 的/ 子树/ [/ 7/ -/ 8/ ]/ ./ 假设/ Su/ 表示/ 以/ u/ 为根/ 的/ 子树中/ 包含/ 的/ Q/ 中/ 的/ 关键字/ 集合/ ,/ 显然/ Su/ / Q/ ./ 直观/ 上/ 看/ ,/ 如果/ 子树/ Tv/ 是/ 匹配/ 子树/ ,/ 则/ 对/ 结点/ v/ 的/ 图/ 1XML/ 文档/ D/ 对应/ 的/ 文档/ 树/ T/ (/ 对于/ 查询/ Q/ =/ {/ CS/ ,/ XML/ ,/ Tom/ ,/ VLDB/ }/ 来说/ ,/ R/ 表示/ 其/ 对应/ 的/ 完全/ 子树/ ,/ R1/ 表示/ 其/ 通过/ 例/ 1/ 可知/ ,/ 完全/ 子树/ R/ 可能/ 包含/ 大量/ 与/ 查询/ 关键字/ 无关/ 的/ 信息/ ,/ 这样/ 的/ 结果/ 对于/ 用户/ 来说/ 意义/ 不/ 大/ ;/ 同样/ ,/ 路径/ 子树/ R1/ 也/ 可能/ 包含/ 很多/ 无用信息/ ./ 例如/ ,/ 对于/ 例/ 1/ 的/ 查询/ Q/ 来说/ ,/ 路径/ 子树/ 是/ 图/ 1/ 中/ 的/ R1/ ,/ 但/ R1/ 中/ 编码/ 为/ 1.2/ ./ 4.10/ ,/ 1.2/ ./ 14.16/ 及/ 1.2/ ./ 14.20/ 的/ 3/ 个/ 结点/ 所/ 表示/ 的/ 3/ 篇文章/ 和/ XML/ 无关/ ,/ 因而/ 会/ 给/ 用户/ 理解/ 查询/ 结果/ 带来/ 额外/ 的/ 干扰/ 因素/ ./ 事实上/ ,/ 从图/ 1/ 可知/ ,/ 对于/ CS/ 实验室/ ,/ 由/ Tom/ 所写/ 并/ 发表/ 在/ VLDB/ 上/ ,/ 且/ 和/ XML/ 相关/ 的/ 文章/ 是/ 编码/ 为/ 1.2/ ./ 4.6/ 的/ 结点/ 所/ 表示/ 的/ 文章/ ./ 由图/ 1/ 可知/ ,/ 对/ 结点/ 1.2/ ./ 3/ ,/ 1.2/ ./ 4/ 和/ 1.2/ ./ 14/ 来说/ ,/ S1/ ./ 2.3/ =/ {/ CS/ }/ ,/ S1/ ./ 2.4/ =/ {/ Tom/ ,/ VLDB/ ,/ XML/ }/ ,/ S1/ ./ 2.14/ =/ {/ VLDB/ }/ ./ 由于/ S1/ ./ 2.14/ / S1/ ./ 2.4/ ,/ 根据/ 关键字/ 包含/ 关系/ ,/ 以/ 1.2/ ./ 14/ 为根/ 的/ 子树/ 应予/ 去除/ ./ 同样/ ,/ 由于/ S1/ ./ 2.4/ ./ 5/ =/ {/ Tom/ }/ ,/ S1/ ./ 2.4/ ./ 6/ =/ {/ Tom/ ,/ VLDB/ ,/ XML/ }/ ,/ S1/ ./ 2.4/ ./ 10/ =/ {/ Tom/ ,/ 任意/ 后代/ 结点/ u/ 来说/ ,/ u/ 不/ 存在/ 任何/ 兄弟/ 结点/ w/ 满足/ Su/ / Sw/ ./ 我们/ 称/ 这/ 一/ 约束条件/ 为/ “/ 关键字/ 包含/ 关系/ ”/ ./ 显然/ ,/ 对于/ 给定/ 的/ 完全/ 子树/ ,/ 可以/ 通过/ 移除/ 不/ 包含/ 关键字/ 的/ 结点/ 得到/ 路径/ 子树/ ./ 类似/ 地/ ,/ 匹配/ 子树/ 可以/ 通过/ 移除/ 路径/ 子树/ 中/ 不/ 满足/ 关键字/ 包含/ 关系/ 的/ 结点/ 得到/ ./ 例/ 1/ ./ 假设/ 用户/ 想/ 从/ 图/ 1/ 所示/ 的/ 文档/ D/ 中/ 查找/ CS/ 实验室/ 由/ Tom/ 所写/ 、/ 且/ 在/ VLDB/ 会议/ 上/ 发表/ 的/ 有关/ XML/ 的/ 文章/ ,/ 则/ 可以/ 使用/ 关键字/ 查询/ Q/ =/ {/ CS/ ,/ XML/ ,/ Tom/ ,/ VLDB/ }/ 检索/ 所/ 需/ 的/ 信息/ ./ 显然/ ,/ 满足条件/ 的/ SLCA/ 结点/ 是/ 图/ 1/ 中/ Dewey/ 编码/ [/ 10/ ]/ 为/ “/ 1.2/ ”/ 的/ “/ lab/ ”/ 结点/ ,/ 完全/ 子树为/ R/ ,/ 路径/ 子树为/ R1/ ,/ 匹配/ 子树为/ R2/ ./ VLDB/ }/ ,/ 可知/ S1/ ./ 2.4/ ./ 5/ / S1/ ./ 24.6/ 且/ S1/ ./ 2.4/ ./ 10/ / S1/ ./ 2.4/ ./ 6/ ./ 根据/ 结点/ 间/ 的/ 关键字/ 包含/ 关系/ ,/ 应移/ 除以/ 结点/ 1.2/ ./ 4.5/ 和/ 1.2/ ./ 4.10/ 为根/ 的/ 子树/ ./ 因此/ ,/ 通过/ 移除/ 不/ 满足/ 关键字/ 包含/ 关系/ 的/ 结点/ ,/ 可以/ 得到/ 包含/ 所有/ 必要/ 信息/ 的/ 匹配/ 子树/ R2/ ./ 与/ 完全/ 子树/ R/ 及/ 路径/ 子树/ R1/ 相比/ ,/ R2/ 更/ 简洁/ 且/ 对/ 查询/ 意图/ 的/ 解释/ 更/ 明确/ ./ 虽然/ XML/ 关键字/ 查询/ 的/ 结果/ 是/ 特定/ 的/ 子树/ ,/ 但/ 大多数/ 现有/ 方法/ [/ 3/ -/ 4/ ,/ 6/ ,/ 9/ ,/ 12/ -/ 14/ ]/ 仅/ 关注/ 如何/ 高效/ 计算/ 满足/ 特定/ 语义/ 的/ 子/ 树根/ 结点/ ,/ 如/ SLCA/ 或者/ ELCA/ 结点/ ,/ 只有/ 文献/ [/ 7/ -/ 8/ ,/ 16/ ]/ 的/ 方法/ 涉及/ 到/ 结果/ 子树/ 的/ 构建/ 问题/ ./ 事实上/ ,/ 构建/ 子树/ 的/ 代价/ 远高于/ 求解/ 子/ 树根/ 结点/ 的/ 代价/ ./ 文献/ [/ 7/ -/ 8/ ]/ 中/ 的/ 方法/ 首先/ 需要/ 扫描/ 倒/ 排表/ 中/ 的/ 所有/ 结点/ 求解/ 满足条件/ 的/ SLCA/ // ELCA/ 结点/ 集/ ;/ 然后/ 基于/ 这些/ 结点/ 重新/ 扫描/ 倒/ 排表/ 中/ 的/ 所有/ 结/ Page3/ 点来/ 构造/ 最初/ 的/ 结果/ 子树集/ ,/ 这些/ 结果/ 子树/ 需要/ 缓存/ 在/ 内存/ 中/ 并/ 根据/ 关键字/ 包含/ 关系/ 逐个/ 进行/ 剪枝/ 来/ 得到/ 最终/ 的/ 子树/ 结果/ ./ 从/ 空间/ 代价/ 来看/ ,/ 这一/ 过程/ 需要/ 缓存/ 大量/ 中间/ 结果/ ;/ 从/ 时间/ 代价/ 来看/ ,/ 算法/ 需要/ 反复/ 扫描/ 倒/ 排表/ 中/ 的/ 结点/ ./ 文献/ [/ 16/ ]/ 提出/ 了/ 一种/ 只/ 需/ 扫描/ 一次/ 倒/ 排表/ 的/ 单/ 阶段/ 子树/ 构建/ 算法/ ./ 虽然/ 该/ 方法/ 无需/ 缓存/ 大量/ 中间/ 结果/ 和/ 多次/ 扫描/ 倒/ 排表/ ,/ 但/ 仍/ 需/ 依次/ 处理/ 倒/ 排表/ 中/ 的/ 所有/ 结点/ ./ 当/ 满足条件/ 的/ 结果/ 数量/ 远/ 小于/ 最短/ 倒/ 排表/ 的/ 长度/ 时/ ,/ 该/ 方法/ 无法/ 利用/ 结点/ 间/ 的/ 位置/ 关系/ 来/ 避免/ 对/ 大量/ 无用/ 结点/ 的/ 处理/ ,/ 因而/ 需要/ 额外/ 的/ 冗余/ 计算/ ./ 例/ 2/ ./ 为了/ 直观/ 理解/ 不同/ 方法/ 在/ 求解/ 子/ 树根/ 结点/ 和/ 构建/ 子树/ 过程/ 中/ 的/ 性能/ 差异/ ,/ 我们/ 实现/ 了/ mergeMatching/ [/ 16/ ]/ 算法/ 和/ 基于/ IL/ [/ 4/ ]/ 的/ MaxMatch/ [/ 8/ ]/ 算法/ ,/ 并/ 在/ 582MBXMark/ 数据/ 集上/ 执行/ 查询/ Q/ =/ {/ female/ ,/ keyword/ ,/ incategory/ ,/ cabbage/ ,/ male/ }/ ./ 表/ 1/ 展示/ 了/ 两种/ 算法/ 计算/ SLCA/ 结点/ 和/ 构建/ 子树/ 的/ 时间/ 比较/ ./ 可以/ 看出/ ,/ 尽管/ IL/ 在/ 求解/ SLCA/ 结果/ 时远/ 比/ mergeMatching/ 算法/ 高效/ ,/ 但/ 和/ MaxMatch/ 算法/ 构建/ 子树/ 所/ 付出/ 的/ 昂贵/ 代价/ 相比/ ,/ 使用/ mergeMatching/ 求解/ SLCA/ 的/ 代价/ 几乎/ 可以/ 忽略不计/ ./ 另一方面/ ,/ 尽管/ mergeMatching/ 的/ 建树/ 过程/ 比/ MaxMatch/ 高效/ ,/ 但/ 建树/ 过程/ 所/ 耗费/ 的/ 时间/ 仍/ 占/ 总/ 时间/ 的/ 66/ %/ ./ 查询/ 算法/ t1/ (/ SLCA/ )/ // mst2/ (/ 子树/ 构建/ )/ // mst1/ // (/ t1/ +/ t2/ )/ // %/ MaxMatch/ -/ IL0/ ./ 5782204.1220/ ./ 03mergeMatching79/ ./ 500152.20034/ ./ 00/ 从例/ 2/ 可知/ ,/ 无论/ 使用/ 哪/ 种/ 方法/ 处理/ 给定/ 的/ 查询/ ,/ 子树/ 构建/ 操作/ 都/ 会/ 耗费/ 大量/ 时间/ ,/ 因而是/ 影响/ 系统/ 性能/ 的/ 关键因素/ 之一/ ./ 查询处理/ 算法/ 应从/ 求解/ 子/ 树根/ 结点/ 和/ 构建/ 子树/ 两个/ 角度/ 来/ 同时/ 进行/ 优化/ ,/ 以便/ 获取/ 最佳/ 的/ 性能/ ./ 本文/ 重点/ 解决/ 基于/ SLCA/ 语义/ 高效/ 构建/ TM/ -/ Subtree/ [/ 16/ ]/ 的/ 问题/ ./ 和/ MSubtree/ 相比/ ,/ 文献/ [/ 16/ ]/ 提出/ 的/ TMSubtree/ 是/ 移除/ 冗余/ 信息/ 的/ MSubtree/ ,/ 从/ 结果/ 表达能力/ 来看/ ,/ TMSubtree/ 更/ 简洁/ ,/ 对/ 查询/ 意图/ 的/ 解释/ 更/ 明确/ (/ 参见/ 第/ 2.3/ 节/ 介绍/ )/ ./ 我们/ 提出/ 一种/ 新/ 的/ 单/ 阶段/ 算法/ TDTMS/ ,/ 该/ 算法/ 以/ 自顶向下/ 的/ 方式/ 求解/ SLCA/ 结点/ ,/ 同时/ 直接/ 构建/ 满足条件/ 的/ TMSubtree/ ./ 和/ 已有/ 方法/ [/ 8/ ,/ 16/ ]/ 相比/ ,/ TDTMS/ 算法/ 同时/ 从/ 求解/ 子/ 树根/ 结点/ 和/ 构建/ 子树/ 两个/ 角度/ 提升/ 系统/ 性能/ ,/ 同时/ 降低/ 了/ 空间/ 复杂度/ ./ 具体来说/ ,/ TDTMS/ 的/ 高效性/ 体现/ 在/ 两/ 方面/ :/ (/ 1/ )/ 更/ 低/ 的/ 时间/ 复杂度/ ./ 求解/ 子/ 树根/ 结点/ 时/ ,/ TDTMS/ 采用/ 自顶向下/ 、/ 深度/ 优先/ 的/ 方式/ 处理/ 倒/ 排表/ 中/ 的/ 结点/ ,/ 可以/ 利用/ 关键字/ 结点/ 的/ 分布/ 特点/ 来/ 避免/ 对/ 无用/ 结点/ 的/ 处理/ ./ 例如/ ,/ 基于/ 图/ 1/ 的/ 文档/ D/ 处理/ 例/ 1/ 的/ 查询/ Q/ 时/ ,/ TDTMS/ 算法/ 可/ 直接/ 跳过/ 对于/ 1.25/ ./ 27.29/ ./ 30/ 、/ 1.25/ ./ 27.29/ ./ 31/ 及/ 1.25/ ./ 27.29/ ./ 32/ 这/ 3/ 个/ 结点/ 的/ 处理/ ,/ 而/ mergeMatching/ 算法/ 需要/ 处理/ 所有/ 关键字/ 结点/ ./ 构建/ 子树时/ ,/ TDTMS/ 采用/ 自顶向下/ 、/ 广度/ 优先/ 的/ 方式/ 构建/ 子树/ ,/ 可以/ 在/ 建树/ 的/ 过程/ 中/ 快速/ 裁剪/ 无用/ 结点/ ./ 例如/ ,/ 基于/ 图/ 1/ 的/ 文档/ D/ 处理/ 例/ 1/ 的/ 查询/ Q/ ,/ 在/ 构建/ 满足条件/ 的/ 子树/ R2/ 时/ ,/ 我们/ 的/ 方法/ 只/ 需/ 扫描/ 编码/ 为/ 1.2/ ./ 14/ 的/ 结点/ ,/ 便/ 可/ 知道/ 该/ 结点/ 的/ 关键字/ 集合/ S1/ ./ 2.14/ =/ {/ VLDB/ }/ ,/ 然后/ 通过/ 结点/ 间/ 关键字/ 集合/ 的/ 包含/ 关系/ 实现/ 对/ 结点/ 1.2/ ./ 14/ 的/ 剪枝/ ,/ 进而/ 避免/ 处理/ 该子/ 树中/ 的/ 其它/ 结点/ ./ 同样/ ,/ 在/ 处理/ 结点/ 1.2/ ./ 4.6/ 时/ ,/ 可以/ 直接/ 实现/ 对/ 结点/ 1.2/ ./ 4.5/ 和/ 结点/ 1.2/ ./ 4.10/ 的/ 剪枝/ ,/ 从而/ 避免/ 进一步/ 处理/ 以/ 1.2/ ./ 4.10/ 为根/ 的/ 子树/ 中/ 的/ 其它/ 结点/ ,/ 而/ mergeMatching/ 算法/ 需要/ 处理/ 子树/ 中/ 的/ 所有/ 结点/ ./ 对于/ 给定/ 的/ 查询/ Q/ =/ {/ k1/ ,/ k2/ ,/ …/ ,/ km/ }/ ,/ 假设/ Li/ 表示/ ki/ (/ i/ ∈/ [/ 1/ ,/ m/ ]/ )/ 对应/ 的/ IDDewey/ 倒/ 排表/ (/ 参见/ 第/ 2.1/ 节/ )/ ,/ LIDi/ 表示/ 由/ Li/ 中/ 不同/ ID/ 值/ 组成/ 的/ 集合/ ,/ |/ Lm/ |/ 表示/ 最长/ 倒/ 排表/ 中/ 包含/ IDDewey/ 编码/ 的/ 数目/ ,/ TDT/ -/ MS/ 的/ 时间/ 复杂度/ 为/ O/ (/ m/ ·/ |/ ∪/ m/ 已有/ 方法/ 的/ 比较/ 和/ 分析/ 参见/ 第/ 2.4/ 节/ )/ ./ (/ 2/ )/ 更/ 低/ 的/ 空间/ 复杂度/ ./ TDTMS/ 算法/ 以/ 自顶向下/ 、/ 广度/ 优先/ 的/ 方式/ 建树/ ,/ 任何/ 时候/ 内存/ 中/ 最/ 多/ 缓存/ 一个/ TMSubtree/ ./ TDTMS/ 的/ 空间/ 复杂度/ 为/ O/ (/ (/ |/ d/ -/ m/ |/ +/ 2/ )/ ·/ m/ !/ )/ ,/ 这里/ d/ 为/ 给定/ XML/ 文档/ 的/ 深度/ ./ 和/ 文献/ [/ 16/ ]/ 最/ 多/ 需要/ 缓存/ d/ 棵子/ 树/ 相比/ ,/ TDTMS/ 只/ 需/ 缓存/ 1/ 棵子/ 树/ ./ 本文/ 第/ 2/ 节对/ 相关/ 工作/ 及/ 背景/ 知识/ 进行/ 介绍/ ;/ 第/ 3/ 节/ 介绍/ 本文/ 算法/ 的/ 基本/ 思想/ ;/ 第/ 4/ 节/ 介绍/ 本文/ 提出/ 的/ TDTMS/ 算法/ ;/ 第/ 5/ 节/ 通过/ 实验/ 对/ 本文/ 算法/ 进行/ 性能/ 验证/ ;/ 最后/ 在/ 第/ 6/ 节/ 总结/ 全文/ ./ 2/ 背景/ 知识/ 和/ 相关/ 工作/ 通常/ ,/ 一个/ XML/ 文档/ 可用/ 带有/ 结点/ 标注/ 信息/ 的/ 树来/ 表示/ ,/ 其中/ 结点/ 表示/ 元素/ 或者/ 属性/ ,/ 边/ 表示/ 节点/ 间/ 的/ 直接/ 嵌套/ 关系/ ./ 如果/ 某个/ 关键字/ k/ 出现/ 在/ 结点/ v/ 的/ 名字/ 、/ 属性/ 或者/ v/ 的/ 文本/ 值中/ ,/ 我们/ 说/ v/ 直接/ 包/ Page4/ 含/ 关键字/ k/ ./ 图/ 1/ 的/ D/ 是/ 一棵/ XML/ 文档/ 树/ 的/ 例子/ ./ 2.1/ 编码方案/ 为了/ 加速/ 查询处理/ ,/ 已有/ 方法/ [/ 2/ ,/ 4/ ,/ 6/ ,/ 12/ ,/ 14/ ,/ 16/ -/ 18/ ]/ 使用/ Dewey/ 编码/ [/ 10/ ]/ 来/ 表示/ 不同/ 结点/ ./ 对于/ 给定/ 的/ 结点/ v/ 来说/ ,/ 其/ Dewey/ 编码/ 由/ 其/ 父亲/ 结点/ 的/ Dewey/ 编码/ 和/ 其/ 本身/ 在/ 兄弟/ 结点/ 中/ 的/ 顺序/ 值/ 组成/ ./ 和/ 文献/ [/ 13/ ]/ 类似/ ,/ 我们/ 给/ 图/ 1/ 中/ 每个/ 结点/ 一个/ 唯一/ 的/ ID/ 值/ ,/ 该值/ 等于/ 以先序/ 遍历/ 方式/ 访问/ D/ 时该/ 结点/ 的/ 访问/ 次序/ ./ 相应/ 的/ ,/ 图/ 1/ 中/ 每个/ 结点/ v/ 的/ Dewey/ 编码/ 由/ 从/ 根/ 结点/ 到/ v/ 的/ 路径/ 上/ 所有/ 结点/ 的/ ID/ 构成/ ,/ 我们/ 称/ 这种/ 由/ 结点/ ID/ 构成/ 的/ Dewey/ 编码/ 为/ IDDewey/ 编码/ [/ 12/ ]/ ./ 注意/ 本文/ 使用/ IDDewey/ 的/ 原因/ 是/ 方便/ 介绍/ 算法/ 时/ 可以/ 使用/ ID/ 来/ 代表/ 一个/ 结点/ ,/ 其它/ Dewey/ 编码/ 的/ 变体/ ,/ 如/ MDC/ [/ 11/ ]/ 、/ JDewey/ [/ 19/ ]/ 等/ ,/ 也/ 可/ 用于/ 本文/ 算法/ ./ 对于/ 给定/ 的/ 两个/ 结点/ u/ 和/ v/ 来说/ ,/ 其/ 位置/ 关系/ 包括/ :/ 文档/ 顺序/ (/ / d/ )/ 、/ 相等/ 关系/ (/ =/ )/ 、/ 祖先/ 后代/ 关系/ (/ / a/ )/ 、/ 父子关系/ (/ / p/ )/ 以及/ 兄弟/ 关系/ ./ u/ / dv/ 表示/ 在/ 文档/ 中/ ,/ u/ 位于/ v/ 的/ 前面/ ,/ u/ / av/ 表示/ u/ 是/ v/ 的/ 祖先/ 结点/ ,/ u/ / pv/ 表示/ u/ 是/ v/ 的/ 父亲/ 结点/ ./ 如果/ u/ 和/ v/ 是/ 同一个/ 结点/ ,/ 则/ u/ =/ v/ ,/ 且/ u/ / dv/ 和/ u/ / av/ 同时/ 成立/ ./ 2.2/ 查询/ 语义/ 为了/ 从/ 给定/ 的/ XML/ 文档/ D/ 中/ 求解/ 满足/ 查询/ Q/ =/ {/ k1/ ,/ k2/ ,/ …/ ,/ km/ }/ 的/ 结果/ ,/ 需要/ 首先/ 为/ 每个/ 关键字/ 构建/ 倒排/ 索引/ ./ 本文/ 使用/ Li/ 表示/ 关键字/ ki/ 对应/ 的/ 倒/ 排表/ ,/ Li/ 由/ 所有/ 直接/ 包含/ ki/ 的/ 结点/ 对应/ 的/ IDDewey/ 编码/ 组成/ ,/ 这些/ 编码/ 按照/ 文档/ 顺序/ 进行/ 组织/ ./ 假定/ S/ =/ {/ v1/ ,/ v2/ ,/ …/ ,/ vn/ }/ 是/ 一组/ 给定/ 的/ 结点/ ,/ lca/ (/ S/ )/ =/ lca/ (/ v1/ ,/ v2/ ,/ …/ ,/ vn/ )/ 表示/ S/ 中/ 所有/ 结点/ 的/ 最低/ 公共/ 祖先/ (/ LowestCommonAncestor/ ,/ LCA/ )/ ./ Q/ 在/ D/ 中/ 的/ 所有/ LCA/ 定义/ 为/ LCA/ (/ Q/ )/ =/ LCA/ (/ L1/ ,/ L2/ ,/ …/ ,/ Lm/ )/ =/ {/ v/ |/ v/ =/ lca/ (/ v1/ ,/ v2/ ,/ …/ ,/ vm/ )/ ,/ vi/ ∈/ Li/ (/ 1/ / i/ / m/ )/ ./ 例如/ ,/ 对查/ Q/ =/ {/ Tom/ ,/ VLDB/ }/ 来说/ ,/ 图/ 1/ 中/ 满足条件/ 的/ LCA/ 结点/ 是/ 1/ ,/ 1.2/ ,/ 1.2/ ./ 4/ ,/ 1.2/ ./ 4.6/ ,/ 1.2/ ./ 4.10/ ,/ 1.25/ ./ 27.29/ ./ 和/ LCA/ 相比/ ,/ SLCA/ (/ SmallestLCA/ )/ [/ 4/ ,/ 6/ ]/ 集合/ 是/ LCA/ (/ Q/ )/ 的/ 一个/ 子集/ ,/ 其中/ 任意/ 一个/ 元素/ 都/ 不是/ 其它/ LCA/ 结点/ 的/ 祖先/ 结点/ ,/ 其/ 形式化/ 定义/ 为/ SLCA/ (/ Q/ )/ =/ {/ v/ |/ v/ ∈/ LCA/ (/ Q/ )/ 并且/ / // v/ ∈/ LCA/ (/ Q/ )/ ,/ 使得/ v/ / av/ }/ ./ 对于/ 图/ 1/ 的/ XML/ 文档/ D/ 和/ 查询/ Q/ =/ {/ Tom/ ,/ VLDB/ }/ 来说/ ,/ 尽管/ 1/ ,/ 1.2/ ,/ 1.2/ ./ 4/ 是/ LCA/ 结点/ ,/ 由于/ 它们/ 都/ 是/ 1.2/ ./ 4.6/ 的/ 祖先/ 结点/ ,/ 因而/ 不是/ SLCA/ 结点/ ./ 满足条件/ 的/ SLCA/ 结点/ 是/ 1.2/ ./ 4.6/ ,/ 1.2/ ./ 4.10/ ,/ 1.25/ ./ 27.29/ ./ 2.3/ 最/ 紧致/ 匹配/ 子树/ TMSubtree/ 对于/ 给定/ 的/ XML/ 文档/ 树/ T/ 和/ 关键字/ 查询/ Q/ ,/ 假定/ Sv/ / Q/ 是/ 在/ 以/ v/ 为根/ 的/ 子树中/ 出现/ 的/ 关键字/ 集合/ ,/ Sv/ ≠/ / ,/ 则/ 子树/ Tv/ 是/ 一个/ 最/ 紧致/ 匹配/ 子树/ (/ TightestMatchedSubtree/ ,/ TMSubtree/ )/ 当且/ 仅/ 当/ Tv/ 的/ 根/ 结点/ v/ 是/ 一个/ SLCA/ 结点/ ,/ 并且/ 对于/ Tv/ 中/ 的/ 每个/ 结点/ u/ 来说/ ,/ 不/ 存在/ 另/ 一个/ 兄弟/ 结点/ w/ 满足/ Su/ / Sw/ ./ 当/ 多个/ 兄弟/ 结点/ 的/ 关键字/ 集合/ 相同/ 时/ ,/ 任意/ 保留/ 其中/ 之一/ 即可/ ./ 直观/ 上/ 看/ ,/ TMSubtree/ 就是/ 移除/ 冗余/ 信息/ 的/ MSubtree/ ,/ 这里/ 的/ 冗余/ 信息/ 指/ 具有/ 相同/ 关键字/ 集合/ 的/ 兄弟/ 结点/ ./ 对于/ 一个/ MSubtree/ 来说/ ,/ 如果/ 其中/ 每个/ 结点/ 都/ 与其/ 兄弟/ 结点/ 的/ 关键字/ 集合/ 不同/ ,/ 则/ 该/ MSubtree/ 是/ 一个/ TMSubtree/ ./ 例如/ ,/ 对于/ 图/ 1/ 的/ R2/ 而言/ ,/ 由于/ 不/ 存在/ 具有/ 相同/ 关键字/ 集合/ 的/ 兄弟/ 结点/ ,/ R2/ 也/ 是/ 一个/ TMSubtree/ ./ 对于/ 给定/ 查询/ Q/ =/ {/ k1/ ,/ k2/ ,/ …/ ,/ km/ }/ 和/ 任意/ 一个/ TMSubtreeTv/ 来说/ ,/ 文献/ [/ 16/ ]/ 通过/ 证明/ 给出/ 了/ Tv/ 所/ 包含/ 的/ 结点/ 数目/ 上限/ N/ (/ Tv/ )/ ,/ 如式/ (/ 1/ )/ 所示/ ./ 2.4/ 相关/ 算法/ 及/ 分析/ 对于/ 一个/ 给定/ 的/ 查询/ Q/ =/ {/ k1/ ,/ k2/ ,/ …/ ,/ km/ }/ 和/ XML/ 文档/ D/ ,/ MaxMatch/ 算法/ [/ 8/ ]/ 分/ 3/ 步/ 计算/ 匹配/ 子树/ :/ (/ 1/ )/ 计算/ 满足条件/ 的/ SLCA/ 结点/ 集/ ./ 这/ 一步/ 可/ 通过/ 调用/ 任何/ 已有/ 的/ SLCA/ 算法/ 来/ 完成/ ,/ 如/ Stack/ [/ 4/ ]/ 、/ IL/ [/ 4/ ]/ 、/ IMS/ [/ 6/ ]/ 、/ HS/ [/ 12/ ]/ 、/ LPSLCA/ [/ 14/ ]/ 及/ FwdSLCA/ [/ 13/ ]/ 算法/ ./ 完成/ 这/ 一步/ 需要/ 处理/ 一个/ 或者/ 多个/ 倒/ 排表/ 中/ 的/ 所有/ 结点/ 编码/ ;/ (/ 2/ )/ 求解/ 每个/ SLCA/ 结点/ 对应/ 的/ 关键字/ 结点/ 集/ ,/ 即/ 使用/ 每个/ SLCA/ 结点/ v/ 在/ 每个/ 倒/ 排表/ 中/ 找/ v/ 的/ 后代/ 结点/ ;/ (/ 3/ )/ 构建/ 满足条件/ 的/ 匹配/ 子树/ ./ 可以/ 看出/ ,/ MaxMatch/ 算法/ 无论/ 在/ 时间/ 还是/ 空间/ 方面/ 都/ 存在/ 问题/ ./ 从/ 空间/ 复杂度/ 来看/ ,/ MaxMatch/ 算法/ 需要/ 在/ 第/ 1/ 步/ 和/ 第/ 2/ 步/ 缓存/ 所有/ 的/ 中间/ 结果/ ,/ 其/ 空间/ 复杂度/ 为/ O/ (/ d/ ∑/ mMaxMatch/ 算法/ 需要/ 扫描/ 3/ 次/ 倒/ 排表/ 中/ 的/ 结点/ ,/ 无论/ 其/ 在/ 第/ 1/ 步/ 使用/ 多么/ 高效/ 的/ 算法/ ,/ MaxMatch/ 算法/ 都/ 需要/ 在/ 第/ 2/ 步/ 重新处理/ 所有/ 的/ 结点/ 编码/ 并/ 将/ 其/ 和/ 对应/ 的/ SLCA/ 结点/ 进行/ 聚类/ ,/ 这/ 一步/ 的/ 时间/ 复杂度/ 为/ O/ (/ d/ ·/ m/ ·/ (/ ∑/ m/ 并/ 进行/ 裁剪/ ,/ 这/ 一步/ 的/ 时间/ 复杂度/ 为/ O/ (/ min/ (/ |/ D/ |/ ,/ Page5i/ =/ 1d/ ·/ (/ ∑/ m/ 兄弟/ 结点/ 间/ 关键字/ 包含/ 关系/ 的/ 代价/ ./ 假设/ Max/ -/ Match/ 算法/ 第/ 1/ 步/ 的/ 代价/ 小于/ 第/ 2/ 步/ 的/ 代价/ ,/ 其/ 时间/ 复杂度/ 为/ O/ (/ max/ (/ min/ (/ |/ D/ |/ ,/ d/ ·/ (/ ∑/ m2m/ )/ ,/ d/ ·/ m/ ·/ (/ ∑/ m/ 考虑/ 到/ MaxMatch/ 算法/ 存在/ 的/ 问题/ ,/ 文献/ [/ 16/ ]/ 提出/ 的/ mergeMatching/ 算法/ 可以/ 在/ 仅/ 扫描/ 一遍/ 结点/ 编码/ 的/ 同时/ 构建/ 满足条件/ 的/ 子树/ ./ 和/ MaxMatch/ 算法/ 相比/ ,/ 其/ 优势/ 体现/ 在/ 两个/ 方面/ :/ (/ 1/ )/ 由于/ 在/ 任何/ 时候/ ,/ 内存/ 中/ 最/ 多/ 缓存/ d/ 个/ TMSubtree/ ,/ 其/ 空间/ 复杂度/ 降为/ O/ (/ d/ ·/ max/ (/ 2m/ !/ ,/ (/ d/ -/ m/ +/ 2/ )/ m/ !/ )/ )/ ./ (/ 2/ )/ 由于/ merge/ -/ Matching/ 算法/ 在/ 一次性/ 扫描/ 倒/ 排表/ 的/ 同时/ 构建/ 子树/ ,/ 其/ 时间/ 复杂度/ 为/ O/ (/ d/ ·/ m2/ ·/ ∑/ m/ 其中/ 代价/ O/ (/ d/ ·/ m/ ·/ ∑/ m/ 排表/ 中/ 的/ 结点/ 编码/ ,/ 对于/ 每个/ 结点/ ,/ 内存/ 中/ 最/ 多/ 缓存/ m2/ 个/ 兄弟/ 结点/ ,/ 检测/ 其/ 关键字/ 集合/ 包含/ 关系/ 的/ 代价/ 为/ O/ (/ m2/ )/ ./ 虽然/ mergeMatching/ 算法/ 无需/ 缓存/ 大量/ 中间/ 结果/ 和/ 多次/ 扫描/ 倒/ 排表/ ,/ 但/ 仍/ 需/ 依次/ 处理/ 倒/ 排表/ 中/ 的/ 所有/ 结点/ ./ 实际/ 应用/ 中/ ,/ 当/ 满足条件/ 的/ 结果/ 数量/ 远/ 小于/ 最短/ 倒/ 排表/ 的/ 长度/ 时/ ,/ 该/ 方法/ 无法/ 利用/ 结点/ 间/ 的/ 位置/ 关系/ 来/ 避免/ 对于/ 大量/ 无用/ 结点/ 的/ 处理/ ,/ 图/ 2/ 查询/ Q/ =/ {/ CS/ ,/ XML/ ,/ Tom/ ,/ VLDB/ }/ 相对/ 于图/ 1/ 中/ XML/ 文档/ D/ 的/ 倒/ 排表/ 及/ KPTree/ 定义/ 1/ ./ 关键字/ 路径/ 树/ (/ KeywordPathTree/ ,/ KPTree/ )/ ./ 对于/ 给定/ 的/ 关键字/ ki/ 来说/ ,/ 其/ KPTree/ 是/ 因而/ 需要/ 额外/ 的/ 冗余/ 计算/ ./ 表/ 2/ 列举/ 了/ 本文/ 所用/ 的/ 重要/ 符号/ 及其/ 意义/ ./ 符号/ Li/ 关键字/ ki/ 对应/ 的/ 倒/ 排表/ LIDiLi/ 中/ 不同/ ID/ 值/ 组成/ 的/ 倒/ 排表/ ,/ 即/ 文献/ [/ 13/ ]/ 中/ 的/ IDListm/ 查询/ Q/ 包含/ 的/ 关键字/ 数目/ d/ 给定/ XML/ 文档/ 的/ 最大/ 深度/ u/ ,/ v/ ,/ w/ 给定/ XML/ 文档/ 树中/ 的/ 结点/ Sv/ 以/ 结点/ v/ 为根/ 的/ 子树中/ 包含/ 的/ Q/ 中/ 的/ 关键字/ 集合/ TKPkiki/ 对应/ 的/ 关键字/ 路径/ 树/ Tv/ 以/ v/ 为根/ 的/ 子树/ 3/ 算法/ 基本/ 思想/ 本文/ 使用/ 基于/ 结点/ ID/ 的/ IDDewey/ 编码/ ./ 在/ 图/ 1/ 中/ ,/ XML/ 文档/ 树/ D/ 中/ 每个/ 结点/ 的/ IDDewey/ 编码/ 位于/ 该/ 结点/ 的/ 下方/ ./ 因而/ ,/ 图/ 1/ 中/ 的/ 每个/ 结点/ 既/ 可/ 由/ 其/ ID/ 表示/ ,/ 也/ 可/ 由/ 其/ IDDewey/ 编码/ 来/ 表示/ ./ 例如/ ,/ 图/ 1/ 中/ 最/ 左边/ 的/ person/ 结点/ 既/ 可以/ 称为/ 结点/ 4/ ,/ 也/ 可以/ 称为/ 结点/ 1.2/ ./ 4/ ./ 基于/ IDDewey/ 编码/ ,/ 我们/ 为/ 每个/ 关键字/ ki/ 构建/ 了/ 倒排/ 索引/ Li/ ,/ 该/ 倒/ 排表/ 由/ 所有/ 直接/ 包含/ ki/ 的/ 关键字/ 结点/ 的/ IDDewey/ 编码/ 构成/ ,/ 编码/ 间/ 按照/ 文档/ 顺序/ 进行/ 组织/ ./ 例如/ ,/ 对于/ 例/ 1/ 的/ 查询/ Q/ =/ {/ CS/ ,/ XML/ ,/ Tom/ ,/ VLDB/ }/ ,/ 其/ 所有/ 关键字/ 对应/ 的/ 倒/ 排表/ 如图/ 2/ 中/ 的/ LCS/ 、/ LXML/ 、/ LTom/ 以及/ LVLDB/ 所示/ ./ 和/ XML/ 文档/ 树/ 同根/ ,/ 以/ Li/ 中/ 所有/ 结点/ 为/ 叶子/ 构成/ 的/ 子树/ ,/ 用/ TKPki/ 表示/ ./ Page6/ 例如/ ,/ 对于/ 查询/ Q/ =/ {/ CS/ ,/ XML/ ,/ Tom/ ,/ VLDB/ }/ 和/ 图/ 1/ 的/ 文档/ D/ ,/ Q/ 中/ 所有/ 关键字/ 对应/ 的/ KPTree/ 如图/ 2/ 中/ 的/ TKP/ 第/ 1/ 节/ 介绍/ 的/ “/ 路径/ 树/ ”/ 指/ 结果/ 树/ 和/ 这里/ 的/ “/ 关键字/ 路径/ 树/ ”/ 不同/ ./ 定义/ 2/ ./ 查询/ 路径/ 树/ (/ QueryPathTree/ ,/ QPTree/ )/ ./ 对于/ 给定/ 的/ 查询/ Q/ =/ {/ k1/ ,/ k2/ ,/ …/ ,/ km/ }/ ,/ Q/ 的/ QPTree/ 是/ 由/ 其/ 所有/ 关键字/ 的/ KPTree/ 合并/ 在/ 一起/ 构成/ 的/ 子树/ ,/ 其中/ 相同/ 结点/ 只/ 保留/ 一次/ ./ 例如/ ,/ 对于/ 查询/ Q/ =/ {/ CS/ ,/ XML/ ,/ Tom/ ,/ VLDB/ }/ 和/ 图/ 1/ 的/ 文档/ D/ ,/ Q/ 的/ QPTree/ 可以/ 通过/ 合并/ 其/ 4/ 个/ 关键字/ 的/ KPTree/ 得到/ ,/ 如图/ 3/ 所示/ ./ 图/ 3/ 查询/ Q/ =/ {/ CS/ ,/ XML/ ,/ Tom/ ,/ VLDB/ }/ 相对/ 于图/ 1/ 中/ XML/ 文档/ D/ 的/ QPTree/ 本文/ 算法/ 的/ 基本/ 思想/ 是/ :/ 对于/ 给定/ 的/ 查询/ Q/ 和/ XML/ 文档/ D/ ,/ 以/ 自顶向下/ 、/ 深度/ 优先/ 的/ 方式/ 访问/ Q/ 的/ QPTree/ ,/ 并/ 在/ 遍历/ 的/ 过程/ 中/ 检测/ 每个/ 被/ 访问/ 的/ 结点/ 是否/ 为/ SLCA/ 结点/ ./ 每当/ 找到/ 一个/ SLCA/ 结点/ 后/ ,/ 以/ 自顶向下/ 、/ 广度/ 优先/ 的/ 方式/ 构建/ 结果/ 子树/ 的/ 每层/ 结点/ ,/ 同时/ 检测/ 兄弟/ 结点/ 间/ 的/ 关键字/ 包含/ 关系/ ,/ 以便/ 及时/ 剪枝/ ,/ 实现/ 子树/ 的/ 快速/ 构建/ ./ 算法/ 名称/ 为/ TDTMS/ ,/ 其中/ TD/ 表示/ “/ top/ -/ down/ ”/ ,/ TMS/ 表示/ TMSubtree/ ,/ 合/ 起来/ 表示/ 以/ 自顶向下/ 的/ 方式/ 求解/ 所有/ TMSubtree/ ./ 对/ SLCA/ 结点/ 的/ 检测/ 问题/ ,/ 基本/ 思想/ 为/ 当以/ 自顶向下/ 、/ 深度/ 优先/ 的/ 方式/ 访问/ QPTree/ 的/ 结点/ 时/ ,/ 对于/ 遇到/ 的/ 每个/ 结点/ v/ ,/ 检测/ 以/ v/ 为根/ 的/ 子树/ Tv/ 是否/ 包含/ 所有/ 关键字/ ./ 若/ 是/ ,/ 则/ 说明/ Tv/ 中/ 至少/ 包含/ 一个/ SLCA/ 结点/ ./ 在/ 删除/ Tv/ 的/ 根/ 结点/ v/ 后/ ,/ 我们/ 可以/ 得到/ Tv/ 的/ 子树/ 森林/ FTv/ =/ {/ T1/ ,/ T2/ ,/ …/ ,/ Tn/ }/ ,/ 其中/ 每个/ 子树/ Ti/ (/ i/ ∈/ [/ 1/ ,/ n/ ]/ )/ 的/ 根/ 结点/ 是/ v/ 的/ 孩子/ 结点/ ./ 基于/ FTv/ ,/ 我们/ 检测/ 每个/ 子树/ 是否/ 包含/ 所有/ 关键字/ ./ 如果/ 不/ 存在/ 包含/ 所有/ 关键字/ 的/ 子树/ ,/ 则/ 表示/ Tv/ 的/ 根/ 结点/ v/ 是/ 一个/ SLCA/ 结点/ ;/ 否则/ ,/ 对于/ FTv/ 中/ 每个/ 包含/ 所有/ 关键字/ 的/ 子树/ ,/ 我们/ 的/ 方法/ 递归计算/ 其/ 对应/ 的/ 子树/ 森林/ ,/ 直到/ 子树/ 森林/ 中/ 不/ 存在/ 包含/ 所有/ 关键字/ 的/ 子树/ 为止/ ./ 这种/ 处理/ 策略/ 在/ 得到/ 每个/ SLCA/ 结点/ v/ 时/ ,/ 就/ 已经/ 知道/ 以/ v/ 为根/ 的/ 子树/ 中/ 所/ 包含/ 的/ 关键字/ 结点/ ,/ 从而/ 避免/ 了/ 使用/ SLCA/ 结点/ 去/ 倒/ 排表/ 中/ 查找/ 关键字/ 结点/ 的/ 代价/ ./ 例/ 3/ ./ 考虑/ 在/ 图/ 1/ 的/ XML/ 文档/ D/ 上/ 处理/ 查询/ Q/ =/ {/ CS/ ,/ XML/ ,/ Tom/ ,/ VLDB/ }/ ./ 对于/ 图/ 3/ 的/ QPTree/ ,/ 由于/ 结点/ 1/ 是/ 根/ 结点/ ,/ 因而/ 以/ 结点/ 1/ 为根/ 的/ 子树/ 肯定/ 包含/ 所有/ 关键字/ ,/ 我们/ 的/ 方法/ 首先/ 访问/ 结点/ 2/ ./ 当/ 发现/ 结点/ 2/ 也/ 包含/ 所有/ 关键字/ 后/ ,/ 我们/ 的/ 方法/ 继续/ 访问/ 结点/ 3/ ,/ 由于/ 结点/ 3/ 不/ 包含/ 所有/ 关键字/ ,/ 且/ 不/ 存在/ 其它/ 结点/ 包含/ 关键字/ “/ CS/ ”/ ,/ 则/ 可知/ 结点/ 2/ 是/ 一个/ SLCA/ 结点/ ./ 当/ 构建/ 以/ 结点/ 2/ 为根/ 的/ TMSubtree/ 时/ ,/ 我们/ 的/ 方法/ 以/ 自顶向下/ 、/ 广度/ 优先/ 的/ 方式/ 建树/ 并/ 检测/ 兄弟/ 结点/ 间/ 的/ 关键字/ 包含/ 关系/ ./ 对于/ 当前/ 的/ SLCA/ 结点/ ,/ 我们/ 的/ 方法/ 首先/ 构建/ 结点/ 3/ ./ 由于/ 结点/ 4/ 的/ 关键字/ 集合/ 为/ S4/ =/ {/ Tom/ ,/ XML/ ,/ VLDB/ }/ ,/ 且/ S3/ =/ {/ CS/ }/ / \/ S4/ ,/ 我们/ 的/ 方法/ 进而/ 构建/ 结点/ 4/ ./ 接下来/ ,/ 由于/ 结点/ 14/ 的/ 关键字/ 集合/ 为/ S14/ =/ {/ VLDB/ }/ / S4/ ,/ 我们/ 的/ 方法/ 直接/ 跳过/ 以/ 结点/ 14/ 为根/ 的/ 子树/ 中/ 的/ 所有/ 结点/ ./ 接下来/ 的/ 子树/ 构建/ 过程/ 类似/ ,/ 在/ 处理/ 下/ 一层/ 结点/ 时/ 通过/ 检测/ 兄弟/ 结点/ 间/ 的/ 关键字/ 包含/ 关系/ ,/ 可以/ 避免/ 处理/ 以/ 结点/ 10/ 为根/ 的/ 子树/ 中/ 的/ 所有/ 结点/ ./ 最后/ ,/ 当/ 构建/ 完以/ 结点/ 2/ 为根/ 的/ TMSub/ -/ tree/ 后/ ,/ 由于/ 已经/ 处理/ 完/ 关键字/ “/ CS/ ”/ 对应/ 的/ 倒/ 排表/ 中/ 的/ 所有/ 结点/ ,/ 我们/ 的/ 方法/ 直接/ 结束/ ,/ 从而/ 避免/ 处理/ 以/ 结点/ 25/ 为根/ 的/ 子树/ 中/ 的/ 所有/ 结点/ ./ 4TDTMS/ 算法/ 对于/ 给定/ 的/ 查询/ Q/ =/ {/ k1/ ,/ k2/ ,/ …/ ,/ km/ }/ ,/ 某个/ 倒/ 排表/ 为空/ 或者/ Q/ 仅/ 包含/ 一个/ 关键字/ 的/ 情况/ 很/ 容易/ 处理/ ,/ 本文/ 不予/ 讨论/ ./ 算法/ 运行/ 过程/ 中/ ,/ 我们/ 为/ 每个/ 倒/ 排表/ Li/ (/ i/ ∈/ [/ 1/ ,/ m/ ]/ )/ 关联/ 一个/ 指向/ 某个/ 编码/ 的/ 指针/ Ci/ ./ 后面/ 的/ 讨论/ 中/ ,/ Ci/ 可以/ 代表/ 其/ 所指/ 的/ 编码/ 或者/ 相应/ 的/ 结点/ ,/ pos/ (/ Ci/ )/ 用于/ 表示/ Ci/ 在/ Li/ 中/ 的/ 位置/ ./ 假设/ l/ 是/ Li/ 中/ 的/ 第/ x/ 个/ 编码/ ,/ 且/ Ci/ 指向/ l/ ,/ 则/ pos/ (/ Ci/ )/ =/ x/ ,/ l/ =/ Ci/ =/ Li/ [/ x/ ]/ ./ 对/ l/ 来说/ ,/ l/ 中/ 第/ j/ 个/ 整数/ 代表/ 了/ XML/ 文档/ 树中/ 第/ j/ 层/ 的/ 一个/ 结点/ v/ 的/ ID/ 值/ idv/ ,/ 因而/ 有/ idv/ =/ l/ [/ j/ ]/ =/ Li/ [/ x/ ]/ [/ j/ ]/ ./ 后续/ 讨论/ 中/ ,/ 我们/ 用/ Li/ [/ s/ ,/ e/ ]/ 表示/ Page7Li/ 中/ 从/ 第/ s/ 到/ 第/ e/ 个/ 编码/ 组成/ 的/ 子/ 倒/ 排表/ ,/ |/ l/ |/ 表示/ l/ 的/ 长度/ ,/ 即/ 其中/ 包含/ 的/ 结点/ ID/ 的/ 数目/ ./ 对于/ 给定/ 的/ 查询/ Q/ 及/ 相应/ 的/ QPTree/ 中/ 的/ 每个/ 结点/ v/ ,/ 我们/ 将/ 所有/ 在/ Tv/ 中/ 出现/ 、/ 且/ 属于/ Li/ 的/ 所有/ 关键字/ 结点/ 用/ Tv/ / Li/ 表示/ ./ Tv/ / lv/ 表示/ v/ 的/ IDDewey/ 编码/ ./ 函数/ binSearch/ (/ Tv/ / Li/ ,/ id/ ,/ level/ )/ 用于/ 从/ Tv/ / Li/ 的/ 第/ level/ 层中/ 找到/ 第/ 1/ 个/ 不/ 小于/ id/ 的/ 值/ 对应/ 的/ 编码/ 在/ Li/ 中/ 的/ 位置/ ,/ 并/ 将/ 光标/ 移动/ 到/ 该/ 位置/ ./ 对/ 隶属于/ 当前/ 子树/ Tv/ 的/ 所有/ 倒/ 排表/ 来说/ ,/ 函数/ eof/ (/ Tv/ )/ 用于/ 检测/ Tv/ 的/ 倒/ 排表/ 中/ 是否/ 存在/ 所有/ 结点/ 已/ 被/ 处理完毕/ 的/ 倒/ 排表/ ./ 若/ 存在/ ,/ 则/ eof/ (/ Tv/ )/ 返回/ TRUE/ ,/ 否则/ 返回/ FALSE/ ./ 4.1/ 算法/ 描述/ 如/ 算法/ 1/ 所示/ ,/ 我们/ 首先/ 在/ 第/ 2/ 行将/ Tv/ 的/ 根/ 结点/ 设为/ 1/ ,/ 并/ 在/ 第/ 3/ 行将/ 所有/ 倒/ 排表/ 中/ 的/ 关键字/ 结点/ 作为/ Tv/ 的/ 叶子/ 结点/ ,/ 即/ Tv/ 的/ 初始状态/ 为/ Q/ 的/ QPTree/ ./ 在/ 第/ 4/ 行/ 调用/ processSubTree/ (/ Tv/ )/ 以/ 自顶向下/ 、/ 深度/ 优先/ 的/ 方式/ 递归/ 处理/ Q/ 的/ QPTree/ 中/ 的/ 结点/ ./ 算法/ 1/ ./ TDTMS/ (/ Q/ )/ ./ 1/ ./ // / Q/ =/ {/ k1/ ,/ …/ ,/ km/ }/ ,/ 0/ </ |/ L1/ |/ / |/ L2/ |/ / …/ / |/ Lm/ |/ / // 2/ ./ Tv/ / lv/ ←/ 13/ ./ Tv/ / [/ L1/ ,/ L2/ ,/ …/ ,/ Lm/ ]/ ←/ [/ L1/ ,/ L2/ ,/ …/ ,/ Lm/ ]/ 4/ ./ processSubTree/ (/ Tv/ )/ 5/ ./ ProcedureprocessSubTree/ (/ Tv/ )/ 6/ ./ FOREACH/ (/ i/ ∈/ [/ 1/ ,/ m/ ]/ )/ DO7/ ./ IF/ (/ |/ Tv/ / Li/ [/ 1/ ]/ |/ >/ |/ Tv/ / lv/ |/ )/ THENCi/ ←/ Tv/ / Li/ [/ 1/ ]/ 8/ ./ ELSECi/ ←/ Tv/ / Li/ [/ 2/ ]/ 9/ ./ min/ ←/ minargi/ {/ |/ Tv/ / Li/ |/ }/ 10/ ./ isSLCA/ ←/ TRUE11/ ./ WHILE/ (/ / eof/ (/ Tv/ )/ )/ DO12/ ./ chLevel/ ←/ |/ Tv/ / lv/ |/ +/ 113/ ./ idch/ ←/ Cmin/ [/ chLevel/ ]/ 14/ ./ {/ isCA/ ,/ Tch/ }/ ←/ getNextTree/ (/ Tv/ ,/ idch/ ,/ min/ ,/ chLevel/ )/ 15/ ./ IF/ (/ isCA/ =/ TRUE/ )/ THEN16/ ./ processSubTree/ (/ Tch/ )/ 17/ ./ isSLCA/ ←/ FALSE18/ ./ ELSE19/ ./ binSearch/ (/ Tv/ / Lmin/ ,/ idch/ +/ 1/ ,/ chLevel/ )/ 20/ ./ IF/ (/ isSLCA/ =/ TRUE/ )/ THEN21/ ./ tTMS/ ←/ generateTMSubtree/ (/ Tv/ )/ 22/ ./ outputtTMSasaTMSubtree23/ ./ FunctiongetNextTree/ (/ Tv/ ,/ idch/ ,/ min/ ,/ chLevel/ )/ 24/ ./ isCA/ ←/ TRUE25/ ./ FOREACH/ (/ j/ ∈/ [/ 1/ ,/ m/ ]/ ,/ j/ ≠/ min/ )/ DO26/ ./ binSearch/ (/ Tv/ / Lj/ ,/ idch/ ,/ chLevel/ )/ 27/ ./ IF/ (/ Cj/ [/ chLevel/ ]/ >/ idch/ )/ THEN28/ ./ isCA/ ←/ FALSE/ ;/ BREAK29/ ./ IF/ (/ isCA/ =/ TRUE/ )/ THEN30/ ./ Tch/ ←/ getSubTree/ (/ Tv/ ,/ idch/ ,/ chLevel/ )/ 31/ ./ RETURN/ {/ TRUE/ ,/ Tch/ }/ 32/ ./ RETURN/ {/ FALSE/ ,/ NULL/ }/ 33/ ./ FunctiongetSubTree/ (/ Tv/ ,/ idch/ ,/ chLevel/ )/ 34/ ./ FOREACH/ (/ i/ ∈/ [/ 1/ ,/ m/ ]/ )/ DO35/ ./ si/ ←/ pos/ (/ Ci/ )/ 36/ ./ binSearch/ (/ Tv/ / Li/ ,/ idch/ +/ 1/ ,/ chLevel/ )/ 37/ ./ Tch/ / Li/ ←/ Li/ [/ si/ ,/ pos/ (/ Ci/ )/ -/ 1/ ]/ 38/ ./ Tch/ / lch/ ←/ Tv/ / lv/ / idch39/ ./ RETURNTch/ 对于/ 某个/ 包含/ 所有/ 关键字/ 的/ 子树/ Tv/ ,/ 过程/ pro/ -/ cessSubTree/ (/ Tv/ )/ 首先/ 在/ 第/ 6/ ~/ 8/ 行/ 设定/ 每个/ 光标/ 在/ 相应/ 倒/ 排表/ 中/ 的/ 位置/ ,/ 第/ 9/ 行/ 得到/ Tv/ 的/ 最/ 短/ 倒/ 排表/ ,/ 第/ 10/ 行用/ isSLCA/ 标识/ v/ 是否/ 为/ SLCA/ 结点/ ./ 对于/ Tv/ 来说/ ,/ 只要/ 不/ 存在/ 某个/ 倒/ 排表/ 的/ 全部/ 结点/ 被/ 处理/ 完/ (/ 第/ 11/ 行值/ 为/ TRUE/ )/ ,/ 在/ 12/ ~/ 19/ 行/ ,/ 首先/ 从/ Tv/ / Lmin/ 的/ 第/ chLevel/ 层/ (/ 第/ 12/ 行/ )/ 得到/ v/ 的/ 一个/ 孩子/ 结点/ idch/ (/ 第/ 13/ 行/ )/ ,/ 并/ 在/ 第/ 14/ 行/ 判断/ 以/ idch/ 为根/ 的/ 子树/ 是否/ 包含/ 所有/ 关键字/ 结点/ ./ 如果/ 包含/ (/ 第/ 15/ 行值/ 为/ TRUE/ )/ ,/ 则/ 在/ 第/ 16/ 行/ 处理/ 以/ idch/ 为根/ 的/ 子树/ Tch/ ,/ 并/ 在/ 第/ 17/ 行将/ isSLCA/ 置/ 为/ FALSE/ ,/ 表示/ v/ 不是/ SLCA/ 结点/ ./ 如果/ 第/ 15/ 行值/ 为/ FALSE/ ,/ 表示/ 以/ idch/ 为根/ 的/ 子树/ 不/ 包含/ 所有/ 的/ 关键字/ 结点/ ,/ 因而/ 在/ 第/ 19/ 行/ ,/ 我们/ 在/ Tv/ / Lmin/ 的/ 第/ chLevel/ 层/ 找/ 下/ 一个/ 不同/ 的/ 整数/ (/ 即/ v/ 的/ 下/ 一个/ 被/ 处理/ 的/ 孩子/ 结点/ )/ ./ 当/ Tv/ 中/ 存在/ 某个/ 倒/ 排表/ 的/ 所有/ 结点/ 已/ 被/ 处理完毕/ 后/ ,/ 如果/ isSLCA/ 仍然/ 等于/ TRUE/ (/ 第/ 20/ 行/ )/ ,/ 说明/ 以/ v/ 的/ 任意/ 孩子/ 结点/ 为根/ 的/ 子树/ 不/ 包含/ 所有/ 关键字/ 结点/ ,/ 因而/ 我们/ 在/ 第/ 21/ 行/ 构建/ 以/ v/ 为根/ 的/ TMSub/ -/ tree/ ,/ 并/ 在/ 第/ 22/ 行将/ 其/ 返回/ ./ 算法/ 1/ 在/ 第/ 14/ 行/ 调用/ getNextTree/ (/ Tv/ ,/ idch/ ,/ min/ ,/ chLevel/ )/ 来/ 判断/ 以/ idch/ 为根/ 的/ 子树/ 是否/ 包含/ 所有/ 关键字/ 结点/ ,/ 若/ 是/ 则/ 得到/ 该子/ 树/ 的/ 统计/ 信息/ ./ 其/ 处理/ 思路/ 如下/ ,/ 首先/ 在/ 第/ 24/ 行将/ 变量/ isCA/ 设为/ TRUE/ ,/ 然后/ 在/ 第/ 25/ ~/ 28/ 行/ 判断/ idch/ 是否/ 在/ 每个/ 倒/ 排表/ 的/ 第/ chLevel/ 层/ 出现/ ./ 如果/ 所有/ 倒/ 排表/ 均/ 包含/ idch/ (/ 第/ 29/ 行值/ 第为/ TRUE/ )/ ,/ 则/ 表示/ 以/ idch/ 为根/ 的/ 子树/ 包含/ 所有/ 的/ 关键字/ 结点/ ,/ 然后/ 我们/ 在/ 第/ 30/ 行/ 通过/ 调用/ getSubTree/ (/ Tv/ ,/ idch/ ,/ chLevel/ )/ 来/ 得到/ 以/ idch/ 为根/ 的/ 子树/ Tch/ 的/ 统计/ 信息/ ./ 注意/ 算法/ 1/ 中/ ,/ 第/ 37/ 行/ 使用/ 全局/ 倒/ 排表/ 来/ 得到/ 当前/ 子树/ 对应/ 的/ 局部/ 倒/ 排表/ ,/ 而/ 第/ 19/ 、/ 26/ 、/ 36/ 行中/ 使用/ Tv/ 的/ 局部/ 倒/ 排表/ 来/ 缩小/ 折半/ 查找/ 的/ 范围/ ./ 例/ 4/ ./ 考虑/ 在/ 图/ 1/ 的/ XML/ 文档/ D/ 上/ 处理/ 查/ Page8/ 询/ Q/ =/ {/ CS/ ,/ XML/ ,/ Tom/ ,/ VLDB/ }/ ,/ 相应/ 的/ 倒/ 排表/ 如图/ 2/ 所示/ ./ 算法/ 1/ 首先/ 使用/ LCS/ 中/ 的/ 2/ 去/ 探测/ 其它/ 倒/ 排表/ 中/ 是否/ 存在/ 包含/ 2/ 的/ 编码/ ./ 由于/ 所有/ 倒/ 排表/ 中均/ 有/ 编码/ 包含/ 2/ ,/ 可知/ 以/ 结点/ 2/ 为根/ 的/ 子树/ 包含/ 所有/ 关键字/ ,/ 因而/ 算法/ 1/ 继续/ 使用/ LCS/ 中/ 的/ 3/ 去/ 探测/ 是否/ 其它/ 倒/ 排表/ 存在/ 包含/ 3/ 的/ 编码/ ./ 由于/ 第/ 1/ 个/ 被/ 探测/ 的/ 倒/ 排表/ LXML/ 中/ 不/ 存在/ 包含/ 3/ 的/ 编码/ ,/ 算法/ 1/ 停止/ 探测/ ,/ 并/ 可/ 立即/ 得知/ 结点/ 2/ 是/ Q/ 的/ SLCA/ 结点/ ,/ 并/ 调用/ 算法/ 2/ 构建/ 相应/ 的/ TMSubtree/ ./ 之后/ 由于/ LCS/ 中/ 的/ 编码/ 被/ 处理完毕/ ,/ 程序/ 结束/ ./ 算法/ 1/ 在/ 执行/ 时/ ,/ 可/ 跳/ 过/ 图/ 2/ 中/ 灰色/ 背景/ 覆盖/ 的/ 编码/ ./ 从例/ 4/ 和/ 算法/ 1/ 的/ 执行/ 过程/ 可知/ ,/ 算法/ 1/ 可以/ 在/ 求解/ SLCA/ 的/ 时候/ 快速/ 跳过/ 对/ 很多/ 无用/ 结点/ 的/ 处理/ ./ 当/ 已知/ 某个/ 子树/ 的/ 根/ 结点/ 为/ SLCA/ 结点/ 后/ ,/ 算法/ 1/ 在/ 第/ 21/ 行/ 调用/ 算法/ 2/ 以/ 自顶向下/ 、/ 广度/ 优先/ 的/ 方式/ 构建/ TMSubtree/ 树/ ,/ 借助/ 队列/ queue/ 来/ 暂存/ 部分/ 兄弟/ 结点/ 及其/ 孩子/ 结点/ ./ 在/ 算法/ 2/ 的/ 第/ 1/ 行/ ,/ 我们/ 将/ 队列/ queue/ 初始化/ 为空/ ./ 第/ 2/ ~/ 3/ 行/ ,/ 初始化/ 入队/ 的/ 第/ 1/ 个/ 元素/ e/ 并/ 在/ 第/ 4/ 行将/ 其/ 入队/ ./ 其中/ 第/ 2/ 行/ 的/ e/ / parent/ 是/ 一个/ 指针/ ,/ 指向/ Tv/ 中/ e/ 对应/ 的/ 父亲/ 结点/ ,/ e/ / label/ 表示/ e/ 对应/ 的/ 结点/ 编码/ ,/ e/ / S/ 表示/ e/ 的/ 关键字/ 集合/ ./ 只要/ 队列/ 不空/ (/ 算法/ 2/ 的/ 第/ 5/ 行为/ TRUE/ )/ ,/ 我们/ 在/ 第/ 6/ 行从/ 队列/ 中/ 移除/ 1/ 个/ 元素/ e/ ,/ 并/ 在/ 第/ 7/ 行/ 根据/ e/ 生成/ 一个/ 结点/ ./ 如果/ 第/ 8/ 行/ e/ / parent/ ≠/ NULL/ ,/ 说明/ v/ 的/ 父/ 结点/ 已经/ 在/ Tv/ 中/ ,/ 则/ 在/ 第/ 9/ 行将/ v/ 插入/ Tv/ 中/ ,/ 否则/ 说明/ Tv/ 为/ 空树/ ,/ 在/ 第/ 10/ 行将/ v/ 作为/ Tv/ 的/ 根/ 结点/ ./ 算法/ 2/ ./ generateTMSubtree/ (/ Tv/ )/ ./ 1/ ./ queue/ ←/ / ;/ 2/ ./ e/ / parent/ ←/ NULL/ ;/ e/ / label/ ←/ Tv/ / lv/ ;/ e/ / S/ ←/ queue/ ;/ 3/ ./ e/ / [/ L1/ ,/ L2/ ,/ …/ ,/ Lm/ ]/ ←/ Tv/ / [/ L1/ ,/ L2/ ,/ …/ ,/ Lm/ ]/ 4/ ./ addTail/ (/ queue/ ,/ e/ )/ 5/ ./ WHILE/ (/ / isEmpty/ (/ queue/ )/ )/ DO6/ ./ e/ ←/ removeHead/ (/ queue/ )/ 7/ ./ generateanodevusinge8/ ./ IF/ (/ e/ / parent/ ≠/ NULL/ )/ THEN9/ ./ addvasachildofe/ / parent10/ ./ ELSETv/ / root/ ←/ v11/ ./ nextL/ ←/ |/ e/ / label/ |/ +/ 112/ ./ [/ c1/ ,/ …/ ,/ cm/ ]/ ←/ [/ pos/ (/ e/ / L1/ [/ 1/ ]/ )/ ,/ …/ ,/ pos/ (/ e/ / Lm/ [/ 1/ ]/ )/ ]/ 13/ ./ WHILE/ (/ / eofL/ (/ e/ ,/ nextL/ )/ )/ DO14/ ./ idch/ ←/ minarg/ {/ e/ / Li/ [/ ci/ ]/ [/ nextL/ ]/ }/ 15/ ./ e/ / S/ ←/ / 16/ ./ e/ / parent/ ←/ v17/ ./ FOR/ (/ eachi/ ∈/ [/ 1/ ,/ m/ ]/ )/ DO18/ ./ starti/ ←/ ci19/ ./ IF/ (/ e/ / Li/ [/ ci/ ]/ [/ nextL/ ]/ =/ idch/ )/ THEN20/ ./ e/ / S/ ←/ e/ / S/ ∪/ {/ ki/ }/ 21/ ./ binSearch/ (/ e/ / Li/ ,/ idch/ +/ 1/ ,/ nextL/ )/ 22/ ./ endi/ ←/ ci/ -/ 123/ ./ ELSEendi/ ←/ starti/ -/ 124/ ./ isConsumed/ ←/ FALSE25/ ./ e/ ←/ getTail/ (/ queue/ )/ 26/ ./ WHILE/ (/ e/ / parent/ =/ e/ / parent/ )/ DO27/ ./ IF/ (/ e/ / S/ / e/ / S/ )/ THEN28/ ./ isConsumed/ ←/ TRUE/ ;/ BREAK29/ ./ ELSEIF/ (/ e/ / S/ / e/ / S/ )/ THENdeleteefromqueue30/ ./ e/ ←/ getPrev/ (/ e/ )/ 31/ ./ IF/ (/ isConsumed/ =/ FALSE/ )/ THEN32/ ./ e/ / label/ ←/ e/ / label/ / idch33/ ./ FOR/ (/ eachi/ ∈/ [/ 1/ ,/ m/ ]/ )/ DOe/ / Li/ ←/ Li34/ ./ addTail/ (/ queue/ ,/ e/ )/ 35/ ./ RETURNTv36/ ./ FunctioneofL/ (/ e/ ,/ nextL/ )/ 37/ ./ IF/ (/ / i/ ∈/ [/ 1/ ,/ m/ ]/ ,/ suchthatnotalldistinctintegers38/ ./ RETURNFALSE39/ ./ RETURNTRUE/ 当/ 处理/ 完/ e/ 之后/ ,/ 算法/ 2/ 在/ 第/ 11/ ~/ 34/ 行/ 处理/ v/ 的/ 所有/ 孩子/ 结点/ ,/ 其/ 基本/ 思想/ 为/ 对于/ 当前/ 被/ 处理/ 的/ 孩子/ 结点/ 而言/ (/ 和/ 算法/ 2/ 中/ 的/ e/ 对应/ )/ ,/ 依次/ 比较/ e/ / S/ (/ e/ 的/ 关键字/ 集合/ )/ 与/ 队列/ 中/ 所有/ 兄弟/ 结点/ 关键字/ 集合/ 之间/ 的/ 包含/ 关系/ (/ 第/ 24/ ~/ 30/ 行/ )/ ,/ 并/ 移除/ 所有/ 被/ e/ / S/ 包含/ 的/ 兄弟/ 结点/ (/ 第/ 29/ 行/ )/ ;/ 如果/ 在/ 比较/ 过程/ 中/ 遇到/ 包含/ e/ / S/ 的/ 关键字/ 集合/ ,/ 则/ 直接/ 终止/ 比较/ (/ 第/ 27/ ~/ 28/ 行/ )/ 并/ 忽略/ 对/ e/ 的/ 处理/ ;/ 对于/ 队列/ 中/ 所有/ 兄弟/ 结点/ 的/ 关键字/ 集合/ 而言/ ,/ 如果/ 在/ 比较/ 完成/ 之后/ 没有/ 发现/ 包含/ e/ / S/ 的/ 关键字/ 集合/ (/ 第/ 31/ 行/ isConsumed/ =/ FALSE/ )/ ,/ 则/ 初始化/ e/ 的/ 其它/ 数据/ 成员/ 并/ 将/ 其/ 放入/ 队列/ (/ 第/ 32/ ~/ 34/ 行/ )/ ./ 算法/ 所/ 使用/ 的/ 集合/ 可/ 通过/ 位/ 向量/ 表示/ ,/ 第/ 20/ 、/ 27/ 、/ 29/ 行/ 集合/ 之间/ 的/ 关系/ 运算/ 的/ 代价/ 为/ O/ (/ 1/ )/ ./ 为了/ 得到/ 当前/ 结点/ 的/ 孩子/ 结点/ ,/ 算法/ 2/ 在/ 第/ 11/ 行/ 得到/ 孩子/ 结点/ 的/ 层数/ ,/ 在/ 第/ 12/ 行为/ e/ 的/ 每个/ 倒/ 排表/ e/ / Li/ 设定/ 初始/ 光标/ ci/ ,/ 在/ 第/ 13/ ~/ 34/ 行/ 依次/ 处理/ v/ 的/ 每个/ 孩子/ 结点/ ./ 具体来说/ ,/ 算法/ 2/ 在/ 第/ 14/ 行/ 得到/ v/ 的/ 一个/ 孩子/ 结点/ (/ 用/ idch/ 表示/ )/ ,/ 并/ 将/ 其/ 关键字/ 集合/ 在/ 第/ 15/ 行/ 初始/ 用/ 化为/ 空集/ ./ 在/ 第/ 16/ ~/ 23/ 行/ ,/ 算法/ 2/ 使用/ idch/ 依次/ 探测/ 每个/ 倒/ 排表/ ,/ 如果/ 被/ 探测/ 的/ 倒/ 排表/ 中/ 包含/ idch/ ,/ 则/ 记录/ 其/ 范围/ 并/ 将/ 相应/ 的/ 关键字/ 加入/ e/ / S/ 中/ ./ 在/ 计算/ 完成/ e/ 的/ 关键字/ 集合/ 后/ ,/ 算法/ 2/ 在/ 第/ 24/ ~/ 34/ 行/ 检测/ e/ / S/ 与/ 队列/ 中/ 兄弟/ 结点/ 的/ 关键/ Page9/ 字/ 集合/ 间/ 的/ 包含/ 关系/ ,/ 其/ 处理/ 思路/ 如/ 上/ 一段/ 所述/ ./ 例/ 5/ ./ 继续/ 例/ 4/ 的/ 处理/ ./ 当/ 已知/ 结点/ 2/ 为/ SLCA/ 结点/ 后/ ,/ 算法/ 1/ 调用/ 算法/ 2/ 构建/ 基于/ 结点/ 2/ 的/ TMSubtreeT2/ ./ 算法/ 2/ 首先/ 在/ 第/ 4/ 行将/ 结点/ 2/ 对应/ 的/ 元素/ 入/ 队列/ ,/ 并/ 通过/ 第/ 5/ ~/ 34/ 行/ 的/ 处理/ 来/ 完成/ TMSubtreeT2/ 的/ 构建/ 过程/ ./ 当/ 结点/ 2/ 在/ 第/ 6/ 行出/ 队列/ 后/ ,/ 首先/ 将/ 其/ 作为/ T2/ 的/ 根/ 结点/ ,/ 然后/ 在/ 第/ 11/ ~/ 34/ 行/ 依次/ 处理/ 结点/ 2/ 的/ 每个/ 孩子/ 结点/ ./ 对于/ 结点/ 2/ 来说/ ,/ 第/ 1/ 个/ 被/ 处理/ 的/ 孩子/ 是/ 结点/ 3/ (/ 关键字/ 集合/ 包含/ “/ CS/ ”/ )/ ,/ 算法/ 2/ 将/ 其入/ 队列/ ;/ 第/ 2/ 个/ 被/ 处理/ 的/ 孩子/ 是/ 结点/ 4/ (/ 关键字/ 集合/ 包含/ “/ XML/ ,/ Tom/ ,/ VLDB/ ”/ )/ ,/ 由于/ 两个/ 兄弟/ 结点/ 的/ 关键字/ 集合/ 之间/ 互不/ 包含/ ,/ 结点/ 4/ 入/ 队列/ ;/ 最后/ 一个/ 被/ 处理/ 的/ 孩子/ 是/ 结点/ 14/ (/ 关键字/ 集合/ 包含/ “/ VLDB/ ”/ )/ ,/ 由于/ 结点/ 4/ 的/ 关键字/ 集合/ 包含/ 结点/ 14/ 的/ 关键字/ 集合/ ,/ 因而/ 结点/ 14/ 不必/ 入队/ ,/ 这一/ 操作/ 避免/ 了/ 处理/ 图/ 2/ 中/ TKP/ 点/ ,/ 即图/ 2/ 中/ 绿色/ 背景/ 覆盖/ 的/ 结点/ ./ 下/ 一个/ 出/ 队列/ 的/ 是/ 结点/ 3/ ,/ 由于/ 结点/ 3/ 没有/ 孩子/ 结点/ ,/ 算法/ 2/ 将/ 结点/ 3/ 作为/ 结点/ 2/ 的/ 孩子/ 结点/ 插入/ T2/ 中/ ./ 然后/ 结点/ 4/ 出队/ ,/ 并/ 将/ 其/ 作为/ 结点/ 2/ 的/ 孩子/ 插入/ T2/ ./ 接下来/ 处理/ 结点/ 4/ 的/ 孩子/ 结点/ ./ 首先/ 进/ 队列/ 的/ 是/ 结点/ 5/ (/ 关键字/ 集合/ 包含/ “/ Tom/ ”/ )/ ,/ 然后/ 处理/ 结点/ 6/ (/ 关键字/ 集合/ 包含/ “/ XML/ ,/ Tom/ ,/ VLDB/ ”/ )/ ./ 由于/ 结点/ 6/ 的/ 关键字/ 集合/ 包含/ 结点/ 5/ 的/ 关键字/ 集合/ ,/ 我们/ 从/ 队列/ 中/ 删除/ 结点/ 5/ 并/ 将/ 结点/ 6/ 进/ 队列/ ./ 该层/ 结点/ 中/ 最后/ 一个/ 处理/ 的/ 是/ 结点/ 10/ (/ 关键字/ 集合/ 包含/ “/ Tom/ ,/ VLDB/ ”/ )/ ,/ 由于/ 队列/ 中/ 结点/ 6/ 的/ 关键字/ 集合/ 包含/ 结点/ 10/ 的/ 关键字/ 集合/ ,/ 结点/ 10/ 无需/ 入/ 队列/ ,/ 这一/ 操作/ 避免/ 了/ 处理/ 图/ 2/ 中/ 紫色/ 背景/ 覆盖/ 的/ 结点/ ./ 当/ 结点/ 6/ 出/ 队列/ 后/ ,/ 算法/ 2/ 将/ 其/ 作为/ 结点/ 4/ 的/ 孩子/ 插入/ T2/ 中/ ./ 最后/ 将/ 结点/ 6/ 的/ 3/ 个/ 孩子/ 依次/ 进/ 队列/ ,/ 并/ 在/ 其出/ 队列/ 后/ 插入/ T2/ 中/ 作为/ 结点/ 6/ 的/ 孩子/ 结点/ ./ 注意/ 在/ 显示/ 结果/ 时/ ,/ 如果/ 需要/ 显示/ TMSubtree/ 中/ 每个/ 结点/ 的/ 名称/ ,/ 一种/ 简单/ 的/ 方式/ 是/ 通过/ 在/ 倒/ 排表/ 中/ 每个/ IDDewey/ 编码/ 的/ 最后/ 附加/ 该/ 结点/ 对应/ 的/ 路径/ ID/ 即可/ ,/ 通过/ 该/ ID/ 值/ ,/ 我们/ 可以/ 在/ O/ (/ 1/ )/ 时间/ 内/ 得到/ 从/ 根到/ 该/ 结点/ 的/ 路径/ 上/ 每个/ 结点/ 的/ 名称/ ./ 4.2/ 算法/ 分析/ 对于/ 给定/ 的/ 查询/ Q/ =/ {/ k1/ ,/ k2/ ,/ …/ ,/ km/ }/ ,/ 假设/ IDDewey/ 倒/ 排表/ 的/ 长度/ 满足/ 0/ </ |/ L1/ |/ / |/ L2/ |/ / …/ / |/ Lm/ |/ ,/ LIDi/ 表示/ Li/ 对应/ 的/ IDList/ [/ 13/ ]/ ./ 例如/ ,/ 对于/ 图/ 2/ 中/ 的/ LTom/ ,/ 总共/ 有/ 4/ 个/ IDDewey/ 编码/ ,/ 显然/ ,/ |/ LTom/ |/ =/ 4/ ,/ LTom/ 中/ 所有/ IDDewey/ 编码/ 包含/ 的/ ID/ 个数/ 为/ 19/ ,/ 其中/ 不同/ ID/ 值/ 的/ 个数/ 为/ |/ LID/ 于/ 该/ 关键字/ 的/ KPTree/ 中/ 的/ 结点/ 数目/ ,/ 即/ |/ LID/ |/ V/ (/ TKPTom/ )/ |/ ./ 我们/ 的/ 方法/ 采用/ 自顶向下/ 的/ 方式/ 处理/ 给定/ 查询/ Q/ 对应/ 的/ QPTree/ 中/ 的/ 结点/ ./ 由于/ 每个/ QPTree/ 中/ 的/ SLCA/ 结点/ 必然/ 出现/ 在/ k1/ 的/ KPTree/ 中/ ,/ 且/ 对于/ 每个/ 包含/ 所有/ 关键字/ 的/ 结点/ ,/ 算法/ 1/ 在/ 处理/ 其/ 孩子/ 结点/ 时/ ,/ 都/ 是/ 使用/ 其/ 最/ 短/ 倒/ 排表/ 中/ 的/ 数字/ 探测/ 其它/ 倒/ 排表/ ,/ 代价/ 为/ m/ ·/ log/ |/ Lm/ |/ ./ 由于/ 被/ 处理/ 的/ 结点/ 数最多/ 为/ k1/ 的/ KPTree/ 中/ 的/ 结点/ 数目/ ,/ 因而/ 用/ 算法/ 1/ 求解/ 所有/ SLCA/ 结点/ 代价/ 为/ O/ (/ m/ ·/ |/ LID1/ |/ ·/ log/ |/ Lm/ |/ )/ ./ 对于/ 构建/ 所有/ TMSubtree/ 而言/ ,/ 假设/ 最坏/ 情况/ 下/ ,/ Q/ 的/ QPTree/ 中/ 的/ 所有/ 结点/ 都/ 需/ 探测/ 兄弟/ 结点/ 间/ 的/ 包含/ 关系/ ,/ 则/ 被/ 处理/ 结点/ 总数/ 为/ |/ ∪/ m/ 对于/ 每个/ 被/ 探测/ 的/ 结点/ 而言/ ,/ 其/ 平均/ 处理/ 代价/ 为/ m/ ·/ log/ |/ Lm/ |/ +/ m2/ ,/ 其中/ m/ ·/ log/ |/ Lm/ |/ 是/ 得到/ 该/ 结点/ 倒/ 排表/ 范围/ 和/ 关键字/ 集合/ 的/ 代价/ ,/ m2/ 为/ 检测/ 包含/ 关系/ 的/ 代价/ ./ 由于/ 通常/ 情况/ 下/ ,/ m/ </ log/ |/ Lm/ |/ ,/ 因而/ 最坏/ 情况/ 下/ 构建/ 所有/ TMSubtree/ 的/ 代价/ 为/ m/ ·/ |/ ∪/ mlog/ |/ Lm/ |/ ./ 由于/ |/ LID1/ |/ / |/ ∪/ m/ 算法/ 1/ 的/ 时间/ 复杂度/ 为/ O/ (/ m/ ·/ |/ ∪/ m/ 由于/ TDTMS/ 算法/ 以/ 自顶向下/ 、/ 广度/ 优先/ 的/ 方式/ 建树/ ,/ 任何/ 时候/ ,/ 内存/ 中/ 最/ 多/ 缓存/ 一个/ TMSubtree/ ,/ 且/ 算法/ 所/ 使用/ 的/ 队列/ 中/ 最/ 多/ 缓存/ 该/ TMSubtree/ 中/ 一层/ 的/ 结点/ 数量/ (/ m2/ 个/ 结点/ )/ ,/ 根据/ 文献/ [/ 16/ ]/ 中/ 对/ TMSubtree/ 大小/ 的/ 证明/ ,/ 即式/ (/ 1/ )/ ,/ 可知/ TDTMS/ 算法/ 的/ 空间/ 复杂度/ 为/ O/ (/ (/ |/ d/ -/ m/ |/ +/ 2/ )/ ·/ m/ !/ )/ ,/ 这里/ d/ 为/ 给定/ XML/ 文档/ 的/ 深度/ ./ 和/ 文献/ [/ 16/ ]/ 需要/ 缓存/ d/ 棵子/ 树/ 相比/ ,/ TDTMS/ 需要/ 缓存/ 的/ 结点/ 数量/ 更少/ ./ 需要/ 说明/ 的/ 是/ ,/ 算法/ 1/ 以/ 自顶向下/ 的/ 方式/ 访问/ Q/ 的/ QPTree/ 中/ 的/ 所有/ 结点/ ,/ 随着/ 处理/ 层数/ 的/ 增加/ ,/ 使用/ 二分/ 查找/ 进行/ 探测/ 时/ 所/ 需/ 的/ 查找/ 范围/ 也/ 快速/ 缩小/ ./ 对于/ 给定/ 的/ 结点/ ,/ 实际/ 中/ 每次/ 探测/ 的/ 范围/ 是/ 其父/ 结点/ 的/ 局部/ 倒/ 排表/ 范围/ ,/ 不是/ 全局/ 倒/ 排表/ 的/ 范围/ ./ 同时/ ,/ 通过/ 跳过/ 无用/ 结点/ 和/ 在/ 建树/ 过程/ 中/ 及时/ 剪枝/ ,/ 算法/ 1/ 需要/ 处理/ 的/ 结点/ 数量/ 得以/ 快速/ 减少/ ./ 5/ 实验/ 5.1/ 实验/ 环境/ 本文/ 实验/ 所用/ 机器/ 的/ 基本/ 配置/ 为/ 奔腾/ 双核/ E75002/ ./ 93GHzCPU/ ,/ 2GB/ 内存/ ,/ 操作系统/ 为/ WindowsXP/ ./ Page10/ 比较/ 的/ 算法/ 有/ MaxMatch/ [/ 8/ ]/ 、/ mergeMatch/ -/ ing/ [/ 16/ ]/ 以及/ 本文/ 提出/ 的/ TDTMS/ 算法/ ./ 对于/ Max/ -/ Match/ 算法/ ,/ 我们/ 分别/ 使用/ HS/ [/ 12/ ]/ 、/ IL/ [/ 4/ ]/ 以及/ IMS/ [/ 6/ ]/ 算法/ 来/ 求解/ SLCA/ 结点/ ,/ 分别/ 用/ MaxMatch/ -/ HS/ 、/ MaxMatch/ -/ IL/ 和/ MaxMatch/ -/ IMS/ 表示/ ./ 所有/ 算法/ 均/ 使用/ V/ C++/ 实现/ ,/ 本文/ 实验/ 中/ 的/ 运行/ 时间/ 是/ 每个/ 算法/ 重复/ 执行/ 100/ 次/ 的/ 平均/ 时间/ ./ 5.2/ 数据/ 集/ 和/ 查询/ 本文/ 实验/ 使用/ 的/ 数据/ 集/ 包括/ XMark/ ①/ (/ 582MB/ )/ 和/ DBLP/ ②/ (/ 876MB/ )/ ./ 我们/ 从/ XMark/ 数据/ 集中/ 选择/ 了/ 30/ 个/ 关键字/ ,/ 这些/ 关键字/ 根据/ 其/ 在/ 数据/ 集中/ 出现/ 的/ 次数/ (/ 和表/ 3/ 中/ |/ Li/ |/ 列中/ 的/ 数字/ 对应/ )/ 分为/ 3/ 类/ :/ (/ 1/ )/ 低频/ 关键字/ (/ 100/ ~/ 1000/ )/ ;/ (/ 2/ )/ 中频/ 关键字/ (/ 10000/ ~/ 40000/ )/ ;/ (/ 3/ )/ 高频/ 关键字/ (/ 300000/ ~/ 600000/ )/ ./ 基于/ 这些/ 关键字/ ,/ 我们/ 生成/ 了/ 32/ 个/ 查询/ ,/ 如表/ 4/ 所表/ 4/ 基于/ XMark/ 数据/ 集/ 的/ 查询/ 查询/ Q1villages/ ,/ hooksQ2baboon/ ,/ patients/ ,/ ArizonaQ3cabbage/ ,/ tissue/ ,/ shocks/ ,/ babbonQ4shocks/ ,/ necklace/ ,/ cognition/ ,/ cabbage/ ,/ tissueQ5female/ ,/ orderQ6privacy/ ,/ check/ ,/ maleQ7takano/ ,/ province/ ,/ school/ ,/ genderQ8school/ ,/ gender/ ,/ education/ ,/ takano/ ,/ province14344435257171291070/ ./ 62Q9bold/ ,/ increaseQ10date/ ,/ listitem/ ,/ emphQ11incategory/ ,/ text/ ,/ bidder/ ,/ dateQ12bidder/ ,/ date/ ,/ keyword/ ,/ incategory/ ,/ textQ13text/ ,/ tissueQ14takano/ ,/ provinceQ15incategory/ ,/ cabbageQ16check/ ,/ bidderQ17baboon/ ,/ patientsQ18tissue/ ,/ shocks/ ,/ orderQ19province/ ,/ bold/ ,/ increaseQ20cabbage/ ,/ male/ ,/ femaleQ21listitem/ ,/ emph/ ,/ ArizonaQ22patients/ ,/ school/ ,/ genderQ23patients/ ,/ school/ ,/ gender/ ,/ textQ24bold/ ,/ increase/ ,/ hooks/ ,/ takanoQ25male/ ,/ female/ ,/ keyword/ ,/ incategoryQ26emph/ ,/ Arizona/ ,/ villages/ ,/ educationQ27check/ ,/ bidder/ ,/ date/ ,/ baboonQ28school/ ,/ gender/ ,/ time/ ,/ baboon/ ,/ patientsQ29tissue/ ,/ shocks/ ,/ order/ ,/ province/ ,/ boldQ30female/ ,/ keyword/ ,/ incategory/ ,/ cabbage/ ,/ male802384411575366Q31Arizona/ ,/ villages/ ,/ education/ ,/ listitem/ ,/ emph692066350560451Q32bidder/ ,/ date/ ,/ necklace/ ,/ cognition/ ,/ check/ 本文/ 实验/ 中/ ,/ 为了/ 测试/ 不同/ 算法/ 在/ 各种/ 情况/ 下/ 的/ 性能/ 特征/ ,/ 我们/ 主要/ 展示/ 基于/ 较/ 复杂/ 模式/ 信息/ 的/ XML/ 数据/ 集上/ 的/ 实验/ 结果/ ./ 限于/ 篇幅/ ,/ DBLP/ 数据/ 集上/ 的/ 实验/ 结果/ 这里/ 不再/ 展示/ ./ 示/ ,/ 其中/ ,/ ∑/ 犿/ 和/ ,/ |/ Lmax/ |/ (/ |/ Lmin/ |/ )/ 表示/ 最长/ (/ 最短/ )/ 倒/ 排表/ 的/ 长度/ ,/ NS/ 表示/ 满足条件/ 的/ SLCA/ 结点/ 数量/ ,/ RS/ =/ NS/ // |/ Lmin/ |/ 表示/ 结果/ 选择率/ ./ 关键字/ |/ Li/ |/ 关键字/ |/ Li/ |/ 关键字/ |/ Li/ |/ tissue384male18441bidder299018baboon725takano17129listitem304969necklace200order16797keyword352121arizona451school23561bold368544cabbage366check36304text535268hooks461education35257time313398shocks596female19902date457232patients382province33520emph350560cognition495privacy31232incategory411575villages829gender34065increase3047528294617423827423665962007423825/ ./ 3/ 评价/ 标准/ 本文/ 实验/ 的/ 评价/ 标准/ 包括/ :/ (/ 1/ )/ 缓存/ 结点/ 数量/ ,/ ①/ ②/ Page11/ 用于/ 比较/ 不同/ 算法/ 的/ 空间/ 代价/ ;/ (/ 2/ )/ 运行/ 时间/ ,/ 包括/ 总/ 的/ 运行/ 时间/ 、/ 求解/ SLCA/ 结果/ 的/ 时间/ 以及/ 构建/ 所有/ 子树/ 的/ 时间/ ;/ (/ 3/ )/ 扩展性/ ./ 对于/ 给定/ 的/ 查询/ ,/ 我们/ 将/ “/ 结果/ 选择率/ ”/ 定义/ 为/ 结果/ 个数/ 除以/ 最短/ 倒/ 排表/ 长度/ 的/ 比值/ ,/ 表/ 4/ 倒数第/ 2/ 列是/ 每个/ 查询/ 的/ 结果/ 选择率/ ./ 5.4/ 性能/ 比较/ 和/ 分析/ 5.4/ ./ 1/ 空间/ 代价/ 比较/ 为了/ 比较/ 不同/ 算法/ 的/ 空间/ 代价/ ,/ 我们/ 统计/ 了/ MaxMatch/ 、/ mergeMatching/ 以及/ TDTMS/ 算法/ 在/ 运行/ 过程/ 中/ 需要/ 缓存/ 的/ 中间/ 结点/ 数量/ ./ 表/ 5/ 为/ 不同/ 算法/ 在/ 处理/ 每个/ 查询/ 时/ 最/ 多/ 需要/ 缓存/ 的/ 结点/ 数量/ ,/ 可以/ 看出/ ,/ mergeMatching/ 算法/ 需要/ 缓存/ 的/ 中间/ 结点/ 数量/ 远/ 少于/ MaxMatch/ ./ 原因/ 在于/ ,/ MaxMatch/ 算法/ 需要/ 首先/ 将/ 完整/ 的/ 路径/ 子树/ 构建/ 好/ ,/ 在/ 此基础/ 上/ 实施/ 剪枝/ 操作/ ,/ 而/ mergeMatching/ 算法/ 在/ 顺序/ 处理/ 所有/ 编码/ 的/ 过程/ 中/ 同时/ 实施/ 剪枝/ 操作/ ,/ 因而/ 在/ 内存/ 中/ 最/ 多/ 缓存/ d/ 个/ TMSubtree/ ./ 查询/ Q1Q2Q3Q4Q5Q6Q7Q8Q9243461Q10465991Q112826470Q123218018Q13Q14Q15Q16Q17Q18Q19Q20Q211441330Q22Q23538832Q24231594Q25Q261331246Q27Q28324085Q29389656Q30623179Q311540236Q32669062/ 和/ mergeMatching/ 相比/ ,/ 本文/ 提出/ 的/ TDTMS/ 算法/ 在/ 最好/ 情况/ 下/ 所/ 需/ 缓存/ 的/ 结点/ 数量/ 不到/ mergeMatching/ 的/ 20/ %/ (/ Q25/ )/ ./ 原因/ 在于/ ,/ TDTMS/ 算法/ 以/ 自顶向下/ 、/ 广度/ 优先/ 的/ 方式/ 剪枝/ ,/ 因而/ 可以/ 避免/ 处理/ 很多/ 无用/ 结点/ 的/ 后代/ 结点/ ,/ 从而/ 可以/ 进一步/ 降低/ 需要/ 缓存/ 的/ 中间/ 结点/ 数量/ ./ 5.4/ ./ 2/ 求解/ SLCA/ 结点/ 的/ 性能/ 比较/ 对于/ 子树/ 构建/ 来说/ ,/ 首先/ 要/ 解决/ 的/ 问题/ 是/ 求解/ 所有/ 满足条件/ 的/ SLCA/ 结点/ ,/ 因此/ 我们/ 首先/ 比较/ 不同/ 算法/ 在/ 求解/ SLCA/ 结点/ 时/ 的/ 性能/ ./ 如图/ 4/ 所示/ ,/ 文本/ 提出/ 的/ 方法/ TDTMS/ 在/ 多数/ 情况/ 下/ 所/ 需/ 时间/ 远/ 少于/ IL/ 、/ IMS/ 和/ mergeMatch/ -/ ing/ ,/ 原因/ 是/ 本文/ 方法/ 以/ 自顶向下/ 的/ 方式/ 依次/ 处理/ 每个/ 公共/ 祖先/ 结点/ ,/ 而/ IL/ 、/ IMS/ 和/ mergeMatching/ 算法/ 的/ 基本操作/ 是/ 比较/ 两个/ Dewey/ 编码/ 中/ 的/ 数字/ ,/ 由于/ Dewey/ 编码/ 中/ 的/ 每个/ 数字/ 都/ 对应/ 了/ XML/ 文档/ 中/ 一个/ 结点/ ,/ 且/ 通常/ 情况/ 下/ ,/ 任意/ 结点/ 都/ 可能/ 是/ 很多/ 后代/ 结点/ 的/ 公共/ 祖先/ 结点/ ,/ 因而/ 频繁/ 比较/ Dewey/ 编码/ 造成/ 了/ “/ 公共/ 祖先/ 重复/ 处/ 公理/ 问题/ ”/ [/ 13/ ]/ ,/ 而/ TDTMS/ 则/ 不/ 存在/ 这一/ 问题/ ./ 即使/ 和/ HS/ 相比/ ,/ 当/ 结果/ 选择率/ 变/ 小时/ ,/ TDTMS/ 所需/ 时间/ 也/ 远/ 少于/ HS/ 算法/ ,/ 原因/ 在于/ HS/ 需要/ 顺序/ 处理/ 最短/ 倒/ 排表/ 中/ 的/ IDDewey/ 编码/ ,/ 由于/ 很多/ 编码/ 中/ 存在/ 相同/ 的/ ID/ 值/ ,/ HS/ 同样/ 无法/ 避免/ 公共/ 祖先/ 重复/ 处理/ 问题/ ,/ 尤其/ 是/ 在/ 最/ 短/ 倒/ 排表/ 很长/ 而/ 结果/ 个数/ 很少/ 的/ 情况/ 下/ ,/ 即/ 结果/ 选择率/ 变小/ 的/ 时候/ ,/ HS/ 的/ 性能/ 远不如/ TDTMS/ ./ 例如/ ,/ Q2/ 、/ Q5/ ~/ Q8/ 、/ Q11/ ~/ Q12/ 、/ Q14/ 、/ Q16/ 、/ Q21/ 、/ Q25/ 、/ Q26/ 、/ Q31/ ./ 对于/ 已有/ 方法/ 而言/ ,/ 通常/ 情况/ 下/ HS/ 要/ 好/ 于/ IL/ 、/ IMS/ 和/ mergeMatching/ ,/ 因而/ 在/ 后续/ 讨论/ 中/ ,/ 当/ 需要/ 和/ MaxMatch/ 算法/ 进行/ 比较/ 时/ ,/ 我们/ 都/ 和/ Max/ -/ Match/ -/ HS/ 比较/ ./ 5.4/ ./ 3/ 已有/ 方法/ 求解/ SLCA/ 对/ 查询处理/ 的/ 影响/ 为了/ 深入/ 理解/ MaxMatch/ 构建/ 子树/ 过程/ 的/ 性能/ 特点/ ,/ 我们/ 在/ 其/ 求解/ SLCA/ 时/ 分别/ 基于/ HS/ 、/ IL/ 和/ IMS/ 算法/ 实现/ 了/ 3/ 种/ MaxMatch/ 算法/ ,/ 分别/ 是/ MaxMatch/ -/ HS/ 、/ MaxMatch/ -/ IL/ 和/ MaxMatch/ -/ IMS/ ,/ 三者/ 在/ 求得/ SLCA/ 结点/ 后/ 构建/ 子树/ 的/ 过程/ 一致/ ./ 如表/ 6/ 所示/ ,/ 3/ 种/ 算法/ 处理/ 每个/ 查询/ 的/ 时间/ 基本相同/ ,/ 其中/ MaxMatch/ -/ HS/ 所需/ 时间/ 在/ 多数/ 情况/ 下/ 略/ 少于/ 另外/ 两种/ 算法/ ./ 原因/ 是/ HS/ 算法/ 在/ 求解/ SLCA/ 结点/ 时/ 只/ 需/ 处理/ 一个/ 倒/ 排表/ 中/ 的/ 结点/ ,/ 和/ ILPage12/ 图/ 4/ 求解/ SLCA/ 结果/ 的/ 运行/ 时间/ 比较/ 及/ IMS/ 相比/ ,/ 时间/ 复杂度/ 更/ 小/ ./ 从表/ 6/ 的/ 结果/ 可以/ 看出/ ,/ 无论/ HS/ 、/ IL/ 和/ IMS/ 有/ 多/ 高效/ ,/ 且/ 无论/ HS/ 比/ IL/ 和/ IMS/ 的/ 性能/ 好/ 多少/ ,/ 当/ 用于/ MaxMatch/ 算法/ 生成/ 子树时/ ,/ 所有/ 算法/ 的/ 性能/ 优势/ 几乎/ 不/ 存在/ ./ 原因/ 在于/ :/ 当/ 使用/ MaxMatch/ 求解/ 结果/ 子树时/ ,/ 相对/ 于/ 建树/ 的/ 代价/ ,/ 求解/ SLCA/ 结点/ 的/ 代价/ 几乎/ 可以/ 忽略不计/ ./ 表/ 6/ 不同/ 版本/ MaxMatch/ 算法/ 运行/ 时间/ 比较/ 查询/ Q12/ ./ 340Q22/ ./ 300Q33/ ./ 100Q42/ ./ 703Q54/ ./ 710Q615/ ./ 110Q797/ ./ 120105.45/ Q8149/ ./ 300151.00/ Q9460/ ./ 600479.70/ Q103021/ ./ 7003135.953037/ ./ 00Q116446/ ./ 2006468.006443/ ./ 70Q129067/ ./ 0009594.009057/ ./ 00Q1325/ ./ 130Q1429/ ./ 400Q1511/ ./ 400Q1632/ ./ 570Q175/ ./ 300Q1893/ ./ 810Q1928/ ./ 100Q2038/ ./ 330Q211909/ ./ 0001910.201910/ ./ 00Q2278/ ./ 300Q234047/ ./ 6304048.454048/ ./ 20Q241651/ ./ 1001651.551652/ ./ 40Q2526/ ./ 170Q261344/ ./ 2001344.551344/ ./ 50Q2720/ ./ 200Q281429/ ./ 3001429.701429/ ./ 80Q292944/ ./ 7002945.352945/ ./ 90Q302204/ ./ 7002204.702204/ ./ 70Q312073/ ./ 3002073.452074/ ./ 20Q321531/ ./ 7001532.001531/ ./ 005.4/ ./ 4/ 不同/ 子树/ 构建/ 方法/ 的/ 性能/ 比较/ 图/ 5/ 展示/ 了/ MaxMatch/ 、/ mergeMatching/ 以及/ TDTMS3/ 种/ 方法/ 在/ 构建/ 子树时/ 的/ 时间/ 比较/ ./ 从/ 该/ 图/ 可以/ 看出/ ,/ 虽然/ 在/ 求解/ SLCA/ 结点/ 时/ ,/ mergeMatching/ 的/ 性能/ 不如/ HS/ 、/ IL/ 和/ IMS/ ,/ 但/ 其/ 构建/ 子树/ 的/ 性能/ 在/ 多数/ 情况/ 下远/ 好/ 于/ MaxMatch/ ,/ 而且/ 这部分/ 节省/ 的/ 时间/ 代价/ 要远/ 多于/ 求解/ SLCA/ 结点/ 时/ 浪费/ 的/ 代价/ ./ 与/ 此对应/ ,/ TDTMS/ 算法/ 由于/ 采用/ 自顶向下/ ,/ 按层/ 剪枝/ 的/ 策略/ ,/ 在/ 多数/ 情况/ 下/ ,/ 尤其/ 是/ 当/ 结果/ 选择率/ 较/ 低时/ ,/ 获得/ 的/ 性能/ 优势/ 远好/ 于/ mergeMatching/ 算法/ ,/ 如/ Q2/ 、/ Q5/ ~/ Q8/ 、/ Q11/ ~/ Q13/ 、/ Q15/ 、/ Q19/ ~/ 28/ 、/ Q30/ ~/ Q32/ ./ 对于/ Q9/ 和/ Q10/ 而言/ ,/ TDTMS/ 构建/ 所有/ 子树/ 所/ 需/ 的/ 时间/ 仍然/ 多于/ mergeMatching/ ,/ 原因/ 是/ :/ 当/ 结果/ 选择率/ 变大后/ ,/ 每个/ 子树/ 中/ 的/ 结点/ 数量/ 相对/ 变少/ ./ 这时/ 可/ 裁剪/ 的/ 结点/ 数量/ 也/ 相对/ 变/ 少/ ,/ 甚至/ 没有/ ./ 相对而言/ ,/ mergeMatching/ 可以/ 更/ 高效/ 的/ 处理/ 每个/ 无需/ 裁剪/ 的/ 结点/ ./ 5.4/ ./ 5/ 不同/ 算法/ 整体/ 性能/ 比较/ 图/ 6/ 展示/ 了/ MaxMatch/ -/ HS/ 、/ mergeMatching/ 以及/ TDTMS/ 这/ 3/ 种/ 算法/ 求解/ 所有/ 子树/ 所/ 需/ 的/ 整体/ 时间/ 比较/ ./ 从/ 该/ 图/ 可以/ 看出/ ,/ 多数/ 情况/ 下/ ,/ mergeMatching/ 的/ 性能/ 远好/ 于/ MaxMatch/ -/ HS/ 算法/ ,/ 原因/ 在于/ mergeMatching/ 无需/ 反复/ 扫描/ 倒/ 排表/ 中/ 的/ 元素/ ,/ 且/ 在/ 剪枝/ 过程/ 中/ 无需/ 像/ MaxMatch/ -/ HS/ 算法/ 一样/ 先/ 建树/ 后/ 剪枝/ (/ 需要/ 反复/ 访问/ 树中/ 结点/ )/ ,/ 而是/ 采/ 需用/ 边/ 建树/ 边/ 裁剪/ 的/ 策略/ ,/ 可以/ 快速/ 减少/ 兄弟/ 结点/ 间/ 比较/ 关键字/ 集合/ 包含/ 关系/ 的/ 次数/ ./ 与/ 此对应/ ,/ 本文/ 提出/ 的/ TDTMS/ 算法/ 从/ 求解/ Page13/ 图/ 5/ 构建/ 子树/ 的/ 时间/ 比较/ 图/ 6/ 不同/ 算法/ 整体/ 运行/ 时间/ 比较/ SLCA/ 和/ 构建/ 子树/ 两个/ 角度/ 进行/ 优化/ ,/ 不但/ 在/ 求解/ SLCA/ 结点/ 时像/ IL/ 和/ IMS/ 一样/ 跳过/ 无用/ 结点/ ,/ 甚至/ 更好/ ,/ 而且/ 在/ 建树/ 过程/ 中/ 通过/ 自顶向下/ 、/ 按层/ 构建/ 的/ 方式/ 快速/ 裁剪/ 无用/ 结点/ ,/ 因而/ 整体/ 性能/ 明显/ 优于/ MaxMatch/ -/ HS/ 和/ mergeMatching/ 算法/ ./ 通常/ 情况/ 下/ ,/ 对于/ 很多/ 查询/ 来说/ (/ Q2/ 、/ Q6/ ~/ Q8/ 、/ Q11/ ~/ Q12/ 、/ Q13/ 、/ Q15/ 、/ Q19/ ~/ Q32/ )/ ,/ TDTMS/ 比/ MaxMatch/ -/ HS/ 和/ merge/ -/ Matching/ 快/ 10/ 倍/ 以上/ ,/ 最好/ 情况/ 下/ 甚至/ 比/ MaxMatch/ -/ HS/ 和/ mergeMatching/ 快/ 3/ 个/ 数量级/ 以上/ ,/ 如/ Q21/ 和/ Q27/ ./ 5.4/ ./ 6/ 扩展性/ 图/ 7/ 展示/ 了/ 不同/ 方法/ 在/ 大小/ 不同/ 的/ XML/ 文档/ 图/ 7/ 不同/ 文档/ 上/ 执行/ 查询/ Q7/ 的/ 扩展性/ 比较/ 上/ 执行/ Q7/ 时/ 的/ 扩展性/ ./ 可以/ 看出/ ,/ TDTMS/ 具有/ 较/ 好/ 的/ 扩展性/ ./ 限于/ 篇幅/ ,/ 其它/ 查询/ 的/ 扩展性/ 不再/ 展示/ ./ 6/ 结论/ 子树/ 构建/ 是/ 影响/ XML/ 关键字/ 查询处理/ 性能/ 的/ 重要/ 因素/ ./ 针对/ 已有/ 方法/ 在/ 求解/ 结果/ 子树时/ 建树/ 代价/ 高/ (/ MaxMatch/ 算法/ )/ ,/ 或者/ 无法/ 避免/ 处理/ 无用/ 结点/ (/ mergeMatching/ 算法/ )/ 的/ 问题/ ,/ 本文/ 提出/ 一种/ 自顶向下/ 构建/ 结果/ 子树/ 的/ 高效/ 算法/ —/ —/ —/ TDTMS/ ./ TDTMS/ 以/ 自顶向下/ 、/ 深度/ 优先/ 的/ 方式/ 求解/ 满足/ SLCA/ 查询/ 语义/ 的/ 子/ 树根/ 结点/ ,/ 避免/ 了/ 已有/ 方法/ 求解/ SLCA/ 结点/ 时/ 存在/ 的/ 公共/ 祖先/ 重复/ 处理/ 问题/ ./ 对于/ 给定/ 的/ 子/ 树根/ 结点/ ,/ TDTMS/ 以/ 自顶向下/ 、/ 广度/ 优先/ 的/ 方式/ 构建/ 子树/ ,/ 可以/ 在/ 建树/ 过程/ 中/ 快速/ 裁剪/ 不/ 满足条件/ 的/ 结点/ ,/ 因此/ 获得/ 了/ 最小/ 的/ 时间/ 复杂度/ 和/ 空间/ 复杂度/ ./ 最后/ 通过/ 实验/ 验证/ 了/ TDTMS/ 在/ 时间/ 和/ 空间/ 两/ 方面/ 的/ 性能/ 优势/ ./ 本文/ 的/ 后续/ 工作/ 将/ 考虑/ 针对/ ELCA/ 语义/ 的/ 结/ Page14/ 果子/ 树/ 构建/ 操作/ ,/ 并/ 设计/ 统一/ 框架/ 来/ 处理/ 基于/ XML/ 关键字/ 查询/ 的/ 子树/ 求解/ 问题/ ./ 

