Page1FClock/ :/ 一种/ 面向/ SSD/ 的/ 自/ 适应/ 缓冲区/ 管理/ 算法/ 汤显/ 孟小峰/ (/ 中国人民大学/ 信息/ 学院/ 北京/ 100872/ )/ 摘要/ 现有/ 的/ 各种/ 基于/ 闪存/ 的/ 缓冲区/ 管理/ 算法/ 针对/ 闪存/ 读写/ 代价/ 的/ 不对称性/ 进行/ 改进/ ,/ 实际/ 中/ 既/ 存在/ 同一/ 闪存/ 读写/ 代价/ 的/ 不对称性/ 问题/ ,/ 也/ 存在/ 不同/ 闪存/ 不对称性/ 之间/ 的/ 巨大/ 差异性/ 问题/ ,/ 而/ 后者/ 一直/ 没有/ 得到/ 足够/ 的/ 重视/ ./ 文章/ 提出/ 一种/ 基于/ 闪存/ 硬盘/ (/ SSD/ )/ 的/ 自/ 适应/ 缓冲区/ 管理/ 算法/ FClock/ ,/ FClock/ 将/ 数据/ 页/ 组织/ 为/ 两个/ 环形/ 数据结构/ (/ CC/ 和/ DC/ )/ ,/ 分别/ 用于/ 存储/ 缓冲区/ 中/ 的/ 只读/ 数据/ 页/ 和/ 已/ 修改/ 数据/ 页/ ./ 当/ 需要/ 选择/ 置换/ 页/ 时/ ,/ FClock/ 使用/ 基于/ 代价/ 的/ 启发式/ 来/ 选择/ 置换/ 页/ ,/ 可/ 在/ 未修改/ 的/ 数据/ 页/ 和/ 已/ 修改/ 的/ 数据/ 页/ 之间/ 进行/ 公平/ 的/ 选择/ ,/ 适用/ 于/ 不同/ 种类/ 的/ SSD/ ./ 针对/ 数据库/ 、/ 虚存/ 和/ 文件系统/ 中/ 数据/ 页/ 访问/ 存在/ 高/ 相关性/ 的/ 特点/ ,/ 提出/ 基于/ “/ 平均/ 命中/ 距离/ ”/ 的/ 访问/ 计数/ 方法/ 来/ 调整/ 数据/ 页/ 的/ 访问/ 频率/ ./ 基于/ 不同/ SSD/ 和/ 不同/ 存取/ 模式/ 的/ 实验/ 结果/ 说明/ ,/ FClock/ 的/ 综合性/ 能/ 优于/ 已有/ 方法/ ./ 关键词/ 闪存/ ;/ 数据库/ ;/ 缓冲区/ ;/ 置换/ 策略/ ;/ CLOCK1/ 引言/ 基于/ 闪存/ 的/ 存储设备/ 以其/ 低/ 延迟/ 、/ 低能耗/ 、/ 小巧/ 轻便/ 及/ 高/ 抗震性/ 等/ 特点/ 广泛应用/ 于/ 移动/ 设备/ 上/ ,/ 随着/ 闪存/ 容量/ 的/ 不断/ 增大/ 和/ 价格/ 的/ 降低/ ,/ 其/ 应用领域/ 已/ 逐步/ 扩展/ 到/ 个人/ 计算机/ 和/ 企业/ 服务器/ 市场/ ./ 过去/ 几年/ NAND/ 型/ 闪存/ 的/ 容量/ 不断/ 增长/ ,/ 并且/ 这种/ 趋势/ 将/ 至少/ 持续/ 到/ 2012/ 年/ [/ 1/ ]/ ./ 目前/ 各种/ 应用/ 中/ 都/ 将/ 闪存/ 硬盘/ SSD/ 看成/ 一个/ 块/ 设备/ 并/ 使用/ 与/ 磁盘/ 一样/ 的/ 存取/ 接口/ ,/ 但/ 这/ 两种/ 硬盘/ 的/ I/ // O/ 特性/ 却/ 存在/ 很大/ 的/ 差异/ ./ 闪存/ 硬盘/ 的/ 随机/ 读/ 速度/ 远快/ 于/ 其/ 随机/ 写/ 速度/ ,/ 在/ 一些/ 对/ 性能/ 要求/ 苛刻/ 或者/ 涉及/ 频繁/ 数据处理/ 的/ 应用/ 场合/ ,/ 如/ 数据库/ 服务器/ ,/ 如果/ 不能/ 根据/ 闪存/ 的/ 特性/ 来/ 设计/ 合适/ 的/ 数据结构/ 和/ 算法/ ,/ 就/ 难以/ 获得最佳/ 性能/ ./ 缓冲区/ 是/ 现代/ 计算机/ 最/ 基本/ 的/ 组成部分/ 之一/ ./ 它/ 在/ 存储系统/ 、/ 数据库/ 、/ 网络/ 服务器/ 、/ 文件系统/ 以及/ 操作系统/ 中/ 都/ 有/ 广泛/ 的/ 应用/ ./ 缓冲区/ 置换/ 算法/ 的/ 任何/ 进展/ 都/ 会/ 影响/ 现代/ 计算机/ 的/ 整体/ 性能/ ./ 假设/ 用/ 磁盘/ 做辅/ 存且/ 读写操作/ 的/ 时间延迟/ 相同/ ,/ 那么/ 对于/ 给定/ 大小/ 的/ 缓冲区/ ,/ 现存/ 的/ 缓冲区/ 置换/ 算法/ [/ 2/ -/ 8/ ]/ 的/ 目标/ 就是/ 最小化/ 缓冲区/ 的/ 缺页/ 率/ ./ 当/ 缓冲区/ 已满/ 并且/ 请求/ 的/ 数据/ 页/ 不/ 在/ 缓冲区/ 中/ 时/ ,/ 缓冲区/ 置换/ 算法/ 首先/ 从/ 当前/ 缓冲区/ 选择/ 一个/ 用于/ 置换/ 的/ 数据/ 页/ ,/ 如果/ 所选/ 的/ 数据/ 页/ 是/ 脏页/ (/ 其/ 内容/ 被/ 修改/ 过/ )/ ,/ 就/ 必须/ 将/ 该页/ 的/ 内容/ 写回/ 硬盘/ ,/ 然后/ 才能/ 将/ 请求/ 的/ 数据/ 页/ 读入/ 缓冲区/ ,/ 以/ 保证数据/ 的/ 一致性/ ./ 这种/ 操作/ 可能/ 会/ 成为/ 系统/ 性能/ 的/ 瓶颈/ ,/ 这/ 是因为/ 请求/ 页/ 的/ 线程/ 或/ 进程/ 必须/ 等待/ 写/ 操作/ 的/ 完成/ ./ 早/ 在/ 20/ 年前/ ,/ Effelsberg/ 等/ [/ 9/ ]/ 已经/ 认识/ 到/ 缓冲区/ 中/ 数据/ 页/ 的/ 读写/ 状态/ 是/ 影响/ 置换/ 策略/ 的/ 重要/ 因素/ ,/ 由于/ 闪存/ 硬盘/ 有望/ 替代/ 磁盘/ 成为/ 新一代/ 的/ 数据/ 存储设备/ ,/ 并且/ 闪存/ 硬盘/ 的/ 读写/ 代价/ 存在/ 不对称性/ 问题/ ,/ 在/ 设计/ 置换/ 策略/ 时/ 更/ 应/ 考虑/ 读写/ 状态/ 的/ 差异性/ ./ 针对/ 闪存/ 读写操作/ 的/ 不对称性/ 问题/ ,/ 近几年/ 研究者/ 已经/ 提出/ 了/ 几种/ 适用/ 于/ 闪存/ 的/ 缓冲区/ 置换/ 策略/ [/ 10/ -/ 14/ ]/ ./ 然而/ ,/ 这些/ 置换/ 策略/ 在/ 实际/ 中/ 存在/ 以下/ 问题/ :/ (/ 1/ )/ 适用/ 的/ 闪存/ 硬盘/ 类型/ 有限/ 已有/ 的/ 基于/ 闪存/ 的/ 缓冲区/ 置换/ 算法/ 的/ 基本/ 假设/ 是/ 闪存/ 的/ 随机/ 读/ 代价/ 相对/ 于/ 随机/ 写/ 代价/ 来说/ 可/ 忽略不计/ ,/ 因此/ 这些/ 缓冲区/ 置换/ 策略/ 都/ 是/ 通过/ 无条件/ 先/ 置换/ 只读/ 页/ 来/ 减少/ 随机/ 写/ 操作/ 的/ 次数/ ,/ 从而/ 提高/ 系统/ 的/ 性能/ ./ 然而/ ,/ 如图/ 1/ 所示/ ,/ 该/ 假设/ 和/ 实际/ 情况/ 并/ 不/ 相符/ ,/ 即/ 随机/ 读/ 代价/ 和/ 随机/ 写/ 代价/ 相比/ ,/ 并非/ 在/ 所有/ 情况/ 下/ 都/ 可以/ 被/ 无条件/ 忽略/ ./ 尽管/ 所有/ 的/ 闪存/ 设备/ 都/ 表现/ 出较/ 快/ 的/ 随机/ 读/ 速度/ 和/ 较慢/ 的/ 随机/ 写/ 速度/ ,/ 但/ 对于/ 不同/ 的/ 闪存/ 设备/ 而言/ ,/ 读写/ 代价/ 的/ 比例/ 差别/ 很大/ ,/ 显然/ 在/ 不/ 考虑/ 只读/ 页/ 的/ 操作/ 代价/ 和/ 访问/ 频率/ 的/ 情况/ 下/ 就/ 无条件/ 首先/ 置换/ 只读/ 页/ 是/ 不合理/ 的/ ./ 图/ 1NAND/ 闪存/ 硬盘/ 随机/ 读/ (/ RR/ )/ 和/ 随机/ 写/ (/ RW/ )/ 消耗/ 的/ 时间/ 比例/ (/ X/ 轴为/ 9/ 种/ 闪存/ 硬盘/ ,/ 1/ 是/ 三星/ MCAQE32G8APP/ -/ 0XA/ ,/ 2/ 是/ 三星/ K9WAG08U1A/ ,/ 3/ 是/ 三星/ K9XXG08UXM/ ,/ 4/ 是/ 三星/ K9F1208R0B/ ,/ 5/ 是/ 三星/ K9GAG08B0M/ ,/ 6/ 是/ 现代/ HY27SA1G1M/ ,/ 7/ 是/ 三星/ K9K1208U0A/ ,/ 8/ 是/ 三星/ K9F2808Q0B/ ,/ 9/ 是/ 三星/ MCAQE32G5APP/ ①/ )/ (/ 2/ )/ 多线程/ 处理/ 能力/ 不足/ ①/ 已有/ 的/ 基于/ 闪存/ 的/ 缓冲区/ 置换/ 策略/ 都/ 是/ 基于/ LRU/ 置换/ 策略/ 进行/ 改进/ ,/ LRU/ 的/ 优势/ 在于/ 它/ 实现/ 简单/ ,/ 操作/ 代价/ 低/ ,/ 但/ LRU/ 也/ 有/ 自身/ 的/ 局限性/ :/ ①/ 每次/ 命中/ 的/ 数据/ 页/ 必须/ 移动/ 到/ 最近/ 使用/ (/ MRU/ )/ 的/ 位置/ ./ 实际/ 中/ 多个/ 线程/ 可能/ 都/ 试图/ 移动/ 各自/ 的/ 数据/ 页/ 到/ MRU/ 位置/ ,/ 而/ MRU/ 位置/ 通过/ 锁/ 保护/ 来/ 保证/ 一致性/ 和/ 正确性/ ./ 由于/ 所有/ 命中/ 操作/ 都/ 在/ 等待/ 该/ 操作/ 的/ 完成/ ,/ 就/ 会/ 引起/ 大量/ 锁争/ 用/ 的/ 问题/ ./ 在/ 高性能/ 和/ 高/ 吞吐量/ 环境/ 中/ ,/ 例如/ 虚存/ 、/ 数据库/ 、/ 文件系统/ 和/ 存储/ 控制器/ 中/ ,/ 这种/ 情况/ 是/ 不可/ 接受/ 的/ ./ ②/ LRU/ 没/ 考虑/ 数据/ 页/ 的/ “/ 访问/ 频率/ ”/ ./ 和/ LRU/ 对应/ ,/ CLOCK/ 算法/ 克服/ 了/ LRU/ 算法/ 的/ 上述/ 缺点/ ./ 通过/ 将/ 数据/ 页/ 组织/ 成/ 时钟/ 形式/ 的/ 环形/ 缓冲区/ ,/ CLOCK/ 算法/ 无需/ 在/ 每次/ 命中/ 数据/ 页/ 后/ 移动/ 数据/ 页/ 的/ 位置/ ,/ 因此/ 不会/ 出现/ 锁争/ 用/ 的/ 问题/ ./ 因此/ ,/ CLOCK/ 算法/ 在/ 实际/ 系统/ 中/ ,/ 如/ DB2/ 、/ SQLServer/ 、/ Postgresql/ 等/ ,/ 得到/ 了/ 广泛应用/ ./ 针对/ 现有/ 基于/ 闪存/ 的/ 缓冲区/ 置换/ 算法/ 存在/ 的/ 问题/ ,/ 本文/ 提出/ 一种/ 基于/ 闪存/ 的/ clock/ 算法/ FClock/ 来/ 解决/ 以上/ 问题/ ./ FClock/ 为/ 每个/ 数据/ 页/ 维护/ 一个/ “/ 访问/ 位/ ”/ 并/ 将/ 缓冲区/ 中/ 的/ 数据/ 页/ 组织/ 成/ 两个/ 时钟/ 形式/ ①/ http/ :/ // // www/ ./ datasheetcatalog/ ./ netPage3/ 的/ 环形/ 结构/ CC/ (/ CleanClock/ )/ 和/ DC/ (/ DirtyClock/ )/ ,/ 分别/ 用于/ 管理/ 未修改/ 的/ 数据/ 页/ 和/ 修改/ 过/ 的/ 数据/ 页/ ./ 当/ 数据/ 页/ 被/ 初次/ 读入/ 缓冲区/ 时/ ,/ 它/ 的/ 访问/ 位/ 被/ 置/ 为/ 0/ ./ 当/ 命中/ 某个/ 数据/ 页/ 时/ ,/ 将/ 其/ 访问/ 位加/ 1/ ./ 当/ 需要/ 选择/ 一个/ 置换/ 页/ 时/ ,/ FClock/ 并非/ 直接/ 置换/ 出/ 未修改/ 页/ ,/ 而是/ 首先/ 根据/ 启发式/ 规则/ 判断/ 被/ 置换/ 的/ 数据/ 页/ 是/ 已/ 修改/ 页/ 还是/ 未修改/ 页/ ,/ 然后/ 再/ 从/ DC/ 或者/ CC/ 中/ 找/ 访问/ 位是/ 0/ 的/ 数据/ 页/ 进行/ 置换/ ,/ 以此/ 来/ 进行/ 自/ 适应/ 的/ 调整/ ./ 最后/ ,/ 受/ 文献/ [/ 3/ ]/ 的/ “/ 局部性/ 过滤/ ”/ 原则/ 的/ 启发/ ,/ FClock/ 使用/ 基于/ 平均/ 命中/ 距离/ 的/ 技术/ 来/ 消除/ 短期/ 频繁/ 访问/ 而/ 长期/ 不/ 访问/ 的/ 数据/ 页/ 长时间/ 驻留/ 内存/ 的/ 问题/ ./ 2/ 背景/ 及/ 相关/ 工作/ 2.1/ 闪存/ 存储器/ 一般来说/ ,/ 有/ 两种/ 不同/ 类型/ 的/ 闪存/ 芯片/ ,/ 分别/ 是/ NOR/ 型/ 闪存/ 和/ NAND/ 型/ 闪存/ ./ NOR/ 型/ 闪存/ 芯片/ 和/ EPROM/ 以及/ SRAM/ 一样/ ,/ 有/ 专用/ 的/ 地址/ 和/ 数据总线/ ;/ 而/ NAND/ 闪存/ 芯片/ 无/ 专用/ 的/ 地址/ 和/ 数据总线/ ,/ 用/ 一个/ IO/ 接口/ 来/ 控制/ 输入输出/ ./ NOR/ 型/ 闪存/ 芯片/ 可用/ 来/ 替换/ 可编程/ 的/ 只/ 读存储器/ (/ PROM/ )/ 和/ 可/ 擦除/ 的/ PROM/ (/ EPROM/ )/ 来/ 进行/ 有效/ 的/ 随机存取/ ;/ NAND/ 型/ 闪存/ 芯片/ 由于/ 其/ 存储容量/ 较/ 高/ ,/ 主要/ 用来/ 存储/ 数据/ ./ 闪存/ 硬盘/ (/ SSD/ )/ 中/ 使用/ 的/ 通常/ 是/ NAND/ 型/ 芯片/ ./ NAND/ 型/ 闪存/ 芯片/ 上/ 有/ 3/ 种/ 基本操作/ :/ 读/ 、/ 写/ 和/ 擦除/ ./ 读/ 和/ 写/ 都/ 是/ 以/ 数据/ 页/ 为/ 单位/ 进行/ 操作/ ;/ 擦除/ 是/ 以块/ 为/ 单位/ 进行/ 操作/ ,/ 一个/ 块/ 通常/ 包含/ 64/ 个页/ ./ NAND/ 型/ 芯片/ 不/ 支持/ 原地/ 更新/ ,/ 如果/ 某个/ 页/ 上/ 有/ 数据/ ,/ 就/ 无法/ 对/ 该页/ 直接/ 进行/ 覆盖/ 写/ 操作/ ./ 为了/ 避免/ 对/ 某些/ 块/ 进行/ 频繁/ 的/ 写/ 和/ 擦除/ 操作/ 之后/ 所/ 造成/ 的/ 数据/ 块/ 失效/ 的/ 问题/ ,/ 通常/ 使用/ 磨损/ 平衡/ 技术/ 将/ 写/ 和/ 擦除/ 操作/ 均匀/ 地/ 分布/ 在/ 所有/ 的/ 数据/ 块/ 上/ ./ 为了/ 克服/ 闪存/ 芯片/ 的/ 物理/ 限制/ ,/ 闪存/ 硬盘/ 利用/ 一个/ 软件/ 层来/ 模拟/ 块/ 设备/ 的/ 功能/ ,/ 并/ 尽量/ 使得/ 擦除/ 操作/ 的/ 延迟/ 不/ 为/ 用户/ 所/ 见/ ,/ 这个/ 软件/ 层/ 通常/ 称为/ 闪存/ 转换/ 层/ (/ FTL/ )/ ,/ 它/ 一般/ 存储/ 在/ SSD/ 的/ ROM/ 芯片/ 中/ ./ FTL/ 的/ 主要/ 作用/ 是/ 将/ 对/ 一个/ 数据/ 页/ 的/ 写/ 请求/ 重新/ 映射/ 到/ 一个/ 已/ 擦除/ 的/ 空白/ 数据/ 页/ 上/ ./ 因此/ ,/ FTL/ 需要/ 维护/ 一个/ 内部/ 映射/ 表来/ 记录/ 逻辑/ 地址/ 和/ 物理地址/ 之间/ 的/ 映射/ 信息/ ./ 该/ 映射/ 表在/ 系统启动/ 时/ 构造/ ,/ 并/ 在/ SSD/ 的/ 易/ 失性/ 存储器/ 中/ 进行/ 维护/ ./ FTL/ 的/ 实现/ 细节/ 与/ 具体/ 的/ 设备/ 相关/ ,/ 由/ 制造商/ 提供/ ,/ 对/ 用户/ 是/ 透明/ 的/ ./ 2.2/ 缓冲区/ 置换/ 策略/ 典型/ 的/ 计算机系统/ 包含/ 两层/ 存储器/ ,/ 分别/ 是/ 主存/ (/ 缓冲区/ )/ 和/ 辅存/ (/ 外部/ 存储介质/ ,/ 如/ 磁盘/ 或者/ SSD/ )/ ./ 缓冲区/ 的/ 存取速度/ 远快/ 于/ 辅存/ ,/ 二者/ 一般/ 使用/ 相同/ 大小/ 的/ 数据/ 页/ ./ 已有/ 基于/ 磁盘/ 的/ 缓冲区/ 置换/ 策略/ [/ 2/ -/ 8/ ]/ 假定/ 每次/ 置换/ 操作/ 的/ 代价/ 相同/ ,/ 其/ 目标/ 是/ 最小化/ 缓冲区/ 的/ 缺页/ 率/ ./ 缺页/ 率/ 反映/ 了/ 必须/ 从/ 辅存/ 读入/ 缓冲区/ 的/ 数据/ 页/ 的/ 比例/ ./ CLOCK/ [/ 2/ ]/ 、/ FBR/ [/ 3/ ]/ 、/ LRU/ -/ K/ [/ 4/ ]/ 、/ 2Q/ [/ 5/ ]/ 、/ LIRS/ [/ 6/ ]/ 、/ ARC/ [/ 7/ ]/ 和/ LRFU/ [/ 8/ ]/ 等/ 算法/ 主要/ 通过/ 使用/ 启发式/ 方法/ 来/ 提高/ 系统/ 的/ 性能/ ,/ 通过/ 考虑/ 数据/ 页/ 在/ 缓冲区/ 中/ 的/ 滞留/ 时间/ 和/ 使用/ 频率/ 来/ 减少/ 缺页/ 率/ ./ 由于/ 闪存/ 的/ 读写/ 时间/ 不/ 对称/ ,/ 以上/ 假设/ 对于/ 闪存/ 来说/ 是/ 不/ 成立/ 的/ ./ 因此/ ,/ 当/ 设计/ 基于/ 闪存/ 的/ 缓冲区/ 管理/ 算法/ 时/ ,/ 需要/ 考虑/ 读写/ 的/ 不对称性/ 问题/ ./ 具有/ 不/ 对称/ 存取时间/ 的/ 缓冲区/ 置换/ 问题/ 可/ 模拟/ 成/ 加权/ 缓冲区/ 问题/ ,/ 其/ 目的/ 是/ 最小化/ 请求/ 序列/ 的/ 总/ 代价/ ./ 针对/ 该/ 问题/ ,/ 文献/ [/ 15/ ]/ 提出/ 了/ 复杂度/ 为/ O/ (/ sn2/ )/ 的/ 最优/ 离线/ 算法/ ,/ 其中/ s/ 表示/ 缓冲区/ 中/ 数据/ 页/ 的/ 个数/ ,/ n/ 表示/ 请求/ 序列/ 的/ 长度/ ./ 该/ 问题/ 可/ 进一步/ 归结为/ 最小/ 代价/ 最大/ 流/ 问题/ [/ 16/ ]/ 进行/ 求解/ ./ 由于/ 该/ 算法/ 的/ 时间/ 和/ 空间/ 复杂度/ 很/ 高/ ,/ 即使/ 提前/ 知道/ 完整/ 的/ 请求/ 序列/ ,/ 其/ 运行/ 也/ 需要/ 耗费/ 大量/ 的/ 时间/ 和/ 空间/ 资源/ ./ 对于/ 在线/ 算法/ ,/ 不/ 可能/ 提前/ 知道/ 任何/ 未来/ 的/ 请求/ 序列/ ./ 研究者/ 已经/ 提出/ 了/ 许多/ 在线/ 的/ 基于/ 闪存/ 的/ 缓冲区/ 管理/ 算法/ ./ 基于/ 闪存/ 的/ 缓冲区/ 置换/ 策略/ (/ FAB/ )/ [/ 11/ ]/ 维护/ 了/ 一个/ 块/ 层/ LRU/ 链表/ ,/ 同一/ 物理/ 块/ 的/ 数据/ 页/ 被/ 聚集/ 到/ 一起/ ./ FAB/ 主要/ 用/ 在/ 多数/ 写/ 请求/ 都/ 是/ 顺序/ 写/ 的/ 便携式/ 媒体播放器/ 上/ ./ BPLRU/ [/ 12/ ]/ 也/ 维护/ 了/ 一个/ 块/ 层/ LRU/ 链表/ ./ 与/ FAB/ 不同/ ,/ BPLRU/ 使用/ SSD/ 内部/ 的/ RAM/ 作为/ 缓冲区/ ,/ 将/ 随机/ 写/ 变成/ 顺序/ 写/ 来/ 提高/ 写/ 操作/ 的/ 效率/ 和/ 减少/ 擦除/ 操作/ 的/ 次数/ ./ CFLRU/ [/ 10/ ]/ 是/ 利用/ 闪存/ 读写/ 性能/ 的/ 不对称性/ 提出/ 一种/ 优先/ 置换/ 只读/ 页/ 的/ 缓冲区/ 置换/ 策略/ ,/ 这种/ 策略/ 假设/ 闪存/ 的/ 写/ 代价/ 远远/ 大于/ 读/ 代价/ ./ CFLRU/ 的/ 基本/ 思想/ 如图/ 2/ 所示/ ./ 其中/ LRU/ 链表/ 分成/ 两个/ 部分/ :/ 工作/ 区/ (/ WorkingRegion/ )/ 和/ 置换/ 区/ (/ Clean/ -/ FirstRegion/ )/ ./ 每当/ 发生/ 缺页/ 中断/ 时/ ,/ 如果/ 在/ 置换/ 区中/ 存在/ 只读/ 的/ 数据/ 页/ ,/ CFLRU/ 就/ 会/ 从中/ 选择/ 最近/ 最少/ 使用/ 的/ 只读/ 页/ 进行/ 置换/ ,/ 如图/ 2/ 的/ p6/ ./ 只有/ 当/ 置换/ 区中/ 没有/ 只读/ 页/ 时/ ,/ 才/ 选择/ 链表/ 尾部/ 的/ 修改/ 页/ p7/ 进行/ 置换/ ./ 置换/ 区/ 的/ 大小/ 是/ 由/ 参数/ w/ 控制/ 的/ ./ Page4/ 基于/ 相同/ 的/ 思想/ ,/ 文献/ [/ 13/ ]/ 将/ CFLRU/ 置换/ 区中/ 的/ 数据/ 页/ 根据/ 其/ 修改/ 状态/ 组织/ 为/ 不同/ 的/ 队列/ ,/ 从而/ 可以/ 将/ 选择/ 置换/ 页/ 操作/ 的/ 时间/ 复杂度/ 降为/ O/ (/ 1/ )/ ./ CFDC/ [/ 14/ ]/ 通过/ 对/ CFLRU/ 置换/ 区中/ 的/ 数据/ 页/ 进行/ 重新/ 组织/ 来/ 提升/ CFLRU/ 算法/ 的/ 执行/ 效率/ ./ 如图/ 3/ 所示/ ,/ CFDC/ 的/ 缓冲区/ 也/ 分为/ 两/ 部分/ ,/ 分别/ 是/ 工作/ 区/ (/ WorkingRegion/ )/ 和/ 置换/ 区/ (/ PriorityRegion/ )/ ./ 在/ CFDC/ 的/ 置换/ 区中/ ,/ 根据/ 数据/ 页/ 是否/ 为/ 修改/ 页/ 将/ 其/ 组织/ 到/ 两个/ 队列/ 中/ ,/ 其中/ 只读/ 页/ 放在/ Cleanqueue/ 中/ ,/ 所有/ 的/ 修改/ 页/ 放在/ 不同/ 的/ Cluster/ 中/ ,/ 这些/ Cluster/ 用/ Dirtyqueue/ 进行/ 组织/ ,/ 同一个/ 集合/ 中/ 修改/ 页/ 的/ 物理/ 位置/ 比较/ 接近/ ./ 和/ FAB/ 算法/ 的/ 块/ 层/ LRU/ 算法/ 相比/ ,/ CFDC/ 中/ 的/ 块/ 大小/ 是/ 可变/ 的/ ./ 3FClock/ 算法/ 3.1/ 数据结构/ 如图/ 4/ 所示/ ,/ FClock/ 将/ 缓冲区/ 中/ 的/ 数据/ 页/ 根据/ 其/ 读写/ 状态/ 组织/ 为/ 两个/ 环形/ 数据结构/ CC/ 和/ DC/ ,/ 分别/ 维护/ 只读/ 页/ 和/ 修改/ 页/ ./ 假定/ 缓冲区/ 可以/ 存放/ s/ 个/ 数据/ 页/ ,/ 则/ |/ CC/ ∪/ DC/ |/ =/ s/ ∧/ CC/ ∩/ DC/ =/ / ./ FClock/ 维护/ 了/ 一个/ 全局/ 计数器/ Counter/ ,/ 每当/ 发生/ 一次/ 数据/ 页/ 请求/ ,/ Counter/ 值加/ 1/ ./ 对于/ 缓冲区/ 中/ 的/ 每个/ 数据/ 页/ p/ ,/ FClock/ 为/ 其/ 关联/ 3/ 个/ 变量/ :/ T/ 、/ C/ 和/ I/ ,/ 其中/ T/ 表示/ p/ 进入/ 缓冲区/ 的/ 时间/ (/ 当时/ 的/ Counter/ 值/ )/ ,/ 否则/ 为/ 最近/ 一次/ 被/ 命中/ 的/ 时间/ )/ ;/ C/ 是/ p/ 的/ 访问/ 位/ 计数器/ ,/ 表示/ p/ 被/ 访问/ 的/ 频繁/ 程度/ ;/ I/ 表示/ p/ 最近/ 两次/ 被/ 命中/ 之间/ 对/ 其它/ 数据/ 页/ 访问/ 的/ 次数/ ,/ 称为/ “/ 命中/ 距离/ ”/ ./ 例如/ ,/ 假设/ 数据/ 页/ 的/ 请求/ 序列/ 为/ “/ r1/ ,/ r2/ ,/ r3/ ,/ r4/ ,/ r1/ ”/ ,/ 则/ 在/ 访问/ 完/ 第一个/ r1/ 之后/ ,/ Counter/ =/ 1/ ,/ 因此/ r1/ ./ T/ =/ 1/ ,/ 第二次/ 访问/ 完/ r1/ 后/ ,/ r1/ ./ I/ =/ Counter/ -/ r1/ ./ T/ -/ 1/ =/ 3/ ,/ 表示/ 最近/ 两次/ 命中/ r1/ 之间/ 对/ 其它/ 数据/ 页/ 进行/ 了/ 3/ 次访问/ ,/ r1/ ./ T/ =/ Counter/ =/ 5/ ./ 另外/ FClock/ 还/ 为/ CC/ 和/ DC/ 各/ 维护/ 一个/ 变量/ F/ ,/ 用于/ 表示/ CC/ 和/ DC/ 从/ 最近/ 一次/ 命中/ 数据/ 页/ 后/ 到/ 目前为止/ 发生/ 页/ 缺失/ 的/ 次数/ ./ 图/ 4/ 中/ 的/ 虚线/ 环/ 用于/ 处理/ 循环/ 和/ 序列/ 模式/ 的/ 数据/ 页/ 访问/ ,/ 称为/ 子环/ ,/ CC/ 和/ DC/ 中/ 的/ 子环/ 分别/ 用/ SCCC/ 和/ SCDC/ 表示/ ./ 本文/ 所用/ 符号/ 的/ 意义/ 如表/ 1/ 所示/ ./ 符号/ 名称/ CC/ 维护/ 只读/ 页/ 的/ clock/ (/ CleanClock/ )/ DC/ 维护/ 修改/ 页/ 的/ clock/ (/ DirtyClock/ )/ s/ 缓冲区/ 可/ 容纳/ 的/ 数据/ 页/ 个数/ SCCCCC/ 中/ 的/ 子环/ SCDCDC/ 中/ 的/ 子环/ ζ/ 过去/ s/ 次访问/ 的/ 命中/ 页/ 的/ 平均/ 访问/ 间隔/ CrCw/ 向/ SSD/ 写入/ 一个/ 数据/ 页/ 的/ 代价/ MCCMDCRCCRDCCounter/ 全局/ 计数器/ 3.2/ 基于/ 代价/ 的/ 置换/ 页/ 选择/ 策略/ 如果/ 缓冲区/ 满且/ 当前/ 请求/ 的/ 数据/ 页/ p/ 在/ 缓冲区/ 中/ ,/ 则/ 可/ 直接/ 从/ 缓冲区/ 中/ 访问/ 此页/ ;/ 反之/ ,/ FClock/ 置换/ 策略/ 将/ 按照/ “/ 代价/ ”/ 从/ CC/ 或/ DC/ 中/ 选择/ 一个/ 页/ x/ 进行/ 置换/ ,/ 并/ 从/ SSD/ 读入/ 数据/ 页/ p/ ./ FClock/ 的/ 基本/ 思想/ 是/ :/ CC/ 和/ DC/ 的/ 大小/ 应该/ 和/ 其/ 在/ 过去/ 一段时间/ 内/ 由于/ 数据/ 页/ 缺失/ 所/ 付出/ 的/ 代价/ 成/ 比例/ (/ 式/ (/ 1/ )/ )/ ./ 假设/ 缓冲区/ 最多/ 可放/ s/ 个/ 数据/ 页/ ,/ FClock/ 的/ 置换/ 策略/ 可/ 表述/ 为/ :/ 若/ |/ CC/ |/ </ β/ s/ ,/ 则/ DC/ 过大/ ,/ 那么/ 选择/ DC/ 中/ 指针/ 所指/ 的/ 计数/ 为/ 0/ 的/ 数据/ 页/ 进行/ 置换/ ;/ 反之/ 从/ CC/ 中/ 选择/ 计数/ 为/ 0/ 的/ 数据/ 页/ 进行/ 置换/ ./ 本文/ 中/ 过去/ 一段时间/ 指/ 过去/ s/ 次访问/ ,/ CC/ 的/ 代价/ 记为/ CCC/ ,/ DC/ 的/ 代价/ 记为/ CDC/ ./ 式/ (/ 1/ )/ 表示/ CC/ 的/ 大小/ 占/ 总/ 缓冲区/ 的/ 比例/ ./ 当/ 数据/ 页/ 驻留/ 缓冲区/ 时/ ,/ 在/ 连续/ 两个/ 物理/ 操作/ 之间/ 可能/ 发生/ 多次/ 逻辑/ 操作/ ./ 尽管/ 物理/ 操作/ 体现/ 了/ Page5CC/ 和/ DC/ 实际/ 付出/ 的/ 代价/ ,/ 访问/ 序列/ 却是/ 以/ 逻辑/ 操作/ 的/ 方式/ 呈现/ 的/ ./ 虽然/ 逻辑/ 操作/ 和/ 物理/ 操作/ 不同/ ,/ 但/ 对于/ 系统/ 的/ 性能/ 来说/ 都/ 有/ 影响/ ./ 一方面/ ,/ 物理/ 操作/ 对/ 存取/ 模式/ 变化/ 本身/ 的/ 反应/ 比较/ 迟钝/ ;/ 另一方面/ ,/ 虽然/ 考虑/ 逻辑/ 操作/ 可以/ 快速/ 侦测/ 存取/ 模式/ 的/ 变化/ ,/ 但/ 对于/ 存取/ 模式/ 剧烈/ 变化/ 的/ 情况/ 不太/ 适用/ ./ 可见/ ,/ 单纯/ 使用/ 任何/ 一种/ 操作/ 计算/ 代价/ 都/ 不够/ 全面/ ./ 为了/ 最小化/ 物理/ 操作/ 的/ 代价/ ,/ 受/ 文献/ [/ 17/ ]/ 的/ 启发/ ,/ 本文/ 提出/ 一种/ 基于/ 时钟/ 数据结构/ 并/ 结合/ 物理/ 操作/ 和/ 逻辑/ 操作/ 优点/ 的/ 代价/ 计算/ 方案/ ./ 假定/ 对/ 数据/ 页/ 的/ 存取/ 是/ 相互/ 独立/ 的/ ,/ 缓冲区/ 可以/ 存放/ s/ 个/ 数据/ 页/ ,/ n/ 是/ 被/ 处理/ 文件/ 中/ 数据/ 页/ 的/ 个数/ ,/ 则/ 对/ 某个/ 数据/ 页/ 的/ 逻辑/ 操作/ 在/ 缓冲区/ 中/ 命中/ 的/ 概率/ 是/ s/ // n/ ,/ 而/ 一个/ 逻辑/ 操作/ 被/ 转换/ 为/ 物理/ 操作/ 的/ 概率/ 是/ (/ 1/ -/ s/ // n/ )/ ./ 如式/ (/ 2/ )/ 和/ 式/ (/ 3/ )/ 所示/ ,/ 本文/ 提出/ 的/ 代价/ 计算/ 方案/ 同时/ 考虑/ 了/ 逻辑/ 操作/ 和/ 物理/ 操作/ ./ CDC/ =/ (/ RDC/ ·/ (/ 1/ -/ s/ // n/ )/ +/ MDC/ )/ ·/ (/ Cw/ +/ Cr/ )/ (/ 3/ )/ 当/ 选择/ 一个/ 置换/ 页/ 时/ ,/ 通过/ 考虑/ 逻辑/ 操作/ 的/ 影响/ ,/ FClock/ 可以/ 较/ 快/ 识别/ 存取/ 模式/ 的/ 变化/ 并/ 进行/ 相应/ 的/ 调整/ ./ 而且/ ,/ 由于/ 物理/ 操作/ 的/ 影响/ 也/ 考虑/ 在内/ ,/ FClock/ 可以/ 适应/ 存取/ 模式/ 剧烈/ 变化/ 的/ 情况/ ./ 如前所述/ ,/ 代价/ 的/ 计算/ 基于/ 过去/ 一段时间/ 内/ (/ s/ 个/ 数据/ 页/ 访问/ )/ 的/ 统计/ 结果/ ./ 本文/ 通过/ 使用/ 一个/ 最大/ 长度/ 为/ s/ 的/ 队列/ 来/ 记录/ 过去/ 一段时间/ 数据/ 页/ 的/ 访问/ 情况/ ,/ 队列/ 中/ 每个/ 元素/ e/ 对应/ 了/ 一次/ 数据/ 页/ 的/ 访问/ ,/ e/ 由/ 两个/ 数据/ 成员/ 组成/ :/ nC/ 和/ bHit/ ,/ 其中/ nC/ 的/ 取值/ 可以/ 是/ CC/ 或者/ DC/ ,/ 表示/ 相应/ 的/ 数据/ 页/ 请求/ 发生/ 在/ CC/ 或者/ DC/ 中/ ,/ bHit/ 表示/ 对/ 数据/ 页/ 的/ 访问/ 请求/ 是否/ 命中/ ,/ 以此/ 来/ 区别/ 逻辑/ 操作/ 和/ 物理/ 操作/ ./ 基于/ 该/ 队列/ ,/ 可以/ 在/ 每次/ 发生/ 数据/ 页/ 请求/ 时/ ,/ 在/ O/ (/ 1/ )/ 代价/ 的/ 基础/ 上/ 更新/ CC/ 和/ DC/ 的/ 代/ 价值/ ./ 由于/ 队列/ 长度/ 有限/ ,/ 因此/ 维护/ 该/ 队列/ 所/ 需/ 的/ 内存/ 非常/ 有限/ ./ 代价/ 的/ 计算/ 分为/ 3/ 步/ :/ (/ 1/ )/ 去除/ 头/ 元素/ eh/ ,/ (/ 2/ )/ 加入/ 新元素/ et/ ,/ (/ 3/ )/ 根据/ 以上/ 介绍/ 的/ 方案/ 计算/ 代价/ CCC/ 和/ CDC/ ./ 其中/ 第/ (/ 1/ )/ 步/ 去除/ 队头/ 元素/ 后/ ,/ 和/ 第/ (/ 2/ )/ 步/ 加入/ 新元素/ 后/ 需要/ 根据/ 去除/ 的/ 元素/ 和/ 加入/ 的/ 新元素/ 修改/ 当前/ CC/ 和/ DC/ 对应/ 的/ 逻辑/ 操作/ 和/ 物理/ 操作/ 的/ 次数/ ./ 3.3/ 数据/ 页/ 访问/ 位/ 修改/ 策略/ 虚存/ 、/ 数据库/ 以及/ 文件系统/ 中/ 经常/ 会/ 出现/ 对/ 同一个/ 数据/ 页/ 多次/ 连续/ 访问/ 后/ 不再/ 访问/ 或者/ 间隔/ 较长时间/ 后/ 再/ 访问/ 的/ 问题/ ./ 假设/ 频繁/ 访问/ 的/ 数据/ 页/ 之间/ 的/ 间隔/ 大于/ 两倍/ 缓冲区/ 大小/ ./ 原始/ 的/ clock/ 算法/ (/ 即/ 二次/ 机会/ 算法/ 的/ 改进/ )/ 为/ 每个/ 数据/ 页/ 关联/ 一个/ 访问/ 位/ ,/ 数据/ 页/ 初次/ 进入/ 缓冲区/ 时/ ,/ 访问/ 位置/ 0/ ,/ 当/ 某个/ 数据/ 页/ 在/ 缓冲区/ 中/ 命中/ 时/ ,/ 访问/ 位置/ 1/ ,/ 当时/ 钟/ 指针/ 扫/ 过/ 该页/ 且/ 其/ 访问/ 位为/ 1/ 时/ ,/ 访问/ 位置/ 0/ ./ 显然/ 这种/ 方法/ 会/ 每隔/ 一段时间/ (/ 大于/ 两倍/ 缓冲区/ 大小/ )/ 将/ 频繁/ 访问/ 的/ 数据/ 页/ 置换/ 出/ 缓冲区/ ./ 而/ 改进/ 的/ clock/ 算法/ 要么/ 在/ 每次/ 访问/ 后/ 都/ 让/ 访问/ 位加/ 1/ ,/ 要么/ 在/ 加/ 1/ 的/ 基础/ 上/ 为/ 访问/ 位/ 设定/ 一个/ 最大值/ ,/ 都/ 会/ 导致/ 短时间/ 内/ 频繁/ 访问/ 但/ 以后/ 不再/ 访问/ 的/ 数据/ 页/ 长时间/ 驻留/ 内存/ ./ 因此/ ,/ 对于/ 短时间/ 内/ 频繁/ 访问/ 的/ 问题/ ,/ 本文/ 提出/ 用/ 平均/ 命中/ 距离/ 来/ 解决/ 这一/ 问题/ ./ 定义/ 1/ (/ 平均/ 命中/ 距离/ ζ/ )/ ./ 对于/ 过去/ 一段时间/ 的/ 访问/ 序列/ “/ r1/ ,/ r2/ ,/ …/ ,/ rn/ ”/ 而言/ ,/ 平均/ 命中/ 距离/ 指该/ 序列/ 中/ 所有/ 被/ 命中/ 的/ 数据/ 页/ 的/ 命中/ 距离/ 的/ 平均值/ ,/ 计算方法/ 见式/ (/ 4/ )/ ,/ 其中/ m/ 指/ 过去/ n/ 次访问/ 数据/ 页/ 时/ 命中/ 的/ 次数/ ./ 例如/ ,/ 对于/ 访问/ 序列/ “/ r1/ ,/ r2/ ,/ r2/ ,/ r3/ ,/ r2/ ,/ r5/ ,/ r1/ ,/ r2/ ”/ 而言/ ,/ 假设/ 缓冲区/ 大小/ 为/ 8/ ,/ 初始状态/ 为空/ ./ 当/ 访问/ 最后/ 一个/ r2/ 时/ ,/ 可知/ 在/ 过去/ 8/ 次访问/ 中/ ,/ r1/ 在/ 第/ 7/ 次访问/ 时/ 被/ 命中/ ,/ 其/ 命中/ 距离/ r1/ ./ I/ =/ 5/ ,/ 而/ r2/ 在/ 第/ 3/ 、/ 第/ 5/ 及第/ 8/ 次访问/ 时/ 被/ 命中/ ,/ 其/ 命中/ 距离/ 分别/ 为/ 0/ 、/ 1/ 和/ 2/ ./ 由式/ (/ 4/ )/ 可知/ 该/ 序列/ 过去/ 8/ 次访问/ 的/ 平均/ 命中/ 距离/ 是/ (/ 5/ +/ 0/ +/ 1/ +/ 2/ )/ // 4/ =/ 2/ ./ FClock/ 使用/ 平均/ 命中/ 距离/ 来/ 衡量/ 某次/ 命中/ 是否/ 为/ 短时间/ 内/ 的/ 频繁/ 访问/ ,/ 其/ 访问/ 位/ 修改/ 策略/ 可/ 表述/ 为/ :/ 如果/ 某个/ 数据/ 页/ 的/ 命中/ 距离/ 不/ 小于/ 平均/ 命中/ 距离/ ζ/ ,/ 则/ 该/ 数据/ 页/ 的/ 访问/ 计数/ 加/ 1/ ,/ 否则/ 保持/ 不变/ ./ 需要/ 注意/ 的/ 是/ ,/ 虽然/ 从/ 表面/ 上/ 看/ 该/ 策略/ 可能/ 造成/ 一直/ 频繁/ 访问/ 的/ 数据/ 页/ 的/ 访问/ 位/ 永远/ 不能/ 增加/ 的/ 问题/ ,/ 实际上/ ,/ 如图/ 5/ 和/ 算法/ 1/ 所示/ 的/ 过程/ ,/ Hash/ 表中/ 维护/ 了/ 数据/ 页/ 的/ 有效/ 访问/ 位置/ ,/ 通过/ 该/ 变量/ ,/ 可知/ 频繁/ 访问/ 数据/ 页/ 的/ 访问/ 位/ 的/ 值会/ 得到/ 慢慢/ 增加/ ./ 这/ 一点/ 在/ 算法/ 1/ 后面/ 的/ 例子/ 中/ 进行/ 具体/ 的/ 说明/ ./ Page6/ 由于/ 平均/ 命中/ 距离/ 是/ 基于/ 过去/ 一段时间/ 的/ 访问/ 序列/ 来/ 进行/ 计算/ 的/ ,/ 每当/ 执行/ 一次/ 新/ 的/ 数据/ 页/ 访问/ 时/ ,/ 如果/ 按照/ 式/ (/ 4/ )/ 进行/ 计算/ 的话/ ,/ 显然/ 时间/ 复杂度/ 太高/ ./ 为此/ ,/ 本文/ 提出/ 一种/ 在/ 常量/ 时间/ 内/ 计算/ 平均/ 命中/ 距离/ 的/ 方法/ ./ 如图/ 6/ 所示/ ,/ 计算/ 平均/ 命中/ 距离/ 时/ 使用/ 两种/ 数据结构/ ,/ 分别/ 是/ 队列/ 和/ Hash/ 表/ ./ 队列/ 用于/ 维护/ 过去/ 一段时间/ 内/ 数据/ 页/ 的/ 访问/ 情况/ ,/ 本文/ 实验/ 中/ ,/ 过去/ 一段时间/ 指/ 过去/ s/ 次/ 数据/ 页/ 的/ 访问/ ,/ s/ 是/ 缓冲区/ 中/ 最/ 多/ 容纳/ 的/ 数据/ 页/ 个数/ ,/ 队列/ 中/ 元素/ 的/ 成员/ I/ 、/ T/ 、/ C/ 的/ 意义/ 在/ 3.1/ 节/ 进行/ 了/ 阐述/ ./ Hash/ 表/ 用于/ 记录/ 在/ 过去/ s/ 次访问/ 中/ 队列/ 中/ 的/ 数据/ 页/ 在/ 队列/ 中/ 的/ 有效/ 位置/ ,/ 该/ 有效/ 位置/ 用于/ 计算/ 每个/ 数据/ 页/ 的/ 命中/ 距离/ 以及/ 整个/ 缓冲区/ 的/ 平均/ 命中/ 距离/ ζ/ ./ 限于/ 篇幅/ ,/ 这里/ 用/ 例子/ 来/ 说明/ 如何/ 在/ 常量/ 时间/ 内/ 计算/ 平均/ 命中/ 距离/ ζ/ ./ 例如/ ,/ 对于/ 访问/ 序列/ “/ r1/ ,/ r2/ ,/ r1/ ,/ r1/ ,/ r3/ ,/ r1/ ,/ r3/ ”/ ,/ 假设/ s/ =/ 6/ ,/ 初始/ 情况/ 下/ 队列/ 和/ Hash/ 表均/ 为/ 空/ ./ 为了/ 说明/ 的/ 方便/ ,/ Hash/ 表中/ 数据/ 页/ 在/ 队列/ 中/ 的/ 位置/ 用/ 数据/ 页/ 的/ T/ 值/ 表示/ ./ 该/ 序列/ 的/ 处理过程/ 如下/ :/ (/ 1/ )/ 访问/ r1/ (/ 图/ 5/ (/ a/ )/ )/ ,/ r1/ 的/ I/ 、/ T/ 的/ 值/ 分别/ 是/ 0/ 、/ 1/ ,/ ζ/ =/ 0/ ,/ 然后/ 将/ r1/ 加入/ Hash/ 表中/ ;/ (/ 2/ )/ 访问/ r2/ (/ 图/ 5/ (/ b/ )/ )/ ,/ r2/ 的/ I/ 、/ T/ 值/ 分别/ 是/ 0/ 、/ 2/ 、/ 0/ ,/ ζ/ =/ 0/ ,/ 然后/ 将/ r2/ 加入/ Hash/ 表中/ ;/ (/ 3/ )/ 访问/ r1/ (/ 图/ 5/ (/ c/ )/ )/ ,/ r1/ 的/ I/ 、/ T/ 值/ 分别/ 是/ 0/ 、/ 3/ ,/ 由于/ r1/ 命中/ ,/ 通过/ r1/ 在/ Hash/ 表中/ 找/ 其/ 在/ 队列/ 中/ 的/ 有效/ 位置/ 1/ ,/ 得到/ 有效/ 位置/ 处/ 的/ T/ 值/ 1/ ,/ 进而/ 可以/ 得到/ r1/ 的/ 命中/ 距离/ 1/ ./ 由于/ 1/ >/ ζ/ =/ 0/ ,/ 将/ Hash/ 表中/ r1/ 的/ 有效/ 位置/ 对应/ 的/ I/ 值/ 更新/ 为/ 1/ ,/ 同时/ 更新/ Hash/ 表中/ r1/ 的/ 有效/ 位置/ 更新/ 为/ 3/ ,/ 最后/ 计算/ 平均/ 命中/ 距离/ ζ/ =/ 1/ ;/ (/ 4/ )/ 访问/ r1/ (/ 图/ 5/ (/ d/ )/ )/ ,/ r1/ 的/ I/ 、/ T/ 值/ 分别/ 是/ 0/ 、/ 4/ ,/ 由于/ r1/ 命中/ ,/ 通过/ r1/ 在/ Hash/ 表中/ 找/ 其/ 在/ 队列/ 中/ 的/ 有效/ 位置/ 3/ ,/ 得到/ 有效/ 位置/ 处/ 的/ T/ 值/ 3/ ,/ 进而/ 可以/ 得到/ r1/ 的/ 命中/ 距离/ 0/ ./ 由于/ 0/ </ ζ/ =/ 1/ ,/ 则/ Hash/ 表中/ r1/ 的/ 有效/ 位置/ 及其/ 对应/ 的/ I/ 值/ 不变/ ,/ 最后/ 计算/ 平均/ 命中/ 距离/ 为/ ζ/ =/ 0.5/ ;/ (/ 5/ )/ 访问/ r3/ (/ 图/ 5/ (/ e/ )/ )/ ,/ r3/ 的/ I/ 、/ T/ 值/ 分别/ 是/ 0/ 、/ 5/ ,/ 由于/ r3/ 没有/ 命中/ ,/ 将/ r3/ 及其/ 有效/ 位置/ 5/ 加入/ Hash/ 表中/ ,/ ζ/ 保持/ 不变/ ;/ (/ 6/ )/ 访问/ r1/ (/ 图/ 5/ (/ f/ )/ )/ ,/ r1/ 的/ I/ 、/ T/ 值/ 分别/ 是/ 0/ 、/ 6/ ./ 由于/ r1/ 命中/ ,/ 通过/ r1/ 在/ Hash/ 表中/ 找/ 其/ 在/ 队列/ 中/ 的/ 有效/ 位置/ 3/ ,/ 得到/ 有效/ 位置/ 处/ 的/ T/ 值/ 3/ ,/ 进而/ 可以/ 得到/ r1/ 的/ 命中/ 距离/ 2/ ./ 由于/ 2/ >/ ζ/ =/ 0.5/ ,/ 则/ Hash/ 表中/ r1/ 的/ 有效/ 位置/ 3/ 对应/ 的/ I/ 值/ 变为/ 2/ ,/ 同时/ 将/ Hash/ 表中/ r1/ 的/ 有效/ 位置/ 更新/ 为/ 6/ ,/ 最后/ 计算/ 平均/ 命中/ 距离/ 为/ ζ/ =/ 1/ ;/ (/ 7/ )/ 访问/ r3/ (/ 图/ 5/ (/ g/ )/ )/ ,/ r3/ 的/ I/ 、/ T/ 值/ 分别/ 是/ 0/ 、/ 7/ ./ 由于/ r3/ 命中/ ,/ 通过/ r3/ 在/ Hash/ 表中/ 找/ 其/ 在/ 队列/ 中/ 的/ 有效/ 位置/ 5/ ,/ 得到/ 有效/ 位置/ 处/ 的/ T/ 值/ 5/ ,/ 进而/ 可以/ 得到/ r3/ 的/ 命中/ 距离/ 1/ ./ 由于/ 1/ / ζ/ =/ 1/ ,/ 则/ Hash/ 表中/ r3/ 的/ 有效/ 位置/ 5/ 对应/ 的/ I/ 值/ 变为/ 1/ ,/ 同时/ 将/ Hash/ 表中/ r3/ 的/ 有效/ 位置/ 更新/ 为/ 7/ ,/ 最后/ 计算/ 平均/ 命中/ 距离/ 为/ ζ/ =/ 1/ ./ 计算/ 平均/ 命中/ 距离/ 的/ 方法/ 在/ FClock/ 算法/ 中用/ update/ (/ ζ/ )/ 来/ 表示/ ./ 3.4/ FClock/ 算法/ FClock/ 算法/ 的/ 具体/ 流程/ 如/ 算法/ 1/ 所示/ ./ 在/ 缓冲区/ 未满/ 的/ 初始/ 阶段/ ,/ 即/ |/ CC/ ∪/ DC/ |/ </ s/ ,/ 如果/ 请求/ 页/ p/ 没有/ 命中/ (/ 算法/ 1/ 中/ 的/ CaseII/ )/ ,/ 则/ 根据/ 对/ p/ 的/ 读/ (/ 8/ ~/ 10/ 行/ )/ 或者/ 写/ (/ 12/ ~/ 14/ 行/ )/ 操作/ 类型/ 从/ SSD/ 上/ 读取/ 到/ CC/ 或者/ DC/ 中/ ,/ 最后/ 在/ 第/ 15/ 行/ 更新/ 平均/ 命中/ 距离/ 的/ 值/ ./ 如果/ p/ 命中/ ,/ 即/ p/ ∈/ CC/ ∪/ DC/ ,/ 对应/ 算法/ 1/ 的/ CaseI/ ,/ 如果/ p/ ∈/ CC/ (/ 第/ 1/ 行/ )/ ,/ 则/ CC/ 的/ 逻辑/ 操作/ 次数/ 加/ 1/ ,/ 然后/ 将/ 其/ 命中/ 距离/ 置/ 0/ ;/ 否则/ 如果/ p/ ∈/ DC/ (/ 第/ 2/ 行/ )/ ,/ 则/ DC/ 的/ 逻辑/ 操作/ 次数/ 加/ 1/ ,/ 然后/ 将/ 其/ 命中/ 距离/ 置/ 0/ ./ 如果/ 操作/ 类型/ 是/ write/ 并且/ p/ ∈/ CC/ (/ 第/ 3/ 行/ )/ ,/ 则/ 将/ p/ 从/ CC/ 中移/ 到/ DC/ 中/ ./ 在/ 第/ 4/ 行/ ,/ 如果/ p/ 的/ 命中/ 距离/ 不/ 小于/ 平均/ 命中/ 距离/ ,/ 则/ 将/ p/ 的/ 访问/ 计数/ 加/ 1/ ./ 最后/ 在/ 第/ 5/ 行/ 更新/ 平均/ 命中/ 距离/ 的/ 值/ ./ 算法/ 1/ ./ FClock/ (/ pagep/ ,/ typeT/ )/ ./ // / FClock/ 在/ 每次/ 系统/ 请求/ 数据/ 页/ p/ 时/ 被/ 触发/ ,/ T/ 表示/ CaseI/ :/ p/ ∈/ CC/ ∪/ DC/ // / p/ 被/ 命中/ / // 1/ ./ if/ (/ p/ ∈/ CC/ )/ then/ {/ RCC/ ←/ RCC/ +/ 1/ ;/ CC/ ./ F/ ←/ 0/ ;/ }/ 2/ ./ else/ {/ RDC/ ←/ RDC/ +/ 1/ ;/ DC/ ./ F/ ←/ 0/ ;/ }/ 3/ ./ if/ (/ T/ =/ writeandp/ ∈/ CC/ )/ thenMoveptoDC/ ;/ 4/ ./ if/ (/ p/ ./ I/ / ζ/ )/ then/ {/ p/ ./ C/ ←/ p/ ./ C/ +/ 1/ ;/ }/ 5/ ./ update/ (/ ζ/ )/ ;/ CaseII/ :/ p/ / CC/ ∪/ DC/ // / p/ 没有/ 命中/ / // 6/ ./ if/ (/ |/ CC/ ∪/ DC/ |/ =/ s/ )/ thenevictPage/ (/ )/ ;/ 7/ ./ if/ (/ T/ =/ read/ )/ then8/ ./ RCC/ ←/ RCC/ +/ 1/ ;/ MCC/ ←/ MCC/ +/ 1/ ;/ 9/ ./ fetchpfromthedisk/ ;/ 10/ ./ Insert/ (/ p/ ,/ CC/ )/ ;/ 11/ ./ else12/ ./ RDC/ ←/ RDC/ +/ 1/ ;/ 13/ ./ fetchpfromthedisk/ ;/ 14/ ./ Insert/ (/ p/ ,/ DC/ )/ ;/ Page7SCDC/ )/ ;/ 15/ ./ update/ (/ ζ/ )/ ;/ 过程/ 1/ ./ evictPage/ (/ )/ 1/ ./ β/ ←/ CCC/ // (/ CCC/ +/ CDC/ )/ CaseI/ ./ |/ CC/ |/ </ β/ s/ // / DC/ 过大/ ,/ 从/ DC/ 中/ 移除/ 数据/ 页/ / // 2/ ./ MDC/ ←/ MDC/ +/ 1/ ;/ 3/ ./ LetqbethepagepointedbyclockhandofDC/ (/ or4/ ./ while/ (/ q/ ./ C/ >/ 0/ )/ do/ {/ q/ ./ C/ ←/ q/ ./ C/ -/ 1/ ;/ q/ ←/ q/ -/ >/ next/ ;/ }/ 5/ ./ writeq/ ’/ scontenttoSSD/ ;/ deleteq/ ;/ CaseII/ ./ |/ CC/ |/ / β/ s/ // / CC/ 过大/ ,/ 从/ CC/ 中/ 移除/ 数据/ 页/ / // 6/ ./ LetqbethepagepointedbyclockhandofCC/ (/ orSCCC/ )/ ;/ 7/ ./ while/ (/ q/ ./ C/ >/ 0/ )/ do/ {/ q/ ./ C/ ←/ q/ ./ C/ -/ 1/ ;/ q/ ←/ q/ -/ >/ next/ ;/ }/ 8/ ./ deleteq/ ;/ 过程/ 2/ ./ Insert/ (/ p/ ,/ clockx/ )/ ./ 1/ ./ if/ (/ clockx/ ./ F/ / λ/ |/ clockx/ |/ )/ then2/ ./ addptoSCclockx/ ;/ 3/ ./ elseaddptoclockx/ ;/ 4/ ./ clockx/ ./ F/ ←/ clockx/ ./ F/ +/ 1/ ./ 如果/ 缓冲区/ 已满/ ,/ 当/ 数据/ 页/ 命中/ 时/ ,/ 其/ 操作/ 和/ 前面/ 一段/ 所/ 介绍/ 的/ 内容/ 相同/ ./ 如果/ 数据/ 页/ 没有/ 命中/ ,/ 则/ FClock/ 会/ 在/ 算法/ 1/ 的/ 第/ 6/ 行/ 首先/ 调用/ evictPage/ (/ )/ 从/ CC/ 或者/ DC/ 中/ 选择/ 一个/ 数据/ 页/ 进行/ 置换/ ./ evict/ -/ Page/ 的/ 具体操作/ 见/ 过程/ 1/ ,/ 其/ 基本/ 思想/ 和/ 计算方法/ 已/ 在/ 3.2/ 节中/ 进行/ 了/ 说明/ ./ 然后/ 在/ 第/ 7/ ~/ 14/ 行/ 根据/ 对/ p/ 的/ 操作/ 类型/ 从/ SSD/ 读入/ p/ 并/ 将/ 其/ 放入/ CC/ 或者/ DC/ 中/ ,/ 最后/ 在/ 第/ 15/ 行/ 更新/ 平均/ 命中/ 距离/ 的/ 值/ ./ 在/ FClock/ 中/ ,/ 将/ 数据/ 页/ 插入/ CC/ (/ DC/ )/ 时/ ,/ 调用/ 了/ Insert/ (/ )/ 过程/ ,/ 在/ 第/ 1/ 行会/ 判断/ CC/ (/ DC/ )/ 的/ F/ 值/ (/ 自从/ 最近/ 一次/ 命中/ 后/ 发生/ 的/ 连续/ 页/ 缺失/ 次数/ )/ ,/ 如果/ F/ >/ λ/ |/ clockx/ |/ ,/ 则/ FClock/ 认为/ 目前/ 的/ 数据/ 页/ 存取/ 模式/ 为/ 序列/ 存取/ ,/ 同时/ 构造/ CC/ (/ DC/ )/ 的/ 子环/ SCCC/ (/ SCDC/ )/ ,/ 并/ 将/ p/ 放入/ SCCC/ (/ SCDC/ )/ 中/ ;/ 否则/ 直接/ 在/ 第/ 3/ 行将/ p/ 放入/ CC/ (/ DC/ )/ 中/ ./ 注意/ 子环/ SCCC/ (/ SCDC/ )/ 是/ CC/ (/ DC/ )/ 的/ 一部分/ ./ 在/ 第/ 4/ 行/ ,/ 将/ CC/ (/ DC/ )/ 的/ 缺页数/ F/ 加/ 1/ ./ 过程/ Insert/ 中/ λ/ 是/ 调节/ 因子/ ,/ 取值/ 在/ [/ 0/ ,/ 1/ ]/ 区间/ ./ 例如/ ,/ 对于/ 访问/ 序列/ “/ r1/ ,/ r2/ ,/ r1/ ,/ r1/ ,/ r3/ ,/ r1/ ,/ r3/ ”/ 而言/ ,/ 其/ 过程/ 如下/ :/ (/ 1/ )/ 访问/ r1/ ,/ 没/ 命中/ ./ 从/ SSD/ 上/ 读入/ r1/ 并/ 按照/ 其/ 操作/ 类型/ 放入/ CC/ 或者/ DC/ 中/ ,/ 同时/ 在/ 算法/ 1/ 的/ 第/ 15/ 行/ 使用/ 3.3/ 节/ 介绍/ 的/ 方法/ 更新/ ζ/ =/ 0/ ./ (/ 2/ )/ 访问/ r2/ ,/ 没/ 命中/ ./ 处理过程/ 同/ (/ 1/ )/ ./ (/ 3/ )/ 访问/ r1/ ,/ 命中/ ./ 则/ 在/ 算法/ 1/ 的/ 第/ 4/ 行/ 根据/ r1/ ./ I/ =/ 1/ >/ ζ/ =/ 0/ ,/ 则/ r1/ ./ C/ 加/ 1/ ,/ 如图/ 5/ (/ c/ )/ 所示/ ,/ 然后/ 更新/ ζ/ 的/ 值/ 为/ 1/ ./ (/ 4/ )/ 访问/ r1/ ,/ 命中/ ./ 由于/ r1/ ./ I/ =/ 0/ </ ζ/ =/ 1/ ,/ 则/ r1/ ./ C/ 保持/ 不变/ ,/ 如图/ 5/ (/ d/ )/ 所示/ ,/ 然后/ 更新/ ζ/ 的/ 值/ 为/ 0.5/ ./ (/ 5/ )/ 访问/ r3/ ,/ 没/ 命中/ ./ 和/ r2/ 的/ 处理/ 相同/ ,/ 如图/ 5/ (/ e/ )/ 所示/ ,/ ζ/ 保持/ 不变/ ,/ r3/ ./ C/ =/ 0/ ./ (/ 6/ )/ 访问/ r1/ ,/ 命中/ ./ 注意/ 这时/ r1/ ./ I/ 的/ 计算/ 依赖于/ 图/ 5/ (/ e/ )/ 中/ 的/ Hash/ 表/ ,/ 可知/ r1/ 的/ 有效/ 位置/ 为/ 3/ ,/ 进而/ 可知/ r1/ ./ I/ =/ 2/ >/ ζ/ =/ 0.5/ ,/ 因此/ r1/ ./ C/ =/ r1/ ./ C/ +/ 1/ =/ 2/ ,/ 如图/ 5/ (/ f/ )/ 所示/ ,/ 然后/ 在/ 算法/ 1/ 第/ 5/ 行/ 更新/ ζ/ =/ 1/ ./ (/ 7/ )/ 访问/ r3/ ,/ 命中/ ./ 由于/ r3/ ./ I/ =/ 1/ / ζ/ =/ 1/ ,/ 因此/ r3/ ./ C/ 加/ 1/ ,/ 如图/ 5/ (/ g/ )/ 所示/ ,/ 随后/ 在/ 算法/ 1/ 第/ 5/ 行/ 更新/ ζ/ =/ 1.3/ ./ 5/ 分析/ FClock/ 的/ 自适应性/ 体现/ 在/ 两/ 方面/ :/ (/ 1/ )/ 基于/ 代价/ 的/ 置换/ 策略/ ,/ 当/ 需要/ 选择/ 一个/ 置换/ 页/ 时/ ,/ FClock/ 从/ CC/ 或者/ DC/ 中/ 根据/ 各自/ 的/ 累加/ 代价/ 和/ 公平/ 地/ 选择/ 合适/ 的/ 置换/ 页/ ./ 当读/ 操作/ 较多时/ ,/ CC/ 会/ 慢慢/ 变/ 大/ ,/ 相反/ ,/ DC/ 会/ 慢慢/ 变大/ ./ 因此/ FClock/ 能/ 很/ 好/ 地/ 处理/ 同一/ 闪存/ 读写/ 的/ 不对称性/ 以及/ 不同/ 闪存/ 读写/ 不对称性/ 的/ 巨大/ 差异性/ ,/ 可以/ 应用/ 到/ 不同/ 类型/ 的/ SSD/ 上/ ;/ 另外/ ,/ 由于/ FClock/ 在/ 计算/ 代价/ 时/ 同时/ 考虑/ 了/ 物理/ 操作/ 和/ 逻辑/ 操作/ ,/ FClock/ 可以/ 适应/ 不同/ 的/ 存取/ 模式/ ./ (/ 2/ )/ FClock/ 使用/ 平均/ 命中/ 距离/ 来/ 控制数据/ 页/ 的/ 引用/ 计数/ ,/ 可以/ 使得/ 频繁/ 访问/ 的/ 数据/ 页/ 的/ 引用/ 计数/ 的/ 值/ 慢慢/ 而/ 不是/ 快速/ 增加/ ,/ 可以/ 避免/ 二次/ 机会/ 算法/ 快速/ 换/ 出/ 间隔/ 较长时间/ 后/ 频繁/ 访问/ 的/ 数据/ 页/ 被/ 过早/ 换出/ 的/ 问题/ ,/ 同时/ 可以/ 避免/ 每次/ 命中/ 就加/ 1/ 的/ 改进/ CLOCK/ 算法/ 所/ 造成/ 的/ 无用/ 数据/ 页/ 长时间/ 驻留/ 内存/ 的/ 问题/ ./ 和/ CFLRU/ 及/ CFDC/ 相比/ ,/ FClock/ 考虑/ 了/ 引用/ 计数/ ,/ 并且/ 可以/ 避免/ LRU/ 、/ CFLRU/ 及/ CFDC/ 存在/ 的/ 锁/ 争用/ 问题/ ./ FClock/ 可以/ 很/ 好/ 地/ 处理/ 序列/ 存取/ 模式/ ./ 当/ 需要/ 处理/ 序列/ 引用/ 时/ ,/ FClock/ 使用/ F/ 来/ 检测/ CC/ (/ DC/ )/ 的/ 页/ 缺失/ 次数/ ,/ 当/ 达到/ 一定/ 程度/ 时/ ,/ 即可/ 认为/ 出现/ 了/ 序列/ 存取/ 模式/ ,/ 这时/ ,/ FClock/ 通过/ 构造/ CC/ (/ DC/ )/ 的/ 子环/ SCCC/ (/ SCDC/ )/ 来/ 处理/ 新来/ 数据/ 页/ 的/ 插入/ 和/ 移除/ 操作/ ,/ 从而/ 不会/ 对子/ 环以外/ 的/ 数据/ 页/ 产生/ 影响/ ./ 相比之下/ ,/ CFLRU/ 及/ CFDC/ 没有/ 考虑/ 存取/ 模式/ 的/ 影响/ ,/ 这/ 一点/ 在/ 第/ 4/ 节/ 的/ 实验/ 结果/ 部分/ 也/ 得到/ 了/ 证明/ ./ 当/ 循环/ 请求/ 序列/ 涉及/ 的/ 操作/ 类型/ 既/ 包含/ 读/ 操作/ ,/ 也/ 包含/ 写/ 操作/ 时/ ,/ FClock/ 可以/ 很/ 好/ 地/ 处理/ 循环/ 存取/ 模式/ ./ 原因/ 在于/ 闪存/ 读写/ 代价/ 不/ 对称/ ,/ 而/ FClock/ 根据/ 代价/ 而/ 不是/ 存取/ 的/ 先后顺序/ 选择/ 置换/ 页/ ,/ 因此/ 对于/ 长/ 循环/ 而言/ ,/ FClock/ 将/ 打乱/ 循环/ 存取/ 模式/ 的/ 置换/ 顺序/ ./ 相比之下/ ,/ CFLRU/ 和/ CFDC/ 由于/ 首先/ 置换/ 只读/ 页/ ,/ 因此/ 可以/ 一定/ 程度/ 上/ 打乱/ 循环/ 存取/ 模式/ 的/ 置换/ 顺序/ ,/ 但/ FClock/ 的/ 自适应性/ 使得/ 这种/ Page8/ 打乱/ 存取/ 模式/ 的/ 行为/ 具有/ 自适应性/ ,/ 可以/ 根据/ 不同/ 闪存/ 的/ 读写/ 特点/ 进行/ 调整/ ,/ 而/ CFLRU/ 和/ CFDC/ 不/ 具备/ 这一/ 特点/ ,/ 从而/ 导致/ 其/ 性能/ 下降/ ,/ 这/ 一点/ 在/ 第/ 4/ 节/ 的/ 实验/ 结果/ 中/ 也/ 得到/ 了/ 进一步/ 证明/ ./ 4/ 实验/ 4.1/ 实验/ 环境/ 本文/ 的/ 实验/ 目的/ 是/ 验证/ FClock/ 算法/ 针对/ 不同/ 读写/ 代价/ 的/ SSD/ 的/ 有效性/ ./ 我们/ 选择/ 两种/ SSD/ 进行/ 实验/ :/ (/ 1/ )/ 三星/ MCAQE32G5APP/ ,/ 简便/ 起/ 见/ ,/ 用/ FD1/ 表示/ ;/ (/ 2/ )/ 三星/ MCAQE32G8APP/ -/ 0XA/ ,/ 用/ FD2/ 表示/ ./ FD1/ 和/ FD2/ 的/ 随机/ 读写/ 的/ 比率/ 分别/ 是/ 1118/ 和/ 12/ ./ 这/ 两个/ 闪存/ 硬盘/ 的/ 读写/ 性能/ 存在/ 巨大/ 的/ 差异/ ,/ 这/ 是因为/ FD1/ 是/ 由/ MLC/ 类型/ 的/ NAND/ 芯片/ 构成/ ,/ 而/ FD2/ 是/ 由/ SLC/ 类型/ 的/ NAND/ 芯片/ 构成/ ./ 对/ SSD/ 来说/ ,/ 缓冲区/ 置换/ 算法/ 的/ 性能/ 受/ 物理/ 读写/ 次数/ 的/ 影响/ ,/ 然而/ FTL/ 层/ 的/ 实现/ 是/ 设备/ 相关/ 的/ ,/ 由/ 硬盘/ 制造商/ 提供/ ,/ 并/ 没有/ 为/ 用户/ 提供/ 跟踪/ 读写/ 次数/ 的/ 接口/ ./ 因此/ ,/ 我们/ 选择/ 使用/ 模拟器/ [/ 18/ ]/ 来/ 进行/ 测试/ ./ 我们/ 实现/ 了/ 5/ 种/ 置换/ 策略/ 来/ 进行/ 比较/ ,/ 即/ LRU/ 、/ CLOCK/ [/ 2/ ]/ 、/ CFLRU/ [/ 10/ ]/ 、/ CFDC/ [/ 14/ ]/ 及/ 本文/ 提出/ 的/ FClock/ ./ 所有/ 的/ 置换/ 策略/ 都/ 用/ Visual/ C++/ 实现/ 的/ ./ 我们/ 将/ CFLRU/ 算法/ 中/ “/ 置换/ 区/ ”/ 的/ “/ 窗口/ 大小/ ”/ 设/ 为/ 缓冲区/ 大小/ 的/ 75/ %/ ,/ 将/ CFDC/ 的/ “/ 置换/ 区/ ”/ 的/ “/ 窗口/ 大小/ ”/ 设/ 为/ 缓冲区/ 的/ 50/ %/ ,/ 将/ CFDC/ 的/ “/ 聚类/ 大小/ ”/ 设为/ 64/ ./ 参数/ 取自/ 对应/ 文献/ 实验/ 中/ 所/ 采用/ 的/ 数值/ ./ 我们/ 将/ 数据库/ 的/ 文件大小/ 模拟/ 为/ 64MB/ ,/ 相当/ 图/ 7/ 不同/ 方法/ 在/ FD1/ 上/ 运行/ T1/ ~/ T4/ 时读/ 次数/ 比较/ 于/ 32000/ 个/ 的/ 物理/ 页/ ,/ 每页/ 为/ 2KB/ ./ 缓冲区/ 的/ 大小/ 范围/ 从/ 2000/ 个页/ 到/ 8000/ 个页/ ./ 本文/ 实验/ 中/ ,/ 模拟器/ 假定/ 数据/ 页/ 的/ 大小/ 是/ 2KB/ ,/ 每个/ 数据/ 块/ 包含/ 64/ 个/ 数据/ 页/ ./ 我们/ 生成/ 了/ 4/ 种/ 类型/ 的/ 测试数据/ ,/ 其/ 统计数据/ 如表/ 2/ 所示/ ,/ 其中/ “/ 读/ // 写/ 比率/ ”/ 列中/ 的/ “/ x/ %/ // y/ %/ ”/ 表示/ 对/ 某种/ 测试数据/ 来说/ ,/ 所有/ 请求/ 的/ x/ %/ 为读/ 操作/ 、/ y/ %/ 为/ 写/ 操作/ ;/ “/ 局部性/ ”/ 列中/ 的/ “/ x/ %/ // y/ %/ ”/ 表示/ 对/ 某种/ 测试数据/ 来说/ ,/ 在/ y/ %/ 的/ 页/ 上/ 有/ x/ %/ 的/ 操作/ ./ 编号/ 总/ 的/ 请求/ 读/ // 写/ 比例/ 局部性/ T1300000090/ %/ // 10/ %/ 60/ %/ // 40/ %/ T2300000080/ %/ // 20/ %/ 50/ %/ // 50/ %/ T3300000060/ %/ // 40/ %/ 60/ %/ // 40/ %/ T4300000080/ %/ // 20/ %/ 80/ %/ // 20/ %/ 表/ 1/ 中/ 读写/ 代价/ Cr/ 和/ Cw/ 可以/ 通过/ SSD/ 的/ 技术/ 手册/ 得到/ ,/ 或者/ 通过/ 执行/ 一定量/ 的/ 读写操作/ 后取/ 平均值/ 来/ 获得/ ./ 本文/ 实验/ 所用/ 数据/ 来自/ 于/ 技术/ 手册/ ./ 我们/ 选择/ 以下/ 标准/ 来/ 评价/ 缓冲区/ 置换/ 策略/ :/ (/ 1/ )/ 物理/ 读/ 操作/ 的/ 次数/ ,/ (/ 2/ )/ 物理/ 写/ 操作/ 的/ 次数/ ,/ (/ 3/ )/ 运行/ 时间/ ./ 其中/ 运行/ 时间/ 是/ 通过/ 将/ 读/ 操作/ 和/ 写/ 操作/ 次数/ 之/ 和/ 相加/ 得到/ 的/ ./ 4.2/ 性能/ 比较/ 和/ 分析/ 4.2/ ./ 1/ 读写操作/ 代价/ 差异/ 巨大/ 的/ SSD/ 上/ 性能/ 比较/ 读/ 操作/ 性能/ 比较/ ./ 图/ 7/ 展示/ 了/ 4/ 种/ 已有/ 方法/ 和/ 基于/ 本文/ 提出/ 的/ 基于/ 代价/ 的/ FClock/ 方法/ 在/ FD1/ 上/ 运行/ T1/ 、/ T2/ 、/ T3/ 及/ T4/ 时/ 随机/ 读/ 次数/ 比较/ ./ 可以/ 看出/ ,/ 和/ LRU/ 及/ CLOCK/ 相比/ ,/ 基于/ 闪存/ 的/ 算法/ Page9/ (/ CFLRU/ 、/ CFDC/ 、/ FClock/ )/ 需要/ 更/ 多/ 的/ 读/ 次数/ ,/ 但/ 本文/ 提出/ 的/ 方法/ FClock/ 所/ 需/ 的/ 读/ 次数/ 在/ T1/ 到/ T4/ 上远/ 少于/ CFLRU/ 和/ CFDC/ ./ 可见/ ,/ 不/ 考虑/ 只读/ 页/ 的/ 操作/ 频率/ 就/ 直接/ 进行/ 置换/ 导致/ CFLRU/ 和/ CFDC/ 需要/ 付出/ 很多/ 不必要/ 的/ 物理/ 读/ 操作/ ./ 写/ 操作/ 性能/ 比较/ ./ 图/ 8/ 展示/ 了/ 4/ 种/ 已有/ 方法/ 和/ 基于/ 本文/ 提出/ 的/ 基于/ 代价/ 的/ FClock/ 方法/ 在/ FD1/ 上/ 运行/ T1/ 、/ T2/ 、/ T3/ 及/ T4/ 时/ 随机/ 写/ 次数/ 比较/ ./ 可以/ 看出/ ,/ 基于/ 闪存/ 的/ 算法/ (/ CFLRU/ 、/ CFDC/ 、/ FClock/ )/ 涉及/ 图/ 8/ 不同/ 方法/ 在/ FD1/ 上/ 运行/ T1/ ~/ T4/ 时写/ 次数/ 比较/ 图/ 9/ 不同/ 方法/ 在/ FD1/ 上/ 运行/ T1/ ~/ T4/ 时/ 运行/ 时间/ 比较/ 的/ 写/ 操作/ 的/ 次数/ 远/ 少于/ 基于/ 磁盘/ 的/ LRU/ 和/ CLOCK/ 算法/ ./ 同时/ ,/ 尽管/ CFLRU/ 首先/ 置换/ 只读/ 页/ ,/ 本文/ 提出/ 的/ 方法/ FClock/ 依然/ 好于/ CFLRU/ ,/ 原因/ 是/ 进行/ 置换/ 时/ ,/ 由于/ FD1/ 的/ 读写/ 比例/ 差异/ 巨大/ ,/ 本文/ 方法/ 将/ 在/ 缓冲区/ 中/ 保留/ 更/ 多/ 的/ 修改/ 页/ ./ 运行/ 时间/ 比较/ ./ 图/ 9/ 展示/ 了/ 不同/ 方法/ 在/ FD1/ 上/ 运行/ T1/ 、/ T2/ 、/ T3/ 及/ T4/ 时/ 运行/ 时间/ 的/ 比较/ ./ 可以/ 看出/ ,/ 基于/ 闪存/ 的/ 算法/ (/ CFLRU/ 、/ CFDC/ 、/ FClock/ )/ 所/ 需/ 的/ 运行/ 时间/ 远/ 少于/ LRU/ 和/ CLOCK/ 算法/ ./ 这/ 是因为/ Page10/ 对于/ FD1/ 来说/ ,/ 读写/ 代价/ 相差/ 118/ 倍/ ,/ 而且/ 对/ 基于/ 闪存/ 的/ 置换/ 算法/ 来说/ ,/ CFLRU/ 和/ CFDC/ 优先/ 置换/ 只读/ 页/ ,/ FClock/ 算法/ 给予/ 写/ 操作/ 更/ 高/ 的/ 权重/ ,/ 因此/ 会/ 大量/ 减少/ 写/ 操作/ 的/ 次数/ ,/ 最终/ 导致/ 整体/ 性能/ 提升/ ./ 4.2/ ./ 2/ 读写操作/ 代价/ 差异/ 小/ 的/ SSD/ 上/ 的/ 性能/ 比较/ 读/ 操作/ 性能/ 比较/ ./ 图/ 10/ 展示/ 了/ 4/ 种/ 已有/ 方法/ 和/ 基于/ 本文/ 提出/ 的/ 基于/ 代价/ 的/ FClock/ 方法/ 在/ FD2/ 上/ 运行/ T1/ 、/ T2/ 、/ T3/ 及/ T4/ 时/ 随机/ 读/ 次数/ 比较/ ./ 可以/ 看出/ ,/ 和/ LRU/ 及/ CLOCK/ 相比/ ,/ CFLRU/ 和/ CFDC/ 由于/ 优先/ 置换/ 只读/ 页/ ,/ 因此/ 需要/ 更/ 多/ 的/ 物理/ 读/ 操作/ ./ FClock/ 既/ 考虑/ 了/ 不同/ 读写/ 状态/ 的/ 数据/ 页/ 操作/ 代价/ ,/ 同时/ 也/ 能/ 更好/ 地/ 处理/ 数据/ 页/ 的/ 存取/ 模式/ ,/ 整体而言/ ,/ 图/ 10/ 不同/ 方法/ 在/ FD2/ 上/ 运行/ T1/ ~/ T4/ 时读/ 次数/ 比较/ 图/ 11/ 不同/ 方法/ 在/ FD2/ 上/ 运行/ T1/ ~/ T4/ 时写/ 次数/ 比较/ 虽然/ 也/ 给予/ 写/ 操作/ 较大/ 的/ 权重/ ,/ 但/ 依然/ 能/ 达到/ 和/ LRU/ 及/ CLOCK/ 算法/ 类似/ 的/ 读/ 操作/ 次数/ ./ 写/ 操作/ 性能/ 比较/ ./ 图/ 11/ 展示/ 了/ 不同/ 方法/ 在/ FD2/ 上/ 运行/ T1/ 、/ T2/ 、/ T3/ 及/ T4/ 时/ 随机/ 写/ 次数/ 比较/ ./ 可以/ 看出/ ,/ 由于/ CFLRU/ 和/ CFDC/ 无条件/ 优先/ 置换/ 只读/ 页/ ,/ 因此/ 所/ 需写/ 操作/ 的/ 次数/ 最少/ ./ 而/ 本文/ 提出/ 的/ 方法/ 综合/ 考虑/ 存取/ 模式/ 及/ 物理/ 操作/ 代价/ ,/ 因此/ 在/ 读写操作/ 代价/ 相差/ 不大/ 的/ 情况/ 下/ ,/ 与/ CFLRU/ 和/ CFDC/ 相比/ ,/ 将/ 更/ 多/ 考虑/ 读/ 操作/ 的/ 权重/ ,/ 因此/ 写/ 操作/ 的/ 次数/ 明显/ 多于/ CFLRU/ 和/ CFDC/ ,/ 但/ 仍然/ 少于/ LRU/ 和/ CLOCK/ 算法/ ./ 运行/ 时间/ 比较/ ./ 图/ 12/ 展示/ 了/ 不同/ 方法/ 在/ FD2Page11/ 图/ 12/ 不同/ 方法/ 在/ FD2/ 上/ 运行/ T1/ ~/ T4/ 时/ 运行/ 时间/ 比较/ 上/ 运行/ T1/ 及/ T2/ 后/ 的/ 运行/ 时间/ 比较/ ./ 可以/ 看出/ ,/ 由于/ FD2/ 读写操作/ 的/ 代价/ 相差/ 不/ 大/ ,/ 而/ CFLRU/ 和/ CFDC/ 的/ 读/ 操作/ 次数/ 远远/ 多于/ 其他/ 方法/ ,/ 因此/ 二者/ 所/ 需/ 的/ 总/ 运行/ 时间/ 远/ 多于/ 其他/ 方法/ ./ 而/ 本文/ 提出/ 方法/ 的/ 读/ 次数/ 和/ LRU/ 及/ CLOCK/ 差不多/ ,/ 且/ 写/ 次数/ 比/ LRU/ 及/ CLOCK/ 少/ ,/ 因此/ 整体/ 性能/ 最好/ ./ 4.2/ ./ 3/ 不同/ SSD/ 硬盘/ 的/ 性能/ 比较/ 通过/ 比较/ 图/ 7/ ~/ 图/ 12/ 可以/ 看出/ ,/ 对于/ 读写操作/ 代价/ 差异/ 巨大/ 的/ SSD/ ,/ 如/ FD1/ 、/ LRU/ 和/ CLOCK/ 的/ 整体/ 性能/ 不如/ 基于/ 闪存/ 的/ 置换/ 算法/ ,/ 但/ 对于/ 读写操作/ 代价/ 差异/ 不大/ 的/ SSD/ ,/ 如/ FD2/ 、/ LRU/ 和/ CLOCK/ 的/ 整体/ 性能/ 要/ 好/ 于/ CFLRU/ 及/ CFDC/ ,/ 而/ 本文/ 提出/ 的/ FClock/ 在/ 选择/ 置换/ 页/ 时/ ,/ 根据/ 操作/ 的/ 代价/ 进行/ 操作/ ,/ 可以/ 在/ 只读/ 页/ 和/ 修改/ 页/ 之间/ 进行/ 公平/ 的/ 选择/ ,/ 因此/ 可以/ 适用/ 于/ 不同/ 读写/ 比例/ 的/ SSD/ ./ 5/ 结论/ 和/ 展望/ 针对/ 现有/ 基于/ 闪存/ 的/ 缓冲区/ 管理/ 算法/ 没有/ 考虑/ 不同/ 闪存/ 读写/ 代价/ 不对称性/ 之间/ 的/ 巨大/ 差异性/ 问题/ 以及/ LRU/ 算法/ 存在/ 锁争/ 用/ 问题/ ,/ 本文/ 提出/ 一种/ 基于/ 闪存/ 硬盘/ (/ SSD/ )/ 的/ 自/ 适应/ 缓冲区/ 管理/ 算法/ FClock/ ,/ FClock/ 将/ 缓冲区/ 中/ 的/ 数据/ 页/ 组织/ 为/ 只读/ 环/ 和/ 修改/ 环/ ,/ 使用/ 基于/ 代价/ 的/ 启发式/ 来/ 选择/ 置换/ 页/ ,/ 可/ 在/ 未修改/ 的/ 数据/ 页/ 和/ 已/ 修改/ 的/ 数据/ 页/ 之间/ 进行/ 公平/ 的/ 选择/ ,/ 适用/ 于/ 不同/ 种类/ 的/ SSD/ 及/ 存取/ 模式/ ./ 针对/ 数据库/ 、/ 虚存/ 和/ 文件系统/ 中/ 数据/ 页/ 访问/ 存在/ 高/ 相关性/ 的/ 特点/ ,/ 提出/ 基于/ “/ 平均/ 命中/ 距离/ ”/ 的/ 访问/ 计数/ 方法/ 来/ 调整/ 数据/ 页/ 的/ 访问/ 频率/ ./ 基于/ 不同/ SSD/ 和/ 不同/ 存取/ 模式/ 的/ 实验/ 结果/ 说明/ ,/ FClock/ 的/ 综合性/ 能/ 优于/ 已有/ 方法/ ./ 

