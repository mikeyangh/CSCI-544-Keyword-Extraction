Page1/ 缫丝/ 排序/ 算法/ 杨帆/ 王箭/ 柳亚/ 男/ 曹蕊/ (/ 南京航空航天大学/ 计算机科学/ 与/ 技术/ 学院/ 南京/ 210016/ )/ 摘要/ 文中/ 提出/ 一种/ 改进/ 的/ 排序/ 算法/ ,/ 弥补/ 了/ 快速/ 排序/ 在/ 大规模/ 下/ 堆栈/ 低效/ 及/ 合并/ 排序/ 在/ 小规模/ 下/ 优势/ 不/ 明显/ 的/ 问题/ ./ 算法/ 扩展/ 了/ 合并/ 排序/ 思想/ ,/ 从/ 一种/ 特殊/ 的/ 蚕茧/ 缫丝/ 工艺/ 得到/ 启发/ ,/ 使用/ 2/ ~/ 6/ 个/ 滚轴/ 分离/ 待排/ 序列/ 中/ 的/ 有序/ 片段/ ,/ 在/ 滚轴/ 始/ 末端/ 扩展/ 新/ 数据/ ,/ 从而/ 达到/ 在/ 合并/ 操作前/ 增加/ 有序/ 子/ 序列/ 长度/ 的/ 目的/ ./ 理论/ 推导/ 表明/ ,/ 缫丝/ 排序/ 中/ 的/ 基本操作/ 数量/ 较/ 合并/ 排序/ 减少/ 4.75/ N/ ,/ 相当于/ 将待排/ 序列/ 缩小/ 至/ 原有/ 规模/ 的/ 1/ // 4/ ;/ 效率/ 测试/ 实验/ 表明/ ,/ 缫丝/ 排序/ 在/ 各种/ 规模/ 下均/ 能/ 获得/ 相比/ 最快/ 经典/ 排序/ 算法/ 10/ %/ ~/ 15/ %/ 的/ 稳定/ 优势/ ,/ 相比/ 前人/ 的/ 改进/ 排序/ 算法/ 具备/ 相当/ 的/ 互补性/ ,/ 并/ 能/ 有效/ 降低/ 排序/ 库函数/ 自/ 适应/ 选择/ 算法/ 的/ 实现/ 复杂度/ ./ 关键词/ 缫丝/ 排序/ ;/ 快速/ 排序/ ;/ 自/ 底向上/ 合并/ 排序/ ;/ 随机/ 序列/ ;/ 有序/ 片段/ 1/ 引言/ 排序/ 的/ 意义/ 在于/ 建立/ 索引/ 以/ 简化/ 统计/ 、/ 查询/ 和/ 搜索/ 工作/ ./ 其/ 评价/ 标准/ 取决于/ 对/ 算法/ 普适性/ 及其/ 应/ Page2/ 插入/ 、/ 交换/ 、/ 选择/ 、/ 合并/ (/ 以下/ 简称/ Merge/ )/ 和/ 分布/ [/ 3/ ]/ ./ 合并/ 思想/ 认为/ 排序/ 是/ 多个/ 有/ 序列/ 归并/ 为/ 一个/ 有/ 序列/ 的/ “/ 阶段性/ ”/ 工作/ ,/ 这种/ 思想/ 实际上/ 包含/ 前/ 3/ 类/ 出发点/ 并/ 正好/ 站/ 在/ 分布/ 思想/ 的/ 对立面/ ,/ 因而/ 具有/ 重要/ 意义/ ;/ 插入/ 思想/ 是/ 一个/ 较长/ 有/ 序列/ 和/ 一个/ 单独/ 数据/ 的/ “/ 合并/ ”/ 操作/ ,/ 但/ 其/ 不/ 平衡/ 合并/ 相对/ 低效/ ;/ 交换/ 思想/ 相当于/ 两个/ 长度/ 始终/ 为/ 1/ 的/ 子/ 序列/ 的/ “/ 合并/ ”/ ,/ 这种/ 合并/ 更为/ 精巧/ 但/ 数据结构/ 的/ 选择/ 对/ 性能/ 影响/ 较大/ ;/ 选择/ 相当于/ 合并/ 的/ 一个/ 步骤/ ,/ 合并/ 的/ 策略/ 只/ 保证数据/ 在/ 局部/ 最小/ 因而/ 大大减少/ 了/ 选择/ 操作/ 的/ 数量/ ;/ 分布/ 思想/ “/ 实际上/ 恰/ 与/ 合并/ 相对/ 立/ ”/ [/ 3/ ]/ ,/ 以/ 树形/ 结构/ 来看/ ,/ 两者/ 只是/ 所/ 使用/ 的/ 分布/ 型/ 不同/ ,/ 这/ 使得/ 合并/ 的/ 效率/ 取决于/ 当前/ 的/ 树形/ 规模/ ,/ 而/ 分布/ (/ 基数排序/ )/ 则/ 取决于/ 可取/ 的/ 树形/ 规模/ ,/ 可取/ 规模较/ 小时/ ,/ 基数排序/ 更/ 有效/ ./ 本文/ 在/ 总结/ 最优/ 经典/ 排序/ 算法/ 快速/ 排序/ [/ 1/ ]/ (/ 以下/ 简称/ QuickSort/ )/ 和/ 合并/ 排序/ [/ 1/ ]/ (/ 以下/ 简称/ BottomUpSort/ )/ 及/ 一些/ 改进/ 方案/ 的/ 优缺点/ 之后/ ,/ 提出/ 一种/ 基于/ 随机/ 序列/ 因素/ 分析/ 思想/ 的/ 改进/ 排序/ 算法/ ,/ 这是/ 一个/ 符合/ 克努斯/ 框架/ 的/ 普适性/ 串行/ 排序/ 算法/ ./ 2/ 研究/ 现状/ 研究/ 表明/ ,/ 大/ N/ 下/ 堆排序/ 的/ 计算/ 复杂度/ [/ 4/ ]/ 较/ 合并/ 排序/ 更/ 多/ [/ 2/ ]/ ,/ 递归/ 版本/ 的/ 合并/ 排序/ 较之/ 非/ 递归/ 的/ BottomUpSort/ 同样/ 在/ 大/ N/ 下/ 出现/ 了/ 无法/ 容忍/ 的/ 递归/ 代价/ ,/ Mart/ í/ nez/ 等/ 人/ [/ 5/ ]/ 对/ QuickSort/ 的/ 元素/ 移动/ 次数/ 进行/ 了/ 详细/ 研究/ ,/ Vall/ é/ e/ 等/ 人/ [/ 6/ ]/ 则/ 进一步/ 认为/ QuickSort/ 的/ 确切/ 时间/ 代价/ 应为/ O/ (/ Nlog2N/ )/ ./ 简单/ 的/ 实验/ 证明/ ,/ BottomUpSort/ 在/ N/ >/ 500000/ 时/ 速度/ 最快/ ,/ 而/ QuickSort/ 在/ N/ </ 500000/ 时/ 优势/ 非常明显/ ,/ 相比/ 其他/ 经典/ 算法/ 更快/ ./ 在/ 排序/ 算法/ 的/ 改进/ 工作/ 方面/ ,/ 近年来/ 国内外/ 仍/ 不断/ 有/ 针对/ 经典/ 单线程/ 内部/ 排序/ 算法/ 的/ 改进/ 方案/ 出现/ :/ 祁建宏/ 等/ 人/ [/ 7/ ]/ 针对/ 插入排序/ 中/ 比较/ 操作/ 利用率/ 不高/ 的/ 问题/ ,/ 提出/ 了/ 一种/ 改进/ 的/ 双/ 插入排序/ 算法/ ,/ 可以/ 在/ 一轮/ 比较/ 中/ 获得/ 2/ 个/ 数据/ 的/ 插入/ 位置/ ;/ Wang/ 等/ 人/ [/ 8/ ]/ 提出/ 的/ 改进/ 堆排序/ 算法/ 使用/ N/ 个/ 存储空间/ 获得/ 了/ NlogN/ -/ N/ 的/ 平均/ 时间/ 效率/ ;/ 唐/ 开山/ [/ 9/ ]/ 提出/ 的/ ASH/ 改进/ 堆排序/ 算法/ 和/ 基于/ 该/ 算法/ 的/ 二次/ 堆排序/ 算法/ 减少/ 了/ 堆排序/ 中/ 重构/ 堆/ 的/ 比较/ 次数/ ,/ 获得/ 了/ 相比/ 原始/ 堆排序/ 80/ %/ 的/ 速率/ 提升/ ,/ 但/ 都/ 无法/ 解决/ 堆排序/ 在/ 大/ N/ 下/ 相对/ 其他/ 最优/ 算法/ 低效/ 问题/ ;/ Mansi/ 提出/ 了/ 一些/ 针对/ QuickSort/ 的/ 改进/ [/ 10/ ]/ ,/ 当待排/ 数据/ 值较/ 小且/ 不/ 等/ 时/ ,/ 其中/ 的/ 一种/ 在/ N/ =/ 10000/ 的/ 小规模/ 下/ 可比/ 原始/ QuickSort/ 节省/ 约/ 40/ %/ 的/ 运行/ 时耗/ [/ 11/ ]/ ;/ Kim/ 等/ 人/ [/ 12/ ]/ 研究/ 扩展/ 了/ Bentley/ 和/ Sedgewick/ 的/ 多/ 键值/ QuickSort/ ,/ 提出/ 一种/ 针对/ 相同/ 键值/ 较/ 多/ 情况/ 的/ 改进/ 方案/ ,/ 但/ 在/ 随机/ 输入/ 下/ 不/ 比/ 原始/ 算法/ 快/ ;/ 武汉大学/ 的/ 杨锋英/ 等/ 人/ [/ 13/ ]/ 将/ 快速/ 排序/ 算法/ 与/ 插入排序/ 结合/ ,/ 提出/ 了/ 改进/ 的/ 快速/ 排序/ 算法/ ,/ 在/ 数据/ 受限/ 条件/ 下/ 可以/ 获得/ 相比/ 原有/ QuickSort50/ %/ 的/ 时间/ 优势/ ;/ 西南/ 大学/ 的/ 胡继/ 宽/ 等/ 人/ [/ 14/ ]/ 提出/ 了/ 一种/ 基于/ QuickSort/ 的/ 海量/ 数据/ 快速/ 分组/ 排序/ 算法/ ,/ 在/ 分组/ 数较/ 多时/ 有/ 很/ 好/ 的/ 优势/ ,/ 而/ 当/ 分组/ 较/ 少时/ 则/ 不如/ 快速/ 排序/ ./ BottomUpSort/ 和/ QuickSort/ 这/ 两种/ 最快/ 的/ 排序/ 算法/ 分别/ 在/ 大/ N/ 和/ 小/ N/ 下/ 取得/ 了/ 成功/ ,/ 而/ 其/ 不足之处/ 也/ 十分/ 明显/ ./ BottomUpSort/ 以/ 稳定/ 的/ 高速/ 特征/ 取胜/ ,/ 但/ QuickSort/ 的/ 基本操作/ 数量/ 通常/ 比/ BottomUpSort/ 更少/ ;/ QuickSort/ 中/ 低效/ 堆栈/ 问题/ 成为/ 其/ 大规模/ 排序/ 的/ 瓶颈/ ,/ 两者/ 都/ 无法/ 在/ 大/ N/ 或/ 小/ N/ 下/ 保持/ 最快/ ./ ReelingSort/ 能/ 同时/ 在/ 大/ N/ 和/ 小/ N/ 下/ 超越/ 更快/ 的/ 一方/ ,/ 正是/ 由于/ 它/ 对/ 实际/ 情况/ 和/ 理论/ 框架/ 的/ 兼顾/ ,/ 利用/ 随机/ 序列/ 的/ 固有特征/ ,/ 以/ 生成/ 尽量/ 长/ 的/ 有序/ 子/ 序列/ ,/ 而后/ 回到/ 纯粹/ 的/ 理论/ 最坏/ 假设/ ,/ 像/ BottomUpSort/ 那样/ 保证/ 算法/ 的/ 理论/ 最坏/ 上界/ ./ 3/ 缫丝/ 算法/ (/ ReelingSort/ )/ 3.1/ 算法/ 思想/ 在/ 桑蚕/ 缫丝/ (/ Reelng/ )/ 工艺/ 中/ ,/ 存在/ 一种/ 绕取/ 方法/ 解决/ 双茧/ (/ 两只/ 蚕/ 在/ 一处/ 结成/ 的/ 一种/ 特殊/ 蚕茧/ )/ 的/ 缫丝/ 问题/ ./ 操作者/ 双手/ 各持/ 一根/ 短棍/ (/ 滚轴/ )/ ,/ 同时/ 将/ 两股/ 蚕丝/ 绕取/ 在/ 不同/ 的/ 滚轴/ 上/ ./ 这种/ 绕取/ 工作/ 可以/ 类比/ 为/ 一种/ 含有/ 两个/ 影响/ 因素/ 的/ 简单/ 随机/ 序列/ 分离/ 操作/ ,/ 它/ 给出/ 了/ 一种/ 不错/ 的/ 排序/ 思路/ ./ 缫丝/ 算法/ (/ 以下/ 简称/ ReelingSort/ )/ 的/ 思想/ 可以/ 这样/ 描述/ :/ 在/ 合并/ 前/ 按照/ 影响/ 因素/ 的/ 不同/ 把/ 数据/ 分离/ 在/ 不同/ 子/ 序列/ 中/ ,/ 加长/ 初始/ 有/ 序列/ 长度/ 以/ 减少/ 合并/ 轮数/ ./ 排序/ 方案/ 吸收/ 了/ 合并/ 的/ 思想/ ,/ 其/ 着眼点/ 在于/ 设法/ 增加/ 合并/ 排序/ 中/ 初始/ 子/ 序列/ 的/ 长度/ ,/ 并/ 通过/ 设立/ 多个/ 可供/ 新/ 数据/ 扩展/ 的/ 子/ 序列/ (/ 滚轴/ )/ 实现/ ,/ 数据/ 扩展/ 仅/ 在/ 序列/ 的/ 两端/ 进行/ ,/ 从而/ 避免/ 了/ 相对/ 低效/ 的/ 插入/ 操作/ ./ 简单/ 的/ 实验/ 可以/ 发现/ ,/ 大于/ 等于/ 因素/ 个数/ 的/ 滚轴/ 数量/ 足以/ 将/ 原始/ 序列/ 从头至尾/ 梳理/ 完毕/ ,/ 但/ 在/ 滚轴/ 数量/ 较/ 少时/ ,/ 子/ 序列/ 长度/ 显然/ 不能/ 伸展到/ 序列/ 末端/ ./ 这个/ 问题/ 构成/ 了/ 缫丝/ 排序/ 研究/ 的/ 关键/ :/ 滚轴/ 查找/ 操作/ 会/ 增加/ 开销/ 因而/ 应当/ 加以/ 限制/ ,/ 如何/ 确定/ 滚轴/ 数量/ 以/ 达到最佳/ 加速/ 比是/ 值得/ 研究/ 的/ ./ Page33/ ./ 2/ 算法/ 过程/ 首先/ 说明/ ReelingSort/ 的/ 设计/ 思路/ ./ 设立/ 2/ ~/ 6/ 个/ 一维/ 数组/ 作为/ 滚轴/ (/ 4/ 滚轴/ ReelingSort/ 为/ 最优/ ,/ 见/ 2.3/ 节/ )/ ,/ 对于/ 待排/ 序列/ 中/ 的/ 每个/ 数据/ ,/ 顺序/ 考察/ 其/ 是否/ 能够/ 在/ 当前/ 活动/ 滚轴/ 的/ 两端/ 扩展/ ,/ 具体/ 方式/ 如下/ :/ 如果/ 考察/ 数据/ 比/ 当前/ 滚轴/ 最小/ 数据/ (/ 第/ 1/ 个/ 键值/ )/ 小/ ,/ 则/ 添加/ 在/ 该子/ 序列/ 首部/ ,/ 若/ 比/ 最大/ 数据/ (/ 最后/ 一个/ 键值/ )/ 大/ ,/ 则/ 添加/ 在/ 该子/ 序列/ 尾部/ ,/ 否则/ 考察/ 下/ 一个/ 活动/ 滚轴/ ;/ 若/ 最后/ 一个/ 滚轴/ 仍/ 无法/ 添加/ 数据/ ,/ 则/ 需/ 新建/ 滚轴/ 存放/ 它/ ,/ 并/ 将/ 第/ 1/ 个/ 滚轴/ 由/ 活动状态/ 转为/ 待/ 合并/ 状态/ ,/ 不再/ 接受/ 新/ 的/ 数据/ ,/ 当待/ 合并/ 滚轴/ 数量/ 达到/ 4/ 个/ 时/ (/ 对/ 4/ 滚轴/ ReelingSort/ 而言/ )/ ,/ 采用/ Merge/ 操作/ 将/ 4/ 个子/ 序列/ 整理/ 有序/ 后/ 送回/ 内存/ 并/ 记录/ 其/ 始末/ 位置/ ,/ 滚轴/ 清空/ 后/ 可/ 循环/ 使用/ ;/ “/ 缫丝/ ”/ 完毕/ 后/ ,/ 根据/ 有序/ 子/ 序列/ 始末/ 位置/ 信息/ 进行/ Merge/ 操作/ 生成/ 最终/ 有序/ 序列/ ./ 一个/ 用伪/ 代码/ 描述/ 的/ 算法/ 步骤/ 如下/ ./ 算法/ 1/ ./ ReelingSort/ ./ 输入/ :/ n/ 个/ 元素/ 的/ 数组/ sr/ [/ n/ ]/ 输出/ :/ 按非/ 降序/ 排列/ 的/ 数组/ sr/ [/ n/ ]/ 寄存器/ 说明/ :/ flag/ [/ n/ // 36/ ]/ 是/ 辅助/ 标志/ 位/ 数组/ ,/ 记录/ sr/ 中/ 有序/ 子/ 序列/ 的/ 终止/ 位置/ ,/ buffer/ [/ 8/ ]/ [/ 40/ ]/ 是/ 8/ 个/ 容量/ 为/ 40/ 的/ 滚轴/ (/ 始终/ 只有/ 4/ 个/ 处于/ 可/ 扩展/ 状态/ )/ ,/ Merge/ 函数/ 返回/ 本次/ 合并/ 生成/ 的/ 子/ 序列/ 在/ sr/ 数组/ 中/ 的/ 终止/ 位置/ ,/ pre/ [/ 8/ ]/ 和/ aft/ [/ 8/ ]/ 分别/ 记录/ 滚轴/ 当前/ 最小/ 和/ 最大/ 有效/ 数据/ 位置/ ,/ 初始值/ 为/ 20/ ,/ FOR/ _/ MERGE/ 和/ FOR/ _/ REEL/ 宏/ 分别/ 代表/ 待/ 合并/ 状态/ 和/ 活动状态/ ;/ 1/ ./ buffer/ [/ 0/ ]/ [/ 20/ ]/ ←/ sr/ [/ 1/ ]/ ,/ j/ ←/ 2/ ,/ t/ ←/ 0/ ,/ p/ ←/ 0/ 转步/ 2/ ;/ 2/ ./ whilej/ / n/ ,/ fork/ ←/ ttot/ +/ 3k/ ++/ 考察/ buffer/ [/ k/ ]/ ,/ 若/ sr/ [/ j/ ]/ / buffer/ [/ k/ ]/ [/ pre/ [/ k/ ]/ ]/ 且/ buffer/ [/ k/ ]/ 未/ 溢出/ ,/ buffer/ [/ k/ ]/ [/ -/ -/ pre/ [/ k/ ]/ ]/ ←/ sr/ [/ j/ ++/ ]/ ,/ 转步/ 3/ ;/ 若/ sr/ [/ j/ ]/ / buffer/ [/ k/ ]/ [/ aft/ [/ k/ ]/ ]/ 且/ buffer/ [/ k/ ]/ 未/ 溢出/ ,/ buffer/ [/ k/ ]/ [/ ++/ aft/ [/ k/ ]/ ]/ ←/ sr/ [/ j/ ++/ ]/ ,/ 转步/ 3/ ;/ 若/ 没有/ 滚轴/ 可以/ 添加/ 该/ 数据/ 或/ buffer/ [/ k/ ]/ 已满/ ,/ 转步/ 4/ ;/ 3/ ./ 若/ j/ / n/ ,/ 转步/ 2/ ,/ 否则/ 转步/ 5/ ;/ 4/ ./ buffer/ [/ t/ ]/ _/ mark/ =/ FOR/ _/ MERGE/ ,/ t/ =/ (/ t/ +/ 1/ )/ mod8/ ,/ buffer/ [/ t/ ]/ _/ mark/ =/ FOR/ _/ REEL/ ,/ buffer/ [/ t/ ]/ [/ 20/ ]/ ←/ sr/ [/ j/ ++/ ]/ ;/ 若/ t/ =/ 3/ (/ 此时/ buffer/ [/ 4/ ]/ ~/ buffer/ [/ 7/ ]/ 标记/ 为/ FOR/ _/ MERGE/ ,/ 可/ 供/ 合并/ )/ ,/ flag/ [/ p/ ++/ ]/ ←/ Merge1/ (/ sr/ ,/ buffer/ [/ 4/ ]/ ,/ buffer/ [/ 5/ ]/ ,/ buffer/ [/ 6/ ]/ ,/ buffer/ [/ 7/ ]/ )/ -/ 1/ ;/ 若/ t/ =/ 7/ (/ 此时/ buffer/ [/ 0/ ]/ ~/ buffer/ [/ 3/ ]/ 标记/ 为/ FOR/ _/ MERGE/ ,/ 可/ 供/ 合并/ )/ ,/ flag/ [/ p/ ++/ ]/ ←/ Merge1/ (/ sr/ ,/ buffer/ [/ 0/ ]/ ,/ buffer/ [/ 1/ ]/ ,/ buffer/ [/ 2/ ]/ ,/ buffer/ [/ 3/ ]/ )/ -/ 1/ ;/ 转步/ 3/ ;/ 5/ ./ Merge2/ (/ sr/ ,/ sr/ ,/ flag/ )/ ./ 算法/ 中/ 的/ 两个/ Merge/ 操作/ 稍/ 有/ 差别/ ,/ Merge1/ (/ sr/ ,/ buffer/ ,/ buffer/ ,/ buffer/ ,/ buffer/ )/ 将/ 4/ 个/ 滚轴/ 中/ 的/ 有序/ 子/ 序列/ 合并/ 后/ 保存/ 在/ 数组/ sr/ 中/ ,/ 返回/ 有序/ 子/ 序列/ 的/ 终止/ 位置/ 用于/ flag/ 标志/ 位/ 寄存器/ 标示/ ,/ Merge2/ (/ sr/ ,/ sr/ ,/ flag/ )/ 在/ “/ 缫丝/ ”/ 完毕/ 后/ 根据/ flag/ 标志/ 位/ 提供/ 的/ 有序/ 子/ 序列/ 末端/ 位置/ ,/ 套用/ 经典/ 合并/ 操作/ 将/ sr/ 数列/ 中/ 的/ 数据/ 合并/ 为/ 最终/ 整体/ 有序/ ,/ 并/ 保存/ 在/ sr/ 中/ ./ 另外/ ,/ 程序定义/ 了/ 8/ 个/ 滚轴/ 而/ 不是/ 4/ 个/ ,/ 这是/ 一种/ 程序实现/ 上/ 的/ 设置/ ,/ 当/ 考察/ 数据/ 无法/ 在/ 当前/ 4/ 个/ 活动/ 滚轴/ 上/ 扩展/ 时/ ,/ 它/ 将/ 导致/ 一个/ 新/ 的/ 滚轴/ 被/ 使用/ ,/ 同时/ 处于/ 顶部/ 的/ 第/ 1/ 个/ 活动/ 滚轴/ 将/ 标记/ 为/ FOR/ _/ MERGE/ ,/ 直接/ 将/ 序列/ 写回/ 内存/ 较为/ 浪费/ ,/ 等/ 它们/ 达到/ 一定/ 数量/ 时/ (/ 例子/ 中为/ 4/ 个/ )/ ,/ 通过/ Merge/ 合并/ 后写/ 回/ 内存/ ./ 根据/ 这个/ 算法/ 步骤/ 进行/ 的/ “/ 缫丝/ ”/ 实/ 例如/ 图/ 1/ ,/ 为/ 加快/ 演示/ 进度/ ,/ 随机/ 数据/ 已经/ 进行/ 了/ 特殊/ 组织/ 以/ 缩短/ 序列/ 长度/ ./ 3.3/ 滚轴/ 数量/ 的/ 确定/ 缫丝/ 算法/ 实际上/ 将/ 待/ 排序/ 数据/ 视为/ 不同/ 主导/ 因素/ 影响/ 下/ 的/ 随机样本/ 序列/ ,/ 使用/ 滚轴/ 尽量/ 分离/ 这些/ 数据/ 以/ 得到/ 更长/ 的/ 有序/ 子/ 序列/ 片段/ ./ BottomUpSort/ 合并/ 模式/ 的/ 保留/ 使得/ 其/ 最坏/ 情况/ 仍然/ 是/ O/ (/ NlogN/ )/ 的/ ,/ 因而/ 比/ QuickSort/ 更/ 稳定/ ./ 显然/ ,/ ReelingSort/ 算法/ 的/ 时间/ 代价/ 取决于/ 滚轴/ 可以/ 绕取/ 的/ 子/ 序列/ 平均/ 长度/ ,/ 而/ 该/ 数值/ 又/ 取决于/ 滚轴/ 数量/ ./ ReelingSort/ 算法/ 的/ 关键/ 是/ 要/ 获得/ 滚轴/ 数量/ 的/ 折中/ ./ 一方面/ ,/ 更/ 多/ 的/ 滚轴/ 能够/ 增加/ 子/ 序列/ 平均/ 长度/ ,/ 但会/ 导致/ 查找/ 这些/ 子/ 序列/ 的/ 代价/ 增加/ ;/ 另一方面/ ,/ 少量/ 的/ 子/ 序列/ 固然/ 可以/ 忽略/ 查找/ 代价/ ,/ 但/ 选择/ 余地/ 的/ 减少/ 又/ 会/ 使子/ 序列/ 长度/ 降低/ ./ 在/ 使用/ 不同/ 微机/ 进行/ 了/ 大量/ 序列/ 规模/ 不/ 等/ 的/ 测试/ 后/ 发现/ :/ 使用/ 2/ 个/ 滚轴/ 时/ ,/ ReelingSort/ 平均/ 花费/ 2.2/ N/ 的/ 代价/ 可以/ 使子/ 序列/ 平均/ 长度/ 达到/ 6/ ;/ 使用/ 4/ 个/ 滚轴/ 时/ ,/ 3.2/ N/ 次/ 比较/ 可以/ 使子/ 序列/ 平均/ 长度/ 达到/ 10/ ;/ 使用/ 6/ 个/ 滚轴/ 时/ ,/ 3.8/ N/ 次/ 比较/ 则/ 能/ 构造/ 平均/ 长度/ 为/ 14/ 的/ 子/ 序列/ ./ 通过/ 计算/ 不难/ 发现/ ,/ 2/ 轴/ 的/ ReelingSort/ 并/ 不/ 具有/ 实际意义/ ,/ 其/ 基本操作/ 数量/ 为/ 1.75/ Nlog/ (/ N/ // 3/ )/ +/ 1.4/ N/ ,/ 其中/ N/ =/ 3/ ×/ 2k/ +/ 2/ ,/ 与/ BottomUpSort/ 基本/ 持平/ ,/ 而/ 6/ 轴/ 的/ ReelingSort/ 虽然/ 理论/ 速度/ 更/ 快/ (/ 其/ 基本操作/ 代价/ 为/ 1.75/ Nlog/ (/ N/ // 21/ )/ +/ 4.3/ N/ ,/ 其中/ N/ =/ 21/ ×/ 2k/ +/ 2/ )/ ,/ 但/ 实际/ 的/ 效率/ 测试表明/ 其/ 寄存器/ 变量/ 查找/ 代价/ 已经/ 开始/ 超过/ 序列/ 长度/ 增加/ 节约/ 的/ 合并/ 排序/ 代价/ ,/ 因此/ 4/ 轴/ ReelingSort/ 是/ 当前/ 兼具/ 理论/ 代价/ 优势/ 和/ 优良/ 实际/ 表现/ 的/ 选择/ ,/ 其/ 基本操作/ 代价/ 将/ 在/ 后面/ 详细/ 说明/ ./ Page4/ 图/ 1ReelingSort/ 滚轴/ 绕取/ 数据/ 情况/ 演示/ 3.4/ 滚轴/ 数据结构/ ReelingSort/ 的/ 由/ 前/ 至/ 后/ 顺序/ 查找/ 方式/ 可以/ 保证/ 找到/ 的/ 第/ 1/ 个/ 可/ 添加/ 位置/ 必定/ 是/ 最佳/ 位置/ ,/ 图/ 2/ 示例/ 性/ 地/ 说明/ 了/ 这/ 一/ 过程/ ./ 4/ 个/ 滚轴/ 当前/ 的/ 使用/ 情况/ 如图/ 2/ :/ 滚轴/ 1/ 上/ 最小/ 的/ 数据/ 是/ 12/ ,/ 最大/ 的/ 数据/ 是/ 876/ ,/ 其它/ 滚轴/ 类似/ ,/ 滚轴/ 长度/ 定性/ 地/ 表现/ 了/ 元素/ 跨越/ 的/ 数值/ 范围/ ,/ 它们/ 是/ 层级/ 包含/ 的/ ,/ 下级/ 滚轴/ 包含/ 于/ 上级/ 滚轴/ ./ 滚轴/ 两端/ 的/ 无框/ 数值/ 标示/ 了/ 数据/ 可以/ 扩展/ 的/ 8/ 个/ 位置/ ./ 假设/ 需要/ 添加/ 的/ 数值/ 为/ 276/ ,/ 贪心/ 逻辑/ 搜索/ 至/ 最后/ 一个/ 滚轴/ (/ 滚轴/ 4/ )/ 仍然/ 无法/ 扩展/ 它/ (/ 219/ </ 276/ </ 354/ )/ ,/ 这/ 将/ 导致/ 位置/ 9/ 上/ 新建/ 一个/ 滚轴/ ,/ 并/ 使/ 滚轴/ 1/ 由/ FOR/ _/ REEL/ 转为/ FOR/ _/ MERGE/ 状态/ ./ 当/ 数值/ 为/ 68/ 的/ 数据/ 到来/ 时/ ,/ 贪心/ 逻辑/ 同样/ 从/ 位置/ 1/ 开始查找/ ,/ 第/ 1/ 个/ 可/ 添加/ 位置/ 为/ 5/ (/ 68/ / 107/ )/ ./ 这种/ 添加/ 位置/ 的/ 选择/ 方式/ 能够/ 保证/ 新/ 数据/ 在/ 当前/ 最优/ 位置/ 上/ 扩展/ ,/ 能够/ 保证/ 子/ 序列/ 长度/ 最大化/ ,/ 不难/ 说明/ 这种/ 数据/ 添加/ 方式/ 将/ 始终保持/ 层级/ 包含/ 特征/ ,/ 并且/ 较长/ 的/ FOR/ _/ MERGE/ 状态/ 滚轴/ 应当/ 是/ 方差/ 较/ 小/ 的/ 优良/ 子/ 序列/ ./ 但是/ 使用/ 贪心/ 逻辑/ 确定/ 数据/ 添加/ 位置/ 的/ 方式/ 并/ 不是/ 最优/ 的/ ./ 图/ 2/ 的/ 8/ 个/ 可/ 扩展/ 位置/ 实际上/ 将/ 数轴/ 分成/ 了/ 9/ 段/ :/ …/ …/ 12/ …/ …/ 34/ …/ …/ 107/ …/ …/ 219/ …/ …/ 354/ …/ …/ 543/ …/ …/ 783/ …/ …/ 876/ …/ …/ ,/ 因此/ 使用/ 二分/ 查找/ 确定/ 数据/ 的/ 添加/ 位置/ 将/ 加快/ 定位/ 速度/ ,/ 前/ 文/ 提到/ 的/ 平均/ 3.2/ N/ 查找/ 代价/ 是/ 选择/ 二分/ 查找/ 后/ 优化/ 的/ 结果/ ./ 4/ 算法/ 效率/ 分析/ 4.1/ 时间/ 复杂度/ 选择/ BottomUpSort/ 自/ 底向上/ 非/ 递归/ 合并/ 排序/ 作为/ 4/ 轴/ ReelingSort/ 的/ 理论/ 时间/ 复杂度/ 比较/ 对象/ ,/ 分析/ 显示/ ,/ ReelingSort/ 比/ BottomUpSort/ 平均/ 节省/ 约/ 1.8/ N/ 的/ 基本操作/ 代价/ ./ 为/ 方便/ 比较/ ,/ 令/ N/ =/ 10/ ×/ 2k/ +/ 2/ ./ BottomUpSort/ 共需/ k/ +/ 5/ 轮/ 合并/ ;/ ReelingSort/ 在/ 缫丝/ 完成/ 后/ 恰好/ 需/ k/ 轮/ 合并/ 操作/ ,/ 缫丝/ 过程/ 中/ 每个/ 数据/ 平均/ 需/ 3.2/ 次/ 比较/ 绕取/ 在/ 滚轴/ 上/ ,/ 因而/ 比较/ 代价/ 为/ 3.2/ N/ ;/ 4/ 个/ 滚轴/ 上/ Page5/ 数据/ 的/ 平均/ 长度/ 为/ 10/ ,/ 两轮/ 两/ 两/ 合并/ 操作/ 共需/ 进行/ N/ // 40/ 轮/ ;/ 从/ 内存/ 逐个/ 读写/ 一次/ 数据/ ,/ 因此/ 赋值/ 次数/ 表/ 1BottomUpSort/ 和/ ReelingSort/ 理论/ 代价/ 详表/ 最多/ 比较/ 次数/ BottomUpSort/ ∑/ k/ +/ 3ReelingSort2j/ (/ 2j/ -/ 1/ )/ +/ 24/ ×/ 2k/ +/ 2/ -/ 410/ +/ 2.4/ N/ +/ 12j/ (/ 2j/ -/ 1/ )/ +/ 24/ ×/ 2k/ +/ 2/ -/ 410/ +/ 2.4/ N/ +/ 1/ 将/ 上述/ 理论/ 代价/ 相减/ 后/ 易得/ ,/ 4/ 轴/ ReelingSort/ 将/ 比/ BottomUpSort/ 节省/ 基本操作/ (/ 最少/ 最/ 多/ 平均/ )/ :/ 1.75/ N2/ ./ 275N1/ ./ 775N/ ,/ 这里/ 将/ 赋值/ 和/ 比较/ 视为/ 等/ 代价/ 操作/ ./ 4.2/ 空间/ 复杂度/ ReelingSort/ 算法/ 的/ 空间/ 复杂度/ 为/ O/ (/ N/ )/ ,/ 与/ BottomUpSort/ 持平/ ,/ 与/ 其他/ 最优/ 排序/ 算法/ 相比/ 使用/ 了/ 典型/ 的/ 空间/ 换/ 时间/ 策略/ ./ 与/ 合并/ 排序/ 类似/ ,/ 缫丝/ 排序/ 需要/ 一个/ 大小/ 为/ N/ 的/ 辅助存储器/ 实现/ Merge/ 操作/ 中/ 数据/ 的/ 轮转/ 缓存/ ;/ 另外/ ,/ 程序/ 中/ 用于/ 指示/ 有序/ 子/ 序列/ 末端/ 位置/ 的/ flag/ 标志/ 位/ 平均/ 数量/ 为/ N/ // 40/ 个/ ,/ 由于/ 大小/ 在/ N/ 数量级/ ,/ 对/ 其/ 进行/ 的/ 赋值/ 操作/ 不能/ 视为/ 寄存器/ 赋值/ ;/ 4/ 轴/ ReelingSort/ 用于/ 绕丝/ 的/ 滚轴/ 为/ 寄存器/ 中/ 的/ 一个/ 8/ ×/ 40/ 二维/ 数组/ ,/ 在/ 规模/ N/ 较大/ 时该/ 部分/ 空间/ 代价/ 可以/ 忽略不计/ ,/ 因此/ ReelingSort/ 所需/ 存储空间/ 总共/ 约/ 为/ 1.025/ N/ ./ 4.3/ 效率/ 测试/ 实验/ 本节/ 将/ 通过/ 实际/ 的/ C++/ 编程/ 实现/ 测试/ Reel/ -/ ingSort/ 算法/ 和/ 其它/ 最优/ 排序/ 算法/ 的/ 效率/ 表现/ ,/ 实验/ 结果显示/ ReelingSort/ 相比/ 小规模/ 下/ 更/ 快/ 的/ Quick/ -/ Sort/ 和/ 大规模/ 下/ 更/ 快/ 的/ BottomUpSort/ 始终/ 能/ 保持/ 10/ %/ ~/ 15/ %/ 的/ 稳定/ 优势/ ./ 在/ N/ </ 500000/ 时/ 将/ ReelingSort/ 与/ QuickSort/ 比较/ ,/ 之后/ 与/ 更/ 快/ 的/ BottomUpSort/ 进行/ 比较/ ;/ S/ 定为/ N/ 的/ 100/ 倍/ ;/ 在/ 5/ ×/ 104/ ~/ 50/ ×/ 104/ 区间/ ,/ 测试/ 实验/ 每次/ 对/ 规模/ N/ 增加/ 5/ ×/ 104/ ,/ 50/ ×/ 104/ ~/ 500/ ×/ 104/ 区间/ 以/ 50/ ×/ 104/ 递增/ ,/ 500/ ×/ 104/ ~/ 5000/ ×/ 104/ 之间/ 以/ 500/ ×/ 104/ 递增/ ./ 根据/ ReelingSort/ 与/ QuickSort/ 实验/ 数据/ 绘制/ 的/ 时耗/ 折线图/ 如图/ 3/ ./ 显然/ 两者/ 的/ 时耗/ 随着/ 规模/ 增大/ 都/ 是/ 线性/ 稳定/ 的/ ,/ 而/ ReelingSort/ 相比/ QuickSort/ 存在/ 约/ 15/ %/ 的/ 稳定/ 运行/ 时间/ 优势/ ./ 为/ 2N/ ;/ 另外/ ,/ flag/ 寄存器/ 的/ 使用/ 数量/ 为/ N/ // 40/ 个/ ,/ 因此/ 缫丝/ 部分/ 赋值/ 代价/ 总共/ 为/ 2N/ +/ N/ // 40/ ./ 根据/ ReelingSort/ 与/ BottomUpSort/ 实验/ 数据/ 绘制/ 的/ 时耗/ 折线图/ 如图/ 4/ (/ a/ )/ 、/ (/ b/ )/ ./ 同样/ 地/ ,/ 两者/ 的/ 时耗/ 随着/ 规模/ 增大/ 线性/ 稳定/ ,/ 这/ 说明/ 实验/ 程序执行/ 是/ 有效/ 可控/ 的/ ,/ 而/ ReelingSort/ 相比/ BottomUpSort/ 同样/ 存在/ 约/ 10/ %/ 的/ 稳定/ 运行/ 时间/ 优势/ ./ 4.4/ 结果/ 分析/ 与/ 数值/ 修正/ 以上/ 分析表明/ ,/ ReelingSort/ 的/ 理论/ 基本/ 操作数/ Page6/ 量/ 比/ BottomUpSort/ 平均/ 减少/ 1.8/ N/ 左右/ ,/ 实际/ 运行/ 耗时/ 相比/ 小/ N/ 下/ 最快/ 的/ QuickSort/ 减少/ 约/ 15/ %/ ,/ 相比/ 大/ N/ 下/ 最快/ 的/ BottomUpSort/ 减少/ 约/ 10/ %/ ,/ 且/ 优势/ 稳定/ ./ 这/ 表明/ ReelingSort/ 在/ 任意/ 规模/ 下/ 都/ 是/ 一个/ 表现/ 良好/ 的/ 算法/ ./ 不难/ 发现/ 缫丝/ 算法/ 的/ 理论/ 优势/ 和/ 实际/ 优势/ 间/ 存在/ 一定/ 差异/ ,/ 以/ N/ =/ 500000/ 时/ 测试/ 结果/ 为例/ ,/ 理论/ 推导/ 的/ ReelingSort/ 运行/ 时耗/ 应/ 比/ BottomUpSort/ 减少/ 5.6/ %/ ,/ 但/ 实验/ 数据/ 显示/ 其/ 相比/ 后者/ 减少/ 9/ %/ 左右/ ,/ 这是/ 由于/ 实际/ 的/ 比较/ 和/ 赋值/ 操作/ 不/ 完全/ 等价/ 造成/ 的/ ./ 定义/ 操作/ A/ 与/ 操作/ B/ 在/ 相同/ 软硬件/ 上/ 运行/ 消耗/ 时间/ 的/ 比值/ 为/ A/ 与/ B/ 的/ 时耗/ 比/ ,/ 简单/ 的/ 实验/ 证明/ 两者/ 准确/ 的/ 时耗/ 比/ 应为/ 12/ ./ 由/ 4.1/ 节/ 可知/ ,/ ReelingSort/ 的/ 比较/ 操作/ 比/ BottomUpSort/ 多/ 1.2/ N/ ,/ 而/ 赋值/ 操作/ 比/ 后者/ 少/ 2.975/ N/ ,/ 缫丝/ 算法/ 将/ 更/ 多/ 的/ 处理/ 代价/ 花/ 在/ 了/ 相对/ 更为/ 省时/ 的/ 比较/ 操作/ 上/ ,/ 考虑/ 比较/ 和/ 赋值/ 操作/ 权值/ 后/ 的/ 新/ 比例式/ 为/ ReelingSort/ 基本操作/ 数量/ BottomUpSort/ 基本操作/ 数量/ =/ (/ 34NlogN/ (/ 4NlogN3/ ≈/ N/ =/ 5000000.907/ ./ 修正/ 的/ 理论/ 时耗/ 比/ 0.907/ 与/ 实验/ 数值/ 0.91/ 非常/ 接近/ ;/ 此时/ ReelingSort/ 将/ 比/ BottomUpSort/ 节约/ 4.75/ N/ 单位/ 耗时/ (/ 赋值/ 操作/ 为/ 2/ 个/ 单位/ 耗时/ )/ ,/ 计算/ BottomUpSort/ 中前/ 两轮/ 的/ 合并/ 操作/ 代价/ 为/ N2/ (/ 第/ 1/ 轮/ 比较/ 代价/ )/ +/ 2.5/ ×/ N2N/ (/ 第/ 1/ 轮/ 赋值/ 代价/ )/ +/ 2N/ (/ 第/ 2/ 轮/ 赋值/ 代价/ )/ =/ 5.125/ N/ ./ 这部分/ 耗时/ 与/ ReelingSort/ 节约/ 的/ 4.75/ N/ 耗时/ 接近/ ,/ BottomUpSort/ 在/ 前/ 两轮/ 合并/ 中将/ 数列/ 规模/ 缩减/ 为/ 1/ // 4/ ,/ 因此/ 从/ 这个/ 角度看/ ,/ ReelingSort/ 的/ 优化/ 相当于/ 把/ 原有/ 数列/ 规模/ 缩小/ 为/ 1/ // 4.4/ ./ 5/ 与/ 其它/ 改进/ 方案/ 的/ 比较/ 本节/ 将/ 以/ 经典/ 算法/ 效率/ 为/ 基准/ ,/ 通过/ 缫丝/ 算法/ 与/ 其他/ 改进/ 排序/ 算法/ 的/ 相对/ 比较/ 说明/ 算法/ 的/ 现实/ 优势/ ./ 比较/ 结果显示/ :/ ReelingSort/ 作为/ 一种/ 普适性/ 最优/ 排序/ 算法/ ,/ 相比/ 双/ 插入排序/ [/ 7/ ]/ 这样/ 的/ 非/ 最优/ 算法/ 优势/ 非常明显/ ;/ 与/ 唐/ 开山/ [/ 9/ ]/ 提出/ 的/ 二次/ 堆排序/ 算法/ 相比/ 在/ 大规模/ 输入/ 下/ 更/ 快/ ,/ 但/ 在/ 小规模/ 时/ 不如/ 后者/ ,/ 因而/ 具有/ 良好/ 的/ 互补性/ ;/ 与/ 杨锋英/ 等/ 人/ [/ 13/ ]/ 提出/ 的/ 改进/ 快速/ 排序/ 算法/ 和/ 胡继/ 宽/ 等/ 人/ [/ 14/ ]/ 提出/ 的/ 改进/ 快速/ 排序/ 算法/ 相比/ ,/ 开销/ 在/ 满足/ 后/ 两者/ 输入/ 要求/ 的/ 情况/ 下/ 基本/ 持平/ ,/ 但/ 在/ 算法/ 普适性/ 方面/ 则/ 有/ 明显/ 优势/ ;/ Wang/ 等/ 人/ [/ 8/ ]/ 提出/ 的/ 改进/ 堆排序/ 算法/ 以及/ Mansi/ [/ 10/ -/ 11/ ]/ 、/ Kim/ [/ 12/ ]/ 等/ 人/ 对/ QuickSort/ 的/ 改进/ 相比/ 其它/ 改进/ 稍慢/ 或/ 出发点/ 类似/ ,/ 在/ 此/ 不/ 做/ 详细/ 比较/ ./ 祁建宏/ 等/ 人/ [/ 7/ ]/ 提出/ 的/ 双/ 插入排序/ 算法/ 是/ 一种/ 针对/ 小规模/ 下/ 链表/ 插入排序/ 算法/ 的/ 改进/ ,/ 推得/ 其/ 实际效果/ 相当于/ 将/ 排序/ 代价/ 缩减/ 为原/ 插入排序/ 的/ 3/ // 4/ ./ 在/ 主频/ 2.8/ GHz/ 的/ CPU/ 上/ 运行/ 小规模/ 的/ N/ =/ 10000/ ~/ N/ =/ 100000/ 原始/ 插入排序/ C语言/ 程序/ 和/ 缫丝/ 程序/ ,/ 按/ 上述/ 理论/ 代价/ 比值/ 推导/ 得/ 改进/ 算法/ 的/ 运行/ 时间/ ,/ 结果显示/ 该/ 方法/ 虽然/ 对/ 插入排序/ 的/ 改进/ 效果/ 明显/ ,/ 但/ 与/ 包括/ 缫丝/ 排序/ 在内/ 的/ 最优/ 排序/ 算法/ 相比/ 效率/ 差距/ 仍然/ 明显/ ,/ 如图/ 5/ ./ 图/ 5ReelingSort/ 与/ 推导/ 的/ 双/ 插入排序/ 时耗/ 折线/ 唐/ 开山/ [/ 9/ ]/ 提出/ 的/ 二次/ 堆排序/ 算法/ 获得/ 了/ 相比/ 原始/ 堆排序/ 80/ %/ 的/ 速率/ 提升/ ./ 同样/ 在/ PC机/ 上/ 运行/ 原始/ 堆排序/ 和/ 缫丝/ 排序程序/ ,/ 参考/ 唐/ 给出/ 的/ 比较/ 值后/ 推出/ 改进/ 的/ 时间/ 开销/ 如图/ 6/ (/ a/ )/ ./ 实验/ 数据/ 显示/ ,/ 在/ 较/ 小规模/ 下/ ,/ 二次/ 堆排序/ 的/ 效率/ 明显/ 优于/ 缫丝/ 排序/ ,/ 但/ 二次/ 堆排序/ 与/ 堆排序/ 的/ 时耗/ 比/ 随/ 规模/ 增大/ 呈上升/ 态势/ (/ 从/ N/ =/ 10000/ 规模/ 下/ 的/ 0.23/ 增至/ N/ =/ 75000/ 规模/ 下/ 的/ 0.28/ )/ ;/ 相反/ 地/ ,/ 避免/ 堆/ 操作/ 代价/ 使得/ 缫丝/ 排序/ 与/ 堆排序/ 的/ 时耗/ 比/ 是/ 减小/ 的/ (/ N/ =/ 1/ ×/ 104/ 时为/ 0.62/ ,/ N/ =/ 7.5/ ×/ 104/ 时为/ 0.60/ ,/ N/ =/ 1000/ ×/ 104/ 时仅/ 为/ 0.30/ )/ ./ 唐/ 的/ 研究/ 没有/ 给出/ 大规模/ 下/ 测试数据/ ,/ 假设/ 其时/ 耗比/ 在/ 短/ 区间/ 内/ 线性/ 变化/ ,/ 推导/ 得/ 二次/ 堆排序/ 的/ 时耗/ 比/ 将/ 在/ N/ =/ 10/ ×/ 104/ 时/ 达到/ 0.30/ ,/ 则/ 缫丝/ 排序/ 的/ 效率/ 将/ 在/ N/ =/ 10/ ×/ 104/ ~/ 1000/ ×/ 104/ 之间/ 超越/ 二次/ 堆排序/ ,/ 两者/ 在/ 不同/ 规模/ 排序/ 工作/ 中是/ 具备/ 互补性/ 的/ ,/ 如图/ 6/ (/ b/ )/ ./ 武汉大学/ 的/ 杨锋英/ 等/ 人/ [/ 13/ ]/ 提出/ 了/ 改进/ 快速/ 排序/ 算法/ ,/ 可/ 获得/ 相比/ 原有/ QuickSort/ 约/ 50/ %/ 的/ 时间/ 优势/ ,/ 这种/ 优势/ 是/ 在/ “/ 数据/ 变化/ 有/ 一定/ 的/ 限度/ ,/ 并/ 围绕/ 该/ 限度/ 上下/ 波动/ ”/ [/ 13/ ]/ 的/ 受限/ 条件/ 下/ 获得/ 的/ ,/ 而/ 在/ 随机/ 序列/ 情况/ 下/ 的/ 表现/ 则/ 不如/ 原始/ 的/ QuickSort/ ./ 随机/ 输入/ 时/ 的/ 比较/ 结果/ 如图/ 7/ ,/ 可见/ 这种/ 改进/ 对于/ Page7/ 图/ 7/ 随机/ 输入/ ReelingSort/ 与/ 改进/ 快速/ 排序/ 时耗/ 折线/ 普适/ 条件/ 下/ 的/ 随机/ 输入/ 情况/ 不如/ 缫丝/ 排序/ ./ 西南/ 大学/ 胡继/ 宽/ 等/ 人/ [/ 14/ ]/ 提出/ 了/ 快速/ 分组/ 排序/ 算法/ ,/ 在/ 分组/ 数较/ 多时/ 相比/ QuickSort/ 有/ 优势/ ,/ 而/ 当/ 分组/ 较/ 少时/ 则/ 不如/ 快速/ 排序/ ./ 推导/ 得/ 该/ 方案/ 在/ 所/ 要求/ 的/ 较/ 好/ 情况/ 下/ 与/ 原始/ QuickSort/ 的/ 时耗/ 比约/ 为/ 0.89/ ,/ 此时/ 的/ 比较/ 结果/ 如图/ 8/ ,/ 可见/ 在/ 分组/ 数较/ 多/ 的/ 小规模/ 排序/ 时/ ,/ 改进/ 与/ 缫丝/ 排序/ 的/ 效果/ 类似/ ,/ 但/ 在/ 考图/ 8ReelingSort/ 与/ 推导/ 的/ 分组/ 排序/ 时耗/ 折线/ 虑/ 包含/ 分组/ 数较/ 少/ 的/ 随机/ 情况/ 并/ 增大/ 排序/ 规模/ 后/ ,/ 缫丝/ 排序/ 将/ 优于/ 分组/ 排序/ 算法/ ./ 综上所述/ ,/ ReelingSort/ 相比/ 其它/ 改进/ 在/ 普适性/ 方面/ 具有/ 明显/ 优势/ ,/ 当/ 数据/ 规模/ 增大/ 后该/ 优势/ 尤其/ 明显/ ./ 4.6/ 与/ 自/ 适应/ 排序/ 库函数/ 的/ 比较/ 根据/ 不同/ 的/ 排序/ 规模/ 自/ 适应/ 地/ 选择/ 排序/ 算法/ 是/ 当今/ 主流/ 库函数/ 的/ 典型/ 特征/ ,/ 而/ ReelingSort/ 可以/ 明显降低/ 这类/ 自/ 适应/ 选择/ 算法/ 的/ 实现/ 复杂性/ ./ 以/ python/ 中/ 的/ sort/ 实现/ [/ 15/ ]/ 为例/ 说明/ Reeling/ -/ Sort/ 对/ 自/ 适应/ 排序/ 算法/ 的/ 简化/ 作用/ ./ Python/ 语言/ 内置/ 的/ 排序/ 方法/ 是/ 一种/ 典型/ 的/ 自/ 适应/ 排序/ ,/ 当/ 规模/ N/ </ 50/ 时/ ,/ 直接/ 使用/ 插入排序/ ;/ 一旦/ 排序/ 规模/ 增大/ ,/ 方案/ 在/ 进行/ 简单/ 的/ 顺逆/ 序/ 检查/ 后/ 使用/ 二分法/ 插入排序/ (/ binaryinsertion/ )/ ,/ 这种/ 方法/ 使用/ 二分/ 查找/ 确定/ 新/ 数据/ 的/ 插入/ 位置/ ,/ 从而/ 将/ 查找/ 代价/ 从/ O/ (/ N/ )/ 降低/ 为/ O/ (/ logN/ )/ ;/ 若/ 排序/ 规模/ 继续/ 增大/ (/ N/ >/ 200/ )/ ,/ 方案/ 将/ 转变/ 为/ 二次/ 抽样/ 排序/ (/ samplesort/ )/ ,/ 这种/ 方案/ 汲取/ 了/ 基数排序/ 的/ 思想/ ,/ 但/ 在/ “/ 分桶/ ”/ 前先/ 进行/ 两轮/ 抽样/ 以/ 保证数据/ “/ 分桶/ ”/ 的/ 均匀/ 性/ ./ 因此/ python/ 的/ 排序/ 时耗/ 曲线/ 是/ 分/ 3/ 段/ 拟合/ 的/ ./ 实验/ 数据/ 显示/ Reeling/ -/ Sort/ 的/ 时间/ 代价/ 只/ 在/ 排序/ 规模/ N/ </ 50/ 时/ 略高于/ python/ 选择/ 的/ 插入排序/ ,/ 而/ 当/ 排序/ 规模/ 增大/ 后/ ,/ ReelingSort/ 的/ 时间/ 代价/ 将/ 始终/ 优于/ python/ 当前/ 选择/ 的/ 自/ 适应/ 算法/ ,/ 如图/ 9/ (/ a/ )/ 、/ (/ b/ )/ ./ 这/ 意味着/ 使用/ ReelingSort/ 将/ 能够/ 明显/ 简化/ python/ 的/ 自/ 适应/ 排序/ 实现/ :/ 在/ N/ </ 50/ 时/ 使用/ 经典/ 的/ 插入排序/ ,/ 而/ 当/ N/ >/ 50/ 以后/ ,/ 可以/ 始终/ 选用/ ReelingSort/ ./ Page85/ 结束语/ 本文/ 从/ 古老/ 的/ “/ 双茧/ ”/ 缫丝/ 工艺/ 得到/ 启发/ ,/ 根据/ 随机/ 序列/ 主导/ 因素/ 的/ 不同/ ,/ 使用/ 多个/ 扩展/ 序列/ 先行/ 分离/ 待排/ 数据/ ,/ 提出/ 了/ 一种/ 改进/ 的/ 普适性/ 排序/ 算法/ ,/ 设计/ 完成/ 了/ 同时/ 具备/ 可控/ 理论/ 优势/ 和/ 现实意义/ 的/ 4/ 轴/ 缫丝/ 程序/ ,/ 并/ 对/ 如何/ 确定/ 程序/ 中/ 滚轴/ 数量/ 和/ 滚轴/ 选择/ 方式/ 做/ 了/ 详细/ 说明/ ./ 效率/ 测试表明/ ,/ 算法/ 可以/ 获得/ 相比/ 现有/ 经典/ 算法/ 10/ %/ 以上/ 的/ 稳定/ 优势/ ,/ 在/ 等价/ 意义/ 上将/ 基本操作/ 中/ 的/ 一部分/ 赋值/ 操作/ 转化/ 为/ 比较/ 操作/ ,/ 进一步/ 降低/ 了/ 算法/ 的/ 实际/ 运行/ 耗时/ ,/ 与/ 其它/ 改进/ 相比/ 具有/ 明显/ 的/ 普适性/ 优势/ ,/ 可/ 用于/ 降低/ 主流/ 排序/ 库函数/ 自/ 适应/ 选择/ 算法/ 的/ 实现/ 复杂性/ ,/ 是/ 一种/ 在/ 较大/ 和/ 较/ 小规模/ 下/ 同时/ 具备/ 良好/ 性能/ 的/ 排序/ 算法/ ./ 致谢/ 衷心感谢/ 林佳骝/ 博士/ 研究生/ 在/ 本/ 论文/ 编写/ 过程/ 中/ 给予/ 的/ 悉心/ 指导/ 和/ 大力协助/ !/ 

