Page1/ 基于/ 相变/ 存储器/ 和/ 闪存/ 的/ 数据库/ 事务/ 恢复/ 模型/ 范玉雷/ 孟小峰/ (/ 中国人民大学/ 信息/ 学院/ 北京/ 100872/ )/ 摘要/ 随着/ 闪存/ 容量/ 不断/ 增大/ 、/ 价格/ 不断/ 下降/ ,/ 闪存/ 在/ 实际/ 存储系统/ 上/ 得到/ 了/ 越来越/ 广泛/ 的/ 应用/ ./ 但是/ ,/ 闪存/ 的/ 页/ 级/ 读写/ 、/ 异位/ 更新/ 、/ 有限/ 寿命/ 等/ 阻碍/ 了/ 闪存/ 数据库系统/ 的/ 性能/ 提升/ ,/ 尤其/ 是/ 事务/ 恢复/ ./ 闪存/ 的/ 异位/ 更新/ 使得/ 影子/ 页/ 技术/ 可以/ 很/ 好/ 地/ 支持/ 闪存/ 数据库/ 事务/ 恢复/ ,/ 同时/ 也/ 给/ 闪存/ 数据库/ 带来/ 新/ 挑战/ ,/ 如/ 事务管理/ 、/ 缓冲区/ 管理/ ./ 相变/ 存储器/ 凭借/ 其比/ 闪存/ 更/ 高/ 的/ 读写/ 速度/ 、/ 更/ 小/ 的/ 读写/ 粒度/ 、/ 更长/ 的/ 寿命/ 成为/ 了/ 下一代/ 主流/ 存储技术/ ,/ 所以/ 相变/ 存储器/ 可以/ 用于/ 解决/ 在/ 闪存/ 数据库/ 中/ 使用/ 影子/ 页/ 技术/ 所/ 产生/ 的/ 事务管理/ 和/ 缓冲区/ 管理/ 问题/ ./ 该文/ 基于/ 相变/ 存储器/ 和/ 闪存/ 混合式/ 存储/ 提出/ 一种/ 全新/ 的/ 数据库/ 事务/ 恢复/ 模型/ —/ —/ —/ SPFP/ ./ 该/ 模型/ 充分利用/ 相变/ 存储器/ 的/ 特性/ 完成/ 事务管理/ ./ 为/ 支持/ 非/ 强制/ 缓冲区/ 管理/ ,/ 基于/ SPFP/ 提出/ 了/ 一种/ 优化/ 的/ 数据库/ 事务/ 恢复/ 模型/ —/ —/ —/ SPFLP/ ,/ 利用/ 相变/ 存储器/ 记录/ 更/ 多/ 事务/ 信息/ ./ 实验/ 结果表明/ ,/ 相较/ 于/ 全/ 闪存/ 存储/ 的/ 数据库系统/ ,/ SPFLP/ 大大提高/ 了/ 基于/ 混合/ 存储/ 的/ 数据库/ 事务处理/ 性能/ ./ 关键词/ 闪存/ ;/ 相变/ 存储器/ ;/ 数据库/ ;/ 事务/ 恢复/ 1/ 引言/ 随着/ 闪存/ 技术/ 的/ 飞速发展/ ,/ 闪存/ 的/ 容量/ 在/ 不断/ 增大/ ,/ 闪存/ 的/ 单位/ 价格/ 也/ 在/ 不断/ 降低/ ,/ 因此/ 闪存/ 在/ 存储系统/ 中/ 得到/ 了/ 广泛应用/ ,/ 小到/ 传感器/ ,/ 大到/ 大型/ 服务器/ ,/ 都/ 充分发挥/ 了/ 其/ 小巧/ 轻便/ 、/ 抗震/ 、/ 耐高/ // 低温/ 、/ 耗电量/ 小/ 、/ 读写/ 速度/ 快/ 等/ 特性/ [/ 1/ ]/ ./ 闪存/ 具有/ 完全/ 不同于/ 磁盘/ 的/ 物理/ 特性/ ,/ 如/ 非对称/ 读写/ 、/ 页级/ 读写/ 、/ 写前/ 擦除/ 、/ 异位/ 更新/ 、/ 有限/ 寿命/ 等/ ,/ 所以/ 学术界/ 和/ 工业界/ 在/ 基于/ 闪存/ 的/ 数据库系统/ 的/ 研究/ 方面/ 进行/ 了/ 大胆/ 尝试/ 并/ 取得/ 了/ 突出/ 的/ 科技成果/ ./ 相变/ 存储器/ (/ PhaseChangeMemory/ ,/ PCM/ )/ 是非/ 易失/ 随机/ 访问/ 存储器/ (/ Non/ -/ VolatileRandomAccessMemory/ ,/ NVRAM/ )/ 中/ 的/ 一种/ ,/ 同时/ 还是/ 具有/ 磁盘/ 和/ 内存/ 优势/ 特性/ 的/ 下一代/ 主流/ 存储技术/ [/ 2/ ]/ ./ 相比/ 于/ 内存/ 和/ 闪存/ ,/ 相变/ 存储器/ 提供/ 了/ 很多/ 吸引/ 人/ 的/ 适合/ 于/ 数据库/ 事务处理/ 的/ 新/ 特性/ ./ 相比/ 于/ 内存/ ,/ 相变/ 存储器/ 具有/ 与/ 内存/ 相近/ 的/ 读/ 速度/ ,/ 同时/ 还/ 具有/ 非易/ 失性/ ./ 相比/ 于/ 现有/ 的/ 闪存/ ,/ 相变/ 存储器/ 具有/ 高出/ 两个/ 数量级/ 以上/ 的/ 读写/ 速度/ ,/ 同时/ 还/ 具有/ 细粒度/ 的/ 原位/ 更新/ 特性/ ,/ 并且/ 相变/ 存储器/ 不/ 具有/ 闪存/ 的/ 写/ 前/ 擦除/ 特性/ ./ 所以/ 研究者/ 将要/ 面临/ 新/ 的/ 问题/ “/ 如何/ 修改/ 数据库/ 使/ 其/ 充分利用/ 新/ 硬件/ 相变/ 存储器/ 的/ 优势/ 特性/ ”/ [/ 3/ ]/ ./ 因此/ 本文/ 充分考虑/ 相变/ 存储器/ ,/ 重新/ 审视/ 闪存/ 数据库/ 的/ 事务处理/ 模块/ ./ 在/ 数据库/ 管理系统/ 中/ ,/ 事务/ 恢复/ 是/ 数据库/ 事务处理/ 的/ 一个/ 重要/ 模块/ ./ 写前/ 日志/ 技术/ [/ 4/ ]/ 和/ 影子/ 页/ 技术/ [/ 5/ ]/ 是/ 两种/ 经典/ 的/ 事务/ 恢复/ 技术/ ./ 写前/ 日志/ 技术/ 是/ 基于/ 磁盘/ 的/ 原位/ 更新/ 设计/ 的/ ,/ 原位/ 更新/ 使得/ 原有/ 旧版本/ 数据/ 被/ 覆盖/ ,/ 故/ 通过/ 记录/ 日志/ 来/ 记录/ 更新/ 操作/ ,/ 在/ 恢复/ 过程/ 中/ 通过/ 读取/ 日志/ 进行/ 相应/ 的/ Redo/ // Undo/ 操作/ 进而/ 获取/ 最/ 准确/ 的/ 数据/ ./ 写前/ 日志/ 技术/ 在/ 记录/ 数据/ 更新/ 的/ 同时/ ,/ 还/ 需要/ 一些/ 特殊/ 的/ 日志/ 用来/ 记录/ 事务/ 状态/ 、/ 检查点/ 等/ 信息/ ,/ 用以/ 完成/ 事务/ 恢复/ ./ 由于/ 闪存/ 存储器/ 多/ 采用/ 异位/ 更新/ 模式/ ,/ 所以/ 写前/ 日志/ 技术/ 不适/ 用于/ 基于/ 闪存/ 的/ 数据库系统/ ./ 影子/ 页/ 技术/ 是/ 基于/ 异位/ 更新/ 设计/ 的/ ,/ 故/ 影子/ 页/ 技术/ 可以/ 很/ 好/ 地/ 用以/ 支持/ 闪存/ 数据库/ 的/ 事务/ 恢复/ ,/ 但/ 同时/ 影子/ 页/ 技术/ 对/ 闪存/ 数据库/ 也/ 提出/ 了/ 两个/ 新/ 的/ 挑战/ —/ —/ —/ 事务管理/ 和/ 缓冲区/ 管理/ ./ 首先/ ,/ 在/ 事务/ 执行/ 和/ 恢复/ 过程/ 中/ 需要/ 进行/ 有效/ 的/ 事务/ 元/ 信息管理/ ./ 其次/ ,/ 像/ 磁盘/ 数据库/ 一样/ ,/ 闪存/ 数据库系统/ 也/ 需要/ 支持/ 非/ 强制/ 的/ 缓冲区/ 管理策略/ ,/ 进而/ 提高/ 整个/ 系统/ 的/ 性能/ ./ 相变/ 存储器/ 具有/ 内存/ 和/ 闪存/ 的/ 优势/ 特性/ ,/ 如/ 按位/ 修改/ 、/ 非易失/ 等/ ,/ 所以/ 本文/ 利用/ 相变/ 存储器/ 解决/ 影子/ 页/ 技术/ 应用/ 在/ 闪存/ 数据库系统/ 中/ 所/ 带来/ 的/ 事务管理/ 和/ 缓冲区/ 管理/ 问题/ ./ 由于/ 相变/ 存储器/ 允许/ 按位/ 修改/ 、/ 具有/ 与/ 内存/ 相当/ 的/ 读/ 速度/ 、/ 具有/ 比/ 闪存/ 高/ 两个/ 数量级/ 的/ 读写/ 速度/ ,/ 所以/ 可以/ 使用/ 相变/ 存储器/ 对/ 事务/ 进行/ 管理/ ,/ 包括/ 事务/ ID/ 和/ 事务/ 状态/ 等/ 信息/ ./ 同时/ 为了/ 支持/ 非/ 强制/ 的/ 缓冲区/ 管理策略/ ,/ 需要/ 对/ 事务/ 进行/ 的/ 操作/ 进行/ 更/ 详细/ 的/ 记录/ 和/ 维护/ ,/ 比如/ 事务/ 操作/ 类型/ 和/ 事务/ 操作/ 内容/ 等/ ./ 本文/ 针对/ 基于/ 相变/ 存储器/ 和/ 闪存/ 的/ 数据库系统/ 设计/ 了/ 全新/ 的/ 事务/ 恢复/ 模型/ ./ 总体/ 来说/ ,/ 本文/ 的/ 主要/ 贡献/ 如下/ :/ (/ 1/ )/ 提出/ 了/ 基于/ 相变/ 存储器/ 和/ 闪存/ 的/ 数据库/ 事务/ 恢复/ 模型/ SPFP/ ,/ 并/ 阐述/ 了/ 在/ SPFP/ 模型/ 下/ 的/ 正常/ 事务处理/ 方式/ ;/ (/ 2/ )/ 设计/ 了/ 适用/ 于/ SPFP/ 模型/ 下/ 的/ 数据库/ 故障/ (/ 3/ )/ 提出/ 了/ 支持/ 非/ 强制/ 缓冲区/ 管理/ 的/ 数据库/ 事务/ 恢复/ 模型/ SPFLP/ ,/ 并/ 阐述/ 了/ 在/ SPFLP/ 模型/ 下/ 的/ 正常/ 事务处理/ 方式/ ;/ (/ 4/ )/ 设计/ 了/ 适用/ 于/ SPFLP/ 模型/ 下/ 的/ 数据库/ 故障/ 恢复/ 方法/ ./ 本文/ 第/ 2/ 节/ 简单/ 介绍/ 闪存/ 、/ 相变/ 存储器/ 以及/ 相关/ 工作/ ;/ 第/ 3/ 节/ 提出/ 基于/ 相变/ 存储器/ 和/ 闪存/ 的/ 数据库/ 事务/ 恢复/ 模型/ SPFP/ ,/ 并/ 阐述/ 事务/ 正常/ 处理/ 方式/ 、/ 数据库/ 故障/ 恢复/ 和/ 闪存/ 空间/ 回收/ 方法/ ;/ 在/ 第/ 4/ 节/ ,/ 本文/ 提出/ 基于/ SPFP/ 优化/ 的/ 数据库/ 事务/ 恢复/ 模型/ SPFLP/ ,/ 并/ 详细描述/ 事务/ 正常/ 处理/ 方式/ 、/ 数据库/ 故障/ 恢复/ 方法/ ;/ 第/ 5/ 节/ 通过/ 实验/ 对比/ 分析/ 阐述/ SPFP/ 和/ SPFLP/ 的/ 性能/ 优势/ ;/ 在/ 第/ 6/ 节作/ 简单/ 总结/ ./ 2/ 研究/ 背景/ 及/ 相关/ 工作/ 恢复/ 方法/ 和/ 闪存/ 空间/ 回收/ 方法/ ;/ 由于/ 闪存/ 和/ 相变/ 存储器/ 都/ 各自/ 具有/ 一些/ 适合/ 于/ 数据库/ 的/ 优良/ 特性/ ,/ 所以/ 需要/ 结合/ 两者/ 的/ 优势/ 充分/ 提高/ 数据库系统/ 的/ 性能/ ./ 2.1/ 闪存/ 和/ 相变/ 存储器/ 和/ 磁盘/ 一样/ ,/ 闪存/ 和/ 相变/ 存储器/ 都/ 是非/ 易失/ 存储器/ ./ 如图/ 1/ 所示/ ,/ 闪存/ 设备/ 由/ 一组/ 闪存/ 芯片/ 组成/ ,/ 每个/ 闪存/ 芯片/ 内部/ 按照/ 块/ 进行/ 组织/ ,/ 块/ 是/ 闪存/ 擦除/ 操作/ 的/ 基本/ 单元/ ./ 块/ 是/ 由/ 若干/ 页/ 组成/ ,/ 页/ 是/ 读写操作/ 的/ 最小/ 单元/ ./ 一个/ 闪存/ 页/ 分为/ 数据/ 区/ 和/ 空闲/ 区/ ,/ 数据/ 区/ 主要/ 存储用户/ 数据/ ,/ 空闲/ 区/ 主要/ 存储/ 校验码/ 和/ 逻/ Page3/ 辑页/ 地址/ 等/ 元/ 信息/ ./ 典型/ 的/ 数据/ 页/ 大小/ 为/ 2KB/ +/ 64KB/ ,/ 其中/ 2K/ 为/ 数据/ 区/ ,/ 64B/ 为/ 空闲/ 区/ ./ NAND/ 闪存/ 常用/ 于/ 存储/ 数据/ ,/ 根据/ 存储密度/ 又/ 可以/ 把/ NAND/ 闪存/ 分为/ SLCNAND/ 闪存/ 和/ MLCNAND/ 闪存/ [/ 6/ ]/ ./ 由于/ MLCNAND/ 闪存/ 的/ 应用/ 广泛性/ ,/ 本文/ 意在/ 研究/ 基于/ MLCNAND/ 闪存/ 的/ 数据库系统/ ./ 不同于/ 磁盘/ ,/ 闪存/ 无/ 机械/ 组件/ ,/ 所以/ 闪存/ 具有/ 较/ 高/ 的/ 读写/ 性能/ [/ 7/ ]/ ,/ 并且/ 单个/ 请求/ 响应/ 延迟/ 主要/ 取决于/ 数据传输/ 的/ 总量/ ./ 由于/ 闪存/ 具有/ 写前/ 擦除/ 等/ 特性/ ,/ 异位/ 更新/ 常/ 被/ 实现/ 在/ 闪存/ 转换/ 层/ (/ FlashTransla/ -/ tionLayer/ ,/ FTL/ )/ 中/ ,/ 用于/ 解决/ 写前/ 擦除/ 的/ 约束/ [/ 8/ ]/ ./ 如图/ 1/ 所示/ ,/ 闪存/ 转换/ 层/ 是/ 承接/ 上层/ 应用/ 的/ 关键/ 组件/ ./ 闪存/ 转换/ 层为/ 上层/ 提供/ 读写/ 接口/ 和/ 事务/ 操作/ 接口/ (/ 提交/ 、/ 回滚/ 和/ 恢复/ )/ ./ 如图/ 2/ 所示/ ,/ 闪存/ 转换/ 层/ 在/ 内存/ 维护/ 一个/ 直接/ 映射/ 表/ (/ DirectMappingTable/ ,/ DMT/ )/ ,/ 用于/ 记录/ 逻辑/ 地址/ 到/ 物理地址/ 的/ 映射/ ;/ 每个/ 闪存/ 物理/ 页/ 的/ 空闲/ 区内/ 的/ 逻辑/ 地址/ 形成/ 了/ 一个/ 反向/ 映射/ 表/ (/ InverseMappingTable/ ,/ IMT/ )/ ,/ 用于/ 在/ 系统启动/ 时/ 在/ 内存/ 重建/ 直接/ 映射/ 表/ ./ 直接/ 映射/ 表/ 和/ 反向/ 映射/ 表/ 对于/ 异位/ 更新/ 的/ 实现/ 是/ 至关重要/ 的/ ./ 异位/ 更新/ 策略/ 产生/ 了/ 大量/ 的/ 无效/ 数据/ 页/ ,/ 故/ 在/ 闪存/ 转换/ 层/ 维护/ 了/ 一个/ 垃圾/ 回收/ 模块/ ,/ 定期/ 的/ 或者/ 不定期/ 的/ 回收/ 无效/ 数据/ 页/ ./ 由于/ 闪存/ 块/ 具有/ 有限/ 的/ 擦除/ 次数/ ,/ 单个/ 闪存/ 块/ 的/ 损坏/ 会/ 导致/ 整个/ 闪存/ 芯片/ 不可/ 用/ ,/ 所以/ 需要/ 在/ 闪存/ 转换/ 层中/ 维护/ 一个/ 磨损/ 均衡/ 模块/ ,/ 用以/ 实现/ 整个/ 闪存/ 的/ 均匀/ 使用/ ./ 根据/ 地址映射/ 的/ 粒度/ 可以/ 把/ 闪存/ 转换/ 层/ 分为/ 4/ 类/ :/ 页级/ 映射/ 、/ 块级/ 映射/ 、/ 块/ 页/ 混合/ 映射/ 和/ 其它/ [/ 9/ ]/ ./ 相变/ 存储器/ 采用/ 了/ 与/ 闪存/ 完全/ 不同/ 的/ 材料/ ,/ 采用/ 材料/ 的/ 晶体/ 和/ 非晶体/ 两种/ 状态/ 来/ 区分/ 1/ 和/ 0/ ./ 内存/ 、/ 磁盘/ 、/ 闪存/ 和/ 相变/ 存储器/ 的/ 硬件/ 性能/ 如表/ 1/ 所示/ [/ 3/ ]/ ./ 除了/ 非易/ 失和/ 高密度/ 之外/ ,/ 相变/ 存储器/ 还/ 具有/ 如下/ 特征/ [/ 1/ -/ 2/ ,/ 10/ ]/ :/ (/ 1/ )/ 细粒度/ 的/ 操作/ ./ 与/ 闪存/ 相比/ ,/ 它/ 没有/ 写前/ 擦除/ 和/ 基于/ 页/ 的/ 访问/ 约束/ ,/ 允许/ 按位/ 修改/ 和/ 访问/ ,/ 所以/ 可以/ 像/ 内存/ 一样/ 支持/ 小/ 粒度/ 的/ 原位/ 更新/ ;/ (/ 2/ )/ 非对称/ 的/ 读写/ 速度/ ./ 写/ 延迟/ 大概/ 是/ 读/ 延迟/ 的/ 20/ 倍/ ;/ (/ 3/ )/ 有限/ 寿命/ ./ 但/ 比/ 闪存/ 寿命/ 要长/ ,/ 可/ 支持/ 106/ ~/ 108/ 次/ 写/ 操作/ ./ 参数/ 密度/ 读/ 延迟/ (/ 粒度/ )/ 写/ 延迟/ (/ 粒度/ )/ 持久性/ 内存/ 1X20/ ~/ 50ns/ (/ 64B/ )/ 20/ ~/ 50ns/ (/ 64B/ )/ N/ // APCM2/ ~/ 4X/ ~/ 50ns/ (/ 64B/ )/ ~/ 1/ μ/ s/ (/ 64B/ )/ 106/ ~/ 108/ 闪存/ 4X/ ~/ 25/ μ/ s/ (/ 4KB/ )/ ~/ 500/ μ/ s/ (/ 4KB/ )/ 104/ ~/ 105/ 磁盘/ N/ // A/ ~/ 5ms/ (/ 512B/ )/ ~/ 5ms/ (/ 512B/ )/ 2.2/ 相关/ 工作/ 对于/ 基于/ 闪存/ 存储器/ 的/ 数据库系统/ ,/ 事务/ 恢复/ 方面/ 的/ 工作/ 较少/ ./ 安士/ 通等/ 提出/ 了/ 基于/ 影子/ 页/ 技术/ 的/ 事务/ 提交/ 策略/ [/ 11/ ]/ ,/ 充分利用/ 了/ SLCNAND/ 闪存/ 独有/ 的/ 部分/ 页/ 写/ 特性/ ./ 在/ 闪存/ 页/ 的/ 空闲/ 区/ 维护/ 操作/ 该/ 数据/ 页/ 的/ 事务/ 元/ 信息/ ,/ 当/ 事务/ 状态/ 发生变化/ (/ 事务/ 由/ 运行/ 状态/ 变为/ 提交/ 状态/ 或者/ 回滚/ 状态/ )/ ,/ 只/ 需要/ 更新/ 该页/ 的/ 空闲/ 区/ ,/ 而/ 不/ 需要/ 新/ 产生/ 闪存/ 页/ ,/ 因为/ SLCNAND/ 闪存/ 页/ 支持/ 多次/ 写/ 操作/ ./ 但是/ SLCNAND/ 闪存/ 相比/ 于/ MLCNAND/ 闪存/ 容量/ 较/ 低且/ 单位/ 容量/ 价格/ 较/ 高/ ,/ 使得/ SLCNAND/ 闪存/ 应用/ 范围/ 较/ 小/ ./ 本文/ 主要/ 针对/ MLCNAND/ 闪存/ 进行/ 数据库/ 恢复/ 研究/ ./ 需要/ 注意/ 的/ 是/ MLCNAND/ 闪存/ 不/ 具有/ 部分/ 页/ 写/ 特性/ ./ 在/ 文献/ [/ 12/ -/ 13/ ]/ 中/ ,/ 卢泽萍/ 等/ 人/ 设计/ 了/ 基于/ 异位/ 更新/ 优化/ 的/ 日志/ 结构/ ,/ 只/ 记录/ 更新/ 前后/ 的/ 数据/ 页/ 地址/ ,/ 大大/ 减小/ 了/ 日志/ 存储空间/ ./ 在/ 此基础/ 之上/ ,/ 作者/ 优化/ 了/ 事务/ 恢复/ 策略/ ,/ 利用/ 日志/ 记录/ 的/ 新旧/ 版本/ 数据/ 页/ 地址/ 可以/ 进行/ 快速/ 恢复/ ,/ 同时/ 通过/ Page4/ 同一/ 事务/ 日志/ 之间/ 的/ 链接/ 跳读/ 日志/ 减少/ 长/ 事务/ 的/ 恢复/ 时间/ ./ 但是/ 日志/ 结构/ 的/ 小/ 粒度/ 写/ 并/ 不/ 适合/ 于页/ 级/ 读写/ 粒度/ 的/ 闪存/ 设备/ ./ 研究/ 人员/ 开始/ 重新/ 审视/ 基于/ 相变/ 存储器/ 的/ 系统/ 的/ 设计/ 和/ 优化/ ./ 综合/ 文献/ [/ 2/ ,/ 14/ ]/ ,/ 有/ 3/ 种/ 可用/ 的/ 基于/ 相变/ 存储器/ 的/ 层次/ 架构/ :/ (/ 1/ )/ 相变/ 存储器/ 为主/ 存/ 的/ 辅助存储器/ ,/ 外存/ 为/ 磁盘/ [/ 2/ ]/ ;/ (/ 2/ )/ 相变/ 存储器/ 作为/ 主存/ ,/ 磁盘/ 为/ 二级/ 存储设备/ [/ 2/ ]/ ;/ (/ 3/ )/ 相变/ 存储器/ 和/ 闪存/ 同时/ 做/ 二级/ 存储设备/ [/ 14/ ]/ ./ 基于/ 相变/ 存储器/ 存储/ 性能/ 考虑/ ,/ 使用/ 相变/ 存储器/ 作为/ 辅助存储器/ 可能/ 更/ 实用/ ./ 第一个/ 原因/ 是/ 相变/ 存储器/ 具有/ 持久性/ 的/ 限制/ ,/ 其/ 写入/ 延迟/ 还/ 稍高于/ DRAM/ ./ 其次/ ,/ 在/ 未来/ 几年/ 内/ ,/ 相变/ 存储器/ 性能/ 赶不上/ DRAM/ 性能/ ./ 基于/ 第/ 1/ 种/ 架构/ ,/ Gao/ 等/ 人/ [/ 15/ ]/ 提出/ 一种/ 利用/ 相变/ 存储器/ 减少/ 日志/ 代价/ 的/ 方法/ ,/ 并且/ 在/ 该文/ 中/ 仍然/ 使用/ 相变/ 存储器/ 进行/ 数据/ 页/ 的/ 缓冲/ ./ 但是/ 相变/ 存储器/ 的/ 写/ 速度/ 距离/ 内存/ 的/ 写/ 速度/ 仍然/ 有/ 两个/ 数量级/ 的/ 差别/ ,/ 并且/ 随着/ 内存/ 技术/ 发展/ ,/ 内存容量/ 也/ 在/ 不断/ 增大/ ,/ 所以/ 尽量/ 充分利用/ 内存/ 缓存数据/ ,/ 使用/ 相变/ 存储器/ 作为/ 永久/ 存储/ 来/ 提高/ 整体/ 性能/ ./ Lee/ 等/ 人/ [/ 16/ ]/ 首先/ 在/ 2007/ 年/ 提出/ 了/ 一种/ 基于/ 页/ 内/ 日志/ 的/ 闪存/ 数据库系统/ ,/ 即/ 在/ 闪存/ 块/ 内/ 分为/ 两个/ 区/ —/ —/ —/ 数据/ 区/ 和/ 日志/ 区/ ./ 数据/ 区/ 用以/ 存储用户/ 数据/ 页/ ./ 日志/ 区/ 只/ 记录/ 当前/ 块/ 内/ 数据/ 页/ 的/ 更新/ ./ 内存/ 有/ 数据/ 缓冲区/ 和/ 日志/ 缓冲区/ 分别/ 对应/ 数据/ 区/ 和/ 日志/ 区/ ./ 但是/ 为了/ 尽可能/ 降低/ 数据/ 丢失/ ,/ 日志/ 缓冲区/ 的/ 日志/ 页/ 要/ 小于/ 数据/ 缓冲区/ 的/ 数据/ 页/ ./ 由于/ 闪存/ 只/ 支持/ 页级/ 读写/ ,/ 日志/ 页/ 的/ 读写/ 浪费/ 了/ 闪存/ 空间/ ,/ 所以/ Lee/ 等/ 人/ [/ 14/ ]/ 提出/ 了/ 一种/ 利用/ 相变/ 存储器/ 加速/ 页/ 内/ 日志/ 的/ 方式/ ,/ 数据/ 区/ 更新/ 产生/ 的/ 日志/ 放到/ 相变/ 存储器/ 上/ ,/ 因为/ 相变/ 存储器/ 支持/ 小/ 粒度/ 的/ 读写操作/ ./ 本文/ 针对/ 第/ 3/ 种/ 存储/ 结构/ 展开/ 研究/ ./ 3/ 基于/ 影子/ 页/ 的/ 数据库/ 恢复/ 模型/ SPFP/ 利用/ 相变/ 存储器/ 维护/ 事务/ 元/ 信息/ ,/ 在/ 闪存/ 数据库/ 中/ 实现/ 影子/ 页/ 恢复/ 技术/ ./ 3.1/ SPFP/ 模型/ 框架/ 基于/ 影子/ 页/ 的/ 数据库/ 恢复/ 模型/ SPFP/ 的/ 基本/ 思想/ :/ 利用/ 影子/ 页/ 跟踪/ 用户/ 对/ 闪存/ 数据/ 页/ 所/ 进行/ 的/ 更新/ 操作/ ,/ 并/ 使用/ 相变/ 存储器/ 记录/ 事务/ 最终/ 状态/ ./ 如图/ 3/ 所示/ ,/ 闪存/ 数据/ 页/ 的/ 空闲/ 区/ 维护/ 3/ 个/ 信息/ :/ 该/ 闪存/ 数据/ 页/ 对应/ 的/ 逻辑/ 地址/ 、/ 指向/ 该/ 闪存/ 数据/ 页/ 前/ 一个/ 版本/ 的/ 指针/ 和/ 产生/ 该/ 闪存/ 数据/ 页/ 的/ 事务/ ID/ ./ 事务/ ID/ 是/ 产生/ 该/ 闪存/ 数据/ 页/ 的/ 唯一/ 标识/ ./ 空闲/ 区/ 信息/ 主要/ 用于/ 完成/ 事务/ 恢复/ 和/ 垃圾/ 回收/ ./ MLCNAND/ 闪存/ 设备/ 没有/ 部分/ 页/ 写/ 特性/ (/ SLCNAND/ 闪存/ 设备/ 的/ 独有/ 特性/ )/ ,/ 但是/ 为了/ 完成/ 事务/ 正常/ 处理/ 和/ 恢复/ 必须/ 要/ 进行/ 事务管理/ ,/ 即/ 追踪/ 并/ 记录/ 事务/ 执行/ 的/ 状态/ 变化/ (/ 正在/ 执行/ // 提交/ // 回滚/ )/ ./ 由于/ 相变/ 存储器/ 允许/ 进行/ 细粒度/ 的/ 访问/ 和/ 原位/ 更新/ 操作/ ,/ 所以/ 本文/ 借助/ 相变/ 存储/ 去/ 实现/ 高效/ 的/ 数据库/ 恢复/ 模型/ ./ 在/ 事务/ 回滚/ 或者/ 系统启动/ 时/ ,/ 相变/ 存储器/ 的/ 数据/ 和/ 闪存/ 数据/ 页/ 空闲/ 区/ 的/ 元/ 数据/ 可以/ 用来/ 取消/ 事务所/ 进行/ 的/ 更新/ 和/ 系统/ 恢复/ ./ 基于/ 磁盘/ 的/ 数据库/ 管理系统/ ,/ 缓冲区/ 缓存/ 经常/ 访问/ 的/ 数据库/ 磁盘/ 页面/ ./ 缓冲区/ 管理策略/ 对/ 事务处理/ 能力/ 有/ 巨大/ 影响/ ./ 在/ 本/ 部分/ ,/ 缓冲区/ 管理策略/ 采用/ Steal/ 和/ 强制/ 的/ 缓冲区/ 管理策略/ ./ 换句话说/ ,/ 事务/ 提交/ 之前/ 允许/ 数据/ 页/ 写/ 到/ 闪存/ 上/ ,/ 并且/ 只有/ 事务/ 更新/ 的/ 所有/ 数据/ 页/ 都/ 刷/ 出到/ 闪存/ 之后/ 才/ 可以/ 提交/ 事务/ ./ 但是/ 对于/ 缓冲区/ 管理/ ,/ 我们/ 需要/ 做/ 一些/ 假设/ ./ 首先/ ,/ 采用/ 页级/ 并发/ 控制协议/ 处理/ 更新/ 冲突/ ./ 其次/ ,/ 采用/ 写回/ 缓冲区/ 策略/ :/ 直到/ 事务/ 提交/ 或者/ 数据/ 缓冲/ 页/ 需要/ 从/ 缓冲区/ 换出/ 的/ 时候/ ,/ 才/ 在/ 闪存/ 上/ 为/ 更新/ 操作/ 真正/ 创建/ 影子/ 页/ ./ 内存/ 数据结构/ 有/ 直接/ 映射/ 表/ 、/ 新/ 映射/ 表/ (/ NewMappingTable/ )/ 和/ 事务/ 表/ (/ TransactionTable/ )/ ,/ 如图/ 3/ 所示/ ./ 直接/ 映射/ 表/ 维护/ 最新/ 的/ 已/ 提交/ 的/ 逻辑/ 地址/ 到/ 物理地址/ 的/ 映射/ 〈/ LBA/ ,/ PBA/ 〉/ ./ 新/ 映射/ 表/ 维护/ 当前/ 正在/ 运行/ 的/ 事务/ 内/ 的/ 更新/ 操作/ 产生/ 的/ 逻辑/ 地址/ 到/ 物理地址/ 的/ 映射/ 〈/ LBA/ ,/ PBA/ 〉/ ./ 事务/ 表/ 存储/ 每个/ 事务/ 的/ 当前/ 状态/ (/ 即/ 运行/ 、/ 提交/ 或/ 回滚/ )/ ./ 由于/ 采用/ 哈希/ 索引/ 直接/ 映射/ 表/ ,/ 所以/ 直接/ 映射/ 表中/ 可以/ 不/ 实际/ Page5/ 存储/ 逻辑/ 地址/ LBA/ ./ 由于/ 事务/ 提交/ 或者/ 回滚/ 之后/ ,/ 事务/ 的/ 最终/ 状态/ 写入/ 到/ 相变/ 存储器/ 中/ ,/ 所以/ 实际上/ 内存/ 中/ 只/ 需要/ 记录/ 正在/ 运行/ 的/ 事务/ ID/ 即可/ ./ 如图/ 3/ 所示/ ,/ 外存/ 存储器/ 主要/ 由/ 两个/ 部分/ 组成/ ,/ 数据/ 存储/ 在/ 闪存/ 中/ ,/ 事务/ 最终/ 状态/ 存储/ 在/ 相变/ 存储器/ 中/ ./ 对于/ 闪存/ ,/ 每个/ 闪存/ 数据/ 页/ 包括/ 一个/ 数据/ 区/ 和/ 空闲/ 区/ ,/ 分别/ 用于/ 存储用户/ 数据/ 和/ 一些/ 元/ 数据/ ./ 空闲/ 区元/ 数据/ 包括/ 该/ 数据/ 页/ 的/ 逻辑/ 地址/ LBA/ ,/ 产生/ 该/ 数据/ 页/ 的/ 事务/ ID/ ,/ 指向/ 该/ 数据/ 页/ 前/ 一个/ 版本/ 的/ 指针/ Link/ (/ 为空/ 表示/ 该/ 数据/ 页/ 是/ 第/ 1/ 个/ 版本/ )/ ,/ 通过/ 该/ 指针/ 把/ 所有/ 版本/ 的/ 数据/ 页/ 链接/ 起来/ ,/ 可/ 记录/ 数据/ 页/ 的/ 更新/ 历史/ ./ 对于/ 相变/ 存储器/ ,/ 我们/ 只/ 记录/ 每个/ 事务/ 的/ 事务/ ID/ 和/ 事务/ 的/ 最终/ 状态/ (/ C/ // A/ ,/ 如果/ 为/ 1/ 代表/ 事务/ 最终/ 提交/ ;/ 如果/ 为/ 0/ 代表/ 事务/ 最终/ 回滚/ )/ ./ 3.2/ 正常/ 事务处理/ 基于/ SPFP/ 模型/ ,/ 我们/ 详细描述/ 正常/ 事务处理/ ,/ 包括/ 数据/ 页/ 更新/ 、/ 事务/ 提交/ 和/ 事务/ 回滚/ ./ 数据/ 页/ 更新/ ./ 当/ 一个/ 事务/ T/ / (/ ID/ 为/ xid/ )/ 更新/ 逻辑/ 地址/ 为/ lpa/ 、/ 物理地址/ 为/ ppa/ 的/ 数据/ 页/ pp/ ,/ SPFP/ 执行/ 以下/ 3/ 个/ 步骤/ :/ (/ 1/ )/ 如果/ 事务/ T/ / 不/ 存在/ 于/ 事务/ 表中/ ,/ 把/ 事务/ T/ / 的/ ID/ 及其/ 状态/ 〈/ xid/ ,/ Inprogress/ 〉/ 插入/ 到/ 事务/ 表中/ ;/ (/ 2/ )/ 在/ 闪存/ 上/ 创建/ 一个/ 影子/ 页/ pp/ ,/ 物理地址/ 为/ ppa/ ,/ 同时/ 把/ 逻辑/ 地址/ lpa/ 、/ 产生/ 该/ 影子/ 页/ 的/ 事务/ T/ / 的/ 唯一/ 标识/ xid/ 以及/ 该/ 影子/ 页/ 前/ 一个/ 版本/ 的/ 物理地址/ ppa/ 插入/ 到/ 该/ 影子/ 页/ 空闲/ 区/ 的/ LBA/ 、/ XID/ 和/ Link/ 区域/ ;/ (/ 3/ )/ 把/ 〈/ lpa/ ,/ xid/ ,/ ppa/ 〉/ 插入/ 到/ 新/ 映射/ 表中/ ,/ 用以/ 在/ 事务/ 结束/ 之后/ 保证/ 直接/ 映射/ 表/ 的/ 正确性/ ./ 事务/ 提交/ ./ 当/ 一个/ 事务/ T/ / (/ ID/ 为/ xid/ )/ 提交/ ,/ SPFP/ 执行/ 以下/ 3/ 个/ 步骤/ :/ (/ 1/ )/ 把/ 〈/ xid/ ,/ 1/ 〉/ 写入/ 到/ 相变/ 存储器/ 中/ ;/ (/ 2/ )/ 把/ 新/ 映射/ 表中/ 所有/ 属于/ 事务/ T/ / 的/ 〈/ lpa/ ,/ xid/ ,/ ppa/ 〉/ 合并/ 到/ 直接/ 映射/ 表中/ ,/ 替换/ 掉/ 直接/ 映射/ 表中/ 具有/ 相同/ 逻辑/ 地址/ lpa/ 的/ 〈/ lpa/ ,/ ppa/ 〉/ ,/ 同时/ 把/ 这些/ 〈/ lpa/ ,/ xid/ ,/ ppa/ 〉/ 从/ 新/ 映射/ 表中/ 删除/ ;/ (/ 3/ )/ 从/ 事务/ 表中/ 删除/ 事务/ T/ / ./ 事务/ 回滚/ ./ 当/ 一个/ 事务/ T/ / (/ ID/ 为/ xid/ )/ 回滚/ ,/ SPFP/ 执行/ 以下/ 3/ 个/ 步骤/ :/ (/ 1/ )/ 把/ 〈/ xid/ ,/ 0/ 〉/ 写入/ 到/ 相变/ 存储器/ 中/ ;/ (/ 2/ )/ 把/ 新/ 映射/ 表中/ 所有/ 属于/ 事务/ T/ / 的/ 〈/ lpa/ ,/ xid/ ,/ ppa/ 〉/ 从/ 新/ 映射/ 表中/ 删除/ ;/ (/ 3/ )/ 从/ 事务/ 表中/ 删除/ 事务/ T/ / ./ 3.3/ 闪存/ 空间/ 回收/ 当/ 闪存/ 设备/ 的/ 空闲/ 空间/ 低于/ 预设/ 的/ 阈值/ ,/ 系统/ 就/ 会/ 触发/ 垃圾/ 回收/ 模块/ ,/ 回收/ 废旧/ 页/ ./ 废旧/ 页/ 包括/ 以下/ 3/ 种/ 类型/ :/ 未/ 提交/ 事务/ 产生/ 的/ 数据/ 页/ 、/ 回滚/ 事务/ 产生/ 的/ 数据/ 页/ 、/ 提交/ 事务/ 产生/ 的/ 已/ 过时/ 的/ 数据/ 页/ ./ 事务/ 状态/ 在/ 识别/ 前/ 两种/ 数据/ 页/ 的/ 过程/ 中/ 起到/ 了/ 至关重要/ 的/ 作用/ ./ 事务/ 状态/ 可以/ 通过/ 读取/ 相变/ 存储器/ 快速/ 获得/ ,/ 因为/ 相变/ 存储器/ 的/ 读/ 速度/ 接近/ 于/ 内存/ 的/ 读/ 速度/ ./ 对于/ 第/ 3/ 种/ 数据/ 页/ ,/ 必须/ 要/ 结合/ 相变/ 存储器/ 上/ 存储/ 的/ 事务/ 状态/ 和/ 闪存/ 数据/ 页/ 空闲/ 区/ 的/ 事务/ 唯一/ 标识/ XID/ 以及/ 指向/ 前/ 一个/ 版本/ 的/ 指针/ Link/ 等/ 信息/ 才能/ 完成/ 识别/ ./ 垃圾/ 回收/ 如/ 算法/ 1/ 所示/ ./ 算法/ 1/ ./ 垃圾/ 回收/ ./ FOR/ 每个/ 闪存/ 数据/ 页/ DOlpa/ ,/ xid/ ,/ link/ =/ 该页/ 空闲/ 区/ LBA/ 、/ XID/ 、/ Link/ 域值/ ;/ ppa/ =/ 该页/ 物理地址/ ;/ stat/ =/ 读取/ 相变/ 存储器/ 获取/ 事务/ xid/ 的/ 状态/ ;/ IFstat/ =/ =/ 0THEN/ 释放/ ppa/ 对应/ 闪存/ 页/ ;/ 把/ ppa/ 加入/ 到/ 空闲/ 页/ 列表/ 中/ ;/ ELSE/ 释放/ link/ 对应/ 闪存/ 页/ ;/ 把/ link/ 加入/ 到/ 空闲/ 页/ 列表/ ./ 对于/ 每个/ 闪存/ 数据/ 页/ ,/ 首先/ 要/ 获取/ 该页/ 空闲/ 区/ 的/ 元/ 数据/ LBA/ 、/ XID/ 、/ Link/ 的/ 值/ ,/ 然后/ 再/ 读取/ 相变/ 存储器/ 获取/ 创建/ 该页/ 的/ 事务/ 状态/ ./ 如果/ 事务/ 状态/ 为/ 0/ ,/ 即/ 事务/ 未/ 提交/ 或/ 已/ 回滚/ ,/ 则/ 当前/ 数据/ 页/ 无效/ ,/ 则/ 可以/ 对/ 该/ 数据/ 页/ 进行/ 回收/ ,/ 并/ 把/ 该页/ 地址/ 加入/ 到/ 空闲/ 页/ 列表/ 中/ 以备/ 后用/ ./ 如果/ 事务/ 状态/ 为/ 1/ ,/ 即/ 事务/ 已经/ 被/ 提交/ ,/ 因为/ 可以/ 确保/ 该/ 数据/ 页/ 的/ 前/ 一个/ 版本/ 无效/ ,/ 所以/ 可以/ 回收/ link/ 指向/ 的/ 闪存/ 数据/ 页/ ,/ 并/ 把/ link/ 加入/ 到/ 空闲/ 页/ 列表/ 中/ 以备/ 后用/ ./ 3.4/ 数据库/ 故障/ 恢复/ 遇到/ 系统/ 正常/ 关机/ 或/ 系统故障/ 后/ 重启/ 数据库/ 时/ ,/ 恢复/ 过程/ 被/ 触发/ ./ 它/ 意在/ 恢复/ 最新/ 版本/ 的/ 数据/ 页/ 以及/ 重建/ 直接/ 映射/ 表/ ./ 重建/ 直接/ 映射/ 表/ 的/ 目的/ 意在/ 为/ 用户/ 索引/ 到/ 正确/ 的/ 数据/ ./ 在/ 恢复/ 过程/ 中/ ,/ 数据/ 页/ 的/ 有效/ // 无效/ 识别/ 是/ 关键/ ,/ 根据/ 3.3/ 节/ 描述/ 可知/ 无效/ 的/ 数据/ 页/ 可以/ 通过/ 事务/ 状态/ 和/ 数据/ 页/ 空闲/ 区元/ 信息/ 识别/ 出来/ ./ 识别/ 出/ 无效/ 数据/ 页/ 之后/ 剩下/ 的/ 就是/ 有效/ 数据/ 页/ ./ 然后/ ,/ 读取/ 有效/ 数据/ 页/ 获取/ 地址映射/ 信息/ 构建/ 直接/ 映射/ 表/ ./ 在/ 恢复/ 过程/ 中/ 引入/ 一个/ 数据结构/ ,/ 即/ 物理/ 页/ 状态/ 位/ 图/ ,/ 如图/ 4/ 所示/ ./ 在/ 物理/ 页/ 状态/ 位图/ 中/ ,/ 每/ 一位/ 对应/ 一个/ 物理/ 页/ ,/ 用以/ 标识/ 这个/ 物理/ 页/ 是/ 有效/ 还是/ 无效/ ./ 如果/ 为/ 1/ ,/ 对应/ 物理/ 页/ 有效/ ;/ 如果/ 为/ 0/ ,/ 对应/ 物理/ 页/ 无效/ ./ 默认/ 情况/ 下/ ,/ 所有/ 闪存/ 数据/ 页/ 都/ 是/ 有效/ 地/ ,/ 即/ 物理/ 页/ 状态/ 位图/ 为/ 全/ 1/ ./ 物理/ 页/ 状态/ 位图/ 只/ 在/ 数据库系统/ 故障/ 恢复/ 时才/ 创建/ 使用/ ,/ 系统/ 正常/ 运行/ 时/ 不/ 需要/ 创建/ Page6/ 维护/ ./ 恢复/ 过程/ 如/ 算法/ 2/ 所示/ ./ 算法/ 2/ ./ 恢复/ ./ 初始化/ PBA/ -/ bitmap/ 为/ 全/ 1/ ;/ FOR/ 每个/ 闪存/ 数据/ 页/ DOlpa/ ,/ xid/ ,/ link/ =/ 该页/ 空闲/ 区/ LBA/ 、/ XID/ 、/ Link/ 域值/ ;/ ppa/ =/ 该页/ 物理地址/ ;/ stat/ =/ 读取/ 相变/ 存储器/ 获取/ 事务/ xid/ 的/ 状态/ ;/ IFstat/ =/ =/ 0THEN/ 根据/ ppa/ 设置/ PBA/ -/ bitmap/ 的/ 相应/ 位为/ 0/ ;/ ELSE/ 根据/ link/ 设置/ PBA/ -/ bitmap/ 的/ 相应/ 位为/ 0/ ;/ FORPBA/ -/ bitmap/ 中/ 的/ 每个/ 位/ DOIF/ 这/ 一位/ 为/ 1THENppa/ =/ 该/ 位/ 对应/ 的/ 物理地址/ ;/ lpa/ =/ 获取/ ppa/ 页/ 空闲/ 区/ LBA/ 域值/ ;/ 把/ 〈/ lpa/ ,/ ppa/ 〉/ 插入/ 到/ 直接/ 映射/ 表/ ./ 在/ 恢复/ 过程/ 之初/ ,/ 首先/ 要/ 初始化/ PBA/ -/ bitmap/ 为/ 全/ 1/ ,/ 即/ 所有/ 闪存/ 数据/ 页/ 都/ 有效/ ./ 在/ 第/ 1/ 个/ 循环/ 中/ ,/ 通过/ 读取/ 每个/ 闪存/ 数据/ 页/ 的/ 空闲/ 区元/ 数据/ 获取/ 创建/ 该页/ 的/ 事务/ xid/ 、/ 该页/ 对应/ 的/ 逻辑/ 地址/ lpa/ 和/ 该页/ 的/ 前/ 一个/ 版本/ 地址/ link/ ,/ 然后/ 根据/ 事务/ xid/ 读取/ 相变/ 存储器/ 获取/ 该/ 事务/ 的/ 最终/ 状态/ ./ 如果/ 事务/ 状态/ 为/ 0/ ,/ 即/ 事务/ 未/ 提交/ 或/ 已/ 回滚/ ,/ 则/ 当前/ 数据/ 页/ 无效/ ,/ 则/ 置/ PBA/ -/ bitmap/ 的/ 第/ ppa/ 位为/ 0/ ;/ 如果/ 事务/ 状态/ 为/ 1/ ,/ 即/ 事务/ 已经/ 被/ 提交/ ,/ 因为/ 可以/ 确保/ 该/ 数据/ 页/ 的/ 前/ 一个/ 版本/ 无效/ ,/ 则/ 置/ PBA/ -/ bitmap/ 的/ 第/ link/ 位为/ 0/ ./ 最终/ 获得/ 每个/ 闪存/ 数据/ 页/ 的/ 最终/ 状态/ 位图/ PBA/ -/ bitmap/ ./ 最后/ ,/ 根据/ PBA/ -/ bitmap/ 的/ 每/ 一位/ 信息/ 来/ 重建/ 直接/ 映射/ 表/ ./ 如果/ 位/ 信息/ 为/ 1/ ,/ 则/ 该位/ 对应/ 的/ ppa/ 闪存/ 数据/ 页/ 有效/ ,/ 读取/ 该页/ 空闲/ 区/ 的/ LBA/ 信息/ lpa/ ,/ 把/ 〈/ lpa/ ,/ ppa/ 〉/ 插入/ 到/ 直接/ 映射/ 表中/ ./ 虽然/ 某些/ 闪存/ 数据/ 页/ 需要/ 进行/ 两次/ 读/ 操作/ ,/ 尤其/ 是/ 第/ 2/ 次读/ 还是/ 随机/ 读/ 操作/ ,/ 但是/ 闪存/ 的/ 随机/ 读/ 顺序/ 读/ 性能/ 都/ 比较/ 好/ ,/ 所以/ 对于/ 性能/ 的/ 影响/ 并/ 不是/ 很大/ ./ 4/ 扩展/ 数据库/ 恢复/ 模型/ SPFLP/ 非/ 强制/ 缓冲区/ 管理策略/ 是/ 数据库/ 管理系统/ 中/ 的/ 一种/ 常用/ 策略/ ./ 非/ 强制/ 缓冲区/ 管理/ 允许/ 数据/ 页/ 在/ 事务/ 提交/ 之后/ 刷写/ 到/ 外存/ 上/ ,/ 进而/ 大大提高/ 缓冲区/ 性能/ ./ 非/ 强制/ 缓冲区/ 管理策略/ 需要/ 在/ 外存/ 记录/ 事务/ 操作/ 的/ 详细信息/ ./ 日志/ 是/ 记录/ 事务/ 操作/ 详细信息/ 的/ 一种/ 方式/ ,/ 但是/ 日志/ 多/ 通过/ 顺序/ 写/ 和/ 顺序/ 读/ 的/ 方式/ 完成/ 日志/ 记录/ 和/ 事务/ 恢复/ ./ 而/ 相变/ 存储器/ 支持/ 像/ 内存/ 一样/ 的/ 随机/ 操作/ ,/ 并且/ 相变/ 存储器/ 具有/ 较/ 好/ 的/ 读/ 性能/ ,/ 而/ 写/ 性能/ 也/ 要/ 比/ 闪存/ 要/ 好/ 很多/ ,/ 所以/ 本/ 部分/ 提出/ 了/ 一种/ 基于/ SPFP/ 的/ 优化/ 的/ 能够/ 支持/ 非/ 强制/ 缓冲区/ 管理/ 的/ 数据库/ 事务/ 恢复/ 模型/ SPFLP/ ./ 4.1/ SPFLP/ 模型/ 架构/ 如图/ 5/ 所示/ ,/ SPFLP/ 模型/ 与/ SPFP/ 模型/ 基本上/ 相同/ ,/ 唯一/ 的/ 不同点/ 在于/ 相变/ 存储器/ 上/ 的/ 数据结构/ 需要/ 重新/ 设计/ 以/ 达到/ 记录/ 事务/ 更新/ 操作/ 的/ 详细信息/ 的/ 目的/ ./ 在/ SPFP/ 中/ ,/ 相变/ 存储器/ 只/ 需要/ 存储/ 事务/ ID/ 和/ 事务/ 最终/ 状态/ 标识/ 位/ ./ 在/ SPFLP/ 中/ ,/ 相变/ 存储器/ 不但/ 要/ 记录/ 事务/ ID/ 和/ 事务/ 最终/ 状态/ ,/ 还/ 需要/ 记录/ 事务/ 内/ 每个/ 更新/ 操作/ 的/ 操作/ 类型/ (/ 插入/ // 更新/ // 删除/ )/ 和/ 更新/ 操作/ 内容/ ./ 事务/ 内/ 每个/ 更新/ 操作/ 作为/ 链表/ 的/ 一个/ 节点/ ,/ 所有/ 更新/ 操作/ 构成/ 一个/ 链表/ ,/ 链接/ 到/ 事务/ ID/ 和/ 事务/ 最终/ 状态/ 信息/ 后面/ ./ 事务/ 开始/ 时/ ,/ 在/ 相变/ 存储器/ 上/ 加入/ 一个/ 不带/ 事务/ 状态/ 的/ 链表/ 头/ ./ 对于/ SPFP/ 模型/ 和/ SPFLP/ 模型/ ,/ 相变/ 存储器/ 上/ 的/ 事务/ 状态/ 信息/ 和/ 闪存/ 数据/ 页/ 空闲/ 区/ 的/ 元/ 信息/ 的/ 产生/ 及/ 操作过程/ 是/ 一样/ 的/ ,/ 闪存/ 空间/ 回收/ 算法/ 仍/ 可/ 使用/ 算法/ 1/ ,/ 这里/ 就/ 不再/ 赘述/ ./ 图/ 5/ 支持/ 非/ 强制/ 缓冲区/ 管理/ 的/ 数据库/ 恢复/ 模型/ SPFLP4/ ./ 2/ 正常/ 事务处理/ 基于/ SPFLP/ 模型/ ,/ 我们/ 详细描述/ 正常/ 事务处理/ 中/ 的/ 数据/ 页/ 更新/ 和/ 事务/ 回滚/ ./ 事务/ 提交/ 过程/ 与/ SPFP/ 模型/ 中/ 的/ 事务/ 提交/ 完全相同/ ./ 数据/ 页/ 更新/ ./ 当/ 一个/ 事务/ T/ / (/ ID/ 为/ xid/ )/ 中/ 更新/ 操作/ (/ 操作/ 类型/ 为/ U/ )/ 对/ 逻辑/ 地址/ 为/ lpa/ 、/ 物理地址/ 为/ ppa/ 的/ 数据/ 页/ pp/ 进行/ 操作/ 时/ ,/ SPFLP/ 执行/ 以/ Page7/ 下/ 4/ 个/ 步骤/ :/ (/ 1/ )/ 如果/ 事务/ T/ / 不/ 存在/ 于/ 事务/ 表中/ ,/ 把/ 事务/ T/ / 的/ ID/ 及其/ 状态/ 〈/ xid/ ,/ Inprogress/ 〉/ 插入/ 到/ 事务/ 表中/ ;/ (/ 2/ )/ 在/ 闪存/ 上/ 创建/ 一个/ 影子/ 页/ pp/ ,/ 物理地址/ 为/ ppa/ ,/ 同时/ 把/ 逻辑/ 地址/ lpa/ 、/ 产生/ 该/ 影子/ 页/ 的/ 事务/ T/ / 的/ 唯一/ 标识/ xid/ 以及/ 该/ 影子/ 页/ 前/ 一个/ 版本/ 的/ 物理地址/ ppa/ 插入/ 到/ 该/ 影子/ 页/ 空闲/ 区/ 的/ LBA/ 、/ XID/ 和/ Link/ 区域/ ;/ (/ 3/ )/ 把/ 操作/ 类型/ 和/ 操作/ 内容/ 形成/ 一个/ 链表/ 节点/ ,/ 然后/ 插入/ 到/ 相变/ 存储器/ 的/ 事务/ xid/ 之后/ 的/ 链表/ 中/ ;/ (/ 4/ )/ 把/ 〈/ lpa/ ,/ xid/ ,/ ppa/ 〉/ 插入/ 到/ 新/ 映射/ 表中/ ,/ 用于/ 事务/ 结束/ 之后/ 保证/ 直接/ 映射/ 表/ 的/ 正确性/ ./ 事务/ 回滚/ ./ 当/ 一个/ 事务/ T/ / (/ ID/ 为/ xid/ )/ 回滚/ ,/ SPFLP/ 执行/ 以下/ 4/ 个/ 步骤/ :/ (/ 1/ )/ 把/ 〈/ xid/ ,/ 0/ 〉/ 写入/ 到/ 相变/ 存储器/ 中/ ;/ (/ 2/ )/ 把/ 相变/ 存储器/ 上/ 的/ xid/ 对应/ 的/ 链表/ 空间/ 释放/ ;/ (/ 3/ )/ 把/ 新/ 映射/ 表中/ 所有/ 属于/ 事务/ T/ / 的/ 〈/ lpa/ ,/ xid/ ,/ ppa/ 〉/ 从/ 新/ 映射/ 表中/ 删除/ ;/ (/ 4/ )/ 从/ 事务/ 表中/ 删除/ 事务/ T/ / ./ 4.3/ 数据库/ 故障/ 恢复/ 在/ SPFLP/ 中/ 仍然/ 需要/ 借用/ PBA/ -/ bitmap/ 这个/ 数据结构/ 来/ 完成/ 数据库/ 故障/ 恢复/ ,/ 即/ 重建/ 直接/ 映射/ 表/ ./ 非/ 强制/ 缓冲区/ 管理策略/ 可能/ 导致/ 已经/ 提交/ 的/ 数据/ 页/ 在/ 数据/ 故障/ 前未/ 来得及/ 刷出/ 到/ 闪存/ 上/ ,/ 进而/ 导致/ 数据/ 丢失/ ,/ 所以/ 只能/ 通过/ 相变/ 存储器/ 上/ 的/ 事务/ 更新/ 操作/ 记录/ 来/ 重建/ 数据/ ,/ 进而/ 获取/ 正确/ 的/ 直接/ 映射/ 表/ ./ 恢复/ 过程/ 如/ 算法/ 3/ 所示/ ./ 同/ 算法/ 2/ ,/ 要/ 设置/ PBA/ -/ bitmap/ 为/ 全/ 1/ ,/ 然后/ 通过/ 读取/ 相变/ 存储器/ 和/ 闪存/ 数据/ 页/ 空闲/ 区元/ 数据/ 可以/ 判断/ 数据/ 页/ 的/ 有效/ // 无效/ ,/ 然后/ 根据/ 数据/ 页/ 的/ 有效/ 无效/ 进行/ 其它/ 操作/ ./ 对于/ 未/ 提交/ 或/ 已/ 回滚/ 事务/ 产生/ 的/ 数据/ 页/ ,/ 则/ 置/ PBA/ -/ bitmap/ 的/ 第/ ppa/ 位为/ 0/ ;/ 对于/ 已/ 提交/ 数据/ 页/ ,/ 同样/ 置/ PBA/ -/ bitmap/ 的/ 第/ link/ 位为/ 0/ ./ 由于/ ppa/ 闪存/ 数据/ 页/ 已经/ 存在/ 于/ 闪存/ 之上/ ,/ 所以/ 相变/ 存储器/ 上/ 的/ 产生/ ppa/ 的/ 操作/ 记录/ 已经/ 无效/ ,/ 所以/ 需要/ 把/ 产生/ ppa/ 闪存/ 数据/ 页/ 的/ 事务/ 操作/ 记录/ 从/ 相变/ 存储器/ 中/ 的/ 事务/ xid/ 后/ 的/ 链表/ 中/ 删除/ 并/ 释放/ 空间/ ./ 算法/ 3/ ./ 恢复/ (/ SPFLP/ )/ ./ 初始化/ PBA/ -/ bitmap/ 为/ 全/ 1/ ;/ FOR/ 每个/ 闪存/ 数据/ 页/ DOlpa/ ,/ xid/ ,/ link/ =/ 该页/ 空闲/ 区/ LBA/ 、/ XID/ 、/ Link/ 域值/ ;/ ppa/ =/ 该页/ 物理地址/ ;/ stat/ =/ 读取/ 相变/ 存储器/ 获取/ 事务/ xid/ 的/ 状态/ ;/ IFstat/ =/ =/ 0THENELSEFOR/ 相变/ 存储器/ 中/ 的/ 每个/ 事务/ DOIF/ 事务/ 状态/ 为/ 1THENIF/ 事务/ 状态/ 为/ 0ThenFORPBA/ -/ bitmap/ 中/ 的/ 每个/ 位/ DOIF/ 这/ 一位/ 为/ 1Thenppa/ =/ 该/ 位/ 对应/ 的/ 物理地址/ ;/ lpa/ =/ 获取/ ppa/ 页/ 空闲/ 区/ LBA/ 域值/ ;/ 如果/ 事务/ 状态/ 为/ 0/ ,/ 则/ 可以/ 完全/ 释放/ 该/ 事务/ 对应/ 的/ 链表/ 节点/ ./ 如果/ 事务/ 状态/ 为/ 1/ ,/ 则/ 需要/ 根据/ 事务/ 对应/ 的/ 链表/ 中/ 的/ 每个/ 节点/ 的/ 更新/ 操作/ 内容/ 产生/ 相应/ 的/ 闪存/ 数据/ 页/ ,/ 把/ 修改/ 前/ 的/ 闪存/ 数据/ 页/ 对应/ 的/ PBA/ -/ bitmap/ 位置/ 0/ ,/ 并且/ 把/ 新/ 产生/ 的/ 闪存/ 数据/ 页/ 对应/ 的/ PBA/ -/ bitmap/ 位置/ 1/ ,/ 最后/ 把/ 该/ 链表/ 节点/ 从/ 该/ 链表/ 中/ 删除/ 并/ 释放/ 空间/ ./ 最终/ 获得/ 正确/ 完整/ 的/ 闪存/ 数据/ 页/ 的/ 最终/ 状态/ 位图/ PBA/ -/ bitmap/ ./ 最后/ 一步/ 和/ SPFP/ 模型/ 中/ 的/ 相同/ ./ 虽然/ 在/ 算法/ 3/ 中/ 需要/ 对/ 相变/ 存储器/ 进行/ 读写操作/ ,/ 但是/ 相变/ 存储器/ 具有/ 接近/ 内存/ 的/ 读/ 性能/ ,/ 并且/ 写/ 性能/ 也/ 介于/ 内存/ 和/ 闪存/ 之间/ ,/ 因此/ 系统/ 整体/ 性能/ 不会/ 受到/ 太/ 大/ 影响/ ./ 5/ 实验/ 结果/ 与/ 分析/ 本/ 部分/ 通过/ TPC/ -/ C/ [/ 17/ ]/ 基准/ 测试/ 验证/ 本文/ 提出/ 的/ SPFP/ 和/ SPFLP/ 模型/ 的/ 性能/ ./ 首先/ 描述/ 实验/ 环境/ ,/ 然后/ 对比/ 全/ 闪存/ 的/ 影子/ 页/ 恢复/ 方法/ 和/ 本文/ 两个/ 模型/ 的/ 性能/ ./ 5.1/ 实验/ 环境/ 为了/ 更好/ 地/ 展示/ 性能/ ,/ 本文/ 实现/ 了/ Trace/ 驱动/ 的/ 闪存/ 模拟器/ 和/ 相变/ 存储器/ 模拟器/ ,/ 通过/ 参数/ 配置/ 可以/ 模拟/ MLCNAND/ 闪存/ 芯片/ 和/ 相变/ 存储器/ ./ 实验/ 平台/ 采用/ Lenovo/ 昭阳/ K46A/ ,/ 其/ 处理器/ 为/ Intel/ 酷睿/ i5450M/ ,/ 双核/ 4/ 线程/ ,/ 内存大小/ 2GB/ ./ 操作系统/ 使用/ 的/ 是/ Fedora14/ ,/ 内核/ 版本/ 为/ Linux2/ ./ 6.35/ ./ 鉴于/ 此/ ,/ 配置/ 相变/ 存储器/ 大小/ 为/ 1GB/ ,/ MLCNAND/ 闪存/ 大小/ 为/ 32GB/ ./ 保留/ 闪存/ 10/ %/ 的/ 空间/ 用于/ 空间/ 回收/ ,/ 空间/ 回收/ 阈值/ 设置/ 为/ 全部/ 可用/ 空间/ 的/ 5/ %/ ./ 我们/ 实现/ 了/ 全/ 闪存/ 的/ 影子/ 页/ 恢复/ 技术/ (/ SP/ )/ 、/ 采用/ 组提/ Page8/ 交/ 的/ 全/ 闪存/ 的/ 影子/ 页/ 恢复/ 技术/ (/ GSP/ )/ 、/ SPFP/ 和/ SPFLP4/ 种/ 事务/ 恢复/ 模型/ ,/ 事务/ 并发/ 处理/ 采用/ 严格/ 的/ 两/ 阶段/ 加锁/ 机制/ ./ 缓冲区/ 采用/ 常用/ 的/ 缓冲区/ 替换/ 策略/ LRU/ ./ 在/ PostgreSQL8/ ./ 4/ 上/ 运行/ TPC/ -/ C/ 事务/ 并/ 记录/ 数据/ 访问/ 请求/ ,/ 获得/ 标准/ 的/ 在线/ 事务处理/ 负载/ ,/ 即/ TPC/ -/ C/ 负载/ Trace/ ./ 我们/ 利用/ 50/ 个/ 客户端/ 和/ 20/ 个/ 仓库/ 产生/ 该/ Trace/ ,/ 用于/ 测试/ SP/ 、/ GSP/ 、/ SPFP/ 和/ SPFLP/ 的/ 性能/ ./ 同时/ ,/ 事务/ 的/ 回滚/ 比率/ 设置/ 为/ 默认值/ 5/ %/ ./ 闪存/ 和/ 相变/ 存储器/ 的/ 参数/ 详见/ 表/ 1/ ./ 其它/ 参数/ 详见/ 表/ 2/ ./ 参数/ 逻辑/ 页/ 大小/ 缓冲/ 池大/ 小组/ 提交/ 策略/ 参数值/ 4KB5/ ./ 2/ 性能/ 对比/ 分析/ 从/ 事务/ 吞吐/ (/ 单位/ 时间/ 内/ 处理事务/ 数/ )/ 、/ 事务/ 执行/ 时间/ (/ Trace/ 的/ 总/ 执行/ 时间/ )/ 、/ 空间/ 回收/ 代价/ (/ 空间/ 回收/ 执行/ 时间/ )/ 和/ 恢复/ 代价/ (/ 恢复/ 执行/ 时间/ )/ 4/ 个/ 方面/ 对比/ 了/ SP/ 、/ GSP/ 、/ SPFP/ 和/ SPFLP4/ 种/ 恢复/ 模型/ ./ 实验/ 对比/ 数据/ 如图/ 6/ ~/ 图/ 9/ 所示/ ./ 如图/ 6/ 和/ 图/ 7/ 所示/ ,/ SPFP/ 的/ 事务/ 吞吐/ 和/ 事务/ 执行/ 时间/ 都/ 要/ 优于/ SP/ 和/ GSP/ ,/ 因为/ 相变/ 存储器/ 的/ 读写/ 速度/ 要/ 远高于/ 闪存/ 的/ 读写/ 速度/ ./ 采用/ 组/ 提交/ 策略/ 的/ GSP/ 会/ 丢失/ 一定量/ 的/ 已/ 提交/ 数据/ ./ SPFLP/ 的/ 吞吐能力/ 和/ 事务/ 执行/ 时间/ 也/ 要略/ 优于/ SPFP/ ./ 虽然/ 在/ SPFLP/ 中/ 更新/ 操作/ 会/ 产生/ 大量/ 对/ 相变/ 存储器/ 的/ 写/ 操作/ ,/ 但是/ SPFLP/ 所/ 采用/ 的/ 非/ 强制/ 缓冲区/ 管理策略/ 却/ 极大/ 地/ 减少/ 了/ 对/ 闪存/ 的/ 写/ 操作/ ,/ 并且/ 闪存/ 的/ 写/ 操作/ 延迟/ 要/ 远大于/ 相变/ 存储器/ 的/ 写/ 操作/ 延迟/ ,/ 所以/ 整体/ 上/ 来说/ SPFLP/ 性能/ 还是/ 优于/ SPFP/ 的/ 事务/ 并行处理/ 性能/ ./ 由于/ 在/ 获取/ 事务/ 状态/ 过程/ ,/ SP/ 要/ 比/ GSP/ 读取/ 更/ 多/ 的/ 闪存/ 页/ ,/ 所以/ SP/ 空间/ 回收/ 代价/ 和/ 数据库/ 恢复/ 代价/ 要/ 大于/ GSP/ 空间/ 回收/ 代价/ 和/ 数据库/ 恢复/ 代价/ ,/ 如图/ 8/ 和/ 9/ 所示/ ./ 在/ 获取/ 事务/ 最终/ 状态/ 时/ ,/ SPFP/ 和/ SPFLP/ 都/ 不/ 需要/ 读/ 闪存/ ,/ 所以/ SPFP/ 和/ SPFLP/ 的/ 空间/ 回收/ 代价/ 和/ 数据库/ 恢复/ 代价/ 要/ 低于/ SP/ 和/ GSP/ 的/ 空间/ 回收/ 代价/ 和/ 数据库/ 恢复/ 代价/ ./ 由于/ SPFP/ 和/ SPFLP/ 采用/ 同样/ 的/ 空间/ 回收/ 机制/ ,/ SPFP/ 和/ SPFLP/ 具有/ 相同/ 的/ 空间/ 回收/ 代价/ ,/ 如图/ 8/ 所示/ ./ 如图/ 9/ 所示/ ,/ SPFLP/ 的/ 恢复/ 代价/ 大于/ SPFP/ 的/ 恢复/ 代价/ ,/ 主要/ 原因/ 有/ 以下/ 3/ 点/ :/ (/ 1/ )/ 相变/ 存储器/ 上/ 的/ 事务/ 信息/ 增多/ ,/ SPFLP/ 记录/ 了/ 事务/ 更新/ 操作/ 的/ 所有/ 信息/ ;/ (/ 2/ )/ SPFLP/ 在/ 完成/ 恢复/ 过程/ 中/ 需要/ 删除/ 和/ 释放/ 节点/ 空间/ ;/ (/ 3/ )/ SPFLP/ 在/ 完成/ 恢复/ 过程/ 中/ 需要/ 改变/ 链表/ 节点/ 中/ 指向/ 下/ 一个/ 节点/ 的/ 指针/ ./ 而由表/ 1/ 可知/ ,/ 相变/ 存储器/ 的/ 写/ 性能/ 和/ 读/ 性能/ 要/ 相差/ 两个/ 数量级/ ,/ 所以/ 会/ 消耗/ 更长/ 的/ 时间/ 来/ 完成/ 系统故障/ 恢复/ ./ 6/ 结论/ 相变/ 存储器/ 同时/ 具有/ 内存/ 、/ 磁盘/ 和/ 闪存/ 的/ 优良/ 特性/ ,/ 在/ 数据库系统/ 中/ 充分发挥/ 相变/ 存储器/ 的/ 优势/ 特性/ 以/ 提高/ 整个/ 数据库系统/ 的/ 性能/ 成为/ 了/ 新/ 的/ 研究/ 热点/ ./ 本文/ 基于/ 相变/ 存储器/ 和/ 闪存/ 的/ 混合/ 存储/ 架构/ 提/ Page9/ 出/ 一种/ 基于/ 影子/ 页/ 的/ 数据库/ 事务/ 恢复/ 模型/ SPFP/ ,/ 利用/ 相变/ 存储器/ 进行/ 事务管理/ ./ 随后/ 基于/ SPFP/ 提出/ 了/ 一种/ 支持/ 非/ 强制/ 缓冲区/ 管理策略/ 的/ 数据库/ 事务/ 恢复/ 模型/ SPFLP/ ,/ 利用/ 相变/ 存储器/ 跟踪/ 并/ 记录/ 事务/ 更新/ 操作/ ./ 通过/ 实验/ 证明/ SPFP/ 和/ SPFLP/ 模型/ 能够/ 大大提高/ 事务处理/ 能力/ ./ 

