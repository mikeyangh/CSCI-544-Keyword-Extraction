Page1/ 基于/ OpenCL/ 的/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 性能/ 优化/ 研究/ 贾海鹏/ 张云泉/ 袁良/ 李士/ 刚/ (/ 中国科学院计算技术研究所/ 计算机/ 体系结构/ 国家/ 重点/ 实验室/ 北京/ 100190/ )/ 摘要/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 是/ 最为/ 成功/ 的/ 可/ 实用/ 的/ 人脸/ 检测/ 算法/ 之一/ ./ 然而/ ,/ 随着/ 该/ 算法/ 所在/ 领域/ 数据处理/ 规模/ 的/ 不断扩大/ ,/ 现有/ 算法/ 的/ 性能/ 已经/ 越来越/ 无法/ 满足/ 日益增长/ 的/ 交互性/ 与/ 实时性/ 要求/ ./ 使用/ GPU/ 计算/ 平台/ 提升/ 该/ 算法/ 性能/ ,/ 以/ 满足/ 日益增长/ 的/ 实时性/ 要求/ 已经/ 成为/ 研究/ 热点/ ./ 然而/ ,/ 该/ 算法/ 在/ 对/ GPU/ 的/ 实现/ 和/ 优化/ 中/ ,/ 存在/ 线程/ 间/ 负载/ 不/ 均衡/ 的/ 非/ 规则/ 特性/ ,/ 如果/ 仅/ 使用/ 传统/ 的/ 优化/ 方法/ ,/ 则/ 难以/ 在/ GPU/ 计算/ 平台/ 上/ 达到/ 较/ 高性能/ ./ 针对/ 此种/ 情况/ ,/ 该文/ 构建/ 了/ 针对/ 此类/ 算法/ 的/ 并行/ 优化/ 框架/ ,/ 通过/ Uberkernel/ 、/ 粗粒度/ 并行/ 、/ PersistentThread/ 、/ 线程/ 与/ 数据/ 的/ 动态/ 映射/ 、/ 全局/ 及/ 本地/ 队列/ 等/ 优化/ 方法/ 的/ 应用/ ,/ 突破/ 了/ 负载/ 不/ 均衡/ 非/ 规则/ 特性/ 导致/ 的/ 性能/ 瓶颈/ ,/ 大幅提高/ 了/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ ./ 同时/ ,/ 该文/ 通过/ 对/ 不同/ GPU/ 计算/ 平台/ 关键/ 性能参数/ 的/ 定义/ 、/ 抽取/ 和/ 传递/ ,/ 实现/ 了/ 该/ 算法/ 在/ 不同/ GPU/ 计算/ 平台/ 间/ 的/ 性能/ 移植/ ./ 实验/ 结果表明/ ,/ 与/ OpenCV2/ ./ 4/ 中/ 经过/ 高度/ 优化/ 的/ CPU/ 版本/ 在/ IntelXeonX5550CPU/ 上/ 的/ 性能/ 相比/ ,/ 优化/ 后/ 的/ 算法/ 在/ AMDHD7970/ 和/ NVIDIAGTX680/ 两个/ 不同/ GPU/ 计算/ 平台/ 上/ 分别/ 达到/ 了/ 11.24/ ~/ 20.27/ 和/ 9.24/ ~/ 17.62/ 倍/ 的/ 加速/ 比/ ,/ 不仅/ 实现/ 了/ 高性能/ ,/ 而且/ 实现/ 了/ 在/ 不同/ GPU/ 计算/ 平台/ 间/ 的/ 性能/ 移植/ ./ 关键词/ OpenCL/ ;/ 负载/ 不/ 均衡/ ;/ 任务/ 队列/ ;/ 线程/ 与/ 任务/ 动态/ 映射/ ;/ 性能/ 移植/ 1/ 引言/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 由/ Viola/ 和/ Jones/ [/ 1/ ]/ 于/ 2001/ 年/ 提出/ ,/ 是/ 最为/ 成功/ 且/ 在/ 一定/ 程度/ 上/ 满足/ 实时/ 要求/ 的/ 可/ 实用/ 人脸/ 检测/ 算法/ ,/ 并/ 在/ 执法/ 监控/ 、/ 安防/ 系统/ 和/ 娱乐/ 等/ 领域/ 有着/ 广泛应用/ ./ 然而/ ,/ 随着/ 该/ 算法/ 所在/ 领域/ 需要/ 同时/ 处理/ 的/ 数据/ 规模/ 的/ 不断扩大/ 以及/ 图片/ 分辨率/ 的/ 不断/ 提高/ ,/ 现有/ 算法/ 的/ 性能/ 已经/ 越来越/ 无法/ 满足/ 其/ 日益增长/ 的/ 交互性/ 与/ 实时性/ 要求/ ,/ 提高/ 该/ 算法/ 性能/ 的/ 需求/ 日益/ 迫切/ ./ 与此同时/ ,/ 随着/ GPU/ 通用/ 计算/ 的/ 发展/ ,/ 特别/ 是/ GPU/ 计算能力/ 与/ 可编程/ 性/ 的/ 不断/ 增强/ ,/ GPU/ 受到/ 了/ 越来越/ 多/ 应用/ 开发人员/ 的/ 青睐/ ,/ 利用/ GPU/ 计算/ 平台/ 实现/ 对/ 应用程序/ 的/ 加速/ 已/ 成为/ 提高/ 程序/ 性能/ 的/ 主要/ 模式/ ./ 使用/ GPU/ 计算/ 平台/ 提升/ 人脸/ 检测/ 算法/ 的/ 性能/ ,/ 以/ 满足/ 日益增长/ 的/ 实时性/ 要求/ 已经/ 成为/ 研究/ 热点/ ./ 本文/ 将/ 对/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 实现/ 和/ 优化/ 的/ 关键技术/ 和/ 方法/ 进行/ 深入研究/ ./ 同时/ ,/ 针对/ 当前/ GPU/ 架构/ 日益/ 多样化/ 以及/ 人脸/ 检测/ 算法/ 应用/ 场景/ 不/ 确定/ 的/ 特点/ ,/ 本文/ 进行/ 该/ 算法/ 在/ 不同/ GPU/ 计算/ 平台/ 间/ 的/ 性能/ 移植/ 研究/ ./ GPU/ 计算/ 平台/ 具有/ 大规模/ 细粒度/ 并行/ 的/ 硬件/ 架构/ 特征/ ,/ 这/ 对于/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 来说/ 是/ 一把/ 双刃剑/ :/ 一方面/ ,/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 具有/ 良好/ 的/ 并行性/ ,/ 非常适合/ GPU/ 大规模/ 并行/ 的/ 架构/ 特点/ ;/ 另一方面/ ,/ 在/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ GPU/ 实现/ 中/ ,/ 线程/ 间会/ 产生/ 严重/ 的/ 负载/ 不/ 均衡/ 现象/ ,/ 它/ 将/ 导致/ 算法/ 性能/ 的/ 急剧/ 降低/ ,/ 这/ 无疑/ 是/ GPU/ 这种/ 细粒度/ 并行/ 处理器/ 的/ 梦魇/ ./ 不幸/ 的/ 是/ ,/ 传统/ GPU/ 编程/ 一般/ 采用/ 静态/ 编程/ 模式/ ,/ 即/ 在/ GPUkernel/ 启动/ 之前/ ,/ 线程/ 和/ 数据/ 的/ 映射/ 就/ 已经/ 确定/ ,/ 线程/ 被/ GPU/ 硬件/ 静态/ 顺序/ 调度/ 执行/ ./ 这种/ 编程/ 模式/ 虽然/ 对/ 任务/ 规则/ 的/ 数据/ 级/ 并行算法/ 具有/ 良好/ 的/ 适用性/ ,/ 但是/ 对于/ 像/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 这样/ 具有/ 线程/ 间/ 负载/ 不/ 均衡/ 非/ 规则/ 特性/ 的/ 算法/ ,/ 该/ 编程/ 模式/ 会/ 产生/ 严重/ 的/ 性能/ 瓶颈/ ,/ 严重/ 制约/ 算法/ 性能/ ./ 因此/ ,/ 要/ 提高/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ ,/ 必须/ 研究/ 新/ 的/ 优化/ 方法/ 和/ 策略/ ,/ 突破/ 由于/ 线程/ 间/ 负载/ 不/ 均衡/ 导致/ 的/ 性能/ 瓶颈/ ,/ 实现/ 算法/ 到/ 硬件/ 架构/ 的/ 良好/ 映射/ ,/ 从而/ 有效/ 地/ 提高/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ ./ 对此/ ,/ 本文/ 提出/ 了/ 一个/ 面向/ GPU/ 计算/ 平台/ ,/ 针对/ 具有/ 负载/ 不/ 均衡/ 特性/ 算法/ 的/ 性能/ 优化/ 框架/ ./ 通过/ Uberkernel/ 、/ 粗粒度/ 并行/ 、/ PersistentThread/ 、/ 线程/ 与/ 数据/ 的/ 动态/ 映射/ 、/ 全局/ 及/ 本地/ 队列/ 等/ 优化/ 方法/ 的/ 应用/ ,/ 突破/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 的/ 实现/ 中/ 由于/ 负载/ 不/ 均衡/ 导致/ 的/ 性能/ 瓶颈/ ,/ 从而/ 完成/ 了/ 该/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 实现/ 和/ 优化/ ./ 本文/ 提出/ 的/ 并行/ 优化/ 框架/ 不仅/ 大大提高/ 了/ 人脸/ 检测/ 算法/ 的/ 性能/ ,/ 而且/ 也/ 能够/ 在/ 一定/ 程度/ 上/ 指导/ 类似/ 算法/ 在/ GPU/ 上/ 的/ 移植/ 和/ 优化/ ,/ 具有/ 一定/ 的/ 普适性/ ./ 同时/ ,/ 本文/ 还/ 针对/ 当前/ GPU/ 架构/ 日益/ 多样化/ 以及/ 人脸/ 检测/ 算法/ 应用/ 场景/ 不/ 确定/ 的/ 特点/ ,/ 总结/ 不同/ GPU/ 平台/ 架构/ 的/ 异同/ ,/ 通过/ 关键/ 性能参数/ 的/ 定义/ 、/ 抽取/ 和/ 传递/ ,/ 实现/ 了/ 人脸/ 检测/ 算法/ 在/ 不同/ GPU/ 计算/ 平台/ 间/ 的/ 性能/ 移植/ ./ 实验/ 结果表明/ :/ 优化/ 后/ 的/ 算法/ 相对/ 于/ OpenCV/ ①/ 库中/ 高度/ 优化/ 的/ CPU/ 版本/ 在/ IntelXeonX5550/ 上/ 的/ 性能/ ,/ 在/ AMDHD7970/ 和/ NVIDIAGTX680/ 两个/ GPU/ 计算/ 平台/ 上/ ,/ 分别/ 达到/ 了/ 11.24/ ~/ 20.27/ 和/ 9.24/ ~/ 17.62/ 倍/ 的/ 加速/ 比/ ./ 它/ 不仅/ 实现/ 了/ 高性能/ ,/ 而且/ 实现/ 了/ 不同/ GPU/ 计算/ 平台/ 间/ 的/ 性能/ 移植/ ./ 值得注意/ 的/ 是/ ,/ 本文/ 工作/ 是/ 在/ 已有/ 工作/ [/ 2/ ]/ 的/ 基础/ 上/ 进行/ 的/ 改进/ 和/ 提升/ ./ 相对/ 于/ 之前/ 工作/ ,/ 本文/ 主要/ 工作/ 体现/ 在/ 整体/ 优化/ 框架/ 的/ 提出/ 、/ Uberkernel/ 调度/ 、/ 本地/ 队列/ 分/ 层次/ 优化/ 、/ 新/ 的/ 线程/ 与/ 任务/ 动态/ 映射/ 机制/ 4/ 个/ 方面/ ./ 与/ 前期工作/ 相比/ ,/ 最终/ 获得/ 了/ 22.3/ %/ ~/ 51.6/ %/ 的/ 性能/ 提升/ ./ 本文/ 的/ 主要/ 贡献/ 如下/ :/ (/ 1/ )/ 研究/ 和/ 实现/ 了/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 关键/ 优化/ 技术/ 和/ 方法/ ./ ①/ OpenCV/ :/ http/ :/ // // www/ ./ opencv/ ./ org/ ./ cnPage3/ (/ 2/ )/ 提出/ 了/ 一个/ 面向/ GPU/ 计算/ 平台/ ,/ 针对/ 具有/ 负载/ 不/ 均衡/ 特征/ 算法/ 的/ 并行/ 优化/ 框架/ ./ (/ 3/ )/ 实现/ 了/ 人脸/ 检测/ 算法/ 在/ NVIDIAGTX680/ 和/ AMDHD7970/ 两个/ 不同/ GPU/ 计算/ 平台/ 上/ 的/ 高性能/ 与/ 性能/ 移植/ ./ 本文/ 第/ 2/ 节为/ 相关/ 工作/ 介绍/ ,/ 详细/ 讨论/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 实现/ 和/ 优化/ 的/ 相关/ 工作/ ;/ 在/ 第/ 3/ 节/ 简要/ 介绍/ GPU/ 架构/ 以及/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 之后/ ;/ 第/ 4/ 节/ 详细/ 讨论/ 该/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 实现/ 和/ 优化/ 的/ 关键技术/ 和/ 方法/ ;/ 并/ 在/ 第/ 5/ 节/ 给出/ 性能/ 评估/ 结果/ ;/ 最后/ ,/ 第/ 6/ 节/ 进行/ 总结/ ./ 2/ 相关/ 工作/ 近年来/ ,/ 关于/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ GPU/ 移植/ 和/ 优化/ 已有/ 许多/ 工作/ ,/ 代表性/ 的/ 工作/ 主要/ 有/ :/ David/ 等/ 人/ [/ 3/ ]/ 通过/ 优化/ 图像/ 积分/ 图/ 算法/ 在/ GPU/ 上/ 的/ 性能/ 来/ 提高/ 人脸/ 检测/ 算法/ 的/ 整体/ 性能/ ,/ 但是/ 对/ 人脸/ 检测/ 部分/ 在/ GPU/ 上/ 的/ 实现/ 和/ 优化/ 工作/ 较/ 少/ ,/ 更/ 没有/ 指出/ 如何/ 解决/ 算法/ 中/ 由于/ 负载/ 不/ 平衡/ 问题/ 而/ 导致/ 的/ 性能/ 瓶颈/ ./ Kong/ 等/ 人/ [/ 4/ ]/ 通过/ 使用/ share/ -/ memory/ 存储/ 待/ 检测/ 窗口/ ,/ 通过/ 数据/ 本地化/ 减小/ 对/ 访存/ 带宽/ 的/ 依赖/ ,/ 但/ 其/ 主要/ 工作/ 集中/ 在/ 检测/ 窗口/ 的/ 并行处理/ 上/ ,/ 并/ 没有/ 对/ 算法/ 并行性/ 进行/ 充分/ 挖掘/ ,/ 更/ 没有/ 解决/ 算法/ 中/ 由于/ 负载/ 不/ 平衡/ 问题/ 而/ 导致/ 的/ 性能/ 瓶颈/ ./ Sharma/ 等/ 人/ [/ 5/ ]/ 将/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 移植/ 到/ GPU/ ,/ 通过/ 建立/ 图像/ 金字塔/ 机制/ 实现/ 对/ 不同/ 大小/ 的/ 缩放/ 图像/ 的/ 统一/ 处理/ ,/ 从而/ 在/ 一定/ 程度/ 上/ 缓解/ 了/ 图像/ 间/ 负载/ 不/ 均衡/ 的/ 问题/ ,/ 但/ 对于/ Thread/ 级/ 和/ work/ -/ group/ 级/ 的/ 负载/ 不/ 均衡/ 现象/ 没有/ 进行/ 进一步/ 研究/ ./ Ghorayeb/ 等/ 人/ [/ 6/ ]/ 充分/ 分析/ 了/ 人脸/ 检测/ 算法/ 的/ 并行性/ ,/ 提出/ 该/ 算法/ 具有/ 三级/ 并行性/ :/ 特征值/ 计算/ 并行/ 、/ 检测/ 窗口/ 并行/ 和/ 缩放/ 图像/ 并行/ ,/ 并/ 通过/ 对/ 这/ 三级/ 并行/ 的/ 性能/ 优化/ ,/ 使/ 人脸/ 检测/ 算法/ 的/ 性能/ 达到/ 了/ 在/ FPGA/ 上/ 的/ 性能/ ,/ 但/ 在/ 负载/ 不/ 均衡/ 的/ 处理/ 上/ ,/ 仅仅/ 通过/ 在/ 工作量/ 大/ 的/ 一级/ 分类器/ 中/ ,/ 将/ 负责/ 每个/ 探测/ 窗口/ 的/ 线程/ 数目/ 提高/ 两倍/ 的/ 方法/ 来/ 解决/ ./ 这种/ 方法/ 不仅/ 简单/ 粗暴/ 而且/ 非常/ 低效/ ,/ 只能/ 在/ 较/ 低/ 的/ 程度/ 上/ 缓解/ 负载/ 不/ 均衡/ 问题/ ,/ 但/ 不能/ 有效/ 解决/ ./ Jia/ 等/ 人/ [/ 2/ ]/ 认为/ 层次/ 式/ 队列/ 机制/ 是/ 解决/ 负载/ 不/ 均衡/ 的/ 优先选择/ ,/ 并/ 构建/ 了/ 本地/ 和/ 全局/ 两级/ 队列/ 解决/ 人脸/ 检测/ 算法/ Thread/ 级/ 和/ work/ -/ group/ 级/ 负载/ 不/ 均衡/ 问题/ ./ 然而/ 该/ 工作/ 的/ 全局/ 队列/ 实现/ 较为简单/ ,/ 没有/ 实现/ 线程/ 和/ 数据/ 的/ 动态/ 映射/ 机制/ ,/ 导致/ 全局/ 队列/ 的/ 任务调度/ 实现/ 方式/ 不够/ 高效/ ,/ 同时/ 也/ 没有/ 解决/ 全局/ 队列/ 的/ 高效/ 访问/ 的/ 问题/ ./ 总之/ ,/ 虽然/ 上述/ 工作/ 在/ 对/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ GPU/ 移植/ 方面/ 取得/ 了/ 很大/ 的/ 进展/ ,/ 但/ 在/ 并行性/ 发掘/ 以及/ 负载/ 不/ 均衡/ 导致/ 的/ 性能/ 瓶颈/ 的/ 处理/ 上/ ,/ 这些/ 工作/ 的/ 研究/ 依然/ 不够/ 深入/ ,/ 更/ 没有/ 给出/ 一个/ 统一/ 、/ 有效/ 的/ 解决方案/ ./ 与此同时/ ,/ 近年来/ 也/ 有/ 许多/ 工作/ 通过/ 其他/ 算法/ 的/ GPU/ 移植/ ,/ 提出/ 了/ 克服/ GPU/ 计算/ 平台/ 上线/ 程间/ 负载/ 不/ 均衡/ 的/ 方法/ 和/ 策略/ ./ 如/ Tzeng/ 等/ 人/ [/ 7/ ]/ 通过/ 光纤/ 追踪/ 算法/ 在/ GPU/ 上/ 的/ 移植/ 和/ 优化/ ,/ 构建/ 了/ 非/ 规则/ 算法/ 在/ GPU/ 实现/ 中/ 的/ 作业管理/ 机制/ ,/ 并/ 提出/ 有效/ 的/ 内存/ 管理/ 和/ 动态/ 调度/ 是/ 负载/ 不/ 均衡/ 应用/ 在/ GPU/ 上/ 达到/ 高性能/ 的/ 关键因素/ ./ Merrill/ 等/ 人/ [/ 8/ ]/ 和/ Aila/ 等/ 人/ [/ 9/ ]/ 根据/ 以上/ 方法/ ,/ 分别/ 完成/ 了/ 光线/ 追踪/ 和/ 广度/ 优先/ 图/ 遍历/ 算法/ 在/ GPU/ 上/ 的/ 实现/ 和/ 优化/ ,/ 并/ 取得/ 了/ 很/ 好/ 的/ 加速/ 比/ ./ Nasre/ 等/ 人/ [/ 10/ ]/ 通过/ 图/ 算法/ 在/ 众核/ 计算/ 平台/ 上/ 的/ 实现/ 和/ 优化/ ,/ 根据/ 其/ 算法/ 特性/ ,/ 得出/ 在/ 众核/ 编程/ 环境/ 下/ ,/ Topology/ -/ driven/ 比/ Data/ -/ driven/ 更能/ 降低/ 负载/ 不/ 均衡/ ,/ 从而/ 会/ 大幅/ 提升/ 程序/ 性能/ 的/ 结论/ ./ Cederman/ 等/ 人/ [/ 11/ ]/ 和/ Chatterjee/ 等/ 人/ [/ 12/ ]/ 通过/ 将/ 改进/ 的/ 任务/ 窃取/ 算法/ 应用/ 到/ 全局/ 队列/ 中/ ,/ 以/ 动态/ 任务调度/ 的/ 方式/ 大大/ 缓解/ 了/ work/ -/ group/ 间/ 的/ 负载/ 不/ 均衡/ 现象/ ,/ 从而/ 获得/ 了/ 较/ 高/ 的/ 性能/ 加速/ ,/ 但/ 该/ 方法/ 实现/ 过于/ 复杂/ ./ Yan/ 等/ 人/ [/ 13/ ]/ 通过/ 引进/ 邻接/ 同步/ 的/ 定义/ 和/ 算法/ ,/ 通过/ 消除/ 全局/ 同步/ 以及/ 降低/ 线程/ 间/ 的/ 任务/ 依赖/ 达到/ 解决/ 负载/ 不/ 均衡/ 的/ 目的/ ,/ 从而/ 提高/ 了/ 程序/ 性能/ ./ Burtscher/ 等/ 人/ [/ 14/ ]/ 提出/ 了/ 针对/ 具有/ 条件/ 分支/ 和/ 访存/ 不规则/ 特征/ 的/ 算法/ 在/ GPU/ 上/ 实现/ 和/ 优化/ 的/ 方法/ 和/ 策略/ ./ Nasre/ 等/ 人/ [/ 15/ ]/ 针对/ 非/ 规则/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 实现/ 和/ 优化/ 中/ ,/ 原子/ 操作/ 可能/ 会/ 导致/ 的/ 性能/ 瓶颈/ ,/ 提出/ 了/ atom/ -/ free/ 编程/ 方法/ ,/ 有效/ 地/ 解决/ 了/ 原子/ 操作/ 导致/ 的/ 性能/ 瓶颈/ ./ 虽然/ ,/ 这些/ 工作/ 针对/ 负载/ 不/ 均衡/ 算法/ 在/ GPU/ 上/ 的/ 实现/ 和/ 优化/ 都/ 提出/ 了/ 不同/ 的/ 编程/ 和/ 优化/ 方法/ ,/ 也/ 都/ 取得/ 了/ 很/ 好/ 的/ 加速/ 效果/ ,/ 但是/ 这些/ 方法/ 都/ 没有/ 在/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 上/ 验证/ 其/ 有效性/ ./ 然而/ ,/ 这些/ 工作/ 提出/ 的/ 方法/ 和/ 思想/ ,/ 对于/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ GPU/ 移植/ 具有/ 很/ 好/ 的/ 借鉴/ 意义/ ./ 本文/ 将/ 从/ 上述/ 的/ 已有/ 研究/ 工作/ 出发/ ,/ 结合/ 已经/ 提出/ 的/ 优化/ 策略/ 方法/ ,/ 根据/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ 算法/ 特点/ 和/ GPU/ 硬件/ 架构/ 特征/ ,/ 实现/ 该/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 高性能/ 移植/ ./ 同时/ ,/ 通过/ 抽象/ 影响/ 性能/ 的/ 关键/ 参数/ ,/ 本文/ 实现/ 了/ 该/ 算法/ 在/ 不同/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ 移植/ ./ Page43/ 背景/ 介绍/ 本节/ 将/ 详细描述/ GPU/ 硬件/ 架构/ 特征/ 和/ Viola/ -/ Jones/ 人脸/ 检测/ 的/ 算法/ 特点/ ./ 3.1/ GPU/ 架构/ 随着/ GPU/ 通用/ 计算/ 应用/ 的/ 推广/ 及其/ 应用领域/ 的/ 不断扩大/ ,/ GPU/ 架构/ 的/ 发展/ 非常/ 迅速/ ./ 主流/ 芯片/ 厂商/ 根据/ 实际/ 计算/ 需求/ ,/ 不断/ 发展/ 自己/ 的/ GPU/ 架构/ 来/ 满足/ 日益增长/ 的/ 市场需求/ 和/ 性能需求/ ./ NVIDIA/ 已经/ 发布/ 了/ 如/ Fermi/ [/ 16/ ]/ 、/ Kepler/ [/ 17/ ]/ 和/ Maxwell/ [/ 18/ ]/ 架构/ 的/ GPU/ ,/ AMD/ 也/ 发布/ 了/ Cypress/ 、/ Cayman/ 、/ GCN/ 架构/ [/ 19/ ]/ 的/ GPU/ ./ 这些/ GPU/ 都/ 具有/ 不同/ 的/ 架构/ 特点/ ,/ 对应/ 的/ 优化/ 策略/ 也/ 有/ 差异/ ./ 这种/ GPU/ 架构/ 的/ 日益/ 多样性/ ,/ 对/ 算法/ 移植/ 特别/ 是/ 性能/ 移植/ 提出/ 了/ 新/ 的/ 挑战/ ./ 幸运/ 的/ 是/ ,/ 虽然/ 不同/ 的/ GPU/ 架构/ 在/ 优化/ 方法/ 选择/ 以及/ 优化/ 细节/ 上会/ 有/ 不同/ ,/ 但是/ 从/ 整体/ 上/ 看/ ,/ GPU/ 架构/ 又/ 具有/ 很/ 好/ 的/ 统一性/ ,/ 即/ 都/ 是/ 大规模/ 细粒度/ 并行/ 处理器/ ,/ 且/ 具有/ 层次/ 式/ 的/ 架构/ 特点/ ,/ 这/ 主要/ 体现/ 在/ 4/ 个/ 方面/ :/ (/ 1/ )/ 在/ 计算/ 单元/ 的/ 组织/ 上/ ,/ GPU/ 由/ 多个/ 计算/ 单元/ (/ ComputeUnit/ ,/ CU/ )/ 组成/ ,/ 每个/ CU/ 又/ 由/ 多个/ 处理部件/ (/ ProcessingUnit/ ,/ PE/ )/ 组成/ ;/ (/ 2/ )/ 从/ 内存/ 组织/ 上/ ,/ 从/ 只能/ 被/ 一个/ 线程/ 访问/ 的/ 私有/ 内存/ ,/ 到/ 能够/ 被/ work/ -/ group/ 内/ 所有/ 线程/ 共享/ 的/ 本地/ 内存/ ,/ 再/ 到/ 可/ 被/ 所有/ 线程/ 访问/ 的/ 全局/ 内存/ ;/ (/ 3/ )/ 在线/ 程/ 调度/ 上/ ,/ GPU/ 一般/ 都/ 采用/ 静态/ 顺序/ 调度/ 模式/ ,/ 线程/ 和/ 数据/ 映射/ 在/ GPUkernel/ 启动/ 之前/ 就/ 已经/ 确定/ ,/ 线程/ 以/ work/ -/ group/ 为/ 单位/ 被/ 硬件/ 顺序/ 调度/ ;/ (/ 4/ )/ 在/ 编程/ 方式/ 上/ ,/ 都/ 采用/ 了/ Host/ +/ Device/ 的/ 编程/ 模式/ ,/ 即/ GPU/ 程序/ 依然/ 由/ CPU/ 端/ 控制/ ,/ CPU/ 设定/ 开启/ 线程/ 的/ 数目/ 后/ ,/ 将/ 计算/ 任务/ 发送到/ GPU/ 端/ 执行/ ,/ 线程/ 组织/ 也/ 都/ 采用/ 了/ Grid/ -/ Block/ -/ Thread/ 的/ 层次/ 式/ 组织/ 方式/ ./ GPU/ 这种/ 统一/ 的/ 架构/ 特点/ 和/ 线程/ 组织/ 调度/ 方式/ ,/ 使/ 性能/ 移植/ 成为/ 可能/ ./ Jia/ 等/ 人/ [/ 20/ ]/ 给出/ 了/ 在/ 不同/ GPU/ 计算/ 平台/ 上/ 优化/ 策略/ 的/ 选择/ 及/ 应用/ ./ 本文/ 将/ 以/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 为例/ ,/ 研究/ 该/ 算法/ 在/ 不同/ GPU/ 计算/ 平台/ 间/ 性能/ 移植/ 的/ 方法/ ./ 3.2/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 由/ 剑桥大学/ 的/ Viola/ 和/ Jones/ [/ 1/ ]/ 于/ 2001/ 年/ 最早/ 提出/ ,/ 是/ 最为/ 成功/ 且/ 满足/ 实时/ 要求/ 的/ 可/ 实用/ 人脸/ 检测/ 算法/ ./ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 使用/ Haar/ 特征值/ 进行/ 目标/ 检测/ :/ 通过/ Adaboost/ 算法/ 生成/ 级联/ 分类器/ ,/ 直接/ 对/ 图像/ 的/ 一小块/ 区域/ 进行/ 特征/ 匹配/ ,/ 从而/ 判断/ 该/ 区域/ 内/ 是否/ 有人/ 脸/ 存在/ ./ 该/ 算法/ 包括/ 训练/ 和/ 检测/ 两/ 部分/ :/ 训练/ 部分/ 使用/ Adaboost/ 算法/ 从/ 预先/ 收集/ 的/ 正负/ 样本/ 中/ 提取/ 特征值/ 进行/ 计算/ ,/ 最终/ 生成/ 一个/ 级联/ 分类器/ ;/ 检测/ 部分/ 使用/ 级联/ 分类器/ ,/ 通过/ 检测/ 窗口/ 的/ 移动/ 和/ 缩放/ ,/ 对/ 图像/ 上/ 的/ 人脸/ 进行/ 检测/ ./ 由于/ 训练/ 部分/ 可/ 脱机/ 执行/ ,/ 对/ 实时/ 要求/ 并/ 不/ 高/ ./ 因此/ ,/ 本文/ 只/ 讨论/ 算法/ 的/ 检测/ 部分/ 在/ GPU/ 上/ 的/ 实现/ 和/ 优化/ ./ 如图/ 1/ 所示/ ,/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 使用/ Haar/ 特征值/ 计算/ 特征/ ./ Haar/ 特征值/ 共/ 使用/ 了/ 3/ 种/ 类型/ 4/ 种/ 形式/ 的/ 特征/ 模板/ ,/ 每种/ 特征/ 模板/ 内/ 包含/ 黑色/ 和/ 白色/ 两种/ 矩形/ ,/ 该/ 模板/ 的/ 特征值/ 定义/ 为/ 白色/ 矩形/ 像素/ 和/ 减去/ 黑色/ 矩形/ 像素/ 和/ 的/ 差值/ ./ 图/ 1/ 所示/ 的/ 特征/ 模板/ 称为/ “/ 特征/ 原型/ ”/ ,/ “/ 特征/ 原型/ ”/ 在/ 图像/ 窗口/ 中/ 平移/ 伸缩/ 而/ 得到/ 的/ 特征/ 称为/ “/ 矩形/ 特征/ ”/ ,/ “/ 矩形/ 特征/ ”/ 的/ 值/ 称为/ “/ 特征值/ ”/ ./ 在/ 检测/ 过程/ 中/ ,/ 特征/ 模板/ 可以/ 以/ 任意/ 尺寸/ 放置/ 在/ 图像/ 窗口/ 上/ 的/ 任意/ 位置/ ./ 从而/ 形成/ 各种/ 形态/ ,/ 每/ 一种/ 形态/ 称为/ 一个/ 特征/ ./ 这样/ ,/ 通过/ 改变/ 特征/ 模板/ 的/ 大小/ 和/ 在/ 图像/ 中/ 的/ 位置/ ,/ 可/ 在/ 图像/ 窗口/ 中穷/ 举出/ 海量/ 特征/ ./ 图/ 2/ 显示/ 了/ 人脸/ 检测/ 中/ 的/ Haar/ 特征值/ 在/ 样本/ 窗口/ 中/ 的/ 位置/ ./ 对于/ 一个/ 24/ ×/ 24/ 的/ 图像/ 样本/ 而言/ ,/ 矩阵/ 特征/ 的/ 数目/ 可达/ 160000/ ,/ 这是/ 非常/ 庞大/ 的/ 计算/ 量/ ./ 而且/ 随着/ 图像/ 尺寸/ 的/ 不断/ 增大/ ,/ 特征/ 数目/ 也/ 会/ 快速增长/ ,/ 这/ 就/ 对/ 计算能力/ 提出/ 了/ 严峻/ 挑战/ ./ 同时/ ,/ 如果/ 每次/ Haar/ 特征值/ 的/ 计算/ ,/ 都/ 要/ 统计/ 矩形/ 中/ 所有/ 像素/ 的/ 和/ ,/ 那么/ 庞大/ 的/ 计算/ 量/ 无疑/ 会/ 降低/ 检测/ 的/ 速/ Page5/ 度/ ./ 为此/ ,/ Viola/ 与/ Jones/ 引入/ 了/ 积分/ 图/ 作为/ 输入/ 图像/ 的/ 一种/ 中间/ 表达形式/ ./ 在/ 完成/ 图像/ 的/ 积分/ 图/ 运算/ 后/ ,/ 通过/ 图像/ 积分/ 图来/ 完成/ Haar/ 特征值/ 的/ 计算/ ./ 因此/ ,/ 积分/ 图/ 生成/ 算法/ 的/ 性能/ 对于/ 人脸/ 检测/ 算法/ 的/ 性能/ 也/ 至关重要/ ./ 然而/ ,/ 这/ 超出/ 了/ 本文/ 的/ 讨论/ 范围/ ,/ 关于/ 积分/ 图/ 生成/ 算法/ 的/ GPU/ 移植/ ,/ 已有/ 大量/ 的/ 研究/ 工作/ ,/ 并且/ 已经/ 非常/ 成熟/ ./ 感兴趣/ 的/ 读者/ 可以/ 参考文献/ [/ 3/ ]/ ./ 图/ 3/ 显示/ 了/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ 主要/ 流程/ ,/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 通过/ 定义/ 检测/ 窗口/ 遍历/ 整幅/ 图像/ ,/ 使用/ Adaboost/ 方法/ 构建/ 的/ 级联/ 分类器/ 检测/ 检测/ 窗口/ 中/ 的/ 人脸/ ./ 值得注意/ 的/ 是/ ,/ 通过/ 使图/ 3Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 4/ 人脸/ 检测/ 算法/ 的/ GPU/ 实现/ 与/ 优化/ 4.1/ 并行性/ 分析/ 通过/ 3.2/ 节/ 的/ 算法/ 介绍/ ,/ 我们/ 可以/ 分析/ 得出/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 具有/ 良好/ 的/ 并行性/ ,/ 具体来说/ ,/ 该/ 算法/ 包含/ 3/ 级/ 并行性/ :/ (/ 1/ )/ 特征值/ 级/ 并行/ :/ 每个/ 特征值/ 的/ 计算/ 是/ 相互/ 独立/ 的/ ,/ 可以/ 并行执行/ ;/ (/ 2/ )/ 窗口/ 级/ 并行/ :/ 每个/ 检测/ 窗口/ 的/ 检测/ 是/ 相互/ 独立/ 的/ ,/ 可以/ 并行/ 检测/ ;/ (/ 3/ )/ 图像/ 级/ 并行/ :/ 为了/ 检测/ 大小/ 不同/ 的/ 人脸/ ,/ 需要/ 将/ 图像/ 进行/ 放缩/ ,/ 对/ 每/ 一幅/ 缩放/ 图像/ 的/ 检测/ 也/ 是/ 相互/ 独立/ 的/ ,/ 可以/ 并行执行/ ./ 由此可见/ ,/ 一方面/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ 计算/ 量/ 非常/ 大/ ,/ 但/ 另一方面/ ,/ 该/ 算法/ 又/ 具备/ 良好/ 的/ 并行性/ ./ 这种/ 算法/ 特性/ 非常适合/ GPU/ 计算/ 平台/ 大规模/ 并行/ 的/ 架构/ 特点/ ./ 针对/ 以上/ 分析/ ,/ 本文/ 实现/ 了/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ nave/ 版本/ ./ 4.2/ nave/ 实现/ 与/ 负载/ 不/ 均衡/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ nave/ 版本/ 采用/ 最/ 基本/ 、/ 最/ 简单/ 的/ 并行/ 化/ 策略/ ,/ 即用/ 级联/ 分类器/ 可/ 明显/ 加快/ 检测/ 速度/ ./ 检测/ 流程/ 具体/ 如下/ :/ 首先/ ,/ 为了/ 检测/ 出/ 图像/ 中/ 包含/ 的/ 不同/ 大小/ 的/ 所有人/ 脸/ ,/ 需要/ 按照/ 一定/ 大小/ 的/ 缩放/ 因子/ 缩放/ 图像/ ;/ 其次/ ,/ 使用/ 级联/ 分类器/ 对/ 检测/ 窗口/ 进行/ 检测/ ./ 级联/ 分类器/ 将/ 检测/ 窗口/ 交给/ 第一级/ 分类器/ ,/ 如果/ 检测/ 窗口/ 检测/ 为/ 未/ 包含/ 人脸/ ,/ 则/ 分类器/ 将/ 此/ 检测/ 窗口/ 丢弃/ 并/ 停止/ 检测/ ,/ 如果/ 当前/ 探测/ 窗口/ 被判/ 为/ 疑似/ 包含/ 人脸/ ,/ 则/ 进入/ 下/ 一级/ 分类器/ 继续/ 检测/ ./ 最后/ ,/ 只有/ 通过/ 所有/ 分类器/ 检测/ 的/ 窗口/ 才/ 被/ 判定/ 为/ 包含/ 人脸/ ./ 在/ 级联/ 分类器/ 中/ ,/ 分类器/ 的/ 复杂度/ 是/ 逐层/ 增加/ 的/ ,/ 层数/ 越深/ ,/ 检测/ 要求/ 越高/ ,/ 与/ 之/ 相对/ 应/ 的/ 计算/ 量/ 也/ 越/ 大/ ./ 仅/ 并行/ 化/ 检测/ 窗口/ 的/ 检测/ ,/ 具体/ 过程/ 为/ :/ (/ 1/ )/ 每次/ 只/ 处理/ 一幅/ 缩放/ 图像/ ,/ 在/ CPU/ 端/ 循环/ 启动/ OpenCLkernel/ 以/ 处理/ 所有/ 的/ 缩放/ 图像/ ;/ (/ 2/ )/ 对于/ 每幅/ 缩放/ 图像/ ,/ 每个/ 线程/ 负责/ 一个/ 检测/ 窗口/ ,/ 多个/ 检测/ 窗口/ 可/ 进行/ 并行/ 检测/ ;/ (/ 3/ )/ 使用/ LDS/ 完成/ 数据/ 本地化/ ,/ 实现/ work/ -/ group/ 内线/ 程/ 的/ 数据共享/ ,/ 减少/ 对/ 访存/ 带宽/ 的/ 依赖/ ;/ (/ 4/ )/ 在线/ 程/ 组织/ 上/ ,/ 采取/ 有/ 多少/ 检测/ 窗口/ ,/ 就/ 开启/ 多少/ 线程/ 的/ 策略/ ,/ 每个/ work/ -/ group/ 大小/ 为/ 256/ ,/ 并/ 采取/ 二维/ 组织/ 形式/ :/ 16/ ×/ 16/ ./ 然而/ ,/ 与/ CPU/ 版本/ 的/ 性能/ 相比/ ,/ nave/ 版本/ 的/ 性能/ 并/ 没有/ 提升/ ,/ 反而/ 有所/ 下降/ ./ 这/ 主要/ 有/ 两/ 方面/ 的/ 原因/ :/ 一是/ 没有/ 充分/ 发掘/ 并行性/ ,/ nave/ 版本/ 仅仅/ 开发/ 了/ 三级/ 并行性/ 中/ 的/ 一级/ ,/ 即/ 检测/ 窗口/ 并行/ ;/ 二是/ 在/ nave/ 实现/ 版本/ 中/ ,/ 线程/ 间/ 存在/ 严重/ 的/ 负载/ 不/ 均衡/ 现象/ ,/ 这是/ GPU/ 这种/ 大规模/ 细粒度/ 并行/ 处理器/ 的/ 梦魇/ ./ 这/ 使得/ GPU/ 计算资源/ 远/ 未/ 得到/ 充分利用/ ,/ 从而/ 导致/ 性能/ 的/ 严重/ 降低/ ./ 其中/ 第/ 2/ 个/ 原因/ 是/ 最/ 主要/ 、/ 最/ 关键/ 的/ 因素/ ./ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ 串行/ 实现/ 中/ ,/ 级联/ 分类器/ 之所以/ 能够/ 提高/ 检测/ 速度/ ,/ 是因为/ 在/ 一般/ 的/ 输入/ 图像/ 中/ ,/ 大部分/ 区域/ 都/ 不/ 包含/ 人脸/ ./ 通过/ 前面/ 的/ 几级/ 简单/ 分类器/ 就/ 可以/ 直接/ 滤去/ 这些/ 区域/ ,/ 只/ 对/ 少/ Page6/ 量/ 的/ 极/ 可能/ 包含/ 人脸/ 的/ 区域/ 使用/ 更为/ 复杂/ 的/ 分类器/ 进行/ 检测/ ./ 在/ 这个/ 检测/ 过程/ 中/ ,/ 随着/ 弱/ 分类器/ 数量/ 的/ 增加/ ,/ 通过/ Adaboost/ 构建/ 的/ 强/ 分类器/ 的/ 检测/ 表现/ 也/ 会/ 不断/ 提高/ ./ 但/ 这种/ 方法/ 也/ 导致/ 了/ 该/ 算法/ 在/ GPU/ 的/ 实现/ 和/ 优化/ 中/ ,/ 会/ 导致/ 严重/ 的/ 负载/ 不/ 均衡/ 现象/ ,/ 大大/ 限制/ 了/ 其/ 在/ GPU/ 上/ 的/ 性能/ ./ 图/ 4/ 说明/ 了/ 这种/ 负载/ 不/ 均衡/ 现象/ 的/ 产生/ 过程/ ./ 如图/ 4/ 所示/ ,/ 假设/ 有/ 9/ 个/ 检测/ 窗口/ ,/ 共/ 开启/ 9/ 个/ 线程/ ,/ 每个/ 线程/ 负责/ 一个/ 窗口/ 的/ 检测/ ./ 当/ 使用/ 级联/ 分类器/ 进行/ 检测/ 时/ :/ 窗口/ (/ 0/ ,/ 0/ )/ 首先/ 被/ Stage0/ 分类器/ 检测/ 为/ 肯定/ 不是/ 人脸/ 而/ 被/ 丢弃/ ,/ 在/ 此后/ 的/ 检测/ 过程/ 图/ 4/ 线程/ 间/ 负载/ 不/ 均衡/ 现象/ 由此可见/ ,/ 级联/ 分类器/ 方法/ 虽然/ 在/ 串行/ 算法/ 中/ 可/ 大大减少/ 工作量/ ,/ 提高/ 检测/ 速度/ ,/ 但/ 在/ GPU/ 实现/ 中/ 却/ 会/ 导致/ 严重/ 的/ 线程/ 间/ 负载/ 不/ 均衡/ 现象/ ,/ 成为/ 性能/ 瓶颈/ ,/ 严重/ 制约/ 算法/ 性能/ ./ 特别/ 是/ 在/ 大多数/ 图像/ 中/ ,/ 人脸/ 区域/ 可能/ 只/ 占/ 很少/ 一部分/ ./ 如果/ 对/ 该/ 算法/ 的/ GPU/ 实现/ 不/ 进行/ 改进/ ,/ 也/ 就/ 意味着/ 在/ 实际/ GPU/ 程序/ 中/ ,/ 只有/ 一小部分/ 线程/ 会/ 一直/ 处于/ 工作/ 状态/ ,/ 直到/ 检测/ 结束/ ./ 而/ 绝大部分/ 线程/ 可能/ 很快/ 就/ 退出/ 并/ 在/ CPU/ 端/ 等待/ 全局/ 同步/ 了/ ./ 这/ 显然/ 是/ 我们/ 不/ 愿意/ 看到/ 的/ 结果/ ./ 此外/ ,/ 为了/ 检测/ 图像/ 中/ 大小/ 不同/ 的/ 人脸/ ,/ 需要/ 将/ 中/ ,/ 线程/ (/ 0/ ,/ 0/ )/ 将/ 一直/ 处于/ 空闲/ 状态/ ,/ 其他/ 线程/ 继续/ 工作/ ;/ 接着/ 在/ 下/ 一级/ 检测/ 中/ ,/ 窗口/ (/ 1/ ,/ 1/ )/ 被/ Stage1/ 分类器/ 也/ 检测/ 为/ 不是/ 人脸/ ,/ 因此/ 线程/ (/ 1/ ,/ 1/ )/ 在/ 随后/ 的/ 检测/ 中/ ,/ 也/ 将/ 处于/ 空闲/ 状态/ ;/ 更为/ 不幸/ 的/ 是/ ,/ 随着/ 检测/ 的/ 进行/ ,/ 越来越/ 多/ 的/ 窗口/ 被/ 检测/ 为/ 不是/ 人脸/ 而/ 被/ 丢弃/ ,/ 也就是说/ 越来越/ 多/ 的/ 线程/ 处于/ 空闲/ 状态/ ;/ 直到/ 最后/ 一个/ 阶段/ ,/ 只有/ 线程/ (/ 1/ ,/ 2/ )/ 处于/ 忙碌/ 状态/ ,/ 而/ 其他/ 线程/ 都/ 处于/ 空闲/ 状态/ ./ 更为严重/ 的/ 是/ ,/ 根据/ 级联/ 分类器/ 的/ 定义/ ,/ 检测/ 越靠/ 后/ ,/ 分类器/ 级数/ 越高/ ,/ 相对/ 应/ 的/ 计算/ 量/ 就/ 越/ 大/ ./ 因此/ ,/ 实际/ 的/ 负载/ 不/ 均衡/ 现象/ 远比图/ 4/ 描述/ 的/ 严重/ 得/ 多/ ./ 图像/ 按照/ 一定/ 的/ 缩放/ 因子/ 进行/ 放缩/ ./ nave/ 实现/ 在/ CPU/ 端/ 循环/ 处理/ 这些/ 缩放/ 图像/ ./ 这样/ 处理/ 不仅/ 增加/ 了/ GPUkernel/ 的/ 启动/ 和/ 同步/ 开销/ ,/ 而且/ 当/ 缩放/ 图像/ 过/ 小/ (/ 如/ 只有/ 几个/ 甚至/ 一个/ 检测/ 窗口/ 时/ )/ 而/ 不能/ 充分利用/ GPU/ 的/ 计算资源/ 时/ ,/ 就/ 不能/ 充分利用/ GPU/ 强大/ 的/ 计算能力/ ,/ 从而/ 造成/ 资源/ 浪费/ ./ 因此/ ,/ 在/ 实际/ 图片/ 的/ 人脸/ 检测/ 中/ ,/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 存在/ 三级/ 负载/ 不/ 均衡/ :/ (/ 1/ )/ Thread/ 级/ ./ 线程/ 负责/ 的/ 检测/ 窗口/ 中/ 的/ 图像/ 越/ 接近/ 于/ 人脸/ ,/ 该/ 线程/ 的/ 工作量/ 越大/ ;/ 否则/ ,/ 工作量/ 越小/ ./ Page7/ (/ 2/ )/ Work/ -/ group/ 级/ ./ 当/ 一个/ work/ -/ group/ 处理/ 的/ 图像/ 区域/ 包含/ 人脸/ 时/ ,/ 工作量/ 巨大/ ;/ 否则/ ,/ 工作量/ 可能/ 会/ 很小/ ./ (/ 3/ )/ 图像/ 级/ ./ 当/ 图像/ 不断/ 放缩/ 而/ 不能/ 充分利用/ GPU/ 计算资源/ 时/ ,/ 就/ 会/ 导致/ 图像/ 级/ 的/ 负载/ 不/ 均衡/ ./ 本文/ 下面/ 的/ 内容/ 将/ 着重/ 讨论/ 如何/ 解决/ 这些/ 负载/ 不/ 均衡/ 的/ 问题/ ./ 幸运/ 的/ 是/ 在/ 解决/ 负载/ 不/ 均衡/ 问题/ 的/ 同时/ ,/ 并行性/ 没有/ 充分/ 发掘/ 的/ 问题/ 也/ 一并/ 得到/ 了/ 解决/ ./ 4.3/ GPU/ 优化/ 如上节/ 分析/ ,/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 虽然/ 具有/ 很/ 好/ 的/ 并行性/ ,/ 但/ 在/ GPU/ 移植/ 中/ 存在/ 负载/ 不/ 均衡/ 的/ 非/ 规则/ 特性/ ./ 这种/ 非/ 规则/ 特性/ 是/ GPU/ 计算/ 平台/ 的/ 梦魇/ :/ 一方面/ ,/ GPU/ 具有/ 大规模/ 细粒度/ 并行/ 的/ 架构/ 特点/ ,/ 负载/ 不/ 均衡/ 会/ 导致/ GPU/ 计算资源/ 利用率/ 的/ 降低/ ;/ 另一方面/ ,/ 现代/ GPU/ 的/ 线程/ 调度/ 采用/ 静态/ 调度/ 策略/ ,/ 如/ 不/ 进行/ 针对性/ 优化/ ,/ 无法/ 自动/ 处理/ 负载/ 不/ 均衡/ 问题/ ./ 更为严重/ 的/ 是/ ,/ 传统/ 的/ GPU/ 编程/ 和/ 优化/ 方法/ 并/ 没有/ 涉及/ 对/ 负载/ 不/ 均衡/ 现象/ 的/ 处理/ 和/ 优化/ ./ 因此/ ,/ 负载/ 不/ 均衡/ 现象/ 将会/ 成为/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ 瓶颈/ ,/ 仅仅/ 使用/ 传统/ GPU/ 编程/ 和/ 优化/ 方法/ (/ 即/ 计算/ 、/ 访存/ 和/ 数据/ 本地化/ 优化/ )/ 无法/ 克服/ 该/ 瓶颈/ ,/ 将/ 严重/ 制约/ 算法/ 的/ 性能/ ./ 对此/ ,/ 本文/ 针对/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ 特性/ ,/ 结合/ GPU/ 的/ 架构/ 特征/ ,/ 提出/ 了/ 一种/ 并行/ 优化/ 框架/ ,/ 以/ 突破/ 由于/ 负载/ 不/ 均衡/ 导致/ 的/ 性能/ 瓶颈/ ./ 图/ 5/ 显示/ 了/ 该/ 优化/ 框架/ 的/ 整体/ 架构/ ./ 并行/ 优化/ 框架/ 主要/ 由/ 6/ 个/ 部分/ 组成/ :/ 粗粒度/ 并行/ 、/ PersistentThread/ 、/ Uberkernel/ 、/ 线程/ 与/ 数据/ 的/ 动态/ 映射/ 、/ 全局/ 及/ 本地/ 队列/ ./ 这/ 6/ 个/ 组成部分/ 相互/ 协同/ ,/ 共同/ 解决/ 由于/ 负载/ 不/ 均衡/ 导致/ 的/ 性能/ 瓶颈/ 问题/ :/ (/ 1/ )/ Uberkernel/ ./ 将/ 执行/ 人脸/ 检测/ 算法/ 主要/ 计算/ 部分/ 的/ 多个/ kernel/ 合并/ 为/ 一个/ Uberkernel/ ,/ 统一/ 负责人/ 脸/ 检测/ ./ 这样/ 一方面/ 可以/ 减少/ kernel/ 的/ 启动/ 和/ 全局/ 同步/ 开销/ ,/ 另一方面/ 也/ 可/ 解决/ 图像/ 级/ 负载/ 不/ 均衡/ 问题/ ./ (/ 2/ )/ PersistentThread/ 与/ 粗粒度/ 并行/ ./ PersistentThread/ 和/ 粗粒度/ 并行/ 共同/ 定义/ 了/ Uberkernel/ 的/ 线程/ 组织/ 和/ 运行/ 方式/ ,/ 作为/ 解决/ 线程/ 间/ 负载/ 不/ 均衡/ 问题/ 的/ 基础/ ./ 粗粒度/ 并行/ 通过/ 重新/ 定义/ 线程/ 组织/ 方式/ ,/ 提升/ GPU/ 并行/ 粒度/ :/ 由/ thread/ 变为/ warp/ (/ wavefront/ ,/ AMDGPU/ )/ ,/ 在/ 一定/ 程度/ 上/ 缓和/ 了/ 负载/ 不/ 均衡/ 对/ 性能/ 的/ 影响/ ./ PersistentThread/ 重新/ 定义/ 了/ GPUthread/ 的/ 运行/ 方式/ ,/ 使/ thread/ 的/ 生命周期/ 和/ OpenCLkernel/ 的/ 生命周期/ 相同/ ,/ 可/ 循环/ 处理/ 多个/ 任务/ ./ (/ 3/ )/ 动态/ 映射/ 与/ 全局/ 队列/ ./ 在线/ 程和/ 任务/ 的/ 映射/ 上/ ,/ 本文/ 不/ 采用/ 传统/ GPU/ 编程/ 中/ 的/ 静态/ 映射/ 方式/ ,/ 而是/ 构建/ 线程/ 与/ 任务/ 的/ 动态/ 映射/ 机制/ ,/ 根据/ 线程/ 的/ 任务/ 负载/ 情况/ ,/ 实现/ 线程/ 和/ 任务/ 的/ 动态/ 映射/ ./ 同时/ 构建/ 以此/ 为/ 任务调度/ 策略/ 的/ 全局/ 队列/ ,/ 解决/ work/ -/ group/ 间/ 负载/ 不/ 均衡/ 的/ 问题/ ./ (/ 4/ )/ 本地/ 队列/ ./ 构建/ 位于/ 共享内存/ (/ LDS/ ,/ AMDGPU/ )/ 的/ 本地/ 队列/ ,/ work/ -/ group/ 内/ 的/ 所有/ 线程/ 协同工作/ ,/ 解决/ work/ -/ group/ 内/ 的/ 负载/ 不/ 均衡/ 问题/ ./ 本节/ 将/ 对/ 以上/ 关键/ 优化/ 方法/ 和/ 技术/ 进行/ 详细/ 讨论/ 和/ 介绍/ ./ 4.3/ ./ 1Uberkernel/ 如/ 3.2/ 节/ 所述/ ,/ 为了/ 检测/ 图像/ 中/ 不同/ 大小/ 的/ 人脸/ ,/ 我们/ 需要/ 按照/ 一定/ 的/ 缩放/ 因子/ 对/ 图像/ 进行/ 缩放/ ,/ 直到/ 缩放/ 图像/ 和/ 检测/ 窗口/ 为/ 同等/ 大小/ 为止/ ,/ 这样/ 就/ 形成/ 了/ 一个/ 缩放/ 图像/ 集/ ./ 如果/ 一次/ 只/ 处理/ 一幅/ 图像/ ,/ 并/ 通过/ 在/ CPU/ 端/ 通过/ 多次/ 启动/ GPUkernel/ 循环/ 处理/ 这些/ 缩放/ 图像/ ,/ 不仅/ 会/ 增加/ GPUkernel/ 的/ 启动/ 和/ 全局/ 同步/ 开销/ ,/ 而且/ 当/ 缩放/ 图像/ 过小而/ 不能/ 充分利用/ GPU/ 的/ 计算资源/ 时/ ,/ 会/ 导致/ GPU/ 计算资源/ 的/ 极大/ 浪费/ ,/ 由此/ 会/ 产生/ 图像/ 级/ 负载/ 不/ 均衡/ ./ 为此/ ,/ 我们/ 引入/ 了/ Uberkernel/ 机制/ ,/ 其/ 核心/ 是/ 通过/ kernel/ 合并/ ,/ 一次/ 处理/ 多幅/ 甚至/ 所有/ 图像/ ./ 这样/ 仅/ 通过/ 一次/ 或/ 几次/ OpenCLkernel/ 的/ 启动/ 就/ 全部/ 处理/ 完/ 所有/ 的/ 缩放/ 图像/ ./ Uberkernel/ 的/ 具体/ 流程/ 如图/ 6/ 所示/ ./ 在/ GPU/ 的/ GlobalMemory/ 中/ 设立/ 一个/ 统一/ 的/ 地址/ 空间/ ,/ 将/ 所有/ 图片/ 按照/ 缩放/ 比例/ ,/ 顺序/ 放入/ 统一/ 的/ 地址/ 空间/ 中/ ./ 同时/ ,/ OpenCLkernel/ 将/ 对/ 这些/ 缩放/ 图片/ 按照/ 统一/ 的/ 方式/ 进行/ 处理/ ./ 当/ 图片/ 太/ 大/ ,/ 统一/ 的/ Page8/ 地址/ 空间/ 不能/ 全部/ 容纳/ 所有/ 缩放/ 图片/ 时/ ,/ 则/ 按照/ 统一/ 地址/ 空间/ 最大化/ 利用/ 的/ 原则/ (/ 尽可能/ 填满/ 统一/ 地址/ 空间/ )/ 对/ 缩放/ 图片/ 进行/ 分组/ ,/ 然后/ 循环/ 处理/ 每组/ 图片/ ./ 该/ 机制/ 尽可能/ 的/ 保证/ 每个/ OpenCLkernel/ 的/ 工作量/ 足以/ 充分利用/ GPU/ 所有/ 的/ 计算资源/ ,/ 很/ 好地解决/ 了/ 图像/ 级/ 负载/ 不/ 均衡/ 问题/ ./ 4.3/ ./ 2/ 粗粒度/ 并行/ 与/ PersistentThread/ 在/ Uberkernel/ 的/ 线程/ 组织/ 及/ 运行/ 方式/ 上/ ,/ 本文/ 引入/ 组/ 粒度/ 并行/ 与/ PersistentThread/ ./ 传统/ GPU/ 编程/ 是/ 大规模/ 细粒度/ 并行/ ,/ 即/ 一次/ 开启/ 大量/ 线程/ ,/ 并/ 以/ 单个/ 软件/ 线程/ (/ thread/ )/ 作为/ 并行/ 粒度/ ./ 这种/ 编程/ 方式/ 无疑/ 是/ 线程/ 间/ 存在/ 负载/ 不/ 均衡/ 特性/ 算法/ 的/ 噩梦/ ./ 为此/ ,/ 本文/ 在/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ GPU/ 实现/ 中/ ,/ 采用/ 硬件/ 线程/ (/ NVIDIAGPU/ 为/ warp/ ,/ 含/ 32/ 个/ thread/ ,/ AMDGPU/ 为/ wave/ -/ front/ ,/ 含/ 64/ 个/ thread/ )/ 作为/ 并行/ 粒度/ ./ 同时/ ,/ 硬件/ 线程/ 内/ 多个/ thread/ 协同工作/ ,/ 共同/ 处理/ 分配/ 的/ 检测/ 窗口/ ,/ 其/ 协同工作/ 方式/ 在/ 4.3/ ./ 5/ 节/ 本地/ 队列/ 中/ 会/ 详细/ 讨论/ ./ 粗粒度/ 并行/ 的/ 实现/ 方式/ 较为简单/ :/ 一个/ work/ -/ group/ 只/ 包含/ 一个/ warp/ 或者/ wavefront/ ,/ work/ -/ group/ 将/ 作为/ 全局/ 队列/ 任务分配/ 的/ 单位/ ./ 采用/ 粗粒度/ 并行/ 编程/ 方式/ 的/ 优势/ 主要/ 有/ 3/ 个/ :/ (/ 1/ )/ 移除/ 本地/ 同步操作/ ./ wavefront/ // warp/ 是/ GPU/ 最/ 基本/ 的/ 执行/ 和/ 调度/ 单元/ ./ 当/ 一个/ work/ -/ group/ 内/ 只/ 包含/ 一个/ wavefront/ // warp/ 时/ ,/ 可/ 移除/ 本地/ 同步操作/ ,/ 减少/ 本地/ 同步/ 开销/ ,/ 在/ 一定/ 程度/ 上/ 提高/ 程序/ 性能/ ./ (/ 2/ )/ 一个/ work/ -/ group/ 只/ 包含/ 一个/ wavefront/ // warp/ ,/ 我们/ 可以/ 将/ work/ -/ group/ 看成/ 是/ 一个/ 与/ 其他/ work/ -/ group/ 执行/ 相互/ 独立/ 的/ 多指令/ 多/ 数据/ (/ MutipleInstructionMultipleData/ ,/ MIMD/ )/ 线程/ ./ 即/ 保证/ 了/ SIMD/ 执行/ 方式/ 的/ 有效性/ ,/ 又/ 提供/ 了/ MIMD/ 式/ 的/ 工作/ 粒度/ ./ (/ 3/ )/ 减轻/ work/ -/ group/ 内线/ 程间/ 的/ 负载/ 不/ 均衡/ ./ 在/ 粗粒度/ 并行/ 模式/ 下/ ,/ 任务/ 的/ 分配/ 以/ work/ -/ group/ 为/ 单位/ ,/ work/ -/ group/ 内/ 的/ 所有/ 线程/ 协同/ 处理/ 所/ 分配/ 的/ 计算/ 任务/ ./ 这种/ 工作/ 模式/ 结合/ 我们/ 下面/ 即将/ 讨论/ 的/ 本地/ 队列/ ,/ 可/ 大大/ 减小/ work/ -/ group/ 内线/ 程/ 的/ 负载/ 不/ 均衡/ 现象/ ./ 当然/ ,/ 粗粒度/ 编程/ 方式/ 也/ 存在/ 一个/ 劣势/ :/ 由于/ GPU/ 硬件资源/ 的/ 限制/ ,/ 每个/ CU/ 上/ 同时/ 运行/ 的/ work/ -/ group/ 数目/ 是/ 有/ 限制/ 的/ ./ 因此/ ,/ 当/ work/ -/ group/ 包含/ 的/ 线程/ 数目/ 较/ 少时/ ,/ 可能/ 会/ 导致/ CU/ 上/ 同时/ 运行/ 的/ 线程/ 不足/ ,/ 从而/ 不能/ 有效/ 地/ 隐藏/ 访存/ 延迟/ ./ 幸运/ 的/ 是/ ,/ 由于/ 人脸/ 检测/ 算法/ 有/ 较大/ 的/ 计算/ 密度/ ,/ 这个/ 劣势/ 可以/ 消除/ ./ 在/ 实际/ 实现/ 中/ ,/ 结合/ 数据/ 本地化/ ,/ 为/ 每个/ CU/ 部署/ 8/ ~/ 12/ 个/ work/ -/ group/ 即可/ 有效/ 地/ 隐藏/ 访存/ 延迟/ ./ 在/ 运行/ 方式/ 上/ ,/ 传统/ GPU/ 线程/ 的/ 生命周期/ 一般/ 为/ 五个/ 过程/ :/ 启动/ 、/ 获取/ 操作/ 数据/ 、/ 处理/ 数据/ 、/ 写回/ 处理结果/ 、/ 退出/ ,/ 其/ 运行/ 及/ 调度/ 方式/ 都/ 是/ 静态/ 的/ 且/ 由/ GPU/ 硬件/ 控制/ ./ 这种/ 运行/ 方式/ 显然/ 对于/ 解决/ 负载/ 不/ 均衡/ 的/ 问题/ 是/ 非常/ 不利/ 的/ ./ 因此/ ,/ 本文/ 引入/ 了/ PersistentThread/ ,/ 其/ 生命周期/ 和/ OpenCLkernel/ 的/ 生命周期/ 相同/ ,/ 并/ 可/ 循环/ 处理/ 多个/ 任务/ :/ 线程/ 在/ 将/ 一次/ 数据处理/ 的/ 结果/ 写/ 回后/ ,/ 不是/ 立即/ 退出/ ,/ 而是/ 判断/ 是否/ 还有/ 别的/ 任务/ 需要/ 处理/ ,/ 如果/ 有/ ,/ 线程/ 将/ 继续/ 获取/ 任务/ 进行/ 处理/ ,/ 如/ 没有/ 才/ 退出/ ./ 这样/ 在/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 中/ ,/ 可/ 为/ 每个/ 线程/ 分配/ 多个/ 检测/ 窗口/ ,/ 线程/ 将/ 循环/ 处理/ 这些/ 检测/ 窗口/ ,/ 直到/ 将/ 分配/ 给/ 它/ 的/ 窗口/ 全部/ 处理完毕/ ./ 同时/ ,/ 线程/ 与/ 检测/ 窗口/ 的/ 映射/ 将/ 根据/ 线程/ 的/ 任务/ 负载/ 情况/ 采用/ 动态/ 映射/ 方式/ ,/ 从而/ 最大/ 限度/ 的/ 保证/ 了/ 线程/ 间/ 的/ 负载/ 均衡/ ./ 这/ 将/ 在/ 4.3/ ./ 3/ 节/ 线程/ 与/ 任务/ 的/ 动态/ 映射/ 中/ 进行/ 详细/ 讨论/ ./ 4.3/ ./ 3/ 线程/ 与/ 任务/ 的/ 动态/ 映射/ 在线/ 程与/ 任务/ 的/ 映射/ 方面/ ,/ 传统/ GPU/ 编程/ 采用/ 静态/ 编程/ 模式/ ,/ 即/ 在/ GPUkernel/ 启动/ 之前/ ,/ 线程/ 和/ 任务/ 的/ 映射/ 就/ 已经/ 确定/ ,/ 线程/ 由/ GPU/ 硬件/ 顺序/ 调度/ 执行/ ,/ 每个/ 线程/ 处理/ 的/ 任务/ 和/ 任务/ 数都/ 是/ 固定/ 的/ ./ 这种/ 编程/ 模式/ 虽然/ 很/ 好/ 的/ 满足/ 了/ 规则/ 的/ 数据/ 并行/ 应用/ ,/ 但/ 对于/ 具有/ 线程/ 间/ 负载/ 不/ 均衡/ 特征/ 的/ 人脸/ 检测/ 算法/ ,/ 无法/ 解决/ 其/ 存在/ 的/ 负载/ 不/ 均衡/ 问题/ ./ 本文/ Page9/ 在/ PersistentThread/ 的/ 基础/ 上/ ,/ 引入/ GPU/ 动态/ 编程/ 模式/ ,/ 该/ 模式/ 具有/ 以下/ 3/ 个/ 特征/ :/ (/ 1/ )/ 固定/ 开启/ 线程/ 数目/ ./ 根据/ 目标/ GPU/ 计算/ 平台/ 的/ CU/ 数量/ ,/ 确定/ 开启/ 的/ 线程/ 数目/ ./ 在/ 人脸/ 检测/ 算法/ 中/ ,/ 共/ 开启/ 8/ ×/ N/ (/ AMDGPU/ )/ 或者/ 12/ ×/ N/ (/ NVIDIAGPU/ )/ 个/ work/ -/ group/ ,/ 其中/ N/ 为/ CU/ 数目/ ./ 每个/ work/ -/ group/ 包含/ 64/ (/ AMDGPU/ )/ 或/ 32/ (/ NVIDIAGPU/ )/ 个/ 线程/ ./ (/ 2/ )/ 每个/ 线程/ 分配/ 多个/ 计算/ 任务/ ./ 结合/ PersistentThread/ 编程/ 方式/ ,/ 每个/ 线程/ 循环/ 处理/ 多个/ 任务/ ./ (/ 3/ )/ 在线/ 程/ 的/ 任务分配/ 方面/ ,/ 在/ GPUkernel/ 启动/ 之后/ ,/ 根据/ 线程/ 的/ 实际/ 任务/ 负载/ 情况/ 确定/ 线程/ 与/ 任务/ 的/ 映射/ 关系/ ./ (/ 4/ )/ 该/ 策略/ 将/ 作为/ 全局/ 队列/ (/ 4.3/ ./ 4/ 节/ )/ 的/ 任务调度/ 机制/ ,/ 根据/ 粗粒度/ 并行/ 的/ 定义/ ,/ 以/ work/ -/ group/ 为/ 单位/ 进行/ 任务分配/ ./ 图/ 7/ 显示/ 了/ 线程/ 与/ 任务/ 动态/ 映射/ 的/ 过程/ :/ 首先/ 每个/ work/ -/ group/ 的/ 第/ 0/ 号/ 线程/ 作为/ 标记/ 线程/ ,/ 访问/ 位于/ 全局/ 内存/ 上/ 的/ 原子/ 变量/ G/ ,/ 在/ 获得/ 原子/ 变量/ 访问/ 权后/ ,/ 对/ 原子/ 变量/ 加/ N/ (/ N/ 为/ work/ -/ group/ 每次/ 处理/ 的/ 窗口/ 数目/ ,/ 在/ AMDGPU/ 上/ N/ 为/ 64/ ,/ 在/ NVIDIAGPU/ 上/ N/ 为/ 32/ )/ ;/ 然后/ 判断/ G/ 是否/ 小于/ 检测/ 窗口/ 总数/ Total/ +/ N/ ,/ 如果/ 小于/ ,/ 则/ 获取/ 该/ work/ -/ group/ 要/ 处理/ 的/ 检测/ 窗口/ ,/ 否则/ 对应/ work/ -/ group/ 退出/ ;/ 最后/ 将/ 待处理/ 的/ N/ 个/ 检测/ 窗口/ 返回/ 给/ 对应/ 的/ work/ -/ group/ ./ work/ -/ group/ 以/ 4.3/ ./ 5/ 节/ 介绍/ 的/ 本地/ 队列/ 机制/ 处理/ 完/ 这些/ 检测/ 窗口/ 后/ ,/ 再/ 重复/ 以上/ 操作/ ,/ 直到/ 所有/ 检测/ 窗口/ 都/ 处理完毕/ 为止/ ./ 注意/ ,/ 所有/ 检测/ 窗口/ 以/ 队列/ 形式/ 存储/ 在/ 全局/ 内存/ 上/ ,/ 全局/ 内存/ 的/ 构建/ 组织/ 方式/ 将/ 在/ 4.3/ ./ 4/ 节/ 详细/ 讨论/ ./ 图/ 8/ 为/ 线程/ 与/ 任务/ 动态/ 映射/ 的/ 伪/ 代码/ ./ G/ :/ 位于/ 全局/ 内存/ 的/ 原子/ 变量/ ,/ 记录/ 被/ 处理/ 的/ 窗口/ 数/ N/ :/ 每个/ work/ -/ group/ 一次/ 处理/ 的/ 窗口/ 数/ 1.2/ ./ 3.4/ ./ 5.6/ ./ 7.8/ ./ 9.10/ ./ 11.12/ ./ 动态/ 编程/ 模式/ 根据/ 线程/ 的/ 实际/ 任务/ 负载/ 情况/ 进行/ 任务分配/ ,/ 即当/ work/ -/ group/ 处理/ 的/ 窗口/ 包含/ 人脸/ 而/ 导致/ 计算/ 量过大/ 时/ ,/ 该/ work/ -/ group/ 处理/ 的/ 窗口/ 数目/ 就会/ 变少/ ;/ 反之/ ,/ 当/ work/ -/ group/ 处理/ 的/ 窗口/ 计算/ 量/ 小时/ ,/ 该/ work/ -/ group/ 就/ 会/ 处理/ 更/ 多/ 的/ 窗口/ ./ 因此/ ,/ 动态/ 编程/ 模式/ 在/ 一定/ 程度/ 上/ 解决/ 了/ work/ -/ group/ 间/ 负载/ 不/ 均衡/ 的/ 问题/ ./ 当然/ ,/ 动态/ 编程/ 模式/ 会因/ 原子/ 变量/ 访问/ 导致/ 额外/ 的/ 开销/ ./ 但/ 一方面/ ,/ 由于/ work/ -/ group/ 的/ 调度/ 执行/ 存在/ 一定/ 的/ 时间/ 间隔/ ,/ 所以/ 这个/ 开销/ 会/ 非常/ 小/ ;/ 另一方面/ 相对/ 于/ 负载/ 不/ 均衡/ 导致/ 的/ 性能/ 瓶颈/ ,/ 这个/ 开销/ 几乎/ 可以/ 忽略不计/ ./ 因此/ ,/ 动态/ 编程/ 方式/ 会/ 大幅提高/ 人脸/ 检测/ 算法/ 在/ GPU/ 上/ 的/ 性能/ ./ 4.3/ ./ 4/ 全局/ 队列/ 线程/ 与/ 任务/ 的/ 动态/ 映射/ 机制/ 能够/ 很/ 好/ 的/ 解决/ work/ -/ group/ 间/ 负载/ 不/ 均衡/ 问题/ 的/ 前提/ 是/ :/ 位于/ 全局/ 内存/ 上/ 的/ 待/ 检测/ 窗口/ 必须/ 被/ 很/ 好/ 的/ 组织/ ,/ 能够/ 及时/ 响应/ 访存/ 请求/ ./ 因此/ ,/ 本文/ 引入/ 了/ 全局/ 队列/ ./ 全局/ 队列/ 的/ 作用/ 是/ 以/ 队列/ 的/ 形式/ 组织/ 好待/ 检测/ 窗口/ ,/ 在线/ 程与/ 负载/ 动态/ 映射/ 机制/ 下/ ,/ 能/ 方便/ 的/ 建立/ 起/ 线程/ 与/ 数据/ 的/ 动态/ 映射/ 关系/ ./ 结合/ 前面/ 讨论/ 的/ Uberkernel/ 和/ PersistentThread/ ,/ 全局/ 任务/ 队列/ 的/ 工作/ 流程/ 如下/ :/ 首先/ 将/ Uberkernel/ 中/ 所有/ 的/ 探测/ 窗口/ 都/ 加入/ 到/ 该/ 队列/ 中/ ;/ 其次/ 以/ 32/ (/ NVIDAGPU/ )/ 或者/ 64/ (/ AMDGPU/ )/ 为/ 单位/ 将/ 探测/ 窗口/ 分成/ 若干/ 任务/ 组/ ,/ 并/ 将/ 其/ 作为/ 任务调度/ 单位/ ;/ 最后/ ,/ 根据/ 线程/ 与/ 任务/ 动态/ 映射/ 机制/ ,/ 以/ work/ -/ group/ 为/ 分配/ 单元/ ,/ Page10/ 根据/ 线程/ 的/ 实际/ 任务/ 负载/ 情况/ ,/ 完成/ 任务/ 的/ 动态分配/ ./ 全局/ 队列/ 除了/ 任务/ 与/ 负载/ 动态/ 映射/ 机制/ 外/ ,/ 没有/ 使用/ 更加/ 复杂/ 的/ 任务调度/ 方式/ ./ 这里/ 有/ 两/ 方面/ 的/ 原因/ :/ 一方面/ ,/ 全局/ 队列/ 位于/ 全局/ 内存/ 上/ ,/ 其访存/ 和/ 原子/ 操作/ 的/ 开销/ 都/ 非常/ 昂贵/ ./ 复杂/ 的/ 任务调度/ 方式/ 不仅/ 难以实现/ ,/ 而且/ 可能/ 会/ 产生/ 昂贵/ 的/ 调度/ 开销/ ,/ 在/ 性能/ 的/ 提升/ 上/ 得不偿失/ ./ 另一方面/ ,/ 线程/ 与/ 数据/ 动态/ 映射/ 机制/ 已经/ 决定/ 了/ 全局/ 任务/ 队列/ 的/ 任务调度/ 方式/ ,/ 且/ 这种/ 任务调度/ 方式/ 足够/ 解决/ work/ -/ group/ 间/ 的/ 负载/ 不/ 均衡/ 现象/ ./ 4.3/ ./ 5/ 本地/ 队列/ 线程/ 与/ 任务/ 的/ 动态/ 映射/ 及/ 全局/ 队列/ 机制/ 的/ 引入/ ,/ 较/ 好地解决/ 了/ work/ -/ group/ 间/ 负载/ 不/ 均衡/ 的/ 问题/ ,/ 而/ work/ -/ group/ 内线/ 程间/ 负载/ 不/ 均衡/ 的/ 问题/ 由/ 位于/ 片上/ 本地/ 内存/ (/ 共享内存/ ,/ NVIDIAGPU/ )/ 的/ 本地/ 队列/ 解决/ ./ 图/ 9/ 详细/ 地/ 显示/ 了/ 本地/ 队列/ 及其/ 任务/ 处理过程/ ./ work/ -/ group/ 将/ 其/ 负责/ 处理/ 的/ 待/ 检测/ 窗口/ 组织/ 为/ 位于/ 片上/ 本地/ 内存/ 的/ 队列/ ,/ 然后/ 使用/ 级联/ 分类器/ 进图/ 9/ 本地/ 队列/ 由此可见/ ,/ 本地/ 队列/ 基本上/ 解决/ 了/ work/ -/ group/ 内部/ 线程/ 间/ 负载/ 不/ 均衡/ 的/ 问题/ ./ 4.3/ ./ 6/ 其他/ 优化/ 方法/ 除/ 以上/ 优化/ 方法/ 外/ ,/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 还/ 使用/ 了/ GPU/ 传统/ 优化/ 方法/ :/ (/ 1/ )/ 开发/ ILP/ ./ 开发/ ILP/ 主要/ 有/ 两种/ 方式/ :/ 一是/ 循环展开/ ;/ 二是/ 调整/ 代码/ 顺序/ ,/ 使/ 相同/ 指令/ 类型/ (/ GPU/ 的/ 指令/ 类型/ 可/ 分为/ 3/ 种/ :/ 读/ 内存/ 指令/ 、/ 计算/ 指行/ 检测/ ./ 每级/ 分类器/ 将会/ 检测/ 队列/ 中/ 的/ 所有/ 窗口/ ,/ 通过/ 本级/ 检测/ 的/ 窗口/ 将会/ 重新/ 进入/ 队列/ ,/ 等待/ 下/ 一级/ 分类器/ 的/ 进一步/ 检测/ ;/ 否则/ ,/ 该/ 窗口/ 将会/ 被/ 丢弃/ ./ 其/ 检测/ 过程/ 分为/ 两个/ 阶段/ :/ (/ 1/ )/ 单独/ 处理/ 阶段/ ./ 因为/ 0/ ~/ 2/ 级/ 分类器/ 特征/ 数目/ 较/ 少/ ,/ 可以/ 很快/ 完成/ 计算/ ,/ 故令/ 每个/ 线程/ 单独/ 负责/ 处理/ 一个/ 窗口/ ./ 在/ 这个/ 过程/ 中/ ,/ 当/ 使用/ 1/ ~/ 2/ 级/ 分类器/ 进行/ 检测/ 时/ ,/ 会/ 有/ 线程/ 处于/ 空闲/ 状态/ ,/ 但/ 这个/ 时间/ 太短/ ,/ 不足以/ 引起/ 性能/ 瓶颈/ ,/ 反而/ 能/ 减少/ 协同/ 处理/ 开销/ ./ (/ 2/ )/ 协同/ 处理/ 阶段/ ./ 随着/ 分类器/ 级数/ 的/ 增大/ ,/ 特征/ 数目/ 和/ 计算/ 量会/ 急剧/ 增长/ ./ 同时/ ,/ 经过/ 0/ ~/ 2/ 级/ 分类器/ 的/ 检测/ ,/ 队列/ 中/ 的/ 待/ 检测/ 窗口/ 数目/ 也/ 会/ 减少/ ./ 此时/ 进入/ 协同/ 处理/ 阶段/ ,/ 即/ 一次/ 从/ 队列/ 中/ 取出/ M/ (/ 在/ AMDGPU/ 上/ M/ 为/ 4/ ,/ NvidiaGPU/ 上/ M/ 为/ 2/ )/ 个/ 检测/ 窗口/ ,/ 由/ work/ -/ group/ 内/ 所有/ 线程/ 协同/ 处理/ (/ 通过/ 检测/ 的/ 窗口/ 返回/ 队列/ )/ ,/ 直到/ 队列/ 中/ 的/ 所有/ 窗口/ 都/ 通过/ 本级/ 分类器/ 检测/ 为止/ ;/ 然后/ ,/ 进入/ 下/ 一级/ 分类器/ 继续/ 检测/ ;/ 最后/ ,/ 只有/ 经过/ 最后/ 一级/ 分类器/ 检测/ 的/ 检测/ 窗口/ 中才/ 包含/ 人脸/ ./ 令/ 以及/ 写/ 内存/ 指令/ ./ 在/ 执行/ 过程/ 中/ ,/ GPU/ 会/ 将/ 相互/ 独立/ 、/ 相同/ 类型/ 且/ 相邻/ 的/ 指令/ 打包/ 在/ 一起/ 并行执行/ )/ 的/ 代码/ 打包/ 在/ 一起/ ,/ 编写/ 对/ 编译器/ 友好/ 的/ 代码/ ./ (/ 2/ )/ 指令/ 选择/ 优化/ ./ 因为/ 人脸/ 检测/ 函数/ 较/ 高/ 的/ 计算/ 密度/ ,/ 选择/ 高/ 吞吐量/ 的/ 指令/ 对/ 性能/ 的/ 提升/ 就/ 变得/ 尤为重要/ ./ 在/ 该/ 算法/ 的/ 实现/ 中/ ,/ 共/ 采取/ 了/ 两种/ 指令/ 优化/ :/ 一是/ 使用/ 位/ 运算/ 指令/ 代替/ 乘法/ 和/ 除法/ 指令/ ;/ 二是/ 用/ mad24/ 、/ MUl24/ 指令/ 代替/ 乘加/ 指令/ ./ Page11/ (/ 3/ )/ 减少/ 动态/ 指令/ ./ 主要/ 方法/ 是/ 减少/ 条件/ 分支/ ./ 因为/ 人脸/ 检测/ 算法/ 中/ 存在/ 着/ 大量/ 的/ 条件/ 判断/ 语句/ ,/ 因此/ 使用/ ?/ :/ 语句/ 代替/ if/ …/ else/ …/ 语句/ 是/ 减少/ 动态/ 指令/ 的/ 主要/ 方式/ ./ 4.3/ ./ 7/ 性能/ 移植/ 优化/ 如前/ 文所/ 所述/ ,/ 虽然/ GPU/ 架构/ 日益/ 多样化/ ,/ 但是/ 统一/ 的/ 层次/ 式/ 架构/ 模式/ 为/ 性能/ 移植/ 提供/ 了/ 可能/ ./ 只要/ 完成/ 了/ 关键/ 性能参数/ 的/ 抽取/ ,/ 并/ 建立/ 完善/ 的/ 性能/ 参数传递/ 机制/ ,/ 就/ 可/ 实现/ 不同/ GPU/ 硬件平台/ 间/ 的/ 性能/ 移植/ ./ 两个/ GPU/ 计算/ 平台/ 的/ 关键/ 性能参数/ 抽取/ 如表/ 1/ 所示/ ./ 在/ 性能/ 参数传递/ 机制/ 构建/ 方面/ ,/ 利用/ OpenCL/ 程序运行/ 时/ 编译/ 的/ 特点/ 是/ 通过/ 宏/ 定义/ 将/ 性能参数/ 在/ 编译/ 时/ 传入/ OpenCLkernel/ ,/ 根据/ 目标/ 平台/ ,/ 传入/ 相应/ 的/ 性能参数/ ./ 根据/ 以上/ 方法/ ,/ 本文/ 在/ 不/ 修改/ 代码/ 的/ 前提/ 下/ ,/ 最终/ 实现/ 了/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ AMDRadeonHD7970/ 和/ NVIDIAGTX680/ 两个/ 不同/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ 移植/ ./ 表/ 2GPU/ 计算/ 平台/ 性能参数/ AMDRadeonHD7970NVIDIAGTX680Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ CPU/ 版本/ 来自/ OpenCV2/ ./ 4/ ,/ 该/ 版本/ 已/ 深度/ 优化/ ,/ 在/ CPU/ 平台/ 上/ 具有/ 较/ 高/ 的/ 性能/ ./ 因此/ ,/ 选择/ 该/ 版本/ ,/ 可/ 提高/ 性能/ 对比/ 的/ 可信性/ ./ 值得注意/ 的/ 是/ CPU/ 版本/ 在/ 编译/ 时/ ,/ 添加/ “/ -/ o3/ ”/ 选项/ ,/ 以/ 充分利用/ CPU/ 的/ 计算资源/ ,/ 提高/ CPU/ 串行/ 版本/ 的/ 性能/ ./ 检测/ 图片/ 来源于/ CMU/ 人脸/ 检测/ 项目/ 所用/ 的/ 数据库/ [/ 21/ ]/ ,/ 该/ 数据库/ 是/ CMU/ 人脸/ 检测/ 项目/ 的/ 专用/ 数据库/ ,/ 提供/ 了/ 用于/ 大量/ 评估/ 算法/ 准确性/ 的/ 人脸/ 正面/ 图片/ ,/ 非常/ 具有/ 代表性/ ./ 在/ 实际/ 测试/ 中/ ,/ 我们/ 选择/ 了/ 50/ 张/ 图像/ 共/ 包含/ 427/ 个人/ 脸来/ 评估/ 我们/ 实现/ 的/ 人脸/ 检测/ 算法/ GPU/ 版本/ 的/ 正确性/ 和/ 性能/ ./ 图/ 10/ 列举/ 了/ 其中/ 3/ 幅/ 不同/ 大小/ 、/ 不同/ 背景/ 、/ 不同/ 人脸/ 数目/ 的/ 图片/ ./ 其中/ 图片/ 1/ 的/ 大小/ 为/ 256/ ×/ 337/ ,/ 包含/ 人脸/ 数目/ 为/ 1/ ;/ 图片/ 2/ 大小/ 为/ 696/ ×/ 510/ ,/ 包含/ 人脸/ 数目/ 为/ 12/ ;/ 图片/ 3/ 大小/ 为/ 1280/ ×/ 1024/ ,/ 包含/ 人脸/ 数目/ 为/ 56.5/ ./ 2/ 正确性/ 验证/ 本文/ 选取/ OpenCV2/ ./ 4/ 库中/ 实现/ 的/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 作为/ 进行/ GPU/ 移植/ 和/ 优化/ 的/ 基准/ CPU/ 程序/ ,/ OpenCL/ 程序/ 的/ 各/ 方面/ 参数/ 与/ 该/ 基准/ 程序/ 保持一致/ ./ 同时/ ,/ 检测/ 模型/ 也/ 直接/ 使用/ OpenCV2/ ./ 4work/ -/ group/ 大小/ work/ -/ group/ 数目/ 全局/ 队列/ 任务/ 发送/ 单元/ 本地/ 队列/ 协同/ 处理单元/ 处理/ 每个/ 检测/ 窗口/ 的/ 线程/ 数目/ 循环展开/ 次数/ 5/ 性能/ 评估/ 5.1/ 测试/ 平台/ 搭建/ 本文/ 选取/ AMDHD7970/ 和/ NVIDIAGTX680/ 两个/ 不同/ 架构/ 的/ GPU/ 作为/ 性能/ 测试/ 平台/ ,/ 选取/ Intel/ (/ R/ )/ Xeon/ (/ R/ )/ X5550QuadCoreCPU/ (/ 2.66/ GHz8MBL3Cache/ )/ 作为/ CPU/ 计算/ 平台/ ./ 选取/ 两个/ 不同/ 计算/ 平台/ 的/ 目的/ 是/ 验证/ 性能/ 可移植性/ ./ 两个/ GPU/ 计算/ 平台/ 的/ 主要/ 性能参数/ 如表/ 2/ 所示/ ./ 3.06/ ./ 0/ 自带/ 的/ 检测/ 模型/ ./ 因此/ ,/ 本文/ 的/ 正确性/ 验证/ 只/ 和/ 该/ CPU/ 串行/ 代码/ 的/ 运行/ 结果/ 进行/ 比较/ ./ 值得注意/ 的/ 是/ ,/ 通过/ 改进/ 算法/ 及/ 检测/ 模型/ 来/ 提高/ 检测/ 的/ 准确率/ 并/ 不是/ 本文/ 关注/ 的/ 内容/ ,/ 本文/ 主要/ 关注/ 的/ 是/ 相同/ 算法/ 实现/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ 提升/ ./ Page12/ 图/ 10/ 显示/ 了/ 本文/ 实现/ 的/ OpenCL/ 版本/ 对/ 3/ 幅/ 不同/ 图像/ 的/ 检测/ 结果/ ./ 从中/ 我们/ 可以/ 看出/ :/ 并/ 不是/ 所有/ 的/ 人脸/ 都/ 被/ 检测/ 出来/ ./ 这/ 主要/ 是因为/ 这些/ 未/ 检测/ 出/ 的/ 人脸/ 并/ 不是/ 标准/ 正面/ 像/ ./ 同时/ 也/ 可以/ 发现/ 许多/ 没有/ 人脸/ 的/ 区域/ 也/ 被/ 检测/ 为/ 人脸/ ,/ 如/ 图像/ 3/ ./ 这/ 是因为/ 这些/ 区域/ 在/ 一定/ 程度/ 上/ 与/ 人脸/ 相似/ ./ 从/ 以上/ 分析/ 可以/ 看出/ :/ OpenCL/ 版本/ 并/ 没有/ 达到/ 100/ %/ 的/ 人脸/ 检测/ 精确度/ ./ 但/ 通过/ 和/ OpenCV/ 库中/ 的/ CPU/ 串行/ 版本/ 的/ 运行/ 结果/ 相/ 比较/ ,/ 我们/ 发现/ 人脸/ 检测/ 精度/ 没有/ 实现/ 100/ %/ 与/ 串行/ 算法/ 实现/ 及/ 检测/ 模型/ 有关/ ,/ 而/ 与/ OpenCL/ 实现/ 无关/ ./ 表/ 3CPU/ 版本/ 与/ OpenCL/ 版本/ 人脸/ 检测/ 数目/ (/ 单位/ :/ 个/ )/ 图片/ 编号/ 123/ 表/ 3/ 显示/ 了/ CPU/ 串行/ 版本/ 和/ 本文/ 实现/ 的/ OpenCL/ 版本/ 针对/ 不同/ 图片/ 的/ 人脸/ 检测/ 数目/ ./ 从中/ 可以/ 看出/ ,/ 本文/ 实现/ 的/ OpenCL/ 版本/ 在/ 人脸/ 检测/ 数目/ 上/ 与/ CPU/ 串行/ 版本/ 完全一致/ ,/ 这/ 就/ 证明/ 了/ 人脸/ 检测/ 算法/ OpenCL/ 版本/ 实现/ 的/ 正确性/ ./ 而/ 人脸/ 检测/ 的/ 准确率/ 可/ 通过/ 改进/ 算法/ 实现/ 或者/ 使用/ 更/ 精确/ 的/ 检测/ 模型/ 来/ 提高/ ,/ 但/ 这/ 并/ 不是/ 本文/ 关注/ 的/ 内容/ ./ 5.3/ 性能/ 分析/ 5.3/ ./ 1/ 整体/ 性能/ 分析/ 图/ 11/ 和/ 图/ 12/ 分别/ 显示/ 了/ 优化/ 后/ 的/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ AMDHD7970/ 和/ NVIDIAGTX680/ 两个/ 不同/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ 及/ 相对/ 于/ CPU/ 版本/ 的/ 性能/ 提升/ ./ 值得注意/ 的/ 是/ ,/ OpenCL/ 版本/ 的/ 性能/ 测定/ 包含/ 了/ OpenCL/ 程序运行/ 的/ 所有/ 时间/ ,/ 包括/ OpenCL/ 初始化/ 时间/ 、/ CPU/ 和/ GPU/ 间/ 的/ 数据传输/ 时间/ 以及/ kernel/ 的/ 运行/ 时间/ ./ 从中/ 我们/ 可以/ 看出/ ,/ 与/ 人脸/ 检测/ 的/ CPU/ 版本/ 的/ 性能/ 相比/ ,/ 本文/ 实现/ 的/ OpenCL/ 版本/ 在/ 两个/ GPU/ 计算/ 平台/ 上/ 处理/ 不同/ 的/ 图片/ 都/ 达到/ 了/ 可观/ 的/ 加速/ 比/ :/ 在/ AMDHD7970GPU/ 计算/ 平台/ 上/ ,/ 实现/ 了/ 11.24/ ~/ 20.27/ 的/ 性能/ 加速/ ;/ 在/ NVIDIAGTX680/ 计算/ 平台/ 上/ ,/ 实现/ 了/ 9.24/ ~/ 17.62/ 的/ 性能/ 加速/ ./ 由此/ 可以/ 看到/ ,/ NVIDIAGTX680GPU/ 与/ AMDHD7970GPU/ 相比/ ,/ 在/ 性能/ 提升/ 方面/ 略有/ 差距/ ./ 这/ 主要/ 是因为/ 前者/ 在/ 峰值/ 计算/ 性能/ 和/ 峰值/ 访存/ 带宽/ 这/ 两个/ 主要/ 的/ 性能参数/ 方面/ 要弱/ 于/ 后者/ ./ 图/ 11/ 和/ 图/ 12/ 不仅/ 说明/ 了/ 我们/ 优化/ 框架/ 的/ 有效性/ ,/ 有效/ 地/ 解决/ 了/ 算法/ 负载/ 不/ 均衡/ 的/ 问题/ ;/ 而且/ 说明/ 了/ 虽然/ 两个/ GPU/ 计算/ 平台/ 的/ 架构/ 不同/ ,/ 计算/ 单元/ 的/ 组织/ 也/ 不/ 相同/ ,/ 但是/ 二者/ 都/ 采用/ 了/ 层次/ 式/ 架构/ ,/ 优化/ 技术/ 和/ 方法/ 也/ 大致相同/ ,/ 只要/ 对/ 性能参数/ 进行/ 精心/ 抽取/ 和/ 定义/ (/ 如/ 4.3/ ./ 7/ 节中/ 的/ 每个/ work/ -/ group/ 一次/ 处理/ 的/ 窗口/ 数/ N/ 以及/ work/ -/ group/ 内线/ 程/ 处理/ 一次/ 协同/ 处理/ 的/ 窗口/ 数/ M/ 等/ )/ ,/ 是/ 完全/ 可以/ 实现/ 不同/ GPU/ 计算/ 平台/ 间/ 性能/ 移植/ 的/ ./ 同时/ ,/ 我们/ 可以/ 看到/ ,/ 对于/ 不同/ 图像/ ,/ GPU/ 的/ 加速/ 效果/ 也/ 是/ 不同/ 的/ ./ 主要/ 有/ 两/ 方面/ 的/ 原因/ :/ 第一/ ,/ GPU/ 是/ 大规模/ 并行/ 处理器/ ,/ 理论/ 上/ ,/ 图片/ 规模/ 越大/ ,/ 计算/ 量/ 越/ 大/ ,/ 越能/ 充分利用/ GPU/ 计算/ 平台/ 强大/ 的/ 计算能力/ ,/ 加速/ 效果/ 也/ 就/ 越/ 好/ ./ 第二/ ,/ 图像/ 的/ 背景/ 和/ 人脸/ 数目/ 不同/ ,/ 算法/ 的/ 总体/ 计算/ 量/ 也/ 不同/ ./ 同时/ ,/ 算法/ 在/ 处理/ 不同/ 图片/ 时/ 的/ 负载/ 不/ 均衡/ 的/ 程度/ 也/ 不尽相同/ ,/ 从而/ 进一步/ 影响/ 了/ GPU/ 计算/ 平台/ 对/ 性能/ 的/ 提升/ 效果/ ./ 5.3/ ./ 2/ 不同/ 优化/ 方法/ 对/ 性能/ 的/ 影响/ 图/ 13/ 显示/ 了/ 以/ Nave/ 版本/ 为/ 基准/ ,/ 采用/ 不同/ 优化/ 方法/ 后/ ,/ 在/ 两个/ GPU/ 计算/ 平台/ 上/ 所/ 带来/ 的/ 性能/ 提升/ ./ 从图/ 13/ 中/ ,/ 我们/ 可以/ 看出/ 如下/ 6/ 点/ :/ (/ 1/ )/ 在/ 两个/ GPU/ 计算/ 平台/ 上/ ,/ 不同/ 优化/ 方法/ 带/ Page13/ 来/ 的/ 性能/ 提升/ 虽/ 有/ 差异/ ,/ 但/ 趋势/ 大致相同/ ./ 这/ 不仅/ 说明/ 了/ 两个/ GPU/ 计算/ 平台/ 在/ 整体/ 架构设计/ 上/ 的/ 统一性/ ,/ 而且/ 说明/ 了/ 在/ 两个/ GPU/ 计算/ 平台/ 上/ ,/ 线程/ 间/ 负载/ 不/ 均衡/ 都/ 是/ 最/ 严重/ 的/ 性能/ 瓶颈/ ,/ 这些/ 都/ 是/ 导致/ 性能/ 降低/ 的/ 主要/ 因素/ ./ 图/ 13/ 不同/ 优化/ 方法/ 在/ 两个/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ 提升/ (/ 2/ )/ 线程/ 与/ 任务/ 的/ 动态/ 映射/ 带来/ 的/ 性能/ 提升/ 最大/ ,/ 注意/ 这里/ 的/ 线程/ 与/ 任务/ 动态/ 映射/ 实际/ 指/ 的/ 是/ 动态/ 映射/ +/ 全局/ 队列/ ,/ 因为/ 两者/ 是/ 一个/ 统一/ 整体/ ,/ 没有/ 必要/ 分开/ 说明/ ./ 从/ 性能/ 图中/ 可以/ 看出/ ,/ 采用/ 传统/ GPU/ 静态/ 编程/ 模式/ ,/ work/ -/ group/ 间/ 的/ 负载/ 不/ 均衡/ 会/ 导致/ 性能/ 的/ 极大/ 降低/ ,/ 这/ 是因为/ 图片/ 中/ 绝大部分/ 区域/ 没有/ 人脸/ ,/ 大量/ 的/ 线程/ 可能/ 运行/ 很/ 短/ 的/ 时间/ 就/ 会/ 退出/ 等待/ ,/ 只有/ 少量/ 线程/ 仍/ 在/ 运行/ ./ 而/ 线程/ 和/ 任务/ 的/ 动态/ 映射/ 很/ 好地解决/ 了/ 这个/ 问题/ ,/ 因为/ 线程/ 和/ 任务/ 动态/ 映射/ 的/ 核心/ 是/ 根据/ 线程/ 的/ 实际/ 任务/ 负载/ 情况/ ,/ 动态/ 进行/ 任务/ 的/ 分配/ ./ 这样/ 就/ 可以/ 让/ 执行/ 大/ 任务/ 的/ 线程/ ,/ 执行/ 的/ 任务/ 数量/ 少/ 一些/ ;/ 执行/ 小/ 任务量/ 的/ 线程/ ,/ 执行/ 的/ 任务/ 数量/ 多一些/ ./ 这/ 就/ 从根本上/ 解决/ 了/ work/ -/ group/ 间/ 负载/ 不/ 均衡/ 的/ 问题/ ./ (/ 3/ )/ 本地/ 队列/ 也/ 有效/ 地/ 提升/ 了/ 算法/ 性能/ ./ 这/ 说明/ 了/ 3/ 点/ :/ 第一/ ,/ work/ -/ group/ 内/ 同样/ 存在/ 着/ 线程/ 间/ 负载/ 不/ 均衡/ 问题/ ,/ 同样/ 会/ 影响/ 程序/ 性能/ ;/ 第二/ ,/ work/ -/ group/ 内线/ 程间/ 负载/ 不/ 均衡/ 对/ 性能/ 的/ 影响/ 没有/ work/ -/ group/ 间/ 的/ 负载/ 不/ 均衡/ 对/ 性能/ 的/ 影响/ 大/ ,/ 这/ 是因为/ 一个/ work/ -/ group/ 处理/ 的/ 图像/ 区域/ 毕竟/ 有限/ ,/ 线程/ 间/ 的/ 计算/ 量/ 差距/ 并/ 不会/ 太/ 大/ ;/ 第三/ ,/ 本地/ 队列/ 很/ 好地解决/ 了/ work/ -/ group/ 内线/ 程间/ 的/ 负载/ 不/ 均衡/ 问题/ ./ (/ 4/ )/ 传统/ 优化/ 方法/ 带来/ 的/ 性能/ 提升/ 并/ 不/ 明显/ ./ 这/ 就/ 说明/ 了/ 负载/ 不/ 均衡/ 是/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ 瓶颈/ ,/ 传统意义/ 上/ 引起/ 性能/ 下降/ 的/ 因素/ 在/ 该/ 算法/ 上/ 体现/ 得/ 并/ 不/ 明显/ ./ 但/ 同时/ 也/ 说明/ 了/ ,/ 只要/ 解决/ 负载/ 不/ 均衡/ 问题/ ,/ 传统/ 优化/ 方法/ 依然/ 后/ 改善/ GPU/ 计算资源/ 的/ 利用率/ ,/ 同样/ 可以/ 带来/ 性能/ 提升/ ./ (/ 5/ )/ 虽然/ PersistentThread/ 和/ kernel/ 合并/ 对/ 性能/ 的/ 提升/ 有限/ ,/ 但是/ 两者/ 是/ 整个/ 优化/ 框架/ 的/ 基础/ ./ 对/ 性能/ 影响/ 最大/ 的/ 线程/ 与/ 任务/ 的/ 动态/ 映射/ 机制/ 构建/ 的/ 基础/ 就是/ PersistentThread/ 和/ kernel/ 合并/ ./ 粗粒度/ 并行/ 虽然/ 无法/ 测试/ 对/ 性能/ 的/ 具体/ 影响/ ,/ 但/ 同样/ 作为/ 优化/ 框架/ 的/ 基础/ ,/ 同/ 本地/ 队列/ 一起/ ,/ 克服/ work/ -/ group/ 内线/ 程间/ 的/ 负载/ 不/ 均衡/ 问题/ ,/ 从而/ 在/ 一定/ 程度/ 上/ 提升/ 了/ 算法/ 性能/ ./ (/ 6/ )/ 通过/ 该/ 算法/ 的/ 优化/ ,/ 说明/ 了/ 只要/ 经过/ 精心/ 优化/ ,/ 具有/ 负载/ 不/ 均衡/ 特征/ 的/ 非/ 规则/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 也/ 能够/ 取得/ 非常/ 好/ 的/ 加速/ 比/ ./ 因此/ ,/ GPU/ 不仅/ 对/ 规则/ 的/ 数据/ 级/ 并行/ 能够/ 取得/ 很/ 好/ 的/ 加速/ 效果/ ,/ 对于/ 不规则/ 的/ 任务/ 级/ 并行/ ,/ 只要/ 优化/ 方法/ 得当/ ,/ 也/ 会/ 取得/ 相当可观/ 的/ 性能/ 加速/ 效果/ ./ 这/ 无疑/ 会/ 大大/ 扩展/ GPU/ 计算/ 平台/ 的/ 应用/ 场景/ ./ 5.3/ ./ 3/ 与/ 以往/ 工作/ 的/ 比较/ 虽然/ 有/ 很多/ 关于/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 的/ GPU/ 移植/ 工作/ ,/ 但/ 很少/ 有/ 发布/ 出来/ 的/ 代码/ 或者/ 库/ ./ 而/ 针对/ 不同/ 图片/ ,/ 人脸/ 检测/ 算法/ 的/ 性能/ 又/ 具有/ 很大/ 的/ 差异性/ ./ 因此/ ,/ 在/ 与/ 以往/ 工作/ 的/ 对比/ 上/ ,/ 本文/ 只/ 选取/ 了/ OpenCV2/ ./ 4/ 库中/ 该/ 算法/ 的/ OpenCL/ 实现/ 版本/ ./ 但/ 考虑/ 到/ OpenCV/ 在/ 计算机/ 视觉/ 领域/ 应用/ 的/ 广泛性/ ,/ 这个/ 对比/ 也/ 在/ 一定/ 程度/ 上/ 体现/ 了/ 我们/ 工作/ 的/ 有效性/ ./ 图/ 14/ 显示/ 了/ 本文/ 实现/ 与/ OpenCV2/ ./ 4/ 中/ 人脸/ 检测/ 算法/ 的/ OpenCL/ 版本/ 的/ 性能/ 对比/ ./ 从图/ 中/ 可以/ 看出/ ,/ 相对/ 于/ OpenCV/ 库/ 的/ 实现/ ,/ 本文/ 实现/ 在/ 两个/ GPU/ 计算/ 平台/ 上/ ,/ 针对/ 不同/ 图片/ 都/ 取得/ 了/ 较大/ 的/ 性能/ 提升/ ./ 具体/ 为/ :/ 在/ AMDHD7970/ 计算/ 平台/ 上/ ,/ 取得/ 了/ 27.1/ %/ ~/ 37.9/ %/ 的/ 性能/ 提升/ ;/ 在/ NVIDIAGTX680/ 计算/ 平台/ 上/ 取得/ 了/ 20.6/ %/ ~/ 31.7/ %/ 的/ 性能/ 提升/ ./ 本文/ 实现/ 性能/ 提升/ 的/ 主要/ 原因/ 是/ work/ -/ group/ 间/ 负载/ 不/ 均衡/ 问题/ 的/ 解决/ :/ OpenCV/ 库/ 的/ OpenCLPage14/ 实现/ 版本/ 中/ ,/ 全局/ 队列/ 依旧/ 采用/ 静态/ 调度/ 的/ 方式/ ,/ 没有/ 很/ 好地解决/ 全局/ 队列/ 的/ 任务调度/ 问题/ ,/ work/ -/ group/ 间/ 的/ 负载/ 不/ 均衡/ 问题/ 依然/ 没有/ 得到/ 改善/ ./ 而/ 本文/ 实现/ 了/ 线程/ 与/ 任务/ 的/ 动态/ 映射/ 机制/ ,/ 全局/ 队列/ 可以/ 根据/ 线程/ 的/ 实际/ 任务/ 负载/ 情况/ 进行/ 任务分配/ ,/ 很/ 好地解决/ 了/ work/ -/ group/ 间/ 的/ 负载/ 不/ 均衡/ 问题/ ./ 总之/ ,/ 本文/ 提出/ 的/ 优化/ 框架/ 很/ 好/ 的/ 解决/ 了/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ GPU/ 的/ 实现/ 和/ 优化/ 中/ ,/ 由于/ 负载/ 不/ 均衡/ 导致/ 的/ 性能/ 瓶颈/ ,/ 取得/ 了/ 可观/ 的/ 性能/ 加速/ 比/ ./ 该/ 框架/ 的/ 6/ 个/ 组成部分/ ,/ 既/ 各司其职/ ,/ 又/ 相互协作/ ,/ 共同/ 提升/ 了/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 性能/ ./ 同时/ ,/ 该/ 框架/ 不仅/ 适用/ 于/ 人脸/ 检测/ 算法/ ,/ 而且/ 对于/ 其他/ 具有/ 类似/ 特征/ 的/ 算法/ ,/ 也/ 具有/ 很/ 好/ 的/ 指导意义/ 和/ 参考价值/ ./ 6/ 结束语/ 本文/ 详细/ 地/ 讨论/ 了/ Viola/ -/ Jones/ 人脸/ 检测/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 实现/ 和/ 优化/ 的/ 关键/ 方法/ 和/ 技术/ ./ 由于/ 人脸/ 检测/ 算法/ 的/ GPU/ 实现/ 存在/ 线程/ 间/ 负载/ 不/ 均衡/ 的/ 非/ 规则/ 特性/ ,/ 导致/ 仅/ 使用/ 传统/ 优化/ 方法/ 无法/ 有效/ 地/ 提升/ 性能/ ./ 本文/ 构建/ 了/ 一个/ 针对/ 此类/ 算法/ 的/ 并行/ 优化/ 框架/ 通过/ Uberkernel/ 、/ 粗粒度/ 并行/ 、/ PersistentThread/ 、/ 线程/ 与/ 任务/ 动态/ 映射/ 、/ 本地/ // 全局/ 队列/ 等/ 优化/ 方法/ 的/ 使用/ 突破/ 了/ 由于/ 线程/ 间/ 负载/ 不/ 均衡/ 导致/ 的/ 性能/ 瓶颈/ ./ 实验/ 结果表明/ ,/ 与/ OpenCV2/ ./ 4/ 中/ 经过/ 高度/ 优化/ 的/ CPU/ 版本/ 在/ IntelXeonX5550CPU/ 上/ 的/ 性能/ 相比/ ,/ 优化/ 后/ 的/ 算法/ 在/ AMDHD7970/ 和/ NVIDIAGTX680/ 两个/ 不同/ GPU/ 计算/ 平台/ 上/ 分别/ 达到/ 了/ 11.24/ ~/ 20.27/ 和/ 9.24/ ~/ 17.62/ 倍/ 的/ 加速/ 比/ ,/ 不仅/ 实现/ 了/ 高性能/ ,/ 而且/ 实现/ 了/ 在/ 不同/ GPU/ 计算/ 平台/ 间/ 的/ 性能/ 移植/ ./ 本文/ 采用/ 的/ 优化/ 方法/ ,/ 对/ 其他/ 具有/ 线程/ 间/ 负载/ 不/ 均衡/ 特性/ 的/ 算法/ 在/ GPU/ 计算/ 平台/ 上/ 的/ 实现/ 和/ 优化/ 也/ 具有/ 很/ 好/ 的/ 指导意义/ 和/ 参考价值/ ./ 致谢/ 感谢/ 王伟/ 俨/ 对/ 本文/ 前期工作/ 的/ 支持/ ;/ 感谢/ AMD/ 公司/ 对/ 本文/ 工作/ 的/ 支持/ ;/ 感谢/ 课题组/ 内/ 其他/ 成员/ 的/ 帮助/ 和/ 支持/ !/ 

