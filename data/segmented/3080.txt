Page1DNA/ 序列/ 中/ 基于/ 适应性/ 后缀/ 树/ 的/ 重复/ 体/ 识别/ 算法/ 霍红卫/ 王小武/ (/ 西安电子科技大学/ 计算机/ 学院/ 西安/ 710071/ )/ 摘要/ 现有/ 的/ 在/ DNA/ 序列/ 中/ 识别/ 重复/ 体/ 的/ 算法/ 多数/ 是/ 基于/ 比/ 对/ 的/ ,/ 对/ 识别/ 速度/ 和/ 吞吐量/ 有/ 很大/ 的/ 限制/ ./ 针对/ 这个/ 问题/ 文中/ 根据/ 一个/ 平衡/ 重复/ 体/ 的/ 长度/ 和/ 频率/ 的/ 定义/ ,/ 提出/ 了/ 一种/ 基于/ Ukkonen/ 后缀/ 树/ 的/ 快速/ 识别/ 重复/ 体/ 的/ RepSeeker/ 算法/ ./ 算法/ 采用/ 最低/ 限制/ 频率/ ,/ 最大/ 程度/ 地/ 扩展/ 了/ 重复/ 体/ 的/ 长度/ ,/ 同时/ 为了/ 进一步/ 地/ 提高/ RepSeeker/ 算法/ 的/ 效率/ ,/ 对/ Ukkonen/ 的/ 后缀/ 树/ 构造/ 算法/ 进行/ 了/ 适应性/ 改进/ ,/ 在/ 构造/ 时/ 加入/ RepSeeker/ 算法/ 所/ 需/ 的/ 结点/ 信息/ 并/ 将/ 叶子/ 结点/ 和/ 分支/ 结点/ 加以/ 区分/ ,/ 从而/ 使得/ RepSeeker/ 算法/ 能/ 通过/ 直接/ 读取/ 结点/ 信息/ 来/ 求得/ 子串/ 频率/ 和/ 子串/ 位置/ ./ 这种/ 改进/ 较大/ 地/ 提高/ 了/ RepSeeker/ 算法/ 的/ 性能/ ,/ 而且/ 空间/ 开销/ 不大/ ./ 实验/ 中/ 使用/ 了/ NCBI/ 中/ 的/ 9/ 条/ 典型/ DNA/ 序列/ 作为/ 测试数据/ ,/ 并/ 对/ 后缀/ 树/ 改进/ 前后/ 的/ 重复/ 体/ 识别/ 算法/ 做/ 了/ 比较/ 分析/ ./ 结果表明/ ,/ RepSeeker/ 在/ 没有/ 损失/ 精度/ 的/ 情况/ 下/ 缩短/ 了/ 算法/ 的/ 运行/ 时间/ ./ 实验/ 结果/ 与/ 理论/ 上/ 的/ 分析/ 一致/ ./ 关键词/ 重复/ 体/ 识别/ ;/ 适应性/ 后缀/ 树/ ;/ Ukkonen/ 算法/ ;/ RepSeeker/ 算法/ 1/ 引言/ 基因组/ 中/ 含有/ 许多/ 重复/ 元素/ ./ 例如/ ,/ 在/ 人类/ 基因组/ 的/ 约/ 3.2/ ×/ 109/ 个/ 碱基对/ 中/ 超过/ 50/ %/ 已/ 被/ 识别/ 为/ 各种/ 重复/ 元素/ [/ 1/ -/ 2/ ]/ ./ 重复/ 体/ 识别/ 对于/ 分析/ 新/ 的/ 基因组/ 非常/ 重要/ [/ 3/ ]/ ,/ 这/ 是因为/ :/ (/ 1/ )/ 重复/ 体以/ 各种/ 方式/ 引导/ 着/ 基因组/ 的/ 进化/ 过程/ ;/ (/ 2/ )/ 在/ 进行/ 同源/ 查找/ 之前/ 需要/ 对/ 重复/ 体/ 进行/ 掩模/ ./ 而/ 在/ 实际/ 中有/ 各种各样/ 的/ 重复/ 体/ ,/ 大多数/ 重复/ 体/ 的/ 功能/ 并未/ 完全/ 被/ 理解/ 和/ 定义/ [/ 4/ ]/ ./ 当前/ 研究/ 表明/ 某些/ 重复/ 体在/ 基因/ 表达/ 和/ 转录/ 调控/ 方面/ 起着/ 重要/ 作用/ [/ 5/ ]/ ./ 与/ 重复/ 体/ 结合/ 的/ 碱基/ 可能/ 导致/ 基因/ 重组/ ,/ 使/ 基因组/ 发生/ 重大/ 变化/ ./ 重复/ 体/ 种类/ 繁多/ ,/ 它们/ 包含/ 着/ 几个/ 到/ 数百/ 的/ 碱基对/ ,/ 有些/ 可/ 达/ 上万/ 碱基对/ ./ 一些/ 人类/ 的/ 遗传疾病/ 诸如/ 脆性/ X/ 染色体/ 综合症/ 、/ 亨延顿/ 氏症/ 以及/ 弗里德/ 共济失调/ 都/ 与/ 重复/ 体/ 长度/ 的/ 不规则/ 性/ 有关/ [/ 6/ ]/ ./ 一个/ 重要/ 的/ 生物/ 信息学/ 问题/ 是/ 如何/ 快速/ 识别/ 并/ 有效/ 地/ 表示/ 基因组/ 中/ 的/ 重复/ 体/ ./ 目前/ ,/ 解决/ 重复/ 体/ 识别/ 的/ 方法/ 大致/ 有/ 两类/ :/ RepeatMasker/ [/ 7/ ]/ 根据/ 一个/ 已经/ 注释/ 的/ 重复/ 体/ 数据库/ 对/ 已知/ 重复/ 体/ 进行/ 查找/ ./ 这个/ 数据库/ 很大/ 程度/ 上/ 依赖于/ 同源/ 序列/ 的/ 相似性/ ./ 这种/ 方法/ 不能/ 用于/ 处理/ 新/ 的/ 基因组/ 序列/ ,/ 是因为/ 它/ 不能/ 为/ 新/ 测序/ 的/ 基因组/ 构建/ 所/ 需/ 的/ 库/ 信息/ ./ 而且/ ,/ 对于/ 新/ 的/ 基因组/ ,/ 它/ 的/ 重复/ 体库/ 需要/ 手工/ 编撰/ ,/ 因为/ 这种/ 方法/ 是/ 面向/ 特定/ 基因组/ 的/ ./ 对/ RepeatMasker/ 数据库/ 的/ 从头/ 识别/ 仍然/ 是/ 生物/ 信息学/ 中/ 的/ 一个/ 挑战/ 问题/ [/ 8/ ]/ ./ REPuter/ [/ 9/ ]/ 是/ 另/ 一种/ 方法/ ,/ 它/ 摘取/ 具有/ 最大/ 长度/ 的/ 所有/ 重复/ 体/ 的/ 相似/ 对/ ,/ 并/ 把/ 重复/ 体/ 定义/ 为/ 一组/ 具有/ 最大/ 长度/ 的/ 相似/ 字符串/ 对/ ./ 这/ 两种/ 方法/ 都/ 没有/ 考虑/ 重复/ 体/ 的/ 出现/ 次数/ ./ 一般而言/ ,/ 在/ 真实/ 生物/ 序列/ 中/ ,/ 重复/ 体会/ 出现/ 多次/ ./ 例如/ ,/ 在/ 人类/ 基因组/ 中/ Alu/ 出现/ 106/ 次/ ./ 在/ 复杂/ 的/ 基因组/ 中/ ,/ 转座子/ 一般/ 出现/ 几十万/ 次/ ./ 因此/ ,/ 在/ 识别方法/ 中/ 结合/ 重复/ 体/ 的/ 频率/ 更/ 合理/ ./ 具有/ 生物/ 意义/ 的/ 重复/ 体/ 的/ 定义/ 必须/ 考虑/ 重复/ 体/ 的/ 长度/ 和/ 频率/ ./ 一些/ 研究/ 表明/ 准确/ 地/ 定义/ 重复/ 体是/ 不/ 容易/ 的/ ./ 一些/ 方法/ 只能/ 找到/ 短/ 的/ 重复/ 序列/ 或/ 串联/ 重复/ 序列/ ./ 它们/ 难以/ 找出/ 长且/ 散布/ 的/ 重复/ 序列/ ./ 最近/ 的/ 一些/ 方法/ 集中/ 在/ 识别/ 重复/ 体/ 的/ 边界/ 上/ ./ Price/ 等/ 人/ 提出/ 了/ RepeatScout/ 算法/ [/ 10/ ]/ ,/ 该/ 方法/ 使用/ 高频/ l/ -/ mer/ 种子/ 来/ 查找/ 重复/ 体/ 的/ 边界/ ,/ 且/ 用/ 贪心/ 法/ 扩展/ 每个/ 种子/ ,/ 使/ 之/ 成为/ 更长/ 的/ 同源/ 序列/ ./ Edgar/ 和/ Myers/ 研制/ 了/ RILER/ 软件包/ [/ 11/ ]/ ,/ 通过/ 刻画/ 重复/ 体/ 特征/ 和/ 局部/ 比/ 对/ 来/ 识别/ 具有/ 可靠/ 边界/ 的/ 重复/ 体/ ./ 意识/ 到/ 重复/ 体/ 出现/ 频率/ 的/ 重要性/ ,/ 已有/ 几种/ 方法/ 把/ 长度/ 和/ 频率/ 结合/ 在/ 重复/ 体/ 的/ 定义/ 中/ ./ Zheng/ 和/ Lonardi/ [/ 12/ ]/ 给出/ 了/ 一种/ 基于/ 后缀/ 树来/ 查找/ DNA/ 序列/ 中/ 重复/ 体/ 的/ 方法/ ,/ 且/ 时间/ 复杂度/ 为/ O/ (/ n2f/ )/ [/ 13/ ]/ ./ Zheng/ 和/ Lonardi/ 算法/ 的/ 效率/ 不高/ ,/ 是因为/ 对于/ 数十万/ 碱基对/ 长度/ 的/ DNA/ 序列/ ,/ 算法/ 仍然/ 难以/ 有效/ 工作/ ./ Σ/ 表示/ 一个/ 有限/ 非空/ 字母表/ ./ 字符串/ 和/ 字母/ 用/ 斜体字/ 体/ ./ |/ S/ |/ 表示/ 字符串/ S/ 的/ 长度/ ./ S/ [/ i/ ]/ 表示/ 字符串/ S/ 中/ 的/ 第/ i/ 个字符/ ,/ 1/ / i/ / |/ S/ |/ ./ S/ [/ i/ ,/ j/ ]/ 表示/ S/ 的/ 子串/ S/ [/ i/ ]/ S/ [/ i/ +/ 1/ ]/ …/ S/ [/ j/ ]/ ,/ 1/ / 尽管/ 在/ 试图/ 定义/ 和/ 识别/ 一个/ 序列/ 中/ 重复/ 体/ 已有/ 大量/ 成果/ ,/ 重复/ 体/ 查找/ 仍然/ 是/ 一个/ 挑战性/ 的/ 问题/ ./ 文献/ [/ 8/ ]/ 使用/ 了/ 局部/ 序列/ 比/ 对/ 策略/ 和/ A/ -/ Bruijn/ 图来解/ 重复/ 体/ 查找/ 问题/ ./ 然而/ ,/ 基于/ A/ -/ Bruijn/ 图/ 的/ 方法/ 的/ 分析/ 非常复杂/ 和/ 困难/ ./ 此外/ ,/ 这种/ 方法/ 需要/ 对/ 输入/ 序列/ 进行/ 双/ 序列/ 局部/ 比/ 对/ ./ 其/ 性能/ 主要/ 依赖于/ 局部/ 比/ 对/ 的/ 结果/ ./ Gu/ 等/ 人/ [/ 14/ ]/ 提出/ 了/ 一种/ 基于/ 精确/ 字/ 统计法/ 来/ 估计/ 大型/ 真核/ 基因组/ 中/ 重复/ 结构/ 出现/ 频率/ 的/ 方法/ ,/ 该/ 方法/ 对比/ 期望/ 出现/ 次数/ 多/ 的/ 寡核苷酸/ 进行/ 分类/ ./ 本文/ 中/ 按照/ 文献/ [/ 12/ ]/ 中/ 对/ 重复/ 体/ 的/ 定义/ ,/ 对/ Ukkonen/ 后缀/ 树/ 构造/ 算法/ 做/ 了/ 适应性/ 的/ 改进/ ,/ 提出/ 一种/ 快速/ 识别/ 重复/ 体/ 的/ 算法/ RepSeeker/ ./ RepSeeker/ 算法/ 使用/ 最低/ 频率/ 限制/ ,/ 并/ 扩展/ 重复/ 体/ 的/ 长度/ 使/ 之/ 达到/ 最大/ ./ 在/ 后缀/ 树/ 的/ 构造/ 过程/ 中/ ,/ 对/ 叶子/ 节点/ 进行/ 编号/ ,/ 并/ 把/ 叶子/ 节点/ 的/ 信息/ 加入/ 到/ 分支/ 节点/ 中/ ,/ 叶子/ 节点/ 和/ 分支/ 节点/ 所/ 包含/ 的/ 信息/ 不同/ ,/ 以使/ RepSeeker/ 算法/ 能够/ 直接/ 从/ 节点/ 中/ 获得/ 子串/ 的/ 频率/ 和/ 位置/ 信息/ ./ 这种/ 改进/ 大大提高/ 了/ RepSeeker/ 算法/ 的/ 性能/ ,/ 而且/ 空间/ 开销/ 不大/ ./ RepSeeker/ 算法/ 使用/ 来自/ NCBI/ 中/ 的/ 9/ 条/ 序列/ 进行/ 了/ 性能/ 测试/ ./ 并/ 对/ 改进/ 前后/ 算法/ 的/ 性能/ 作/ 了/ 比较/ ./ 实验/ 结果表明/ ,/ 对/ 其/ 数据结构/ 所/ 做/ 的/ 改进/ 大大降低/ 了/ RepSeeker/ 算法/ 的/ 运行/ 时间/ ,/ 同时/ 又/ 保证/ 了/ 识别/ 的/ 精度/ ./ 实验/ 结果/ 与/ 理论/ 上/ 的/ 分析/ 一致/ ./ 2RepSeeker/ 算法/ 2.1/ 表示/ 、/ 约定/ 及/ 基本/ 定义/ Page3i/ / j/ / |/ S/ |/ ./ 约定/ S/ [/ i/ ,/ i/ ]/ =/ S/ [/ i/ ]/ ./ L/ -/ 串/ (/ 或/ L/ -/ 子串/ )/ 是/ 一个/ 长为/ L/ 的/ 字符串/ (/ 子串/ )/ ./ Ai/ 表示/ A/ 在/ S/ 中/ 的/ 第/ i/ 个/ 出现/ ./ Ai/ 表示/ A/ 的/ 第/ i/ 个/ 拷贝/ ./ 有时/ 我们/ 会/ 交替/ 使用/ 这些/ 表示/ ,/ 因为/ 根据/ 上下文/ 就/ 可以/ 明确/ 它们/ 是/ 表示/ 子串/ 还是/ 表示/ 子串/ 所在位置/ ./ 如果/ 字符串/ A/ 是/ 字符串/ S/ 的/ 一个/ 子串/ ,/ 且/ 在/ S/ 中/ 出现/ 多次/ ,/ 则/ 称/ A/ 是/ S/ 的/ 一个/ 重复/ 体/ ./ 在/ 分子生物学/ 中/ ,/ 重复/ 体/ 就是/ 一个/ 碱基/ 序列/ 在/ 染色体/ 中/ 多次/ 出现/ 的/ 拷贝/ ./ 阈值/ 是/ 指/ 一个/ 重复/ 体在/ 一个/ 序列/ 中/ 重复/ 出现/ 次数/ 所/ 指定/ 的/ 最小值/ ./ 滑动/ 窗口/ (/ 见图/ 1/ )/ 是/ 某个/ 定长/ 的/ 可视/ 框/ ./ 2.2/ 定义/ 定义/ 1/ ./ 设/ A/ 是/ S/ 的/ 一个/ 重复/ 体/ ,/ (/ A1/ ,/ A2/ ,/ …/ ,/ Am/ )/ 是/ A/ 在/ S/ 中/ 出现/ 的/ 一个/ 有序/ 表/ ,/ Ai/ 是/ A/ 在/ S/ 中/ 的/ 第/ i/ 个/ 出现/ ,/ m/ 是/ A/ 在/ S/ 中/ 的/ 出现/ 次数/ ,/ 且/ m/ / 2/ ./ 设/ B/ 是/ A/ 的/ 一个/ 子串/ ,/ (/ B1/ ,/ B2/ ,/ …/ ,/ Bk/ )/ 是/ B/ 在/ S/ 中/ 出现/ 的/ 一个/ 有序/ 表/ ,/ k/ 是/ B/ 在/ S/ 中/ 的/ 出现/ 次数/ ./ 如果/ B/ 在/ A/ 中/ 从/ 位置/ s/ 开始/ ,/ 那么/ B/ =/ A/ [/ s/ ,/ s/ -/ 1/ +/ |/ B/ |/ ]/ ,/ 0/ / s/ / |/ A/ |/ -/ |/ B/ |/ ./ 如果/ k/ =/ m/ 且/ 每个/ Bi/ 在/ Ai/ 中/ 出现/ 的/ 偏移量/ 相同/ ,/ 则/ 称/ B/ 是/ A/ 的/ 一个/ 子/ 重复/ ,/ i/ =/ 1/ ,/ 2/ ,/ …/ ,/ m/ ./ 定义/ 2/ ./ A/ 是/ S/ 的/ 一个/ 非/ 平凡/ 子串/ ,/ 当且/ 仅/ 当/ A/ 是/ S/ 的/ 一个/ 非空/ 、/ 真/ L/ -/ 子串/ ,/ 0/ </ |/ A/ |/ </ |/ S/ |/ ,/ L/ 是/ 重复/ 体/ 的/ 最小/ 长度/ ./ 定义/ 3/ ./ 如果/ A/ 是/ S/ 的/ 一个/ 具有/ 最大/ 长度/ 的/ 非/ 平凡/ 子串/ ,/ 且/ A/ 在/ S/ 中/ 至少/ 出现/ Fm/ 次/ ,/ A/ 的/ 每个/ 非/ 平凡/ 子串/ 是/ A/ 的/ 一个/ 子/ 重复/ ,/ 其中/ Fm/ 是/ 指定/ 的/ 重复/ 体/ 最小/ 出现/ 频率/ ,/ 则/ 称/ A/ 是/ S/ 的/ 一个/ 基本/ 重复/ 体/ ./ 性质/ 1/ ./ 如果/ A/ 是/ S/ 的/ 一个/ 基本/ 重复/ 体/ ,/ 且/ 出现/ 频率/ 为/ f/ ,/ 那么/ A/ 的/ 每个/ L/ -/ 子串/ 出现/ 频率/ 均/ 为/ f/ ./ 证明/ ./ 略/ ./ 结论/ 可/ 由/ 定义/ 直接/ 而/ 得/ ./ 上述/ 性质/ 使/ 我们/ 在/ 计算/ 重复/ 体/ 的/ 出现/ 频率/ 时/ ,/ 可以/ 删除/ 大多数/ 非/ 候选/ 的/ 重复/ 体/ ./ 在/ 计算/ 中/ ,/ 使用/ 后缀/ 树/ 作为/ 基本/ 数据结构/ ,/ 来/ 统计/ 具有/ 给定/ 阈值/ 的/ 其/ L/ -/ 子串/ 的/ 频率/ ./ 2.3/ 算法/ 描述/ RepSeeker/ 算法/ 首先/ 找出/ 输入/ 序列/ S/ 中/ 的/ 所有/ 基本/ 重复/ 体/ ,/ 然后/ 输出/ 重复/ 体/ 的/ 一个/ 有序/ 表/ ./ 重复/ 体表/ 中/ 的/ 元素/ 是/ 一个/ 数对/ ,/ 表示/ 一个/ 重复/ 体在/ 输入/ 序列/ 中/ 的/ 起始/ 位置/ 和/ 结束/ 位置/ ./ 因此/ ,/ 识别/ 基本/ 重复/ 体/ 的/ 问题/ 可以/ 转换/ 为/ 寻找/ 重复/ 体/ 的/ 边界问题/ ./ 因而/ ,/ RepSeeker/ 算法/ 检查/ 输入/ 序列/ 中/ 每个/ 位置/ ,/ 并/ 确定/ 一个/ 位置/ 是否是/ 重复/ 体/ 的/ 一个/ 边界/ ./ 使用/ 穷尽/ 算法/ 查找/ 基本/ 重复/ 体是/ 不切实际/ 的/ ,/ 因为/ 在/ S/ 中有/ O/ (/ n2/ )/ 个/ 子串/ ,/ 对于/ 每个/ 长为/ m/ 的/ 子串/ ,/ 需要/ 检查/ O/ (/ m2/ )/ 个/ 子串/ ./ 因而/ ,/ 我们/ 构造/ 输入/ 序列/ S/ 的/ 一棵/ 后缀/ 树/ ,/ 帮助/ 进行/ 频率/ 统计/ ./ 按照/ 性质/ 1/ ,/ 可/ 得/ :/ 如果/ A/ 是/ S/ 的/ 一个/ 基本/ 重复/ 体/ ,/ 那么/ A/ 的/ 所有/ L/ -/ 子串/ 出现/ 频率/ 相同/ ,/ 且/ 至少/ 为/ Fm/ ./ 于是/ ,/ RepSeeker/ 算法/ 计算/ 出/ 所有/ L/ -/ 子串/ 的/ 出现/ 频率/ ,/ 并/ 根据/ 频率/ 数组/ 把/ 频率/ 相等/ 且/ 至少/ 为/ Fm/ 的/ 放在/ 一块/ 中/ ./ 由于/ 这/ 只是/ 一个/ 必要条件/ ,/ RepSeeker/ 算法/ 会/ 检查/ 这些/ 块/ ,/ 并/ 分裂/ 那些/ 包含/ 非/ 子/ 重复/ 的/ 块/ ./ 进而/ ,/ 算法/ 对/ 所得/ 重复/ 体/ 进行/ 扩展/ ,/ 最终/ 进行/ 分类/ ./ RepSeeker/ 算法/ 由/ 以下/ 5/ 步/ 组成/ ./ 第/ 1/ 步/ ./ 计算/ 子串/ 在/ 滑动/ 窗口/ 中/ 的/ 频率/ ./ 我们/ 把/ 重复/ 体/ 的/ 最小/ 长度/ L/ 作为/ 滑动/ 窗口/ 的/ 宽度/ ,/ 并/ 计算长度/ 为/ W/ 的/ 子串/ 在/ 此/ 窗口/ 中/ 出现/ 的/ 频率/ ./ 滑动/ 窗口/ 每次/ 向/ 右/ 移动/ 一个/ 位置/ ./ 设/ 频率/ 数组/ 为/ f/ ,/ f/ [/ i/ ]/ 表示/ 在/ 位置/ i/ 开始/ 的/ L/ -/ 子串/ 的/ 出现/ 次数/ ,/ 即/ S/ [/ i/ ,/ i/ +/ L/ -/ 1/ ]/ 的/ 频率/ ./ 图/ 1/ 中/ 显示/ 了/ 输入/ 序列/ S/ 的/ 频率/ 数组/ f/ 的/ 值/ ./ 在/ 图/ 1/ 中/ ,/ f/ [/ 0/ ]/ =/ 3/ 表示/ 在/ 位置/ 0/ 开始/ 的/ 长为/ 4/ 的/ 子串/ S/ [/ 0/ ,/ 3/ ]/ 在/ S/ 中/ 出现/ 3/ 次/ ,/ S/ [/ 0/ ,/ 3/ ]/ =/ “/ ABCD/ ”/ ;/ f/ [/ 5/ ]/ =/ 3/ 表示/ 在/ 位置/ 5/ 开始/ 的/ 长为/ 4/ 的/ 子串/ S/ [/ 5/ ,/ 8/ ]/ 在/ S/ 中/ 出现/ 3/ 次/ ./ 第/ 2/ 步/ ./ 求出/ 频率/ 相等/ 的/ 块/ ./ 根据/ 第/ 1/ 步中/ 计算/ 的/ 频率/ 数组/ ,/ 可以/ 计算/ 出/ 出现/ 次数/ 至少/ 为/ Fm/ 的/ L/ -/ 子串/ 的/ 起始/ 位置/ 和/ 结束/ 位置/ ./ 在/ RepSeeker/ 算法/ 中/ ,/ 使用/ l/ 和/ r/ 分别/ 记录/ 它/ 的/ 左右/ 边界/ (/ 即/ 起始/ 位置/ 和/ 结束/ 位置/ )/ ./ 如果/ 分别/ 来自/ l/ 数组/ 和/ r/ 数组/ 的/ 两个/ 元素/ 在/ 输入/ 序列/ S/ 中/ 的/ 位置/ 相同/ 且/ 位置/ 为/ i/ ,/ 那么/ 它们/ 表示/ 同/ 频率/ 的/ 候选/ 重复/ 块/ (/ l/ [/ i/ ]/ ,/ r/ [/ i/ ]/ )/ ./ 基于/ 频率/ 数组/ f/ ,/ 我们/ 把/ 序列/ 划分/ 成同/ 频率/ 的/ 块/ ./ 特别/ 是/ ,/ 对于/ 任何/ 位置/ i/ ,/ 如果/ f/ [/ i/ ]/ ≠/ f/ [/ i/ -/ 1/ ]/ ,/ 那么/ 位置/ i/ 是/ 这个/ 同/ 频率/ 块/ 的/ 起始/ 位置/ ;/ 如果/ f/ [/ i/ ]/ ≠/ f/ [/ i/ +/ 1/ ]/ ,/ 说明/ 同/ 频率/ 块/ 的/ 最后/ L/ -/ 子串/ 在/ 位置/ i/ 开始/ ,/ 也就是说/ ,/ i/ +/ L/ -/ 1/ 是/ 这块/ 的/ 结束/ 位置/ ./ 每当/ 得到/ 一个/ 起始/ 位置/ 或/ 结束/ 位置/ 时/ ,/ 就/ 把/ 这个/ 位置/ 插入/ 到/ l/ 数组/ 或/ r/ 数组/ 中/ ./ 完成/ l/ 数组/ 或/ r/ 数组/ 的/ 计算/ 之后/ ,/ 接下来/ 是/ 对/ l/ 数组/ 和/ r/ 数组/ 中/ 的/ 元素/ 进行/ 配对/ ./ (/ l/ [/ i/ ]/ ,/ r/ [/ i/ ]/ )/ 是/ 我们/ 所/ 找到/ 的/ 第/ i/ 个/ 相同/ 频率/ 块/ ./ 例如/ ,/ 对于/ l/ [/ 0/ ]/ =/ 0/ 且/ r/ [/ 0/ ]/ =/ 9/ ,/ 图/ 1/ 中/ 的/ 块/ S/ [/ 0/ ,/ 9/ ]/ =/ “/ ABCDEEBCAD/ ”/ 是/ 一个/ 频率/ 相等/ 块/ ,/ 它/ 的/ 长为/ 4/ 的/ 7/ 个/ 子串/ 出现/ 频率/ 一样/ ./ 对于/ 图/ 1/ 中/ 的/ 示例/ ,/ 去掉/ 频率/ 小于/ Fm/ (/ =/ 3/ )/ Page4/ 的/ 子串/ 后/ ,/ 最终/ 频率/ 相等/ 块/ 为/ S/ [/ 0/ ,/ 9/ ]/ ,/ S/ [/ 12/ ,/ 21/ ]/ ,/ S/ [/ 24/ ,/ 28/ ]/ ,/ S/ [/ 29/ ,/ 33/ ]/ 和/ S/ [/ 36/ ,/ 41/ ]/ ./ 第/ 3/ 步/ ./ 子/ 重复/ 检查/ ./ 对/ 从/ 第/ 2/ 步/ 得到/ 的/ 块/ 进行/ 检查/ ,/ 设某/ 一块/ Di/ =/ S/ [/ i1/ ,/ i2/ ]/ ,/ 块/ 长度/ 为/ length/ ,/ 出现/ 频率/ 为/ k/ ,/ 其块/ 内/ 所有/ 长度/ 为/ L/ 的/ 子串/ 的/ 频率/ 为/ m/ ,/ 若/ k/ </ m/ ,/ 则/ 块/ Di/ 内/ 含有/ 不是/ 子/ 重复/ 的/ 子串/ ./ 从左到右/ 依次/ 求出/ 块/ Di/ 中/ 所有/ 长度/ 为/ L/ 的/ 子串/ 在/ S/ 中/ 的/ 出现/ 位置/ ,/ 然后/ 对/ 开始/ 位置/ 相邻/ 的/ 两个/ 子串/ 的/ 出现/ 位置/ 序列/ 进行/ 比较/ ,/ 若/ 存在/ 对应/ 次序/ 上/ 的/ 位置/ 不/ 相邻/ ,/ 则/ 分裂/ 块/ Di/ ./ 例如/ ,/ 图/ 1/ 中/ ,/ 子串/ S/ [/ 0/ ,/ 9/ ]/ 的/ 发生/ 频率/ 为/ 2/ ,/ 但/ 在/ 第/ 2/ 步中/ 被/ 识别/ 为/ 重复/ 体/ ,/ 通过/ 子/ 重复/ 检查/ ,/ 发现/ S/ [/ 1/ ,/ 4/ ]/ =/ “/ BCDE/ ”/ 的/ 出现/ 位置/ 为/ {/ 1/ ,/ 13/ ,/ 30/ }/ ,/ S/ [/ 2/ ,/ 5/ ]/ =/ “/ CDEE/ ”/ 的/ 出现/ 位置/ 为/ {/ 2/ ,/ 14/ ,/ 36/ }/ ,/ 两/ 子串/ 的/ 第/ 3/ 次/ 出现/ 位置/ 不/ 相邻/ ,/ 因此/ 将/ 2/ 插入/ l/ 数组/ ,/ 将/ 5/ 插入/ r/ 数组/ ./ 对/ 数组/ l/ 和/ r/ 的/ 插入/ 要求/ 进行/ 有序/ 插入/ ,/ 即/ 插入/ 后/ 数组/ 仍/ 保持/ 有序/ ./ 所以/ S/ [/ 0/ ,/ 9/ ]/ 可/ 分裂/ 成/ S/ [/ 0/ ,/ 4/ ]/ ,/ S/ [/ 2/ ,/ 7/ ]/ ,/ S/ [/ 5/ ,/ 9/ ]/ 3/ 个/ 重复/ 体/ ./ 第/ 4/ 步/ ./ 重复/ 体/ 扩展/ ./ 为了/ 尽可能/ 得到/ 更长/ 的/ 重复/ 体/ ,/ 我们/ 归并/ 有/ 重叠/ 的/ 重复/ 体/ ,/ 如果/ 归并/ 后/ 的/ 重复/ 体/ 频率/ 至少/ 为/ Fm/ ./ 具有/ 较/ 高频率/ 的/ 重复/ 体/ 仍然/ 被/ 保留/ 下来/ ,/ 较/ 低/ 频率/ 的/ 重复/ 体/ 被/ 扩展/ ./ 令/ 重复/ 体/ A/ 和/ B/ 含有/ 重叠/ 块/ ,/ 重叠/ 块/ 称为/ C/ ./ 归并/ 满足/ 的/ 条件/ 如下/ :/ 且/ 其中/ merop/ 为/ 重叠/ 率/ ,/ OP/ 为/ 指定/ 最小/ 重叠/ 率/ ,/ A/ ∪/ B/ 为/ 归并/ A/ 与/ B/ 之后/ 的/ 结果/ ,/ frequency/ 为/ 归并/ 后/ 子串/ 的/ 出现/ 频率/ ./ 例如/ ,/ 在/ 图/ 2/ 中/ ,/ 假设/ 重复/ 体/ A/ 和/ B/ 分别/ 在/ 输入/ 序列/ 中/ 出现/ 3/ 次/ 和/ 2/ 次/ ./ 由图/ 2/ 可得/ A1/ 和/ B1/ 有/ 公共/ 重叠/ 子块/ ./ 如果/ A/ 和/ B/ 的/ 重叠/ 率/ 至少/ 为/ OP/ ,/ 且/ 归并/ 之后/ 的/ 结果/ 块/ M1/ 至少/ 出现/ Fm/ 次/ ,/ 那么/ 我们/ 进行/ 归并/ ,/ 也/ 即/ 实施/ 了/ 扩展/ ./ 同样/ ,/ 归并/ A3/ 和/ B2/ 得到/ M2/ ./ 最终/ ,/ B1/ 和/ B2/ 分别/ 被/ 扩展/ 至/ M1/ 和/ M2/ ./ 第/ 5/ 步/ ./ 重复/ 体/ 归类/ ./ 将/ 相同/ 的/ 重复/ 体归为/ 一类/ ./ 2.4/ RepSeeker/ 算法/ RepSeeker/ 算法/ 如下/ ./ RepSeeker/ (/ S/ ,/ L/ ,/ Fm/ )/ Input/ :/ stringSwithlengthn/ ,/ minimumlengthLofOutput/ :/ classificationlistofallrepeatsinSthatap/ -/ 0/ ./ createasuffixtreeforthestringS1/ ./ fori/ ←/ 0ton/ -/ Ldo2/ ./ f/ [/ i/ ]/ ←/ frequencyoftheithL/ -/ substringinS3/ ./ createD/ :/ anarrayofrepeatblocksinS4/ ./ iff/ [/ 0/ ]/ / Fmthenadd0inlarray5/ ./ fori/ ←/ 1ton/ -/ L/ -/ 1do6/ ./ iff/ [/ i/ ]/ / Fmthen7/ ./ iff/ [/ i/ ]/ ≠/ f/ [/ i/ -/ 1/ ]/ thenaddiinlarrayasa8/ ./ iff/ [/ i/ ]/ ≠/ f/ [/ i/ +/ 1/ ]/ thenaddi/ +/ L/ -/ 1inrarray9/ ./ fori/ ←/ 0to/ |/ l/ |/ -/ 1do10/ ./ D/ [/ i/ ]/ ←/ (/ l/ [/ i/ ]/ ,/ r/ [/ i/ ]/ )/ 11/ ./ D/ ←/ {/ D/ [/ 0/ ]/ ,/ D/ [/ 1/ ]/ ,/ …/ ,/ D/ [/ k/ -/ 1/ ]/ }/ ,/ sum/ ←/ |/ D/ |/ 12/ ./ Check/ (/ D/ )/ 13/ ./ Extend/ (/ D/ )/ 14/ ./ Classify/ (/ D/ )/ Check/ (/ D/ :/ anarrayofblocksofequalfrequency/ )/ 1/ ./ fori/ ←/ 0tosum/ -/ 1do2/ ./ iff/ [/ l/ [/ i/ ]/ ]/ ≠/ f/ (/ D/ [/ i/ ]/ )/ then3/ ./ forj/ ←/ 0to/ |/ D/ [/ i/ ]/ |/ -/ Ldo4/ ./ P/ [/ j/ ]/ ←/ sortedlistofpositionsofoccurrencesof5/ ./ fork/ ←/ 0to/ |/ D/ [/ i/ ]/ |/ -/ L/ -/ 1do6/ ./ form/ ←/ 0tof/ [/ l/ [/ i/ ]/ ]/ -/ 1do7/ ./ ifP/ [/ k/ +/ 1/ ,/ m/ ]/ ≠/ P/ [/ k/ ,/ m/ ]/ +/ 1then8/ ./ insertl/ [/ i/ ]/ +/ k/ +/ 1intolandkeepitsorder9/ ./ insertl/ [/ i/ ]/ +/ k/ +/ L/ -/ 1intorandkeepitsorder10/ ./ sum/ ←/ sum/ +/ 1Extend/ (/ D/ :/ anarrayofelementaryrepeats/ )/ 1/ ./ fori/ ←/ 1tosum/ -/ 1do2/ ./ ifmerop/ (/ i/ ,/ i/ +/ 1/ )/ / OPandfrequencyofmerged3/ ./ then4/ ./ D/ [/ i/ ]/ ←/ (/ l/ [/ i/ ]/ ,/ r/ [/ i/ +/ 1/ ]/ )/ 5/ ./ i/ ←/ i/ -/ 1/ ,/ sum/ ←/ sum/ -/ 1Classify/ (/ D/ :/ anarrayofextendedrepeats/ )/ 1/ ./ fori/ ←/ 0tosum/ -/ 1do2/ ./ class/ [/ i/ ]/ ←/ repeatsequaltoD/ [/ i/ ]/ RepSeeker/ 算法/ 工作/ 如下/ ./ 第/ 1/ ~/ 2/ 行/ 计算/ S/ 的/ 所有/ L/ -/ 子串/ 的/ 频率/ ./ 第/ 4/ ~/ 8/ 行/ 找出/ 频率/ 至少/ 为/ Fm/ 的/ 所有/ 重复/ 块/ 的/ 起始/ 位置/ 和/ 结束/ 位置/ ./ 第/ 9/ ~/ 10/ 行对/ l/ 数组/ 和/ r/ 数组/ 中/ 元素/ 配对/ ./ 子/ 例程/ Check/ 检查/ 块/ Di/ 是否/ 包含/ 非/ 子/ 重复/ ./ 子/ 例程/ Extend/ 归并/ 满足条件/ 的/ 重复/ 体/ ,/ 以/ 达到/ 扩展/ 的/ 目的/ ./ 子/ 例程/ Classify/ 对/ 重复/ 体/ 归类/ 输出/ ./ Page52/ ./ 5/ 后缀/ 树/ 在/ RepSeeker/ 算法/ 中/ 的/ 作用/ 后缀/ 树/ 数据结构/ 对于/ RepSeeker/ 重复/ 体/ 识别/ 算法/ 的/ 有效/ 实现/ 起着/ 至关重要/ 的/ 作用/ ./ 在/ 图/ 3/ 中/ ,/ 我们/ 从/ T/ 出发/ 到/ 叶子/ 结点/ ,/ 可/ 得到/ 该/ 序列/ 的/ 一个/ 后缀/ ./ 设/ 序列/ P/ 是/ k/ 个/ 后缀/ 的/ 公共/ 前缀/ ,/ 而/ 对于/ 整个/ 序列/ 来说/ ,/ P/ 出现/ 了/ k/ 次/ ./ 这样/ 我们/ 可以/ 通过/ 遍历/ 同一/ “/ 主干/ ”/ 下/ 的/ 叶子/ 数目/ ,/ 来/ 确定/ 该/ “/ 主干/ ”/ 在/ 序列/ 中/ 的/ 出现/ 次数/ ,/ 也/ 即/ 频率/ ./ RepSeeker/ 算法/ 的/ 主/ 过程/ 第/ 2/ ~/ 3/ 行用/ 后缀/ 树/ 求得/ 频率/ 数组/ f/ ./ 存在/ 的/ 问题/ :/ (/ 1/ )/ 为了/ 得到/ 子串/ P/ 的/ 频率/ ,/ 我们/ 必须/ 遍历/ N/ 下/ 所有/ 叶子/ 结点/ ,/ 来/ 计算/ 叶子/ 数目/ ./ 对于/ DNA/ 序列/ 来说/ ,/ 通过/ 遍/ 历来/ 获取/ 所/ 需/ 信息/ 的/ 时间/ 需求/ 是/ 无法忍受/ 的/ ./ (/ 2/ )/ Ukkonen/ 构建/ 的/ 后缀/ 树/ ,/ 结点/ 是/ 按/ 顺序/ 分配/ 的/ ,/ 没有/ 对/ 叶子/ 结点/ 和/ 分支/ 结点/ 的/ 区分/ ./ 我们/ 不能/ 通过/ 叶子/ 的/ 序号/ 来/ 得到/ 重复/ 体/ 的/ 出现/ 位置/ ./ 在/ 第/ 3/ 步/ 的/ 子/ 重复/ 检查/ 中/ ,/ 要/ 通过/ KMP/ [/ 15/ ]/ 来/ 解决/ ./ 在/ 第/ 5/ 步/ 的/ 重复/ 体/ 归类/ 中/ ,/ 要/ 通过/ 甚至/ 时间/ 复杂度/ 为/ O/ (/ n2/ )/ 的/ 算法/ 来/ 完成/ ./ 3/ 对/ Ukkonen/ 算法/ 的/ 适应性/ 改进/ 3.1/ Ukkonen/ 后缀/ 树/ 构造/ 过程/ Ukkonen/ 后缀/ 树/ 构造/ 算法/ [/ 16/ -/ 17/ ]/ 的/ 基本/ 思想/ 是/ 对于/ 字符串/ S/ 的/ 每个/ 前缀/ S/ [/ 1/ ../ i/ ]/ 构造/ 一个/ 隐/ 后缀/ 树/ Ti/ ,/ 从/ T1/ 开始/ ,/ 逐步/ 增加/ i/ ,/ 直到/ 完成/ Tn/ 的/ 构造/ ,/ i/ =/ 1/ ../ n/ ./ 若/ 字符串/ S/ 的/ 长度/ 为/ n/ ,/ 则/ 构造/ 算法/ 分成/ n/ 步/ ,/ 对于/ 每/ 一步/ i/ +/ 1/ ,/ 又/ 分成/ i/ +/ 1/ 个/ 扩展/ ,/ 每个/ 扩展/ 代表/ 了/ S/ [/ 1/ ../ i/ +/ 1/ ]/ 的/ i/ +/ 1/ 个/ 后缀/ 中/ 的/ 一个/ 后缀/ ,/ 在/ 第/ i/ +/ 1/ 步/ 的/ 第/ j/ 个/ 扩展/ 中/ ,/ 算法/ 首先/ 找到/ 从根/ 节点/ 开始/ 标记/ 子串/ S/ [/ j/ ,/ …/ ,/ i/ ]/ 的/ 路径/ 的/ 结束/ 位置/ ,/ 然后/ 将/ 字符/ S/ (/ i/ +/ 1/ )/ 加入/ 该/ 子串/ 尾/ 对/ 它/ 进行/ 扩展/ ,/ 除非/ S/ (/ i/ +/ 1/ )/ 已经/ 存在/ ./ 因此/ ,/ 在/ 第/ i/ +/ 1/ 步/ ,/ 字符串/ S/ [/ 1/ ,/ …/ ,/ i/ +/ 1/ ]/ 首先/ 被/ 插入/ 树中/ ,/ 然后/ 插入/ S/ [/ 2/ ,/ …/ ,/ i/ +/ 1/ ]/ ,/ S/ [/ 3/ ,/ …/ ,/ i/ +/ 1/ ]/ ,/ 以此类推/ ./ 在/ i/ +/ 1/ 步/ 的/ 第/ i/ +/ 1/ 个/ 扩展/ 中/ 对/ S/ [/ 1/ ../ i/ ]/ 的/ 空/ 后缀/ 进行/ 扩展/ ,/ 确保/ 向树中/ 插入/ 了/ 单个/ 字符/ S/ (/ i/ +/ 1/ )/ (/ 除非/ S/ (/ i/ +/ 1/ )/ 已经/ 存在/ )/ ./ 树/ T1/ 是/ 标记/ 为/ S/ (/ 1/ )/ 的/ 单条/ 边/ ./ 在/ 后缀/ 树/ 算法/ 构造/ 过程/ 中/ ,/ 引入/ 了/ 扩展/ 后缀/ 树/ 的/ 3/ 个/ 规则/ 以及/ 后缀/ 链使/ 算法/ 的/ 时间/ 复杂度/ 为/ O/ (/ n/ )/ ./ 算法/ 的/ 详细描述/ 见/ 文献/ [/ 16/ -/ 17/ ]/ ./ 3.2/ Ukkonen/ 算法/ 特征分析/ 这个/ 算法/ 有/ 几个/ 显著/ 的/ 特点/ :/ 一旦/ 一个/ 结点/ 被/ 作为/ 叶子/ 结点/ 创建/ ,/ 那么/ 它/ 始终/ 都/ 是/ 叶子/ 结点/ ,/ 将/ 不会/ 有/ 子孙/ 结点/ ./ 更/ 重要/ 的/ 是/ ,/ 在/ 每次/ 将/ 一个/ 前缀/ 插入/ 到/ 树/ 中/ ,/ 就/ 机械/ 地用/ 一个/ 相同/ 的/ 字符/ 去/ 扩展/ 每/ 一个/ 指向/ 叶子/ 结点/ 的/ 边/ ,/ 而/ 这个/ 字符/ 必然/ 是/ 新/ 后缀/ 的/ 最后/ 一个/ 字符/ ./ 3.3/ 构建/ 后缀/ 树时/ 的/ 改进/ 后缀/ 树对/ RepSeeker/ 算法/ 的/ 主要/ 贡献/ 在于/ ,/ 它/ 能/ 快速/ 地求/ 出定/ 长/ 子串/ P/ 在/ S/ 中/ 的/ 出现/ 频率/ ,/ 也/ 就是/ 求出/ 有/ 相同/ 前缀/ P/ 的/ 后缀/ 个数/ ./ 如图/ 3/ ,/ 利用/ 后缀/ 树/ 计算/ 子串/ 频率/ 传统/ 的/ 方法/ 是/ :/ (/ 1/ )/ 从/ 树根/ 找/ 起/ ,/ 先/ 找到/ 与/ P/ 相匹配/ 的/ 树/ 的/ 主干/ ;/ (/ 2/ )/ 遍历/ 以/ 结点/ N/ 为根/ 的/ 所有/ 叶子/ 结点/ ,/ 所得/ 的/ 叶子/ 结点/ 数/ 就是/ 要求/ 的/ P/ 的/ 频率/ ./ 第/ 1/ 步/ 可以/ 在/ 线性/ 时间/ 内/ 找到/ N/ ,/ 第/ 2/ 步则/ 要/ 遍历/ 以/ N/ 为根/ 的/ 树/ ,/ 对于/ RepSeeker/ 算法/ 中/ ,/ 用/ 移动/ 窗口/ 求/ 频率/ 数组/ ,/ 总共/ 要/ 遍历/ |/ S/ |/ -/ L/ 个/ 这样/ 的/ 树/ ./ 而/ 查找/ 重复/ 体/ 的/ 副本/ 位置/ ,/ Ukkonen/ 构建/ 的/ 后缀/ 树/ 无所适从/ ./ 为了/ 高效/ 实现/ RepSeeker/ 算法/ ,/ 我们/ 对/ Ukkonen/ 构建/ 后缀/ 树/ 的/ 算法/ 进行/ 了/ 适应性/ 改进/ ./ 改进/ 主要/ 是/ 在/ 构造/ 时/ 加入/ 了/ 结点/ 信息/ ,/ 包括/ 两点/ :/ (/ 1/ )/ 在/ 构建/ 后缀/ 树时/ ,/ 对/ 叶子/ 结点/ 和/ 分支/ 结点/ 进行/ 区分/ ,/ 做/ 不同/ 的/ 编号/ ./ 结点/ 总/ 个数/ 初始化/ 为/ 2/ ×/ |/ S/ |/ ,/ 给/ 叶子/ 编号/ 是从/ 0/ 开始/ ,/ 每次/ 加/ 1/ ,/ 给/ 分支/ 结点/ 编号/ 从/ 尾部/ 开始/ ,/ 每次/ 减/ 1/ ./ (/ 2/ )/ 在/ 分支/ 结点/ 处/ 加入/ 结点/ 信息/ ,/ 包括/ 当前/ 结点/ 下/ 的/ 叶子/ 数/ 以及/ 叶子/ 序号/ ./ 以/ 2.3/ 节中/ 的/ 算法/ 为据/ ,/ 首先/ 给/ 结点/ 数组/ 中/ 每/ 一个/ 成员/ 加入/ parent/ 变量/ ,/ 保存/ 父/ 结点/ 编号/ ./ 通过/ parent/ ,/ 给/ 新/ 叶子/ 结点/ 的/ 所有/ 父/ 结点/ 加入/ 新/ 的/ 结点/ 信息/ ,/ 即/ 叶子/ 数加/ 1/ ,/ 并/ 在/ 结点/ 信息/ 数组/ 中/ 加入/ 新/ 叶子/ 编号/ ./ 图/ 4/ 显示/ 了/ 字符串/ agagagcagagt/ 所/ 对应/ 的/ 改进/ 后/ 的/ 适应性/ 的/ 后缀/ 树/ ./ 结点/ 5/ 上/ 的/ 信息/ 3138/ 表明/ ,/ 该/ 结点/ 下有/ 3/ 个/ 叶子/ 结点/ ,/ 它/ 的/ 后缀/ 在/ 字符串/ 中/ 出现/ 的/ 位置/ 为/ 1/ ,/ 3/ 和/ 8/ ./ Page6/ 图/ 4/ 字符串/ agagagcagagt/ 所/ 对应/ 的/ 适应性/ 的/ 后缀/ 树/ 3.4/ 改进/ 对/ 算法/ 的/ 支持/ 质/ 的/ 提高/ ./ 优点/ 主要/ 表现/ 在/ 两/ 方面/ :/ 对/ Ukkonen/ 后缀/ 树/ 改进/ 后/ ,/ 带来/ 了/ 算法/ 速度/ 上/ (/ 1/ )/ 用/ 移动/ 窗口/ 求/ 频率/ 数组/ 时/ ,/ 求/ 每/ 一/ 窗口/ 内/ 子串/ 的/ 频率/ 可/ 在/ O/ (/ L/ )/ 时间/ 内/ 完成/ ,/ L/ 为/ 窗口/ 宽度/ ,/ 即/ 如图/ 3/ 中/ ,/ 求/ P/ 的/ 频率/ 就/ 等/ 于是/ 在/ 找到/ 主干/ P/ 的/ 终止/ 结点/ N/ ,/ 找到/ 后/ 读取/ 信息/ 即可/ ./ 而/ 匹配/ P/ 的/ 过程/ 是/ 在/ HASH/ 表中/ 进行/ 的/ ,/ 只/ 需/ 进行/ 主干/ P/ 路径/ 上/ 的/ 结点/ 数次/ 比较/ ,/ 便/ 可/ 找到/ N/ ./ 时间/ 复杂度/ 由/ O/ (/ nlog/ (/ n/ )/ )/ 降为/ O/ (/ n/ )/ ./ (/ 2/ )/ 在子/ 过程/ Classify/ 中/ ,/ 无需/ 进行/ 二重/ 循环式/ 的/ 比较/ ,/ 和/ 求/ 频率/ 数组/ 一样/ ,/ 只/ 需/ 找到/ 当前/ 重复/ 体/ 的/ 结束/ 结点/ ,/ 读取/ 结点/ 信息/ 即可/ ,/ 结点/ 中/ 的/ 后缀/ 位置/ 信息/ 就是/ 该/ 重复/ 体/ 的/ 副本/ 分布/ 位置/ ./ 时间/ 复杂度/ 由/ O/ (/ n2/ )/ 降为/ O/ (/ n/ )/ ./ (/ 3/ )/ 更/ 重要/ 的/ 是/ ,/ 加入/ 结点/ 信息/ 所用/ 的/ 时间/ 只是/ 在/ 找/ 新/ 叶子/ 的/ 父/ 结点/ ,/ parent/ 变量/ 是/ 结点/ 数组/ 的/ 索引/ 号/ ,/ 找父/ 结点/ 的/ 时间/ 复杂度/ 为/ O/ (/ 1/ )/ ×/ 父/ 结点/ 个数/ ./ 因此/ 改进/ 后/ 的/ Ukkonen/ 算法/ 在/ 构造/ 速度/ 方面/ 几乎/ 没有/ 受到/ 影响/ ./ 4/ 时间/ 和/ 空间/ 复杂度/ 分析/ 在/ 对/ 后缀/ 树/ 构造/ 算法/ 改进/ 之后/ ,/ 算法/ 主/ 过程/ RepSeeker/ (/ S/ ,/ L/ ,/ Fm/ )/ 的/ 第/ 1/ ~/ 3/ 步/ ,/ 在/ 后缀/ 树上/ 查找/ 长度/ 为/ L/ 的/ 子串/ 是/ 在/ Hash/ 表上/ 进行/ 的/ ,/ 所以/ 计算/ 频率/ 数组/ 时间/ 复杂度/ 为/ O/ (/ n/ )/ ./ 算法/ 主/ 过程/ RepSeeker/ (/ S/ ,/ L/ ,/ Fm/ )/ 的/ 时间/ 复杂度/ 依赖于/ 子/ 过程/ Check/ 的/ 时间/ 复杂度/ ./ 子/ 过程/ Check/ 是/ 一个/ 多重/ 循环/ 过程/ ,/ 第/ 1/ 层/ 循环/ 遍历/ 所有/ 频率/ 相等/ 且/ 大于/ 限定/ 频率/ Fm/ 的/ 所有/ 块/ ./ 第/ 2/ 层/ 循环/ 用/ 宽度/ 为/ L/ 的/ 移动/ 窗口/ 对/ 每个/ 块/ 进行/ 分析/ ./ 第/ 3/ 层/ 循环/ 的/ 循环/ 次数/ 为/ 当前/ 移动/ 窗口/ 内/ 子串/ 的/ 发生/ 位置/ 的/ 频率/ ./ 设/ 频率/ 相等/ 块/ 的/ 个数/ 为/ N/ ,/ 移动/ 窗口/ 可/ 移动/ 次数/ 为/ M/ ,/ 窗口/ 内/ 子串/ 的/ 平均/ 发生/ 频率/ 为/ f/ ,/ 那么/ 可以/ 看出/ 检查/ 过程/ 运算/ 次数/ 为/ N/ ×/ M/ ×/ f/ ,/ 时间/ 复杂度/ 为/ O/ (/ N/ ×/ M/ ×/ f/ )/ ./ 分析/ 出/ 算法/ 的/ 时间/ 复杂度/ 为/ O/ (/ MN/ )/ ./ 算法/ 在/ 运行/ 过程/ 中/ 存储/ 边/ 的/ 信息/ 到/ 散/ 列表/ 中/ ,/ 这个/ 表/ 的/ 大小/ 一般/ 不/ 超过/ |/ S/ |/ ×/ 2.1/ ./ 结点/ 存储/ 在/ 顺序/ 数组/ 中/ ,/ 大小/ 为/ |/ S/ |/ +/ 1/ ./ 由于/ 对/ Ukkonen/ 后缀/ 树/ 的/ 适应性/ 改进/ ,/ 增加/ 了/ 结点/ 信息/ ,/ 从而/ 加大/ 了/ 算法/ 对于/ 空间/ 的/ 要求/ ./ 设/ 新增/ 结点/ 信息/ 平均/ 空间/ 需求/ 为/ |/ X/ |/ ,/ 由于/ 只是/ 在/ 分支/ 结点/ 上/ 加入/ 了/ 结点/ 信息/ ,/ 叶子/ 结点/ 所/ 需/ 空间/ 为/ |/ M/ |/ ,/ 所以/ 结点/ 总/ 的/ 空间/ 应为/ (/ |/ S/ |/ +/ 1/ )/ ×/ |/ X/ |/ +/ |/ M/ |/ ×/ (/ |/ S/ |/ +/ 1/ )/ // 2.5/ 实验/ 5.1/ 实验/ 参数设置/ 程序/ RepSeeker/ 在/ MicrosoftVisual/ C++/ 6.0/ 环境/ 上/ 通过/ C++/ 语言/ 实现/ ./ 算法/ 取/ 移动/ 窗口/ 宽度/ L/ 为/ 20/ ,/ 最低/ 限制/ 频率/ 为/ 3/ ,/ 合并/ 重叠/ 序列/ 时/ 重叠/ 限制/ 比例/ 为/ 25/ %/ ./ 本/ 实验/ 测试/ 机器/ 为/ Intel3GHz/ ,/ 1GB/ 内存/ 的/ 计算机/ ./ 5.2/ 实验/ 结果/ 实验/ 使用/ 大小不等/ 的/ DNA/ 序列/ 作为/ 测试/ 对象/ ,/ 以/ 识别/ 出/ 的/ 重复/ 体/ 个数/ 、/ 最大/ 重复/ 体/ 及其/ 长度/ 、/ 重复/ 体/ 的/ 归类/ 表/ 作为/ 测试/ 的/ 结果/ ./ 并/ 与/ 改进/ 前/ 的/ 指标/ 进行/ 了/ 对比/ ./ 表/ 1/ 列出/ 了/ 实验/ 结果/ ./ Page7/ 表/ 1/ 重复/ 体/ 识别/ 算法/ 在/ 后缀/ 树/ 改进/ 前后/ 的/ 性能/ 序列/ 名/ 长度/ 限制/ 频率/ X141121522613AL5938532232763AC0085831224933CU210914314333NC/ _/ 0074103663543DOGHUMAN3M290001035/ ./ 3/ 结果/ 分析/ 基于/ 表/ 1/ 的/ 实验/ 结果/ ,/ 分别/ 从/ 重复/ 体/ 识别/ 结果/ 和/ 运行/ 时间/ 两个/ 方面/ 进行/ 分析/ ./ 对于/ 重复/ 体/ 识别/ 结果/ ,/ 从/ 实验/ 结果/ 来看/ ,/ 改进/ 后/ 的/ 后缀/ 树对/ RepSeeker/ 算法/ 提供/ 了/ 强有力/ 的/ 支持/ ,/ 使/ 其/ 在/ 计算速度/ 上/ 得到/ 了/ 很大/ 程度/ 的/ 提高/ ./ 对于/ 长度/ 较/ 小/ 的/ 序列/ 时间/ 性能/ 的/ 提高/ 意义/ 不/ 大/ ,/ 如/ DNA/ 序列/ 文件/ AC008583/ ,/ 运行/ 时间/ 都/ 是/ 在/ 100s/ 以内/ ;/ 而/ 对于/ 大/ 序列/ ,/ 如/ DNA/ 序列/ 文件/ HUMAN3M/ ,/ 运行/ 时间/ 减少/ 了/ 5/ 个/ 小时/ 左右/ ./ 从/ 运行/ 时间/ 上/ 看/ ,/ RepSeeker/ 算法/ 在/ 改进/ 了/ 后缀/ 树后/ 优于/ 改进/ 前/ 的/ 算法/ ,/ 这/ 也/ 证明/ 了/ 算法/ 在/ 时间/ 复杂度/ 上/ 有所改进/ 的/ 分析/ ./ 下/ 一步/ 算法/ 将/ 在/ 如何/ 减少/ 算法/ 的/ 空间/ 需求/ 上/ 做/ 改进/ ,/ 将/ 在/ 引入/ 新/ 的/ 数据结构/ 上/ 做/ 进一步/ 的/ 探索/ ./ 6/ 结论/ 本文/ 根据/ 当前/ 重复/ 体/ 识别/ 算法/ 中/ 存在/ 的/ 问题/ 提出/ 了/ 一种/ 基于/ Ukkonen/ 后缀/ 树/ 算法/ 的/ 准确/ 重复/ 体/ 的/ 快速/ 识别/ 算法/ RepSeeker/ ./ RepSeeker/ 算法/ 将/ 对/ 近似/ 重复/ 体/ 和/ 重复/ 结构/ 的/ 识别/ 提供/ 强有力/ 的/ 支持/ ,/ 算法/ 在/ 快速/ 识别/ 重复/ 体/ 的/ 同时/ 定位/ 了/ 每/ 一个/ 重复/ 体/ 序列/ 的/ 左右/ 边界/ ,/ 并/ 把/ 每/ 一个/ 重复/ 体/ 归入/ 相应/ 的/ 类/ ./ 算法/ 无论是/ 在/ 计算/ 频率/ 、/ 检查/ 子/ 重复/ 、/ 重复/ 体/ 合并/ 以及/ 最后/ 的/ 重复/ 归类/ 都/ 充分运用/ 了/ 改进/ 后/ 的/ 适应性/ 后缀/ 树/ 构造/ 算法/ ,/ 从而/ 较大/ 地/ 提高/ 了/ 运行/ 速度/ ./ 实验/ 结果表明/ RepSeeker/ 算法/ 的/ 运算/ 速度/ 相对/ 改进/ Ukkonen/ 算法/ 前/ 的/ 算法/ 得到/ 了/ 很大/ 的/ 提高/ ,/ 是/ 一种/ 有效/ 的/ 重复/ 体/ 识别/ 算法/ ./ 

