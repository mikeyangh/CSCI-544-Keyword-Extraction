Page1/ 基线/ 与/ 增量/ 数据/ 分离/ 架构/ 下/ 的/ 分布式/ 连接/ 算法/ 樊秋实/ 周敏奇/ 周傲/ 英/ (/ 华东师范大学/ 数据/ 科学/ 与/ 工程/ 研究院/ ,/ 上海/ 高/ 可信计算/ 重点/ 实验室/ 上海/ 200062/ )/ 摘要/ 在/ 大/ 数据/ 背景/ 下/ ,/ 数据库系统/ 表/ 连接/ 操作/ 的/ 效率/ 急需/ 优化/ ,/ 尤其/ 对于/ 基线/ 与/ 增量/ 数据/ 分离/ 的/ 数据库系统/ 来说/ ,/ 其/ 连接/ 操作/ 更是/ 成为/ 其/ 性能/ 的/ 主要/ 瓶颈/ ./ 为了/ 有效/ 提升/ 事务处理/ 的/ 性能/ ,/ 在/ 基线/ 与/ 增量/ 数据/ 分离/ 的/ 数据库系统/ 架构/ 中/ ,/ 通常/ 将/ 基线/ 数据/ 存储/ 于/ 磁盘/ 中/ ,/ 增量/ 数据/ 存储/ 于/ 内存/ 中/ ,/ 进而/ 获得/ 较/ 高/ 的/ 事务处理/ 吞吐量/ 和/ 可扩展性/ ./ Hbase/ 、/ BigTable/ 、/ OceanBase/ 等/ 系统/ 是/ 典型/ 的/ 基线/ 与/ 增量/ 数据/ 分离/ 的/ 数据库/ 管理系统/ ,/ 但是/ 他们/ 的/ 表/ 连接/ 效率/ 较/ 低/ ,/ 其/ 主要/ 原因/ 包括/ :/ 每次/ 表/ 连接/ 前/ 必须/ 先/ 合并/ 基线/ 数据/ 和/ 增量/ 数据/ ;/ 数据/ 存储/ 模式/ 更为/ 复杂/ ,/ 导致/ 过大/ 的/ 网络/ 开销/ ./ 该文/ 提出/ 了/ 一种/ 基线/ 与/ 增量/ 数据/ 分离/ 架构/ 下/ 的/ 排序/ 归并/ 连接/ 优化/ 算法/ ./ 该/ 算法/ 对/ 连接/ 属性/ 做/ 范围/ 切分/ ,/ 在/ 多个/ 节点/ 上/ 并行/ 做/ 排序/ 归并/ 连接/ ./ 该/ 算法/ 无需/ 在/ 连接/ 前/ 合并/ 基线/ 数据/ 和/ 增量/ 数据/ ,/ 进而/ 实现/ 对/ 基线/ 和/ 增量/ 数据/ 并行处理/ ,/ 同时/ 也/ 避免/ 了/ 大量/ 非/ 连接/ 结果/ 集/ 数据/ 的/ 基线/ 与/ 增量/ 合并/ 操作/ ./ 并/ 在/ 开源/ 的/ 数据库/ OceanBase/ 上/ 实现/ 了/ 该/ 算法/ ,/ 通过/ 一系列/ 实验/ 证明/ ,/ 该/ 算法/ 可以/ 极大/ 提高/ OceanBase/ 数据库/ 的/ 表/ 连接/ 处理/ 性能/ ./ 关键词/ 分布式/ 连接/ ;/ 增量/ 数据/ ;/ 并行处理/ ;/ 排序/ 归并/ 连接/ 1/ 引言/ 随着/ 大/ 数据/ 时代/ 的/ 到来/ ,/ 如何/ 更好/ 地/ 管理/ 和/ 利用/ 大/ 数据/ 已经/ 成为/ 普遍/ 关注/ 的/ 话题/ ./ 在/ 2008/ 年/ ,/ 《/ Nature/ 》/ 推出/ 了/ BigData/ 专刊/ ①/ ;/ 2011/ 年/ 2/ 月/ ,/ 《/ Science/ 》/ 也/ 接着/ 推出/ 专刊/ :/ DealingwithData/ ②/ ./ 美国/ 奥巴马/ 政府/ 在/ 2012/ 年/ 提出/ 了/ “/ 大/ 数据/ 研究/ 和/ 发展/ 倡议/ ”/ ,/ 共/ 投资/ 了/ 2/ 亿美元/ ,/ 正式/ 开始/ “/ 大/ 数据/ 发展/ 计划/ ”/ ,/ 并/ 计划/ 利用/ 大/ 数据/ 技术/ 实现/ 在/ 科学研究/ 、/ 生物医学/ 、/ 环境/ 等/ 领域/ 的/ 突破/ ./ 当/ 数据/ 的/ 规模/ 达到/ PB/ 、/ EB/ 或/ ZB/ 的/ 时候/ ,/ 传统/ 关系/ 型/ 数据库/ 将/ 面临/ 极大/ 的/ 考验/ ./ 所以/ 近几年/ NoSQL/ [/ 1/ ]/ 数据库/ 得到/ 了/ 迅速/ 的/ 发展/ ,/ 比如/ HBase/ [/ 2/ ]/ ,/ MongoDB/ [/ 3/ ]/ 等/ ,/ 这些/ 数据库/ 解决/ 了/ 大规模/ 数据/ 集合/ 多重/ 数据/ 种类/ 带来/ 的/ 挑战/ ,/ 攻克/ 了/ 一些/ 大/ 数据/ 应用/ 难题/ ./ 但是/ NoSQL/ 数据库/ 的/ 数据模型/ 比较简单/ ,/ 以/ 牺牲/ 数据库/ 的/ 高度/ 数据/ 一致性/ 实现/ 更/ 高/ 的/ 数据库/ 性能/ ./ 因此/ 对于/ 数据/ 一致性/ 要求/ 高/ 的/ 应用/ 来说/ ,/ 传统/ 的/ 分布式/ 关系数据库/ 模型/ 是/ 一个/ 更好/ 的/ 选择/ ./ 例如/ 谷歌/ 公司/ 最新/ 公开/ 的/ 分布式/ 关系/ 型/ 数据库/ F1/ ,/ 由前/ Facebook/ 工程师/ 创办/ 的/ 号称/ 世界/ 上/ 最快/ 的/ 分布式/ 关系/ 型/ 数据库/ MemSQL/ ,/ 还有/ 已经/ 全面/ 支撑/ 支付宝/ 业务/ 的/ 分布式/ 关系/ 型/ 数据库/ OceanBase/ [/ 4/ ]/ ./ 这些/ 数据库/ 在/ 一定/ 程度/ 上/ 解决/ 了/ 工业/ 上/ 对/ 数据库/ 的/ 需求/ ./ 连接/ 操作/ 是/ 关系/ 型/ 数据库/ 最/ 重要/ 的/ 数据分析/ 操作/ 之一/ ./ 以/ 某/ 国有银行/ 历史/ 库/ 交易/ 为例/ ,/ 所有/ 的/ 查询/ SQL/ 中/ 单表/ 查询/ 占/ 11.3/ %/ ,/ 两张/ 表/ 连接/ 的/ 查询/ 占/ 65.2/ %/ ,/ 多表/ 连接/ 的/ 查询/ 占/ 23.5/ %/ ./ 如何/ 在/ 大/ 数据量/ 的/ 情况/ 下/ 保证/ 连接/ 操作/ 的/ 正确性/ 与/ 实时性/ 是/ 一个/ 很难/ 解决/ 的/ 技术/ ./ 这一/ 问题/ 对/ 具有/ 基线/ 数据/ 和/ 增量/ 数据/ 分离/ 架构/ 的/ 数据库/ 来说/ 更为/ 突出/ ./ 对于/ 该/ 架构/ 的/ 数据库/ 来说/ ,/ 基线/ 数据/ 是/ 存储/ 在/ 磁盘/ 上/ 的/ 数据/ ,/ 增量/ 数据/ 采用/ 类似/ 于/ Log/ -/ StructuredMergeTree/ [/ 5/ ]/ 的/ 架构/ ,/ 在/ 内存/ 中/ 存储/ 一段时间/ 内/ 对/ 数据库/ 的/ 修改/ 数据/ ,/ 当/ 修改/ 增量/ 到达/ 一定/ 大/ 小时/ ,/ 增量/ 数据/ 会/ 被/ 物化/ 到/ 磁盘/ 上/ ./ 与/ 很多/ 基于/ Log/ -/ StructuredMergeTree/ 架构/ 的/ 数据库/ (/ 例如/ LevelDB/ ,/ HBase/ ,/ Cassandra/ 等/ )/ 相似/ ,/ 这种/ 架构/ 的/ 数据库/ 能够/ 极大地提高/ 事务/ 的/ 处理/ 性能/ ,/ 并且/ 具有/ 良好/ 的/ 可扩展性/ ./ 但是/ 它/ 的/ 缺点/ 是/ 在/ 做/ 连接/ 操作/ 之前/ 必须/ 先/ 把/ 基线/ 数据/ 和/ 增量/ 数据/ 合并/ ,/ 这/ 通常/ 会/ 导致/ 连接/ 操作/ 的/ 效率/ 低下/ ./ OceanBase/ 就是/ 典型/ 的/ 基线/ 与/ 增量/ 分离/ 架构/ 的/ 分布式/ 关系数据库/ ,/ 在/ 超大/ 表做/ 连接/ 的/ 情况/ 下/ ,/ OceanBase/ 的/ 处理/ 时间/ 是/ 在/ 分钟/ 级别/ 的/ ./ 对于/ 一个/ 实时/ 的/ 系统/ 来说/ ,/ 这/ 显然/ 是/ 不能/ 接受/ 的/ ./ 可以/ 看出/ ,/ 基线/ 与/ 增量/ 数据/ 分离/ 架构/ 的/ 数据库/ 具有/ 以下/ 缺点/ :/ (/ 1/ )/ 查询处理/ 效率/ 低下/ ,/ 每次/ 查询/ 前/ 都/ 要/ 先/ 将/ 增量/ 数据/ 和/ 基线/ 数据/ 合并/ ;/ (/ 2/ )/ 数据/ 模式/ 复杂/ ,/ 有/ 的/ 数据/ 在/ 内存/ 中/ ,/ 有/ 的/ 数据/ 在/ 磁盘/ 中/ ,/ 并且/ 由于/ 数据分布/ 在/ 不同/ 的/ 机器/ 上/ ,/ 导致/ 处理/ 数据/ 时/ 产生/ 了/ 很多/ 额外/ 的/ 开销/ ;/ (/ 3/ )/ 网络/ 负载/ 远大于/ 传统/ 的/ 数据库/ ./ 以上/ 3/ 个/ 缺点/ 导致/ 了/ 在/ 该/ 架构/ 下/ ,/ 连接/ 操作/ 的/ 效率/ 非常/ 低下/ ./ 针对/ 这一/ 问题/ ,/ 本文/ 提出/ 了/ 一种/ 分布式/ 连接/ 算法/ ,/ 该/ 算法/ 基于/ MapReduce/ 框架/ ,/ 将/ 基线/ 数据/ 和/ 增量/ 数据/ 同时/ 分发/ 到/ 多个/ 节点/ ,/ 每个/ 节点/ 内先/ 不/ 合并/ 数据/ ,/ 而是/ 对/ 增量/ 数据/ 和/ 基线/ 数据/ 并行/ 的/ 做/ 排序/ 归并/ 连接/ ./ 该/ 算法/ 有/ 以下/ 贡献/ :/ (/ 1/ )/ 解决/ 了/ 在/ 基线/ 与/ 增量/ 数据/ 分离/ 架构/ 下/ 连接/ 效率/ 低下/ 的/ 问题/ ;/ (/ 2/ )/ 提供/ 了/ 一种/ 如何/ 在/ 该/ 架构/ 下/ 避免/ 在/ 连接/ 前先/ 合并/ 数据/ 的/ 思路/ ;/ (/ 3/ )/ 在/ 开源/ 的/ 数据库/ OceanBase/ 上/ 实现/ 了/ 该/ 算法/ ,/ 并/ 通过/ 一系列/ 测试/ 证明/ 该/ 算法/ 的/ 正确性/ 和/ 高效率/ ./ 本文/ 第/ 2/ 节/ 介绍/ 3/ 种/ 基本/ 的/ 连接/ 算法/ 的/ 实现/ 以及/ 优化/ ;/ 第/ 3/ 节/ 形式化/ 定义/ 了/ 该/ 算法/ 所/ 解决/ 的/ 问题/ ;/ 第/ 4/ 节/ 介绍/ 算法/ 在/ 开源/ 数据库/ OceanBase/ 上/ 的/ 详细/ 实现/ ;/ 第/ 5/ 节/ 分析/ 该/ 算法/ 的/ 正确性/ 和/ 算法/ 效率/ ;/ 第/ 6/ 节/ 补充/ 算法/ 实现/ 过程/ 中/ 对/ 增量/ 数据/ 的/ 一些/ 特殊/ 处理/ ;/ 第/ 7/ 节/ 通过/ 一系列/ 实验/ 结果/ 验证/ 算法/ 的/ 效率/ ;/ 第/ 8/ 节/ 总结/ 本文/ 所/ 做/ 的/ 工作/ 以及/ 未来/ 研究/ 的/ 方向/ ./ 2/ 相关/ 工作/ 传统/ 的/ 连接/ 算法/ 主要/ 有/ 3/ 种/ :/ 嵌套循环/ 连接/ 、/ 哈希/ 连接/ 、/ 排序/ 归并/ 连接/ ./ 这/ 3/ 种/ 算法/ 有着/ 各自/ 的/ 特色/ ,/ 随着/ 数据库/ 技术/ 的/ 发展/ ,/ 对/ 这/ 3/ 种/ 算法/ 的/ 优化/ 也/ 有/ 很多/ ./ 下面/ 简要/ 介绍/ 一下/ 这/ 3/ 种/ 算法/ ./ 2.1/ 嵌套循环/ 连接/ 嵌套循环/ 连接/ (/ NestedLoopJoin/ )/ 是/ 一种/ 相对/ 稳定/ 、/ 简单/ 的/ 表/ 连接/ 方法/ ./ 它/ 使用/ 两层/ 嵌套循环/ 即外/ ①/ ②/ Page3/ 层/ 循环/ 和/ 内层/ 循环/ ,/ 从而/ 得到/ 最终/ 的/ 连接/ 结果/ 集/ ./ 在/ 处理/ 一些/ 选择性/ 强/ 、/ 约束性/ 高/ ,/ 并且/ 最终/ 结果/ 集较/ 小/ 的/ 查询/ 时/ ,/ 嵌套循环/ 连接/ 能够/ 显示/ 出较/ 高/ 的/ 性能/ ./ 嵌套循环/ 连接/ 由/ 驱动/ 表/ 和/ 被/ 驱动/ 表/ 循环/ 比较/ 得到/ 连接/ 结果/ ,/ 当/ 驱动/ 表/ 的/ 记录/ 较/ 少/ ,/ 被/ 驱动/ 表/ 连接/ 列/ 有/ 唯一/ 索引/ 时/ ,/ 两张/ 表/ 记录/ 比较/ 的/ 次数/ 会/ 较/ 少/ ,/ 所以/ 嵌套循环/ 连接/ 的/ 效率/ 变得/ 很/ 高/ ./ 当/ 使用/ 了/ 嵌套循环/ 后/ ,/ 数据库/ 不/ 需要/ 等到/ 全部/ 循环/ 结束/ 再/ 返回/ 结果/ 集/ ,/ 而是/ 可以/ 不断/ 地/ 将/ 查询/ 出来/ 的/ 局部/ 结果/ 集/ 返回/ ,/ 所以/ 嵌套循环/ 连接/ 在/ 返回/ 前/ 几行/ 的/ 记录/ 方面/ 上/ 是/ 非常/ 快/ 的/ ./ 但是/ ,/ 当/ 驱动/ 表/ 的/ 记录/ 很多/ ,/ 或者/ 是/ 被/ 驱动/ 表/ 的/ 连接/ 列/ 上/ 没有/ 索引/ 时/ ,/ 两张/ 表/ 循环/ 比较/ 的/ 时间/ 变/ 长/ ,/ 从而/ 导致/ 嵌套循环/ 连接/ 的/ 效率/ 变得/ 十分/ 低下/ ./ 在/ 共享内存/ 架构/ 中/ ,/ 减少/ 高速缓存/ 缺失/ 和/ 充分利用/ SIMD/ 技术/ 是/ 提升/ 嵌套循环/ 连接/ 算法/ 性能/ 的/ 两种/ 手段/ ./ Zhou/ 和/ Ross/ [/ 6/ ]/ 提出/ 了/ 利用/ SIMD/ 技术/ 优化/ 嵌套循环/ 连接/ 的/ 3/ 种/ 方式/ :/ 复制/ 外层/ 循环/ 、/ 复制/ 内层/ 循环/ 和/ 旋转/ 方式/ ./ 而/ Shatdal/ 等/ 人/ [/ 7/ ]/ 提出/ 了/ 基于/ 块/ 的/ 处理/ 方式/ ,/ 使得/ 连接/ 时/ 高速缓存/ 缺失/ 尽量少/ ./ 在/ 无/ 共享/ 架构/ 下/ ,/ 通常/ 采用/ 复制/ 分片/ 将/ 一张/ 表/ 的/ 数据/ 复制到/ 所有/ 节点/ 上/ ,/ Hadoop/ 框架/ [/ 8/ ]/ 中/ 采用/ 分布式/ 缓存/ ,/ Spark/ 框架/ [/ 9/ ]/ 中则/ 采用/ 广播/ 变量/ ./ 2.2/ 哈希/ 连接/ 哈希/ 连接/ 由/ 构建/ 阶段/ 和/ 探测/ 阶段/ 两个/ 阶段/ 组成/ ./ (/ 1/ )/ 构建/ 阶段/ :/ 选择/ 一张/ 小表/ 作为/ 驱动/ 表/ ,/ 使用/ 特定/ 的/ 哈希/ 函数/ 计算/ 连接/ 列/ 的/ 值/ ,/ 最终/ 产生/ 一张/ 哈希/ 表/ ./ 由于/ 计算/ 是/ 在/ 内存/ 里面/ 进行/ 的/ ,/ 因此/ 该/ 阶段/ 的/ 时间/ 较/ 短/ ./ (/ 2/ )/ 探测/ 阶段/ :/ 使用/ 相同/ 的/ 哈希/ 函数/ 计算/ 被/ 驱动/ 表/ 的/ 连接/ 列上/ 的/ 值/ ,/ 将/ 计算/ 的/ 结果/ 与/ 第/ 1/ 阶段/ 形成/ 的/ 哈希/ 表/ 进行/ 探测/ ,/ 并/ 返回/ 符合条件/ 的/ 记录/ ./ 当/ 被/ 驱动/ 表/ 和/ 驱动/ 表/ 的/ 某些/ 记录/ 在/ 连接/ 列上/ 的/ 值/ 不/ 相等/ 时/ ,/ 这些/ 记录/ 会/ 在/ 探测/ 阶段/ 被/ 丢弃/ ./ 在/ 大/ 数据量/ 时/ ,/ 哈希/ 连接/ 只会用/ 小表/ 的/ 连接/ 列/ 构建/ 一个/ 哈希/ 表/ ,/ 所用/ 内存/ 不/ 多/ ,/ 不会/ 发生/ 排序/ 溢出/ ./ 所以/ 在/ 大/ 数据量/ 时/ ,/ 采用/ 哈希/ 连接/ 会/ 更好/ ./ 但/ 由于/ 哈希/ 算法/ 所/ 特有/ 的/ 特点/ ,/ 哈希/ 连接/ 只/ 适用/ 于/ 等值/ 连接/ ./ 多/ 核大/ 内存/ 计算环境/ 成/ 了/ 哈希/ 连接/ 的/ 一个/ 优化/ 的/ 新/ 切入点/ ./ Boncz/ 等/ 人/ [/ 10/ ]/ 中/ 提出/ 的/ radix/ 连接/ 算法/ 就是/ 充分利用/ 了/ 硬件/ 特征/ ,/ 极大/ 地/ 优化/ 了/ 连接/ 算法/ 在/ 内存/ 中/ 的/ Cache/ 缺失/ 和/ TLB/ 缺失/ ./ 但是/ ,/ Blanas/ 和/ Patel/ 在/ 文献/ [/ 11/ ]/ 中/ 提到/ ,/ radix/ 算法/ 的/ 连接/ 效率/ 与/ 数据/ 在/ 内存/ 中/ 并且/ 没有/ 分区/ 阶段/ 的/ 哈希/ 连接/ 算法/ 相比/ ,/ 并/ 没有/ 显著/ 的/ 提高/ ,/ 因为/ 在/ 没有/ 分区/ 阶段/ 时/ ,/ 该/ 算法/ 能/ 充分利用/ 硬件/ 的/ 预取/ 而/ 提高/ 一定/ 的/ 效率/ ./ 然而/ ,/ Balkesen/ 等/ 人/ [/ 12/ ]/ 通过/ 论文/ 实验/ 证明/ :/ 即使/ 是/ 无/ 分区/ 阶段/ 的/ 连接/ 算法/ ,/ 性能/ 上/ 还是/ 比不上/ radix/ 连接/ 算法/ ./ 他/ 指出/ Blanas/ 只是/ 利用/ 小表/ 建立/ 哈希/ 表/ ,/ 因此/ 减少/ 了/ 分区/ 阶段/ 在/ 连接/ 算法/ 中/ 的/ 占/ 比/ ,/ 明显/ 低估/ 了/ radix/ 连接/ 的/ 整体/ 性能/ ./ 2.3/ 排序/ 归并/ 连接/ 排序/ 归并/ 连接/ 指/ 的/ 是/ 两个/ 表/ 连接/ 时/ ,/ 先/ 通过/ 连接/ 列/ 排序/ 后/ ,/ 再/ 通过/ 合并/ 操作/ 来/ 得到/ 最后/ 返回/ 的/ 结果/ 集/ 的/ 方法/ ./ 在/ 对/ 排序/ 归并/ 算法/ 的/ 研究/ 中/ ,/ Kim/ 等/ 人/ [/ 13/ ]/ 指出/ ,/ 排序/ 归并/ 连接/ 的/ 效率/ 与/ SIMD/ 宽度/ 相关/ ,/ 当/ 宽度/ 超过/ 256/ 位/ 的/ 时候/ ,/ 排序/ 归并/ 连接/ 的/ 性能/ 能够/ 超过/ 哈希/ 连接/ ./ 而/ Albutiu/ 等/ 人/ [/ 14/ ]/ 提出/ 的/ MPSM/ 并行/ 排序/ 归并/ 算法/ 则/ 充分考虑/ 了/ NUMA/ 架构/ ,/ 他/ 强调/ MPSM/ 算法/ 能够/ 超过/ 哈希/ 连接/ 算法/ 的/ 性能/ ,/ 即使/ 在/ 没有/ SIMD/ 的/ 支持/ 下/ ./ 2.4/ 分布式计算/ 在/ NoSQL/ 领域/ ,/ 基于/ Spark/ 内核/ 的/ 数据仓库/ 基础架构/ Shark/ [/ 15/ ]/ 对/ 连接/ 性能/ 做/ 了/ 很大/ 的/ 优化/ ./ Shark/ 中有/ 两种/ 分布式/ 连接/ 算法/ ,/ 分别/ 为/ map/ 连接/ ,/ shuffle/ 连接/ ./ map/ 连接/ 的/ 思路/ 是/ 将/ 小表/ 的/ 全部/ 数据/ 广播/ 传输/ 到/ 所有/ 含有/ 大表/ 分区/ 数据/ 的/ 节点/ 上/ ,/ 每个/ 节点/ 并行/ 做/ 连接/ ./ shuffle/ 连接/ 的/ 核心/ 是/ 将/ 两个/ 表/ 的/ 记录/ 都/ 按照/ 相同/ 的/ 哈希/ 函数/ 在/ 连接/ 属性/ 上/ 进行/ 切分/ ,/ 最后/ 在/ 切分/ 后/ 的/ 第/ 3/ 批/ 节点/ 上/ 并行/ 地/ 做/ 连接/ 操作/ ./ 对于/ 基线/ 与/ 增量/ 数据/ 分离/ 架构/ 的/ 数据库/ 来说/ ,/ 优化/ 连接/ 性能/ 显得/ 更加/ 复杂/ ./ 以/ HBase/ 为例/ ,/ HBase/ 不能/ 支持/ where/ 条件/ ,/ orderby/ 查询/ ,/ 只能/ 按照/ 主键/ 和/ 主键/ 的/ range/ 来/ 查询/ ./ 但是/ 可以/ 通过/ 将/ Hive/ 和/ HBase/ 结合/ ,/ 使用/ Hive/ 提供/ 的/ HQL/ 语言/ 实现/ HBase/ 大表/ 连接/ 查询/ ,/ 同时/ 使用/ 底层/ 的/ MapReduce/ 计算/ 框架/ 处理/ 连接/ 查询/ 任务/ ,/ 将/ 满足条件/ 的/ 结果/ 存放/ 在/ HBase/ 表中/ ./ 虽然/ 有/ 很多/ 对/ 连接/ 算法/ 的/ 优化/ ,/ 但是/ 大部分/ 优化/ 算法/ 都/ 没有/ 考虑/ 到/ 基线/ 数据/ 与/ 增量/ 数据/ 分离/ 的/ 情况/ ./ 本文/ 提出/ 的/ 算法/ 本质/ 上/ 是/ shuffle/ 连接/ ,/ 但是/ 在/ 连接/ 之前/ 没有/ 把/ 所有/ 的/ 基线/ 数据/ 和/ 增量/ 数据/ 都/ 合并/ ,/ 而是/ 对/ 基线/ 数据/ 和/ 增量/ 数据/ 并行处理/ ,/ 减少/ 了/ 数据/ 的/ 交互/ ,/ 同时/ 也/ 保证/ 了/ 数据/ 的/ 正确性/ ./ 3/ 问题/ 定义/ 互联网/ 企业/ 的/ 很多/ 应用/ 都/ 有/ 这样/ 一个/ 特点/ :/ 数/ Page4/ 据/ 的/ 总量/ 很大/ ,/ 但是/ 一段时间/ 内/ 的/ 修改/ 增量/ 相对/ 很小/ ./ 这种/ 情况/ 下/ ,/ 基线/ 与/ 增量/ 分离/ 架构/ 的/ 数据库/ 是/ 很/ 好/ 的/ 选择/ ./ 这类/ 数据库/ 的/ 设计/ 思路/ 在/ 很/ 早就/ 已经/ 被/ 提出/ 了/ ,/ 例如/ 谷歌/ 的/ BigTable/ [/ 16/ ]/ ./ 对于/ BigTable/ 来说/ ,/ 每/ 一个/ 节点/ 有/ 一个/ memtable/ ,/ 当该/ 节点/ 接收/ 到/ 一个/ 写/ 请求/ ,/ 它会/ 将/ 数据/ 写/ 到/ 内存/ 中/ 的/ memtable/ 里/ 去/ ./ 当/ memtable/ 成长/ 到/ 一定/ 规模/ 会/ 被/ 冻结/ ,/ 冻结/ 的/ memtable/ 会/ 转换成/ SSTable/ 形式/ 写入/ GFS/ ./ 当该/ 节点/ 接收/ 到/ 一个/ 读/ 请求/ ,/ 这个/ 读/ 操作/ 会/ 查看/ 所有/ SSTable/ 文件/ 和/ memtable/ 的/ 合并/ 视图/ ./ 在/ 国内/ 对/ 数据库/ 的/ 研究/ 中/ ,/ OceanBase/ 是/ 最/ 典型/ 的/ 基线/ 与/ 增量/ 分离/ 的/ 数据库/ ./ OceanBase/ 是/ 阿里巴巴/ 研发/ 的/ 可/ 扩展/ 型/ 关系数据库/ ,/ 它/ 以/ 成本低/ ,/ 高/ 可扩展性/ ,/ 高可用性/ 和/ 高可靠性/ 著称/ ./ 现已/ 支持/ 了/ 阿里/ 集团/ 包括/ 支付宝/ 在内/ 的/ 许多/ 业务/ ./ OceanBase/ 的/ 实现/ 借鉴/ 了/ BigTable/ 的/ 思路/ ,/ 但/ 又/ 有/ 一些/ 自己/ 的/ 改动/ ./ 它/ 的/ 基线/ 数据/ 分布式/ 地/ 存在/ 多台/ 机器/ 上/ ,/ 这些/ 机器/ 被/ 称为/ ChunkServer/ (/ CS/ )/ ./ 而/ 它/ 的/ 所有/ 的/ 增量/ 数据/ 集中/ 的/ 存在/ 一台/ 机器/ 上/ ,/ 这台/ 机器/ 被/ 称为/ UpdateServer/ (/ UPS/ )/ ./ 如图/ 1/ ./ 在/ 基线/ 与/ 增量/ 分离/ 的/ 架构/ 下/ ,/ 事务处理/ 的/ 速度/ 明显/ 加快/ ,/ 但/ 查询处理/ 方面/ ,/ 尤其/ 是/ 对/ 连接/ 操作/ 的/ 处理/ ,/ 还是/ 存在/ 很大/ 问题/ 的/ :/ (/ 1/ )/ 对于/ 读/ 请求/ 来说/ ,/ 每次/ 读/ 操作/ 都/ 要/ 做/ 一次/ 基线/ 数据/ 与/ 增量/ 数据/ 的/ 合并/ ,/ 由于/ 基线/ 数据/ 和/ 增量/ 数据/ 在/ 不同/ 的/ 机器/ 上/ ,/ 每次/ 合并/ 都/ 要/ 有/ 网络/ 的/ 开销/ ./ 在/ 查询/ 的/ 数据量/ 很少/ 的/ 时候/ ,/ 这/ 对/ 查询/ 性能/ 的/ 影响/ 不是/ 很大/ ,/ 但是/ 当表/ 的/ 数据/ 上/ 千万/ 或者/ 上/ 亿行/ 的/ 时候/ ,/ 每/ 一行/ 都/ 要/ 做/ 一次/ 基线/ 数据/ 与/ 增量/ 数据/ 的/ 合并/ ,/ 这/ 中间/ 的/ 网络/ 开销/ 是/ 非常/ 大/ 的/ ;/ (/ 2/ )/ 在/ 连接/ 算法/ 的/ 选择/ 上/ ,/ 大多数/ 数据库/ 采用/ 的/ 是/ 排序/ 归并/ 连接/ 算法/ ./ 传统/ 的/ 实现/ 是/ 先/ 把/ 各个/ 表/ 的/ 基线/ 数据/ 和/ 增量/ 数据/ 合并/ ,/ 然后/ 把/ 各个/ 表/ 合并/ 后/ 的/ 数据/ 串行/ 发送到/ 一台/ 主/ 节点/ 上面/ ,/ 再/ 在/ 该主/ 节点/ 的/ 内存/ 里/ 对/ 各个/ 表/ 的/ 数据/ 排序/ ,/ 最后/ 对排/ 完序/ 的/ 结果/ 做/ 归并/ 连接/ ./ 这种/ 实现/ 方式/ 的/ 优点/ 是/ 简单/ 、/ 稳定/ ./ 缺点/ 是/ 性能/ 太差/ 了/ ,/ 连接/ 的/ 处理/ 时间/ 过长/ ,/ 无法/ 支持/ 对/ 实时性/ 要求/ 高/ 的/ 系统/ ./ 针对/ 以上/ 两个/ 问题/ ,/ 本文/ 提出/ 了/ 一种/ 在/ 基线/ 与/ 增量/ 分离/ 架构/ 下/ 对/ 连接/ 操作/ 的/ 优化/ 算法/ ./ 由于/ 算法/ 在/ 开源/ 数据库/ OceanBase/ 上/ 做/ 了/ 实现/ ,/ 为了/ 更/ 直观/ 的/ 介绍/ 该/ 算法/ ,/ 本文/ 在/ 这里/ 对/ 问题/ 进行/ 一些/ 形式化/ 定义/ :/ (/ 1/ )/ OceanBase/ 集群/ ./ 现有/ 一个/ 集群/ ,/ 集群/ 有/ n/ 台/ 机器/ ./ 节点/ M/ 代表/ MergeServer/ ,/ 节点/ U/ 代表/ UpdateServer/ ,/ 节点/ Ci/ 至/ 节点/ Cj/ 代表/ ChunkServer/ ./ 其中/ ,/ 节点/ U/ 集中/ 的/ 存储/ 所有/ 的/ 增量/ 数据/ ,/ 节点/ Ci/ 至/ 节点/ Cj/ 分布式/ 的/ 存储/ 基线/ 数据/ ./ (/ 2/ )/ 数据分布/ ./ 现有/ R/ 表/ 和/ S/ 表在/ 属性/ a/ 上面/ 做/ 自然/ 连接/ ./ R/ 表/ 的/ 增量/ 数据/ 全部/ 存在/ 节点/ U/ 上面/ ./ R/ 表/ 的/ 基线/ 数据/ 共有/ m/ 个/ tablet/ :/ R1/ ,/ R2/ ,/ …/ ,/ Rm/ ,/ 分别/ 存在/ 节点/ Ci/ 至/ 节点/ Cj/ 上面/ ./ S/ 表/ 的/ 增量/ 数据/ 全部/ 存在/ 节点/ U/ 上面/ ./ S/ 表/ 的/ 基线/ 数据/ 共有/ m/ 个/ tablet/ :/ S1/ ,/ S2/ ,/ …/ ,/ Sm/ ,/ 也/ 分别/ 存在/ 节点/ Ci/ 至/ 节点/ Cj/ 上面/ ./ (/ 3/ )/ 连接/ 操作/ ./ 由于/ 篇幅/ 所/ 限/ ,/ 本文/ 只/ 介绍/ 自然/ 连接/ 下/ 算法/ 的/ 实现/ ,/ 现有/ R/ 表/ 和/ S/ 表在/ 连接/ 属性/ a/ 上/ 做/ 自然/ 连接/ :/ select/ / fromRinnerjoinSonR/ ./ a/ =/ S/ ./ a/ ;/ (/ 4/ )/ 连接/ 结果/ ./ 将/ 满足条件/ 的/ R/ 表/ 和/ S/ 表/ 的/ 数据/ 返回/ 给/ 节点/ M/ ./ 节点/ M/ 再/ 将/ 结果/ 返回/ 给/ 客户端/ ./ 4/ 算法/ 介绍/ 算法/ 基于/ MapReduce/ [/ 17/ ]/ 框架/ ,/ 在/ 多个/ 节点/ 上/ 并行/ 地/ 做/ 排序/ 归并/ 连接/ ./ 首先/ 对/ 连接/ 属性/ 做/ 范围/ (/ range/ )/ 切分/ ,/ 为/ 每个/ 节点/ 分配/ 一个/ 范围/ ./ 其次/ 在/ 多个/ 节点/ 之间/ 做/ 基线/ 数据/ 混洗/ (/ shuffle/ )/ ,/ 将/ 连接/ 属性/ 值/ 在/ 同一/ 范围/ 的/ 记录/ 传输/ 到/ 相同/ 的/ 节点/ 上/ ,/ 同时/ 根据/ 连接/ 属性/ 范围/ 信息/ 对/ 增量/ 数据/ 做/ 切分/ ,/ 将/ 一个/ 范围/ 内/ 的/ 所有/ 增量/ 数据/ 发送到/ 该/ 范围/ 对应/ 的/ 节点/ 上/ ./ 最后/ 在/ 每个/ 节点/ 上/ 并行/ 地/ 做/ 排序/ 归并/ 连接/ ,/ 并/ 将/ 连接/ 的/ 结果/ 发送给/ 主/ 节点/ ./ 4.1/ 算法/ 实现/ 由于/ OceanBase/ 是/ 国内/ 著名/ 的/ 基于/ 基线/ 与/ 增量/ 分离/ 的/ 分布式/ 数据库/ ,/ 并且/ 已经/ 在/ 阿里巴巴公司/ 的/ 很多/ 线上/ 系统/ 得到/ 了/ 应用/ ./ 所以/ 从/ 实用性/ 上/ 考虑/ ,/ 算/ Page5/ 法在/ 开源/ 的/ 数据库/ OceanBase/ 上/ 做/ 了/ 实现/ ./ Ocean/ -/ Base/ 的/ 基线/ 数据/ 是/ 分布式/ 存储/ 的/ ,/ 每/ 一台/ 存储/ 基线/ 数据/ 的/ 机器/ 叫做/ ChunkServer/ ./ 它/ 的/ 增量/ 数据/ 是/ 集中式/ 存储/ 在/ 一台/ 机器/ 上/ ,/ 该/ 机器/ 叫做/ UpdateServer/ ./ 算法/ 中/ 还有/ 一个/ 主/ 节点/ 的/ 角色/ ,/ 负责/ 发送/ 请求/ 和/ 合并/ 子/ 节点/ 返回/ 的/ 连接/ 结果/ ./ 在/ OceanBase/ 中/ ,/ MergeServer/ 充当/ 主/ 节点/ 角色/ ./ 根据/ 第/ 3/ 部分/ 的/ 问题/ 定义/ ,/ 算法/ 实际/ 分为/ 5/ 个/ 阶段/ ,/ 具体/ 流程/ 如图/ 2/ 所示/ ./ (/ 1/ )/ 并行/ 统计/ 各个/ ChunkServer/ 上面/ 两张/ 表在/ 连接/ 属性/ a/ 上/ 的/ 数据分布/ ,/ 并/ 将/ 各个/ 节点/ 上/ 的/ 数据分布/ 信息/ 统一/ 发送到/ 一台/ MergeServer/ 上面/ ./ 由于/ ChunkServer/ 存/ 的/ 数据/ 只是/ 基线/ 数据/ ,/ 想要/ 得到/ 正确/ 的/ 连接/ 属性/ a/ 上/ 的/ 数据分布/ ,/ 还/ 需要/ 获得/ 增量/ 数据/ 中/ 连接/ 属性/ a/ 上/ 的/ 数据分布/ 信息/ ;/ (/ 2/ )/ MergeServer/ 根据/ 每个/ ChunkServer/ 传输/ 来/ 的/ a/ 的/ 统计/ 信息/ ,/ 对/ 连接/ 属性/ a/ 进行/ 范围/ 划分/ ,/ 每个/ ChunkServer/ 对应/ 一个/ 范围/ ./ 并/ 把/ 范围/ 划分/ 的/ 结果/ 发送给/ 所有/ 的/ ChunkServer/ 以及/ UpdateServer/ ;/ (/ 3/ )/ 各个/ ChunkServer/ 之间/ 做/ 数据/ 的/ 交互/ ,/ 最终/ 每个/ ChunkServer/ 都/ 得到/ 了/ 对应/ 的/ 连接/ 属性/ 范围/ 内里/ 的/ R/ 表/ 和/ S/ 表/ 的/ 基线/ 数据/ ./ 同时/ ,/ UpdateServer/ 也/ 根据/ 连接/ 属性/ 的/ 范围/ 信息/ ,/ 将/ 相应/ 的/ 增量/ 数据/ 发送到/ 相应/ 的/ ChunkServer/ 上面/ 去/ ;/ (/ 4/ )/ 每个/ ChunkServer/ 都/ 获得/ 了/ 自己/ 对应/ 的/ 连接/ 属性/ 范围/ 上/ 的/ 4/ 个/ 部分/ 数据/ :/ R/ 表/ 的/ 基线/ 数据/ 和/ 增量/ 数据/ ,/ S/ 表/ 的/ 基线/ 数据/ 和/ 增量/ 数据/ ./ 所有/ 的/ ChunkServer/ 并行/ 地/ 对/ 自己/ 的/ 4/ 个/ 部分/ 数据/ 做/ 排序/ 归并/ 连接/ ,/ 并/ 将/ 连接/ 的/ 结果/ 发送给/ MergeServer/ ;/ (/ 5/ )/ MergeServer/ 整合/ 所有/ 的/ ChunkServer/ 发送/ 过来/ 的/ 合并/ 的/ 结果/ ,/ 并/ 将/ 结果/ 返回/ 给/ 客户端/ ./ 4.2/ 统计/ 信息/ 计算/ 在/ 算法/ 的/ 开始/ 阶段/ ,/ 主/ 节点/ 向/ 各个/ ChunkServer/ 发送/ 计算/ 统计/ 信息/ 的/ 请求/ ,/ 也/ 会/ 同时/ 把/ R/ 表/ 和/ S/ 表在/ 各个/ ChunkServer/ 上/ 的/ 数据分布/ 信息/ 发送给/ UpdateServer/ ./ 这里/ 的/ 数据分布/ 是/ 以/ R/ 表/ 和/ S/ 表在/ 各个/ ChunkServer/ 上/ 的/ 主键/ 范围/ 来/ 标识/ 的/ ./ 如图/ 3/ ./ 这样/ ,/ UpdateServer/ 和/ ChunkServer/ 就/ 会/ 并行/ 地/ 处理/ 请求/ ./ 首先/ 看/ ChunkServer/ 这端/ ,/ 每个/ ChunkServer/ 要/ 把/ 自己/ 在/ 相应/ 主键/ 范围/ 内/ 的/ R/ 表/ 和/ S/ 表/ 的/ 基线/ 数据/ 从/ 磁盘/ 中读/ 到/ 内存/ 里面/ ,/ 并/ 计算/ 连接/ 属性/ 上/ 的/ 统计/ 信息/ ./ 由于/ 基线/ 数据/ 是/ 以/ SSTable/ 的/ 形式/ 存储/ 的/ ,/ 一个/ SSTable/ 最大/ 为/ 256MB/ ,/ 所以/ 在/ 一个/ 主键/ 范围/ 内/ 可能/ 有/ 多个/ SSTable/ ./ 算法/ 的/ 实现/ 是/ 在/ ChunkServer/ 上/ 开启/ 一个/ 线程/ 池/ ,/ 用/ 多个/ 线程/ 并行/ 地/ 计算/ 统计/ 信息/ ./ 统计/ 信息/ 的/ 计算/ 有/ 两种/ 方法/ :/ 抽样/ 统计/ 和/ 直方图/ 统计/ ./ 前者/ 扫描/ 的/ 数据/ 少/ ,/ 速度/ 快/ ,/ 但/ 后者/ 比/ 前者/ 更/ 精确/ ./ 这里/ 由于/ 数据/ 已经/ 被/ 读/ 到/ 内存/ 中/ 并且/ 是/ 多线程/ 计算/ ,/ 所以/ 算法/ 采用/ 了/ 直方图/ 的/ 形式/ 来/ 计算/ 统计/ 信息/ ./ 每个/ ChunkServer/ 计算/ 完/ 基线/ 数据/ 的/ 统计/ 信息/ 后/ ,/ 不能/ 立刻/ 将/ 结果/ 发送给/ MergeServer/ ,/ 因为/ 还/ 需要/ 获得/ 增量/ 数据/ 的/ 统计/ 信息/ ./ 再/ 看/ UpdateServer/ 的/ 处理/ ,/ UpdateServer/ 根据/ R/ 表/ 和/ S/ 表/ 的/ 主键/ 范围/ ,/ 对/ 增量/ 数据/ 进行/ 范围/ 遍历/ ./ 增量/ 数据/ 存在/ UpdateServer/ 内存/ 中/ 的/ 数据结构/ memtable/ 里面/ ,/ memtable/ 的/ 本质/ 是/ 一个/ B/ +/ 树/ ,/ 每张/ 表/ 的/ 每/ 一个/ 主键/ 对应/ 一个/ 叶/ 节点/ ,/ 一个/ 叶/ 节点/ 指向/ 一个/ 行/ 操作/ 链表/ ,/ 链表/ 的/ 每/ 一个/ 元素/ 都/ 是/ 一个/ cell/ ,/ 记录/ 了/ 对/ 该行/ 的/ 某/ 一列/ 上/ 的/ 修改/ ./ 如图/ 4/ 所示/ ./ 算法/ 使用/ 一个/ 类似/ bitmap/ 的/ 数据结构/ 来/ 存储/ 对/ memtable/ 遍历/ 的/ 结果/ ,/ 每个/ 主键/ 对应/ 一个/ 值/ ,/ 如果/ 该行/ 上面/ 的/ 修改/ 没有/ 涉及/ 到/ 连接/ 属性/ ,/ 则/ 该行/ 对应/ 的/ 值/ 为/ 0/ ,/ 否则/ ,/ 该行/ 对应/ 的/ 值/ 为/ 1/ ,/ 并且/ 将/ 该行/ 在/ Page6/ 连接/ 属性/ 上/ 的/ 最新/ 值/ 也/ 存/ 起来/ ./ 遍历/ 结束/ 后/ ,/ UpdateServer/ 把/ 遍历/ 结果/ 发送给/ 相应/ 的/ ChunkServer/ ./ 由于/ 在/ memtable/ 中/ ,/ 只有/ 被/ 修改/ 的/ 行才/ 会/ 作为/ 叶/ 节点/ ,/ 没有/ 被/ 修改/ 的/ 行/ 不会/ 在/ memtable/ 上/ 出现/ ,/ 所以/ 最后/ 遍历/ 的/ 结果/ 不会/ 很大/ ,/ 同时/ 遍历/ 都/ 是/ 在/ 内存/ 中/ 完成/ 的/ ,/ 整体/ 速度/ 不会/ 太慢/ ./ ChunkServer/ 会/ 根据/ 接收/ 到/ 的/ UpdateServer/ 上/ 的/ 遍历/ 结果/ ,/ 对/ 基线/ 数据/ 的/ 直方图/ 进行/ 修改/ ,/ 将/ 修改/ 后/ 的/ 统计/ 信息/ 发送给/ MergeServer/ ./ 同时/ ,/ ChunkServer/ 也/ 会/ 根据/ 遍历/ 结果/ 中/ 所有/ 对应/ 的/ 值/ 为/ 1/ 的/ 主键/ ,/ 来/ 修改/ 基线/ 数据/ 中/ 的/ 对应/ 行/ ./ 如图/ 5/ 所示/ ./ 4.3/ 增量/ 数据/ 划分/ 在/ 算法/ 的/ 第/ 3/ 阶段/ 中/ ,/ UpdateServer/ 要/ 根据/ 连接/ 属性/ 的/ 范围/ 分布/ 信息/ ,/ 将/ 每个/ 连接/ 属性/ 范围/ 内/ 的/ 增量/ 数据/ 发送到/ 对应/ 的/ ChunkServer/ 上面/ 去/ ./ 但是/ 根据/ memtable/ 的/ 构造/ ,/ 有些/ 行只/ 修改/ 了/ 连接/ 属性/ 之外/ 的/ 属性/ ,/ 所以/ 这些/ 行/ 的/ 增量/ 数据/ 中/ 没有/ 连接/ 属性/ 的/ 值/ ./ 这个/ 时候/ 没有/ 办法/ 确定/ 把/ 这些/ 行/ 的/ 增量/ 数据/ 发到/ 哪个/ ChunkServer/ 上面/ 去/ ./ 基于/ 这种/ 情况/ ,/ 本文/ 提出/ 了/ “/ 最大/ 范围/ ”/ 算法/ ,/ 来/ 保证/ UpdateServer/ 发给/ ChunkServer/ 的/ 增量/ 数据/ 包含/ 了/ 该/ ChunkServer/ 在/ 自己/ 的/ 连接/ 属性/ 范围/ 上/ 的/ 所有/ 增量/ ./ 最大/ 范围/ 算法/ :/ 由于/ 每个/ ChunkServer/ 对应/ 一个/ 连接/ 属性/ 上/ 的/ 范围/ ,/ 而/ UpdateServer/ 只能/ 把/ 一个/ 主键/ 范围/ 上/ 的/ 增量/ 数据/ 发给/ ChunkServer/ ,/ 所以/ 如何/ 确定/ 这个/ 主键/ 范围/ 是/ 该/ 算法/ 的/ 核心/ ./ 最大/ 范围/ 算法/ 的/ 思路/ 是/ 由/ 各个/ ChunkServer/ 发给/ UpdateServer/ 多个/ 子/ 主键/ 范围/ ,/ UpdateServer/ 整合/ 所有/ 的/ 主键/ 范围/ ,/ 生成/ 每个/ ChunkServer/ 对应/ 的/ 最终/ 的/ 主键/ 范围/ ,/ 并/ 保证/ 该/ ChunkServer/ 对应/ 的/ 连接/ 属性/ 范围/ 上/ 的/ 所有/ 增量/ 都/ 在/ 这个/ 最终/ 主键/ 范围/ 内/ ./ 最大/ 范围/ 算法/ 分为/ 两个/ 阶段/ ./ (/ 1/ )/ 第/ 1/ 阶段/ ChunkServer/ 生成/ 多个/ 子/ 主键/ 范围/ ./ 下面/ 介绍/ 一下/ 该/ 阶段/ 的/ 伪/ 代码/ 子/ 主键/ 生成/ 伪/ 代码/ :/ 输入/ :/ data/ _/ scanner/ _/ (/ 存储/ 基线/ 数据/ )/ ,/ join/ _/ column/ _/ id/ 输出/ :/ Buffer1/ ,/ Buffer2/ ,/ …/ ,/ Buffer5/ (/ 存储/ 不同/ 范围/ 1/ ./ WHILE/ (/ 不停/ 地/ 从/ data/ _/ scanner/ _/ 中取/ 一行/ 记录/ :/ row/ )/ 2/ ./ ObObjjoin/ _/ value/ =/ row/ ./ raw/ _/ get/ _/ cell/ (/ join/ _/ column/ _/ 3/ ./ Intlocation/ =/ join/ _/ range/ _/ partition/ (/ join/ _/ value/ )/ ;/ 4/ ./ SWITCH/ (/ location/ )/ 5/ ./ Case1/ :/ 6/ ./ Buffer1/ ./ add/ _/ row/ (/ row/ )/ ;/ 7/ ./ Break/ ;/ 8/ ./ …/ 9/ ./ Case5/ :/ 10/ ./ Buffer5/ ./ add/ _/ row/ (/ row/ )/ ;/ 11/ ./ Break/ ;/ 12/ ./ RowKeyRangesub/ _/ range1/ =/ Buffer1/ ./ get/ _/ sub/ _/ join/ _/ 13/ ./ …/ 14/ ./ RowKeyRangesub/ _/ range5/ =/ Buffer5/ ./ get/ _/ sub/ _/ join/ _/ 在/ 做/ 数据/ shuffle/ 前/ ,/ 每/ 一个/ ChunkServer/ 的/ 内存/ 中/ 都/ 有/ R/ 表/ 和/ S/ 表在/ 相应/ 主键/ 范围/ 上/ 的/ 基线/ 数据/ ./ 并且/ 这些/ 基线/ 数据/ 在/ 连接/ 属性/ 上/ 的/ 值/ 都/ 是/ 最新/ 的/ (/ 上/ 文中/ 计算/ 统计/ 信息/ 的/ 时候/ 已经/ 将/ 连接/ 属性/ 上/ 的/ 增量/ 数据/ 与/ 基线/ 数据/ 合并/ 了/ )/ ./ 每个/ ChunkServer/ 同时/ 也/ 拥有/ 连接/ 属性/ 范围/ 的/ 切分/ 信息/ :/ CS1/ 对应/ [/ a/ _/ min1/ ,/ a/ _/ max1/ ]/ ,/ CS2/ 对应/ [/ a/ _/ min2/ ,/ a/ _/ max2/ ]/ ,/ CS3/ 对应/ [/ a/ _/ min3/ ,/ a/ _/ max3/ ]/ ,/ CS4/ 对应/ [/ a/ _/ min4/ ,/ a/ _/ max4/ ]/ ,/ CS5/ 对应/ [/ a/ _/ min5/ ,/ a/ _/ max5/ ]/ ./ 每个/ ChunkServer/ 在/ 做/ 数据/ Shuffle/ 之前/ 会/ 在/ 内存/ 中/ 申请/ 5/ 个/ Buffer/ :/ Buffer1/ ,/ Buffer2/ ,/ Buffer3/ ,/ Buffer4/ ,/ Buffer5/ ./ 这/ 5/ 个/ Buffer/ 分别/ 对应/ 上述/ 的/ 5/ 个/ 连接/ 属性/ 上/ 的/ range/ ./ 在/ 做/ 数据/ Shuffle/ 之前/ ,/ ChunkServer/ 会/ 遍历/ 内存/ 中/ 的/ 基线/ 数据/ (/ R/ 表/ 和/ S/ 表/ 的/ 数据/ 并行处理/ ,/ 现以/ R/ 表为例/ )/ ,/ 根据/ 每/ 一行/ 在/ 连接/ 属性/ 的/ 值/ ,/ 将/ 该行/ 追加/ 到/ 相应/ 的/ Buffer/ 里面/ ./ 如图/ 6/ 所示/ ./ 这样/ 在/ 基线/ 数据/ 遍历/ 结束/ 的/ 时候/ ,/ 5/ 个/ Buffer/ 里面/ 都/ 被/ 填充/ 了/ 很多/ 行/ ,/ 由于/ 基线/ 数据/ 是/ 按照/ 主键/ 排序/ 的/ ,/ 所以/ 此时/ 每个/ Buffer/ 中/ 的/ 数据/ 也/ 是/ 按照/ 主键/ 排序/ 的/ ./ 将/ 每个/ Buffer/ 内/ 的/ 第/ 1/ 行/ 和/ 最后/ 一/ Page7/ 图/ 6CS1/ 根据/ 连接/ 属性/ 的/ 值/ 将/ 自己/ 的/ 基线/ 数据/ 分成/ 5/ 块行/ 的/ 主键/ 取出/ 来/ ,/ 这样/ 就/ 产生/ 了/ 5/ 个子/ 主键/ 范围/ :/ [/ k/ _/ min1/ ,/ k/ _/ max1/ ]/ ,/ [/ k/ _/ min2/ ,/ k/ _/ max2/ ]/ ,/ [/ k/ _/ min3/ ,/ k/ _/ max3/ ]/ ,/ [/ k/ _/ min4/ ,/ k/ _/ max4/ ]/ ,/ [/ k/ _/ min5/ ,/ k/ _/ max5/ ]/ ./ 例如/ 对于/ Buffer1/ 来说/ ,/ 若/ Buffer1/ 内/ 存储/ 的/ 主键/ 集合/ 为/ {/ 2/ ,/ 3/ ,/ 5/ ,/ 7/ ,/ 9/ ,/ 11/ ,/ 15/ }/ ,/ 则/ Buffer1/ 生成/ 的/ 子/ 主键/ 范围/ 就是/ [/ 2/ ,/ 15/ ]/ ./ 子/ 主键/ 范围/ 生成/ 后/ ,/ 每个/ ChunkServer/ 封装/ 一个/ 特殊/ 的/ 包/ (/ SP/ )/ 发送给/ UpdateServer/ ,/ 特殊/ 包/ SP/ 里面/ 包含/ 的/ 信息/ 有/ :/ 机器/ ip/ ,/ 表/ 的/ id/ ,/ 每个/ 连接/ 属性/ 上/ 的/ range/ 对应/ 的/ 主键/ range/ ./ ChunkServer/ 发送/ 完/ SP/ 包/ 之后/ 再/ 做/ 数据/ 的/ shuffle/ ,/ 将/ Buffer/ 里/ 的/ 全部/ 数据/ 发送给/ 相应/ 的/ ChunkServer/ ./ (/ 2/ )/ 第/ 2/ 阶段/ UpdateServer/ 接收/ 到/ 了/ 所有/ ChunkServer/ 发送/ 的/ SP/ 包/ 之后/ ,/ 根据/ 连接/ 属性/ 的/ range/ ,/ 把/ 所有/ SP/ 包/ 的/ 信息/ 整合/ 起来/ ./ 如图/ 7/ 所示/ ./ 整合/ 结束/ 时/ ,/ 5/ 个/ 连接/ 属性/ 的/ range/ 分别/ 对应/ 了/ R/ 表/ 和/ S/ 表/ 的/ 5/ 个/ 最终/ 主键/ 范围/ ./ 例如/ [/ a/ _/ min1/ ,/ a/ _/ max1/ ]/ 对应/ 了/ R/ 表/ 的/ [/ e/ _/ min1/ ,/ e/ _/ max1/ ]/ 和/ S/ 表/ 的/ [/ e/ _/ min1/ ,/ e/ _/ max1/ ]/ ./ 此时/ ,/ UpdateServer/ 会/ 根据/ 这些/ 最终/ 主键/ 范围/ 遍历/ memtable/ ,/ 将/ 范围/ 内/ 的/ 增量/ 数据/ 发给/ 相应/ 的/ ChunkServer/ ./ 4.4/ 基线/ 数据/ 与/ 增量/ 数据/ 归并/ 连接/ 当/ 算法/ 进行/ 到/ 第/ 4/ 阶段/ 的/ 时候/ ,/ 每个/ Chunk/ -/ Server/ 的/ 内存/ 中/ 已经/ 有/ 了/ 4/ 块/ 数据/ ./ 对/ R/ 表/ 和/ S/ 表/ 的/ 基线/ 数据/ 做/ 归并/ 连接/ (/ 如/ 下面/ 伪/ 代码/ 所述/ )/ :/ 从/ 每张/ 表/ 的/ 基线/ 数据/ 中取/ 一行/ 记录/ 开始/ 匹配/ ,/ 如果/ 符合/ 连接/ 条件/ ,/ 则/ 根据/ 该行/ 的/ 主键/ 到/ 该表/ 的/ 增量/ 数据/ 中/ 二分/ 查找/ ,/ 如果/ 找到/ ,/ 则/ 将/ 该行/ 的/ 增量/ 数据/ 和/ 基线/ 数据/ 合并/ ,/ 并/ 把/ 合并/ 后/ 的/ 结果/ 放到/ 结果/ 集中/ ./ 如果/ 不/ 符合/ 连接/ 条件/ ,/ 则/ 将/ 连接/ 字段/ 较/ 小/ 的/ 记录/ 抛弃/ ,/ 从/ 这条/ 记录/ 对应/ 的/ 表中取/ 下/ 一条/ 记录/ 继续/ 进行/ 匹配/ ,/ 直到/ 整个/ 循环/ 结束/ ./ 如图/ 8/ 所示/ ./ 归并/ 连接/ 伪/ 代码/ :/ 输入/ :/ row/ _/ store/ _/ r/ (/ 存储/ R/ 表/ 数据/ )/ ,/ row/ _/ store/ _/ s/ (/ 存储/ 输出/ :/ result/ _/ buffer/ (/ 存储/ 连接/ 操作/ 的/ 结果/ )/ 1/ ./ WHILE/ (/ row/ _/ store/ _/ r/ 和/ row/ _/ store/ _/ s/ 都/ 还有/ 数据/ )/ 2/ ./ 从/ row/ _/ store/ _/ r/ 中取/ 一行/ 记录/ :/ row/ _/ r3/ ./ 从/ row/ _/ store/ _/ s/ 中取/ 一行/ 记录/ :/ row/ _/ s4/ ./ 根据/ join/ _/ column/ _/ id/ 从/ row/ _/ r/ 里面/ 获得/ 该行/ 在/ 5/ ./ 根据/ join/ _/ column/ _/ id/ 从/ row/ _/ s/ 里面/ 获得/ 该行/ 在/ 6/ ./ IF/ (/ join/ _/ value/ _/ r/ </ join/ _/ value/ _/ s/ )/ 7/ ./ 从/ row/ _/ store/ _/ r/ 中取/ 下/ 一行/ 记录/ 8/ ./ ELSEIF/ (/ join/ _/ value/ _/ r/ >/ join/ _/ value/ _/ s/ )/ 9/ ./ 从/ row/ _/ store/ _/ s/ 中取/ 下/ 一行/ 记录/ 10/ ./ ELSEIF/ (/ join/ _/ value/ _/ r/ =/ =/ join/ _/ value/ _/ s/ )/ 11/ ./ 根据/ row/ _/ r/ 和/ row/ _/ s/ 的/ 主键/ 到/ R/ 表/ 和/ S/ 的/ 增/ 12/ ./ IF/ (/ R/ 表/ 的/ 增量/ Buffer/ 中/ 找到/ 了/ row/ _/ r/ 的/ 主键/ )/ 13/ ./ 将/ row/ _/ r/ 与/ 该行/ 的/ 增量/ 数据/ 合并/ 14/ ./ IF/ (/ S/ 表/ 的/ 增量/ Buffer/ 中/ 找到/ 了/ row/ _/ s/ 的/ 主键/ )/ 15/ ./ 将/ row/ _/ s/ 与/ 该行/ 的/ 增量/ 数据/ 合并/ 16/ ./ 将/ 合并/ 后/ 的/ row/ _/ r/ 与/ row/ _/ s/ 存到/ result/ _/ buffer/ 中/ ./ 5/ 算法/ 分析/ 5.1/ 算法/ 正确性/ 算法/ 通过/ 以下/ 细节/ 保证/ 了/ 结果/ 的/ 准确性/ ./ Page8/ (/ 1/ )/ 在/ 统计/ 连接/ 属性/ 上/ 的/ 信息/ 时/ ,/ 不是/ 只/ 把/ 对/ 基线/ 数据/ 的/ 统计/ 结果/ 发送给/ UpdateServer/ ,/ 而是/ 将/ 连接/ 属性/ 上/ 的/ 增量/ 数据/ 也/ 算入/ 到/ 统计/ 信息/ 里面/ ./ 这样/ 保证/ 了/ 在/ 切分/ 连接/ 属性/ range/ 的/ 时候/ ,/ 能够/ 根据/ 真正/ 的/ 统计/ 信息/ ,/ 做出/ 正确/ 的/ 、/ 均匀/ 的/ range/ 切分/ ./ (/ 2/ )/ 最大/ 范围/ 算法/ 的/ 正确性/ :/ 在/ 基线/ 数据/ 的/ Shuffle/ 过程/ 中/ ,/ 每个/ ChunkServer/ 对应/ 一个/ 连接/ 属性/ 上/ 的/ range/ ,/ 每个/ ChunkServer/ 会/ 接收/ 到/ 其他/ ChunkServer/ 发送/ 来/ 的/ 属于/ 该/ range/ 里/ 的/ 数据/ 块/ ,/ 以及/ 自己/ 本地/ 的/ 属于/ 该/ range/ 里/ 的/ 数据/ 块/ ./ 这些/ 数据/ 块/ 都/ 有/ 主键/ 范围/ ,/ 取/ 这些/ 主键/ 范围/ 的/ 并/ 集/ ,/ 得到/ 最终/ 的/ 主键/ 范围/ ./ 虽然/ 最终/ 的/ 主键/ 范围/ 并/ 不/ 精确/ ,/ 因为/ 它/ 是/ 不/ 连续/ 的/ ./ 但是/ 该/ ChunkServer/ 在/ 连接/ 属性/ range/ 上/ 的/ 所有/ 数据/ 都/ 在/ 这个/ 主键/ 范围/ 内/ ./ 所以/ 最终/ 在/ 做/ mergejoin/ 的/ 时候/ ,/ 每/ 一行/ 基线/ 数据/ 肯定/ 能够/ 从/ 增量/ Buffer/ 中/ 找到/ 对应/ 的/ 增量/ 数据/ (/ 如果/ 该行/ 被/ 修改/ 了/ 的话/ )/ ./ 5.2/ 算法/ 效率/ 分析/ 与/ 传统/ 的/ 排序/ 归并/ 连接/ 算法/ 相比/ ,/ 改进/ 后/ 的/ 算法/ 极大地提高/ 了/ 连接/ 的/ 效率/ ./ 设/ 两张/ 表/ 的/ 基线/ 数据/ 行数/ 为/ nBase/ ,/ 增量/ 数据/ 行数/ 为/ nIncrease/ ,/ 连接/ 结果/ 的/ 行数/ 为/ nResult/ ,/ 每/ 一行/ 数据/ 在/ 网络/ 上/ 的/ 传输/ 时间/ 为/ tnet/ ,/ 每/ 一行/ 增量/ 数据/ 和/ 一行/ 基线/ 数据/ 合并/ 的/ 时间/ 为/ tmerge/ ,/ 内存/ 中/ 每/ 排序/ 一行/ 数据/ 的/ 时间/ 为/ tsort/ ,/ 排序/ 归并/ 连接/ 时/ 每/ 处理/ 一行/ 数据/ 的/ 时间/ 为/ tjoin/ ,/ 节点/ 的/ 个数/ 为/ N/ ./ 则/ 可/ 得到/ 传统/ 的/ 连接/ 算法/ 下/ 的/ 连接时间/ T/ _/ old/ :/ T/ _/ old/ =/ (/ nBase/ +/ nIncrease/ )/ ×/ 优化/ 后/ 的/ 算法/ 处理/ 时间/ T/ _/ new/ :/ T/ _/ new/ =/ 由/ 公式/ 可以/ 看出/ ,/ 优化/ 后/ 的/ 算法/ 明显/ 地/ 减少/ 了/ 基线/ 与/ 增量/ 数据/ 合并/ 所用/ 的/ 时间/ ,/ 当/ 节点/ 个数/ N/ 较大/ 时/ ,/ T/ _/ new/ 远/ 小于/ T/ _/ old/ ./ 下面/ 从/ 3/ 个/ 方面/ 详细/ 介绍/ 下/ 算法/ 如何/ 提升/ 了/ 连接/ 效率/ :/ (/ 1/ )/ MergeServer/ 在/ 切分/ 连接/ 属性/ 范围/ 的/ 时候/ ,/ 会/ 根据/ 每个/ ChunkServer/ 上/ 的/ 统计/ 信息/ ,/ 尽量/ 使得/ 切分/ 后/ 的/ 每个/ 范围/ 里/ 的/ 数据量/ 是/ 平均/ 的/ ./ 如果/ 总/ 的/ 数据量/ 是/ m/ ,/ 对/ m/ 行/ 数据/ 做/ 排序/ 归并/ 连接/ 的/ 时间/ 为/ s/ ,/ 范围/ 的/ 个数/ 为/ r/ ./ 则/ 如果/ 每个/ 范围/ 里/ 的/ 数据量/ 是/ 平均/ 的/ ,/ 最终/ 的/ 连接/ 处理/ 时间/ 为/ s/ // r/ ./ 如果/ 每个/ 范围/ 里/ 的/ 数据量/ 是/ 不/ 平均/ 的/ ,/ 假设/ 最大/ 的/ 范围/ 的/ 数据量/ 为/ m1/ ,/ 则/ 最终/ 的/ 连接/ 处理/ 时间/ 为/ s/ ×/ m1/ // m/ ./ 同时/ ,/ 在/ 给/ 每个/ CS/ 分配/ 范围/ 的/ 时候/ ,/ 如果/ 某个/ 范围/ 内/ 的/ 数据/ 大部分/ 都/ 在/ ChunkServer1/ 上面/ ,/ 就/ 把/ 该/ 范围/ 分配/ 给/ ChunkServer1/ ./ 这样/ 就/ 使得/ 网络/ 间/ Shuffle/ 的/ 数据量/ 最少/ ,/ 减少/ 做/ 数据/ Shuffle/ 所用/ 的/ 时间/ ./ (/ 2/ )/ 使用/ 最大/ 范围/ 算法/ 避免/ 了/ UpdateServer/ 将/ 所有/ 的/ 增量/ 数据/ 发给/ 每个/ ChunkServer/ ./ 如果/ 没有/ 最大/ 范围/ 算法/ ,/ 为/ 保证/ 结果/ 的/ 正确性/ ,/ UpdateServer/ 需要/ 将/ 每张/ 表/ 所有/ 的/ 增量/ 数据/ 发送给/ 每个/ Chunk/ -/ Server/ ,/ 这样/ 在/ 做/ mergejoin/ 的/ 时候/ ,/ 基线/ 数据/ 才/ 能够/ 从/ 增量/ Buffer/ 中/ 找到/ 自己/ 的/ 增量/ 数据/ ./ 但是/ 每张/ 表/ 的/ 所有/ 增量/ 是/ 很大/ 的/ ,/ 这会/ 导致/ UpdateServer/ 与/ ChunkServer/ 之间/ 的/ 网络/ 开销/ 特别/ 大/ ./ 如果/ 使用/ 最大/ 范围/ 算法/ ,/ UpdateServer/ 只/ 需要/ 将/ 一个/ 主键/ 范围/ 内/ 的/ 增量/ 数据/ 发送给/ ChunkServer/ ,/ 虽然/ 这个/ 主键/ 范围/ 内/ 的/ 数据/ 会/ 比/ ChunkServer/ 真正/ 需要/ 的/ 增量/ 数据/ 多/ ,/ 但是/ 与/ 所有/ 的/ 增量/ 数据/ 相比/ ,/ 最大/ 范围/ 算法/ 提升/ 的/ 效率/ 还是/ 很大/ 的/ ./ (/ 3/ )/ 4.1/ 节中/ 的/ 算法/ 在/ 很多/ 处/ 都/ 采用/ 了/ 并行/ 的/ 实现/ :/ 第/ 1/ 阶段/ ChunkServer/ 和/ UpdateServer/ 并行/ 地/ 处理/ MergeServer/ 发送/ 的/ 请求/ ;/ 第/ 3/ 阶段/ ChunkServer/ 之间/ 基线/ 数据/ 的/ Shuffle/ 和/ UpdateServer/ 内/ 增量/ 数据/ 的/ 划分/ 是/ 并行/ 的/ ;/ 第/ 4/ 阶段/ 多个/ ChunkServer/ 之间/ 是/ 并行/ 地/ 做/ mergejoin/ 的/ ./ 并行/ 的/ 处理/ 能够/ 充分/ 的/ 利用/ 分布式/ 数据库/ 的/ 特点/ ,/ 极大地提高/ 算法/ 的/ 效率/ ./ 5.3/ 算法/ 适用性/ 之所以/ 选择/ 在/ OceanBase/ 上/ 实现/ 该/ 算法/ ,/ 是因为/ OceanBase/ 的/ 增量/ 数据/ 全部/ 集中/ 在/ 一台/ 机器/ 上/ ,/ 基线/ 数据/ 分布式/ 地/ 存储/ 在/ 多台/ 机器/ 上/ ./ 基线/ 数据/ 和/ 增量/ 数据/ 不/ 在/ 一台/ 机器/ 内/ ,/ 真正/ 实现/ 了/ 物理/ 上/ 的/ 分离/ ./ 这一/ 特性/ 能够/ 更好/ 地/ 符合/ 该/ 算法/ 的/ 特点/ ,/ 使得/ 该/ 算法/ 在/ OceanBase/ 上/ 的/ 优化/ 效果/ 更好/ ./ 对于/ 其他/ 的/ 分布式/ 数据库/ 来说/ ,/ 该/ 算法/ 也/ 是/ 适用/ 的/ ,/ 只是/ 需要/ 在/ 实现/ 的/ 时候/ 根据/ 数据库/ 的/ 特点/ 做/ 不同/ 的/ 修改/ ./ 以/ HBase/ 为例/ ,/ Hbase/ 的/ 基线/ 数据/ 和/ 增量/ 数据/ 是/ 存储/ 在/ 一台/ 机器/ 上/ 的/ ,/ 则/ 只/ 需要/ 在/ 算法/ 的/ 第/ 3/ 阶段/ 增加/ 不同/ 机器/ 之间/ 增量/ 数据/ 的/ 交互/ ,/ 算法/ 的/ 整体/ 思路/ 在/ Hbase/ 还是/ 可以/ 实现/ 的/ ./ Page96/ 对/ 增量/ 数据/ 的/ 特殊/ 处理/ 增量/ 数据/ 一般/ 存储/ 在/ 内存/ 中/ ,/ 不同/ 的/ 数据库/ 采用/ 不同/ 的/ 数据结构/ 来/ 存储/ 增量/ 数据/ ./ 以/ OceanBase/ 为例/ ,/ 增量/ 数据/ 是/ 存储/ 在/ 一个/ 叫做/ 内存/ 表/ 的/ 结构/ 里面/ ./ 下面/ 详细/ 介绍/ 一下/ 内存/ 表/ 的/ 架构/ ./ 6.1/ 内存/ 表/ 结构/ 内存/ 表/ 本质/ 上/ 是/ 一个/ B/ +/ 树/ ./ 它/ 的/ 非/ 叶子/ 节点/ 是/ 由表/ id/ 和/ 主键/ 组成/ 的/ ,/ 叶/ 节点/ 则/ 存储/ 某/ 张表/ 的/ 某/ 一行/ 的/ 所有/ 增量/ ./ 例如/ 想要/ 更新/ 表/ t1/ 的/ 主键/ 为/ R1/ 的/ 行/ 的/ 某/ 一个/ 非/ 主键/ 列/ c1/ ,/ 则/ 首先/ 根据/ t1/ 的/ 表/ id/ 查找/ B/ +/ 树/ ,/ 找到/ t1/ 对应/ 的/ 节点/ ,/ 再/ 通过/ R1/ 查找/ 该/ 节点/ 的/ 孩子/ 节点/ ,/ 如果/ 找到/ 某个/ 叶子/ 节点/ 对应/ 的/ 主键/ 为/ R1/ ,/ 则/ 在/ 该/ 叶子/ 节点/ 指向/ 的/ 链表/ 的/ 尾部/ 再/ 增加/ 一个/ 链表/ 节点/ ,/ 该/ 链表/ 节点/ 的/ 值/ 为/ c1/ 更新/ 后/ 的/ 值/ ./ 这里/ 需要/ 指出/ 的/ 是/ ,/ 叶子/ 节点/ 指向/ 的/ 链表/ 是/ 不/ 存储/ 该行/ 的/ 所有/ 列/ 的/ 值/ 的/ ,/ 它/ 只/ 存储/ 该行/ 被/ 修改/ 的/ 列/ 的/ 值/ ./ 如果/ 某/ 一列/ 未/ 被/ 修改/ 过/ ,/ 它/ 是/ 不/ 存在/ 内存/ 表中/ 的/ ./ 可以/ 看出/ ,/ 一张/ 内存/ 表是/ 可以/ 存储/ 数据库/ 中/ 所有/ 表/ 的/ 增量/ 数据/ 的/ ./ 数据库/ 刚/ 启动/ 的/ 时候/ ,/ 内存/ 表是/ 初始/ 为空/ 的/ ./ 当有/ 事务/ 来/ 临时/ ,/ 如果/ 事务/ 更新/ 的/ 行/ 在/ 内存/ 表/ 里面/ 不/ 存在/ ,/ 则/ 在/ 内存/ 表内/ 新增/ 节点/ ./ 随着/ 事务/ 越来越/ 多/ ,/ 内存/ 表/ 的/ 大小/ 也/ 会/ 逐渐/ 增加/ ,/ 当/ 增加/ 到/ 一个/ 阈值/ 的/ 时候/ ,/ 会/ 触发/ 内存/ 表/ 的/ 冻结/ 操作/ ./ 冻结/ 操作/ 会/ 将/ 该/ 内存/ 表/ 转存/ 到/ 磁盘/ 上/ ,/ 并且/ 在/ 内存/ 中/ 新建/ 一张/ 空/ 的/ 内存/ 表/ ./ 所以/ ,/ OceanBase/ 系统/ 运行/ 时/ 最/ 多/ 只有/ 一个/ 内存/ 表/ ,/ 但是/ 可能/ 有/ 多个/ 被/ 转储/ 到/ 磁盘/ 中/ 的/ 冻结/ 内存/ 表/ ./ 针对/ OceanBase/ 内存/ 表/ 的/ 这些/ 特性/ ,/ 本文/ 在/ 算法/ 设计/ 的/ 时候/ 提出/ 了/ 最大/ 范围/ 算法/ 来/ 进行/ 增量/ 数据/ 的/ 分发/ ./ 由于/ 内存/ 表/ 的/ 结构限制/ ,/ OceanBase/ 只/ 支持/ 通过/ 主键/ 或者/ 主键/ 范围/ 向/ 内存/ 表拉取/ 增量/ 数据/ ./ 而/ 本文/ 算法/ 在/ 实现/ 的/ 时候/ ,/ 是/ 为/ 每个/ 节点/ 分配/ 一个/ 连接/ 列上/ 的/ 范围/ ,/ 根据/ 这个/ 连接/ 列/ 范围/ 向/ 内存/ 表拉取/ 该/ 范围/ 内/ 的/ 增量/ 数据/ ./ 这里/ 就/ 出现/ 了/ 问题/ :/ 当/ 连接/ 列/ 不是/ 主键/ 的/ 时候/ ,/ 无法/ 通过/ 连接/ 列/ 的/ 范围/ 向/ 内存/ 表拉取/ 该/ 范围/ 内/ 的/ 增量/ 数据/ ./ 解决/ 这个/ 问题/ 的/ 关键/ 就是/ :/ 通过/ 连接/ 列/ 的/ 范围/ 生成/ 一个/ 近似/ 的/ 主键/ 范围/ ,/ 然后/ 通过/ 这个/ 近似/ 的/ 主键/ 范围/ 向/ 内存/ 表拉取/ 增量/ 数据/ ,/ 并且/ 保证/ 连接/ 列/ 范围/ 内/ 的/ 基线/ 数据/ 所/ 对应/ 的/ 增量/ 全部/ 都/ 在/ 该/ 近似/ 的/ 主键/ 范围/ 内/ ./ 上文/ 提出/ 的/ 最大/ 范围/ 算法/ 就是/ 用来/ 求/ 出/ 这个/ 近似/ 的/ 主键/ 范围/ 的/ ./ 6.2/ 数据/ 修改/ 操作/ 增量/ 数据/ 的/ 类型/ 有/ 很/ 多种/ ,/ OceanBase/ 支持/ 4/ 种/ 对/ 数据/ 修改/ 的/ 操作/ :/ insert/ ,/ replace/ ,/ update/ 和/ delete/ ./ 这/ 4/ 种/ 操作/ 在/ memtable/ 上/ 增加/ 的/ 增量/ 数据/ 是/ 不同/ 的/ ./ 所以/ 在/ 算法/ 的/ 第/ 1/ 阶段/ ,/ UpdateServer/ 给/ ChunkServer/ 发送/ 遍历/ memtable/ 的/ 结果/ 的/ 时候/ ,/ 需要/ 对/ 不同/ 类型/ 的/ 增量/ 数据/ 进行/ 特殊/ 的/ 处理/ :/ (/ 1/ )/ 因为/ delete/ 操作/ 在/ memtable/ 的/ 表示/ 是/ 只/ 在/ 该行/ 的/ 行/ 操作/ 链表/ 中/ 增加/ 一个/ 删除/ 的/ 标识/ ,/ 所以/ 即使/ 该行/ 的/ 行/ 操作/ 链表/ 中/ 没有/ 连接/ 属性/ 上/ 的/ 值/ ,/ 也/ 要/ 把/ 该行/ 对应/ 的/ bitmap/ 里/ 的/ 值置/ 为/ 1/ ,/ 并且/ 连接/ 属性/ 的/ 值/ 为/ 空/ ./ (/ 2/ )/ 对于/ insert/ 操作/ 来说/ ,/ 基线/ 数据/ 是/ 没有/ 新/ 插入/ 的/ 行/ 的/ ,/ 所以/ ChunkServer/ 在/ 根据/ UpdateServer/ 的/ 遍历/ 结果/ 修改/ 基线/ 数据/ 的/ 时候/ ,/ 需要/ 在/ 基线/ 数据/ 中/ 添加/ 那些/ 新/ 插入/ 的/ 行/ ./ (/ 3/ )/ 对于/ replace/ 操作/ 来说/ ,/ 基线/ 数据/ 中/ 可能/ 有/ 该行/ ,/ 也/ 可能/ 没有/ ./ 所以/ ChunkServer/ 在/ 根据/ UpdateServer/ 的/ 遍历/ 结果/ 修改/ 基线/ 数据/ 的/ 时候/ ,/ 如果/ 某/ 一个/ 主键/ 对应/ 的/ bitmap/ 里面/ 的/ 值/ 为/ 1/ ,/ 但是/ 在/ 基线/ 数据/ 中/ 找/ 不到/ 该/ 主键/ ,/ 同样/ 也/ 需要/ 在/ 基线/ 数据/ 中/ 添加/ 一行/ ./ 7/ 实验/ 评估/ 为了/ 验证/ 算法/ 的/ 正确性/ 与/ 效率/ ,/ 本文/ 设计/ 了/ 一系列/ 实验/ ./ 实验/ 的/ 思路/ 是/ 通过/ 对比/ OceanBase/ 开源/ 的/ 版本/ 与/ 经/ 算法/ 改进/ 后/ 的/ 版本/ 对/ 相同/ SQL/ 的/ 处理/ 时间/ 与/ 处理结果/ ,/ 最终/ 得出结论/ ./ 7.1/ 实验/ 环境/ 实验/ 有/ 两个/ OceanBase/ 集群/ ,/ 每个/ 集群/ 都/ 有/ 一台/ UpdateServer/ ,/ 一台/ RootServer/ ,/ 10/ 台/ Chunk/ -/ Server/ 和/ 一台/ MergeServer/ ./ 其中/ 一个/ 集群/ 使用/ 的/ OceanBase/ 开源/ 的/ 0.4/ 版本/ ./ 另/ 一个/ 集群/ 使用/ 的/ 是/ 实现/ 了/ 上述/ 算法/ 的/ 版本/ ./ 实验/ 采用/ 的/ 数据/ 是/ 使用/ 数据/ 生成器/ 随机/ 生成/ 的/ 数据/ ,/ 数据/ 集/ 的/ 大小/ 从/ 1GB/ 到/ 6GB/ 不/ 等/ ./ 为了/ 保证/ 两个/ 集群/ 使用/ 同样/ 的/ 数据/ ,/ 我们/ 首先/ 把/ 随机/ 生成/ 的/ 数据/ 存/ 到/ 文件/ 中/ ,/ 然后/ 使用/ 工具/ ObImport/ 将/ 该/ 文件/ 导入/ 两个/ 集群/ 中/ ./ 7.2/ 实验/ 变量/ (/ 1/ )/ 做/ 连接/ 的/ 表/ 的/ 数据量/ ;/ (/ 2/ )/ 集群/ 中/ Chunk/ -/ Server/ 的/ 个数/ ;/ (/ 3/ )/ 基线/ 数据/ 与/ 增量/ 数据/ 的/ 比例/ ./ 7.3/ 实验/ 流程/ 在/ 两个/ 集群/ 中/ 建立/ 相同/ 的/ 两张/ 表/ ,/ 插入/ 相同/ 的/ Page10/ 数据/ ,/ 执行/ 相同/ 的/ 查询/ :/ select/ / fromtable/ _/ Rinnerjointable/ _/ Sontable/ _/ R/ ./ col2/ =/ table/ _/ S/ ./ col2/ ;/ 比较/ 在/ 不同/ 数据量/ 、/ 不同/ ChunkServer/ 个数/ 的/ 图/ 9/ 实验/ 对比/ 结果/ 实验/ 结果/ 分析/ :/ (/ 1/ )/ 当/ 数据/ 行数/ 较/ 少时/ ,/ 两个/ 集群/ 的/ 处理/ 时间/ 相差/ 不大/ ./ 但是/ ,/ 当/ 数据/ 行/ 数/ 超过/ 1500/ 万行/ 的/ 时候/ ,/ 开源/ 版本/ 集群/ 的/ 处理/ 时间/ 出现/ 大幅/ 增长/ ,/ 而/ 算法/ 改进/ 后/ 集群/ 的/ 处理/ 时间/ 呈近/ 线性/ 增长/ ./ 这/ 是因为/ 开源/ 版本/ 集群/ 只/ 在/ 一台/ MergeServer/ 上/ 做/ 排序/ 归并/ 连接/ ,/ 当/ MergeServer/ 的/ 内存/ 不能/ 容纳/ 所有/ 的/ 数据/ 的/ 时候/ ,/ 一部分/ 数据/ 会/ 被/ 物化/ 到/ 磁盘/ 上/ ,/ 等/ 需要/ 的/ 时候/ 再/ 从/ 磁盘/ 中/ 取出/ 来/ ,/ 这/ 极大/ 地/ 影响/ 了/ 连接/ 处理/ 的/ 效率/ ./ (/ 2/ )/ ChunkServer/ 的/ 个数/ 对/ 开源/ 版本/ 集群/ 的/ 处理/ 时间/ 几乎/ 没有/ 影响/ ./ 而/ 算法/ 改进/ 后/ 集群/ 的/ 处理/ 时间/ 随着/ ChunkServer/ 的/ 个数/ 增加/ 而/ 呈/ 近/ 线性/ 减少/ ./ 这/ 是因为/ 无论/ 有/ 多少/ 台/ ChunkServer/ ,/ 开源/ 版本/ 集群/ 只/ 在/ 一台/ MergeServer/ 上/ 做/ 连接/ ./ 而/ 算法/ 改进/ 后/ 集群/ 则/ 是/ 在/ 多个/ ChunkServer/ 上/ 并行/ 地/ 做/ 连接/ ./ 情况/ 下/ ,/ 两个/ 集群/ 的/ 处理/ 时间/ 与/ 处理结果/ ./ 最终/ 得到/ 的/ 结论/ 如图/ 9/ ./ (/ 3/ )/ 当/ 增量/ 数据/ 占/ 总/ 数据量/ 的/ 比例/ 越来越/ 大时/ ,/ 开源/ 版本/ 集群/ 的/ 处理/ 时间/ 呈近/ 线性/ 增长/ ,/ 这/ 是因为/ 要/ 做/ 合并/ 操作/ 的/ 增量/ 数据/ 越来越/ 多/ ,/ 导致/ 网络/ 传输/ 量/ 增加/ ./ 而/ 算法/ 改进/ 后/ 集群/ 的/ 处理/ 时间/ 呈/ 先/ 下降/ 后/ 上升/ 的/ 趋势/ ,/ 这/ 是因为/ 当/ 基线/ 数据/ 减少/ 时/ ,/ ChunkServer/ 之间/ 数据/ 交互/ 的/ 数量/ 变/ 少/ ,/ 整体/ 的/ 处理/ 时间/ 下降/ ./ 但是/ 当/ 增量/ 数据/ 越来越/ 多/ 的/ 时候/ ,/ 增量/ 数据/ 的/ 网络/ 传输/ 时间/ 增加/ ,/ 导致/ 整体/ 的/ 处理/ 时间/ 上升/ ./ 7.4/ TPC/ -/ H/ 测试/ 除了/ 通过/ 对比/ 实验/ 来/ 测试/ 算法/ 的/ 优化/ 性能/ ,/ 本文/ 还/ 参考/ 了/ TPC/ -/ H/ 基准/ 测试/ 对/ 算法/ 优化/ 后/ 的/ OceanBase/ 进行/ 了/ 进一步/ 测试/ ./ TPC/ -/ H/ 基准/ 测试/ 是/ 由/ TPC/ -/ D/ 发展/ 而/ 来/ ,/ 包括/ 22/ 个/ 查询/ ,/ 其/ 主要/ 评价/ 指标/ 是/ 各个/ 查询/ 的/ 相应/ 时间/ ,/ 其/ 度量/ 单位/ 是/ 每/ 小时/ 执行/ 的/ 查询/ 数/ ./ 本文/ 使用/ 了/ TPC/ -/ H/ 不同/ 大小/ 的/ 数据/ 集/ ,/ 修改/ 了/ 查询/ 语句/ ./ 最终/ 生成/ 的/ 测试/ 结果/ 如图/ 10/ ./ Page11/ 通过/ 以上/ 实验/ 和/ 测试/ 可以/ 看出/ ,/ 改进/ 后/ 的/ 算法/ 的确/ 极大地提高/ 了/ OceanBase/ 对/ 连接/ 操作/ 的/ 处理/ 效率/ ./ 并且/ ChunkServer/ 个数/ 越/ 多/ ,/ 改进/ 后/ 的/ 算法/ 效率/ 越高/ ./ 8/ 总结/ 以及/ 未来/ 工作/ 本文/ 提出/ 了/ 一种/ 分布式/ 环境/ 下/ 的/ 排序/ 归并/ 连接/ 算法/ ,/ 该/ 算法/ 充分利用/ 了/ 基线/ 数据/ 与/ 增量/ 数据/ 分离/ 的/ 特点/ ,/ 通过/ 对/ 连接/ 属性/ 做/ 范围/ 切分/ ,/ 并行/ 地/ 处理/ 基线/ 数据/ 和/ 增量/ 数据/ ,/ 避免/ 了/ 在/ 做/ 连接/ 前/ 把/ 大量/ 的/ 基线/ 数据/ 和/ 增量/ 数据/ 合并/ 导致/ 的/ 查询/ 效率/ 低下/ 的/ 情况/ ./ 通过/ 在/ 开源/ 数据库/ OceanBase/ 上/ 实现/ 该/ 算法/ 并/ 做/ 了/ 一系列/ 的/ 测试/ ,/ 充分/ 验证/ 了/ 所/ 提/ 连接/ 算法/ 能够/ 极大/ 地/ 提升/ 大表/ 连接/ 的/ 效率/ ./ 本文/ 重点/ 讨论/ 了/ 两张/ 大表/ 连接/ 的/ 情况/ ,/ 对于/ 多表/ 连接/ ,/ 如何/ 根据/ 统计/ 信息/ 、/ 中间/ 结果/ 集/ 的/ 大小/ 来/ 确定/ 连接/ 的/ 顺序/ ,/ 以及/ 如何/ 对多表/ 的/ 数据/ 同时/ 进行/ MapReduce/ 操作/ 等/ 优化/ 方法/ ,/ 将/ 是/ 未来/ 连接/ 优化/ 算法/ 研究/ 的/ 重点/ ./ 致谢/ 在/ 导师/ 周敏奇/ 教授/ 的/ 细心/ 指导/ 下/ ,/ 我/ 才能/ 顺利/ 地/ 完成/ 本文/ 的/ 工作/ ./ 写/ 论文/ 期间/ ,/ 周教授/ 严谨/ 的/ 治学/ 态度/ 极大/ 地/ 影响/ 了/ 我/ ,/ 让我学/ 到/ 了/ 很多/ ./ 在/ 这里/ 衷心感谢/ 3/ 年/ 来/ 周/ 老师/ 对/ 我/ 的/ 关心/ 和/ 指导/ ./ 同时/ ,/ 周傲/ 英/ 教授/ 也/ 对/ 我/ 的/ 工作/ 和/ 论文/ 提出/ 了/ 许多/ 宝贵/ 的/ 意见/ ,/ 让/ 我/ 少/ 走/ 了/ 很多/ 弯路/ ,/ 提高/ 了/ 学习/ 的/ 效率/ ,/ 在/ 这里/ 表示/ 衷心/ 的/ 感谢/ ./ 在/ 写/ 论文/ 期间/ ,/ 实验室/ 的/ 很多/ 小伙伴/ ,/ 如周欢/ 等/ 对/ 我/ 的/ 工作/ 、/ 生活/ 给予/ 了/ 热情/ 的/ 帮助/ ,/ 让/ 我/ 感受/ 到/ 同窗/ 的/ 温暖/ ,/ 在/ 此/ 向/ 他们/ 表达/ 我/ 的/ 感谢/ !/ 

