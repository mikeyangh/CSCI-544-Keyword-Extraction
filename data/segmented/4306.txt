Page1/ 一种/ 面向/ 众核/ 架构/ 的/ 数据流/ 编译/ 框架/ 魏/ 海涛/ 1/ )/ 秦明康/ 1/ )/ 于俊清/ 1/ )/ ,/ 2/ )/ 范东/ 睿/ 3/ )/ 1/ )/ (/ 华中科技大学/ 计算机科学/ 与/ 技术/ 学院/ 武汉/ 430074/ )/ 2/ )/ (/ 华中科技大学/ 网络/ 与/ 计算中心/ 武汉/ 430074/ )/ 3/ )/ (/ 中国科学院计算技术研究所/ 计算机/ 体系结构/ 国家/ 重点/ 实验室/ 北京/ 100190/ )/ 摘要/ 数据流/ 编程/ 模型/ 将/ 程序设计/ 与/ 媒体/ 处理/ 相结合/ ,/ 已/ 大量/ 应用/ 到/ 各个领域/ ./ 众核/ 处理器/ 已经/ 成为/ 主流/ 和/ 工业/ 标准/ ,/ 如何/ 利用/ 众核/ 架构/ 的/ 特性/ 来/ 提高/ 流/ 应用/ 执行/ 性能/ 已/ 成为/ 目前/ 研究/ 工作/ 的/ 一大/ 难点/ ./ 文中/ 提出/ 了/ 一个/ 高效/ 的/ 流/ 编译/ 框架/ 来/ 优化/ 流/ 应用/ 的/ 执行/ ,/ 该/ 框架/ 包含/ 3/ 个/ 优化/ 策略/ :/ 设计/ 一个/ 最优/ 的/ 软件/ 流水/ 调度/ 方法/ ;/ 提出/ 一个/ 高效/ 的/ 数据/ 存储/ 分配/ 算法/ ;/ 并/ 采用/ 合理/ 的/ 众/ 核间/ 的/ 映射/ 策略/ ,/ 减小/ 通信/ 以及/ 同步/ 的/ 开销/ ./ 文中/ 在/ Godson/ -/ T/ 上/ 实现/ 了/ 该/ 编译器/ 框架/ ,/ 实验/ 结果表明/ ,/ 该/ 方法/ 比/ 优化/ 前有/ 较大/ 性能/ 改进/ ./ 关键词/ 编译/ 框架/ ;/ 数据流/ 程序/ ;/ 众核/ 处理器/ ;/ 软件/ 流水/ ;/ 并行/ 1/ 引言/ 近年来/ ,/ 众核/ 架构/ 已经/ 成为/ 处理器/ 设计/ 的/ 主流/ ./ 各个/ 研究/ 机构/ 和/ 芯片/ 厂商/ 推出/ 了/ 相应/ 的/ 处理器/ 原型/ ./ 如/ MIT/ 的/ Raw/ [/ 1/ ]/ 有/ 16/ 个/ 核/ ,/ 中国科学院计算技术研究所/ 的/ Godson/ -/ T/ [/ 2/ ]/ 有/ 64/ 个/ 核/ ,/ Intel/ 的/ SCC/ [/ 3/ ]/ 有/ 48/ 个/ 核/ ./ 众核/ 虽然/ 具有/ 高效/ 的/ 计算能力/ ,/ 但是/ 也/ 带来/ 了/ 复杂/ 的/ 存储/ 和/ 通信/ 机制/ 等/ 问题/ ,/ 增加/ 了/ 编程/ 的/ 难度/ ./ 数据流/ 编程/ (/ DataFlowProgramming/ )/ 模型/ 将/ 程序设计/ 与/ 多媒体/ 处理/ 相结合/ ,/ 在/ 简化/ 了/ 编程/ 的/ 同时/ ,/ 为/ 编译器/ 在/ 众核/ 架构/ 下/ 的/ 并行性/ 优化/ 提供/ 了/ 极大/ 的/ 可能性/ ,/ 受到/ 了/ 广泛/ 的/ 关注/ ./ 软件/ 流水/ 调度/ (/ SoftwarePipeliningSchedule/ )/ 充分/ 地/ 利用/ 了/ 数据流/ 程序/ 中/ 存在/ 的/ 并行性/ ,/ 使/ 不同/ 执行/ 阶段/ 的/ 指令/ 可以/ 在/ 流水线/ 中/ 并发/ 地/ 执行/ ,/ 提高/ 了/ 程序/ 的/ 执行/ 性能/ ,/ 并且/ 可以/ 通过/ 降低/ 每次/ 迭代/ 的/ 时间/ 来/ 优化/ 软件/ 流水/ 调度/ 的/ 执行/ 性能/ ./ 然而/ ,/ 处理器/ 核/ 、/ 通信/ 带宽/ 和/ 片/ 上/ 存储/ 等/ 系统资源/ 的/ 局限性/ 会/ 影响/ 软件/ 流水/ 调度/ 的/ 性能/ ,/ 本文/ 将/ 针对/ 这一/ 问题/ ,/ 提出/ 一种/ 高效/ 的/ 优化/ 方法/ ./ 本文/ 基于/ Godson/ -/ T/ 众核/ 架构/ 提出/ 了/ 一种/ 针对/ 数据流/ 程序/ 的/ 编译器/ 框架/ ./ 该/ 框架/ 包括/ 3/ 个/ 组成部分/ :/ 前端/ 编译/ 模块/ 、/ 优化/ 模块/ 和/ 代码生成/ 模块/ ./ 我们/ 选择/ DFBrook/ [/ 4/ ]/ 为/ 输入/ 语言/ ,/ 通过/ 该/ 编译/ 框架/ 生成/ 在/ Godson/ -/ T/ 上/ 可/ 编译/ 执行/ 的/ 软件/ 流水/ 代码/ ./ DF/ -/ Brook/ 在/ 语义上/ 对/ Brook/ 语言/ 进行/ 了/ 数据流/ 扩展/ ,/ 相对/ 于/ 传统/ 语言/ 具有/ 更好/ 的/ 数据/ 并行性/ 和/ 运算/ 密集/ 图/ 1Godson/ -/ T/ 的/ 整体/ 架构/ 及/ 每个/ 小核/ 的/ 结构/ [/ 2/ ]/ 为了/ 确保/ L1cache/ 与/ L2cache/ 间/ 的/ 数据/ 一致性/ ,/ Godson/ -/ T/ 采用/ 了/ 区域/ cache/ 一致性/ 协议/ ;/ 为了/ 性/ ,/ 在/ 图形图像/ 处理/ ,/ 网络服务/ 和/ 其他/ 媒体/ 处理/ 领域/ 具有/ 较强/ 的/ 适用性/ ./ 本文/ 的/ 主要/ 贡献/ 有/ 以下/ 4/ 点/ :/ (/ 1/ )/ 提出/ 了/ 一个/ 有效/ 的/ 针对/ 众核/ 架构/ 的/ 数据流/ 编译器/ 框架/ ;/ (/ 2/ )/ 基于/ 软件/ 流水/ 调度/ ,/ 提出/ 了/ 混合/ 分配/ SPM/ (/ Scratched/ -/ PadMemory/ )/ 和/ 主存/ 的/ 存储/ 分配/ 算法/ 并/ 对/ 特定/ 的/ 数据/ 拷贝/ 操作/ 进行/ 消除/ ,/ 提高/ 了/ 数据/ 访问速度/ ;/ (/ 3/ )/ 提出/ 了/ 一种/ 虚拟/ 核向/ 物理/ 核/ 映射/ 的/ 算法/ ,/ 进一步/ 减小/ 通信/ 开销/ 和/ 同步/ 开销/ ;/ (/ 4/ )/ 在/ Godson/ -/ T/ 上/ 实现/ 了/ 该/ 编译器/ 框架/ 并/ 通过/ 实验/ 来/ 验证/ 该/ 框架/ 的/ 有效性/ ./ 本文/ 第/ 2/ 节/ 介绍/ 同步/ 数据流/ 模型/ 和/ Godson/ -/ T/ 的/ 体系结构/ ;/ 第/ 3/ 节/ 讨论/ 软件/ 流水/ 调度/ ,/ 混合/ 存储/ 优化/ 和/ 通信/ 优化/ ;/ 第/ 4/ 节/ 介绍/ 实验/ 方法/ 和/ 结果/ ;/ 第/ 5/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 6/ 节对/ 全文/ 进行/ 总结/ ./ 2Godson/ -/ T/ 体系/ 架构/ 与/ 流/ 编程/ 模型/ 2.1/ Godson/ -/ T/ 体系/ 架构/ Godson/ -/ T/ 是/ 中国科学院计算技术研究所/ 正在/ 研究/ 开发/ 的/ 片/ 上/ 众核/ 系统/ ,/ 它/ 主要/ 是/ 面向/ 大规模/ 的/ 并行处理/ 的/ 众核/ 结构/ ./ 它/ 的/ 提出/ 是/ 为了/ 解决/ 片上/ 多/ // 众核/ 架构/ 下/ 数据/ 在/ L2cache/ 下/ 访问/ 延迟/ 和/ 存储容量/ 利用率/ 的/ 问题/ ./ Godson/ -/ T/ 的/ 整体/ 的/ 架构/ 由/ 64/ 个/ RISC/ 计算/ 节点/ 构成/ ,/ 每个/ 计算/ 节点/ 都/ 有/ 自己/ 私有/ 的/ 计算/ 与/ 访存/ 部件/ 以及/ L1cache/ ,/ 所有/ 计算/ 单元/ 共享/ L2cache/ ,/ 另外/ ,/ 计算/ 节点/ 都/ 有/ 作为/ 自己/ 协处理器/ 存在/ 的/ DataTransferAgent/ (/ DTA/ )/ ,/ 它/ 类似/ 于/ DMA/ 用来/ 传输数据/ ./ 同步/ 管理/ 的/ 方便/ ,/ Godson/ -/ T/ 包含/ 有/ 专用/ 的/ 同步/ 管理器/ ./ 这些/ 协议/ 和/ 部件/ 优化/ 了/ Godson/ -/ T/ 的/ 系统/ 架构/ ./ Page3/ 本文/ 用/ Godson/ -/ T/ 模拟器/ 作为/ 实验/ 平台/ ,/ 在/ 该/ 平台/ 上/ Godson/ -/ T/ 的/ 核上/ 浮点/ 加/ 操作/ 、/ 整型/ 加/ 操作/ 以及/ 数据包/ 经/ 路由/ 的/ 延迟/ 分别/ 为/ 4cycle/ 、/ 2cycle/ 和/ 2cycle/ ./ 2.2/ 流/ 编程/ 模型/ 流/ 编程/ 模型/ 提供/ 了/ 一种/ 开发/ 众核/ 架构/ 下/ 并行性/ 程序/ 的/ 可行/ 方法/ ./ 在/ 本文/ 中/ ,/ 我们/ 重点/ 关注/ 基于/ 同步/ 数据流/ (/ SynchronousDataflow/ ,/ SDF/ )/ 的/ 流/ 编程/ 模型/ ,/ 该/ 模型/ 中/ 每个/ 结点/ 代表/ 一个/ 独立/ 的/ 计算/ 单元/ (/ 也/ 称/ actor/ )/ ,/ 拥有/ 自己/ 独立/ 的/ 指令/ 与/ 地址/ 空间/ ,/ 每条/ 边/ 代表/ actor/ 间/ 的/ 数据传输/ ,/ 通过/ 通信/ 管道/ 实现/ ./ SDF/ 编程/ 模型/ 将/ 存在/ 并行/ 的/ actors/ 和/ 核间/ 的/ 数据通信/ 暴露/ 给/ 编程人员/ ,/ 为/ 编译器/ 优化/ 提供/ 了/ 新/ 的/ 机遇/ 和/ 挑战/ ./ actor/ 的/ 执行/ 靠/ 数据/ 驱动/ ,/ 只要/ actor/ 的/ 输入/ 端口/ 有/ 足够/ 的/ 数据/ 消耗/ ,/ 它/ 将/ 不停/ 地/ 重复/ 执行/ 并/ 产生/ 数据/ 到/ 输出/ 端口/ ./ actor/ 每次/ 执行/ 消耗/ 的/ 数据量/ 称为/ 消耗率/ ,/ 同样/ 地/ ,/ actor/ 每次/ 执行/ 产生/ 的/ 数据量/ 称为/ 产生/ 率/ ./ 在/ SDF/ 模型/ 中/ ,/ actor/ 有/ 两种/ 类型/ ,/ 有/ 状态/ 的/ 和/ 无/ 状态/ 的/ ./ 一个/ 有/ 状态/ 的/ actor/ 根据/ 上次/ 执行/ 的/ 状态/ 来/ 决定/ 执行/ 之后/ 的/ 状态/ ./ 一个/ 无/ 状态/ 的/ actor/ 不/ 关心/ 上次/ 执行/ 的/ 状态/ ,/ 因此/ ,/ 无/ 状态/ 的/ actor/ 允许/ 我们/ 复制/ 一个/ 无/ 状态/ 的/ actor/ ./ 利用/ 这个/ 特性/ 我们/ 可以/ 像/ 之前/ 工作/ [/ 5/ ]/ 中/ 讨论/ 的/ 那样/ ,/ 极大/ 地/ 扩大/ 应用程序/ 的/ 并行度/ ./ 3/ 众核/ 架构/ 下/ 的/ 流/ 编译/ 框架/ 本/ 节/ 介绍/ SCMC/ (/ StreamCompilationforMany/ -/ Core/ )/ 的/ 基本/ 框架/ ,/ 其/ 编译/ 框架/ 如图/ 2/ 所示/ ./ 我们/ 主要/ 从/ 计算能力/ ,/ 存储/ 性能/ 和/ 网络通信/ 等/ 3/ 个/ 方面/ 来/ 进行/ 性能/ 的/ 优化/ ,/ 目标/ 是/ 获得/ 使流/ 程序/ 具有/ 最大/ 吞吐/ 率/ 的/ 软件/ 流水/ 调度/ ./ SCMC/ 编译/ 框架/ 的/ 输入/ 是/ 以/ DFBrook/ 语言/ 编写/ 的/ 流/ 程序/ ,/ 经过/ 编译/ 产生/ 的/ 源文件/ 可以/ 在/ Godson/ -/ T/ 上/ 运行/ ./ 我们/ 的/ 优化/ 过程/ 包括/ 3/ 个/ 阶段/ :/ 软件/ 流水/ 调度/ 阶段/ 、/ 存储/ 访问/ 优化/ 阶段/ 和/ 通信/ 优化/ 阶段/ ./ 所有/ 优化/ 过程/ 是/ 在/ 源流/ 程序/ 经过/ 前端/ 解析/ 之后/ 生成/ SDF/ 图/ 进行/ 的/ ./ 优化/ 过程/ 的/ 第/ 1/ 阶段/ 是/ 软件/ 流水/ 调度/ 过程/ ./ 根据/ 各个/ actor/ 的/ 任务/ 计算/ 量/ ,/ 将/ 所有/ 的/ actor/ 均衡/ 地/ 划分/ 到/ 众/ 核上/ ,/ 然后/ 根据/ 划分/ 的/ 结果/ 形成/ 一个/ 软件/ 流水/ 调度/ 方案/ ./ 在/ 这个/ 阶段/ 我们/ 假定/ 每个/ 核/ 的/ 存储容量/ 为/ 无限大/ 且/ 所处/ 的/ 网络/ 环境/ 是/ 完全/ 对/ 等/ 的/ ./ 这样/ 做/ 的/ 目的/ 是/ 为了/ 平衡/ 各个/ 核上/ 的/ 计算/ 量/ ,/ 同时/ 将/ 通信/ 和/ 计算/ 重叠/ ,/ 让/ 通信/ 过程/ 隐藏/ 在/ 计算/ 之中/ ,/ 最大化/ 软件/ 流水/ 的/ 理论/ 吞吐/ 率/ ./ 第/ 2/ 阶段/ 为/ 存储/ 性能/ 的/ 优化/ ,/ 根据/ 众核/ 架构/ 下/ 的/ 层次性/ 存储/ 结构/ ,/ 不仅/ 要/ 高效/ 地/ 分配/ 存储资源/ ,/ 而且/ 要/ 消除/ 冗余/ 的/ 数据/ 拷贝/ 操作/ ./ 第/ 3/ 阶段/ 为/ 核间/ 映射/ 阶段/ ,/ 把/ 初始/ 划分/ 后/ 的/ 任务/ 映射/ 到/ 各个/ 物理/ 核上/ ,/ 在/ 映射/ 的/ 过程/ 中/ 根据/ 众核/ 的/ 拓扑/ 结构/ 和/ 通信/ 的/ 模型/ 进行/ 优化/ ,/ 减小/ 通信/ 的/ 开销/ ./ 最后/ SCMC/ 根据/ 优化/ 结果/ 生成/ Godson/ -/ T/ 上/ 的/ 源代码/ ,/ 该/ 代码/ 经/ 编译器/ 编译/ 链接/ 后/ 生成/ 在/ Godson/ -/ T/ 上/ 可/ 运行/ 的/ 执行/ 文件/ ./ 3.1/ 软件/ 流水/ 调度/ 3.1/ ./ 1/ 任务/ 划分/ 任务/ 划分/ 的/ 目的/ 是/ 为了/ 使众/ 核/ 的/ 负载/ 均衡/ ,/ 核间/ 的/ 通信/ 与/ 计算/ 更好/ 的/ 重叠/ ,/ 从而/ 构造/ 一条/ 具有/ 最大/ 吞吐/ 率/ 的/ 软件/ 流水/ 调度/ ./ 在/ 本节/ 中/ ,/ 我们/ 将/ 任务/ 划分/ 问题/ 规划/ 化为/ 一个/ 整数/ 线性规划/ 问题/ (/ IntegerLinearProgramming/ ,/ ILP/ )/ ./ 采用/ 传统/ 的/ 流水线/ 启动/ 间隔/ (/ InitiationInterval/ ,/ II/ )/ 来/ 衡量/ 软件/ 流水/ 调度/ 的/ 性能/ ./ II/ 被/ 定义/ 为/ 相邻/ 两次/ 循环/ 迭代/ (/ 任务/ )/ 进入/ 流水线/ 的/ 时间/ 间隔/ [/ 6/ ]/ ,/ 所/ 需要/ 的/ 最小/ 启动/ II/ 越小/ 表示/ 流水线/ 的/ 吞吐/ 率越/ 大/ ./ ILP/ 目标/ 就是/ 使/ II/ 的/ 值/ 最小/ ,/ 即使/ 流水线/ 的/ 吞吐/ 率/ 最大/ ./ 本/ 实验/ 中/ ,/ 我们/ 假定/ 每个/ 处理/ 核/ 的/ 存储容量/ 是/ 无限大/ ,/ 每/ 两个/ 核间/ 的/ 数据传输/ 延时/ 是/ 相同/ 的/ ,/ 并且/ 所有/ 的/ 数据/ 都/ 分配/ 在/ SPM/ 上/ ,/ 而且/ 所有/ 核间/ 的/ 操作/ 都/ 通过/ DTA/ 操作/ 完成/ ./ 对/ SDF/ 图/ G/ =/ (/ V/ ,/ E/ )/ ,/ 其中/ ,/ V/ 表示/ 图中/ 的/ 计算/ 结点/ ,/ E/ 表示/ 图中/ 两个/ 计算/ 结点/ 的/ 通信/ 边/ ./ 用/ 狉/ 表示/ 计算/ 结点/ 重复/ 执行/ 次数/ 的/ 向/ Page4/ 量/ ,/ 对于/ 任意/ v/ ∈/ V/ ,/ 狉/ v/ 表示/ 稳定/ 状态/ 调度/ 中/ 结点/ v/ 的/ 重复/ 执行/ 的/ 次数/ ./ PC/ 代表/ 众核/ 架构/ 下/ 处理/ 核/ 的/ 个数/ ,/ 用/ 0/ ,/ 1/ ,/ …/ ,/ Pmax/ -/ 1/ 来/ 表示/ ./ 通过/ 任务/ 划分/ ,/ 确定/ 每个/ actor/ 执行/ 时/ 所在/ 的/ 核/ 以及/ 其/ 在/ 流水线/ 中/ 的/ 执行/ 阶段/ ./ 本/ 实验/ 中/ ,/ 定义/ 0/ -/ 1/ 变量/ av/ ,/ p/ 来/ 表示/ 结点/ v/ 是否/ 在/ 处理/ 核/ p/ 上/ ./ av/ ,/ p/ 为/ 1/ 表示/ v/ 在/ 处理/ 核/ p/ 上/ ,/ 否则/ 不/ 在/ 处理/ 核/ p/ 上/ ./ 对/ 处理/ 核/ 我们/ 有/ 如下/ 限制/ ./ 等式/ (/ 1/ )/ 保证/ 每个/ actor/ 必须/ 分配/ 到/ 一个/ 处理/ 核上/ ,/ 且/ 只能/ 分配/ 到/ 一个/ 处理/ 核上/ ./ 本/ 实验/ 没有/ 考虑/ 数据/ 之间/ 的/ 依赖性/ ,/ 当/ 存在/ 数据/ 依赖/ 的/ 结点/ 分/ 到/ 两个/ 不同/ 的/ 处理/ 核上/ 时/ ,/ 需要/ 增加/ 一个/ DTA/ 操作/ 以/ 完成/ 它们/ 之间/ 的/ 数据传输/ ./ 这里/ ,/ 我们/ 规定/ 由/ 目的/ actor/ 所在/ 的/ 处理/ 核/ 发起/ DTA/ 请求/ ./ 对/ 每/ 条边/ (/ u/ ,/ v/ )/ ∈/ E/ ,/ 我们/ 定义/ 0/ -/ 1/ 变量/ du/ ,/ v/ ,/ p/ ./ du/ ,/ v/ ,/ p/ =/ 1/ 表示/ v/ 分配/ 到/ 处理/ 核/ p/ 上/ ,/ u/ 没有/ 分配/ 到/ 处理/ 核/ p/ 上/ ./ 这/ 意味着/ u/ ,/ v/ 之间/ 需要/ DTA/ 传输/ ,/ 且/ 该/ DTA/ 传输/ 由/ 处理/ 核/ p/ 发起/ ./ du/ ,/ v/ ,/ p/ / av/ ,/ p/ -/ au/ ,/ p/ 烄/ du/ ,/ v/ ,/ p/ / av/ ,/ p/ 烅/ 烆/ du/ ,/ v/ ,/ p/ / 1/ -/ au/ ,/ 软件/ 流水/ 的/ 启动/ 间隔/ II/ 是/ 由/ 流水线/ 中/ 各/ 资源/ 的/ 处理/ 时间/ 决定/ ,/ 不/ 小于/ 各/ 资源/ 中/ 最长/ 处理/ 时间/ [/ 6/ ]/ ,/ 此处/ 的/ 资源/ 为/ 处理器/ 核/ 和/ DTA/ 部件/ ,/ 因此/ 我们/ 的/ II/ 由/ 处理/ 核上/ 的/ 最大/ 计算/ 时间/ 和/ DTA/ 上/ 通信/ 时间/ 来/ 决定/ ./ 我们/ 以/ work/ (/ v/ )/ 代表/ actor/ 结点/ v/ 的/ 计算/ 时间/ ,/ 以/ comm/ (/ u/ ,/ v/ )/ 代表/ 结点/ u/ 和/ v/ 之间/ 的/ 数据通信/ 时间/ ./ 不等式/ (/ 3/ )/ 保证/ 每个/ 小核/ 上/ 的/ 计算/ 时间/ 之/ 和/ 不会/ 大于/ 指定/ 的/ II/ ,/ 不等式/ (/ 4/ )/ 保证/ 小核/ 之间/ 的/ 通信/ 时间/ 之/ 和/ 不会/ 大于/ 指定/ 的/ II/ ./ 表达式/ (/ 5/ )/ 指定/ 了/ 我们/ 的/ 目标/ 是/ 最小化/ II/ ./ ∑/ v/ ∈/ V/ ∑/ (/ u/ ,/ v/ )/ ∈/ E3/ ./ 1.2/ 阶段/ 赋值/ 通过/ 上面/ 的/ 公式/ ,/ 我们/ 给出/ 了/ actors/ 在/ PCs/ 上/ 重复/ 执行/ 以及/ 如何/ 进行/ DTA/ 分配/ 的/ 信息/ ,/ 目的/ 是/ 实现/ 负载/ 均衡/ ./ 但是/ ,/ 任务/ 划分/ 阶段/ 只是/ 完成/ 了/ 如何/ 将/ 各个/ actor/ 划分/ 到/ 各个/ 执行/ 单元/ ,/ 其/ 并/ 没有/ 考虑/ actor/ 之间/ 存在/ 的/ 数据/ 依赖/ 关系/ ./ 因此/ ,/ 需要/ 通过/ 为/ actor/ 和/ 数据传输/ 分配/ 执行/ 阶段/ ,/ 以/ 满足/ actor/ 间/ 的/ 依赖/ 限制/ ./ 我们/ 定义/ stagev/ 代表/ 结点/ v/ 的/ 阶段/ 号/ ,/ stageu/ ,/ v/ 代表/ 边/ (/ u/ ,/ v/ )/ ∈/ E/ 中/ 结点/ u/ 和/ 结点/ v/ 之间/ DTA/ 操作/ 的/ 阶段/ 号/ ./ 为了/ 满足/ actor/ 间/ 的/ 数据/ 依赖/ 关系/ ,/ 规定/ actor/ 和/ 数据传输/ 的/ 阶段/ 号/ 遵循/ 以下/ 条件/ :/ (/ 1/ )/ 对于/ 任意/ 有/ 向/ 边/ (/ u/ ,/ v/ )/ ∈/ E/ ,/ 源/ 节点/ u/ 必须/ 在/ 目的/ 节点/ v/ 之前/ 执行/ ,/ 即/ stageu/ / stagev/ ;/ (/ 2/ )/ 如果/ 任务/ 划分/ 阶段/ 将源/ 节点/ u/ 和/ 目的/ 节点/ v/ 分配/ 到/ 不同/ 的/ 执行/ 单元/ ,/ 则/ 需要/ 一个/ 额外/ 阶段/ 来/ 完成/ DTA/ 操作/ ,/ 即/ stageu/ ,/ v/ ,/ 同时/ 该/ DTA/ 两端/ 的/ actoru/ 和/ v/ 的/ 阶段/ 和/ 该/ DTA/ 的/ 阶段/ 需要/ 满足/ 不等式/ stageu/ </ stageu/ ,/ v/ </ stagev/ ,/ 也就是说/ ,/ 源/ 节点/ u/ 、/ 数据传输/ 操作/ DTA/ 和/ 目的/ 节点/ v/ 的/ 阶段/ 号/ 必须/ 至少/ 差/ 一个/ 阶段/ ,/ 这样/ 就/ 在/ 满足/ 数据/ 依赖/ 的/ 条件/ 下/ ,/ 将/ 计算/ 操作/ 和/ 数据传输/ 操作/ 相/ 分离/ ,/ 使/ 处理单元/ 和/ 数据传输/ 单元/ 并行执行/ ./ 算法/ 1/ 给出/ 了/ 阶段/ 赋值/ 的/ 具体/ 算法/ ./ 首先/ ,/ 我们/ 对流/ 图/ G/ (/ V/ ,/ E/ )/ 进行/ 拓扑/ 排序/ ./ 对于/ 计算/ 节点/ u/ ,/ 遍历/ u/ 的/ 所有/ 父/ 节点/ ,/ 如果/ 父/ 结点/ v/ 与子/ 节点/ u/ 不/ 在/ 同一个/ 处理/ 核上/ ,/ 那么/ v/ 和/ u/ 的/ 阶段/ 差为/ 2/ ;/ 如果/ 父/ 结点/ v/ 和子/ 节点/ u/ 被/ 划分/ 到/ 同一个/ 处理单元/ ,/ 那么/ v/ 和/ u/ 的/ 阶段/ 号/ 相同/ ./ 对于/ 处理单元/ 间/ 的/ 数据传输/ DTA/ ,/ 如果/ 其源/ 节点/ u/ 和/ 目的/ 节点/ v/ 不/ 在/ 同一个/ 处理单元/ 上/ ,/ 那么/ 该/ DTA/ 的/ 阶段/ 号/ 比父/ 结点/ 的/ 阶段/ 号/ 大/ 1/ ;/ 而/ 如果/ 有/ 向/ 边/ (/ u/ ,/ v/ )/ ∈/ E/ 的/ 源/ 节点/ u/ 和/ 目的/ 节点/ v/ 被/ 划分/ 到/ 同一个/ 执行/ 单元/ ,/ 此时/ 不/ 需要/ 额外/ 的/ DTA/ 操作/ ,/ 也/ 就/ 没有/ DTA/ 阶段/ 号/ ./ 算法/ 1/ ./ StageAssignmentAlgorithm/ ./ 输入/ :/ actorProcMap/ (/ actor/ :/ proc/ )/ 输出/ :/ actorStageMap/ (/ actor/ :/ stage/ )/ ,/ DTAStageMap/ (/ edge/ :/ stage/ )/ 1/ ./ topologOrder/ =/ topologTrav/ (/ )/ ;/ 2/ ./ forallactorvintopologOrderdo3/ ./ intmaxStageNum/ =/ 0/ ;/ intstageNum/ ;/ 4/ ./ forallactorsuwhichisaparentofvdo5/ ./ if/ (/ actorProcMap/ [/ u/ ]/ !/ =/ actorProcMap/ [/ v/ ]/ )/ then6/ ./ stageNum/ =/ actorStageMap/ [/ u/ ]/ +/ 2/ ;/ 7/ ./ DTAStageMap/ [/ (/ u/ ,/ v/ )/ ]/ =/ actorStageMap/ [/ u/ ]/ +/ 1/ ;/ 8/ ./ else9/ ./ stageNum/ =/ actorStageMap/ [/ u/ ]/ ;/ 10/ ./ DTAStageMap/ [/ (/ u/ ,/ v/ )/ ]/ =/ Invalid/ ;/ 11/ ./ endif12/ ./ if/ (/ stageNummaxStageNum/ )/ then13/ ./ maxStageNum/ =/ stageNum/ ;/ 14/ ./ endif15/ ./ endfor16/ ./ actorStageMap/ [/ v/ ]/ =/ maxStageNum/ ;/ 17/ ./ endforPage5/ 如图/ 3/ 所示/ ,/ 任务/ 经过/ 划分/ 和/ 各/ 阶段/ 号/ 的/ 赋值/ 之后/ ,/ 进行/ 软件/ 流水/ 调度/ ./ 在/ 初始/ 的/ 填充/ 阶段/ ,/ 当/ 满足/ 数据/ 依赖/ 时/ ,/ 每个/ 核上/ 的/ actor/ 和/ DTA/ 操作/ 依次/ 图/ 3/ (/ a/ )/ 任务/ 划分/ 和/ 阶段/ 赋值/ 的/ 例子/ ,/ 结点/ 中/ 的/ 数字/ 代表/ 了/ 计算/ 时间/ ./ (/ b/ )/ 例子/ (/ a/ )/ 中/ 的/ 软件/ 流水/ 执行/ 过程/ 3.2/ 存储/ 访问/ 优化/ 为了/ 在/ 存储/ 大小/ 受限/ 的/ 情况/ 下/ ,/ 对/ 存储/ 访问/ 效率/ 进行/ 优化/ ,/ 本文/ 采用/ 了/ 混合/ 存储/ 分配/ 算法/ 和/ 拷贝/ 消除/ 策略/ ./ 本节/ 将/ 对/ 上述/ 算法/ 和/ 策略/ 进行/ 介绍/ ./ 3.2/ ./ 1/ 混合/ 存储/ 分配/ 算法/ 在/ 软件/ 流水线/ 上/ ,/ 通过/ 设置/ 缓冲/ 池/ (/ bufferpool/ )/ 来/ 实现/ 不同/ actor/ 间/ 的/ 数据通信/ ,/ 即/ 数据传输/ ./ 不同/ actor/ 之间/ 缓冲/ 池中/ 缓冲区/ 的/ 个数/ 取决于/ actor/ 间/ 的/ 阶段/ 差/ 和/ 该/ 对/ actor/ 的/ 划分/ 情况/ ,/ 若/ 这/ 对/ actor/ 划分/ 在/ 同一个/ 核内/ 则/ 至少/ 含有/ 一组/ 个数/ 为/ 两者/ 阶段/ 号/ 差加/ 1/ 的/ 缓冲区/ 组/ (/ BufferGroup/ ,/ BG/ )/ ,/ 若/ 这/ 对/ actor/ 划分/ 在/ 不同/ 的/ 核上/ ,/ 则/ 需要/ 2/ 个/ BG/ ./ 每个/ 缓冲区/ 的/ 大小/ 由/ 编译器/ 根据/ 该/ 对/ actor/ 的/ 计算/ 速率/ 在/ 编译/ 阶段/ 时/ 确定/ ./ 例如/ ,/ 图/ 4/ (/ a/ )/ 中/ ,/ actoru/ 和/ actorv/ 之间/ 的/ 阶段/ 差为/ 1/ ,/ 则/ 其/ BG/ 中/ 含有/ 2/ 个/ 缓冲区/ ,/ actoru/ 和/ v/ 位于/ 同一/ 核中/ (/ 图中/ 方框/ 代表/ 一个/ 核/ )/ ,/ 故/ 缓冲/ 池中/ 只/ 含有/ 一个/ BG/ ./ 同理/ ,/ 图/ 4/ (/ b/ )/ 中/ ,/ actoru/ 和/ DTA/ 的/ 阶段/ 差为/ 1/ ,/ 则/ 其/ BG/ 中/ 也/ 含有/ 2/ 个/ 缓冲区/ ,/ 而/ actoru/ 和/ v/ 位于/ 不同/ 的/ 处理器/ 核中/ ,/ 故其/ 缓冲/ 池中/ 含有/ 2/ 个/ BG/ ./ 在/ 任务/ 划分/ 和/ 阶段/ 赋值/ 过程/ 中/ ,/ 我们/ 假定/ 所有/ 的/ 缓冲区/ 都/ 位于/ 该/ actor/ 的/ 处理器/ 核上/ 的/ SPM/ 上/ ./ 不过/ ,/ SPM/ 的/ 容量/ 并/ 不能/ 确保/ 容纳/ 所有/ 的/ 缓冲区/ ./ 开始/ 启动/ 执行/ ./ 当/ 流水线/ 达到/ 满/ 阶段/ 时/ ,/ 吞吐/ 率/ 达到/ 最大值/ ./ 进入/ 最后/ 的/ 排空/ 阶段/ 时/ ,/ 所有/ actor/ 和/ DTA/ 操作/ 会/ 按/ 顺序/ 依次/ 退出/ 执行/ ,/ 直至/ 结束/ ./ 图/ 4/ 缓冲区/ 分配/ 的/ 3/ 种/ 情况/ :/ (/ a/ )/ 缓冲区/ 分配/ 在/ 同一个/ 核/ 的/ SPM/ 上/ ;/ (/ b/ )/ 缓冲区/ 分配/ 在/ 不同/ 的/ 核/ 的/ SPM/ 上/ ;/ (/ c/ )/ 缓冲区/ 分配/ 在/ Cache/ (/ 通过/ 主存/ )/ 上/ 故/ 为了/ 确保/ 流/ 程序/ 在/ 机器/ 上/ 顺利/ 运行/ ,/ 我们/ 将/ 实现/ 一个/ 有效/ 的/ 缓冲区/ 分配机制/ ./ 如/ 第/ 2/ 节/ 所述/ ,/ Godson/ -/ T/ 上/ 的/ 小/ 核上/ 的/ 本地/ 存储/ 被/ 配置/ 成/ SPM/ 和/ L1cache/ 的/ 混合/ ./ SPM/ 由/ 软件/ 管理/ ,/ load/ // store/ 只/ 需要/ 一个/ cycle/ 的/ 延时/ ,/ 因此/ 存在/ cachemiss/ 和/ 替换/ 造成/ 的/ 开销/ ./ Licache/ 为/ 各个/ 核/ 私有/ ,/ L2cache/ 被/ 所有/ 小核/ 共享/ ,/ 是/ 主存/ Memory/ 的/ 局部/ 拷贝/ ./ 因此/ ,/ 本文/ 将/ 采用/ 将/ 缓冲区/ 分配/ 至/ SPM/ 的/ 策略/ ,/ 若有/ 溢出/ ,/ 则/ Page6/ 将/ 其/ 分配/ 至/ 2/ 级/ 缓存/ (/ L2Cache/ )/ ./ 图/ 5/ 解释/ 了/ 混合/ 缓冲/ 分配机制/ ./ 图/ 5/ (/ a/ )/ 中/ 含有/ 处理器/ 核/ P1/ 和/ P2/ ,/ P1/ 上/ 分配/ 了/ BG0/ ~/ BG6/ ,/ P2/ 上/ 分配/ 了/ BG7/ 和/ BG11/ ./ 其中/ 的/ 箭头/ 代表/ 核间/ 数据/ 传递/ ,/ 核内/ 的/ 数据/ 传递/ 箭头/ 未/ 显示/ ./ 图/ 5/ (/ b/ )/ 代表/ 了/ 进行/ 混合/ 分配/ 策略/ 后/ 的/ 结果/ ,/ 由于/ SMP/ 空间/ 有限/ ,/ 处理器/ 核上/ 的/ SMP0/ 和/ SMP1/ 只能/ 容纳/ 部分/ BG/ ,/ 剩余/ 的/ BG/ 放置/ 于/ L2cache/ 中/ ./ 这样/ 不仅/ 不会/ 引入/ 新/ 的/ 流水线/ 阶段/ ,/ 而且/ 还/ 能/ 消除/ 内存/ 拷贝/ 中/ 的/ 冗余/ 操作/ ,/ 极大/ 的/ 提高/ 程序/ 效率/ ./ 图/ 5/ (/ a/ )/ 和/ (/ b/ )/ 是/ SPM/ 与/ L2/ -/ cache/ // Memory/ 混合/ 分配/ 算法/ 在/ 分配/ 前/ 和/ 分配/ 后/ 的/ 状态/ ,/ (/ c/ )/ 是/ 使用/ 拷贝/ 消除/ 策略/ 后/ L2/ -/ cache/ // Memory/ 上/ 的/ 存储状态/ 算法/ 2/ 所示/ 为/ 混合/ 存储/ 分配/ 算法/ ./ 初始/ 阶段/ ,/ 将/ 所有/ BG/ 都/ 分配/ 到/ SPM/ 上/ ,/ 并且/ 设置/ BG/ 都/ 为/ 未/ 选中/ 状态/ ./ 根据/ 已经/ 划分/ 好/ 的/ 结果/ 以及/ 每个/ 任务/ 的/ 阶段/ 值/ 计算/ 出/ 每个/ 处理/ 核/ 的/ 存储/ 消耗/ ,/ 进一步/ 得出/ 超出/ 当前/ SPM/ 限制/ 的/ 处理/ 核/ ./ 针对/ 这些/ 超出/ 限制/ 的/ 处理/ 核/ ,/ 根据/ SPM/ 大小/ 的/ 限制/ ,/ 合理/ 地/ 标记/ 出/ 满足条件/ 的/ BG/ ,/ 将/ 满足条件/ 的/ 选中/ 的/ BG/ 在/ SPM/ 上/ 分配/ 存储空间/ ,/ 对/ 未/ 标记/ 的/ BG/ 在/ L2cache/ // Memory/ 上/ 分配/ 存储空间/ ./ 同时/ ,/ 我们/ 需要/ 对/ DTA/ 操作/ 的/ 阶段/ 号/ 进行/ 合理/ 的/ 调整/ ./ 算法/ 2/ ./ HybridBufferAllocationAlgorithm/ ./ 输入/ :/ procMap/ (/ processor/ :/ actor/ [/ ]/ )/ ,/ 1/ ./ forallEdgeeginedgeMapdo2/ ./ bg/ =/ findBufferGroup/ (/ eg/ )/ 3/ ./ InitasNonVictimBufferGroup/ (/ bg/ )/ ;/ 4/ ./ endfor/ {/ ComputememoryusageforeverySPMbasedon5/ ./ memUsage/ [/ processor/ ]/ ←/ 6/ ./ (/ victimProc/ [/ ]/ ,/ nonVictimProc/ [/ ]/ )/ ←/ 7/ ./ SortSpilledBufferDescending/ (/ victimProcs/ )/ ;/ 8/ ./ forallProcessorpinvictimProcsdo9/ ./ BufferGroupBGs/ [/ ]/ ←/ AllBufferGroups/ (/ p/ )/ ;/ 10/ ./ SortBySizeDescending/ (/ BGs/ )/ ;/ 11/ ./ forallBufferGroupbginBGsdo12/ ./ if/ (/ memUsage/ [/ p/ ]/ >/ SPM/ _/ SIZE/ )/ then13/ ./ if/ (/ !/ isVictim/ (/ bg/ )/ )/ then14/ ./ markAsVictimBufferGroup/ (/ bg/ )/ ;/ 15/ ./ updateMemUsage/ (/ p/ )/ ;/ 16/ ./ endif17/ ./ else18/ ./ break/ ;/ 19/ ./ endif20/ ./ endfor21/ ./ endfor22/ ./ forallEdgeeginedgeMapdo23/ ./ bg/ ←/ findBufferGroup/ (/ eg/ )/ ;/ 24/ ./ if/ (/ !/ isVictim/ (/ bg/ )/ )/ then25/ ./ allocateBufferOnSPM/ (/ bg/ )/ ;/ 26/ ./ else27/ ./ allocateBufferOnMem/ (/ bg/ )/ ;/ 28/ ./ endif29/ ./ updateDTA/ (/ eg/ )/ ;/ 30/ ./ Endfor3/ ./ 2.2/ 拷贝/ 消除/ 在/ L2cache/ // Memory/ 中/ ,/ 可能/ 存在/ 由/ BG/ 分配/ 算法/ 分配/ 的/ 一对/ BG/ ,/ 这/ 对/ BG/ 在/ 软件/ 流水/ 执行/ 时/ ,/ 由于/ actor/ 间/ 存在/ 着/ 数据/ 依赖/ ,/ BG/ 间/ 的/ 数据/ 会/ 不断/ 地/ 进行/ 拷贝/ ,/ 从而/ 引起/ 缓存/ 缺失/ 率/ 的/ 上升/ ./ 这会/ 导致/ 极大/ 的/ 系统/ 开销/ 和/ 网络/ 负载/ ./ 图/ 5/ (/ b/ )/ 中/ 的/ BG11/ 与/ BG6/ 就是/ 这样/ 的/ BG/ 对/ ./ BG/ 拷贝/ 操作/ 带来/ 的/ 性能/ 影响/ 太/ 大/ ,/ 需要/ 设法/ 加以改进/ ./ 这里/ 考虑/ 到/ L2cache/ 的/ 核间/ 共享/ 关系/ ,/ 则/ 可以/ 消除/ 在/ L2cache/ 上/ 的/ BG/ 对/ ./ 图/ 4/ (/ c/ )/ 将/ 图/ 4/ (/ b/ )/ 中/ 的/ BG/ 对/ 合并/ ,/ 因此/ 消除/ 了/ 在/ 图/ 4/ (/ b/ )/ 中/ 存在/ 数据/ 拷贝/ 的/ BG/ 对/ ./ 同时/ ,/ 在/ 软件/ 流水/ 的/ 阶段/ 划分/ 中/ ,/ actoru/ 与/ actorv/ 之间/ 的/ 阶段/ Page7/ 数/ 也/ 由/ 原来/ 的/ 3/ 个/ 阶段/ 减少/ 为/ 现在/ 的/ 2/ 个/ 阶段/ ./ 流水线/ 阶段/ 数/ 的/ 更新/ 使得/ 软件/ 流水/ 总/ 阶段/ 数/ 降低/ ,/ 这会/ 提高/ 软件/ 流水/ 执行/ 的/ 效率/ ./ 在/ 拷贝/ 消除/ 操作/ 完成/ 之后/ ,/ 节点/ 的/ 阶段/ 赋值/ 的/ 阶段/ 数将会/ 减少/ ,/ 这时/ 需要/ 重新/ 计算/ BG/ 的/ 大小/ 来/ 满足/ 软件/ 流水/ 的/ 需求/ ,/ 这里/ 引入/ 了/ 阶段/ 重/ 赋值/ 算法/ 来/ 解决/ 这一/ 问题/ ./ 这里/ 用到/ 的/ 阶段/ 重/ 赋值/ 算法/ 称作/ 混合/ 缓存/ 分配/ 算法/ ,/ 如图/ 6/ 所示/ ,/ 该/ 算法/ 与/ 算法/ 1/ 相比/ 针对/ L2cache/ 做/ 了/ 相关/ 优化/ ,/ 如果/ actor/ 边上/ 的/ 两个/ 节点/ 分配/ 到/ 了/ 不同/ 的/ 核上/ ,/ 而/ 它们/ 的/ BG/ 又/ 同时/ 分配/ 到/ 了/ L2cache/ 上/ ,/ 则/ 这/ 两个/ 节点/ 间/ 的/ 阶段/ 数之差/ 设为/ 1/ ./ 同时/ ,/ 由于/ 它们/ 间/ 的/ 数据/ 拷贝/ 可以/ 通过/ 上述/ 方法/ 加以/ 消除/ ,/ 则/ 它们/ 间/ 的/ DTA/ 将会/ 标记/ 为/ 非法/ ./ 若/ 不/ 属于/ 以上/ 的/ 情况/ ,/ 则/ 按照/ 一般/ 的/ 方法/ 进行/ 处理/ ./ 3.3/ 通信/ 优化/ 在/ 3.1/ 节中/ ,/ 我们/ 在/ 虚拟/ 处理/ 核/ 上将/ 流/ 程序/ 划分/ 成/ 负载/ 均衡/ 的/ 群组/ ./ 在/ 本节/ 中/ ,/ 我们/ 会/ 在/ 考虑/ 通信/ 开销/ 的/ 情况/ 下/ ,/ 将/ 虚拟/ 核/ 映射/ 到/ Godson/ -/ T/ 架构/ 下/ 的/ 实际/ 物理/ 核上/ ,/ 以/ 减小/ 通信/ 和/ 同步/ 开销/ ./ 我们/ 称/ 这/ 一/ 过程/ 为/ 核间/ 映射/ 的/ 通信/ 优化/ ./ 本/ 实验/ 使用/ 模拟退火/ 算法/ (/ SimulatedAnnealing/ ,/ SA/ )/ 来/ 实现/ 核间/ 映射/ 过程/ ./ 首先/ ,/ 定义/ 3/ 个/ 函数/ :/ 扰动/ 函数/ 、/ 概率/ 接受/ 函数/ 和/ 代价/ 函数/ ./ 其中/ ,/ 扰动/ 函数/ 的/ 作用/ 是从/ 当前/ 的/ 映射/ 状态/ 变换/ 到/ 另/ 一个/ 新/ 的/ 映射/ 状态/ ,/ 而/ 在/ 实际/ 处理/ 中/ ,/ 我们/ 随机/ 选择/ 两个/ 虚拟/ 核/ 对应/ 的/ 物理/ 核/ ./ 概率/ 接受/ 函数/ 用于/ 判断/ 经过/ 上述/ 扰动/ 函数/ 产生/ 的/ 映射/ 状态/ 是否/ 成立/ ./ 代价/ 函数/ 用来/ 计算/ 每/ 一种/ 映射/ 对应/ 的/ 通信/ 开销/ 和/ 同步/ 开销/ ,/ 并/ 选择/ 开销/ 最小/ 的/ 状态/ 进行/ 映射/ ./ 实验/ 中/ ,/ 我们/ 用/ (/ vs/ ,/ vd/ )/ 表示/ 虚拟/ 核/ vs/ 与/ 虚拟/ 核/ vd/ 之间/ 存在/ 数据通信/ 量/ ,/ 用/ assign/ (/ C/ )/ 代表/ 虚拟/ 核/ C/ 映射/ 到/ 的/ 物理/ 核/ ./ route/ (/ ps/ ,/ pd/ )/ 代表/ 物理/ 核/ ps/ 和/ pd/ 在/ 进行/ 数据传输/ 时/ 经过/ 的/ 路径/ ./ Godson/ -/ T/ 采用/ 了/ 静态/ X/ -/ Y/ 路由/ 策略/ ,/ 即/ 数据/ 先沿/ X/ 轴/ 传输/ ,/ 然后/ 沿/ Y/ 轴/ 传输/ 到达/ 目的/ 处理/ 核/ ./ Cost/ (/ map/ )/ =/ ∑/ all/ (/ vs/ ,/ vd/ )/ wherepath/ =/ route/ (/ assign/ (/ vs/ )/ ,/ assgin/ (/ vd/ )/ )/ (/ 6/ )/ 式/ (/ 6/ )/ 为/ 给定/ 映射/ 下/ 的/ 代价/ 函数/ ./ 其中/ ,/ Items/ 包含/ 在/ 流水线/ 满时/ vs/ 上/ 的/ actor/ 与/ vd/ 上/ 的/ actor/ 之间/ 总/ 的/ 数据传输/ 量/ ./ hop/ 函数/ 得到/ path/ 这条/ 路径/ 中/ 包含/ 的/ 处理/ 核/ 的/ 个数/ ./ sync/ 函数/ 返回/ path/ 这条/ 路径/ 上/ 包含/ 其他/ 路径/ 经过/ 的/ 处理/ 核/ 的/ 个数/ ,/ 如果/ 有/ 多条/ 路径/ 同时/ 经过/ 同一个/ 核/ ,/ 数据/ 则/ 会/ 按序/ 在/ 该/ 核/ 上路/ 由/ ./ 权值/ w1/ 和/ w2/ 分别/ 为/ 通信/ 开销/ 和/ 同步/ 开销/ ,/ 本/ 实验/ 设置/ w1/ 为/ 2/ ,/ 因为/ 在/ Godson/ -/ T/ 上/ ,/ 一个/ 字/ 的/ 数据/ 经过/ 一个/ 处理/ 核有/ 2/ 个/ cycle/ 的/ 延时/ ./ 同步/ 开销/ 并/ 没有/ 理论值/ ,/ 经过/ 在/ Godson/ -/ T/ 上/ 的/ 实际/ 测试/ ,/ 我们/ 设置/ w2/ 的/ 值/ 为/ 20.4/ 实验/ 结果/ 与/ 分析/ 本/ 实验/ 完成/ 了/ Godson/ -/ T/ 下/ 的/ 编译/ 框架/ ,/ 实验/ 的/ 测试/ 是/ 在/ Godson/ -/ T/ 的/ 模拟器/ (/ Godson/ -/ TArchi/ -/ tectureSimulator/ ,/ GAS/ )/ 进行/ 的/ ./ 其中/ ,/ GAS/ 模拟/ 了/ 一个/ 64/ 核/ 处理器/ 的/ 所有/ 功能/ 单元/ ./ 我们/ 从/ DFBrook/ 程序/ 集中/ 选出/ 测试程序/ 集/ ,/ 并/ 做/ 了/ 适当/ 的/ 扩展/ 来/ 增加/ 优化/ 的/ 机会/ ./ 首先/ ,/ 我们/ 比较/ 了/ 优化/ 前后/ 的/ 整体/ 性能/ ./ 在/ 优化/ 前/ 只/ 使用/ 了/ 第/ 1/ 阶段/ 的/ 软件/ 流水/ 调度/ 而/ 没有/ 使用/ 存储/ 访问/ 优化/ 和/ 通信/ 优化/ ,/ 所有/ 的/ 数据/ 都/ 存放/ 在/ L2cache/ 中/ ,/ 也/ 没有/ 对/ 冗余/ 的/ 数据/ 拷贝/ 操作/ 进行/ 消除/ ,/ 核间/ 映射/ 采用/ 了/ X/ -/ Y/ 寻径/ 的/ 方式/ ./ 图/ 6/ 给出/ 了/ 优化/ 前后/ 的/ 性能/ 比较/ ./ 实验/ 使用/ 了/ Godson/ -/ T/ 中/ 的/ 所有/ 64/ 个/ 核/ ,/ 每/ 段程序/ 的/ 执行/ 时间/ 被/ 标准化/ 到/ 0/ -/ 1/ 区间/ ./ 对/ 大部分/ 的/ 测试代码/ 来说/ ,/ SCMC/ 比/ 优化/ 前/ 的/ 性能/ 提高/ 了/ 70/ %/ ,/ 对于/ 所有/ 测试代码/ ,/ 平均/ 性能/ 可以/ 提高/ 58.3/ %/ ./ 图/ 6Godson/ -/ T/ 上/ 测试代码/ 在/ 优化/ 前后/ 的/ 性能/ 对比/ 图/ 7/ 显示/ 的/ 是/ 测试代码/ 经过/ SCMC/ 编译/ 前后/ 在/ 不同/ 核数/ 处理器/ 上/ 执行/ 时/ 的/ 加速/ 比/ ./ 从图/ 中/ 可以/ 看出/ ,/ 当/ 执行/ 的/ 核数/ 小于/ 32/ 时/ ,/ 加速/ 比/ 与/ 核数/ 接近/ 线性关系/ ./ 选择/ 16/ 个/ 核/ 执行/ 时/ 加速/ 比为/ 13x/ ,/ 而/ 对于/ 多数/ 测试代码/ ,/ 选择/ 64/ 个/ 核/ 执行/ 时/ 加速/ 比为/ 33x/ ,/ 这/ 是/ 由/ 任务/ 划分/ 过程/ 中/ 各个/ 核/ 的/ 负载/ 不/ 均衡/ 造成/ 的/ ,/ 对比/ 图/ 6/ ,/ avermoti/ 和/ MultiBlock/ 测试程序/ Page8/ 在/ 存储/ 和/ 通信/ 优化/ 后/ 性能/ 有/ 显著/ 提高/ ,/ 而/ 在/ 64/ 个/ 处理/ 核时/ 加速/ 比/ 却/ 没有/ 显著/ 变化/ ,/ 这是/ 由于/ 这/ 2/ 个/ 测试程序/ 任务/ 的/ 均衡性/ 差/ ,/ 因此/ 加速/ 比/ 没有/ 较大/ 提高/ ./ 图/ 7/ 测试代码/ 在/ Godson/ -/ T/ 上/ 达到/ 的/ 加速/ 比/ SCMC/ 编译/ 框架/ 的/ 第/ 2/ 个/ 优化/ 阶段/ 是/ 存储/ 访问/ 优化/ ,/ 该/ 阶段/ 的/ 目的/ 是/ 使/ 本地/ 存储空间/ 的/ 利用率/ 尽可能/ 的/ 最大化/ ,/ 减小/ 数据/ 访问/ 的/ 时间/ ./ 存储/ 访问/ 优化/ 包含/ 混合/ 存储/ 分配/ 和/ 拷贝/ 消除/ 两个/ 阶段/ ./ 图/ 8/ 给出/ 了/ 在/ 16/ 个/ 处理/ 核时/ ,/ 对/ 3/ 种/ 存储/ 访问/ 策略/ 性能/ 的/ 比较/ :/ (/ 1/ )/ L2Cache/ // Memory/ ./ 所有/ BGs/ 都/ 存放/ 在/ L2cache/ 上/ 并且/ 不/ 使用/ 拷贝/ 消除/ 策略/ ;/ (/ 2/ )/ L2cache/ 与/ 拷贝/ 消除/ 结合/ ./ BGs/ 都/ 放在/ L2cache/ 上/ 并且/ 使用/ 了/ 拷贝/ 消除/ 策略/ ;/ (/ 3/ )/ SPM/ 与/ 拷贝/ 消除/ ./ 即/ 混合/ 存储/ 分配/ 和/ 拷贝/ 消除/ 策略/ ,/ 也/ 是/ 本文/ 用到/ 的/ 方法/ ./ 从图/ 中/ 可以/ 看出/ ,/ 程序/ 利用/ 方法/ (/ 2/ )/ 比/ 方法/ (/ 1/ )/ 的/ 执行/ 性能/ 平均/ 提升/ 31/ %/ ,/ 而/ 对于/ 测试用例/ avermoti/ ,/ 性能/ 可/ 提升/ 50/ %/ ./ 因为/ 冗余/ 数据/ 的/ 消除/ 减小/ 了/ 冗余/ 数据传输/ 的/ 时间/ ,/ 而且/ 减小/ 了/ 缓冲区/ 的/ 利用/ 个数/ ,/ 从而/ 降低/ 了/ L2cache/ 上/ 的/ cachemiss/ 率/ ./ 采用/ 方法/ (/ 3/ )/ 进行/ 存储/ 访问/ ,/ 对比/ 方法/ (/ 1/ )/ ,/ 程序/ 的/ 执行/ 性能/ 平均/ 提升/ 50/ %/ ,/ 对比/ 方法/ (/ 2/ )/ ,/ 程序/ 的/ 执行/ 性能/ 平均/ 提升/ 27.5/ %/ ./ 这/ 是因为/ 方法/ (/ 3/ )/ 采用/ 了/ 将/ 一部分/ 缓冲区/ 放在/ SPM/ 上/ ,/ 提高/ 了/ 数据/ 访问/ 效率/ ./ 在/ 实验/ 中/ ,/ 我们/ 发现/ L1cache/ 的/ miss/ 率/ 很/ 低/ ,/ 而且/ 对/ 当前/ 测试程序/ 的/ 实际/ 性能/ 的/ 影响/ 很小/ ./ 因此/ ,/ 我们/ 主要/ 对/ L2cache/ 的/ cachemiss/ 率/ 进行/ 了/ 分析/ ./ 图/ 9/ 给出/ 了/ 上面/ 3/ 种/ 存储/ 访问/ 方法/ 的/ L2cachemiss/ 率/ ./ 图中/ 数据/ 显示/ ,/ 采用/ 拷贝/ 消除/ ,/ 减小/ 缓冲区/ 的/ 个数/ 以及/ 将/ 部分/ 缓冲区/ 分配/ 到/ SPM/ 上/ 的/ 方法/ 可以/ 有效/ 的/ 减小/ cachemiss/ 率/ ./ 图/ 93/ 种/ 存储/ 优化/ 方法/ cachemiss/ 率/ 的/ 比较/ 我们/ 将/ 基于/ 缓冲区/ 的/ 混合/ 存储/ 分配/ 策略/ 与/ 文献/ [/ 7/ ]/ 中/ 的/ 单/ 缓冲/ 分配/ 策略/ 进行/ 了/ 比较/ ./ 在/ 文献/ [/ 7/ ]/ 的/ 方法/ 中/ ,/ 每个/ BG/ 中/ 的/ 单个/ 缓冲区/ 作为/ 基本/ 分配/ 单元/ ./ 当/ SPM/ 溢出/ 后/ ,/ BG/ 中/ 溢出/ 的/ 缓冲区/ 会/ 分配/ 到/ 其他/ 空闲/ 的/ SPM/ 中/ ,/ 如果/ 没有/ 空闲/ 的/ SPM/ 存在/ ,/ 那么/ 溢出/ 的/ 缓冲区/ 放在/ L2cache/ 上/ ./ 如图/ 10/ 所示/ ,/ 为/ 混合/ 存储/ 分配/ 方法/ 和/ 单/ 缓冲/ 分配/ 方法/ 的/ 性能/ 比较/ ,/ 实验/ 数据/ 表明/ ,/ 相对/ 于单/ 缓冲/ 方法/ ,/ 采用/ 混合/ 存储/ 分配/ 方法/ 的/ 性能/ 可以/ 提高/ 3/ %/ 到/ 55/ %/ ./ 这/ 是因为/ 文献/ [/ 7/ ]/ 的/ 方法/ 在/ 缓冲区/ 溢出/ 的/ 情况/ 下/ ,/ 溢出/ 的/ 缓冲区/ 部分/ 与/ 原/ 缓冲区/ 之间/ 会/ 产生/ 额外/ 的/ DTA/ 操作/ ,/ 从而/ 增加/ 了/ 通信/ 开销/ ,/ 除此之外/ ,/ 还会/ 增加/ 软件/ 流水/ 的/ 阶段/ 数/ ,/ 也/ 会/ 导致/ 软件/ 流水/ 开销/ 的/ 增加/ ./ 我们/ 的/ 方法/ 以/ BG/ 为/ 分配/ 单元/ ,/ 不但/ 没有/ 引入/ 额外/ 的/ 数据传输/ 开销/ ,/ 而且/ 消除/ 了/ 冗余/ 的/ 数据/ 拷贝/ ,/ 从而/ 降低/ 了/ 软件/ 流水/ 的/ 阶段/ 数/ ./ 图/ 10/ 单/ 缓冲/ 分配/ 策略/ 与/ 本文/ 分配/ 策略/ 的/ 性能/ 对比/ Page9SCMC/ 的/ 最后/ 一个/ 优化/ 阶段/ 是/ 通信/ 优化/ 的/ 核间/ 映射/ ./ 核间/ 映射/ 的/ 目的/ 是/ 为了/ 将/ 虚拟/ 核/ 映射/ 到/ 物理/ 核上/ 以/ 减小/ Godson/ -/ T/ 上/ 的/ 核/ 间通信/ 代价/ ./ 本/ 实验/ 与/ X/ -/ Y/ 寻径/ 进行/ 了/ 比较/ ./ 在/ X/ -/ Y/ 寻径/ 中/ ,/ 虚拟/ 核/ 按照/ 先/ X/ 轴/ 再/ Y/ 轴/ 的/ 顺序/ 映射/ 到/ 物理/ 核上/ ./ 如图/ 11/ 所示/ ,/ 为/ 测试代码/ 采用/ 两种/ 方法/ 的/ 执行/ 时间/ 的/ 比较/ ./ 实验/ 数据/ 表明/ ,/ 相比/ X/ -/ Y/ 寻径/ 方法/ ,/ 本/ 实验/ 采用/ 的/ 核间/ 映射/ 的/ 方法/ 可以/ 使/ 程序/ 的/ 执行/ 性能/ 提升/ 9/ %/ 左右/ ,/ 其中/ avermoti/ 的/ 执行/ 性能/ 提高/ 达到/ 24/ %/ ./ 该/ 方法/ 对/ 带宽/ 有限/ 的/ 系统/ 会/ 有/ 更好/ 的/ 效果/ ./ 5/ 相关/ 工作/ 软件/ 流水/ 调度/ 作为/ 一种/ 开发/ 指令/ 级/ 并行/ 的/ 调度/ 策略/ 当前/ 逐渐/ 被/ 用到/ 了/ 众核/ 处理器/ 上/ ./ 软件/ 流水/ 最初/ 是/ 在/ 开发/ 硬件/ 指令集/ 流水线/ 时/ 提出/ 来/ 的/ [/ 7/ ]/ ./ 在/ 原先/ 的/ 模型/ 中/ ,/ 每个/ 任务/ 在/ 开始/ 执行/ 后/ ,/ 会/ 同步/ 地/ 在/ 资源/ 之间/ 进行/ 软件/ 流水/ 调度/ ,/ 并且/ 这些/ 资源/ 可以/ 重复/ 利用/ ;/ 当/ 一个/ 任务/ 与/ 其他/ 运行/ 的/ 任务/ 不/ 存在/ 资源/ 冲突/ 时/ ,/ 该/ 任务/ 便/ 可以/ 开始/ 执行/ ./ Kudlur/ 等/ 人/ 采用/ 软件/ 流水/ 的/ 方法/ 实现/ 了/ StreamIt/ 在/ 众核/ 处理器/ 上/ 的/ 调度/ ,/ 该/ 方法/ 通过/ 线性规划/ 的/ 方法/ 将/ 所有/ actor/ 按/ 计算/ 量/ 均衡/ 地/ 分配/ 到/ 众/ 核上/ ,/ 并/ 通过/ 阶段/ 赋值/ 算法/ 为/ 每个/ actor/ 确定/ 阶段/ 号/ ,/ 然后/ 进行/ 软件/ 流水/ 调度/ ,/ 这种/ 方法/ 的/ 缺点/ 是/ 没有/ 考虑/ 数据/ 的/ 通信量/ 相对/ 比较/ 大/ 的/ 情况/ [/ 6/ ]/ ./ 我们/ 先前/ 的/ 工作/ 将/ 计算/ 量/ 和/ 通信量/ 同时/ 进行/ 了/ 建模/ ,/ 在/ 最小化/ II/ 的/ 情况/ 下/ 同时/ 减小/ 通信/ 开销/ ,/ 但/ 该/ 方法/ 并/ 没有/ 考虑/ 存储/ 消耗/ 情况/ [/ 4/ ]/ ./ Choi/ 等/ 人/ [/ 8/ ]/ 在/ Kudlur/ 的/ 基础/ 上/ 提出/ 了/ 在/ 资源/ 受限/ 情况/ 下/ 软件/ 流水/ 调度/ ,/ 该/ 方法/ 采用/ 了/ 保守/ 估计/ 的/ 方法/ 对/ 存储/ 进行/ 的/ 建模/ ,/ 丢失/ 了/ 部分/ 解/ ./ 很多/ 关于/ SPM/ 管理/ 技术/ 的/ 研究/ 专注/ 于/ 将/ 数据/ 以/ 静态/ 或/ 动态/ 的/ 方式/ 放在/ SPM/ 上/ ./ Steinke/ 等/ 人/ [/ 6/ ]/ 提出/ 了/ 一个/ 静态/ 的/ ,/ 理想/ 的/ 选择/ 算法/ ./ 这个/ 算法/ 选择/ 有利/ 的/ 程序段/ 和/ 变量/ 到/ SPM/ 中来/ 节省/ 能耗/ ./ Uday/ -/ akumaran/ 等/ 人/ 提出/ 了/ 一种/ postpass/ 的/ 静态方法/ ,/ 它会/ 找到/ 一组/ 最优/ 的/ 频繁/ 访问/ 的/ 指令/ 块/ 放入/ SPM/ 中/ ./ Verma/ 等/ 人/ [/ 9/ ]/ 提出/ 了/ 一个/ 静态/ 算法/ 和/ 一个/ ILP/ 公式/ 来/ 减小/ 指令/ 读取/ 时/ 的/ 能耗/ ,/ 主要/ 针对/ 包含/ 了/ cache/ 和/ SPM/ 的/ 嵌入式/ 系统/ ,/ 同时/ 也/ 提出/ 了/ 一种/ cache/ -/ aware/ 的/ SPM/ 分配/ 策略/ ,/ 通过/ 在/ SPM/ 上/ 存储/ 指令/ 来/ 达到/ 节省/ 能耗/ 的/ 目的/ ./ Avissar/ 等/ 人/ [/ 10/ ]/ 提出/ 了/ 一个/ 在/ SPM/ 和/ 外存/ 间/ 静态数据/ 划分算法/ 来/ 提高/ 性能/ ./ Francesco/ 等/ 人/ [/ 11/ ]/ 提出/ 了/ 一个/ 使用/ DMA/ 来/ 减少/ 将/ 数据/ 动态/ 拷贝到/ SPM/ 上/ 的/ 开销/ 的/ 运行/ 时/ 机制/ ,/ 并/ 提供/ 了/ 一组/ API/ 接口/ ./ Kandemir/ 等/ 人/ [/ 12/ -/ 13/ ]/ 提出/ 了/ 一种/ 基于/ 循环/ 转换/ 的/ ,/ 为/ 数组/ 动态/ 管理/ SPM/ 的/ 编译器/ 技术/ ./ 6/ 总结/ 本文/ 提出/ 了/ 一个/ 优化/ 流/ 应用/ 执行/ 效率/ 的/ 流/ 编译/ 框架/ —/ —/ —/ SCMC/ ./ 它/ 将/ 编译/ 优化/ 过程/ 分为/ 了/ 3/ 个/ 阶段/ :/ 软件/ 流水/ 调度/ ,/ 存储/ 访问/ 优化/ 和/ 核间/ 映射/ ./ 除了/ 开发/ 流/ 程序/ 的/ 并行性/ ,/ SCMC/ 同时/ 也/ 实现/ 了/ 高效/ 的/ 混合/ 存储/ 分配/ 算法/ 和/ 拷贝/ 消除/ 策略/ ,/ 提高/ 存储/ 效率/ ./ 并且/ 针对/ 众核/ 架构/ 上/ 复杂/ 的/ 片/ 上/ 网络通信/ 的/ 问题/ ,/ 提出/ 了/ 核间/ 映射/ 策略/ 来/ 减小/ 网络通信/ 负载/ 和/ 同步/ 开销/ ./ 结果表明/ ,/ SCMC/ 能/ 达到/ 33x/ 的/ 加速/ 比/ 并/ 比/ 优化/ 前/ 获得/ 平均/ 58/ %/ 左右/ 的/ 性能/ 提升/ ./ 

