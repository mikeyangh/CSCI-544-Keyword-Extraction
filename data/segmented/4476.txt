Page1/ 具有/ 依赖/ 关系/ 的/ 周期/ 任务/ 实时/ 调度/ 方法/ 黄姝娟/ 1/ )/ ,/ 2/ )/ 朱怡安/ 1/ )/ 李兵/ 哲/ 1/ )/ 陆伟/ 2/ )/ 1/ )/ (/ 西北工业大学/ 计算机/ 学院/ 西安/ 710072/ )/ 2/ )/ (/ 西北工业大学/ 软件/ 与/ 微电子/ 学院/ 西安/ 710072/ )/ 摘要/ 随着/ 多/ 核技术/ 在/ 嵌入式/ 领域/ 的/ 快速/ 发展/ ,/ 越来越/ 多/ 的/ 功能/ 被/ 集成/ 在/ 同一个/ 平台/ 上/ ,/ 任务/ 之间/ 的/ 关系/ 越来越/ 复杂/ ./ 而/ 当前/ 大多数/ 的/ 实时/ 周期/ 任务/ 的/ 调度/ 模型/ 都/ 是/ 不/ 考虑/ 任务/ 之间/ 关系/ 的/ 相互/ 独立/ 的/ 任务模型/ ./ 文中/ 则/ 针对/ 具有/ 依赖/ 关系/ 的/ 周期/ 任务/ ,/ 提出/ 了/ 一种/ 基于/ ST/ (/ Simple/ -/ Tree/ )/ 的/ 实时/ 周期/ 任务调度/ 模型/ ,/ 通过/ 该/ 模型/ 来/ 维护/ 任务/ 之间/ 的/ 依赖/ 关系/ ./ 此外/ ,/ 为了/ 有效/ 地/ 提高/ 系统/ 利用率/ 以及/ 降低/ 死限/ 丢失/ 率/ ,/ 文中/ 还/ 提出/ 了/ 可/ 延迟时间/ 越短/ 越/ 优先/ 的/ 调度/ 方法/ 并/ 和/ RM/ 算法/ 、/ EDF/ 算法/ 进行/ 仿真/ 实验/ 比较/ ,/ 结果表明/ 该/ 方法/ 具有/ 较/ 高/ 的/ 核/ 利用率/ 和/ 较/ 低/ 的/ 死限/ 丢失/ 率/ ./ 关键词/ 多核/ ;/ 实时/ 调度/ ;/ 周期/ 任务/ ;/ 调度/ 模型/ ;/ 调度/ 算法/ 1/ 引言/ 随着/ 多/ 核技术/ 在/ 嵌入式/ 领域/ 的/ 快速/ 发展/ ,/ 围绕/ Page2/ 应/ 的/ 依赖/ 关系/ ,/ 那么/ 针对/ 这种/ 具有/ 依赖/ 关系/ 的/ 实时/ 任务/ 如何/ 进行/ 调度/ 就/ 成为/ 了/ 研究/ 的/ 热点问题/ [/ 6/ ]/ ./ 当前/ 片上/ 多处理器/ 任务调度/ 方法/ 中/ 主要/ 考虑/ 两种/ 模型/ [/ 7/ ]/ ./ 一种/ 是/ 相互/ 独立/ 的/ 实时/ 周期/ 任务模型/ ./ 其中/ 典型/ 的/ 是/ Liu/ 和/ Layland/ [/ 8/ ]/ 提出/ 的/ ,/ 其/ 周期/ 任务模型/ 是/ 很多/ 实时/ 任务模型/ 的/ 基础/ ,/ 相应/ 的/ 调度/ 算法/ 有/ RM/ (/ Rate/ -/ Monotonous/ )/ 算法/ [/ 9/ ]/ ,/ EDF/ (/ EarliestDeadlineFirst/ )/ 算法/ [/ 2/ ]/ 等/ ;/ 另/ 一种/ 则/ 是/ 考虑/ 任务/ 之间/ 存在/ 约束/ 关系/ 的/ 任务/ 图/ 模型/ ./ 该/ 模型/ 中/ 的/ 任务/ 之间/ 有/ 很/ 强/ 的/ 制约/ 关系/ ,/ 但/ 却/ 不/ 考虑/ 任务/ 实时性/ 和/ 周期性/ 问题/ [/ 10/ -/ 11/ ]/ ./ 本文/ 则/ 针对/ 具有/ 依赖/ 关系/ 的/ 周期性/ 任务/ 提出/ 一种/ 能/ 体现/ 部分/ 依赖/ 关系/ 的/ ST/ 任务/ 树/ 模型/ ,/ 并/ 针对/ 该/ 任务/ 树/ 模型/ 特征/ 提出/ 基于/ 可/ 延迟时间/ 越短/ 越/ 优先/ (/ ProbablyLagTimeShortestFirst/ ,/ PLTSF/ )/ 的/ 调度/ 方法/ ./ 该/ 方法/ 在/ 考虑/ 任务/ 的/ 实时性/ 以及/ 任务/ 之间/ 的/ 依赖/ 关系/ 的/ 基础/ 上/ 进行/ 相应/ 的/ 优先/ 关系/ 定义/ ,/ 并/ 对/ 可/ 并行执行/ 的/ 工作/ 分别/ 采用/ 了/ PLTSF/ 、/ RM/ 以及/ EDF/ 算法/ ./ 其/ 实验/ 结果表明/ PLTSF/ 算法/ 在/ 系统/ 整体/ 利用率/ 以及/ 死限/ 丢失/ 率/ 方面/ 都/ 比/ RM/ 、/ EDF/ 算法/ 先进/ ./ 本文/ 第/ 2/ 节/ 介绍/ ST/ 任务/ 树/ 模型/ ;/ 第/ 3/ 节/ 讲述/ ST/ 任务/ 树/ 模型/ 中/ 各种/ 优先/ 关系/ 定义/ 以及/ 可/ 延迟时间/ 、/ 延迟/ 界限/ 的/ 计算方法/ 以及/ 处理器/ 预/ 分配/ 算法/ ;/ 第/ 4/ 节/ 讲述/ 仿真/ 实验/ 的/ 方法/ 和/ 性能/ 评测/ 的/ 指标/ 以及/ 实验/ 结果/ 分析/ ;/ 第/ 5/ 节是/ 总结/ ./ 2ST/ (/ Simple/ -/ Tree/ )/ 模型/ 2.1/ 相关/ 定义/ 定义/ 1/ ./ ST/ 模型/ 的/ 树型/ 数据结构/ Tree/ =/ (/ D/ ,/ R/ )/ 满足/ 树/ 的/ 基本特征/ 即/ 在/ 任意/ 一棵树/ 中/ :/ (/ 1/ )/ 有且/ 仅/ 有/ 一个/ 特定/ 的/ 称为/ 根/ 的/ 节点/ ;/ (/ 2/ )/ 当/ n/ >/ 1/ 时/ ,/ 其余/ 节点/ 可/ 分为/ n/ (/ n/ >/ 0/ )/ 个/ 互不/ 相交/ 的/ 有限/ 集/ T1/ ,/ T2/ ,/ …/ ,/ Tn/ ,/ 其中/ 每/ 一个/ 集合/ 本身/ 又/ 是/ 一棵树/ ,/ 并且/ 称为/ 根的子/ 树/ ./ 定义/ 2/ ./ 对于/ 任何/ 一棵树/ 而言/ ,/ 每个/ 节点/ 都/ 有/ 层次/ ,/ 根为/ 第/ 1/ 层/ ,/ 根/ 的/ 孩子/ 为/ 第/ 2/ 层/ ./ 若/ 某个/ 节点/ 在/ 第/ K/ 层/ ,/ 其/ 孩子/ 就/ 在/ 第/ K/ +/ 1/ 层/ ,/ 树/ 的/ 深度/ 为树中/ 节点/ 的/ 最大/ 层次/ ./ 树/ T/ 深度/ 为/ H/ ,/ 用/ layer/ (/ T/ )/ =/ H/ 表示/ ;/ 节点/ Pi/ 层次/ 为/ K/ ,/ 用/ layer/ (/ Pi/ )/ =/ K/ 来/ 表示/ ./ 定义/ 3/ ./ 对于/ 任意/ 一棵树/ T/ ,/ 除了/ 叶子/ 节点/ 外/ ,/ 所有/ 节点/ 都/ 只有/ 一个/ 孩子/ 节点/ 的/ 树/ 称为/ 单行/ 树/ ST/ (/ SimpleTree/ )/ ,/ 单行/ 树是/ 一棵/ 每个/ 父/ 节点/ 只有/ 一个/ 孩子/ 节点/ 的/ 树/ ./ 如图/ 1/ 所示/ 为/ 一棵/ 深度/ 为/ 4/ 的/ 单行/ 树/ ,/ 树中/ 第/ K/ 层/ 的/ 节点/ 数用/ Number/ (/ K/ )/ 来/ 表示/ ./ ST/ 具有/ 如下/ 特征/ :/ ST/ 每层/ 只有/ 一个/ 节点/ 即/ Number/ (/ Ti/ )/ =/ layer/ (/ Ti/ )/ ./ 节点/ 个数/ 就是/ 层数/ 即/ K/ =/ Number/ (/ Ti/ )/ ./ 节点/ 之间/ 都/ 是/ 具有/ 一定/ 的/ 顺序/ 关系/ 的/ ./ 定义/ 4/ ./ ST/ 任务模型/ 中/ 的/ 节点/ 都/ 是/ 暗含/ 死限/ 的/ 实时/ 周期/ 任务/ 节点/ ,/ 即该/ 任务/ 节点/ 为/ 一个二元/ 组/ {/ ei/ ,/ pi/ }/ ,/ 其中/ ei/ 表示/ 该/ 任务/ 一个/ 最坏/ 执行/ 时间/ ,/ pi/ 表示/ 该/ 周期/ 任务/ 的/ 周期/ 或/ 死限/ ./ 以下/ 所/ 提到/ 的/ ST/ 都/ 是/ 此类/ 性质/ 的/ 树/ ./ 另外/ ,/ 本文/ 假设/ ST/ 任务模型/ 中树/ 与/ 树/ 之间/ 都/ 是/ 相互/ 独立/ 的/ ./ 2.2/ ST/ 模型/ 考虑/ 一个/ 任务/ 系统/ Γ/ 的/ 调度/ 集/ Γ/ =/ {/ ST1/ ,/ ST2/ ,/ …/ ,/ STn/ }/ 为/ n/ 个/ 相互/ 独立/ 的/ ST/ 被/ 调度/ 在/ m/ / 2/ 的/ 处理器/ 核上/ 运行/ ./ 其中/ STi/ (/ 1/ / i/ / n/ )/ 为/ 一棵/ 深度/ 为/ h/ 的/ 任务/ 树/ ,/ 当/ h/ =/ 1/ 时/ ,/ 该树/ 就是/ 一个/ 独立/ 的/ 实时/ 周期/ 任务/ 节点/ ./ 树中/ 每个/ 节点/ 我们/ 称其为/ 该/ 树根/ 节点/ 的/ 子/ 任务/ 即/ STi/ =/ {/ T1/ 赖/ 关系/ 的/ 任务/ ,/ 其中/ T1T2i/ ,/ …/ ,/ Thi/ 为/ T1/ 为/ 该/ STi/ 的/ 任务/ ./ 而/ 其中/ 任何/ 一个/ 任务/ Tkn/ ,/ 1/ / k/ / h/ )/ 都/ 是/ 周期/ 任务/ 节点/ 即/ Tk/ 于/ 其中/ 任何/ 一个/ 任务/ Tk/ 任务/ 会/ 被/ 周期性地/ 执行/ 和/ 释放/ ,/ 对于/ 其/ 每次/ 执行/ 我们/ 称为/ 一次/ 工作/ (/ job/ )/ ./ 本文/ 假设/ 该/ 工作/ 不/ 可以/ 再/ 划分/ 为/ 更/ 小/ 的/ 可/ 并行执行/ 的/ 粒度/ ./ 我们/ 把/ Tk/ 执行/ 记为/ Tkrki/ ,/ j/ ,/ 绝对/ 死限为/ dki/ ,/ j/ ./ 由于/ Tkrki/ ,/ j/ +/ pkSTi/ (/ 1/ / i/ / n/ )/ 树/ ,/ 其/ 利用率/ 记为/ USTi/ =/ ∑/ h/ 系统/ Γ/ 的/ 总/ 利用率/ 为/ Usum/ =/ ∑/ ni/ ./ 任务/ TkPage3/ 对于/ 同/ 一棵/ ST/ 而言/ ,/ 由于/ 任务/ 之间/ 有/ 相互依赖/ 关系/ ,/ 那么/ 在/ 执行/ 过程/ 中/ 必然/ 有/ 执行/ 顺序/ ,/ 例如/ Tk/ +/ 1i/ ,/ j/ 一定/ 在/ Tki/ ,/ j/ +/ 1/ 也/ 必须/ 在/ TkTk/ 此/ ,/ 为了/ 区分/ 它们/ ,/ 将/ 同一/ 周期/ 子/ 任务/ 的/ 上次/ 工作/ i/ ,/ j/ -/ 1/ 称为/ TkTk/ 工作/ 后继/ (/ job/ )/ ,/ 并/ 将/ 与其/ 有/ 依赖/ 关系/ 的/ 上层/ 工作/ Tk/ -/ 1i/ ,/ j/ 称为/ Tki/ ,/ j/ 依赖/ (/ depend/ )/ 后继/ ./ Tk3/ 可/ 延迟时间/ 以及/ 优先/ 关系/ 确定/ 3.1/ 可/ 延迟时间/ 确定/ 定义/ 5/ ./ 如果/ 一个/ 工作/ Tk/ 开始/ 却/ 没有/ 在/ 时刻/ t/ 完成/ ,/ 那么/ 该/ 时刻/ t/ 称为/ 子任/ i/ ,/ j/ 的/ 延用/ 时刻/ ,/ 该/ 工作/ 称为/ 时刻/ t/ 未/ 完成/ 工作/ ./ 务/ Tk/ 如果/ t/ 为/ 该/ 工作/ 的/ 绝对/ 死限/ ,/ 则/ 称/ 该/ 工作/ 死限未/ 满足/ 或/ 死限/ 丢失/ ./ 定义/ 6/ ./ 在/ 调度/ 算法/ S/ 下/ ,/ 定义/ 一个/ 时间/ 分配/ 函数/ 为/ rs/ (/ x/ )/ ,/ 该/ 函数/ 表示/ 在/ 一个/ 很小/ 的/ 单位/ 时间/ 间隔/ Δ/ t/ 内/ ,/ 一个/ 工作/ x/ 如果/ 被/ 执行/ ,/ 该/ 函数/ 值为/ 1/ ,/ 否则/ 函数/ 值为/ 0/ ./ 定义/ 7/ ./ 一个/ 工作/ Tk/ 内/ 通过/ 调度/ 算法/ S/ 所能/ 给/ 分配/ 的/ 时间/ 值/ 定义/ 为/ Runtime/ (/ Tk/ 推论/ 1/ ./ 在/ 调度/ 算法/ S/ 下/ ,/ 对于/ 一棵/ STi/ 树中/ 任何/ 一个/ 暗含/ 死限/ 的/ 周期/ 任务/ Tk/ 有/ 任何/ 外界/ 干扰/ 且/ STi/ 的/ 根/ 节点/ T1/ 的/ 情况/ 下/ ,/ 该/ 周期/ 任务/ 的/ 任何/ 一个/ 工作/ Tk/ 可/ 被/ 调度/ 的/ 最早/ 发布/ 时刻/ 记为/ Oki/ ,/ j/ {/ =/ max/ (/ j/ -/ 1/ )/ ×/ pnOk/ (/ j/ -/ 1/ )/ ×/ pk/ }/ i/ ./ 证明/ ./ 第/ 1/ 个/ 任务/ T1/ 以/ 发布/ 时刻/ 为/ O1/ 由于/ 第/ 2/ 个/ 任务/ 在/ 第/ 1/ 个/ 任务/ 完成/ 之后/ 才能/ 开始/ 执行/ ./ 因此/ ,/ 第/ 2/ 个/ 任务/ T2i/ 的/ 第/ j/ 个/ job/ 的/ 最早/ 可以/ 发布/ 的/ 时刻/ 为/ i/ ,/ j/ =/ max/ {/ O1O2/ 同样/ 第/ 3/ 个/ 任务/ 在/ 第/ 2/ 个/ 任务/ 的/ 完成/ 之后/ 才能/ 执行/ ,/ 第/ 3/ 个/ 任务/ T3/ 时刻/ 为/ 以此类推/ ,/ 第/ k/ 个/ 任务/ Tk/ 发布/ 的/ 时刻/ 为/ i/ ,/ j/ =/ max/ {/ Ok/ -/ 1Ok/ {/ (/ =/ max/ (/ j/ -/ 1/ )/ ×/ p1/ (/ j/ -/ 1/ )/ ×/ p2i/ +/ ∑/ k/ -/ 1/ (/ j/ -/ 1/ )/ ×/ pk/ -/ 1/ {/ =/ max/ (/ j/ -/ 1/ )/ ×/ pn/ (/ j/ -/ 1/ )/ ×/ pk/ }/ i/ 定理/ 1/ ./ 在/ 调度/ 算法/ S/ 下/ ,/ 由/ ST/ 模型/ 可知/ 第/ k/ 层/ 节点/ Tk/ {/ T1i/ ,/ T2i/ ,/ …/ ,/ Tk/ -/ 1i/ }/ ./ 在/ 忽略/ 其他/ 额外/ 开销/ 的/ 情况/ 下/ ,/ 从/ 0/ 时刻/ 开始/ 调度/ 根/ 任务/ ,/ 则/ 判断/ 其/ 能否/ 与其/ 前驱/ 结点/ 在/ 同一个/ 处理器/ 上/ 可/ 被/ 调度/ 的/ 必要条件/ 是/ i/ / max/ {/ pnpk/ 证明/ ./ 如果/ 算法/ S/ 能/ 成功/ 调度/ ,/ 那么/ 该/ 节点/ 的/ 任何/ 一个/ 工作/ Tk/ 它/ 的/ 最早/ 开始/ 发布/ 时刻/ 一定/ 小于/ 最迟/ 开始/ 执行/ 时刻/ i/ ,/ 也就是说/ 如果/ 它/ 的/ 最早/ 开始/ 发布/ 时刻/ 大于/ dki/ ,/ j/ -/ ek/ 最迟/ 开始/ 执行/ 时刻/ ,/ 则/ 它/ 就/ 不/ 可能/ 在/ 其/ 绝对/ 死限/ dki/ ,/ j/ 之前/ 完成/ ,/ 那么/ 必定/ 存在/ 丢失/ 死限/ 情况/ ./ 因此/ 必须/ 有/ Oki/ ,/ j/ / (/ dki/ ,/ j/ -/ ekOk/ / {/ [/ max/ (/ j/ -/ 1/ )/ ×/ pnn/ =/ 1/ ,/ 2/ ,/ 3/ ,/ …/ ,/ k/ ]/ -/ 1/ ,/ (/ j/ -/ 1/ )/ ×/ pk/ }/ i/ / (/ dki/ ,/ j/ -/ ek/ / (/ dki/ ,/ j/ -/ ek/ (/ j/ -/ 1/ )/ ×/ pk/ -/ 1/ / (/ j/ ×/ pk/ (/ j/ -/ 1/ )/ ×/ pk/ -/ 1/ 也就是说/ ,/ j/ ×/ pk/ 则/ 有/ Page4j/ ×/ pkj/ ×/ pk/ / pkj/ ×/ pk/ / pk/ …/ ,/ j/ ×/ pk/ / pk/ 因此/ ,/ 可以/ 得到/ i/ / maxj/ -/ 1pk/ 当/ j/ 趋于/ 无穷大/ 时/ ,/ 即/ i/ / limj/ →/ maxj/ -/ 1pk/ / pk/ 定理/ 2/ ./ 在/ 调度/ 算法/ S/ 下/ ,/ 对于/ 一个/ 单行/ 树/ 模型/ STi/ 从/ 0/ 时刻/ 开始/ 调度/ 根/ 任务/ ,/ 如果/ 其中/ 一个/ 暗含/ 死限/ 的/ 周期/ 任务/ Tk/ 在/ 任意/ 一个/ 时间/ 间隔/ [/ t1/ ,/ t2/ )/ 内/ ,/ 该/ 任务/ 应该/ 被/ 调度/ 的/ 时间/ 值为/ i/ ,/ j/ ,/ t1/ ,/ t2/ )/ =/ 该/ 周期/ 任务/ 的/ 任何/ 一个/ 工作/ Tk/ 该/ 被/ 执行/ 的/ 时间/ 值为/ r/ (/ Tk0/ ,/ t1/ / dki/ ,/ j/ ∧/ t2/ </ Ok/ 烄/ i/ ,/ t2/ -/ t1/ / ekek/ (/ t2/ -/ t1/ )/ ×/ uk/ 烅/ dki/ ,/ j/ -/ t1pkpk/ (/ )/ i/ ×/ eki1/ -/ dki/ ,/ j/ -/ t2/ 烆/ i/ ,/ j/ 为/ Tk/ 其中/ Ok/ 证明/ ./ 根据/ 推论/ 1/ 和/ 定理/ 1/ 知/ ,/ 一个/ 周期/ 任务/ 的/ 一次/ 作业/ Tk/ 布/ 时刻/ 为/ dki/ ,/ j/ -/ ek/ [/ t1/ ,/ t2/ )/ 的/ 时间段/ r/ (/ Tk/ 情况/ :/ 第/ 1/ 种/ 情况/ ./ 如果/ t1/ / dki/ ,/ j/ 或者/ t2/ </ Oki/ ,/ j/ 的/ 执行/ 不/ 在/ 该/ 范围/ 内则/ r/ (/ TkTk/ 第/ 2/ 种/ 情况/ ./ 如果/ t2/ -/ t1/ / ekdki/ ,/ j/ ]/ ,/ 那么/ 调度/ 执行/ 时间/ 为/ ek/ 个/ 时间/ 间隔/ [/ t1/ ,/ t2/ )/ 内/ 包含/ 有/ 该/ 任务/ 的/ 周期/ 个数/ 为/ (/ t2/ -/ t1/ )/ pkii/ ,/ j/ 在/ 该/ 时间/ 间隔/ [/ t1/ ,/ t2/ )/ 内/ 被/ 调度/ 的/ 时间/ 值为/ Tkr/ (/ Tk/ 第/ 3/ 种/ 情况/ ./ 如果/ Oki/ ,/ j/ 在/ 该/ 时间/ 间隔/ [/ t1/ ,/ t2/ )/ 内/ 被/ 调度/ 的/ 时间/ 值为/ 么/ Tk/ 第/ 4/ 种/ 情况/ ./ 如果/ t1/ </ Oki/ ,/ j/ 在/ 该/ 时间/ 间隔/ [/ t1/ ,/ t2/ )/ 内/ 被/ 成功/ 调度/ 的/ 时间/ 那么/ Tk/ 值为/ r/ (/ Tk/ 由此/ 得/ 证式/ (/ 2/ )/ 成立/ ./ 假设/ 周期/ 任务/ Tki/ ,/ j/ ,/ t1/ ,/ t2/ )/ =/ ek/ 的/ 第一个/ 工作/ 为/ Tk/ 则/ j/ -/ 1/ 之前/ 的/ 工作/ (/ 包括/ 第/ j/ -/ 1/ 个/ 工作/ )/ 和/ h/ +/ 1/ 之后/ 的/ 工作/ (/ 包括/ 第/ h/ +/ 1/ 个/ 工作/ )/ 都/ 分别/ 在/ 时间/ 间隔/ [/ 0/ ,/ t1/ )/ 和/ [/ t2/ ,/ )/ 之间/ 执行/ ,/ 而/ 没有/ 在/ 该/ 时间/ 间隔/ [/ t1/ ,/ t2/ )/ 内/ 执行/ ,/ 所以/ 它们/ 在/ 该/ 时间/ 间隔/ 内/ 被/ 分配/ 的/ 时间/ 值为/ 0/ ./ 由于/ 第/ j/ 个/ 任务/ 和/ 第/ h/ 个/ 任务/ 都/ 是/ 在/ 该/ 时间/ 间隔/ 内/ 最早/ 和/ 最后/ 执行/ ,/ 所以/ h/ -/ j/ -/ 1/ 个/ 任务/ 在/ 该/ 时间/ 间隔/ 内/ 都/ 执行/ 完毕/ 则/ 执行/ 的/ 时间/ 值/ i/ ,/ 第/ j/ 个/ 任务/ 和/ 第/ h/ 个/ 任务/ 执行/ 的/ 时间/ 值/ 分别/ 为/ ekpk/ (/ )/ i/ ×/ ek/ 为/ dki/ ,/ j/ -/ t1i/ ,/ t1/ ,/ t2/ )/ =/ ∑/ j/ / l/ / hR/ (/ Tk/ =/ (/ h/ -/ j/ -/ 1/ )/ ek/ =/ (/ h/ -/ j/ -/ 1/ )/ ek/ =/ (/ h/ -/ j/ -/ 1/ )/ ek/ =/ t2i/ -/ t1ekpki/ =/ (/ t2/ -/ t1/ )/ uk/ 由此/ 得/ 证式/ (/ 1/ )/ 成立/ ./ Page5/ 定义/ 8/ ./ 在/ 任意/ 一个/ 时间/ 间隔/ [/ t1/ ,/ t2/ )/ 内/ ,/ 一个/ i/ ,/ j/ 在/ 调度/ 算法/ S/ 的/ 调度/ 下/ 被/ 推迟/ 执行/ 的/ 时间/ 工作/ Tk/ 记为/ lag/ (/ Tkr/ (/ Tk/ 其中/ Runtime/ (/ Tk/ 间隔/ 内/ ,/ S/ 调度/ 算法/ 下/ 实际/ 分配/ 给/ 该/ 工作/ 的/ 时间/ 片/ ./ 若该/ 工作/ 在/ [/ t1/ ,/ t2/ )/ 时间/ 间隔/ 内/ 没有/ 被/ 调度/ 执行/ 则/ Runtime/ (/ Tk/ 定义/ 9/ ./ 一个/ 子/ 任务/ 被/ 推迟/ 执行/ 的/ 时间/ 记为/ lag/ (/ Tk/ =/ ∑/ j/ / 1/ =/ R/ (/ Tk/ =/ (/ t2/ -/ t1/ )/ ×/ uk/ 任务/ Tk/ 率/ uk/ 定理/ 3/ ./ 如果/ 某/ 时刻/ t/ 在/ 调度/ 算法/ S/ 下/ 是/ 子/ i/ 的/ 延用/ 时刻/ ,/ 那么/ Tki/ 和/ 最坏/ 执行/ 时间/ ek/ 证明/ ./ 由于/ t/ 时刻/ 为/ 延用/ 时刻/ ,/ 则/ 一定/ 存在/ Tk/ 的/ 某个/ 工作/ Tk/ 结束/ ./ 考察/ 时间/ 间隔/ [/ 0/ ,/ t/ )/ ,/ 假定/ Tk/ 刻/ 之前/ 开始/ 执行/ 却/ 没有/ 在/ t/ 时刻/ 完成/ 的/ 工作/ 为/ 第/ j/ 个/ 工作/ ,/ 那么/ lag/ (/ Tk/ 假设/ 第/ j/ 个/ 工作/ 释放/ 时刻/ 为/ rki/ ,/ j/ ,/ 那么/ 在/ 该/ 时刻/ 之前/ 即/ 在/ 时间段/ [/ 0/ ,/ rki/ ,/ j/ )/ 内/ ,/ 该子/ 任务/ 所有/ 第/ i/ (/ i/ </ j/ )/ 个/ 工作/ 在/ t/ 时刻/ 之前/ 都/ 已经/ 完成/ ./ 由于/ 从/ 第/ j/ 个/ 工作/ 开始/ 才/ 出现/ 未/ 完成/ 的/ 工作/ ,/ 因此/ rki/ ,/ j/ </ t/ ./ 令/ λ/ ki/ ,/ j/ 为/ 截至/ t/ 时刻/ 分配/ 给/ 工作/ Tkt/ ,/ S/ )/ =/ λ/ ki/ ,/ j/ ,/ 那么/ i/ ,/ 0/ ,/ t/ ,/ S/ )/ =/ ∑/ h/ / jlag/ (/ Tk/ =/ ∑/ h/ >/ jlag/ (/ Tk/ =/ ∑/ h/ >/ jr/ (/ Tkr/ (/ Tk/ 因为/ 第/ j/ 个/ 工作/ 在/ t/ 时刻/ 还/ 没有/ 执行/ ,/ 那么/ 在/ 时间/ 间隔/ [/ 0/ ,/ t/ )/ 内/ 不/ 可能/ 执行/ j/ 以后/ 的/ 工作/ ,/ 所以/ 当/ h/ >/ j/ 时/ 又/ 有/ Runtime/ (/ Tk/ ∑/ h/ >/ jr/ (/ Tk/ 而/ r/ (/ Tk/ 故/ lag/ (/ Tki/ ,/ j/ ,/ rki/ ,/ j/ ,/ t/ )/ / ek/ 由此/ 得证/ 并/ 记录/ lagup/ (/ Tk/ 定义/ 10/ ./ 一个/ 工作/ 在/ 时刻/ t/ 的/ 可/ 延迟时间/ (/ ProbablyLagTime/ ,/ PLT/ )/ 定义/ 为/ 该/ 工作/ 的/ 绝对/ 死限/ 与/ 该/ 工作/ 在/ [/ 0/ ,/ t/ )/ 延迟时间/ 的/ 差值/ ,/ 结合/ 定义/ 9/ 得到/ PLT/ (/ Tk/ =/ dki/ ,/ j/ -/ (/ r/ (/ Tk/ 其中/ dki/ ,/ j/ 为/ 该/ 工作/ 的/ 绝对/ 死限/ ./ 3.2/ 优先级/ 定义/ 定义/ 11/ ./ 给定/ 属于/ 同/ 一棵/ 任务/ 树/ 的/ 任何/ 两个/ 工作/ Tw/ 果/ (/ 1/ / v/ </ j/ )/ ∧/ (/ w/ =/ k/ )/ 或/ (/ v/ =/ j/ ∧/ 1/ / w/ </ k/ )/ ,/ 则/ 认为/ i/ ,/ v/ 顺序/ 执行/ 优先/ 于/ TkTw/ (/ v/ ≠/ j/ )/ ∧/ (/ w/ ≠/ k/ )/ 情况/ 下/ ,/ 如果/ 两个/ 工作/ 的/ 所有/ 前驱/ 都/ 执行/ 完毕/ 则/ 可以/ 并行执行/ ,/ 具体/ 执行/ 顺序/ 可/ 根据/ 不同/ 的/ 调度/ 算法/ 来/ 执行/ ./ 如果/ 采用/ PLTSF/ 算法/ 调度/ 并行执行/ 工作/ 则/ 计算/ PLT/ (/ TwPLT/ (/ Tk/ 则/ Twi/ ,/ v/ / Tk/ 定义/ 12/ ./ 对于/ 不同/ 的/ 两棵/ 单行/ 树中/ 的/ 两个/ 工/ u/ ,/ v/ 和/ Tku/ ,/ v/ / Tk/ 作/ Tw/ 则/ Tw/ 则/ 比较/ 两个/ 子/ 任务/ 的/ 延迟/ 界限/ ;/ 若/ lagup/ (/ Twt/ ,/ S/ )/ </ lagup/ (/ Tk3/ ./ 3/ 处理器/ 预/ 分配/ 算法/ 首先/ 将/ ST/ 模型/ 中/ 的/ 每个/ ST/ 的/ 任务/ 节点/ 按照/ 定理/ 1/ 进行/ 判断/ 是否/ 可以/ 满足/ 可/ 被/ 调度/ 的/ 必要条件/ ./ 如果/ 满足/ ,/ 则/ 根据/ 任务/ 之间/ 的/ 依赖/ 关系/ ,/ 在/ m/ 个/ 处理器/ 核上/ 进行/ 分配/ ,/ 预/ 分配/ 算法/ 如下/ :/ (/ 1/ )/ 将/ 任务/ 系统/ 中/ n/ 个/ ST/ 树中/ 的/ 第一个/ 工作/ 放入/ 到/ 就绪/ 队列/ 中/ ,/ 根据/ 定义/ 11/ 和/ 定义/ 12/ 进行/ 优先级/ 判定/ ,/ 选择/ m/ 个/ 高/ 优先级/ 的/ 工作/ 分配/ 到/ m/ 个/ 核/ 上去/ 执行/ ./ 如果/ 工作/ 个数/ n/ 小于/ m/ 个/ ,/ 则/ 选择/ n/ 个/ 核来/ 执行/ ./ (/ 2/ )/ 当/ 执行/ 一个/ 单位/ 时间/ 之后/ ,/ 将/ 可/ 并行/ 的/ 任务/ 放到/ 就绪/ 队列/ 中/ ,/ 计算/ 当前/ 核上/ 每个/ 任务/ 的/ 工作/ 所/ 执行/ 的/ 时间/ 值/ λ/ ki/ ,/ j/ ,/ 如果/ λ/ ki/ ,/ j/ =/ ek/ 执行/ 完毕/ ,/ 则/ 将/ 其/ 在/ 所/ 对应/ 的/ 任务/ 扩展/ 图/ 和/ 就绪/ 队列/ 中/ 删除/ ./ 如果/ λ/ ki/ ,/ j/ </ ek/ 则/ 更改/ 该/ 工作/ 需要/ 执行/ 的/ 时间/ 片为/ ek/ 工作/ 重新/ 放到/ 就绪/ 队列/ 中/ 等待/ 和/ 其他/ 工作/ 一起/ 调度/ ./ (/ 3/ )/ 重新/ 计算/ 就绪/ 队列/ 中/ 的/ 每个/ 任务/ 的/ 优先/ Page6/ 级/ ,/ 选取/ m/ 个/ 任务/ 分别/ 分配/ 到/ m/ 个/ 核上/ 运行/ ./ 如果/ 工作/ 数/ n/ 小于/ m/ 个/ 核则/ 选择/ n/ 个/ 核去/ 执行/ ./ (/ 4/ )/ 重复/ 步骤/ (/ 2/ )/ ~/ (/ 3/ )/ ,/ 直到/ 所有/ 的/ 工作/ 都/ 能/ 分配/ 到/ 核/ 上去/ 执行/ ./ 4/ 实验/ 及/ 结果/ 分析/ 本文/ 的/ 仿真/ 实验/ 平台/ 是/ 在/ 4/ 核/ Intelcore/ (/ TM/ )/ 2QuadCPU2/ ./ 66GHz/ 内存/ 为/ 3.4/ GB/ 的/ 硬件/ 环境/ 下/ 运行/ UbuntuLinux10/ ./ 042.6/ ./ 33/ -/ 29/ 实时/ 内核/ ,/ 采用/ Codeblocks/ -/ v10/ ./ 05/ 编写/ 仿真/ 测试程序/ ./ 根据/ 文献/ [/ 8/ ]/ 中/ 的/ 定理/ ,/ 在/ 实验设计/ 时/ ,/ 选择/ 了/ 处理器/ 核数/ m/ 与/ ST/ 树/ 总/ 利用率/ Usum/ 之间/ 的/ 3/ 种/ 不同/ 的/ 关系/ :/ Usum/ >/ m/ ,/ Usum/ =/ m/ ,/ Usum/ </ m/ ,/ 针对/ 随机/ 输入/ 的/ 具有/ 依赖/ 关系/ 的/ ST/ 树/ 进行/ 了/ 多组/ 实验/ 求得/ 平均值/ ,/ 为了/ 进行/ 实验/ 结果/ 对比/ 分析/ ,/ 定义/ 如下/ 的/ 性能/ 评价/ 指标/ ./ 定义/ 13/ ./ 为了/ 在/ 给定/ 时间段/ 内/ 分析/ 上述/ 3/ 种/ 情况/ 下/ 不同/ 调度/ 算法/ 的/ 吞吐量/ ,/ 定义/ 在/ 相同/ 的/ 时间段/ 内/ 某/ 调度/ 算法/ 所/ 能够/ 完成/ 的/ 工作/ 总数/ 为/ 该/ 调度/ 算法/ 的/ 吞吐量/ ./ 定义/ 14/ ./ 在/ 算法/ 分配/ 过程/ 中/ 存在/ 某/ 时间段/ 内核/ 处于/ 空闲/ 状态/ ,/ 为了/ 描述/ 核/ 利用/ 情况/ ,/ 定义/ 核/ 总/ 利用率/ 为/ 所有/ 核/ 执行/ 工作/ 的/ 时间/ 片/ 数量/ 与/ 全部/ 时间/ 片/ 数量/ 的/ 一个/ 比值/ ./ 该/ 比值/ 是/ ST/ 模型/ 对核/ 利用/ 情况/ 的/ 一个/ 反映/ ./ 该值/ 越大/ 说明/ 该/ 模型/ 和/ 调度/ 方法/ 对核/ 的/ 利用/ 越/ 充分/ ./ 定义/ 15/ ./ 由于/ ST/ 模型/ 中/ 的/ 工作/ 在/ 调度/ 过程/ 中/ 存在/ 死限/ 不/ 满足/ 的/ 情况/ ,/ 为了/ 考察/ 死限/ 不/ 满足/ 的/ 严重/ 程度/ ,/ 定义/ 死限/ 丢失/ 率为/ 所有/ 丢失/ 死限/ 的/ 工作/ 数量/ 与/ 总/ 工作/ 数量/ 的/ 比值/ ./ 根据/ 以上/ 的/ 评价/ 指标/ ,/ 对/ 可/ 并行执行/ 的/ 工作/ 分别/ 采用/ EDF/ 算法/ 、/ RM/ 算法/ 以及/ PLTSF/ 算法/ 进行/ 调度/ ,/ 在/ 500/ 个/ 时间/ 片内/ 对系统/ 的/ 吞吐量/ 、/ 核/ 利用率/ 以及/ 丢失/ 死限数/ 进行/ 了/ 统计/ ./ 图/ 2/ 展示/ 了/ 在/ 3/ 种/ 情况/ 下/ ,/ 每种/ 情况/ 随机/ 输入/ 10/ 组/ 数据/ 得出/ 的/ 系统/ 吞吐量/ 的/ 平均值/ ./ 从图/ 2/ 中/ 可以/ 看出/ 在/ 负载量/ 较大/ 情况/ 下即/ Usum/ >/ m/ 时/ ,/ PLTSF/ 算法/ 系统/ 吞吐量/ 明显/ 大于/ 其他/ 两个/ 算法/ ,/ 而/ 在/ 负载量/ 较/ 小/ 的/ 情况/ 下/ 对比/ 不是/ 很/ 明显/ ,/ 因此/ 本文/ 仅/ 针对/ 在/ 负载量/ 较大/ 的/ 情况/ 下/ ,/ 统计/ 3/ 种/ 算法/ 的/ 核/ 总/ 利用率/ 和/ 死限/ 丢失/ 率/ 的/ 情况/ ,/ 分别/ 如图/ 3/ 和表/ 1/ 所示/ ./ 图/ 3/ 的/ 结果显示/ 出/ 采用/ PLTSF/ 算法/ 的/ 核/ 利用率/ 效果/ 很/ 好/ ./ 从表/ 1/ 中/ 可以/ 看出/ 任务/ 的/ 死限/ 不/ 满足/ 率/ 随着/ 时间/ 的/ 持续/ 而/ 增长/ ,/ 但/ PLTSF/ 算法/ 下/ 增长/ 的/ 趋势/ 较/ 低/ ./ 分析/ 原因/ 发现/ 由于/ EDF/ 算法/ 和/ RM/ 算法/ 都/ 是/ 针对/ 独立/ 任务模型/ 而/ 设置/ 的/ ,/ 优先级/ 是/ 根据/ 自身/ 的/ 参数/ (/ 死限/ 和/ 利用率/ )/ 来/ 决定/ 的/ ,/ 并/ 没有/ 考虑/ 任务/ 的/ 实际/ 执行/ 情况/ ,/ 有时/ 会/ 导致/ 一些/ 后面/ 的/ 任务/ 优先级/ 高而/ 没有/ 办法/ 执行/ 的/ 情况/ (/ 因为/ 前驱/ 没有/ 执行/ 完毕/ )/ ./ 而/ PLTSF/ 算法/ 从/ 一/ 开始/ 就/ 考虑/ 任务/ 在/ 实际/ 执行/ 过程/ 中/ 出现/ 的/ 延迟时间/ 以及/ 任务/ 之间/ 前后/ 执行/ 顺序/ 问题/ ,/ 所以/ 效果/ 较/ 好/ ./ 这/ 说明/ 在/ ST/ 模型/ 下/ ,/ PLTSF/ 调度/ 算法/ 比/ EDF/ 算法/ 和/ RM/ 算法/ 更加/ 合适/ ./ 表/ 1/ 固定/ 时间/ 片内/ 3/ 个/ 算法/ 的/ 死限/ 丢失/ 率/ 统计/ 固定/ 时间/ 片/ // msPLTSF/ 算法/ EDF/ 算法/ RM/ 算法/ 1000.001200/ ./ 001800.002202000/ ./ 010120.050320/ ./ 042673000.023100/ ./ 061600.071204000/ ./ 032500.125000/ ./ 132005000.032600/ ./ 150000.200005/ 结束语/ 本文/ 考虑/ 具有/ 依赖/ 关系/ 的/ 实时/ 周期/ 任务/ 在/ 多/ 核/ Page7/ 处理器/ 上/ 的/ 调度/ 模型/ 和/ 调度/ 算法/ ,/ 该/ 模型/ 不仅/ 维持/ 了/ 任务/ 之间/ 的/ 部分/ 依赖/ 关系/ ,/ 而且/ 采用/ 了/ 基于/ 可/ 延迟时间/ 越短/ 越/ 优先/ 的/ 调度/ 策略/ ,/ 提高/ 了/ 系统/ 利用率/ 又/ 降低/ 了/ 死限/ 丢失/ 的/ 任务/ 数量/ ./ 文章/ 首先/ 描述/ 了/ ST/ 任务/ 树/ 的/ 模型/ ,/ 接着/ 定义/ 了/ 延迟时间/ 、/ 延迟/ 界限/ 以及/ 优先/ 关系/ ,/ 通过/ 将/ 模型/ 图中/ 的/ ST/ 树/ 进行/ 扩展/ ,/ 根据/ 相应/ 的/ 优先/ 执行/ 关系/ 利用/ PLTSF/ 调度/ 算法/ 将/ 其/ 映射/ 到/ 相应/ 的/ 核/ 上去/ 执行/ ./ 仿真/ 实验/ 表明/ 在/ ST/ 模型/ 下/ 的/ PLTSF/ 调度/ 算法/ 比/ RM/ 、/ EDF/ 算法/ 在/ 吞吐量/ 、/ 核/ 利用率/ 以及/ 死限/ 丢失/ 率/ 方面/ 都/ 较优/ ./ 不足之处/ 是/ 本文/ 假设/ ST/ 树/ 与/ 树/ 之间/ 无/ 任何/ 关联/ 关系/ 且/ 所选/ 算法/ 还是/ 存在/ 任务/ 死限/ 丢失/ 情况/ ./ 未来/ 方向/ 就是/ 研究/ 如何/ 将/ ST/ 树/ 之间/ 的/ 关联性/ 加入/ 到/ 调度/ 考虑/ 的/ 范围/ 当中/ 以及/ 如何/ 将/ 死限/ 丢失/ 率/ 降到/ 最低/ 限度/ ./ 

