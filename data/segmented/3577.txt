Page1EasiCache/ :/ 一种/ 基于/ 缓存/ 机制/ 的/ 低/ 开销/ 传感器/ 网络/ 代码/ 更新/ 方法/ 邱杰/ 凡/ 1/ )/ ,/ 2/ )/ 李栋/ 1/ )/ 石/ 海龙/ 1/ )/ ,/ 2/ )/ 杜文振/ 1/ )/ ,/ 2/ )/ 崔莉/ 1/ )/ 1/ )/ (/ 中国科学院计算技术研究所/ 北京/ 100190/ )/ 2/ )/ (/ 中国科学院/ 研究生院/ 北京/ 100049/ )/ 摘要/ 随着/ 应用环境/ 越来越/ 复杂多变/ ,/ 传感器/ 网络/ 需要/ 具备/ 远程/ 代码/ 更新/ 的/ 能力/ ,/ 对/ 节点/ 进行/ 灵活/ 地/ 配置/ 和/ 升级/ 以/ 适应环境/ 变化/ ./ 然而/ 过高/ 的/ 代码/ 更新/ 开销/ 一直/ 困扰/ 着/ 远程/ 代码/ 更新/ 在/ 传感器/ 网络/ 中/ 的/ 大规模/ 应用/ ./ 代码/ 更新/ 开销/ 主要/ 包括/ 存储/ 代码/ 引起/ 的/ 重组/ 开销/ 和/ 节点/ 通信/ 产生/ 的/ 传输/ 开销/ ./ 在/ 工程/ 实践/ 中/ ,/ 作者/ 发现/ 重组/ 开销/ 甚至/ 有/ 可能/ 超过/ 传输/ 开销/ 成为/ 主要/ 的/ 更新/ 开销/ ./ 为此/ 作者/ 提出/ 了/ 一种/ 基于/ 代码/ 缓存/ 机制/ 的/ 低/ 开销/ 远程/ 代码/ 更新/ 方法/ —/ —/ —/ EasiCache/ ./ 该/ 方法/ 通过/ 代码/ 缓存/ 机制/ 在/ 低功耗/ RAM/ 上/ 动态/ 保存/ 并/ 执行/ 需要/ 频繁/ 更新/ 的/ 代码/ ,/ 尽量避免/ 对/ 高功耗/ 闪存/ flash/ 进行/ 读写操作/ ,/ 从而/ 有效/ 降低/ 了/ 重组/ 开销/ ./ 此外/ ,/ 该/ 方法/ 通过/ 函数/ 级/ 代码/ 差异/ 对比/ ,/ 降低/ 了/ 传输/ 代码/ 量/ ,/ 同时/ 保存/ 了/ 代码/ 缓存/ 机制/ 所/ 需/ 的/ 程序结构/ 信息/ ,/ 进一步/ 降低/ 了/ 重组/ 开销/ ./ 实验/ 结果/ 验证/ 了/ 该/ 方法/ 在/ 降低/ 代码/ 更新/ 开销/ 方面/ 的/ 有效性/ ./ 关键词/ 传感器/ 网络/ ;/ 远程/ 代码/ 更新/ ;/ 代码/ 缓存/ 机制/ ;/ 函数/ 级/ 代码/ 差异/ 对比/ ;/ 物/ 联网/ 1/ 引言/ 在/ 一个/ 大规模/ 无人/ 值守/ 的/ 传感器/ 网络/ 中/ ,/ 受/ 节点/ 自身/ 资源/ 的/ 限制/ 和/ 周围环境/ 变化/ 的/ 影响/ ,/ 开发者/ 很难/ 在/ 开发阶段/ 全面/ 考虑/ 节点/ 在/ 部署/ 后/ 可能/ 遇到/ 的/ 各种/ 突发/ 情况/ ,/ 因此/ 需要/ 通过/ 远程/ 代码/ 更新/ 对/ 节点/ 进行/ 灵活/ 地/ 配置/ 和/ 升级/ ./ 以/ 我们/ 在/ 故宫/ 中/ 部署/ 的/ 文物/ 监测/ 传感器/ 网络/ 为例/ [/ 1/ ]/ ./ 传感器/ 节点/ 一旦/ 被/ 部署/ 到/ 展柜/ 中/ ,/ 展柜/ 即/ 被/ 封闭/ ,/ 只有/ 在/ 换展/ 时/ 才能/ 被/ 取出/ ,/ 如图/ 1/ (/ a/ )/ 所示/ ./ 其中/ 一些/ 传感器/ 节点/ 受到/ 人流/ 密度/ 及/ 展柜/ 布置/ 的/ 影响/ ,/ 频繁/ 发送数据/ ,/ 导致/ 电池/ 能量/ 迅速/ 耗尽/ ./ 利用/ 远程/ 代码/ 更新/ ,/ 可以/ 根据/ 节点/ 所/ 处/ 环境/ 的/ 不同/ ,/ 动态/ 地/ 调整/ 节点/ 上/ 的/ 休眠/ 机制/ 和/ 数据/ 保存/ 机制/ ,/ 从而/ 有效/ 地/ 延长/ 节点/ 的/ 生命周期/ ./ 我们/ 在/ 太湖/ 部署/ 的/ 蓝藻/ 监测/ 打捞/ 感/ -/ 执/ 系统/ (/ Cyber/ -/ PhysicalSystems/ )/ [/ 2/ ]/ 也/ 存在/ 类似/ 问题/ ./ 感/ -/ 执/ 节点/ 受/ 波浪/ 及/ 天气/ 影响/ 较大/ ./ 特别/ 是/ 阴雨/ 天气/ ,/ 经常/ 发生/ 数据/ 被/ 阻塞/ 的/ 情况/ ,/ 如图/ 1/ (/ b/ )/ 所示/ ./ 利用/ 远程/ 代码/ 更新/ 可以/ 在/ 降雨/ 之前/ 更新/ 路由/ 策略/ ,/ 防止/ 数据/ 阻塞/ 情况/ 的/ 发生/ ./ 另一方面/ ,/ 受/ 季节/ 变化/ 的/ 影响/ ,/ 蓝藻/ 爆发/ 的/ 程度/ 不尽相同/ ,/ 通过/ 远程/ 代码/ 更新/ 动态/ 调整/ 蓝藻/ 打捞/ 的/ 调度/ 策略/ 可以/ 提高/ 打捞/ 效率/ ./ 此外/ 诸如/ 普度/ 大学/ 的/ 球场/ 监测/ 系统/ eStadium/ [/ 3/ ]/ 、/ 香港科技大学/ 的/ 森林/ 监测/ 系统/ GreenOrbs/ [/ 4/ ]/ 等/ 传感器/ 网络/ ,/ 也/ 都/ 采用/ 了/ 不同/ 的/ 远程/ 代码/ 更新/ 方法/ 处理/ 节点/ 在/ 部署/ 以后/ 遇到/ 的/ 各种/ 突发/ 情况/ ./ 随着/ 物/ 联网/ 的/ 发展/ ,/ 作为/ 感知/ 前端/ 的/ 传感器/ 网络/ 会/ 越来越/ 多地/ 担负起/ 局部/ 数据处理/ 工作/ ./ 在/ 物/ 与/ 物/ 能够/ 智能/ 交流/ 的/ 场景/ 中/ ,/ 传感器/ 节点/ 需要/ 作为/ 信息/ 装置/ 融入/ 到/ 各种/ 物体/ 中/ ,/ 交互/ 执行/ 各种/ 智能算法/ 并/ 产生/ 有效/ 的/ 智能/ 判断/ [/ 5/ ]/ ./ 这/ 不仅/ 要求/ 节点/ 具有/ 数据/ 采集/ 和/ 发送/ 功能/ ,/ 更/ 需要/ 节点/ 能够/ 根据/ 外部/ 需求/ 变化/ ,/ 主动/ 调整/ 自身/ 功能/ ,/ 动态/ 实现/ 各种/ 算法/ ./ 因此/ 远程/ 代码/ 更新/ 势必/ 成为/ 物/ 联网/ 中/ 不可或缺/ 的/ 技术/ ./ 较/ 高/ 更新/ 开销/ 一直/ 困扰/ 着/ 远程/ 代码/ 更新/ 的/ 大规模/ 应用/ ./ 更新/ 开销/ 主要/ 包括/ 两/ 方面/ :/ 一方面/ 是/ 节点/ 之间/ 发送/ 和/ 接收/ 更新/ 代码/ 时/ 产生/ 的/ 传输/ 开销/ ;/ 另一方面/ 是/ 节点/ 上/ 重建/ 和/ 存储/ 代码/ 时/ 产生/ 的/ 重组/ 开销/ ./ 目前/ 大多数/ 远程/ 代码/ 更新/ 方法/ 对/ 如何/ 降低/ 传输/ 开销/ 进行/ 了/ 深入/ 的/ 研究/ ,/ 而/ 对/ 如何/ 降低/ 重组/ 开销/ 则/ 关注/ 较少/ ./ 以/ 增量/ 式/ 代码/ 更新/ 方法/ 为例/ ,/ 该类/ 方法/ 通过/ 只/ 传输/ 新旧/ 程序/ 的/ 差异/ 代码/ ,/ 可以/ 有效/ 地/ 降低/ 传输/ 开销/ [/ 3/ ,/ 6/ -/ 9/ ]/ ./ 该类/ 方法/ 在/ 代码/ 重组/ 时/ ,/ 通常/ 要/ 对外部/ flash/ (/ 由/ 节点/ 板载/ 的/ 扩展/ flash/ 组成/ ,/ 如/ TelosB/ [/ 10/ ]/ 节点/ 默认/ 的/ 扩展/ flash/ 为/ STM25P/ )/ 和/ 嵌入式/ 芯片/ 的/ 内部/ flash/ 进行/ 读写操作/ ./ 如表/ 1/ 所示/ ,/ 较/ 高/ 的/ flash/ 读写/ 功耗/ 导致/ 这/ 类/ 方法/ 的/ 重组/ 开销/ 超过/ 传输/ 开销/ ./ 以/ 我们/ 在/ 故宫/ 中/ 部署/ 的/ 传感器/ 网络/ 为例/ ,/ 在/ 采用/ 增量/ 式/ 代码/ 更新/ 方法/ 后/ ,/ 我们/ 将/ 传感器/ 节点/ 上/ 的/ 程序/ 从/ 2.2/ 版/ 升级/ 至/ 2.3/ 版/ 需要/ 传输/ 1560/ 字节/ 更新/ 代码/ ,/ 通过/ 一个/ 电流/ 检测/ 放大/ 电路/ 测量/ 节点/ 上/ 存储器/ 读写操作/ 的/ 电流/ 、/ 电压/ 和/ 时间/ ,/ 并/ 计算/ 开销/ ./ 在/ 这个/ 过程/ 中/ ,/ 传输/ 能量/ 开销/ 为/ 19.4/ mJ/ ,/ 而/ 重组/ 开销/ 竟/ 达到/ 35.7/ mJ/ ,/ 其中/ 读写/ flash/ 产生/ 的/ 开销/ 占/ 到/ 重组/ 开销/ 的/ 98.2/ %/ 以上/ ./ 表/ 1TelosB/ 节点/ 存储器/ 读写/ 1000Bytes/ 数据/ 的/ 平均/ 开销/ 读/ 操作/ 平均/ 开销/ // μ/ J/ 写/ 操作/ 平均/ 开销/ // μ/ J/ 读/ 外部/ flash1015/ 写/ 外部/ flash/ / 2458/ 读/ 内部/ flash785/ 写/ 内部/ flash1850/ 读/ RAM/ </ 50/ 写/ RAM126/ 注/ :/ / 写/ flash/ 操作/ 之前/ 需要/ 进行/ 擦除/ 操作/ ,/ 因此/ 写/ flash/ 开销/ 包含/ 擦除/ flash/ 的/ 开销/ ./ 从表/ 1/ 可知/ ,/ 使用/ 低功耗/ RAM/ 代替/ 高功耗/ flash/ 存储/ 代码/ 可以/ 有效/ 降低/ 重组/ 开销/ ./ 但是/ 由于/ RAM/ 空间/ 有限/ ,/ 一般/ 不/ 可能/ 将/ 所有/ 需要/ 更新/ 的/ 代码/ 都/ 放入/ RAM/ 中/ ,/ 只能/ 将/ 一部分/ 需要/ 频繁/ 更新/ 的/ 代码/ 放入/ ,/ 然而/ 如何/ 确定/ 需要/ 频繁/ 更新/ 的/ 代码/ 目前/ 尚未/ 有/ 相关/ 研究/ ./ 当前/ 可供参考/ 的/ 做法/ 是/ 由/ 开发者/ 在/ 编程/ 阶段/ 指定/ 放入/ RAM/ 中/ 的/ 代码/ ./ 这种/ 做法/ 仍然/ 是/ 以/ 简单/ 的/ 传感器/ 节点/ 作为/ 应用/ 对象/ ,/ 没有/ 考虑/ 在/ 物/ 联网/ 中/ 节点/ 可能/ 由于/ 外界/ 应用/ 需求/ 的/ 变化/ 而/ 频繁/ 地/ 调整/ 自身/ 功能/ ,/ 从而/ 改变/ 最初/ 程序/ 中/ 各/ 部分/ 代码/ 更新/ 的/ 频度/ :/ 一部分/ 保存/ 在/ 内部/ flash/ 中/ 原本/ 不/ 需要/ 更新/ 的/ 代码/ 开始/ 进行/ 频繁/ 更新/ ,/ 引起/ 大量/ 的/ 读写/ flash/ 操作/ ;/ 而/ 一部分/ 保存/ 在/ RAM/ 中/ 原本/ 需要/ 频繁/ 更新/ 的/ 代码/ 则/ 很/ 长时间/ 不/ 进行/ 更新/ ,/ 却/ 占据/ Page3/ 着/ 有限/ 的/ RAM/ 空间/ ./ 针对/ 这个/ 问题/ ,/ 我们/ 设计/ 了/ 一种/ 基于/ 代码/ 缓存/ 的/ 低/ 开销/ 远程/ 代码/ 更新/ 方法/ ,/ EasiCache/ ./ 该/ 方法/ 在/ RAM/ 上/ 模拟出/ 一块/ 代码/ 缓存/ 区域/ 保存/ 需要/ 频繁/ 更新/ 的/ 代码/ ./ 这种/ 代码/ 缓存/ 同/ 传统意义/ 上/ 的/ 高速缓存/ (/ Cache/ )/ 相似/ ,/ 同样/ 基于/ 代码/ 的/ 局部性/ 原理/ :/ 通常/ 外部/ 物理/ 世界/ 的/ 需求/ 是/ 渐变/ 的/ ,/ 因此/ 我们/ 假设/ 对/ 代码/ 的/ 修改/ 具有/ 局部性/ ./ 即/ 对/ 完成/ 某个/ 功能/ 的/ 若干个/ 函数/ (/ function/ )/ 在/ 一段时间/ 内/ 需要/ 根据/ 外界/ 需求/ 的/ 变化/ 连续/ 地/ 进行/ 更新/ ;/ 不同之处/ 在于/ ,/ 代码/ 缓存/ 机制/ 并/ 不是/ 以/ 提高/ 程序/ 的/ 执行/ 效率/ 为/ 目的/ ,/ 而是/ 利用/ flash/ 与/ RAM/ 阶梯式/ 的/ 读写/ 功耗/ 差异/ ,/ 动态/ 地/ 使用/ 低功耗/ 的/ RAM/ 保存/ 并/ 执行/ 需要/ 频繁/ 更新/ 的/ 代码/ ,/ 避免/ 对/ 高功耗/ 的/ flash/ 进行/ 读写操作/ ,/ 从而/ 有效/ 降低/ 重组/ 开销/ ./ 另一方面/ ,/ EasiCache/ 作为/ 一种/ 增量/ 式/ 代码/ 更新/ 方法/ ,/ 采用/ 了/ 函数/ 级/ 代码/ 差异/ 对比/ 技术/ ./ 该/ 技术/ 用于/ 计算/ 新旧/ 程序/ 间/ 差异/ 代码/ ,/ 通过/ 传输/ 这些/ 差异/ 代码/ 可以/ 有效/ 降低/ 代码/ 更新过程/ 中/ 的/ 传输/ 开销/ ;/ 同时/ ,/ 该/ 技术/ 可以/ 保留/ 代码/ 缓存/ 机制/ 所/ 需/ 的/ 程序结构/ 信息/ ./ 利用/ 这些/ 信息/ 我们/ 设计/ 了/ 重组/ 操作/ ,/ 可以/ 减少/ 代码/ 重建/ 次数/ ,/ 进一步/ 降低/ 重组/ 开销/ ./ 本文/ 的/ 贡献/ 主要/ 集中/ 在/ 以下/ 几个/ 方面/ :/ (/ 1/ )/ 为了/ 降低/ 重组/ 开销/ ,/ 提出/ 一种/ 代码/ 缓存/ 机制/ ,/ 可以/ 有效/ 避免/ 对/ 高功耗/ flash/ 的/ 读写操作/ ,/ 并且/ 设计/ 了/ 相应/ 的/ 替换算法/ ./ (/ 2/ )/ 为了/ 降低/ 传输/ 开销/ ,/ 提出/ 了/ 一种/ 与/ 代码/ 缓存/ 机制/ 相匹配/ 的/ 函数/ 级/ 代码/ 差异/ 对比/ 技术/ ./ 它/ 在/ 减少/ 更新/ 代码/ 传输/ 量/ 的/ 同时/ ,/ 可以/ 保留/ 程序结构/ 信息/ ./ 利用/ 这些/ 信息/ ,/ 我们/ 定义/ 了/ 3/ 种/ 重组/ 操作/ ,/ 进一步/ 降低/ 了/ 重组/ 开销/ ./ (/ 3/ )/ 为了/ 验证/ EasiCache/ 的/ 有效性/ ,/ 我们/ 设计/ 了/ 单次/ 更新/ 实验/ 和/ 连续/ 更新/ 实验/ ,/ 以/ 验证/ EasiCache/ 在/ 降低/ 更新/ 开销/ 方面/ 的/ 有效性/ ./ 本文/ 第/ 2/ 节/ 简要/ 介绍/ 研究/ 背景/ ;/ 第/ 3/ 节/ 给出/ EasiCache/ 的/ 组成/ 结构/ 与/ 执行/ 流程/ ;/ 第/ 4/ 节/ 介绍/ EasiCache/ 的/ 实现/ ;/ 第/ 5/ 节/ 设计/ 实验/ 更新/ 场景/ 并/ 分析/ 实验/ 结果/ ;/ 第/ 6/ 节/ 介绍/ 相关/ 工作/ ;/ 最后/ 在/ 第/ 7/ 节/ 给出/ 结论/ 和/ 未来/ 的/ 工作/ ./ 2/ 研究/ 背景/ 我们/ 的/ 研究/ 以/ TinyOS/ 及/ nes/ C语言/ 为/ 基础/ ,/ 并/ 以/ TelosB/ 节点/ [/ 10/ ]/ 作为/ 硬件/ 实现/ 平台/ ./ nes/ C语言/ 是/ 一种/ 扩展/ 的/ C语言/ ,/ 专门/ 针对/ 传感器/ 网络/ 特点/ 进行/ 了/ 优化/ ./ 以/ nes/ C语言/ 编写/ 的/ 程序/ 能够/ 被/ nesC/ 编译器/ 编译/ ,/ 并/ 最终/ 生成/ 嵌入式/ 芯片/ 可/ 执行/ 的/ 文件/ ./ 以/ 采用/ 嵌入式/ 芯片/ MSP430/ 的/ TelosB/ 节点/ 为例/ ,/ 图/ 2/ 显示/ 了/ 使用/ nes/ C语言/ 编写/ 的/ ./ nc/ 文件/ 如何/ 生成/ MSP430/ 可/ 执行/ 的/ ./ ihex/ 文件/ ./ 由于/ ./ nc/ 文件/ 仅仅/ 包含/ 了/ 开发者/ 的/ 应用程序/ ,/ 如果/ 直接/ 比较/ 新旧/ 程序/ 的/ ./ nc/ 文件/ 并/ 不能/ 反映/ TinyOS/ 系统/ 模块/ 的/ 变化/ ../ nc/ 文件/ 对应/ 生成/ 的/ C语言/ 文件/ app/ ./ c/ 是/ TinyOS/ 镜像/ (/ image/ )/ 文件/ ,/ 它/ 包含/ 了/ 整个/ TinyOS/ 操作系统/ 以及/ 上层/ 应用程序/ ,/ 但是/ 由于/ 很难/ 确定/ 单条/ C语言/ 代码/ 可能/ 生成/ 的/ 指令/ 类型/ 以及/ 指令/ 条数/ ,/ 通常/ 无法/ 计算/ 代码/ 的/ 修改/ 地址/ ./ 在/ EasiCache/ 中/ ,/ 将/ 保存/ 有/ 程序结构/ 信息/ 的/ 汇编/ 文件/ (/ ./ s/ )/ 作为/ 生成/ 差异/ 代码/ 的/ 比较/ 对象/ ./ 而/ 最终/ 生成/ 的/ ./ ihex/ 文件/ 将/ 作为/ 传输/ 对象/ ,/ 它/ 可以/ 被/ 嵌入式/ 芯片/ 直接/ 执行/ ./ 当前/ 大多数/ 传感器/ 节点/ 的/ 嵌入式/ 芯片/ 都/ 采用/ 了/ flash/ +/ RAM/ 的/ 存储/ 结构/ ./ 以/ TelosB/ 节点/ 为例/ ,/ MSP430/ 的/ 内部/ flash/ 与/ RAM/ 统一/ 编址/ ,/ 表/ 2/ 显示/ 了/ 一种/ 典型/ 的/ MSP430/ 存储/ 地址/ 空间/ ①/ ./ 内部/ flash/ (/ 48KB/ )/ RAM/ (/ 10KB/ )/ (/ informationmemory/ )/ (/ bootmemory/ )/ RAM/ (/ 对映/ RAM/ )/ ①/ MSP430F15x/ ,/ MSP430F16x/ ,/ MSP430F161xMixedSignallit/ // ds/ // symlink/ // msp430f1611/ ./ pdfPage4/ 默认/ 情况/ 下/ ,/ ./ ihex/ 文件/ 中/ 的/ 代码段/ (/ ./ text/ 段/ )/ 被/ 放入/ 0x4000/ 到/ 0xFFFF/ 的/ 内部/ flash/ 中/ ,/ 全局变量/ 段/ (/ 包括/ ./ data/ 段/ 和/ ./ bss/ 段/ )/ 被/ 放入/ 0x1100/ 到/ 0x38FF/ 的/ RAM/ 中/ ./ 如果/ 代码段/ 大小/ 超出/ 内部/ flash/ 容量/ ,/ 则/ 需要/ 将/ 代码/ 放入/ 外部/ flash/ 中/ ./ 3EasiCache/ 概述/ 图/ 3/ 给出/ 了/ EasiCache/ 的/ 组成/ 结构/ ,/ 它/ 主要/ 由/ 在/ 计算机/ 端/ 执行/ 的/ 生成/ 更新/ 脚本/ (/ deltascript/ )/ 以及/ 节点/ 上/ 运行/ 的/ 代码/ 缓存/ 机制/ 两/ 部分/ 组成/ ./ 生成/ 更新/ 脚本/ 主要/ 在/ 计算机/ 端/ 实现/ ,/ 包括/ 计算/ 函数/ 级/ 的/ 差异/ 代码/ 以及/ 定义/ 3/ 种/ 重组/ 操作/ ./ 通过/ 传输/ 包含/ 差异/ 代码/ 及/ 重组/ 操作/ 的/ 更新/ 脚本/ ,/ EasiCache/ 实现/ 了/ 增量/ 式/ 代码/ 更新/ ./ 待/ 更新/ 节点/ 将/ 更新/ 脚本/ 下载/ 到/ RAM/ 中/ 的/ 函数/ 组装/ 区/ (/ functionassembler/ )/ ,/ 并/ 根据/ 更新/ 脚本/ 中/ 的/ 重组/ 操作/ ,/ 将/ 差异/ 代码/ 与/ 旧/ 函数/ 代码/ 进行/ 组合/ 后/ 生成/ 新/ 函数/ 的/ 代码/ ./ 随后/ 使用/ 替换算法/ 判断/ 当前/ 新/ 生成/ 的/ 函数/ 是否/ 需要/ 保存/ 在/ 代码/ 缓存/ 中/ ./ 如果/ 需要/ ,/ 则/ 将/ 替换/ 出/ 的/ 若干/ 函数/ 回写/ 至/ 内部/ flash/ ;/ 否则/ ,/ 新/ 函数/ 直接/ 写入/ 内部/ flash/ ./ 最后/ 节点/ 发送/ 携带/ 有/ 当前/ 新/ 函数/ 奇偶校验/ 码/ 的/ 应答/ 消息/ ,/ 请求/ 继续/ 更新/ 函数/ ./ 如果/ 没有/ 函数/ 再/ 需要/ 更新/ ,/ 则/ 整个/ 程序/ 的/ 代码/ 更新过程/ 结束/ ,/ 节点/ 开始/ 执行/ 新/ 程序/ ./ 4EasiCache/ 的/ 设计/ 与/ 实现/ 本/ 节/ 主要/ 由/ 4.1/ 节/ 介绍/ 的/ 生成/ 更新/ 脚本/ 和/ 4.2/ 节/ 介绍/ 的/ 代码/ 缓存/ 机制/ 两/ 部分/ 组成/ ./ 前者/ 主要/ 解决/ 传输/ 开销/ 过高/ 的/ 问题/ ,/ 后者/ 主要/ 解决/ 重组/ 开销/ 过高图/ 4EasiCache/ 执行/ 流程图/ 的/ 问题/ ./ 4.1/ 更新/ 脚本/ 的/ 生成/ 在/ 计算/ 差异/ 代码/ 之前/ ,/ 首先/ 确定/ 哪些/ 函数/ 需要/ 更新/ ./ EasiCache/ 采用/ 二级/ 比较/ 机制/ ,/ 即/ 通过/ 比/ 对/ 新旧/ 代码/ 的/ 奇偶校验/ 码/ 和/ MD4/ 码/ 的/ 方式/ 确定/ 需要/ 更新/ 的/ 函数/ ./ 首先/ 对/ 旧/ 程序/ 中/ 的/ 所有/ 函数/ 分别/ 生成/ 奇偶校验/ 码/ 以及/ MD4/ 码/ ,/ 并/ 对/ 旧/ 程序/ 本身/ 再/ 生成/ 一次/ 奇偶校验/ 码/ 和/ MD4/ 码/ ./ 由于/ 生成/ MD4/ 码/ 的/ 计算/ 开销/ 较大/ ,/ 当/ 获得/ 新/ 程序/ 的/ 代码/ 后/ ,/ 并/ 不/ 立即/ 生成/ 新/ 程序/ 的/ MD4/ 码/ ,/ 而是/ 首先/ 生成/ 新/ 程序/ 的/ 奇偶校验/ 码/ ./ 对/ 新旧/ 程序/ 的/ 奇偶校验/ 码/ 进行/ 比较/ ,/ 如果/ 不同/ ,/ 直接/ 开始/ 比较/ 新旧/ 程序/ 中/ 的/ 各个/ 函数/ ;/ 否则/ 计算/ 新/ 程序/ 的/ MD4/ 码/ ,/ 继续/ 与/ 旧/ 程序/ 的/ MD4/ 码/ 进行/ 比较/ ./ 新旧/ 函数/ 的/ 比较/ 与/ 新旧/ 程序/ 的/ 比较/ 类似/ ./ 首先/ 将/ 新/ 程序/ 中/ 每个/ 函数/ 的/ 奇偶校验/ 码/ 与/ 旧/ 程序/ 中/ 对应/ EasiCache/ 中/ 的/ 代码/ 缓存/ 机制/ 运行/ 在/ 节点/ 上/ ,/ 由/ 代码/ 缓存/ 初始化/ 、/ 函数/ 的/ 二次/ 调用/ 、/ 空闲/ 空间/ 管理/ 以及/ 替换算法/ 4/ 部分/ 组成/ ./ 代码/ 缓存/ 初始化/ 使/ 开发者/ 有/ 机会/ 在/ 编程/ 阶段/ 预先/ 将/ 代码/ 以/ 函数/ 为/ 单位/ 放入/ 代码/ 缓存/ 中/ ./ 函数/ 的/ 二次/ 调用/ 保证/ 了/ 函数/ 在/ 重新/ 定位/ 后/ 仍/ 能够/ 被/ 正确/ 地/ 调用/ ./ 空闲/ 空间/ 管理/ 则/ 是/ 为了/ 提高/ 存储空间/ 利用率/ ,/ 通过/ 空闲/ 空间/ 列表/ 重新/ 释放/ 代码/ 重复/ 占用/ 的/ 存储空间/ ./ 替换算法/ 主要/ 考虑/ 当/ 代码/ 缓存/ 耗尽/ 时/ ,/ 采用/ 何种/ 策略/ 选择/ 回写/ 到/ 内部/ flash/ 中/ 的/ 函数/ ./ 节点/ 部署/ 之前/ ,/ 开发者/ 通常/ 可以/ 预见/ 部分/ 需要/ 频繁/ 更新/ 的/ 代码/ ./ 通过/ 代码/ 缓存/ 初始化/ 将/ 这部分/ 代码/ 预先/ 保存/ 在/ 代码/ 缓存/ 中/ ./ 图/ 4/ 给出/ 了/ 在/ 节点/ 部署/ 之后/ ,/ 对/ 节点/ 进行/ 代码/ 更新/ 的/ 执行/ 流程/ ./ 首先/ 在/ 计算机/ 端/ 确定/ 需要/ 更新/ 的/ 差异/ 函数/ ,/ 计算/ 新旧/ 函数/ 间/ 的/ 差异/ 代码/ 并/ 生成/ 相应/ 的/ 重组/ 操作/ ./ 随后/ 计算机/ 通过/ 串口/ 将/ 包含/ 函数/ 差异/ 代码/ 与/ 重组/ 操作/ 的/ 函数/ 更新/ 脚本/ (/ deltascript/ )/ 后发/ 往网/ 关节点/ ./ 网/ 关节点/ 收到/ 更新/ 脚本/ 之后/ ,/ 以/ 无线/ 多/ 跳/ (/ multi/ -/ hop/ )/ 方式/ 将/ 更新/ 脚本/ 发往/ 待/ 更新/ 节点/ ./ Page5/ 函数/ 的/ 奇偶校验/ 码/ 进行/ 比较/ ,/ 如果/ 不同/ ,/ 则/ 确定/ 需要/ 更新/ 的/ 函数/ ;/ 然后/ 对/ 所有/ 奇偶校验/ 码/ 相同/ 的/ 函数/ 分别/ 生成/ MD4/ 码/ ,/ 继续/ 比较/ ./ 在/ 确定/ 需要/ 更新/ 的/ 函数/ 之后/ ,/ 可以/ 直接/ 计算/ 新旧/ 函数/ 之间/ 的/ 差异/ 代码/ ./ 我们/ 使用/ Python/ 语言/ 编写/ 计算/ 差异/ 代码/ 的/ 程序/ ./ 输入/ 为/ 新旧/ 程序/ 的/ 汇编/ 文件/ (/ app/ ./ s/ )/ ;/ 输出/ 为/ 汇编语言/ 组成/ 的/ 差异/ 代码/ 文件/ (/ Diff/ ./ s/ )/ ./ 差异/ 代码/ 文件/ (/ Diff/ ./ s/ )/ 中/ 包括/ :/ 以/ 函数/ 为/ 单位/ 的/ 新旧/ 程序/ 的/ 差异/ 代码/ ,/ 差异/ 代码/ 距离/ 函数/ 第一条/ 指令/ 的/ 指令/ 偏移/ 数/ 以及/ 需要/ 进行/ 的/ 重组/ 操作/ ./ Diff/ ./ s/ 文件/ 内容/ 如图/ 5/ 所示/ ./ main/ :/ call/ #__/ nesc/ _/ atomic/ _/ start/ // / 4/ _/ Rep/ / // // / / // 中/ 的/ 数字/ 表示/ 相对/ 于/ 函数/ 第一条/ 指令/ 的/ 指令/ 偏移/ 数/ ./ 由于/ 每/ 一条/ 汇编/ 指令/ 对应/ 的/ 机器指令/ 长度/ 是/ 一定/ 的/ ,/ 所以/ 在/ 得到/ 指令/ 偏移/ 数/ 之后/ ,/ 可以/ 计算/ 得到/ 差异/ 代码/ 相对/ 于/ 函数/ 起始/ 地址/ 的/ 偏移量/ ./ Del/ 、/ Ins/ 和/ Rep/ 分别/ 表示/ 3/ 重组/ 操作/ :/ 删除/ 操作/ 、/ 插入/ 操作/ 和/ 替换/ 操作/ ./ 替换/ 操作/ 不会/ 改变/ 函数/ 的/ 大小/ ,/ 可以/ 直接/ 写入/ 新/ 代码/ 覆盖/ 旧/ 代码/ ./ 插入/ 操作/ 或/ 删除/ 操作/ 会/ 改变/ 旧/ 函数/ 的/ 大小/ ./ 由于/ 保存/ 了/ 程序/ 的/ 结构/ 信息/ ,/ 当/ 一个/ 函数/ 的/ 更新/ 仅仅/ 涉及/ 替换/ 操作/ 或/ 删除/ 操作/ 时/ ,/ 可以/ 通过/ 写入/ 无条件/ 跳转/ 指令/ (/ JMP/ )/ 或者/ 空/ 指令/ (/ NULL/ )/ 来/ 实现/ 删除/ 操作/ ,/ 并/ 通过/ 直接/ 覆盖/ 原始/ 代码/ 实现/ 替换/ 操作/ ,/ 避免/ 函数/ 的/ 代码/ 重建/ ,/ 有效/ 降低/ 重组/ 开销/ ./ 如果/ 对/ 函数/ 的/ 更新/ 包含/ 了/ 插入/ 操作/ ,/ 则/ 需要/ 对/ 这个/ 函数/ 进行/ 重建/ ./ 如图/ 2/ 所示/ ,/ Diff/ ./ s/ 文件/ 中/ 的/ 差异/ 代码/ 经过/ 链接/ 器/ (/ MSP430/ -/ ld/ )/ 链接/ 和/ 嵌入式/ 代码/ 格式/ 转换器/ (/ MSP430/ -/ objcopy/ )/ 最终/ 生成/ 嵌入式/ 芯片/ 可/ 执行/ 的/ 代码/ (/ ./ ihex/ 文件/ )/ ./ 这些/ 可/ 执行/ 的/ 代码/ 、/ 重组/ 操作/ 以及/ 修改/ 地址/ 组成/ 了/ 代码/ 更新/ 所/ 需/ 的/ 更新/ 脚本/ ./ 另外/ ,/ 需要/ 特别/ 指出/ 的/ 是/ 由于/ 上述/ 生成/ 更新/ 脚本/ 的/ 过程/ 全部/ 由/ 计算机/ 完成/ ,/ 不会/ 消耗/ 传感器/ 节点/ 的/ 能量/ ,/ 也/ 不会/ 给/ 传感器/ 网络/ 增添/ 额外/ 的/ 开销/ ./ 4.2/ 代码/ 缓存/ 机制/ 由于/ 读写/ RAM/ 与/ flash/ 的/ 功耗/ 差异/ 巨大/ ,/ EasiCache/ 通过/ 代码/ 缓存/ 机制/ 将/ 需要/ 频繁/ 进行/ 更新/ 的/ 代码/ 保存/ 在/ RAM/ 中/ ,/ 减少/ 对/ flash/ 的/ 读写操作/ ./ 4.2/ ./ 1/ 代码/ 缓存/ 初始化/ 开发者/ 可以/ 在/ 编程/ 阶段/ 将/ 特定/ 函数/ 放入/ 特殊/ 段/ ,/ 并/ 通过/ 链接/ 器/ (/ MSP430/ -/ ld/ )/ 设置/ 特殊/ 段/ 的/ 起始/ 地址/ ①/ ./ 由于/ MSP430/ 的/ RAM/ 与/ flash/ 统一/ 编址/ ,/ 通过/ 设定/ 特殊/ 段/ 的/ 地址/ ,/ 可以/ 将/ 程序/ 的/ 部分/ 函数/ 保存/ 在/ RAM/ 中/ 并/ 执行/ ./ 使用/ 属性/ (/ attribute/ )/ 对/ 需要/ 放入/ 特殊/ 段/ 的/ 函数/ 进行/ 标记/ ./ 图/ 6/ 中/ 显示/ 了/ 两个/ 被/ 标记/ 的/ 函数/ ,/ 它们/ 被/ 指定/ 存放/ 在/ 代码/ 缓存/ 区域/ (/ ./ cache/ 段/ )/ 中/ ,/ 而/ 不是/ 默认/ 的/ ./ text/ 段/ ./ 另外/ 如果/ 开发者/ 可以/ 预见到/ 若干/ 全局变量/ 未来/ 可能/ 需要/ 频繁/ 修改/ ,/ 也/ 可以/ 使用/ 相同/ 的/ 方法/ ,/ 将/ 这些/ 全局变量/ 分别/ 放入/ ./ dataram/ 段/ (/ 初始化/ 全局变量/ 段/ )/ 或者/ ./ bssram/ 段/ (/ 未/ 初始化/ 全局变量/ 段/ )/ ,/ 再/ 通过/ 设定/ 这/ 两个/ 特殊/ 段/ 的/ 地址/ 将/ 它们/ 放入/ RAM/ 中/ .__/ attribute/ __/ (/ section/ (/ "/ ./ Cache/ "/ )/ )/ staticBoot/ __/ booted/ (/ void/ )/ __/ attribute/ __/ (/ section/ (/ "/ ./ Cache/ "/ )/ )/ staticTimer0/ __/ fired/ (/ void/ )/ 由于/ RAM/ 中/ 默认/ 存放/ 了/ ./ bss/ 段/ 和/ ./ data/ 段/ ,/ 为了/ 避免/ ./ bssram/ 段/ 、/ ./ dataram/ 段/ 、/ 代码/ 缓存/ 区域/ (/ ./ cache/ 段/ )/ 、/ 函数/ 组装/ 区域/ (/ FunctionAssembler/ )/ 以及/ 管理/ 列表/ 区域/ (/ ManagementList/ )/ 与/ RAM/ 默认/ 存放/ 的/ 段/ 发生/ 地址/ 冲突/ ,/ 需要/ 进行/ 两次/ 编译/ ./ 在/ 第一次/ 编译/ 时/ ,/ 设定/ 所有/ 区域/ 和/ 段/ 位于/ 相距/ 较远/ 的/ 地址/ 上/ ./ 由于/ 代码/ 缓存/ 区域/ 、/ 函数/ 组装/ 区域/ 以及/ 管理/ 列表/ 区域/ 的/ 大小/ 是/ 我们/ 预先/ 设定/ 的/ ,/ 在/ 进行/ 一次/ 编译/ 后/ ,/ 只/ 需要/ 计算/ ./ bas/ 段/ 、/ ./ data/ 段/ 、/ ./ bssram/ 段/ 以及/ ./ dataram/ 段/ 的/ 大小/ ,/ 确定/ 所有/ 段/ 和/ 区域/ 的/ 最终/ 地址/ 后/ ,/ 再/ 进行/ 一次/ 编译/ ./ 经过/ 代码/ 缓存/ 初始化/ 后/ ,/ 内部/ flash/ 、/ 外部/ flash/ 和/ RAM/ 的/ 分配情况/ 如图/ 7/ 所示/ ./ RAM/ 中/ 地址/ 自低/ 到/ 高/ 依次/ 存放/ 了/ ./ data/ 段/ 、/ ./ bss/ 段/ 、/ ./ dataram/ 段/ 、/ ./ bssram/ 段/ 、/ 函数/ 组装/ 区域/ 、/ 管理/ 列表/ 区域/ 、/ 代码/ 缓存/ 区域/ (/ ./ cache/ 段/ )/ 以及/ 系统/ 堆栈/ ./ 4.2/ ./ 2/ 函数/ 的/ 二次/ 调用/ 执行/ 删除/ 或者/ 插入/ 操作/ 之后/ 会/ 导致/ 函数/ 代码/ 量/ 发生变化/ ./ 特别/ 是/ 执行/ 插入/ 操作/ 后/ ,/ 可能/ 会/ 增加/ 函数/ 的/ 代码/ 量/ ./ 由于/ 函数/ 是/ 连续/ 存放/ 的/ ,/ 如果/ 将/ 代码/ 量/ 增加/ 后/ 的/ 新/ 函数/ 仍/ 保存/ 到/ 旧/ 函数/ 地址/ 上/ ,/ 势必会/ 覆盖/ 与/ 它/ 相邻/ 的/ 函数/ ,/ 严重/ 时会/ 导致/ 整个/ 程序/ 崩溃/ ,/ 所以/ 必须/ 将/ 新/ 函数/ 转存/ 到/ 其它/ 地址/ 上/ ./ 转存/ 之后/ ,/ 这个/ 函数/ 的/ 入口/ 地址/ (/ entryaddress/ )/ 发生/ 改变/ ,/ ①/ GNUBinutils/ :/ loaderandlinker/ [/ Online/ ]/ ./ Available/ :/ http/ :/ Page6/ 意味着/ 对/ 这个/ 函数/ 进行/ 调用/ 的/ 所有/ 指令/ 都/ 需要/ 进行/ 更新/ ,/ 而/ 更新/ 这些/ 指令/ 可能/ 会/ 引起/ 较大/ 的/ 更新/ 开销/ ./ 为此/ 需要/ 使用/ 函数/ 的/ 二次/ 调用/ 解决/ 这个/ 问题/ :/ 调图/ 7/ 代码/ 存储/ 示意图/ 及/ 函数/ 二次/ 调用/ 示意图/ ./ 函数/ 二次/ 调用/ :/ 保存/ 在/ 代码/ 缓存/ 中/ 的/ 函数/ Boot/ _/ booted/ 地址/ 为/ 0x1230/ ./ 当/ 保存/ 在/ 内部/ flash/ 上/ 的/ 某条/ 指令/ 要/ 调用/ Boot/ _/ booted/ 函数/ 时/ ,/ 需要/ 先/ 跳转/ 到/ 指令/ 数据/ 混合/ 列表/ 中/ 的/ 调用/ 指令/ (/ 位于/ 0x112C/ 的/ 地址/ 上/ )/ ,/ 其中/ 包含/ 了/ Boot/ _/ booted/ 的/ 真实/ 地址/ ./ 再/ 由/ 这条/ 调用/ 指令/ 调用/ 保存/ 在/ 缓存/ 区域/ 中/ 的/ Boot/ _/ booted/ 函数/ ./ 如图/ 8/ 所示/ ,/ 指令/ 数据/ 混合/ 列表/ 由/ 函数/ 信息/ 数据/ 以及/ 对/ 函数/ 的/ 调用/ 指令/ 组成/ ./ 嵌入式/ 芯片/ 存储资源/ 的/ 稀缺性/ (/ 例如/ MSP430/ 的/ 存储空间/ 小于/ 64KB/ )/ 要求/ 我们/ 必须/ 尽量/ 复用/ 存储空间/ ./ 函数调用/ 指令/ 包含/ 了/ 函数/ 当前/ 的/ 存储/ 地址/ ,/ 因此/ 将/ 它/ 与/ 函数/ 的/ 信息/ 数据/ 进行/ 空间/ 复用/ ./ 函数/ 的/ 信息/ 数据/ 包含/ 了/ 函数/ 编号/ 、/ 函数/ 代码/ 量/ 以及/ 更新/ 次数/ ./ 更新/ 次数/ 指示/ 当前/ 函数/ 已/ 被/ 更新/ 的/ 次数/ ,/ 同时/ 通过/ 正负数/ 区分/ 当前/ 函数/ 是否/ 已/ 被/ 保存/ 在/ 代码/ 缓存/ 中/ (/ 正数/ 表示/ 当前/ 函数/ 保存/ 在/ 内部/ flash/ 中/ ,/ 负数/ 表示/ 保存/ 在/ 代码/ 缓存/ 中/ )/ ./ 函数/ 编号/ 3166/ -/ 1call0x1560ret48263call0x4a18ret12626/ -/ 2call0x5160ret/ 指令/ 数据/ 混合/ 列表/ 保存/ 在/ 管理/ 列表/ 区域/ 中/ ./ 列表/ 中/ 每条/ 函数调用/ 指令/ 的/ 位置/ 是/ 固定/ 的/ ,/ 如图/ 7/ 中/ ,/ 在/ 指令/ 数据/ 混合/ 列表/ 中/ 调用/ Boot/ _/ booted/ 函数/ 的/ 指令/ 地址/ 固定/ 为/ 0x112C/ ./ 当/ 某个/ 函数/ 的/ 入口/ 地址/ 发生/ 了/ 变化/ ,/ 只/ 需要/ 修改/ 指令/ 数据/ 混合/ 列表/ 中/ 调用/ 这个/ 函数/ 的/ 指令/ ,/ 而/ 不再/ 需要/ 修改/ 其他/ 对/ 这个/ 函数/ 的/ 调用/ 指令/ ./ 函数/ 的/ 二次/ 调用/ 实际上/ 是/ 一种/ 对/ 函数/ 地址/ 用/ 函数/ 时/ ,/ 并/ 不是/ 直接/ 对/ 函数/ 进行/ 调用/ ,/ 而是/ 先/ 跳转/ 到/ 指令/ 数据/ 混合/ 列表/ (/ InstrumentandDateList/ )/ ,/ 由/ 指令/ 数据/ 混合/ 列表/ 中/ 的/ 函数调用/ 指令/ 调用/ 真正/ 的/ 函数/ ,/ 调用/ 过程/ 如图/ 7/ 所示/ ./ 的/ 集中式/ 管理/ ,/ 只/ 需要/ 修改/ 指令/ 数据/ 混合/ 列表/ 中/ 的/ 一条/ 调用/ 指令/ ,/ 就/ 可以/ 完成/ 对/ 所有/ 调用/ 指令/ 的/ 修改/ ./ 函数/ 的/ 二次/ 调用/ 相当于/ 在/ 调用函数/ 时/ 增加/ 一条/ 跳转/ 指令/ ./ 在/ 实验/ 部分/ 的/ 第/ 5.3/ 节/ ,/ 我们/ 将/ 分析/ 增加/ 一次/ 跳转/ 对/ 程序执行/ 效率/ 产生/ 的/ 影响/ ./ 4.2/ ./ 3/ 空闲/ 空间/ 的/ 管理/ 函数/ 代码/ 量/ 在/ 更新/ 后/ 有/ 可能/ 增加/ ,/ 这时/ 需要/ 将/ 更新/ 后/ 的/ 函数/ 放入/ 新/ 的/ 地址/ ./ 如果/ 直接/ 将/ 新/ 函数/ 放入/ 代码/ 缓存/ 或者/ 内部/ flash/ 的/ 末尾/ 空间/ ,/ 会/ 造成/ 嵌入式/ 芯片/ 上/ 的/ 存储资源/ 被/ 迅速/ 耗尽/ ./ 为了/ 节约/ 有限/ 的/ 存储资源/ ,/ 当新/ 函数/ 被/ 放入/ 代码/ 缓存/ 或者/ 回写/ 到/ 内部/ flash/ 中时/ ,/ 可以/ 将/ 原函数/ 所/ 占用/ 的/ 空间/ 重新/ 释放/ ,/ 保存/ 其它/ 新/ 函数/ ./ 我们/ 设计/ 了/ 缓存/ 空闲/ 空间/ 列表/ (/ FreeCacheList/ )/ 和/ Flash/ 空闲/ 空间/ 列表/ (/ FreeFlashList/ )/ 管理/ 空闲/ 空间/ ,/ 并/ 将/ 这/ 两个/ 列表/ 保存/ 在/ 管理/ 列表/ 区域/ ./ 如图/ 9/ 所示/ ,/ 缓存/ 空闲/ 空间/ 列表/ 和/ Flash/ 空闲/ 空间/ 列表/ 分别/ 记录/ 了/ 代码/ 缓存/ 和/ 内部/ flash/ 中/ 空闲/ 空间/ 的/ 起始/ 地址/ 及/ 大小/ ./ 当新/ 函数/ 需要/ 重新/ 选择/ 地址/ 保存/ 时/ ,/ 可以/ 通过/ 空闲/ 空间/ 列表/ 查找/ 合适/ 的/ 存储空间/ ./ 转存/ 之后/ ,/ 需要/ 修改/ 空闲/ 空间/ 列表/ 对应/ 的/ 项/ ,/ 并/ 将/ 对应/ 的/ 原始/ 函数/ 的/ 起始/ 地址/ 和/ 函数/ 大小/ 记录/ 到/ 空闲/ 空间/ 列表/ ,/ 释放/ 对应/ 原函数/ 的/ 存储空间/ ./ Page7/ 缓存/ 空闲/ 空间/ 起始/ 地址/ 0x150080x1542140x168A86/ (/ a/ )/ 缓存/ 空闲/ 空间/ 列表/ 图/ 9/ 空闲/ 空间/ 列表/ (/ 列表/ 的/ 最后/ 一项/ 记录/ 了/ 4.2/ ./ 4/ 代码/ 缓存/ 的/ 替换/ 节点/ 接收/ 到/ 函数/ 更新/ 脚本/ 后/ ,/ 根据/ 指令/ 数据/ 混合/ 列表/ 中/ 函数/ 更新/ 次数/ 的/ 正负/ ,/ 确定/ 旧/ 程序/ 中/ 相应/ 的/ 函数/ 是否/ 已经/ 被/ 保存/ 到/ 代码/ 缓存/ 中/ ./ 如果/ 代码/ 缓存/ 已经/ 保存/ 了/ 这个/ 需要/ 更新/ 的/ 函数/ ,/ 称之为/ 命中/ ./ 将/ 需要/ 更新/ 的/ 旧/ 函数/ 代码/ 与/ 差异/ 代码/ 一起/ 放入/ 函数/ 组装/ 区域/ 进行/ 组合/ ,/ 重建/ 新/ 函数/ ./ 代码/ 缓存/ 区域/ 的/ 容量/ 通常/ 在/ 节点/ 部署/ 之前/ 确定/ ./ 其/ 确定/ 原则/ 是/ 不/ 能够/ 影响/ RAM/ 中/ ./ bss/ 段/ 、/ ./ data/ 段/ 以及/ 系统/ 堆栈/ 正常/ 使用/ ./ 如果/ 代码/ 缓存/ 即将/ 被/ 耗尽/ ,/ 而/ 重建/ 函数/ 的/ 代码/ 量/ 超出/ 了/ 代码/ 缓存/ 的/ 剩余/ 容量/ ,/ 则/ 需要/ 将/ 保存/ 在/ 缓存/ 中/ 的/ 部分/ 函数/ 回写/ 到/ 内部/ flash/ 中/ ,/ 腾出/ 空间/ 存放/ 新/ 函数/ ,/ 这个/ 过程/ 称为/ 替换/ ./ 传统/ 缓存/ 代码/ 替换算法/ 通常/ 关注/ 保存/ 在/ 缓存/ 中/ 的/ 代码/ 是否/ 被/ 执行/ ./ 如/ :/ 最近/ 最少/ 使用/ (/ LeastRecentlyUsed/ ,/ LRU/ )/ 算法/ 以/ 代码/ 被/ 执行/ 的/ 次数/ 作为/ 是否/ 替换/ 的/ 主要/ 因素/ ./ 在/ EasiCache/ 中/ ,/ 缓存/ 代码/ 的/ 替换/ 以/ 函数/ 为/ 单位/ 进行/ ,/ 如果/ 仅仅/ 以/ 函数/ 被/ 更新/ 次数/ 为/ 替换/ 的/ 主要/ 因素/ ,/ 有/ 可能/ 出现/ 这样/ 一种/ 情况/ :/ 函数/ Fm/ 每次/ 升级/ 都/ 需要/ 更新/ ,/ 命中率/ 较/ 高/ ,/ 但/ 函数/ Fm/ 代码/ 变化/ 较/ 小/ ;/ 而/ 函数/ Fn/ 被/ 更新/ 次数/ 较/ 少/ ,/ 命中率/ 较/ 低/ ,/ 但/ 发生/ 更新/ 时/ 代码/ 变化/ 较大/ ./ 这时/ 有/ 可能/ 将/ 函数/ Fn/ 替换/ 出去/ ,/ 一旦/ 对/ 函数/ Fn/ 进行/ 更新/ ,/ 仍然/ 需要/ 对/ flash/ 进行/ 大量/ 的/ 读写操作/ ./ 为此/ 我们/ 设计/ 了/ 最近/ 最少/ 变化/ 算法/ (/ LeastRecentlyChanged/ ,/ LRC/ )/ 将/ 函数/ 变化/ 次数/ 以及/ 函数/ 变化/ 的/ 程度/ 同时/ 考虑/ ./ 算法/ 中/ 的/ 相关/ 参数/ 见表/ 3/ ./ 参数/ 名/ Pold/ // Pnew/ 更新/ 前/ 的/ 旧/ 程序/ // 更新/ 后/ 的/ 新/ 程序/ ./ F/ (/ old/ ,/ i/ )/ // F/ (/ new/ ,/ i/ )/ 旧/ 程序/ // 新/ 程序/ 中/ 的/ 函数/ Fi/ ./ CRFi/ 函数/ Fi/ 的/ 变化率/ ./ Ck/ 在/ 第/ k/ 次/ 升级/ 时/ ,/ 函数/ 已/ 被/ 更新/ 的/ 次数/ ./ Rf/ (/ k/ ,/ i/ )/ 函数/ Fi/ 的/ 替换/ 因子/ ./ 决定/ 在/ 第/ k/ 次/ 升级/ 时/ 是/ a/ 比例/ 因子/ ,/ 调节/ 函数/ 变化/ 次数/ 和/ 函数/ 变化/ 程/ 首先/ 定义/ 反映/ 函数/ Fi/ 变化/ 情况/ 的/ 变化率/ CRFi/ :/ CRFi/ =/ SizeofChag/ (/ F/ (/ old/ ,/ i/ )/ ,/ F/ (/ new/ ,/ i/ )/ )/ 函数/ SizeofChag/ (/ x/ ,/ y/ )/ 计算/ x/ 更新/ 到/ y/ 发生/ 改变/ 的/ 代码/ 总量/ ./ 变化率/ CRFi/ 越大/ 说明/ 函数/ Fi/ 的/ 变化/ 程度/ 越高/ ,/ 相对/ 于/ 其它/ 函数/ 对/ 整体/ 程序/ 的/ 更新/ 贡献/ 越大/ ./ 在/ 第/ k/ 次/ 升级/ 时/ ,/ 最近/ 最少/ 变化/ (/ LRC/ )/ 算法/ 将/ 函数/ 被/ 更新/ 的/ 次数/ 和/ 函数/ 变化/ 的/ 程度/ 统一/ 考虑/ ,/ 并/ 计算/ 函数/ 在/ 第/ k/ 次/ 升级/ 时/ 的/ 替换/ 因子/ :/ 如果/ 需要/ 更新/ 的/ 函数/ Fi/ 没有/ 保存/ 在/ 代码/ 缓存/ 中/ ,/ 且/ 它/ 的/ 替换/ 因子/ Rf/ (/ k/ ,/ i/ )/ 大于/ 已经/ 保存/ 在/ 代码/ 缓存/ 中/ 的/ 若干个/ 函数/ 的/ Rf/ (/ k/ ,/ j/ )/ ,/ 则/ 需要/ 计算/ 替换/ 出/ 这/ 若干个/ 函数/ 后/ 腾出/ 的/ 缓存/ 空间/ 是否/ 足够/ 保存/ 函数/ Fi/ ./ 如果/ 可以/ ,/ 则/ 将/ 这/ 若干个/ 函数/ 回/ 写入/ 内部/ flash/ 中/ ,/ 并/ 将/ 函数/ Fi/ 保存/ 在/ 缓存/ 中/ ./ 反之/ 如果/ 仍然/ 没有/ 足够/ 的/ 缓存/ 空间/ ,/ 则/ 将/ 函数/ Fi/ 写入/ 内部/ flash/ 中/ ./ LRC/ 算法/ 的/ 核心思想/ 是/ 对/ 不/ 经常/ 发生变化/ 或者/ 变化/ 较/ 小/ 的/ 函数/ 进行/ 替换/ ,/ 而/ 尽量/ 将/ 经常/ 变化/ 或者/ 变化/ 较大/ 的/ 函数/ 保存/ 在/ 代码/ 缓存/ 中/ ./ 同时/ 为了/ 能够/ 适应/ 不同/ 更新/ ,/ 可以/ 通过/ 合理/ 设置/ 比例/ 因子/ a/ ,/ 调节/ 函数/ 被/ 更新/ 次数/ 与/ 函数/ 变化/ 程度/ 对/ 替换/ 因子/ 的/ 影响/ ./ 4.2/ ./ 5/ 代码/ 缓存/ 的/ 安全性/ 由于/ 代码/ 缓存/ 使用/ 易/ 挥发性/ 的/ RAM/ 保存/ 代码/ ,/ 当/ 节点/ 断电/ 重启/ 时/ 可能/ 导致/ RAM/ 中/ 的/ 关键/ 代码/ 丢失/ ,/ 严重/ 时会/ 使/ 程序/ 崩溃/ ,/ 因此/ 需要/ 通过/ 备份/ 代码/ 来/ 消除/ 潜在/ 的/ 程序/ 安全隐患/ ./ 如图/ 7/ 所示/ ,/ 我们/ 将/ RAM/ 中/ 代码/ 缓存/ 和/ 管理/ 列表/ 的/ 内容/ 备份/ 到/ 内部/ flash/ 中/ ,/ 将/ 内部/ flash/ 中/ ./ text/ 段/ 的/ 内容/ 备份/ 到/ 外部/ flash/ 中/ ./ 当/ 节点/ 重启/ 之后/ 首先/ 将/ 外部/ flash/ 中/ 的/ ./ text/ 段/ 内容/ 读入/ 内部/ flash/ ,/ 然后/ 将/ 内部/ flash/ 中/ 代码/ 缓存/ 和/ 管理/ 列表/ 的/ 内容/ 读入/ RAM/ 中/ ,/ 完成/ 程序/ 恢复/ ./ 为了/ 尽量避免/ 对/ flash/ 的/ 读写操作/ ,/ 并/ 不是/ 每/ 一次/ 升级/ 都/ 进行/ 代码/ 备份/ ./ 只有/ 当/ 程序/ 需要/ 进行/ 重大/ 升级/ 时/ ,/ 才/ 进行/ 代码/ 备份/ ,/ 并/ 记录/ 备份/ 程序/ 的/ 版本号/ ./ 当/ 节点/ 完成/ 程序/ 恢复/ 后/ ,/ 如果/ 发现/ 当前/ 程序/ 的/ 版本号/ 过低/ ,/ 可以/ 要求/ 计算机/ 端/ 重新/ 发送/ 最新/ 程序/ 的/ 更新/ 脚本/ ,/ 并/ 更新/ 至/ 最新/ 的/ 程序/ ./ Page85/ 实验/ 结果/ 与/ 分析/ 我们/ 设计/ 的/ 实验/ 包括/ 单次/ 更新/ 和/ 连续/ 更新/ 两种/ ./ 单次/ 更新/ 实验/ 测试/ EasiCache/ 的/ 传输/ 开销/ 以及/ 对/ 程序/ 的/ 某个/ 特定/ 部分/ 进行/ 更新/ 的/ 重组/ 开销/ ./ 连续/ 更新/ 实验/ 测试代码/ 缓存/ 机制/ 的/ 有效性/ ./ 在/ 现有/ 代码/ 更新/ 方法/ 中/ ,/ 由于/ 不/ 存在/ 代码/ 缓存/ 机制/ ,/ 因此/ 通常/ 只/ 进行/ 单次/ 更新/ 实验/ ./ 而/ 我们/ 为了/ 更好/ 地/ 验证/ 代码/ 缓存/ 机制/ 的/ 有效性/ ,/ 把/ 实验/ 重点/ 放在/ 对/ 连续/ 更新/ 场景/ 的/ 测试/ 上/ ./ 最后/ 我们/ 通过/ 实验/ 分析/ EasiCache/ 对/ 程序执行/ 效率/ 的/ 影响/ ./ 5.1/ 单次/ 更新/ 实验/ LED/ 的/ 闪烁/ 频率/ ./ 我们/ 在/ 单次/ 更新/ 时/ ,/ 设计/ 了/ 6/ 种/ 场景/ ,/ 包括/ :/ 更新/ 1/ ./ 修改/ 程序/ Blink/ 中/ 的/ 全局变量/ ,/ 改变/ 更新/ 2/ ./ 修改/ 程序/ Blink/ 中/ 的/ 单条/ 指令/ ,/ 关闭/ 一个/ LED/ ./ 更新/ 3/ ./ 在/ 程序/ Blink/ 中/ 删除/ 函数/ Blink/ _/ Boot/ _/ booted/ 中/ 的/ 连续/ 两行/ 代码/ ,/ 同时/ 删除/ 函数/ Blink/ _/ Timer0/ _/ fired/ 中/ 的/ 一行/ 代码/ ./ 更新/ 4/ ./ 在/ 程序/ Blink/ 的/ 函数/ BlinkC/ _/ Timer0/ _/ fired/ 中/ 插入/ 两行/ 代码/ ./ 更新/ 5/ ./ 在/ 程序/ Blink/ 中/ 插入/ 一个/ 控制/ LED/ 闪烁/ 模式/ 的/ 函数/ Control/ _/ LED/ _/ Pattern/ ./ 更新/ 6/ ./ 将/ 程序/ Blink/ 更新/ 为/ 程序/ CntToLed/ ./ 程序/ CntToLed/ 通过/ 3/ 个/ LED/ 显示/ 计数/ 变量/ counter/ 最后/ 3/ 位/ 的/ 值/ ./ 在/ 单次/ 更新/ 实验/ 中/ ,/ 我们/ 将/ EasiCache/ 与/ 当前/ 的/ 远程/ 代码/ 更新/ 方法/ Deluge/ [/ 11/ ]/ 、/ Elon/ [/ 12/ ]/ 以及/ Hermes/ [/ 7/ ]/ 进行/ 比较/ ./ 其中/ Deluge/ 是/ TinyOS/ 标准/ 远程/ 代码/ 更新/ 方法/ ./ Elon/ 通过/ 设定/ TinyOS/ 的/ 组件/ (/ component/ )/ 为/ 可/ 替换/ (/ replaceable/ )/ ,/ 在/ 编程/ 阶段/ 将/ 可能/ 频繁/ 更新/ 的/ 代码/ 保存/ 在/ RAM/ 中/ 并/ 执行/ ./ Hermes/ 基于/ 比/ 特级/ 差异/ 对比/ 技术/ ,/ 有效/ 降低/ 了/ 传输/ 代码/ 量/ ./ 实验/ 结果显示/ EasiCache/ 在/ 大多数/ 情况/ 下/ 优势/ 明显/ ./ 表/ 4/ 显示/ 了/ 在/ 更新/ 1/ ~/ 6/ 中/ Deluge/ 、/ Elon/ 以及/ EasiCache/ 需要/ 传输/ 的/ 代码/ 量/ ./ 观察/ 发现/ Deluge/ 的/ 传输/ 开销/ 十分/ 巨大/ ./ 这是/ 由于/ 在/ 使用/ Deluge/ 进行/ 更新/ 时要/ 传输/ 整个/ TinyOS/ 镜像/ (/ image/ )/ 以及/ 代码/ 更新/ 协议/ ./ 以/ 更新/ 1/ 为例/ ,/ 当/ 使用/ Deluge/ 进行/ 代码/ 更新/ 时/ ,/ 传输/ 的/ Blink/ 镜像/ 本身/ 仅/ 占/ 总/ 传输/ 代码/ 量/ 的/ 11.5/ %/ ,/ 而/ 真正/ 要/ 更新/ 的/ 代码/ 只/ 占/ 总/ 传输/ 代码/ 量/ 的/ 0.043/ %/ ./ Elon/ 和/ EasiCache/ 都/ 可以/ 单独/ 对/ 变量/ 进行/ 修改/ [/ 12/ ]/ ,/ 因此/ 两种/ 方法/ 在/ 更新/ 1/ 中/ 的/ 传输/ 开销/ 很/ 低/ ./ 在/ 更新/ 2/ ~/ 4/ 中/ 和/ 更新/ 6/ 中/ ,/ Elon/ 没有/ 采用/ 代码/ 差异/ 比较/ ,/ 当/ 新旧/ 程序/ 中/ 的/ 若干个/ 函数/ 不/ 同时/ ,/ 需要/ 传输/ 整个/ 函数/ ./ 而/ EasiCache/ 通过/ 函数/ 级/ 代码/ 差异/ 对比/ 只/ 需要/ 传输/ 差异/ 代码/ ,/ 因此/ 传输/ 代码/ 量/ 明显/ 少于/ Elon/ ./ 在/ 更新/ 5/ 中/ ,/ 整个/ 函数/ 被/ 插入/ 旧/ 程序/ 中/ ./ 新旧/ 程序/ 的/ 差异/ 是/ 整个/ 函数/ ,/ 因此/ EasiCache/ 与/ Elon/ 传输/ 代码/ 量/ 相同/ ./ 表/ 4/ 各种/ 更新/ 场景/ 下/ 代码/ 更新/ 所/ 需/ 传输/ 的/ 代码/ 量/ 方法/ Deluge231102311023114231162329625008Elon858624286156EasiCache814162086132/ 表/ 5/ 显示/ 了/ 在/ 更新/ 1/ ~/ 6/ 中/ ,/ Hermes/ 、/ Elon/ 以及/ EasiCache/ 的/ 重组/ 开销/ ./ 3/ 种/ 更新/ 方法/ 都/ 可以/ 独立/ 对/ 存储/ 在/ RAM/ 中/ 的/ 全局变量/ 进行/ 写改/ ,/ 在/ 更新/ 1/ 中/ 重组/ 开销/ 基本相同/ ./ Hermes/ 在/ 更新/ 代码/ 时/ ,/ 会/ 首先/ 将/ 更新/ 脚本/ 存入/ 外部/ flash/ ,/ 然后/ 将/ 重建/ 后/ 的/ 新/ 程序/ 回写/ 到/ 嵌入式/ 芯片/ 的/ 内部/ flash/ ./ 这样/ 做/ 导致/ 重组/ 效率/ 低/ ,/ 重组/ 开销/ 大/ ./ 由于/ Elon/ 采用/ 了/ 直接/ 把/ 保存/ 在/ RAM/ 上/ 的/ 函数/ 进行/ 整体/ 替换/ 的/ 策略/ ,/ 重组/ 开销/ 主要/ 来自/ 于/ 向/ RAM/ 写入/ 函数/ 代码/ ,/ 因此/ 重组/ 开销/ 较/ 小/ ./ EasiCache/ 通过/ 删除/ 操作/ 和/ 替换/ 操作/ 可以/ 在/ 不/ 重建/ 代码/ 的/ 情况/ 下/ 直接/ 对/ 函数/ 完成/ 更新/ ,/ 因此/ 在/ 更新/ 2/ 和/ 更新/ 3/ 中/ 重组/ 开销/ 明显/ 少于/ Elon/ ./ 在/ 更新/ 4/ 和/ 更新/ 6/ 中/ ,/ EasiCache/ 执行/ 插入/ 操作/ ,/ 需要/ 重建/ 函数/ 代码/ ,/ 因此/ 重组/ 开销/ 与/ Elon/ 相差/ 不大/ ./ 而/ 在/ 更新/ 5/ 中/ 由于/ 代码/ 差异/ 主要/ 是/ 整个/ 函数/ ,/ 函数/ 级/ 差异/ 对比/ 对/ 降低/ 重组/ 开销/ 效果/ 不/ 明显/ ,/ 重组/ 开销/ 与/ Elon/ 基本相同/ ./ 表/ 5/ 各种/ 更新/ 场景/ 下/ 代码/ 更新/ 所/ 需/ 的/ 重组/ 开销/ 方法/ Hermes0/ ./ 0358027.18157/ ./ 28144.68256/ ./ 712490.5/ Elon0/ ./ 03940.257/ ./ 734.86/ ./ 4796.8/ EasiCache0/ ./ 0210.140/ ./ 3636.26/ ./ 9288.5/ 在/ 单次/ 更新/ 的/ 场景/ 中/ ,/ 开发者/ 通过/ 缓存/ 初始化/ 可以/ 将/ 需要/ 更新/ 的/ 函数/ 在/ 编程/ 阶段/ 预先/ 保存/ 在/ RAM/ 中/ ./ 如果/ 设置/ 合理/ ,/ 可以/ 完全避免/ 对/ flash/ 的/ 读写操作/ ,/ 因此/ 重组/ 开销/ 较/ 低/ ./ 然而/ 在/ 一个/ 连续/ 更新/ 的/ 场景/ 中/ ,/ 开发者/ 不/ 可能/ 完全/ 预测/ 所有/ 需要/ 更新/ 的/ 函数/ ,/ 由此/ 可能/ 导致/ 对/ 内部/ flash/ 进行/ 大量/ 读写/ 操/ Page9/ 作/ ,/ 增加/ 重组/ 开销/ ,/ 因此/ 需要/ 使用/ 代码/ 缓存/ 机制/ 动态/ 保存/ 更新/ 频繁/ 的/ 函数/ ./ 5.2/ 连续/ 更新/ 实验/ 为了/ 验证/ 代码/ 缓存/ 机制/ 的/ 有效性/ ,/ 我们/ 设计/ 了/ 一个/ 连续/ 更新/ 的/ 场景/ ,/ 即当/ 节点/ 的/ 代码/ 完成/ 更新/ 之后/ ,/ 立即/ 再/ 一次/ 更新/ 节点/ 上/ 的/ 程序/ ./ 如图/ 10/ 所示/ ,/ 我们/ 选取/ 4/ 个/ TinyOS/ 的/ 例子/ 程序/ :/ RadioCnt/ 、/ RadCntToLeds/ 、/ BaseStation/ 和/ BaseStation15/ ./ 4/ 以及/ 我们/ 在/ 故宫/ 传感器/ 网络/ 节点/ 上/ 的/ 程序/ :/ EasiRouter2/ ./ 2/ 图/ 10/ 连续/ 更新/ 流程图/ 按照/ 图/ 10/ 所示/ 的/ Order/ (/ A/ ,/ B/ ,/ C/ ,/ D/ ,/ E/ ,/ F/ ,/ A/ ,/ G/ ,/ H/ ,/ C/ ,/ I/ )/ 顺序/ 对/ 节点/ 上/ 的/ 程序/ 进行/ 更新/ ./ 我们/ 定义/ 缓存/ 的/ 命中率/ 为/ 命中/ 函数/ 的/ 代码/ 量/ 与/ 缓存/ 容量/ 之比/ ./ 默认/ 设定/ 缓存/ 容量/ 为/ 3KB/ ,/ 比例/ 因子/ α/ =/ 0.5/ ./ 图/ 11/ 给出/ 了/ 在/ 这个/ 连续/ 更新过程/ 中/ ,/ 采用/ 最近/ 最少/ 使用/ (/ LRU/ )/ 替换算法/ 和/ 最近/ 最少/ 变化/ (/ LRC/ )/ 替换算法/ 的/ 代码/ 缓存/ 命中率/ ./ 图/ 11/ 采用/ 最近/ 最少/ 使用/ (/ LRU/ )/ 算法/ 和/ 最近/ 最少/ 变化/ 节点/ 上/ 保存/ 的/ 起始/ 程序/ 是/ RadioCnt/ ./ 由于/ 程序/ RadioCnt/ 与/ 程序/ RadCntToLeds/ 较为/ 相似/ ,/ 更新/ A/ 缓存/ 命中率/ 达到/ 了/ 较/ 高/ 的/ 95.2/ %/ ./ 这/ 也/ 说明/ 通过/ 代码/ 缓存/ 初始化/ 合理/ 地/ 安排/ 缓存/ 中/ 的/ 代码/ ,/ 可以/ 有效/ 提高/ 缓存/ 命中率/ ./ 在/ 更新/ A/ 之前/ 没有/ 替换/ 行为/ 的/ 发生/ ,/ 所以/ 两种/ 替换算法/ 的/ 命中率/ 相同/ ./ 在/ 更新/ A/ 之后/ ,/ 缓存/ 已经/ 无法/ 容纳/ 所有/ 需要/ 更新/ 的/ 函数/ ,/ 部分/ 函数/ 需要/ 被/ 替换/ 出/ 并/ 回/ 写/ 到/ 内部/ flash/ 中/ ./ 程序/ RadCntToLeds/ 与/ 程序/ BaseStation/ 相似/ 度/ 较/ 低/ ,/ 导致/ 更新/ B/ 的/ 命中率/ 明显/ 下降/ ./ 程序/ BaseStation/ 与/ 程序/ BaseStation15/ ./ 4/ 较为/ 相似/ ,/ 差/ 和/ EasiRouter2/ ./ 3/ 作为/ 实验/ 更新/ 程序/ ./ 程序/ RadioCnt/ 与/ 程序/ RadCntToLeds/ 类似/ ,/ 后者/ 加入/ 了/ 通过/ LED/ 显示/ 计数/ 变量/ counter/ 最后/ 三位/ 的/ 功能/ ./ 程序/ BaseStation15/ ./ 4/ 与/ 程序/ BaseStation/ 都/ 具有/ 监测/ 无线/ 信道/ 数据/ 并/ 向/ 串口/ 转发/ 的/ 功能/ ,/ 后者/ 增加/ 了/ 接收/ 串口/ 数据/ 以及/ 通过/ 无线/ 信道/ 发送数据/ 的/ 功能/ ./ 程序/ EasiRouter2/ ./ 3/ 最为/ 复杂/ ,/ 加入/ 了/ 实用/ 的/ 路由/ 机制/ ./ 程序/ EasiRouter2/ ./ 3/ 是/ 程序/ EasiRouter2/ ./ 2/ 的/ 升级/ 版本/ ,/ 不同之处/ 在于/ 前者/ 拥有/ 更/ 完善/ 的/ 休眠/ 重启/ 机制/ ./ 异/ 在于/ 增加/ 了/ 串口/ 和/ 射频/ 发送数据/ 的/ 功能/ ,/ 因此/ 更新/ C/ 的/ 命中率/ 相较/ 于/ B/ 有所/ 回升/ ,/ 但/ 仍然/ 偏低/ ./ 从/ 更新/ B/ 和/ 更新/ C/ 可以/ 看出/ ,/ LRC/ 算法/ 的/ 命中率/ 明显/ 高于/ LRU/ 算法/ 的/ 命中率/ ,/ 这是/ 由于/ LRC/ 算法/ 能够/ 将/ 那些/ 变化/ 比较/ 大且/ 更新/ 频繁/ 的/ 函数/ 尽量/ 保存/ 在/ 代码/ 缓存/ 中/ ,/ 而/ LRU/ 算法/ 只/ 将/ 函数/ 被/ 更新/ 次数/ 作为/ 唯一/ 的/ 考虑/ 因素/ ./ 在/ 更新/ D/ 中/ ,/ 程序/ BaseStation/ 与/ 程序/ EasiRouter2/ ./ 2/ 差异/ 较大/ ,/ 需要/ 更新/ 的/ 函数/ 较/ 多/ ,/ 命中率/ 下降/ 到/ 80/ %/ 以下/ ./ 在/ 更新/ D/ 中/ ,/ LRU/ 算法/ 的/ 命中率/ 高于/ LRC/ 算法/ ./ 这是/ 由于/ LRC/ 算法/ 在/ 上/ 一次/ 更新/ 中/ (/ 更新/ C/ )/ 替换/ 出/ 了/ 若干/ 更新/ 比较/ 频繁/ 但是/ 变化/ 程度/ 较/ 小/ 的/ 函数/ (/ 约/ 占/ 缓存/ 总量/ 的/ 8.1/ %/ )/ ,/ 而/ 在/ 更新/ D/ 中/ 这些/ 函数/ 成为/ 了/ 被/ 更新/ 的/ 对象/ ,/ 导致/ LRC/ 算法/ 的/ 命中率/ 降到/ 了/ 73.14/ %/ ./ 这种/ 情况/ 同样/ 发生/ 在/ 更新/ H/ 和/ 更新/ I/ 中/ ./ 在/ 更新/ E/ ~/ G/ 和/ 更新/ C/ 中/ ,/ LRC/ 算法/ 的/ 命中率/ 普遍/ 较/ 高/ ./ 特别/ 是/ 在/ 更新/ G/ 中/ ,/ LRU/ 算法/ 的/ 命中率/ 下降/ 到/ 了/ 72.39/ %/ ,/ 而/ LRC/ 算法/ 的/ 命中率/ 仍然/ 保持/ 在/ 85/ %/ 以上/ ./ 总体而言/ ,/ LRC/ 算法/ 的/ 平均/ 命中率/ 较/ 高/ ,/ 达到/ 了/ 87.5/ %/ ;/ LRU/ 算法/ 的/ 平均/ 命中率/ 为/ 82.2/ %/ ./ 表/ 6/ 列出/ 了/ 使用/ LRC/ 算法/ (/ α/ =/ 0.5/ // α/ =/ 0.95/ )/ 和/ LRU/ 算法/ 对/ 上述/ 6/ 个/ 程序/ 分别/ 进行/ 20/ 次/ 、/ 30/ 次/ 、/ 45/ 次/ 、/ 60/ 次/ 、/ 100/ 次/ 以及/ 150/ 次连续/ 随机/ 更新/ 的/ 平均/ 命中率/ (/ 每次/ 测试/ 均/ 重复/ 50/ 遍/ ,/ 取/ 平均值/ )/ ./ 当/ α/ =/ 0.5/ 时/ ,/ 除了/ 在/ 连续/ 更新/ 20/ 次时/ ,/ LRC/ 算法/ 的/ 平均/ 命中率/ 略低/ 之外/ ;/ 在/ 大多数/ 情况/ 下/ ,/ LRC/ 算法/ 的/ 平均/ 命中率/ 均/ 高于/ LRU/ 算法/ ./ 当/ α/ =/ 0.95/ 时/ ,/ LRC/ 算法/ 的/ 命中率/ 已/ 与/ LRU/ 算法/ 的/ 命中率/ 相差/ 不大/ ./ 由式/ (/ 2/ )/ 可知/ ,/ 当/ α/ 趋近/ 于/ 1/ 时/ 表示/ 函数/ 更新/ 次数/ Page10Ck/ 将/ 在/ 越来越/ 大/ 的/ 程度/ 上/ 决定/ 替换/ 因子/ Rf/ (/ k/ ,/ i/ )/ ,/ 当/ α/ =/ 1/ 时/ ,/ LRC/ 替换算法/ 与/ LRU/ 替换算法/ 等价/ ./ 算法/ LRC/ (/ α/ =/ 0.5/ )/ 84.4185/ ./ 6085.2588/ ./ 7984.1886/ ./ 54LRC/ (/ α/ =/ 0.95/ )/ 83.3481/ ./ 2280.2380/ ./ 1578.1481/ ./ 37LRU84/ ./ 7182.5280/ ./ 4480.5279/ ./ 4481.23/ 表/ 7/ 和表/ 8/ 列出/ 了/ EasiCache/ 、/ Hermes/ [/ 7/ ]/ 和/ TinyModule/ -/ Link/ [/ 13/ ]/ 3/ 种/ 更新/ 方法/ 按照/ Order/ 更新过程/ 中/ 对/ flash/ 进行/ 读写操作/ 的/ 情况/ ./ Hermes/ 的/ 重组/ 过程/ 包括/ 将/ 更新/ 脚本/ 写入/ 外部/ flash/ ,/ 与/ 保存/ 在/ 外部/ flash/ 的/ 原始/ 程序/ 进行/ 组合/ 后/ 产生/ 新/ 程序/ ,/ 最后/ 将/ 新/ 程序/ 的/ 代码/ 整体/ 从/ 外部/ flash/ 读出/ 并/ 写入/ 内部/ flash/ ./ 实际上/ 新/ 程序/ 的/ 代码/ 量/ 决定/ 了/ Hermes/ 的/ 重表/ 7/ 完成/ 更新/ 需要/ 从/ flash/ 读取/ 的/ 代码/ 量/ Hermes/ 读/ 外部/ flash131481588416826181921925012026181921588419250TinyModule/ -/ Link/ 读/ 外部/ flash14281392198628142518890441025225014EasiCache/ 读/ 外部/ flash/ -/ -/ -/ -/ -/ -/ -/ -/ -/ 表/ 8/ 完成/ 更新/ 需要/ 写入/ flash/ 的/ 代码/ 量/ Hermes/ 写/ 外部/ flash15624614201029461596926452826404872TinyModule/ -/ Link/ 写/ 外部/ flash14281392198628141890890441025225014EasiCache/ 写/ 外部/ flash/ -/ -/ -/ -/ -/ -/ -/ -/ -/ EasiCache/ 为了/ 进一步/ 降低/ 重组/ 开销/ ,/ 使用/ 低功耗/ RAM/ 动态/ 保存/ 并/ 执行/ 部分/ 需要/ 频繁/ 更新/ 的/ 函数/ ,/ 可以/ 有效/ 减少/ 对/ 内部/ flash/ 的/ 读写操作/ ./ 同时/ 由于/ EasiCache/ 使用/ RAM/ 保存/ 更新/ 脚本/ ,/ 避免/ 了/ 对外部/ flash/ 进行/ 读写/ 的/ 操作/ ,/ 因此/ 表/ 7/ 和表/ 8/ 中未/ 列出/ EasiCache/ 对外部/ flash/ 进行/ 读写操作/ 的/ 代码/ 量/ ./ Hermes/ 不/ 需要/ 对/ 内部/ flash/ 进行/ 读/ 操作/ ,/ 故/ 也/ 未/ 列出/ ./ 在/ 更新/ B/ 和/ 更新/ F/ 中/ ,/ 由于/ EasiCache/ 的/ 代码/ 缓存/ 中/ 保存/ 了/ 所有/ 需要/ 更新/ 的/ 函数/ ,/ 因此/ 不再/ 需要/ 向/ 内部/ flash/ 读取/ 这些/ 函数/ 的/ 原始/ 代码/ ,/ 对/ 内部/ flash/ 的/ 读取/ 量/ 降为/ 0/ ./ 而/ 在/ 其他/ 更新/ 中/ EasiCache/ 读取/ 内部/ flash/ 的/ 代码/ 量/ 也/ 远远/ 小于/ TinyModule/ -/ Link/ ./ 另外/ ,/ EasiCache/ 可以/ 在/ RAM/ 上/ 直接/ 执行/ 函数/ 代码/ ,/ 不再/ 像/ TinyModule/ -/ Link/ 需要/ 将/ 所有/ 更新/ 组/ 开销/ ,/ 导致/ 即使/ 新/ 程序/ 相较/ 于/ 原始/ 程序/ 变化/ 较/ 小/ ,/ 也/ 有/ 可能/ 引起/ 较大/ 的/ 编程/ 开销/ ./ 如/ 在/ 更新/ F/ 中/ ,/ 程序/ EasiRouter2/ ./ 3/ 相较/ 于/ 程序/ RadioCnt/ 功能/ 十分/ 完善/ ,/ 从/ 更新/ 脚本/ 的/ 尺寸/ 上/ 反映/ 了/ 对/ 程序/ EasiRouter2/ ./ 3/ 进行/ 较/ 小/ 的/ 修改/ 就/ 可以/ 完成/ 更新/ ,/ 但是/ 将/ 新/ 程序/ RadioCnt/ 从/ 外部/ flash/ 搬移到/ 内部/ flash/ 仍然/ 使/ 更新/ F/ 的/ 重组/ 开销/ 维持/ 在/ 一个/ 较/ 高/ 的/ 水平/ ./ 另/ 一种/ 更新/ 方法/ TinyModule/ -/ Link/ 充分考虑/ 了/ 这种/ 代码/ 搬移/ 造成/ 的/ 高/ 开销/ 问题/ ,/ 提出/ 将/ 代码/ 组合/ 过程/ 放入/ 低功耗/ 的/ RAM/ 中/ 进行/ ,/ 外部/ flash/ 仅/ 存放/ 更新/ 脚本/ [/ 13/ ]/ ./ 更新/ 时/ 需要/ 将/ 更新/ 脚本/ 读出/ 与/ 保存/ 在/ 内部/ flash/ 中/ 的/ 原始/ 代码/ 进行/ 组合/ ./ 同时/ 由于/ TinyModule/ -/ Link/ 也/ 是/ 以/ 函数/ 为/ 单位/ 进行/ 更新/ ,/ 所以/ 更新/ 时仅/ 需/ 从/ 内部/ flash/ 中/ 读取/ 需要/ 更新/ 的/ 函数/ 代码/ ./ 的/ 函数/ 代码/ 回写/ 到/ 内部/ flash/ 中/ ,/ 因此/ 写入/ 内部/ flash/ 的/ 代码/ 量/ 也/ 明显/ 少于/ TinyModule/ -/ Link/ ./ 在/ 表/ 9/ 中/ 列出/ 了/ Hermes/ 及/ TinyModule/ -/ Link/ 与/ EasiCache/ 的/ 重组/ 开销/ 之比/ ./ 可以/ 看出/ EasiCache/ 的/ 重组/ 开销/ 明显/ 小于/ 另外/ 两种/ 更新/ 方法/ ./ 例如/ 在/ 更新/ F/ 中/ ,/ Hermes/ 和/ TinyModule/ -/ Link/ 的/ 重组/ 开销/ 分别/ 达到/ 了/ EasiCache/ 的/ 763.3/ 倍/ 和/ 91.03/ 倍/ ./ 这/ 也/ 表明/ 在/ EasiCache/ 中/ ,/ 程序/ 更新/ 代码/ 量/ 成为/ 影响/ 重组/ 开销/ 的/ 主要/ 因素/ ./ 当/ 更新/ 代码/ 量/ 增大/ 时/ ,/ EasiCache/ 的/ 重组/ 开销/ 也/ 随之/ 增加/ ./ 例如/ 在/ 更新/ I/ 中/ ,/ 新/ 生成/ 函数/ 的/ 代码/ 量/ 远远/ 超出/ 了/ 代码/ 缓存/ 能够/ 容纳/ 的/ 极限/ ,/ 只能/ 向/ 内部/ flash/ 回写/ 大量/ 代码/ ,/ 这/ 两种/ 更新/ 方法/ 与/ EasiCache/ 的/ 重组/ 开销/ 之/ 比/ 下降/ 到/ 6.7/ 和/ 3.29/ ./ Page11/ 表/ 9Hermes/ 及/ TinyModule/ -/ Link/ 与/ EasiCache/ 的/ 重组/ 开销/ 之比/ Hermes/ :/ EasiCache35/ ./ 3312.3734/ ./ 9213.2020/ ./ 96763.610/ ./ 218.846/ ./ 70TinyModule/ -/ Link/ :/ EasiCache8/ ./ 644.668/ ./ 335.245/ ./ 6191.034/ ./ 872.943/ ./ 295.3/ EasiCache/ 对/ 执行/ 效率/ 的/ 影响/ 对/ 函数/ 进行/ 二次/ 调用/ 处理/ 后/ ,/ 每次/ 函数调用/ 多/ 进行/ 一次/ 跳转/ ,/ 增加/ 了/ 程序/ 的/ 复杂度/ ,/ 会/ 对/ 程序执行/ 效率/ 产生/ 影响/ ./ 以/ TelosB/ 节点/ 采用/ 的/ MSP430F1611/ 为例/ ./ 增加/ 一次函数/ 跳转/ 意味着/ 每次/ 函数调用/ 要/ 多/ 执行/ 一次/ 调用/ 指令/ (/ CALL/ )/ 和/ 一次/ 返回/ 指令/ (/ RET/ )/ ./ 图/ 12/ 给出/ 了/ 6/ 个/ 更新/ 程序/ 在/ 采用/ 函数/ 的/ 二次/ 调用/ 后/ ,/ 执行/ 效率/ 受到/ 的/ 影响/ ./ 受/ 影响/ 最大/ 的/ 是/ 程序/ BaseStation15/ ./ 4/ 和/ 程序/ BaseStation/ ,/ 执行/ 效率/ 分别/ 下降/ 了/ 9.5/ %/ 和/ 12.3/ %/ ./ 由于/ 这/ 两个/ 程序/ 的/ 大量/ 工作/ 是/ 串口/ 通信/ 和/ 射频/ 通信/ ,/ 在/ 多数/ 时间/ 里/ 需要/ 对/ 与/ 底层/ 量/ 硬件/ 相关/ 的/ 函数/ 进行/ 调用/ ,/ 函数/ 的/ 切换/ 较为/ 频繁/ ,/ 而且/ 这部分/ 函数/ 的/ 代码/ 量/ 较/ 少/ ,/ 执行/ 时间/ 较/ 短/ ,/ 因此/ CALL/ 指令/ 和/ RET/ 指令/ 所/ 消耗/ 的/ 时钟/ 周期/ 占/ 程序执行/ 总/ 的/ 时钟/ 周期/ 比重/ 较大/ ./ 当/ 增加/ 一次函数/ 跳转/ 后/ ,/ 执行/ 效率/ 受到/ 的/ 影响/ 也/ 相对/ 较大/ ./ 我们/ 在/ 故宫/ 传感器/ 网络/ 节点/ 上/ 运行/ 的/ 程序/ 需要/ 经常/ 进入/ 休眠状态/ 并/ 重启/ ,/ 对/ 与/ 底层/ 硬件/ 相关/ 的/ 函数调用/ 也/ 较/ 多/ ,/ 相对/ 于/ 另外/ 两个/ 没有/ 休眠/ 机制/ 的/ 程序/ RadioCnt/ 和/ 程序/ RadCntToLeds/ 执行/ 效率/ 受/ 影响/ 较大/ ./ 图/ 12/ 函数/ 的/ 二次/ 调用/ 对/ 程序执行/ 效率/ 的/ 影响/ 为了/ 提高/ 程序执行/ 效率/ ,/ 我们/ 可以/ 不/ 对/ 与/ 底层/ 硬件/ 相关/ 的/ 函数/ 进行/ 函数/ 二次/ 调用/ ./ 但/ 这样/ 的/ 后果/ 是/ 如果/ 这部分/ 函数/ 被/ 更新/ ,/ 则/ 可能/ 导致/ 对/ 调用/ 这部分/ 函数/ 的/ 指令/ 进行/ 大量/ 修改/ ,/ 增加/ 了/ 代码/ 更新/ 开销/ ./ 6/ 相关/ 工作/ Deluge/ [/ 11/ ]/ 是/ 较/ 早/ 的/ 代码/ 更新/ 方法/ ./ 该/ 方法/ 在/ 代码/ 无线/ 分发/ 阶段/ 需要/ 传输/ 更新/ 协议/ 和/ 整个/ TinyOS/ 镜像/ ./ 当/ 被/ 更新/ 节点/ 收到/ 新/ 代码/ 时/ 直接/ 写入/ 外部/ flash/ ./ 当/ 更新/ 代码/ 接收/ 完毕/ 后/ ,/ 通过/ Bootloader/ 将/ 代码/ 读入/ 内部/ 程序/ flash/ ,/ 进行/ 硬件/ 重启/ 完成/ 更新/ ,/ 因此/ 更新/ 开销/ 大/ ./ 针对/ Deluge/ 的/ 不足/ ,/ 文献/ [/ 14/ -/ 17/ ]/ 提出/ 了/ 不同/ 的/ 解决方案/ ./ Elon/ [/ 12/ ]/ 以/ TinyOS/ 为/ 基础/ ,/ 将/ 代码/ 以/ 组件/ (/ component/ )/ 为/ 单位/ 放入/ RAM/ 中/ 执行/ ,/ 提高/ 了/ 更新/ 效率/ ,/ 但/ 它/ 在/ 更新/ 时以/ 组件/ 作为/ 传输/ 和/ 重组/ 的/ 基本/ 单位/ ,/ 包含/ 了/ 大量/ 无关/ 代码/ ./ Kim/ 等/ 人/ [/ 13/ ]/ 提出/ 的/ TinyModule/ -/ Link/ 主要/ 考虑/ 了/ 由于/ 读写/ 外部/ flash/ 引起/ 的/ 重组/ 开销/ ,/ 将/ 新/ 程序代码/ 重建/ 全部/ 放入/ RAM/ 中/ 进行/ ,/ 但是/ 在/ 完成/ 重建/ 后/ ,/ 仍然/ 需要/ 将/ 所有/ 被/ 更新/ 的/ 函数/ 回写/ 到/ 内部/ flash/ 中/ ./ 增量/ 式/ 代码/ 更新/ 方法/ 通过/ 传输/ 差异/ 代码/ 降低/ 传输/ 开销/ ./ 其中/ Hermes/ [/ 7/ ]/ 采用/ Rsync/ 算法/ 计算/ 字节/ 级/ 差异/ ,/ 但是/ 由于/ 它/ 必须/ 对外部/ flash/ 进行/ 读写/ ,/ 增加/ 了/ 重组/ 开销/ ./ Koshy/ 和/ Pandey/ [/ 6/ ]/ 试图/ 通过/ 给/ 每个/ 函数/ 末尾/ 添加/ 溢出/ 空间/ (/ slopregion/ )/ 来/ 存放/ 插入/ 的/ 代码/ ,/ 尽量避免/ 代码/ 重建/ ./ 但是/ 溢出/ 空间/ 会/ 导致/ 大量/ 无效/ 的/ 存储/ 碎片/ ,/ 而且/ 插入/ 的/ 代码/ 量/ 受到/ 溢出/ 空间/ 大小/ 的/ 限制/ ./ 除了/ 专门/ 的/ 远程/ 代码/ 更新/ 方法/ 之外/ ,/ SOS/ [/ 18/ ]/ 、/ Contiki/ [/ 19/ ]/ 等/ 操作系统/ 使用/ 了/ 动态/ 链接/ 方法/ 实现/ 代码/ 更新/ ,/ 但是/ 这些/ 操作系统/ 在/ 更新/ 代码/ 时/ 需要/ 传输/ 符号表/ 和/ 重/ 定位/ 表/ ,/ 增加/ 了/ 传输/ 开销/ ,/ 并且/ 也/ 无法/ 对/ 操作系统/ 内核模块/ 进行/ 代码/ 更新/ ./ Mate/ [/ 20/ ]/ 和/ ASVM/ [/ 21/ ]/ 在/ 节点/ 上/ 实现/ 了/ 虚拟机/ 技术/ ,/ 可以/ 在/ 传输/ 少量/ 代码/ 的/ 情况/ 下/ ,/ 完成/ 代码/ 更新/ ./ 然而/ 虚拟机/ 代码/ 是/ 一种/ 紧凑型/ 代码/ (/ compactcode/ )/ ,/ 与/ 本地/ 码/ (/ nativecode/ )/ 相比/ 执行/ 效率/ 过低/ ,/ 并且/ 表达能力/ 有限/ ./ 7/ 结束语/ 目前/ 大多数/ 传感器/ 网络/ 代码/ 更新/ 研究/ 仍然/ 集中/ Page12/ 在/ 如何/ 有效/ 降低/ 传输/ 开销/ 上/ ,/ 而/ 对/ 如何/ 有效/ 地/ 降低/ 重组/ 开销/ 的/ 研究/ 则/ 较/ 少/ ./ 然而/ 通过/ 在/ 故宫/ 中/ 布署/ 传感器/ 网络/ [/ 1/ ]/ 的/ 工程/ 实践/ ,/ 我们/ 发现/ 有时/ 重组/ 开销/ 能够/ 超过/ 传输/ 开销/ 成为/ 代码/ 更新/ 的/ 主要/ 开销/ ./ 本文/ 介绍/ 了/ 一种/ 基于/ 代码/ 缓存/ 机制/ 的/ 低/ 开销/ 远程/ 代码/ 更新/ 方法/ EasiCache/ ./ 该/ 方法/ 通过/ 代码/ 缓存/ 机制/ 将/ 部分/ 代码/ 动态/ 地/ 保存/ 在/ RAM/ 中/ ,/ 尽量避免/ 对/ flash/ 元件/ 的/ 读写/ ,/ 从而/ 有效/ 降低/ 了/ 代码/ 更新/ 的/ 重组/ 开销/ ./ 同时/ 在/ EasiCache/ 中/ ,/ 针对/ 代码/ 更新/ 中/ 传输/ 开销/ 较/ 高/ 的/ 问题/ ,/ 提出/ 了/ 与/ 代码/ 缓存/ 机制/ 相适应/ 的/ 函数/ 级/ 代码/ 差异/ 对比/ 技术/ ./ 通过/ 单次/ 更新/ 实验/ 和/ 连续/ 更新/ 实验/ ,/ 我们/ 验证/ 了/ EasiCache/ 在/ 降低/ 更新/ 开销/ 方面/ 的/ 优势/ ./ 在/ 未来/ 的/ 工作/ 中/ ,/ 我们/ 将/ 进一步/ 研究/ 与/ 代码/ 缓存/ 机制/ 相适应/ 的/ 替换算法/ ,/ 提高/ 在/ 动态变化/ 场景/ 中/ 的/ 缓存/ 命中率/ ./ 

