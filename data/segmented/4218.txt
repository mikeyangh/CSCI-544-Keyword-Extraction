Page1/ 基于/ 偏序/ 约简/ 程序/ 可达图/ 的/ 并发程序/ 切片/ 方法/ 戚晓芳/ 1/ )/ ,/ 2/ )/ 徐晓晶/ 3/ )/ 江振亮/ 1/ )/ ,/ 2/ )/ 汪鹏/ 1/ )/ 1/ )/ (/ 东南大学/ 计算机科学/ 与/ 工程学院/ 南京/ 211189/ )/ 2/ )/ (/ 东南大学/ 计算机网络/ 和/ 信息/ 集成/ 教育部/ 重点/ 实验室/ 南京/ 211189/ )/ 3/ )/ (/ IBM/ 中国/ 系统/ 与/ 科技/ 实验室/ 上海/ 201203/ )/ 摘要/ 并发程序/ 切片/ 是/ 一种/ 重要/ 的/ 并发程序/ 分析/ 手段/ ./ 基于/ 程序/ 可达图/ 可/ 构造/ 以/ 程序/ 状态/ 和/ 语句/ 二元/ 组为/ 节点/ 的/ 、/ 依赖/ 关系/ 具有/ 可/ 传递性/ 的/ 并发程序/ 依赖图/ ,/ 解决/ 依赖/ 关系/ 的/ 不可/ 传递性/ 问题/ ,/ 提高/ 切片/ 精度/ ./ 程序/ 可达图/ 通过/ 交织/ 执行/ 模拟/ 并发/ 活动/ ,/ 分析/ 代价/ 较/ 高/ ./ 偏序/ 约简/ 是/ 一种/ 十分/ 有效/ 的/ 并发/ 系统/ 状态/ 空间/ 约简/ 技术/ ,/ 约简/ 的/ 并发/ 系统/ 状态/ 空间/ 包含/ 所有/ 的/ 并发程序/ 执行/ 代表/ ./ 为/ 提高效率/ ,/ 该文/ 将/ 偏序/ 约简/ 技术/ 扩展/ 到/ 程序/ 可达图/ 的/ 约简/ 中/ ,/ 在/ 偏序/ 约简/ 理论/ 的/ 基础/ 上/ ,/ 证明/ 了/ 基于/ 未/ 约简/ 和/ 约简/ 的/ 并发程序/ 可达图/ 构造/ 的/ 并发程序/ 依赖图/ 在/ 进行/ 切片/ 计算/ 时/ 是/ 等价/ 的/ ./ 实验/ 结果表明/ ,/ 采用/ 偏序/ 约简/ 技术/ 使/ 基于/ 程序/ 可达图/ 的/ 并发程序/ 切片/ 方法/ 在/ 保证/ 切片/ 精度/ 不/ 受/ 损失/ 的/ 前提/ 下/ 显著/ 提高/ 切片/ 效率/ ./ 与/ 其它/ 高精度/ 切片/ 方法/ 相比/ ,/ 基于/ 约简/ 程序/ 可达图/ 的/ 切片/ 方法/ 的/ 精度/ 更高/ ,/ 在/ 大多数/ 情况/ 下/ ,/ 切片/ 效率/ 也/ 有/ 一定/ 提高/ ./ 关键词/ 并发程序/ ;/ 程序/ 切片/ ;/ 依赖性/ 分析/ ;/ 可达性/ 分析/ ;/ 偏序/ 约简/ ;/ 程序/ 分析/ ;/ 软件测试/ 1/ 引言/ 多/ 核技术/ 的/ 普及/ 、/ 高级/ 编程语言/ 对/ 并发/ 设施/ 的/ 支持/ 以及/ 实际/ 应用/ 需求/ 的/ 不断/ 增加/ ,/ 使得/ 并发/ 软件/ 的/ 开发/ 和/ 使用/ 日益/ 广泛/ [/ 1/ ]/ ./ 由于/ 并发/ 与/ 竞争/ 的/ 存在/ ,/ 并发程序/ 具有/ 不确定性/ ,/ 这种/ 不确定性/ 给/ 并发程序/ 的/ 分析/ 理解/ 和/ 维护/ 带来/ 了/ 新/ 的/ 困难/ 和/ 挑战/ [/ 1/ -/ 3/ ]/ ./ 程序/ 切片/ 是/ 一种/ 重要/ 的/ 程序/ 分析/ 理解/ 方法/ ,/ 用于/ 从/ 原有/ 程序/ 中/ 抽取/ 对/ 特定/ 语句/ 有/ 影响/ 的/ 程序/ 成份/ 以/ 构成/ 新/ 程序/ ,/ 通过/ 分析/ 这种/ 简短/ 的/ 新/ 程序/ (/ 称为/ 程序/ 切片/ )/ 达到/ 简化/ 原有/ 程序/ 分析/ 的/ 目的/ [/ 2/ -/ 3/ ]/ ./ 目前/ 并发程序/ 切片/ 研究/ 尚未/ 成熟/ ,/ 还/ 存在/ 着/ 如何/ 有效/ 表示/ 并发程序/ 、/ 提高/ 并发程序/ 切片/ 的/ 精度/ 和/ 效率/ 等/ 问题/ 有待/ 解决/ [/ 4/ -/ 19/ ]/ ./ 对/ 并发程序/ 切片/ 进行/ 深入/ 的/ 研究/ 不仅/ 可/ 丰富/ 并发程序/ 分析/ 理解/ 和/ 维护/ 的/ 理论/ 基础/ ,/ 还/ 可/ 将/ 其/ 研究成果/ 广泛应用/ 于/ 并发/ 软件/ 的/ 分析/ 理解/ 、/ 调试/ 、/ 测试/ 、/ 度量/ 等/ 并发/ 软件/ 的/ 工程/ 活动/ 之中/ ./ 现有/ 的/ 并发程序/ 切片/ 大多/ 先/ 基于/ 并发程序/ 流图/ 进行/ 依赖性/ 分析/ ,/ 然后/ 构造/ 并发程序/ 依赖图/ ,/ 再/ 遍历/ 依赖图/ 以/ 计算/ 切片/ [/ 4/ -/ 15/ ]/ ./ 由于/ 不同/ 并发/ 单元/ 中/ 可/ 并发/ 执行/ 语句/ 间/ 的/ 数据/ 依赖/ (/ 干扰/ 依赖/ )/ 的/ 引入/ ,/ 并发程序/ 语句/ 间/ 依赖/ 关系/ 具有/ 不可/ 传递性/ ,/ 简单/ 遍历/ 并发程序/ 依赖图/ 将/ 不可避免/ 地/ 引入/ 冗余/ 语句/ ,/ 导致/ 切片/ 精度/ 较/ 低/ [/ 4/ -/ 6/ ]/ ./ 为/ 解决/ 依赖/ 关系/ 不可/ 传递性/ 问题/ ,/ 人们/ 根据/ 依赖/ 序列/ 应/ 满足/ 执行/ 的/ 先后/ 时序/ 要求/ ,/ 提出/ 在/ 遍历/ 并发程序/ 依赖图/ 时/ 进行/ 附加/ 判断/ ,/ 去/ 除了/ 部分/ 冗余/ 语句/ [/ 7/ -/ 15/ ]/ ./ 尽管/ 这些/ 方法/ 从/ 某种程度/ 上/ 提高/ 了/ 切片/ 精度/ ,/ 但/ 未/ 有效/ 解决/ 依赖/ 关系/ 不可/ 传递性/ 问题/ ./ 某些/ 依赖/ 序列/ 满足/ 执行/ 先后/ 时序/ 要求/ ,/ 但/ 当/ 存在/ 其它/ 并发/ 单元/ 对/ 共享/ 变量/ 的/ 重新/ 定义/ 时/ ,/ 依赖/ 关系/ 仍/ 有/ 可能/ 是/ 不可/ 传递/ 的/ ,/ 并发程序/ 切片/ 的/ 精度/ 仍/ 需/ 进一步提高/ [/ 11/ -/ 12/ ]/ ./ 为/ 解决/ 上述/ 问题/ ,/ 我们/ 提出/ 一种/ 基于/ 程序/ 可达图/ 的/ 并发程序/ 依赖性/ 分析方法/ ,/ 该/ 方法/ 可/ 解决/ 依赖/ 关系/ 不可/ 传递性/ 问题/ ,/ 获得/ 高精度/ 的/ 并发程序/ 切片/ ,/ 精度/ 较/ 其它/ 高精度/ 并发程序/ 切片/ 方法/ 有/ 明显提高/ [/ 16/ -/ 19/ ]/ ./ 但/ 程序/ 可达图/ 通过/ 交织/ 执行/ 模拟/ 并发/ 活动/ ,/ 可达图/ 存在/ 状态/ 爆炸/ 问题/ [/ 20/ ]/ ./ 与/ 其它/ 高精度/ 并发程序/ 切片/ 方法/ 类似/ ,/ 基于/ 程序/ 可达图/ 的/ 并发程序/ 切片/ 方法/ 具有/ 指数/ 级/ 的/ 复杂度/ ,/ 切片/ 效率/ 较/ 低/ ,/ 并发程序/ 切片/ 技术/ 的/ 应用/ 因此/ 受到/ 较大/ 的/ 限制/ [/ 16/ ]/ ./ 偏序/ 约简/ 技术/ 是/ 一种/ 十分/ 有效/ 的/ 并发/ 系统/ 状态/ 空间/ 约简/ 技术/ ,/ 约简/ 的/ 并发/ 系统/ 状态/ 空间/ 包含/ 所有/ 的/ 并发程序/ 执行/ 代表/ ./ 当/ 并发/ 单元/ 之间/ 的/ 交互作用/ 较/ 少时/ ,/ 在/ 某些/ 情况/ 下/ ,/ 通过/ 约简/ 并发/ 系统/ 的/ 状态/ 空间/ 可/ 从/ 指数/ 级/ 增长/ 下降/ 为/ 多项式/ 级/ 增长/ [/ 21/ -/ 23/ ]/ ./ 本文/ 在/ 前期工作/ 的/ 基础/ 上/ ,/ 将/ 偏序/ 约简/ 技术/ 应用/ 到/ 程序/ 可达图/ 的/ 约简/ 中/ ,/ 在/ 不/ 损失/ 切片/ 精度/ 的/ 前提/ 下/ ,/ 提高/ 分析/ 效率/ ./ 为/ 方便/ 理解/ ,/ 文中/ 首先/ 通过/ 两个/ 实例/ 说明/ 并发程序/ 中/ 两类/ 依赖/ 关系/ 不可/ 传递性/ 问题/ ,/ 然后/ 给出/ 我们/ 在/ 前期工作/ 中/ 提出/ 的/ 基于/ 程序/ 可达图/ 的/ 依赖性/ 分析方法/ [/ 16/ -/ 19/ ]/ ,/ 并/ 在/ 偏序/ 约简/ 相关/ 技术/ 和/ 理论/ 的/ 基础/ 上/ 证明/ 基于/ 未/ 约简/ 和/ 约简/ 的/ 并发程序/ 可达图/ 所/ 构造/ 的/ 并发程序/ 依赖图/ 在/ 进行/ 并发程序/ 切片/ 计算/ 时/ 是/ 等价/ 的/ ,/ 同时/ 实现/ 了/ 相应/ 的/ 切片/ 算法/ 和/ 目前/ 其它/ 主要/ 并发程序/ 切片/ 算法/ ,/ 进行/ 实验/ 研究/ ,/ 最后/ 给出/ 相关/ 工作/ 比较/ 和/ 结论/ ./ 2/ 依赖/ 关系/ 不可/ 传递性/ 问题/ Krinke/ 和/ Nanda/ [/ 9/ -/ 12/ ]/ 所/ 研究/ 的/ 基于/ 共享/ 变量/ 的/ 通信/ 是/ 一种/ 经典/ 的/ 基于/ 共享/ 变量/ 的/ 并发/ 机制/ ,/ 对/ 它/ 的/ 研究/ 具有/ 普适性/ ,/ 易/ 扩展/ 到/ Java/ 、/ C++/ 等/ 语言/ 的/ 并发程序/ 研究/ 中/ ./ 为此/ ,/ 本文/ 以/ Krinke/ 和/ Nanda/ 所/ 研究/ 的/ 并发程序/ 为例/ 进行/ 分析/ ./ 本文/ 所/ 研究/ 的/ 并发程序/ 是/ 所谓/ 的/ 轻度/ 并发程序/ ,/ 由/ 一组/ 线程/ 组成/ ,/ 各个/ 线程/ 共享/ 同一/ 地址/ 空间/ ./ 线程/ 间/ 通过/ 共享/ 变量/ 进行/ 通信/ ,/ 共享/ 变量/ 的/ 读写/ 是/ 原子/ 操作/ ,/ 用/ cobegin/ 和/ coend/ 分别/ 表示/ 线程/ 的/ 创建/ 和/ 终止/ ./ 设/ Si/ 与/ Sj/ 为/ 并发程序/ 的/ 两个/ 语句/ ,/ 若/ Si/ 与/ Sj/ 并发/ 执行/ ,/ Si/ 执行/ 时/ 使用/ 到/ Sj/ 定义/ 的/ 变量/ ,/ 则/ 称/ Si/ 干扰/ 数据/ 依赖于/ Sj/ ./ 在/ 并发程序/ 中/ ,/ 干扰/ 依赖/ 可/ 产生/ 两种/ 类型/ 的/ 依赖/ 关系/ 不可/ 传递性/ 问题/ ,/ 即/ 依赖/ 时序/ 问题/ 和/ 共享/ 变量/ 重/ 定义/ 问题/ [/ 11/ -/ 12/ ]/ ./ 依赖/ 序列/ 因/ 不/ 满足/ 语句/ 执行/ 的/ 时序/ 要求/ 而/ 产生/ 的/ 不可/ 传递性/ 问题/ ,/ Page3/ 称作/ 并发程序/ 依赖/ 时序/ 问题/ (/ TimeTravel/ )/ [/ 9/ -/ 15/ ]/ ./ 图/ 1/ (/ a/ )/ 给出/ 一个/ 实例/ ,/ 实例/ 1/ 由/ 4/ 个/ 线程/ 组成/ ,/ 主线/ 程/ θ/ 1/ 创建/ 3/ 个/ 并发/ 执行/ 的/ 子/ 线程/ θ/ 2/ 、/ θ/ 3/ 和/ θ/ 4/ ,/ 各/ 线程/ 通过/ 共享/ 变量/ x/ 和/ y/ 进行/ 通信/ ./ S6/ 使用/ 共享/ 变量/ x/ 干扰/ 依赖于/ S4/ ,/ 类似/ 地/ ,/ S4/ 干扰/ 依赖于/ S7/ ,/ 由于/ 在/ θ/ 3/ 的/ 控制流/ 图中/ 不/ 存在/ S7/ 到达/ S6/ 的/ 路径/ ,/ 〈/ S7/ ,/ S4/ ,/ S6/ 〉/ 不/ 满足/ 时序/ 要求/ ,/ S6/ 不/ 可能/ 依赖于/ S7/ ,/ 〈/ S6/ ,/ S4/ ,/ S7/ 〉/ 中/ 的/ 依赖/ 关系/ 是/ 不可/ 传递/ 的/ ./ 在/ 并发程序/ 中/ ,/ 某些/ 依赖/ 序列/ 尽管/ 满足/ 语句/ 执行/ 的/ 时序/ 要求/ ,/ 但/ 由于/ 共享/ 变量/ 的/ 重新/ 定义/ ,/ 仍/ 可能/ 产生/ 依赖/ 关系/ 不可/ 传递性/ 问题/ ,/ 本文/ 将/ 这类/ 问题/ 称作/ 共享/ 变量/ 重/ 定义/ 问题/ ./ 图/ 1/ (/ b/ )/ 给出/ 文献/ [/ 11/ ]/ 中/ 的/ 一个/ 实例/ ,/ 实例/ 2/ 中/ S3/ 干扰/ 依赖于/ S4/ ,/ S4/ 数据/ 依赖于/ S1/ ./ 〈/ S1/ ,/ S4/ ,/ S3/ 〉/ 满足/ 时序/ 要求/ ,/ 但/ 由于/ S2/ 中/ 对/ 共享/ 变量/ x/ 的/ 重新/ 定义/ ,/ S3/ 依赖于/ S4/ 与/ S4/ 依赖于/ S1/ 不能/ 同时/ 发生/ ,/ 使得/ 〈/ S3/ ,/ S4/ ,/ S1/ 〉/ 中/ 的/ 依赖/ 关系/ 不可/ 传递/ ./ 目前/ ,/ 大多数/ 并发程序/ 切片/ 方法/ 采用/ 并发程序/ 流图/ 表示/ 并发程序/ 的/ 执行/ ,/ 而/ 并发程序/ 流图/ 中/ 并行/ 流/ 被/ 简单/ 地/ 视为/ 分/ 支流/ 处理/ ,/ 尽管/ 增加/ 了/ 干扰/ 数据/ 的/ 依赖/ 分析/ ,/ 但/ 没有/ 从/ 全局/ 分析/ 并行/ 流间/ 的/ 数据/ 依赖/ 关系/ ,/ 造成/ 上述/ 两类/ 依赖/ 关系/ 不可/ 传递性/ 问题/ ./ 3/ 线程/ 交互/ 可达图/ 及其/ 偏序/ 约简/ 技术/ 欲/ 解决/ 上述/ 问题/ ,/ 需/ 寻求/ 一种/ 全局/ 的/ 并发程序/ 表示/ 方式/ [/ 16/ ]/ ./ 可达性/ 分析/ 对/ 并行/ 流/ 进行/ 顺序/ 化/ 处理/ ,/ 基于/ 程序/ 可达图/ 可/ 从/ 全局/ 进行/ 并发程序/ 依赖性/ 分析/ ,/ 解决/ 依赖/ 关系/ 不可/ 传递性/ 问题/ [/ 16/ ]/ ./ 为/ 避免/ 语句/ 级/ 的/ 可达性/ 分析/ 造成/ 分析/ 代价/ 过/ 高等/ 问题/ ,/ 在/ 不/ 影响/ 分析/ 精度/ 的/ 前提/ 下/ ,/ 本文/ 采用/ 线程/ 交互/ 图对/ 线程/ 进行/ 粗粒度/ 的/ 表示/ ,/ 再/ 进行/ 可达性/ 分析/ ,/ 从而/ 生成/ 线程/ 交互/ 可达图/ ,/ 在/ 可达性/ 分析/ 过程/ 中/ 采用/ 偏序/ 约简/ 技术/ 进一步/ 降低/ 可达图/ 的/ 复杂度/ ,/ 提高/ 分析/ 效率/ ./ 3.1/ 线程/ 交互/ 可达图/ 并发程序/ 由/ 一组/ 线程/ 组成/ ,/ 每个/ 线程/ 是/ 一个/ 顺序/ 执行/ 流/ ./ 为/ 方便/ 描述/ ,/ 文中/ 对/ 共享/ 变量/ 读写/ 、/ 线程/ 创建/ 或/ 等待/ 线程/ 终止/ 等/ 涉及/ 到/ 线程/ 之间/ 交互/ 的/ 语句/ ,/ 称为/ 交互/ 语句/ ,/ 这些/ 语句/ 在/ 所在/ 线程/ 外是/ 可见/ 的/ ./ 除/ 交互/ 语句/ 以外/ 的/ 语句/ 称作/ 非/ 交互/ 语句/ ,/ 非/ 交互/ 语句/ 在/ 所在/ 线程/ 外是/ 不/ 可见/ 的/ ./ 在/ 并发程序/ 中/ ,/ 交互/ 语句/ 的/ 执行/ 顺序/ 一旦/ 确定/ ,/ 非/ 交互/ 语句/ 的/ 不同/ 顺序/ 的/ 交织/ 执行/ 对/ 并发程序/ 的/ 执行/ 结果/ 和/ 依赖/ 分析/ 不/ 产生/ 影响/ ./ 为此/ ,/ 根据/ 交互/ 语句/ ,/ 我们/ 可/ 对/ 线程/ 分块/ 或/ 程序段/ (/ 称/ 线程/ 域/ )/ 进行/ 分析/ ./ 给定/ 某/ 线程/ 的/ 控制流/ 图/ (/ CFG/ )/ ,/ 采用/ 下列/ 方法/ 构造/ 线程/ 域/ :/ 从/ 入口/ 语句/ 或/ 交互/ 语句/ 的/ 后继/ 语句/ 起始/ ,/ 沿/ CFG/ 路径/ 到达/ 最近/ 的/ 交互/ 语句/ 或/ 出口/ 语句/ 终止/ ,/ 被/ 遍历/ 的/ 一个/ 单/ 入口/ 、/ 多/ 出口/ 的/ CFG/ 子图/ 所/ 对应/ 的/ 程序段/ 为/ 一个/ 线程/ 域/ ./ 每个/ 线程/ 域/ 表示/ 一个/ 程序控制/ 点/ ,/ 即将/ 执行/ 该/ 线程/ 域/ 所/ 包含/ 的/ 程序段/ ./ 将/ 每个/ 线程/ 域用/ 一个/ 节点/ 表示/ ,/ 节点/ 间/ 的/ 边/ 称作/ 变迁/ ,/ 表示/ 相应/ 的/ 交互/ 语句/ 及其/ 之前/ 所有/ 非/ 交互/ 语句/ 程序段/ 的/ 执行/ ,/ 由此/ 可/ 生成/ 线程/ 交互/ 图/ ./ 定义/ 1/ ./ 给定/ 线程/ θ/ ,/ 其/ 线程/ 交互/ 图/ (/ TIG/ )/ 是/ 一个/ 五元/ 组/ 〈/ N/ ,/ T/ ,/ ns/ ,/ Σ/ ,/ υ/ 〉/ ,/ 其中/ :/ 节点/ 集/ N/ 是/ 线程/ 域集/ ,/ 边集/ T/ 是/ 变迁/ 集/ ,/ T/ / N/ ×/ Σ/ ×/ N/ ,/ ns/ 是/ 初始状态/ ,/ Σ/ 是/ 变迁/ 标签集/ ,/ υ/ 是/ 标签/ 函数/ ,/ 对/ T/ 中/ 的/ 每个/ 变迁/ 映射/ 为/ Σ/ 中/ 的/ 一个/ 标签/ ./ 在/ 定义/ 1/ 中/ ,/ 变迁/ 分为/ 共享/ 变量/ 读写/ 、/ 线程/ 创建/ 和/ 等待/ 线程/ 终止/ ,/ 每/ 类/ 变迁/ 的/ 标签/ 仅/ 与/ 交互/ 语句/ 有关/ ./ 共享/ 变量/ 读写/ 变迁/ 的/ 标签/ 为/ 该/ 共享/ 变量/ 读写/ 语句/ 的/ 标号/ ,/ 线程/ θ/ 创建/ 和/ 等待/ 各子/ 线程/ θ/ 1/ ,/ θ/ 2/ ,/ …/ ,/ θ/ k/ 终止/ 变迁/ 的/ 标签/ 分别/ 为/ θ/ →/ (/ θ/ 1/ ,/ θ/ 2/ ,/ …/ ,/ θ/ k/ )/ 和/ θ/ ←/ (/ θ/ 1/ ,/ θ/ 2/ ,/ …/ ,/ θ/ k/ )/ ./ 若/ t/ ∈/ T/ ,/ t/ =/ (/ n/ ,/ e/ ,/ n/ )/ ,/ n/ ,/ n/ ∈/ N/ ,/ n/ 和/ n/ 则/ 分别/ 记为/ pre/ (/ t/ )/ 和/ post/ (/ t/ )/ ,/ t/ 所在/ 线程/ 记为/ Active/ (/ t/ )/ ,/ t/ 中/ 使用/ 的/ 共享/ 对象/ 的/ 集合/ 记为/ Used/ (/ t/ )/ ./ 实例/ 1/ 的/ 4/ 个/ TIG/ 图如图/ 2/ 所示/ ./ Page4/ 给定/ 并发程序/ CP/ ,/ 各/ 线程/ 的/ 线程/ 交互/ 图/ TIGs/ =/ i/ =/ 1/ 〈/ Ni/ ,/ Ti/ ,/ nis/ ,/ Σ/ i/ ,/ υ/ i/ 〉/ ,/ 共享/ 变量/ 集合/ 为/ O/ =/ ∪/ r/ ∪/ p/ 并发程序/ 的/ 全局/ 执行/ 空间/ 可/ 通过/ 可达性/ 分析/ ,/ 生成/ 线程/ 交互/ 可达/ 图来/ 表示/ ./ 可达性/ 分析/ 从/ 初始状态/ 出发/ ,/ 执行/ 在/ 该/ 状态/ 下/ 可能/ 发生/ 的/ 变迁/ ,/ 生成/ 后继/ 状态/ ,/ 再/ 从/ 这些/ 后继/ 状态/ 出发/ 执行/ 可行/ 变迁/ ,/ 如此/ 反复/ ,/ 直到/ 没有/ 新/ 的/ 状态/ 生成/ ./ 定义/ 2/ ./ 线程/ 交互/ 可达图/ (/ TIRG/ )/ 是/ 一个/ 四元组/ A/ =/ (/ M/ ,/ m0/ ,/ TG/ ,/ Δ/ G/ )/ ,/ 其中/ :/ 节点/ 集/ M/ 是/ 全局/ 状态/ 集/ ,/ m0/ ∈/ M/ ,/ 表示/ 初始状态/ ,/ 边集/ TG/ 是/ 变迁/ 集/ ,/ TG/ / M/ ×/ Δ/ G/ ×/ M/ ,/ Δ/ G/ 是/ 变迁/ 标签集/ ./ 在/ 定义/ 2/ 中/ ,/ 全局/ 状态/ 通过/ 各/ 线程/ 的/ 程序控制/ 点/ 以及/ 共享/ 变量/ 的/ 取值/ 表示/ ,/ 全局/ 状态/ 集/ M/ / N1/ ×/ N2/ ×/ …/ ×/ Np/ ×/ V1/ ×/ V2/ ×/ …/ ×/ Vr/ ,/ V1/ ,/ V2/ ,/ …/ ,/ Vm/ 分别/ 为/ 共享/ 对象/ O1/ ,/ O2/ ,/ …/ ,/ Or/ 的/ 取值/ 空间/ ./ 在/ 可达性/ 分析/ 过程/ 中/ ,/ 后继/ 状态/ 中/ 的/ 线程/ 域/ 分量/ 与/ 前驱/ 状态/ 除/ 发生/ 变迁/ 的/ 线程/ 的/ 分量/ 发生变化/ 外/ ,/ 其余/ 分量/ 不图/ 3/ 实例/ 1/ 的/ TIRG/ 图若/ / m/ ∈/ M/ :/ (/ m/ ,/ t/ ,/ m/ )/ ∈/ TG/ ,/ 则/ 称/ 在/ m/ 下/ 可/ 发生/ 变迁/ t/ ,/ 记在/ m/ 下/ 可/ 发生/ 变迁/ 组成/ 的/ 集合/ 为/ Enabled/ (/ m/ )/ ./ 若/ (/ m/ ,/ t/ ,/ m/ )/ ∈/ TG/ ,/ 则/ 称/ 在/ m/ 下/ 发生/ t/ 变迁/ 后/ 到达/ m/ ,/ 记/ 为/ (/ m/ ,/ t/ )/ →/ m/ ./ 设/ ω/ 为/ 一个/ 变迁/ 序列/ ,/ ω/ =/ t1t2/ …/ tn/ ,/ 当且/ 仅/ 当/ 满足/ (/ m/ =/ m1/ ,/ t1/ )/ →/ m2/ ∧/ (/ m2/ ,/ t2/ )/ →/ m3/ ∧/ …/ ∧/ (/ mn/ ,/ tn/ )/ →/ mn/ +/ 1/ =/ m/ 时/ ,/ 称/ 在/ m/ 下/ 发生/ ω/ 变迁/ 序列/ 后/ 到达/ m/ ,/ 记/ 为/ (/ m/ ,/ ω/ )/ →/ m/ ./ 定义/ 3/ ./ 给定/ 某/ 并发程序/ CP/ ,/ 设/ CP/ 的/ 局部/ 变迁/ 集合/ 为/ T/ ,/ 全局/ 状态/ 集为/ M/ ,/ 则/ I/ / T/ ×/ T/ ,/ I/ 是/ 变迁/ 独立/ 关系/ 当且/ 仅/ 当/ / (/ t1/ ,/ t2/ )/ ∈/ I/ 满足/ :/ / m/ ∈/ M/ :/ (/ t1/ ≠/ t2/ ∧/ (/ m/ ,/ t1/ )/ →/ m1/ ∧/ (/ m/ ,/ t2/ )/ →/ m2/ )/ 独立/ 关系/ 的/ 补集/ 称作/ 依赖/ 关系/ ,/ 若/ 独立/ 关系/ 为变/ ./ 为/ 方便/ 描述/ ,/ 称/ 定义/ 1/ 中/ 变迁/ 集/ T/ 中/ 的/ 变迁/ 为/ 局部/ 变迁/ ,/ 定义/ 2/ 中/ 变迁/ 集/ TG/ 中/ 的/ 变迁/ 为/ 全局/ 变迁/ ,/ TG/ 中/ 每个/ 全局/ 变迁/ 与/ T/ 中/ 的/ 某个/ 局部/ 变迁/ 相对/ 应/ ./ 全局/ 变迁/ 分为/ 共享/ 变量/ 读写/ 以及/ 线程/ 创建/ 和/ 终止/ 等/ 3/ 类/ ,/ 其/ 标签/ 与/ 定义/ 1/ 中/ 局部/ 变迁/ 类似/ ./ 实例/ 1/ 的/ TIRG/ 图如图/ 3/ 所示/ ,/ 从/ 初始状态/ m0/ =/ (/ 1/ ,/ -/ ,/ -/ ,/ -/ ,/ x/ =/ ?/ ,/ y/ =/ ?/ )/ 开始/ ,/ 其中/ -/ 表示/ 线程/ 处于/ 未激活/ 或/ 执行/ 已/ 终止/ ,/ ?/ 表示/ 未/ 初始化/ ,/ 发生/ θ/ 1/ 创建/ θ/ 2/ ,/ θ/ 3/ 和/ θ/ 4/ 变迁/ 后/ ,/ 生成/ m1/ =/ (/ 2/ ,/ 4/ ,/ 6/ ,/ 9/ ,/ x/ =/ 5/ ,/ y/ =/ 10/ )/ ./ 在/ m1/ 下/ ,/ 可/ 发生/ 标签/ 为/ S4/ ,/ S6/ 和/ S9/ 的/ 变迁/ ./ 执行/ S4/ 变迁/ 后/ ,/ 改变/ m1/ 中/ θ/ 1/ 的/ 分量/ 和/ x/ 的/ 值/ ,/ 生成/ m2/ =/ (/ 2/ ,/ 5/ ,/ 6/ ,/ 9/ ,/ x/ =/ 15/ ,/ y/ =/ 10/ )/ ./ 类似/ 地/ ,/ 执行/ S6/ 和/ S7/ 变迁/ ,/ 则/ 分别/ 生成/ m3/ 和/ m4/ ./ 从/ 这些/ 状态/ 出发/ 执行/ 可行/ 变迁/ ,/ 生成/ 新/ 状态/ ,/ 反复/ 上述/ 过程/ ,/ 直至/ 生成/ 终态/ m15/ 和/ m16/ ./ 图/ 3/ 中/ 完全/ 扩展/ 线程/ 可达图/ 的/ 状态/ 数为/ 17/ ,/ 变迁/ 数为/ 23/ ,/ 变迁/ 序列/ 数为/ 12/ ./ I/ ,/ 则/ 依赖/ 关系/ D/ =/ T/ ×/ T/ \/ I/ ./ 按照/ 变迁/ 独立/ 关系/ 的/ 语义/ ,/ 判断/ 变迁/ 独立/ 和/ 依赖/ 关系/ 需/ 考虑/ 并发/ 系统/ 所有/ 的/ 全局/ 状态/ ,/ 操作/ 十分困难/ 也/ 不/ 可行/ ./ 一般/ 地/ ,/ 我们/ 通过/ 一个/ 语法/ 检查/ 的/ 充分条件/ 来/ 判断/ 两个/ 变迁/ 之间/ 是否/ 依赖/ ./ 当/ 满足/ 下列/ 条件/ 之一/ 时/ ,/ t1/ 与/ t2/ 依赖/ :/ / ;/ 一个/ 变迁/ 对/ O/ 中/ 的/ 共享/ 对象/ 进行/ 写/ 操作/ ./ (/ 1/ )/ (/ pre/ (/ t1/ )/ ∪/ post/ (/ t1/ )/ )/ ∩/ (/ pre/ (/ t2/ )/ ∪/ post/ (/ t2/ )/ )/ ≠/ (/ 2/ )/ Used/ (/ t1/ )/ ∩/ Used/ (/ t2/ )/ ≠/ / 且/ t1/ 和/ t2/ 中/ 至少/ 有/ 在/ 条件/ (/ 1/ )/ 中/ ,/ 当/ pre/ (/ t1/ )/ ∩/ pre/ (/ t2/ )/ ≠/ / 时/ ,/ t1/ 与/ t2/ 的/ 依赖/ 也/ 称作/ 冲突/ 依赖/ ./ 在/ 条件/ (/ 2/ )/ 中/ ,/ 若/ t1/ 和/ t2/ 对/ 某/ 一/ 共享/ 变量/ 均/ 进行/ 读/ 操作/ ,/ 则/ t1/ 与/ t2/ 之间/ 不/ 产生/ 依赖/ ./ 在/ 偏序/ 约简/ 过程/ 中/ ,/ 一般/ 只/ 需/ 考虑/ 冲突/ 依赖/ 和/ 并行/ Page5/ 执行/ 变迁/ 之间/ 由于/ 共享/ 变量/ 读写/ 产生/ 的/ 依赖/ [/ 21/ -/ 22/ ]/ ./ 传统/ 偏序/ 约简/ 技术/ 在/ 描述/ 并发/ 系统/ 全局/ 状态/ 时/ 考虑/ 了/ 各/ 并发/ 单元/ 的/ 控制点/ 和/ 各/ 共享/ 对象/ 的/ 值/ ,/ 主要/ 由于/ 待/ 检验/ 性能/ 不仅/ 与/ 控制流/ 还/ 与/ 数据流/ 密切相关/ [/ 21/ -/ 23/ ]/ ./ 而/ 程序/ 依赖/ 分析/ 仅/ 需/ 提取/ 并发程序/ 的/ 控制流/ 信息/ ,/ 因此/ ,/ 可/ 将/ 具有/ 相同/ 控制点/ 分量/ 、/ 不同/ 共享/ 对象/ 分量/ 的/ 状态/ 节点/ 合并/ 为/ 一个/ 节点/ ,/ 生成/ 一个/ 简化/ 的/ 线程/ 交互/ 可达图/ 表示/ 并发程序/ 执行/ ./ 在/ 图/ 3/ 中/ ,/ 若/ 分别/ 将/ m11/ 与/ m12/ ,/ m13/ 与/ m14/ ,/ m15/ 与/ m16/ 合并/ 为/ 一个/ 节点/ 后/ ,/ 则/ 状态/ 数/ 减少/ 为/ 14/ ,/ 变迁/ 数为/ 21/ ,/ 但/ 变迁/ 序列/ 数/ 仍/ 为/ 12/ ,/ 与/ 未/ 简化/ 的/ 线程/ 交互/ 可达图/ 中/ 的/ 变迁/ 序列/ 数上/ 完全相同/ ./ 3.2/ 偏序/ 约简/ 技术/ 为/ 方便/ 描述/ ,/ 下面/ 对/ 完全/ 扩展/ 的/ 线程/ 交互/ 可达/ 图用/ AG/ 表示/ ,/ 约简/ 后/ 的/ 线程/ 交互/ 可达/ 图用/ AR/ 表示/ ./ 目前/ 常用/ 的/ 偏序/ 约简/ 技术/ 为/ 稳固/ 集/ 技术/ 和/ 睡眠/ 集/ 技术/ ,/ 这/ 两种/ 技术/ 都/ 是/ 通过/ 去除/ AG/ 中/ 的/ 冗余/ 变迁/ 序列/ 实现/ 约简/ 的/ [/ 21/ ]/ ./ 定义/ 4/ ./ 设/ ω/ 、/ ω/ 为/ 两个/ 变迁/ 序列/ ,/ 若/ ω/ (/ ω/ )/ 可/ 由/ ω/ (/ ω/ )/ 通过/ 连续/ 交换/ 相邻/ 独立/ 变迁/ 的/ 位置/ 而/ 获得/ ,/ 则/ 称/ ω/ 与/ ω/ 等价/ ,/ 所有/ 与/ ω/ 等价/ 的/ 变迁/ 序列/ 集合/ 称作/ 并发/ 系统/ 的/ 一个/ 迹/ (/ Mazurkiewicz/ ’/ sTrace/ )/ ,/ 记/ 为/ [/ ω/ ]/ [/ 21/ ]/ ./ 由/ 定义/ 3/ 和/ 定义/ 4/ ,/ 可/ 得/ :/ 性质/ 1/ ./ 设/ m/ 为/ 某/ 状态/ ,/ ω/ 1/ ,/ ω/ 2/ 为/ 两个/ 变迁/ 序列/ ,/ 若/ [/ ω/ 1/ ]/ =/ [/ ω/ 2/ ]/ ,/ (/ m/ ,/ ω/ 1/ )/ →/ m1/ ,/ (/ m/ ,/ ω/ 2/ )/ →/ m2/ ,/ 则/ m1/ =/ m2/ 定义/ 5/ ./ 给定/ 某/ 状态/ m/ ,/ 变迁/ 集/ T/ / Enabled/ (/ m/ )/ ,/ T/ 是/ m/ 下/ 的/ 稳固/ 集当且/ 仅/ 当/ :/ 对/ 在/ AG/ 中/ 从/ m/ 出发/ 的/ 任意/ 变迁/ 序列/ ω/ =/ t1t2/ …/ tn/ (/ / 1/ / i/ / n/ :/ ti/ / T/ )/ ,/ (/ m/ =/ m1/ ,/ t1/ )/ →/ m2/ ∧/ (/ m2/ ,/ t2/ )/ →/ m3/ ∧/ …/ ∧/ (/ mn/ ,/ tn/ )/ →/ mn/ +/ 1/ ,/ 满足/ tn/ 在/ mn/ 下/ 与/ T/ 中/ 所有/ 变迁/ 独立/ ./ 稳固/ 集/ 满足/ 当/ 选择/ 稳固/ 集/ 之外/ 的/ 变迁/ 扩展/ 时/ 对/ 稳固/ 集中/ 的/ 变迁/ 不/ 产生/ 任何/ 影响/ [/ 21/ -/ 22/ ]/ ./ 稳固/ 集/ 计算/ 主要/ 采用/ 一些/ 启发式/ 算法/ ,/ 各种/ 算法/ 各有/ 优缺点/ [/ 21/ ]/ ./ 本文/ 选取/ Overman/ 提出/ 的/ 算法/ ,/ 该/ 算法/ 的/ 约简/ 效果/ 和/ 复杂度/ 达到/ 了/ 较/ 好/ 的/ 折中/ ./ 采用/ 以下/ 方法/ 计算/ 状态/ m/ 的/ 稳固/ 集/ P/ _/ S/ (/ m/ )/ :/ 初始/ 时/ 在/ 工作/ 表/ W/ 中/ 加入/ Active/ (/ t0/ )/ ,/ t0/ 为/ 在/ 当前/ 状态/ m/ 下/ 可/ 发生/ 的/ 一个/ 任意/ 变迁/ ,/ 从/ W/ 中/ 取出/ 下/ 一个/ 线程/ θ/ x/ ,/ 在/ W/ 中/ 加入/ Active/ (/ t/ )/ 和/ Active/ (/ t/ )/ ,/ 其中/ t/ 为/ 在/ m/ 下/ 线程/ θ/ x/ 中/ 可/ 发生/ 的/ 变迁/ ,/ t/ 是/ 与/ t/ 并行执行/ 且/ 依赖/ 的/ 变迁/ ,/ 同时/ 将/ 加入/ W/ 中/ 的/ 线程/ 标记/ 为/ 已/ 访问/ 线程/ ,/ 再/ 从/ W/ 中/ 取出/ 下/ 一个/ 线程/ ,/ 如此/ 反复/ ,/ 直至/ W/ 为空/ ,/ 最后/ 从/ Enabled/ (/ m/ )/ 中/ 找出/ 已/ 访问/ 线程/ 中/ 在/ m/ 下/ 可/ 发生/ 的/ 变迁/ ,/ 即/ 为/ 稳固/ 集/ ./ 该/ 算法/ 时间/ 复杂度/ 为/ O/ (/ p2/ )/ ,/ 其中/ p/ 为/ 线程/ 数/ ./ 在/ 一般/ 情况/ 下/ ,/ 稳固/ 集中/ 不可避免/ 地/ 存在/ 相互/ 独立/ 的/ 变迁/ ,/ 采用/ 睡眠/ 集/ 技术/ 可/ 去除/ 这些/ 独立/ 变迁/ 产生/ 的/ 冗余/ 交织/ ,/ 进一步/ 减少/ 可达图/ 中/ 的/ 状态/ 和/ 变迁/ 数/ ./ 稳固/ 集中/ 不/ 被/ 扩展/ 的/ 变迁/ 集/ 称作/ 睡眠/ 集/ [/ 21/ ]/ ./ 采用/ 下述/ 方法/ 计算/ 睡眠/ 集/ :/ 令/ 初始状态/ m0/ 的/ 睡眠/ 集/ Sleep/ (/ m0/ )/ 为/ / ,/ 对/ 任意/ 状态/ m/ ,/ 将/ 已/ 在/ m/ 下/ 扩展/ 的/ 变迁/ 集/ 与/ m/ 的/ 睡眠/ 集/ 进行/ 合并/ ,/ 去除/ 在/ m/ 处/ 与/ 待/ 扩展/ 变迁/ t/ 依赖/ 的/ 变迁/ 后/ 所得/ 变迁/ 集即/ 为/ m/ 的/ 睡眠/ 集/ Sleep/ (/ m/ )/ ,/ 其中/ m/ 为/ 在/ m/ 处/ 发生/ 变迁/ t/ 后/ 生成/ 的/ 后继/ 状态/ ,/ Sleep/ (/ m/ )/ 中/ 的/ 变迁/ 在/ m/ 处不需/ 扩展/ 或/ 在/ m/ 处/ 已/ 扩展/ 且/ 与/ t/ 独立/ ./ 设/ P/ _/ S/ (/ m/ )/ 和/ Sleep/ (/ m/ )/ 分别/ 为/ m/ 状态/ 下/ 的/ 稳固/ 集/ 和/ 睡眠/ 集/ ,/ 则/ 在/ m/ 状态/ 下/ 实际/ 扩展/ 的/ 变迁/ 集为/ P/ _/ S/ (/ m/ )/ \/ Sleep/ (/ m/ )/ ./ 为/ 保证/ 约简/ 状态/ 空间/ 图/ 表示/ 并发/ 系统/ 所有/ 可能/ 的/ 执行/ ,/ Godefroid/ 对/ 稳固/ 集/ 的/ 计算/ 进行/ 改进/ ,/ 要求/ 稳固/ 集/ 满足/ 下列/ 定义/ 6/ 中/ 的/ 附加条件/ (/ 也/ 称为/ Godefroid/ 附加条件/ )/ [/ 21/ ]/ ./ 定义/ 6/ ./ 在/ 并发/ 系统/ 状态/ 空间/ 搜索/ 过程/ 中/ ,/ 所/ 计算/ 的/ 各/ 状态/ m/ 的/ 稳固/ 集/ 满足/ 下列/ 两个/ 条件/ 之一/ :/ (/ 1/ )/ 存在/ 一个/ 不/ 在/ 睡眠/ 集中/ 的/ 变迁/ ,/ 且/ 该/ 变迁/ 扩展/ 后/ 所/ 生成/ 的/ 后继/ 状态/ 不/ 在/ 当前/ 栈中/ ,/ 即/ 扩展/ 该/ 变迁/ 后/ 在/ 当前/ 扩展/ 路径/ 上/ 不/ 产生/ 回路/ ;/ (/ 2/ )/ 稳固/ 集为/ Enabled/ (/ m/ )/ ./ 实例/ 1/ 的/ 约简/ 状态/ 空间/ 如图/ 4/ 所示/ ,/ 其中/ 未/ 划线/ 的/ 状态/ 节点/ 和/ 实线/ 边/ 组成/ 了/ 约简/ 状态/ 空间/ 图/ ,/ 划线/ 的/ 状态/ 节点/ 和/ 虚线/ 边为/ 约简/ 去除/ 的/ 状态/ 和/ 变迁/ ,/ 状态/ 节点/ 后面/ 的/ 集合/ 表示/ 睡眠/ 集/ ./ 在/ 实例/ 1/ 中/ ,/ 变迁/ 依赖/ 集/ 为/ {/ (/ S4/ ,/ S6/ )/ ,/ (/ S4/ ,/ S7/ )/ ,/ (/ S7/ ,/ S9/ )/ }/ ./ 在/ 初始状态/ m0/ =/ (/ 1/ ,/ -/ ,/ -/ ,/ -/ )/ 处/ ,/ 创建/ 线程/ ,/ 进入状态/ m1/ ,/ 在/ m1/ 处/ ,/ 初始/ 选择/ S4/ 变迁/ ,/ 将/ θ/ 2/ 加入/ W/ 中/ ,/ 在/ m1/ 下/ θ/ 2/ 可/ 发生/ 的/ 变迁/ 为/ S4/ ,/ 由于/ S4/ 与/ S6/ 和/ S7/ 并行/ 且/ 依赖/ ,/ 将/ θ/ 3/ 加入/ W/ 中/ ,/ 在/ m1/ 下/ θ/ 3/ 可/ 发生/ 的/ 变迁/ 为/ S6/ ,/ S6/ 与/ S4/ 并行/ 且/ 依赖/ ,/ 但/ θ/ 2/ 已/ 加入/ 过/ W/ ,/ 迭代/ 终止/ ,/ 在/ 计算/ 过程/ 中/ 已/ 访问/ 的/ 线程/ 为/ θ/ 2/ 和/ θ/ 3/ ,/ m1/ 的/ 稳固/ 集/ 为/ {/ S4/ ,/ S6/ }/ ,/ m1/ 的/ 睡眠/ 集/ 为/ / ./ 在/ m8/ 处/ ,/ 采用/ 类似/ 的/ 方法/ 可/ 计算/ 出其/ 稳固/ 集/ 为/ {/ S4/ ,/ S7/ }/ ,/ sleep/ (/ m8/ )/ =/ sleep/ (/ m3/ )/ ∪/ {/ S4/ ,/ S7/ }/ \/ {/ S7/ }/ =/ {/ S4/ }/ ,/ 其中/ sleep/ (/ m3/ )/ 为/ 空集/ ,/ S7/ 因/ 与/ S9/ 依赖/ 在/ 睡眠/ 集中/ 被/ 去除/ ./ 在/ 图/ 4/ 中/ ,/ 完全/ 扩展/ 线程/ 可达图/ 中/ 的/ 状态/ 数为/ 14/ ,/ 变迁/ 数为/ 22/ ,/ 变迁/ 序列/ 数为/ 12/ ,/ 约简/ 后/ 状态/ 数/ 减少/ 为/ 12/ ,/ 变迁/ 数/ 减少/ 为/ 15/ ,/ 变迁/ 序列/ 数/ 减少/ 为/ 6/ ./ Page6/ 图/ 4/ 实例/ 1/ 的/ TIRG/ 约简/ 示意图/ 4/ 基于/ 约简/ 程序/ 可达图/ 的/ 并发程序/ 切片/ 可达图/ 通过/ 模拟/ 并行/ 流/ 的/ 交织/ 执行/ 将/ 其/ 顺序/ 化/ 处理/ ,/ 可达图/ 中/ 每个/ 从/ 初始状态/ 出发/ 到/ 终态/ 的/ 变迁/ 序列/ 表示/ 并发程序/ 一个/ 可能/ 的/ 执行/ ,/ 可达图/ 描述/ 了/ 并发程序/ 所有/ 可能/ 执行/ 的/ 先后顺序/ 关系/ ./ 基于/ 可达图/ 我们/ 可/ 采用/ 在/ 控制流/ 图中/ 常用/ 的/ 数据流/ 分析/ 技术/ 进行/ 并发程序/ 依赖性/ 分析/ ,/ 然后/ 进行/ 切片/ 计算/ ./ 与/ 一般/ 顺序程序/ 控制流/ 图/ 不同/ 的/ 是/ ,/ 并发程序/ 中/ 不同/ 线程/ 可/ 对/ 同一个/ 共享/ 变量/ 进行/ 赋值/ 定义/ ,/ 同一/ 语句/ 在/ 不同/ 的/ 并行/ 流/ 交织/ 执行/ 情况/ 下/ 处于/ 不同/ 的/ 程序/ 状态/ ./ 对/ 这些/ 在/ 不同/ 程序/ 状态/ 下/ 执行/ 的/ 语句/ 不/ 进行/ 区分/ ,/ 可能/ 会/ 引起/ 语句/ 间/ 依赖性/ 不可/ 传递/ 的/ 问题/ [/ 16/ ]/ ./ 为此/ ,/ 我们/ 将/ 程序/ 状态/ 和/ 语句/ 进行/ 组合/ ,/ 将/ 这种/ 组合/ 称作/ M/ -/ S/ 对/ ,/ 并/ 基于/ 线程/ 交互/ 可达图/ 分析/ M/ -/ S/ 对/ 之间/ 的/ 依赖/ 关系/ ,/ 构建/ 以/ M/ -/ S/ 对/ 为/ 节点/ 的/ 并发程序/ 依赖图/ ,/ 简称/ MSDG/ 图/ ./ 定义/ 7/ ./ 设/ 并发程序/ CP/ 的/ TIRG/ 图为/ AG/ =/ (/ M/ ,/ m0/ ,/ TG/ ,/ Δ/ G/ )/ ,/ 则/ CP/ 基于/ AG/ 的/ 依赖图/ (/ MSDG/ )/ 为/ 四元组/ 〈/ M/ ,/ S/ ,/ MS/ ,/ ED/ 〉/ ,/ 其中/ :/ M/ 为/ CP/ 的/ 程序/ 状态/ 集/ ,/ S/ 为/ CP/ 的/ 语句/ 集/ ,/ 节点/ 集/ MS/ / M/ ×/ S/ ,/ 边集/ ED/ =/ {/ (/ Λ/ i/ ,/ Λ/ j/ )/ |/ dep/ (/ Λ/ i/ ,/ Λ/ j/ )/ ,/ Λ/ i/ ,/ Λ/ j/ ∈/ MS/ ,/ dep/ ∈/ {/ CD/ ,/ DD/ ,/ SD/ }/ }/ ./ 在/ 上述/ 定义/ 中/ ,/ CD/ ,/ DD/ ,/ SD/ 分别/ 表示/ 控制/ 依赖/ 、/ 数据/ 依赖/ 和/ 同步/ 依赖/ ./ 由于/ 可达图/ 将/ 并发程序/ 的/ 并行/ 流/ 顺序/ 化/ 处理/ ,/ 在/ 分析/ 数据/ 依赖/ 时/ ,/ 我们/ 不需/ 再/ 区分/ 一般/ 数据/ 依赖/ 和/ 干扰/ 数据/ 依赖/ ./ 考虑/ 到/ 由/ cobegin/ // coend/ 引起/ 的/ 同步/ 活动/ 是/ 一种/ 线程/ 执行/ 等待/ 引起/ 的/ 控制/ ,/ 故/ 将/ 这种/ 由/ 同步/ 活动/ 引发/ 的/ 控制/ 依赖/ 称为/ 同步/ 依赖/ ,/ 以/ 区别/ 于/ 由/ 谓词/ 取值/ 等/ 引起/ 的/ 一般/ 控制/ 依赖/ ./ MSDG/ 图中/ 的/ 依赖/ 关系/ 具有/ 可/ 传递性/ ,/ 具体/ 证明/ 参见/ 文献/ [/ 16/ ]/ ./ 性质/ 1/ ./ 给定/ 并发程序/ CP/ ,/ 其/ MSDG/ 图中/ 的/ 依赖/ 关系/ 具有/ 可/ 传递性/ [/ 16/ ]/ ./ 基于/ MSDG/ 图/ 计算/ 并发程序/ 切片/ 是/ 一个/ 简单/ 的/ 图/ 的/ 遍历/ 问题/ ./ 给定/ 切片/ 标准/ s/ ,/ 先/ 找出/ 所有/ 以/ 语句/ 分量/ 为/ s/ 的/ M/ -/ S/ 对/ 集合/ ,/ 然后/ 分别/ 以/ 这些/ M/ -/ S/ 对/ 为/ 始点/ 遍历/ MSDG/ 图/ ,/ 所/ 访问/ 的/ 节点/ 合并/ 后/ 去除/ 状态/ 分量/ 后/ 得到/ 的/ 语句/ 集合/ 即为/ s/ 的/ 切片/ ./ 约简/ 后/ 的/ 线程/ 交互/ 可达图/ 包含/ 所有/ 的/ 并发程序/ 执行/ 代表/ ,/ 基于/ 未/ 约简/ 和/ 约简/ 并发程序/ 可达图/ 构造/ 的/ 并发程序/ 依赖图/ 在/ 进行/ 切片/ 计算/ 时/ 是/ 等价/ 的/ ,/ 下面/ 先/ 给出/ 迹/ 自动机/ 的/ 定义/ 和/ 相关/ 性质/ ,/ 再/ 进行/ 证明/ ./ 定义/ 8/ ./ 设/ AG/ 为/ 并发/ 系统/ 的/ 状态/ 空间/ 图/ ,/ AR/ 为/ 约简/ 状态/ 空间/ 图/ ,/ 当/ 满足/ 下列/ 性质/ 时/ ,/ 称/ AR/ 为/ 该/ 并发/ 系统/ 的/ 一个/ 迹/ 自动机/ :/ 对/ AG/ 中/ 从/ 初始状态/ m0/ 出发/ 的/ 任意/ 变迁/ 序列/ ω/ ,/ 在/ AR/ 中/ 存在/ 一个/ 从/ m0/ 出发/ 的/ 变迁/ 序列/ ω/ ,/ 满足/ ω/ ∈/ Pref/ [/ ω/ ,/ m0/ ]/ ,/ 其中/ [/ ω/ ,/ m0/ ]/ 表示/ 从/ m0/ 出发/ 、/ 与/ ω/ 等价/ 的/ 变迁/ 序列/ 集合/ ,/ Pref/ [/ ω/ ,/ m0/ ]/ 表示/ 由/ [/ ω/ ,/ m0/ ]/ 中/ 变迁/ 序列/ 的/ 前缀/ 生成/ 的/ 变迁/ 序列/ 集合/ [/ 21/ ]/ ./ 采用/ Godefroid/ 附加条件/ 的/ 算法/ 生成/ 的/ 约简/ 状态/ 空间/ 图是/ 并发/ 系统/ 的/ 一个/ 迹/ 自动机/ [/ 21/ ]/ ./ 图/ 4/ 中/ 的/ AR/ 是/ 实例/ 1/ 的/ 一个/ 迹/ 自动机/ ,/ 设/ ω/ =/ t1S9S6S4S7t2/ ,/ 其中/ t1/ 为/ θ/ 1/ →/ (/ θ/ 2/ ,/ θ/ 3/ ,/ θ/ 4/ )/ ,/ t2/ 为/ θ/ 1/ ←/ (/ θ/ 2/ ,/ θ/ 3/ ,/ θ/ 4/ )/ ,/ 显然/ ω/ 是/ 一个/ 被/ 约简/ 掉/ 的/ 变迁/ 序列/ ,/ 但/ 在/ AR/ 中/ 可/ 找到/ 一个/ 变迁/ 序列/ ω/ =/ t1S6S4S9S7t2/ ,/ S4/ 和/ S6/ 分别/ 与/ S9/ 独立/ ,/ 在/ ω/ 中先/ 交换/ S4/ 与/ S9/ 的/ 位置/ ,/ 再/ 交换/ S6/ 与/ S9/ 的/ 位置/ ,/ 即可/ 生成/ ω/ ,/ ω/ ∈/ [/ ω/ ,/ m0/ ]/ ,/ ω/ 是/ 自身/ 的/ 前缀/ ,/ ω/ ∈/ Pref/ [/ ω/ ,/ m0/ ]/ ./ 设/ ω/ 为/ 某/ 变迁/ 序列/ ,/ 称/ ω/ 中/ 语句/ 间/ 的/ 控制/ 依/ Page7/ 赖/ 、/ 数据/ 依赖/ 以及/ 同步/ 依赖/ 关系/ 集合/ 为/ ω/ 的/ 程序/ 依赖/ ,/ 记为/ ProgDep/ (/ ω/ )/ ./ 性质/ 2/ ./ 设/ ω/ 、/ ω/ 为/ 两个/ 变迁/ 序列/ ,/ 若/ [/ ω/ ]/ =/ [/ ω/ ]/ ,/ 则/ ProgDep/ (/ ω/ )/ =/ ProgDep/ (/ ω/ )/ ./ 证明/ ./ 由于/ [/ ω/ ]/ =/ [/ ω/ ]/ ,/ 因此/ ω/ 与/ ω/ 是/ 等价/ 的/ ,/ ω/ 可/ 由/ ω/ 通过/ 连续/ 交换/ 相邻/ 独立/ 变迁/ 位置/ 而/ 获得/ ./ 设在/ 由/ ω/ 生成/ ω/ 过程/ 中/ 的/ 各/ 变迁/ 序列/ 为/ (/ ω/ =/ ω/ 1/ ,/ ω/ 2/ ,/ …/ ,/ ω/ n/ =/ ω/ )/ ,/ 满足/ / 1/ / i/ / n/ -/ 1/ :/ 存在/ 变迁/ 序列/ u/ ,/ v/ 和/ 独立/ 变迁/ a/ ,/ b/ ,/ 其中/ ω/ i/ =/ uabv/ 且/ ω/ i/ +/ 1/ =/ ubav/ ./ 同一个/ 并发/ 单元/ 内部/ 中/ 的/ 相邻/ 变迁/ 或/ 冲突/ 变迁/ 存在/ 依赖/ ,/ 变迁/ a/ ,/ b/ 独立/ ,/ 表明/ a/ ,/ b/ 为/ 不同/ 线程/ 中/ 的/ 变迁/ ,/ 而/ 控制/ 依赖/ 发生/ 在/ 同一个/ 线程/ 内部/ ,/ 因此/ ,/ a/ 和/ b/ 交换/ 位置/ 不/ 影响/ ω/ i/ 和/ ω/ i/ +/ 1/ 中/ 的/ 控制/ 依赖/ 分析/ ./ 变迁/ a/ ,/ b/ 在/ u/ 之后/ ,/ a/ ,/ b/ 位置/ 的/ 交换/ 不/ 影响/ u/ 中/ 语句/ 的/ 数据/ 依赖/ 关系/ ;/ 其次/ ,/ 由/ 变迁/ 独立/ 关系/ 的/ 定义/ 得/ ,/ 变迁/ a/ ,/ b/ 对应/ 语句/ 之间/ 也/ 不/ 可能/ 存在/ 由于/ 对/ 同一个/ 变量/ 的/ 定义/ 引用/ 而/ 产生/ 的/ 数据/ 依赖/ 关系/ ,/ a/ ,/ b/ 位置/ 的/ 交换/ 不/ 影响/ a/ ,/ b/ 本身/ 的/ 数据/ 依赖/ 关系/ ;/ 最后/ ,/ 由/ 变迁/ 独立/ 关系/ 的/ 定义/ ,/ 变迁/ a/ ,/ b/ 对应/ 语句/ 之间/ 也/ 不/ 存在/ 对/ 同一个/ 变量/ 的/ 定义/ ,/ 否则/ a/ ,/ b/ 不/ 独立/ ,/ 因此/ ,/ a/ ,/ b/ 位置/ 的/ 交换/ 不/ 影响/ v/ 对应/ 语句/ 的/ 数据/ 依赖/ 关系/ ./ 以上/ 分析表明/ ,/ a/ ,/ b/ 位置/ 的/ 交换/ 不/ 影响/ ω/ i/ 和/ ω/ i/ +/ 1/ 中/ 的/ 数据/ 依赖/ 关系/ ./ 参加/ 同步/ 活动/ 的/ 变迁/ 之间/ 存在/ 依赖/ ,/ 变迁/ a/ ,/ b/ 独立/ ,/ 表明/ a/ ,/ b/ 未/ 参加/ 任何/ 同步/ 活动/ ,/ 因此/ ,/ 交换/ a/ 和/ b/ 的/ 位置/ 不会/ 影响/ ω/ i/ 和/ ω/ i/ +/ 1/ 中/ 的/ 同步/ 依赖/ 关系/ 分析/ ./ 综上所述/ ,/ a/ ,/ b/ 位置/ 的/ 交换/ 不/ 影响/ ω/ i/ 和/ ω/ i/ +/ 1/ 中/ 数据/ 依赖/ 、/ 控制/ 依赖/ 以及/ 同步/ 依赖/ ,/ 即/ ProgDep/ (/ ω/ i/ )/ =/ ProgDep/ (/ ω/ i/ +/ 1/ )/ ,/ 将/ i/ 从/ 1/ ~/ n/ -/ 1/ 代入/ ProgDep/ (/ ω/ i/ )/ =/ ProgDep/ (/ ω/ i/ +/ 1/ )/ ,/ 可/ 得/ :/ ProgDep/ (/ ω/ )/ =/ ProgDep/ (/ ω/ 1/ )/ =/ ProgDep/ (/ ω/ 2/ )/ =/ …/ =/ ProgDep/ (/ ω/ n/ )/ =/ ProgDep/ (/ ω/ )/ ./ 证毕/ ./ 设/ 并发程序/ CP/ 完全/ 扩展/ 的/ 线程/ 交互/ 可达/ 图为/ AG/ ,/ 采用/ 综合/ 稳固/ 集/ 和/ 睡眠/ 集/ 技术/ 约简/ 生成/ 的/ 可达/ 图为/ AR/ ,/ 记/ 基于/ AG/ 和/ AR/ 构造/ 的/ 依赖图/ 分别/ 为/ MSDG/ 和/ MSDGR/ ./ 由于/ AR/ 是/ AG/ 的/ 子/ 图/ ,/ 可/ 得/ :/ 性质/ 3/ ./ MSDGR/ 图是/ MSDG/ 图/ 的/ 子/ 图/ ./ 给定/ 切片/ 标准/ s/ ,/ 记/ 基于/ MSDG/ 图/ 计算/ s/ 的/ 切片/ 为/ Slice/ (/ s/ )/ ,/ 基于/ MSDGR/ 图/ 计算/ s/ 的/ 切片/ 为/ Slice/ _/ R/ (/ s/ )/ ./ 性质/ 4/ ./ Slice/ (/ s/ )/ =/ Slice/ _/ R/ (/ s/ )/ ./ 证明/ ./ 设/ l/ 为/ MSDG/ 图中/ 任意/ 一个/ 从以/ 语句/ 分量/ 为/ s/ 的/ 某/ M/ -/ S/ 对/ 节点/ 开始/ 的/ 依赖/ 序列/ ,/ l/ 由/ TIRG/ 图中/ 的/ 变迁/ 序列/ ω/ 分析/ 所得/ ./ 由/ 性质/ 1/ ,/ 在/ AR/ 图中/ 存在/ 一个/ 变迁/ 序列/ ω/ ,/ 满足/ ω/ 为/ 某/ 变迁/ 序列/ ω/ 的/ 前缀/ ,/ 且/ [/ ω/ ]/ =/ [/ ω/ ]/ ./ 由/ 性质/ 2/ 可得/ ,/ ProgDep/ (/ ω/ )/ =/ ProgDep/ (/ ω/ )/ ./ 由于/ ω/ 为/ ω/ 的/ 前缀/ ,/ 因此/ ,/ ProgDep/ (/ ω/ )/ / ProgDep/ (/ ω/ )/ ,/ 即/ ProgDep/ (/ ω/ )/ / ProgDep/ (/ ω/ )/ ,/ 基于/ MSRGR/ 图可/ 遍历/ 到/ 依赖/ 序列/ l/ 中/ 各/ 语句/ ./ 由/ Slice/ (/ s/ )/ 和/ Slice/ _/ R/ (/ s/ )/ 的/ 定义/ ,/ 可得/ Slice/ (/ s/ )/ / Slice/ _/ R/ (/ s/ )/ ./ 由/ 性质/ 3/ ,/ MSDGR/ 图是/ MSDG/ 图/ 的/ 子/ 图/ ,/ 可得/ Slice/ _/ R/ (/ s/ )/ / Slice/ (/ s/ )/ ./ 由/ Slice/ (/ s/ )/ / Slice/ _/ R/ (/ s/ )/ 和/ Slice/ _/ R/ (/ s/ )/ / Slice/ (/ s/ )/ 可得/ Slice/ (/ s/ )/ =/ Slice/ _/ R/ (/ s/ )/ ./ 下面/ 给出/ 实例/ 1/ 说明/ 基于/ 未/ 约简/ 和/ 约简/ 线程/ 交互/ 可达图/ 进行/ 并发程序/ 切片/ 计算/ 的/ 情况/ ./ 实例/ 1/ 的/ MSDG/ 图/ 比较复杂/ ,/ 其中/ 最/ 重要/ 的/ 是/ 数据/ 依赖边/ ,/ 为/ 降低/ 图/ 的/ 复杂程度/ ,/ 图中/ 只/ 给出/ 了/ 数据/ 依赖/ ,/ 其它/ 控制/ 依赖/ 和/ 同步/ 依赖/ 用/ 文字/ 表述/ ./ 整个/ 图/ 5/ 中/ 的/ 所有/ 依赖/ 关系/ 组成/ 基于/ 未/ 约简/ 线程/ 交互/ 可达图/ 生成/ 的/ MSDG/ 图/ ./ 而图/ 5/ (/ a/ )/ 中/ 的/ 实线/ 边/ 以及/ 与/ 这些/ 边/ 相连/ 的/ 节点/ 表示/ 基于/ 约简/ 程序/ 可达图/ 分析/ 所得/ 的/ 数据/ 依赖/ ,/ 图/ 5/ (/ b/ )/ 、/ (/ c/ )/ 中/ 黑色/ 文字/ 表示/ 了/ 基于/ 约简/ 线程/ 交互/ 可达图/ 分析/ 所得/ 的/ 控制/ 和/ 同步/ 依赖/ ,/ 三者/ 共同/ 组成/ MSDGR/ 图/ ./ 由图/ 4/ 可见/ ,/ MSDGR/ 是/ MSDG/ 的/ 子/ 图/ ./ MSDG/ 图中/ 的/ 节点/ 数为/ 41/ ,/ 数据/ 依赖边/ 数为/ 48/ ,/ 控制/ 依赖边/ 数为/ 39/ ,/ 同步/ 依赖边/ 数为/ 3/ ;/ MSDGR/ 图中/ 节点/ 数为/ 29/ ,/ 数据/ 依赖边/ 数为/ 27/ ,/ 控制/ 依赖边/ 数为/ 22/ ,/ 同步/ 依赖边/ 数为/ 3/ ,/ 约简/ 效果/ 较为/ 明显/ ./ 对/ MSDG/ 图中/ 的/ 任意/ M/ -/ S/ 对/ 依赖/ 序列/ ,/ 在/ MSDGR/ 图中/ 都/ 存在/ 一个/ 长度/ 相同/ 且/ 相同/ 位置/ 的/ M/ -/ S/ 对/ 中/ 语句/ 分量/ 分别/ 相同/ 的/ M/ -/ S/ 对/ 依赖/ 序列/ ./ 如图/ 5/ (/ a/ )/ ,/ 依赖/ 序列/ l/ =/ (/ 〈/ m0/ ,/ S1/ 〉/ ,/ 〈/ m4/ ,/ S4/ 〉/ ,/ 〈/ m7/ ,/ S6/ 〉/ ,/ 〈/ m10/ ,/ S7/ 〉/ )/ 中/ 的/ 依赖边/ 均/ 为/ 虚线/ ,/ 表明/ 该/ 依赖/ 序列/ 仅/ 在/ 未/ 约简/ 的/ MSDG/ 图中/ 出现/ ,/ 在/ 约简/ 的/ MSDGR/ 图中/ ,/ 我们/ 可/ 找到/ 一个/ 依赖边/ 均/ 为/ 实线/ 的/ 依赖/ 序列/ l/ =/ (/ 〈/ m0/ ,/ S1/ 〉/ ,/ 〈/ m1/ ,/ S4/ 〉/ ,/ 〈/ m2/ ,/ S6/ 〉/ ,/ 〈/ m10/ ,/ S7/ 〉/ )/ ,/ l/ 与/ l/ 长度/ 相同/ ,/ 且/ 依赖/ 序列/ 中/ 相同/ 位置/ 的/ M/ -/ S/ 对/ 的/ 语句/ 分量/ 也/ 分别/ 相同/ ./ 基于/ MSDG/ 图/ 与/ MSDGR/ 图/ 进行/ 切片/ 计算/ 是/ 等价/ 的/ ./ 如对/ S6/ 进行/ 切片/ ,/ 遍历/ MSDGR/ 图/ 的/ M/ -/ S/ 对/ 集合/ 为/ {/ 〈/ m2/ ,/ S6/ 〉/ ,/ 〈/ m1/ ,/ S4/ 〉/ ,/ 〈/ m0/ ,/ S1/ 〉/ ,/ 〈/ m1/ ,/ S3/ 〉/ ,/ 〈/ m1/ ,/ S6/ 〉/ ,/ 〈/ m0/ ,/ startt0/ 〉/ ,/ 〈/ m1/ ,/ startt1/ 〉/ ,/ 〈/ m1/ ,/ startt2/ 〉/ ,/ 〈/ m0/ ,/ cobegin/ 〉/ }/ ,/ 图/ 5/ (/ a/ )/ 中/ 深色/ 的/ 实线/ 节点/ 为/ 通过/ 数据/ 依赖边/ 获得/ 的/ 节点/ ;/ 遍历/ 未/ 约简/ MSDG/ 图/ 的/ M/ -/ S/ 对/ 集合/ 为/ Page8/ 图/ 5/ 实例/ 1/ 的/ MSDG/ 图/ {/ 〈/ m2/ ,/ S6/ 〉/ ,/ 〈/ m1/ ,/ S4/ 〉/ ,/ 〈/ m0/ ,/ S1/ 〉/ ,/ 〈/ m1/ ,/ S3/ 〉/ ,/ 〈/ m1/ ,/ S6/ 〉/ ,/ 〈/ m7/ ,/ S6/ 〉/ ,/ 〈/ m4/ ,/ S4/ 〉/ ,/ 〈/ m4/ ,/ S3/ 〉/ ,/ 〈/ m0/ ,/ startt0/ 〉/ ,/ 〈/ m1/ ,/ startt1/ 〉/ ,/ 〈/ m1/ ,/ startt2/ 〉/ ,/ 〈/ m0/ ,/ cobegin/ 〉/ }/ ,/ 在/ 图/ 5/ (/ a/ )/ 中/ 深色/ 的/ 实线/ 和/ 虚线/ 节点/ 为/ 通过/ 数据/ 依赖边/ 获得/ 的/ 节点/ ./ 去除/ 状态/ 分量/ 后/ 所得/ S6/ 的/ 切片/ 相同/ ,/ Slice/ (/ S6/ )/ =/ {/ S6/ ,/ S4/ ,/ S1/ ,/ S3/ ,/ startt0/ ,/ startt1/ ,/ startt2/ ,/ cobegin/ }/ ./ 实例/ 2/ 的/ TIRG/ 和/ MSDG/ 图/ 以及/ 相关/ 分析/ 已/ 在/ 文献/ [/ 16/ ]/ 给出/ ,/ 限于/ 篇幅/ ,/ 本文/ 不再/ 赘述/ ./ 5/ 实验/ 分析/ 在/ 上述/ 理论/ 工作/ 的/ 基础/ 上/ ,/ 我们/ 针对/ 多线程/ 共享/ 变量/ 通信/ 机制/ ,/ 通过/ C/ // C++/ 程序/ 分析/ 工具/ CodeSurfer/ 获取/ 程序/ 的/ 控制流/ 图/ 、/ 子程序/ 调用/ 图/ 以及/ 数据/ 的/ 定义/ // 引用/ 等/ 基本/ 信息/ ,/ 实现/ 了/ 基于/ 程序/ 可/ Page9/ 达图/ 的/ 并发程序/ 切片/ 原型/ 系统/ [/ 19/ ]/ ./ 该/ 系统/ 主要/ 包括/ 构造/ TIRG/ 图/ 、/ 构造/ MSDG/ 图/ 以及/ 切片/ 计算/ 等/ 子系统/ ,/ 其中/ 构造/ TIRG/ 图/ 子系统/ 实现/ 了/ 完全/ 扩展/ 线程/ 交互/ 可达图/ 以及/ 采用/ 本文/ 3.2/ 节中/ 稳固/ 集/ 和/ 睡眠/ 集/ 偏序/ 约简/ 技术/ 生成/ 的/ 程序/ 交互/ 可达图/ 的/ 算法/ ./ 同时/ ,/ 为/ 方便/ 与/ 相关/ 工作/ 进行/ 比较/ ,/ 我们/ 还/ 实现/ 了/ 目前/ 最有/ 代表性/ 的/ Nanda/ 提出/ 的/ 基于/ 线程/ 系统/ 依赖图/ (/ TSDG/ )/ 的/ 并发程序/ 切片/ 算法/ :/ 三/ 色/ 两趟/ 式/ 并发/ 子程序/ 间/ 切片/ 方法/ 、/ 基于/ 拓扑/ 号/ 的/ 上下文/ 敏感/ 的/ 并发/ 子程序/ 间/ 切片/ 算法/ [/ 11/ -/ 12/ ]/ 以及/ Giffhorn/ 对/ 该/ 方法/ 进行/ 约束/ 优化/ 的/ 改进/ 算法/ [/ 14/ ]/ ,/ 其中/ TSDG/ 图是/ 将/ 各/ 线程/ 的/ 系统/ 依赖图/ 通过/ 干扰/ 依赖边/ 连接/ 而成/ 的/ 语句/ 间/ 的/ 依赖图/ ./ 实验/ 环境/ 为/ IntelCore2Q8400/ 处理器/ ,/ 2.66/ GHz/ ,/ 3GB/ 内存/ ,/ WindowsXP/ 系统/ ,/ CodeSurfer/ 版本/ 为/ 2.1/ p1/ ./ 20070526/ -/ i686/ -/ pc/ -/ win32/ ./ 实验/ 程序/ 为/ 文献/ [/ 14/ ]/ 中/ 使用/ 的/ 两个/ Java/ 并发程序/ ,/ 为/ 方便/ CodeSurfer/ 分析/ ,/ 我们/ 将/ 这/ 两个/ Java/ 并发程序/ 转换/ 为/ 类似/ C语言/ 的/ 程序/ ,/ 其中/ main/ 函数/ 视为/ 主线/ 程/ ,/ 子程序/ cobegin/ (/ )/ // coend/ (/ )/ 的/ 调用/ 视为/ 线程/ 的/ 创建/ // 终止/ ,/ 两个/ 或/ 多个/ 线程/ 使用/ 的/ 全局变量/ 视为/ 共享/ 变量/ ./ 为/ 观察/ 不同/ 切片/ 方法/ 在/ 状态/ 组合/ 爆炸/ 问题/ 上/ 的/ 处理/ 情况/ 及其/ 对/ 切片/ 时间/ 性能/ 的/ 影响/ ,/ 我们/ 对/ 上述/ 两个/ 实验/ 程序/ 在/ 具有/ 不同/ 线程/ 数/ 的/ 情况/ 下/ 进行/ 依赖性/ 分析/ 和/ 切片/ 实验/ ./ 表/ 1/ 给出/ 两个/ 实验/ 程序/ 在/ 不同/ 线程/ 数下/ 构造/ 的/ 线程/ 系统/ 依赖图/ (/ TSDG/ )/ 以及/ 线程/ 交互/ 可达图/ (/ TIRG/ )/ 和/ M/ -/ S/ 对/ 依赖图/ (/ MSDG/ )/ 的/ 大小/ ,/ 其中/ TIRG/ 和/ TIRGR/ 分别/ 表示/ 未/ 约简/ 和/ 约简/ 的/ 线程/ 交互/ 可达图/ ,/ MSDG/ 和/ MSDGR/ 分别/ 表示/ 基于/ TIRG/ 和/ TIRGR/ 图/ 构造/ 的/ M/ -/ S/ 对/ 依赖图/ ,/ TSDG/ 图是/ 线程/ 系统/ 依赖图/ ./ 表/ 1/ 中/ N/ 表示/ 相应/ 图中/ 的/ 节点/ 数/ ,/ E/ 表示/ 边数/ ,/ —/ 表示/ 分析/ 超过/ 1h/ 而/ 无法/ 正确/ 获取/ 相应/ 数据/ ./ 程序/ 线程/ Time/ -/ TravelShared/ -/ Queue/ 由表/ 1/ 可见/ ,/ 采用/ 偏序/ 约简/ 技术/ 对/ SharedQueue/ 程序/ 产生/ 了/ 明显/ 的/ 约简/ 效果/ ,/ 较/ 大幅度/ 地/ 降低/ 了/ TIRG/ 图/ 和/ MSDG/ 图/ 的/ 复杂度/ ,/ 且/ 随着/ 线程/ 数/ 的/ 增加/ ,/ 两者/ 的/ 约简/ 效果/ 愈加/ 明显/ ./ 当/ 线程/ 数为/ 2/ 、/ 3/ 、/ 4/ 时/ ,/ TIRGR/ 图/ (/ 约简/ 后/ 的/ TIRG/ )/ 的/ 节点/ 数/ 分别/ 减少/ 为/ 未/ 约简/ TIRG/ 图/ 节点/ 数/ 的/ 75/ %/ 、/ 63/ %/ 和/ 60/ %/ ,/ 边数/ 分别/ 减少/ 为/ 未/ 约简/ TIRG/ 图边数/ 的/ 52/ %/ 、/ 32/ %/ 和/ 24/ %/ ./ 当/ 线程/ 数为/ 5/ 时/ ,/ 不/ 采用/ 约简/ 技术/ 难以/ 构造/ TIRG/ 图/ ./ 相应/ 地/ ,/ MSDGR/ 图/ 的/ 复杂度/ 远远/ 低于/ MSDG/ 图/ 的/ 复杂度/ ./ 当/ 线程/ 数为/ 2/ 、/ 3/ 时/ ,/ MSDGR/ 图/ 的/ 节点/ 数/ 分别/ 为/ MSDG/ 图/ 节点/ 数/ 的/ 59/ %/ 和/ 42/ %/ ,/ 边数/ 分别/ 为/ MSDG/ 图边数/ 的/ 33/ %/ 和/ 13/ %/ ./ 当/ 线程/ 数为/ 4/ 、/ 5/ 时/ ,/ 基于/ 未/ 约简/ 的/ TIRG/ 图/ 难以/ 构造/ MSDG/ 图/ ./ 由表/ 1/ 还/ 可/ 看出/ ,/ 采用/ 偏序/ 约简/ 技术/ 对/ TimeTravel/ 程序/ 并未/ 产生/ 十分/ 明显/ 的/ 约简/ 效果/ ,/ 约简/ 后/ TIRG/ 图/ 和/ MSDG/ 图/ 的/ 复杂度/ 略有/ 减小/ ,/ 没有/ 明显/ 的/ 变化/ ./ 实验/ 采用/ 不同/ 切片/ 算法/ 分别/ 对/ 两个/ 实验/ 程序/ 进行/ 切片/ 实验/ ,/ 表/ 2/ 和表/ 3/ 分别/ 给出/ 了/ 切片/ 的/ 精度/ 和/ 时间/ 性能/ 的/ 实验/ 结果/ ./ 在/ 表/ 2/ 和表/ 3/ 中/ ,/ Name/ 表示/ 程序/ 名/ ,/ Inst/ 表示/ 线程/ 的/ 实例/ 数/ ,/ R/ 和/ RO/ 是/ 我们/ 提出/ 的/ 基于/ 程序/ 可达图/ 的/ 切片/ 算法/ ,/ 其中/ R/ 表示/ 基于/ 未/ 约简/ 程序/ 可达图/ 的/ 切片/ 算法/ ,/ RO/ 表示/ 基于/ 约简/ 程序/ 可达图/ 的/ 切片/ 算法/ ,/ N/ 和/ NO/ 是/ Nanda/ 在/ 文献/ [/ 11/ -/ 12/ ]/ 所/ 提出/ 的/ 可/ 解决/ 依赖/ 时序/ 问题/ 和/ 上下文/ 不/ 敏感/ 问题/ 的/ 高精度/ 切片/ 算法/ ,/ N/ 表示/ 未/ 进行/ 优化/ 的/ 切片/ 算法/ ,/ NO/ 表示/ 通过/ 元组/ 可达性/ 的/ 判断/ 对/ N/ 方法/ 进行/ 优化/ 的/ 切片/ 算法/ ,/ I/ 表示/ Nanda/ 提出/ 的/ 三色/ 两/ 阶段/ 遍历/ TSDG/ 图/ 的/ 切片/ 算法/ ,/ 该/ 算法/ 不能/ 解决/ 依赖性/ 不可/ 传递/ 问题/ 和/ 上下文/ 不/ 敏感/ 问题/ ./ 本次/ 实验/ 选取/ 的/ 切片/ 标准/ 为/ 含/ 共享/ 变量/ 的/ 语句/ ,/ 切片/ 大小/ 为/ 各/ 切片/ 中/ 语句/ 数/ 的/ 平均值/ ,/ 表示/ 切片/ 的/ 精度/ ,/ 工作/ 节点/ 数是/ 每个/ 切片/ 计算/ 过程/ 中/ 的/ 加入/ 工作/ 表中/ 的/ 节点/ 数/ 的/ 平均值/ (/ 与/ 切片/ 时间/ 密切相关/ )/ ./ 表/ 2/ 中/ 的/ S/ 表示/ 切片/ 语句/ 数/ ,/ W/ 表示/ 工作/ 节点/ 数/ ./ 在/ TimeTravel/ 程序/ 中/ ,/ 采用/ R/ 和/ RO/ 方法/ 所/ 获得/ 的/ 切片/ 的/ 精度/ 较/ I/ 方法/ 提高/ 3.3/ %/ ~/ 10/ %/ ,/ 较/ N/ 和/ NO/ 方法/ 提高/ 1.6/ %/ ~/ 3.3/ %/ ,/ 表明/ 对/ 该/ 程序/ 进行/ 切片/ ,/ 存在/ 两类/ 依赖/ 关系/ 不可/ 传递性/ 问题/ ./ 在/ SharedQueue/ 程序/ 中/ ,/ 5/ 种/ 方法/ 切片/ 精度/ 相同/ ,/ 表明/ 对/ 所选/ 切片/ 标准/ 进行/ 切片/ ,/ 不/ 存在/ 依赖/ 关系/ 不可/ 传递性/ 问题/ 和/ 上下文/ 不/ 敏感/ 问题/ ./ 表/ 3/ 给出/ 了/ 不同/ 切片/ 算法/ 的/ 时间/ 性能/ ,/ TB/ 表示/ 构造/ 依赖图/ 的/ 时间/ ,/ TS/ 表示/ 切片/ 时间/ ,/ 其中/ 切片/ 时/ Page10/ 间/ 为/ 各/ 切片/ 时间/ 的/ 平均值/ ./ N/ 、/ NO/ 和/ I/ 方法/ 的/ 切片/ 计算/ 都/ 基于/ TSDG/ 图/ ,/ 依赖图/ 构造/ 时间/ 相同/ ,/ 主要/ 包括/ 程序/ 编译/ 和/ 语句/ 依赖/ 关系/ 分析/ 的/ 时间/ ,/ R/ 和/ RO/ 方法/ 的/ 切片/ 计算/ 基于/ MSDG/ 图/ ,/ 依赖图/ 构造/ 时间/ 包括/ 程序/ 编译/ 、/ 构造/ TIRG/ 图/ 和/ M/ -/ S/ 对/ 依赖/ 关系/ 分析/ 的/ 时间/ ./ 程序/ 线程/ Time/ -/ TravelShared/ -/ Queue/ 程序/ 线程/ Time/ -/ TravelShared/ -/ Queue/ 在/ SharedQueue/ 和/ TimeTravel/ 程序/ 中/ ,/ 当/ 线程/ 数较/ 小时/ ,/ TSDG/ 图/ 与/ MSDG/ 图/ 的/ 构造/ 时间/ 相差/ 不/ 大/ ,/ 但/ 随着/ 线程/ 数/ 的/ 增加/ ,/ TSDG/ 图/ 的/ 构造/ 时间/ 大致/ 呈/ 线性/ 增长/ ,/ 在/ SharedQueue/ 程序/ 中/ ,/ 偏序/ 约简/ 效果/ 较为/ 明显/ ,/ 未/ 约简/ MSDG/ 图/ 的/ 构造/ 时间/ 呈/ 指数/ 级/ 增长/ ,/ 约简/ 的/ MSDGR/ 图则/ 明显/ 减缓/ 增长/ 的/ 幅度/ ,/ 而/ 在/ TimeTravel/ 程序/ 中/ ,/ 略有/ 约简/ ,/ 两者/ 差距/ 不大/ ./ 结合/ 表/ 1/ 可/ 看出/ ,/ 依赖图/ 的/ 构造/ 时间/ 大致/ 与表/ 1/ 中/ 依赖图/ 的/ 大小/ 相吻合/ ./ 由表/ 3/ 可见/ ,/ 采用/ I/ 方法/ 进行/ 切片/ 所/ 花费/ 的/ 平均/ 切片/ 时间/ 较/ 少/ ,/ 切片/ 效率/ 最高/ ,/ 且/ 随着/ 线程/ 数/ 的/ 增加/ ,/ 切片/ 时间/ 大致/ 呈/ 线性/ 增长/ ./ N/ 方法/ 和/ R/ 方法/ 切片/ 效率/ 较/ 低/ ,/ 且/ 随着/ 线程/ 数/ 的/ 增加/ ,/ 切片/ 时间/ 呈/ 指数/ 级/ 增长/ ,/ NO/ 和/ RO/ 方法/ 减缓/ 了/ 这种/ 增长/ 趋势/ ,/ 这些/ 趋势/ 与表/ 2/ 中/ 工作/ 节点/ 数随/ 线程/ 数/ 的/ 增长/ 趋势/ 相吻合/ ./ 表/ 2/ 中/ RO/ 方法/ 的/ 工作/ 节点/ 数/ 明显/ 多于/ NO/ 方法/ 的/ 工作/ 节点/ 数/ ,/ 但/ 由于/ NO/ 方法/ 为/ 解决/ 时序/ 依赖/ 问题/ 在/ 切片/ 过程/ 中/ 对/ 每个/ 工作/ 节点/ 需/ 进行/ 依赖/ 序列/ 是否/ 满足/ 时序/ 要求/ 的/ 检查/ ,/ 因此/ ,/ 在/ 两个/ 实验/ 程序/ 中/ ,/ RO/ 方法/ 的/ 切片/ 时间/ 在/ 大多数/ 情况/ 下/ 表现/ 为/ 少于/ NO/ 方法/ ./ 6/ 相关/ 工作/ Cheng/ [/ 4/ ]/ 最早/ 研究/ 了/ Ada/ 并发程序/ 切片/ ,/ 通过/ 添加/ 选择/ 依赖/ 、/ 同步/ 依赖/ 和/ 通信/ 依赖边/ 将/ 一般/ 顺序程序/ 依赖图/ 扩展/ 为/ 进程/ 依赖/ 网/ (/ PDN/ )/ ,/ 然后/ 遍历/ PDN/ 计算/ 并发程序/ 切片/ ./ Zhao/ [/ 5/ ]/ 在/ PDN/ 上/ 增加/ 形参/ 、/ 实参/ 节点/ 以及/ 相关/ 依赖边/ 表示/ 由于/ 子程序/ 调用/ 引起/ 的/ 数据/ 和/ 控制/ 依赖/ ,/ 生成/ 多线程/ 依赖图/ (/ MDG/ )/ ,/ 同时/ 采用/ 一般/ 顺序/ 子程序/ 两趟/ 式/ 遍历/ 算法/ 遍历/ MDG/ 图/ 计算/ 并发/ 子程序/ 间/ 切片/ 和/ 面向对象/ 的/ 并发程序/ 切片/ ./ Nanda/ 等/ 人/ [/ 12/ ]/ 在/ 系统/ 依赖图/ (/ SDG/ )/ 上/ 添加/ 干扰/ 依赖边/ 生成/ 线程/ 系统/ 依赖图/ (/ TSDG/ )/ 表示/ 并发程序/ 的/ 依赖/ 关系/ ,/ 并/ 在/ 此基础/ 上/ 提出/ 三/ 色/ 两趟/ 式/ 并发/ 子程序/ 间/ 切片/ 方法/ ,/ 对/ 一般/ 顺序/ 子程序/ 两趟/ 式/ 遍历/ 算法/ 进行/ 改进/ ,/ 在/ 遍历/ TSDG/ 图/ 的/ 过程/ 中/ ,/ 通过/ 保证/ 干扰/ 数据/ 依赖边/ 所/ 遍历/ 语句/ 可/ 进行/ 调用/ 上下文/ 的/ 两趟/ 遍历/ ,/ 来/ 确保/ 切片/ 结果/ 的/ 正确性/ ./ Hatcliff/ [/ 6/ ]/ 通过/ 简单/ 遍历/ TSDG/ 图/ 计算/ Java/ 并发程序/ 切片/ ,/ 其/ 切片/ 方法/ 类似/ 于/ Zhao/ 的/ 算法/ ./ 上述/ 4/ 种/ 方法/ 因未/ 考虑/ 并发程序/ 中/ 依赖/ 关系/ 的/ 不可/ 传递性/ 和/ 上下文/ 不/ 敏感/ 问题/ ,/ 直接/ 遍历/ 依赖图/ ,/ 所得/ 切片/ 包含/ 大量/ 冗余/ 语句/ ,/ 精度/ 较/ 低/ ./ 为/ 解决/ 依赖/ 关系/ 不可/ 传递性/ 问题/ ,/ 人们/ 根据/ 依赖/ 序列/ 应/ 满足/ 执行/ 的/ 先后/ 时序/ 要求/ ,/ 提出/ 在/ 遍历/ 并发程序/ 依赖图/ 时/ 进行/ 附加/ 的/ 判断/ ,/ 以/ 提高/ 切片/ 精度/ [/ 7/ -/ 15/ ]/ ./ 如/ 张晶/ 等/ 人/ [/ 7/ ]/ 在/ 遍历/ 依赖图/ 的/ 过程/ 中/ ,/ 根据/ 切片/ 标准/ 的/ 控制流/ 和/ 并行/ 流/ 的/ 可达/ 语句/ 集/ 去除/ 部分/ 冗余/ 语句/ (/ 该/ 方法/ 不能/ 保证/ 每个/ 依赖/ 序列/ 是/ 一个/ 可能/ 的/ 执行/ 语句/ 序列/ )/ ,/ 解决/ 了/ 部分/ 时序/ 依赖/ 不可/ 传递/ 问题/ ./ 陈振强/ 等/ 人/ [/ 8/ ]/ 根据/ 依赖/ 序列/ 的/ 不/ 可能/ 依赖/ 语句/ 集/ 的/ 判断/ 去除/ 冗余/ 语句/ ,/ 由于/ 不/ 可能/ 依赖/ 语句/ 集/ 的/ 保守/ 计算/ ,/ 该/ 方法/ 同样/ 不能/ 保证/ 每个/ 依赖/ 序列/ 是/ 一个/ 可能/ 的/ 执行/ 语句/ 序列/ ,/ 仅/ 解决/ 了/ 部分/ 时序/ 依赖/ 不可/ 传递性/ 问题/ ,/ 但/ 与/ 张晶/ 的/ 方法/ 相比/ ,/ 该/ 方法/ 由于/ 在/ 进行/ 冗余/ 语句/ 判断/ 时/ 不仅/ 考虑/ 了/ 切片/ 标准/ 的/ 可达/ 信息/ ,/ 还/ 考虑/ 了/ 依赖/ 序列/ 中/ 的/ 各/ 节点/ 的/ 可达/ 信息/ ,/ 因此/ 该/ 方法/ 较/ 张晶/ 的/ 方法/ 可/ 去除/ 更/ 多/ 的/ 冗余/ 语句/ ./ Krinke/ [/ 9/ ]/ 提出/ 一种/ 附加/ 判断/ 方法/ ,/ 在/ 遍/ 历时/ 记录/ 各/ 线程/ 的/ 最后/ 依赖/ 语句/ ,/ 当/ 通过/ 干扰/ 依赖/ 到达某/ 线程/ 时/ ,/ 判断/ 当前/ 依赖/ 语句/ 是否/ 存在/ 一条/ 控制流/ 路径/ 到达/ 该/ 线程/ 中/ 所/ 记录/ 的/ 最后/ 依赖/ 语句/ ,/ 由此/ 保证/ 每个/ 依赖/ 序列/ 是/ 一个/ 可能/ 的/ 执行/ 序列/ ,/ 较/ 好地解决/ 了/ 时序/ 依赖性/ 不可/ 传递/ 问题/ ,/ 获得/ 高精度/ 的/ 并发程序/ 切/ Page11/ 片/ ,/ 但/ 该/ 方法/ 的/ 效率/ 较/ 低/ ,/ 具有/ 程序/ 语句/ 数/ 指数/ 级/ 的/ 复杂度/ ./ 在/ 后续/ 的/ 工作/ 中/ ,/ Krinke/ [/ 10/ ]/ 还/ 将/ 该/ 方法/ 扩展/ 到/ 并发/ 子程序/ 间/ 切片/ 的/ 研究/ 中/ ,/ 基于/ 调用/ 串/ 实现/ 子程序/ 虚拟/ 内联/ ,/ 解决/ 了/ 上下文/ 不/ 敏感/ 问题/ ,/ 获得/ 了/ 较/ 高精度/ 的/ 并发/ 子程序/ 间/ 切片/ ./ Nanda/ 等/ 人/ [/ 11/ -/ 12/ ]/ 对/ Krinke/ 的/ 方法/ 进行/ 了/ 完善/ 和/ 优化/ ,/ 提出/ 基于/ 拓扑/ 号/ 的/ 并发/ 子程序/ 间/ 切片/ 方法/ ,/ 采用/ 虚拟/ 内联/ 的/ 方法/ ,/ 对/ 同一/ 语句/ 在/ 不同/ 调用/ 下/ 的/ 执行/ 实例/ 进行/ 区分/ ,/ 在/ 遍历/ 到/ 每个/ 语句/ 时/ 都/ 记录/ 各/ 并发/ 单元/ 在/ 依赖/ 序列/ 中/ 的/ 最近/ 依赖/ 语句/ 的/ 实例/ ,/ 并/ 将/ 该/ 方法/ 应用/ 于/ Java/ 并发程序/ 切片/ ./ Giffhorn/ 等/ 人/ [/ 13/ ]/ 通过/ 实验/ 研究/ ,/ 比较/ 了/ Krink/ 和/ Nanda/ 提出/ 的/ 几种/ 并发程序/ 切片/ 方法/ 及/ 优化/ 措施/ 对/ 并发程序/ 切片/ 精度/ 和/ 效率/ 的/ 影响/ [/ 13/ -/ 15/ ]/ ./ 尽管/ 上述/ 方法/ 从/ 某种程度/ 上/ 提高/ 了/ 切片/ 精度/ ,/ 但/ 由于/ 并发程序/ 依赖图/ 是/ 由/ 各/ 并发/ 单元/ 依赖图/ 通过/ 并发/ 单元/ 间/ 依赖边/ 简单/ 连接/ 构成/ 的/ ,/ 它/ 不能/ 从/ 全局/ 有效/ 地/ 表示/ 并发/ 单元/ 间/ 的/ 依赖/ 关系/ ,/ 这/ 类/ 方法/ 均/ 不能/ 解决/ 共享/ 变量/ 重/ 定义/ 不可/ 传递性/ 问题/ ,/ 并发程序/ 切片/ 的/ 精度/ 仍/ 需/ 进一步提高/ ./ 为/ 解决/ 依赖性/ 不可/ 传递/ 问题/ ,/ 在/ 前期工作/ 中/ ,/ 我们/ 提出/ 了/ 基于/ 程序/ 可达图/ 的/ 并发程序/ 切片/ 方法/ ,/ 该/ 方法/ 可/ 解决/ 时序/ 依赖/ 不可/ 传递性/ 问题/ 和/ 共享/ 变量/ 重/ 定义/ 不可/ 传递性/ 问题/ ,/ 切片/ 精度/ 较/ 上述/ 方法/ 高/ [/ 16/ -/ 19/ ]/ ./ 在/ 切片/ 效率/ 方面/ ,/ 虽然/ 该/ 方法/ 具有/ 程序/ 语句/ 块数/ 指数/ 级/ 的/ 复杂度/ ,/ 在/ 最坏/ 情况/ 下较/ Krinke/ 和/ Nanda/ 切片/ 方法/ 有所提高/ ,/ 但/ 切片/ 效率/ 仍然/ 较/ 低/ ./ 本文/ 采用/ 偏序/ 约简/ 技术/ 约简/ 程序/ 可达图/ ,/ 在/ 保证/ 切片/ 精度/ 不/ 受/ 损失/ 的/ 前提/ 下/ 提高/ 切片/ 效率/ ,/ 实验/ 研究/ 表明/ ,/ 与/ 其它/ 高精度/ 切片/ 方法/ 相比/ ,/ 基于/ 约简/ 程序/ 可达图/ 的/ 切片/ 方法/ 的/ 精度/ 更高/ ,/ 在/ 大多数/ 情况/ 下/ ,/ 切片/ 效率/ 也/ 有/ 一定/ 提高/ ./ 7/ 结论/ 干扰/ 依赖/ 的/ 存在/ 使得/ 并发程序/ 中/ 语句/ 间/ 的/ 依赖/ 关系/ 具有/ 不可/ 传递性/ ,/ 大多数/ 并发程序/ 切片/ 方法/ 只能/ 解决/ 时序/ 依赖/ 不可/ 传递性/ 问题/ ./ 基于/ 程序/ 可达图/ 可/ 构造/ 以/ 程序/ 状态/ 和/ 语句/ 二元/ 组/ 的/ 、/ 具有/ 可/ 传递/ 性质/ 的/ 并发程序/ 依赖图/ ,/ 但/ 可达图/ 存在/ 状态/ 爆炸/ 问题/ ,/ 切片/ 效率/ 较/ 低/ ,/ 并发程序/ 切片/ 技术/ 的/ 应用/ 因此/ 受到限制/ ./ 偏序/ 约简/ 方法/ 是/ 一种/ 十分/ 有效/ 的/ 降低/ 可达性/ 分析/ 代价/ 的/ 方法/ ,/ 本文/ 将/ 偏序/ 约简/ 技术/ 扩展/ 到/ 程序/ 可达图/ 的/ 约简/ 中/ ,/ 在/ 偏序/ 约简/ 理论/ 的/ 基础/ 上/ ,/ 证明/ 了/ 基于/ 未/ 约简/ 和/ 约简/ 的/ 并发程序/ 可达图/ 构造/ 的/ 并发程序/ 依赖图/ 在/ 进行/ 切片/ 计算/ 时/ 是/ 等价/ 的/ ./ 实验/ 研究/ 表明/ ,/ 基于/ 偏序/ 约简/ 程序/ 可达图/ 的/ 并发程序/ 切片/ 方法/ ,/ 在/ 保证/ 切片/ 精度/ 不/ 受/ 损失/ 的/ 前提/ 下/ 可/ 明显提高/ 程序/ 切片/ 的/ 效率/ ./ 与/ 目前/ 经典/ 的/ Nanda/ 所/ 提出/ 带/ 优化/ 的/ 可/ 解决/ 依赖/ 时序/ 问题/ 和/ 上下文/ 不/ 敏感/ 问题/ 的/ 高精度/ 切片/ 算法/ NO/ 相比/ ,/ 基于/ 约简/ 程序/ 可达图/ 的/ 切片/ 方法/ 精度/ 更高/ ,/ 切片/ 效率/ 在/ 大多数/ 情况/ 下好/ 于/ NO/ 方法/ ./ 

