Page1/ 一种/ 面向/ 传感器/ 网络应用/ 程序/ 的/ 有效/ 测试方法/ 孙玉霞/ 1/ )/ ,/ 2/ )/ HARROLDMaryJean3/ )/ 张成志/ 4/ )/ 汤庸/ 5/ )/ 1/ )/ (/ 中山大学/ 计算机科学/ 系/ 广州/ 510006/ )/ 2/ )/ (/ 暨南大学/ 计算机科学/ 系/ 广州/ 510632/ )/ 3/ )/ (/ 乔治亚/ 理工大学/ 计算机/ 学院/ 美国/ 亚特兰大/ 30332/ )/ 4/ )/ (/ 香港科技大学/ 计算机科学/ 与/ 工程系/ 香港/ 999077/ )/ 5/ )/ (/ 华南/ 师范大学/ 计算机/ 学院/ 广州/ 510631/ )/ 摘要/ 无线/ 传感器/ 网络/ 是/ 物/ 联网/ 的/ 基本/ 组成部分/ ./ 随着/ 传感器/ 网络/ 的/ 广泛应用/ ,/ 其/ 软件/ 质量/ 的/ 问题/ 日益突出/ ./ 传感器/ 网络应用/ 程序/ 中/ 的/ 瞬态/ 错误/ 很难/ 被/ 发现/ ,/ 这/ 是因为/ 它们/ 由/ 偶然/ 交织/ 的/ 事件处理/ 逻辑/ 所/ 触发/ ,/ 而且/ 有效/ 的/ 自动测试/ 预言/ 往往/ 不可/ 得/ ./ 基于/ 区间/ 的/ 测试方法/ 将/ 传感/ 网/ 程序/ 的/ 执行/ 过程/ 划分/ 为/ 若干/ 区间/ ,/ 并/ 检测/ 包含/ 瞬态/ 错误/ 的/ 区间/ ,/ 但是/ 这种/ 方法/ 可能/ 产生/ 大量/ 的/ 误报/ ./ 文中/ 详述/ 了/ 对/ 这些/ 误报/ 进行/ 深入研究/ 的/ 结果/ ,/ 并/ 进而/ 提出/ 一种/ 有效/ 的/ 基于/ 区间/ 的/ 测试方法/ ,/ 用于/ 检测/ 传感/ 网/ 程序/ 应用/ 级/ 组件/ 中/ 的/ 瞬态/ 错误/ ./ 此/ 方法/ 的/ 主要/ 特点/ 是/ 采用/ 新/ 的/ 区间/ 划分/ 策略/ 和/ 程序/ 行为/ 选择/ 策略/ ./ 这些/ 策略/ 用于/ 排除/ 被/ 分析/ 区间/ 中/ 的/ 良性/ 偶然/ 交织/ 行为/ ./ 文中/ 提出/ 了/ 一种/ 区间/ 识别/ 算法/ ,/ 并/ 在/ 此基础/ 上/ 实现/ 了/ 该/ 方法/ 的/ 一个/ 原型/ 工具/ ./ 文中/ 给出/ 了/ 一组/ 实验/ 来/ 评估/ 原型/ 工具/ 的/ 效果/ 和/ 效率/ ./ 实验/ 结果表明/ ,/ 此/ 工具/ 能够/ 有效/ 而/ 高效/ 地/ 检测/ 被测/ 程序/ 中/ 的/ 瞬态/ 错误/ ./ 关键词/ 物/ 联网/ ;/ 无线/ 传感器/ 网络/ ;/ 瞬态/ 错误/ ;/ 基于/ 区间/ 的/ 测试/ ;/ 误报/ 1/ 引言/ 无线/ 传感器/ 网络/ 是/ 物/ 联网/ 感知/ 事物/ 和/ 传输数据/ 的/ 重要/ 手段/ ,/ 具有/ 大规模/ 、/ 自/ 组织/ 、/ 拓扑/ 动态变化/ 和/ 节点/ 资源/ 受限/ 等/ 特征/ ./ 随着/ 物/ 联网/ 的/ 兴起/ ,/ 无线/ 传感器/ 网络/ 的/ 应用/ 日益/ 广泛/ ./ 然而/ ,/ 如何/ 开发/ 高质量/ 的/ 软件/ 仍/ 是/ 目前/ 制约/ 传感/ 网/ 应用/ 的/ 难题/ 之一/ [/ 1/ ]/ ./ 实际/ 的/ 传感/ 网/ 应用/ 系统/ 常常/ 因为/ 软件/ 错误/ 而/ 出现/ 各种/ 不可/ 预期/ 的/ 故障/ [/ 2/ -/ 3/ ]/ ./ 当/ 人们/ 把/ 传感/ 网/ 部署/ 到/ 实际/ 环境/ (/ 特别/ 是/ 人/ 难以/ 到达/ 的/ 环境/ )/ 之后/ ,/ 受/ 环境/ 条件/ 所/ 限/ ,/ 往往/ 很难/ 进行/ 软件/ 的/ 查错/ 和/ 排错/ ./ 因此/ ,/ 部署/ 前/ 的/ 程序/ 分析/ 与/ 测试/ 对/ 传感器/ 网络/ 十分/ 重要/ ,/ 本文/ 的/ 研究/ 内容/ 属于/ 此/ 范畴/ ./ 传感/ 网/ 程序/ 具有/ 数据流/ 驱动/ 的/ 特征/ ,/ 因此/ 我们/ 在/ 动态/ 测试/ 传感/ 网/ 程序/ 时/ ,/ 往往/ 需要/ 将/ 程序/ 的/ 执行/ 轨迹/ 划分/ 成/ 区间/ ,/ 通过/ 检测/ 包含/ 错误/ 程序/ 行为/ 的/ 区间/ 来/ 发现/ 程序/ 中/ 的/ 错误/ ./ 本文/ 称/ 这类/ 测试方法/ 为/ “/ 基于/ 区间/ 的/ 测试方法/ ”/ ./ 每种/ 基于/ 区间/ 的/ 测试方法/ 都/ 包括/ 以下/ 4/ 个/ 关键/ 策略/ :/ (/ 1/ )/ “/ 区间/ 的/ 划分/ 策略/ ”/ :/ 测试方法/ 在/ 划分/ 程序/ 的/ 执行/ 轨迹/ 时/ ,/ 所/ 使用/ 的/ 区间/ 可能/ 是/ 某类/ 数据/ 的/ 处理/ 区间/ ,/ 或者/ 某类/ 操作/ 的/ 连续/ 两次/ 执行/ 点/ 之间/ 的/ 区间/ 等/ ;/ (/ 2/ )/ “/ 程序/ 行为/ 的/ 选择/ 策略/ ”/ :/ 测试方法/ 在/ 捕获/ 发生/ 在/ 一个/ 区间/ 中/ 的/ 程序/ 行为/ 时/ ,/ 可以/ 有/ 选择地/ 捕获/ 其中/ 的/ 部分/ 程序/ 行为/ ,/ 比如/ 只/ 捕获/ 那些/ 处理/ 某类/ 数据/ 的/ 程序/ 行为/ ;/ 也/ 可以/ 捕获/ 所有/ 的/ 程序/ 行为/ ;/ (/ 3/ )/ “/ 程序/ 行为/ 特征/ 的/ 选取/ 策略/ ”/ :/ 对/ 一个/ 区间/ 而言/ ,/ 测试方法/ 所/ 选取/ 的/ 程序/ 行为/ 特征/ 可以/ 是/ 指令/ 执行/ 的/ 计数/ 、/ 指令/ 执行/ 的/ 序列/ 、/ 函数调用/ 的/ 序列/ 、/ 或/ 内存/ 位置/ 的/ 访问/ 序列/ 等/ ;/ (/ 4/ )/ “/ 错误/ 区间/ 的/ 检测/ 策略/ ”/ :/ 测试方法/ 为了/ 检测/ 包含/ 错误行为/ 的/ 区间/ ,/ 在/ 已知/ 错误模式/ 时/ 可/ 采用/ 模式匹配/ 等/ 技术/ ;/ 而/ 在/ 未知/ 错误模式/ 时/ 可/ 采用/ 数据挖掘/ 、/ 机器/ 学习/ 或/ 统计/ 的/ 技术/ ,/ 找出/ 可能/ 包含/ 错误行为/ 的/ 区间/ ,/ 并/ 以/ 人工/ 检查/ 辅助/ 判断/ ./ 本文/ 所/ 关注/ 的/ 是/ ,/ 如何/ 采用/ 恰当/ 的/ 策略/ (/ 1/ )/ 和/ 策略/ (/ 2/ )/ 来/ 提高/ 基于/ 区间/ 的/ 测试方法/ 的/ 有效性/ ./ 传感/ 网/ 应用程序/ 是/ 事件驱动/ 的/ 网络/ 嵌入式/ 系统/ ,/ 它/ 通过/ 协同/ 的/ 事件处理/ 逻辑/ 来/ 实现/ [/ 4/ ]/ ./ 当/ 具有/ 隐式/ 依赖/ 关系/ 的/ 处理/ 逻辑/ 在/ 执行/ 中/ 偶然/ 交织/ 时/ ,/ 就/ 可能/ 产生/ 瞬态/ 错误/ ,/ 并/ 可能/ 导致/ 严重/ 的/ 失效/ [/ 5/ ]/ ./ 这些/ 错误/ 的/ 显现/ 很/ 短暂/ ,/ 而且/ 用于/ 揭示/ 它们/ 的/ 有效/ 的/ 自动测试/ 预言/ (/ TestOracle/ )/ 往往/ 不可/ 得/ ,/ 因此/ 这些/ 瞬态/ 错误/ 很难/ 被/ 发现/ ,/ 从而/ 很/ 容易/ 残留/ 在/ 部署/ 后/ 的/ 代码/ 中/ ./ TinyOS/ 操作系统/ 是/ 传感器/ 网络/ 在/ 节点/ 级/ 编程/ 的/ 事实上/ 的/ 标准/ 平台/ ,/ 其/ 应用程序/ 采用/ nes/ C语言/ ,/ 基于/ 组件/ 编写/ 而成/ [/ 6/ ]/ ./ TinyOS/ 系统/ 级/ 的/ 组件/ 被/ 广泛/ 地/ 使用/ 并/ 得到/ 频繁/ 的/ 测试/ ./ 因此/ 在/ TinyOS/ 的/ 应用/ 开发/ 中/ ,/ 我们/ 通常/ 需要/ 重点/ 测试/ 其/ 应用/ 级/ 的/ 组件/ ./ 本文/ 研究/ 如何/ 有效/ 地/ 检测/ 这些/ 应用/ 级/ 组件/ 中/ 的/ 瞬态/ 错误/ ./ 为了/ 发现/ 传感器/ 网/ 程序/ 中/ 的/ 瞬态/ 错误/ ,/ Zhou/ 等/ 学者/ [/ 5/ ]/ 提出/ 了/ 一种/ 基于/ 区间/ 的/ 测试方法/ Sentomist/ ./ 此/ 方法/ 在/ 对/ 程序/ 的/ 执行/ 轨迹/ 进行/ 区间/ 划分/ 时/ ,/ 采用/ 的/ 是/ 指定/ 中断/ 的/ 中断/ 事件处理/ 区间/ ./ Sentomist/ 方法/ 的/ 基本/ 思想/ 是/ :/ 在/ 上述/ 区间/ 中/ ,/ 程序处理/ 同/ 类型/ 的/ 中断/ 事件/ (/ 即/ 指定/ 的/ 中断/ 事件/ )/ ,/ 因此/ 这些/ 区间/ 中/ 所/ 发生/ 的/ 正常/ 程序/ 行为/ 应当/ 具有/ 统计/ 相似性/ ,/ 而/ 偶然/ 的/ 程序/ 行为/ 则/ 很/ 可能/ 是/ 瞬态/ 错误/ 的/ 表现/ ./ Sentomist/ 的/ 程序/ 行为/ 选择/ 策略/ 是/ 捕获/ 发生/ 在/ 每个/ 区间/ 中/ 的/ 所有/ 程序/ 行为/ ,/ 而/ 程序/ 行为/ 的/ 特征/ 是/ 指令/ 的/ 执行/ 计数/ ./ Sentomist/ 根据/ 指令/ 计数/ 对/ 这些/ 区间/ 进行/ 聚类/ ,/ 把/ 对应/ 着/ 聚类/ 离群/ 点/ 的/ 区间/ 看作/ 可能/ 包含/ 瞬态/ 错误/ 的/ 区间/ ,/ 而且/ 离群/ 值越/ 大/ 的/ 区间/ 越/ 可疑/ ;/ 它/ 使用/ 一种/ 异常/ 检测/ 算法/ 对/ 这些/ 区间/ 进行/ 自动/ 排序/ ,/ 区间/ 的/ 排序/ 越靠/ 前/ 表示/ 其/ 包含/ 瞬态/ 错误/ 的/ 可疑/ 度越/ 高/ ./ 在/ Sent/ -/ omist/ 方法/ 中/ ,/ 如果/ 一个/ “/ 正确/ 区间/ ”/ (/ 即/ 实际上/ 不/ 包含/ 瞬态/ 错误/ 的/ 区间/ )/ 排/ 在/ 某个/ “/ 错误/ 区间/ ”/ (/ 即/ 实际上/ Page3/ 包含/ 瞬态/ 错误/ 的/ 区间/ )/ 之前/ ,/ 那么/ 前者/ 就是/ 这种/ 方法/ 的/ 误报/ ./ 对于/ 瞬态/ 错误/ 而言/ ,/ 错误/ 区间/ 的/ 个数/ 非常/ 有限/ ./ 本文/ 根据/ Sentomist/ 方法/ 对/ 这些/ 错误/ 区间/ 的/ 排序/ 结果/ 来/ 衡量/ 该/ 方法/ 的/ 有效性/ ./ 当/ 我们/ 将/ Sentomist/ 方法/ 用于/ 检测/ 传感/ 网/ 程序/ 在/ 应用/ 组件/ 中/ 的/ 瞬态/ 错误/ 时/ ,/ 发现/ 它/ 产生/ 了/ 大量/ 的/ 误报/ ./ 这种/ 误报/ 需要/ 通过/ 人工/ 检查/ 来/ 排除/ ,/ 而/ 人工/ 检查/ 是/ 耗时/ 而/ 高/ 成本/ 的/ ./ 比如/ 根据/ 我们/ 在/ 实验/ 中/ 的/ 经验/ ,/ 检查/ 一个/ 区间/ 往往/ 需要/ 查看/ 100/ (/ 甚至/ 1000/ )/ 个/ 以上/ 的/ 包含/ 程序执行/ 信息/ 的/ 字符串/ ,/ 而/ 让/ 一个/ 测试者/ 一次/ 检查/ 20/ 个/ 以上/ 的/ 区间/ 通常/ 都/ 是/ 困难/ 的/ ./ 因此/ ,/ 降低/ 误报/ 是/ 该/ 方法/ 的/ 重要/ 目标/ ./ 我们/ 实现/ 了/ 新/ 测试方法/ 的/ 一个/ 原型/ 工具/ ,/ 并/ 执行/ 了/ 一组/ 实验/ 来/ 评估/ 它/ 的/ 效果/ ./ 在/ 所有/ 这些/ 实验/ 中/ ,/ 我们/ 的/ 方法/ 都/ 将/ 错误/ 区间/ 排在/ 了/ 最/ 靠/ 前/ 或/ 很/ 靠/ 前/ 的/ 位置/ ./ 实验/ 结果表明/ ,/ 和/ 现有/ 的/ 测试方法/ 相比/ ,/ (/ 1/ )/ 本文/ 测试方法/ 明显/ 地/ 改善/ 了/ 误报/ 问题/ ./ 例如/ ,/ 它/ 可/ 将/ 错/ 通过/ 分析/ 误报/ 产生/ 的/ 原因/ ,/ 我们/ 发现/ 此/ 方法/ 的/ 有效性/ 高度/ 依赖于/ 区间/ 划分/ 策略/ ,/ 无效/ 的/ 划分/ 策略/ 会/ 导致/ 大量/ 的/ 误报/ ./ Sentomist/ 方法/ 所/ 使用/ 的/ 区间/ 是/ 底层/ 系统/ 级/ 事件/ (/ 即/ 中断/ 事件/ )/ 的/ 处理/ 区间/ ./ 然而/ ,/ 发生/ 在/ 此/ 区间/ 的/ 程序/ 偶然/ 行为/ 未必/ 就/ 代表/ 应用/ 组件/ 中/ 的/ 瞬态/ 错误/ ,/ 而/ 有/ 可能/ 是/ 良性/ 的/ 偶然/ 行为/ (/ 详见/ 第/ 3/ 节/ )/ ./ 我们/ 还/ 发现/ 此/ 方法/ 的/ 有效性/ 也/ 受/ 程序/ 行为/ 选择/ 策略/ 的/ 影响/ ./ Sentomist/ 采用/ 了/ 捕获/ 区间/ 中/ “/ 所有/ 程序/ 行为/ ”/ 的/ 策略/ ,/ 其/ 背后/ 的/ 假设/ 是/ “/ 正确/ 区间/ 内/ 的/ 所有/ 程序/ 行为/ 都/ 具有/ 相似性/ ”/ ./ 然而/ ,/ 在/ 上述/ “/ 指定/ 类型/ 事件/ 的/ 处理/ 区间/ ”/ 中/ ,/ 也/ 有/ 可能/ 发生/ 处理/ 各种/ 其它/ 类型/ 事件/ 的/ 行为/ ;/ 而/ 在/ 正确/ 区间/ 中/ 所/ 发生/ 的/ 、/ “/ 处理/ 不同/ 类/ 事件/ 的/ 行为/ ”/ 未必/ 具有/ 相似性/ ./ 为了/ 解决/ 上述/ 的/ 误报/ 问题/ ,/ 我们/ 提出/ 了/ 一种/ 新/ 的/ 基于/ 区间/ 的/ 测试方法/ ./ 根据/ 测试者/ 所/ 指定/ 的/ “/ 应用/ 级/ 事件/ ”/ (/ 即/ 在/ 应用/ 级/ 组件/ 中/ 定义/ 的/ 事件/ )/ ,/ 新/ 方法/ 采取/ 以下/ 两个/ 新策略/ 来/ 排除/ 被/ 分析/ 区间/ 中/ 的/ 良性/ 偶然/ 行为/ :/ (/ 1/ )/ “/ 新/ 的/ 区间/ 划分/ 策略/ ”/ 是/ 新/ 方法/ 的/ 关键/ ,/ 它/ 利用/ 指定/ 的/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ 来/ 划分/ 程序/ 的/ 执行/ 轨迹/ ./ 其/ 结果/ 是/ ,/ 和/ 现有/ 的/ 方法/ 相比/ ,/ 我们/ 的/ 方法/ 能/ 有效/ 地/ 降低/ 误报/ ;/ (/ 2/ )/ 对于/ 在/ 使用/ 上述/ 新策略/ 后/ 仍/ 存在/ 误报/ 的/ 情况/ ,/ 我们/ 进而/ 使用/ “/ 新/ 的/ 程序/ 行为/ 选择/ 策略/ ”/ ,/ 它/ 仅/ 捕获/ 那些/ 处理/ 指定/ 应用/ 级/ 事件/ 的/ 程序/ 行为/ ,/ 即仅/ 捕获/ 指定/ 类型/ 事件/ 的/ 处理过程/ 、/ 而/ 忽略/ 其它/ 类型/ 事件/ 的/ 处理过程/ ./ 我们/ 的/ 实验/ 表明/ ,/ 通过/ 采用/ 此/ 策略/ 能/ 进一步/ 地/ 减少/ 甚至/ 消除/ 误报/ ./ 本文/ 的/ 贡献/ 在于/ :/ (/ 1/ )/ 通过/ 实验/ ,/ 报告/ 并/ 深入分析/ 基于/ 区间/ 的/ 测试方法/ 在/ 检测/ 传感/ 网/ 应用程序/ 的/ 瞬态/ 错误/ 时/ 的/ 误报/ 问题/ ,/ 并/ 指出/ 其/ 产生/ 误报/ 的/ 原因/ ./ (/ 2/ )/ 提出/ 一种/ 新/ 的/ 基于/ 区间/ 的/ 测试方法/ ,/ 用于/ 检测/ 传感/ 网/ 程序/ 在/ 应用/ 级/ 组件/ 中/ 的/ 瞬态/ 错误/ 、/ 缓解/ TestOracle/ 问题/ ./ 此/ 方法/ 的/ 特点/ 是/ 利用/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ ,/ 分析/ 由/ 这些/ 事件/ 所/ 触发/ 的/ 程序/ 行为/ ,/ 提出/ 一种/ 高效/ 的/ 区间/ 识别/ 算法/ ,/ 并/ 在/ 此基础/ 上/ 实现/ 了/ 新/ 方法/ 的/ 一个/ 原型/ 工具/ ./ (/ 3/ )/ 通过/ 实验/ 评估/ 新/ 工具/ 的/ 有效性/ ,/ 并/ 与/ 现有/ 的/ 方法/ 进行/ 比较/ ./ 结果表明/ ,/ 新/ 工具/ 能/ 有效/ 地/ 报告/ 错误/ 区间/ ,/ 并/ 能/ 减轻/ 测试者/ 在/ 人工/ 检查/ 单个/ 区间/ 时/ 的/ 负担/ ./ (/ 4/ )/ 通过/ 实验/ 评估/ 新/ 工具/ 的/ 在线/ 处理/ 效率/ ,/ 并/ 与/ 现有/ 的/ 工具/ 进行/ 比较/ ./ 结果表明/ ,/ 新/ 工具/ 的/ 在线/ 处理过程/ 具有/ 更/ 高/ 的/ 时空/ 效率/ ./ 误区/ 间/ 的/ 排序/ 从/ 第/ 22/ 位/ 提升/ 到/ 第/ 1/ 位/ ;/ (/ 2/ )/ 本文/ 方法/ 所/ 报告/ 的/ 可疑/ 区间/ 具有/ 明显/ 更/ 短/ 的/ 长度/ ,/ 从而/ 能/ 大大/ 减轻/ 人工/ 检查/ 阶段/ 的/ 工作/ ./ 例如/ ,/ 它/ 可以/ 将/ 所/ 报告/ 区间/ 的/ 平均/ 长度/ 减少/ 53/ %/ ./ 基于/ 区间/ 的/ 测试方法/ 在线/ 地/ 识别/ 被测/ 程序/ 的/ 各个/ 区间/ 并/ 收集/ 运行/ 时/ 信息/ ,/ 因此/ 我们/ 关注/ 其/ 在线/ 处理过程/ 的/ 效率/ ./ 本文/ 提出/ 了/ 一种/ 新/ 的/ 区间/ 识别/ 算法/ ,/ 我们/ 的/ 原型/ 工具/ 是/ 基于/ 此/ 算法/ 而/ 实现/ 的/ ./ 我们/ 执行/ 了/ 一组/ 实验/ 来/ 评估/ 该/ 工具/ 的/ 在线/ 处理/ 效率/ ./ 实验/ 结果表明/ ,/ 和/ 现有/ 的/ 测试工具/ 相比/ ,/ 我们/ 测试工具/ 的/ 在线/ 处理过程/ 具有/ 更/ 低/ 的/ 时空/ 耗费/ ./ 本文/ 第/ 2/ 节/ 介绍/ 现有/ 的/ 基于/ 区间/ 的/ 测试方法/ 以及/ 相关/ 的/ 概念/ ;/ 第/ 3/ 节/ 通过/ 一个/ 实际/ 例子/ ,/ 分析/ 发生/ 在/ 中断/ 处理/ 区间/ 中/ 的/ 良性/ 偶然/ 行为/ ;/ 第/ 4/ 节/ 详细描述/ 我们/ 的/ 基于/ 区间/ 的/ 测试方法/ ;/ 第/ 5/ 节/ 通过/ 实验/ 评估/ 和/ 分析/ 我们/ 方法/ 的/ 效果/ 和/ 效率/ ;/ 第/ 6/ 节/ 介绍/ 相关/ 工作/ ;/ 第/ 7/ 节/ 总结/ 全文/ 并/ 展望未来/ 的/ 工作/ ./ 2/ 背景/ 介绍/ 2.1/ 相关/ 概念/ TinyOS/ 应用程序/ 是/ 基于/ 组件/ 的/ 程序/ ,/ 其/ 系统/ 级/ 组件/ 由/ TinyOS/ 服务/ 包/ 提供/ ,/ 而/ 其/ 应用/ 级/ 组件/ 包括/ 应用/ 特定/ 的/ 用户/ 组件/ 和/ 应用/ 相关/ 的/ 路由/ 协议/ 组件/ ./ 组件/ 中/ 的/ nesC/ 模块/ 包括/ 如下/ 形式/ :/ 中断/ 处理/ 模块/ (/ Interrupt/ -/ Handler/ )/ 、/ 任务/ (/ task/ )/ 、/ nesC/ 事件/ Page4/ (/ event/ )/ 函数/ 、/ nesC/ 命令/ (/ command/ )/ 函数/ 和/ C/ 函数/ [/ 6/ ]/ ./ 其中/ ,/ nesC/ 事件/ 函数/ 是非/ 中断/ 事件/ 的/ 事件处理/ 模块/ (/ Event/ -/ Handler/ )/ ,/ 关键字/ event/ 和/ signal/ 分别/ 用于/ 声明/ 和/ 调用/ 它/ ./ 一个/ 异步/ 的/ (/ async/ )/ nesC/ 事件/ 函数/ 从/ 中断/ 处理/ 模块/ 中/ 抢占/ 式/ 地/ 执行/ ,/ 而/ 一个/ 同步/ 的/ nesC/ 事件/ 函数/ 则/ 只能/ 从/ 任务/ 中/ 执行/ ./ 当/ 一个/ 中断/ 事件/ 发生/ 时/ ,/ 微控制器/ 单元/ (/ MCU/ )/ 将/ 自动/ 调用/ 相应/ 的/ 应用逻辑/ 以/ 处理/ 此/ 事件/ ,/ 文献/ [/ 5/ ]/ 称/ 这种/ 应用逻辑/ 为/ “/ 事件/ 过程/ ”/ (/ Event/ -/ Procedure/ )/ ./ 一个/ 典型/ 中断/ 事件/ 的/ 事件/ 过程/ 包括/ 立即/ 执行/ 的/ 中断/ 处理/ 模块/ 和/ 一些/ 延迟/ 执行/ 的/ 任务/ [/ 5/ ]/ ./ 由于/ nesC/ 模块/ 之间/ 相互依赖/ 、/ 复杂/ 交织/ ,/ TinyOS/ 程序/ 的/ 动态/ 执行/ 过程/ 难以/ 理解/ 、/ 容易/ 出错/ ./ TinyOS/ 程序/ 中/ 的/ 事件处理/ 模块/ 可/ 分为/ 中断/ 事件处理/ 模块/ 和/ 非/ 中断/ 事件/ 的/ 处理/ 模块/ ,/ 其中/ 后者/ 包括/ 应用/ 级/ 事件/ 的/ 处理/ 模块/ ./ 最底层/ 的/ 硬件/ 中断/ 触发/ 中断/ 处理/ 模块/ 的/ 执行/ ,/ 在/ 执行/ 过程/ 中/ 可/ 通过/ signal/ 操作/ 向上/ 触发/ 一系列/ 的/ 非/ 中断/ 事件处理/ 模块/ ./ 典型/ 的/ 处理/ 链/ 依次/ 涉及/ 字节/ 级/ 组件/ 、/ 包级/ 组件/ 、/ 消息/ 级/ 组件/ ,/ 最后/ 可能/ 到达/ 应用/ 级/ 组件/ [/ 7/ ]/ ./ 每个/ 应用/ 级/ 事件/ 类型/ 都/ 有/ 一个/ “/ 相应/ 的/ ”/ 中断/ 类型/ ,/ 即/ 触发/ 向上/ 处理/ 链/ 的/ 那个/ 中断/ 的/ 类型/ ./ 表/ 1/ 列出/ 了/ 3/ 种/ 典型/ TinyOS/ 应用程序/ 的/ 3/ 个/ 应用/ 级/ 事件/ 的/ 类型/ 及其/ 相应/ 的/ 中断/ 类型/ ./ 其中/ ,/ 应用程序/ Osilloscope/ 是/ 一个/ 采集/ 传感器/ 数据/ 的/ 程序/ ,/ 它/ 使用/ 单跳/ 技术/ 传送/ 数据包/ ;/ TestBlink/ 实现/ 了/ 数据包/ 的/ 多/ 跳/ 传送/ ;/ TestCTP/ 使用/ 一种/ 汇聚/ 树/ 路由/ 协议/ 传送/ 传感/ 读数/ ./ 这些/ 程序/ 来自/ TinyOS2/ ./ x/ 软件包/ ①/ 或者/ Sentomist/ 工具/ 的/ 软件包/ ②/ ./ 第/ 2/ 列/ 的/ 应用/ 级/ 事件/ 以/ “/ 应用/ 级/ 组件/ 名/ ./ 接口/ 名/ ./ 事件/ 名/ ”/ 的/ 形式/ 表示/ ,/ 其中/ 的/ AdcMessageC/ 和/ BlinkToRadioC/ 是/ 用户/ 自定义/ 的/ 组件/ ,/ 而/ CtpForwardingEngineP/ 是/ 路由/ 协议/ 组件/ ./ 这些/ 应用/ 级/ 事件/ 分别/ 对应/ 3/ 种/ 典型/ 的/ 硬件/ 中断/ ,/ 即/ ADC/ 中断/ 、/ SPI/ 中断/ 和/ 定时器/ 中断/ ./ 表/ 1/ 典型/ 应用程序/ 的/ 应用/ 级/ 事件/ 及其/ 对应/ 的/ 中断/ 应用程序/ OscilloscopeAdcMessageC/ ./ Read/ ./ readDoneADCTestBlinkBlinkToRadioC/ ./ Receive/ ./ receiveSPITestCTPCtpForwardingEngineP/ ./ 0.2/ ./ 2Sentomist/ 方法/ Sentomist/ 方法/ [/ 5/ ]/ 用于/ 检测/ 传感/ 网/ 程序/ 中/ 的/ 瞬态/ 错误/ ,/ 其/ 基本/ 假设/ 是/ :/ 在/ 同一/ 中断/ 的/ 各个/ 中断/ 处理/ 区间/ 中/ ,/ 所/ 发生/ 的/ 正常/ 程序/ 行为/ 应当/ 具有/ 统计/ 相似性/ ,/ 而/ 异常/ 的/ 程序/ 行为/ 则/ 很/ 可能/ 是/ 瞬态/ 错误/ 的/ 表现/ ./ Sentomist/ 方法/ 输入/ 二进制/ 的/ 程序代码/ 、/ 程序/ 的/ 测试/ 场景/ 以及/ 测试者/ 所/ 指定/ 的/ 中断/ 事件/ 类型/ ,/ 并/ 运行/ 这些/ 测试/ 以/ 获取/ 程序/ 的/ 执行/ 轨迹/ ./ Sentomist/ 是/ 一种/ 基于/ 区间/ 的/ 测试方法/ ,/ 它/ 根据/ 测试者/ 指定/ 的/ 中断/ 类型/ ,/ 将/ 程序/ 的/ 执行/ 轨迹/ 划分/ 成/ 此类/ 中断/ 事件/ 的/ 处理/ 区间/ ./ 它/ 使用/ 一个/ N/ 元/ 向量/ ,/ 捕获/ 发生/ 在/ 每个/ 区间/ 中/ 的/ 所有/ 程序/ 行为/ (/ 其中/ ,/ N/ 是/ 程序/ 机器指令/ 的/ 总数/ ,/ 而/ 第/ i/ 个/ 向量/ 元素/ 表示/ 第/ i/ 条/ 指令/ 在/ 此/ 区间/ 的/ 执行/ 次数/ )/ ;/ 与此同时/ ,/ 它/ 记录/ 发生/ 在/ 每个/ 区间/ 的/ 函数调用/ 序列/ ,/ 以备/ 人工/ 检查/ ./ 此/ 方法/ 在/ 获得/ 基于/ 区间/ 的/ 运行/ 数据/ 之后/ ,/ 使用/ one/ -/ classSVM/ [/ 8/ ]/ 作为/ 异常/ 检测/ 算法/ ,/ 根据/ 区间/ 向量/ 的/ 异常情况/ 对/ 区间/ 进行/ 排序/ :/ 一个/ 向量/ 越/ 异常/ ,/ 就/ 意味着/ 它/ 包含/ 瞬态/ 错误/ 的/ 可疑/ 度越/ 高/ ,/ 而/ 其/ 排序/ 也/ 越/ 高/ ./ 最后/ ,/ 测试者/ 按/ 区间/ 排序/ 从/ 高到/ 低/ 逐个/ 检查/ 区间/ 的/ 函数调用/ 序列/ ,/ 直至/ 找到/ 瞬态/ 错误/ ./ 3/ 举例/ 分析/ Sentomist/ 方法/ 使用/ 中断/ 事件/ 的/ 处理/ 区间/ ,/ 分析/ 发生/ 在/ 这些/ 区间/ 中/ 的/ 所有/ 程序/ 行为/ ./ 然而/ ,/ 发生/ 在/ 这些/ 区间/ 中/ 的/ 偶然/ 行为/ 未必/ 就/ 代表/ 应用/ 组件/ 中/ 的/ 瞬态/ 错误/ ./ 本节/ 将/ 以表/ 1/ 中/ 的/ TestBlink/ 程序/ 为例/ ,/ 对/ 这些/ 行为/ 进行/ 分析/ ./ 图/ 1/ 所示/ 的/ 代码/ 片段/ 是/ TestBlink/ 程序/ 中/ 与/ SPI/ (/ 串行/ 外部设备/ 接口/ )/ 中断/ 的/ 事件/ 过程/ 相关/ 的/ 部分/ 代码/ ./ SPI/ 中断/ 会/ 触发/ Mica2/ 平台/ 的/ 射频/ 芯片/ CC1000/ 的/ 功能/ ③/ ./ 图中/ 的/ 系统/ 级/ 组件/ HplCC1000SpiP/ 实现/ 底层/ 的/ 功能/ ,/ 例如/ 访问/ CC1000/ 总线/ 的/ 中断/ 处理/ 模块/ ;/ 而/ 组件/ CC1000SendReceiveP/ 实现/ 发送/ 和/ 接收/ CC1000/ 射频/ 信号/ 的/ 功能/ ./ 事件处理/ 模块/ 的/ 一次/ 完整/ 的/ 执行/ 轨迹/ 就是/ 一个/ 事件/ 过程/ 实例/ ./ 在/ 图/ 1/ 中/ ,/ 一个/ SPI/ 中断/ 事件/ 的/ 过程/ 实例/ 始于/ SPI/ 中断/ 处理/ 模块/ 的/ 入口/ (/ 第/ H1/ 行/ )/ ;/ 此/ 模块/ 在/ 执行/ 第/ H2/ 行时/ 、/ 通过/ 组件/ CC1000SendReceivedP/ 的/ 接口/ HplCC1000Spi/ 调用/ 第/ C1/ 行/ ,/ 而/ 组件/ CC1000SendReceivedP/ 被/ 连接/ 到/ 组件/ HplCC1000SpiP/ ./ 于是/ ,/ SPI/ 的/ 中断/ 事件/ 过程/ 实/ ①/ ②/ ③/ Page5/ 例/ 就/ 延伸/ 到/ 了/ 组件/ CC1000SendReceiveP/ ./ 沿着/ 执行/ 轨迹/ H1/ -/ H2/ -/ C1/ -/ C6/ -/ C9/ -/ C11/ -/ C15/ -/ C16/ ,/ 如果/ 第/ C16/ 行/ 的/ 任务/ 提交/ 是/ 成功/ 的/ ,/ 那么/ 第/ C19/ 行/ 的/ 任务/ 将/ 被/ 执行/ 、/ 并/ 成为/ 一个/ SPI/ 事件/ 过程/ 实例/ 的/ 一部分/ ;/ 否则/ ,/ 该/ 任务/ 将/ 不会/ 被/ 执行/ ,/ 也/ 不是/ SPI/ 事件/ 过程/ 实例/ 的/ 一部分/ ./ HplCC1000SpiP/ ./ nc/ :/ // // 系统/ 级/ 组件/ // / SPI/ 中断/ 处理/ 模块/ / // H1/ :/ AVR/ _/ ATOMIC/ _/ HANDLER/ (/ 犛/ 犐/ 犌/ _/ 犛/ 犘/ 犐/ )/ {/ …/ H2/ :/ signalHplCC1000Spi/ ./ dataReady/ (/ temp/ )/ ;/ H3/ :/ }/ CC1000SendReceiveP/ ./ nc/ :/ // // 系统/ 级/ 组件/ C1/ :/ asynceventvoidHplCC1000Spi/ ./ dataReady/ (/ uint8/ _/ tdata/ )/ C2/ :/ {/ …/ C3/ :/ switch/ (/ radioState/ )/ {/ C4/ :/ default/ :/ break/ ;/ C5/ :/ caseSYNC/ _/ STATE/ :/ syncData/ (/ data/ )/ ;/ break/ ;/ C6/ :/ caseSENDING/ _/ ACK/ :/ ackData/ (/ data/ )/ ;/ break/ ;/ C7/ :/ …/ }/ C8/ :/ }/ C9/ :/ voidackData/ (/ uint8/ _/ tin/ )/ {/ C10/ :/ if/ (/ ++/ count/ >/ =/ ACK/ _/ LENGTH/ )/ {/ …/ C11/ :/ packetReceiveDone/ (/ )/ ;/ }/ C12/ :/ elseif/ (/ count/ >/ =/ ACK/ _/ LENGTH/ -/ sizeofackCode/ )/ C13/ :/ callHplCC1000Spi/ ./ writeByte/ (/ …/ )/ ;/ C14/ :/ }/ C15/ :/ voidpacketReceiveDone/ (/ )/ {/ …/ C16/ :/ postsignalPacketReceived/ (/ )/ ;/ C17/ :/ …/ C18/ :/ }/ C19/ :/ taskvoidsignalPacketReceived/ (/ )/ {/ …/ C20/ :/ pBuf/ =/ signalReceive/ ./ receive/ (/ …/ )/ ;/ C21/ :/ …/ C22/ :/ }/ BlinkToRadioC/ ./ nc/ :/ // // 应用/ 级/ 组件/ B1/ :/ eventmessage/ _/ t/ / Receive/ ./ receive/ (/ …/ )/ {/ …/ B2/ :/ if/ (/ TOS/ _/ NODE/ _/ ID/ =/ =/ TARGET/ )/ {/ …/ B3/ :/ postuartSendTask/ (/ )/ ;/ }/ B4/ :/ else/ {/ …/ B5/ :/ callAMSend/ ./ send/ (/ …/ )/ ;/ }/ B6/ :/ …/ B7/ :/ }/ B8/ :/ taskvoiduartSendTask/ (/ )/ {/ B9/ :/ if/ (/ callSerialSend/ ./ send/ (/ …/ )/ !/ =/ SUCCESS/ )/ {/ …/ }/ B10/ :/ …/ B11/ :/ }/ 图/ 1TestBlink/ 程序/ 中/ 与/ SPI/ 中断/ 事件/ 过程/ 有关/ 的/ 图/ 2/ 示例/ 了/ TestBlink/ 程序/ 中/ 与/ SPI/ 中断/ 事件/ 过程/ 有关/ 的/ 部分/ 执行/ 轨迹/ ./ 图中/ 的/ 每个/ 矩形/ 节点/ 表示/ 一个/ 被/ 执行/ 的/ 函数/ :/ 若此/ 函数/ 在/ 图/ 1/ 中有/ 相应/ 的/ 代码/ ,/ 则/ 其/ 节点/ 以/ 代码/ 行号/ 为/ 前缀/ ,/ 否则/ 其/ 节点/ 以/ Nodei/ (/ 1/ / i/ / 2/ )/ 为/ 前缀/ ;/ 带有/ 实线/ 圆角/ 矩形/ 的/ Endi/ (/ 1/ / i/ / 5/ )/ 节点/ 表示/ 相应/ 的/ 执行/ 轨迹/ 在/ 字节/ 级/ 或/ 包级/ 结束/ ,/ 而/ 带有/ 虚线/ 圆角/ 矩形/ 的/ Endi/ (/ 6/ / i/ / 7/ )/ 节点/ 表示/ 相应/ 的/ 执行/ 轨迹/ 延伸/ 到/ “/ 应用/ 组件/ 级/ ”/ (/ 简称/ “/ 应用/ 级/ ”/ )/ ;/ 有/ 向/ 边/ 代表/ 节点/ 的/ 执行/ 顺序/ ./ 于是/ ,/ 图/ 2/ 中/ 的/ 每条/ 路径/ 对应/ SPI/ 中断/ 事件/ 过程/ 的/ 一种/ 执行/ 轨迹/ ,/ 它/ 始于/ 前缀/ 为/ H1/ 的/ 节点/ ,/ 而/ 终于/ 一个/ Endi/ (/ 1/ / i/ / 7/ )/ 节点/ ./ 图/ 2TestBlink/ 程序/ 中/ 与/ SPI/ 中断/ 事件/ 过程/ 有关/ 的/ 在/ 图/ 2/ 中/ ,/ 有/ 5/ 个/ 执行/ 轨迹/ ,/ 即以/ Endi/ (/ 1/ / i/ / 5/ )/ 结束/ 的/ 轨迹/ ,/ 不/ 涉及/ 任何/ 应用/ 级/ 的/ 事件/ ;/ 有/ 4/ 个/ 执行/ 轨迹/ ,/ 即以/ Endi/ (/ 1/ / i/ / 4/ )/ 结束/ 的/ 轨迹/ ,/ 执行/ 系统/ 级/ 功能/ ,/ 例如/ 介质/ 访问控制/ 、/ 低功耗/ 监听/ 和/ 通用/ 控制/ 等/ 功能/ ./ 上述/ 执行/ 轨迹/ 中/ 的/ 程序/ 行为/ 仅仅/ 由/ 系统/ 级/ 组件/ 完成/ ,/ 而/ 与/ 应用/ 级/ 组件/ 的/ 执行/ 无关/ ./ 以/ End5/ 为/ 终点/ 的/ 轨迹/ ,/ 终止/ 于/ 一个/ 失败/ 的/ 系统/ 任务/ 提交/ 操作/ ./ 此/ 轨迹/ 的/ 行为/ 都/ 是/ 由/ 系统/ 级/ 的/ 函数/ 来/ 执行/ ,/ 而/ 与/ 特定/ 的/ 应用/ 无关/ ./ 总之/ ,/ 上述/ 的/ 执行/ 轨迹/ 均/ 不/ 涉及/ 应用/ 级/ Page6/ 的/ 事件/ ./ 而/ 这样/ 的/ 执行/ 轨迹/ 在/ TinyOS/ 程序/ 中是/ 常见/ 的/ ,/ 这/ 是因为/ :/ (/ 1/ )/ 系统/ 级/ 的/ 功能/ ,/ 如/ 介质/ 访问控制/ 等/ 功能/ ,/ 是/ 大部分/ 应用程序/ 的/ 共同/ 基础/ ;/ (/ 2/ )/ 在/ 程序执行/ 中/ ,/ 失败/ 的/ 系统/ 任务/ 提交/ 操作/ 是/ 常见/ 的/ ,/ 特别/ 是/ 当/ 中断/ 发生/ 的/ 频率/ 较/ 高时/ ./ 根据/ 我们/ 的/ 实验/ 结果/ (/ 见/ 第/ 5.3/ 节/ )/ ,/ 在/ 一个/ TinyOS/ 程序/ 的/ 一次/ 运行/ 中/ ,/ 不/ 涉及/ 应用/ 级/ 事件/ 的/ 执行/ 轨迹/ 可以/ 高达/ 99/ %/ ./ 在/ 图/ 2/ 中/ ,/ 分别/ 以/ End6/ 和/ End7/ 为/ 终点/ 的/ 两个/ 轨迹/ 都/ 包含/ 一个/ 应用/ 级/ 事件/ BlinkToRadioC/ ./ Receive/ ./ receive/ (/ 对应/ 前缀/ 为/ B1/ 的/ 节点/ )/ ./ 在/ 前缀/ 为/ H1/ 的/ 节点/ 和/ Node1/ 节点/ 之间/ 的/ 程序执行/ 段/ ,/ 发生/ 在/ 所有/ 的/ 应用/ 级/ 事件/ 触发/ 之前/ ./ 系统/ 级/ 的/ 组件/ 决定/ 了/ 此/ 执行/ 段/ 的/ 行为/ ;/ 而/ 发生/ 在/ 此/ 执行/ 段/ 之后/ 的/ 应用/ 级/ 事件/ (/ 例如/ 前缀/ 为/ B1/ 的/ 节点/ )/ 并/ 不会/ 影响/ 此/ 执行/ 段/ 的/ 行为/ ./ 这些/ 系统/ 级/ 的/ 行为/ 都/ 是/ 与/ 应用/ 级/ 组件/ 无关/ 的/ ./ 发生/ 在/ 前缀/ 为/ B1/ 的/ 节点/ 与/ End6/ (/ 或/ End7/ )/ 节点/ 之间/ 的/ 程序执行/ 段/ 、/ 是/ 由/ 应用/ 级/ 事件/ BlinkToRadioC/ ./ Receive/ ./ receive/ 所/ 触发/ 的/ ./ 此/ 执行/ 段/ 的/ 程序/ 行为/ 可/ 被/ 看作/ 是/ 由/ 应用/ 级/ 事件/ 所/ 直接/ 驱动/ 、/ 而/ 由/ SPI/ 中断/ 事件/ 所/ 间接/ 驱动/ 的/ ./ 本文/ 研究/ 如何/ 揭示/ 传感/ 网/ 程序/ 的/ 应用/ 级/ 组件/ 中/ 的/ 瞬态/ 错误/ ./ 在/ 一个/ 中断/ 事件/ 的/ 处理/ 区间/ 中/ ,/ 不/ 涉及/ 应用/ 级/ 组件/ 执行/ 的/ 偶然/ 行为/ 有/ 可能/ 是/ 无错/ 的/ ,/ 即/ 良性/ 的/ ./ 在/ 图/ 2/ 中/ ,/ 这些/ 良性/ 行为/ 的/ 例子/ 包括/ :/ (/ 1/ )/ 发生/ 在/ 以/ Endi/ (/ 1/ / i/ / 5/ )/ 为/ 终点/ 的/ 执行/ 轨迹/ 中/ 的/ 偶然/ 行为/ ;/ (/ 2/ )/ 发生/ 在/ 前缀/ 为/ H1/ 的/ 节点/ 和/ Node1/ 节点/ 之间/ 的/ 执行/ 段/ 中/ 的/ 偶然/ 行为/ ./ 此外/ ,/ 具有/ 相同/ 事件/ 类型/ 的/ 事件/ 过程/ 会/ 共享/ 变量/ 或者/ 共享/ 事件处理/ 逻辑/ ./ 根据/ 我们/ 的/ 编程/ 经验/ ,/ 数据/ 依赖/ 和/ 控制/ 依赖/ 大量/ 地/ 存在/ 于/ 这些/ 事件/ 过程/ 之间/ ,/ 而/ 具有/ 不同/ 事件/ 类型/ 的/ 事件/ 过程/ 之间/ 往往/ 较/ 少/ 存在/ 依赖/ ./ 因此/ ,/ 由/ 不同/ 事件/ 类型/ 的/ 事件/ 过程/ 交织/ 而/ 造成/ 的/ 偶然/ 行为/ 很/ 可能/ 是/ 良性/ 的/ ./ 例如/ ,/ 在/ 图/ 2/ 的/ 任何/ 执行/ 轨迹/ 中/ 都/ 可能/ 发生/ 这种/ 良性/ 行为/ ./ 直观/ 地看/ ,/ 为了/ 在/ 基于/ 区间/ 的/ 测试/ 中/ 减少/ 误报/ ,/ 我们/ 需要/ 排除/ 被/ 分析/ 区间/ 中/ 的/ 良性/ 偶然/ 行为/ ./ 为此/ ,/ 我们/ 提出/ 了/ 一种/ 新/ 的/ 基于/ 区间/ 的/ 测试方法/ ,/ 下/ 一节/ 将/ 详述/ 我们/ 的/ 方法/ ./ 4/ 基于/ 区间/ 的/ 测试方法/ 为了/ 有效/ 地/ 发现/ 传感/ 网/ 应用/ 级/ 组件/ 中/ 的/ 瞬态/ 错误/ ,/ 我们/ 提出/ 一种/ 基于/ “/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ ”/ 的/ 测试方法/ ./ 本节/ 首先/ 给出/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ 的/ 定义/ ,/ 然后/ 描述/ 如何/ 识别/ 这些/ 区间/ ,/ 最后/ 阐述/ 我们/ 的/ 测试方法/ 的/ 具体步骤/ ./ 4.1/ 定义/ 在/ 一个/ nesC/ 程序/ 中/ ,/ 设/ EH/ 是/ 在/ 应用/ 级/ 组件/ 中/ 定义/ 的/ 一个/ 事件处理/ 模块/ ,/ 则/ EH/ 所/ 处理/ 的/ 事件/ e/ 称为/ 一个/ 应用/ 级/ 事件/ ./ 下面/ 给出/ 应用/ 级/ 事件/ 的/ 相关/ 定义/ ./ 定义/ 1/ ./ 事件/ 过程/ (/ Event/ -/ Procedure/ )/ ./ EH/ (/ 或/ e/ )/ 的/ 事件/ 过程/ 由/ 以下/ 3/ 种/ nesC/ 模块/ 的/ 静态/ 代码/ 组成/ :/ EH/ 、/ EH/ 所/ 调用/ 的/ 模块/ 和/ EH/ 的/ 任务/ ./ 其中/ ,/ (/ 1/ )/ EH/ 所/ 调用/ 的/ 模块/ 是/ 这样/ 一个/ 函数/ ,/ 它/ 被/ EH/ 、/ EH/ 所/ 调用/ 的/ 模块/ 或者/ EH/ 的/ 任务/ 所/ 调用/ ;/ (/ 2/ )/ EH/ 的/ 任务/ 是/ 这样/ 一个/ 任务/ ,/ 它/ 被/ EH/ 、/ EH/ 所/ 调用/ 的/ 模块/ 或者/ EH/ 的/ 任务/ 所/ 提交/ ./ 定义/ 2/ ./ 事件/ 过程/ 实例/ (/ Event/ -/ Procedure/ -/ Instance/ )/ ./ EH/ (/ 或/ e/ )/ 的/ 一个/ 事件/ 过程/ 实例/ ,/ 简称/ 实例/ ,/ 是/ “/ EH/ 的/ 事件/ 过程/ ”/ 的/ 一次/ 执行/ ./ 此/ 实例/ 所/ 调用/ 的/ 模块/ 是/ 指/ 在/ 此次/ 执行/ 中/ 所/ 包含/ 的/ “/ EH/ 所/ 调用/ 的/ 模块/ ”/ ./ 此/ 实例/ 的/ 任务/ 是/ 指/ 在/ 此次/ 执行/ 中/ 所/ 包含/ 的/ (/ 也/ 即/ 被/ 成功/ 提交/ 的/ )/ “/ EH/ 的/ 任务/ ”/ ./ 定义/ 3/ ./ 事件/ 过程/ 实例/ 的/ 区间/ (/ Interval/ )/ ./ EH/ 的/ 一个/ 事件/ 过程/ 实例/ 的/ 执行/ 时间/ 称为/ 此/ 事件/ 过程/ 实例/ 的/ 区间/ ,/ 也/ 称/ 事件/ e/ 的/ 处理/ 区间/ ./ 直观/ 看来/ ,/ 一个/ 事件/ 过程/ 实例/ 包括/ 一个/ EH/ 运行/ 部分/ 和/ 若干个/ (/ 零个/ 或/ 多个/ )/ 任务/ 运行/ 部分/ ;/ 事件/ e/ 的/ 一个/ 处理/ 区间/ 始于/ 其/ 事件/ 过程/ 实例/ 的/ 起点/ (/ 即/ EH/ 的/ 入口/ 执行/ 点/ )/ ,/ 而/ 终于/ 此/ 实例/ 的/ 终点/ (/ 即此/ 实例/ 的/ EH/ 的/ 出口/ 执行/ 点/ 、/ 或者/ 此/ 实例/ 的/ 最后/ 一个/ 任务/ 的/ 出口/ 执行/ 点/ )/ ./ 在/ 定义/ 1/ 中/ 引入/ 了/ “/ EH/ 所/ 调用/ 的/ 模块/ ”/ ,/ 这/ 是因为/ 当/ EH/ 的/ 实例/ 所/ 调用/ 的/ 模块/ 成功/ 地/ 提交/ 了/ 一个/ 任务/ 时/ ,/ 此/ 任务/ 将来/ 的/ 执行/ 也/ 成为/ 此/ 实例/ 的/ 一部分/ ./ 在/ 定义/ 2/ 中/ 只/ 考虑/ 被/ 成功/ 提交/ 的/ 任务/ ,/ 这/ 是因为/ 一个/ 任务/ 提交/ 操作/ 未必/ 会/ 成功/ :/ 例如/ 在/ TinyOS2/ 中/ ,/ 当/ 一个/ 任务/ 在/ 队列/ 中/ 等待/ 执行/ 时/ ,/ 其它/ 同名/ 任务/ 的/ 提交/ 操作/ 都/ 会/ 失败/ [/ 6/ ]/ ./ 假设/ e/ 是/ 一个/ 中断/ 事件/ ,/ 而/ IH/ 是/ e/ 的/ 中断/ 处理/ 模块/ ,/ 那么/ 将/ 上述/ 3/ 个/ 定义/ 中/ 的/ EH/ 全部/ 替换/ 为/ IH/ ,/ 就/ 可/ 得到/ 中断/ 事件/ 的/ 所有/ 相关/ 定义/ ./ 为了/ 更/ 直观/ 地/ 说明/ 上述/ 的/ 概念/ ,/ 图/ 3/ 示例/ 了/ “/ 应用/ 级/ 事件/ ”/ 的/ 处理/ 区间/ 和/ “/ 相应/ 的/ 中断/ 事件/ (/ 含义/ 见/ 2.1/ 节/ )/ ”/ 的/ 处理/ 区间/ ./ 图中/ 的/ EH/ 是/ 应用/ 级/ 事件/ 的/ 处理/ 模块/ ,/ 其/ 事件/ 过程/ 实例/ 用/ 黑/ 实线/ 表示/ ;/ IH/ 是/ 相应/ 的/ 中断/ 事件/ 的/ 处理/ 模块/ ,/ 其/ 事件/ 过程/ 实例/ 用/ 灰/ 实线/ 表示/ ./ 应用/ 级/ 事件/ 可/ 分成/ 异步/ 事件/ 和/ 同步/ 事件/ 两种/ 类型/ ,/ 子图/ (/ a/ )/ 和/ (/ b/ )/ 分别/ 示例/ 这/ 两种/ 情况/ 下/ 的/ 实例/ 执行/ 情况/ ./ 如图所示/ ,/ 在/ 这/ 两种/ 情况/ 下/ ,/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ 都/ 是/ 相应/ 中断/ 事件处理/ 区间/ 的/ 子/ 区间/ ./ Page7/ 图/ 3/ 应用/ 级/ 事件/ 及其/ 对应/ 中断/ 事件/ 的/ 处理/ 区间/ 4.2/ 区间/ 的/ 识别方法/ 实现/ 基于/ 区间/ 的/ 测试方法/ 的/ 关键/ 之一/ 是/ 识别/ 相应/ 的/ 区间/ ./ 识别/ 给定/ 事件/ 的/ 处理/ 区间/ ,/ 就是/ 在/ 被/ 测/ 程序执行/ 时/ 识别/ 这些/ 区间/ 的/ 起点/ 和/ 终点/ ./ 我们/ 用/ i/ 表示/ 被测/ 程序/ 当前/ 执行/ 的/ 机器指令/ ./ 当/ i/ 是/ 给定/ 的/ 中断/ 处理/ 模块/ 的/ 入口/ 指令/ 时/ ,/ 给定/ 中断/ 的/ 一个/ 事件/ 过程/ 实例/ 开始/ 执行/ ,/ 该/ 指令/ 就是/ 给定/ 中断/ 的/ 一个/ 处理/ 区间/ 的/ 起点/ ./ 我们/ 开发/ 了/ 算法/ 1/ 来/ 识别/ 此/ 区间/ 的/ 终点/ ./ 算法/ 1/ ./ 区间/ 终点/ 的/ 识别/ ./ 全局变量/ :/ 堆栈/ instS/ ,/ 存放/ 所有/ 活动/ 实例/ 的/ 实例/ 信息/ ;/ 队列/ instQ/ ,/ 存放/ 所有/ 待/ 执行/ 任务/ 的/ 实例/ 信息/ 输入/ :/ 一个/ 区间/ 的/ 起点/ 所/ 对应/ 的/ 指令/ i/ 输出/ :/ 此/ 区间/ 的/ 终点/ 所/ 对应/ 的/ 指令/ j1/ ./ found/ =/ false/ ;/ // // 尚未/ 找到/ 此/ 区间/ 的/ 终点/ 2/ ./ inst/ =/ 创建/ i/ 的/ 实例/ 信息/ ;/ 3/ ./ curInst/ =/ inst/ ;/ // // 设置/ 当前/ 实例/ 4/ ./ DO/ {/ 5/ ./ j/ =/ 取得/ 下/ 一条/ 待/ 执行/ 的/ 指令/ ;/ 6/ ./ 执行/ j/ ;/ 7/ ./ SWITCH/ (/ j/ )/ {/ 8/ ./ 开始/ 执行/ 一个/ 中断/ 处理/ 模块/ :/ 9/ ./ instS/ ./ push/ (/ curInst/ )/ ;/ // // 保存/ 中断/ 前/ 的/ 实例/ 10/ ./ curInst/ =/ 创建/ j/ 的/ 实例/ 信息/ // // 重置/ 当前/ 实例/ 11/ ./ 成功/ 地/ 提交/ 一个/ 任务/ :/ 12/ ./ curInst/ 入/ 队列/ instQ/ // // 保存/ 此/ 任务/ 的/ 实例/ 13/ ./ 开始/ 执行/ 一个/ 任务/ :/ 14/ ./ curInst/ =/ instQ/ 首/ 元素/ 出/ 队列/ ;/ 15/ ./ 结束/ 执行/ 一个/ 中断/ 处理/ 模块/ :/ 16/ ./ IF/ (/ (/ curInst/ =/ =/ inst/ )/ &&/ (/ inst/ 不/ 在/ instQ/ 中/ )/ )/ 17/ ./ found/ =/ true/ ;/ // // 找到/ 此/ 区间/ 的/ 终点/ 18/ ./ curInst/ =/ instS/ ./ pop/ (/ )/ ;/ // // 恢复/ 中断/ 前/ 的/ 实例/ 19/ ./ 结束/ 执行/ 一个/ 任务/ :/ 20/ ./ IF/ (/ (/ curInst/ =/ =/ inst/ )/ &&/ (/ inst/ 不/ 在/ instQ/ 中/ )/ )/ 21/ ./ found/ =/ true/ ;/ // // 找到/ 此/ 区间/ 的/ 终点/ 22/ ./ Default/ :/ 23/ ./ }/ 24/ ./ IF/ (/ found/ )/ 25/ ./ RETURNj/ ;/ // // 返回/ 此/ 区间/ 的/ 终点/ 26/ ./ }/ WHILE/ (/ !/ found/ )/ ;/ 各种/ 中断/ 的/ 各个/ 事件处理/ 区间/ 复杂/ 地/ 交织/ 在/ 一起/ ./ 为了/ 识别/ 每个/ 中断/ 处理/ 区间/ ,/ 我们/ 需/ 分析/ 所有/ 中断/ 的/ 事件/ 过程/ 实例/ 的/ 切换/ 情况/ ./ 算法/ 1/ 跟踪/ 处理/ 4/ 种/ 实例/ 切换/ 点/ :/ 中断/ 处理/ 模块/ 的/ 入口/ 点/ (/ 第/ 8/ 行/ )/ 和/ 出口/ 点/ (/ 第/ 15/ 行/ )/ 、/ 任务/ 运行/ 函数/ 的/ 入口/ 点/ (/ 第/ 13/ 行/ )/ 和/ 出口/ 点/ (/ 第/ 19/ 行/ )/ ./ 其中/ ,/ 任务/ 运行/ 函数/ 的/ 一个/ 例子/ 是/ 图/ 2/ 所示/ 的/ BlinkToRadioC/ ./ uartSendTask/ ./ runTask/ (/ )/ ./ 为了/ 识别/ 各个/ 任务/ 提交/ 操作/ 是否/ 成功/ ,/ 我们/ 还/ 需/ 跟踪/ 系统/ postTask/ 函数/ 中/ 与/ 任务/ 提交/ 成功/ 相对/ 应/ 的/ 指令/ (/ 第/ 11/ 行/ )/ ;/ 此/ 指令/ 在/ 系统/ postTask/ 函数/ 中/ 的/ 偏移/ 地址/ 是/ 个/ 常数/ ./ 算法/ 1/ 使用/ 全局/ 堆栈/ instS/ 保存/ 当前/ 正在/ 运行/ 的/ 各个/ 事件/ 过程/ 实例/ 的/ 信息/ ./ 当/ 一个/ 中断/ 抢占/ 发生/ 时/ ,/ 一个/ 中断/ 处理/ 模块/ 开始/ 执行/ ,/ 该/ 中断/ 的/ 实例/ 开始运行/ ,/ 因此/ 算法/ 1/ 创建/ 此/ 实例/ 的/ 信息/ (/ 包括/ 实例/ 编号/ )/ ,/ 并/ 放入/ 堆栈/ instS/ (/ 8/ ~/ 10/ 行/ )/ ./ 当此/ 中断/ 处理/ 模块/ 结束/ 运行/ 时/ ,/ 程序/ 的/ 执行/ 将/ 转回/ 被/ 抢占/ 的/ 实例/ 中/ ,/ 因此/ 算法/ 1/ 从/ instS/ 中/ 恢复/ 中断/ 前/ 的/ 实例/ 信息/ (/ 第/ 18/ 行/ )/ ./ 为了/ 在/ 任意/ 一个/ 任务/ 开始运行/ 时/ 识别/ 它/ 是/ 哪个/ 实例/ 的/ 任务/ ,/ 算法/ 1/ 使用/ 一个/ 全局/ 队列/ instQ/ 来/ 保存/ 程序/ 在/ 运行/ 时/ 的/ 所有/ 待/ 执行/ 任务/ 的/ 实例/ 信息/ :/ 每当/ 有/ 任务/ 被/ 系统/ 成功/ 提交/ 时/ ,/ 算法/ 1/ 就/ 把/ 当前/ 的/ 实例/ 信息/ (/ 即此/ 任务/ 的/ 实例/ 信息/ )/ 入队/ (/ 第/ 12/ 行/ )/ ;/ 而/ 每当/ 一个/ 任务/ 开始运行/ 时/ ,/ 就/ 将/ 实例/ 信息/ 队列/ 的/ 首/ 元素/ 出队/ ,/ 此/ 元素/ 就是/ 开始运行/ 的/ 这个/ 任务/ 的/ 实例/ 信/ Page8/ 息/ (/ 第/ 14/ 行/ )/ ./ 可见/ 在/ 被/ 分析/ 程序运行/ 的/ 任一/ 时刻/ ,/ 如果/ 某个/ 实例/ 有/ n/ 个/ “/ 被/ 成功/ 提交/ 且/ 尚未/ 执行/ ”/ 的/ 任务/ (/ 即/ “/ 待/ 执行/ 的/ 任务/ ”/ )/ ,/ 那么/ 在/ instQ/ 队列/ 中/ 就/ 有/ n/ 个/ 元素/ 的/ 值/ 是/ 此/ 实例/ 的/ 信息/ ./ 因此/ 在/ 任一/ 时刻/ ,/ 如果/ 某个/ 实例/ 的/ 信息/ 不/ 存在/ 于/ instQ/ 中/ ,/ 那么/ 这个/ 实例/ 必然/ 无/ “/ 待/ 执行/ 的/ 任务/ ”/ ./ 从/ 4.1/ 节/ 所述/ 可知/ ,/ 在/ 一个/ 实例/ 的/ EH/ 出口/ 执行/ 点/ ,/ 或者/ 此/ 实例/ 的/ 一个/ 任务/ 的/ 出口/ 执行/ 点/ ,/ 若此/ 实例/ 无/ 待/ 执行/ 的/ 任务/ ,/ 则/ 这个/ 出口/ 执行/ 点/ 就是/ 此/ 实例/ 的/ 终点/ ./ 在/ 算法/ 1/ 中/ ,/ 当/ j/ 为/ 一个/ 中断/ 处理/ 模块/ 的/ 出口/ 点/ (/ 第/ 15/ 行/ )/ 或者/ 任务/ 运行/ 函数/ 的/ 出口/ 点/ (/ 第/ 19/ 行/ )/ 时/ :/ 如果/ 当前/ 实例/ 的/ 信息/ 就是/ 指令/ i/ 的/ 实例/ 信息/ inst/ (/ 第/ 16/ 和/ 20/ 行/ )/ ,/ 那么/ j/ 的/ 实例/ 就是/ i/ 的/ 实例/ ;/ 而/ 如果/ 此时/ inst/ 不/ 存在/ 于/ instQ/ 队列/ 中/ (/ 第/ 16/ 和/ 20/ 行/ )/ ,/ 那么/ 如/ 前/ 一段/ 所述/ ,/ i/ 的/ 实例/ 必然/ 无/ “/ 待/ 执行/ 的/ 任务/ ”/ ./ 综上/ 可知/ ,/ 此时/ 的/ j/ 就是/ i/ 的/ 实例/ 终点/ (/ 即/ 区间/ 终点/ )/ ,/ 因此/ 算法/ 1/ 在/ 此时/ 找到/ 了/ 所/ 要/ 的/ 区间/ 终点/ (/ 第/ 17/ 和/ 21/ 行/ )/ ./ 可见/ ,/ 算法/ 1/ 能/ 在/ 实例/ 终点/ 指令/ 执行/ 时/ ,/ 实时/ 地/ 将/ 其/ 识别/ 为/ 实例/ 终点/ ./ 算法/ 1/ 不仅/ 可/ 识别/ 给定/ 中断/ 事件/ 的/ 区间/ ,/ 也/ 可/ 用于/ 识别/ 给定/ 应用/ 级/ 事件/ 的/ 区间/ ./ 当/ 我们/ 使用/ 算法/ 1/ 来/ 识别/ 给定/ 应用/ 级/ 事件/ 的/ 区间/ 时/ ,/ 我们/ 需要/ 把/ 给定/ 的/ 应用/ 级/ 事件/ 看作/ 是/ 一个/ “/ 虚拟/ 的/ 中断/ 事件/ ”/ :/ (/ 1/ )/ 在/ 调用/ 算法/ 1/ 之前/ 的/ 静态/ 扫描/ 阶段/ ,/ 将/ 此/ 应用/ 级/ 事件处理/ 模块/ 的/ 入口/ 地址/ 与/ 一个/ 自设/ 的/ 虚/ 中断/ 号/ (/ 如/ 999/ )/ 相关联/ ;/ (/ 2/ )/ 在/ 调用/ 算法/ 1/ 来/ 识别/ “/ 此/ 应用/ 级/ 事件/ ”/ 的/ 区间/ 时/ ,/ 将/ 给定/ 的/ 事件/ 设/ 为/ “/ 中断/ 号/ 为/ 999/ 的/ 中断/ 事件/ ”/ ./ 4.3/ 本文/ 基于/ 区间/ 的/ 测试方法/ 当/ 使用/ 现有/ 的/ 方法/ 时/ ,/ 测试者/ 通过/ 中断/ 号/ 指定/ 一个/ 中断/ 事件/ 类型/ ;/ 而/ 使用/ 本文/ 方法/ 时/ ,/ 测试者/ 通过/ 应用/ 级/ 事件/ 名/ 指定/ 一个/ 应用/ 级/ 事件/ 类型/ ./ 和/ 现有/ 的/ 基于/ 区间/ 的/ 测试方法/ 相比/ ,/ 本文/ 方法/ 在/ 以下/ 3/ 个/ 方面/ 采取/ 了/ 新/ 的/ 策略/ :/ 区间/ 的/ 划分/ 、/ 程序/ 行为/ 的/ 选择/ 和/ 函数/ 执行/ 信息/ 的/ 记录/ ./ 新/ 的/ 区间/ 划分/ 策略/ 用于/ 减少/ 那些/ 不/ 涉及/ 应用/ 级/ 组件/ 执行/ 的/ 良性/ 偶然/ 行为/ ,/ 而/ 新/ 的/ 程序/ 行为/ 选择/ 策略/ 用于/ 排除/ 事件/ 类型/ 不同/ 的/ 事件/ 过程/ 之间/ 的/ 良性/ 交织/ ./ 这/ 两个/ 策略/ 旨在/ 解决/ 基于/ 区间/ 测试/ 的/ 误报/ 问题/ ./ 对于/ 测试者/ 所/ 指定/ 的/ 应用/ 级/ 事件/ 类型/ ,/ 第/ 1/ 个/ 策略/ 将/ 被/ 分析程序/ 的/ 运行/ 时间/ 划分/ 成/ 这些/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ ;/ 而/ 第/ 2/ 个/ 策略/ 仅/ 捕获/ 由/ 这些/ 应用/ 级/ 事件/ 所/ 触发/ 的/ 行为/ ,/ 即仅/ 捕获/ 这些/ 应用/ 级/ 事件/ 的/ 事件/ 过程/ 实例/ ,/ 而/ 忽略/ 其它/ 中断/ 事件/ 的/ 事件/ 过程/ 实例/ ./ 值得注意/ 的/ 是/ ,/ 和/ 现有/ 的/ 方法/ 相比/ ,/ 第/ 2/ 个/ 策略/ 并未/ 改变/ 所/ 分析/ 的/ 程序/ 行为/ 特征/ ,/ 即/ 所/ 分析/ 的/ 仍/ 为/ 指令/ 的/ 执行/ 计数/ ./ TinyOS/ 应用程序/ 在/ 应用/ 级/ 提交/ 一个/ 任务/ 后/ ,/ 未必/ 会/ 检查/ 此次/ 的/ 任务/ 提交/ 是否/ 成功/ ;/ 而/ 测试者/ 往往/ 会/ 关注/ 任务/ 提交/ 操作/ 成功/ 与否/ ./ 因此/ ,/ 我们/ 通过/ 第/ 3/ 个/ 策略/ 为/ 测试者/ 提供/ 每/ 一个/ 任务/ 提交/ 操作/ 的/ 结果/ ,/ 旨在/ 帮助/ 测试者/ 更/ 有效/ 地/ 进行/ 人工/ 检查/ ./ 为了/ 判断/ “/ 一条/ 指令/ 的/ 执行/ ”/ (/ 即/ 一个/ 程序/ 行为/ )/ 是否/ 应该/ 被/ 捕获/ ,/ 我们/ 只/ 需/ 判断/ 此/ 指令/ 的/ 事件/ 过程/ 实例/ 所/ 对应/ 的/ 事件/ 是否/ 为/ 给定/ 的/ 事件/ ./ 因为/ 程序/ 行为/ 捕获/ 的/ 过程/ 交织/ 在/ 区间/ 识别/ 的/ 过程/ 中/ ,/ 所以/ 我们/ 通过/ 修改/ 算法/ 1/ 来/ 实现/ 上述/ 的/ 判断/ ./ 图/ 4/ 直观/ 地/ 描述/ 了/ 我们/ 对/ 算法/ 1/ 的/ 修改/ ,/ 其中/ 灰底/ 的/ 部分/ 表示/ 原/ 算法/ 1/ 的/ 内容/ ,/ 其它/ 部分/ 表示/ 修改/ 后/ 用于/ 捕获/ 程序/ 行为/ 的/ 内容/ ,/ 具体/ 的/ 修改/ 如下/ :/ (/ 1/ )/ 将/ 算法/ 1/ 中/ 保存/ 实例/ 信息/ 的/ 数据结构/ 设为/ INST/ 〈/ instNum/ ,/ ofE/ 〉/ ,/ 其中/ instNum/ 表示/ 实例/ 编号/ ,/ 而/ ofE/ 表示/ 这个/ 实例/ “/ 是否/ 为/ 给定/ 事件/ 的/ 实例/ ”/ ./ (/ 2/ )/ 在/ 算法/ 1/ 的/ 第/ 2/ 行/ 创建/ 给定/ 事件/ 的/ 实例/ 信息/ 时/ 、/ 将/ ofE/ 字段/ 设为/ TRUE/ ;/ 同时/ 可/ 判定/ :/ “/ 指令/ i/ 的/ 执行/ 应当/ 被/ 捕获/ ”/ ./ (/ 3/ )/ 在/ 第/ 10/ 行/ 创建/ 某个/ 事件/ 的/ 实例/ 信息/ 时/ ,/ 根据/ “/ 此/ 事件/ 的/ 中断/ 号/ 等于/ (/ 或/ 不/ 等于/ )/ 给定/ 事件/ 的/ 中断/ 号/ ”/ ,/ 将/ ofE/ 字段/ 的/ 值/ 设为/ TRUE/ (/ 或/ FALSE/ )/ ./ 对于/ 给定/ 的/ 应用/ 级/ 事件/ ,/ 给定/ 的/ 事件/ 中断/ 号/ 就是/ 4.2/ 节/ 所述/ 的/ 虚/ 中断/ 号/ ./ (/ 4/ )/ 在/ 第/ 23/ 和/ 24/ 行/ 之间/ ,/ 取得/ 指令/ j/ 的/ 实例/ curInst/ 的/ ofE/ 字/ 段值/ ;/ 如果/ 此字/ 段值/ 为/ TRUE/ ,/ 则/ 可/ 判定/ :/ “/ 指令/ j/ 的/ 执行/ 应当/ 被/ 捕获/ ”/ ./ 修改/ 后/ 的/ 算法/ 1/ ./ 区间/ 终点/ 的/ 识别/ +/ 程序/ 行为/ 的/ 捕获/ ./ 数据结构/ :/ INST/ 〈/ instNum/ ,/ ofE/ 〉/ :/ 用于/ 保存/ 实例/ 信息/ …/ 2/ ./ // // 创建/ i/ 的/ 实例/ 信息/ inst/ =/ 〈/ ++/ instNum/ ,/ TRUE/ 〉/ 捕获/ 指令/ i/ 的/ 执行/ 3/ ./ curInst/ =/ inst/ ;/ // // 设置/ 当前/ 实例/ …/ 10/ ./ // // 创建/ j/ 的/ 实例/ 信息/ ,/ 并/ 重置/ 当前/ 实例/ IF/ (/ 此/ 中断/ 处理/ 模块/ 的/ 中断/ 号/ =/ =/ 给定/ 事件/ 的/ 中断/ 号/ )/ 11/ ./ 成功/ 地/ 提交/ 一个/ 任务/ :/ …/ 23/ ./ }/ 捕获/ 指令/ j/ 的/ 执行/ 24/ ./ IF/ (/ found/ )/ …/ IF/ (/ curInst/ ./ ofE/ )/ Page9/ 对于/ 测试者/ 所/ 指定/ 的/ 应用/ 级/ 事件/ 类型/ ,/ 我们/ 的/ 测试方法/ 包括/ 以下/ 3/ 个/ 步骤/ :/ (/ 1/ )/ 以/ 这些/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ 为/ 单位/ ,/ 在线/ 收集/ 被测/ 程序/ 的/ 运行/ 时/ 数据/ ./ 它/ 具体/ 包括/ 以下/ 3/ 个子/ 过程/ :/ ①/ 识别/ 这些/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ ;/ 识别/ 所选/ 的/ 行为/ (/ 即/ 由/ 这些/ 应用/ 级/ 事件/ 所/ 触发/ 的/ 行为/ )/ ;/ 识别/ 与/ 函数/ 执行/ 相关/ 的/ 信息/ ,/ 其中/ 包括/ 任务/ 提交/ 操作/ 的/ 信息/ ./ ②/ 用/ 一个/ 变/ 长/ 向量/ 记录/ 发生/ 在/ 每个/ 区间/ 中/ 的/ 所选/ 程序/ 行为/ ./ 每个/ 向量/ 元素/ 表示/ 一条/ 指令/ 在/ 此/ 区间/ 中/ 的/ 执行/ 次数/ ,/ 每个/ 元素/ 包括/ 两/ 部分/ :/ 指令/ 的/ 地址/ 和/ 指令/ 的/ 执行/ 次数/ ./ 这些/ 向量/ 用于/ 离线/ 的/ 区间/ 排序/ ./ ③/ 用/ 一个/ 字符串/ 序列/ 记录/ 发生/ 在/ 一个/ 区间/ 中/ 的/ 与/ 函数/ 执行/ 有关/ 的/ 信息/ ./ 每个/ 字符串/ 表示/ 一个/ 函数调用/ ,/ 或者/ 表示/ 一个/ 任务/ 提交/ 操作/ 的/ 结果/ 为/ 成功/ (/ 或/ 失败/ )/ ./ 字符串/ 的/ 值/ 是/ 函数/ 名/ ,/ 或者/ 以/ “/ @/ PostOk/ ”/ (/ 或/ “/ @/ PostFail/ ”/ )/ 为/ 后缀/ 的/ 任务/ 名/ ./ (/ 2/ )/ 采用/ 现有/ 测试方法/ 的/ 离线/ 排序/ 技术/ ,/ 对/ 收集/ 到/ 的/ 区间/ 进行/ 排序/ ./ (/ 3/ )/ 从/ 高到/ 低/ ,/ 人工/ 检查/ 各个/ 区间/ 的/ 函数/ 执行/ 信息/ ,/ 直至/ 找到/ 瞬态/ 错误/ ./ 因为/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ 比/ 相应/ 的/ 中断/ 事件/ 的/ 处理/ 区间/ 短/ ,/ 所以/ 我们/ 的/ 方法/ 在/ 人工/ 检查/ 阶段/ 只/ 需/ 检查/ 更/ 短/ 的/ 函数/ 执行/ 信息/ ./ 5/ 实验/ 研究/ 5.1/ 研究/ 的/ 问题/ 为了/ 揭示/ 应用/ 级/ 组件/ 中/ 的/ 瞬态/ 错误/ ,/ 现有/ 的/ 测试方法/ 报告/ 包含/ 上述/ 错误/ 的/ 中断/ 处理/ 区间/ ;/ 而/ 我们/ 的/ 测试方法/ 采用/ 新/ 的/ 区间/ 划分/ 策略/ 和/ 程序/ 行为/ 选择/ 策略/ ,/ 报告/ 包含/ 上述/ 错误/ 的/ 应用/ 级/ 事件处理/ 区间/ ./ 针对/ 应用/ 级/ 组件/ 中/ 的/ 瞬态/ 错误/ ,/ 我们/ 围绕/ 下/ 5/ 个/ 问题/ 展开/ 实验/ 研究/ :/ RQ1/ :/ 现有/ 的/ 测试方法/ 在/ 报告/ 包含/ 错误/ 的/ 区间/ 时/ 是否/ 存在/ 误报/ 问题/ ?/ 现有/ 方法/ 中/ 的/ 区间/ 筛选/ 策略/ 对/ 测试/ 效果/ 有何/ 影响/ ?/ RQ2/ :/ 我们/ 的/ 测试方法/ 能否/ 有效/ 地/ 报告/ 包含/ 错误/ 的/ 区间/ ?/ 和/ 现有/ 的/ 方法/ 相比/ ,/ 我们/ 的/ 方法/ 是否/ 有/ 更/ 少/ 的/ 误报/ ?/ 的/ 可疑/ 区间/ 是否/ 具有/ 明显/ 更/ 短/ 的/ 长度/ ?/ RQ3/ :/ 和/ 现有/ 的/ 方法/ 相比/ ,/ 我们/ 的/ 方法/ 所/ 报告/ RQ4/ :/ 如果/ RQ2/ 的/ 答案/ 是/ 肯定/ 的/ ,/ 那么/ 我们/ 方/ RQ5/ :/ 在/ 实际/ 中/ ,/ 我们/ 测试方法/ 的/ “/ 在线/ 处理/ 过法/ 中/ 的/ 两个/ 策略/ 对于/ 降低/ 误报/ 有何/ 作用/ ?/ 程/ ”/ 在/ 时空/ 方面/ 的/ 开销/ 如何/ ?/ 在/ 上述/ 问题/ 中/ ,/ RQ2/ ~/ RQ4/ 研究/ 我们/ 测试方法/ 的/ 效果/ ,/ 而/ RQ5/ 研究/ 其/ 效率/ ./ 5.2/ 实验/ 设置/ 5.2/ ./ 1/ 原型/ 实现/ 与/ 运行/ 环境/ 我们/ 用/ Java/ 语言/ 开发/ 了/ 两个/ 原型/ 工具/ ,/ 分别/ 实现/ 我们/ 的/ 测试方法/ 和/ 现有/ 的/ 测试方法/ ./ 这/ 两个/ 工具/ 都/ 采用/ 相同/ 的/ 区间/ 识别/ 算法/ (/ 即/ 算法/ 1/ )/ ,/ 并/ 使用/ Sentomist/ 工具/ (/ 参见/ 第/ 2.1/ 节/ 脚注/ ②/ )/ 的/ 离线/ 分析/ 模块/ 对/ 区间/ 进行/ 排序/ ./ 上述/ 工具/ 运行/ 于/ 传感/ 网/ 的/ 指令/ 级/ 模拟器/ Avrora/ [/ 9/ ]/ 之上/ ,/ 它们/ 利用/ Avrora/ 所/ 提供/ 的/ 插装/ 机制/ 来/ 插装/ 被/ 测/ 程序/ 的/ 指令/ ;/ 当/ Avrora/ 解释/ 执行/ 被测/ 程序/ 时/ ,/ 被/ 插装/ 的/ 探针/ 也/ 随之/ 执行/ ./ 我们/ 在/ 实验/ 中/ 发现/ ,/ 传感/ 网/ 模拟器/ 的/ 版本/ 差异/ 会/ 对/ 工具/ 的/ 运行/ 结果/ 产生/ 一定/ 的/ 影响/ ./ 为了/ 在/ 对比/ 工具/ 的/ 运行/ 结果/ 时/ 减少/ 这种/ 影响/ ,/ 我们/ 所有/ 的/ 实验/ 都/ 运行/ 于/ 同一/ 版本/ 的/ 模拟器/ (/ 即/ Avrora1/ ./ 7.113/ ①/ )/ 之上/ ./ 实验/ 所用/ 的/ 模拟/ 平台/ 为/ Mica2/ 、/ 微控制器/ 为/ ATmega128/ ②/ ./ 实验/ 所用/ 的/ 传感/ 网/ 操作系统/ 为/ TinyOS2/ ./ 1/ ,/ 它/ 运行/ 于/ WindowsXP/ 和/ Cygwin/ ③/ 平台/ 上/ ./ 实验/ 所用/ 的/ 计算机/ 是/ 一台/ 具有/ 2.7/ GHzIntel/ 双核/ 处理器/ 和/ 1GB/ 内存/ 的/ 台式/ 计算机/ ./ 5.2/ ./ 2/ 被测/ 程序/ 与/ 运行/ 设置/ 我们/ 在/ 实验/ 中/ 所用/ 的/ 被/ 测/ 程序/ 如表/ 2/ 第/ 1/ 列/ 所示/ ,/ 它们/ 是/ 表/ 1/ 所示/ 的/ 3/ 种/ 典型/ 的/ TinyOS/ 应用程序/ 或/ 其/ 变体/ ./ 其中/ ,/ 被测/ 程序/ Sub1/ ~/ Sub3/ 分别/ 是/ 程序/ Osilloscope/ 的/ 3/ 个/ 变体/ ,/ Sub4/ 是/ 程序/ TestBlink/ 的/ 变体/ ,/ 而/ Sub5/ 即/ TestCTP/ 程序/ (/ 参见/ 第/ 2.1/ 节/ 脚注/ ①/ ②/ )/ ./ 被测/ 程序/ Sub1/ 源/ 节点/ Sub2/ 源/ 节点/ Sub3/ 包/ 覆盖/ Run51Avrora/ 的/ 缺省/ 设置/ 10Sub4/ 中继/ 节点/ Sub5/ 停止/ 数据/ ①/ ②/ ③/ Page10/ 被测/ 程序/ Sub1/ ~/ Sub5/ 的/ 应用/ 级/ 组件/ 中/ 包含/ 瞬态/ 错误/ ,/ 其/ 症状/ 如表/ 2/ 的/ 第/ 2/ 列/ 所示/ ./ 这些/ 错误/ 症状/ 在/ 传感/ 网/ 程序/ 中是/ 常见/ 的/ ,/ 并/ 曾/ 被/ TinyOS/ 社区/ ①/ 所/ 讨论/ 或/ 被/ 现有/ 的/ 实验/ 研究/ [/ 5/ ,/ 10/ ]/ 所/ 引用/ ./ 其中/ ,/ Sub1/ ~/ Sub2/ 中/ 的/ 错误/ 是/ 源/ 节点/ 的/ 丢/ 包/ 错误/ ,/ 原因/ 是/ 源/ 节点/ 在/ 发送/ 数据包/ 时/ 没有/ 缓冲/ 机制/ ,/ 当/ 采样/ 频率/ 较/ 高时/ 就/ 会/ 有/ 数据包/ 因/ 无法/ 及时/ 发出/ 而/ 丢失/ ;/ 错误/ 的/ 最大/ 显现/ 次数/ 在/ Sub1/ 中为/ 1/ 次/ 、/ 而/ 在/ Sub2/ 中为/ 3/ 次/ ./ Sub3/ 中/ 存在/ 一个/ 如下/ 的/ 包/ 覆盖/ 错误/ :/ 应用/ 级/ 组件/ 中/ 的/ 一个/ 异步/ 事件/ 将/ 传感/ 数据/ 封装/ 成包/ ,/ 并/ 提交/ 一个/ 任务/ 来/ 发送/ 此包/ ,/ 如果/ 在/ 此/ 任务/ 的/ “/ 成功/ 提交/ 点/ ”/ 与/ “/ 运行/ 调度/ 点/ ”/ 之间/ ,/ 又/ 有/ 一个/ 异步/ 事件/ 形成/ 新/ 的/ 数据包/ 并/ 提交/ 了/ 另/ 一个/ 任务/ 来/ 发送/ 此包/ ,/ 那么/ 新/ 数据包/ 会/ 完全/ 覆盖/ 上/ 一个/ 数据包/ 的/ 内容/ ,/ 而/ 新/ 的/ 任务/ 提交/ 操作/ 则/ 会/ 失败/ ./ Sub4/ 中/ 的/ 错误/ 是/ 中继/ 节点/ 的/ 丢/ 包/ 错误/ ,/ 原因/ 是/ 中继/ 节点/ 因忙/ 而/ 无法/ 转发/ 新/ 接收/ 的/ 数据包/ ;/ Sub4/ 的/ 错误/ 显现/ 次数/ 是/ 一个/ 变量/ ,/ 它/ 随/ 运行/ 时间/ 和源/ 节点/ 的/ 采样/ 周期/ 而/ 变化/ ./ Sub5/ 使用/ 汇聚/ 树/ 路由/ 协议/ CTP/ 传送/ 传感/ 读数/ ,/ 同时/ 使用/ 另/ 一个/ 协议/ 在/ 节点/ 间/ 传送/ 其它/ 数据/ ,/ 这/ 两个/ 协议/ 有/ 可能/ 争用/ 资源/ ;/ 由于/ CTP/ 未能/ 正确/ 地/ 处理/ 上述/ 竞争/ ,/ 而/ 造成/ 了/ 停止/ 发送数据/ 的/ 错误/ ./ 瞬态/ 错误/ 在/ 传感/ 网/ 程序运行/ 时/ 未必/ 会/ 显现出来/ ,/ 其/ 显现/ 与否/ 和/ 显现/ 次数/ 都/ 会/ 受/ 程序运行/ 设置/ (/ 包括/ 程序/ 的/ 运行/ 时间/ 和源/ 节点/ 的/ 采样/ 周期/ )/ 的/ 影响/ ./ 被测/ 程序/ Sub1/ ~/ Sub5/ 的/ 瞬态/ 错误/ 可以/ 通过/ 表/ 2/ 所示/ 的/ 测试运行/ 显现出来/ ./ 表/ 2/ 的/ 第/ 3/ 列/ 给出/ 了/ 这些/ 测试运行/ (/ Test/ -/ Run/ )/ 的/ 编号/ ./ 第/ 4/ 列/ 报告/ 了/ 瞬态/ 错误/ 在/ 各个/ 测试运行/ 中/ 的/ 显现/ 次数/ ,/ 并/ 记为/ #/ BM/ (/ 即/ NumberofBugManifestation/ )/ ./ 第/ 5/ 、/ 6/ 列/ 分别/ 给出/ 了/ 每个/ 测试运行/ 中源/ 节点/ 的/ 采样/ 周期/ (/ 以/ ms/ 为/ 单位/ )/ 和/ 在/ Avrora/ 上/ 模拟/ 运行/ 的/ 时间/ (/ 以/ s/ 为/ 单位/ )/ ./ 例如/ 在/ Run1/ 中/ ,/ Sub1/ 被/ 执行/ 了/ 5/ 次/ ,/ 每次/ 的/ 执行/ 时间/ 都/ 是/ 10s/ ,/ 而/ 5/ 次/ 的/ 源/ 节点/ 采样/ 周期/ 分别/ 为/ 20ms/ ,/ 40ms/ ,/ 60ms/ ,/ 80ms/ 和/ 100ms/ ./ TestCTP/ 由/ 节点/ 2/ 、/ 4/ 、/ 6/ 、/ 8/ 采样/ 传感/ 数据/ ,/ 其中/ 节点/ 8/ 的/ 采样/ 周期/ 为/ 400ms/ ,/ 而/ 其余/ 节点/ 的/ 采样/ 周期/ 为/ 550ms/ ./ 被测/ 程序/ Sub1/ ~/ Sub4/ 和/ 现有/ 实验/ 研究/ 的/ 被/ 测/ 程序/ 都/ 是/ 源于/ 程序/ Osilloscope/ 和/ TestBlink/ ,/ 但是/ Sub1/ ~/ Sub4/ 具有/ 以下/ 特点/ :/ (/ 1/ )/ 程序/ 的/ 运行/ 设置/ 对应/ 更/ 多种/ 情况/ 的/ 运行/ 场景/ ,/ 即/ 不仅/ 包含/ 采用/ 多个/ 采样/ 周期/ 的/ 情况/ (/ 如/ Run1/ 、/ Run3/ 、/ Run7/ 和/ Run8/ )/ ,/ 而且/ 包含/ 采用/ 单个/ 采样/ 周期/ 的/ 情况/ (/ 如/ Run2/ )/ ;/ (/ 2/ )/ 程序/ 的/ 瞬态/ 错误/ 不仅/ 包括/ 单次/ 显现/ 的/ 错误/ (/ 如/ Run1/ ~/ Run2/ ,/ Run5/ ~/ Run7/ )/ ,/ 而且/ 包括/ 多次/ 显现/ 的/ 错误/ (/ 如/ Run3/ ~/ Run4/ ,/ Run8/ ~/ Run9/ )/ ;/ (/ 3/ )/ 程序/ 中/ 的/ 应用/ 级/ 事件/ 不仅/ 包括/ 同步/ 事件/ ,/ 而且/ 包括/ 异步/ 事件/ (/ 即/ Run5/ ~/ Run6/ )/ ./ 我们/ 在/ 运行/ 基于/ 中断/ 区间/ 的/ 测试工具/ 时/ ,/ 所/ 指定/ 的/ 中断/ 类型/ 为表/ 1/ 第/ 3/ 列/ 所示/ 的/ 中断/ ,/ 即/ ADC/ 中断/ (/ 用于/ Sub1/ ~/ Sub3/ )/ 、/ SPI/ 中断/ (/ 用于/ Sub4/ )/ 和/ 定时器/ 中断/ (/ 用于/ Sub5/ )/ ./ 而/ 我们/ 在/ 运行/ 基于/ 应用/ 级/ 事件/ 区间/ 的/ 测试工具/ 时/ ,/ 所/ 指定/ 的/ 应用/ 级/ 事件/ 类型/ 为/ AdcMessageC/ ./ Read/ ./ readDone/ (/ 用于/ Sub1/ ~/ Sub2/ )/ 、/ AdcMessageC/ ./ mySensor/ ./ dataReady/ (/ 用于/ Sub3/ )/ 、/ BlinkToRadioC/ ./ Receive/ ./ receive/ (/ 用于/ Sub4/ )/ 以及/ CtpForwardingEngineP/ ./ 0/ ./ RetxmitTimer/ ./ fired/ (/ 用于/ Sub5/ )/ ./ 5.3/ 效果/ 的/ 研究/ 5.3/ ./ 1/ 现有/ 方法/ 的/ 区间/ 排序/ 效果/ 本/ 节/ 研究/ 问题/ RQ1/ ./ 现有/ 的/ 测试方法/ 在/ 对/ 区间/ 进行/ 排序/ 之前/ ,/ 可以/ 使用/ “/ 区间/ 筛选/ 策略/ ”/ ,/ 即/ 筛选/ 出/ 包含/ 指定/ 字符串/ 的/ 区间/ ,/ 然后/ 仅/ 对/ 这些/ 区间/ 进行/ 排序/ (/ 参见/ 第/ 2.1/ 节/ 脚注/ ②/ )/ ./ 如/ 5.2/ ./ 1/ 节/ 所述/ ,/ 我们/ 实现/ 了/ 现有/ 测试方法/ 的/ 原型/ 工具/ ,/ 该/ 工具/ 使用/ Sentomist/ 工具/ 的/ 离线/ 分析/ 模块/ 对/ 区间/ 进行/ 排序/ ./ 为了/ 使用/ 区间/ 筛选/ 策略/ ,/ 我们/ 在/ 区间/ 排序/ 之前/ 启用/ Sentomist/ 工具/ 的/ “/ 区间/ 筛选/ 功能/ ”/ ,/ 并/ 指定/ 筛选/ 用/ 的/ 字符串/ 为/ 5.2/ ./ 2/ 节/ 最后/ 一段/ 所示/ 的/ 应用/ 级/ 事件/ 名/ (/ 即/ 我们/ 的/ 测试方法/ 所用/ 的/ 应用/ 级/ 事件/ 类型/ 的/ 名字/ )/ ./ 我们/ 分别/ 在/ “/ 不/ 使用/ ”/ 和/ “/ 使用/ ”/ 区间/ 筛选/ 策略/ 的/ 情况/ 下/ ,/ 将/ 现有/ 测试方法/ 的/ 原型/ 工具/ 应用/ 于表/ 2/ 所示/ 的/ 各个/ 测试运行/ 上/ ,/ 并/ 检查/ 工具/ 对/ 错误/ 区间/ (/ 即/ 实际上/ 包含/ 瞬态/ 错误/ 的/ 区间/ )/ 的/ 排序/ ,/ 其/ 结果/ 如表/ 3/ 所示/ ./ 其中/ ,/ 第/ 1/ 列是/ 表/ 2/ 所示/ 的/ 测试运行/ 的/ 编号/ ./ 第/ 2/ 列/ 给出/ 了/ 每个/ 测试运行/ 中/ 的/ 错误/ 区间/ 总数/ #/ BI/ (/ 即/ NumberofBuggyIntervals/ )/ ./ 因为/ 在/ 这些/ 测试运行/ 中/ ,/ 每个/ 错误/ 区间/ 只/ 包含/ 一个/ 错误/ ,/ 所以/ 每个/ 测试运行/ 的/ 错误/ 区间/ 总数/ #/ BI/ 和/ 它/ 的/ 错误/ 显现/ 次数/ #/ BM/ (/ 如表/ 2/ 的/ 第/ 4/ 列/ 所示/ )/ 相等/ ./ 第/ 3/ 列/ 表示/ 测试者/ 运用/ 现有/ 的/ 测试方法/ 时/ ,/ 所/ 指定/ 的/ 中断/ 类型/ ./ 第/ 4/ 和/ 5/ 列/ 分别/ 报告/ 在/ “/ 不/ 使用/ ”/ 和/ “/ 使用/ ”/ 区间/ 筛选/ 策略/ 的/ 情况/ 下/ ,/ 运用/ 现有/ 的/ 测试方法/ 时/ 所得/ 的/ 错误/ 区间/ 的/ 排序/ 号/ ./ ①/ http/ :/ // // www/ ./ tinyos/ ./ net/ // community/ ./ html2012/ ,/ 5/ ,/ 1Page11/ 运行/ 编号/ #/ BI/ 中断/ Run11ADC839Run21ADC626Run33ADC909/ ,/ 950/ ,/ 97821/ ,/ 23/ ,/ 711/ ,/ 2/ ,/ 3Run43ADC926/ ,/ 931/ ,/ 93613/ ,/ 20/ ,/ 281/ ,/ 2/ ,/ 3Run51ADC1Run61ADC1Run71SPI206Run83SPI167/ ,/ 168/ ,/ 1692/ ,/ 3/ ,/ 41/ ,/ 2/ ,/ 3Run93SPI107/ ,/ 108/ ,/ 1092/ ,/ 3/ ,/ 81/ ,/ 2/ ,/ 3Run101Timer0Run111Timer0/ 从/ 第/ 4/ 列可/ 看出/ ,/ 在/ 不/ 使用/ 区间/ 筛选/ 策略/ 时/ ,/ 对于/ 大部分/ 的/ 测试运行/ ,/ 现有/ 的/ 测试方法/ 不能/ 将/ 错误/ 区间/ 排/ 在/ 前列/ 、/ 产生/ 了/ 大量/ 的/ 误报/ :/ 它/ 将/ 9/ 个/ 测试运行/ (/ 即/ Run1/ ~/ Run4/ 和/ Run7/ ~/ Run11/ )/ 的/ 错误/ 区间/ 在/ 第/ 100/ 位/ 之后/ ./ 可见/ ,/ 其/ 区间/ 排序/ 效果/ 有/ 很大/ 的/ 改进/ 空间/ ./ 而/ 第/ 5/ 列/ 表明/ ,/ 在/ 使用/ 区间/ 筛选/ 策略/ 之后/ ,/ 现有/ 测试方法/ 的/ 误报/ 问题/ 明显/ 得以/ 缓解/ ;/ 但是/ 误报/ 问题/ 仍然/ 存在/ :/ 大部分/ 测试运行/ (/ 即/ Run1/ ~/ Run4/ 和/ Run8/ ~/ Run11/ )/ 的/ 排序/ 结果/ 仍/ 有待/ 提高/ ,/ 其中/ 有些/ 排序/ 结果/ (/ 如/ Run3/ ~/ Run4/ 和/ Run10/ ~/ Run11/ )/ 高于/ 20/ ./ 比如/ 对于/ Run11/ ,/ 测试者/ 需/ 手工/ 检查/ 22/ 个/ 可疑/ 区间/ 才能/ 找到/ 错误/ 区间/ ./ 上述/ 的/ 实验/ 结果表明/ :/ 在/ 使用/ 现有/ 的/ 测试方法/ 检测/ 应用/ 级/ 组件/ 中/ 的/ 瞬态/ 错误/ 时/ ,/ 使用/ 区间/ 筛选/ 策略/ 能/ 明显/ 地/ 改善/ 测试/ 效果/ ./ 另一方面/ ,/ 在/ 使用/ 此/ 策略/ 之后/ ,/ 现有/ 方法/ 的/ 测试/ 效果/ 仍/ 有/ 改进/ 的/ 空间/ ,/ 即/ 仍然/ 存在/ 误报/ 问题/ ./ 5.3/ ./ 2/ 本文/ 方法/ 的/ 区间/ 排序/ 效果/ 本/ 节/ 研究/ 问题/ RQ2/ ./ 如前所述/ ,/ 我们/ 开发/ 了/ 一个/ 原型/ 工具/ 实现/ 我们/ 的/ 测试方法/ ./ 在/ 本节/ 我们/ 将/ 此/ 工具/ 应用/ 于表/ 2/ 所示/ 的/ 各个/ 测试运行/ 上/ ,/ 得到/ 的/ 错误/ 区间/ 排序/ 结果/ 如表/ 3/ 的/ 最后/ 一列/ 所示/ ./ 从此/ 列可/ 看出/ ,/ 对于/ 所有/ 的/ 测试运行/ ,/ 我们/ 的/ 测试方法/ 都/ 能够/ 有效/ 地/ 将/ 错误/ 区间/ 排在/ 前/ 几位/ :/ 它/ 将/ Run10/ 的/ 错误/ 区间/ 排在/ 第/ 5/ 位/ ,/ 而/ 将/ 其余/ 11/ 个/ 测试运行/ 的/ 错误/ 区间/ 都/ 排/ 在/ 第/ 1/ 位/ ./ 这/ 意味着/ ,/ 通过/ 使用/ 我们/ 的/ 方法/ ,/ 测试者/ 只/ 需/ 手工/ 检查/ 1/ 个/ 或者/ 5/ 个/ 可疑/ 区间/ 就/ 能/ 发现错误/ 区间/ ./ 我们/ 在/ 对比/ 了/ Run10/ 和/ 其它/ 测试运行/ 之后/ 发现/ :/ Run10/ 和/ Run11/ 从/ 多个/ 节点/ 、/ 而/ 其它/ 的/ 测试/ 从/ 单个/ 节点/ 收集/ 区间/ ,/ 且/ Run10/ 所/ 收集/ 的/ 区间/ 数/ (/ 190/ )/ 远/ 少于/ Run11/ 所/ 收集/ 的/ 区间/ 数/ (/ 502/ )/ ./ 这个/ 结果/ 说明/ 当/ 从/ 多个/ 节点/ 收集/ 区间/ 数据/ 时/ ,/ 所/ 收集/ 的/ 区间/ 数/ 可能/ 会/ 影响/ 排序/ 的/ 效果/ ./ 通过/ 对比/ 表/ 3/ 的/ 最后/ 两列/ ,/ 我们/ 可以/ 看出/ :/ 本文/ 测试方法/ 能/ 将/ Run10/ 的/ 错误/ 区间/ 排序/ 从/ 第/ 20/ 位/ 提高/ 到/ 第/ 5/ 位/ ,/ 而/ 将/ 其余/ 10/ 个/ 测试运行/ 中待/ 改进/ 的/ 排序/ 结果/ 都/ 提升/ 到/ 最佳/ ,/ 即/ 第/ 1/ 位/ ./ 上述/ 的/ 实验/ 结果表明/ :/ 本文/ 测试方法/ 能够/ 有效/ 地/ 报告/ 包含/ 瞬态/ 错误/ 的/ 区间/ ./ 和/ 使用/ 区间/ 筛选/ 策略/ 的/ 现有/ 方法/ 相比/ ,/ 本文/ 方法/ 能/ 有效/ 地/ 降低/ 误报/ ,/ 甚至/ 消除/ 误报/ ./ 5.3/ ./ 3/ 本文/ 方法/ 的/ 区间/ 长度/ 效果/ 本/ 节/ 研究/ 问题/ RQ3/ ./ 本文/ 方法/ 使用/ “/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ ”/ (/ 记作/ EInterval/ )/ ,/ 而/ 现有/ 的/ 方法/ 使用/ “/ 中断/ 的/ 处理/ 区间/ ”/ (/ 记作/ IInterval/ )/ ./ 一个/ 应用/ 级/ 事件/ 的/ EInterval/ 是/ “/ 触发/ 该/ 事件/ 的/ 那个/ 中断/ ”/ 的/ IInterval/ 的/ 子/ 区间/ ./ 如/ 5.3/ ./ 1/ 节/ 所述/ ,/ 在/ 使用/ 区间/ 筛选/ 策略/ 之后/ ,/ 现有/ 测试方法/ 所/ 排序/ 的/ 区间/ 都/ 是/ “/ 包含/ 应用/ 级/ 事件处理/ ”/ 的/ IInterval/ ./ 我们/ 通过/ 实验/ 比较/ 这/ 两种/ 区间/ 的/ 实际/ 长度/ ./ 对于/ 每/ 一个/ 测试运行/ Runi/ (/ 1/ / i/ / 11/ )/ ,/ 表/ 4/ 比较/ 我们/ 的/ 方法/ 和/ 现有/ 的/ 方法/ 所/ 生成/ 的/ 区间/ 长度/ ,/ 这些/ 长度/ 包括/ :/ 最大/ 长度/ 、/ 最小/ 长度/ 和/ 平均/ 长度/ ./ 其中/ ,/ 一个/ 区间/ 的/ 长度/ 是/ 指该/ 区间/ 所/ 包含/ 的/ 字符串/ 的/ 个数/ :/ 在/ 现有/ 的/ 方法/ 中/ ,/ 一个/ 区间/ 的/ 字符串/ 序列/ 由/ “/ 在/ 该/ 区间/ 被/ 调用/ 的/ 函数/ ”/ 的/ 函数/ 名/ 组成/ ;/ 而/ 在/ 我们/ 的/ 方法/ 中/ ,/ 此/ 序列/ 除/ 包括/ 上述/ 的/ 函数/ 名/ 之外/ ,/ 还/ 包括/ “/ 在/ 该/ 区间/ 被/ 提交/ 的/ 任务/ ”/ 的/ 提交/ 操作/ 结果/ (/ 详见/ 4.3/ 节/ 我们/ 方法/ 的/ 步骤/ (/ 1/ )/ 之子/ 过程/ ③/ )/ ./ 表/ 4/ 的/ 最后/ 一列/ 表示/ 用/ 我们/ 的/ 方法/ 替代/ 现有/ 的/ 方法/ 后/ ,/ 区间/ 的/ 平均/ 长度/ 的/ 下降/ 率/ ./ 运行/ 编号/ Run14665713130856253Run24665713030856252Run34615713231856253Run44615713231856253Run51501592171446512542Run61501592061446512241Run75412123161725315651Run84542123111575315450Run94542123111575315351Run105801493183863620336Run115911493143893619737/ 表/ 4/ 表明/ ,/ 本文/ 方法/ 所/ 报告/ 的/ 可疑/ 区间/ 具有/ 明显/ 更/ 短/ 的/ 长度/ ,/ 比如/ 平均/ 长度/ 的/ 下降/ 率/ 在/ 36/ %/ 和/ 53/ %/ 之间/ ./ 这/ 说明/ 我们/ 的/ 方法/ 能/ 明显/ 地/ 减轻/ 测试者/ 在/ 人工/ 检查/ 单个/ 区间/ 时/ 的/ 负担/ ./ 另外/ 由表/ 4/ 可知/ ,/ 在/ Page12/ 两种/ 方法/ 中/ ,/ 区间/ 的/ 平均/ 长度/ 一般/ 都/ 大于/ 100/ ,/ 而/ 最大/ 长度/ 甚至/ 会/ 大于/ 1000/ ./ 因此/ ,/ 测试者/ 必须/ 手工/ 检查/ 多于/ 100/ (/ 甚至/ 1000/ )/ 个/ 表示/ 执行/ 信息/ 的/ 字符串/ 、/ 才/ 有/ 可能/ 判断/ 一个/ 区间/ 是否/ 包含/ 错误/ ./ 这/ 说明/ ,/ 无论/ 采用/ 哪/ 种/ 方法/ ,/ 当/ 需要/ 检查/ 较/ 多/ 的/ 区间/ 时/ ,/ 人工/ 检查/ 都/ 将/ 变得/ 非常/ 费力/ 、/ 难以完成/ ./ 上述/ 的/ 实验/ 结果表明/ :/ 和/ 使用/ 区间/ 筛选/ 策略/ 的/ 现有/ 方法/ 相比/ ,/ 我们/ 的/ 方法/ 所/ 报告/ 的/ 可疑/ 区间/ 具有/ 明显/ 更/ 短/ 的/ 长度/ ./ 这/ 意味着/ ,/ 我们/ 的/ 方法/ 能/ 显著/ 地/ 减轻/ 测试者/ 在/ 人工/ 检查/ 单个/ 区间/ 时/ 的/ 负担/ ./ 5.3/ ./ 4/ 本文/ 方法/ 中/ 的/ 两种/ 策略/ 的/ 作用/ 接下来/ ,/ 我们/ 研究/ 问题/ RQ4/ ./ 本节/ 通过/ 实验/ ,/ 比较/ 我们/ 方法/ 中/ 的/ 两种/ 策略/ (/ 即/ 新/ 的/ 区间/ 划分/ 策略/ 和/ 程序/ 行为/ 选择/ 策略/ )/ 对/ 解决/ 误报/ 问题/ 的/ 各自/ 贡献/ ./ 我们/ 测试方法/ 的/ 原型/ 工具/ 同时/ 实现/ 了/ 这/ 两种/ 策略/ ./ 通过/ 对此/ 工具/ 进行/ 修改/ ,/ 分别/ 得到/ 了/ 另外/ 两个/ 新/ 工具/ ,/ 它们/ 分别/ 只/ 实现/ 上述/ 的/ 策略/ 之一/ ./ 其中/ ,/ “/ 只/ 使用/ 新/ 的/ 程序/ 行为/ 选择/ 策略/ ”/ 的/ 工具/ 仍然/ 沿用/ 给定/ 中断/ 事件/ 的/ IInterval/ 区间/ ,/ 但是/ 仅/ 捕获/ 由/ 给定/ 中断/ 事件/ 所/ 触发/ 的/ 程序/ 行为/ ;/ “/ 只/ 使用/ 新/ 的/ 区间/ 划分/ 策略/ ”/ 的/ 工具/ 仍然/ 不/ 加/ 选择地/ 捕获/ 任意/ 事件/ 所/ 触发/ 的/ 程序/ 行为/ ,/ 但是/ 使用/ 应用/ 级/ 事件/ 的/ EInterval/ 区间/ ./ 我们/ 将/ 这/ 两个/ 新/ 工具/ 分别/ 应用/ 于/ 前述/ 的/ 11/ 个/ 测试运行/ 中/ ,/ 所得/ 的/ 结果/ 如表/ 5/ 的/ 第/ 2/ 和/ 3/ 列/ 所示/ ./ 为作/ 对比/ ,/ 最后/ 一列/ 给出/ 使用/ 本文/ 方法/ 时/ 所得/ 的/ 结果/ ./ 表/ 5/ 分别/ 使用/ 本文/ 两种/ 策略/ 时/ 的/ 区间/ 排序/ 结果/ 运行/ 编号/ Run1827Run2624Run3907/ ,/ 908/ ,/ 9097/ ,/ 10/ ,/ 111/ ,/ 2/ ,/ 3Run4926/ ,/ 927/ ,/ 9284/ ,/ 7/ ,/ 8Run51Run61Run7204Run8167/ ,/ 168/ ,/ 1691/ ,/ 2/ ,/ 3Run9107/ ,/ 108/ ,/ 1091/ ,/ 2/ ,/ 3Run10345Run11611/ 比较/ 表/ 3/ 的/ 第/ 4/ 列和表/ 5/ 的/ 第/ 2/ 列可/ 看出/ :/ 通过/ 单独/ 使用/ 我们/ 的/ 程序/ 行为/ 选择/ 策略/ ,/ 错误/ 区间/ 的/ 排序/ 有所/ 提升/ ;/ 但是/ 对于/ 大部分/ 的/ 测试运行/ (/ 即/ Run1/ ~/ Run4/ 和/ Run7/ ~/ Run11/ )/ ,/ 错误/ 区间/ 的/ 排序/ 仍/ 超过/ 100/ ,/ 即/ 仍/ 存在/ 大量/ 的/ 误报/ ./ 从表/ 5/ 的/ 第/ 3/ 列可/ 看出/ :/ 通过/ 单独/ 使用/ 我们/ 的/ 区间/ 划分/ 策略/ ,/ 针对/ 3/ 个/ 测试运行/ (/ 即/ Run7/ ~/ Run9/ )/ 的/ 排序/ 结果/ 都/ 达到/ 了/ 最佳/ ;/ 而/ 针对/ 另外/ 6/ 个/ 测试运行/ (/ 即/ Run1/ ~/ Run4/ 和/ Run10/ ~/ Run11/ )/ 的/ 排序/ 结果/ 都/ “/ 小于/ 20/ ”/ ./ 可见/ ,/ 通过/ 单独/ 地/ 使用/ 我们/ 的/ 区间/ 划分/ 策略/ ,/ 可以/ 有效/ 地/ 减少/ 误报/ ./ 而/ 通过/ 比较/ 表/ 5/ 的/ 最后/ 两列/ 可知/ :/ 如果/ 不/ 使用/ 程序/ 行为/ 选择/ 策略/ ,/ 那么/ 对于/ Run1/ ~/ Run4/ 和/ Run10/ ~/ Run11/ ,/ 其/ 错误/ 区间/ 的/ 排序/ 结果/ 无法/ 进一步提高/ ./ 因此/ ,/ 我们/ 的/ 程序/ 行为/ 选择/ 策略/ 对/ 降低/ 误报/ 也/ 有/ 重要/ 的/ 贡献/ ./ 以上/ 的/ 实验/ 结果表明/ :/ 本文/ 测试方法/ 的/ 有效性/ 同时/ 得益于/ 两种/ 策略/ ./ 接下来/ ,/ 本文/ 将/ 举例/ 分析/ :/ 这/ 两种/ 策略/ 是/ 如何/ 减少/ 误报/ 的/ ?/ 以/ Run11/ 为例/ ,/ 模拟器/ 所/ 配置/ 的/ 传感/ 网/ 包含/ 9/ 个/ 节点/ ,/ 每个/ 节点/ 都/ 运行/ 被测/ 程序/ Sub5/ :/ 节点/ 0/ 是/ 目标/ 节点/ ,/ 节点/ 2/ 、/ 4/ 、/ 6/ 和/ 8/ 每隔/ 一段时间/ 通过/ CTP/ 协议/ 传送/ 传感/ 读数/ ,/ 节点/ 1/ 、/ 3/ 、/ 5/ 、/ 7/ 和/ 8/ 每隔/ 一段时间/ 通过/ 一个/ 消息/ 交换/ 协议/ HeartBeat/ 向/ 邻居/ 节点/ 发送/ 心跳/ 消息/ ./ 这/ 两个/ 协议/ 都/ 使用/ ActiveMessageC/ 组件/ 的/ AMSend/ 接口/ 发送/ 消息/ 包到/ 主动/ 消息/ 层/ ,/ 因此/ 它们/ 共用/ radio/ ./ CTP/ 的/ CtpForwardingEngineP/ 组件/ 在/ 实现/ 发送/ 任务/ 时/ ,/ 只/ 考虑/ 了/ 使用/ 本/ 协议/ 的/ 各个/ clients/ 之间/ 争用/ radio/ 的/ 情况/ ,/ 并未/ 考虑/ 本/ 协议/ 的/ client/ 与/ 其它/ 协议/ 争用/ radio/ 的/ 情形/ ①/ :/ 如图/ 5/ 的/ 第/ 13/ ~/ 20/ 行/ 所示/ ,/ 该/ 组件/ 的/ 发送/ 任务/ sendTask/ 在/ 调用/ SubSend/ ./ send/ (/ )/ 时/ ,/ 对/ 返回值/ 为/ FAIL/ 或/ EBUSY/ 的/ 情形/ 未/ 做/ 任何/ 处理/ ./ 在/ Run11/ 的/ 节点/ 8/ 上/ 就/ 出现/ 了/ 这种/ 情形/ :/ CTP/ 协议/ 触发/ RetxmitTimer/ ./ fired/ 事件/ (/ 图/ 5/ 第/ 7/ 行/ )/ ,/ 并/ 沿着/ 执行/ 路径/ 7/ -/ 8/ -/ 10/ -/ 12/ -/ 13/ (/ 图/ 5CtpForwardingEngineP/ ./ nc/ :/ 1/ :/ genericmoduleCtpForwardingEngineP/ (/ )/ {/ 2/ :/ usesinterfaceAMSendasSubSend/ ;/ 3/ :/ usesinterfaceTimer/ 〈/ TMilli/ 〉/ asRetxmitTimer/ ;/ 4/ :/ …/ }/ 5/ :/ implementation/ {/ 6/ :/ …/ 7/ :/ eventvoidRetxmitTimer/ ./ fired/ (/ )/ {/ …/ 8/ :/ postsendTask/ (/ )/ ;/ }/ 9/ :/ 10/ :/ taskvoidsendTask/ (/ )/ {/ 11/ :/ …/ 12/ :/ error/ _/ tsubsendResult/ ;/ 13/ :/ subsendResult/ =/ // // 错误/ :/ 以下/ 代码/ 未/ 处理/ 返回值/ 为/ FAIL/ 和/ EBUSY/ 时/ 的/ 情况/ 14/ :/ if/ (/ subsendResult/ =/ =/ SUCCESS/ )/ {/ …/ 15/ :/ return/ ;/ }/ 16/ :/ elseif/ (/ subsendResult/ =/ =/ EBUSY/ )/ {/ // / donothing/ / // }/ 17/ :/ elseif/ (/ subsendResult/ =/ =/ EOFF/ )/ {/ 18/ :/ radioOn/ =/ FALSE/ ;/ }/ 19/ :/ elseif/ (/ subsendResult/ =/ =/ ESIZE/ )/ {/ …/ 20/ :/ postsendTask/ (/ )/ ;/ }/ }/ 21/ :/ …/ }/ }/ ①/ Thecollectiontreeprotocol/ (/ CTP/ )/ [/ EB/ // OL/ ]/ ./ http/ :/ // // Page13/ 中/ 的/ 行号/ )/ 调用函数/ SubSend/ ./ send/ (/ )/ ;/ SubSend/ ./ send/ (/ )/ 试图/ 发送数据/ ,/ 而/ 此时/ AM/ 层正/ 忙于/ 传送/ HeartBeat/ 协议/ 的/ 数据/ ,/ 因此/ SubSend/ ./ send/ (/ )/ 函数/ 的/ 返回值/ 为/ FAIL/ ./ 此后/ ,/ 节点/ 8/ 因/ 上述/ 的/ FAIL/ 状态/ 未/ 被/ 处理/ 而/ 无穷/ 等待/ 相应/ 的/ SubSend/ ./ sendDone/ 信号/ ,/ CTP/ 数据/ 传送/ 中止/ ./ 在/ Run11/ 中/ ,/ 节点/ 2/ 、/ 4/ 和/ 6/ 上/ 都/ 未/ 出现/ CTP/ 中止/ 传送/ 的/ 错误/ ./ 测试工具/ 从/ 节点/ 2/ 、/ 4/ 、/ 6/ 和/ 8/ 收集/ 程序/ 的/ 运行/ 信息/ ./ 在/ Run11/ 中/ ,/ 现有/ 方法/ 所/ 收集/ 的/ 是/ Timer0/ 中断/ 处理/ 区间/ 中/ 所/ 发生/ 的/ 全部/ 程序/ 行为/ ./ 当/ 现有/ 方法/ 不/ 使用/ 区间/ 筛选/ 策略/ 时/ ,/ 错误/ 区间/ 被/ 排/ 在/ 第/ 755/ 位/ (/ 表/ 3/ 第/ 4/ 列/ )/ ./ 在/ 这/ 754/ 个/ 误报/ 的/ 中断/ 处理/ 区间/ 中/ ,/ 有/ 3/ 种/ 类型/ 的/ 程序/ 行为/ 并/ 不/ 属于/ CtpForwarding/ -/ EngineP/ ./ 0/ ./ RetxmitTimer/ ./ fired/ 事件/ 的/ 处理过程/ :/ (/ 1/ )/ 发生/ 在/ 不/ 调用/ 此/ 事件/ 函数/ 的/ 中断/ 处理/ 区间/ 中/ 的/ 行为/ ./ 例如/ 排序/ 为/ 第/ 1/ 的/ 区间/ 中/ 的/ 行为/ ,/ 其中/ 的/ 部分/ 执行/ 序列/ 如图/ 6/ (/ 1/ )/ 所示/ ./ 这些/ 行为/ 收集/ 自/ 节点/ 2/ ,/ 节点/ 2/ 通过/ Timer0/ 中断/ ,/ 触发/ 对/ CTP/ 的/ 路由/ 更新/ ,/ 并/ 在/ 路由/ 重建/ 之后/ 直接/ 提交/ 一个/ sendTask/ (/ )/ 任务/ 来/ 发送数据/ ;/ 在/ 此/ 过程/ 中/ 并未/ 调用函数/ CtpFor/ -/ wardingEngineP/ ./ 0/ ./ RetxmitTimer/ ./ fired/ (/ )/ ./ 在/ 节点/ 2/ 上/ 未/ 出现/ CTP/ 发送/ 中止/ 的/ 错误/ ,/ 因此/ 该/ 区间/ 是/ 误报/ ./ (/ 2/ )/ 发生/ 在/ 调用函数/ CtpForwardingEngineP/ ./ 0/ ./ RetxmitTimer/ ./ fired/ (/ )/ 的/ 中断/ 处理/ 区间/ 之中/ 、/ 且/ 发生/ 在/ 此/ 函数/ 开始/ 执行/ 之前/ 的/ 行为/ ./ 例如/ 在/ 排序/ 为/ 第/ 6/ 的/ 区间/ 中/ 的/ 行为/ ,/ 其中/ 的/ 部分/ 执行/ 序列/ 如图/ 6/ (/ 2/ )/ 所示/ ./ VitualizeTimerC/ 定时器/ 先后/ 触发/ 以下/ 两个/ 事件处理/ 函数/ 的/ 执行/ :/ 函数/ BlinkToRadioC/ ./ TimerSense/ ./ fired/ (/ )/ 和/ 函数/ CtpForwardingEngineP/ ./ 0/ ./ Retxmit/ -/ Timer/ ./ fired/ (/ )/ ;/ 而/ 在/ 前/ 一个/ 函数/ 的/ 执行/ 中/ 并/ 不/ 处理/ RetxmitTimer/ ./ fired/ 事件/ ./ 此/ 区间/ 收集/ 自/ 节点/ 6/ ,/ 而/ 在/ 节点/ 6/ 上/ 并未/ 出现/ CTP/ 错误/ ,/ 因此/ 该/ 区间/ 是/ 误报/ ./ (/ 3/ )/ 其它/ 中断/ 的/ 处理/ 行为/ ./ 这些/ 行为/ 不是/ Timer0/ 中断/ 的/ 处理/ 行为/ ,/ 因此/ 也/ 不会/ 属于/ RetxmitTimer/ ./ fired/ 事件/ 的/ 处理过程/ ./ 由于/ 中断/ 发生/ 的/ 随机性/ ,/ 这种/ 行为/ 可能/ 随机/ 交织/ 进/ Timer0/ 中断/ 处理/ 区间/ 的/ 任何/ 非/ 原子/ 的/ 执行/ 段/ ./ 图/ 6/ 所示/ 的/ 每个/ 示例/ 区间/ 中/ 都/ 包含/ 有/ SPI/ 中断/ 的/ 处理/ 行为/ ./ 我们/ 的/ 目标/ 是/ 发现/ CtpForwardingEngineP/ ./ 0/ ./ RetxmitTimer/ ./ fired/ 事件/ 处理过程/ 中/ 的/ 偶然/ 行为/ ./ 当/ 我们/ 使用/ 现有/ 的/ 方法/ ,/ 从/ 包含/ 有/ 上述/ 3/ 类/ 行为/ 的/ 程序执行/ 中/ 寻找/ 目标/ 偶然/ 行为/ 时/ ,/ 会/ 受到/ 这/ 3/ 类/ 行为/ 的/ 干扰/ ./ 对于/ Run11/ ,/ 当/ 现有/ 的/ 方法/ 使用/ “/ 区间/ 筛选/ 策略/ ”/ ,/ 并/ 将/ 过滤/ 用/ 的/ 字符串/ 指定/ 为/ CtpForwardingEngineP/ ./ 0/ ./ RetxmitTimer/ ./ fired/ 时/ ,/ 可以/ 消除/ 待/ 排序/ 区间/ 中/ 的/ (/ 1/ )/ 类/ 行为/ ,/ 但是/ 仍然/ 不能/ 消除/ (/ 2/ )/ 和/ (/ 3/ )/ 类/ 行为/ 的/ 干扰/ ./ 其/ 结果/ 是/ Run11/ 的/ 错误/ 区间/ 排序/ 为/ 22/ (/ 如表/ 3/ 第/ 5/ 列/ 所示/ )/ ,/ 即/ 仍然/ 存在/ 21/ 个/ 误报/ 区间/ ./ (/ 1/ )/ 包含/ 1/ 类/ 行为/ 的/ 执行/ 序列/ :/ (/ 2/ )/ 包含/ 2/ 类/ 行为/ 的/ 执行/ 序列/ :/ 〈/ TIMER0/ 中断/ 发生/ 〉/ AlarmToTimerC/ ./ 0/ ./ Alarm/ ./ firedVirtualizeTimerC/ ./ 0/ ./ Timer/ ./ firedCtpRoutingEngineP/ ./ 0/ ./ BeaconTimer/ ./ firedCtpRoutingEngineP/ ./ 0/ ./ updateRouteTask/ ./ postTaskCtpRoutingEngineP/ ./ 0/ ./ sendBeaconTask/ ./ postTaskCtpRoutingEngineP/ ./ 0/ ./ updateRouteTask/ ./ runTask/ 〈/ SPI/ 中断/ 处理/ 〉/ CtpRoutingEngineP/ ./ 0/ ./ Routing/ ./ routeFoundCtpForwardingEngineP/ ./ 0/ ./ UnicastNameFreeRouting/ ./ routeFoundCtpForwardingEngineP/ ./ 0/ ./ sendTask/ ./ postTaskCtpRoutingEngineP/ ./ 0/ ./ sendBeaconTask/ ./ runTask/ 〈/ SPI/ 中断/ 处理/ 〉/ 〈/ SPI/ 中断/ 处理/ 〉/ CtpForwardingEngineP/ ./ 0/ ./ sendTask/ ./ runTaskCtpForwardingEngineP/ ./ 0/ ./ SendQueue/ ./ empty/ …/ 〈/ TIMER0/ 中断/ 发生/ 〉/ AlarmToTimerC/ ./ 0/ ./ Alarm/ ./ fired/ 〈/ SPI/ 中断/ 处理/ 〉/ VirtualizeTimerC/ ./ 0/ ./ Timer/ ./ fired/ (/ )/ BlinkToRadioC/ ./ TimerSense/ ./ fired/ (/ )/ BlinkToRadioCSendsendCtpForwardingEngineP0SendsendCtpForwardingEngineP0SendQueueenqueueCtpForwardingEngineP0RetxmitTimerisRunningVirtualizeTimerC/ ./ 0/ ./ updateFromTimer/ ./ postTask/ (/ )/ VirtualizeTimerC/ ./ 0/ ./ updateFromTimer/ ./ runTask/ (/ )/ VirtualizeTimerC/ ./ 0/ ./ Timer/ ./ fired/ (/ )/ CtpForwardingEngineP/ ./ 0/ ./ RetxmitTimer/ ./ fired/ (/ )/ CtpForwardingEngineP/ ./ 0/ ./ sendTask/ ./ postTask/ (/ )/ CtpForwardingEngineP/ ./ 0/ ./ sendTask/ ./ runTask/ (/ )/ 〈/ SPI/ 中断/ 处理/ 〉/ CtpForwardingEngineP/ ./ 0/ ./ SubSend/ ./ send/ (/ )/ 〈/ 返回值/ 为/ SUCCESS/ 〉/ 〈/ SPI/ 中断/ 处理/ 〉/ …/ 〈/ TIMER0/ 中断/ 发生/ 〉/ AlarmToTimerC/ ./ 0/ ./ Alarm/ ./ firedVirtualizeTimerC/ ./ 0/ ./ Timer/ ./ firedCtpForwardingEngineP/ ./ 0/ ./ RetxmitTimer/ ./ firedCtpForwardingEngineP/ ./ 0/ ./ sendTask/ ./ postTaskCtpForwardingEngineP/ ./ 0/ ./ sendTask/ ./ runTask/ 〈/ SPI/ 中断/ 处理/ 〉/ CtpForwardingEngineP/ ./ 0/ ./ SubSend/ ./ send/ 〈/ 返回值/ 为/ FAIL/ 〉/ …/ (/ 3/ )/ 包含/ 错误行为/ 的/ 执行/ 序列/ :/ 对于/ Run11/ ,/ 我们/ 在/ 使用/ 新/ 的/ 区间/ 划分/ 策略/ 之后/ ,/ 就/ 从/ 被/ 分析/ 区间/ 中/ 同时/ 消除/ 了/ 上述/ 的/ (/ 1/ )/ 和/ (/ 2/ )/ 类/ 行为/ ,/ 从而/ 将/ 错误/ 区间/ 的/ 排序/ 提高/ 到/ 第/ 19/ 位/ (/ 表/ 5/ 第/ 3/ 列/ )/ ./ 然而/ ,/ 在/ 这些/ 被/ 分析/ 的/ 区间/ 中/ 仍然/ 存在/ (/ 3/ )/ 类/ 行为/ ./ 图/ 6/ (/ 3/ )/ 示例/ 了/ 包含/ 错误/ 的/ 中断/ 区间/ 的/ 执行/ 序列/ ,/ 其中/ 黑体/ 部分/ 的/ 执行/ 序列/ 也/ 出现/ 在/ “/ 使用/ 新/ 的/ 区间/ 划分/ 策略/ 后/ 所得/ 的/ 错误/ 区间/ ”/ 之中/ ./ 这个/ Page14/ 错误/ 区间/ 是/ 应用/ 级/ 事件/ 的/ 处理/ 区间/ ,/ 并/ 不/ 包含/ (/ 1/ )/ 和/ (/ 2/ )/ 类/ 行为/ ./ 然而/ 如图/ 6/ (/ 3/ )/ 所示/ ,/ 在/ 此/ 错误/ 区间/ 中/ 交织/ 了/ SPI/ 中断/ 的/ 处理/ 行为/ ,/ 即/ 包含/ (/ 3/ )/ 类/ 行为/ ./ 此外/ ,/ 在/ 其余/ 大部分/ 的/ 正确/ 区间/ 中/ 也/ 交织/ 了/ SPI/ 中断/ 或/ ADC/ 中断/ 的/ 处理/ 行为/ ./ 总之/ ,/ 在/ 这些/ 被/ 分析/ 的/ 应用/ 级/ 事件/ 区间/ 中/ 仍然/ 存在/ (/ 3/ )/ 类/ 行为/ ./ 我们/ 通过/ 使用/ 新/ 的/ 程序/ 行为/ 选择/ 策略/ ,/ 进一步/ 消除/ 了/ 这些/ (/ 3/ )/ 类/ 行为/ 的/ 干扰/ ,/ 从而/ 将/ Run11/ 的/ 排序/ 结果/ 提高/ 到/ 第/ 1/ 位/ (/ 如表/ 5/ 最后/ 一列/ 所示/ )/ ./ 在/ 分析/ 应用/ 级/ 事件/ 的/ 处理/ 行为/ 时/ ,/ 被/ 分析/ 区间/ 中/ 的/ 上述/ 3/ 类/ 行为/ 可/ 视为/ 噪声/ ./ 这些/ 噪声/ 行为/ 的/ 数量/ 越/ 多/ ,/ 它们/ 干扰/ 区间/ 排序/ 结果/ 的/ 可能性/ 就/ 越/ 高/ ,/ 因此/ 通过/ 消除/ 它们/ 来/ 减少/ 误报/ 的/ 可能性/ 也/ 就/ 越/ 高/ ./ 而/ 我们/ 的/ 实验/ 结果表明/ ,/ (/ 1/ )/ 和/ (/ 2/ )/ 类/ 行为/ 在/ 中断/ 区间/ 的/ 全部/ 行为/ 中所/ 占/ 的/ 比率/ 很/ 高/ :/ 其/ 比率/ 分别/ 等于/ (/ 采用/ 我们/ 的/ 区间/ 划分/ 策略/ 之后/ )/ 待/ 排序/ 区间/ 的/ 个数/ 减少/ 率/ 和/ 长度/ 减少/ 率/ ,/ 分别/ 如表/ 6/ 的/ 最后/ 一列/ 和表/ 4/ 的/ 最后/ 一列/ 所示/ ./ 从/ 这/ 两列/ 可/ 看出/ :/ 对于/ 除/ Run5/ ~/ Run6/ 之外/ 的/ 9/ 个/ 测试运行/ ,/ (/ 1/ )/ 类/ 行为/ 的/ 比率/ 为/ 27/ %/ ~/ 99.6/ %/ ;/ 而/ 对于/ 11/ 个/ 测试运行/ ,/ (/ 2/ )/ 类/ 行为/ 的/ 比率/ 为/ 36/ %/ ~/ 53/ %/ ./ Run5/ ~/ Run6/ 中/ 不/ 存在/ (/ 1/ )/ 类/ 行为/ ,/ 这/ 是因为/ 所/ 指定/ 的/ 应用/ 级/ 事件/ 为/ 异步/ 事件/ ;/ 而/ 在/ TinyOS/ 的/ 应用程序/ 中/ ,/ 大部分/ 的/ 应用/ 级/ 事件/ 都/ 是/ 同步/ 事件/ ./ 此外/ ,/ 因为/ 在/ 被/ 测/ 程序运行/ 时/ ,/ 各种/ 中断/ 会/ 随机/ 产生/ ,/ 所以/ 第/ (/ 3/ )/ 类/ 行为/ 会/ 随机/ 地/ 出现/ 在/ 被/ 分析/ 的/ 区间/ 中/ ./ 运行/ 编号/ Run11497Run21203Run31639Run41800Run5Run6133Run727742Run827826Run921182Run10705Run111590/ 综上所述/ ,/ 本文/ 测试方法/ 的/ 有效性/ 同时/ 得益于/ 新/ 的/ 区间/ 划分/ 策略/ 和/ 新/ 的/ 程序/ 行为/ 选择/ 策略/ ./ 这/ 两种/ 策略/ 降低/ 误报/ 的/ 原因/ 是/ :/ 排除/ 了/ 待/ 排序/ 区间/ 中/ 的/ 3/ 种/ 程序/ 行为/ 的/ 干扰/ ,/ 而/ 这些/ 程序/ 行为/ 并/ 不/ 属于/ 指定/ 应用/ 级/ 事件/ 的/ 处理过程/ ./ 5.4/ 效率/ 的/ 研究/ 5.4/ ./ 1/ 实验/ 设置/ 在/ 本节/ ,/ 我们/ 研究/ RQ5/ ./ 如前所述/ ,/ 我们/ 基于/ 算法/ 1/ 实现/ 了/ 新/ 测试方法/ 的/ 工具/ ,/ 简记/ 作/ “/ Ours/ 工具/ ”/ ./ 我们/ 研究/ Ours/ 工具/ 的/ 在线/ 处理/ 效率/ ,/ 并/ 和/ Sentomist/ 工具/ 进行/ 比较/ ./ 每种/ 工具/ 的/ 在线/ 处理过程/ 包括/ 识别/ 区间/ 和/ 收集/ 区间/ 中/ 的/ 程序执行/ 信息/ ,/ 而/ 其/ 离线/ 处理过程/ 对/ 收集/ 到/ 的/ 信息/ 进行/ 离线/ 的/ 分析/ ./ 对于/ 每种/ 工具/ ,/ 我们/ 只/ 评估/ 其/ 在线/ 处理过程/ 的/ 时空/ 开销/ ,/ 而/ 不/ 启动/ 其/ 离线/ 处理/ 功能/ ./ 我们/ 仍/ 使用/ 前述/ 的/ Sub1/ ~/ Sub5/ 作为/ 被测/ 程序/ ,/ 监测/ 它们/ 在/ 单个/ 节点/ 上/ 的/ 运行/ 开销/ ,/ 这些/ 开销/ 可能/ 随/ 运行/ 时间/ 的/ 增加/ 而/ 递增/ ./ 表/ 7/ 的/ 第/ 2/ 列/ 报告/ 了/ 被/ 测/ 程序/ 的/ 9/ 组/ 测试运行/ 的/ 设置/ ./ 每个/ 测试运行/ 组/ Ri/ (/ 1/ / i/ / 9/ )/ 由/ 4/ 次/ 测试运行/ 组成/ ,/ 每次/ 运行/ 分别/ 对应/ 以下/ 4/ 个/ 运行/ 时/ 长/ :/ 10s/ 、/ 50s/ 、/ 100s/ 和/ 150s/ ./ 因此/ ,/ 第/ 2/ 列共/ 包括/ 9/ ×/ 4/ =/ 36/ 个/ 测试运行/ ./ 源/ 节点/ 的/ 采样/ 周期/ 也/ 可能/ 影响/ 某个/ 节点/ 的/ 运行/ 开销/ ./ 表/ 7/ 的/ 第/ 3/ 栏/ 列出/ 了/ 每个/ 测试运行/ 组中/ 、/ 源/ 节点/ 的/ 采样/ 周期/ ./ 对于/ 每/ 一个/ 采样/ 周期/ 可变/ 的/ 被/ 测/ 程序/ (/ 即/ Sub1/ ~/ Sub2/ 和/ Sub4/ )/ ,/ 我们/ 分别/ 使用/ 两个/ 不同/ 的/ 采样/ 周期/ (/ 其中/ 一个/ 较长/ ,/ 另/ 一个/ 较/ 短/ )/ 来/ 运行/ 被测/ 程序/ ./ Sub3/ 的/ 采样/ 周期/ 由/ Avrora/ 的/ 默认值/ 确定/ ./ 第/ 4/ 栏/ 列出/ 了/ 每个/ 运行/ 组/ 的/ 被/ 监测/ 节点/ ./ 表/ 7/ 用于/ 效率/ 评估/ 的/ 被/ 测/ 程序/ 及其/ 运行/ 设置/ 被测/ 程序运行/ 组号/ 采样/ 周期/ // ms/ 被/ 监测/ 的/ 节点/ Sub1R1Sub2R3Sub3R5Avrora/ 的/ 缺省值/ 源/ 节点/ Sub4R6Sub5R8/ 由/ TestCTP/ 设置/ 正常/ 的/ 节点/ 我们/ 将/ 每个/ 工具/ 分别/ 应用/ 于表/ 7/ 所列/ 的/ 每次/ 测试运行/ ,/ 并/ 测量/ 工具/ 的/ 在线/ 处理/ 部分/ 的/ 运行/ 时/ 开销/ ./ 为了/ 计算/ 每个/ 工具/ 用于/ 在线/ 处理/ 的/ 空间/ 开销/ ,/ 我们/ 用/ 工具/ 运行/ 时所/ 消耗/ 的/ 内存/ 量/ 减去/ 模拟器/ 运行/ 时所/ 消耗/ 的/ 内存/ 量/ ;/ 为了/ 计算/ 每个/ 工具/ 用于/ 在线/ 处理/ 的/ 时间/ 开销/ ,/ 我们/ 以/ 减速/ 因子/ (/ slowdownfactor/ )/ 为/ 单位/ ,/ 测量/ 因/ 工具/ 的/ 在线/ 处理/ 而/ 造成/ 的/ 程序运行/ 减速/ 情况/ ./ 减速/ 因子/ 等于/ 工具/ 的/ 在线/ 处理过程/ 的/ 执行/ 时间/ 与/ 被/ 分析程序/ 的/ 运行/ 时间/ 之/ 比率/ ./ Page155/ ./ 4.2/ 实验/ 结果/ 与/ 分析/ 图/ 7/ 和/ 图/ 8/ 对比/ 显示/ 了/ 两种/ 工具/ 用于/ 在线/ 处理过程/ 的/ 开销/ ./ 浅/ 灰色/ 柱体/ 表示/ Ours/ 工具/ 的/ 开销/ ,/ 而/ 黑图/ 7/ 用/ 两种/ 方法/ 进行/ 在线/ 处理/ 的/ 空间/ 开销/ 图/ 8/ 用/ 两种/ 方法/ 进行/ 在线/ 处理/ 的/ 时间/ 开销/ 在/ 图/ 7/ 中/ ,/ 柱体/ 代表/ 在线/ 处理/ 的/ 空间/ 开销/ ,/ 其/ 柱体/ 高度/ 表示/ 以/ MB/ 为/ 单位/ 的/ 内存/ 使用量/ ./ 从图/ 中/ 可以/ 看出/ :/ 两种/ 工具/ 的/ 空间/ 开销/ 都/ 会/ 随/ 模拟/ 时间/ 的/ 延长/ 而/ 增加/ ./ 从/ 单个/ 测试运行/ 来看/ ,/ Ours/ 的/ 空间/ 开销/ 低于/ 或/ 等于/ Sentomist/ 的/ 空间/ 开销/ ./ 从/ 所有/ 的/ 测试运行/ 来看/ ,/ Ours/ 的/ 最大/ 开销/ 低于/ 70MB/ ./ 与此相反/ ,/ 当/ 运行/ 时间/ 达/ 150s/ 时/ ,/ Sentomist/ 的/ 最小/ 开销/ 都/ 超过/ 120MB/ ;/ 而/ 当/ 运行/ 时间/ 不少/ 于/ 50s/ 时/ ,/ Sentomist/ 应用/ 在/ R2/ 和/ R4/ 上/ 的/ 开销/ 甚至/ 超过/ 220MB/ ./ 以上/ 结果表明/ :/ 我们/ 工具/ 的/ 在线/ 处理过程/ 具有/ 更/ 低/ 的/ 空间/ 开销/ ;/ 而且/ 两种/ 工具/ 的/ 开销/ 差别/ 随/ 运行/ 时间/ 的/ 延长/ 而/ 愈加/ 明显/ ./ 图/ 8/ 显示/ 了/ 减速/ 情况/ 的/ 实验/ 结果/ ./ 为了/ 分析/ 时间/ 开销/ 随/ 运行/ 时间/ 变化/ 的/ 平均/ 趋势/ ,/ 我们/ 以/ 具有/ 相同/ 运行/ 时间/ 的/ 测试运行/ 组为/ 单位/ ,/ 计算/ 每组/ 中/ 9/ 个/ 测试运行/ 的/ 平均/ 时间/ 开销/ ./ 每个/ 测试运行/ 的/ 减速/ 因子/ 和/ 每组/ 的/ 平均/ 减速/ 因子/ 分别/ 用/ 柱体/ 和/ 虚线/ 表示/ ,/ 柱体/ 或/ 虚线/ 的/ 高度/ 代表/ 减速/ 因子/ 的/ 值/ ./ 从图/ 中/ 可/ 看色/ 柱体/ 代表/ Sentomist/ 工具/ 的/ 开销/ ./ 每/ 一个/ 测试运行/ 占据/ 水平/ 轴/ 的/ 一个/ 位置/ ,/ 而/ 36/ 个/ 测试运行/ 按照/ 其/ 模拟/ 运行/ 的/ 时长/ (/ 即/ 10s/ ,/ 50s/ ,/ 100s/ 和/ 150s/ )/ 被/ 分为/ 4/ 组/ ./ 出/ :/ 两种/ 工具/ 的/ 时间/ 开销/ 都/ 会/ 随/ 运行/ 时间/ 的/ 延长/ 而/ 增加/ ,/ 但是/ 从/ 每个/ 测试运行/ 来看/ ,/ Ours/ 都/ 比/ Sentomist/ 的/ 时间/ 开销/ 低/ ./ 对/ 所有/ 的/ 测试运行/ 而言/ ,/ Ours/ 的/ 减速/ 情况/ 都/ 是/ 相近/ 的/ ,/ 即/ 无论/ 运行/ 时间/ 有/ 多长/ ,/ 每组/ 测试运行/ 的/ 平均/ 减速/ 因子/ 都/ 是/ 1.1/ 倍/ ;/ 相比之下/ ,/ Sentomist/ 的/ 减速/ 趋势/ 随/ 运行/ 时间/ 延长/ 而/ 愈加/ 明显/ ,/ 在/ 运行/ 时间/ 为/ 10s/ 、/ 50s/ 、/ 100s/ 和/ 150s/ 时/ 的/ 减速/ 因子/ 分别/ 为/ 1.7/ 倍/ 、/ 4.7/ 倍/ 、/ 8.5/ 倍/ 和/ 11.4/ 倍/ ./ 例如/ ,/ 当/ 被/ 测/ 程序/ 的/ 运行/ 时间/ 为/ 150s/ (/ 即/ 大约/ 2.5/ min/ )/ 时/ ,/ Ours/ 的/ 在线/ 处理过程/ 只/ 需要/ 165s/ (/ 即/ 大约/ 3min/ )/ 、/ 而/ Sentomist/ 的/ 在线/ 处理过程/ 则/ 需要/ 1710s/ (/ 即/ 大约/ 30min/ )/ ./ 总之/ ,/ 以上/ 的/ 实验/ 结果表明/ :/ 和/ 已有/ 的/ 测试方法/ 相比/ ,/ 我们/ 的/ 测试方法/ 用于/ 在线/ 处理/ 的/ 时间/ 开销/ 和/ 空间/ 开销/ 都/ 有/ 明显/ 的/ 降低/ ,/ 特别/ 是/ 时间/ 开销/ 的/ 降低/ 尤为/ 明显/ ;/ 而且/ 这种/ 降低/ 随着/ 运行/ 时间/ 的/ 延长/ 而/ 愈加/ 显著/ ./ 另一方面/ ,/ 当/ 被/ 测/ 程序/ 的/ 运行/ 时间/ 较/ 短时/ ,/ 现有/ 工具/ 的/ 在线/ 处理/ 效率/ 仍/ 是/ 可/ 接受/ 的/ ;/ 而/ 新/ 工具/ Page16/ 的/ 效率/ 优势/ 主要/ 体现/ 在/ 需要/ 较长时间/ 地/ 运行/ 被测/ 程序/ 时/ ./ 新/ 工具/ 在/ 时空/ 开销/ 上/ 的/ 优势/ 主要/ 得益于/ 其/ 区间/ 识别/ 技术/ 的/ 两个/ 特点/ :/ (/ 1/ )/ 只/ 使用/ 两个/ 长度/ 很小/ 的/ 数据结构/ (/ 即/ 堆栈/ instS/ 和/ 队列/ instQ/ )/ 来/ 动态/ 地/ 存储/ 少量/ 的/ 信息/ ,/ 而/ 不是/ 使用/ 列表/ 增量/ 地/ 保存/ 大量/ 的/ 信息/ ;/ (/ 2/ )/ 能够/ 实时/ 地/ 识别/ 区间/ 的/ 终点/ ./ 这种/ 区间/ 识别/ 技术/ 在/ 效率/ 上/ 的/ 优势/ ,/ 使得/ 它/ 有/ 可能/ 运用/ 在/ 更/ 多/ 潜在/ 的/ 基于/ 区间/ 的/ 测试方法/ 中/ ,/ 尤其/ 是/ 运用/ 在/ 需要/ 实时/ 地/ 分析/ 区间/ 数据/ 的/ 场合/ ./ 6/ 相关/ 工作/ 随着/ 无线/ 传感器/ 网络/ 的/ 应用/ 和/ 研究/ 的/ 增多/ ,/ 出现/ 了/ 越来越/ 多/ 的/ 软件测试/ 、/ 验证/ 与/ 调试/ 技术/ ./ 下面/ 分类/ 简介/ 其中/ 的/ 部分/ 工作/ ./ 而/ 文献/ [/ 2/ ]/ 从/ 更/ 广泛/ 的/ 视角/ 对/ 这些/ 技术/ 进行/ 了/ 综述/ ./ 基于/ 数据挖掘/ 的/ 测试/ 与/ 调试/ ./ Sentomist/ [/ 5/ ]/ 是/ 基于/ 指令/ 级/ 模拟器/ 的/ 测试/ 技术/ ,/ 它/ 利用/ one/ -/ classSVM/ 作为/ 异常/ 检测/ 算法/ 分析/ 指令/ 的/ 执行/ 计数/ ,/ 以/ 发现/ 程序/ 的/ 瞬态/ 错误/ ./ 为了/ 帮助/ 测试者/ 识别/ 错误/ 的/ 原因/ ,/ Diagnostic/ -/ simulation/ [/ 11/ ]/ 利用/ 扩展/ 的/ TOSSIM/ 模拟器/ 记录/ 系统/ 运行/ 中/ 的/ 事件/ 序列/ ,/ 并/ 对/ 这些/ 事件/ 日志/ 进行/ 频繁/ 模式/ 挖掘/ ;/ Dustminer/ [/ 12/ ]/ 和/ SNTS/ [/ 13/ ]/ 利用/ 日志/ 引擎/ [/ 14/ ]/ 捕获/ 系统/ 在/ 正常/ 与/ 故障/ 两种/ 运行/ 情况/ 下/ 的/ 事件/ 历史/ ,/ 并/ 对/ 两种/ 情况/ 下/ 的/ 事件/ 日志/ 进行/ 判别/ 规则/ 挖掘/ ./ 文献/ [/ 15/ ]/ 系统地/ 综述/ 了/ 运用/ 数据挖掘/ 来/ 测试/ 和/ 调试/ WSN/ 程序/ 的/ 技术/ ./ 基于/ 静态/ 分析/ 的/ 测试/ ./ Lu/ 等/ 人/ [/ 16/ ]/ 研究/ 了/ 上下文/ 感知/ 应用程序/ 中/ 基于/ 数据流/ 的/ 测试/ 覆盖/ 准则/ ./ Lai/ 等/ 人/ [/ 4/ ]/ 基于/ 上下文/ 间/ (/ inter/ -/ context/ )/ 的/ 流图/ ,/ 提出/ 了/ 一种/ 用于/ nesC/ 程序/ 的/ 测试/ 覆盖/ 准则/ ,/ 此图/ 捕获/ 由/ 中断/ 驱动/ 的/ 组件/ 内/ 交互/ 行为/ ./ Le/ 等/ 人/ [/ 17/ ]/ 基于/ 中断/ 间/ 的/ 流图/ 和/ 一个/ 懒/ 抢占/ (/ lazy/ -/ preemption/ )/ 模型/ ,/ 提出/ 了/ 一种/ 基于/ 路径/ 的/ 全/ 程序/ 分析方法/ ./ FSMGen/ [/ 18/ ]/ 通过/ 静态/ 分析/ 生成/ 了/ TinyOS/ 程序/ 的/ 状态机/ 模型/ ,/ 可/ 帮助/ 测试者/ 理解/ 应用逻辑/ ,/ 从而/ 有助于/ 发现错误/ ./ 验证/ 与/ 检测/ ./ T/ -/ Check/ [/ 19/ ]/ 和/ KleeNet/ [/ 20/ ]/ 基于/ 模拟器/ 对/ 程序/ 的/ 状态/ 进行/ 深度/ 搜索/ ./ 其中/ T/ -/ Check/ 利用/ 模型/ 检测/ 和/ 随机/ 测试/ 来/ 发现错误/ ,/ 而/ KleeNet/ 通过/ 建立/ 非/ 确定性/ 事件/ 模型/ 和/ 符号分析/ 来/ 查找/ 错误/ ./ Anquiro/ [/ 21/ ]/ 和/ 文献/ [/ 22/ ]/ 中/ 的/ 模型/ 检测/ 技术/ 用于/ 验证/ Contiki/ 操作系统/ 上/ 的/ 应用程序/ ./ 运行/ 时/ 检查/ 与/ 调试/ ./ Harbor/ [/ 23/ ]/ 、/ SafeTinyOS/ [/ 24/ ]/ 和/ Neutron/ [/ 25/ ]/ 检查/ 违反/ 内存/ 安全/ 、/ 类型/ 安全/ 和/ 并发/ 安全/ 的/ 错误/ ./ Interface/ -/ contract/ [/ 26/ ]/ 检查/ 组件/ 接口/ 错误/ ./ Marionette/ [/ 27/ ]/ 和/ Clairvoyant/ [/ 28/ ]/ 提供/ 类似/ GDB/ 的/ 功能/ 、/ 用于/ 在/ 节点/ 级/ 进行/ 交互式/ 调试/ ;/ EnviroLog/ [/ 14/ ]/ 能/ 记录/ 和/ 重/ 放在/ 底层/ 产生/ 的/ 事件/ 以/ 用于/ 性能/ 评估/ 和/ 调试/ ;/ Declarative/ -/ Tracepoints/ [/ 29/ ]/ 和/ NodeMD/ [/ 30/ ]/ 利用/ 简单/ 的/ 批注/ 和/ 日志/ 记录/ 来/ 发现/ 和/ 排除/ 严重/ 的/ 程序/ 错误/ ./ ADA/ [/ 31/ ]/ 采用/ 自/ 适应/ 的/ 源码/ 级/ 追踪/ 和/ 重放/ 技术/ 对/ 部署/ 后/ 的/ 程序/ 进行/ 错误诊断/ ,/ 可/ 分析/ 和/ 调试/ 属性/ 违反/ 错误/ ,/ 且/ 能/ 有效/ 地/ 控制/ 调试/ 中/ 的/ 时空/ 开销/ ./ 7/ 结论/ 本文/ 提出/ 了/ 一种/ 新/ 的/ 基于/ 区间/ 的/ 测试方法/ ,/ 以/ 有效/ 地/ 检测/ 传感/ 网/ 应用/ 级/ 组件/ 中/ 的/ 瞬态/ 错误/ ./ 此/ 方法/ 的/ 主要/ 特点/ 是/ 采用/ 了/ 基于/ 应用/ 级/ 事件/ 的/ 区间/ 划分/ 策略/ 和/ 程序/ 行为/ 选择/ 策略/ ./ 与/ 现有/ 的/ 方法/ 相比/ ,/ 这/ 两个/ 策略/ 可/ 降低/ 甚至/ 消除/ 待/ 排序/ 区间/ 中/ 的/ 良性/ 偶然/ 行为/ ,/ 并/ 报告/ 更/ 短/ 的/ 可疑/ 区间/ ./ 我们/ 提出/ 了/ 一种/ 高效/ 的/ 区间/ 识别/ 算法/ ./ 基于/ 此/ 算法/ ,/ 开发/ 了/ 一个/ 原型/ 工具/ 以/ 实现/ 我们/ 的/ 方法/ ./ 通过/ 实验/ 评估/ 了/ 我们/ 测试方法/ 的/ 有效性/ ./ 实验/ 结果表明/ ,/ 我们/ 的/ 方法/ 能够/ 有效/ 地/ 将/ 错误/ 区间/ 排/ 在/ 前列/ ,/ 并/ 能/ 明显/ 地/ 减轻/ 测试者/ 在/ 人工/ 检查/ 单个/ 区间/ 时/ 的/ 负担/ ,/ 从而/ 有效/ 地/ 缓解/ 了/ TestOracle/ 问题/ ./ 我们/ 通过/ 实验/ 评估/ 了/ 我们/ 测试工具/ 的/ 运行/ 效率/ ./ 实验/ 结果表明/ ,/ 和/ 现有/ 的/ 工具/ 相比/ ,/ 我们/ 的/ 测试工具/ 的/ 在线/ 处理过程/ 具有/ 更/ 高/ 的/ 时空/ 效率/ ./ 现有/ 的/ 基于/ 区间/ 测试方法/ 包括/ 4/ 个/ 关键/ 策略/ ,/ 即/ 区间/ 的/ 划分/ 策略/ 、/ 程序/ 行为/ 的/ 选取/ 策略/ 、/ 程序/ 行为/ 特征/ 的/ 选取/ 策略/ 和/ 错误/ 区间/ 的/ 检测/ 策略/ ./ 新/ 方法/ 虽然/ 只是/ 对/ 现有/ 方法/ 的/ 前/ 两个/ 策略/ 进行/ 改进/ ,/ 但是/ 能/ 明显/ 地/ 改善/ 错误/ 检测/ 的/ 有效性/ ./ 我们/ 的/ 后续/ 工作/ 包括/ :/ 尝试/ 改变/ 上述/ 的/ 后/ 两种/ 策略/ ,/ 并/ 研究/ 这种/ 改变/ 对/ 测试/ 效果/ 的/ 影响/ ;/ 用/ 更/ 多样/ 的/ 被/ 测/ 程序/ 和/ 测试用例/ 来/ 检验/ 新/ 方法/ 的/ 有效性/ ;/ 探讨/ 在/ 单个/ 区间/ 中/ 包含/ 多个/ 错误/ 时/ 的/ 测试方法/ ;/ 以及/ 针对/ 非/ 瞬态/ 错误/ ,/ 开发新/ 的/ 基于/ 区间/ 的/ 测试/ 技术/ ./ 致谢/ 审稿/ 专家/ 和/ 编辑/ 为/ 本文/ 提出/ 了/ 宝贵/ 的/ 意见/ 和/ 建议/ ,/ 作者/ 在/ 此/ 表示/ 衷心感谢/ !/ Page17/ 

