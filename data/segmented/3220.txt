Page1HV/ -/ Recovery/ :/ 一种/ 闪存/ 数据库/ 的/ 高效/ 恢复/ 方法/ 卢泽萍/ 孟小峰/ 周大/ (/ 中国人民大学/ 信息/ 学院/ 北京/ 100872/ )/ 摘要/ 和/ 磁盘/ 相比/ ,/ 闪存/ 作为/ 一种/ 新型/ 的/ 存储设备/ ,/ 具有/ 读写/ 速度/ 快/ 、/ 抗震/ 、/ 省/ 电/ 、/ 体积小/ 等/ 优点/ ./ 因此/ ,/ 当前/ 的/ 研究/ 普遍认为/ 闪存/ 将/ 取代/ 磁盘/ 成为/ 新一代/ 的/ 数据库/ 二级/ 存储设备/ ./ 但是/ ,/ 由于/ 闪存/ 具有/ 和/ 磁盘/ 不同/ 的/ 一些/ 固有/ 的/ 读取/ 特性/ ,/ 将/ 当前/ 基于/ 磁盘/ 设计/ 的/ 数据库/ 直接/ 移植/ 到/ 闪存/ 上时/ ,/ 并/ 不能/ 充分发挥/ 闪存/ 设备/ 的/ 优越性/ ./ 在/ 数据库/ 的/ 恢复/ 过程/ 中/ ,/ 由于/ 闪存/ 的/ 异地/ 更新/ 和/ 重写/ 之前/ 先/ 擦除/ 的/ 特性/ 将/ 带来/ 大量/ 高/ 代价/ 的/ 小/ 的/ 随机/ 写/ ,/ 直接/ 使用/ 传统/ 的/ 恢复/ 方法/ 在/ 闪存/ 数据库/ 中/ 就/ 更/ 难以/ 充分利用/ 闪存/ 的/ 优越性/ ./ 因此/ ,/ 文中/ 提出/ 了/ 一种/ 对/ 闪存/ 中/ 天然/ 存在/ 的/ 数据/ 的/ 历史/ 版本/ 来/ 进行/ 管理/ 和/ 利用/ 的/ 恢复/ 方法/ HV/ -/ recovery/ ,/ 来/ 改进/ undo/ 恢复/ 的/ 性能/ ./ 通过/ 和/ 开源/ 数据库/ OracleBerkeleyDB/ 的/ 比较/ ,/ 实验/ 结果表明/ HV/ -/ recovery/ 是/ 原有/ 的/ 恢复/ 算法/ 性能/ 的/ 2/ ~/ 8/ 倍/ ,/ 充分说明/ 了/ 其/ 优越性/ ./ 关键词/ 闪存/ ;/ 闪存/ 数据库/ ;/ 固态/ 硬盘/ ;/ 恢复/ ;/ 日志/ 1/ 引言/ 海量/ 的/ 数据/ 对/ 数据库系统/ 性能/ 的/ 要求/ 也/ 越来越/ 高/ ./ 而/ 作为/ 当前/ 比较/ 主流/ 的/ 二级/ 存储介质/ ,/ 磁盘/ 因为/ 其/ 内部/ 的/ 机械/ 移动/ 已经/ 成为/ IO/ 性能/ 的/ 瓶颈/ ,/ 越来越/ 随着/ 信息技术/ 的/ 飞速发展/ ,/ 数据/ 呈/ 爆炸性/ 增长/ ,/ 不能/ 满足/ 实际/ 应用/ 系统对/ 数据/ 存取/ 带宽/ 的/ 需求/ ./ 在/ Page2/ 过去/ 的/ 20/ 年里/ ,/ CPU/ 处理速度/ 增加/ 了/ 570/ 倍/ ,/ 而/ 磁盘/ 的/ 访问速度/ 却/ 只/ 增加/ 了/ 20/ 倍/ [/ 1/ ]/ ./ 可见/ ,/ CPU/ 和/ 主要/ 二级/ 存储器/ 磁盘/ 之间/ 的/ 带宽/ 鸿沟/ 已经/ 成为/ 了/ 制约/ 计算机系统/ 处理/ 能力/ 提高/ 的/ 主要/ 瓶颈/ ./ 值得/ 庆幸/ 的/ 是/ ,/ 闪存/ 作为/ 一种/ 新型/ 的/ 固态/ 存储设备/ ,/ 由于/ 其/ 读写/ 速度/ 快/ 、/ 消耗/ 电量/ 低/ 、/ 抗震/ 、/ 小巧/ 轻便/ 等/ 优点/ ,/ 已经/ 受到/ 越来越/ 多/ 的/ 关注/ ./ 随着/ 容量/ 的/ 不断/ 增大/ 和/ 单位/ 价格/ 的/ 不断/ 下降/ ,/ 许多/ 研究者/ 纷纷/ 预测/ 闪存/ 将/ 逐渐/ 取代/ 磁盘/ 成为/ 新/ 的/ 主流/ 二级/ 存储设备/ ./ 图灵奖/ 得主/ GrayJim/ 在/ 2005/ 年/ 就/ 曾/ 预测/ 说/ “/ 就/ 像/ 磁盘/ 取代/ 磁带/ 一样/ ,/ 闪存/ 将会/ 取代/ 磁盘/ ”/ [/ 1/ ]/ ./ 即使/ 对/ 现有/ 的/ 数据库/ 不/ 做/ 任何/ 改进/ ,/ 直接/ 移植/ 到/ 闪存/ 上/ ,/ 其/ 性能/ 也/ 能/ 提高/ 大约/ 10/ 倍/ [/ 2/ ]/ ./ 但是/ ,/ 由于/ 闪存/ 其/ 固有/ 的/ 特性/ ,/ 若/ 将/ 现有/ 的/ 面向/ 磁盘/ 的/ 传统/ 数据库/ 直接/ 运行/ 在/ 闪存/ 存储器/ 上/ ,/ 还/ 不能/ 充分发挥/ 闪存/ 的/ 优越性/ ./ 因此/ ,/ 当前/ 迫切需要/ 将/ 传统/ 的/ 数据库/ 进行/ 改进/ ,/ 让/ 其/ 更好/ 地/ 适应/ 闪存/ 本身/ 的/ 特点/ ,/ 以/ 进一步提高/ 闪存/ 数据库/ 的/ 性能/ [/ 3/ -/ 4/ ]/ ./ 数据库/ 开发/ 和/ 应用/ 的/ 实践/ 表明/ ,/ 数据库/ 恢复/ 技术/ 作为/ 数据库系统/ 中/ 不可/ 缺少/ 的/ 组成部分/ ,/ 对/ 整个/ 系统/ 的/ 性能/ 影响/ 是/ 非常/ 大/ 的/ [/ 5/ -/ 7/ ]/ ./ 在/ 恢复/ 过程/ 中/ ,/ 为了/ 对/ 事务/ 已经/ 更改/ 的/ 数据项/ 进行/ 还原/ ,/ 通常/ 需要/ 对/ 数据库/ 中/ 的/ 一些/ 已经/ 赋予/ 新值/ 的/ 数据/ 进行/ 重写/ ./ 而/ 这种/ 大量/ 的/ 小/ 随机/ 重写/ 操作/ ,/ 对/ 闪存/ 的/ 代价/ 是/ 非常/ 巨大/ 的/ ,/ 不但/ 浪费/ 空间/ ,/ 而且/ 非常/ 耗时/ ./ 因此/ ,/ 迫切需要/ 一种/ 高效/ 且/ 稳定性/ 强/ 的/ 闪存/ 数据库/ 的/ 恢复/ 技术/ ./ 本文/ 针对/ 闪存/ 存储器/ 中/ 天然/ 存在/ 的/ 历史/ 版本/ 数据/ ,/ 提出/ 了/ 一种/ 充分利用/ 这些/ 数据/ 的/ 历史/ 版本/ 从而/ 进行/ 恢复/ 的/ 一种/ 新型/ 的/ 恢复/ 方法/ HV/ -/ recovery/ ./ 总的来说/ ,/ 本文/ 所/ 做/ 的/ 主要/ 贡献/ 如下/ :/ (/ 1/ )/ 本文/ 研究/ 了/ 闪存/ 数据库/ 中/ 的/ 恢复/ 问题/ ,/ 并/ 提出/ 了/ 新/ 的/ 适用/ 于/ 闪存/ 的/ 恢复/ 方法/ ./ (/ 2/ )/ 提供/ 简单/ 有效/ 的/ 恢复/ 操作/ ./ 有效/ 地/ 减少/ 在/ 恢复/ 过程/ 中/ 容易/ 出现/ 的/ 冗余/ 写/ 操作/ ,/ 从而/ 大幅度/ 减少/ 恢复/ 时间/ ./ (/ 3/ )/ 优化/ 日志/ 结构/ ./ 减少/ 过多/ 的/ 日志/ 冗余/ ,/ 从而/ 提供/ 高效/ 的/ 日志/ 文件/ ./ (/ 4/ )/ 提高/ 空间/ 利用率/ ./ 减少/ 大量/ 垃圾/ 数据/ 的/ 存在/ ,/ 从而/ 提高/ 存储设备/ 中/ 的/ 空间/ 利用率/ ./ 本文/ 第/ 2/ 节/ 介绍/ 闪存/ 特殊/ 的/ 物理/ 特性/ 给/ 恢复/ 带来/ 的/ 挑战/ 以及/ 相关/ 工作/ ;/ 第/ 3/ 节/ 详细/ 介绍/ 本文/ 设计/ 的/ HV/ -/ recovery/ 的/ 基本原理/ ;/ 第/ 4/ 节/ 提出/ 怎样/ 针对/ HV/ -/ recovery/ 中/ 的/ 设计/ 进行/ 进一步/ 的/ 性能/ 优化/ ;/ 第/ 5/ 节用/ 分析/ 及/ 实验/ 结果/ 证明/ 设计/ 的/ 优越性/ ;/ 最后/ 第/ 6/ 节/ 进行/ 总结/ ./ 2/ 问题/ 定义/ 及/ 相关/ 工作/ 闪存/ 和/ 磁盘/ 读写/ 特性/ 的/ 不同/ 使得/ 将/ 现有/ 的/ 传统/ 的/ 数据库/ 移植/ 到/ 闪存/ 上/ 时会/ 出现/ 一些/ 问题/ ./ 下面/ 将/ 具体/ 介绍/ 在/ 恢复/ 中/ 出现/ 问题/ 的/ 原因/ 和/ 现有/ 的/ 一些/ 改进/ 方案/ 及/ 它们/ 所/ 存在/ 的/ 问题/ ./ 2.1/ 闪存/ 存储器/ 的/ 物理/ 特性/ 没有/ 机械/ 延迟/ ./ 我们/ 知道/ ,/ 在/ 磁盘/ 中/ ,/ 访问/ 数据/ 的/ 时间/ 主要/ 用于/ 移动/ 磁头/ 以及/ 等待/ 磁盘/ 旋转/ ./ 而/ 闪存/ 没有/ 像/ 磁头/ 一样/ 的/ 机械/ 部件/ ,/ 其/ 随机/ 访问/ 模式/ 和/ 顺序/ 访问/ 模式/ 的/ 开销/ 是/ 相当/ 的/ ./ 这样/ ,/ 就/ 可以/ 把/ 数据/ 离散/ 地/ 分布/ ,/ 这/ 并/ 不会/ 使/ 访问/ 的/ 开销/ 增加/ ./ 重写/ 之前/ 先/ 擦除/ ./ 众所周知/ ,/ 在/ 磁盘/ 中/ ,/ 如果/ 需要/ 更新/ 数据/ ,/ 这些/ 数据/ 的/ 新/ 版本/ 可以/ 直接/ 原地/ 覆盖/ 在/ 旧版本/ 所/ 占有/ 的/ 地址/ 上/ ,/ 这/ 就是/ 所谓/ 的/ 原地/ 更新/ ./ 可是/ 在/ 闪存/ 中/ ,/ 在/ 数据/ 的/ 旧版本/ 没有/ 被/ 擦除/ 前/ ,/ 是/ 不能/ 在/ 原地/ 写入/ 新/ 的/ 版本/ 的/ ./ 也就是说/ ,/ 如果/ 修改/ 一个/ 数据/ ,/ 就/ 需要/ 对/ 整个/ 块/ (/ 通常/ 为/ 64K/ 或/ 128K/ )/ 上/ 的/ 数据/ 进行/ 擦除/ ,/ 这是/ 非常/ 巨大/ 的/ 代价/ ./ 因此/ ,/ 在/ 闪存/ 中/ 往往/ 会/ 采取/ 异地/ 更新/ 的/ 方式/ ,/ 即/ 把/ 数据/ 的/ 新/ 版本/ 写入/ 另外/ 的/ 空闲/ 空间/ 中/ ,/ 而/ 不/ 直接/ 在/ 原地/ 覆盖/ ./ 读写/ 速度/ 不/ 一致/ ./ 在/ 闪存/ 中/ ,/ 不同/ 的/ 访问/ 操作/ 的/ 速度/ 差别/ 很大/ ./ 一般来说/ ,/ 读/ 的/ 速度/ 很快/ ,/ 写/ 的/ 速度/ 略慢/ ,/ 擦除/ 的/ 速度/ 最慢/ ./ 因此/ ,/ 在/ 设计/ 新/ 的/ 基于/ 闪存/ 的/ 数据结构/ 中/ ,/ 应当/ 尽量减少/ 写/ 操作/ 和/ 擦除/ 操作/ ,/ 可以/ 适当/ 增加/ 读/ 操作/ ,/ 以/ 整体/ 上/ 提高/ 系统/ 性能/ ./ 有限/ 的/ 擦除/ 次数/ ./ 虽然/ 闪存/ 中/ 的/ 块/ 是/ 可以/ 进行/ 反复/ 擦除/ 的/ ,/ 但/ 每个/ 块/ 的/ 擦除/ 次数/ 是/ 有限/ 的/ ,/ 一般/ 为/ 10000/ ~/ 100000/ 次/ ./ 因此/ ,/ 就/ 必须/ 尽量减少/ 写入/ 的/ 次数/ ,/ 以/ 间接/ 减少/ 擦除/ 的/ 次数/ ,/ 来/ 延长/ 闪存/ 的/ 使用寿命/ ./ 2.2/ 问题/ 定义/ 在/ 面向/ 磁盘/ 的/ 数据库系统/ 中/ ,/ 基于/ 日志/ 的/ 恢复/ 技术/ 被/ 广泛/ 采用/ ./ 不同/ 的/ 协议/ 之下/ ,/ 日志/ 记录/ 的/ 设计/ 、/ 日志/ // 数据/ 缓冲区/ 的/ 管理/ 、/ 检查点/ 机制/ 、/ 记录/ 日志/ 和/ 恢复/ 的/ 过程/ 都/ 很/ 不/ 一样/ ./ 以/ 最为/ 常见/ 的/ undo/ 日志/ 为例/ ,/ 当/ 事务/ T/ 需要/ 将/ 数据库/ 元素/ X/ 的/ 取值/ v/ 改变/ 时/ ,/ undo/ 日志/ 就/ 会/ 将/ 形如/ 〈/ T/ ,/ X/ ,/ v/ 〉/ 的/ 日志/ 记录/ 记到/ 磁盘/ 上/ ,/ 当/ 需要/ 对/ 事务/ T/ 进行/ 恢复/ ,/ 则/ 需要/ 在/ 外存/ 中/ 重新/ 写入/ X/ 的/ 值/ v/ ./ 若/ 将/ 这个/ 过程/ 移/ 到/ 闪存/ 上/ ,/ 举例来说/ ,/ 如果/ 数据库/ 中/ 存在/ 一个/ 如表/ 1/ (/ a/ )/ 所示/ 的/ 数据表/ ,/ 当/ 需要/ 将/ 数据表/ 中/ 的/ A/ 值/ 由/ v1/ 修改/ 为/ v2/ 时/ ,/ 就要/ 写入/ 一条/ 新/ 的/ 记录/ ,/ 如表/ 1/ (/ b/ )/ 所示/ 得/ 最后/ 1/ 行/ ./ 而/ 如果/ 需要/ 将/ APage3/ 值/ 进行/ 恢复/ 的/ 时候/ ,/ 就要/ 再/ 写入/ 一条/ 其实/ 早已/ 存在/ 于/ 内存/ 中/ 的/ 记录/ ,/ 如表/ 1/ (/ c/ )/ 所示/ ./ 这/ 就/ 可以/ 看出/ ,/ 最后/ 1/ 条/ 记录/ 和/ 第/ 1/ 条/ 记录/ 是/ 相同/ 的/ ./ 也就是说/ ,/ 这/ 其实/ 是/ 存在/ 冗余/ 的/ ./ 因此/ ,/ 闪存/ 中/ 通常/ 存在/ 着/ 大量/ 的/ 数据/ 的/ 历史/ 版本/ ,/ 而/ 显式/ 的/ 恢复/ 过程/ 又/ 不断/ 地/ 写入/ 已经/ 存在/ 的/ 数据项/ ./ 这/ 既/ 浪费/ 空间/ 又/ 浪费时间/ ./ 表/ 1undo/ 日志/ 在/ 闪存/ 数据库/ 中/ 存在/ 的/ 问题/ 同时/ ,/ 我们/ 已经/ 知道/ ,/ 闪存/ 通常/ 采取/ 异地/ 更新/ ,/ 但是/ 因为/ 闪存/ 每次/ 写/ 的/ 单位/ 为页/ ,/ 即使/ 是/ 有所改进/ 的/ 闪存/ ,/ 其/ 一页/ 也/ 通常/ 只能/ 写/ 4/ 次/ ./ 也就是说/ ,/ 不管/ 一次/ 要/ 写入/ 的/ 数据量/ 多大/ ,/ 至少/ 需要/ 占用/ 闪存/ 中/ 四分之一/ 个页/ 的/ 大小/ ,/ 而/ 通常/ 来说/ ,/ 一个/ 需要/ 恢复/ 的/ 数据项/ 可能/ 并/ 没有/ 这么/ 大/ ./ 这样/ ,/ 就/ 更/ 带来/ 了/ 额外/ 的/ 空间/ 浪费/ ./ 同时/ ,/ 这些/ 额外/ 的/ 写/ 操作/ 会/ 有/ 较/ 高/ 的/ 时间/ 代价/ ,/ 并且/ 因为/ 一些/ 额外/ 的/ 空间/ 浪费/ ,/ 就/ 会/ 带来/ 一些/ 本/ 不必要/ 的/ 擦除/ 操作/ ,/ 其/ 时间/ 代价/ 更为/ 巨大/ ./ 因此/ ,/ 在/ 恢复/ 中/ 所/ 进行/ 这种/ 大量/ 的/ 小/ 的/ 随机/ 重写/ 对/ 闪存/ 的/ 代价/ 也/ 是/ 非常/ 可怕/ 的/ ,/ 这/ 就/ 需要/ 设计/ 新/ 的/ 恢复/ 方法/ ./ 2.3/ 相关/ 工作/ 随着/ 技术/ 的/ 不断/ 发展/ ,/ 闪存/ 的/ 优势/ 越来越/ 明显/ ,/ 有/ 越来越/ 多/ 的/ 研究/ 关注/ 于/ 如何/ 在/ 基于/ 闪存/ 的/ 数据库/ 中/ 提供/ 更/ 高/ 的/ 性能/ ,/ 其中/ 较/ 有/ 影响力/ 的/ 工作/ 包括/ IPL/ [/ 8/ ]/ 、/ FlashLogging/ [/ 9/ ]/ 、/ TransactionalFlash/ [/ 10/ ]/ 和/ PORCE/ [/ 11/ ]/ 等/ ./ IPL/ 彻底改变/ 了/ 闪存/ 数据库/ 中/ 的/ 存储/ 结构/ ,/ 它/ 将/ 闪存/ 上/ 每个/ 块/ 中/ 的/ 页/ 分为/ 两个/ 部分/ :/ 数据/ 页/ 和/ 日志/ 页/ ./ 当对/ 一个/ 块/ 中/ 的/ 数据/ 页/ 进行/ 修改/ 时/ ,/ 为了/ 避免/ 闪存/ 的/ 原地/ 更新/ 带来/ 的/ 巨大/ 代价/ ,/ IPL/ 只是/ 将/ 修改/ 以/ 日志/ 的/ 形式/ 保存/ 在/ 其/ 数据/ 所在/ 块/ 的/ 日志/ 页/ 中/ ./ 并且/ 在/ 日志/ 区域/ 满时/ ,/ 进行/ 日志/ 记录/ 与/ 数据/ 的/ 合并/ ,/ 来/ 减少/ 存储空间/ ./ 这种/ 存储/ 方式/ 因为/ 将/ 对/ 数据库/ 的/ 改变/ 通过/ 日志/ 方式/ 保存/ ,/ 可以/ 间接/ 的/ 对/ 数据库/ 提供/ 恢复/ ./ 但是/ ,/ 这/ 需要/ 对/ 现有/ 的/ 数据库/ 进行/ 较大/ 的/ 修改/ ,/ 并/ 不能/ 方便/ 地/ 移植/ 于/ 不同/ 的/ 数据库/ 中/ ./ FlashLogging/ 提出/ 了/ 一种/ 使用/ 多个/ 性价比/ 高且/ 更/ 适合/ 于/ 日志/ 的/ 访问/ 和/ 存储/ 模式/ 的/ USB/ 设备/ ,/ 来/ 取代/ SSD/ 记录/ 日志/ ./ 因为/ USB/ 的/ 存储容量/ 一般来说/ 相对/ 较/ 小/ ,/ FlashLogging/ 设计/ 了/ 一种/ 轮转/ 式/ 的/ 阵列/ 组织/ 方式/ 来/ 有效/ 地/ 管理/ 这些/ 分散/ 存放/ 在/ USB/ 设备/ 中/ 的/ 日志/ 记录/ ,/ 并/ 提供/ 恢复/ ./ 这种/ 方法/ 需要/ 大量/ 的/ USB/ 设备/ 阵列/ ,/ 并且/ 会/ 需要/ 对/ 多个/ USB/ 设备/ 进行/ 读写/ ,/ 这是/ 非常/ 耗时/ 的/ ,/ 而且/ 随着/ SSD/ 价格/ 的/ 不断/ 下降/ ,/ USB/ 设备/ 的/ 价格优势/ 也/ 在/ 渐渐/ 消失/ ,/ 因此/ ,/ 这/ 并/ 不是/ 一个/ 方便/ 的/ 系统/ 搭建/ 模式/ ./ 另外/ ,/ 在/ 闪存/ 中/ ,/ 若/ 使用/ FTL/ 层来/ 屏蔽/ Flash/ 的/ 物理/ 特性/ ,/ 则/ 需要/ 维护/ 一个/ 物理地址/ 和/ 逻辑/ 地址/ 的/ 映射/ 表/ ,/ 而/ 将/ 闪存/ 作为/ 嵌入式/ 系统/ 的/ 存储设备/ 时/ ,/ 则/ 因为/ 常常/ 会/ 出现/ 断电/ 的/ 情况/ ,/ 就/ 容易/ 丢失/ 这个/ 映射/ 表/ ./ 因此/ ,/ PORCE/ 提供/ 了/ 一种/ 在/ 断电/ 之后/ 如何/ 提供/ 物理地址/ 和/ 逻辑/ 地址映射/ 的/ 恢复/ 方法/ ./ 而/ 针对/ 基于/ 闪存/ 的/ 文件系统/ ,/ SAC2006/ [/ 12/ ]/ 和/ TOS2006/ [/ 13/ ]/ 提出/ 了/ 一种/ 如何/ 利用/ 闪存/ 的/ 特性/ ,/ 来/ 提供/ 对/ 基于/ 闪存/ 的/ 文件系统/ 的/ 快速/ 载入/ 和/ 崩溃/ 之后/ 的/ 恢复/ 的/ 方法/ ./ 然而/ ,/ 这些/ 方法/ 是/ 针对/ 于/ 文件系统/ ,/ 而/ 不是/ 我们/ 讨论/ 的/ 数据库系统/ ,/ 虽然/ 设计/ 思路/ 上/ 可以/ 有/ 较/ 好/ 的/ 参考/ ,/ 但/ 其/ 性能/ 并/ 不能/ 直接/ 地/ 与/ 我们/ 的/ 设计/ 相互/ 比较/ ./ 3HV/ -/ recovery/ 通过/ 之前/ 的/ 分析/ ,/ 可以/ 发现/ ,/ 在/ 闪存/ 存储设备/ 中/ ,/ 在/ 恢复/ 时/ ,/ 完全/ 没有/ 必要/ 用/ 显式/ 的/ 回滚/ 操作/ 来/ 重新/ 写入/ 数据/ 元素/ 在/ 事务/ 更新/ 前/ 的/ 内容/ ./ 考虑/ 到/ 在/ 闪存/ 中/ 数据项/ 新旧/ 版本/ 的/ 同时/ 存在/ ,/ 可以/ 利用/ 旧版本/ 来/ 加快/ 回滚/ 和/ 恢复/ 的/ 过程/ ,/ 而/ 不/ 需要/ 发起/ 更为/ 昂贵/ 的/ 写/ 操作/ 来/ 多次/ 写入/ 一个/ 已经/ 存在/ 的/ 数据项/ 内容/ ./ 本文/ 的/ 设计/ 就是/ 考虑/ 最大/ 限度/ 地/ 利用/ 数据项/ 之前/ 的/ 历史/ 版本/ 来/ 进行/ 恢复/ ./ 图/ 1/ 是/ HV/ -/ recovery/ 的/ 一个/ 整体/ 的/ 体系结构/ 图/ ./ 在/ 数据库/ 的/ 正常/ 运行/ 阶段/ ,/ 随着/ 事务/ 对/ 数据/ 文/ Page4/ 件/ 的/ 不断/ 更改/ ,/ 日志/ 管理器/ 同时/ 将/ 形如/ (/ Tid/ ,/ X/ ,/ P/ (/ X/ )/ )/ 的/ 日志/ 记录/ 存放/ 在/ 日志/ 文件/ 中/ ,/ 当/ 数据库/ 发生/ 崩溃/ 或是/ 要/ 对/ 事务/ 进行/ 回滚时/ ,/ 恢复/ 管理器/ 就/ 根据/ 得到/ 的/ 需要/ 进行/ 恢复/ 的/ 事务/ 的/ ID/ 读取/ 日志/ 文件/ ,/ 获得/ 相关/ 的/ 日志/ 记录/ ,/ 并/ 根据/ 这些/ 日志/ 记录/ 进行/ 恢复/ ./ 以下/ 将/ 详细/ 介绍/ 其中/ 各/ 部分/ 的/ 具体/ 实现/ ./ 3.1/ 更新/ 日志/ 在/ 对/ 日志/ 记录/ 进行/ 管理/ 时/ ,/ HV/ -/ recovery/ 使用/ 了/ 一个/ 版本/ 列表/ version/ _/ list/ 来/ 保存/ 日志/ 记录/ ,/ 其/ 结构/ 如表/ 2/ 所示/ ./ 作为/ 日志/ 记录/ ,/ 其中/ 存储/ 的/ 是/ 被/ 修改/ 的/ 各/ 数据库/ 元素/ 的/ 历史/ 版本/ 的/ 地址/ 信息/ 、/ 引起/ 该/ 数据库/ 元素/ 更改/ 的/ 事务/ 的/ 标识/ 以及/ 该/ 数据项/ 的/ 旧值/ ./ TidT1T2T4T4T4T6T2T1T1commitNULLNULL/ …/ 当/ 需要/ 数据库系统/ 对/ 数据项/ 进行/ 更新/ 时/ ,/ 在/ 将/ 新/ 的/ 数据/ 版本/ 写入/ 新/ 地址/ 的/ 同时/ ,/ 日志/ 管理器/ 会/ 将/ 这个/ 数据项/ 的/ 旧值/ 、/ 旧/ 地址/ 以及/ 该/ 事务/ 标识/ 存入/ 到/ version/ _/ list/ 中/ ./ 并/ 将/ 其/ 作为/ 日志/ 记录/ 保存/ 在/ 永久性/ 存储器/ 中/ ./ 同时/ ,/ HV/ -/ recovery/ 的/ 日志/ 记录/ 类似/ 于/ undo/ 日志/ ,/ 必须/ 遵守/ 两条/ 规则/ ./ 规则/ A/ ./ 如果/ 事务/ 改变/ 了/ 数据库/ 元素/ ,/ 则/ 日志/ 记录/ 必须/ 在/ 数据库/ 元素/ 的/ 新值/ 写/ 到/ 二级/ 存储器/ 前/ 写出/ ./ 规则/ B/ ./ 如果/ 事务/ 提交/ ,/ 则/ 其/ 事务/ 提交/ 日志/ 记录/ 操作/ 必须/ 在/ 事务/ 改变/ 的/ 所有/ 数据库/ 元素/ 已写/ 到/ 二级/ 存储器/ 之后/ 再/ 执行/ ,/ 但应/ 尽快/ ./ 这样/ ,/ 在/ 恢复/ 中/ ,/ 只要/ 对于/ 在/ 日志/ 记录/ 中/ 显示/ 为/ 未/ 提交/ 的/ 事务/ ,/ 对/ 在/ 日志/ 记录/ 中/ 所/ 保存/ 的/ 该/ 事务所/ 做/ 的/ 所有/ 修改/ 进行/ 还原/ ,/ 就/ 可以/ 保证/ 数据库/ 对于/ 事务所/ 要求/ 的/ ACID/ 特性/ ./ 另外/ ,/ 在/ HV/ -/ recovery/ 中/ ,/ 若/ 同一个/ 事务/ 对/ 某/ 一个/ 它/ 已/ 更新/ 过/ 的/ 数据项/ 又/ 有/ 新/ 的/ 更新/ ,/ 就/ 增加/ 一条/ 新/ 的/ 日志/ 记录/ ,/ 保存/ 新/ 的/ 更新/ 操作/ ./ 如表/ 2/ 的/ 第/ 1/ 条/ 记录/ 和/ 第/ 8/ 条/ 记录/ 所示/ ./ 而/ 如果/ 是/ 不同/ 事务/ 对/ 同一/ 数据项/ 进行/ 修改/ ,/ 在/ 满足/ 数据库/ 对于/ 并发/ 设计/ 的/ 要求/ 的/ 前提/ 下/ ,/ 对/ 日志/ 记录/ 部分/ 来说/ ,/ 也/ 是/ 产生/ 一条/ 新/ 的/ 日志/ 记录/ 在/ version/ _/ list/ 中/ ./ 如表/ 2/ 中/ ,/ 第/ 2/ 条/ 记录/ 和/ 第/ 7/ 条/ 记录/ 所示/ ,/ T2/ 修改/ 了/ A/ 之后/ 又/ 修改/ 了/ 数据项/ Y/ ,/ 那/ 日志/ 管理器/ 就/ 将/ 这/ 两次/ 修改/ 作为/ 两条/ 不同/ 的/ 日志/ 记录/ 来/ 存储/ ./ 若/ 数据库/ 插入/ 一个/ 新/ 的/ 数据库/ 元素/ ,/ 则/ 与/ 更改/ 日志/ 记录/ 类似/ ,/ 产生/ 一条/ 新/ 的/ 日志/ 记录/ ,/ 只是/ 该/ 日志/ 记录/ 的/ 旧值/ 和/ 旧/ 地址/ 项/ 被/ 设置/ 为空/ ,/ 以/ 识别/ 为/ 插入/ 操作/ ./ 如表/ 2/ 中/ 第/ 3/ 条/ 记录/ 所示/ ./ 若/ 数据库/ 删除/ 一个/ 数据项/ ,/ 在/ 写入/ 原有/ 的/ 日志/ 记录/ 的/ 同时/ ,/ 再/ 增加/ 一条/ 日志/ 记录/ ,/ 使用/ 相同/ 的/ 事务/ 标识/ 和/ 数据项/ ,/ 但是/ 将/ 其/ 旧版本/ 地址/ 设置/ 为/ 一个/ 定义/ 了/ 的/ 删除/ 标识/ ./ 如表/ 2/ 中/ 第/ 4/ 条/ 记录/ 和/ 第/ 5/ 条/ 记录/ 所示/ ,/ T4/ 删除/ 了/ 一个/ 数据库/ 元素/ B/ ,/ 则/ 为/ T4/ 和/ B/ 增加/ 两条/ 新/ 的/ 日志/ 记录/ ,/ 并/ 把/ 后/ 一条/ 日志/ 记录/ 的/ 历史/ 版本/ 的/ 值/ 设置/ 为/ delete/ 标识/ ,/ 旧值/ 设为/ 空/ ./ 3.2/ 事务/ 提交/ 日志/ 在/ HV/ -/ recovery/ 中/ ,/ 每当/ 有/ 事务/ 提交/ ,/ 就/ 在/ 日志/ 记录/ 文件/ ,/ 也/ 就是/ version/ _/ list/ 中/ 对/ 该/ 事务/ 添加/ 一个/ 新/ 的/ 提交/ 记录/ ./ 具体来说/ ,/ 就是/ HV/ -/ recovery/ 为/ 每个/ 事务/ 设置/ 了/ 一个/ commit/ 元素/ ,/ 当/ 某个/ 事务/ 提交/ 时/ ,/ 就/ 为/ 该/ 事务/ 增加/ 一条/ 日志/ 记录/ ,/ 在/ 这个/ 日志/ 记录/ 中/ ,/ 将/ 该/ 事务/ 的/ commit/ 元素/ 的/ 地址/ 置/ 为/ 空/ ./ 如表/ 2/ 中/ 第/ 9/ 条/ 记录/ 所示/ ,/ 当/ T1/ 事务/ 提交/ ,/ 日志/ 管理器/ 就/ 对/ T1/ 事务/ 设置/ commit/ 元素/ ,/ 并/ 将/ 该/ 日志/ 记录/ 的/ 旧版本/ 地址/ 字段/ 设为/ 空/ ./ 注意/ ,/ 因为/ 本文/ 的/ 日志/ 记录/ 必须/ 满足/ 规则/ B/ ,/ 也就是说/ ,/ 当/ 事务/ 提交/ 日志/ 记录/ 到达/ 二级/ 存储器/ 的/ 时候/ ,/ 该/ 事务所/ 改变/ 的/ 所有/ 数据库/ 元素/ 已经/ 写/ 到/ 二级/ 存储器/ 上/ 了/ ./ 因此/ ,/ 此时/ 数据库/ 已经/ 提交/ 了/ 该/ 事务/ 的/ 所有/ 更新/ 操作/ ./ 相反/ ,/ 如果/ 事务/ 提交/ 日志/ 记录/ 未/ 到达/ 二级/ 存储器/ ,/ 则/ 在/ 恢复/ 时/ ,/ 不管/ 这个/ 事务/ 的/ 修改/ 在/ 数据库/ 中/ 完成/ 了/ 多少/ ,/ 这个/ 事务所/ 做/ 的/ 所有/ 操作/ 都/ 将/ 被/ 还原/ ,/ 从而/ 保证/ 事务/ 的/ 原子/ 性/ ./ 另外/ ,/ 日志/ 文件/ 中/ 存在/ 的/ 已经/ 提交/ 的/ 日志/ 记录/ 会/ 增加/ 日志/ 文件/ 的/ 长度/ ,/ 同时/ ,/ 会/ 使得/ 对/ 日志/ 文件/ 的/ 访问/ 变成/ 随机/ 模式/ ./ 但是/ ,/ 正如/ 之前/ 所/ 介绍/ 的/ ,/ 因为/ 闪存/ 设备/ 的/ 随机/ 读/ 和/ 连续/ 读/ 的/ 访问/ 时间/ 的/ 差异/ 不明/ Page5/ 显/ ,/ 所以/ 这些/ 日志/ 记录/ 的/ 存在/ 对于/ 其它/ 事务/ 的/ 恢复/ 效率/ 的/ 影响/ 是/ 非常/ 微小/ 的/ ,/ 几乎/ 可以/ 不必/ 考虑/ ./ 不过/ ,/ 这种/ 日志/ 记录/ 长久/ 保存/ 是/ 以/ 大量/ 的/ 闪存/ 存储空间/ 为/ 代价/ 的/ ,/ 考虑/ 到/ 当前/ 闪存/ 存储设备/ 的/ 价格/ 还/ 不是/ 很/ 低廉/ ,/ 这会/ 使得/ 应用/ 系统/ 的/ 成本/ 价格/ 提高/ ,/ 所以/ 在/ 第/ 4/ 节中/ ,/ 本文/ 会/ 提供/ 一个/ 进一步/ 改进/ 的/ 方案/ ./ 3.3/ 恢复/ 过程/ 当/ 系统/ 发生/ 崩溃/ 或者/ 事务/ 需要/ 进行/ 回滚时/ ,/ 由于/ HV/ -/ recovery/ 对/ 日志/ 记录/ 和/ 数据/ 更新/ 的/ 提交/ 顺序/ 满足/ 规则/ A/ 和/ 规则/ B/ ,/ 所以/ ,/ 只/ 需要/ 对/ 在/ 日志/ 记录/ 中/ 体现/ 为/ 尚未/ 提交/ 的/ 事务/ 进行/ 恢复/ ./ 首先/ ,/ 像/ 其它/ 恢复/ 方式/ 一样/ ,/ 先/ 读入/ 在/ 数据库/ 的/ 二级/ 永久性/ 存储器/ 中/ 需要/ 恢复/ 事务/ 的/ 日志/ 记录/ ./ 对于/ 同一个/ 事务/ 修改/ 的/ 同一个/ 数据项/ 的/ 所有/ 记录/ ,/ 选择/ 所有/ 记录/ 中/ 的/ 第一条/ 记录/ ./ 因为/ 日志/ 记录/ 是/ 顺序/ 添加/ 的/ ./ 而/ 一个/ 事务/ 对/ 某/ 一/ 数据项/ 不断/ 地/ 更改/ ,/ 就/ 不断/ 地/ 在/ 后面/ 添加/ 新/ 的/ 日志/ 记录/ ,/ 这/ 就/ 保证/ 了/ 其/ 第一次/ 保存/ 的/ 历史/ 版本/ 的/ 地址/ 恰好/ 就是/ 在/ 该/ 事务/ 修改/ 之前/ 的/ 数据项/ 的/ 值/ ./ 然后/ 根据/ 这些/ 日志/ 记录/ ,/ 恢复/ 管理器/ 读出/ 需要/ 恢复/ 的/ 各/ 数据项/ 的/ 历史/ 版本/ 的/ 地址/ ,/ 从/ 纸质/ 中/ 取出/ 其所存/ 的/ 数据/ ,/ 判断/ 是否/ 与/ 日志/ 记录/ 中存/ 的/ 旧值/ 相同/ ,/ 若/ 相同/ ,/ 将/ 已/ 写入/ 新/ 更新/ 数据/ 内容/ 的/ 地址/ 标识/ 为/ 无效/ ,/ 将/ 原/ 地址/ 标识/ 为/ 有效/ ,/ 并/ 将/ 原/ 地址/ 赋给/ 上层/ 索引/ 结构/ ,/ 从而/ 完成/ 恢复/ ;/ 若/ 不同/ ,/ 则/ 只有/ 重新/ 写入/ ./ 4HV/ -/ recovery/ 方法/ 的/ 改进/ 为了/ 进一步提高/ HV/ -/ recovery/ 的/ 性能/ 表现/ ,/ 在/ 本节/ 中/ ,/ 针对/ HV/ -/ recovery/ 中/ 还/ 存在/ 的/ 一些/ 问题/ 提供/ 了/ 一些/ 改进/ 的/ 方法/ ./ 4.1/ 设立/ 检查点/ 为了/ 减少/ 数据文件/ 和/ 日志/ 文件/ 对/ 存储空间/ 的/ 浪费/ ,/ 本文/ 采取/ 了/ 一种/ 周期性/ 设立/ 检查点/ 的/ 措施/ ,/ 来/ 有效/ 地/ 提高/ 空间/ 利用率/ ./ 4.1/ ./ 1/ 对于/ 日志/ 文件/ 的/ 操作/ 首先/ ,/ 可以/ 看出/ ,/ HV/ -/ recovery/ 中/ 的/ 日志/ 记录/ 的/ 更新/ 是/ 非常/ 频繁/ 的/ ,/ 随着/ 事务/ 的/ 不断/ 进行/ ,/ 需要/ 不断/ 地向/ 日志/ 文件/ 中/ 添加/ 新/ 的/ 日志/ 记录/ ,/ 而/ 随着/ 事务/ 的/ 不断/ 提交/ ,/ 又/ 使得/ 大量/ 的/ 日志/ 记录/ 变为/ 无效/ ./ 而/ 在/ 一般/ 情况/ 下/ ,/ 事务/ 的/ 回滚率/ 通常/ 不会/ 太/ 大/ ,/ 也就是说/ ,/ 其实/ 在/ 日志/ 文件/ 中/ 存在/ 着/ 大量/ 无效/ 的/ 日志/ 记录/ ,/ 而/ 这些/ 日志/ 记录/ 的/ 存在/ ,/ 增加/ 了/ 日志/ 文件/ 的/ 长度/ ,/ 也/ 占用/ 了/ 过/ 多/ 的/ 闪存/ 存储空间/ ./ 因此/ ,/ 在/ 检查/ 点中/ 采取/ 一种/ 最/ 简单/ 的/ 转移/ 操作/ ,/ 将/ 日志/ 文件/ 中尚/ 有效/ 的/ 日志/ 记录/ 进行/ 转移/ 并/ 进行/ 整合/ ./ 也就是说/ ,/ 在/ 设立/ 的/ 检查/ 点中/ ,/ 先/ 找到/ 一个/ 干净/ 的/ 块/ ,/ 然后/ 逐条/ 检查/ 每条/ 日志/ 记录/ 是否/ 有效/ ,/ 在/ 日志/ 记录/ 中/ 选出/ 尚/ 有效/ 的/ 记录/ ,/ 写入/ 到/ 新/ 的/ 空闲/ 块/ ,/ 当对/ 某/ 一旧/ 日志/ 块/ 上/ 的/ 所有/ 日志/ 记录/ 都/ 检查/ 过/ 一遍/ 后/ ,/ 就/ 对/ 该/ 旧块/ 进行/ 擦除/ ./ 通过/ 之前/ 的/ 介绍/ ,/ 可以/ 看出/ ,/ 实际/ 需要/ 转移/ 的/ 日志/ 记录/ 相对/ 于/ 大量/ 的/ 已经/ 提交/ 的/ 事务/ 的/ 日志/ 记录/ 而言/ ,/ 其/ 数量/ 是/ 相当/ 小/ 的/ ,/ 这样/ 其/ 转移/ 的/ 代价/ 也/ 是/ 可以/ 接受/ 的/ ./ 4.1/ ./ 2/ 对于/ 数据文件/ 的/ 操作/ 由于/ 我们/ 在/ 闪存/ 中/ 采取/ 异地/ 更新/ ,/ 因此/ ,/ 为了/ 显式/ 地/ 使用/ 历史/ 版本/ 的/ 数据/ ,/ 在/ 实现/ 时/ ,/ 在/ 存储设备/ 看来/ ,/ 我们/ 将/ 更新/ 操作/ 改为/ 了/ 插入/ ,/ 而/ 删除/ 操作/ 只是/ 记录/ 了/ 日志/ ,/ 并/ 没有/ 将/ 历史数据/ 删除/ ,/ 或/ 标识/ 为/ 无效/ ,/ 这样/ 虽然/ 防止/ 了/ 我们/ 将/ 需要/ 的/ 历史/ 版本/ 的/ 数据/ 进行/ 回收/ ,/ 但/ 同时/ 造成/ 了/ 系统/ 中有/ 过/ 多/ 的/ 历史数据/ ,/ 存储空间/ 大量/ 浪费/ ./ 因此/ ,/ 在/ 检查点/ 时/ ,/ 我们/ 会/ 在/ 对/ 日志/ 记录/ 进行/ 扫描/ 的/ 同时/ ,/ 将/ 无效/ 的/ 日志/ 记录/ 中/ 显示/ 为/ 应该/ 被/ 删除/ 或/ 替代/ 掉/ 的/ 数据/ 标识/ 为/ 无效/ ,/ 以便/ 让/ 垃圾/ 回收/ 机制/ 对/ 空间/ 进行/ 回收/ 管理/ ,/ 提高/ 空间/ 利用率/ ./ 4.1/ ./ 3/ 检查点/ 时间/ 间隔/ 设置/ 检查点/ 的/ 间隔时间/ 的/ 确定/ ,/ 是/ 与/ 闪存/ 中/ 日志/ 文件/ 的/ 大小/ 以及/ 闪存/ 的/ 总/ 存储空间/ 有关/ 的/ ./ 间隔时间/ 太短/ 会/ 因为/ 过多/ 的/ 擦除/ 操作/ 而/ 浪费时间/ ,/ 并/ 缩短/ 闪存/ 的/ 寿命/ ,/ 而/ 间隔时间/ 过长/ 又/ 会/ 浪费/ 存储空间/ ./ 因此/ ,/ 可以/ 根据/ 闪存/ 的/ 总/ 存储空间/ 设计/ 固定/ 的/ 可/ 接受/ 的/ 日志/ 文件/ 的/ 大小/ ./ 当/ 到达/ 某个/ 阈值/ 的/ 时候/ 就/ 设立/ 检查点/ 开始/ 进行/ 转移/ 操作/ ./ 同时/ ,/ 类似/ 于/ undo/ 日志/ 的/ 检查点/ ,/ 不但/ 可以/ 设立/ 静态/ 的/ 检查点/ ,/ 也/ 可以/ 设置/ 动态/ 的/ 检查点/ ./ 在/ 检查点/ 的/ 开始/ 阶段/ 保存/ 正在/ 活跃/ 的/ 事务/ 的/ ID/ ,/ 这样/ ,/ 就/ 可以/ 不必/ 等到/ 所有/ 事务/ 都/ 提交/ 完毕/ 后/ ,/ 再/ 设立/ 检查点/ ,/ 对/ 日志/ 文件/ 进行/ 转移/ ./ 并且/ 也/ 可以/ 在/ 数据库/ 负载量/ 较/ 小/ 的/ 时候/ 进行/ 检查点/ 的/ 日志/ 记录/ 转移/ 操作/ ,/ 从而/ 进一步/ 减少/ 系统/ 负担/ ./ 4.2/ 混合式/ 存储系统/ 另外/ ,/ 也/ 可以/ 看出/ ,/ HV/ -/ recovery/ 中/ 对/ 日志/ 记录/ 的/ 主要/ 操作/ 就是/ 一些/ 小/ 的/ 追加/ 写/ 操作/ 和/ 一些/ 擦除/ 操作/ ./ 而/ 由/ 之前/ 对/ 闪存/ 的/ 硬件/ 特性/ 的/ 介绍/ 可以/ 得知/ ,/ 这些/ 操作/ 对于/ 闪存/ 而言/ 是/ 非常/ 昂贵/ 的/ ./ 因此/ ,/ 可以/ 看出/ ,/ 日志/ 记录/ 其/ 本身/ 的/ 特点/ 是/ 不适/ 用于/ 闪存/ 的/ ./ 而/ 一般来说/ ,/ 基于/ 闪存/ 的/ 数据库/ 是/ 指/ 将/ 大量/ 的/ 对/ 其/ 操作/ 较/ 多/ 的/ 数据文件/ 保存/ 在/ 闪存/ 中/ ,/ 以/ 利用/ 其/ Page6/ 优越/ 的/ 读写/ 速度/ 来/ 提供/ 更好/ 的/ 数据库/ 性能/ ./ 而/ 当前/ 的/ 数据库/ 一般/ 都/ 支持/ 将/ 日志/ 文件/ 和/ 数据文件/ 分开/ 存储/ ,/ 因此/ ,/ 可以/ 考虑/ 在/ 存储/ 时/ 使用/ 混合式/ 系统/ ,/ 如图/ 2/ 所示/ ./ 将/ 数据/ 记录/ 存放/ 在/ 闪存/ 上/ ,/ 同时/ 将/ 并/ 不是/ 非常/ 适用/ 于/ 闪存/ 的/ 日志/ 记录/ 存放/ 在/ 磁盘/ 中/ ./ 通过/ 这样/ 的/ 设计/ ,/ 就/ 可以/ 在/ 不/ 增加/ 系统/ 恢复/ 算法/ 复杂度/ 的/ 同时/ ,/ 节约/ 大量/ 的/ 日志/ 记录/ 所/ 占用/ 的/ 闪存/ 空间/ ,/ 为/ 数据库系统/ 服务/ ./ 降低/ 了/ 数据库系统/ 搭建/ 的/ 成本/ 的/ 同时/ ,/ 从/ 整体/ 上/ 并/ 没有/ 影响/ 数据库系统/ 的/ 性能/ 表现/ ./ 5/ 实验/ 结果/ 及/ 分析/ 本章/ 通过/ 对/ HV/ -/ recovery/ 在/ 闪存/ 上/ 和/ 磁盘/ 上/ 的/ 实际/ 对比/ 实验/ ,/ 从/ 恢复/ 时/ 的/ 写/ 操作数/ 、/ 恢复/ 时间/ 等/ 方面/ 来/ 证明/ HV/ -/ recovery/ 的/ 优越性/ ./ 5.1/ 实验/ 环境/ 本文/ 设计/ 了/ 两个/ 实验/ 平台/ ,/ 其中/ 一个/ 的/ 存储设备/ 配置/ 了/ SSD/ ,/ 是/ 80GB/ 的/ IntelSSDSA2MH080G1GC/ ,/ 另/ 一个/ 配置/ 的/ 是/ 磁盘/ ,/ 是/ 250GB7200rpmST3250310AS/ ,/ 其中/ 有/ 8MB/ 的/ 缓存/ ./ 除此之外/ ,/ 两个/ 实验/ 平台/ 具有/ 相同/ 的/ 配置/ ,/ SSD/ 和/ 磁盘/ 都/ 是/ 通过/ SATA/ 接口/ 接入/ ./ CPU/ 是/ Intel/ (/ R/ )/ Core/ (/ TM/ )/ 2DuoCPUE8300/ @/ 2.83/ GHz/ ,/ 物理/ 内存/ 为/ 2GB/ ,/ 操作系统/ 是/ WindowsXPProfessional2002ServicePark2/ ./ 5.2/ 与/ 相关/ 工作/ 的/ 对比/ 与/ 分析/ 之前/ 的/ 介绍/ 中/ 提到/ ,/ IPL/ 主要/ 是/ 给出/ 一种/ 新型/ 的/ 存储/ 模式/ ,/ 以/ 提供/ 性能/ 较/ 高/ 的/ 对/ 数据库/ 的/ 操作/ ./ 它/ 所/ 提出/ 的/ 恢复/ 技术/ 主要/ 是/ 针对/ 这种/ 新/ 的/ 存储/ 方式/ 的/ 一种/ 扩展/ ,/ 因此/ ,/ IPL/ 不能/ 像/ HV/ -/ recovery/ 一样/ ,/ 方便/ 地/ 扩展/ 到/ 现有/ 的/ 大量/ 数据库/ 中/ ./ 同时/ ,/ IPL/ 的/ 存储/ 方式/ 是/ 针对/ 原始/ 的/ 闪存/ 存储器/ 的/ ,/ 而/ 不是/ 现在/ 被/ 简单/ 广泛/ 地/ 应用/ 在/ SSD/ 上/ ,/ 因此/ ,/ IPL/ 具有/ 相当/ 大/ 的/ 局限性/ ./ 同时/ ,/ 因为/ IPL/ 的/ 论文/ 中/ 并/ 没有/ 给出/ 针对/ 其/ 恢复/ 性能/ 的/ 实验/ 结果/ ,/ 并且/ ,/ 其/ 设计/ 思想/ 的/ 实现/ 必须/ 在/ 原始/ 的/ 闪存/ 存储器/ 上/ ,/ 而/ 论文/ 中/ 也/ 没有/ 对/ 其/ 实现/ 细节/ 进行/ 详细/ 的/ 阐述/ ,/ 这/ 就/ 对/ 我们/ 重现/ 其/ 工作/ 带来/ 了/ 较大/ 的/ 困难/ ,/ 难以/ 提供/ 定量/ 的/ 对比/ 结果/ ./ 另外/ ,/ FlashLogging/ 给出/ 在/ TPCC/ 执行/ 过程/ 中/ 突然/ 崩溃/ 需要/ 扫描/ 日志/ 记录/ 的/ 时间/ ,/ 大约/ 是/ 基于/ 磁盘/ 的/ 2/ // 3/ 左右/ ,/ 而/ HV/ -/ recovery/ 的/ 恢复/ 时间/ 是/ 基于/ 磁盘/ 的/ 1/ // 8/ 左右/ (/ 在/ 5.4/ 中会/ 详细/ 阐述/ )/ ./ 当然/ ,/ 两种/ 设计/ 的/ 实验/ 环境/ 和/ 对比/ 细节/ 不/ 完全相同/ ,/ 把/ 实验/ 结果/ 直接/ 进行/ 比较/ 不是/ 很/ 具有/ 说服力/ ./ 但是/ ,/ 由于/ FlashLogging/ 要求/ 搭建/ USB/ 阵列/ ,/ 我们/ 在/ 短时间/ 内较/ 难/ 重现/ ,/ 因此/ ,/ 我们/ 在/ 本文/ 中/ 难以/ 给出/ 直接/ 的/ 量化/ 比较/ ./ 但是/ ,/ 从/ 单纯/ 的/ 恢复/ 时间/ 的/ 比较/ ,/ 我们/ 至少/ 可以/ 相信/ ,/ HV/ -/ recovery/ 的/ 性能/ 表现/ 并/ 不会/ 比/ FlashLogging/ 的/ 表现/ 差/ ./ 5.3/ 恢复/ 时/ 的/ 写/ 操作数/ TPC/ 提供/ 了/ 一系列/ 系统/ 性能/ 的/ 压力/ 测试/ 标准/ ,/ 其中/ 的/ TPCC/ 通过/ 规定/ 数据库/ 原始数据/ 生成/ 以及/ 查询/ 负载/ 的/ 相关/ 指导/ 标准/ 来/ 模拟/ 了/ OLTP/ 的/ 处理/ 场景/ ,/ 是/ 数据库系统/ 事务处理/ 性能/ 的/ 标准/ 测试/ 集/ ./ TPCC/ 规定/ 了/ 在/ OLTP/ 中/ 典型/ 的/ 5/ 种/ 事务/ ,/ 包括/ New/ -/ Order/ 、/ Payment/ 、/ Order/ -/ Status/ 、/ Delivery/ 以及/ Stock/ -/ Level/ ,/ 在/ 下面/ 的/ 分析/ 计算/ 中/ ,/ 对/ 这些/ 事务/ 类型/ 分别/ 简称/ 为/ T1/ 、/ T2/ 、/ T3/ 、/ T4/ 、/ T5/ ./ 并且/ ,/ TPCC/ 模拟/ 实际/ 情况/ ,/ 设定/ 了/ 这/ 5/ 种/ 事务/ 各自/ 所/ 占/ 的/ 比例/ ,/ 分别/ 为/ 45/ %/ 、/ 43/ %/ 、/ 4/ %/ 、/ 4/ %/ 、/ 4/ %/ ,/ 不妨/ 将/ 这些/ 值用/ P1/ 、/ P2/ 、/ P3/ 、/ P4/ 、/ P5/ 表示/ ./ TPCC/ 还/ 根据/ 实际/ 情形/ 为/ 每/ 一种/ 事务/ 定义/ 了/ 一系列/ 的/ 插入/ 、/ 删除/ 和/ 更新/ 操作/ ,/ 不妨/ 把/ 每种/ 事务/ 需要/ 进行/ 的/ 操作数/ 记为/ N1/ 、/ N2/ 、/ N3/ 、/ N4/ 、/ N5/ ,/ 如表/ 3/ 所示/ ./ New/ -/ OrderT1P1/ =/ 45N1PaymentT2P2/ =/ 43N2Order/ -/ StatusT3P3/ =/ 4DeliveryT4P4/ =/ 4Stock/ -/ LevelT5P5/ =/ 4TPCC/ 模拟/ 了/ 大量/ 用户/ 同时/ 对系统/ 进行/ 并发/ 访问/ 的/ 模式/ ,/ 此处/ 设/ 存在/ 的/ 用户/ 并发/ 数为/ Nuser/ ./ 同时/ ,/ 容易/ 理解/ ,/ 在/ 任一/ 时刻/ ,/ 正在/ 并发/ 执行/ 的/ 事务/ 都/ 完成/ 了/ 其中/ 的/ 一部分/ ,/ 也就是说/ ,/ 每个/ 事务/ 都/ 有/ 一个/ 自己/ Page7/ 的/ 完成率/ ,/ 它/ 是/ 一个/ 从/ 0/ ~/ 100/ %/ 之间/ 的/ 一个/ 随机数/ ,/ 记为/ C/ ./ 因此/ ,/ 可以/ 知道/ ,/ 对/ 一次/ 有/ Nuser/ 个/ 并发/ 的/ TPCC/ 测试/ 而言/ ,/ 任一/ 时刻/ 系统/ 发生/ 崩溃/ ,/ 其/ 需要/ 恢复/ 的/ 数据量/ Nrecovery/ 为/ 其中/ 保证/ 对/ 每/ 一种/ 事务/ 的/ 相互/ 比例/ 满足/ TPCC/ 的/ 要求/ ,/ 也就是说/ ,/ T1T2T3T4T5/ =/ P1P2P3P4P5/ ./ 通过/ 之前/ 的/ 介绍/ 可以/ 看出/ ,/ 在/ 恢复/ 过程/ 中/ ,/ 对于/ 每/ 一个/ 需要/ 进行/ 恢复/ 的/ 数据项/ ,/ HV/ -/ recovery/ 都/ 可以/ 比/ 传统/ 的/ 恢复/ 方式/ 减少/ 一次/ 写/ 操作/ ,/ 也就是说/ ,/ HV/ -/ recovery/ 只/ 需要/ 2Nrecovery/ 个/ 写/ 操作/ 和/ Nrecovery/ 个读/ 操作/ 就/ 可以/ 完成/ 恢复/ ,/ 而/ 传统/ 的/ 恢复/ 方式/ 至少/ 需要/ 3Nrecovery/ 个/ 写/ 操作/ ./ 实验/ 结果/ 如图/ 3/ (/ a/ )/ 、/ (/ b/ )/ 所示/ ,/ 可以/ 发现/ ,/ 随着/ 并发/ 用户数/ 的/ 不断/ 增加/ ,/ 与/ 传统/ 的/ undo/ 日志/ 相比/ ,/ 在/ 数据库/ 恢复/ 阶段/ ,/ HV/ -/ recovery/ 可以/ 大量/ 地/ 减少/ 写/ 操作/ ./ 一般而言/ ,/ 在/ 并发/ 用户数/ 从/ 100/ 增加/ 到/ 10000/ 时/ ,/ HV/ -/ recovery/ 可以/ 减少/ 大约/ 有/ 400/ ~/ 37000/ 次/ 写/ 操作/ ./ 在/ 减少/ 写/ 操作/ 的/ 同时/ ,/ 也/ 节约/ 了/ 大量/ 的/ 闪存/ 空间/ ,/ 提高/ 了/ 闪存/ 的/ 空间/ 利用率/ ./ 同时/ ,/ 因为/ 写/ 操作/ 的/ 时间/ 代价/ 比较/ 大/ ,/ 从/ 理论/ 上/ 分析/ ,/ HV/ -/ recovery/ 可以/ 在/ 恢复/ 时/ 节省/ 大量/ 的/ 时间/ ./ 因此/ ,/ 我们/ 将/ HV/ -/ recovery/ 实现/ 到/ 现有/ 的/ 数据库/ 中/ ,/ 用/ 实验/ 结果/ 来/ 验证/ 其/ 可以/ 节省/ 大量/ 的/ 恢复/ 时间/ ./ 5.4/ 在/ BerkeleyDB/ 中/ 实现/ HV/ -/ recovery/ 为了/ 方便/ 地/ 将/ HV/ -/ recovery/ 在/ 现有/ 的/ 数据库/ 中/ 进行/ 实现/ ,/ 本文/ 选择/ 的/ 是/ 开源/ 的/ OracleBerkeleyDB/ 数据库/ ,/ 编程语言/ 为/ C语言/ ,/ 编译/ 环境/ 是/ MicrosoftVisualStudio2005/ ,/ 硬件/ 环境/ 如/ 5.1/ 节/ 所述/ ./ 在/ 实验/ 中/ ,/ 在/ 开始/ 后/ 不断/ 地/ 对/ 数据库/ 中/ 的/ 内容/ 进行/ 各种/ 操作/ ,/ 然后/ ,/ 再/ 显式/ 地/ 对/ 事务/ 回滚/ ,/ 即/ 进行/ 恢复/ 操作/ ,/ 并/ 记录/ 恢复/ 所/ 耗费/ 的/ 时间/ ,/ 其/ 结果/ 如图/ 4/ 所示/ ./ 由/ 实验/ 结果/ 可以/ 看出/ ,/ HV/ -/ recovery/ 相比/ 于/ 传统/ 的/ 基于/ 磁盘/ 的/ 数据库/ 有/ 明显/ 的/ 优越性/ ./ 能够/ 大幅度/ 的/ 减少/ 恢复/ 时间/ ./ 并且/ 随着/ 数据量/ 的/ 不断/ 增加/ ,/ 这种/ 优越性/ 也/ 越来越/ 明显/ ./ 在/ 较/ 小/ 的/ 数据量/ 时/ ,/ 如图/ 4/ (/ a/ )/ 所示/ ,/ 使用/ 传统/ 数据库/ 恢复/ 技术/ 所用/ 的/ 恢复/ 时间/ 平均/ 是/ 使用/ HV/ -/ recovery/ 进行/ 恢复/ 的/ 2/ ~/ 3/ 倍/ ,/ 而/ 数据量/ 不断/ 增大/ 时/ ,/ HV/ -/ recovery/ 的/ 优势/ 也/ 成倍增加/ ./ 如图/ 4/ (/ b/ )/ 所示/ ,/ 最好/ 情况/ 下/ ,/ 基于/ 磁盘/ 上/ 的/ 传统/ 数据库/ 的/ 恢复/ 时间/ 是/ HV/ -/ recovery/ 恢复/ 时间/ 的/ 8.3/ 倍/ ,/ 充分体现/ 了/ HV/ -/ recovery/ 的/ 优越性/ ./ 而且/ ,/ 与/ 将/ 传统/ 的/ 数据库/ 直接/ 移到/ SSD/ 上/ 的/ 情况/ 相比/ ,/ HV/ -/ recovery/ 也/ 体现/ 了/ 较大/ 的/ 优势/ ./ 一般而言/ ,/ 在/ SSD/ 上/ ,/ HV/ -/ recovery/ 要/ 比/ BerkeleyDB/ 中/ 传统/ 的/ undo/ 日志/ 的/ 方法/ 要/ 提高/ 20/ %/ ,/ 而/ 随着/ 数据量/ 的/ 增大/ ,/ 这种/ 优势/ 也/ 体现/ 的/ 更为/ 明显/ ,/ 如图/ 4/ (/ b/ )/ 所示/ ,/ 某些/ 情况/ 下/ ,/ HV/ -/ recovery/ 要/ 比/ BerkeleyDB/ 中/ Page8/ 传统/ 的/ undo/ 日志/ 的/ 方法/ 要/ 提高/ 38/ %/ ,/ 能/ 很/ 好/ 地/ 体现/ HV/ -/ recovery/ 的/ 优越性/ ./ 6/ 结论/ 闪存/ 即将/ 取代/ 磁盘/ 成为/ 下一代/ 主流/ 的/ 二级/ 存储器/ ,/ 但/ 由于/ 其/ 特有/ 的/ 物理/ 特性/ ,/ 目前/ 基于/ 磁盘/ 设计/ 的/ 恢复/ 技术/ 不能/ 充分/ 地/ 利用/ 闪存/ 的/ 优越性/ ./ 为此/ ,/ 本文/ 提出/ 了/ 一种/ 新颖/ 的/ 具有/ 较/ 高性能/ 的/ 恢复/ 方式/ HV/ -/ recovery/ ./ HV/ -/ recovery/ 对/ 闪存/ 中/ 天然/ 存在/ 的/ 数据/ 的/ 历史/ 版本/ 使用/ version/ _/ list/ 结构/ 加以/ 管理/ 和/ 利用/ ,/ 提供/ 高效/ 的/ 恢复/ ./ 通过/ 周期性/ 设立/ 检查点/ ,/ 减小/ 无效/ 日志/ 记录/ 的/ 长度/ ,/ 节约/ 闪存/ 空间/ ./ 引入/ 混合式/ 存储系统/ ,/ 将/ 日志/ 记录/ 单独/ 存放/ 在/ 磁盘/ 上/ ,/ 以便/ 对/ 闪存/ 数据库/ 的/ 恢复/ 性能/ 进一步提高/ ./ 同时/ 也/ 保证/ 了/ 算法/ 具有/ 在/ 数据库/ 正常/ 运行/ 时有/ 较/ 小/ 的/ 开支/ 、/ 算法/ 有/ 比较/ 强/ 的/ 可靠性/ 、/ 系统/ 失败/ 后/ 恢复/ 速度/ 快/ 和/ 日志/ 文件/ 的/ 空间/ 需求/ 较/ 小/ 等/ 优势/ ./ 通过/ 针对/ TPCC/ 的/ 分析/ 及/ 和/ 开源/ 数据库/ OracleBerkeleyDB/ 的/ 对比/ 实验/ 看出/ ,/ HV/ -/ recovery/ 比/ 传统/ 数据库/ 的/ 恢复/ 时/ 的/ 写/ 操作数/ 可以/ 减少/ 接近/ 一半/ ,/ 其/ 恢复/ 时间/ 与/ 传统/ 数据库/ 相比/ ,/ 能/ 缩短/ 到/ 原来/ 的/ 大约/ 1/ // 8/ ,/ 与/ 在/ SSD/ 上/ 的/ 传统/ 数据库/ 相比/ ,/ 也/ 可以/ 缩短/ 40/ %/ ,/ 充分/ 显示/ 了/ 本/ 算法/ 的/ 优越性/ ./ 

