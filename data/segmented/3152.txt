Page1DBCC/ -/ Join/ :/ 一种/ 新/ 的/ 高速缓存/ 敏感/ 的/ 磁盘/ 连接/ 算法/ 韩希先/ 1/ )/ 杨/ 东华/ 2/ )/ 李建中/ 1/ )/ 1/ )/ (/ 哈尔滨工业大学/ 计算机科学/ 与/ 技术/ 学院/ 哈尔滨/ 150001/ )/ 2/ )/ (/ 哈尔滨工业大学/ 基础/ 与/ 交叉科学/ 研究院/ 高性能/ 计算中心/ 哈尔滨/ 150001/ )/ 摘要/ 随着/ CPU/ 和/ 内存/ 的/ 性能/ 差距/ 越来越/ 大/ ,/ 系统/ 设计者/ 在/ CPU/ 寄存器/ 和/ 内存/ 之间/ 插入/ 高速缓存/ 来/ 弥补/ 这个/ 差距/ ./ 高速缓存/ 的/ 数据/ 存取速度/ 远高于/ 内存/ ,/ 所以/ 数据库/ 操作/ 要/ 获得/ 更好/ 的/ 性能/ 就/ 必须/ 考虑/ 充分利用/ 高速缓存/ ./ 基于/ 磁盘/ 的/ 连接/ 操作/ 是/ 一种/ 常用/ 并且/ 耗时/ 的/ 数据库/ 查询/ 操作/ ,/ 可是/ 大多数/ 传统/ 的/ 连接/ 算法/ 在/ 设计/ 时/ 都/ 没有/ 考虑/ 高速缓存/ 的/ 使用/ ,/ 从而/ 使得/ 这些/ 连接/ 算法/ 无法/ 充分利用/ CPU/ 的/ 能力/ ./ 文中/ 分析/ 了/ 传统/ 的/ 连接/ 算法/ 在/ 高速缓存/ 利用/ 方面/ 的/ 问题/ ,/ 并且/ 提出/ 了/ 一种/ 新/ 的/ 可以/ 充分利用/ 高速缓存/ 的/ 磁盘/ 连接/ 算法/ DBCC/ -/ Join/ ./ 连接/ 位置/ 索引/ 对表/ JPIPT/ 是/ 用到/ 的/ 数据结构/ ,/ 说明/ 了/ 每个/ 连接/ 结果/ 元组/ 在/ 各自/ 表中/ 的/ 位置/ 索引/ 对/ ./ DBCC/ -/ Join/ 的/ 执行/ 包括/ 两个/ 阶段/ :/ JPIPT/ 构建/ 阶段/ 和/ 结果/ 输出/ 阶段/ ./ JPIPT/ 构建/ 阶段/ 对列/ 存储/ 化/ 的/ 连接/ 属性/ 执行/ 高速缓存/ 敏感/ 的/ 算法/ 来/ 构建/ 连接/ 位置/ 索引/ 对表/ ./ 利用/ 获得/ 的/ JPIPT/ ,/ 结果/ 输出/ 阶段/ 只/ 需要/ 对/ 数据表/ 执行/ 一遍/ 顺序/ 扫描/ 就/ 可以/ 获得/ 结果/ ./ 该文/ 是/ 第一篇/ 提出/ 利用/ 高速缓存/ 的/ 磁盘/ 连接/ 算法/ 的/ 文章/ ./ 实验/ 表明/ ,/ 和/ 传统/ 磁盘/ 连接/ 算法/ 相比/ ,/ DBCC/ -/ Join/ 算法/ 可以/ 获得/ 一个/ 数量级/ 的/ 加速/ 比/ ./ 关键词/ DBCC/ -/ Join/ ;/ JPIPT/ 构建/ 阶段/ ;/ 结果/ 输出/ 阶段/ ;/ 缓存/ 敏感/ 算法/ 1/ 引言/ 摩尔定律/ 预测/ CPU/ 的/ 处理速度/ 每/ 18/ 个/ 月/ 增长/ 一倍/ ,/ 主存/ 的/ 存取速度/ 也/ 有/ 类似/ 的/ 定律/ ,/ 可是/ 其/ 增长速度/ 却/ 比/ CPU/ 的/ 要/ 慢得/ 多/ (/ 每/ 6/ 年/ 提高/ 一倍/ )/ ./ 如图/ 1/ 所示/ [/ 1/ ]/ ,/ 这/ 使得/ CPU/ 和/ 内存/ 之间/ 的/ 性能/ 差异/ 越来越/ 大/ (/ 每/ 21/ 个/ 月/ 差距/ 增大/ 一倍/ )/ ./ 系统/ 设计者/ 在/ CPU/ 寄存器/ 和/ 主存/ 之间/ 插入/ 高速缓存/ 来/ 弥补/ 这个/ 差距/ ./ 高速缓存/ 的/ 数据/ 存取速度/ 远高于/ 内存/ ,/ 如果/ 数据/ 存储/ 在/ 高速缓存/ 中/ ,/ 引用/ 该/ 数据/ 需要/ 几个/ CPU/ 时钟/ 周期/ ;/ 如果/ 数据/ 存储/ 在/ 主存/ ,/ 则/ 需要/ 几十个/ 甚至/ 几百个/ 时钟/ 周期/ 才/ 可以/ 访问/ 该/ 数据/ ./ 所以/ ,/ 数据库/ 操作/ 要/ 获得/ 更好/ 的/ 性能/ ,/ 就/ 必须/ 考虑/ 充分利用/ 高速缓存/ [/ 2/ ]/ ./ 连接/ 操作/ 是/ 一种/ 常用/ 的/ 关系数据库/ 查询/ 操作/ ,/ 它/ 可以/ 根据/ 公共信息/ 将/ 两个/ 或/ 多个/ 表/ 的/ 元组/ 组合/ 起来/ ./ 连接/ 操作/ 也/ 是/ 数据库/ 操作/ 中/ 最/ 耗时/ 的/ 操作/ 之一/ ,/ 其/ 性能/ 直接/ 影响/ 着/ 数据库/ 的/ 整体/ 性能/ ./ 连接/ 操作/ 已经/ 得到/ 了/ 广泛/ 和/ 深入/ 的/ 研究/ [/ 3/ ]/ ,/ 并且/ 已经/ 提出/ 了/ 一些/ 经典/ 的/ 连接/ 算法/ :/ nested/ -/ loop/ 方法/ 、/ Sort/ -/ merge/ 连接/ 方法/ 和/ 基于/ hash/ 的/ 连接/ 方法/ ./ 大多数/ 传统/ 的/ 连接/ 算法/ 在/ 设计/ 时/ 没有/ 考虑/ 高速缓存/ 的/ 使用/ ,/ 从而/ 使得/ 这些/ 连接/ 算法/ 无法/ 充分利用/ CPU/ 的/ 能力/ [/ 4/ -/ 5/ ]/ ./ 现有/ 的/ 研究/ 工作/ 提出/ 了/ 新/ 的/ 利用/ 高速缓存/ 的/ 内存/ 连接/ 算法/ [/ 6/ ]/ ,/ 可是/ 这些/ 方法/ 只/ 适用/ 于/ 内存/ 数据库/ ./ 而/ 在/ 实际/ 应用/ 中/ ,/ 用户/ 需要/ 更/ 多/ 的/ 是/ 基于/ 磁盘/ 的/ 连接/ 操作/ ./ 本文/ 分析/ 了/ 传统/ 磁盘/ 连接/ 算法/ 在/ 高速缓存/ 利用/ 中/ 存在/ 的/ 问题/ ,/ 并且/ 提出/ 一种/ 新/ 的/ 高速缓存/ 敏感/ 的/ 磁盘/ 连接/ 算法/ DBCC/ -/ Join/ (/ Disk/ -/ BasedCache/ -/ Con/ -/ sciousJoin/ )/ ./ 该/ 算法/ 解决/ 了/ 现有/ 连接/ 算法/ 的/ 低/ 缓存/ 利用率/ 问题/ ./ 在/ 本文/ 中/ ,/ 数据表/ 根据/ 列/ 存储/ 模式/ 维护/ ./ 连接/ 位置/ 索引/ 对表/ JPIPT/ (/ JoinPositionalIndexPairTable/ )/ 是/ DBCC/ -/ Join/ 用到/ 的/ 数据结构/ ,/ 说明/ 了/ 每个/ 连接/ 结果/ 元组/ 在/ 各自/ 数据表/ 中/ 的/ 位置/ 索引/ 对/ ./ DBCC/ -/ Join/ 的/ 执行/ 分为/ 两个/ 阶段/ :/ JPIPT/ 构建/ 阶段/ JCS/ (/ JPIPTConstructionStage/ )/ 和/ 结果/ 输出/ 阶段/ ROS/ (/ ResultOutputStage/ )/ ./ JCS/ 类似/ 于/ 普通/ 的/ 连接/ 操作/ ,/ 可是/ 该/ 阶段/ 只/ 处理/ 连接/ 属性/ ./ 本文/ 提出/ 一种/ 缓存/ 敏感/ 的/ 构建/ 算法/ 来/ 快速/ 构建/ JPIPT/ ./ ROS/ 的/ 执行/ 包括/ 3/ 个/ 连续/ 操作/ :/ JPIPT/ 划分/ 、/ 外/ 关系/ 扫描/ 和/ 内/ 关系/ 扫描/ ./ 我们/ 设计/ 了/ 元组/ 抽取/ 算法/ 来/ 保证/ 只/ 需要/ 对/ 关系/ 表/ 执行/ 一次/ 顺序/ 扫描/ 就/ 可以/ 获得/ 结果/ ./ 本文/ 还/ 提供/ 了/ DBCC/ -/ Join/ 算法/ 的/ 正确性/ 证明/ ./ 需要/ 注意/ 的/ 是/ ,/ JCS/ 要求/ 连接/ 属性/ 列/ 存储/ 化/ ,/ 可是/ 在/ ROS/ 中/ ,/ 只要/ 存储/ 模型/ 支持/ 利用/ 位置/ 索引/ 来/ 抽取/ 元组/ ,/ DBCC/ -/ Join/ 就/ 可以/ 应用/ 于/ 该/ 存储/ 模型/ ./ 这/ 实际上/ 包括/ 了/ 目前/ 的/ 所有/ 存储/ 模型/ (/ 行/ 存储/ 和/ 列/ 存储/ )/ ./ 本文/ 作者/ 设计/ 了/ 较/ 全面/ 的/ 实验/ 分别/ 从/ 元组/ 数量/ 、/ 表/ 宽度/ 、/ 输出/ 属性/ 数量/ 和/ 连接/ 选择/ 度/ 4/ 个/ 方面/ 来/ 评价/ DBCC/ -/ Join/ 的/ 性能/ ./ 实验/ 表明/ ,/ 和/ 传统/ 磁盘/ 连接/ 算法/ 相比/ ,/ DBCC/ -/ Join/ 算法/ 可以/ 获得/ 一个/ 数量级/ 的/ 加速/ 比/ ./ 本文/ 的/ 主要/ 贡献/ 如下/ :/ (/ 1/ )/ 本文/ 分析/ 了/ 传统/ 磁盘/ 连接/ 算法/ 在/ 高速缓存/ 利用/ 中/ 存在/ 的/ 问题/ ,/ 提出/ 一种/ 新/ 的/ 高速缓存/ 敏感/ 的/ 磁盘/ 连接/ 算法/ DBCC/ -/ Join/ ./ 据/ 我们/ 所知/ ,/ 本文/ 是/ 第一篇/ 提出/ 利用/ 高速缓存/ 的/ 磁盘/ 连接/ 算法/ 的/ 文章/ ./ (/ 2/ )/ 本文/ 提出/ 一种/ 高速缓存/ 敏感/ 的/ JPIPT/ 构建/ 算法/ 来/ 获得/ 连接/ 位置/ 索引/ 对表/ ./ (/ 3/ )/ 利用/ 获得/ 的/ JPIPT/ ,/ 本文/ 提出/ 元组/ 抽取/ 算法/ 只/ 需要/ 对/ 数据表/ 执行/ 一遍/ 顺序/ 扫描/ 来/ 获得/ 结果/ ,/ 并且/ 提供/ 理论/ 分析/ 证明/ 了/ 算法/ 的/ 正确性/ ./ (/ 4/ )/ 本文/ 通过/ 较/ 全面/ 的/ 实验/ 来/ 评价/ DBCC/ -/ Join/ 的/ 性能/ ./ 实验/ 结果表明/ ,/ 和/ 传统/ 的/ 磁盘/ 连接/ 算法/ 相比/ ,/ DBCC/ -/ Join/ 算法/ 可以/ 获得/ 一个/ 数量级/ 的/ 加速/ 比/ ./ 本文/ 第/ 2/ 节/ 介绍/ 高速缓存/ 结构/ ;/ 第/ 3/ 节/ 分析/ 传统/ Join/ 算法/ 在/ 利用/ 高速缓存/ 方面/ 的/ 问题/ ;/ DBCC/ -/ Join/ 算法/ 在/ 第/ 4/ 节中/ 详细描述/ ;/ 第/ 5/ 节是/ 性能/ 评价/ 部分/ ;/ 相关/ 工作/ 和/ 结论/ 分别/ 在/ 第/ 6/ 和/ 第/ 7/ 节中/ 给出/ ./ 2/ 高速缓存/ 结构/ 计算机/ 读取数据/ 的/ 顺序/ 是/ 先/ 查看/ 需要/ 的/ 数据/ 是否/ 在/ 寄存器/ ,/ 如果/ 不/ 在/ 就/ 继续/ 检查/ 是否/ 在/ 高速缓存/ ,/ 如果/ 也/ 不/ 在/ 就/ 继续/ 检查/ 是否/ 在/ 内存/ 和/ 磁盘/ ./ 如果/ Page3CPU/ 请求/ 的/ 数据/ 存储/ 在/ 高速缓存/ ,/ 称为/ 缓存/ 命中/ (/ cachehit/ )/ ,/ 否则/ 称为/ 缓存/ 不/ 命中/ (/ cachemiss/ )/ ./ 高速缓存/ 包括/ L1/ 高速缓存/ 和/ L2/ 高速缓存/ ./ 本文/ 主要/ 考虑/ L2/ 高速缓存/ ,/ 因为/ L2cache/ 比/ L1cache/ 要/ 大得多/ ,/ 并且/ L1datacachemiss/ 对/ 性能/ 的/ 影响/ 要远/ 小于/ L2datacachemiss/ 的/ 影响/ [/ 5/ ]/ ./ 图/ 2/ 表示/ 了/ 存储器/ 的/ 层次结构/ ./ 高速缓存/ 由/ 昂贵/ 的/ 静态/ RAM/ 构成/ ,/ 所以/ 其/ 容量/ 一般/ 不/ 大/ ,/ 一个/ 桌面/ 系统/ 的/ 高速缓存/ 一般/ 不会/ 超过/ 几/ M/ 字节/ ./ 高速缓存/ 被/ 划分/ 成/ 一组/ 固定/ 大小/ 的/ 高速缓存/ 行/ (/ cacheline/ )/ ,/ 其/ 大小/ 在/ 16/ ~/ 256/ 字节/ ./ 当/ 高速缓存/ 从/ 主存/ 中/ 读取数据/ 时/ ,/ 即使/ 只/ 需要/ 一个/ 字节/ ,/ 高速缓存/ 也/ 会/ 从/ 主存/ 中/ 读取/ 可以/ 填满/ 整个/ cacheline/ 的/ 数据/ ./ 如果/ 计算机程序/ 具有/ 较/ 好/ 的/ 局部性/ ,/ 即/ 程序/ 倾向/ 于/ 访问/ 相同/ 的/ 数据项/ 集合/ ,/ 或者/ 倾向/ 于/ 访问/ 临近/ 的/ 数据项/ 集合/ ,/ 则/ 系统/ 就/ 可以/ 很/ 好/ 地/ 利用/ 缓存/ 来/ 提高/ 程序/ 的/ 性能/ ./ 与/ 主存/ 和/ 磁盘/ 不同/ ,/ 人们/ 无法/ 直接/ 利用软件/ 来/ 控制/ 哪些/ 数据/ 放置/ 到/ 高速缓存/ ,/ 因为/ 高速缓存/ 是/ 由/ 硬件/ 控制/ 的/ ./ 所以/ 要/ 充分利用/ 高速缓存/ ,/ 我们/ 的/ 程序/ 就/ 必须/ 具有/ 良好/ 的/ 局部性/ ,/ 根据/ 高速缓存/ 的/ 数据/ 读取/ 特点/ 来/ 设计/ 程序/ 操作/ ./ 本文/ 我们/ 主要/ 考虑/ 如何/ 利用/ 缓存/ 来/ 提高/ 磁盘/ 连接/ 操作/ 的/ 性能/ ./ 3/ 当前/ 连接/ 算法/ 利用/ 高速缓存/ 的/ 问题/ 连接/ 操作/ 是/ 数据库系统/ 中/ 的/ 一个/ 重要/ 并且/ 耗时/ 的/ 操作/ ,/ 其/ 性能/ 对于/ 整个/ 数据库系统/ 的/ 性能/ 有着/ 很大/ 的/ 影响/ ./ 人们/ 提出/ 了/ 很多/ 的/ 连接/ 算法/ :/ nested/ -/ loopjoin/ 、/ sort/ -/ mergejoin/ 和/ hashjoin/ 算法/ 等/ ./ Hashjoin/ 由于/ 其较/ 好/ 的/ 性能/ 更/ 多/ 地被/ 人们/ 所/ 采用/ ,/ 所以/ 本文/ 以/ hashjoin/ 为/ 例来/ 讨论/ 连接/ 算法/ ./ 本文/ 讨论/ 的/ hashjoin/ 的/ 形式/ 是/ GRACEhashjoin/ [/ 3/ ]/ ,/ 一方面/ 因为/ GRACEjoin/ 具有/ 严格/ 区分/ 的/ 划分/ 阶段/ 和/ 连接/ 阶段/ ,/ 方便/ 我们/ 对/ 性能/ 的/ 分析/ ,/ 另一方面/ 由于/ 我们/ 处理/ 的/ 数据量/ 较大/ ,/ hybridhashjoin/ [/ 3/ ]/ 和/ GRACEhashjoin/ 的/ 性能/ 差距/ 不大/ ./ 本节/ 中/ ,/ 我们/ 分析/ hashjoin/ 算法/ 在/ 利用/ 高速缓存/ 方面/ 存在/ 的/ 问题/ ./ (/ 1/ )/ Tuple/ -/ oriented/ 处理/ 模式/ ./ 当前/ 主流/ 数据库/ 采用/ 行/ 存储/ 模式/ ,/ 同一/ 元组/ 的/ 数据/ 连续/ 存储/ ,/ 并且/ 采用/ tuple/ -/ oriented/ 处理/ 模式/ ./ 在/ 执行/ 查询处理/ 时/ ,/ tuple/ -/ at/ -/ a/ -/ time/ 迭代/ 器/ 每次/ 读取/ 一个/ 元组/ ,/ 提供/ 给/ 上层/ 的/ 关系/ 操作符/ 进行/ 处理/ ./ 假设/ 高速缓存/ 的/ cacheline/ 大小/ 是/ Wcl/ ,/ 关系/ 的/ 元组/ 宽度/ 是/ Wtuple/ ,/ 在/ tuple/ -/ at/ -/ a/ -/ time/ 迭代/ 器/ 模型/ 下/ ,/ 高速缓存/ 读取/ tuple/ 的/ 过程/ 如图/ 3/ 所示/ ./ 高速缓存/ 每次/ 执行/ 主存/ 读时/ ,/ 会/ 同时/ 获得/ Wcl/ 字节/ 的/ 数据/ 放入/ cacheline/ ,/ 加快/ 接下来/ 的/ 读取/ 操作/ ./ 所以/ ,/ 执行/ 一次/ 内存/ 读/ ,/ 高速缓存/ 会/ 读取/ Wcl/ // Wtuple/ 个/ 元组/ ./ 典型/ 的/ cacheline/ 大小/ 是/ 64/ 字节/ ,/ 而/ 数据表/ 的/ 属性/ 数量/ 一般/ 都/ 较大/ ,/ 几十个/ 属性/ 的/ 数据表/ 是/ 很/ 常见/ 的/ ./ 一般来说/ Wcl/ </ Wtuple/ ,/ 使得/ 每次/ 读取/ 下/ 一个/ 元组/ 都/ 需要/ 执行/ 主存/ 读/ 操作/ ,/ 所以/ tuple/ -/ oriented/ 处理/ 模型/ 并/ 没有/ 很/ 好/ 地/ 利用/ 高速缓存/ ./ (/ 2/ )/ 较大/ 的/ 内/ 关系/ 块/ ./ Hashjoin/ 划分/ 阶段/ 把/ 内/ 关系/ 划分/ 成/ 多个/ 块/ ,/ 使得/ 每个/ 块/ 都/ 小于/ 内存/ 的/ 容量/ ,/ 再/ 对外/ 关系/ 执行/ 相应/ 的/ 划分/ ,/ 划分/ 后内/ 关系/ 的/ 每个/ 块/ 通常/ 比/ 高速缓存/ 大得多/ ./ 内/ 关系/ 构建/ Hash/ 表/ 完毕/ 后/ ,/ 外/ 关系/ 的/ 元组/ 开始/ 探测/ Hash/ 表以/ 得到/ 连接/ 结果/ ./ 内/ 关系/ 构建/ Hash/ 表时/ ,/ 为/ 保证/ 外/ 关系/ 探测/ Hash/ 表/ 的/ 效率/ ,/ Hash/ 表/ 的/ 桶/ 数/ 较大/ ./ 由于/ Hash/ 函数/ 的/ 随机性/ 以及/ 较大/ 的/ 内/ 关系/ 块/ ,/ 当前/ 的/ 内/ 关系/ 元组/ 映射/ 到/ 的/ Hash/ 桶/ 所在/ 的/ 数据/ 页/ 一般/ 不/ 在/ 高速缓存/ ,/ 即/ 每次/ 内/ 关系/ 元组/ 插入/ Hash/ 表/ 的/ 操作/ 通常/ 引起/ 内存/ 读/ ./ 同样/ ,/ 在外/ 关系/ 探测/ 阶段/ ,/ 被/ 探测/ 桶/ 所在/ 的/ 数据/ 页/ 一般/ 也/ 不/ 在/ 高速缓存/ 中/ ,/ 从而/ 使得/ 每次/ 探/ Page4/ 测/ Hash/ 表/ 的/ 操作/ 都/ 会/ 引起/ 一个/ 内存/ 读/ ./ 基于/ 同样/ 的/ 原因/ ,/ hashjoin/ 的/ Hash/ 表/ 构建/ 和/ 探测/ 过程/ 中/ ,/ 当前/ 需要/ 读取/ 的/ 数据/ 页/ 很/ 可能/ 没有/ 存储/ 在/ TLB/ (/ 翻译/ 后备/ 缓冲器/ ,/ 存储/ 最近/ 处理/ 过/ 的/ 64/ 个/ 虚拟/ 页/ -/ 物理/ 页/ 地址/ 影射/ ,/ 如果/ 当前/ 请求/ 的/ 虚拟/ 页/ 地址/ 转换/ 没有/ 存储/ 在/ TLB/ ,/ 则/ 说/ 发生/ 一次/ TLBmiss/ 操作/ )/ ,/ 从而/ 使得/ 每次/ 主存/ 读写操作/ 还/ 需要/ 执行/ 虚拟/ 页/ -/ 物理/ 页/ 地址/ 转换/ ,/ 进一步/ 增加/ 了/ 其/ 执行/ 费用/ ./ 我们/ 知道/ ,/ 具有/ 良好/ 局部性/ 的/ 程序/ 比/ 局部性/ 差/ 的/ 程序运行/ 得/ 更/ 快/ ./ 局部性/ 通常/ 有/ 两种/ 形式/ :/ 时间/ 局部性/ 和/ 空间/ 局部性/ ./ 时间/ 局部性/ 指/ 的/ 是/ 重复/ 引用/ 相同/ 的/ 数据项/ 集合/ ,/ 而/ 空间/ 局部性/ 指/ 的/ 是/ 倾向/ 于/ 引用/ 当前/ 访问/ 数据/ 附近/ 的/ 数据项/ 集合/ ./ 很/ 明显/ ,/ 连接/ 操作/ 不/ 具有/ 良好/ 的/ 时间/ 局部性/ ,/ 因为/ 它/ 处理/ 完/ 一个/ 元组/ 后/ 就/ 继续/ 处理/ 下/ 一个/ 元组/ ./ 我们/ 利用/ 步长/ 为/ k/ 的/ 引用/ 模式/ 来/ 讨论/ 空间/ 局部性/ ,/ 具有/ 步长/ 为/ k/ 的/ 引用/ 模式/ 指/ 的/ 是/ 顺序/ 访问/ 连续/ 空间/ 第/ k/ 个/ 字节/ 的/ 数据/ ,/ k/ 表示/ 跳过/ 的/ 字节数/ ./ 步长/ 越小/ ,/ 则/ 空间/ 局部性/ 就/ 越/ 好/ ,/ 在/ 存储器/ 中以/ 大步/ 长/ 访问/ 不同/ 位置/ 的/ 数据/ 的/ 程序/ 不/ 具有/ 良好/ 的/ 空间/ 局部性/ ./ 处理/ 每个/ 元组/ 时/ ,/ 连接/ 操作/ 具有/ 步长/ 为/ Wtuple/ 的/ 访问/ 模式/ ,/ Wtuple/ 的/ 值/ 一般/ 较大/ ,/ 则/ 关系/ 的/ 顺序/ 扫描/ 操作/ 不/ 具有/ 良好/ 的/ 空间/ 局部性/ ./ Hash/ 函数/ 的/ 随机性/ 以及/ 较大/ 的/ 内/ 关系/ 块/ 使得/ 构建/ 和/ 探测/ Hash/ 表/ 具有/ 较大/ 的/ 步长/ ,/ 所以/ 构建/ 和/ 探测/ Hash/ 表/ 的/ 操作/ 不/ 具有/ 良好/ 的/ 空间/ 局部性/ ./ 总的来看/ ,/ 现有/ 的/ hashjoin/ 算法/ 不/ 具有/ 良好/ 的/ 局部性/ ,/ 从而/ 无法/ 充分利用/ 高速缓存/ 的/ 能力/ ./ 下/ 一节/ 中/ ,/ 我们/ 提出/ 一种/ 新/ 的/ 高速缓存/ 敏感/ 的/ 磁盘/ 连接/ 算法/ DBCC/ -/ Join/ ,/ 该/ 算法/ 可以/ 充分利用/ 高速缓存/ 以/ 提高/ 磁盘/ 连接/ 操作/ 的/ 性能/ ./ 4DBCC/ -/ Join/ 算法/ 通过/ 分析/ ,/ 我们/ 知道/ 传统/ 连接/ 算法/ 较/ 低/ 的/ 高速缓存/ 利用率/ 的/ 主要/ 原因/ 在于/ :/ 较大/ 的/ 引用/ 步长/ 和/ 较大/ 的/ 内/ 关系/ 分片/ ./ DBCC/ -/ Join/ 通过/ 减少/ 引用/ 步长/ 和/ 内/ 关系/ 分片/ 大小/ 的/ 方法/ 来/ 获得/ 较/ 好/ 的/ 高速缓存/ 利用率/ ./ 减小/ 引用/ 步长/ 的/ 一个/ 方法/ 是/ 不/ 采用/ 面向/ 元组/ 的/ 处理/ 模式/ ,/ DBCC/ -/ Join/ 算法/ 采用/ 列/ 存储/ 策略/ [/ 7/ ]/ 存储/ 关系/ ,/ 关系/ 不是/ 一行行/ 地/ 连续/ 存储/ ,/ 而是/ 把/ 关系/ 的/ 每个/ 属性/ 的/ 值/ 顺序存储/ 到/ 单独/ 的/ 文件/ ./ 采用/ 列/ 存储/ 的/ 好处/ 不但/ 可以/ 减小/ 扫描/ 操作/ 的/ 引用/ 步长/ ,/ 在/ 查询处理/ 阶段/ ,/ 还/ 可以/ 只/ 处理/ 相关/ 的/ 属性/ ,/ 而/ 忽略/ 其他/ 的/ 属性/ ./ DBCC/ -/ Join/ 的/ 执行/ 分为/ 两个/ 阶段/ :/ JPIPT/ 构建/ 阶段/ (/ 4.1/ 节/ )/ 和/ 结果/ 输出/ 阶段/ (/ 4.2/ 节/ )/ ./ 4.1/ 节/ 介绍/ 如何/ 利用/ 高速缓存/ 来/ 快速/ 构建/ JPIPT/ ./ 利用/ 获得/ 的/ JPIPT/ ,/ 4.2/ 节/ 介绍/ 了/ 如何/ 获得/ 最终/ 的/ 连接/ 结果/ ./ 4.1/ JPIPT/ 构建/ 阶段/ JCS/ (/ JPIPTConstructionStage/ )/ 假设/ T1/ 和/ T2/ 是/ 参与/ 连接/ 操作/ 的/ 数据表/ ./ 在/ 执行/ 阶段/ ,/ T1/ 作为/ 外/ 关系/ 而/ T2/ 作为/ 内/ 关系/ ./ 用户/ 提交/ 的/ 查询/ Q/ 的/ 形式/ 为/ “/ selectattribute/ -/ listfromT1/ ,/ T2whereT1/ ./ key/ =/ T2/ ./ key/ ”/ ./ 我们/ 首先/ 给出/ 本文/ 用到/ 的/ 一些/ 定义/ ./ 定义/ 1/ (/ 位置/ 索引/ )/ ./ 给定/ 表/ T/ ,/ 元组/ t/ ∈/ T/ 的/ 位置/ 索引/ PI/ (/ PositionalIndex/ )/ 是/ i/ ,/ 如果/ t/ 是/ T/ 的/ 第/ i/ 个/ 元组/ ./ 我们/ 用/ T/ (/ i/ )/ 来/ 表示/ 表/ T/ 中/ 位置/ 索引/ 为/ i/ 的/ 元组/ ./ 定义/ 2/ (/ 连接/ 位置/ 索引/ 对表/ )/ ./ 给定/ 表/ T1/ 和/ T2/ ,/ T1/ ./ key1/ 和/ T2/ ./ key2/ 分别/ 是/ T1/ 和/ T2/ 的/ 连接/ 属性/ ,/ T1/ / / T2/ 包括/ N/ 个/ 结果/ ,/ JPIPT/ 是/ T1/ / / T2/ 的/ 连接/ 位置/ 索引/ 对表/ ,/ 如果/ JPIPT/ 满足条件/ :/ (/ 1/ )/ |/ JPIPT/ |/ =/ N/ ,/ (/ 2/ )/ / i/ ,/ j/ ,/ (/ PI1/ :/ i/ ,/ PI2/ :/ j/ )/ ∈/ JPIPT/ ,/ 当且/ 仅/ 当/ T1/ (/ i/ )/ ./ key1/ =/ T2/ (/ j/ )/ ./ key2/ ./ 在/ 本文/ 中/ ,/ 我们/ 把/ JPIPT/ 看作/ 具有/ 两个/ 属性/ (/ PI1/ ,/ PI2/ )/ 的/ 表/ ./ DBCC/ -/ Join/ 把/ T1/ 和/ T2/ 的/ 连接/ 属性/ 存储/ 为/ 两个/ 独立/ 的/ 列/ 文件/ :/ C1/ 和/ C2/ ./ 每个/ 列/ 文件/ 都/ 包含/ 一个/ 隐含/ 的/ 属性/ :/ PI/ ./ C1/ 和/ C2/ 的/ 模式/ 可以/ 分别/ 看作/ C1/ (/ key1/ ,/ PI1/ )/ 和/ C2/ (/ key2/ ,/ PI2/ )/ ,/ 其中/ ,/ key1/ 和/ key2/ 分别/ 是/ T1/ 和/ T2/ 的/ 连接/ 属性/ ,/ PI1/ 和/ PI2/ 分别/ 表示/ key1/ 和/ key2/ 在/ 表/ T1/ 和/ T2/ 的/ 位置/ 索引/ ./ JPIPT/ 的/ 构建/ 操作/ 就是/ 执行/ 如下/ 的/ 连接/ 操作/ :/ “/ selectPI1/ ,/ PI2fromC1/ ,/ C2whereC1/ ./ key1/ =/ C2/ ./ key2/ ”/ ./ 传统/ 的/ 磁盘/ hashjoin/ 并/ 没有/ 考虑/ 高速缓存/ ,/ 从而/ 导致/ 了/ 较/ 低/ 的/ 高速缓存/ 和/ CPU/ 利用率/ ./ 本文/ 提出/ 高速缓存/ 敏感/ 的/ JPIPT/ 构建/ 算法/ C3/ -/ JPIPT/ 算法/ (/ Cache/ -/ ConsciousConstructionofJPIPT/ )/ ,/ 该/ 算法/ 充分利用/ 高速缓存/ 来/ 更/ 快/ 地/ 构建/ JPIPT/ ,/ 其/ 执行/ 过程/ 如/ 算法/ 1/ [/ 8/ ]/ 所示/ ./ 注意/ :/ 本文/ 涉及/ 的/ 所有/ 算法/ 的/ 伪/ 代码/ 都/ 包含/ 在/ 文献/ [/ 8/ ]/ 中/ ./ C3/ -/ JPIPT/ 的/ 执行/ 包括/ 两个/ 步骤/ :/ 划分/ 和/ 连接/ ./ 划分/ 把/ 每个/ 表/ 划分/ 成/ Np1/ =/ 2/ ×/ (/ Sc1/ +/ Sc2/ )/ {/ C1i/ }/ 和/ {/ C2i/ }/ (/ 1/ / i/ / Np1/ )/ ./ 其中/ ,/ SC1/ 和/ SC2/ 分别/ 表示/ 列/ 文件/ C1/ 和/ C2/ 的/ 大小/ ,/ M/ 表示/ C3/ -/ JPIPT/ 利用/ 的/ 内存容量/ ./ C3/ -/ JPIPT/ 产生/ 比/ 传统/ Hash/ 连接/ 操作/ 更/ 多/ 的/ 分片/ 数量/ ,/ 这/ 是因为/ 该/ 算法/ 的/ 连接/ 阶段/ 要求/ 同时/ 把/ 内/ 关系/ 和/ 外/ 关系/ 的/ 单个/ 子表/ 对/ 读入/ 内存/ ./ 在/ 划分/ 时/ ,/ C3/ -/ JPIPT/ 实例/ 化/ 每个/ 元组/ 的/ 位置/ 索引/ 值/ ./ 注意/ :/ 如果/ 和/ 外/ 关系/ 相比/ ,/ 内/ 关系/ 非常/ 小/ ,/ 那么/ JCS/ 就/ 采用/ 传统/ 的/ 连接/ 算法/ 而/ 不是/ C3/ -/ JPIPT/ ./ Page5/ 当/ C3/ -/ JPIPT/ 进入/ 连接/ 操作/ 时/ ,/ 每/ 一对/ 子表/ C1i/ 和/ C2i/ 依次/ 读入/ 内存/ ,/ 并且/ 划分/ 为/ Np2/ =/ SC2iC/ 个/ 分片/ ,/ 使得/ 每个/ 内/ 关系/ 子表/ 的/ 分片/ 可以/ 放入/ 高速缓存/ ./ 其中/ ,/ SC2i/ 表示/ 读入/ 内存/ 的/ 内/ 关系/ 子表/ 大小/ ,/ C/ 表示/ 高速缓存/ 的/ 大小/ ./ 如果/ Np2/ >/ 64/ ,/ 则/ 该/ 划分/ 操作/ 采用/ 多轮/ 划分/ 方法/ 来/ 减少/ TLBmiss/ ./ 每/ 一轮/ 划分/ 的/ 分片/ 数量/ 少于/ 64/ ,/ 并且/ 前/ 一轮/ 获得/ 的/ 分片/ 进一步/ 划分/ 成/ 多个/ 子/ 分片/ ./ 该/ 过程/ 继续执行/ 直到/ 获得/ 的/ 分片/ 数量/ 达到/ Np2/ ./ C3/ -/ JPIPT/ 采用/ 的/ 多轮/ 划分/ 方法/ 类似/ 于/ Radix/ -/ cluster/ 算法/ [/ 6/ ]/ ./ 经过/ 第二次/ 的/ 划分/ ,/ C1i/ 和/ C2i/ 分别/ 被/ 划分/ 为/ 两个/ 含有/ Np2/ 个/ 分片/ 的/ 集合/ ./ Hash/ 连接/ 操作/ 在/ C1i/ 和/ C2i/ 的/ 每个/ 分片/ 对/ 上/ 执行/ ./ 因为/ 当前/ 的/ 内/ 关系/ 的/ 分片/ 可以/ 放入/ 高速缓存/ ,/ 所以/ 构建/ 和/ 探测/ Hash/ 表/ 的/ 操作/ 都/ 可以/ 在/ 高速缓存/ 中/ 执行/ ./ C1i/ 和/ C2i/ 的/ 第/ j/ 分片/ 对/ 的/ 连接/ 结果/ 是/ 第/ j/ 分片/ 对/ 对应/ 的/ 连接/ 位置/ 索引/ 对表/ JPIPTij/ ./ 我们/ 在/ 内存/ 中/ 维护/ JPIPTij/ 以/ 方便/ 接下来/ 的/ 操作/ ./ 定理/ 1/ ./ 产生/ 的/ JPIPTij/ 根据/ PI1/ 域/ 排序/ ./ 证明/ ./ / k1/ ,/ k2/ (/ k1/ </ k2/ )/ ,/ (/ PI1/ :/ mk1/ ,/ PI2/ :/ nk1/ )/ ∈/ JPIPTij/ ,/ (/ PI1/ :/ mk2/ ,/ PI2/ :/ nk2/ )/ ∈/ JPIPTij/ ./ 假设/ 在/ JPIPTij/ 中/ ,/ (/ PI1/ :/ mk1/ ,/ PI2/ :/ nk1/ )/ 的/ 出现/ 要/ 早于/ (/ PI1/ :/ mk2/ ,/ PI2/ :/ nk2/ )/ ./ 这/ 意味着/ ,/ 读取/ T1/ (/ mk1/ )/ 的/ 时间/ 不能/ 晚于/ 读取/ T1/ (/ mk2/ )/ 的/ 时间/ ./ 已知/ 在/ 连接/ 操作/ 中/ ,/ T1/ 作为/ 外/ 关系/ ,/ 并且/ T1/ 的/ 元组/ 按/ 顺序/ 读取/ 来/ 探测/ Hash/ 表/ ,/ 所以/ mk1/ / mk2/ ./ C1i/ 和/ C2i/ 的/ 连接/ 操作/ 产生/ Np2/ 个/ 连接/ 位置/ 索引/ 对表/ ./ 根据/ 定理/ 1/ ,/ 每个/ JPIPTij/ 根据/ PI1/ 域/ 排序/ ./ 我们/ 利用/ 一次/ 多路/ 合并/ 排序/ 操作/ 来/ 合并/ JPIPTij/ (/ 1/ / j/ / Np2/ )/ 获得/ JPIPTi/ ,/ JPIPTi/ 输出/ 到/ 磁盘/ ./ 类似/ 的/ 操作/ 在/ 每个/ C1i/ 和/ C2i/ (/ 1/ / i/ / Np1/ )/ 上/ 执行/ ,/ 获得/ Np1/ 个/ JPIPTi/ 文件/ ./ 此时/ ,/ 再/ 一次/ 执行/ 多路/ 合并/ 排序/ 来/ 合并/ JPIPTi/ (/ 1/ / i/ / Np1/ )/ 获得/ 最终/ 的/ JPIPT/ ./ 4.2/ 结果/ 输出/ 阶段/ ROS/ (/ ResultOutputStage/ )/ (/ PI1/ :/ i/ ,/ PI2/ :/ j/ )/ ∈/ JPIPT/ 意味着/ T1/ (/ i/ )/ 和/ T2/ (/ j/ )/ 满足/ 连接/ 条件/ ./ 利用/ JPIPT/ ,/ 一个/ 直观/ 的/ 输出/ 结果/ 的/ 想法/ 是/ 根据/ PI1/ 和/ PI2/ 域/ 的/ 值/ ,/ 抽取/ 表/ T1/ 和/ T2/ 的/ 指定/ 位置/ 索引/ 的/ 元组/ ,/ 分别/ 存储/ 到/ 文件/ R1/ 和/ R2/ ./ R1/ 和/ R2/ 中/ 具有/ 相同/ 的/ 新/ 位置/ 索引/ (/ Ri/ 的/ 第一个/ 元组/ 具有/ 新/ 位置/ 索引/ 1/ )/ 的/ 元组/ 对/ 构成/ 一个/ 连接/ 元组/ ./ 这个/ 想法/ 比较简单/ ,/ 可是/ 其/ 效率/ 却/ 较/ 低/ ./ JPIPT/ 的/ PI1/ 域/ 是/ 排序/ 的/ ,/ 对/ T1/ 的/ 一次/ 顺序/ 扫描/ 就/ 可以/ 获得/ 需要/ 的/ T1/ 元组/ ./ 可是/ ,/ JPIPT/ 的/ PI2/ 域/ 却/ 不是/ 排序/ 的/ ,/ 根据/ PI2/ 的/ 域/ 指定/ 的/ 位置/ 索引/ 来/ 抽取/ T2/ 元组/ 会/ 引起/ 大量/ 的/ 磁盘/ seek/ 操作/ ,/ 执行/ 效率/ 较/ 低/ ./ 在/ 本节/ 讨论/ 时/ 用到/ 的/ 参数/ 定义/ 如表/ 1/ 所示/ ./ 在/ 结果/ 输出/ 阶段/ 中/ ,/ 有/ 3/ 个/ 步骤/ 顺序/ 执行/ :/ JPIPT/ 划分/ 、/ 外/ 关系/ 扫描/ 和/ 内/ 关系/ 扫描/ ./ JPIPT/ 划分/ 过程/ 把/ JPIPT/ 划分/ 为/ 多个/ 分片/ 来/ 保证/ 外/ 关系/ 扫描/ 和/ 内/ 关系/ 扫描/ 的/ 内存/ 需求/ ./ 外/ 关系/ 扫描/ 利用/ PI1/ 域来/ 抽取/ T1/ 元组/ ,/ 内/ 关系/ 扫描/ 则/ 利用/ PI2/ 域来/ 抽取/ T2/ 元组/ ,/ 当然/ 只/ 返回/ attribute/ -/ list/ 涉及/ 到/ 的/ 属性/ ./ 接下来/ ,/ 我们/ 依次/ 介绍/ 3/ 个/ 步骤/ 的/ 执行/ 过程/ ./ 符号/ SJPIPTSJTST24/ ./ 2.1/ JPIPT/ 划分/ JP/ (/ JPIPTPartition/ )/ 在/ DBCC/ -/ Join/ 中/ ,/ 外/ 关系/ 扫描/ 要求/ 每个/ JPIPT/ 分片/ 可以/ 放入/ 内存/ ,/ 内/ 关系/ 扫描/ 则/ 要求/ 每个/ JPIPT/ 分片/ 和/ 对应/ 的/ T2/ 元组/ 都/ 可以/ 放入/ 内存/ ./ JP/ 独立/ 地/ 把/ JPIPT/ 划分/ 成/ 两个/ 不同/ 的/ 分片/ 集合/ :/ PS1/ 和/ PS2/ ./ 其中/ PS1/ 包括/ m/ =/ SJPIPTM/ 个/ 分片/ ,/ PS2/ 包括/ n/ =/ SJPIPT/ +/ N/ ×/ ST2M/ 个/ 分片/ ./ PS1/ 的/ 第/ k/ 个/ 元素/ PS1/ (/ k/ )/ {/ (/ i/ ,/ j/ )/ :/ (/ i/ ,/ j/ )/ ∈/ JPIPT/ ,/ i/ ∈/ [/ PI1k/ -/ 1/ ,/ PI1k/ ]/ ,/ PI1k/ =/ k/ ×/ N1m/ ,/ 1/ / k/ / }/ m/ ./ [/ PI1k/ -/ 1/ ,/ PI1k/ ]/ 是/ T1/ 的/ 位置/ 索引/ 的/ 一个/ 连续/ 子/ 范围/ (/ 为/ 方便/ 讨论/ ,/ 假设/ T1/ 和/ T2/ 的/ 连接/ 属性/ 在/ 其/ 值域/ 内/ 均匀分布/ )/ ./ [/ PI1k/ -/ 1/ ,/ PI1k/ ]/ 满足/ / i/ ,/ j/ (/ i/ ≠/ j/ )/ ,/ [/ PI1i/ -/ 1/ ,/ PI1i/ ]/ ∩/ [/ PI1j/ -/ 1/ ,/ PI1j/ ]/ =/ / ,/ ∪/ mi/ =/ 1/ [/ PI1i/ -/ 1/ ,/ PI1i/ ]/ =/ [/ 1/ ,/ N1/ ]/ ./ 类似/ 的/ ,/ PS2/ 的/ kth/ 元素/ PS2/ (/ k/ )/ {/ =/ (/ i/ ,/ j/ )/ :/ (/ i/ ,/ j/ )/ ∈/ JPIPT/ ,/ i/ ∈/ [/ PI2k/ -/ 1/ ,/ PI2k/ ]/ ,/ PI2k/ =/ k/ ×/ N2n/ ,/ 1/ / k/ / n/ }/ )/ ,/ [/ PI2k/ -/ 1/ ,/ PI2k/ ]/ 是/ T2/ 位置/ 索引/ 的/ 一个/ 连续/ 子/ 范围/ ./ [/ PI2k/ -/ 1/ ,/ PI2k/ ]/ 满足/ / i/ ,/ j/ (/ i/ ≠/ j/ )/ ,/ [/ PI2i/ -/ 1/ ,/ PI2i/ ]/ ∩/ [/ PI2j/ -/ 1/ ,/ PI2j/ ]/ =/ / ,/ ∪/ ni/ =/ 1/ [/ PI2i/ -/ 1/ ,/ PI2i/ ]/ =/ [/ 1/ ,/ N2/ ]/ ./ JPIPT/ 划分/ 过程/ 的/ 子/ 范围/ 划分/ 如图/ 4/ 所示/ ./ JPIPT/ 构建/ 阶段/ 最后/ 的/ 多路/ 合并/ 排序/ 操作/ 和/ JPIPT/ 划分/ 操作/ 结合/ 为/ 连续/ 的/ 操作/ ,/ 从而/ 节省/ Page6JPIPT/ 的/ 一次/ 读/ 和/ 一次/ 写/ 操作/ ./ JPIPT/ 划分/ 只/ 需要/ 对/ JPIPT/ 进行/ 一次/ 扫描/ 就/ 可以/ 把/ JPIPT/ 元组/ 分配/ 到/ 对应/ 的/ PS1/ 和/ PS2/ 元素/ 中/ ,/ 其/ 执行/ 过程/ 如/ 算法/ 2/ [/ 8/ ]/ 所示/ ,/ 该/ 过程/ 具有/ 步长/ 为/ 8/ 的/ 引用/ 模式/ ./ 4.2/ ./ 2/ 外/ 关系/ 扫描/ ORS/ (/ Outer/ -/ RelationScan/ )/ 这部分/ 介绍/ 如何/ 利用/ PS1/ 来/ 抽取/ T1/ 元组/ ./ 在/ ORS/ 过程/ 中/ ,/ PS1/ 从/ 第一个/ 元素/ PS1/ (/ 1/ )/ 开始/ 遍历/ ./ 根据/ 定义/ ,/ PS1/ (/ 1/ )/ 中/ PI1/ 的/ 值/ 在/ 范围/ [/ PI10/ ,/ PI11/ ]/ ,/ 并且/ 根据/ PI1/ 的/ 值/ 排序/ ./ ORS/ 从/ 涉及/ 的/ T1/ 表/ 的/ 起始/ 位置/ 开始/ 扫描/ ,/ 抽取/ PS1/ (/ 1/ )/ 中/ PI1/ 值/ 指定/ 的/ T1/ 元组/ ./ 注意/ ,/ 获得/ 的/ 结果/ 元组/ 不是/ 输出/ 到/ 单个/ 文件/ ,/ 而是/ 根据/ 该/ 元组/ 对应/ 的/ JPIPT/ 元组/ 的/ PI2/ 值/ 输出/ 到/ n/ 个/ 文件/ 的/ 某/ 一个/ 文件/ ./ 给定/ JPIPT/ 元组/ (/ PI1/ ,/ PI2/ )/ 指定/ 的/ T1/ 元组/ t/ ,/ 如果/ PI2/ ∈/ [/ PI2j/ -/ 1/ ,/ PI2j/ ]/ ,/ 元组/ t/ 输出/ 到/ 文件/ file1/ _/ 1/ _/ j/ (/ 1/ / j/ / n/ )/ )/ ./ 继续/ 遍历/ PS1/ 的/ 元素/ ,/ 得到/ PS1/ (/ 2/ )/ 的/ 数据/ ./ 根据/ PS1/ 的/ 划分/ 规则/ ,/ PS1/ (/ 2/ )/ 中/ 的/ PI1/ 的/ 值/ 在/ 范围/ [/ PI11/ ,/ PI12/ ]/ ./ / i0/ ,/ i1/ ,/ j0/ ,/ j1/ ,/ (/ i0/ ,/ j0/ )/ ∈/ PS1/ (/ 1/ )/ ,/ (/ i1/ ,/ j1/ )/ ∈/ PS1/ (/ 2/ )/ ,/ 则/ 必然/ 有/ i0/ / i1/ ./ 所以/ ORS/ 可以/ 从/ 当前/ T1/ 的/ 偏移/ 位置/ 继续/ 扫描/ ,/ 而/ 不/ 需要/ 重新/ 从头开始/ 扫描/ ./ 该/ 处理过程/ 类似/ 于/ 对/ PS1/ (/ 1/ )/ 的/ 讨论/ ,/ 根据/ 对应/ 的/ JPIPT/ 元组/ 的/ PI2/ 值/ ,/ T1/ 元组/ 输出/ 到/ 对应/ 文件/ file1/ _/ 2/ _/ j/ (/ 1/ / j/ / n/ )/ )/ ./ 该/ 过程/ 继续执行/ 直到/ PS1/ 的/ 元素/ 都/ 处理完毕/ ./ 图/ 5/ 给出/ 了/ ORS/ 的/ 一个/ 示例/ ./ 此时/ ,/ 我们/ 获得/ 一组/ 文件/ FS1/ =/ {/ file1/ _/ i/ _/ j/ ,/ 1/ / i/ / m/ ,/ 1/ / j/ / n/ }/ ./ ORS/ 的/ 执行/ 过程/ 如/ 算法/ 3/ [/ 8/ ]/ 所示/ ./ ORS/ 执行/ 采用/ 批量/ 读写/ 机制/ ,/ 当/ 需要/ 读取/ 连续/ 的/ 大块/ 数据/ 时/ ,/ 每次/ 读/ 操作/ 不是/ 读取/ 单个/ 元组/ ,/ 而是/ 一次性/ 读取/ 多个/ 数据/ 块/ ,/ 从而/ 分摊/ 了/ 磁盘/ 寻道/ 和/ 旋转/ 时间/ ./ 但是/ ,/ 当/ 一次性/ 读取/ 的/ 数据/ 块/ 增长/ 到/ 一定/ 程度/ 的/ 时候/ ,/ 批量/ 读取/ 带来/ 的/ 增量/ 收益/ 就/ 会/ 变得/ 很小/ ./ 根据/ 实验/ 的/ 机器配置/ ,/ 本文/ 的/ 批量/ 读/ 操作/ 一次性/ 读取/ 4/ 个/ 数据/ 块/ ./ 类似/ 的/ ,/ 每个/ 输出/ 文件维护/ 一个/ 输出/ 缓冲区/ ,/ 当该/ 缓冲区/ 满/ 的/ 时候/ 才/ 真正/ 执行/ 磁盘/ 写/ 操作/ ./ 4.2/ ./ 3/ 内/ 关系/ 扫描/ IRS/ (/ Inner/ -/ RelationScan/ )/ 这部分/ 介绍/ 如何/ 利用/ PS2/ 来/ 抽取/ T2/ 元组/ ./ 由于/ JPIPT/ 的/ PI2/ 域/ 不是/ 排序/ 的/ ,/ 所以/ IRS/ 的/ 执行/ 过程/ 比/ ORS/ 更加/ 复杂/ ./ 在/ IRS/ 过程/ 中/ ,/ PS2/ 从/ 第一个/ 元素/ PS2/ (/ 1/ )/ 开始/ 遍历/ ./ 根据/ 定义/ ,/ PS2/ (/ 1/ )/ 中/ PI2/ 的/ 值/ 在/ 范围/ [/ PI20/ ,/ PI21/ ]/ ./ 要/ 对/ T2/ 执行/ 顺序/ 扫描/ 来/ 获得/ 结果/ 元组/ ,/ PS2/ (/ 1/ )/ 先/ 根据/ PI2/ 的/ 值/ 执行/ 一次/ 排序/ 操作/ ./ 因为/ PS2/ (/ 1/ )/ 的/ 大小/ 通常/ 都/ 要/ 大大/ 超过/ 高速缓存/ 的/ 容量/ ,/ 并且/ 常用/ 的/ 排序/ 算法/ 具有/ 较大/ 的/ 引用/ 步长/ ,/ 本文/ 提出/ 一种/ 新/ 的/ 缓存/ 敏感/ 的/ 排序/ 算法/ C2/ -/ Sort/ 来/ 更/ 快/ 地/ 完成/ 排序/ 操作/ ,/ 其/ 执行/ 代码/ 如/ 算法/ 4/ [/ 8/ ]/ 所示/ ./ C2/ -/ Sort/ 的/ 基本/ 思想/ 是/ :/ 不同于/ 一次性/ 对大/ 数据/ 块/ 执行/ 排序/ 操作/ ,/ 我们/ 先/ 把/ 数据/ 块/ 划分/ 成/ 多个/ 子块/ ,/ 使得/ 每个/ 子块/ 可以/ 放入/ 高速缓存/ ,/ 然后/ 依次/ 对/ 每个/ 子块/ 执行/ 排序/ 操作/ ,/ 最后/ 利用/ 一次/ 多路/ 归并/ 排序/ 来/ 合并/ 排好序/ 的/ 子块/ ./ 在/ 每/ 一个/ 执行/ 步骤/ 中/ ,/ C2/ -/ Sort/ 都/ 可以/ 较/ 好/ 地/ 利用/ 高速缓存/ 从而/ 获得/ 较/ 好/ 的/ 性能/ ./ 我们/ 排序/ PS2/ (/ 1/ )/ 的/ 方法/ 不是/ 一次性/ 把/ 它/ 读入/ 内存/ ,/ 而是/ 每次/ 读入/ C/ // SJT/ 个/ JPIPT/ 元组/ 并且/ 对/ 这些/ 元组/ 执行/ 排序/ ./ 排好序/ 的/ 元组/ 在/ 内存/ 中/ 维护/ ./ 该/ 过程/ 持续/ 进行/ 直到/ 所有/ 的/ PS2/ (/ 1/ )/ 的/ 数据/ 都/ 读入/ 内存/ ,/ 此时/ 一次/ 合并/ 操作/ 就/ 可以/ 把/ 排好序/ 的/ 子块/ 合并/ 为/ 单个/ 排好序/ 的/ PS2/ (/ 1/ )/ ./ PS2/ (/ 1/ )/ 排序/ 完毕/ 后/ ,/ IRS/ 从/ 涉及/ 的/ T2/ 表/ 的/ 起始/ 位置/ 开始/ 扫描/ ,/ 因为/ 此时/ PI2/ 的/ 值/ 是/ 排序/ 的/ ,/ 所以/ 顺序/ 扫描/ 足够/ 抽取/ PS2/ (/ 1/ )/ ./ PI2/ 指定/ 的/ T2/ 元组/ ./ IRS/ 在/ 内存/ 中/ 缓存/ 获得/ 的/ 元组/ ./ 当/ 所有/ 的/ PS2/ (/ 1/ )/ 指定/ 的/ T2/ 元组/ 都/ 获得/ 后/ ,/ IRS/ 利用/ C2/ -/ Sort/ 根据/ PS2/ (/ 1/ )/ :/ PI1/ 对/ 缓存/ 的/ T2/ 元组/ 执行/ 第二次/ 排序/ 操作/ ,/ 来/ 保证/ 结果/ 的/ 正确性/ (/ 正确性/ 证明/ 在/ 4.2/ ./ 4/ 节/ )/ ./ 每个/ 排好序/ 的/ T2/ 元组/ 根据/ 对应/ 的/ JPIPT/ 元组/ 的/ PI1/ 的/ 值来/ 决定/ 输出/ 到/ m/ 个/ 文件/ 中/ 的/ 某/ 一个/ ./ 如果/ PI1/ 的/ 值/ 落入/ 范围/ [/ PI1i/ -/ 1/ ,/ PI1i/ ]/ ,/ 则/ 对应/ 的/ T2/ 元组/ 输出/ 到/ 文件/ file2/ _/ i/ _/ 1/ (/ 1/ / i/ / m/ )/ ./ 继续/ 遍历/ PS2/ 的/ 元素/ ,/ 得到/ PS2/ (/ 2/ )/ 的/ 数据/ ./ 根据/ 定义/ ,/ PS2/ (/ 2/ )/ 中/ 的/ PI2/ 的/ 值/ 在/ 范围/ [/ PI21/ ,/ PI22/ ]/ ./ Page7/ / i0/ ,/ i1/ ,/ j0/ ,/ j1/ ,/ (/ i0/ ,/ j0/ )/ ∈/ PS2/ (/ 1/ )/ ,/ (/ i1/ ,/ j1/ )/ ∈/ PS2/ (/ 2/ )/ ,/ 则/ 必然/ 有/ j0/ / j1/ ./ 所以/ IRS/ 可以/ 从/ 当前/ T2/ 的/ 偏移/ 位置/ 继续/ 扫描/ ,/ 而/ 不/ 需要/ 重新/ 从头开始/ 扫描/ ,/ 该/ 处理过程/ 类似/ 于/ 对/ PS2/ (/ 1/ )/ 的/ 讨论/ ,/ 此时/ 连接/ 结果/ 根据/ 对应/ 的/ JPIPT/ 元组/ 的/ PI1/ 值/ 输出/ 到/ 文件/ file2/ _/ i/ _/ 2/ (/ 1/ / i/ / m/ )/ ./ IRS/ 的/ 执行/ 过程/ 见/ 文献/ [/ 8/ ]/ 算法/ 5/ ./ 该/ 过程/ 继续执行/ 直到/ PS2/ 的/ 元素/ 都/ 处理完毕/ ./ 我们/ 获得/ 一组/ 文件/ FS2/ =/ {/ file2/ _/ i/ _/ j/ ,/ 1/ / i/ / m/ ,/ 1/ / j/ / n/ }/ ./ 此时/ ,/ ROS/ 阶段/ 执行/ 完毕/ ./ 我们/ 获得/ m/ ×/ n/ 对/ 文件/ :/ file1/ _/ i/ _/ j/ 和/ file2/ _/ i/ _/ j/ (/ 1/ / i/ / m/ ,/ 1/ / j/ / n/ )/ ,/ 在/ 每/ 对/ 文件/ 中/ ,/ 具有/ 相等/ 的/ 新/ 位置/ 索引/ 的/ 元组/ 构成/ 连接/ 操作/ 的/ 结果/ 元组/ ./ 4.2/ ./ 4/ 正确性/ 证明/ 这部分/ 证明/ ROS/ 的/ 正确性/ ./ 我们/ 首先/ 证明/ 定理/ 2/ 的/ 正确性/ ./ 在/ 定理/ 2/ 中/ ,/ 没有/ 内存/ 限制/ 的/ ROS/ 不/ 包括/ JPIPT/ 划分/ 阶段/ ,/ 即/ m/ =/ 1/ 和/ n/ =/ 1/ ./ 定理/ 2/ ./ 没有/ 内存/ 限制/ 的/ ROS/ 生成/ 的/ 结果/ 是/ 正确/ 的/ ./ 证明/ ./ 假设/ BUF/ _/ T1/ 保存/ ORS/ 操作/ 获得/ 的/ T1/ 元组/ ,/ BUF/ _/ T2/ 保存/ IRS/ 操作/ 获得/ 的/ 没有/ 经过/ 第二次/ 排序/ 的/ T2/ 元组/ ./ JPIPT/ 的/ PI1/ 域/ 的/ 数据/ 可以/ 看图/ 6/ 定理/ 2/ 证明/ 实例/ 由于/ PI1/ 和/ PI2/ 根据/ 各自/ 范围/ 进行/ 划分/ ,/ PS1/ 和/ PS2/ 的/ 元素/ 不/ 存在/ 直接/ 的/ 关系/ ./ 我们/ 用/ 矩阵/ 犛来/ 构建/ PS1/ 和/ PS2/ 的/ 元素/ 之间/ 的/ 联系/ ,/ 犛的/ 第/ i/ 行/ 对应/ 于/ PS1/ (/ i/ )/ ,/ 犛的/ 第/ j/ 列/ 对应/ 于/ PS2/ (/ j/ )/ ,/ 犛/ (/ r/ ,/ c/ )/ =/ {/ (/ i/ ,/ j/ )/ :/ (/ i/ ,/ j/ )/ ∈/ JPIPT/ ,/ i/ ∈/ [/ PI1r/ -/ 1/ ,/ PI1r/ ]/ ,/ j/ ∈/ [/ PI2c/ -/ 1/ ,/ PI2c/ ]/ ,/ 1/ / r/ / m/ ,/ 1/ / c/ / n/ }/ ./ 注意/ ,/ 犛并/ 没有/ 像/ PS1/ 和/ PS2/ 那样/ 被/ 实例/ 化/ ,/ 只是/ 虚拟/ 地/ 维护/ 指定/ 数据/ 的/ 范围/ ./ 定理/ 3/ ./ ROS/ 生成/ 的/ 结果/ 是/ 正确/ 的/ ./ 证明/ ./ ROS/ 阶段/ 产生/ m/ ×/ n/ 对/ 文件/ :/ file1/ _/ i/ _/ j/ 和/ file2/ _/ i/ _/ j/ (/ 1/ / i/ / m/ ,/ 1/ / j/ / n/ )/ ./ 犛的/ 元素/ S/ (/ i/ ,/ j/ )/ 对应/ 文件/ 对/ file1/ _/ i/ _/ j/ 和/ file2/ _/ i/ _/ j/ ,/ 这/ 是因为/ / a/ ,/ b/ ,/ (/ a/ ,/ b/ )/ ∈/ S/ (/ i/ ,/ j/ )/ 满足/ 如下/ 条件/ :/ (/ 1/ )/ a/ ∈/ [/ PI1i/ -/ 1/ ,/ PI1i/ ]/ ,/ (/ 2/ )/ b/ ∈/ [/ PI2j/ -/ 1/ ,/ PI2j/ ]/ ./ S/ (/ i/ ,/ j/ )/ 是/ JPIPT/ 的/ 子/ 序列/ ,/ 已知/ JPIPT/ 根据/ PI1/ 排序/ ,/ 则/ S/ (/ i/ ,/ j/ )/ 也/ 根据/ PI1/ 排序/ ./ 定理/ 2/ 证明/ file1/ _/ i/ _/ j/ 和/ file2/ _/ i/ _/ j/ 的/ 正确性/ ,/ 所以/ / i/ ,/ j/ ,/ file1/ _/ i/ _/ j/ 和/ file2/ _/ i/ _/ j/ 都/ 产生/ 正确/ 的/ 结果/ ./ 证毕/ ./ 作/ 序列/ S1/ =/ {/ i1/ ,/ i2/ ,/ …/ ,/ iN/ }/ ,/ PI2/ 域/ 的/ 数据/ 可以/ 看作/ 序列/ S2/ =/ {/ j1/ ,/ j2/ ,/ …/ ,/ jN/ }/ ./ 由于/ JPIPT/ 根据/ PI1/ 排序/ ,/ 所以/ i1/ / i2/ / …/ / iN/ ,/ BUF/ _/ T1/ 保存/ 的/ 元组/ 具有/ 新/ 的/ 位置/ 索引/ P1/ =/ {/ 1/ ,/ 2/ ,/ …/ ,/ N/ }/ ,/ 并且/ P1/ 的/ 元素/ 和/ S1/ 的/ 元素/ 具有/ 1/ -/ 1/ 对应/ 关系/ (/ 虽然/ S1/ 可能/ 存在/ 重复/ 值/ ,/ 可是/ 这些/ 重复/ 值/ 表示/ 相同/ 的/ T1/ 元组/ ,/ 所以/ 其/ 顺序/ 不会/ 影响/ 结果/ 的/ 正确性/ )/ ./ 我们/ 把/ S1/ 和/ P1/ 结合/ 而/ 获得/ 一个/ 新/ 的/ 序列/ SP1/ =/ {/ (/ i1/ ,/ 1/ )/ ,/ (/ i2/ ,/ 2/ )/ ,/ …/ ,/ (/ iN/ ,/ N/ )/ }/ ./ 类似/ 的/ ,/ 我们/ 获得/ SP2/ =/ {/ (/ j1/ ,/ (/ i1/ ,/ 1/ )/ )/ ,/ (/ j2/ ,/ (/ i2/ ,/ 2/ )/ )/ ,/ …/ ,/ (/ jN/ ,/ (/ iN/ ,/ N/ )/ )/ }/ ,/ 其中/ (/ jk/ ,/ (/ ik/ ,/ k/ )/ )/ 表示/ T2/ (/ jk/ )/ 是/ JPIPT/ (/ k/ )/ 对应/ 的/ 连接/ 结果/ 的/ 一部分/ ./ 因为/ SP2/ 不是/ 根据/ jk/ 排序/ 的/ ,/ 为/ 方便/ 对/ T2/ 的/ 顺序/ 扫描/ 来/ 获得/ 结果/ ,/ IRS/ 对/ SP2/ 根据/ jk/ 排序/ ,/ 获得/ SP2/ =/ {/ (/ j1/ ,/ (/ is1/ ,/ s1/ )/ )/ ,/ (/ j2/ ,/ (/ is2/ ,/ s2/ )/ )/ ,/ …/ ,/ (/ jN/ ,/ (/ isN/ ,/ sN/ )/ )/ }/ ,/ j1/ / j2/ / …/ / jN/ ,/ {/ s1/ ,/ s2/ ,/ …/ ,/ sN/ }/ 是/ P1/ 的/ 一个/ 排列/ ./ 很/ 明显/ ,/ BUF/ _/ T1/ 和/ BUF/ _/ T2/ 中/ 具有/ 相同/ 的/ 新/ 位置/ 索引/ 的/ 元组/ 不是/ 连接/ 操作/ 的/ 结果/ 元组/ ,/ 因为/ 通常/ sk/ ≠/ isk/ ./ 要/ 保证/ 结果/ 的/ 正确性/ ,/ BUF/ _/ T2/ 需要/ 执行/ 另/ 一次/ 根据/ sk/ 排序/ 的/ 操作/ ./ 由于/ S1/ 和/ P1/ 的/ 元素/ 有/ 1/ -/ 1/ 对应/ 关系/ ,/ 所以/ BUF/ _/ T2/ 也/ 可以/ 根据/ isk/ 排序/ ,/ 即/ 根据/ 对应/ 的/ PI1/ 排序/ ./ 该/ 证明/ 过程/ 如图/ 6/ 所示/ ./ 证毕/ ./ 5/ 性能/ 评价/ 和/ 分析/ 我们/ 通过/ 实验/ 来/ 评价/ DBCC/ -/ Join/ 的/ 性能/ ./ 由于/ 现有/ 的/ 利用/ 高速缓存/ 的/ 连接/ 算法/ [/ 4/ ,/ 6/ ,/ 9/ -/ 11/ ]/ 只/ 适用/ 于/ 内存/ 数据库/ ,/ 而/ 本文/ 的/ 重点/ 是/ 海量/ 数据/ 上/ 的/ 磁盘/ 连接/ 算法/ ,/ 所以/ 本文/ 的/ 实验/ 部分/ 比较/ DBCC/ -/ Join/ 和/ 传统/ 的/ hashjoin/ 算法/ ./ 我们/ 用/ Java/ 实现/ hashjoin/ 和/ DBCC/ -/ Join/ ,/ jdk/ 版本/ 是/ jdk/ -/ 6u17/ -/ windows/ -/ x64/ ,/ 实验/ 程序/ 在/ HPxw8600workstation/ (/ 8/ ×/ 2.8/ GHzXeonCPU/ +/ 6MBL2cache/ +/ 32GB/ 内存/ +/ 1.4/ TB/ 硬盘/ +/ 64bitwindows/ )/ 上/ 运行/ ./ 我们/ 用/ tpc/ -/ h/ 生成元/ 组定/ 长/ 的/ 实验/ 数据/ ,/ 采用/ 的/ 数据表/ 是/ lineitem/ 和/ orders/ ./ 1sf/ 的/ lineitem/ 和/ orders/ 表/ 分别/ 含有/ 6M/ 和/ 1.5/ M/ 条/ 元组/ ,/ lineitem/ 的/ 每个/ 元组/ 为/ 160/ 字节/ ,/ orders/ 的/ 每个/ 元组/ 为/ 128/ 字节/ ,/ 1sf/ 数据表/ 的/ 大小/ 分别/ 是/ 0.89/ GBPage8/ 和/ 0.18/ GB/ ./ 实验/ 中/ 采用/ 的/ 查询/ Q/ 如下/ 所示/ :/ 实验/ 从/ 4/ 个/ 方面/ 评价/ DBCC/ -/ Join/ 算法/ 的/ 性能/ :/ 元组/ 数量/ 、/ 表/ 宽度/ 、/ 输出/ 属性/ 数量/ 和/ 连接/ 选择/ 度/ ./ 考虑/ 的/ 元组/ 数量/ 是/ 30sf/ 、/ 60sf/ 、/ 90sf/ 、/ 120sf/ 和/ 150sf/ ./ 令/ tpc/ -/ h/ 的/ 默认/ 表/ 模式/ 作为/ 表/ 宽度/ 1/ (/ 默认值/ )/ ,/ 表/ 宽度/ 2/ 则/ 表示/ 把/ tpc/ -/ h/ 的/ 表/ 模式/ 扩大/ 一倍/ ,/ 即/ 重复/ 一遍/ 初始/ 表/ 模式/ ,/ 以此类推/ 得到/ 表/ 宽度/ 为/ 3/ 、/ 4/ 和/ 5/ 的/ 数据/ 集/ ./ 输出/ 属性/ 数量/ 考虑/ :/ 表/ 模式/ 的/ 20/ %/ 、/ 40/ %/ 、/ 60/ %/ (/ 默认值/ )/ 、/ 80/ %/ 和/ 100/ %/ 的/ 属性/ ./ 本文/ 考虑/ 相对/ 连接/ 选择率/ ,/ 连接/ 属性/ l/ _/ orderkey/ 和/ o/ _/ orderkey/ 在/ 给定/ 的/ 值域/ 范围/ (/ 0/ ,/ MAX/ )/ 内/ 随机/ 分布/ ./ 默认/ 情况/ 下/ ,/ MAX/ =/ 2/ ×/ N1/ ,/ N1/ 表示/ lineitem/ 表/ 的/ 元组/ 数量/ ,/ 假设/ 当/ MAX/ =/ 1/ ×/ N1/ 时/ 的/ 选择率/ 为/ 1/ ,/ 则/ 默认/ 选择率/ 为/ 1/ // 2/ ./ 讨论/ 连接/ 选择/ 度/ 的/ 效果/ 时/ ,/ 我们/ 考虑/ 的/ 相对/ 选择/ 度/ 分别/ 为/ 1/ 、/ 1/ // 2/ 、/ 1/ // 3/ 、/ 1/ // 4/ 和/ 1/ // 5/ ./ 在/ 实验/ 中/ ,/ 内存/ 使用量/ 限制/ 为/ 8G/ ./ 5.1/ 实验/ 1/ :/ 元组/ 数量/ 的/ 效果/ 实验/ 1/ ./ 评价/ 在/ 元组/ 数量/ 变化/ 的/ 情况/ 下/ DBCC/ -/ 图/ 7/ 元组/ 数量/ 变化/ 时/ 执行/ 时间/ 的/ 比较/ 5.2/ 实验/ 2/ :/ 表宽/ 的/ 效果/ 实验/ 2/ ./ 评价/ 在/ 表/ 宽度/ 变化/ 的/ 情况/ 下/ DBCC/ -/ Join/ 的/ 性能/ ,/ 其中/ ,/ sf/ 设置/ 为/ 30/ ,/ 输出/ 属性/ 比例/ 设置/ Join/ 的/ 性能/ ,/ 其中/ ,/ 表宽/ 设置/ 为/ 1/ ,/ 输出/ 属性/ 比例/ 为/ 60/ %/ ,/ 相对/ 选择率/ 为/ 1/ // 2/ ./ 如图/ 7/ (/ a/ )/ 所示/ ,/ 在/ 实验/ 1/ 中/ ,/ DBCC/ -/ Join/ 的/ 执行/ 时间/ 平均/ 比/ hashjoin/ 快/ 7.26/ 倍/ ./ 该/ 加速/ 比/ 的/ 获得/ 一方面/ 是/ 由于/ DBCC/ -/ Join/ 只/ 需要/ 对原/ 数据表/ 执行/ 一次/ 扫描/ 就/ 可以/ 完成/ ,/ 而/ 传统/ 的/ hashjoin/ 则/ 需要/ 对原/ 数据表/ 执行/ 多次/ 扫描/ 操作/ ,/ 另一方面/ 由于/ 是/ DBCC/ -/ Join/ 充分利用/ 高速缓存/ 而/ 获得/ 的/ 更好/ 的/ 性能/ ./ JPIPT/ 构建/ 阶段/ 执行/ Hash/ 表/ 的/ 构建/ 和/ 探测/ 操作/ 时/ ,/ 采用/ 多次/ 划分/ 操作/ 使得/ 内/ 关系/ 子/ 分片/ 可以/ 放入/ 高速缓存/ ,/ 然后/ 对/ 每个/ 子/ 分片/ 执行/ Hash/ 操作/ ,/ Hash/ 操作/ 的/ 结果/ 在/ 输出/ 之前/ 还/ 需要/ 执行/ 归并/ 排序/ 操作/ ,/ 使得/ 输出/ 的/ 位置/ 索引/ 对/ 根据/ 外/ 关系/ 的/ 位置/ 索引/ 排序/ ,/ 如图/ 7/ (/ b/ )/ 所示/ ,/ 即使/ 需要/ 如此/ 多/ 的/ 步骤/ 来/ 执行/ 内存/ 内/ 的/ Hash/ 操作/ ,/ DBCC/ -/ Join/ 的/ 执行/ 时间/ 仍然/ 比/ 不/ 考虑/ 高速缓存/ 的/ Hash/ 操作/ 要/ 快/ 5.62/ 倍/ ./ 图/ 7/ (/ c/ )/ 和/ (/ d/ )/ 说明/ 在内/ 关系/ 扫描/ 阶段/ ,/ 采用/ C2/ -/ Sort/ 算法/ 比/ 普通/ 的/ 排序/ 算法/ 运行/ 得/ 更/ 快/ ,/ 分别/ 获得/ 了/ 1.79/ 和/ 1.51/ 倍/ 的/ 加速/ 比/ ./ 为/ 60/ %/ ,/ 相对/ 选择率/ 为/ 1/ // 2/ ./ 如图/ 8/ (/ a/ )/ 所示/ ,/ 在/ 实验/ 2/ 中/ ,/ DBCC/ -/ Join/ 的/ 执行/ 时间/ 平均/ 比/ hashjoin/ 快/ 了/ 10.58/ 倍/ ./ 通过/ 实验/ 我/ Page9/ 们/ 发现/ ,/ 在/ 其它/ 条件/ 不变/ 的/ 情况/ 下/ ,/ 增加/ 表/ 宽度/ 会/ 提高/ DBCC/ -/ Join/ 对/ hashjoin/ 的/ 加速/ 比/ ,/ 这是/ 由于/ 在/ 固定/ 元组/ 数量/ 的/ 情况/ 下/ ,/ JPIPT/ 构建/ 阶段/ 的/ 执行/ 时间/ 不会/ 随着/ 表宽/ 的/ 增大/ 而/ 增加/ ,/ 而且/ 如图/ 8/ (/ b/ )/ 所示/ 考虑/ 高速缓存/ 的/ Hash/ 操作/ 比/ 不/ 考虑/ 高速缓存/ 的/ Hash/ 操作/ 要/ 快/ 5.31/ 倍/ ,/ 而/ hashjoin/ 的/ 划分/ 和/ 连接/ 操作/ 都/ 会/ 随着/ 表宽/ 的/ 增大/ 而/ 增加/ ./ 图/ 8/ (/ c/ )/ 和/ (/ d/ )/ 表图/ 8/ 表宽/ 变化/ 时/ 执行/ 时间/ 的/ 比较/ 5.3/ 实验/ 3/ :/ 输出/ 属性/ 数量/ 的/ 效果/ 实验/ 3/ ./ 评价/ 在/ 输出/ 属性/ 数量/ 变化/ 的/ 情况/ 下/ DBCC/ -/ Join/ 的/ 性能/ ,/ 其中/ ,/ sf/ 设为/ 30/ ,/ 表宽/ 设置/ 为/ 1/ ,/ 相对/ 选择率/ 为/ 1/ // 2/ ./ 如图/ 9/ (/ a/ )/ 所示/ ,/ 在/ 实验/ 3/ 中/ ,/ DBCC/ -/ Join/ 的/ 执行/ 时间/ 平均/ 比/ hashjoin/ 快/ 了/ 6.44/ 倍/ ./ 我们/ 发现/ ,/ 在/ 输出/ 属性/ 从/ 80/ %/ 提高/ 到/ 100/ %/ 时/ ,/ 执行/ 时间/ 的/ 增长幅度/ 较大/ ,/ 这是/ 由于/ lineitem/ 和/ orders/ 表/ 的/ 最后/ 一个/ 属性/ l/ _/ comment/ 和/ o/ _/ comment/ 比较/ 长/ ,/ 该/ 属性/ 的/ 字节/ 长度/ 分别/ 占/ 整个/ 元组/ 长度/ 的/ 1/ // 3/ 和/ 1/ // 2/ ./ 在/ 固定/ 元组/ 数量/ 的/ 情况/ 下/ ,/ JPIPT/ 构建/ 阶段/ Hash/ 操作/ 的/ 时间/ 不会/ 随着/ 输出/ 属性/ 数量/ 的/ 变化/ 而/ 变化/ ,/ 如图/ 9/ (/ b/ )/ 所示/ ./ 可以/ 看到/ ,/ 考虑/ 高速缓存/ 的/ Hash/ 操作/ 比/ 不/ 考虑/ 高速缓存/ 的/ Hash/ 操作/ 仍然/ 具有/ 较大/ 的/ 优势/ ./ 随着/ 输出/ 属性/ 的/ 增加/ ,/ 如图/ 9/ (/ c/ )/ 和/ (/ d/ )/ ,/ 采用/ C2/ -/ Sort/ 算法/ 比/ 不/ 考虑/ 高速缓存/ 的/ 排序/ 算法/ 运行/ 得示/ 在/ 右/ 扫描/ 阶段/ 中/ ,/ 采用/ C2/ -/ Sort/ 算法/ 比/ 不/ 考虑/ 高速缓存/ 的/ 排序/ 算法/ 运行/ 得/ 更/ 快/ ,/ 分别/ 获得/ 了/ 1.53/ 和/ 1.24/ 倍/ 的/ 加速/ 比/ ,/ 和/ 实验/ 1/ 相比/ ,/ C2/ -/ Sort/ (/ orders/ )/ 获得/ 加速/ 要/ 小/ 一些/ ,/ 这是/ 由于/ 随着/ 表宽/ 的/ 增大/ ,/ 更/ 多/ 的/ 属性/ 需要/ 执行/ 排序/ 操作/ ,/ 这/ 使得/ 合并/ 操作/ 的/ 费用/ 增加/ ,/ 从而/ 减小/ 了/ 所/ 获得/ 的/ 加速/ 比/ ./ 更快/ ,/ 分别/ 获得/ 了/ 1.98/ 倍/ 和/ 1.63/ 倍/ 的/ 加速/ 比/ ./ 5.4/ 实验/ 4/ :/ 连接/ 选择/ 度/ 的/ 效果/ 实验/ 4/ ./ 评价/ 在/ 输出/ 属性/ 数量/ 变化/ 的/ 情况/ 下/ DBCC/ -/ Join/ 的/ 性能/ ,/ 其中/ ,/ sf/ 设为/ 30/ ,/ 表宽/ 设置/ 为/ 1/ ,/ 输出/ 属性/ 比例/ 设置/ 为/ 60/ %/ ./ 如图/ 10/ (/ a/ )/ 所示/ ,/ 在/ 实验/ 4/ 中/ ,/ DBCC/ -/ Join/ 的/ 执行/ 时间/ 平均/ 比/ hashjoin/ 快/ 了/ 6.35/ 倍/ ./ 可以/ 看到/ ,/ 随着/ 相对/ 选择/ 度/ 的/ 降低/ ,/ hashjoin/ 和/ DBCC/ -/ Join/ 的/ 执行/ 时间/ 也/ 在/ 下降/ ,/ 但是/ DBCC/ -/ Join/ 的/ 下降/ 幅度/ 更大/ ./ 这是/ 由于/ ,/ 更/ 小/ 的/ 选择/ 度/ 使得/ 结果/ 输出/ 阶段/ 所/ 需要/ 处理/ 的/ 数据/ 越/ 少/ ,/ 所以/ 内/ 关系/ 扫描/ 和/ 外/ 关系/ 扫描/ 所/ 耗费/ 的/ 时间/ 基本/ 呈/ 线性/ 下降/ ./ DBCC/ -/ Join/ 的/ 70/ %/ 的/ 时间/ 花费/ 在/ 结果/ 输出/ 阶段/ ,/ 所以/ 该/ 阶段/ 所/ 耗费/ 的/ 时间/ 随着/ 选择/ 度/ 降低/ 而/ 线性/ 下降/ ,/ 使得/ DBCC/ -/ Join/ 的/ 整体/ 时间/ 下降/ 幅度/ 较大/ ./ 而/ hashjoin/ 的/ 划分/ 阶段/ 不/ 受/ 选择/ 度/ 变化/ 的/ 影响/ ,/ 在/ 连接/ 阶段/ 的/ Hash/ 表构/ Page10/ 图/ 9/ 输出/ 属性/ 数量/ 变化/ 时/ 执行/ 时间/ 的/ 比较/ 图/ 10/ 连接/ 选择/ 度/ 变化/ 时/ 执行/ 时间/ 的/ 比较/ Page11/ 建/ 的/ 费用/ 也/ 不变/ ,/ 选择/ 度/ 降低/ 只是/ 会/ 使得/ Hash/ 表/ 的/ 探测/ 阶段/ 的/ 时间/ 降低/ ,/ 所以/ 选择/ 度/ 对/ hashjoin/ 的/ 影响/ 没有/ 对/ DBCC/ -/ Join/ 那么/ 大/ ,/ 所以/ DBCC/ -/ Join/ 比/ hashjoin/ 的/ 性能/ 优势/ 逐渐/ 变大/ ./ 如图/ 10/ (/ b/ )/ 所示/ ,/ 在/ 执行/ Hash/ 构建/ 操作/ 时/ ,/ 随着/ 选择/ 度/ 的/ 降低/ ,/ 其/ 执行/ 时间/ 也/ 在/ 逐渐/ 下降/ ,/ 但是/ 和/ 不/ 考虑/ 高速缓存/ 的/ 算法/ 相比/ ,/ 高速缓存/ 敏感/ 的/ Hash/ 算法/ 仍然/ 获得/ 了/ 6.06/ 倍/ 的/ 加速/ 比/ ./ 同样/ ,/ 如图/ 10/ (/ c/ )/ 和/ (/ d/ )/ 所示/ ,/ 选择/ 度/ 降低/ 使得/ 内/ 关系/ 扫描/ 需要/ 排序/ 的/ 数据/ 也/ 减少/ ,/ 从而/ 减少/ 了/ 执行/ 时间/ ,/ 但是/ 相对/ 于/ 普通/ 的/ 排序/ 算法/ ,/ C2/ -/ Sort/ 仍然/ 获得/ 了/ 1.69/ 和/ 1.59/ 倍/ 的/ 加速/ 比/ ./ 6/ 相关/ 工作/ 连接/ 操作/ 是/ 数据库/ 中/ 的/ 一种/ 基本/ 并且/ 耗时/ 的/ 操作/ ,/ 所以/ 得到/ 了/ 研究/ 人员/ 的/ 广泛/ 关注/ ./ Nested/ -/ loop/ 算法/ 、/ Sort/ -/ merge/ 算法/ 、/ GraceHashjoin/ 和/ HybridHashjoin/ 是/ 4/ 种/ 常用/ 的/ 连接/ 算法/ [/ 3/ ,/ 12/ ]/ ./ Bucketskipmergejoin/ [/ 13/ ]/ 的/ 方法/ 假定/ 关系/ 表/ 已经/ 根据/ 连接/ 属性/ 排序/ ,/ 并且/ 虚拟/ 地/ 把/ 数据表/ 划分/ 成/ 多个/ 分片/ ,/ 利用/ 每个/ 分片/ 的/ 连接/ 属性/ 的/ 最大值/ 和/ 最小值/ 信息/ 来/ 跳/ 过/ 不/ 满足/ 连接/ 条件/ 的/ 元组/ 及/ 分片/ ,/ 从而/ 提高/ 了/ 连接/ 算法/ 的/ 性能/ ./ Graefe/ [/ 14/ ]/ 利用/ 5/ 种/ 方法/ 来/ 改进/ Hybridhashjoin/ 的/ 性能/ :/ 压缩/ 、/ 大规模/ 的/ 机群/ 及/ 多层/ 递归/ 、/ 内/ 关系/ 和/ 外/ 关系/ 的/ 角色/ 转换/ 、/ 利用/ 数据分布/ 的/ 柱状图/ 以及/ 多表/ 连接/ 的/ 算法/ 等/ ./ Chen/ 等/ [/ 15/ -/ 16/ ]/ 利用/ 预取/ 机制/ 来/ 充分/ 利用计算机/ 的/ 硬件/ 特点/ ,/ 提高/ 了/ hashjoin/ 的/ 性能/ ./ 本文/ 利用/ 位置/ 索引/ 对/ 信息/ 来/ 减少/ 所/ 需要/ 的/ IO/ 代价/ ,/ 加快/ join/ 查询/ 的/ 处理速度/ ,/ 其/ 概念/ 和/ Valduriez/ [/ 17/ ]/ 提到/ 的/ 连接/ 索引/ 类似/ ./ Lei/ 等/ [/ 18/ ]/ 提出/ stripe/ -/ join/ 方法/ 处理/ join/ 操作/ ,/ 可是/ 该/ 算法/ 假设/ 已经/ 得到/ 所/ 需要/ 的/ 连接/ 索引/ ./ 大多数/ 现有/ 的/ 数据库/ 查询/ 算法/ 并/ 没有/ 充分利用/ 计算机硬件/ ,/ 从而/ 没有/ 充分发挥/ CPU/ 的/ 能力/ [/ 4/ -/ 5/ ]/ ./ 一部分/ 研究/ 人员/ 提出/ 利用/ 缓存/ 的/ join/ 算法/ ./ Shatdal/ 等/ [/ 2/ ]/ 提出/ 缓存/ 划分算法/ ,/ 使得/ 在/ 划分/ 阶段/ 把/ 内/ 关系/ 的/ 每个/ 分片/ 划分/ 得/ 尽可能/ 小/ ,/ 使得/ 每个/ 分片/ 可以/ 放入/ 高速缓存/ ,/ 但是/ 该/ 方法/ 引起/ 昂贵/ 的/ 磁盘/ IO/ 费用/ ./ Boncz/ 等/ [/ 4/ ]/ 指出/ 了/ 数据库/ 操作/ 的/ 新/ 瓶颈/ 是/ 内存/ 存取/ ,/ 而/ 不是/ 通常/ 认为/ 的/ IO/ 存储/ ,/ 并且/ 发现/ 在/ 主存/ 数据库/ 的/ 划分/ 操作/ 中/ ,/ 划分/ 分片/ 过多时/ ,/ 会/ 引起/ 大量/ 的/ TLBmiss/ ,/ 所以/ 他们/ 提出/ 了/ radix/ -/ clustering/ 算法/ [/ 6/ ]/ ,/ 通过/ 执行/ 多遍/ 划分/ 的/ 方法/ ,/ 使得/ 每遍/ 划分/ 的/ 分片/ 数量/ 小于/ TLB/ 维护/ 的/ 映射/ 数量/ ,/ 从而/ 减少/ 了/ TLBmiss/ 的/ 数量/ ./ He/ 等/ [/ 9/ -/ 11/ ]/ 提出/ cacheoblivious/ 查询处理/ 方法/ ,/ 该/ 方法/ 意识/ 到/ 多层/ 存储/ 结构/ 的/ 存在/ ,/ 但是/ 不/ 需要/ 知道/ 存储/ 结构/ 的/ 具体/ 参数/ ,/ 而是/ 采用/ 自动/ 调节/ 的/ 方法/ 获得/ 较/ 好/ 的/ 性能/ ./ 和/ 本文/ 的/ 方法/ 不同/ ,/ Boncz/ 和/ He/ 等/ 处理/ 的/ 是/ 主存/ 数据库/ 的/ join/ 操作/ ,/ 而/ 不是/ 磁盘/ join/ 操作/ ./ Kim/ 等/ [/ 19/ ]/ 根据/ Radix/ -/ clustering/ 算法/ ,/ 并且/ 结合/ 了/ 计算机/ SIMD/ 和/ 多/ 核/ 的/ 特点/ 实现/ 了/ join/ 算法/ ,/ 来/ 比较/ 同样/ 充分利用/ 计算机硬件/ 特性/ 的/ sort/ -/ mergejoin/ 的/ 性能/ ./ 他们/ 得出/ 如下/ 结论/ :/ 当/ SIMD/ 的/ 宽度/ 达到/ 512/ -/ bit/ 的/ 时候/ ,/ sort/ -/ mergejoin/ 就/ 优于/ hashjoin/ ./ Ny/ -/ berg/ 等/ [/ 20/ ]/ 指出/ 要/ 获得/ 高性能/ 的/ 排序/ 算法/ ,/ 必须/ 考虑/ 如何/ 利用/ 高速缓存/ ,/ 他们/ 采用/ 的/ 方法/ 也/ 是/ 利用/ 划分/ 操作/ 把/ 数据表/ 数据/ 分为/ 多个/ 分片/ ,/ 每个/ 分片/ 可以/ 放入/ 高速缓存/ ,/ 从而/ 获得/ 较/ 快/ 的/ cache/ 执行/ 效率/ ,/ 可是/ 其/ 划分/ 过程/ 存在/ 的/ 问题/ 和/ 文献/ [/ 2/ ]/ 中/ 的/ 问题/ 类似/ ./ 7/ 结论/ 为/ 弥补/ CPU/ 和/ 内存/ 之间/ 日益/ 增大/ 的/ 性能/ 差异/ ,/ 人们/ 在/ CPU/ 和/ 内存/ 之间/ 插入/ 了/ 高速缓存/ ./ 要/ 提高/ CPU/ 的/ 利用率/ ,/ 应用程序/ 必须/ 充分利用/ 高速缓存/ ./ 本文/ 分析/ 了/ 传统/ 的/ 磁盘/ 连接/ 算法/ 在/ 高速缓存/ 利用/ 方面/ 的/ 问题/ ,/ 并且/ 提出/ 了/ 一种/ 新/ 的/ 可以/ 充分利用/ 高速缓存/ 的/ 磁盘/ 连接/ 算法/ DBCC/ -/ Join/ ./ 连接/ 位置/ 索引/ 对表/ JPIPT/ 是/ 用到/ 的/ 数据结构/ ,/ 说明/ 了/ 每个/ 连接/ 结果/ 元组/ 在/ 各自/ 表中/ 的/ 位置/ 索引/ 对/ ./ DBCC/ -/ Join/ 的/ 执行/ 包括/ 两个/ 阶段/ :/ JPIPT/ 构建/ 阶段/ 和/ 结果/ 输出/ 阶段/ ./ JPIPT/ 构建/ 阶段/ 对列/ 存储/ 化/ 的/ 连接/ 属性/ 执行/ 高速缓存/ 敏感/ 的/ 算法/ 来/ 构建/ 连接/ 位置/ 索引/ 对表/ ./ 利用/ 获得/ 的/ JPIPT/ ,/ 结果/ 输出/ 阶段/ 只/ 需要/ 对/ 数据表/ 执行/ 一遍/ 顺序/ 扫描/ 就/ 可以/ 获得/ 结果/ ./ 实验/ 表明/ ,/ 和/ 传统/ 磁盘/ 连接/ 算法/ 相比/ ,/ DBCC/ -/ Join/ 算法/ 可以/ 获得/ 一个/ 数量级/ 的/ 加速/ 比/ ,/ 从而/ 强调/ 了/ 高速缓存/ 在/ 数据库/ 查询处理/ 方面/ 的/ 重要性/ ./ 

