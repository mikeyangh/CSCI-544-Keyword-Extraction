Page1TKEP/ :/ 海量/ 数据/ 上/ 一种/ 有效/ 的/ Top/ -/ 犓/ 查询处理/ 算法/ 韩希先/ 1/ )/ 杨/ 东华/ 2/ )/ 李建中/ 1/ )/ 1/ )/ (/ 哈尔滨工业大学/ 计算机科学/ 与/ 技术/ 学院/ 哈尔滨/ 150001/ )/ 2/ )/ (/ 哈尔滨工业大学/ 基础/ 与/ 交叉科学/ 研究院/ 高性能/ 计算中心/ 哈尔滨/ 150001/ )/ 摘要/ 在/ 许多/ 应用领域/ 中/ ,/ top/ -/ k/ 查询/ 是/ 一种/ 十分/ 重要/ 的/ 操作/ ,/ 它/ 根据/ 给定/ 的/ 评分/ 函数/ 在/ 潜在/ 的/ 巨大/ 的/ 数据/ 空间/ 中/ 返回/ k/ 个/ 最/ 重要/ 的/ 对象/ ./ 不同于/ 传统/ 的/ TA/ 算法/ ,/ NRA/ 算法/ 只/ 需要/ 顺序/ 读/ 就/ 可以/ 处理/ top/ -/ k/ 查询/ ,/ 从而/ 适合/ 于/ 随机/ 读/ 受限/ 或/ 不/ 可能/ 的/ 场合/ ./ 文中/ 详细/ 地/ 分析/ 了/ NRA/ 算法/ 的/ 执行/ 行为/ ,/ 确定/ 了/ 增长/ 阶段/ 和/ 收缩/ 阶段/ 中/ 每个/ 文件/ 需要/ 扫描/ 的/ 元组/ 个数/ ./ 文中/ 发现/ 在/ 海量/ 数据/ 环境/ 中/ ,/ NRA/ 在/ 增长/ 阶段/ 需要/ 维护/ 大量/ 的/ 候选/ 元组/ ,/ 严重/ 影响/ 了/ 算法/ 的/ 执行/ 效率/ ./ 所以/ ,/ 文中/ 提出/ 一种/ 新/ 的/ 海量/ 数据/ 上/ 的/ top/ -/ k/ 查询/ 算法/ TKEP/ ,/ 该/ 算法/ 在/ 查询/ 的/ 增长/ 阶段/ 就/ 执行/ 早/ 剪切/ ,/ 从而/ 大大减少/ 增长/ 阶段/ 需要/ 维护/ 的/ 候选/ 元组/ ./ 文中/ 给出/ 了/ 早/ 剪切/ 操作/ 的/ 数学分析/ ,/ 确定/ 了/ 早/ 剪切/ 操作/ 的/ 理论/ 和/ 实际/ 剪切/ 效果/ ./ 据/ 作者/ 所知/ ,/ 该文/ 是/ 第一篇/ 提出/ 在/ top/ -/ k/ 查询/ 的/ 增长/ 阶段/ 执行/ 早/ 剪切/ 的/ 文章/ ./ 实验/ 结果表明/ ,/ 和/ 传统/ 的/ NRA/ 相比/ ,/ TKEP/ 在/ 增长/ 阶段/ 维护/ 的/ 元组/ 数量/ 减少/ 3/ 个/ 数量级/ ,/ 需要/ 的/ 内存/ 量减少/ 1/ 个/ 数量级/ ,/ TKEP/ 算法/ 获得/ 1/ 个/ 数量级/ 的/ 加速/ 比/ ./ 关键词/ 海量/ 数据/ ;/ top/ -/ k/ ;/ 早/ 剪切/ ;/ TKEP1/ 引言/ 在/ 许多/ 应用领域/ 中/ ,/ 例如/ Web/ 搜索/ 、/ 信息检索/ 、/ 多媒体数据库/ 和/ 数据挖掘/ 等/ ,/ top/ -/ k/ 查询/ 是/ 一种/ 十分/ 重要/ 的/ 操作/ ,/ 它/ 根据/ 给定/ 的/ 评分/ 函数/ 在/ 潜在/ 的/ 数据/ 空间/ 中/ 返回/ k/ 个/ 最/ 重要/ 的/ 结果/ ./ 处理/ top/ -/ k/ 查询/ 时/ ,/ 系统/ 通常/ 根据/ 用户/ 的/ 要求/ 对/ 涉及/ 到/ 的/ 每个/ 对象/ 的/ 属性/ 计算/ 一个/ 数值/ 来/ 反映/ 该/ 属性/ 的/ 特点/ ,/ 然后/ 利用/ 一个/ 单调/ 评分/ 函数/ 聚集/ 多个/ 属性/ 的/ 数值/ 作为/ 该/ 对象/ 的/ 权重/ ,/ top/ -/ k/ 查询/ 返回/ k/ 个/ 权重/ 最高/ 的/ 对象/ 作为/ 查询/ 的/ 结果/ ./ 处理/ top/ -/ k/ 查询/ 的/ 一种/ 方式/ 是/ 利用/ 多维/ 索引/ ,/ 可是/ 当/ 查询/ 涉及/ 的/ 属性/ 超过/ 6/ 时/ ,/ 多维/ 索引/ 的/ 查询/ 性能/ 急剧下降/ (/ curseofdimensionality/ )/ [/ 1/ ]/ ./ 相对/ 于/ 多维/ 索引/ ,/ 另/ 一种/ 更/ 具有/ 扩展性/ 的/ 方法/ 是/ 把/ 数据表/ 列/ 存储/ 化/ 并且/ 按/ 属性/ 值/ 降序/ 排列/ 存储/ ./ Fagin/ 等/ [/ 2/ ]/ 提出/ TA/ 算法/ 在/ 多个/ 有序/ 文件/ 上/ 执行/ top/ -/ k/ 查询/ ./ top/ -/ k/ 查询处理/ 涉及/ 到/ 两种/ 数据/ 读/ 方式/ 来/ 获得/ 对象/ x/ 在/ 指定/ 列/ 文件/ 的/ 数值/ :/ 顺序/ 读/ 和/ 随机/ 读/ ./ 顺序/ 读/ 意味着/ 处理/ 完该/ 文件/ 中/ 分数/ 比/ x/ 大/ 的/ 元组/ 后/ 可以/ 获得/ x/ 的/ 分数/ ,/ 而/ 随机/ 读则/ 直接/ 获得/ 该/ 文件/ 中/ x/ 对应/ 的/ 属性/ 值/ ./ 在/ 某些/ 情况/ 下/ ,/ 例如/ 数据流/ 和/ 海量/ 数据/ 环境/ ,/ 随机/ 读/ 操作/ 是/ 受限/ 的/ 或/ 过于/ 昂贵/ 的/ ,/ 人们/ 利用/ NRA/ 算法/ [/ 3/ -/ 6/ ]/ 来/ 处理/ 只/ 支持/ 顺序/ 读/ 的/ top/ -/ k/ 查询/ ./ NRA/ 的/ 执行/ 可以/ 分为/ 两个/ 阶段/ :/ 增长/ 阶段/ (/ 不断/ 累积/ top/ -/ k/ 候选/ 元组/ 直到/ 找到/ top/ -/ k/ 结果/ 的/ 阈值/ )/ 和/ 收缩/ 阶段/ (/ 不断/ 剪切/ 候选/ 元组/ 直到/ 获得/ 最终/ top/ -/ k/ 结果/ )/ ./ 由于/ 属性/ 文件/ 的/ 降序/ 排列/ 和/ 评分/ 函数/ 的/ 单调/ 性/ ,/ NRA/ 算法/ 通常/ 不/ 需要/ 处理/ 完/ 属性/ 文件/ 所有/ 数据/ 就/ 可以/ 结束/ 查询/ 并/ 返回/ 结果/ ./ 随着/ 涉及/ 的/ 属性/ 数量/ 、/ 元组/ 数量/ 和/ 返回/ 的/ 结果/ 数量/ 的/ 增大/ ,/ NRA/ 的/ 增长/ 阶段/ 需要/ 维护/ 的/ 候选/ 元组/ 也/ 越来越/ 多/ ,/ 其/ 维护费用/ 也/ 越来越/ 大/ ./ 尤其/ 是/ 增长/ 阶段/ 维护/ 的/ 数据/ 超过/ 给定/ 的/ 内存容量/ 时/ ,/ NRA/ 算法/ 将/ 不得不/ 把/ 内存/ 中/ 的/ 数据/ 反复/ 输出/ 到/ 磁盘/ ,/ 这/ 必然/ 会/ 引起/ 较/ 高/ 的/ 费用/ ,/ 从而/ 影响/ top/ -/ k/ 查询/ 的/ 执行/ 效率/ ./ 本文/ 详细/ 地/ 分析/ 了/ NRA/ 算法/ 的/ 执行/ 行为/ ,/ 确定/ 了/ 增长/ 阶段/ 和/ 收缩/ 阶段/ 中/ 每个/ 文件/ 需要/ 扫描/ 的/ 元组/ 数/ ,/ 同时/ 还/ 分析/ 了/ NRA/ 算法/ 在/ 增长/ 阶段/ 需要/ 维护/ 的/ 候选/ 元组/ 的/ 数量/ ./ 分析表明/ ,/ 在/ 海量/ 数据/ 上/ ,/ NRA/ 在/ 增长/ 阶段/ 需要/ 维护/ 大量/ 的/ 候选/ 元组/ ,/ 严重/ 影响/ 了/ 算法/ 的/ 执行/ 效率/ ./ 基于/ 对/ NRA/ 行为/ 的/ 分析/ ,/ 本文/ 提出/ 一种/ 新/ 的/ 海量/ 数据/ 上/ 的/ top/ -/ k/ 查询处理/ 算法/ TKEP/ (/ Top/ -/ KwithEarlyPruning/ )/ ./ 该/ 算法/ 和/ 现有/ NRA/ 算法/ 的/ 最大/ 不同/ 在于/ ,/ 该/ 算法/ 可以/ 在/ 查询/ 的/ 增长/ 阶段/ 就/ 执行/ 早/ 剪切/ ,/ 从而/ 减少/ 增长/ 阶段/ 需要/ 维护/ 的/ 元组/ 数量/ ./ 本文/ 给出/ 早/ 剪切/ 操作/ 的/ 数学分析/ ,/ 确定/ 了/ 早/ 剪切/ 的/ 理论/ 和/ 实际/ 剪切/ 效果/ ./ 指数/ 间距/ bloomfilter/ 表/ (/ EGBFT/ )/ 是/ TKEP/ 算法/ 执行/ 剪切/ 时/ 用到/ 的/ 数据结构/ ,/ EGBFT/ 的/ 第/ j/ 个/ 元组/ 是/ 构建/ 在/ 对应/ 文件/ 的/ 第/ 1/ 到/ 第/ 2j/ 元组/ 上/ 的/ bloomfilter/ ./ 本文/ 提供/ 了/ 较/ 全面/ 的/ 实验/ 来/ 评价/ TKEP/ 的/ 性能/ ,/ 实验/ 结果表明/ ,/ 和/ 传统/ 的/ NRA/ 相比/ ,/ TKEP/ 在/ 增长/ 阶段/ 维护/ 的/ 元组/ 数量/ 减少/ 3/ 个/ 数量级/ ,/ 需要/ 的/ 内存/ 量减少/ 1/ 个/ 数量级/ ,/ TKEP/ 算法/ 获得/ 1/ 个/ 数量级/ 的/ 加速/ 比/ ./ 本文/ 的/ 主要/ 贡献/ 在于/ :/ (/ 1/ )/ 本文/ 提出/ 了/ 一种/ 新/ 的/ 海量/ 数据/ 上/ 的/ top/ -/ k/ 算法/ TKEP/ ./ 不同于/ 传统/ 的/ NRA/ 算法/ ,/ TKEP/ 算法/ 在/ 增长/ 阶段/ 就/ 开始/ 执行/ 早/ 剪切/ 操作/ ,/ 从而/ 大大减少/ 了/ 需要/ 维护/ 的/ 候选/ 元组/ ./ 据/ 我们/ 所知/ ,/ 本文/ 是/ 第一篇/ 提出/ 在/ top/ -/ k/ 查询/ 中/ 执行/ 早/ 剪切/ 的/ 文章/ ./ (/ 2/ )/ 本文/ 给出/ 了/ NRA/ 算法/ 的/ 行为/ 分析/ ,/ 确定/ 了/ 增长/ 阶段/ 和/ 收缩/ 阶段/ 需要/ 扫描/ 的/ 元组/ 数/ 以及/ 增长/ 阶段/ 需要/ 维护/ 的/ 候选/ 元组/ 数量/ ./ (/ 3/ )/ 本文/ 提出/ 了/ 早/ 剪切/ 操作/ 的/ 数学分析/ ,/ 并且/ 确定/ 了/ 早/ 剪切/ 操作/ 的/ 理论/ 和/ 实际/ 剪切/ 效果/ ./ (/ 4/ )/ 本文/ 利用/ 较/ 全面/ 的/ 实验/ 比较/ 了/ TKEP/ 和/ NRA/ 算法/ 的/ 性能/ ./ 实验/ 表明/ ,/ 不管/ 在/ 执行/ 时间/ 还是/ 内存/ 消耗/ 方面/ ,/ TKEP/ 比/ NRA/ 算法/ 都/ 具有/ 较大/ 的/ 优势/ ./ 本文/ 第/ 2/ 节/ 给出/ 本文/ 的/ 背景/ 和/ 问题/ 定义/ ;/ 第/ 3/ 节/ 给出/ NRA/ 的/ 行为/ 分析/ ;/ TKEP/ 算法/ 在/ 第/ 4/ 节中/ 介绍/ ;/ 实验/ 和/ 性能/ 分析/ 在/ 第/ 5/ 节中/ 给出/ ;/ 第/ 6/ 节/ 和/ 第/ 7/ 节/ 分别/ 是/ 相关/ 工作/ 和/ 本文/ 的/ 结论/ ./ 2/ 背景/ 和/ 问题/ 定义/ 给定/ 具有/ N/ 个/ 元组/ 的/ 表/ T/ ,/ 每个/ 元组/ 具有/ M/ 个/ 属性/ A1/ ,/ A2/ ,/ …/ ,/ AM/ ./ 表/ T/ 存储/ 为列/ 文件/ 集合/ LS/ =/ {/ L1/ ,/ L2/ ,/ …/ ,/ LM/ }/ ,/ 每个/ 列/ 文件/ Li/ 的/ 模式/ 为/ Li/ (/ RID/ ,/ Ai/ )/ ,/ 其中/ RID/ 表示/ 元组/ 的/ 标识符/ ,/ Ai/ 表示/ 元组/ 在/ 属性/ Ai/ 上/ 的/ 值/ ./ / t/ ∈/ T/ ,/ 如果/ t/ ./ RID/ =/ ridi/ ,/ t/ ./ Ai/ =/ ai/ ,/ 则/ (/ ridi/ ,/ ai/ )/ ∈/ Li/ ./ Li/ 根据/ Ai/ 的/ 值/ 降序/ 排列/ ./ F/ 是/ 定义/ 在/ m/ 个/ 属性/ 上/ 的/ 评分/ 函数/ ,/ 不失/ 一般性/ ,/ 假设/ F/ 定义/ 在/ A1/ ,/ A2/ ,/ …/ ,/ Am/ ,/ F/ (/ t/ )/ =/ ∑/ mt/ ./ Ai/ )/ ,/ wi/ 是/ 评分/ 函数/ F/ 定义/ 在/ 属性/ Ai/ 上/ 的/ 权重/ ./ 通常/ ,/ F/ 是/ 单调/ 函数/ ,/ 即/ / t1/ ,/ t2/ ∈/ T/ ,/ 如果/ 对/ 所有/ 1/ / i/ / m/ ,/ t1/ ./ Ai/ / t2/ ./ Ai/ ,/ 那么/ F/ (/ t1/ )/ / F/ (/ t2/ )/ ./ Page3Top/ -/ 犽/ 查询/ ./ 给定/ 表/ T/ 和/ 涉及/ 到/ m/ 个/ 属性/ 的/ 评分/ 函数/ F/ ,/ top/ -/ k/ 查询/ 返回/ 表/ T/ 的/ k/ 子集/ R/ (/ k/ </ N/ )/ ,/ / ti/ ∈/ R/ ,/ / tj/ ∈/ (/ T/ -/ R/ )/ ,/ F/ (/ ti/ )/ / F/ (/ tj/ )/ ./ 通常/ ,/ m/ / 10/ [/ 7/ ]/ ./ 经典/ 的/ ThresholdAlgorithm/ (/ TA/ )/ 算法/ 要求/ 同时/ 支持/ 顺序/ 读/ 和/ 随机/ 读/ ./ TA/ 以/ round/ -/ robin/ 方式/ 读取/ m/ 个列/ 文件/ 的/ 元组/ ,/ 如果/ 元组/ t/ 第一次/ 出现/ ,/ 则/ 利用/ 随机/ 读/ 从/ 其它/ (/ m/ -/ 1/ )/ 个列/ 文件/ 中/ 获得/ t/ 的/ 其它/ 属性/ 值/ ,/ 得到/ t/ 的/ 分数/ F/ (/ t/ )/ ./ TA/ 利用/ 优先/ 队列/ PQ/ 维护/ 分数/ 最大/ 的/ k/ 个/ 元组/ ,/ 令/ PQ/ ./ min/ 表示/ PQ/ 中/ 最小/ 的/ 分数/ ./ 假设/ 所有/ 列/ 文件/ 最后/ 读取/ 的/ 元组/ 为/ (/ rid1/ ,/ a1/ )/ ,/ …/ ,/ (/ ridm/ ,/ am/ )/ ,/ 则/ TA/ 算法/ 的/ 阈值/ threshold/ 定义/ 为/ τ/ =/ F/ (/ a1/ ,/ …/ ,/ am/ )/ ./ 随着/ 列/ 文件/ 的/ 扫描/ ,/ TA/ 算法/ 不断更新/ PQ/ 和/ τ/ ./ 当/ PQ/ ./ min/ / τ/ 时/ ,/ PQ/ 维护/ 的/ 就是/ top/ -/ k/ 的/ 结果/ ,/ TA/ 算法/ 结束/ ./ 当/ m/ 个列/ 文件/ 可以/ 放入/ 内存/ 时/ ,/ TA/ 算法/ 可以/ 处理/ top/ -/ k/ 查询/ ./ 但是/ ,/ 在/ 海量/ 数据/ 环境/ 中/ ,/ 内存/ 甚至/ 无法/ 完全/ 容纳/ 单个/ 列/ 文件/ ./ 此时/ ,/ top/ -/ k/ 查询/ 的/ 列/ 文件/ 都/ 存储/ 在/ 磁盘/ ,/ 每次/ 随机/ 读/ 需要/ 完全/ 扫描/ 其他/ (/ m/ -/ 1/ )/ 个列/ 文件/ ,/ 费用/ 极高/ ./ NRA/ 算法/ 只/ 需要/ 顺序/ 读/ 就/ 可以/ 完成/ top/ -/ k/ 查询/ ./ NRA/ 以/ round/ -/ robin/ 方式/ 依次/ 读取/ m/ 个列/ 文件/ 的/ 元组/ ,/ 并且/ 维护/ 见到/ 的/ 每个/ 元组/ t/ 的/ 上界/ Fubt/ ./ Aiu/ )/ ,/ 在/ NRA/ 的/ 处理过程/ 中/ ,/ 如果/ t/ ./ Ai/ 已经/ 出现/ ,/ 则/ t/ ./ Aiu/ =/ t/ ./ Ai/ ,/ 否则/ t/ ./ Aiu/ =/ MAX/ (/ Ai/ )/ ,/ 其中/ MAX/ (/ Ai/ )/ 表示/ 属性/ Ai/ 的/ 最大值/ ;/ Flbt/ ./ Ail/ )/ ,/ 在/ NRA/ 的/ 处理过程/ 中/ ,/ 如果/ t/ ./ Ai/ 已经/ 出现/ ,/ 则/ t/ ./ Ail/ =/ t/ ./ Ai/ ,/ 否则/ t/ ./ Ail/ =/ MIN/ (/ Ai/ )/ ,/ 其中/ MIN/ (/ Ai/ )/ 表示/ 属性/ Ai/ 的/ 最小值/ ./ NRA/ 利用/ 优先/ 队列/ PQ/ 维护/ t/ 最大/ 的/ k/ 个/ 元组/ ./ NRA/ 算法/ 阈值/ τ/ 的/ 定义/ 和/ TAFlb/ 算法/ 的/ 类似/ ./ NRA/ 的/ 执行/ 分为/ 两个/ 阶段/ :/ 增长/ 阶段/ 和/ 收缩/ 阶段/ ./ 增长/ 阶段/ 利用/ Hash/ 表/ 维护/ 见到/ 的/ 候选/ 元组/ 集合/ C/ 直到/ PQ/ ./ min/ / τ/ ,/ 此时/ 我们/ 可以/ 肯定/ top/ -/ k/ 结果/ 包括/ 在/ C/ 中/ ;/ 在/ 收缩/ 阶段/ ,/ NRA/ 逐渐/ 剪切/ 候选/ 元组/ 并且/ 更新/ PQ/ ,/ 当/ PQ/ ./ min/ / Fubt/ ∈/ (/ C/ -/ PQ/ )/ )/ 时/ ,/ PQ/ 维护/ 的/ 就是/ top/ -/ k/ 的/ 结果/ ,/ NRA/ 算法/ 结束/ ./ 虽然/ NRA/ 只/ 需要/ 顺序/ 读/ 来/ 处理/ top/ -/ k/ 查询/ ,/ 但是/ 它/ 也/ 存在/ 着/ 如下/ 问题/ :/ NRA/ 在/ 增长/ 阶段/ 累积/ 候选/ 元组/ ,/ 直到/ 满足/ 给定/ 阈值条件/ ,/ 根据/ 下节/ 的/ 分析/ ,/ 这/ 使得/ 增长/ 阶段/ 将/ 维护/ 大量/ 的/ 数据/ ,/ 甚至/ 超过/ 内存容量/ ./ 此时/ ,/ NRA/ 算法/ 将/ 不得不/ 把/ 内存/ 中/ 的/ 数据/ 反复/ 输出/ 到/ 磁盘/ ,/ 这会/ 引起/ 较/ 高/ 的/ 费用/ ./ TKEP/ 算法/ 采用/ 早/ 剪切/ 的/ 方法/ 在/ 增长/ 阶段/ 就/ 执行/ 剪切/ 操作/ ,/ 从而/ 减少/ 了/ 增长/ 阶段/ 需要/ 的/ 内存/ 量/ ,/ 加快/ 了/ top/ -/ k/ 查询/ 的/ 执行/ ./ 3NRA/ 行为/ 分析/ 我们/ 先/ 给出/ 本/ 节/ 需要/ 用到/ 的/ 定义/ ./ 定义/ 1/ (/ 位置/ 索引/ )/ ./ 给定/ 表/ T/ ,/ 元组/ t/ ∈/ T/ 的/ 位置/ 索引/ PI/ (/ PositionalIndex/ )/ 是/ i/ ,/ 如果/ t/ 是/ T/ 的/ 第/ i/ 个/ 元组/ ./ 我们/ 用/ T/ (/ i/ )/ 来/ 表示/ 表/ T/ 中/ 位置/ 索引/ 为/ i/ 的/ 元组/ ./ 令/ T1/ 和/ T2/ 分别/ 表示/ 增长/ 阶段/ 和/ 收缩/ 阶段/ 每个/ 列/ 文件/ 需要/ 扫描/ 到/ 的/ 位置/ 索引/ 值/ ./ 3.1/ 节/ 介绍/ 如何/ 确定/ T1/ 和/ T2/ ,/ 3.2/ 节/ 分析/ NRA/ 在/ 增长/ 阶段/ 需要/ 维护/ 的/ 候选/ 元组/ 数/ ./ 由于/ 本文/ 重点/ 在于/ 讨论/ 早/ 剪切/ 操作/ ,/ 为/ 更/ 清晰/ 地/ 分析/ 问题/ ,/ 假设/ 评分/ 函数/ F/ 的/ 权重/ 都/ 为/ 1/ ,/ 属性/ 在/ 值域/ [/ 0/ ,/ 1/ ]/ 内/ 均匀分布/ 并且/ 属性/ 间/ 独立/ 分布/ ./ 3.1/ 确定/ 犜/ 1/ 和/ 犜/ 2/ 保守/ 地/ 估计/ ,/ 当有/ k/ 个/ 元组/ 前/ m/ 个/ 属性/ A1/ ,/ …/ ,/ Am/ 都/ 在/ 增长/ 阶段/ 出现/ 时/ ,/ 增长/ 阶段/ 结束/ ,/ 因为/ 此时/ 肯定/ 满足条件/ PQ/ ./ min/ / F/ (/ L1/ (/ T1/ )/ ./ A1/ ,/ …/ ,/ Lm/ (/ T1/ )/ ./ Am/ )/ ./ 令/ T1/ 表示/ T1/ 的/ 估计值/ ,/ T1/ 的/ 值/ 对应/ 着/ 需要/ 扫描/ m/ 个列/ 文件/ 的/ 元组/ 个数/ 使得/ 有/ k/ 个/ 元组/ 的/ 对应/ m/ 个/ 属性/ 都/ 出现/ ./ / t/ ∈/ T/ ,/ P/ (/ t/ ./ Ai/ / Li/ (/ T1/ )/ ./ Ai/ )/ =/ T1/ // N/ ,/ t/ ./ A1/ ,/ …/ ,/ t/ ./ Am/ 同时/ 分别/ 出现/ 在/ L1/ ,/ …/ ,/ Lm/ 的/ 前/ T1/ 个/ 元组/ 的/ 概率/ p/ =/ (/ T1/ // N/ )/ m/ ./ 如果/ 把/ 任意/ 元组/ t/ 的/ 前/ m/ 个/ 属性/ 出现/ 在/ 列/ 文件/ L1/ ,/ …/ ,/ Lm/ 的/ 前/ T1/ 个/ 元组/ 的/ 结果/ 看作/ 一次/ 成功/ 的/ 事件/ S/ ,/ 则/ 成功/ 的/ 次数/ 满足/ 二项式/ 分布/ BD/ (/ N/ ,/ p/ )/ ,/ 该/ 二项式/ 分布/ 的/ 期望/ 是/ Np/ ./ 要/ 获得/ T1/ 的/ 值/ ,/ 一种/ 简单/ 的/ 方法/ 是/ 令/ Np/ =/ k/ ,/ 可以/ 得出/ T1/ =/ N/ ×/ (/ k/ // N/ )/ 1/ 是/ 分布/ BD/ 的/ 方差/ 是/ Np/ (/ 1/ -/ p/ )/ ,/ 该/ 方法/ 无法/ 保证/ 能够/ 获得/ 至少/ k/ 个/ 满足条件/ 的/ 元组/ ./ 根据/ 棣/ 莫/ 弗/ -/ 拉普拉斯/ 定理/ ,/ 当/ n/ 较大/ 时/ ,/ 参数/ 为/ (/ n/ ,/ p/ )/ 的/ 二项分布/ 可以/ 很/ 好/ 地/ 近似/ 为/ 均值/ 为/ np/ 、/ 方差/ 为/ np/ (/ 1/ -/ p/ )/ 的/ 正态分布/ ./ 由于/ 海量/ 数据/ 中/ ,/ N/ 很大/ ,/ p/ =/ (/ T1/ // N/ )/ m/ 很小/ ,/ 所以/ 分布/ BD/ 可以/ 用/ 正态分布/ ND/ (/ μ/ ,/ σ/ 2/ )/ 来/ 代替/ ,/ 其中/ μ/ =/ Np/ ,/ σ/ 2/ =/ Np/ (/ 1/ -/ p/ )/ ./ 定理/ 1/ ./ T1/ =/ N/ ×/ [/ (/ -/ b/ +/ b2/ -/ 4/ 槡/ ac/ )/ // (/ 2a/ )/ ]/ 1/ 以/ 99.9968/ %/ 的/ 概率/ 保证/ 事件/ S/ 成功/ 的/ 次数/ 不少/ 于/ k/ ,/ 其中/ ,/ a/ =/ N2/ +/ 16N/ ,/ b/ =/ -/ (/ 2Nk/ +/ 16N/ )/ ,/ c/ =/ k2/ ./ 证明/ ./ 正态分布/ ND/ (/ μ/ ,/ σ/ 2/ )/ 如图/ 1/ 所示/ ./ 已知/ Page4/ 如果/ k/ =/ μ/ -/ 4/ σ/ ,/ 那么/ 以/ 99.9968/ %/ 的/ 概率/ 可以/ 保证/ 正态分布/ ND/ (/ μ/ ,/ σ/ 2/ )/ 的/ x/ 轴/ 的/ 值/ 不/ 小于/ k/ ,/ 即/ 事件/ S/ 成功/ 的/ 次数/ 不少/ 于/ k/ ./ (/ k/ =/ μ/ -/ 4/ σ/ )/ / (/ k/ =/ [/ Np/ -/ 4Np/ (/ 1/ -/ p/ 槡/ )/ ]/ )/ / (/ N2/ +/ 16N/ )/ p2/ -/ (/ 2Nk/ +/ 16N/ )/ p/ +/ k2/ =/ 0/ ./ 解/ 上述/ 一元二次方程/ 得样/ 保守/ 地/ 获得/ T2/ 的/ 估计值/ T2/ ./ 其中/ ,/ a/ =/ N2/ +/ 16N/ ,/ b/ =/ -/ (/ 2Nk/ +/ 16N/ )/ ,/ c/ =/ k2/ ./ 由/ p/ =/ (/ T1/ // N/ )/ m/ ,/ 得/ T1/ =/ N/ ×/ [/ (/ -/ b/ +/ b2/ -/ 4/ 槡/ ac/ )/ // (/ 2a/ )/ ]/ 1m/ (/ 解方程/ 时/ 我们/ 丢弃/ 了/ 另/ 一个/ 不合理/ 的/ 解/ )/ ./ 增长/ 阶段/ 结束/ 后/ ,/ NRA/ 进入/ 收缩/ 阶段/ ./ 我们/ 同/ 定理/ 2/ ./ T2/ =/ mT1/ 时/ ,/ NRA/ 算法/ 结束/ ./ 证明/ ./ 已知/ ,/ 当/ 增长/ 阶段/ 结束/ 时/ ,/ PQ/ ./ min/ / F/ (/ L1/ (/ T1/ )/ ./ A1/ ,/ …/ ,/ Lm/ (/ T1/ )/ ./ Am/ )/ ./ 在/ 收缩/ 阶段/ ,/ PQ/ ./ min/ 的/ 值/ 单调/ 递增/ ./ 令/ C/ 表示/ 增长/ 阶段/ 维护/ 的/ 候选/ 元组/ 集合/ ,/ 当/ PQ/ ./ min/ / FubNRA/ 算法/ 结束/ ./ 令/ Pm/ 表示/ 出现/ m/ 个/ 属性/ 的/ 元组/ 集合/ ./ 可以/ 肯定/ ,/ 如果/ F/ (/ L1/ (/ T1/ )/ ./ A1/ ,/ …/ ,/ Lm/ (/ T1/ )/ ./ Am/ )/ / t/ (/ / t/ ,/ t/ ∈/ (/ C/ -/ Pm/ )/ )/ ,/ PQ/ / Pm/ ,/ 则/ NRA/ 算法/ 结束/ ./ Fub/ 图/ 2/ 增长/ 阶段/ 维护/ 的/ 元组/ 个数/ 因为/ ,/ / t/ ∈/ Pm/ -/ PQ/ ,/ 必然/ 有/ PQ/ ./ min/ / F/ (/ t/ )/ ./ / t/ ∈/ (/ C/ -/ Pm/ )/ ,/ 要/ 排除/ t/ ,/ 需要/ 扫描/ m/ 个列/ 文件/ 的/ 最大/ 元组/ 数/ Tmax/ 对应/ 着/ 如下/ 情况/ :/ t/ 的/ (/ m/ -/ 1/ )/ 个/ 属性/ 取/ 最大值/ 1/ ,/ 剩余/ 一个/ 属性/ 值较/ 小/ ,/ 即/ F/ (/ L1/ (/ T1/ )/ ./ A1/ ,/ …/ ,/ Lm/ (/ T1/ )/ ./ Am/ )/ =/ (/ 1/ -/ T1/ // N/ )/ ×/ m/ / Ft/ =/ 1/ ×/ (/ m/ -/ 1/ )/ +/ (/ 1/ -/ Tmax/ // N/ )/ ,/ 解此/ 不等式/ ,/ 我们/ 得到/ Tmax/ / N/ +/ N/ ×/ (/ m/ -/ 1/ )/ -/ m/ ×/ (/ N/ -/ T1/ )/ =/ mT1/ ,/ 则/ 当/ T2/ =/ mT1/ 时/ ,/ NRA/ 算法/ 结束/ ./ 证毕/ ./ 定理/ 1/ 和/ 定理/ 2/ 证明/ T1/ 和/ T2/ 以极/ 高/ 的/ 概率/ (/ 99.9968/ %/ ,/ 根据/ 后文早/ 剪切/ 的/ 操作方法/ ,/ 实际/ 的/ 概率/ 还要/ 远高于/ 该值/ )/ 保证/ T1/ / T1/ ,/ T2/ / T2/ ,/ 所以/ 本文/ 的/ 剩余/ 部分/ 认为/ T1/ 和/ T1/ 可以/ 互换/ ,/ T2/ 和/ T2/ 可以/ 互换/ ./ 3.2/ NRA/ 在/ 增长/ 阶段/ 需要/ 维护/ 的/ 数据量/ NRA/ 算法/ 在/ 增长/ 阶段/ 不/ 对/ 元组/ 进行/ 剪切/ [/ 4/ -/ 5/ ]/ ,/ 由/ 定理/ 1/ 知/ ,/ T1/ =/ N/ ×/ p1/ // m/ ,/ p/ =/ (/ -/ b/ +/ b2/ -/ 4/ 槡/ ac/ )/ // (/ 2a/ )/ </ 1/ ,/ 则/ T1/ 的/ 值/ 随着/ m/ 的/ 增大/ 而/ 指数/ 级/ 增长/ ,/ 随着/ N/ 和/ k/ 的/ 增大/ 而/ 多项式/ 级/ 增长/ ./ 接下来/ ,/ 我们/ 分析/ 在/ 增长/ 阶段/ NRA/ 需要/ 维护/ 的/ 元组/ 数/ ,/ 从而/ 更/ 清楚/ 地/ 理解/ NRA/ 在/ 增长/ 阶段/ 所/ 需要/ 的/ 内存/ 量/ ./ / t/ ∈/ T/ ,/ P/ (/ t/ ./ Ai/ / Li/ (/ T1/ )/ ./ Ai/ )/ =/ T1/ // N/ (/ 1/ / i/ / m/ )/ ,/ 令/ NUM/ (/ t/ ,/ T1/ )/ 表示/ t/ 满足条件/ t/ ./ Ai/ / Li/ (/ T1/ )/ ./ Ai/ 的/ 属性/ 个数/ ,/ 则/ NUM/ (/ t/ ,/ T1/ )/ 满足/ 二项式/ 分布/ BD2/ (/ m/ ,/ T1/ // N/ )/ ,/ P/ (/ NUM/ (/ t/ ,/ T1/ )/ =/ m/ )/ =/ mNRA/ 在/ 增长/ 阶段/ 维护/ 的/ 元组/ 数量/ m/ (/ )/ ×/ T1/ // (/ )/ Nm/ ×/ (/ 1/ -/ T1/ // N/ )/ (/ m/ -/ m/ )/ ,/ 所以/ NUMtuple/ =/ ∑/ m/ 图/ 2/ (/ a/ )/ 说明/ 了/ 当/ N/ =/ 12/ ×/ 108/ ,/ k/ =/ 20/ 时/ ,/ 随着/ m/ 的/ 变化/ ,/ 增长/ 阶段/ 需要/ 维护/ 的/ 元组/ 数量/ ./ 可以/ 看到/ ,/ 随着/ m/ 的/ 增长/ ,/ 维护/ 的/ 元组/ 数量/ 呈/ 指数/ 级/ 增长/ ,/ Page5/ 其/ 增长/ 趋势/ 和/ T1/ 的/ 增长/ 趋势/ 一致/ ./ 图/ 2/ (/ b/ )/ 说明/ 了/ 当/ m/ =/ 4/ 时/ ,/ N/ 和/ k/ 的/ 变化/ 对/ 维护/ 元组/ 数量/ 的/ 影响/ ./ 固定/ k/ =/ 20/ ,/ 随着/ N/ 从/ 4/ ×/ 108/ 增长/ 到/ 20/ ×/ 108/ ,/ 元组/ 数量/ 基本/ 呈/ 线性/ 增长/ ;/ 固定/ N/ =/ 12/ ×/ 108/ ,/ 随着/ k/ 从/ 5/ 增长/ 到/ 25/ ,/ 元组/ 数量/ 也/ 呈/ 线性/ 增长/ ,/ 但是/ 其/ 增长速度/ 较慢/ ./ 总的来看/ ,/ 由于/ 传统/ 的/ NRA/ 算法/ 在/ 增长/ 阶段/ 不/ 执行/ 剪切/ 操作/ ,/ 在/ 海量/ 数据/ 上/ 执行/ top/ -/ k/ 查询/ 时/ ,/ 增长/ 阶段/ 维护/ 大量/ 的/ 候选/ 元组/ ,/ 从而/ 严重/ 影响/ 查询/ 的/ 执行/ 效率/ ./ 接下来/ 介绍/ TKEP/ 算法/ 如何/ 在/ 增长/ 阶段/ 执行/ 早/ 剪切/ 操作/ ./ 4TKEP/ 算法/ 本/ 节/ 主要/ 介绍/ Top/ -/ KwithEarlyPruning/ (/ TKEP/ )/ 算法/ ./ 4.1/ 节/ 给出/ 了/ 早/ 剪切/ 的/ 数学分析/ ,/ 4.2/ 节/ 介绍/ 了/ 指数/ 间距/ bloomfilter/ 表/ 的/ 构造/ ,/ 4.3/ 节/ 描述/ 如何/ 实现/ TKEP/ 算法/ ./ 4.1/ 早/ 剪切/ 的/ 数学分析/ 早/ 剪切/ 在/ top/ -/ k/ 的/ 增长/ 阶段/ 就/ 开始/ 对/ 每个/ 候选/ 元组/ 执行/ 剪切/ 操作/ ,/ 从而/ 尽可能/ 地/ 减少/ top/ -/ k/ 处理/ 需要/ 维护/ 的/ 候选/ 元组/ ,/ 同时/ 加快/ top/ -/ k/ 的/ 执行/ 速度/ ./ 早/ 剪切/ 基本/ 规则/ ./ 由/ 定理/ 2/ ,/ / t/ ∈/ C/ ,/ 如果/ / i/ (/ 1/ / i/ / m/ )/ ,/ t/ ./ Ai/ </ Li/ (/ T2/ )/ ./ Ai/ ,/ t/ 肯定/ 不是/ top/ -/ k/ 的/ 结果/ ./ 如果/ t/ 的/ 属性/ 在/ 增长/ 阶段/ 出现/ 了/ i/ 次/ ,/ t/ 无法/ 被/ 早/ 剪切/ 的/ 概率/ 是/ Pi/ 的/ 计算公式/ 解释/ 如下/ :/ 假设/ 元组/ t/ 有/ i/ 个/ 属性/ 出现/ 在/ 对应/ 列/ 文件/ 的/ 前/ T1/ 个/ 元组/ ,/ 要/ 使得/ t/ 不会/ 被/ 早/ 剪切/ ,/ 则/ t/ 的/ 其余/ m/ -/ i/ 个/ 属性/ 必须/ 全部/ 在/ 对应/ 的/ 列/ 文件/ 的/ 第/ T1/ 和/ 第/ T2/ 元组/ 之间/ 出现/ ./ 给定/ t/ ./ Ai/ / Li/ (/ T1/ )/ ./ Ai/ ,/ P/ (/ Li/ (/ T2/ )/ ./ Ai/ / t/ ./ Ai/ / Li/ (/ T1/ )/ ./ Ai/ )/ =/ (/ T2/ -/ T1/ )/ // (/ N/ -/ T1/ )/ ,/ 从而/ 得到/ Pi/ 的/ 计算公式/ ./ 令/ NUMremain/ 表示/ 候选/ 元组/ 集合/ C/ 中/ 无法/ 被/ 早/ 剪切/ 的/ 元组/ 数量/ ,/ 计算/ 如下/ :/ 利用/ NUMtuple/ 和/ NUMremain/ ,/ 早/ 剪切/ 操作/ 在/ 理论/ 上/ 可以/ 剪切/ 的/ 元组/ 个数/ NUMpru/ =/ NUMtuple/ -/ NUMremain/ ,/ 即令/ fp/ 表示/ 早/ 剪切/ 操作/ 可以/ 剪切/ 的/ 元组/ 占/ 增长/ 阶段/ 见到/ 的/ 所有/ 元组/ 的/ 比例/ ,/ fp/ =/ NUMpruNUMtuple/ =/ ∑/ m/ 所以/ 早/ 剪切/ 的/ 理论/ 效果/ 取决于/ Pi/ 的/ 取值/ ./ 利用/ 定理/ 1/ 和/ 定理/ 2/ 的/ 结果/ ,/ Pi/ =/ T2/ -/ T1N/ -/ T/ (/ )/ 1/ [/ =/ (/ m/ -/ 1/ )/ ×/ [/ (/ -/ b/ +/ b2/ -/ 4/ 槡/ ac/ )/ // (/ 2a/ )/ ]/ 1/ // m/ 其中/ ,/ a/ 、/ b/ 和/ c/ 的/ 取值/ 如/ 定理/ 1/ 所示/ ./ 可以/ 看出/ ,/ Pi/ 的/ 值/ 较/ 小/ ,/ 因为/ Pi/ ≈/ [/ (/ m/ -/ 1/ )/ ×/ (/ 2k/ // N/ )/ 1/ // m/ ]/ (/ m/ -/ i/ )/ ./ 当/ N/ =/ 12/ ×/ 108/ ,/ m/ =/ 4/ ,/ k/ =/ 20/ 时/ ,/ Pi/ =/ 0.043/ (/ 4/ -/ i/ )/ ./ 给定/ m/ ,/ 随着/ i/ 的/ 减小/ ,/ Pi/ 指数/ 级/ 地/ 减小/ ,/ 这/ 也/ 符合/ 直观/ 的/ 感觉/ ,/ 即/ 如果/ 元组/ t/ 在/ 增长/ 阶段/ 出现/ 的/ 属性/ 越/ 少/ ,/ 则/ 元组/ t/ 越/ 不/ 可能/ 是/ top/ -/ k/ 的/ 结果/ ./ 观察/ NUMi/ 的/ 计算公式/ ,/ 我们/ 发现/ 在/ 增长/ 阶段/ ,/ 绝大多数/ 的/ 元组/ 的/ 属性/ 只/ 出现/ 1/ 次/ 或者/ 2/ 次/ ,/ 即/ NUM1/ 和/ NUM2/ 的/ 值/ 比/ NUMi/ (/ 3/ / i/ / m/ )/ 要/ 大/ 很多/ ,/ 例如/ N/ =/ 12/ ×/ 108/ ,/ k/ =/ 20/ ,/ m/ =/ 4/ 时/ ,/ NUM1/ // NUMtuple/ =/ 97.87/ %/ ,/ NUM2/ // NUMtuple/ =/ 2.1/ %/ ./ 再/ 加上/ Pi/ 的/ 值/ 很小/ ,/ 尤其/ 在/ i/ 较/ 小时/ ,/ 1/ -/ Pi/ 的/ 值/ 就/ 接近/ 于/ 1/ ,/ 所以/ fp/ 的/ 值/ 接近/ 于/ 1/ ./ 这/ 就/ 意味着/ 早/ 剪切/ 算法/ 在/ 理论/ 上/ 可以/ 剪切/ 绝大多数/ 的/ 无用/ 元组/ ./ 图/ 3/ (/ a/ )/ 给出/ 了/ N/ =/ 12/ ×/ 108/ ,/ k/ =/ 20/ ,/ m/ 变化/ 时/ 的/ 剪切/ 效果/ ./ 可以/ 看到/ ,/ 剪切/ 比例/ 都/ 在/ 99/ %/ 以上/ ,/ 虽然/ 从/ m/ =/ 3/ 开始/ ,/ 剪切/ 比例/ 开始/ 降低/ ,/ 但是/ 即使/ m/ =/ 6/ 时/ ,/ 剪切/ 比例/ 仍/ 维持/ 在/ 99.59/ %/ ./ 这是/ 由于/ 随着/ m/ 的/ 增大/ ,/ T1/ 随着/ m/ 的/ 增长/ 而/ 指数/ 级/ 增加/ ,/ 给定/ N/ =/ 12/ ×/ 108/ 不变/ ,/ 增长/ 阶段/ 有/ 更/ 多/ 的/ 元组/ 找到/ 了/ 更/ 多/ 的/ 属性/ ,/ 从而/ 降低/ 了/ 剪切/ 比例/ ./ 从/ m/ =/ 2/ 到/ m/ =/ 3/ ,/ 剪切/ 比例/ 有所增加/ ,/ 这/ 是因为/ m/ =/ 2/ 时/ ,/ 早/ 剪切/ 操作/ 只能/ 剪切/ 属性/ 在/ 增长/ 阶段/ 只/ 出现/ 过/ 1/ 次/ 的/ 元组/ ,/ 而/ m/ =/ 3/ 时/ ,/ 早/ 剪切/ 操作/ 还/ 可以/ 剪切/ 属性/ 在/ 增长/ 阶段/ 出现/ 2/ 次/ 的/ 元组/ ,/ 所以/ 剪切/ 比例/ 增加/ ./ 可是/ ,/ 当/ m/ / 3/ 时/ ,/ T1/ 的/ 增加/ 对/ 剪切/ 比例/ 的/ 影响/ 超过/ 了/ 属性/ 增加/ 对/ 剪切/ 比例/ 的/ 影响/ ,/ 所以/ 此时/ 剪切/ 比例/ 开始/ 下降/ ./ Page6/ 图/ 3/ 早/ 剪切/ 的/ 理论/ 剪切/ 效果图/ 3/ (/ b/ )/ 给出/ 了/ m/ =/ 4/ ,/ k/ =/ 20/ ,/ N/ 变化/ 时/ 的/ 剪切/ 效果/ ./ 我们/ 看到/ 随着/ N/ 的/ 增大/ ,/ 剪切/ 比例/ 越来越/ 大/ ,/ 这是/ 由于/ 更大/ 的/ N/ 使得/ 属性/ 值/ 在/ 列/ 文件/ 中/ 的/ 分布/ 越/ 分散/ ,/ 从而/ 早/ 剪切/ 可以/ 剪切/ 的/ 元组/ 也/ 越来越/ 多/ ./ 通过/ 分析/ ,/ 早/ 剪切/ 操作/ 理论/ 上/ 可以/ 剪切/ 绝大多数/ 的/ 候选/ 元组/ ,/ 从而/ 大大减少/ 了/ top/ -/ k/ 处理/ 需要/ 的/ 内存/ 量/ ,/ 也/ 加快/ 了/ top/ -/ k/ 的/ 执行/ 速度/ ./ 4.2/ 指数/ 间距/ bloomfilter/ 表/ (/ EGBFT/ )/ Bloomfilter/ [/ 8/ ]/ 是/ 一种/ 简洁/ 的/ 概率/ 数据结构/ ,/ 用来/ 判断/ 给定/ 元素/ 是否是/ 集合/ 的/ 成员/ ./ 用于/ 集合/ S/ =/ {/ x1/ ,/ x2/ ,/ …/ ,/ xn/ }/ 成员/ 查询/ 的/ bloomfilter/ 实现/ 为/ 一个/ a/ 位/ 的/ 比特/ 向量/ ,/ 初始/ 时/ 每个/ 位/ 都/ 是/ 0/ ./ bloomfilter/ 用/ b/ 个/ 值域/ 为/ [/ 1/ ,/ …/ ,/ a/ ]/ 的/ 独立/ Hash/ 函数/ h1/ ,/ h2/ ,/ …/ ,/ hb/ 来/ 构建/ 和/ 探测/ bloomfilter/ ./ / x/ ∈/ S/ ,/ bloomfilter/ 的/ 第/ hi/ (/ x/ )/ (/ 1/ / i/ / b/ )/ 位设/ 为/ 1/ ./ 要/ 判断/ 给定/ 元素/ y/ 是否/ 属于/ 集合/ S/ ,/ bloomfilter/ 判断/ 是否/ 所有/ 的/ 第/ hi/ (/ y/ )/ (/ 1/ / i/ / b/ )/ 位/ 都/ 是/ 1/ ./ 如果/ 有/ 任何/ 一位/ 为/ 0/ ,/ 则/ y/ 肯定/ 不是/ S/ 的/ 元素/ ./ 否则/ ,/ bloomfilter/ 认为/ y/ 属于/ S/ ./ 当然/ ,/ 即使/ y/ 不/ 属于/ S/ ,/ bloomfilter/ 也/ 可能/ 返回/ y/ 属于/ S/ 的/ 结论/ (/ falsepositive/ )/ ./ 但是/ ,/ bloomfilter/ 对于/ 属于/ S/ 的/ 元素/ 肯定/ 返回/ 正确/ 的/ 结论/ ./ 令/ fpr/ 表示/ bloomfilter/ 固有/ 的/ falsepositiverate/ ,/ 即/ 不/ 属于/ 集合/ S/ 的/ 元素/ 被/ bloomfilter/ 误认为/ 是/ 集合/ 元素/ 的/ 概率/ ./ 给定/ b/ =/ (/ a/ ×/ ln2/ )/ // n/ 时/ ,/ falsepositiverate/ 最小/ ,/ fpr/ =/ (/ 1/ // 2/ )/ b/ ./ 下面/ 给出/ TKEP/ 用到/ 的/ 指数/ 间距/ bloomfilter/ 表/ 的/ 定义/ ./ 定义/ 2/ (/ 指数/ 间距/ bloomfilter/ 表/ )/ ./ 给定/ 包括/ N/ 个/ 元组/ 的/ 列/ 文件/ Li/ ,/ EGBFTi/ 是/ Li/ 上/ 的/ 指数/ 间距/ bloomfilter/ 表/ ,/ 如果/ EGBFTi/ 满足条件/ :/ (/ 1/ )/ |/ EGBFTi/ |/ =/ log2N/ ,/ (/ 2/ )/ EGBFTi/ (/ j/ )/ 是/ 构建/ 在/ Li/ (/ 1/ )/ 到/ Li/ (/ 2j/ )/ 的/ RID/ 属性/ 上/ 的/ bloomfilter/ ./ EGBFT/ 的/ 构造/ 如图/ 4/ 所示/ ./ 给定/ 任意/ 列/ 文件/ Li/ ,/ EGBFTi/ 占据/ 的/ 磁盘空间/ 与/ 元组/ 数量/ N/ 和/ fpr/ 有关/ ./ EGBFTi/ (/ j/ )/ 是/ 定义/ 在/ 2j/ 个/ 元素/ 上/ 的/ a/ 位/ 并且/ 具有/ b/ 个/ Hash/ 函数/ 的/ bloomfilter/ ,/ 如果/ b/ =/ (/ a/ ×/ ln2/ )/ // 2j/ ,/ fpr/ (/ falsepositiverate/ )/ 最小/ ,/ fpr/ =/ (/ 1/ // 2/ )/ b/ ./ 给定/ fpr/ 和/ 元组/ 数量/ 2j/ ,/ 我们/ 得到/ 最优/ 的/ bloomfilter/ 长度/ 已知/ ,/ |/ EGBFTi/ |/ =/ log2N/ ,/ 令/ SIZEEGBFTi/ 表示/ EGBFTi/ 占据/ 的/ 磁盘空间/ ,/ 则/ 根据/ SIZEEGBFTi/ 的/ 计算公式/ ,/ EGBFT/ 表/ 占据/ 的/ 磁盘空间/ 和/ 元组/ 数量/ 呈/ 线性关系/ ./ 由于/ 本文/ 中/ TKEP/ 采用/ 的/ fpr/ =/ 0.01/ ,/ EGBFTi/ 占据/ 的/ 磁盘空间/ 不/ 超过/ 列/ 文件大小/ 的/ 30/ %/ ./ TKEP/ 在/ 每个/ 列/ 文件/ L1/ ,/ L2/ ,/ …/ ,/ LM/ 上/ 预先/ 构建/ 各自/ 的/ EGBFT/ 表/ ./ 4.3/ 算法/ 实现/ 4.1/ 节/ 给出/ 了/ 令人/ 欣喜/ 的/ 早/ 剪切/ 的/ 理论/ 效果/ ,/ 可是/ 在/ 实际/ 中/ ,/ 理论/ 效果/ 是/ 很/ 难/ 实现/ 的/ ,/ 因为/ 它/ 要求/ Page7/ 快速/ 返回/ 任意/ 位置/ 索引/ 范围/ 的/ RID/ 集合/ 的/ 成员/ 检测/ 结果/ ./ Bloomfilter/ 是/ 一种/ 简洁/ 的/ 成员/ 检测/ 数据结构/ ,/ 考虑/ 到/ 早/ 剪切/ 涉及/ 的/ 位置/ 索引/ 范围/ 的/ 不/ 固定/ ,/ 所以/ TKEP/ 利用/ EGBFT/ 表来/ 执行/ 早/ 剪切/ 操作/ ./ 利用/ 定理/ 2/ 给出/ T2/ 的/ 值/ ,/ TKEP/ 首先/ 把/ EGBFTi/ (/ j/ )/ (/ 1/ / i/ / m/ )/ 读入/ 内存/ ,/ 其中/ j/ =/ log2T2/ ,/ 然后/ 利用/ 内存/ 中/ 维护/ 的/ bloomfilter/ 对/ 增长/ 阶段/ 碰到/ 的/ 元组/ 执行/ 早/ 剪切/ 操作/ ./ 早/ 剪切/ 的/ 代码/ 如/ 算法/ 1/ 所示/ ./ 算法/ 1/ 的/ 实际效果/ 不如/ 早/ 剪切/ 的/ 理论/ 效果/ ,/ 其/ 主要/ 原因/ 有/ 两个/ :/ (/ 1/ )/ EGBFTi/ (/ j/ )/ 涉及/ 的/ 元素/ 数量/ 要/ 大于/ T2/ ;/ (/ 2/ )/ bloomfilter/ 固有/ 的/ falsepositive/ 问题/ ./ 算法/ 1/ ./ EarlyPruning/ (/ RIDrid/ )/ ./ // // functiontestInBF/ (/ bf/ ,/ rid/ )/ isusedtodetermine/ // // whetherridiscontainedinSonwhichbloomfilter/ // // bfisconstructed/ ,/ trueisin/ ,/ falseisnot1/ ./ intindex/ =/ log2T22/ ./ fori/ =/ 1tom3/ ./ booleaninflag/ =/ testInBF/ (/ EGBFTi/ (/ index/ )/ ,/ rid/ )/ 4/ ./ if/ (/ !/ inflag/ )/ 5/ ./ returntrue/ ;/ 6/ ./ enfif7/ ./ endfor/ 图/ 5/ 早/ 剪切/ 的/ 实际/ 剪切/ 效果/ 如图/ 5/ (/ b/ )/ 所示/ ,/ 在/ N/ =/ 12/ ×/ 108/ 时/ ,/ 实际/ 剪切/ 比例/ 要/ 低于/ 其它/ 点/ 的/ 剪切/ 比例/ ,/ 这是/ 由于/ N/ =/ 12/ ×/ 108/ 时/ ,/ T2/ =/ 67738932/ 刚好/ 超过/ EGBFT/ (/ 26/ )/ ,/ TKEP/ 载入/ EGBFT/ (/ 27/ )/ 执行/ 早/ 剪切/ 操作/ ,/ EGBFT/ (/ 27/ )/ 是/ 构建/ 在/ 第/ 1/ 和/ 第/ 134217728/ 元组/ 的/ RID/ 属性/ 上/ 的/ bloomfilter/ ,/ 该/ 范围/ 几乎/ 是/ T2/ 的/ 两倍/ ,/ 所以/ N/ =/ 12/ ×/ 108/ 时/ 的/ 剪切/ 比例/ 较/ 低/ ,/ 而/ N/ 取/ 其它/ 数值/ 时/ 并/ 没有/ 出现/ 类似/ 的/ 最差/ 情况/ ./ 令/ SIZEadded/ 表示/ 需要/ 读入/ 内存/ 的/ EGBFT/ 元组/ 大小/ ,/ 则/ 8/ ./ returnfalse/ ;/ 接下来/ ,/ 我们/ 分析/ 算法/ 1/ 的/ 实际/ 剪切/ 效果/ ./ / t/ ∈/ C/ ,/ 假设/ t/ 的/ 属性/ 在/ 增长/ 阶段/ 出现/ 了/ i/ 次/ ,/ t/ 无法/ 被/ 算法/ 1/ 剪切/ 的/ 概率/ 是/ Pi/ 解释/ 如下/ :/ 假设/ 元组/ t/ 有/ i/ 个/ 属性/ A1/ ,/ …/ ,/ Ai/ 出现/ 在/ 列/ 文件/ L1/ ,/ …/ ,/ Li/ 的/ 前/ T1/ 个/ 元组/ ,/ 要/ 使得/ t/ 不会/ 被/ 算法/ 1/ 剪切/ ,/ 那么/ 给定/ (/ i/ +/ 1/ )/ / d/ / m/ ,/ 存在/ 如下/ 两种/ 情况/ :/ (/ 1/ )/ Ld/ (/ 2j/ )/ ./ Ad/ / t/ ./ Ad/ / Ld/ (/ T1/ )/ ./ Ad/ ,/ (/ 2/ )/ t/ ./ Ad/ </ Ld/ (/ 2j/ )/ ./ Ad/ ,/ 但是/ 以/ 概率/ fpr/ ,/ EGBFTd/ (/ j/ )/ 认为/ Ld/ (/ 2j/ )/ ./ Ad/ / t/ ./ Ad/ / Ld/ (/ T1/ )/ ./ Ad/ ./ 令/ fp/ 表示/ 算法/ 1/ 的/ 实际/ 剪切/ 比例/ ,/ 计算公式/ 如下/ :/ 由于/ / i/ ,/ Pi/ >/ Pi/ ,/ 所以/ fp/ </ fp/ ,/ 但是/ 算法/ 1/ 仍然/ 可以/ 较/ 好/ 地/ 完成/ 剪切/ 工作/ ./ 如图/ 5/ (/ a/ )/ 所示/ ,/ 即使/ m/ =/ 6/ 时/ ,/ 算法/ 1/ 仍然/ 可以/ 获得/ 98.4/ %/ 的/ 剪切/ 比例/ ,/ 而/ 在/ 图/ 5/ (/ b/ )/ 中/ ,/ 算法/ 1/ 最低/ 可以/ 获得/ 99.85/ %/ 的/ 剪切/ 比例/ ./ 令/ SIZEpruned/ 表示/ 早/ 剪切/ 操作/ 剪切/ 掉/ 的/ 元组/ 大小/ ,/ Ltuple/ 表示/ 每个/ 元组/ 在/ Hash/ 表中/ 占据/ 的/ 空间/ ,/ 则/ SIZEpruned/ =/ Ltuple/ ×/ ∑/ m/ 通过/ 本文/ 的/ 实验/ 可知/ ,/ 读入/ 内存/ 的/ EGBFT/ 元组/ 的/ 空间/ 比/ 剪切/ 掉/ 的/ 元组/ 占用/ 的/ 空间/ 要/ 小/ 1/ 个/ 数量级/ ,/ 而且/ ,/ 内存/ 中/ 的/ EGBFT/ 元组/ 不/ 需要/ 参与/ 任何/ 更新/ 操/ Page8/ 作/ ,/ 绝大多数/ 候选/ 元组/ 的/ 剪切/ 不但/ 节省/ 了/ 大量/ 的/ 内存空间/ ,/ 还/ 减少/ 了/ 数据/ 维护/ 和/ 更新/ 的/ 费用/ ,/ 这/ 使得/ 在/ 内存/ 中/ 维护/ EGBFT/ 的/ 代价/ 远/ 小于/ 早/ 剪切/ 带来/ 的/ 收益/ ./ TKEP/ 的/ 执行/ 代码/ 如/ 算法/ 2/ 所示/ ./ 算法/ 1/ 可以/ 较/ 好/ 地/ 执行/ 单次/ 剪切/ 操作/ ./ 可是/ ,/ 在/ 增长/ 阶段/ ,/ 如果/ 同一/ 元组/ 的/ 多个/ 不同/ 属性/ 在/ 不同/ 列/ 文件/ 出现/ ,/ 算法/ 1/ 需要/ 被/ 调用/ 多次/ ,/ 而/ 其中/ 只有/ 一次/ 剪切/ 是/ 必要/ 的/ ./ 一种/ 解决/ 方法/ 是/ 记录/ 已经/ 剪切/ 的/ 元组/ ,/ 如果/ 已/ 剪切/ 的/ 元组/ 的/ 其他/ 属性/ 再次出现/ ,/ 则/ 不/ 需要/ 再/ 执行/ 剪切/ ./ 可是/ ,/ 这样/ 会/ 增加/ 内存/ 的/ 消耗/ ,/ 违背/ 早/ 剪切/ 操作/ 的/ 初衷/ ./ TKEP/ 采用/ 的/ 方法/ 是/ :/ 即使/ 增长/ 阶段/ 出现/ 单个/ 元组/ 的/ 多个/ 属性/ ,/ TKEP/ 也/ 仍然/ 执行/ 多次/ 剪切/ 操作/ ./ 这样/ 做/ 的/ 原因/ 是/ ,/ 在/ 增长/ 阶段/ ,/ 绝大多数/ 的/ 元组/ 其/ 属性/ 只/ 出现/ 过/ 1/ 次/ 或者/ 2/ 次/ ,/ 当/ N/ =/ 12/ ×/ 108/ ,/ k/ =/ 20/ ,/ m/ =/ 4/ 时/ ,/ 增长/ 阶段/ 属性/ 数量/ 只/ 出现/ 1/ 次/ 的/ 元组/ 占/ 所有/ 元组/ 的/ 97.87/ %/ ,/ 属性/ 数量/ 值/ 出现/ 2/ 次/ 的/ 占/ 2.1/ %/ ,/ 需要/ 的/ 剪切/ 判断/ 次数/ 只/ 比/ 最优/ 情况/ 多/ 2.14/ %/ ,/ 而且/ ,/ bloomfilter/ 的/ 检测/ 操作/ 可以/ 在/ 内存/ 中/ 快速/ 执行/ ,/ 从而/ TKEP/ 可以/ 较/ 小/ 的/ 代价/ 获得/ 较大/ 的/ 收益/ ./ 算法/ 2/ ./ TKEP/ (/ L1/ ,/ …/ ,/ Lm/ ,/ F/ )/ // // PQ/ :/ priorityqueuetomaintainkhighestlowerbound/ // // C/ :/ tuplesetinhashtable1/ ./ booleanbeGrowing/ =/ true/ ;/ 2/ ./ hashtableht/ ;/ 3/ ./ loopfrom4/ ~/ 29/ ;/ 4/ ./ readnextobjectxinround/ -/ robinwayandupdate5/ ./ if/ (/ beGrowing/ )/ 6/ ./ if/ (/ earlyPruning/ (/ x/ ./ rid/ )/ )/ 7/ ./ continue/ ;/ 8/ ./ else9/ ./ Hashtable/ _/ Valuevalue/ =/ update/ _/ hashtable/ (/ ht/ ,/ 10/ ./ if/ (/ value/ ./ partialScore/ / PQ/ ./ min/ )/ 11/ ./ update/ (/ PQ/ ,/ value/ )/ 12/ ./ endif13/ ./ if/ (/ PQ/ ./ min/ / threshold/ )/ 14/ ./ beGrowing/ =/ false/ ;/ 15/ ./ endif16/ ./ endif17/ ./ else18/ ./ Hashtable/ _/ valuevalue/ =/ ht/ ./ get/ (/ x/ ./ rid/ )/ 19/ ./ if/ (/ value/ =/ =/ null/ )/ 20/ ./ continue/ ;/ 21/ ./ else22/ ./ Hashtable/ _/ Valuevalue/ =/ 23/ ./ if/ (/ value/ ./ partialScore/ / PQ/ ./ min/ )/ 24/ ./ Update/ (/ PQ/ ,/ value/ )/ 25/ ./ endif26/ ./ if/ (/ PQ/ ./ min/ / Fub27/ ./ returnPQ28/ ./ endif29/ ./ endif30/ ./ endifTKEP/ 算法/ 对/ 增长/ 阶段/ 见到/ 的/ 每个/ 元组/ 执行/ 早/ 剪切/ 操作/ ,/ 从而/ 减少/ 了/ 需要/ 维护/ 的/ 候选/ 元组/ 数量/ ./ 在/ 处理过程/ 中/ ,/ TKEP/ 不断更新/ threshold/ 和/ PQ/ ,/ 当/ PQ/ ./ min/ / threshold/ 时/ ,/ TKEP/ 离开/ 增长/ 阶段/ 进入/ 收缩/ 阶段/ ./ 由于/ 此时/ TKEP/ 维护/ 的/ 元组/ 数量/ 很少/ ,/ 所以/ 收缩/ 阶段/ 可以/ 较/ 快/ 地/ 执行/ ./ 在/ 收缩/ 阶段/ ,/ TKEP/ 采用/ 类似/ 于/ LARA/ [/ 4/ -/ 5/ ]/ 的/ 方式/ 维护/ 候选/ 元组/ 的/ 上界/ ,/ 同时/ 忽略/ 不/ 在/ 候选/ 元组/ 集合/ 中/ 的/ 元组/ ,/ 因为/ 它们/ 不/ 可能/ 是/ 最终/ 的/ top/ -/ k/ 结果/ ./ 当/ PQ/ ./ min/ / FubPQ/ )/ 时/ ,/ TKEP/ 执行/ 结束/ ,/ PQ/ 维护/ 的/ k/ 个/ 元组/ 就是/ top/ -/ k/ 的/ 最终/ 结果/ ./ 5/ 性能/ 评价/ 和/ 分析/ 5.1/ 实验/ 设置/ 本/ 节/ 通过/ 实验/ 评价/ TKEP/ 的/ 性能/ ,/ 我们/ 利用/ Java/ 语言/ 实现/ TKEP/ 和/ NRA/ 算法/ ,/ jdk/ 版本/ 为/ jdk/ -/ 6u17/ -/ windows/ -/ x64/ ,/ 实验/ 在/ HPxw8600/ 工作站/ (/ 8/ ×/ 2.8/ GHzXeonCPU/ +/ 32GB/ 内存/ +/ 1.4/ TB/ 硬盘/ +/ 64bitwindows/ )/ 上/ 执行/ ./ 实验/ 从/ 3/ 个/ 方面/ 来/ 比较/ 算法/ 的/ 性能/ :/ 元组/ 数量/ N/ 、/ 返回/ 结果/ 数量/ k/ 和/ 涉及/ 到/ 的/ 属性/ 数量/ m/ ./ 实现/ 的/ NRA/ 算法/ 结合/ 了/ 传统/ 的/ NRA/ [/ 3/ ]/ 、/ LARA/ [/ 4/ -/ 5/ ]/ 和/ TBB/ [/ 6/ ]/ 算法/ ./ 根据/ m/ 的/ 数值/ ,/ 我们/ 生成/ m/ 个/ 属性/ 的/ 表/ ,/ 每个/ 属性/ 的/ 值/ 在/ [/ 0/ ,/ 1/ ]/ 上/ 均匀分布/ ,/ 该表/ 的/ 每个/ 属性/ 单独/ 存储/ 为列/ 文件/ ,/ 同时/ 实例/ 化/ 每个/ 属性/ 所在/ 元组/ 的/ 标识符/ ,/ 列/ 文件/ 根据/ 属性/ 值/ 降序/ 排列/ 后/ 存储/ ./ 实验/ 用到/ 的/ 评分/ 函数/ F/ =/ ∑/ m/ 参数/ 默认值/ N12/ ×/ 108k20m/ 元组/ 数量/ N/ 分别/ 取值/ 4/ ×/ 108/ 、/ 8/ ×/ 108/ 、/ 12/ ×/ 108/ (/ 默认值/ )/ 、/ 16/ ×/ 108/ 和/ 20/ ×/ 108/ ,/ 返回/ 结果/ 数量/ k/ 分别/ 取值/ 5/ 、/ 10/ 、/ 15/ 、/ 20/ (/ 默认值/ )/ 和/ 25/ ,/ 属性/ 数量/ m/ 分别/ Page9/ 取值/ 2/ 、/ 3/ 、/ 4/ (/ 默认值/ )/ 、/ 5/ 和/ 6/ ./ 在/ 实验/ 中/ ,/ 我们/ 设置/ 内存/ Hash/ 表/ 维护/ 的/ 最大/ 元组/ 数量/ 是/ 4/ ×/ 107/ ,/ 此时/ 系统/ 占用/ 的/ 内存空间/ 大约/ 是/ 6G/ ./ 当/ 需要/ 维护/ 的/ 元组/ 数量/ 超过/ 该/ 数量/ 时/ ,/ 我们/ 采用/ 类似/ 于/ LARA/ 的/ 处理/ 方法/ ,/ 把/ Hash/ 表/ 的/ 元组/ 输出/ 到/ 磁盘/ ,/ 并且/ 和/ 指定/ 缓存/ 文件/ (/ 初始/ 为空/ )/ 合并/ ,/ 同时/ 更新/ PQ/ ,/ 然后/ 清空/ Hash/ 表/ ,/ 继续执行/ 接下来/ 的/ 操作/ ./ 该种/ 方法/ 可以/ 处理/ 维护/ 的/ 元组/ 数量/ 超过/ 内存/ 最大/ 容量/ 的/ 情况/ ,/ 可是/ 该/ 方法/ 延长/ 了/ top/ -/ k/ 的/ 增长/ 阶段/ 的/ 执行/ 时间/ ,/ 因为/ 在/ 两次/ 文件/ 合并/ 之间/ ,/ 当前/ Hash/ 表/ 维护/ 的/ 不是/ 增长/ 阶段/ 已经/ 看到/ 的/ 所有/ 元组/ 信息/ ,/ 而/ 只是/ 上次/ Hash/ 表/ 清空/ 后/ 看到/ 的/ 部分/ 元组/ 信息/ ,/ 只有/ 当下/ 一次/ 文件/ 合并/ 操作/ 时/ ,/ 我们/ 才/ 可以/ 更新/ 已经/ 看到/ 的/ 所有/ 元组/ 信息/ ./ 5.2/ 实验/ 1/ :/ 犖/ 的/ 效果/ 固定/ k/ =/ 20/ 和/ m/ =/ 4/ ,/ 实验/ 1/ 评价/ N/ 变化/ 时图/ 6/ 元组/ 数量/ 的/ 影响/ 图/ 6/ (/ c/ )/ 说明/ 了/ TKEP/ 和/ NRA/ 的/ 执行/ 所/ 需要/ 的/ 内存/ 量/ ,/ 平均/ 来看/ ,/ NRA/ 需要/ 的/ 内存/ 量/ 是/ TKEP/ 的/ 15.29/ 倍/ ,/ 其中/ TKEP/ 所/ 需要/ 的/ 大部分/ 内存/ 用来/ 维护/ 对应/ 的/ EGBFT/ 元组/ ,/ 因为/ 绝大多数/ 的/ 候选/ 元组/ 都/ 被/ 剪切/ 了/ ./ 从图/ 6/ (/ c/ )/ 可以/ 看到/ ,/ 在/ N/ 大于/ 8/ ×/ 108/ 时/ ,/ NRA/ 所/ 需要/ 的/ 内存/ 量/ 基本/ 不变/ ,/ 这是/ 由于/ 我们/ 限制/ 了/ 内存/ 的/ Hash/ 表/ 最/ 多/ 维护/ 4/ ×/ 107/ 个/ 元组/ ,/ 而/ TKEP/ 算法/ 的/ 性能/ ./ 如图/ 6/ (/ a/ )/ 所示/ ,/ 和/ NRA/ 算法/ 相比/ ,/ TKEP/ 获得/ 的/ 平均/ 加速/ 比是/ 16.08/ ./ 在/ 图/ 6/ (/ a/ )/ 中/ ,/ 我们/ 注意/ 到/ 当/ N/ =/ 12/ 、/ 16/ 和/ 20/ (/ ×/ 108/ )/ 时/ ,/ NRA/ 的/ 执行/ 时间/ 增长/ 的/ 幅度/ 不/ 大/ ,/ 其/ 原因/ 在于/ 此时/ 需要/ 维护/ 的/ 所有/ 元组/ 数量/ 超过/ 最大/ 限制/ ,/ 只有/ 当前/ Hash/ 表/ 的/ 部分/ 元组/ 信息/ 和/ 磁盘/ 上/ 的/ 缓存/ 文件/ 合并/ 时/ ,/ 我们/ 才/ 可以/ 获得/ 已经/ 看到/ 的/ 所有/ 元组/ 信息/ 和/ 更新/ PQ/ 的/ 信息/ ,/ 这/ 就/ 把/ 检查/ 增长/ 阶段/ 是否/ 结束/ 的/ 检测/ 推迟/ 到/ 了/ 下次/ 文件/ 合并/ 操作/ ,/ 这/ 可以/ 在/ 图/ 6/ (/ b/ )/ 中/ 得到/ 证实/ ,/ 当/ N/ =/ 12/ 、/ 16/ 和/ 20/ (/ ×/ 108/ )/ 时/ ,/ NRA/ 在/ 增长/ 阶段/ 维护/ 的/ 基本/ 相等/ 的/ 元组/ 数量/ ./ 由于/ 采取/ 早/ 剪切/ 操作/ ,/ TKEP/ 可以/ 剪切/ 掉/ 在/ 增长/ 阶段/ 见到/ 的/ 绝大多数/ 元组/ ,/ TKEP/ 维护/ 的/ 元组/ 数量/ 比/ NRA/ 维护/ 的/ 平均/ 少/ 1448.85/ 倍/ ,/ 并且/ 本文/ 对/ 早/ 剪切/ 的/ 理论/ 分析/ 结果/ 和/ 实际/ 运行/ 结果/ 相符/ ./ N/ =/ 12/ 、/ 16/ 和/ 20/ (/ ×/ 108/ )/ 时/ ,/ NRA/ 需要/ 维护/ 的/ 元组/ 数量/ 都/ 超过/ 内存/ 的/ 最大/ 限制/ ,/ 当/ N/ =/ 8/ ×/ 108/ ,/ NRA/ 需要/ 维护/ 的/ 元组/ 数量/ (/ 35913291/ )/ 虽然/ 没有/ 超过/ 可是/ 也/ 很/ 接近/ 最大/ 限制/ ./ 当/ N/ =/ 12/ 、/ 16/ 和/ 20/ (/ ×/ 108/ )/ 时/ ,/ TKEP/ 所/ 需要/ 的/ 内存/ 量/ 也/ 基本/ 相等/ ,/ 这是/ 由于/ 在/ TKEP/ 的/ 执行/ 过程/ 中/ ,/ 绝大多数/ 的/ 内存/ 是/ 用来/ 维护/ EGBFT/ 元组/ 的/ ,/ 当/ N/ =/ 12/ 、/ 16/ 和/ 20/ (/ ×/ 108/ )/ 时/ ,/ Page10TKEP/ 需要/ 维护/ 同样/ 的/ EGBFTi/ (/ 27/ )/ (/ 1/ / i/ / m/ )/ 元组/ ,/ 所以/ 需要/ 的/ 内存/ 量/ 基本/ 相等/ ./ 图/ 6/ (/ d/ )/ 比较/ 了/ 估计/ 的/ T2/ 和/ 实际/ 的/ T2/ ,/ 我们/ 发现/ T2/ >/ T2/ ,/ 从而/ 验证/ 了/ 本文/ 对/ NRA/ 的/ 行为/ 分析/ ./ 5.3/ 实验/ 2/ :/ 犽/ 的/ 效果/ 固定/ N/ =/ 12/ ×/ 108/ 和/ m/ =/ 4/ ,/ 实验/ 2/ 评价/ 返回/ 结果/ 数量/ k/ 变化/ 时/ TKEP/ 的/ 性能/ ./ 如图/ 7/ (/ a/ )/ 所示/ ,/ TKEP/ 的/ 执行/ 时间/ 平均/ 比/ NRA/ 的/ 执行/ 时间/ 快/ 20.07/ 倍/ ,/ 这是/ 由于/ TKEP/ 的/ 早/ 剪切/ 操作/ 及时/ 地/ 剪切/ 了/ 绝大多数/ 的/ 候选/ 元组/ ,/ 如图/ 7/ (/ b/ )/ ,/ TKEP/ 在/ 增长/ 阶段/ 需要/ 维护/ 的/ 元组/ 数量/ 比/ NRA/ 需要/ 维护/ 的/ 平均/ 少/ 3194.66/ 倍/ ./ 我们/ 注意/ 到/ ,/ 在/ k/ =/ 10/ 、/ 15/ 、/ 20/ 和/ 25/ 时/ ,/ NRA/ 的/ 执行/ 时间/ 基本/ 不变/ ,/ 其/ 原因/ 和/ 5.2/ 节/ 的/ 讨论/ 类似/ ,/ 此时/ NRA/ 需要/ 维护/ 的/ 元组/ 数量/ 超过/ 内存/ 的/ 最大/ 限制/ ,/ 内存/ 溢出/ 处理/ 把/ 增长/ 阶段/ 结束/ 的/ 结论/ 检查/ 推迟/ 到/ 下次/ 文件/ 合并/ 操图/ 7/ 返回/ 结果/ 数量/ 的/ 影响/ 5.4/ 实验/ 3/ :/ 犿/ 的/ 效果/ 固定/ N/ =/ 12/ ×/ 108/ 和/ k/ =/ 20/ ,/ 实验/ 3/ 评价/ 涉及/ 到/ 的/ 属性/ 数量/ m/ 变化/ 时/ TKEP/ 的/ 性能/ ./ 如图/ 8/ (/ a/ )/ 所示/ ,/ TKEP/ 的/ 执行/ 时间/ 比/ NRA/ 快/ 了/ 9.07/ 倍/ ,/ 而且/ 基本上/ 从/ m/ =/ 3/ 开始/ ,/ TKEP/ 对/ NRA/ 的/ 加速/ 比/ 在/ 逐渐/ 减小/ ./ 这是/ 由于/ 随着/ m/ 的/ 增大/ ,/ T1/ 随着/ m/ 的/ 增长/ 而/ 指数/ 级/ 增加/ ,/ 给定/ N/ =/ 12/ ×/ 作/ ,/ 使得/ NRA/ 在/ k/ =/ 10/ 、/ 15/ 、/ 20/ 和/ 25/ 时/ 维护/ 基本/ 相等/ 数量/ 的/ 元组/ ./ 更少/ 的/ 元组/ 数量/ 使得/ TKEP/ 需要/ 更少/ 的/ 内存/ ,/ 如图/ 7/ (/ c/ )/ 所示/ ,/ TKEP/ 需要/ 的/ 内存/ 量/ 比/ NRA/ 少/ 16.57/ 倍/ ,/ TKEP/ 需要/ 的/ 绝大多数/ 内存/ 是/ 用来/ 维护/ EGBFT/ 元组/ ,/ 而/ 在/ k/ =/ 5/ 、/ 10/ 和/ 15/ 时/ ,/ TKEP/ 需要/ 同样/ EGBFTi/ (/ 26/ )/ (/ 1/ / i/ / m/ )/ ,/ 所以/ 其/ 消耗/ 的/ 内存/ 量/ 基本/ 不变/ ,/ k/ =/ 20/ 和/ 25/ 时/ ,/ TKEP/ 需要/ 同样/ 的/ EGBFTi/ (/ 27/ )/ ,/ 所以/ 其内/ 存量/ 也/ 相等/ ./ 在/ k/ =/ 10/ 、/ 15/ 、/ 20/ 和/ 25/ 时/ ,/ NRA/ 消耗/ 的/ 内存/ 量/ 达到/ 内存/ 的/ 最大/ 限制/ ,/ 所以/ 内存/ 量/ 基本/ 维持/ 不变/ ./ 当/ k/ =/ 5/ 时/ ,/ NRA/ 需要/ 维护/ 的/ 元组/ 数/ (/ 38181274/ )/ 虽然/ 没有/ 超过/ 但是/ 也/ 很/ 接近/ 内存/ 最大/ 限制/ ,/ 所以/ NRA/ 在/ 这组/ 实验/ 中/ 对内/ 存量/ 的/ 消耗/ 基本/ 不变/ ./ 图/ 7/ (/ d/ )/ 比较/ 了/ 估计/ 的/ T2/ 和/ 实际/ 的/ T2/ ,/ 我们/ 发现/ T2/ >/ T2/ ,/ 从而/ 验证/ 了/ 本文/ 对/ NRA/ 的/ 行为/ 分析/ ./ 108/ 不变/ ,/ 增长/ 阶段/ 有/ 更/ 多/ 的/ 元组/ 找到/ 了/ 更/ 多/ 的/ 属性/ ,/ 从而/ 降低/ 了/ 剪切/ 比例/ ,/ 如图/ 8/ (/ b/ )/ ,/ 这/ 使得/ TKEP/ 需要/ 维护/ 更/ 多/ 的/ 元组/ ,/ 但是/ TKEP/ 维护/ 的/ 元组/ 数量/ 仍然/ 比/ NRA/ 少/ 了/ 320.56/ 倍/ ./ 如图/ 8/ (/ c/ )/ ,/ TKEP/ 需要/ 的/ 内存/ 量/ 比/ NRA/ 少/ 9.56/ 倍/ ./ 我们/ 发现/ ,/ 在/ m/ =/ 5/ 和/ 6/ 时/ ,/ NRA/ 需要/ 的/ 内存/ 量/ 超过/ 了/ 预定/ 的/ 最大/ 限制/ ,/ 这/ 是因为/ 在/ m/ =/ 5/ 时/ ,/ NRA/ 需要/ 清空/ Hash/ 表/ 5Page11/ 次/ ,/ 而/ m/ =/ 6/ 时/ ,/ NRA/ 需要/ 清空/ Hash/ 表/ 9/ 次/ ,/ 而/ Java/ 采用/ 的/ 自动/ 内存/ 回收/ 机制/ ,/ 这/ 就/ 使得/ 在/ 多次/ 反复/ 清空/ 、/ 插入/ Hash/ 表/ 操作/ 时/ ,/ 有/ 一部分/ 内存/ 没有/ 被/ Java/ 及时/ 回收/ ,/ 从而/ 造成/ NRA/ 运行/ 期间/ 内存/ 超过/ 图/ 8/ 属性/ 数量/ 的/ 影响/ 6/ 相关/ 工作/ 作为/ 多个/ 领域/ 中/ 一种/ 重要/ 的/ 数据/ 操作/ ,/ top/ -/ k/ 查询/ 得到/ 了/ 研究/ 人员/ 的/ 广泛/ 关注/ [/ 9/ ]/ ./ Bruno/ 等/ [/ 10/ ]/ 把/ top/ -/ k/ 查询/ 转换/ 为/ 数据库/ 上/ 的/ 范围/ 查询/ ,/ 从而/ 可以/ 利用/ 现有/ 数据库/ 技术/ 来/ 直接/ 回答/ top/ -/ k/ 查询/ ./ Fagin/ 等/ [/ 2/ ]/ 提出/ ThresholdAlgorithm/ (/ TA/ )/ 算法/ 处理/ 有序/ 链表/ 上/ 的/ top/ -/ k/ 查询/ ./ TA/ 算法/ 要求/ 系统/ 同时/ 支持/ 顺序/ 读/ 和/ 随机/ 读/ 操作/ ./ 相对/ 于/ TA/ 算法/ 的/ round/ -/ robin/ 读取/ 方式/ ,/ Guntzer/ 等/ [/ 11/ ]/ 提出/ Quick/ -/ Combine/ 算法/ 优先/ 读取/ 使/ 算法/ 阈值/ 下降/ 最快/ 的/ 链表/ ,/ 从而/ 加快/ 了/ TA/ 算法/ 的/ 执行/ ./ Bast/ 等/ [/ 12/ ]/ 把/ top/ -/ k/ 优化/ 问题/ 转化/ 为/ 顺序/ 读/ 和/ 随机/ 读/ 的/ 调度/ 问题/ ,/ 从而/ 获得/ 最优/ 的/ 调度/ 和/ 性能/ ./ Akbarinia/ 等/ [/ 13/ ]/ 提出/ BestPosition/ 算法/ 来/ 改进/ 传统/ 的/ TA/ 算法/ ,/ BestPosition/ 算法/ 利用/ 随机/ 读/ 过程/ 中/ 获得/ 的/ 辅助/ 信息/ 来/ 加快/ top/ -/ k/ 处理/ ./ TA/ 算法/ 要求/ 系统/ 支持/ 随机/ 读/ 操作/ ,/ 可是/ 在/ 有/ 最大/ 限制/ ./ 这/ 从/ 另/ 一个/ 方面/ 也/ 说明/ 了/ 早/ 剪切/ 操作/ 的/ 必要性/ ./ 图/ 8/ (/ d/ )/ 给出/ 了/ 估计/ 的/ T2/ 和/ 实际/ 的/ T2/ 的/ 比较/ ,/ 与/ 之前/ 的/ 分析/ 类似/ ,/ 我们/ 发现/ T2/ >/ T2/ ,/ 从而/ 验证/ 了/ 本文/ 对/ NRA/ 的/ 行为/ 分析/ ./ 些/ 情况/ 中/ ,/ 例如/ 数据流/ 和/ 海量/ 数据/ 环境/ ,/ 随机/ 读/ 操作/ 是/ 受限制/ 的/ 或者/ 不/ 可能/ 的/ ./ Fagin/ 等/ [/ 3/ ]/ 提出/ NRA/ 算法/ (/ NoRandomAccess/ )/ 来/ 处理/ 只/ 支持/ 顺序/ 读/ 环境/ 下/ 的/ top/ -/ k/ 查询/ ./ Guntzer/ 等/ [/ 14/ ]/ 提出/ 的/ Stream/ -/ Combine/ 算法/ 改进/ NRA/ 算法/ ,/ 优先/ 读取/ 使得/ 算法/ 阈值/ 下降/ 最快/ 的/ 链表/ ./ Mamoulis/ 等/ [/ 4/ -/ 5/ ]/ 通过/ 对/ NRA/ 算法/ 的/ 分析/ ,/ 把/ NRA/ 的/ 执行/ 过程/ 分为/ 增长/ 和/ 收缩/ 两个/ 阶段/ ,/ 并且/ 提出/ LARA/ 算法/ 减少/ 了/ top/ -/ k/ 处理/ 的/ 计算/ 费用/ 和/ 内存/ 需求/ ./ Bruno/ 等/ [/ 15/ ]/ 和/ Marian/ 等/ [/ 16/ ]/ 提出/ Upper/ 和/ Pick/ 算法/ 处理/ Web/ -/ accessible/ 数据库/ 的/ top/ -/ k/ 查询/ ./ Hwang/ 等/ [/ 17/ ]/ 提出/ MinimalProbing/ 算法/ 来/ 最小化/ top/ -/ k/ 查询/ 中/ 的/ 谓词/ 评价/ 费用/ ./ Pang/ 等/ [/ 6/ ]/ 提出/ TBB/ 算法/ 把/ NRA/ 的/ round/ -/ robin/ 数据/ 读取/ 过程/ 转换/ 为/ 链表/ 的/ 顺序/ 扫描/ ,/ 从而/ 提高/ 了/ 磁盘/ 效率/ ./ 另/ 一种/ 处理/ top/ -/ k/ 的/ 方法/ 是/ 利用/ 索引/ 和/ 视图/ ./ Chang/ 等/ [/ 18/ ]/ 提出/ OnionIndices/ 来/ 处理/ top/ -/ k/ 查询/ ,/ 该/ 方法/ 把/ 元组/ 看作/ 多维/ 空间/ 的/ 点/ ,/ 利用/ 预计/ 算/ 的/ 数据/ 点/ 的/ 闭/ 包来/ 回答/ top/ -/ k/ 查询/ ./ Xin/ 等/ [/ 19/ ]/ 提出/ 了/ Page12robust/ 索引/ 的/ 概念/ 来/ 加快/ top/ -/ k/ 处理/ ,/ 该/ 方法/ 把/ 元组/ 划分/ 为/ 多个/ 连续/ 的/ 层次/ ,/ 任何/ top/ -/ k/ 查询/ 可以/ 最/ 多/ 利用/ k/ 层/ 元组/ 来/ 回答/ ./ Zou/ [/ 20/ ]/ 等/ 通过/ 构建/ 支配/ 图/ 结构/ 来/ 改进/ top/ -/ k/ 查询/ 效率/ ,/ 预计/ 算/ 得到/ 的/ 支配/ 图/ 表示/ 元组/ 间/ 的/ 支配/ 关系/ ,/ top/ -/ k/ 查询/ 转换/ 为/ 图/ 的/ 遍历/ 问题/ ./ Hristidis/ 等/ [/ 21/ ]/ 和/ Das/ 等/ [/ 22/ ]/ 提出/ 利用/ 实例/ 化/ 视图/ 来/ 加快/ top/ -/ k/ 处理/ ./ 7/ 结论/ 本文/ 详细/ 地/ 分析/ 了/ NRA/ 算法/ 的/ 执行/ 行为/ ,/ 确定/ 了/ 增长/ 阶段/ 和/ 收缩/ 阶段/ 中/ 每个/ 文件/ 需要/ 扫描/ 的/ 元组/ 个数/ ./ 为/ 解决/ NRA/ 在/ 增长/ 阶段/ 维护/ 元组/ 过多/ 的/ 问题/ ,/ 本文/ 提出/ 一种/ 新/ 的/ 海量/ 数据/ 上/ 的/ top/ -/ k/ 查询/ 算法/ TKEP/ ,/ 该/ 算法/ 在/ 查询/ 的/ 增长/ 阶段/ 就/ 执行/ 早/ 剪切/ ,/ 从而/ 大大减少/ 增长/ 阶段/ 需要/ 维护/ 的/ 候选/ 元组/ ./ 本文/ 给出/ 了/ 早/ 剪切/ 操作/ 的/ 数学分析/ ,/ 证明/ 了/ 早/ 剪切/ 操作/ 的/ 理论/ 和/ 实际/ 剪切/ 效果/ ./ 实验/ 表明/ ,/ 不管/ 在/ 执行/ 时间/ 还是/ 内存/ 消耗/ 方面/ ,/ TKEP/ 比/ NRA/ 算法/ 都/ 具有/ 较大/ 的/ 优势/ ./ 本文/ 给出/ 的/ TKEP/ 算法/ 假设/ 涉及/ 到/ 的/ 属性/ 在/ 其/ 值域/ 内/ 均匀分布/ 并且/ 属性/ 间/ 独立/ 分布/ ,/ 在/ 后续/ 工作/ 中/ ,/ 我们/ 将/ 继续/ 考虑/ 把/ TKEP/ 扩展/ 到/ 属性/ 不/ 均匀分布/ 和/ 属性/ 相关/ 的/ 环境/ ./ 

