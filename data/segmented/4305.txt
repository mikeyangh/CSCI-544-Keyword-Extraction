Page1/ 面向/ 异构/ 多核/ 架构/ 的/ 自/ 适应/ 编译/ 框架/ 白秀秀/ 董小社/ 刘超/ 曹/ 海军/ 李亮/ (/ 西安交通大学/ 计算机科学/ 与/ 技术/ 系/ 西安/ 710049/ )/ 摘要/ 针对/ 应用/ 在/ 移植/ 到/ 异构/ 多核/ 高性能/ 计算机系统/ 中/ 所/ 面临/ 的/ 可移植性/ 差/ 以及/ 性能/ 优化/ 难度/ 大/ 的/ 问题/ ,/ 文中/ 提出/ 一种/ 面向/ 异构/ 多核/ 架构/ 的/ 自/ 适应/ 编译/ 框架/ ./ 通过/ 源到/ 源/ 编译/ 解决/ 传统/ 并行/ 编程/ 模型/ 应用/ 向/ 异构/ 多核/ 架构/ 的/ 映射/ 问题/ ;/ 同时/ 利用/ 动态/ 剖分/ 信息/ ,/ 自/ 适应/ 地/ 调整/ 插桩/ 并/ 配置/ 优化/ 策略/ ,/ 形成/ 迭代/ 式/ 的/ 自动/ 优化/ 过程/ ./ 文中/ 自/ 适应/ 编译/ 框架/ 将/ 软硬件/ 映射/ 机制/ 与/ 优化/ 策略/ 结合/ ,/ 有效/ 地/ 解决/ 了/ 同构/ 并行/ 应用/ 向/ 异构/ 多核/ 架构/ 的/ 移植/ 问题/ 并/ 提高/ 了/ 应用/ 的/ 整体/ 性能/ ./ 实验/ 结果表明/ ,/ 文中/ 基于/ Cell/ 架构/ 实现/ 的/ 原型/ 系统/ ,/ 很/ 好地解决/ 了/ 异构/ 多核/ 架构/ 下/ 应用/ 移植性/ 等/ 问题/ ,/ 同时/ 应用/ 性能/ 有所提高/ ./ 关键词/ 异构/ 多核/ ;/ 源到/ 源/ 编译/ ;/ 插桩/ ;/ 迭代/ 式/ 优化/ 1/ 引言/ 目前/ ,/ 功耗/ 和/ 散热/ 问题/ 限制/ 了/ 处理器/ 主频/ 的/ 提高/ ,/ 多核/ 已/ 成为/ 提高/ 系统/ 性能/ 的/ 有效/ 方法/ ,/ 其中/ 异构/ 多核/ 更是/ 高性能/ 计算技术/ 的/ 发展趋势/ ./ 异构/ 多/ 核技术/ 通过/ 在/ 片/ 上/ 简化/ 单个/ 核/ 设计/ ,/ 增加/ 了/ 专用/ 处理/ 核/ 的/ 个数/ ,/ 以较/ 小/ 的/ 成本/ 和/ 功耗/ 获得/ 更/ 高/ 的/ 计算/ 性能/ ./ Page22010/ 年/ 11/ 月/ 在/ 世界/ 超级计算机/ top500/ 中/ 位列/ 第一/ 的/ “/ 天河/ 一号/ ”/ 超级计算机/ 就是/ 采用/ CPU/ +/ GPU/ 的/ 混合/ 架构/ ,/ IBM/ 的/ Roadrunner/ 采用/ Cell/ 架构/ ,/ 而/ 目前/ 异构/ 多核/ 系统/ 面临/ 的/ 最大/ 挑战/ 是/ 编程/ 模式/ ./ Cell/ 架构/ 是/ 目前/ 异构/ 多核/ 系统/ 架构/ 的/ 典型/ 代表/ 之一/ ,/ 基于/ CellBE/ (/ CellBroadbandEngine/ )/ 架构/ 的/ Cell/ [/ 1/ -/ 2/ ]/ 提供/ 了/ 强大/ 的/ 浮点/ 计算能力/ ,/ 并/ 可/ 用于/ 科学计算/ ./ Cell/ 处理器/ 内置/ 一个/ 通用/ PPE/ (/ PowerPCProcessingElement/ )/ 和/ 8/ 个/ SPE/ (/ SynergisticPro/ -/ cessingElement/ )/ ,/ PPE/ 和/ SPE/ 具有/ 不同/ 的/ ISA/ (/ InstructionSetArchitecture/ )/ ./ Cell/ 处理器/ 的/ 计算能力/ 主要/ 来自/ SPE/ ,/ 每个/ SPE/ 有/ 256KB/ 可/ 直接/ 寻址/ 的/ 片/ 上/ 本地/ 存储/ LS/ (/ LocalStorage/ )/ ./ SPE/ 只能/ 直接/ 访问/ LS/ 中/ 的/ 数据/ 和/ 代码/ ,/ 当/ SPE/ 上/ 运行/ 的/ 计算/ 代码/ 和/ 数据/ 大小/ 超过/ 256KB/ 限制/ 时/ ,/ 需/ 将/ 部分/ 数据/ 和/ 代码/ 放在/ 片外/ 主存/ ,/ 必要/ 时/ 通过/ DMA/ (/ DirectMemoryAccess/ )/ 操作/ 从片/ 外/ 主存/ 中/ 获取/ ./ 由于/ SPE/ 的/ LS/ 存储容量/ 受限/ ,/ 因此/ 在/ CellBE/ 架构/ 下/ 的/ 编程/ 需要/ 管理/ 消息/ 编制/ ,/ 才能/ 使得/ SPE/ 执行/ 时/ 接近/ 峰值/ 吞吐量/ ./ Cell/ 的/ 另外/ 一个/ 显著/ 特征/ 是/ SPE/ 中有/ 128/ 个/ 128/ 位/ 的/ 向量/ 寄存器/ ,/ 因此/ 在/ 软件开发/ 时/ 需要/ 合理/ 编排/ 和/ 组织/ 数据/ ,/ 以便/ 最大/ 限度/ 地/ 发挥/ SPE/ 的/ 计算能力/ ./ 从/ 目前/ 应用软件/ 的/ 编程/ 模式/ 来看/ ,/ 大多数/ 编程/ 工具/ 与/ 应用/ 仍/ 是/ 基于/ x86/ 架构/ ,/ 所以/ 要/ 想/ 充分发挥/ Cell/ 架构/ 的/ 性能/ ,/ 首先/ 需要/ 解决/ 已有/ 应用程序/ 的/ 移植/ 问题/ ./ 异构/ 多核/ 的/ 出现/ 为/ 高效能/ 计算/ 系统/ 的/ 构造/ 提供/ 了/ 契机/ ,/ 但/ 其/ 显式/ 的/ 并行/ 模式/ 及/ 多级/ 的/ 存储/ 层次/ 给/ 编程/ 带来/ 困难/ ,/ 如何/ 屏蔽/ 异构/ 多核/ 底层/ 软硬件/ 环境/ ,/ 充分/ 挖掘/ 异构/ 多核/ 环境/ 下/ 应用/ 的/ 可移植性/ 及/ 性能/ 成为/ 目前/ 亟待解决/ 的/ 问题/ ./ 本文/ 提出/ 了/ 一种/ 面向/ 异构/ 多核/ 架构/ 的/ 自/ 适应/ 编译/ 框架/ ,/ 通过/ 源到/ 源/ 编译/ 解决/ 同构/ 并行程序/ 向/ 异构/ 多核/ 架构/ 的/ 移植/ 问题/ ;/ 通过/ 自/ 适应/ 调整/ 插桩/ 并/ 配置/ 优化/ 策略/ ,/ 形成/ 迭代/ 式/ 的/ 自动/ 优化/ 过程/ ,/ 将/ 软硬件/ 映射/ 机制/ 与/ 优化/ 策略/ 结合/ ,/ 充分利用/ 架构/ 提供/ 的/ 软件/ 显式/ 管理/ 资源/ 能力/ ,/ 以/ 提高/ 应用/ 性能/ ./ 本文/ 第/ 2/ 节/ 介绍/ 相关/ 领域/ 的/ 研究/ 工作/ ;/ 第/ 3/ 节/ 介绍/ 自/ 适应/ 编译/ 框架/ ;/ 第/ 4/ 节对/ 原型/ 系统/ 进行/ 测试/ 验证/ ;/ 最后/ 在/ 第/ 5/ 节中/ 进行/ 总结/ 并/ 探讨/ 下/ 一步/ 工作/ ./ 2/ 相关/ 工作/ 异构/ 多核/ 架构/ 下/ 的/ 应用/ 可移植性/ 与/ 性能/ 优化/ 问题/ ,/ 受到/ 业界/ 广泛/ 关注/ ./ 一种/ 研究/ 方法/ 是/ 在/ 较/ 高/ 抽象层次/ 使用/ 制导/ 语句/ 和/ 代码/ 分析/ 技术/ ,/ 通过/ 源到/ 源/ 编译/ 将/ 原/ 应用/ 程序代码/ 映射/ 到/ 通用/ 处理器/ 与/ 协处理器/ ./ BarcelonaSupercomputingCenter/ 的/ CellSs/ [/ 3/ ]/ 采用/ 一种/ 在/ 函数/ 级/ 支持/ 类似/ 于/ OpenMP/ 制导/ 语句/ 的/ 方式/ ,/ 实现/ 软件/ 代码/ 向/ CellBE/ 硬件/ 的/ 自动/ 编译/ 映射/ ;/ 随/ IBM/ 的/ CBESDK/ 一起/ 发布/ 的/ ALF/ 支持/ SPMD/ (/ SingleProgramMultipleData/ )/ 并行/ 模式/ ,/ 用于/ 解决/ 数据/ 并行/ 问题/ ;/ UniversityofToronto/ 的/ hiCUDA/ [/ 4/ ]/ 在/ 串行/ 程序/ 中/ 加入/ 制导/ 语句/ 标明/ 可/ 并行执行/ 的/ 代码/ ,/ 通过/ 源到/ 源/ 自动/ 映射/ 机制/ 将/ hiCUDA/ 程序转换/ 为/ GPU/ 的/ CUDA/ 程序/ ./ 针对/ 具体/ 协处理器/ 的/ 编程/ 模型/ ,/ 如/ Sequoia/ [/ 5/ -/ 7/ ]/ 、/ Merge/ [/ 8/ ]/ 等/ ./ Sequoia/ 是/ Stanford/ 面向/ CellBE/ 处理器/ 推出/ 的/ 一种/ 基于/ 内存/ 层次/ 感知/ (/ MemoryHierarchyAwareParallelProgramming/ )/ ,/ 直接/ 针对/ CellBE/ 处理器/ 存储/ 层次/ 进行/ 程序设计/ 的/ 语言/ ;/ Stanford/ 的/ Merge/ 是/ 基于/ 集成/ 现有/ 处理器/ 编程语言/ 能/ 兼容/ 多种/ 处理器/ 的/ 编程/ 框架/ ,/ 支持/ 在/ 运行/ 时/ 根据/ 任务/ 的/ 特征/ 将/ 任务/ 映射/ 到/ 协处理器/ 或/ 通用/ 处理器/ 上/ ;/ 文献/ [/ 9/ ]/ 针对/ RAxML/ 应用/ ,/ 基于/ CellBE/ 平台/ 通过/ 在/ 任务/ 并行/ 级/ 与/ 循环/ 级/ 挖掘/ 并行性/ ,/ 优化/ 存储器/ 访问/ ;/ Ohara/ 等/ 人/ [/ 10/ ]/ 提出/ 的/ MPIMicrotask/ 通过/ 将/ 任务/ 分解/ 为/ 可/ 在/ SPE/ 中/ 运行/ 的/ 微/ 任务/ 并/ 最终/ 转换/ 为流/ 处理器/ 模型/ [/ 11/ ]/ 达到/ 充分/ 挖掘/ Cell/ 计算能力/ 的/ 目的/ ./ 微软/ 提出/ 的/ Accelerator/ [/ 12/ ]/ 基于/ GPU/ 平台/ 利用/ 数据/ 并行性/ 达到/ 通用/ 目的/ 计算/ ;/ 文献/ [/ 13/ ]/ 最大/ 利用/ GPU/ 计算/ 单元/ 以及/ 隐藏/ 内存/ 访问/ 带宽/ 延迟/ ,/ 通过/ 采用/ 数据/ 分块/ 以及/ 数据/ 预取/ 等/ 技术/ 充分利用/ GPU/ 片上/ 资源/ 及/ 全局/ 内存/ 带宽/ ,/ 使/ 总体/ 应用/ 性能/ 获得/ 了/ 提升/ ./ 上述/ 编程/ 模型/ 和/ 映射/ 机制/ 主要/ 还/ 存在/ 以下/ 问题/ :/ (/ 1/ )/ 类似/ OpenMP/ 加/ 制导/ 语句/ 的/ 编程/ 模式/ 具有/ 较/ 好/ 的/ 通用性/ 和/ 扩展性/ ,/ 但/ 缺乏/ 对/ 协处理器/ 底层/ 硬件/ 特征/ 支持/ 的/ 性能/ 优化/ 策略/ ,/ 应用/ 执行/ 效率/ 差/ ,/ 不能/ 有效/ 利用/ 和/ 发挥/ 协处理器/ 的/ 性能/ ;/ (/ 2/ )/ 针对/ 底层/ 具体/ 协/ 处理/ 硬件/ 架构/ 的/ 编程/ 模型/ 可/ 获得/ 较/ 好/ 的/ 性能/ ,/ 但/ 缺乏/ 对/ 传统/ 编程/ 模型/ 的/ 支持/ ,/ 传统/ 应用/ 移植/ 困难/ ./ 因此/ ,/ 本文/ 提出/ 了/ 一种/ 基于/ 插桩/ 分析/ 的/ 自/ 适应/ 编译/ 框架/ ,/ 该/ 框架/ 通过/ 插桩/ 收集/ 信息/ ,/ 并/ 根据/ 程序/ 在/ 新型/ 系统/ 架构/ 下/ 运行/ 时/ 的/ 反馈/ 信息/ ,/ 自/ 适应/ 调整/ 插桩/ 并/ 配置/ 优化/ 策略/ ,/ 形成/ 迭代/ 式/ 的/ 优化/ 过程/ ,/ 将/ 软硬件/ 映射/ 机制/ 与/ 优化/ 策略/ 有效/ 结合/ ,/ 解决/ 了/ 异构/ 多核/ 架构/ 下/ 应用/ 的/ 移植性/ 差/ 问题/ 并/ 提高/ 了/ 整体/ 性能/ ./ Page33/ 自/ 适应/ 编译/ 框架/ 3.1/ 统一/ 架构/ 抽象/ 异构/ 多核/ 架构/ 的/ 主要/ 计算能力/ 来自/ 协/ 处理单元/ ,/ 对应/ 协/ 处理单元/ 都/ 拥有/ 各自/ 的/ 小/ 容量/ 局部/ 存储/ ,/ 数据/ 可/ 在/ 局部/ 存储/ 与/ 主存/ 之间/ 传输/ ./ 这类/ 架构/ 不同/ 处理单元/ 的/ 编程/ 环境/ 也/ 不同/ ,/ 从/ 目前/ 应用软件/ 的/ 编程/ 模式/ 来看/ ,/ 多数/ 编程/ 工具/ 与/ 应用/ 仍然/ 是/ 基于/ x86/ 架构/ ,/ 所以/ 要/ 充分发挥/ 混合/ 架构/ 的/ 性能/ ,/ 首先/ 需要/ 解决/ 已有/ 应用程序/ 的/ 移植/ 问题/ ./ 另外/ ,/ 因协/ 处理单元/ 的/ 局部/ 存储容量/ 受限/ ,/ 将/ 应用/ 映射/ 到/ 这类/ 异构/ 多核/ 架构/ 时/ ,/ 需/ 考虑/ 消息/ 的/ 编制/ 与/ 数据/ 布局/ 等/ 问题/ ./ 基于/ 这/ 类/ 异构/ 多核/ 架构/ ,/ 软硬件/ 映射/ 机制/ 需要/ 解决/ 的/ 问题/ 如下/ :/ (/ 1/ )/ 如何/ 确定/ 应用/ 中/ 的/ 计算/ 核心/ ;/ (/ 2/ )/ 若/ 将/ 计算/ 核心/ 下载/ 到协/ 处理单元/ 执行/ 时/ ,/ 如何/ 解决/ 计算/ 核心/ 在协/ 处理单元/ 的/ 编程/ 问题/ ;/ (/ 3/ )/ 由于/ 协/ 处理单元/ 的/ 局部/ 存储容量/ 受限/ ,/ 如何/ 管理/ 数据通信/ 问题/ ./ 为/ 解决/ 上述/ 问题/ ,/ 本文/ 在/ 传统/ 多核/ 存储/ 模型/ 的/ 基础/ 上/ 建立/ 以/ 协处理器/ 为/ 中心/ 的/ 层次化/ 存储/ 模型/ ,/ 对/ 异构/ 多核/ 架构/ 进行/ 了/ 抽象/ ,/ 并/ 在/ 此基础/ 上/ 研究/ 软件/ 向/ 硬件/ 的/ 映射/ 机制/ 及/ 性能/ 优化/ 方法/ ,/ 提出/ 了/ 面向/ 异构/ 多核/ 架构/ 的/ 自/ 适应/ 编译/ 框架/ ,/ 使用/ 源到/ 源/ 编译/ 转化/ 时/ 迭代/ 式/ 的/ 优化/ 方法/ 将/ 软硬件/ 映射/ 机制/ 与/ 优化/ 策略/ 相结合/ ./ 如图/ 1/ 所示/ ,/ 本文/ 建立/ 以协/ 处理单元/ 为/ 中心/ 的/ 层次化/ 存储/ 模型/ ,/ 包括/ 通用/ 处理单元/ 的/ 主存/ ,/ 协/ 处理/ 图/ 2/ 以协/ 处理单元/ 为/ 中心/ 的/ 程序执行/ 模型/ 3.2/ 总体/ 框架/ 为了/ 解决/ 异构/ 多核/ 环境/ 下/ 应用/ 可移植性/ 与/ 性能/ 优化/ 问题/ ,/ 本文/ 提出/ 一种/ 面向/ 异构/ 多核/ 的/ 自/ 适应/ 编译/ 框架/ 如图/ 3/ 所示/ ,/ 由源/ 到源/ 编译/ 、/ 自/ 适应/ 插桩/ 与/ 策略/ 分析/ 3/ 部分/ 组成/ ./ 该/ 框架/ 通过/ 源到/ 源/ 编译/ 将/ 同构/ 架构/ 下/ 应用/ 的/ 计算/ 核心/ 移植/ 到协/ 处理单元/ ,/ 并/ 负责/ 单元/ 的/ 局部/ 存储/ 和/ 寄存器/ ./ 其中/ 通用/ 处理单元/ 可以/ 自由/ 访问/ 主存/ ,/ 每个/ 协/ 处理单元/ 可以/ 自由/ 高速/ 访问/ 其/ 本地/ 的/ 局部/ 存储/ 和/ 寄存器/ ,/ 主存/ 和协/ 处理单元/ 局部/ 存储/ 之间/ 采用/ 数据总线/ 进行/ 连接/ ./ 以协/ 处理单元/ 为/ 中心/ 的/ 层次/ 存储/ 模型/ 淡化/ 了/ 主/ 存在/ 存储/ 模型/ 中/ 的/ 地位/ ,/ 将/ 数据/ 尽可能/ 多/ 的/ 置于/ 协/ 处理单元/ 的/ 局部/ 存储/ 中/ ,/ 从而/ 减少/ 访存/ 延迟/ ./ 图/ 1/ 以协/ 处理单元/ 为/ 中心/ 的/ 层次化/ 存储/ 模型/ 基于/ 上述/ 层次化/ 存储/ 模型/ ,/ 本文/ 建立/ 以协/ 处理单元/ 为/ 中心/ 的/ 程序执行/ 模型/ ,/ 如图/ 2/ 所示/ ,/ 该/ 执行/ 模型/ 在于/ 淡化/ 通用/ 处理单元/ 在/ 计算/ 中/ 的/ 地位/ ,/ 将/ 应用/ 计算/ 核心/ 下载/ 到协/ 处理单元/ 上/ 进行/ 计算/ ,/ 同时/ 对/ 局部/ 存储/ 的/ 管理/ 交由/ 协/ 处理单元/ 完成/ ,/ 而/ 将/ 系统/ 资源管理/ 与/ 控制/ 部分/ 保留/ 在/ 通用/ 处理单元/ ,/ 此外/ 从/ 应用逻辑/ 中/ 分离/ 出/ 针对性/ 能/ 优化/ 的/ 配置/ 框架/ ,/ 与/ 优化/ 库/ 结合/ 进一步/ 地/ 挖掘/ 应用/ 性能/ ./ 局部/ 存储/ 的/ 管理/ ,/ 同时/ 从/ 应用逻辑/ 中/ 分离/ 出/ 与/ 性能/ 优化/ 相关/ 的/ 配置/ 框架/ ,/ 解决/ 了/ 异构/ 架构/ 下/ 应用程序/ 的/ 可移植/ 问题/ ,/ 但/ 应用/ 性能/ 并/ 没有/ 得到/ 充分发挥/ ,/ 要/ 进一步/ 挖掘/ 应用/ 性能/ ,/ 则/ 需/ 分析/ 动态/ 剖分/ 得到/ 的/ 运行/ 时/ 信息/ ,/ 合理/ 管理/ 局部/ 存储/ 并/ 利用/ 数据/ 布局/ 对/ 生成/ 代码/ 进行/ 优化/ ./ Page4/ 各/ 模块/ 作用/ 如下/ 所述/ :/ (/ 1/ )/ 源到/ 源/ 编译/ ./ 在/ 自/ 适应/ 插桩/ 与/ 优化/ 策略/ 的/ 配合/ 下/ ,/ 完成/ 传统/ 编程/ 模型/ 的/ 应用/ 向/ 异构/ 多核/ 架构/ 的/ 映射/ 转换/ ,/ 实现/ 新型/ 系统/ 下/ 应用/ 可移植性/ ./ 在/ 映射/ 的/ 过程/ 中/ ,/ 涉及/ 到/ 确定/ 计算/ 核心/ 以及/ 将/ 其/ 移植/ 到协/ 处理单元/ 的/ 编程/ 问题/ 、/ 对/ 一些/ 支持/ 库/ 的/ 显式/ 调用/ 进行/ 封装/ 以及/ 调度/ 管理/ 插桩/ 模块/ ./ (/ 2/ )/ 自/ 适应/ 插桩/ ./ 通过/ 源到/ 源/ 编译/ 调用/ 该/ 部件/ 为/ 生成/ 代码/ 进行/ 插桩/ ,/ 收集/ 相关/ 信息/ 与/ 运行/ 时/ 反馈/ 信息/ ./ 需要/ 的/ 信息内容/ 是/ 由/ 上/ 一级/ 配置/ 框架/ 中/ 的/ 决策/ 来/ 决定/ ./ (/ 3/ )/ 策略/ 分析/ ./ 通过/ 分析/ 收集/ 到/ 的/ 相关/ 信息/ 与/ 运行/ 时/ 的/ 反馈/ 信息/ ,/ 获取/ 相关/ 决策/ ,/ 如/ 计算/ 核心/ 与/ 优化/ 策略/ ,/ 间接/ 地/ 指导/ 下次/ 的/ 源/ 到/ 源/ 编译/ 优化/ ./ 图/ 4/ 所示/ 总体/ 框架/ 的/ 工作/ 流程/ 如下/ :/ 象/ 信息/ 写入/ 到/ 寄存/ 文件/ 中/ ./ 译/ 调用/ 与/ 统计/ 对象/ 相关/ 的/ 函数/ 进行/ 预插/ 桩/ ./ (/ 1/ )/ 在/ 对/ 输入/ 源程序/ 首次/ 编译/ 时/ ,/ 由源/ 到/ 源/ 编/ (/ 2/ )/ 应用程序/ 在/ 运行/ 的/ 过程/ 中/ ,/ 将/ 收集/ 到/ 的/ 对/ (/ 3/ )/ 寄存/ 文件/ 中/ 信息/ 经/ 策略/ 分析/ 后/ 得到/ 相应/ 的/ 决策/ ./ (/ 4/ )/ 通过/ 决策/ 判断/ 应用/ 是否/ 需要/ 进一步/ 优化/ ,/ 若/ 已/ 达到/ 满意/ 程度/ 则/ 输出/ 最终/ 生成/ 优化/ 代码/ ,/ 否则/ 转到第/ (/ 5/ )/ 步/ ./ (/ 5/ )/ 配置/ 框架/ 根据/ 反馈/ 调用/ 自/ 适应/ 插桩/ 模块/ ,/ 结合/ 到/ 下次/ 源到/ 源/ 编译/ 过程/ ./ (/ 6/ )/ 回到/ 步/ (/ 2/ )/ 继续执行/ ./ 这是/ 一个/ 迭代/ 式/ 的/ 自动/ 优化/ 过程/ :/ 编译/ 运行/ 、/ 收集/ 信息/ 、/ 分析/ 信息/ 、/ 自/ 适应/ 插桩/ 、/ 编译/ 运行/ 、/ 收集/ 信息/ 继续/ 优化/ ,/ 最终/ 将/ 优化/ 策略/ “/ 固化/ ”/ 在/ 最终/ 生成/ 的/ 代码/ 中/ ./ 输入/ 源程序/ 在/ 此/ 过程/ 中/ 不断/ 地/ 演变/ ,/ 生成/ 的/ 最终/ 优化/ 代码/ 在/ 对应/ 的/ 异构/ 多核/ 架构/ 下/ 具有/ 良好/ 的/ 性能/ ./ 3.3/ 源到/ 源/ 编译/ 自/ 适应/ 编译/ 框架/ 采用/ 源到/ 源/ 编译/ 解决/ 传统/ 的/ 消息传递/ 模型/ MPI/ 或/ Pthread/ 编程/ 模型/ 的/ 应用/ 向/ 异构/ 多核/ 架构/ 映射/ 转换/ 问题/ ./ 如图/ 5/ 所示/ ,/ 在/ 应用/ 映射/ 转换/ 的/ 过程/ 中/ ,/ 源到/ 源/ 编译/ 模块/ 主要/ 负责/ 完成/ 以下/ 功能/ :/ (/ 1/ )/ 将/ 计算/ 核心/ 下载/ 到协/ 处理单元/ ,/ 应用/ 的/ 其他/ 部分/ 保留/ 在/ 通用/ 处理单元/ ,/ 由/ 主控/ 部分/ 调用/ 执行/ 计算/ 核心/ ,/ 同时/ 将/ 数据/ 拷入/ 到协/ 处理单元/ 的/ 局部/ 存储/ ./ 在/ 启动/ 计算/ 核心/ 后/ ,/ 协/ 处理单元/ 访问/ 局部/ 存储/ 的/ 数据/ ,/ 当/ 出现/ 数据/ 中断/ 时/ ,/ 由/ 消息/ 管理/ 完成/ 与/ 通用/ 处理单元/ 数据通信/ 任务/ ;/ (/ 2/ )/ 源到/ 源/ 编译/ 将/ 配置/ 框架/ 与/ 具体/ 应用逻辑/ 分离/ ./ 配置/ 框架/ 为/ 策略/ 分析/ 模块/ 与/ 自/ 适应/ 插桩/ 之间/ 的/ 接口/ ,/ 分别/ 从/ 任务/ 层/ 、/ 数据/ 层/ 与/ 存储/ 层/ 辅助/ 性能/ 优化/ ;/ (/ 3/ )/ 调度/ 管理/ 插桩/ 在/ 相邻/ 两次/ 映射/ 过程/ 起到/ 承接/ 的/ 作用/ ,/ 从而/ 使/ 整个/ 系统/ 形成/ 自/ 适应/ 编译/ 过程/ ./ 插桩/ 管理/ 部件/ 由/ signal/ (/ i/ )/ 启动/ ,/ 具体/ 如式/ (/ 1/ )/ 所示/ ./ Page5signal/ (/ i/ )/ =/ 1/ ,/ 表示/ 启动/ 相应/ 插桩/ 其中/ i/ =/ 1/ 为/ 计数/ 桩/ 获取/ 应用/ 中/ 计算/ 核心/ ,/ i/ =/ 2/ 为/ 获取数据/ 块/ 结点/ 的/ 工具/ ,/ i/ =/ 3/ 为/ 获取/ 存储/ 层/ 特征/ 的/ 工具/ ./ 后/ 两级/ 插桩/ 是否/ 启动/ 由/ 上级/ 插桩/ 的/ 程序运行/ 后/ 反馈/ 信息/ 决定/ ./ 3.4/ 自/ 适应/ 插桩/ 在/ 解决/ 了/ 应用程序/ 向/ 异构/ 架构/ 下/ 移植/ 问题/ 的/ 基础/ 上/ ,/ 需要/ 进一步/ 挖掘/ 新型/ 架构/ 下/ 的/ 应用/ 性能/ ,/ 自/ 适应/ 编译/ 框架/ 通过/ 分析/ 应用/ 自身/ 特征/ 与/ 具体/ 架构/ 结构/ 寻找/ 相关/ 优化/ 措施/ ./ 由于/ 优化/ 应用/ 性能/ 时/ 需要/ 分析/ 运行/ 时/ 信息/ ,/ 因此/ 提升/ 性能/ 是/ 一个/ 迭代/ 式/ 优化/ 过程/ ./ 如图/ 6/ 所示/ 系统/ 以/ 配置/ 框架/ 为/ 接口/ ,/ 通过/ 自/ 适应/ 插桩/ 模块/ 对/ 应用/ 进行/ 不同/ 层次/ 剖分/ 得到/ 运行/ 时/ 信息/ ,/ 进而/ 由/ 策略/ 分析/ 做出/ 相关/ 决策/ ,/ 指导/ 下/ 一级/ 优化/ ,/ 依次/ 此/ 循环/ 生成/ 最终/ 优化/ 代码/ ./ 自/ 适应/ 插桩/ 分别/ 从/ 不同/ 层次/ 对/ 应用/ 进行/ 剖分/ ,/ 包含/ 任务/ 层/ 、/ 数据/ 层/ 以及/ 存储/ 层/ ./ 前/ 两层/ 与/ 应用/ 自身/ 特征/ 相关/ ,/ 后者/ 与/ 具体/ 架构/ 结构/ 相关/ ./ 任务/ 层/ 通过/ 分析/ 应用/ 子/ 任务/ 执行/ 时间/ 及其/ 占/ 总/ 执行/ 时间/ 的/ 比例/ 得到/ 应用/ 中/ 的/ 计算/ 核心/ ./ 对于/ 大规模/ 应用/ ,/ 系统/ 可用/ 相应/ 较/ 小规模/ 数据/ 进行/ 任务/ 层/ 移植/ ,/ 从而/ 降低/ 开销/ ./ 数据/ 层/ 通过/ 分析/ 计算/ 核心/ 中/ 对应/ 数据/ 块/ 上/ 下界/ 、/ 大小/ 以及/ 访问/ 频度/ 等/ 信息/ 确定/ 数据/ 块/ 是否/ 需要/ 进一步/ 剖分/ ./ 存储/ 层/ 通过/ 分析/ 计算/ 核心/ 在/ 对应/ 内存/ 块/ 上/ 的/ 数据/ 访问/ 行为/ 以及/ 具体/ 架构/ 存储/ 结构特征/ 确定/ 应用/ 中/ 计算/ 性能/ 瓶颈/ 并/ 给出/ 优化/ 策略/ ./ 为了/ 准确/ 分析/ 存储/ 层/ 所/ 需要/ 的/ 数据/ 访问/ 行为/ 特征/ ,/ 本文/ 定义/ 流为/ 一段/ 内存/ 访问/ 元素/ 序列/ 的/ 子/ 序列/ ./ 该子/ 序列/ 中/ 任意/ 两个/ 相邻/ 元素/ 的/ 距离/ 称为/ 步长/ ./ 根据/ 流中/ 步长/ 的/ 概念/ 可以/ 分析/ 流/ 的/ 访存/ 行为/ 特征/ 并/ 对/ 其/ 进行/ 划分/ ./ 设/ 一个/ 流/ stream/ 中/ 出现/ 的/ 步长/ 为/ 离散/ 型/ 随机变量/ S/ ,/ 所有/ 步长/ 可能/ 的/ 不同/ 取值/ 为/ sk/ (/ k/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ )/ ,/ 出现/ 不同/ 步长/ {/ S/ =/ sk/ }/ 的/ 概率/ 表示/ 为/ P/ {/ S/ =/ sk/ }/ =/ pk/ (/ k/ =/ 1/ ,/ 2/ ,/ …/ ,/ n/ )/ ,/ 满足条件/ ∑/ n/ 系统/ 根据/ 概率分布/ 不同/ 对/ 访存/ 行为/ 特征/ 通过/ 下列/ 公式/ 定义/ 不同/ 的/ 流/ ,/ 其中/ ε/ 为/ 任意/ 小/ 的/ 正数/ ./ 定义/ 1/ ./ 定义/ 1/ 中/ 命题/ P/ 表示/ 一个/ 流/ 的/ 步长/ 序列/ 中/ 出现/ 一个/ 非常/ 高频率/ 的/ 非/ 零/ 步长/ sd/ ,/ 说明/ 此流/ 的/ 步长/ 稳定/ 趋于/ 此/ 步长/ ,/ 此流/ 称为/ 规则/ 流/ ,/ 其中/ sd/ 称为/ 热点/ 步长/ ./ 命题/ Q/ 表示/ 此流/ 中/ 热点/ 步长/ sd/ 为/ 1/ ,/ 这种/ 流/ 称为/ 顺序/ 流/ ./ 下列/ 用/ 命题逻辑/ 公式/ 定义/ 不同/ 流/ ./ Rregseq/ =/ P/ ∧/ Q/ ,/ Rregseq/ 为/ 真/ 表示/ stream/ 为/ 规则/ 顺序/ 流/ 烄/ Rregnon/ =/ P/ ∧/ / Q/ ,/ Rregnon/ 为/ 真/ 表示/ stream/ 为/ 规则/ 非/ 顺序/ 流/ 烅/ Rirreg/ =/ / P/ ,/ Rirreg/ 为/ 真/ 表示/ stream/ 烆/ 定义/ 2/ ./ 在/ 二级/ 插桩/ 中/ 主要/ 是/ 为了/ 检测/ 是否/ 存在/ 热点/ 步长/ sd/ ,/ 并/ 判断/ sd/ 是否/ 为/ 1/ ./ 系统/ 根据/ 定义/ 2/ 确定/ 数据/ 访存/ 行为/ 特征/ ,/ 并/ 结合/ 具体/ 架构/ 存储/ 结构特征/ ,/ 通过/ 策略/ 分析/ 模块/ 得到/ 相应/ 优化/ 策略/ ,/ 深入/ 优化/ 下载/ 到协/ 处理单元/ 上/ 的/ 计算/ 核心/ ./ 3.5/ 策略/ 分析/ 策略/ 分析/ 需/ 结合/ 底层/ 优化/ 库/ 进行/ 论述/ ,/ 本文/ 基于/ Cell/ 架构/ 层次化/ 存储/ 特点/ 与/ 协处理器/ 存储/ 访问/ 方法/ ,/ 提供/ 了/ 一个/ 访存库/ [/ 14/ ]/ ,/ 其中/ 包括/ 4/ 种访存/ 方式/ ,/ 针对/ 应用/ 的/ 不同/ 访存/ 特征/ 选取/ 最/ 有效/ 的/ 方式/ 以/ 提高/ 应用/ 性能/ ./ 这/ 4/ 种访存/ 方式/ :/ 批量/ 访存/ 、/ 单/ 缓冲/ 、/ 四路/ 缓冲/ 和/ 组/ 相联/ ,/ 后/ 3/ 种/ 统称/ 为/ 按/ 需访存/ ./ 与/ 按/ 需访存/ 相关/ 的/ 缓冲区/ 参数/ 有/ 组数/ 、/ 路数/ 和/ 块/ 的/ 大小/ ./ 面向/ Cell/ 架构/ 的/ 迭代/ 式/ 优化/ 过程/ 中/ ,/ 系统/ 首先/ 确定/ 计算/ 核心/ 中访存/ 变量/ 采用/ 哪类/ 访存/ 方式/ 性能/ 最优/ ,/ 判定/ 过程/ 中/ 采用/ 命题演算/ 方法/ ;/ 若/ 采用/ 按/ 需访存/ ,/ 则/ 根据/ 基于/ 离线/ 的/ 经验/ 搜索/ 制定/ 的/ 规则/ 确定/ 其/ 缓冲区/ 的/ 参数/ ,/ 完成/ 存储/ 层/ 优化/ ,/ 进一步提高/ 应用/ 性能/ ./ 3.5/ ./ 1/ 数据/ 层/ 优化/ 系统/ 根据/ 数据/ 层剖分/ 信息/ 对/ 计算/ 核心/ 的/ 访存/ 变量/ 确定/ 其访存/ 方式/ ./ 一个/ 计算/ 核心/ 的/ 每个/ 数据/ 块/ 大小/ 表示/ 为/ Size/ (/ k/ )/ (/ k/ =/ 1/ ,/ 2/ ,/ …/ ,/ m/ )/ ,/ 其中/ m/ 表示/ 数据/ 块/ 的/ 块/ 数/ ,/ 数据/ 块/ 总/ 大小/ 为/ AllSize/ =/ ∑/ m/ 处理器/ SPE/ 上/ 局部/ 存储空间/ 用/ LS/ 表示/ ,/ 其中/ LS/ =/ 256KB/ ,/ 除去/ 计算/ 任务/ 代码/ 所/ 占/ 空间/ LSc/ ,/ 剩余/ 空/ Page6/ 间/ 记为/ LSd/ ./ 访存/ 策略/ 用/ MemStrategy/ (/ i/ )/ (/ i/ =/ 1/ ,/ 2/ ,/ 3/ ,/ 4/ )/ 表示/ ,/ 式/ (/ 4/ )/ 中/ 具体/ 指定/ 不同/ 的/ 访存/ 方式/ ./ 式/ (/ 5/ )/ 中/ 命题/ T/ 表示/ 访存/ 区域/ 小于/ 除去/ 代码/ 所/ 占/ 空间/ 的/ 局部/ 存储空间/ ,/ 若/ 计算/ 核心/ 中/ 的/ 访存/ 区域/ 不/ 确定/ ,/ 则/ 表示/ 为/ Tunk/ ./ 规则/ 1/ ./ 策略/ 分析/ 模块/ 根据/ 规则/ 1/ 采用/ 命题演算/ 选择/ 合适/ 的/ 访存/ 方式/ ,/ 如式/ (/ 6/ )/ 所示/ ./ 批量/ 访存/ 适用/ 于/ 访存/ 区域/ 小于/ 协/ 处理单元/ LSd/ ;/ 按/ 需访存/ 适用/ 于/ 访存/ 区域/ 大于/ LSd/ 或/ 无法/ 确定/ 的/ 情况/ ./ 对于/ 按/ 需访存/ ,/ 则/ 需/ 进一步/ 判断/ 参数/ 的/ 访问/ 特征/ ,/ 若/ 是/ 规则/ 顺序/ 流/ ,/ 则/ 采用/ 单/ 缓冲/ 方式/ ;/ 若/ 是/ 规则/ 非/ 顺序/ 流/ ,/ 且/ 在/ 访存/ 区域/ 很大/ 的/ 情况/ 下/ 采用/ 四路/ 缓冲/ 方式/ ,/ 否则/ 采用/ 组/ 相联/ 方式/ ;/ 若/ 是非/ 规则/ 流/ ,/ 则/ 选取/ 组/ 相联/ 方式/ ./ T/ →/ MemStrategy/ (/ 1/ )/ 烄/ (/ / T/ ∧/ Rregseq/ )/ ∨/ (/ Tunk/ ∧/ Rregseq/ )/ →/ MemStrategy/ (/ 2/ )/ (/ T2/ ∧/ Rregnon/ )/ →/ MemStrategy/ (/ 3/ )/ 烅/ (/ T1/ ∧/ Rirreg/ )/ ∨/ (/ Tunk/ ∧/ Rirreg/ )/ ∨/ (/ Tunk/ ∧/ Rregnon/ )/ →/ MemStrategy/ (/ 4/ 烆/ 3.5/ ./ 2/ 存储/ 层/ 优化/ 对于/ 按/ 需访存/ ,/ 若/ 将/ 代码/ 和/ 数据/ 直接/ 放入/ LS/ 可能/ 会/ 导致/ 程序运行/ 崩溃/ ,/ 只能/ 将/ 计算/ 函数/ 分为/ 多个/ 计算/ 单元/ Cu/ ,/ 调用/ 过程/ 中/ 按照/ Cu/ 对/ 数据/ 的/ 需求/ 通过/ DMA/ 操作/ 按/ 需/ 若干次/ 将/ 数据/ 读入/ LS/ 的/ 数据/ 缓冲区/ 中/ ./ 策略/ 分析/ 模块/ 对/ 其/ 缓冲区/ 的/ 组数/ 、/ 路数/ 、/ 块/ 大小/ 进行/ 配置/ ,/ 分别/ 用/ 参数/ set/ 、/ way/ 、/ line/ 表示/ ./ 由于/ Cell/ 架构/ 中/ 一次/ DMA/ 操作/ 的/ 传输/ 上限/ 为/ 16KB/ ,/ 且/ 要求/ 至少/ 是/ 16/ 字节/ 对齐/ ./ 因此/ ,/ 可/ 得到/ 如式/ (/ 7/ )/ 的/ 初始条件/ ./ bufferSize/ =/ (/ 1/ / set/ )/ ×/ (/ 1/ / way/ )/ ×/ (/ 1/ / line/ )/ 烄/ bufferSize/ </ 256KB/ 烅/ lineSize/ =/ 1/ / line/ 烆/ 16B/ / lineSize/ / 由式/ (/ 7/ )/ 可/ 得/ ,/ 组/ 相联/ 方式/ 通过/ 使用/ 软件/ 的/ 方法/ 在/ LS/ 中/ 建立/ 一个组/ 相联/ 的/ 缓存/ ,/ 可以/ 提高/ 细粒度/ 的/ 非/ 规则/ 应用/ 的/ 数据/ 复用/ 机会/ ./ 在/ 我们/ 提供/ 的/ 组/ 相联/ 缓存/ 中/ ,/ 设定/ 每组/ 有/ 4/ 路/ (/ way/ =/ 2/ )/ ,/ 缓存/ 查找/ 表中/ 一个组/ 的/ 4/ 路/ 放到/ 一个/ 矢量/ 中/ ,/ 这样/ 主存/ 中/ 的/ 一块/ 可以/ 映像/ 到/ 缓存/ 的/ 这/ 4/ 路中/ ./ 单/ 缓冲/ 方法/ 在/ LS/ 中/ 设定/ 一个/ 缓冲区/ ,/ 在/ 数据/ 访问/ 点/ 检查/ 所/ 需/ 的/ 数据/ 是否/ 在/ 缓冲区/ 中/ ,/ 若/ 不/ 在/ 则/ 使用/ DMA/ 操作/ 从/ 主存/ 读取/ 一个/ 缓冲区/ 的/ 数据/ 放入/ 缓冲区/ ./ 对于/ 规则/ 非/ 顺序/ 访存/ 时/ ,/ 在/ 单/ 缓冲区/ 的/ 基础/ 上/ 建立/ 4/ 个/ 缓冲区/ ,/ 当/ SPE/ 使用/ 其中/ 一个/ 缓冲区/ 的/ 数据/ 时/ ,/ 其余/ 缓冲区/ 利用/ 异步/ DMA/ 操作/ 读取/ 将要/ 使用/ 的/ 数据/ ./ 根据/ 以上/ 要求/ ,/ 系统/ 按照/ 规则/ 2/ 对/ 缓冲区/ 参数/ 进行/ 预设/ ./ 由此/ 确定/ 这/ 3/ 种/ 按/ 需访存/ 参数/ (/ set/ ,/ way/ ,/ line/ )/ 的/ 取/ 值域/ ,/ 如式/ (/ 9/ )/ 、/ (/ 10/ )/ ./ MemStrategy/ (/ i/ )/ →/ CacheConf/ (/ i/ ,/ set/ ,/ way/ ,/ line/ )/ CacheConf/ (/ )/ =/ 规则/ 2/ ./ i/ =/ 2/ ,/ set/ =/ 0/ ,/ way/ =/ 0/ ,/ 4/ / line/ / 14/ 烄/ i/ =/ 3/ ,/ set/ =/ 0/ ,/ way/ =/ 2/ ,/ 4/ / line/ / 12/ 烅/ i/ =/ 4/ ,/ 0/ / set/ / 11/ ,/ way/ =/ 2/ ,/ 4/ / line/ / 14/ ,/ 烆/ set/ +/ line/ / 协处理器/ SPE/ 启动/ 时/ ,/ 将/ 一个/ 计算/ 核心/ 代码段/ 与/ 相关/ 数据/ 段/ 调入/ SPE/ 的/ 局部/ 存储/ LS/ 中/ ./ 因此/ ,/ 在/ 需要/ 缓存/ 策略/ 配置/ 时/ ,/ 需要/ 综合/ 考虑/ 该/ 计算/ 函数/ 的/ 几个/ 数据/ 块/ 访问/ 区域/ ,/ 设/ 一个/ 计算/ 核心/ 有/ varNo/ 个/ 访存/ 参数/ ,/ 那么/ 须/ 满足/ varNo/ ×/ bufferSize/ </ 256KB/ ./ 在/ 符合/ 上述/ 条件/ 的/ 前提/ 下/ ,/ 缓冲区/ 设置/ 的/ 越/ 大/ 性能/ 越/ 好/ ,/ 因此/ 单/ 缓冲/ 与/ 四路/ 缓冲/ 参数/ 便/ 可/ 设定/ ./ 针对/ 组/ 相联/ 的/ 情况/ ,/ 系统/ 还/ 需/ 考虑/ 组数/ 与/ 块/ 大小/ 之间/ 的/ 平衡/ 关系/ ./ 本文/ 采用/ 了/ 基于/ 离线/ 的/ 经验/ 搜索/ ,/ 由源/ 到源/ 编译/ 生成/ 与/ 具体/ 应用逻辑/ 分离/ 的/ 策略/ 配置文件/ ,/ 针对/ 不同/ 的/ 参数/ 配置/ ,/ 形成/ 一个/ 最佳/ 策略/ 的/ 搜索/ 空间/ ,/ 对/ 其/ 进行/ 系统化/ 观测/ ,/ 找到/ 最优/ 配置/ 方案/ ,/ 并/ 制定/ 出/ 相应/ 的/ 规则/ ./ 应用程序/ 移植/ 过程/ 中/ 根据/ 该/ 规则/ 进行/ 存储/ 层/ 优化/ ./ 如图/ 7/ 所示/ ,/ 在/ Cell/ 平台/ 上/ ,/ 512/ ×/ 512/ 的/ 单精度/ 浮点/ 矩阵/ 乘法/ 中/ 对/ 分块/ B/ 使用/ 组/ 相联/ 方式/ ,/ 通过/ 调整/ 组数/ 与/ 块/ 大小/ 来/ 调整/ 缓冲区/ 总/ 大小/ ./ 经过/ 分析/ 获得/ 以下/ 3/ 条/ 原则/ :/ (/ 1/ )/ 缓冲区/ 容量/ 越大/ ,/ 应用/ 的/ 计算/ 性能/ 越/ 好/ ;/ (/ 2/ )/ 对于/ 不同/ 分块/ 大小/ 的/ 计算/ ,/ 当/ 缓冲区/ 的/ 容量/ 小于/ 分块/ 大小/ 的/ 四分之一/ ,/ 组数/ 为/ 1/ (/ set/ =/ 0/ )/ 时/ 即可/ 得到/ 较优/ 性能/ ;/ (/ 3/ )/ 当/ 缓冲区/ 的/ 容量/ 达到/ 分块/ 大小/ 的/ 四分之一/ 或/ 二分之一/ 时/ ,/ 调整/ 组数/ 计算/ 性能/ 得到/ 很大/ 的/ 改善/ ;/ 当/ 缓冲区/ 的/ 容量/ 超过/ 分块/ 大小/ 的/ 二分之一/ 时/ ,/ 调整/ 组数/ 对/ 计算/ Page7/ 性能/ 影响/ 不大/ ./ 本文/ 使用/ 的/ 四路/ 组/ 相联/ ,/ 当/ 缓冲区/ 容量/ 达到/ 分块/ 大小/ 的/ 四分之一/ ,/ 可以/ 得到/ 很/ 好/ 的/ 性能/ ./ 根据/ 以上/ 原则/ 制定/ 出/ 指导/ 存储/ 层/ 优化/ 的/ 规则/ 3/ 如式/ (/ 11/ )/ ~/ (/ 13/ )/ 所示/ ,/ 其中/ mostStep/ (/ k/ )/ (/ k/ =/ 1/ ,/ 2/ ,/ …/ ,/ m/ )/ 为/ 数据/ 块/ 中/ 出现/ 概率/ 最大/ 的/ 步长/ ,/ 系统/ 根据/ 数据流/ 的/ 特征/ 调节/ 缓存/ 大小/ 以及/ 组内块/ 大小/ 以/ 利用/ 空间/ 局部性/ ,/ 从而/ 有效/ 降低/ 缓存/ 的/ 失效率/ ,/ 提高/ 性能/ ./ 通常/ 情况/ 下/ ,/ 当/ 一个组/ 内块/ 总/ 大小/ 达到/ 数据流/ 最大/ 概率/ 步/ 长大/ 小时/ ,/ 性能/ 达到/ 最优/ ./ 在/ 应用/ 移植/ 的/ 过程/ 中/ ,/ 系统/ 根据/ 规则/ 2/ 与/ 规则/ 3/ 对/ 存储/ 层/ 进行/ 优化/ ,/ 进一步提高/ 应用/ 性能/ ./ 规则/ 3/ ./ bufferSize/ =/ 1/ / (/ ceil/ (/ log2Size/ (/ k/ )/ // 4/ )/ )/ 烄/ 2blockNo/ -/ 1/ </ mostStep/ (/ k/ )/ / 2blockNo/ 烅/ lineSize/ ×/ 2way/ =/ 2blockNo/ ×/ sizeof/ (/ type/ _/ data/ 烆/ 4/ 验证/ 与/ 测试/ 4.1/ 实验/ 环境/ 本文/ 基于/ PS3/ (/ PlayStation3/ )/ 平台/ 对/ 提出/ 的/ 面向/ 异构/ 多核/ 架构/ 的/ 自/ 适应/ 编译/ 框架/ 进行/ 了/ 测试/ 验证/ ./ PS3/ 配置/ 了/ 工作/ 主频/ 为/ 3.2/ GHzCell/ 处理器/ ,/ 包含/ 一个/ PPE/ 与/ 6/ 个/ SPE/ ,/ 256MB/ 主存/ ,/ 每个/ SPE/ 配备/ 256KB/ 本地/ LS/ ;/ 操作系统/ 为/ FedoraCore6/ ,/ 软件/ 环境/ 为/ CBESDK2/ ./ 0.4/ ./ 2/ 实验/ 结果/ 本文/ 测试/ 结合/ 已有/ 访存库/ 验证/ 自/ 适应/ 编译/ 框架/ 的/ 有效性/ 和/ 通用性/ ./ 实验/ 中/ 采用/ 了/ 6/ 类/ 测试用例/ 包含/ 基数排序/ (/ radixSort/ )/ 、/ 基于/ 距离/ 的/ 迭代/ 聚类/ 算法/ (/ k/ -/ means/ )/ 、/ 分块/ 矩阵/ 相乘/ (/ BMM/ )/ 、/ 分块/ 稀疏/ 矩阵/ LU/ 分解/ 、/ n/ -/ body/ 问题/ (/ 采用/ PP/ 算法/ )/ 、/ MolecularDynamics/ 分子/ 动力学/ 模拟/ (/ MD/ )/ ./ 这些/ 程序/ 在/ 不同/ 领域/ 有所/ 应用/ ,/ 如/ 科学计算/ 、/ 数据挖掘/ 、/ 物理学/ 及/ 流体/ 动力学/ 等/ ./ 表/ 1/ 给出/ 了/ 这/ 6/ 类/ 测试用例/ 的/ 问题/ 规模/ ./ 实验/ 采用/ 程序执行/ 时间/ 为/ 评价/ 标准/ ./ 测试用例/ radixSortk/ -/ meansBMMLUn/ -/ bodyMD4/ ./ 2.1/ 系统/ 性能/ 测试/ 与/ 有效性/ 分析/ 本文/ 在/ Cell/ 架构/ 实验/ 平台/ 下/ 对/ 自/ 适应/ 编译/ 过程/ 的/ 3/ 个/ 阶段/ 进行/ 评测/ ,/ 最终/ 优化/ 结果/ 与/ 采用/ IBM/ 提供/ 的/ CBESDK/ 默认/ 方式/ 的/ 结果/ 对比/ ,/ 从而/ 验证/ 本文/ 提出/ 的/ 自/ 适应/ 编译/ 框架/ 的/ 有效性/ ./ 自/ 适应/ 编译/ 框架/ 中/ 任务/ 层/ 移植/ 将/ 程序/ 中/ 计算/ 核心/ 移植/ 到协/ 处理单元/ ,/ 解决/ 应用/ 面向/ 异构/ 多核/ 架构/ 的/ 移植/ 问题/ ;/ 数据/ 层/ 优化/ 根据/ 应用/ 特征/ 对/ 应用/ 进行/ 优化/ ;/ 存储/ 层/ 优化/ 结合/ 具体/ 架构/ 的/ 存储/ 特征/ 对/ 应用/ 进行/ 优化/ ./ 因此/ ,/ 输入/ 源程序/ 最/ 多/ 需要/ 迭代/ 三次/ 便/ 可/ 生成/ 最终/ 的/ 优化/ 代码/ ./ 如图/ 8/ 性能/ 评测/ 中/ ,/ 前/ 2/ 类/ 应用/ radixSort/ 与/ k/ -/ means/ 采用/ 小规模/ 数据/ 集/ 进行/ 测试/ ,/ 完成/ 任务/ 层/ 移植/ 及/ 数据/ 层/ 优化/ 后/ ,/ 经/ 系统/ 的/ 策略/ 分析/ 模块/ 根据/ Page8/ 相应/ 规则/ 判断/ 出/ 不/ 需要/ 进行/ 存储/ 层/ 优化/ ,/ 因为/ 小规模/ 数据/ 集可/ 一次性/ 存入/ 局部/ 存储/ ,/ 系统/ 不需/ 对/ 存储/ 层/ 进行/ 分析/ ./ 从图/ 8/ 中/ 可以/ 看出/ ,/ radixSort/ 与/ k/ -/ means/ 经/ 数据/ 层/ 优化/ 后/ 的/ 性能/ 与/ 采用/ IBM/ 默认/ 设定/ 的/ 访存/ 方式/ 相比/ 分别/ 提高/ 25/ %/ 与/ 27/ %/ ./ 测试用例/ BMM/ 、/ LU/ 、/ n/ -/ body/ 及/ MD/ 采用/ 大规模/ 数据/ 集/ 进行/ 测试/ ,/ 系统/ 完成/ 任务/ 层/ 移植/ 与/ 数据/ 层/ 优化/ 后/ ,/ 经/ 策略/ 分析/ 模块/ 做出/ 相应/ 的/ 决策/ ,/ 即/ 应用/ 性能/ 可/ 通过/ 存储/ 层/ 优化/ 进一步提高/ ./ 这/ 是因为/ 对于/ 大规模/ 数据/ 需/ 分批/ 存入/ 局部/ 存储/ ,/ 系统/ 可/ 根据/ 数据流/ 特征/ 重新/ 组织/ 映像/ 方式/ 的/ 结构/ ,/ 可/ 有效/ 降低/ 缓存/ 失效率/ ,/ 从而/ 提高/ 性能/ ./ 从图/ 8/ 中/ 可以/ 看出/ ,/ 应用/ 通过/ 存储/ 层/ 优化/ 后/ 与/ 只/ 进行/ 数据/ 层/ 优化/ 后/ 性能/ 相比/ 平均/ 提高/ 21/ %/ ,/ 从而/ 验证/ 了/ 存储/ 层/ 优化/ 对/ 采用/ 大规模/ 数据/ 的/ 应用/ 是/ 有效/ 的/ ./ 这/ 4/ 类/ 应用/ 最终/ 优化/ 后/ 的/ 性能/ 较/ IBM/ 默认/ 设定/ 的/ 访存/ 方式/ 平均/ 提高/ 32/ %/ ./ 系统/ 中/ 数据/ 层/ 优化/ 根据/ 计算/ 核心/ 访存/ 变量/ 的/ 特征/ ,/ 选取/ 合适/ 访存/ 方式/ ,/ 充分利用/ 协/ 处理单元/ 中/ 有限/ 的/ 局部/ 存储空间/ ,/ 提高/ 计算/ 性能/ ./ 从图/ 8/ 中/ 可以/ 看出/ ,/ 前/ 5/ 类/ 应用/ 通过/ 数据/ 层/ 优化/ 后/ 性能/ 与/ 采用/ IBM/ 默认/ 设定/ 的/ 访存/ 方式/ 相比/ 平均/ 提高/ 24/ %/ ,/ 从而/ 验证/ 了/ 数据/ 层/ 优化/ 的/ 有效性/ ./ 而/ MD/ 通过/ 数据/ 层/ 优化/ 后/ 性能/ 不如/ IBM/ 默认/ 设定/ 的/ 访存/ 方式/ 的/ 性能/ ,/ 这/ 是因为/ MD/ 相对/ 其他/ 5/ 类/ 应用程序/ 中/ 存在/ 大量/ 3.4/ 节/ 定义/ 的/ 非/ 规则/ 流/ 导致/ 的/ ./ 系统/ 根据/ 数据/ 层剖分/ 信息/ 分析/ 出/ ,/ MD/ 程序/ 在/ 计算/ 过程/ 中/ 内存/ 访问/ 步长/ 很/ 不/ 稳定/ ,/ 根据/ 规则/ 1/ 判断/ 出/ 这些/ 访问/ 变量/ 需/ 使用/ 组/ 相联/ 映像/ 方式/ ,/ 而/ 对于/ 大量/ 非/ 规则/ 流/ 使用/ 固定/ 规模/ 的/ 组/ 相联/ 方式/ ,/ 不能/ 很/ 好/ 的/ 降低/ 缓存/ 失效率/ ,/ 从而/ 导致/ MD/ 程序/ 经过/ 数据/ 层/ 优化/ 后/ 性能/ 改进/ 不/ 明显/ ./ 存储/ 层/ 优化/ 对于/ 组/ 相联/ 映像/ 方式/ 可/ 根据/ 非/ 规则/ 流/ 的/ 特征/ 通过/ 调节/ 缓存/ 大小/ 以及/ 组内块/ 大小/ ,/ 利用/ 空间/ 局部性/ 有效/ 降低/ 缓存/ 的/ 失效率/ 进一步提高/ 性能/ ./ 因此/ 对于/ 这/ 类/ 应用/ 可/ 通过/ 文中/ 存储/ 层/ 优化/ 更/ 有效/ 地/ 提高/ 性能/ ./ 从图/ 8/ 中/ 可以/ 看出/ ,/ MD/ 经/ 存储/ 层/ 优化/ 后/ 性能/ 较/ 采用/ IBM/ 默认/ 访存/ 方式/ 相比/ 提高/ 29/ %/ ,/ 进一步/ 验证/ 了/ 存储/ 层/ 优化/ 的/ 必要性/ 和/ 有效性/ ./ 综上/ ,/ 自/ 适应/ 编译/ 框架/ 中/ 数据/ 层/ 优化/ 对/ 移植/ 到/ 异构/ 多核/ 架构/ 的/ 应用/ 进行/ 优化/ 时/ ,/ 可/ 有效/ 地/ 提高/ 性能/ ./ 而/ 存储/ 层/ 优化/ 对/ 大规模/ 数据/ 的/ 应用/ 以及/ 存在/ 大量/ 非/ 规则/ 流/ 的/ 应用/ 能/ 进一步/ 地/ 提高/ 性能/ ./ 如图/ 9/ 所示/ ,/ 本文/ 自/ 适应/ 编译/ 优化/ 后/ 程序/ 性能/ 随/ SPE/ 个数/ 增加/ 表现/ 出/ 的/ 平均/ 加速/ 比/ 优于/ 采用/ IBM/ 默认/ 访存/ 方式/ ./ 4.2/ ./ 2/ 系统/ 开销/ 针对/ 同一个/ 应用/ ,/ 其/ 计算/ 核心/ 是/ 确定/ 的/ ,/ 任务/ 层剖分/ 只/ 需/ 执行/ 一次/ ,/ 因此/ 对于/ 大规模/ 应用/ ,/ 系统/ 通过/ 输入/ 较/ 小规模/ 数据/ 进行/ 任务/ 层剖分/ ,/ 将/ 计算/ 核心/ 移植/ 到协/ 处理单元/ ,/ 进一步/ 对/ 该/ 应用/ 进行/ 数据/ 层及/ 存储/ 层/ 优化/ ./ 对于/ 系统/ 中/ 数据/ 层/ 与/ 存储/ 层剖分/ 开销/ 计算/ 如式/ (/ 14/ )/ ./ 设定/ 应用/ 中/ 每个/ 计算/ 核心/ 的/ 执行/ 时间/ 为/ kernelTime/ (/ n/ )/ (/ n/ =/ 1/ ,/ …/ ,/ N/ )/ ,/ 其中/ N/ 为/ 计算/ 核心/ 个数/ ,/ 优化/ 后/ 计算/ 核心/ 的/ 执行/ 时间/ 为/ kernelTime1/ (/ n/ )/ (/ n/ =/ 1/ ,/ …/ ,/ N/ )/ ,/ 每个/ 计算/ 核心/ 的/ 迭代/ 次数/ 为/ iteration/ (/ n/ )/ (/ n/ =/ 1/ ,/ …/ ,/ N/ )/ ,/ 应用/ 中非/ 计算/ 核心/ 的/ 执行/ 时间/ 为/ otherTime/ ,/ 决策/ 所/ 需/ 时间/ 为/ decideTime/ ,/ 数据/ 层/ 与/ 存储/ 层剖分/ 开销/ 时间/ 为/ overhead/ ,/ 应用/ 优化/ 后/ 执行/ 时间/ 为/ runTime/ ./ overhead/ =/ otherTime/ +/ ∑/ N/ 烄/ decideTime/ 烅/ runTime/ =/ otherTime/ +/ ∑/ NkernelTime1/ (/ n/ 烆/ 当/ 问题/ 规模/ 增大/ 时/ ,/ 应用/ 中/ 计算/ 核心/ 的/ 迭代/ 次数/ 将/ 增大/ ,/ 根据/ 式/ (/ 14/ )/ overhead/ // runTime/ 趋势/ 将/ 变小/ ,/ 说明/ 系统/ 中剖分/ 开销/ 随着/ 问题/ 规模/ 增大/ 而/ 减小/ ./ 如图/ 10/ 所示/ ,/ 前/ 2/ 类/ 测试用例/ radixSort/ 与/ k/ -/ means/ 采用/ 小规模/ 数据/ 集/ 测试/ ,/ 其/ 开销/ 时间/ 占/ 总/ 执行/ 时间/ 的/ 21/ %/ ;/ 后/ 4/ 类/ 测试用例/ 采用/ 大规模/ 数据/ 集/ 测试/ ,/ Page9/ 其/ 开销/ 时间/ 占/ 总/ 执行/ 时间/ 的/ 3/ %/ ./ 当/ 应用/ 通过/ 自/ 适应/ 编译/ 生成/ 最终/ 优化/ 代码/ 后/ ,/ 即/ 优化/ 策略/ “/ 固化/ ”/ 在/ 生成/ 代码/ 中/ ,/ 应用/ 在/ 以后/ 的/ 执行/ 过程/ 中则/ 不再/ 需要/ 额外/ 的/ 开销/ ./ 4.2/ ./ 3/ 自/ 适应/ 编译/ 过程/ 测试/ 以/ 分块/ 稀疏/ 矩阵/ LU/ 分解/ 为例/ 进行/ 测试/ ,/ 其中/ 分块/ 大小/ 设为/ 256/ ×/ 256/ ,/ 规模/ 大小/ 分别/ 使用/ 1K/ ×/ 1K/ 、/ 2K/ ×/ 2K/ 、/ 3K/ ×/ 3K/ 及/ 4K/ ×/ 4K/ 单精度/ 浮点数/ ./ 采用/ 本文/ 提出/ 的/ 自/ 适应/ 编译/ 框架/ ,/ 渐进/ 获取/ 应用/ 中/ 的/ 计算/ 核心/ ,/ 数据/ 块/ 信息/ 与/ 访存/ 行为/ 特征/ ,/ 从而/ 对/ 应用/ 进行/ 数据/ 层/ 优化/ 与/ 存储/ 层/ 优化/ ,/ 有效/ 地/ 改善/ 应用/ 计算/ 性能/ ./ 其中/ 函数/ fwd/ (/ )/ 用于/ 对角线/ 子块/ 及/ 与/ 它/ 同行/ 的/ 其他/ 子块/ 进行/ 计算/ ;/ 函数/ bdiv/ (/ )/ 用于/ 对角线/ 子块/ 与/ 它/ 同列/ 的/ 其他/ 子块/ 进行/ 计算/ ;/ 函数/ bmod/ (/ )/ 用于/ 处理/ 上述/ 子块/ 外/ 的/ 其他/ 子块/ ./ 以/ 1K/ ×/ 1K/ 的/ 矩阵/ 规模/ 为例/ 验证/ 自/ 适应/ 编译/ 过程/ ./ 表/ 2/ 所示/ LU/ 分解/ 中/ 的/ 相关/ 函数/ 执行/ 情况/ ,/ 得到/ LU/ 分解/ 的/ 计算/ 核心/ 为/ bmod/ (/ )/ 、/ fwd/ (/ )/ 、/ bdiv/ (/ )/ ./ 函数/ bmodfwdbdiv/ 在/ 任务/ 层剖分/ 得到/ 计算/ 核心/ 的/ 基础/ 上/ ,/ 进一步/ 剖分/ 得到/ 计算/ 核心/ 中/ 参数/ 的/ 访存/ 行为/ 特征/ ./ 由表/ 3/ 中剖分/ 信息/ 与/ 3.5/ ./ 1/ 节中/ 规则/ 1/ 结合/ 可知/ ,/ 函数/ bmod/ (/ )/ 中访存/ 数组/ row/ 和/ inner/ 热点/ 步长/ 是/ 1/ ,/ 为/ 规则/ 顺序/ 流/ ,/ 设定/ 为单/ 缓冲/ 方式/ ,/ 数组/ col/ 热点/ 步长/ 是/ 256/ ,/ 为/ 规则/ 非/ 顺序/ 流/ ,/ 设定/ 为组/ 相联/ ;/ 函数/ fwd/ (/ )/ 中访存/ 数组/ col/ 与/ diag/ 为/ 规则/ 非/ 顺序/ 流/ ,/ 设定/ 其访存/ 方式/ 为组/ 相联/ ;/ 函数/ bdiv/ (/ )/ 中访存/ 数组/ diag/ 与/ row/ 都/ 为/ 规则/ 顺序/ 流/ ,/ 设定/ 其访存/ 方式/ 为单/ 缓冲/ ./ 函数参数/ 热点/ 步长/ 热点/ 步长/ 比例/ // %/ 数据/ 块/ 大小/ // Bytebmodinner199/ ./ 61fwdcol25696/ ./ 12bdivdiag199/ ./ 22/ 根据/ 系统/ 提供/ 的/ 数据/ 层/ 优化/ 策略/ ,/ 进一步/ 对/ 应用/ 进行/ 存储/ 层/ 优化/ ./ 根据/ 规则/ 2/ 与/ 规则/ 3/ 设定/ 单/ 缓冲/ 参数/ 配置/ 为/ (/ set/ =/ 0/ ,/ way/ =/ 0/ ,/ line/ =/ 13/ )/ ,/ 组/ 相联/ 参数/ 配置/ 为/ (/ set/ =/ 6/ ,/ way/ =/ 2/ ,/ line/ =/ 8/ )/ ,/ LU/ 分解/ 的/ 计算/ 性能/ 达到最佳/ ./ 如图/ 11/ 所示/ ,/ LU/ 分解/ 通过/ 数据/ 层/ 优化/ 后/ 较/ 采用/ IBM/ 默认/ 的/ 访存/ 方式/ 性能/ 平均/ 提高/ 42/ %/ ,/ 进一步/ 通过/ 存储/ 层/ 优化/ 后/ 性能/ 平均/ 提高/ 到/ 48/ %/ ./ 图/ 11/ 自/ 适应/ 编译/ 过程/ 中/ 不同/ 阶段/ 性能/ 测试/ 如图/ 12/ 所示/ ,/ LU/ 分/ 解剖/ 分/ 开销/ 占/ 总/ 执行/ 时间/ 比例/ 随/ 问题/ 规模/ 增大/ 而/ 减小/ ./ 当/ 规模/ 增大/ 到/ 4K/ ×/ 4K/ 时/ ,/ 自/ 适应/ 编译/ 过程/ 中/ 开销/ 时间/ 所/ 占/ 总/ 执行/ 时间/ 的/ 比例/ 降为/ 9/ %/ ./ 当/ 生成/ 最终/ 优化/ 代码/ 后/ ,/ 应用/ 在/ 执行/ 过程/ 中则/ 不再/ 需要/ 额外/ 的/ 开销/ ./ 图/ 12/ 问题/ 规模/ 对/ 自/ 适应/ 编译/ 过程/ 中/ 系统/ 开销/ 的/ 影响/ 附录/ A/ 中/ 给出/ 了/ 一段/ 计算/ 核心/ 源代码/ 与/ 自/ 适应/ 编译/ 后/ 生成/ 的/ 最终/ 优化/ 代码/ ./ 4.2/ ./ 4/ 不同/ 问题/ 规模/ 性能/ 对比/ 测试/ 针对/ Cell/ 平台/ 的/ 编程/ 模型/ CellSs/ 与/ ALF/ 都/ 要求/ 计算/ 核心/ 的/ 数据/ 大小/ 完全/ 容纳/ 在/ SPE/ 的/ LS/ 中/ ,/ 因此/ 当访存/ 数据量/ 增大/ 到/ 一定/ 程度/ ,/ 即/ 超过/ SPE/ 中/ LS/ 容量/ 时/ ,/ CellSs/ 与/ ALF/ 编程/ 模型/ 已/ 不再/ 适用/ ./ 对/ 测试用例/ BMM/ 分别/ 使用/ CellSs/ 、/ ALF/ 方法/ 与/ 本文/ 方法/ 进行/ 实验/ 对比/ ./ 对/ 测试用例/ BMM/ ,/ 设定/ 矩阵/ 大小/ 为/ 1024/ ×/ 1024/ ,/ 分块/ 子/ 矩阵/ 大小/ 为/ 32/ ×/ 32/ ,/ 矩阵/ 分块/ 可/ 完全/ 容纳/ 在/ LS/ 中/ ,/ 经过/ 自/ 适应/ 编译/ 后/ BMM/ 只/ 需/ 进行/ 数据/ 层/ 优化/ ./ 如图/ 13/ 所示/ ,/ 本文/ 系统/ 的/ 性能/ 较/ CellSs/ 与/ ALF/ 分别/ 提高/ 57/ %/ 和/ 36/ %/ ./ 当/ 计算/ 核心/ 访存/ 数据量/ 超过/ SPE/ 中/ LS/ 容量/ 时/ ,/ CellSs/ 与/ ALF/ 编程/ 模型/ 已/ 不再/ 适用/ ,/ 测试/ 中/ 与/ IBM/ 提供/ 的/ CBESDK/ 方法/ 进行/ 对比/ ./ Page10/ 如图/ 14/ 中/ ,/ 设定/ BMM/ 子/ 矩阵/ 大小/ 为/ 256/ ×/ 256/ ,/ 规模/ 大小/ 分别/ 设定/ 为/ 1K/ ×/ 1K/ 、/ 2K/ ×/ 2K/ 、/ 3K/ ×/ 3K/ 及/ 4K/ ×/ 4K/ ./ 此时/ 分块/ 大小/ 为/ 256/ ×/ 256/ ×/ 4B/ =/ 256KB/ ,/ 超出/ LS/ 容量/ ./ n/ -/ body/ 问题/ 描述/ 了/ 具有/ 相互/ 引力/ 作用/ 的/ n/ 个/ 粒子/ 运行/ 轨迹/ 的/ 计算/ 过程/ ,/ n/ -/ body/ 问题/ 最/ 直接/ 的/ 算法/ 是/ PP/ 算法/ ./ 本文/ 采用/ PP/ 算法/ 对/ n/ 为/ 8192/ 、/ 16384/ 、/ 32768/ 及/ 65536/ 个/ 粒子/ 进行/ 测试/ ./ 当/ n/ =/ 8192/ 时/ ,/ 需要/ 320KB/ 的/ 存储空间/ ,/ 已/ 超过/ LS/ 的/ 容量/ ./ 如图/ 14/ 所示/ ,/ BMM/ 及/ n/ -/ body/ 经过/ 系统/ 数据/ 层/ 优化/ 后/ 性能/ 较/ IBM/ 默认/ 设定/ 的/ 访存/ 方式/ 平均/ 提高/ 13/ %/ ,/ 进一步/ 根据/ 规则/ 2/ 与/ 规则/ 3/ 进行/ 存储/ 层/ 优化/ 后/ ,/ 性能/ 较/ IBM/ 默认/ 的/ 访存/ 方式/ 平均/ 提高/ 到/ 25/ %/ ./ 优化/ 后/ 的/ 规则/ 应用/ 性能/ 提高/ 比例/ 随/ 问题/ 规模/ 变化/ 的/ 趋势/ 是/ 稳定/ 的/ ./ 针对/ 复杂/ 非/ 规则/ 应用/ ,/ 由于/ 程序/ 中有/ 很多/ 非/ 规则/ 流/ ,/ 访存/ 空间/ 不/ 确定/ ,/ CellSs/ 与/ ALF/ 无法/ 直接/ 支持/ 此类/ 应用/ ./ 通过/ 使用/ 本文/ 中自/ 适应/ 编译/ 框架/ 提供/ 的/ 存储/ 层/ 分析/ ,/ 可/ 对/ 程序/ 进一步/ 优化/ ./ 以/ 分子/ 动力学/ Gromacs/ 的/ kernel010/ 程序/ (/ MD/ )/ 为例/ ,/ 其中/ 循环/ 执行/ 步数/ 设定/ 为/ 1000/ 步/ ,/ 粒子/ 数/ 分别/ 设定/ 为/ 8000/ (/ 203/ )/ ,/ 15625/ (/ 253/ )/ ,/ 27000/ (/ 303/ )/ ./ 如图/ 15/ 所示/ ,/ 通过/ 本文/ 中自/ 适应/ 编译/ 优化/ 后/ 应用/ 性能/ 较/ IBM/ 提供/ 的/ CBESDK/ 访存/ 方式/ 提高/ 29/ %/ ./ 优化/ 后/ 的/ 非/ 规则/ 应用/ 性能/ 提高/ 比例/ 随/ 问题/ 规模/ 变化/ 的/ 趋势/ 是/ 稳定/ 的/ ./ 图/ 15/ 不同/ 问题/ 规模/ 的/ 非/ 规则/ 应用/ 性能/ 测试/ 5/ 结论/ 与/ 后续/ 工作/ 本文/ 提出/ 了/ 一种/ 面向/ 异构/ 多核/ 架构/ 的/ 自/ 适应/ 编译/ 框架/ ./ 该/ 框架/ 通过/ 源到/ 源/ 编译/ 技术/ 解决/ 传统/ 并行/ 编程/ 模型/ 应用/ 向/ 异构/ 多核/ 架构/ 的/ 映射/ 问题/ ,/ 并/ 利用/ 动态/ 剖分/ 信息/ ,/ 自/ 适应/ 地/ 调整/ 插桩/ 并/ 配置/ 优化/ 策略/ ,/ 形成/ 迭代/ 式/ 的/ 自动/ 优化/ 过程/ ,/ 将/ 软硬件/ 映射/ 机制/ 与/ 优化/ 策略/ 相结合/ ,/ 有效/ 解决/ 了/ 异构/ 多核/ 架构/ 的/ 移植/ 问题/ 并/ 提高/ 了/ 应用/ 的/ 整体/ 性能/ ./ 实验/ 结果表明/ ,/ 本文/ 基于/ Cell/ 架构/ 实现/ 的/ 原型/ 系统/ ,/ 在/ 不/ 增加/ 程序员/ 负担/ 的/ 前提/ 下/ ,/ 应用/ 性能/ 相比/ 同类/ 技术/ 有/ 显著/ 的/ 提高/ ./ 我们/ 下/ 一步/ 工作/ 将/ 原型/ 系统/ 扩展/ 到/ CPU/ +/ GPU/ 以及/ CPU/ +/ MIC/ 异构/ 架构/ ,/ 基于/ 这/ 两种/ 异构/ 架构/ 已/ 做/ 了/ 基本/ 的/ 研究/ ,/ 包含/ 底层/ 的/ 优化/ 方法/ 等/ ./ 

